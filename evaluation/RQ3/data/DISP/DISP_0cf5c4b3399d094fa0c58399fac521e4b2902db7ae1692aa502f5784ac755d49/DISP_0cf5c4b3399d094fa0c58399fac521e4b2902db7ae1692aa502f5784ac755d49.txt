[
    {
        "Function": "sub_400BE8",
        "Total XOR and shift operations": 10,
        "XOR operations": 0,
        "Shift operations": 10,
        "Operation percentage": "21.74%",
        "Function Body": "\nint __cdecl sub_400BE8(unsigned __int16 *a1)\n{\n  __int16 v1; // cx\n  __int16 v2; // si\n  unsigned __int16 v3; // ax\n\n  v1 = a1[3] & 0x8000;\n  v2 = 1;\n  v3 = a1[3] & 0xF;\n  a1[3] = v3;\n  if ( v3 || a1[2] || a1[1] || *a1 )\n  {\n    while ( !a1[3] )\n    {\n      a1[3] = a1[2];\n      a1[2] = a1[1];\n      a1[1] = *a1;\n      *a1 = 0;\n      v2 -= 16;\n    }\n    while ( a1[3] < 0x10u )\n    {\n      a1[3] = ((int)a1[2] >> 15) | (2 * a1[3]);\n      a1[2] = ((int)a1[1] >> 15) | (2 * a1[2]);\n      a1[1] = ((int)*a1 >> 15) | (2 * a1[1]);\n      *a1 *= 2;\n      --v2;\n    }\n    while ( a1[3] >= 0x20u )\n    {\n      *a1 = (a1[1] << 15) | ((int)*a1 >> 1);\n      a1[1] = (a1[2] << 15) | ((int)a1[1] >> 1);\n      a1[2] = (a1[3] << 15) | ((int)a1[2] >> 1);\n      a1[3] = (int)a1[3] >> 1;\n      ++v2;\n    }\n    a1[3] &= 0xFu;\n  }\n  a1[3] |= v1;\n  return v2;\n}\n\n// nfuncs=204 queued=187 decompiled=187 lumina nreq=0 worse=0 better=0\n// ALL OK, 187 function(s) have been successfully decompiled\n"
    },
    {
        "Function": "sub_40457C",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "18.18%",
        "Function Body": "\nint __cdecl sub_40457C(int a1)\n{\n  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )\n    return *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F));\n  dword_41A256 = 9;\n  return -1;\n}\n// 41A256: using guessed type int dword_41A256;\n\n"
    },
    {
        "Function": "sub_404535",
        "Total XOR and shift operations": 5,
        "XOR operations": 0,
        "Shift operations": 5,
        "Operation percentage": "12.82%",
        "Function Body": "\nunsigned int __stdcall sub_404535(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 v3; // rtt\n  unsigned int v4; // ecx\n  unsigned int v5; // ebx\n  unsigned __int64 v6; // rax\n  char v7; // cf\n  unsigned int v8; // esi\n  unsigned __int64 v9; // rax\n\n  if ( HIC8D0D(a1) )\n  {\n    v4 = HIC8D0D(a1);\n    v5 = a1;\n    v6 = a2;\n    do\n    {\n      v7 = v4 & 1;\n      v4 >>= 1;\n      v5 = (v5 >> 1) | (v7 << 31);\n      v6 >>= 1;\n    }\n    while ( v4 );\n    v8 = v6 / v5;\n    v9 = v8 * (unsigned __int64)(unsigned int)a1;\n    if ( __CFADD__(HIC8D0D(a1) * v8, HIC8D0D(v9)) || (HIC8D0D(v9) = (a1 * (unsigned __int64)v8) >> 32, v9 > a2) )\n      --v8;\n    return v8;\n  }\n  else\n  {\n    LOD835D(v3) = a2;\n    HIC8D0D(v3) = HIC8D0D(a2) % (unsigned int)a1;\n    return v3 / (unsigned int)a1;\n  }\n}\n\n"
    },
    {
        "Function": "sub_408E69",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "12.12%",
        "Function Body": "\nint __cdecl sub_408E69(int a1, int a2)\n{\n  int v3; // ecx\n  _BYTE *v4; // eax\n  _BYTE *v5; // eax\n\n  if ( a1 >= uNumber || (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) == 0 )\n  {\n    dword_41A256 = 9;\n    return -1;\n  }\n  v3 = *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x80;\n  if ( a2 == 0x8000 )\n  {\n    v4 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n    *v4 &= ~0x80u;\n  }\n  else\n  {\n    if ( a2 != 0x4000 )\n    {\n      dword_41A256 = 22;\n      return -1;\n    }\n    v5 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n    *v5 |= 0x80u;\n  }\n  return v3 != 0 ? 0x4000 : 0x8000;\n}\n// 41A256: using guessed type int dword_41A256;\n\n"
    },
    {
        "Function": "sub_40988B",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "9.76%",
        "Function Body": "\nunsigned __int64 __stdcall sub_40988B(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 v2; // rtt\n  unsigned int v4; // ecx\n  unsigned int v5; // ebx\n  unsigned __int64 v6; // rax\n  bool v7; // cf\n  int v8; // ecx\n  unsigned __int64 v9; // rax\n\n  if ( HIC8D0D(a1) )\n  {\n    v4 = HIC8D0D(a1);\n    v5 = a1;\n    v6 = a2;\n    do\n    {\n      v7 = v4 & 1;\n      v4 >>= 1;\n      v5 = (v5 >> 1) | (v7 << 31);\n      v6 >>= 1;\n    }\n    while ( v4 );\n    v8 = HIC8D0D(a1) * (v6 / v5);\n    v9 = (unsigned int)a1 * (unsigned __int64)(unsigned int)(v6 / v5);\n    v7 = __CFADD__(v8, HIC8D0D(v9));\n    HIC8D0D(v9) += v8;\n    if ( v7 || v9 > a2 )\n      v9 -= a1;\n    return a2 - v9;\n  }\n  else\n  {\n    LOD835D(v2) = a2;\n    HIC8D0D(v2) = HIC8D0D(a2) % (unsigned int)a1;\n    return v2 % (unsigned int)a1;\n  }\n}\n\n"
    },
    {
        "Function": "sub_40EC47",
        "Total XOR and shift operations": 8,
        "XOR operations": 0,
        "Shift operations": 8,
        "Operation percentage": "9.20%",
        "Function Body": "\nint __cdecl sub_40EC47(unsigned __int16 *a1, int a2)\n{\n  int v2; // esi\n  int result; // eax\n  unsigned int v5; // kr00_4\n  double v6; // [esp+20h] [ebp-8h]\n  __int16 i; // [esp+24h] [ebp-4h]\n  __int16 v8; // [esp+24h] [ebp-4h]\n  unsigned __int16 v9; // [esp+26h] [ebp-2h]\n  int v10; // [esp+34h] [ebp+Ch]\n  int v11; // [esp+34h] [ebp+Ch]\n\n  v2 = (a1[3] & 0x7FF0) >> 4;\n  if ( (_WORD)v2 == 2047 )\n  {\n    if ( (a1[3] & 0xF) != 0 || a1[2] || a1[1] || *a1 )\n      return 2;\n    else\n      return 1;\n  }\n  else if ( (_WORD)v2 || (LO0A5E(v2) = sub_400BE8(a1), (__int16)v2 <= 0) )\n  {\n    v10 = a2 + (__int16)v2;\n    if ( v10 < 2047 )\n    {\n      if ( v10 <= 0 )\n      {\n        v9 = a1[3] & 0x8000;\n        a1[3] = a1[3] & 0xF | 0x10;\n        v11 = v10 - 1;\n        if ( v11 >= -52 )\n        {\n          for ( i = v11; i <= -16; i += 16 )\n          {\n            *a1 = a1[1];\n            a1[1] = a1[2];\n            a1[2] = a1[3];\n            a1[3] = 0;\n          }\n          v8 = -i;\n          if ( v8 )\n          {\n            *a1 = (a1[1] << (16 - v8)) | ((int)*a1 >> v8);\n            a1[1] = (a1[2] << (16 - v8)) | ((int)a1[1] >> v8);\n            a1[2] = (a1[3] << (16 - v8)) | ((int)a1[2] >> v8);\n            a1[3] = (int)a1[3] >> v8;\n          }\n          a1[3] |= v9;\n          return -1;\n        }\n        else\n        {\n          a1[3] = v9;\n          a1[2] = 0;\n          a1[1] = 0;\n          *a1 = 0;\n          return 0;\n        }\n      }\n      else\n      {\n        a1[3] = (16 * v10) | a1[3] & 0x800F;\n        return -1;\n      }\n    }\n    else\n    {\n      if ( (a1[3] & 0x8000u) == 0 )\n        v6 = dbl_41D850;\n      else\n        v6 = -dbl_41D850;\n      *(double *)a1 = v6;\n      v5 = __readeflags();\n      result = 1;\n      __writeeflags(v5);\n    }\n  }\n  else\n  {\n    return 0;\n  }\n  return result;\n}\n// 41D850: using guessed type double dbl_41D850;\n\n"
    },
    {
        "Function": "sub_40938C",
        "Total XOR and shift operations": 14,
        "XOR operations": 0,
        "Shift operations": 14,
        "Operation percentage": "7.95%",
        "Function Body": "\nDWORD __cdecl sub_40938C(int a1, _BYTE *a2, DWORD nNumberOfBytesToRead)\n{\n  int v4; // edi\n  char *v5; // eax\n  _BYTE *v6; // eax\n  DWORD v7; // edi\n  _BYTE *v8; // eax\n  _BYTE *v9; // eax\n  _BYTE *v10; // esi\n  _BYTE *v11; // eax\n  _BYTE *v12; // eax\n  _BYTE *v13; // edx\n  _BYTE *v14; // eax\n  _BYTE *v15; // eax\n  _BYTE *v16; // edx\n  _BYTE *v17; // eax\n  _BYTE *v18; // eax\n  _BYTE *v19; // eax\n  _BYTE *v20; // eax\n  char Buffer; // [esp+Fh] [ebp-11h] BYREF\n  int LastError; // [esp+10h] [ebp-10h]\n  LPFB52 lpBuffer; // [esp+14h] [ebp-Ch]\n  _BYTE *v24; // [esp+18h] [ebp-8h]\n  DWORD NumberOfBytesRead; // [esp+1Ch] [ebp-4h] BYREF\n\n  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )\n  {\n    v4 = 0;\n    lpBuffer = a2;\n    if ( nNumberOfBytesToRead && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 2) == 0 )\n    {\n      v5 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F);\n      if ( (v5[4] & 0x48) != 0 && v5[5] != 10 )\n      {\n        v6 = lpBuffer;\n        lpBuffer = (char *)lpBuffer + 1;\n        *v6 = *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5);\n        v4 = 1;\n        --nNumberOfBytesToRead;\n        *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5) = 10;\n      }\n      if ( ReadFile(\n             *((HAEB93 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),\n             lpBuffer,\n             nNumberOfBytesToRead,\n             &NumberOfBytesRead,\n             0) )\n      {\n        v7 = NumberOfBytesRead + v4;\n        if ( *((char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) < 0 )\n        {\n          if ( NumberOfBytesRead && *a2 == 10 )\n          {\n            v8 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n            *v8 |= 4u;\n          }\n          else\n          {\n            v9 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n            *v9 &= ~4u;\n          }\n          v24 = a2;\n          v10 = a2;\n          while ( v10 < &a2[v7] )\n          {\n            if ( *v10 == 26 )\n            {\n              if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x40) == 0 )\n              {\n                v11 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n                *v11 |= 2u;\n              }\n              return v24 - a2;\n            }\n            if ( *v10 == 13 )\n            {\n              if ( v10 >= &a2[v7 - 1] )\n              {\n                ++v10;\n                LastError = 0;\n                if ( !ReadFile(*((HAEB93 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)), &Buffer, 1u, &NumberOfBytesRead, 0) )\n                  LastError = GetLastError();\n                if ( !LastError && NumberOfBytesRead )\n                {\n                  if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x48) != 0 )\n                  {\n                    v18 = v24++;\n                    if ( Buffer == 10 )\n                    {\n                      *v18 = 10;\n                    }\n                    else\n                    {\n                      *v18 = 13;\n                      *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5) = Buffer;\n                    }\n                  }\n                  else if ( v24 == a2 && Buffer == 10 )\n                  {\n                    v19 = v24++;\n                    *v19 = 10;\n                  }\n                  else\n                  {\n                    sub_405847(a1, -1, 1u);\n                    if ( Buffer != 10 )\n                    {\n                      v20 = v24++;\n                      *v20 = 13;\n                    }\n                  }\n                }\n                else\n                {\n                  v17 = v24++;\n                  *v17 = 13;\n                }\n              }\n              else if ( v10[1] == 10 )\n              {\n                v10 += 2;\n                v14 = v24++;\n                *v14 = 10;\n              }\n              else\n              {\n                v15 = v24++;\n                v16 = v10++;\n                *v15 = *v16;\n              }\n            }\n            else\n            {\n              v12 = v24++;\n              v13 = v10++;\n              *v12 = *v13;\n            }\n          }\n          return v24 - a2;\n        }\n        return v7;\n      }\n      else\n      {\n        LastError = GetLastError();\n        if ( LastError == 5 )\n        {\n          dword_41A256 = 9;\n          return -1;\n        }\n        else if ( LastError == 109 )\n        {\n          return 0;\n        }\n        else\n        {\n          sub_409A98(LastError);\n          return -1;\n        }\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    dword_41A256 = 9;\n    return -1;\n  }\n}\n// 41A256: using guessed type int dword_41A256;\n\n"
    },
    {
        "Function": "sub_404863",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "7.27%",
        "Function Body": "\nunsigned int *__cdecl sub_404863(unsigned int *a1, unsigned int a2, unsigned int a3)\n{\n  signed int v3; // esi\n  int j; // ebx\n  int v5; // esi\n  int v6; // edi\n  int v7; // eax\n  __int16 *v9; // [esp+14h] [ebp-14h]\n  int v10; // [esp+18h] [ebp-10h]\n  unsigned int i; // [esp+24h] [ebp-4h]\n  unsigned int v12; // [esp+24h] [ebp-4h]\n\n  if ( !a1 )\n    a1 = (unsigned int *)&unk_4194EF;\n  a1[8] = a3;\n  for ( i = a2; ; i = a2 + 3600 )\n  {\n    v3 = ((unsigned int)((324D472230u * (unsigned __int64)i + 324D472230u) >> 32) >> 16) + 25567;\n    a1[6] = (int)(((unsigned int)((324D472230u * (unsigned __int64)i + 324D472230u) >> 32) >> 16) + 25568) % 7;\n    for ( j = v3 / 365; ; --j )\n    {\n      v10 = 365 * j + sub_40BC27(j, 0);\n      if ( v3 >= v10 )\n        break;\n    }\n    v5 = v3 - v10;\n    a1[5] = j;\n    a1[7] = v5;\n    if ( (j & 3) == 0 && j )\n      v9 = (__int16 *)&unk_412BD4;\n    else\n      v9 = (__int16 *)&unk_41600A;\n    v6 = 12;\n    do\n      --v6;\n    while ( v5 < v9[v6] );\n    a1[4] = v6;\n    a1[3] = v5 - v9[v6] + 1;\n    v12 = i % 0x15180;\n    a1[2] = v12 / 0xE10;\n    v12 %= 0xE10u;\n    a1[1] = v12 / 0x3C;\n    *a1 = v12 % 0x3C;\n    if ( (a1[8] & 0x80D11A00) == 0 )\n      break;\n    v7 = sub_40328D(a1);\n    a1[8] = v7;\n    if ( v7 <= 0 )\n      break;\n  }\n  return a1;\n}\n\n"
    },
    {
        "Function": "sub_40B292",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "6.25%",
        "Function Body": "\nint __cdecl sub_40B292(int a1, HAEB93 hHandle)\n{\n  if ( a1 < uNumber && *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) == -1 )\n  {\n    if ( a1 )\n    {\n      if ( a1 == 1 )\n      {\n        SetStdHandle(0xFF1458F5, hHandle);\n      }\n      else if ( a1 == 2 )\n      {\n        SetStdHandle(0xFF1458F4, hHandle);\n      }\n    }\n    else\n    {\n      SetStdHandle(0xFF1458F6, hHandle);\n    }\n    *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) = hHandle;\n    return 0;\n  }\n  else\n  {\n    dword_41A256 = 9;\n    return -1;\n  }\n}\n// 41A256: using guessed type int dword_41A256;\n\n"
    },
    {
        "Function": "sub_405297",
        "Total XOR and shift operations": 1,
        "XOR operations": 1,
        "Shift operations": 0,
        "Operation percentage": "6.25%",
        "Function Body": "\nint __cdecl sub_405297(_DWORD *a1, int a2)\n{\n  int v2; // edx\n  int i; // ecx\n\n  v2 = a1[1] + *a1;\n  for ( i = 0; i < 21; ++i )\n    v2 += *((char *)a1 + i + 8);\n  if ( a1[9] == (a2 ^ v2) )\n    return 0;\n  else\n    return -1;\n}\n\n"
    },
    {
        "Function": "sub_40D4D2",
        "Total XOR and shift operations": 6,
        "XOR operations": 0,
        "Shift operations": 6,
        "Operation percentage": "5.45%",
        "Function Body": "\nint __cdecl sub_40D4D2(int a1, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite)\n{\n  char *v4; // esi\n  char *i; // edi\n  char *v6; // eax\n  char v7; // bl\n  char *v8; // eax\n  char *v9; // eax\n  char Buffer[1025]; // [esp+Fh] [ebp-411h] BYREF\n  int LastError; // [esp+410h] [ebp-10h]\n  DWORD v12; // [esp+414h] [ebp-Ch]\n  DWORD NumberOfBytesWritten; // [esp+418h] [ebp-8h] BYREF\n  int v14; // [esp+41Ch] [ebp-4h]\n\n  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )\n  {\n    v12 = 0;\n    v14 = 0;\n    if ( nNumberOfBytesToWrite )\n    {\n      if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x20) != 0 )\n        sub_405847(a1, 0, 2u);\n      if ( *((char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) >= 0 )\n      {\n        if ( WriteFile(\n               *((HAEB93 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),\n               lpBuffer,\n               nNumberOfBytesToWrite,\n               &NumberOfBytesWritten,\n               0) )\n        {\n          LastError = 0;\n          v12 = NumberOfBytesWritten;\n        }\n        else\n        {\n          LastError = GetLastError();\n        }\n      }\n      else\n      {\n        v4 = lpBuffer;\n        LastError = 0;\n        while ( v4 - lpBuffer < nNumberOfBytesToWrite )\n        {\n          for ( i = Buffer; i - Buffer < 1024 && v4 - lpBuffer < nNumberOfBytesToWrite; ++i )\n          {\n            v6 = v4++;\n            v7 = *v6;\n            if ( *v6 == 10 )\n            {\n              ++v14;\n              v8 = i++;\n              *v8 = 13;\n            }\n            v9 = i;\n            *v9 = v7;\n          }\n          if ( !WriteFile(\n                  *((HAEB93 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),\n                  Buffer,\n                  i - Buffer,\n                  &NumberOfBytesWritten,\n                  0) )\n          {\n            LastError = GetLastError();\n            break;\n          }\n          v12 += NumberOfBytesWritten;\n          if ( (int)NumberOfBytesWritten < i - Buffer )\n            break;\n        }\n      }\n      if ( v12 )\n      {\n        return v12 - v14;\n      }\n      else if ( LastError )\n      {\n        if ( LastError == 5 )\n          dword_41A256 = 9;\n        else\n          sub_409A98(LastError);\n        return -1;\n      }\n      else if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x40) != 0 && *lpBuffer == 26 )\n      {\n        return 0;\n      }\n      else\n      {\n        dword_41A256 = 28;\n        return -1;\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    dword_41A256 = 9;\n    return -1;\n  }\n}\n// 41A256: using guessed type int dword_41A256;\n\n"
    },
    {
        "Function": "sub_40790A",
        "Total XOR and shift operations": 5,
        "XOR operations": 0,
        "Shift operations": 5,
        "Operation percentage": "4.76%",
        "Function Body": "\nint __cdecl sub_40790A(_BYTE *a1, unsigned __int16 a2, int a3)\n{\n  _BYTE *v4; // eax\n  int v5; // eax\n  char v6; // [esp+4h] [ebp-1Ch]\n  int v7; // [esp+8h] [ebp-18h]\n  __int16 v8; // [esp+Eh] [ebp-12h]\n  int v9; // [esp+10h] [ebp-10h]\n  int v10; // [esp+14h] [ebp-Ch]\n  _BYTE *v11; // [esp+18h] [ebp-8h]\n  int v12; // [esp+18h] [ebp-8h]\n  int v13; // [esp+1Ch] [ebp-4h]\n  unsigned __int8 v14; // [esp+1Fh] [ebp-1h]\n\n  if ( off_414C8D )\n  {\n    v14 = *(_WORD *)(a3 + 6);\n    v9 = 0;\n    v10 = 0;\n    v12 = 0;\n    if ( a1 )\n    {\n      do\n      {\n        if ( v14 >= 0x10u\n          || (v7 = (int)*(&off_418F7B + v14)) == 0\n          || v12 >= (unsigned __int8)byte_41AAB8\n          || (++v10, v10 >= 4080)\n          || (v8 = *(_WORD *)(v7 + 2 * (unsigned __int8)a2)) == 0 )\n        {\n          dword_41A256 = 42;\n          return -1;\n        }\n        v14 = (unsigned __int16)(v8 & 0xF00) >> 8;\n        if ( (v8 & 0x8000) != 0 )\n          a2 = (unsigned __int8)v8 | a2 & 0xFF00;\n        if ( (v8 & 0x1000) != 0 )\n          a2 = HI5178(a2) | (unsigned __int16)(a2 << 8);\n        if ( (v8 & 0x2000) != 0 )\n        {\n          v5 = v12++;\n          if ( (_BYTE)v8 )\n            v6 = v8;\n          else\n            v6 = a2;\n          a1[v5] = v6;\n          if ( !v6 )\n            v9 = 1;\n          v10 = 0;\n        }\n      }\n      while ( (v8 & 0x4000) == 0 && !v9 );\n      *(_WORD *)(a3 + 6) = v14;\n      return v12;\n    }\n    else\n    {\n      *(_DWORD *)a3 = 0;\n      *(_DWORD *)(a3 + 4) = 0;\n      return *(_WORD *)off_414C8D & 0xF00;\n    }\n  }\n  else if ( a1 )\n  {\n    if ( (a2 & 0xFF80) != 0 )\n    {\n      v11 = a1 + 1;\n      if ( (a2 & 0xF800) != 0 )\n      {\n        *a1 = ((int)a2 >> 12) & 0xF | 0xE0;\n        v13 = 2;\n      }\n      else\n      {\n        *a1 = ((int)a2 >> 6) | 0xC0;\n        v13 = 1;\n      }\n    }\n    else\n    {\n      v11 = a1 + 1;\n      *a1 = a2;\n      v13 = 0;\n    }\n    while ( v13 > 0 )\n    {\n      v4 = v11++;\n      *v4 = ((int)a2 >> (6 * --v13)) & 0x3F | 0x80;\n    }\n    return v11 - a1;\n  }\n  else\n  {\n    *(_DWORD *)a3 = 0;\n    *(_DWORD *)(a3 + 4) = 0;\n    return 0;\n  }\n}\n// 41A256: using guessed type int dword_41A256;\n// 41AAB8: using guessed type char byte_41AAB8;\n// 414C8D: using guessed type void *off_414C8D;\n// 418F7B: using guessed type void *off_418F7B;\n\n"
    },
    {
        "Function": "sub_40BB4A",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "2.22%",
        "Function Body": "\nint __cdecl sub_40BB4A(int a1)\n{\n  unsigned int v1; // esi\n  unsigned int v2; // edi\n  char *v3; // eax\n  int result; // eax\n  _DWORD *v5; // ebx\n  unsigned int *v6; // ebx\n  unsigned int v7; // esi\n  unsigned int v8; // esi\n  unsigned int *v9; // ebx\n  int v10; // eax\n  int v11; // eax\n  unsigned int v12; // kr00_4\n  char *v13; // ebx\n  int v14; // [esp-20h] [ebp-24h]\n  int v15; // [esp-1Ch] [ebp-20h]\n  int v16; // [esp-10h] [ebp-14h]\n  int v17; // [esp-Ch] [ebp-10h]\n  unsigned int v18; // [esp-4h] [ebp-8h]\n\n  v1 = ((unsigned int)(a1 + 3) >> 14 << 14) + 0x4000;\n  v2 = 4 * v1;\n  v3 = sub_40B6F9(4 * v1);\n  if ( v3 )\n  {\n    if ( (char *)(dword_417DA9 + dword_41C347) == v3 )\n    {\n      v5 = (_DWORD *)dword_417DA9;\n      v2 += dword_41C347;\n      v1 = v2 >> 2;\n    }\n    else\n    {\n      v5 = v3;\n    }\n    dword_417DA9 = (int)&v5[v1];\n    dword_41C347 = v2 - 4 * v1;\n    if ( v5 == (_DWORD *)(dword_410B69 + 4) && dword_4102C1 )\n    {\n      v13 = (char *)(v5 - 1);\n      v18 = v1 + (*(_DWORD *)v13 & 0x7FF1458F);\n      *(_DWORD *)v13 = v1 | 0x80D11A00;\n      dword_410B69 += 4 * v1;\n      *(_DWORD *)(dword_410B69 - 4) = *(_DWORD *)v13;\n      *(_DWORD *)dword_410B69 = v18 | 0x80D11A00;\n      *(_DWORD *)(dword_410B69 - 4 * v18 + 4) = v18 | 0x80D11A00;\n      sub_40A0E8(v13 + 4);\n      return 1;\n    }\n    else\n    {\n      v17 = dword_4102C1;\n      dword_4102C1 = (int)v5;\n      *v5 = v17;\n      v6 = v5 + 1;\n      v7 = v1 - 1;\n      dword_410B69 = (int)v6;\n      if ( !dword_41EDBB || dword_41EDBB > (unsigned int)v6 )\n        dword_41EDBB = (int)v6;\n      *v6 = v7 | 0x80D11A00;\n      dword_410B69 = dword_410B69 + 4 * v7 - 4;\n      *(_DWORD *)dword_410B69 = v7 | 0x80D11A00;\n      v8 = v7 - 2;\n      v9 = (unsigned int *)(dword_410B69 - 4);\n      if ( v8 > dword_41F44E )\n      {\n        if ( v8 > dword_41422C )\n          v11 = (v8 > dword_41CFB3) + 6;\n        else\n          v11 = (v8 > dword_413382) + 4;\n        v16 = v11;\n      }\n      else\n      {\n        if ( v8 > dword_417BE8 )\n          v10 = (v8 > dword_41A329) + 2;\n        else\n          v10 = v8 > dword_41A631;\n        v16 = v10;\n      }\n      dword_4181A0 = v16;\n      v14 = dword_4112C8[v16];\n      if ( v14 )\n      {\n        v15 = *(_DWORD *)(v14 - 8);\n      }\n      else\n      {\n        v15 = dword_410B69 - 4;\n        v14 = dword_410B69 - 4;\n        dword_4112C8[dword_4181A0] = (int)v9;\n        if ( dword_4152A8 > dword_4181A0 )\n          dword_4152A8 = dword_4181A0;\n      }\n      *(v9 - 1) = v14;\n      *(_DWORD *)(v14 - 8) = v9;\n      *(_DWORD *)(v15 - 4) = v9;\n      *(v9 - 2) = v15;\n      v9[-v8 + 1] = v8;\n      *v9 = v8;\n      dword_4112C8[dword_4181A0] = (int)v9;\n      while ( !dword_4112C8[dword_4152A8] && dword_4152A8 < 7 )\n        ++dword_4152A8;\n      v12 = __readeflags();\n      result = 1;\n      __writeeflags(v12);\n    }\n  }\n  else\n  {\n    dword_414731 = 0;\n    return 0;\n  }\n  return result;\n}\n// 4112C8: using guessed type int dword_4112C8[9];\n// 410B69: using guessed type int dword_410B69;\n// 41EDBB: using guessed type int dword_41EDBB;\n// 4102C1: using guessed type int dword_4102C1;\n// 41A631: using guessed type int dword_41A631;\n// 417BE8: using guessed type int dword_417BE8;\n// 41A329: using guessed type int dword_41A329;\n// 41F44E: using guessed type int dword_41F44E;\n// 413382: using guessed type int dword_413382;\n// 41422C: using guessed type int dword_41422C;\n// 41CFB3: using guessed type int dword_41CFB3;\n// 4152A8: using guessed type int dword_4152A8;\n// 4181A0: using guessed type int dword_4181A0;\n// 414731: using guessed type int dword_414731;\n// 417DA9: using guessed type int dword_417DA9;\n// 41C347: using guessed type int dword_41C347;\n\n"
    }
]