[
    {
        "Function": "sub_4B0C1E",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "42.86%",
        "Function Body": "\nint __fastcall sub_4B0C1E(int a1, int a2)\n{\n  return (HI3B6F(a2) << 24) + (BYTE2(a2) << 16) + (BYTE1(a2) << 8) + (unsigned __int8)a2;\n}\n\n"
    },
    {
        "Function": "sub_4C36DF",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "42.86%",
        "Function Body": "\nint __fastcall sub_4C36DF(int a1, int a2)\n{\n  return (HI3B6F(a2) << 24) + (BYTE2(a2) << 16) + (BYTE1(a2) << 8) + (unsigned __int8)a2;\n}\n\n"
    },
    {
        "Function": "sub_4CF95E",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "42.86%",
        "Function Body": "\nint __fastcall sub_4CF95E(int a1, int a2)\n{\n  return (HI3B6F(a2) << 24) + (BYTE2(a2) << 16) + (BYTE1(a2) << 8) + (unsigned __int8)a2;\n}\n\n"
    },
    {
        "Function": "sub_4CE416",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "42.86%",
        "Function Body": "\nint __fastcall sub_4CE416(int a1, int a2)\n{\n  return (HI3B6F(a2) << 24) + (BYTE2(a2) << 16) + (BYTE1(a2) << 8) + (unsigned __int8)a2;\n}\n\n"
    },
    {
        "Function": "sub_456330",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "28.57%",
        "Function Body": "\nint __usercall sub_456330@<eax>(unsigned int a1@<eax>, char a2@<dl>, char a3@<cl>)\n{\n  return ((1 << a3) - 1) & (a1 >> a2);\n}\n\n"
    },
    {
        "Function": "sub_4DF9E6",
        "Total XOR and shift operations": 2,
        "XOR operations": 2,
        "Shift operations": 0,
        "Operation percentage": "28.57%",
        "Function Body": "\nint __usercall sub_4DF9E6@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  return a1 ^ a2 ^ a3;\n}\n\n"
    },
    {
        "Function": "__ROL4__",
        "Total XOR and shift operations": 15,
        "XOR operations": 5,
        "Shift operations": 10,
        "Operation percentage": "26.79%",
        "Function Body": "\n__int64 __userpurge sub_40D227@<edx:eax>(int a1@<eax>, int a2@<edx>, __int64 a3)\n{\n  int v3; // esi\n  __int64 v4; // rax\n  unsigned __int64 v5; // rax\n  int v6; // esi\n  int v7; // ecx\n  __int64 v8; // kr00_8\n  int v9; // ecx\n  int v10; // et0\n  int v11; // eax\n  int v12; // edx\n  unsigned int v13; // edi\n  unsigned int v14; // ecx\n  unsigned int v15; // ecx\n  __int64 v16; // rax\n\n  v3 = a2 >> 31;\n  LO07E3D(v4) = (a2 >> 31) ^ a1;\n  HIAB21D(v4) = (a2 >> 31) ^ a2;\n  v5 = v4 - __PA0E39__(v3, v3);\n  v6 = (SHIAB21D(a3) >> 31) ^ v3;\n  v8 = abs64(a3);\n  v7 = HIAB21D(v8);\n  if ( HIAB21D(v8) )\n  {\n    v13 = __ROR4__(HIAB21D(v8), 1);\n    _BitScanReverse(&v14, HIAB21D(v8));\n    v15 = (v5 >> 1 >> (v14 & 0x1F)) / (unsigned int)(__PA0E39__(v13, v8 >> 1) >> v14);\n    v11 = (__PA0E39__(v15, HIAB21D(v5))\n         - (unsigned int)(((unsigned int)v5 < (unsigned int)v8 * v15)\n                        + v15 * __ROL4__(v13, 1)\n                        + (((unsigned int)v8 * (unsigned __int64)v15) >> 32))) >> 32;\n    v12 = 0;\n  }\n  else\n  {\n    if ( HIAB21D(v5) >= (unsigned int)v8 )\n    {\n      v9 = v5;\n      LO07E3D(v5) = HIAB21D(v5) / (unsigned int)v8;\n      HIAB21D(v5) %= (unsigned int)v8;\n      v10 = v5;\n      LO07E3D(v5) = v9;\n      v7 = v10;\n    }\n    v11 = v5 / (unsigned int)v8;\n    v12 = v7;\n  }\n  LO07E3D(v16) = v6 ^ v11;\n  HIAB21D(v16) = v6 ^ v12;\n  return v16 - __PA0E39__(v6, v6);\n}\n\n"
    },
    {
        "Function": "sub_404654",
        "Total XOR and shift operations": 7,
        "XOR operations": 0,
        "Shift operations": 7,
        "Operation percentage": "24.14%",
        "Function Body": "\n_DWORD *__usercall sub_404654@<eax>(_DWORD *result@<eax>, int a2@<edx>)\n{\n  char *v2; // ecx\n  char *v3; // edx\n  unsigned int v4; // ecx\n\n  v2 = (char *)&unk_4F125D\n     + 8\n     * ((((unsigned __int64)((unsigned int)(a2 - 2864) >> 8) - 1023) >> 32) & (((unsigned int)(a2 - 2864) >> 8) - 1023))\n     + 8184;\n  v3 = (char *)*((_DWORD *)v2 + 1);\n  *result = v2;\n  result[1] = v3;\n  *(_DWORD *)v3 = result;\n  *((_DWORD *)v2 + 1) = result;\n  if ( v3 == v2 )\n  {\n    v4 = v2 - (char *)&unk_4F125D;\n    dword_4FF199[BYTE1(v4)] |= 1 << (v4 >> 3);\n    result = (_DWORD *)(1 << SB4D14(v4));\n    dword_4F4242 |= 1 << SB4D14(v4);\n  }\n  return result;\n}\n// 4F4242: using guessed type int dword_4F4242;\n// 4FF199: using guessed type int dword_4FF199[32];\n\n"
    },
    {
        "Function": "sub_4D612C",
        "Total XOR and shift operations": 24,
        "XOR operations": 24,
        "Shift operations": 0,
        "Operation percentage": "24.00%",
        "Function Body": "\n_DWORD *__usercall sub_4D612C@<eax>(int a1@<eax>, int *a2@<edx>, int *a3@<ecx>, int a4@<ebx>)\n{\n  _DWORD *v4; // eax\n  int v5; // ecx\n  int v6; // edx\n  _DWORD *result; // eax\n  int *v8; // [esp+0h] [ebp-54h]\n  int v9; // [esp+4h] [ebp-50h]\n  int v10; // [esp+4h] [ebp-50h]\n  int v11; // [esp+4h] [ebp-50h]\n  int v12; // [esp+8h] [ebp-4Ch]\n  int v13; // [esp+8h] [ebp-4Ch]\n  int v14; // [esp+8h] [ebp-4Ch]\n  int v15; // [esp+Ch] [ebp-48h]\n  int v16; // [esp+Ch] [ebp-48h]\n  int v17; // [esp+Ch] [ebp-48h]\n  int v18; // [esp+10h] [ebp-44h]\n  int v19; // [esp+10h] [ebp-44h]\n  int v20; // [esp+24h] [ebp-30h]\n  int v21; // [esp+24h] [ebp-30h]\n  int v22; // [esp+28h] [ebp-2Ch]\n  int v23; // [esp+28h] [ebp-2Ch]\n  int v24; // [esp+28h] [ebp-2Ch]\n  int v25; // [esp+2Ch] [ebp-28h]\n  int v26; // [esp+2Ch] [ebp-28h]\n  int v27; // [esp+2Ch] [ebp-28h]\n  int v28; // [esp+30h] [ebp-24h]\n  int v29; // [esp+30h] [ebp-24h]\n  int v30; // [esp+30h] [ebp-24h]\n\n  v8 = a3;\n  if ( !*(_BYTE *)(a1 + 64) )\n  {\n    v4 = sub_42415B((int)off_4DD3ED, 1, (__int32)L\"Cipher not initialized\");\n    a1 = sub_40B91A((int)v4, a4, (int)v8, v9, v12, v15);\n  }\n  v20 = *a2;\n  v22 = a2[1];\n  v25 = a2[2];\n  v28 = a2[3];\n  v5 = *(_DWORD *)(a1 + 112) - 2 + 1;\n  v6 = 0;\n  do\n  {\n    v10 = v20 ^ *(_DWORD *)(a1 + 32 * v6 + 116);\n    v13 = v22 ^ *(_DWORD *)(a1 + 32 * v6 + 120);\n    v16 = v25 ^ *(_DWORD *)(a1 + 32 * v6 + 124);\n    v18 = v28 ^ *(_DWORD *)(a1 + 32 * v6 + 128);\n    v20 = dword_4EC7C8[HI3B6F(v18)] ^ dword_4EAA3D[BYTE2(v16)] ^ dword_4E0C53[BYTE1(v13)] ^ dword_4E9CAD[(unsigned __int8)v10];\n    v22 = dword_4EC7C8[HI3B6F(v10)] ^ dword_4EAA3D[BYTE2(v18)] ^ dword_4E0C53[BYTE1(v16)] ^ dword_4E9CAD[(unsigned __int8)v13];\n    v25 = dword_4EC7C8[HI3B6F(v13)] ^ dword_4EAA3D[BYTE2(v10)] ^ dword_4E0C53[BYTE1(v18)] ^ dword_4E9CAD[(unsigned __int8)v16];\n    v28 = dword_4EC7C8[HI3B6F(v16)] ^ dword_4EAA3D[BYTE2(v13)] ^ dword_4E0C53[BYTE1(v10)] ^ dword_4E9CAD[(unsigned __int8)v18];\n    ++v6;\n    --v5;\n  }\n  while ( v5 );\n  v11 = v20 ^ *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 84);\n  v14 = v22 ^ *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 88);\n  v17 = v25 ^ *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 92);\n  v19 = v28 ^ *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 96);\n  LO2ADC(v21) = BYTE1(dword_4E9CAD[(unsigned __int8)v11]);\n  BYTE1(v21) = BYTE1(dword_4E9CAD[BYTE1(v14)]);\n  BYTE2(v21) = BYTE1(dword_4E9CAD[BYTE2(v17)]);\n  HI3B6F(v21) = BYTE1(dword_4E9CAD[HI3B6F(v19)]);\n  LO2ADC(v23) = BYTE1(dword_4E9CAD[(unsigned __int8)v14]);\n  BYTE1(v23) = BYTE1(dword_4E9CAD[BYTE1(v17)]);\n  BYTE2(v23) = BYTE1(dword_4E9CAD[BYTE2(v19)]);\n  HI3B6F(v23) = BYTE1(dword_4E9CAD[HI3B6F(v11)]);\n  LO2ADC(v26) = BYTE1(dword_4E9CAD[(unsigned __int8)v17]);\n  BYTE1(v26) = BYTE1(dword_4E9CAD[BYTE1(v19)]);\n  BYTE2(v26) = BYTE1(dword_4E9CAD[BYTE2(v11)]);\n  HI3B6F(v26) = BYTE1(dword_4E9CAD[HI3B6F(v14)]);\n  LO2ADC(v29) = BYTE1(dword_4E9CAD[(unsigned __int8)v19]);\n  BYTE1(v29) = BYTE1(dword_4E9CAD[BYTE1(v11)]);\n  BYTE2(v29) = BYTE1(dword_4E9CAD[BYTE2(v14)]);\n  HI3B6F(v29) = BYTE1(dword_4E9CAD[HI3B6F(v17)]);\n  v24 = *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 120) ^ v23;\n  v27 = *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 124) ^ v26;\n  v30 = *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 128) ^ v29;\n  *v8 = *(_DWORD *)(a1 + 32 * *(_DWORD *)(a1 + 112) + 116) ^ v21;\n  v8[1] = v24;\n  v8[2] = v27;\n  result = v8 + 3;\n  v8[3] = v30;\n  return result;\n}\n// 4DC72F: variable 'v9' is possibly undefined\n// 4DC72F: variable 'v12' is possibly undefined\n// 4DC72F: variable 'v15' is possibly undefined\n// 4D3532: variable 'a2' is possibly undefined\n// 4DCD20: variable 'v8' is possibly undefined\n// 4DD3ED: using guessed type int (*off_4DD3ED[2])();\n// 4D2402: using guessed type wchar_t aCipherNotIniti_12[23];\n// 4E9CAD: using guessed type int dword_4E9CAD[];\n// 4E0C53: using guessed type int dword_4E0C53[256];\n// 4EAA3D: using guessed type int dword_4EAA3D[256];\n// 4EC7C8: using guessed type int dword_4EC7C8[256];\n\n"
    },
    {
        "Function": "sub_4D0C7D",
        "Total XOR and shift operations": 24,
        "XOR operations": 24,
        "Shift operations": 0,
        "Operation percentage": "24.00%",
        "Function Body": "\nint __usercall sub_4D0C7D@<eax>(int a1@<eax>, int *a2@<edx>, int *a3@<ecx>, int a4@<ebx>)\n{\n  _DWORD *v4; // eax\n  unsigned int v5; // edx\n  int result; // eax\n  int v7; // [esp+0h] [ebp-50h]\n  int v8; // [esp+0h] [ebp-50h]\n  int v9; // [esp+0h] [ebp-50h]\n  int v10; // [esp+4h] [ebp-4Ch]\n  int v11; // [esp+4h] [ebp-4Ch]\n  int v12; // [esp+4h] [ebp-4Ch]\n  int v13; // [esp+8h] [ebp-48h]\n  int v14; // [esp+8h] [ebp-48h]\n  int v15; // [esp+8h] [ebp-48h]\n  int v16; // [esp+Ch] [ebp-44h]\n  int v17; // [esp+Ch] [ebp-44h]\n  int v18; // [esp+Ch] [ebp-44h]\n  int v19; // [esp+20h] [ebp-30h]\n  int v20; // [esp+20h] [ebp-30h]\n  int v21; // [esp+24h] [ebp-2Ch]\n  int v22; // [esp+24h] [ebp-2Ch]\n  int v23; // [esp+24h] [ebp-2Ch]\n  int v24; // [esp+28h] [ebp-28h]\n  int v25; // [esp+28h] [ebp-28h]\n  int v26; // [esp+28h] [ebp-28h]\n  int v27; // [esp+2Ch] [ebp-24h]\n  int v28; // [esp+2Ch] [ebp-24h]\n  int v29; // [esp+2Ch] [ebp-24h]\n\n  if ( !*(_BYTE *)(a1 + 64) )\n  {\n    v4 = sub_42415B((int)off_4DD3ED, 1, (__int32)L\"Cipher not initialized\");\n    a1 = sub_40B91A((int)v4, a4, v7, v10, v13, v16);\n  }\n  v19 = *a2;\n  v21 = a2[1];\n  v24 = a2[2];\n  v27 = a2[3];\n  v5 = *(_DWORD *)(a1 + 112);\n  if ( v5 >= 2 )\n  {\n    do\n    {\n      v8 = v19 ^ *(_DWORD *)(a1 + 32 * v5 + 596);\n      v11 = v21 ^ *(_DWORD *)(a1 + 32 * v5 + 600);\n      v14 = v24 ^ *(_DWORD *)(a1 + 32 * v5 + 604);\n      v17 = v27 ^ *(_DWORD *)(a1 + 32 * v5 + 608);\n      v19 = dword_4EC84F[HI3B6F(v11)] ^ dword_4E1325[BYTE2(v14)] ^ dword_4E2644[BYTE1(v17)] ^ dword_4E412E[(unsigned __int8)v8];\n      v21 = dword_4EC84F[HI3B6F(v14)] ^ dword_4E1325[BYTE2(v17)] ^ dword_4E2644[BYTE1(v8)] ^ dword_4E412E[(unsigned __int8)v11];\n      v24 = dword_4EC84F[HI3B6F(v17)] ^ dword_4E1325[BYTE2(v8)] ^ dword_4E2644[BYTE1(v11)] ^ dword_4E412E[(unsigned __int8)v14];\n      v27 = dword_4EC84F[HI3B6F(v8)] ^ dword_4E1325[BYTE2(v11)] ^ dword_4E2644[BYTE1(v14)] ^ dword_4E412E[(unsigned __int8)v17];\n      --v5;\n    }\n    while ( v5 != 1 );\n  }\n  v9 = v19 ^ *(_DWORD *)(a1 + 628);\n  v12 = v21 ^ *(_DWORD *)(a1 + 632);\n  v15 = v24 ^ *(_DWORD *)(a1 + 636);\n  v18 = v27 ^ *(_DWORD *)(a1 + 640);\n  LO2ADC(v20) = RijnDael_AES_inv_LONG_4E65C8[(unsigned __int8)v9];\n  BYTE1(v20) = RijnDael_AES_inv_LONG_4E65C8[BYTE1(v18)];\n  BYTE2(v20) = RijnDael_AES_inv_LONG_4E65C8[BYTE2(v15)];\n  HI3B6F(v20) = RijnDael_AES_inv_LONG_4E65C8[HI3B6F(v12)];\n  LO2ADC(v22) = RijnDael_AES_inv_LONG_4E65C8[(unsigned __int8)v12];\n  BYTE1(v22) = RijnDael_AES_inv_LONG_4E65C8[BYTE1(v9)];\n  BYTE2(v22) = RijnDael_AES_inv_LONG_4E65C8[BYTE2(v18)];\n  HI3B6F(v22) = RijnDael_AES_inv_LONG_4E65C8[HI3B6F(v15)];\n  LO2ADC(v25) = RijnDael_AES_inv_LONG_4E65C8[(unsigned __int8)v15];\n  BYTE1(v25) = RijnDael_AES_inv_LONG_4E65C8[BYTE1(v12)];\n  BYTE2(v25) = RijnDael_AES_inv_LONG_4E65C8[BYTE2(v9)];\n  HI3B6F(v25) = RijnDael_AES_inv_LONG_4E65C8[HI3B6F(v18)];\n  LO2ADC(v28) = RijnDael_AES_inv_LONG_4E65C8[(unsigned __int8)v18];\n  BYTE1(v28) = RijnDael_AES_inv_LONG_4E65C8[BYTE1(v15)];\n  BYTE2(v28) = RijnDael_AES_inv_LONG_4E65C8[BYTE2(v12)];\n  HI3B6F(v28) = RijnDael_AES_inv_LONG_4E65C8[HI3B6F(v9)];\n  v23 = *(_DWORD *)(a1 + 600) ^ v22;\n  v26 = *(_DWORD *)(a1 + 604) ^ v25;\n  v29 = *(_DWORD *)(a1 + 608) ^ v28;\n  *a3 = *(_DWORD *)(a1 + 596) ^ v20;\n  a3[1] = v23;\n  a3[2] = v26;\n  result = v29;\n  a3[3] = v29;\n  return result;\n}\n// 4DBE95: variable 'v7' is possibly undefined\n// 4DBE95: variable 'v10' is possibly undefined\n// 4DBE95: variable 'v13' is possibly undefined\n// 4DBE95: variable 'v16' is possibly undefined\n// 4D2F40: variable 'a2' is possibly undefined\n// 4DF84A: variable 'a3' is possibly undefined\n// 4DD3ED: using guessed type int (*off_4DD3ED[2])();\n// 4DD3E1: using guessed type wchar_t aCipherNotIniti_13[23];\n// 4E412E: using guessed type int dword_4E412E[256];\n// 4E2644: using guessed type int dword_4E2644[256];\n// 4E1325: using guessed type int dword_4E1325[256];\n// 4EC84F: using guessed type int dword_4EC84F[256];\n\n"
    },
    {
        "Function": "sub_4D8EE9",
        "Total XOR and shift operations": 6,
        "XOR operations": 0,
        "Shift operations": 6,
        "Operation percentage": "13.33%",
        "Function Body": "\nint __usercall sub_4D8EE9@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)\n{\n  int v4; // ebx\n  int v5; // edi\n  int v6; // eax\n\n  v4 = 0;\n  v5 = 0;\n  v6 = a3 / 3;\n  if ( a3 / 3 > 0 )\n  {\n    do\n    {\n      *(_BYTE *)(a2 + v5) = BAF61A_table_4E067B[*(unsigned __int8 *)(a1 + v4) >> 2];\n      *(_BYTE *)(a2 + v5 + 1) = BAF61A_table_4E067B[16 * (*(_BYTE *)(a1 + v4) & 3)\n                                                  + (*(unsigned __int8 *)(a1 + v4 + 1) >> 4)];\n      *(_BYTE *)(a2 + v5 + 2) = BAF61A_table_4E067B[4 * (*(_BYTE *)(a1 + v4 + 1) & 0xF)\n                                                  + (*(unsigned __int8 *)(a1 + v4 + 2) >> 6)];\n      *(_BYTE *)(a2 + v5 + 3) = BAF61A_table_4E067B[*(_BYTE *)(a1 + v4 + 2) & 0x3F];\n      v5 += 4;\n      v4 += 3;\n      --v6;\n    }\n    while ( v6 );\n  }\n  if ( a3 % 3 == 1 )\n  {\n    *(_BYTE *)(a2 + v5) = BAF61A_table_4E067B[*(unsigned __int8 *)(a1 + v4) >> 2];\n    *(_BYTE *)(a2 + v5 + 1) = BAF61A_table_4E067B[16 * (*(_BYTE *)(a1 + v4) & 3)];\n    *(_BYTE *)(a2 + v5 + 2) = 61;\n    *(_BYTE *)(a2 + v5 + 3) = 61;\n  }\n  else if ( a3 % 3 == 2 )\n  {\n    *(_BYTE *)(a2 + v5) = BAF61A_table_4E067B[*(unsigned __int8 *)(a1 + v4) >> 2];\n    *(_BYTE *)(a2 + v5 + 1) = BAF61A_table_4E067B[16 * (*(_BYTE *)(a1 + v4) & 3)\n                                                + (*(unsigned __int8 *)(a1 + v4 + 1) >> 4)];\n    *(_BYTE *)(a2 + v5 + 2) = BAF61A_table_4E067B[4 * (*(_BYTE *)(a1 + v4 + 1) & 0xF)];\n    *(_BYTE *)(a2 + v5 + 3) = 61;\n  }\n  return 4 * ((a3 + 2) / 3);\n}\n\n"
    },
    {
        "Function": "sub_4A8513",
        "Total XOR and shift operations": 6,
        "XOR operations": 0,
        "Shift operations": 6,
        "Operation percentage": "10.53%",
        "Function Body": "\nint __usercall sub_4A8513@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)\n{\n  unsigned __int64 v6; // rax\n  int v7; // ecx\n\n  *a2 = 0;\n  a2[1] = 0;\n  LO07E3D(v6) = sub_4A81CC();\n  if ( a3 > 0 )\n  {\n    v7 = *(_DWORD *)(a1 + 16);\n    LO07E3D(v6) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7);\n    *a2 = v6;\n    a2[1] = 0;\n    if ( a3 > 1 )\n    {\n      v6 = ((unsigned __int64)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 1) << 8) | *(_QWORD *)a2;\n      *(_QWORD *)a2 = v6;\n      if ( a3 > 2 )\n      {\n        v6 = ((unsigned __int64)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 2) << 16) | *(_QWORD *)a2;\n        *(_QWORD *)a2 = v6;\n        if ( a3 > 3 )\n        {\n          v6 = ((unsigned __int64)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 3) << 24) | *(_QWORD *)a2;\n          *(_QWORD *)a2 = v6;\n          if ( a3 > 4 )\n          {\n            LO07E3D(v6) = *a2;\n            *(_QWORD *)a2 = __PA0E39__((unsigned int)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 4) | a2[1], *a2);\n            if ( a3 > 5 )\n            {\n              LO07E3D(v6) = *a2;\n              *(_QWORD *)a2 = __PA0E39__((*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 5) << 8) | a2[1], *a2);\n              if ( a3 > 6 )\n              {\n                LO07E3D(v6) = *a2;\n                *(_QWORD *)a2 = __PA0E39__((*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 6) << 16) | a2[1], *a2);\n                if ( a3 > 7 )\n                {\n                  LO07E3D(v6) = *a2;\n                  *(_QWORD *)a2 = __PA0E39__(a2[1] | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 7) << 24), *a2);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  *(_DWORD *)(a1 + 16) += a3;\n  return v6;\n}\n// 4A81CC: using guessed type int sub_4A81CC(void);\n\n"
    },
    {
        "Function": "sub_4AEAD2",
        "Total XOR and shift operations": 6,
        "XOR operations": 0,
        "Shift operations": 6,
        "Operation percentage": "10.53%",
        "Function Body": "\nint __usercall sub_4AEAD2@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)\n{\n  unsigned __int64 v6; // rax\n  int v7; // ecx\n\n  *a2 = 0;\n  a2[1] = 0;\n  LO07E3D(v6) = sub_4A81CC();\n  if ( a3 > 0 )\n  {\n    v7 = *(_DWORD *)(a1 + 16);\n    LO07E3D(v6) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7);\n    *a2 = v6;\n    a2[1] = 0;\n    if ( a3 > 1 )\n    {\n      v6 = ((unsigned __int64)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 1) << 8) | *(_QWORD *)a2;\n      *(_QWORD *)a2 = v6;\n      if ( a3 > 2 )\n      {\n        v6 = ((unsigned __int64)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 2) << 16) | *(_QWORD *)a2;\n        *(_QWORD *)a2 = v6;\n        if ( a3 > 3 )\n        {\n          v6 = ((unsigned __int64)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 3) << 24) | *(_QWORD *)a2;\n          *(_QWORD *)a2 = v6;\n          if ( a3 > 4 )\n          {\n            LO07E3D(v6) = *a2;\n            *(_QWORD *)a2 = __PA0E39__((unsigned int)*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 4) | a2[1], *a2);\n            if ( a3 > 5 )\n            {\n              LO07E3D(v6) = *a2;\n              *(_QWORD *)a2 = __PA0E39__((*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 5) << 8) | a2[1], *a2);\n              if ( a3 > 6 )\n              {\n                LO07E3D(v6) = *a2;\n                *(_QWORD *)a2 = __PA0E39__((*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 6) << 16) | a2[1], *a2);\n                if ( a3 > 7 )\n                {\n                  LO07E3D(v6) = *a2;\n                  *(_QWORD *)a2 = __PA0E39__(a2[1] | (*(unsigned __int8 *)(*(_DWORD *)(a1 + 8) + v7 + 7) << 24), *a2);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  *(_DWORD *)(a1 + 16) += a3;\n  return v6;\n}\n// 4A81CC: using guessed type int sub_4A81CC(void);\n\n"
    },
    {
        "Function": "sub_4D4117",
        "Total XOR and shift operations": 13,
        "XOR operations": 12,
        "Shift operations": 1,
        "Operation percentage": "9.29%",
        "Function Body": "\nint __usercall sub_4D4117@<eax>(int a1@<eax>, __int64 *a2@<edx>, unsigned int a3@<ecx>)\n{\n  unsigned int v5; // ebx\n  unsigned int v6; // ecx\n  unsigned int v7; // edi\n  unsigned int v8; // edx\n  unsigned int v9; // eax\n  unsigned int v10; // eax\n  int result; // eax\n  int v12; // edi\n  int v13; // [esp+0h] [ebp-48h]\n  int v14; // [esp+4h] [ebp-44h]\n  unsigned int v15; // [esp+8h] [ebp-40h]\n  int v16; // [esp+8h] [ebp-40h]\n  int v17; // [esp+8h] [ebp-40h]\n  int v18; // [esp+8h] [ebp-40h]\n  __int64 *v19; // [esp+Ch] [ebp-3Ch]\n  __int64 *v20; // [esp+10h] [ebp-38h]\n  char *v21; // [esp+14h] [ebp-34h]\n  __int64 v22; // [esp+18h] [ebp-30h] BYREF\n  unsigned __int8 v23; // [esp+24h] [ebp-24h]\n  unsigned __int8 v24; // [esp+25h] [ebp-23h]\n  unsigned __int8 v25; // [esp+26h] [ebp-22h]\n  unsigned __int8 v26; // [esp+27h] [ebp-21h]\n  char v27; // [esp+28h] [ebp-20h] BYREF\n  char v28; // [esp+29h] [ebp-1Fh]\n  char v29; // [esp+2Ah] [ebp-1Eh]\n  char v30; // [esp+2Bh] [ebp-1Dh]\n\n  v5 = a3 >> 3;\n  sub_40C668(&v22, 32, 0);\n  sub_402CA0(a2, &v22, v5);\n  if ( v5 > 0x10 )\n  {\n    if ( v5 > 0x18 )\n    {\n      v6 = 8;\n      v13 = 14;\n    }\n    else\n    {\n      v6 = 6;\n      v13 = 12;\n    }\n  }\n  else\n  {\n    v6 = 4;\n    v13 = 10;\n  }\n  *(_DWORD *)(a1 + 112) = v13;\n  v7 = 0;\n  v8 = 0;\n  v9 = 0;\n  while ( v6 > v9 && v7 < v13 + 1 )\n  {\n    while ( v6 > v9 && v8 < 4 )\n      *(_DWORD *)(a1 + 32 * v7 + 4 * v8++ + 116) = *((_DWORD *)&v22 + v9++);\n    if ( v8 == 4 )\n    {\n      v8 = 0;\n      ++v7;\n    }\n  }\n  v14 = 0;\n  while ( v7 < v13 + 1 )\n  {\n    LO2ADC(v22) = RijnDael_AES_LONG_4ED746[*((unsigned __int8 *)&v21 + 4 * v6 + 1)] ^ v22;\n    BYTE1(v22) ^= RijnDael_AES_LONG_4ED746[*((unsigned __int8 *)&v21 + 4 * v6 + 2)];\n    BYTE2(v22) ^= RijnDael_AES_LONG_4ED746[*((unsigned __int8 *)&v21 + 4 * v6 + 3)];\n    BYTE3(v22) ^= RijnDael_AES_LONG_4ED746[LO2ADC((&v21)[v6])];\n    LO2ADC(v22) = byte_4FF01A[4 * v14++] ^ v22;\n    if ( v6 == 8 )\n    {\n      v16 = 3;\n      v20 = &v22;\n      do\n      {\n        *((_DWORD *)v20 + 1) ^= *(_DWORD *)v20;\n        v20 = (__int64 *)((char *)v20 + 4);\n        --v16;\n      }\n      while ( v16 );\n      v27 ^= RijnDael_AES_LONG_4ED746[v23];\n      v28 ^= RijnDael_AES_LONG_4ED746[v24];\n      v29 ^= RijnDael_AES_LONG_4ED746[v25];\n      v30 ^= RijnDael_AES_LONG_4ED746[v26];\n      v17 = 3;\n      v21 = &v27;\n      do\n      {\n        *((_DWORD *)v21 + 1) ^= *(_DWORD *)v21;\n        v21 += 4;\n        --v17;\n      }\n      while ( v17 );\n    }\n    else\n    {\n      v15 = v6 - 1;\n      v19 = &v22;\n      do\n      {\n        *((_DWORD *)v19 + 1) ^= *(_DWORD *)v19;\n        v19 = (__int64 *)((char *)v19 + 4);\n        --v15;\n      }\n      while ( v15 );\n    }\n    v10 = 0;\n    while ( v6 > v10 && v7 < v13 + 1 )\n    {\n      while ( v6 > v10 && v8 < 4 )\n        *(_DWORD *)(a1 + 32 * v7 + 4 * v8++ + 116) = *((_DWORD *)&v22 + v10++);\n      if ( v8 == 4 )\n      {\n        ++v7;\n        v8 = 0;\n      }\n    }\n  }\n  sub_402CA0((__int64 *)(a1 + 116), (__int64 *)(a1 + 596), 480);\n  result = *(_DWORD *)(a1 + 112) - 1;\n  if ( *(_DWORD *)(a1 + 112) != 1 )\n  {\n    v18 = *(_DWORD *)(a1 + 112) - 1;\n    v12 = 1;\n    do\n    {\n      result = sub_4DEB6A(a1 + 32 * v12++ + 596, 4u);\n      --v18;\n    }\n    while ( v18 );\n  }\n  return result;\n}\n// 4D2C22: conditional instruction was optimized away because ecx.4 is in (==4|==6)\n\n"
    },
    {
        "Function": "sub_43AC85",
        "Total XOR and shift operations": 12,
        "XOR operations": 0,
        "Shift operations": 12,
        "Operation percentage": "4.94%",
        "Function Body": "\nLONG __usercall sub_43AC85@<eax>(unsigned __int16 *a1@<eax>, void *a2@<ecx>, int a3@<edi>, int a4@<esi>)\n{\n  int v4; // eax\n  int v5; // edx\n  __int64 v6; // rax\n  void *v7; // ecx\n  __int64 v8; // rax\n  void *v9; // ecx\n  __int64 v10; // rax\n  void *v11; // ecx\n  __int64 v12; // rax\n  void *v13; // ecx\n  __int64 v14; // rax\n  void *v15; // ecx\n  __int64 v16; // rax\n  void *v17; // ecx\n  __int64 v18; // rax\n  void *v19; // ecx\n  __int64 v20; // rax\n  void *v21; // ecx\n  int *v22; // eax\n  int *v23; // eax\n  unsigned int v25[6]; // [esp-Ch] [ebp-20h] BYREF\n  unsigned __int16 *v26; // [esp+Ch] [ebp-8h]\n  LONG v27; // [esp+10h] [ebp-4h] BYREF\n  int savedregs; // [esp+14h] [ebp+0h] BYREF\n\n  v26 = a1;\n  v25[2] = (unsigned int)&savedregs;\n  v25[1] = (unsigned int)&loc_43E6FD;\n  v25[0] = (unsigned int)NtCurrentTeb()->NtTib.ExceptionList;\n  __writefsdword(0, (unsigned int)v25);\n  v4 = *a1;\n  v5 = (unsigned __int16)v4;\n  if ( (unsigned __int16)v4 > 0xCu )\n  {\n    if ( (unsigned __int16)v4 > 0x14u )\n    {\n      switch ( (unsigned __int16)v4 )\n      {\n        case 0x15u:\n          if ( *((int *)v26 + 2) >> 31 != *((_DWORD *)v26 + 3) )\n            sub_40C4CB(a2);\n          v27 = *((_DWORD *)v26 + 2);\n          break;\n        case 0x100u:\n          goto LABEL_44;\n        case 0x101u:\n          v27 = (LONG)sub_43CDD5((VA134DTARG *)v26, a3, a4);\n          break;\n        case 0x102u:\nLABEL_44:\n          v27 = (LONG)sub_43A39D((VA134DTARG *)v26, a2, a3, a4);\n          break;\n        default:\nLABEL_46:\n          if ( (v4 & 0x4000) != 0 )\n          {\n            switch ( v4 & 0xBFFF )\n            {\n              case 2:\n                v27 = **((__int16 **)v26 + 2);\n                break;\n              case 3:\n                v27 = **((_DWORD **)v26 + 2);\n                break;\n              case 4:\n                v14 = sub_40A07B(**((float **)v26 + 2));\n                if ( (int)v14 >> 31 != HIAB21D(v14) )\n                  sub_40C4CB(v15);\n                v27 = v14;\n                break;\n              case 5:\n                v16 = sub_40A07B(*(double *)*((_DWORD *)v26 + 2));\n                if ( (int)v16 >> 31 != HIAB21D(v16) )\n                  sub_40C4CB(v17);\n                v27 = v16;\n                break;\n              case 6:\n                v18 = sub_40A07B((double)*(__int64 *)*((_DWORD *)v26 + 2) / 10000.0);\n                if ( (int)v18 >> 31 != HIAB21D(v18) )\n                  sub_40C4CB(v19);\n                v27 = v18;\n                break;\n              case 7:\n                v20 = sub_40A07B(*(double *)*((_DWORD *)v26 + 2));\n                if ( (int)v20 >> 31 != HIAB21D(v20) )\n                  sub_40C4CB(v21);\n                v27 = v20;\n                break;\n              case 8:\n                goto LABEL_44;\n              case 0xB:\n                v27 = **((__int16 **)v26 + 2);\n                break;\n              case 0xC:\n                goto LABEL_43;\n              case 0x10:\n                v27 = **((char **)v26 + 2);\n                break;\n              case 0x11:\n                v27 = **((unsigned __int8 **)v26 + 2);\n                break;\n              case 0x12:\n                v27 = **((unsigned __int16 **)v26 + 2);\n                break;\n              case 0x13:\n                if ( **((int **)v26 + 2) < 0 )\n                  sub_40C4CB(a2);\n                v27 = **((_DWORD **)v26 + 2);\n                break;\n              case 0x14:\n                v22 = (int *)*((_DWORD *)v26 + 2);\n                if ( *v22 >> 31 != v22[1] )\n                  sub_40C4CB(a2);\n                v27 = *v22;\n                break;\n              case 0x15:\n                v23 = (int *)*((_DWORD *)v26 + 2);\n                if ( *v23 >> 31 != v23[1] )\n                  sub_40C4CB(a2);\n                v27 = *v23;\n                break;\n              default:\n                goto LABEL_76;\n            }\n          }\n          else if ( !(unsigned __int8)sub_43D129(v26, &v27, (int)a2) )\n          {\nLABEL_76:\n            v27 = sub_43EF9E(v26, a3, a4);\n          }\n          break;\n      }\n    }\n    else if ( (unsigned __int16)v4 == 20 )\n    {\n      if ( *((int *)v26 + 2) >> 31 != *((_DWORD *)v26 + 3) )\n        sub_40C4CB(a2);\n      v27 = *((_DWORD *)v26 + 2);\n    }\n    else\n    {\n      switch ( (__int16)v4 )\n      {\n        case 13:\n          goto LABEL_76;\n        case 16:\n          v27 = *((char *)v26 + 8);\n          break;\n        case 17:\n          v27 = *((unsigned __int8 *)v26 + 8);\n          break;\n        case 18:\n          v27 = v26[4];\n          break;\n        case 19:\n          if ( *((int *)v26 + 2) < 0 )\n            sub_40C4CB(a2);\n          v27 = *((_DWORD *)v26 + 2);\n          break;\n        default:\n          goto LABEL_46;\n      }\n    }\n  }\n  else if ( (unsigned __int16)v4 == 12 )\n  {\nLABEL_43:\n    v27 = sub_43AC85();\n  }\n  else\n  {\n    switch ( (__int16)v4 )\n    {\n      case 0:\n        v27 = 0;\n        break;\n      case 1:\n        if ( byte_4E42E7 )\n        {\n          LO9CE5(v5) = 3;\n          LO9CE5(v4) = 1;\n          sub_437D88(v4, v5, a3);\n        }\n        v27 = 0;\n        break;\n      case 2:\n        v27 = (__int16)v26[4];\n        break;\n      case 3:\n        v27 = *((_DWORD *)v26 + 2);\n        break;\n      case 4:\n        v6 = sub_40A07B(*((float *)v26 + 2));\n        if ( (int)v6 >> 31 != HIAB21D(v6) )\n          sub_40C4CB(v7);\n        v27 = v6;\n        break;\n      case 5:\n        v8 = sub_40A07B(*((double *)v26 + 1));\n        if ( (int)v8 >> 31 != HIAB21D(v8) )\n          sub_40C4CB(v9);\n        v27 = v8;\n        break;\n      case 6:\n        v10 = sub_40A07B((double)*((__int64 *)v26 + 1) / 10000.0);\n        if ( (int)v10 >> 31 != HIAB21D(v10) )\n          sub_40C4CB(v11);\n        v27 = v10;\n        break;\n      case 7:\n        v12 = sub_40A07B(*((double *)v26 + 1));\n        if ( (int)v12 >> 31 != HIAB21D(v12) )\n          sub_40C4CB(v13);\n        v27 = v12;\n        break;\n      case 8:\n        goto LABEL_44;\n      case 9:\n        goto LABEL_76;\n      case 11:\n        v27 = (__int16)v26[4];\n        break;\n      default:\n        goto LABEL_46;\n    }\n  }\n  __writefsdword(0, v25[0]);\n  return v27;\n}\n// 437917: variable 'v7' is possibly undefined\n// 4334C2: variable 'v9' is possibly undefined\n// 43E72D: variable 'v11' is possibly undefined\n// 437E63: variable 'v13' is possibly undefined\n// 43CB63: variable 'v15' is possibly undefined\n// 43673B: variable 'v17' is possibly undefined\n// 432287: variable 'v19' is possibly undefined\n// 43AC0D: variable 'v21' is possibly undefined\n// 4E42E7: using guessed type char byte_4E42E7;\n\n"
    },
    {
        "Function": "sub_40AA93",
        "Total XOR and shift operations": 7,
        "XOR operations": 0,
        "Shift operations": 7,
        "Operation percentage": "2.63%",
        "Function Body": "\nvolatile signed __int8 **__usercall sub_40AA93@<eax>(int a1@<eax>)\n{\n  volatile signed __int8 *v1; // ebx\n  volatile signed __int8 *v2; // edx\n  volatile signed __int8 **result; // eax\n  unsigned int v4; // ecx\n  int v5; // edx\n  char *v6; // ecx\n  int v7; // ecx\n  unsigned int v8; // eax\n  unsigned int v9; // ecx\n  int v10; // ecx\n  char *v11; // edi\n  volatile signed __int8 **v12; // esi\n  volatile signed __int8 *v13; // edx\n  int v14; // edx\n  bool v15; // zf\n  unsigned int v16; // edi\n  int v17; // edx\n  char *v18; // eax\n  int v19; // ecx\n  unsigned int v20; // ebx\n  unsigned int v21; // edx\n  unsigned int v22; // ecx\n  unsigned int v23; // eax\n  unsigned int v24; // ecx\n  unsigned int v25; // ecx\n  char *v26; // edi\n  int v27; // esi\n  char *v28; // eax\n  int v29; // eax\n  unsigned int v30; // edx\n  _DWORD *v31; // eax\n\n  if ( (unsigned int)a1 > 0xA2C )\n  {\n    if ( (unsigned int)a1 > 0x40A2C )\n    {\n      if ( a1 >= 0 )\n        return (volatile signed __int8 **)sub_407963(a1);\n      else\n        return 0;\n    }\n    v20 = ((a1 + 211) & 0xFF5B2300) + 48;\n    if ( byte_4FAEAC )\n    {\n      while ( _InterlockedCompareExchange8(&byte_4FA9B0, 1, 0) )\n      {\n        _mm_pause();\n        if ( !byte_4F05B2 )\n        {\n          Sleep(0);\n          if ( !_InterlockedCompareExchange8(&byte_4FA9B0, 1, 0) )\n            break;\n          Sleep(0xAu);\n        }\n      }\n    }\n    v21 = (v20 - 2864) >> 13;\n    v22 = (v20 - 2864) >> 8;\n    if ( (dword_4FF199[v21] & (-1 << v22)) != 0 )\n    {\n      _BitScanForward(&v23, dword_4FF199[v21] & (-1 << v22));\n      v24 = v23 | v22 & 0xFF5B23E0;\n    }\n    else\n    {\n      if ( (dword_4F4242 & (-2 << v21)) == 0 )\n      {\n        if ( dword_4F7E4B < v20 )\n        {\n          result = (volatile signed __int8 **)sub_40A7D2(v20);\n        }\n        else\n        {\n          result = (volatile signed __int8 **)(dword_4F734C - v20);\n          dword_4F734C = (int)result;\n          dword_4F7E4B -= v20;\n          *(result - 1) = (volatile signed __int8 *)(v20 | 2);\n        }\n        byte_4FA9B0 = 0;\n        return result;\n      }\n      _BitScanForward(&v21, dword_4F4242 & (-2 << v21));\n      _BitScanForward(&v25, dword_4FF199[v21]);\n      v24 = (32 * v21) | v25;\n    }\n    v26 = (char *)&unk_4F125D + 8 * v24;\n    v27 = *((_DWORD *)v26 + 1);\n    v28 = *(char **)(v27 + 4);\n    *((_DWORD *)v26 + 1) = v28;\n    *(_DWORD *)v28 = v26;\n    if ( v26 == v28 )\n    {\n      v29 = __ROL4__(-2, v24);\n      v15 = (v29 & dword_4FF199[v21]) == 0;\n      dword_4FF199[v21] &= v29;\n      if ( v15 )\n        _bittestandreset(&dword_4F4242, v21);\n    }\n    v30 = (*(_DWORD *)(v27 - 4) & 0xFF5B23F0) - v20;\n    if ( v30 )\n    {\n      v31 = (_DWORD *)(v27 + v20);\n      *(v31 - 1) = v30 + 3;\n      *(_DWORD *)((char *)v31 + v30 - 8) = v30;\n      if ( v30 >= 0xB30 )\n        sub_404654(v31, v30);\n    }\n    else\n    {\n      *(_BYTE *)(v27 + (*(_DWORD *)(v27 - 4) & 0xFF5B23F0) - 4) &= ~8u;\n    }\n    *(_DWORD *)(v27 - 4) = v20 + 2;\n    byte_4FA9B0 = 0;\n    return (volatile signed __int8 **)v27;\n  }\n  else\n  {\n    v1 = (char *)&unk_4EDBA0 + 8 * (unsigned __int8)byte_4F52C0[(unsigned int)(a1 + 3) >> 3];\n    if ( byte_4FAEAC )\n    {\n      while ( _InterlockedCompareExchange8(v1, 1, 0) )\n      {\n        v1 += 32;\n        if ( !_InterlockedCompareExchange8(v1, 1, 0) )\n          break;\n        v1 += 32;\n        if ( !_InterlockedCompareExchange8(v1, 1, 0) )\n          break;\n        v1 -= 64;\n        _mm_pause();\n        if ( !byte_4F05B2 )\n        {\n          Sleep(0);\n          if ( !_InterlockedCompareExchange8(v1, 1, 0) )\n            break;\n          Sleep(0xAu);\n        }\n      }\n    }\n    v2 = (volatile signed __int8 *)*((_DWORD *)v1 + 2);\n    result = (volatile signed __int8 **)*((_DWORD *)v2 + 4);\n    if ( v2 == v1 )\n    {\n      v5 = *((_DWORD *)v1 + 6);\n      v6 = (char *)result + *((unsigned __int16 *)v1 + 1);\n      if ( (unsigned int)result <= *((_DWORD *)v1 + 5) )\n      {\n        ++*(_DWORD *)(v5 + 20);\n        *((_DWORD *)v1 + 4) = v6;\n        *v1 = 0;\n        *(result - 1) = (volatile signed __int8 *)v5;\n        return result;\n      }\n      if ( byte_4FAEAC )\n      {\n        while ( _InterlockedCompareExchange8(&byte_4FA9B0, 1, 0) )\n        {\n          _mm_pause();\n          if ( !byte_4F05B2 )\n          {\n            Sleep(0);\n            if ( !_InterlockedCompareExchange8(&byte_4FA9B0, 1, 0) )\n              break;\n            Sleep(0xAu);\n          }\n        }\n      }\n      if ( (dword_4F4242 & v1[1]) != 0 )\n      {\n        _BitScanForward(&v8, dword_4F4242 & v1[1]);\n        _BitScanForward(&v9, dword_4FF199[v8]);\n        v10 = v9 + 32 * v8;\n        v11 = (char *)&unk_4F125D + 8 * v10;\n        v12 = (volatile signed __int8 **)*((_DWORD *)v11 + 1);\n        v13 = v12[1];\n        *((_DWORD *)v11 + 1) = v13;\n        *(_DWORD *)v13 = v11;\n        if ( v11 == v13 )\n        {\n          v14 = __ROL4__(-2, v10);\n          v15 = (v14 & dword_4FF199[v8]) == 0;\n          dword_4FF199[v8] &= v14;\n          if ( v15 )\n            _bittestandreset(&dword_4F4242, v8);\n        }\n        v16 = (unsigned int)*(v12 - 1) & 0xFF5B23F0;\n        if ( v16 < 0x10A60 )\n        {\n          *((_BYTE *)v12 + v16 - 4) &= ~8u;\n        }\n        else\n        {\n          v16 = *((unsigned __int16 *)v1 + 3);\n          v17 = ((unsigned int)*(v12 - 1) & 0xFF5B23F0) - v16;\n          v18 = (char *)v12 + v16;\n          *((_DWORD *)v18 - 1) = v17 + 3;\n          *(_DWORD *)&v18[v17 - 8] = v17;\n          sub_404654((volatile signed __int8 **)((char *)v12 + v16), v17);\n        }\n      }\n      else\n      {\n        v16 = dword_4F7E4B;\n        if ( dword_4F7E4B < (unsigned int)*((unsigned __int16 *)v1 + 2) )\n        {\n          v16 = *((unsigned __int16 *)v1 + 3);\n          result = (volatile signed __int8 **)sub_40A7D2(v16);\n          v12 = result;\n          if ( !result )\n          {\n            byte_4FA9B0 = 0;\n            *v1 = 0;\n            return result;\n          }\n        }\n        else\n        {\n          if ( dword_4F7E4B >= (unsigned int)*((unsigned __int16 *)v1 + 3) + 2864 )\n            v16 = *((unsigned __int16 *)v1 + 3);\n          v12 = (volatile signed __int8 **)(dword_4F734C - v16);\n          dword_4F7E4B -= v16;\n          dword_4F734C -= v16;\n        }\n      }\n      *(v12 - 1) = (volatile signed __int8 *)(v16 + 6);\n      byte_4FA9B0 = 0;\n      *v12 = v1;\n      v12[4] = 0;\n      v12[5] = (volatile signed __int8 *)1;\n      *((_DWORD *)v1 + 6) = v12;\n      result = v12 + 8;\n      v19 = *((unsigned __int16 *)v1 + 1);\n      *((_DWORD *)v1 + 4) = (char *)v12 + v19 + 32;\n      *((_DWORD *)v1 + 5) = (char *)v12 + v16 - v19;\n      *v1 = 0;\n      v12[7] = (volatile signed __int8 *)v12;\n    }\n    else\n    {\n      ++*((_DWORD *)v2 + 5);\n      v4 = (unsigned int)*(result - 1) & 0xFF5B23F8;\n      *((_DWORD *)v2 + 4) = v4;\n      *(result - 1) = v2;\n      if ( !v4 )\n      {\n        v7 = *((_DWORD *)v2 + 2);\n        *(_DWORD *)(v7 + 12) = v1;\n        *((_DWORD *)v1 + 2) = v7;\n      }\n      *v1 = 0;\n    }\n  }\n  return result;\n}\n// 4FAEAC: using guessed type char byte_4FAEAC;\n// 4F05B2: using guessed type char byte_4F05B2;\n// 4FA9B0: using guessed type char byte_4FA9B0;\n// 4F734C: using guessed type int dword_4F734C;\n// 4F7E4B: using guessed type int dword_4F7E4B;\n// 4F4242: using guessed type int dword_4F4242;\n// 4FF199: using guessed type int dword_4FF199[32];\n\n"
    }
]