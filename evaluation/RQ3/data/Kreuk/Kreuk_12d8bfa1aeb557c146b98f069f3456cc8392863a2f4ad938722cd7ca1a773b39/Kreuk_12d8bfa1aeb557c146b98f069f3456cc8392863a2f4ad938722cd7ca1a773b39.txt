[
    {
        "Function": "sub_4056FD",
        "Total XOR and shift operations": 10,
        "XOR operations": 0,
        "Shift operations": 10,
        "Operation percentage": "21.74%",
        "Function Body": "\nint __cdecl sub_4056FD(unsigned __int16 *a1)\n{\n  __int16 v1; // cx\n  __int16 v2; // si\n  unsigned __int16 v3; // ax\n\n  v1 = a1[3] & 0x8000;\n  v2 = 1;\n  v3 = a1[3] & 0xF;\n  a1[3] = v3;\n  if ( v3 || a1[2] || a1[1] || *a1 )\n  {\n    while ( !a1[3] )\n    {\n      a1[3] = a1[2];\n      a1[2] = a1[1];\n      a1[1] = *a1;\n      *a1 = 0;\n      v2 -= 16;\n    }\n    while ( a1[3] < 0x10u )\n    {\n      a1[3] = ((int)a1[2] >> 15) | (2 * a1[3]);\n      a1[2] = ((int)a1[1] >> 15) | (2 * a1[2]);\n      a1[1] = ((int)*a1 >> 15) | (2 * a1[1]);\n      *a1 *= 2;\n      --v2;\n    }\n    while ( a1[3] >= 0x20u )\n    {\n      *a1 = (a1[1] << 15) | ((int)*a1 >> 1);\n      a1[1] = (a1[2] << 15) | ((int)a1[1] >> 1);\n      a1[2] = (a1[3] << 15) | ((int)a1[2] >> 1);\n      a1[3] = (int)a1[3] >> 1;\n      ++v2;\n    }\n    a1[3] &= 0xFu;\n  }\n  a1[3] |= v1;\n  return v2;\n}\n\n// nfuncs=204 queued=187 decompiled=187 lumina nreq=0 worse=0 better=0\n// ALL OK, 187 function(s) have been successfully decompiled\n"
    },
    {
        "Function": "sub_40FDC1",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "18.18%",
        "Function Body": "\nint __cdecl sub_40FDC1(int a1)\n{\n  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )\n    return *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F));\n  dword_414FB5 = 9;\n  return -1;\n}\n// 414FB5: using guessed type int dword_414FB5;\n\n"
    },
    {
        "Function": "sub_40B1E7",
        "Total XOR and shift operations": 5,
        "XOR operations": 0,
        "Shift operations": 5,
        "Operation percentage": "12.82%",
        "Function Body": "\nunsigned int __stdcall sub_40B1E7(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 v3; // rtt\n  unsigned int v4; // ecx\n  unsigned int v5; // ebx\n  unsigned __int64 v6; // rax\n  char v7; // cf\n  unsigned int v8; // esi\n  unsigned __int64 v9; // rax\n\n  if ( HI5EB6D(a1) )\n  {\n    v4 = HI5EB6D(a1);\n    v5 = a1;\n    v6 = a2;\n    do\n    {\n      v7 = v4 & 1;\n      v4 >>= 1;\n      v5 = (v5 >> 1) | (v7 << 31);\n      v6 >>= 1;\n    }\n    while ( v4 );\n    v8 = v6 / v5;\n    v9 = v8 * (unsigned __int64)(unsigned int)a1;\n    if ( __CFADD__(HI5EB6D(a1) * v8, HI5EB6D(v9)) || (HI5EB6D(v9) = (a1 * (unsigned __int64)v8) >> 32, v9 > a2) )\n      --v8;\n    return v8;\n  }\n  else\n  {\n    LO288FD(v3) = a2;\n    HI5EB6D(v3) = HI5EB6D(a2) % (unsigned int)a1;\n    return v3 / (unsigned int)a1;\n  }\n}\n\n"
    },
    {
        "Function": "sub_40D5A3",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "12.12%",
        "Function Body": "\nint __cdecl sub_40D5A3(int a1, int a2)\n{\n  int v3; // ecx\n  _BYTE *v4; // eax\n  _BYTE *v5; // eax\n\n  if ( a1 >= uNumber || (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) == 0 )\n  {\n    dword_414FB5 = 9;\n    return -1;\n  }\n  v3 = *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x80;\n  if ( a2 == 0x8000 )\n  {\n    v4 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n    *v4 &= ~0x80u;\n  }\n  else\n  {\n    if ( a2 != 0x4000 )\n    {\n      dword_414FB5 = 22;\n      return -1;\n    }\n    v5 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n    *v5 |= 0x80u;\n  }\n  return v3 != 0 ? 0x4000 : 0x8000;\n}\n// 414FB5: using guessed type int dword_414FB5;\n\n"
    },
    {
        "Function": "sub_403D64",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "9.76%",
        "Function Body": "\nunsigned __int64 __stdcall sub_403D64(__int64 a1, unsigned __int64 a2)\n{\n  unsigned __int64 v2; // rtt\n  unsigned int v4; // ecx\n  unsigned int v5; // ebx\n  unsigned __int64 v6; // rax\n  bool v7; // cf\n  int v8; // ecx\n  unsigned __int64 v9; // rax\n\n  if ( HI5EB6D(a1) )\n  {\n    v4 = HI5EB6D(a1);\n    v5 = a1;\n    v6 = a2;\n    do\n    {\n      v7 = v4 & 1;\n      v4 >>= 1;\n      v5 = (v5 >> 1) | (v7 << 31);\n      v6 >>= 1;\n    }\n    while ( v4 );\n    v8 = HI5EB6D(a1) * (v6 / v5);\n    v9 = (unsigned int)a1 * (unsigned __int64)(unsigned int)(v6 / v5);\n    v7 = __CFADD__(v8, HI5EB6D(v9));\n    HI5EB6D(v9) += v8;\n    if ( v7 || v9 > a2 )\n      v9 -= a1;\n    return a2 - v9;\n  }\n  else\n  {\n    LO288FD(v2) = a2;\n    HI5EB6D(v2) = HI5EB6D(a2) % (unsigned int)a1;\n    return v2 % (unsigned int)a1;\n  }\n}\n\n"
    },
    {
        "Function": "sub_404C18",
        "Total XOR and shift operations": 8,
        "XOR operations": 0,
        "Shift operations": 8,
        "Operation percentage": "9.20%",
        "Function Body": "\nint __cdecl sub_404C18(unsigned __int16 *a1, int a2)\n{\n  int v2; // esi\n  int result; // eax\n  unsigned int v5; // kr00_4\n  double v6; // [esp+20h] [ebp-8h]\n  __int16 i; // [esp+24h] [ebp-4h]\n  __int16 v8; // [esp+24h] [ebp-4h]\n  unsigned __int16 v9; // [esp+26h] [ebp-2h]\n  int v10; // [esp+34h] [ebp+Ch]\n  int v11; // [esp+34h] [ebp+Ch]\n\n  v2 = (a1[3] & 0x7FF0) >> 4;\n  if ( (_WORD)v2 == 2047 )\n  {\n    if ( (a1[3] & 0xF) != 0 || a1[2] || a1[1] || *a1 )\n      return 2;\n    else\n      return 1;\n  }\n  else if ( (_WORD)v2 || (LO53FB(v2) = sub_4056FD(a1), (__int16)v2 <= 0) )\n  {\n    v10 = a2 + (__int16)v2;\n    if ( v10 < 2047 )\n    {\n      if ( v10 <= 0 )\n      {\n        v9 = a1[3] & 0x8000;\n        a1[3] = a1[3] & 0xF | 0x10;\n        v11 = v10 - 1;\n        if ( v11 >= -52 )\n        {\n          for ( i = v11; i <= -16; i += 16 )\n          {\n            *a1 = a1[1];\n            a1[1] = a1[2];\n            a1[2] = a1[3];\n            a1[3] = 0;\n          }\n          v8 = -i;\n          if ( v8 )\n          {\n            *a1 = (a1[1] << (16 - v8)) | ((int)*a1 >> v8);\n            a1[1] = (a1[2] << (16 - v8)) | ((int)a1[1] >> v8);\n            a1[2] = (a1[3] << (16 - v8)) | ((int)a1[2] >> v8);\n            a1[3] = (int)a1[3] >> v8;\n          }\n          a1[3] |= v9;\n          return -1;\n        }\n        else\n        {\n          a1[3] = v9;\n          a1[2] = 0;\n          a1[1] = 0;\n          *a1 = 0;\n          return 0;\n        }\n      }\n      else\n      {\n        a1[3] = (16 * v10) | a1[3] & 0x800F;\n        return -1;\n      }\n    }\n    else\n    {\n      if ( (a1[3] & 0x8000u) == 0 )\n        v6 = dbl_41AF7C;\n      else\n        v6 = -dbl_41AF7C;\n      *(double *)a1 = v6;\n      v5 = __readeflags();\n      result = 1;\n      __writeeflags(v5);\n    }\n  }\n  else\n  {\n    return 0;\n  }\n  return result;\n}\n// 41AF7C: using guessed type double dbl_41AF7C;\n\n"
    },
    {
        "Function": "sub_40BC26",
        "Total XOR and shift operations": 14,
        "XOR operations": 0,
        "Shift operations": 14,
        "Operation percentage": "7.95%",
        "Function Body": "\nDWORD __cdecl sub_40BC26(int a1, _BYTE *a2, DWORD nNumberOfBytesToRead)\n{\n  int v4; // edi\n  char *v5; // eax\n  _BYTE *v6; // eax\n  DWORD v7; // edi\n  _BYTE *v8; // eax\n  _BYTE *v9; // eax\n  _BYTE *v10; // esi\n  _BYTE *v11; // eax\n  _BYTE *v12; // eax\n  _BYTE *v13; // edx\n  _BYTE *v14; // eax\n  _BYTE *v15; // eax\n  _BYTE *v16; // edx\n  _BYTE *v17; // eax\n  _BYTE *v18; // eax\n  _BYTE *v19; // eax\n  _BYTE *v20; // eax\n  char Buffer; // [esp+Fh] [ebp-11h] BYREF\n  int LastError; // [esp+10h] [ebp-10h]\n  LPD4C1 lpBuffer; // [esp+14h] [ebp-Ch]\n  _BYTE *v24; // [esp+18h] [ebp-8h]\n  DWORD NumberOfBytesRead; // [esp+1Ch] [ebp-4h] BYREF\n\n  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )\n  {\n    v4 = 0;\n    lpBuffer = a2;\n    if ( nNumberOfBytesToRead && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 2) == 0 )\n    {\n      v5 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F);\n      if ( (v5[4] & 0x48) != 0 && v5[5] != 10 )\n      {\n        v6 = lpBuffer;\n        lpBuffer = (char *)lpBuffer + 1;\n        *v6 = *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5);\n        v4 = 1;\n        --nNumberOfBytesToRead;\n        *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5) = 10;\n      }\n      if ( ReadFile(\n             *((HABDE8 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),\n             lpBuffer,\n             nNumberOfBytesToRead,\n             &NumberOfBytesRead,\n             0) )\n      {\n        v7 = NumberOfBytesRead + v4;\n        if ( *((char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) < 0 )\n        {\n          if ( NumberOfBytesRead && *a2 == 10 )\n          {\n            v8 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n            *v8 |= 4u;\n          }\n          else\n          {\n            v9 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n            *v9 &= ~4u;\n          }\n          v24 = a2;\n          v10 = a2;\n          while ( v10 < &a2[v7] )\n          {\n            if ( *v10 == 26 )\n            {\n              if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x40) == 0 )\n              {\n                v11 = (char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4;\n                *v11 |= 2u;\n              }\n              return v24 - a2;\n            }\n            if ( *v10 == 13 )\n            {\n              if ( v10 >= &a2[v7 - 1] )\n              {\n                ++v10;\n                LastError = 0;\n                if ( !ReadFile(*((HABDE8 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)), &Buffer, 1u, &NumberOfBytesRead, 0) )\n                  LastError = GetLastError();\n                if ( !LastError && NumberOfBytesRead )\n                {\n                  if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x48) != 0 )\n                  {\n                    v18 = v24++;\n                    if ( Buffer == 10 )\n                    {\n                      *v18 = 10;\n                    }\n                    else\n                    {\n                      *v18 = 13;\n                      *((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 5) = Buffer;\n                    }\n                  }\n                  else if ( v24 == a2 && Buffer == 10 )\n                  {\n                    v19 = v24++;\n                    *v19 = 10;\n                  }\n                  else\n                  {\n                    sub_40511D(a1, -1, 1u);\n                    if ( Buffer != 10 )\n                    {\n                      v20 = v24++;\n                      *v20 = 13;\n                    }\n                  }\n                }\n                else\n                {\n                  v17 = v24++;\n                  *v17 = 13;\n                }\n              }\n              else if ( v10[1] == 10 )\n              {\n                v10 += 2;\n                v14 = v24++;\n                *v14 = 10;\n              }\n              else\n              {\n                v15 = v24++;\n                v16 = v10++;\n                *v15 = *v16;\n              }\n            }\n            else\n            {\n              v12 = v24++;\n              v13 = v10++;\n              *v12 = *v13;\n            }\n          }\n          return v24 - a2;\n        }\n        return v7;\n      }\n      else\n      {\n        LastError = GetLastError();\n        if ( LastError == 5 )\n        {\n          dword_414FB5 = 9;\n          return -1;\n        }\n        else if ( LastError == 109 )\n        {\n          return 0;\n        }\n        else\n        {\n          sub_405E79(LastError);\n          return -1;\n        }\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    dword_414FB5 = 9;\n    return -1;\n  }\n}\n// 414FB5: using guessed type int dword_414FB5;\n\n"
    },
    {
        "Function": "sub_40C32F",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "7.27%",
        "Function Body": "\nunsigned int *__cdecl sub_40C32F(unsigned int *a1, unsigned int a2, unsigned int a3)\n{\n  signed int v3; // esi\n  int j; // ebx\n  int v5; // esi\n  int v6; // edi\n  int v7; // eax\n  __int16 *v9; // [esp+14h] [ebp-14h]\n  int v10; // [esp+18h] [ebp-10h]\n  unsigned int i; // [esp+24h] [ebp-4h]\n  unsigned int v12; // [esp+24h] [ebp-4h]\n\n  if ( !a1 )\n    a1 = (unsigned int *)&unk_415C9E;\n  a1[8] = a3;\n  for ( i = a2; ; i = a2 + 3600 )\n  {\n    v3 = ((unsigned int)((321EA62230u * (unsigned __int64)i + 321EA62230u) >> 32) >> 16) + 25567;\n    a1[6] = (int)(((unsigned int)((321EA62230u * (unsigned __int64)i + 321EA62230u) >> 32) >> 16) + 25568) % 7;\n    for ( j = v3 / 365; ; --j )\n    {\n      v10 = 365 * j + sub_40134A(j, 0);\n      if ( v3 >= v10 )\n        break;\n    }\n    v5 = v3 - v10;\n    a1[5] = j;\n    a1[7] = v5;\n    if ( (j & 3) == 0 && j )\n      v9 = (__int16 *)&unk_41C4E8;\n    else\n      v9 = (__int16 *)&unk_41C279;\n    v6 = 12;\n    do\n      --v6;\n    while ( v5 < v9[v6] );\n    a1[4] = v6;\n    a1[3] = v5 - v9[v6] + 1;\n    v12 = i % 0x15180;\n    a1[2] = v12 / 0xE10;\n    v12 %= 0xE10u;\n    a1[1] = v12 / 0x3C;\n    *a1 = v12 % 0x3C;\n    if ( (a1[8] & 0x802AB700) == 0 )\n      break;\n    v7 = sub_40A37B(a1);\n    a1[8] = v7;\n    if ( v7 <= 0 )\n      break;\n  }\n  return a1;\n}\n\n"
    },
    {
        "Function": "sub_4098B9",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "6.25%",
        "Function Body": "\nint __cdecl sub_4098B9(int a1, HABDE8 hHandle)\n{\n  if ( a1 < uNumber && *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) == -1 )\n  {\n    if ( a1 )\n    {\n      if ( a1 == 1 )\n      {\n        SetStdHandle(0xFFF6B5F5, hHandle);\n      }\n      else if ( a1 == 2 )\n      {\n        SetStdHandle(0xFFF6B5F4, hHandle);\n      }\n    }\n    else\n    {\n      SetStdHandle(0xFFF6B5F6, hHandle);\n    }\n    *((_DWORD *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)) = hHandle;\n    return 0;\n  }\n  else\n  {\n    dword_414FB5 = 9;\n    return -1;\n  }\n}\n// 414FB5: using guessed type int dword_414FB5;\n\n"
    },
    {
        "Function": "sub_40B13F",
        "Total XOR and shift operations": 1,
        "XOR operations": 1,
        "Shift operations": 0,
        "Operation percentage": "6.25%",
        "Function Body": "\nint __cdecl sub_40B13F(_DWORD *a1, int a2)\n{\n  int v2; // edx\n  int i; // ecx\n\n  v2 = a1[1] + *a1;\n  for ( i = 0; i < 21; ++i )\n    v2 += *((char *)a1 + i + 8);\n  if ( a1[9] == (a2 ^ v2) )\n    return 0;\n  else\n    return -1;\n}\n\n"
    },
    {
        "Function": "sub_40E0EE",
        "Total XOR and shift operations": 6,
        "XOR operations": 0,
        "Shift operations": 6,
        "Operation percentage": "5.45%",
        "Function Body": "\nint __cdecl sub_40E0EE(int a1, _BYTE *lpBuffer, DWORD nNumberOfBytesToWrite)\n{\n  char *v4; // esi\n  char *i; // edi\n  char *v6; // eax\n  char v7; // bl\n  char *v8; // eax\n  char *v9; // eax\n  char Buffer[1025]; // [esp+Fh] [ebp-411h] BYREF\n  int LastError; // [esp+410h] [ebp-10h]\n  DWORD v12; // [esp+414h] [ebp-Ch]\n  DWORD NumberOfBytesWritten; // [esp+418h] [ebp-8h] BYREF\n  int v14; // [esp+41Ch] [ebp-4h]\n\n  if ( a1 < uNumber && (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 1) != 0 )\n  {\n    v12 = 0;\n    v14 = 0;\n    if ( nNumberOfBytesToWrite )\n    {\n      if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x20) != 0 )\n        sub_40511D(a1, 0, 2u);\n      if ( *((char *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) >= 0 )\n      {\n        if ( WriteFile(\n               *((HABDE8 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),\n               lpBuffer,\n               nNumberOfBytesToWrite,\n               &NumberOfBytesWritten,\n               0) )\n        {\n          LastError = 0;\n          v12 = NumberOfBytesWritten;\n        }\n        else\n        {\n          LastError = GetLastError();\n        }\n      }\n      else\n      {\n        v4 = lpBuffer;\n        LastError = 0;\n        while ( v4 - lpBuffer < nNumberOfBytesToWrite )\n        {\n          for ( i = Buffer; i - Buffer < 1024 && v4 - lpBuffer < nNumberOfBytesToWrite; ++i )\n          {\n            v6 = v4++;\n            v7 = *v6;\n            if ( *v6 == 10 )\n            {\n              ++v14;\n              v8 = i++;\n              *v8 = 13;\n            }\n            v9 = i;\n            *v9 = v7;\n          }\n          if ( !WriteFile(\n                  *((HABDE8 *)*(&lpMem + (a1 >> 5)) + 2 * (a1 & 0x1F)),\n                  Buffer,\n                  i - Buffer,\n                  &NumberOfBytesWritten,\n                  0) )\n          {\n            LastError = GetLastError();\n            break;\n          }\n          v12 += NumberOfBytesWritten;\n          if ( (int)NumberOfBytesWritten < i - Buffer )\n            break;\n        }\n      }\n      if ( v12 )\n      {\n        return v12 - v14;\n      }\n      else if ( LastError )\n      {\n        if ( LastError == 5 )\n          dword_414FB5 = 9;\n        else\n          sub_405E79(LastError);\n        return -1;\n      }\n      else if ( (*((_BYTE *)*(&lpMem + (a1 >> 5)) + 8 * (a1 & 0x1F) + 4) & 0x40) != 0 && *lpBuffer == 26 )\n      {\n        return 0;\n      }\n      else\n      {\n        dword_414FB5 = 28;\n        return -1;\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    dword_414FB5 = 9;\n    return -1;\n  }\n}\n// 414FB5: using guessed type int dword_414FB5;\n\n"
    },
    {
        "Function": "sub_40E3E2",
        "Total XOR and shift operations": 5,
        "XOR operations": 0,
        "Shift operations": 5,
        "Operation percentage": "4.76%",
        "Function Body": "\nint __cdecl sub_40E3E2(_BYTE *a1, unsigned __int16 a2, int a3)\n{\n  _BYTE *v4; // eax\n  int v5; // eax\n  char v6; // [esp+4h] [ebp-1Ch]\n  int v7; // [esp+8h] [ebp-18h]\n  __int16 v8; // [esp+Eh] [ebp-12h]\n  int v9; // [esp+10h] [ebp-10h]\n  int v10; // [esp+14h] [ebp-Ch]\n  _BYTE *v11; // [esp+18h] [ebp-8h]\n  int v12; // [esp+18h] [ebp-8h]\n  int v13; // [esp+1Ch] [ebp-4h]\n  unsigned __int8 v14; // [esp+1Fh] [ebp-1h]\n\n  if ( off_4106AE )\n  {\n    v14 = *(_WORD *)(a3 + 6);\n    v9 = 0;\n    v10 = 0;\n    v12 = 0;\n    if ( a1 )\n    {\n      do\n      {\n        if ( v14 >= 0x10u\n          || (v7 = (int)*(&off_41BBC6 + v14)) == 0\n          || v12 >= (unsigned __int8)byte_4172C7\n          || (++v10, v10 >= 4080)\n          || (v8 = *(_WORD *)(v7 + 2 * (unsigned __int8)a2)) == 0 )\n        {\n          dword_414FB5 = 42;\n          return -1;\n        }\n        v14 = (unsigned __int16)(v8 & 0xF00) >> 8;\n        if ( (v8 & 0x8000) != 0 )\n          a2 = (unsigned __int8)v8 | a2 & 0xFF00;\n        if ( (v8 & 0x1000) != 0 )\n          a2 = HI6E79(a2) | (unsigned __int16)(a2 << 8);\n        if ( (v8 & 0x2000) != 0 )\n        {\n          v5 = v12++;\n          if ( (_BYTE)v8 )\n            v6 = v8;\n          else\n            v6 = a2;\n          a1[v5] = v6;\n          if ( !v6 )\n            v9 = 1;\n          v10 = 0;\n        }\n      }\n      while ( (v8 & 0x4000) == 0 && !v9 );\n      *(_WORD *)(a3 + 6) = v14;\n      return v12;\n    }\n    else\n    {\n      *(_DWORD *)a3 = 0;\n      *(_DWORD *)(a3 + 4) = 0;\n      return *(_WORD *)off_4106AE & 0xF00;\n    }\n  }\n  else if ( a1 )\n  {\n    if ( (a2 & 0xFF80) != 0 )\n    {\n      v11 = a1 + 1;\n      if ( (a2 & 0xF800) != 0 )\n      {\n        *a1 = ((int)a2 >> 12) & 0xF | 0xE0;\n        v13 = 2;\n      }\n      else\n      {\n        *a1 = ((int)a2 >> 6) | 0xC0;\n        v13 = 1;\n      }\n    }\n    else\n    {\n      v11 = a1 + 1;\n      *a1 = a2;\n      v13 = 0;\n    }\n    while ( v13 > 0 )\n    {\n      v4 = v11++;\n      *v4 = ((int)a2 >> (6 * --v13)) & 0x3F | 0x80;\n    }\n    return v11 - a1;\n  }\n  else\n  {\n    *(_DWORD *)a3 = 0;\n    *(_DWORD *)(a3 + 4) = 0;\n    return 0;\n  }\n}\n// 414FB5: using guessed type int dword_414FB5;\n// 4172C7: using guessed type char byte_4172C7;\n// 4106AE: using guessed type void *off_4106AE;\n// 41BBC6: using guessed type void *off_41BBC6;\n\n"
    },
    {
        "Function": "sub_40E23D",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "2.22%",
        "Function Body": "\nint __cdecl sub_40E23D(int a1)\n{\n  unsigned int v1; // esi\n  unsigned int v2; // edi\n  char *v3; // eax\n  int result; // eax\n  _DWORD *v5; // ebx\n  unsigned int *v6; // ebx\n  unsigned int v7; // esi\n  unsigned int v8; // esi\n  unsigned int *v9; // ebx\n  int v10; // eax\n  int v11; // eax\n  unsigned int v12; // kr00_4\n  char *v13; // ebx\n  int v14; // [esp-20h] [ebp-24h]\n  int v15; // [esp-1Ch] [ebp-20h]\n  int v16; // [esp-10h] [ebp-14h]\n  int v17; // [esp-Ch] [ebp-10h]\n  unsigned int v18; // [esp-4h] [ebp-8h]\n\n  v1 = ((unsigned int)(a1 + 3) >> 14 << 14) + 0x4000;\n  v2 = 4 * v1;\n  v3 = sub_407D51(4 * v1);\n  if ( v3 )\n  {\n    if ( (char *)(dword_41BBF3 + dword_411947) == v3 )\n    {\n      v5 = (_DWORD *)dword_41BBF3;\n      v2 += dword_411947;\n      v1 = v2 >> 2;\n    }\n    else\n    {\n      v5 = v3;\n    }\n    dword_41BBF3 = (int)&v5[v1];\n    dword_411947 = v2 - 4 * v1;\n    if ( v5 == (_DWORD *)(dword_41F8B5 + 4) && dword_41CFF1 )\n    {\n      v13 = (char *)(v5 - 1);\n      v18 = v1 + (*(_DWORD *)v13 & 0x7FFF6B5F);\n      *(_DWORD *)v13 = v1 | 0x802AB700;\n      dword_41F8B5 += 4 * v1;\n      *(_DWORD *)(dword_41F8B5 - 4) = *(_DWORD *)v13;\n      *(_DWORD *)dword_41F8B5 = v18 | 0x802AB700;\n      *(_DWORD *)(dword_41F8B5 - 4 * v18 + 4) = v18 | 0x802AB700;\n      sub_40F724(v13 + 4);\n      return 1;\n    }\n    else\n    {\n      v17 = dword_41CFF1;\n      dword_41CFF1 = (int)v5;\n      *v5 = v17;\n      v6 = v5 + 1;\n      v7 = v1 - 1;\n      dword_41F8B5 = (int)v6;\n      if ( !dword_41806B || dword_41806B > (unsigned int)v6 )\n        dword_41806B = (int)v6;\n      *v6 = v7 | 0x802AB700;\n      dword_41F8B5 = dword_41F8B5 + 4 * v7 - 4;\n      *(_DWORD *)dword_41F8B5 = v7 | 0x802AB700;\n      v8 = v7 - 2;\n      v9 = (unsigned int *)(dword_41F8B5 - 4);\n      if ( v8 > dword_415435 )\n      {\n        if ( v8 > dword_41D23C )\n          v11 = (v8 > dword_416546) + 6;\n        else\n          v11 = (v8 > dword_41B63E) + 4;\n        v16 = v11;\n      }\n      else\n      {\n        if ( v8 > dword_411035 )\n          v10 = (v8 > dword_414697) + 2;\n        else\n          v10 = v8 > dword_415BF5;\n        v16 = v10;\n      }\n      dword_41D969 = v16;\n      v14 = dword_411B04[v16];\n      if ( v14 )\n      {\n        v15 = *(_DWORD *)(v14 - 8);\n      }\n      else\n      {\n        v15 = dword_41F8B5 - 4;\n        v14 = dword_41F8B5 - 4;\n        dword_411B04[dword_41D969] = (int)v9;\n        if ( dword_41E4F2 > dword_41D969 )\n          dword_41E4F2 = dword_41D969;\n      }\n      *(v9 - 1) = v14;\n      *(_DWORD *)(v14 - 8) = v9;\n      *(_DWORD *)(v15 - 4) = v9;\n      *(v9 - 2) = v15;\n      v9[-v8 + 1] = v8;\n      *v9 = v8;\n      dword_411B04[dword_41D969] = (int)v9;\n      while ( !dword_411B04[dword_41E4F2] && dword_41E4F2 < 7 )\n        ++dword_41E4F2;\n      v12 = __readeflags();\n      result = 1;\n      __writeeflags(v12);\n    }\n  }\n  else\n  {\n    dword_41A62B = 0;\n    return 0;\n  }\n  return result;\n}\n// 411B04: using guessed type int dword_411B04[9];\n// 41F8B5: using guessed type int dword_41F8B5;\n// 41806B: using guessed type int dword_41806B;\n// 41CFF1: using guessed type int dword_41CFF1;\n// 415BF5: using guessed type int dword_415BF5;\n// 411035: using guessed type int dword_411035;\n// 414697: using guessed type int dword_414697;\n// 415435: using guessed type int dword_415435;\n// 41B63E: using guessed type int dword_41B63E;\n// 41D23C: using guessed type int dword_41D23C;\n// 416546: using guessed type int dword_416546;\n// 41E4F2: using guessed type int dword_41E4F2;\n// 41D969: using guessed type int dword_41D969;\n// 41A62B: using guessed type int dword_41A62B;\n// 41BBF3: using guessed type int dword_41BBF3;\n// 411947: using guessed type int dword_411947;\n\n"
    }
]