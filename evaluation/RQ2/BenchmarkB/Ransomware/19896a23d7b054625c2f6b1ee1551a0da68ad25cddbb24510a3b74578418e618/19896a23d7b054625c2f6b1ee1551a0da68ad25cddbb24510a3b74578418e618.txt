[
    {
        "Function": "sub_14001B6D0",
        "Total XOR and shift operations": 9,
        "XOR operations": 7,
        "Shift operations": 2,
        "Operation percentage": "25.00%",
        "Function Body": "\nuintptr_t sub_14001B6D0()\n{\n  uintptr_t result; // rax\n  unsigned __int64 v1; // rcx\n  unsigned __int64 v2; // [rsp+30h] [rbp+8h] BYREF\n  struct _FILETIME SystemTimeAsFileTime; // [rsp+38h] [rbp+10h] BYREF\n  LARGE_INTEGER PerformanceCount; // [rsp+40h] [rbp+18h] BYREF\n\n  if ( _security_cookie == 0x2B992DDFA232i64 )\n  {\n    SystemTimeAsFileTime = 0i64;\n    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);\n    v2 = (unsigned __int64)SystemTimeAsFileTime;\n    v2 ^= GetCurrentThreadId();\n    v2 ^= GetCurrentProcessId();\n    v2 ^= GetTickCount64() << 56;\n    v2 ^= GetTickCount64();\n    QueryPerformanceCounter(&PerformanceCount);\n    v1 = ((unsigned __int64)&v2 ^ v2 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32)) & 0xFFFFFFFFFFFFi64;\n    result = 0x2B992DDFA233i64;\n    if ( v1 == 0x2B992DDFA232i64 )\n      v1 = 0x2B992DDFA233i64;\n    _security_cookie = v1;\n    qword_14002B0B8 = ~v1;\n  }\n  else\n  {\n    result = ~_security_cookie;\n    qword_14002B0B8 = ~_security_cookie;\n  }\n  return result;\n}\n// 14002B0B8: using guessed type __int64 qword_14002B0B8;\n\n"
    },
    {
        "Function": "sub_14001CA20",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "16.67%",
        "Function Body": "\nvoid __fastcall sub_14001CA20(unsigned __int64 a1)\n{\n  unsigned __int64 v1; // rdx\n\n  if ( (char *)a1 < iob[0]._ptr || a1 > (unsigned __int64)&iob[19] )\n  {\n    EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));\n  }\n  else\n  {\n    v1 = (__int64)((unsigned __int128)((__int64)(a1 - (unsigned __int64)iob[0]._ptr) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 3;\n    lock((unsigned int)v1 + (v1 >> 63) + 16);\n  }\n}\n// 14001E468: using guessed type __int64 __fastcall lock(_QWORD);\n\n"
    },
    {
        "Function": "sub_14001CA70",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "16.67%",
        "Function Body": "\nvoid __fastcall sub_14001CA70(unsigned __int64 a1)\n{\n  unsigned __int64 v1; // rdx\n\n  if ( (char *)a1 < iob[0]._ptr || a1 > (unsigned __int64)&iob[19] )\n  {\n    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));\n  }\n  else\n  {\n    v1 = (__int64)((unsigned __int128)((__int64)(a1 - (unsigned __int64)iob[0]._ptr) * (__int128)0x2AAAAAAAAAAAAAABi64) >> 64) >> 3;\n    unlock((unsigned int)v1 + (v1 >> 63) + 16);\n  }\n}\n// 14001E470: using guessed type __int64 __fastcall unlock(_QWORD);\n\n"
    },
    {
        "Function": "sub_140015F28",
        "Total XOR and shift operations": 5,
        "XOR operations": 0,
        "Shift operations": 5,
        "Operation percentage": "10.20%",
        "Function Body": "\n_OWORD *__fastcall sub_140015F28(unsigned __int64 *a1, _OWORD *a2, __int128 *a3)\n{\n  __int128 v3; // xmm0\n  unsigned __int64 v4; // rsi\n  __int64 v5; // rbx\n  __int64 v6; // r8\n  __int64 v7; // r15\n  unsigned __int64 v10; // rdi\n  __int64 v11; // rbx\n  __int128 v13; // [rsp+30h] [rbp-40h] BYREF\n  __int128 v14; // [rsp+40h] [rbp-30h] BYREF\n  __int128 v15; // [rsp+50h] [rbp-20h] BYREF\n  __int128 v16; // [rsp+60h] [rbp-10h] BYREF\n\n  v3 = *a3;\n  v4 = *a1;\n  v5 = 0i64;\n  v6 = a1[3];\n  v7 = 0i64;\n  v13 = *a1;\n  v10 = v4;\n  v14 = v3;\n  if ( v6 )\n  {\n    v11 = *((_QWORD *)&v14 + 1) + 32 * ((__int64)(v14 - v4) >> 2);\n    if ( v11 >= 0 )\n      v10 = v4 + 4 * ((unsigned __int64)v11 >> 5);\n    else\n      v10 = v4 - (4 * ((unsigned __int64)~v11 >> 5) + 4);\n    v5 = v11 & 0x1F;\n    *(_QWORD *)&v13 = v10;\n    v7 = (unsigned int)v5;\n    *((_QWORD *)&v13 + 1) = (unsigned int)v5;\n  }\n  v14 = v4;\n  sub_14000D5EC(&v14, &v15, v6);\n  v14 = v13;\n  *((_QWORD *)&v13 + 1) = ((_DWORD)v5 + 1) & 0x1F;\n  *(_QWORD *)&v13 = v13 + 4 * ((unsigned __int64)(v5 + 1) >> 5);\n  sub_14000462C(&v16, (__int64)&v13, &v15, (int **)&v14);\n  sub_14001423C(a1, a1[3] - 1);\n  v14 = *a1;\n  sub_14000D5EC(&v14, a2, v7 + 32 * ((__int64)(v10 - v4) >> 2));\n  return a2;\n}\n// 140015F8E: conditional instruction was optimized away because rbx.8<0\n\n"
    },
    {
        "Function": "sub_14001BE90",
        "Total XOR and shift operations": 4,
        "XOR operations": 4,
        "Shift operations": 0,
        "Operation percentage": "8.51%",
        "Function Body": "\n__int64 __fastcall sub_14001BE90(__int64 a1, unsigned int *a2, _QWORD **a3, unsigned int *a4)\n{\n  _QWORD **v6; // rdx\n  __int64 v7; // r9\n  void *v8; // rax\n  unsigned int v9; // ebx\n  __int64 v11; // [rsp+20h] [rbp-18h] BYREF\n  void *v12; // [rsp+48h] [rbp+10h] BYREF\n  unsigned int *v13; // [rsp+58h] [rbp+20h]\n\n  v13 = a4;\n  lock(*a2);\n  v6 = (_QWORD **)*a3;\n  v12 = (void *)__ROR8__(*(_QWORD *)**a3 ^ _security_cookie, _security_cookie & 0x3F);\n  v7 = __ROR8__((*v6)[2] ^ _security_cookie, _security_cookie & 0x3F);\n  v11 = v7;\n  if ( !v12 && !v7 )\n  {\n    v8 = malloc(0x100ui64);\n    v12 = v8;\n    if ( !v8 )\n    {\n      v9 = -1;\n      goto LABEL_9;\n    }\n    v11 = (__int64)v8;\n  }\n  if ( _dllonexit(*a3[1], &v12, &v11) )\n  {\n    *(_QWORD *)**a3 = __ROR8__(v12, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)) ^ _security_cookie;\n    *(_QWORD *)(**a3 + 16i64) = __ROR8__(v11, 64 - ((unsigned __int8)_security_cookie & 0x3Fu)) ^ _security_cookie;\n    v9 = 0;\n  }\n  else\n  {\n    v9 = -1;\n  }\nLABEL_9:\n  unlock(*a4);\n  return v9;\n}\n// 14001E468: using guessed type __int64 __fastcall lock(_QWORD);\n// 14001E470: using guessed type __int64 __fastcall unlock(_QWORD);\n// 14001E5D0: using guessed type __int64 __fastcall _dllonexit(_QWORD, _QWORD, _QWORD);\n\n"
    },
    {
        "Function": "sub_14001423C",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "8.11%",
        "Function Body": "\nunsigned __int64 __fastcall sub_14001423C(unsigned __int64 *a1, unsigned __int64 a2)\n{\n  unsigned __int64 result; // rax\n  unsigned __int64 v5; // rbp\n  char *v6; // rdx\n  unsigned __int64 v7; // rbp\n  char *v8; // rbx\n  int v9; // edi\n\n  if ( a2 > 0x7FFFFFFFFFFFFFFFi64 )\n    sub_1400142E0();\n  result = *a1;\n  v5 = a2 + 31;\n  v6 = (char *)a1[1];\n  v7 = v5 >> 5;\n  if ( v7 < (__int64)&v6[-*a1] >> 2 )\n  {\n    v8 = (char *)(result + 4 * v7);\n    if ( v8 != v6 )\n    {\n      result = (unsigned __int64)memmove((void *)(result + 4 * v7), v6, 0i64);\n      a1[1] = (unsigned __int64)v8;\n    }\n  }\n  a1[3] = a2;\n  v9 = a2 & 0x1F;\n  if ( v9 )\n  {\n    result = (unsigned int)((1 << v9) - 1);\n    *(_DWORD *)(*a1 + 4 * v7 - 4) &= result;\n  }\n  return result;\n}\n// 1400142E0: using guessed type void __noreturn sub_1400142E0(void);\n\n"
    },
    {
        "Function": "sub_14000D574",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "7.41%",
        "Function Body": "\n_OWORD *__fastcall sub_14000D574(__int128 *a1, _OWORD *a2, __int64 a3)\n{\n  __int64 v3; // r8\n  char v5; // dl\n  _OWORD *result; // rax\n  __int128 v7; // [rsp+0h] [rbp-18h]\n\n  v3 = -a3;\n  v7 = *a1;\n  if ( v3 >= 0 || *((_QWORD *)&v7 + 1) >= (unsigned __int64)-v3 )\n  {\n    v5 = v3 + BYTE8(v7);\n    *(_QWORD *)&v7 = v7 + 4 * ((unsigned __int64)(v3 + *((_QWORD *)&v7 + 1)) >> 5);\n  }\n  else\n  {\n    v5 = v3 + BYTE8(v7);\n    *(_QWORD *)&v7 = -4i64 - 4 * ((unsigned __int64)~(v3 + *((_QWORD *)&v7 + 1)) >> 5) + v7;\n  }\n  result = a2;\n  *((_QWORD *)&v7 + 1) = v5 & 0x1F;\n  *a2 = v7;\n  return result;\n}\n\n"
    },
    {
        "Function": "sub_14000D5EC",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "7.41%",
        "Function Body": "\n_OWORD *__fastcall sub_14000D5EC(__int128 *a1, _OWORD *a2, __int64 a3)\n{\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  _OWORD *result; // rax\n  __int128 v6; // [rsp+0h] [rbp-18h]\n\n  v6 = *a1;\n  v3 = *((_QWORD *)a1 + 1);\n  if ( a3 >= 0 || *((_QWORD *)&v6 + 1) >= (unsigned __int64)-a3 )\n  {\n    *((_QWORD *)&v6 + 1) = ((_BYTE)a3 + BYTE8(v6)) & 0x1F;\n    *(_QWORD *)&v6 = v6 + 4 * ((unsigned __int64)(a3 + v3) >> 5);\n  }\n  else\n  {\n    v4 = *((_QWORD *)&v6 + 1) + a3;\n    *(_QWORD *)&v6 = -4i64 - 4 * ((unsigned __int64)~v4 >> 5) + v6;\n    *((_QWORD *)&v6 + 1) = v4 & 0x1F;\n  }\n  result = a2;\n  *a2 = v6;\n  return result;\n}\n\n"
    },
    {
        "Function": "sub_1400011A0",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "7.14%",
        "Function Body": "\nunsigned __int64 __fastcall sub_1400011A0(_QWORD *a1, _QWORD *a2, _QWORD *a3)\n{\n  unsigned __int64 v5; // rsi\n  __int64 v6; // rax\n  unsigned __int64 v7; // r12\n  unsigned __int64 v8; // rax\n  unsigned __int64 v9; // rcx\n  unsigned __int64 v10; // rdi\n  char *v11; // r15\n  unsigned __int64 v12; // rsi\n  char *v13; // r14\n  _QWORD *v14; // rdx\n  char *v15; // r8\n  _QWORD *v16; // rcx\n\n  v5 = (unsigned __int64)a2 - *a1;\n  v6 = (__int64)(a1[1] - *a1) >> 5;\n  if ( v6 == 0x7FFFFFFFFFFFFFFi64 )\n    sub_140002E18();\n  v7 = v6 + 1;\n  v8 = (__int64)(a1[2] - *a1) >> 5;\n  v9 = v8 >> 1;\n  if ( v8 <= 0x7FFFFFFFFFFFFFFi64 - (v8 >> 1) )\n  {\n    v10 = v9 + v8;\n    if ( v9 + v8 < v7 )\n      v10 = v7;\n  }\n  else\n  {\n    v10 = v7;\n  }\n  v11 = (char *)sub_140002E2C((__int64)a1, v10);\n  v12 = v5 & 0xFFFFFFFFFFFFFFE0ui64;\n  v13 = &v11[v12];\n  *((_QWORD *)v13 + 2) = 0i64;\n  *((_QWORD *)v13 + 3) = 0i64;\n  sub_140002B9C(&v11[v12], a3);\n  v14 = (_QWORD *)a1[1];\n  v15 = v11;\n  v16 = (_QWORD *)*a1;\n  if ( a2 != v14 )\n  {\n    sub_140002120(v16, a2, v11);\n    v15 = v13 + 32;\n    v14 = (_QWORD *)a1[1];\n    v16 = a2;\n  }\n  sub_140002120(v16, v14, v15);\n  sub_140002AE4((__int64)a1, (__int64)v11, v7, v10);\n  return v12 + *a1;\n}\n// 140002E18: using guessed type void __noreturn sub_140002E18(void);\n\n"
    },
    {
        "Function": "sub_1400050D8",
        "Total XOR and shift operations": 5,
        "XOR operations": 0,
        "Shift operations": 5,
        "Operation percentage": "7.04%",
        "Function Body": "\n__int64 __fastcall sub_1400050D8(__int64 a1, void *a2, _QWORD *a3)\n{\n  __int64 v6; // r12\n  __int64 v7; // rax\n  unsigned __int64 v8; // r13\n  unsigned __int64 v9; // rax\n  unsigned __int64 v10; // rcx\n  __int64 v11; // rsi\n  _QWORD *v12; // r15\n  void *v13; // rbx\n  size_t v14; // rbx\n  void *v15; // rdx\n  _QWORD *v16; // rcx\n  __int64 v17; // rbx\n  char v19[8]; // [rsp+20h] [rbp-68h] BYREF\n  void *Src; // [rsp+28h] [rbp-60h]\n  __int64 v21; // [rsp+38h] [rbp-50h]\n  _QWORD *v22; // [rsp+40h] [rbp-48h]\n  __int64 v23; // [rsp+48h] [rbp-40h]\n  __int64 v24; // [rsp+50h] [rbp-38h]\n\n  v24 = -2i64;\n  Src = a2;\n  v23 = a1;\n  v6 = ((__int64)a2 - *(_QWORD *)a1) >> 3;\n  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;\n  if ( v7 == 0x1FFFFFFFFFFFFFFFi64 )\n    sub_140002E18();\n  v8 = v7 + 1;\n  v9 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3;\n  v10 = v9 >> 1;\n  if ( v9 <= 0x1FFFFFFFFFFFFFFFi64 - (v9 >> 1) )\n  {\n    v11 = v10 + v9;\n    if ( v10 + v9 < v8 )\n      v11 = v8;\n  }\n  else\n  {\n    v11 = v8;\n  }\n  v21 = v11;\n  v12 = sub_140014374(a1, v11);\n  v22 = v12;\n  v12[v6] = *a3;\n  v13 = *(void **)(a1 + 8);\n  sub_140006D98(v19);\n  if ( a2 == v13 )\n  {\n    v14 = (size_t)v13 - *(_QWORD *)a1;\n    v15 = *(void **)a1;\n    v16 = v12;\n  }\n  else\n  {\n    memmove(v12, *(const void **)a1, (size_t)a2 - *(_QWORD *)a1);\n    v17 = *(_QWORD *)(a1 + 8);\n    sub_140006D98(v19);\n    v15 = Src;\n    v14 = v17 - (_QWORD)Src;\n    v16 = &v12[v6 + 1];\n  }\n  memmove(v16, v15, v14);\n  sub_140012FD8(a1, (__int64)v12, v8, v11);\n  return *(_QWORD *)a1 + 8 * v6;\n}\n// 140002E18: using guessed type void __noreturn sub_140002E18(void);\n// 1400050D8: using guessed type char var_68[8];\n\n"
    },
    {
        "Function": "sub_14001C294",
        "Total XOR and shift operations": 6,
        "XOR operations": 6,
        "Shift operations": 0,
        "Operation percentage": "6.98%",
        "Function Body": "\n__int64 sub_14001C294()\n{\n  char v5; // r11\n  int v6; // r14d\n  int v7; // ebp\n  int v8; // r9d\n  int v9; // r8d\n  int v11; // r10d\n  int v16; // esi\n  int v17; // edi\n  int v18; // eax\n  unsigned __int64 v19; // rax\n  __int64 v20; // rcx\n  int v21; // r8d\n  int v26; // eax\n\n  dword_14002B0E4 = 2;\n  _RAX = 0i64;\n  dword_14002B0E0 = 1;\n  __asm { cpuid }\n  v5 = 0;\n  v6 = _RAX;\n  v7 = _RCX ^ 0x444D4163 | _RDX ^ 0x69746E65 | _RBX ^ 0x68747541;\n  v8 = _RDX ^ 0x49656E69;\n  v9 = _RBX ^ 0x756E6547;\n  _RAX = 1i64;\n  v11 = _RCX ^ 0x6C65746E;\n  __asm { cpuid }\n  v16 = _RCX;\n  v17 = _RAX;\n  if ( !(v11 | v8 | v9)\n    && ((qword_14002B0E8 = -1i64, v18 = _RAX & 0xFFF3FF0, v18 == 67264)\n     || v18 == 132704\n     || v18 == 132720\n     || (v19 = (unsigned int)(v18 - 198224), (unsigned int)v19 <= 0x20) && (v20 = 0x100010001i64, _bittest64(&v20, v19))) )\n  {\n    v21 = dword_14002C198 | 1;\n    dword_14002C198 |= 1u;\n  }\n  else\n  {\n    v21 = dword_14002C198;\n  }\n  if ( !v7 && (v17 & 0xFF00F00u) >= 0x601100 )\n  {\n    v21 |= 4u;\n    dword_14002C198 = v21;\n  }\n  _RAX = 7i64;\n  if ( v6 >= 7 )\n  {\n    __asm { cpuid }\n    v5 = _RBX;\n    if ( (_RBX & 0x200) != 0 )\n      dword_14002C198 = v21 | 2;\n  }\n  if ( (v16 & 0x100000) != 0 )\n  {\n    dword_14002B0E0 = 2;\n    dword_14002B0E4 = 6;\n    if ( (v16 & 0x8000000) != 0 && (v16 & 0x10000000) != 0 )\n    {\n      __asm { xgetbv }\n      if ( (_RAX & 6) == 6 )\n      {\n        v26 = dword_14002B0E4 | 8;\n        dword_14002B0E0 = 3;\n        dword_14002B0E4 |= 8u;\n        if ( (v5 & 0x20) != 0 )\n        {\n          dword_14002B0E0 = 5;\n          dword_14002B0E4 = v26 | 0x20;\n        }\n      }\n    }\n  }\n  return 0i64;\n}\n// 14001C294: using guessed type __int64 sub_14001C294();\n// 14002B0E0: using guessed type int dword_14002B0E0;\n// 14002B0E4: using guessed type int dword_14002B0E4;\n// 14002B0E8: using guessed type __int64 qword_14002B0E8;\n// 14002C198: using guessed type int dword_14002C198;\n\n"
    },
    {
        "Function": "sub_1400046DC",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "4.08%",
        "Function Body": "\nunsigned __int64 __fastcall sub_1400046DC(_QWORD *a1, _QWORD *a2)\n{\n  unsigned __int64 v4; // r12\n  __int64 v5; // rax\n  unsigned __int64 v6; // r13\n  unsigned __int64 v7; // rax\n  unsigned __int64 v8; // rcx\n  unsigned __int64 v9; // rbx\n  _QWORD *v10; // rsi\n  unsigned __int64 v11; // r12\n  _QWORD *v12; // rdx\n  _QWORD *v13; // rax\n  _QWORD *v14; // rcx\n  char *v15; // r8\n  _QWORD *v16; // rcx\n  char *v17; // rdx\n  _QWORD *v18; // rcx\n  char *v19; // r8\n\n  v4 = (unsigned __int64)a2 - *a1;\n  v5 = (__int64)(a1[1] - *a1) >> 4;\n  if ( v5 == 0xFFFFFFFFFFFFFFFi64 )\n    sub_140002E18();\n  v6 = v5 + 1;\n  v7 = (__int64)(a1[2] - *a1) >> 4;\n  v8 = v7 >> 1;\n  if ( v7 <= 0xFFFFFFFFFFFFFFFi64 - (v7 >> 1) )\n  {\n    v9 = v8 + v7;\n    if ( v8 + v7 < v6 )\n      v9 = v6;\n  }\n  else\n  {\n    v9 = v6;\n  }\n  v10 = sub_14001444C((__int64)a1, v9);\n  v11 = v4 & 0xFFFFFFFFFFFFFFF0ui64;\n  *((_BYTE *)v10 + v11) = 0;\n  sub_14000C36C((_QWORD *)((char *)v10 + v11 + 8), 0);\n  v12 = (_QWORD *)a1[1];\n  v13 = (_QWORD *)*a1;\n  if ( a2 == v12 )\n  {\n    if ( v13 != v12 )\n    {\n      v14 = v13 + 1;\n      v15 = (char *)((char *)v10 - (char *)v13);\n      do\n      {\n        *((_BYTE *)v14 + (_QWORD)v15 - 8) = *((_BYTE *)v14 - 8);\n        *(_QWORD *)((char *)v14 + (_QWORD)v15) = *v14;\n        *((_BYTE *)v14 - 8) = 0;\n        *v14 = 0i64;\n        v14 += 2;\n      }\n      while ( v14 - 1 != v12 );\n    }\n  }\n  else\n  {\n    if ( v13 != a2 )\n    {\n      v16 = v13 + 1;\n      v17 = (char *)((char *)v10 - (char *)v13);\n      do\n      {\n        *((_BYTE *)v16 + (_QWORD)v17 - 8) = *((_BYTE *)v16 - 8);\n        *(_QWORD *)((char *)v16 + (_QWORD)v17) = *v16;\n        *((_BYTE *)v16 - 8) = 0;\n        *v16 = 0i64;\n        v16 += 2;\n      }\n      while ( v16 - 1 != a2 );\n      v12 = (_QWORD *)a1[1];\n    }\n    if ( a2 != v12 )\n    {\n      v18 = a2 + 1;\n      v19 = (char *)v10 + v11 - (_QWORD)a2;\n      do\n      {\n        *((_BYTE *)v18 + (_QWORD)v19 + 8) = *((_BYTE *)v18 - 8);\n        *(_QWORD *)((char *)v18 + (_QWORD)v19 + 16) = *v18;\n        *((_BYTE *)v18 - 8) = 0;\n        *v18 = 0i64;\n        v18 += 2;\n      }\n      while ( v18 - 1 != v12 );\n    }\n  }\n  sub_140013144((__int64)a1, (__int64)v10, v6, v9);\n  return v11 + *a1;\n}\n// 140002E18: using guessed type void __noreturn sub_140002E18(void);\n\n"
    },
    {
        "Function": "sub_140004A2C",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "3.96%",
        "Function Body": "\nunsigned __int64 __fastcall sub_140004A2C(_QWORD *a1, _QWORD *a2, unsigned __int64 *a3)\n{\n  unsigned __int64 v5; // r12\n  __int64 v6; // rax\n  unsigned __int64 v7; // r13\n  unsigned __int64 v8; // rax\n  unsigned __int64 v9; // rcx\n  unsigned __int64 v10; // rdi\n  char *v11; // rsi\n  unsigned __int64 v12; // r12\n  char *v13; // r15\n  _QWORD *v14; // rdx\n  _QWORD *v15; // rax\n  _QWORD *v16; // rcx\n  char *v17; // r8\n  _QWORD *v18; // rcx\n  char *v19; // rdx\n  _QWORD *v20; // rcx\n  char *v21; // r9\n\n  v5 = (unsigned __int64)a2 - *a1;\n  v6 = (__int64)(a1[1] - *a1) >> 4;\n  if ( v6 == 0xFFFFFFFFFFFFFFFi64 )\n    sub_140002E18();\n  v7 = v6 + 1;\n  v8 = (__int64)(a1[2] - *a1) >> 4;\n  v9 = v8 >> 1;\n  if ( v8 <= 0xFFFFFFFFFFFFFFFi64 - (v8 >> 1) )\n  {\n    v10 = v9 + v8;\n    if ( v9 + v8 < v7 )\n      v10 = v7;\n  }\n  else\n  {\n    v10 = v7;\n  }\n  v11 = (char *)sub_14001444C((__int64)a1, v10);\n  v12 = v5 & 0xFFFFFFFFFFFFFFF0ui64;\n  v13 = &v11[v12];\n  *((_QWORD *)v13 + 1) = 0i64;\n  *v13 = 3;\n  *((_QWORD *)v13 + 1) = sub_140007BD4(a3);\n  v14 = (_QWORD *)a1[1];\n  v15 = (_QWORD *)*a1;\n  if ( a2 == v14 )\n  {\n    if ( v15 != v14 )\n    {\n      v16 = v15 + 1;\n      v17 = (char *)(v11 - (char *)v15);\n      do\n      {\n        *((_BYTE *)v16 + (_QWORD)v17 - 8) = *((_BYTE *)v16 - 8);\n        *(_QWORD *)((char *)v16 + (_QWORD)v17) = *v16;\n        *((_BYTE *)v16 - 8) = 0;\n        *v16 = 0i64;\n        v16 += 2;\n      }\n      while ( v16 - 1 != v14 );\n    }\n  }\n  else\n  {\n    if ( v15 != a2 )\n    {\n      v18 = v15 + 1;\n      v19 = (char *)(v11 - (char *)v15);\n      do\n      {\n        *((_BYTE *)v18 + (_QWORD)v19 - 8) = *((_BYTE *)v18 - 8);\n        *(_QWORD *)((char *)v18 + (_QWORD)v19) = *v18;\n        *((_BYTE *)v18 - 8) = 0;\n        *v18 = 0i64;\n        v18 += 2;\n      }\n      while ( v18 - 1 != a2 );\n      v14 = (_QWORD *)a1[1];\n    }\n    if ( a2 != v14 )\n    {\n      v20 = a2 + 1;\n      v21 = &v11[v12 - (_QWORD)a2];\n      do\n      {\n        *((_BYTE *)v20 + (_QWORD)v21 + 8) = *((_BYTE *)v20 - 8);\n        *(_QWORD *)((char *)v20 + (_QWORD)v21 + 16) = *v20;\n        *((_BYTE *)v20 - 8) = 0;\n        *v20 = 0i64;\n        v20 += 2;\n      }\n      while ( v20 - 1 != v14 );\n    }\n  }\n  sub_140013144((__int64)a1, (__int64)v11, v7, v10);\n  return v12 + *a1;\n}\n// 140002E18: using guessed type void __noreturn sub_140002E18(void);\n\n"
    },
    {
        "Function": "sub_140004884",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "3.85%",
        "Function Body": "\nunsigned __int64 __fastcall sub_140004884(_QWORD *a1, _QWORD *a2, __int64 *a3)\n{\n  unsigned __int64 v6; // r14\n  __int64 v7; // rax\n  unsigned __int64 v8; // r15\n  unsigned __int64 v9; // rax\n  unsigned __int64 v10; // rcx\n  unsigned __int64 v11; // rdi\n  char *v12; // r10\n  unsigned __int64 v13; // r14\n  char *v14; // rax\n  __int64 v15; // xmm0_8\n  _QWORD *v16; // rdx\n  _QWORD *v17; // rax\n  _QWORD *v18; // rcx\n  char *v19; // r8\n  _QWORD *v20; // rcx\n  char *v21; // rdx\n  _QWORD *v22; // rcx\n  char *v23; // r9\n\n  v6 = (unsigned __int64)a2 - *a1;\n  v7 = (__int64)(a1[1] - *a1) >> 4;\n  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )\n    sub_140002E18();\n  v8 = v7 + 1;\n  v9 = (__int64)(a1[2] - *a1) >> 4;\n  v10 = v9 >> 1;\n  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )\n  {\n    v11 = v10 + v9;\n    if ( v10 + v9 < v8 )\n      v11 = v8;\n  }\n  else\n  {\n    v11 = v8;\n  }\n  v12 = (char *)sub_14001444C((__int64)a1, v11);\n  v13 = v6 & 0xFFFFFFFFFFFFFFF0ui64;\n  v14 = &v12[v13];\n  *v14 = 0;\n  *((_QWORD *)v14 + 1) = 0i64;\n  v15 = *a3;\n  *v14 = 7;\n  *((_QWORD *)v14 + 1) = v15;\n  v16 = (_QWORD *)a1[1];\n  v17 = (_QWORD *)*a1;\n  if ( a2 == v16 )\n  {\n    if ( v17 != v16 )\n    {\n      v18 = v17 + 1;\n      v19 = (char *)(v12 - (char *)v17);\n      do\n      {\n        *((_BYTE *)v18 + (_QWORD)v19 - 8) = *((_BYTE *)v18 - 8);\n        *(_QWORD *)((char *)v18 + (_QWORD)v19) = *v18;\n        *((_BYTE *)v18 - 8) = 0;\n        *v18 = 0i64;\n        v18 += 2;\n      }\n      while ( v18 - 1 != v16 );\n    }\n  }\n  else\n  {\n    if ( v17 != a2 )\n    {\n      v20 = v17 + 1;\n      v21 = (char *)(v12 - (char *)v17);\n      do\n      {\n        *((_BYTE *)v20 + (_QWORD)v21 - 8) = *((_BYTE *)v20 - 8);\n        *(_QWORD *)((char *)v20 + (_QWORD)v21) = *v20;\n        *((_BYTE *)v20 - 8) = 0;\n        *v20 = 0i64;\n        v20 += 2;\n      }\n      while ( v20 - 1 != a2 );\n      v16 = (_QWORD *)a1[1];\n    }\n    if ( a2 != v16 )\n    {\n      v22 = a2 + 1;\n      v23 = &v12[v13 - (_QWORD)a2];\n      do\n      {\n        *((_BYTE *)v22 + (_QWORD)v23 + 8) = *((_BYTE *)v22 - 8);\n        *(_QWORD *)((char *)v22 + (_QWORD)v23 + 16) = *v22;\n        *((_BYTE *)v22 - 8) = 0;\n        *v22 = 0i64;\n        v22 += 2;\n      }\n      while ( v22 - 1 != v16 );\n    }\n  }\n  sub_140013144((__int64)a1, (__int64)v12, v8, v11);\n  return v13 + *a1;\n}\n// 140002E18: using guessed type void __noreturn sub_140002E18(void);\n\n"
    },
    {
        "Function": "sub_140004BD8",
        "Total XOR and shift operations": 4,
        "XOR operations": 0,
        "Shift operations": 4,
        "Operation percentage": "3.85%",
        "Function Body": "\nunsigned __int64 __fastcall sub_140004BD8(_QWORD *a1, _QWORD *a2, __int64 *a3)\n{\n  unsigned __int64 v6; // r14\n  __int64 v7; // rax\n  unsigned __int64 v8; // r15\n  unsigned __int64 v9; // rax\n  unsigned __int64 v10; // rcx\n  unsigned __int64 v11; // rdi\n  char *v12; // r10\n  unsigned __int64 v13; // r14\n  char *v14; // rdx\n  __int64 v15; // rax\n  _QWORD *v16; // rdx\n  _QWORD *v17; // rax\n  _QWORD *v18; // rcx\n  char *v19; // r8\n  _QWORD *v20; // rcx\n  char *v21; // rdx\n  _QWORD *v22; // rcx\n  char *v23; // r9\n\n  v6 = (unsigned __int64)a2 - *a1;\n  v7 = (__int64)(a1[1] - *a1) >> 4;\n  if ( v7 == 0xFFFFFFFFFFFFFFFi64 )\n    sub_140002E18();\n  v8 = v7 + 1;\n  v9 = (__int64)(a1[2] - *a1) >> 4;\n  v10 = v9 >> 1;\n  if ( v9 <= 0xFFFFFFFFFFFFFFFi64 - (v9 >> 1) )\n  {\n    v11 = v10 + v9;\n    if ( v10 + v9 < v8 )\n      v11 = v8;\n  }\n  else\n  {\n    v11 = v8;\n  }\n  v12 = (char *)sub_14001444C((__int64)a1, v11);\n  v13 = v6 & 0xFFFFFFFFFFFFFFF0ui64;\n  v14 = &v12[v13];\n  *v14 = 0;\n  *((_QWORD *)v14 + 1) = 0i64;\n  v15 = *a3;\n  *v14 = 5;\n  *((_QWORD *)v14 + 1) = v15;\n  v16 = (_QWORD *)a1[1];\n  v17 = (_QWORD *)*a1;\n  if ( a2 == v16 )\n  {\n    if ( v17 != v16 )\n    {\n      v18 = v17 + 1;\n      v19 = (char *)(v12 - (char *)v17);\n      do\n      {\n        *((_BYTE *)v18 + (_QWORD)v19 - 8) = *((_BYTE *)v18 - 8);\n        *(_QWORD *)((char *)v18 + (_QWORD)v19) = *v18;\n        *((_BYTE *)v18 - 8) = 0;\n        *v18 = 0i64;\n        v18 += 2;\n      }\n      while ( v18 - 1 != v16 );\n    }\n  }\n  else\n  {\n    if ( v17 != a2 )\n    {\n      v20 = v17 + 1;\n      v21 = (char *)(v12 - (char *)v17);\n      do\n      {\n        *((_BYTE *)v20 + (_QWORD)v21 - 8) = *((_BYTE *)v20 - 8);\n        *(_QWORD *)((char *)v20 + (_QWORD)v21) = *v20;\n        *((_BYTE *)v20 - 8) = 0;\n        *v20 = 0i64;\n        v20 += 2;\n      }\n      while ( v20 - 1 != a2 );\n      v16 = (_QWORD *)a1[1];\n    }\n    if ( a2 != v16 )\n    {\n      v22 = a2 + 1;\n      v23 = &v12[v13 - (_QWORD)a2];\n      do\n      {\n        *((_BYTE *)v22 + (_QWORD)v23 + 8) = *((_BYTE *)v22 - 8);\n        *(_QWORD *)((char *)v22 + (_QWORD)v23 + 16) = *v22;\n        *((_BYTE *)v22 - 8) = 0;\n        *v22 = 0i64;\n        v22 += 2;\n      }\n      while ( v22 - 1 != v16 );\n    }\n  }\n  sub_140013144((__int64)a1, (__int64)v12, v8, v11);\n  return v13 + *a1;\n}\n// 140002E18: using guessed type void __noreturn sub_140002E18(void);\n\n"
    },
    {
        "Function": "sub_140018948",
        "Total XOR and shift operations": 6,
        "XOR operations": 0,
        "Shift operations": 6,
        "Operation percentage": "1.06%",
        "Function Body": "\n__int64 __fastcall sub_140018948(__int64 a1)\n{\n  _QWORD *v2; // rdi\n  _BYTE *v3; // rax\n  char **v4; // rcx\n  char *v5; // rdx\n  char v6; // al\n  int v7; // eax\n  __int64 v8; // r8\n  const char *v9; // rax\n  int v11; // eax\n  int v12; // eax\n  int v13; // esi\n  int v14; // eax\n  unsigned __int64 v15; // rdx\n  char v16; // cl\n  char v17; // cl\n  _BYTE *v18; // rax\n  _BYTE *v19; // rax\n  unsigned __int64 v20; // rcx\n  _BYTE *v21; // rax\n  char v22; // cl\n  _BYTE *v23; // rax\n  char v24; // r9\n  unsigned __int64 v25; // rcx\n  _BYTE *v26; // rax\n  unsigned __int64 v27; // rcx\n  _BYTE *v28; // rax\n  unsigned __int64 v29; // rcx\n  _BYTE *v30; // rax\n  unsigned __int64 v31; // rcx\n  _BYTE *v32; // rax\n  unsigned __int64 v33; // rcx\n  _BYTE *v34; // rax\n  unsigned __int64 v35; // rcx\n  _BYTE *v36; // rax\n  unsigned __int64 v37; // rcx\n  _BYTE *v38; // rax\n  unsigned __int64 v39; // rcx\n  _BYTE *v40; // rax\n  __int128 *p_si128; // rdx\n  __int128 v42; // xmm0\n  char v43[16]; // [rsp+28h] [rbp-99h] BYREF\n  __m128i si128; // [rsp+38h] [rbp-89h] BYREF\n  int v45[2]; // [rsp+48h] [rbp-79h] BYREF\n  char v46; // [rsp+50h] [rbp-71h] BYREF\n  __int128 v47; // [rsp+58h] [rbp-69h] BYREF\n  int v48[2]; // [rsp+68h] [rbp-59h] BYREF\n  char v49; // [rsp+70h] [rbp-51h] BYREF\n  __m128i v50; // [rsp+78h] [rbp-49h]\n  __int128 v51; // [rsp+88h] [rbp-39h]\n  __int128 v52; // [rsp+98h] [rbp-29h]\n  __int128 v53; // [rsp+A8h] [rbp-19h]\n  __int128 v54; // [rsp+B8h] [rbp-9h]\n  __int128 v55; // [rsp+C8h] [rbp+7h]\n  __int128 v56; // [rsp+D8h] [rbp+17h]\n  __int64 v57; // [rsp+E8h] [rbp+27h]\n\n  v57 = -2i64;\n  v2 = (_QWORD *)(a1 + 72);\n  v3 = (_BYTE *)(a1 + 72);\n  if ( *(_QWORD *)(a1 + 96) >= 0x10ui64 )\n    v3 = (_BYTE *)*v2;\n  *(_QWORD *)(a1 + 88) = 0i64;\n  *v3 = 0;\n  v4 = (char **)(a1 + 48);\n  v5 = *v4;\n  v4[1] = *v4;\n  v6 = *(_BYTE *)(a1 + 16);\n  v43[0] = v6;\n  if ( v4[2] == v5 )\n  {\n    sub_1400053F4((__int64)v4, v5, v43);\n  }\n  else\n  {\n    *v5 = v6;\n    ++v4[1];\n  }\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v7 = sub_1400167E0(a1);\n        if ( v7 > 223 )\n        {\n          if ( v7 > 239 )\n          {\n            if ( v7 == 240 )\n            {\n              si128 = _mm_load_si128((const __m128i *)&xmmword_140021B30);\n              *(_QWORD *)&v56 = &si128;\n              *((_QWORD *)&v56 + 1) = &v46;\n              v42 = v56;\n            }\n            else if ( v7 <= 243 )\n            {\n              si128 = _mm_load_si128((const __m128i *)&xmmword_140021B20);\n              *(_QWORD *)&v55 = &si128;\n              *((_QWORD *)&v55 + 1) = &v46;\n              v42 = v55;\n            }\n            else\n            {\n              if ( v7 != 244 )\n                goto LABEL_19;\n              si128 = _mm_load_si128((const __m128i *)&xmmword_140021B00);\n              *(_QWORD *)&v54 = &si128;\n              *((_QWORD *)&v54 + 1) = &v46;\n              v42 = v54;\n            }\n            v45[0] = 128;\n            v45[1] = 191;\n            goto LABEL_129;\n          }\n          if ( v7 < 238 )\n          {\n            if ( v7 == 224 )\n            {\n              si128 = _mm_load_si128((const __m128i *)&xmmword_140021B40);\n              *(_QWORD *)&v52 = &si128;\n              *((_QWORD *)&v52 + 1) = v45;\n              v42 = v52;\n              goto LABEL_129;\n            }\n            if ( v7 > 236 )\n            {\n              si128 = _mm_load_si128((const __m128i *)&xmmword_140021B10);\n              *(_QWORD *)&v51 = &si128;\n              *((_QWORD *)&v51 + 1) = v45;\n              v42 = v51;\nLABEL_129:\n              v47 = v42;\n              p_si128 = &v47;\n              goto LABEL_130;\n            }\n          }\n          si128 = _mm_load_si128((const __m128i *)&xmmword_140021B20);\n          *(_QWORD *)&v53 = &si128;\n          *((_QWORD *)&v53 + 1) = v45;\n          v42 = v53;\n          goto LABEL_129;\n        }\n        if ( v7 < 194 )\n          break;\n        v48[0] = 128;\n        v48[1] = 191;\n        v50.m128i_i64[0] = (__int64)v48;\n        v50.m128i_i64[1] = (__int64)&v49;\n        si128 = v50;\n        p_si128 = (__int128 *)&si128;\nLABEL_130:\n        if ( !sub_1400172DC(a1, (__int64)p_si128) )\n          return 14i64;\n      }\n      if ( v7 <= 18 )\n      {\n        if ( v7 == 18 )\n        {\n          v9 = \"invalid string: control character U+0012 (DC2) must be escaped to \\\\u0012\";\n        }\n        else if ( v7 > 8 )\n        {\n          switch ( v7 )\n          {\n            case 9:\n              v9 = \"invalid string: control character U+0009 (HT) must be escaped to \\\\u0009 or \\\\t\";\n              break;\n            case 10:\n              v9 = \"invalid string: control character U+000A (LF) must be escaped to \\\\u000A or \\\\n\";\n              break;\n            case 11:\n              v9 = \"invalid string: control character U+000B (VT) must be escaped to \\\\u000B\";\n              break;\n            case 12:\n              v9 = \"invalid string: control character U+000C (FF) must be escaped to \\\\u000C or \\\\f\";\n              break;\n            case 13:\n              v9 = \"invalid string: control character U+000D (CR) must be escaped to \\\\u000D or \\\\r\";\n              break;\n            case 14:\n              v9 = \"invalid string: control character U+000E (SO) must be escaped to \\\\u000E\";\n              break;\n            case 15:\n              v9 = \"invalid string: control character U+000F (SI) must be escaped to \\\\u000F\";\n              break;\n            case 16:\n              v9 = \"invalid string: control character U+0010 (DLE) must be escaped to \\\\u0010\";\n              break;\n            default:\n              v9 = \"invalid string: control character U+0011 (DC1) must be escaped to \\\\u0011\";\n              break;\n          }\n        }\n        else if ( v7 == 8 )\n        {\n          v9 = \"invalid string: control character U+0008 (BS) must be escaped to \\\\u0008 or \\\\b\";\n        }\n        else if ( v7 == -1 )\n        {\n          v9 = \"invalid string: missing closing quote\";\n        }\n        else if ( v7 )\n        {\n          switch ( v7 )\n          {\n            case 1:\n              v9 = \"invalid string: control character U+0001 (SOH) must be escaped to \\\\u0001\";\n              break;\n            case 2:\n              v9 = \"invalid string: control character U+0002 (STX) must be escaped to \\\\u0002\";\n              break;\n            case 3:\n              v9 = \"invalid string: control character U+0003 (ETX) must be escaped to \\\\u0003\";\n              break;\n            case 4:\n              v9 = \"invalid string: control character U+0004 (EOT) must be escaped to \\\\u0004\";\n              break;\n            case 5:\n              v9 = \"invalid string: control character U+0005 (ENQ) must be escaped to \\\\u0005\";\n              break;\n            case 6:\n              v9 = \"invalid string: control character U+0006 (ACK) must be escaped to \\\\u0006\";\n              break;\n            case 7:\n              v9 = \"invalid string: control character U+0007 (BEL) must be escaped to \\\\u0007\";\n              break;\n            default:\nLABEL_19:\n              v9 = \"invalid string: ill-formed UTF-8 byte\";\n              break;\n          }\n        }\n        else\n        {\n          v9 = \"invalid string: control character U+0000 (NUL) must be escaped to \\\\u0000\";\n        }\n        goto LABEL_20;\n      }\n      if ( v7 > 92 )\n      {\n        if ( v7 > 127 )\n          goto LABEL_19;\n        goto LABEL_109;\n      }\n      if ( v7 != 92 )\n        break;\n      v11 = sub_1400167E0(a1);\n      switch ( v11 )\n      {\n        case '\"':\n          v39 = v2[2];\n          if ( v39 >= v2[3] )\n          {\n            v24 = 34;\n            goto LABEL_67;\n          }\n          v2[2] = v39 + 1;\n          v40 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v40 = (_BYTE *)*v2;\n          *(_WORD *)&v40[v39] = 34;\n          break;\n        case '/':\n          v37 = v2[2];\n          if ( v37 >= v2[3] )\n          {\n            v24 = 47;\n            goto LABEL_67;\n          }\n          v2[2] = v37 + 1;\n          v38 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v38 = (_BYTE *)*v2;\n          *(_WORD *)&v38[v37] = 47;\n          break;\n        case '\\\\':\n          v35 = v2[2];\n          if ( v35 >= v2[3] )\n          {\n            v24 = 92;\n            goto LABEL_67;\n          }\n          v2[2] = v35 + 1;\n          v36 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v36 = (_BYTE *)*v2;\n          *(_WORD *)&v36[v35] = 92;\n          break;\n        case 'b':\n          v33 = v2[2];\n          if ( v33 >= v2[3] )\n          {\n            v24 = 8;\n            goto LABEL_67;\n          }\n          v2[2] = v33 + 1;\n          v34 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v34 = (_BYTE *)*v2;\n          *(_WORD *)&v34[v33] = 8;\n          break;\n        case 'f':\n          v31 = v2[2];\n          if ( v31 >= v2[3] )\n          {\n            v24 = 12;\n            goto LABEL_67;\n          }\n          v2[2] = v31 + 1;\n          v32 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v32 = (_BYTE *)*v2;\n          *(_WORD *)&v32[v31] = 12;\n          break;\n        case 'n':\n          v29 = v2[2];\n          if ( v29 >= v2[3] )\n          {\n            v24 = 10;\n            goto LABEL_67;\n          }\n          v2[2] = v29 + 1;\n          v30 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v30 = (_BYTE *)*v2;\n          *(_WORD *)&v30[v29] = 10;\n          break;\n        case 'r':\n          v27 = v2[2];\n          if ( v27 >= v2[3] )\n          {\n            v24 = 13;\n            goto LABEL_67;\n          }\n          v2[2] = v27 + 1;\n          v28 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v28 = (_BYTE *)*v2;\n          *(_WORD *)&v28[v27] = 13;\n          break;\n        case 't':\n          v25 = v2[2];\n          if ( v25 >= v2[3] )\n          {\n            v24 = 9;\n            goto LABEL_67;\n          }\n          v2[2] = v25 + 1;\n          v26 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v26 = (_BYTE *)*v2;\n          *(_WORD *)&v26[v25] = 9;\n          break;\n        case 'u':\n          v12 = sub_1400168A4(a1);\n          v13 = v12;\n          if ( v12 == -1 )\n            goto LABEL_155;\n          if ( (unsigned int)(v12 - 55296) > 0x3FF )\n          {\n            if ( (unsigned int)(v12 - 56320) <= 0x3FF )\n            {\n              v9 = \"invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF\";\n              goto LABEL_20;\n            }\n          }\n          else\n          {\n            if ( (unsigned int)sub_1400167E0(a1) != 92 || (unsigned int)sub_1400167E0(a1) != 117 )\n            {\nLABEL_154:\n              v9 = \"invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF\";\n              goto LABEL_20;\n            }\n            v14 = sub_1400168A4(a1);\n            if ( v14 == -1 )\n            {\nLABEL_155:\n              v9 = \"invalid string: '\\\\u' must be followed by 4 hex digits\";\n              goto LABEL_20;\n            }\n            if ( (unsigned int)(v14 - 56320) > 0x3FF )\n              goto LABEL_154;\n            v13 = v14 + ((v13 - 55287) << 10);\n          }\n          if ( v13 >= 128 )\n          {\n            v15 = v2[2];\n            if ( v13 > 2047 )\n            {\n              if ( v13 > 0xFFFF )\n              {\n                v22 = (v13 >> 18) | 0xF0;\n                if ( v15 >= v2[3] )\n                {\n                  LOBYTE(v8) = 0;\n                  sub_1400070D0(v2, 1ui64, v8, v22);\n                }\n                else\n                {\n                  v2[2] = v15 + 1;\n                  v23 = v2;\n                  if ( v2[3] >= 0x10ui64 )\n                    v23 = (_BYTE *)*v2;\n                  v23[v15] = v22;\n                  v23[v15 + 1] = 0;\n                }\n                v17 = (v13 >> 12) & 0x3F | 0x80;\n                v15 = v2[2];\n              }\n              else\n              {\n                v17 = (v13 >> 12) | 0xE0;\n              }\n              if ( v15 >= v2[3] )\n              {\n                LOBYTE(v8) = 0;\n                sub_1400070D0(v2, 1ui64, v8, v17);\n              }\n              else\n              {\n                v2[2] = v15 + 1;\n                v18 = v2;\n                if ( v2[3] >= 0x10ui64 )\n                  v18 = (_BYTE *)*v2;\n                v18[v15] = v17;\n                v18[v15 + 1] = 0;\n              }\n              v16 = (v13 >> 6) & 0x3F | 0x80;\n              v15 = v2[2];\n            }\n            else\n            {\n              v16 = (v13 >> 6) | 0xC0;\n            }\n            if ( v15 >= v2[3] )\n            {\n              LOBYTE(v8) = 0;\n              sub_1400070D0(v2, 1ui64, v8, v16);\n            }\n            else\n            {\n              v2[2] = v15 + 1;\n              v19 = v2;\n              if ( v2[3] >= 0x10ui64 )\n                v19 = (_BYTE *)*v2;\n              v19[v15] = v16;\n              v19[v15 + 1] = 0;\n            }\n            LOBYTE(v13) = v13 & 0x3F | 0x80;\n          }\n          v20 = v2[2];\n          if ( v20 >= v2[3] )\n          {\n            v24 = v13;\n            goto LABEL_67;\n          }\n          v2[2] = v20 + 1;\n          v21 = v2;\n          if ( v2[3] >= 0x10ui64 )\n            v21 = (_BYTE *)*v2;\n          v21[v20] = v13;\nLABEL_113:\n          v21[v20 + 1] = 0;\n          break;\n        default:\n          v9 = \"invalid string: forbidden character after backslash\";\n          goto LABEL_20;\n      }\n    }\n    if ( v7 <= 27 )\n    {\n      switch ( v7 )\n      {\n        case 27:\n          v9 = \"invalid string: control character U+001B (ESC) must be escaped to \\\\u001B\";\n          break;\n        case 19:\n          v9 = \"invalid string: control character U+0013 (DC3) must be escaped to \\\\u0013\";\n          break;\n        case 20:\n          v9 = \"invalid string: control character U+0014 (DC4) must be escaped to \\\\u0014\";\n          break;\n        case 21:\n          v9 = \"invalid string: control character U+0015 (NAK) must be escaped to \\\\u0015\";\n          break;\n        case 22:\n          v9 = \"invalid string: control character U+0016 (SYN) must be escaped to \\\\u0016\";\n          break;\n        case 23:\n          v9 = \"invalid string: control character U+0017 (ETB) must be escaped to \\\\u0017\";\n          break;\n        case 24:\n          v9 = \"invalid string: control character U+0018 (CAN) must be escaped to \\\\u0018\";\n          break;\n        case 25:\n          v9 = \"invalid string: control character U+0019 (EM) must be escaped to \\\\u0019\";\n          break;\n        default:\n          v9 = \"invalid string: control character U+001A (SUB) must be escaped to \\\\u001A\";\n          break;\n      }\n      goto LABEL_20;\n    }\n    switch ( v7 )\n    {\n      case 28:\n        v9 = \"invalid string: control character U+001C (FS) must be escaped to \\\\u001C\";\n        goto LABEL_20;\n      case 29:\n        v9 = \"invalid string: control character U+001D (GS) must be escaped to \\\\u001D\";\n        goto LABEL_20;\n      case 30:\n        v9 = \"invalid string: control character U+001E (RS) must be escaped to \\\\u001E\";\n        goto LABEL_20;\n      case 31:\n        v9 = \"invalid string: control character U+001F (US) must be escaped to \\\\u001F\";\nLABEL_20:\n        *(_QWORD *)(a1 + 104) = v9;\n        return 14i64;\n    }\n    if ( v7 > 33 )\n      break;\nLABEL_109:\n    v24 = *(_BYTE *)(a1 + 16);\n    v20 = v2[2];\n    if ( v20 < v2[3] )\n    {\n      v2[2] = v20 + 1;\n      v21 = v2;\n      if ( v2[3] >= 0x10ui64 )\n        v21 = (_BYTE *)*v2;\n      v21[v20] = v24;\n      goto LABEL_113;\n    }\nLABEL_67:\n    LOBYTE(v8) = 0;\n    sub_1400070D0(v2, 1ui64, v8, v24);\n  }\n  if ( v7 != 34 )\n  {\n    if ( (unsigned int)(v7 - 35) > 0x38 )\n      goto LABEL_19;\n    goto LABEL_109;\n  }\n  return 4i64;\n}\n// 140018A21: conditional instruction was optimized away because eax.4 is in (20..5B)\n// 140018EAB: conditional instruction was optimized away because ecx.4==ED\n// 140018F31: conditional instruction was optimized away because ecx.4>=F1\n// 140018E97: conditional instruction was optimized away because eax.4 is in (E1..ED)\n// 14001904A: conditional instruction was optimized away because eax.4==1A\n// 1400191DC: conditional instruction was optimized away because eax.4==11\n// 140018BAD: variable 'v8' is possibly undefined\n// 140021B00: using guessed type __int128 xmmword_140021B00;\n// 140021B10: using guessed type __int128 xmmword_140021B10;\n// 140021B20: using guessed type __int128 xmmword_140021B20;\n// 140021B30: using guessed type __int128 xmmword_140021B30;\n// 140021B40: using guessed type __int128 xmmword_140021B40;\n// 140018948: using guessed type char var_F0[16];\n\n"
    }
]