[
    {
        "Function": "sub_4009E5",
        "Total XOR and shift operations": 4,
        "XOR operations": 4,
        "Shift operations": 0,
        "Operation percentage": "8.89%",
        "Function Body": "\nunsigned __int64 sub_4009E5()\n{\n  unsigned __int64 result; // rax\n  struct _FIE416ME v1; // r12\n  __int64 CurrentProcessId; // rbp\n  DWORD CurrentThreadId; // edi\n  DWORD TickCount; // esi\n  LOFE2CNG v5; // rsi\n  struct _FIE416ME SystemTimeAsFileTime; // [rsp+20h] [rbp-48h] BYREF\n  LARGE_IN123ER PerformanceCount; // [rsp+30h] [rbp-38h] BYREF\n\n  result = 0x2B7842DF68A7i64;\n  SystemTimeAsFileTime = 0i64;\n  if ( qword_40EA46 == 0x2B7842DF68A7i64 )\n  {\n    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);\n    v1 = SystemTimeAsFileTime;\n    CurrentProcessId = GetCurrentProcessId();\n    CurrentThreadId = GetCurrentThreadId();\n    TickCount = GetTickCount();\n    QueryPerformanceCounter(&PerformanceCount);\n    v5 = (TickCount ^ CurrentThreadId ^ PerformanceCount.QuadPart ^ *(_QWORD *)&v1 ^ CurrentProcessId) & 0xFF9F59FF9F59i64;\n    if ( v5 == 0x2B7842DF68A7i64 )\n    {\n      result = 0xFFF1D1663EC55DCCui64;\n      v5 = 0x2B7842DF6563i64;\n    }\n    else\n    {\n      result = ~v5;\n    }\n    qword_40EA46 = v5;\n    qword_404987 = result;\n  }\n  else\n  {\n    qword_404987 = ~qword_40EA46;\n  }\n  return result;\n}\n// 40EA46: using guessed type __int64 qword_40EA46;\n// 404987: using guessed type __int64 qword_404987;\n\n"
    },
    {
        "Function": "sub_405D69",
        "Total XOR and shift operations": 3,
        "XOR operations": 0,
        "Shift operations": 3,
        "Operation percentage": "0.70%",
        "Function Body": "\n__int64 __fastcall sub_405D69(const char *a1, __int64 a2, __int64 a3, _DWORD *a4, _QWORD *a5)\n{\n  __int64 v8; // rax\n  __int64 result; // rax\n  __int64 v10; // rdx\n  __int64 v11; // rdi\n  __int64 v12; // rbx\n  const char *v13; // rdx\n  __int64 v14; // rax\n  unsigned int v15; // eax\n  int v16; // ebx\n  __int64 v17; // rax\n  __int64 v18; // rsi\n  __int64 v19; // r15\n  int v20; // esi\n  int v21; // r14d\n  int v22; // r13d\n  int v23; // r12d\n  __int64 v24; // rsi\n  __int64 v25; // rax\n  __int64 v26; // rbx\n  unsigned int v27; // eax\n  int v28; // ebx\n  __int64 v29; // r8\n  __int64 i; // rax\n  __int64 v31; // rax\n  int v32; // esi\n  __int64 v33; // rax\n  unsigned int v34; // edi\n  __int64 v35; // rdi\n  __int64 v36; // r12\n  int *v37; // r13\n  _BYTE *v38; // r14\n  int v39; // ebp\n  int v40; // eax\n  char v41; // cl\n  __int64 v42; // rax\n  _BYTE *v43; // r8\n  int v44; // edx\n  int v45; // eax\n  int v46; // r9d\n  _BYTE *v47; // rcx\n  __int64 v48; // rdx\n  char v49; // al\n  __int64 v50; // r13\n  __int64 v51; // rax\n  __int64 v52; // rbx\n  unsigned int v53; // r12d\n  __int64 v54; // rsi\n  __int64 v55; // r12\n  __int64 v56; // rdx\n  const char *v57; // r8\n  __int64 v58; // rbx\n  unsigned int v59; // eax\n  __int64 v60; // rax\n  __int64 v61; // rbx\n  unsigned int v62; // eax\n  int *v63; // rax\n  __int64 v64; // rdi\n  const char *v65; // rdx\n  const char *v66; // r8\n  __int64 v67; // rsi\n  int *v68; // rax\n  unsigned int v69; // ebx\n  unsigned int v70; // eax\n  __int64 v71; // [rsp+20h] [rbp-F8h]\n  unsigned int v72; // [rsp+40h] [rbp-D8h]\n  unsigned int v73; // [rsp+40h] [rbp-D8h]\n  int v74; // [rsp+40h] [rbp-D8h]\n  int v75; // [rsp+40h] [rbp-D8h]\n  int v76; // [rsp+48h] [rbp-D0h]\n  int *v77; // [rsp+48h] [rbp-D0h]\n  int v78; // [rsp+54h] [rbp-C4h]\n  _BYTE *Block; // [rsp+58h] [rbp-C0h]\n  int v80; // [rsp+70h] [rbp-A8h]\n  unsigned int v81; // [rsp+74h] [rbp-A4h]\n  __int64 v82; // [rsp+78h] [rbp-A0h]\n  __int64 v83; // [rsp+88h] [rbp-90h] BYREF\n  int v84; // [rsp+90h] [rbp-88h] BYREF\n  int v85; // [rsp+94h] [rbp-84h]\n  int v86; // [rsp+98h] [rbp-80h]\n  int v87; // [rsp+9Ch] [rbp-7Ch]\n  char v88[120]; // [rsp+A0h] [rbp-78h] BYREF\n  _DWORD *v89; // [rsp+138h] [rbp+20h]\n\n  v83 = 0i64;\n  v8 = gimp_locale_directory();\n  libintl_bindtextdomain(\"gimp20-std-plug-ins\", v8);\n  libintl_bind_textdomain_codeset(\"gimp20-std-plug-ins\", \"UTF-8\");\n  libintl_textdomain(\"gimp20-std-plug-ins\");\n  *a4 = 1;\n  *a5 = &dword_40DC0D;\n  result = 1i64;\n  dword_40DC0D = 21;\n  dword_40C657 = 0;\n  if ( strcmp(a1, \"file-jp2-load\") )\n    goto LABEL_2;\n  v11 = *(_QWORD *)(a3 + 48);\n  jas_init();\n  v12 = gimp_filename_to_utf8(v11);\n  v14 = libintl_gettext(\"Opening '%s'\", v13);\n  gimp_progress_init_printf(v14, v12);\n  v15 = g_open(v11, 0x8000i64, 0i64);\n  v16 = v15;\n  if ( v15 == -1 || (v17 = jas_stream_fdopen(v15, \"rb\"), (v18 = v17) == 0) )\n  {\n    v63 = _errno();\n    g_strerror((unsigned int)*v63);\n    v64 = gimp_filename_to_utf8(v11);\n    v67 = libintl_gettext(\"Could not open '%s' for reading: %s\", v65, v66);\n    v68 = _errno();\n    v69 = g_file_error_from_errno((unsigned int)*v68);\n    v70 = g_file_error_quark();\n    g_set_error(&v83, v70, v69, v67, v64);\n    result = 0i64;\n    goto LABEL_2;\n  }\n  v19 = jas_image_decode(v17, 0xFF9F59FFi64, 0i64);\n  if ( !v19 )\n  {\n    v24 = gimp_filename_to_utf8(v11);\n    v25 = libintl_gettext(\"Couldn't decode '%s'.\");\n    goto LABEL_10;\n  }\n  gimp_progress_update();\n  jas_stream_close(v18);\n  close(v16);\n  v20 = *(_DWORD *)(v19 + 8);\n  v21 = *(_DWORD *)v19;\n  v22 = *(_DWORD *)(v19 + 12);\n  v23 = *(_DWORD *)(v19 + 4);\n  switch ( *(int *)(v19 + 32) >> 8 )\n  {\n    case 1:\n      v24 = gimp_filename_to_utf8(v11);\n      v25 = libintl_gettext(\"The image '%s' is in the CI14E7 color space, but there is no code in place to convert it to RGB.\");\n      goto LABEL_10;\n    case 2:\n      v24 = gimp_filename_to_utf8(v11);\n      v25 = libintl_gettext(\"The image '%s' is in the CI8608 color space, but there is no code in place to convert it to RGB.\");\n      goto LABEL_10;\n    case 3:\n      v78 = jas_image_getcmptbytype(v19, 0i64);\n      v84 = v78;\n      if ( v78 != -1 )\n      {\n        v72 = 1;\n        v85 = jas_image_getcmptbytype(v19, 0x8000i64);\n        v28 = (v85 != -1) + 1;\n        v76 = (v85 != -1) + 2;\n        goto LABEL_16;\n      }\n      v24 = gimp_filename_to_utf8(v11);\n      v25 = libintl_gettext(\"The image '%s' is in grayscale but does not contain any gray component.\");\n      goto LABEL_10;\n    case 4:\n      v78 = jas_image_getcmptbytype(v19, 0i64);\n      v84 = v78;\n      v85 = jas_image_getcmptbytype(v19, 1i64);\n      v45 = jas_image_getcmptbytype(v19, 2i64);\n      v86 = v45;\n      if ( v85 == -1 || v78 == -1 || v45 == -1 )\n      {\n        v24 = gimp_filename_to_utf8(v11);\n        v25 = libintl_gettext(\"The image '%s' is in RGB, but is missing some of the components.\");\nLABEL_10:\n        v26 = v25;\n        v27 = g_file_error_quark();\n        g_set_error(&v83, v27, 24i64, v26, v24);\n        goto LABEL_11;\n      }\n      v87 = jas_image_getcmptbytype(v19, 0x8000i64);\n      if ( v87 == -1 )\n      {\n        v72 = 0;\n        v87 = jas_image_getcmptbytype(v19, 3i64);\n        v28 = (v87 != -1) + 3;\n        v76 = v87 != -1;\n      }\n      else\n      {\n        v28 = 4;\n        v72 = 0;\n        v76 = 1;\n      }\nLABEL_16:\n      v29 = 0i64;\n      for ( i = v78; ; i = *(&v84 + v29) )\n      {\n        v31 = *(_QWORD *)(*(_QWORD *)(v19 + 24) + 8 * i);\n        if ( *(_QWORD *)v31 != *(_QWORD *)v19\n          || *(_DWORD *)v31 + *(_DWORD *)(v31 + 8) * *(_DWORD *)(v31 + 16) != *(_DWORD *)(v19 + 8)\n          || *(_DWORD *)(v31 + 4) + *(_DWORD *)(v31 + 12) * *(_DWORD *)(v31 + 20) != *(_DWORD *)(v19 + 12) )\n        {\n          v74 = v29;\n          gimp_filename_to_utf8(v11);\n          v58 = libintl_gettext(\n                  \"Image component %d of image '%s' does not have the same size as the image. This is currently not supported.\",\n                  v56,\n                  v57);\n          v59 = g_file_error_quark();\n          LOFA4CD(v71) = v74;\n          g_set_error(&v83, v59, 24i64, v58, v71);\n          result = 0i64;\n          goto LABEL_2;\n        }\n        if ( *(_QWORD *)(v31 + 8) != 0x107921001i64 )\n        {\n          v75 = v29;\n          gimp_filename_to_utf8(v11);\n          v60 = libintl_gettext(\"Image component %d of image '%s' does not have both a hstep and vstep.\");\nLABEL_53:\n          v61 = v60;\n          v62 = g_file_error_quark();\n          LOFA4CD(v71) = v75;\n          g_set_error(&v83, v62, 24i64, v61, v71);\n          result = 0i64;\n          goto LABEL_2;\n        }\n        if ( *(_DWORD *)(v31 + 28) )\n        {\n          v75 = v29;\n          gimp_filename_to_utf8(v11);\n          v60 = libintl_gettext(\"Image component %d of image '%s' is signed. This is currently not supported.\");\n          goto LABEL_53;\n        }\n        if ( v28 <= (int)++v29 )\n          break;\n      }\n      v32 = v20 - v21;\n      v80 = v22 - v23;\n      v81 = gimp_image_new((unsigned int)v32, (unsigned int)(v22 - v23), v72);\n      gimp_image_set_filename(v81, v11);\n      v33 = libintl_gettext(\"Background\");\n      v34 = gimp_layer_new(v81, v33, (unsigned int)v32, (unsigned int)(v22 - v23), v76, 0x40BC7500A5820000i64, 0);\n      gimp_image_insert_layer(v81, v34, 0xFF9F59FFi64, 0i64);\n      v82 = gimp_drawable_get(v34);\n      gimp_tile_cache_ntiles(*(unsigned int *)(v82 + 20));\n      gimp_pixel_rgn_init(v88, v82, 0i64, 0i64, v32, v22 - v23, 1, 0);\n      Block = malloc(v28 * v32);\n      v35 = jas_matrix_create(1i64, (unsigned int)v32);\n      if ( v22 - v23 <= 0 )\n        goto LABEL_45;\n      v73 = 0;\n      v89 = a4;\n      v77 = &v84 + (unsigned int)(v28 - 1);\n      v36 = 4i64 * (unsigned int)(v32 - 1) + 4;\n      while ( 2 )\n      {\n        v37 = &v84;\n        v38 = Block;\n        v39 = v78;\n        while ( 2 )\n        {\n          jas_image_readcmpt(v19, (unsigned int)v39, 0i64, v73, v32, 1, v35);\n          v40 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v19 + 24) + 8i64 * v39) + 24i64);\n          if ( v40 > 7 )\n          {\n            v41 = v40 - 8;\n            if ( v40 == 8 )\n              v41 = 0;\n            v42 = 0i64;\n            v43 = v38;\n            if ( v32 > 0 )\n            {\n              do\n              {\n                v44 = *(_DWORD *)(**(_QWORD **)(v35 + 32) + v42);\n                v42 += 4i64;\n                *v43 = v44 >> v41;\n                v43 += v28;\n              }\n              while ( v36 != v42 );\n            }\n            goto LABEL_32;\n          }\n          v46 = 1 << (8 - v40);\n          if ( v32 <= 0 )\n          {\nLABEL_32:\n            ++v38;\n            if ( v37 == v77 )\n              break;\n            goto LABEL_33;\n          }\n          v47 = v38;\n          v48 = 0i64;\n          do\n          {\n            v49 = *(_BYTE *)(**(_QWORD **)(v35 + 32) + v48) * v46;\n            v48 += 4i64;\n            *v47 = v49;\n            v47 += v28;\n          }\n          while ( v48 != v36 );\n          ++v38;\n          if ( v37 != v77 )\n          {\nLABEL_33:\n            v39 = v37[1];\n            ++v37;\n            continue;\n          }\n          break;\n        }\n        gimp_pixel_rgn_set_rect(v88, Block, 0i64, v73++, v32, 1);\n        if ( v80 != v73 )\n          continue;\n        break;\n      }\n      a4 = v89;\nLABEL_45:\n      gimp_progress_update();\n      if ( *(_QWORD *)(v19 + 40) )\n      {\n        v50 = jas_iccprof_createfromcmprof();\n        if ( v50 )\n        {\n          v51 = jas_stream_memopen(0i64, 0xFF9F59FFi64);\n          v52 = v51;\n          if ( v51 )\n          {\n            jas_iccprof_save(v50, v51);\n            jas_stream_rewind(v52);\n            v53 = jas_stream_length(v52);\n            v54 = g_malloc();\n            jas_stream_read(v52, v54, v53);\n            v55 = gimp_parasite_new(\"icc-profile\", 3i64, v53, v54);\n            gimp_image_attach_parasite(v81, v55);\n            gimp_parasite_free(v55);\n            g_free(v54);\n            jas_stream_close(v52);\n            jas_iccprof_destroy(v50);\n          }\n        }\n      }\n      jas_matrix_destroy(v35);\n      free(Block);\n      jas_image_destroy(v19);\n      gimp_drawable_flush(v82);\n      _IAT_start__(v82);\n      jas_cleanup();\n      if ( v81 != -1 )\n      {\n        *a4 = 2;\n        LOFA4CD(qword_403EF8) = v81;\n        result = 3i64;\n        dword_40E6B3 = 13;\n        goto LABEL_4;\n      }\nLABEL_11:\n      result = 0i64;\nLABEL_2:\n      if ( v83 )\n      {\n        v10 = *(_QWORD *)(v83 + 8);\n        *a4 = 2;\n        dword_40E6B3 = 4;\n        qword_403EF8 = v10;\n      }\nLABEL_4:\n      dword_40C657 = result;\n      return result;\n    case 5:\n      v24 = gimp_filename_to_utf8(v11);\n      v25 = libintl_gettext(\"The image '%s' is in the YCbCr color space, but there is no code in place to convert it to RGB.\");\n      goto LABEL_10;\n    default:\n      v24 = gimp_filename_to_utf8(v11);\n      v25 = libintl_gettext(\"The image '%s' is in an unknown color space.\");\n      goto LABEL_10;\n  }\n}\n// 40457A: variable 'v13' is possibly undefined\n// 4040F5: variable 'v56' is possibly undefined\n// 4040F5: variable 'v57' is possibly undefined\n// 40C386: variable 'v71' is possibly undefined\n// 403CDC: variable 'v65' is possibly undefined\n// 403CDC: variable 'v66' is possibly undefined\n// 40C832: using guessed type __int64 __fastcall gimp_tile_cache_ntiles(_QWORD);\n// 406962: using guessed type __int64 gimp_progress_update(void);\n// 406846: using guessed type __int64 __fastcall gimp_progress_init_printf(_QWORD, _QWORD);\n// 40EBB0: using guessed type __int64 __fastcall gimp_pixel_rgn_set_rect(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);\n// 4082B0: using guessed type __int64 __fastcall gimp_pixel_rgn_init(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD, _DWORD);\n// 40F929: using guessed type __int64 __fastcall gimp_layer_new(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);\n// 40BC31: using guessed type __int64 __fastcall gimp_image_set_filename(_QWORD, _QWORD);\n// 40C29B: using guessed type __int64 __fastcall gimp_image_new(_QWORD, _QWORD, _QWORD);\n// 40EC86: using guessed type __int64 __fastcall gimp_image_insert_layer(_QWORD, _QWORD, _QWORD, _QWORD);\n// 40713A: using guessed type __int64 __fastcall gimp_image_attach_parasite(_QWORD, _QWORD);\n// 404A65: using guessed type __int64 __fastcall gimp_drawable_get(_QWORD);\n// 40756A: using guessed type __int64 __fastcall gimp_drawable_flush(_QWORD);\n// 401D0E: using guessed type __int64 __fastcall _IAT_start__(_QWORD);\n// 40154E: using guessed type __int64 __fastcall gimp_parasite_new(_QWORD, _QWORD, _QWORD, _QWORD);\n// 4079B9: using guessed type __int64 __fastcall gimp_parasite_free(_QWORD);\n// 40A106: using guessed type __int64 gimp_locale_directory(void);\n// 40B71F: using guessed type __int64 __fastcall gimp_filename_to_utf8(_QWORD);\n// 40BBF8: using guessed type __int64 __fastcall g_strerror(_QWORD);\n// 40E70D: using guessed type __int64 __fastcall g_open(_QWORD, _QWORD, _QWORD);\n// 40FBFB: using guessed type __int64 g_malloc(void);\n// 400DED: using guessed type __int64 __fastcall g_free(_QWORD);\n// 40D1B4: using guessed type __int64 g_file_error_quark(void);\n// 4064B8: using guessed type __int64 __fastcall g_file_error_from_errno(_QWORD);\n// 408E69: using guessed type __int64 __fastcall jas_stream_rewind(_QWORD);\n// 40886F: using guessed type __int64 __fastcall jas_stream_read(_QWORD, _QWORD, _QWORD);\n// 40157A: using guessed type __int64 __fastcall jas_stream_memopen(_QWORD, _QWORD);\n// 40A7E5: using guessed type __int64 __fastcall jas_stream_length(_QWORD);\n// 40B21F: using guessed type __int64 __fastcall jas_stream_fdopen(_QWORD, _QWORD);\n// 40B0A0: using guessed type __int64 __fastcall jas_stream_close(_QWORD);\n// 409426: using guessed type __int64 __fastcall jas_matrix_destroy(_QWORD);\n// 4010B1: using guessed type __int64 __fastcall jas_matrix_create(_QWORD, _QWORD);\n// 40835D: using guessed type __int64 jas_init(void);\n// 400557: using guessed type __int64 __fastcall jas_image_readcmpt(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD);\n// 405C77: using guessed type __int64 __fastcall jas_image_getcmptbytype(_QWORD, _QWORD);\n// 4068DE: using guessed type __int64 __fastcall jas_image_destroy(_QWORD);\n// 401387: using guessed type __int64 __fastcall jas_image_decode(_QWORD, _QWORD, _QWORD);\n// 400DFF: using guessed type __int64 __fastcall jas_iccprof_save(_QWORD, _QWORD);\n// 40E1BB: using guessed type __int64 __fastcall jas_iccprof_destroy(_QWORD);\n// 40A1AF: using guessed type __int64 jas_iccprof_createfromcmprof(void);\n// 408E97: using guessed type __int64 jas_cleanup(void);\n// 407592: using guessed type __int64 __fastcall libintl_textdomain(_QWORD);\n// 40377B: using guessed type __int64 libintl_gettext(const char *, ...);\n// 406E59: using guessed type __int64 __fastcall libintl_bindtextdomain(_QWORD, _QWORD);\n// 40D234: using guessed type __int64 __fastcall libintl_bind_textdomain_codeset(_QWORD, _QWORD);\n// 40DC0D: using guessed type int dword_40DC0D;\n// 40C657: using guessed type int dword_40C657;\n// 40E6B3: using guessed type int dword_40E6B3;\n// 403EF8: using guessed type __int64 qword_403EF8;\n\n"
    },
    {
        "Function": "sub_40F0AF",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n// write access to const memory has been detected, the output may be wrong!\n__int64 sub_40F0AF()\n{\n  BOOL v0; // edx\n  __int16 v2; // cx\n\n  v0 = 0;\n  unk_40D78C = 1;\n  unk_40D114 = 1;\n  unk_4053DE = 1;\n  unk_407289 = 1;\n  if ( ME7909[0x40F0D8] == 23117 && *(_DWORD *)(ME7909[0x40B15B] + 0x40F0D8i64) == 17744 )\n  {\n    v2 = *(_WORD *)(ME7909[0x40B15B] + 0x40D2CCi64);\n    if ( v2 == 267 )\n    {\n      if ( *(_DWORD *)(ME7909[0x40B15B] + 0x40F067i64) > 0xEu )\n        v0 = *(_DWORD *)(ME7909[0x40B15B] + 0x40DE97i64) != 0;\n    }\n    else if ( v2 == 523 && *(_DWORD *)(ME7909[0x40B15B] + 0x4066F1i64) > 0xEu )\n    {\n      v0 = *(_DWORD *)(ME7909[0x40B15B] + 0x406AA7i64) != 0;\n    }\n  }\n  dword_40F97B = v0;\n  if ( unk_406FDA )\n    _set_app_type(_crt_gui_app);\n  else\n    _set_app_type(_crt_console_app);\n  qword_404669 = sub_402EB2(-1i64);\n  qword_408731 = qword_404669;\n  _fmode = unk_40A497;\n  sub_405E0A();\n  if ( unk_403D96 == 1 )\n    sub_40D44E((_UserMathErrorFunctionPointer)sub_40505E);\n  return 0i64;\n}\n// 4023EB: write access to const memory at 4039A2 has been detected\n// 40F0AF: using guessed type __int64 sub_40F0AF();\n// 405E0A: using guessed type __int64 sub_405E0A(void);\n// 40F97B: using guessed type int dword_40F97B;\n// 408731: using guessed type __int64 qword_408731;\n// 404669: using guessed type __int64 qword_404669;\n\n"
    },
    {
        "Function": "sub_408E00",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_408E00()\n{\n  __int64 result; // rax\n\n  dword_40C10C = unk_40E587;\n  result = _getmainargs(&argc, &argv, &envp, unk_402847, &dword_40C10C);\n  dword_40C775 = result;\n  return result;\n}\n// 408E00: using guessed type __int64 sub_408E00();\n// 407749: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);\n// 40C10C: using guessed type int dword_40C10C;\n// 40C775: using guessed type int dword_40C775;\n\n"
    },
    {
        "Function": "sub_40F27E",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_40F27E()\n{\n  unk_406FDA = 0;\n  sub_4009E5();\n  return sub_40EC86();\n}\n// 40EC86: using guessed type __int64 sub_40EC86(void);\n// 40F27E: using guessed type __int64 sub_40F27E();\n\n"
    },
    {
        "Function": "sub_4078A5",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid sub_4078A5()\n{\n  ;\n}\n\n"
    },
    {
        "Function": "sub_4028CA",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_4028CA()\n{\n  HME51CE ModuleHandleA; // rax\n  FAFB8CC ProcAddress; // rax\n\n  if ( qword_40D366 )\n  {\n    ModuleHandleA = GetModuleHandleA(\"libgcj-16.dll\");\n    if ( ModuleHandleA )\n    {\n      ProcAddress = GetProcAddress(ModuleHandleA, \"_Jv_RegisterClasses\");\n      if ( ProcAddress )\n        ((void (__fastcall *)(__int64 *))ProcAddress)(&qword_40D366);\n    }\n    else\n    {\n      ((void (__fastcall *)(__int64 *))sub_4078A5)(&qword_40D366);\n    }\n  }\n  return sub_40B54D((int (__cdecl *)())sub_40733E);\n}\n// 4028CA: using guessed type __int64 sub_4028CA();\n// 40D366: using guessed type __int64 qword_40D366;\n\n"
    },
    {
        "Function": "sub_40733E",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid sub_40733E()\n{\n  ;\n}\n\n"
    },
    {
        "Function": "sub_40025D",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_40025D()\n{\n  gimp_install_procedure(\n    \"file-jp2-load\",\n    \"Loads JPEG 2000 images.\",\n    \"The JPEG 2000 image loader.\",\n    \"Aurimas Ju\u0161ka\",\n    \"Aurimas Ju\u0161ka, Florian Traverse\",\n    \"2009\",\n    \"JPEG 2000 image\",\n    0i64,\n    1,\n    3,\n    1,\n    &unk_4040CA,\n    \"\\r\");\n  gimp_register_magic_load_handler(\"file-jp2-load\", \"jp2,jpc,jpx,j2k,jpf\", &unk_40E899, &unk_408651);\n  return gimp_register_file_handler_mime(\"file-jp2-load\", \"image/jp2\");\n}\n// 40025D: using guessed type __int64 sub_40025D();\n// 406F22: using guessed type __int64 __fastcall gimp_register_magic_load_handler(_QWORD, _QWORD, _QWORD, _QWORD);\n// 400BB0: using guessed type __int64 __fastcall gimp_register_file_handler_mime(_QWORD, _QWORD);\n// 409F9E: using guessed type __int64 __fastcall gimp_install_procedure(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD, _QWORD, _QWORD);\n\n"
    },
    {
        "Function": "sub_40A1D5",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_40A1D5()\n{\n  return gimp_main(&unk_40EA17, (unsigned int)__argc, __argv);\n}\n// 40A1D5: using guessed type __int64 sub_40A1D5();\n// 40DB25: using guessed type __int64 __fastcall gimp_main(_QWORD, _QWORD, _QWORD);\n\n"
    }
]