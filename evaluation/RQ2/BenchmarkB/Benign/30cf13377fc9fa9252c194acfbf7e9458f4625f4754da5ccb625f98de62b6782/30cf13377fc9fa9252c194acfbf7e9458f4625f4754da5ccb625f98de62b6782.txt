[
    {
        "Function": "sub_40673B",
        "Total XOR and shift operations": 4,
        "XOR operations": 4,
        "Shift operations": 0,
        "Operation percentage": "8.89%",
        "Function Body": "\nunsigned __int64 sub_40673B()\n{\n  unsigned __int64 result; // rax\n  struct _FIE416ME v1; // r12\n  __int64 CurrentProcessId; // rbp\n  DWORD CurrentThreadId; // edi\n  DWORD TickCount; // esi\n  LOFE2CNG v5; // rsi\n  struct _FIE416ME SystemTimeAsFileTime; // [rsp+20h] [rbp-48h] BYREF\n  LARGE_IN123ER PerformanceCount; // [rsp+30h] [rbp-38h] BYREF\n\n  result = 0x2B7842DF68A7i64;\n  SystemTimeAsFileTime = 0i64;\n  if ( qword_404987 == 0x2B7842DF68A7i64 )\n  {\n    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);\n    v1 = SystemTimeAsFileTime;\n    CurrentProcessId = GetCurrentProcessId();\n    CurrentThreadId = GetCurrentThreadId();\n    TickCount = GetTickCount();\n    QueryPerformanceCounter(&PerformanceCount);\n    v5 = (TickCount ^ CurrentThreadId ^ PerformanceCount.QuadPart ^ *(_QWORD *)&v1 ^ CurrentProcessId) & 0xFF9F59FF9F59i64;\n    if ( v5 == 0x2B7842DF68A7i64 )\n    {\n      result = 0xFFF1D1663EC55DCCui64;\n      v5 = 0x2B7842DF6563i64;\n    }\n    else\n    {\n      result = ~v5;\n    }\n    qword_404987 = v5;\n    qword_40D366 = result;\n  }\n  else\n  {\n    qword_40D366 = ~qword_404987;\n  }\n  return result;\n}\n// 404987: using guessed type __int64 qword_404987;\n// 40D366: using guessed type __int64 qword_40D366;\n\n"
    },
    {
        "Function": "sub_40025D",
        "Total XOR and shift operations": 2,
        "XOR operations": 0,
        "Shift operations": 2,
        "Operation percentage": "1.10%",
        "Function Body": "\n__int64 __fastcall sub_40025D(unsigned int *a1, __int64 a2)\n{\n  unsigned int v2; // edi\n  __int64 v3; // rdi\n  __int64 v4; // r9\n  unsigned int v5; // eax\n  unsigned int v6; // r12d\n  int v7; // ebp\n  unsigned int v8; // r15d\n  __int64 v9; // r10\n  __int64 v10; // r11\n  int v11; // r14d\n  __int64 v12; // r9\n  int v13; // ebx\n  int v14; // r13d\n  unsigned int v15; // eax\n  __int64 v16; // rcx\n  __int64 result; // rax\n  __int64 v18; // rdx\n  signed int v19; // [rsp+50h] [rbp-E8h]\n  int v20; // [rsp+54h] [rbp-E4h]\n  __int64 v21; // [rsp+58h] [rbp-E0h]\n  __int64 v22; // [rsp+60h] [rbp-D8h]\n  signed int v23; // [rsp+68h] [rbp-D0h]\n  int has_alpha; // [rsp+6Ch] [rbp-CCh]\n  __int64 v25; // [rsp+70h] [rbp-C8h]\n  unsigned int v26; // [rsp+80h] [rbp-B8h] BYREF\n  unsigned int v27; // [rsp+84h] [rbp-B4h] BYREF\n  unsigned int v28; // [rsp+88h] [rbp-B0h] BYREF\n  int v29; // [rsp+8Ch] [rbp-ACh] BYREF\n  char v30[48]; // [rsp+90h] [rbp-A8h] BYREF\n  char v31[120]; // [rsp+C0h] [rbp-78h] BYREF\n\n  v2 = a1[3];\n  v23 = v2;\n  if ( a2 )\n  {\n    gimp_preview_get_position(a2, &v26, &v27);\n    gimp_preview_get_size(a2, &v28, &v29);\n    v3 = g_malloc((int)(v2 * v29 * v28));\n    v25 = v3;\n  }\n  else\n  {\n    result = gimp_drawable_mask_intersect(*a1, &v26, &v27, &v28, &v29);\n    if ( !(_DWORD)result )\n      return result;\n    v3 = g_malloc((int)(v28 * v2));\n    gimp_pixel_rgn_init(v31, a1, v26, v27, v28, v29, 1, 1);\n    v25 = 0i64;\n  }\n  v4 = 0i64;\n  v5 = v29 + 1;\n  if ( v29 + 1 > a1[2] )\n    v5 = a1[2];\n  if ( (int)v27 >= 2 )\n    v4 = v27 - 1;\n  gimp_pixel_rgn_init(v30, a1, v26, v4, v28, v5, 0, 0);\n  has_alpha = gimp_drawable_has_alpha(*a1);\n  v21 = g_malloc((int)(v23 * v28));\n  v22 = g_malloc((int)(v23 * v28));\n  if ( (int)v27 < (int)(v27 + v29) )\n  {\n    v6 = v27 + 1;\n    v7 = v23 - 1;\n    while ( 1 )\n    {\n      v20 = v6 - 1;\n      gimp_pixel_rgn_get_row(v30, v3, v26, v6 - 1, v28);\n      if ( (int)(v6 - 1) % 2 == dword_407786 )\n        break;\n      if ( v20 <= 0 )\n        gimp_pixel_rgn_get_row(v30, v21, v26, (unsigned int)dword_407786, v28);\n      else\n        gimp_pixel_rgn_get_row(v30, v21, v26, v6 - 2, v28);\n      v19 = v6;\n      if ( a1[2] <= v6 )\n        gimp_pixel_rgn_get_row(v30, v22, v26, v6 + dword_407786 - 2, v28);\n      else\n        gimp_pixel_rgn_get_row(v30, v22, v26, v6, v28);\n      v8 = v28;\n      if ( has_alpha )\n      {\n        if ( (int)v28 > 0 )\n        {\n          v9 = v22;\n          v10 = v3;\n          v11 = 0;\n          v12 = v21;\n          do\n          {\n            v13 = *(unsigned __int8 *)(v12 + v23 - 1);\n            v14 = *(unsigned __int8 *)(v9 + v23 - 1);\n            v15 = (unsigned int)(v13 + v14) >> 1;\n            *(_BYTE *)(v10 + v23 - 1) = v15;\n            if ( v15 && v7 > 0 )\n            {\n              v16 = 0i64;\n              do\n              {\n                *(_BYTE *)(v10 + v16) = (v13 * *(unsigned __int8 *)(v12 + v16)\n                                       + v14 * (unsigned int)*(unsigned __int8 *)(v9 + v16))\n                                      / (v13 + v14);\n                ++v16;\n              }\n              while ( v7 > (int)v16 );\n            }\n            ++v11;\n            v12 += v23;\n            v9 += v23;\n            v10 += v23;\n          }\n          while ( v11 != v8 );\n        }\nLABEL_22:\n        if ( !a2 )\n          goto LABEL_32;\n        goto LABEL_23;\n      }\n      v18 = 0i64;\n      if ( (int)(v28 * v23) <= 0 )\n        goto LABEL_22;\n      do\n      {\n        *(_BYTE *)(v3 + v18) = (*(unsigned __int8 *)(v21 + v18) + (unsigned int)*(unsigned __int8 *)(v22 + v18)) >> 1;\n        ++v18;\n      }\n      while ( (int)(v8 * v23) > (int)v18 );\n      if ( !a2 )\n      {\nLABEL_32:\n        gimp_pixel_rgn_set_row(v31, v3, v26, (unsigned int)v20, v8);\n        if ( v20 == 20 * (v20 / 20) )\n          gimp_progress_update();\n        goto LABEL_24;\n      }\nLABEL_23:\n      v3 += (int)(v23 * v8);\nLABEL_24:\n      ++v6;\n      if ( (int)(v27 + v29) <= v19 )\n        goto LABEL_25;\n    }\n    v8 = v28;\n    v19 = v6;\n    goto LABEL_22;\n  }\nLABEL_25:\n  if ( a2 )\n  {\n    gimp_preview_draw_buffer(a2, v25, v28 * v23);\n  }\n  else\n  {\n    gimp_progress_update();\n    gimp_drawable_flush(a1);\n    gimp_drawable_merge_shadow(*a1, 1i64);\n    gimp_drawable_update(*a1, v26, v27, v28, v29);\n    v25 = v3;\n  }\n  g_free(v22);\n  g_free(v21);\n  return g_free(v25);\n}\n// 408863: using guessed type __int64 gimp_progress_update(void);\n// 407DE0: using guessed type __int64 __fastcall gimp_pixel_rgn_set_row(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 408BC4: using guessed type __int64 __fastcall gimp_pixel_rgn_init(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD, _DWORD);\n// 403279: using guessed type __int64 __fastcall gimp_pixel_rgn_get_row(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 40421E: using guessed type __int64 __fastcall gimp_drawable_update(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 40735C: using guessed type __int64 __fastcall gimp_drawable_merge_shadow(_QWORD, _QWORD);\n// 400FBF: using guessed type __int64 __fastcall gimp_drawable_mask_intersect(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);\n// 40B54D: using guessed type __int64 __fastcall gimp_drawable_has_alpha(_QWORD);\n// 4071E4: using guessed type __int64 __fastcall gimp_drawable_flush(_QWORD);\n// 403536: using guessed type __int64 __fastcall gimp_preview_get_size(_QWORD, _QWORD, _QWORD);\n// 401189: using guessed type __int64 __fastcall gimp_preview_get_position(_QWORD, _QWORD, _QWORD);\n// 4040CB: using guessed type __int64 __fastcall gimp_preview_draw_buffer(_QWORD, _QWORD, _QWORD);\n// 403A8D: using guessed type __int64 __fastcall g_malloc(_QWORD);\n// 405E0A: using guessed type __int64 __fastcall g_free(_QWORD);\n// 407786: using guessed type int dword_407786;\n\n"
    },
    {
        "Function": "sub_40F0AF",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n// write access to const memory has been detected, the output may be wrong!\n__int64 sub_40F0AF()\n{\n  BOOL v0; // edx\n  __int16 v2; // cx\n\n  v0 = 0;\n  unk_402C83 = 1;\n  unk_40643A = 1;\n  unk_407CE3 = 1;\n  unk_4030F0 = 1;\n  if ( ME7909[0x40F0D8] == 23117 && *(_DWORD *)(ME7909[0x40B15B] + 0x40F0D8i64) == 17744 )\n  {\n    v2 = *(_WORD *)(ME7909[0x40B15B] + 0x40D2CCi64);\n    if ( v2 == 267 )\n    {\n      if ( *(_DWORD *)(ME7909[0x40B15B] + 0x40F067i64) > 0xEu )\n        v0 = *(_DWORD *)(ME7909[0x40B15B] + 0x40DE97i64) != 0;\n    }\n    else if ( v2 == 523 && *(_DWORD *)(ME7909[0x40B15B] + 0x4066F1i64) > 0xEu )\n    {\n      v0 = *(_DWORD *)(ME7909[0x40B15B] + 0x406AA7i64) != 0;\n    }\n  }\n  dword_40F97B = v0;\n  if ( unk_4019E8 )\n    _set_app_type(_crt_gui_app);\n  else\n    _set_app_type(_crt_console_app);\n  qword_4060B0 = sub_40BB54(-1i64);\n  qword_40EFD2 = qword_4060B0;\n  _fmode = unk_4053DE;\n  sub_407323();\n  if ( unk_404591 == 1 )\n    sub_40E958((_UserMathErrorFunctionPointer)sub_40F4BB);\n  return 0i64;\n}\n// 4023EB: write access to const memory at 40E8B0 has been detected\n// 40F0AF: using guessed type __int64 sub_40F0AF();\n// 407323: using guessed type __int64 sub_407323(void);\n// 40F97B: using guessed type int dword_40F97B;\n// 40EFD2: using guessed type __int64 qword_40EFD2;\n// 4060B0: using guessed type __int64 qword_4060B0;\n\n"
    },
    {
        "Function": "sub_408E00",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_408E00()\n{\n  __int64 result; // rax\n\n  dword_40C10C = unk_407E4A;\n  result = _getmainargs(&argc, &argv, &envp, unk_40CBEE, &dword_40C10C);\n  dword_40C775 = result;\n  return result;\n}\n// 408E00: using guessed type __int64 sub_408E00();\n// 4025F2: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);\n// 40C10C: using guessed type int dword_40C10C;\n// 40C775: using guessed type int dword_40C775;\n\n"
    },
    {
        "Function": "sub_40F27E",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_40F27E()\n{\n  unk_4019E8 = 0;\n  sub_40673B();\n  return sub_401FD0();\n}\n// 401FD0: using guessed type __int64 sub_401FD0(void);\n// 40F27E: using guessed type __int64 sub_40F27E();\n\n"
    },
    {
        "Function": "sub_4078A5",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid sub_4078A5()\n{\n  ;\n}\n\n"
    },
    {
        "Function": "sub_4028CA",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_4028CA()\n{\n  HME51CE ModuleHandleA; // rax\n  FAFB8CC ProcAddress; // rax\n\n  if ( qword_4067E9 )\n  {\n    ModuleHandleA = GetModuleHandleA(\"libgcj-16.dll\");\n    if ( ModuleHandleA )\n    {\n      ProcAddress = GetProcAddress(ModuleHandleA, \"_Jv_RegisterClasses\");\n      if ( ProcAddress )\n        ((void (__fastcall *)(__int64 *))ProcAddress)(&qword_4067E9);\n    }\n    else\n    {\n      ((void (__fastcall *)(__int64 *))sub_4078A5)(&qword_4067E9);\n    }\n  }\n  return sub_40C419((int (__cdecl *)())sub_40733E);\n}\n// 4028CA: using guessed type __int64 sub_4028CA();\n// 4067E9: using guessed type __int64 qword_4067E9;\n\n"
    },
    {
        "Function": "sub_40733E",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid sub_40733E()\n{\n  ;\n}\n\n"
    },
    {
        "Function": "sub_403B02",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 __fastcall sub_403B02(__int64 a1, int a2, _DWORD *a3, _DWORD *a4, _QWORD *a5)\n{\n  int v5; // esi\n  __int64 v9; // rax\n  unsigned int *v10; // rax\n  __int64 v11; // rdx\n  unsigned int *v12; // rbx\n  int is_gray; // eax\n  int v14; // edx\n  __int64 v15; // rax\n  unsigned int v16; // eax\n  __int64 v18; // rax\n  __int64 v19; // rdi\n  __int64 type; // r13\n  __int64 v21; // rax\n  __int64 v22; // rax\n  __int64 v23; // rax\n  __int64 v24; // r12\n  __int64 v25; // rax\n  __int64 v26; // rax\n  __int64 v27; // r14\n  __int64 v28; // rax\n  __int64 content_area; // rax\n  __int64 v30; // rax\n  __int64 v31; // r13\n  __int64 v32; // rax\n  __int64 v33; // r15\n  __int64 v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // rax\n  __int64 v37; // rax\n  __int64 v38; // rax\n  __int64 v39; // rax\n  unsigned int v40; // eax\n  __int64 v41; // rdx\n  __int64 v42; // rcx\n  __int64 v43; // rax\n  unsigned int v44; // eax\n  __int64 v45; // [rsp+60h] [rbp-58h] BYREF\n  __int64 v46[10]; // [rsp+68h] [rbp-50h] BYREF\n\n  v5 = a3[2];\n  v9 = gimp_locale_directory();\n  libintl_bindtextdomain(\"gimp20-std-plug-ins\", v9);\n  libintl_bind_textdomain_codeset(\"gimp20-std-plug-ins\", \"UTF-8\");\n  libintl_textdomain(\"gimp20-std-plug-ins\");\n  v10 = (unsigned int *)gimp_drawable_get((unsigned int)a3[22]);\n  v12 = v10;\n  switch ( v5 )\n  {\n    case 1:\n      v14 = 1;\n      if ( a2 != 4 )\n        goto LABEL_8;\n      v42 = *v10;\n      dword_407786 = a3[32];\n      if ( (unsigned int)gimp_drawable_is_rgb(v42, 1i64) )\n      {\n        v43 = libintl_gettext(\"Deinterlace\");\n        gimp_progress_init(v43);\n        v44 = gimp_tile_width();\n        gimp_tile_cache_ntiles(2 * (v12[1] / v44) + 2, v12[1] % v44);\n        sub_40025D(v12, 0i64);\nLABEL_14:\n        v14 = 3;\n        goto LABEL_8;\n      }\n      goto LABEL_5;\n    case 2:\n      gimp_procedural_db_get_data(\"plug-in-deinterlace\", &dword_407786);\n      if ( !(unsigned int)gimp_drawable_is_rgb(*v12, v41) )\n        goto LABEL_5;\n      goto LABEL_11;\n    case 0:\n      gimp_procedural_db_get_data(\"plug-in-deinterlace\", &dword_407786);\n      gimp_ui_init(\"deinterlace\", 0i64);\n      v18 = libintl_gettext(\"Deinterlace\");\n      v19 = gimp_dialog_new(\n              v18,\n              \"gimp-deinterlace\",\n              0i64,\n              0i64,\n              &gimp_standard_help_func,\n              \"plug-in-deinterlace\",\n              \"gtk-cancel\",\n              -6,\n              \"gtk-ok\",\n              -5,\n              0i64);\n      type = gtk_dialog_get_type();\n      v21 = g_type_check_instance_cast(v19, type);\n      gtk_dialog_set_alternative_button_order(v21, 4205B07291i64, 4205B07290i64, 0xFF9F59FFi64);\n      v22 = gtk_window_get_type();\n      v23 = g_type_check_instance_cast(v19, v22);\n      gimp_window_set_transient(v23);\n      v24 = gtk_box_new(1i64, 12i64);\n      v25 = gtk_container_get_type();\n      v26 = g_type_check_instance_cast(v24, v25);\n      gtk_container_set_border_width(v26, 12i64);\n      v27 = gtk_box_get_type();\n      v28 = g_type_check_instance_cast(v19, type);\n      content_area = gtk_dialog_get_content_area(v28);\n      v30 = g_type_check_instance_cast(content_area, v27);\n      gtk_box_pack_start(v30, v24, 1i64, 1i64, 0);\n      gtk_widget_show(v24);\n      v31 = gimp_drawable_preview_new(v12, 0i64);\n      v32 = g_type_check_instance_cast(v24, v27);\n      gtk_box_pack_start(v32, v31, 1i64, 1i64, 0);\n      gtk_widget_show(v31);\n      g_signal_connect_data(v31, \"invalidated\", sub_40025D, v12, 0i64, 2);\n      v33 = libintl_gettext(\"Keep _even fields\");\n      v34 = libintl_gettext(\"Keep o_dd fields\");\n      v35 = gimp_int_radio_group_new(\n              0i64,\n              0i64,\n              &gimp_radio_button_update,\n              &dword_407786,\n              dword_407786,\n              v34,\n              0,\n              &v45,\n              v33,\n              1,\n              v46,\n              0i64);\n      g_signal_connect_data(v45, \"toggled\", &gimp_preview_invalidate, v31, 0i64, 2);\n      g_signal_connect_data(v46[0], \"toggled\", &gimp_preview_invalidate, v31, 0i64, 2);\n      v36 = g_type_check_instance_cast(v24, v27);\n      gtk_box_pack_start(v36, v35, 0i64, 0i64, 0);\n      gtk_widget_show(v35);\n      gtk_widget_show(v19);\n      v37 = gimp_dialog_get_type();\n      v38 = g_type_check_instance_cast(v19, v37);\n      LOFA4CD(v24) = gimp_dialog_run(v38);\n      gtk_widget_destroy(v19);\n      v14 = 0;\n      if ( (_DWORD)v24 != -5 )\n        goto LABEL_8;\n      if ( !(unsigned int)gimp_drawable_is_rgb(*v12, 0i64) )\n        goto LABEL_5;\nLABEL_11:\n      v39 = libintl_gettext(\"Deinterlace\");\n      gimp_progress_init(v39);\n      v40 = gimp_tile_width();\n      gimp_tile_cache_ntiles(2 * (v12[1] / v40) + 2, v12[1] % v40);\n      sub_40025D(v12, 0i64);\nLABEL_12:\n      gimp_displays_flush();\n      if ( !v5 )\n        gimp_procedural_db_set_data(\"plug-in-deinterlace\", &dword_407786, 4i64);\n      goto LABEL_14;\n  }\n  if ( (unsigned int)gimp_drawable_is_rgb(*v10, v11) )\n    goto LABEL_6;\nLABEL_5:\n  is_gray = gimp_drawable_is_gray(*v12);\n  v14 = 0;\n  if ( is_gray )\n  {\nLABEL_6:\n    v15 = libintl_gettext(\"Deinterlace\");\n    gimp_progress_init(v15);\n    v16 = gimp_tile_width();\n    gimp_tile_cache_ntiles(2 * (v12[1] / v16) + 2, v12[1] % v16);\n    sub_40025D(v12, 0i64);\n    if ( v5 == 1 )\n    {\n      v14 = 3;\n      goto LABEL_8;\n    }\n    goto LABEL_12;\n  }\nLABEL_8:\n  *a4 = 1;\n  *a5 = &dword_40DC0D;\n  dword_40C657 = v14;\n  dword_40DC0D = 21;\n  return gimp_drawable_detach(v12);\n}\n// 402187: variable 'v11' is possibly undefined\n// 40DE4B: variable 'v41' is possibly undefined\n// 40191D: using guessed type __int64 __fastcall gimp_window_set_transient(_QWORD);\n// 4085EB: using guessed type __int64 __fastcall gimp_ui_init(_QWORD, _QWORD);\n// 40B1BA: using guessed type __int64 __fastcall gimp_drawable_preview_new(_QWORD, _QWORD);\n// 40C106: using guessed type __int64 gimp_tile_width(void);\n// 408E17: using guessed type __int64 __fastcall gimp_tile_cache_ntiles(_QWORD, _QWORD);\n// 40BC77: using guessed type __int64 __fastcall gimp_progress_init(_QWORD);\n// 409791: using guessed type __int64 __fastcall gimp_procedural_db_set_data(_QWORD, _QWORD, _QWORD);\n// 408883: using guessed type __int64 __fastcall gimp_procedural_db_get_data(_QWORD, _QWORD);\n// 40CD9A: using guessed type __int64 __fastcall gimp_drawable_is_rgb(_QWORD, _QWORD);\n// 406DFC: using guessed type __int64 __fastcall gimp_drawable_is_gray(_QWORD);\n// 403B11: using guessed type __int64 __fastcall gimp_drawable_get(_QWORD);\n// 40EA09: using guessed type __int64 __fastcall gimp_drawable_detach(_QWORD);\n// 409528: using guessed type __int64 gimp_displays_flush(void);\n// 40EED3: using guessed type __int64 __fastcall gtk_box_new(_QWORD, _QWORD);\n// 4000E0: using guessed type __int64 __fastcall gimp_int_radio_group_new(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD);\n// 409893: using guessed type __int64 __fastcall gimp_dialog_run(_QWORD);\n// 404AE7: using guessed type __int64 __fastcall gimp_dialog_new(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD);\n// 4040D1: using guessed type __int64 gimp_dialog_get_type(void);\n// 4052F6: using guessed type __int64 gimp_locale_directory(void);\n// 40DF45: using guessed type __int64 gtk_window_get_type(void);\n// 40E793: using guessed type __int64 __fastcall gtk_widget_show(_QWORD);\n// 40B479: using guessed type __int64 __fastcall gtk_widget_destroy(_QWORD);\n// 401F11: using guessed type __int64 __fastcall gtk_dialog_set_alternative_button_order(_QWORD, _QWORD, _QWORD, _QWORD);\n// 40A33D: using guessed type __int64 gtk_dialog_get_type(void);\n// 40041F: using guessed type __int64 __fastcall gtk_dialog_get_content_area(_QWORD);\n// 4032E0: using guessed type __int64 __fastcall gtk_container_set_border_width(_QWORD, _QWORD);\n// 403E67: using guessed type __int64 gtk_container_get_type(void);\n// 409580: using guessed type __int64 __fastcall gtk_box_pack_start(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 404A28: using guessed type __int64 gtk_box_get_type(void);\n// 4047C8: using guessed type __int64 __fastcall g_type_check_instance_cast(_QWORD, _QWORD);\n// 4043D7: using guessed type __int64 __fastcall g_signal_connect_data(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 40654B: using guessed type __int64 __fastcall libintl_textdomain(_QWORD);\n// 4009E5: using guessed type __int64 __fastcall libintl_gettext(_QWORD);\n// 40549E: using guessed type __int64 __fastcall libintl_bindtextdomain(_QWORD, _QWORD);\n// 405F8B: using guessed type __int64 __fastcall libintl_bind_textdomain_codeset(_QWORD, _QWORD);\n// 407786: using guessed type int dword_407786;\n// 40DC0D: using guessed type int dword_40DC0D;\n// 40C657: using guessed type int dword_40C657;\n// 403B02: using guessed type __int64 var_50[10];\n\n"
    },
    {
        "Function": "sub_40D1B4",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_40D1B4()\n{\n  gimp_install_procedure(\n    \"plug-in-deinterlace\",\n    \"Fix images where every other row is missing\",\n    \"Deinterlace is useful for processing images from video capture cards. When only the odd or even fields get captured,\"\n    \" deinterlace can be used to interpolate between the existing fields to correct this.\");\n  return gimp_plugin_menu_register(\"plug-in-deinterlace\", \"<Image>/Filters/Enhance\");\n}\n// 40D1B4: using guessed type __int64 sub_40D1B4();\n// 406CA0: using guessed type __int64 __fastcall gimp_plugin_menu_register(_QWORD, _QWORD);\n// 40CDD4: using guessed type __int64 __fastcall gimp_install_procedure(_QWORD, _QWORD, _QWORD);\n\n"
    }
]