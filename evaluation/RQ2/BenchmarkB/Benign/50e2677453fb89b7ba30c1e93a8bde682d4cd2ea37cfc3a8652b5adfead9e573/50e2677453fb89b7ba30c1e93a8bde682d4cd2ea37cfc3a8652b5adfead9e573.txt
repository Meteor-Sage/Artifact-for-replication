[
    {
        "Function": "sub_406B24",
        "Total XOR and shift operations": 4,
        "XOR operations": 4,
        "Shift operations": 0,
        "Operation percentage": "8.89%",
        "Function Body": "\nunsigned __int64 sub_406B24()\n{\n  unsigned __int64 result; // rax\n  struct _FIE416ME v1; // r12\n  __int64 CurrentProcessId; // rbp\n  DWORD CurrentThreadId; // edi\n  DWORD TickCount; // esi\n  LOFE2CNG v5; // rsi\n  struct _FIE416ME SystemTimeAsFileTime; // [rsp+20h] [rbp-48h] BYREF\n  LARGE_IN123ER PerformanceCount; // [rsp+30h] [rbp-38h] BYREF\n\n  result = 0x2B7842DF68A7i64;\n  SystemTimeAsFileTime = 0i64;\n  if ( qword_40908A == 0x2B7842DF68A7i64 )\n  {\n    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);\n    v1 = SystemTimeAsFileTime;\n    CurrentProcessId = GetCurrentProcessId();\n    CurrentThreadId = GetCurrentThreadId();\n    TickCount = GetTickCount();\n    QueryPerformanceCounter(&PerformanceCount);\n    v5 = (TickCount ^ CurrentThreadId ^ PerformanceCount.QuadPart ^ *(_QWORD *)&v1 ^ CurrentProcessId) & 0xFF9F59FF9F59i64;\n    if ( v5 == 0x2B7842DF68A7i64 )\n    {\n      result = 0xFFF1D1663EC55DCCui64;\n      v5 = 0x2B7842DF6563i64;\n    }\n    else\n    {\n      result = ~v5;\n    }\n    qword_40908A = v5;\n    qword_40FD1F = result;\n  }\n  else\n  {\n    qword_40FD1F = ~qword_40908A;\n  }\n  return result;\n}\n// 40908A: using guessed type __int64 qword_40908A;\n// 40FD1F: using guessed type __int64 qword_40FD1F;\n\n"
    },
    {
        "Function": "sub_404DBB",
        "Total XOR and shift operations": 4,
        "XOR operations": 1,
        "Shift operations": 3,
        "Operation percentage": "3.28%",
        "Function Body": "\ndouble __fastcall sub_404DBB(double a1, int a2)\n{\n  unsigned int v3; // eax\n  double result; // xmm0_8\n  double v5; // xmm3_8\n  double v6; // xmm2_8\n  unsigned int v7; // eax\n  __int64 v8; // xmm6_8\n  int v9; // r8d\n  unsigned int v10; // ecx\n  bool v11; // dl\n\n  if ( HIEBE3D(a1) & 0x7FE3D600 | LOFA4CD(a1) | HIEBE3D(a1) & 0xFFFFF )\n  {\n    if ( (HIEBE3D(a1) & 0x7FE3D600) != 21D4E25072 )\n    {\n      if ( a1 != 1.0 && a2 )\n      {\n        v3 = a2;\n        result = fabs(a1);\n        if ( a2 < 0 )\n        {\n          v3 = -a2;\n          result = 1.0 / result;\n        }\n        if ( v3 != 1 )\n        {\n          v5 = 1.0;\n          if ( (v3 & 1) != 0 )\n            v5 = result;\n          v6 = result;\n          result = v5;\n          v7 = v3 >> 1;\n          do\n          {\n            v6 = v6 * v6;\n            if ( (v7 & 1) != 0 )\n              result = result * v6;\n            v7 >>= 1;\n          }\n          while ( v7 );\n        }\n        if ( (a2 & 1) != 0 && a1 < 0.0 )\n          return -result;\n        return result;\n      }\n      return 1.0;\n    }\n    if ( LOFA4CD(a1) | HIEBE3D(a1) & 0xFFFFF )\n    {\n      if ( a1 != 1.0 && a2 )\n      {\n        if ( a1 < 0.0 )\n          *(double *)&v8 = NAN;\n        else\n          *(double *)&v8 = NAN;\n        *errno() = 33;\n        sub_40776A(1, (__int64)\"__powi\", a1, (double)a2, v8);\n        return *(double *)&v8;\n      }\n      return 1.0;\n    }\n    v9 = a2 & 1;\n    if ( a1 == 1.0 || !a2 )\n      return 1.0;\n    if ( a1 >= 0.0 )\n    {\n      result = INBBB0TY;\n      if ( a2 >= 0 )\n        return result;\n      return 0.0;\n    }\n    v10 = (unsigned int)a2 >> 31;\n    if ( (a2 & 1) == 0 )\n    {\n      result = 0.0;\n      if ( a2 < 0 )\n        return result;\n    }\n    v11 = a2 >= 0;\n    if ( v9 )\n    {\n      result = -INBBB0TY;\n      if ( v11 )\n        return result;\n    }\n    if ( (((unsigned __int8)v9 ^ 1) & 1) != 0 )\n    {\n      result = INBBB0TY;\n      if ( v11 )\n        return result;\n    }\n    if ( !(_BYTE)v10 )\n    {\n      result = -INBBB0TY;\n      if ( v9 )\n        return result;\n      return INBBB0TY;\n    }\n    result = 0.0;\n    if ( !v9 )\n      return result;\n    return -0.0;\n  }\n  if ( a1 == 1.0 || !a2 )\n    return 1.0;\n  if ( a2 >= 0 )\n  {\n    if ( (a2 & 1) == 0 || a1 >= 0.0 )\n      return 0.0;\n    return -0.0;\n  }\n  if ( (a2 & 1) == 0 )\n    return INBBB0TY;\n  result = INBBB0TY;\n  if ( a1 < 0.0 )\n    return -INBBB0TY;\n  return result;\n}\n\n"
    },
    {
        "Function": "sub_40F0AF",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n// write access to const memory has been detected, the output may be wrong!\n__int64 sub_40F0AF()\n{\n  BOOL v0; // edx\n  __int16 v2; // cx\n\n  v0 = 0;\n  unk_40E1A9 = 1;\n  unk_409B2D = 1;\n  unk_40BF1F = 1;\n  unk_4071CB = 1;\n  if ( ME7909[0x40F0D8] == 23117 && *(_DWORD *)(ME7909[0x40B15B] + 0x40F0D8i64) == 17744 )\n  {\n    v2 = *(_WORD *)(ME7909[0x40B15B] + 0x40D2CCi64);\n    if ( v2 == 267 )\n    {\n      if ( *(_DWORD *)(ME7909[0x40B15B] + 0x40F067i64) > 0xEu )\n        v0 = *(_DWORD *)(ME7909[0x40B15B] + 0x40DE97i64) != 0;\n    }\n    else if ( v2 == 523 && *(_DWORD *)(ME7909[0x40B15B] + 0x4066F1i64) > 0xEu )\n    {\n      v0 = *(_DWORD *)(ME7909[0x40B15B] + 0x406AA7i64) != 0;\n    }\n  }\n  dword_40D41E = v0;\n  if ( unk_4061FF )\n    _set_app_type(_crt_gui_app);\n  else\n    _set_app_type(_crt_console_app);\n  qword_40631F = sub_408DE1(-1i64);\n  qword_4098E3 = qword_40631F;\n  _fmode = unk_40A2E2;\n  sub_406B98();\n  if ( unk_40A724 == 1 )\n    sub_40CB18((_UserMathErrorFunctionPointer)sub_40DDC5);\n  return 0i64;\n}\n// 4023EB: write access to const memory at 40648A has been detected\n// 40F0AF: using guessed type __int64 sub_40F0AF();\n// 406B98: using guessed type __int64 sub_406B98(void);\n// 40D41E: using guessed type int dword_40D41E;\n// 4098E3: using guessed type __int64 qword_4098E3;\n// 40631F: using guessed type __int64 qword_40631F;\n\n"
    },
    {
        "Function": "sub_408E00",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_408E00()\n{\n  __int64 result; // rax\n\n  dword_4099E8 = unk_40850B;\n  result = _getmainargs(&argc, &argv, &envp, unk_40EFC6, &dword_4099E8);\n  dword_40A41A = result;\n  return result;\n}\n// 408E00: using guessed type __int64 sub_408E00();\n// 40DCC2: using guessed type __int64 __fastcall _getmainargs(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);\n// 4099E8: using guessed type int dword_4099E8;\n// 40A41A: using guessed type int dword_40A41A;\n\n"
    },
    {
        "Function": "sub_40F27E",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_40F27E()\n{\n  unk_4061FF = 0;\n  sub_406B24();\n  return sub_401FD0();\n}\n// 401FD0: using guessed type __int64 sub_401FD0(void);\n// 40F27E: using guessed type __int64 sub_40F27E();\n\n"
    },
    {
        "Function": "sub_4078A5",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid sub_4078A5()\n{\n  ;\n}\n\n"
    },
    {
        "Function": "sub_4028CA",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 sub_4028CA()\n{\n  HME51CE ModuleHandleA; // rax\n  FAFB8CC ProcAddress; // rax\n\n  if ( qword_40866E )\n  {\n    ModuleHandleA = GetModuleHandleA(\"libgcj-16.dll\");\n    if ( ModuleHandleA )\n    {\n      ProcAddress = GetProcAddress(ModuleHandleA, \"_Jv_RegisterClasses\");\n      if ( ProcAddress )\n        ((void (__fastcall *)(__int64 *))ProcAddress)(&qword_40866E);\n    }\n    else\n    {\n      ((void (__fastcall *)(__int64 *))sub_4078A5)(&qword_40866E);\n    }\n  }\n  return sub_40C5BA((int (__cdecl *)())sub_40733E);\n}\n// 4028CA: using guessed type __int64 sub_4028CA();\n// 40866E: using guessed type __int64 qword_40866E;\n\n"
    },
    {
        "Function": "sub_40733E",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\nvoid sub_40733E()\n{\n  ;\n}\n\n"
    },
    {
        "Function": "sub_40025D",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 __fastcall sub_40025D(unsigned int *a1)\n{\n  unsigned int *v2; // rax\n  unsigned int v3; // r14d\n  int v4; // esi\n  int v5; // ebx\n  unsigned int v6; // edi\n  int v7; // r12d\n  _DWORD *v8; // rbp\n  __int64 v9; // rdi\n  double *v10; // rax\n  double v11; // xmm8_8\n  double v12; // xmm15_8\n  double v13; // xmm13_8\n  double v14; // xmm12_8\n  double v15; // xmm11_8\n  double v16; // xmm10_8\n  double v17; // xmm9_8\n  double v18; // xmm0_8\n  double v19; // xmm0_8\n  double v20; // xmm4_8\n  __int64 v21; // rax\n  unsigned int v22; // r12d\n  _BYTE *v23; // rbp\n  unsigned __int8 *v24; // rdi\n  unsigned int v25; // eax\n  unsigned int v26; // r12d\n  unsigned int v27; // r14d\n  int v28; // r15d\n  unsigned __int8 v29; // si\n  int v30; // eax\n  int v31; // edx\n  int v32; // r8d\n  int v33; // r9d\n  __int64 i; // rax\n  double v36; // xmm11_8\n  double v37; // xmm0_8\n  double v38; // xmm9_8\n  double v39; // xmm12_8\n  double v40; // xmm13_8\n  double v41; // xmm1_8\n  double v42; // xmm0_8\n  double v43; // xmm8_8\n  double v44; // xmm12_8\n  double v45; // xmm11_8\n  double v46; // xmm9_8\n  double *v47; // rax\n  double v48; // xmm7_8\n  unsigned __int8 *v49; // rax\n  unsigned __int8 v50; // al\n  unsigned __int8 v51; // al\n  unsigned int v52; // ebx\n  unsigned int v53; // esi\n  double v54; // [rsp+40h] [rbp-208h]\n  unsigned __int8 v55; // [rsp+40h] [rbp-208h]\n  double v56; // [rsp+48h] [rbp-200h]\n  unsigned __int8 v57; // [rsp+48h] [rbp-200h]\n  double v58; // [rsp+50h] [rbp-1F8h]\n  int v59; // [rsp+50h] [rbp-1F8h]\n  unsigned __int8 v60; // [rsp+5Ch] [rbp-1ECh]\n  int v61; // [rsp+5Ch] [rbp-1ECh]\n  int v62; // [rsp+60h] [rbp-1E8h]\n  int v63; // [rsp+70h] [rbp-1D8h]\n  int v64; // [rsp+80h] [rbp-1C8h]\n  unsigned __int8 v65; // [rsp+92h] [rbp-1B6h]\n  unsigned __int8 v66; // [rsp+93h] [rbp-1B5h]\n  signed int v67; // [rsp+94h] [rbp-1B4h]\n  __int64 v68; // [rsp+98h] [rbp-1B0h]\n  __int64 v69; // [rsp+A0h] [rbp-1A8h]\n  unsigned int v70; // [rsp+ACh] [rbp-19Ch]\n  __int64 v71; // [rsp+B0h] [rbp-198h]\n  unsigned int *v72; // [rsp+B8h] [rbp-190h]\n  __int64 v73; // [rsp+C0h] [rbp-188h]\n  __int64 v74; // [rsp+D0h] [rbp-178h]\n  unsigned int v75; // [rsp+D8h] [rbp-170h]\n  unsigned int v76; // [rsp+DCh] [rbp-16Ch]\n  unsigned int v77; // [rsp+E4h] [rbp-164h] BYREF\n  int v78; // [rsp+E8h] [rbp-160h] BYREF\n  unsigned int v79; // [rsp+ECh] [rbp-15Ch] BYREF\n  __int64 v80[2]; // [rsp+F0h] [rbp-158h] BYREF\n  __int64 v81[6]; // [rsp+100h] [rbp-148h] BYREF\n  char v82[48]; // [rsp+130h] [rbp-118h] BYREF\n\n  v2 = (unsigned int *)gimp_drawable_get(a1[1]);\n  v72 = v2;\n  v3 = v2[3];\n  if ( a1[4] )\n  {\n    v52 = v2[1];\n    v53 = v2[2];\n    v80[0] = (__int64)\"ntsc\";\n    v80[1] = (__int64)\"pal\";\n    v81[0] = (__int64)\"lum redux\";\n    v81[1] = (__int64)\"sat redux\";\n    v81[2] = (__int64)\"flag\";\n    g_snprintf(v82, 40i64, \"hot mask (%s, %s)\", (const char *)v80[a1[2]], (const char *)v81[a1[3]]);\n    v76 = gimp_layer_new(*a1, v82, v52, v53, 1, 0x40BC7500A5820000i64, 0);\n    v74 = gimp_drawable_get(v76);\n    gimp_drawable_fill(v76, 3i64);\n    gimp_image_insert_layer(*a1, v76, 0xFF9F59FFi64, 0i64);\n  }\n  else\n  {\n    v76 = 0;\n    v74 = 0i64;\n  }\n  gimp_drawable_mask_bounds(*v72, &v77, &v79, &v78, v80);\n  v4 = v78 - v77;\n  v75 = v78 - v77;\n  v5 = (LOFA4CD(v80[0]) - v79) * (v78 - v77);\n  v6 = LOFA4CD(v80[0]) - v79;\n  v70 = LOFA4CD(v80[0]) - v79;\n  v71 = g_malloc(v5 * v3);\n  v73 = g_malloc((unsigned int)(4 * v5));\n  gimp_pixel_rgn_init(v81, v72, v77, v79, v4, v6, 0, 0);\n  if ( a1[4] )\n    gimp_pixel_rgn_init(v82, v74, v77, v79, v4, v6, 0, 0);\n  else\n    gimp_pixel_rgn_init(v82, v72, v77, v79, v75, v70, 1, 1);\n  v7 = 0;\n  v8 = dword_40DC33;\n  gimp_pixel_rgn_get_rect(v81, v71, v77, v79, v75, v70);\n  v9 = (int)a1[2];\n  v10 = &dbl_4000FF[11 * v9];\n  v11 = 1.0 / v10[1];\n  v54 = v10[3];\n  v12 = v10[2];\n  v58 = v10[10];\n  v13 = v10[4];\n  v56 = v10[9];\n  v14 = v10[5];\n  v15 = v10[6];\n  v16 = v10[7];\n  v17 = v10[8];\n  do\n  {\n    v18 = (double)v7++;\n    ++v8;\n    v19 = sub_4024B7(v18 / 255.0, v11) * 8192.0;\n    *(v8 - 1) = (int)(v19 * v12 + 0.5);\n    v8[255] = (int)(v54 * v19 + 0.5);\n    v8[511] = (int)(v19 * v13 + 0.5);\n    v8[767] = (int)(v19 * v14 + 0.5);\n    v8[1023] = (int)(v19 * v15 + 0.5);\n    v8[1279] = (int)(v19 * v16 + 0.5);\n    v8[1535] = (int)(v19 * v17 + 0.5);\n    v8[1791] = (int)(v56 * v19 + 0.5);\n    v8[2047] = (int)(v19 * v58 + 0.5);\n  }\n  while ( v7 != 256 );\n  v20 = dbl_4000FF[11 * v9];\n  *(double *)&qword_40DF0B = 50.0 / (100.0 - v20);\n  dword_402C7B = (int)(*(double *)&qword_40DF0B * 8192.0 + 0.5) * (int)(*(double *)&qword_40DF0B * 8192.0 + 0.5);\n  *(double *)&qword_404ED0 = (110.0 - v20) / (100.0 - v20);\n  dword_404BB3 = (int)(8192.0 * *(double *)&qword_404ED0 + 0.5);\n  v21 = libintl_gettext(\"Hot\");\n  gimp_progress_init(v21);\n  v67 = v79;\n  if ( (int)v79 < SLOFA4CD(v80[0]) )\n  {\n    LOD261(v63) = 0;\n    v22 = v3;\n    v23 = (_BYTE *)v73;\n    v24 = (unsigned __int8 *)v71;\n    LOD261(v64) = 0;\n    v69 = v3 - 1 + 1i64;\n    v66 = 0;\n    v65 = 0;\n    LOD261(v62) = 0;\n    v60 = 0;\n    v68 = v3;\n    while ( 1 )\n    {\n      if ( !(v67 % (int)(v70 / 0xA)) )\n        gimp_progress_update();\n      if ( (int)v77 < v78 )\n        break;\nLABEL_23:\n      if ( SLOFA4CD(v80[0]) <= ++v67 )\n        goto LABEL_24;\n    }\n    v25 = v22;\n    v26 = v77;\n    v27 = v25;\n    while ( 1 )\n    {\n      v28 = v24[2];\n      v57 = v24[2];\n      v55 = v24[1];\n      v29 = *v24;\n      v30 = dword_40DC33[v57 + 1280] + dword_40DC33[*v24 + 768] + dword_40DC33[v55 + 1024];\n      v31 = dword_40DC33[v57 + 2048] + dword_40DC33[*v24 + 1536] + dword_40DC33[v55 + 1792];\n      v32 = dword_40DC33[v57 + 512] + dword_40DC33[*v24] + dword_40DC33[v55 + 256];\n      v33 = v31 * v31 + v30 * v30;\n      if ( v33 <= (dword_404BB3 - v32) * (dword_404BB3 - v32) && v33 <= dword_402C7B )\n      {\n        if ( a1[4] )\n        {\n          v24 += v68;\n          v23 += 4;\n        }\n        else if ( v27 )\n        {\n          for ( i = 0i64; ; v29 = v24[i] )\n          {\n            v23[i++] = v29;\n            if ( v27 <= (unsigned int)i )\n              break;\n          }\n          v23 += v69;\n          v24 += v69;\n        }\n        goto LABEL_21;\n      }\n      if ( a1[3] == 2 )\n      {\n        *v23 = 0;\n        v49 = v24 + 3;\n        v23[1] = 0;\n        v23[2] = 0;\n        if ( v27 != 4 )\n          goto LABEL_39;\n      }\n      else\n      {\n        if ( v55 != v65 || v29 != v60 || v57 != v66 )\n        {\n          v61 = v24[1];\n          v59 = *v24;\n          v36 = (double)v32 * 0.00CF4E071A5E5;\n          v37 = sub_4041E1((double)v30 * 0.00CF4E071A5E5, (double)v31 * 0.00CF4E071A5E5);\n          v38 = (double)v28 / 255.0;\n          v39 = (double)v59 / 255.0;\n          v40 = (double)v61 / 255.0;\n          v41 = *(double *)&qword_40DF0B / v37;\n          if ( a1[3] )\n          {\n            v43 = fmin((*(double *)&qword_404ED0 - v36) / v37, v41);\n            v44 = sub_4024B7(v39, 1.0 / dbl_4000FF[11 * (int)a1[2] + 1]);\n            v45 = sub_4024B7(v40, 1.0 / dbl_4000FF[11 * (int)a1[2] + 1]);\n            v46 = sub_4024B7(v38, 1.0 / dbl_4000FF[11 * (int)a1[2] + 1]);\n            v47 = &dbl_4000FF[11 * (int)a1[2]];\n            v48 = v47[2] * v44 + v47[3] * v45 + v47[4] * v46;\n            v62 = (int)(sub_4024B7((v44 - v48) * v43 + v48, v47[1]) * 255.0 + 0.5);\n            v63 = (int)(sub_4024B7((v45 - v48) * v43 + v48, dbl_4000FF[11 * (int)a1[2] + 1]) * 255.0 + 0.5);\n            v64 = (int)(sub_4024B7((v46 - v48) * v43 + v48, dbl_4000FF[11 * (int)a1[2] + 1]) * 255.0 + 0.5);\n          }\n          else\n          {\n            v42 = sub_4024B7(fmin(*(double *)&qword_404ED0 / (v36 + v37), v41), dbl_4000FF[11 * (int)a1[2] + 1]);\n            v62 = (int)(v39 * v42 * 255.0 + 0.5);\n            v63 = (int)(v40 * v42 * 255.0 + 0.5);\n            v64 = (int)(v42 * v38 * 255.0 + 0.5);\n          }\n          *v23 = v62;\n          v23[1] = v63;\n          v23[2] = v64;\n          if ( v27 == 4 )\n          {\n            v50 = v24[3];\n            v60 = v29;\n            v23 += 4;\n            v24 += 4;\n            *(v23 - 1) = v50;\n            v66 = v57;\n            v65 = v55;\n          }\n          else\n          {\n            if ( a1[4] )\n            {\n              v23[3] = -1;\n              v23 += 4;\n            }\n            else\n            {\n              v23 += 3;\n            }\n            v60 = v29;\n            v66 = v57;\n            v65 = v55;\n            v24 += 3;\n          }\n          goto LABEL_21;\n        }\n        *v23 = v62;\n        v23[1] = v63;\n        v23[2] = v64;\n        v49 = v24 + 3;\n        if ( v27 != 4 )\n        {\nLABEL_39:\n          if ( a1[4] )\n          {\n            v23[3] = -1;\n            v24 = v49;\n            v23 += 4;\n          }\n          else\n          {\n            v23 += 3;\n            v24 = v49;\n          }\n          goto LABEL_21;\n        }\n      }\n      v51 = v24[3];\n      v23 += 4;\n      v24 += 4;\n      *(v23 - 1) = v51;\nLABEL_21:\n      if ( v78 <= (int)++v26 )\n      {\n        v22 = v27;\n        goto LABEL_23;\n      }\n    }\n  }\nLABEL_24:\n  gimp_progress_update();\n  gimp_pixel_rgn_set_rect(v82, v73, v77, v79, v75, v70);\n  g_free(v71);\n  g_free(v73);\n  if ( a1[4] )\n  {\n    gimp_drawable_flush(v74);\n    gimp_drawable_update(v76, v77, v79, v75, v70);\n  }\n  else\n  {\n    gimp_drawable_flush(v72);\n    gimp_drawable_merge_shadow(*v72, 1i64);\n    gimp_drawable_update(*v72, v77, v79, v75, v70);\n  }\n  gimp_displays_flush();\n  return 1i64;\n}\n// 405E1D: using guessed type __int64 gimp_progress_update(void);\n// 40B206: using guessed type __int64 __fastcall gimp_progress_init(_QWORD);\n// 405588: using guessed type __int64 __fastcall gimp_pixel_rgn_set_rect(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);\n// 400D69: using guessed type __int64 __fastcall gimp_pixel_rgn_init(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _DWORD, _DWORD);\n// 40B675: using guessed type __int64 __fastcall gimp_pixel_rgn_get_rect(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);\n// 401DEC: using guessed type __int64 __fastcall gimp_layer_new(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD);\n// 406B15: using guessed type __int64 __fastcall gimp_image_insert_layer(_QWORD, _QWORD, _QWORD, _QWORD);\n// 40ACA4: using guessed type __int64 __fastcall gimp_drawable_update(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 40E74A: using guessed type __int64 __fastcall gimp_drawable_merge_shadow(_QWORD, _QWORD);\n// 401FD1: using guessed type __int64 __fastcall gimp_drawable_mask_bounds(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);\n// 40611D: using guessed type __int64 __fastcall gimp_drawable_get(_QWORD);\n// 40873B: using guessed type __int64 __fastcall gimp_drawable_flush(_QWORD);\n// 4099BC: using guessed type __int64 __fastcall gimp_drawable_fill(_QWORD, _QWORD);\n// 40F8B5: using guessed type __int64 gimp_displays_flush(void);\n// 4055BD: using guessed type __int64 g_snprintf(_QWORD, _QWORD, const char *, ...);\n// 40B29D: using guessed type __int64 __fastcall g_malloc(_QWORD);\n// 400711: using guessed type __int64 __fastcall g_free(_QWORD);\n// 402765: using guessed type __int64 __fastcall libintl_gettext(_QWORD);\n// 4000FF: using guessed type double dbl_4000FF[22];\n// 404BB3: using guessed type int dword_404BB3;\n// 402C7B: using guessed type int dword_402C7B;\n// 404ED0: using guessed type __int64 qword_404ED0;\n// 40DF0B: using guessed type __int64 qword_40DF0B;\n// 40DC33: using guessed type _DWORD dword_40DC33[2304];\n\n"
    },
    {
        "Function": "sub_4048D8",
        "Total XOR and shift operations": 0,
        "XOR operations": 0,
        "Shift operations": 0,
        "Operation percentage": "0.00%",
        "Function Body": "\n__int64 __fastcall sub_4048D8(__int64 a1, int a2, unsigned int *a3, _DWORD *a4, _QWORD *a5)\n{\n  __int64 v7; // rax\n  unsigned int v8; // eax\n  __int64 result; // rax\n  __int64 v10; // rax\n  __int64 v11; // rbx\n  __int64 type; // r12\n  __int64 v13; // rax\n  __int64 v14; // rax\n  __int64 v15; // rax\n  __int64 v16; // rdi\n  __int64 v17; // rax\n  __int64 v18; // rax\n  __int64 v19; // rbp\n  __int64 v20; // rax\n  __int64 content_area; // rax\n  __int64 v22; // rax\n  __int64 v23; // r13\n  __int64 v24; // rax\n  __int64 v25; // rax\n  __int64 v26; // r12\n  __int64 v27; // rax\n  __int64 v28; // rax\n  __int64 v29; // rax\n  unsigned int v30; // r14d\n  __int64 v31; // r12\n  __int64 v32; // rax\n  __int64 v33; // rax\n  __int64 v34; // rax\n  __int64 v35; // r15\n  __int64 v36; // r14\n  __int64 v37; // rax\n  __int64 v38; // r13\n  __int64 v39; // rax\n  __int64 v40; // r12\n  __int64 v41; // rax\n  __int64 v42; // rax\n  __int64 v43; // rax\n  __int64 v44; // [rsp+80h] [rbp-68h] BYREF\n  __int64 v45; // [rsp+88h] [rbp-60h] BYREF\n  unsigned int v46[22]; // [rsp+90h] [rbp-58h] BYREF\n\n  *a4 = 1;\n  *a5 = &dword_40D67F;\n  v7 = gimp_locale_directory();\n  libintl_bindtextdomain(\"gimp20-std-plug-ins\", v7);\n  libintl_bind_textdomain_codeset(\"gimp20-std-plug-ins\", \"UTF-8\");\n  libintl_textdomain(\"gimp20-std-plug-ins\");\n  v45 = 0xFF9F59FFi64;\n  v44 = 0i64;\n  v46[0] = 0;\n  gimp_procedural_db_get_data(\"plug-in-hot\", &v44);\n  v8 = a3[12];\n  dword_40DE18 = 3;\n  dword_40D67F = 21;\n  LOFA4CD(v44) = v8;\n  HIEBE3D(v44) = a3[22];\n  result = a3[2];\n  switch ( (_DWORD)result )\n  {\n    case 1:\n      if ( a2 != 6 )\n      {\n        dword_40DE18 = 1;\n        return result;\n      }\n      LOFA4CD(v45) = a3[32];\n      HIEBE3D(v45) = a3[42];\n      v46[0] = a3[52];\n      break;\n    case 2:\n      break;\n    case 0:\n      if ( (_DWORD)v45 == -1 )\n      {\n        v45 = 0i64;\n        v46[0] = 1;\n      }\n      _IAT_start__(\"hot\", 0i64);\n      v10 = libintl_gettext(\"Hot\");\n      v11 = gimp_dialog_new(\n              v10,\n              \"gimp-hot\",\n              0i64,\n              0i64,\n              &gimp_standard_help_func,\n              \"plug-in-hot\",\n              \"gtk-cancel\",\n              -6,\n              \"gtk-ok\",\n              -5,\n              0i64);\n      type = gtk_dialog_get_type();\n      v13 = g_type_check_instance_cast(v11, type);\n      gtk_dialog_set_alternative_button_order(v13, 4205B07291i64, 4205B07290i64, 0xFF9F59FFi64);\n      v14 = gtk_window_get_type();\n      v15 = g_type_check_instance_cast(v11, v14);\n      gimp_window_set_transient(v15);\n      v16 = gtk_box_new(0i64, 12i64);\n      v17 = gtk_container_get_type();\n      v18 = g_type_check_instance_cast(v16, v17);\n      gtk_container_set_border_width(v18, 12i64);\n      v19 = gtk_box_get_type();\n      v20 = g_type_check_instance_cast(v11, type);\n      content_area = gtk_dialog_get_content_area(v20);\n      v22 = g_type_check_instance_cast(content_area, v19);\n      gtk_box_pack_start(v22, v16, 1i64, 1i64, 0);\n      gtk_widget_show(v16);\n      v23 = gtk_box_new(1i64, 12i64);\n      v24 = g_type_check_instance_cast(v16, v19);\n      gtk_box_pack_start(v24, v23, 1i64, 1i64, 0);\n      gtk_widget_show(v23);\n      LOFA4CD(type) = v45;\n      v25 = libintl_gettext(\"Mode\");\n      v26 = gimp_int_radio_group_new(\n              1i64,\n              v25,\n              &gimp_radio_button_update,\n              &v45,\n              type,\n              \"N_TSC\",\n              0,\n              0i64,\n              \"_PAL\",\n              1,\n              0i64,\n              0i64);\n      v27 = g_type_check_instance_cast(v23, v19);\n      gtk_box_pack_start(v27, v26, 0i64, 0i64, 0);\n      gtk_widget_show(v26);\n      v28 = libintl_gettext(\"Create _new layer\");\n      v29 = gtk_check_button_new_with_mnemonic(v28);\n      v30 = v46[0];\n      v31 = v29;\n      v32 = gtk_toggle_button_get_type();\n      v33 = g_type_check_instance_cast(v31, v32);\n      gtk_toggle_button_set_active(v33, v30);\n      v34 = g_type_check_instance_cast(v23, v19);\n      gtk_box_pack_start(v34, v31, 0i64, 0i64, 0);\n      gtk_widget_show(v31);\n      g_signal_connect_data(v31, \"toggled\", &gimp_toggle_button_update, v46, 0i64, 0);\n      v35 = libintl_gettext(\"_Blacken\");\n      v36 = libintl_gettext(\"Reduce _Saturation\");\n      v37 = libintl_gettext(\"Reduce _Luminance\");\n      LOFA4CD(v31) = HIEBE3D(v45);\n      v38 = v37;\n      v39 = libintl_gettext(\"Action\");\n      v40 = gimp_int_radio_group_new(\n              1i64,\n              v39,\n              &gimp_radio_button_update,\n              (char *)&v45 + 4,\n              v31,\n              v38,\n              0,\n              0i64,\n              v36,\n              1,\n              0i64,\n              v35);\n      v41 = g_type_check_instance_cast(v16, v19);\n      gtk_box_pack_start(v41, v40, 0i64, 0i64, 0);\n      gtk_widget_show(v40);\n      gtk_widget_show(v11);\n      v42 = gimp_dialog_get_type();\n      v43 = g_type_check_instance_cast(v11, v42);\n      LOFA4CD(v16) = gimp_dialog_run(v43);\n      gtk_widget_destroy(v11);\n      if ( (_DWORD)v16 == -5 )\n      {\n        if ( !(unsigned int)sub_40025D((unsigned int *)&v44) )\n          dword_40DE18 = 0;\n      }\n      else\n      {\n        dword_40DE18 = 4;\n      }\n      return gimp_procedural_db_set_data(\"plug-in-hot\", &v44, 20i64);\n    default:\n      return result;\n  }\n  result = sub_40025D((unsigned int *)&v44);\n  if ( !(_DWORD)result )\n    dword_40DE18 = 0;\n  return result;\n}\n// 40B54D: using guessed type __int64 __fastcall gimp_window_set_transient(_QWORD);\n// 4001E1: using guessed type __int64 __fastcall _IAT_start__(_QWORD, _QWORD);\n// 40916E: using guessed type __int64 __fastcall gimp_procedural_db_set_data(_QWORD, _QWORD, _QWORD);\n// 409BD2: using guessed type __int64 __fastcall gimp_procedural_db_get_data(_QWORD, _QWORD);\n// 401565: using guessed type __int64 __fastcall gtk_box_new(_QWORD, _QWORD);\n// 4083EE: using guessed type __int64 __fastcall gimp_int_radio_group_new(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD);\n// 408C04: using guessed type __int64 __fastcall gimp_dialog_run(_QWORD);\n// 409E09: using guessed type __int64 __fastcall gimp_dialog_new(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD);\n// 400806: using guessed type __int64 gimp_dialog_get_type(void);\n// 40556C: using guessed type __int64 gimp_locale_directory(void);\n// 40A43F: using guessed type __int64 gtk_window_get_type(void);\n// 400418: using guessed type __int64 __fastcall gtk_widget_show(_QWORD);\n// 40A7A1: using guessed type __int64 __fastcall gtk_widget_destroy(_QWORD);\n// 405E15: using guessed type __int64 __fastcall gtk_toggle_button_set_active(_QWORD, _QWORD);\n// 4035FE: using guessed type __int64 gtk_toggle_button_get_type(void);\n// 406C0E: using guessed type __int64 __fastcall gtk_dialog_set_alternative_button_order(_QWORD, _QWORD, _QWORD, _QWORD);\n// 40C58E: using guessed type __int64 gtk_dialog_get_type(void);\n// 4084BA: using guessed type __int64 __fastcall gtk_dialog_get_content_area(_QWORD);\n// 407C3A: using guessed type __int64 __fastcall gtk_container_set_border_width(_QWORD, _QWORD);\n// 405833: using guessed type __int64 gtk_container_get_type(void);\n// 402FB3: using guessed type __int64 __fastcall gtk_check_button_new_with_mnemonic(_QWORD);\n// 401CB5: using guessed type __int64 __fastcall gtk_box_pack_start(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 40D683: using guessed type __int64 gtk_box_get_type(void);\n// 40D330: using guessed type __int64 __fastcall g_type_check_instance_cast(_QWORD, _QWORD);\n// 4029B8: using guessed type __int64 __fastcall g_signal_connect_data(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);\n// 408CF4: using guessed type __int64 __fastcall libintl_textdomain(_QWORD);\n// 402765: using guessed type __int64 __fastcall libintl_gettext(_QWORD);\n// 402872: using guessed type __int64 __fastcall libintl_bindtextdomain(_QWORD, _QWORD);\n// 407D67: using guessed type __int64 __fastcall libintl_bind_textdomain_codeset(_QWORD, _QWORD);\n// 40D67F: using guessed type int dword_40D67F;\n// 40DE18: using guessed type int dword_40DE18;\n// 4048D8: using guessed type unsigned int var_58[22];\n\n"
    }
]