/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void __thiscall sub_401000(_BYTE *this);
int __stdcall sub_401069(_BYTE *a1, unsigned int a2);
int __thiscall sub_4010BF(_DWORD *this);
int __thiscall sub_4010D3(int this, int a2);
void __thiscall sub_401105(void **this);
void __thiscall sub_401113(int this, int a2);
_QWORD *__thiscall sub_401188(_QWORD *this, int a2);
void __thiscall sub_4011B4(int this, int a2);
bool __thiscall sub_401235(int this);
int __thiscall sub_4012C2(_DWORD *this, char a2);
void __stdcall sub_4012DD(int a1, int a2);
_DWORD *__thiscall sub_401306(_DWORD *this, int a2);
void __thiscall sub_401325(_DWORD *this, unsigned int a2);
char __thiscall sub_40133F(int this, LPWSTR *a2);
void *__thiscall sub_401416(void *this, char a2);
_DWORD *__thiscall sub_401432(_DWORD *this);
char __thiscall sub_40146C(_DWORD *this, char a2);
bool __thiscall sub_4017A4(int this, int a2);
int __thiscall sub_40185E(int this, _BYTE *a2);
char __thiscall sub_401A23(int this, char a2);
char __thiscall sub_401A56(_DWORD *this, int a2);
char __thiscall sub_401A91(_BYTE *this);
int __thiscall sub_401A98(int this);
_WORD *__thiscall sub_401ABA(_DWORD *this, int a2);
unsigned __int64 __thiscall sub_401B47(_DWORD *this);
BOOL __thiscall sub_401B88(const wchar_t *this, wchar_t *String2);
void __stdcall sub_401B9F(int a1);
char __thiscall sub_401BBF(int this);
void __thiscall sub_401C05(_DWORD *this, unsigned int a2);
int __thiscall sub_401C1F(int this);
int __thiscall sub_401C68(_BYTE *this);
int __thiscall sub_401C8B(void *this, int a2);
int __thiscall sub_401CA9(int this);
int __thiscall sub_402716(void *this, int *a2, int a3, int Buf1);
char __thiscall sub_402C37(int this, int *a2, int a3);
int __cdecl sub_402ECC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, __int16 a17, int a18, __int16 a19);
unsigned int __cdecl sub_402ED0(int a1, int a2, int Val, int a4, unsigned __int64 a5, __int64 Buf1, void *Block, int a8, int a9, int a10, int a11, unsigned int a12, int a13, int a14, int a15, unsigned int a16, int a17);
int __thiscall sub_40363F(_DWORD); // weak
int __thiscall sub_4036AE(_DWORD *this, int a2);
int __thiscall sub_403707(wchar_t *this, wchar_t *String2);
int sub_40374F();
int __stdcall sub_4037C2(int a1, unsigned int *a2);
void *__thiscall sub_40489F(void *this);
// int __userpurge sub_4048C2@<eax>(void *a1@<ecx>, int a2@<eax>, int a3);
// int *__userpurge sub_404926@<eax>(const void *a1@<eax>, int a2);
// void __userpurge sub_404C47(int a1@<esi>, char *Src, size_t Size);
// int __userpurge sub_404D06@<eax>(int a1@<esi>, int a2);
int __stdcall sub_404DD4(char *a1);
void __thiscall sub_404E33(int *this);
void __stdcall sub_404E85(int *a1);
void *__stdcall sub_404E91(char *a1, char *Src, unsigned int a3);
int __stdcall sub_404FF9(char *Src, int a2);
bool __stdcall sub_405088(HWND a1, const WCHAR *a2, LPWSTR pszPath);
bool __stdcall sub_405104(HWND a1, const WCHAR *a2, WCHAR *a3, wchar_t *Source, char a5);
char __stdcall sub_405218(wchar_t *a1, char a2, wchar_t *Source, int a4, int a5);
wchar_t *__thiscall sub_405321(_DWORD *this, wchar_t *a2);
char __thiscall sub_40532C(wchar_t *this, wchar_t *a2, int a3);
void __thiscall sub_40533C(int this);
bool __thiscall sub_4053AF(int this, wchar_t *Source, char a3, int a4, char a5);
int __thiscall sub_405409(wchar_t *this, int a2, bool *a3, int a4);
_DWORD *__thiscall sub_405497(_DWORD *this);
unsigned int __stdcall sub_405512(int a1);
unsigned int __stdcall sub_405595(unsigned int a1, _DWORD *a2, unsigned int a3);
_BYTE *__thiscall sub_40566F(_BYTE *this);
int __thiscall sub_4056AB(_BYTE *this);
_BYTE *__thiscall sub_4056F9(bool *this, int a2, void *a3, wchar_t *String, void *Buf2);
_BYTE *__stdcall sub_40598C(char *Src, size_t Size, char *a3, size_t a4, int a5);
_BYTE *__stdcall sub_405AC9(char *a1, size_t Size, void *Src, unsigned int a4, void *a5, void *a6, void *a7, int a8);
void __thiscall sub_405BE4(_DWORD *this, int a2, void *a3, unsigned __int16 *a4, void *Buf2, int Val, unsigned int a7, void *a8, void *a9);
void __thiscall sub_405DE6(_BYTE *this);
void __thiscall sub_405DF2(void *); // idb
void __thiscall sub_405DF7(_BYTE *this);
__m128i *__thiscall sub_405E38(_DWORD *this, __m128i *a2, __m128i *a3);
void __stdcall sub_405E60(_DWORD *a1, char *a2);
int __thiscall sub_405ED9(int this);
char __thiscall sub_405F4F(int this, int a2, int a3, _BYTE *Src, void *Buf2, int Val, int a7, void *a8, void *a9);
BOOL __stdcall sub_406013(HWND hDlg, int nIDDlgItem, unsigned __int8 a3);
BOOL __stdcall sub_406031(HWND hDlg, int nIDDlgItem, char a3);
char __stdcall sub_406056(HWND hWnd, int a2, int a3, int a4, LPCWCH lpWideCharStr, int a6, char a7);
int __thiscall sub_406096(int this);
unsigned int __thiscall sub_4060A7(_BYTE *this, int a2, unsigned __int8 *a3, unsigned int a4, int a5, unsigned int a6);
int __thiscall sub_406205(_DWORD *this);
char __stdcall sub_40621D(int a1);
int __thiscall sub_406222(int *this, int a2);
void __thiscall sub_406265(int this, int pExceptionObject);
bool __thiscall sub_40629E(_BYTE *this, int a1, int a2);
int __thiscall sub_4062AE(int *this);
int __stdcall sub_4062C3(int pExceptionObject); // idb
void __stdcall sub_4062C8(int a1, int a2, int a3);
void __thiscall sub_4062F7(int *this);
void __thiscall sub_40630A(_BYTE *this, int a2);
void __thiscall sub_40632B(_BYTE *this, int a2);
void sub_40634C(int a1, wchar_t *Format, ...);
int __thiscall sub_406382(int *this, int a2, int a3);
int __thiscall sub_4063A1(int *this, int a2, int a3);
int __thiscall sub_4063C0(int *this, int a2, int a3);
int __thiscall sub_4063DF(int *this, int a2, int a3);
int __stdcall sub_4063FE(int a1, int a2);
void __thiscall sub_40641C(int *this, int a2, int a3);
int __thiscall sub_406439(int *this, int a2);
int __thiscall sub_406447(int *this, int a2);
int __thiscall sub_406455(int *this, int a2);
void __thiscall sub_406463(int *this, int a2);
bool __stdcall sub_40647C(LPCWSTR lpName);
char __stdcall sub_4064ED(_DWORD *a1, _WORD *a2, int a3);
bool __stdcall sub_406573(wchar_t *lpFileName, __int16 *lpExistingFileName, int a3);
_DWORD *__thiscall sub_4065D5(_DWORD *this);
void __stdcall sub_4065FE(int a1, WCHAR *lpFileName);
char __stdcall sub_4066FE(int a1, wchar_t *lpFileName, int a3);
char __stdcall sub_406AAD(int a1, int a2, int a3, wchar_t *lpFileName);
char __stdcall sub_406AD4(_DWORD *a1, wchar_t *Source);
char __stdcall sub_406C70(int a1, int a2, WCHAR *lpFileName);
int __thiscall sub_406CC8(_DWORD *this, int a2, wchar_t *a3, wchar_t *String, int a5);
BOOL __thiscall sub_406DC2(_QWORD *this, _QWORD *a2);
BOOL __thiscall sub_406DE0(unsigned int *this, int a2);
void __thiscall sub_406E0C(int this);
DWORD __thiscall sub_406E66(int this, int *a2);
void __stdcall sub_406EE0(int a1, int a2, int a3, int a4);
_DWORD *__thiscall sub_406F15(_DWORD *this, _DWORD *a2);
void __stdcall sub_406FC2(char *a1, unsigned int a2, int a3);
char __stdcall sub_407059(int *a1, int a2, int a3, __int16 *a4, int a5);
char __thiscall sub_407121(_BYTE *this, int a2, wchar_t *Source);
char __thiscall sub_40715B(int this, int a2, int a3);
char __thiscall sub_4072BB(int this, int a2, int a3);
BOOL __stdcall sub_4073CE(int a1, int a2);
bool __thiscall sub_407428(int this, _DWORD *a2, int a3, int a4);
int __thiscall sub_407F3E(int this);
char __thiscall sub_4080F3(int this);
char __stdcall sub_408295(WCHAR *lpszShortPath);
bool __stdcall sub_408465(int a1, int a2, WCHAR *lpFileName, int a4, _BYTE *a5, __int64 a6, int a7, char a8);
_DWORD *__thiscall sub_408533(_DWORD *this);
bool __thiscall sub_408570(int this, WCHAR *lpFileName, char a3);
char __thiscall sub_4086AB(void *this, int a2);
BOOL __thiscall sub_4086D1(int this, WCHAR *lpFileName, DWORD dwShareMode);
char __thiscall sub_408796(void *this, WCHAR *lpFileName, DWORD dwShareMode);
bool __thiscall sub_4087BE(int this);
bool __thiscall sub_40880C(int this);
void __thiscall sub_408835(int *this, char *lpBuffer, DWORD nNumberOfBytesToWrite);
int __thiscall sub_40892A(int this);
char __fastcall sub_4089AB(int *a1);
BOOL __thiscall sub_4089C3(HANDLE *this);
_DWORD __stdcall nullsub_1(_DWORD, _DWORD); // weak
bool __thiscall sub_4089D6(HANDLE *this);
bool __thiscall sub_4089F9(int this);
DWORD __thiscall sub_408A1C(int this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead);
BOOL __thiscall sub_408AB6(int this, int *a2, int *a3, int *a4);
__int64 __thiscall sub_408B84(int *this);
void *__thiscall sub_408BE0(void *this, char a2);
DWORD __thiscall sub_408BFC(_BYTE *this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead);
bool __thiscall sub_408CCC(int *this, __int64 lDistanceToMove, DWORD dwMoveMethod);
char __thiscall sub_408D40(int *this, __int64 lDistanceToMove);
void __thiscall sub_408D6E(int this, __int64 lDistanceToMove, DWORD dwMoveMethod);
BOOL __stdcall sub_408D9D(int a1);
int __stdcall sub_408DB5(unsigned int a1);
DWORD __stdcall sub_408DC2(WCHAR *lpFileName);
bool __stdcall sub_408E0E(WCHAR *lpFileName, DWORD dwFileAttributes);
bool __stdcall sub_408E65(WCHAR *lpFileName);
char __stdcall sub_408EB6(WCHAR *lpFileName, int *a2, int *a3, int *a4);
bool __stdcall sub_409026(WCHAR *lpFileName);
bool __stdcall sub_40903C(WCHAR *lpFileName);
int __stdcall sub_40904A(WCHAR *lpPathName, char a2, DWORD dwFileAttributes);
bool __stdcall sub_4090CB(wchar_t *Source, char a2);
_DWORD *__thiscall sub_4091A0(_DWORD *this);
HANDLE __thiscall sub_4091B6(HANDLE *this);
wchar_t *__thiscall sub_4091C9(wchar_t *Destination, wchar_t *Source);
int __stdcall sub_4091E3(int hFindFile, WCHAR *lpFileName, wchar_t *Destination);
char __thiscall sub_40937B(WCHAR *lpFileName, wchar_t *String, int a3);
char __stdcall sub_409429(wchar_t *String, wchar_t *Destination, int a3);
int __thiscall sub_40948D(int this, char a2);
void __thiscall sub_4094C3(int this);
int __thiscall sub_4094D3(int this, int a2);
int __thiscall sub_4094F9(_DWORD *this);
int __thiscall sub_409527(_DWORD *this, int a2);
int __thiscall sub_40953E(_DWORD *this);
void *__thiscall sub_409543(_DWORD *this, void *a2);
bool __thiscall sub_409572(int *this, int *a2);
_BYTE *__thiscall sub_4095C9(int this);
int __thiscall sub_4095F2(void *this, int a2, unsigned int a3);
void __thiscall sub_409631(void *this, char *Src, int a3);
int __stdcall sub_40969B(int a1, int a2, int a3, int a4, int (__thiscall *a5)(int, int));
char *__fastcall sub_4096C2(_DWORD *a1);
int __thiscall sub_4096EE(int this, int a2);
_DWORD *__thiscall sub_409732(_DWORD *this, int a2);
_DWORD *__thiscall sub_40974B(_DWORD *this);
_DWORD *__thiscall sub_409776(_DWORD *this, int a2);
_DWORD *__thiscall sub_4097E5(_DWORD *this);
int __thiscall sub_409804(int *this, int *a2);
bool __thiscall sub_409856(int *this, int *a2, char *a3);
int __thiscall sub_409886(int this);
void *__thiscall sub_4098B1(int this, unsigned int a2);
int __stdcall sub_409973(int C, char a2);
int __stdcall sub_40998C(wchar_t *String1, wchar_t *String2, char a3); // idb
int __stdcall sub_4099AD(wchar_t *String1, wchar_t *String2, size_t MaxCount, char a4); // idb
bool __stdcall sub_4099D2(unsigned __int16 *a1, wchar_t *Str, char a3);
char __stdcall sub_409AF8(wchar_t *String, wchar_t *Source, int a3);
unsigned int __thiscall sub_409C86(void *this);
int __thiscall sub_409CFD(void **this);
int __thiscall sub_409D27(int this);
wchar_t *__stdcall sub_409D8B(wchar_t *String);
BOOL __stdcall sub_409DA5(wchar_t *String);
BOOL __stdcall sub_409DC6(int a1);
BOOL __stdcall sub_409DDE(int a1);
wchar_t *__stdcall sub_409DEB(wchar_t *String, unsigned int a2);
wchar_t *__stdcall sub_409E1B(wchar_t *Source, wchar_t *a2, wchar_t *Destination, int a4);
bool __stdcall sub_409E72(wchar_t *String);
void __stdcall sub_409EE6(wchar_t *a1, char a2);
void __stdcall sub_409F99(char *a1, int a2, int a3);
int __stdcall sub_409FD2(__int16 *a1, int a2, int a3);
BOOL __stdcall sub_40A017(wint_t *a1);
int __stdcall sub_40A043(wchar_t *Str, char a2); // idb
wchar_t *__stdcall sub_40A078(LPCCH lpMultiByteStr, wchar_t *Source, wchar_t *Destination, size_t Count);
wchar_t *__stdcall sub_40A0CE(wchar_t *String);
wchar_t *__stdcall sub_40A10B(wchar_t *a1, wchar_t *Destination);
wchar_t *__stdcall sub_40A238(wchar_t *String, wchar_t *Source, int a3);
wchar_t *__stdcall sub_40A25D(wchar_t *String);
BOOL __stdcall sub_40A27B(wchar_t *String, PCNZWCH lpString2);
int __stdcall sub_40A2A1(wchar_t *Source, wchar_t *Destination, int a3); // idb
wchar_t *__stdcall sub_40A2E6(wchar_t *String);
wchar_t *__stdcall sub_40A311(wchar_t *String);
int __stdcall sub_40A394(wchar_t *String, int a2, char a3); // idb
BOOL __stdcall sub_40A4BE(wint_t *a1);
wchar_t *__stdcall sub_40A4F3(wchar_t *String, wchar_t *Destination, size_t BufferCount);
char __stdcall sub_40A582(wchar_t *String, wchar_t *Destination, unsigned int a3);
wchar_t *__stdcall sub_40A72F(WCHAR *lpFileName, wchar_t *Destination, int a3);
_DWORD *__thiscall sub_40A7E1(_DWORD *this);
void __thiscall sub_40A7F3(void **this);
void __thiscall sub_40A807(_DWORD *this);
int __stdcall sub_40A820(_DWORD *a1, int a2);
int __stdcall sub_40A82D(_DWORD *a1);
int __thiscall sub_40A8CB(_DWORD *this, unsigned int a2, void *Src, unsigned int a4);
int __stdcall sub_40A8FF(_DWORD *a1, unsigned int a2);
unsigned int __stdcall sub_40A940(int a1, int a2, char a3);
int __stdcall sub_40A990(int a1, int a2, int a3, char a4);
void __thiscall sub_40A9E9(int this, int a2);
_DWORD *__thiscall sub_40AA63(int this, _BYTE *Src, unsigned int a3, _DWORD *a4);
void __thiscall sub_40AB67(_DWORD *this, int a2);
char __thiscall sub_40B00B(_DWORD *this, _DWORD *a2, unsigned int a3);
int __thiscall sub_40B06D(_DWORD *this, size_t Size);
int __thiscall sub_40B189(_DWORD *this, unsigned int a2);
int __thiscall sub_40B223(_DWORD *this);
int __thiscall sub_40B23B(_DWORD *this);
int __thiscall sub_40B270(_DWORD *this);
unsigned __int64 __thiscall sub_40B2AD(_DWORD *this);
__int64 __thiscall sub_40B2CE(int *this);
int __thiscall sub_40B331(int *this, unsigned int a2);
size_t __thiscall sub_40B357(_DWORD *this, char *a2, unsigned int a3);
int __thiscall sub_40B3A7(_DWORD *this, char a2);
unsigned int __thiscall sub_40B3D7(_DWORD *this);
_DWORD *__thiscall sub_40B3F7(_DWORD *this, int a2);
int __thiscall sub_40B419(_DWORD *this);
void __thiscall sub_40B4B9(int this, __int64 a2, unsigned int a3, int a4);
int __thiscall sub_40B524(_DWORD *this, int a2, int a3);
char __thiscall sub_40B544(_BYTE *this, char a2, int a3, _BYTE *Src, void *Buf2, int Val, int a7, void *a8, void *a9);
int __thiscall sub_40B58F(int this, int a2, int a3);
_DWORD *__thiscall sub_40B5A4(_DWORD *this);
int __thiscall sub_40B60F(char *this, __m128i *a2, unsigned int a3);
char __thiscall sub_40B7BF(int this, char *Src, size_t Size);
_DWORD *__thiscall sub_40B82C(_DWORD *this);
BOOL __thiscall sub_40B842(_DWORD *this);
__int16 *__thiscall sub_40B84A(__int16 **this, int a2);
void __thiscall sub_40B8B0(_BYTE *this, HWND hWnd);
char __thiscall sub_40B8D7(int this, wchar_t *Source);
wchar_t *__thiscall sub_40BBC2(__int16 **this, wchar_t *Source, wchar_t *Destination, int a4, int a5, LPCWCH lpWideCharStr);
BOOL __thiscall sub_40BD12(__int16 **this, LPCWCH lpWideCharStr, _DWORD *a3, _DWORD *a4);
char __thiscall sub_40BD93(int this);
HWND __thiscall sub_40BDF9(__int16 **this, HWND hWnd, LPCWCH lpWideCharStr, HWND a4);
char __thiscall sub_40C045(void *this, wchar_t *Source);
WCHAR *__stdcall sub_40C05C(UINT uID);
int __stdcall sub_40C0D8(int *a1, _DWORD *a2, _DWORD *a3);
__m128i *__thiscall sub_40C10A(int this, const __m128i *a2, int a3, __m128i *a4);
char __thiscall sub_40C19C(_DWORD *this, void *Src);
int __thiscall sub_40C361(_DWORD *this);
int sub_40C3F3();
_BYTE *__thiscall sub_40C6D6(_BYTE *this);
char __thiscall sub_40C6EF(bool *this, int a2, int a3, int a4, int Val);
__m128i *__thiscall sub_40C7C0(_DWORD *this, const __m128i *a2, __m128i *a3, __m128i *a4);
void __thiscall sub_40CB53(HMODULE *this);
DWORD __stdcall sub_40CB92(int a1, unsigned int a2, char a3);
_BYTE *__stdcall sub_40CC38(_BYTE *a1, int a2);
DWORD __stdcall sub_40CC4E(void *Src, unsigned int a2, void *a3, unsigned int a4, char a5);
int __thiscall sub_40CC83(void *Src, _WORD *a2, int a3);
void *__thiscall sub_40CCBC(_BYTE *this, wchar_t *String);
int __thiscall sub_40CD07(void *this, void *Src);
_BYTE *__thiscall sub_40CD6F(_BYTE *this);
_BYTE *__thiscall sub_40CD80(_BYTE *this);
int __thiscall sub_40CD93(_DWORD); // weak
LRESULT sub_40CD98();
int __stdcall sub_40CDD7(__int64 a1, LPWSTR lpNumberStr, int cchNumber);
unsigned int __stdcall sub_40CE5E(unsigned int a1, unsigned int a2);
int __stdcall sub_40CE92(LPWSTR pszPath, int csidl); // idb
__int16 *__stdcall sub_40CECC(__int16 *a1);
int __stdcall sub_40CF18(int a1);
int __stdcall sub_40CF5B(int a1);
BOOL sub_40CF9E();
LRESULT __stdcall sub_40CFBD(char a1, LPARAM a2);
LPCWSTR sub_40D0D1(LPCWSTR a1, ...);
INT_PTR __stdcall sub_40D113(HWND hDlg, int a2, int a3, WCHAR *lpString);
INT_PTR __stdcall DialogFunc(HWND hDlg, int a2, int a3, const WCHAR *lpString);
LRESULT __stdcall sub_40D238(int a1, int a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7, int a8);
INT_PTR __stdcall sub_40D263(HWND hDlg, int a2, int a3, const WCHAR **a4);
unsigned __int16 *__stdcall sub_40D31C(unsigned __int16 *a1);
// int swprintf(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, ...);
WCHAR *__fastcall sub_40D46E(_BYTE *a1, WCHAR *a2, WCHAR *a3, wchar_t *Destination, _BYTE *a5, int a6);
DWORD __stdcall sub_40D544(HANDLE hHandle);
int sub_40D583();
// wchar_t *__usercall sub_40D61A@<eax>(WCHAR **a1@<edi>);
// LRESULT __usercall sub_40D6EA@<eax>(HWND a1@<esi>);
// wchar_t *__userpurge sub_40D73C@<eax>(wchar_t *a1@<esi>, wchar_t *Source);
void __stdcall sub_40D779(BYTE *lpData);
void __stdcall sub_40D803(wchar_t *Destination, int a2);
HWND __stdcall sub_40D8AE(HWND hWnd);
unsigned __int16 *__stdcall sub_40D9A5(unsigned __int16 *a1, _WORD *a2);
wchar_t *__stdcall sub_40DA6B(wchar_t *String, int a2);
BOOL __stdcall sub_40DAEC(int a1, int a2, int a3, char a4);
INT_PTR __stdcall sub_40DB4B(HWND hDlg, HANDLE hFindFile, int a3, wchar_t *a4);
char __stdcall sub_40DE9F(int a1, LPCCH lpMultiByteStr, wchar_t *Source, _BYTE *a4);
void sub_40DF70(int a1, wchar_t *Format, ...);
void __stdcall sub_40DFC4(int a1, wchar_t *Source);
BOOL __stdcall sub_40E0BC(LPARAM a1, LPARAM a2);
LRESULT __stdcall sub_40E0F7(char a1, wchar_t *String);
void __thiscall sub_40E152(const WCHAR *this, HWND hWnd, char a3);
INT_PTR __stdcall sub_40E3FA(LPARAM dwInitParam, int a2, __int64 a3, int a4, int a5);
bool __stdcall sub_40E48A(int a1, int a2, _DWORD *a3, int *a4);
WCHAR *__stdcall sub_40E582(HWND hWnd, WCHAR *a2, int a3);
INT_PTR __stdcall sub_40F1A6(HWND hWnd, HWND a2, int a3, LPARAM a4);
INT_PTR __stdcall sub_40F2B8(HWND hDlg, HWND hWnd, HANDLE hFileMappingObject, LPCVOID lpBaseAddress);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
_DWORD *__stdcall sub_40FD6B(const void *a1, unsigned int *a2, void *Src, char a4);
_DWORD *__stdcall sub_4100CB(_DWORD *a1);
void *__stdcall sub_4100FC(unsigned int *a1, char *Src, unsigned int a3, char a4);
_BYTE *__stdcall sub_4101B0(int Src, int a2, char a3);
_DWORD *__stdcall sub_4102A1(_DWORD *a1);
// _BYTE *__usercall sub_4102E7@<eax>(int a1@<esi>);
_BYTE *__stdcall sub_4105A3(_DWORD *a1, char *Src, size_t Size);
_BYTE *__stdcall sub_41061C(int a1, int a2);
int __stdcall sub_4106CF(__int64 a1, __int64 a2);
int __stdcall sub_4106FA(__int64 a1, __int64 a2);
BOOL __stdcall sub_410725(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
int __stdcall sub_410745(wint_t a1);
BOOL __stdcall sub_410760(int a1);
BOOL __stdcall sub_410772(int a1);
int __stdcall sub_41078A(PCNZWCH lpString1, PCNZWCH lpString2); // idb
wchar_t *__stdcall sub_41078F(wchar_t *Destination, wchar_t *Source, int a3);
wchar_t *__stdcall sub_4107BC(wchar_t *String, wchar_t *Source, unsigned int a3);
int __stdcall sub_4107EB(__int64 a1, int a2);
unsigned __int16 *__stdcall sub_410841(unsigned __int16 *a1, int a2, int a3);
void __thiscall sub_4108E4(_DWORD *this);
void __thiscall sub_4108E9(_DWORD *this);
wchar_t *__thiscall sub_4108FF(_DWORD *this, wchar_t *String);
char __thiscall sub_41093B(_DWORD *this, const wchar_t **a2);
_DWORD *__thiscall sub_410977(_DWORD *this);
char __thiscall sub_410990(wchar_t *this, wchar_t *Destination, int a3);
const wchar_t *__thiscall sub_4109B5(wchar_t *this);
char sub_4109C7();
HMODULE __stdcall sub_410A27(char a1);
int sub_410A5B();
DWORD __stdcall sub_410AAB(HANDLE hHandle);
int sub_410AE6();
unsigned int sub_410B1D();
char *__thiscall sub_410B34(char *this, unsigned int a2);
char __thiscall sub_410BD6(int this, _DWORD *a2);
int __thiscall sub_410C36(int this);
void *sub_410C7D();
BOOL __thiscall sub_410CE2(int this);
char __thiscall sub_410D4F(int this);
DWORD __stdcall StartAddress(LPVOID lpThreadParameter); // idb
void __stdcall sub_410DB4(void *a1);
void __thiscall sub_410E04(HANDLE *lpParameter);
int __thiscall sub_410E83(int this, int a2, int a3);
_DWORD *__thiscall sub_410EE3(_DWORD *this, _DWORD *a2);
int __thiscall sub_410EF6(int *this, _DWORD *a2);
_QWORD *__thiscall sub_410F07(_QWORD *this, __int64 a2);
int __thiscall sub_410F33(_DWORD *this, int a2, int a3);
DWORD __thiscall sub_410F43(DWORD *this);
BOOL __stdcall sub_410F72(int a1);
DWORD __thiscall sub_410FA1(DWORD *this, int *a2);
int __thiscall sub_4110D5(_DWORD *this, int a2);
int __thiscall sub_4111C2(_DWORD *this, unsigned int a2);
INT_PTR __stdcall sub_41121D(LPARAM dwInitParam, int a2, __int64 a3, int a4, int a5);
LRESULT __stdcall sub_41123B(char a1, wchar_t *String);
BOOL __stdcall sub_411257(int, int, int, char);
LRESULT __stdcall sub_41125C(int a1, int a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7, int a8);
void __thiscall sub_411280(int *this);
char __stdcall sub_4114D8(int a1, wchar_t *Source, _BYTE *a3);
char sub_4114EE();
LRESULT sub_4114F4();
BOOL __stdcall sub_4114F9(LPARAM, LPARAM);
INT_PTR __stdcall sub_4114FE(int a1, wchar_t *Source, int a3, __int64 a4, int a5, int a6);
bool __stdcall sub_4115D5(int a1, int a2);
bool __stdcall sub_411643(LPCWCH lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte);
bool __stdcall sub_411682(LPCCH lpMultiByteStr, LPWSTR lpWideCharStr, int cchWideChar);
int __stdcall sub_4116BD(_BYTE *a1, int a2, unsigned int a3);
int __stdcall sub_4116ED(unsigned __int8 *a1, int a2, unsigned int a3);
unsigned int __stdcall sub_41172D(unsigned __int16 *a1, _BYTE *a2, int a3);
char __stdcall sub_411817(_BYTE *a1, _WORD *a2, int a3);
int __stdcall sub_4119A6(PCNZWCH lpString1, PCNZWCH lpString2); // idb
int __stdcall sub_4119C7(PCNZWCH lpString1, PCNZWCH lpString2, unsigned int a3);
int __stdcall sub_411A29(wint_t C); // idb
unsigned int __stdcall sub_411A39(_WORD *a1);
bool __thiscall sub_411A88(_BYTE *this);
_DWORD __stdcall sub_411AC8(_DWORD); // weak
unsigned __int8 *__thiscall sub_411ACD(unsigned __int8 *this, int a2, int a3, int a4);
void __thiscall sub_411B2D(_DWORD *this);
char __thiscall sub_411B42(unsigned int *this, int a2);
_BYTE *__thiscall sub_411B9E(char *this);
// _DWORD __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *__hidden this); idb
void __thiscall sub_411CB5(void *this);
_DWORD *__thiscall sub_411CC0(_DWORD *this, char a2);
_DWORD *__thiscall sub_411CE2(unsigned __int8 *this, _DWORD *Src, int a3, int a4);
int __thiscall sub_411D52(int this, int a2);
void *__thiscall sub_411E81(_BYTE *this);
bool __thiscall sub_411E9F(int this);
bool __thiscall sub_411F1D(int this);
unsigned int __thiscall sub_411FD6(int *this, char *Src, size_t Size);
char *__thiscall sub_412035(char *this);
void __thiscall sub_41205E(void **this);
void __thiscall sub_41207F(void **this, unsigned int a2);
std::exception *__thiscall sub_41212C(std::exception *this, struct std::exception *a2);
int __thiscall sub_412144(int *this, unsigned int a2);
void __thiscall sub_41217C(int *this, int a2, int a3, unsigned int *a4, int a5);
void __thiscall sub_4121C1(int *this, _BYTE *a2, int a3, int a4);
unsigned int __thiscall sub_4121ED(unsigned int *this, unsigned int a2, unsigned int a3);
void __thiscall sub_412222(int this, size_t Size, char a3);
char __stdcall sub_41237D(int a1, unsigned int *a2, unsigned int a3);
void __stdcall sub_4124F5(int *a1, int *a2);
void __thiscall sub_41251D(int this, int a2);
void __thiscall sub_412595(int this);
void __thiscall sub_4125B2(int this, int a2);
int __thiscall sub_41262C(_DWORD *this);
int __thiscall sub_412669(unsigned __int16 *this);
_BYTE *__thiscall sub_412687(_BYTE *this);
void __thiscall sub_4126A6(_DWORD *this);
void __thiscall sub_4126BE(void **this);
int __thiscall sub_4126DB(int *this);
int __thiscall sub_4126FC(void *this, int a2);
char *__thiscall sub_412730(_DWORD *this);
_DWORD *__thiscall sub_412890(int this, int a2);
_DWORD *__thiscall sub_41292D(_DWORD *this, int a2);
_DWORD *__thiscall sub_412982(_DWORD *this);
_DWORD *__thiscall sub_4129B2(_DWORD *this, _DWORD *Src, int a3);
_DWORD *__thiscall sub_412A08(void *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_412A40(_DWORD *this);
int __thiscall sub_412A5D(int this);
void *__thiscall sub_412BD8(int this, int a2);
int *__thiscall sub_412C89(unsigned __int16 *this, int a2);
_DWORD *__thiscall sub_412E18(_DWORD *this, char a2, char *a3);
int __thiscall sub_412F32(int this);
void __thiscall sub_413210(unsigned __int16 *this, int a2, int a3);
char __thiscall sub_413258(unsigned __int16 *this, int a2);
int __thiscall sub_413396(unsigned __int16 *this, int a2, int a3);
unsigned __int16 *__thiscall sub_4133D0(unsigned __int16 *this, int a2, int a3);
char __thiscall sub_413462(unsigned __int16 *this, int a2);
void *__thiscall sub_4135A1(unsigned int *this);
bool __thiscall sub_4135C7(unsigned int *this, int *a2, int *a3);
int __thiscall sub_41366A(int this);
void __thiscall sub_413829(_DWORD *this);
char *__thiscall sub_41392E(char *this, char a2);
int __thiscall sub_41397A(unsigned int *this);
void __thiscall sub_4139A7(void **this);
int __thiscall sub_4139C2(int *this, _DWORD *Size);
char __thiscall sub_413A24(int this);
int __stdcall sub_413D6C(_DWORD *a1);
bool __thiscall sub_413DD1(_DWORD *this, int a2, int a3);
_BYTE *__thiscall sub_413E47(_DWORD *this, _BYTE *a2, unsigned int a3, unsigned __int8 *a4);
void __thiscall sub_413FA1(int this, unsigned int a2, size_t a3);
bool __thiscall sub_414050(_DWORD *this, int *a2, int a3);
bool __thiscall sub_41416C(_DWORD *this, int a2, int a3, unsigned int *a4);
int __thiscall sub_41442E(_DWORD *this, int a2);
void __thiscall sub_414449(_DWORD *this, unsigned int a2);
int __thiscall sub_414463(_DWORD *this, int a2, int a3, int a4, int a5);
char __thiscall sub_414487(_DWORD *this, int a2);
char __thiscall sub_414A4B(int this);
void **__thiscall sub_414AA5(void **this, char a2);
unsigned int __thiscall sub_414AC4(int this);
void __thiscall sub_414E0E(_DWORD *this);
unsigned int __thiscall sub_414E8A(int this);
void __thiscall sub_415133(int this);
_DWORD *__thiscall sub_415206(_DWORD *this);
char __stdcall sub_415237(int a1);
void __thiscall sub_415266(int this, char a2);
char __thiscall sub_4152AF(_DWORD *this, int a2);
void __thiscall sub_41530F(int this, char a2);
char __thiscall sub_4153B7(int this, int a2);
bool __thiscall sub_4158D3(int this, int a2);
char __thiscall sub_4162C9(int this, char a2, void *Src, signed int Size);
char __thiscall sub_416767(int this, char a2);
int __thiscall sub_4171B2(int this, int a2);
void *__thiscall sub_4172C2(int this, char a2);
char __thiscall sub_4176B3(_DWORD *this);
char __thiscall sub_4177C3(unsigned int *this);
char __thiscall sub_417894(int this, char a2);
unsigned __int8 __thiscall sub_41861B(int this, int a2, char a3);
char __stdcall sub_418659(_DWORD *a1, int a2, int a3, __int16 a4);
int __thiscall sub_418932(_DWORD *this);
int __stdcall sub_418963(int a1);
int __stdcall sub_418970(int a1, int a2, int a3, int a4);
int __stdcall sub_418978(int a1, int a2);
int __stdcall sub_418980(int a1, _DWORD *a2);
int __stdcall sub_4189A4(int a1);
int __stdcall sub_4189A9(int a1, _DWORD *a2, _DWORD *a3, RECT *lprcSrc, LPRECT lprcDst, _DWORD *a6);
int __stdcall sub_418A23(int a1, int a2, int a3);
int __stdcall sub_418A2B(int a1, int a2);
int __stdcall sub_418A33(int a1);
int __stdcall sub_418A3B(int a1, int a2);
BOOL __stdcall sub_418A40(void *Buf1, void *Buf2);
int __stdcall sub_418A5A(int a1, int a2, int a3);
int __stdcall sub_418A5F(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __stdcall sub_418A6E(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
HRESULT __thiscall sub_418A76(LPVOID *this, LPCOLESTR lpsz);
int (__stdcall ***__thiscall sub_418AFC(_DWORD *this))(_DWORD, void *, int *);
void __thiscall sub_418B7C(_DWORD *this, int a2);
void __thiscall sub_418BEC(_DWORD *this, int a2);
int __thiscall sub_418C38(_DWORD *this);
_DWORD *__thiscall sub_418C53(_DWORD *this);
int __thiscall sub_418C75(_DWORD *this);
HWND __thiscall sub_418CA4(HWND *this);
BOOL __stdcall sub_418CBB(int a1, int a2);
char __stdcall sub_418D92(_WORD *a1);
wchar_t *__stdcall sub_418DC8(wchar_t *Block);
int __thiscall sub_418EC0(_DWORD **this);
int __stdcall sub_418F6F(int a1, int a2);
int __stdcall sub_418F97(int a1);
int __stdcall sub_418FA1(int a1, void *Buf1, _DWORD *a3);
int __stdcall sub_41904C(_DWORD *a1);
void __thiscall sub_41906D(int *this, wchar_t *String);
WCHAR *__stdcall sub_4191B6(wchar_t *String);
void __thiscall sub_419338(int this);
int __stdcall sub_419365(int a1, void *a2, _DWORD *a3);
int __stdcall sub_41936F(int a1);
int __stdcall sub_419383(int a1);
_DWORD *__thiscall sub_4193A1(_DWORD *this);
void __thiscall sub_4193E1(int this, int a2);
LRESULT __stdcall sub_419491(HWND hWnd, UINT Msg, WPARAM wParam, LONG *lParam);
ATOM __thiscall sub_4194DB(HINSTANCE *this, HINSTANCE a2);
void __thiscall sub_419542(LPVOID lpParam, HINSTANCE a2, HWND hWnd, int a4, int a5, char X);
char __stdcall sub_419655(char a1, int a2, int a3, int a4, int a5, int a6, int a7);
BOOL __stdcall sub_41972D(LPCWSTR lpPathName);
BOOL __stdcall sub_419740(LPWSTR lpBuffer, DWORD nBufferLength);
HWND __stdcall sub_419757(HWND hWnd);
HANDLE __stdcall sub_4197B0(HANDLE h, int a2, int ho);
HMODULE *__thiscall sub_419958(HMODULE *this);
void __thiscall sub_4199B2(HMODULE *this);
// void *__cdecl operator new[](unsigned int); idb
// void __cdecl operator delete(void *); idb
// void __cdecl free(void *Block);
// void *__cdecl realloc(void *Block, size_t Size);
// size_t __cdecl wcslen(const wchar_t *String);
// wchar_t *__cdecl wcscat(wchar_t *Destination, const wchar_t *Source);
// wchar_t *__cdecl wcscpy(wchar_t *Destination, const wchar_t *Source);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl operator new(size_t Size); idb
// int __cdecl _vswprintf_c_l(wchar_t *const Buffer, const size_t BufferCount, const wchar_t *const Format, const _locale_t Locale, va_list ArgList);
// int __cdecl wcscmp(const wchar_t *String1, const wchar_t *String2);
// size_t __cdecl strlen(const char *Str);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *)); idb
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, int, void (__thiscall *)(void *), void (__thiscall *)(void *)); idb
// clock_t __cdecl clock();
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
void __thiscall sub_41C239(struct type_info *this);
struct type_info *__thiscall sub_41C249(struct type_info *this, char a2);
// int __cdecl wcsncmp(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// wchar_t *__cdecl wcsncpy(wchar_t *Destination, const wchar_t *Source, size_t Count);
// void __cdecl operator delete[](void *); idb
// wchar_t *__cdecl wcspbrk(const wchar_t *String, const wchar_t *Control);
// wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch);
// wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// int __cdecl abs(int Number);
// void *__cdecl malloc(size_t Size);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// int __cdecl toupper(int C);
// unsigned int __cdecl _byteswap_ulong(unsigned int Number);
// wchar_t *__cdecl wcsncat(wchar_t *Destination, const wchar_t *Source, size_t Count);
// wint_t __cdecl towupper(wint_t C);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *); idb
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *); idb
void __thiscall sub_41D17D(void *this);
void *__thiscall sub_41D1A0(void *this, char a2);
std::exception *__thiscall sub_41D425(std::exception *this, char *a2);
void __thiscall sub_41D443(void *this);
_DWORD *__thiscall sub_41D44E(_DWORD *this, char a2);
std::exception *__thiscall sub_41DFDB(std::exception *this, struct std::exception *a2);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
int __cdecl sub_41F68C(int a1);
// int _get_sse2_info(void); weak
int sub_41F85B();
int __cdecl sub_41F9CC(int a1);
// void __cdecl type_info::_Type_info_dtor(struct type_info *); idb
void **sub_420E88();
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_422FA5();
int __thiscall nullsub_2(_DWORD); // weak
void *sub_423831();
void __cdecl sub_423857(); // idb
int __cdecl sub_423CAF(int a1);
void sub_4248F9();
int sub_424DD8();
int __cdecl sub_424F95(int a1);
int __cdecl sub_424FA4(int a1);
// _DWORD __cdecl flsall(_DWORD); weak
int sub_4251DC();
int __cdecl sub_4251E5(int a1, int a2, int a3);
int __cdecl sub_425E1D(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_425EC5(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_426D8C(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_4272D0(unsigned __int16 *a1, _DWORD *a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
bool sub_4294E0();
int sub_429515();
int sub_42951F();
int sub_429529();
void sub_429533();
void __cdecl sub_42953F(); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_429301; // weak
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern BOOL (__stdcall *SetFileSecurityW)(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern BOOL (__stdcall *LookupPrivilegeValueW)(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *InitCommonControlsEx)(const INITCOMMONCONTROLSEX *picce);
// extern BOOL (__stdcall *GetSaveFileNameW)(LPOPENFILENAMEW);
// extern DWORD (__stdcall *CommDlgExtendedError)();
// extern BOOL (__stdcall *GetOpenFileNameW)(LPOPENFILENAMEW);
// extern int (__stdcall *GetObjectW)(HANDLE h, int c, LPVOID pv);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern int (__stdcall *GetDeviceCaps)(HDC hdc, int index);
// extern HBITMAP (__stdcall *CreateDIBSection)(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern DWORD (__stdcall *GetCurrentDirectoryW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern DWORD (__stdcall *GetFullPathNameW)(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern HRSRC (__stdcall *FindResourceW)(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern int (__stdcall *GetLocaleInfoW)(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// extern int (__stdcall *GetNumberFormatW)(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
// extern DWORD (__stdcall *ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern int (__stdcall *GetDateFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// extern int (__stdcall *GetTimeFormatW)(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode);
// extern DWORD (__stdcall *GetTempPathW)(DWORD nBufferLength, LPWSTR lpBuffer);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *UnmapViewOfFile)(LPCVOID lpBaseAddress);
// extern LPVOID (__stdcall *MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern HANDLE (__stdcall *CreateFileMappingW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *SetEnvironmentVariableW)(LPCWSTR lpName, LPCWSTR lpValue);
// extern HANDLE (__stdcall *OpenFileMappingW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *GetProcessAffinityMask)(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern HANDLE (__stdcall *CreateSemaphoreW)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern void (__stdcall *GetSystemTime)(LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *SystemTimeToTzSpecificLocalTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
// extern BOOL (__stdcall *TzSpecificLocalTimeToSystemTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern BOOL (__stdcall *SetFileTime)(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern BOOL (__stdcall *IsDBCSLeadByte)(BYTE TestChar);
// extern BOOL (__stdcall *GetCPInfo)(UINT CodePage, LPCPINFO lpCPInfo);
// extern HGLOBAL (__stdcall *GlobalAlloc)(UINT uFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *SetCurrentDirectoryW)(LPCWSTR lpPathName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern DWORD (__stdcall *GetLongPathNameW)(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer);
// extern DWORD (__stdcall *GetShortPathNameW)(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);
// extern int (__stdcall *CompareStringW)(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// extern BOOL (__stdcall *MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *CreateDirectoryW)(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern BOOL (__stdcall *DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *RemoveDirectoryW)(LPCWSTR lpPathName);
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *CreateHardLinkW)(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern DWORD (__stdcall *GetLastError)();
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern void (__stdcall *VariantInit)(VARIANTARG *pvarg);
// extern HRESULT (__stdcall *SHGetMalloc)(IMalloc **ppMalloc);
// extern HRESULT (__stdcall *SHGetSpecialFolderLocation)(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);
// extern DWORD_PTR (__stdcall *SHGetFileInfoW)(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);
// extern BOOL (__stdcall *ShellExecuteExW)(SHELLEXECUTEINFOW *pExecInfo);
// extern void (__stdcall *SHChangeNotify)(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
// extern int (__stdcall *SHFileOperationW)(LPSHFILEOPSTRUCTW lpFileOp);
// extern LPITEMIDLIST (__stdcall *SHBrowseForFolderW)(LPBROWSEINFOW lpbi);
// extern BOOL (__stdcall *SHGetPathFromIDListW)(LPCITEMIDLIST pidl, LPWSTR pszPath);
// extern HRESULT (__stdcall *SHAutoComplete)(HWND hwndEdit, DWORD dwFlags);
// extern BOOL (__stdcall *EnableWindow)(HWND hWnd, BOOL bEnable);
// extern HWND (__stdcall *GetDlgItem)(HWND hDlg, int nIDDlgItem);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern LONG (__stdcall *SetWindowLongW)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern HWND (__stdcall *FindWindowExW)(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);
// extern HWND (__stdcall *GetParent)(HWND hWnd);
// extern int (__stdcall *MapWindowPoints)(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
// extern HWND (__stdcall *CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern BOOL (__stdcall *UpdateWindow)(HWND hWnd);
// extern HCURSOR (__stdcall *LoadCursorW)(HINSTANCE hInstance, LPCWSTR lpCursorName);
// extern ATOM (__stdcall *RegisterClassExW)(const WNDCLASSEXW *);
// extern LRESULT (__stdcall *DefWindowProcW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern BOOL (__stdcall *CopyRect)(LPRECT lprcDst, const RECT *lprcSrc);
// extern BOOL (__stdcall *IsWindow)(HWND hWnd);
// extern BOOL (__stdcall *OemToCharBuffA)(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
// extern HICON (__stdcall *LoadIconW)(HINSTANCE hInstance, LPCWSTR lpIconName);
// extern HBITMAP (__stdcall *LoadBitmapW)(HINSTANCE hInstance, LPCWSTR lpBitmapName);
// extern BOOL (__stdcall *PostMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *SetForegroundWindow)(HWND hWnd);
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern DWORD (__stdcall *WaitForInputIdle)(HANDLE hProcess, DWORD dwMilliseconds);
// extern BOOL (__stdcall *IsWindowVisible)(HWND hWnd);
// extern INT_PTR (__stdcall *DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// extern BOOL (__stdcall *DestroyIcon)(HICON hIcon);
// extern HWND (__stdcall *SetFocus)(HWND hWnd);
// extern int (__stdcall *GetClassNameW)(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
// extern LRESULT (__stdcall *SendDlgItemMessageW)(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *EndDialog)(HWND hDlg, INT_PTR nResult);
// extern UINT (__stdcall *GetDlgItemTextW)(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);
// extern BOOL (__stdcall *SetDlgItemTextW)(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
// extern int (__stdcall *wvsprintfW)(LPWSTR, LPCWSTR, va_list arglist);
// extern LRESULT (__stdcall *SendMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern BOOL (__stdcall *PeekMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern BOOL (__stdcall *GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern LRESULT (__stdcall *DispatchMessageW)(const MSG *lpMsg);
// extern int (__stdcall *LoadStringW)(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// extern BOOL (__stdcall *GetWindowRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *GetClientRect)(HWND hWnd, LPRECT lpRect);
// extern BOOL (__stdcall *SetWindowPos)(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// extern int (__stdcall *GetWindowTextW)(HWND hWnd, LPWSTR lpString, int nMaxCount);
// extern BOOL (__stdcall *SetWindowTextW)(HWND hWnd, LPCWSTR lpString);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern HWND (__stdcall *GetWindow)(HWND hWnd, UINT uCmd);
// extern LONG (__stdcall *GetWindowLongW)(HWND hWnd, int nIndex);
// extern DWORD (__stdcall *GetSysColor)(int nIndex);
// extern HRESULT (__stdcall *CLSIDFromString)(LPCOLESTR lpsz, LPCLSID pclsid);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// extern HRESULT (__stdcall *OleInitialize)(LPVOID pvReserved);
// extern void (__stdcall *OleUninitialize)();
// extern HRESULT (__stdcall *CreateStreamOnHGlobal)(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
int (__thiscall *off_42A448)(void *, char) = &sub_401416; // weak
int SHA256_Constants_42A478[] = { 1779033703 }; // weak
char byte_42A498[] = { '\0' }; // weak
char byte_42A499[] = { '\x01' }; // weak
char byte_42A49A[] = { '\x02' }; // weak
char byte_42A49B[] = { '\x03' }; // weak
char byte_42A49C[] = { '\x04' }; // weak
char byte_42A49D[] = { '\x05' }; // weak
char byte_42A49E[] = { '\x06' }; // weak
char byte_42A49F[] = { '\a' }; // weak
char byte_42A4A0[] = { '\b' }; // weak
char byte_42A4A1[] = { '\t' }; // weak
char byte_42A4A2[] = { '\n' }; // weak
char byte_42A4A3[] = { '\v' }; // weak
char byte_42A4A4[] = { '\f' }; // weak
char byte_42A4A5[] = { '\r' }; // weak
char byte_42A4A6[] = { '\x0E' }; // weak
char byte_42A4A7[145] =
{
  '\x0F',
  '\x0E',
  '\n',
  '\x04',
  '\b',
  '\t',
  '\x0F',
  '\r',
  '\x06',
  '\x01',
  '\f',
  '\0',
  '\x02',
  '\v',
  '\a',
  '\x05',
  '\x03',
  '\v',
  '\b',
  '\f',
  '\0',
  '\x05',
  '\x02',
  '\x0F',
  '\r',
  '\n',
  '\x0E',
  '\x03',
  '\x06',
  '\a',
  '\x01',
  '\t',
  '\x04',
  '\a',
  '\t',
  '\x03',
  '\x01',
  '\r',
  '\f',
  '\v',
  '\x0E',
  '\x02',
  '\x06',
  '\x05',
  '\n',
  '\x04',
  '\0',
  '\x0F',
  '\b',
  '\t',
  '\0',
  '\x05',
  '\a',
  '\x02',
  '\x04',
  '\n',
  '\x0F',
  '\x0E',
  '\x01',
  '\v',
  '\f',
  '\x06',
  '\b',
  '\x03',
  '\r',
  '\x02',
  '\f',
  '\x06',
  '\n',
  '\0',
  '\v',
  '\b',
  '\x03',
  '\x04',
  '\r',
  '\a',
  '\x05',
  '\x0F',
  '\x0E',
  '\x01',
  '\t',
  '\f',
  '\x05',
  '\x01',
  '\x0F',
  '\x0E',
  '\r',
  '\x04',
  '\n',
  '\0',
  '\a',
  '\x06',
  '\x03',
  '\t',
  '\x02',
  '\b',
  '\v',
  '\r',
  '\v',
  '\a',
  '\x0E',
  '\f',
  '\x01',
  '\x03',
  '\t',
  '\x05',
  '\0',
  '\x0F',
  '\x04',
  '\b',
  '\x06',
  '\x02',
  '\n',
  '\x06',
  '\x0F',
  '\x0E',
  '\t',
  '\v',
  '\x03',
  '\0',
  '\b',
  '\f',
  '\x02',
  '\r',
  '\a',
  '\x01',
  '\x04',
  '\n',
  '\x05',
  '\n',
  '\x02',
  '\b',
  '\x04',
  '\a',
  '\x06',
  '\x01',
  '\x05',
  '\x0F',
  '\v',
  '\t',
  '\x0E',
  '\x03',
  '\f',
  '\r',
  '\0'
}; // weak
const wchar_t Source[] = L"*"; // idb
const WCHAR String = 0u; // idb
int (__thiscall *off_42A614)(void *, char) = &sub_408BE0; // weak
const char aR[2] = "r!"; // idb
const WCHAR off_42A7E0 = 82u; // idb
const WCHAR TemplateName = 71u; // idb
const WCHAR off_42A888 = 82u; // idb
const wchar_t asc_42A8A8[] = L"X"; // idb
int dword_42AB90 = 1116352408; // weak
char byte_42AD9C[16] =
{
  '\x19',
  '\x0E',
  '\t',
  '\a',
  '\x05',
  '\x05',
  '\x04',
  '\x04',
  '\x04',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02'
}; // weak
_UNKNOWN unk_42ADAC; // weak
int (__stdcall *off_42ADBC)(int, int, int) = &sub_419365; // weak
void *off_42ADD8 = &loc_419397; // weak
void *off_42AE14 = &loc_41938D; // weak
int (__stdcall *off_42AE50)(int, void *Buf1, int) = &sub_418FA1; // weak
const WCHAR szClass = 69u; // idb
const IID stru_42B060 =
{
  3965634729u,
  50069u,
  17172u,
  { 156u, 119u, 84u, 215u, 169u, 53u, 255u, 112u }
}; // idb
const IID stru_42B0A8 = { 136441u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_42B0B8; // weak
_UNKNOWN unk_42B0C8; // weak
_UNKNOWN unk_42B0D8; // weak
_UNKNOWN unk_42B0E8; // weak
_UNKNOWN unk_42B0F8; // weak
_UNKNOWN unk_42B108; // weak
const IID Buf2 = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
_UNKNOWN unk_42B128; // weak
_UNKNOWN unk_42B138; // weak
_UNKNOWN unk_42B148; // weak
const IID rclsid = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } }; // idb
const IID stru_42B168 = { 3402297954u, 37744u, 17941u, { 161u, 59u, 159u, 85u, 57u, 218u, 76u, 10u } }; // idb
_UNKNOWN unk_42B178; // weak
int (__thiscall *off_42B18C)(void *, char) = &sub_411CC0; // weak
int (__thiscall *off_42B1B8)(void *, char) = &sub_41C249; // weak
void *std::exception::`vftable' = &sub_41D1A0; // weak
void *std::bad_exception::`vftable' = &sub_41D44E; // weak
_UNKNOWN unk_42CE4C; // weak
const _ThrowInfo _TI1_AW4RAR_EXIT__ = { 0u, NULL, NULL, &_CTA1_AW4RAR_EXIT__ }; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &sub_411CB5, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
_UNKNOWN unk_42F01C; // weak
int dword_42F068[] = { 53 }; // weak
int dword_42F06C[] = { -1386780537 }; // weak
int dword_42F070[4] = { 1, 57, 1020781950, 2 }; // weak
char byte_42F081[] = { '\0' }; // weak
char byte_42F09D[19] =
{
  ']',
  ',',
  '\x1C',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\xD8',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\xE7',
  '\x85',
  '\xBC',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_42F0B0[16] =
{
  '\x04',
  '\x04',
  '\x06',
  '\x06',
  '\0',
  '\0',
  '\a',
  '\a',
  '\x04',
  '\x04',
  '\0',
  '\0',
  '\x04',
  '\x04',
  '\0',
  '\0'
}; // weak
PCNZWCH off_42F0C0 = L"RarSFX"; // idb
NUMBERFMTW Format = { 0u, 0u, 3u, L".", NULL, 0u }; // idb
PCNZWCH lpString2 = L"Delete"; // idb
_UNKNOWN unk_42F130; // weak
char byte_42F180[16] =
{
  '\x02',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\0',
  '\x04',
  '\b',
  '\x10',
  ' ',
  '@',
  '',
  '\xC0'
}; // weak
char byte_42F190[] = { '\0' }; // weak
char byte_42F1AC[28] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\n',
  '\f',
  '\x0E',
  '\x10',
  '\x14',
  '\x18',
  '\x1C',
  ' ',
  '(',
  '0',
  '8',
  '@',
  'P',
  '`',
  'p',
  '',
  '\xA0',
  '\xC0',
  '\xE0'
}; // weak
size_t Size[27] =
{
  4u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  14u,
  0u,
  12u,
  4367924u,
  0u,
  0u,
  4367924u,
  0u,
  0u,
  0u,
  4367924u
}; // weak
void *off_42F540 = &unk_44F8C0; // weak
int dword_4301F8 = 1024; // weak
int dword_4301FC = -1023; // weak
int dword_430200 = 53; // weak
int dword_430204 = 11; // weak
int dword_430208 = 64; // weak
int dword_43020C = 1023; // weak
int dword_430210 = 128; // weak
int dword_430214 = -127; // weak
int dword_430218 = 24; // weak
int dword_43021C = 8; // weak
int dword_430220 = 32; // weak
int dword_430224 = 127; // weak
__int128 xmmword_430580 = 0i64; // weak
__int128 xmmword_430590 = 0i64; // weak
int dword_4305A0[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  }; // weak
int dword_4309A0[256]; // weak
int dword_430DA0[256]; // weak
int dword_4311A0[256]; // weak
int dword_4315A0[256]; // weak
int dword_4319A0[256]; // weak
int dword_431DA0[256]; // weak
int dword_4321A0[256]; // weak
int dword_4325A8; // weak
_UNKNOWN unk_4325B0; // weak
_UNKNOWN unk_4325C0; // weak
_UNKNOWN unk_4325D0; // weak
char byte_4326D2[]; // weak
_UNKNOWN unk_4326D3; // weak
char byte_432A60; // weak
char byte_432A61; // weak
char byte_432A62; // weak
HINSTANCE dword_432A64; // idb
HINSTANCE hInstance; // idb
int dword_432A6C; // weak
char byte_432A77; // weak
_UNKNOWN unk_432A7C; // weak
_UNKNOWN unk_432A90; // weak
int dword_434A90; // weak
char byte_434A98[]; // weak
char byte_434A99[]; // weak
char byte_434A9A[]; // weak
char byte_434A9B[1021]; // weak
char byte_434E98[]; // weak
char byte_434E99[]; // weak
char byte_434E9A[]; // weak
char byte_434E9B[1021]; // weak
char byte_435298[]; // weak
char byte_435299[]; // weak
char byte_43529A[]; // weak
char byte_43529B[1021]; // weak
char byte_435698[]; // weak
char byte_435699[]; // weak
char byte_43569A[]; // weak
char byte_43569B[1021]; // weak
int dword_435A98[]; // weak
int dword_435E98[]; // weak
int dword_436298[]; // weak
int dword_436698[]; // weak
_UNKNOWN unk_436A98; // weak
char byte_436A9A[]; // weak
char byte_436A9B[1021]; // weak
char byte_436E98[]; // weak
char byte_436E99[]; // weak
char byte_436E9A[]; // weak
char byte_436E9B[1021]; // weak
char byte_437298[]; // weak
char byte_437299[]; // weak
char byte_43729A[]; // weak
char byte_43729B[1021]; // weak
char byte_437698[]; // weak
char byte_437699[]; // weak
char byte_43769A[]; // weak
char byte_43769B[1021]; // weak
char byte_437A98[32]; // weak
char byte_437AB8[256]; // weak
char byte_437BB8[256]; // weak
HMODULE dword_437CB8[2]; // weak
int (__stdcall *dword_437CC0)(_DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_437CC4)(_DWORD, _DWORD, _DWORD); // weak
LPVOID lpParam; // idb
LPVOID dword_437CCC; // idb
wchar_t String1; // idb
LPARAM dword_438CD0; // idb
LPARAM lParam; // idb
wchar_t Filename[2048]; // weak
wchar_t Src[8192]; // weak
wchar_t pszPath[2048]; // weak
wchar_t word_43ECD8[2048]; // weak
wchar_t word_43FCD8[438]; // weak
int dword_440CD8; // weak
char byte_440CDC; // weak
char byte_440CDD; // weak
char byte_440CDE; // weak
char byte_440CDF; // weak
int qword_440CE0; // idb
char byte_440CE8; // weak
char byte_440CE9; // weak
char byte_440CEA; // weak
int dword_440CEC; // weak
int dword_440CF0; // weak
HWND hWnd; // idb
HWND hWndParent; // idb
char byte_440CFC; // weak
char byte_440CFD; // weak
char byte_440CFE; // weak
char byte_440CFF; // weak
void *dword_440D00; // idb
wchar_t *Destination; // idb
void *Block; // idb
int dword_440D0C; // weak
char byte_440D10; // weak
char byte_440D11; // weak
int dword_440D14; // weak
DWORD dwMilliseconds; // idb
HANDLE hHandle; // idb
char byte_440D28; // weak
int dword_440D2C; // weak
char byte_440D30; // weak
char byte_440D31; // weak
wchar_t word_440D32[2048]; // weak
wchar_t word_441D32[2048]; // weak
_BYTE byte_442D32[256]; // weak
char byte_442E32; // weak
_DWORD dword_442E38[5203]; // weak
char byte_447F87; // weak
char byte_447F88; // weak
char byte_447FC0; // weak
int dword_4490C4; // weak
int dword_4490C8; // weak
int dword_4490CC; // weak
wchar_t word_44A0EA; // idb
wchar_t word_44B10A; // idb
_DWORD dword_44C10C[115]; // weak
_BYTE byte_44C2D8[256]; // weak
char byte_44C3D8; // weak
__int16 word_44C3DC; // weak
__int16 word_44C3DE; // weak
int dword_44C3E0; // weak
int dword_44C3E4; // weak
LPWSTR lpString; // idb
int dword_44C3EC; // weak
wchar_t Buffer; // idb
_UNKNOWN unk_44E3F4; // weak
_UNKNOWN unk_44E3FC; // weak
_UNKNOWN unk_44E53C; // weak
_UNKNOWN unk_44E58C; // weak
_UNKNOWN unk_44E718; // weak
_UNKNOWN unk_44E71C; // weak
_UNKNOWN unk_44E8A8; // weak
_UNKNOWN unk_44E8AC; // weak
char byte_44EA30; // weak
_UNKNOWN unk_44EA34; // weak
int dword_44EA38; // weak
int dword_44EA3C; // weak
int dword_44EA40; // weak
void *dword_44EA44; // idb
int dword_44EA48; // weak
int nPriority; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
_BYTE byte_44EA70[264]; // weak
char byte_44EB78[64]; // weak
int dword_44EBB8[]; // weak
int dword_44EBBC; // weak
IMalloc *ppMalloc; // idb
_DWORD dword_44ECBC[3]; // weak
int dword_44EE5C; // weak
int dword_44EE64; // weak
int dword_44F63C; // weak
int dword_44F64C; // weak
int dword_44F658; // weak
int dword_44F664; // weak
int dword_44F6A8; // weak
int dword_44F6AC; // weak
int dword_44F6B0; // weak
int dword_44F6B4; // weak
int dword_44F6B8; // weak
int dword_44F78C; // weak
int dword_4508D8; // weak


//----- (00401000) --------------------------------------------------------
void __thiscall sub_401000(_BYTE *this)
{
  sub_4095C9((int)(this + 12136));
  sub_4095C9((int)(this + 9220));
  sub_4095C9((int)(this + 6304));
  sub_405DF7(this + 3148);
  sub_405DF7(this + 64);
}

//----- (00401069) --------------------------------------------------------
int __stdcall sub_401069(_BYTE *a1, unsigned int a2)
{
  int result; // eax
  char v3; // cl

  result = 0;
  if ( a2 && *a1 == 82 && a2 >= 7 && a1[1] == 97 && a1[2] == 114 && a1[3] == 33 && a1[4] == 26 && a1[5] == 7 )
  {
    v3 = a1[6];
    if ( !v3 )
      return 2;
    if ( v3 == 1 )
      return 3;
    if ( v3 != 2 )
      return result;
    return 4;
  }
  return result;
}

//----- (004010BF) --------------------------------------------------------
int __thiscall sub_4010BF(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*this + 12))(this, this[10378], this[10379], 0);
}

//----- (004010D3) --------------------------------------------------------
int __thiscall sub_4010D3(int this, int a2)
{
  int v3; // [esp+8h] [ebp+8h]

  if ( *(_BYTE *)(this + 41532) )
  {
    v3 = (-(char)a2 & 0xF) + a2;
    if ( *(_DWORD *)(this + 41520) == 3 )
      return v3 + 16;
    else
      return v3 + 8;
  }
  return a2;
}

//----- (00401105) --------------------------------------------------------
void __thiscall sub_401105(void **this)
{
  if ( *this )
    free(*this);
}

//----- (00401113) --------------------------------------------------------
void __thiscall sub_401113(int this, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  size_t v5; // ebx
  void *v6; // edi

  *(_DWORD *)(this + 4) += a2;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 > *(_DWORD *)(this + 8) )
  {
    v4 = *(_DWORD *)(this + 12);
    if ( v4 && v3 > v4 )
    {
      sub_40634C((int)&dword_432A6C, (wchar_t *)L"Maximum allowed array size (%u) is exceeded", v4);
      sub_4062F7(&dword_432A6C);
    }
    v5 = *(_DWORD *)(this + 4);
    if ( v5 <= (*(_DWORD *)(this + 8) >> 2) + *(_DWORD *)(this + 8) + 32 )
      v5 = (*(_DWORD *)(this + 8) >> 2) + *(_DWORD *)(this + 8) + 32;
    v6 = realloc(*(void **)this, v5);
    if ( !v6 )
      sub_4062F7(&dword_432A6C);
    *(_DWORD *)this = v6;
    *(_DWORD *)(this + 8) = v5;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00401188) --------------------------------------------------------
_QWORD *__thiscall sub_401188(_QWORD *this, int a2)
{
  *(_DWORD *)this = a2;
  this[1] = ((__int64 (__thiscall *)(int))*(_DWORD *)(*(_DWORD *)a2 + 16))(a2);
  return this;
}

//----- (004011B4) --------------------------------------------------------
void __thiscall sub_4011B4(int this, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // edi
  int v6; // ecx
  void *v7; // ebx

  *(_DWORD *)(this + 4) += a2;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 > *(_DWORD *)(this + 8) )
  {
    v4 = *(_DWORD *)(this + 12);
    if ( v4 && v3 > v4 )
    {
      sub_40634C((int)&dword_432A6C, (wchar_t *)L"Maximum allowed array size (%u) is exceeded", v4);
      sub_4062F7(&dword_432A6C);
    }
    v5 = *(_DWORD *)(this + 4);
    v6 = *(_DWORD *)(this + 8) >> 2;
    if ( v5 <= v6 + *(_DWORD *)(this + 8) + 32 )
      v5 = v6 + *(_DWORD *)(this + 8) + 32;
    v7 = realloc(*(void **)this, 2 * v5);
    if ( !v7 )
      sub_4062F7(&dword_432A6C);
    *(_DWORD *)(this + 8) = v5;
    *(_DWORD *)this = v7;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00401235) --------------------------------------------------------
bool __thiscall sub_401235(int this)
{
  void *v2; // edi

  *(_DWORD *)this = &off_42A448;
  if ( *(_BYTE *)(this + 22272) )
  {
    v2 = *(void **)(this + 22276);
    if ( v2 )
    {
      sub_409CFD(*(void ***)(this + 22276));
      operator delete(v2);
    }
  }
  sub_401105((void **)(this + 35624));
  sub_401105((void **)(this + 26600));
  sub_401000((_BYTE *)(this + 7216));
  sub_405DF7((_BYTE *)(this + 4132));
  return sub_4089F9(this);
}
// 42A448: using guessed type int (__thiscall *off_42A448)(void *, char);

//----- (004012C2) --------------------------------------------------------
int __thiscall sub_4012C2(_DWORD *this, char a2)
{
  int result; // eax

  sub_401113((int)this, 1);
  result = this[1];
  *(_BYTE *)(result + *this - 1) = a2;
  return result;
}

//----- (004012DD) --------------------------------------------------------
void __stdcall sub_4012DD(int a1, int a2)
{
  int v2[19]; // [esp+0h] [ebp-4Ch] BYREF

  v2[17] = 0;
  v2[18] = a1;
  v2[0] = a2;
  v2[16] = 1;
  sub_411280(v2);
}

//----- (00401306) --------------------------------------------------------
_DWORD *__thiscall sub_401306(_DWORD *this, int a2)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  sub_401113((int)this, a2);
  return this;
}

//----- (00401325) --------------------------------------------------------
void __thiscall sub_401325(_DWORD *this, unsigned int a2)
{
  if ( a2 <= this[2] )
    this[1] = a2;
  else
    sub_4011B4((int)this, a2 - this[1]);
}

//----- (0040133F) --------------------------------------------------------
char __thiscall sub_40133F(int this, LPWSTR *a2)
{
  unsigned int v4; // edi
  unsigned int v5; // edi
  unsigned int v6; // eax
  void *Block; // [esp+8h] [ebp-1Ch] BYREF
  unsigned int v8; // [esp+Ch] [ebp-18h]
  int v9; // [esp+10h] [ebp-14h]
  int v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+20h] [ebp-4h]

  Block = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_402C37(this, (int *)&Block, 0) )
  {
    v4 = v8;
    sub_4012C2(&Block, 0);
    sub_401325(a2, v4 + 1);
    if ( *(_DWORD *)(this + 41520) == 3 )
    {
      sub_411817(Block, *a2, (int)a2[1]);
    }
    else if ( (*(_BYTE *)(this + 31524) & 1) != 0 )
    {
      v5 = v4 >> 1;
      sub_4116ED((unsigned __int8 *)Block, (int)*a2, v5);
      (*a2)[v5] = 0;
    }
    else
    {
      sub_411682((LPCCH)Block, *a2, (int)a2[1]);
    }
    v6 = wcslen(*a2);
    sub_401325(a2, v6);
    if ( Block )
      free(Block);
    return 1;
  }
  else
  {
    if ( Block )
      free(Block);
    return 0;
  }
}

//----- (00401416) --------------------------------------------------------
void *__thiscall sub_401416(void *this, char a2)
{
  sub_401235((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00401432) --------------------------------------------------------
_DWORD *__thiscall sub_401432(_DWORD *this)
{
  _DWORD *result; // eax
  _DWORD *v2; // ecx

  result = this;
  v2 = this + 1032;
  *v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  v2[3] = 0;
  result[1036] = 0;
  result[1037] = 0;
  result[1038] = 0;
  result[1039] = 0;
  result[1040] = 0;
  result[1041] = 0;
  return result;
}

//----- (0040146C) --------------------------------------------------------
char __thiscall sub_40146C(_DWORD *this, char a2)
{
  int v3; // eax
  _BYTE *v4; // edi
  int v6; // eax
  int v7; // edi
  __int64 v8; // rax
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // edi
  int v20; // eax
  int v21; // eax
  bool v22; // al
  bool v23; // al
  int v24; // ecx
  int v25; // eax
  int v26; // [esp-Ch] [ebp-4Ch]
  int v27; // [esp-8h] [ebp-48h]
  __int64 v28; // [esp+Ch] [ebp-34h] BYREF
  int v29; // [esp+14h] [ebp-2Ch]
  int v30; // [esp+18h] [ebp-28h]
  void *Block[3]; // [esp+1Ch] [ebp-24h] BYREF
  int v32; // [esp+28h] [ebp-18h]
  int v33; // [esp+2Ch] [ebp-14h]
  int v34; // [esp+30h] [ebp-10h]
  int v35; // [esp+3Ch] [ebp-4h]

  v3 = *this;
  v4 = this + 5584;
  *((_BYTE *)this + 41532) = 0;
  *((_BYTE *)this + 41540) = 0;
  if ( (*(int (__stdcall **)(_DWORD *, int))(v3 + 8))(this + 5584, 7) != 7 )
    return 0;
  this[10384] = 0;
  v6 = sub_401069(v4, 7u);
  if ( v6 )
  {
    this[10380] = v6;
    if ( v6 == 1 )
    {
      v7 = *this;
      v8 = ((__int64 (__thiscall *)(_DWORD *, _DWORD))*(_DWORD *)(*this + 16))(this, 0);
      (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD))(v7 + 12))(this, v8 - 7, (unsigned __int64)(v8 - 7) >> 32);
    }
  }
  else
  {
    sub_401306(Block, 0x100000);
    v9 = *this;
    v35 = 0;
    v10 = (*(int (__thiscall **)(_DWORD *))(v9 + 16))(this);
    v11 = (*(int (__thiscall **)(_DWORD *, void *, char *))(*this + 8))(this, Block[0], (char *)Block[1] - 16);
    v12 = 0;
    v34 = v11;
    if ( v11 > 0 )
    {
      while ( 1 )
      {
        if ( *((_BYTE *)Block[0] + v12) == 82 )
        {
          v13 = sub_401069((_BYTE *)Block[0] + v12, v34 - v12);
          if ( v13 )
          {
            this[10380] = v13;
            if ( v13 != 1
              || v12 <= 0
              || v10 >= 28
              || v34 <= 31
              || ((_BYTE *)Block[0] - v10)[28] == 82
              && ((_BYTE *)Block[0] - v10)[29] == 83
              && ((_BYTE *)Block[0] - v10)[30] == 70
              && ((_BYTE *)Block[0] - v10)[31] == 88 )
            {
              break;
            }
          }
        }
        if ( ++v12 >= v34 )
          goto LABEL_22;
      }
      v14 = v12 + v10;
      v15 = *this;
      this[10384] = v14;
      (*(void (__thiscall **)(_DWORD *, int, _DWORD, _DWORD))(v15 + 12))(this, v14, 0, 0);
      v16 = this[10380];
      if ( v16 == 2 || v16 == 3 )
        (*(void (__thiscall **)(_DWORD *, _DWORD *, int))(*this + 8))(this, this + 5584, 7);
    }
LABEL_22:
    if ( !this[10384] )
    {
      if ( Block[0] )
        free(Block[0]);
      return 0;
    }
    v35 = -1;
    if ( Block[0] )
      free(Block[0]);
  }
  v17 = this[10380];
  if ( v17 == 4 )
  {
    sub_4012DD(59, (int)this + 30);
    return 0;
  }
  if ( v17 == 3 )
  {
    (*(void (__thiscall **)(_DWORD *, int, int))(*this + 8))(this, (int)this + 22343, 1);
    if ( *((_BYTE *)this + 22343) )
      return 0;
    this[5586] = 8;
  }
  else
  {
    this[5586] = 7;
  }
  while ( sub_40363F(this) )
  {
    v18 = this[5577];
    if ( v18 == 1 || *((_BYTE *)this + 22312) && v18 == 4 )
      break;
    sub_4010BF(this);
  }
  if ( *((_BYTE *)this + 41541) && !a2 )
    return 0;
  sub_4010BF(this);
  if ( *((_BYTE *)this + 41540) )
  {
    sub_4012DD(25, (int)this + 30);
    if ( !a2 )
      return 0;
  }
  *((_BYTE *)this + 41526) = *((_BYTE *)this + 22380);
  if ( !*((_BYTE *)this + 22312) || !*((_BYTE *)this + 41532) )
  {
    sub_401188(&v28, (int)this);
    v19 = this[10376];
    v32 = this[10377];
    v33 = this[10378];
    v20 = this[10379];
    v35 = 1;
    v34 = v20;
    while ( sub_40363F(this) )
    {
      v21 = this[5577];
      if ( v21 == 3 )
      {
        v22 = *((_BYTE *)this + 41525) && !*((_BYTE *)this + 35728);
        *((_BYTE *)this + 41529) = v22;
      }
      else if ( v21 == 2 )
      {
        v23 = *((_BYTE *)this + 41525) && !*((_BYTE *)this + 26704);
        *((_BYTE *)this + 41529) = v23;
        break;
      }
      sub_4010BF(this);
    }
    v24 = v28;
    v35 = -1;
    this[10377] = v32;
    v27 = v30;
    this[10378] = v33;
    v25 = v34;
    v26 = v29;
    this[10376] = v19;
    this[10379] = v25;
    (*(void (__thiscall **)(int, int, int, _DWORD))(*(_DWORD *)v24 + 12))(v24, v26, v27, 0);
  }
  if ( !*((_BYTE *)this + 41525) || *((_BYTE *)this + 41529) )
    wcscpy((wchar_t *)this + 20797, (const wchar_t *)this + 15);
  return 1;
}
// 401542: variable 'v12' is possibly undefined
// 40363F: using guessed type int __thiscall sub_40363F(_DWORD);

//----- (004017A4) --------------------------------------------------------
bool __thiscall sub_4017A4(int this, int a2)
{
  int v4; // edi
  unsigned __int64 v5; // rax
  char v6; // al
  int v7; // eax
  __int64 v8; // [esp+8h] [ebp-1Ch] BYREF
  int v9; // [esp+10h] [ebp-14h]
  int v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+20h] [ebp-4h]
  bool v12; // [esp+2Fh] [ebp+Bh]

  if ( !*(_BYTE *)(this + 41526) )
    return 0;
  sub_401188(&v8, this);
  v11 = 0;
  if ( *(_BYTE *)(this + 22380) )
  {
    (*(void (__thiscall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)this + 12))(
      this,
      *(_DWORD *)(this + 41536) + 20,
      0,
      0);
    sub_40363F(this);
    v12 = *(_DWORD *)(a2 + 4) != 0;
  }
  else
  {
    v4 = *(_DWORD *)this;
    v5 = sub_401B47((_DWORD *)this);
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD))(v4 + 12))(this, v5, HIDWORD(v5), 0);
    if ( !sub_403707((wchar_t *)this, (wchar_t *)L"CMT") || (v6 = sub_40133F(this, (LPWSTR *)a2), v12 = 1, !v6) )
      v12 = 0;
  }
  v7 = *(_DWORD *)v8;
  v11 = -1;
  (*(void (__thiscall **)(_DWORD, int, int, _DWORD))(v7 + 12))(v8, v9, v10, 0);
  return v12;
}
// 40363F: using guessed type int __thiscall sub_40363F(_DWORD);

//----- (0040185E) --------------------------------------------------------
int __thiscall sub_40185E(int this, _BYTE *a2)
{
  void *v3; // ecx
  _BYTE *v4; // eax
  char v5; // al

  sub_408533((_DWORD *)this);
  *(_DWORD *)this = &off_42A448;
  sub_405ED9(this + 4132);
  sub_40B5A4((_DWORD *)(this + 7216));
  *(_DWORD *)(this + 22296) = 0;
  *(_DWORD *)(this + 22300) = 0;
  sub_401432((_DWORD *)(this + 22472));
  sub_401432((_DWORD *)(this + 31496));
  *(_DWORD *)(this + 22276) = 0;
  *(_BYTE *)(this + 22272) = a2 == 0;
  if ( a2 )
  {
    v4 = a2;
  }
  else
  {
    v3 = operator new(0x72A8u);
    if ( v3 )
      v4 = (_BYTE *)sub_409D27((int)v3);
    else
      v4 = 0;
  }
  *(_DWORD *)(this + 22276) = v4;
  v5 = v4[20885];
  *(_DWORD *)(this + 22280) = -1;
  *(_DWORD *)(this + 22284) = -1;
  *(_DWORD *)(this + 22288) = -1;
  *(_BYTE *)(this + 28) = v5;
  *(_DWORD *)(this + 41520) = 2;
  *(_BYTE *)(this + 41524) = 0;
  *(_BYTE *)(this + 41525) = 0;
  *(_BYTE *)(this + 41526) = 0;
  *(_BYTE *)(this + 41527) = 0;
  *(_BYTE *)(this + 41528) = 0;
  *(_BYTE *)(this + 41529) = 0;
  *(_BYTE *)(this + 41530) = 0;
  *(_DWORD *)(this + 41536) = 0;
  *(_DWORD *)(this + 22296) = 0;
  *(_DWORD *)(this + 22300) = 0;
  *(_BYTE *)(this + 41531) = 0;
  *(_BYTE *)(this + 41532) = 0;
  *(_BYTE *)(this + 41541) = 0;
  *(_BYTE *)(this + 41540) = 0;
  *(_DWORD *)(this + 22304) = 0;
  *(_DWORD *)(this + 41504) = 0;
  *(_DWORD *)(this + 41508) = 0;
  *(_DWORD *)(this + 41512) = 0;
  *(_DWORD *)(this + 41516) = 0;
  memset((void *)(this + 22352), 0, 0x40u);
  memset((void *)(this + 22416), 0, 0x34u);
  memset((void *)(this + 31432), 0, 0x20u);
  *(_WORD *)(this + 41594) = 0;
  *(_DWORD *)(this + 41560) = 0;
  *(_DWORD *)(this + 41568) = 0;
  *(_DWORD *)(this + 41572) = 0;
  *(_DWORD *)(this + 41576) = 0;
  *(_DWORD *)(this + 41580) = 0;
  *(_DWORD *)(this + 41584) = 0;
  *(_DWORD *)(this + 41588) = 0;
  *(_BYTE *)(this + 41558) = 0;
  *(_BYTE *)(this + 41592) = 0;
  *(_BYTE *)(this + 22312) = 0;
  return this;
}
// 42A448: using guessed type int (__thiscall *off_42A448)(void *, char);

//----- (00401A23) --------------------------------------------------------
char __thiscall sub_401A23(int this, char a2)
{
  char result; // al

  result = sub_40146C((_DWORD *)this, a2);
  if ( !result )
  {
    if ( !*(_BYTE *)(this + 41541) )
      sub_4012DD(56, this + 30);
    return sub_4062C3(2);
  }
  return result;
}

//----- (00401A56) --------------------------------------------------------
char __thiscall sub_401A56(_DWORD *this, int a2)
{
  if ( !sub_4086AB(this, a2) )
    return 0;
  if ( !sub_40146C(this, 0) )
  {
    sub_4012DD(56, (int)this + 30);
    sub_4087BE((int)this);
    return 0;
  }
  return 1;
}

//----- (00401A91) --------------------------------------------------------
char __thiscall sub_401A91(_BYTE *this)
{
  return this[26793];
}

//----- (00401A98) --------------------------------------------------------
int __thiscall sub_401A98(int this)
{
  int result; // eax

  if ( *(_DWORD *)(this + 26804) )
  {
    result = *(_BYTE *)(this + 26793) == 0 ? 32 : 16;
    *(_DWORD *)(this + 22500) = result;
  }
  return result;
}

//----- (00401ABA) --------------------------------------------------------
_WORD *__thiscall sub_401ABA(_DWORD *this, int a2)
{
  _WORD *result; // eax

  if ( this[10380] == 2 && *(_BYTE *)(a2 + 25) < 0x14u && (*(_BYTE *)(a2 + 28) & 0x10) != 0 )
    *(_BYTE *)(a2 + 4321) = 1;
  if ( *(_DWORD *)(a2 + 4332) == 2 )
    *(_DWORD *)(a2 + 28) = *(_BYTE *)(a2 + 4321) == 0 ? 32 : 16;
  for ( result = (_WORD *)(a2 + 32); *result; ++result )
  {
    if ( *result == 92 && this[10380] == 3 )
      *result = 95;
    if ( *result == 58 )
      *result = 95;
    if ( *result == 47 || *result == 92 && this[10380] != 3 )
      *result = 92;
  }
  return result;
}

//----- (00401B47) --------------------------------------------------------
unsigned __int64 __thiscall sub_401B47(_DWORD *this)
{
  int v1; // edi
  int v2; // eax

  v1 = this[10384] + this[5586];
  if ( this[10380] == 2 )
    v2 = this[5591];
  else
    v2 = this[5607] + sub_4010D3((int)this, this[5591]);
  return (unsigned int)v2 + (unsigned __int64)(unsigned int)v1;
}

//----- (00401B88) --------------------------------------------------------
BOOL __thiscall sub_401B88(const wchar_t *this, wchar_t *String2)
{
  return wcscmp(this + 16, String2) == 0;
}

//----- (00401B9F) --------------------------------------------------------
void __stdcall sub_401B9F(int a1)
{
  int v1[19]; // [esp+0h] [ebp-4Ch] BYREF

  v1[16] = 0;
  v1[17] = 0;
  v1[18] = a1;
  sub_411280(v1);
}

//----- (00401BBF) --------------------------------------------------------
char __thiscall sub_401BBF(int this)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 22276);
  if ( !*(_BYTE *)(v2 + 16672) )
  {
    LOBYTE(v2) = sub_4114D8(2, (wchar_t *)(this + 30), (_BYTE *)(v2 + 16416));
    if ( !(_BYTE)v2 )
    {
      sub_4087BE(this);
      sub_401B9F(2);
      LOBYTE(v2) = sub_4062C3(255);
    }
  }
  return v2;
}

//----- (00401C05) --------------------------------------------------------
void __thiscall sub_401C05(_DWORD *this, unsigned int a2)
{
  if ( a2 <= this[2] )
    this[1] = a2;
  else
    sub_401113((int)this, a2 - this[1]);
}

//----- (00401C1F) --------------------------------------------------------
int __thiscall sub_401C1F(int this)
{
  __int64 v2; // rax

  v2 = sub_408B84((int *)this);
  if ( *(_QWORD *)(this + 41504) != v2
    || *(_DWORD *)(this + 41512) != (_DWORD)v2
    || (LODWORD(v2) = *(_DWORD *)(this + 41516), (_DWORD)v2 != HIDWORD(v2)) )
  {
    sub_4012DD(55, this + 30);
    LODWORD(v2) = sub_406222(&dword_432A6C, 1);
  }
  return v2;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00401C68) --------------------------------------------------------
int __thiscall sub_401C68(_BYTE *this)
{
  sub_4012DD(24, (int)(this + 30));
  this[41540] = 1;
  return sub_406222(&dword_432A6C, 3);
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00401C8B) --------------------------------------------------------
int __thiscall sub_401C8B(void *this, int a2)
{
  sub_4062C8(32, (int)this + 30, a2);
  return sub_406222(&dword_432A6C, 1);
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00401CA9) --------------------------------------------------------
int __thiscall sub_401CA9(int this)
{
  bool v2; // zf
  int v4; // esi
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  int v7; // esi
  int v8; // esi
  int v9; // esi
  int v10; // ecx
  __int64 v11; // kr00_8
  int v12; // eax
  int v13; // edi
  unsigned __int16 v14; // ax
  int v15; // eax
  void *v16; // edi
  unsigned int v17; // esi
  int v18; // eax
  bool v19; // cl
  int v20; // esi
  bool v21; // cl
  int v22; // edx
  int v23; // eax
  unsigned __int8 v24; // dl
  int v25; // edi
  bool v26; // al
  char v27; // al
  wchar_t *v28; // eax
  bool v29; // al
  unsigned int v30; // edi
  size_t v31; // eax
  signed int v32; // edi
  unsigned __int8 *v33; // eax
  int v34; // ecx
  int v35; // edx
  int v36; // ecx
  int v37; // edx
  int v38; // eax
  int v39; // eax
  __int64 v40; // rax
  int v41; // eax
  int v42; // edi
  unsigned __int16 v43; // ax
  DWORD *v44; // edi
  int v45; // eax
  unsigned int v46; // edi
  int v47; // eax
  int v48; // eax
  bool v49; // cf
  int v50; // eax
  int v51; // ecx
  char v52; // al
  int v53; // eax
  int v54; // eax
  __int64 v55; // rax
  int v56; // esi
  int v57; // eax
  int v58; // esi
  __int64 v59; // [esp-10h] [ebp-289Ch]
  unsigned __int64 v60; // [esp-10h] [ebp-289Ch]
  __int64 v61; // [esp-8h] [ebp-2894h]
  CHAR Str[8192]; // [esp+Ch] [ebp-2880h] BYREF
  CHAR szDst[2048]; // [esp+200Ch] [ebp-880h] BYREF
  int v64[5]; // [esp+280Ch] [ebp-80h] BYREF
  int v65; // [esp+2820h] [ebp-6Ch]
  int v66; // [esp+2824h] [ebp-68h]
  char v67[4]; // [esp+2830h] [ebp-5Ch] BYREF
  __int64 v68; // [esp+2834h] [ebp-58h] BYREF
  int v69; // [esp+283Ch] [ebp-50h]
  int v70; // [esp+2840h] [ebp-4Ch]
  void *Block[5]; // [esp+2844h] [ebp-48h] BYREF
  int v72; // [esp+2858h] [ebp-34h]
  int v73; // [esp+2860h] [ebp-2Ch]
  __int64 Buf2; // [esp+2864h] [ebp-28h] BYREF
  int v75; // [esp+286Ch] [ebp-20h]
  int v76; // [esp+2870h] [ebp-1Ch]
  wchar_t *String1; // [esp+2874h] [ebp-18h]
  unsigned int v78; // [esp+2878h] [ebp-14h]
  char v79; // [esp+287Eh] [ebp-Eh]
  bool v80; // [esp+287Fh] [ebp-Dh]
  int v81; // [esp+2888h] [ebp-4h]

  sub_40B3F7(Block, this);
  v2 = *(_BYTE *)(this + 41532) == 0;
  v81 = 0;
  if ( v2 || *(_QWORD *)(this + 41504) <= *(unsigned int *)(this + 41536) + 7i64 )
  {
    v79 = 0;
  }
  else
  {
    v79 = 1;
    sub_401BBF(this);
    if ( (*(int (__thiscall **)(int, __int64 *, int))(*(_DWORD *)this + 8))(this, &Buf2, 8) != 8 )
    {
LABEL_4:
      sub_401C1F(this);
LABEL_5:
      if ( Block[0] )
        free(Block[0]);
      return 0;
    }
    sub_405F4F(this + 4132, 0, 4, (_BYTE *)(*(_DWORD *)(this + 22276) + 16416), &Buf2, 0, 0, 0, 0);
    v73 = this + 4132;
  }
  sub_40B189(Block, 7u);
  if ( !v72 )
    goto LABEL_4;
  *(_DWORD *)(this + 22316) = (unsigned __int16)sub_40B23B(Block);
  *(_BYTE *)(this + 22332) = 0;
  v4 = (unsigned __int8)sub_40B223(Block);
  v5 = sub_40B23B(Block);
  *(_DWORD *)(this + 22324) = v5;
  *(_BYTE *)(this + 22332) = (v5 & 0x4000) != 0;
  v6 = sub_40B23B(Block);
  *(_DWORD *)(this + 22328) = v6;
  *(_DWORD *)(this + 22320) = v4;
  if ( v6 < 7u )
  {
LABEL_12:
    sub_401C68((_BYTE *)this);
    goto LABEL_5;
  }
  v7 = v4 - 115;
  if ( v7 )
  {
    v8 = v7 - 1;
    if ( v8 )
    {
      v9 = v8 - 6;
      if ( v9 )
      {
        if ( v9 == 1 )
          *(_DWORD *)(this + 22320) = 5;
      }
      else
      {
        *(_DWORD *)(this + 22320) = 3;
      }
    }
    else
    {
      *(_DWORD *)(this + 22320) = 2;
    }
  }
  else
  {
    *(_DWORD *)(this + 22320) = 1;
  }
  v10 = *(_DWORD *)(this + 22320);
  *(_DWORD *)(this + 22308) = v10;
  if ( v10 == 117 || v10 == 1 && (*(_BYTE *)(this + 22324) & 2) != 0 )
    sub_40B189(Block, 6u);
  else
    sub_40B189(Block, v6 - 7);
  v11 = *(_QWORD *)(this + 41504) + (unsigned int)sub_4010D3(this, *(_DWORD *)(this + 22328));
  *(_DWORD *)(this + 41512) = v11;
  v12 = *(_DWORD *)(this + 22320);
  *(_DWORD *)(this + 41516) = HIDWORD(v11);
  if ( v12 == 1 )
  {
    sub_409886(this + 22352);
    qmemcpy((void *)(this + 22352), (const void *)(this + 22316), 0x14u);
    *(_WORD *)(this + 22372) = sub_40B23B(Block);
    v50 = sub_40B270(Block);
    v51 = *(_DWORD *)(this + 22360);
    *(_BYTE *)(this + 41525) = *(_BYTE *)(this + 22360) & 1;
    *(_BYTE *)(this + 41524) = (v51 & 8) != 0;
    *(_BYTE *)(this + 41527) = (v51 & 4) != 0;
    *(_BYTE *)(this + 41531) = (v51 & 0x40) != 0;
    *(_DWORD *)(this + 22376) = v50;
    *(_BYTE *)(this + 41532) = (v51 & 0x80) != 0;
    if ( v50 || (v52 = 0, *(_WORD *)(this + 22372)) )
      v52 = 1;
    *(_BYTE *)(this + 41528) = v52;
    *(_BYTE *)(this + 22380) = (v51 & 2) != 0;
    *(_BYTE *)(this + 41529) = BYTE1(v51) & 1;
    *(_BYTE *)(this + 41530) = (v51 & 0x10) != 0;
  }
  else
  {
    if ( v12 <= 1 )
    {
LABEL_109:
      if ( (*(_DWORD *)(this + 22324) & 0x8000) != 0 )
        *(_QWORD *)(this + 41512) += (unsigned int)sub_40B270(Block);
      goto LABEL_115;
    }
    if ( v12 > 3 )
    {
      if ( v12 == 5 )
      {
        qmemcpy((void *)(this + 31432), (const void *)(this + 22316), 0x14u);
        v13 = *(_DWORD *)(this + 31440);
        *(_BYTE *)(this + 31460) = *(_BYTE *)(this + 31440) & 1;
        *(_BYTE *)(this + 31462) = (v13 & 4) != 0;
        *(_BYTE *)(this + 31461) = (v13 & 2) != 0;
        *(_BYTE *)(this + 31463) = (v13 & 8) != 0;
        if ( (v13 & 2) != 0 )
          *(_DWORD *)(this + 31452) = sub_40B270(Block);
        if ( *(_BYTE *)(this + 31463) )
        {
          v14 = sub_40B23B(Block);
          *(_DWORD *)(this + 31456) = v14;
          *(_DWORD *)(this + 41560) = v14;
        }
        goto LABEL_115;
      }
      goto LABEL_109;
    }
    v80 = v12 == 2;
    v2 = v12 != 2;
    v15 = this + 22472;
    if ( v2 )
      v15 = this + 31496;
    v16 = (void *)v15;
    v78 = v15;
    sub_4098B1(v15, 0);
    qmemcpy(v16, (const void *)(this + 22316), 0x14u);
    v17 = v78;
    *(_BYTE *)(v78 + 4232) = *(_BYTE *)(v78 + 8) & 1;
    v18 = *(_DWORD *)(v17 + 8);
    *(_BYTE *)(v17 + 4233) = (v18 & 2) != 0;
    *(_BYTE *)(v17 + 4235) = (v18 & 4) != 0;
    v2 = !v80;
    *(_BYTE *)(v17 + 4240) = (v18 & 0x400) != 0;
    v19 = !v2 && (v18 & 0x10) != 0;
    v2 = !v80;
    v20 = v78;
    *(_BYTE *)(v78 + 4320) = v19;
    v21 = v2 && (v18 & 0x10) != 0;
    *(_BYTE *)(v20 + 4330) = v21;
    *(_BYTE *)(v20 + 4321) = (v18 & 0xE0) == 0xE0;
    if ( (v18 & 0xE0) == 0xE0 )
      v22 = 0;
    else
      v22 = 0x10000 << ((unsigned __int8)v18 >> 5);
    *(_BYTE *)(v20 + 4322) = (v18 & 8) != 0;
    *(_DWORD *)(v20 + 4324) = v22;
    *(_BYTE *)(v20 + 4323) = (v18 & 0x800) != 0;
    *(_DWORD *)(v20 + 20) = sub_40B270(Block);
    v76 = sub_40B270(Block);
    *(_BYTE *)(v20 + 24) = sub_40B223(Block);
    *(_DWORD *)(v20 + 4192) = 2;
    *(_DWORD *)(v20 + 4196) = sub_40B270(Block);
    v75 = sub_40B270(Block);
    *(_BYTE *)(v20 + 25) = sub_40B223(Block);
    *(_BYTE *)(v20 + 26) = sub_40B223(Block) - 48;
    v78 = (unsigned __int16)sub_40B23B(Block);
    v23 = sub_40B270(Block);
    *(_DWORD *)(v20 + 4236) = 0;
    v2 = *(_BYTE *)(v20 + 4235) == 0;
    *(_DWORD *)(v20 + 28) = v23;
    if ( !v2 )
    {
      switch ( *(_BYTE *)(v20 + 25) )
      {
        case 0xD:
          *(_DWORD *)(v20 + 4236) = 1;
          break;
        case 0xF:
          *(_DWORD *)(v20 + 4236) = 2;
          break;
        case 0x14:
        case 0x1A:
          *(_DWORD *)(v20 + 4236) = 3;
          break;
        default:
          *(_DWORD *)(v20 + 4236) = 4;
          break;
      }
    }
    v24 = *(_BYTE *)(v20 + 24);
    *(_DWORD *)(v20 + 4332) = 2;
    if ( v24 == 3 || v24 == 5 )
    {
      *(_DWORD *)(v20 + 4332) = 1;
    }
    else if ( v24 < 6u )
    {
      *(_DWORD *)(v20 + 4332) = 0;
    }
    v25 = 0;
    *(_DWORD *)(v20 + 4336) = 0;
    if ( v24 == 3 && (v23 & 0xF000) == 40960 )
    {
      *(_DWORD *)(v20 + 4336) = 1;
      *(_WORD *)(v20 + 4340) = 0;
    }
    v26 = !v80 && v23 < 0;
    *(_BYTE *)(v20 + 4328) = v26;
    v27 = BYTE1(*(_DWORD *)(v20 + 8)) & 1;
    *(_BYTE *)(v20 + 4329) = v27;
    if ( v27 )
    {
      v25 = sub_40B270(Block);
      v28 = (wchar_t *)sub_40B270(Block);
      String1 = v28;
      v29 = v76 == -1 && v28 == (wchar_t *)-1;
    }
    else
    {
      String1 = 0;
      v29 = v76 == -1;
    }
    *(_BYTE *)(v20 + 4234) = v29;
    v59 = (unsigned int)String1;
    *(_QWORD *)(v20 + 4168) = *(unsigned int *)(v20 + 20) + ((unsigned __int64)(unsigned int)v25 << 32);
    *(_QWORD *)(v20 + 4176) = (unsigned int)v76 + (v59 << 32);
    if ( *(_BYTE *)(v20 + 4234) )
    {
      *(_DWORD *)(v20 + 4176) = 0x7FFFFFFF;
      *(_DWORD *)(v20 + 4180) = 0x7FFFFFFF;
    }
    v30 = 0x1FFF;
    if ( v78 < 0x1FFF )
      v30 = v78;
    sub_40B357(Block, Str, v30);
    v2 = !v80;
    Str[v30] = 0;
    if ( v2 )
    {
      String1 = (wchar_t *)(v20 + 32);
      sub_411682(Str, (LPWSTR)(v20 + 32), 2048);
      v32 = *(_DWORD *)(v20 + 12) - v78 - 32;
      if ( (*(_DWORD *)(v20 + 8) & 0x400) != 0 )
        v32 = *(_DWORD *)(v20 + 12) - v78 - 40;
      if ( v32 > 0 )
      {
        sub_401C05((_DWORD *)(v20 + 4128), v32);
        sub_40B357(Block, *(char **)(v20 + 4128), v32);
        if ( !wcscmp(String1, L"RR") )
        {
          v33 = *(unsigned __int8 **)(v20 + 4128);
          v34 = v33[11];
          v35 = v33[10];
          v33 += 8;
          v36 = v35 + (v34 << 8);
          v37 = v33[1];
          v38 = *v33;
          *(_DWORD *)(this + 22284) = 0;
          HIDWORD(v60) = *(_DWORD *)(this + 22284);
          LODWORD(v60) = v38 + ((v37 + (v36 << 8)) << 8);
          *(_DWORD *)(this + 22280) = (_DWORD)v60 << 9;
          v39 = *(_DWORD *)this;
          *(_DWORD *)(this + 22284) = v60 >> 23;
          v40 = ((__int64 (__thiscall *)(int))*(_DWORD *)(v39 + 16))(this);
          HIDWORD(v60) = *(_DWORD *)(this + 22284);
          Buf2 = v40;
          LODWORD(v60) = *(_DWORD *)(this + 22280);
          v41 = sub_4106FA(v60, v40);
          HIDWORD(v61) = HIDWORD(Buf2);
          *(_DWORD *)(this + 22288) = v41;
          LODWORD(v61) = Buf2;
          v42 = v41;
          if ( sub_4106FA(*(_QWORD *)(this + 22280) + Buf2 / 200, v61) > v41 )
            *(_DWORD *)(this + 22288) = v42 + 1;
        }
      }
      if ( !wcscmp(String1, L"CMT") )
        *(_BYTE *)(this + 41526) = 1;
    }
    else
    {
      if ( (*(_DWORD *)(v20 + 8) & 0x200) != 0 )
      {
        sub_406096((int)v67);
        v31 = strlen(Str);
        String1 = (wchar_t *)(v20 + 32);
        sub_4060A7(v67, (int)Str, (unsigned __int8 *)&Str[v31 + 1], v78 - (v31 + 1), v20 + 32, 0x800u);
      }
      else
      {
        String1 = (wchar_t *)(v20 + 32);
        *(_WORD *)(v20 + 32) = 0;
      }
      sub_410725(Str, szDst, 0x800u);
      sub_40A078(szDst, String1, String1, 0x800u);
      sub_401ABA((_DWORD *)this, v20);
    }
    if ( (*(_DWORD *)(v20 + 8) & 0x400) != 0 )
      sub_40B357(Block, (char *)(v20 + 4241), 8u);
    sub_4111C2((_DWORD *)(v20 + 4144), v75);
    if ( (*(_DWORD *)(v20 + 8) & 0x1000) != 0 )
    {
      v43 = sub_40B23B(Block);
      v70 = 0;
      v78 = 0;
      LODWORD(v68) = this + 26616;
      HIDWORD(v68) = this + 26624;
      v69 = this + 26632;
      HIDWORD(Buf2) = v43;
      v76 = 12;
      do
      {
        v44 = (DWORD *)*((_DWORD *)&v68 + v78);
        v75 = HIDWORD(Buf2) >> v76;
        if ( ((HIDWORD(Buf2) >> v76) & 8) != 0 && v44 )
        {
          if ( v78 )
          {
            v45 = sub_40B270(Block);
            sub_4111C2(v44, v45);
          }
          sub_410FA1(v44, v64);
          if ( (v75 & 4) != 0 )
            ++v65;
          v66 = 0;
          if ( (v75 & 3) != 0 )
          {
            v46 = 8 * (3 - (v75 & 3));
            v75 &= 3u;
            do
            {
              v47 = (unsigned __int8)sub_40B223(Block) << v46;
              v46 += 8;
              v66 |= v47;
              --v75;
            }
            while ( v75 );
          }
          sub_4110D5(*((_DWORD **)&v68 + v78), (int)v64);
        }
        v76 -= 4;
        ++v78;
      }
      while ( v76 > -4 );
    }
    v48 = *(_DWORD *)(v20 + 4168);
    v49 = __CFADD__(v48, *(_DWORD *)(this + 41512));
    *(_DWORD *)(this + 41512) += v48;
    *(_DWORD *)(this + 41516) += *(_DWORD *)(v20 + 4172) + v49;
    BYTE4(Buf2) = *(_BYTE *)(v20 + 4322);
    if ( *(_DWORD *)v20 != (unsigned __int16)sub_40B3A7(Block, SBYTE4(Buf2)) )
    {
      *(_BYTE *)(this + 41540) = 1;
      sub_406222(&dword_432A6C, 1);
      if ( !v79 )
        sub_4062C8(26, this + 30, (int)String1);
    }
  }
LABEL_115:
  if ( *(_DWORD *)(this + 22316) != (unsigned __int16)sub_40B3A7(Block, 0) )
  {
    v53 = *(_DWORD *)(this + 22320);
    if ( v53 != 121 && v53 != 118 )
    {
      if ( v53 != 5 || !*(_BYTE *)(this + 31462) )
        goto LABEL_125;
      sub_401188(&v68, this);
      v54 = *(_DWORD *)this;
      LOBYTE(v81) = 1;
      v55 = ((__int64 (__thiscall *)(int))*(_DWORD *)(v54 + 16))(this);
      v56 = 7;
      (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 12))(
        this,
        v55 - 7,
        (unsigned __int64)(v55 - 7) >> 32,
        0);
      v80 = 1;
      do
      {
        if ( sub_4089AB((int *)this) )
          v80 = 0;
        --v56;
      }
      while ( v56 );
      v57 = *(_DWORD *)v68;
      LOBYTE(v81) = 0;
      (*(void (__thiscall **)(_DWORD, int, int, _DWORD))(v57 + 12))(v68, v69, v70, 0);
      if ( !v80 )
      {
LABEL_125:
        *(_BYTE *)(this + 41540) = 1;
        sub_406222(&dword_432A6C, 3);
        if ( v79 )
        {
          sub_4062C8(4, this + 30, this + 30);
          *(_BYTE *)(this + 41541) = 1;
          goto LABEL_5;
        }
      }
    }
  }
  if ( *(_QWORD *)(this + 41512) <= *(_QWORD *)(this + 41504) )
    goto LABEL_12;
  v58 = v72;
  if ( Block[0] )
    free(Block[0]);
  return v58;
}
// 432A6C: using guessed type int dword_432A6C;
// 401CA9: using guessed type CHAR Str[8192];
// 401CA9: using guessed type char var_5C[4];
// 401CA9: using guessed type int var_80[5];

//----- (00402716) --------------------------------------------------------
int __thiscall sub_402716(void *this, int *a2, int a3, int Buf1)
{
  __int64 v5; // rax
  unsigned int v6; // ecx
  int v7; // esi
  int v8; // ecx
  __int64 v9; // rax
  unsigned int v10; // ebx
  bool v11; // zf
  __int64 v12; // rax
  __int64 v13; // rax
  int v14; // eax
  char v15; // al
  unsigned int v16; // eax
  unsigned int v17; // ebx
  int v18; // eax
  char v19; // al
  char v20; // bl
  int v21; // eax
  unsigned __int64 v22; // rax
  int v23; // eax
  unsigned __int64 v24; // rax
  int v25; // eax
  unsigned __int64 v26; // rax
  char v27; // al
  unsigned __int8 v28; // al
  char v30[8192]; // [esp+4h] [ebp-2054h] BYREF
  int v31[28]; // [esp+2004h] [ebp-54h] BYREF
  wchar_t Buffer[4]; // [esp+2074h] [ebp+1Ch] BYREF
  char Buf2[32]; // [esp+207Ch] [ebp+24h] BYREF
  unsigned int v34; // [esp+209Ch] [ebp+44h]
  unsigned int v35; // [esp+20A8h] [ebp+50h]
  unsigned int v36; // [esp+20ACh] [ebp+54h]
  int v37; // [esp+20B4h] [ebp+5Ch]
  unsigned __int64 v38; // [esp+20B8h] [ebp+60h]
  void *v39; // [esp+20C0h] [ebp+68h]
  char v40; // [esp+20CCh] [ebp+74h]
  unsigned int v41; // [esp+20CCh] [ebp+74h]
  unsigned int v42; // [esp+20CCh] [ebp+74h]
  char v43; // [esp+20CFh] [ebp+77h]
  char v44; // [esp+20D0h] [ebp+78h]

  v39 = this;
  LODWORD(v5) = a2[5] - a3;
  if ( (unsigned int)v5 >= a2[6] )
  {
    v6 = a2[5] - v5;
    a2[6] = v5;
    if ( v6 >= 2 )
    {
      v7 = Buf1;
      do
      {
        v5 = sub_40B2CE(a2);
        v35 = HIDWORD(v5);
        if ( !v5 )
          break;
        v8 = a2[6];
        HIDWORD(v5) = a2[5] - v8;
        if ( !HIDWORD(v5) || __SPAIR64__(v35, v5) > HIDWORD(v5) )
          break;
        v37 = v5 + v8;
        v9 = sub_40B2CE(a2);
        v10 = a2[5] - a2[6];
        v11 = *(_DWORD *)(v7 + 4) == 1;
        v38 = v9;
        if ( v11 && v9 == 1 )
        {
          *(_BYTE *)(v7 + 30) = 1;
          v40 = sub_40B2CE(a2);
          if ( (v40 & 1) != 0 )
          {
            v12 = sub_40B2CE(a2);
            v36 = v12;
            if ( v12 )
            {
              LODWORD(v12) = *((_DWORD *)v39 + 10376);
              *(_QWORD *)(v7 + 32) = __PAIR64__(*((_DWORD *)v39 + 10377), v36) + v12;
            }
          }
          if ( (v40 & 2) != 0 )
          {
            v13 = sub_40B2CE(a2);
            v34 = v13;
            if ( v13 )
            {
              LODWORD(v13) = *((_DWORD *)v39 + 10376);
              *(_QWORD *)(v7 + 48) = __PAIR64__(*((_DWORD *)v39 + 10377), v34) + v13;
            }
          }
        }
        v14 = *(_DWORD *)(v7 + 4);
        if ( (v14 == 2 || v14 == 3) && v38 <= 7 )
        {
          switch ( (_DWORD)v38 )
          {
            case 1:
              if ( (unsigned int)sub_40B2CE(a2) )
              {
                sub_401C8B(v39, v7 + 32);
              }
              else
              {
                v27 = sub_40B2CE(a2);
                *(_BYTE *)(v7 + 4273) = v27 & 1;
                *(_BYTE *)(v7 + 4282) = (v27 & 2) != 0;
                v28 = sub_40B223(a2);
                *(_DWORD *)(v7 + 4316) = v28;
                if ( v28 > 0x18u )
                  sub_401C8B(v39, v7 + 32);
                sub_40B357(a2, (char *)(v7 + 4241), 0x10u);
                sub_40B357(a2, (char *)(v7 + 4257), 0x10u);
                if ( *(_BYTE *)(v7 + 4273) )
                {
                  sub_40B357(a2, (char *)(v7 + 4274), 8u);
                  sub_40B357(a2, (char *)&Buf1, 4u);
                  sub_4102A1(v31);
                  sub_4105A3(v31, (char *)(v7 + 4274), 8u);
                  sub_41061C((int)v31, (int)Buf2);
                  *(_BYTE *)(v7 + 4273) = memcmp(&Buf1, Buf2, 4u) == 0;
                }
                *(_BYTE *)(v7 + 4240) = 1;
                *(_DWORD *)(v7 + 4236) = 5;
                *(_BYTE *)(v7 + 4235) = 1;
              }
              break;
            case 2:
              if ( !(unsigned int)sub_40B2CE(a2) )
              {
                *(_DWORD *)(v7 + 4192) = 3;
                sub_40B357(a2, (char *)(v7 + 4196), 0x20u);
              }
              break;
            case 3:
              if ( v10 >= 9 )
              {
                v19 = sub_40B2CE(a2);
                v20 = v19 & 1;
                v43 = v19;
                if ( (v19 & 2) != 0 )
                {
                  if ( v20 )
                  {
                    v21 = sub_40B270(a2);
                    sub_410F07((_QWORD *)(v7 + 4144), (unsigned int)v21);
                  }
                  else
                  {
                    v22 = sub_40B2AD(a2);
                    sub_410F33((_DWORD *)(v7 + 4144), v22, SHIDWORD(v22));
                  }
                }
                if ( (v43 & 4) != 0 )
                {
                  if ( v20 )
                  {
                    v23 = sub_40B270(a2);
                    sub_410F07((_QWORD *)(v7 + 4152), (unsigned int)v23);
                  }
                  else
                  {
                    v24 = sub_40B2AD(a2);
                    sub_410F33((_DWORD *)(v7 + 4152), v24, SHIDWORD(v24));
                  }
                }
                if ( (v43 & 8) != 0 )
                {
                  if ( v20 )
                  {
                    v25 = sub_40B270(a2);
                    sub_410F07((_QWORD *)(v7 + 4160), (unsigned int)v25);
                  }
                  else
                  {
                    v26 = sub_40B2AD(a2);
                    sub_410F33((_DWORD *)(v7 + 4160), v26, SHIDWORD(v26));
                  }
                }
              }
              break;
            case 4:
              if ( v10 )
              {
                sub_40B2CE(a2);
                v18 = sub_40B2CE(a2);
                if ( v18 )
                {
                  *(_BYTE *)(v7 + 4323) = 1;
                  swprintf(Buffer, 0x14u, L";%u", v18);
                  sub_4107BC((wchar_t *)v39 + 11252, Buffer, 0x800u);
                }
              }
              break;
            case 5:
              *(_DWORD *)(v7 + 4336) = sub_40B2CE(a2);
              *(_BYTE *)(v7 + 8436) = sub_40B2CE(a2) & 1;
              v16 = sub_40B2CE(a2);
              v17 = v16;
              v30[0] = 0;
              if ( v16 < 0x1FFF )
              {
                sub_40B357(a2, v30, v16);
                v30[v17] = 0;
              }
              sub_409F99(v30, (int)v30, 0x2000);
              sub_411817(v30, (_WORD *)(v7 + 4340), 2048);
              break;
            case 6:
              v15 = sub_40B2CE(a2);
              *(_BYTE *)(v7 + 8438) = (v15 & 4) != 0;
              v44 = v15;
              *(_BYTE *)(v7 + 8439) = (v15 & 8) != 0;
              *(_BYTE *)(v7 + 8696) = 0;
              *(_BYTE *)(v7 + 8440) = 0;
              if ( (v15 & 1) != 0 )
              {
                v41 = sub_40B2CE(a2);
                if ( v41 >= 0xFF )
                  v41 = 255;
                sub_40B357(a2, (char *)(v7 + 8440), v41);
                *(_BYTE *)(v7 + 8440 + v41) = 0;
              }
              if ( (v44 & 2) != 0 )
              {
                v42 = sub_40B2CE(a2);
                if ( v42 >= 0xFF )
                  v42 = 255;
                sub_40B357(a2, (char *)(v7 + 8696), v42);
                *(_BYTE *)(v7 + 8696 + v42) = 0;
              }
              if ( *(_BYTE *)(v7 + 8438) )
                *(_DWORD *)(v7 + 8952) = sub_40B2CE(a2);
              if ( *(_BYTE *)(v7 + 8439) )
                *(_DWORD *)(v7 + 8956) = sub_40B2CE(a2);
              *(_BYTE *)(v7 + 8437) = 1;
              break;
            case 7:
              sub_401C05((_DWORD *)(v7 + 4128), v10);
              sub_40B357(a2, *(char **)(v7 + 4128), v10);
              break;
          }
        }
        a2[6] = v37;
        LODWORD(v5) = a2[5] - a2[6];
      }
      while ( (unsigned int)v5 >= 2 );
    }
  }
  return v5;
}
// 402716: using guessed type char var_20C0[8192];

//----- (00402C37) --------------------------------------------------------
char __thiscall sub_402C37(int this, int *a2, int a3)
{
  int v5; // eax
  int v6; // eax
  bool v7; // zf
  unsigned int v8; // eax
  int v9; // ecx
  size_t v10; // [esp-8h] [ebp-E720h]
  char v11[19520]; // [esp+Ch] [ebp-E70Ch] BYREF
  unsigned int v12; // [esp+4C4Ch] [ebp-9ACCh]
  int v13; // [esp+4C50h] [ebp-9AC8h]
  char v14; // [esp+4C64h] [ebp-9AB4h]
  int v15; // [esp+E714h] [ebp-4h]

  if ( !*(_BYTE *)(this + 41540) )
  {
    if ( *(_BYTE *)(this + 31522) > 5u
      || *(unsigned __int8 *)(this + 31521) > (*(_DWORD *)(this + 41520) != 3 ? 0x1D : 0) )
    {
      sub_4012DD(28, this + 30);
      return 0;
    }
    if ( !*(_QWORD *)(this + 35664) && *(_BYTE *)(this + 35729) == (*(_BYTE *)(this + 35668) | *(_BYTE *)(this + 35664)) )
      return 1;
    sub_40B419((_DWORD *)(this + 7216));
    sub_4171B2((int)v11, this + 7216);
    v10 = *(_DWORD *)(this + 35820);
    v15 = 0;
    sub_412222((int)v11, v10, 0);
    if ( !a3 )
    {
      if ( *(__int64 *)(this + 35672) > 0x1000000 )
      {
        sub_4012DD(28, this + 30);
        goto LABEL_11;
      }
      sub_401C05(a2, *(_DWORD *)(this + 35672));
      sub_40B58F(this + 7216, *a2, *(_DWORD *)(this + 35672));
    }
    if ( *(_BYTE *)(this + 35731) )
    {
      v5 = *(_DWORD *)(this + 22276);
      if ( !*(_BYTE *)(v5 + 16672) )
        goto LABEL_11;
      sub_40B544(
        (_BYTE *)(this + 7216),
        0,
        *(_DWORD *)(this + 35732),
        (_BYTE *)(v5 + 16416),
        *(_BYTE *)(this + 35736) != 0 ? (void *)(this + 35737) : 0,
        this + 35753,
        *(_DWORD *)(this + 35812),
        (void *)(this + 35770),
        (void *)(this + 35779));
    }
    sub_4095F2((void *)(this + 19352), *(_DWORD *)(this + 35688), 1u);
    v6 = *(_DWORD *)(this + 35664);
    *(_DWORD *)(this + 7252) = *(_DWORD *)(this + 35668);
    *(_DWORD *)(this + 7248) = v6;
    *(_BYTE *)(this + 7256) = 0;
    sub_40B524((_DWORD *)(this + 7216), this, a3);
    *(_BYTE *)(this + 13455) = *(_BYTE *)(this + 35729);
    *(_DWORD *)(this + 7276) = 0;
    *(_DWORD *)(this + 7272) = this + 31496;
    v7 = *(_BYTE *)(this + 31522) == 0;
    v8 = *(_DWORD *)(this + 35672);
    v9 = *(_DWORD *)(this + 35676);
    v12 = v8;
    v13 = v9;
    v14 = 0;
    if ( v7 )
      sub_406FC2((char *)(this + 7216), v8, v9);
    else
      sub_41861B((int)v11, *(unsigned __int8 *)(this + 31521), 0);
    if ( sub_409856(
           (int *)(this + 19352),
           (int *)(this + 35688),
           *(_BYTE *)(this + 35778) != 0 ? (char *)(this + 35779) : 0) )
    {
      v15 = -1;
      sub_415133((int)v11);
      return 1;
    }
    sub_4062C8(29, this + 30, this + 31528);
    sub_406222(&dword_432A6C, 3);
    if ( a2 )
      sub_412595((int)a2);
LABEL_11:
    v15 = -1;
    sub_415133((int)v11);
    return 0;
  }
  sub_4012DD(27, this + 30);
  sub_406222(&dword_432A6C, 3);
  return 0;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00402ECC) --------------------------------------------------------
int __cdecl sub_402ECC(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        void *a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        __int16 a17,
        int a18,
        __int16 a19)
{
  return sub_402ED0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
}

//----- (00402ED0) --------------------------------------------------------
unsigned int __cdecl sub_402ED0(
        int a1,
        int a2,
        int Val,
        int a4,
        unsigned __int64 a5,
        __int64 Buf1,
        void *Block,
        int a8,
        int a9,
        int a10,
        int a11,
        unsigned int a12,
        int a13,
        int a14,
        int a15,
        unsigned int a16,
        int a17)
{
  int v17; // ecx
  int v18; // ebx
  bool v19; // zf
  _DWORD *v20; // esi
  int v21; // edi
  __int64 v22; // rax
  int v23; // eax
  unsigned int v24; // edi
  int v25; // eax
  int v26; // eax
  __int64 v27; // kr00_8
  int v28; // eax
  unsigned __int8 v29; // al
  int v30; // eax
  void *v31; // edi
  int v32; // eax
  int v33; // esi
  int v34; // eax
  __int64 v35; // rax
  unsigned int v36; // eax
  unsigned int v37; // edx
  int v38; // eax
  int v39; // eax
  unsigned int v40; // eax
  unsigned int v41; // eax
  char v42; // dl
  unsigned int v43; // edi
  _DWORD *v44; // ecx
  int v45; // ecx
  bool v46; // cl
  char v47; // dl
  int v48; // eax
  char v49; // al
  bool v50; // al
  unsigned int v51; // esi
  char v53[8192]; // [esp+Ch] [ebp-207Ch] BYREF
  int v54[31]; // [esp+200Ch] [ebp-7Ch] BYREF
  char Buf2; // [esp+2088h] [ebp+0h] BYREF

  v18 = v17;
  sub_40B3F7(&Block, v17);
  v19 = *(_BYTE *)(v18 + 41532) == 0;
  v54[30] = 0;
  if ( v19 || *(_QWORD *)(v18 + 41504) <= *(unsigned int *)(v18 + 41536) + 8i64 )
  {
    HIBYTE(a17) = 0;
  }
  else
  {
    HIBYTE(a17) = 1;
    sub_401BBF(v18);
    if ( (*(int (__thiscall **)(int, int *, int))(*(_DWORD *)v18 + 8))(v18, &Val, 16) != 16 )
    {
LABEL_4:
      sub_401C1F(v18);
LABEL_5:
      v19 = Block == 0;
LABEL_81:
      if ( !v19 )
        free(Block);
      return 0;
    }
    sub_405F4F(
      v18 + 4132,
      0,
      5,
      (_BYTE *)(*(_DWORD *)(v18 + 22276) + 16416),
      (void *)(v18 + 22444),
      (int)&Val,
      *(_DWORD *)(v18 + 22440),
      0,
      &Buf1);
    if ( *(_BYTE *)(v18 + 22436) && memcmp(&Buf1, (const void *)(v18 + 22460), 8u) )
    {
      sub_4012DD(6, v18 + 30);
      *(_BYTE *)(v18 + 41541) = 1;
      sub_406222(&dword_432A6C, 11);
      goto LABEL_5;
    }
    a14 = v18 + 4132;
  }
  if ( (unsigned int)sub_40B189(&Block, 7u) < 7 )
    goto LABEL_4;
  *(_BYTE *)(v18 + 22332) = 0;
  v20 = (_DWORD *)(v18 + 22316);
  *(_DWORD *)(v18 + 22316) = sub_40B270(&Block);
  v21 = sub_40B331((int *)&Block, 4u);
  v22 = sub_40B2CE((int *)&Block);
  if ( !v22 )
    goto LABEL_79;
  if ( !v21 )
    goto LABEL_79;
  v23 = v21 + v22;
  v24 = v23 + 4;
  if ( v23 - 3 < 0 || v24 < 7 )
    goto LABEL_79;
  sub_40B189(&Block, v23 - 3);
  if ( a12 < v24 )
  {
    sub_401C1F(v18);
LABEL_80:
    v19 = Block == 0;
    goto LABEL_81;
  }
  a16 = sub_40B3D7(&Block);
  *(_DWORD *)(v18 + 22320) = sub_40B2CE((int *)&Block);
  v25 = sub_40B2CE((int *)&Block);
  *(_DWORD *)(v18 + 22324) = v25;
  *(_BYTE *)(v18 + 22332) = (v25 & 4) != 0;
  *(_DWORD *)(v18 + 22308) = *(_DWORD *)(v18 + 22320);
  v19 = *v20 == a16;
  *(_DWORD *)(v18 + 22328) = v24;
  HIBYTE(a15) = !v19;
  if ( !v19 )
  {
    sub_401C68((_BYTE *)v18);
    *(_BYTE *)(v18 + 41540) = 1;
    sub_406222(&dword_432A6C, 3);
    if ( HIBYTE(a17) )
    {
      sub_4062C8(4, v18 + 30, v18 + 30);
      *(_BYTE *)(v18 + 41541) = 1;
      goto LABEL_80;
    }
  }
  v19 = (*(_BYTE *)(v18 + 22324) & 1) == 0;
  a5 = 0i64;
  if ( !v19 )
  {
    a5 = sub_40B2CE((int *)&Block);
    if ( a5 >= *(unsigned int *)(v18 + 22328) )
    {
      sub_401C68((_BYTE *)v18);
      goto LABEL_5;
    }
  }
  v19 = (*(_BYTE *)(v18 + 22324) & 2) == 0;
  Buf1 = 0i64;
  if ( !v19 )
    Buf1 = sub_40B2CE((int *)&Block);
  v26 = sub_4010D3(v18, *(_DWORD *)(v18 + 22328));
  v27 = Buf1 + *(_QWORD *)(v18 + 41504) + (unsigned int)v26;
  *(_DWORD *)(v18 + 41512) = v27;
  v28 = *(_DWORD *)(v18 + 22320);
  *(_DWORD *)(v18 + 41516) = HIDWORD(v27);
  if ( v28 == 1 )
  {
    sub_409886(v18 + 22352);
    qmemcpy((void *)(v18 + 22352), v20, 0x14u);
    v49 = sub_40B2CE((int *)&Block);
    *(_BYTE *)(v18 + 41525) = v49 & 1;
    *(_BYTE *)(v18 + 41524) = (v49 & 4) != 0;
    *(_BYTE *)(v18 + 41527) = (v49 & 0x10) != 0;
    *(_BYTE *)(v18 + 41531) = (v49 & 8) != 0;
    *(_BYTE *)(v18 + 41528) = 0;
    *(_BYTE *)(v18 + 41530) = 1;
    if ( (v49 & 2) != 0 )
      *(_DWORD *)(v18 + 41560) = sub_40B2CE((int *)&Block);
    else
      *(_DWORD *)(v18 + 41560) = 0;
    v50 = *(_BYTE *)(v18 + 41525) && !*(_DWORD *)(v18 + 41560);
    *(_BYTE *)(v18 + 41529) = v50;
    if ( a5 )
      sub_402716((void *)v18, (int *)&Block, a5, v18 + 22352);
  }
  else if ( v28 > 1 )
  {
    if ( v28 <= 3 )
    {
      v19 = v28 == 2;
      v30 = v18 + 22472;
      if ( !v19 )
        v30 = v18 + 31496;
      v31 = (void *)v30;
      a16 = v30;
      sub_4098B1(v30, 0);
      v32 = Buf1;
      qmemcpy(v31, v20, 0x14u);
      v19 = *(_DWORD *)(v18 + 22320) == 2;
      v33 = a16;
      *(_DWORD *)(a16 + 4168) = v32;
      v34 = HIDWORD(Buf1);
      HIBYTE(a17) = v19;
      *(_BYTE *)(v33 + 4329) = 1;
      *(_DWORD *)(v33 + 4172) = v34;
      *(_DWORD *)(v33 + 4228) = sub_40B2CE((int *)&Block);
      v35 = sub_40B2CE((int *)&Block);
      *(_DWORD *)(v33 + 4176) = v35;
      LOBYTE(v35) = (*(_DWORD *)(v33 + 4228) & 8) != 0;
      v19 = (*(_DWORD *)(v33 + 4228) & 8) == 0;
      *(_DWORD *)(v33 + 4180) = HIDWORD(v35);
      *(_BYTE *)(v33 + 4234) = v35;
      if ( !v19 )
      {
        *(_DWORD *)(v33 + 4176) = 0x7FFFFFFF;
        *(_DWORD *)(v33 + 4180) = 0x7FFFFFFF;
      }
      v36 = *(_DWORD *)(v33 + 4172);
      v37 = *(_DWORD *)(v33 + 4168);
      if ( __SPAIR64__(v36, v37) <= *(_QWORD *)(v33 + 4176) )
      {
        v37 = *(_DWORD *)(v33 + 4176);
        v36 = *(_DWORD *)(v33 + 4180);
      }
      *(_DWORD *)(v33 + 4184) = v37;
      *(_DWORD *)(v33 + 4188) = v36;
      v38 = sub_40B2CE((int *)&Block);
      v19 = (*(_BYTE *)(v33 + 4228) & 2) == 0;
      *(_DWORD *)(v33 + 28) = v38;
      if ( !v19 )
      {
        v39 = sub_40B270(&Block);
        sub_410F07((_QWORD *)(v33 + 4144), (unsigned int)v39);
      }
      *(_DWORD *)(v33 + 4192) = 0;
      if ( (*(_BYTE *)(v33 + 4228) & 4) != 0 )
      {
        *(_DWORD *)(v33 + 4192) = 2;
        *(_DWORD *)(v33 + 4196) = sub_40B270(&Block);
      }
      *(_DWORD *)(v33 + 4336) = 0;
      v40 = sub_40B2CE((int *)&Block);
      a16 = v40;
      *(_BYTE *)(v33 + 26) = (v40 >> 7) & 7;
      *(_BYTE *)(v33 + 25) = v40 & 0x3F;
      *(_BYTE *)(v33 + 24) = sub_40B2CE((int *)&Block);
      v41 = sub_40B2CE((int *)&Block);
      v42 = *(_BYTE *)(v33 + 24);
      v43 = v41;
      v44 = (_DWORD *)(v33 + 4332);
      *(_BYTE *)(v33 + 4328) = (*(_DWORD *)(v18 + 22324) & 0x40) != 0;
      *(_DWORD *)(v33 + 4332) = 2;
      if ( v42 == 1 )
      {
        *v44 = 1;
      }
      else if ( !v42 )
      {
        *v44 = 0;
      }
      v45 = *(_DWORD *)(v33 + 8);
      *(_BYTE *)(v33 + 4232) = (v45 & 8) != 0;
      v19 = HIBYTE(a17) == 0;
      *(_BYTE *)(v33 + 4233) = (v45 & 0x10) != 0;
      *(_BYTE *)(v33 + 4330) = (v45 & 0x20) != 0;
      v46 = !v19 && (a16 & 0x40) != 0;
      v47 = *(_BYTE *)(v33 + 4228);
      *(_BYTE *)(v33 + 4320) = v46;
      v47 &= 1u;
      v48 = -(*(_BYTE *)(v33 + 4235) != 0);
      *(_DWORD *)(v33 + 4324) = v47 == 0 ? 0x20000 << ((a16 >> 10) & 0xF) : 0;
      *(_BYTE *)(v33 + 4321) = v47;
      *(_DWORD *)(v33 + 4236) = v48 & 5;
      if ( v43 >= 0x1FFF )
        v43 = 0x1FFF;
      sub_40B357(&Block, v53, v43);
      v53[v43] = 0;
      sub_411817(v53, (_WORD *)(v33 + 32), 2047);
      if ( a5 )
        sub_402716((void *)v18, (int *)&Block, a5, v33);
      if ( HIBYTE(a17) )
      {
        sub_401ABA((_DWORD *)v18, v33);
      }
      else if ( !wcscmp((const wchar_t *)(v33 + 32), L"CMT") )
      {
        *(_BYTE *)(v18 + 41526) = 1;
      }
      if ( HIBYTE(a15) )
        sub_4062C8(26, v18 + 30, v33 + 32);
    }
    else if ( v28 == 4 )
    {
      qmemcpy((void *)(v18 + 22416), v20, 0x14u);
      if ( (unsigned int)sub_40B2CE((int *)&Block)
        || (*(_BYTE *)(v18 + 22436) = sub_40B2CE((int *)&Block) & 1,
            v29 = sub_40B223(&Block),
            *(_DWORD *)(v18 + 22440) = v29,
            v29 > 0x18u) )
      {
        sub_401C8B((void *)v18, v18 + 30);
        goto LABEL_80;
      }
      sub_40B357(&Block, (char *)(v18 + 22444), 0x10u);
      if ( *(_BYTE *)(v18 + 22436) )
      {
        sub_40B357(&Block, (char *)(v18 + 22460), 8u);
        sub_40B357(&Block, (char *)&a16, 4u);
        sub_4102A1(v54);
        sub_4105A3(v54, (char *)(v18 + 22460), 8u);
        sub_41061C((int)v54, (int)&Buf2);
        *(_BYTE *)(v18 + 22436) = memcmp(&a16, &Buf2, 4u) == 0;
      }
      *(_BYTE *)(v18 + 41532) = 1;
    }
    else if ( v28 == 5 )
    {
      qmemcpy((void *)(v18 + 31432), v20, 0x14u);
      *(_BYTE *)(v18 + 31460) = sub_40B2CE((int *)&Block) & 1;
      *(_BYTE *)(v18 + 31463) = 0;
      *(_BYTE *)(v18 + 31461) = 0;
      *(_BYTE *)(v18 + 31462) = 0;
    }
  }
  if ( *(_QWORD *)(v18 + 41512) <= *(_QWORD *)(v18 + 41504) )
  {
LABEL_79:
    sub_401C68((_BYTE *)v18);
    goto LABEL_80;
  }
  v51 = a12;
  if ( Block )
    free(Block);
  return v51;
}
// 402EE6: variable 'v17' is possibly undefined
// 432A6C: using guessed type int dword_432A6C;
// 402ED0: using guessed type char var_207C[8192];

//----- (0040363F) --------------------------------------------------------
#error "40366C: call analysis failed (funcsize=37)"

//----- (004036AE) --------------------------------------------------------
int __thiscall sub_4036AE(_DWORD *this, int a2)
{
  int v3; // ebx
  int v4; // edi

  v3 = 0;
  v4 = sub_40363F(this);
  if ( v4 )
  {
    while ( a2 == 5 || this[5577] != 5 )
    {
      if ( (++v3 & 0x7F) == 0 )
        sub_4109C7();
      if ( this[5577] == a2 )
        return v4;
      sub_4010BF(this);
      v4 = sub_40363F(this);
      if ( !v4 )
        return 0;
    }
  }
  return 0;
}
// 40363F: using guessed type int __thiscall sub_40363F(_DWORD);

//----- (00403707) --------------------------------------------------------
int __thiscall sub_403707(wchar_t *this, wchar_t *String2)
{
  wchar_t *i; // esi
  int v3; // eax
  int v4; // edi

  for ( i = this; ; this = i )
  {
    v4 = sub_40363F(this);
    if ( !v4 )
      return 0;
    v3 = *((_DWORD *)i + 5577);
    if ( v3 == 5 )
      return 0;
    if ( v3 == 3 && sub_401B88(i + 15748, String2) )
      break;
    sub_4010BF(i);
  }
  return v4;
}
// 40363F: using guessed type int __thiscall sub_40363F(_DWORD);

//----- (0040374F) --------------------------------------------------------
int sub_40374F()
{
  int result; // eax

  result = 1359893119;
  xmmword_430590 = (__int128)_mm_unpacklo_epi32(
                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(0x6A09E667u), _mm_cvtsi32_si128(0x3C6EF372u)),
                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(0xBB67AE85), _mm_cvtsi32_si128(0xA54FF53A)));
  xmmword_430580 = (__int128)_mm_unpacklo_epi32(
                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(0x510E527Fu), _mm_cvtsi32_si128(0x1F83D9ABu)),
                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(0x9B05688C), _mm_cvtsi32_si128(0x5BE0CD19u)));
  return result;
}
// 430580: using guessed type __int128 xmmword_430580;
// 430590: using guessed type __int128 xmmword_430590;

//----- (004037C2) --------------------------------------------------------
int __stdcall sub_4037C2(int a1, unsigned int *a2)
{
  __m128i si128; // xmm4
  unsigned int v3; // ecx
  unsigned int v4; // edx
  __m128i v5; // xmm1
  unsigned int v6; // esi
  unsigned int v7; // edi
  __m128i v8; // xmm6
  unsigned int v9; // ebx
  unsigned int v10; // ebx
  __m128i v11; // xmm0
  __m128i v12; // xmm2
  __m128i v13; // xmm2
  __m128i v14; // xmm1
  __m128i v15; // xmm3
  __m128i v16; // xmm3
  __m128i v17; // xmm0
  __m128i v18; // xmm4
  __m128i v19; // xmm4
  __m128i v20; // xmm1
  __m128i v21; // xmm5
  __m128i v22; // xmm3
  __m128i v23; // xmm2
  __m128i v24; // xmm1
  unsigned int v25; // ebx
  __m128i v26; // xmm4
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm3
  __m128i v30; // xmm1
  __m128i v31; // xmm1
  __m128i v32; // xmm4
  __m128i v33; // xmm2
  __m128i v34; // xmm2
  __m128i v35; // xmm3
  __m128i v36; // xmm5
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm0
  __m128i v40; // xmm0
  __m128i v41; // xmm2
  __m128i v42; // xmm3
  __m128i v43; // xmm1
  __m128i v44; // xmm4
  __m128i v45; // xmm0
  __m128i v46; // xmm3
  __m128i v47; // xmm2
  __m128i v48; // xmm5
  __m128i v49; // xmm1
  __m128i v50; // xmm4
  __m128i v51; // xmm0
  __m128i v52; // xmm0
  __m128i v53; // xmm2
  __m128i v54; // xmm1
  __m128i v55; // xmm1
  __m128i v56; // xmm4
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  __m128i v59; // xmm2
  __m128i v60; // xmm1
  __m128i v61; // xmm1
  __m128i v62; // xmm4
  __m128i v63; // xmm0
  __m128i v64; // xmm0
  __m128i v65; // xmm2
  __m128i v66; // xmm1
  __m128i v67; // xmm1
  __m128i v68; // xmm4
  __m128i v69; // xmm0
  __m128i v70; // xmm3
  __m128i v71; // xmm2
  __m128i v72; // xmm5
  __m128i v73; // xmm1
  __m128i v74; // xmm4
  __m128i v75; // xmm0
  __m128i v76; // xmm0
  __m128i v77; // xmm2
  __m128i v78; // xmm1
  __m128i v79; // xmm1
  __m128i v80; // xmm4
  __m128i v81; // xmm3
  __m128i v82; // xmm3
  __m128i v83; // xmm2
  __m128i v84; // xmm1
  __m128i v85; // xmm1
  __m128i v86; // xmm4
  __m128i v87; // xmm0
  __m128i v88; // xmm0
  __m128i v89; // xmm2
  __m128i v90; // xmm1
  __m128i v91; // xmm1
  __m128i v92; // xmm4
  __m128i v93; // xmm0
  __m128i v94; // xmm3
  __m128i v95; // xmm2
  __m128i v96; // xmm5
  __m128i v97; // xmm1
  __m128i v98; // xmm4
  __m128i v99; // xmm0
  __m128i v100; // xmm0
  __m128i v101; // xmm2
  __m128i v102; // xmm1
  __m128i v103; // xmm1
  __m128i v104; // xmm4
  __m128i v105; // xmm0
  __m128i v106; // xmm3
  __m128i v107; // xmm2
  __m128i v108; // xmm5
  __m128i v109; // xmm1
  __m128i v110; // xmm4
  __m128i v111; // xmm0
  __m128i v112; // xmm0
  __m128i v113; // xmm2
  __m128i v114; // xmm1
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm3
  __m128i v118; // xmm3
  __m128i v119; // xmm2
  __m128i v120; // xmm1
  __m128i v121; // xmm1
  __m128i v122; // xmm4
  __m128i v123; // xmm3
  __m128i v124; // xmm0
  __m128i v125; // xmm2
  __m128i v126; // xmm1
  __m128i v127; // xmm1
  __m128i v128; // xmm4
  __m128i v129; // xmm0
  __m128i v130; // xmm3
  __m128i v131; // xmm2
  __m128i v132; // xmm5
  __m128i v133; // xmm1
  __m128i v134; // xmm4
  __m128i v135; // xmm0
  __m128i v136; // xmm0
  __m128i v137; // xmm2
  __m128i v138; // xmm1
  __m128i v139; // xmm1
  __m128i v140; // xmm4
  __m128i v141; // xmm3
  __m128i v142; // xmm3
  __m128i v143; // xmm2
  __m128i v144; // xmm5
  __m128i v145; // xmm1
  __m128i v146; // xmm4
  __m128i v147; // xmm0
  __m128i v148; // xmm0
  __m128i v149; // xmm2
  __m128i v150; // xmm1
  __m128i v151; // xmm1
  __m128i v152; // xmm4
  __m128i v153; // xmm0
  __m128i v154; // xmm3
  __m128i v155; // xmm2
  __m128i v156; // xmm5
  __m128i v157; // xmm1
  __m128i v158; // xmm4
  __m128i v159; // xmm0
  __m128i v160; // xmm0
  __m128i v161; // xmm2
  __m128i v162; // xmm1
  __m128i v163; // xmm1
  __m128i v164; // xmm4
  __m128i v165; // xmm0
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  __m128i v168; // xmm5
  __m128i v169; // xmm1
  __m128i v170; // xmm4
  __m128i v171; // xmm0
  __m128i v172; // xmm0
  __m128i v173; // xmm2
  __m128i v174; // xmm1
  __m128i v175; // xmm1
  __m128i v176; // xmm4
  __m128i v177; // xmm3
  __m128i v178; // xmm3
  __m128i v179; // xmm2
  __m128i v180; // xmm1
  __m128i v181; // xmm1
  __m128i v182; // xmm4
  __m128i v183; // xmm3
  __m128i v184; // xmm0
  __m128i v185; // xmm2
  __m128i v186; // xmm1
  __m128i v187; // xmm1
  __m128i v188; // xmm4
  __m128i v189; // xmm0
  __m128i v190; // xmm3
  __m128i v191; // xmm2
  __m128i v192; // xmm5
  __m128i v193; // xmm1
  __m128i v194; // xmm4
  __m128i v195; // xmm0
  __m128i v196; // xmm0
  __m128i v197; // xmm2
  __m128i v198; // xmm1
  __m128i v199; // xmm1
  __m128i v200; // xmm4
  __m128i v201; // xmm3
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  __m128i v204; // xmm5
  __m128i v205; // xmm1
  __m128i v206; // xmm4
  __m128i v207; // xmm0
  __m128i v208; // xmm0
  __m128i v209; // xmm2
  __m128i v210; // xmm1
  __m128i v211; // xmm1
  __m128i v212; // xmm4
  __m128i v213; // xmm0
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  __m128i v216; // xmm5
  __m128i v217; // xmm1
  __m128i v218; // xmm4
  __m128i v219; // xmm0
  __m128i v220; // xmm0
  __m128i v221; // xmm2
  __m128i v222; // xmm1
  __m128i v223; // xmm1
  __m128i v224; // xmm4
  __m128i v225; // xmm0
  __m128i v226; // xmm3
  __m128i v227; // xmm2
  __m128i v228; // xmm5
  __m128i v229; // xmm1
  __m128i v230; // xmm4
  __m128i v231; // xmm0
  __m128i v232; // xmm0
  __m128i v233; // xmm2
  __m128i v234; // xmm1
  __m128i v235; // xmm1
  __m128i v236; // xmm4
  __m128i v237; // xmm3
  __m128i v238; // xmm3
  __m128i v239; // xmm2
  __m128i v240; // xmm1
  __m128i v241; // xmm1
  __m128i v242; // xmm4
  __m128i v243; // xmm3
  __m128i v244; // xmm0
  __m128i v245; // xmm2
  __m128i v246; // xmm3
  __m128i v247; // xmm1
  __m128i v248; // xmm4
  __m128i v249; // xmm3
  __m128i v250; // xmm3
  __m128i v251; // xmm2
  __m128i v252; // xmm0
  unsigned int v254; // [esp+4h] [ebp-50h]
  unsigned int v255; // [esp+8h] [ebp-4Ch]
  unsigned int v256; // [esp+Ch] [ebp-48h]
  unsigned int v257; // [esp+10h] [ebp-44h]
  unsigned int v258; // [esp+14h] [ebp-40h]
  unsigned int v259; // [esp+18h] [ebp-3Ch]
  unsigned int v260; // [esp+1Ch] [ebp-38h]
  unsigned int v261; // [esp+20h] [ebp-34h]
  unsigned int v262; // [esp+24h] [ebp-30h]
  unsigned int v263; // [esp+2Ch] [ebp-28h]
  unsigned int v264; // [esp+30h] [ebp-24h]
  __m128i v265; // [esp+34h] [ebp-20h] BYREF
  __m128i v266; // [esp+44h] [ebp-10h] BYREF

  si128 = _mm_load_si128((const __m128i *)(*(_DWORD *)(a1 + 244) + 16));
  v3 = a2[6];
  v4 = a2[4];
  v5 = _mm_xor_si128(
         _mm_load_si128((const __m128i *)&xmmword_430580),
         _mm_load_si128((const __m128i *)*(_DWORD *)(a1 + 248)));
  v6 = a2[2];
  v7 = *a2;
  v255 = a2[7];
  v8 = _mm_cvtsi32_si128(*a2);
  v257 = a2[5];
  v9 = a2[3];
  v265 = _mm_load_si128((const __m128i *)*(_DWORD *)(a1 + 244));
  v259 = v9;
  v10 = a2[1];
  v11 = _mm_add_epi32(
          _mm_add_epi32(
            v265,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(v8, _mm_cvtsi32_si128(v4)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v6), _mm_cvtsi32_si128(v3)))),
          si128);
  v12 = _mm_xor_si128(v5, v11);
  v13 = _mm_xor_si128(_mm_srli_epi32(v12, 0x10u), _mm_slli_epi32(v12, 0x10u));
  v266 = si128;
  v14 = _mm_add_epi32(_mm_load_si128((const __m128i *)&xmmword_430590), v13);
  v254 = v10;
  v15 = _mm_xor_si128(si128, v14);
  v16 = _mm_xor_si128(_mm_srli_epi32(v15, 0xCu), _mm_slli_epi32(v15, 0x14u));
  v262 = a2[14];
  v261 = a2[12];
  v17 = _mm_add_epi32(
          _mm_add_epi32(
            v11,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v10), _mm_cvtsi32_si128(v257)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v259), _mm_cvtsi32_si128(v255)))),
          v16);
  v18 = _mm_xor_si128(v13, v17);
  v19 = _mm_xor_si128(_mm_srli_epi32(v18, 8u), _mm_slli_epi32(v18, 0x18u));
  v20 = _mm_add_epi32(v14, v19);
  v21 = _mm_xor_si128(v16, v20);
  v22 = _mm_shuffle_epi32(v20, 78);
  v263 = a2[10];
  v23 = _mm_shuffle_epi32(v19, 147);
  v24 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v21, 7u), _mm_slli_epi32(v21, 0x19u)), 57);
  v256 = a2[8];
  v264 = a2[15];
  v258 = a2[13];
  v25 = a2[11];
  v26 = _mm_add_epi32(
          _mm_add_epi32(
            v17,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v256), _mm_cvtsi32_si128(v261)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v263), _mm_cvtsi32_si128(v262)))),
          v24);
  v27 = _mm_xor_si128(v23, v26);
  v28 = _mm_xor_si128(_mm_srli_epi32(v27, 0x10u), _mm_slli_epi32(v27, 0x10u));
  v29 = _mm_add_epi32(v22, v28);
  v30 = _mm_xor_si128(v24, v29);
  v31 = _mm_xor_si128(_mm_srli_epi32(v30, 0xCu), _mm_slli_epi32(v30, 0x14u));
  v260 = a2[9];
  v32 = _mm_add_epi32(
          _mm_add_epi32(
            v26,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v260), _mm_cvtsi32_si128(v258)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v25), _mm_cvtsi32_si128(v264)))),
          v31);
  v33 = _mm_xor_si128(v28, v32);
  v34 = _mm_xor_si128(_mm_srli_epi32(v33, 8u), _mm_slli_epi32(v33, 0x18u));
  v35 = _mm_add_epi32(v29, v34);
  v36 = _mm_xor_si128(v31, v35);
  v37 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v36, 7u), _mm_slli_epi32(v36, 0x19u)), 147);
  v38 = _mm_add_epi32(
          _mm_add_epi32(
            v32,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v262), _mm_cvtsi32_si128(v260)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v4), _mm_cvtsi32_si128(v258)))),
          v37);
  v39 = _mm_xor_si128(_mm_shuffle_epi32(v34, 57), v38);
  v40 = _mm_xor_si128(_mm_srli_epi32(v39, 0x10u), _mm_slli_epi32(v39, 0x10u));
  v41 = _mm_add_epi32(_mm_shuffle_epi32(v35, 78), v40);
  v42 = _mm_xor_si128(v37, v41);
  v43 = _mm_xor_si128(_mm_srli_epi32(v42, 0xCu), _mm_slli_epi32(v42, 0x14u));
  v44 = _mm_add_epi32(
          _mm_add_epi32(
            v38,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v263), _mm_cvtsi32_si128(v264)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v256), _mm_cvtsi32_si128(v3)))),
          v43);
  v45 = _mm_xor_si128(v40, v44);
  v46 = _mm_xor_si128(_mm_srli_epi32(v45, 8u), _mm_slli_epi32(v45, 0x18u));
  v47 = _mm_add_epi32(v41, v46);
  v48 = _mm_xor_si128(v43, v47);
  v49 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v48, 7u), _mm_slli_epi32(v48, 0x19u)), 57);
  v50 = _mm_add_epi32(
          _mm_add_epi32(
            v44,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v254), _mm_cvtsi32_si128(v25)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v257)))),
          v49);
  v51 = _mm_xor_si128(_mm_shuffle_epi32(v46, 147), v50);
  v52 = _mm_xor_si128(_mm_srli_epi32(v51, 0x10u), _mm_slli_epi32(v51, 0x10u));
  v53 = _mm_add_epi32(_mm_shuffle_epi32(v47, 78), v52);
  v54 = _mm_xor_si128(v49, v53);
  v55 = _mm_xor_si128(_mm_srli_epi32(v54, 0xCu), _mm_slli_epi32(v54, 0x14u));
  v56 = _mm_add_epi32(
          _mm_add_epi32(
            v50,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v261), _mm_cvtsi32_si128(v255)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v6), _mm_cvtsi32_si128(v259)))),
          v55);
  v57 = _mm_xor_si128(v52, v56);
  v58 = _mm_xor_si128(_mm_srli_epi32(v57, 8u), _mm_slli_epi32(v57, 0x18u));
  v59 = _mm_add_epi32(v53, v58);
  v60 = _mm_xor_si128(v55, v59);
  v61 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v60, 7u), _mm_slli_epi32(v60, 0x19u)), 147);
  v62 = _mm_add_epi32(
          _mm_add_epi32(
            v56,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v25), _mm_cvtsi32_si128(v257)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v261), _mm_cvtsi32_si128(v264)))),
          v61);
  v63 = _mm_xor_si128(_mm_shuffle_epi32(v58, 57), v62);
  v64 = _mm_xor_si128(_mm_srli_epi32(v63, 0x10u), _mm_slli_epi32(v63, 0x10u));
  v65 = _mm_add_epi32(_mm_shuffle_epi32(v59, 78), v64);
  v66 = _mm_xor_si128(v61, v65);
  v67 = _mm_xor_si128(_mm_srli_epi32(v66, 0xCu), _mm_slli_epi32(v66, 0x14u));
  v68 = _mm_add_epi32(
          _mm_add_epi32(
            v62,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v256), _mm_cvtsi32_si128(v6)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v258)))),
          v67);
  v69 = _mm_xor_si128(v64, v68);
  v70 = _mm_xor_si128(_mm_srli_epi32(v69, 8u), _mm_slli_epi32(v69, 0x18u));
  v71 = _mm_add_epi32(v65, v70);
  v72 = _mm_xor_si128(v67, v71);
  v73 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v72, 7u), _mm_slli_epi32(v72, 0x19u)), 57);
  v74 = _mm_add_epi32(
          _mm_add_epi32(
            v68,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v263), _mm_cvtsi32_si128(v255)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v259), _mm_cvtsi32_si128(v260)))),
          v73);
  v75 = _mm_xor_si128(_mm_shuffle_epi32(v70, 147), v74);
  v76 = _mm_xor_si128(_mm_srli_epi32(v75, 0x10u), _mm_slli_epi32(v75, 0x10u));
  v77 = _mm_add_epi32(_mm_shuffle_epi32(v71, 78), v76);
  v78 = _mm_xor_si128(v73, v77);
  v79 = _mm_xor_si128(_mm_srli_epi32(v78, 0xCu), _mm_slli_epi32(v78, 0x14u));
  v80 = _mm_add_epi32(
          _mm_add_epi32(
            v74,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v262), _mm_cvtsi32_si128(v254)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), _mm_cvtsi32_si128(v4)))),
          v79);
  v81 = _mm_xor_si128(v76, v80);
  v82 = _mm_xor_si128(_mm_srli_epi32(v81, 8u), _mm_slli_epi32(v81, 0x18u));
  v83 = _mm_add_epi32(v77, v82);
  v84 = _mm_xor_si128(v79, v83);
  v85 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v84, 7u), _mm_slli_epi32(v84, 0x19u)), 147);
  v86 = _mm_add_epi32(
          _mm_add_epi32(
            v80,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v255), _mm_cvtsi32_si128(v258)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v259), _mm_cvtsi32_si128(v25)))),
          v85);
  v87 = _mm_xor_si128(_mm_shuffle_epi32(v82, 57), v86);
  v88 = _mm_xor_si128(_mm_srli_epi32(v87, 0x10u), _mm_slli_epi32(v87, 0x10u));
  v89 = _mm_add_epi32(_mm_shuffle_epi32(v83, 78), v88);
  v90 = _mm_xor_si128(v85, v89);
  v91 = _mm_xor_si128(_mm_srli_epi32(v90, 0xCu), _mm_slli_epi32(v90, 0x14u));
  v92 = _mm_add_epi32(
          _mm_add_epi32(
            v86,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v260), _mm_cvtsi32_si128(v261)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v254), _mm_cvtsi32_si128(v262)))),
          v91);
  v93 = _mm_xor_si128(v88, v92);
  v94 = _mm_xor_si128(_mm_srli_epi32(v93, 8u), _mm_slli_epi32(v93, 0x18u));
  v95 = _mm_add_epi32(v89, v94);
  v96 = _mm_xor_si128(v91, v95);
  v97 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v96, 7u), _mm_slli_epi32(v96, 0x19u)), 57);
  v98 = _mm_add_epi32(
          _mm_add_epi32(
            v92,
            _mm_unpacklo_epi32(
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v6), _mm_cvtsi32_si128(v4)),
              _mm_unpacklo_epi32(_mm_cvtsi32_si128(v257), _mm_cvtsi32_si128(v264)))),
          v97);
  v99 = _mm_xor_si128(_mm_shuffle_epi32(v94, 147), v98);
  v100 = _mm_xor_si128(_mm_srli_epi32(v99, 0x10u), _mm_slli_epi32(v99, 0x10u));
  v101 = _mm_add_epi32(_mm_shuffle_epi32(v95, 78), v100);
  v102 = _mm_xor_si128(v97, v101);
  v103 = _mm_xor_si128(_mm_srli_epi32(v102, 0xCu), _mm_slli_epi32(v102, 0x14u));
  v104 = _mm_add_epi32(
           _mm_add_epi32(
             v98,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), _mm_cvtsi32_si128(v7)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v263), _mm_cvtsi32_si128(v256)))),
           v103);
  v105 = _mm_xor_si128(v100, v104);
  v106 = _mm_xor_si128(_mm_srli_epi32(v105, 8u), _mm_slli_epi32(v105, 0x18u));
  v107 = _mm_add_epi32(v101, v106);
  v108 = _mm_xor_si128(v103, v107);
  v109 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v108, 7u), _mm_slli_epi32(v108, 0x19u)), 147);
  v110 = _mm_add_epi32(
           _mm_add_epi32(
             v104,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v260), _mm_cvtsi32_si128(v6)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v257), _mm_cvtsi32_si128(v263)))),
           v109);
  v111 = _mm_xor_si128(_mm_shuffle_epi32(v106, 57), v110);
  v112 = _mm_xor_si128(_mm_srli_epi32(v111, 0x10u), _mm_slli_epi32(v111, 0x10u));
  v113 = _mm_add_epi32(_mm_shuffle_epi32(v107, 78), v112);
  v114 = _mm_xor_si128(v109, v113);
  v115 = _mm_xor_si128(_mm_srli_epi32(v114, 0xCu), _mm_slli_epi32(v114, 0x14u));
  v116 = _mm_add_epi32(
           _mm_add_epi32(
             v110,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v4)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v255), _mm_cvtsi32_si128(v264)))),
           v115);
  v117 = _mm_xor_si128(v112, v116);
  v118 = _mm_xor_si128(_mm_srli_epi32(v117, 8u), _mm_slli_epi32(v117, 0x18u));
  v119 = _mm_add_epi32(v113, v118);
  v120 = _mm_xor_si128(v115, v119);
  v121 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v120, 7u), _mm_slli_epi32(v120, 0x19u)), 57);
  v122 = _mm_add_epi32(
           _mm_add_epi32(
             v116,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v262), _mm_cvtsi32_si128(v3)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v25), _mm_cvtsi32_si128(v259)))),
           v121);
  v123 = _mm_xor_si128(_mm_shuffle_epi32(v118, 147), v122);
  v124 = _mm_xor_si128(_mm_srli_epi32(v123, 0x10u), _mm_slli_epi32(v123, 0x10u));
  v125 = _mm_add_epi32(_mm_shuffle_epi32(v119, 78), v124);
  v126 = _mm_xor_si128(v121, v125);
  v127 = _mm_xor_si128(_mm_srli_epi32(v126, 0xCu), _mm_slli_epi32(v126, 0x14u));
  v128 = _mm_add_epi32(
           _mm_add_epi32(
             v122,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v254), _mm_cvtsi32_si128(v256)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v261), _mm_cvtsi32_si128(v258)))),
           v127);
  v129 = _mm_xor_si128(v124, v128);
  v130 = _mm_xor_si128(_mm_srli_epi32(v129, 8u), _mm_slli_epi32(v129, 0x18u));
  v131 = _mm_add_epi32(v125, v130);
  v132 = _mm_xor_si128(v127, v131);
  v133 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v132, 7u), _mm_slli_epi32(v132, 0x19u)), 147);
  v134 = _mm_add_epi32(
           _mm_add_epi32(
             v128,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v6), _mm_cvtsi32_si128(v7)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), _mm_cvtsi32_si128(v256)))),
           v133);
  v135 = _mm_xor_si128(_mm_shuffle_epi32(v130, 57), v134);
  v136 = _mm_xor_si128(_mm_srli_epi32(v135, 0x10u), _mm_slli_epi32(v135, 0x10u));
  v137 = _mm_add_epi32(_mm_shuffle_epi32(v131, 78), v136);
  v138 = _mm_xor_si128(v133, v137);
  v139 = _mm_xor_si128(_mm_srli_epi32(v138, 0xCu), _mm_slli_epi32(v138, 0x14u));
  v140 = _mm_add_epi32(
           _mm_add_epi32(
             v134,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v261), _mm_cvtsi32_si128(v25)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v263), _mm_cvtsi32_si128(v259)))),
           v139);
  v141 = _mm_xor_si128(v136, v140);
  v142 = _mm_xor_si128(_mm_srli_epi32(v141, 8u), _mm_slli_epi32(v141, 0x18u));
  v143 = _mm_add_epi32(v137, v142);
  v144 = _mm_xor_si128(v139, v143);
  v145 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v144, 7u), _mm_slli_epi32(v144, 0x19u)), 57);
  v146 = _mm_add_epi32(
           _mm_add_epi32(
             v140,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v4), _mm_cvtsi32_si128(v264)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v255), _mm_cvtsi32_si128(v254)))),
           v145);
  v147 = _mm_xor_si128(_mm_shuffle_epi32(v142, 147), v146);
  v148 = _mm_xor_si128(_mm_srli_epi32(v147, 0x10u), _mm_slli_epi32(v147, 0x10u));
  v149 = _mm_add_epi32(_mm_shuffle_epi32(v143, 78), v148);
  v150 = _mm_xor_si128(v145, v149);
  v151 = _mm_xor_si128(_mm_srli_epi32(v150, 0xCu), _mm_slli_epi32(v150, 0x14u));
  v152 = _mm_add_epi32(
           _mm_add_epi32(
             v146,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v258), _mm_cvtsi32_si128(v262)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v257), _mm_cvtsi32_si128(v260)))),
           v151);
  v153 = _mm_xor_si128(v148, v152);
  v154 = _mm_xor_si128(_mm_srli_epi32(v153, 8u), _mm_slli_epi32(v153, 0x18u));
  v155 = _mm_add_epi32(v149, v154);
  v156 = _mm_xor_si128(v151, v155);
  v157 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v156, 7u), _mm_slli_epi32(v156, 0x19u)), 147);
  v158 = _mm_add_epi32(
           _mm_add_epi32(
             v152,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v261), _mm_cvtsi32_si128(v262)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v254), _mm_cvtsi32_si128(v4)))),
           v157);
  v159 = _mm_xor_si128(_mm_shuffle_epi32(v154, 57), v158);
  v160 = _mm_xor_si128(_mm_srli_epi32(v159, 0x10u), _mm_slli_epi32(v159, 0x10u));
  v161 = _mm_add_epi32(_mm_shuffle_epi32(v155, 78), v160);
  v162 = _mm_xor_si128(v157, v161);
  v163 = _mm_xor_si128(_mm_srli_epi32(v162, 0xCu), _mm_slli_epi32(v162, 0x14u));
  v164 = _mm_add_epi32(
           _mm_add_epi32(
             v158,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v257), _mm_cvtsi32_si128(v258)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v264), _mm_cvtsi32_si128(v263)))),
           v163);
  v165 = _mm_xor_si128(v160, v164);
  v166 = _mm_xor_si128(_mm_srli_epi32(v165, 8u), _mm_slli_epi32(v165, 0x18u));
  v167 = _mm_add_epi32(v161, v166);
  v168 = _mm_xor_si128(v163, v167);
  v169 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v168, 7u), _mm_slli_epi32(v168, 0x19u)), 57);
  v170 = _mm_add_epi32(
           _mm_add_epi32(
             v164,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v260)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), _mm_cvtsi32_si128(v256)))),
           v169);
  v171 = _mm_xor_si128(_mm_shuffle_epi32(v166, 147), v170);
  v172 = _mm_xor_si128(_mm_srli_epi32(v171, 0x10u), _mm_slli_epi32(v171, 0x10u));
  v173 = _mm_add_epi32(_mm_shuffle_epi32(v167, 78), v172);
  v174 = _mm_xor_si128(v169, v173);
  v175 = _mm_xor_si128(_mm_srli_epi32(v174, 0xCu), _mm_slli_epi32(v174, 0x14u));
  v176 = _mm_add_epi32(
           _mm_add_epi32(
             v170,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v255), _mm_cvtsi32_si128(v6)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v259), _mm_cvtsi32_si128(v25)))),
           v175);
  v177 = _mm_xor_si128(v172, v176);
  v178 = _mm_xor_si128(_mm_srli_epi32(v177, 8u), _mm_slli_epi32(v177, 0x18u));
  v179 = _mm_add_epi32(v173, v178);
  v180 = _mm_xor_si128(v175, v179);
  v181 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v180, 7u), _mm_slli_epi32(v180, 0x19u)), 147);
  v182 = _mm_add_epi32(
           _mm_add_epi32(
             v176,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v258), _mm_cvtsi32_si128(v261)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v255), _mm_cvtsi32_si128(v259)))),
           v181);
  v183 = _mm_xor_si128(_mm_shuffle_epi32(v178, 57), v182);
  v184 = _mm_xor_si128(_mm_srli_epi32(v183, 0x10u), _mm_slli_epi32(v183, 0x10u));
  v185 = _mm_add_epi32(_mm_shuffle_epi32(v179, 78), v184);
  v186 = _mm_xor_si128(v181, v185);
  v187 = _mm_xor_si128(_mm_srli_epi32(v186, 0xCu), _mm_slli_epi32(v186, 0x14u));
  v188 = _mm_add_epi32(
           _mm_add_epi32(
             v182,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v25), _mm_cvtsi32_si128(v254)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v262), _mm_cvtsi32_si128(v260)))),
           v187);
  v189 = _mm_xor_si128(v184, v188);
  v190 = _mm_xor_si128(_mm_srli_epi32(v189, 8u), _mm_slli_epi32(v189, 0x18u));
  v191 = _mm_add_epi32(v185, v190);
  v192 = _mm_xor_si128(v187, v191);
  v193 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v192, 7u), _mm_slli_epi32(v192, 0x19u)), 57);
  v194 = _mm_add_epi32(
           _mm_add_epi32(
             v188,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v257), _mm_cvtsi32_si128(v256)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v264), _mm_cvtsi32_si128(v6)))),
           v193);
  v195 = _mm_xor_si128(_mm_shuffle_epi32(v190, 147), v194);
  v196 = _mm_xor_si128(_mm_srli_epi32(v195, 0x10u), _mm_slli_epi32(v195, 0x10u));
  v197 = _mm_add_epi32(_mm_shuffle_epi32(v191, 78), v196);
  v198 = _mm_xor_si128(v193, v197);
  v199 = _mm_xor_si128(_mm_srli_epi32(v198, 0xCu), _mm_slli_epi32(v198, 0x14u));
  v200 = _mm_add_epi32(
           _mm_add_epi32(
             v194,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v3)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v4), _mm_cvtsi32_si128(v263)))),
           v199);
  v201 = _mm_xor_si128(v196, v200);
  v202 = _mm_xor_si128(_mm_srli_epi32(v201, 8u), _mm_slli_epi32(v201, 0x18u));
  v203 = _mm_add_epi32(v197, v202);
  v204 = _mm_xor_si128(v199, v203);
  v205 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v204, 7u), _mm_slli_epi32(v204, 0x19u)), 147);
  v206 = _mm_add_epi32(
           _mm_add_epi32(
             v200,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), _mm_cvtsi32_si128(v25)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v262), _mm_cvtsi32_si128(v7)))),
           v205);
  v207 = _mm_xor_si128(_mm_shuffle_epi32(v202, 57), v206);
  v208 = _mm_xor_si128(_mm_srli_epi32(v207, 0x10u), _mm_slli_epi32(v207, 0x10u));
  v209 = _mm_add_epi32(_mm_shuffle_epi32(v203, 78), v208);
  v210 = _mm_xor_si128(v205, v209);
  v211 = _mm_xor_si128(_mm_srli_epi32(v210, 0xCu), _mm_slli_epi32(v210, 0x14u));
  v212 = _mm_add_epi32(
           _mm_add_epi32(
             v206,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v264), _mm_cvtsi32_si128(v259)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v260), _mm_cvtsi32_si128(v256)))),
           v211);
  v213 = _mm_xor_si128(v208, v212);
  v214 = _mm_xor_si128(_mm_srli_epi32(v213, 8u), _mm_slli_epi32(v213, 0x18u));
  v215 = _mm_add_epi32(v209, v214);
  v216 = _mm_xor_si128(v211, v215);
  v217 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v216, 7u), _mm_slli_epi32(v216, 0x19u)), 57);
  v218 = _mm_add_epi32(
           _mm_add_epi32(
             v212,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v261), _mm_cvtsi32_si128(v254)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v258), _mm_cvtsi32_si128(v263)))),
           v217);
  v219 = _mm_xor_si128(_mm_shuffle_epi32(v214, 147), v218);
  v220 = _mm_xor_si128(_mm_srli_epi32(v219, 0x10u), _mm_slli_epi32(v219, 0x10u));
  v221 = _mm_add_epi32(_mm_shuffle_epi32(v215, 78), v220);
  v222 = _mm_xor_si128(v217, v221);
  v223 = _mm_xor_si128(_mm_srli_epi32(v222, 0xCu), _mm_slli_epi32(v222, 0x14u));
  v224 = _mm_add_epi32(
           _mm_add_epi32(
             v218,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v6), _mm_cvtsi32_si128(v4)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v255), _mm_cvtsi32_si128(v257)))),
           v223);
  v225 = _mm_xor_si128(v220, v224);
  v226 = _mm_xor_si128(_mm_srli_epi32(v225, 8u), _mm_slli_epi32(v225, 0x18u));
  v227 = _mm_add_epi32(v221, v226);
  v228 = _mm_xor_si128(v223, v227);
  v229 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v228, 7u), _mm_slli_epi32(v228, 0x19u)), 147);
  v230 = _mm_add_epi32(
           _mm_add_epi32(
             v224,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v263), _mm_cvtsi32_si128(v255)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v256), _mm_cvtsi32_si128(v254)))),
           v229);
  v231 = _mm_xor_si128(_mm_shuffle_epi32(v226, 57), v230);
  v232 = _mm_xor_si128(_mm_srli_epi32(v231, 0x10u), _mm_slli_epi32(v231, 0x10u));
  v233 = _mm_add_epi32(_mm_shuffle_epi32(v227, 78), v232);
  v234 = _mm_xor_si128(v229, v233);
  v235 = _mm_xor_si128(_mm_srli_epi32(v234, 0xCu), _mm_slli_epi32(v234, 0x14u));
  v236 = _mm_add_epi32(
           _mm_add_epi32(
             v230,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v6), _mm_cvtsi32_si128(v3)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v4), _mm_cvtsi32_si128(v257)))),
           v235);
  v237 = _mm_xor_si128(v232, v236);
  v238 = _mm_xor_si128(_mm_srli_epi32(v237, 8u), _mm_slli_epi32(v237, 0x18u));
  v239 = _mm_add_epi32(v233, v238);
  v240 = _mm_xor_si128(v235, v239);
  v241 = _mm_shuffle_epi32(_mm_xor_si128(_mm_srli_epi32(v240, 7u), _mm_slli_epi32(v240, 0x19u)), 57);
  v242 = _mm_add_epi32(
           _mm_add_epi32(
             v236,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v264), _mm_cvtsi32_si128(v259)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v260), _mm_cvtsi32_si128(v258)))),
           v241);
  v243 = _mm_xor_si128(_mm_shuffle_epi32(v238, 147), v242);
  v244 = _mm_xor_si128(_mm_srli_epi32(v243, 0x10u), _mm_slli_epi32(v243, 0x10u));
  v245 = _mm_add_epi32(_mm_shuffle_epi32(v239, 78), v244);
  v246 = _mm_xor_si128(v241, v245);
  v247 = _mm_xor_si128(_mm_srli_epi32(v246, 0xCu), _mm_slli_epi32(v246, 0x14u));
  v248 = _mm_add_epi32(
           _mm_add_epi32(
             v242,
             _mm_unpacklo_epi32(
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v25), _mm_cvtsi32_si128(v261)),
               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v262), _mm_cvtsi32_si128(v7)))),
           v247);
  v249 = _mm_xor_si128(v244, v248);
  v250 = _mm_xor_si128(_mm_srli_epi32(v249, 8u), _mm_slli_epi32(v249, 0x18u));
  v251 = _mm_add_epi32(v245, v250);
  v252 = _mm_xor_si128(v247, v251);
  *(__m128i *)*(_DWORD *)(a1 + 244) = _mm_xor_si128(
                                        _mm_load_si128(&v265),
                                        _mm_xor_si128(v248, _mm_shuffle_epi32(v251, 78)));
  *(__m128i *)(*(_DWORD *)(a1 + 244) + 16) = _mm_xor_si128(
                                               _mm_load_si128(&v266),
                                               _mm_xor_si128(
                                                 _mm_shuffle_epi32(
                                                   _mm_xor_si128(_mm_srli_epi32(v252, 7u), _mm_slli_epi32(v252, 0x19u)),
                                                   147),
                                                 _mm_shuffle_epi32(v250, 57)));
  return 0;
}
// 430580: using guessed type __int128 xmmword_430580;
// 430590: using guessed type __int128 xmmword_430590;

//----- (0040489F) --------------------------------------------------------
void *__thiscall sub_40489F(void *this)
{
  void *result; // eax

  result = memset(this, 0, 0xF0u);
  *((_DWORD *)this + 64) = 0;
  *((_BYTE *)this + 260) = 0;
  return result;
}

//----- (004048C2) --------------------------------------------------------
int __userpurge sub_4048C2@<eax>(void *a1@<ecx>, int a2@<eax>, int a3)
{
  int i; // eax
  int result; // eax

  if ( dword_44EA38 >= 2 )
    sub_40374F();
  sub_40489F(a1);
  for ( i = 0; i < 8; ++i )
    *(_DWORD *)(i * 4 + *((_DWORD *)a1 + 61)) = SHA256_Constants_42A478[i];
  **((_DWORD **)a1 + 61) ^= 0x2080020u;
  result = *((_DWORD *)a1 + 61);
  *(_DWORD *)(result + 8) ^= a3;
  *(_DWORD *)(*((_DWORD *)a1 + 61) + 12) ^= (a2 | 0x2000) << 16;
  return result;
}
// 42A478: using guessed type int SHA256_Constants_42A478[];
// 44EA38: using guessed type int dword_44EA38;

//----- (00404926) --------------------------------------------------------
int *__userpurge sub_404926@<eax>(const void *a1@<eax>, int a2)
{
  int *v3; // eax
  int v4; // ecx
  int v5; // esi
  _DWORD *v6; // eax
  int v7; // edx
  int v8; // ecx
  unsigned int v9; // esi
  unsigned int v10; // eax
  int v11; // ebx
  int v12; // edi
  int v13; // edx
  int v14; // ecx
  int v15; // ebx
  int v16; // edx
  int v17; // esi
  int v18; // ecx
  int v19; // edx
  int v20; // edx
  int v21; // esi
  int v22; // edx
  int v23; // esi
  int v24; // edx
  int v25; // edx
  int v26; // edi
  int v27; // edx
  int v28; // esi
  int v29; // edx
  int v30; // edx
  int v31; // edi
  int v32; // esi
  int v33; // edx
  int v34; // esi
  int v35; // edi
  int v36; // edx
  int v37; // esi
  int v38; // edx
  int v39; // edi
  int v40; // edx
  int v41; // ecx
  int v42; // edx
  unsigned int i; // ecx
  int *result; // eax
  int v45; // edx
  int v46[16]; // [esp+Ch] [ebp-80h] BYREF
  int v47[8]; // [esp+4Ch] [ebp-40h] BYREF
  int v48; // [esp+6Ch] [ebp-20h]
  int v49; // [esp+70h] [ebp-1Ch]
  int v50; // [esp+74h] [ebp-18h]
  int v51; // [esp+78h] [ebp-14h]
  int v52; // [esp+7Ch] [ebp-10h]
  unsigned int v53; // [esp+80h] [ebp-Ch]
  int v54; // [esp+84h] [ebp-8h]
  int v55; // [esp+88h] [ebp-4h]

  v3 = *(int **)(a2 + 248);
  qmemcpy(v46, a1, sizeof(v46));
  qmemcpy(v47, *(const void **)(a2 + 244), sizeof(v47));
  v4 = *v3;
  v5 = v3[1];
  v6 = *(_DWORD **)(a2 + 252);
  v7 = *v6 ^ 0x1F83D9AB;
  v8 = v4 ^ 0x510E527F;
  v9 = v5 ^ 0x9B05688C;
  v55 = v6[1] ^ 0x5BE0CD19;
  v48 = 1779033703;
  v49 = -1150833019;
  v50 = 1013904242;
  v51 = -1521486534;
  v54 = v7;
  v10 = 0;
  while ( 1 )
  {
    v11 = v47[4] + v46[(unsigned __int8)byte_42A498[v10]] + v47[0];
    v12 = v46[(unsigned __int8)byte_42A499[v10]];
    v13 = __ROR4__(v8 ^ v11, 16);
    v48 += v13;
    v14 = __ROR4__(v48 ^ v47[4], 12);
    v47[0] = v14 + v12 + v11;
    v15 = __ROR4__(v13 ^ v47[0], 8);
    v47[1] += v47[5] + v46[(unsigned __int8)byte_42A49A[v10]];
    v48 += v15;
    v16 = v9 ^ v47[1];
    v17 = v46[(unsigned __int8)byte_42A49B[v10]];
    v18 = __ROR4__(v48 ^ v14, 7);
    v19 = __ROR4__(v16, 16);
    v49 += v19;
    v53 = v19;
    v20 = __ROR4__(v49 ^ v47[5], 12);
    v47[1] += v20 + v17;
    v21 = __ROR4__(v53 ^ v47[1], 8);
    v49 += v21;
    v53 = v21;
    v47[5] = __ROR4__(v49 ^ v20, 7);
    v47[2] += v47[6] + v46[(unsigned __int8)byte_42A49C[v10]];
    v22 = __ROR4__(v54 ^ v47[2], 16);
    v50 += v22;
    v54 = v22;
    v23 = __ROR4__(v50 ^ v47[6], 12);
    v47[2] += v23 + v46[(unsigned __int8)byte_42A49D[v10]];
    v24 = __ROR4__(v22 ^ v47[2], 8);
    v50 += v24;
    v54 = v24;
    v47[3] += v47[7] + v46[(unsigned __int8)byte_42A49E[v10]];
    v25 = __ROR4__(v55 ^ v47[3], 16);
    v51 += v25;
    v47[6] = __ROR4__(v50 ^ v23, 7);
    v55 = v25;
    v26 = __ROR4__(v51 ^ v47[7], 12);
    v47[3] += v26 + v46[(unsigned __int8)byte_42A49F[v10]];
    v27 = __ROR4__(v25 ^ v47[3], 8);
    v51 += v27;
    v55 = v27;
    v47[0] += v47[5] + v46[(unsigned __int8)byte_42A4A0[v10]];
    v28 = __ROR4__(v27 ^ v47[0], 16);
    v50 += v28;
    v47[7] = __ROR4__(v51 ^ v26, 7);
    v29 = __ROR4__(v50 ^ v47[5], 12);
    v47[0] += v29 + v46[(unsigned __int8)byte_42A4A1[v10]];
    v47[5] = v29;
    v30 = __ROR4__(v28 ^ v47[0], 8);
    v50 += v30;
    v55 = v30;
    v31 = v46[(unsigned __int8)byte_42A4A3[v10]];
    v47[5] = __ROR4__(v50 ^ v47[5], 7);
    v47[1] += v47[6] + v46[(unsigned __int8)byte_42A4A2[v10]];
    v32 = __ROR4__(v15 ^ v47[1], 16);
    v51 += v32;
    v33 = __ROR4__(v51 ^ v47[6], 12);
    v47[1] += v33 + v31;
    v34 = __ROR4__(v32 ^ v47[1], 8);
    v51 += v34;
    v35 = v46[(unsigned __int8)byte_42A4A5[v10]];
    v47[6] = __ROR4__(v51 ^ v33, 7);
    v36 = (unsigned __int8)byte_42A4A4[v10];
    v52 = v34;
    v47[2] += v47[7] + v46[v36];
    v37 = __ROR4__(v53 ^ v47[2], 16);
    v48 += v37;
    v38 = __ROR4__(v48 ^ v47[7], 12);
    v47[2] += v38 + v35;
    v9 = __ROR4__(v37 ^ v47[2], 8);
    v48 += v9;
    v39 = v46[(unsigned __int8)byte_42A4A7[v10]];
    v47[7] = __ROR4__(v48 ^ v38, 7);
    v47[3] += v18 + v46[(unsigned __int8)byte_42A4A6[v10]];
    v10 += 16;
    v40 = __ROR4__(v54 ^ v47[3], 16);
    v49 += v40;
    v53 = v9;
    v41 = __ROR4__(v49 ^ v18, 12);
    v47[3] += v41 + v39;
    v42 = __ROR4__(v40 ^ v47[3], 8);
    v49 += v42;
    v54 = v42;
    v47[4] = __ROR4__(v49 ^ v41, 7);
    if ( v10 > 0x90 )
      break;
    v8 = v52;
  }
  for ( i = 0; i < 8; *result = v46[i + 15] ^ v45 )
  {
    result = (int *)(i * 4 + *(_DWORD *)(a2 + 244));
    v45 = *result ^ *(int *)((char *)&v48 + i * 4);
    ++i;
  }
  return result;
}

//----- (00404C47) --------------------------------------------------------
void __userpurge sub_404C47(int a1@<esi>, char *Src, size_t Size)
{
  size_t v3; // ebx
  int v4; // eax
  int v5; // edi
  void *v6; // ecx

  v3 = Size;
  while ( v3 )
  {
    v4 = *(_DWORD *)(a1 + 256);
    v5 = 128 - v4;
    v6 = (void *)(v4 + *(_DWORD *)(a1 + 240));
    if ( v3 <= 128 - v4 )
    {
      memcpy(v6, Src, v3);
      *(_DWORD *)(a1 + 256) += v3;
      Src += v3;
      v3 = 0;
    }
    else
    {
      memcpy(v6, Src, 128 - v4);
      *(_DWORD *)(a1 + 256) += v5;
      **(_DWORD **)(a1 + 248) += 64;
      *(_DWORD *)(*(_DWORD *)(a1 + 248) + 4) += **(_DWORD **)(a1 + 248) < 0x40u;
      if ( dword_44EA38 < 2 )
        sub_404926(*(const void **)(a1 + 240), a1);
      else
        sub_4037C2(a1, *(unsigned int **)(a1 + 240));
      memcpy(*(void **)(a1 + 240), (const void *)(*(_DWORD *)(a1 + 240) + 64), 0x40u);
      *(_DWORD *)(a1 + 256) -= 64;
      Src += v5;
      v3 -= v5;
    }
  }
}
// 44EA38: using guessed type int dword_44EA38;

//----- (00404D06) --------------------------------------------------------
int __userpurge sub_404D06@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // ecx
  int result; // eax

  if ( *(_DWORD *)(a1 + 256) > 0x40u )
  {
    **(_DWORD **)(a1 + 248) += 64;
    *(_DWORD *)(*(_DWORD *)(a1 + 248) + 4) += **(_DWORD **)(a1 + 248) < 0x40u;
    sub_404926(*(const void **)(a1 + 240), a1);
    *(_DWORD *)(a1 + 256) -= 64;
    memcpy(*(void **)(a1 + 240), (const void *)(*(_DWORD *)(a1 + 240) + 64), *(_DWORD *)(a1 + 256));
  }
  v2 = *(_DWORD *)(a1 + 256);
  **(_DWORD **)(a1 + 248) += v2;
  *(_DWORD *)(*(_DWORD *)(a1 + 248) + 4) += **(_DWORD **)(a1 + 248) < v2;
  if ( *(_BYTE *)(a1 + 260) )
    *(_DWORD *)(*(_DWORD *)(a1 + 252) + 4) = -1;
  **(_DWORD **)(a1 + 252) = -1;
  memset((void *)(*(_DWORD *)(a1 + 256) + *(_DWORD *)(a1 + 240)), 0, 128 - *(_DWORD *)(a1 + 256));
  sub_404926(*(const void **)(a1 + 240), a1);
  for ( result = 0; result < 32; result += 4 )
    *(_DWORD *)(result + a2) = *(_DWORD *)(result + *(_DWORD *)(a1 + 244));
  return result;
}

//----- (00404DD4) --------------------------------------------------------
int __stdcall sub_404DD4(char *a1)
{
  unsigned int v1; // edi
  char *v2; // ebx
  int result; // eax

  v1 = 0;
  memset(a1 + 2376, 0, 0x200u);
  *((_DWORD *)a1 + 722) = 0;
  sub_4048C2(a1 + 2112, 1, 0);
  v2 = a1;
  do
  {
    result = sub_4048C2(v2, 0, v1++);
    v2 += 264;
  }
  while ( v1 < 8 );
  a1[2372] = 1;
  a1[2108] = 1;
  return result;
}

//----- (00404E33) --------------------------------------------------------
void __thiscall sub_404E33(int *this)
{
  unsigned int v2; // ebp
  int v3; // eax
  int v4; // [esp+Ch] [ebp-4h]

  v2 = this[2];
  v3 = this[1];
  v4 = v3;
  if ( v2 >= 0x200 )
  {
    while ( 1 )
    {
      if ( dword_44EA38 >= 1 && v2 >= 0x400 )
        _mm_prefetch((const char *)(v3 + 512), 1);
      sub_404C47(*this, (char *)v3, 0x40u);
      v4 += 512;
      v2 -= 512;
      if ( v2 < 0x200 )
        break;
      v3 = v4;
    }
  }
}
// 44EA38: using guessed type int dword_44EA38;

//----- (00404E85) --------------------------------------------------------
void __stdcall sub_404E85(int *a1)
{
  sub_404E33(a1);
}

//----- (00404E91) --------------------------------------------------------
void *__stdcall sub_404E91(char *a1, char *Src, unsigned int a3)
{
  int v4; // esi
  unsigned int v5; // edi
  char *v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // eax
  char *v9; // esi
  char *v10; // eax
  int *v11; // edi
  int v12; // ecx
  int v13; // edi
  void *result; // eax
  char v15; // [esp+Ch] [ebp-70h] BYREF
  unsigned int v16; // [esp+6Ch] [ebp-10h]
  char *j; // [esp+70h] [ebp-Ch]
  unsigned int i; // [esp+74h] [ebp-8h]
  int v19; // [esp+78h] [ebp-4h]
  char *v20; // [esp+84h] [ebp+8h]
  unsigned int v21; // [esp+84h] [ebp+8h]
  char *Srca; // [esp+88h] [ebp+Ch]

  v4 = *((_DWORD *)a1 + 722);
  v5 = 512 - v4;
  v19 = v4;
  if ( v4 && a3 >= v5 )
  {
    memcpy(&a1[v4 + 2376], Src, 512 - v4);
    v6 = a1;
    v20 = a1 + 2376;
    v16 = 8;
    do
    {
      sub_404C47((int)v6, v20, 0x40u);
      v20 += 64;
      v6 += 264;
      --v16;
    }
    while ( v16 );
    Src += v5;
    a3 -= v5;
    v19 = 0;
    v4 = 0;
  }
  if ( a3 >= 0x1000 )
  {
    v7 = *((_DWORD *)a1 + 724);
    v21 = v7;
    if ( v7 == 6 || v7 == 7 )
      v21 = 4;
  }
  else
  {
    v21 = 1;
  }
  v8 = 0;
  for ( i = 0; i < 8; v8 = i )
  {
    v16 = 0;
    if ( v21 )
    {
      v9 = &a1[264 * v8];
      v10 = &Src[64 * v8];
      v11 = (int *)&v15;
      for ( j = v10; i < 8; v10 = j )
      {
        v11[2] = a3;
        v11[1] = (int)v10;
        *v11 = (int)v9;
        if ( v21 <= 1 )
          sub_404E33(v11);
        else
          sub_410E83(*((_DWORD *)a1 + 723), (int)sub_404E85, (int)v11);
        ++i;
        j += 64;
        v9 += 264;
        ++v16;
        v11 += 3;
        if ( v16 >= v21 )
          break;
      }
      v4 = v19;
    }
    v12 = *((_DWORD *)a1 + 723);
    if ( v12 )
      sub_410C36(v12);
  }
  v13 = a3 & 0x1FF;
  result = (void *)(a3 - v13);
  Srca = &Src[a3 - v13];
  if ( (a3 & 0x1FF) != 0 )
    result = memcpy(&a1[v4 + 2376], Srca, a3 & 0x1FF);
  *((_DWORD *)a1 + 722) = v13 + v4;
  return result;
}

//----- (00404FF9) --------------------------------------------------------
int __stdcall sub_404FF9(char *Src, int a2)
{
  unsigned int v3; // ebx
  char *v4; // esi
  unsigned int v5; // eax
  size_t v6; // eax
  char *v7; // esi
  char *v8; // edi
  int v9; // ebx
  char v11[256]; // [esp+Ch] [ebp-104h] BYREF
  char *v12; // [esp+10Ch] [ebp-4h]
  char *Srca; // [esp+118h] [ebp+8h]

  v12 = v11;
  v3 = 0;
  v4 = Src;
  Srca = Src + 2376;
  do
  {
    v5 = *((_DWORD *)Src + 722);
    if ( v5 > v3 )
    {
      v6 = v5 - v3;
      if ( v6 > 0x40 )
        v6 = 64;
      sub_404C47((int)v4, Srca, v6);
    }
    sub_404D06((int)v4, (int)v12);
    Srca += 64;
    v12 += 32;
    v3 += 64;
    v4 += 264;
  }
  while ( v3 < 0x200 );
  v7 = Src + 2112;
  v8 = v11;
  v9 = 8;
  do
  {
    sub_404C47((int)v7, v8, 0x20u);
    v8 += 32;
    --v9;
  }
  while ( v9 );
  return sub_404D06((int)v7, a2);
}

//----- (00405088) --------------------------------------------------------
bool __stdcall sub_405088(HWND a1, const WCHAR *a2, LPWSTR pszPath)
{
  const ITEMIDLIST *v4; // eax
  ITEMIDLIST *v5; // esi
  BOOL v6; // edi
  char v7; // [esp+0h] [ebp-22Ch] BYREF
  struct _browseinfoW bi; // [esp+208h] [ebp-24h] BYREF
  IMalloc *ppMalloc; // [esp+228h] [ebp-4h] BYREF

  if ( SHGetMalloc(&ppMalloc) )
    return 0;
  bi.pidlRoot = 0;
  bi.lpfn = 0;
  bi.lParam = 0;
  bi.hwndOwner = a1;
  bi.pszDisplayName = (LPWSTR)&v7;
  bi.lpszTitle = a2;
  bi.ulFlags = 65;
  v4 = SHBrowseForFolderW(&bi);
  v5 = (ITEMIDLIST *)v4;
  if ( !v4 )
    return 0;
  v6 = SHGetPathFromIDListW(v4, pszPath);
  ppMalloc->lpVtbl->Free(ppMalloc, v5);
  return v6;
}

//----- (00405104) --------------------------------------------------------
bool __stdcall sub_405104(HWND a1, const WCHAR *a2, WCHAR *a3, wchar_t *Source, char a5)
{
  wchar_t *v5; // esi
  wchar_t *v6; // esi
  WCHAR *v7; // eax
  wchar_t *v8; // esi
  BOOL SaveFileNameW; // eax
  BOOL v10; // edi
  bool v11; // zf
  BOOL OpenFileNameW; // eax
  wchar_t String[512]; // [esp+Ch] [ebp-458h] BYREF
  struct tagOFNW v15; // [esp+40Ch] [ebp-58h] BYREF

  v5 = String;
  if ( Source )
  {
    wcscpy(String, Source);
    v6 = &String[wcslen(String) + 1];
    wcscpy(v6, Source);
    v5 = &v6[wcslen(v6) + 1];
  }
  v7 = sub_40C05C(0xA2u);
  wcscpy(v5, v7);
  v8 = &v5[wcslen(v5) + 1];
  wcscpy(v8, ::Source);
  v8[wcslen(v8) + 1] = 0;
  memset(&v15, 0, sizeof(v15));
  v15.hwndOwner = a1;
  v15.hInstance = hInstance;
  v15.lpstrFilter = String;
  v15.lStructSize = 88;
  v15.lpstrTitle = a2;
  v15.lpstrFile = a3;
  v15.nMaxFile = 2048;
  v15.Flags = 67596;
  if ( a5 )
    SaveFileNameW = GetSaveFileNameW(&v15);
  else
    SaveFileNameW = GetOpenFileNameW(&v15);
  v10 = SaveFileNameW;
  v11 = !SaveFileNameW;
  if ( !SaveFileNameW )
  {
    if ( CommDlgExtendedError() == 12290 )
    {
      *a3 = 0;
      if ( a5 )
        OpenFileNameW = GetSaveFileNameW(&v15);
      else
        OpenFileNameW = GetOpenFileNameW(&v15);
      v10 = OpenFileNameW;
    }
    v11 = !v10;
  }
  return !v11;
}

//----- (00405218) --------------------------------------------------------
char __stdcall sub_405218(wchar_t *a1, char a2, wchar_t *Source, int a4, int a5)
{
  wchar_t *v5; // edi
  bool v6; // al
  wchar_t *v7; // eax
  wchar_t *v8; // edi
  wchar_t *v9; // eax
  char result; // al
  __int16 v11[2]; // [esp+8h] [ebp-2008h] BYREF
  wchar_t v12[2048]; // [esp+Ch] [ebp-2004h] BYREF
  wchar_t Destination[2050]; // [esp+100Ch] [ebp-1004h] BYREF
  wchar_t *Sourcea; // [esp+2020h] [ebp+10h]

  Sourcea = sub_40A10B(Source, 0);
  sub_4108E4(a1);
  while ( 1 )
  {
    result = sub_410990(a1, Destination, 2048);
    if ( !result )
      return result;
    v5 = sub_409D8B(Destination);
    v6 = sub_409DC6(*v5);
    if ( !a2 )
    {
      if ( v6 )
        wcscat(Destination, ::Source);
      goto LABEL_9;
    }
    if ( v6 )
    {
      *v5 = 0;
LABEL_9:
      v8 = Sourcea;
      if ( Destination[0] == 42 )
      {
        if ( sub_409DC6(Destination[1]) )
        {
          v11[0] = 46;
          v11[1] = 92;
          sub_41078F(v12, Sourcea, 2048);
          v8 = (wchar_t *)v11;
        }
      }
      v9 = sub_40A10B(Destination, 0);
      if ( sub_409AF8(v9, v8, a5) )
        return 1;
    }
    else
    {
      v7 = sub_40A0CE(Destination);
      if ( !sub_409DA5(v7) )
        goto LABEL_9;
    }
  }
}
// 405218: using guessed type wchar_t var_2004[2048];

//----- (00405321) --------------------------------------------------------
wchar_t *__thiscall sub_405321(_DWORD *this, wchar_t *a2)
{
  return sub_4108FF(this + 9466, a2);
}

//----- (0040532C) --------------------------------------------------------
char __thiscall sub_40532C(wchar_t *this, wchar_t *a2, int a3)
{
  return sub_410990(this + 18932, a2, a3);
}

//----- (0040533C) --------------------------------------------------------
void __thiscall sub_40533C(int this)
{
  sub_409C86((void *)this);
  *(_WORD *)(this + 29362) = 0;
  *(_WORD *)(this + 33490) = 0;
  *(_BYTE *)(this + 29352) = 0;
  *(_BYTE *)(this + 29353) = 0;
  *(_DWORD *)(this + 29356) = 0;
  *(_BYTE *)(this + 29360) = 0;
  sub_4108E9((_DWORD *)(this + 37588));
  sub_4108E9((_DWORD *)(this + 37680));
  sub_4108E9((_DWORD *)(this + 37772));
  sub_4108E9((_DWORD *)(this + 37956));
  sub_4108E9((_DWORD *)(this + 37864));
  sub_412595(this + 20840);
}

//----- (004053AF) --------------------------------------------------------
bool __thiscall sub_4053AF(int this, wchar_t *Source, char a3, int a4, char a5)
{
  if ( sub_405218((wchar_t *)(this + 37680), a3, Source, a4, 5) )
    return 1;
  if ( a5 && *(_DWORD *)(this + 37792) )
    return sub_405218((wchar_t *)(this + 37772), a3, Source, 0, 5) == 0;
  return 0;
}

//----- (00405409) --------------------------------------------------------
int __thiscall sub_405409(wchar_t *this, int a2, bool *a3, int a4)
{
  WCHAR *v4; // ebx
  wchar_t *v6; // esi
  wchar_t *v7; // eax
  const WCHAR *v8; // edi
  int i; // [esp+14h] [ebp+8h]

  v4 = (WCHAR *)(a2 + 32);
  if ( wcslen((const wchar_t *)(a2 + 32)) < 0x800 && !sub_4053AF((int)this, v4, *(_BYTE *)(a2 + 4321), 0, 1) )
  {
    v6 = this + 18794;
    sub_4108E4(v6);
    for ( i = 1; ; ++i )
    {
      v7 = (wchar_t *)sub_4109B5(v6);
      v8 = v7;
      if ( !v7 )
        break;
      if ( sub_409AF8(v7, v4, a4) )
      {
        if ( a3 )
          *a3 = sub_41078A(v8, v4) == 0;
        return i;
      }
    }
  }
  return 0;
}
// 405409: using guessed type int arg_0;

//----- (00405497) --------------------------------------------------------
_DWORD *__thiscall sub_405497(_DWORD *this)
{
  sub_409D27((int)this);
  sub_410977(this + 9397);
  sub_410977(this + 9420);
  sub_410977(this + 9443);
  sub_410977(this + 9466);
  sub_410977(this + 9489);
  sub_40533C((int)this);
  return this;
}

//----- (00405512) --------------------------------------------------------
unsigned int __stdcall sub_405512(int a1)
{
  unsigned int result; // eax
  unsigned int v2; // ecx
  int v3; // esi

  result = 0;
  if ( !*(_DWORD *)(a1 + 4) )
  {
    do
    {
      v2 = result;
      v3 = 8;
      do
      {
        if ( (v2 & 1) != 0 )
          v2 = (v2 >> 1) ^ 0xEDB88320;
        else
          v2 >>= 1;
        --v3;
      }
      while ( v3 );
      *(_DWORD *)(a1 + 4 * result++) = v2;
    }
    while ( result < 0x100 );
  }
  return result;
}

//----- (00405595) --------------------------------------------------------
unsigned int __stdcall sub_405595(unsigned int a1, _DWORD *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int v6; // eax
  int v7; // edi
  bool v8; // zf
  unsigned int v9; // [esp+10h] [ebp+8h]

  result = a1;
  while ( a3 && ((unsigned __int8)a2 & 7) != 0 )
  {
    result = dword_4305A0[(unsigned __int8)result ^ *(unsigned __int8 *)a2] ^ (result >> 8);
    --a3;
    a2 = (_DWORD *)((char *)a2 + 1);
  }
  if ( a3 >= 8 )
  {
    v9 = a3 >> 3;
    do
    {
      v6 = *a2 ^ result;
      v7 = dword_4321A0[(unsigned __int8)v6] ^ dword_4311A0[(unsigned __int8)a2[1]] ^ dword_431DA0[BYTE1(v6)] ^ dword_4319A0[BYTE2(v6)] ^ dword_4315A0[HIBYTE(v6)] ^ dword_430DA0[(unsigned __int8)BYTE1(a2[1])] ^ dword_4305A0[HIBYTE(a2[1])] ^ dword_4309A0[(unsigned __int8)BYTE2(a2[1])];
      a3 -= 8;
      a2 += 2;
      v8 = v9-- == 1;
      result = v7;
    }
    while ( !v8 );
  }
  while ( a3 )
  {
    result = dword_4305A0[(unsigned __int8)result ^ *(unsigned __int8 *)a2] ^ (result >> 8);
    --a3;
    a2 = (_DWORD *)((char *)a2 + 1);
  }
  return result;
}
// 4305A0: using guessed type int dword_4305A0[256];
// 4309A0: using guessed type int dword_4309A0[256];
// 430DA0: using guessed type int dword_430DA0[256];
// 4311A0: using guessed type int dword_4311A0[256];
// 4315A0: using guessed type int dword_4315A0[256];
// 4319A0: using guessed type int dword_4319A0[256];
// 431DA0: using guessed type int dword_431DA0[256];
// 4321A0: using guessed type int dword_4321A0[256];

//----- (0040566F) --------------------------------------------------------
_BYTE *__thiscall sub_40566F(_BYTE *this)
{
  _BYTE *v2; // edi

  v2 = this + 32;
  sub_40CD6F(this + 32);
  sub_40CCBC(v2, (wchar_t *)&String);
  return this;
}

//----- (004056AB) --------------------------------------------------------
int __thiscall sub_4056AB(_BYTE *this)
{
  _BYTE *v1; // esi

  v1 = this;
  sub_40CC38(this, 16);
  sub_40CC38(v1 + 16, 16);
  v1 += 32;
  sub_40CC38(v1, 258);
  return sub_40CD93(v1);
}
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);

//----- (004056F9) --------------------------------------------------------
_BYTE *__thiscall sub_4056F9(bool *this, int a2, void *a3, wchar_t *String, void *Buf2)
{
  int v5; // esi
  unsigned int i; // edi
  bool v7; // zf
  unsigned int v8; // ebx
  int k; // eax
  unsigned int v10; // edi
  char *v11; // esi
  int m; // ecx
  unsigned int v13; // edx
  int v14; // edx
  int v15; // eax
  int v17; // esi
  int v18[39]; // [esp+Ch] [ebp-228h] BYREF
  char v19[264]; // [esp+A8h] [ebp-18Ch] BYREF
  int v20[39]; // [esp+1B0h] [ebp-84h] BYREF
  int v21[5]; // [esp+24Ch] [ebp+18h] BYREF
  int v22[4]; // [esp+260h] [ebp+2Ch] BYREF
  char v23; // [esp+270h] [ebp+3Ch]
  _BYTE Val[16]; // [esp+274h] [ebp+40h] BYREF
  _BYTE Src[16]; // [esp+284h] [ebp+50h] BYREF
  bool *v26; // [esp+294h] [ebp+60h]
  int j; // [esp+298h] [ebp+64h]

  v5 = 0;
  v26 = this;
  for ( i = 0; i < 0x4B0; i += 300 )
  {
    if ( !(unsigned __int8)sub_40CD07((char *)&unk_4325D0 + i, a3) )
      goto LABEL_8;
    if ( Buf2 )
    {
      if ( !byte_4326D2[i] )
        goto LABEL_8;
      v7 = memcmp((char *)&unk_4326D3 + i, Buf2, 8u) == 0;
    }
    else
    {
      v7 = byte_4326D2[i] == 0;
    }
    if ( v7 )
    {
      v17 = 300 * v5;
      memcpy(Src, (char *)&unk_4325B0 + v17, sizeof(Src));
      memcpy(Val, (char *)&unk_4325C0 + v17, sizeof(Val));
      goto LABEL_22;
    }
LABEL_8:
    ++v5;
  }
  sub_4116BD(String, (int)v19, 0x108u);
  v8 = 2 * wcslen(String);
  if ( Buf2 )
  {
    memcpy(&v19[v8], Buf2, 8u);
    v8 += 8;
  }
  sub_4100CB(v20);
  for ( j = 0; j < 0x40000; ++j )
  {
    sub_4100FC((unsigned int *)v20, v19, v8, 0);
    LOBYTE(String) = j;
    *(_WORD *)((char *)&String + 1) = *(_WORD *)((char *)&j + 1);
    sub_4100FC((unsigned int *)v20, (char *)&String, 3u, 0);
    if ( !(j % 0x4000) )
    {
      qmemcpy(v18, v20, sizeof(v18));
      sub_4101B0((int)v18, (int)v22, 0);
      Val[j / 0x4000] = v23;
    }
  }
  sub_4101B0((int)v20, (int)v21, 0);
  for ( k = 0; k < 4; ++k )
  {
    v10 = v21[k];
    v11 = &Src[k * 4];
    for ( m = 0; m < 32; m += 8 )
    {
      v13 = v10 >> m;
      *v11++ = v13;
    }
  }
  v14 = dword_4325A8;
  v15 = 300 * dword_4325A8;
  v7 = Buf2 == 0;
  qmemcpy((char *)&unk_4325D0 + 300 * dword_4325A8, a3, 0x102u);
  byte_4326D2[v15] = !v7;
  if ( !v7 )
  {
    memcpy((char *)&unk_4326D3 + v15, Buf2, 8u);
    v14 = dword_4325A8;
  }
  memcpy((char *)&unk_4325B0 + 300 * v14, Src, 0x10u);
  memcpy((char *)&unk_4325C0 + 300 * dword_4325A8, Val, 0x10u);
  dword_4325A8 = ((_BYTE)dword_4325A8 + 1) & 3;
  sub_40CC38(v19, 264);
LABEL_22:
  sub_40C6EF(v26 + 1512, a2, (int)Src, 128, (int)Val);
  sub_40CC38(Src, 16);
  return sub_40CC38(Val, 16);
}
// 4325A8: using guessed type int dword_4325A8;
// 4056F9: using guessed type char var_1F4[264];
// 4056F9: using guessed type int var_3C[4];
// 4056F9: using guessed type _BYTE Val[16];
// 4056F9: using guessed type _BYTE Src[16];

//----- (0040598C) --------------------------------------------------------
_BYTE *__stdcall sub_40598C(char *Src, size_t Size, char *a3, size_t a4, int a5)
{
  size_t v5; // esi
  size_t i; // ecx
  char *v7; // eax
  char v8; // dl
  size_t j; // ecx
  char *v10; // eax
  char v11; // dl
  int v13[28]; // [esp+8h] [ebp-1D0h] BYREF
  int v14[28]; // [esp+78h] [ebp-160h] BYREF
  int v15[28]; // [esp+E8h] [ebp-F0h] BYREF
  char v16[32]; // [esp+158h] [ebp-80h] BYREF
  char v17[32]; // [esp+178h] [ebp-60h] BYREF
  char v18[64]; // [esp+198h] [ebp-40h] BYREF

  v5 = Size;
  if ( Size > 0x40 )
  {
    sub_4102A1(v13);
    sub_4105A3(v13, Src, Size);
    sub_41061C((int)v13, (int)v16);
    Src = v16;
    v5 = 32;
  }
  for ( i = 0; i < v5; *v7 = v8 )
  {
    v7 = &v18[i];
    v8 = v18[i++ + Src - v18] ^ 0x36;
  }
  if ( v5 < 0x40 )
    memset(&v18[v5], 54, 64 - v5);
  sub_4102A1(v15);
  sub_4105A3(v15, v18, 0x40u);
  sub_4105A3(v15, a3, a4);
  sub_41061C((int)v15, (int)v17);
  sub_4102A1(v14);
  for ( j = 0; j < v5; *v10 = v11 )
  {
    v10 = &v18[j];
    v11 = v18[j++ + Src - v18] ^ 0x5C;
  }
  if ( v5 < 0x40 )
    memset(&v18[v5], 92, 64 - v5);
  sub_4105A3(v14, v18, 0x40u);
  sub_4105A3(v14, v17, 0x20u);
  return sub_41061C((int)v14, a5);
}
// 40598C: using guessed type char var_40[64];

//----- (00405AC9) --------------------------------------------------------
_BYTE *__stdcall sub_405AC9(char *a1, size_t Size, void *Src, unsigned int a4, void *a5, void *a6, void *a7, int a8)
{
  size_t v8; // eax
  unsigned int i; // edi
  unsigned int j; // eax
  _BYTE v12[32]; // [esp+8h] [ebp-64h] BYREF
  char v13[68]; // [esp+28h] [ebp-44h] BYREF
  char v14[32]; // [esp+6Ch] [ebp+0h] BYREF
  char v15[32]; // [esp+8Ch] [ebp+20h] BYREF
  void *v16[3]; // [esp+ACh] [ebp+40h]
  int v17[3]; // [esp+B8h] [ebp+4Ch]
  int v18; // [esp+D8h] [ebp+6Ch]

  v8 = 64;
  if ( a4 < 0x40 )
    v8 = a4;
  memcpy(v13, Src, v8);
  v13[a4] = 0;
  v13[a4 + 1] = 0;
  v13[a4 + 2] = 0;
  v13[a4 + 3] = 1;
  sub_40598C(a1, Size, v13, a4 + 4, (int)v15);
  memcpy(v14, v15, sizeof(v14));
  v17[0] = a8 - 1;
  v17[1] = 16;
  v17[2] = 16;
  v16[0] = a5;
  v16[1] = a6;
  v16[2] = a7;
  for ( i = 0; i < 3; ++i )
  {
    if ( v17[i] )
    {
      v18 = v17[i];
      do
      {
        sub_40598C(a1, Size, v15, 0x20u, (int)v12);
        memcpy(v15, v12, sizeof(v15));
        for ( j = 0; j < 0x20; ++j )
          v14[j] ^= v15[j];
        --v18;
      }
      while ( v18 );
    }
    memcpy(v16[i], v14, 0x20u);
  }
  sub_40CC38(v13, 68);
  sub_40CC38(v14, 32);
  sub_40CC38(v15, 32);
  return sub_40CC38(v12, 32);
}
// 405AC9: using guessed type char var_38[32];
// 405AC9: using guessed type char var_58[32];
// 405AC9: using guessed type _BYTE var_BC[32];

//----- (00405BE4) --------------------------------------------------------
void __thiscall sub_405BE4(
        _DWORD *this,
        int a2,
        void *a3,
        unsigned __int16 *a4,
        void *Buf2,
        int Val,
        unsigned int a7,
        void *a8,
        void *a9)
{
  _DWORD *v10; // ebx
  size_t v11; // eax
  bool *v12; // ebx
  unsigned int i; // ecx
  char Str[512]; // [esp+8h] [ebp-264h] BYREF
  int v15[8]; // [esp+208h] [ebp-64h] BYREF
  _BYTE v16[32]; // [esp+228h] [ebp-44h] BYREF
  char Src[32]; // [esp+248h] [ebp-24h] BYREF
  bool *v18; // [esp+268h] [ebp-4h]
  unsigned int v19; // [esp+288h] [ebp+1Ch]

  v10 = this;
  v18 = (bool *)this;
  if ( a7 <= 0x18 )
  {
    v19 = 0;
    while ( v10[69] != a7 || !(unsigned __int8)sub_40CD07(v10, a3) || memcmp((char *)v10 + 258, Buf2, 0x10u) )
    {
      ++v19;
      v10 += 94;
      if ( v19 >= 4 )
      {
        sub_41172D(a4, Str, 512);
        v11 = strlen(Str);
        sub_405AC9(Str, v11, Buf2, 0x10u, Src, v15, v16, 1 << a7);
        sub_40CC38(Str, 512);
        v12 = &v18[376 * ((*((_DWORD *)v18 + 376))++ & 3)];
        *((_DWORD *)v12 + 69) = a7;
        qmemcpy(v12, a3, 0x102u);
        memcpy(v12 + 258, Buf2, 0x10u);
        memcpy(v12 + 280, Src, 0x20u);
        memcpy(v12 + 312, v16, 0x20u);
        memcpy(v12 + 344, v15, 0x20u);
        sub_40CB92((int)(v12 + 280), 0x20u, 1);
        goto LABEL_8;
      }
    }
    sub_40CB92((int)(v10 + 70), 0x20u, 0);
    memcpy(Src, v10 + 70, sizeof(Src));
    sub_40CB92((int)(v10 + 70), 0x20u, 1);
    memcpy(v16, v10 + 78, sizeof(v16));
    memcpy(v15, v10 + 86, sizeof(v15));
LABEL_8:
    if ( a8 )
      memcpy(a8, v15, 0x20u);
    if ( a9 )
    {
      memset(a9, 0, 8u);
      for ( i = 0; i < 0x20; ++i )
        *((_BYTE *)a9 + (i & 7)) ^= v16[i];
      sub_40CC38(v16, 32);
    }
    if ( Val )
      sub_40C6EF(v18 + 1512, a2, (int)Src, 256, Val);
    sub_40CC38(Src, 32);
  }
}
// 405BE4: using guessed type _BYTE var_44[32];

//----- (00405DE6) --------------------------------------------------------
void __thiscall sub_405DE6(_BYTE *this)
{
  sub_40CD6F(this);
}

//----- (00405DF7) --------------------------------------------------------
void __thiscall sub_405DF7(_BYTE *this)
{
  sub_40CC38(this, 1504);
  `eh vector destructor iterator'(this, 0x178u, 4, sub_405DF2);
}

//----- (00405E38) --------------------------------------------------------
__m128i *__thiscall sub_405E38(_DWORD *this, __m128i *a2, __m128i *a3)
{
  int v3; // eax
  __m128i *result; // eax
  bool v5; // cf

  v3 = this[377];
  v5 = v3 == 4;
  result = (__m128i *)(v3 - 4);
  if ( v5 || result == (__m128i *)1 )
    return sub_40C7C0(this + 378, a2, a3, a2);
  return result;
}

//----- (00405E60) --------------------------------------------------------
void __stdcall sub_405E60(_DWORD *a1, char *a2)
{
  _DWORD *v2; // esi
  int v3; // edx
  unsigned int i; // eax
  char *v5; // esi
  char Src[32]; // [esp+4h] [ebp-20h] BYREF

  v2 = a1;
  if ( *a1 == 2 )
  {
    a1 = (_DWORD *)a1[1];
    sub_40598C(a2, 0x20u, (char *)&a1, 4u, (int)Src);
    v3 = 0;
    v2[1] = 0;
    for ( i = 0; i < 0x20; ++i )
      v3 ^= (unsigned __int8)Src[i] << (8 * (i & 3));
    v2[1] = v3;
  }
  if ( *v2 == 3 )
  {
    v5 = (char *)(v2 + 1);
    sub_40598C(a2, 0x20u, v5, 0x20u, (int)Src);
    memcpy(v5, Src, 0x20u);
  }
}
// 405E60: using guessed type char Src[32];

//----- (00405ED9) --------------------------------------------------------
int __thiscall sub_405ED9(int this)
{
  `eh vector constructor iterator'((void *)this, 0x178u, 4, (void (__thiscall *)(void *))sub_405DE6, sub_405DF2);
  sub_40C6D6((_BYTE *)(this + 1512));
  *(_DWORD *)(this + 1508) = 0;
  memset((void *)this, 0, 0x5E0u);
  *(_DWORD *)(this + 1504) = 0;
  memset((void *)(this + 1776), 0, 0x400u);
  return this;
}

//----- (00405F4F) --------------------------------------------------------
char __thiscall sub_405F4F(int this, int a2, int a3, _BYTE *Src, void *Buf2, int Val, int a7, void *a8, void *a9)
{
  CHAR MultiByteStr[128]; // [esp+8h] [ebp-180h] BYREF
  WCHAR WideCharStr[128]; // [esp+88h] [ebp-100h] BYREF

  if ( !Src[256] || !a3 )
    return 0;
  *(_DWORD *)(this + 1508) = a3;
  sub_40CC83(Src, WideCharStr, 128);
  sub_411643(WideCharStr, MultiByteStr, 128);
  if ( a3 == 4 )
  {
    sub_4056F9((bool *)this, a2, Src, WideCharStr, Buf2);
  }
  else if ( a3 == 5 )
  {
    sub_405BE4((_DWORD *)this, a2, Src, WideCharStr, Buf2, Val, a7, a8, a9);
  }
  sub_40CC38(MultiByteStr, 128);
  sub_40CC38(WideCharStr, 256);
  return 1;
}

//----- (00406013) --------------------------------------------------------
BOOL __stdcall sub_406013(HWND hDlg, int nIDDlgItem, unsigned __int8 a3)
{
  HWND DlgItem; // eax

  DlgItem = GetDlgItem(hDlg, nIDDlgItem);
  return EnableWindow(DlgItem, a3);
}

//----- (00406031) --------------------------------------------------------
BOOL __stdcall sub_406031(HWND hDlg, int nIDDlgItem, char a3)
{
  HWND DlgItem; // eax

  DlgItem = GetDlgItem(hDlg, nIDDlgItem);
  return ShowWindow(DlgItem, a3 != 0 ? 9 : 0);
}

//----- (00406056) --------------------------------------------------------
char __stdcall sub_406056(HWND hWnd, int a2, int a3, int a4, LPCWCH lpWideCharStr, int a6, char a7)
{
  if ( a2 == 48 )
  {
    sub_40B8B0(&unk_432A7C, hWnd);
  }
  else if ( a2 == 272 )
  {
    sub_40BDF9((__int16 **)&unk_432A7C, hWnd, lpWideCharStr, (HWND)(a7 & 1));
  }
  return 0;
}

//----- (00406096) --------------------------------------------------------
int __thiscall sub_406096(int this)
{
  int result; // eax

  result = this;
  *(_BYTE *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  return result;
}

//----- (004060A7) --------------------------------------------------------
unsigned int __thiscall sub_4060A7(_BYTE *this, int a2, unsigned __int8 *a3, unsigned int a4, int a5, unsigned int a6)
{
  _BYTE *v7; // ebx
  unsigned int v8; // edx
  unsigned int result; // eax
  int v10; // edi
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  unsigned __int8 v15; // bl
  int i; // ecx
  int j; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v19; // [esp+27h] [ebp+Fh]

  v7 = this;
  v8 = 1;
  result = 0;
  v10 = a5;
  v19 = *a3;
  if ( a4 > 1 )
  {
    while ( 1 )
    {
      if ( result >= a6 )
        goto LABEL_16;
      if ( !*((_DWORD *)v7 + 2) )
      {
        v7[4] = a3[v8++];
        *((_DWORD *)v7 + 2) = 8;
      }
      v11 = (unsigned __int8)v7[4] >> 6;
      if ( !v11 )
      {
        *(_WORD *)(v10 + 2 * result++) = a3[v8++];
        goto LABEL_14;
      }
      v12 = v11 - 1;
      if ( !v12 )
        break;
      v13 = v12 - 1;
      if ( !v13 )
      {
        *(_WORD *)(v10 + 2 * result++) = a3[v8] + (a3[v8 + 1] << 8);
        v8 += 2;
LABEL_13:
        v7 = this;
        goto LABEL_14;
      }
      if ( v13 == 1 )
      {
        v14 = a3[v8++];
        if ( (v14 & 0x80u) == 0 )
        {
          for ( i = v14 + 2; i > 0 && result < a6; --i )
          {
            *(_WORD *)(v10 + 2 * result) = *(char *)(result + a2);
            v7 = this;
            ++result;
          }
          goto LABEL_14;
        }
        v15 = a3[v8++];
        for ( j = (v14 & 0x7F) + 2; j > 0; ++result )
        {
          if ( result >= a6 )
            break;
          v10 = a5;
          --j;
          *(_WORD *)(a5 + 2 * result) = (v19 << 8) + (unsigned __int8)(v15 + *(_BYTE *)(result + a2));
        }
        goto LABEL_13;
      }
LABEL_14:
      v7[4] *= 4;
      *((_DWORD *)v7 + 2) -= 2;
      if ( v8 >= a4 )
        goto LABEL_15;
    }
    v10 = a5;
    *(_WORD *)(a5 + 2 * result++) = (v19 << 8) + a3[v8++];
    goto LABEL_13;
  }
LABEL_15:
  if ( result >= a6 )
LABEL_16:
    result = a6 - 1;
  *(_WORD *)(v10 + 2 * result) = 0;
  return result;
}

//----- (00406205) --------------------------------------------------------
int __thiscall sub_406205(_DWORD *this)
{
  int result; // eax

  result = 0;
  *this = 0;
  this[1] = 0;
  *((_BYTE *)this + 8) = 1;
  *((_BYTE *)this + 9) = 0;
  *((_BYTE *)this + 10) = 0;
  *((_BYTE *)this + 11) = 0;
  *((_BYTE *)this + 12) = 0;
  return result;
}

//----- (0040621D) --------------------------------------------------------
char __stdcall sub_40621D(int a1)
{
  return 0;
}

//----- (00406222) --------------------------------------------------------
int __thiscall sub_406222(int *this, int a2)
{
  int result; // eax

  result = a2 - 1;
  if ( a2 != 1 )
  {
    if ( a2 == 2 )
    {
      result = *this;
      if ( !*this || result == 1 )
        *this = 2;
      goto LABEL_7;
    }
    result = a2 - 3;
    if ( a2 == 3 )
    {
      if ( *this != 11 )
        *this = 3;
      goto LABEL_7;
    }
    result = a2 - 255;
    if ( a2 != 255 )
    {
LABEL_6:
      *this = a2;
      goto LABEL_7;
    }
  }
  if ( !*this )
    goto LABEL_6;
LABEL_7:
  ++this[1];
  return result;
}

//----- (00406265) --------------------------------------------------------
void __thiscall sub_406265(int this, int pExceptionObject)
{
  int v2; // esi

  v2 = pExceptionObject;
  if ( pExceptionObject != 255 || *(_BYTE *)(this + 8) )
  {
    sub_406222((int *)this, pExceptionObject);
    pExceptionObject = v2;
    _CxxThrowException(&pExceptionObject, (_ThrowInfo *)&_TI1_AW4RAR_EXIT__);
  }
}

//----- (0040629E) --------------------------------------------------------
bool __thiscall sub_40629E(_BYTE *this, int a1, int a2)
{
  return !this[9] && sub_4115D5(a1, a2);
}

//----- (004062AE) --------------------------------------------------------
int __thiscall sub_4062AE(int *this)
{
  sub_401B9F(7);
  return sub_406222(this, 8);
}

//----- (004062C8) --------------------------------------------------------
void __stdcall sub_4062C8(int a1, int a2, int a3)
{
  int v3[19]; // [esp+0h] [ebp-4Ch] BYREF

  v3[17] = 0;
  v3[18] = a1;
  v3[0] = a2;
  v3[1] = a3;
  v3[16] = 2;
  sub_411280(v3);
}

//----- (004062F7) --------------------------------------------------------
void __thiscall sub_4062F7(int *this)
{
  sub_4062AE(this);
  sub_406265((int)this, 8);
}

//----- (0040630A) --------------------------------------------------------
void __thiscall sub_40630A(_BYTE *this, int a2)
{
  if ( !this[11] )
    sub_4012DD(10, a2);
  sub_406265((int)this, 2);
}

//----- (0040632B) --------------------------------------------------------
void __thiscall sub_40632B(_BYTE *this, int a2)
{
  if ( !this[11] )
    sub_4012DD(11, a2);
  sub_406265((int)this, 2);
}

//----- (0040634C) --------------------------------------------------------
void sub_40634C(int a1, wchar_t *Format, ...)
{
  wchar_t Buffer[1024]; // [esp+0h] [ebp-800h] BYREF
  va_list va; // [esp+810h] [ebp+10h] BYREF

  va_start(va, Format);
  _vswprintf_c_l(Buffer, 0x400u, Format, 0, va);
  sub_4012DD(1, (int)Buffer);
}

//----- (00406382) --------------------------------------------------------
int __thiscall sub_406382(int *this, int a2, int a3)
{
  sub_4062C8(8, a2, a3);
  return sub_406222(this, 6);
}

//----- (004063A1) --------------------------------------------------------
int __thiscall sub_4063A1(int *this, int a2, int a3)
{
  sub_4062C8(9, a2, a3);
  return sub_406222(this, 9);
}

//----- (004063C0) --------------------------------------------------------
int __thiscall sub_4063C0(int *this, int a2, int a3)
{
  sub_4062C8(12, a2, a3);
  return sub_406222(this, 2);
}

//----- (004063DF) --------------------------------------------------------
int __thiscall sub_4063DF(int *this, int a2, int a3)
{
  sub_4062C8(13, a2, a3);
  return sub_406222(this, 5);
}

//----- (004063FE) --------------------------------------------------------
int __stdcall sub_4063FE(int a1, int a2)
{
  sub_4062C8(31, a1, a2);
  return sub_406222(&dword_432A6C, 2);
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0040641C) --------------------------------------------------------
void __thiscall sub_40641C(int *this, int a2, int a3)
{
  sub_4063DF(this, a2, a3);
  sub_406265((int)this, 5);
}

//----- (00406439) --------------------------------------------------------
int __thiscall sub_406439(int *this, int a2)
{
  return sub_406382(this, 0, a2);
}

//----- (00406447) --------------------------------------------------------
int __thiscall sub_406447(int *this, int a2)
{
  return sub_4063A1(this, 0, a2);
}

//----- (00406455) --------------------------------------------------------
int __thiscall sub_406455(int *this, int a2)
{
  return sub_4063C0(this, 0, a2);
}

//----- (00406463) --------------------------------------------------------
void __thiscall sub_406463(int *this, int a2)
{
  sub_406455(this, a2);
  sub_406265((int)this, 2);
}

//----- (0040647C) --------------------------------------------------------
bool __stdcall sub_40647C(LPCWSTR lpName)
{
  bool v1; // bl
  HANDLE CurrentProcess; // eax
  struct _TOKEN_PRIVILEGES NewState; // [esp+4h] [ebp-14h] BYREF
  HANDLE TokenHandle; // [esp+14h] [ebp-4h] BYREF

  v1 = 0;
  CurrentProcess = GetCurrentProcess();
  if ( OpenProcessToken(CurrentProcess, 0x20u, &TokenHandle) )
  {
    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Attributes = 2;
    if ( LookupPrivilegeValueW(0, lpName, &NewState.Privileges[0].Luid)
      && AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0, 0) )
    {
      v1 = GetLastError() == 0;
    }
    CloseHandle(TokenHandle);
  }
  return v1;
}

//----- (004064ED) --------------------------------------------------------
char __stdcall sub_4064ED(_DWORD *a1, _WORD *a2, int a3)
{
  unsigned __int8 *v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // esi
  char result; // al
  size_t v7; // esi
  char v8[8192]; // [esp+4h] [ebp-2000h] BYREF

  v3 = (unsigned __int8 *)a1[8906];
  v4 = a1[8907];
  if ( a1[10380] == 2 )
  {
    v5 = v4 >> 1;
    if ( v4 >> 1 >= a3 - 1 )
      v5 = a3 - 1;
    sub_4116ED(v3, (int)a2, v5);
    result = 0;
    a2[v5] = 0;
  }
  else
  {
    v7 = a1[8907];
    if ( v4 >= 0x1FFF )
      v7 = 0x1FFF;
    memcpy(v8, v3, v7);
    v8[v7] = 0;
    return sub_411817(v8, a2, a3);
  }
  return result;
}
// 4064ED: using guessed type char var_2000[8192];

//----- (00406573) --------------------------------------------------------
bool __stdcall sub_406573(wchar_t *lpFileName, __int16 *lpExistingFileName, int a3)
{
  bool result; // al
  BOOL HardLinkW; // eax
  bool v5; // bl

  sub_409FD2(lpExistingFileName, (int)lpExistingFileName, a3);
  result = sub_409026((WCHAR *)lpExistingFileName);
  if ( result )
  {
    sub_4090CB(lpFileName, 1);
    HardLinkW = CreateHardLinkW(lpFileName, (LPCWSTR)lpExistingFileName, 0);
    v5 = HardLinkW;
    if ( !HardLinkW )
    {
      sub_4012DD(21, (int)lpFileName);
      nullsub_2(&dword_432A6C);
      sub_406222(&dword_432A6C, 9);
    }
    return v5;
  }
  return result;
}
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 432A6C: using guessed type int dword_432A6C;

//----- (004065D5) --------------------------------------------------------
_DWORD *__thiscall sub_4065D5(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1028] = 0;
  this[1029] = 0;
  this[1030] = 0;
  this[1031] = 0;
  this[1032] = 0;
  this[1033] = 0;
  return result;
}

//----- (004065FE) --------------------------------------------------------
void __stdcall sub_4065FE(int a1, WCHAR *lpFileName)
{
  bool v2; // zf
  SECURITY_INFORMATION v3; // edi
  PSECURITY_DESCRIPTOR v4; // ebx
  WCHAR FileName[2048]; // [esp+4h] [ebp-101Ch] BYREF
  PSECURITY_DESCRIPTOR pSecurityDescriptor[7]; // [esp+1004h] [ebp-1Ch] BYREF

  memset(pSecurityDescriptor, 0, 16);
  pSecurityDescriptor[6] = 0;
  if ( sub_402C37(a1, (int *)pSecurityDescriptor, 0) )
  {
    if ( !byte_432A61 )
    {
      if ( sub_40647C(L"SeSecurityPrivilege") )
        byte_432A60 = 1;
      sub_40647C(L"SeRestorePrivilege");
      byte_432A61 = 1;
    }
    v3 = 7;
    if ( byte_432A60 )
      v3 = 15;
    v4 = pSecurityDescriptor[0];
    if ( !SetFileSecurityW(lpFileName, v3, pSecurityDescriptor[0])
      && (!sub_40A582(lpFileName, FileName, 0x800u) || !SetFileSecurityW(FileName, v3, v4)) )
    {
      sub_4062C8(79, a1 + 30, (int)lpFileName);
      nullsub_2(&dword_432A6C);
      sub_406222(&dword_432A6C, 1);
    }
    v2 = pSecurityDescriptor[0] == 0;
  }
  else
  {
    v2 = pSecurityDescriptor[0] == 0;
  }
  if ( !v2 )
    free(pSecurityDescriptor[0]);
}
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 432A60: using guessed type char byte_432A60;
// 432A61: using guessed type char byte_432A61;
// 432A6C: using guessed type int dword_432A6C;

//----- (004066FE) --------------------------------------------------------
char __stdcall sub_4066FE(int a1, wchar_t *lpFileName, int a3)
{
  HANDLE FileW; // eax
  wchar_t *p_Source; // esi
  int v6; // eax
  bool v7; // bl
  wchar_t *p_Destination; // eax
  wchar_t *v10; // eax
  int v11; // ecx
  unsigned __int16 *v12; // esi
  HANDLE v13; // ebx
  char v14; // bl
  _DWORD v15[1033]; // [esp+0h] [ebp-3048h] BYREF
  wchar_t v16; // [esp+1024h] [ebp-2024h] BYREF
  wchar_t Destination; // [esp+1026h] [ebp-2022h] BYREF
  wchar_t String[4]; // [esp+2024h] [ebp-1024h] BYREF
  wchar_t String1[3]; // [esp+202Ch] [ebp-101Ch] BYREF
  wchar_t Source; // [esp+2032h] [ebp-1016h] BYREF
  DWORD BytesReturned; // [esp+3024h] [ebp-24h] BYREF
  LPVOID lpInBuffer[4]; // [esp+3028h] [ebp-20h] BYREF
  wchar_t *v23; // [esp+3038h] [ebp-10h]
  int v24; // [esp+3044h] [ebp-4h]
  int v25; // [esp+3058h] [ebp+10h]

  if ( !byte_432A62 )
  {
    sub_40647C(L"SeRestorePrivilege");
    sub_40647C(L"SeCreateSymbolicLinkPrivilege");
    byte_432A62 = 1;
  }
  sub_4090CB(lpFileName, 1);
  if ( *(_BYTE *)(a3 + 4321) || *(_BYTE *)(a3 + 8436) )
  {
    if ( CreateDirectoryW(lpFileName, 0) )
      goto LABEL_7;
    return 0;
  }
  FileW = CreateFileW(lpFileName, 0x40000000u, 0, 0, 1u, 0x80u, 0);
  if ( FileW == (HANDLE)-1 )
    return 0;
  CloseHandle(FileW);
LABEL_7:
  sub_401306(lpInBuffer, 5144);
  v24 = 0;
  sub_41078F(String, (wchar_t *)(a3 + 4340), 2048);
  v25 = wcslen(String);
  p_Source = String;
  v23 = &v16;
  v6 = wcsncmp(String, L"\\??\\", 4u);
  v7 = v6 == 0;
  if ( v6 || (p_Source = String1, wcsncmp(String1, L"UNC\\", 4u)) )
  {
    p_Destination = v23;
  }
  else
  {
    v16 = 92;
    p_Destination = &Destination;
    p_Source = &Source;
  }
  wcscpy(p_Destination, p_Source);
  v10 = (wchar_t *)wcslen(&v16);
  v11 = *(_DWORD *)(a3 + 4336);
  v23 = v10;
  if ( v11 == 3 )
  {
    v12 = (unsigned __int16 *)lpInBuffer[0];
    *((_WORD *)lpInBuffer[0] + 2) = 2 * (v25 + (_WORD)v10) + 12;
    v12[3] = 0;
    v12[4] = 0;
    *(_DWORD *)v12 = -1610612733;
    v12[5] = 2 * v25;
    wcscpy(v12 + 8, String);
    v12[7] = 2 * (_WORD)v23;
    v12[6] = 2 * v25 + 2;
    wcscpy(&v12[v25 + 9], &v16);
  }
  else
  {
    if ( v11 != 2 && v11 != 1 )
    {
      if ( lpInBuffer[0] )
        free(lpInBuffer[0]);
      return 0;
    }
    v12 = (unsigned __int16 *)lpInBuffer[0];
    *((_WORD *)lpInBuffer[0] + 2) = 2 * (v25 + (_WORD)v10) + 16;
    v12[3] = 0;
    v12[4] = 0;
    v12[5] = 2 * v25;
    *(_DWORD *)v12 = -1610612724;
    wcscpy(v12 + 10, String);
    v12[6] = 2 * v25 + 2;
    v12[7] = 2 * (_WORD)v23;
    wcscpy(&v12[v25 + 11], &v16);
    *((_DWORD *)v12 + 4) = !v7;
  }
  v13 = CreateFileW(lpFileName, 0xC0000000, 0, 0, 3u, 0x2200000u, 0);
  if ( v13 == (HANDLE)-1 )
  {
    free(v12);
    return 0;
  }
  if ( DeviceIoControl(v13, 0x900A4u, v12, v12[2] + 8, 0, 0, &BytesReturned, 0) )
  {
    sub_408533(v15);
    LOBYTE(v24) = 1;
    sub_4087BE((int)v15);
    v15[1] = v13;
    sub_408AB6(
      (int)v15,
      *(_DWORD *)(a1 + 25228) != 0 ? (int *)(a3 + 4144) : 0,
      *(_DWORD *)(a1 + 25232) != 0 ? (int *)(a3 + 4152) : 0,
      *(_DWORD *)(a1 + 25236) != 0 ? (int *)(a3 + 4160) : 0);
    sub_4087BE((int)v15);
    if ( !*(_BYTE *)(a1 + 20891) )
      sub_408E0E(lpFileName, *(_DWORD *)(a3 + 28));
    LOBYTE(v24) = 0;
    sub_4089F9((int)v15);
    v14 = 1;
  }
  else
  {
    CloseHandle(v13);
    sub_4062C8(20, 0, (int)lpFileName);
    if ( GetLastError() == 1314 )
      sub_401B9F(22);
    nullsub_2(&dword_432A6C);
    sub_406222(&dword_432A6C, 9);
    if ( *(_BYTE *)(a3 + 4321) )
      RemoveDirectoryW(lpFileName);
    else
      DeleteFileW(lpFileName);
    v14 = 0;
  }
  free(v12);
  return v14;
}
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 432A62: using guessed type char byte_432A62;
// 432A6C: using guessed type int dword_432A6C;
// 4066FE: using guessed type LPVOID lpInBuffer[4];

//----- (00406AAD) --------------------------------------------------------
char __stdcall sub_406AAD(int a1, int a2, int a3, wchar_t *lpFileName)
{
  if ( *(_DWORD *)(a3 + 41520) == 3 )
    return sub_4066FE(a1, lpFileName, a3 + 22472);
  else
    return 0;
}

//----- (00406AD4) --------------------------------------------------------
char __stdcall sub_406AD4(_DWORD *a1, wchar_t *Source)
{
  char v3; // bl
  HANDLE v4[1033]; // [esp+Ch] [ebp-50A0h] BYREF
  wchar_t v5[2048]; // [esp+1030h] [ebp-407Ch] BYREF
  wchar_t Destination[2050]; // [esp+2030h] [ebp-307Ch] BYREF
  wchar_t v7[2052]; // [esp+3034h] [ebp-2078h] BYREF
  DWORD dwFileAttributes; // [esp+403Ch] [ebp-1070h]
  FILETIME CreationTime; // [esp+405Ch] [ebp-1050h] BYREF
  FILETIME LastAccessTime; // [esp+4064h] [ebp-1048h] BYREF
  FILETIME LastWriteTime; // [esp+406Ch] [ebp-1040h] BYREF
  _DWORD v12[1033]; // [esp+407Ch] [ebp-1030h] BYREF
  int v13; // [esp+50A8h] [ebp-4h]

  if ( !*Source || Source[1] )
  {
    sub_41078F(Destination, Source, 2050);
  }
  else
  {
    wcscpy(Destination, L".\\");
    sub_41078F(&Destination[2], Source, 2048);
  }
  sub_4064ED(a1, v5, 2048);
  if ( v5[0] == 58 )
  {
    sub_4107BC(Destination, v5, 0x802u);
    sub_4065D5(v7);
    v3 = sub_409429(Source, v7, 0);
    if ( (dwFileAttributes & 1) != 0 )
      sub_408E0E(Source, dwFileAttributes & 0xFFFFFFFE);
    sub_408533(v12);
    v13 = 0;
    if ( sub_408796(v12, Destination, 9u) && sub_402C37((int)a1, 0, (int)v12) )
      sub_4087BE((int)v12);
    sub_408533(v4);
    LOBYTE(v13) = 1;
    if ( v3 )
    {
      if ( sub_408570((int)v4, Source, 5) )
        SetFileTime(v4[1], &CreationTime, &LastAccessTime, &LastWriteTime);
    }
    sub_408E0E(Source, dwFileAttributes);
    LOBYTE(v13) = 0;
    sub_4089F9((int)v4);
    v13 = -1;
    return sub_4089F9((int)v12);
  }
  else
  {
    sub_4062C8(80, (int)a1 + 30, (int)Source);
    return sub_406222(&dword_432A6C, 3);
  }
}
// 432A6C: using guessed type int dword_432A6C;
// 406AD4: using guessed type _DWORD var_1030[1033];

//----- (00406C70) --------------------------------------------------------
char __stdcall sub_406C70(int a1, int a2, WCHAR *lpFileName)
{
  int v3; // eax

  if ( *(_BYTE *)(a1 + 20872) && !wcscmp((const wchar_t *)(a2 + 31528), L"ACL") )
    sub_4065FE(a2, lpFileName);
  v3 = wcscmp((const wchar_t *)(a2 + 31528), L"STM");
  if ( !v3 )
    LOBYTE(v3) = sub_406AD4((_DWORD *)a2, lpFileName);
  return v3;
}

//----- (00406CC8) --------------------------------------------------------
int __thiscall sub_406CC8(_DWORD *this, int a2, wchar_t *a3, wchar_t *String, int a5)
{
  wchar_t *v7; // eax
  int v8; // eax
  __int16 v9; // bx
  int result; // eax
  __int16 v11; // si
  wchar_t *v12; // [esp-8h] [ebp-10h]
  int v13; // [esp-4h] [ebp-Ch]
  char String_3; // [esp+1Bh] [ebp+13h]

  sub_41078F(String, (wchar_t *)(this[2] + 4114), a5);
  if ( *(_WORD *)(this[2] + 4114) )
  {
    v7 = sub_409D8B((wchar_t *)(this[2] + 4114));
    if ( !sub_409DC6(*v7) )
      sub_409DEB(String, a5);
  }
  v8 = this[2];
  v9 = *(_WORD *)(v8 + 29362);
  if ( *(_DWORD *)(v8 + 20820) == 4 && v9 == 88 && sub_409DDE(58) )
  {
    String_3 = 1;
    *String = 0;
  }
  else
  {
    String_3 = 0;
  }
  if ( v9 == 69 || *(_DWORD *)(this[2] + 20820) == 1 )
  {
    v12 = sub_40A0CE(a3);
    sub_4107BC(String, v12, a5);
  }
  else
  {
    sub_4107BC(String, a3, a5);
  }
  result = sub_411A29(*String);
  v11 = result;
  if ( String_3 )
  {
    if ( String[1] == 95 )
    {
      result = sub_409DC6(String[2]);
      if ( (_BYTE)result )
      {
        if ( (unsigned __int16)(v11 - 65) <= 0x19u )
        {
          v13 = 58;
LABEL_21:
          result = v13;
          String[1] = v13;
          return result;
        }
      }
    }
    if ( *String == 95 && String[1] == 95 )
    {
      *String = 92;
      v13 = 92;
      goto LABEL_21;
    }
  }
  return result;
}

//----- (00406DC2) --------------------------------------------------------
BOOL __thiscall sub_406DC2(_QWORD *this, _QWORD *a2)
{
  return *this < *a2;
}

//----- (00406DE0) --------------------------------------------------------
BOOL __thiscall sub_406DE0(unsigned int *this, int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx

  v2 = *this;
  v3 = this[1];
  return __PAIR64__(v3, v2) > *(_QWORD *)a2 || v2 == *(_DWORD *)a2 && v3 == *(_DWORD *)(a2 + 4);
}

//----- (00406E0C) --------------------------------------------------------
void __thiscall sub_406E0C(int this)
{
  void *v2; // edi

  v2 = *(void **)(this + 15072);
  if ( v2 )
  {
    sub_415133((int)v2);
    operator delete(v2);
  }
  sub_40CD93(this + 19188);
  sub_401000((_BYTE *)(this + 16));
}
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);

//----- (00406E66) --------------------------------------------------------
DWORD __thiscall sub_406E66(int this, int *a2)
{
  int v3; // eax
  char v4; // cl

  *(_QWORD *)(this + 6264) = sub_408B84(a2);
  v3 = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 15080) = 0;
  *(_DWORD *)(this + 15084) = 0;
  v4 = *(_BYTE *)(v3 + 16672);
  *(_BYTE *)(this + 19446) = v4;
  if ( v4 )
    qmemcpy((void *)(this + 19188), (const void *)(v3 + 16416), 0x102u);
  *(_BYTE *)(this + 6255) = 0;
  *(_BYTE *)(this + 19447) = 0;
  *(_BYTE *)(this + 15089) = 1;
  *(_BYTE *)(this + 15090) = 0;
  *(_BYTE *)(this + 15091) = 0;
  return sub_410F43((DWORD *)this);
}

//----- (00406EE0) --------------------------------------------------------
void __stdcall sub_406EE0(int a1, int a2, int a3, int a4)
{
  int v4[19]; // [esp+0h] [ebp-4Ch] BYREF

  v4[17] = 0;
  v4[18] = a1;
  v4[0] = a2;
  v4[1] = a3;
  v4[2] = a4;
  v4[16] = 3;
  sub_411280(v4);
}

//----- (00406F15) --------------------------------------------------------
_DWORD *__thiscall sub_406F15(_DWORD *this, _DWORD *a2)
{
  void *v3; // ecx
  int v4; // eax
  unsigned int v5; // ebx

  *this = 0;
  this[1] = 0;
  sub_40B5A4(this + 4);
  sub_40CD6F((_BYTE *)this + 19188);
  this[3769] = 0;
  this[2] = a2;
  *((_WORD *)this + 7546) = 0;
  *((_WORD *)this + 9724) = 0;
  sub_40CCBC((_BYTE *)this + 19188, (wchar_t *)&String);
  v3 = operator new(0xE700u);
  if ( v3 )
    v4 = sub_4171B2((int)v3, (int)(this + 4));
  else
    v4 = 0;
  this[3768] = v4;
  v5 = a2[7334];
  if ( v5 >= 8 )
    v5 = 8;
  *(_DWORD *)(v4 + 28) = v5;
  return this;
}

//----- (00406FC2) --------------------------------------------------------
void __stdcall sub_406FC2(char *a1, unsigned int a2, int a3)
{
  __m128i *v3; // edi
  unsigned int i; // esi
  int v6; // et0
  void *Block; // [esp+8h] [ebp-1Ch] BYREF
  int v8; // [esp+Ch] [ebp-18h]
  int v9; // [esp+20h] [ebp-4h]

  sub_401306(&Block, 0x40000);
  v3 = (__m128i *)Block;
  v9 = 0;
  for ( i = sub_40B60F(a1, (__m128i *)Block, v8); i; i = sub_40B60F(a1, v3, v8) )
  {
    if ( i == -1 )
      break;
    if ( a3 <= 0 && (a3 < 0 || i >= a2) )
      i = a2;
    sub_40B7BF((int)a1, v3->m128i_i8, i);
    if ( a3 >= 0 )
    {
      v6 = (__PAIR64__(a3, a2) - i) >> 32;
      a2 -= i;
      a3 = v6;
    }
  }
  if ( v3 )
    free(v3);
}

//----- (00407059) --------------------------------------------------------
char __stdcall sub_407059(int *a1, int a2, int a3, __int16 *a4, int a5)
{
  char v5; // bl
  void *v7; // esi
  DWORD v8; // eax
  _DWORD v9[1033]; // [esp+8h] [ebp-1040h] BYREF
  void *Block[4]; // [esp+102Ch] [ebp-1Ch] BYREF
  int v11; // [esp+1044h] [ebp-4h]

  sub_409FD2(a4, (int)a4, a5);
  sub_408533(v9);
  v5 = 0;
  v11 = 0;
  if ( sub_4086AB(v9, (int)a4) )
  {
    sub_401306(Block, 0x100000);
    LOBYTE(v11) = 1;
    sub_4109C7();
    v7 = Block[0];
    while ( 1 )
    {
      v8 = sub_408BFC(v9, v7, (DWORD)Block[1]);
      if ( !v8 )
        break;
      sub_408835(a1, (char *)v7, v8);
      sub_4109C7();
    }
    if ( v7 )
      free(v7);
    v5 = 1;
  }
  else
  {
    sub_406EE0(17, a2, (int)a4, a3);
    sub_4012DD(18, a2);
  }
  v11 = -1;
  sub_4089F9((int)v9);
  return v5;
}
// 407059: using guessed type _DWORD var_1040[1033];

//----- (00407121) --------------------------------------------------------
char __thiscall sub_407121(_BYTE *this, int a2, wchar_t *Source)
{
  if ( this[19444] || sub_4114D8(1, Source, this + 19188) )
    return 1;
  sub_401B9F(2);
  sub_4012DD(6, (int)Source);
  return 0;
}

//----- (0040715B) --------------------------------------------------------
char __thiscall sub_40715B(int this, int a2, int a3)
{
  int v4; // eax
  int v5; // esi
  WCHAR *v6; // ebx
  int v7; // eax
  int v9; // [esp+4h] [ebp-4h]

  v4 = *(_DWORD *)(this + 8);
  if ( *(_BYTE *)(v4 + 20929) )
    return v4;
  v5 = a2;
  v6 = (WCHAR *)(this + 19448);
  v4 = sub_40904A((WCHAR *)(this + 19448), *(_BYTE *)(v4 + 20891) == 0, *(_DWORD *)(a2 + 22500));
  v9 = v4;
  if ( !v4 )
    goto LABEL_12;
  HIBYTE(a2) = sub_409026((WCHAR *)(this + 19448));
  if ( !HIBYTE(a2) )
    goto LABEL_7;
  v7 = sub_408DC2((WCHAR *)(this + 19448));
  LOBYTE(v4) = sub_408D9D(v7);
  if ( !(_BYTE)v4 )
  {
    LOBYTE(v4) = sub_408465(
                   *(_DWORD *)(this + 8),
                   0,
                   (WCHAR *)(this + 19448),
                   2048,
                   (_BYTE *)&a2 + 3,
                   *(_QWORD *)(v5 + 26648),
                   v5 + 26616,
                   0);
    HIBYTE(a2) = 0;
  }
  if ( !HIBYTE(a2) )
  {
LABEL_7:
    sub_4090CB((wchar_t *)(this + 19448), 1);
    v4 = sub_40904A((WCHAR *)(this + 19448), *(_BYTE *)(*(_DWORD *)(this + 8) + 20891) == 0, *(_DWORD *)(v5 + 22500));
    v9 = v4;
  }
  if ( !v9 )
    goto LABEL_12;
  if ( HIBYTE(a2) )
  {
    v4 = *(_DWORD *)(this + 8);
    if ( !*(_BYTE *)(v4 + 20891) )
      LOBYTE(v4) = sub_408E0E((WCHAR *)(this + 19448), *(_DWORD *)(v5 + 22500));
LABEL_12:
    *(_BYTE *)(this + 19447) = 1;
    goto LABEL_14;
  }
  sub_4062C8(19, v5 + 30, this + 19448);
  nullsub_2(&dword_432A6C);
  LOBYTE(v4) = sub_406222(&dword_432A6C, 9);
LABEL_14:
  if ( *(_BYTE *)(this + 19447) )
    LOBYTE(v4) = sub_408EB6(
                   v6,
                   *(_DWORD *)(*(_DWORD *)(this + 8) + 25228) != 0 ? (int *)(v5 + 26616) : 0,
                   *(_DWORD *)(*(_DWORD *)(this + 8) + 25232) != 0 ? (int *)(v5 + 26624) : 0,
                   *(_DWORD *)(*(_DWORD *)(this + 8) + 25236) != 0 ? (int *)(v5 + 26632) : 0);
  return v4;
}
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 432A6C: using guessed type int dword_432A6C;

//----- (004072BB) --------------------------------------------------------
char __thiscall sub_4072BB(int this, int a2, int a3)
{
  int v3; // eax
  __int16 v4; // dx
  int v5; // esi
  wchar_t *v6; // ebx
  wchar_t Destination[2048]; // [esp+0h] [ebp-100Ch] BYREF
  int v9; // [esp+1000h] [ebp-Ch]
  int v10; // [esp+1004h] [ebp-8h]
  char v11; // [esp+100Bh] [ebp-1h]

  v3 = *(_DWORD *)(this + 8);
  v4 = *(_WORD *)(v3 + 29362);
  v9 = this;
  v11 = 1;
  if ( (v4 == 69 || v4 == 88) && !*(_BYTE *)(v3 + 20929) )
  {
    v5 = a2;
    v6 = (wchar_t *)(this + 19448);
    if ( !sub_408465(v3, a3, (WCHAR *)(this + 19448), 2048, (_BYTE *)&a2 + 3, *(_QWORD *)(a2 + 26648), a2 + 26616, 1) )
    {
      v11 = 0;
      if ( !HIBYTE(a2) )
      {
        v10 = v5 + 30;
        sub_4063A1(&dword_432A6C, v5 + 30, (int)v6);
        if ( !sub_409E72(v6) )
        {
          sub_4012DD(106, v10);
          sub_41078F(Destination, v6, 2048);
          sub_409EE6(v6, 1);
          sub_4090CB(v6, 1);
          if ( sub_408465(*(_DWORD *)(v9 + 8), a3, v6, 2048, (_BYTE *)&a2 + 3, *(_QWORD *)(v5 + 26648), v5 + 26616, 1) )
            return 1;
          else
            sub_4063A1(&dword_432A6C, v10, (int)v6);
        }
      }
    }
  }
  return v11;
}
// 432A6C: using guessed type int dword_432A6C;
// 4072BB: using guessed type wchar_t Destination[2048];

//----- (004073CE) --------------------------------------------------------
BOOL __stdcall sub_4073CE(int a1, int a2)
{
  bool v2; // bl

  if ( *(_DWORD *)(a1 + 41520) == 3 )
    v2 = *(_BYTE *)(a1 + 22497) != 0;
  else
    v2 = *(_BYTE *)(a1 + 22497) != 29;
  if ( !*(_BYTE *)(a1 + 22498) )
    v2 = 0;
  if ( v2 )
  {
    sub_4063FE(a1 + 30, a2);
    sub_4012DD(34, a1 + 30);
  }
  return !v2;
}

//----- (00407428) --------------------------------------------------------
bool __thiscall sub_407428(int this, _DWORD *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // eax
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  char v13; // al
  int v14; // eax
  bool v15; // zf
  int v16; // eax
  char v17; // bl
  int v18; // eax
  int v19; // ecx
  char v20; // al
  char v21; // cl
  unsigned int v22; // edx
  unsigned int v23; // edi
  int v24; // ecx
  int v25; // eax
  char v26; // al
  char v27; // al
  int v28; // eax
  int v29; // edx
  bool v30; // al
  int v31; // [esp-20h] [ebp-41CCh]
  void *v32; // [esp-18h] [ebp-41C4h]
  int v33; // [esp-10h] [ebp-41BCh]
  wchar_t *v34; // [esp-10h] [ebp-41BCh]
  wchar_t String[2048]; // [esp+8h] [ebp-41A4h] BYREF
  wchar_t v36[2054]; // [esp+1008h] [ebp-31A4h] BYREF
  char v37; // [esp+2014h] [ebp-2198h]
  unsigned int v38[14]; // [esp+2018h] [ebp-2194h] BYREF
  wchar_t Destination[2048]; // [esp+2050h] [ebp-215Ch] BYREF
  HANDLE v40[4]; // [esp+3050h] [ebp-115Ch] BYREF
  bool v41; // [esp+3063h] [ebp-1149h]
  WCHAR FileName[2051]; // [esp+306Eh] [ebp-113Eh] BYREF
  char Src[260]; // [esp+4074h] [ebp-138h] BYREF
  char Buf2[8]; // [esp+4178h] [ebp-34h] BYREF
  int v45; // [esp+4180h] [ebp-2Ch]
  int v46; // [esp+4184h] [ebp-28h]
  int v47; // [esp+4188h] [ebp-24h]
  int v48; // [esp+418Fh] [ebp-1Dh]
  char v49; // [esp+4193h] [ebp-19h]
  int v50; // [esp+4194h] [ebp-18h]
  bool v51; // [esp+419Ah] [ebp-12h] BYREF
  bool v52; // [esp+419Bh] [ebp-11h]
  char v53; // [esp+419Ch] [ebp-10h]
  char v54; // [esp+419Dh] [ebp-Fh]
  bool v55; // [esp+419Eh] [ebp-Eh]
  char v56; // [esp+419Fh] [ebp-Dh]
  int v57; // [esp+41A8h] [ebp-4h]

  v4 = (int)a2;
  v5 = this;
  v6 = *(unsigned __int16 *)(*(_DWORD *)(this + 8) + 29362);
  v47 = this;
  v50 = v6;
  if ( !a3 )
  {
    if ( !*(_BYTE *)(this + 6255) )
      return 0;
    if ( !sub_418659(a2, this + 16, 0, v6) )
    {
      sub_406222(&dword_432A6C, 1);
      return 0;
    }
  }
  v8 = *(_DWORD *)(v4 + 22308);
  if ( v8 == 2 )
  {
    v9 = *(_DWORD *)(v5 + 8);
    *(_BYTE *)(v5 + 19447) = 0;
    if ( !*(_DWORD *)(v9 + 20824) && *(_DWORD *)(v5 + 15084) >= *(_DWORD *)(v9 + 37608) && *(_BYTE *)(v5 + 15089) )
      return 0;
    v51 = 0;
    v10 = sub_405409((wchar_t *)v9, v4 + 22472, &v51, 5);
    v55 = v10 != 0;
    if ( v10 && !v51 )
      *(_BYTE *)(v5 + 15089) = 0;
    sub_401A98(v4);
    sub_40A10B((wchar_t *)(v4 + 22504), Destination);
    if ( *(_BYTE *)(v4 + 26795) )
    {
      v11 = *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25220);
      if ( v11 != 1 && !v51 )
      {
        if ( !v11 )
          v55 = 0;
        if ( *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25220) - 1 == sub_40A043(Destination, 0) )
        {
          sub_40A043(Destination, 1);
          goto LABEL_32;
        }
LABEL_31:
        v55 = 0;
      }
    }
    else if ( !sub_401A91((_BYTE *)v4) && *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25220) > 1u )
    {
      goto LABEL_31;
    }
LABEL_32:
    *(_BYTE *)(v5 + 6255) = *(_BYTE *)(v4 + 26705);
    *(_BYTE *)(v5 + 6256) = 0;
    (*(void (__thiscall **)(int, int, _DWORD, _DWORD))(*(_DWORD *)v4 + 12))(
      v4,
      *(_DWORD *)(v4 + 41512) - *(_DWORD *)(v4 + 26640),
      (*(_QWORD *)(v4 + 41512) - *(_QWORD *)(v4 + 26640)) >> 32,
      0);
    HIBYTE(a3) = 0;
    LOBYTE(v48) = 0;
    if ( !v55 )
    {
      LOBYTE(v48) = *(_BYTE *)(v4 + 41524);
      if ( !(_BYTE)v48 )
        goto LABEL_175;
    }
    v13 = *(_BYTE *)(*(_DWORD *)(v5 + 8) + 20929);
    LOBYTE(v12) = v13 && (_WORD)v50 != 73;
    if ( !sub_411257((int)Destination, v13 == 0, v12, v48) )
      return 0;
    sub_406CC8((_DWORD *)v5, v4, Destination, (wchar_t *)(v5 + 19448), 2048);
    if ( (_BYTE)v48 || !*(_WORD *)(v5 + 19448) || (v15 = *(_BYTE *)(v4 + 26704) == 0, HIBYTE(a3) = 1, !v15) )
      HIBYTE(a3) = 0;
    v14 = *(_DWORD *)(v5 + 8);
    if ( !*(_BYTE *)(v14 + 20815) && !*(_BYTE *)(v14 + 20816) || (_WORD)v50 != 69 && (_WORD)v50 != 88 )
    {
LABEL_54:
      if ( *(_BYTE *)(v4 + 26707) )
      {
        if ( !sub_407121((_BYTE *)v5, v4, Destination) )
        {
          *(_BYTE *)(v5 + 23544) = 1;
          return 0;
        }
        if ( !*(_BYTE *)(v5 + 19444) )
        {
          sub_406222(&dword_432A6C, 1);
          HIBYTE(a3) = 0;
        }
      }
      if ( !sub_4073CE(v4, (int)Destination) )
      {
        HIBYTE(a3) = 0;
        sub_406222(&dword_432A6C, 2);
      }
      sub_408533(v40);
      v57 = 0;
      v16 = *(_DWORD *)(v4 + 26808);
      v52 = v16 != 0;
      if ( !v16 || v16 == 5 )
      {
        if ( sub_401A91((_BYTE *)v4) )
        {
          if ( !HIBYTE(a3)
            || (_WORD)v50 == 80
            || (_WORD)v50 == 73
            || (_WORD)v50 == 69
            || *(_DWORD *)(*(_DWORD *)(v5 + 8) + 20820) == 1 )
          {
            v57 = -1;
            sub_4089F9((int)v40);
            return 1;
          }
          ++*(_DWORD *)(v5 + 15076);
          sub_40715B(v5, v4, (int)Destination);
          v17 = 1;
LABEL_78:
          v57 = -1;
          sub_4089F9((int)v40);
          return v17;
        }
        if ( HIBYTE(a3) )
        {
          HIBYTE(a3) = sub_4072BB(v5, v4, (int)v40);
          goto LABEL_82;
        }
      }
      else if ( HIBYTE(a3) )
      {
        if ( (_WORD)v50 != 80 && !*(_BYTE *)(*(_DWORD *)(v5 + 8) + 20929) )
        {
          HIBYTE(a2) = 0;
          if ( sub_409026((WCHAR *)(v5 + 19448)) )
          {
            if ( HIBYTE(a2) )
            {
LABEL_70:
              HIBYTE(a3) = 0;
              goto LABEL_82;
            }
            sub_408465(
              *(_DWORD *)(v5 + 8),
              0,
              (WCHAR *)(v5 + 19448),
              2048,
              (_BYTE *)&a2 + 3,
              *(_QWORD *)(v4 + 26648),
              v4 + 26616,
              0);
          }
          if ( !HIBYTE(a2) )
            goto LABEL_82;
          goto LABEL_70;
        }
LABEL_82:
        if ( HIBYTE(a3) )
          goto LABEL_87;
      }
      if ( !*(_BYTE *)(v4 + 41524) )
      {
LABEL_173:
        v57 = -1;
        sub_4089F9((int)v40);
        if ( v55 )
          ++*(_DWORD *)(v5 + 15084);
LABEL_175:
        if ( *(_BYTE *)(v5 + 6256) )
          return 0;
        if ( HIBYTE(a3) )
          return 1;
        if ( *(_BYTE *)(v4 + 41524) )
          return (_BYTE)v48 != 0;
        goto LABEL_178;
      }
      LOBYTE(v48) = 1;
      HIBYTE(a3) = 1;
      if ( !sub_411257((int)Destination, 0, 0, 1) )
      {
        v17 = 0;
        goto LABEL_78;
      }
LABEL_87:
      if ( *(_BYTE *)(*(_DWORD *)(v5 + 8) + 20929) || (_BYTE)v48 )
      {
        v53 = 1;
        if ( (_BYTE)v48 )
          goto LABEL_93;
      }
      else
      {
        v53 = 0;
        if ( (_WORD)v50 != 80 && sub_4089D6(v40) )
        {
          sub_4062C8(58, v4 + 30, v5 + 19448);
          sub_40641C(&dword_432A6C, v4 + 30, v5 + 19448);
        }
      }
      ++*(_DWORD *)(v5 + 15076);
LABEL_93:
      v18 = v47;
      ++*(_DWORD *)(v47 + 15080);
      qmemcpy(Src, (const void *)(v18 + 19188), 0x102u);
      v33 = *(_DWORD *)(v4 + 26788);
      v32 = *(_BYTE *)(v4 + 26712) != 0 ? (void *)(v4 + 26713) : 0;
      v31 = *(_DWORD *)(v4 + 26708);
      LOBYTE(v57) = 1;
      v46 = v18 + 16;
      sub_40B544((_BYTE *)(v18 + 16), 0, v31, Src, v32, v4 + 26729, v33, Buf2, (void *)(v4 + 26755));
      v15 = *(_BYTE *)(v4 + 26707) == 0;
      v54 = 0;
      if ( !v15 && *(_BYTE *)(v4 + 26745) && memcmp((const void *)(v4 + 26746), Buf2, 8u) && !*(_BYTE *)(v4 + 41540) )
      {
        sub_4012DD(6, v4 + 30);
        sub_406222(&dword_432A6C, 11);
        v54 = 1;
      }
      v5 = v47;
      *(_DWORD *)(v47 + 6288) = 0;
      *(_DWORD *)(v5 + 6292) = 0;
      *(_DWORD *)(v5 + 6296) = 0;
      *(_DWORD *)(v5 + 6300) = 0;
      sub_4095F2((void *)(v5 + 12152), *(_DWORD *)(v4 + 26664), *(_DWORD *)(*(_DWORD *)(v5 + 8) + 29336));
      sub_4095F2((void *)(v5 + 6320), *(_DWORD *)(v4 + 26664), *(_DWORD *)(*(_DWORD *)(v5 + 8) + 29336));
      v19 = *(_DWORD *)(v4 + 26644);
      *(_DWORD *)(v5 + 48) = *(_DWORD *)(v4 + 26640);
      *(_DWORD *)(v5 + 52) = v19;
      sub_40B524((_DWORD *)v46, v4, (int)v40);
      v20 = v53;
      v21 = v48;
      *(_BYTE *)(v5 + 57) = v53;
      *(_BYTE *)(v5 + 58) = v21;
      if ( !v20 && !v54 && !*(_BYTE *)(v4 + 41540) )
      {
        v22 = *(_DWORD *)(v4 + 26652);
        v23 = *(_DWORD *)(v4 + 26648);
        if ( *(_QWORD *)(v4 + 26640) << 11 > __SPAIR64__(v22, v23)
          && (__SPAIR64__(v22, v23) < 100000000 || sub_408B84((int *)v4) > *(_QWORD *)(v4 + 26640)) )
        {
          sub_408D40((int *)v40, *(_QWORD *)(v4 + 26648));
        }
      }
      v24 = *(_DWORD *)(v5 + 8);
      v41 = *(_BYTE *)(v24 + 20884) == 0;
      if ( v53 || (_BYTE)v48 || (v56 = 1, (_WORD)v50 == 80) )
        v56 = 0;
      v49 = 1;
      HIBYTE(a2) = 1;
      if ( !v52 )
      {
        if ( !*(_BYTE *)(v4 + 26704) && !v54 )
        {
          if ( *(_BYTE *)(v4 + 22498) )
          {
            sub_412222(*(_DWORD *)(v5 + 15072), *(_DWORD *)(v4 + 26796), *(_BYTE *)(v4 + 26792));
            v28 = *(_DWORD *)(v5 + 15072);
            v29 = *(_DWORD *)(v4 + 26652);
            *(_DWORD *)(v28 + 19520) = *(_DWORD *)(v4 + 26648);
            *(_DWORD *)(v28 + 19524) = v29;
            *(_BYTE *)(v28 + 19544) = 0;
            sub_41861B(*(_DWORD *)(v5 + 15072), *(unsigned __int8 *)(v4 + 22497), *(_BYTE *)(v4 + 26792));
          }
          else
          {
            sub_406FC2((char *)v46, *(_DWORD *)(v4 + 26648), *(_DWORD *)(v4 + 26652));
          }
        }
LABEL_139:
        sub_4010BF((_DWORD *)v4);
        v30 = sub_409856(
                (int *)(v5 + 12152),
                (int *)(v4 + 26664),
                *(_BYTE *)(v4 + 26754) != 0 ? (char *)(v4 + 26755) : 0);
        if ( *(_BYTE *)(v4 + 26792) )
        {
          if ( *(_BYTE *)(v4 + 22498) && *(__int64 *)(v4 + 26648) > 0 && v30 )
            *(_BYTE *)(v5 + 15091) = 1;
        }
        else
        {
          *(_BYTE *)(v5 + 15091) = 0;
        }
        v56 = 0;
        if ( !(_BYTE)v48 && v49 )
        {
          if ( !v54 )
          {
            if ( v30 )
              goto LABEL_156;
            if ( !*(_BYTE *)(v4 + 26707) || *(_BYTE *)(v4 + 26745) && !*(_BYTE *)(v4 + 41540) || *(_BYTE *)(v5 + 15091) )
              sub_4062C8(3, v4 + 30, (int)Destination);
            else
              sub_4062C8(4, v4 + 30, (int)Destination);
          }
          v56 = 1;
          sub_406222(&dword_432A6C, 3);
        }
LABEL_156:
        if ( !v53
          && !v54
          && ((_WORD)v50 == 88 || (_WORD)v50 == 69)
          && (!v52 || *(_DWORD *)(v4 + 26808) == 5 && HIBYTE(a2)) )
        {
          if ( !v56 )
          {
LABEL_166:
            if ( *(_BYTE *)(*(_DWORD *)(v5 + 8) + 20812) )
              *(_DWORD *)(v4 + 22500) &= ~0x20u;
            sub_408AB6(
              (int)v40,
              *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25228) != 0 ? (int *)(v4 + 26616) : 0,
              *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25232) != 0 ? (int *)(v4 + 26624) : 0,
              *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25236) != 0 ? (int *)(v4 + 26632) : 0);
            sub_4087BE((int)v40);
            nullsub_1(
              *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25228) != 0 ? v4 + 26616 : 0,
              *(_DWORD *)(*(_DWORD *)(v5 + 8) + 25236) != 0 ? v4 + 26632 : 0);
            if ( !*(_BYTE *)(*(_DWORD *)(v5 + 8) + 20891) && !sub_408E0E(FileName, *(_DWORD *)(v4 + 22500)) )
              sub_4062C8(16, v4 + 30, (int)FileName);
            *(_BYTE *)(v5 + 19447) = 1;
            goto LABEL_172;
          }
          if ( *(_BYTE *)(*(_DWORD *)(v5 + 8) + 20884) )
          {
            sub_4089C3(v40);
            goto LABEL_166;
          }
        }
LABEL_172:
        LOBYTE(v57) = 0;
        sub_40CD93(Src);
        goto LABEL_173;
      }
      v25 = *(_DWORD *)(v4 + 26808);
      v45 = v25;
      if ( v25 == 4 || v25 == 5 )
      {
        sub_406CC8((_DWORD *)v5, v4, (wchar_t *)(v4 + 26812), String, 2048);
        if ( v56 && String[0] )
        {
          v34 = (wchar_t *)(v5 + 19448);
          if ( v45 == 4 )
            v26 = sub_406573(v34, (__int16 *)String, 2048);
          else
            v26 = sub_407059((int *)v40, v4 + 30, (int)v34, (__int16 *)String, 2048);
LABEL_125:
          HIBYTE(a2) = v26;
          if ( !v26 )
            goto LABEL_128;
        }
      }
      else
      {
        if ( v25 != 1 && v25 != 2 && v25 != 3 )
        {
          sub_4062C8(70, v4 + 30, v5 + 19448);
          HIBYTE(a2) = 0;
          goto LABEL_128;
        }
        if ( v56 )
        {
          v26 = sub_406AAD(v24, v46, v4, (wchar_t *)(v5 + 19448));
          goto LABEL_125;
        }
      }
      if ( *(_DWORD *)(v4 + 41520) != 2 )
        goto LABEL_129;
      if ( v56 )
      {
LABEL_130:
        if ( HIBYTE(a2) )
        {
          v27 = 1;
LABEL_133:
          *(_BYTE *)(v5 + 19447) = v27;
          goto LABEL_139;
        }
LABEL_132:
        v27 = 0;
        goto LABEL_133;
      }
LABEL_128:
      v49 = 0;
LABEL_129:
      if ( !v56 )
        goto LABEL_132;
      goto LABEL_130;
    }
    sub_4065D5(v36);
    if ( sub_409429((wchar_t *)(v5 + 19448), v36, 0) )
    {
      if ( !sub_406DE0(v38, v4 + 26616) )
        goto LABEL_54;
      if ( !v37 )
      {
LABEL_53:
        HIBYTE(a3) = 0;
        goto LABEL_54;
      }
      v15 = !sub_406DC2(v38, (_QWORD *)v5);
    }
    else
    {
      v15 = *(_BYTE *)(*(_DWORD *)(v5 + 8) + 20815) == 0;
    }
    if ( v15 )
      goto LABEL_54;
    goto LABEL_53;
  }
  if ( v8 != 3 )
    goto LABEL_10;
  if ( !*(_BYTE *)(v5 + 19447) )
  {
LABEL_178:
    sub_4010BF((_DWORD *)v4);
    return 1;
  }
  sub_406C70(*(_DWORD *)(v5 + 8), v4, (WCHAR *)(v5 + 19448));
LABEL_10:
  if ( v8 != 5 )
    goto LABEL_178;
  if ( *(_BYTE *)(v4 + 31460) )
  {
    if ( !sub_418659((_DWORD *)v4, v5 + 16, 0, v50) )
    {
      sub_406222(&dword_432A6C, 1);
      return 0;
    }
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v4 + 12))(
      v4,
      *(_DWORD *)(v4 + 41504),
      *(_DWORD *)(v4 + 41508),
      0);
    return 1;
  }
  return 0;
}
// 407902: conditional instruction was optimized away because %arg_4@3.1==0
// 40767F: variable 'v12' is possibly undefined
// 4089D3: using guessed type _DWORD __stdcall nullsub_1(_DWORD, _DWORD);
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);
// 432A6C: using guessed type int dword_432A6C;
// 407428: using guessed type unsigned int var_2194[14];
// 407428: using guessed type HANDLE var_115C[4];

//----- (00407F3E) --------------------------------------------------------
int __thiscall sub_407F3E(int this)
{
  unsigned int v2; // ebx
  bool i; // zf
  int v4; // eax
  __int16 v5; // cx
  int v6; // eax
  int v7; // eax
  int v9[7]; // [esp+Ch] [ebp-D2E0h] BYREF
  wchar_t Source[20747]; // [esp+2Ah] [ebp-D2C2h] BYREF
  char v11; // [esp+A241h] [ebp-30ABh]
  char v12; // [esp+A246h] [ebp-30A6h]
  char v13; // [esp+A251h] [ebp-309Bh]
  wchar_t v14[2048]; // [esp+B28Ch] [ebp-2060h] BYREF
  __int64 v15; // [esp+C28Ch] [ebp-1060h]
  wchar_t Destination[2050]; // [esp+C2D4h] [ebp-1018h] BYREF
  unsigned int v17; // [esp+D2D8h] [ebp-14h]
  char v18; // [esp+D2DFh] [ebp-Dh] BYREF
  int v19; // [esp+D2E8h] [ebp-4h]

  sub_40185E((int)v9, *(_BYTE **)(this + 8));
  v2 = 0;
  v19 = 0;
  if ( sub_4086AB(v9, this + 15092) )
  {
    if ( sub_40146C(v9, 1) )
    {
      if ( !v13 )
      {
        v17 = 0;
        if ( v11 )
        {
          wcscpy(Destination, Source);
          for ( i = v12 == 0; ; i = v12 == 0 )
          {
            sub_40A394(Destination, 2048, i);
            sub_4065D5(v14);
            if ( !sub_409429(Destination, v14, 0) )
              break;
            v17 = (v15 + __PAIR64__(v17, v2)) >> 32;
            v2 += v15;
          }
          *(_QWORD *)(this + 6312) += __PAIR64__(v17, v2);
        }
        sub_406E66(this, v9);
        v4 = *(_DWORD *)(this + 8);
        v5 = *(_WORD *)(v4 + 29362);
        if ( v5 == 84 || v5 == 73 )
          *(_BYTE *)(v4 + 20929) = 1;
        v6 = *(_DWORD *)(this + 8);
        if ( *(_WORD *)(v6 + 29362) != 73 )
          sub_41123B(*(_BYTE *)(v6 + 20929) == 0, (wchar_t *)(this + 15092));
        nullsub_2(v9);
        do
          v7 = sub_40363F(v9);
        while ( sub_407428(this, v9, v7, (int)&v18) );
      }
    }
    else if ( sub_40A27B((wchar_t *)(this + 15092), L"rar") )
    {
      sub_406222(&dword_432A6C, 1);
    }
  }
  v19 = -1;
  sub_401235((int)v9);
  return 0;
}
// 40363F: using guessed type int __thiscall sub_40363F(_DWORD);
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 432A6C: using guessed type int dword_432A6C;
// 407F3E: using guessed type int var_D2E0[7];
// 407F3E: using guessed type wchar_t Source[20747];

//----- (004080F3) --------------------------------------------------------
char __thiscall sub_4080F3(int this)
{
  int v2; // eax
  wchar_t *v3; // edi
  bool v4; // cf
  int v5; // eax
  int v6; // esi
  int v7; // eax
  _WORD *v8; // edi
  wchar_t Destination[2048]; // [esp+Ch] [ebp-115Ch] BYREF
  int v11; // [esp+100Ch] [ebp-15Ch]
  int v12; // [esp+1010h] [ebp-158h]
  _WORD v13[130]; // [esp+1054h] [ebp-114h] BYREF
  wchar_t *String; // [esp+1158h] [ebp-10h]
  int v15; // [esp+1164h] [ebp-4h]

  v2 = *(_DWORD *)(this + 8);
  *(_BYTE *)(this + 23544) = 0;
  *(_WORD *)(this + 6252) = *(_WORD *)(v2 + 29362);
  sub_4065D5(Destination);
  v3 = (wchar_t *)(this + 15092);
  String = (wchar_t *)(this + 15092);
  while ( sub_40532C(*(wchar_t **)(this + 8), (wchar_t *)(this + 15092), 2048) )
  {
    if ( sub_409429(v3, Destination, 0) )
    {
      v4 = __CFADD__(v11, *(_DWORD *)(this + 6312));
      *(_DWORD *)(this + 6312) += v11;
      *(_DWORD *)(this + 6316) += v12 + v4;
    }
  }
  sub_4108E4((_DWORD *)(*(_DWORD *)(this + 8) + 37864));
  LOBYTE(v5) = sub_40532C(*(wchar_t **)(this + 8), (wchar_t *)(this + 15092), 2048);
  if ( (_BYTE)v5 )
  {
    do
    {
      sub_40CD6F(v13);
      while ( 1 )
      {
        v6 = *(_DWORD *)(this + 8);
        v15 = 0;
        qmemcpy(v13, (const void *)(v6 + 16416), 0x102u);
        v7 = sub_407F3E(this);
        v8 = (_WORD *)(*(_DWORD *)(this + 8) + 16416);
        qmemcpy(v8, v13, 0x100u);
        v8[128] = v13[128];
        if ( v7 != 1 )
          break;
        v15 = -1;
        sub_40CD93(v13);
        sub_40CD6F(v13);
      }
      v15 = -1;
      sub_40CD93(v13);
      if ( sub_409429(String, Destination, 0) )
      {
        v4 = __CFADD__(v11, *(_DWORD *)(this + 6304));
        *(_DWORD *)(this + 6304) += v11;
        *(_DWORD *)(this + 6308) += v12 + v4;
      }
      LOBYTE(v5) = sub_40532C(*(wchar_t **)(this + 8), String, 2048);
    }
    while ( (_BYTE)v5 );
    v3 = String;
  }
  if ( !*(_DWORD *)(this + 15076) )
  {
    v5 = *(_DWORD *)(this + 8);
    if ( *(_WORD *)(v5 + 29362) != 73 && dword_432A6C != 11 )
    {
      if ( !*(_BYTE *)(this + 23544) )
        sub_4012DD(67, (int)v3);
      LOBYTE(v5) = sub_406222(&dword_432A6C, 10);
    }
  }
  return v5;
}
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);
// 432A6C: using guessed type int dword_432A6C;

//----- (00408295) --------------------------------------------------------
char __stdcall sub_408295(WCHAR *lpszShortPath)
{
  DWORD LongPathNameW; // eax
  DWORD ShortPathNameW; // eax
  wchar_t *v3; // eax
  const WCHAR *v4; // edi
  wchar_t *v5; // eax
  int v6; // edi
  wchar_t *v7; // eax
  bool v8; // bl
  WCHAR szLongPath[2048]; // [esp+Ch] [ebp-5034h] BYREF
  WCHAR szShortPath[2048]; // [esp+100Ch] [ebp-4034h] BYREF
  WCHAR ExistingFileName[2048]; // [esp+200Ch] [ebp-3034h] BYREF
  _DWORD v13[1033]; // [esp+300Ch] [ebp-2034h] BYREF
  WCHAR NewFileName[2048]; // [esp+4030h] [ebp-1010h] BYREF
  PCNZWCH lpString1; // [esp+5030h] [ebp-10h]
  int v16; // [esp+503Ch] [ebp-4h]

  LongPathNameW = GetLongPathNameW(lpszShortPath, szLongPath, 0x800u);
  if ( !LongPathNameW )
    return 0;
  if ( LongPathNameW >= 0x800 )
    return 0;
  ShortPathNameW = GetShortPathNameW(lpszShortPath, szShortPath, 0x800u);
  if ( !ShortPathNameW )
    return 0;
  if ( ShortPathNameW >= 0x800 )
    return 0;
  lpString1 = sub_40A0CE(szLongPath);
  v3 = sub_40A0CE(szShortPath);
  v4 = v3;
  if ( !*v3 )
    return 0;
  if ( !sub_4119A6(lpString1, v3) )
    return 0;
  v5 = sub_40A0CE(lpszShortPath);
  if ( sub_4119A6(v5, v4) )
    return 0;
  NewFileName[0] = 0;
  v6 = 0;
  while ( !NewFileName[0] )
  {
    sub_41078F(NewFileName, lpszShortPath, 2048);
    v7 = sub_40A0CE(NewFileName);
    swprintf(v7, 0x800u, L"rtmp%d", v6);
    if ( sub_409026(NewFileName) )
      NewFileName[0] = 0;
    v6 += 123;
    if ( v6 >= 10000 )
    {
      if ( !NewFileName[0] )
        return 0;
      break;
    }
  }
  sub_41078F(ExistingFileName, lpszShortPath, 2048);
  sub_40A238(ExistingFileName, (wchar_t *)lpString1, 2048);
  if ( !MoveFileW(ExistingFileName, NewFileName) )
    return 0;
  sub_408533(v13);
  v16 = 0;
  v8 = 0;
  if ( !sub_409026(lpszShortPath) )
    v8 = sub_4086D1((int)v13, lpszShortPath, 0xAu);
  MoveFileW(NewFileName, ExistingFileName);
  if ( v8 )
  {
    sub_4087BE((int)v13);
    sub_40880C((int)v13);
  }
  v16 = -1;
  sub_4089F9((int)v13);
  return 1;
}
// 408295: using guessed type _DWORD var_2034[1033];

//----- (00408465) --------------------------------------------------------
bool __stdcall sub_408465(int a1, int a2, WCHAR *lpFileName, int a4, _BYTE *a5, __int64 a6, int a7, char a8)
{
  char v8; // bl
  bool i; // al
  INT_PTR v10; // eax

  if ( a5 )
    *a5 = 0;
  v8 = 0;
  for ( i = sub_409026(lpFileName); ; i = sub_409026(lpFileName) )
  {
    if ( !i )
    {
LABEL_12:
      if ( a2 && sub_4086D1(a2, lpFileName, (a8 != 0) + 9) )
        return 1;
      sub_40903C(lpFileName);
      sub_4090CB(lpFileName, 1);
      if ( a2 )
        return sub_4086D1(a2, lpFileName, (a8 != 0) + 9);
      else
        return sub_408E65(lpFileName);
    }
    if ( v8 )
      break;
    v8 = 1;
    if ( !sub_408295(lpFileName) )
      break;
LABEL_10:
    ;
  }
  v8 = 0;
  v10 = sub_4114FE(a1, lpFileName, a4, a6, a7, a2 == 0);
  if ( !v10 )
    goto LABEL_12;
  if ( v10 != 1 )
  {
    if ( v10 == 6 )
      sub_4062C3(255);
    goto LABEL_10;
  }
  if ( a5 )
    *a5 = 1;
  return 0;
}

//----- (00408533) --------------------------------------------------------
_DWORD *__thiscall sub_408533(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1] = -1;
  *this = &off_42A614;
  *((_WORD *)this + 15) = 0;
  *((_BYTE *)this + 18) = 0;
  *((_BYTE *)this + 8) = 0;
  this[3] = 0;
  *((_BYTE *)this + 16) = 0;
  *((_BYTE *)this + 17) = 0;
  this[1032] = 0;
  *((_BYTE *)this + 28) = 0;
  *((_BYTE *)this + 19) = 1;
  *((_BYTE *)this + 20) = 1;
  *((_BYTE *)this + 21) = 0;
  this[6] = 256;
  return result;
}
// 42A614: using guessed type int (__thiscall *off_42A614)(void *, char);

//----- (00408570) --------------------------------------------------------
bool __thiscall sub_408570(int this, WCHAR *lpFileName, char a3)
{
  bool v4; // zf
  bool v5; // al
  DWORD v6; // edi
  char *FileW; // ebp
  DWORD dwShareMode; // [esp+10h] [ebp-100Ch]
  int dwFlagsAndAttributes; // [esp+14h] [ebp-1008h]
  DWORD LastError; // [esp+18h] [ebp-1004h]
  WCHAR FileName[2048]; // [esp+1Ch] [ebp-1000h] BYREF

  v4 = *(_BYTE *)(this + 28) == 0;
  *(_DWORD *)(this + 4128) = 0;
  v5 = !v4 || (a3 & 4) != 0;
  v6 = (a3 & 2) != 0 ? 0x40000000 : 0x80000000;
  if ( (a3 & 1) != 0 )
    v6 |= 0x40000000u;
  dwShareMode = 1;
  if ( v5 )
    dwShareMode = 3;
  dwFlagsAndAttributes = *(_BYTE *)(this + 21) != 0 ? 0 : 0x8000000;
  FileW = (char *)CreateFileW(lpFileName, v6, dwShareMode, 0, 3u, dwFlagsAndAttributes, 0);
  if ( FileW == (char *)-1 )
  {
    LastError = GetLastError();
    if ( !sub_40A582(lpFileName, FileName, 0x800u) )
      goto LABEL_14;
    FileW = (char *)CreateFileW(FileName, v6, dwShareMode, 0, 3u, dwFlagsAndAttributes, 0);
    if ( GetLastError() == 2 )
      LastError = 2;
    if ( FileW == (char *)-1 )
    {
LABEL_14:
      if ( LastError == 2 )
        *(_DWORD *)(this + 4128) = 1;
    }
  }
  *(_DWORD *)(this + 12) = 0;
  *(_BYTE *)(this + 18) = 0;
  *(_BYTE *)(this + 16) = 0;
  if ( FileW != (char *)-1 )
  {
    *(_DWORD *)(this + 4) = FileW;
    sub_41078F((wchar_t *)(this + 30), lpFileName, 2048);
  }
  return FileW + 1 != 0;
}

//----- (004086AB) --------------------------------------------------------
char __thiscall sub_4086AB(void *this, int a2)
{
  if ( (*(unsigned __int8 (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 4))(this, a2, 0) )
    return 1;
  sub_406439(&dword_432A6C, a2);
  return 0;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (004086D1) --------------------------------------------------------
BOOL __thiscall sub_4086D1(int this, WCHAR *lpFileName, DWORD dwShareMode)
{
  bool v4; // al
  bool v5; // dl
  HANDLE FileW; // eax
  WCHAR FileName[2048]; // [esp+Ch] [ebp-1004h] BYREF
  DWORD dwDesiredAccess; // [esp+100Ch] [ebp-4h]
  BOOL dwShareModea; // [esp+101Ch] [ebp+Ch]

  v4 = (dwShareMode & 2) != 0;
  v5 = (dwShareMode & 8) != 0 || *(_BYTE *)(this + 28);
  *(_DWORD *)(this + 24) = dwShareMode;
  dwDesiredAccess = (dwShareMode & 2) == 0 ? -1073741824 : 0x40000000;
  dwShareModea = v5;
  FileW = CreateFileW(lpFileName, !v4 ? -1073741824 : 0x40000000, dwShareModea, 0, 2u, 0, 0);
  *(_DWORD *)(this + 4) = FileW;
  if ( FileW == (HANDLE)-1 && sub_40A582(lpFileName, FileName, 0x800u) )
    *(_DWORD *)(this + 4) = CreateFileW(FileName, dwDesiredAccess, dwShareModea, 0, 2u, 0, 0);
  *(_BYTE *)(this + 18) = 1;
  *(_DWORD *)(this + 12) = 0;
  *(_BYTE *)(this + 16) = 0;
  sub_41078F((wchar_t *)(this + 30), lpFileName, 2048);
  return *(_DWORD *)(this + 4) != -1;
}

//----- (00408796) --------------------------------------------------------
char __thiscall sub_408796(void *this, WCHAR *lpFileName, DWORD dwShareMode)
{
  if ( sub_4086D1((int)this, lpFileName, dwShareMode) )
    return 1;
  sub_406447(&dword_432A6C, (int)lpFileName);
  return 0;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (004087BE) --------------------------------------------------------
bool __thiscall sub_4087BE(int this)
{
  bool v2; // bl

  v2 = 1;
  if ( *(_DWORD *)(this + 4) != -1 )
  {
    if ( !*(_BYTE *)(this + 16) && !*(_DWORD *)(this + 12) )
      v2 = CloseHandle(*(HANDLE *)(this + 4));
    *(_DWORD *)(this + 4) = -1;
  }
  *(_DWORD *)(this + 12) = 0;
  if ( !v2 && *(_BYTE *)(this + 20) )
    sub_40630A(&dword_432A6C, this + 30);
  return v2;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0040880C) --------------------------------------------------------
bool __thiscall sub_40880C(int this)
{
  if ( *(_DWORD *)(this + 12) )
    return 0;
  if ( *(_DWORD *)(this + 4) != -1 )
    sub_4087BE(this);
  return *(_BYTE *)(this + 19) && sub_408E65((WCHAR *)(this + 30));
}

//----- (00408835) --------------------------------------------------------
void __thiscall sub_408835(int *this, char *lpBuffer, DWORD nNumberOfBytesToWrite)
{
  __int64 v3; // rcx
  DWORD v5; // edi
  DWORD v6; // eax
  char v7; // al
  int v8; // edi
  __int64 v9; // rax
  DWORD NumberOfBytesWritten; // [esp+8h] [ebp-4h] BYREF

  HIDWORD(v3) = 0;
  if ( nNumberOfBytesToWrite )
  {
    if ( this[3] == 1 )
      this[1] = (int)GetStdHandle(0xFFFFFFF5);
    while ( 1 )
    {
      NumberOfBytesWritten = HIDWORD(v3);
      if ( this[3] == HIDWORD(v3) )
      {
        v7 = WriteFile(
               (HANDLE)this[1],
               lpBuffer,
               nNumberOfBytesToWrite,
               &NumberOfBytesWritten,
               (LPOVERLAPPED)HIDWORD(v3));
LABEL_12:
        if ( v7 != BYTE4(v3) )
          goto LABEL_20;
      }
      else
      {
        v5 = 0;
        while ( 1 )
        {
          v6 = 0x4000;
          if ( nNumberOfBytesToWrite - v5 < 0x4000 )
            v6 = nNumberOfBytesToWrite - v5;
          v7 = WriteFile((HANDLE)this[1], &lpBuffer[v5], v6, &NumberOfBytesWritten, (LPOVERLAPPED)HIDWORD(v3));
          if ( !v7 )
            break;
          v5 += 0x4000;
          if ( v5 >= nNumberOfBytesToWrite )
            goto LABEL_12;
        }
      }
      if ( *((_BYTE *)this + 20) == BYTE4(v3) || this[3] != HIDWORD(v3) )
        goto LABEL_20;
      if ( !sub_40629E(&dword_432A6C, (int)this + 30, SHIDWORD(v3)) )
        break;
      if ( NumberOfBytesWritten < nNumberOfBytesToWrite && NumberOfBytesWritten > HIDWORD(v3) )
      {
        v8 = *this;
        v9 = ((__int64 (__thiscall *)(int *, _DWORD))*(_DWORD *)(*this + 16))(this, HIDWORD(v3));
        v3 = NumberOfBytesWritten;
        (*(void (__thiscall **)(int *, _DWORD, _DWORD))(v8 + 12))(
          this,
          v9 - NumberOfBytesWritten,
          (v9 - (unsigned __int64)NumberOfBytesWritten) >> 32);
      }
    }
    sub_40641C(&dword_432A6C, SHIDWORD(v3), (int)this + 30);
LABEL_20:
    *((_BYTE *)this + 8) = 1;
  }
}
// 408867: conditional instruction was optimized away because %nNumberOfBytesToWrite.4!=0
// 432A6C: using guessed type int dword_432A6C;

//----- (0040892A) --------------------------------------------------------
int __thiscall sub_40892A(int this)
{
  DWORD v2; // edi
  void *v4; // [esp-14h] [ebp-20h]
  LONG DistanceToMoveHigh; // [esp+8h] [ebp-4h] BYREF

  if ( *(_DWORD *)(this + 4) == -1 )
  {
    if ( !*(_BYTE *)(this + 20) )
      return -1;
    sub_40632B(&dword_432A6C, this + 30);
  }
  v4 = *(void **)(this + 4);
  DistanceToMoveHigh = 0;
  v2 = SetFilePointer(v4, 0, &DistanceToMoveHigh, 1u);
  if ( v2 == -1 && GetLastError() )
  {
    if ( !*(_BYTE *)(this + 20) )
      return -1;
    sub_40632B(&dword_432A6C, this + 30);
  }
  return v2;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (004089AB) --------------------------------------------------------
char __fastcall sub_4089AB(int *a1)
{
  int v1; // eax
  char v3; // [esp+1h] [ebp-1h] BYREF

  v3 = HIBYTE(a1);
  v1 = *a1;
  v3 = 0;
  (*(void (__thiscall **)(int *, char *, int))(v1 + 8))(a1, &v3, 1);
  return v3;
}

//----- (004089C3) --------------------------------------------------------
BOOL __thiscall sub_4089C3(HANDLE *this)
{
  return SetEndOfFile(this[1]);
}

//----- (004089D6) --------------------------------------------------------
bool __thiscall sub_4089D6(HANDLE *this)
{
  DWORD FileType; // eax

  if ( this[1] == (HANDLE)-1 )
    return 0;
  FileType = GetFileType(this[1]);
  return FileType == 2 || FileType == 3;
}

//----- (004089F9) --------------------------------------------------------
bool __thiscall sub_4089F9(int this)
{
  bool v1; // zf
  bool result; // al

  v1 = *(_DWORD *)(this + 4) == -1;
  *(_DWORD *)this = &off_42A614;
  if ( !v1 && !*(_BYTE *)(this + 16) )
  {
    if ( *(_BYTE *)(this + 18) )
      return sub_40880C(this);
    else
      return sub_4087BE(this);
  }
  return result;
}
// 42A614: using guessed type int (__thiscall *off_42A614)(void *, char);

//----- (00408A1C) --------------------------------------------------------
DWORD __thiscall sub_408A1C(int this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead)
{
  DWORD v4; // edi
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-4h] BYREF

  v4 = 20000;
  if ( *(_DWORD *)(this + 12) == 1 )
  {
    if ( nNumberOfBytesToRead > 0x4E20 )
      nNumberOfBytesToRead = 20000;
    *(_DWORD *)(this + 4) = GetStdHandle(0xFFFFFFF6);
  }
  if ( ReadFile(*(HANDLE *)(this + 4), lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0) )
    return NumberOfBytesRead;
  if ( sub_4089D6((HANDLE *)this) && nNumberOfBytesToRead > 0x4E20 )
    return sub_408A1C(lpBuffer, v4);
  if ( *(_DWORD *)(this + 12) == 1 && GetLastError() == 109 )
    return 0;
  if ( !*(_DWORD *)(this + 12) )
  {
    v4 = 0x8000;
    if ( nNumberOfBytesToRead > 0x8000 && GetLastError() == 33 )
      return sub_408A1C(lpBuffer, v4);
  }
  return -1;
}

//----- (00408AB6) --------------------------------------------------------
BOOL __thiscall sub_408AB6(int this, int *a2, int *a3, int *a4)
{
  int v4; // eax
  bool v6; // zf
  bool v8; // bl
  FILETIME v10; // [esp+0h] [ebp-1Ch] BYREF
  FILETIME v11; // [esp+8h] [ebp-14h] BYREF
  FILETIME v12; // [esp+10h] [ebp-Ch] BYREF
  int v13; // [esp+18h] [ebp-4h]
  char v14; // [esp+27h] [ebp+Bh]
  char v15; // [esp+2Bh] [ebp+Fh]

  v4 = *(_DWORD *)(this + 24);
  v13 = this;
  if ( v4 != 256 && (v4 & 2) == 0 )
    FlushFileBuffers(*(HANDLE *)(this + 4));
  if ( !a2 || (v6 = *(_QWORD *)a2 == 0i64, v14 = 1, v6) )
    v14 = 0;
  if ( !a3 || (v6 = *(_QWORD *)a3 == 0i64, v15 = 1, v6) )
    v15 = 0;
  v8 = a4 && *(_QWORD *)a4;
  if ( v14 )
    sub_410EF6(a2, &v12);
  if ( v15 )
    sub_410EF6(a3, &v10);
  if ( v8 )
    sub_410EF6(a4, &v11);
  return SetFileTime(*(HANDLE *)(v13 + 4), v15 != 0 ? &v10 : 0, v8 ? &v11 : 0, v14 != 0 ? &v12 : 0);
}
// 408AB6: using guessed type FILETIME var_C;
// 408AB6: using guessed type FILETIME var_1C;
// 408AB6: using guessed type FILETIME var_14;

//----- (00408B84) --------------------------------------------------------
__int64 __thiscall sub_408B84(int *this)
{
  int v2; // eax
  __int64 v3; // rax
  __int64 v4; // kr00_8
  __int64 v6; // [esp+8h] [ebp-1Ch] BYREF
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+20h] [ebp-4h]

  sub_401188(&v6, (int)this);
  v2 = *this;
  v9 = 0;
  (*(void (__thiscall **)(int *, _DWORD, _DWORD, int))(v2 + 12))(this, 0, 0, 2);
  v3 = ((__int64 (__thiscall *)(int *))*(_DWORD *)(*this + 16))(this);
  v9 = -1;
  v4 = v3;
  (*(void (__thiscall **)(_DWORD, int, int, _DWORD))(*(_DWORD *)v6 + 12))(v6, v7, v8, 0);
  return v4;
}

//----- (00408BE0) --------------------------------------------------------
void *__thiscall sub_408BE0(void *this, char a2)
{
  sub_4089F9((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00408BFC) --------------------------------------------------------
DWORD __thiscall sub_408BFC(_BYTE *this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead)
{
  DWORD v5; // eax
  DWORD v6; // eax
  __int64 v7; // [esp+Ch] [ebp-10h]
  DWORD v8; // [esp+14h] [ebp-8h]
  DWORD i; // [esp+18h] [ebp-4h]

  v7 = 0i64;
  if ( this[17] )
    v7 = ((__int64 (__thiscall *)(_BYTE *))*(_DWORD *)(*(_DWORD *)this + 16))(this);
  while ( 1 )
  {
    v8 = sub_408A1C((int)this, lpBuffer, nNumberOfBytesToRead);
    if ( v8 != -1 )
      break;
    *((_DWORD *)this + 1032) = 2;
    if ( !this[20] )
      break;
    if ( this[17] )
    {
      v8 = 0;
      for ( i = 0; i < nNumberOfBytesToRead; v8 += v6 )
      {
        (*(void (__thiscall **)(_BYTE *, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 12))(
          this,
          v7 + i,
          (v7 + (unsigned __int64)i) >> 32,
          0);
        v5 = nNumberOfBytesToRead - i;
        if ( nNumberOfBytesToRead - i >= 0x200 )
          v5 = 512;
        v6 = sub_408A1C((int)this, lpBuffer, v5);
        if ( v6 == -1 )
          v6 = 512;
        i += 512;
      }
      return v8;
    }
    if ( *((_DWORD *)this + 3) || !sub_40621D((int)(this + 30)) )
    {
      sub_406463(&dword_432A6C, (int)(this + 30));
      return v8;
    }
  }
  return v8;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00408CCC) --------------------------------------------------------
bool __thiscall sub_408CCC(int *this, __int64 lDistanceToMove, DWORD dwMoveMethod)
{
  LONG v4; // edi
  __int64 v5; // rax
  LONG DistanceToMoveHigh; // [esp+4h] [ebp-4h] BYREF

  if ( this[1] == -1 )
    return 1;
  v4 = HIDWORD(lDistanceToMove);
  if ( lDistanceToMove < 0 && dwMoveMethod )
  {
    if ( dwMoveMethod == 1 )
      LODWORD(v5) = (*(int (__thiscall **)(int *))(*this + 16))(this);
    else
      v5 = sub_408B84(this);
    v4 = (unsigned __int64)(v5 + lDistanceToMove) >> 32;
    LODWORD(lDistanceToMove) = v5 + lDistanceToMove;
    dwMoveMethod = 0;
  }
  DistanceToMoveHigh = v4;
  return SetFilePointer((HANDLE)this[1], lDistanceToMove, &DistanceToMoveHigh, dwMoveMethod) != -1 || !GetLastError();
}
// 408D04: variable 'v5' is possibly undefined

//----- (00408D40) --------------------------------------------------------
char __thiscall sub_408D40(int *this, __int64 lDistanceToMove)
{
  char result; // al

  result = sub_408CCC(this, lDistanceToMove, 0);
  if ( result )
  {
    sub_4089C3((HANDLE *)this);
    return (*(int (__thiscall **)(int *, _DWORD, _DWORD, _DWORD))(*this + 12))(this, 0, 0, 0);
  }
  return result;
}

//----- (00408D6E) --------------------------------------------------------
void __thiscall sub_408D6E(int this, __int64 lDistanceToMove, DWORD dwMoveMethod)
{
  if ( !sub_408CCC((int *)this, lDistanceToMove, dwMoveMethod) )
  {
    if ( *(_BYTE *)(this + 20) )
      sub_40632B(&dword_432A6C, this + 30);
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00408D9D) --------------------------------------------------------
BOOL __stdcall sub_408D9D(int a1)
{
  return a1 != -1 && (a1 & 0x10) != 0;
}

//----- (00408DB5) --------------------------------------------------------
int __stdcall sub_408DB5(unsigned int a1)
{
  return (a1 >> 10) & 1;
}

//----- (00408DC2) --------------------------------------------------------
DWORD __stdcall sub_408DC2(WCHAR *lpFileName)
{
  DWORD FileAttributesW; // edi
  WCHAR FileName[2048]; // [esp+8h] [ebp-1000h] BYREF

  FileAttributesW = GetFileAttributesW(lpFileName);
  if ( FileAttributesW == -1 && sub_40A582(lpFileName, FileName, 0x800u) )
    return GetFileAttributesW(FileName);
  return FileAttributesW;
}

//----- (00408E0E) --------------------------------------------------------
bool __stdcall sub_408E0E(WCHAR *lpFileName, DWORD dwFileAttributes)
{
  BOOL v2; // eax
  bool v3; // bl
  WCHAR FileName[2048]; // [esp+8h] [ebp-1000h] BYREF

  v2 = SetFileAttributesW(lpFileName, dwFileAttributes);
  v3 = v2;
  if ( !v2 && sub_40A582(lpFileName, FileName, 0x800u) )
    return SetFileAttributesW(FileName, dwFileAttributes);
  return v3;
}

//----- (00408E65) --------------------------------------------------------
bool __stdcall sub_408E65(WCHAR *lpFileName)
{
  BOOL v1; // eax
  bool v2; // bl
  WCHAR FileName[2048]; // [esp+8h] [ebp-1000h] BYREF

  v1 = DeleteFileW(lpFileName);
  v2 = v1;
  if ( !v1 && sub_40A582(lpFileName, FileName, 0x800u) )
    return DeleteFileW(FileName);
  return v2;
}

//----- (00408EB6) --------------------------------------------------------
char __stdcall sub_408EB6(WCHAR *lpFileName, int *a2, int *a3, int *a4)
{
  bool v4; // zf
  DWORD v5; // eax
  HANDLE FileW; // eax
  WCHAR FileName[2048]; // [esp+Ch] [ebp-1024h] BYREF
  FILETIME v9; // [esp+100Ch] [ebp-24h] BYREF
  FILETIME v10; // [esp+1014h] [ebp-1Ch] BYREF
  FILETIME v11; // [esp+101Ch] [ebp-14h] BYREF
  DWORD dwFileAttributes; // [esp+1024h] [ebp-Ch]
  HANDLE hFile; // [esp+1028h] [ebp-8h]
  char v14; // [esp+102Ch] [ebp-4h]
  char v15; // [esp+102Dh] [ebp-3h]
  char v16; // [esp+102Eh] [ebp-2h]
  char v17; // [esp+102Fh] [ebp-1h]

  if ( !a2 || (v4 = *(_QWORD *)a2 == 0i64, v15 = 1, v4) )
    v15 = 0;
  if ( !a3 || (v4 = *(_QWORD *)a3 == 0i64, v16 = 1, v4) )
    v16 = 0;
  if ( !a4 || (v4 = *(_QWORD *)a4 == 0i64, v17 = 1, v4) )
    v17 = 0;
  v5 = sub_408DC2(lpFileName);
  dwFileAttributes = v5;
  if ( v5 == -1 || (v5 & 1) == 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    sub_408E0E(lpFileName, 0);
  }
  hFile = CreateFileW(lpFileName, 0x40000000u, 3u, 0, 3u, 0x2000000u, 0);
  if ( hFile != (HANDLE)-1
    || (LOBYTE(FileW) = sub_40A582(lpFileName, FileName, 0x800u), (_BYTE)FileW)
    && (FileW = CreateFileW(FileName, 0x40000000u, 3u, 0, 3u, 0x2000000u, 0), hFile = FileW, FileW != (HANDLE)-1) )
  {
    if ( v15 )
      sub_410EF6(a2, &v9);
    if ( v16 )
      sub_410EF6(a3, &v10);
    if ( v17 )
      sub_410EF6(a4, &v11);
    SetFileTime(hFile, v16 != 0 ? &v10 : 0, v17 != 0 ? &v11 : 0, v15 != 0 ? &v9 : 0);
    LOBYTE(FileW) = CloseHandle(hFile);
    if ( v14 )
      LOBYTE(FileW) = sub_408E0E(lpFileName, dwFileAttributes);
  }
  return (char)FileW;
}
// 408EB6: using guessed type FILETIME var_24;
// 408EB6: using guessed type FILETIME var_1C;
// 408EB6: using guessed type FILETIME var_14;

//----- (00409026) --------------------------------------------------------
bool __stdcall sub_409026(WCHAR *lpFileName)
{
  return sub_408DC2(lpFileName) != -1;
}

//----- (0040903C) --------------------------------------------------------
bool __stdcall sub_40903C(WCHAR *lpFileName)
{
  return sub_408E0E(lpFileName, 0);
}

//----- (0040904A) --------------------------------------------------------
int __stdcall sub_40904A(WCHAR *lpPathName, char a2, DWORD dwFileAttributes)
{
  DWORD LastError; // eax
  WCHAR PathName[2048]; // [esp+8h] [ebp-1000h] BYREF

  if ( CreateDirectoryW(lpPathName, 0)
    || !sub_409026(lpPathName) && sub_40A582(lpPathName, PathName, 0x800u) && CreateDirectoryW(PathName, 0) )
  {
    if ( a2 )
      sub_408E0E(lpPathName, dwFileAttributes);
    return 0;
  }
  else
  {
    LastError = GetLastError();
    if ( LastError == 2 || LastError == 3 )
      return 2;
    else
      return 1;
  }
}

//----- (004090CB) --------------------------------------------------------
bool __stdcall sub_4090CB(wchar_t *Source, char a2)
{
  wchar_t *v2; // esi
  bool v3; // bl
  int v4; // edi
  wchar_t *v5; // eax
  wchar_t Destination[2048]; // [esp+4h] [ebp-1004h] BYREF
  int v8; // [esp+1004h] [ebp-4h]

  v2 = Source;
  if ( !Source || !*Source )
    return 0;
  v8 = 0;
  v3 = 1;
  do
  {
    v4 = v8 >> 1;
    if ( (unsigned int)(v8 >> 1) >= 0x800 )
      break;
    if ( sub_409DC6(*Source) && (Source != v2 + 2 || v2[1] != 58) )
    {
      wcsncpy(Destination, v2, v4);
      Destination[v4] = 0;
      v3 = sub_40904A(Destination, 1, 0) == 0;
    }
    ++Source;
    v8 += 2;
  }
  while ( *Source );
  if ( !a2 )
  {
    v5 = sub_409D8B(v2);
    if ( !sub_409DC6(*v5) )
      return sub_40904A(v2, 1, 0) == 0;
  }
  return v3;
}
// 4090CB: using guessed type wchar_t Destination[2048];

//----- (004091A0) --------------------------------------------------------
_DWORD *__thiscall sub_4091A0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[1025] = -1;
  *(_WORD *)this = 0;
  *((_BYTE *)this + 4096) = 1;
  return result;
}

//----- (004091B6) --------------------------------------------------------
HANDLE __thiscall sub_4091B6(HANDLE *this)
{
  HANDLE result; // eax

  result = this[1025];
  if ( result != (HANDLE)-1 )
    return (HANDLE)FindClose(this[1025]);
  return result;
}

//----- (004091C9) --------------------------------------------------------
wchar_t *__thiscall sub_4091C9(wchar_t *Destination, wchar_t *Source)
{
  wchar_t *result; // eax

  result = wcscpy(Destination, Source);
  *((_BYTE *)Destination + 4096) = 1;
  return result;
}

//----- (004091E3) --------------------------------------------------------
int __stdcall sub_4091E3(int hFindFile, WCHAR *lpFileName, wchar_t *Destination)
{
  DWORD LastError; // eax
  bool v4; // al
  unsigned __int64 v5; // rax
  WCHAR FileName[2048]; // [esp+Ch] [ebp-1250h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+100Ch] [ebp-250h] BYREF

  if ( hFindFile == -1 )
  {
    hFindFile = (int)FindFirstFileW(lpFileName, &FindFileData);
    if ( hFindFile == -1 )
    {
      if ( !sub_40A582(lpFileName, FileName, 0x800u)
        || (hFindFile = (int)FindFirstFileW(FileName, &FindFileData), hFindFile == -1) )
      {
        LastError = GetLastError();
        v4 = LastError != 2 && LastError != 3 && LastError != 18;
        *((_BYTE *)Destination + 4164) = v4;
        goto LABEL_15;
      }
    }
LABEL_14:
    sub_41078F(Destination, lpFileName, 2048);
    sub_40A238(Destination, FindFileData.cFileName, 2048);
    v5 = (unsigned __int64)FindFileData.nFileSizeHigh << 32;
    *((_DWORD *)Destination + 1024) = FindFileData.nFileSizeLow;
    *((_DWORD *)Destination + 1026) = FindFileData.dwFileAttributes;
    *((FILETIME *)Destination + 517) = FindFileData.ftCreationTime;
    *((FILETIME *)Destination + 518) = FindFileData.ftLastAccessTime;
    *((FILETIME *)Destination + 519) = FindFileData.ftLastWriteTime;
    *((_DWORD *)Destination + 1025) = HIDWORD(v5);
    sub_410EE3((_DWORD *)Destination + 1028, &FindFileData.ftLastWriteTime.dwLowDateTime);
    sub_410EE3((_DWORD *)Destination + 1030, &FindFileData.ftCreationTime.dwLowDateTime);
    sub_410EE3((_DWORD *)Destination + 1032, &FindFileData.ftLastAccessTime.dwLowDateTime);
    goto LABEL_15;
  }
  if ( !FindNextFileW((HANDLE)hFindFile, &FindFileData) )
  {
    hFindFile = -1;
    *((_BYTE *)Destination + 4164) = GetLastError() != 18;
  }
  if ( hFindFile != -1 )
    goto LABEL_14;
LABEL_15:
  *((_DWORD *)Destination + 1040) = 0;
  return hFindFile;
}

//----- (0040937B) --------------------------------------------------------
char __thiscall sub_40937B(WCHAR *lpFileName, wchar_t *String, int a3)
{
  int v4; // eax
  bool v5; // al
  wchar_t *v6; // ebp
  int v8; // [esp-4h] [ebp-14h]
  unsigned int v9; // [esp-4h] [ebp-14h]

  do
  {
    *((_BYTE *)String + 4164) = 0;
    if ( !*lpFileName )
      return 0;
    if ( *((_BYTE *)lpFileName + 4096) )
    {
      v4 = sub_4091E3(-1, lpFileName, String);
      *((_DWORD *)lpFileName + 1025) = v4;
    }
    else
    {
      v4 = sub_4091E3(*((_DWORD *)lpFileName + 1025), lpFileName, String);
    }
    if ( v4 == -1 )
      return 0;
    v8 = *((_DWORD *)String + 1026);
    *((_DWORD *)String + 1040) = 0;
    v5 = sub_408D9D(v8);
    v9 = *((_DWORD *)String + 1026);
    *((_BYTE *)String + 4108) = v5;
    *((_BYTE *)String + 4109) = sub_408DB5(v9);
    *((_BYTE *)lpFileName + 4096) = 0;
    v6 = sub_40A0CE(String);
  }
  while ( !wcscmp(v6, L".") || !wcscmp(v6, L"..") );
  return 1;
}

//----- (00409429) --------------------------------------------------------
char __stdcall sub_409429(wchar_t *String, wchar_t *Destination, int a3)
{
  void *v4; // eax
  bool v5; // al
  unsigned int v6; // [esp-8h] [ebp-Ch]

  *((_BYTE *)Destination + 4164) = 0;
  if ( sub_409DA5(String) )
    return 0;
  v4 = (void *)sub_4091E3(-1, String, Destination);
  if ( v4 == (void *)-1 )
    return 0;
  FindClose(v4);
  *((_DWORD *)Destination + 1040) = 0;
  v5 = sub_408D9D(*((_DWORD *)Destination + 1026));
  v6 = *((_DWORD *)Destination + 1026);
  *((_BYTE *)Destination + 4108) = v5;
  *((_BYTE *)Destination + 4109) = sub_408DB5(v6);
  return 1;
}

//----- (0040948D) --------------------------------------------------------
int __thiscall sub_40948D(int this, char a2)
{
  void *v3; // eax

  *(_BYTE *)(this + 8) = 0;
  if ( a2 )
  {
    v3 = operator new[](0x8003u);
    *(_DWORD *)(this + 12) = v3;
    memset(v3, 0, 0x8003u);
  }
  else
  {
    *(_DWORD *)(this + 12) = 0;
  }
  return this;
}

//----- (004094C3) --------------------------------------------------------
void __thiscall sub_4094C3(int this)
{
  if ( !*(_BYTE *)(this + 8) )
    operator delete[](*(void **)(this + 12));
}

//----- (004094D3) --------------------------------------------------------
int __thiscall sub_4094D3(int this, int a2)
{
  int result; // eax

  if ( *(_DWORD *)(this + 12) && !*(_BYTE *)(this + 8) )
    operator delete[](*(void **)(this + 12));
  result = a2;
  *(_DWORD *)(this + 12) = a2;
  *(_BYTE *)(this + 8) = 1;
  return result;
}

//----- (004094F9) --------------------------------------------------------
int __thiscall sub_4094F9(_DWORD *this)
{
  return (unsigned __int16)((unsigned int)(*(unsigned __int8 *)(this[3] + *this + 2) | ((*(unsigned __int8 *)(this[3] + *this + 1) | (*(unsigned __int8 *)(this[3] + *this) << 8)) << 8)) >> (8 - *((_BYTE *)this + 4)));
}

//----- (00409527) --------------------------------------------------------
int __thiscall sub_409527(_DWORD *this, int a2)
{
  unsigned int v2; // eax
  int result; // eax

  v2 = a2 + this[1];
  *this += v2 >> 3;
  result = v2 & 7;
  this[1] = result;
  return result;
}

//----- (00409543) --------------------------------------------------------
void *__thiscall sub_409543(_DWORD *this, void *a2)
{
  void *result; // eax

  result = a2;
  *this = a2;
  if ( a2 == (void *)1 || a2 == (void *)2 )
    this[1] = 0;
  if ( a2 == (void *)3 )
    return memcpy(this + 1, &unk_42F01C, 0x20u);
  return result;
}

//----- (00409572) --------------------------------------------------------
bool __thiscall sub_409572(int *this, int *a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // eax

  v2 = *this;
  if ( !*this )
    return 1;
  v3 = *a2;
  if ( !*a2 )
    return 1;
  if ( v2 == 1 && v3 == 1 || v2 == 2 && v3 == 2 )
  {
    v4 = this[1] - a2[1];
    return v4 == 0;
  }
  if ( v2 == 3 && v3 == 3 )
  {
    v4 = memcmp(this + 1, a2 + 1, 0x20u);
    return v4 == 0;
  }
  return 0;
}

//----- (004095C9) --------------------------------------------------------
_BYTE *__thiscall sub_4095C9(int this)
{
  sub_410DB4(*(void **)(this + 2908));
  sub_40CC38((_BYTE *)(this + 8), 2900);
  return sub_40CC38((_BYTE *)(this + 4), 4);
}

//----- (004095F2) --------------------------------------------------------
int __thiscall sub_4095F2(void *this, int a2, unsigned int a3)
{
  int result; // eax

  *(_DWORD *)this = a2;
  if ( a2 == 1 )
    *((_DWORD *)this + 1) = 0;
  if ( a2 == 2 )
    *((_DWORD *)this + 1) = -1;
  if ( a2 == 3 )
    sub_404DD4((char *)this + 8);
  result = a3;
  if ( a3 >= 8 )
    result = 8;
  *((_DWORD *)this + 728) = result;
  return result;
}

//----- (00409631) --------------------------------------------------------
void __thiscall sub_409631(void *this, char *Src, int a3)
{
  if ( *(_DWORD *)this == 2 )
    *((_DWORD *)this + 1) = sub_405595(*((_DWORD *)this + 1), Src, a3);
  if ( *(_DWORD *)this == 3 )
  {
    if ( *((_DWORD *)this + 728) > 1u && !*((_DWORD *)this + 727) )
      *((_DWORD *)this + 727) = sub_410C7D();
    *((_DWORD *)this + 725) = *((_DWORD *)this + 727);
    *((_DWORD *)this + 726) = *((_DWORD *)this + 728);
    sub_404E91((char *)this + 8, Src, a3);
  }
}

//----- (0040969B) --------------------------------------------------------
int __stdcall sub_40969B(int a1, int a2, int a3, int a4, int (__thiscall *a5)(int, int))
{
  int result; // eax
  int i; // [esp+14h] [ebp+14h]

  for ( i = a4 - 1; i >= 0; --i )
  {
    result = a5(a1, a2);
    a1 += a3;
    a2 += a3;
  }
  return result;
}

//----- (004096C2) --------------------------------------------------------
char *__fastcall sub_4096C2(_DWORD *a1)
{
  char *v1; // eax
  char *result; // eax

  v1 = (char *)a1 + (-(char)a1 & 0x3F);
  a1[60] = v1;
  v1 += 128;
  a1[61] = v1;
  v1 += 32;
  a1[62] = v1;
  result = v1 + 8;
  a1[63] = result;
  return result;
}

//----- (004096EE) --------------------------------------------------------
int __thiscall sub_4096EE(int this, int a2)
{
  if ( this != a2 )
  {
    memcpy(*(void **)(this + 240), *(const void **)(a2 + 240), 0xB0u);
    *(_DWORD *)(this + 256) = *(_DWORD *)(a2 + 256);
    *(_BYTE *)(this + 260) = *(_BYTE *)(a2 + 260);
  }
  return this;
}

//----- (00409732) --------------------------------------------------------
_DWORD *__thiscall sub_409732(_DWORD *this, int a2)
{
  sub_4096C2(this);
  sub_4096EE((int)this, a2);
  return this;
}

//----- (0040974B) --------------------------------------------------------
_DWORD *__thiscall sub_40974B(_DWORD *this)
{
  _DWORD *v2; // edi
  int i; // ebx

  v2 = this;
  for ( i = 7; i >= 0; --i )
  {
    sub_4096C2(v2);
    v2 += 66;
  }
  sub_4096C2(this + 528);
  return this;
}

//----- (00409776) --------------------------------------------------------
_DWORD *__thiscall sub_409776(_DWORD *this, int a2)
{
  sub_40969B((int)this, a2, 264, 8, (int (__thiscall *)(int, int))sub_409732);
  sub_409732(this + 528, a2 + 2112);
  qmemcpy(this + 594, (const void *)(a2 + 2376), 0x20Cu);
  return this;
}

//----- (004097E5) --------------------------------------------------------
_DWORD *__thiscall sub_4097E5(_DWORD *this)
{
  sub_40974B(this + 2);
  *this = 0;
  this[727] = 0;
  this[728] = 0;
  return this;
}

//----- (00409804) --------------------------------------------------------
int __thiscall sub_409804(int *this, int *a2)
{
  int result; // eax
  _DWORD Src[725]; // [esp+4h] [ebp-B54h] BYREF

  result = *this;
  *a2 = *this;
  if ( *this == 1 )
  {
    result = this[1];
    a2[1] = result;
  }
  if ( *this == 2 )
  {
    result = ~this[1];
    a2[1] = result;
  }
  if ( *this == 3 )
  {
    sub_409776(Src, (int)(this + 2));
    return sub_404FF9((char *)Src, (int)(a2 + 1));
  }
  return result;
}

//----- (00409856) --------------------------------------------------------
bool __thiscall sub_409856(int *this, int *a2, char *a3)
{
  int v4[9]; // [esp+0h] [ebp-24h] BYREF

  sub_409804(this, v4);
  if ( a3 )
    sub_405E60(v4, a3);
  return sub_409572(v4, a2);
}

//----- (00409886) --------------------------------------------------------
int __thiscall sub_409886(int this)
{
  int result; // eax

  result = 0;
  *(_WORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 28) = 0;
  *(_BYTE *)(this + 29) = 0;
  *(_BYTE *)(this + 30) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  return result;
}

//----- (004098B1) --------------------------------------------------------
void *__thiscall sub_4098B1(int this, unsigned int a2)
{
  void *result; // eax

  sub_401C05((_DWORD *)(this + 4128), a2);
  *(_BYTE *)(this + 16) = 0;
  result = sub_409543((_DWORD *)(this + 4192), 0);
  *(_DWORD *)(this + 4144) = 0;
  *(_DWORD *)(this + 4148) = 0;
  *(_DWORD *)(this + 4160) = 0;
  *(_DWORD *)(this + 4164) = 0;
  *(_DWORD *)(this + 4152) = 0;
  *(_DWORD *)(this + 4156) = 0;
  *(_BYTE *)(this + 4232) = 0;
  *(_BYTE *)(this + 4233) = 0;
  *(_BYTE *)(this + 4234) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 4236) = 0;
  *(_BYTE *)(this + 4235) = 0;
  *(_BYTE *)(this + 4240) = 0;
  *(_BYTE *)(this + 4273) = 0;
  *(_BYTE *)(this + 4282) = 0;
  *(_DWORD *)(this + 4316) = 0;
  *(_BYTE *)(this + 4320) = 0;
  *(_BYTE *)(this + 4321) = 0;
  *(_DWORD *)(this + 4324) = 0;
  *(_BYTE *)(this + 4328) = 0;
  *(_BYTE *)(this + 4330) = 0;
  *(_BYTE *)(this + 4322) = 0;
  *(_BYTE *)(this + 4323) = 0;
  *(_BYTE *)(this + 4329) = 0;
  *(_DWORD *)(this + 4336) = 0;
  *(_BYTE *)(this + 8437) = 0;
  return result;
}

//----- (00409973) --------------------------------------------------------
int __stdcall sub_409973(int C, char a2)
{
  if ( a2 )
    return C;
  else
    return sub_411A29(C);
}
// 409973: using guessed type _DWORD C;

//----- (0040998C) --------------------------------------------------------
int __stdcall sub_40998C(wchar_t *String1, wchar_t *String2, char a3)
{
  if ( a3 )
    return wcscmp(String1, String2);
  else
    return sub_41078A(String1, String2);
}

//----- (004099AD) --------------------------------------------------------
int __stdcall sub_4099AD(wchar_t *String1, wchar_t *String2, size_t MaxCount, char a4)
{
  if ( a4 )
    return wcsncmp(String1, String2, MaxCount);
  else
    return sub_4119C7(String1, String2, MaxCount);
}

//----- (004099D2) --------------------------------------------------------
bool __stdcall sub_4099D2(unsigned __int16 *a1, wchar_t *Str, char a3)
{
  __int16 v5; // di
  __int16 v6; // cx
  bool result; // al
  wchar_t *v8; // edi
  wchar_t *v9; // edi
  char v10; // al
  wchar_t *Stra; // [esp+18h] [ebp+Ch]

  while ( 1 )
  {
    v5 = sub_409973(*Str, a3);
    v6 = sub_409973(*a1++, a3);
    if ( !v6 )
      return v5 == 0;
    if ( v6 == 42 )
      break;
    if ( v6 == 63 )
    {
      if ( !v5 )
        return 0;
LABEL_11:
      ++Str;
    }
    else
    {
      if ( v6 == v5 )
        goto LABEL_11;
      if ( v6 != 46 || v5 && v5 != 92 && v5 != 46 )
        return 0;
    }
  }
  if ( !*a1 )
    return 1;
  if ( *a1 != 46 )
    goto LABEL_26;
  Stra = a1 + 1;
  if ( a1[1] == 42 && !a1[2] )
    return 1;
  v8 = wcschr(Str, 0x2Eu);
  result = 0;
  if ( *Stra )
  {
    if ( !v8 || (Str = v8, wcspbrk(a1, L"*?")) || (v9 = v8 + 1, wcschr(v9, 0x2Eu)) )
    {
LABEL_26:
      while ( *Str )
      {
        v10 = sub_4099D2((int)a1, Str++, a3);
        if ( v10 )
          return 1;
      }
      return 0;
    }
    return sub_40998C(Stra, v9, a3) == 0;
  }
  else if ( !v8 || !v8[1] )
  {
    return 1;
  }
  return result;
}

//----- (00409AF8) --------------------------------------------------------
char __stdcall sub_409AF8(wchar_t *String, wchar_t *Source, int a3)
{
  unsigned __int16 *v3; // ebx
  bool v4; // zf
  int v5; // edi
  size_t v6; // eax
  size_t v7; // esi
  wchar_t v8; // ax
  int v10; // eax
  size_t v11; // eax
  wchar_t *v12; // esi
  wchar_t *v13; // [esp-8h] [ebp-2014h]
  char v14; // [esp-4h] [ebp-2010h]
  wchar_t String2[2048]; // [esp+Ch] [ebp-2000h] BYREF
  wchar_t Destination[2048]; // [esp+100Ch] [ebp-1000h] BYREF
  bool v17; // [esp+201Ch] [ebp+10h]

  v3 = String;
  v5 = (unsigned __int16)a3;
  v4 = (unsigned __int16)a3 == 0;
  v17 = a3 < 0;
  if ( !v4 )
  {
    v6 = wcslen(String);
    v7 = v6;
    if ( v5 != 2 && v5 != 3 && !sub_4099AD(String, Source, v6, v17) )
    {
      v8 = Source[v7];
      if ( v8 == 92 || v8 == 47 || !v8 )
        return 1;
    }
    if ( v5 == 1 )
      return 0;
    sub_40A2A1(String, Destination, 2048);
    sub_40A2A1(Source, String2, 2048);
    if ( v5 == 2 || v5 == 3 )
    {
      if ( sub_40998C(Destination, String2, v17) )
        return 0;
    }
    if ( v5 == 4 || v5 == 5 )
    {
      if ( sub_409DA5(Destination) )
      {
        v14 = v17;
        v13 = Source;
        return sub_4099D2(v3, v13, v14);
      }
      if ( v5 == 4 || sub_409DA5(String) )
      {
        if ( !Destination[0] )
          goto LABEL_25;
        v11 = wcslen(Destination);
        v10 = sub_4099AD(Destination, String2, v11, v17);
      }
      else
      {
        v10 = sub_40998C(Destination, String2, v17);
      }
      if ( v10 )
        return 0;
    }
  }
LABEL_25:
  v3 = sub_40A0CE(String);
  v12 = sub_40A0CE(Source);
  if ( !sub_4119C7(L"__rar_", v12, 6u) )
    return 0;
  v14 = v17;
  v13 = v12;
  if ( v5 != 2 )
    return sub_4099D2(v3, v13, v14);
  return sub_40998C(v3, v12, v17) == 0;
}

//----- (00409C86) --------------------------------------------------------
unsigned int __thiscall sub_409C86(void *this)
{
  unsigned int result; // eax

  memset(this, 0, 0x72A8u);
  *((_DWORD *)this + 5195) = 0;
  *((_DWORD *)this + 5193) = 0;
  *((_DWORD *)this + 5217) = 0;
  *((_DWORD *)this + 3) = 0x2000000;
  *((_DWORD *)this + 5196) = 3;
  *((_DWORD *)this + 6307) = 4;
  *((_DWORD *)this + 5228) = 0x7FFFFFFF;
  *((_DWORD *)this + 5229) = 0x7FFFFFFF;
  *((_DWORD *)this + 5230) = 0x7FFFFFFF;
  *((_DWORD *)this + 5231) = 0x7FFFFFFF;
  *((_DWORD *)this + 5197) = 2;
  result = sub_410B1D();
  *((_DWORD *)this + 7334) = result;
  return result;
}

//----- (00409CFD) --------------------------------------------------------
int __thiscall sub_409CFD(void **this)
{
  memset(this, 0, 0x72A8u);
  sub_401105(this + 5210);
  return sub_40CD93(this + 4104);
}
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);

//----- (00409D27) --------------------------------------------------------
int __thiscall sub_409D27(int this)
{
  sub_40CD6F((_BYTE *)(this + 16416));
  *(_DWORD *)(this + 20840) = 0;
  *(_DWORD *)(this + 20844) = 0;
  *(_DWORD *)(this + 20848) = 0;
  *(_DWORD *)(this + 20852) = 0;
  *(_DWORD *)(this + 20896) = 0;
  *(_DWORD *)(this + 20900) = 0;
  *(_DWORD *)(this + 20904) = 0;
  *(_DWORD *)(this + 20908) = 0;
  sub_409C86((void *)this);
  return this;
}

//----- (00409D8B) --------------------------------------------------------
wchar_t *__stdcall sub_409D8B(wchar_t *String)
{
  size_t v1; // eax
  bool v2; // zf
  wchar_t *result; // eax

  v1 = wcslen(String);
  v2 = v1 == 0;
  result = &String[v1 - 1];
  if ( v2 )
    return String;
  return result;
}

//----- (00409DA5) --------------------------------------------------------
BOOL __stdcall sub_409DA5(wchar_t *String)
{
  BOOL result; // eax

  result = 0;
  if ( String )
    return wcspbrk(String, L"*?") != 0;
  return result;
}

//----- (00409DC6) --------------------------------------------------------
BOOL __stdcall sub_409DC6(int a1)
{
  return a1 == 92 || a1 == 47;
}

//----- (00409DDE) --------------------------------------------------------
BOOL __stdcall sub_409DDE(int a1)
{
  return a1 == 58;
}

//----- (00409DEB) --------------------------------------------------------
wchar_t *__stdcall sub_409DEB(wchar_t *String, unsigned int a2)
{
  wchar_t *result; // eax

  result = (wchar_t *)wcslen(String);
  if ( result && String[(_DWORD)result - 1] != 92 )
  {
    result = (wchar_t *)((char *)result + 1);
    if ( (unsigned int)result < a2 )
      return wcscat(String, L"\\");
  }
  return result;
}

//----- (00409E1B) --------------------------------------------------------
wchar_t *__stdcall sub_409E1B(wchar_t *Source, wchar_t *a2, wchar_t *Destination, int a4)
{
  wchar_t String[2048]; // [esp+4h] [ebp-1000h] BYREF

  sub_41078F(String, Source, 2048);
  sub_409DEB(String, 0x800u);
  sub_4107BC(String, a2, 0x800u);
  return sub_41078F(Destination, String, a4);
}

//----- (00409E72) --------------------------------------------------------
bool __stdcall sub_409E72(wchar_t *String)
{
  wchar_t v2; // ax
  wchar_t *v3; // ecx

  if ( *String && String[1] && wcschr(String + 2, 0x3Au) )
    return 0;
  v2 = *String;
  v3 = String;
  if ( *String )
  {
    while ( v2 >= 0x20u && (v2 != 32 && v2 != 46 || !sub_409DC6(v3[1])) )
    {
      v2 = *++v3;
      if ( !*v3 )
        return !wcspbrk(String, L"?*<>|\"");
    }
    return 0;
  }
  return 0;
}
// 409EC3: variable 'v3' is possibly undefined

//----- (00409EE6) --------------------------------------------------------
void __stdcall sub_409EE6(wchar_t *a1, char a2)
{
  wchar_t *i; // esi
  const wchar_t *v3; // eax
  __int16 v4; // cx

  for ( i = a1; *i; ++i )
  {
    v3 = L"?*<>|\"";
    if ( !a2 )
      v3 = L"?*";
    if ( wcschr(v3, *i) || a2 && *i < 0x20u )
      *i = 95;
    if ( (int)(((char *)i - (char *)a1) & 0xFFFFFFFE) > 2 && *i == 58 )
      *i = 95;
    if ( *i == 32 || *i == 46 && i > a1 && !sub_409DC6(*(i - 1)) && v4 != 46 )
    {
      if ( sub_409DC6(i[1]) )
        *i = 95;
    }
  }
}
// 409F71: variable 'v4' is possibly undefined
// 42A670: using guessed type wchar_t asc_42A670[3];

//----- (00409F99) --------------------------------------------------------
void __stdcall sub_409F99(char *a1, int a2, int a3)
{
  unsigned int v3; // edi
  char *v4; // eax
  char v5; // cl

  v3 = 0;
  if ( a3 != 1 )
  {
    v4 = a1;
    do
    {
      v5 = *v4;
      if ( !*v4 )
        break;
      if ( v5 == 47 )
        v5 = 92;
      ++v3;
      (v4++)[a2 - (_DWORD)a1] = v5;
    }
    while ( v3 < a3 - 1 );
  }
  *(_BYTE *)(v3 + a2) = 0;
}

//----- (00409FD2) --------------------------------------------------------
int __stdcall sub_409FD2(__int16 *a1, int a2, int a3)
{
  unsigned int v3; // edi
  __int16 *v4; // eax
  __int16 v5; // cx
  int result; // eax

  v3 = 0;
  if ( a3 != 1 )
  {
    v4 = a1;
    do
    {
      v5 = *v4;
      if ( !*v4 )
        break;
      if ( v5 == 47 )
        v5 = 92;
      *(__int16 *)((char *)v4 + a2 - (_DWORD)a1) = v5;
      ++v3;
      ++v4;
    }
    while ( v3 < a3 - 1 );
  }
  result = 0;
  *(_WORD *)(a2 + 2 * v3) = 0;
  return result;
}

//----- (0040A017) --------------------------------------------------------
BOOL __stdcall sub_40A017(wint_t *a1)
{
  return (unsigned __int16)(sub_410745(*a1) - 65) <= 0x19u && a1[1] == 58;
}

//----- (0040A043) --------------------------------------------------------
int __stdcall sub_40A043(wchar_t *Str, char a2)
{
  int v2; // edi
  wchar_t *v3; // esi

  v2 = 0;
  v3 = wcsrchr(Str, 0x3Bu);
  if ( v3 )
  {
    v2 = sub_411AC8(v3 + 1);
    if ( a2 )
      *v3 = 0;
  }
  return v2;
}
// 411AC8: using guessed type _DWORD __stdcall sub_411AC8(_DWORD);

//----- (0040A078) --------------------------------------------------------
wchar_t *__stdcall sub_40A078(LPCCH lpMultiByteStr, wchar_t *Source, wchar_t *Destination, size_t Count)
{
  wchar_t *v4; // esi

  if ( Source && *Source )
  {
    v4 = Destination;
    if ( Destination != Source )
      wcsncpy(Destination, Source, Count);
  }
  else
  {
    v4 = Destination;
    if ( lpMultiByteStr )
      sub_411682(lpMultiByteStr, Destination, Count);
    else
      *Destination = 0;
  }
  if ( Count )
    v4[Count - 1] = 0;
  return v4;
}

//----- (0040A0CE) --------------------------------------------------------
wchar_t *__stdcall sub_40A0CE(wchar_t *String)
{
  size_t v1; // ecx
  int v2; // ecx
  wchar_t *result; // eax

  v1 = wcslen(String);
  while ( 1 )
  {
    v2 = v1 - 1;
    if ( v2 < 0 )
      break;
    if ( sub_409DC6(String[v2]) )
      return &String[v1 + 1];
  }
  if ( !*String )
    return String;
  result = String + 2;
  if ( String[1] != 58 )
    return String;
  return result;
}
// 40A0EC: variable 'v1' is possibly undefined

//----- (0040A10B) --------------------------------------------------------
wchar_t *__stdcall sub_40A10B(wchar_t *a1, wchar_t *Destination)
{
  wchar_t *v2; // edi
  wchar_t v3; // dx
  _WORD *v4; // ecx
  wchar_t *v5; // esi
  wchar_t *v6; // eax
  wchar_t *v7; // eax
  wchar_t v8; // cx
  int v9; // edx
  __int16 v10; // cx
  wchar_t Source[2048]; // [esp+4h] [ebp-1000h] BYREF

  v2 = a1;
  if ( *a1 )
  {
    v3 = *a1;
    do
    {
      if ( sub_409DC6(v3) && *(v4 - 1) == 46 && *v4 == 46 && sub_409DC6((unsigned __int16)v4[1]) )
        v2 = v4 + 2;
      v3 = *(v4 - 1);
    }
    while ( v3 );
  }
  if ( *v2 )
  {
    do
    {
      v5 = v2;
      if ( *v2 && v2[1] == 58 )
        v5 = v2 + 2;
      if ( *v5 == 92 && v5[1] == 92 )
      {
        v6 = wcschr(v5 + 2, 0x5Cu);
        if ( v6 )
        {
          v7 = wcschr(v6 + 1, 0x5Cu);
          if ( v7 )
            v5 = v7 + 1;
        }
      }
      if ( *v5 )
      {
        v8 = *v5;
        do
        {
          if ( sub_409DC6(v8) )
          {
            v5 = (wchar_t *)(v9 + 2);
          }
          else if ( v10 != 46 )
          {
            break;
          }
          v8 = *(_WORD *)(v9 + 2);
        }
        while ( v8 );
      }
      if ( v5 == v2 )
        break;
      v2 = v5;
    }
    while ( *v5 );
  }
  if ( *v2 == 46 && v2[1] == 46 && !v2[2] )
    v2 += 2;
  if ( Destination )
  {
    sub_41078F(Source, v2, 2048);
    wcscpy(Destination, Source);
  }
  return v2;
}
// 40A139: variable 'v4' is possibly undefined
// 40A1CE: variable 'v9' is possibly undefined
// 40A1D7: variable 'v10' is possibly undefined

//----- (0040A238) --------------------------------------------------------
wchar_t *__stdcall sub_40A238(wchar_t *String, wchar_t *Source, int a3)
{
  wchar_t *v3; // eax

  v3 = sub_40A0CE(String);
  return sub_41078F(v3, Source, a3 - (v3 - String));
}

//----- (0040A25D) --------------------------------------------------------
wchar_t *__stdcall sub_40A25D(wchar_t *String)
{
  wchar_t *result; // eax
  wchar_t *v2; // eax

  result = 0;
  if ( String )
  {
    v2 = sub_40A0CE(String);
    return wcsrchr(v2, 0x2Eu);
  }
  return result;
}

//----- (0040A27B) --------------------------------------------------------
BOOL __stdcall sub_40A27B(wchar_t *String, PCNZWCH lpString2)
{
  wchar_t *v2; // eax

  v2 = sub_40A25D(String);
  return v2 && !sub_4119A6(v2 + 1, lpString2);
}

//----- (0040A2A1) --------------------------------------------------------
int __stdcall sub_40A2A1(wchar_t *Source, wchar_t *Destination, int a3)
{
  int result; // eax
  size_t v4; // esi

  result = a3;
  if ( a3 )
  {
    v4 = a3 - 1;
    if ( a3 - 1 >= (unsigned int)(sub_40A0CE(Source) - Source) )
      v4 = sub_40A0CE(Source) - Source;
    wcsncpy(Destination, Source, v4);
    result = 0;
    Destination[v4] = 0;
  }
  return result;
}

//----- (0040A2E6) --------------------------------------------------------
wchar_t *__stdcall sub_40A2E6(wchar_t *String)
{
  wchar_t *result; // eax

  result = sub_40A0CE(String);
  if ( result >= String + 2 && (String[1] != 58 || result >= String + 4) )
    --result;
  *result = 0;
  return result;
}

//----- (0040A311) --------------------------------------------------------
wchar_t *__stdcall sub_40A311(wchar_t *String)
{
  wchar_t *i; // edi
  int v2; // eax
  wchar_t *v3; // esi
  wchar_t *v4; // eax
  wchar_t *v5; // eax

  for ( i = &String[wcslen(String) - 1]; !sub_410760(*i) && i > String; --i )
    ;
  v2 = *i;
  v3 = i;
  while ( sub_410760(v2) )
  {
    if ( v3 <= String )
      return i;
    v2 = *--v3;
  }
  while ( v3 > String && *v3 != 46 )
  {
    if ( sub_410760(*v3) )
    {
      v4 = sub_40A0CE(String);
      v5 = wcschr(v4, 0x2Eu);
      if ( v5 && v5 < v3 )
        return v3;
      return i;
    }
    --v3;
  }
  return i;
}

//----- (0040A394) --------------------------------------------------------
int __stdcall sub_40A394(wchar_t *String, int a2, char a3)
{
  wchar_t *v3; // eax
  wchar_t *v4; // esi
  wchar_t *v5; // esi
  int result; // eax
  wchar_t *i; // eax
  wchar_t *v8; // edi
  unsigned __int16 *v9; // esi

  v3 = sub_40A25D(String);
  v4 = v3;
  if ( v3 )
  {
    if ( !v3[1] && wcslen(String) < a2 - 3 || !sub_4119A6(v4 + 1, L"exe") || !sub_4119A6(v4 + 1, L"sfx") )
      wcscpy(v4 + 1, L"rar");
  }
  else
  {
    sub_4107BC(String, (wchar_t *)L".rar", a2);
    v4 = sub_40A25D(String);
  }
  if ( a3 )
  {
    v8 = v4 + 2;
    if ( sub_410760(v4[2]) && (v9 = v4 + 3, sub_410760(*v9)) )
    {
      for ( result = (int)v9; ++*(_WORD *)result == 58; result -= 2 )
      {
        if ( *(_WORD *)(result - 2) == 46 )
        {
          *(_WORD *)result = 65;
          return result;
        }
        *(_WORD *)result = 48;
      }
    }
    else
    {
      return (int)wcscpy(v8, L"00");
    }
  }
  else
  {
    v5 = sub_40A311(String);
    while ( 1 )
    {
      result = ++*v5;
      if ( (_WORD)result != 58 )
        break;
      *v5-- = 48;
      if ( v5 < String || !sub_410760(*v5) )
      {
        for ( i = &String[wcslen(String)]; i != v5; --i )
          i[1] = *i;
        result = 49;
        v5[1] = 49;
        return result;
      }
    }
  }
  return result;
}

//----- (0040A4BE) --------------------------------------------------------
BOOL __stdcall sub_40A4BE(wint_t *a1)
{
  return *a1 == 92 && a1[1] == 92 || sub_40A017(a1) && sub_409DC6(a1[2]);
}

//----- (0040A4F3) --------------------------------------------------------
wchar_t *__stdcall sub_40A4F3(wchar_t *String, wchar_t *Destination, size_t BufferCount)
{
  wchar_t *result; // eax
  wchar_t *v4; // eax
  size_t v5; // eax
  size_t v6; // edi

  *Destination = 0;
  result = (wchar_t *)sub_40A017(String);
  if ( (_BYTE)result )
    return (wchar_t *)swprintf(Destination, BufferCount, L"%c:\\", *String);
  if ( *String == 92 && String[1] == 92 )
  {
    result = wcschr(String + 2, 0x5Cu);
    if ( result )
    {
      v4 = wcschr(result + 1, 0x5Cu);
      if ( v4 )
        v5 = v4 - String + 1;
      else
        v5 = wcslen(String);
      v6 = v5;
      if ( v5 >= BufferCount )
        v6 = 0;
      wcsncpy(Destination, String, v6);
      result = 0;
      Destination[v6] = 0;
    }
  }
  return result;
}

//----- (0040A582) --------------------------------------------------------
char __stdcall sub_40A582(wchar_t *String, wchar_t *Destination, unsigned int a3)
{
  wchar_t *v3; // esi
  size_t v5; // ebx
  DWORD CurrentDirectoryW; // eax
  WCHAR Buffer[2048]; // [esp+4h] [ebp-1000h] BYREF

  v3 = String;
  if ( !*String )
    return 0;
  sub_40A017(String);
  v5 = wcslen(String);
  if ( sub_40A4BE(String) )
  {
    if ( sub_40A017(String) )
    {
      if ( a3 > v5 + 4 )
      {
        wcsncpy(Destination, L"\\\\?\\", 4u);
        wcscpy(Destination + 4, String);
        return 1;
      }
    }
    else if ( *String == 92 && String[1] == 92 && a3 > v5 + 6 )
    {
      wcsncpy(Destination, L"\\\\?\\", 4u);
      wcscpy(Destination + 4, L"UNC");
      wcscpy(Destination + 7, String + 1);
      return 1;
    }
  }
  else
  {
    CurrentDirectoryW = GetCurrentDirectoryW(0x7FFu, Buffer);
    if ( CurrentDirectoryW && CurrentDirectoryW <= 0x7FF )
    {
      if ( sub_409DC6(*String) )
      {
        if ( a3 > v5 + 6 )
        {
          wcsncpy(Destination, L"\\\\?\\", 4u);
          wcsncpy(Destination + 4, Buffer, 2u);
          wcscpy(Destination + 6, String);
          return 1;
        }
      }
      else
      {
        sub_409DEB(Buffer, 0x800u);
        if ( a3 > wcslen(Buffer) + v5 + 4 )
        {
          wcsncpy(Destination, L"\\\\?\\", 4u);
          wcscpy(Destination + 4, Buffer);
          if ( *String == 46 && sub_409DC6(String[1]) )
            v3 = String + 2;
          sub_4107BC(Destination, v3, a3);
          return 1;
        }
      }
    }
  }
  return 0;
}

//----- (0040A72F) --------------------------------------------------------
wchar_t *__stdcall sub_40A72F(WCHAR *lpFileName, wchar_t *Destination, int a3)
{
  wchar_t *result; // eax
  DWORD FullPathNameW; // eax
  DWORD v5; // ebx
  WCHAR FileName[2048]; // [esp+8h] [ebp-2004h] BYREF
  WCHAR Buffer[2048]; // [esp+1008h] [ebp-1004h] BYREF
  LPWSTR FilePart; // [esp+2008h] [ebp-4h] BYREF

  result = lpFileName;
  if ( lpFileName && *lpFileName )
  {
    FullPathNameW = GetFullPathNameW(lpFileName, 0x800u, Buffer, &FilePart);
    v5 = FullPathNameW;
    if ( (!FullPathNameW || FullPathNameW > 0x800) && sub_40A582(lpFileName, FileName, 0x800u) )
      v5 = GetFullPathNameW(FileName, 0x800u, Buffer, &FilePart);
    if ( v5 && v5 < 0x800 )
    {
      return sub_41078F(Destination, Buffer, a3);
    }
    else
    {
      result = Destination;
      if ( lpFileName != Destination )
        return sub_41078F(Destination, lpFileName, a3);
    }
  }
  else if ( a3 )
  {
    result = 0;
    *Destination = 0;
  }
  return result;
}

//----- (0040A7E1) --------------------------------------------------------
_DWORD *__thiscall sub_40A7E1(_DWORD *this)
{
  sub_40948D((int)this, 1);
  this[4] = 0;
  return this;
}

//----- (0040A7F3) --------------------------------------------------------
void __thiscall sub_40A7F3(void **this)
{
  operator delete[](this[4]);
  sub_4094C3((int)this);
}

//----- (0040A807) --------------------------------------------------------
void __thiscall sub_40A807(_DWORD *this)
{
  if ( !this[4] )
    this[4] = operator new[](0x40004u);
}

//----- (0040A820) --------------------------------------------------------
int __stdcall sub_40A820(_DWORD *a1, int a2)
{
  int result; // eax

  result = a2;
  *a1 = a2;
  return result;
}

//----- (0040A82D) --------------------------------------------------------
int __stdcall sub_40A82D(_DWORD *a1)
{
  unsigned int v1; // esi
  int v2; // eax
  int v3; // esi
  unsigned int v4; // esi

  v1 = sub_40953E(a1);
  v2 = v1 & 0xC000;
  if ( (v1 & 0xC000) != 0 )
  {
    if ( v2 == 0x4000 )
    {
      if ( (v1 & 0x3C00) != 0 )
      {
        v4 = (unsigned __int8)(v1 >> 6);
        sub_409527(a1, 10);
      }
      else
      {
        v4 = (v1 >> 2) | 0xFFFFFF00;
        sub_409527(a1, 14);
      }
    }
    else
    {
      if ( v2 == 0x8000 )
      {
        sub_409527(a1, 2);
        v4 = sub_40953E(a1);
      }
      else
      {
        sub_409527(a1, 2);
        v3 = sub_40953E(a1) << 16;
        sub_409527(a1, 16);
        v4 = sub_40953E(a1) | v3;
      }
      sub_409527(a1, 16);
    }
    return v4;
  }
  else
  {
    sub_409527(a1, 6);
    return (v1 >> 10) & 0xF;
  }
}

//----- (0040A8CB) --------------------------------------------------------
int __thiscall sub_40A8CB(_DWORD *this, unsigned int a2, void *Src, unsigned int a4)
{
  int result; // eax
  void *v5; // ecx
  size_t v6; // eax

  result = 0x40000;
  if ( a2 < 0x40000 )
  {
    v5 = (void *)(a2 + this[4]);
    if ( Src != v5 )
    {
      v6 = 0x40000 - a2;
      if ( a4 < 0x40000 - a2 )
        v6 = a4;
      return (int)memcpy_0(v5, Src, v6);
    }
  }
  return result;
}

//----- (0040A8FF) --------------------------------------------------------
int __stdcall sub_40A8FF(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // eax
  int v3; // edx
  int v4; // eax
  unsigned int v5; // ecx

  v2 = sub_405595(0xFFFFFFFF, a1, a2);
  v3 = 0;
  v4 = ~v2;
  v5 = 0;
  while ( dword_42F06C[v5] != v4 || dword_42F068[v5] != a2 )
  {
    v5 += 3;
    ++v3;
    if ( v5 >= 18 )
      return 0;
  }
  return dword_42F070[3 * v3];
}
// 42F068: using guessed type int dword_42F068[];
// 42F06C: using guessed type int dword_42F06C[];
// 42F070: using guessed type int dword_42F070[4];

//----- (0040A940) --------------------------------------------------------
unsigned int __stdcall sub_40A940(int a1, int a2, char a3)
{
  return (0xFFFFFFFF >> (32 - a3)) & ((unsigned int)((*(unsigned __int8 *)(a2 / 8 + 1 + a1) << 8) | *(unsigned __int8 *)(a2 / 8 + a1) | (*(unsigned __int16 *)(a2 / 8 + 1 + a1 + 1) << 16)) >> (a2 & 7));
}

//----- (0040A990) --------------------------------------------------------
int __stdcall sub_40A990(int a1, int a2, int a3, char a4)
{
  int result; // eax
  unsigned int v5; // edi
  int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // [esp+14h] [ebp+Ch]

  result = a1;
  v8 = a2 << (a3 & 7);
  v5 = 0;
  v6 = a1 + a3 / 8;
  v7 = ~(0xFFFFFFFF >> (32 - a4) << (a3 & 7));
  do
  {
    LOBYTE(result) = v8 | v7 & *(_BYTE *)(v6 + v5);
    v8 >>= 8;
    v7 = (v7 >> 8) | 0xFF000000;
    *(_BYTE *)(v6 + v5++) = result;
  }
  while ( v5 < 4 );
  return result;
}

//----- (0040A9E9) --------------------------------------------------------
void __thiscall sub_40A9E9(int this, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // ebx
  void *v6; // edi

  *(_DWORD *)(this + 4) += a2;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 > *(_DWORD *)(this + 8) )
  {
    v4 = *(_DWORD *)(this + 12);
    if ( v4 && v3 > v4 )
    {
      sub_40634C((int)&dword_432A6C, (wchar_t *)L"Maximum allowed array size (%u) is exceeded", v4);
      sub_4062F7(&dword_432A6C);
    }
    v5 = *(_DWORD *)(this + 4);
    if ( v5 <= (*(_DWORD *)(this + 8) >> 2) + *(_DWORD *)(this + 8) + 32 )
      v5 = (*(_DWORD *)(this + 8) >> 2) + *(_DWORD *)(this + 8) + 32;
    v6 = realloc(*(void **)this, 40 * v5);
    if ( !v6 )
      sub_4062F7(&dword_432A6C);
    *(_DWORD *)this = v6;
    *(_DWORD *)(this + 8) = v5;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0040AA63) --------------------------------------------------------
_DWORD *__thiscall sub_40AA63(int this, _BYTE *Src, unsigned int a3, _DWORD *a4)
{
  size_t v5; // eax
  unsigned int v6; // eax
  char i; // bl
  int v8; // edi
  int v9; // eax
  int v10; // ecx
  _DWORD *result; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // edi

  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = 0;
  v5 = 0x8000;
  if ( a3 < 0x8000 )
    v5 = a3;
  memcpy(*(void **)(this + 12), Src, v5);
  v6 = 1;
  for ( i = 0; v6 < a3; ++v6 )
    i ^= Src[v6];
  sub_409527((_DWORD *)this, 8);
  a4[5] = 0;
  if ( i == *Src && (v8 = sub_40A8FF(Src, a3)) != 0 )
  {
    sub_40A9E9((int)a4, 1);
    v9 = a4[5];
    v10 = v9 + 1;
    result = (_DWORD *)(*a4 + 40 * v9);
    a4[5] = v10;
    result[3] = v8;
    result[5] = result + 3;
    result[9] = result + 7;
    *result = 40;
    result[6] = 3;
    result[2] = 3;
  }
  else
  {
    sub_40A9E9((int)a4, 1);
    v12 = a4[5];
    v13 = v12 + 1;
    result = (_DWORD *)(*a4 + 40 * v12);
    a4[5] = v13;
    result[5] = result + 3;
    result[9] = result + 7;
    result[6] = 3;
    result[2] = 3;
    *result = 22;
    v14 = 0;
    if ( (int)a4[5] > 0 )
    {
      v15 = 0;
      do
      {
        result = (_DWORD *)(v15 + *a4);
        if ( !result[5] )
          result[5] = result + 3;
        if ( !result[9] )
          result[9] = result + 7;
        ++v14;
        v15 += 40;
      }
      while ( v14 < a4[5] );
    }
  }
  return result;
}

//----- (0040AB67) --------------------------------------------------------
void __thiscall sub_40AB67(_DWORD *this, int a2)
{
  unsigned int v4; // ecx
  int v5; // eax
  int v6; // edi
  int v7; // ebx
  int v8; // edx
  char v9; // al
  int v10; // edi
  int v11; // edx
  unsigned int v12; // edi
  int v13; // eax
  int v14; // esi
  unsigned int v15; // ebx
  int v16; // eax
  bool j; // cc
  unsigned int v18; // edi
  int v19; // ecx
  int v20; // esi
  char v21; // dl
  int v22; // eax
  int v23; // esi
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  unsigned int v30; // edx
  unsigned int v31; // edi
  unsigned int k; // ecx
  int *v33; // eax
  unsigned int v34; // eax
  int v35; // edx
  int v36; // esi
  int v37; // ecx
  unsigned int v38; // ebx
  unsigned __int8 *v39; // esi
  unsigned int v40; // eax
  int v41; // edi
  int v42; // eax
  char v43; // al
  unsigned __int8 v44; // al
  bool v45; // zf
  int v46; // eax
  int v47; // edx
  char v48; // cl
  int v49; // eax
  int v50; // eax
  int v51; // ebx
  int v52; // eax
  unsigned __int8 v53; // al
  int i; // edi
  unsigned int v55; // eax
  int v56; // eax
  char *v57; // ecx
  int v58; // esi
  int v59; // edi
  char v60; // dl
  char v61; // al
  int v62; // eax
  int v63; // eax
  int v64[7]; // [esp+4h] [ebp-50h] BYREF
  int v65; // [esp+20h] [ebp-34h]
  unsigned int v66; // [esp+24h] [ebp-30h]
  int v67; // [esp+28h] [ebp-2Ch]
  int v68; // [esp+2Ch] [ebp-28h]
  int v69; // [esp+30h] [ebp-24h]
  unsigned int v70; // [esp+34h] [ebp-20h]
  int v71; // [esp+38h] [ebp-1Ch]
  int v72; // [esp+3Ch] [ebp-18h]
  int v73; // [esp+40h] [ebp-14h]
  int v74; // [esp+44h] [ebp-10h]
  unsigned int v75; // [esp+48h] [ebp-Ch]
  int v76; // [esp+4Ch] [ebp-8h]
  int v77; // [esp+50h] [ebp-4h]
  int v78; // [esp+5Ch] [ebp+8h]
  int v79; // [esp+5Ch] [ebp+8h]
  int v80; // [esp+5Ch] [ebp+8h]
  _BYTE *v81; // [esp+5Ch] [ebp+8h]
  int v82; // [esp+5Ch] [ebp+8h]

  if ( a2 <= 0 )
    return;
  if ( a2 <= 2 )
  {
    v56 = this[9];
    v57 = (char *)this[4];
    v58 = this[11];
    if ( (unsigned int)v56 >= 0x3C000 )
      return;
    if ( v56 < 4 )
      return;
    v82 = 0;
    v59 = v56 - 4;
    v60 = (a2 == 2) - 24;
    if ( v56 - 4 <= 0 )
      return;
    while ( 1 )
    {
      v61 = *v57++;
      ++v82;
      ++v58;
      if ( v61 != -24 && v61 != v60 )
        goto LABEL_89;
      v62 = *(_DWORD *)v57;
      if ( *(int *)v57 >= 0 )
      {
        if ( v62 < 0x1000000 )
        {
          v63 = v62 - v58;
          goto LABEL_87;
        }
      }
      else if ( v58 + v62 >= 0 )
      {
        v63 = v62 + 0x1000000;
LABEL_87:
        *(_DWORD *)v57 = v63;
      }
      v82 += 4;
      v57 += 4;
      v58 += 4;
LABEL_89:
      if ( v82 >= v59 )
        return;
    }
  }
  switch ( a2 )
  {
    case 3:
      v81 = (_BYTE *)this[4];
      v49 = this[9];
      if ( (unsigned int)v49 < 0x3C000 && v49 >= 21 )
      {
        v50 = v49 - 21;
        v51 = this[11] >> 4;
        if ( v50 > 0 )
        {
          v67 = ((unsigned int)(v50 - 1) >> 4) + 1;
          do
          {
            v52 = (*v81 & 0x1F) - 16;
            if ( v52 >= 0 )
            {
              v53 = byte_42F0B0[v52];
              if ( v53 )
              {
                v71 = 0;
                v65 = v53;
                for ( i = 18; i <= 100; i += 41 )
                {
                  if ( ((1 << v71) & v65) != 0 && sub_40A940((int)v81, i + 24, 4) == 5 )
                  {
                    v55 = sub_40A940((int)v81, i, 20);
                    sub_40A990((int)v81, (v55 - v51) & 0xFFFFF, i, 20);
                  }
                  ++v71;
                }
              }
            }
            v81 += 16;
            ++v51;
            --v67;
          }
          while ( v67 );
        }
      }
      break;
    case 4:
      v34 = this[9];
      v35 = this[6];
      v36 = this[4];
      v37 = this[5] - 3;
      v74 = v34;
      v65 = v37;
      v66 = v35;
      v71 = v36;
      v38 = v36 + v34;
      *(_DWORD *)(v36 + 245792) = v34;
      if ( v34 < 0x1E000 && v35 >= 0 )
      {
        v76 = 0;
        v73 = -v37;
        do
        {
          v80 = 0;
          if ( v76 < v74 )
          {
            v72 = v73;
            v39 = (unsigned __int8 *)(v38 + v73);
            v75 = (v74 - v76 - 1) / 3u + 1;
            do
            {
              if ( v72 < 3
                || (v40 = *(v39 - 3),
                    v69 = *v39,
                    v41 = v80 + v69 - v40,
                    v70 = v40,
                    v67 = abs(v69 - v40),
                    v68 = abs(v41 - v69),
                    v42 = abs(v41 - v70),
                    v67 <= v68)
                && v67 <= v42 )
              {
                v43 = v80;
              }
              else if ( v68 > v42 )
              {
                v43 = v70;
              }
              else
              {
                v43 = v69;
              }
              v44 = v43 - *(_BYTE *)v71++;
              v72 += 3;
              v39[v65] = v44;
              v39 += 3;
              v45 = v75-- == 1;
              v80 = v44;
            }
            while ( !v45 );
          }
          ++v76;
          ++v73;
        }
        while ( v76 < 3 );
        v46 = v66;
        v47 = v74 - 2;
        while ( v46 < v47 )
        {
          v48 = *(_BYTE *)(v46 + v38 + 1);
          *(_BYTE *)(v46 + v38) += v48;
          *(_BYTE *)(v46 + v38 + 2) += v48;
          v46 += 3;
        }
      }
      break;
    case 5:
      v12 = this[9];
      v13 = this[5];
      v14 = this[4];
      v68 = v12;
      v67 = v13;
      v73 = v14;
      v66 = v14 + v12;
      *(_DWORD *)(v14 + 245792) = v12;
      if ( v12 < 0x1E000 )
      {
        v15 = 0;
        v74 = 0;
        if ( v13 > 0 )
        {
          while ( 1 )
          {
            v69 = 0;
            v70 = 0;
            v75 = 0;
            v76 = 0;
            v77 = 0;
            v79 = 0;
            memset(v64, 0, sizeof(v64));
            v16 = v74;
            v71 = 0;
            for ( j = v74 < (int)v12; ; j = v67 + v72 < v68 )
            {
              v72 = v16;
              if ( !j )
                break;
              v18 = v15;
              v15 = v70 - v75;
              v19 = *(unsigned __int8 *)v73++;
              v20 = v70 * v76 + (v70 - v75) * v77 + v79 * v18;
              v21 = v69;
              v75 = v70;
              v65 = v19;
              v22 = (unsigned __int8)((unsigned int)(v20 + 8 * v69) >> 3) - v19;
              *(_BYTE *)(v72 + v66) = v22;
              v23 = 8 * (char)v65;
              v70 = (char)(v22 - v21);
              v69 = v22;
              v64[0] += abs(v23);
              v24 = abs(v23 - v75);
              v64[1] += v24;
              v25 = abs(v23 + v75);
              v64[2] += v25;
              v26 = abs(v23 - v15);
              v64[3] += v26;
              v27 = abs(v23 + v15);
              v64[4] += v27;
              v28 = abs(v23 - v18);
              v64[5] += v28;
              v29 = abs(v18 + v23);
              v64[6] += v29;
              if ( (v71 & 0x1F) == 0 )
              {
                v30 = v64[0];
                v31 = 0;
                v64[0] = 0;
                for ( k = 1; k < 7; ++k )
                {
                  v33 = &v64[k];
                  if ( *v33 < v30 )
                  {
                    v30 = *v33;
                    v31 = k;
                  }
                  *v33 = 0;
                }
                switch ( v31 )
                {
                  case 1u:
                    if ( v76 >= -16 )
                      --v76;
                    break;
                  case 2u:
                    if ( v76 < 16 )
                      ++v76;
                    break;
                  case 3u:
                    if ( v77 >= -16 )
                      --v77;
                    break;
                  case 4u:
                    if ( v77 < 16 )
                      ++v77;
                    break;
                  case 5u:
                    if ( v79 >= -16 )
                      --v79;
                    break;
                  default:
                    if ( v31 == 6 && v79 < 16 )
                      ++v79;
                    break;
                }
              }
              v16 = v67 + v72;
              ++v71;
            }
            if ( ++v74 >= v67 )
              break;
            v12 = v68;
            v15 = 0;
          }
        }
      }
      break;
    case 6:
      v4 = this[9];
      v5 = this[5];
      v6 = this[4];
      v7 = 0;
      v71 = v5;
      v8 = 2 * v4;
      *(_DWORD *)(v6 + 245792) = v4;
      if ( v4 < 0x1E000 )
      {
        v78 = 0;
        if ( v5 > 0 )
        {
          do
          {
            v9 = 0;
            v10 = v4 + v78;
            while ( v10 < v8 )
            {
              v11 = this[4];
              v9 -= *(_BYTE *)(v11 + v7++);
              *(_BYTE *)(v11 + v10) = v9;
              v10 += v71;
              v8 = 2 * v4;
            }
            ++v78;
          }
          while ( v78 < v71 );
        }
      }
      break;
  }
}

//----- (0040B00B) --------------------------------------------------------
char __thiscall sub_40B00B(_DWORD *this, _DWORD *a2, unsigned int a3)
{
  _DWORD *v3; // eax
  int v4; // esi
  unsigned int v5; // edx
  unsigned int v6; // eax

  v3 = a2;
  v4 = 25000000;
  while ( 1 )
  {
    while ( *v3 != 22 )
    {
      if ( *v3 == 40 )
      {
        sub_40AB67(this, v3[3]);
        return 1;
      }
      v3 += 10;
      --v4;
    }
    v5 = this[12];
    if ( v5 >= 0x40000 )
      return 1;
    v6 = *(_DWORD *)((v5 & 0x3FFFF) + this[4]);
    if ( v6 >= a3 )
      return 1;
    if ( --v4 <= 0 )
      break;
    v3 = &a2[10 * v6];
    this[12] = v5 + 4;
  }
  return 0;
}

//----- (0040B06D) --------------------------------------------------------
int __thiscall sub_40B06D(_DWORD *this, size_t Size)
{
  size_t v4; // eax
  _DWORD *v5; // ebx
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  void **v9; // esi
  int result; // eax
  size_t v11; // ebx
  size_t Sizea; // [esp+14h] [ebp+8h]

  memcpy(this + 5, (const void *)(Size + 56), 0x1Cu);
  Sizea = *(_DWORD *)(Size + 28);
  if ( Sizea >= 0x2000 )
    Sizea = 0x2000;
  if ( Sizea )
    memcpy((void *)(this[4] + 245760), *(const void **)(Size + 24), Sizea);
  v4 = *(_DWORD *)(Size + 44);
  if ( v4 >= 0x2000 - Sizea )
    v4 = 0x2000 - Sizea;
  if ( v4 )
    memcpy((void *)(this[4] + Sizea + 245760), *(const void **)(Size + 40), v4);
  this[13] = 0;
  this[12] = 0x40000;
  v5 = *(_DWORD **)(Size + 16);
  if ( !v5 )
    v5 = *(_DWORD **)Size;
  if ( *(int *)(Size + 20) > 0 && !sub_40B00B(this, v5, *(_DWORD *)(Size + 20)) )
    *v5 = 22;
  v6 = this[4];
  v7 = *(_DWORD *)(v6 + 245792) & 0x3FFFF;
  v8 = *(_DWORD *)(v6 + 245788) & 0x3FFFF;
  if ( (unsigned int)(v8 + v7) >= 0x40000 )
  {
    v8 = 0;
    v7 = 0;
  }
  *(_DWORD *)(Size + 84) = v7 + v6;
  *(_DWORD *)(Size + 88) = v8;
  v9 = (void **)(Size + 24);
  sub_412595((int)v9);
  result = 8128;
  if ( *(_DWORD *)(this[4] + 245808) < 0x1FC0u )
    result = *(_DWORD *)(this[4] + 245808);
  if ( result )
  {
    v11 = result + 64;
    sub_401113((int)v9, result + 64);
    return (int)memcpy(*v9, (const void *)(this[4] + 245760), v11);
  }
  return result;
}

//----- (0040B189) --------------------------------------------------------
int __thiscall sub_40B189(_DWORD *this, unsigned int a2)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // edx
  __m128i *v6; // edi
  int v8; // [esp+8h] [ebp-4h]

  v3 = 0;
  if ( this[7] )
  {
    v4 = this[1];
    v5 = this[5];
    v8 = v4;
    if ( a2 <= v4 - v5 )
    {
      v3 = a2;
      this[5] = a2 + v5;
    }
    else
    {
      v6 = (__m128i *)(a2 - (v4 - v5) + (((_BYTE)v4 - (_BYTE)v5 - (_BYTE)a2) & 0xF));
      sub_401113((int)this, (int)v6);
      v3 = (*(int (__thiscall **)(_DWORD, int, __m128i *))(*(_DWORD *)this[4] + 8))(this[4], v4 + *this, v6);
      sub_405E38((_DWORD *)this[7], (__m128i *)(v8 + *this), v6);
      this[5] += v3 != 0 ? a2 : 0;
    }
  }
  else if ( a2 )
  {
    sub_401113((int)this, a2);
    v3 = (*(int (__thiscall **)(_DWORD, int, unsigned int))(*(_DWORD *)this[4] + 8))(this[4], *this + this[5], a2);
    this[5] += v3;
  }
  return v3;
}

//----- (0040B223) --------------------------------------------------------
int __thiscall sub_40B223(_DWORD *this)
{
  unsigned int v1; // eax

  v1 = this[6];
  if ( v1 >= this[5] )
    return 0;
  this[6] = v1 + 1;
  return *(unsigned __int8 *)(*this + v1);
}

//----- (0040B23B) --------------------------------------------------------
int __thiscall sub_40B23B(_DWORD *this)
{
  int v1; // edx
  int result; // eax

  v1 = this[6];
  if ( (unsigned int)(v1 + 1) >= this[5] )
    return 0;
  result = (unsigned __int16)(*(unsigned __int8 *)(v1 + *this) + (*(unsigned __int8 *)(v1 + *this + 1) << 8));
  this[6] = v1 + 2;
  return result;
}

//----- (0040B270) --------------------------------------------------------
int __thiscall sub_40B270(_DWORD *this)
{
  int v1; // esi
  int result; // eax

  v1 = this[6];
  if ( (unsigned int)(v1 + 3) >= this[5] )
    return 0;
  result = *(unsigned __int8 *)(v1 + *this)
         + ((*(unsigned __int8 *)(v1 + *this + 1)
           + ((*(unsigned __int8 *)(v1 + *this + 2) + (*(unsigned __int8 *)(v1 + *this + 3) << 8)) << 8)) << 8);
  this[6] = v1 + 4;
  return result;
}

//----- (0040B2AD) --------------------------------------------------------
unsigned __int64 __thiscall sub_40B2AD(_DWORD *this)
{
  int v1; // esi
  _DWORD *v2; // ecx

  v1 = sub_40B270(this);
  return (unsigned int)v1 + ((unsigned __int64)(unsigned int)sub_40B270(v2) << 32);
}
// 40B2B5: variable 'v2' is possibly undefined

//----- (0040B2CE) --------------------------------------------------------
__int64 __thiscall sub_40B2CE(int *this)
{
  char v1; // bp
  int v2; // edi
  int v3; // eax
  __int64 v5; // [esp+10h] [ebp-8h]

  v1 = 0;
  v5 = 0i64;
  if ( this[6] >= (unsigned int)this[5] )
    return 0i64;
  v2 = *this;
  while ( 1 )
  {
    v3 = this[6];
    this[6] = v3 + 1;
    v5 += (unsigned __int64)(*(_BYTE *)(v2 + v3) & 0x7F) << v1;
    if ( *(char *)(v2 + v3) >= 0 )
      break;
    v1 += 7;
    if ( this[6] >= (unsigned int)this[5] )
      return 0i64;
  }
  return v5;
}

//----- (0040B331) --------------------------------------------------------
int __thiscall sub_40B331(int *this, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  int v4; // ecx

  v2 = this[5];
  v3 = a2;
  if ( a2 >= v2 )
    return 0;
  v4 = *this;
  while ( *(char *)(v4 + v3) < 0 )
  {
    if ( ++v3 >= v2 )
      return 0;
  }
  return v3 - a2 + 1;
}

//----- (0040B357) --------------------------------------------------------
size_t __thiscall sub_40B357(_DWORD *this, char *a2, unsigned int a3)
{
  int v4; // eax
  size_t v5; // edi

  v4 = this[6];
  v5 = this[5] - v4;
  if ( v5 >= a3 )
    v5 = a3;
  if ( v5 )
    memcpy(a2, (const void *)(v4 + *this), v5);
  if ( a3 > v5 )
    memset(&a2[v5], 0, a3 - v5);
  this[6] += v5;
  return v5;
}

//----- (0040B3A7) --------------------------------------------------------
int __thiscall sub_40B3A7(_DWORD *this, char a2)
{
  unsigned int v2; // edx

  v2 = this[5];
  if ( v2 <= 2 )
    return 0;
  if ( a2 )
    v2 = this[6];
  return (unsigned __int16)~sub_405595(0xFFFFFFFF, (_DWORD *)(*this + 2), v2 - 2);
}

//----- (0040B3D7) --------------------------------------------------------
unsigned int __thiscall sub_40B3D7(_DWORD *this)
{
  unsigned int v1; // edx

  v1 = this[5];
  if ( v1 > 4 )
    return ~sub_405595(0xFFFFFFFF, (_DWORD *)(*this + 4), v1 - 4);
  else
    return -1;
}

//----- (0040B3F7) --------------------------------------------------------
_DWORD *__thiscall sub_40B3F7(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  result = this;
  *this = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = a2;
  this[1] = 0;
  this[6] = 0;
  this[5] = 0;
  this[7] = 0;
  return result;
}

//----- (0040B419) --------------------------------------------------------
int __thiscall sub_40B419(_DWORD *this)
{
  int result; // eax

  this[1558] = -1;
  result = 0;
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 12) = 0;
  this[8] = 0;
  this[9] = 0;
  *((_BYTE *)this + 40) = 1;
  *((_BYTE *)this + 41) = 0;
  *((_BYTE *)this + 42) = 0;
  *((_BYTE *)this + 6238) = 0;
  *((_BYTE *)this + 6239) = 0;
  *((_BYTE *)this + 6240) = 0;
  this[11] = 0;
  this[12] = 0;
  this[6] = 0;
  this[13] = 0;
  *((_BYTE *)this + 15052) = 0;
  *((_BYTE *)this + 15053) = 0;
  this[1570] = 0;
  this[1571] = 0;
  this[1568] = 0;
  this[1569] = 0;
  this[1566] = 0;
  this[1567] = 0;
  this[1564] = 0;
  this[1565] = 0;
  this[14] = 0;
  this[15] = 0;
  *((_WORD *)this + 3118) = 0;
  this[1574] = 0;
  this[1575] = 0;
  this[1572] = 0;
  this[1573] = 0;
  return result;
}

//----- (0040B4B9) --------------------------------------------------------
void __thiscall sub_40B4B9(int this, __int64 a2, unsigned int a3, int a4)
{
  int v4; // eax

  if ( *(_BYTE *)(this + 40) )
  {
    v4 = *(_DWORD *)(this + 44);
    if ( v4 )
    {
      if ( *(_QWORD *)(this + 6296) )
      {
        a3 = *(_DWORD *)(this + 6296);
        a4 = *(_DWORD *)(this + 6300);
        a2 += *(_QWORD *)(this + 6288);
      }
      sub_41125C(
        *(_DWORD *)(this + 6280),
        *(_DWORD *)(this + 6284),
        *(_DWORD *)(v4 + 26648),
        *(_DWORD *)(v4 + 26652),
        a2,
        SHIDWORD(a2),
        a3,
        a4);
    }
  }
}

//----- (0040B524) --------------------------------------------------------
int __thiscall sub_40B524(_DWORD *this, int a2, int a3)
{
  int result; // eax

  if ( a2 )
    this[11] = a2;
  result = a3;
  if ( a3 )
    this[12] = a3;
  this[1558] = -1;
  return result;
}

//----- (0040B544) --------------------------------------------------------
char __thiscall sub_40B544(_BYTE *this, char a2, int a3, _BYTE *Src, void *Buf2, int Val, int a7, void *a8, void *a9)
{
  char result; // al

  if ( a2 )
  {
    result = sub_405F4F((int)(this + 64), 1, a3, Src, Buf2, Val, a7, a9, a8);
    this[15052] = result;
  }
  else
  {
    result = sub_405F4F((int)(this + 3148), 0, a3, Src, Buf2, Val, a7, a9, a8);
    this[15053] = result;
  }
  return result;
}

//----- (0040B58F) --------------------------------------------------------
int __thiscall sub_40B58F(int this, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)(this + 20) = a2;
  result = a3;
  *(_BYTE *)(this + 12) = 1;
  *(_DWORD *)(this + 16) = a3;
  return result;
}

//----- (0040B5A4) --------------------------------------------------------
_DWORD *__thiscall sub_40B5A4(_DWORD *this)
{
  sub_405ED9((int)(this + 16));
  sub_405ED9((int)(this + 787));
  sub_4097E5(this + 1576);
  sub_4097E5(this + 2305);
  sub_4097E5(this + 3034);
  sub_40B419(this);
  return this;
}

//----- (0040B60F) --------------------------------------------------------
int __thiscall sub_40B60F(char *this, __m128i *a2, unsigned int a3)
{
  int v4; // edi
  int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // ecx
  int result; // eax
  _DWORD *v9; // eax
  int v10; // eax
  _DWORD *v11; // [esp+Ch] [ebp-Ch]
  char *Src; // [esp+10h] [ebp-8h]
  __m128i *v13; // [esp+14h] [ebp-4h]

  if ( this[15053] )
    a3 &= 0xFFFFFFF0;
  v4 = 0;
  v13 = 0;
  Src = (char *)a2;
  while ( a3 )
  {
    v11 = (_DWORD *)*((_DWORD *)this + 11);
    if ( *this )
    {
      memcpy(a2, *((const void **)this + 2), *((_DWORD *)this + 1));
      v4 = *((_DWORD *)this + 1);
      *((_DWORD *)this + 1) = 0;
    }
    else
    {
      v5 = *((_DWORD *)this + 9);
      v6 = *((_DWORD *)this + 8);
      if ( a3 <= __SPAIR64__(v5, v6) )
        v7 = a3;
      else
        v7 = *((_DWORD *)this + 8);
      if ( v7 )
      {
        if ( this[6239]
          && this[15053]
          && v5 <= 0
          && (v5 < 0 || a3 > v6)
          && (int)((((unsigned int)v13->m128i_u32 + v7) & 0xFFFFFFF0) - (_DWORD)v13) > 0 )
        {
          v7 = (((unsigned int)v13->m128i_u32 + v7) & 0xFFFFFFF0) - (_DWORD)v13;
        }
        result = -1;
        if ( v11[1] == -1 )
          return result;
        v4 = (*(int (__thiscall **)(_DWORD *, char *, unsigned int))(*v11 + 8))(v11, Src, v7);
        v9 = (_DWORD *)*((_DWORD *)this + 14);
        if ( !v9 )
          v9 = v11 + 5618;
        if ( *((_BYTE *)v9 + 4233) )
          sub_409631(this + 6304, Src, v4);
      }
    }
    *((_QWORD *)this + 784) += v4;
    v13 = (__m128i *)((char *)v13 + v4);
    Src += v4;
    a3 -= v4;
    *((_QWORD *)this + 4) -= v4;
    if ( !this[6239] || *((_QWORD *)this + 4) || v4 && (!this[15053] || ((unsigned __int8)v13 & 0xF) == 0) )
      break;
    if ( !sub_418659(v11, (int)this, 1, *((_WORD *)this + 3118)) )
    {
      this[6240] = 1;
      return -1;
    }
  }
  v10 = *((_DWORD *)this + 11);
  if ( v10 )
    sub_40B4B9(
      (int)this,
      *((_QWORD *)this + 784) + *(_QWORD *)(v10 + 41504),
      *((_DWORD *)this + 1562),
      *((_DWORD *)this + 1563));
  if ( v4 != -1 )
  {
    v4 = (int)v13;
    if ( this[15053] )
      sub_405E38((_DWORD *)this + 787, a2, v13);
  }
  sub_4109C7();
  return v4;
}

//----- (0040B7BF) --------------------------------------------------------
char __thiscall sub_40B7BF(int this, char *Src, size_t Size)
{
  bool v4; // zf

  v4 = *(_BYTE *)(this + 12) == 0;
  *(_DWORD *)(this + 28) = Src;
  *(_DWORD *)(this + 24) = Size;
  if ( v4 )
  {
    if ( !*(_BYTE *)(this + 41) )
      sub_408835(*(int **)(this + 48), Src, Size);
  }
  else if ( Size <= *(_DWORD *)(this + 16) )
  {
    memcpy(*(void **)(this + 20), Src, Size);
    *(_DWORD *)(this + 20) += Size;
    *(_DWORD *)(this + 16) -= Size;
  }
  *(_QWORD *)(this + 6280) += Size;
  if ( !*(_BYTE *)(this + 42) )
    sub_409631((void *)(this + 12136), Src, Size);
  return sub_4109C7();
}

//----- (0040B82C) --------------------------------------------------------
_DWORD *__thiscall sub_40B82C(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = 0;
  this[1] = 0;
  *((_BYTE *)this + 16) = 0;
  return result;
}

//----- (0040B842) --------------------------------------------------------
BOOL __thiscall sub_40B842(_DWORD *this)
{
  return *this != 0;
}

//----- (0040B84A) --------------------------------------------------------
__int16 *__thiscall sub_40B84A(__int16 **this, int a2)
{
  __int16 *v2; // esi
  __int16 v3; // ax

  v2 = *this;
  v3 = **this;
  if ( v3 )
  {
    do
    {
      if ( v3 == *(_WORD *)a2
        && !wcsncmp((const wchar_t *)v2 + 1, (const wchar_t *)(a2 + 2), 7u)
        && v2[8] == 61
        && v2[9] == 34 )
      {
        return v2;
      }
      while ( *v2 )
      {
        if ( *v2 == 12 )
          goto LABEL_11;
        ++v2;
      }
      while ( *v2 == 12 )
LABEL_11:
        ++v2;
      v3 = *v2;
    }
    while ( *v2 );
  }
  return 0;
}

//----- (0040B8B0) --------------------------------------------------------
void __thiscall sub_40B8B0(_BYTE *this, HWND hWnd)
{
  LONG WindowLongW; // eax

  if ( this[16] )
  {
    WindowLongW = GetWindowLongW(hWnd, -20);
    SetWindowLongW(hWnd, -20, WindowLongW | 0x400000);
  }
}

//----- (0040B8D7) --------------------------------------------------------
char __thiscall sub_40B8D7(int this, wchar_t *Source)
{
  bool v3; // zf
  WCHAR *v4; // eax
  wchar_t *v5; // eax
  unsigned int v6; // ebx
  signed int v7; // edi
  char *v8; // ebx
  void *v9; // eax
  DWORD v10; // eax
  WCHAR *v11; // edi
  int v12; // eax
  int v13; // ecx
  LPCCH v14; // eax
  __int16 v15; // dx
  __int16 v17; // [esp-Ch] [ebp-4050h]
  char Buffer[4]; // [esp+4h] [ebp-4040h] BYREF
  wchar_t String1[4094]; // [esp+8h] [ebp-403Ch] BYREF
  WCHAR Filename[2048]; // [esp+2004h] [ebp-2040h] BYREF
  _DWORD v21[1033]; // [esp+3004h] [ebp-1040h] BYREF
  int v22; // [esp+4028h] [ebp-1Ch]
  DWORD v23; // [esp+402Ch] [ebp-18h]
  unsigned int i; // [esp+4030h] [ebp-14h]
  LONG lDistanceToMove; // [esp+4034h] [ebp-10h]
  int v26; // [esp+4040h] [ebp-4h]
  char Source_3; // [esp+404Fh] [ebp+Bh]

  v3 = wcschr(Source, 0x5Cu) == 0;
  v4 = Filename;
  if ( !v3 )
  {
LABEL_4:
    wcscpy(v4, Source);
    sub_408533(v21);
    v6 = 0;
    v26 = 0;
    if ( !sub_408570((int)v21, Filename, 4) )
    {
      v26 = -1;
      LOBYTE(v5) = sub_4089F9((int)v21);
      return (char)v5;
    }
    lDistanceToMove = -1;
    Source_3 = 0;
    for ( i = 0; i < 0x80; ++i )
    {
      if ( lDistanceToMove != -1 )
        goto LABEL_25;
      v22 = sub_40892A((int)v21);
      v23 = sub_408BFC(v21, Buffer, 0x2000u);
      v7 = 0;
      if ( (int)(v23 - 16) >= 0 )
      {
        while ( 1 )
        {
          v8 = &Buffer[v7];
          if ( Buffer[v7] == 42 && Buffer[v7 + 1] == 42 && !strncmp(&Buffer[v7 + 2], "*messages***", 0xBu) )
            break;
          if ( *(_WORD *)v8 == 42
            && *(_WORD *)&Buffer[v7 + 2] == 42
            && v7 <= (int)(v23 - 32)
            && !wcsncmp((wchar_t *)((char *)String1 + v7), L"*messages***", 0xBu) )
          {
            Source_3 = 1;
            break;
          }
          if ( *v8 == 82 && Buffer[v7 + 1] == 97 && !strncmp(&Buffer[v7 + 2], aR, 4u) )
            goto LABEL_52;
          if ( ++v7 > (int)(v23 - 16) )
            goto LABEL_23;
        }
        lDistanceToMove = v22 + v7;
      }
LABEL_23:
      v6 = 0;
      sub_408D6E((int)v21, v23 + v22 - 16, 0);
    }
    if ( lDistanceToMove != -1 )
    {
LABEL_25:
      sub_408D6E((int)v21, lDistanceToMove, 0);
      v9 = malloc(0x80002u);
      *(_DWORD *)this = v9;
      if ( v9 )
      {
        v10 = sub_408BFC(v21, v9, 0x80000u);
        *(_DWORD *)(this + 4) = v10;
        if ( Source_3 )
        {
          *(_DWORD *)(this + 4) = v10 >> 1;
        }
        else
        {
          v11 = (WCHAR *)malloc(2 * v10 + 2);
          if ( !v11 )
            goto LABEL_52;
          *(_BYTE *)(*(_DWORD *)(this + 4) + *(_DWORD *)this) = 0;
          sub_411682(*(LPCCH *)this, v11, *(_DWORD *)(this + 4) + 1);
          free(*(void **)this);
          *(_DWORD *)this = v11;
        }
        v12 = 0x40000;
        if ( *(_DWORD *)(this + 4) <= 0x40000u )
          v12 = *(_DWORD *)(this + 4);
        *(_WORD *)(*(_DWORD *)this + 2 * v12) = 0;
        v13 = 0;
        if ( *(_DWORD *)(this + 4) )
        {
          while ( 1 )
          {
            v14 = *(LPCCH *)this;
            v15 = *(_WORD *)(*(_DWORD *)this + 2 * v6++);
            if ( !v15 )
              goto LABEL_51;
            if ( v15 != 92 )
              break;
            switch ( *(_WORD *)&v14[2 * v6] )
            {
              case '"':
                v17 = 34;
LABEL_45:
                ++v6;
LABEL_49:
                v15 = v17;
                break;
              case '\\':
                v17 = 92;
                goto LABEL_45;
              case 'n':
                v17 = 10;
                goto LABEL_45;
              case 'r':
                v17 = 13;
                goto LABEL_45;
              case 't':
                v17 = 9;
                goto LABEL_45;
            }
LABEL_50:
            *(_WORD *)&v14[2 * v13++] = v15;
            if ( v6 >= *(_DWORD *)(this + 4) )
              goto LABEL_51;
          }
          if ( v15 != 13 && v15 != 10 )
            goto LABEL_50;
          v17 = 12;
          goto LABEL_49;
        }
LABEL_51:
        *(_WORD *)(*(_DWORD *)this + 2 * v13) = 0;
        *(_DWORD *)(this + 4) = v13;
      }
    }
LABEL_52:
    v26 = -1;
    LOBYTE(v5) = sub_4089F9((int)v21);
    return (char)v5;
  }
  GetModuleFileNameW(0, Filename, 0x800u);
  v5 = wcsrchr(Filename, 0x5Cu);
  if ( v5 )
  {
    v4 = v5 + 1;
    goto LABEL_4;
  }
  return (char)v5;
}
// 40B8D7: using guessed type _DWORD var_1040[1033];

//----- (0040BBC2) --------------------------------------------------------
wchar_t *__thiscall sub_40BBC2(
        __int16 **this,
        wchar_t *Source,
        wchar_t *Destination,
        int a4,
        int a5,
        LPCWCH lpWideCharStr)
{
  wchar_t *v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  __int16 *v12; // eax
  const wchar_t *v13; // ebx
  wchar_t *v14; // eax
  unsigned int v15; // esi
  wchar_t *result; // eax
  char Str[4096]; // [esp+Ch] [ebp-2014h] BYREF
  CHAR MultiByteStr[4096]; // [esp+100Ch] [ebp-1014h] BYREF
  wchar_t Buffer[10]; // [esp+200Ch] [ebp-14h] BYREF

  if ( !*this )
    goto LABEL_20;
  v7 = L"";
  if ( a5 )
  {
    if ( a5 == 1 )
    {
      v7 = L"$";
    }
    else if ( a5 == 2 )
    {
      v7 = L"@";
    }
  }
  else
  {
    v7 = L"s";
  }
  v8 = sub_405595(0xFFFFFFFF, v7, 1u);
  if ( lpWideCharStr )
  {
    sub_411643(lpWideCharStr, Str, 4096);
    v9 = strlen(Str);
    v8 = sub_405595(v8, Str, v9);
  }
  sub_411643(Source, MultiByteStr, 4096);
  MultiByteStr[4095] = 0;
  v10 = strlen(MultiByteStr);
  v11 = sub_405595(v8, MultiByteStr, v10);
  swprintf(Buffer, 0xAu, L"%08x", ~v11);
  v12 = sub_40B84A(this, (int)Buffer);
  if ( v12 )
  {
    v13 = (const wchar_t *)(v12 + 10);
    v14 = wcschr((const wchar_t *)v12 + 10, 0xCu);
    if ( v14 )
      v15 = v14 - v13;
    else
      v15 = 255;
    if ( v15 > a4 - 1 )
      v15 = a4 != 0 ? a4 - 1 : 0;
    if ( v15 )
      wcsncpy(Destination, v13, v15);
    Destination[v15] = 0;
    result = wcsrchr(Destination, 0x22u);
    if ( result )
      *result = 0;
  }
  else
  {
LABEL_20:
    result = Destination;
    if ( Source != Destination )
      return wcscpy(Destination, Source);
  }
  return result;
}
// 42A6FC: using guessed type wchar_t aS_0[2];
// 42A700: using guessed type wchar_t asc_42A700[2];
// 42A704: using guessed type wchar_t asc_42A704[2];

//----- (0040BD12) --------------------------------------------------------
BOOL __thiscall sub_40BD12(__int16 **this, LPCWCH lpWideCharStr, _DWORD *a3, _DWORD *a4)
{
  wchar_t *v4; // edi
  _DWORD *v5; // esi
  int v6; // eax
  _DWORD *v7; // ecx
  wchar_t Str[512]; // [esp+Ch] [ebp-400h] BYREF

  sub_40BBC2(this, (wchar_t *)&String, Str, 512, 1, lpWideCharStr);
  v4 = wcschr(Str, 0x2Au);
  if ( v4 )
  {
    v5 = a3;
    *a3 = sub_411AC8(Str);
    v6 = sub_411AC8(v4 + 1);
    v7 = a4;
    *a4 = v6;
  }
  else
  {
    v7 = a4;
    v5 = a3;
    *a4 = 100;
    *a3 = 100;
  }
  return *v5 != 100 || *v7 != 100;
}
// 411AC8: using guessed type _DWORD __stdcall sub_411AC8(_DWORD);

//----- (0040BD93) --------------------------------------------------------
char __thiscall sub_40BD93(int this)
{
  HMODULE ModuleHandleW; // eax
  HRSRC ResourceW; // eax
  wchar_t String1[1024]; // [esp+8h] [ebp-800h] BYREF

  ModuleHandleW = GetModuleHandleW(0);
  ResourceW = FindResourceW(ModuleHandleW, L"RTL", (LPCWSTR)5);
  if ( ResourceW )
  {
    *(_BYTE *)(this + 16) = 1;
  }
  else
  {
    sub_40BBC2((__int16 **)this, (wchar_t *)L"LTR", String1, 1024, 1, L"LTR");
    LOBYTE(ResourceW) = wcscmp(String1, L"RTL") == 0;
    *(_BYTE *)(this + 16) = (_BYTE)ResourceW;
  }
  return (char)ResourceW;
}

//----- (0040BDF9) --------------------------------------------------------
HWND __thiscall sub_40BDF9(__int16 **this, HWND hWnd, LPCWCH lpWideCharStr, HWND a4)
{
  int v4; // edi
  int v5; // ebx
  int v6; // ebx
  int v7; // esi
  int v8; // edi
  HWND result; // eax
  WCHAR String[1024]; // [esp+Ch] [ebp-850h] BYREF
  struct tagRECT v11; // [esp+80Ch] [ebp-50h] BYREF
  struct tagRECT v12; // [esp+81Ch] [ebp-40h] BYREF
  struct tagRECT Rect; // [esp+82Ch] [ebp-30h] BYREF
  __int16 **v14; // [esp+83Ch] [ebp-20h]
  UINT uFlags; // [esp+840h] [ebp-1Ch]
  int cy; // [esp+844h] [ebp-18h]
  int v17; // [esp+848h] [ebp-14h]
  int v18; // [esp+84Ch] [ebp-10h] BYREF
  int v19; // [esp+850h] [ebp-Ch] BYREF
  HWND v20; // [esp+854h] [ebp-8h]
  bool v21; // [esp+85Bh] [ebp-1h]
  HWND hWnda; // [esp+864h] [ebp+8h]
  HWND v23; // [esp+86Ch] [ebp+10h]

  v14 = this;
  v21 = sub_40BD12(this, lpWideCharStr, &v18, &v19);
  GetWindowRect(hWnd, &Rect);
  GetClientRect(hWnd, &v11);
  v4 = Rect.bottom - Rect.top + 1 - v11.bottom;
  v5 = Rect.right - Rect.left + 1 - v11.right;
  v20 = (HWND)v5;
  if ( v21 )
  {
    if ( (_BYTE)a4 )
      goto LABEL_12;
    v17 = (int)v20 + v18 * v11.right / 100;
    cy = v4 + v19 * v11.bottom / 100;
    v6 = Rect.left + (Rect.right - Rect.left + 1 - v17) / 2;
    v7 = Rect.top + (Rect.bottom - Rect.top + 1 - cy) / 2;
    if ( v6 < 0 )
      v6 = 0;
    if ( v7 < 0 )
      v7 = 0;
    uFlags = 516;
    if ( (GetWindowLongW(hWnd, -16) & 0x800) == 0 )
      uFlags = 518;
    SetWindowPos(hWnd, 0, v6, v7, v17, cy, uFlags);
    GetWindowRect(hWnd, &Rect);
    v5 = (int)v20;
  }
  if ( !(_BYTE)a4 )
  {
    GetWindowTextW(hWnd, String, 1024);
    sub_40BBC2(v14, String, String, 1024, 1, lpWideCharStr);
    SetWindowTextW(hWnd, String);
  }
LABEL_12:
  v8 = v4 - GetSystemMetrics(8);
  result = GetWindow(hWnd, 5u);
  hWnda = 0;
  v23 = result;
  v20 = result;
  while ( result && (int)hWnda < 512 )
  {
    GetWindowTextW(v23, String, 1024);
    if ( String[0] )
    {
      sub_40BBC2(v14, String, String, 1024, 1, lpWideCharStr);
      SetWindowTextW(v23, String);
    }
    if ( v21 )
    {
      GetWindowRect(v23, &v12);
      SetWindowPos(
        v23,
        0,
        v18 * (v12.left - v5 / 2 - Rect.left) / 100,
        v19 * (v12.top - v8 - Rect.top) / 100,
        v18 * (v12.right - v12.left + 1) / 100,
        v19 * (v12.bottom - v12.top + 1) / 100,
        0x204u);
    }
    result = GetWindow(v23, 2u);
    v23 = result;
    if ( result == v20 )
      break;
    hWnda = (HWND)((char *)hWnda + 1);
  }
  return result;
}

//----- (0040C045) --------------------------------------------------------
char __thiscall sub_40C045(void *this, wchar_t *Source)
{
  sub_40B8D7((int)this, Source);
  return sub_40BD93((int)this);
}

//----- (0040C05C) --------------------------------------------------------
WCHAR *__stdcall sub_40C05C(UINT uID)
{
  unsigned int v1; // eax
  WCHAR *v2; // esi

  v1 = dword_434A90 + 1;
  dword_434A90 = v1;
  if ( v1 >= 8 )
  {
    v1 = 0;
    dword_434A90 = 0;
  }
  v2 = (WCHAR *)((char *)&unk_432A90 + 1024 * v1);
  *v2 = 0;
  if ( sub_40B842(&unk_432A7C) || !LoadStringW(hInstance, uID, v2, 512) )
    LoadStringW(dword_432A64, uID, v2, 512);
  sub_40BBC2((__int16 **)&unk_432A7C, v2, v2, 512, 0, 0);
  return v2;
}
// 434A90: using guessed type int dword_434A90;

//----- (0040C0D8) --------------------------------------------------------
int __stdcall sub_40C0D8(int *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax

  *a1 = *a3 ^ *a2;
  a1[1] = a3[1] ^ a2[1];
  a1[2] = a3[2] ^ a2[2];
  result = a3[3] ^ a2[3];
  a1[3] = result;
  return result;
}

//----- (0040C10A) --------------------------------------------------------
__m128i *__thiscall sub_40C10A(int this, const __m128i *a2, int a3, __m128i *a4)
{
  __m128i *result; // eax
  __m128i v5; // xmm1
  const __m128i *v7; // esi
  __m128i v8; // xmm2
  int v9; // eax
  const __m128i *v11; // edx
  bool v15; // zf
  __m128i *v16; // [esp+8h] [ebp-4h]

  result = a4;
  v5 = _mm_loadu_si128((const __m128i *)(this + 8));
  v16 = a4;
  v7 = (const __m128i *)(this + 24);
  if ( a3 )
  {
    do
    {
      v8 = _mm_loadu_si128(a2++);
      v9 = *(_DWORD *)(this + 4) - 1;
      _XMM0 = _mm_xor_si128(_mm_loadu_si128(&v7[*(_DWORD *)(this + 4)]), v8);
      if ( v9 > 0 )
      {
        v11 = &v7[v9];
        do
        {
          _XMM3 = _mm_loadu_si128(v11);
          --v9;
          --v11;
          __asm { aesdec  xmm0, xmm3 }
        }
        while ( v9 > 0 );
      }
      _XMM3 = _mm_loadu_si128(v7);
      __asm { aesdeclast xmm0, xmm3 }
      if ( *(_BYTE *)(this + 1) )
        _XMM0 = _mm_xor_si128(_XMM0, v5);
      result = v16++;
      v15 = a3-- == 1;
      v5 = v8;
      *result = _XMM0;
    }
    while ( !v15 );
  }
  *(__m128i *)(this + 8) = v5;
  return result;
}

//----- (0040C19C) --------------------------------------------------------
char __thiscall sub_40C19C(_DWORD *this, void *Src)
{
  int v2; // edi
  int v3; // ebx
  int v4; // ebx
  int v5; // eax
  int v6; // edx
  _DWORD *v7; // ecx
  _DWORD *v8; // edi
  _DWORD *v9; // esi
  _DWORD *v10; // ecx
  int v11; // edi
  int i; // esi
  _BYTE *v13; // ecx
  int v14; // edi
  int v15; // esi
  _BYTE *v16; // ecx
  int v17; // edi
  int v18; // esi
  int v19; // ecx
  _DWORD *v20; // edi
  _DWORD *v21; // esi
  char v23[4]; // [esp+8h] [ebp-3Ch] BYREF
  _DWORD v24[8]; // [esp+Ch] [ebp-38h] BYREF
  char *v25; // [esp+2Ch] [ebp-18h]
  char *v26; // [esp+30h] [ebp-14h]
  char *v27; // [esp+34h] [ebp-10h]
  char *v28; // [esp+38h] [ebp-Ch]
  char *v29; // [esp+3Ch] [ebp-8h]
  _DWORD *v30; // [esp+40h] [ebp-4h]
  int Srca; // [esp+4Ch] [ebp+8h]

  v2 = (int)this;
  v3 = this[1];
  v30 = this;
  v4 = v3 - 6;
  memcpy(v24, Src, sizeof(v24));
  v5 = 0;
  v6 = 0;
  Srca = 0;
  while ( v5 < v4 )
  {
    if ( v6 > *(_DWORD *)(v2 + 4) )
      return v5;
    if ( v5 < v4 )
    {
      v7 = &v24[v5];
      do
      {
        if ( Srca >= 4 )
          break;
        v8 = (_DWORD *)(v2 + 4 * (Srca + 4 * v6) + 24);
        v9 = v7;
        ++v5;
        ++v7;
        ++Srca;
        *v8 = *v9;
        v2 = (int)v30;
      }
      while ( v5 < v4 );
    }
    if ( Srca == 4 )
    {
      ++v6;
      Srca = 0;
    }
  }
  if ( v6 > *(_DWORD *)(v2 + 4) )
    return v5;
  v28 = &v23[4 * v4 + 1];
  v27 = &v23[4 * v4 + 2];
  v26 = &v23[4 * v4 + 3];
  v25 = &v23[4 * v4];
  v29 = &byte_437A98;
  while ( 1 )
  {
    LOBYTE(v24[0]) ^= byte_437BB8[(unsigned __int8)*v28];
    BYTE1(v24[0]) ^= byte_437BB8[(unsigned __int8)*v27];
    BYTE2(v24[0]) ^= byte_437BB8[(unsigned __int8)*v26];
    HIBYTE(v24[0]) ^= byte_437BB8[(unsigned __int8)*v25];
    LOBYTE(v5) = *v29++ ^ LOBYTE(v24[0]);
    LOBYTE(v24[0]) = v5;
    if ( v4 == 8 )
    {
      v13 = &v24[1];
      v14 = 3;
      do
      {
        v15 = 4;
        do
        {
          *v13 ^= *(v13 - 4);
          ++v13;
          --v15;
        }
        while ( v15 );
        --v14;
      }
      while ( v14 );
      LOBYTE(v24[4]) ^= byte_437BB8[LOBYTE(v24[3])];
      BYTE1(v24[4]) ^= byte_437BB8[BYTE1(v24[3])];
      BYTE2(v24[4]) ^= byte_437BB8[BYTE2(v24[3])];
      HIBYTE(v24[4]) ^= byte_437BB8[HIBYTE(v24[3])];
      v16 = &v24[5];
      v17 = 3;
      do
      {
        v18 = 4;
        do
        {
          LOBYTE(v5) = *(v16 - 4);
          *v16++ ^= v5;
          --v18;
        }
        while ( v18 );
        --v17;
      }
      while ( v17 );
    }
    else
    {
      if ( v4 <= 1 )
        goto LABEL_28;
      v10 = &v24[1];
      v11 = v4 - 1;
      do
      {
        for ( i = 0; i < 4; ++i )
        {
          LOBYTE(v5) = *((_BYTE *)v10 + i - 4);
          *((_BYTE *)v10 + i) ^= v5;
        }
        ++v10;
        --v11;
      }
      while ( v11 );
    }
    v2 = (int)v30;
LABEL_28:
    v19 = 0;
    if ( v4 > 0 )
      break;
LABEL_37:
    if ( v6 > *(_DWORD *)(v2 + 4) )
      return v5;
  }
  while ( v6 <= *(_DWORD *)(v2 + 4) )
  {
    if ( v19 < v4 )
    {
      v5 = (int)&v24[v19];
      do
      {
        if ( Srca >= 4 )
          break;
        v20 = (_DWORD *)(v2 + 4 * (Srca + 4 * v6) + 24);
        v21 = (_DWORD *)v5;
        ++v19;
        v5 += 4;
        ++Srca;
        *v20 = *v21;
        v2 = (int)v30;
      }
      while ( v19 < v4 );
    }
    if ( Srca == 4 )
    {
      ++v6;
      Srca = 0;
    }
    if ( v19 >= v4 )
      goto LABEL_37;
  }
  return v5;
}
// 437A98: using guessed type char byte_437A98;

//----- (0040C361) --------------------------------------------------------
int __thiscall sub_40C361(_DWORD *this)
{
  int result; // eax
  bool v3; // cc
  int i; // eax
  char *v5; // esi
  unsigned __int8 *v6; // ecx
  char v7; // dl
  char Src[16]; // [esp+4h] [ebp-1Ch] BYREF
  int v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+18h] [ebp-8h]
  void *v11; // [esp+1Ch] [ebp-4h]

  result = 1;
  v3 = this[1] <= 1;
  v10 = 1;
  if ( !v3 )
  {
    v11 = this + 10;
    do
    {
      for ( i = 0; i < 4; ++i )
      {
        v5 = &Src[i];
        v6 = (unsigned __int8 *)v11 + 2;
        v9 = 4;
        do
        {
          v7 = byte_434E98[4 * *v6 + i] ^ byte_435698[4 * *(v6 - 2) + i] ^ byte_435298[4 * *(v6 - 1) + i] ^ byte_434A98[4 * v6[1] + i];
          v6 += 4;
          *v5 = v7;
          v5 += 4;
          --v9;
        }
        while ( v9 );
      }
      memcpy(v11, Src, 0x10u);
      v11 = (char *)v11 + 16;
      result = ++v10;
    }
    while ( v10 < this[1] );
  }
  return result;
}

//----- (0040C3F3) --------------------------------------------------------
int sub_40C3F3()
{
  int v0; // ecx
  int v1; // eax
  unsigned int i; // ecx
  int v3; // ebx
  __int16 v4; // ax
  __int16 v5; // ax
  unsigned __int8 v6; // cl
  int result; // eax
  unsigned __int8 *v8; // edx
  char v9; // dl
  char v10; // cl
  unsigned __int8 v11; // bl
  char v12; // dl
  int v13; // ecx
  char v14; // dl
  char v15; // dl
  char v16; // dl
  bool v17; // cc
  char v18[255]; // [esp+Ch] [ebp-304h]
  char v19[513]; // [esp+10Bh] [ebp-205h]
  int j; // [esp+30Ch] [ebp-4h]

  v0 = 0;
  v1 = 1;
  do
  {
    v18[v0] = v1;
    v19[v0] = v1;
    v19[v1 + 257] = v0++;
    v1 ^= (2 * v1) ^ ((char)(v1 & 0x80) != 0 ? 0x11B : 0);
  }
  while ( v1 != 1 );
  for ( i = 0; i < 0x1E; ++i )
  {
    byte_437A98[i] = v1;
    v1 = ((char)(v1 & 0x80) != 0 ? 0x11B : 0) ^ (2 * v1);
  }
  v3 = 0;
  for ( j = 0; ; v3 = j )
  {
    v4 = (_BYTE)v3 ? (unsigned __int8)v19[-(unsigned __int8)v19[(unsigned __int8)v3 + 257]] : 0;
    v5 = (2 * (v4 ^ (2 * (v4 ^ (2 * (v4 ^ (2 * v4))))))) ^ v4;
    v6 = v5 ^ HIBYTE(v5) ^ 0x63;
    result = v3;
    v8 = (unsigned __int8 *)&unk_436A98 + 4 * v3;
    byte_437BB8[v3] = v6;
    v8[1] = v6;
    *v8 = v6;
    byte_436E9B[result * 4] = v6;
    byte_436E98[result * 4] = v6;
    byte_43729B[result * 4] = v6;
    byte_43729A[result * 4] = v6;
    byte_43769A[result * 4] = v6;
    byte_437699[result * 4] = v6;
    v9 = v6 ? v18[(unsigned __int8)v19[v6 + 257] + 25] : 0;
    byte_436A9B[4 * v3] = v9;
    byte_436E9A[4 * v3] = v9;
    byte_437299[4 * v3] = v9;
    byte_437698[4 * v3] = v9;
    v10 = v6 ? v18[(unsigned __int8)v19[v6 + 257] + 1] : 0;
    byte_436A9A[4 * v3] = v10;
    byte_436E99[4 * v3] = v10;
    byte_437298[4 * v3] = v10;
    byte_43769B[4 * v3] = v10;
    v11 = (unsigned __int8)((2 * (v3 ^ (4 * (v3 ^ (8 * v3))))) ^ (((unsigned __int8)v3 ^ (4
                                                                                        * ((unsigned __int8)v3 ^ (8 * (unsigned __int8)v3)))) >> 7)) ^ 5
        ? v19[-(unsigned __int8)v19[((unsigned __int8)(2 * (v3 ^ (4 * (v3 ^ (8 * v3))))) ^ (unsigned __int8)(((unsigned __int8)v3 ^ (4 * ((unsigned __int8)v3 ^ (8 * (unsigned __int8)v3)))) >> 7) ^ 5)
                                  + 257]]
        : 0;
    byte_437AB8[j] = v11;
    v12 = v11 ? v18[(unsigned __int8)v19[v11 + 257] + 104] : 0;
    v13 = 4 * v11;
    BYTE2(dword_435A98[result]) = v12;
    BYTE1(dword_435E98[result]) = v12;
    LOBYTE(dword_436298[result]) = v12;
    HIBYTE(dword_436698[result]) = v12;
    byte_434A9A[v13] = v12;
    byte_434E99[v13] = v12;
    byte_435298[v13] = v12;
    byte_43569B[v13] = v12;
    v14 = v11 ? v18[(unsigned __int8)v19[v11 + 257] + 199] : 0;
    LOBYTE(dword_435A98[result]) = v14;
    HIBYTE(dword_435E98[result]) = v14;
    BYTE2(dword_436298[result]) = v14;
    BYTE1(dword_436698[result]) = v14;
    byte_434A98[4 * v11] = v14;
    byte_434E9B[4 * v11] = v14;
    byte_43529A[4 * v11] = v14;
    byte_435699[4 * v11] = v14;
    v15 = v11 ? v18[(unsigned __int8)v19[v11 + 257] + 238] : 0;
    BYTE1(dword_435A98[result]) = v15;
    LOBYTE(dword_435E98[result]) = v15;
    HIBYTE(dword_436298[result]) = v15;
    BYTE2(dword_436698[result]) = v15;
    byte_434A99[4 * v11] = v15;
    byte_434E98[4 * v11] = v15;
    byte_43529B[4 * v11] = v15;
    byte_43569A[4 * v11] = v15;
    v16 = v11 ? v18[(unsigned __int8)v19[v11 + 257] + 223] : 0;
    v17 = ++j < 256;
    HIBYTE(dword_435A98[result]) = v16;
    BYTE2(dword_435E98[result]) = v16;
    BYTE1(dword_436298[result]) = v16;
    LOBYTE(dword_436698[result]) = v16;
    byte_434A9B[4 * v11] = v16;
    byte_434E9A[4 * v11] = v16;
    byte_435299[4 * v11] = v16;
    byte_435698[4 * v11] = v16;
    if ( !v17 )
      break;
  }
  return result * 4;
}
// 435A98: using guessed type int dword_435A98[];
// 435E98: using guessed type int dword_435E98[];
// 436298: using guessed type int dword_436298[];
// 436698: using guessed type int dword_436698[];

//----- (0040C6D6) --------------------------------------------------------
_BYTE *__thiscall sub_40C6D6(_BYTE *this)
{
  if ( !byte_437BB8[0] )
    sub_40C3F3();
  this[1] = 1;
  return this;
}

//----- (0040C6EF) --------------------------------------------------------
char __thiscall sub_40C6EF(bool *this, int a2, int a3, int a4, int Val)
{
  bool *v10; // esi
  unsigned int v11; // ecx
  unsigned int i; // eax
  char v13; // bl
  unsigned int v14; // edx
  int v15; // edi
  int j; // eax
  char result; // al
  char Src[16]; // [esp+4h] [ebp-24h] BYREF
  int v19; // [esp+14h] [ebp-14h]
  int v20; // [esp+18h] [ebp-10h]
  int v21; // [esp+1Ch] [ebp-Ch]
  int v22; // [esp+20h] [ebp-8h]
  bool *v23; // [esp+24h] [ebp-4h]

  _EAX = 1;
  v23 = this;
  __asm { cpuid }
  v19 = _EAX;
  v20 = _EBX;
  v21 = _ECX;
  v22 = _EDX;
  v10 = v23;
  *v23 = (_ECX & 0x2000000) != 0;
  switch ( a4 )
  {
    case 128:
      v11 = 16;
      *((_DWORD *)v10 + 1) = 10;
      break;
    case 192:
      v11 = 24;
      *((_DWORD *)v10 + 1) = 12;
      break;
    case 256:
      v11 = 32;
      *((_DWORD *)v10 + 1) = 14;
      break;
    default:
      v11 = a2;
      break;
  }
  for ( i = 0; i < v11; Src[4 * v14 + v15] = v13 )
  {
    v13 = *(_BYTE *)(i + a3);
    v14 = i >> 2;
    v15 = i++ & 3;
  }
  if ( Val )
  {
    for ( j = 0; j < 16; ++j )
      v10[j + 8] = *(_BYTE *)(j + Val);
  }
  else
  {
    memset(v10 + 8, 0, 0x10u);
  }
  result = sub_40C19C(v10, Src);
  if ( !(_BYTE)a2 )
    return sub_40C361(v10);
  return result;
}

//----- (0040C7C0) --------------------------------------------------------
__m128i *__thiscall sub_40C7C0(_DWORD *this, const __m128i *a2, __m128i *a3, __m128i *a4)
{
  __m128i *result; // eax
  unsigned int v6; // edi
  __int32 *v7; // edi
  __int32 *v8; // ebx
  int v9; // eax
  bool v10; // zf
  int Src[4]; // [esp+4h] [ebp-34h] BYREF
  int v12; // [esp+14h] [ebp-24h] BYREF
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h] BYREF
  unsigned __int8 v17; // [esp+28h] [ebp-10h]
  unsigned __int8 v18; // [esp+29h] [ebp-Fh]
  unsigned __int8 v19; // [esp+2Ah] [ebp-Eh]
  unsigned __int8 v20; // [esp+2Bh] [ebp-Dh]
  unsigned __int8 v21; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 v22; // [esp+2Dh] [ebp-Bh]
  unsigned __int8 v23; // [esp+2Eh] [ebp-Ah]
  unsigned __int8 v24; // [esp+2Fh] [ebp-9h]
  unsigned __int8 v25; // [esp+30h] [ebp-8h]
  unsigned __int8 v26; // [esp+31h] [ebp-7h]
  unsigned __int8 v27; // [esp+32h] [ebp-6h]
  unsigned __int8 v28; // [esp+33h] [ebp-5h]
  void *v29; // [esp+34h] [ebp-4h]
  int v30; // [esp+40h] [ebp+8h]
  unsigned int v31; // [esp+44h] [ebp+Ch]
  _DWORD *v32; // [esp+48h] [ebp+10h]

  result = a3;
  if ( a3 )
  {
    v6 = (unsigned int)a3 >> 4;
    if ( *(_BYTE *)this )
    {
      return sub_40C10A((int)this, a2, (unsigned int)a3 >> 4, a4);
    }
    else
    {
      v29 = this + 2;
      memcpy(Src, this + 2, sizeof(Src));
      v31 = (unsigned int)a3 >> 4;
      if ( v6 )
      {
        v7 = (__int32 *)a2;
        v8 = (__int32 *)a4;
        do
        {
          sub_40C0D8(&v16, v7, &this[4 * this[1] + 6]);
          v12 = dword_435A98[v20] ^ dword_435E98[v23] ^ dword_436298[v26] ^ dword_436698[(unsigned __int8)v16];
          v13 = dword_435A98[v24] ^ dword_435E98[v27] ^ dword_436298[BYTE1(v16)] ^ dword_436698[v17];
          v14 = dword_435A98[v28] ^ dword_435E98[BYTE2(v16)] ^ dword_436298[v18] ^ dword_436698[v21];
          v15 = dword_435A98[HIBYTE(v16)] ^ dword_435E98[v19] ^ dword_436298[v22] ^ dword_436698[v25];
          v9 = this[1] - 1;
          if ( v9 > 1 )
          {
            v32 = &this[4 * v9 + 6];
            v30 = this[1] - 2;
            do
            {
              sub_40C0D8(&v16, &v12, v32);
              v12 = dword_435A98[v20] ^ dword_435E98[v23] ^ dword_436298[v26] ^ dword_436698[(unsigned __int8)v16];
              v13 = dword_435A98[v24] ^ dword_435E98[v27] ^ dword_436298[BYTE1(v16)] ^ dword_436698[v17];
              v32 -= 4;
              v14 = dword_435A98[v28] ^ dword_435E98[BYTE2(v16)] ^ dword_436298[v18] ^ dword_436698[v21];
              v10 = v30-- == 1;
              v15 = dword_435A98[HIBYTE(v16)] ^ dword_435E98[v19] ^ dword_436298[v22] ^ dword_436698[v25];
            }
            while ( !v10 );
          }
          sub_40C0D8(&v16, &v12, this + 10);
          LOBYTE(v12) = byte_437AB8[(unsigned __int8)v16];
          BYTE1(v12) = byte_437AB8[v26];
          BYTE2(v12) = byte_437AB8[v23];
          HIBYTE(v12) = byte_437AB8[v20];
          LOBYTE(v13) = byte_437AB8[v17];
          BYTE1(v13) = byte_437AB8[BYTE1(v16)];
          BYTE2(v13) = byte_437AB8[v27];
          HIBYTE(v13) = byte_437AB8[v24];
          LOBYTE(v14) = byte_437AB8[v21];
          BYTE1(v14) = byte_437AB8[v18];
          BYTE2(v14) = byte_437AB8[BYTE2(v16)];
          HIBYTE(v14) = byte_437AB8[v28];
          LOBYTE(v15) = byte_437AB8[v25];
          BYTE1(v15) = byte_437AB8[v22];
          BYTE2(v15) = byte_437AB8[v19];
          HIBYTE(v15) = byte_437AB8[HIBYTE(v16)];
          sub_40C0D8(&v12, &v12, this + 6);
          if ( *((_BYTE *)this + 1) )
            sub_40C0D8(&v12, &v12, Src);
          Src[0] = *v7;
          Src[1] = v7[1];
          Src[2] = v7[2];
          Src[3] = v7[3];
          *v8 = v12;
          v8[1] = v13;
          v8[2] = v14;
          v8[3] = v15;
          v7 += 4;
          v8 += 4;
          --v31;
        }
        while ( v31 );
      }
      return (__m128i *)memcpy(v29, Src, 0x10u);
    }
  }
  return result;
}
// 435A98: using guessed type int dword_435A98[];
// 435E98: using guessed type int dword_435E98[];
// 436298: using guessed type int dword_436298[];
// 436698: using guessed type int dword_436698[];

//----- (0040CB53) --------------------------------------------------------
void __thiscall sub_40CB53(HMODULE *this)
{
  HMODULE LibraryW; // eax
  BOOL (__stdcall *CryptProtectMemory)(LPVOID, DWORD, DWORD); // eax
  HMODULE v4; // [esp-Ch] [ebp-10h]

  if ( !*((_BYTE *)this + 4) )
  {
    LibraryW = LoadLibraryW(L"Crypt32.dll");
    *this = LibraryW;
    if ( LibraryW )
    {
      CryptProtectMemory = (BOOL (__stdcall *)(LPVOID, DWORD, DWORD))GetProcAddress(LibraryW, "CryptProtectMemory");
      v4 = *this;
      this[2] = (HMODULE)CryptProtectMemory;
      this[3] = (HMODULE)GetProcAddress(v4, "CryptUnprotectMemory");
    }
    *((_BYTE *)this + 4) = 1;
  }
}

//----- (0040CB92) --------------------------------------------------------
DWORD __stdcall sub_40CB92(int a1, unsigned int a2, char a3)
{
  unsigned int v3; // eax
  DWORD result; // eax
  unsigned int v5; // ecx
  char v6; // dl
  wchar_t *v7; // [esp-4h] [ebp-Ch]

  if ( !dword_437CC0 )
    sub_40CB53(dword_437CB8);
  v3 = a2 - (a2 & 0xF);
  if ( a3 )
  {
    if ( dword_437CC0 )
    {
      result = dword_437CC0(a1, v3, 0);
      if ( result )
        return result;
      v7 = (wchar_t *)L"CryptProtectMemory failed";
      goto LABEL_7;
    }
    goto LABEL_11;
  }
  if ( !dword_437CC4 )
  {
LABEL_11:
    result = GetCurrentProcessId();
    v5 = 0;
    if ( a2 )
    {
      v6 = result + 75;
      do
      {
        result = v5 + a1;
        *(_BYTE *)(v5 + a1) ^= (_BYTE)v5 + v6;
        ++v5;
      }
      while ( v5 < a2 );
    }
    return result;
  }
  result = dword_437CC4(a1, v3, 0);
  if ( !result )
  {
    v7 = L"CryptUnprotectMemory failed";
LABEL_7:
    sub_40634C((int)&dword_432A6C, v7);
    nullsub_2(&dword_432A6C);
    return sub_4062C3(2);
  }
  return result;
}
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 42A75C: using guessed type wchar_t aCryptunprotect_0[28];
// 432A6C: using guessed type int dword_432A6C;
// 437CB8: using guessed type HMODULE dword_437CB8[2];
// 437CC0: using guessed type int (__stdcall *dword_437CC0)(_DWORD, _DWORD, _DWORD);
// 437CC4: using guessed type int (__stdcall *dword_437CC4)(_DWORD, _DWORD, _DWORD);

//----- (0040CC38) --------------------------------------------------------
_BYTE *__stdcall sub_40CC38(_BYTE *a1, int a2)
{
  int v2; // ecx
  _BYTE *result; // eax

  v2 = a2;
  for ( result = a1; v2; --v2 )
    *result++ = 0;
  return result;
}

//----- (0040CC4E) --------------------------------------------------------
DWORD __stdcall sub_40CC4E(void *Src, unsigned int a2, void *a3, unsigned int a4, char a5)
{
  unsigned int v5; // eax

  v5 = a2;
  if ( a2 >= a4 )
    v5 = a4;
  memcpy(a3, Src, 2 * v5);
  return sub_40CB92((int)a3, 2 * a4, a5);
}

//----- (0040CC83) --------------------------------------------------------
int __thiscall sub_40CC83(void *Src, _WORD *a2, int a3)
{
  int result; // eax

  if ( *((_BYTE *)Src + 256) )
  {
    sub_40CC4E(Src, 0x80u, a2, a3, 0);
    result = 0;
    a2[a3 - 1] = 0;
  }
  else
  {
    result = 0;
    *a2 = 0;
  }
  return result;
}

//----- (0040CCBC) --------------------------------------------------------
void *__thiscall sub_40CCBC(_BYTE *this, wchar_t *String)
{
  size_t v3; // eax

  if ( *String )
  {
    this[256] = 1;
    v3 = wcslen(String);
    return (void *)sub_40CC4E(String, v3 + 1, this, 0x80u, 1);
  }
  else
  {
    this[256] = 0;
    return memset(this, 0, 0x100u);
  }
}

//----- (0040CD07) --------------------------------------------------------
int __thiscall sub_40CD07(void *this, void *Src)
{
  int v2; // esi
  int result; // eax
  int v4; // edx
  wchar_t *v5; // ecx
  wchar_t *v6; // ecx
  wchar_t String2[128]; // [esp+4h] [ebp-200h] BYREF
  wchar_t String1[128]; // [esp+104h] [ebp-100h] BYREF

  v2 = 128;
  sub_40CC83(this, String1, 128);
  sub_40CC83(Src, String2, 128);
  result = -wcscmp(String1, String2);
  LOBYTE(result) = result == 0;
  v4 = 128;
  v5 = String1;
  do
  {
    *(_BYTE *)v5 = 0;
    v5 = (wchar_t *)((char *)v5 + 1);
    --v4;
  }
  while ( v4 );
  v6 = String2;
  do
  {
    *(_BYTE *)v6 = 0;
    v6 = (wchar_t *)((char *)v6 + 1);
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (0040CD6F) --------------------------------------------------------
_BYTE *__thiscall sub_40CD6F(_BYTE *this)
{
  sub_40CCBC(this, (wchar_t *)&String);
  return this;
}

//----- (0040CD80) --------------------------------------------------------
_BYTE *__thiscall sub_40CD80(_BYTE *this)
{
  this[256] = 0;
  return sub_40CC38(this, 256);
}

//----- (0040CD98) --------------------------------------------------------
LRESULT sub_40CD98()
{
  LRESULT result; // eax
  struct tagMSG Msg; // [esp+4h] [ebp-1Ch] BYREF

  result = PeekMessageW(&Msg, 0, 0, 0, 0);
  if ( result )
  {
    GetMessageW(&Msg, 0, 0, 0);
    TranslateMessage(&Msg);
    return DispatchMessageW(&Msg);
  }
  return result;
}

//----- (0040CDD7) --------------------------------------------------------
int __stdcall sub_40CDD7(__int64 a1, LPWSTR lpNumberStr, int cchNumber)
{
  int result; // eax
  WCHAR LCData[100]; // [esp+Ch] [ebp-12Ch] BYREF
  WCHAR Value[50]; // [esp+D4h] [ebp-64h] BYREF

  if ( !Format.lpThousandSep )
  {
    GetLocaleInfoW(0x400u, 0xFu, LCData, 100);
    word_44C3DC = LCData[0];
    word_44C3DE = 0;
    Format.lpThousandSep = (LPWSTR)&word_44C3DC;
  }
  sub_4107EB(a1, (int)Value);
  *lpNumberStr = 0;
  GetNumberFormatW(0x400u, 0, Value, &Format, lpNumberStr, cchNumber);
  result = 0;
  lpNumberStr[cchNumber - 1] = 0;
  return result;
}
// 44C3DC: using guessed type __int16 word_44C3DC;
// 44C3DE: using guessed type __int16 word_44C3DE;
// 40CDD7: using guessed type WCHAR LCData[100];

//----- (0040CE5E) --------------------------------------------------------
unsigned int __stdcall sub_40CE5E(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // eax

  v2 = a1;
  if ( a1 > 0xF4240 )
  {
    v2 = a1 >> 8;
    a2 >>= 8;
  }
  if ( !a2 )
    return 0;
  if ( a2 >= v2 )
    return 100 * v2 / a2;
  return 100;
}

//----- (0040CE92) --------------------------------------------------------
int __stdcall sub_40CE92(LPWSTR pszPath, int csidl)
{
  IMalloc *ppMalloc; // [esp+0h] [ebp-8h] BYREF
  LPITEMIDLIST ppidl; // [esp+4h] [ebp-4h] BYREF

  SHGetMalloc(&ppMalloc);
  SHGetSpecialFolderLocation(0, csidl, &ppidl);
  SHGetPathFromIDListW(ppidl, pszPath);
  return ((int (__stdcall *)(IMalloc *, LPITEMIDLIST))ppMalloc->lpVtbl->Free)(ppMalloc, ppidl);
}

//----- (0040CECC) --------------------------------------------------------
__int16 *__stdcall sub_40CECC(__int16 *a1)
{
  __int16 *result; // eax
  __int16 *v2; // ecx
  __int16 v3; // si
  __int16 v4; // [esp-8h] [ebp-8h]

  result = a1;
  v2 = a1;
  if ( *a1 )
  {
    while ( *v2 == 92 )
    {
      v3 = v2[1];
      if ( v3 == 92 )
      {
        v4 = 92;
      }
      else
      {
        if ( v3 != 110 )
          break;
        v4 = 10;
      }
      *result++ = v4;
      v2 += 2;
LABEL_9:
      if ( !*v2 )
        goto LABEL_10;
    }
    *result++ = *v2++;
    goto LABEL_9;
  }
LABEL_10:
  *result = 0;
  return result;
}

//----- (0040CF18) --------------------------------------------------------
int __stdcall sub_40CF18(int a1)
{
  HDC DC; // eax
  HDC v2; // esi

  if ( !dword_44C3E0 )
  {
    DC = GetDC(0);
    v2 = DC;
    if ( DC )
    {
      dword_44C3E0 = GetDeviceCaps(DC, 88);
      ReleaseDC(0, v2);
    }
  }
  return a1 * dword_44C3E0 / 96;
}
// 44C3E0: using guessed type int dword_44C3E0;

//----- (0040CF5B) --------------------------------------------------------
int __stdcall sub_40CF5B(int a1)
{
  HDC DC; // eax
  HDC v2; // esi

  if ( !dword_44C3E4 )
  {
    DC = GetDC(0);
    v2 = DC;
    if ( DC )
    {
      dword_44C3E4 = GetDeviceCaps(DC, 90);
      ReleaseDC(0, v2);
    }
  }
  return a1 * dword_44C3E4 / 96;
}
// 44C3E4: using guessed type int dword_44C3E4;

//----- (0040CF9E) --------------------------------------------------------
BOOL sub_40CF9E()
{
  return sub_40CF18(100) >= 125 || sub_40CF5B(100) >= 125;
}

//----- (0040CFBD) --------------------------------------------------------
LRESULT __stdcall sub_40CFBD(char a1, LPARAM a2)
{
  HWND DlgItem; // edi
  LPARAM lParam; // [esp+Ch] [ebp-60h] BYREF
  int v5; // [esp+10h] [ebp-5Ch]
  unsigned int v6; // [esp+14h] [ebp-58h]
  int v7; // [esp+20h] [ebp-4Ch]
  char v8; // [esp+25h] [ebp-47h]
  HWND hWnd; // [esp+68h] [ebp-4h]

  DlgItem = GetDlgItem(hWndParent, 104);
  hWnd = DlgItem;
  if ( !byte_440CFC )
  {
    sub_418CA4((HWND *)dword_437CCC);
    ShowWindow(DlgItem, 5);
    SendMessageW(DlgItem, 0xB1u, 0, -1);
    SendMessageW(DlgItem, 0xC2u, 0, (LPARAM)&String);
    byte_440CFC = 1;
  }
  SendMessageW(hWnd, 0xB1u, 0x5F5E100u, 100000000);
  lParam = 92;
  SendMessageW(hWnd, 0x43Au, 0, (LPARAM)&lParam);
  v8 = 0;
  v5 = 1;
  if ( a1 )
  {
    v6 = v6 & 0xBFFFFFFE | 1;
    v7 = 160;
    v5 = 1073741825;
  }
  SendMessageW(hWnd, 0x444u, 1u, (LPARAM)&lParam);
  SendMessageW(hWnd, 0xC2u, 0, a2);
  SendMessageW(hWnd, 0xB1u, 0x5F5E100u, 100000000);
  if ( a1 )
  {
    v6 = v6 & 0xBFFFFFFE | 0x40000000;
    SendMessageW(hWnd, 0x444u, 1u, (LPARAM)&lParam);
  }
  return SendMessageW(hWnd, 0xC2u, 0, (LPARAM)L"\r\n");
}
// 440CFC: using guessed type char byte_440CFC;

//----- (0040D0D1) --------------------------------------------------------
LPCWSTR sub_40D0D1(LPCWSTR a1, ...)
{
  LPCWSTR result; // eax
  WCHAR v2[5120]; // [esp+0h] [ebp-2800h] BYREF
  va_list va; // [esp+280Ch] [ebp+Ch] BYREF

  va_start(va, a1);
  result = a1;
  if ( a1 )
  {
    if ( !*a1 )
      return result;
    wvsprintfW(v2, a1, va);
    result = (LPCWSTR)sub_40CFBD(1, (LPARAM)v2);
  }
  ++dword_440CF0;
  return result;
}
// 440CF0: using guessed type int dword_440CF0;

//----- (0040D113) --------------------------------------------------------
INT_PTR __stdcall sub_40D113(HWND hDlg, int a2, int a3, WCHAR *lpString)
{
  if ( !sub_406056(hDlg, a2, a3, (int)lpString, &off_42A7E0, 0, 0) )
  {
    if ( a2 == 272 )
    {
      ::lpString = lpString;
      SetDlgItemTextW(hDlg, 101, lpString);
      SetDlgItemTextW(hDlg, 102, ::lpString);
    }
    else
    {
      if ( a2 != 273 )
        return 0;
      if ( (unsigned __int16)a3 == 1 )
      {
        GetDlgItemTextW(hDlg, 102, ::lpString, 2048);
        EndDialog(hDlg, 1);
      }
      else
      {
        if ( (unsigned __int16)a3 != 2 )
          return 0;
        EndDialog(hDlg, 0);
      }
    }
  }
  return 1;
}

//----- (0040D19C) --------------------------------------------------------
INT_PTR __stdcall DialogFunc(HWND hDlg, int a2, int a3, const WCHAR *lpString)
{
  WCHAR String[128]; // [esp+8h] [ebp-100h] BYREF

  if ( !sub_406056(hDlg, a2, a3, (int)lpString, &TemplateName, 0, 0) )
  {
    if ( a2 == 272 )
    {
      SetDlgItemTextW(hDlg, 102, lpString);
    }
    else
    {
      if ( a2 != 273 )
        return 0;
      if ( (unsigned __int16)a3 == 1 )
      {
        GetDlgItemTextW(hDlg, 101, String, 128);
        sub_40CCBC(byte_44C2D8, String);
        sub_40CC38(String, 128);
        EndDialog(hDlg, 1);
      }
      else
      {
        if ( (unsigned __int16)a3 != 2 )
          return 0;
        EndDialog(hDlg, 0);
      }
    }
  }
  return 1;
}
// 44C2D8: using guessed type _BYTE byte_44C2D8[256];

//----- (0040D238) --------------------------------------------------------
LRESULT __stdcall sub_40D238(int a1, int a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7, int a8)
{
  unsigned int v8; // eax

  v8 = sub_40CE5E(a5, a7);
  SendDlgItemMessageW(hWndParent, 106, 0x402u, v8, 0);
  return sub_40CD98();
}

//----- (0040D263) --------------------------------------------------------
INT_PTR __stdcall sub_40D263(HWND hDlg, int a2, int a3, const WCHAR **a4)
{
  WCHAR *v5; // eax
  WCHAR *v6; // [esp-Ch] [ebp-14h]
  wchar_t *v7; // [esp-8h] [ebp-10h]
  const WCHAR *v8; // [esp-4h] [ebp-Ch]

  if ( !sub_406056(hDlg, a2, a3, (int)a4, L"ASKNEXTVOL", 0, 0) )
  {
    if ( a2 == 272 )
    {
      v8 = *a4;
      dword_44C3EC = (int)a4;
      SetDlgItemTextW(hDlg, 101, v8);
    }
    else
    {
      if ( a2 != 273 )
        return 0;
      switch ( (unsigned __int16)a3 )
      {
        case 1u:
          GetDlgItemTextW(hDlg, 101, *(LPWSTR *)dword_44C3EC, *(_DWORD *)(dword_44C3EC + 4));
          EndDialog(hDlg, 1);
          break;
        case 2u:
          EndDialog(hDlg, 0);
          break;
        case 0x66u:
          v7 = sub_40A0CE(*(wchar_t **)dword_44C3EC);
          v6 = *(WCHAR **)dword_44C3EC;
          v5 = sub_40C05C(0x8Eu);
          if ( sub_405104(hDlg, v5, v6, v7, 0) )
            SetDlgItemTextW(hDlg, 101, *(LPCWSTR *)dword_44C3EC);
          break;
        default:
          return 0;
      }
    }
  }
  return 1;
}
// 44C3EC: using guessed type int dword_44C3EC;

//----- (0040D31C) --------------------------------------------------------
unsigned __int16 *__stdcall sub_40D31C(unsigned __int16 *a1)
{
  unsigned __int16 *result; // eax
  unsigned __int16 *i; // edi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  __int16 v9[2]; // [esp+8h] [ebp-804h] BYREF
  wchar_t Source; // [esp+Ch] [ebp-800h] BYREF
  wchar_t v11[1021]; // [esp+Eh] [ebp-7FEh] BYREF
  int v12; // [esp+808h] [ebp-4h]

  v12 = 0;
  result = sub_410841(a1, (int)v9, 1024);
  for ( i = result; result; i = result )
  {
    if ( ++v12 == 1 || v9[0] != 47 && v9[0] != 45 )
      goto LABEL_22;
    v3 = sub_411A29(v9[1]) - 68;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( !v4 )
      {
        if ( sub_411A29(Source) == 76 && !v11[0] )
          byte_440D31 = 1;
        goto LABEL_22;
      }
      v5 = v4 - 11;
      if ( v5 )
      {
        if ( v5 == 3 )
        {
          v6 = sub_411A29(Source);
          if ( v6 && (v7 = v6 - 49) != 0 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 30 )
                sub_41078F(word_441D32, v11, 2048);
              goto LABEL_22;
            }
            dword_440D2C = 2;
          }
          else
          {
            dword_440D2C = 1;
          }
          byte_440CFE = 1;
        }
      }
      else
      {
        sub_40CCBC(byte_442D32, &Source);
      }
    }
    else
    {
      sub_41078F(word_440D32, &Source, 2048);
    }
LABEL_22:
    result = sub_410841(i, (int)v9, 1024);
  }
  return result;
}
// 440CFE: using guessed type char byte_440CFE;
// 440D2C: using guessed type int dword_440D2C;
// 440D31: using guessed type char byte_440D31;
// 440D32: using guessed type wchar_t word_440D32[2048];
// 441D32: using guessed type wchar_t word_441D32[2048];
// 442D32: using guessed type _BYTE byte_442D32[256];
// 40D31C: using guessed type wchar_t var_7FE[1021];

//----- (0040D46E) --------------------------------------------------------
WCHAR *__fastcall sub_40D46E(_BYTE *a1, WCHAR *a2, WCHAR *a3, wchar_t *Destination, _BYTE *a5, int a6)
{
  WCHAR *v7; // edi
  WCHAR v8; // ax
  const WCHAR *v9; // esi
  int v10; // ecx
  WCHAR Dst[4096]; // [esp+8h] [ebp-2000h] BYREF

  v7 = a3;
  if ( a1 )
    *a1 = 0;
  if ( a5 )
    *a5 = 0;
  if ( !a3 )
    return 0;
  v8 = *a3;
  if ( !*a3 )
    return 0;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    ++v7;
    if ( v8 != 61 )
      break;
    if ( Destination && !v9 )
    {
      if ( a1 )
        *a1 = 1;
      v9 = a2;
      goto LABEL_17;
    }
LABEL_16:
    *a2++ = v8;
    if ( v10 >= a6 - 2 )
    {
      *a5 = 1;
      goto LABEL_21;
    }
LABEL_17:
    v8 = *v7;
    ++v10;
    if ( !*v7 )
      goto LABEL_21;
  }
  if ( v8 != 13 )
  {
    if ( v8 == 10 )
      goto LABEL_21;
    goto LABEL_16;
  }
  ++v7;
LABEL_21:
  *a2 = 0;
  if ( Destination )
  {
    *Destination = 0;
    if ( v9 )
    {
      ExpandEnvironmentStringsW(v9, Dst, 0x1000u);
      sub_41078F(Destination, Dst, a6);
      *v9 = 0;
    }
  }
  return v7;
}

//----- (0040D544) --------------------------------------------------------
DWORD __stdcall sub_40D544(HANDLE hHandle)
{
  DWORD result; // eax
  struct tagMSG Msg; // [esp+8h] [ebp-1Ch] BYREF

  for ( result = WaitForSingleObject(hHandle, 0xAu); result == 258; result = WaitForSingleObject(hHandle, 0xAu) )
    PeekMessageW(&Msg, 0, 0, 0, 1u);
  return result;
}

//----- (0040D583) --------------------------------------------------------
int sub_40D583()
{
  int result; // eax
  wchar_t *v1; // eax
  const WCHAR *v2; // [esp-8h] [ebp-1028h]
  wchar_t String[2048]; // [esp+0h] [ebp-1020h] BYREF
  struct _SHFILEOPSTRUCTW FileOp; // [esp+1000h] [ebp-20h] BYREF

  result = sub_419740(String, 0x800u);
  if ( !byte_440CFD )
  {
    v2 = off_42F0C0;
    v1 = sub_40A0CE(String);
    result = sub_4119C7(v1, v2, 6u);
    if ( !result )
    {
      sub_41972D(L"..");
      String[wcslen(String) + 1] = 0;
      memset(&FileOp, 0, sizeof(FileOp));
      FileOp.fFlags = 20;
      FileOp.pFrom = String;
      FileOp.wFunc = 3;
      return SHFileOperationW(&FileOp);
    }
  }
  return result;
}
// 440CFD: using guessed type char byte_440CFD;

//----- (0040D61A) --------------------------------------------------------
wchar_t *__usercall sub_40D61A@<eax>(WCHAR **a1@<edi>)
{
  wchar_t *v1; // esi
  int v2; // ebx
  size_t v3; // eax
  wchar_t *v4; // eax
  WCHAR *v5; // eax
  wchar_t String[4097]; // [esp+8h] [ebp-2004h] BYREF
  int var1; // [esp+200Bh] [ebp-1h] BYREF

  v1 = (wchar_t *)malloc(0x20000u);
  if ( !v1 )
    sub_4062F7(&dword_432A6C);
  *v1 = 0;
  v2 = 0;
  while ( 1 )
  {
    v5 = sub_40D46E(0, String, *a1, 0, &var1, 4096);
    *a1 = v5;
    if ( !v5 )
      break;
    if ( *v1 || String[0] != 123 )
    {
      if ( String[0] == 125 || v2 + wcslen(String) > 0xFFFB )
        return v1;
      wcscat(v1, String);
      v3 = wcslen(v1);
      v2 = v3;
      if ( v3 )
      {
        v4 = &v1[v3 - 1];
        do
        {
          if ( *v4 != 32 )
            break;
          --v2;
          --v4;
        }
        while ( v2 );
      }
      if ( !(_BYTE)var1 )
        wcscpy(&v1[v2], L"\r\n");
    }
  }
  return v1;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0040D6EA) --------------------------------------------------------
LRESULT __usercall sub_40D6EA@<eax>(HWND a1@<esi>)
{
  LRESULT result; // eax

  byte_440CE9 = 1;
  dword_440CEC = 0;
  byte_440CE8 = 1;
  ShowWindow(a1, 1);
  result = sub_406013(a1, 2, 0);
  if ( !dword_440D0C && !byte_440CFC || !dword_440CF0 )
    return SendMessageW(a1, 0x111u, 1u, 0);
  return result;
}
// 440CE8: using guessed type char byte_440CE8;
// 440CE9: using guessed type char byte_440CE9;
// 440CEC: using guessed type int dword_440CEC;
// 440CF0: using guessed type int dword_440CF0;
// 440CFC: using guessed type char byte_440CFC;
// 440D0C: using guessed type int dword_440D0C;

//----- (0040D73C) --------------------------------------------------------
wchar_t *__userpurge sub_40D73C@<eax>(wchar_t *a1@<esi>, wchar_t *Source)
{
  wchar_t *result; // eax
  int v3; // ecx
  wchar_t v4; // dx

  result = wcscpy(a1, Source);
  v3 = 0;
  if ( *a1 )
  {
    result = a1;
    do
    {
      v4 = *result;
      if ( *result == 58 || v4 == 92 || v4 == 47 )
        *result = 37;
      result = &a1[++v3];
    }
    while ( *result );
  }
  return result;
}

//----- (0040D779) --------------------------------------------------------
void __stdcall sub_40D779(BYTE *lpData)
{
  size_t v1; // eax
  WCHAR ValueName[2048]; // [esp+4h] [ebp-1008h] BYREF
  DWORD dwDisposition; // [esp+1004h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+1008h] [ebp-4h] BYREF

  if ( byte_440D30 && String1 )
  {
    sub_40D73C(ValueName, &String1);
    if ( !RegCreateKeyExW(HKEY_CURRENT_USER, L"Software\\WinRAR SFX", 0, 0, 0, 0x20006u, 0, &phkResult, &dwDisposition) )
    {
      v1 = wcslen((const wchar_t *)lpData);
      RegSetValueExW(phkResult, ValueName, 0, 1u, lpData, 2 * v1 + 2);
      RegCloseKey(phkResult);
    }
  }
}
// 440D30: using guessed type char byte_440D30;

//----- (0040D803) --------------------------------------------------------
void __stdcall sub_40D803(wchar_t *Destination, int a2)
{
  DWORD v2; // eax
  WCHAR ValueName[2048]; // [esp+0h] [ebp-200Ch] BYREF
  wchar_t Data[2048]; // [esp+1000h] [ebp-100Ch] BYREF
  DWORD Type; // [esp+2000h] [ebp-Ch] BYREF
  HKEY phkResult; // [esp+2004h] [ebp-8h] BYREF
  DWORD cbData; // [esp+2008h] [ebp-4h] BYREF

  if ( byte_440D30 )
  {
    sub_40D73C(ValueName, Destination);
    if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\WinRAR SFX", 0, 1u, &phkResult) )
    {
      cbData = 4096;
      if ( !RegQueryValueExW(phkResult, ValueName, 0, &Type, (LPBYTE)Data, &cbData) )
      {
        cbData >>= 1;
        v2 = 2047;
        if ( cbData < 0x7FF )
          v2 = cbData;
        Data[v2] = 0;
        sub_41078F(Destination, Data, a2);
      }
      RegCloseKey(phkResult);
    }
  }
}
// 440D30: using guessed type char byte_440D30;
// 40D803: using guessed type wchar_t Data[2048];

//----- (0040D8AE) --------------------------------------------------------
HWND __stdcall sub_40D8AE(HWND hWnd)
{
  HWND result; // eax
  HWND v2; // edi
  void *v3; // esi
  int v4; // eax
  HANDLE v5; // eax
  int v6; // [esp-10h] [ebp-102Ch]
  WCHAR ClassName[2048]; // [esp+0h] [ebp-101Ch] BYREF
  char pv[4]; // [esp+1000h] [ebp-1Ch] BYREF
  int v9; // [esp+1004h] [ebp-18h]
  int v10; // [esp+1008h] [ebp-14h]
  HWND i; // [esp+1018h] [ebp-4h]
  HWND hWnda; // [esp+1024h] [ebp+8h]

  result = (HWND)sub_40CF9E();
  if ( (_BYTE)result )
  {
    result = GetWindow(hWnd, 5u);
    hWnda = 0;
    v2 = result;
    for ( i = result; result; hWnda = (HWND)((char *)hWnda + 1) )
    {
      if ( (int)hWnda >= 512 )
        break;
      GetClassNameW(v2, ClassName, 2048);
      if ( !sub_4119A6(ClassName, L"STATIC") && (GetWindowLongW(v2, -16) & 0x1F) == 14 )
      {
        v3 = (void *)SendMessageW(v2, 0x173u, 0, 0);
        if ( v3 )
        {
          GetObjectW(v3, 24, pv);
          v6 = sub_40CF5B(v10);
          v4 = sub_40CF18(v9);
          v5 = sub_4197B0(v3, v4, v6);
          SendMessageW(v2, 0x172u, 0, (LPARAM)v5);
          if ( v3 != (void *)dword_438CD0 )
            DeleteObject(v3);
        }
      }
      result = GetWindow(v2, 2u);
      v2 = result;
      if ( result == i )
        break;
    }
  }
  return result;
}
// 40D8AE: using guessed type char pv[4];

//----- (0040D9A5) --------------------------------------------------------
unsigned __int16 *__stdcall sub_40D9A5(unsigned __int16 *a1, _WORD *a2)
{
  unsigned __int16 *v2; // esi
  unsigned __int16 v3; // ax
  _WORD *v4; // edi
  unsigned __int16 v5; // ax
  char v6; // bl
  unsigned __int16 *result; // eax
  char v9; // [esp+1Bh] [ebp+Bh]

  v2 = a1;
  if ( !a1 || (v3 = *a1) == 0 )
  {
    result = 0;
    *a2 = 0;
    return result;
  }
  v4 = a2;
  v9 = 0;
  while ( v3 == 34 )
  {
    if ( v2[1] != 34 || !v9 && v2 == a1 && ((v5 = v2[2], v5 == 44) || !v5) )
    {
      v6 = v9;
      if ( v9 )
        v9 = 0;
      else
        v9 = wcschr(v2 + 1, 0x22u) != 0;
      if ( v6 != v9 )
        goto LABEL_19;
      break;
    }
    ++v2;
    *v4 = 34;
LABEL_18:
    ++v4;
LABEL_19:
    v3 = *++v2;
    if ( !*v2 )
    {
      *v4 = 0;
      return v2;
    }
  }
  if ( *v2 != 44 || v9 )
  {
    *v4 = *v2;
    goto LABEL_18;
  }
  *v4 = 0;
  do
    ++v2;
  while ( sub_410772(*v2) );
  return v2;
}

//----- (0040DA6B) --------------------------------------------------------
wchar_t *__stdcall sub_40DA6B(wchar_t *String, int a2)
{
  size_t v2; // edi
  wchar_t *v3; // esi

  if ( wcschr(String, 0x20u) && (*String != 34 || *sub_409D8B(String) != 34) )
  {
    v2 = wcslen(String);
    v3 = (wchar_t *)operator new[](2 * (v2 + 3));
    wcscpy(v3 + 1, String);
    v3[v2 + 1] = 34;
    *v3 = 34;
    v3[v2 + 2] = 0;
    sub_41078F(String, v3, a2);
    operator delete[](v3);
  }
  return String;
}

//----- (0040DAEC) --------------------------------------------------------
BOOL __stdcall sub_40DAEC(int a1, int a2, int a3, char a4)
{
  WCHAR *v4; // eax
  WCHAR String[2560]; // [esp+0h] [ebp-1400h] BYREF

  if ( a4 )
    v4 = sub_40C05C(0x66u);
  else
    v4 = sub_40C05C(0x65u);
  swprintf(String, 0xA00u, v4, a1);
  SetDlgItemTextW(hWndParent, 101, String);
  sub_40CD98();
  return byte_440CEA == 0;
}
// 440CEA: using guessed type char byte_440CEA;

//----- (0040DB4B) --------------------------------------------------------
INT_PTR __stdcall sub_40DB4B(HWND hDlg, HANDLE hFindFile, int a3, wchar_t *a4)
{
  INT_PTR v5; // esi
  HICON v6; // eax
  HWND DlgItem; // eax
  WCHAR *v8; // eax
  WCHAR *v9; // eax
  WCHAR *v10; // eax
  WCHAR *v11; // eax
  int v12; // [esp-8h] [ebp-19F8h]
  WCHAR String[2048]; // [esp+8h] [ebp-19E8h] BYREF
  SHFILEINFOW psfi; // [esp+1008h] [ebp-9E8h] BYREF
  WCHAR Buffer[512]; // [esp+12BCh] [ebp-734h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+16BCh] [ebp-334h] BYREF
  WCHAR NumberStr[50]; // [esp+190Ch] [ebp-E4h] BYREF
  WCHAR TimeStr[50]; // [esp+1970h] [ebp-80h] BYREF
  WCHAR DateStr[50]; // [esp+19D4h] [ebp-1Ch] BYREF
  FILETIME FileTime; // [esp+1A38h] [ebp+48h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+1A40h] [ebp+50h] BYREF
  struct _FILETIME LocalFileTime; // [esp+1A50h] [ebp+60h] BYREF
  HANDLE hFindFilea; // [esp+1A64h] [ebp+74h]

  if ( sub_406056(hDlg, (int)hFindFile, a3, (int)a4, &off_42A888, 0, 0) )
    return 1;
  if ( hFindFile == (HANDLE)272 )
  {
    DlgItem = GetDlgItem(hDlg, 108);
    SetFocus(DlgItem);
    sub_41078F(String, a4, 2048);
    sub_409FD2((__int16 *)String, (int)String, 2048);
    SetDlgItemTextW(hDlg, 101, String);
    SHGetFileInfoW(String, 0, &psfi, 0x2B4u, 0x100u);
    SendDlgItemMessageW(hDlg, 102, 0x170u, (WPARAM)psfi.hIcon, 0);
    hFindFilea = FindFirstFileW(String, &FindFileData);
    if ( hFindFilea != (HANDLE)-1 )
    {
      FileTimeToLocalFileTime(&FindFileData.ftLastWriteTime, &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      GetTimeFormatW(0x400u, 2u, &SystemTime, 0, TimeStr, 50);
      GetDateFormatW(0x400u, 0, &SystemTime, 0, DateStr, 50);
      v8 = sub_40C05C(0x99u);
      swprintf(Buffer, 0x200u, L"%s %s %s", v8, DateStr, TimeStr);
      SetDlgItemTextW(hDlg, 106, Buffer);
      FindClose(hFindFilea);
      if ( (FindFileData.dwFileAttributes & 0x10) == 0 )
      {
        sub_40CDD7(FindFileData.nFileSizeLow + ((unsigned __int64)FindFileData.nFileSizeHigh << 32), NumberStr, 50);
        v9 = sub_40C05C(0x98u);
        swprintf(Buffer, 0x200u, L"%s %s", NumberStr, v9);
        SetDlgItemTextW(hDlg, 104, Buffer);
      }
      SendDlgItemMessageW(hDlg, 103, 0x170u, (WPARAM)psfi.hIcon, 0);
      sub_410EF6((int *)dword_440CD8, &FileTime);
      FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
      FileTimeToSystemTime(&LocalFileTime, &SystemTime);
      GetTimeFormatW(0x400u, 2u, &SystemTime, 0, TimeStr, 50);
      GetDateFormatW(0x400u, 0, &SystemTime, 0, DateStr, 50);
      v10 = sub_40C05C(0x99u);
      swprintf(Buffer, 0x200u, L"%s %s %s", v10, DateStr, TimeStr);
      SetDlgItemTextW(hDlg, 107, Buffer);
      if ( (FindFileData.dwFileAttributes & 0x10) == 0 || *(_QWORD *)&qword_440CE0 )
      {
        sub_40CDD7(*(__int64 *)&qword_440CE0, NumberStr, 50);
        v11 = sub_40C05C(0x98u);
        swprintf(Buffer, 0x200u, L"%s %s", NumberStr, v11);
        SetDlgItemTextW(hDlg, 105, Buffer);
      }
    }
    return 0;
  }
  if ( hFindFile != (HANDLE)273 )
    return 0;
  v5 = 2;
  switch ( (unsigned __int16)a3 )
  {
    case 2u:
      goto LABEL_12;
    case 0x6Cu:
      v5 = 0;
      goto LABEL_14;
    case 0x6Du:
      v5 = 1;
      goto LABEL_14;
    case 0x6Eu:
      v12 = 4;
      goto LABEL_13;
  }
  if ( (unsigned __int16)a3 != 111 )
  {
    if ( (unsigned __int16)a3 == 112 )
    {
      v12 = 3;
      goto LABEL_13;
    }
    if ( (unsigned __int16)a3 == 113 )
    {
LABEL_12:
      v12 = 6;
LABEL_13:
      v5 = v12;
      goto LABEL_14;
    }
    return 0;
  }
LABEL_14:
  v6 = (HICON)SendDlgItemMessageW(hDlg, 102, 0x171u, 0, 0);
  if ( v6 )
    DestroyIcon(v6);
  EndDialog(hDlg, v5);
  return 1;
}
// 440CD8: using guessed type int dword_440CD8;

//----- (0040DE9F) --------------------------------------------------------
char __stdcall sub_40DE9F(int a1, LPCCH lpMultiByteStr, wchar_t *Source, _BYTE *a4)
{
  _BYTE *v4; // ebx
  const void *v5; // esi
  void *v6; // edi
  HWND v7; // esi
  wchar_t dwInitParam[2048]; // [esp+Ch] [ebp-1000h] BYREF

  if ( byte_442E32 )
  {
    v4 = a4;
    v5 = &unk_442D32;
    v6 = a4;
LABEL_12:
    qmemcpy(v6, v5, 0x102u);
    return v4[256];
  }
  v7 = hWndParent;
  if ( a1 == 2 && !IsWindowVisible(hWndParent) )
    v7 = 0;
  sub_40A078(lpMultiByteStr, Source, dwInitParam, 0x800u);
  if ( byte_44C3D8 || DialogBoxParamW(dword_432A64, &TemplateName, v7, (DLGPROC)DialogFunc, (LPARAM)dwInitParam) )
  {
    v4 = a4;
    qmemcpy(a4, byte_44C2D8, 0x102u);
  }
  else
  {
    v4 = a4;
    sub_40CCBC(a4, (wchar_t *)&String);
    byte_440CEA = 1;
  }
  if ( v4[256] )
  {
    v5 = v4;
    v6 = &unk_442D32;
    goto LABEL_12;
  }
  return v4[256];
}
// 440CEA: using guessed type char byte_440CEA;
// 442E32: using guessed type char byte_442E32;
// 44C2D8: using guessed type _BYTE byte_44C2D8[256];
// 44C3D8: using guessed type char byte_44C3D8;
// 40DE9F: using guessed type wchar_t dwInitParam[2048];

//----- (0040DF70) --------------------------------------------------------
void sub_40DF70(int a1, wchar_t *Format, ...)
{
  DWORD LastError; // edi
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  if ( !byte_440CEA && *Format )
  {
    LastError = GetLastError();
    _vswprintf_c_l(&Buffer, 0x1000u, Format, 0, va);
    sub_40D0D1(L"%s", &Buffer);
    if ( LastError )
      SetLastError(LastError);
  }
}
// 440CEA: using guessed type char byte_440CEA;

//----- (0040DFC4) --------------------------------------------------------
void __stdcall sub_40DFC4(int a1, wchar_t *Source)
{
  void *v2; // esp
  int v3; // [esp-Ch] [ebp-5C1Ch] BYREF
  _DWORD v4[5889]; // [esp+0h] [ebp-5C10h] BYREF
  int v5; // [esp+5C0Ch] [ebp-4h]

  v2 = alloca(23552);
  v4[5888] = &v3;
  wcscpy(&word_44A0EA, asc_42A8A8);
  sub_4108FF(dword_44C10C, (wchar_t *)::Source);
  wcscpy(&word_44B10A, Source);
  sub_405321(dword_442E38, Source);
  v5 = 0;
  dword_4490CC = 4;
  dword_4490C8 = 4;
  dword_4490C4 = 4;
  byte_447F87 = byte_440CDD;
  byte_447FC0 = 1;
  byte_447F88 = byte_440CDC;
  sub_406F15(v4, dword_442E38);
  LOBYTE(v5) = 1;
  sub_4080F3((int)v4);
  LOBYTE(v5) = 0;
  sub_406E0C((int)v4);
}
// 440CDC: using guessed type char byte_440CDC;
// 440CDD: using guessed type char byte_440CDD;
// 442E38: using guessed type _DWORD dword_442E38[5203];
// 447F87: using guessed type char byte_447F87;
// 447F88: using guessed type char byte_447F88;
// 447FC0: using guessed type char byte_447FC0;
// 4490C4: using guessed type int dword_4490C4;
// 4490C8: using guessed type int dword_4490C8;
// 4490CC: using guessed type int dword_4490CC;
// 44C10C: using guessed type _DWORD dword_44C10C[115];

//----- (0040E0BC) --------------------------------------------------------
BOOL __stdcall sub_40E0BC(LPARAM a1, LPARAM a2)
{
  LPARAM dwInitParam[2]; // [esp+0h] [ebp-8h] BYREF

  dwInitParam[0] = a1;
  dwInitParam[1] = a2;
  return DialogBoxParamW(hInstance, L"ASKNEXTVOL", hWndParent, (DLGPROC)sub_40D263, (LPARAM)dwInitParam) == 1;
}

//----- (0040E0F7) --------------------------------------------------------
LRESULT __stdcall sub_40E0F7(char a1, wchar_t *String)
{
  WCHAR *v2; // eax
  wchar_t *v4; // [esp-4h] [ebp-1408h]
  wchar_t Buffer[2560]; // [esp+4h] [ebp-1400h] BYREF

  v4 = sub_40A0CE(String);
  v2 = sub_40C05C(a1 == 84 ? 523 : 141);
  swprintf(Buffer, 0xA00u, v2, v4);
  return sub_40CFBD(0, (LPARAM)Buffer);
}

//----- (0040E152) --------------------------------------------------------
void __thiscall sub_40E152(const WCHAR *this, HWND hWnd, char a3)
{
  WCHAR v4; // cx
  int v5; // eax
  const WCHAR *v6; // ecx
  const WCHAR *v7; // eax
  wchar_t *v8; // eax
  bool v9; // bl
  wchar_t v10[2048]; // [esp+8h] [ebp-2048h] BYREF
  wchar_t Destination[2048]; // [esp+1008h] [ebp-1048h] BYREF
  SHELLEXECUTEINFOW pExecInfo; // [esp+2008h] [ebp-48h] BYREF
  DWORD ExitCode; // [esp+2044h] [ebp-Ch] BYREF
  PCNZWCH lpString1; // [esp+2048h] [ebp-8h]
  char v15; // [esp+204Fh] [ebp-1h]

  if ( *this && wcslen(this) < 0x7F6 )
  {
    memset(&pExecInfo, 0, sizeof(pExecInfo));
    v4 = *this;
    pExecInfo.cbSize = 60;
    pExecInfo.fMask = 448;
    if ( v4 == 34 )
      pExecInfo.lpFile = this + 1;
    else
      pExecInfo.lpFile = this;
    v5 = 0;
    if ( v4 )
    {
      v6 = this;
      while ( 1 )
      {
        if ( *v6 == 34 )
        {
          while ( this[++v5] )
          {
            if ( this[v5] == 34 )
            {
              this[v5] = 32;
              break;
            }
          }
        }
        if ( this[v5] == 32 || this[v5 + 1] == 47 )
          break;
        v6 = &this[++v5];
        if ( !*v6 )
          goto LABEL_21;
      }
      v7 = &this[v5];
      if ( *v7 == 32 )
        *v7 = 0;
      pExecInfo.lpParameters = v7 + 1;
    }
LABEL_21:
    if ( !pExecInfo.lpParameters && !a3 && word_441D32[0] )
      pExecInfo.lpParameters = word_441D32;
    pExecInfo.nShow = 1;
    v8 = sub_40A25D((wchar_t *)pExecInfo.lpFile);
    lpString1 = v8;
    if ( v8 && !sub_4119A6(v8, L".inf") )
      pExecInfo.lpVerb = L"Install";
    v9 = sub_409026((WCHAR *)pExecInfo.lpFile);
    if ( v9 )
    {
      sub_40A72F((WCHAR *)pExecInfo.lpFile, v10, 2048);
      pExecInfo.lpFile = v10;
    }
    if ( !a3 || v9 || (wcscpy(Destination, pExecInfo.lpFile), wcscat(Destination, L".exe"), sub_409026(Destination)) )
    {
      if ( ShellExecuteExW(&pExecInfo) )
      {
        v15 = 0;
        if ( byte_440D28 || a3 || byte_440D11 )
        {
          if ( hWnd && IsWindowVisible(hWnd) )
          {
            ShowWindow(hWnd, 0);
            v15 = 1;
          }
          WaitForInputIdle(pExecInfo.hProcess, 0x7D0u);
          sub_40D544(pExecInfo.hProcess);
          if ( byte_440D11 && GetExitCodeProcess(pExecInfo.hProcess, &ExitCode) && ExitCode + 1000 > dword_440D14 )
            dword_440D14 = ExitCode + 1000;
        }
        CloseHandle(pExecInfo.hProcess);
        if ( !lpString1 || sub_4119A6(lpString1, L".exe") )
        {
          if ( !byte_440D28 || a3 )
            dwMilliseconds = a3 == 0 ? 1000 : 200;
          else
            dwMilliseconds = 7000;
        }
        if ( v15 )
        {
          if ( a3 )
            ShowWindow(hWnd, 1);
        }
      }
    }
  }
}
// 42A8B8: using guessed type wchar_t aInstall[8];
// 440D11: using guessed type char byte_440D11;
// 440D14: using guessed type int dword_440D14;
// 440D28: using guessed type char byte_440D28;
// 441D32: using guessed type wchar_t word_441D32[2048];

//----- (0040E3FA) --------------------------------------------------------
INT_PTR __stdcall sub_40E3FA(LPARAM dwInitParam, int a2, __int64 a3, int a4, int a5)
{
  INT_PTR v6; // edi

  *(_QWORD *)&qword_440CE0 = a3;
  dword_440CD8 = a4;
  if ( byte_440CDE )
    return 0;
  if ( byte_440CDF )
    return 1;
  do
    v6 = DialogBoxParamW(dword_432A64, &off_42A888, hWndParent, (DLGPROC)sub_40DB4B, dwInitParam);
  while ( v6 == 4 && !DialogBoxParamW(hInstance, &off_42A7E0, hWnd, (DLGPROC)sub_40D113, dwInitParam) );
  return v6;
}
// 440CD8: using guessed type int dword_440CD8;
// 440CDE: using guessed type char byte_440CDE;
// 440CDF: using guessed type char byte_440CDF;

//----- (0040E48A) --------------------------------------------------------
bool __stdcall sub_40E48A(int a1, int a2, _DWORD *a3, int *a4)
{
  void *v4; // esp
  size_t v5; // esi
  int v6; // edi
  char *v7; // eax
  int v9; // [esp-Ch] [ebp-B2ACh] BYREF
  _DWORD v10[11424]; // [esp+0h] [ebp-B2A0h] BYREF
  void *Block; // [esp+B280h] [ebp-20h] BYREF
  int v12; // [esp+B284h] [ebp-1Ch]
  int v13; // [esp+B288h] [ebp-18h]
  int v14; // [esp+B28Ch] [ebp-14h]
  int *v15; // [esp+B290h] [ebp-10h]
  int v16; // [esp+B29Ch] [ebp-4h]

  v4 = alloca(45712);
  v15 = &v9;
  v16 = 0;
  sub_40185E((int)v10, 0);
  LOBYTE(v16) = 1;
  sub_401A56(v10, a2);
  Block = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  LOBYTE(v16) = 2;
  if ( sub_4017A4((int)v10, (int)&Block) )
  {
    v5 = 2 * v12;
    v6 = v12;
    v7 = (char *)malloc(2 * v12 + 2);
    *a3 = v7;
    if ( v7 )
    {
      *(_WORD *)&v7[v5] = 0;
      memcpy(v7, Block, v5);
    }
    else
    {
      v6 = 0;
    }
    *a4 = v6;
  }
  if ( Block )
    free(Block);
  LOBYTE(v16) = 0;
  return sub_401235((int)v10);
}
// 40E48A: using guessed type _DWORD var_B2A0[11424];

//----- (0040E582) --------------------------------------------------------
WCHAR *__stdcall sub_40E582(HWND hWnd, WCHAR *a2, int a3)
{
  WCHAR *result; // eax
  unsigned __int16 *p_String; // eax
  WCHAR *v5; // edi
  size_t v6; // esi
  size_t v7; // eax
  wchar_t *v8; // eax
  WCHAR *v9; // edi
  wchar_t v10; // ax
  DWORD v11; // eax
  size_t v12; // edi
  wchar_t *v13; // eax
  HWND DlgItem; // edi
  int v15; // eax
  int v16; // ecx
  WCHAR *v17; // eax
  int v18; // esi
  int v19; // eax
  wchar_t *v20; // eax
  wchar_t *p_Destination; // edi
  wchar_t v22; // si
  wchar_t *v23; // eax
  wchar_t *v24; // eax
  wchar_t *v25; // eax
  wchar_t v26[4096]; // [esp+0h] [ebp-1BC90h] BYREF
  wchar_t v27; // [esp+2000h] [ebp-19C90h] BYREF
  wchar_t v28[4095]; // [esp+2002h] [ebp-19C8Eh] BYREF
  wchar_t v29[4096]; // [esp+4000h] [ebp-17C90h] BYREF
  __int16 v30; // [esp+6000h] [ebp-15C90h] BYREF
  wchar_t v31; // [esp+8000h] [ebp-13C90h] BYREF
  WCHAR v32[4096]; // [esp+A000h] [ebp-11C90h] BYREF
  wchar_t v33[2048]; // [esp+C000h] [ebp-FC90h] BYREF
  WCHAR String1[4096]; // [esp+D000h] [ebp-EC90h] BYREF
  wchar_t v35[2048]; // [esp+F000h] [ebp-CC90h] BYREF
  wchar_t v36[2048]; // [esp+10000h] [ebp-BC90h] BYREF
  wchar_t dwItem1[2048]; // [esp+11000h] [ebp-AC90h] BYREF
  wchar_t v38[2048]; // [esp+12000h] [ebp-9C90h] BYREF
  WCHAR Buffer[2048]; // [esp+13000h] [ebp-8C90h] BYREF
  HANDLE v40[1026]; // [esp+14000h] [ebp-7C90h] BYREF
  wchar_t Destination; // [esp+15008h] [ebp-6C88h] BYREF
  wchar_t Str[2047]; // [esp+1500Ah] [ebp-6C86h] BYREF
  WCHAR FileName[2054]; // [esp+16008h] [ebp-5C88h] BYREF
  char v44; // [esp+17014h] [ebp-4C7Ch]
  wchar_t v45; // [esp+17050h] [ebp-4C40h] BYREF
  wchar_t v46[1023]; // [esp+17052h] [ebp-4C3Eh] BYREF
  WCHAR String; // [esp+17850h] [ebp-4440h] BYREF
  wchar_t v48[4095]; // [esp+17852h] [ebp-443Eh] BYREF
  wchar_t pszPath[2048]; // [esp+19850h] [ebp-2440h] BYREF
  WCHAR Caption[512]; // [esp+1A850h] [ebp-1440h] BYREF
  wchar_t NewFileName[2048]; // [esp+1AC50h] [ebp-1040h] BYREF
  struct _SHFILEOPSTRUCTW FileOp; // [esp+1BC50h] [ebp-40h] BYREF
  DWORD Type; // [esp+1BC70h] [ebp-20h] BYREF
  HKEY phkResult; // [esp+1BC74h] [ebp-1Ch] BYREF
  wchar_t *Source; // [esp+1BC78h] [ebp-18h]
  bool v56; // [esp+1BC7Eh] [ebp-12h]
  char v57; // [esp+1BC7Fh] [ebp-11h] BYREF
  DWORD cbData; // [esp+1BC80h] [ebp-10h] BYREF
  int v59; // [esp+1BC8Ch] [ebp-4h]

  result = (WCHAR *)&loc_429301;
  if ( a2 )
  {
    result = sub_40D46E(&v57, String1, a2, &String, (_BYTE *)&a2 + 3, 4096);
    a2 = result;
    if ( result )
    {
      while ( 1 )
      {
        p_String = &String;
        cbData = (DWORD)v26;
        Source = (wchar_t *)6;
        do
        {
          p_String = sub_40D9A5(p_String, (_WORD *)cbData);
          cbData += 0x2000;
          Source = (wchar_t *)((char *)Source - 1);
        }
        while ( Source );
        cbData = 0;
        while ( sub_4119A6(String1, (&lpString2)[cbData]) )
        {
          if ( ++cbData >= 0xE )
            goto LABEL_156;
        }
        switch ( cbData )
        {
          case 0u:
            if ( a3 != 2 )
              goto LABEL_156;
            sub_419740(Buffer, 0x800u);
            sub_409E1B(Buffer, &String, v33, 2048);
            sub_4091A0(v40);
            v59 = 0;
            sub_4091C9((wchar_t *)v40, v33);
            sub_4065D5(FileName);
            if ( !sub_40937B((WCHAR *)v40, FileName, 0) )
              goto LABEL_25;
            do
            {
              SetFileAttributesW(FileName, 0);
              if ( v44 )
              {
                sub_40A4F3(Buffer, NewFileName, 0x800u);
                sub_409DEB(NewFileName, 0x800u);
                Source = (wchar_t *)wcslen(Buffer);
                if ( ((unsigned int)Source < 4 || (unsigned int)Source <= wcslen(NewFileName)) && sub_409DA5(&String) )
                  break;
                FileName[wcslen(FileName) + 1] = 0;
                memset(&FileOp, 0, sizeof(FileOp));
                FileOp.fFlags = 20;
                FileOp.pFrom = FileName;
                FileOp.wFunc = 3;
                SHFileOperationW(&FileOp);
              }
              if ( GetFileAttributesW(FileName) != -1 && !DeleteFileW(FileName) )
              {
                cbData = 0;
                swprintf(NewFileName, 0x800u, L"%s.%d.tmp", FileName, 0);
                while ( GetFileAttributesW(NewFileName) != -1 )
                  swprintf(NewFileName, 0x800u, L"%s.%d.tmp", FileName, ++cbData);
                if ( MoveFileW(FileName, NewFileName) )
                  MoveFileExW(NewFileName, 0, 4u);
              }
            }
            while ( sub_40937B((WCHAR *)v40, FileName, 0) );
LABEL_25:
            v59 = -1;
            sub_4091B6(v40);
            goto LABEL_156;
          case 1u:
            if ( !a3 )
            {
              v56 = ::Destination == 0;
              if ( ::Destination )
                wcscat(::Destination, L"<br>");
              if ( v57 )
                v5 = &String;
              else
                v5 = sub_40D61A(&a2);
              if ( v56 )
                v6 = 0;
              else
                v6 = wcslen(::Destination);
              v7 = wcslen(v5);
              v8 = (wchar_t *)realloc(::Destination, 2 * (v6 + v7) + 10);
              ::Destination = v8;
              if ( v56 )
                *v8 = 0;
              wcscat(v8, v5);
              if ( !v57 )
                free(v5);
            }
            goto LABEL_156;
          case 2u:
            if ( !a3 )
              SetWindowTextW(hWnd, &String);
            goto LABEL_156;
          case 3u:
            if ( a3 || word_440D32[0] )
              goto LABEL_156;
            v9 = &String;
            Source = &String;
            NewFileName[0] = 0;
            if ( String == 34 )
            {
              v9 = v48;
              Source = v48;
            }
            if ( wcslen(v9) >= 0x800 )
              goto LABEL_156;
            v10 = *v9;
            if ( *v9 == 46 && v9[1] == 92 )
            {
              if ( !v9[2] )
                goto LABEL_156;
              wcscpy(NewFileName, v9 + 2);
            }
            else if ( v10 == 92 || v10 && v9[1] == 58 )
            {
              wcscpy(NewFileName, v9);
            }
            else
            {
              if ( !RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,
                      L"Software\\Microsoft\\Windows\\CurrentVersion",
                      0,
                      1u,
                      &phkResult) )
              {
                cbData = 4096;
                RegQueryValueExW(phkResult, L"ProgramFilesDir", 0, &Type, (LPBYTE)NewFileName, &cbData);
                RegCloseKey(phkResult);
                cbData >>= 1;
                v11 = 2047;
                if ( cbData < 0x7FF )
                  v11 = cbData;
                NewFileName[v11] = 0;
              }
              if ( NewFileName[0] && Caption[wcslen(NewFileName) + 511] != 92 )
                wcscat(NewFileName, L"\\");
              v12 = wcslen(v9);
              if ( wcslen(NewFileName) + v12 < 0x7FF )
                wcscat(NewFileName, Source);
            }
            v13 = wcsrchr(NewFileName, 0x22u);
            if ( v13 && !v13[1] )
              *v13 = 0;
            wcscpy(&::String1, NewFileName);
            sub_40D803(NewFileName, 2048);
            DlgItem = GetDlgItem(hWnd, 102);
            SetWindowTextW(DlgItem, NewFileName);
            SendMessageW(DlgItem, 0x143u, 0, (LPARAM)&::String1);
            if ( wcscmp(&::String1, NewFileName) )
              SendMessageW(DlgItem, 0x143u, 0, (LPARAM)NewFileName);
            goto LABEL_156;
          case 4u:
            if ( dword_440D2C != 1 )
            {
              if ( sub_410760(String) )
                dword_440D2C = String - 48;
              else
                dword_440D2C = 2;
            }
            goto LABEL_156;
          case 5u:
            if ( !String )
              goto LABEL_79;
            if ( String == 48 )
            {
              byte_440CDF = 0;
LABEL_78:
              byte_440CDE = 0;
              goto LABEL_156;
            }
            if ( String != 49 )
            {
              if ( String != 50 )
                goto LABEL_156;
              byte_440CDF = 1;
              goto LABEL_78;
            }
LABEL_79:
            byte_440CDF = 0;
            byte_440CDE = 1;
LABEL_156:
            result = sub_40D46E(&v57, String1, a2, &String, (_BYTE *)&a2 + 3, 4096);
            a2 = result;
            if ( !result )
              return result;
            break;
          case 6u:
            if ( a3 == 4 && wcscmp(&String, L"<>") )
              sub_40E152(&String, hWnd, 0);
            goto LABEL_88;
          case 7u:
            if ( a3 != 1 )
              goto LABEL_107;
            GetTempPathW(0x800u, Buffer);
            sub_409DEB(Buffer, 0x800u);
            cbData = 0;
            swprintf(NewFileName, 0x800u, L"%s%s%d", Buffer, off_42F0C0, 0);
            while ( GetFileAttributesW(NewFileName) != -1 )
              swprintf(NewFileName, 0x800u, L"%s%s%d", Buffer, off_42F0C0, ++cbData);
            SetDlgItemTextW(hWnd, 102, NewFileName);
            if ( !String || byte_440CFE )
              goto LABEL_156;
            Caption[0] = 0;
            if ( wcschr(&String, 0x2Cu) )
              goto LABEL_103;
            v16 = 0;
            if ( !String )
              goto LABEL_103;
            v17 = &String;
            while ( *v17 != 64 )
            {
              v17 = &v48[v16++];
              if ( !*v17 )
                goto LABEL_103;
            }
            v18 = v16;
            wcscpy(Caption, &v48[v16]);
            v48[v18 - 1] = 0;
LABEL_103:
            if ( !Caption[0] )
            {
              wcscpy(&String, v26);
              wcscpy(Caption, &v27);
            }
            sub_40CECC((__int16 *)&String);
            v48[2047] = 0;
            if ( MessageBoxW(hWnd, &String, Caption, 0x24u) != 6 )
            {
              byte_440CFD = 1;
              byte_440CEA = 1;
              EndDialog(hWnd, 1);
LABEL_107:
              if ( a3 == 7 )
              {
                if ( !dword_440D2C )
                  dword_440D2C = 2;
                byte_440D28 = 1;
              }
            }
            goto LABEL_156;
          case 8u:
            if ( a3 == 3 )
            {
              if ( String )
                SetWindowTextW(hWnd, &String);
              Block = sub_40D61A(&a2);
            }
            byte_440CFF = 1;
            goto LABEL_156;
          case 9u:
            if ( a3 == 5 )
              sub_40E152(&String, hWnd, 1);
LABEL_88:
            byte_440D10 = 1;
            goto LABEL_156;
          case 0xAu:
            if ( a3 == 6 )
            {
              pszPath[0] = 0;
              v19 = toupper(v26[0]);
              if ( v19 == 80 )
              {
                sub_41078F(pszPath, word_43ECD8, 2048);
                Source = (wchar_t *)2;
              }
              else if ( v19 == 84 )
              {
                sub_41078F(pszPath, ::pszPath, 2048);
                Source = (wchar_t *)7;
              }
              else
              {
                sub_41078F(pszPath, word_43FCD8, 2048);
                Source = (wchar_t *)16;
              }
              v36[0] = 0;
              v45 = 0;
              wcscpy(&Destination, &v27);
              if ( Destination == 34 )
              {
                wcscpy(&Destination, v28);
                v20 = wcschr(Str, 0x22u);
                if ( v20 )
                {
                  *v20 = 0;
                  wcscpy(&v45, v20 + 1);
                }
              }
              else if ( !sub_409026(&Destination) )
              {
                cbData = 0;
                p_Destination = &Destination;
                if ( Destination )
                {
                  do
                  {
                    if ( *p_Destination == 32 || *p_Destination == 47 )
                    {
                      v22 = *p_Destination;
                      *p_Destination = 0;
                      if ( sub_409026(&Destination) )
                      {
                        cbData = (DWORD)p_Destination;
                        if ( v22 == 47 )
                        {
                          v45 = 47;
                          wcscpy(v46, p_Destination + 1);
                        }
                        else
                        {
                          do
                            ++p_Destination;
                          while ( *p_Destination == 32 );
                          wcscpy(&v45, p_Destination);
                        }
                        *(_WORD *)cbData = v22;
                      }
                      else
                      {
                        *p_Destination = v22;
                      }
                    }
                    ++p_Destination;
                  }
                  while ( *p_Destination );
                  if ( cbData )
                    *(_WORD *)cbData = 0;
                }
              }
              if ( v32[0] )
                sub_40A72F(v32, v36, 2048);
              sub_40A72F(&Destination, v35, 2048);
              if ( !pszPath[0] )
                sub_40CE92(pszPath, (int)Source);
              sub_409DEB(pszPath, 0x800u);
              if ( v29[0] )
              {
                sub_4107BC(pszPath, v29, 0x800u);
                sub_409DEB(pszPath, 0x800u);
              }
              wcscpy(dwItem1, pszPath);
              v23 = &v31;
              if ( !v31 )
                v23 = &v27;
              v24 = sub_40A0CE(v23);
              sub_4107BC(pszPath, v24, 0x800u);
              v25 = sub_40A25D(pszPath);
              if ( !v25 || sub_4119A6(v25, L".lnk") )
                sub_4107BC(pszPath, (wchar_t *)L".lnk", 0x800u);
              sub_4090CB(pszPath, 1);
              wcscpy(v38, v35);
              sub_40A2E6(v38);
              sub_419655(
                0,
                (int)v35,
                (int)pszPath,
                v38[0] != 0 ? (unsigned int)v38 : 0,
                v30 != 0 ? (unsigned int)&v30 : 0,
                v36[0] != 0 ? (unsigned int)v36 : 0,
                v45 != 0 ? (unsigned int)&v45 : 0);
              if ( dwItem1[0] )
                SHChangeNotify(4096, 5u, dwItem1, 0);
            }
            goto LABEL_156;
          case 0xBu:
            if ( a3 == 7 )
              byte_440D30 = 1;
            goto LABEL_156;
          case 0xCu:
            v15 = toupper(String);
            if ( v15 == 70 )
            {
              byte_440CDD = 1;
            }
            else if ( v15 == 85 )
            {
              byte_440CDC = 1;
            }
            else
            {
              byte_440CDD = 0;
              byte_440CDC = 0;
            }
            goto LABEL_156;
          case 0xDu:
            byte_440D11 = 1;
            goto LABEL_156;
          default:
            goto LABEL_156;
        }
      }
    }
  }
  return result;
}
// 43DCD8: using guessed type wchar_t pszPath[2048];
// 43ECD8: using guessed type wchar_t word_43ECD8[2048];
// 43FCD8: using guessed type wchar_t word_43FCD8[438];
// 440CDC: using guessed type char byte_440CDC;
// 440CDD: using guessed type char byte_440CDD;
// 440CDE: using guessed type char byte_440CDE;
// 440CDF: using guessed type char byte_440CDF;
// 440CEA: using guessed type char byte_440CEA;
// 440CFD: using guessed type char byte_440CFD;
// 440CFE: using guessed type char byte_440CFE;
// 440CFF: using guessed type char byte_440CFF;
// 440D10: using guessed type char byte_440D10;
// 440D11: using guessed type char byte_440D11;
// 440D28: using guessed type char byte_440D28;
// 440D2C: using guessed type int dword_440D2C;
// 440D30: using guessed type char byte_440D30;
// 440D32: using guessed type wchar_t word_440D32[2048];
// 40E582: using guessed type HANDLE var_7C90[1026];
// 40E582: using guessed type wchar_t NewFileName[2048];
// 40E582: using guessed type wchar_t var_19C8E[4095];
// 40E582: using guessed type wchar_t Str[2047];
// 40E582: using guessed type wchar_t var_4C3E[1023];
// 40E582: using guessed type WCHAR var_11C90[4096];
// 40E582: using guessed type wchar_t var_17C90[4096];

//----- (0040F1A6) --------------------------------------------------------
INT_PTR __stdcall sub_40F1A6(HWND hWnd, HWND a2, int a3, LPARAM a4)
{
  LPARAM SysColor; // eax
  HWND DlgItem; // [esp+14h] [ebp+Ch]

  if ( sub_406056(hWnd, (int)a2, a3, a4, L"LICENSEDLG", 0, 0) )
    return 1;
  if ( a2 == (HWND)272 )
  {
    if ( lParam )
      SendMessageW(hWnd, 0x80u, 1u, lParam);
    if ( dword_438CD0 )
      SendDlgItemMessageW(hWnd, 102, 0x172u, 0, dword_438CD0);
    sub_40D8AE(hWnd);
    DlgItem = GetDlgItem(hWnd, 101);
    SendMessageW(DlgItem, 0x435u, 0, 0x10000);
    SysColor = GetSysColor(15);
    SendMessageW(DlgItem, 0x443u, 0, SysColor);
    sub_40E582(hWnd, (WCHAR *)dword_440D00, 3);
    if ( Block )
    {
      SetForegroundWindow(hWnd);
      sub_419542(lpParam, dword_432A64, DlgItem, (int)Block, 0, 0);
      free(Block);
      return 1;
    }
LABEL_14:
    EndDialog(hWnd, 1);
    return 1;
  }
  if ( a2 != (HWND)273 )
    return 0;
  if ( (unsigned __int16)a3 == 1 )
    goto LABEL_14;
  if ( (unsigned __int16)a3 != 2 )
    return 0;
  EndDialog(hWnd, 0);
  return 1;
}

//----- (0040F2B8) --------------------------------------------------------
INT_PTR __stdcall sub_40F2B8(HWND hDlg, HWND hWnd, HANDLE hFileMappingObject, LPCVOID lpBaseAddress)
{
  WCHAR *v5; // eax
  HWND DlgItem; // eax
  WCHAR *v7; // eax
  WCHAR *v8; // eax
  DWORD LastError; // eax
  DWORD TickCount; // eax
  wchar_t *CommandLineW; // eax
  BOOL v12; // edi
  WCHAR *v13; // eax
  WCHAR *v14; // eax
  HWND v15; // eax
  LONG WindowLongW; // eax
  WCHAR *v17; // eax
  UINT v18; // ebx
  WCHAR *v19; // eax
  WCHAR *v20; // eax
  WCHAR *v21; // eax
  WCHAR *v22; // eax
  WCHAR *v23; // eax
  WCHAR *v24; // eax
  WCHAR *v25; // [esp-Ch] [ebp-9C98h]
  wchar_t v26[780]; // [esp+8h] [ebp-9C84h] BYREF
  wchar_t Destination[8192]; // [esp+620h] [ebp-966Ch] BYREF
  _DWORD v28[1033]; // [esp+4620h] [ebp-566Ch] BYREF
  WCHAR Text[2560]; // [esp+5644h] [ebp-4648h] BYREF
  wchar_t Buffer[2176]; // [esp+6A44h] [ebp-3248h] BYREF
  WCHAR Source[2048]; // [esp+7B44h] [ebp-2148h] BYREF
  WCHAR String[2048]; // [esp+8B44h] [ebp-1148h] BYREF
  _WORD v33[128]; // [esp+9B44h] [ebp-148h] BYREF
  SHELLEXECUTEINFOW pExecInfo; // [esp+9C44h] [ebp-48h] BYREF
  int v35; // [esp+9C88h] [ebp-4h]
  HWND hWnda; // [esp+9C98h] [ebp+Ch]
  HWND hWndb; // [esp+9C98h] [ebp+Ch]
  signed int hWndc; // [esp+9C98h] [ebp+Ch]
  char hWnd_3; // [esp+9C9Bh] [ebp+Fh]
  bool hWnd_3a; // [esp+9C9Bh] [ebp+Fh]
  HANDLE hFileMappingObjecta; // [esp+9C9Ch] [ebp+10h]
  HWND hFileMappingObjectb; // [esp+9C9Ch] [ebp+10h]
  bool hFileMappingObject_3; // [esp+9C9Fh] [ebp+13h]
  void *lpBaseAddressb; // [esp+9CA0h] [ebp+14h]
  HWND lpBaseAddressa; // [esp+9CA0h] [ebp+14h]

  if ( sub_406056(hDlg, (int)hWnd, (int)hFileMappingObject, (int)lpBaseAddress, L"STARTDLG", 0, 0) )
    return 1;
  if ( hWnd == (HWND)272 )
  {
    ::hWnd = hDlg;
    hWndParent = hDlg;
    if ( lParam )
      SendMessageW(hDlg, 0x80u, 1u, lParam);
    if ( dword_438CD0 )
      SendDlgItemMessageW(hDlg, 108, 0x172u, 0, dword_438CD0);
    sub_40D8AE(hDlg);
    lpBaseAddressa = GetDlgItem(hDlg, 104);
    SendMessageW(lpBaseAddressa, 0x435u, 0, 0x400000);
    sub_419740(String, 0x800u);
    hFileMappingObjectb = GetDlgItem(hDlg, 102);
    v20 = word_440D32;
    if ( !word_440D32[0] )
      v20 = String;
    SetWindowTextW(hFileMappingObjectb, v20);
    sub_419757(hFileMappingObjectb);
    byte_440CFC = 0;
    sub_40E48A((int)hDlg, (int)Filename, &dword_440D00, &dword_440D0C);
    if ( dword_440D0C )
      sub_40E582(hDlg, (WCHAR *)dword_440D00, 7);
    if ( !byte_440CFC )
    {
      Destination[0] = 0;
      for ( hWndc = 170; hWndc <= 176; ++hWndc )
      {
        if ( (hWndc != 170 || byte_440D10) && (hWndc != 171 || !byte_440D10) )
        {
          wcscat(Destination, L" ");
          v21 = sub_40C05C(hWndc);
          wcscat(Destination, v21);
        }
      }
      if ( !dword_440D2C )
        sub_419542(dword_437CCC, dword_432A64, lpBaseAddressa, (int)Destination, 0, 0);
    }
    if ( !byte_440D10 )
    {
      v22 = sub_40C05C(0xBFu);
      SetDlgItemTextW(hDlg, 107, v22);
      v23 = sub_40C05C(0xBEu);
      SetDlgItemTextW(hDlg, 1, v23);
    }
    if ( dword_440D0C )
    {
      sub_40E582(hDlg, (WCHAR *)dword_440D00, 0);
      if ( ::Destination && !dword_440D2C )
      {
        sub_419542(dword_437CCC, dword_432A64, lpBaseAddressa, (int)::Destination, 0, 0);
        free(::Destination);
      }
      if ( dword_440D2C != 1 )
      {
        SetForegroundWindow(hDlg);
        if ( dword_440D2C != 1
          && !byte_440D31
          && !DialogBoxParamW(dword_432A64, L"LICENSEDLG", 0, (DLGPROC)sub_40F1A6, 0) )
        {
          goto LABEL_17;
        }
      }
      sub_40E582(hDlg, (WCHAR *)dword_440D00, 1);
    }
    if ( dword_440D2C == 2 )
      EnableWindow(hFileMappingObjectb, 0);
    if ( byte_440D28 )
    {
      sub_406013(hDlg, 103, 0);
      sub_406013(hDlg, 102, 0);
    }
    if ( dword_440D2C && !byte_440CEA )
    {
      if ( dword_440D2C == 1 )
        SendMessageW(hDlg, 0x111u, 1u, 0);
      else
        PostMessageW(hDlg, 0x111u, 1u, 0);
    }
    if ( byte_440CE8 )
    {
      v24 = sub_40C05C(0x90u);
      SetDlgItemTextW(hDlg, 1, v24);
    }
    return 1;
  }
  if ( hWnd != (HWND)273 )
    return 0;
  if ( (unsigned __int16)hFileMappingObject != 1 )
  {
    if ( (unsigned __int16)hFileMappingObject != 2 )
    {
      if ( (unsigned __int16)hFileMappingObject != 103 )
        return 0;
      v5 = sub_40C05C(0x64u);
      if ( sub_405088(hDlg, v5, String) )
        SetDlgItemTextW(hDlg, 102, String);
      return 1;
    }
    byte_440CEA = 1;
    if ( !dword_440CEC || !dword_440CF0 )
      goto LABEL_13;
    return 1;
  }
  GetDlgItemTextW(hDlg, 102, Source, 2048);
  if ( byte_440CE9 )
  {
    if ( !byte_440CE8 )
    {
LABEL_18:
      EndDialog(hDlg, 1);
      return 1;
    }
LABEL_17:
    byte_440CEA = 1;
    goto LABEL_18;
  }
  if ( !byte_440CE8 )
  {
    DlgItem = GetDlgItem(hDlg, 104);
    hWnda = DlgItem;
    if ( !dword_440CF0 )
    {
      SendMessageW(DlgItem, 0xB1u, 0, -1);
      SendMessageW(hWnda, 0xC2u, 0, (LPARAM)&::String);
    }
    SetFocus(hWnda);
    if ( byte_440D28 )
    {
      v7 = sub_40C05C(0xBAu);
    }
    else
    {
      sub_41078F(String, Source, 2048);
      sub_40DA6B(String, 2048);
      v8 = sub_40C05C(0xB9u);
      swprintf(Buffer, 0x880u, v8, String);
      v7 = Buffer;
    }
    sub_40CFBD(0, (LPARAM)v7);
    if ( !byte_440D31 )
      sub_40D779((BYTE *)Source);
    hWnd_3 = 0;
    if ( !sub_4090CB(Source, 0) )
    {
      LastError = GetLastError();
      if ( LastError == 5 || LastError == 3 )
        hWnd_3 = 1;
    }
    hFileMappingObject_3 = sub_41972D(Source);
    if ( !hFileMappingObject_3 && GetLastError() == 5 )
      hWnd_3 = 1;
    if ( !byte_440D31 )
    {
      if ( !hFileMappingObject_3 )
        goto LABEL_44;
      TickCount = GetTickCount();
      swprintf(String, 0x800u, L"__tmp_rar_sfx_access_check_%u", TickCount);
      sub_408533(v28);
      v35 = 0;
      hFileMappingObject_3 = sub_4086D1((int)v28, String, 9u);
      if ( !hFileMappingObject_3 && GetLastError() == 5 )
        hWnd_3 = 1;
      v35 = -1;
      sub_4089F9((int)v28);
    }
    if ( hFileMappingObject_3 )
    {
      dword_440CEC = 1;
      sub_406031(hDlg, 103, 0);
      sub_406031(hDlg, 102, 0);
      sub_406013(hDlg, 1, 0);
      sub_406031(hDlg, 105, 1);
      SetDlgItemTextW(hDlg, 101, &::String);
      v15 = GetDlgItem(hDlg, 101);
      hWndb = v15;
      if ( v15 )
      {
        WindowLongW = GetWindowLongW(v15, -16);
        SetWindowLongW(hWndb, -16, WindowLongW | 0x80);
      }
      sub_40E582(hDlg, (WCHAR *)dword_440D00, 5);
      sub_40E582(hDlg, (WCHAR *)dword_440D00, 2);
      sub_40DFC4((int)hDlg, Filename);
      sub_40E582(hDlg, (WCHAR *)dword_440D00, 6);
      if ( !byte_440CEA && !dword_440CF0 && !hHandle )
        sub_40E582(hDlg, (WCHAR *)dword_440D00, 4);
      sub_406013(hDlg, 1, 1u);
      dword_440CEC = 0;
      goto LABEL_63;
    }
    if ( byte_440D31 )
      hWnd_3 = 0;
LABEL_44:
    hWnd_3a = hWnd_3 == 0;
    if ( hWnd_3a )
      goto LABEL_55;
    GetModuleFileNameW(0, String, 0x800u);
    sub_40CC83(byte_442D32, v33, 128);
    swprintf(v26, 0x230Cu, L"-el -s2 \"-d%s\" \"-p%s\" \"-sp%s\"", Source, v33, word_441D32);
    pExecInfo.lpFile = String;
    pExecInfo.cbSize = 60;
    pExecInfo.fMask = 64;
    pExecInfo.hwnd = hDlg;
    pExecInfo.lpVerb = L"runas";
    pExecInfo.lpParameters = v26;
    pExecInfo.lpDirectory = L".";
    pExecInfo.nShow = 1;
    pExecInfo.hInstApp = 0;
    hFileMappingObjecta = CreateFileMappingW((HANDLE)0xFFFFFFFF, 0, 0x8000004u, 0, 0x7000u, L"winrarsfxmappingfile.tmp");
    if ( hFileMappingObjecta )
    {
      CommandLineW = GetCommandLineW();
      if ( CommandLineW )
        sub_41078F(Src, CommandLineW, 0x2000);
      sub_40CE92(pszPath, 7);
      sub_40CE92(word_43ECD8, 2);
      sub_40CE92(word_43FCD8, 16);
      lpBaseAddressb = MapViewOfFile(hFileMappingObjecta, 2u, 0, 0, 0);
      memcpy(lpBaseAddressb, Src, 0x7000u);
      UnmapViewOfFile(lpBaseAddressb);
    }
    v12 = ShellExecuteExW(&pExecInfo);
    sub_40CC38(v33, 128);
    sub_40CC38(v26, 8972);
    if ( v12 )
    {
      WaitForInputIdle(pExecInfo.hProcess, 0x2710u);
      Sleep(0x1F4u);
      hHandle = pExecInfo.hProcess;
    }
    else
    {
      hWnd_3a = 1;
    }
    if ( hFileMappingObjecta )
      CloseHandle(hFileMappingObjecta);
    if ( hWnd_3a )
    {
LABEL_55:
      v13 = sub_40C05C(0x9Au);
      swprintf(Text, 0xA00u, L"\"%s\"\n%s", Source, v13);
      sub_406222(&dword_432A6C, 1);
      v14 = sub_40C05C(0x96u);
      MessageBoxW(hDlg, Text, v14, 0x30u);
      ++dword_440CF0;
    }
LABEL_13:
    EndDialog(hDlg, 0);
    return 1;
  }
  byte_440CEA = 1;
LABEL_63:
  if ( dword_440CF0 <= 0 || byte_440CEA )
  {
    EndDialog(hDlg, 1);
  }
  else
  {
    byte_440CE9 = 1;
    v17 = sub_40C05C(0x90u);
    SetDlgItemTextW(hDlg, 1, v17);
    if ( dword_432A6C == 9 )
      v18 = 160;
    else
      v18 = dword_432A6C != 3 ? 151 : 161;
    v25 = sub_40C05C(0x96u);
    v19 = sub_40C05C(v18);
    MessageBoxW(hDlg, v19, v25, 0x30u);
  }
  return 1;
}
// 42AAA0: using guessed type wchar_t aRunas[6];
// 432A6C: using guessed type int dword_432A6C;
// 438CD8: using guessed type wchar_t Filename[2048];
// 439CD8: using guessed type wchar_t Src[8192];
// 43DCD8: using guessed type wchar_t pszPath[2048];
// 43ECD8: using guessed type wchar_t word_43ECD8[2048];
// 43FCD8: using guessed type wchar_t word_43FCD8[438];
// 440CE8: using guessed type char byte_440CE8;
// 440CE9: using guessed type char byte_440CE9;
// 440CEA: using guessed type char byte_440CEA;
// 440CEC: using guessed type int dword_440CEC;
// 440CF0: using guessed type int dword_440CF0;
// 440CFC: using guessed type char byte_440CFC;
// 440D0C: using guessed type int dword_440D0C;
// 440D10: using guessed type char byte_440D10;
// 440D28: using guessed type char byte_440D28;
// 440D2C: using guessed type int dword_440D2C;
// 440D31: using guessed type char byte_440D31;
// 440D32: using guessed type wchar_t word_440D32[2048];
// 441D32: using guessed type wchar_t word_441D32[2048];
// 442D32: using guessed type _BYTE byte_442D32[256];
// 40F2B8: using guessed type _DWORD var_566C[1033];
// 40F2B8: using guessed type _WORD var_148[128];

//----- (0040FB40) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  LPWSTR CommandLineW; // eax
  HANDLE v5; // eax
  const void *v6; // eax
  HMODULE ModuleHandleW; // edi
  int result; // eax
  _DWORD v9[10]; // [esp+Ch] [ebp-5Ch] BYREF
  _DWORD v10[10]; // [esp+34h] [ebp-34h] BYREF
  HMODULE v11; // [esp+5Ch] [ebp-Ch] BYREF
  HANDLE hObject; // [esp+60h] [ebp-8h]
  LPCVOID lpBaseAddress; // [esp+64h] [ebp-4h]

  sub_410A27(1);
  OleInitialize(0);
  sub_411A88(byte_44EA70);
  memset(Src, 0, 0x7000u);
  CommandLineW = GetCommandLineW();
  hObject = CommandLineW;
  if ( CommandLineW )
  {
    sub_40D31C(CommandLineW);
    if ( byte_440D31 )
    {
      v5 = OpenFileMappingW(4u, 0, L"winrarsfxmappingfile.tmp");
      hObject = v5;
      if ( v5 )
      {
        v6 = MapViewOfFile(v5, 4u, 0, 0, 0x7000u);
        lpBaseAddress = v6;
        if ( v6 )
        {
          memcpy(Src, v6, 0x7000u);
          SetEnvironmentVariableW(L"sfxcmd", Src);
        }
        UnmapViewOfFile(lpBaseAddress);
      }
      CloseHandle(hObject);
    }
    else
    {
      SetEnvironmentVariableW(L"sfxcmd", (LPCWSTR)hObject);
    }
  }
  GetModuleFileNameW(0, Filename, 0x800u);
  SetEnvironmentVariableW(L"sfxname", Filename);
  ModuleHandleW = GetModuleHandleW(0);
  dword_432A64 = ModuleHandleW;
  ::hInstance = ModuleHandleW;
  lParam = (LPARAM)LoadIconW(ModuleHandleW, (LPCWSTR)0x64);
  dword_438CD0 = (LPARAM)LoadBitmapW(::hInstance, (LPCWSTR)0x65);
  sub_419958(&v11);
  sub_40C045(&unk_432A7C, Filename);
  sub_418C53(v9);
  sub_418C53(v10);
  v9[7] = sub_40CF18(100);
  v10[7] = sub_40CF18(100);
  dword_437CCC = v9;
  lpParam = v10;
  DialogBoxParamW(ModuleHandleW, L"STARTDLG", 0, (DLGPROC)sub_40F2B8, 0);
  lpParam = 0;
  dword_437CCC = 0;
  sub_418C75(v10);
  sub_418C75(v9);
  sub_4199B2(&v11);
  if ( byte_440D28 )
    sub_40D583();
  sub_40CD80(byte_44C2D8);
  if ( dword_440D0C )
    free(dword_440D00);
  DeleteObject((HGDIOBJ)lParam);
  if ( dword_438CD0 )
    DeleteObject((HGDIOBJ)dword_438CD0);
  if ( !dword_432A6C && byte_440CEA )
    sub_406222(&dword_432A6C, 255);
  byte_440CEA = 1;
  if ( hHandle )
    sub_40D544(hHandle);
  if ( dwMilliseconds )
    Sleep(dwMilliseconds);
  OleUninitialize();
  result = dword_440D14;
  if ( !dword_440D14 )
    return dword_432A6C;
  return result;
}
// 432A6C: using guessed type int dword_432A6C;
// 438CD8: using guessed type wchar_t Filename[2048];
// 439CD8: using guessed type wchar_t Src[8192];
// 440CEA: using guessed type char byte_440CEA;
// 440D0C: using guessed type int dword_440D0C;
// 440D14: using guessed type int dword_440D14;
// 440D28: using guessed type char byte_440D28;
// 440D31: using guessed type char byte_440D31;
// 44C2D8: using guessed type _BYTE byte_44C2D8[256];
// 44EA70: using guessed type _BYTE byte_44EA70[264];

//----- (0040FD6B) --------------------------------------------------------
_DWORD *__stdcall sub_40FD6B(const void *a1, unsigned int *a2, void *Src, char a4)
{
  unsigned int *v4; // ebx
  int v5; // ecx
  int *v6; // esi
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  int v9; // edx
  int v10; // edi
  _DWORD *v11; // edx
  unsigned int *v12; // esi
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // edi
  int *v16; // edx
  unsigned int *v17; // esi
  unsigned int v18; // eax
  int v19; // edi
  char *v20; // ecx
  unsigned int *v21; // esi
  unsigned int v22; // eax
  int v23; // esi
  int *v24; // edi
  int v25; // edx
  int *v26; // edx
  unsigned int *v27; // esi
  unsigned int v28; // eax
  int v29; // edi
  _DWORD *result; // eax
  int v31; // edx
  int v32[5]; // [esp+Ch] [ebp-20h] BYREF
  int *v33; // [esp+20h] [ebp-Ch]
  int *v34; // [esp+24h] [ebp-8h]
  int *v35; // [esp+28h] [ebp-4h]
  int *Srcb; // [esp+3Ch] [ebp+10h]
  int *Srcc; // [esp+3Ch] [ebp+10h]
  int *Srcd; // [esp+3Ch] [ebp+10h]
  char *Srca; // [esp+3Ch] [ebp+10h]
  int *Srce; // [esp+3Ch] [ebp+10h]
  unsigned int *v41; // [esp+40h] [ebp+14h]
  char v42; // [esp+40h] [ebp+14h]
  char v43; // [esp+40h] [ebp+14h]
  char v44; // [esp+40h] [ebp+14h]
  int v45; // [esp+40h] [ebp+14h]

  if ( a4 )
  {
    v4 = a2;
    memcpy(a2, Src, 0x40u);
  }
  else
  {
    v4 = (unsigned int *)Src;
  }
  if ( !byte_44EA30 )
  {
    v5 = 0;
    v6 = (int *)&unk_44E3F4;
    do
    {
      *(v6 - 1) = v5;
      *v6 = (v5 + 1) % 5;
      v6 += 5;
      *(v6 - 4) = (v5 + 2) % 5;
      *(v6 - 3) = (v5 + 3) % 5;
      *(v6 - 2) = (v5 + 4) % 5;
      if ( v5 )
        --v5;
      else
        v5 = 4;
    }
    while ( (int)v6 < (int)&unk_44EA34 );
    byte_44EA30 = 1;
  }
  qmemcpy(v32, a1, sizeof(v32));
  v7 = &unk_44E3FC;
  v41 = v4;
  do
  {
    v8 = __ROL4__(*v41, 8) & 0xFF00FF | __ROR4__(*v41, 8) & 0xFF00FF00;
    *v41 = v8;
    v9 = v32[*v7];
    v10 = v32[*(v7 - 1)];
    ++v41;
    Srcb = &v32[*(v7 - 2)];
    v35 = &v32[v7[1]];
    *v35 += (v9 ^ *Srcb & (v9 ^ v10)) + v8 + __ROL4__(v32[*(v7 - 3)], 5) + 1518500249;
    *Srcb = __ROR4__(*Srcb, 2);
    v7 += 5;
    v11 = &unk_44E53C;
  }
  while ( (int)v7 < (int)&unk_44E53C );
  v42 = 16;
  do
  {
    v12 = &v4[v42 & 0xF];
    v13 = __ROL4__(*v12 ^ v4[(v42 - 3) & 0xF] ^ v4[(v42 - 3 + 5) & 0xF] ^ v4[(v42 - 8) & 0xF], 1);
    *v12 = v13;
    v14 = v32[*v11];
    v15 = v32[*(v11 - 1)];
    Srcc = &v32[*(v11 - 2)];
    v35 = &v32[v11[1]];
    *v35 += (v14 ^ *Srcc & (v14 ^ v15)) + v13 + __ROL4__(v32[*(v11 - 3)], 5) + 1518500249;
    *Srcc = __ROR4__(*Srcc, 2);
    ++v42;
    v11 += 5;
  }
  while ( (int)v11 < (int)&unk_44E58C );
  v43 = 20;
  v16 = (int *)&unk_44E58C;
  do
  {
    v17 = &v4[v43 & 0xF];
    v18 = __ROL4__(*v17 ^ v4[(v43 - 3) & 0xF] ^ v4[(v43 - 3 + 5) & 0xF] ^ v4[(v43 - 8) & 0xF], 1);
    *v17 = v18;
    v19 = *v16;
    Srcd = &v32[*(v16 - 2)];
    v35 = &v32[v16[1]];
    *v35 += (*Srcd ^ v32[v19] ^ v32[*(v16 - 1)]) + v18 + __ROL4__(v32[*(v16 - 3)], 5) + 1859775393;
    *Srcd = __ROR4__(*Srcd, 2);
    ++v43;
    v16 += 5;
  }
  while ( (int)v16 < (int)&unk_44E71C );
  v20 = (char *)&unk_44E718;
  v44 = 40;
  Srca = (char *)&unk_44E718;
  do
  {
    v21 = &v4[v44 & 0xF];
    v22 = __ROL4__(*v21 ^ v4[(v44 - 3) & 0xF] ^ v4[(v44 - 3 + 5) & 0xF] ^ v4[(v44 - 8) & 0xF], 1);
    *v21 = v22;
    v23 = v32[*(_DWORD *)v20];
    v24 = &v32[*((_DWORD *)v20 + 2)];
    v33 = &v32[*((_DWORD *)v20 - 1)];
    v25 = *v33;
    v34 = v24;
    *v24 += (v23 & v25 | (v23 | v25) & v32[*((_DWORD *)v20 + 1)])
          + v22
          + __ROL4__(v32[*((_DWORD *)v20 - 2)], 5)
          - 1894007588;
    *v33 = __ROR4__(*v33, 2);
    ++v44;
    v20 = Srca + 20;
    Srca = v20;
  }
  while ( (int)v20 < (int)&unk_44E8A8 );
  v45 = 60;
  v26 = (int *)&unk_44E8AC;
  do
  {
    v27 = &v4[v45 & 0xF];
    v28 = __ROL4__(*v27 ^ v4[(v45 - 3) & 0xF] ^ v4[((_BYTE)v45 - 3 + 5) & 0xF] ^ v4[((_BYTE)v45 - 8) & 0xF], 1);
    *v27 = v28;
    v29 = *v26;
    Srce = &v32[*(v26 - 2)];
    v33 = &v32[v26[1]];
    *v33 += (*Srce ^ v32[v29] ^ v32[*(v26 - 1)]) + v28 + __ROL4__(v32[*(v26 - 3)], 5) - 899497514;
    *Srce = __ROR4__(*Srce, 2);
    ++v45;
    v26 += 5;
  }
  while ( (int)v26 < (int)&dword_44EA3C );
  result = a1;
  v31 = 5;
  do
  {
    *result += *(_DWORD *)((char *)result + (char *)v32 - (_BYTE *)a1);
    ++result;
    --v31;
  }
  while ( v31 );
  return result;
}
// 44EA30: using guessed type char byte_44EA30;
// 44EA3C: using guessed type int dword_44EA3C;
// 40FD6B: using guessed type int var_20[5];

//----- (004100CB) --------------------------------------------------------
_DWORD *__stdcall sub_4100CB(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  a1[6] = 0;
  a1[5] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
  return result;
}

//----- (004100FC) --------------------------------------------------------
void *__stdcall sub_4100FC(unsigned int *a1, char *Src, unsigned int a3, char a4)
{
  unsigned int v5; // edx
  void *result; // eax
  unsigned int v7; // edi
  unsigned int v8; // [esp+1Ch] [ebp+10h]

  v5 = 8 * a3 + a1[5];
  result = (void *)((a1[5] >> 3) & 0x3F);
  a1[5] = v5;
  if ( v5 < 8 * a3 )
    ++a1[6];
  a1[6] += a3 >> 29;
  if ( (unsigned int)result + a3 <= 0x3F )
  {
    v7 = 0;
  }
  else
  {
    v7 = 64 - (_DWORD)result;
    memcpy((char *)a1 + (_DWORD)result + 28, Src, 64 - (_DWORD)result);
    sub_40FD6B(a1, a1 + 23, a1 + 7, a4);
    if ( v7 + 63 < a3 )
    {
      v8 = v7 + 63;
      do
      {
        sub_40FD6B(a1, a1 + 23, &Src[v8 - 63], a4);
        v8 += 64;
        v7 += 64;
      }
      while ( v8 < a3 );
    }
    result = 0;
  }
  if ( a3 > v7 )
    return memcpy((char *)a1 + (_DWORD)result + 28, &Src[v7], a3 - v7);
  return result;
}

//----- (004101B0) --------------------------------------------------------
_BYTE *__stdcall sub_4101B0(int Src, int a2, char a3)
{
  int v3; // esi
  unsigned int i; // eax
  int v5; // edx
  _BYTE *result; // eax
  char v8[8]; // [esp+4h] [ebp-10h] BYREF
  char v9[4]; // [esp+Ch] [ebp-8h] BYREF
  unsigned int j; // [esp+10h] [ebp-4h] BYREF

  v3 = Src;
  for ( i = 0; i < 8; v8[i - 1] = v5 )
  {
    v5 = *(_DWORD *)(v3 + 4 * (i < 4) + 20) >> (8 * (3 - (i & 3)));
    ++i;
  }
  j = i;
  HIBYTE(Src) = 0x80;
  sub_4100FC((unsigned int *)v3, (char *)&Src + 3, 1u, a3);
  while ( (*(_DWORD *)(v3 + 20) & 0x1F8) != 448 )
  {
    HIBYTE(Src) = 0;
    sub_4100FC((unsigned int *)v3, (char *)&Src + 3, 1u, a3);
  }
  sub_4100FC((unsigned int *)v3, v8, 8u, a3);
  for ( j = 0; j < 5; ++j )
    *(_DWORD *)(4 * j + a2) = *(_DWORD *)(4 * j + v3);
  sub_40CC38(&j, 4);
  sub_40CC38(v9, 4);
  sub_40CC38((_BYTE *)(v3 + 28), 64);
  sub_40CC38((_BYTE *)v3, 20);
  sub_40CC38((_BYTE *)(v3 + 20), 8);
  result = sub_40CC38(v8, 8);
  if ( a3 )
    return memset((void *)(v3 + 92), 0, 0x40u);
  return result;
}
// 4101B0: using guessed type char var_8[4];

//----- (004102A1) --------------------------------------------------------
_DWORD *__stdcall sub_4102A1(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  a1[8] = 0;
  a1[9] = 0;
  *a1 = 1779033703;
  a1[1] = -1150833019;
  a1[2] = 1013904242;
  a1[3] = -1521486534;
  a1[4] = 1359893119;
  a1[5] = -1694144372;
  a1[6] = 528734635;
  a1[7] = 1541459225;
  return result;
}

//----- (004102E7) --------------------------------------------------------
_BYTE *__usercall sub_4102E7@<eax>(int a1@<esi>)
{
  _BYTE *result; // eax
  int *v2; // eax
  int v3; // edi
  int v4; // edi
  bool v5; // zf
  int v6; // eax
  int v7; // edi
  int v8; // edx
  int v9; // eax
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ebx
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int v24[14]; // [esp+0h] [ebp-124h] BYREF
  int v25[50]; // [esp+38h] [ebp-ECh] BYREF
  int v26; // [esp+100h] [ebp-24h] BYREF
  int v27; // [esp+104h] [ebp-20h]
  int v28; // [esp+108h] [ebp-1Ch]
  int v29; // [esp+10Ch] [ebp-18h]
  int v30; // [esp+114h] [ebp-10h]
  int v31; // [esp+118h] [ebp-Ch]
  int v32; // [esp+11Ch] [ebp-8h]
  unsigned int v33; // [esp+120h] [ebp-4h]

  if ( a1 )
  {
    v24[0] = _byteswap_ulong(**(_DWORD **)(a1 + 40));
    v24[1] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4));
    v24[2] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 8));
    v24[3] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 12));
    v24[4] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 16));
    v24[5] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 20));
    v24[6] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 24));
    v24[7] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 28));
    v24[8] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 32));
    v24[9] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 36));
    v24[10] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 40));
    v24[11] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 44));
    v24[12] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 48));
    v24[13] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 52));
    v25[0] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 56));
    v25[1] = _byteswap_ulong(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 60));
    v2 = v25;
    v33 = 48;
    do
    {
      v3 = *(v2 - 14)
         + (((unsigned int)*v2 >> 10) ^ __ROL4__(*v2, 13) ^ __ROL4__(*v2, 15))
         + (((unsigned int)*(v2 - 13) >> 3) ^ __ROR4__(*(v2 - 13), 7) ^ __ROL4__(*(v2 - 13), 14));
      v4 = *(++v2 - 6) + v3;
      v5 = v33-- == 1;
      v2[1] = v4;
    }
    while ( !v5 );
    v6 = *(_DWORD *)(a1 + 4);
    v7 = *(_DWORD *)a1;
    v8 = *(_DWORD *)(a1 + 16);
    v33 = 0;
    v27 = v6;
    v28 = *(_DWORD *)(a1 + 8);
    v29 = *(_DWORD *)(a1 + 12);
    v30 = *(_DWORD *)(a1 + 20);
    v31 = *(_DWORD *)(a1 + 24);
    v9 = *(_DWORD *)(a1 + 28);
    v26 = v7;
    v32 = v9;
    do
    {
      v10 = v33;
      v11 = *(int *)((char *)&dword_42AB90 + v33)
          + (v8 & v30 ^ v31 & ~v8)
          + (__ROR4__(v8, 6) ^ __ROL4__(v8, 7) ^ __ROR4__(v8, 11));
      v33 += 4;
      v12 = v32 + *(int *)((char *)v24 + v10) + v11;
      v32 = v31;
      v31 = v30;
      v30 = v8;
      v8 = v12 + v29;
      v13 = (v26 & v27 ^ v28 & (v7 ^ v27)) + (__ROR4__(v7, 2) ^ __ROL4__(v7, 10) ^ __ROR4__(v7, 13));
      v14 = v27;
      v29 = v28;
      v27 = v26;
      v7 = v13 + v12;
      v28 = v14;
      v26 = v13 + v12;
    }
    while ( v33 < 0x100 );
    v15 = v27;
    *(_DWORD *)a1 += v7;
    v16 = v15 + *(_DWORD *)(a1 + 4);
    v17 = v29;
    *(_DWORD *)(a1 + 4) = v16;
    *(_DWORD *)(a1 + 8) += v14;
    v18 = v17 + *(_DWORD *)(a1 + 12);
    v19 = v30;
    *(_DWORD *)(a1 + 12) = v18;
    *(_DWORD *)(a1 + 16) += v8;
    v20 = v19 + *(_DWORD *)(a1 + 20);
    v21 = v31;
    *(_DWORD *)(a1 + 20) = v20;
    v22 = v21 + *(_DWORD *)(a1 + 24);
    v23 = v32;
    *(_DWORD *)(a1 + 24) = v22;
    result = (_BYTE *)(v23 + *(_DWORD *)(a1 + 28));
    *(_DWORD *)(a1 + 28) = result;
  }
  else
  {
    sub_40CC38(&v26, 32);
    return sub_40CC38(v24, 256);
  }
  return result;
}
// 42AB90: using guessed type int dword_42AB90;

//----- (004105A3) --------------------------------------------------------
_BYTE *__stdcall sub_4105A3(_DWORD *a1, char *Src, size_t Size)
{
  char *v3; // ecx
  size_t v4; // ebx
  int v5; // edi
  bool v6; // cf

  v3 = Src;
  v4 = Size;
  v5 = a1[8] & 0x3F;
  v6 = __CFADD__(Size, a1[8]);
  a1[8] += Size;
  a1[9] += v6;
  if ( Size )
  {
    while ( 1 )
    {
      if ( v4 > 64 - v5 )
        v4 = 64 - v5;
      if ( v4 == 64 )
      {
        a1[10] = v3;
      }
      else
      {
        a1[10] = a1 + 11;
        memcpy((char *)a1 + v5 + 44, v3, v4);
      }
      Src += v4;
      Size -= v4;
      v5 += v4;
      if ( v5 == 64 )
      {
        v5 = 0;
        sub_4102E7((int)a1);
      }
      v4 = Size;
      if ( !Size )
        break;
      v3 = Src;
    }
  }
  return sub_4102E7(0);
}

//----- (0041061C) --------------------------------------------------------
_BYTE *__stdcall sub_41061C(int a1, int a2)
{
  _BYTE *v2; // ebx
  int v3; // edi
  int v4; // edi
  _BYTE *v5; // edi
  int v6; // eax
  unsigned int i; // edi
  __int64 v9; // [esp-10h] [ebp-24h]
  __int64 v10; // [esp+Ch] [ebp-8h]

  v9 = *(_QWORD *)(a1 + 32);
  v2 = (_BYTE *)(a1 + 44);
  *(_DWORD *)(a1 + 40) = a1 + 44;
  v3 = *(_DWORD *)(a1 + 32) & 0x3F;
  v10 = 8 * v9;
  *(_BYTE *)(v3 + a1 + 44) = 0x80;
  while ( 1 )
  {
    v4 = v3 + 1;
    if ( v4 == 56 )
      break;
    v3 = v4 & 0x3F;
    if ( !v3 )
      sub_4102E7(a1);
    v2[v3] = 0;
  }
  v5 = (_BYTE *)(a1 + 100);
  v6 = 8;
  do
  {
    *v5++ = HIBYTE(v10);
    --v6;
    v10 <<= 8;
  }
  while ( v6 );
  sub_4102E7(a1);
  for ( i = 0; i < 0x20; ++i )
    *(_BYTE *)(i + a2) = *(_DWORD *)(a1 + 4 * (i >> 2)) >> (8 * (3 - (i & 3)));
  sub_4102A1((_DWORD *)a1);
  sub_4102E7(0);
  return sub_40CC38(v2, 64);
}

//----- (004106CF) --------------------------------------------------------
int __stdcall sub_4106CF(__int64 a1, __int64 a2)
{
  __int64 v2; // rax

  LODWORD(v2) = HIDWORD(a2) | a2;
  if ( a2 )
    return 100 * a1 / a2;
  return v2;
}

//----- (004106FA) --------------------------------------------------------
int __stdcall sub_4106FA(__int64 a1, __int64 a2)
{
  if ( a2 >= a1 )
    return sub_4106CF(a1, a2);
  else
    return 100;
}

//----- (00410725) --------------------------------------------------------
BOOL __stdcall sub_410725(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
{
  BOOL result; // eax

  result = OemToCharBuffA(lpszSrc, lpszDst, cchDstLength);
  lpszDst[cchDstLength - 1] = 0;
  return result;
}

//----- (00410745) --------------------------------------------------------
int __stdcall sub_410745(wint_t a1)
{
  if ( a1 == 105 )
    return 73;
  else
    return sub_411A29(a1);
}

//----- (00410760) --------------------------------------------------------
BOOL __stdcall sub_410760(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (00410772) --------------------------------------------------------
BOOL __stdcall sub_410772(int a1)
{
  return a1 == 32 || a1 == 9;
}

//----- (0041078F) --------------------------------------------------------
wchar_t *__stdcall sub_41078F(wchar_t *Destination, wchar_t *Source, int a3)
{
  if ( a3 )
  {
    wcsncpy(Destination, Source, a3 - 1);
    Destination[a3 - 1] = 0;
  }
  return Destination;
}

//----- (004107BC) --------------------------------------------------------
wchar_t *__stdcall sub_4107BC(wchar_t *String, wchar_t *Source, unsigned int a3)
{
  size_t v3; // eax

  v3 = wcslen(String);
  if ( v3 + 1 < a3 )
    wcsncat(String, Source, a3 - v3 - 1);
  return String;
}

//----- (004107EB) --------------------------------------------------------
int __stdcall sub_4107EB(__int64 a1, int a2)
{
  unsigned int v2; // esi
  __int64 v3; // rcx
  unsigned int v4; // eax
  char *v5; // ecx
  int result; // eax
  char v7[106]; // [esp+6h] [ebp-6Eh] BYREF
  int v8; // [esp+70h] [ebp-4h]

  v2 = 0;
  do
  {
    v3 = a1 % 10;
    *(_WORD *)&v7[2 * v2++ + 2] = a1 % 10 + 48;
    a1 /= 10i64;
    v4 = HIDWORD(a1) | a1;
    v8 = HIDWORD(v3);
  }
  while ( a1 );
  if ( v2 )
  {
    v5 = &v7[2 * v2];
    do
    {
      *(_WORD *)(a2 + 2 * v4++) = *(_WORD *)v5;
      v5 -= 2;
    }
    while ( v4 < v2 );
  }
  result = 0;
  *(_WORD *)(a2 + 2 * v2) = 0;
  return result;
}

//----- (00410841) --------------------------------------------------------
unsigned __int16 *__stdcall sub_410841(unsigned __int16 *a1, int a2, int a3)
{
  unsigned __int16 *v4; // edx
  unsigned __int16 v5; // cx
  unsigned int v7; // esi
  bool v8; // [esp+Bh] [ebp+Bh]

  while ( sub_410772(*a1) )
    a1 = v4 + 1;
  v5 = *v4;
  if ( !*v4 )
    return 0;
  v7 = 0;
  v8 = 0;
  do
  {
    if ( !v8 && sub_410772(v5) )
      break;
    if ( v5 == 34 )
    {
      if ( v4[1] == 34 )
      {
        if ( a2 && v7 < a3 - 1 )
          *(_WORD *)(a2 + 2 * v7++) = 34;
        ++v4;
      }
      else
      {
        v8 = !v8;
      }
    }
    else if ( a2 && v7 < a3 - 1 )
    {
      *(_WORD *)(a2 + 2 * v7++) = v5;
    }
    v5 = *++v4;
  }
  while ( *v4 );
  if ( a2 )
    *(_WORD *)(a2 + 2 * v7) = 0;
  return v4;
}
// 41084A: variable 'v4' is possibly undefined
// 41088A: variable 'v5' is possibly undefined

//----- (004108E4) --------------------------------------------------------
void __thiscall sub_4108E4(_DWORD *this)
{
  this[4] = 0;
}

//----- (004108E9) --------------------------------------------------------
void __thiscall sub_4108E9(_DWORD *this)
{
  this[4] = 0;
  sub_412595((int)this);
  this[5] = 0;
  this[22] = 0;
}

//----- (004108FF) --------------------------------------------------------
wchar_t *__thiscall sub_4108FF(_DWORD *this, wchar_t *String)
{
  const wchar_t *v2; // ebx
  int v4; // edi
  size_t v5; // eax
  wchar_t *result; // eax

  v2 = String;
  if ( !String )
    v2 = &::String;
  v4 = this[1];
  v5 = wcslen(v2);
  sub_4011B4((int)this, v5 + 1);
  result = wcscpy((wchar_t *)(*this + 2 * v4), v2);
  ++this[5];
  return result;
}

//----- (0041093B) --------------------------------------------------------
char __thiscall sub_41093B(_DWORD *this, const wchar_t **a2)
{
  unsigned int v2; // eax
  const wchar_t *v4; // edi

  v2 = this[4];
  if ( v2 < this[1] )
  {
    v4 = (const wchar_t *)(*this + 2 * v2);
    this[4] += wcslen(v4) + 1;
    if ( a2 )
      *a2 = v4;
    return 1;
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    return 0;
  }
}

//----- (00410977) --------------------------------------------------------
_DWORD *__thiscall sub_410977(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  sub_4108E9(this);
  return this;
}

//----- (00410990) --------------------------------------------------------
char __thiscall sub_410990(wchar_t *this, wchar_t *Destination, int a3)
{
  char result; // al
  wchar_t *Source; // [esp+0h] [ebp-4h] BYREF

  Source = this;
  result = sub_41093B(this, (const wchar_t **)&Source);
  if ( result )
  {
    sub_41078F(Destination, Source, a3);
    return 1;
  }
  return result;
}

//----- (004109B5) --------------------------------------------------------
const wchar_t *__thiscall sub_4109B5(wchar_t *this)
{
  wchar_t *v2; // [esp+0h] [ebp-4h] BYREF

  v2 = this;
  sub_41093B(this, (const wchar_t **)&v2);
  return v2;
}

//----- (004109C7) --------------------------------------------------------
char sub_4109C7()
{
  int v0; // eax

  if ( (dword_44EA40 & 1) == 0 )
  {
    dword_44EA40 |= 1u;
    dword_44EA3C = clock();
  }
  v0 = clock() - dword_44EA3C;
  if ( v0 > 50 )
  {
    sub_4114F4();
    LOBYTE(v0) = sub_4114EE();
    if ( (_BYTE)v0 )
      LOBYTE(v0) = sub_4062C3(255);
  }
  if ( byte_432A77 )
    LOBYTE(v0) = sub_4062C3(255);
  return v0;
}
// 432A77: using guessed type char byte_432A77;
// 44EA3C: using guessed type int dword_44EA3C;
// 44EA40: using guessed type int dword_44EA40;

//----- (00410A27) --------------------------------------------------------
HMODULE __stdcall sub_410A27(char a1)
{
  HMODULE result; // eax

  result = GetModuleHandleW(L"kernel32");
  if ( result )
  {
    result = (HMODULE)GetProcAddress(result, "SetDllDirectoryW");
    if ( result )
      return (HMODULE)((int (__stdcall *)(const WCHAR *))result)(a1 != 0 ? &String : 0);
  }
  return result;
}

//----- (00410A5B) --------------------------------------------------------
int sub_410A5B()
{
  _EAX = 1;
  __asm { cpuid }
  if ( (_ECX & 0x80000) != 0 )
    return 4;
  if ( (_ECX & 0x200) != 0 )
    return 3;
  if ( (_EDX & 0x4000000) != 0 )
    return 2;
  return (_EDX >> 25) & 1;
}

//----- (00410AAB) --------------------------------------------------------
DWORD __stdcall sub_410AAB(HANDLE hHandle)
{
  DWORD result; // eax
  DWORD LastError; // eax

  result = WaitForSingleObject(hHandle, 0xFFFFFFFF);
  if ( result == -1 )
  {
    LastError = GetLastError();
    sub_40634C((int)&dword_432A6C, (wchar_t *)L"\nWaitForMultipleObjects error %d, GetLastError %d", -1, LastError);
    return sub_4062C3(2);
  }
  return result;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00410AE6) --------------------------------------------------------
int sub_410AE6()
{
  HANDLE CurrentProcess; // eax
  int result; // eax
  int v2; // ecx
  ULONG_PTR SystemAffinityMask; // [esp+0h] [ebp-8h] BYREF
  ULONG_PTR ProcessAffinityMask; // [esp+4h] [ebp-4h] BYREF

  CurrentProcess = GetCurrentProcess();
  if ( !GetProcessAffinityMask(CurrentProcess, &ProcessAffinityMask, &SystemAffinityMask) )
    return 1;
  result = 0;
  v2 = 1;
  do
  {
    if ( (v2 & ProcessAffinityMask) != 0 )
      ++result;
    v2 *= 2;
  }
  while ( v2 );
  if ( !result )
    return 1;
  return result;
}

//----- (00410B1D) --------------------------------------------------------
unsigned int sub_410B1D()
{
  unsigned int result; // eax

  result = sub_410AE6();
  if ( !result )
    return 1;
  if ( result > 0x20 )
    return 32;
  return result;
}

//----- (00410B34) --------------------------------------------------------
char *__thiscall sub_410B34(char *this, unsigned int a2)
{
  HANDLE EventW; // eax

  *(_DWORD *)this = a2;
  if ( a2 > 0x20 )
    *(_DWORD *)this = 32;
  if ( !*(_DWORD *)this )
    *(_DWORD *)this = 1;
  *((_DWORD *)this + 33) = 0;
  if ( *(_DWORD *)this > 0x20u )
    *(_DWORD *)this = 32;
  this[404] = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(this + 416));
  *((_DWORD *)this + 102) = CreateSemaphoreW(0, 0, 32, 0);
  EventW = CreateEventW(0, 1, 1, 0);
  *((_DWORD *)this + 103) = EventW;
  if ( !*((_DWORD *)this + 102) || !EventW )
  {
    sub_40634C((int)&dword_432A6C, (wchar_t *)L"\nThread pool initialization failed.");
    sub_4062C3(2);
  }
  *((_DWORD *)this + 99) = 0;
  *((_DWORD *)this + 100) = 0;
  *((_DWORD *)this + 34) = 0;
  return this;
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00410BD6) --------------------------------------------------------
char __thiscall sub_410BD6(int this, _DWORD *a2)
{
  int v4; // ecx

  sub_410AAB(*(HANDLE *)(this + 408));
  if ( *(_BYTE *)(this + 404) )
    return 0;
  EnterCriticalSection((LPCRITICAL_SECTION)(this + 416));
  v4 = *(_DWORD *)(this + 400);
  *a2 = *(_DWORD *)(this + 8 * v4 + 140);
  a2[1] = *(_DWORD *)(this + 8 * v4 + 144);
  *(_DWORD *)(this + 400) = ((unsigned __int8)*(_DWORD *)(this + 400) + 1) & 0x1F;
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 416));
  return 1;
}

//----- (00410C36) --------------------------------------------------------
int __thiscall sub_410C36(int this)
{
  LONG *v2; // ebx
  int result; // eax
  HANDLE *v4; // edi

  v2 = (LONG *)(this + 136);
  result = (*(_DWORD *)(this + 396) - *(_DWORD *)(this + 400)) & 0x1F;
  *(_DWORD *)(this + 136) = result;
  if ( result )
  {
    v4 = (HANDLE *)(this + 412);
    ResetEvent(*(HANDLE *)(this + 412));
    ReleaseSemaphore(*(HANDLE *)(this + 408), *v2, 0);
    return sub_410AAB(*v4);
  }
  return result;
}

//----- (00410C7D) --------------------------------------------------------
void *sub_410C7D()
{
  char *v1; // ecx
  char *v2; // eax

  EnterCriticalSection(&CriticalSection);
  if ( !dword_44EA48++ )
  {
    v1 = (char *)operator new(0x1B8u);
    v2 = 0;
    if ( v1 )
      v2 = sub_410B34(v1, 0x20u);
    dword_44EA44 = v2;
  }
  LeaveCriticalSection(&CriticalSection);
  return dword_44EA44;
}
// 44EA48: using guessed type int dword_44EA48;

//----- (00410CE2) --------------------------------------------------------
BOOL __thiscall sub_410CE2(int this)
{
  unsigned int v2; // ebx
  HANDLE *v3; // edi
  void *v5; // [esp-Ch] [ebp-18h]

  sub_410C36(this);
  v2 = 0;
  v5 = *(void **)(this + 408);
  *(_BYTE *)(this + 404) = 1;
  ReleaseSemaphore(v5, 32, 0);
  if ( *(_DWORD *)(this + 132) )
  {
    v3 = (HANDLE *)(this + 4);
    do
    {
      sub_410AAB(*v3);
      CloseHandle(*v3);
      ++v2;
      ++v3;
    }
    while ( v2 < *(_DWORD *)(this + 132) );
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 416));
  CloseHandle(*(HANDLE *)(this + 408));
  return CloseHandle(*(HANDLE *)(this + 412));
}

//----- (00410D4F) --------------------------------------------------------
char __thiscall sub_410D4F(int this)
{
  char result; // al
  int v4[2]; // [esp+4h] [ebp-8h] BYREF

  for ( result = sub_410BD6(this, v4); result; result = sub_410BD6(this, v4) )
  {
    ((void (__stdcall *)(int))v4[0])(v4[1]);
    EnterCriticalSection((LPCRITICAL_SECTION)(this + 416));
    if ( (*(_DWORD *)(this + 136))-- == 1 )
      SetEvent(*(HANDLE *)(this + 412));
    LeaveCriticalSection((LPCRITICAL_SECTION)(this + 416));
  }
  return result;
}

//----- (00410DA6) --------------------------------------------------------
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  sub_410D4F((int)lpThreadParameter);
  return 0;
}

//----- (00410DB4) --------------------------------------------------------
void __stdcall sub_410DB4(void *a1)
{
  void *v1; // esi

  EnterCriticalSection(&CriticalSection);
  if ( a1 )
  {
    if ( a1 == dword_44EA44 )
    {
      if ( dword_44EA48 )
      {
        if ( !--dword_44EA48 )
        {
          v1 = dword_44EA44;
          if ( dword_44EA44 )
          {
            sub_410CE2((int)dword_44EA44);
            operator delete(v1);
          }
        }
      }
    }
  }
  LeaveCriticalSection(&CriticalSection);
}
// 44EA48: using guessed type int dword_44EA48;

//----- (00410E04) --------------------------------------------------------
void __thiscall sub_410E04(HANDLE *lpParameter)
{
  unsigned int v2; // ebp
  HANDLE *v3; // edi
  HANDLE v4; // ebx
  DWORD ThreadId; // [esp+8h] [ebp-4h] BYREF

  v2 = 0;
  if ( *lpParameter )
  {
    v3 = lpParameter + 1;
    do
    {
      v4 = CreateThread(0, 0x10000u, StartAddress, lpParameter, 0, &ThreadId);
      if ( !v4 )
      {
        sub_40634C((int)&dword_432A6C, (wchar_t *)L"CreateThread failed");
        nullsub_2(&dword_432A6C);
        sub_4062C3(2);
      }
      *v3 = v4;
      lpParameter[33] = (char *)lpParameter[33] + 1;
      if ( nPriority )
        SetThreadPriority(*v3, nPriority);
      ++v2;
      ++v3;
    }
    while ( v2 < (unsigned int)*lpParameter );
  }
}
// 422FB3: using guessed type int __thiscall nullsub_2(_DWORD);
// 432A6C: using guessed type int dword_432A6C;

//----- (00410E83) --------------------------------------------------------
int __thiscall sub_410E83(int this, int a2, int a3)
{
  int result; // eax

  if ( !*(_DWORD *)(this + 132) )
    sub_410E04((HANDLE *)this);
  if ( (((unsigned __int8)*(_DWORD *)(this + 396) + 1) & 0x1F) == *(_DWORD *)(this + 400) )
    sub_410C36(this);
  *(_DWORD *)(this + 8 * *(_DWORD *)(this + 396) + 140) = a2;
  *(_DWORD *)(this + 8 * *(_DWORD *)(this + 396) + 144) = a3;
  result = ((unsigned __int8)*(_DWORD *)(this + 396) + 1) & 0x1F;
  *(_DWORD *)(this + 396) = result;
  return result;
}

//----- (00410EE3) --------------------------------------------------------
_DWORD *__thiscall sub_410EE3(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // ecx

  result = this;
  v3 = a2[1];
  *result = *a2;
  result[1] = v3;
  return result;
}

//----- (00410EF6) --------------------------------------------------------
int __thiscall sub_410EF6(int *this, _DWORD *a2)
{
  int result; // eax
  int v3; // ecx

  result = *this;
  v3 = this[1];
  *a2 = result;
  a2[1] = v3;
  return result;
}

//----- (00410F07) --------------------------------------------------------
_QWORD *__thiscall sub_410F07(_QWORD *this, __int64 a2)
{
  *this = 10000000 * (a2 + 0x2B6109100i64);
  return this;
}

//----- (00410F33) --------------------------------------------------------
int __thiscall sub_410F33(_DWORD *this, int a2, int a3)
{
  int result; // eax

  *this = a2;
  result = a3;
  this[1] = a3;
  return result;
}

//----- (00410F43) --------------------------------------------------------
DWORD __thiscall sub_410F43(DWORD *this)
{
  DWORD result; // eax
  DWORD dwHighDateTime; // ecx
  struct _SYSTEMTIME SystemTime; // [esp+4h] [ebp-18h] BYREF
  struct _FILETIME FileTime; // [esp+14h] [ebp-8h] BYREF

  GetSystemTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, &FileTime);
  result = FileTime.dwLowDateTime;
  dwHighDateTime = FileTime.dwHighDateTime;
  *this = FileTime.dwLowDateTime;
  this[1] = dwHighDateTime;
  return result;
}

//----- (00410F72) --------------------------------------------------------
BOOL __stdcall sub_410F72(int a1)
{
  return (a1 & 3) == 0 && (a1 % 100 || !(a1 % 400));
}

//----- (00410FA1) --------------------------------------------------------
DWORD __thiscall sub_410FA1(DWORD *this, int *a2)
{
  DWORD v2; // eax
  DWORD v3; // ecx
  __int64 v4; // rax
  int wDay; // eax
  int wYear; // edx
  unsigned int wMonth; // ecx
  int wDayOfWeek; // ebx
  unsigned int v10; // eax
  DWORD result; // eax
  struct _SYSTEMTIME LocalTime; // [esp+Ch] [ebp-50h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+1Ch] [ebp-40h] BYREF
  SYSTEMTIME v14; // [esp+2Ch] [ebp-30h] BYREF
  struct _FILETIME v15; // [esp+3Ch] [ebp-20h] BYREF
  struct _FILETIME v16; // [esp+44h] [ebp-18h] BYREF
  FILETIME FileTime; // [esp+4Ch] [ebp-10h] BYREF
  FILETIME v18; // [esp+54h] [ebp-8h] BYREF
  _DWORD *v19; // [esp+64h] [ebp+8h]

  v2 = *this;
  v3 = this[1];
  FileTime.dwLowDateTime = v2;
  FileTime.dwHighDateTime = v3;
  FileTimeToSystemTime(&FileTime, &SystemTime);
  SystemTimeToTzSpecificLocalTime(0, &SystemTime, &LocalTime);
  SystemTimeToFileTime(&LocalTime, &v18);
  SystemTimeToFileTime(&SystemTime, &v16);
  LODWORD(v4) = 0;
  HIDWORD(v4) = FileTime.dwHighDateTime + v18.dwHighDateTime - v16.dwHighDateTime;
  v18 = (FILETIME)(FileTime.dwLowDateTime + v18.dwLowDateTime + v4 - v16.dwLowDateTime);
  FileTimeToSystemTime(&v18, &v14);
  wDay = v14.wDay;
  wYear = v14.wYear;
  wMonth = v14.wMonth;
  a2[3] = v14.wHour;
  a2[4] = v14.wMinute;
  a2[5] = v14.wSecond;
  wDayOfWeek = v14.wDayOfWeek;
  a2[2] = wDay;
  *a2 = wYear;
  a2[1] = wMonth;
  a2[7] = wDayOfWeek;
  a2[8] = wDay - 1;
  v10 = 1;
  if ( wMonth > 1 )
  {
    v19 = &unk_42F130;
    do
    {
      if ( v10 > 0xC )
        break;
      a2[8] += *v19++;
      ++v10;
    }
    while ( v10 < wMonth );
  }
  if ( wMonth > 2 && sub_410F72(wYear) )
    ++a2[8];
  v14.wMilliseconds = 0;
  SystemTimeToFileTime(&v14, &v15);
  result = v18.dwHighDateTime;
  a2[6] = v18.dwLowDateTime - v15.dwLowDateTime;
  return result;
}

//----- (004110D5) --------------------------------------------------------
int __thiscall sub_4110D5(_DWORD *this, int a2)
{
  __int64 v3; // rax
  DWORD v4; // esi
  __int64 v5; // rax
  struct _SYSTEMTIME UniversalTime; // [esp+Ch] [ebp-48h] BYREF
  SYSTEMTIME LocalTime; // [esp+1Ch] [ebp-38h] BYREF
  SYSTEMTIME SystemTime; // [esp+2Ch] [ebp-28h] BYREF
  struct _FILETIME v10; // [esp+3Ch] [ebp-18h] BYREF
  struct _FILETIME v11; // [esp+44h] [ebp-10h] BYREF
  struct _FILETIME FileTime; // [esp+4Ch] [ebp-8h] BYREF

  SystemTime.wYear = *(_WORD *)a2;
  SystemTime.wMonth = *(_WORD *)(a2 + 4);
  SystemTime.wDay = *(_WORD *)(a2 + 8);
  SystemTime.wHour = *(_WORD *)(a2 + 12);
  SystemTime.wMinute = *(_WORD *)(a2 + 16);
  SystemTime.wSecond = *(_WORD *)(a2 + 20);
  SystemTime.wMilliseconds = 0;
  LODWORD(v3) = SystemTimeToFileTime(&SystemTime, &FileTime);
  if ( (_DWORD)v3 )
  {
    v4 = *(_DWORD *)(a2 + 24);
    FileTime.dwLowDateTime += v4;
    if ( FileTime.dwLowDateTime < v4 )
      ++FileTime.dwHighDateTime;
    FileTimeToSystemTime(&FileTime, &LocalTime);
    TzSpecificLocalTimeToSystemTime(0, &LocalTime, &UniversalTime);
    SystemTimeToFileTime(&UniversalTime, &v10);
    SystemTimeToFileTime(&LocalTime, &v11);
    LODWORD(v5) = 0;
    HIDWORD(v5) = FileTime.dwHighDateTime + v10.dwHighDateTime - v11.dwHighDateTime;
    v3 = FileTime.dwLowDateTime + v10.dwLowDateTime + v5 - v11.dwLowDateTime;
    *(_QWORD *)this = v3;
  }
  else
  {
    *this = 0;
    this[1] = 0;
  }
  return v3;
}

//----- (004111C2) --------------------------------------------------------
int __thiscall sub_4111C2(_DWORD *this, unsigned int a2)
{
  int v3[9]; // [esp+0h] [ebp-24h] BYREF

  v3[5] = 2 * (a2 & 0x1F);
  v3[4] = (a2 >> 5) & 0x3F;
  v3[6] = 0;
  v3[3] = (unsigned __int16)a2 >> 11;
  v3[2] = HIWORD(a2) & 0x1F;
  v3[0] = (a2 >> 25) + 1980;
  v3[1] = (a2 >> 21) & 0xF;
  return sub_4110D5(this, (int)v3);
}

//----- (0041121D) --------------------------------------------------------
INT_PTR __stdcall sub_41121D(LPARAM dwInitParam, int a2, __int64 a3, int a4, int a5)
{
  return sub_40E3FA(dwInitParam, a2, a3, a4, a5);
}

//----- (0041123B) --------------------------------------------------------
LRESULT __stdcall sub_41123B(char a1, wchar_t *String)
{
  return sub_40E0F7(4 * (a1 != 0) + 84, String);
}

//----- (0041125C) --------------------------------------------------------
LRESULT __stdcall sub_41125C(int a1, int a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7, int a8)
{
  return sub_40D238(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (00411280) --------------------------------------------------------
void __thiscall sub_411280(int *this)
{
  int v2; // eax
  WCHAR *v3; // eax
  WCHAR *v4; // eax
  WCHAR *v5; // eax
  WCHAR *v6; // eax
  WCHAR *v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp-8h] [ebp-Ch]
  int v13; // [esp-4h] [ebp-8h]
  int v14; // [esp-4h] [ebp-8h]
  int v15; // [esp-4h] [ebp-8h]

  v2 = this[18];
  if ( v2 > 106 )
    return;
  if ( v2 == 106 )
  {
    v4 = sub_40C05C(0x456u);
    goto LABEL_53;
  }
  if ( v2 <= 21 )
  {
    if ( v2 == 21 )
    {
      v14 = *this;
      v6 = sub_40C05C(0xDDu);
LABEL_20:
      sub_40DF70(0, v6, v14);
    }
    else
    {
      switch ( v2 )
      {
        case 0:
          sub_40DF70((int)L">", (wchar_t *)L"%ls", *this);
          break;
        case 1:
          sub_40DF70(0, (wchar_t *)L"%ls", *this);
          break;
        case 2:
          sub_40D0D1(0);
          break;
        case 3:
          v13 = this[1];
          v3 = sub_40C05C(0x7Bu);
          goto LABEL_11;
        case 4:
          v13 = this[1];
          v3 = sub_40C05C(0x7Au);
          goto LABEL_11;
        case 5:
          v13 = this[1];
          v3 = sub_40C05C(0x7Cu);
          goto LABEL_11;
        case 6:
          v4 = sub_40C05C(0xC9u);
          goto LABEL_53;
        case 7:
          v5 = sub_40C05C(0x70u);
          goto LABEL_16;
        case 8:
          v13 = this[1];
          v3 = sub_40C05C(0x72u);
          goto LABEL_11;
        case 9:
          v13 = this[1];
          v3 = sub_40C05C(0x78u);
          goto LABEL_11;
        case 10:
          v14 = *this;
          v6 = sub_40C05C(0x85u);
          goto LABEL_20;
        case 11:
          v14 = *this;
          v6 = sub_40C05C(0x204u);
          goto LABEL_20;
        case 12:
          v13 = this[1];
          v3 = sub_40C05C(0x84u);
          goto LABEL_11;
        case 13:
          v13 = this[1];
          v3 = sub_40C05C(0x83u);
          goto LABEL_11;
        case 17:
          v15 = this[2];
          v12 = this[1];
          v7 = sub_40C05C(0xD2u);
          sub_40DF70(*this, v7, v12, v15);
          break;
        case 19:
          v13 = this[1];
          v3 = sub_40C05C(0x79u);
          goto LABEL_11;
        case 20:
          v13 = this[1];
          v3 = sub_40C05C(0xDCu);
          goto LABEL_11;
        default:
          return;
      }
    }
    return;
  }
  if ( v2 > 55 )
  {
    v8 = v2 - 56;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( !v10 )
        {
          v13 = this[1];
          v3 = sub_40C05C(0x406u);
LABEL_11:
          sub_40DF70(*this, v3, v13);
          return;
        }
        v11 = v10 - 9;
        if ( v11 )
        {
          if ( v11 != 1 )
            return;
          v4 = sub_40C05C(0x86u);
        }
        else
        {
          v4 = sub_40C05C(0x343u);
        }
      }
      else
      {
        v4 = sub_40C05C(0x6Fu);
      }
    }
    else
    {
      v4 = sub_40C05C(0x8Cu);
    }
LABEL_53:
    sub_40DF70(*this, v4);
    return;
  }
  if ( v2 == 55 )
  {
    v4 = sub_40C05C(0x67u);
    goto LABEL_53;
  }
  switch ( v2 )
  {
    case 22:
      v5 = sub_40C05C(0xE1u);
LABEL_16:
      sub_40DF70(0, v5);
      break;
    case 23:
      v4 = sub_40C05C(0xB4u);
      goto LABEL_53;
    case 24:
      v4 = sub_40C05C(0x69u);
      goto LABEL_53;
    case 25:
      v4 = sub_40C05C(0x6Au);
      goto LABEL_53;
    case 26:
      v13 = this[1];
      v3 = sub_40C05C(0x68u);
      goto LABEL_11;
    case 27:
      v4 = sub_40C05C(0x46Fu);
      goto LABEL_53;
    case 28:
      v4 = sub_40C05C(0x470u);
      goto LABEL_53;
    case 29:
      v13 = this[1];
      v3 = sub_40C05C(0x471u);
      goto LABEL_11;
    case 31:
      v13 = this[1];
      v3 = sub_40C05C(0x71u);
      goto LABEL_11;
    case 32:
      v13 = this[1];
      v3 = sub_40C05C(0xC8u);
      goto LABEL_11;
    default:
      return;
  }
}
// 42AD90: using guessed type wchar_t asc_42AD90[2];

//----- (004114D8) --------------------------------------------------------
char __stdcall sub_4114D8(int a1, wchar_t *Source, _BYTE *a3)
{
  return sub_40DE9F(a1, 0, Source, a3);
}

//----- (004114EE) --------------------------------------------------------
char sub_4114EE()
{
  return byte_440CEA;
}
// 440CEA: using guessed type char byte_440CEA;

//----- (004114FE) --------------------------------------------------------
INT_PTR __stdcall sub_4114FE(int a1, wchar_t *Source, int a3, __int64 a4, int a5, int a6)
{
  int v6; // eax
  INT_PTR result; // eax
  wchar_t String[2048]; // [esp+8h] [ebp-1000h] BYREF

  v6 = *(_DWORD *)(a1 + 20780);
  if ( v6 == 2 )
    return 1;
  if ( *(_BYTE *)(a1 + 20860) || v6 == 1 )
    return 0;
  sub_41078F(String, Source, 2048);
  result = sub_41121D((LPARAM)String, 2048, a4, a5, a6);
  switch ( result )
  {
    case 2:
      *(_DWORD *)(a1 + 20780) = 1;
      return 0;
    case 3:
      *(_DWORD *)(a1 + 20780) = 2;
      return 1;
    case 4:
      if ( sub_40A0CE(String) == String )
        sub_40A238(Source, String, a3);
      else
        sub_41078F(Source, String, a3);
      if ( sub_409026(Source) )
        return sub_4114FE(a1, Source, a3, a4, SHIDWORD(a4), a5, a6);
      return 0;
  }
  return result;
}

//----- (004115D5) --------------------------------------------------------
bool __stdcall sub_4115D5(int a1, int a2)
{
  WCHAR *v2; // eax
  DWORD LastError; // esi
  WCHAR *v4; // eax
  bool v5; // bl
  WCHAR Text[2304]; // [esp+8h] [ebp-1200h] BYREF

  v2 = sub_40C05C(0x83u);
  swprintf(Text, 0x900u, v2, a1);
  LastError = GetLastError();
  v4 = sub_40C05C(0x96u);
  v5 = MessageBoxW(hWnd, Text, v4, 0x35u) == 4;
  SetLastError(LastError);
  return v5;
}

//----- (00411643) --------------------------------------------------------
bool __stdcall sub_411643(LPCWCH lpWideCharStr, LPSTR lpMultiByteStr, int cbMultiByte)
{
  bool v4; // [esp+Fh] [ebp-1h]

  *lpMultiByteStr = 0;
  v4 = WideCharToMultiByte(0, 0, lpWideCharStr, -1, lpMultiByteStr, cbMultiByte, 0, 0) != 0;
  if ( cbMultiByte )
    lpMultiByteStr[cbMultiByte - 1] = 0;
  return v4;
}

//----- (00411682) --------------------------------------------------------
bool __stdcall sub_411682(LPCCH lpMultiByteStr, LPWSTR lpWideCharStr, int cchWideChar)
{
  bool v3; // bl

  *lpWideCharStr = 0;
  v3 = MultiByteToWideChar(0, 0, lpMultiByteStr, -1, lpWideCharStr, cchWideChar) != 0;
  if ( cchWideChar )
    lpWideCharStr[cchWideChar - 1] = 0;
  return v3;
}

//----- (004116BD) --------------------------------------------------------
int __stdcall sub_4116BD(_BYTE *a1, int a2, unsigned int a3)
{
  int result; // eax
  unsigned int i; // esi

  result = a2;
  for ( i = 0; i < a3; a1 += 2 )
  {
    *(_BYTE *)(a2 + 2 * i) = *a1;
    *(_BYTE *)(a2 + 2 * i + 1) = a1[1];
    if ( !*(_WORD *)a1 )
      break;
    ++i;
  }
  return result;
}

//----- (004116ED) --------------------------------------------------------
int __stdcall sub_4116ED(unsigned __int8 *a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi
  unsigned __int8 *v4; // ecx
  __int16 v5; // ax
  __int16 v6; // di

  v3 = 0;
  if ( a3 )
  {
    v4 = a1;
    do
    {
      v5 = v4[1] << 8;
      v6 = *v4;
      *(_WORD *)&v4[a2 - (_DWORD)a1] = v6 + v5;
      if ( !(v6 + v5) )
        break;
      ++v3;
      v4 += 2;
    }
    while ( v3 < a3 );
  }
  return a2;
}

//----- (0041172D) --------------------------------------------------------
unsigned int __stdcall sub_41172D(unsigned __int16 *a1, _BYTE *a2, int a3)
{
  unsigned __int16 *v4; // esi
  unsigned int result; // eax
  char v6; // dl
  unsigned __int16 v7; // dx
  char v8; // dl
  int v9; // [esp+1Ch] [ebp+10h]

  v4 = a1;
  v9 = a3 - 1;
  for ( result = *a1; (_WORD)result; result = *v4 )
  {
    if ( --v9 < 0 )
      break;
    result = (unsigned __int16)result;
    ++v4;
    if ( (unsigned __int16)result >= 0x80u )
    {
      if ( (unsigned __int16)result >= 0x800u || (--v9, v9 < 0) )
      {
        if ( (unsigned int)(unsigned __int16)result - 55296 <= 0x3FF )
        {
          v7 = *v4;
          if ( *v4 >= 0xDC00u && v7 <= 0xDFFFu )
          {
            result = v7 + (((unsigned __int16)result - 55287) << 10);
            ++v4;
          }
        }
        if ( result >= 0x10000 || (v9 -= 2, v9 < 0) )
        {
          if ( result >= 0x200000 )
            continue;
          v9 -= 3;
          if ( v9 < 0 )
            continue;
          *a2++ = (result >> 18) | 0xF0;
          v8 = (result >> 12) & 0x3F | 0x80;
        }
        else
        {
          v8 = (result >> 12) | 0xE0;
        }
        *a2++ = v8;
        v6 = (result >> 6) & 0x3F | 0x80;
      }
      else
      {
        v6 = ((unsigned __int16)result >> 6) | 0xC0;
      }
      *a2++ = v6;
      LOBYTE(result) = result & 0x3F | 0x80;
    }
    *a2++ = result;
  }
  *a2 = 0;
  return result;
}

//----- (00411817) --------------------------------------------------------
char __stdcall sub_411817(_BYTE *a1, _WORD *a2, int a3)
{
  _BYTE *v3; // esi
  unsigned int v4; // ecx
  _WORD *v5; // eax
  char v7; // [esp+7h] [ebp-1h]
  int v8; // [esp+18h] [ebp+10h]

  v3 = a1;
  LOBYTE(v4) = *a1;
  v7 = 1;
  v8 = a3 - 1;
  while ( *v3 )
  {
    ++v3;
    if ( (unsigned __int8)v4 >= 0x80u )
    {
      if ( (v4 & 0xE0) == 192 )
      {
        if ( (*v3 & 0xC0) != 0x80 )
          goto LABEL_29;
        v4 = ((v4 & 0x1F) << 6) | *v3++ & 0x3F;
      }
      else if ( (v4 & 0xF0) == 224 )
      {
        if ( (*v3 & 0xC0) != 0x80 || (v3[1] & 0xC0) != 0x80 )
          goto LABEL_29;
        v4 = v3[1] & 0x3F | ((((v4 & 0xF) << 6) | *v3 & 0x3F) << 6);
        v3 += 2;
      }
      else
      {
        if ( (v4 & 0xF8) != 240 || (*v3 & 0xC0) != 0x80 || (v3[1] & 0xC0) != 0x80 || (v3[2] & 0xC0) != 0x80 )
        {
LABEL_29:
          v7 = 0;
          break;
        }
        v4 = v3[2] & 0x3F | ((v3[1] & 0x3F | ((((v4 & 7) << 6) | *v3 & 0x3F) << 6)) << 6);
        v3 += 3;
      }
    }
    else
    {
      v4 = (unsigned __int8)v4;
    }
    v5 = a2;
    if ( a2 )
    {
      if ( --v8 < 0 )
        break;
    }
    if ( v4 <= 0xFFFF )
    {
      if ( a2 )
        goto LABEL_26;
    }
    else
    {
      if ( a2 )
      {
        if ( --v8 < 0 )
          break;
      }
      if ( v4 <= 0x10FFFF )
      {
        if ( a2 )
        {
          *a2 = ((v4 - 0x10000) >> 10) - 10240;
          v5 = a2 + 1;
          LOWORD(v4) = (v4 & 0x3FF) - 9216;
LABEL_26:
          *v5 = v4;
          a2 = v5 + 1;
        }
      }
      else
      {
        v7 = 0;
      }
    }
    LOBYTE(v4) = *v3;
  }
  if ( a2 )
    *a2 = 0;
  return v7;
}

//----- (004119A6) --------------------------------------------------------
int __stdcall sub_4119A6(PCNZWCH lpString1, PCNZWCH lpString2)
{
  return CompareStringW(0x400u, 0x1001u, lpString1, -1, lpString2, -1) - 2;
}

//----- (004119C7) --------------------------------------------------------
int __stdcall sub_4119C7(PCNZWCH lpString1, PCNZWCH lpString2, unsigned int a3)
{
  int v3; // esi
  int v4; // eax

  if ( wcslen(lpString1) + 1 >= a3 )
    v3 = a3;
  else
    v3 = wcslen(lpString1) + 1;
  if ( wcslen(lpString2) + 1 >= a3 )
    v4 = a3;
  else
    v4 = wcslen(lpString2) + 1;
  return CompareStringW(0x400u, 0x1001u, lpString1, v3, lpString2, v4) - 2;
}

//----- (00411A29) --------------------------------------------------------
int __stdcall sub_411A29(wint_t C)
{
  return towupper(C);
}

//----- (00411A39) --------------------------------------------------------
unsigned int __stdcall sub_411A39(_WORD *a1)
{
  _WORD *v1; // esi
  unsigned __int16 v2; // ax
  unsigned int v3; // ecx
  unsigned int i; // edi
  unsigned __int64 v5; // kr00_8

  v1 = a1;
  v2 = *a1;
  v3 = 0;
  for ( i = 0; *v1 >= 0x30u; v3 = v5 )
  {
    if ( v2 > 0x39u )
      break;
    v5 = 10 * __PAIR64__(i, v3) + v2 - 48;
    v2 = *++v1;
    i = HIDWORD(v5);
  }
  return v3;
}

//----- (00411A88) --------------------------------------------------------
bool __thiscall sub_411A88(_BYTE *this)
{
  unsigned int v1; // esi
  bool result; // al
  struct _cpinfo CPInfo; // [esp+8h] [ebp-14h] BYREF

  v1 = 0;
  GetCPInfo(0, &CPInfo);
  this[256] = CPInfo.MaxCharSize > 1;
  do
  {
    result = IsDBCSLeadByte(v1);
    this[v1++] = result;
  }
  while ( v1 < 0x100 );
  return result;
}

//----- (00411ACD) --------------------------------------------------------
unsigned __int8 *__thiscall sub_411ACD(unsigned __int8 *this, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // eax
  _DWORD *v6; // edx
  int v7; // esi
  int v8; // esi
  unsigned __int8 *v9; // edi
  int v10; // esi
  unsigned __int8 *result; // eax

  v4 = this[a4 + 4];
  v5 = this[a3 + 4] - v4;
  v6 = (_DWORD *)(a2 + 12 * v4);
  v7 = this[v5 + 41];
  if ( this[v7 + 4] != v5 )
  {
    v8 = v7 - 1;
    v9 = &this[4 * v8 + 184];
    *v6 = *(_DWORD *)v9;
    *(_DWORD *)v9 = v6;
    v10 = this[v8 + 4];
    v6 += 3 * v10;
    v5 -= v10;
  }
  result = &this[4 * this[v5 + 41] + 184];
  *v6 = *(_DWORD *)result;
  *(_DWORD *)result = v6;
  return result;
}

//----- (00411B2D) --------------------------------------------------------
void __thiscall sub_411B2D(_DWORD *this)
{
  void *v1; // [esp-4h] [ebp-4h]

  if ( *this )
  {
    v1 = (void *)this[43];
    *this = 0;
    free(v1);
  }
}

//----- (00411B42) --------------------------------------------------------
char __thiscall sub_411B42(unsigned int *this, int a2)
{
  unsigned int v3; // ebx
  char *v5; // eax

  v3 = a2 << 20;
  if ( *this == a2 << 20 )
    return 1;
  sub_411B2D(this);
  v5 = (char *)malloc(12 * (v3 / 0xC + 2));
  this[43] = (unsigned int)v5;
  if ( v5 )
  {
    this[86] = (unsigned int)&v5[12 * (v3 / 0xC) + 12];
    *this = v3;
    return 1;
  }
  else
  {
    sub_4062F7(&dword_432A6C);
    return 0;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00411B9E) --------------------------------------------------------
_BYTE *__thiscall sub_411B9E(char *this)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  _BYTE *result; // eax
  unsigned int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+Ch] [ebp-8h]

  memset(this + 184, 0, 0x98u);
  v2 = *(_DWORD *)this;
  v3 = *(_DWORD *)this / 8 / 0xCu;
  v4 = *((_DWORD *)this + 43);
  *((_DWORD *)this + 84) = v4;
  v14 = v2 - 84 * v3;
  v5 = 12 * (v14 / 0xC + 1) + v4;
  *((_DWORD *)this + 87) = v14 + v4;
  v6 = 4;
  *((_DWORD *)this + 85) = v5;
  *((_DWORD *)this + 44) = v5;
  v7 = 4;
  *((_DWORD *)this + 45) = v5 + 12 * (84 * v3 / 0xC);
  v8 = 1;
  do
  {
    this[v8 + 3] = v8;
    ++v8;
    --v6;
  }
  while ( v6 );
  v9 = v8 + 1;
  do
  {
    this[v7++ + 4] = v9;
    v9 += 2;
  }
  while ( v7 < 8 );
  v10 = v9 + 1;
  while ( v7 < 12 )
  {
    this[v7++ + 4] = v10;
    v10 += 3;
  }
  v11 = v10 + 1;
  while ( v7 < 38 )
  {
    this[v7++ + 4] = v11;
    v11 += 4;
  }
  v12 = 0;
  this[170] = 0;
  result = this + 42;
  v15 = 128;
  do
  {
    v12 += (unsigned __int8)this[v12 + 4] < (int)&result[-41 - (_DWORD)this];
    *result++ = v12;
    --v15;
  }
  while ( v15 );
  return result;
}

//----- (00411CB5) --------------------------------------------------------
void __thiscall sub_411CB5(void *this)
{
  *(_DWORD *)this = &off_42B18C;
  sub_41D17D(this);
}
// 42B18C: using guessed type int (__thiscall *off_42B18C)(void *, char);

//----- (00411CC0) --------------------------------------------------------
_DWORD *__thiscall sub_411CC0(_DWORD *this, char a2)
{
  *this = &off_42B18C;
  sub_41D17D(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 42B18C: using guessed type int (__thiscall *off_42B18C)(void *, char);

//----- (00411CE2) --------------------------------------------------------
_DWORD *__thiscall sub_411CE2(unsigned __int8 *this, _DWORD *Src, int a3, int a4)
{
  int v5; // ebx
  int v6; // edx
  unsigned __int8 *v8; // ecx
  _DWORD *v9; // edi
  unsigned __int8 *v10; // eax

  v5 = this[a3 + 41];
  v6 = this[a4 + 41];
  if ( v5 == v6 )
    return Src;
  v8 = &this[4 * v6 + 184];
  v9 = *(_DWORD **)v8;
  if ( *(_DWORD *)v8 )
  {
    *(_DWORD *)v8 = *v9;
    memcpy(v9, Src, 12 * a4);
    v10 = &this[4 * v5 + 184];
    *Src = *(_DWORD *)v10;
    *(_DWORD *)v10 = Src;
    return v9;
  }
  else
  {
    sub_411ACD(this, (int)Src, v5, v6);
    return Src;
  }
}

//----- (00411D52) --------------------------------------------------------
int __thiscall sub_411D52(int this, int a2)
{
  unsigned __int8 v3; // al
  unsigned __int8 *v4; // edi
  int v5; // ecx
  _WORD *v6; // ecx
  unsigned int v7; // ebx
  int result; // eax
  unsigned int v9; // eax
  char v10; // cl

  v3 = *(_BYTE *)(**(unsigned __int8 **)(a2 + 1616) + a2 + 2412);
  *(_BYTE *)(a2 + 2670) = v3;
  v4 = (unsigned __int8 *)(this + 2);
  v5 = *(unsigned __int8 *)(a2 + 2669)
     + ((*(int *)(a2 + 1636) >> 26) & 0x20)
     + *(unsigned __int8 *)(**(unsigned __int16 **)(this + 8) + a2 + 2155)
     + 2 * (32 * *(unsigned __int8 *)(this + 3) + *(unsigned __int8 *)(*(unsigned __int8 *)(this + 2) + a2 + 2412))
     + 1272;
  *(_DWORD *)(a2 + 19064) >>= 14;
  v6 = (_WORD *)(a2 + 2 * (v3 + v5));
  v7 = (unsigned __int16)*v6;
  if ( (unsigned int)(*(_DWORD *)(a2 + 19060) - *(_DWORD *)(a2 + 19056)) / *(_DWORD *)(a2 + 19064) >= v7 )
  {
    *(_DWORD *)(a2 + 19068) = v7;
    *v6 -= ((unsigned __int16)*v6 + 32) >> 7;
    *(_DWORD *)(a2 + 19072) = 0x4000;
    v9 = (unsigned __int16)*v6;
    v10 = *(_BYTE *)(a2 + 2668);
    *(_DWORD *)(a2 + 1624) = (unsigned __int8)byte_42AD9C[v9 >> 10];
    *(_DWORD *)(a2 + 1620) = 1;
    result = *v4;
    *(_BYTE *)(result + a2 + 1644) = v10;
    *(_DWORD *)(a2 + 1616) = 0;
    *(_BYTE *)(a2 + 2669) = 0;
  }
  else
  {
    *(_DWORD *)(a2 + 1616) = v4;
    v4[1] += v4[1] < 0x80u;
    *(_DWORD *)(a2 + 19068) = 0;
    *(_DWORD *)(a2 + 19072) = (unsigned __int16)*v6;
    result = (unsigned __int16)*v6 - (((unsigned __int16)*v6 + 32) >> 7) + 128;
    *v6 = result;
    ++*(_DWORD *)(a2 + 1636);
    *(_BYTE *)(a2 + 2669) = 1;
  }
  return result;
}

//----- (00411E81) --------------------------------------------------------
void *__thiscall sub_411E81(_BYTE *this)
{
  this[2668] = 1;
  return memset(this + 1644, 0, 0x100u);
}

//----- (00411E9F) --------------------------------------------------------
bool __thiscall sub_411E9F(int this)
{
  signed int v2; // ecx
  int v3; // eax
  signed int v4; // edi
  int v6; // eax
  bool v7; // zf
  int v8; // ecx

  v2 = *(_DWORD *)(this + 120);
  v3 = *(_DWORD *)(this + 4);
  v4 = v2 - v3;
  if ( v2 - v3 < 0 )
    return 0;
  if ( v3 <= 0x4000 )
  {
    v4 = v2;
  }
  else
  {
    if ( v4 > 0 )
      memcpy_0(*(void **)(this + 16), (const void *)(*(_DWORD *)(this + 16) + v3), v4);
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)(this + 120) = v4;
  }
  v6 = sub_40B60F(*(char **)this, (__m128i *)(v4 + *(_DWORD *)(this + 16)), 0x8000 - v4);
  if ( v6 > 0 )
    *(_DWORD *)(this + 120) += v6;
  v7 = *(_BYTE *)(this + 19513) == 0;
  v8 = *(_DWORD *)(this + 120);
  *(_DWORD *)(this + 124) = v8 - 30;
  if ( !v7 )
    *(_DWORD *)(this + 124) = v8 - 500;
  return v6 != -1;
}

//----- (00411F1D) --------------------------------------------------------
bool __thiscall sub_411F1D(int this)
{
  signed int v2; // ecx
  int v3; // eax
  signed int v4; // edi
  int v6; // eax
  bool v7; // zf
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // ecx

  v2 = *(_DWORD *)(this + 120);
  v3 = *(_DWORD *)(this + 4);
  v4 = v2 - v3;
  if ( v2 - v3 < 0 )
    return 0;
  *(_DWORD *)(this + 128) += *(_DWORD *)(this + 136) - v3;
  if ( v3 <= 0x4000 )
  {
    v4 = v2;
  }
  else
  {
    if ( v4 > 0 )
      memcpy_0(*(void **)(this + 16), (const void *)(*(_DWORD *)(this + 16) + v3), v4);
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)(this + 120) = v4;
  }
  v6 = 0;
  if ( v4 != 0x8000 )
  {
    v6 = sub_40B60F(*(char **)this, (__m128i *)(v4 + *(_DWORD *)(this + 16)), 0x8000 - v4);
    if ( v6 > 0 )
      *(_DWORD *)(this + 120) += v6;
  }
  v7 = *(_BYTE *)(this + 19513) == 0;
  v8 = *(_DWORD *)(this + 120);
  *(_DWORD *)(this + 124) = v8 - 30;
  if ( !v7 )
    *(_DWORD *)(this + 124) = v8 - 500;
  v9 = *(_DWORD *)(this + 128);
  v10 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 136) = v10;
  if ( v9 != -1 )
  {
    v11 = v9 + v10 - 1;
    if ( *(_DWORD *)(this + 124) < v11 )
      v11 = *(_DWORD *)(this + 124);
    *(_DWORD *)(this + 124) = v11;
  }
  return v6 != -1;
}

//----- (00411FD6) --------------------------------------------------------
unsigned int __thiscall sub_411FD6(int *this, char *Src, size_t Size)
{
  int v4; // edx
  unsigned int result; // eax
  int v6; // ecx
  int v7; // edi
  size_t v8; // ebx
  bool v9; // cf

  v4 = this[4885];
  result = this[4881];
  v6 = this[4880];
  v7 = this[4884];
  if ( __SPAIR64__(v4, v7) < __SPAIR64__(result, v6) )
  {
    v8 = Size;
    if ( Size > (__int64)(__PAIR64__(result, v6) - __PAIR64__(v4, v7)) )
      v8 = v6 - v7;
    sub_40B7BF(*this, Src, v8);
    result = Size;
    v9 = __CFADD__(Size, this[4884]);
    this[4884] += Size;
    this[4885] += v9;
  }
  return result;
}

//----- (00412035) --------------------------------------------------------
char *__thiscall sub_412035(char *this)
{
  memset(this, 0, 0x80u);
  memset(this + 128, 0, 0x80u);
  return this;
}

//----- (0041205E) --------------------------------------------------------
void __thiscall sub_41205E(void **this)
{
  unsigned int i; // esi

  for ( i = 0; i < 0x20; ++i )
  {
    if ( this[i] )
    {
      free(this[i]);
      this[i] = 0;
    }
  }
}

//----- (0041207F) --------------------------------------------------------
void __thiscall sub_41207F(void **this, unsigned int a2)
{
  unsigned int v2; // edi
  size_t v3; // esi
  void *v4; // eax
  void *v5; // ebx
  int v6; // eax
  int v7; // ecx
  char pExceptionObject[12]; // [esp+4h] [ebp-18h] BYREF
  void **v9; // [esp+10h] [ebp-Ch]
  unsigned int v10; // [esp+14h] [ebp-8h]
  unsigned int v11; // [esp+18h] [ebp-4h]

  v9 = this;
  sub_41205E(this);
  v2 = 0;
  v11 = 0;
  if ( a2 )
  {
    while ( v11 < 0x20 )
    {
      v3 = a2 - v2;
      v10 = (a2 - v2) / (32 - v11);
      if ( v10 <= 0x400000 )
        v10 = 0x400000;
      while ( 1 )
      {
        if ( v3 < v10 )
          goto LABEL_8;
        v4 = malloc(v3);
        v5 = v4;
        if ( v4 )
          break;
        v3 -= v3 >> 5;
      }
      memset(v4, 0, v3);
      v6 = (int)v9;
      v7 = v11;
      v2 += v3;
      ++v11;
      v9[v7] = v5;
      *(_DWORD *)(v7 * 4 + v6 + 128) = v2;
      if ( v2 >= a2 )
        return;
    }
    if ( v2 < a2 )
    {
LABEL_8:
      std::bad_alloc::bad_alloc((std::bad_alloc *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
}

//----- (0041212C) --------------------------------------------------------
std::exception *__thiscall sub_41212C(std::exception *this, struct std::exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &off_42B18C;
  return this;
}
// 42B18C: using guessed type int (__thiscall *off_42B18C)(void *, char);

//----- (00412144) --------------------------------------------------------
int __thiscall sub_412144(int *this, unsigned int a2)
{
  int v2; // eax
  int v4; // edx
  unsigned int *i; // eax

  if ( a2 >= this[32] )
  {
    v4 = 1;
    for ( i = (unsigned int *)(this + 33); a2 >= *i; ++i )
    {
      if ( (unsigned int)++v4 >= 0x20 )
        return *this;
    }
    v2 = this[v4] - this[v4 + 31];
  }
  else
  {
    v2 = *this;
  }
  return a2 + v2;
}

//----- (0041217C) --------------------------------------------------------
void __thiscall sub_41217C(int *this, int a2, int a3, unsigned int *a4, int a5)
{
  int i; // edi
  _BYTE *v6; // ebx
  int *v7; // ecx

  for ( i = *a4 - a3; a2; *a4 = a5 & (*a4 + 1) )
  {
    --a2;
    v6 = (_BYTE *)sub_412144(this, a5 & i);
    *(_BYTE *)sub_412144(v7, *a4) = *v6;
    ++i;
  }
}
// 412199: variable 'this' is possibly undefined
// 4121A2: variable 'v7' is possibly undefined

//----- (004121C1) --------------------------------------------------------
void __thiscall sub_4121C1(int *this, _BYTE *a2, int a3, int a4)
{
  int v4; // ebx
  _BYTE *v5; // esi

  v4 = a4;
  if ( a4 )
  {
    v5 = a2;
    do
    {
      *v5 = *(_BYTE *)sub_412144(this, (unsigned int)&v5[a3 - (_DWORD)a2]);
      ++v5;
      --v4;
    }
    while ( v4 );
  }
}
// 4121DA: variable 'this' is possibly undefined

//----- (004121ED) --------------------------------------------------------
unsigned int __thiscall sub_4121ED(unsigned int *this, unsigned int a2, unsigned int a3)
{
  int v3; // eax
  unsigned int *i; // edx
  unsigned int result; // eax

  v3 = 0;
  for ( i = this + 32; a2 >= *i; ++i )
  {
    if ( (unsigned int)++v3 >= 0x20 )
      return 0;
  }
  result = this[v3 + 32] - a2;
  if ( result >= a3 )
    return a3;
  return result;
}

//----- (00412222) --------------------------------------------------------
void __thiscall sub_412222(int this, size_t Size, char a3)
{
  size_t v3; // ebx
  unsigned int i; // ecx
  unsigned int v6; // eax
  size_t v7; // edx
  char pExceptionObject[12]; // [esp+8h] [ebp-10h] BYREF
  void *v9; // [esp+14h] [ebp-4h]
  char v10; // [esp+27h] [ebp+Fh]

  v3 = Size;
  if ( !Size )
    sub_4062F7(&dword_432A6C);
  if ( Size < 0x40000 )
  {
    v3 = 0x40000;
    Size = 0x40000;
  }
  if ( v3 > *(_DWORD *)(this + 59124) )
  {
    if ( a3 && (*(_DWORD *)(this + 19252) || *(_BYTE *)(this + 19512)) )
    {
      v10 = 1;
      if ( *(_BYTE *)(this + 19512) )
        goto LABEL_10;
    }
    else
    {
      v10 = 0;
    }
    if ( *(_BYTE *)(this + 19512) )
    {
      v9 = 0;
    }
    else
    {
      v9 = malloc(v3);
      if ( v9 )
      {
LABEL_20:
        if ( !*(_BYTE *)(this + 19512) )
        {
          memset(v9, 0, v3);
          if ( v10 )
          {
            for ( i = 1;
                  i < *(_DWORD *)(this + 59124);
                  *((_BYTE *)v9 + (v6 & v7)) = *(_BYTE *)((v6 & (*(_DWORD *)(this + 59124) - 1))
                                                        + *(_DWORD *)(this + 19252)) )
            {
              v6 = *(_DWORD *)(this + 112) - i;
              v7 = v3 - 1;
              v3 = Size;
              ++i;
            }
          }
          if ( *(_DWORD *)(this + 19252) )
            free(*(void **)(this + 19252));
          *(_DWORD *)(this + 19252) = v9;
        }
        *(_DWORD *)(this + 59124) = v3;
        *(_DWORD *)(this + 59128) = v3 - 1;
        return;
      }
    }
    if ( v10 || v3 < 0x1000000 )
    {
LABEL_10:
      std::bad_alloc::bad_alloc((std::bad_alloc *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    if ( *(_DWORD *)(this + 19252) )
    {
      free(*(void **)(this + 19252));
      *(_DWORD *)(this + 19252) = 0;
    }
    sub_41207F((void **)(this + 19256), v3);
    *(_BYTE *)(this + 19512) = 1;
    goto LABEL_20;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0041237D) --------------------------------------------------------
char __stdcall sub_41237D(int a1, unsigned int *a2, unsigned int a3)
{
  unsigned int i; // ecx
  int *v5; // eax
  int v6; // eax
  _DWORD *v7; // edx
  int v8; // eax
  int v9; // edi
  int v10; // ecx
  unsigned int v11; // eax
  unsigned int j; // edx
  int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // ebx
  unsigned int v16; // edi
  unsigned int v17; // eax
  unsigned int *k; // ecx
  _WORD *v19; // ecx
  int v21[16]; // [esp+Ch] [ebp-80h] BYREF
  int v22[16]; // [esp+4Ch] [ebp-40h] BYREF
  _WORD *v23; // [esp+94h] [ebp+8h]
  unsigned int v24; // [esp+98h] [ebp+Ch]

  *a2 = a3;
  memset(v22, 0, sizeof(v22));
  for ( i = 0; i < a3; ++i )
  {
    v5 = &v22[*(_BYTE *)(i + a1) & 0xF];
    ++*v5;
  }
  v22[0] = 0;
  memset(a2 + 802, 0, 2 * a3);
  a2[17] = 0;
  a2[1] = 0;
  v6 = 0;
  v24 = 1;
  v7 = a2 + 17;
  do
  {
    v8 = v22[v24] + v6;
    v9 = v8 << (16 - v24);
    v10 = *v7 + v21[v24 + 15];
    v6 = 2 * v8;
    ++v24;
    *(v7 - 15) = v9;
    v7[1] = v10;
    ++v7;
  }
  while ( v24 < 0x10 );
  LOBYTE(v11) = (unsigned __int8)memcpy(v21, a2 + 17, sizeof(v21));
  for ( j = 0; j < a3; ++j )
  {
    LOBYTE(v11) = *(_BYTE *)(j + a1) & 0xF;
    if ( (_BYTE)v11 )
    {
      v11 = (unsigned int)&v21[(unsigned __int8)v11];
      v13 = *(_DWORD *)v11;
      *((_WORD *)a2 + v13 + 1604) = j;
      *(_DWORD *)v11 = v13 + 1;
    }
  }
  if ( a3 >= 0x12A && (a3 <= 0x12B || a3 == 306) )
    a2[33] = 10;
  else
    a2[33] = 7;
  v14 = 1;
  v15 = 1 << a2[33];
  v16 = 0;
  if ( v15 )
  {
    v23 = a2 + 290;
    do
    {
      v17 = v16 << (16 - *((_BYTE *)a2 + 132));
      for ( k = &a2[v14 + 1]; v17 >= *k && v14 < 0x10; ++k )
        ++v14;
      *((_BYTE *)a2 + v16 + 136) = v14;
      v19 = v23;
      v11 = a2[v14 + 17] + ((v17 - a2[v14]) >> (16 - v14));
      if ( v11 >= a3 )
        LOWORD(v11) = 0;
      else
        LOWORD(v11) = *((_WORD *)a2 + v11 + 1604);
      ++v23;
      ++v16;
      *v19 = v11;
    }
    while ( v16 < v15 );
  }
  return v11;
}
// 41237D: using guessed type int var_40[16];

//----- (004124F5) --------------------------------------------------------
void __stdcall sub_4124F5(int *a1, int *a2)
{
  int v2; // [esp+8h] [ebp-8h]
  __int16 v3; // [esp+Ch] [ebp-4h]

  v2 = *a1;
  v3 = *((_WORD *)a1 + 2);
  *a1 = *a2;
  *((_WORD *)a1 + 2) = *((_WORD *)a2 + 2);
  *a2 = v2;
  *((_WORD *)a2 + 2) = v3;
}

//----- (0041251D) --------------------------------------------------------
void __thiscall sub_41251D(int this, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // edi
  int v6; // ecx
  void *v7; // ebx

  *(_DWORD *)(this + 4) += a2;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 > *(_DWORD *)(this + 8) )
  {
    v4 = *(_DWORD *)(this + 12);
    if ( v4 && v3 > v4 )
    {
      sub_40634C((int)&dword_432A6C, (wchar_t *)L"Maximum allowed array size (%u) is exceeded", v4);
      sub_4062F7(&dword_432A6C);
    }
    v5 = *(_DWORD *)(this + 4);
    v6 = *(_DWORD *)(this + 8) >> 2;
    if ( v5 <= v6 + *(_DWORD *)(this + 8) + 32 )
      v5 = v6 + *(_DWORD *)(this + 8) + 32;
    v7 = realloc(*(void **)this, 4 * v5);
    if ( !v7 )
      sub_4062F7(&dword_432A6C);
    *(_DWORD *)(this + 8) = v5;
    *(_DWORD *)this = v7;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (00412595) --------------------------------------------------------
void __thiscall sub_412595(int this)
{
  if ( *(_DWORD *)this )
  {
    free(*(void **)this);
    *(_DWORD *)this = 0;
  }
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
}

//----- (004125B2) --------------------------------------------------------
void __thiscall sub_4125B2(int this, int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // ebx
  void *v6; // edi

  *(_DWORD *)(this + 4) += a2;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 > *(_DWORD *)(this + 8) )
  {
    v4 = *(_DWORD *)(this + 12);
    if ( v4 && v3 > v4 )
    {
      sub_40634C((int)&dword_432A6C, (wchar_t *)L"Maximum allowed array size (%u) is exceeded", v4);
      sub_4062F7(&dword_432A6C);
    }
    v5 = *(_DWORD *)(this + 4);
    if ( v5 <= (*(_DWORD *)(this + 8) >> 2) + *(_DWORD *)(this + 8) + 32 )
      v5 = (*(_DWORD *)(this + 8) >> 2) + *(_DWORD *)(this + 8) + 32;
    v6 = realloc(*(void **)this, 16 * v5);
    if ( !v6 )
      sub_4062F7(&dword_432A6C);
    *(_DWORD *)this = v6;
    *(_DWORD *)(this + 8) = v5;
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0041262C) --------------------------------------------------------
int __thiscall sub_41262C(_DWORD *this)
{
  unsigned __int8 *v1; // edx

  v1 = (unsigned __int8 *)(this[3] + *this);
  return (v1[4] >> (8 - this[1])) | ((v1[3] | ((v1[2] | ((v1[1] | (*v1 << 8)) << 8)) << 8)) << this[1]);
}

//----- (00412669) --------------------------------------------------------
int __thiscall sub_412669(unsigned __int16 *this)
{
  int v1; // edx

  v1 = *this >> *((_BYTE *)this + 2);
  *this -= v1;
  return v1 + (v1 == 0);
}

//----- (00412687) --------------------------------------------------------
_BYTE *__thiscall sub_412687(_BYTE *this)
{
  _BYTE *result; // eax
  unsigned __int8 v2; // cl

  result = this;
  v2 = this[2];
  if ( v2 < 7u && result[3]-- == 1 )
  {
    *(_WORD *)result *= 2;
    result[2] = v2 + 1;
    result[3] = 3 << v2;
  }
  return result;
}

//----- (004126A6) --------------------------------------------------------
void __thiscall sub_4126A6(_DWORD *this)
{
  sub_40948D((int)(this + 1), 0);
  this[4789] = 0;
}

//----- (004126BE) --------------------------------------------------------
void __thiscall sub_4126BE(void **this)
{
  if ( this[4789] )
    free(this[4789]);
  sub_4094C3((int)(this + 1));
}

//----- (004126DB) --------------------------------------------------------
int __thiscall sub_4126DB(int *this)
{
  int v2; // ecx
  int result; // eax

  if ( this[1] > 32738 )
    sub_411F1D((int)this);
  v2 = this[1];
  result = *(unsigned __int8 *)(this[4] + v2);
  this[1] = v2 + 1;
  return result;
}

//----- (004126FC) --------------------------------------------------------
int __thiscall sub_4126FC(void *this, int a2)
{
  int v3; // edi
  int result; // eax

  *((_DWORD *)this + 1) = 0;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 2) = -1;
  *((_DWORD *)this + 6) = a2;
  v3 = 4;
  do
  {
    result = sub_4126DB(*((int **)this + 6));
    --v3;
    *((_DWORD *)this + 1) = result | (*((_DWORD *)this + 1) << 8);
  }
  while ( v3 );
  return result;
}

//----- (00412730) --------------------------------------------------------
char *__thiscall sub_412730(_DWORD *this)
{
  _BYTE *v1; // eax
  unsigned __int8 *v2; // edi
  char **v3; // edx
  char *v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  _DWORD *v15; // edx
  _DWORD *v16; // eax
  int *v17; // eax
  char *result; // eax
  char v19; // [esp+0h] [ebp-10h] BYREF
  char *v20; // [esp+4h] [ebp-Ch]
  char *v21; // [esp+8h] [ebp-8h]
  int v22; // [esp+Ch] [ebp-4h]

  v1 = (_BYTE *)this[44];
  if ( v1 != (_BYTE *)this[45] )
    *v1 = 0;
  v21 = &v19;
  v20 = &v19;
  v2 = (unsigned __int8 *)(this + 1);
  v3 = (char **)(this + 46);
  v22 = 38;
  do
  {
    while ( *v3 )
    {
      v4 = *v3;
      *v3 = *(char **)*v3;
      *((_DWORD *)v4 + 2) = &v19;
      *((_DWORD *)v4 + 1) = v20;
      *((_DWORD *)v20 + 2) = v4;
      v20 = v4;
      *(_WORD *)v4 = -1;
      *((_WORD *)v4 + 1) = *v2;
    }
    ++v3;
    ++v2;
    --v22;
  }
  while ( v22 );
  v5 = (int)v20;
  if ( v20 == &v19 )
    goto LABEL_21;
  do
  {
    while ( 1 )
    {
      v6 = v5 + 12 * *(unsigned __int16 *)(v5 + 2);
      if ( *(_WORD *)v6 != 0xFFFF || *(unsigned __int16 *)(v5 + 2) + *(unsigned __int16 *)(v6 + 2) >= 0x10000 )
        break;
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(*(_DWORD *)(v6 + 4) + 8) = *(_DWORD *)(v6 + 8);
      *(_WORD *)(v5 + 2) += *(_WORD *)(v6 + 2);
    }
    v5 = *(_DWORD *)(v5 + 4);
  }
  while ( (char *)v5 != &v19 );
  while ( 1 )
  {
    v5 = (int)v20;
LABEL_21:
    result = &v19;
    v12 = v5;
    if ( (char *)v5 == &v19 )
      break;
    v7 = v5 + 4;
    v8 = *(_DWORD *)(v5 + 4);
    v9 = v5 + 8;
    *(_DWORD *)(*(_DWORD *)v9 + 4) = v8;
    *(_DWORD *)(*(_DWORD *)v7 + 8) = *(_DWORD *)v9;
    v10 = *(unsigned __int16 *)(v12 + 2);
    if ( v10 > 0x80 )
    {
      v11 = ((v10 - 129) >> 7) + 1;
      v10 += -128 * v11;
      do
      {
        *(_DWORD *)v12 = this[83];
        this[83] = v12;
        v12 += 1536;
        --v11;
      }
      while ( v11 );
    }
    v13 = *((unsigned __int8 *)this + v10 + 41);
    if ( *((unsigned __int8 *)this + v13 + 4) != v10 )
    {
      v14 = *((unsigned __int8 *)this + v13-- + 3);
      v15 = &this[v10 - v14 + 45];
      v16 = (_DWORD *)(v12 + 12 * v14);
      *v16 = *v15;
      *v15 = v16;
    }
    v17 = &this[v13 + 46];
    *(_DWORD *)v12 = *v17;
    *v17 = v12;
  }
  return result;
}

//----- (00412890) --------------------------------------------------------
_DWORD *__thiscall sub_412890(int this, int a2)
{
  _DWORD *v3; // ecx
  _DWORD *result; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  int *v7; // eax
  _DWORD *v8; // ebx
  int v9; // eax
  int v10; // [esp-10h] [ebp-18h]

  if ( *(_BYTE *)(this + 170)
    || (*(_BYTE *)(this + 170) = -1,
        sub_412730((_DWORD *)this),
        v3 = (_DWORD *)(this + 4 * a2 + 184),
        (result = (_DWORD *)*v3) == 0) )
  {
    v5 = a2;
    v6 = (_DWORD *)(this + 4 * a2 + 184);
    while ( 1 )
    {
      ++v5;
      ++v6;
      if ( v5 == 38 )
        break;
      if ( *v6 )
      {
        v7 = (int *)(this + 4 * v5 + 184);
        v8 = (_DWORD *)*v7;
        v10 = *v7;
        *v7 = *(_DWORD *)*v7;
        sub_411ACD((unsigned __int8 *)this, v10, v5, a2);
        return v8;
      }
    }
    --*(_BYTE *)(this + 170);
    v9 = 12 * *(unsigned __int8 *)(a2 + this + 4);
    if ( *(_DWORD *)(this + 348) - *(_DWORD *)(this + 336) <= v9 )
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(this + 348) -= v9;
      *(_DWORD *)(this + 340) -= v9;
      return *(_DWORD **)(this + 340);
    }
  }
  else
  {
    *v3 = *result;
  }
  return result;
}

//----- (0041292D) --------------------------------------------------------
_DWORD *__thiscall sub_41292D(_DWORD *this, int a2)
{
  int v2; // esi
  _DWORD **v3; // edx
  _DWORD *result; // eax
  _DWORD *v5; // edx

  v2 = *((unsigned __int8 *)this + a2 + 41);
  v3 = (_DWORD **)&this[v2 + 46];
  result = *v3;
  if ( *v3 )
  {
    *v3 = (_DWORD *)*result;
  }
  else
  {
    result = (_DWORD *)this[44];
    v5 = &result[3 * *((unsigned __int8 *)this + v2 + 4)];
    this[44] = v5;
    if ( (unsigned int)v5 > this[45] )
    {
      this[44] = &v5[-3 * *((unsigned __int8 *)this + v2 + 4)];
      return sub_412890((int)this, v2);
    }
  }
  return result;
}

//----- (00412982) --------------------------------------------------------
_DWORD *__thiscall sub_412982(_DWORD *this)
{
  int v1; // eax
  _DWORD *result; // eax
  _DWORD **v3; // edx

  v1 = this[45];
  if ( v1 == this[44] )
  {
    v3 = (_DWORD **)(this + 46);
    if ( this[46] )
    {
      result = *v3;
      *v3 = (_DWORD *)**v3;
    }
    else
    {
      return sub_412890((int)this, 0);
    }
  }
  else
  {
    result = (_DWORD *)(v1 - 12);
    this[45] = result;
  }
  return result;
}

//----- (004129B2) --------------------------------------------------------
_DWORD *__thiscall sub_4129B2(_DWORD *this, _DWORD *Src, int a3)
{
  int v5; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v9; // [esp+18h] [ebp+Ch]

  v5 = *((unsigned __int8 *)this + a3 + 41);
  if ( v5 == *((unsigned __int8 *)this + a3 + 42) )
    return Src;
  v7 = sub_41292D(this, a3 + 1);
  v9 = (int)v7;
  if ( v7 )
  {
    memcpy(v7, Src, 12 * a3);
    v8 = &this[v5 + 46];
    *Src = *v8;
    *v8 = Src;
  }
  return (_DWORD *)v9;
}

//----- (00412A08) --------------------------------------------------------
_DWORD *__thiscall sub_412A08(void *this, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = sub_412982((_DWORD *)(a2 + 19084));
  if ( result )
  {
    *(_WORD *)result = 1;
    *(_DWORD *)((char *)result + 2) = *(_DWORD *)a4;
    *((_WORD *)result + 3) = *(_WORD *)(a4 + 4);
    result[2] = this;
    *(_DWORD *)(a3 + 2) = result;
  }
  return result;
}

//----- (00412A40) --------------------------------------------------------
_DWORD *__thiscall sub_412A40(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  this[4771] = 0;
  this[401] = 0;
  this[403] = 0;
  this[402] = 0;
  return result;
}

//----- (00412A5D) --------------------------------------------------------
int __thiscall sub_412A5D(int this)
{
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // ecx
  int i; // eax
  unsigned __int16 *v6; // ecx
  _WORD *v7; // eax
  bool v8; // zf
  int v9; // edx
  _BYTE *v10; // ecx
  int result; // eax
  int v12; // esi
  int v13; // [esp+Ch] [ebp-14h]
  _WORD *v14; // [esp+10h] [ebp-10h]
  _WORD *v15; // [esp+14h] [ebp-Ch]
  _WORD *v16; // [esp+18h] [ebp-8h]
  int v17; // [esp+1Ch] [ebp-4h]

  memset((void *)(this + 1644), 0, 0x100u);
  sub_411B9E((char *)(this + 19084));
  v2 = *(_DWORD *)(this + 1632);
  if ( v2 >= 12 )
    v2 = 12;
  *(_DWORD *)(this + 1640) = -1 - v2;
  v3 = sub_412982((_DWORD *)(this + 19084));
  *(_DWORD *)(this + 1612) = v3;
  *(_DWORD *)(this + 1604) = v3;
  v3[2] = 0;
  *(_DWORD *)(this + 1628) = *(_DWORD *)(this + 1632);
  **(_WORD **)(this + 1604) = 256;
  *(_WORD *)(*(_DWORD *)(this + 1604) + 2) = 257;
  *(_DWORD *)(*(_DWORD *)(this + 1604) + 4) = sub_41292D((_DWORD *)(this + 19084), 128);
  *(_DWORD *)(this + 1616) = *(_DWORD *)(*(_DWORD *)(this + 1604) + 4);
  v4 = 0;
  *(_DWORD *)(this + 1636) = *(_DWORD *)(this + 1640);
  *(_BYTE *)(this + 2669) = 0;
  for ( i = 0; i < 1536; i += 6 )
  {
    *(_BYTE *)(i + *(_DWORD *)(*(_DWORD *)(this + 1604) + 4)) = v4;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(this + 1604) + 4) + i + 1) = 1;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 1604) + 4) + i + 2) = 0;
    ++v4;
  }
  v17 = 0;
  v14 = (_WORD *)(this + 2672);
  do
  {
    v6 = (unsigned __int16 *)&unk_42ADAC;
    v15 = v14;
    do
    {
      v16 = v15;
      v13 = 8;
      do
      {
        v7 = v16;
        v16 += 8;
        v8 = v13-- == 1;
        *v7 = 0x4000 - *v6 / (v17 + 2);
      }
      while ( !v8 );
      ++v15;
      ++v6;
    }
    while ( (int)v6 < (int)&off_42ADBC );
    ++v17;
    v14 += 64;
  }
  while ( v17 < 128 );
  v9 = 0;
  v10 = (_BYTE *)(this + 3);
  do
  {
    result = 40 * (v9 + 2);
    v12 = 16;
    do
    {
      *(v10 - 1) = 3;
      *(_WORD *)(v10 - 3) = result;
      *v10 = 4;
      v10 += 4;
      --v12;
    }
    while ( v12 );
    ++v9;
  }
  while ( v9 < 25 );
  return result;
}
// 42ADBC: using guessed type int (__stdcall *off_42ADBC)(int, int, int);

//----- (00412BD8) --------------------------------------------------------
void *__thiscall sub_412BD8(int this, int a2)
{
  int v3; // ebx
  int i; // eax
  char v5; // dl
  int v6; // edi
  void *result; // eax

  v3 = 1;
  *(_BYTE *)(this + 2668) = 1;
  *(_DWORD *)(this + 1632) = a2;
  sub_412A5D(this);
  *(_BYTE *)(this + 2156) = 0;
  *(_BYTE *)(this + 2157) = 2;
  memset((void *)(this + 2158), 4, 9u);
  memset((void *)(this + 2167), 6, 0xF5u);
  for ( i = 0; i < 3; ++i )
    *(_BYTE *)(this + i + 1900) = i;
  v5 = i;
  v6 = 1;
  while ( i < 256 )
  {
    --v6;
    *(_BYTE *)(this + i + 1900) = v5;
    if ( !v6 )
    {
      v6 = ++v3;
      ++v5;
    }
    ++i;
  }
  memset((void *)(this + 2412), 0, 0x40u);
  result = memset((void *)(this + 2476), 8, 0xC0u);
  *(_BYTE *)(this + 1602) = 7;
  return result;
}

//----- (00412C89) --------------------------------------------------------
int *__thiscall sub_412C89(unsigned __int16 *this, int a2)
{
  int i; // eax
  int v4; // esi
  _WORD *v5; // ecx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  _WORD *v10; // edi
  _WORD *v11; // esi
  _BYTE *v12; // eax
  int v13; // eax
  int *result; // eax
  int v15; // [esp+Ch] [ebp-20h]
  __int16 v16; // [esp+10h] [ebp-1Ch]
  int v17; // [esp+14h] [ebp-18h]
  BOOL v18; // [esp+18h] [ebp-14h]
  int *v19; // [esp+18h] [ebp-14h]
  int v20; // [esp+1Ch] [ebp-10h]
  unsigned __int16 v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]
  int v23; // [esp+28h] [ebp-4h]

  v17 = *this;
  v23 = v17 - 1;
  for ( i = *(_DWORD *)(a2 + 1616); i != *((_DWORD *)this + 1); i = v4 )
  {
    v4 = i - 6;
    sub_4124F5((int *)i, (int *)(i - 6));
  }
  *(_BYTE *)(*((_DWORD *)this + 1) + 1) += 4;
  v5 = this + 1;
  this[1] += 4;
  v22 = this[1] - *(unsigned __int8 *)(i + 1);
  v18 = *(_DWORD *)(a2 + 1628) != 0;
  v6 = (v18 + *(unsigned __int8 *)(i + 1)) >> 1;
  *(_BYTE *)(i + 1) = v6;
  this[1] = (unsigned __int8)v6;
  do
  {
    v7 = *(unsigned __int8 *)(i + 7);
    v22 -= v7;
    i += 6;
    v8 = (v18 + v7) >> 1;
    *(_BYTE *)(i + 1) = v8;
    *v5 += (unsigned __int8)v8;
    if ( *(_BYTE *)(i + 1) > *(_BYTE *)(i - 5) )
    {
      v15 = *(_DWORD *)i;
      v9 = i;
      v16 = *(_WORD *)(i + 4);
      do
      {
        *(_DWORD *)v9 = *(_DWORD *)(v9 - 6);
        v11 = (_WORD *)(v9 - 6 + 4);
        v10 = (_WORD *)(v9 + 4);
        v9 -= 6;
        *v10 = *v11;
      }
      while ( v9 != *((_DWORD *)this + 1) && BYTE1(v15) > *(_BYTE *)(v9 - 5) );
      *(_DWORD *)v9 = v15;
      *(_WORD *)(v9 + 4) = v16;
    }
    --v23;
  }
  while ( v23 );
  v12 = (_BYTE *)(i + 1);
  if ( *v12 )
  {
    v13 = v22;
  }
  else
  {
    do
    {
      ++v23;
      v12 -= 6;
    }
    while ( !*v12 );
    *this -= v23;
    v13 = v23 + v22;
    if ( *this == 1 )
    {
      v19 = (int *)*((_DWORD *)this + 1);
      v20 = *v19;
      v21 = *((_WORD *)v19 + 2);
      do
      {
        v13 >>= 1;
        BYTE1(v20) -= BYTE1(v20) >> 1;
      }
      while ( v13 > 1 );
      result = (int *)(a2 + 4 * *(unsigned __int8 *)(((v17 + 1) >> 1) + a2 + 19125) + 19268);
      *v19 = *result;
      *result = (int)v19;
      *(_DWORD *)(a2 + 1616) = v5;
      *(_DWORD *)v5 = v20;
      this[3] = v21;
      return result;
    }
  }
  *v5 += v13 - (v13 >> 1);
  if ( (v17 + 1) >> 1 != (*this + 1) >> 1 )
    *((_DWORD *)this + 1) = sub_411CE2(
                              (unsigned __int8 *)(a2 + 19084),
                              *((_DWORD **)this + 1),
                              (v17 + 1) >> 1,
                              (*this + 1) >> 1);
  result = (int *)*((_DWORD *)this + 1);
  *(_DWORD *)(a2 + 1616) = result;
  return result;
}

//----- (00412E18) --------------------------------------------------------
_DWORD *__thiscall sub_412E18(_DWORD *this, char a2, char *a3)
{
  int v4; // eax
  _DWORD *v5; // ecx
  char *v6; // esi
  int *v7; // edi
  bool v8; // zf
  char *i; // eax
  char v10; // dl
  unsigned __int16 v11; // si
  _BYTE *j; // eax
  unsigned int v14; // eax
  unsigned int v15; // edx
  char v16; // al
  int v17; // [esp+Ch] [ebp-108h] BYREF
  char v18; // [esp+10h] [ebp-104h] BYREF
  char v19[2]; // [esp+10Ch] [ebp-8h] BYREF
  _BYTE *v20; // [esp+10Eh] [ebp-6h]

  v4 = this[404];
  v5 = (_DWORD *)this[401];
  v6 = *(char **)(v4 + 2);
  v7 = &v17;
  if ( !a2 )
  {
    v8 = v5[2] == 0;
    v17 = v4;
    v7 = (int *)&v18;
    if ( v8 )
      goto LABEL_16;
  }
  i = a3;
  if ( !a3 )
    goto LABEL_5;
  v5 = (_DWORD *)v5[2];
  while ( *(char **)(i + 2) == v6 )
  {
    *v7++ = (int)i;
    if ( !v5[2] )
      goto LABEL_15;
LABEL_5:
    v5 = (_DWORD *)v5[2];
    if ( *(_WORD *)v5 == 1 )
    {
      i = (char *)v5 + 2;
    }
    else
    {
      for ( i = (char *)v5[1]; *i != *(_BYTE *)this[404]; i += 6 )
        ;
    }
  }
  v5 = *(_DWORD **)(i + 2);
LABEL_15:
  if ( v7 != &v17 )
  {
LABEL_16:
    v10 = *v6;
    v20 = v6 + 1;
    v11 = *(_WORD *)v5;
    v19[0] = v10;
    if ( v11 == 1 )
    {
      v16 = *((_BYTE *)v5 + 3);
    }
    else
    {
      if ( (unsigned int)v5 <= this[4855] )
        return 0;
      for ( j = (_BYTE *)v5[1]; *j != v10; j += 6 )
        ;
      v14 = (unsigned __int8)j[1] - 1;
      v15 = *((unsigned __int16 *)v5 + 1) - v11 - v14;
      if ( 2 * v14 > v15 )
        v14 = (3 * v15 + 2 * v14 - 1) / (2 * v15);
      else
        LOBYTE(v14) = v15 < 5 * v14;
      v16 = v14 + 1;
    }
    v19[1] = v16;
    while ( 1 )
    {
      v5 = sub_412A08(v5, (int)this, *--v7, (int)v19);
      if ( !v5 )
        break;
      if ( v7 == &v17 )
        return v5;
    }
    return 0;
  }
  return v5;
}

//----- (00412F32) --------------------------------------------------------
int __thiscall sub_412F32(int this)
{
  int v2; // esi
  char v3; // cl
  int v4; // esi
  int v5; // edi
  unsigned __int8 v6; // al
  int result; // eax
  unsigned int v8; // eax
  unsigned __int16 *v10; // eax
  unsigned __int16 *v11; // esi
  int v12; // edi
  unsigned int v13; // eax
  _DWORD *v14; // eax
  unsigned __int16 *v15; // ecx
  __int16 v16; // dx
  unsigned __int16 v17; // ax
  _DWORD *v18; // eax
  unsigned __int16 *v19; // esi
  unsigned __int8 v20; // dl
  unsigned __int16 v21; // ax
  unsigned int v22; // edx
  unsigned int v23; // eax
  unsigned __int16 v24; // ax
  int v25; // eax
  _BYTE v26[6]; // [esp+Ch] [ebp-20h]
  unsigned int v27; // [esp+18h] [ebp-14h]
  int v28; // [esp+1Ch] [ebp-10h]
  unsigned int v29; // [esp+20h] [ebp-Ch]
  unsigned __int16 *v30; // [esp+24h] [ebp-8h]
  unsigned int v31; // [esp+28h] [ebp-4h]

  v2 = *(_DWORD *)(this + 1616);
  *(_DWORD *)v26 = *(_DWORD *)v2;
  *(_WORD *)&v26[4] = *(_WORD *)(v2 + 4);
  v3 = *(_DWORD *)v2;
  v4 = 0;
  if ( v26[1] < 0x1Fu )
  {
    v5 = *(_DWORD *)(*(_DWORD *)(this + 1604) + 8);
    if ( v5 )
    {
      if ( *(_WORD *)v5 == 1 )
      {
        v4 = v5 + 2;
        *(_BYTE *)(v5 + 3) += *(_BYTE *)(v5 + 3) < 0x20u;
      }
      else
      {
        v4 = *(_DWORD *)(v5 + 4);
        if ( *(_BYTE *)v4 != v26[0] )
        {
          do
            v4 += 6;
          while ( *(_BYTE *)v4 != v26[0] );
          if ( *(_BYTE *)(v4 + 1) >= *(_BYTE *)(v4 - 5) )
          {
            sub_4124F5((int *)v4, (int *)(v4 - 6));
            v4 -= 6;
          }
        }
        v6 = *(_BYTE *)(v4 + 1);
        v3 = v26[0];
        if ( v6 < 0x73u )
        {
          *(_BYTE *)(v4 + 1) = v6 + 2;
          *(_WORD *)(v5 + 2) += 2;
        }
      }
    }
  }
  if ( *(_DWORD *)(this + 1628) )
  {
    *(_BYTE *)(*(_DWORD *)(this + 19420))++ = v3;
    v8 = *(_DWORD *)(this + 19420);
    v27 = v8;
    if ( v8 >= *(_DWORD *)(this + 19432) )
      goto LABEL_13;
    if ( *(_DWORD *)&v26[2] )
    {
      if ( *(_DWORD *)&v26[2] <= v8 )
      {
        *(_DWORD *)&v26[2] = sub_412E18((_DWORD *)this, 0, (char *)v4);
        if ( !*(_DWORD *)&v26[2] )
          goto LABEL_13;
      }
      if ( (*(_DWORD *)(this + 1628))-- == 1 )
      {
        v27 = *(_DWORD *)&v26[2];
        *(_DWORD *)(this + 19420) -= *(_DWORD *)(this + 1612) != *(_DWORD *)(this + 1604);
      }
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(this + 1616) + 2) = v8;
      *(_DWORD *)&v26[2] = *(_DWORD *)(this + 1604);
    }
    v10 = *(unsigned __int16 **)(this + 1604);
    v29 = *v10;
    v11 = *(unsigned __int16 **)(this + 1612);
    v12 = v10[1] - v26[1] - v29 + 1;
    v28 = v12;
    v30 = v11;
    if ( v11 != v10 )
    {
      while ( 1 )
      {
        v13 = *v11;
        v31 = v13;
        if ( v13 == 1 )
        {
          v18 = sub_41292D((_DWORD *)(this + 19084), 1);
          if ( !v18 )
            goto LABEL_13;
          v15 = v11 + 1;
          v19 = v11 + 1;
          *v18 = *(_DWORD *)v19;
          *((_WORD *)v18 + 2) = v19[2];
          *((_DWORD *)v30 + 1) = v18;
          v20 = *((_BYTE *)v18 + 1);
          *((_BYTE *)v18 + 1) = v20 >= 0x1Eu ? 120 : 2 * v20;
          v17 = *((unsigned __int8 *)v18 + 1);
          v12 = v28;
          v11 = v30;
          v16 = *(_WORD *)(this + 1624) + (v29 > 3);
        }
        else
        {
          if ( (v13 & 1) == 0 )
          {
            v14 = sub_4129B2((_DWORD *)(this + 19084), *((_DWORD **)v11 + 1), v13 >> 1);
            *((_DWORD *)v11 + 1) = v14;
            if ( !v14 )
              goto LABEL_13;
            v13 = v31;
          }
          v15 = v11 + 1;
          v16 = (2 * v31 < v29) + 2 * (v29 >= 4 * v31 && 8 * v13 >= v11[1]);
          v17 = v11[1];
        }
        v21 = v17 + v16;
        *v15 = v21;
        v22 = v12 + v21;
        v23 = 2 * v26[1] * (v21 + 6);
        if ( v23 >= 6 * v22 )
        {
          LOWORD(v22) = (v23 >= 12 * v22) + (v23 >= 15 * v22) + (v23 >= 9 * v22) + 4;
          v24 = v22 + *v15;
        }
        else
        {
          LOBYTE(v22) = (v23 >= 4 * v22) + (v22 < v23) + 1;
          v24 = *v15 + 3;
        }
        *v15 = v24;
        v25 = *((_DWORD *)v11 + 1) + 6 * v31;
        *(_DWORD *)(v25 + 2) = v27;
        *(_BYTE *)v25 = v26[0];
        *(_BYTE *)(v25 + 1) = v22;
        *v11 = v31 + 1;
        v30 = (unsigned __int16 *)*((_DWORD *)v11 + 2);
        if ( v30 == *(unsigned __int16 **)(this + 1604) )
          break;
        v11 = (unsigned __int16 *)*((_DWORD *)v11 + 2);
        v12 = v28;
      }
    }
    result = *(_DWORD *)&v26[2];
    *(_DWORD *)(this + 1604) = *(_DWORD *)&v26[2];
    *(_DWORD *)(this + 1612) = *(_DWORD *)&v26[2];
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 1616) + 2) = sub_412E18((_DWORD *)this, 1, (char *)v4);
    result = *(_DWORD *)(*(_DWORD *)(this + 1616) + 2);
    *(_DWORD *)(this + 1612) = result;
    *(_DWORD *)(this + 1604) = result;
    if ( !result )
    {
LABEL_13:
      result = sub_412A5D(this);
      *(_BYTE *)(this + 2668) = 0;
    }
  }
  return result;
}

//----- (00413210) --------------------------------------------------------
void __thiscall sub_413210(unsigned __int16 *this, int a2, int a3)
{
  *(_DWORD *)(a2 + 1616) = a3;
  *(_BYTE *)(a3 + 1) += 4;
  this[1] += 4;
  if ( *(_BYTE *)(a3 + 1) > *(_BYTE *)(a3 - 5) )
  {
    sub_4124F5((int *)a3, (int *)(a3 - 6));
    *(_DWORD *)(a2 + 1616) = a3 - 6;
    if ( *(_BYTE *)(a3 - 6 + 1) > 0x7Cu )
      sub_412C89(this, a2);
  }
}

//----- (00413258) --------------------------------------------------------
char __thiscall sub_413258(unsigned __int16 *this, int a2)
{
  unsigned __int8 *v3; // edi
  unsigned int v4; // eax
  signed int v6; // edx
  bool v7; // al
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  unsigned int v13; // [esp+14h] [ebp+8h]
  signed int v14; // [esp+14h] [ebp+8h]

  *(_DWORD *)(a2 + 19076) = this[1];
  v3 = (unsigned __int8 *)*((_DWORD *)this + 1);
  v13 = *(_DWORD *)(a2 + 19064) / *(_DWORD *)(a2 + 19076);
  *(_DWORD *)(a2 + 19064) = v13;
  v14 = (*(_DWORD *)(a2 + 19060) - *(_DWORD *)(a2 + 19056)) / v13;
  v4 = *(_DWORD *)(a2 + 19076);
  if ( v14 >= (int)v4 )
    return 0;
  v6 = v3[1];
  if ( v14 >= v6 )
  {
    if ( !*(_DWORD *)(a2 + 1616) )
      return 0;
    *(_BYTE *)(a2 + 2669) = 0;
    v9 = *this - 1;
    do
    {
      v10 = v3[7];
      v3 += 6;
      v6 += v10;
      if ( v6 > v14 )
      {
        *(_DWORD *)(a2 + 19072) = v6;
        *(_DWORD *)(a2 + 19068) = v6 - v3[1];
        sub_413210(this, a2, (int)v3);
        return 1;
      }
      --v9;
    }
    while ( v9 );
    *(_BYTE *)(a2 + 2670) = *(_BYTE *)(**(unsigned __int8 **)(a2 + 1616) + a2 + 2412);
    *(_DWORD *)(a2 + 19068) = v6;
    *(_BYTE *)(*v3 + a2 + 1644) = *(_BYTE *)(a2 + 2668);
    v11 = *this;
    *(_DWORD *)(a2 + 1620) = v11;
    v12 = v11 - 1;
    *(_DWORD *)(a2 + 1616) = 0;
    do
    {
      v3 -= 6;
      --v12;
      *(_BYTE *)(*v3 + a2 + 1644) = *(_BYTE *)(a2 + 2668);
    }
    while ( v12 );
    *(_DWORD *)(a2 + 19072) = *(_DWORD *)(a2 + 19076);
  }
  else
  {
    v7 = 2 * v6 > v4;
    *(_BYTE *)(a2 + 2669) = v7;
    *(_DWORD *)(a2 + 19072) = v6;
    *(_DWORD *)(a2 + 1636) += v7;
    v8 = v6 + 4;
    *(_DWORD *)(a2 + 1616) = v3;
    v3[1] = v8;
    this[1] += 4;
    if ( v8 > 124 )
      sub_412C89(this, a2);
    *(_DWORD *)(a2 + 19068) = 0;
  }
  return 1;
}

//----- (00413396) --------------------------------------------------------
int __thiscall sub_413396(unsigned __int16 *this, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)(a2 + 1616) = a3;
  *(_BYTE *)(a3 + 1) += 4;
  this[1] += 4;
  if ( *(_BYTE *)(a3 + 1) > 0x7Cu )
    sub_412C89(this, a2);
  result = *(_DWORD *)(a2 + 1640);
  ++*(_BYTE *)(a2 + 2668);
  *(_DWORD *)(a2 + 1636) = result;
  return result;
}

//----- (004133D0) --------------------------------------------------------
unsigned __int16 *__thiscall sub_4133D0(unsigned __int16 *this, int a2, int a3)
{
  unsigned __int16 *v3; // edi

  if ( *this == 256 )
  {
    v3 = (unsigned __int16 *)(a2 + 1600);
    *(_DWORD *)(a2 + 19076) = 1;
  }
  else
  {
    v3 = (unsigned __int16 *)(a2
                            + 4
                            * (*(unsigned __int8 *)(a2 + 2670)
                             + (a3 < **((unsigned __int16 **)this + 2) - *this)
                             + 2
                             * ((this[1] < 11 * *this)
                              + 2 * ((*(_DWORD *)(a2 + 1620) > a3) + 4 * *(unsigned __int8 *)(a2 + a3 + 1899)))));
    *(_DWORD *)(a2 + 19076) = sub_412669(v3);
  }
  return v3;
}

//----- (00413462) --------------------------------------------------------
char __thiscall sub_413462(unsigned __int16 *this, int a2)
{
  int v4; // edi
  unsigned __int8 *v5; // eax
  int v6; // ecx
  int *v7; // edx
  signed int v8; // edx
  int v10; // edi
  int *v11; // eax
  signed int i; // edx
  unsigned __int16 *v13; // ecx
  int v14; // edi
  unsigned __int8 **v15; // eax
  int v16; // [esp+8h] [ebp-40Ch] BYREF
  int v17[256]; // [esp+Ch] [ebp-408h] BYREF
  int v18; // [esp+40Ch] [ebp-8h]
  unsigned __int16 *v19; // [esp+410h] [ebp-4h]
  int *v20; // [esp+41Ch] [ebp+8h]
  unsigned int v21; // [esp+41Ch] [ebp+8h]
  signed int v22; // [esp+41Ch] [ebp+8h]

  v4 = *this - *(_DWORD *)(a2 + 1620);
  v19 = sub_4133D0(this, a2, v4);
  v20 = v17;
  v5 = (unsigned __int8 *)(*((_DWORD *)this + 1) - 6);
  v18 = 0;
  do
  {
    do
      v5 += 6;
    while ( *(_BYTE *)(*v5 + a2 + 1644) == *(_BYTE *)(a2 + 2668) );
    v6 = v5[1] + v18;
    v7 = v20++;
    --v4;
    v18 = v6;
    *v7 = (int)v5;
  }
  while ( v4 );
  *(_DWORD *)(a2 + 19076) += v6;
  v21 = *(_DWORD *)(a2 + 19064) / *(_DWORD *)(a2 + 19076);
  *(_DWORD *)(a2 + 19064) = v21;
  v8 = *(_DWORD *)(a2 + 19076);
  v22 = (*(_DWORD *)(a2 + 19060) - *(_DWORD *)(a2 + 19056)) / v21;
  if ( v22 >= v8 )
    return 0;
  v10 = v17[0];
  v11 = v17;
  if ( v22 >= v6 )
  {
    *(_DWORD *)(a2 + 19068) = v6;
    *(_DWORD *)(a2 + 19072) = v8;
    v14 = *this - *(_DWORD *)(a2 + 1620);
    v15 = (unsigned __int8 **)&v16;
    do
    {
      ++v15;
      --v14;
      *(_BYTE *)(**v15 + a2 + 1644) = *(_BYTE *)(a2 + 2668);
    }
    while ( v14 );
    *v19 += *(_WORD *)(a2 + 19076);
    *(_DWORD *)(a2 + 1620) = *this;
  }
  else
  {
    for ( i = *(unsigned __int8 *)(v17[0] + 1); i <= v22; i += *(unsigned __int8 *)(*v11 + 1) )
      v10 = *++v11;
    v13 = v19;
    *(_DWORD *)(a2 + 19072) = i;
    *(_DWORD *)(a2 + 19068) = i - *(unsigned __int8 *)(v10 + 1);
    sub_412687(v13);
    sub_413396(this, a2, v10);
  }
  return 1;
}

//----- (004135A1) --------------------------------------------------------
void *__thiscall sub_4135A1(unsigned int *this)
{
  unsigned int *v2; // edi

  v2 = this + 4771;
  sub_411B2D(this + 4771);
  sub_411B42(v2, 1);
  return sub_412BD8((int)this, 2);
}

//----- (004135C7) --------------------------------------------------------
bool __thiscall sub_4135C7(unsigned int *this, int *a2, int *a3)
{
  int v5; // ebx
  unsigned int *v6; // ecx
  int v8; // [esp+Ch] [ebp-4h]
  char v9; // [esp+18h] [ebp+8h]

  v9 = sub_4126DB(a2);
  if ( (v9 & 0x20) != 0 )
  {
    v8 = sub_4126DB(a2);
  }
  else if ( !this[4771] )
  {
    return 0;
  }
  if ( (v9 & 0x40) != 0 )
    *a3 = sub_4126DB(a2);
  sub_4126FC(this + 4764, (int)a2);
  if ( (v9 & 0x20) != 0 )
  {
    v5 = (v9 & 0x1F) + 1;
    if ( v5 > 16 )
      v5 = 3 * v5 - 32;
    v6 = this + 4771;
    if ( v5 == 1 )
    {
      sub_411B2D(v6);
      return 0;
    }
    sub_411B42(v6, v8 + 1);
    sub_412BD8((int)this, v5);
  }
  return this[401] != 0;
}
// 41364A: variable 'v8' is possibly undefined

//----- (0041366A) --------------------------------------------------------
int __thiscall sub_41366A(int this)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edi
  unsigned int v5; // eax
  char v6; // al
  int v8; // ecx
  int v9; // edx
  unsigned __int8 *v10; // eax
  int v11; // ebx
  unsigned int v12; // eax
  int v13; // eax
  unsigned int v14; // ecx
  int v15; // eax
  int v16; // ecx
  unsigned int v17; // eax
  int v18; // ecx
  unsigned __int16 *v19; // ecx
  int v20; // eax
  unsigned int v21; // ecx
  int v22; // eax
  int v23; // ecx

  v2 = *(_DWORD *)(this + 1604);
  v3 = *(_DWORD *)(this + 19420);
  if ( v2 <= v3 )
    return -1;
  v4 = *(_DWORD *)(this + 19428);
  if ( v2 > v4 )
    return -1;
  if ( *(_WORD *)v2 != 1 )
  {
    v5 = *(_DWORD *)(v2 + 4);
    if ( v5 > v3 && v5 <= v4 )
    {
      v6 = sub_413258((unsigned __int16 *)v2, this);
      goto LABEL_7;
    }
    return -1;
  }
  sub_411D52(v2, this);
LABEL_10:
  v8 = *(_DWORD *)(this + 19068);
  v9 = *(_DWORD *)(this + 19064);
  *(_DWORD *)(this + 19056) += v8 * v9;
  *(_DWORD *)(this + 19064) = v9 * (*(_DWORD *)(this + 19072) - v8);
  if ( !*(_DWORD *)(this + 1616) )
  {
    while ( 1 )
    {
      v13 = *(_DWORD *)(this + 19056);
      v14 = *(_DWORD *)(this + 19064);
      if ( (v13 ^ (v13 + v14)) >= 0x1000000 )
      {
        if ( v14 >= 0x8000 )
        {
          v17 = *(_DWORD *)(this + 19420);
          do
          {
            v18 = *(_DWORD *)(this + 1604);
            ++*(_DWORD *)(this + 1628);
            v19 = *(unsigned __int16 **)(v18 + 8);
            *(_DWORD *)(this + 1604) = v19;
            if ( (unsigned int)v19 <= v17 || (unsigned int)v19 > *(_DWORD *)(this + 19428) )
              return -1;
          }
          while ( *v19 == *(_DWORD *)(this + 1620) );
          v6 = sub_413462(v19, this);
LABEL_7:
          if ( !v6 )
            return -1;
          goto LABEL_10;
        }
        *(_DWORD *)(this + 19064) = -v13 & 0x7FFF;
      }
      v15 = sub_4126DB(*(int **)(this + 19080));
      v16 = *(_DWORD *)(this + 19060);
      *(_DWORD *)(this + 19064) <<= 8;
      *(_DWORD *)(this + 19056) <<= 8;
      *(_DWORD *)(this + 19060) = (v16 << 8) | v15;
    }
  }
  v10 = *(unsigned __int8 **)(this + 1616);
  v11 = *v10;
  if ( *(_DWORD *)(this + 1628) || (v12 = *(_DWORD *)(v10 + 2), v12 <= *(_DWORD *)(this + 19420)) )
  {
    sub_412F32(this);
    if ( !*(_BYTE *)(this + 2668) )
      sub_411E81((_BYTE *)this);
  }
  else
  {
    *(_DWORD *)(this + 1612) = v12;
    *(_DWORD *)(this + 1604) = v12;
  }
  while ( 1 )
  {
    v20 = *(_DWORD *)(this + 19056);
    v21 = *(_DWORD *)(this + 19064);
    if ( (v20 ^ (v20 + v21)) < 0x1000000 )
      goto LABEL_28;
    if ( v21 >= 0x8000 )
      return v11;
    *(_DWORD *)(this + 19064) = -v20 & 0x7FFF;
LABEL_28:
    v22 = sub_4126DB(*(int **)(this + 19080));
    v23 = *(_DWORD *)(this + 19060);
    *(_DWORD *)(this + 19064) <<= 8;
    *(_DWORD *)(this + 19056) <<= 8;
    *(_DWORD *)(this + 19060) = (v23 << 8) | v22;
  }
}

//----- (00413829) --------------------------------------------------------
void __thiscall sub_413829(_DWORD *this)
{
  void *v2; // eax
  int v3; // esi
  int v4; // ecx
  int *v5; // eax
  void *v6; // eax
  char *v7; // eax
  _DWORD *v8; // esi
  void *v9; // eax
  void *v10; // [esp+Ch] [ebp-14h]
  char *v11; // [esp+Ch] [ebp-14h]
  char *v12; // [esp+10h] [ebp-10h]

  if ( !this[8] )
  {
    v2 = operator new[](0x400400u);
    this[8] = v2;
    memset(v2, 0, 0x400400u);
  }
  if ( !this[6] )
  {
    v3 = 2 * this[7];
    v4 = (19172 * (unsigned __int64)(unsigned int)v3) >> 32 != 0 ? -1 : 38344 * this[7];
    v5 = (int *)operator new[](__CFADD__(v4, 4) ? -1 : v4 + 4);
    if ( v5 )
    {
      *v5 = v3;
      v10 = v5 + 1;
      `eh vector constructor iterator'(
        v5 + 1,
        0x4AE4u,
        v3,
        (void (__thiscall *)(void *))sub_4126A6,
        (void (__thiscall *)(void *))sub_4126BE);
      v6 = v10;
    }
    else
    {
      v6 = 0;
    }
    this[6] = v6;
    memset(v6, 0, 19172 * v3);
    if ( v3 )
    {
      v12 = 0;
      v11 = (char *)v3;
      do
      {
        v7 = &v12[this[6]];
        v8 = v7 + 19156;
        if ( !*((_DWORD *)v7 + 4789) )
        {
          *((_DWORD *)v7 + 4791) = 16640;
          v9 = malloc(0x30C00u);
          *v8 = v9;
          if ( !v9 )
            sub_4062F7(&dword_432A6C);
        }
        v12 += 19172;
        --v11;
      }
      while ( v11 );
    }
  }
}
// 432A6C: using guessed type int dword_432A6C;

//----- (0041392E) --------------------------------------------------------
char *__thiscall sub_41392E(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x4AE4u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))sub_4126BE);
    if ( (a2 & 1) != 0 )
      operator delete[](this - 4);
    return this - 4;
  }
  else
  {
    sub_4126BE((void **)this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

//----- (0041397A) --------------------------------------------------------
int __thiscall sub_41397A(unsigned int *this)
{
  unsigned int *v2; // edi
  int v3; // ebx

  v2 = this + 9780;
  v3 = sub_41366A((int)(this + 9780));
  if ( v3 == -1 )
  {
    sub_4135A1(v2);
    this[14748] = 0;
  }
  return v3;
}

//----- (004139A7) --------------------------------------------------------
void __thiscall sub_4139A7(void **this)
{
  sub_401105(this + 10);
  sub_401105(this + 6);
  sub_401105(this);
}

//----- (004139C2) --------------------------------------------------------
int __thiscall sub_4139C2(int *this, _DWORD *Size)
{
  int result; // eax

  if ( Size[7] )
  {
    Size[20] = this[4884];
    sub_40A820((_DWORD *)(Size[6] + 36), this[4884]);
    sub_40A820((_DWORD *)(Size[6] + 40), this[4885]);
    return sub_40B06D(this + 14750, (size_t)Size);
  }
  return result;
}

//----- (00413A24) --------------------------------------------------------
char __thiscall sub_413A24(int this)
{
  _DWORD *v2; // esi
  char result; // al
  __int16 v4; // ax
  int v5; // edi
  int v6; // edi
  int v7; // eax
  unsigned int *v8; // edi
  __int16 v9; // ax
  int v10; // edx
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // ecx
  int v14; // eax
  unsigned int v15; // edx
  unsigned int *v16; // ecx
  unsigned int v17; // ecx
  int v18; // edx
  unsigned int v19; // eax
  int v20; // ecx
  unsigned int v21; // eax
  int v22; // eax
  unsigned int v23; // eax
  int v24; // eax
  bool v25; // cc
  int v26; // [esp-8h] [ebp-1C0h]
  int v27; // [esp-8h] [ebp-1C0h]
  _BYTE Src[432]; // [esp+8h] [ebp-1B0h] BYREF

  v2 = (_DWORD *)(this + 4);
  if ( *(_DWORD *)(this + 4) <= *(_DWORD *)(this + 120) - 25 || (result = sub_411E9F(this)) != 0 )
  {
    sub_409527(v2, -*(_DWORD *)(this + 8) & 7);
    v4 = sub_40953E(v2);
    if ( (v4 & 0x8000) != 0 )
    {
      *(_DWORD *)(this + 58992) = 1;
      return sub_4135C7((unsigned int *)(this + 39120), (int *)this, (int *)(this + 58556));
    }
    else
    {
      *(_DWORD *)(this + 58992) = 0;
      *(_DWORD *)(this + 39112) = 0;
      *(_DWORD *)(this + 39116) = 0;
      if ( (v4 & 0x4000) == 0 )
        memset((void *)(this + 58560), 0, 0x1AEu);
      sub_409527(v2, 2);
      *(_DWORD *)&Src[428] = 0;
      do
      {
        *(_DWORD *)&Src[424] = (unsigned __int8)((unsigned int)sub_40953E(v2) >> 12);
        sub_409527(v2, 4);
        if ( *(_DWORD *)&Src[424] == 15 )
        {
          v5 = (unsigned __int8)((unsigned int)sub_40953E(v2) >> 12);
          sub_409527(v2, 4);
          if ( v5 )
          {
            v6 = v5 + 2;
            while ( v6 > 0 )
            {
              --v6;
              if ( *(_DWORD *)&Src[428] >= 0x14u )
                break;
              v7 = (*(_DWORD *)&Src[428])++;
              Src[v7 + 404] = 0;
            }
            --*(_DWORD *)&Src[428];
          }
          else
          {
            Src[*(_DWORD *)&Src[428] + 404] = 15;
          }
        }
        else
        {
          Src[*(_DWORD *)&Src[428] + 404] = Src[424];
        }
        ++*(_DWORD *)&Src[428];
      }
      while ( *(_DWORD *)&Src[428] < 0x14u );
      v8 = (unsigned int *)(this + 15428);
      sub_41237D((int)&Src[404], (unsigned int *)(this + 15428), 0x14u);
      *(_DWORD *)&Src[428] = 0;
      do
      {
        if ( *v2 > *(_DWORD *)(this + 120) - 5 && !sub_411E9F(this) )
          return 0;
        v9 = sub_4094F9(v2);
        v10 = *(_DWORD *)(this + 15560);
        v11 = v9 & 0xFFFE;
        if ( v11 >= v8[v10 + 1] )
        {
          v15 = v10 + 1;
          *(_DWORD *)&Src[424] = 15;
          if ( v15 < 0xF )
          {
            v16 = &v8[v15 + 1];
            while ( v11 >= *v16 )
            {
              ++v15;
              ++v16;
              if ( v15 >= 0xF )
                goto LABEL_29;
            }
            *(_DWORD *)&Src[424] = v15;
          }
LABEL_29:
          v17 = *(_DWORD *)&Src[424] + v2[1];
          *v2 += v17 >> 3;
          v18 = *(_DWORD *)&Src[424];
          v2[1] = v17 & 7;
          v19 = v8[v18 + 17] + ((v11 - v8[v18]) >> (16 - v18));
          if ( v19 >= *v8 )
            v19 = 0;
          v14 = *((unsigned __int16 *)v8 + v19 + 1604);
        }
        else
        {
          v12 = v11 >> (16 - v10);
          v13 = v2[1] + *((unsigned __int8 *)v8 + v12 + 136);
          *v2 += v13 >> 3;
          v2[1] = v13 & 7;
          v14 = *((unsigned __int16 *)v8 + v12 + 580);
        }
        if ( v14 >= 16 )
        {
          if ( v14 >= 18 )
          {
            if ( v14 == 18 )
            {
              v23 = ((unsigned int)sub_40953E(v2) >> 13) + 3;
              v27 = 3;
            }
            else
            {
              v23 = ((unsigned int)sub_40953E(v2) >> 9) + 11;
              v27 = 7;
            }
            *(_DWORD *)&Src[424] = v23;
            sub_409527(v2, v27);
            while ( *(int *)&Src[424] > 0 )
            {
              --*(_DWORD *)&Src[424];
              if ( *(int *)&Src[428] >= 404 )
                goto LABEL_52;
              v24 = (*(_DWORD *)&Src[428])++;
              Src[v24] = 0;
            }
          }
          else
          {
            if ( v14 == 16 )
            {
              v21 = ((unsigned int)sub_40953E(v2) >> 13) + 3;
              v26 = 3;
            }
            else
            {
              v21 = ((unsigned int)sub_40953E(v2) >> 9) + 11;
              v26 = 7;
            }
            *(_DWORD *)&Src[424] = v21;
            sub_409527(v2, v26);
            if ( *(int *)&Src[428] > 0 )
            {
              while ( *(int *)&Src[424] > 0 )
              {
                v22 = *(_DWORD *)&Src[428];
                --*(_DWORD *)&Src[424];
                if ( *(int *)&Src[428] >= 404 )
                  goto LABEL_52;
                Src[*(_DWORD *)&Src[428]] = Src[*(_DWORD *)&Src[428] - 1];
                *(_DWORD *)&Src[428] = v22 + 1;
              }
            }
          }
        }
        else
        {
          v20 = *(_DWORD *)&Src[428];
          Src[*(_DWORD *)&Src[428]] = (v14 + *(_BYTE *)(*(_DWORD *)&Src[428] + this + 58560)) & 0xF;
          *(_DWORD *)&Src[428] = v20 + 1;
        }
      }
      while ( *(int *)&Src[428] < 404 );
LABEL_52:
      v25 = *v2 <= *(_DWORD *)(this + 120);
      *(_BYTE *)(this + 58996) = 1;
      if ( !v25 )
        return 0;
      sub_41237D((int)Src, (unsigned int *)(this + 148), 0x12Bu);
      sub_41237D((int)&Src[299], (unsigned int *)(this + 3968), 0x3Cu);
      sub_41237D((int)&Src[359], (unsigned int *)(this + 7788), 0x11u);
      sub_41237D((int)&Src[376], (unsigned int *)(this + 11608), 0x1Cu);
      memcpy((void *)(this + 58560), Src, 0x1AEu);
      return 1;
    }
  }
  return result;
}

//----- (00413D6C) --------------------------------------------------------
int __stdcall sub_413D6C(_DWORD *a1)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // eax
  int v9; // [esp+10h] [ebp+8h]

  v2 = ((unsigned int)sub_40953E(a1) >> 14) + 1;
  v3 = a1[1] + 2;
  *a1 += v3 >> 3;
  v4 = 0;
  a1[1] = v3 & 7;
  v9 = 0;
  if ( v2 )
  {
    v5 = v2;
    do
    {
      v6 = (unsigned int)sub_40953E(a1) >> 8 << v4;
      v4 += 8;
      v9 += v6;
      v7 = a1[1] + 8;
      *a1 += v7 >> 3;
      --v5;
      a1[1] = v7 & 7;
    }
    while ( v5 );
  }
  return v9;
}

//----- (00413DD1) --------------------------------------------------------
bool __thiscall sub_413DD1(_DWORD *this, int a2, int a3)
{
  bool result; // al

  if ( *(_BYTE *)(a2 + 8) || *(_DWORD *)a2 <= this[30] - 16 || (result = sub_411F1D((int)this)) )
  {
    *(_DWORD *)(a3 + 4) = sub_413D6C((_DWORD *)a2);
    *(_DWORD *)(a3 + 8) = sub_413D6C((_DWORD *)a2);
    *(_BYTE *)a3 = (unsigned int)sub_40953E((_DWORD *)a2) >> 13;
    sub_409527((_DWORD *)a2, 3);
    if ( !*(_BYTE *)a3 )
    {
      *(_BYTE *)(a3 + 12) = ((unsigned int)sub_40953E((_DWORD *)a2) >> 11) + 1;
      sub_409527((_DWORD *)a2, 5);
    }
    return 1;
  }
  return result;
}

//----- (00413E47) --------------------------------------------------------
_BYTE *__thiscall sub_413E47(_DWORD *this, _BYTE *a2, unsigned int a3, unsigned __int8 *a4)
{
  unsigned __int8 v4; // bl
  char *v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  unsigned __int8 *v8; // eax
  unsigned int v9; // esi
  int v10; // ecx
  _BYTE *result; // eax
  int v12; // ecx
  char v13; // bl
  int v14; // edx
  char v15; // cl
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  unsigned int v19; // ebx
  _DWORD *v20; // esi
  unsigned int v21; // edx
  char i; // cl
  signed int v24; // [esp+18h] [ebp+8h]
  unsigned int v25; // [esp+18h] [ebp+8h]
  int v26; // [esp+1Ch] [ebp+Ch]
  signed int v27; // [esp+20h] [ebp+10h]
  int v28; // [esp+20h] [ebp+10h]

  v4 = *a4;
  v5 = a2;
  if ( *a4 )
  {
    if ( v4 > 2u )
    {
      if ( v4 != 3 )
        return 0;
      v6 = this[4884];
      if ( (int)(a3 - 3) > 0 )
      {
        v7 = v6;
        v8 = a2 + 1;
        v9 = ((a3 - 4) >> 2) + 1;
        do
        {
          if ( v8[2] == 0xEB )
          {
            v10 = *(v8 - 1) + ((*v8 + (v8[1] << 8)) << 8) - (v7 >> 2);
            *(v8 - 1) -= v7 >> 2;
            *v8 = BYTE1(v10);
            v8[1] = BYTE2(v10);
          }
          v8 += 4;
          v7 += 4;
          --v9;
        }
        while ( v9 );
      }
      return a2;
    }
    v12 = this[4884];
    v24 = 0;
    v13 = (v4 == 2) - 24;
    v27 = a3 - 4;
    if ( (int)(a3 - 4) <= 0 )
      return a2;
    v14 = v12;
    while ( 1 )
    {
      v15 = *v5++;
      ++v24;
      v26 = ++v14;
      if ( v15 != -24 && v15 != v13 )
        goto LABEL_21;
      v16 = *(_DWORD *)v5;
      v17 = v14 & 0xFFFFFF;
      if ( (*(_DWORD *)v5 & 0x80000000) != 0 )
      {
        if ( ((v16 + v17) & 0x80000000) == 0 )
        {
          v18 = v16 + 0x1000000;
LABEL_19:
          *(_DWORD *)v5 = v18;
        }
      }
      else if ( ((v16 - 0x1000000) & 0x80000000) != 0 )
      {
        v18 = v16 - v17;
        goto LABEL_19;
      }
      v24 += 4;
      v5 += 4;
      v14 = v26 + 4;
LABEL_21:
      if ( v24 >= v27 )
        return a2;
    }
  }
  v19 = a4[12];
  v28 = 0;
  v20 = this + 13;
  sub_401C05(this + 13, a3);
  v25 = 0;
  for ( result = (_BYTE *)*v20; v25 < v19; ++v25 )
  {
    v21 = v25;
    for ( i = 0; v21 < a3; v21 += v19 )
    {
      i -= v5[v28++];
      result[v21] = i;
    }
  }
  return result;
}

//----- (00413FA1) --------------------------------------------------------
void __thiscall sub_413FA1(int this, unsigned int a2, size_t a3)
{
  int v3; // ebx
  unsigned int v5; // edi
  char *v6; // eax
  int i; // [esp+18h] [ebp+Ch]

  v3 = a2;
  if ( a3 != a2 )
  {
    *(_BYTE *)(this + 19530) = 1;
    if ( a3 < a2 )
      *(_BYTE *)(this + 19529) = 1;
  }
  if ( *(_BYTE *)(this + 19512) )
  {
    for ( i = *(_DWORD *)(this + 59128) & (a3 - a2); i; v3 = *(_DWORD *)(this + 59128) & (v5 + v3) )
    {
      v5 = sub_4121ED((unsigned int *)(this + 19256), v3, i);
      v6 = (char *)sub_412144((int *)(this + 19256), v3);
      sub_411FD6((int *)this, v6, v5);
      i -= v5;
    }
  }
  else if ( a3 >= a2 )
  {
    sub_411FD6((int *)this, (char *)(a2 + *(_DWORD *)(this + 19252)), a3 - a2);
  }
  else
  {
    sub_411FD6((int *)this, (char *)(a2 + *(_DWORD *)(this + 19252)), *(_DWORD *)(this + 59124) - a2);
    sub_411FD6((int *)this, *(char **)(this + 19252), a3);
  }
}

//----- (00414050) --------------------------------------------------------
bool __thiscall sub_414050(_DWORD *this, int *a2, int a3)
{
  bool result; // al
  unsigned int v6; // eax
  unsigned int v7; // ebx
  char v8; // al
  int v9; // ebx
  int v10; // eax
  unsigned int v11; // eax
  char v12; // cl
  unsigned int v13; // eax
  int v14; // esi
  int v15; // edx
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  char v19; // [esp+1Fh] [ebp+Bh]
  unsigned __int8 v20; // [esp+23h] [ebp+Fh]

  *(_DWORD *)(a3 + 12) = 0;
  if ( *((_BYTE *)a2 + 8) || *a2 <= this[30] - 7 || (result = sub_411F1D((int)this)) )
  {
    sub_409527(a2, -a2[1] & 7);
    v6 = sub_40953E(a2);
    v7 = v6 >> 8;
    v20 = BYTE1(v6);
    sub_409527(a2, 8);
    v8 = v7;
    v9 = (((unsigned __int8)v7 >> 3) & 3) + 1;
    if ( v9 == 4 )
      return 0;
    *(_DWORD *)(a3 + 12) = v9 + 2;
    *(_DWORD *)(a3 + 4) = (v8 & 7) + 1;
    v19 = (unsigned __int16)sub_40953E(a2) >> 8;
    sub_409527(a2, 8);
    v10 = 0;
    v17 = 0;
    if ( v9 )
    {
      v18 = 0;
      do
      {
        v11 = sub_40953E(a2);
        v12 = v18;
        v18 += 8;
        v17 += v11 >> 8 << v12;
        v13 = a2[1] + 8;
        *a2 += v13 >> 3;
        --v9;
        a2[1] = v13 & 7;
      }
      while ( v9 );
      v10 = v17;
    }
    *(_DWORD *)a3 = v10;
    if ( ((unsigned __int8)(v20 ^ v10 ^ BYTE1(v10) ^ BYTE2(v10)) ^ 0x5A) == v19 )
    {
      v14 = *a2;
      v15 = v14 + v10 - 1;
      *(_DWORD *)(a3 + 8) = v14;
      if ( this[31] < v15 )
        v15 = this[31];
      this[31] = v15;
      result = 1;
      *(_BYTE *)(a3 + 16) = (v20 & 0x40) != 0;
      *(_BYTE *)(a3 + 17) = v20 >> 7;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0041416C) --------------------------------------------------------
bool __thiscall sub_41416C(_DWORD *this, int a2, int a3, unsigned int *a4)
{
  bool v4; // zf
  bool result; // al
  int v6; // ebx
  int v7; // edi
  int v8; // edi
  unsigned int v9; // eax
  unsigned int *v10; // edi
  __int16 v11; // ax
  unsigned int v12; // ebx
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // edx
  unsigned int v18; // ebx
  unsigned int *v19; // ecx
  unsigned int v20; // ebx
  unsigned int v21; // eax
  int v22; // ecx
  signed int v23; // ebx
  int v24; // eax
  signed int v25; // ebx
  int v26; // eax
  char v28[306]; // [esp+2h] [ebp-1C8h] BYREF
  char v29[64]; // [esp+134h] [ebp-96h] BYREF
  char v30[16]; // [esp+174h] [ebp-56h] BYREF
  char v31[46]; // [esp+184h] [ebp-46h] BYREF
  char v32[20]; // [esp+1B2h] [ebp-18h] BYREF
  _DWORD *v33; // [esp+1C6h] [ebp-4h]
  unsigned int i; // [esp+1D6h] [ebp+Ch]
  int v35; // [esp+1D6h] [ebp+Ch]

  v4 = *(_BYTE *)(a3 + 17) == 0;
  v33 = this;
  if ( v4 )
    return 1;
  if ( *(_BYTE *)(a2 + 8) || *(_DWORD *)a2 <= this[30] - 25 || (result = sub_411F1D((int)this)) )
  {
    for ( i = 0; i < 0x14; ++i )
    {
      v6 = (unsigned __int8)((unsigned int)sub_40953E((_DWORD *)a2) >> 12);
      sub_409527((_DWORD *)a2, 4);
      if ( v6 == 15 )
      {
        v7 = (unsigned __int8)((unsigned int)sub_40953E((_DWORD *)a2) >> 12);
        sub_409527((_DWORD *)a2, 4);
        if ( v7 )
        {
          v8 = v7 + 2;
          while ( v8 > 0 )
          {
            --v8;
            if ( i >= 0x14 )
              break;
            v9 = i++;
            v32[v9] = 0;
          }
          --i;
        }
        else
        {
          v32[i] = 15;
        }
      }
      else
      {
        v32[i] = v6;
      }
    }
    v10 = a4 + 3820;
    sub_41237D((int)v32, a4 + 3820, 0x14u);
    v35 = 0;
    do
    {
      if ( !*(_BYTE *)(a2 + 8) && *(_DWORD *)a2 > v33[30] - 5 && !sub_411F1D((int)v33) )
        return 0;
      v11 = sub_4094F9((_DWORD *)a2);
      v12 = a4[3853];
      v13 = v11 & 0xFFFE;
      if ( v13 >= v10[v12 + 1] )
      {
        v17 = 15;
        v18 = v12 + 1;
        if ( v18 < 0xF )
        {
          v19 = &v10[v18 + 1];
          while ( v13 >= *v19 )
          {
            ++v18;
            ++v19;
            if ( v18 >= 0xF )
              goto LABEL_29;
          }
          v17 = v18;
        }
LABEL_29:
        v20 = v17 + *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a2 + 4) = v20 & 7;
        *(_DWORD *)a2 += v20 >> 3;
        v21 = v10[v17 + 17] + ((v13 - v10[v17]) >> (16 - v17));
        if ( v21 >= *v10 )
          v21 = 0;
        v16 = *((unsigned __int16 *)v10 + v21 + 1604);
      }
      else
      {
        v14 = v13 >> (16 - v12);
        v15 = *(_DWORD *)(a2 + 4) + *((unsigned __int8 *)v10 + v14 + 136);
        *(_DWORD *)a2 += v15 >> 3;
        *(_DWORD *)(a2 + 4) = v15 & 7;
        v16 = *((unsigned __int16 *)v10 + v14 + 580);
      }
      if ( v16 >= 16 )
      {
        if ( v16 >= 18 )
        {
          if ( v16 == 18 )
          {
            v25 = ((unsigned int)sub_40953E((_DWORD *)a2) >> 13) + 3;
            sub_409527((_DWORD *)a2, 3);
          }
          else
          {
            v25 = ((unsigned int)sub_40953E((_DWORD *)a2) >> 9) + 11;
            sub_409527((_DWORD *)a2, 7);
          }
          while ( v25 > 0 )
          {
            --v25;
            if ( v35 >= 430 )
              goto LABEL_52;
            v26 = v35++;
            v28[v26] = 0;
          }
        }
        else
        {
          if ( v16 == 16 )
          {
            v23 = ((unsigned int)sub_40953E((_DWORD *)a2) >> 13) + 3;
            sub_409527((_DWORD *)a2, 3);
          }
          else
          {
            v23 = ((unsigned int)sub_40953E((_DWORD *)a2) >> 9) + 11;
            sub_409527((_DWORD *)a2, 7);
          }
          v24 = v35;
          if ( v35 > 0 )
          {
            while ( v23 > 0 )
            {
              --v23;
              if ( v24 >= 430 )
                goto LABEL_52;
              v28[v24] = v28[v24 - 1];
              v35 = ++v24;
            }
          }
        }
      }
      else
      {
        v22 = v35++;
        v28[v22] = v16;
      }
    }
    while ( v35 < 430 );
LABEL_52:
    if ( !*(_BYTE *)(a2 + 8) && *(_DWORD *)a2 > v33[30] )
      return 0;
    sub_41237D((int)v28, a4, 0x132u);
    sub_41237D((int)v29, a4 + 955, 0x40u);
    sub_41237D((int)v30, a4 + 1910, 0x10u);
    sub_41237D((int)v31, a4 + 2865, 0x2Cu);
    return 1;
  }
  return result;
}
// 41416C: using guessed type char var_18[20];
// 41416C: using guessed type char var_1C8[306];
// 41416C: using guessed type char var_96[64];
// 41416C: using guessed type char var_56[16];
// 41416C: using guessed type char var_46[46];

//----- (0041442E) --------------------------------------------------------
int __thiscall sub_41442E(_DWORD *this, int a2)
{
  int result; // eax

  sub_41251D((int)this, 1);
  result = this[1];
  *(_DWORD *)(*this + 4 * result - 4) = a2;
  return result;
}

//----- (00414449) --------------------------------------------------------
void __thiscall sub_414449(_DWORD *this, unsigned int a2)
{
  if ( a2 <= this[2] )
    this[1] = a2;
  else
    sub_4125B2((int)this, a2 - this[1]);
}

//----- (00414463) --------------------------------------------------------
int __thiscall sub_414463(_DWORD *this, int a2, int a3, int a4, int a5)
{
  int result; // eax
  _DWORD *v7; // edi

  sub_4125B2((int)this, 1);
  result = 16 * this[1];
  v7 = (_DWORD *)(result + *this - 16);
  *v7++ = a2;
  *v7++ = a3;
  *v7 = a4;
  v7[1] = a5;
  return result;
}

//----- (00414487) --------------------------------------------------------
char __thiscall sub_414487(_DWORD *this, int a2)
{
  bool v3; // zf
  int v4; // eax
  int *v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  void *v11; // eax
  _DWORD *v12; // ebx
  int v13; // eax
  __int16 v14; // ax
  int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // edx
  unsigned int *v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // eax
  unsigned __int16 v24; // cx
  unsigned __int16 v25; // cx
  unsigned int v26; // eax
  int v27; // ebx
  unsigned int v28; // eax
  unsigned int v29; // eax
  __int16 v30; // ax
  int v31; // edx
  unsigned int v32; // eax
  unsigned int v33; // eax
  unsigned int v34; // ecx
  unsigned int v35; // eax
  int v36; // ebx
  unsigned int v37; // ecx
  unsigned int *v38; // edx
  unsigned int v39; // edx
  unsigned int v40; // eax
  unsigned int v41; // ebx
  unsigned int v42; // ebx
  __int16 v43; // ax
  int v44; // ebx
  unsigned int v45; // eax
  unsigned int v46; // eax
  unsigned int v47; // ecx
  int v48; // eax
  int v49; // edx
  unsigned int v50; // ecx
  unsigned int *v51; // ebx
  unsigned int v52; // ebx
  unsigned int v53; // eax
  unsigned int v54; // eax
  __int16 v55; // cx
  _DWORD *v56; // eax
  int v57; // eax
  __int16 v58; // ax
  int v59; // edx
  unsigned int v60; // eax
  unsigned int v61; // eax
  unsigned int v62; // ecx
  unsigned int v63; // edx
  unsigned int *v64; // ecx
  unsigned int v65; // ecx
  unsigned int v66; // eax
  unsigned int v67; // eax
  char v69[4]; // [esp+4h] [ebp-2Ch] BYREF
  int v70; // [esp+8h] [ebp-28h]
  int v71; // [esp+Ch] [ebp-24h]
  unsigned __int8 v72; // [esp+10h] [ebp-20h]
  _DWORD *v73; // [esp+14h] [ebp-1Ch]
  _DWORD *v74; // [esp+18h] [ebp-18h]
  unsigned int v75; // [esp+1Ch] [ebp-14h]
  int v76; // [esp+20h] [ebp-10h]
  int v77; // [esp+24h] [ebp-Ch]
  int v78; // [esp+28h] [ebp-8h]
  unsigned int v79; // [esp+2Ch] [ebp-4h]
  int v80; // [esp+38h] [ebp+8h]
  unsigned int v81; // [esp+38h] [ebp+8h]
  int v82; // [esp+38h] [ebp+8h]
  unsigned int v83; // [esp+38h] [ebp+8h]
  unsigned int v84; // [esp+38h] [ebp+8h]

  v3 = *(_BYTE *)(a2 + 44) == 0;
  v73 = this;
  if ( !v3
    || (*(_BYTE *)(a2 + 44) = 1, LOBYTE(v4) = sub_41416C(this, a2 + 4, a2 + 24, (unsigned int *)(a2 + 48)), (_BYTE)v4) )
  {
    v4 = *(_DWORD *)(a2 + 24);
    v5 = (int *)(a2 + 4);
    if ( *(_DWORD *)(a2 + 4) > v4 + *(_DWORD *)(a2 + 36) )
    {
      *(_BYTE *)(a2 + 19152) = 1;
      return v4;
    }
    v6 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a2 + 19160) = 0;
    v7 = v6 + v4 - 1;
    v8 = *(_DWORD *)(a2 + 19148) - 16;
    v77 = v7;
    v76 = v8;
    v78 = v7;
    if ( v7 >= v8 )
      v78 = v8;
    while ( 1 )
    {
      while ( 1 )
      {
        v4 = *v5;
        if ( *v5 >= v78 )
        {
          if ( v4 > v77 || v4 == v77 && *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 28) )
            return v4;
          if ( v4 >= v76 && !*(_BYTE *)(a2 + 19154) || v4 >= *(_DWORD *)(a2 + 19148) )
          {
            *(_BYTE *)(a2 + 19155) = 1;
            return v4;
          }
        }
        v9 = *(_DWORD *)(a2 + 19164);
        if ( *(_DWORD *)(a2 + 19160) > (unsigned int)(v9 - 8) )
        {
          v10 = 2 * v9;
          *(_DWORD *)(a2 + 19164) = v10;
          v11 = realloc(*(void **)(a2 + 19156), 12 * v10);
          *(_DWORD *)(a2 + 19156) = v11;
          if ( !v11 )
            sub_4062F7(&dword_432A6C);
        }
        v12 = (_DWORD *)(*(_DWORD *)(a2 + 19156) + 12 * *(_DWORD *)(a2 + 19160));
        v13 = *(_DWORD *)(a2 + 19160) + 1;
        v74 = v12;
        *(_DWORD *)(a2 + 19160) = v13;
        v14 = sub_4094F9((_DWORD *)(a2 + 4));
        v15 = *(_DWORD *)(a2 + 180);
        v16 = v14 & 0xFFFE;
        if ( v16 >= *(_DWORD *)(a2 + 4 * v15 + 52) )
        {
          v20 = v15 + 1;
          v80 = 15;
          if ( v20 < 0xF )
          {
            v21 = (unsigned int *)(a2 + 4 * v20 + 52);
            while ( v16 >= *v21 )
            {
              ++v20;
              ++v21;
              if ( v20 >= 0xF )
                goto LABEL_26;
            }
            v80 = v20;
          }
LABEL_26:
          v22 = v80 + *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a2 + 4) += v22 >> 3;
          *(_DWORD *)(a2 + 8) = v22 & 7;
          v23 = *(_DWORD *)(a2 + 4 * v80 + 116) + ((v16 - *(_DWORD *)(a2 + 4 * v80 + 48)) >> (16 - v80));
          if ( v23 >= *(_DWORD *)(a2 + 48) )
            v23 = 0;
          v19 = *(unsigned __int16 *)(a2 + 2 * v23 + 3256);
        }
        else
        {
          v17 = v16 >> (16 - v15);
          v18 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v17 + a2 + 184);
          *v5 += v18 >> 3;
          *(_DWORD *)(a2 + 8) = v18 & 7;
          v19 = *(unsigned __int16 *)(a2 + 2 * v17 + 1208);
        }
        if ( v19 < 0x100 )
          break;
        if ( v19 < 0x106 )
        {
          if ( v19 == 256 )
          {
            sub_413DD1(v73, a2 + 4, (int)v69);
            *((_WORD *)v12 + 2) = (unsigned __int8)v69[0];
            v12[2] = v70;
            *v12 = 4;
            v57 = *(_DWORD *)(a2 + 19156) + 12 * (*(_DWORD *)(a2 + 19160))++;
            *(_DWORD *)v57 = 4;
            *(_WORD *)(v57 + 4) = v72;
            *(_DWORD *)(v57 + 8) = v71;
          }
          else if ( v19 == 257 )
          {
            *v12 = 2;
          }
          else
          {
            *v12 = 3;
            v12[2] = v19 - 258;
            v58 = sub_4094F9((_DWORD *)(a2 + 4));
            v59 = *(_DWORD *)(a2 + 11640);
            v60 = v58 & 0xFFFE;
            if ( v60 >= *(_DWORD *)(a2 + 4 * v59 + 11512) )
            {
              v63 = v59 + 1;
              v82 = 15;
              if ( v63 < 0xF )
              {
                v64 = (unsigned int *)(a2 + 4 * v63 + 11512);
                while ( v60 >= *v64 )
                {
                  ++v63;
                  ++v64;
                  if ( v63 >= 0xF )
                    goto LABEL_88;
                }
                v82 = v63;
              }
LABEL_88:
              v65 = v82 + *(_DWORD *)(a2 + 8);
              *(_DWORD *)(a2 + 4) += v65 >> 3;
              *(_DWORD *)(a2 + 8) = v65 & 7;
              v66 = *(_DWORD *)(a2 + 4 * v82 + 11576) + ((v60 - *(_DWORD *)(a2 + 4 * v82 + 11508)) >> (16 - v82));
              if ( v66 >= *(_DWORD *)(a2 + 11508) )
                v66 = 0;
              v19 = *(unsigned __int16 *)(a2 + 2 * v66 + 14716);
            }
            else
            {
              v61 = v60 >> (16 - v59);
              v62 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v61 + a2 + 11644);
              *v5 += v62 >> 3;
              *(_DWORD *)(a2 + 8) = v62 & 7;
              v19 = *(unsigned __int16 *)(a2 + 2 * v61 + 12668);
            }
            if ( v19 >= 8 )
            {
              v79 = (v19 >> 2) - 1;
              v19 = ((v19 & 3 | 4) << v79) + 2;
              v83 = v19;
              if ( v79 )
              {
                v67 = sub_4094F9((_DWORD *)(a2 + 4));
                v84 = (v67 >> (16 - v79)) + v83;
                v19 = v79 + *(_DWORD *)(a2 + 8);
                *v5 += v19 >> 3;
                *(_DWORD *)(a2 + 8) = v19 & 7;
                LOWORD(v19) = v84;
              }
            }
            else
            {
              LOWORD(v19) = v19 + 2;
            }
LABEL_95:
            *((_WORD *)v12 + 2) = v19;
          }
        }
        else
        {
          v26 = v19 - 262;
          if ( v26 >= 8 )
          {
            v27 = (v26 >> 2) - 1;
            v79 = ((v26 & 3 | 4) << v27) + 2;
            if ( v26 >> 2 != 1 )
            {
              v28 = sub_4094F9((_DWORD *)(a2 + 4));
              v79 += v28 >> (16 - v27);
              v29 = v27 + *(_DWORD *)(a2 + 8);
              *v5 += v29 >> 3;
              *(_DWORD *)(a2 + 8) = v29 & 7;
            }
          }
          else
          {
            v79 = v26 + 2;
          }
          v75 = v79;
          v30 = sub_4094F9((_DWORD *)(a2 + 4));
          v31 = *(_DWORD *)(a2 + 4000);
          v32 = v30 & 0xFFFE;
          if ( v32 >= *(_DWORD *)(a2 + 4 * v31 + 3872) )
          {
            v36 = 15;
            v37 = v31 + 1;
            if ( (unsigned int)(v31 + 1) < 0xF )
            {
              v38 = (unsigned int *)(a2 + 4 * v37 + 3872);
              while ( v32 >= *v38 )
              {
                ++v37;
                ++v38;
                if ( v37 >= 0xF )
                  goto LABEL_48;
              }
              v36 = v37;
            }
LABEL_48:
            v39 = v36 + *(_DWORD *)(a2 + 8);
            *(_DWORD *)(a2 + 8) = v39 & 7;
            *v5 += v39 >> 3;
            v40 = *(_DWORD *)(a2 + 4 * v36 + 3936) + ((v32 - *(_DWORD *)(a2 + 4 * v36 + 3868)) >> (16 - v36));
            if ( v40 >= *(_DWORD *)(a2 + 3868) )
              v40 = 0;
            v35 = *(unsigned __int16 *)(a2 + 2 * v40 + 7076);
          }
          else
          {
            v33 = v32 >> (16 - v31);
            v34 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v33 + a2 + 4004);
            *v5 += v34 >> 3;
            *(_DWORD *)(a2 + 8) = v34 & 7;
            v35 = *(unsigned __int16 *)(a2 + 2 * v33 + 5028);
          }
          if ( v35 >= 4 )
          {
            v41 = (v35 >> 1) - 1;
            v81 = ((v35 & 1 | 2) << v41) + 1;
            if ( v35 >> 1 != 1 )
            {
              if ( v41 < 4 )
              {
                v81 += (unsigned int)sub_41262C((_DWORD *)(a2 + 4)) >> (32 - v41);
                v54 = v41 + *(_DWORD *)(a2 + 8);
                *v5 += v54 >> 3;
                *(_DWORD *)(a2 + 8) = v54 & 7;
              }
              else
              {
                if ( v41 > 4 )
                {
                  v81 += 16 * ((unsigned int)sub_41262C((_DWORD *)(a2 + 4)) >> (36 - v41));
                  v42 = *(_DWORD *)(a2 + 8) + v41 - 4;
                  *v5 += v42 >> 3;
                  *(_DWORD *)(a2 + 8) = v42 & 7;
                }
                v43 = sub_4094F9((_DWORD *)(a2 + 4));
                v44 = *(_DWORD *)(a2 + 7820);
                v45 = v43 & 0xFFFE;
                if ( v45 >= *(_DWORD *)(a2 + 4 * v44 + 7692) )
                {
                  v49 = 15;
                  v50 = v44 + 1;
                  if ( (unsigned int)(v44 + 1) < 0xF )
                  {
                    v51 = (unsigned int *)(a2 + 4 * v50 + 7692);
                    while ( v45 >= *v51 )
                    {
                      ++v50;
                      ++v51;
                      if ( v50 >= 0xF )
                        goto LABEL_65;
                    }
                    v49 = v50;
                  }
LABEL_65:
                  v52 = v49 + *(_DWORD *)(a2 + 8);
                  *(_DWORD *)(a2 + 8) = v52 & 7;
                  *v5 += v52 >> 3;
                  v53 = *(_DWORD *)(a2 + 4 * v49 + 7756) + ((v45 - *(_DWORD *)(a2 + 4 * v49 + 7688)) >> (16 - v49));
                  if ( v53 >= *(_DWORD *)(a2 + 7688) )
                    v53 = 0;
                  v48 = *(unsigned __int16 *)(a2 + 2 * v53 + 10896);
                }
                else
                {
                  v46 = v45 >> (16 - v44);
                  v47 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v46 + a2 + 7824);
                  *v5 += v47 >> 3;
                  *(_DWORD *)(a2 + 8) = v47 & 7;
                  v48 = *(unsigned __int16 *)(a2 + 2 * v46 + 8848);
                }
                v81 += v48;
              }
            }
          }
          else
          {
            v81 = v35 + 1;
          }
          if ( v81 <= 0x100 )
          {
            v55 = v75;
          }
          else
          {
            v55 = v79 + 1;
            if ( v81 > 0x2000 )
            {
              v55 = v79 + 2;
              if ( v81 > 0x40000 )
                v55 = v79 + 3;
            }
          }
          v56 = v74;
          *v74 = 1;
          *((_WORD *)v56 + 2) = v55;
          v56[2] = v81;
        }
      }
      if ( *(_DWORD *)(a2 + 19160) <= 1u || *(v12 - 3) || (v24 = *((_WORD *)v12 - 4), v24 >= 3u) )
      {
        *v12 = 0;
        *((_BYTE *)v12 + 8) = v19;
        LOWORD(v19) = 0;
        goto LABEL_95;
      }
      v25 = v24 + 1;
      *((_WORD *)v12 - 4) = v25;
      *((_BYTE *)v12 + v25 - 4) = v19;
      --*(_DWORD *)(a2 + 19160);
    }
  }
  *(_BYTE *)(a2 + 19152) = 1;
  return v4;
}
// 432A6C: using guessed type int dword_432A6C;
// 414487: using guessed type char var_2C[4];

//----- (00414A4B) --------------------------------------------------------
char __thiscall sub_414A4B(int this)
{
  _DWORD *v2; // esi
  __int16 v3; // ax
  char v4; // dl
  bool v5; // cl
  unsigned int v6; // eax

  v2 = (_DWORD *)(this + 4);
  v3 = sub_4094F9((_DWORD *)(this + 4));
  v4 = 0;
  if ( (v3 & 0x8000) != 0 )
  {
    v5 = 1;
    v6 = v2[1] + 1;
  }
  else
  {
    v4 = 1;
    v5 = (v3 & 0x4000) != 0;
    v6 = v2[1] + 2;
  }
  *v2 += v6 >> 3;
  v2[1] = v6 & 7;
  *(_BYTE *)(this + 58996) = !v5;
  if ( v4 )
    return 0;
  else
    return sub_413A24(this);
}

//----- (00414AA5) --------------------------------------------------------
void **__thiscall sub_414AA5(void **this, char a2)
{
  sub_4139A7(this + 5);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00414AC4) --------------------------------------------------------
unsigned int __thiscall sub_414AC4(int this)
{
  unsigned int v2; // ecx
  unsigned int result; // eax
  int v4; // ebx
  size_t v5; // edi
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // edi
  int v10; // edi
  unsigned int v11; // eax
  int v12; // edi
  _DWORD *v13; // ebx
  unsigned int v14; // eax
  void *v15; // eax
  unsigned int v16; // edi
  int v17; // ebx
  void **v18; // ecx
  int v19; // ebx
  int v20; // edi
  unsigned int v21; // eax
  int v22; // edi
  _DWORD *v23; // ebx
  unsigned int v24; // eax
  void **v25; // ecx
  bool v26; // cf
  unsigned int i; // ecx
  unsigned int v28; // [esp+Ch] [ebp-18h]
  void *Src; // [esp+10h] [ebp-14h]
  void *Srca; // [esp+10h] [ebp-14h]
  size_t v31; // [esp+18h] [ebp-Ch]
  unsigned int v32; // [esp+1Ch] [ebp-8h]
  unsigned int v33; // [esp+1Ch] [ebp-8h]
  unsigned int v34; // [esp+20h] [ebp-4h]

  v34 = 0;
  v2 = *(_DWORD *)(this + 116);
  result = *(_DWORD *)(this + 59128) & (*(_DWORD *)(this + 112) - v2);
  v32 = v2;
  if ( !*(_DWORD *)(this + 59092) )
  {
LABEL_41:
    sub_413FA1(this, v32, *(_DWORD *)(this + 112));
    result = *(_DWORD *)(this + 112);
    *(_DWORD *)(this + 116) = result;
    return result;
  }
  while ( 1 )
  {
    v4 = *(_DWORD *)(4 * v34 + *(_DWORD *)(this + 59088));
    if ( v4 )
      break;
LABEL_40:
    if ( ++v34 >= *(_DWORD *)(this + 59092) )
      goto LABEL_41;
  }
  if ( *(_BYTE *)(v4 + 12) )
  {
    *(_BYTE *)(v4 + 12) = 0;
    goto LABEL_40;
  }
  v5 = *(_DWORD *)v4;
  Src = *(void **)(v4 + 4);
  v6 = *(_DWORD *)(this + 59128);
  v31 = *(_DWORD *)v4;
  if ( (v6 & (*(_DWORD *)v4 - v32)) >= result )
    goto LABEL_40;
  v7 = v32;
  if ( v32 != v5 )
  {
    sub_413FA1(this, v32, v5);
    v6 = *(_DWORD *)(this + 59128);
    v7 = v5;
    result = v6 & (*(_DWORD *)(this + 112) - v5);
  }
  if ( (unsigned int)Src <= result )
  {
    v8 = v6 & ((unsigned int)Src + v5);
    v28 = v8;
    if ( v5 >= v8 && v8 )
    {
      v9 = *(_DWORD *)(this + 59124) - v31;
      sub_40A8CB((_DWORD *)(this + 59000), 0, (void *)(v31 + *(_DWORD *)(this + 19252)), v9);
      sub_40A8CB((_DWORD *)(this + 59000), v9, *(void **)(this + 19252), v28);
    }
    else
    {
      sub_40A8CB((_DWORD *)(this + 59000), 0, (void *)(v5 + *(_DWORD *)(this + 19252)), (unsigned int)Src);
    }
    v10 = *(_DWORD *)(*(_DWORD *)(this + 59072) + 4 * *(_DWORD *)(v4 + 16));
    v11 = *(_DWORD *)(v10 + 48);
    v12 = v10 + 20;
    v13 = (_DWORD *)(v4 + 20);
    if ( v11 > 0x40 )
    {
      sub_401C05(v13 + 6, v11);
      memcpy((void *)(v13[6] + 64), (const void *)(*(_DWORD *)(v12 + 24) + 64), *(_DWORD *)(v12 + 28) - 64);
    }
    sub_4139C2((int *)this, v13);
    v14 = v13[7];
    if ( v14 <= 0x40 )
    {
      sub_412595(v12 + 24);
    }
    else
    {
      if ( *(_DWORD *)(v12 + 28) < v14 )
        sub_401C05((_DWORD *)(v12 + 24), v13[7]);
      memcpy((void *)(*(_DWORD *)(v12 + 24) + 64), (const void *)(v13[6] + 64), v13[7] - 64);
    }
    v15 = (void *)v13[21];
    v16 = v13[22];
    v17 = 4 * v34;
    Srca = v15;
    v18 = *(void ***)(4 * v34 + *(_DWORD *)(this + 59088));
    if ( v18 )
      sub_414AA5(v18, 1);
    *(_DWORD *)(4 * v34 + *(_DWORD *)(this + 59088)) = 0;
    if ( v34 + 1 < *(_DWORD *)(this + 59092) )
    {
      v33 = v34 + 1;
      while ( 1 )
      {
        v19 = *(_DWORD *)(*(_DWORD *)(this + 59088) + v17 + 4);
        if ( !v19 || *(_DWORD *)v19 != v31 || *(_DWORD *)(v19 + 4) != v16 || *(_BYTE *)(v19 + 12) )
          break;
        sub_40A8CB((_DWORD *)(this + 59000), 0, Srca, v16);
        v20 = *(_DWORD *)(*(_DWORD *)(this + 59072) + 4 * *(_DWORD *)(v19 + 16));
        v21 = *(_DWORD *)(v20 + 48);
        v22 = v20 + 20;
        v23 = (_DWORD *)(v19 + 20);
        if ( v21 > 0x40 )
        {
          sub_401C05(v23 + 6, v21);
          memcpy((void *)(v23[6] + 64), (const void *)(*(_DWORD *)(v22 + 24) + 64), *(_DWORD *)(v22 + 28) - 64);
        }
        sub_4139C2((int *)this, v23);
        v24 = v23[7];
        if ( v24 <= 0x40 )
        {
          sub_412595(v22 + 24);
        }
        else
        {
          if ( *(_DWORD *)(v22 + 28) < v24 )
            sub_401C05((_DWORD *)(v22 + 24), v23[7]);
          memcpy((void *)(*(_DWORD *)(v22 + 24) + 64), (const void *)(v23[6] + 64), v23[7] - 64);
        }
        ++v34;
        v16 = v23[22];
        ++v33;
        Srca = (void *)v23[21];
        v25 = *(void ***)(4 * v34 + *(_DWORD *)(this + 59088));
        if ( v25 )
          sub_414AA5(v25, 1);
        *(_DWORD *)(4 * v34 + *(_DWORD *)(this + 59088)) = 0;
        if ( v33 >= *(_DWORD *)(this + 59092) )
          break;
        v17 = 4 * v34;
      }
    }
    sub_40B7BF(*(_DWORD *)this, (char *)Srca, v16);
    v26 = __CFADD__(v16, *(_DWORD *)(this + 19536));
    *(_DWORD *)(this + 19536) += v16;
    *(_BYTE *)(this + 19530) = 1;
    v32 = v28;
    *(_DWORD *)(this + 19540) += v26;
    result = *(_DWORD *)(this + 59128) & (*(_DWORD *)(this + 112) - v28);
    goto LABEL_40;
  }
  for ( i = v34; i < *(_DWORD *)(this + 59092); ++i )
  {
    result = *(_DWORD *)(*(_DWORD *)(this + 59088) + 4 * i);
    if ( result && *(_BYTE *)(result + 12) )
      *(_BYTE *)(result + 12) = 0;
  }
  *(_DWORD *)(this + 116) = v7;
  return result;
}

//----- (00414E0E) --------------------------------------------------------
void __thiscall sub_414E0E(_DWORD *this)
{
  unsigned int i; // edi
  void **v3; // ecx
  unsigned int j; // edi
  void **v5; // ecx

  sub_412595((int)(this + 14776));
  this[14780] = 0;
  for ( i = 0; i < this[14769]; ++i )
  {
    v3 = *(void ***)(this[14768] + 4 * i);
    if ( v3 )
      sub_414AA5(v3, 1);
  }
  sub_412595((int)(this + 14768));
  for ( j = 0; j < this[14773]; ++j )
  {
    v5 = *(void ***)(this[14772] + 4 * j);
    if ( v5 )
      sub_414AA5(v5, 1);
  }
  sub_412595((int)(this + 14772));
}

//----- (00414E8A) --------------------------------------------------------
unsigned int __thiscall sub_414E8A(int this)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  int v4; // ecx
  size_t v5; // esi
  unsigned int v6; // edi
  int v7; // ecx
  _BYTE *v8; // eax
  size_t v9; // edi
  int *v10; // ecx
  char *v11; // eax
  bool v12; // cf
  unsigned int v13; // ecx
  int v14; // edx
  _BYTE *v15; // eax
  int v16; // edx
  _DWORD *v17; // ecx
  _DWORD *v18; // esi
  _DWORD *v19; // edi
  int v20; // eax
  int v21; // ecx
  int v22; // esi
  unsigned int result; // eax
  int v24; // edx
  unsigned __int8 *v25; // [esp+Ch] [ebp-20h]
  unsigned int v26; // [esp+10h] [ebp-1Ch]
  size_t v27; // [esp+14h] [ebp-18h]
  unsigned int v28; // [esp+18h] [ebp-14h]
  unsigned int v29; // [esp+18h] [ebp-14h]
  int v30; // [esp+1Ch] [ebp-10h]
  unsigned int Size; // [esp+20h] [ebp-Ch]
  size_t Sizea; // [esp+20h] [ebp-Ch]
  unsigned int v33; // [esp+24h] [ebp-8h]
  _BYTE *v34; // [esp+24h] [ebp-8h]
  char v35; // [esp+2Bh] [ebp-1h]

  v2 = *(_DWORD *)(this + 59128) & (*(_DWORD *)(this + 112) - *(_DWORD *)(this + 116));
  v33 = *(_DWORD *)(this + 116);
  v26 = v2;
  v3 = v2;
  v35 = 0;
  v28 = 0;
  if ( !*(_DWORD *)(this + 72) )
    goto LABEL_33;
  v30 = 0;
  while ( 1 )
  {
    v4 = v30 + *(_DWORD *)(this + 68);
    v25 = (unsigned __int8 *)v4;
    if ( *(_BYTE *)v4 == 8 )
      goto LABEL_25;
    v5 = *(_DWORD *)(v4 + 4);
    if ( *(_BYTE *)(v4 + 13) )
    {
      if ( (*(_DWORD *)(this + 59128) & (v5 - *(_DWORD *)(this + 116))) <= v2 )
        *(_BYTE *)(v4 + 13) = 0;
      goto LABEL_25;
    }
    v6 = *(_DWORD *)(v4 + 8);
    v7 = *(_DWORD *)(this + 59128);
    v27 = v6;
    if ( (v7 & (v5 - v33)) >= v3 )
      goto LABEL_25;
    if ( v33 != v5 )
    {
      sub_413FA1(this, v33, v5);
      v7 = *(_DWORD *)(this + 59128);
      v33 = v5;
      v3 = v7 & (*(_DWORD *)(this + 112) - v5);
    }
    if ( v6 > v3 )
      break;
    if ( v6 )
    {
      Size = v7 & (v6 + v5);
      sub_401C05((_DWORD *)(this + 36), v6);
      v8 = *(_BYTE **)(this + 36);
      v34 = v8;
      if ( v5 >= Size && Size )
      {
        v9 = *(_DWORD *)(this + 59124) - v5;
        if ( *(_BYTE *)(this + 19512) )
        {
          sub_4121C1((int *)(this + 19256), v8, v5, v9);
          sub_4121C1(v10, &v34[v9], 0, Size);
        }
        else
        {
          memcpy(v8, (const void *)(v5 + *(_DWORD *)(this + 19252)), v9);
          memcpy(&v34[v9], *(const void **)(this + 19252), Size);
        }
        v6 = v27;
      }
      else if ( *(_BYTE *)(this + 19512) )
      {
        sub_4121C1((int *)(this + 19256), v8, v5, v6);
      }
      else
      {
        memcpy(v8, (const void *)(v5 + *(_DWORD *)(this + 19252)), v6);
      }
      v11 = sub_413E47((_DWORD *)this, v34, v6, v25);
      *(_BYTE *)(v30 + *(_DWORD *)(this + 68)) = 8;
      if ( v11 )
        sub_40B7BF(*(_DWORD *)this, v11, v6);
      v12 = __CFADD__(v6, *(_DWORD *)(this + 19536));
      *(_DWORD *)(this + 19536) += v6;
      *(_BYTE *)(this + 19530) = 1;
      v33 = Size;
      *(_DWORD *)(this + 19540) += v12;
      v3 = *(_DWORD *)(this + 59128) & (*(_DWORD *)(this + 112) - Size);
    }
LABEL_25:
    ++v28;
    v30 += 16;
    if ( v28 >= *(_DWORD *)(this + 72) )
      goto LABEL_33;
    v2 = v26;
  }
  *(_DWORD *)(this + 116) = v33;
  v13 = v28;
  if ( v28 < *(_DWORD *)(this + 72) )
  {
    v14 = 16 * v28;
    do
    {
      v15 = (_BYTE *)(v14 + *(_DWORD *)(this + 68));
      if ( *v15 != 8 )
        v15[13] = 0;
      ++v13;
      v14 += 16;
    }
    while ( v13 < *(_DWORD *)(this + 72) );
  }
  v35 = 1;
LABEL_33:
  v16 = 0;
  Sizea = 0;
  v29 = 0;
  if ( *(_DWORD *)(this + 72) )
  {
    v17 = (_DWORD *)(this + 68);
    do
    {
      if ( Sizea )
      {
        v18 = (_DWORD *)(v16 + *v17);
        v19 = (_DWORD *)(*v17 + 16 * (v29 - Sizea));
        *v19 = *v18++;
        *++v19 = *v18++;
        *++v19 = *v18;
        v19[1] = v18[1];
      }
      if ( *(_BYTE *)(v16 + *v17) == 8 )
        ++Sizea;
      ++v29;
      v16 += 16;
    }
    while ( v29 < *(_DWORD *)(this + 72) );
    if ( Sizea )
      sub_414449(v17, *(_DWORD *)(this + 72) - Sizea);
  }
  if ( !v35 )
  {
    sub_413FA1(this, v33, *(_DWORD *)(this + 112));
    *(_DWORD *)(this + 116) = *(_DWORD *)(this + 112);
  }
  v20 = 0x400000;
  if ( *(_DWORD *)(this + 59124) < 0x400000u )
    v20 = *(_DWORD *)(this + 59124);
  v21 = *(_DWORD *)(this + 112);
  v22 = *(_DWORD *)(this + 59128);
  result = v22 & (v21 + v20);
  *(_DWORD *)(this + 19248) = result;
  if ( result == v21
    || (v24 = *(_DWORD *)(this + 116), v24 != v21)
    && (result = v22 & (result - v21), (v22 & (unsigned int)(v24 - v21)) < result) )
  {
    result = *(_DWORD *)(this + 116);
    *(_DWORD *)(this + 19248) = result;
  }
  return result;
}
// 414F91: variable 'v10' is possibly undefined

//----- (00415133) --------------------------------------------------------
void __thiscall sub_415133(int this)
{
  char *v2; // ecx

  sub_414E0E((_DWORD *)this);
  if ( *(_DWORD *)(this + 19252) )
    free(*(void **)(this + 19252));
  sub_410DB4(*(void **)(this + 20));
  operator delete[](*(void **)(this + 32));
  v2 = *(char **)(this + 24);
  if ( v2 )
    sub_41392E(v2, 3);
  sub_401105((void **)(this + 59104));
  sub_401105((void **)(this + 59088));
  sub_401105((void **)(this + 59072));
  sub_4094C3(this + 59056);
  sub_40A7F3((void **)(this + 59000));
  sub_411B2D((_DWORD *)(this + 58204));
  sub_41205E((void **)(this + 19256));
  sub_401105((void **)(this + 68));
  sub_401105((void **)(this + 52));
  sub_401105((void **)(this + 36));
  sub_4094C3(this + 4);
}

//----- (00415206) --------------------------------------------------------
_DWORD *__thiscall sub_415206(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 0;
  this[12] = 0;
  this[13] = 0;
  this[4] = 0;
  this[22] = 0;
  this[5] = 0;
  return result;
}

//----- (00415237) --------------------------------------------------------
char __stdcall sub_415237(int a1)
{
  int v1; // ebx
  unsigned int i; // edi
  char result; // al

  v1 = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 4); v1 += 19172 )
  {
    result = sub_414487(**(_DWORD ***)a1, v1 + *(_DWORD *)a1);
    ++i;
  }
  return result;
}

//----- (00415266) --------------------------------------------------------
void __thiscall sub_415266(int this, char a2)
{
  if ( !a2 )
  {
    *(_BYTE *)(this + 58996) = 0;
    memset((void *)(this + 58560), 0, 0x1AEu);
    *(_DWORD *)(this + 58556) = 2;
    *(_DWORD *)(this + 58992) = 0;
    sub_414E0E((_DWORD *)this);
  }
  *(_BYTE *)(this + 19513) = 0;
}

//----- (004152AF) --------------------------------------------------------
char __thiscall sub_4152AF(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // ecx
  bool v5; // al

  if ( this[18] >= 0x1FFFu )
    sub_414E8A((int)this);
  v3 = this[29];
  v4 = this[28];
  v5 = v3 != v4 && (this[14782] & (unsigned int)(v3 - v4)) <= *(_DWORD *)(a2 + 4);
  *(_BYTE *)(a2 + 13) = v5;
  *(_DWORD *)(a2 + 4) = this[14782] & (*(_DWORD *)(a2 + 4) + this[28]);
  sub_414463(this + 17, *(_DWORD *)a2, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return 1;
}

//----- (0041530F) --------------------------------------------------------
void __thiscall sub_41530F(int this, char a2)
{
  unsigned int v3; // eax

  if ( !a2 )
  {
    memset((void *)(this + 84), 0, 0x10u);
    *(_DWORD *)(this + 100) = 0;
    *(_DWORD *)(this + 104) = 0;
    *(_DWORD *)(this + 108) = 0;
    memset((void *)(this + 148), 0, 0x4A9Cu);
    v3 = *(_DWORD *)(this + 59124);
    *(_DWORD *)(this + 116) = 0;
    *(_DWORD *)(this + 112) = 0;
    if ( v3 >= 0x400000 )
      v3 = 0x400000;
    *(_DWORD *)(this + 19248) = v3 & *(_DWORD *)(this + 59128);
    sub_412595(this + 68);
  }
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 19536) = 0;
  *(_DWORD *)(this + 19540) = 0;
  *(_DWORD *)(this + 120) = 0;
  *(_DWORD *)(this + 124) = 0;
  memset((void *)(this + 128), 0, 0x14u);
  *(_DWORD *)(this + 128) = -1;
  *(_BYTE *)(this + 19513) = 0;
  sub_415266(this, a2);
}

//----- (004153B7) --------------------------------------------------------
char __thiscall sub_4153B7(int this, int a2)
{
  unsigned int v2; // edi
  bool i; // cf
  int v5; // eax
  int v6; // ecx
  int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  int v10; // eax
  int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // edx
  unsigned int v14; // ebx
  unsigned int v15; // eax
  unsigned int v16; // edi
  int v17; // ebx
  _BYTE *v18; // edi
  _BYTE *v19; // ebx
  unsigned int v20; // eax
  bool v21; // cc
  int v22; // edx
  int v23; // eax
  unsigned int v24; // edx
  _DWORD *v25; // ecx
  unsigned int v26; // ecx
  unsigned int v27; // ebx
  unsigned int v28; // eax
  unsigned int v29; // edi
  int v30; // ebx
  unsigned int v31; // eax
  int v32; // edx
  unsigned int v33; // ecx
  unsigned int v34; // edx
  unsigned int v35; // ebx
  unsigned int v36; // eax
  unsigned int v37; // edi
  int v38; // ebx
  unsigned int v39; // eax
  int v40; // edx
  int v41; // eax
  int v42; // edi
  char v44[4]; // [esp+Ch] [ebp-1Ch] BYREF
  int v45; // [esp+10h] [ebp-18h]
  int v46; // [esp+14h] [ebp-14h]
  char v47; // [esp+18h] [ebp-10h]
  unsigned int v48; // [esp+1Ch] [ebp-Ch]
  unsigned int v49; // [esp+20h] [ebp-8h]
  unsigned int v50; // [esp+24h] [ebp-4h]
  unsigned int v51; // [esp+30h] [ebp+8h]
  unsigned int v52; // [esp+30h] [ebp+8h]

  v2 = *(_DWORD *)(a2 + 19156);
  v48 = v2 + 12 * *(_DWORD *)(a2 + 19160);
  for ( i = v2 < v48; ; i = v50 + 12 < v48 )
  {
    v50 = v2;
    if ( !i )
      return 1;
    v5 = *(_DWORD *)(this + 59128);
    *(_DWORD *)(this + 112) &= v5;
    v6 = *(_DWORD *)(this + 112);
    if ( (v5 & (unsigned int)(*(_DWORD *)(this + 19248) - v6)) < 0x1004 && *(_DWORD *)(this + 19248) != v6 )
    {
      sub_414E8A(this);
      if ( *(_QWORD *)(this + 19536) > *(_QWORD *)(this + 19520) )
        break;
    }
    v7 = *(_DWORD *)v2;
    if ( !*(_DWORD *)v2 )
    {
      if ( *(_WORD *)(v2 + 4) == 3 && (v8 = *(_DWORD *)(this + 112), v8 < *(_DWORD *)(this + 59124) - 4) )
      {
        *(_DWORD *)(v8 + *(_DWORD *)(this + 19252)) = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(this + 112) += 4;
      }
      else
      {
        v9 = 0;
        do
          *(_BYTE *)((*(_DWORD *)(this + 59128) & (*(_DWORD *)(this + 112))++) + *(_DWORD *)(this + 19252)) = *(_BYTE *)(v2 + v9++ + 8);
        while ( v9 <= *(unsigned __int16 *)(v2 + 4) );
      }
      goto LABEL_80;
    }
    switch ( v7 )
    {
      case 1:
        v10 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(this + 96) = *(_DWORD *)(this + 92);
        *(_DWORD *)(this + 92) = *(_DWORD *)(this + 88);
        v11 = *(_DWORD *)(this + 84);
        *(_DWORD *)(this + 84) = v10;
        *(_DWORD *)(this + 88) = v11;
        v12 = *(_DWORD *)(this + 112);
        *(_DWORD *)(this + 104) = *(unsigned __int16 *)(v2 + 4);
        v13 = *(_DWORD *)(v2 + 8);
        v14 = *(unsigned __int16 *)(v2 + 4);
        v15 = v12 - v13;
        v16 = *(_DWORD *)(this + 59124) - 4097;
        v51 = v14;
        if ( v12 - v13 < v16 && v12 < v16 )
        {
          v17 = *(_DWORD *)(this + 19252);
          v18 = (_BYTE *)(v17 + v15);
          v19 = (_BYTE *)(v12 + v17);
          *(_DWORD *)(this + 112) = v51 + v12;
          if ( v13 >= v51 )
          {
            if ( v51 >= 8 )
            {
              v49 = v51 >> 3;
              do
              {
                memcpy(v19, v18, 8u);
                v51 -= 8;
                v18 += 8;
                v19 += 8;
                --v49;
              }
              while ( v49 );
            }
          }
          else if ( v51 >= 8 )
          {
            v20 = v51 >> 3;
            do
            {
              v51 -= 8;
              *v19 = *v18;
              v19[1] = v18[1];
              v19[2] = v18[2];
              v19[3] = v18[3];
              v19[4] = v18[4];
              v19[5] = v18[5];
              v19[6] = v18[6];
              v19[7] = v18[7];
              v18 += 8;
              v19 += 8;
              --v20;
            }
            while ( v20 );
          }
LABEL_23:
          if ( !v51 )
            break;
          *v19 = *v18;
          if ( v51 <= 1 )
            break;
          v19[1] = v18[1];
          if ( v51 <= 2 )
            break;
          v19[2] = v18[2];
          if ( v51 <= 3 )
            break;
          v19[3] = v18[3];
          if ( v51 <= 4 )
            break;
          v19[4] = v18[4];
          if ( v51 <= 5 )
            break;
          v19[5] = v18[5];
          v21 = v51 <= 6;
          goto LABEL_30;
        }
        if ( v14 )
        {
          v22 = *(_DWORD *)(this + 59128);
          do
          {
            *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v15 & v22)
                                                                                       + *(_DWORD *)(this + 19252));
            v22 = *(_DWORD *)(this + 59128);
            --v14;
            ++v15;
            *(_DWORD *)(this + 112) = v22 & (*(_DWORD *)(this + 112) + 1);
          }
          while ( v14 );
        }
        break;
      case 3:
        v23 = *(_DWORD *)(v2 + 8);
        v24 = *(_DWORD *)(this + 4 * v23 + 84);
        if ( v23 )
        {
          v25 = (_DWORD *)(this + 4 * v23 + 84);
          do
          {
            *v25 = *(v25 - 1);
            --v23;
            --v25;
          }
          while ( v23 );
        }
        v26 = *(_DWORD *)(this + 112);
        *(_DWORD *)(this + 84) = v24;
        *(_DWORD *)(this + 104) = *(unsigned __int16 *)(v2 + 4);
        v27 = *(unsigned __int16 *)(v2 + 4);
        v28 = v26 - v24;
        v29 = *(_DWORD *)(this + 59124) - 4097;
        v51 = v27;
        if ( v26 - v24 < v29 && v26 < v29 )
        {
          v30 = *(_DWORD *)(this + 19252);
          v18 = (_BYTE *)(v30 + v28);
          v19 = (_BYTE *)(v26 + v30);
          *(_DWORD *)(this + 112) = v51 + v26;
          if ( v24 >= v51 )
          {
            if ( v51 >= 8 )
            {
              v49 = v51 >> 3;
              do
              {
                memcpy(v19, v18, 8u);
                v51 -= 8;
                v18 += 8;
                v19 += 8;
                --v49;
              }
              while ( v49 );
            }
          }
          else if ( v51 >= 8 )
          {
            v31 = v51 >> 3;
            do
            {
              v51 -= 8;
              *v19 = *v18;
              v19[1] = v18[1];
              v19[2] = v18[2];
              v19[3] = v18[3];
              v19[4] = v18[4];
              v19[5] = v18[5];
              v19[6] = v18[6];
              v19[7] = v18[7];
              v18 += 8;
              v19 += 8;
              --v31;
            }
            while ( v31 );
          }
          goto LABEL_23;
        }
        if ( v27 )
        {
          v32 = *(_DWORD *)(this + 59128);
          do
          {
            *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v28 & v32)
                                                                                       + *(_DWORD *)(this + 19252));
            v32 = *(_DWORD *)(this + 59128);
            --v27;
            ++v28;
            *(_DWORD *)(this + 112) = v32 & (*(_DWORD *)(this + 112) + 1);
          }
          while ( v27 );
        }
        break;
      case 2:
        if ( !*(_DWORD *)(this + 104) )
          break;
        v33 = *(_DWORD *)(this + 112);
        v34 = *(_DWORD *)(this + 84);
        v35 = *(_DWORD *)(this + 104);
        v36 = v33 - v34;
        v37 = *(_DWORD *)(this + 59124) - 4097;
        v52 = v35;
        if ( v33 - v34 >= v37 || v33 >= v37 )
        {
          if ( v35 )
          {
            v40 = *(_DWORD *)(this + 59128);
            do
            {
              *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v36 & v40)
                                                                                         + *(_DWORD *)(this + 19252));
              v40 = *(_DWORD *)(this + 59128);
              --v35;
              ++v36;
              *(_DWORD *)(this + 112) = v40 & (*(_DWORD *)(this + 112) + 1);
            }
            while ( v35 );
          }
        }
        else
        {
          v38 = *(_DWORD *)(this + 19252);
          v18 = (_BYTE *)(v38 + v36);
          v19 = (_BYTE *)(v33 + v38);
          *(_DWORD *)(this + 112) = v52 + v33;
          if ( v34 >= v52 )
          {
            if ( v52 >= 8 )
            {
              v49 = v52 >> 3;
              do
              {
                memcpy(v19, v18, 8u);
                v52 -= 8;
                v18 += 8;
                v19 += 8;
                --v49;
              }
              while ( v49 );
            }
          }
          else if ( v52 >= 8 )
          {
            v39 = v52 >> 3;
            do
            {
              v52 -= 8;
              *v19 = *v18;
              v19[1] = v18[1];
              v19[2] = v18[2];
              v19[3] = v18[3];
              v19[4] = v18[4];
              v19[5] = v18[5];
              v19[6] = v18[6];
              v19[7] = v18[7];
              v18 += 8;
              v19 += 8;
              --v39;
            }
            while ( v39 );
          }
          if ( v52 )
          {
            *v19 = *v18;
            if ( v52 != 1 )
            {
              v19[1] = v18[1];
              if ( v52 > 2 )
              {
                v19[2] = v18[2];
                if ( v52 > 3 )
                {
                  v19[3] = v18[3];
                  if ( v52 > 4 )
                  {
                    v19[4] = v18[4];
                    if ( v52 > 5 )
                    {
                      v21 = v52 <= 6;
                      v19[5] = v18[5];
LABEL_30:
                      if ( !v21 )
                        v19[6] = v18[6];
                    }
                  }
                }
              }
            }
          }
        }
        break;
      case 4:
        v44[0] = *(_BYTE *)(v2 + 4);
        v41 = *(_DWORD *)(v2 + 8);
        v42 = v2 + 12;
        v45 = v41;
        v47 = *(_BYTE *)(v42 + 4);
        v46 = *(_DWORD *)(v42 + 8);
        v50 = v42;
        sub_4152AF((_DWORD *)this, (int)v44);
        break;
    }
LABEL_80:
    v2 = v50 + 12;
  }
  return 0;
}
// 4153B7: using guessed type char var_1C[4];

//----- (004158D3) --------------------------------------------------------
bool __thiscall sub_4158D3(int this, int a2)
{
  bool result; // al
  int v5; // eax
  int *v6; // esi
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  __int16 v12; // ax
  int v13; // edx
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // eax
  unsigned int v18; // edx
  unsigned int *v19; // ecx
  unsigned int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // eax
  __int16 v25; // ax
  int v26; // edx
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned int v29; // ecx
  unsigned int v30; // eax
  unsigned int v31; // edx
  unsigned int *v32; // ecx
  unsigned int v33; // ecx
  unsigned int v34; // eax
  unsigned int v35; // ecx
  unsigned int v36; // edx
  unsigned int v37; // eax
  __int16 v38; // ax
  int v39; // edx
  unsigned int v40; // eax
  unsigned int v41; // eax
  unsigned int v42; // ecx
  int v43; // eax
  unsigned int v44; // edx
  unsigned int *v45; // ecx
  unsigned int v46; // ecx
  unsigned int v47; // eax
  unsigned int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // edx
  unsigned int v51; // eax
  unsigned int v52; // eax
  unsigned int v53; // ecx
  unsigned int v54; // edx
  int v55; // edx
  unsigned int v56; // ecx
  void *v57; // edx
  _BYTE *v58; // eax
  _BYTE *v59; // ecx
  _BYTE *v60; // ecx
  _BYTE *v61; // eax
  int v62; // edx
  int v63; // eax
  unsigned int v64; // ecx
  unsigned int v65; // eax
  unsigned int v66; // edx
  int v67; // edx
  void *v68; // edx
  _BYTE *v69; // eax
  _BYTE *v70; // ecx
  int v71; // edx
  int v72; // ecx
  bool v73; // zf
  unsigned int v74; // eax
  int *v75; // ecx
  __int16 v76; // ax
  int v77; // edx
  unsigned int v78; // eax
  unsigned int v79; // eax
  unsigned int v80; // ecx
  unsigned int v81; // eax
  unsigned int v82; // edx
  unsigned int *v83; // ecx
  unsigned int v84; // ecx
  unsigned int v85; // eax
  unsigned int v86; // eax
  unsigned int v87; // eax
  unsigned int v88; // eax
  unsigned int v89; // edx
  unsigned int v90; // ecx
  int v91; // ecx
  int v92; // edx
  int v93; // ecx
  int v94; // eax
  char v95; // dl
  int v96; // ecx
  char v97[16]; // [esp+8h] [ebp-30h] BYREF
  int v98; // [esp+18h] [ebp-20h]
  int v99; // [esp+1Ch] [ebp-1Ch]
  int v100; // [esp+20h] [ebp-18h]
  unsigned int v101; // [esp+24h] [ebp-14h]
  unsigned int v102; // [esp+28h] [ebp-10h]
  unsigned int v103; // [esp+2Ch] [ebp-Ch]
  void *v104; // [esp+30h] [ebp-8h]
  void *Src; // [esp+34h] [ebp-4h]
  int v106; // [esp+40h] [ebp+8h]
  int v107; // [esp+40h] [ebp+8h]
  int v108; // [esp+40h] [ebp+8h]
  unsigned int v109; // [esp+40h] [ebp+8h]
  int v110; // [esp+40h] [ebp+8h]
  unsigned int v111; // [esp+40h] [ebp+8h]
  unsigned int v112; // [esp+40h] [ebp+8h]
  int v113; // [esp+40h] [ebp+8h]
  int v114; // [esp+40h] [ebp+8h]

  if ( !*(_BYTE *)(a2 + 44) )
  {
    *(_BYTE *)(a2 + 44) = 1;
    result = sub_41416C((_DWORD *)this, a2 + 4, a2 + 24, (unsigned int *)(a2 + 48));
    if ( !result )
    {
      *(_BYTE *)(a2 + 19152) = 1;
      return result;
    }
  }
  v5 = *(_DWORD *)(a2 + 24);
  v6 = (int *)(a2 + 4);
  if ( *(_DWORD *)(a2 + 4) > v5 + *(_DWORD *)(a2 + 36) )
  {
    *(_BYTE *)(a2 + 19152) = 1;
    return 0;
  }
  v7 = *(_DWORD *)(a2 + 32) + v5 - 1;
  v8 = *(_DWORD *)(a2 + 19148) - 16;
  v99 = v7;
  v98 = v8;
  v100 = v7;
  if ( v7 >= v8 )
    v100 = v8;
  while ( 1 )
  {
    v9 = *(_DWORD *)(this + 59128);
    *(_DWORD *)(this + 112) &= v9;
    v10 = *v6;
    if ( *v6 >= v100 )
    {
      if ( v10 > v99 || v10 == v99 && *(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 28) )
        return 1;
      if ( v10 >= v98 && !*(_BYTE *)(a2 + 19154) || v10 >= *(_DWORD *)(a2 + 19148) )
        break;
    }
    v11 = *(_DWORD *)(this + 112);
    if ( (v9 & (unsigned int)(*(_DWORD *)(this + 19248) - v11)) < 0x1004 && *(_DWORD *)(this + 19248) != v11 )
    {
      sub_414E8A(this);
      if ( *(_QWORD *)(this + 19536) > *(_QWORD *)(this + 19520) )
        return 0;
    }
    v12 = sub_4094F9((_DWORD *)(a2 + 4));
    v13 = *(_DWORD *)(a2 + 180);
    v14 = v12 & 0xFFFE;
    if ( v14 >= *(_DWORD *)(a2 + 4 * v13 + 52) )
    {
      v18 = v13 + 1;
      v106 = 15;
      if ( v18 < 0xF )
      {
        v19 = (unsigned int *)(a2 + 4 * v18 + 52);
        while ( v14 >= *v19 )
        {
          ++v18;
          ++v19;
          if ( v18 >= 0xF )
            goto LABEL_27;
        }
        v106 = v18;
      }
LABEL_27:
      v20 = v106 + *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 4) += v20 >> 3;
      *(_DWORD *)(a2 + 8) = v20 & 7;
      v21 = *(_DWORD *)(a2 + 4 * v106 + 116) + ((v14 - *(_DWORD *)(a2 + 4 * v106 + 48)) >> (16 - v106));
      if ( v21 >= *(_DWORD *)(a2 + 48) )
        v21 = 0;
      v17 = *(unsigned __int16 *)(a2 + 2 * v21 + 3256);
    }
    else
    {
      v15 = v14 >> (16 - v13);
      v16 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v15 + a2 + 184);
      *v6 += v16 >> 3;
      *(_DWORD *)(a2 + 8) = v16 & 7;
      v17 = *(unsigned __int16 *)(a2 + 2 * v15 + 1208);
    }
    if ( v17 >= 0x100 )
    {
      if ( v17 < 0x106 )
      {
        if ( v17 == 256 )
        {
          if ( !sub_413DD1((_DWORD *)this, a2 + 4, (int)v97) || !sub_4152AF((_DWORD *)this, (int)v97) )
            return 1;
        }
        else if ( v17 == 257 )
        {
          if ( *(_DWORD *)(this + 104) )
          {
            v64 = *(_DWORD *)(this + 112);
            v112 = *(_DWORD *)(this + 104);
            v65 = v64 - *(_DWORD *)(this + 84);
            v66 = *(_DWORD *)(this + 59124) - 4097;
            v101 = v65;
            if ( v65 < v66 && v64 < v66 )
            {
              v67 = *(_DWORD *)(this + 19252);
              v104 = (void *)(v67 + v65);
              v68 = (void *)(v64 + v67);
              Src = v68;
              *(_DWORD *)(this + 112) = v112 + v64;
              if ( *(_DWORD *)(this + 84) >= v112 )
              {
                if ( v112 >= 8 )
                {
                  v101 = v112 >> 3;
                  do
                  {
                    memcpy(Src, v104, 8u);
                    v104 = (char *)v104 + 8;
                    Src = (char *)Src + 8;
                    v112 -= 8;
                    --v101;
                  }
                  while ( v101 );
                }
                goto LABEL_110;
              }
              if ( v112 >= 8 )
              {
                v101 = v112 >> 3;
                v69 = v104;
                v70 = v68;
                do
                {
                  v112 -= 8;
                  *v70 = *v69;
                  v70[1] = v69[1];
                  v70[2] = v69[2];
                  v70[3] = v69[3];
                  v70[4] = v69[4];
                  v70[5] = v69[5];
                  v70[6] = v69[6];
                  v70[7] = v69[7];
                  v69 += 8;
                  v70 += 8;
                  --v101;
                }
                while ( v101 );
LABEL_106:
                Src = v70;
                v104 = v69;
                goto LABEL_110;
              }
              goto LABEL_110;
            }
            if ( v112 )
            {
              v71 = *(_DWORD *)(this + 59128);
              do
              {
                --v112;
                *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v71 & v65)
                                                                                           + *(_DWORD *)(this + 19252));
                v71 = *(_DWORD *)(this + 59128);
                v65 = v101 + 1;
                v72 = v71 & (*(_DWORD *)(this + 112) + 1);
                ++v101;
                *(_DWORD *)(this + 112) = v72;
              }
              while ( v112 );
            }
          }
        }
        else
        {
          v73 = v17 == 258;
          v74 = v17 - 258;
          v75 = (int *)(this + 4 * v74 + 84);
          v101 = *v75;
          if ( !v73 )
          {
            do
            {
              *v75 = *(v75 - 1);
              --v74;
              --v75;
            }
            while ( v74 );
          }
          *(_DWORD *)(this + 84) = v101;
          v76 = sub_4094F9((_DWORD *)(a2 + 4));
          v77 = *(_DWORD *)(a2 + 11640);
          v78 = v76 & 0xFFFE;
          if ( v78 >= *(_DWORD *)(a2 + 4 * v77 + 11512) )
          {
            v82 = v77 + 1;
            v113 = 15;
            if ( v82 < 0xF )
            {
              v83 = (unsigned int *)(a2 + 4 * v82 + 11512);
              while ( v78 >= *v83 )
              {
                ++v82;
                ++v83;
                if ( v82 >= 0xF )
                  goto LABEL_132;
              }
              v113 = v82;
            }
LABEL_132:
            v84 = v113 + *(_DWORD *)(a2 + 8);
            *(_DWORD *)(a2 + 4) += v84 >> 3;
            *(_DWORD *)(a2 + 8) = v84 & 7;
            v85 = *(_DWORD *)(a2 + 4 * v113 + 11576) + ((v78 - *(_DWORD *)(a2 + 4 * v113 + 11508)) >> (16 - v113));
            if ( v85 >= *(_DWORD *)(a2 + 11508) )
              v85 = 0;
            v81 = *(unsigned __int16 *)(a2 + 2 * v85 + 14716);
          }
          else
          {
            v79 = v78 >> (16 - v77);
            v80 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v79 + a2 + 11644);
            *v6 += v80 >> 3;
            *(_DWORD *)(a2 + 8) = v80 & 7;
            v81 = *(unsigned __int16 *)(a2 + 2 * v79 + 12668);
          }
          if ( v81 >= 8 )
          {
            v114 = (v81 >> 2) - 1;
            v86 = ((v81 & 3 | 4) << v114) + 2;
            v102 = v86;
            if ( v114 )
            {
              v87 = sub_4094F9((_DWORD *)(a2 + 4));
              v102 += v87 >> (16 - v114);
              v88 = v114 + *(_DWORD *)(a2 + 8);
              *v6 += v88 >> 3;
              *(_DWORD *)(a2 + 8) = v88 & 7;
              v86 = v102;
            }
          }
          else
          {
            v86 = v81 + 2;
            v102 = v86;
          }
          v89 = *(_DWORD *)(this + 112) - v101;
          v90 = *(_DWORD *)(this + 59124) - 4097;
          *(_DWORD *)(this + 104) = v86;
          v112 = v86;
          v103 = v89;
          if ( v89 >= v90 || *(_DWORD *)(this + 112) >= v90 )
          {
            if ( v86 )
            {
              v93 = *(_DWORD *)(this + 59128);
              do
              {
                v94 = *(_DWORD *)(this + 19252);
                --v112;
                v95 = *(_BYTE *)((v93 & v103) + v94);
                v96 = *(_DWORD *)(this + 112);
                ++v103;
                *(_BYTE *)(v94 + v96) = v95;
                v93 = *(_DWORD *)(this + 59128);
                *(_DWORD *)(this + 112) = v93 & (*(_DWORD *)(this + 112) + 1);
              }
              while ( v112 );
            }
          }
          else
          {
            v91 = *(_DWORD *)(this + 19252);
            v104 = (void *)(v91 + v89);
            v92 = *(_DWORD *)(this + 112);
            Src = (void *)(v92 + v91);
            *(_DWORD *)(this + 112) = v86 + v92;
            if ( v101 >= v86 )
            {
              if ( v86 >= 8 )
              {
                v101 = v102 >> 3;
                do
                {
                  memcpy(Src, v104, 8u);
                  v104 = (char *)v104 + 8;
                  Src = (char *)Src + 8;
                  v112 -= 8;
                  --v101;
                }
                while ( v101 );
              }
              goto LABEL_110;
            }
            if ( v86 >= 8 )
            {
              v70 = Src;
              v101 = v102 >> 3;
              v69 = v104;
              do
              {
                v112 -= 8;
                *v70 = *v69;
                v70[1] = v69[1];
                v70[2] = v69[2];
                v70[3] = v69[3];
                v70[4] = v69[4];
                v70[5] = v69[5];
                v70[6] = v69[6];
                v70[7] = v69[7];
                v69 += 8;
                v70 += 8;
                --v101;
              }
              while ( v101 );
              goto LABEL_106;
            }
LABEL_110:
            if ( v112 )
            {
              v60 = Src;
              *(_BYTE *)Src = *(_BYTE *)v104;
              if ( v112 != 1 )
              {
                v60[1] = *((_BYTE *)v104 + 1);
                if ( v112 > 2 )
                {
                  v60[2] = *((_BYTE *)v104 + 2);
                  if ( v112 > 3 )
                  {
                    v60[3] = *((_BYTE *)v104 + 3);
                    if ( v112 > 4 )
                    {
                      v60[4] = *((_BYTE *)v104 + 4);
                      if ( v112 > 5 )
                      {
                        v60[5] = *((_BYTE *)v104 + 5);
                        if ( v112 > 6 )
                        {
                          v61 = v104;
LABEL_89:
                          v60[6] = v61[6];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v22 = v17 - 262;
        if ( v22 >= 8 )
        {
          v107 = (v22 >> 2) - 1;
          v104 = (void *)(((v22 & 3 | 4) << v107) + 2);
          if ( v22 >> 2 != 1 )
          {
            v23 = sub_4094F9((_DWORD *)(a2 + 4));
            v104 = (char *)v104 + (v23 >> (16 - v107));
            v24 = v107 + *(_DWORD *)(a2 + 8);
            *v6 += v24 >> 3;
            *(_DWORD *)(a2 + 8) = v24 & 7;
          }
        }
        else
        {
          v104 = (void *)(v22 + 2);
        }
        v103 = (unsigned int)v104;
        v25 = sub_4094F9((_DWORD *)(a2 + 4));
        v26 = *(_DWORD *)(a2 + 4000);
        v27 = v25 & 0xFFFE;
        if ( v27 >= *(_DWORD *)(a2 + 4 * v26 + 3872) )
        {
          v31 = v26 + 1;
          v108 = 15;
          if ( v31 < 0xF )
          {
            v32 = (unsigned int *)(a2 + 4 * v31 + 3872);
            while ( v27 >= *v32 )
            {
              ++v31;
              ++v32;
              if ( v31 >= 0xF )
                goto LABEL_45;
            }
            v108 = v31;
          }
LABEL_45:
          v33 = v108 + *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a2 + 4) += v33 >> 3;
          *(_DWORD *)(a2 + 8) = v33 & 7;
          v34 = *(_DWORD *)(a2 + 4 * v108 + 3936) + ((v27 - *(_DWORD *)(a2 + 4 * v108 + 3868)) >> (16 - v108));
          if ( v34 >= *(_DWORD *)(a2 + 3868) )
            v34 = 0;
          v30 = *(unsigned __int16 *)(a2 + 2 * v34 + 7076);
        }
        else
        {
          v28 = v27 >> (16 - v26);
          v29 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v28 + a2 + 4004);
          *v6 += v29 >> 3;
          *(_DWORD *)(a2 + 8) = v29 & 7;
          v30 = *(unsigned __int16 *)(a2 + 2 * v28 + 5028);
        }
        if ( v30 >= 4 )
        {
          v35 = (v30 >> 1) - 1;
          v109 = v35;
          v102 = ((v30 & 1 | 2) << v35) + 1;
          if ( v30 >> 1 != 1 )
          {
            if ( v35 < 4 )
            {
              v48 = sub_41262C((_DWORD *)(a2 + 4));
              v102 += v48 >> (32 - v109);
              v49 = v109 + *(_DWORD *)(a2 + 8);
              *v6 += v49 >> 3;
              *(_DWORD *)(a2 + 8) = v49 & 7;
            }
            else
            {
              if ( v35 > 4 )
              {
                v36 = sub_41262C((_DWORD *)(a2 + 4));
                v37 = v109 + *(_DWORD *)(a2 + 8) - 4;
                v102 += 16 * (v36 >> (36 - v109));
                *v6 += v37 >> 3;
                *(_DWORD *)(a2 + 8) = v37 & 7;
              }
              v38 = sub_4094F9((_DWORD *)(a2 + 4));
              v39 = *(_DWORD *)(a2 + 7820);
              v40 = v38 & 0xFFFE;
              if ( v40 >= *(_DWORD *)(a2 + 4 * v39 + 7692) )
              {
                v44 = v39 + 1;
                v110 = 15;
                if ( v44 < 0xF )
                {
                  v45 = (unsigned int *)(a2 + 4 * v44 + 7692);
                  while ( v40 >= *v45 )
                  {
                    ++v44;
                    ++v45;
                    if ( v44 >= 0xF )
                      goto LABEL_62;
                  }
                  v110 = v44;
                }
LABEL_62:
                v46 = v110 + *(_DWORD *)(a2 + 8);
                *(_DWORD *)(a2 + 4) += v46 >> 3;
                *(_DWORD *)(a2 + 8) = v46 & 7;
                v47 = *(_DWORD *)(a2 + 4 * v110 + 7756) + ((v40 - *(_DWORD *)(a2 + 4 * v110 + 7688)) >> (16 - v110));
                if ( v47 >= *(_DWORD *)(a2 + 7688) )
                  v47 = 0;
                v43 = *(unsigned __int16 *)(a2 + 2 * v47 + 10896);
              }
              else
              {
                v41 = v40 >> (16 - v39);
                v42 = *(_DWORD *)(a2 + 8) + *(unsigned __int8 *)(v41 + a2 + 7824);
                *v6 += v42 >> 3;
                *(_DWORD *)(a2 + 8) = v42 & 7;
                v43 = *(unsigned __int16 *)(a2 + 2 * v41 + 8848);
              }
              v102 += v43;
            }
          }
        }
        else
        {
          v102 = v30 + 1;
        }
        v50 = v102;
        if ( v102 > 0x100 )
        {
          v103 = (unsigned int)v104 + 1;
          if ( v102 > 0x2000 )
          {
            ++v103;
            if ( v102 > 0x40000 )
              ++v103;
          }
        }
        *(_DWORD *)(this + 96) = *(_DWORD *)(this + 92);
        *(_DWORD *)(this + 92) = *(_DWORD *)(this + 88);
        *(_DWORD *)(this + 88) = *(_DWORD *)(this + 84);
        v51 = v103;
        *(_DWORD *)(this + 104) = v103;
        v111 = v51;
        v52 = *(_DWORD *)(this + 112);
        v53 = v52 - v50;
        *(_DWORD *)(this + 84) = v50;
        v54 = *(_DWORD *)(this + 59124) - 4097;
        v101 = v53;
        if ( v53 >= v54 || v52 >= v54 )
        {
          if ( v103 )
          {
            v62 = *(_DWORD *)(this + 59128);
            do
            {
              --v111;
              *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v62 & v53)
                                                                                         + *(_DWORD *)(this + 19252));
              v62 = *(_DWORD *)(this + 59128);
              v53 = v101 + 1;
              v63 = v62 & (*(_DWORD *)(this + 112) + 1);
              ++v101;
              *(_DWORD *)(this + 112) = v63;
            }
            while ( v111 );
          }
        }
        else
        {
          v55 = *(_DWORD *)(this + 19252);
          Src = (void *)(v55 + v53);
          v56 = v103;
          v57 = (void *)(v52 + v55);
          v104 = v57;
          *(_DWORD *)(this + 112) = v103 + v52;
          if ( v102 >= v56 )
          {
            if ( v56 >= 8 )
            {
              v101 = v103 >> 3;
              do
              {
                memcpy(v104, Src, 8u);
                Src = (char *)Src + 8;
                v104 = (char *)v104 + 8;
                v111 -= 8;
                --v101;
              }
              while ( v101 );
            }
          }
          else if ( v56 >= 8 )
          {
            v101 = v56 >> 3;
            v58 = Src;
            v59 = v57;
            do
            {
              v111 -= 8;
              *v59 = *v58;
              v59[1] = v58[1];
              v59[2] = v58[2];
              v59[3] = v58[3];
              v59[4] = v58[4];
              v59[5] = v58[5];
              v59[6] = v58[6];
              v59[7] = v58[7];
              v58 += 8;
              v59 += 8;
              --v101;
            }
            while ( v101 );
            v104 = v59;
            Src = v58;
          }
          if ( v111 )
          {
            v60 = v104;
            *(_BYTE *)v104 = *(_BYTE *)Src;
            if ( v111 != 1 )
            {
              v60[1] = *((_BYTE *)Src + 1);
              if ( v111 > 2 )
              {
                v60[2] = *((_BYTE *)Src + 2);
                if ( v111 > 3 )
                {
                  v60[3] = *((_BYTE *)Src + 3);
                  if ( v111 > 4 )
                  {
                    v60[4] = *((_BYTE *)Src + 4);
                    if ( v111 > 5 )
                    {
                      v60[5] = *((_BYTE *)Src + 5);
                      if ( v111 > 6 )
                      {
                        v61 = Src;
                        goto LABEL_89;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(this + 19252) + (*(_DWORD *)(this + 112))++) = v17;
    }
  }
  *(_BYTE *)(a2 + 19155) = 1;
  return 1;
}

//----- (004162C9) --------------------------------------------------------
char __thiscall sub_4162C9(int this, char a2, void *Src, signed int Size)
{
  _DWORD *v5; // edi
  size_t v6; // eax
  int v7; // eax
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned int *v10; // eax
  unsigned int *v11; // edi
  _DWORD *v13; // eax
  int v14; // ebx
  int v15; // eax
  unsigned int *v16; // ebx
  int v17; // eax
  unsigned int v18; // eax
  int v19; // eax
  _DWORD *v20; // ecx
  int v21; // edx
  int v22; // eax
  unsigned int v23; // ebx
  int v24; // eax
  unsigned int v25; // eax
  int v26; // eax
  int v27; // ecx
  bool v28; // al
  int *v29; // ebx
  unsigned int v30; // eax
  unsigned int v31; // esi
  unsigned int v32; // eax
  unsigned int v33; // ebx
  int v34; // esi
  bool v35; // zf
  _BYTE *v36; // ebx
  int v37; // eax
  _DWORD *v38; // ecx
  int v39; // esi
  int v40; // eax
  _DWORD *v41; // ebx
  _DWORD *v42; // esi
  unsigned int v43; // eax
  unsigned int v44; // edi
  int v45; // edi
  int v46; // esi
  _DWORD *v47; // ebx
  _DWORD *v48; // [esp-4h] [ebp-40h]
  void *Block; // [esp+Ch] [ebp-30h] BYREF
  int v50; // [esp+1Ch] [ebp-20h]
  int v51; // [esp+20h] [ebp-1Ch]
  int v52; // [esp+24h] [ebp-18h]
  int v53; // [esp+28h] [ebp-14h]
  _DWORD *v54; // [esp+2Ch] [ebp-10h]
  int v55; // [esp+38h] [ebp-4h]
  unsigned int v56; // [esp+44h] [ebp+8h]
  unsigned int Srca; // [esp+48h] [ebp+Ch]
  int Srcb; // [esp+48h] [ebp+Ch]
  _DWORD *Srcc; // [esp+48h] [ebp+Ch]
  unsigned int Sizea; // [esp+4Ch] [ebp+10h]
  size_t Sizeb; // [esp+4Ch] [ebp+10h]
  int *Sizec; // [esp+4Ch] [ebp+10h]
  bool Size_3; // [esp+4Fh] [ebp+13h]

  v5 = (_DWORD *)(this + 59056);
  *(_DWORD *)(this + 59060) = 0;
  *(_DWORD *)(this + 59056) = 0;
  v6 = 0x8000;
  v54 = (_DWORD *)(this + 59056);
  if ( Size <= 0x8000 )
    v6 = Size;
  memcpy(*(void **)(this + 59068), Src, v6);
  v53 = this + 59000;
  sub_40A807((_DWORD *)(this + 59000));
  if ( a2 >= 0 )
  {
    Srca = *(_DWORD *)(this + 59120);
    v8 = Srca;
  }
  else
  {
    v7 = sub_40A82D(v5);
    v8 = v7;
    Srca = v7;
    if ( v7 )
    {
      v8 = v7 - 1;
      Srca = v7 - 1;
    }
    else
    {
      sub_414E0E((_DWORD *)this);
    }
  }
  v9 = *(_DWORD *)(this + 59076);
  if ( v8 > v9 || v8 > *(_DWORD *)(this + 59108) )
    return 0;
  *(_DWORD *)(this + 59120) = v8;
  Size_3 = v8 == v9;
  v10 = (unsigned int *)operator new(0x70u);
  v11 = v10;
  if ( v10 )
    sub_415206(v10 + 5);
  else
    v11 = 0;
  if ( Size_3 )
  {
    if ( v8 > 0x400 )
    {
      if ( v11 )
        sub_414AA5((void **)v11, 1);
      return 0;
    }
    sub_41251D(this + 59072, 1);
    v13 = operator new(0x70u);
    v14 = (int)v13;
    if ( v13 )
      sub_415206(v13 + 5);
    else
      v14 = 0;
    *(_DWORD *)(*(_DWORD *)(this + 59072) + 4 * *(_DWORD *)(this + 59076) - 4) = v14;
    v15 = *(_DWORD *)(this + 59076) - 1;
    v51 = v14;
    v11[4] = v15;
    sub_41442E((_DWORD *)(this + 59104), 0);
    v16 = (unsigned int *)(v14 + 8);
    *v16 = 0;
  }
  else
  {
    v17 = *(_DWORD *)(*(_DWORD *)(this + 59072) + 4 * v8);
    v11[4] = v8;
    v16 = (unsigned int *)(v17 + 8);
    ++*(_DWORD *)(v17 + 8);
    v51 = v17;
  }
  v18 = 0;
  v52 = 0;
  v50 = 0;
  if ( !*(_DWORD *)(this + 59092) )
    goto LABEL_30;
  do
  {
    *(_DWORD *)(*(_DWORD *)(this + 59088) + 4 * (v18 - v52)) = *(_DWORD *)(*(_DWORD *)(this + 59088) + 4 * v18);
    v19 = v50;
    v20 = (_DWORD *)(*(_DWORD *)(this + 59088) + 4 * v50);
    if ( !*v20 )
      ++v52;
    v21 = v52;
    if ( v52 > 0 )
      *v20 = 0;
    v18 = v19 + 1;
    v50 = v18;
  }
  while ( v18 < *(_DWORD *)(this + 59092) );
  if ( !v21 )
  {
LABEL_30:
    sub_41251D(this + 59088, 1);
    v21 = 1;
  }
  v48 = v54;
  *(_DWORD *)(*(_DWORD *)(this + 59088) + 4 * (*(_DWORD *)(this + 59092) - v21)) = v11;
  v11[2] = *v16;
  v22 = sub_40A82D(v48);
  v23 = v22;
  if ( (a2 & 0x40) != 0 )
    v23 = v22 + 258;
  *v11 = *(_DWORD *)(this + 59128) & (v23 + *(_DWORD *)(this + 112));
  if ( (a2 & 0x20) != 0 )
  {
    v24 = sub_40A82D(v54);
    v11[1] = v24;
    *(_DWORD *)(*(_DWORD *)(this + 59104) + 4 * Srca) = v24;
  }
  else
  {
    if ( Srca >= *(_DWORD *)(this + 59108) )
      v25 = 0;
    else
      v25 = *(_DWORD *)(*(_DWORD *)(this + 59104) + 4 * Srca);
    v11[1] = v25;
  }
  v26 = *(_DWORD *)(this + 116);
  v27 = *(_DWORD *)(this + 112);
  v28 = v26 != v27 && (*(_DWORD *)(this + 59128) & (unsigned int)(v26 - v27)) <= v23;
  v29 = (int *)(v11 + 19);
  *((_BYTE *)v11 + 12) = v28;
  memset(v11 + 19, 0, 0x1Cu);
  v11[23] = v11[1];
  v30 = v11[2];
  v11[22] = 245760;
  v11[24] = v30;
  if ( (a2 & 0x10) != 0 )
  {
    v31 = (unsigned int)sub_40953E(v54) >> 9;
    sub_409527(v54, 7);
    for ( Srcb = 0; Srcb < 7; ++Srcb )
    {
      if ( ((1 << Srcb) & v31) != 0 )
        *v29 = sub_40A82D(v54);
      ++v29;
    }
  }
  if ( Size_3 )
  {
    v32 = sub_40A82D(v54);
    v33 = v32;
    Sizea = v32;
    if ( v32 >= 0x10000 )
      return 0;
    v34 = 0;
    if ( !v32 )
      return 0;
    sub_401306(&Block, v32);
    v35 = v33 == 0;
    v36 = Block;
    v55 = 0;
    if ( !v35 )
    {
      while ( (unsigned int)(*v54 + 3) < 0x8000 )
      {
        v37 = sub_40953E(v54);
        v38 = v54;
        v36[v34] = BYTE1(v37);
        sub_409527(v38, 8);
        if ( ++v34 >= Sizea )
          goto LABEL_54;
      }
      if ( v36 )
        free(v36);
      return 0;
    }
LABEL_54:
    v39 = v51;
    sub_40AA63(v53, v36, Sizea, (_DWORD *)(v51 + 20));
    v55 = -1;
    if ( v36 )
      free(v36);
  }
  else
  {
    v39 = v51;
  }
  v11[9] = *(_DWORD *)(v39 + 20);
  v11[10] = *(_DWORD *)(v39 + 40);
  v40 = *(_DWORD *)(v39 + 64);
  Sizeb = v40;
  if ( (unsigned int)(v40 - 1) <= 0x1FFE )
  {
    sub_401113((int)(v11 + 15), v40);
    memcpy((void *)v11[15], *(const void **)(v39 + 60), Sizeb);
  }
  if ( v11[12] < 0x40 )
  {
    sub_412595((int)(v11 + 11));
    sub_401113((int)(v11 + 11), 64);
  }
  v41 = v11 + 11;
  v42 = (_DWORD *)v11[11];
  Srcc = v42;
  Sizec = (int *)(v11 + 19);
  v50 = 7;
  do
  {
    sub_40A820(Srcc++, *Sizec++);
    --v50;
  }
  while ( v50 );
  sub_40A820(v42 + 7, v11[1]);
  sub_40A820(v42 + 8, 0);
  sub_40A820(v42 + 11, v11[2]);
  memset(v42 + 12, 0, 0x10u);
  if ( (a2 & 8) != 0 )
  {
    if ( (unsigned int)(*v54 + 3) >= 0x8000 )
      return 0;
    v43 = sub_40A82D(v54);
    v56 = v43;
    if ( v43 > 0x1FC0 )
      return 0;
    v44 = v11[12];
    if ( v44 < v43 + 64 )
      sub_401113((int)v41, v43 - v44 + 64);
    v45 = 0;
    v46 = *v41 + 64;
    if ( v56 )
    {
      while ( 1 )
      {
        v47 = v54;
        if ( (unsigned int)(*v54 + 3) >= 0x8000 )
          break;
        *(_BYTE *)(v45 + v46) = (unsigned __int16)sub_40953E(v54) >> 8;
        sub_409527(v47, 8);
        if ( ++v45 >= v56 )
          return 1;
      }
      return 0;
    }
  }
  return 1;
}

//----- (00416767) --------------------------------------------------------
char __thiscall sub_416767(int this, char a2)
{
  bool v3; // zf
  signed int v4; // eax
  int *v5; // edi
  int v6; // eax
  int v7; // ecx
  __int16 v8; // ax
  int v9; // ebx
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // ebx
  int v14; // edx
  unsigned int v15; // ecx
  unsigned int *v16; // ebx
  unsigned int v17; // ebx
  unsigned int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  int v21; // ebx
  unsigned int v22; // eax
  unsigned int v23; // eax
  __int16 v24; // ax
  int v25; // edx
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // ecx
  unsigned int v29; // eax
  int v30; // ebx
  unsigned int v31; // ecx
  unsigned int *v32; // edx
  unsigned int v33; // edx
  unsigned int v34; // eax
  unsigned int v35; // ebx
  unsigned int v36; // eax
  unsigned int v37; // ebx
  __int16 v38; // ax
  int v39; // ebx
  unsigned int v40; // eax
  unsigned int v41; // eax
  unsigned int v42; // ecx
  int v43; // eax
  int v44; // edx
  unsigned int v45; // ecx
  unsigned int *v46; // ebx
  unsigned int v47; // ebx
  unsigned int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // eax
  int v51; // ebx
  int *v52; // eax
  unsigned int v53; // edx
  unsigned int v54; // ecx
  unsigned int v55; // ebx
  char *v56; // ebx
  unsigned int v57; // ecx
  _BYTE *v58; // eax
  char v59; // dl
  void *v60; // ecx
  _BYTE *v61; // eax
  int v62; // ebx
  int v63; // edx
  int v64; // edx
  int v65; // eax
  int *v66; // eax
  unsigned int v67; // edx
  unsigned int v68; // ecx
  unsigned int v69; // ebx
  _BYTE *v70; // eax
  unsigned int v71; // ecx
  int v72; // ebx
  int v73; // edx
  unsigned int v74; // ebx
  void **v75; // eax
  unsigned int v76; // ecx
  __int16 v77; // ax
  int v78; // ebx
  unsigned int v79; // eax
  unsigned int v80; // eax
  unsigned int v81; // ecx
  unsigned int v82; // eax
  int v83; // edx
  unsigned int v84; // ecx
  unsigned int *v85; // ebx
  unsigned int v86; // ebx
  unsigned int v87; // eax
  int v88; // ebx
  unsigned int v89; // eax
  unsigned int v90; // eax
  int *v91; // eax
  unsigned int v92; // edx
  unsigned int v93; // ecx
  unsigned int v94; // ebx
  int v95; // eax
  char *v96; // ebx
  unsigned int v97; // eax
  unsigned int v98; // ecx
  _BYTE *v99; // eax
  _BYTE *v100; // ecx
  int v101; // ebx
  int v102; // edx
  char v104[16]; // [esp+Ch] [ebp-1Ch] BYREF
  void *v105; // [esp+1Ch] [ebp-Ch]
  unsigned int v106; // [esp+20h] [ebp-8h]
  void *v107; // [esp+24h] [ebp-4h]
  unsigned int v108; // [esp+30h] [ebp+8h]
  unsigned int v109; // [esp+30h] [ebp+8h]
  unsigned int v110; // [esp+30h] [ebp+8h]
  unsigned int v111; // [esp+30h] [ebp+8h]

  v3 = *(_BYTE *)(this + 19528) == 0;
  *(_BYTE *)(this + 19544) = 1;
  if ( !v3
    || (sub_41530F(this, a2), LOBYTE(v4) = sub_411F1D(this), (_BYTE)v4)
    && (LOBYTE(v4) = sub_414050((_DWORD *)this, (int *)(this + 4), this + 128), (_BYTE)v4)
    && (LOBYTE(v4) = sub_41416C((_DWORD *)this, this + 4, this + 128, (unsigned int *)(this + 148)), (_BYTE)v4) )
  {
    v5 = (int *)(this + 4);
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          *(_DWORD *)(this + 112) &= *(_DWORD *)(this + 59128);
          if ( *v5 >= *(_DWORD *)(this + 124) )
          {
            while ( 1 )
            {
              v6 = *(_DWORD *)(this + 128) + *(_DWORD *)(this + 136) - 1;
              if ( *v5 <= v6 && (*v5 != v6 || *(_DWORD *)(this + 8) < *(_DWORD *)(this + 132)) )
                break;
              if ( *(_BYTE *)(this + 144) )
                goto LABEL_103;
              LOBYTE(v4) = sub_414050((_DWORD *)this, (int *)(this + 4), this + 128);
              if ( (_BYTE)v4 )
              {
                LOBYTE(v4) = sub_41416C((_DWORD *)this, this + 4, this + 128, (unsigned int *)(this + 148));
                if ( (_BYTE)v4 )
                  continue;
              }
              return v4;
            }
            if ( !sub_411F1D(this) )
            {
LABEL_103:
              LOBYTE(v4) = sub_414E8A(this);
              return v4;
            }
          }
          v7 = *(_DWORD *)(this + 112);
          if ( (*(_DWORD *)(this + 59128) & (unsigned int)(*(_DWORD *)(this + 19248) - v7)) < 0x1004
            && *(_DWORD *)(this + 19248) != v7 )
          {
            sub_414E8A(this);
            v4 = *(_DWORD *)(this + 19540);
            if ( v4 > *(_DWORD *)(this + 19524) )
              return v4;
            if ( v4 >= *(_DWORD *)(this + 19524) )
            {
              v4 = *(_DWORD *)(this + 19536);
              if ( (unsigned int)v4 > *(_DWORD *)(this + 19520) )
                return v4;
            }
            if ( *(_BYTE *)(this + 19528) )
            {
              *(_BYTE *)(this + 19544) = 0;
              return v4;
            }
          }
          v8 = sub_4094F9((_DWORD *)(this + 4));
          v9 = *(_DWORD *)(this + 280);
          v10 = v8 & 0xFFFE;
          if ( v10 >= *(_DWORD *)(this + 4 * v9 + 152) )
          {
            v14 = 15;
            v15 = v9 + 1;
            if ( (unsigned int)(v9 + 1) < 0xF )
            {
              v16 = (unsigned int *)(this + 4 * v15 + 152);
              while ( v10 >= *v16 )
              {
                ++v15;
                ++v16;
                if ( v15 >= 0xF )
                  goto LABEL_29;
              }
              v14 = v15;
            }
LABEL_29:
            v17 = v14 + *(_DWORD *)(this + 8);
            *(_DWORD *)(this + 8) = v17 & 7;
            *v5 += v17 >> 3;
            v18 = *(_DWORD *)(this + 4 * v14 + 216) + ((v10 - *(_DWORD *)(this + 4 * v14 + 148)) >> (16 - v14));
            if ( v18 >= *(_DWORD *)(this + 148) )
              v18 = 0;
            v13 = *(unsigned __int16 *)(this + 2 * v18 + 3356);
          }
          else
          {
            v11 = v10 >> (16 - v9);
            v12 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v11 + this + 284);
            *v5 += v12 >> 3;
            *(_DWORD *)(this + 8) = v12 & 7;
            v13 = *(unsigned __int16 *)(this + 2 * v11 + 1308);
          }
          if ( v13 >= 0x100 )
            break;
          if ( *(_BYTE *)(this + 19512) )
          {
            v19 = *(_DWORD *)(this + 112);
            *(_DWORD *)(this + 112) = v19 + 1;
            *(_BYTE *)sub_412144((int *)(this + 19256), v19) = v13;
          }
          else
          {
            *(_BYTE *)(*(_DWORD *)(this + 19252) + (*(_DWORD *)(this + 112))++) = v13;
          }
        }
        if ( v13 < 0x106 )
          break;
        v20 = v13 - 262;
        if ( v13 - 262 >= 8 )
        {
          v21 = (v20 >> 2) - 1;
          v105 = (void *)(((v20 & 3 | 4) << v21) + 2);
          if ( v20 >> 2 != 1 )
          {
            v22 = sub_4094F9((_DWORD *)(this + 4));
            v105 = (char *)v105 + (v22 >> (16 - v21));
            v23 = v21 + *(_DWORD *)(this + 8);
            *v5 += v23 >> 3;
            *(_DWORD *)(this + 8) = v23 & 7;
          }
        }
        else
        {
          v105 = (void *)(v20 + 2);
        }
        v108 = (unsigned int)v105;
        v24 = sub_4094F9((_DWORD *)(this + 4));
        v25 = *(_DWORD *)(this + 4100);
        v26 = v24 & 0xFFFE;
        if ( v26 >= *(_DWORD *)(this + 4 * v25 + 3972) )
        {
          v30 = 15;
          v31 = v25 + 1;
          if ( (unsigned int)(v25 + 1) < 0xF )
          {
            v32 = (unsigned int *)(this + 4 * v31 + 3972);
            while ( v26 >= *v32 )
            {
              ++v31;
              ++v32;
              if ( v31 >= 0xF )
                goto LABEL_49;
            }
            v30 = v31;
          }
LABEL_49:
          v33 = v30 + *(_DWORD *)(this + 8);
          *(_DWORD *)(this + 8) = v33 & 7;
          *v5 += v33 >> 3;
          v34 = *(_DWORD *)(this + 4 * v30 + 4036) + ((v26 - *(_DWORD *)(this + 4 * v30 + 3968)) >> (16 - v30));
          if ( v34 >= *(_DWORD *)(this + 3968) )
            v34 = 0;
          v29 = *(unsigned __int16 *)(this + 2 * v34 + 7176);
        }
        else
        {
          v27 = v26 >> (16 - v25);
          v28 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v27 + this + 4104);
          *v5 += v28 >> 3;
          *(_DWORD *)(this + 8) = v28 & 7;
          v29 = *(unsigned __int16 *)(this + 2 * v27 + 5128);
        }
        if ( v29 >= 4 )
        {
          v35 = (v29 >> 1) - 1;
          v106 = ((v29 & 1 | 2) << v35) + 1;
          if ( v29 >> 1 != 1 )
          {
            if ( v35 < 4 )
            {
              v49 = sub_41262C((_DWORD *)(this + 4));
              v106 += v49 >> (32 - v35);
              v50 = v35 + *(_DWORD *)(this + 8);
              *v5 += v50 >> 3;
              *(_DWORD *)(this + 8) = v50 & 7;
            }
            else
            {
              if ( v35 > 4 )
              {
                v36 = sub_41262C((_DWORD *)(this + 4));
                v106 += 16 * (v36 >> (36 - v35));
                v37 = *(_DWORD *)(this + 8) + v35 - 4;
                *v5 += v37 >> 3;
                *(_DWORD *)(this + 8) = v37 & 7;
              }
              v38 = sub_4094F9((_DWORD *)(this + 4));
              v39 = *(_DWORD *)(this + 7920);
              v40 = v38 & 0xFFFE;
              if ( v40 >= *(_DWORD *)(this + 4 * v39 + 7792) )
              {
                v44 = 15;
                v45 = v39 + 1;
                if ( (unsigned int)(v39 + 1) < 0xF )
                {
                  v46 = (unsigned int *)(this + 4 * v45 + 7792);
                  while ( v40 >= *v46 )
                  {
                    ++v45;
                    ++v46;
                    if ( v45 >= 0xF )
                      goto LABEL_66;
                  }
                  v44 = v45;
                }
LABEL_66:
                v47 = v44 + *(_DWORD *)(this + 8);
                *(_DWORD *)(this + 8) = v47 & 7;
                *v5 += v47 >> 3;
                v48 = *(_DWORD *)(this + 4 * v44 + 7856) + ((v40 - *(_DWORD *)(this + 4 * v44 + 7788)) >> (16 - v44));
                if ( v48 >= *(_DWORD *)(this + 7788) )
                  v48 = 0;
                v43 = *(unsigned __int16 *)(this + 2 * v48 + 10996);
              }
              else
              {
                v41 = v40 >> (16 - v39);
                v42 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v41 + this + 7924);
                *v5 += v42 >> 3;
                *(_DWORD *)(this + 8) = v42 & 7;
                v43 = *(unsigned __int16 *)(this + 2 * v41 + 8948);
              }
              v106 += v43;
            }
          }
        }
        else
        {
          v106 = v29 + 1;
        }
        v51 = v106;
        if ( v106 > 0x100 )
        {
          v108 = (unsigned int)v105 + 1;
          if ( v106 > 0x2000 )
          {
            v108 = (unsigned int)v105 + 2;
            if ( v106 > 0x40000 )
              v108 = (unsigned int)v105 + 3;
          }
        }
        v3 = *(_BYTE *)(this + 19512) == 0;
        *(_DWORD *)(this + 96) = *(_DWORD *)(this + 92);
        *(_DWORD *)(this + 92) = *(_DWORD *)(this + 88);
        *(_DWORD *)(this + 88) = *(_DWORD *)(this + 84);
        *(_DWORD *)(this + 84) = v51;
        *(_DWORD *)(this + 104) = v108;
        v52 = (int *)(this + 112);
        if ( v3 )
        {
          v53 = *v52;
          v107 = (void *)v108;
          v54 = v53 - v51;
          v55 = *(_DWORD *)(this + 59124) - 4097;
          v105 = (void *)v54;
          if ( v54 < v55 && v53 < v55 )
          {
            v56 = (char *)(v54 + *(_DWORD *)(this + 19252));
            v105 = (void *)(v53 + *(_DWORD *)(this + 19252));
            *v52 = v108 + v53;
            if ( v106 >= v108 )
            {
              if ( v108 >= 8 )
              {
                v109 = v108 >> 3;
                do
                {
                  memcpy(v105, v56, 8u);
                  v105 = (char *)v105 + 8;
                  v107 = (char *)v107 - 8;
                  v56 += 8;
                  --v109;
                }
                while ( v109 );
              }
            }
            else if ( v108 >= 8 )
            {
              v57 = v108 >> 3;
              v58 = v105;
              do
              {
                v59 = *v56;
                v107 = (char *)v107 - 8;
                *v58 = v59;
                v58[1] = v56[1];
                v58[2] = v56[2];
                v58[3] = v56[3];
                v58[4] = v56[4];
                v58[5] = v56[5];
                v58[6] = v56[6];
                v58[7] = v56[7];
                v56 += 8;
                v58 += 8;
                --v57;
              }
              while ( v57 );
              v105 = v58;
            }
            v60 = v107;
            goto LABEL_88;
          }
          if ( v108 )
          {
            v62 = *(_DWORD *)(this + 59128);
            do
            {
              v63 = *(_DWORD *)(this + 19252);
              v107 = (char *)v107 - 1;
              *(_BYTE *)(v63 + *v52) = *(_BYTE *)((v62 & v54) + v63);
              v62 = *(_DWORD *)(this + 59128);
              v54 = (unsigned int)v105 + 1;
              v64 = v62 & (*v52 + 1);
              v3 = v107 == 0;
              v105 = (char *)v105 + 1;
              *v52 = v64;
            }
            while ( !v3 );
          }
        }
        else
        {
          sub_41217C((int *)(this + 19256), v108, v51, (unsigned int *)(this + 112), *(_DWORD *)(this + 59128));
        }
      }
      if ( v13 == 256 )
      {
        if ( !sub_413DD1((_DWORD *)this, this + 4, (int)v104) || !sub_4152AF((_DWORD *)this, (int)v104) )
          goto LABEL_103;
      }
      else if ( v13 == 257 )
      {
        v65 = *(_DWORD *)(this + 104);
        if ( v65 )
        {
          if ( *(_BYTE *)(this + 19512) )
          {
            sub_41217C(
              (int *)(this + 19256),
              v65,
              *(_DWORD *)(this + 84),
              (unsigned int *)(this + 112),
              *(_DWORD *)(this + 59128));
          }
          else
          {
            v110 = *(_DWORD *)(this + 104);
            v66 = (int *)(this + 112);
            v67 = *(_DWORD *)(this + 112);
            v68 = v67 - *(_DWORD *)(this + 84);
            v69 = *(_DWORD *)(this + 59124) - 4097;
            v105 = (void *)v68;
            if ( v68 >= v69 || v67 >= v69 )
            {
              if ( v110 )
              {
                v72 = *(_DWORD *)(this + 59128);
                do
                {
                  --v110;
                  *(_BYTE *)(*(_DWORD *)(this + 19252) + *v66) = *(_BYTE *)((v72 & v68) + *(_DWORD *)(this + 19252));
                  v72 = *(_DWORD *)(this + 59128);
                  v68 = (unsigned int)v105 + 1;
                  v73 = v72 & (*v66 + 1);
                  v105 = (char *)v105 + 1;
                  *v66 = v73;
                }
                while ( v110 );
              }
            }
            else
            {
              v56 = (char *)(v68 + *(_DWORD *)(this + 19252));
              v105 = (void *)(v67 + *(_DWORD *)(this + 19252));
              *v66 = v110 + v67;
              if ( *(_DWORD *)(this + 84) >= v110 )
              {
                if ( v110 >= 8 )
                {
                  v106 = v110 >> 3;
                  do
                  {
                    memcpy(v105, v56, 8u);
                    v105 = (char *)v105 + 8;
                    v110 -= 8;
                    v56 += 8;
                    --v106;
                  }
                  while ( v106 );
                }
              }
              else if ( v110 >= 8 )
              {
                v70 = v105;
                v71 = v110 >> 3;
                do
                {
                  v110 -= 8;
                  *v70 = *v56;
                  v70[1] = v56[1];
                  v70[2] = v56[2];
                  v70[3] = v56[3];
                  v70[4] = v56[4];
                  v70[5] = v56[5];
                  v70[6] = v56[6];
                  v70[7] = v56[7];
                  v56 += 8;
                  v70 += 8;
                  --v71;
                }
                while ( v71 );
                v105 = v70;
              }
              v60 = (void *)v110;
LABEL_88:
              if ( v60 )
              {
                v61 = v105;
                *(_BYTE *)v105 = *v56;
                if ( (unsigned int)v60 > 1 )
                {
                  v61[1] = v56[1];
                  if ( (unsigned int)v60 > 2 )
                  {
                    v61[2] = v56[2];
                    if ( (unsigned int)v60 > 3 )
                    {
                      v61[3] = v56[3];
                      if ( (unsigned int)v60 > 4 )
                      {
                        v61[4] = v56[4];
                        if ( (unsigned int)v60 > 5 )
                        {
                          v61[5] = v56[5];
                          if ( (unsigned int)v60 > 6 )
                            v61[6] = v56[6];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v3 = v13 == 258;
        v74 = v13 - 258;
        v75 = (void **)(this + 4 * v74 + 84);
        v105 = *v75;
        v76 = v74;
        if ( !v3 )
        {
          do
          {
            *v75 = *(v75 - 1);
            --v76;
            --v75;
          }
          while ( v76 );
        }
        *(_DWORD *)(this + 84) = v105;
        v77 = sub_4094F9((_DWORD *)(this + 4));
        v78 = *(_DWORD *)(this + 11740);
        v79 = v77 & 0xFFFE;
        if ( v79 >= *(_DWORD *)(this + 4 * v78 + 11612) )
        {
          v83 = 15;
          v84 = v78 + 1;
          if ( (unsigned int)(v78 + 1) < 0xF )
          {
            v85 = (unsigned int *)(this + 4 * v84 + 11612);
            while ( v79 >= *v85 )
            {
              ++v84;
              ++v85;
              if ( v84 >= 0xF )
                goto LABEL_134;
            }
            v83 = v84;
          }
LABEL_134:
          v86 = v83 + *(_DWORD *)(this + 8);
          *(_DWORD *)(this + 8) = v86 & 7;
          *v5 += v86 >> 3;
          v87 = *(_DWORD *)(this + 4 * v83 + 11676) + ((v79 - *(_DWORD *)(this + 4 * v83 + 11608)) >> (16 - v83));
          if ( v87 >= *(_DWORD *)(this + 11608) )
            v87 = 0;
          v82 = *(unsigned __int16 *)(this + 2 * v87 + 14816);
        }
        else
        {
          v80 = v79 >> (16 - v78);
          v81 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v80 + this + 11744);
          *v5 += v81 >> 3;
          *(_DWORD *)(this + 8) = v81 & 7;
          v82 = *(unsigned __int16 *)(this + 2 * v80 + 12768);
        }
        if ( v82 >= 8 )
        {
          v88 = (v82 >> 2) - 1;
          v106 = ((v82 & 3 | 4) << v88) + 2;
          if ( v82 >> 2 != 1 )
          {
            v89 = sub_4094F9((_DWORD *)(this + 4));
            v106 += v89 >> (16 - v88);
            v90 = v88 + *(_DWORD *)(this + 8);
            *v5 += v90 >> 3;
            *(_DWORD *)(this + 8) = v90 & 7;
          }
        }
        else
        {
          v106 = v82 + 2;
        }
        v3 = *(_BYTE *)(this + 19512) == 0;
        *(_DWORD *)(this + 104) = v106;
        if ( v3 )
        {
          v111 = v106;
          v91 = (int *)(this + 112);
          v92 = *(_DWORD *)(this + 112);
          v93 = v92 - (_DWORD)v105;
          v94 = *(_DWORD *)(this + 59124) - 4097;
          v107 = (void *)(v92 - (_DWORD)v105);
          if ( v92 - (unsigned int)v105 >= v94 || v92 >= v94 )
          {
            if ( v106 )
            {
              v101 = *(_DWORD *)(this + 59128);
              do
              {
                --v111;
                *(_BYTE *)(*(_DWORD *)(this + 19252) + *v91) = *(_BYTE *)((v101 & v93) + *(_DWORD *)(this + 19252));
                v101 = *(_DWORD *)(this + 59128);
                v93 = (unsigned int)v107 + 1;
                v102 = v101 & (*v91 + 1);
                v107 = (char *)v107 + 1;
                *v91 = v102;
              }
              while ( v111 );
            }
          }
          else
          {
            v95 = *(_DWORD *)(this + 19252);
            v96 = (char *)(v95 + v93);
            v107 = (void *)(v92 + v95);
            v97 = v106;
            *(_DWORD *)(this + 112) = v106 + v92;
            if ( (unsigned int)v105 >= v97 )
            {
              if ( v97 >= 8 )
              {
                v105 = (void *)(v106 >> 3);
                do
                {
                  memcpy(v107, v96, 8u);
                  v107 = (char *)v107 + 8;
                  v111 -= 8;
                  v96 += 8;
                  v105 = (char *)v105 - 1;
                }
                while ( v105 );
              }
            }
            else if ( v97 >= 8 )
            {
              v98 = v97 >> 3;
              v99 = v107;
              do
              {
                v111 -= 8;
                *v99 = *v96;
                v99[1] = v96[1];
                v99[2] = v96[2];
                v99[3] = v96[3];
                v99[4] = v96[4];
                v99[5] = v96[5];
                v99[6] = v96[6];
                v99[7] = v96[7];
                v96 += 8;
                v99 += 8;
                --v98;
              }
              while ( v98 );
              v107 = v99;
            }
            if ( v111 )
            {
              v100 = v107;
              *(_BYTE *)v107 = *v96;
              if ( v111 != 1 )
              {
                v100[1] = v96[1];
                if ( v111 > 2 )
                {
                  v100[2] = v96[2];
                  if ( v111 > 3 )
                  {
                    v100[3] = v96[3];
                    if ( v111 > 4 )
                    {
                      v100[4] = v96[4];
                      if ( v111 > 5 )
                      {
                        v100[5] = v96[5];
                        if ( v111 > 6 )
                          v100[6] = v96[6];
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          sub_41217C((int *)(this + 19256), v106, (int)v105, (unsigned int *)(this + 112), *(_DWORD *)(this + 59128));
        }
      }
    }
  }
  return v4;
}

//----- (004171B2) --------------------------------------------------------
int __thiscall sub_4171B2(int this, int a2)
{
  sub_40948D(this + 4, 1);
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  sub_412035((char *)(this + 19256));
  sub_412A40((_DWORD *)(this + 39120));
  sub_40A7E1((_DWORD *)(this + 59000));
  sub_40948D(this + 59056, 1);
  *(_DWORD *)(this + 59072) = 0;
  *(_DWORD *)(this + 59076) = 0;
  *(_DWORD *)(this + 59080) = 0;
  *(_DWORD *)(this + 59084) = 0;
  *(_DWORD *)(this + 59088) = 0;
  *(_DWORD *)(this + 59092) = 0;
  *(_DWORD *)(this + 59096) = 0;
  *(_DWORD *)(this + 59100) = 0;
  *(_DWORD *)(this + 59104) = 0;
  *(_DWORD *)(this + 59108) = 0;
  *(_DWORD *)(this + 59112) = 0;
  *(_DWORD *)(this + 59116) = 0;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 19252) = 0;
  *(_BYTE *)(this + 19512) = 0;
  *(_BYTE *)(this + 19528) = 0;
  *(_BYTE *)(this + 19529) = 0;
  *(_BYTE *)(this + 19530) = 0;
  *(_DWORD *)(this + 28) = 1;
  *(_DWORD *)(this + 20) = sub_410C7D();
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 59124) = 0;
  *(_DWORD *)(this + 59128) = 0;
  sub_41530F(this, 0);
  return this;
}

//----- (004172C2) --------------------------------------------------------
void *__thiscall sub_4172C2(int this, char a2)
{
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // eax
  void *v6; // edi
  int v7; // eax
  bool v8; // zf
  unsigned int v9; // esi
  bool v10; // al
  int v11; // eax
  unsigned int v12; // ecx
  int v13; // esi
  _DWORD *v14; // ecx
  int v15; // eax
  unsigned int v16; // edx
  unsigned int v17; // edi
  int v18; // eax
  int v19; // esi
  int v20; // esi
  char *v21; // ecx
  int v22; // eax
  _DWORD *v23; // eax
  int v24; // edi
  int v25; // ecx
  int v26; // eax
  void *v28; // [esp-Ch] [ebp-14Ch]
  char v29; // [esp+Ch] [ebp-134h] BYREF
  void *v30; // [esp+10Ch] [ebp-34h]
  void *v31; // [esp+110h] [ebp-30h]
  unsigned int v32; // [esp+114h] [ebp-2Ch]
  int v33; // [esp+118h] [ebp-28h]
  int v34; // [esp+11Ch] [ebp-24h]
  unsigned int v35; // [esp+120h] [ebp-20h]
  unsigned int v36; // [esp+124h] [ebp-1Ch]
  char *v37; // [esp+128h] [ebp-18h]
  unsigned int v38; // [esp+12Ch] [ebp-14h]
  int v39; // [esp+130h] [ebp-10h]
  char v40; // [esp+137h] [ebp-9h]
  unsigned int v41; // [esp+138h] [ebp-8h]
  int v42; // [esp+13Ch] [ebp-4h]
  char v43; // [esp+14Bh] [ebp+Bh]

  sub_413829((_DWORD *)this);
  sub_41530F(this, a2);
  v3 = 0;
  if ( 2 * *(_DWORD *)(this + 28) )
  {
    v4 = 0;
    do
    {
      v5 = v4 + *(_DWORD *)(this + 24);
      *(_BYTE *)(v5 + 19153) = 0;
      *(_BYTE *)(v5 + 19155) = 0;
      ++v3;
      v4 += 19172;
    }
    while ( v3 < 2 * *(_DWORD *)(this + 28) );
  }
  v6 = (void *)(*(_DWORD *)(this + 24) + 24);
  v30 = (void *)(this + 148);
  v31 = (void *)(this + 128);
  qmemcpy(v6, (const void *)(this + 128), 0x14u);
  memcpy((void *)(*(_DWORD *)(this + 24) + 48), (const void *)(this + 148), 0x4A9Cu);
  v32 = 0;
  v42 = 0;
  v39 = 0;
  v40 = 0;
  v43 = 0;
LABEL_5:
  while ( 1 )
  {
    v7 = sub_40B60F(*(char **)this, (__m128i *)(v42 + *(_DWORD *)(this + 32)), (0x400000 - v42) & 0xFFFFFFF0);
    v34 = v7;
    if ( v7 < 0 )
      break;
    v42 += v7;
    if ( !v42 )
      break;
    if ( v39 < v42 )
    {
      while ( 1 )
      {
        v8 = 2 * *(_DWORD *)(this + 28) == 0;
        v38 = 0;
        v36 = 0;
        if ( !v8 )
        {
          v41 = 0;
          while ( 1 )
          {
            v9 = v41 + *(_DWORD *)(this + 24);
            v8 = *(_BYTE *)(v9 + 19155) == 0;
            v32 = v38;
            *(_DWORD *)v9 = this;
            if ( v8 )
            {
              sub_4094D3(v9 + 4, v39 + *(_DWORD *)(this + 32));
              *(_DWORD *)(v9 + 8) = 0;
              *(_DWORD *)(v9 + 4) = 0;
              v8 = v42 == v39;
              *(_DWORD *)(v9 + 19148) = v42 - v39;
              if ( v8 )
                goto LABEL_26;
              *(_BYTE *)(v9 + 19152) = 0;
              *(_BYTE *)(v9 + 20) = 0;
              *(_BYTE *)(v9 + 44) = 0;
            }
            else
            {
              *(_DWORD *)(v9 + 19148) = v42;
            }
            v8 = v34 == 0;
            *(_BYTE *)(v9 + 19155) = 0;
            v10 = v8;
            v8 = *(_BYTE *)(v9 + 20) == 0;
            *(_BYTE *)(v9 + 19154) = v10;
            *(_DWORD *)(v9 + 19168) = v38;
            if ( v8 )
            {
              *(_BYTE *)(v9 + 20) = 1;
              if ( !sub_414050((_DWORD *)this, (int *)(v9 + 4), v9 + 24) )
                break;
            }
            if ( v40 || *(int *)(v9 + 24) > 0x20000 )
            {
              *(_BYTE *)(v9 + 19153) = 1;
              v40 = 1;
            }
            else
            {
              ++v36;
            }
            v11 = *(_DWORD *)(v9 + 24) + *(_DWORD *)(v9 + 36);
            v41 += 19172;
            v39 += v11;
            ++v38;
            if ( v42 - v39 >= 0 && *(_BYTE *)(v9 + 40) || v42 - v39 < 1024 || v38 >= 2 * *(_DWORD *)(this + 28) )
              goto LABEL_26;
          }
          v43 = 1;
        }
LABEL_26:
        v12 = *(_DWORD *)(this + 28);
        v13 = 0;
        v35 = v36 / v12;
        if ( v36 % v12 )
          ++v35;
        v41 = 0;
        if ( v36 )
        {
          v33 = 19172 * v35;
          v37 = &v29;
          do
          {
            v14 = v37;
            v15 = *(_DWORD *)(this + 24);
            v16 = v36 - v41;
            v17 = v35;
            v37 += 8;
            v18 = v13 + v15;
            *v14 = v18;
            if ( v17 < v16 )
              v16 = v17;
            v8 = v38 == 1;
            v14[1] = v16;
            if ( v8 )
              sub_414487((_DWORD *)this, v18);
            else
              sub_410E83(*(_DWORD *)(this + 20), (int)sub_415237, (int)v14);
            v41 += v17;
            v13 += v33;
          }
          while ( v41 < v36 );
        }
        if ( !v38 )
          break;
        sub_410C36(*(_DWORD *)(this + 20));
        v41 = 0;
        if ( v38 )
        {
          v37 = 0;
          do
          {
            v19 = (int)&v37[*(_DWORD *)(this + 24)];
            if ( *(_BYTE *)(v19 + 19153) )
              goto LABEL_65;
            if ( !sub_4153B7(this, (int)&v37[*(_DWORD *)(this + 24)]) )
              goto LABEL_62;
            if ( *(_BYTE *)(v19 + 19153) )
            {
LABEL_65:
              if ( !sub_4158D3(this, v19) )
                goto LABEL_62;
            }
            if ( *(_BYTE *)(v19 + 19152) )
              goto LABEL_62;
            if ( *(_BYTE *)(v19 + 19155) )
            {
              v21 = *(char **)(this + 32);
              v22 = *(_DWORD *)(v19 + 4) + *(_DWORD *)(v19 + 16) - (_DWORD)v21;
              if ( v42 <= v22 )
                goto LABEL_62;
              v34 = v42 - v22;
              memcpy_0(v21, &v21[v22], v42 - v22);
              *(_DWORD *)(v19 + 24) += *(_DWORD *)(v19 + 32) - *(_DWORD *)(v19 + 4);
              *(_DWORD *)(v19 + 36) = 0;
              *(_DWORD *)(v19 + 32) = 0;
              *(_DWORD *)(v19 + 16) = *(_DWORD *)(this + 32);
              *(_DWORD *)(v19 + 4) = 0;
              if ( v41 )
              {
                v23 = *(_DWORD **)(this + 24);
                v24 = v23[4789];
                v33 = v23[4791];
                memcpy(v23, (const void *)v19, 0x4AE4u);
                v25 = v33;
                *(_DWORD *)(*(_DWORD *)(this + 24) + 19156) = v24;
                *(_DWORD *)(*(_DWORD *)(this + 24) + 19164) = v25;
                *(_BYTE *)(v19 + 19155) = 0;
              }
              v39 = 0;
              v42 = v34;
              goto LABEL_61;
            }
            if ( *(_BYTE *)(v19 + 40) )
            {
              v43 = 1;
              break;
            }
            ++v41;
            v37 += 19172;
          }
          while ( v41 < v38 );
        }
        if ( v43 )
          goto LABEL_62;
        v20 = v42 - v39;
        if ( v42 - v39 < 1024 )
        {
          if ( v20 < 0 )
            goto LABEL_62;
          if ( v20 > 0 )
            memcpy_0(*(void **)(this + 32), (const void *)(*(_DWORD *)(this + 32) + v39), v42 - v39);
          v39 = 0;
          v42 = v20;
          break;
        }
        if ( v39 >= v42 )
          goto LABEL_5;
      }
LABEL_61:
      if ( !v43 )
        continue;
      break;
    }
  }
LABEL_62:
  sub_414E8A(this);
  v26 = *(_DWORD *)(this + 24) + 19172 * v32;
  v28 = v30;
  qmemcpy(v31, (const void *)(v26 + 24), 0x14u);
  return memcpy(v28, (const void *)(v26 + 48), 0x4A9Cu);
}

//----- (004176B3) --------------------------------------------------------
char __thiscall sub_4176B3(_DWORD *this)
{
  _DWORD *v1; // esi
  unsigned int v2; // edi
  unsigned int v3; // eax
  int v4; // edi
  unsigned int v5; // eax
  int v6; // ebx
  int v7; // eax
  unsigned int v8; // eax
  char v9; // bl
  void *Block; // [esp+Ch] [ebp-24h] BYREF
  int v12; // [esp+1Ch] [ebp-14h]
  _DWORD *v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-4h]

  v1 = this + 1;
  v13 = this;
  v2 = sub_4094F9(this + 1);
  v3 = v1[1] + 8;
  *v1 += v3 >> 3;
  v12 = v2 >> 8;
  v4 = ((v2 >> 8) & 7) + 1;
  v1[1] = v3 & 7;
  if ( v4 == 7 )
  {
    v4 = ((unsigned int)sub_4094F9(v1) >> 8) + 7;
    v5 = v1[1] + 8;
  }
  else
  {
    if ( v4 != 8 )
      goto LABEL_6;
    v4 = sub_4094F9(v1);
    v5 = v1[1] + 16;
  }
  *v1 += v5 >> 3;
  v1[1] = v5 & 7;
LABEL_6:
  sub_401306(&Block, v4);
  v6 = 0;
  v14 = 0;
  if ( v4 <= 0 )
  {
LABEL_11:
    v9 = sub_4162C9((int)v13, v12, Block, v4);
    if ( Block )
      free(Block);
    return v9;
  }
  else
  {
    while ( *v1 < v13[30] - 1 || sub_411E9F((int)v13) || v6 >= v4 - 1 )
    {
      v7 = sub_4094F9(v1);
      *((_BYTE *)Block + v6) = BYTE1(v7);
      v8 = v1[1] + 8;
      *v1 += v8 >> 3;
      ++v6;
      v1[1] = v8 & 7;
      if ( v6 >= v4 )
        goto LABEL_11;
    }
    if ( Block )
      free(Block);
    return 0;
  }
}

//----- (004177C3) --------------------------------------------------------
char __thiscall sub_4177C3(unsigned int *this)
{
  int v2; // eax
  int v4; // esi
  int v5; // eax
  int v6; // esi
  int v7; // eax
  _BYTE *v8; // edi
  int v9; // ebx
  int v10; // eax
  char v11; // bl
  void *Block; // [esp+Ch] [ebp-24h] BYREF
  int v13; // [esp+1Ch] [ebp-14h]
  unsigned int *v14; // [esp+20h] [ebp-10h]
  int v15; // [esp+2Ch] [ebp-4h]

  v14 = this;
  v2 = sub_41397A(this);
  v13 = v2;
  if ( v2 == -1 )
    return 0;
  v4 = (v2 & 7) + 1;
  if ( (v2 & 7) == 6 )
  {
    v5 = sub_41397A(this);
    if ( v5 != -1 )
    {
      v4 = v5 + 7;
      goto LABEL_10;
    }
    return 0;
  }
  if ( (v2 & 7) == 7 )
  {
    v6 = sub_41397A(this);
    if ( v6 == -1 )
      return 0;
    v7 = sub_41397A(this);
    if ( v7 == -1 )
      return 0;
    v4 = v7 + (v6 << 8);
  }
LABEL_10:
  sub_401306(&Block, v4);
  v8 = Block;
  v9 = 0;
  v15 = 0;
  if ( v4 > 0 )
  {
    while ( 1 )
    {
      v10 = sub_41397A(v14);
      if ( v10 == -1 )
        break;
      v8[v9++] = v10;
      if ( v9 >= v4 )
        goto LABEL_13;
    }
    if ( v8 )
      free(v8);
    return 0;
  }
LABEL_13:
  v11 = sub_4162C9((int)v14, v13, v8, v4);
  if ( v8 )
    free(v8);
  return v11;
}

//----- (00417894) --------------------------------------------------------
char __thiscall sub_417894(int this, char a2)
{
  unsigned int v2; // ebx
  int v4; // edi
  bool v5; // zf
  signed int v6; // eax
  _DWORD *v7; // edi
  int v8; // ecx
  int v9; // eax
  char v10; // bl
  int v11; // eax
  char v12; // al
  int v13; // ebx
  int v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // edx
  int v18; // edx
  _BYTE *v19; // ebx
  char *v20; // edx
  unsigned int v21; // ecx
  char *v22; // eax
  unsigned int v23; // ecx
  _BYTE *v24; // eax
  int v25; // edx
  int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // edx
  unsigned int v29; // ecx
  int v30; // ecx
  unsigned int v31; // ecx
  int v32; // ecx
  __int16 v33; // ax
  int v34; // ebx
  unsigned int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // ecx
  int v38; // eax
  int v39; // edx
  unsigned int v40; // ecx
  unsigned int *v41; // ebx
  unsigned int v42; // ebx
  unsigned int v43; // eax
  int v44; // ebx
  unsigned int v45; // ebx
  unsigned int v46; // eax
  __int16 v47; // ax
  int v48; // ebx
  unsigned int v49; // eax
  unsigned int v50; // eax
  unsigned int v51; // ecx
  int v52; // eax
  int v53; // edx
  unsigned int v54; // ecx
  unsigned int *v55; // ebx
  unsigned int v56; // ebx
  unsigned int v57; // eax
  unsigned int v58; // ebx
  unsigned int v59; // edx
  unsigned int v60; // eax
  int v61; // eax
  __int16 v62; // ax
  int v63; // edx
  unsigned int v64; // eax
  unsigned int v65; // eax
  unsigned int v66; // ecx
  int v67; // eax
  unsigned int v68; // edx
  unsigned int *v69; // ecx
  unsigned int v70; // ecx
  unsigned int v71; // eax
  unsigned int v72; // eax
  unsigned int v73; // ecx
  int v74; // edx
  int v75; // eax
  unsigned int v76; // edx
  int v77; // edx
  char *v78; // edx
  char *v79; // eax
  int v80; // edx
  unsigned int v81; // ecx
  unsigned int v82; // eax
  unsigned int v83; // edx
  int v84; // edx
  char *v85; // edx
  unsigned int v86; // ecx
  int v87; // edx
  int v88; // eax
  void **v89; // ecx
  void *v90; // edx
  __int16 v91; // ax
  int v92; // ebx
  unsigned int v93; // eax
  unsigned int v94; // eax
  unsigned int v95; // ecx
  int v96; // eax
  int v97; // edx
  unsigned int v98; // ebx
  unsigned int *v99; // ecx
  unsigned int v100; // ebx
  unsigned int v101; // eax
  int v102; // ebx
  unsigned int v103; // eax
  unsigned int v104; // ecx
  unsigned int v105; // eax
  unsigned int v106; // edx
  int v107; // edx
  _BYTE *v108; // ebx
  _BYTE *v109; // edx
  unsigned int v110; // ecx
  _BYTE *v111; // eax
  int v112; // edx
  int v113; // ebx
  unsigned int v114; // eax
  unsigned int v115; // ecx
  int v116; // edx
  unsigned int v117; // eax
  unsigned int v118; // edx
  int v119; // edx
  _BYTE *v120; // eax
  _BYTE *v121; // edx
  int v122; // edx
  int v124; // [esp+Ch] [ebp-10h]
  int v125; // [esp+10h] [ebp-Ch]
  unsigned int v126; // [esp+10h] [ebp-Ch]
  unsigned int v127; // [esp+10h] [ebp-Ch]
  unsigned int v128; // [esp+10h] [ebp-Ch]
  unsigned int v129; // [esp+10h] [ebp-Ch]
  unsigned int v130; // [esp+10h] [ebp-Ch]
  unsigned int v131; // [esp+10h] [ebp-Ch]
  unsigned int v132; // [esp+10h] [ebp-Ch]
  unsigned int v133; // [esp+10h] [ebp-Ch]
  char *v134; // [esp+14h] [ebp-8h]
  char *v135; // [esp+14h] [ebp-8h]
  void *v136; // [esp+14h] [ebp-8h]
  char *v137; // [esp+18h] [ebp-4h]
  char *v138; // [esp+18h] [ebp-4h]
  unsigned int v139; // [esp+18h] [ebp-4h]
  _BYTE *v140; // [esp+18h] [ebp-4h]
  unsigned int v141; // [esp+24h] [ebp+8h]
  int v142; // [esp+24h] [ebp+8h]
  int v143; // [esp+24h] [ebp+8h]
  int v144; // [esp+24h] [ebp+8h]
  unsigned int v145; // [esp+24h] [ebp+8h]
  int v146; // [esp+24h] [ebp+8h]
  unsigned int v147; // [esp+24h] [ebp+8h]
  int v148; // [esp+24h] [ebp+8h]
  int v149; // [esp+24h] [ebp+8h]
  char v150; // [esp+27h] [ebp+Bh]

  v2 = 0;
  if ( !dword_44EBBC )
  {
    v134 = 0;
    v4 = 0;
    do
    {
      if ( (int)Size[v2] > 0 )
      {
        v137 = (char *)Size[v2];
        memset(&byte_44EB78[v4], v2, (size_t)v137);
        do
        {
          dword_44EBB8[v4++] = (int)v134;
          v5 = v137-- == (char *)1;
          v134 += 1 << v2;
        }
        while ( !v5 );
      }
      ++v2;
    }
    while ( v2 < 0x13 );
  }
  v5 = *(_BYTE *)(this + 19528) == 0;
  *(_BYTE *)(this + 19544) = 1;
  if ( !v5
    || (sub_41530F(this, a2), LOBYTE(v6) = sub_411E9F(this), (_BYTE)v6)
    && (a2 && *(_BYTE *)(this + 58996) || (LOBYTE(v6) = sub_413A24(this), (_BYTE)v6)) )
  {
    v7 = (_DWORD *)(this + 4);
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
LABEL_13:
            *(_DWORD *)(this + 112) &= *(_DWORD *)(this + 59128);
            if ( *v7 > *(_DWORD *)(this + 124) && !sub_411E9F(this) )
            {
LABEL_219:
              LOBYTE(v6) = sub_414AC4(this);
              return v6;
            }
            v8 = *(_DWORD *)(this + 112);
            if ( (*(_DWORD *)(this + 59128) & (unsigned int)(*(_DWORD *)(this + 116) - v8)) < 0x104
              && *(_DWORD *)(this + 116) != v8 )
            {
              sub_414AC4(this);
              v6 = *(_DWORD *)(this + 19540);
              if ( v6 > *(_DWORD *)(this + 19524) )
                return v6;
              if ( v6 >= *(_DWORD *)(this + 19524) )
              {
                v6 = *(_DWORD *)(this + 19536);
                if ( (unsigned int)v6 > *(_DWORD *)(this + 19520) )
                  return v6;
              }
              if ( *(_BYTE *)(this + 19528) )
              {
                *(_BYTE *)(this + 19544) = 0;
                return v6;
              }
            }
            if ( *(_DWORD *)(this + 58992) != 1 )
              break;
            v9 = sub_41366A(this + 39120);
            v10 = v9;
            if ( v9 == -1 )
            {
              sub_4135A1((unsigned int *)(this + 39120));
              *(_DWORD *)(this + 58992) = 0;
              goto LABEL_219;
            }
            if ( v9 != *(_DWORD *)(this + 58556) )
              goto LABEL_78;
            v11 = sub_41397A((unsigned int *)this);
            if ( v11 )
            {
              switch ( v11 )
              {
                case -1:
                case 2:
                  goto LABEL_219;
                case 3:
                  v12 = sub_4177C3((unsigned int *)this);
                  goto LABEL_26;
                case 4:
                  v13 = 0;
                  v150 = 0;
                  v125 = 0;
                  while ( !v150 )
                  {
                    v14 = sub_41397A((unsigned int *)this);
                    if ( v14 == -1 )
                    {
                      v150 = 1;
                    }
                    else if ( v125 == 3 )
                    {
                      v124 = (unsigned __int8)v14;
                    }
                    else
                    {
                      v13 = (unsigned __int8)v14 + (v13 << 8);
                    }
                    if ( ++v125 >= 4 )
                    {
                      if ( v150 )
                        goto LABEL_219;
                      v15 = *(_DWORD *)(this + 112);
                      v141 = v124 + 32;
                      v16 = v15 - (v13 + 2);
                      v126 = v13 + 2;
                      v17 = *(_DWORD *)(this + 59124) - 4097;
                      if ( v16 >= v17 || v15 >= v17 )
                      {
                        if ( v124 != -32 )
                        {
                          v25 = *(_DWORD *)(this + 59128);
                          do
                          {
                            --v141;
                            *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v16 & v25) + *(_DWORD *)(this + 19252));
                            v25 = *(_DWORD *)(this + 59128);
                            ++v16;
                            *(_DWORD *)(this + 112) = v25 & (*(_DWORD *)(this + 112) + 1);
                          }
                          while ( v141 );
                        }
                        goto LABEL_13;
                      }
                      v18 = *(_DWORD *)(this + 19252);
                      v19 = (_BYTE *)(v18 + v16);
                      v20 = (char *)(v15 + v18);
                      v138 = v20;
                      *(_DWORD *)(this + 112) = v141 + v15;
                      if ( v126 >= v141 )
                      {
                        if ( v141 >= 8 )
                        {
                          v127 = v141 >> 3;
                          do
                          {
                            memcpy(v138, v19, 8u);
                            v138 += 8;
                            v141 -= 8;
                            v19 += 8;
                            --v127;
                          }
                          while ( v127 );
                        }
                        goto LABEL_52;
                      }
                      if ( v141 < 8 )
                        goto LABEL_52;
                      v21 = v141 >> 3;
                      v22 = v20;
                      do
                      {
                        v141 -= 8;
                        *v22 = *v19;
                        v22[1] = v19[1];
                        v22[2] = v19[2];
                        v22[3] = v19[3];
                        v22[4] = v19[4];
                        v22[5] = v19[5];
                        v22[6] = v19[6];
                        v22[7] = v19[7];
                        v19 += 8;
                        v22 += 8;
                        --v21;
                      }
                      while ( v21 );
                      goto LABEL_48;
                    }
                  }
                  goto LABEL_219;
              }
              if ( v11 != 5 )
              {
LABEL_78:
                *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = v10;
                goto LABEL_92;
              }
              v26 = sub_41397A((unsigned int *)this);
              if ( v26 == -1 )
                goto LABEL_219;
              v141 = v26 + 4;
              v27 = *(_DWORD *)(this + 112);
              v28 = v27 - 1;
              v29 = *(_DWORD *)(this + 59124) - 4097;
              if ( v27 - 1 >= v29 || v27 >= v29 )
              {
                if ( v141 )
                {
                  v32 = *(_DWORD *)(this + 59128);
                  do
                  {
                    --v141;
                    *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v28 & v32)
                                                                                               + *(_DWORD *)(this + 19252));
                    v32 = *(_DWORD *)(this + 59128);
                    ++v28;
                    *(_DWORD *)(this + 112) = v32 & (*(_DWORD *)(this + 112) + 1);
                  }
                  while ( v141 );
                }
              }
              else
              {
                v30 = *(_DWORD *)(this + 19252);
                v19 = (_BYTE *)(v30 + v28);
                v138 = (char *)(v27 + v30);
                *(_DWORD *)(this + 112) = v141 + v27;
                if ( v141 >= 8 )
                {
                  v22 = (char *)(v27 + v30);
                  v31 = v141 >> 3;
                  do
                  {
                    v141 -= 8;
                    *v22 = *v19;
                    v22[1] = v19[1];
                    v22[2] = v19[2];
                    v22[3] = v19[3];
                    v22[4] = v19[4];
                    v22[5] = v19[5];
                    v22[6] = v19[6];
                    v22[7] = v19[7];
                    v19 += 8;
                    v22 += 8;
                    --v31;
                  }
                  while ( v31 );
LABEL_48:
                  v138 = v22;
                }
LABEL_52:
                v23 = v141;
                if ( v141 )
                {
                  v24 = v138;
                  goto LABEL_54;
                }
              }
            }
            else
            {
              v12 = sub_413A24(this);
LABEL_26:
              if ( !v12 )
                goto LABEL_219;
            }
          }
          v33 = sub_4094F9((_DWORD *)(this + 4));
          v34 = *(_DWORD *)(this + 280);
          v35 = v33 & 0xFFFE;
          if ( v35 >= *(_DWORD *)(this + 4 * v34 + 152) )
          {
            v39 = 15;
            v40 = v34 + 1;
            if ( (unsigned int)(v34 + 1) < 0xF )
            {
              v41 = (unsigned int *)(this + 4 * v40 + 152);
              while ( v35 >= *v41 )
              {
                ++v40;
                ++v41;
                if ( v40 >= 0xF )
                  goto LABEL_87;
              }
              v39 = v40;
            }
LABEL_87:
            v42 = v39 + *(_DWORD *)(this + 8);
            *(_DWORD *)(this + 8) = v42 & 7;
            *v7 += v42 >> 3;
            v43 = *(_DWORD *)(this + 4 * v39 + 216) + ((v35 - *(_DWORD *)(this + 4 * v39 + 148)) >> (16 - v39));
            if ( v43 >= *(_DWORD *)(this + 148) )
              v43 = 0;
            v38 = *(unsigned __int16 *)(this + 2 * v43 + 3356);
          }
          else
          {
            v36 = v35 >> (16 - v34);
            v37 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v36 + this + 284);
            *v7 += v37 >> 3;
            *(_DWORD *)(this + 8) = v37 & 7;
            v38 = *(unsigned __int16 *)(this + 2 * v36 + 1308);
          }
          if ( v38 >= 256 )
            break;
          *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = v38;
LABEL_92:
          ++*(_DWORD *)(this + 112);
        }
        if ( v38 >= 271 )
          break;
        switch ( v38 )
        {
          case 256:
            v12 = sub_414A4B(this);
            goto LABEL_26;
          case 257:
            v12 = sub_4176B3((_DWORD *)this);
            goto LABEL_26;
          case 258:
            if ( *(_DWORD *)(this + 104) )
            {
              v81 = *(_DWORD *)(this + 112);
              v145 = *(_DWORD *)(this + 104);
              v82 = v81 - *(_DWORD *)(this + 84);
              v83 = *(_DWORD *)(this + 59124) - 4097;
              if ( v82 >= v83 || v81 >= v83 )
              {
                if ( v145 )
                {
                  v87 = *(_DWORD *)(this + 59128);
                  do
                  {
                    --v145;
                    *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v82 & v87)
                                                                                               + *(_DWORD *)(this + 19252));
                    v87 = *(_DWORD *)(this + 59128);
                    ++v82;
                    *(_DWORD *)(this + 112) = v87 & (*(_DWORD *)(this + 112) + 1);
                  }
                  while ( v145 );
                }
              }
              else
              {
                v84 = *(_DWORD *)(this + 19252);
                v19 = (_BYTE *)(v84 + v82);
                v85 = (char *)(v81 + v84);
                v135 = v85;
                *(_DWORD *)(this + 112) = v145 + v81;
                if ( *(_DWORD *)(this + 84) >= v145 )
                {
                  if ( v145 >= 8 )
                  {
                    v131 = v145 >> 3;
                    do
                    {
                      memcpy(v135, v19, 8u);
                      v135 += 8;
                      v145 -= 8;
                      v19 += 8;
                      --v131;
                    }
                    while ( v131 );
                  }
                  goto LABEL_143;
                }
                if ( v145 >= 8 )
                {
                  v86 = v145 >> 3;
                  v79 = v85;
                  do
                  {
                    v145 -= 8;
                    *v79 = *v19;
                    v79[1] = v19[1];
                    v79[2] = v19[2];
                    v79[3] = v19[3];
                    v79[4] = v19[4];
                    v79[5] = v19[5];
                    v79[6] = v19[6];
                    v79[7] = v19[7];
                    v19 += 8;
                    v79 += 8;
                    --v86;
                  }
                  while ( v86 );
                  goto LABEL_139;
                }
LABEL_143:
                v23 = v145;
                if ( v145 )
                {
                  v24 = v135;
LABEL_54:
                  *v24 = *v19;
                  if ( v23 > 1 )
                  {
                    v24[1] = v19[1];
                    if ( v23 > 2 )
                    {
                      v24[2] = v19[2];
                      if ( v23 > 3 )
                      {
                        v24[3] = v19[3];
                        if ( v23 > 4 )
                        {
                          v24[4] = v19[4];
                          if ( v23 > 5 )
                          {
                            v24[5] = v19[5];
                            if ( v23 > 6 )
                              v24[6] = v19[6];
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;
          default:
            if ( v38 >= 263 )
            {
              v113 = (unsigned __int8)byte_42F081[v38] + 1;
              v148 = (unsigned __int8)byte_42F180[v38 - 263];
              if ( byte_42F180[v38 - 263] )
              {
                v113 += (unsigned int)sub_4094F9((_DWORD *)(this + 4)) >> (16 - v148);
                v114 = v148 + *(_DWORD *)(this + 8);
                *v7 += v114 >> 3;
                *(_DWORD *)(this + 8) = v114 & 7;
              }
              v115 = *(_DWORD *)(this + 112);
              v116 = *(_DWORD *)(this + 59124);
              *(_DWORD *)(this + 96) = *(_DWORD *)(this + 92);
              *(_DWORD *)(this + 92) = *(_DWORD *)(this + 88);
              *(_DWORD *)(this + 88) = *(_DWORD *)(this + 84);
              *(_DWORD *)(this + 104) = 2;
              v149 = 2;
              v117 = v115 - v113;
              v118 = v116 - 4097;
              *(_DWORD *)(this + 84) = v113;
              if ( v115 - v113 >= v118 || v115 >= v118 )
              {
                v122 = *(_DWORD *)(this + 59128);
                do
                {
                  --v149;
                  *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v117 & v122)
                                                                                             + *(_DWORD *)(this + 19252));
                  v122 = *(_DWORD *)(this + 59128);
                  ++v117;
                  *(_DWORD *)(this + 112) = v122 & (*(_DWORD *)(this + 112) + 1);
                }
                while ( v149 );
              }
              else
              {
                v119 = *(_DWORD *)(this + 19252);
                v120 = (_BYTE *)(v119 + v117);
                v121 = (_BYTE *)(v115 + v119);
                *(_DWORD *)(this + 112) = v115 + 2;
                *v121 = *v120;
                v121[1] = v120[1];
              }
            }
            else
            {
              v88 = v38 - 259;
              v89 = (void **)(this + 4 * v88 + 84);
              v90 = *v89;
              v136 = *v89;
              while ( v88 > 0 )
              {
                *v89 = *(v89 - 1);
                --v88;
                --v89;
              }
              *(_DWORD *)(this + 84) = v90;
              v91 = sub_4094F9((_DWORD *)(this + 4));
              v92 = *(_DWORD *)(this + 11740);
              v93 = v91 & 0xFFFE;
              if ( v93 >= *(_DWORD *)(this + 4 * v92 + 11612) )
              {
                v97 = 15;
                v98 = v92 + 1;
                if ( v98 < 0xF )
                {
                  v99 = (unsigned int *)(this + 4 * v98 + 11612);
                  while ( v93 >= *v99 )
                  {
                    ++v98;
                    ++v99;
                    if ( v98 >= 0xF )
                      goto LABEL_182;
                  }
                  v97 = v98;
                }
LABEL_182:
                v100 = v97 + *(_DWORD *)(this + 8);
                *(_DWORD *)(this + 8) = v100 & 7;
                *v7 += v100 >> 3;
                v101 = *(_DWORD *)(this + 4 * v97 + 11676) + ((v93 - *(_DWORD *)(this + 4 * v97 + 11608)) >> (16 - v97));
                if ( v101 >= *(_DWORD *)(this + 11608) )
                  v101 = 0;
                v96 = *(unsigned __int16 *)(this + 2 * v101 + 14816);
              }
              else
              {
                v94 = v93 >> (16 - v92);
                v95 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v94 + this + 11744);
                *v7 += v95 >> 3;
                *(_DWORD *)(this + 8) = v95 & 7;
                v96 = *(unsigned __int16 *)(this + 2 * v94 + 12768);
              }
              v102 = (unsigned __int8)byte_42F1AC[v96] + 2;
              v132 = v102;
              v146 = (unsigned __int8)byte_42F190[v96];
              if ( byte_42F190[v96] )
              {
                v102 += (unsigned int)sub_4094F9((_DWORD *)(this + 4)) >> (16 - v146);
                v103 = v146 + *(_DWORD *)(this + 8);
                v132 = v102;
                *v7 += v103 >> 3;
                *(_DWORD *)(this + 8) = v103 & 7;
              }
              v104 = *(_DWORD *)(this + 112);
              v105 = v104 - (_DWORD)v136;
              v106 = *(_DWORD *)(this + 59124) - 4097;
              *(_DWORD *)(this + 104) = v102;
              v147 = v102;
              if ( v104 - (unsigned int)v136 >= v106 || v104 >= v106 )
              {
                if ( v102 )
                {
                  v112 = *(_DWORD *)(this + 59128);
                  do
                  {
                    --v147;
                    *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v105 & v112)
                                                                                               + *(_DWORD *)(this + 19252));
                    v112 = *(_DWORD *)(this + 59128);
                    ++v105;
                    *(_DWORD *)(this + 112) = v112 & (*(_DWORD *)(this + 112) + 1);
                  }
                  while ( v147 );
                }
              }
              else
              {
                v107 = *(_DWORD *)(this + 19252);
                v108 = (_BYTE *)(v107 + v105);
                v109 = (_BYTE *)(v104 + v107);
                v140 = v109;
                *(_DWORD *)(this + 112) = v132 + v104;
                if ( (unsigned int)v136 >= v132 )
                {
                  if ( v132 >= 8 )
                  {
                    v133 = v132 >> 3;
                    do
                    {
                      memcpy(v140, v108, 8u);
                      v140 += 8;
                      v147 -= 8;
                      v108 += 8;
                      --v133;
                    }
                    while ( v133 );
                  }
                }
                else if ( v132 >= 8 )
                {
                  v110 = v132 >> 3;
                  v111 = v109;
                  do
                  {
                    v147 -= 8;
                    *v111 = *v108;
                    v111[1] = v108[1];
                    v111[2] = v108[2];
                    v111[3] = v108[3];
                    v111[4] = v108[4];
                    v111[5] = v108[5];
                    v111[6] = v108[6];
                    v111[7] = v108[7];
                    v108 += 8;
                    v111 += 8;
                    --v110;
                  }
                  while ( v110 );
                  v140 = v111;
                }
                if ( v147 )
                {
                  *v140 = *v108;
                  if ( v147 != 1 )
                  {
                    v140[1] = v108[1];
                    if ( v147 > 2 )
                    {
                      v140[2] = v108[2];
                      if ( v147 > 3 )
                      {
                        v140[3] = v108[3];
                        if ( v147 > 4 )
                        {
                          v140[4] = v108[4];
                          if ( v147 > 5 )
                          {
                            v140[5] = v108[5];
                            if ( v147 > 6 )
                              v140[6] = v108[6];
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;
        }
      }
      v139 = (unsigned __int8)byte_42F09D[v38] + 3;
      v142 = (unsigned __int8)byte_42F190[v38 - 271];
      if ( byte_42F190[v38 - 271] )
      {
        v44 = (unsigned __int8)byte_42F09D[v38] + 3;
        v45 = ((unsigned int)sub_4094F9((_DWORD *)(this + 4)) >> (16 - v142)) + v44;
        v46 = v142 + *(_DWORD *)(this + 8);
        v139 = v45;
        *v7 += v46 >> 3;
        *(_DWORD *)(this + 8) = v46 & 7;
      }
      v47 = sub_4094F9((_DWORD *)(this + 4));
      v48 = *(_DWORD *)(this + 4100);
      v49 = v47 & 0xFFFE;
      if ( v49 >= *(_DWORD *)(this + 4 * v48 + 3972) )
      {
        v53 = 15;
        v54 = v48 + 1;
        if ( (unsigned int)(v48 + 1) < 0xF )
        {
          v55 = (unsigned int *)(this + 4 * v54 + 3972);
          while ( v49 >= *v55 )
          {
            ++v54;
            ++v55;
            if ( v54 >= 0xF )
              goto LABEL_104;
          }
          v53 = v54;
        }
LABEL_104:
        v56 = v53 + *(_DWORD *)(this + 8);
        *(_DWORD *)(this + 8) = v56 & 7;
        *v7 += v56 >> 3;
        v57 = *(_DWORD *)(this + 4 * v53 + 4036) + ((v49 - *(_DWORD *)(this + 4 * v53 + 3968)) >> (16 - v53));
        if ( v57 >= *(_DWORD *)(this + 3968) )
          v57 = 0;
        v52 = *(unsigned __int16 *)(this + 2 * v57 + 7176);
      }
      else
      {
        v50 = v49 >> (16 - v48);
        v51 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v50 + this + 4104);
        *v7 += v51 >> 3;
        *(_DWORD *)(this + 8) = v51 & 7;
        v52 = *(unsigned __int16 *)(this + 2 * v50 + 5128);
      }
      v58 = dword_44EBB8[v52] + 1;
      v128 = v58;
      v143 = (unsigned __int8)byte_44EB78[v52];
      if ( byte_44EB78[v52] )
        break;
LABEL_130:
      if ( v58 >= 0x2000 )
      {
        ++v139;
        if ( v58 >= 0x40000 )
          ++v139;
      }
      v73 = *(_DWORD *)(this + 112);
      v74 = *(_DWORD *)(this + 59124);
      *(_DWORD *)(this + 96) = *(_DWORD *)(this + 92);
      *(_DWORD *)(this + 92) = *(_DWORD *)(this + 88);
      *(_DWORD *)(this + 88) = *(_DWORD *)(this + 84);
      *(_DWORD *)(this + 104) = v139;
      v145 = v139;
      v75 = v73 - v58;
      v76 = v74 - 4097;
      *(_DWORD *)(this + 84) = v58;
      if ( v73 - v58 < v76 && v73 < v76 )
      {
        v77 = *(_DWORD *)(this + 19252);
        v19 = (_BYTE *)(v77 + v75);
        v78 = (char *)(v73 + v77);
        v135 = v78;
        *(_DWORD *)(this + 112) = v139 + v73;
        if ( v128 >= v139 )
        {
          if ( v139 >= 8 )
          {
            v130 = v139 >> 3;
            do
            {
              memcpy(v135, v19, 8u);
              v135 += 8;
              v145 -= 8;
              v19 += 8;
              --v130;
            }
            while ( v130 );
          }
          goto LABEL_143;
        }
        if ( v139 >= 8 )
        {
          v129 = v139 >> 3;
          v79 = v78;
          do
          {
            v145 -= 8;
            *v79 = *v19;
            v79[1] = v19[1];
            v79[2] = v19[2];
            v79[3] = v19[3];
            v79[4] = v19[4];
            v79[5] = v19[5];
            v79[6] = v19[6];
            v79[7] = v19[7];
            v19 += 8;
            v79 += 8;
            --v129;
          }
          while ( v129 );
LABEL_139:
          v135 = v79;
          goto LABEL_143;
        }
        goto LABEL_143;
      }
      if ( v139 )
      {
        v80 = *(_DWORD *)(this + 59128);
        do
        {
          --v145;
          *(_BYTE *)(*(_DWORD *)(this + 19252) + *(_DWORD *)(this + 112)) = *(_BYTE *)((v75 & v80)
                                                                                     + *(_DWORD *)(this + 19252));
          v80 = *(_DWORD *)(this + 59128);
          ++v75;
          *(_DWORD *)(this + 112) = v80 & (*(_DWORD *)(this + 112) + 1);
        }
        while ( v145 );
      }
    }
    if ( v52 <= 9 )
    {
      v58 += (unsigned int)sub_4094F9((_DWORD *)(this + 4)) >> (16 - v143);
      v72 = v143 + *(_DWORD *)(this + 8);
      *v7 += v72 >> 3;
      *(_DWORD *)(this + 8) = v72 & 7;
      goto LABEL_129;
    }
    if ( (unsigned __int8)byte_44EB78[v52] > 4u )
    {
      v59 = sub_4094F9((_DWORD *)(this + 4));
      v60 = *(_DWORD *)(this + 8) + v143 - 4;
      *v7 += v60 >> 3;
      v58 += 16 * (v59 >> (20 - v143));
      *(_DWORD *)(this + 8) = v60 & 7;
    }
    v61 = *(_DWORD *)(this + 39116);
    if ( v61 <= 0 )
    {
      v62 = sub_4094F9((_DWORD *)(this + 4));
      v63 = *(_DWORD *)(this + 7920);
      v64 = v62 & 0xFFFE;
      if ( v64 >= *(_DWORD *)(this + 4 * v63 + 7792) )
      {
        v68 = v63 + 1;
        v144 = 15;
        if ( v68 < 0xF )
        {
          v69 = (unsigned int *)(this + 4 * v68 + 7792);
          while ( v64 >= *v69 )
          {
            ++v68;
            ++v69;
            if ( v68 >= 0xF )
              goto LABEL_122;
          }
          v144 = v68;
        }
LABEL_122:
        v70 = v144 + *(_DWORD *)(this + 8);
        *(_DWORD *)(this + 4) += v70 >> 3;
        *(_DWORD *)(this + 8) = v70 & 7;
        v71 = *(_DWORD *)(this + 4 * v144 + 7856) + ((v64 - *(_DWORD *)(this + 4 * v144 + 7788)) >> (16 - v144));
        if ( v71 >= *(_DWORD *)(this + 7788) )
          v71 = 0;
        v67 = *(unsigned __int16 *)(this + 2 * v71 + 10996);
      }
      else
      {
        v65 = v64 >> (16 - v63);
        v66 = *(_DWORD *)(this + 8) + *(unsigned __int8 *)(v65 + this + 7924);
        *v7 += v66 >> 3;
        *(_DWORD *)(this + 8) = v66 & 7;
        v67 = *(unsigned __int16 *)(this + 2 * v65 + 8948);
      }
      if ( v67 != 16 )
      {
        v58 += v67;
        *(_DWORD *)(this + 39112) = v67;
        goto LABEL_129;
      }
      *(_DWORD *)(this + 39116) = 15;
    }
    else
    {
      *(_DWORD *)(this + 39116) = v61 - 1;
    }
    v58 += *(_DWORD *)(this + 39112);
LABEL_129:
    v128 = v58;
    goto LABEL_130;
  }
  return v6;
}
// 418520: conditional instruction was optimized away because eax.4 is in (107..10E)
// 417C98: conditional instruction was optimized away because %arg_0.4<2u
// 417A81: variable 'v124' is possibly undefined
// 42F1C8: using guessed type size_t Size[27];
// 44EBB8: using guessed type int dword_44EBB8[];
// 44EBBC: using guessed type int dword_44EBBC;

//----- (0041861B) --------------------------------------------------------
unsigned __int8 __thiscall sub_41861B(int this, int a2, char a3)
{
  unsigned __int8 result; // al

  if ( a2 )
  {
    if ( a2 == 29 )
      return sub_417894(this, a3);
  }
  else if ( *(_DWORD *)(this + 28) <= 1u || *(_BYTE *)(this + 19512) )
  {
    return sub_416767(this, a3);
  }
  else
  {
    return (unsigned __int8)sub_4172C2(this, a3);
  }
  return result;
}

//----- (00418659) --------------------------------------------------------
char __stdcall sub_418659(_DWORD *a1, int a2, int a3, __int16 a4)
{
  int v5; // eax
  _DWORD *v6; // edi
  int v8; // edi
  __int64 v10; // kr00_8
  _DWORD *v11; // edi
  __int64 v12; // rax
  wchar_t Source[2048]; // [esp+Ch] [ebp-2014h] BYREF
  wchar_t Destination[2048]; // [esp+100Ch] [ebp-1014h] BYREF
  __int64 v15; // [esp+200Ch] [ebp-14h]
  int v16; // [esp+2014h] [ebp-Ch]
  int v17; // [esp+2018h] [ebp-8h]
  _DWORD *v18; // [esp+201Ch] [ebp-4h]
  char v19; // [esp+202Bh] [ebp+Bh]
  char v20; // [esp+202Fh] [ebp+Fh]

  v17 = a1[5569];
  v5 = a1[5577];
  v16 = v5;
  if ( v5 == 3 )
  {
    v6 = a1 + 7874;
    v18 = a1 + 7874;
  }
  else
  {
    v18 = a1 + 5618;
    v6 = a1 + 5618;
    if ( v5 != 2 )
    {
LABEL_5:
      v19 = 0;
      goto LABEL_6;
    }
  }
  v19 = 1;
  if ( !*((_BYTE *)v6 + 4233) )
    goto LABEL_5;
LABEL_6:
  if ( a2
    && v19
    && (a1[10380] == 3 || *((_BYTE *)v6 + 25) >= 0x14u && v6[1049] != -1)
    && !sub_409856((int *)(a2 + 6304), v6 + 1048, *((_BYTE *)v6 + 4282) != 0 ? (char *)v6 + 4283 : 0) )
  {
    sub_4062C8(5, (int)a1 + 30, (int)(v6 + 8));
  }
  v15 = ((__int64 (__thiscall *)(_DWORD *))*(_DWORD *)(*a1 + 16))(a1);
  if ( a2 )
    *(_QWORD *)(a2 + 6288) += sub_408B84(a1);
  sub_4087BE((int)a1);
  wcscpy(Destination, (const wchar_t *)a1 + 15);
  sub_40A394(Destination, 2048, *((_BYTE *)a1 + 41530) == 0);
  v20 = 0;
  v8 = *(_BYTE *)(v17 + 20885) != 0 ? 4 : 0;
  while ( !(*(unsigned __int8 (__thiscall **)(_DWORD *, wchar_t *, int))(*a1 + 4))(a1, Destination, v8) )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 6296) = 0;
      *(_DWORD *)(a2 + 6300) = 0;
    }
    if ( !v20 )
    {
      wcscpy(Source, (const wchar_t *)a1 + 15);
      sub_40A394(Source, 2048, 1);
      v20 = 1;
      if ( (*(unsigned __int8 (__thiscall **)(_DWORD *, wchar_t *, int))(*a1 + 4))(a1, Source, v8) )
      {
        wcscpy(Destination, Source);
        break;
      }
    }
    if ( *(_BYTE *)(v17 + 20860) || !sub_4114F9((LPARAM)Destination, 2048) )
    {
      sub_4012DD(68, (int)Destination);
      (*(void (__thiscall **)(_DWORD *, int, int))(*a1 + 4))(a1, (int)a1 + 30, v8);
      (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*a1 + 12))(a1, v15, HIDWORD(v15), 0);
      return 0;
    }
  }
  sub_41123B(a4 != 84, (wchar_t *)a1 + 15);
  sub_401A23((int)a1, 1);
  if ( v19 )
    sub_4036AE(a1, v16);
  else
    sub_40363F(a1);
  if ( a1[5577] == 2 )
  {
    sub_401A98((int)a1);
    v10 = *((_QWORD *)a1 + 5189) - *((_QWORD *)a1 + 3330);
    (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD))(*a1 + 12))(a1, v10, HIDWORD(v10), 0);
  }
  if ( a2 )
  {
    v11 = v18;
    if ( v16 == 5 )
    {
      *(_BYTE *)(a2 + 6239) = 0;
    }
    else
    {
      *(_BYTE *)(a2 + 6239) = *((_BYTE *)v18 + 4233);
      *(_DWORD *)(a2 + 32) = v11[1042];
      *(_DWORD *)(a2 + 36) = v11[1043];
    }
    v12 = sub_408B84(a1);
    *(_DWORD *)(a2 + 6272) = 0;
    *(_DWORD *)(a2 + 6276) = 0;
    *(_DWORD *)(a2 + 6248) = v12;
    LODWORD(v12) = v17;
    *(_DWORD *)(a2 + 6252) = HIDWORD(v12);
    sub_4095F2((void *)(a2 + 6304), v11[1048], *(_DWORD *)(v12 + 29336));
  }
  return 1;
}
// 40363F: using guessed type int __thiscall sub_40363F(_DWORD);

//----- (00418932) --------------------------------------------------------
int __thiscall sub_418932(_DWORD *this)
{
  int result; // eax

  result = this[6];
  *this = &off_42AE50;
  this[1] = &off_42AE14;
  this[2] = &off_42ADD8;
  this[3] = &off_42ADBC;
  if ( result )
  {
    result = (*(int (__stdcall **)(int))(*(_DWORD *)result + 8))(result);
    this[6] = 0;
  }
  return result;
}
// 42ADBC: using guessed type int (__stdcall *off_42ADBC)(int, int, int);
// 42ADD8: using guessed type void *off_42ADD8;
// 42AE14: using guessed type void *off_42AE14;
// 42AE50: using guessed type int (__stdcall *off_42AE50)(int, void *Buf1, int);

//----- (00418963) --------------------------------------------------------
int __stdcall sub_418963(int a1)
{
  return ++*(_DWORD *)(a1 + 16);
}

//----- (00418970) --------------------------------------------------------
int __stdcall sub_418970(int a1, int a2, int a3, int a4)
{
  return -2147467263;
}

//----- (00418978) --------------------------------------------------------
int __stdcall sub_418978(int a1, int a2)
{
  return -2147467262;
}

//----- (00418980) --------------------------------------------------------
int __stdcall sub_418980(int a1, _DWORD *a2)
{
  if ( !IsWindow(*(HWND *)(a1 + 16)) )
    return 1;
  *a2 = *(_DWORD *)(a1 + 16);
  return 0;
}

//----- (004189A4) --------------------------------------------------------
int __stdcall sub_4189A4(int a1)
{
  return 0;
}

//----- (004189A9) --------------------------------------------------------
int __stdcall sub_4189A9(int a1, _DWORD *a2, _DWORD *a3, RECT *lprcSrc, LPRECT lprcDst, _DWORD *a6)
{
  int v6; // eax
  LONG bottom; // ecx
  struct tagRECT Rect; // [esp+Ch] [ebp-10h] BYREF

  if ( a1 == 4 )
    v6 = 0;
  else
    v6 = a1 + 4;
  *a2 = v6;
  *a3 = 0;
  GetClientRect(*(HWND *)(a1 + 16), &Rect);
  lprcSrc->right = Rect.right;
  bottom = Rect.bottom;
  lprcSrc->left = 0;
  lprcSrc->top = 0;
  lprcSrc->bottom = bottom;
  CopyRect(lprcDst, lprcSrc);
  *a6 = 20;
  a6[1] = 0;
  a6[2] = *(_DWORD *)(a1 + 16);
  a6[3] = 0;
  a6[4] = 0;
  (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*a2 + 4))(*a2);
  return 0;
}

//----- (00418A23) --------------------------------------------------------
int __stdcall sub_418A23(int a1, int a2, int a3)
{
  return -2147467263;
}

//----- (00418A2B) --------------------------------------------------------
int __stdcall sub_418A2B(int a1, int a2)
{
  return -2147467263;
}

//----- (00418A33) --------------------------------------------------------
int __stdcall sub_418A33(int a1)
{
  return -2147467263;
}

//----- (00418A3B) --------------------------------------------------------
int __stdcall sub_418A3B(int a1, int a2)
{
  return 0;
}

//----- (00418A40) --------------------------------------------------------
BOOL __stdcall sub_418A40(void *Buf1, void *Buf2)
{
  return memcmp(Buf1, Buf2, 0x10u) == 0;
}

//----- (00418A5A) --------------------------------------------------------
int __stdcall sub_418A5A(int a1, int a2, int a3)
{
  return 0;
}

//----- (00418A5F) --------------------------------------------------------
int __stdcall sub_418A5F(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  *a6 = -1;
  return -2147352570;
}

//----- (00418A6E) --------------------------------------------------------
int __stdcall sub_418A6E(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  return -2147352573;
}

//----- (00418A76) --------------------------------------------------------
HRESULT __thiscall sub_418A76(LPVOID *this, LPCOLESTR lpsz)
{
  _DWORD *v3; // esi
  HRESULT result; // eax
  CLSID pclsid; // [esp+8h] [ebp-14h] BYREF
  int v6; // [esp+18h] [ebp-4h] BYREF

  CLSIDFromString(lpsz, &pclsid);
  v3 = this + 6;
  result = CoCreateInstance(&pclsid, 0, 5u, &Buf2, this + 6);
  if ( this[6] )
  {
    result = (**(int (__stdcall ***)(_DWORD, void *, LPCOLESTR *))*v3)(*v3, &unk_42B0D8, &lpsz);
    if ( result >= 0 )
    {
      (*(void (__stdcall **)(LPCOLESTR, LPVOID *))(*(_DWORD *)lpsz + 12))(lpsz, this);
      (*(void (__stdcall **)(LPCOLESTR))(*(_DWORD *)lpsz + 8))(lpsz);
      result = (**(int (__stdcall ***)(_DWORD, void *, int *))*v3)(*v3, &unk_42B0B8, &v6);
      if ( result >= 0 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v6 + 32))(v6);
        return (*(int (__stdcall **)(int))(*(_DWORD *)v6 + 8))(v6);
      }
    }
  }
  return result;
}

//----- (00418AFC) --------------------------------------------------------
int (__stdcall ***__thiscall sub_418AFC(_DWORD *this))(_DWORD, void *, int *)
{
  int (__stdcall ***result)(_DWORD, void *, int *); // eax
  int v3; // [esp+4h] [ebp-8h] BYREF
  int v4; // [esp+8h] [ebp-4h] BYREF

  result = (int (__stdcall ***)(_DWORD, void *, int *))this[6];
  if ( result )
  {
    if ( (**result)(result, &unk_42B0D8, &v4) >= 0 )
    {
      (*(void (__stdcall **)(int, int))(*(_DWORD *)v4 + 24))(v4, 1);
      (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)v4 + 12))(v4, 0);
      (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
    }
    if ( (**(int (__stdcall ***)(_DWORD, void *, int *))this[6])(this[6], &unk_42B0F8, &v3) >= 0 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 24))(v3);
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 20))(v3);
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
    }
    result = (int (__stdcall ***)(_DWORD, void *, int *))(*(int (__stdcall **)(_DWORD))(*(_DWORD *)this[6] + 8))(this[6]);
    this[6] = 0;
  }
  return result;
}

//----- (00418B7C) --------------------------------------------------------
void __thiscall sub_418B7C(_DWORD *this, int a2)
{
  int v3; // ecx
  int *v4; // [esp+8h] [ebp-4h] BYREF

  if ( this[6] && (**(int (__stdcall ***)(_DWORD, void *, int *))this[6])(this[6], &unk_42B0D8, (int *)&v4) >= 0 )
  {
    v3 = *v4;
    if ( a2 )
    {
      (*(void (__stdcall **)(int *, int, _DWORD, _DWORD *, _DWORD, _DWORD, _DWORD *))(v3 + 44))(
        v4,
        -5,
        0,
        this,
        0,
        this[5],
        this + 7);
      (*(void (__stdcall **)(int *, int, _DWORD, _DWORD *, _DWORD, _DWORD, _DWORD *))(*v4 + 44))(
        v4,
        -1,
        0,
        this,
        0,
        this[5],
        this + 7);
    }
    else
    {
      (*(void (__stdcall **)(int *, int, _DWORD, _DWORD *, _DWORD, _DWORD, _DWORD))(v3 + 44))(
        v4,
        -3,
        0,
        this,
        0,
        this[5],
        0);
    }
    (*(void (__stdcall **)(int *))(*v4 + 8))(v4);
  }
}

//----- (00418BEC) --------------------------------------------------------
void __thiscall sub_418BEC(_DWORD *this, int a2)
{
  if ( this[6] && a2 && (**(int (__stdcall ***)(_DWORD, void *, int *))this[6])(this[6], &unk_42B0D8, &a2) >= 0 )
  {
    (*(void (__stdcall **)(int, int, _DWORD, _DWORD *, _DWORD, _DWORD, _DWORD *))(*(_DWORD *)a2 + 44))(
      a2,
      -4,
      0,
      this,
      0,
      this[5],
      this + 7);
    (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 8))(a2);
  }
}

//----- (00418C38) --------------------------------------------------------
int __thiscall sub_418C38(_DWORD *this)
{
  if ( !this[6] )
    return 0;
  (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this[6] + 4))(this[6]);
  return this[6];
}

//----- (00418C53) --------------------------------------------------------
_DWORD *__thiscall sub_418C53(_DWORD *this)
{
  _DWORD *result; // eax

  result = this;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  *((_BYTE *)this + 24) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 33) = 0;
  this[9] = 0;
  return result;
}

//----- (00418C75) --------------------------------------------------------
int __thiscall sub_418C75(_DWORD *this)
{
  int result; // eax
  _DWORD *v3; // ecx

  result = this[3];
  if ( result )
  {
    result = (*(int (__stdcall **)(int))(*(_DWORD *)result + 8))(result);
    this[3] = 0;
  }
  v3 = (_DWORD *)this[2];
  if ( v3 )
  {
    sub_418AFC(v3);
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this[2] + 8))(this[2]);
    this[2] = 0;
  }
  return result;
}

//----- (00418CA4) --------------------------------------------------------
HWND __thiscall sub_418CA4(HWND *this)
{
  HWND result; // eax

  result = this[1];
  if ( result )
  {
    result = (HWND)DestroyWindow(this[1]);
    this[1] = 0;
  }
  return result;
}

//----- (00418CBB) --------------------------------------------------------
BOOL __stdcall sub_418CBB(int a1, int a2)
{
  int v2; // esi
  struct tagMSG Msg; // [esp+Ch] [ebp-28h] BYREF
  DWORD TickCount; // [esp+28h] [ebp-Ch]
  int v6; // [esp+2Ch] [ebp-8h] BYREF
  int v7; // [esp+30h] [ebp-4h] BYREF

  v7 = 0;
  v6 = 0;
  TickCount = GetTickCount();
  while ( ((*(int (__stdcall **)(int, int *))(*(_DWORD *)a1 + 72))(a1, &v7) < 0 || !v7)
       && GetTickCount() - TickCount <= 0x2710 )
  {
    if ( PeekMessageW(&Msg, 0, 0, 0, 0) )
    {
      GetMessageW(&Msg, 0, 0, 0);
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
  }
  v2 = (*(int (__stdcall **)(int, int *))(*(_DWORD *)a1 + 72))(a1, &v7);
  if ( v2 >= 0 )
  {
    v2 = (**(int (__stdcall ***)(int, void *, int *))v7)(v7, &unk_42B0B8, &v6);
    if ( v2 >= 0 )
    {
      v2 = (*(int (__stdcall **)(int))(*(_DWORD *)v6 + 32))(v6);
      if ( v2 >= 0 )
        v2 = (*(int (__stdcall **)(int, int))(*(_DWORD *)v6 + 20))(v6, a2);
      (*(void (__stdcall **)(int))(*(_DWORD *)v6 + 8))(v6);
    }
    (*(void (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  return v2 >= 0;
}

//----- (00418D92) --------------------------------------------------------
char __stdcall sub_418D92(_WORD *a1)
{
  int v2; // ecx

  while ( 1 )
  {
    if ( !*a1 )
      return 0;
    if ( *a1 == 60 && a1[1] == 47 )
      break;
LABEL_7:
    ++a1;
  }
  v2 = 2;
  while ( a1[v2] != 62 )
  {
    if ( (unsigned int)++v2 >= 0x14 )
      goto LABEL_7;
  }
  return 1;
}

//----- (00418DC8) --------------------------------------------------------
wchar_t *__stdcall sub_418DC8(wchar_t *Block)
{
  wchar_t *v1; // esi
  size_t v2; // eax
  wchar_t *v3; // eax
  const wchar_t *v4; // edi
  size_t v6; // ebx
  wchar_t *v7; // edi
  wchar_t *v8; // [esp+8h] [ebp-8h]
  wchar_t *Destination; // [esp+Ch] [ebp-4h]

  v1 = Block;
  v2 = wcslen(Block);
  v3 = (wchar_t *)malloc(12 * v2 + 512);
  v4 = v3;
  v8 = v3;
  if ( !v3 )
    return Block;
  wcscpy(v3, L"<style>body{font-family:\"Arial\";font-size:12;}</style>");
  v6 = wcslen(v4);
  if ( *Block )
  {
    do
    {
      if ( sub_4119C7(v1, L"\r\n\r\n", 4u) )
      {
        if ( v1 > Block && *v1 == 32 && *(v1 - 1) == 32 )
        {
          wcscpy((wchar_t *)&v4[v6], L"&nbsp;");
          v6 += 6;
        }
        else
        {
          v4[v6++] = *v1;
        }
      }
      else
      {
        v7 = v1 + 2;
        if ( v1[2] == 13 )
        {
          Destination = &v8[v6];
          do
          {
            if ( v1[3] != 10 )
              break;
            wcscpy(Destination, L"<br>");
            Destination += 4;
            v1 = v7;
            v7 += 2;
            v6 += 4;
          }
          while ( *v7 == 13 );
        }
        v4 = v8;
        ++v1;
      }
      ++v1;
    }
    while ( *v1 );
  }
  v4[v6] = 0;
  free(Block);
  return (wchar_t *)v4;
}

//----- (00418EC0) --------------------------------------------------------
int __thiscall sub_418EC0(_DWORD **this)
{
  unsigned int i; // eax
  _DWORD *v2; // eax
  struct tagMSG Msg; // [esp+Ch] [ebp-38h] BYREF
  VARIANTARG pvarg; // [esp+28h] [ebp-1Ch] BYREF
  int v6; // [esp+38h] [ebp-Ch] BYREF
  _DWORD **v7; // [esp+3Ch] [ebp-8h]
  DWORD TickCount; // [esp+40h] [ebp-4h]

  v7 = this;
  TickCount = GetTickCount();
  for ( i = GetTickCount() - TickCount; i <= 0x2710; i = GetTickCount() - TickCount )
  {
    (*(void (__stdcall **)(_DWORD *, int *))(*v7[3] + 224))(v7[3], &v6);
    if ( v6 == 4 )
      break;
    if ( PeekMessageW(&Msg, 0, 0, 0, 0) )
    {
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
      GetMessageW(&Msg, 0, 0, 0);
    }
  }
  VariantInit(&pvarg);
  pvarg.vt = 3;
  v2 = v7[3];
  pvarg.lVal = 150;
  return (*(int (__stdcall **)(_DWORD *, int, int, VARIANTARG *, _DWORD))(*v2 + 216))(v2, 63, 2, &pvarg, 0);
}

//----- (00418F6F) --------------------------------------------------------
int __stdcall sub_418F6F(int a1, int a2)
{
  return sub_418A2B(a1 - 4, a2);
}

//----- (00418F97) --------------------------------------------------------
int __stdcall sub_418F97(int a1)
{
  return sub_418963(a1 - 12);
}

//----- (00418FA1) --------------------------------------------------------
int __stdcall sub_418FA1(int a1, void *Buf1, _DWORD *a3)
{
  int v4; // eax
  int v5; // ecx

  if ( !a3 )
    return -2147467261;
  if ( sub_418A40(Buf1, &unk_42B0C8) )
    goto LABEL_16;
  if ( sub_418A40(Buf1, &unk_42B108) )
  {
    v4 = a1;
    if ( a1 )
    {
      v5 = a1 + 4;
LABEL_14:
      *a3 = v5;
LABEL_17:
      (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 4))(v4);
      return 0;
    }
    goto LABEL_13;
  }
  if ( sub_418A40(Buf1, &unk_42B0E8) )
  {
    v4 = a1;
    if ( a1 )
    {
      v5 = a1 + 8;
      goto LABEL_14;
    }
LABEL_13:
    v5 = 0;
    goto LABEL_14;
  }
  if ( sub_418A40(Buf1, &unk_42B128) )
  {
    v4 = a1;
    if ( a1 )
    {
      v5 = a1 + 12;
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if ( sub_418A40(Buf1, (void *)&Buf2) )
  {
LABEL_16:
    v4 = a1;
    *a3 = a1;
    goto LABEL_17;
  }
  *a3 = 0;
  return -2147467262;
}

//----- (0041904C) --------------------------------------------------------
int __stdcall sub_41904C(_DWORD *a1)
{
  bool v1; // zf
  int result; // eax

  v1 = a1[4]-- == 1;
  result = a1[4];
  if ( v1 )
  {
    sub_418932(a1);
    operator delete(a1);
    return 0;
  }
  return result;
}

//----- (0041906D) --------------------------------------------------------
void __thiscall sub_41906D(int *this, wchar_t *String)
{
  const wchar_t *v2; // esi
  size_t v3; // eax
  wchar_t *v4; // eax
  wchar_t *v5; // edi
  bool v6; // zf
  int v7; // eax
  bool v8; // bl
  SIZE_T v9; // esi
  CHAR *v10; // ebx
  LPSTREAM ppstm; // [esp+4h] [ebp-8h] BYREF
  PCNZWCH lpString1; // [esp+8h] [ebp-4h]
  char String_3; // [esp+17h] [ebp+Bh]

  if ( this[3] )
  {
    ppstm = 0;
    v2 = String;
    String_3 = sub_418D92(String);
    v3 = wcslen(v2);
    v4 = (wchar_t *)malloc(2 * v3 + 512);
    v5 = v4;
    if ( v4 )
    {
      wcscpy(v4, L"<html>");
      wcscat(v5, L"<head><meta http-equiv=\"content-type\" content=\"text/html; charset=");
      wcscat(v5, L"utf-8\"></head>");
      v6 = *v2 == 32;
      lpString1 = v2;
      if ( v6 )
      {
        do
          ++lpString1;
        while ( *lpString1 == 32 );
      }
      v7 = sub_4119C7(lpString1, L"<html>", 6u);
      v8 = v7 == 0;
      if ( !v7 )
        v2 = lpString1 + 6;
      wcscat(v5, v2);
      if ( !v8 )
        wcscat(v5, L"</html>");
      if ( !String_3 )
        v5 = sub_418DC8(v5);
      v9 = 6 * wcslen(v5) + 9;
      v10 = (CHAR *)GlobalAlloc(0x40u, v9);
      if ( v10 )
      {
        if ( WideCharToMultiByte(0xFDE9u, 0, v5, -1, v10 + 3, v9 - 3, 0, 0) )
        {
          *v10 = -17;
          v10[1] = -69;
          v10[2] = -65;
        }
        else
        {
          *v10 = 0;
        }
      }
      free(v5);
      if ( CreateStreamOnHGlobal(v10, 1, &ppstm) >= 0 )
      {
        sub_418CBB(this[3], (int)ppstm);
        ppstm->lpVtbl->Release(ppstm);
      }
    }
  }
}

//----- (004191B6) --------------------------------------------------------
WCHAR *__stdcall sub_4191B6(wchar_t *String)
{
  wchar_t *v1; // esi
  size_t v2; // eax
  WCHAR *result; // eax
  WCHAR *v4; // edi
  WCHAR v5; // ax
  WCHAR v6; // ax
  char v7; // bl
  unsigned int i; // edx
  wchar_t v9; // cx
  int v10; // eax
  bool v11; // bl
  _WORD *v12; // edi
  _WORD *v13; // edi
  WCHAR *v15; // [esp+8h] [ebp-4h]
  char String_3; // [esp+17h] [ebp+Bh]

  v1 = String;
  v2 = wcslen(String);
  result = (WCHAR *)malloc(2 * v2 + 2);
  v15 = result;
  if ( result )
  {
    v4 = result;
    String_3 = sub_418D92(String);
    v5 = *v1;
    if ( *v1 )
    {
      while ( 1 )
      {
        if ( v5 )
          goto LABEL_4;
        while ( 1 )
        {
          do
          {
            v10 = sub_4119C7(v1, L"</p>", 4u);
            v11 = v10 == 0;
            if ( !v10 || !sub_4119C7(v1, L"<br>", 4u) )
            {
              *v4 = 13;
              v12 = v4 + 1;
              *v12 = 10;
              v4 = v12 + 1;
              if ( v11 )
              {
                *v4 = 13;
                v13 = v4 + 1;
                *v13 = 10;
                v4 = v13 + 1;
              }
            }
            *v4 = 0;
            if ( sub_4119C7(v1, L"<style>", 7u) )
            {
              while ( *v1 )
              {
                if ( *v1 == 62 )
                  goto LABEL_41;
                ++v1;
              }
              if ( *v1 != 62 )
                goto LABEL_42;
LABEL_41:
              ++v1;
            }
            else
            {
              if ( !*v1 )
                return v15;
              while ( sub_4119C7(v1++, L"</style>", 8u) )
              {
                if ( !*v1 )
                  goto LABEL_42;
              }
              v1 += 7;
            }
LABEL_42:
            v5 = *v1;
            if ( !*v1 )
              return v15;
LABEL_4:
            ;
          }
          while ( v5 == 60 );
          if ( String_3 && (v5 == 13 || v5 == 10) )
          {
            if ( v4 == v15 || *(v4 - 1) != 32 )
            {
              v6 = 32;
              goto LABEL_23;
            }
            goto LABEL_24;
          }
          v7 = 0;
          if ( String_3 && v5 == 38 )
          {
            for ( i = 0; i < 20; ++i )
            {
              v9 = v1[i];
              if ( !v9 )
                break;
              if ( v9 == 59 )
              {
                v1 = (wchar_t *)((char *)v1 + i * 2 + 2);
                v7 = 1;
              }
            }
            if ( v7 )
              break;
          }
          v6 = *v1;
          if ( *v1 )
          {
            if ( v6 != 32 || v4 == v15 || *(v4 - 1) != 32 )
LABEL_23:
              *v4++ = v6;
LABEL_24:
            ++v1;
            break;
          }
        }
        v5 = *v1;
      }
    }
    return v15;
  }
  return result;
}

//----- (00419338) --------------------------------------------------------
void __thiscall sub_419338(int this)
{
  bool v2; // zf

  if ( !*(_DWORD *)(this + 20) && !*(_BYTE *)(this + 32) )
    sub_41906D((int *)this, *(wchar_t **)(this + 16));
  v2 = *(_BYTE *)(this + 33) == 0;
  *(_BYTE *)(this + 32) = 1;
  if ( !v2 )
    sub_418BEC(*(_DWORD **)(this + 8), 1);
}

//----- (00419365) --------------------------------------------------------
int __stdcall sub_419365(int a1, void *a2, _DWORD *a3)
{
  return sub_418FA1(a1 - 12, a2, a3);
}

//----- (0041936F) --------------------------------------------------------
int __stdcall sub_41936F(int a1)
{
  return sub_41904C((_DWORD *)(a1 - 4));
}

//----- (00419383) --------------------------------------------------------
int __stdcall sub_419383(int a1)
{
  return sub_41904C((_DWORD *)(a1 - 12));
}

//----- (004193A1) --------------------------------------------------------
_DWORD *__thiscall sub_4193A1(_DWORD *this)
{
  this[5] = 0;
  this[6] = 0;
  *this = &off_42AE50;
  this[1] = &off_42AE14;
  this[2] = &off_42ADD8;
  this[3] = &off_42ADBC;
  this[4] = 1;
  memset(this + 7, 0, 0x10u);
  return this;
}
// 42ADBC: using guessed type int (__stdcall *off_42ADBC)(int, int, int);
// 42ADD8: using guessed type void *off_42ADD8;
// 42AE14: using guessed type void *off_42AE14;
// 42AE50: using guessed type int (__stdcall *off_42AE50)(int, void *Buf1, int);

//----- (004193E1) --------------------------------------------------------
void __thiscall sub_4193E1(int this, int a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  int (__stdcall ***v5)(_DWORD, void *, int); // eax
  int (__stdcall ***v6)(_DWORD, void *, int); // edi
  int v7; // ebp
  int v8; // eax
  int v9; // ecx

  *(_DWORD *)(this + 4) = a2;
  v3 = operator new(0x2Cu);
  if ( v3 )
    v4 = sub_4193A1(v3);
  else
    v4 = 0;
  *(_DWORD *)(this + 8) = v4;
  if ( v4 )
  {
    v4[5] = a2;
    sub_418A76(*(LPVOID **)(this + 8), L"Shell.Explorer");
    sub_418B7C(*(_DWORD **)(this + 8), 1);
    sub_418BEC(*(_DWORD **)(this + 8), 1);
    v5 = (int (__stdcall ***)(_DWORD, void *, int))sub_418C38(*(_DWORD **)(this + 8));
    v6 = v5;
    if ( !v5
      || (v7 = (**v5)(v5, &unk_42B138, this + 12),
          ((void (__stdcall *)(int (__stdcall ***)(_DWORD, void *, int)))(*v6)[2])(v6),
          v7 >= 0) )
    {
      v8 = *(_DWORD *)(this + 12);
      if ( v8 )
      {
        v9 = *(_DWORD *)(this + 20);
        *(_BYTE *)(this + 32) = 0;
        if ( v9 )
        {
          (*(void (__stdcall **)(int, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v8 + 44))(v8, v9, 0, 0, 0, 0);
        }
        else
        {
          (*(void (__stdcall **)(int, const wchar_t *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v8 + 44))(
            v8,
            L"about:blank",
            0,
            0,
            0,
            0);
          sub_419338(this);
        }
      }
    }
  }
}
// 42AFF8: using guessed type wchar_t aAboutBlank[12];

//----- (00419491) --------------------------------------------------------
LRESULT __stdcall sub_419491(HWND hWnd, UINT Msg, WPARAM wParam, LONG *lParam)
{
  int WindowLongW; // eax

  if ( Msg == 1 )
  {
    WindowLongW = GetWindowLongW(hWnd, -21);
    sub_4193E1(WindowLongW, (int)hWnd);
  }
  else if ( Msg == 129 )
  {
    SetWindowLongW(hWnd, -21, *lParam);
  }
  return DefWindowProcW(hWnd, Msg, wParam, (LPARAM)lParam);
}

//----- (004194DB) --------------------------------------------------------
ATOM __thiscall sub_4194DB(HINSTANCE *this, HINSTANCE a2)
{
  ATOM result; // ax
  WNDCLASSEXW v4; // [esp+Ch] [ebp-30h] BYREF

  v4.cbSize = 48;
  v4.style = 2088;
  v4.lpfnWndProc = (WNDPROC)sub_419491;
  v4.cbClsExtra = 0;
  v4.cbWndExtra = 0;
  v4.hInstance = a2;
  v4.hIcon = 0;
  v4.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  v4.hbrBackground = (HBRUSH)6;
  v4.lpszMenuName = 0;
  v4.lpszClassName = L"RarHtmlClassName";
  v4.hIconSm = 0;
  result = RegisterClassExW(&v4);
  *this = a2;
  return result;
}

//----- (00419542) --------------------------------------------------------
void __thiscall sub_419542(LPVOID lpParam, HINSTANCE a2, HWND hWnd, int a4, int a5, char X)
{
  HWND Parent; // eax
  int v8; // edi
  HWND v9; // eax
  HWND Window; // eax
  WCHAR *v11; // esi
  HINSTANCE v12; // [esp-8h] [ebp-24h]
  struct tagRECT Rect; // [esp+Ch] [ebp-10h] BYREF
  int Xa; // [esp+34h] [ebp+18h]

  *((_BYTE *)lpParam + 33) = X;
  ShowWindow(hWnd, 0);
  sub_4194DB((HINSTANCE *)lpParam, a2);
  *((_DWORD *)lpParam + 4) = a4;
  *((_DWORD *)lpParam + 5) = a5;
  GetWindowRect(hWnd, &Rect);
  Parent = GetParent(hWnd);
  MapWindowPoints(0, Parent, (LPPOINT)&Rect, 2u);
  if ( *((_DWORD *)lpParam + 1) )
    DestroyWindow(*((HWND *)lpParam + 1));
  v12 = *(HINSTANCE *)lpParam;
  Xa = Rect.left + 1;
  v8 = Rect.right - Rect.left - 2;
  v9 = GetParent(hWnd);
  Window = CreateWindowExW(
             0,
             L"RarHtmlClassName",
             0,
             0x40000000u,
             Xa,
             Rect.top,
             v8,
             Rect.bottom - Rect.top,
             v9,
             0,
             v12,
             lpParam);
  *((_DWORD *)lpParam + 1) = Window;
  if ( *((_DWORD *)lpParam + 3) )
  {
    if ( Window )
    {
      ShowWindow(Window, 5);
      UpdateWindow(*((HWND *)lpParam + 1));
    }
    if ( *((_DWORD *)lpParam + 7) > 0x64u )
      sub_418EC0((_DWORD **)lpParam);
  }
  else if ( hWnd && !*((_DWORD *)lpParam + 5) && *((_DWORD *)lpParam + 4) )
  {
    v11 = sub_4191B6(*((wchar_t **)lpParam + 4));
    if ( v11 )
    {
      ShowWindow(hWnd, 5);
      SetWindowTextW(hWnd, v11);
      free(v11);
    }
  }
}

//----- (00419655) --------------------------------------------------------
char __stdcall sub_419655(char a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl
  int v8; // ecx
  int v10; // [esp+4h] [ebp-8h] BYREF
  LPVOID ppv; // [esp+8h] [ebp-4h] BYREF

  v7 = 0;
  if ( CoCreateInstance(&rclsid, 0, 1u, &stru_42B0A8, &ppv) >= 0 )
  {
    if ( (**(int (__stdcall ***)(LPVOID, void *, int *))ppv)(ppv, &unk_42B148, &v10) >= 0 )
    {
      if ( a1 )
        (*(void (__stdcall **)(int, int, int))(*(_DWORD *)v10 + 20))(v10, a3, 2);
      (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 80))(ppv, a2);
      if ( a5 )
        (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 28))(ppv, a5);
      v8 = *(_DWORD *)ppv;
      if ( a6 )
        (*(void (__stdcall **)(LPVOID, int, _DWORD))(v8 + 68))(ppv, a6, 0);
      else
        (*(void (__stdcall **)(LPVOID, const WCHAR *, _DWORD))(v8 + 68))(ppv, &String, 0);
      if ( a7 )
        (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 44))(ppv, a7);
      if ( a4 )
        (*(void (__stdcall **)(LPVOID, int))(*(_DWORD *)ppv + 36))(ppv, a4);
      if ( (*(int (__stdcall **)(int, int, int))(*(_DWORD *)v10 + 24))(v10, a3, 1) >= 0 )
        v7 = 1;
      (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
    }
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  }
  return v7;
}

//----- (0041972D) --------------------------------------------------------
BOOL __stdcall sub_41972D(LPCWSTR lpPathName)
{
  return SetCurrentDirectoryW(lpPathName);
}

//----- (00419740) --------------------------------------------------------
BOOL __stdcall sub_419740(LPWSTR lpBuffer, DWORD nBufferLength)
{
  return GetCurrentDirectoryW(nBufferLength, lpBuffer) != 0;
}

//----- (00419757) --------------------------------------------------------
HWND __stdcall sub_419757(HWND hWnd)
{
  HWND v1; // edi
  HWND result; // eax
  WCHAR ClassName[80]; // [esp+4h] [ebp-A0h] BYREF

  v1 = hWnd;
  result = (HWND)GetClassNameW(hWnd, ClassName, 80);
  if ( result )
  {
    result = (HWND)sub_4119A6(ClassName, &szClass);
    if ( result )
    {
      result = FindWindowExW(hWnd, 0, &szClass, 0);
      v1 = result;
    }
  }
  if ( v1 )
    return (HWND)SHAutoComplete(v1, 0x10u);
  return result;
}

//----- (004197B0) --------------------------------------------------------
HANDLE __stdcall sub_4197B0(HANDLE h, int a2, int ho)
{
  LONG v3; // esi
  int v4; // ebx
  bool v5; // sf
  LPVOID v6; // eax
  HANDLE result; // eax
  BITMAPINFO pbmi; // [esp+34h] [ebp-68h] BYREF
  char pv[4]; // [esp+60h] [ebp-3Ch] BYREF
  int v10; // [esp+64h] [ebp-38h]
  int v11; // [esp+68h] [ebp-34h]
  int v12[4]; // [esp+78h] [ebp-24h] BYREF
  void *ppvBits; // [esp+88h] [ebp-14h] BYREF
  void *v14; // [esp+8Ch] [ebp-10h]
  int v15; // [esp+90h] [ebp-Ch] BYREF
  int v16; // [esp+94h] [ebp-8h] BYREF
  LPVOID ppv; // [esp+98h] [ebp-4h] BYREF

  GetObjectW(h, 24, pv);
  v3 = a2;
  v4 = ho;
  if ( a2 * v11 / v10 < ho )
    v4 = a2 * v11 / v10;
  if ( CoCreateInstance(&stru_42B168, 0, 1u, &stru_42B060, &ppv) < 0 )
    return h;
  v5 = (*(int (__stdcall **)(LPVOID, HANDLE, _DWORD, int, int *))(*(_DWORD *)ppv + 84))(ppv, h, 0, 2, &v16) < 0;
  v6 = ppv;
  if ( v5 )
    goto LABEL_5;
  v15 = 0;
  if ( (*(int (__stdcall **)(LPVOID, int *))(*(_DWORD *)ppv + 40))(ppv, &v15) < 0 )
  {
LABEL_7:
    (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
    v6 = ppv;
LABEL_5:
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)v6 + 8))(v6);
    return h;
  }
  if ( (*(int (__stdcall **)(int, int, void *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v15 + 32))(
         v15,
         v16,
         &unk_42B178,
         0,
         0,
         COERCE_UNSIGNED_INT64(0.0),
         HIDWORD(COERCE_UNSIGNED_INT64(0.0)),
         0) < 0 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
    goto LABEL_7;
  }
  memset(&pbmi, 0, sizeof(pbmi));
  pbmi.bmiHeader.biHeight = -v4;
  pbmi.bmiHeader.biPlanes = 1;
  pbmi.bmiHeader.biBitCount = 32;
  pbmi.bmiHeader.biSize = 40;
  pbmi.bmiHeader.biWidth = v3;
  pbmi.bmiHeader.biCompression = 0;
  v14 = 0;
  ho = (int)CreateDIBSection(0, &pbmi, 0, &ppvBits, 0, 0);
  if ( (ho != 0 ? 0 : -2147024882) >= 0 )
  {
    (*(void (__stdcall **)(LPVOID, int *))(*(_DWORD *)ppv + 44))(ppv, &a2);
    (*(void (__stdcall **)(int, int, LONG, int, int))(*(_DWORD *)a2 + 32))(a2, v16, v3, v4, 3);
    v12[0] = 0;
    v12[1] = 0;
    v12[2] = v3;
    v12[3] = v4;
    if ( (*(int (__stdcall **)(int, int *, int, int, void *))(*(_DWORD *)a2 + 28))(
           a2,
           v12,
           4 * v3,
           4 * v4 * v3,
           ppvBits) < 0 )
      DeleteObject((HGDIOBJ)ho);
    else
      v14 = (void *)ho;
    (*(void (__stdcall **)(int))(*(_DWORD *)a2 + 8))(a2);
  }
  (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
  (*(void (__stdcall **)(int))(*(_DWORD *)v15 + 8))(v15);
  (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  result = v14;
  if ( !v14 )
    return h;
  return result;
}
// 4197B0: using guessed type char pv[4];

//----- (00419958) --------------------------------------------------------
HMODULE *__thiscall sub_419958(HMODULE *this)
{
  INITCOMMONCONTROLSEX picce; // [esp+8h] [ebp-8h] BYREF

  this[1] = 0;
  *this = 0;
  *this = LoadLibraryW(L"riched32.dll");
  this[1] = LoadLibraryW(L"riched20.dll");
  OleInitialize(0);
  picce.dwSize = 8;
  picce.dwICC = 2047;
  InitCommonControlsEx(&picce);
  SHGetMalloc(&ppMalloc);
  return this;
}

//----- (004199B2) --------------------------------------------------------
void __thiscall sub_4199B2(HMODULE *this)
{
  HMODULE v2; // esi

  if ( *this )
    FreeLibrary(*this);
  v2 = this[1];
  if ( v2 )
    FreeLibrary(v2);
  ppMalloc->lpVtbl->Release(ppMalloc);
  OleUninitialize();
}

//----- (0041C239) --------------------------------------------------------
void __thiscall sub_41C239(struct type_info *this)
{
  *(_DWORD *)this = &off_42B1B8;
  type_info::_Type_info_dtor(this);
}
// 42B1B8: using guessed type int (__thiscall *off_42B1B8)(void *, char);

//----- (0041C249) --------------------------------------------------------
struct type_info *__thiscall sub_41C249(struct type_info *this, char a2)
{
  sub_41C239(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0041D17D) --------------------------------------------------------
void __thiscall sub_41D17D(void *this)
{
  bool v1; // zf

  v1 = *((_DWORD *)this + 2) == 0;
  *(_DWORD *)this = &std::exception::`vftable';
  if ( !v1 )
    free(*((void **)this + 1));
}
// 42B1C0: using guessed type void *std::exception::`vftable';

//----- (0041D1A0) --------------------------------------------------------
void *__thiscall sub_41D1A0(void *this, char a2)
{
  sub_41D17D(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0041D425) --------------------------------------------------------
std::exception *__thiscall sub_41D425(std::exception *this, char *a2)
{
  std::exception::exception(this, (const char *const *)&a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 42B1F0: using guessed type void *std::bad_exception::`vftable';

//----- (0041D443) --------------------------------------------------------
void __thiscall sub_41D443(void *this)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_41D17D(this);
}
// 42B1F0: using guessed type void *std::bad_exception::`vftable';

//----- (0041D44E) --------------------------------------------------------
_DWORD *__thiscall sub_41D44E(_DWORD *this, char a2)
{
  *this = &std::bad_exception::`vftable';
  sub_41D17D(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 42B1F0: using guessed type void *std::bad_exception::`vftable';

//----- (0041DFDB) --------------------------------------------------------
std::exception *__thiscall sub_41DFDB(std::exception *this, struct std::exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 42B1F0: using guessed type void *std::bad_exception::`vftable';

//----- (0041F68C) --------------------------------------------------------
int __cdecl sub_41F68C(int a1)
{
  int result; // eax

  result = a1;
  dword_44EE5C = a1;
  return result;
}
// 44EE5C: using guessed type int dword_44EE5C;

//----- (0041F85B) --------------------------------------------------------
int sub_41F85B()
{
  dword_4508D8 = _get_sse2_info();
  return 0;
}
// 41F7F9: using guessed type int _get_sse2_info(void);
// 4508D8: using guessed type int dword_4508D8;

//----- (0041F9CC) --------------------------------------------------------
int __cdecl sub_41F9CC(int a1)
{
  int result; // eax

  result = a1;
  dword_44EE64 = a1;
  return result;
}
// 44EE64: using guessed type int dword_44EE64;

//----- (00420E88) --------------------------------------------------------
void **sub_420E88()
{
  return &off_42F540;
}
// 42F540: using guessed type void *off_42F540;

//----- (00422FA5) --------------------------------------------------------
int sub_422FA5()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (00423831) --------------------------------------------------------
void *sub_423831()
{
  return &unk_42CE4C;
}

//----- (00423857) --------------------------------------------------------
void __cdecl sub_423857()
{
  ;
}

//----- (00423CAF) --------------------------------------------------------
int __cdecl sub_423CAF(int a1)
{
  int result; // eax

  result = a1;
  dword_44F63C = a1;
  return result;
}
// 44F63C: using guessed type int dword_44F63C;

//----- (004248F9) --------------------------------------------------------
void sub_4248F9()
{
  dword_44F78C = 0;
}
// 44F78C: using guessed type int dword_44F78C;

//----- (00424DD8) --------------------------------------------------------
int sub_424DD8()
{
  return _decode_pointer(dword_44F64C);
}
// 41E168: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 44F64C: using guessed type int dword_44F64C;

//----- (00424F95) --------------------------------------------------------
int __cdecl sub_424F95(int a1)
{
  int result; // eax

  result = a1;
  dword_44F658 = a1;
  return result;
}
// 44F658: using guessed type int dword_44F658;

//----- (00424FA4) --------------------------------------------------------
int __cdecl sub_424FA4(int a1)
{
  int result; // eax

  result = a1;
  dword_44F664 = a1;
  return result;
}
// 44F664: using guessed type int dword_44F664;

//----- (004251DC) --------------------------------------------------------
int sub_4251DC()
{
  return flsall(1);
}
// 425102: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (004251E5) --------------------------------------------------------
int __cdecl sub_4251E5(int a1, int a2, int a3)
{
  int v3; // ebx
  HMODULE LibraryA; // eax
  HMODULE v5; // edi
  int (__stdcall *MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationA)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v11)(void); // esi
  int (__stdcall *v12)(int, int, char *, int, char *); // eax
  int (__stdcall *v13)(int, int, char *, int, char *); // edi
  int v14; // eax
  int (*v15)(void); // eax
  int (__stdcall *v16)(int); // eax
  int (__stdcall *v17)(int, int, int, int); // eax
  char v19[12]; // [esp+10h] [ebp-14h] BYREF
  char v20[4]; // [esp+1Ch] [ebp-8h] BYREF
  int v21; // [esp+20h] [ebp-4h]

  v21 = 0;
  v3 = _encoded_null();
  if ( !dword_44F6A8 )
  {
    LibraryA = LoadLibraryA("USER32.DLL");
    v5 = LibraryA;
    if ( !LibraryA )
      return 0;
    MessageBoxA = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
    if ( !MessageBoxA )
      return 0;
    dword_44F6A8 = _encode_pointer(MessageBoxA);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v5, "GetActiveWindow");
    dword_44F6AC = _encode_pointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v5, "GetLastActivePopup");
    dword_44F6B0 = _encode_pointer(GetLastActivePopup);
    GetUserObjectInformationA = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                          v5,
                                                                                          "GetUserObjectInformationA");
    dword_44F6B8 = _encode_pointer(GetUserObjectInformationA);
    if ( dword_44F6B8 )
    {
      GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v5, "GetProcessWindowStation");
      dword_44F6B4 = _encode_pointer(GetProcessWindowStation);
    }
  }
  if ( dword_44F6B4 == v3
    || dword_44F6B8 == v3
    || (v11 = (int (*)(void))_decode_pointer(dword_44F6B4),
        v12 = (int (__stdcall *)(int, int, char *, int, char *))_decode_pointer(dword_44F6B8),
        v13 = v12,
        !v11)
    || !v12
    || (v14 = v11()) != 0 && v13(v14, 1, v19, 12, v20) && (v19[8] & 1) != 0 )
  {
    if ( dword_44F6AC != v3 )
    {
      v15 = (int (*)(void))_decode_pointer(dword_44F6AC);
      if ( v15 )
      {
        v21 = v15();
        if ( v21 )
        {
          if ( dword_44F6B0 != v3 )
          {
            v16 = (int (__stdcall *)(int))_decode_pointer(dword_44F6B0);
            if ( v16 )
              v21 = v16(v21);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v17 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_44F6A8);
  if ( v17 )
    return v17(v21, a1, a2, a3);
  return 0;
}
// 41E0ED: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 41E15F: using guessed type int _encoded_null(void);
// 41E168: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 44F6A8: using guessed type int dword_44F6A8;
// 44F6AC: using guessed type int dword_44F6AC;
// 44F6B0: using guessed type int dword_44F6B0;
// 44F6B4: using guessed type int dword_44F6B4;
// 44F6B8: using guessed type int dword_44F6B8;
// 4251E5: using guessed type char var_8[4];

//----- (00425E1D) --------------------------------------------------------
int __cdecl sub_425E1D(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_426D8C(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 427814: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 425E1D: using guessed type char var_28[4];
// 425E1D: using guessed type unsigned __int16 var_10[6];

//----- (00425EC5) --------------------------------------------------------
int __cdecl sub_425EC5(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_4272D0(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 427814: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 425EC5: using guessed type char var_28[4];
// 425EC5: using guessed type unsigned __int16 var_10[6];

//----- (00426D8C) --------------------------------------------------------
int __cdecl sub_426D8C(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // esi
  int *v9; // edi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // esi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  unsigned int v20; // esi
  char v21; // cl
  int v22; // edx
  int *v23; // ecx
  int v24; // esi
  int v25; // eax
  int *v26; // ebx
  bool j; // zf
  int v28; // eax
  unsigned int v29; // edx
  int *v30; // ecx
  unsigned int v31; // edi
  int k; // ecx
  int *v33; // ecx
  unsigned int v34; // esi
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int *v38; // ebx
  unsigned int v39; // esi
  char v40; // cl
  int v41; // edx
  int *v42; // ecx
  int v43; // eax
  int v44; // edx
  int *v45; // ebx
  unsigned int v46; // esi
  char v47; // cl
  int v48; // edx
  int *v49; // ecx
  int v50; // eax
  int v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  int *v54; // ecx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // [esp+8h] [ebp-2Ch]
  int v58; // [esp+Ch] [ebp-28h]
  int v59; // [esp+10h] [ebp-24h]
  int v60; // [esp+14h] [ebp-20h] BYREF
  int v61; // [esp+18h] [ebp-1Ch]
  int v62; // [esp+1Ch] [ebp-18h] BYREF
  int v63; // [esp+20h] [ebp-14h]
  int v64; // [esp+24h] [ebp-10h]
  int v65; // [esp+28h] [ebp-Ch]
  int v66; // [esp+2Ch] [ebp-8h]
  int v67; // [esp+30h] [ebp-4h]
  int v68; // [esp+3Ch] [ebp+8h]
  unsigned int v69; // [esp+3Ch] [ebp+8h]
  int v70; // [esp+3Ch] [ebp+8h]
  int v71; // [esp+3Ch] [ebp+8h]
  int v72; // [esp+3Ch] [ebp+8h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+3Ch] [ebp+8h]

  v2 = a1[5];
  v63 = v2 & 0x8000;
  v60 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v61 = *(_DWORD *)(a1 + 1);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_430200 - 1;
    v64 = v3;
    v65 = dword_430200 / 32;
    v9 = &v60 + dword_430200 / 32;
    v66 = 31 - dword_430200 % 32;
    if ( ((1 << (31 - dword_430200 % 32)) & *v9) != 0 )
    {
      v10 = v65;
      for ( i = (~(-1 << (31 - dword_430200 % 32)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_22;
      }
      v12 = v8 / 32;
      v67 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v60 + v8 / 32;
      v69 = v13 + *v14;
      if ( v69 >= *v14 )
      {
        v15 = v69 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v69;
        if ( v12 < 0 || !v67 )
          break;
        v67 = 0;
        v14 = &v60 + v12;
        v16 = *v14 + 1;
        v69 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v9 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_4301FC - dword_430200 )
    {
      if ( v3 > dword_4301FC )
      {
        if ( v3 < dword_4301F8 )
        {
          v60 &= ~0x80000000;
          v5 = dword_43020C + v3;
          v50 = dword_430204 / 32;
          v51 = dword_430204 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_430204 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & v52;
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 0x80000000;
          v43 = dword_430204 / 32;
          v44 = dword_430204 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_430204 % 32;
          do
          {
            v45 = &v60 + v73;
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_43020C + dword_4301F8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_4301FC - v64) / 32;
      v62 = v59;
      v18 = (dword_4301FC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = &v60 + v70;
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_430200 - 1;
      v25 = dword_430200 / 32;
      v65 = dword_430200 / 32;
      v26 = &v60 + dword_430200 / 32;
      v64 = 31 - dword_430200 % 32;
      if ( ((1 << (31 - dword_430200 % 32)) & *v26) != 0 )
      {
        for ( j = (~(-1 << (31 - dword_430200 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = &v60 + v24 / 32;
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = &v60 + v28;
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || *v33 == -1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_430204 + 1) / 32;
      v37 = (dword_430204 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = &v60 + v72;
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_430204));
  if ( dword_430208 == 64 )
  {
    v56 = v61;
    a2[1] = v55;
    *a2 = v56;
  }
  else if ( dword_430208 == 32 )
  {
    *a2 = v55;
  }
  return result;
}
// 4301F8: using guessed type int dword_4301F8;
// 4301FC: using guessed type int dword_4301FC;
// 430200: using guessed type int dword_430200;
// 430204: using guessed type int dword_430204;
// 430208: using guessed type int dword_430208;
// 43020C: using guessed type int dword_43020C;

//----- (004272D0) --------------------------------------------------------
int __cdecl sub_4272D0(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // esi
  int *v9; // edi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // esi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  unsigned int v20; // esi
  char v21; // cl
  int v22; // edx
  int *v23; // ecx
  int v24; // esi
  int v25; // eax
  int *v26; // ebx
  bool j; // zf
  int v28; // eax
  unsigned int v29; // edx
  int *v30; // ecx
  unsigned int v31; // edi
  int k; // ecx
  int *v33; // ecx
  unsigned int v34; // esi
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int *v38; // ebx
  unsigned int v39; // esi
  char v40; // cl
  int v41; // edx
  int *v42; // ecx
  int v43; // eax
  int v44; // edx
  int *v45; // ebx
  unsigned int v46; // esi
  char v47; // cl
  int v48; // edx
  int *v49; // ecx
  int v50; // eax
  int v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  int *v54; // ecx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // [esp+8h] [ebp-2Ch]
  int v58; // [esp+Ch] [ebp-28h]
  int v59; // [esp+10h] [ebp-24h]
  int v60; // [esp+14h] [ebp-20h] BYREF
  int v61; // [esp+18h] [ebp-1Ch]
  int v62; // [esp+1Ch] [ebp-18h] BYREF
  int v63; // [esp+20h] [ebp-14h]
  int v64; // [esp+24h] [ebp-10h]
  int v65; // [esp+28h] [ebp-Ch]
  int v66; // [esp+2Ch] [ebp-8h]
  int v67; // [esp+30h] [ebp-4h]
  int v68; // [esp+3Ch] [ebp+8h]
  unsigned int v69; // [esp+3Ch] [ebp+8h]
  int v70; // [esp+3Ch] [ebp+8h]
  int v71; // [esp+3Ch] [ebp+8h]
  int v72; // [esp+3Ch] [ebp+8h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+3Ch] [ebp+8h]

  v2 = a1[5];
  v63 = v2 & 0x8000;
  v60 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v61 = *(_DWORD *)(a1 + 1);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_430218 - 1;
    v64 = v3;
    v65 = dword_430218 / 32;
    v9 = &v60 + dword_430218 / 32;
    v66 = 31 - dword_430218 % 32;
    if ( ((1 << (31 - dword_430218 % 32)) & *v9) != 0 )
    {
      v10 = v65;
      for ( i = (~(-1 << (31 - dword_430218 % 32)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_22;
      }
      v12 = v8 / 32;
      v67 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v60 + v8 / 32;
      v69 = v13 + *v14;
      if ( v69 >= *v14 )
      {
        v15 = v69 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v69;
        if ( v12 < 0 || !v67 )
          break;
        v67 = 0;
        v14 = &v60 + v12;
        v16 = *v14 + 1;
        v69 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v9 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_430214 - dword_430218 )
    {
      if ( v3 > dword_430214 )
      {
        if ( v3 < dword_430210 )
        {
          v60 &= ~0x80000000;
          v5 = dword_430224 + v3;
          v50 = dword_43021C / 32;
          v51 = dword_43021C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_43021C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & v52;
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 0x80000000;
          v43 = dword_43021C / 32;
          v44 = dword_43021C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_43021C % 32;
          do
          {
            v45 = &v60 + v73;
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_430224 + dword_430210;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_430214 - v64) / 32;
      v62 = v59;
      v18 = (dword_430214 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = &v60 + v70;
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_430218 - 1;
      v25 = dword_430218 / 32;
      v65 = dword_430218 / 32;
      v26 = &v60 + dword_430218 / 32;
      v64 = 31 - dword_430218 % 32;
      if ( ((1 << (31 - dword_430218 % 32)) & *v26) != 0 )
      {
        for ( j = (~(-1 << (31 - dword_430218 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = &v60 + v24 / 32;
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = &v60 + v28;
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || *v33 == -1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_43021C + 1) / 32;
      v37 = (dword_43021C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = &v60 + v72;
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_43021C));
  if ( dword_430220 == 64 )
  {
    v56 = v61;
    a2[1] = v55;
    *a2 = v56;
  }
  else if ( dword_430220 == 32 )
  {
    *a2 = v55;
  }
  return result;
}
// 430210: using guessed type int dword_430210;
// 430214: using guessed type int dword_430214;
// 430218: using guessed type int dword_430218;
// 43021C: using guessed type int dword_43021C;
// 430220: using guessed type int dword_430220;
// 430224: using guessed type int dword_430224;

//----- (004294E0) --------------------------------------------------------
bool sub_4294E0()
{
  return sub_411A88(byte_44EA70);
}
// 44EA70: using guessed type _BYTE byte_44EA70[264];

//----- (00429515) --------------------------------------------------------
int sub_429515()
{
  return sub_40CD93(&unk_44C2D8);
}
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);

//----- (0042951F) --------------------------------------------------------
int sub_42951F()
{
  return sub_40CD93(&unk_442D32);
}
// 40CD93: using guessed type int __thiscall sub_40CD93(_DWORD);

//----- (00429529) --------------------------------------------------------
int sub_429529()
{
  sub_401105((void **)&dword_442E38[9489]);
  sub_401105((void **)&dword_442E38[9466]);
  sub_401105((void **)&dword_442E38[9443]);
  sub_401105((void **)&dword_442E38[9420]);
  sub_401105((void **)&dword_442E38[9397]);
  return sub_409CFD((void **)dword_442E38);
}
// 442E38: using guessed type _DWORD dword_442E38[5203];

//----- (00429533) --------------------------------------------------------
void sub_429533()
{
  DeleteCriticalSection(&CriticalSection);
}

//----- (0042953F) --------------------------------------------------------
void __cdecl sub_42953F()
{
  dword_44ECBC[0] = &off_42B18C;
  sub_41D17D(dword_44ECBC);
}
// 42B18C: using guessed type int (__thiscall *off_42B18C)(void *, char);
// 44ECBC: using guessed type _DWORD dword_44ECBC[3];

// nfuncs=897 queued=562 decompiled=562 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 562 function(s)"
